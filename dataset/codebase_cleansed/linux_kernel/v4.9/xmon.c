static inline long plapr_set_ciabr(unsigned long ciabr) {return 0; }\r\nstatic inline void dump_opal_msglog(void)\r\n{\r\nprintf("Machine is not running OPAL firmware.\n");\r\n}\r\nstatic inline void sync(void)\r\n{\r\nasm volatile("sync; isync");\r\n}\r\nstatic inline void store_inst(void *p)\r\n{\r\nasm volatile ("dcbst 0,%0; sync; icbi 0,%0; isync" : : "r" (p));\r\n}\r\nstatic inline void cflush(void *p)\r\n{\r\nasm volatile ("dcbf 0,%0; icbi 0,%0" : : "r" (p));\r\n}\r\nstatic inline void cinval(void *p)\r\n{\r\nasm volatile ("dcbi 0,%0; icbi 0,%0" : : "r" (p));\r\n}\r\nstatic void write_ciabr(unsigned long ciabr)\r\n{\r\nif (!cpu_has_feature(CPU_FTR_ARCH_207S))\r\nreturn;\r\nif (cpu_has_feature(CPU_FTR_HVMODE)) {\r\nmtspr(SPRN_CIABR, ciabr);\r\nreturn;\r\n}\r\nplapr_set_ciabr(ciabr);\r\n}\r\nstatic void set_ciabr(unsigned long addr)\r\n{\r\naddr &= ~CIABR_PRIV;\r\nif (cpu_has_feature(CPU_FTR_HVMODE))\r\naddr |= CIABR_PRIV_HYPER;\r\nelse\r\naddr |= CIABR_PRIV_SUPER;\r\nwrite_ciabr(addr);\r\n}\r\nstatic inline void disable_surveillance(void)\r\n{\r\n#ifdef CONFIG_PPC_PSERIES\r\nstatic struct rtas_args args;\r\nint token;\r\ntoken = rtas_token("set-indicator");\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\nreturn;\r\nrtas_call_unlocked(&args, token, 3, 1, NULL, SURVEILLANCE_TOKEN, 0, 0);\r\n#endif\r\n}\r\nstatic void get_output_lock(void)\r\n{\r\nint me = smp_processor_id() + 0x100;\r\nint last_speaker = 0, prev;\r\nlong timeout;\r\nif (xmon_speaker == me)\r\nreturn;\r\nfor (;;) {\r\nlast_speaker = cmpxchg(&xmon_speaker, 0, me);\r\nif (last_speaker == 0)\r\nreturn;\r\ntimeout = 10000;\r\nwhile (xmon_speaker == last_speaker) {\r\nif (--timeout > 0) {\r\nudelay(100);\r\ncontinue;\r\n}\r\nprev = cmpxchg(&xmon_speaker, last_speaker, me);\r\nif (prev == last_speaker)\r\nreturn;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void release_output_lock(void)\r\n{\r\nxmon_speaker = 0;\r\n}\r\nint cpus_are_in_xmon(void)\r\n{\r\nreturn !cpumask_empty(&cpus_in_xmon);\r\n}\r\nstatic inline int unrecoverable_excp(struct pt_regs *regs)\r\n{\r\n#if defined(CONFIG_4xx) || defined(CONFIG_PPC_BOOK3E)\r\nreturn 0;\r\n#else\r\nreturn ((regs->msr & MSR_RI) == 0);\r\n#endif\r\n}\r\nstatic int xmon_core(struct pt_regs *regs, int fromipi)\r\n{\r\nint cmd = 0;\r\nstruct bpt *bp;\r\nlong recurse_jmp[JMP_BUF_LEN];\r\nunsigned long offset;\r\nunsigned long flags;\r\n#ifdef CONFIG_SMP\r\nint cpu;\r\nint secondary;\r\nunsigned long timeout;\r\n#endif\r\nlocal_irq_save(flags);\r\nhard_irq_disable();\r\nbp = in_breakpoint_table(regs->nip, &offset);\r\nif (bp != NULL) {\r\nregs->nip = bp->address + offset;\r\natomic_dec(&bp->ref_count);\r\n}\r\nremove_cpu_bpts();\r\n#ifdef CONFIG_SMP\r\ncpu = smp_processor_id();\r\nif (cpumask_test_cpu(cpu, &cpus_in_xmon)) {\r\nif (catch_spr_faults)\r\nlongjmp(bus_error_jmp, 1);\r\nget_output_lock();\r\nexcprint(regs);\r\nprintf("cpu 0x%x: Exception %lx %s in xmon, "\r\n"returning to main loop\n",\r\ncpu, regs->trap, getvecname(TRAP(regs)));\r\nrelease_output_lock();\r\nlongjmp(xmon_fault_jmp[cpu], 1);\r\n}\r\nif (setjmp(recurse_jmp) != 0) {\r\nif (!in_xmon || !xmon_gate) {\r\nget_output_lock();\r\nprintf("xmon: WARNING: bad recursive fault "\r\n"on cpu 0x%x\n", cpu);\r\nrelease_output_lock();\r\ngoto waiting;\r\n}\r\nsecondary = !(xmon_taken && cpu == xmon_owner);\r\ngoto cmdloop;\r\n}\r\nxmon_fault_jmp[cpu] = recurse_jmp;\r\nbp = NULL;\r\nif ((regs->msr & (MSR_IR|MSR_PR|MSR_64BIT)) == (MSR_IR|MSR_64BIT))\r\nbp = at_breakpoint(regs->nip);\r\nif (bp || unrecoverable_excp(regs))\r\nfromipi = 0;\r\nif (!fromipi) {\r\nget_output_lock();\r\nexcprint(regs);\r\nif (bp) {\r\nprintf("cpu 0x%x stopped at breakpoint 0x%lx (",\r\ncpu, BP_NUM(bp));\r\nxmon_print_symbol(regs->nip, " ", ")\n");\r\n}\r\nif (unrecoverable_excp(regs))\r\nprintf("WARNING: exception is not recoverable, "\r\n"can't continue\n");\r\nrelease_output_lock();\r\n}\r\ncpumask_set_cpu(cpu, &cpus_in_xmon);\r\nwaiting:\r\nsecondary = 1;\r\nwhile (secondary && !xmon_gate) {\r\nif (in_xmon == 0) {\r\nif (fromipi)\r\ngoto leave;\r\nsecondary = test_and_set_bit(0, &in_xmon);\r\n}\r\nbarrier();\r\n}\r\nif (!secondary && !xmon_gate) {\r\nint ncpus = num_online_cpus();\r\nxmon_owner = cpu;\r\nmb();\r\nif (ncpus > 1) {\r\nsmp_send_debugger_break();\r\nfor (timeout = 100000000; timeout != 0; --timeout) {\r\nif (cpumask_weight(&cpus_in_xmon) >= ncpus)\r\nbreak;\r\nbarrier();\r\n}\r\n}\r\nremove_bpts();\r\ndisable_surveillance();\r\nif (bp || TRAP(regs) == 0xd00)\r\nppc_inst_dump(regs->nip, 1, 0);\r\nprintf("enter ? for help\n");\r\nmb();\r\nxmon_gate = 1;\r\nbarrier();\r\n}\r\ncmdloop:\r\nwhile (in_xmon) {\r\nif (secondary) {\r\nif (cpu == xmon_owner) {\r\nif (!test_and_set_bit(0, &xmon_taken)) {\r\nsecondary = 0;\r\ncontinue;\r\n}\r\nwhile (cpu == xmon_owner)\r\nbarrier();\r\n}\r\nbarrier();\r\n} else {\r\ncmd = cmds(regs);\r\nif (cmd != 0) {\r\ninsert_bpts();\r\nxmon_gate = 0;\r\nwmb();\r\nin_xmon = 0;\r\nbreak;\r\n}\r\nsecondary = 1;\r\n}\r\n}\r\nleave:\r\ncpumask_clear_cpu(cpu, &cpus_in_xmon);\r\nxmon_fault_jmp[cpu] = NULL;\r\n#else\r\nif (in_xmon) {\r\nprintf("Exception %lx %s in xmon, returning to main loop\n",\r\nregs->trap, getvecname(TRAP(regs)));\r\nlongjmp(xmon_fault_jmp[0], 1);\r\n}\r\nif (setjmp(recurse_jmp) == 0) {\r\nxmon_fault_jmp[0] = recurse_jmp;\r\nin_xmon = 1;\r\nexcprint(regs);\r\nbp = at_breakpoint(regs->nip);\r\nif (bp) {\r\nprintf("Stopped at breakpoint %lx (", BP_NUM(bp));\r\nxmon_print_symbol(regs->nip, " ", ")\n");\r\n}\r\nif (unrecoverable_excp(regs))\r\nprintf("WARNING: exception is not recoverable, "\r\n"can't continue\n");\r\nremove_bpts();\r\ndisable_surveillance();\r\nif (bp || TRAP(regs) == 0xd00)\r\nppc_inst_dump(regs->nip, 1, 0);\r\nprintf("enter ? for help\n");\r\n}\r\ncmd = cmds(regs);\r\ninsert_bpts();\r\nin_xmon = 0;\r\n#endif\r\n#ifdef CONFIG_BOOKE\r\nif (regs->msr & MSR_DE) {\r\nbp = at_breakpoint(regs->nip);\r\nif (bp != NULL) {\r\nregs->nip = (unsigned long) &bp->instr[0];\r\natomic_inc(&bp->ref_count);\r\n}\r\n}\r\n#else\r\nif ((regs->msr & (MSR_IR|MSR_PR|MSR_64BIT)) == (MSR_IR|MSR_64BIT)) {\r\nbp = at_breakpoint(regs->nip);\r\nif (bp != NULL) {\r\nint stepped = emulate_step(regs, bp->instr[0]);\r\nif (stepped == 0) {\r\nregs->nip = (unsigned long) &bp->instr[0];\r\natomic_inc(&bp->ref_count);\r\n} else if (stepped < 0) {\r\nprintf("Couldn't single-step %s instruction\n",\r\n(IS_RFID(bp->instr[0])? "rfid": "mtmsrd"));\r\n}\r\n}\r\n}\r\n#endif\r\ninsert_cpu_bpts();\r\ntouch_nmi_watchdog();\r\nlocal_irq_restore(flags);\r\nreturn cmd != 'X' && cmd != EOF;\r\n}\r\nint xmon(struct pt_regs *excp)\r\n{\r\nstruct pt_regs regs;\r\nif (excp == NULL) {\r\nppc_save_regs(&regs);\r\nexcp = &regs;\r\n}\r\nreturn xmon_core(excp, 0);\r\n}\r\nirqreturn_t xmon_irq(int irq, void *d)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nprintf("Keyboard interrupt\n");\r\nxmon(get_irq_regs());\r\nlocal_irq_restore(flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xmon_bpt(struct pt_regs *regs)\r\n{\r\nstruct bpt *bp;\r\nunsigned long offset;\r\nif ((regs->msr & (MSR_IR|MSR_PR|MSR_64BIT)) != (MSR_IR|MSR_64BIT))\r\nreturn 0;\r\nbp = in_breakpoint_table(regs->nip, &offset);\r\nif (bp != NULL && offset == 4) {\r\nregs->nip = bp->address + 4;\r\natomic_dec(&bp->ref_count);\r\nreturn 1;\r\n}\r\nbp = at_breakpoint(regs->nip);\r\nif (!bp)\r\nreturn 0;\r\nxmon_core(regs, 0);\r\nreturn 1;\r\n}\r\nstatic int xmon_sstep(struct pt_regs *regs)\r\n{\r\nif (user_mode(regs))\r\nreturn 0;\r\nxmon_core(regs, 0);\r\nreturn 1;\r\n}\r\nstatic int xmon_break_match(struct pt_regs *regs)\r\n{\r\nif ((regs->msr & (MSR_IR|MSR_PR|MSR_64BIT)) != (MSR_IR|MSR_64BIT))\r\nreturn 0;\r\nif (dabr.enabled == 0)\r\nreturn 0;\r\nxmon_core(regs, 0);\r\nreturn 1;\r\n}\r\nstatic int xmon_iabr_match(struct pt_regs *regs)\r\n{\r\nif ((regs->msr & (MSR_IR|MSR_PR|MSR_64BIT)) != (MSR_IR|MSR_64BIT))\r\nreturn 0;\r\nif (iabr == NULL)\r\nreturn 0;\r\nxmon_core(regs, 0);\r\nreturn 1;\r\n}\r\nstatic int xmon_ipi(struct pt_regs *regs)\r\n{\r\n#ifdef CONFIG_SMP\r\nif (in_xmon && !cpumask_test_cpu(smp_processor_id(), &cpus_in_xmon))\r\nxmon_core(regs, 1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int xmon_fault_handler(struct pt_regs *regs)\r\n{\r\nstruct bpt *bp;\r\nunsigned long offset;\r\nif (in_xmon && catch_memory_errors)\r\nhandle_fault(regs);\r\nif ((regs->msr & (MSR_IR|MSR_PR|MSR_64BIT)) == (MSR_IR|MSR_64BIT)) {\r\nbp = in_breakpoint_table(regs->nip, &offset);\r\nif (bp != NULL) {\r\nregs->nip = bp->address + offset;\r\natomic_dec(&bp->ref_count);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct bpt *at_breakpoint(unsigned long pc)\r\n{\r\nint i;\r\nstruct bpt *bp;\r\nbp = bpts;\r\nfor (i = 0; i < NBPTS; ++i, ++bp)\r\nif (bp->enabled && pc == bp->address)\r\nreturn bp;\r\nreturn NULL;\r\n}\r\nstatic struct bpt *in_breakpoint_table(unsigned long nip, unsigned long *offp)\r\n{\r\nunsigned long off;\r\noff = nip - (unsigned long) bpts;\r\nif (off >= sizeof(bpts))\r\nreturn NULL;\r\noff %= sizeof(struct bpt);\r\nif (off != offsetof(struct bpt, instr[0])\r\n&& off != offsetof(struct bpt, instr[1]))\r\nreturn NULL;\r\n*offp = off - offsetof(struct bpt, instr[0]);\r\nreturn (struct bpt *) (nip - off);\r\n}\r\nstatic struct bpt *new_breakpoint(unsigned long a)\r\n{\r\nstruct bpt *bp;\r\na &= ~3UL;\r\nbp = at_breakpoint(a);\r\nif (bp)\r\nreturn bp;\r\nfor (bp = bpts; bp < &bpts[NBPTS]; ++bp) {\r\nif (!bp->enabled && atomic_read(&bp->ref_count) == 0) {\r\nbp->address = a;\r\nbp->instr[1] = bpinstr;\r\nstore_inst(&bp->instr[1]);\r\nreturn bp;\r\n}\r\n}\r\nprintf("Sorry, no free breakpoints. Please clear one first.\n");\r\nreturn NULL;\r\n}\r\nstatic void insert_bpts(void)\r\n{\r\nint i;\r\nstruct bpt *bp;\r\nbp = bpts;\r\nfor (i = 0; i < NBPTS; ++i, ++bp) {\r\nif ((bp->enabled & (BP_TRAP|BP_CIABR)) == 0)\r\ncontinue;\r\nif (mread(bp->address, &bp->instr[0], 4) != 4) {\r\nprintf("Couldn't read instruction at %lx, "\r\n"disabling breakpoint there\n", bp->address);\r\nbp->enabled = 0;\r\ncontinue;\r\n}\r\nif (IS_MTMSRD(bp->instr[0]) || IS_RFID(bp->instr[0])) {\r\nprintf("Breakpoint at %lx is on an mtmsrd or rfid "\r\n"instruction, disabling it\n", bp->address);\r\nbp->enabled = 0;\r\ncontinue;\r\n}\r\nstore_inst(&bp->instr[0]);\r\nif (bp->enabled & BP_CIABR)\r\ncontinue;\r\nif (mwrite(bp->address, &bpinstr, 4) != 4) {\r\nprintf("Couldn't write instruction at %lx, "\r\n"disabling breakpoint there\n", bp->address);\r\nbp->enabled &= ~BP_TRAP;\r\ncontinue;\r\n}\r\nstore_inst((void *)bp->address);\r\n}\r\n}\r\nstatic void insert_cpu_bpts(void)\r\n{\r\nstruct arch_hw_breakpoint brk;\r\nif (dabr.enabled) {\r\nbrk.address = dabr.address;\r\nbrk.type = (dabr.enabled & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\r\nbrk.len = 8;\r\n__set_breakpoint(&brk);\r\n}\r\nif (iabr)\r\nset_ciabr(iabr->address);\r\n}\r\nstatic void remove_bpts(void)\r\n{\r\nint i;\r\nstruct bpt *bp;\r\nunsigned instr;\r\nbp = bpts;\r\nfor (i = 0; i < NBPTS; ++i, ++bp) {\r\nif ((bp->enabled & (BP_TRAP|BP_CIABR)) != BP_TRAP)\r\ncontinue;\r\nif (mread(bp->address, &instr, 4) == 4\r\n&& instr == bpinstr\r\n&& mwrite(bp->address, &bp->instr, 4) != 4)\r\nprintf("Couldn't remove breakpoint at %lx\n",\r\nbp->address);\r\nelse\r\nstore_inst((void *)bp->address);\r\n}\r\n}\r\nstatic void remove_cpu_bpts(void)\r\n{\r\nhw_breakpoint_disable();\r\nwrite_ciabr(0);\r\n}\r\nstatic void set_lpp_cmd(void)\r\n{\r\nunsigned long lpp;\r\nif (!scanhex(&lpp)) {\r\nprintf("Invalid number.\n");\r\nlpp = 0;\r\n}\r\nxmon_set_pagination_lpp(lpp);\r\n}\r\nstatic int\r\ncmds(struct pt_regs *excp)\r\n{\r\nint cmd = 0;\r\nlast_cmd = NULL;\r\nxmon_regs = excp;\r\nif (!xmon_no_auto_backtrace) {\r\nxmon_no_auto_backtrace = 1;\r\nxmon_show_stack(excp->gpr[1], excp->link, excp->nip);\r\n}\r\nfor(;;) {\r\n#ifdef CONFIG_SMP\r\nprintf("%x:", smp_processor_id());\r\n#endif\r\nprintf("mon> ");\r\nflush_input();\r\ntermch = 0;\r\ncmd = skipbl();\r\nif( cmd == '\n' ) {\r\nif (last_cmd == NULL)\r\ncontinue;\r\ntake_input(last_cmd);\r\nlast_cmd = NULL;\r\ncmd = inchar();\r\n}\r\nswitch (cmd) {\r\ncase 'm':\r\ncmd = inchar();\r\nswitch (cmd) {\r\ncase 'm':\r\ncase 's':\r\ncase 'd':\r\nmemops(cmd);\r\nbreak;\r\ncase 'l':\r\nmemlocate();\r\nbreak;\r\ncase 'z':\r\nmemzcan();\r\nbreak;\r\ncase 'i':\r\nshow_mem(0);\r\nbreak;\r\ndefault:\r\ntermch = cmd;\r\nmemex();\r\n}\r\nbreak;\r\ncase 'd':\r\ndump();\r\nbreak;\r\ncase 'l':\r\nsymbol_lookup();\r\nbreak;\r\ncase 'r':\r\nprregs(excp);\r\nbreak;\r\ncase 'e':\r\nexcprint(excp);\r\nbreak;\r\ncase 'S':\r\nsuper_regs();\r\nbreak;\r\ncase 't':\r\nbacktrace(excp);\r\nbreak;\r\ncase 'f':\r\ncacheflush();\r\nbreak;\r\ncase 's':\r\nif (do_spu_cmd() == 0)\r\nbreak;\r\nif (do_step(excp))\r\nreturn cmd;\r\nbreak;\r\ncase 'x':\r\ncase 'X':\r\nreturn cmd;\r\ncase EOF:\r\nprintf(" <no input ...>\n");\r\nmdelay(2000);\r\nreturn cmd;\r\ncase '?':\r\nxmon_puts(help_string);\r\nbreak;\r\ncase '#':\r\nset_lpp_cmd();\r\nbreak;\r\ncase 'b':\r\nbpt_cmds();\r\nbreak;\r\ncase 'C':\r\ncsum();\r\nbreak;\r\ncase 'c':\r\nif (cpu_cmd())\r\nreturn 0;\r\nbreak;\r\ncase 'z':\r\nbootcmds();\r\nbreak;\r\ncase 'p':\r\nproccall();\r\nbreak;\r\ncase 'P':\r\nshow_tasks();\r\nbreak;\r\n#ifdef CONFIG_PPC_STD_MMU\r\ncase 'u':\r\ndump_segments();\r\nbreak;\r\n#elif defined(CONFIG_44x)\r\ncase 'u':\r\ndump_tlb_44x();\r\nbreak;\r\n#elif defined(CONFIG_PPC_BOOK3E)\r\ncase 'u':\r\ndump_tlb_book3e();\r\nbreak;\r\n#endif\r\ndefault:\r\nprintf("Unrecognized command: ");\r\ndo {\r\nif (' ' < cmd && cmd <= '~')\r\nputchar(cmd);\r\nelse\r\nprintf("\\x%x", cmd);\r\ncmd = inchar();\r\n} while (cmd != '\n');\r\nprintf(" (type ? for help)\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int do_step(struct pt_regs *regs)\r\n{\r\nregs->msr |= MSR_DE;\r\nmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM);\r\nreturn 1;\r\n}\r\nstatic int do_step(struct pt_regs *regs)\r\n{\r\nunsigned int instr;\r\nint stepped;\r\nif ((regs->msr & (MSR_64BIT|MSR_PR|MSR_IR)) == (MSR_64BIT|MSR_IR)) {\r\nif (mread(regs->nip, &instr, 4) == 4) {\r\nstepped = emulate_step(regs, instr);\r\nif (stepped < 0) {\r\nprintf("Couldn't single-step %s instruction\n",\r\n(IS_RFID(instr)? "rfid": "mtmsrd"));\r\nreturn 0;\r\n}\r\nif (stepped > 0) {\r\nregs->trap = 0xd00 | (regs->trap & 1);\r\nprintf("stepped to ");\r\nxmon_print_symbol(regs->nip, " ", "\n");\r\nppc_inst_dump(regs->nip, 1, 0);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nregs->msr |= MSR_SE;\r\nreturn 1;\r\n}\r\nstatic void bootcmds(void)\r\n{\r\nint cmd;\r\ncmd = inchar();\r\nif (cmd == 'r')\r\nppc_md.restart(NULL);\r\nelse if (cmd == 'h')\r\nppc_md.halt();\r\nelse if (cmd == 'p')\r\nif (pm_power_off)\r\npm_power_off();\r\n}\r\nstatic int cpu_cmd(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nunsigned long cpu, first_cpu, last_cpu;\r\nint timeout;\r\nif (!scanhex(&cpu)) {\r\nprintf("cpus stopped:");\r\nlast_cpu = first_cpu = NR_CPUS;\r\nfor_each_possible_cpu(cpu) {\r\nif (cpumask_test_cpu(cpu, &cpus_in_xmon)) {\r\nif (cpu == last_cpu + 1) {\r\nlast_cpu = cpu;\r\n} else {\r\nif (last_cpu != first_cpu)\r\nprintf("-0x%lx", last_cpu);\r\nlast_cpu = first_cpu = cpu;\r\nprintf(" 0x%lx", cpu);\r\n}\r\n}\r\n}\r\nif (last_cpu != first_cpu)\r\nprintf("-0x%lx", last_cpu);\r\nprintf("\n");\r\nreturn 0;\r\n}\r\nif (!cpumask_test_cpu(cpu, &cpus_in_xmon)) {\r\nprintf("cpu 0x%x isn't in xmon\n", cpu);\r\nreturn 0;\r\n}\r\nxmon_taken = 0;\r\nmb();\r\nxmon_owner = cpu;\r\ntimeout = 10000000;\r\nwhile (!xmon_taken) {\r\nif (--timeout == 0) {\r\nif (test_and_set_bit(0, &xmon_taken))\r\nbreak;\r\nmb();\r\nxmon_owner = smp_processor_id();\r\nprintf("cpu 0x%x didn't take control\n", cpu);\r\nreturn 0;\r\n}\r\nbarrier();\r\n}\r\nreturn 1;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void\r\ncsum(void)\r\n{\r\nunsigned int i;\r\nunsigned short fcs;\r\nunsigned char v;\r\nif (!scanhex(&adrs))\r\nreturn;\r\nif (!scanhex(&ncsum))\r\nreturn;\r\nfcs = 0xffff;\r\nfor (i = 0; i < ncsum; ++i) {\r\nif (mread(adrs+i, &v, 1) == 0) {\r\nprintf("csum stopped at "REG"\n", adrs+i);\r\nbreak;\r\n}\r\nfcs = FCS(fcs, v);\r\n}\r\nprintf("%x\n", fcs);\r\n}\r\nstatic long check_bp_loc(unsigned long addr)\r\n{\r\nunsigned int instr;\r\naddr &= ~3;\r\nif (!is_kernel_addr(addr)) {\r\nprintf("Breakpoints may only be placed at kernel addresses\n");\r\nreturn 0;\r\n}\r\nif (!mread(addr, &instr, sizeof(instr))) {\r\nprintf("Can't read instruction at address %lx\n", addr);\r\nreturn 0;\r\n}\r\nif (IS_MTMSRD(instr) || IS_RFID(instr)) {\r\nprintf("Breakpoints may not be placed on mtmsrd or rfid "\r\n"instructions\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nbpt_cmds(void)\r\n{\r\nint cmd;\r\nunsigned long a;\r\nint mode, i;\r\nstruct bpt *bp;\r\nconst char badaddr[] = "Only kernel addresses are permitted "\r\n"for breakpoints\n";\r\ncmd = inchar();\r\nswitch (cmd) {\r\n#ifndef CONFIG_8xx\r\ncase 'd':\r\nmode = 7;\r\ncmd = inchar();\r\nif (cmd == 'r')\r\nmode = 5;\r\nelse if (cmd == 'w')\r\nmode = 6;\r\nelse\r\ntermch = cmd;\r\ndabr.address = 0;\r\ndabr.enabled = 0;\r\nif (scanhex(&dabr.address)) {\r\nif (!is_kernel_addr(dabr.address)) {\r\nprintf(badaddr);\r\nbreak;\r\n}\r\ndabr.address &= ~HW_BRK_TYPE_DABR;\r\ndabr.enabled = mode | BP_DABR;\r\n}\r\nbreak;\r\ncase 'i':\r\nif (!cpu_has_feature(CPU_FTR_ARCH_207S)) {\r\nprintf("Hardware instruction breakpoint "\r\n"not supported on this cpu\n");\r\nbreak;\r\n}\r\nif (iabr) {\r\niabr->enabled &= ~BP_CIABR;\r\niabr = NULL;\r\n}\r\nif (!scanhex(&a))\r\nbreak;\r\nif (!check_bp_loc(a))\r\nbreak;\r\nbp = new_breakpoint(a);\r\nif (bp != NULL) {\r\nbp->enabled |= BP_CIABR;\r\niabr = bp;\r\n}\r\nbreak;\r\n#endif\r\ncase 'c':\r\nif (!scanhex(&a)) {\r\nfor (i = 0; i < NBPTS; ++i)\r\nbpts[i].enabled = 0;\r\niabr = NULL;\r\ndabr.enabled = 0;\r\nprintf("All breakpoints cleared\n");\r\nbreak;\r\n}\r\nif (a <= NBPTS && a >= 1) {\r\nbp = &bpts[a-1];\r\n} else {\r\nbp = at_breakpoint(a);\r\nif (bp == NULL) {\r\nprintf("No breakpoint at %lx\n", a);\r\nbreak;\r\n}\r\n}\r\nprintf("Cleared breakpoint %lx (", BP_NUM(bp));\r\nxmon_print_symbol(bp->address, " ", ")\n");\r\nbp->enabled = 0;\r\nbreak;\r\ndefault:\r\ntermch = cmd;\r\ncmd = skipbl();\r\nif (cmd == '?') {\r\nprintf(breakpoint_help_string);\r\nbreak;\r\n}\r\ntermch = cmd;\r\nif (!scanhex(&a)) {\r\nprintf(" type address\n");\r\nif (dabr.enabled) {\r\nprintf(" data "REG" [", dabr.address);\r\nif (dabr.enabled & 1)\r\nprintf("r");\r\nif (dabr.enabled & 2)\r\nprintf("w");\r\nprintf("]\n");\r\n}\r\nfor (bp = bpts; bp < &bpts[NBPTS]; ++bp) {\r\nif (!bp->enabled)\r\ncontinue;\r\nprintf("%2x %s ", BP_NUM(bp),\r\n(bp->enabled & BP_CIABR) ? "inst": "trap");\r\nxmon_print_symbol(bp->address, " ", "\n");\r\n}\r\nbreak;\r\n}\r\nif (!check_bp_loc(a))\r\nbreak;\r\nbp = new_breakpoint(a);\r\nif (bp != NULL)\r\nbp->enabled |= BP_TRAP;\r\nbreak;\r\n}\r\n}\r\nstatic\r\nconst char *getvecname(unsigned long vec)\r\n{\r\nchar *ret;\r\nswitch (vec) {\r\ncase 0x100: ret = "(System Reset)"; break;\r\ncase 0x200: ret = "(Machine Check)"; break;\r\ncase 0x300: ret = "(Data Access)"; break;\r\ncase 0x380: ret = "(Data SLB Access)"; break;\r\ncase 0x400: ret = "(Instruction Access)"; break;\r\ncase 0x480: ret = "(Instruction SLB Access)"; break;\r\ncase 0x500: ret = "(Hardware Interrupt)"; break;\r\ncase 0x600: ret = "(Alignment)"; break;\r\ncase 0x700: ret = "(Program Check)"; break;\r\ncase 0x800: ret = "(FPU Unavailable)"; break;\r\ncase 0x900: ret = "(Decrementer)"; break;\r\ncase 0x980: ret = "(Hypervisor Decrementer)"; break;\r\ncase 0xa00: ret = "(Doorbell)"; break;\r\ncase 0xc00: ret = "(System Call)"; break;\r\ncase 0xd00: ret = "(Single Step)"; break;\r\ncase 0xe40: ret = "(Emulation Assist)"; break;\r\ncase 0xe60: ret = "(HMI)"; break;\r\ncase 0xe80: ret = "(Hypervisor Doorbell)"; break;\r\ncase 0xf00: ret = "(Performance Monitor)"; break;\r\ncase 0xf20: ret = "(Altivec Unavailable)"; break;\r\ncase 0x1300: ret = "(Instruction Breakpoint)"; break;\r\ncase 0x1500: ret = "(Denormalisation)"; break;\r\ncase 0x1700: ret = "(Altivec Assist)"; break;\r\ndefault: ret = "";\r\n}\r\nreturn ret;\r\n}\r\nstatic void get_function_bounds(unsigned long pc, unsigned long *startp,\r\nunsigned long *endp)\r\n{\r\nunsigned long size, offset;\r\nconst char *name;\r\n*startp = *endp = 0;\r\nif (pc == 0)\r\nreturn;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\nname = kallsyms_lookup(pc, &size, &offset, NULL, tmpstr);\r\nif (name != NULL) {\r\n*startp = pc - offset;\r\n*endp = pc - offset + size;\r\n}\r\nsync();\r\n}\r\ncatch_memory_errors = 0;\r\n}\r\nstatic void xmon_show_stack(unsigned long sp, unsigned long lr,\r\nunsigned long pc)\r\n{\r\nint max_to_print = 64;\r\nunsigned long ip;\r\nunsigned long newsp;\r\nunsigned long marker;\r\nstruct pt_regs regs;\r\nwhile (max_to_print--) {\r\nif (sp < PAGE_OFFSET) {\r\nif (sp != 0)\r\nprintf("SP (%lx) is in userspace\n", sp);\r\nbreak;\r\n}\r\nif (!mread(sp + LRSAVE_OFFSET, &ip, sizeof(unsigned long))\r\n|| !mread(sp, &newsp, sizeof(unsigned long))) {\r\nprintf("Couldn't read stack frame at %lx\n", sp);\r\nbreak;\r\n}\r\nif ((pc | lr) != 0) {\r\nunsigned long fnstart, fnend;\r\nunsigned long nextip;\r\nint printip = 1;\r\nget_function_bounds(pc, &fnstart, &fnend);\r\nnextip = 0;\r\nif (newsp > sp)\r\nmread(newsp + LRSAVE_OFFSET, &nextip,\r\nsizeof(unsigned long));\r\nif (lr == ip) {\r\nif (lr < PAGE_OFFSET\r\n|| (fnstart <= lr && lr < fnend))\r\nprintip = 0;\r\n} else if (lr == nextip) {\r\nprintip = 0;\r\n} else if (lr >= PAGE_OFFSET\r\n&& !(fnstart <= lr && lr < fnend)) {\r\nprintf("[link register ] ");\r\nxmon_print_symbol(lr, " ", "\n");\r\n}\r\nif (printip) {\r\nprintf("["REG"] ", sp);\r\nxmon_print_symbol(ip, " ", " (unreliable)\n");\r\n}\r\npc = lr = 0;\r\n} else {\r\nprintf("["REG"] ", sp);\r\nxmon_print_symbol(ip, " ", "\n");\r\n}\r\nif (mread(sp + MARKER_OFFSET, &marker, sizeof(unsigned long))\r\n&& marker == STACK_FRAME_REGS_MARKER) {\r\nif (mread(sp + STACK_FRAME_OVERHEAD, &regs, sizeof(regs))\r\n!= sizeof(regs)) {\r\nprintf("Couldn't read registers at %lx\n",\r\nsp + STACK_FRAME_OVERHEAD);\r\nbreak;\r\n}\r\nprintf("--- Exception: %lx %s at ", regs.trap,\r\ngetvecname(TRAP(&regs)));\r\npc = regs.nip;\r\nlr = regs.link;\r\nxmon_print_symbol(pc, " ", "\n");\r\n}\r\nif (newsp == 0)\r\nbreak;\r\nsp = newsp;\r\n}\r\n}\r\nstatic void backtrace(struct pt_regs *excp)\r\n{\r\nunsigned long sp;\r\nif (scanhex(&sp))\r\nxmon_show_stack(sp, 0, 0);\r\nelse\r\nxmon_show_stack(excp->gpr[1], excp->link, excp->nip);\r\nscannl();\r\n}\r\nstatic void print_bug_trap(struct pt_regs *regs)\r\n{\r\n#ifdef CONFIG_BUG\r\nconst struct bug_entry *bug;\r\nunsigned long addr;\r\nif (regs->msr & MSR_PR)\r\nreturn;\r\naddr = regs->nip;\r\nif (addr < PAGE_OFFSET)\r\nreturn;\r\nbug = find_bug(regs->nip);\r\nif (bug == NULL)\r\nreturn;\r\nif (is_warning_bug(bug))\r\nreturn;\r\n#ifdef CONFIG_DEBUG_BUGVERBOSE\r\nprintf("kernel BUG at %s:%u!\n",\r\nbug->file, bug->line);\r\n#else\r\nprintf("kernel BUG at %p!\n", (void *)bug->bug_addr);\r\n#endif\r\n#endif\r\n}\r\nstatic void excprint(struct pt_regs *fp)\r\n{\r\nunsigned long trap;\r\n#ifdef CONFIG_SMP\r\nprintf("cpu 0x%x: ", smp_processor_id());\r\n#endif\r\ntrap = TRAP(fp);\r\nprintf("Vector: %lx %s at [%lx]\n", fp->trap, getvecname(trap), fp);\r\nprintf(" pc: ");\r\nxmon_print_symbol(fp->nip, ": ", "\n");\r\nprintf(" lr: ", fp->link);\r\nxmon_print_symbol(fp->link, ": ", "\n");\r\nprintf(" sp: %lx\n", fp->gpr[1]);\r\nprintf(" msr: %lx\n", fp->msr);\r\nif (trap == 0x300 || trap == 0x380 || trap == 0x600 || trap == 0x200) {\r\nprintf(" dar: %lx\n", fp->dar);\r\nif (trap != 0x380)\r\nprintf(" dsisr: %lx\n", fp->dsisr);\r\n}\r\nprintf(" current = 0x%lx\n", current);\r\n#ifdef CONFIG_PPC64\r\nprintf(" paca = 0x%lx\t softe: %d\t irq_happened: 0x%02x\n",\r\nlocal_paca, local_paca->soft_enabled, local_paca->irq_happened);\r\n#endif\r\nif (current) {\r\nprintf(" pid = %ld, comm = %s\n",\r\ncurrent->pid, current->comm);\r\n}\r\nif (trap == 0x700)\r\nprint_bug_trap(fp);\r\nprintf(linux_banner);\r\n}\r\nstatic void prregs(struct pt_regs *fp)\r\n{\r\nint n, trap;\r\nunsigned long base;\r\nstruct pt_regs regs;\r\nif (scanhex(&base)) {\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\nregs = *(struct pt_regs *)base;\r\nsync();\r\n__delay(200);\r\n} else {\r\ncatch_memory_errors = 0;\r\nprintf("*** Error reading registers from "REG"\n",\r\nbase);\r\nreturn;\r\n}\r\ncatch_memory_errors = 0;\r\nfp = &regs;\r\n}\r\n#ifdef CONFIG_PPC64\r\nif (FULL_REGS(fp)) {\r\nfor (n = 0; n < 16; ++n)\r\nprintf("R%.2ld = "REG" R%.2ld = "REG"\n",\r\nn, fp->gpr[n], n+16, fp->gpr[n+16]);\r\n} else {\r\nfor (n = 0; n < 7; ++n)\r\nprintf("R%.2ld = "REG" R%.2ld = "REG"\n",\r\nn, fp->gpr[n], n+7, fp->gpr[n+7]);\r\n}\r\n#else\r\nfor (n = 0; n < 32; ++n) {\r\nprintf("R%.2d = %.8x%s", n, fp->gpr[n],\r\n(n & 3) == 3? "\n": " ");\r\nif (n == 12 && !FULL_REGS(fp)) {\r\nprintf("\n");\r\nbreak;\r\n}\r\n}\r\n#endif\r\nprintf("pc = ");\r\nxmon_print_symbol(fp->nip, " ", "\n");\r\nif (TRAP(fp) != 0xc00 && cpu_has_feature(CPU_FTR_CFAR)) {\r\nprintf("cfar= ");\r\nxmon_print_symbol(fp->orig_gpr3, " ", "\n");\r\n}\r\nprintf("lr = ");\r\nxmon_print_symbol(fp->link, " ", "\n");\r\nprintf("msr = "REG" cr = %.8lx\n", fp->msr, fp->ccr);\r\nprintf("ctr = "REG" xer = "REG" trap = %4lx\n",\r\nfp->ctr, fp->xer, fp->trap);\r\ntrap = TRAP(fp);\r\nif (trap == 0x300 || trap == 0x380 || trap == 0x600)\r\nprintf("dar = "REG" dsisr = %.8lx\n", fp->dar, fp->dsisr);\r\n}\r\nstatic void cacheflush(void)\r\n{\r\nint cmd;\r\nunsigned long nflush;\r\ncmd = inchar();\r\nif (cmd != 'i')\r\ntermch = cmd;\r\nscanhex((void *)&adrs);\r\nif (termch != '\n')\r\ntermch = 0;\r\nnflush = 1;\r\nscanhex(&nflush);\r\nnflush = (nflush + L1_CACHE_BYTES - 1) / L1_CACHE_BYTES;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\nif (cmd != 'i') {\r\nfor (; nflush > 0; --nflush, adrs += L1_CACHE_BYTES)\r\ncflush((void *) adrs);\r\n} else {\r\nfor (; nflush > 0; --nflush, adrs += L1_CACHE_BYTES)\r\ncinval((void *) adrs);\r\n}\r\nsync();\r\n__delay(200);\r\n}\r\ncatch_memory_errors = 0;\r\n}\r\nstatic int\r\nread_spr(int n, unsigned long *vp)\r\n{\r\nunsigned long ret = -1UL;\r\nint ok = 0;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_spr_faults = 1;\r\nsync();\r\nret = xmon_mfspr(n, *vp);\r\nsync();\r\n*vp = ret;\r\nok = 1;\r\n}\r\ncatch_spr_faults = 0;\r\nreturn ok;\r\n}\r\nstatic void\r\nwrite_spr(int n, unsigned long val)\r\n{\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_spr_faults = 1;\r\nsync();\r\nxmon_mtspr(n, val);\r\nsync();\r\n} else {\r\nprintf("SPR 0x%03x (%4d) Faulted during write\n", n, n);\r\n}\r\ncatch_spr_faults = 0;\r\n}\r\nstatic void dump_206_sprs(void)\r\n{\r\n#ifdef CONFIG_PPC64\r\nif (!cpu_has_feature(CPU_FTR_ARCH_206))\r\nreturn;\r\nprintf("srr0 = %.16x srr1 = %.16x dsisr = %.8x\n",\r\nmfspr(SPRN_SRR0), mfspr(SPRN_SRR1), mfspr(SPRN_DSISR));\r\nprintf("dscr = %.16x ppr = %.16x pir = %.8x\n",\r\nmfspr(SPRN_DSCR), mfspr(SPRN_PPR), mfspr(SPRN_PIR));\r\nif (!(mfmsr() & MSR_HV))\r\nreturn;\r\nprintf("sdr1 = %.16x hdar = %.16x hdsisr = %.8x\n",\r\nmfspr(SPRN_SDR1), mfspr(SPRN_HDAR), mfspr(SPRN_HDSISR));\r\nprintf("hsrr0 = %.16x hsrr1 = %.16x hdec = %.8x\n",\r\nmfspr(SPRN_HSRR0), mfspr(SPRN_HSRR1), mfspr(SPRN_HDEC));\r\nprintf("lpcr = %.16x pcr = %.16x lpidr = %.8x\n",\r\nmfspr(SPRN_LPCR), mfspr(SPRN_PCR), mfspr(SPRN_LPID));\r\nprintf("hsprg0 = %.16x hsprg1 = %.16x\n",\r\nmfspr(SPRN_HSPRG0), mfspr(SPRN_HSPRG1));\r\nprintf("dabr = %.16x dabrx = %.16x\n",\r\nmfspr(SPRN_DABR), mfspr(SPRN_DABRX));\r\n#endif\r\n}\r\nstatic void dump_207_sprs(void)\r\n{\r\n#ifdef CONFIG_PPC64\r\nunsigned long msr;\r\nif (!cpu_has_feature(CPU_FTR_ARCH_207S))\r\nreturn;\r\nprintf("dpdes = %.16x tir = %.16x cir = %.8x\n",\r\nmfspr(SPRN_DPDES), mfspr(SPRN_TIR), mfspr(SPRN_CIR));\r\nprintf("fscr = %.16x tar = %.16x pspb = %.8x\n",\r\nmfspr(SPRN_FSCR), mfspr(SPRN_TAR), mfspr(SPRN_PSPB));\r\nmsr = mfmsr();\r\nif (msr & MSR_TM) {\r\nprintf("tfhar = %.16x tfiar = %.16x texasr = %.16x\n",\r\nmfspr(SPRN_TFHAR), mfspr(SPRN_TFIAR),\r\nmfspr(SPRN_TEXASR));\r\n}\r\nprintf("mmcr0 = %.16x mmcr1 = %.16x mmcr2 = %.16x\n",\r\nmfspr(SPRN_MMCR0), mfspr(SPRN_MMCR1), mfspr(SPRN_MMCR2));\r\nprintf("pmc1 = %.8x pmc2 = %.8x pmc3 = %.8x pmc4 = %.8x\n",\r\nmfspr(SPRN_PMC1), mfspr(SPRN_PMC2),\r\nmfspr(SPRN_PMC3), mfspr(SPRN_PMC4));\r\nprintf("mmcra = %.16x siar = %.16x pmc5 = %.8x\n",\r\nmfspr(SPRN_MMCRA), mfspr(SPRN_SIAR), mfspr(SPRN_PMC5));\r\nprintf("sdar = %.16x sier = %.16x pmc6 = %.8x\n",\r\nmfspr(SPRN_SDAR), mfspr(SPRN_SIER), mfspr(SPRN_PMC6));\r\nprintf("ebbhr = %.16x ebbrr = %.16x bescr = %.16x\n",\r\nmfspr(SPRN_EBBHR), mfspr(SPRN_EBBRR), mfspr(SPRN_BESCR));\r\nif (!(msr & MSR_HV))\r\nreturn;\r\nprintf("hfscr = %.16x dhdes = %.16x rpr = %.16x\n",\r\nmfspr(SPRN_HFSCR), mfspr(SPRN_DHDES), mfspr(SPRN_RPR));\r\nprintf("dawr = %.16x dawrx = %.16x ciabr = %.16x\n",\r\nmfspr(SPRN_DAWR), mfspr(SPRN_DAWRX), mfspr(SPRN_CIABR));\r\n#endif\r\n}\r\nstatic void dump_one_spr(int spr, bool show_unimplemented)\r\n{\r\nunsigned long val;\r\nval = 0xdeadbeef;\r\nif (!read_spr(spr, &val)) {\r\nprintf("SPR 0x%03x (%4d) Faulted during read\n", spr, spr);\r\nreturn;\r\n}\r\nif (val == 0xdeadbeef) {\r\nval = 0x0badcafe;\r\nif (!read_spr(spr, &val)) {\r\nprintf("SPR 0x%03x (%4d) Faulted during read\n", spr, spr);\r\nreturn;\r\n}\r\nif (val == 0x0badcafe) {\r\nif (show_unimplemented)\r\nprintf("SPR 0x%03x (%4d) Unimplemented\n", spr, spr);\r\nreturn;\r\n}\r\n}\r\nprintf("SPR 0x%03x (%4d) = 0x%lx\n", spr, spr, val);\r\n}\r\nstatic void super_regs(void)\r\n{\r\nstatic unsigned long regno;\r\nint cmd;\r\nint spr;\r\ncmd = skipbl();\r\nswitch (cmd) {\r\ncase '\n': {\r\nunsigned long sp, toc;\r\nasm("mr %0,1" : "=r" (sp) :);\r\nasm("mr %0,2" : "=r" (toc) :);\r\nprintf("msr = "REG" sprg0 = "REG"\n",\r\nmfmsr(), mfspr(SPRN_SPRG0));\r\nprintf("pvr = "REG" sprg1 = "REG"\n",\r\nmfspr(SPRN_PVR), mfspr(SPRN_SPRG1));\r\nprintf("dec = "REG" sprg2 = "REG"\n",\r\nmfspr(SPRN_DEC), mfspr(SPRN_SPRG2));\r\nprintf("sp = "REG" sprg3 = "REG"\n", sp, mfspr(SPRN_SPRG3));\r\nprintf("toc = "REG" dar = "REG"\n", toc, mfspr(SPRN_DAR));\r\ndump_206_sprs();\r\ndump_207_sprs();\r\nreturn;\r\n}\r\ncase 'w': {\r\nunsigned long val;\r\nscanhex(&regno);\r\nval = 0;\r\nread_spr(regno, &val);\r\nscanhex(&val);\r\nwrite_spr(regno, val);\r\ndump_one_spr(regno, true);\r\nbreak;\r\n}\r\ncase 'r':\r\nscanhex(&regno);\r\ndump_one_spr(regno, true);\r\nbreak;\r\ncase 'a':\r\nfor (spr = 1; spr < 1024; ++spr)\r\ndump_one_spr(spr, false);\r\nbreak;\r\n}\r\nscannl();\r\n}\r\nstatic int\r\nmread(unsigned long adrs, void *buf, int size)\r\n{\r\nvolatile int n;\r\nchar *p, *q;\r\nn = 0;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\np = (char *)adrs;\r\nq = (char *)buf;\r\nswitch (size) {\r\ncase 2:\r\n*(u16 *)q = *(u16 *)p;\r\nbreak;\r\ncase 4:\r\n*(u32 *)q = *(u32 *)p;\r\nbreak;\r\ncase 8:\r\n*(u64 *)q = *(u64 *)p;\r\nbreak;\r\ndefault:\r\nfor( ; n < size; ++n) {\r\n*q++ = *p++;\r\nsync();\r\n}\r\n}\r\nsync();\r\n__delay(200);\r\nn = size;\r\n}\r\ncatch_memory_errors = 0;\r\nreturn n;\r\n}\r\nstatic int\r\nmwrite(unsigned long adrs, void *buf, int size)\r\n{\r\nvolatile int n;\r\nchar *p, *q;\r\nn = 0;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\np = (char *) adrs;\r\nq = (char *) buf;\r\nswitch (size) {\r\ncase 2:\r\n*(u16 *)p = *(u16 *)q;\r\nbreak;\r\ncase 4:\r\n*(u32 *)p = *(u32 *)q;\r\nbreak;\r\ncase 8:\r\n*(u64 *)p = *(u64 *)q;\r\nbreak;\r\ndefault:\r\nfor ( ; n < size; ++n) {\r\n*p++ = *q++;\r\nsync();\r\n}\r\n}\r\nsync();\r\n__delay(200);\r\nn = size;\r\n} else {\r\nprintf("*** Error writing address "REG"\n", adrs + n);\r\n}\r\ncatch_memory_errors = 0;\r\nreturn n;\r\n}\r\nstatic int handle_fault(struct pt_regs *regs)\r\n{\r\nfault_except = TRAP(regs);\r\nswitch (TRAP(regs)) {\r\ncase 0x200:\r\nfault_type = 0;\r\nbreak;\r\ncase 0x300:\r\ncase 0x380:\r\nfault_type = 1;\r\nbreak;\r\ndefault:\r\nfault_type = 2;\r\n}\r\nlongjmp(bus_error_jmp, 1);\r\nreturn 0;\r\n}\r\nstatic void\r\nbyterev(unsigned char *val, int size)\r\n{\r\nint t;\r\nswitch (size) {\r\ncase 2:\r\nSWAP(val[0], val[1], t);\r\nbreak;\r\ncase 4:\r\nSWAP(val[0], val[3], t);\r\nSWAP(val[1], val[2], t);\r\nbreak;\r\ncase 8:\r\nSWAP(val[0], val[7], t);\r\nSWAP(val[1], val[6], t);\r\nSWAP(val[2], val[5], t);\r\nSWAP(val[3], val[4], t);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nmemex(void)\r\n{\r\nint cmd, inc, i, nslash;\r\nunsigned long n;\r\nunsigned char val[16];\r\nscanhex((void *)&adrs);\r\ncmd = skipbl();\r\nif (cmd == '?') {\r\nprintf(memex_help_string);\r\nreturn;\r\n} else {\r\ntermch = cmd;\r\n}\r\nlast_cmd = "m\n";\r\nwhile ((cmd = skipbl()) != '\n') {\r\nswitch( cmd ){\r\ncase 'b': size = 1; break;\r\ncase 'w': size = 2; break;\r\ncase 'l': size = 4; break;\r\ncase 'd': size = 8; break;\r\ncase 'r': brev = !brev; break;\r\ncase 'n': mnoread = 1; break;\r\ncase '.': mnoread = 0; break;\r\n}\r\n}\r\nif( size <= 0 )\r\nsize = 1;\r\nelse if( size > 8 )\r\nsize = 8;\r\nfor(;;){\r\nif (!mnoread)\r\nn = mread(adrs, val, size);\r\nprintf(REG"%c", adrs, brev? 'r': ' ');\r\nif (!mnoread) {\r\nif (brev)\r\nbyterev(val, size);\r\nputchar(' ');\r\nfor (i = 0; i < n; ++i)\r\nprintf("%.2x", val[i]);\r\nfor (; i < size; ++i)\r\nprintf("%s", fault_chars[fault_type]);\r\n}\r\nputchar(' ');\r\ninc = size;\r\nnslash = 0;\r\nfor(;;){\r\nif( scanhex(&n) ){\r\nfor (i = 0; i < size; ++i)\r\nval[i] = n >> (i * 8);\r\nif (!brev)\r\nbyterev(val, size);\r\nmwrite(adrs, val, size);\r\ninc = size;\r\n}\r\ncmd = skipbl();\r\nif (cmd == '\n')\r\nbreak;\r\ninc = 0;\r\nswitch (cmd) {\r\ncase '\'':\r\nfor(;;){\r\nn = inchar();\r\nif( n == '\\' )\r\nn = bsesc();\r\nelse if( n == '\'' )\r\nbreak;\r\nfor (i = 0; i < size; ++i)\r\nval[i] = n >> (i * 8);\r\nif (!brev)\r\nbyterev(val, size);\r\nmwrite(adrs, val, size);\r\nadrs += size;\r\n}\r\nadrs -= size;\r\ninc = size;\r\nbreak;\r\ncase ',':\r\nadrs += size;\r\nbreak;\r\ncase '.':\r\nmnoread = 0;\r\nbreak;\r\ncase ';':\r\nbreak;\r\ncase 'x':\r\ncase EOF:\r\nscannl();\r\nreturn;\r\ncase 'b':\r\ncase 'v':\r\nsize = 1;\r\nbreak;\r\ncase 'w':\r\nsize = 2;\r\nbreak;\r\ncase 'l':\r\nsize = 4;\r\nbreak;\r\ncase 'u':\r\nsize = 8;\r\nbreak;\r\ncase '^':\r\nadrs -= size;\r\nbreak;\r\ncase '/':\r\nif (nslash > 0)\r\nadrs -= 1 << nslash;\r\nelse\r\nnslash = 0;\r\nnslash += 4;\r\nadrs += 1 << nslash;\r\nbreak;\r\ncase '\\':\r\nif (nslash < 0)\r\nadrs += 1 << -nslash;\r\nelse\r\nnslash = 0;\r\nnslash -= 4;\r\nadrs -= 1 << -nslash;\r\nbreak;\r\ncase 'm':\r\nscanhex((void *)&adrs);\r\nbreak;\r\ncase 'n':\r\nmnoread = 1;\r\nbreak;\r\ncase 'r':\r\nbrev = !brev;\r\nbreak;\r\ncase '<':\r\nn = size;\r\nscanhex(&n);\r\nadrs -= n;\r\nbreak;\r\ncase '>':\r\nn = size;\r\nscanhex(&n);\r\nadrs += n;\r\nbreak;\r\ncase '?':\r\nprintf(memex_subcmd_help_string);\r\nbreak;\r\n}\r\n}\r\nadrs += inc;\r\n}\r\n}\r\nstatic int\r\nbsesc(void)\r\n{\r\nint c;\r\nc = inchar();\r\nswitch( c ){\r\ncase 'n': c = '\n'; break;\r\ncase 'r': c = '\r'; break;\r\ncase 'b': c = '\b'; break;\r\ncase 't': c = '\t'; break;\r\n}\r\nreturn c;\r\n}\r\nstatic void xmon_rawdump (unsigned long adrs, long ndump)\r\n{\r\nlong n, m, r, nr;\r\nunsigned char temp[16];\r\nfor (n = ndump; n > 0;) {\r\nr = n < 16? n: 16;\r\nnr = mread(adrs, temp, r);\r\nadrs += nr;\r\nfor (m = 0; m < r; ++m) {\r\nif (m < nr)\r\nprintf("%.2x", temp[m]);\r\nelse\r\nprintf("%s", fault_chars[fault_type]);\r\n}\r\nn -= r;\r\nif (nr < r)\r\nbreak;\r\n}\r\nprintf("\n");\r\n}\r\nstatic void dump_one_paca(int cpu)\r\n{\r\nstruct paca_struct *p;\r\n#ifdef CONFIG_PPC_STD_MMU_64\r\nint i = 0;\r\n#endif\r\nif (setjmp(bus_error_jmp) != 0) {\r\nprintf("*** Error dumping paca for cpu 0x%x!\n", cpu);\r\nreturn;\r\n}\r\ncatch_memory_errors = 1;\r\nsync();\r\np = &paca[cpu];\r\nprintf("paca for cpu 0x%x @ %p:\n", cpu, p);\r\nprintf(" %-*s = %s\n", 20, "possible", cpu_possible(cpu) ? "yes" : "no");\r\nprintf(" %-*s = %s\n", 20, "present", cpu_present(cpu) ? "yes" : "no");\r\nprintf(" %-*s = %s\n", 20, "online", cpu_online(cpu) ? "yes" : "no");\r\n#define DUMP(paca, name, format) \\r\nprintf(" %-*s = %#-*"format"\t(0x%lx)\n", 20, #name, 18, paca->name, \\r\noffsetof(struct paca_struct, name));\r\nDUMP(p, lock_token, "x");\r\nDUMP(p, paca_index, "x");\r\nDUMP(p, kernel_toc, "lx");\r\nDUMP(p, kernelbase, "lx");\r\nDUMP(p, kernel_msr, "lx");\r\nDUMP(p, emergency_sp, "p");\r\n#ifdef CONFIG_PPC_BOOK3S_64\r\nDUMP(p, mc_emergency_sp, "p");\r\nDUMP(p, in_mce, "x");\r\nDUMP(p, hmi_event_available, "x");\r\n#endif\r\nDUMP(p, data_offset, "lx");\r\nDUMP(p, hw_cpu_id, "x");\r\nDUMP(p, cpu_start, "x");\r\nDUMP(p, kexec_state, "x");\r\n#ifdef CONFIG_PPC_STD_MMU_64\r\nfor (i = 0; i < SLB_NUM_BOLTED; i++) {\r\nu64 esid, vsid;\r\nif (!p->slb_shadow_ptr)\r\ncontinue;\r\nesid = be64_to_cpu(p->slb_shadow_ptr->save_area[i].esid);\r\nvsid = be64_to_cpu(p->slb_shadow_ptr->save_area[i].vsid);\r\nif (esid || vsid) {\r\nprintf(" slb_shadow[%d]: = 0x%016lx 0x%016lx\n",\r\ni, esid, vsid);\r\n}\r\n}\r\nDUMP(p, vmalloc_sllp, "x");\r\nDUMP(p, slb_cache_ptr, "x");\r\nfor (i = 0; i < SLB_CACHE_ENTRIES; i++)\r\nprintf(" slb_cache[%d]: = 0x%016lx\n", i, p->slb_cache[i]);\r\n#endif\r\nDUMP(p, dscr_default, "llx");\r\n#ifdef CONFIG_PPC_BOOK3E\r\nDUMP(p, pgd, "p");\r\nDUMP(p, kernel_pgd, "p");\r\nDUMP(p, tcd_ptr, "p");\r\nDUMP(p, mc_kstack, "p");\r\nDUMP(p, crit_kstack, "p");\r\nDUMP(p, dbg_kstack, "p");\r\n#endif\r\nDUMP(p, __current, "p");\r\nDUMP(p, kstack, "lx");\r\nDUMP(p, stab_rr, "lx");\r\nDUMP(p, saved_r1, "lx");\r\nDUMP(p, trap_save, "x");\r\nDUMP(p, soft_enabled, "x");\r\nDUMP(p, irq_happened, "x");\r\nDUMP(p, io_sync, "x");\r\nDUMP(p, irq_work_pending, "x");\r\nDUMP(p, nap_state_lost, "x");\r\nDUMP(p, sprg_vdso, "llx");\r\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\r\nDUMP(p, tm_scratch, "llx");\r\n#endif\r\n#ifdef CONFIG_PPC_POWERNV\r\nDUMP(p, core_idle_state_ptr, "p");\r\nDUMP(p, thread_idle_state, "x");\r\nDUMP(p, thread_mask, "x");\r\nDUMP(p, subcore_sibling_mask, "x");\r\n#endif\r\nDUMP(p, accounting.user_time, "llx");\r\nDUMP(p, accounting.system_time, "llx");\r\nDUMP(p, accounting.user_time_scaled, "llx");\r\nDUMP(p, accounting.starttime, "llx");\r\nDUMP(p, accounting.starttime_user, "llx");\r\nDUMP(p, accounting.startspurr, "llx");\r\nDUMP(p, accounting.utime_sspurr, "llx");\r\nDUMP(p, stolen_time, "llx");\r\n#undef DUMP\r\ncatch_memory_errors = 0;\r\nsync();\r\n}\r\nstatic void dump_all_pacas(void)\r\n{\r\nint cpu;\r\nif (num_possible_cpus() == 0) {\r\nprintf("No possible cpus, use 'dp #' to dump individual cpus\n");\r\nreturn;\r\n}\r\nfor_each_possible_cpu(cpu)\r\ndump_one_paca(cpu);\r\n}\r\nstatic void dump_pacas(void)\r\n{\r\nunsigned long num;\r\nint c;\r\nc = inchar();\r\nif (c == 'a') {\r\ndump_all_pacas();\r\nreturn;\r\n}\r\ntermch = c;\r\nif (scanhex(&num))\r\ndump_one_paca(num);\r\nelse\r\ndump_one_paca(xmon_owner);\r\n}\r\nstatic void\r\ndump(void)\r\n{\r\nint c;\r\nc = inchar();\r\n#ifdef CONFIG_PPC64\r\nif (c == 'p') {\r\nxmon_start_pagination();\r\ndump_pacas();\r\nxmon_end_pagination();\r\nreturn;\r\n}\r\n#endif\r\nif ((isxdigit(c) && c != 'f' && c != 'd') || c == '\n')\r\ntermch = c;\r\nscanhex((void *)&adrs);\r\nif (termch != '\n')\r\ntermch = 0;\r\nif (c == 'i') {\r\nscanhex(&nidump);\r\nif (nidump == 0)\r\nnidump = 16;\r\nelse if (nidump > MAX_DUMP)\r\nnidump = MAX_DUMP;\r\nadrs += ppc_inst_dump(adrs, nidump, 1);\r\nlast_cmd = "di\n";\r\n} else if (c == 'l') {\r\ndump_log_buf();\r\n} else if (c == 'o') {\r\ndump_opal_msglog();\r\n} else if (c == 'r') {\r\nscanhex(&ndump);\r\nif (ndump == 0)\r\nndump = 64;\r\nxmon_rawdump(adrs, ndump);\r\nadrs += ndump;\r\nlast_cmd = "dr\n";\r\n} else {\r\nscanhex(&ndump);\r\nif (ndump == 0)\r\nndump = 64;\r\nelse if (ndump > MAX_DUMP)\r\nndump = MAX_DUMP;\r\nprdump(adrs, ndump);\r\nadrs += ndump;\r\nlast_cmd = "d\n";\r\n}\r\n}\r\nstatic void\r\nprdump(unsigned long adrs, long ndump)\r\n{\r\nlong n, m, c, r, nr;\r\nunsigned char temp[16];\r\nfor (n = ndump; n > 0;) {\r\nprintf(REG, adrs);\r\nputchar(' ');\r\nr = n < 16? n: 16;\r\nnr = mread(adrs, temp, r);\r\nadrs += nr;\r\nfor (m = 0; m < r; ++m) {\r\nif ((m & (sizeof(long) - 1)) == 0 && m > 0)\r\nputchar(' ');\r\nif (m < nr)\r\nprintf("%.2x", temp[m]);\r\nelse\r\nprintf("%s", fault_chars[fault_type]);\r\n}\r\nfor (; m < 16; ++m) {\r\nif ((m & (sizeof(long) - 1)) == 0)\r\nputchar(' ');\r\nprintf(" ");\r\n}\r\nprintf(" |");\r\nfor (m = 0; m < r; ++m) {\r\nif (m < nr) {\r\nc = temp[m];\r\nputchar(' ' <= c && c <= '~'? c: '.');\r\n} else\r\nputchar(' ');\r\n}\r\nn -= r;\r\nfor (; m < 16; ++m)\r\nputchar(' ');\r\nprintf("|\n");\r\nif (nr < r)\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ngeneric_inst_dump(unsigned long adr, long count, int praddr,\r\ninstruction_dump_func dump_func)\r\n{\r\nint nr, dotted;\r\nunsigned long first_adr;\r\nunsigned long inst, last_inst = 0;\r\nunsigned char val[4];\r\ndotted = 0;\r\nfor (first_adr = adr; count > 0; --count, adr += 4) {\r\nnr = mread(adr, val, 4);\r\nif (nr == 0) {\r\nif (praddr) {\r\nconst char *x = fault_chars[fault_type];\r\nprintf(REG" %s%s%s%s\n", adr, x, x, x, x);\r\n}\r\nbreak;\r\n}\r\ninst = GETWORD(val);\r\nif (adr > first_adr && inst == last_inst) {\r\nif (!dotted) {\r\nprintf(" ...\n");\r\ndotted = 1;\r\n}\r\ncontinue;\r\n}\r\ndotted = 0;\r\nlast_inst = inst;\r\nif (praddr)\r\nprintf(REG" %.8x", adr, inst);\r\nprintf("\t");\r\ndump_func(inst, adr);\r\nprintf("\n");\r\n}\r\nreturn adr - first_adr;\r\n}\r\nstatic int\r\nppc_inst_dump(unsigned long adr, long count, int praddr)\r\n{\r\nreturn generic_inst_dump(adr, count, praddr, print_insn_powerpc);\r\n}\r\nvoid\r\nprint_address(unsigned long addr)\r\n{\r\nxmon_print_symbol(addr, "\t# ", "");\r\n}\r\nvoid\r\ndump_log_buf(void)\r\n{\r\nstruct kmsg_dumper dumper = { .active = 1 };\r\nunsigned char buf[128];\r\nsize_t len;\r\nif (setjmp(bus_error_jmp) != 0) {\r\nprintf("Error dumping printk buffer!\n");\r\nreturn;\r\n}\r\ncatch_memory_errors = 1;\r\nsync();\r\nkmsg_dump_rewind_nolock(&dumper);\r\nxmon_start_pagination();\r\nwhile (kmsg_dump_get_line_nolock(&dumper, false, buf, sizeof(buf), &len)) {\r\nbuf[len] = '\0';\r\nprintf("%s", buf);\r\n}\r\nxmon_end_pagination();\r\nsync();\r\n__delay(200);\r\ncatch_memory_errors = 0;\r\n}\r\nstatic void dump_opal_msglog(void)\r\n{\r\nunsigned char buf[128];\r\nssize_t res;\r\nloff_t pos = 0;\r\nif (!firmware_has_feature(FW_FEATURE_OPAL)) {\r\nprintf("Machine is not running OPAL firmware.\n");\r\nreturn;\r\n}\r\nif (setjmp(bus_error_jmp) != 0) {\r\nprintf("Error dumping OPAL msglog!\n");\r\nreturn;\r\n}\r\ncatch_memory_errors = 1;\r\nsync();\r\nxmon_start_pagination();\r\nwhile ((res = opal_msglog_copy(buf, pos, sizeof(buf) - 1))) {\r\nif (res < 0) {\r\nprintf("Error dumping OPAL msglog! Error: %zd\n", res);\r\nbreak;\r\n}\r\nbuf[res] = '\0';\r\nprintf("%s", buf);\r\npos += res;\r\n}\r\nxmon_end_pagination();\r\nsync();\r\n__delay(200);\r\ncatch_memory_errors = 0;\r\n}\r\nstatic void\r\nmemops(int cmd)\r\n{\r\nscanhex((void *)&mdest);\r\nif( termch != '\n' )\r\ntermch = 0;\r\nscanhex((void *)(cmd == 's'? &mval: &msrc));\r\nif( termch != '\n' )\r\ntermch = 0;\r\nscanhex((void *)&mcount);\r\nswitch( cmd ){\r\ncase 'm':\r\nmemmove((void *)mdest, (void *)msrc, mcount);\r\nbreak;\r\ncase 's':\r\nmemset((void *)mdest, mval, mcount);\r\nbreak;\r\ncase 'd':\r\nif( termch != '\n' )\r\ntermch = 0;\r\nscanhex((void *)&mdiffs);\r\nmemdiffs((unsigned char *)mdest, (unsigned char *)msrc, mcount, mdiffs);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nmemdiffs(unsigned char *p1, unsigned char *p2, unsigned nb, unsigned maxpr)\r\n{\r\nunsigned n, prt;\r\nprt = 0;\r\nfor( n = nb; n > 0; --n )\r\nif( *p1++ != *p2++ )\r\nif( ++prt <= maxpr )\r\nprintf("%.16x %.2x # %.16x %.2x\n", p1 - 1,\r\np1[-1], p2 - 1, p2[-1]);\r\nif( prt > maxpr )\r\nprintf("Total of %d differences\n", prt);\r\n}\r\nstatic void\r\nmemlocate(void)\r\n{\r\nunsigned a, n;\r\nunsigned char val[4];\r\nlast_cmd = "ml";\r\nscanhex((void *)&mdest);\r\nif (termch != '\n') {\r\ntermch = 0;\r\nscanhex((void *)&mend);\r\nif (termch != '\n') {\r\ntermch = 0;\r\nscanhex((void *)&mval);\r\nmask = ~0;\r\nif (termch != '\n') termch = 0;\r\nscanhex((void *)&mask);\r\n}\r\n}\r\nn = 0;\r\nfor (a = mdest; a < mend; a += 4) {\r\nif (mread(a, val, 4) == 4\r\n&& ((GETWORD(val) ^ mval) & mask) == 0) {\r\nprintf("%.16x: %.16x\n", a, GETWORD(val));\r\nif (++n >= 10)\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nmemzcan(void)\r\n{\r\nunsigned char v;\r\nunsigned a;\r\nint ok, ook;\r\nscanhex(&mdest);\r\nif (termch != '\n') termch = 0;\r\nscanhex(&mskip);\r\nif (termch != '\n') termch = 0;\r\nscanhex(&mlim);\r\nook = 0;\r\nfor (a = mdest; a < mlim; a += mskip) {\r\nok = mread(a, &v, 1);\r\nif (ok && !ook) {\r\nprintf("%.8x .. ", a);\r\n} else if (!ok && ook)\r\nprintf("%.8x\n", a - mskip);\r\nook = ok;\r\nif (a + mskip < a)\r\nbreak;\r\n}\r\nif (ook)\r\nprintf("%.8x\n", a - mskip);\r\n}\r\nstatic void show_task(struct task_struct *tsk)\r\n{\r\nchar state;\r\nstate = (tsk->state == 0) ? 'R' :\r\n(tsk->state < 0) ? 'U' :\r\n(tsk->state & TASK_UNINTERRUPTIBLE) ? 'D' :\r\n(tsk->state & TASK_STOPPED) ? 'T' :\r\n(tsk->state & TASK_TRACED) ? 'C' :\r\n(tsk->exit_state & EXIT_ZOMBIE) ? 'Z' :\r\n(tsk->exit_state & EXIT_DEAD) ? 'E' :\r\n(tsk->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\r\nprintf("%p %016lx %6d %6d %c %2d %s\n", tsk,\r\ntsk->thread.ksp,\r\ntsk->pid, tsk->parent->pid,\r\nstate, task_thread_info(tsk)->cpu,\r\ntsk->comm);\r\n}\r\nstatic void show_tasks(void)\r\n{\r\nunsigned long tskv;\r\nstruct task_struct *tsk = NULL;\r\nprintf(" task_struct ->thread.ksp PID PPID S P CMD\n");\r\nif (scanhex(&tskv))\r\ntsk = (struct task_struct *)tskv;\r\nif (setjmp(bus_error_jmp) != 0) {\r\ncatch_memory_errors = 0;\r\nprintf("*** Error dumping task %p\n", tsk);\r\nreturn;\r\n}\r\ncatch_memory_errors = 1;\r\nsync();\r\nif (tsk)\r\nshow_task(tsk);\r\nelse\r\nfor_each_process(tsk)\r\nshow_task(tsk);\r\nsync();\r\n__delay(200);\r\ncatch_memory_errors = 0;\r\n}\r\nstatic void proccall(void)\r\n{\r\nunsigned long args[8];\r\nunsigned long ret;\r\nint i;\r\ntypedef unsigned long (*callfunc_t)(unsigned long, unsigned long,\r\nunsigned long, unsigned long, unsigned long,\r\nunsigned long, unsigned long, unsigned long);\r\ncallfunc_t func;\r\nif (!scanhex(&adrs))\r\nreturn;\r\nif (termch != '\n')\r\ntermch = 0;\r\nfor (i = 0; i < 8; ++i)\r\nargs[i] = 0;\r\nfor (i = 0; i < 8; ++i) {\r\nif (!scanhex(&args[i]) || termch == '\n')\r\nbreak;\r\ntermch = 0;\r\n}\r\nfunc = (callfunc_t) adrs;\r\nret = 0;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\nret = func(args[0], args[1], args[2], args[3],\r\nargs[4], args[5], args[6], args[7]);\r\nsync();\r\nprintf("return value is 0x%lx\n", ret);\r\n} else {\r\nprintf("*** %x exception occurred\n", fault_except);\r\n}\r\ncatch_memory_errors = 0;\r\n}\r\nint\r\nskipbl(void)\r\n{\r\nint c;\r\nif( termch != 0 ){\r\nc = termch;\r\ntermch = 0;\r\n} else\r\nc = inchar();\r\nwhile( c == ' ' || c == '\t' )\r\nc = inchar();\r\nreturn c;\r\n}\r\nint\r\nscanhex(unsigned long *vp)\r\n{\r\nint c, d;\r\nunsigned long v;\r\nc = skipbl();\r\nif (c == '%') {\r\nchar regname[8];\r\nint i;\r\nfor (i = 0; i < sizeof(regname) - 1; ++i) {\r\nc = inchar();\r\nif (!isalnum(c)) {\r\ntermch = c;\r\nbreak;\r\n}\r\nregname[i] = c;\r\n}\r\nregname[i] = 0;\r\nfor (i = 0; i < N_PTREGS; ++i) {\r\nif (strcmp(regnames[i], regname) == 0) {\r\nif (xmon_regs == NULL) {\r\nprintf("regs not available\n");\r\nreturn 0;\r\n}\r\n*vp = ((unsigned long *)xmon_regs)[i];\r\nreturn 1;\r\n}\r\n}\r\nprintf("invalid register name '%%%s'\n", regname);\r\nreturn 0;\r\n}\r\nif (c == '0') {\r\nc = inchar();\r\nif (c == 'x') {\r\nc = inchar();\r\n} else {\r\nd = hexdigit(c);\r\nif (d == EOF) {\r\ntermch = c;\r\n*vp = 0;\r\nreturn 1;\r\n}\r\n}\r\n} else if (c == '$') {\r\nint i;\r\nfor (i=0; i<63; i++) {\r\nc = inchar();\r\nif (isspace(c) || c == '\0') {\r\ntermch = c;\r\nbreak;\r\n}\r\ntmpstr[i] = c;\r\n}\r\ntmpstr[i++] = 0;\r\n*vp = 0;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\n*vp = kallsyms_lookup_name(tmpstr);\r\nsync();\r\n}\r\ncatch_memory_errors = 0;\r\nif (!(*vp)) {\r\nprintf("unknown symbol '%s'\n", tmpstr);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nd = hexdigit(c);\r\nif (d == EOF) {\r\ntermch = c;\r\nreturn 0;\r\n}\r\nv = 0;\r\ndo {\r\nv = (v << 4) + d;\r\nc = inchar();\r\nd = hexdigit(c);\r\n} while (d != EOF);\r\ntermch = c;\r\n*vp = v;\r\nreturn 1;\r\n}\r\nstatic void\r\nscannl(void)\r\n{\r\nint c;\r\nc = termch;\r\ntermch = 0;\r\nwhile( c != '\n' )\r\nc = inchar();\r\n}\r\nstatic int hexdigit(int c)\r\n{\r\nif( '0' <= c && c <= '9' )\r\nreturn c - '0';\r\nif( 'A' <= c && c <= 'F' )\r\nreturn c - ('A' - 10);\r\nif( 'a' <= c && c <= 'f' )\r\nreturn c - ('a' - 10);\r\nreturn EOF;\r\n}\r\nvoid\r\ngetstring(char *s, int size)\r\n{\r\nint c;\r\nc = skipbl();\r\ndo {\r\nif( size > 1 ){\r\n*s++ = c;\r\n--size;\r\n}\r\nc = inchar();\r\n} while( c != ' ' && c != '\t' && c != '\n' );\r\ntermch = c;\r\n*s = 0;\r\n}\r\nstatic void\r\nflush_input(void)\r\n{\r\nlineptr = NULL;\r\n}\r\nstatic int\r\ninchar(void)\r\n{\r\nif (lineptr == NULL || *lineptr == 0) {\r\nif (xmon_gets(line, sizeof(line)) == NULL) {\r\nlineptr = NULL;\r\nreturn EOF;\r\n}\r\nlineptr = line;\r\n}\r\nreturn *lineptr++;\r\n}\r\nstatic void\r\ntake_input(char *str)\r\n{\r\nlineptr = str;\r\n}\r\nstatic void\r\nsymbol_lookup(void)\r\n{\r\nint type = inchar();\r\nunsigned long addr;\r\nstatic char tmp[64];\r\nswitch (type) {\r\ncase 'a':\r\nif (scanhex(&addr))\r\nxmon_print_symbol(addr, ": ", "\n");\r\ntermch = 0;\r\nbreak;\r\ncase 's':\r\ngetstring(tmp, 64);\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\naddr = kallsyms_lookup_name(tmp);\r\nif (addr)\r\nprintf("%s: %lx\n", tmp, addr);\r\nelse\r\nprintf("Symbol '%s' not found.\n", tmp);\r\nsync();\r\n}\r\ncatch_memory_errors = 0;\r\ntermch = 0;\r\nbreak;\r\n}\r\n}\r\nstatic void xmon_print_symbol(unsigned long address, const char *mid,\r\nconst char *after)\r\n{\r\nchar *modname;\r\nconst char *name = NULL;\r\nunsigned long offset, size;\r\nprintf(REG, address);\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\nname = kallsyms_lookup(address, &size, &offset, &modname,\r\ntmpstr);\r\nsync();\r\n__delay(200);\r\n}\r\ncatch_memory_errors = 0;\r\nif (name) {\r\nprintf("%s%s+%#lx/%#lx", mid, name, offset, size);\r\nif (modname)\r\nprintf(" [%s]", modname);\r\n}\r\nprintf("%s", after);\r\n}\r\nvoid dump_segments(void)\r\n{\r\nint i;\r\nunsigned long esid,vsid;\r\nunsigned long llp;\r\nprintf("SLB contents of cpu 0x%x\n", smp_processor_id());\r\nfor (i = 0; i < mmu_slb_size; i++) {\r\nasm volatile("slbmfee %0,%1" : "=r" (esid) : "r" (i));\r\nasm volatile("slbmfev %0,%1" : "=r" (vsid) : "r" (i));\r\nif (esid || vsid) {\r\nprintf("%02d %016lx %016lx", i, esid, vsid);\r\nif (esid & SLB_ESID_V) {\r\nllp = vsid & SLB_VSID_LLP;\r\nif (vsid & SLB_VSID_B_1T) {\r\nprintf(" 1T ESID=%9lx VSID=%13lx LLP:%3lx \n",\r\nGET_ESID_1T(esid),\r\n(vsid & ~SLB_VSID_B) >> SLB_VSID_SHIFT_1T,\r\nllp);\r\n} else {\r\nprintf(" 256M ESID=%9lx VSID=%13lx LLP:%3lx \n",\r\nGET_ESID(esid),\r\n(vsid & ~SLB_VSID_B) >> SLB_VSID_SHIFT,\r\nllp);\r\n}\r\n} else\r\nprintf("\n");\r\n}\r\n}\r\n}\r\nvoid dump_segments(void)\r\n{\r\nint i;\r\nprintf("sr0-15 =");\r\nfor (i = 0; i < 16; ++i)\r\nprintf(" %x", mfsrin(i));\r\nprintf("\n");\r\n}\r\nstatic void dump_tlb_44x(void)\r\n{\r\nint i;\r\nfor (i = 0; i < PPC44x_TLB_SIZE; i++) {\r\nunsigned long w0,w1,w2;\r\nasm volatile("tlbre %0,%1,0" : "=r" (w0) : "r" (i));\r\nasm volatile("tlbre %0,%1,1" : "=r" (w1) : "r" (i));\r\nasm volatile("tlbre %0,%1,2" : "=r" (w2) : "r" (i));\r\nprintf("[%02x] %08x %08x %08x ", i, w0, w1, w2);\r\nif (w0 & PPC44x_TLB_VALID) {\r\nprintf("V %08x -> %01x%08x %c%c%c%c%c",\r\nw0 & PPC44x_TLB_EPN_MASK,\r\nw1 & PPC44x_TLB_ERPN_MASK,\r\nw1 & PPC44x_TLB_RPN_MASK,\r\n(w2 & PPC44x_TLB_W) ? 'W' : 'w',\r\n(w2 & PPC44x_TLB_I) ? 'I' : 'i',\r\n(w2 & PPC44x_TLB_M) ? 'M' : 'm',\r\n(w2 & PPC44x_TLB_G) ? 'G' : 'g',\r\n(w2 & PPC44x_TLB_E) ? 'E' : 'e');\r\n}\r\nprintf("\n");\r\n}\r\n}\r\nstatic void dump_tlb_book3e(void)\r\n{\r\nu32 mmucfg, pidmask, lpidmask;\r\nu64 ramask;\r\nint i, tlb, ntlbs, pidsz, lpidsz, rasz, lrat = 0;\r\nint mmu_version;\r\nstatic const char *pgsz_names[] = {\r\n" 1K",\r\n" 2K",\r\n" 4K",\r\n" 8K",\r\n" 16K",\r\n" 32K",\r\n" 64K",\r\n"128K",\r\n"256K",\r\n"512K",\r\n" 1M",\r\n" 2M",\r\n" 4M",\r\n" 8M",\r\n" 16M",\r\n" 32M",\r\n" 64M",\r\n"128M",\r\n"256M",\r\n"512M",\r\n" 1G",\r\n" 2G",\r\n" 4G",\r\n" 8G",\r\n" 16G",\r\n" 32G",\r\n" 64G",\r\n"128G",\r\n"256G",\r\n"512G",\r\n" 1T",\r\n" 2T",\r\n};\r\nmmucfg = mfspr(SPRN_MMUCFG);\r\nmmu_version = (mmucfg & 3) + 1;\r\nntlbs = ((mmucfg >> 2) & 3) + 1;\r\npidsz = ((mmucfg >> 6) & 0x1f) + 1;\r\nlpidsz = (mmucfg >> 24) & 0xf;\r\nrasz = (mmucfg >> 16) & 0x7f;\r\nif ((mmu_version > 1) && (mmucfg & 0x10000))\r\nlrat = 1;\r\nprintf("Book3E MMU MAV=%d.0,%d TLBs,%d-bit PID,%d-bit LPID,%d-bit RA\n",\r\nmmu_version, ntlbs, pidsz, lpidsz, rasz);\r\npidmask = (1ul << pidsz) - 1;\r\nlpidmask = (1ul << lpidsz) - 1;\r\nramask = (1ull << rasz) - 1;\r\nfor (tlb = 0; tlb < ntlbs; tlb++) {\r\nu32 tlbcfg;\r\nint nent, assoc, new_cc = 1;\r\nprintf("TLB %d:\n------\n", tlb);\r\nswitch(tlb) {\r\ncase 0:\r\ntlbcfg = mfspr(SPRN_TLB0CFG);\r\nbreak;\r\ncase 1:\r\ntlbcfg = mfspr(SPRN_TLB1CFG);\r\nbreak;\r\ncase 2:\r\ntlbcfg = mfspr(SPRN_TLB2CFG);\r\nbreak;\r\ncase 3:\r\ntlbcfg = mfspr(SPRN_TLB3CFG);\r\nbreak;\r\ndefault:\r\nprintf("Unsupported TLB number !\n");\r\ncontinue;\r\n}\r\nnent = tlbcfg & 0xfff;\r\nassoc = (tlbcfg >> 24) & 0xff;\r\nfor (i = 0; i < nent; i++) {\r\nu32 mas0 = MAS0_TLBSEL(tlb);\r\nu32 mas1 = MAS1_TSIZE(BOOK3E_PAGESZ_4K);\r\nu64 mas2 = 0;\r\nu64 mas7_mas3;\r\nint esel = i, cc = i;\r\nif (assoc != 0) {\r\ncc = i / assoc;\r\nesel = i % assoc;\r\nmas2 = cc * 0x1000;\r\n}\r\nmas0 |= MAS0_ESEL(esel);\r\nmtspr(SPRN_MAS0, mas0);\r\nmtspr(SPRN_MAS1, mas1);\r\nmtspr(SPRN_MAS2, mas2);\r\nasm volatile("tlbre 0,0,0" : : : "memory");\r\nmas1 = mfspr(SPRN_MAS1);\r\nmas2 = mfspr(SPRN_MAS2);\r\nmas7_mas3 = mfspr(SPRN_MAS7_MAS3);\r\nif (assoc && (i % assoc) == 0)\r\nnew_cc = 1;\r\nif (!(mas1 & MAS1_VALID))\r\ncontinue;\r\nif (assoc == 0)\r\nprintf("%04x- ", i);\r\nelse if (new_cc)\r\nprintf("%04x-%c", cc, 'A' + esel);\r\nelse\r\nprintf(" |%c", 'A' + esel);\r\nnew_cc = 0;\r\nprintf(" %016llx %04x %s %c%c AS%c",\r\nmas2 & ~0x3ffull,\r\n(mas1 >> 16) & 0x3fff,\r\npgsz_names[(mas1 >> 7) & 0x1f],\r\nmas1 & MAS1_IND ? 'I' : ' ',\r\nmas1 & MAS1_IPROT ? 'P' : ' ',\r\nmas1 & MAS1_TS ? '1' : '0');\r\nprintf(" %c%c%c%c%c%c%c",\r\nmas2 & MAS2_X0 ? 'a' : ' ',\r\nmas2 & MAS2_X1 ? 'v' : ' ',\r\nmas2 & MAS2_W ? 'w' : ' ',\r\nmas2 & MAS2_I ? 'i' : ' ',\r\nmas2 & MAS2_M ? 'm' : ' ',\r\nmas2 & MAS2_G ? 'g' : ' ',\r\nmas2 & MAS2_E ? 'e' : ' ');\r\nprintf(" %016llx", mas7_mas3 & ramask & ~0x7ffull);\r\nif (mas1 & MAS1_IND)\r\nprintf(" %s\n",\r\npgsz_names[(mas7_mas3 >> 1) & 0x1f]);\r\nelse\r\nprintf(" U%c%c%c S%c%c%c\n",\r\nmas7_mas3 & MAS3_UX ? 'x' : ' ',\r\nmas7_mas3 & MAS3_UW ? 'w' : ' ',\r\nmas7_mas3 & MAS3_UR ? 'r' : ' ',\r\nmas7_mas3 & MAS3_SX ? 'x' : ' ',\r\nmas7_mas3 & MAS3_SW ? 'w' : ' ',\r\nmas7_mas3 & MAS3_SR ? 'r' : ' ');\r\n}\r\n}\r\n}\r\nstatic void xmon_init(int enable)\r\n{\r\nif (enable) {\r\n__debugger = xmon;\r\n__debugger_ipi = xmon_ipi;\r\n__debugger_bpt = xmon_bpt;\r\n__debugger_sstep = xmon_sstep;\r\n__debugger_iabr_match = xmon_iabr_match;\r\n__debugger_break_match = xmon_break_match;\r\n__debugger_fault_handler = xmon_fault_handler;\r\n} else {\r\n__debugger = NULL;\r\n__debugger_ipi = NULL;\r\n__debugger_bpt = NULL;\r\n__debugger_sstep = NULL;\r\n__debugger_iabr_match = NULL;\r\n__debugger_break_match = NULL;\r\n__debugger_fault_handler = NULL;\r\n}\r\n}\r\nstatic void sysrq_handle_xmon(int key)\r\n{\r\nxmon_init(1);\r\ndebugger(get_irq_regs());\r\n}\r\nstatic int __init setup_xmon_sysrq(void)\r\n{\r\nregister_sysrq_key('x', &sysrq_xmon_op);\r\nreturn 0;\r\n}\r\nstatic int __init early_parse_xmon(char *p)\r\n{\r\nif (!p || strncmp(p, "early", 5) == 0) {\r\nxmon_init(1);\r\nxmon_early = 1;\r\n} else if (strncmp(p, "on", 2) == 0)\r\nxmon_init(1);\r\nelse if (strncmp(p, "off", 3) == 0)\r\nxmon_off = 1;\r\nelse if (strncmp(p, "nobt", 4) == 0)\r\nxmon_no_auto_backtrace = 1;\r\nelse\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid __init xmon_setup(void)\r\n{\r\n#ifdef CONFIG_XMON_DEFAULT\r\nif (!xmon_off)\r\nxmon_init(1);\r\n#endif\r\nif (xmon_early)\r\ndebugger(NULL);\r\n}\r\nvoid xmon_register_spus(struct list_head *list)\r\n{\r\nstruct spu *spu;\r\nlist_for_each_entry(spu, list, full_list) {\r\nif (spu->number >= XMON_NUM_SPUS) {\r\nWARN_ON(1);\r\ncontinue;\r\n}\r\nspu_info[spu->number].spu = spu;\r\nspu_info[spu->number].stopped_ok = 0;\r\nspu_info[spu->number].dump_addr = (unsigned long)\r\nspu_info[spu->number].spu->local_store;\r\n}\r\n}\r\nstatic void stop_spus(void)\r\n{\r\nstruct spu *spu;\r\nint i;\r\nu64 tmp;\r\nfor (i = 0; i < XMON_NUM_SPUS; i++) {\r\nif (!spu_info[i].spu)\r\ncontinue;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\nspu = spu_info[i].spu;\r\nspu_info[i].saved_spu_runcntl_RW =\r\nin_be32(&spu->problem->spu_runcntl_RW);\r\ntmp = spu_mfc_sr1_get(spu);\r\nspu_info[i].saved_mfc_sr1_RW = tmp;\r\ntmp &= ~MFC_STATE1_MASTER_RUN_CONTROL_MASK;\r\nspu_mfc_sr1_set(spu, tmp);\r\nsync();\r\n__delay(200);\r\nspu_info[i].stopped_ok = 1;\r\nprintf("Stopped spu %.2d (was %s)\n", i,\r\nspu_info[i].saved_spu_runcntl_RW ?\r\n"running" : "stopped");\r\n} else {\r\ncatch_memory_errors = 0;\r\nprintf("*** Error stopping spu %.2d\n", i);\r\n}\r\ncatch_memory_errors = 0;\r\n}\r\n}\r\nstatic void restart_spus(void)\r\n{\r\nstruct spu *spu;\r\nint i;\r\nfor (i = 0; i < XMON_NUM_SPUS; i++) {\r\nif (!spu_info[i].spu)\r\ncontinue;\r\nif (!spu_info[i].stopped_ok) {\r\nprintf("*** Error, spu %d was not successfully stopped"\r\n", not restarting\n", i);\r\ncontinue;\r\n}\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\nspu = spu_info[i].spu;\r\nspu_mfc_sr1_set(spu, spu_info[i].saved_mfc_sr1_RW);\r\nout_be32(&spu->problem->spu_runcntl_RW,\r\nspu_info[i].saved_spu_runcntl_RW);\r\nsync();\r\n__delay(200);\r\nprintf("Restarted spu %.2d\n", i);\r\n} else {\r\ncatch_memory_errors = 0;\r\nprintf("*** Error restarting spu %.2d\n", i);\r\n}\r\ncatch_memory_errors = 0;\r\n}\r\n}\r\nstatic void dump_spu_fields(struct spu *spu)\r\n{\r\nprintf("Dumping spu fields at address %p:\n", spu);\r\nDUMP_FIELD(spu, "0x%x", number);\r\nDUMP_FIELD(spu, "%s", name);\r\nDUMP_FIELD(spu, "0x%lx", local_store_phys);\r\nDUMP_FIELD(spu, "0x%p", local_store);\r\nDUMP_FIELD(spu, "0x%lx", ls_size);\r\nDUMP_FIELD(spu, "0x%x", node);\r\nDUMP_FIELD(spu, "0x%lx", flags);\r\nDUMP_FIELD(spu, "%d", class_0_pending);\r\nDUMP_FIELD(spu, "0x%lx", class_0_dar);\r\nDUMP_FIELD(spu, "0x%lx", class_1_dar);\r\nDUMP_FIELD(spu, "0x%lx", class_1_dsisr);\r\nDUMP_FIELD(spu, "0x%lx", irqs[0]);\r\nDUMP_FIELD(spu, "0x%lx", irqs[1]);\r\nDUMP_FIELD(spu, "0x%lx", irqs[2]);\r\nDUMP_FIELD(spu, "0x%x", slb_replace);\r\nDUMP_FIELD(spu, "%d", pid);\r\nDUMP_FIELD(spu, "0x%p", mm);\r\nDUMP_FIELD(spu, "0x%p", ctx);\r\nDUMP_FIELD(spu, "0x%p", rq);\r\nDUMP_FIELD(spu, "0x%p", timestamp);\r\nDUMP_FIELD(spu, "0x%lx", problem_phys);\r\nDUMP_FIELD(spu, "0x%p", problem);\r\nDUMP_VALUE("0x%x", problem->spu_runcntl_RW,\r\nin_be32(&spu->problem->spu_runcntl_RW));\r\nDUMP_VALUE("0x%x", problem->spu_status_R,\r\nin_be32(&spu->problem->spu_status_R));\r\nDUMP_VALUE("0x%x", problem->spu_npc_RW,\r\nin_be32(&spu->problem->spu_npc_RW));\r\nDUMP_FIELD(spu, "0x%p", priv2);\r\nDUMP_FIELD(spu, "0x%p", pdata);\r\n}\r\nint\r\nspu_inst_dump(unsigned long adr, long count, int praddr)\r\n{\r\nreturn generic_inst_dump(adr, count, praddr, print_insn_spu);\r\n}\r\nstatic void dump_spu_ls(unsigned long num, int subcmd)\r\n{\r\nunsigned long offset, addr, ls_addr;\r\nif (setjmp(bus_error_jmp) == 0) {\r\ncatch_memory_errors = 1;\r\nsync();\r\nls_addr = (unsigned long)spu_info[num].spu->local_store;\r\nsync();\r\n__delay(200);\r\n} else {\r\ncatch_memory_errors = 0;\r\nprintf("*** Error: accessing spu info for spu %d\n", num);\r\nreturn;\r\n}\r\ncatch_memory_errors = 0;\r\nif (scanhex(&offset))\r\naddr = ls_addr + offset;\r\nelse\r\naddr = spu_info[num].dump_addr;\r\nif (addr >= ls_addr + LS_SIZE) {\r\nprintf("*** Error: address outside of local store\n");\r\nreturn;\r\n}\r\nswitch (subcmd) {\r\ncase 'i':\r\naddr += spu_inst_dump(addr, 16, 1);\r\nlast_cmd = "sdi\n";\r\nbreak;\r\ndefault:\r\nprdump(addr, 64);\r\naddr += 64;\r\nlast_cmd = "sd\n";\r\nbreak;\r\n}\r\nspu_info[num].dump_addr = addr;\r\n}\r\nstatic int do_spu_cmd(void)\r\n{\r\nstatic unsigned long num = 0;\r\nint cmd, subcmd = 0;\r\ncmd = inchar();\r\nswitch (cmd) {\r\ncase 's':\r\nstop_spus();\r\nbreak;\r\ncase 'r':\r\nrestart_spus();\r\nbreak;\r\ncase 'd':\r\nsubcmd = inchar();\r\nif (isxdigit(subcmd) || subcmd == '\n')\r\ntermch = subcmd;\r\ncase 'f':\r\nscanhex(&num);\r\nif (num >= XMON_NUM_SPUS || !spu_info[num].spu) {\r\nprintf("*** Error: invalid spu number\n");\r\nreturn 0;\r\n}\r\nswitch (cmd) {\r\ncase 'f':\r\ndump_spu_fields(spu_info[num].spu);\r\nbreak;\r\ndefault:\r\ndump_spu_ls(num, subcmd);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_spu_cmd(void)\r\n{\r\nreturn -1;\r\n}
