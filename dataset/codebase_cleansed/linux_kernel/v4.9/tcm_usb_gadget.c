static int guas_unbind(struct usb_composite_dev *cdev)\r\n{\r\nif (!IS_ERR_OR_NULL(f_tcm))\r\nusb_put_function(f_tcm);\r\nreturn 0;\r\n}\r\nstatic int tcm_do_config(struct usb_configuration *c)\r\n{\r\nint status;\r\nf_tcm = usb_get_function(fi_tcm);\r\nif (IS_ERR(f_tcm))\r\nreturn PTR_ERR(f_tcm);\r\nstatus = usb_add_function(c, f_tcm);\r\nif (status < 0) {\r\nusb_put_function(f_tcm);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_target_bind(struct usb_composite_dev *cdev)\r\n{\r\nint ret;\r\nret = usb_string_ids_tab(cdev, usbg_us_strings);\r\nif (ret)\r\nreturn ret;\r\nusbg_device_desc.iManufacturer =\r\nusbg_us_strings[USB_GADGET_MANUFACTURER_IDX].id;\r\nusbg_device_desc.iProduct = usbg_us_strings[USB_GADGET_PRODUCT_IDX].id;\r\nusbg_device_desc.iSerialNumber =\r\nusbg_us_strings[USB_GADGET_SERIAL_IDX].id;\r\nusbg_config_driver.iConfiguration =\r\nusbg_us_strings[USB_G_STR_CONFIG].id;\r\nret = usb_add_config(cdev, &usbg_config_driver, tcm_do_config);\r\nif (ret)\r\nreturn ret;\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\nreturn 0;\r\n}\r\nstatic int usbg_attach(struct usb_function_instance *f)\r\n{\r\nreturn usb_composite_probe(&usbg_driver);\r\n}\r\nstatic void usbg_detach(struct usb_function_instance *f)\r\n{\r\nusb_composite_unregister(&usbg_driver);\r\n}\r\nstatic int __init usb_target_gadget_init(void)\r\n{\r\nstruct f_tcm_opts *tcm_opts;\r\nfi_tcm = usb_get_function_instance("tcm");\r\nif (IS_ERR(fi_tcm))\r\nreturn PTR_ERR(fi_tcm);\r\ntcm_opts = container_of(fi_tcm, struct f_tcm_opts, func_inst);\r\nmutex_lock(&tcm_opts->dep_lock);\r\ntcm_opts->tcm_register_callback = usbg_attach;\r\ntcm_opts->tcm_unregister_callback = usbg_detach;\r\ntcm_opts->dependent = THIS_MODULE;\r\ntcm_opts->can_attach = true;\r\ntcm_opts->has_dep = true;\r\nmutex_unlock(&tcm_opts->dep_lock);\r\nfi_tcm->set_inst_name(fi_tcm, "tcm-legacy");\r\nreturn 0;\r\n}\r\nstatic void __exit usb_target_gadget_exit(void)\r\n{\r\nif (!IS_ERR_OR_NULL(fi_tcm))\r\nusb_put_function_instance(fi_tcm);\r\n}
