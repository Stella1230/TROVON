static enum rbtn_type rbtn_check(struct acpi_device *device)\r\n{\r\nunsigned long long output;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(device->handle, "CRBT", NULL, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn RBTN_UNKNOWN;\r\nswitch (output) {\r\ncase 0:\r\ncase 1:\r\nreturn RBTN_TOGGLE;\r\ncase 2:\r\ncase 3:\r\nreturn RBTN_SLIDER;\r\ndefault:\r\nreturn RBTN_UNKNOWN;\r\n}\r\n}\r\nstatic int rbtn_get(struct acpi_device *device)\r\n{\r\nunsigned long long output;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(device->handle, "GRBT", NULL, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn -EINVAL;\r\nreturn !output;\r\n}\r\nstatic int rbtn_acquire(struct acpi_device *device, bool enable)\r\n{\r\nstruct acpi_object_list input;\r\nunion acpi_object param;\r\nacpi_status status;\r\nparam.type = ACPI_TYPE_INTEGER;\r\nparam.integer.value = enable;\r\ninput.count = 1;\r\ninput.pointer = &param;\r\nstatus = acpi_evaluate_object(device->handle, "ARBT", &input, NULL);\r\nif (ACPI_FAILURE(status))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void rbtn_rfkill_query(struct rfkill *rfkill, void *data)\r\n{\r\nstruct acpi_device *device = data;\r\nint state;\r\nstate = rbtn_get(device);\r\nif (state < 0)\r\nreturn;\r\nrfkill_set_states(rfkill, state, state);\r\n}\r\nstatic int rbtn_rfkill_set_block(void *data, bool blocked)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int rbtn_rfkill_init(struct acpi_device *device)\r\n{\r\nstruct rbtn_data *rbtn_data = device->driver_data;\r\nint ret;\r\nif (rbtn_data->rfkill)\r\nreturn 0;\r\nrbtn_data->rfkill = rfkill_alloc("dell-rbtn", &device->dev,\r\nRFKILL_TYPE_WLAN, &rbtn_ops, device);\r\nif (!rbtn_data->rfkill)\r\nreturn -ENOMEM;\r\nret = rfkill_register(rbtn_data->rfkill);\r\nif (ret) {\r\nrfkill_destroy(rbtn_data->rfkill);\r\nrbtn_data->rfkill = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rbtn_rfkill_exit(struct acpi_device *device)\r\n{\r\nstruct rbtn_data *rbtn_data = device->driver_data;\r\nif (!rbtn_data->rfkill)\r\nreturn;\r\nrfkill_unregister(rbtn_data->rfkill);\r\nrfkill_destroy(rbtn_data->rfkill);\r\nrbtn_data->rfkill = NULL;\r\n}\r\nstatic void rbtn_rfkill_event(struct acpi_device *device)\r\n{\r\nstruct rbtn_data *rbtn_data = device->driver_data;\r\nif (rbtn_data->rfkill)\r\nrbtn_rfkill_query(rbtn_data->rfkill, device);\r\n}\r\nstatic int rbtn_input_init(struct rbtn_data *rbtn_data)\r\n{\r\nint ret;\r\nrbtn_data->input_dev = input_allocate_device();\r\nif (!rbtn_data->input_dev)\r\nreturn -ENOMEM;\r\nrbtn_data->input_dev->name = "DELL Wireless hotkeys";\r\nrbtn_data->input_dev->phys = "dellabce/input0";\r\nrbtn_data->input_dev->id.bustype = BUS_HOST;\r\nrbtn_data->input_dev->evbit[0] = BIT(EV_KEY);\r\nset_bit(KEY_RFKILL, rbtn_data->input_dev->keybit);\r\nret = input_register_device(rbtn_data->input_dev);\r\nif (ret) {\r\ninput_free_device(rbtn_data->input_dev);\r\nrbtn_data->input_dev = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rbtn_input_exit(struct rbtn_data *rbtn_data)\r\n{\r\ninput_unregister_device(rbtn_data->input_dev);\r\nrbtn_data->input_dev = NULL;\r\n}\r\nstatic void rbtn_input_event(struct rbtn_data *rbtn_data)\r\n{\r\ninput_report_key(rbtn_data->input_dev, KEY_RFKILL, 1);\r\ninput_sync(rbtn_data->input_dev);\r\ninput_report_key(rbtn_data->input_dev, KEY_RFKILL, 0);\r\ninput_sync(rbtn_data->input_dev);\r\n}\r\nstatic void ACPI_SYSTEM_XFACE rbtn_clear_suspended_flag(void *context)\r\n{\r\nstruct rbtn_data *rbtn_data = context;\r\nrbtn_data->suspended = false;\r\n}\r\nstatic int rbtn_suspend(struct device *dev)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct rbtn_data *rbtn_data = acpi_driver_data(device);\r\nrbtn_data->suspended = true;\r\nreturn 0;\r\n}\r\nstatic int rbtn_resume(struct device *dev)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct rbtn_data *rbtn_data = acpi_driver_data(device);\r\nacpi_status status;\r\nstatus = acpi_os_execute(OSL_NOTIFY_HANDLER,\r\nrbtn_clear_suspended_flag, rbtn_data);\r\nif (ACPI_FAILURE(status))\r\nrbtn_clear_suspended_flag(rbtn_data);\r\nreturn 0;\r\n}\r\nstatic int rbtn_inc_count(struct device *dev, void *data)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct rbtn_data *rbtn_data = device->driver_data;\r\nint *count = data;\r\nif (rbtn_data->type == RBTN_SLIDER)\r\n(*count)++;\r\nreturn 0;\r\n}\r\nstatic int rbtn_switch_dev(struct device *dev, void *data)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct rbtn_data *rbtn_data = device->driver_data;\r\nbool enable = data;\r\nif (rbtn_data->type != RBTN_SLIDER)\r\nreturn 0;\r\nif (enable)\r\nrbtn_rfkill_init(device);\r\nelse\r\nrbtn_rfkill_exit(device);\r\nreturn 0;\r\n}\r\nint dell_rbtn_notifier_register(struct notifier_block *nb)\r\n{\r\nbool first;\r\nint count;\r\nint ret;\r\ncount = 0;\r\nret = driver_for_each_device(&rbtn_driver.drv, NULL, &count,\r\nrbtn_inc_count);\r\nif (ret || count == 0)\r\nreturn -ENODEV;\r\nfirst = !rbtn_chain_head.head;\r\nret = atomic_notifier_chain_register(&rbtn_chain_head, nb);\r\nif (ret != 0)\r\nreturn ret;\r\nif (auto_remove_rfkill && first)\r\nret = driver_for_each_device(&rbtn_driver.drv, NULL,\r\n(void *)false, rbtn_switch_dev);\r\nreturn ret;\r\n}\r\nint dell_rbtn_notifier_unregister(struct notifier_block *nb)\r\n{\r\nint ret;\r\nret = atomic_notifier_chain_unregister(&rbtn_chain_head, nb);\r\nif (ret != 0)\r\nreturn ret;\r\nif (auto_remove_rfkill && !rbtn_chain_head.head)\r\nret = driver_for_each_device(&rbtn_driver.drv, NULL,\r\n(void *)true, rbtn_switch_dev);\r\nreturn ret;\r\n}\r\nstatic int rbtn_add(struct acpi_device *device)\r\n{\r\nstruct rbtn_data *rbtn_data;\r\nenum rbtn_type type;\r\nint ret = 0;\r\ntype = rbtn_check(device);\r\nif (type == RBTN_UNKNOWN) {\r\ndev_info(&device->dev, "Unknown device type\n");\r\nreturn -EINVAL;\r\n}\r\nret = rbtn_acquire(device, true);\r\nif (ret < 0) {\r\ndev_err(&device->dev, "Cannot enable device\n");\r\nreturn ret;\r\n}\r\nrbtn_data = devm_kzalloc(&device->dev, sizeof(*rbtn_data), GFP_KERNEL);\r\nif (!rbtn_data)\r\nreturn -ENOMEM;\r\nrbtn_data->type = type;\r\ndevice->driver_data = rbtn_data;\r\nswitch (rbtn_data->type) {\r\ncase RBTN_TOGGLE:\r\nret = rbtn_input_init(rbtn_data);\r\nbreak;\r\ncase RBTN_SLIDER:\r\nif (auto_remove_rfkill && rbtn_chain_head.head)\r\nret = 0;\r\nelse\r\nret = rbtn_rfkill_init(device);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rbtn_remove(struct acpi_device *device)\r\n{\r\nstruct rbtn_data *rbtn_data = device->driver_data;\r\nswitch (rbtn_data->type) {\r\ncase RBTN_TOGGLE:\r\nrbtn_input_exit(rbtn_data);\r\nbreak;\r\ncase RBTN_SLIDER:\r\nrbtn_rfkill_exit(device);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrbtn_acquire(device, false);\r\ndevice->driver_data = NULL;\r\nreturn 0;\r\n}\r\nstatic void rbtn_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct rbtn_data *rbtn_data = device->driver_data;\r\nif (rbtn_data->suspended) {\r\ndev_dbg(&device->dev, "ACPI notification ignored\n");\r\nreturn;\r\n}\r\nif (event != 0x80) {\r\ndev_info(&device->dev, "Received unknown event (0x%x)\n",\r\nevent);\r\nreturn;\r\n}\r\nswitch (rbtn_data->type) {\r\ncase RBTN_TOGGLE:\r\nrbtn_input_event(rbtn_data);\r\nbreak;\r\ncase RBTN_SLIDER:\r\nrbtn_rfkill_event(device);\r\natomic_notifier_call_chain(&rbtn_chain_head, event, device);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}
