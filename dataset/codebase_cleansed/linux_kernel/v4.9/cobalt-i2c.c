static struct cobalt_i2c_regs __iomem *\r\ncobalt_i2c_regs(struct cobalt *cobalt, unsigned idx)\r\n{\r\nswitch (idx) {\r\ncase 0:\r\ndefault:\r\nreturn (struct cobalt_i2c_regs __iomem *)\r\n(cobalt->bar1 + COBALT_I2C_0_BASE);\r\ncase 1:\r\nreturn (struct cobalt_i2c_regs __iomem *)\r\n(cobalt->bar1 + COBALT_I2C_1_BASE);\r\ncase 2:\r\nreturn (struct cobalt_i2c_regs __iomem *)\r\n(cobalt->bar1 + COBALT_I2C_2_BASE);\r\ncase 3:\r\nreturn (struct cobalt_i2c_regs __iomem *)\r\n(cobalt->bar1 + COBALT_I2C_3_BASE);\r\ncase 4:\r\nreturn (struct cobalt_i2c_regs __iomem *)\r\n(cobalt->bar1 + COBALT_I2C_HSMA_BASE);\r\n}\r\n}\r\nstatic int cobalt_tx_bytes(struct cobalt_i2c_regs __iomem *regs,\r\nstruct i2c_adapter *adap, bool start, bool stop,\r\nu8 *data, u16 len)\r\n{\r\nunsigned long start_time;\r\nint status;\r\nint cmd;\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\niowrite8(data[i], &regs->txr_rxr);\r\nif (i == 0 && start != 0) {\r\ncmd = M00018_CR_BITMAP_WR_MSK |\r\nM00018_CR_BITMAP_STA_MSK;\r\n} else if (i == len - 1 && stop != 0) {\r\ncmd = M00018_CR_BITMAP_WR_MSK |\r\nM00018_CR_BITMAP_STO_MSK;\r\n} else {\r\ncmd = M00018_CR_BITMAP_WR_MSK;\r\n}\r\niowrite8(cmd, &regs->cr_sr);\r\nstart_time = jiffies;\r\nstatus = ioread8(&regs->cr_sr);\r\nwhile (status & M00018_SR_BITMAP_TIP_MSK) {\r\nif (time_after(jiffies, start_time + adap->timeout))\r\nreturn -ETIMEDOUT;\r\ncond_resched();\r\nstatus = ioread8(&regs->cr_sr);\r\n}\r\nif (status & M00018_SR_BITMAP_RXACK_MSK) {\r\nreturn -EIO;\r\n}\r\nif (status & M00018_SR_BITMAP_AL_MSK) {\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cobalt_rx_bytes(struct cobalt_i2c_regs __iomem *regs,\r\nstruct i2c_adapter *adap, bool start, bool stop,\r\nu8 *data, u16 len)\r\n{\r\nunsigned long start_time;\r\nint status;\r\nint cmd;\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nif (i == 0 && start != 0) {\r\ncmd = M00018_CR_BITMAP_RD_MSK |\r\nM00018_CR_BITMAP_STA_MSK;\r\n} else if (i == len - 1 && stop != 0) {\r\ncmd = M00018_CR_BITMAP_RD_MSK |\r\nM00018_CR_BITMAP_STO_MSK;\r\n} else {\r\ncmd = M00018_CR_BITMAP_RD_MSK;\r\n}\r\nif (i == len - 1)\r\ncmd |= M00018_CR_BITMAP_ACK_MSK;\r\niowrite8(cmd, &regs->cr_sr);\r\nstart_time = jiffies;\r\nstatus = ioread8(&regs->cr_sr);\r\nwhile (status & M00018_SR_BITMAP_TIP_MSK) {\r\nif (time_after(jiffies, start_time + adap->timeout))\r\nreturn -ETIMEDOUT;\r\ncond_resched();\r\nstatus = ioread8(&regs->cr_sr);\r\n}\r\nif (status & M00018_SR_BITMAP_AL_MSK) {\r\nreturn -EIO;\r\n}\r\ndata[i] = ioread8(&regs->txr_rxr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cobalt_stop(struct cobalt_i2c_regs __iomem *regs,\r\nstruct i2c_adapter *adap)\r\n{\r\nu8 data = 0;\r\nreturn cobalt_tx_bytes(regs, adap, true, true, &data, 1);\r\n}\r\nstatic int cobalt_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct cobalt_i2c_data *data = adap->algo_data;\r\nstruct cobalt_i2c_regs __iomem *regs = data->regs;\r\nstruct i2c_msg *pmsg;\r\nunsigned short flags;\r\nint ret = 0;\r\nint i, j;\r\nfor (i = 0; i < num; i++) {\r\nint stop = (i == num - 1);\r\npmsg = &msgs[i];\r\nflags = pmsg->flags;\r\nif (!(pmsg->flags & I2C_M_NOSTART)) {\r\nu8 addr = pmsg->addr << 1;\r\nif (flags & I2C_M_RD)\r\naddr |= 1;\r\nif (flags & I2C_M_REV_DIR_ADDR)\r\naddr ^= 1;\r\nfor (j = 0; j < adap->retries; j++) {\r\nret = cobalt_tx_bytes(regs, adap, true, false,\r\n&addr, 1);\r\nif (!ret)\r\nbreak;\r\ncobalt_stop(regs, adap);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nret = 0;\r\n}\r\nif (pmsg->flags & I2C_M_RD) {\r\nret = cobalt_rx_bytes(regs, adap, false, stop,\r\npmsg->buf, pmsg->len);\r\nif (ret < 0)\r\ngoto bailout;\r\n} else {\r\nret = cobalt_tx_bytes(regs, adap, false, stop,\r\npmsg->buf, pmsg->len);\r\nif (ret < 0)\r\ngoto bailout;\r\n}\r\n}\r\nret = i;\r\nbailout:\r\nif (ret < 0)\r\ncobalt_stop(regs, adap);\r\nreturn ret;\r\n}\r\nstatic u32 cobalt_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nint cobalt_i2c_init(struct cobalt *cobalt)\r\n{\r\nint i, err;\r\nint status;\r\nint prescale;\r\nunsigned long start_time;\r\ncobalt_dbg(1, "i2c init\n");\r\nprescale = ((ALT_CPU_FREQ) / (5 * I2C_FREQUENCY)) - 1;\r\nfor (i = 0; i < COBALT_NUM_ADAPTERS; i++) {\r\nstruct cobalt_i2c_regs __iomem *regs =\r\ncobalt_i2c_regs(cobalt, i);\r\nstruct i2c_adapter *adap = &cobalt->i2c_adap[i];\r\niowrite8(M00018_CTR_BITMAP_EN_MSK, &regs->cr_sr);\r\niowrite8(0, &regs->ctr);\r\niowrite8(0, &regs->cr_sr);\r\nstart_time = jiffies;\r\ndo {\r\nif (time_after(jiffies, start_time + HZ)) {\r\nif (cobalt_ignore_err) {\r\nadap->dev.parent = NULL;\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatus = ioread8(&regs->cr_sr);\r\n} while (status & M00018_SR_BITMAP_TIP_MSK);\r\niowrite8(0, &regs->ctr);\r\niowrite8(0, &regs->cr_sr);\r\niowrite8(prescale & 0xff, &regs->prerlo);\r\niowrite8((prescale >> 8) & 0xff, &regs->prerhi);\r\niowrite8(M00018_CTR_BITMAP_EN_MSK, &regs->ctr);\r\ncobalt->i2c_data[i].cobalt = cobalt;\r\ncobalt->i2c_data[i].regs = regs;\r\n*adap = cobalt_i2c_adap_template;\r\nadap->algo = &cobalt_algo;\r\nadap->algo_data = &cobalt->i2c_data[i];\r\nadap->retries = 3;\r\nsprintf(adap->name + strlen(adap->name),\r\n" #%d-%d", cobalt->instance, i);\r\ni2c_set_adapdata(adap, &cobalt->v4l2_dev);\r\nadap->dev.parent = &cobalt->pci_dev->dev;\r\nerr = i2c_add_adapter(adap);\r\nif (err) {\r\nif (cobalt_ignore_err) {\r\nadap->dev.parent = NULL;\r\nreturn 0;\r\n}\r\nwhile (i--)\r\ni2c_del_adapter(&cobalt->i2c_adap[i]);\r\nreturn err;\r\n}\r\ncobalt_info("registered bus %s\n", adap->name);\r\n}\r\nreturn 0;\r\n}\r\nvoid cobalt_i2c_exit(struct cobalt *cobalt)\r\n{\r\nint i;\r\ncobalt_dbg(1, "i2c exit\n");\r\nfor (i = 0; i < COBALT_NUM_ADAPTERS; i++) {\r\ncobalt_err("unregistered bus %s\n", cobalt->i2c_adap[i].name);\r\ni2c_del_adapter(&cobalt->i2c_adap[i]);\r\n}\r\n}
