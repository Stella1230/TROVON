static int vl600_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret;\r\nstruct vl600_state *s = kzalloc(sizeof(struct vl600_state), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\nret = usbnet_cdc_bind(dev, intf);\r\nif (ret) {\r\nkfree(s);\r\nreturn ret;\r\n}\r\ndev->driver_priv = s;\r\ndev->net->flags |= IFF_NOARP;\r\ndev->net->flags |= IFF_MULTICAST;\r\nreturn ret;\r\n}\r\nstatic void vl600_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct vl600_state *s = dev->driver_priv;\r\nif (s->current_rx_buf)\r\ndev_kfree_skb(s->current_rx_buf);\r\nkfree(s);\r\nreturn usbnet_cdc_unbind(dev, intf);\r\n}\r\nstatic int vl600_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct vl600_frame_hdr *frame;\r\nstruct vl600_pkt_hdr *packet;\r\nstruct ethhdr *ethhdr;\r\nint packet_len, count;\r\nstruct sk_buff *buf = skb;\r\nstruct sk_buff *clone;\r\nstruct vl600_state *s = dev->driver_priv;\r\nif (s->current_rx_buf) {\r\nframe = (struct vl600_frame_hdr *) s->current_rx_buf->data;\r\nif (skb->len + s->current_rx_buf->len >\r\nle32_to_cpup(&frame->len)) {\r\nnetif_err(dev, ifup, dev->net, "Fragment too long\n");\r\ndev->net->stats.rx_length_errors++;\r\ngoto error;\r\n}\r\nbuf = s->current_rx_buf;\r\nmemcpy(skb_put(buf, skb->len), skb->data, skb->len);\r\n} else if (skb->len < 4) {\r\nnetif_err(dev, ifup, dev->net, "Frame too short\n");\r\ndev->net->stats.rx_length_errors++;\r\ngoto error;\r\n}\r\nframe = (struct vl600_frame_hdr *) buf->data;\r\nif (ntohl(frame->magic) != 0x53544448 &&\r\nntohl(frame->magic) != 0x44544d48)\r\ngoto error;\r\nif (buf->len < sizeof(*frame) ||\r\nbuf->len != le32_to_cpup(&frame->len)) {\r\nif (s->current_rx_buf)\r\nreturn 0;\r\ns->current_rx_buf = skb_copy_expand(skb, 0,\r\nle32_to_cpup(&frame->len), GFP_ATOMIC);\r\nif (!s->current_rx_buf) {\r\nnetif_err(dev, ifup, dev->net, "Reserving %i bytes "\r\n"for packet assembly failed.\n",\r\nle32_to_cpup(&frame->len));\r\ndev->net->stats.rx_errors++;\r\n}\r\nreturn 0;\r\n}\r\ncount = le32_to_cpup(&frame->pkt_cnt);\r\nskb_pull(buf, sizeof(*frame));\r\nwhile (count--) {\r\nif (buf->len < sizeof(*packet)) {\r\nnetif_err(dev, ifup, dev->net, "Packet too short\n");\r\ngoto error;\r\n}\r\npacket = (struct vl600_pkt_hdr *) buf->data;\r\npacket_len = sizeof(*packet) + le32_to_cpup(&packet->len);\r\nif (packet_len > buf->len) {\r\nnetif_err(dev, ifup, dev->net,\r\n"Bad packet length stored in header\n");\r\ngoto error;\r\n}\r\nethhdr = (struct ethhdr *) skb->data;\r\nif (be16_to_cpup(&ethhdr->h_proto) == ETH_P_ARP &&\r\nbuf->len > 0x26) {\r\nmemcpy(ethhdr->h_source,\r\n&buf->data[sizeof(*ethhdr) + 0x8],\r\nETH_ALEN);\r\nmemcpy(ethhdr->h_dest,\r\n&buf->data[sizeof(*ethhdr) + 0x12],\r\nETH_ALEN);\r\n} else {\r\neth_zero_addr(ethhdr->h_source);\r\nmemcpy(ethhdr->h_dest, dev->net->dev_addr, ETH_ALEN);\r\nif ((buf->data[sizeof(*ethhdr)] & 0xf0) == 0x60)\r\nethhdr->h_proto = htons(ETH_P_IPV6);\r\n}\r\nif (count) {\r\nclone = skb_clone(buf, GFP_ATOMIC);\r\nif (!clone)\r\ngoto error;\r\nskb_trim(clone, packet_len);\r\nusbnet_skb_return(dev, clone);\r\nskb_pull(buf, (packet_len + 3) & ~3);\r\n} else {\r\nskb_trim(buf, packet_len);\r\nif (s->current_rx_buf) {\r\nusbnet_skb_return(dev, buf);\r\ns->current_rx_buf = NULL;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\n}\r\nerror:\r\nif (s->current_rx_buf) {\r\ndev_kfree_skb_any(s->current_rx_buf);\r\ns->current_rx_buf = NULL;\r\n}\r\ndev->net->stats.rx_errors++;\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *vl600_tx_fixup(struct usbnet *dev,\r\nstruct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *ret;\r\nstruct vl600_frame_hdr *frame;\r\nstruct vl600_pkt_hdr *packet;\r\nstatic uint32_t serial = 1;\r\nint orig_len = skb->len - sizeof(struct ethhdr);\r\nint full_len = (skb->len + sizeof(struct vl600_frame_hdr) + 3) & ~3;\r\nframe = (struct vl600_frame_hdr *) skb->data;\r\nif (skb->len > sizeof(*frame) && skb->len == le32_to_cpup(&frame->len))\r\nreturn skb;\r\nif (skb->len < sizeof(struct ethhdr))\r\nreturn NULL;\r\nif (!skb_cloned(skb)) {\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nif (tailroom >= full_len - skb->len - sizeof(*frame) &&\r\nheadroom >= sizeof(*frame))\r\ngoto encapsulate;\r\nif (headroom + tailroom + skb->len >= full_len) {\r\nskb->data = memmove(skb->head + sizeof(*frame),\r\nskb->data, skb->len);\r\nskb_set_tail_pointer(skb, skb->len);\r\ngoto encapsulate;\r\n}\r\n}\r\nret = skb_copy_expand(skb, sizeof(struct vl600_frame_hdr), full_len -\r\nskb->len - sizeof(struct vl600_frame_hdr), flags);\r\ndev_kfree_skb_any(skb);\r\nif (!ret)\r\nreturn ret;\r\nskb = ret;\r\nencapsulate:\r\npacket = (struct vl600_pkt_hdr *) skb->data;\r\npacket->h_proto = htons(ETH_P_IP);\r\nmemset(&packet->dummy, 0, sizeof(packet->dummy));\r\npacket->len = cpu_to_le32(orig_len);\r\nframe = (struct vl600_frame_hdr *) skb_push(skb, sizeof(*frame));\r\nmemset(frame, 0, sizeof(*frame));\r\nframe->len = cpu_to_le32(full_len);\r\nframe->serial = cpu_to_le32(serial++);\r\nframe->pkt_cnt = cpu_to_le32(1);\r\nif (skb->len < full_len)\r\nskb_put(skb, full_len - skb->len);\r\nreturn skb;\r\n}
