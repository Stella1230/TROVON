static int\r\ngm20b_secboot_prepare_blobs(struct gm200_secboot *gsb)\r\n{\r\nstruct nvkm_subdev *subdev = &gsb->base.subdev;\r\nint acr_size;\r\nint ret;\r\nret = gm20x_secboot_prepare_blobs(gsb);\r\nif (ret)\r\nreturn ret;\r\nacr_size = gsb->acr_load_blob->size;\r\nif (acr_size > gsb->wpr_size) {\r\nnvkm_error(subdev, "WPR region too small for FW blob!\n");\r\nnvkm_error(subdev, "required: %dB\n", acr_size);\r\nnvkm_error(subdev, "WPR size: %dB\n", gsb->wpr_size);\r\nreturn -ENOSPC;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ngm20b_secboot_fixup_bl_desc(const struct gm200_flcn_bl_desc *desc, void *ret)\r\n{\r\nstruct gm20b_flcn_bl_desc *gdesc = ret;\r\nu64 addr;\r\nmemcpy(gdesc->reserved, desc->reserved, sizeof(gdesc->reserved));\r\nmemcpy(gdesc->signature, desc->signature, sizeof(gdesc->signature));\r\ngdesc->ctx_dma = desc->ctx_dma;\r\naddr = desc->code_dma_base.hi;\r\naddr <<= 32;\r\naddr |= desc->code_dma_base.lo;\r\ngdesc->code_dma_base = lower_32_bits(addr >> 8);\r\ngdesc->non_sec_code_off = desc->non_sec_code_off;\r\ngdesc->non_sec_code_size = desc->non_sec_code_size;\r\ngdesc->sec_code_off = desc->sec_code_off;\r\ngdesc->sec_code_size = desc->sec_code_size;\r\ngdesc->code_entry_point = desc->code_entry_point;\r\naddr = desc->data_dma_base.hi;\r\naddr <<= 32;\r\naddr |= desc->data_dma_base.lo;\r\ngdesc->data_dma_base = lower_32_bits(addr >> 8);\r\ngdesc->data_size = desc->data_size;\r\n}\r\nstatic void\r\ngm20b_secboot_fixup_hs_desc(struct gm200_secboot *gsb,\r\nstruct hsflcn_acr_desc *desc)\r\n{\r\ndesc->ucode_blob_base = gsb->ls_blob->addr;\r\ndesc->ucode_blob_size = gsb->ls_blob->size;\r\ndesc->wpr_offset = 0;\r\n}\r\nstatic int\r\ngm20b_tegra_read_wpr(struct gm200_secboot *gsb)\r\n{\r\nstruct nvkm_secboot *sb = &gsb->base;\r\nvoid __iomem *mc;\r\nu32 cfg;\r\nmc = ioremap(TEGRA_MC_BASE, 0xd00);\r\nif (!mc) {\r\nnvkm_error(&sb->subdev, "Cannot map Tegra MC registers\n");\r\nreturn PTR_ERR(mc);\r\n}\r\ngsb->wpr_addr = ioread32_native(mc + MC_SECURITY_CARVEOUT2_BOM_0) |\r\n((u64)ioread32_native(mc + MC_SECURITY_CARVEOUT2_BOM_HI_0) << 32);\r\ngsb->wpr_size = ioread32_native(mc + MC_SECURITY_CARVEOUT2_SIZE_128K)\r\n<< 17;\r\ncfg = ioread32_native(mc + MC_SECURITY_CARVEOUT2_CFG0);\r\niounmap(mc);\r\nif (gsb->wpr_size == 0) {\r\nnvkm_error(&sb->subdev, "WPR region is empty\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(cfg & TEGRA_MC_SECURITY_CARVEOUT_CFG_LOCKED)) {\r\nnvkm_error(&sb->subdev, "WPR region not locked\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngm20b_tegra_read_wpr(struct gm200_secboot *gsb)\r\n{\r\nnvkm_error(&gsb->base.subdev, "Tegra support not compiled in\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ngm20b_secboot_init(struct nvkm_secboot *sb)\r\n{\r\nstruct gm200_secboot *gsb = gm200_secboot(sb);\r\nint ret;\r\nret = gm20b_tegra_read_wpr(gsb);\r\nif (ret)\r\nreturn ret;\r\nreturn gm200_secboot_init(sb);\r\n}\r\nint\r\ngm20b_secboot_new(struct nvkm_device *device, int index,\r\nstruct nvkm_secboot **psb)\r\n{\r\nint ret;\r\nstruct gm200_secboot *gsb;\r\ngsb = kzalloc(sizeof(*gsb), GFP_KERNEL);\r\nif (!gsb) {\r\npsb = NULL;\r\nreturn -ENOMEM;\r\n}\r\n*psb = &gsb->base;\r\nret = nvkm_secboot_ctor(&gm20b_secboot, device, index, &gsb->base);\r\nif (ret)\r\nreturn ret;\r\ngsb->func = &gm20b_secboot_func;\r\nreturn 0;\r\n}
