static int i40iw_query_device(struct ib_device *ibdev,\r\nstruct ib_device_attr *props,\r\nstruct ib_udata *udata)\r\n{\r\nstruct i40iw_device *iwdev = to_iwdev(ibdev);\r\nif (udata->inlen || udata->outlen)\r\nreturn -EINVAL;\r\nmemset(props, 0, sizeof(*props));\r\nether_addr_copy((u8 *)&props->sys_image_guid, iwdev->netdev->dev_addr);\r\nprops->fw_ver = I40IW_FW_VERSION;\r\nprops->device_cap_flags = iwdev->device_cap_flags;\r\nprops->vendor_id = iwdev->ldev->pcidev->vendor;\r\nprops->vendor_part_id = iwdev->ldev->pcidev->device;\r\nprops->hw_ver = (u32)iwdev->sc_dev.hw_rev;\r\nprops->max_mr_size = I40IW_MAX_OUTBOUND_MESSAGE_SIZE;\r\nprops->max_qp = iwdev->max_qp;\r\nprops->max_qp_wr = (I40IW_MAX_WQ_ENTRIES >> 2) - 1;\r\nprops->max_sge = I40IW_MAX_WQ_FRAGMENT_COUNT;\r\nprops->max_cq = iwdev->max_cq;\r\nprops->max_cqe = iwdev->max_cqe;\r\nprops->max_mr = iwdev->max_mr;\r\nprops->max_pd = iwdev->max_pd;\r\nprops->max_sge_rd = I40IW_MAX_SGE_RD;\r\nprops->max_qp_rd_atom = I40IW_MAX_IRD_SIZE;\r\nprops->max_qp_init_rd_atom = props->max_qp_rd_atom;\r\nprops->atomic_cap = IB_ATOMIC_NONE;\r\nprops->max_map_per_fmr = 1;\r\nprops->max_fast_reg_page_list_len = I40IW_MAX_PAGES_PER_FMR;\r\nreturn 0;\r\n}\r\nstatic int i40iw_query_port(struct ib_device *ibdev,\r\nu8 port,\r\nstruct ib_port_attr *props)\r\n{\r\nstruct i40iw_device *iwdev = to_iwdev(ibdev);\r\nstruct net_device *netdev = iwdev->netdev;\r\nmemset(props, 0, sizeof(*props));\r\nprops->max_mtu = IB_MTU_4096;\r\nif (netdev->mtu >= 4096)\r\nprops->active_mtu = IB_MTU_4096;\r\nelse if (netdev->mtu >= 2048)\r\nprops->active_mtu = IB_MTU_2048;\r\nelse if (netdev->mtu >= 1024)\r\nprops->active_mtu = IB_MTU_1024;\r\nelse if (netdev->mtu >= 512)\r\nprops->active_mtu = IB_MTU_512;\r\nelse\r\nprops->active_mtu = IB_MTU_256;\r\nprops->lid = 1;\r\nif (netif_carrier_ok(iwdev->netdev))\r\nprops->state = IB_PORT_ACTIVE;\r\nelse\r\nprops->state = IB_PORT_DOWN;\r\nprops->port_cap_flags = IB_PORT_CM_SUP | IB_PORT_REINIT_SUP |\r\nIB_PORT_VENDOR_CLASS_SUP | IB_PORT_BOOT_MGMT_SUP;\r\nprops->gid_tbl_len = 1;\r\nprops->pkey_tbl_len = 1;\r\nprops->active_width = IB_WIDTH_4X;\r\nprops->active_speed = 1;\r\nprops->max_msg_sz = I40IW_MAX_OUTBOUND_MESSAGE_SIZE;\r\nreturn 0;\r\n}\r\nstatic struct ib_ucontext *i40iw_alloc_ucontext(struct ib_device *ibdev,\r\nstruct ib_udata *udata)\r\n{\r\nstruct i40iw_device *iwdev = to_iwdev(ibdev);\r\nstruct i40iw_alloc_ucontext_req req;\r\nstruct i40iw_alloc_ucontext_resp uresp;\r\nstruct i40iw_ucontext *ucontext;\r\nif (ib_copy_from_udata(&req, udata, sizeof(req)))\r\nreturn ERR_PTR(-EINVAL);\r\nif (req.userspace_ver != I40IW_ABI_USERSPACE_VER) {\r\ni40iw_pr_err("Invalid userspace driver version detected. Detected version %d, should be %d\n",\r\nreq.userspace_ver, I40IW_ABI_USERSPACE_VER);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmemset(&uresp, 0, sizeof(uresp));\r\nuresp.max_qps = iwdev->max_qp;\r\nuresp.max_pds = iwdev->max_pd;\r\nuresp.wq_size = iwdev->max_qp_wr * 2;\r\nuresp.kernel_ver = I40IW_ABI_KERNEL_VER;\r\nucontext = kzalloc(sizeof(*ucontext), GFP_KERNEL);\r\nif (!ucontext)\r\nreturn ERR_PTR(-ENOMEM);\r\nucontext->iwdev = iwdev;\r\nif (ib_copy_to_udata(udata, &uresp, sizeof(uresp))) {\r\nkfree(ucontext);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nINIT_LIST_HEAD(&ucontext->cq_reg_mem_list);\r\nspin_lock_init(&ucontext->cq_reg_mem_list_lock);\r\nINIT_LIST_HEAD(&ucontext->qp_reg_mem_list);\r\nspin_lock_init(&ucontext->qp_reg_mem_list_lock);\r\nreturn &ucontext->ibucontext;\r\n}\r\nstatic int i40iw_dealloc_ucontext(struct ib_ucontext *context)\r\n{\r\nstruct i40iw_ucontext *ucontext = to_ucontext(context);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\r\nif (!list_empty(&ucontext->cq_reg_mem_list)) {\r\nspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\r\nspin_lock_irqsave(&ucontext->qp_reg_mem_list_lock, flags);\r\nif (!list_empty(&ucontext->qp_reg_mem_list)) {\r\nspin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);\r\nkfree(ucontext);\r\nreturn 0;\r\n}\r\nstatic int i40iw_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)\r\n{\r\nstruct i40iw_ucontext *ucontext;\r\nu64 db_addr_offset;\r\nu64 push_offset;\r\nucontext = to_ucontext(context);\r\nif (ucontext->iwdev->sc_dev.is_pf) {\r\ndb_addr_offset = I40IW_DB_ADDR_OFFSET;\r\npush_offset = I40IW_PUSH_OFFSET;\r\nif (vma->vm_pgoff)\r\nvma->vm_pgoff += I40IW_PF_FIRST_PUSH_PAGE_INDEX - 1;\r\n} else {\r\ndb_addr_offset = I40IW_VF_DB_ADDR_OFFSET;\r\npush_offset = I40IW_VF_PUSH_OFFSET;\r\nif (vma->vm_pgoff)\r\nvma->vm_pgoff += I40IW_VF_FIRST_PUSH_PAGE_INDEX - 1;\r\n}\r\nvma->vm_pgoff += db_addr_offset >> PAGE_SHIFT;\r\nif (vma->vm_pgoff == (db_addr_offset >> PAGE_SHIFT)) {\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nvma->vm_private_data = ucontext;\r\n} else {\r\nif ((vma->vm_pgoff - (push_offset >> PAGE_SHIFT)) % 2)\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nelse\r\nvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\r\n}\r\nif (io_remap_pfn_range(vma, vma->vm_start,\r\nvma->vm_pgoff + (pci_resource_start(ucontext->iwdev->ldev->pcidev, 0) >> PAGE_SHIFT),\r\nPAGE_SIZE, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic void i40iw_alloc_push_page(struct i40iw_device *iwdev, struct i40iw_sc_qp *qp)\r\n{\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nenum i40iw_status_code status;\r\nif (qp->push_idx != I40IW_INVALID_PUSH_PAGE_INDEX)\r\nreturn;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request)\r\nreturn;\r\natomic_inc(&cqp_request->refcount);\r\ncqp_info = &cqp_request->info;\r\ncqp_info->cqp_cmd = OP_MANAGE_PUSH_PAGE;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.manage_push_page.info.qs_handle = dev->qs_handle;\r\ncqp_info->in.u.manage_push_page.info.free_page = 0;\r\ncqp_info->in.u.manage_push_page.cqp = &iwdev->cqp.sc_cqp;\r\ncqp_info->in.u.manage_push_page.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (!status)\r\nqp->push_idx = cqp_request->compl_info.op_ret_val;\r\nelse\r\ni40iw_pr_err("CQP-OP Push page fail");\r\ni40iw_put_cqp_request(&iwdev->cqp, cqp_request);\r\n}\r\nstatic void i40iw_dealloc_push_page(struct i40iw_device *iwdev, struct i40iw_sc_qp *qp)\r\n{\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nenum i40iw_status_code status;\r\nif (qp->push_idx == I40IW_INVALID_PUSH_PAGE_INDEX)\r\nreturn;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, false);\r\nif (!cqp_request)\r\nreturn;\r\ncqp_info = &cqp_request->info;\r\ncqp_info->cqp_cmd = OP_MANAGE_PUSH_PAGE;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.manage_push_page.info.push_idx = qp->push_idx;\r\ncqp_info->in.u.manage_push_page.info.qs_handle = dev->qs_handle;\r\ncqp_info->in.u.manage_push_page.info.free_page = 1;\r\ncqp_info->in.u.manage_push_page.cqp = &iwdev->cqp.sc_cqp;\r\ncqp_info->in.u.manage_push_page.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (!status)\r\nqp->push_idx = I40IW_INVALID_PUSH_PAGE_INDEX;\r\nelse\r\ni40iw_pr_err("CQP-OP Push page fail");\r\n}\r\nstatic struct ib_pd *i40iw_alloc_pd(struct ib_device *ibdev,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct i40iw_pd *iwpd;\r\nstruct i40iw_device *iwdev = to_iwdev(ibdev);\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_alloc_pd_resp uresp;\r\nstruct i40iw_sc_pd *sc_pd;\r\nu32 pd_id = 0;\r\nint err;\r\nerr = i40iw_alloc_resource(iwdev, iwdev->allocated_pds,\r\niwdev->max_pd, &pd_id, &iwdev->next_pd);\r\nif (err) {\r\ni40iw_pr_err("alloc resource failed\n");\r\nreturn ERR_PTR(err);\r\n}\r\niwpd = kzalloc(sizeof(*iwpd), GFP_KERNEL);\r\nif (!iwpd) {\r\nerr = -ENOMEM;\r\ngoto free_res;\r\n}\r\nsc_pd = &iwpd->sc_pd;\r\ndev->iw_pd_ops->pd_init(dev, sc_pd, pd_id);\r\nif (context) {\r\nmemset(&uresp, 0, sizeof(uresp));\r\nuresp.pd_id = pd_id;\r\nif (ib_copy_to_udata(udata, &uresp, sizeof(uresp))) {\r\nerr = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\ni40iw_add_pdusecount(iwpd);\r\nreturn &iwpd->ibpd;\r\nerror:\r\nkfree(iwpd);\r\nfree_res:\r\ni40iw_free_resource(iwdev, iwdev->allocated_pds, pd_id);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int i40iw_dealloc_pd(struct ib_pd *ibpd)\r\n{\r\nstruct i40iw_pd *iwpd = to_iwpd(ibpd);\r\nstruct i40iw_device *iwdev = to_iwdev(ibpd->device);\r\ni40iw_rem_pdusecount(iwpd, iwdev);\r\nreturn 0;\r\n}\r\nstatic int i40iw_qp_roundup(u32 wr_ring_size)\r\n{\r\nint scount = 1;\r\nif (wr_ring_size < I40IWQP_SW_MIN_WQSIZE)\r\nwr_ring_size = I40IWQP_SW_MIN_WQSIZE;\r\nfor (wr_ring_size--; scount <= 16; scount *= 2)\r\nwr_ring_size |= wr_ring_size >> scount;\r\nreturn ++wr_ring_size;\r\n}\r\nstatic struct i40iw_pbl *i40iw_get_pbl(unsigned long va,\r\nstruct list_head *pbl_list)\r\n{\r\nstruct i40iw_pbl *iwpbl;\r\nlist_for_each_entry(iwpbl, pbl_list, list) {\r\nif (iwpbl->user_base == va) {\r\nlist_del(&iwpbl->list);\r\nreturn iwpbl;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid i40iw_free_qp_resources(struct i40iw_device *iwdev,\r\nstruct i40iw_qp *iwqp,\r\nu32 qp_num)\r\n{\r\ni40iw_dealloc_push_page(iwdev, &iwqp->sc_qp);\r\nif (qp_num)\r\ni40iw_free_resource(iwdev, iwdev->allocated_qps, qp_num);\r\ni40iw_free_dma_mem(iwdev->sc_dev.hw, &iwqp->q2_ctx_mem);\r\ni40iw_free_dma_mem(iwdev->sc_dev.hw, &iwqp->kqp.dma_mem);\r\nkfree(iwqp->kqp.wrid_mem);\r\niwqp->kqp.wrid_mem = NULL;\r\nkfree(iwqp->allocated_buffer);\r\n}\r\nstatic void i40iw_clean_cqes(struct i40iw_qp *iwqp, struct i40iw_cq *iwcq)\r\n{\r\nstruct i40iw_cq_uk *ukcq = &iwcq->sc_cq.cq_uk;\r\nukcq->ops.iw_cq_clean(&iwqp->sc_qp.qp_uk, ukcq);\r\n}\r\nstatic int i40iw_destroy_qp(struct ib_qp *ibqp)\r\n{\r\nstruct i40iw_qp *iwqp = to_iwqp(ibqp);\r\niwqp->destroyed = 1;\r\nif (iwqp->ibqp_state >= IB_QPS_INIT && iwqp->ibqp_state < IB_QPS_RTS)\r\ni40iw_next_iw_state(iwqp, I40IW_QP_STATE_ERROR, 0, 0, 0);\r\nif (!iwqp->user_mode) {\r\nif (iwqp->iwscq) {\r\ni40iw_clean_cqes(iwqp, iwqp->iwscq);\r\nif (iwqp->iwrcq != iwqp->iwscq)\r\ni40iw_clean_cqes(iwqp, iwqp->iwrcq);\r\n}\r\n}\r\ni40iw_rem_ref(&iwqp->ibqp);\r\nreturn 0;\r\n}\r\nstatic int i40iw_setup_virt_qp(struct i40iw_device *iwdev,\r\nstruct i40iw_qp *iwqp,\r\nstruct i40iw_qp_init_info *init_info)\r\n{\r\nstruct i40iw_pbl *iwpbl = iwqp->iwpbl;\r\nstruct i40iw_qp_mr *qpmr = &iwpbl->qp_mr;\r\niwqp->page = qpmr->sq_page;\r\ninit_info->shadow_area_pa = cpu_to_le64(qpmr->shadow);\r\nif (iwpbl->pbl_allocated) {\r\ninit_info->virtual_map = true;\r\ninit_info->sq_pa = qpmr->sq_pbl.idx;\r\ninit_info->rq_pa = qpmr->rq_pbl.idx;\r\n} else {\r\ninit_info->sq_pa = qpmr->sq_pbl.addr;\r\ninit_info->rq_pa = qpmr->rq_pbl.addr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i40iw_setup_kmode_qp(struct i40iw_device *iwdev,\r\nstruct i40iw_qp *iwqp,\r\nstruct i40iw_qp_init_info *info)\r\n{\r\nstruct i40iw_dma_mem *mem = &iwqp->kqp.dma_mem;\r\nu32 sqdepth, rqdepth;\r\nu32 sq_size, rq_size;\r\nu8 sqshift, rqshift;\r\nu32 size;\r\nenum i40iw_status_code status;\r\nstruct i40iw_qp_uk_init_info *ukinfo = &info->qp_uk_init_info;\r\nsq_size = i40iw_qp_roundup(ukinfo->sq_size + 1);\r\nrq_size = i40iw_qp_roundup(ukinfo->rq_size + 1);\r\nstatus = i40iw_get_wqe_shift(sq_size, ukinfo->max_sq_frag_cnt, ukinfo->max_inline_data, &sqshift);\r\nif (!status)\r\nstatus = i40iw_get_wqe_shift(rq_size, ukinfo->max_rq_frag_cnt, 0, &rqshift);\r\nif (status)\r\nreturn -ENOMEM;\r\nsqdepth = sq_size << sqshift;\r\nrqdepth = rq_size << rqshift;\r\nsize = sqdepth * sizeof(struct i40iw_sq_uk_wr_trk_info) + (rqdepth << 3);\r\niwqp->kqp.wrid_mem = kzalloc(size, GFP_KERNEL);\r\nukinfo->sq_wrtrk_array = (struct i40iw_sq_uk_wr_trk_info *)iwqp->kqp.wrid_mem;\r\nif (!ukinfo->sq_wrtrk_array)\r\nreturn -ENOMEM;\r\nukinfo->rq_wrid_array = (u64 *)&ukinfo->sq_wrtrk_array[sqdepth];\r\nsize = (sqdepth + rqdepth) * I40IW_QP_WQE_MIN_SIZE;\r\nsize += (I40IW_SHADOW_AREA_SIZE << 3);\r\nstatus = i40iw_allocate_dma_mem(iwdev->sc_dev.hw, mem, size, 256);\r\nif (status) {\r\nkfree(ukinfo->sq_wrtrk_array);\r\nukinfo->sq_wrtrk_array = NULL;\r\nreturn -ENOMEM;\r\n}\r\nukinfo->sq = mem->va;\r\ninfo->sq_pa = mem->pa;\r\nukinfo->rq = &ukinfo->sq[sqdepth];\r\ninfo->rq_pa = info->sq_pa + (sqdepth * I40IW_QP_WQE_MIN_SIZE);\r\nukinfo->shadow_area = ukinfo->rq[rqdepth].elem;\r\ninfo->shadow_area_pa = info->rq_pa + (rqdepth * I40IW_QP_WQE_MIN_SIZE);\r\nukinfo->sq_size = sq_size;\r\nukinfo->rq_size = rq_size;\r\nukinfo->qp_id = iwqp->ibqp.qp_num;\r\nreturn 0;\r\n}\r\nstatic struct ib_qp *i40iw_create_qp(struct ib_pd *ibpd,\r\nstruct ib_qp_init_attr *init_attr,\r\nstruct ib_udata *udata)\r\n{\r\nstruct i40iw_pd *iwpd = to_iwpd(ibpd);\r\nstruct i40iw_device *iwdev = to_iwdev(ibpd->device);\r\nstruct i40iw_cqp *iwcqp = &iwdev->cqp;\r\nstruct i40iw_qp *iwqp;\r\nstruct i40iw_ucontext *ucontext;\r\nstruct i40iw_create_qp_req req;\r\nstruct i40iw_create_qp_resp uresp;\r\nu32 qp_num = 0;\r\nvoid *mem;\r\nenum i40iw_status_code ret;\r\nint err_code;\r\nint sq_size;\r\nint rq_size;\r\nstruct i40iw_sc_qp *qp;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_qp_init_info init_info;\r\nstruct i40iw_create_qp_info *qp_info;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_qp_host_ctx_info *ctx_info;\r\nstruct i40iwarp_offload_info *iwarp_info;\r\nunsigned long flags;\r\nif (init_attr->create_flags)\r\nreturn ERR_PTR(-EINVAL);\r\nif (init_attr->cap.max_inline_data > I40IW_MAX_INLINE_DATA_SIZE)\r\ninit_attr->cap.max_inline_data = I40IW_MAX_INLINE_DATA_SIZE;\r\nif (init_attr->cap.max_send_sge > I40IW_MAX_WQ_FRAGMENT_COUNT)\r\ninit_attr->cap.max_send_sge = I40IW_MAX_WQ_FRAGMENT_COUNT;\r\nmemset(&init_info, 0, sizeof(init_info));\r\nsq_size = init_attr->cap.max_send_wr;\r\nrq_size = init_attr->cap.max_recv_wr;\r\ninit_info.qp_uk_init_info.sq_size = sq_size;\r\ninit_info.qp_uk_init_info.rq_size = rq_size;\r\ninit_info.qp_uk_init_info.max_sq_frag_cnt = init_attr->cap.max_send_sge;\r\ninit_info.qp_uk_init_info.max_rq_frag_cnt = init_attr->cap.max_recv_sge;\r\ninit_info.qp_uk_init_info.max_inline_data = init_attr->cap.max_inline_data;\r\nmem = kzalloc(sizeof(*iwqp), GFP_KERNEL);\r\nif (!mem)\r\nreturn ERR_PTR(-ENOMEM);\r\niwqp = (struct i40iw_qp *)mem;\r\nqp = &iwqp->sc_qp;\r\nqp->back_qp = (void *)iwqp;\r\nqp->push_idx = I40IW_INVALID_PUSH_PAGE_INDEX;\r\niwqp->ctx_info.iwarp_info = &iwqp->iwarp_info;\r\nif (i40iw_allocate_dma_mem(dev->hw,\r\n&iwqp->q2_ctx_mem,\r\nI40IW_Q2_BUFFER_SIZE + I40IW_QP_CTX_SIZE,\r\n256)) {\r\ni40iw_pr_err("dma_mem failed\n");\r\nerr_code = -ENOMEM;\r\ngoto error;\r\n}\r\ninit_info.q2 = iwqp->q2_ctx_mem.va;\r\ninit_info.q2_pa = iwqp->q2_ctx_mem.pa;\r\ninit_info.host_ctx = (void *)init_info.q2 + I40IW_Q2_BUFFER_SIZE;\r\ninit_info.host_ctx_pa = init_info.q2_pa + I40IW_Q2_BUFFER_SIZE;\r\nerr_code = i40iw_alloc_resource(iwdev, iwdev->allocated_qps, iwdev->max_qp,\r\n&qp_num, &iwdev->next_qp);\r\nif (err_code) {\r\ni40iw_pr_err("qp resource\n");\r\ngoto error;\r\n}\r\niwqp->allocated_buffer = mem;\r\niwqp->iwdev = iwdev;\r\niwqp->iwpd = iwpd;\r\niwqp->ibqp.qp_num = qp_num;\r\nqp = &iwqp->sc_qp;\r\niwqp->iwscq = to_iwcq(init_attr->send_cq);\r\niwqp->iwrcq = to_iwcq(init_attr->recv_cq);\r\niwqp->host_ctx.va = init_info.host_ctx;\r\niwqp->host_ctx.pa = init_info.host_ctx_pa;\r\niwqp->host_ctx.size = I40IW_QP_CTX_SIZE;\r\ninit_info.pd = &iwpd->sc_pd;\r\ninit_info.qp_uk_init_info.qp_id = iwqp->ibqp.qp_num;\r\niwqp->ctx_info.qp_compl_ctx = (uintptr_t)qp;\r\nif (init_attr->qp_type != IB_QPT_RC) {\r\nerr_code = -EINVAL;\r\ngoto error;\r\n}\r\nif (iwdev->push_mode)\r\ni40iw_alloc_push_page(iwdev, qp);\r\nif (udata) {\r\nerr_code = ib_copy_from_udata(&req, udata, sizeof(req));\r\nif (err_code) {\r\ni40iw_pr_err("ib_copy_from_data\n");\r\ngoto error;\r\n}\r\niwqp->ctx_info.qp_compl_ctx = req.user_compl_ctx;\r\nif (ibpd->uobject && ibpd->uobject->context) {\r\niwqp->user_mode = 1;\r\nucontext = to_ucontext(ibpd->uobject->context);\r\nif (req.user_wqe_buffers) {\r\nspin_lock_irqsave(\r\n&ucontext->qp_reg_mem_list_lock, flags);\r\niwqp->iwpbl = i40iw_get_pbl(\r\n(unsigned long)req.user_wqe_buffers,\r\n&ucontext->qp_reg_mem_list);\r\nspin_unlock_irqrestore(\r\n&ucontext->qp_reg_mem_list_lock, flags);\r\nif (!iwqp->iwpbl) {\r\nerr_code = -ENODATA;\r\ni40iw_pr_err("no pbl info\n");\r\ngoto error;\r\n}\r\n}\r\n}\r\nerr_code = i40iw_setup_virt_qp(iwdev, iwqp, &init_info);\r\n} else {\r\nerr_code = i40iw_setup_kmode_qp(iwdev, iwqp, &init_info);\r\n}\r\nif (err_code) {\r\ni40iw_pr_err("setup qp failed\n");\r\ngoto error;\r\n}\r\ninit_info.type = I40IW_QP_TYPE_IWARP;\r\nret = dev->iw_priv_qp_ops->qp_init(qp, &init_info);\r\nif (ret) {\r\nerr_code = -EPROTO;\r\ni40iw_pr_err("qp_init fail\n");\r\ngoto error;\r\n}\r\nctx_info = &iwqp->ctx_info;\r\niwarp_info = &iwqp->iwarp_info;\r\niwarp_info->rd_enable = true;\r\niwarp_info->wr_rdresp_en = true;\r\nif (!iwqp->user_mode) {\r\niwarp_info->fast_reg_en = true;\r\niwarp_info->priv_mode_en = true;\r\n}\r\niwarp_info->ddp_ver = 1;\r\niwarp_info->rdmap_ver = 1;\r\nctx_info->iwarp_info_valid = true;\r\nctx_info->send_cq_num = iwqp->iwscq->sc_cq.cq_uk.cq_id;\r\nctx_info->rcv_cq_num = iwqp->iwrcq->sc_cq.cq_uk.cq_id;\r\nif (qp->push_idx == I40IW_INVALID_PUSH_PAGE_INDEX) {\r\nctx_info->push_mode_en = false;\r\n} else {\r\nctx_info->push_mode_en = true;\r\nctx_info->push_idx = qp->push_idx;\r\n}\r\nret = dev->iw_priv_qp_ops->qp_setctx(&iwqp->sc_qp,\r\n(u64 *)iwqp->host_ctx.va,\r\nctx_info);\r\nctx_info->iwarp_info_valid = false;\r\ncqp_request = i40iw_get_cqp_request(iwcqp, true);\r\nif (!cqp_request) {\r\nerr_code = -ENOMEM;\r\ngoto error;\r\n}\r\ncqp_info = &cqp_request->info;\r\nqp_info = &cqp_request->info.in.u.qp_create.info;\r\nmemset(qp_info, 0, sizeof(*qp_info));\r\nqp_info->cq_num_valid = true;\r\nqp_info->next_iwarp_state = I40IW_QP_STATE_IDLE;\r\ncqp_info->cqp_cmd = OP_QP_CREATE;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.qp_create.qp = qp;\r\ncqp_info->in.u.qp_create.scratch = (uintptr_t)cqp_request;\r\nret = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (ret) {\r\ni40iw_pr_err("CQP-OP QP create fail");\r\nerr_code = -EACCES;\r\ngoto error;\r\n}\r\ni40iw_add_ref(&iwqp->ibqp);\r\nspin_lock_init(&iwqp->lock);\r\niwqp->sig_all = (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) ? 1 : 0;\r\niwdev->qp_table[qp_num] = iwqp;\r\ni40iw_add_pdusecount(iwqp->iwpd);\r\nif (ibpd->uobject && udata) {\r\nmemset(&uresp, 0, sizeof(uresp));\r\nuresp.actual_sq_size = sq_size;\r\nuresp.actual_rq_size = rq_size;\r\nuresp.qp_id = qp_num;\r\nuresp.push_idx = qp->push_idx;\r\nerr_code = ib_copy_to_udata(udata, &uresp, sizeof(uresp));\r\nif (err_code) {\r\ni40iw_pr_err("copy_to_udata failed\n");\r\ni40iw_destroy_qp(&iwqp->ibqp);\r\nreturn ERR_PTR(err_code);\r\n}\r\n}\r\ninit_completion(&iwqp->sq_drained);\r\ninit_completion(&iwqp->rq_drained);\r\nreturn &iwqp->ibqp;\r\nerror:\r\ni40iw_free_qp_resources(iwdev, iwqp, qp_num);\r\nreturn ERR_PTR(err_code);\r\n}\r\nstatic int i40iw_query_qp(struct ib_qp *ibqp,\r\nstruct ib_qp_attr *attr,\r\nint attr_mask,\r\nstruct ib_qp_init_attr *init_attr)\r\n{\r\nstruct i40iw_qp *iwqp = to_iwqp(ibqp);\r\nstruct i40iw_sc_qp *qp = &iwqp->sc_qp;\r\nattr->qp_access_flags = 0;\r\nattr->cap.max_send_wr = qp->qp_uk.sq_size;\r\nattr->cap.max_recv_wr = qp->qp_uk.rq_size;\r\nattr->cap.max_recv_sge = 1;\r\nattr->cap.max_inline_data = I40IW_MAX_INLINE_DATA_SIZE;\r\ninit_attr->event_handler = iwqp->ibqp.event_handler;\r\ninit_attr->qp_context = iwqp->ibqp.qp_context;\r\ninit_attr->send_cq = iwqp->ibqp.send_cq;\r\ninit_attr->recv_cq = iwqp->ibqp.recv_cq;\r\ninit_attr->srq = iwqp->ibqp.srq;\r\ninit_attr->cap = attr->cap;\r\nreturn 0;\r\n}\r\nvoid i40iw_hw_modify_qp(struct i40iw_device *iwdev, struct i40iw_qp *iwqp,\r\nstruct i40iw_modify_qp_info *info, bool wait)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_modify_qp_info *m_info;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, wait);\r\nif (!cqp_request)\r\nreturn;\r\ncqp_info = &cqp_request->info;\r\nm_info = &cqp_info->in.u.qp_modify.info;\r\nmemcpy(m_info, info, sizeof(*m_info));\r\ncqp_info->cqp_cmd = OP_QP_MODIFY;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.qp_modify.qp = &iwqp->sc_qp;\r\ncqp_info->in.u.qp_modify.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Modify QP fail");\r\n}\r\nint i40iw_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\r\nint attr_mask, struct ib_udata *udata)\r\n{\r\nstruct i40iw_qp *iwqp = to_iwqp(ibqp);\r\nstruct i40iw_device *iwdev = iwqp->iwdev;\r\nstruct i40iw_qp_host_ctx_info *ctx_info;\r\nstruct i40iwarp_offload_info *iwarp_info;\r\nstruct i40iw_modify_qp_info info;\r\nu8 issue_modify_qp = 0;\r\nu8 dont_wait = 0;\r\nu32 err;\r\nunsigned long flags;\r\nmemset(&info, 0, sizeof(info));\r\nctx_info = &iwqp->ctx_info;\r\niwarp_info = &iwqp->iwarp_info;\r\nspin_lock_irqsave(&iwqp->lock, flags);\r\nif (attr_mask & IB_QP_STATE) {\r\nswitch (attr->qp_state) {\r\ncase IB_QPS_INIT:\r\ncase IB_QPS_RTR:\r\nif (iwqp->iwarp_state > (u32)I40IW_QP_STATE_IDLE) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nif (iwqp->iwarp_state == I40IW_QP_STATE_INVALID) {\r\ninfo.next_iwarp_state = I40IW_QP_STATE_IDLE;\r\nissue_modify_qp = 1;\r\n}\r\nbreak;\r\ncase IB_QPS_RTS:\r\nif ((iwqp->iwarp_state > (u32)I40IW_QP_STATE_RTS) ||\r\n(!iwqp->cm_id)) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nissue_modify_qp = 1;\r\niwqp->hw_tcp_state = I40IW_TCP_STATE_ESTABLISHED;\r\niwqp->hte_added = 1;\r\ninfo.next_iwarp_state = I40IW_QP_STATE_RTS;\r\ninfo.tcp_ctx_valid = true;\r\ninfo.ord_valid = true;\r\ninfo.arp_cache_idx_valid = true;\r\ninfo.cq_num_valid = true;\r\nbreak;\r\ncase IB_QPS_SQD:\r\nif (iwqp->hw_iwarp_state > (u32)I40IW_QP_STATE_RTS) {\r\nerr = 0;\r\ngoto exit;\r\n}\r\nif ((iwqp->iwarp_state == (u32)I40IW_QP_STATE_CLOSING) ||\r\n(iwqp->iwarp_state < (u32)I40IW_QP_STATE_RTS)) {\r\nerr = 0;\r\ngoto exit;\r\n}\r\nif (iwqp->iwarp_state > (u32)I40IW_QP_STATE_CLOSING) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\ninfo.next_iwarp_state = I40IW_QP_STATE_CLOSING;\r\nissue_modify_qp = 1;\r\nbreak;\r\ncase IB_QPS_SQE:\r\nif (iwqp->iwarp_state >= (u32)I40IW_QP_STATE_TERMINATE) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\ninfo.next_iwarp_state = I40IW_QP_STATE_TERMINATE;\r\nissue_modify_qp = 1;\r\nbreak;\r\ncase IB_QPS_ERR:\r\ncase IB_QPS_RESET:\r\nif (iwqp->iwarp_state == (u32)I40IW_QP_STATE_ERROR) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nif (iwqp->sc_qp.term_flags)\r\ndel_timer(&iwqp->terminate_timer);\r\ninfo.next_iwarp_state = I40IW_QP_STATE_ERROR;\r\nif ((iwqp->hw_tcp_state > I40IW_TCP_STATE_CLOSED) &&\r\niwdev->iw_status &&\r\n(iwqp->hw_tcp_state != I40IW_TCP_STATE_TIME_WAIT))\r\ninfo.reset_tcp_conn = true;\r\nelse\r\ndont_wait = 1;\r\nissue_modify_qp = 1;\r\ninfo.next_iwarp_state = I40IW_QP_STATE_ERROR;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\niwqp->ibqp_state = attr->qp_state;\r\nif (issue_modify_qp)\r\niwqp->iwarp_state = info.next_iwarp_state;\r\nelse\r\ninfo.next_iwarp_state = iwqp->iwarp_state;\r\n}\r\nif (attr_mask & IB_QP_ACCESS_FLAGS) {\r\nctx_info->iwarp_info_valid = true;\r\nif (attr->qp_access_flags & IB_ACCESS_LOCAL_WRITE)\r\niwarp_info->wr_rdresp_en = true;\r\nif (attr->qp_access_flags & IB_ACCESS_REMOTE_WRITE)\r\niwarp_info->wr_rdresp_en = true;\r\nif (attr->qp_access_flags & IB_ACCESS_REMOTE_READ)\r\niwarp_info->rd_enable = true;\r\nif (attr->qp_access_flags & IB_ACCESS_MW_BIND)\r\niwarp_info->bind_en = true;\r\nif (iwqp->user_mode) {\r\niwarp_info->rd_enable = true;\r\niwarp_info->wr_rdresp_en = true;\r\niwarp_info->priv_mode_en = false;\r\n}\r\n}\r\nif (ctx_info->iwarp_info_valid) {\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nint ret;\r\nctx_info->send_cq_num = iwqp->iwscq->sc_cq.cq_uk.cq_id;\r\nctx_info->rcv_cq_num = iwqp->iwrcq->sc_cq.cq_uk.cq_id;\r\nret = dev->iw_priv_qp_ops->qp_setctx(&iwqp->sc_qp,\r\n(u64 *)iwqp->host_ctx.va,\r\nctx_info);\r\nif (ret) {\r\ni40iw_pr_err("setting QP context\n");\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\n}\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\nif (issue_modify_qp)\r\ni40iw_hw_modify_qp(iwdev, iwqp, &info, true);\r\nif (issue_modify_qp && (iwqp->ibqp_state > IB_QPS_RTS)) {\r\nif (dont_wait) {\r\nif (iwqp->cm_id && iwqp->hw_tcp_state) {\r\nspin_lock_irqsave(&iwqp->lock, flags);\r\niwqp->hw_tcp_state = I40IW_TCP_STATE_CLOSED;\r\niwqp->last_aeq = I40IW_AE_RESET_SENT;\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\n}\r\n}\r\n}\r\nreturn 0;\r\nexit:\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\nreturn err;\r\n}\r\nstatic void cq_free_resources(struct i40iw_device *iwdev, struct i40iw_cq *iwcq)\r\n{\r\nstruct i40iw_sc_cq *cq = &iwcq->sc_cq;\r\nif (!iwcq->user_mode)\r\ni40iw_free_dma_mem(iwdev->sc_dev.hw, &iwcq->kmem);\r\ni40iw_free_resource(iwdev, iwdev->allocated_cqs, cq->cq_uk.cq_id);\r\n}\r\nstatic void cq_wq_destroy(struct i40iw_device *iwdev, struct i40iw_sc_cq *cq)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request)\r\nreturn;\r\ncqp_info = &cqp_request->info;\r\ncqp_info->cqp_cmd = OP_CQ_DESTROY;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.cq_destroy.cq = cq;\r\ncqp_info->in.u.cq_destroy.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Destroy QP fail");\r\n}\r\nstatic int i40iw_destroy_cq(struct ib_cq *ib_cq)\r\n{\r\nstruct i40iw_cq *iwcq;\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_sc_cq *cq;\r\nif (!ib_cq) {\r\ni40iw_pr_err("ib_cq == NULL\n");\r\nreturn 0;\r\n}\r\niwcq = to_iwcq(ib_cq);\r\niwdev = to_iwdev(ib_cq->device);\r\ncq = &iwcq->sc_cq;\r\ncq_wq_destroy(iwdev, cq);\r\ncq_free_resources(iwdev, iwcq);\r\nkfree(iwcq);\r\nreturn 0;\r\n}\r\nstatic struct ib_cq *i40iw_create_cq(struct ib_device *ibdev,\r\nconst struct ib_cq_init_attr *attr,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct i40iw_device *iwdev = to_iwdev(ibdev);\r\nstruct i40iw_cq *iwcq;\r\nstruct i40iw_pbl *iwpbl;\r\nu32 cq_num = 0;\r\nstruct i40iw_sc_cq *cq;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_cq_init_info info;\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_cq_uk_init_info *ukinfo = &info.cq_uk_init_info;\r\nunsigned long flags;\r\nint err_code;\r\nint entries = attr->cqe;\r\nif (entries > iwdev->max_cqe)\r\nreturn ERR_PTR(-EINVAL);\r\niwcq = kzalloc(sizeof(*iwcq), GFP_KERNEL);\r\nif (!iwcq)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemset(&info, 0, sizeof(info));\r\nerr_code = i40iw_alloc_resource(iwdev, iwdev->allocated_cqs,\r\niwdev->max_cq, &cq_num,\r\n&iwdev->next_cq);\r\nif (err_code)\r\ngoto error;\r\ncq = &iwcq->sc_cq;\r\ncq->back_cq = (void *)iwcq;\r\nspin_lock_init(&iwcq->lock);\r\ninfo.dev = dev;\r\nukinfo->cq_size = max(entries, 4);\r\nukinfo->cq_id = cq_num;\r\niwcq->ibcq.cqe = info.cq_uk_init_info.cq_size;\r\ninfo.ceqe_mask = 0;\r\ninfo.ceq_id = 0;\r\ninfo.ceq_id_valid = true;\r\ninfo.ceqe_mask = 1;\r\ninfo.type = I40IW_CQ_TYPE_IWARP;\r\nif (context) {\r\nstruct i40iw_ucontext *ucontext;\r\nstruct i40iw_create_cq_req req;\r\nstruct i40iw_cq_mr *cqmr;\r\nmemset(&req, 0, sizeof(req));\r\niwcq->user_mode = true;\r\nucontext = to_ucontext(context);\r\nif (ib_copy_from_udata(&req, udata, sizeof(struct i40iw_create_cq_req)))\r\ngoto cq_free_resources;\r\nspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\r\niwpbl = i40iw_get_pbl((unsigned long)req.user_cq_buffer,\r\n&ucontext->cq_reg_mem_list);\r\nspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\r\nif (!iwpbl) {\r\nerr_code = -EPROTO;\r\ngoto cq_free_resources;\r\n}\r\niwcq->iwpbl = iwpbl;\r\niwcq->cq_mem_size = 0;\r\ncqmr = &iwpbl->cq_mr;\r\ninfo.shadow_area_pa = cpu_to_le64(cqmr->shadow);\r\nif (iwpbl->pbl_allocated) {\r\ninfo.virtual_map = true;\r\ninfo.pbl_chunk_size = 1;\r\ninfo.first_pm_pbl_idx = cqmr->cq_pbl.idx;\r\n} else {\r\ninfo.cq_base_pa = cqmr->cq_pbl.addr;\r\n}\r\n} else {\r\nint rsize;\r\nint shadow;\r\nrsize = info.cq_uk_init_info.cq_size * sizeof(struct i40iw_cqe);\r\nrsize = round_up(rsize, 256);\r\nshadow = I40IW_SHADOW_AREA_SIZE << 3;\r\nstatus = i40iw_allocate_dma_mem(dev->hw, &iwcq->kmem,\r\nrsize + shadow, 256);\r\nif (status) {\r\nerr_code = -ENOMEM;\r\ngoto cq_free_resources;\r\n}\r\nukinfo->cq_base = iwcq->kmem.va;\r\ninfo.cq_base_pa = iwcq->kmem.pa;\r\ninfo.shadow_area_pa = info.cq_base_pa + rsize;\r\nukinfo->shadow_area = iwcq->kmem.va + rsize;\r\n}\r\nif (dev->iw_priv_cq_ops->cq_init(cq, &info)) {\r\ni40iw_pr_err("init cq fail\n");\r\nerr_code = -EPROTO;\r\ngoto cq_free_resources;\r\n}\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request) {\r\nerr_code = -ENOMEM;\r\ngoto cq_free_resources;\r\n}\r\ncqp_info = &cqp_request->info;\r\ncqp_info->cqp_cmd = OP_CQ_CREATE;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.cq_create.cq = cq;\r\ncqp_info->in.u.cq_create.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status) {\r\ni40iw_pr_err("CQP-OP Create QP fail");\r\nerr_code = -EPROTO;\r\ngoto cq_free_resources;\r\n}\r\nif (context) {\r\nstruct i40iw_create_cq_resp resp;\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.cq_id = info.cq_uk_init_info.cq_id;\r\nresp.cq_size = info.cq_uk_init_info.cq_size;\r\nif (ib_copy_to_udata(udata, &resp, sizeof(resp))) {\r\ni40iw_pr_err("copy to user data\n");\r\nerr_code = -EPROTO;\r\ngoto cq_destroy;\r\n}\r\n}\r\nreturn (struct ib_cq *)iwcq;\r\ncq_destroy:\r\ncq_wq_destroy(iwdev, cq);\r\ncq_free_resources:\r\ncq_free_resources(iwdev, iwcq);\r\nerror:\r\nkfree(iwcq);\r\nreturn ERR_PTR(err_code);\r\n}\r\nstatic inline u16 i40iw_get_user_access(int acc)\r\n{\r\nu16 access = 0;\r\naccess |= (acc & IB_ACCESS_LOCAL_WRITE) ? I40IW_ACCESS_FLAGS_LOCALWRITE : 0;\r\naccess |= (acc & IB_ACCESS_REMOTE_WRITE) ? I40IW_ACCESS_FLAGS_REMOTEWRITE : 0;\r\naccess |= (acc & IB_ACCESS_REMOTE_READ) ? I40IW_ACCESS_FLAGS_REMOTEREAD : 0;\r\naccess |= (acc & IB_ACCESS_MW_BIND) ? I40IW_ACCESS_FLAGS_BIND_WINDOW : 0;\r\nreturn access;\r\n}\r\nstatic void i40iw_free_stag(struct i40iw_device *iwdev, u32 stag)\r\n{\r\nu32 stag_idx;\r\nstag_idx = (stag & iwdev->mr_stagmask) >> I40IW_CQPSQ_STAG_IDX_SHIFT;\r\ni40iw_free_resource(iwdev, iwdev->allocated_mrs, stag_idx);\r\n}\r\nstatic u32 i40iw_create_stag(struct i40iw_device *iwdev)\r\n{\r\nu32 stag = 0;\r\nu32 stag_index = 0;\r\nu32 next_stag_index;\r\nu32 driver_key;\r\nu32 random;\r\nu8 consumer_key;\r\nint ret;\r\nget_random_bytes(&random, sizeof(random));\r\nconsumer_key = (u8)random;\r\ndriver_key = random & ~iwdev->mr_stagmask;\r\nnext_stag_index = (random & iwdev->mr_stagmask) >> 8;\r\nnext_stag_index %= iwdev->max_mr;\r\nret = i40iw_alloc_resource(iwdev,\r\niwdev->allocated_mrs, iwdev->max_mr,\r\n&stag_index, &next_stag_index);\r\nif (!ret) {\r\nstag = stag_index << I40IW_CQPSQ_STAG_IDX_SHIFT;\r\nstag |= driver_key;\r\nstag += (u32)consumer_key;\r\n}\r\nreturn stag;\r\n}\r\nstatic inline u64 *i40iw_next_pbl_addr(struct i40iw_pble_alloc *palloc,\r\nu64 *pbl,\r\nstruct i40iw_pble_info **pinfo,\r\nu32 *idx)\r\n{\r\n*idx += 1;\r\nif ((!(*pinfo)) || (*idx != (*pinfo)->cnt))\r\nreturn ++pbl;\r\n*idx = 0;\r\n(*pinfo)++;\r\nreturn (u64 *)(*pinfo)->addr;\r\n}\r\nstatic void i40iw_copy_user_pgaddrs(struct i40iw_mr *iwmr,\r\nu64 *pbl,\r\nenum i40iw_pble_level level)\r\n{\r\nstruct ib_umem *region = iwmr->region;\r\nstruct i40iw_pbl *iwpbl = &iwmr->iwpbl;\r\nint chunk_pages, entry, pg_shift, i;\r\nstruct i40iw_pble_alloc *palloc = &iwpbl->pble_alloc;\r\nstruct i40iw_pble_info *pinfo;\r\nstruct scatterlist *sg;\r\nu32 idx = 0;\r\npinfo = (level == I40IW_LEVEL_1) ? NULL : palloc->level2.leaf;\r\npg_shift = ffs(region->page_size) - 1;\r\nfor_each_sg(region->sg_head.sgl, sg, region->nmap, entry) {\r\nchunk_pages = sg_dma_len(sg) >> pg_shift;\r\nif ((iwmr->type == IW_MEMREG_TYPE_QP) &&\r\n!iwpbl->qp_mr.sq_page)\r\niwpbl->qp_mr.sq_page = sg_page(sg);\r\nfor (i = 0; i < chunk_pages; i++) {\r\n*pbl = cpu_to_le64(sg_dma_address(sg) + region->page_size * i);\r\npbl = i40iw_next_pbl_addr(palloc, pbl, &pinfo, &idx);\r\n}\r\n}\r\n}\r\nstatic int i40iw_setup_pbles(struct i40iw_device *iwdev,\r\nstruct i40iw_mr *iwmr,\r\nbool use_pbles)\r\n{\r\nstruct i40iw_pbl *iwpbl = &iwmr->iwpbl;\r\nstruct i40iw_pble_alloc *palloc = &iwpbl->pble_alloc;\r\nstruct i40iw_pble_info *pinfo;\r\nu64 *pbl;\r\nenum i40iw_status_code status;\r\nenum i40iw_pble_level level = I40IW_LEVEL_1;\r\nif (!use_pbles && (iwmr->page_cnt > MAX_SAVE_PAGE_ADDRS))\r\nreturn -ENOMEM;\r\nif (use_pbles) {\r\nmutex_lock(&iwdev->pbl_mutex);\r\nstatus = i40iw_get_pble(&iwdev->sc_dev, iwdev->pble_rsrc, palloc, iwmr->page_cnt);\r\nmutex_unlock(&iwdev->pbl_mutex);\r\nif (status)\r\nreturn -ENOMEM;\r\niwpbl->pbl_allocated = true;\r\nlevel = palloc->level;\r\npinfo = (level == I40IW_LEVEL_1) ? &palloc->level1 : palloc->level2.leaf;\r\npbl = (u64 *)pinfo->addr;\r\n} else {\r\npbl = iwmr->pgaddrmem;\r\n}\r\ni40iw_copy_user_pgaddrs(iwmr, pbl, level);\r\nreturn 0;\r\n}\r\nstatic int i40iw_handle_q_mem(struct i40iw_device *iwdev,\r\nstruct i40iw_mem_reg_req *req,\r\nstruct i40iw_pbl *iwpbl,\r\nbool use_pbles)\r\n{\r\nstruct i40iw_pble_alloc *palloc = &iwpbl->pble_alloc;\r\nstruct i40iw_mr *iwmr = iwpbl->iwmr;\r\nstruct i40iw_qp_mr *qpmr = &iwpbl->qp_mr;\r\nstruct i40iw_cq_mr *cqmr = &iwpbl->cq_mr;\r\nstruct i40iw_hmc_pble *hmc_p;\r\nu64 *arr = iwmr->pgaddrmem;\r\nint err;\r\nint total;\r\ntotal = req->sq_pages + req->rq_pages + req->cq_pages;\r\nerr = i40iw_setup_pbles(iwdev, iwmr, use_pbles);\r\nif (err)\r\nreturn err;\r\nif (use_pbles && (palloc->level != I40IW_LEVEL_1)) {\r\ni40iw_free_pble(iwdev->pble_rsrc, palloc);\r\niwpbl->pbl_allocated = false;\r\nreturn -ENOMEM;\r\n}\r\nif (use_pbles)\r\narr = (u64 *)palloc->level1.addr;\r\nif (req->reg_type == IW_MEMREG_TYPE_QP) {\r\nhmc_p = &qpmr->sq_pbl;\r\nqpmr->shadow = (dma_addr_t)arr[total];\r\nif (use_pbles) {\r\nhmc_p->idx = palloc->level1.idx;\r\nhmc_p = &qpmr->rq_pbl;\r\nhmc_p->idx = palloc->level1.idx + req->sq_pages;\r\n} else {\r\nhmc_p->addr = arr[0];\r\nhmc_p = &qpmr->rq_pbl;\r\nhmc_p->addr = arr[1];\r\n}\r\n} else {\r\nhmc_p = &cqmr->cq_pbl;\r\ncqmr->shadow = (dma_addr_t)arr[total];\r\nif (use_pbles)\r\nhmc_p->idx = palloc->level1.idx;\r\nelse\r\nhmc_p->addr = arr[0];\r\n}\r\nreturn err;\r\n}\r\nstatic int i40iw_hw_alloc_stag(struct i40iw_device *iwdev, struct i40iw_mr *iwmr)\r\n{\r\nstruct i40iw_allocate_stag_info *info;\r\nstruct i40iw_pd *iwpd = to_iwpd(iwmr->ibmr.pd);\r\nenum i40iw_status_code status;\r\nint err = 0;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request)\r\nreturn -ENOMEM;\r\ncqp_info = &cqp_request->info;\r\ninfo = &cqp_info->in.u.alloc_stag.info;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->page_size = PAGE_SIZE;\r\ninfo->stag_idx = iwmr->stag >> I40IW_CQPSQ_STAG_IDX_SHIFT;\r\ninfo->pd_id = iwpd->sc_pd.pd_id;\r\ninfo->total_len = iwmr->length;\r\ninfo->remote_access = true;\r\ncqp_info->cqp_cmd = OP_ALLOC_STAG;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.alloc_stag.dev = &iwdev->sc_dev;\r\ncqp_info->in.u.alloc_stag.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status) {\r\nerr = -ENOMEM;\r\ni40iw_pr_err("CQP-OP MR Reg fail");\r\n}\r\nreturn err;\r\n}\r\nstatic struct ib_mr *i40iw_alloc_mr(struct ib_pd *pd,\r\nenum ib_mr_type mr_type,\r\nu32 max_num_sg)\r\n{\r\nstruct i40iw_pd *iwpd = to_iwpd(pd);\r\nstruct i40iw_device *iwdev = to_iwdev(pd->device);\r\nstruct i40iw_pble_alloc *palloc;\r\nstruct i40iw_pbl *iwpbl;\r\nstruct i40iw_mr *iwmr;\r\nenum i40iw_status_code status;\r\nu32 stag;\r\nint err_code = -ENOMEM;\r\niwmr = kzalloc(sizeof(*iwmr), GFP_KERNEL);\r\nif (!iwmr)\r\nreturn ERR_PTR(-ENOMEM);\r\nstag = i40iw_create_stag(iwdev);\r\nif (!stag) {\r\nerr_code = -EOVERFLOW;\r\ngoto err;\r\n}\r\niwmr->stag = stag;\r\niwmr->ibmr.rkey = stag;\r\niwmr->ibmr.lkey = stag;\r\niwmr->ibmr.pd = pd;\r\niwmr->ibmr.device = pd->device;\r\niwpbl = &iwmr->iwpbl;\r\niwpbl->iwmr = iwmr;\r\niwmr->type = IW_MEMREG_TYPE_MEM;\r\npalloc = &iwpbl->pble_alloc;\r\niwmr->page_cnt = max_num_sg;\r\nmutex_lock(&iwdev->pbl_mutex);\r\nstatus = i40iw_get_pble(&iwdev->sc_dev, iwdev->pble_rsrc, palloc, iwmr->page_cnt);\r\nmutex_unlock(&iwdev->pbl_mutex);\r\nif (status)\r\ngoto err1;\r\nif (palloc->level != I40IW_LEVEL_1)\r\ngoto err2;\r\nerr_code = i40iw_hw_alloc_stag(iwdev, iwmr);\r\nif (err_code)\r\ngoto err2;\r\niwpbl->pbl_allocated = true;\r\ni40iw_add_pdusecount(iwpd);\r\nreturn &iwmr->ibmr;\r\nerr2:\r\ni40iw_free_pble(iwdev->pble_rsrc, palloc);\r\nerr1:\r\ni40iw_free_stag(iwdev, stag);\r\nerr:\r\nkfree(iwmr);\r\nreturn ERR_PTR(err_code);\r\n}\r\nstatic int i40iw_set_page(struct ib_mr *ibmr, u64 addr)\r\n{\r\nstruct i40iw_mr *iwmr = to_iwmr(ibmr);\r\nstruct i40iw_pbl *iwpbl = &iwmr->iwpbl;\r\nstruct i40iw_pble_alloc *palloc = &iwpbl->pble_alloc;\r\nu64 *pbl;\r\nif (unlikely(iwmr->npages == iwmr->page_cnt))\r\nreturn -ENOMEM;\r\npbl = (u64 *)palloc->level1.addr;\r\npbl[iwmr->npages++] = cpu_to_le64(addr);\r\nreturn 0;\r\n}\r\nstatic int i40iw_map_mr_sg(struct ib_mr *ibmr, struct scatterlist *sg,\r\nint sg_nents, unsigned int *sg_offset)\r\n{\r\nstruct i40iw_mr *iwmr = to_iwmr(ibmr);\r\niwmr->npages = 0;\r\nreturn ib_sg_to_pages(ibmr, sg, sg_nents, sg_offset, i40iw_set_page);\r\n}\r\nstatic void i40iw_drain_sq(struct ib_qp *ibqp)\r\n{\r\nstruct i40iw_qp *iwqp = to_iwqp(ibqp);\r\nstruct i40iw_sc_qp *qp = &iwqp->sc_qp;\r\nif (I40IW_RING_MORE_WORK(qp->qp_uk.sq_ring))\r\nwait_for_completion(&iwqp->sq_drained);\r\n}\r\nstatic void i40iw_drain_rq(struct ib_qp *ibqp)\r\n{\r\nstruct i40iw_qp *iwqp = to_iwqp(ibqp);\r\nstruct i40iw_sc_qp *qp = &iwqp->sc_qp;\r\nif (I40IW_RING_MORE_WORK(qp->qp_uk.rq_ring))\r\nwait_for_completion(&iwqp->rq_drained);\r\n}\r\nstatic int i40iw_hwreg_mr(struct i40iw_device *iwdev,\r\nstruct i40iw_mr *iwmr,\r\nu16 access)\r\n{\r\nstruct i40iw_pbl *iwpbl = &iwmr->iwpbl;\r\nstruct i40iw_reg_ns_stag_info *stag_info;\r\nstruct i40iw_pd *iwpd = to_iwpd(iwmr->ibmr.pd);\r\nstruct i40iw_pble_alloc *palloc = &iwpbl->pble_alloc;\r\nenum i40iw_status_code status;\r\nint err = 0;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request)\r\nreturn -ENOMEM;\r\ncqp_info = &cqp_request->info;\r\nstag_info = &cqp_info->in.u.mr_reg_non_shared.info;\r\nmemset(stag_info, 0, sizeof(*stag_info));\r\nstag_info->va = (void *)(unsigned long)iwpbl->user_base;\r\nstag_info->stag_idx = iwmr->stag >> I40IW_CQPSQ_STAG_IDX_SHIFT;\r\nstag_info->stag_key = (u8)iwmr->stag;\r\nstag_info->total_len = iwmr->length;\r\nstag_info->access_rights = access;\r\nstag_info->pd_id = iwpd->sc_pd.pd_id;\r\nstag_info->addr_type = I40IW_ADDR_TYPE_VA_BASED;\r\nif (iwmr->page_cnt > 1) {\r\nif (palloc->level == I40IW_LEVEL_1) {\r\nstag_info->first_pm_pbl_index = palloc->level1.idx;\r\nstag_info->chunk_size = 1;\r\n} else {\r\nstag_info->first_pm_pbl_index = palloc->level2.root.idx;\r\nstag_info->chunk_size = 3;\r\n}\r\n} else {\r\nstag_info->reg_addr_pa = iwmr->pgaddrmem[0];\r\n}\r\ncqp_info->cqp_cmd = OP_MR_REG_NON_SHARED;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.mr_reg_non_shared.dev = &iwdev->sc_dev;\r\ncqp_info->in.u.mr_reg_non_shared.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status) {\r\nerr = -ENOMEM;\r\ni40iw_pr_err("CQP-OP MR Reg fail");\r\n}\r\nreturn err;\r\n}\r\nstatic struct ib_mr *i40iw_reg_user_mr(struct ib_pd *pd,\r\nu64 start,\r\nu64 length,\r\nu64 virt,\r\nint acc,\r\nstruct ib_udata *udata)\r\n{\r\nstruct i40iw_pd *iwpd = to_iwpd(pd);\r\nstruct i40iw_device *iwdev = to_iwdev(pd->device);\r\nstruct i40iw_ucontext *ucontext;\r\nstruct i40iw_pble_alloc *palloc;\r\nstruct i40iw_pbl *iwpbl;\r\nstruct i40iw_mr *iwmr;\r\nstruct ib_umem *region;\r\nstruct i40iw_mem_reg_req req;\r\nu64 pbl_depth = 0;\r\nu32 stag = 0;\r\nu16 access;\r\nu64 region_length;\r\nbool use_pbles = false;\r\nunsigned long flags;\r\nint err = -ENOSYS;\r\nif (length > I40IW_MAX_MR_SIZE)\r\nreturn ERR_PTR(-EINVAL);\r\nregion = ib_umem_get(pd->uobject->context, start, length, acc, 0);\r\nif (IS_ERR(region))\r\nreturn (struct ib_mr *)region;\r\nif (ib_copy_from_udata(&req, udata, sizeof(req))) {\r\nib_umem_release(region);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\niwmr = kzalloc(sizeof(*iwmr), GFP_KERNEL);\r\nif (!iwmr) {\r\nib_umem_release(region);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\niwpbl = &iwmr->iwpbl;\r\niwpbl->iwmr = iwmr;\r\niwmr->region = region;\r\niwmr->ibmr.pd = pd;\r\niwmr->ibmr.device = pd->device;\r\nucontext = to_ucontext(pd->uobject->context);\r\nregion_length = region->length + (start & 0xfff);\r\npbl_depth = region_length >> 12;\r\npbl_depth += (region_length & (4096 - 1)) ? 1 : 0;\r\niwmr->length = region->length;\r\niwpbl->user_base = virt;\r\npalloc = &iwpbl->pble_alloc;\r\niwmr->type = req.reg_type;\r\niwmr->page_cnt = (u32)pbl_depth;\r\nswitch (req.reg_type) {\r\ncase IW_MEMREG_TYPE_QP:\r\nuse_pbles = ((req.sq_pages + req.rq_pages) > 2);\r\nerr = i40iw_handle_q_mem(iwdev, &req, iwpbl, use_pbles);\r\nif (err)\r\ngoto error;\r\nspin_lock_irqsave(&ucontext->qp_reg_mem_list_lock, flags);\r\nlist_add_tail(&iwpbl->list, &ucontext->qp_reg_mem_list);\r\nspin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);\r\nbreak;\r\ncase IW_MEMREG_TYPE_CQ:\r\nuse_pbles = (req.cq_pages > 1);\r\nerr = i40iw_handle_q_mem(iwdev, &req, iwpbl, use_pbles);\r\nif (err)\r\ngoto error;\r\nspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\r\nlist_add_tail(&iwpbl->list, &ucontext->cq_reg_mem_list);\r\nspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\r\nbreak;\r\ncase IW_MEMREG_TYPE_MEM:\r\naccess = I40IW_ACCESS_FLAGS_LOCALREAD;\r\nuse_pbles = (iwmr->page_cnt != 1);\r\nerr = i40iw_setup_pbles(iwdev, iwmr, use_pbles);\r\nif (err)\r\ngoto error;\r\naccess |= i40iw_get_user_access(acc);\r\nstag = i40iw_create_stag(iwdev);\r\nif (!stag) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\niwmr->stag = stag;\r\niwmr->ibmr.rkey = stag;\r\niwmr->ibmr.lkey = stag;\r\nerr = i40iw_hwreg_mr(iwdev, iwmr, access);\r\nif (err) {\r\ni40iw_free_stag(iwdev, stag);\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\niwmr->type = req.reg_type;\r\nif (req.reg_type == IW_MEMREG_TYPE_MEM)\r\ni40iw_add_pdusecount(iwpd);\r\nreturn &iwmr->ibmr;\r\nerror:\r\nif (palloc->level != I40IW_LEVEL_0)\r\ni40iw_free_pble(iwdev->pble_rsrc, palloc);\r\nib_umem_release(region);\r\nkfree(iwmr);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct ib_mr *i40iw_reg_phys_mr(struct ib_pd *pd,\r\nu64 addr,\r\nu64 size,\r\nint acc,\r\nu64 *iova_start)\r\n{\r\nstruct i40iw_pd *iwpd = to_iwpd(pd);\r\nstruct i40iw_device *iwdev = to_iwdev(pd->device);\r\nstruct i40iw_pbl *iwpbl;\r\nstruct i40iw_mr *iwmr;\r\nenum i40iw_status_code status;\r\nu32 stag;\r\nu16 access = I40IW_ACCESS_FLAGS_LOCALREAD;\r\nint ret;\r\niwmr = kzalloc(sizeof(*iwmr), GFP_KERNEL);\r\nif (!iwmr)\r\nreturn ERR_PTR(-ENOMEM);\r\niwmr->ibmr.pd = pd;\r\niwmr->ibmr.device = pd->device;\r\niwpbl = &iwmr->iwpbl;\r\niwpbl->iwmr = iwmr;\r\niwmr->type = IW_MEMREG_TYPE_MEM;\r\niwpbl->user_base = *iova_start;\r\nstag = i40iw_create_stag(iwdev);\r\nif (!stag) {\r\nret = -EOVERFLOW;\r\ngoto err;\r\n}\r\naccess |= i40iw_get_user_access(acc);\r\niwmr->stag = stag;\r\niwmr->ibmr.rkey = stag;\r\niwmr->ibmr.lkey = stag;\r\niwmr->page_cnt = 1;\r\niwmr->pgaddrmem[0] = addr;\r\niwmr->length = size;\r\nstatus = i40iw_hwreg_mr(iwdev, iwmr, access);\r\nif (status) {\r\ni40iw_free_stag(iwdev, stag);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ni40iw_add_pdusecount(iwpd);\r\nreturn &iwmr->ibmr;\r\nerr:\r\nkfree(iwmr);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct ib_mr *i40iw_get_dma_mr(struct ib_pd *pd, int acc)\r\n{\r\nu64 kva = 0;\r\nreturn i40iw_reg_phys_mr(pd, 0, 0, acc, &kva);\r\n}\r\nstatic void i40iw_del_memlist(struct i40iw_mr *iwmr,\r\nstruct i40iw_ucontext *ucontext)\r\n{\r\nstruct i40iw_pbl *iwpbl = &iwmr->iwpbl;\r\nunsigned long flags;\r\nswitch (iwmr->type) {\r\ncase IW_MEMREG_TYPE_CQ:\r\nspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\r\nif (!list_empty(&ucontext->cq_reg_mem_list))\r\nlist_del(&iwpbl->list);\r\nspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\r\nbreak;\r\ncase IW_MEMREG_TYPE_QP:\r\nspin_lock_irqsave(&ucontext->qp_reg_mem_list_lock, flags);\r\nif (!list_empty(&ucontext->qp_reg_mem_list))\r\nlist_del(&iwpbl->list);\r\nspin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int i40iw_dereg_mr(struct ib_mr *ib_mr)\r\n{\r\nstruct ib_pd *ibpd = ib_mr->pd;\r\nstruct i40iw_pd *iwpd = to_iwpd(ibpd);\r\nstruct i40iw_mr *iwmr = to_iwmr(ib_mr);\r\nstruct i40iw_device *iwdev = to_iwdev(ib_mr->device);\r\nenum i40iw_status_code status;\r\nstruct i40iw_dealloc_stag_info *info;\r\nstruct i40iw_pbl *iwpbl = &iwmr->iwpbl;\r\nstruct i40iw_pble_alloc *palloc = &iwpbl->pble_alloc;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nu32 stag_idx;\r\nif (iwmr->region)\r\nib_umem_release(iwmr->region);\r\nif (iwmr->type != IW_MEMREG_TYPE_MEM) {\r\nif (ibpd->uobject) {\r\nstruct i40iw_ucontext *ucontext;\r\nucontext = to_ucontext(ibpd->uobject->context);\r\ni40iw_del_memlist(iwmr, ucontext);\r\n}\r\nif (iwpbl->pbl_allocated)\r\ni40iw_free_pble(iwdev->pble_rsrc, palloc);\r\nkfree(iwmr);\r\nreturn 0;\r\n}\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request)\r\nreturn -ENOMEM;\r\ncqp_info = &cqp_request->info;\r\ninfo = &cqp_info->in.u.dealloc_stag.info;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->pd_id = cpu_to_le32(iwpd->sc_pd.pd_id & 0x00007fff);\r\ninfo->stag_idx = RS_64_1(ib_mr->rkey, I40IW_CQPSQ_STAG_IDX_SHIFT);\r\nstag_idx = info->stag_idx;\r\ninfo->mr = true;\r\nif (iwpbl->pbl_allocated)\r\ninfo->dealloc_pbl = true;\r\ncqp_info->cqp_cmd = OP_DEALLOC_STAG;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.dealloc_stag.dev = &iwdev->sc_dev;\r\ncqp_info->in.u.dealloc_stag.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP dealloc failed for stag_idx = 0x%x\n", stag_idx);\r\ni40iw_rem_pdusecount(iwpd, iwdev);\r\ni40iw_free_stag(iwdev, iwmr->stag);\r\nif (iwpbl->pbl_allocated)\r\ni40iw_free_pble(iwdev->pble_rsrc, palloc);\r\nkfree(iwmr);\r\nreturn 0;\r\n}\r\nstatic ssize_t i40iw_show_rev(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i40iw_ib_device *iwibdev = container_of(dev,\r\nstruct i40iw_ib_device,\r\nibdev.dev);\r\nu32 hw_rev = iwibdev->iwdev->sc_dev.hw_rev;\r\nreturn sprintf(buf, "%x\n", hw_rev);\r\n}\r\nstatic ssize_t i40iw_show_hca(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "I40IW\n");\r\n}\r\nstatic ssize_t i40iw_show_board(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%.*s\n", 32, "I40IW Board ID");\r\n}\r\nstatic void i40iw_copy_sg_list(struct i40iw_sge *sg_list, struct ib_sge *sgl, int num_sges)\r\n{\r\nunsigned int i;\r\nfor (i = 0; (i < num_sges) && (i < I40IW_MAX_WQ_FRAGMENT_COUNT); i++) {\r\nsg_list[i].tag_off = sgl[i].addr;\r\nsg_list[i].len = sgl[i].length;\r\nsg_list[i].stag = sgl[i].lkey;\r\n}\r\n}\r\nstatic int i40iw_post_send(struct ib_qp *ibqp,\r\nstruct ib_send_wr *ib_wr,\r\nstruct ib_send_wr **bad_wr)\r\n{\r\nstruct i40iw_qp *iwqp;\r\nstruct i40iw_qp_uk *ukqp;\r\nstruct i40iw_post_sq_info info;\r\nenum i40iw_status_code ret;\r\nint err = 0;\r\nunsigned long flags;\r\nbool inv_stag;\r\niwqp = (struct i40iw_qp *)ibqp;\r\nukqp = &iwqp->sc_qp.qp_uk;\r\nspin_lock_irqsave(&iwqp->lock, flags);\r\nwhile (ib_wr) {\r\ninv_stag = false;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.wr_id = (u64)(ib_wr->wr_id);\r\nif ((ib_wr->send_flags & IB_SEND_SIGNALED) || iwqp->sig_all)\r\ninfo.signaled = true;\r\nif (ib_wr->send_flags & IB_SEND_FENCE)\r\ninfo.read_fence = true;\r\nswitch (ib_wr->opcode) {\r\ncase IB_WR_SEND:\r\ncase IB_WR_SEND_WITH_INV:\r\nif (ib_wr->opcode == IB_WR_SEND) {\r\nif (ib_wr->send_flags & IB_SEND_SOLICITED)\r\ninfo.op_type = I40IW_OP_TYPE_SEND_SOL;\r\nelse\r\ninfo.op_type = I40IW_OP_TYPE_SEND;\r\n} else {\r\nif (ib_wr->send_flags & IB_SEND_SOLICITED)\r\ninfo.op_type = I40IW_OP_TYPE_SEND_SOL_INV;\r\nelse\r\ninfo.op_type = I40IW_OP_TYPE_SEND_INV;\r\n}\r\nif (ib_wr->send_flags & IB_SEND_INLINE) {\r\ninfo.op.inline_send.data = (void *)(unsigned long)ib_wr->sg_list[0].addr;\r\ninfo.op.inline_send.len = ib_wr->sg_list[0].length;\r\nret = ukqp->ops.iw_inline_send(ukqp, &info, ib_wr->ex.invalidate_rkey, false);\r\n} else {\r\ninfo.op.send.num_sges = ib_wr->num_sge;\r\ninfo.op.send.sg_list = (struct i40iw_sge *)ib_wr->sg_list;\r\nret = ukqp->ops.iw_send(ukqp, &info, ib_wr->ex.invalidate_rkey, false);\r\n}\r\nif (ret) {\r\nif (ret == I40IW_ERR_QP_TOOMANY_WRS_POSTED)\r\nerr = -ENOMEM;\r\nelse\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\ncase IB_WR_RDMA_WRITE:\r\ninfo.op_type = I40IW_OP_TYPE_RDMA_WRITE;\r\nif (ib_wr->send_flags & IB_SEND_INLINE) {\r\ninfo.op.inline_rdma_write.data = (void *)(unsigned long)ib_wr->sg_list[0].addr;\r\ninfo.op.inline_rdma_write.len = ib_wr->sg_list[0].length;\r\ninfo.op.inline_rdma_write.rem_addr.tag_off = rdma_wr(ib_wr)->remote_addr;\r\ninfo.op.inline_rdma_write.rem_addr.stag = rdma_wr(ib_wr)->rkey;\r\ninfo.op.inline_rdma_write.rem_addr.len = ib_wr->sg_list->length;\r\nret = ukqp->ops.iw_inline_rdma_write(ukqp, &info, false);\r\n} else {\r\ninfo.op.rdma_write.lo_sg_list = (void *)ib_wr->sg_list;\r\ninfo.op.rdma_write.num_lo_sges = ib_wr->num_sge;\r\ninfo.op.rdma_write.rem_addr.tag_off = rdma_wr(ib_wr)->remote_addr;\r\ninfo.op.rdma_write.rem_addr.stag = rdma_wr(ib_wr)->rkey;\r\ninfo.op.rdma_write.rem_addr.len = ib_wr->sg_list->length;\r\nret = ukqp->ops.iw_rdma_write(ukqp, &info, false);\r\n}\r\nif (ret) {\r\nif (ret == I40IW_ERR_QP_TOOMANY_WRS_POSTED)\r\nerr = -ENOMEM;\r\nelse\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\ncase IB_WR_RDMA_READ_WITH_INV:\r\ninv_stag = true;\r\ncase IB_WR_RDMA_READ:\r\nif (ib_wr->num_sge > I40IW_MAX_SGE_RD) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ninfo.op_type = I40IW_OP_TYPE_RDMA_READ;\r\ninfo.op.rdma_read.rem_addr.tag_off = rdma_wr(ib_wr)->remote_addr;\r\ninfo.op.rdma_read.rem_addr.stag = rdma_wr(ib_wr)->rkey;\r\ninfo.op.rdma_read.rem_addr.len = ib_wr->sg_list->length;\r\ninfo.op.rdma_read.lo_addr.tag_off = ib_wr->sg_list->addr;\r\ninfo.op.rdma_read.lo_addr.stag = ib_wr->sg_list->lkey;\r\ninfo.op.rdma_read.lo_addr.len = ib_wr->sg_list->length;\r\nret = ukqp->ops.iw_rdma_read(ukqp, &info, inv_stag, false);\r\nif (ret) {\r\nif (ret == I40IW_ERR_QP_TOOMANY_WRS_POSTED)\r\nerr = -ENOMEM;\r\nelse\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\ncase IB_WR_LOCAL_INV:\r\ninfo.op_type = I40IW_OP_TYPE_INV_STAG;\r\ninfo.op.inv_local_stag.target_stag = ib_wr->ex.invalidate_rkey;\r\nret = ukqp->ops.iw_stag_local_invalidate(ukqp, &info, true);\r\nif (ret)\r\nerr = -ENOMEM;\r\nbreak;\r\ncase IB_WR_REG_MR:\r\n{\r\nstruct i40iw_mr *iwmr = to_iwmr(reg_wr(ib_wr)->mr);\r\nint page_shift = ilog2(reg_wr(ib_wr)->mr->page_size);\r\nint flags = reg_wr(ib_wr)->access;\r\nstruct i40iw_pble_alloc *palloc = &iwmr->iwpbl.pble_alloc;\r\nstruct i40iw_sc_dev *dev = &iwqp->iwdev->sc_dev;\r\nstruct i40iw_fast_reg_stag_info info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.access_rights = I40IW_ACCESS_FLAGS_LOCALREAD;\r\ninfo.access_rights |= i40iw_get_user_access(flags);\r\ninfo.stag_key = reg_wr(ib_wr)->key & 0xff;\r\ninfo.stag_idx = reg_wr(ib_wr)->key >> 8;\r\ninfo.wr_id = ib_wr->wr_id;\r\ninfo.addr_type = I40IW_ADDR_TYPE_VA_BASED;\r\ninfo.va = (void *)(uintptr_t)iwmr->ibmr.iova;\r\ninfo.total_len = iwmr->ibmr.length;\r\ninfo.reg_addr_pa = *(u64 *)palloc->level1.addr;\r\ninfo.first_pm_pbl_index = palloc->level1.idx;\r\ninfo.local_fence = ib_wr->send_flags & IB_SEND_FENCE;\r\ninfo.signaled = ib_wr->send_flags & IB_SEND_SIGNALED;\r\nif (iwmr->npages > I40IW_MIN_PAGES_PER_FMR)\r\ninfo.chunk_size = 1;\r\nif (page_shift == 21)\r\ninfo.page_size = 1;\r\nret = dev->iw_priv_qp_ops->iw_mr_fast_register(&iwqp->sc_qp, &info, true);\r\nif (ret)\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\ni40iw_pr_err(" upost_send bad opcode = 0x%x\n",\r\nib_wr->opcode);\r\nbreak;\r\n}\r\nif (err)\r\nbreak;\r\nib_wr = ib_wr->next;\r\n}\r\nif (err)\r\n*bad_wr = ib_wr;\r\nelse\r\nukqp->ops.iw_qp_post_wr(ukqp);\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\nreturn err;\r\n}\r\nstatic int i40iw_post_recv(struct ib_qp *ibqp,\r\nstruct ib_recv_wr *ib_wr,\r\nstruct ib_recv_wr **bad_wr)\r\n{\r\nstruct i40iw_qp *iwqp;\r\nstruct i40iw_qp_uk *ukqp;\r\nstruct i40iw_post_rq_info post_recv;\r\nstruct i40iw_sge sg_list[I40IW_MAX_WQ_FRAGMENT_COUNT];\r\nenum i40iw_status_code ret = 0;\r\nunsigned long flags;\r\nint err = 0;\r\niwqp = (struct i40iw_qp *)ibqp;\r\nukqp = &iwqp->sc_qp.qp_uk;\r\nmemset(&post_recv, 0, sizeof(post_recv));\r\nspin_lock_irqsave(&iwqp->lock, flags);\r\nwhile (ib_wr) {\r\npost_recv.num_sges = ib_wr->num_sge;\r\npost_recv.wr_id = ib_wr->wr_id;\r\ni40iw_copy_sg_list(sg_list, ib_wr->sg_list, ib_wr->num_sge);\r\npost_recv.sg_list = sg_list;\r\nret = ukqp->ops.iw_post_receive(ukqp, &post_recv);\r\nif (ret) {\r\ni40iw_pr_err(" post_recv err %d\n", ret);\r\nif (ret == I40IW_ERR_QP_TOOMANY_WRS_POSTED)\r\nerr = -ENOMEM;\r\nelse\r\nerr = -EINVAL;\r\n*bad_wr = ib_wr;\r\ngoto out;\r\n}\r\nib_wr = ib_wr->next;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\nreturn err;\r\n}\r\nstatic int i40iw_poll_cq(struct ib_cq *ibcq,\r\nint num_entries,\r\nstruct ib_wc *entry)\r\n{\r\nstruct i40iw_cq *iwcq;\r\nint cqe_count = 0;\r\nstruct i40iw_cq_poll_info cq_poll_info;\r\nenum i40iw_status_code ret;\r\nstruct i40iw_cq_uk *ukcq;\r\nstruct i40iw_sc_qp *qp;\r\nstruct i40iw_qp *iwqp;\r\nunsigned long flags;\r\niwcq = (struct i40iw_cq *)ibcq;\r\nukcq = &iwcq->sc_cq.cq_uk;\r\nspin_lock_irqsave(&iwcq->lock, flags);\r\nwhile (cqe_count < num_entries) {\r\nret = ukcq->ops.iw_cq_poll_completion(ukcq, &cq_poll_info);\r\nif (ret == I40IW_ERR_QUEUE_EMPTY) {\r\nbreak;\r\n} else if (ret == I40IW_ERR_QUEUE_DESTROYED) {\r\ncontinue;\r\n} else if (ret) {\r\nif (!cqe_count)\r\ncqe_count = -1;\r\nbreak;\r\n}\r\nentry->wc_flags = 0;\r\nentry->wr_id = cq_poll_info.wr_id;\r\nif (cq_poll_info.error) {\r\nentry->status = IB_WC_WR_FLUSH_ERR;\r\nentry->vendor_err = cq_poll_info.major_err << 16 | cq_poll_info.minor_err;\r\n} else {\r\nentry->status = IB_WC_SUCCESS;\r\n}\r\nswitch (cq_poll_info.op_type) {\r\ncase I40IW_OP_TYPE_RDMA_WRITE:\r\nentry->opcode = IB_WC_RDMA_WRITE;\r\nbreak;\r\ncase I40IW_OP_TYPE_RDMA_READ_INV_STAG:\r\ncase I40IW_OP_TYPE_RDMA_READ:\r\nentry->opcode = IB_WC_RDMA_READ;\r\nbreak;\r\ncase I40IW_OP_TYPE_SEND_SOL:\r\ncase I40IW_OP_TYPE_SEND_SOL_INV:\r\ncase I40IW_OP_TYPE_SEND_INV:\r\ncase I40IW_OP_TYPE_SEND:\r\nentry->opcode = IB_WC_SEND;\r\nbreak;\r\ncase I40IW_OP_TYPE_REC:\r\nentry->opcode = IB_WC_RECV;\r\nbreak;\r\ndefault:\r\nentry->opcode = IB_WC_RECV;\r\nbreak;\r\n}\r\nentry->ex.imm_data = 0;\r\nqp = (struct i40iw_sc_qp *)cq_poll_info.qp_handle;\r\nentry->qp = (struct ib_qp *)qp->back_qp;\r\nentry->src_qp = cq_poll_info.qp_id;\r\niwqp = (struct i40iw_qp *)qp->back_qp;\r\nif (iwqp->iwarp_state > I40IW_QP_STATE_RTS) {\r\nif (!I40IW_RING_MORE_WORK(qp->qp_uk.sq_ring))\r\ncomplete(&iwqp->sq_drained);\r\nif (!I40IW_RING_MORE_WORK(qp->qp_uk.rq_ring))\r\ncomplete(&iwqp->rq_drained);\r\n}\r\nentry->byte_len = cq_poll_info.bytes_xfered;\r\nentry++;\r\ncqe_count++;\r\n}\r\nspin_unlock_irqrestore(&iwcq->lock, flags);\r\nreturn cqe_count;\r\n}\r\nstatic int i40iw_req_notify_cq(struct ib_cq *ibcq,\r\nenum ib_cq_notify_flags notify_flags)\r\n{\r\nstruct i40iw_cq *iwcq;\r\nstruct i40iw_cq_uk *ukcq;\r\nunsigned long flags;\r\nenum i40iw_completion_notify cq_notify = IW_CQ_COMPL_EVENT;\r\niwcq = (struct i40iw_cq *)ibcq;\r\nukcq = &iwcq->sc_cq.cq_uk;\r\nif (notify_flags == IB_CQ_SOLICITED)\r\ncq_notify = IW_CQ_COMPL_SOLICITED;\r\nspin_lock_irqsave(&iwcq->lock, flags);\r\nukcq->ops.iw_cq_request_notification(ukcq, cq_notify);\r\nspin_unlock_irqrestore(&iwcq->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int i40iw_port_immutable(struct ib_device *ibdev, u8 port_num,\r\nstruct ib_port_immutable *immutable)\r\n{\r\nstruct ib_port_attr attr;\r\nint err;\r\nerr = i40iw_query_port(ibdev, port_num, &attr);\r\nif (err)\r\nreturn err;\r\nimmutable->pkey_tbl_len = attr.pkey_tbl_len;\r\nimmutable->gid_tbl_len = attr.gid_tbl_len;\r\nimmutable->core_cap_flags = RDMA_CORE_PORT_IWARP;\r\nreturn 0;\r\n}\r\nstatic void i40iw_get_dev_fw_str(struct ib_device *dev, char *str,\r\nsize_t str_len)\r\n{\r\nu32 firmware_version = I40IW_FW_VERSION;\r\nsnprintf(str, str_len, "%u.%u", firmware_version,\r\n(firmware_version & 0x000000ff));\r\n}\r\nstatic struct rdma_hw_stats *i40iw_alloc_hw_stats(struct ib_device *ibdev,\r\nu8 port_num)\r\n{\r\nstruct i40iw_device *iwdev = to_iwdev(ibdev);\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nint num_counters = I40IW_HW_STAT_INDEX_MAX_32 +\r\nI40IW_HW_STAT_INDEX_MAX_64;\r\nunsigned long lifespan = RDMA_HW_STATS_DEFAULT_LIFESPAN;\r\nBUILD_BUG_ON(ARRAY_SIZE(i40iw_hw_stat_names) !=\r\n(I40IW_HW_STAT_INDEX_MAX_32 +\r\nI40IW_HW_STAT_INDEX_MAX_64));\r\nif (!dev->is_pf)\r\nlifespan = 1000;\r\nreturn rdma_alloc_hw_stats_struct(i40iw_hw_stat_names, num_counters,\r\nlifespan);\r\n}\r\nstatic int i40iw_get_hw_stats(struct ib_device *ibdev,\r\nstruct rdma_hw_stats *stats,\r\nu8 port_num, int index)\r\n{\r\nstruct i40iw_device *iwdev = to_iwdev(ibdev);\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_dev_pestat *devstat = &dev->dev_pestat;\r\nstruct i40iw_dev_hw_stats *hw_stats = &devstat->hw_stats;\r\nunsigned long flags;\r\nif (dev->is_pf) {\r\nspin_lock_irqsave(&devstat->stats_lock, flags);\r\ndevstat->ops.iw_hw_stat_read_all(devstat,\r\n&devstat->hw_stats);\r\nspin_unlock_irqrestore(&devstat->stats_lock, flags);\r\n} else {\r\nif (i40iw_vchnl_vf_get_pe_stats(dev, &devstat->hw_stats))\r\nreturn -ENOSYS;\r\n}\r\nmemcpy(&stats->value[0], &hw_stats, sizeof(*hw_stats));\r\nreturn stats->num_counters;\r\n}\r\nstatic int i40iw_query_gid(struct ib_device *ibdev,\r\nu8 port,\r\nint index,\r\nunion ib_gid *gid)\r\n{\r\nstruct i40iw_device *iwdev = to_iwdev(ibdev);\r\nmemset(gid->raw, 0, sizeof(gid->raw));\r\nether_addr_copy(gid->raw, iwdev->netdev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int i40iw_modify_port(struct ib_device *ibdev,\r\nu8 port,\r\nint port_modify_mask,\r\nstruct ib_port_modify *props)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int i40iw_query_pkey(struct ib_device *ibdev,\r\nu8 port,\r\nu16 index,\r\nu16 *pkey)\r\n{\r\n*pkey = 0;\r\nreturn 0;\r\n}\r\nstatic struct ib_ah *i40iw_create_ah(struct ib_pd *ibpd,\r\nstruct ib_ah_attr *attr)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic int i40iw_destroy_ah(struct ib_ah *ah)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic struct i40iw_ib_device *i40iw_init_rdma_device(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_ib_device *iwibdev;\r\nstruct net_device *netdev = iwdev->netdev;\r\nstruct pci_dev *pcidev = (struct pci_dev *)iwdev->hw.dev_context;\r\niwibdev = (struct i40iw_ib_device *)ib_alloc_device(sizeof(*iwibdev));\r\nif (!iwibdev) {\r\ni40iw_pr_err("iwdev == NULL\n");\r\nreturn NULL;\r\n}\r\nstrlcpy(iwibdev->ibdev.name, "i40iw%d", IB_DEVICE_NAME_MAX);\r\niwibdev->ibdev.owner = THIS_MODULE;\r\niwdev->iwibdev = iwibdev;\r\niwibdev->iwdev = iwdev;\r\niwibdev->ibdev.node_type = RDMA_NODE_RNIC;\r\nether_addr_copy((u8 *)&iwibdev->ibdev.node_guid, netdev->dev_addr);\r\niwibdev->ibdev.uverbs_cmd_mask =\r\n(1ull << IB_USER_VERBS_CMD_GET_CONTEXT) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_DEVICE) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_PORT) |\r\n(1ull << IB_USER_VERBS_CMD_ALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_DEALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_REG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_DEREG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_REQ_NOTIFY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_QP) |\r\n(1ull << IB_USER_VERBS_CMD_MODIFY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POLL_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_AH) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_AH) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POST_RECV) |\r\n(1ull << IB_USER_VERBS_CMD_POST_SEND);\r\niwibdev->ibdev.phys_port_cnt = 1;\r\niwibdev->ibdev.num_comp_vectors = 1;\r\niwibdev->ibdev.dma_device = &pcidev->dev;\r\niwibdev->ibdev.dev.parent = &pcidev->dev;\r\niwibdev->ibdev.query_port = i40iw_query_port;\r\niwibdev->ibdev.modify_port = i40iw_modify_port;\r\niwibdev->ibdev.query_pkey = i40iw_query_pkey;\r\niwibdev->ibdev.query_gid = i40iw_query_gid;\r\niwibdev->ibdev.alloc_ucontext = i40iw_alloc_ucontext;\r\niwibdev->ibdev.dealloc_ucontext = i40iw_dealloc_ucontext;\r\niwibdev->ibdev.mmap = i40iw_mmap;\r\niwibdev->ibdev.alloc_pd = i40iw_alloc_pd;\r\niwibdev->ibdev.dealloc_pd = i40iw_dealloc_pd;\r\niwibdev->ibdev.create_qp = i40iw_create_qp;\r\niwibdev->ibdev.modify_qp = i40iw_modify_qp;\r\niwibdev->ibdev.query_qp = i40iw_query_qp;\r\niwibdev->ibdev.destroy_qp = i40iw_destroy_qp;\r\niwibdev->ibdev.create_cq = i40iw_create_cq;\r\niwibdev->ibdev.destroy_cq = i40iw_destroy_cq;\r\niwibdev->ibdev.get_dma_mr = i40iw_get_dma_mr;\r\niwibdev->ibdev.reg_user_mr = i40iw_reg_user_mr;\r\niwibdev->ibdev.dereg_mr = i40iw_dereg_mr;\r\niwibdev->ibdev.alloc_hw_stats = i40iw_alloc_hw_stats;\r\niwibdev->ibdev.get_hw_stats = i40iw_get_hw_stats;\r\niwibdev->ibdev.query_device = i40iw_query_device;\r\niwibdev->ibdev.create_ah = i40iw_create_ah;\r\niwibdev->ibdev.destroy_ah = i40iw_destroy_ah;\r\niwibdev->ibdev.drain_sq = i40iw_drain_sq;\r\niwibdev->ibdev.drain_rq = i40iw_drain_rq;\r\niwibdev->ibdev.alloc_mr = i40iw_alloc_mr;\r\niwibdev->ibdev.map_mr_sg = i40iw_map_mr_sg;\r\niwibdev->ibdev.iwcm = kzalloc(sizeof(*iwibdev->ibdev.iwcm), GFP_KERNEL);\r\nif (!iwibdev->ibdev.iwcm) {\r\nib_dealloc_device(&iwibdev->ibdev);\r\ni40iw_pr_err("iwcm == NULL\n");\r\nreturn NULL;\r\n}\r\niwibdev->ibdev.iwcm->add_ref = i40iw_add_ref;\r\niwibdev->ibdev.iwcm->rem_ref = i40iw_rem_ref;\r\niwibdev->ibdev.iwcm->get_qp = i40iw_get_qp;\r\niwibdev->ibdev.iwcm->connect = i40iw_connect;\r\niwibdev->ibdev.iwcm->accept = i40iw_accept;\r\niwibdev->ibdev.iwcm->reject = i40iw_reject;\r\niwibdev->ibdev.iwcm->create_listen = i40iw_create_listen;\r\niwibdev->ibdev.iwcm->destroy_listen = i40iw_destroy_listen;\r\nmemcpy(iwibdev->ibdev.iwcm->ifname, netdev->name,\r\nsizeof(iwibdev->ibdev.iwcm->ifname));\r\niwibdev->ibdev.get_port_immutable = i40iw_port_immutable;\r\niwibdev->ibdev.get_dev_fw_str = i40iw_get_dev_fw_str;\r\niwibdev->ibdev.poll_cq = i40iw_poll_cq;\r\niwibdev->ibdev.req_notify_cq = i40iw_req_notify_cq;\r\niwibdev->ibdev.post_send = i40iw_post_send;\r\niwibdev->ibdev.post_recv = i40iw_post_recv;\r\nreturn iwibdev;\r\n}\r\nvoid i40iw_port_ibevent(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_ib_device *iwibdev = iwdev->iwibdev;\r\nstruct ib_event event;\r\nevent.device = &iwibdev->ibdev;\r\nevent.element.port_num = 1;\r\nevent.event = iwdev->iw_status ? IB_EVENT_PORT_ACTIVE : IB_EVENT_PORT_ERR;\r\nib_dispatch_event(&event);\r\n}\r\nstatic void i40iw_unregister_rdma_device(struct i40iw_ib_device *iwibdev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(i40iw_dev_attributes); ++i)\r\ndevice_remove_file(&iwibdev->ibdev.dev,\r\ni40iw_dev_attributes[i]);\r\nib_unregister_device(&iwibdev->ibdev);\r\n}\r\nvoid i40iw_destroy_rdma_device(struct i40iw_ib_device *iwibdev)\r\n{\r\nif (!iwibdev)\r\nreturn;\r\ni40iw_unregister_rdma_device(iwibdev);\r\nkfree(iwibdev->ibdev.iwcm);\r\niwibdev->ibdev.iwcm = NULL;\r\nib_dealloc_device(&iwibdev->ibdev);\r\n}\r\nint i40iw_register_rdma_device(struct i40iw_device *iwdev)\r\n{\r\nint i, ret;\r\nstruct i40iw_ib_device *iwibdev;\r\niwdev->iwibdev = i40iw_init_rdma_device(iwdev);\r\nif (!iwdev->iwibdev)\r\nreturn -ENOMEM;\r\niwibdev = iwdev->iwibdev;\r\nret = ib_register_device(&iwibdev->ibdev, NULL);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < ARRAY_SIZE(i40iw_dev_attributes); ++i) {\r\nret =\r\ndevice_create_file(&iwibdev->ibdev.dev,\r\ni40iw_dev_attributes[i]);\r\nif (ret) {\r\nwhile (i > 0) {\r\ni--;\r\ndevice_remove_file(&iwibdev->ibdev.dev, i40iw_dev_attributes[i]);\r\n}\r\nib_unregister_device(&iwibdev->ibdev);\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nkfree(iwdev->iwibdev->ibdev.iwcm);\r\niwdev->iwibdev->ibdev.iwcm = NULL;\r\nib_dealloc_device(&iwdev->iwibdev->ibdev);\r\nreturn ret;\r\n}
