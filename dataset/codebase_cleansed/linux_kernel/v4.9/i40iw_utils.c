int i40iw_arp_table(struct i40iw_device *iwdev,\r\nu32 *ip_addr,\r\nbool ipv4,\r\nu8 *mac_addr,\r\nu32 action)\r\n{\r\nint arp_index;\r\nint err;\r\nu32 ip[4];\r\nif (ipv4) {\r\nmemset(ip, 0, sizeof(ip));\r\nip[0] = *ip_addr;\r\n} else {\r\nmemcpy(ip, ip_addr, sizeof(ip));\r\n}\r\nfor (arp_index = 0; (u32)arp_index < iwdev->arp_table_size; arp_index++)\r\nif (memcmp(iwdev->arp_table[arp_index].ip_addr, ip, sizeof(ip)) == 0)\r\nbreak;\r\nswitch (action) {\r\ncase I40IW_ARP_ADD:\r\nif (arp_index != iwdev->arp_table_size)\r\nreturn -1;\r\narp_index = 0;\r\nerr = i40iw_alloc_resource(iwdev, iwdev->allocated_arps,\r\niwdev->arp_table_size,\r\n(u32 *)&arp_index,\r\n&iwdev->next_arp_index);\r\nif (err)\r\nreturn err;\r\nmemcpy(iwdev->arp_table[arp_index].ip_addr, ip, sizeof(ip));\r\nether_addr_copy(iwdev->arp_table[arp_index].mac_addr, mac_addr);\r\nbreak;\r\ncase I40IW_ARP_RESOLVE:\r\nif (arp_index == iwdev->arp_table_size)\r\nreturn -1;\r\nbreak;\r\ncase I40IW_ARP_DELETE:\r\nif (arp_index == iwdev->arp_table_size)\r\nreturn -1;\r\nmemset(iwdev->arp_table[arp_index].ip_addr, 0,\r\nsizeof(iwdev->arp_table[arp_index].ip_addr));\r\neth_zero_addr(iwdev->arp_table[arp_index].mac_addr);\r\ni40iw_free_resource(iwdev, iwdev->allocated_arps, arp_index);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn arp_index;\r\n}\r\ninline void i40iw_wr32(struct i40iw_hw *hw, u32 reg, u32 value)\r\n{\r\nwritel(value, hw->hw_addr + reg);\r\n}\r\ninline u32 i40iw_rd32(struct i40iw_hw *hw, u32 reg)\r\n{\r\nreturn readl(hw->hw_addr + reg);\r\n}\r\nint i40iw_inetaddr_event(struct notifier_block *notifier,\r\nunsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct in_ifaddr *ifa = ptr;\r\nstruct net_device *event_netdev = ifa->ifa_dev->dev;\r\nstruct net_device *netdev;\r\nstruct net_device *upper_dev;\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_handler *hdl;\r\nu32 local_ipaddr;\r\nhdl = i40iw_find_netdev(event_netdev);\r\nif (!hdl)\r\nreturn NOTIFY_DONE;\r\niwdev = &hdl->device;\r\nnetdev = iwdev->ldev->netdev;\r\nupper_dev = netdev_master_upper_dev_get(netdev);\r\nif (netdev != event_netdev)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_DOWN:\r\nif (upper_dev)\r\nlocal_ipaddr = ntohl(\r\n((struct in_device *)upper_dev->ip_ptr)->ifa_list->ifa_address);\r\nelse\r\nlocal_ipaddr = ntohl(ifa->ifa_address);\r\ni40iw_manage_arp_cache(iwdev,\r\nnetdev->dev_addr,\r\n&local_ipaddr,\r\ntrue,\r\nI40IW_ARP_DELETE);\r\nreturn NOTIFY_OK;\r\ncase NETDEV_UP:\r\nif (upper_dev)\r\nlocal_ipaddr = ntohl(\r\n((struct in_device *)upper_dev->ip_ptr)->ifa_list->ifa_address);\r\nelse\r\nlocal_ipaddr = ntohl(ifa->ifa_address);\r\ni40iw_manage_arp_cache(iwdev,\r\nnetdev->dev_addr,\r\n&local_ipaddr,\r\ntrue,\r\nI40IW_ARP_ADD);\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nif (upper_dev)\r\nlocal_ipaddr = ntohl(\r\n((struct in_device *)upper_dev->ip_ptr)->ifa_list->ifa_address);\r\nelse\r\nlocal_ipaddr = ntohl(ifa->ifa_address);\r\ni40iw_manage_arp_cache(iwdev,\r\nnetdev->dev_addr,\r\n&local_ipaddr,\r\ntrue,\r\nI40IW_ARP_ADD);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nint i40iw_inet6addr_event(struct notifier_block *notifier,\r\nunsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\r\nstruct net_device *event_netdev = ifa->idev->dev;\r\nstruct net_device *netdev;\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_handler *hdl;\r\nu32 local_ipaddr6[4];\r\nhdl = i40iw_find_netdev(event_netdev);\r\nif (!hdl)\r\nreturn NOTIFY_DONE;\r\niwdev = &hdl->device;\r\nnetdev = iwdev->ldev->netdev;\r\nif (netdev != event_netdev)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_DOWN:\r\ni40iw_copy_ip_ntohl(local_ipaddr6, ifa->addr.in6_u.u6_addr32);\r\ni40iw_manage_arp_cache(iwdev,\r\nnetdev->dev_addr,\r\nlocal_ipaddr6,\r\nfalse,\r\nI40IW_ARP_DELETE);\r\nreturn NOTIFY_OK;\r\ncase NETDEV_UP:\r\ncase NETDEV_CHANGEADDR:\r\ni40iw_copy_ip_ntohl(local_ipaddr6, ifa->addr.in6_u.u6_addr32);\r\ni40iw_manage_arp_cache(iwdev,\r\nnetdev->dev_addr,\r\nlocal_ipaddr6,\r\nfalse,\r\nI40IW_ARP_ADD);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nint i40iw_net_event(struct notifier_block *notifier, unsigned long event, void *ptr)\r\n{\r\nstruct neighbour *neigh = ptr;\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_handler *iwhdl;\r\n__be32 *p;\r\nu32 local_ipaddr[4];\r\nswitch (event) {\r\ncase NETEVENT_NEIGH_UPDATE:\r\niwhdl = i40iw_find_netdev((struct net_device *)neigh->dev);\r\nif (!iwhdl)\r\nreturn NOTIFY_DONE;\r\niwdev = &iwhdl->device;\r\np = (__be32 *)neigh->primary_key;\r\ni40iw_copy_ip_ntohl(local_ipaddr, p);\r\nif (neigh->nud_state & NUD_VALID) {\r\ni40iw_manage_arp_cache(iwdev,\r\nneigh->ha,\r\nlocal_ipaddr,\r\nfalse,\r\nI40IW_ARP_ADD);\r\n} else {\r\ni40iw_manage_arp_cache(iwdev,\r\nneigh->ha,\r\nlocal_ipaddr,\r\nfalse,\r\nI40IW_ARP_DELETE);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstruct i40iw_cqp_request *i40iw_get_cqp_request(struct i40iw_cqp *cqp, bool wait)\r\n{\r\nstruct i40iw_cqp_request *cqp_request = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cqp->req_lock, flags);\r\nif (!list_empty(&cqp->cqp_avail_reqs)) {\r\ncqp_request = list_entry(cqp->cqp_avail_reqs.next,\r\nstruct i40iw_cqp_request, list);\r\nlist_del_init(&cqp_request->list);\r\n}\r\nspin_unlock_irqrestore(&cqp->req_lock, flags);\r\nif (!cqp_request) {\r\ncqp_request = kzalloc(sizeof(*cqp_request), GFP_ATOMIC);\r\nif (cqp_request) {\r\ncqp_request->dynamic = true;\r\nINIT_LIST_HEAD(&cqp_request->list);\r\ninit_waitqueue_head(&cqp_request->waitq);\r\n}\r\n}\r\nif (!cqp_request) {\r\ni40iw_pr_err("CQP Request Fail: No Memory");\r\nreturn NULL;\r\n}\r\nif (wait) {\r\natomic_set(&cqp_request->refcount, 2);\r\ncqp_request->waiting = true;\r\n} else {\r\natomic_set(&cqp_request->refcount, 1);\r\n}\r\nreturn cqp_request;\r\n}\r\nvoid i40iw_free_cqp_request(struct i40iw_cqp *cqp, struct i40iw_cqp_request *cqp_request)\r\n{\r\nunsigned long flags;\r\nif (cqp_request->dynamic) {\r\nkfree(cqp_request);\r\n} else {\r\ncqp_request->request_done = false;\r\ncqp_request->callback_fcn = NULL;\r\ncqp_request->waiting = false;\r\nspin_lock_irqsave(&cqp->req_lock, flags);\r\nlist_add_tail(&cqp_request->list, &cqp->cqp_avail_reqs);\r\nspin_unlock_irqrestore(&cqp->req_lock, flags);\r\n}\r\n}\r\nvoid i40iw_put_cqp_request(struct i40iw_cqp *cqp,\r\nstruct i40iw_cqp_request *cqp_request)\r\n{\r\nif (atomic_dec_and_test(&cqp_request->refcount))\r\ni40iw_free_cqp_request(cqp, cqp_request);\r\n}\r\nstatic void i40iw_free_qp(struct i40iw_cqp_request *cqp_request, u32 num)\r\n{\r\nstruct i40iw_sc_qp *qp = (struct i40iw_sc_qp *)cqp_request->param;\r\nstruct i40iw_qp *iwqp = (struct i40iw_qp *)qp->back_qp;\r\nstruct i40iw_device *iwdev;\r\nu32 qp_num = iwqp->ibqp.qp_num;\r\niwdev = iwqp->iwdev;\r\ni40iw_rem_pdusecount(iwqp->iwpd, iwdev);\r\ni40iw_free_qp_resources(iwdev, iwqp, qp_num);\r\n}\r\nstatic int i40iw_wait_event(struct i40iw_device *iwdev,\r\nstruct i40iw_cqp_request *cqp_request)\r\n{\r\nstruct cqp_commands_info *info = &cqp_request->info;\r\nstruct i40iw_cqp *iwcqp = &iwdev->cqp;\r\nbool cqp_error = false;\r\nint err_code = 0;\r\nint timeout_ret = 0;\r\ntimeout_ret = wait_event_timeout(cqp_request->waitq,\r\ncqp_request->request_done,\r\nI40IW_EVENT_TIMEOUT);\r\nif (!timeout_ret) {\r\ni40iw_pr_err("error cqp command 0x%x timed out ret = %d\n",\r\ninfo->cqp_cmd, timeout_ret);\r\nerr_code = -ETIME;\r\ni40iw_request_reset(iwdev);\r\ngoto done;\r\n}\r\ncqp_error = cqp_request->compl_info.error;\r\nif (cqp_error) {\r\ni40iw_pr_err("error cqp command 0x%x completion maj = 0x%x min=0x%x\n",\r\ninfo->cqp_cmd, cqp_request->compl_info.maj_err_code,\r\ncqp_request->compl_info.min_err_code);\r\nerr_code = -EPROTO;\r\ngoto done;\r\n}\r\ndone:\r\ni40iw_put_cqp_request(iwcqp, cqp_request);\r\nreturn err_code;\r\n}\r\nenum i40iw_status_code i40iw_handle_cqp_op(struct i40iw_device *iwdev,\r\nstruct i40iw_cqp_request\r\n*cqp_request)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nenum i40iw_status_code status;\r\nstruct cqp_commands_info *info = &cqp_request->info;\r\nint err_code = 0;\r\nstatus = i40iw_process_cqp_cmd(dev, info);\r\nif (status) {\r\ni40iw_pr_err("error cqp command 0x%x failed\n", info->cqp_cmd);\r\ni40iw_free_cqp_request(&iwdev->cqp, cqp_request);\r\nreturn status;\r\n}\r\nif (cqp_request->waiting)\r\nerr_code = i40iw_wait_event(iwdev, cqp_request);\r\nif (err_code)\r\nstatus = I40IW_ERR_CQP_COMPL_ERROR;\r\nreturn status;\r\n}\r\nvoid i40iw_add_pdusecount(struct i40iw_pd *iwpd)\r\n{\r\natomic_inc(&iwpd->usecount);\r\n}\r\nvoid i40iw_rem_pdusecount(struct i40iw_pd *iwpd, struct i40iw_device *iwdev)\r\n{\r\nif (!atomic_dec_and_test(&iwpd->usecount))\r\nreturn;\r\ni40iw_free_resource(iwdev, iwdev->allocated_pds, iwpd->sc_pd.pd_id);\r\nkfree(iwpd);\r\n}\r\nvoid i40iw_add_ref(struct ib_qp *ibqp)\r\n{\r\nstruct i40iw_qp *iwqp = (struct i40iw_qp *)ibqp;\r\natomic_inc(&iwqp->refcount);\r\n}\r\nvoid i40iw_rem_ref(struct ib_qp *ibqp)\r\n{\r\nstruct i40iw_qp *iwqp;\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_device *iwdev;\r\nu32 qp_num;\r\nunsigned long flags;\r\niwqp = to_iwqp(ibqp);\r\niwdev = iwqp->iwdev;\r\nspin_lock_irqsave(&iwdev->qptable_lock, flags);\r\nif (!atomic_dec_and_test(&iwqp->refcount)) {\r\nspin_unlock_irqrestore(&iwdev->qptable_lock, flags);\r\nreturn;\r\n}\r\nqp_num = iwqp->ibqp.qp_num;\r\niwdev->qp_table[qp_num] = NULL;\r\nspin_unlock_irqrestore(&iwdev->qptable_lock, flags);\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, false);\r\nif (!cqp_request)\r\nreturn;\r\ncqp_request->callback_fcn = i40iw_free_qp;\r\ncqp_request->param = (void *)&iwqp->sc_qp;\r\ncqp_info = &cqp_request->info;\r\ncqp_info->cqp_cmd = OP_QP_DESTROY;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.qp_destroy.qp = &iwqp->sc_qp;\r\ncqp_info->in.u.qp_destroy.scratch = (uintptr_t)cqp_request;\r\ncqp_info->in.u.qp_destroy.remove_hash_idx = true;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Destroy QP fail");\r\n}\r\nstruct ib_qp *i40iw_get_qp(struct ib_device *device, int qpn)\r\n{\r\nstruct i40iw_device *iwdev = to_iwdev(device);\r\nif ((qpn < IW_FIRST_QPN) || (qpn >= iwdev->max_qp))\r\nreturn NULL;\r\nreturn &iwdev->qp_table[qpn]->ibqp;\r\n}\r\nvoid i40iw_debug_buf(struct i40iw_sc_dev *dev,\r\nenum i40iw_debug_flag mask,\r\nchar *desc,\r\nu64 *buf,\r\nu32 size)\r\n{\r\nu32 i;\r\nif (!(dev->debug_mask & mask))\r\nreturn;\r\ni40iw_debug(dev, mask, "%s\n", desc);\r\ni40iw_debug(dev, mask, "starting address virt=%p phy=%llxh\n", buf,\r\n(unsigned long long)virt_to_phys(buf));\r\nfor (i = 0; i < size; i += 8)\r\ni40iw_debug(dev, mask, "index %03d val: %016llx\n", i, buf[i / 8]);\r\n}\r\nu8 __iomem *i40iw_get_hw_addr(void *par)\r\n{\r\nstruct i40iw_sc_dev *dev = (struct i40iw_sc_dev *)par;\r\nreturn dev->hw->hw_addr;\r\n}\r\nvoid *i40iw_remove_head(struct list_head *list)\r\n{\r\nstruct list_head *entry;\r\nif (list_empty(list))\r\nreturn NULL;\r\nentry = (void *)list->next;\r\nlist_del(entry);\r\nreturn (void *)entry;\r\n}\r\nenum i40iw_status_code i40iw_allocate_dma_mem(struct i40iw_hw *hw,\r\nstruct i40iw_dma_mem *mem,\r\nu64 size,\r\nu32 alignment)\r\n{\r\nstruct pci_dev *pcidev = (struct pci_dev *)hw->dev_context;\r\nif (!mem)\r\nreturn I40IW_ERR_PARAM;\r\nmem->size = ALIGN(size, alignment);\r\nmem->va = dma_zalloc_coherent(&pcidev->dev, mem->size,\r\n(dma_addr_t *)&mem->pa, GFP_KERNEL);\r\nif (!mem->va)\r\nreturn I40IW_ERR_NO_MEMORY;\r\nreturn 0;\r\n}\r\nvoid i40iw_free_dma_mem(struct i40iw_hw *hw, struct i40iw_dma_mem *mem)\r\n{\r\nstruct pci_dev *pcidev = (struct pci_dev *)hw->dev_context;\r\nif (!mem || !mem->va)\r\nreturn;\r\ndma_free_coherent(&pcidev->dev, mem->size,\r\nmem->va, (dma_addr_t)mem->pa);\r\nmem->va = NULL;\r\n}\r\nenum i40iw_status_code i40iw_allocate_virt_mem(struct i40iw_hw *hw,\r\nstruct i40iw_virt_mem *mem,\r\nu32 size)\r\n{\r\nif (!mem)\r\nreturn I40IW_ERR_PARAM;\r\nmem->size = size;\r\nmem->va = kzalloc(size, GFP_KERNEL);\r\nif (mem->va)\r\nreturn 0;\r\nelse\r\nreturn I40IW_ERR_NO_MEMORY;\r\n}\r\nenum i40iw_status_code i40iw_free_virt_mem(struct i40iw_hw *hw,\r\nstruct i40iw_virt_mem *mem)\r\n{\r\nif (!mem)\r\nreturn I40IW_ERR_PARAM;\r\nkfree(mem->va);\r\nreturn 0;\r\n}\r\nenum i40iw_status_code i40iw_cqp_sds_cmd(struct i40iw_sc_dev *dev,\r\nstruct i40iw_update_sds_info *sdinfo)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request)\r\nreturn I40IW_ERR_NO_MEMORY;\r\ncqp_info = &cqp_request->info;\r\nmemcpy(&cqp_info->in.u.update_pe_sds.info, sdinfo,\r\nsizeof(cqp_info->in.u.update_pe_sds.info));\r\ncqp_info->cqp_cmd = OP_UPDATE_PE_SDS;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.update_pe_sds.dev = dev;\r\ncqp_info->in.u.update_pe_sds.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Update SD's fail");\r\nreturn status;\r\n}\r\nvoid i40iw_term_modify_qp(struct i40iw_sc_qp *qp, u8 next_state, u8 term, u8 term_len)\r\n{\r\nstruct i40iw_qp *iwqp;\r\niwqp = (struct i40iw_qp *)qp->back_qp;\r\ni40iw_next_iw_state(iwqp, next_state, 0, term, term_len);\r\n}\r\nvoid i40iw_terminate_done(struct i40iw_sc_qp *qp, int timeout_occurred)\r\n{\r\nstruct i40iw_qp *iwqp;\r\nu32 next_iwarp_state = I40IW_QP_STATE_ERROR;\r\nu8 hte = 0;\r\nbool first_time;\r\nunsigned long flags;\r\niwqp = (struct i40iw_qp *)qp->back_qp;\r\nspin_lock_irqsave(&iwqp->lock, flags);\r\nif (iwqp->hte_added) {\r\niwqp->hte_added = 0;\r\nhte = 1;\r\n}\r\nfirst_time = !(qp->term_flags & I40IW_TERM_DONE);\r\nqp->term_flags |= I40IW_TERM_DONE;\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\nif (first_time) {\r\nif (!timeout_occurred)\r\ni40iw_terminate_del_timer(qp);\r\nelse\r\nnext_iwarp_state = I40IW_QP_STATE_CLOSING;\r\ni40iw_next_iw_state(iwqp, next_iwarp_state, hte, 0, 0);\r\ni40iw_cm_disconn(iwqp);\r\n}\r\n}\r\nstatic void i40iw_terminate_timeout(unsigned long context)\r\n{\r\nstruct i40iw_qp *iwqp = (struct i40iw_qp *)context;\r\nstruct i40iw_sc_qp *qp = (struct i40iw_sc_qp *)&iwqp->sc_qp;\r\ni40iw_terminate_done(qp, 1);\r\n}\r\nvoid i40iw_terminate_start_timer(struct i40iw_sc_qp *qp)\r\n{\r\nstruct i40iw_qp *iwqp;\r\niwqp = (struct i40iw_qp *)qp->back_qp;\r\ninit_timer(&iwqp->terminate_timer);\r\niwqp->terminate_timer.function = i40iw_terminate_timeout;\r\niwqp->terminate_timer.expires = jiffies + HZ;\r\niwqp->terminate_timer.data = (unsigned long)iwqp;\r\nadd_timer(&iwqp->terminate_timer);\r\n}\r\nvoid i40iw_terminate_del_timer(struct i40iw_sc_qp *qp)\r\n{\r\nstruct i40iw_qp *iwqp;\r\niwqp = (struct i40iw_qp *)qp->back_qp;\r\ndel_timer(&iwqp->terminate_timer);\r\n}\r\nstatic void i40iw_cqp_generic_worker(struct work_struct *work)\r\n{\r\nstruct i40iw_virtchnl_work_info *work_info =\r\n&((struct virtchnl_work *)work)->work_info;\r\nif (work_info->worker_vf_dev)\r\nwork_info->callback_fcn(work_info->worker_vf_dev);\r\n}\r\nvoid i40iw_cqp_spawn_worker(struct i40iw_sc_dev *dev,\r\nstruct i40iw_virtchnl_work_info *work_info,\r\nu32 iw_vf_idx)\r\n{\r\nstruct virtchnl_work *work;\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\nwork = &iwdev->virtchnl_w[iw_vf_idx];\r\nmemcpy(&work->work_info, work_info, sizeof(*work_info));\r\nINIT_WORK(&work->work, i40iw_cqp_generic_worker);\r\nqueue_work(iwdev->virtchnl_wq, &work->work);\r\n}\r\nstatic void i40iw_cqp_manage_hmc_fcn_worker(struct work_struct *work)\r\n{\r\nstruct i40iw_cqp_request *cqp_request =\r\n((struct virtchnl_work *)work)->cqp_request;\r\nstruct i40iw_ccq_cqe_info ccq_cqe_info;\r\nstruct i40iw_hmc_fcn_info *hmcfcninfo =\r\n&cqp_request->info.in.u.manage_hmc_pm.info;\r\nstruct i40iw_device *iwdev =\r\n(struct i40iw_device *)cqp_request->info.in.u.manage_hmc_pm.dev->back_dev;\r\nccq_cqe_info.cqp = NULL;\r\nccq_cqe_info.maj_err_code = cqp_request->compl_info.maj_err_code;\r\nccq_cqe_info.min_err_code = cqp_request->compl_info.min_err_code;\r\nccq_cqe_info.op_code = cqp_request->compl_info.op_code;\r\nccq_cqe_info.op_ret_val = cqp_request->compl_info.op_ret_val;\r\nccq_cqe_info.scratch = 0;\r\nccq_cqe_info.error = cqp_request->compl_info.error;\r\nhmcfcninfo->callback_fcn(cqp_request->info.in.u.manage_hmc_pm.dev,\r\nhmcfcninfo->cqp_callback_param, &ccq_cqe_info);\r\ni40iw_put_cqp_request(&iwdev->cqp, cqp_request);\r\n}\r\nstatic void i40iw_cqp_manage_hmc_fcn_callback(struct i40iw_cqp_request *cqp_request,\r\nu32 unused)\r\n{\r\nstruct virtchnl_work *work;\r\nstruct i40iw_hmc_fcn_info *hmcfcninfo =\r\n&cqp_request->info.in.u.manage_hmc_pm.info;\r\nstruct i40iw_device *iwdev =\r\n(struct i40iw_device *)cqp_request->info.in.u.manage_hmc_pm.dev->\r\nback_dev;\r\nif (hmcfcninfo && hmcfcninfo->callback_fcn) {\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_HMC, "%s1\n", __func__);\r\natomic_inc(&cqp_request->refcount);\r\nwork = &iwdev->virtchnl_w[hmcfcninfo->iw_vf_idx];\r\nwork->cqp_request = cqp_request;\r\nINIT_WORK(&work->work, i40iw_cqp_manage_hmc_fcn_worker);\r\nqueue_work(iwdev->virtchnl_wq, &work->work);\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_HMC, "%s2\n", __func__);\r\n} else {\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_HMC, "%s: Something wrong\n", __func__);\r\n}\r\n}\r\nenum i40iw_status_code i40iw_cqp_manage_hmc_fcn_cmd(struct i40iw_sc_dev *dev,\r\nstruct i40iw_hmc_fcn_info *hmcfcninfo)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_HMC, "%s\n", __func__);\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, false);\r\nif (!cqp_request)\r\nreturn I40IW_ERR_NO_MEMORY;\r\ncqp_info = &cqp_request->info;\r\ncqp_request->callback_fcn = i40iw_cqp_manage_hmc_fcn_callback;\r\ncqp_request->param = hmcfcninfo;\r\nmemcpy(&cqp_info->in.u.manage_hmc_pm.info, hmcfcninfo,\r\nsizeof(*hmcfcninfo));\r\ncqp_info->in.u.manage_hmc_pm.dev = dev;\r\ncqp_info->cqp_cmd = OP_MANAGE_HMC_PM_FUNC_TABLE;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.manage_hmc_pm.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Manage HMC fail");\r\nreturn status;\r\n}\r\nenum i40iw_status_code i40iw_cqp_query_fpm_values_cmd(struct i40iw_sc_dev *dev,\r\nstruct i40iw_dma_mem *values_mem,\r\nu8 hmc_fn_id)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request)\r\nreturn I40IW_ERR_NO_MEMORY;\r\ncqp_info = &cqp_request->info;\r\ncqp_request->param = NULL;\r\ncqp_info->in.u.query_fpm_values.cqp = dev->cqp;\r\ncqp_info->in.u.query_fpm_values.fpm_values_pa = values_mem->pa;\r\ncqp_info->in.u.query_fpm_values.fpm_values_va = values_mem->va;\r\ncqp_info->in.u.query_fpm_values.hmc_fn_id = hmc_fn_id;\r\ncqp_info->cqp_cmd = OP_QUERY_FPM_VALUES;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.query_fpm_values.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Query FPM fail");\r\nreturn status;\r\n}\r\nenum i40iw_status_code i40iw_cqp_commit_fpm_values_cmd(struct i40iw_sc_dev *dev,\r\nstruct i40iw_dma_mem *values_mem,\r\nu8 hmc_fn_id)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, true);\r\nif (!cqp_request)\r\nreturn I40IW_ERR_NO_MEMORY;\r\ncqp_info = &cqp_request->info;\r\ncqp_request->param = NULL;\r\ncqp_info->in.u.commit_fpm_values.cqp = dev->cqp;\r\ncqp_info->in.u.commit_fpm_values.fpm_values_pa = values_mem->pa;\r\ncqp_info->in.u.commit_fpm_values.fpm_values_va = values_mem->va;\r\ncqp_info->in.u.commit_fpm_values.hmc_fn_id = hmc_fn_id;\r\ncqp_info->cqp_cmd = OP_COMMIT_FPM_VALUES;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.commit_fpm_values.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Commit FPM fail");\r\nreturn status;\r\n}\r\nenum i40iw_status_code i40iw_vf_wait_vchnl_resp(struct i40iw_sc_dev *dev)\r\n{\r\nstruct i40iw_device *iwdev = dev->back_dev;\r\nint timeout_ret;\r\ni40iw_debug(dev, I40IW_DEBUG_VIRT, "%s[%u] dev %p, iwdev %p\n",\r\n__func__, __LINE__, dev, iwdev);\r\natomic_set(&iwdev->vchnl_msgs, 2);\r\ntimeout_ret = wait_event_timeout(iwdev->vchnl_waitq,\r\n(atomic_read(&iwdev->vchnl_msgs) == 1),\r\nI40IW_VCHNL_EVENT_TIMEOUT);\r\natomic_dec(&iwdev->vchnl_msgs);\r\nif (!timeout_ret) {\r\ni40iw_pr_err("virt channel completion timeout = 0x%x\n", timeout_ret);\r\natomic_set(&iwdev->vchnl_msgs, 0);\r\ndev->vchnl_up = false;\r\nreturn I40IW_ERR_TIMEOUT;\r\n}\r\nwake_up(&dev->vf_reqs);\r\nreturn 0;\r\n}\r\nvoid i40iw_ieq_mpa_crc_ae(struct i40iw_sc_dev *dev, struct i40iw_sc_qp *qp)\r\n{\r\nstruct i40iw_qp_flush_info info;\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\ni40iw_debug(dev, I40IW_DEBUG_AEQ, "%s entered\n", __func__);\r\nmemset(&info, 0, sizeof(info));\r\ninfo.ae_code = I40IW_AE_LLP_RECEIVED_MPA_CRC_ERROR;\r\ninfo.generate_ae = true;\r\ninfo.ae_source = 0x3;\r\n(void)i40iw_hw_flush_wqes(iwdev, qp, &info, false);\r\n}\r\nenum i40iw_status_code i40iw_init_hash_desc(struct shash_desc **desc)\r\n{\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *tdesc;\r\ntfm = crypto_alloc_shash("crc32c", 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn I40IW_ERR_MPA_CRC;\r\ntdesc = kzalloc(sizeof(*tdesc) + crypto_shash_descsize(tfm),\r\nGFP_KERNEL);\r\nif (!tdesc) {\r\ncrypto_free_shash(tfm);\r\nreturn I40IW_ERR_MPA_CRC;\r\n}\r\ntdesc->tfm = tfm;\r\n*desc = tdesc;\r\nreturn 0;\r\n}\r\nvoid i40iw_free_hash_desc(struct shash_desc *desc)\r\n{\r\nif (desc) {\r\ncrypto_free_shash(desc->tfm);\r\nkfree(desc);\r\n}\r\n}\r\nenum i40iw_status_code i40iw_alloc_query_fpm_buf(struct i40iw_sc_dev *dev,\r\nstruct i40iw_dma_mem *mem)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\nstatus = i40iw_obj_aligned_mem(iwdev, mem, I40IW_QUERY_FPM_BUF_SIZE,\r\nI40IW_FPM_QUERY_BUF_ALIGNMENT_MASK);\r\nreturn status;\r\n}\r\nenum i40iw_status_code i40iw_ieq_check_mpacrc(struct shash_desc *desc,\r\nvoid *addr,\r\nu32 length,\r\nu32 value)\r\n{\r\nu32 crc = 0;\r\nint ret;\r\nenum i40iw_status_code ret_code = 0;\r\ncrypto_shash_init(desc);\r\nret = crypto_shash_update(desc, addr, length);\r\nif (!ret)\r\ncrypto_shash_final(desc, (u8 *)&crc);\r\nif (crc != value) {\r\ni40iw_pr_err("mpa crc check fail\n");\r\nret_code = I40IW_ERR_MPA_CRC;\r\n}\r\nreturn ret_code;\r\n}\r\nstruct i40iw_sc_qp *i40iw_ieq_get_qp(struct i40iw_sc_dev *dev,\r\nstruct i40iw_puda_buf *buf)\r\n{\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\nstruct i40iw_qp *iwqp;\r\nstruct i40iw_cm_node *cm_node;\r\nu32 loc_addr[4], rem_addr[4];\r\nu16 loc_port, rem_port;\r\nstruct ipv6hdr *ip6h;\r\nstruct iphdr *iph = (struct iphdr *)buf->iph;\r\nstruct tcphdr *tcph = (struct tcphdr *)buf->tcph;\r\nif (iph->version == 4) {\r\nmemset(loc_addr, 0, sizeof(loc_addr));\r\nloc_addr[0] = ntohl(iph->daddr);\r\nmemset(rem_addr, 0, sizeof(rem_addr));\r\nrem_addr[0] = ntohl(iph->saddr);\r\n} else {\r\nip6h = (struct ipv6hdr *)buf->iph;\r\ni40iw_copy_ip_ntohl(loc_addr, ip6h->daddr.in6_u.u6_addr32);\r\ni40iw_copy_ip_ntohl(rem_addr, ip6h->saddr.in6_u.u6_addr32);\r\n}\r\nloc_port = ntohs(tcph->dest);\r\nrem_port = ntohs(tcph->source);\r\ncm_node = i40iw_find_node(&iwdev->cm_core, rem_port, rem_addr, loc_port,\r\nloc_addr, false);\r\nif (!cm_node)\r\nreturn NULL;\r\niwqp = cm_node->iwqp;\r\nreturn &iwqp->sc_qp;\r\n}\r\nvoid i40iw_ieq_update_tcpip_info(struct i40iw_puda_buf *buf, u16 length, u32 seqnum)\r\n{\r\nstruct tcphdr *tcph;\r\nstruct iphdr *iph;\r\nu16 iphlen;\r\nu16 packetsize;\r\nu8 *addr = (u8 *)buf->mem.va;\r\niphlen = (buf->ipv4) ? 20 : 40;\r\niph = (struct iphdr *)(addr + buf->maclen);\r\ntcph = (struct tcphdr *)(addr + buf->maclen + iphlen);\r\npacketsize = length + buf->tcphlen + iphlen;\r\niph->tot_len = htons(packetsize);\r\ntcph->seq = htonl(seqnum);\r\n}\r\nenum i40iw_status_code i40iw_puda_get_tcpip_info(struct i40iw_puda_completion_info *info,\r\nstruct i40iw_puda_buf *buf)\r\n{\r\nstruct iphdr *iph;\r\nstruct ipv6hdr *ip6h;\r\nstruct tcphdr *tcph;\r\nu16 iphlen;\r\nu16 pkt_len;\r\nu8 *mem = (u8 *)buf->mem.va;\r\nstruct ethhdr *ethh = (struct ethhdr *)buf->mem.va;\r\nif (ethh->h_proto == htons(0x8100)) {\r\ninfo->vlan_valid = true;\r\nbuf->vlan_id = ntohs(((struct vlan_ethhdr *)ethh)->h_vlan_TCI) & VLAN_VID_MASK;\r\n}\r\nbuf->maclen = (info->vlan_valid) ? 18 : 14;\r\niphlen = (info->l3proto) ? 40 : 20;\r\nbuf->ipv4 = (info->l3proto) ? false : true;\r\nbuf->iph = mem + buf->maclen;\r\niph = (struct iphdr *)buf->iph;\r\nbuf->tcph = buf->iph + iphlen;\r\ntcph = (struct tcphdr *)buf->tcph;\r\nif (buf->ipv4) {\r\npkt_len = ntohs(iph->tot_len);\r\n} else {\r\nip6h = (struct ipv6hdr *)buf->iph;\r\npkt_len = ntohs(ip6h->payload_len) + iphlen;\r\n}\r\nbuf->totallen = pkt_len + buf->maclen;\r\nif (info->payload_len < buf->totallen - 4) {\r\ni40iw_pr_err("payload_len = 0x%x totallen expected0x%x\n",\r\ninfo->payload_len, buf->totallen);\r\nreturn I40IW_ERR_INVALID_SIZE;\r\n}\r\nbuf->tcphlen = (tcph->doff) << 2;\r\nbuf->datalen = pkt_len - iphlen - buf->tcphlen;\r\nbuf->data = (buf->datalen) ? buf->tcph + buf->tcphlen : NULL;\r\nbuf->hdrlen = buf->maclen + iphlen + buf->tcphlen;\r\nbuf->seqnum = ntohl(tcph->seq);\r\nreturn 0;\r\n}\r\nstatic void i40iw_hw_stats_timeout(unsigned long dev)\r\n{\r\nstruct i40iw_sc_dev *pf_dev = (struct i40iw_sc_dev *)dev;\r\nstruct i40iw_dev_pestat *pf_devstat = &pf_dev->dev_pestat;\r\nstruct i40iw_dev_pestat *vf_devstat = NULL;\r\nu16 iw_vf_idx;\r\nunsigned long flags;\r\npf_devstat->ops.iw_hw_stat_read_all(pf_devstat, &pf_devstat->hw_stats);\r\nfor (iw_vf_idx = 0; iw_vf_idx < I40IW_MAX_PE_ENABLED_VF_COUNT; iw_vf_idx++) {\r\nspin_lock_irqsave(&pf_devstat->stats_lock, flags);\r\nif (pf_dev->vf_dev[iw_vf_idx]) {\r\nif (pf_dev->vf_dev[iw_vf_idx]->stats_initialized) {\r\nvf_devstat = &pf_dev->vf_dev[iw_vf_idx]->dev_pestat;\r\nvf_devstat->ops.iw_hw_stat_read_all(vf_devstat, &vf_devstat->hw_stats);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pf_devstat->stats_lock, flags);\r\n}\r\nmod_timer(&pf_devstat->stats_timer,\r\njiffies + msecs_to_jiffies(STATS_TIMER_DELAY));\r\n}\r\nvoid i40iw_hw_stats_start_timer(struct i40iw_sc_dev *dev)\r\n{\r\nstruct i40iw_dev_pestat *devstat = &dev->dev_pestat;\r\ninit_timer(&devstat->stats_timer);\r\ndevstat->stats_timer.function = i40iw_hw_stats_timeout;\r\ndevstat->stats_timer.data = (unsigned long)dev;\r\nmod_timer(&devstat->stats_timer,\r\njiffies + msecs_to_jiffies(STATS_TIMER_DELAY));\r\n}\r\nvoid i40iw_hw_stats_del_timer(struct i40iw_sc_dev *dev)\r\n{\r\nstruct i40iw_dev_pestat *devstat = &dev->dev_pestat;\r\ndel_timer_sync(&devstat->stats_timer);\r\n}
