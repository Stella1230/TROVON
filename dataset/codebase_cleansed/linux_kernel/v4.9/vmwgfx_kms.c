void vmw_du_cleanup(struct vmw_display_unit *du)\r\n{\r\nif (du->cursor_surface)\r\nvmw_surface_unreference(&du->cursor_surface);\r\nif (du->cursor_dmabuf)\r\nvmw_dmabuf_unreference(&du->cursor_dmabuf);\r\ndrm_connector_unregister(&du->connector);\r\ndrm_crtc_cleanup(&du->crtc);\r\ndrm_encoder_cleanup(&du->encoder);\r\ndrm_connector_cleanup(&du->connector);\r\n}\r\nint vmw_cursor_update_image(struct vmw_private *dev_priv,\r\nu32 *image, u32 width, u32 height,\r\nu32 hotspotX, u32 hotspotY)\r\n{\r\nstruct {\r\nu32 cmd;\r\nSVGAFifoCmdDefineAlphaCursor cursor;\r\n} *cmd;\r\nu32 image_size = width * height * 4;\r\nu32 cmd_size = sizeof(*cmd) + image_size;\r\nif (!image)\r\nreturn -EINVAL;\r\ncmd = vmw_fifo_reserve(dev_priv, cmd_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\nmemcpy(&cmd[1], image, image_size);\r\ncmd->cmd = SVGA_CMD_DEFINE_ALPHA_CURSOR;\r\ncmd->cursor.id = 0;\r\ncmd->cursor.width = width;\r\ncmd->cursor.height = height;\r\ncmd->cursor.hotspotX = hotspotX;\r\ncmd->cursor.hotspotY = hotspotY;\r\nvmw_fifo_commit_flush(dev_priv, cmd_size);\r\nreturn 0;\r\n}\r\nint vmw_cursor_update_dmabuf(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *dmabuf,\r\nu32 width, u32 height,\r\nu32 hotspotX, u32 hotspotY)\r\n{\r\nstruct ttm_bo_kmap_obj map;\r\nunsigned long kmap_offset;\r\nunsigned long kmap_num;\r\nvoid *virtual;\r\nbool dummy;\r\nint ret;\r\nkmap_offset = 0;\r\nkmap_num = (width*height*4 + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nret = ttm_bo_reserve(&dmabuf->base, true, false, NULL);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("reserve failed\n");\r\nreturn -EINVAL;\r\n}\r\nret = ttm_bo_kmap(&dmabuf->base, kmap_offset, kmap_num, &map);\r\nif (unlikely(ret != 0))\r\ngoto err_unreserve;\r\nvirtual = ttm_kmap_obj_virtual(&map, &dummy);\r\nret = vmw_cursor_update_image(dev_priv, virtual, width, height,\r\nhotspotX, hotspotY);\r\nttm_bo_kunmap(&map);\r\nerr_unreserve:\r\nttm_bo_unreserve(&dmabuf->base);\r\nreturn ret;\r\n}\r\nvoid vmw_cursor_update_position(struct vmw_private *dev_priv,\r\nbool show, int x, int y)\r\n{\r\nu32 *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t count;\r\nvmw_mmio_write(show ? 1 : 0, fifo_mem + SVGA_FIFO_CURSOR_ON);\r\nvmw_mmio_write(x, fifo_mem + SVGA_FIFO_CURSOR_X);\r\nvmw_mmio_write(y, fifo_mem + SVGA_FIFO_CURSOR_Y);\r\ncount = vmw_mmio_read(fifo_mem + SVGA_FIFO_CURSOR_COUNT);\r\nvmw_mmio_write(++count, fifo_mem + SVGA_FIFO_CURSOR_COUNT);\r\n}\r\nint vmw_du_crtc_cursor_set2(struct drm_crtc *crtc, struct drm_file *file_priv,\r\nuint32_t handle, uint32_t width, uint32_t height,\r\nint32_t hot_x, int32_t hot_y)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\r\nstruct vmw_surface *surface = NULL;\r\nstruct vmw_dma_buffer *dmabuf = NULL;\r\ns32 hotspot_x, hotspot_y;\r\nint ret;\r\ndrm_modeset_unlock_crtc(crtc);\r\ndrm_modeset_lock_all(dev_priv->dev);\r\nhotspot_x = hot_x + du->hotspot_x;\r\nhotspot_y = hot_y + du->hotspot_y;\r\nif (handle && (width != 64 || height != 64)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (handle) {\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nret = vmw_user_lookup_handle(dev_priv, tfile,\r\nhandle, &surface, &dmabuf);\r\nif (ret) {\r\nDRM_ERROR("failed to find surface or dmabuf: %i\n", ret);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nif (surface && !surface->snooper.image) {\r\nDRM_ERROR("surface not suitable for cursor\n");\r\nvmw_surface_unreference(&surface);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (du->cursor_surface) {\r\ndu->cursor_surface->snooper.crtc = NULL;\r\nvmw_surface_unreference(&du->cursor_surface);\r\n}\r\nif (du->cursor_dmabuf)\r\nvmw_dmabuf_unreference(&du->cursor_dmabuf);\r\nret = 0;\r\nif (surface) {\r\ndu->cursor_surface = surface;\r\ndu->cursor_surface->snooper.crtc = crtc;\r\ndu->cursor_age = du->cursor_surface->snooper.age;\r\nret = vmw_cursor_update_image(dev_priv, surface->snooper.image,\r\n64, 64, hotspot_x, hotspot_y);\r\n} else if (dmabuf) {\r\ndu->cursor_dmabuf = dmabuf;\r\nret = vmw_cursor_update_dmabuf(dev_priv, dmabuf, width, height,\r\nhotspot_x, hotspot_y);\r\n} else {\r\nvmw_cursor_update_position(dev_priv, false, 0, 0);\r\ngoto out;\r\n}\r\nif (!ret) {\r\nvmw_cursor_update_position(dev_priv, true,\r\ndu->cursor_x + hotspot_x,\r\ndu->cursor_y + hotspot_y);\r\ndu->core_hotspot_x = hot_x;\r\ndu->core_hotspot_y = hot_y;\r\n}\r\nout:\r\ndrm_modeset_unlock_all(dev_priv->dev);\r\ndrm_modeset_lock_crtc(crtc, crtc->cursor);\r\nreturn ret;\r\n}\r\nint vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\r\nbool shown = du->cursor_surface || du->cursor_dmabuf ? true : false;\r\ndu->cursor_x = x + du->set_gui_x;\r\ndu->cursor_y = y + du->set_gui_y;\r\ndrm_modeset_unlock_crtc(crtc);\r\ndrm_modeset_lock_all(dev_priv->dev);\r\nvmw_cursor_update_position(dev_priv, shown,\r\ndu->cursor_x + du->hotspot_x +\r\ndu->core_hotspot_x,\r\ndu->cursor_y + du->hotspot_y +\r\ndu->core_hotspot_y);\r\ndrm_modeset_unlock_all(dev_priv->dev);\r\ndrm_modeset_lock_crtc(crtc, crtc->cursor);\r\nreturn 0;\r\n}\r\nvoid vmw_kms_cursor_snoop(struct vmw_surface *srf,\r\nstruct ttm_object_file *tfile,\r\nstruct ttm_buffer_object *bo,\r\nSVGA3dCmdHeader *header)\r\n{\r\nstruct ttm_bo_kmap_obj map;\r\nunsigned long kmap_offset;\r\nunsigned long kmap_num;\r\nSVGA3dCopyBox *box;\r\nunsigned box_count;\r\nvoid *virtual;\r\nbool dummy;\r\nstruct vmw_dma_cmd {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSurfaceDMA dma;\r\n} *cmd;\r\nint i, ret;\r\ncmd = container_of(header, struct vmw_dma_cmd, header);\r\nif (!srf->snooper.image)\r\nreturn;\r\nif (cmd->dma.host.face != 0 || cmd->dma.host.mipmap != 0) {\r\nDRM_ERROR("face and mipmap for cursors should never != 0\n");\r\nreturn;\r\n}\r\nif (cmd->header.size < 64) {\r\nDRM_ERROR("at least one full copy box must be given\n");\r\nreturn;\r\n}\r\nbox = (SVGA3dCopyBox *)&cmd[1];\r\nbox_count = (cmd->header.size - sizeof(SVGA3dCmdSurfaceDMA)) /\r\nsizeof(SVGA3dCopyBox);\r\nif (cmd->dma.guest.ptr.offset % PAGE_SIZE ||\r\nbox->x != 0 || box->y != 0 || box->z != 0 ||\r\nbox->srcx != 0 || box->srcy != 0 || box->srcz != 0 ||\r\nbox->d != 1 || box_count != 1) {\r\nDRM_ERROR("Cant snoop dma request for cursor!\n");\r\nDRM_ERROR("(%u, %u, %u) (%u, %u, %u) (%ux%ux%u) %u %u\n",\r\nbox->srcx, box->srcy, box->srcz,\r\nbox->x, box->y, box->z,\r\nbox->w, box->h, box->d, box_count,\r\ncmd->dma.guest.ptr.offset);\r\nreturn;\r\n}\r\nkmap_offset = cmd->dma.guest.ptr.offset >> PAGE_SHIFT;\r\nkmap_num = (64*64*4) >> PAGE_SHIFT;\r\nret = ttm_bo_reserve(bo, true, false, NULL);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("reserve failed\n");\r\nreturn;\r\n}\r\nret = ttm_bo_kmap(bo, kmap_offset, kmap_num, &map);\r\nif (unlikely(ret != 0))\r\ngoto err_unreserve;\r\nvirtual = ttm_kmap_obj_virtual(&map, &dummy);\r\nif (box->w == 64 && cmd->dma.guest.pitch == 64*4) {\r\nmemcpy(srf->snooper.image, virtual, 64*64*4);\r\n} else {\r\nfor (i = 0; i < box->h; i++)\r\nmemcpy(srf->snooper.image + i * 64,\r\nvirtual + i * cmd->dma.guest.pitch,\r\nbox->w * 4);\r\n}\r\nsrf->snooper.age++;\r\nttm_bo_kunmap(&map);\r\nerr_unreserve:\r\nttm_bo_unreserve(bo);\r\n}\r\nvoid vmw_kms_legacy_hotspot_clear(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_display_unit *du;\r\nstruct drm_crtc *crtc;\r\ndrm_modeset_lock_all(dev);\r\ndrm_for_each_crtc(crtc, dev) {\r\ndu = vmw_crtc_to_du(crtc);\r\ndu->hotspot_x = 0;\r\ndu->hotspot_y = 0;\r\n}\r\ndrm_modeset_unlock_all(dev);\r\n}\r\nvoid vmw_kms_cursor_post_execbuf(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_display_unit *du;\r\nstruct drm_crtc *crtc;\r\nmutex_lock(&dev->mode_config.mutex);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\ndu = vmw_crtc_to_du(crtc);\r\nif (!du->cursor_surface ||\r\ndu->cursor_age == du->cursor_surface->snooper.age)\r\ncontinue;\r\ndu->cursor_age = du->cursor_surface->snooper.age;\r\nvmw_cursor_update_image(dev_priv,\r\ndu->cursor_surface->snooper.image,\r\n64, 64,\r\ndu->hotspot_x + du->core_hotspot_x,\r\ndu->hotspot_y + du->core_hotspot_y);\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}\r\nstatic void vmw_framebuffer_surface_destroy(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct vmw_framebuffer_surface *vfbs =\r\nvmw_framebuffer_to_vfbs(framebuffer);\r\ndrm_framebuffer_cleanup(framebuffer);\r\nvmw_surface_unreference(&vfbs->surface);\r\nif (vfbs->base.user_obj)\r\nttm_base_object_unref(&vfbs->base.user_obj);\r\nkfree(vfbs);\r\n}\r\nstatic int vmw_framebuffer_surface_dirty(struct drm_framebuffer *framebuffer,\r\nstruct drm_file *file_priv,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(framebuffer->dev);\r\nstruct vmw_framebuffer_surface *vfbs =\r\nvmw_framebuffer_to_vfbs(framebuffer);\r\nstruct drm_clip_rect norect;\r\nint ret, inc = 1;\r\nif (dev_priv->active_display_unit == vmw_du_legacy)\r\nreturn -EINVAL;\r\ndrm_modeset_lock_all(dev_priv->dev);\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0)) {\r\ndrm_modeset_unlock_all(dev_priv->dev);\r\nreturn ret;\r\n}\r\nif (!num_clips) {\r\nnum_clips = 1;\r\nclips = &norect;\r\nnorect.x1 = norect.y1 = 0;\r\nnorect.x2 = framebuffer->width;\r\nnorect.y2 = framebuffer->height;\r\n} else if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\r\nnum_clips /= 2;\r\ninc = 2;\r\n}\r\nif (dev_priv->active_display_unit == vmw_du_screen_object)\r\nret = vmw_kms_sou_do_surface_dirty(dev_priv, &vfbs->base,\r\nclips, NULL, NULL, 0, 0,\r\nnum_clips, inc, NULL);\r\nelse\r\nret = vmw_kms_stdu_surface_dirty(dev_priv, &vfbs->base,\r\nclips, NULL, NULL, 0, 0,\r\nnum_clips, inc, NULL);\r\nvmw_fifo_flush(dev_priv, false);\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\ndrm_modeset_unlock_all(dev_priv->dev);\r\nreturn 0;\r\n}\r\nint vmw_kms_readback(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_framebuffer *vfb,\r\nstruct drm_vmw_fence_rep __user *user_fence_rep,\r\nstruct drm_vmw_rect *vclips,\r\nuint32_t num_clips)\r\n{\r\nswitch (dev_priv->active_display_unit) {\r\ncase vmw_du_screen_object:\r\nreturn vmw_kms_sou_readback(dev_priv, file_priv, vfb,\r\nuser_fence_rep, vclips, num_clips);\r\ncase vmw_du_screen_target:\r\nreturn vmw_kms_stdu_dma(dev_priv, file_priv, vfb,\r\nuser_fence_rep, NULL, vclips, num_clips,\r\n1, false, true);\r\ndefault:\r\nWARN_ONCE(true,\r\n"Readback called with invalid display system.\n");\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic int vmw_kms_new_framebuffer_surface(struct vmw_private *dev_priv,\r\nstruct vmw_surface *surface,\r\nstruct vmw_framebuffer **out,\r\nconst struct drm_mode_fb_cmd\r\n*mode_cmd,\r\nbool is_dmabuf_proxy)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_framebuffer_surface *vfbs;\r\nenum SVGA3dSurfaceFormat format;\r\nint ret;\r\nif (dev_priv->active_display_unit == vmw_du_legacy)\r\nreturn -ENOSYS;\r\nif (unlikely(!surface->scanout))\r\nreturn -EINVAL;\r\nif (unlikely(surface->mip_levels[0] != 1 ||\r\nsurface->num_sizes != 1 ||\r\nsurface->base_size.width < mode_cmd->width ||\r\nsurface->base_size.height < mode_cmd->height ||\r\nsurface->base_size.depth != 1)) {\r\nDRM_ERROR("Incompatible surface dimensions "\r\n"for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (mode_cmd->depth) {\r\ncase 32:\r\nformat = SVGA3D_A8R8G8B8;\r\nbreak;\r\ncase 24:\r\nformat = SVGA3D_X8R8G8B8;\r\nbreak;\r\ncase 16:\r\nformat = SVGA3D_R5G6B5;\r\nbreak;\r\ncase 15:\r\nformat = SVGA3D_A1R5G5B5;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid color depth: %d\n", mode_cmd->depth);\r\nreturn -EINVAL;\r\n}\r\nif (!dev_priv->has_dx && format != surface->format) {\r\nDRM_ERROR("Invalid surface format for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nvfbs = kzalloc(sizeof(*vfbs), GFP_KERNEL);\r\nif (!vfbs) {\r\nret = -ENOMEM;\r\ngoto out_err1;\r\n}\r\nvfbs->base.base.bits_per_pixel = mode_cmd->bpp;\r\nvfbs->base.base.pitches[0] = mode_cmd->pitch;\r\nvfbs->base.base.depth = mode_cmd->depth;\r\nvfbs->base.base.width = mode_cmd->width;\r\nvfbs->base.base.height = mode_cmd->height;\r\nvfbs->surface = vmw_surface_reference(surface);\r\nvfbs->base.user_handle = mode_cmd->handle;\r\nvfbs->is_dmabuf_proxy = is_dmabuf_proxy;\r\n*out = &vfbs->base;\r\nret = drm_framebuffer_init(dev, &vfbs->base.base,\r\n&vmw_framebuffer_surface_funcs);\r\nif (ret)\r\ngoto out_err2;\r\nreturn 0;\r\nout_err2:\r\nvmw_surface_unreference(&surface);\r\nkfree(vfbs);\r\nout_err1:\r\nreturn ret;\r\n}\r\nstatic void vmw_framebuffer_dmabuf_destroy(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(framebuffer);\r\ndrm_framebuffer_cleanup(framebuffer);\r\nvmw_dmabuf_unreference(&vfbd->buffer);\r\nif (vfbd->base.user_obj)\r\nttm_base_object_unref(&vfbd->base.user_obj);\r\nkfree(vfbd);\r\n}\r\nstatic int vmw_framebuffer_dmabuf_dirty(struct drm_framebuffer *framebuffer,\r\nstruct drm_file *file_priv,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(framebuffer->dev);\r\nstruct vmw_framebuffer_dmabuf *vfbd =\r\nvmw_framebuffer_to_vfbd(framebuffer);\r\nstruct drm_clip_rect norect;\r\nint ret, increment = 1;\r\ndrm_modeset_lock_all(dev_priv->dev);\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0)) {\r\ndrm_modeset_unlock_all(dev_priv->dev);\r\nreturn ret;\r\n}\r\nif (!num_clips) {\r\nnum_clips = 1;\r\nclips = &norect;\r\nnorect.x1 = norect.y1 = 0;\r\nnorect.x2 = framebuffer->width;\r\nnorect.y2 = framebuffer->height;\r\n} else if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY) {\r\nnum_clips /= 2;\r\nincrement = 2;\r\n}\r\nswitch (dev_priv->active_display_unit) {\r\ncase vmw_du_screen_target:\r\nret = vmw_kms_stdu_dma(dev_priv, NULL, &vfbd->base, NULL,\r\nclips, NULL, num_clips, increment,\r\ntrue, true);\r\nbreak;\r\ncase vmw_du_screen_object:\r\nret = vmw_kms_sou_do_dmabuf_dirty(dev_priv, &vfbd->base,\r\nclips, NULL, num_clips,\r\nincrement, true, NULL);\r\nbreak;\r\ncase vmw_du_legacy:\r\nret = vmw_kms_ldu_do_dmabuf_dirty(dev_priv, &vfbd->base, 0, 0,\r\nclips, num_clips, increment);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nWARN_ONCE(true, "Dirty called with invalid display system.\n");\r\nbreak;\r\n}\r\nvmw_fifo_flush(dev_priv, false);\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\ndrm_modeset_unlock_all(dev_priv->dev);\r\nreturn ret;\r\n}\r\nstatic int vmw_framebuffer_pin(struct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\r\nstruct vmw_dma_buffer *buf;\r\nint ret;\r\nbuf = vfb->dmabuf ? vmw_framebuffer_to_vfbd(&vfb->base)->buffer :\r\nvmw_framebuffer_to_vfbs(&vfb->base)->surface->res.backup;\r\nif (!buf)\r\nreturn 0;\r\nswitch (dev_priv->active_display_unit) {\r\ncase vmw_du_legacy:\r\nvmw_overlay_pause_all(dev_priv);\r\nret = vmw_dmabuf_pin_in_start_of_vram(dev_priv, buf, false);\r\nvmw_overlay_resume_all(dev_priv);\r\nbreak;\r\ncase vmw_du_screen_object:\r\ncase vmw_du_screen_target:\r\nif (vfb->dmabuf)\r\nreturn vmw_dmabuf_pin_in_vram_or_gmr(dev_priv, buf,\r\nfalse);\r\nreturn vmw_dmabuf_pin_in_placement(dev_priv, buf,\r\n&vmw_mob_placement, false);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vmw_framebuffer_unpin(struct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(vfb->base.dev);\r\nstruct vmw_dma_buffer *buf;\r\nbuf = vfb->dmabuf ? vmw_framebuffer_to_vfbd(&vfb->base)->buffer :\r\nvmw_framebuffer_to_vfbs(&vfb->base)->surface->res.backup;\r\nif (WARN_ON(!buf))\r\nreturn 0;\r\nreturn vmw_dmabuf_unpin(dev_priv, buf, false);\r\n}\r\nstatic int vmw_create_dmabuf_proxy(struct drm_device *dev,\r\nconst struct drm_mode_fb_cmd *mode_cmd,\r\nstruct vmw_dma_buffer *dmabuf_mob,\r\nstruct vmw_surface **srf_out)\r\n{\r\nuint32_t format;\r\nstruct drm_vmw_size content_base_size;\r\nstruct vmw_resource *res;\r\nunsigned int bytes_pp;\r\nint ret;\r\nswitch (mode_cmd->depth) {\r\ncase 32:\r\ncase 24:\r\nformat = SVGA3D_X8R8G8B8;\r\nbytes_pp = 4;\r\nbreak;\r\ncase 16:\r\ncase 15:\r\nformat = SVGA3D_R5G6B5;\r\nbytes_pp = 2;\r\nbreak;\r\ncase 8:\r\nformat = SVGA3D_P8;\r\nbytes_pp = 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid framebuffer format %d\n", mode_cmd->depth);\r\nreturn -EINVAL;\r\n}\r\ncontent_base_size.width = mode_cmd->pitch / bytes_pp;\r\ncontent_base_size.height = mode_cmd->height;\r\ncontent_base_size.depth = 1;\r\nret = vmw_surface_gb_priv_define(dev,\r\n0,\r\n0,\r\nformat,\r\ntrue,\r\n1,\r\n0,\r\n0,\r\ncontent_base_size,\r\nsrf_out);\r\nif (ret) {\r\nDRM_ERROR("Failed to allocate proxy content buffer\n");\r\nreturn ret;\r\n}\r\nres = &(*srf_out)->res;\r\nmutex_lock(&res->dev_priv->cmdbuf_mutex);\r\n(void) vmw_resource_reserve(res, false, true);\r\nvmw_dmabuf_unreference(&res->backup);\r\nres->backup = vmw_dmabuf_reference(dmabuf_mob);\r\nres->backup_offset = 0;\r\nvmw_resource_unreserve(res, false, NULL, 0);\r\nmutex_unlock(&res->dev_priv->cmdbuf_mutex);\r\nreturn 0;\r\n}\r\nstatic int vmw_kms_new_framebuffer_dmabuf(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *dmabuf,\r\nstruct vmw_framebuffer **out,\r\nconst struct drm_mode_fb_cmd\r\n*mode_cmd)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_framebuffer_dmabuf *vfbd;\r\nunsigned int requested_size;\r\nint ret;\r\nrequested_size = mode_cmd->height * mode_cmd->pitch;\r\nif (unlikely(requested_size > dmabuf->base.num_pages * PAGE_SIZE)) {\r\nDRM_ERROR("Screen buffer object size is too small "\r\n"for requested mode.\n");\r\nreturn -EINVAL;\r\n}\r\nif (dev_priv->active_display_unit == vmw_du_screen_object) {\r\nswitch (mode_cmd->depth) {\r\ncase 32:\r\ncase 24:\r\nif (mode_cmd->bpp == 32)\r\nbreak;\r\nDRM_ERROR("Invalid color depth/bbp: %d %d\n",\r\nmode_cmd->depth, mode_cmd->bpp);\r\nreturn -EINVAL;\r\ncase 16:\r\ncase 15:\r\nif (mode_cmd->bpp == 16)\r\nbreak;\r\nDRM_ERROR("Invalid color depth/bbp: %d %d\n",\r\nmode_cmd->depth, mode_cmd->bpp);\r\nreturn -EINVAL;\r\ndefault:\r\nDRM_ERROR("Invalid color depth: %d\n", mode_cmd->depth);\r\nreturn -EINVAL;\r\n}\r\n}\r\nvfbd = kzalloc(sizeof(*vfbd), GFP_KERNEL);\r\nif (!vfbd) {\r\nret = -ENOMEM;\r\ngoto out_err1;\r\n}\r\nvfbd->base.base.bits_per_pixel = mode_cmd->bpp;\r\nvfbd->base.base.pitches[0] = mode_cmd->pitch;\r\nvfbd->base.base.depth = mode_cmd->depth;\r\nvfbd->base.base.width = mode_cmd->width;\r\nvfbd->base.base.height = mode_cmd->height;\r\nvfbd->base.dmabuf = true;\r\nvfbd->buffer = vmw_dmabuf_reference(dmabuf);\r\nvfbd->base.user_handle = mode_cmd->handle;\r\n*out = &vfbd->base;\r\nret = drm_framebuffer_init(dev, &vfbd->base.base,\r\n&vmw_framebuffer_dmabuf_funcs);\r\nif (ret)\r\ngoto out_err2;\r\nreturn 0;\r\nout_err2:\r\nvmw_dmabuf_unreference(&dmabuf);\r\nkfree(vfbd);\r\nout_err1:\r\nreturn ret;\r\n}\r\nstruct vmw_framebuffer *\r\nvmw_kms_new_framebuffer(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *dmabuf,\r\nstruct vmw_surface *surface,\r\nbool only_2d,\r\nconst struct drm_mode_fb_cmd *mode_cmd)\r\n{\r\nstruct vmw_framebuffer *vfb = NULL;\r\nbool is_dmabuf_proxy = false;\r\nint ret;\r\nif (dmabuf && only_2d &&\r\ndev_priv->active_display_unit == vmw_du_screen_target) {\r\nret = vmw_create_dmabuf_proxy(dev_priv->dev, mode_cmd,\r\ndmabuf, &surface);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nis_dmabuf_proxy = true;\r\n}\r\nif (surface) {\r\nret = vmw_kms_new_framebuffer_surface(dev_priv, surface, &vfb,\r\nmode_cmd,\r\nis_dmabuf_proxy);\r\nif (is_dmabuf_proxy)\r\nvmw_surface_unreference(&surface);\r\n} else if (dmabuf) {\r\nret = vmw_kms_new_framebuffer_dmabuf(dev_priv, dmabuf, &vfb,\r\nmode_cmd);\r\n} else {\r\nBUG();\r\n}\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nvfb->pin = vmw_framebuffer_pin;\r\nvfb->unpin = vmw_framebuffer_unpin;\r\nreturn vfb;\r\n}\r\nstatic struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd2)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_framebuffer *vfb = NULL;\r\nstruct vmw_surface *surface = NULL;\r\nstruct vmw_dma_buffer *bo = NULL;\r\nstruct ttm_base_object *user_obj;\r\nstruct drm_mode_fb_cmd mode_cmd;\r\nint ret;\r\nmode_cmd.width = mode_cmd2->width;\r\nmode_cmd.height = mode_cmd2->height;\r\nmode_cmd.pitch = mode_cmd2->pitches[0];\r\nmode_cmd.handle = mode_cmd2->handles[0];\r\ndrm_fb_get_bpp_depth(mode_cmd2->pixel_format, &mode_cmd.depth,\r\n&mode_cmd.bpp);\r\nif (!vmw_kms_validate_mode_vram(dev_priv,\r\nmode_cmd.pitch,\r\nmode_cmd.height)) {\r\nDRM_ERROR("Requested mode exceed bounding box limit.\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nuser_obj = ttm_base_object_lookup(tfile, mode_cmd.handle);\r\nif (unlikely(user_obj == NULL)) {\r\nDRM_ERROR("Could not locate requested kms frame buffer.\n");\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nret = vmw_user_lookup_handle(dev_priv, tfile,\r\nmode_cmd.handle,\r\n&surface, &bo);\r\nif (ret)\r\ngoto err_out;\r\nvfb = vmw_kms_new_framebuffer(dev_priv, bo, surface,\r\n!(dev_priv->capabilities & SVGA_CAP_3D),\r\n&mode_cmd);\r\nif (IS_ERR(vfb)) {\r\nret = PTR_ERR(vfb);\r\ngoto err_out;\r\n}\r\nerr_out:\r\nif (bo)\r\nvmw_dmabuf_unreference(&bo);\r\nif (surface)\r\nvmw_surface_unreference(&surface);\r\nif (ret) {\r\nDRM_ERROR("failed to create vmw_framebuffer: %i\n", ret);\r\nttm_base_object_unref(&user_obj);\r\nreturn ERR_PTR(ret);\r\n} else\r\nvfb->user_obj = user_obj;\r\nreturn &vfb->base;\r\n}\r\nstatic int vmw_kms_generic_present(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_framebuffer *vfb,\r\nstruct vmw_surface *surface,\r\nuint32_t sid,\r\nint32_t destX, int32_t destY,\r\nstruct drm_vmw_rect *clips,\r\nuint32_t num_clips)\r\n{\r\nreturn vmw_kms_sou_do_surface_dirty(dev_priv, vfb, NULL, clips,\r\n&surface->res, destX, destY,\r\nnum_clips, 1, NULL);\r\n}\r\nint vmw_kms_present(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_framebuffer *vfb,\r\nstruct vmw_surface *surface,\r\nuint32_t sid,\r\nint32_t destX, int32_t destY,\r\nstruct drm_vmw_rect *clips,\r\nuint32_t num_clips)\r\n{\r\nint ret;\r\nswitch (dev_priv->active_display_unit) {\r\ncase vmw_du_screen_target:\r\nret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL, clips,\r\n&surface->res, destX, destY,\r\nnum_clips, 1, NULL);\r\nbreak;\r\ncase vmw_du_screen_object:\r\nret = vmw_kms_generic_present(dev_priv, file_priv, vfb, surface,\r\nsid, destX, destY, clips,\r\nnum_clips);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(true,\r\n"Present called with invalid display system.\n");\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\nvmw_fifo_flush(dev_priv, false);\r\nreturn 0;\r\n}\r\nstatic void\r\nvmw_kms_create_hotplug_mode_update_property(struct vmw_private *dev_priv)\r\n{\r\nif (dev_priv->hotplug_mode_update_property)\r\nreturn;\r\ndev_priv->hotplug_mode_update_property =\r\ndrm_property_create_range(dev_priv->dev,\r\nDRM_MODE_PROP_IMMUTABLE,\r\n"hotplug_mode_update", 0, 1);\r\nif (!dev_priv->hotplug_mode_update_property)\r\nreturn;\r\n}\r\nint vmw_kms_init(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nint ret;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.funcs = &vmw_kms_funcs;\r\ndev->mode_config.min_width = 1;\r\ndev->mode_config.min_height = 1;\r\ndev->mode_config.max_width = dev_priv->texture_max_width;\r\ndev->mode_config.max_height = dev_priv->texture_max_height;\r\ndrm_mode_create_suggested_offset_properties(dev);\r\nvmw_kms_create_hotplug_mode_update_property(dev_priv);\r\nret = vmw_kms_stdu_init_display(dev_priv);\r\nif (ret) {\r\nret = vmw_kms_sou_init_display(dev_priv);\r\nif (ret)\r\nret = vmw_kms_ldu_init_display(dev_priv);\r\n}\r\nreturn ret;\r\n}\r\nint vmw_kms_close(struct vmw_private *dev_priv)\r\n{\r\nint ret;\r\ndrm_mode_config_cleanup(dev_priv->dev);\r\nif (dev_priv->active_display_unit == vmw_du_screen_object)\r\nret = vmw_kms_sou_close_display(dev_priv);\r\nelse if (dev_priv->active_display_unit == vmw_du_screen_target)\r\nret = vmw_kms_stdu_close_display(dev_priv);\r\nelse\r\nret = vmw_kms_ldu_close_display(dev_priv);\r\nreturn ret;\r\n}\r\nint vmw_kms_cursor_bypass_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_cursor_bypass_arg *arg = data;\r\nstruct vmw_display_unit *du;\r\nstruct drm_crtc *crtc;\r\nint ret = 0;\r\nmutex_lock(&dev->mode_config.mutex);\r\nif (arg->flags & DRM_VMW_CURSOR_BYPASS_ALL) {\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\ndu = vmw_crtc_to_du(crtc);\r\ndu->hotspot_x = arg->xhot;\r\ndu->hotspot_y = arg->yhot;\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn 0;\r\n}\r\ncrtc = drm_crtc_find(dev, arg->crtc_id);\r\nif (!crtc) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\ndu = vmw_crtc_to_du(crtc);\r\ndu->hotspot_x = arg->xhot;\r\ndu->hotspot_y = arg->yhot;\r\nout:\r\nmutex_unlock(&dev->mode_config.mutex);\r\nreturn ret;\r\n}\r\nint vmw_kms_write_svga(struct vmw_private *vmw_priv,\r\nunsigned width, unsigned height, unsigned pitch,\r\nunsigned bpp, unsigned depth)\r\n{\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_write(vmw_priv, SVGA_REG_PITCHLOCK, pitch);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\nvmw_mmio_write(pitch, vmw_priv->mmio_virt +\r\nSVGA_FIFO_PITCHLOCK);\r\nvmw_write(vmw_priv, SVGA_REG_WIDTH, width);\r\nvmw_write(vmw_priv, SVGA_REG_HEIGHT, height);\r\nvmw_write(vmw_priv, SVGA_REG_BITS_PER_PIXEL, bpp);\r\nif (vmw_read(vmw_priv, SVGA_REG_DEPTH) != depth) {\r\nDRM_ERROR("Invalid depth %u for %u bpp, host expects %u\n",\r\ndepth, bpp, vmw_read(vmw_priv, SVGA_REG_DEPTH));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint vmw_kms_save_vga(struct vmw_private *vmw_priv)\r\n{\r\nstruct vmw_vga_topology_state *save;\r\nuint32_t i;\r\nvmw_priv->vga_width = vmw_read(vmw_priv, SVGA_REG_WIDTH);\r\nvmw_priv->vga_height = vmw_read(vmw_priv, SVGA_REG_HEIGHT);\r\nvmw_priv->vga_bpp = vmw_read(vmw_priv, SVGA_REG_BITS_PER_PIXEL);\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_priv->vga_pitchlock =\r\nvmw_read(vmw_priv, SVGA_REG_PITCHLOCK);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\nvmw_priv->vga_pitchlock = vmw_mmio_read(vmw_priv->mmio_virt +\r\nSVGA_FIFO_PITCHLOCK);\r\nif (!(vmw_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY))\r\nreturn 0;\r\nvmw_priv->num_displays = vmw_read(vmw_priv,\r\nSVGA_REG_NUM_GUEST_DISPLAYS);\r\nif (vmw_priv->num_displays == 0)\r\nvmw_priv->num_displays = 1;\r\nfor (i = 0; i < vmw_priv->num_displays; ++i) {\r\nsave = &vmw_priv->vga_save[i];\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, i);\r\nsave->primary = vmw_read(vmw_priv, SVGA_REG_DISPLAY_IS_PRIMARY);\r\nsave->pos_x = vmw_read(vmw_priv, SVGA_REG_DISPLAY_POSITION_X);\r\nsave->pos_y = vmw_read(vmw_priv, SVGA_REG_DISPLAY_POSITION_Y);\r\nsave->width = vmw_read(vmw_priv, SVGA_REG_DISPLAY_WIDTH);\r\nsave->height = vmw_read(vmw_priv, SVGA_REG_DISPLAY_HEIGHT);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\nif (i == 0 && vmw_priv->num_displays == 1 &&\r\nsave->width == 0 && save->height == 0) {\r\nsave->width = vmw_priv->vga_width - save->pos_x;\r\nsave->height = vmw_priv->vga_height - save->pos_y;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint vmw_kms_restore_vga(struct vmw_private *vmw_priv)\r\n{\r\nstruct vmw_vga_topology_state *save;\r\nuint32_t i;\r\nvmw_write(vmw_priv, SVGA_REG_WIDTH, vmw_priv->vga_width);\r\nvmw_write(vmw_priv, SVGA_REG_HEIGHT, vmw_priv->vga_height);\r\nvmw_write(vmw_priv, SVGA_REG_BITS_PER_PIXEL, vmw_priv->vga_bpp);\r\nif (vmw_priv->capabilities & SVGA_CAP_PITCHLOCK)\r\nvmw_write(vmw_priv, SVGA_REG_PITCHLOCK,\r\nvmw_priv->vga_pitchlock);\r\nelse if (vmw_fifo_have_pitchlock(vmw_priv))\r\nvmw_mmio_write(vmw_priv->vga_pitchlock,\r\nvmw_priv->mmio_virt + SVGA_FIFO_PITCHLOCK);\r\nif (!(vmw_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY))\r\nreturn 0;\r\nfor (i = 0; i < vmw_priv->num_displays; ++i) {\r\nsave = &vmw_priv->vga_save[i];\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, i);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_IS_PRIMARY, save->primary);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_POSITION_X, save->pos_x);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_POSITION_Y, save->pos_y);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_WIDTH, save->width);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_HEIGHT, save->height);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\n}\r\nreturn 0;\r\n}\r\nbool vmw_kms_validate_mode_vram(struct vmw_private *dev_priv,\r\nuint32_t pitch,\r\nuint32_t height)\r\n{\r\nreturn ((u64) pitch * (u64) height) < (u64)\r\n((dev_priv->active_display_unit == vmw_du_screen_target) ?\r\ndev_priv->prim_bb_mem : dev_priv->vram_size);\r\n}\r\nu32 vmw_get_vblank_counter(struct drm_device *dev, unsigned int pipe)\r\n{\r\nreturn 0;\r\n}\r\nint vmw_enable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nvoid vmw_disable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\n}\r\nstatic int vmw_du_update_layout(struct vmw_private *dev_priv, unsigned num,\r\nstruct drm_vmw_rect *rects)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct vmw_display_unit *du;\r\nstruct drm_connector *con;\r\nmutex_lock(&dev->mode_config.mutex);\r\n#if 0\r\n{\r\nunsigned int i;\r\nDRM_INFO("%s: new layout ", __func__);\r\nfor (i = 0; i < num; i++)\r\nDRM_INFO("(%i, %i %ux%u) ", rects[i].x, rects[i].y,\r\nrects[i].w, rects[i].h);\r\nDRM_INFO("\n");\r\n}\r\n#endif\r\nlist_for_each_entry(con, &dev->mode_config.connector_list, head) {\r\ndu = vmw_connector_to_du(con);\r\nif (num > du->unit) {\r\ndu->pref_width = rects[du->unit].w;\r\ndu->pref_height = rects[du->unit].h;\r\ndu->pref_active = true;\r\ndu->gui_x = rects[du->unit].x;\r\ndu->gui_y = rects[du->unit].y;\r\ndrm_object_property_set_value\r\n(&con->base, dev->mode_config.suggested_x_property,\r\ndu->gui_x);\r\ndrm_object_property_set_value\r\n(&con->base, dev->mode_config.suggested_y_property,\r\ndu->gui_y);\r\n} else {\r\ndu->pref_width = 800;\r\ndu->pref_height = 600;\r\ndu->pref_active = false;\r\ndrm_object_property_set_value\r\n(&con->base, dev->mode_config.suggested_x_property,\r\n0);\r\ndrm_object_property_set_value\r\n(&con->base, dev->mode_config.suggested_y_property,\r\n0);\r\n}\r\ncon->status = vmw_du_connector_detect(con, true);\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\ndrm_sysfs_hotplug_event(dev);\r\nreturn 0;\r\n}\r\nint vmw_du_crtc_gamma_set(struct drm_crtc *crtc,\r\nu16 *r, u16 *g, u16 *b,\r\nuint32_t size)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(crtc->dev);\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nDRM_DEBUG("%d r/g/b = 0x%04x / 0x%04x / 0x%04x\n", i,\r\nr[i], g[i], b[i]);\r\nvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 0, r[i] >> 8);\r\nvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 1, g[i] >> 8);\r\nvmw_write(dev_priv, SVGA_PALETTE_BASE + i * 3 + 2, b[i] >> 8);\r\n}\r\nreturn 0;\r\n}\r\nint vmw_du_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\nreturn 0;\r\n}\r\nenum drm_connector_status\r\nvmw_du_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nuint32_t num_displays;\r\nstruct drm_device *dev = connector->dev;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_display_unit *du = vmw_connector_to_du(connector);\r\nnum_displays = vmw_read(dev_priv, SVGA_REG_NUM_DISPLAYS);\r\nreturn ((vmw_connector_to_du(connector)->unit < num_displays &&\r\ndu->pref_active) ?\r\nconnector_status_connected : connector_status_disconnected);\r\n}\r\nvoid vmw_guess_mode_timing(struct drm_display_mode *mode)\r\n{\r\nmode->hsync_start = mode->hdisplay + 50;\r\nmode->hsync_end = mode->hsync_start + 50;\r\nmode->htotal = mode->hsync_end + 50;\r\nmode->vsync_start = mode->vdisplay + 50;\r\nmode->vsync_end = mode->vsync_start + 50;\r\nmode->vtotal = mode->vsync_end + 50;\r\nmode->clock = (u32)mode->htotal * (u32)mode->vtotal / 100 * 6;\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\n}\r\nint vmw_du_connector_fill_modes(struct drm_connector *connector,\r\nuint32_t max_width, uint32_t max_height)\r\n{\r\nstruct vmw_display_unit *du = vmw_connector_to_du(connector);\r\nstruct drm_device *dev = connector->dev;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_display_mode *bmode;\r\nstruct drm_display_mode prefmode = { DRM_MODE("preferred",\r\nDRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\nDRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC)\r\n};\r\nint i;\r\nu32 assumed_bpp = 4;\r\nif (dev_priv->assume_16bpp)\r\nassumed_bpp = 2;\r\nif (dev_priv->active_display_unit == vmw_du_screen_target) {\r\nmax_width = min(max_width, dev_priv->stdu_max_width);\r\nmax_height = min(max_height, dev_priv->stdu_max_height);\r\n}\r\nmode = drm_mode_duplicate(dev, &prefmode);\r\nif (!mode)\r\nreturn 0;\r\nmode->hdisplay = du->pref_width;\r\nmode->vdisplay = du->pref_height;\r\nvmw_guess_mode_timing(mode);\r\nif (vmw_kms_validate_mode_vram(dev_priv,\r\nmode->hdisplay * assumed_bpp,\r\nmode->vdisplay)) {\r\ndrm_mode_probed_add(connector, mode);\r\n} else {\r\ndrm_mode_destroy(dev, mode);\r\nmode = NULL;\r\n}\r\nif (du->pref_mode) {\r\nlist_del_init(&du->pref_mode->head);\r\ndrm_mode_destroy(dev, du->pref_mode);\r\n}\r\ndu->pref_mode = mode;\r\nfor (i = 0; vmw_kms_connector_builtin[i].type != 0; i++) {\r\nbmode = &vmw_kms_connector_builtin[i];\r\nif (bmode->hdisplay > max_width ||\r\nbmode->vdisplay > max_height)\r\ncontinue;\r\nif (!vmw_kms_validate_mode_vram(dev_priv,\r\nbmode->hdisplay * assumed_bpp,\r\nbmode->vdisplay))\r\ncontinue;\r\nmode = drm_mode_duplicate(dev, bmode);\r\nif (!mode)\r\nreturn 0;\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\ndrm_mode_connector_list_update(connector);\r\ndrm_mode_sort(&connector->modes);\r\nreturn 1;\r\n}\r\nint vmw_du_connector_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct vmw_display_unit *du = vmw_connector_to_du(connector);\r\nstruct vmw_private *dev_priv = vmw_priv(connector->dev);\r\nif (property == dev_priv->implicit_placement_property)\r\ndu->is_implicit = val;\r\nreturn 0;\r\n}\r\nint vmw_kms_update_layout_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_update_layout_arg *arg =\r\n(struct drm_vmw_update_layout_arg *)data;\r\nvoid __user *user_rects;\r\nstruct drm_vmw_rect *rects;\r\nunsigned rects_size;\r\nint ret;\r\nint i;\r\nu64 total_pixels = 0;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_vmw_rect bounding_box = {0};\r\nif (!arg->num_outputs) {\r\nstruct drm_vmw_rect def_rect = {0, 0, 800, 600};\r\nvmw_du_update_layout(dev_priv, 1, &def_rect);\r\nreturn 0;\r\n}\r\nrects_size = arg->num_outputs * sizeof(struct drm_vmw_rect);\r\nrects = kcalloc(arg->num_outputs, sizeof(struct drm_vmw_rect),\r\nGFP_KERNEL);\r\nif (unlikely(!rects))\r\nreturn -ENOMEM;\r\nuser_rects = (void __user *)(unsigned long)arg->rects;\r\nret = copy_from_user(rects, user_rects, rects_size);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to get rects.\n");\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nfor (i = 0; i < arg->num_outputs; ++i) {\r\nif (rects[i].x < 0 ||\r\nrects[i].y < 0 ||\r\nrects[i].x + rects[i].w > mode_config->max_width ||\r\nrects[i].y + rects[i].h > mode_config->max_height) {\r\nDRM_ERROR("Invalid GUI layout.\n");\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (rects[i].x + rects[i].w > bounding_box.w)\r\nbounding_box.w = rects[i].x + rects[i].w;\r\nif (rects[i].y + rects[i].h > bounding_box.h)\r\nbounding_box.h = rects[i].y + rects[i].h;\r\ntotal_pixels += (u64) rects[i].w * (u64) rects[i].h;\r\n}\r\nif (dev_priv->active_display_unit == vmw_du_screen_target) {\r\nu64 bb_mem = bounding_box.w * bounding_box.h * 4;\r\nu64 pixel_mem = total_pixels * 4;\r\nif (bb_mem > dev_priv->prim_bb_mem) {\r\nDRM_ERROR("Topology is beyond supported limits.\n");\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (pixel_mem > dev_priv->prim_bb_mem) {\r\nDRM_ERROR("Combined output size too large\n");\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nvmw_du_update_layout(dev_priv, arg->num_outputs, rects);\r\nout_free:\r\nkfree(rects);\r\nreturn ret;\r\n}\r\nint vmw_kms_helper_dirty(struct vmw_private *dev_priv,\r\nstruct vmw_framebuffer *framebuffer,\r\nconst struct drm_clip_rect *clips,\r\nconst struct drm_vmw_rect *vclips,\r\ns32 dest_x, s32 dest_y,\r\nint num_clips,\r\nint increment,\r\nstruct vmw_kms_dirty *dirty)\r\n{\r\nstruct vmw_display_unit *units[VMWGFX_NUM_DISPLAY_UNITS];\r\nstruct drm_crtc *crtc;\r\nu32 num_units = 0;\r\nu32 i, k;\r\ndirty->dev_priv = dev_priv;\r\nlist_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list, head) {\r\nif (crtc->primary->fb != &framebuffer->base)\r\ncontinue;\r\nunits[num_units++] = vmw_crtc_to_du(crtc);\r\n}\r\nfor (k = 0; k < num_units; k++) {\r\nstruct vmw_display_unit *unit = units[k];\r\ns32 crtc_x = unit->crtc.x;\r\ns32 crtc_y = unit->crtc.y;\r\ns32 crtc_width = unit->crtc.mode.hdisplay;\r\ns32 crtc_height = unit->crtc.mode.vdisplay;\r\nconst struct drm_clip_rect *clips_ptr = clips;\r\nconst struct drm_vmw_rect *vclips_ptr = vclips;\r\ndirty->unit = unit;\r\nif (dirty->fifo_reserve_size > 0) {\r\ndirty->cmd = vmw_fifo_reserve(dev_priv,\r\ndirty->fifo_reserve_size);\r\nif (!dirty->cmd) {\r\nDRM_ERROR("Couldn't reserve fifo space "\r\n"for dirty blits.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(dirty->cmd, 0, dirty->fifo_reserve_size);\r\n}\r\ndirty->num_hits = 0;\r\nfor (i = 0; i < num_clips; i++, clips_ptr += increment,\r\nvclips_ptr += increment) {\r\ns32 clip_left;\r\ns32 clip_top;\r\nif (clips) {\r\ndirty->fb_x = (s32) clips_ptr->x1;\r\ndirty->fb_y = (s32) clips_ptr->y1;\r\ndirty->unit_x2 = (s32) clips_ptr->x2 + dest_x -\r\ncrtc_x;\r\ndirty->unit_y2 = (s32) clips_ptr->y2 + dest_y -\r\ncrtc_y;\r\n} else {\r\ndirty->fb_x = vclips_ptr->x;\r\ndirty->fb_y = vclips_ptr->y;\r\ndirty->unit_x2 = dirty->fb_x + vclips_ptr->w +\r\ndest_x - crtc_x;\r\ndirty->unit_y2 = dirty->fb_y + vclips_ptr->h +\r\ndest_y - crtc_y;\r\n}\r\ndirty->unit_x1 = dirty->fb_x + dest_x - crtc_x;\r\ndirty->unit_y1 = dirty->fb_y + dest_y - crtc_y;\r\nif (dirty->unit_x1 >= crtc_width ||\r\ndirty->unit_y1 >= crtc_height ||\r\ndirty->unit_x2 <= 0 || dirty->unit_y2 <= 0)\r\ncontinue;\r\ndirty->unit_x2 = min_t(s32, dirty->unit_x2,\r\ncrtc_width);\r\ndirty->unit_y2 = min_t(s32, dirty->unit_y2,\r\ncrtc_height);\r\nclip_left = min_t(s32, dirty->unit_x1, 0);\r\nclip_top = min_t(s32, dirty->unit_y1, 0);\r\ndirty->unit_x1 -= clip_left;\r\ndirty->unit_y1 -= clip_top;\r\ndirty->fb_x -= clip_left;\r\ndirty->fb_y -= clip_top;\r\ndirty->clip(dirty);\r\n}\r\ndirty->fifo_commit(dirty);\r\n}\r\nreturn 0;\r\n}\r\nint vmw_kms_helper_buffer_prepare(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buf,\r\nbool interruptible,\r\nbool validate_as_mob)\r\n{\r\nstruct ttm_buffer_object *bo = &buf->base;\r\nint ret;\r\nttm_bo_reserve(bo, false, false, NULL);\r\nret = vmw_validate_single_buffer(dev_priv, bo, interruptible,\r\nvalidate_as_mob);\r\nif (ret)\r\nttm_bo_unreserve(bo);\r\nreturn ret;\r\n}\r\nvoid vmw_kms_helper_buffer_revert(struct vmw_dma_buffer *buf)\r\n{\r\nif (buf)\r\nttm_bo_unreserve(&buf->base);\r\n}\r\nvoid vmw_kms_helper_buffer_finish(struct vmw_private *dev_priv,\r\nstruct drm_file *file_priv,\r\nstruct vmw_dma_buffer *buf,\r\nstruct vmw_fence_obj **out_fence,\r\nstruct drm_vmw_fence_rep __user *\r\nuser_fence_rep)\r\n{\r\nstruct vmw_fence_obj *fence;\r\nuint32_t handle;\r\nint ret;\r\nret = vmw_execbuf_fence_commands(file_priv, dev_priv, &fence,\r\nfile_priv ? &handle : NULL);\r\nif (buf)\r\nvmw_fence_single_bo(&buf->base, fence);\r\nif (file_priv)\r\nvmw_execbuf_copy_fence_user(dev_priv, vmw_fpriv(file_priv),\r\nret, user_fence_rep, fence,\r\nhandle);\r\nif (out_fence)\r\n*out_fence = fence;\r\nelse\r\nvmw_fence_obj_unreference(&fence);\r\nvmw_kms_helper_buffer_revert(buf);\r\n}\r\nvoid vmw_kms_helper_resource_revert(struct vmw_resource *res)\r\n{\r\nvmw_kms_helper_buffer_revert(res->backup);\r\nvmw_resource_unreserve(res, false, NULL, 0);\r\nmutex_unlock(&res->dev_priv->cmdbuf_mutex);\r\n}\r\nint vmw_kms_helper_resource_prepare(struct vmw_resource *res,\r\nbool interruptible)\r\n{\r\nint ret = 0;\r\nif (interruptible)\r\nret = mutex_lock_interruptible(&res->dev_priv->cmdbuf_mutex);\r\nelse\r\nmutex_lock(&res->dev_priv->cmdbuf_mutex);\r\nif (unlikely(ret != 0))\r\nreturn -ERESTARTSYS;\r\nret = vmw_resource_reserve(res, interruptible, false);\r\nif (ret)\r\ngoto out_unlock;\r\nif (res->backup) {\r\nret = vmw_kms_helper_buffer_prepare(res->dev_priv, res->backup,\r\ninterruptible,\r\nres->dev_priv->has_mob);\r\nif (ret)\r\ngoto out_unreserve;\r\n}\r\nret = vmw_resource_validate(res);\r\nif (ret)\r\ngoto out_revert;\r\nreturn 0;\r\nout_revert:\r\nvmw_kms_helper_buffer_revert(res->backup);\r\nout_unreserve:\r\nvmw_resource_unreserve(res, false, NULL, 0);\r\nout_unlock:\r\nmutex_unlock(&res->dev_priv->cmdbuf_mutex);\r\nreturn ret;\r\n}\r\nvoid vmw_kms_helper_resource_finish(struct vmw_resource *res,\r\nstruct vmw_fence_obj **out_fence)\r\n{\r\nif (res->backup || out_fence)\r\nvmw_kms_helper_buffer_finish(res->dev_priv, NULL, res->backup,\r\nout_fence, NULL);\r\nvmw_resource_unreserve(res, false, NULL, 0);\r\nmutex_unlock(&res->dev_priv->cmdbuf_mutex);\r\n}\r\nint vmw_kms_update_proxy(struct vmw_resource *res,\r\nconst struct drm_clip_rect *clips,\r\nunsigned num_clips,\r\nint increment)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct drm_vmw_size *size = &vmw_res_to_srf(res)->base_size;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdUpdateGBImage body;\r\n} *cmd;\r\nSVGA3dBox *box;\r\nsize_t copy_size = 0;\r\nint i;\r\nif (!clips)\r\nreturn 0;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd) * num_clips);\r\nif (!cmd) {\r\nDRM_ERROR("Couldn't reserve fifo space for proxy surface "\r\n"update.\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < num_clips; ++i, clips += increment, ++cmd) {\r\nbox = &cmd->body.box;\r\ncmd->header.id = SVGA_3D_CMD_UPDATE_GB_IMAGE;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.image.sid = res->id;\r\ncmd->body.image.face = 0;\r\ncmd->body.image.mipmap = 0;\r\nif (clips->x1 > size->width || clips->x2 > size->width ||\r\nclips->y1 > size->height || clips->y2 > size->height) {\r\nDRM_ERROR("Invalid clips outsize of framebuffer.\n");\r\nreturn -EINVAL;\r\n}\r\nbox->x = clips->x1;\r\nbox->y = clips->y1;\r\nbox->z = 0;\r\nbox->w = clips->x2 - clips->x1;\r\nbox->h = clips->y2 - clips->y1;\r\nbox->d = 1;\r\ncopy_size += sizeof(*cmd);\r\n}\r\nvmw_fifo_commit(dev_priv, copy_size);\r\nreturn 0;\r\n}\r\nint vmw_kms_fbdev_init_data(struct vmw_private *dev_priv,\r\nunsigned unit,\r\nu32 max_width,\r\nu32 max_height,\r\nstruct drm_connector **p_con,\r\nstruct drm_crtc **p_crtc,\r\nstruct drm_display_mode **p_mode)\r\n{\r\nstruct drm_connector *con;\r\nstruct vmw_display_unit *du;\r\nstruct drm_display_mode *mode;\r\nint i = 0;\r\nlist_for_each_entry(con, &dev_priv->dev->mode_config.connector_list,\r\nhead) {\r\nif (i == unit)\r\nbreak;\r\n++i;\r\n}\r\nif (i != unit) {\r\nDRM_ERROR("Could not find initial display unit.\n");\r\nreturn -EINVAL;\r\n}\r\nif (list_empty(&con->modes))\r\n(void) vmw_du_connector_fill_modes(con, max_width, max_height);\r\nif (list_empty(&con->modes)) {\r\nDRM_ERROR("Could not find initial display mode.\n");\r\nreturn -EINVAL;\r\n}\r\ndu = vmw_connector_to_du(con);\r\n*p_con = con;\r\n*p_crtc = &du->crtc;\r\nlist_for_each_entry(mode, &con->modes, head) {\r\nif (mode->type & DRM_MODE_TYPE_PREFERRED)\r\nbreak;\r\n}\r\nif (mode->type & DRM_MODE_TYPE_PREFERRED)\r\n*p_mode = mode;\r\nelse {\r\nWARN_ONCE(true, "Could not find initial preferred mode.\n");\r\n*p_mode = list_first_entry(&con->modes,\r\nstruct drm_display_mode,\r\nhead);\r\n}\r\nreturn 0;\r\n}\r\nvoid vmw_kms_del_active(struct vmw_private *dev_priv,\r\nstruct vmw_display_unit *du)\r\n{\r\nmutex_lock(&dev_priv->global_kms_state_mutex);\r\nif (du->active_implicit) {\r\nif (--(dev_priv->num_implicit) == 0)\r\ndev_priv->implicit_fb = NULL;\r\ndu->active_implicit = false;\r\n}\r\nmutex_unlock(&dev_priv->global_kms_state_mutex);\r\n}\r\nvoid vmw_kms_add_active(struct vmw_private *dev_priv,\r\nstruct vmw_display_unit *du,\r\nstruct vmw_framebuffer *vfb)\r\n{\r\nmutex_lock(&dev_priv->global_kms_state_mutex);\r\nWARN_ON_ONCE(!dev_priv->num_implicit && dev_priv->implicit_fb);\r\nif (!du->active_implicit && du->is_implicit) {\r\ndev_priv->implicit_fb = vfb;\r\ndu->active_implicit = true;\r\ndev_priv->num_implicit++;\r\n}\r\nmutex_unlock(&dev_priv->global_kms_state_mutex);\r\n}\r\nbool vmw_kms_crtc_flippable(struct vmw_private *dev_priv,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\r\nbool ret;\r\nmutex_lock(&dev_priv->global_kms_state_mutex);\r\nret = !du->is_implicit || dev_priv->num_implicit == 1;\r\nmutex_unlock(&dev_priv->global_kms_state_mutex);\r\nreturn ret;\r\n}\r\nvoid vmw_kms_update_implicit_fb(struct vmw_private *dev_priv,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct vmw_display_unit *du = vmw_crtc_to_du(crtc);\r\nstruct vmw_framebuffer *vfb;\r\nmutex_lock(&dev_priv->global_kms_state_mutex);\r\nif (!du->is_implicit)\r\ngoto out_unlock;\r\nvfb = vmw_framebuffer_to_vfb(crtc->primary->fb);\r\nWARN_ON_ONCE(dev_priv->num_implicit != 1 &&\r\ndev_priv->implicit_fb != vfb);\r\ndev_priv->implicit_fb = vfb;\r\nout_unlock:\r\nmutex_unlock(&dev_priv->global_kms_state_mutex);\r\n}\r\nvoid\r\nvmw_kms_create_implicit_placement_property(struct vmw_private *dev_priv,\r\nbool immutable)\r\n{\r\nif (dev_priv->implicit_placement_property)\r\nreturn;\r\ndev_priv->implicit_placement_property =\r\ndrm_property_create_range(dev_priv->dev,\r\nimmutable ?\r\nDRM_MODE_PROP_IMMUTABLE : 0,\r\n"implicit_placement", 0, 1);\r\n}
