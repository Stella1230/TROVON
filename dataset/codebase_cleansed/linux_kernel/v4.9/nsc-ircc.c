static int __init nsc_ircc_init(void)\r\n{\r\nchipio_t info;\r\nnsc_chip_t *chip;\r\nint ret;\r\nint cfg_base;\r\nint cfg, id;\r\nint reg;\r\nint i = 0;\r\nret = platform_driver_register(&nsc_ircc_driver);\r\nif (ret) {\r\nnet_err_ratelimited("%s, Can't register driver!\n",\r\ndriver_name);\r\nreturn ret;\r\n}\r\nret = pnp_register_driver(&nsc_ircc_pnp_driver);\r\nif (!ret)\r\npnp_registered = 1;\r\nret = -ENODEV;\r\nfor (chip = chips; chip->name ; chip++) {\r\npr_debug("%s(), Probing for %s ...\n", __func__,\r\nchip->name);\r\nfor (cfg = 0; cfg < ARRAY_SIZE(chip->cfg); cfg++) {\r\ncfg_base = chip->cfg[cfg];\r\nif (!cfg_base)\r\ncontinue;\r\nreg = inb(cfg_base);\r\nif (reg == 0xff) {\r\npr_debug("%s() no chip at 0x%03x\n",\r\n__func__, cfg_base);\r\ncontinue;\r\n}\r\noutb(chip->cid_index, cfg_base);\r\nid = inb(cfg_base+1);\r\nif ((id & chip->cid_mask) == chip->cid_value) {\r\npr_debug("%s() Found %s chip, revision=%d\n",\r\n__func__, chip->name,\r\nid & ~chip->cid_mask);\r\nif (pnp_succeeded) {\r\nmemset(&info, 0, sizeof(chipio_t));\r\ninfo.cfg_base = cfg_base;\r\ninfo.fir_base = pnp_info.fir_base;\r\ninfo.dma = pnp_info.dma;\r\ninfo.irq = pnp_info.irq;\r\nif (info.fir_base < 0x2000) {\r\nnet_info_ratelimited("%s, chip->init\n",\r\ndriver_name);\r\nchip->init(chip, &info);\r\n} else\r\nchip->probe(chip, &info);\r\nif (nsc_ircc_open(&info) >= 0)\r\nret = 0;\r\n}\r\nif (ret) {\r\npr_debug("%s, PnP init failed\n",\r\ndriver_name);\r\nmemset(&info, 0, sizeof(chipio_t));\r\ninfo.cfg_base = cfg_base;\r\ninfo.fir_base = io[i];\r\ninfo.dma = dma[i];\r\ninfo.irq = irq[i];\r\nif (io[i] < 0x2000) {\r\nchip->init(chip, &info);\r\n} else\r\nchip->probe(chip, &info);\r\nif (nsc_ircc_open(&info) >= 0)\r\nret = 0;\r\n}\r\ni++;\r\n} else {\r\npr_debug("%s(), Wrong chip id=0x%02x\n",\r\n__func__, id);\r\n}\r\n}\r\n}\r\nif (ret) {\r\nplatform_driver_unregister(&nsc_ircc_driver);\r\npnp_unregister_driver(&nsc_ircc_pnp_driver);\r\npnp_registered = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit nsc_ircc_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dev_self); i++) {\r\nif (dev_self[i])\r\nnsc_ircc_close(dev_self[i]);\r\n}\r\nplatform_driver_unregister(&nsc_ircc_driver);\r\nif (pnp_registered)\r\npnp_unregister_driver(&nsc_ircc_pnp_driver);\r\npnp_registered = 0;\r\n}\r\nstatic int __init nsc_ircc_open(chipio_t *info)\r\n{\r\nstruct net_device *dev;\r\nstruct nsc_ircc_cb *self;\r\nvoid *ret;\r\nint err, chip_index;\r\nfor (chip_index = 0; chip_index < ARRAY_SIZE(dev_self); chip_index++) {\r\nif (!dev_self[chip_index])\r\nbreak;\r\n}\r\nif (chip_index == ARRAY_SIZE(dev_self)) {\r\nnet_err_ratelimited("%s(), maximum number of supported chips reached!\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nnet_info_ratelimited("%s, Found chip at base=0x%03x\n",\r\ndriver_name, info->cfg_base);\r\nif ((nsc_ircc_setup(info)) == -1)\r\nreturn -1;\r\nnet_info_ratelimited("%s, driver loaded (Dag Brattli)\n", driver_name);\r\ndev = alloc_irdadev(sizeof(struct nsc_ircc_cb));\r\nif (dev == NULL) {\r\nnet_err_ratelimited("%s(), can't allocate memory for control block!\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nself = netdev_priv(dev);\r\nself->netdev = dev;\r\nspin_lock_init(&self->lock);\r\ndev_self[chip_index] = self;\r\nself->index = chip_index;\r\nself->io.cfg_base = info->cfg_base;\r\nself->io.fir_base = info->fir_base;\r\nself->io.irq = info->irq;\r\nself->io.fir_ext = CHIP_IO_EXTENT;\r\nself->io.dma = info->dma;\r\nself->io.fifo_size = 32;\r\nret = request_region(self->io.fir_base, self->io.fir_ext, driver_name);\r\nif (!ret) {\r\nnet_warn_ratelimited("%s(), can't get iobase of 0x%03x\n",\r\n__func__, self->io.fir_base);\r\nerr = -ENODEV;\r\ngoto out1;\r\n}\r\nirda_init_max_qos_capabilies(&self->qos);\r\nself->qos.baud_rate.bits = IR_9600|IR_19200|IR_38400|IR_57600|\r\nIR_115200|IR_576000|IR_1152000 |(IR_4000000 << 8);\r\nself->qos.min_turn_time.bits = qos_mtt_bits;\r\nirda_qos_bits_to_value(&self->qos);\r\nself->rx_buff.truesize = 14384;\r\nself->tx_buff.truesize = 14384;\r\nself->rx_buff.head =\r\ndma_zalloc_coherent(NULL, self->rx_buff.truesize,\r\n&self->rx_buff_dma, GFP_KERNEL);\r\nif (self->rx_buff.head == NULL) {\r\nerr = -ENOMEM;\r\ngoto out2;\r\n}\r\nself->tx_buff.head =\r\ndma_zalloc_coherent(NULL, self->tx_buff.truesize,\r\n&self->tx_buff_dma, GFP_KERNEL);\r\nif (self->tx_buff.head == NULL) {\r\nerr = -ENOMEM;\r\ngoto out3;\r\n}\r\nself->rx_buff.in_frame = FALSE;\r\nself->rx_buff.state = OUTSIDE_FRAME;\r\nself->tx_buff.data = self->tx_buff.head;\r\nself->rx_buff.data = self->rx_buff.head;\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\ndev->netdev_ops = &nsc_ircc_sir_ops;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nnet_err_ratelimited("%s(), register_netdev() failed!\n",\r\n__func__);\r\ngoto out4;\r\n}\r\nnet_info_ratelimited("IrDA: Registered device %s\n", dev->name);\r\nif ((dongle_id <= 0) ||\r\n(dongle_id >= ARRAY_SIZE(dongle_types))) {\r\ndongle_id = nsc_ircc_read_dongle_id(self->io.fir_base);\r\nnet_info_ratelimited("%s, Found dongle: %s\n",\r\ndriver_name, dongle_types[dongle_id]);\r\n} else {\r\nnet_info_ratelimited("%s, Using dongle: %s\n",\r\ndriver_name, dongle_types[dongle_id]);\r\n}\r\nself->io.dongle_id = dongle_id;\r\nnsc_ircc_init_dongle_interface(self->io.fir_base, dongle_id);\r\nself->pldev = platform_device_register_simple(NSC_IRCC_DRIVER_NAME,\r\nself->index, NULL, 0);\r\nif (IS_ERR(self->pldev)) {\r\nerr = PTR_ERR(self->pldev);\r\ngoto out5;\r\n}\r\nplatform_set_drvdata(self->pldev, self);\r\nreturn chip_index;\r\nout5:\r\nunregister_netdev(dev);\r\nout4:\r\ndma_free_coherent(NULL, self->tx_buff.truesize,\r\nself->tx_buff.head, self->tx_buff_dma);\r\nout3:\r\ndma_free_coherent(NULL, self->rx_buff.truesize,\r\nself->rx_buff.head, self->rx_buff_dma);\r\nout2:\r\nrelease_region(self->io.fir_base, self->io.fir_ext);\r\nout1:\r\nfree_netdev(dev);\r\ndev_self[chip_index] = NULL;\r\nreturn err;\r\n}\r\nstatic int __exit nsc_ircc_close(struct nsc_ircc_cb *self)\r\n{\r\nint iobase;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\niobase = self->io.fir_base;\r\nplatform_device_unregister(self->pldev);\r\nunregister_netdev(self->netdev);\r\npr_debug("%s(), Releasing Region %03x\n",\r\n__func__, self->io.fir_base);\r\nrelease_region(self->io.fir_base, self->io.fir_ext);\r\nif (self->tx_buff.head)\r\ndma_free_coherent(NULL, self->tx_buff.truesize,\r\nself->tx_buff.head, self->tx_buff_dma);\r\nif (self->rx_buff.head)\r\ndma_free_coherent(NULL, self->rx_buff.truesize,\r\nself->rx_buff.head, self->rx_buff_dma);\r\ndev_self[self->index] = NULL;\r\nfree_netdev(self->netdev);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_init_108(nsc_chip_t *chip, chipio_t *info)\r\n{\r\nint cfg_base = info->cfg_base;\r\n__u8 temp=0;\r\noutb(2, cfg_base);\r\noutb(0x00, cfg_base+1);\r\noutb(CFG_108_BAIC, cfg_base);\r\nswitch (info->fir_base) {\r\ncase 0x3e8: outb(0x14, cfg_base+1); break;\r\ncase 0x2e8: outb(0x15, cfg_base+1); break;\r\ncase 0x3f8: outb(0x16, cfg_base+1); break;\r\ncase 0x2f8: outb(0x17, cfg_base+1); break;\r\ndefault: net_err_ratelimited("%s(), invalid base_address\n", __func__);\r\n}\r\nswitch (info->irq) {\r\ncase 3: temp = 0x01; break;\r\ncase 4: temp = 0x02; break;\r\ncase 5: temp = 0x03; break;\r\ncase 7: temp = 0x04; break;\r\ncase 9: temp = 0x05; break;\r\ncase 11: temp = 0x06; break;\r\ncase 15: temp = 0x07; break;\r\ndefault: net_err_ratelimited("%s(), invalid irq\n", __func__);\r\n}\r\noutb(CFG_108_CSRT, cfg_base);\r\nswitch (info->dma) {\r\ncase 0: outb(0x08+temp, cfg_base+1); break;\r\ncase 1: outb(0x10+temp, cfg_base+1); break;\r\ncase 3: outb(0x18+temp, cfg_base+1); break;\r\ndefault: net_err_ratelimited("%s(), invalid dma\n", __func__);\r\n}\r\noutb(CFG_108_MCTL, cfg_base);\r\noutb(0x03, cfg_base+1);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_probe_108(nsc_chip_t *chip, chipio_t *info)\r\n{\r\nint cfg_base = info->cfg_base;\r\nint reg;\r\noutb(CFG_108_BAIC, cfg_base);\r\nreg = inb(cfg_base+1);\r\nswitch (reg & 0x03) {\r\ncase 0:\r\ninfo->fir_base = 0x3e8;\r\nbreak;\r\ncase 1:\r\ninfo->fir_base = 0x2e8;\r\nbreak;\r\ncase 2:\r\ninfo->fir_base = 0x3f8;\r\nbreak;\r\ncase 3:\r\ninfo->fir_base = 0x2f8;\r\nbreak;\r\n}\r\ninfo->sir_base = info->fir_base;\r\npr_debug("%s(), probing fir_base=0x%03x\n", __func__,\r\ninfo->fir_base);\r\noutb(CFG_108_CSRT, cfg_base);\r\nreg = inb(cfg_base+1);\r\nswitch (reg & 0x07) {\r\ncase 0:\r\ninfo->irq = -1;\r\nbreak;\r\ncase 1:\r\ninfo->irq = 3;\r\nbreak;\r\ncase 2:\r\ninfo->irq = 4;\r\nbreak;\r\ncase 3:\r\ninfo->irq = 5;\r\nbreak;\r\ncase 4:\r\ninfo->irq = 7;\r\nbreak;\r\ncase 5:\r\ninfo->irq = 9;\r\nbreak;\r\ncase 6:\r\ninfo->irq = 11;\r\nbreak;\r\ncase 7:\r\ninfo->irq = 15;\r\nbreak;\r\n}\r\npr_debug("%s(), probing irq=%d\n", __func__, info->irq);\r\nswitch ((reg >> 3) & 0x03) {\r\ncase 0:\r\ninfo->dma = -1;\r\nbreak;\r\ncase 1:\r\ninfo->dma = 0;\r\nbreak;\r\ncase 2:\r\ninfo->dma = 1;\r\nbreak;\r\ncase 3:\r\ninfo->dma = 3;\r\nbreak;\r\n}\r\npr_debug("%s(), probing dma=%d\n", __func__, info->dma);\r\noutb(CFG_108_MCTL, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->enabled = reg & 0x01;\r\ninfo->suspended = !((reg >> 1) & 0x01);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_init_338(nsc_chip_t *chip, chipio_t *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_probe_338(nsc_chip_t *chip, chipio_t *info)\r\n{\r\nint cfg_base = info->cfg_base;\r\nint reg, com = 0;\r\nint pnp;\r\noutb(CFG_338_FER, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->enabled = (reg >> 2) & 0x01;\r\noutb(CFG_338_PNP0, cfg_base);\r\nreg = inb(cfg_base+1);\r\npnp = (reg >> 3) & 0x01;\r\nif (pnp) {\r\npr_debug("(), Chip is in PnP mode\n");\r\noutb(0x46, cfg_base);\r\nreg = (inb(cfg_base+1) & 0xfe) << 2;\r\noutb(0x47, cfg_base);\r\nreg |= ((inb(cfg_base+1) & 0xfc) << 8);\r\ninfo->fir_base = reg;\r\n} else {\r\noutb(CFG_338_FAR, cfg_base);\r\nreg = inb(cfg_base+1);\r\nswitch ((reg >> 4) & 0x03) {\r\ncase 0:\r\ninfo->fir_base = 0x3f8;\r\nbreak;\r\ncase 1:\r\ninfo->fir_base = 0x2f8;\r\nbreak;\r\ncase 2:\r\ncom = 3;\r\nbreak;\r\ncase 3:\r\ncom = 4;\r\nbreak;\r\n}\r\nif (com) {\r\nswitch ((reg >> 6) & 0x03) {\r\ncase 0:\r\nif (com == 3)\r\ninfo->fir_base = 0x3e8;\r\nelse\r\ninfo->fir_base = 0x2e8;\r\nbreak;\r\ncase 1:\r\nif (com == 3)\r\ninfo->fir_base = 0x338;\r\nelse\r\ninfo->fir_base = 0x238;\r\nbreak;\r\ncase 2:\r\nif (com == 3)\r\ninfo->fir_base = 0x2e8;\r\nelse\r\ninfo->fir_base = 0x2e0;\r\nbreak;\r\ncase 3:\r\nif (com == 3)\r\ninfo->fir_base = 0x220;\r\nelse\r\ninfo->fir_base = 0x228;\r\nbreak;\r\n}\r\n}\r\n}\r\ninfo->sir_base = info->fir_base;\r\noutb(CFG_338_PNP1, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->irq = reg >> 4;\r\noutb(CFG_338_PNP3, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->dma = (reg & 0x07) - 1;\r\noutb(CFG_338_PTR, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->suspended = reg & 0x01;\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_init_39x(nsc_chip_t *chip, chipio_t *info)\r\n{\r\nint cfg_base = info->cfg_base;\r\nint enabled;\r\npr_debug("%s(): nsc_ircc_init_39x (user settings): io=0x%04x, irq=%d, dma=%d\n",\r\n__func__, info->fir_base, info->irq, info->dma);\r\noutb(CFG_39X_LDN, cfg_base);\r\noutb(0x02, cfg_base+1);\r\noutb(CFG_39X_ACT, cfg_base);\r\nenabled = inb(cfg_base+1) & 0x01;\r\nif (!enabled) {\r\noutb(CFG_39X_SIOCF1, cfg_base);\r\noutb(0x01, cfg_base+1);\r\n}\r\noutb(CFG_39X_SPC, cfg_base);\r\noutb(0x82, cfg_base+1);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_probe_39x(nsc_chip_t *chip, chipio_t *info)\r\n{\r\nint cfg_base = info->cfg_base;\r\nint reg1, reg2, irq, irqt, dma1, dma2;\r\nint enabled, susp;\r\npr_debug("%s(), nsc_ircc_probe_39x, base=%d\n",\r\n__func__, cfg_base);\r\noutb(CFG_39X_LDN, cfg_base);\r\noutb(0x02, cfg_base+1);\r\noutb(CFG_39X_BASEH, cfg_base);\r\nreg1 = inb(cfg_base+1);\r\noutb(CFG_39X_BASEL, cfg_base);\r\nreg2 = inb(cfg_base+1);\r\ninfo->fir_base = (reg1 << 8) | reg2;\r\noutb(CFG_39X_IRQNUM, cfg_base);\r\nirq = inb(cfg_base+1);\r\noutb(CFG_39X_IRQSEL, cfg_base);\r\nirqt = inb(cfg_base+1);\r\ninfo->irq = irq;\r\noutb(CFG_39X_DMA0, cfg_base);\r\ndma1 = inb(cfg_base+1);\r\noutb(CFG_39X_DMA1, cfg_base);\r\ndma2 = inb(cfg_base+1);\r\ninfo->dma = dma1 -1;\r\noutb(CFG_39X_ACT, cfg_base);\r\ninfo->enabled = enabled = inb(cfg_base+1) & 0x01;\r\noutb(CFG_39X_SPC, cfg_base);\r\nsusp = 1 - ((inb(cfg_base+1) & 0x02) >> 1);\r\npr_debug("%s(): io=0x%02x%02x, irq=%d (type %d), rxdma=%d, txdma=%d, enabled=%d (suspended=%d)\n",\r\n__func__, reg1, reg2, irq, irqt, dma1, dma2, enabled, susp);\r\noutb(CFG_39X_ACT, cfg_base);\r\nenabled = inb(cfg_base+1) & 0x01;\r\nif (!enabled) {\r\noutb(CFG_39X_SIOCF1, cfg_base);\r\noutb(0x01, cfg_base+1);\r\n}\r\noutb(CFG_39X_SPC, cfg_base);\r\noutb(0x82, cfg_base+1);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *id)\r\n{\r\nmemset(&pnp_info, 0, sizeof(chipio_t));\r\npnp_info.irq = -1;\r\npnp_info.dma = -1;\r\npnp_succeeded = 1;\r\nif (id->driver_data & NSC_FORCE_DONGLE_TYPE9)\r\ndongle_id = 0x9;\r\nif (pnp_port_valid(dev, 0) &&\r\n!(pnp_port_flags(dev, 0) & IORESOURCE_DISABLED))\r\npnp_info.fir_base = pnp_port_start(dev, 0);\r\nif (pnp_irq_valid(dev, 0) &&\r\n!(pnp_irq_flags(dev, 0) & IORESOURCE_DISABLED))\r\npnp_info.irq = pnp_irq(dev, 0);\r\nif (pnp_dma_valid(dev, 0) &&\r\n!(pnp_dma_flags(dev, 0) & IORESOURCE_DISABLED))\r\npnp_info.dma = pnp_dma(dev, 0);\r\npr_debug("%s() : From PnP, found firbase 0x%03X ; irq %d ; dma %d.\n",\r\n__func__, pnp_info.fir_base, pnp_info.irq, pnp_info.dma);\r\nif((pnp_info.fir_base == 0) ||\r\n(pnp_info.irq == -1) || (pnp_info.dma == -1)) {\r\npnp_succeeded = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_setup(chipio_t *info)\r\n{\r\nint version;\r\nint iobase = info->fir_base;\r\nswitch_bank(iobase, BANK3);\r\nversion = inb(iobase+MID);\r\npr_debug("%s() Driver %s Found chip version %02x\n",\r\n__func__, driver_name, version);\r\nif (0x20 != (version & 0xf0)) {\r\nnet_err_ratelimited("%s, Wrong chip version %02x\n",\r\ndriver_name, version);\r\nreturn -1;\r\n}\r\nswitch_bank(iobase, BANK2);\r\noutb(ECR1_EXT_SL, iobase+ECR1);\r\nswitch_bank(iobase, BANK0);\r\nswitch_bank(iobase, BANK0);\r\noutb(FCR_RXTH|FCR_TXTH|FCR_TXSR|FCR_RXSR|FCR_FIFO_EN, iobase+FCR);\r\noutb(0x03, iobase+LCR);\r\noutb(MCR_SIR, iobase+MCR);\r\nswitch_bank(iobase, BANK2);\r\noutb(EXCR2_RFSIZ|EXCR2_TFSIZ, iobase+EXCR2);\r\nswitch_bank(iobase, BANK5);\r\noutb(0x02, iobase+4);\r\nswitch_bank(iobase, BANK6);\r\noutb(0x20, iobase+0);\r\noutb(0x0a, iobase+1);\r\noutb(0x0d, iobase+2);\r\noutb(0x2a, iobase+4);\r\nswitch_bank(iobase, BANK0);\r\noutb(IER_RXHDL_IE, iobase+IER);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_read_dongle_id (int iobase)\r\n{\r\nint dongle_id;\r\n__u8 bank;\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK7);\r\noutb(0x00, iobase+7);\r\nudelay(50);\r\ndongle_id = inb(iobase+4) & 0x0f;\r\n#ifdef BROKEN_DONGLE_ID\r\nif (dongle_id == 0x0a)\r\ndongle_id = 0x09;\r\n#endif\r\nswitch_bank(iobase, BANK0);\r\noutb(bank, iobase+BSR);\r\nreturn dongle_id;\r\n}\r\nstatic void nsc_ircc_init_dongle_interface (int iobase, int dongle_id)\r\n{\r\nint bank;\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK7);\r\nswitch (dongle_id) {\r\ncase 0x00:\r\ncase 0x01:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x04:\r\nbreak;\r\ncase 0x05:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x06:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x07:\r\npr_debug("%s(), %s is not for IrDA mode\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x08:\r\npr_debug("%s(), %s\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x09:\r\noutb(0x28, iobase+7);\r\nbreak;\r\ncase 0x0A:\r\ncase 0x0B:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x0C:\r\ncase 0x0D:\r\noutb(0x48, iobase+7);\r\nbreak;\r\ncase 0x0E:\r\noutb(0x28, iobase+7);\r\nbreak;\r\ncase 0x0F:\r\npr_debug("%s(), %s\n",\r\n__func__, dongle_types[dongle_id]);\r\nswitch_bank(iobase, BANK0);\r\noutb(0x62, iobase+MCR);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), invalid dongle_id %#x",\r\n__func__, dongle_id);\r\n}\r\noutb(0x00, iobase+4);\r\noutb(bank, iobase+BSR);\r\n}\r\nstatic void nsc_ircc_change_dongle_speed(int iobase, int speed, int dongle_id)\r\n{\r\n__u8 bank;\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK7);\r\nswitch (dongle_id) {\r\ncase 0x00:\r\ncase 0x01:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x04:\r\nbreak;\r\ncase 0x05:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x06:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x07:\r\npr_debug("%s(), %s is not for IrDA mode\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x08:\r\npr_debug("%s(), %s\n",\r\n__func__, dongle_types[dongle_id]);\r\noutb(0x00, iobase+4);\r\nif (speed > 115200)\r\noutb(0x01, iobase+4);\r\nbreak;\r\ncase 0x09:\r\noutb(0x01, iobase+4);\r\nif (speed == 4000000) {\r\noutb(0x81, iobase+4);\r\noutb(0x80, iobase+4);\r\n} else\r\noutb(0x00, iobase+4);\r\nbreak;\r\ncase 0x0A:\r\ncase 0x0B:\r\npr_debug("%s(), %s not defined by irda yet\n",\r\n__func__, dongle_types[dongle_id]);\r\nbreak;\r\ncase 0x0C:\r\ncase 0x0D:\r\nbreak;\r\ncase 0x0E:\r\nbreak;\r\ncase 0x0F:\r\npr_debug("%s(), %s is not for IrDA mode\n",\r\n__func__, dongle_types[dongle_id]);\r\nswitch_bank(iobase, BANK0);\r\noutb(0x62, iobase+MCR);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), invalid data_rate\n", __func__);\r\n}\r\noutb(bank, iobase+BSR);\r\n}\r\nstatic __u8 nsc_ircc_change_speed(struct nsc_ircc_cb *self, __u32 speed)\r\n{\r\nstruct net_device *dev;\r\n__u8 mcr = MCR_SIR;\r\nint iobase;\r\n__u8 bank;\r\n__u8 ier;\r\npr_debug("%s(), speed=%d\n", __func__, speed);\r\nIRDA_ASSERT(self != NULL, return 0;);\r\ndev = self->netdev;\r\niobase = self->io.fir_base;\r\nself->io.speed = speed;\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\noutb(0, iobase+IER);\r\nswitch_bank(iobase, BANK2);\r\noutb(0x00, iobase+BGDH);\r\nswitch (speed) {\r\ncase 9600: outb(0x0c, iobase+BGDL); break;\r\ncase 19200: outb(0x06, iobase+BGDL); break;\r\ncase 38400: outb(0x03, iobase+BGDL); break;\r\ncase 57600: outb(0x02, iobase+BGDL); break;\r\ncase 115200: outb(0x01, iobase+BGDL); break;\r\ncase 576000:\r\nswitch_bank(iobase, BANK5);\r\noutb(inb(iobase+4) | 0x04, iobase+4);\r\nmcr = MCR_MIR;\r\npr_debug("%s(), handling baud of 576000\n", __func__);\r\nbreak;\r\ncase 1152000:\r\nmcr = MCR_MIR;\r\npr_debug("%s(), handling baud of 1152000\n", __func__);\r\nbreak;\r\ncase 4000000:\r\nmcr = MCR_FIR;\r\npr_debug("%s(), handling baud of 4000000\n", __func__);\r\nbreak;\r\ndefault:\r\nmcr = MCR_FIR;\r\npr_debug("%s(), unknown baud rate of %d\n",\r\n__func__, speed);\r\nbreak;\r\n}\r\nswitch_bank(iobase, BANK0);\r\noutb(mcr | MCR_TX_DFR, iobase+MCR);\r\nnsc_ircc_change_dongle_speed(iobase, speed, self->io.dongle_id);\r\nswitch_bank(iobase, BANK0);\r\noutb(0x00, iobase+FCR);\r\noutb(FCR_FIFO_EN, iobase+FCR);\r\noutb(FCR_RXTH|\r\nFCR_TXTH|\r\nFCR_TXSR|\r\nFCR_RXSR|\r\nFCR_FIFO_EN,\r\niobase+FCR);\r\nswitch_bank(iobase, BANK2);\r\noutb(EXCR2_RFSIZ|EXCR2_TFSIZ, iobase+EXCR2);\r\nswitch_bank(iobase, BANK0);\r\nif (speed > 115200) {\r\ndev->netdev_ops = &nsc_ircc_fir_ops;\r\nier = IER_SFIF_IE;\r\nnsc_ircc_dma_receive(self);\r\n} else {\r\ndev->netdev_ops = &nsc_ircc_sir_ops;\r\nier = IER_RXHDL_IE;\r\n}\r\noutb(ier, iobase+IER);\r\noutb(bank, iobase+BSR);\r\nreturn ier;\r\n}\r\nstatic netdev_tx_t nsc_ircc_hard_xmit_sir(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct nsc_ircc_cb *self;\r\nunsigned long flags;\r\nint iobase;\r\n__s32 speed;\r\n__u8 bank;\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return NETDEV_TX_OK;);\r\niobase = self->io.fir_base;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&self->lock, flags);\r\nspeed = irda_get_next_speed(skb);\r\nif ((speed != self->io.speed) && (speed != -1)) {\r\nif (!skb->len) {\r\nif (self->io.direction == IO_RECV) {\r\nnsc_ircc_change_speed(self, speed);\r\nnetif_wake_queue(dev);\r\n} else {\r\nself->new_speed = speed;\r\n}\r\nnetif_trans_update(dev);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n} else\r\nself->new_speed = speed;\r\n}\r\nbank = inb(iobase+BSR);\r\nself->tx_buff.data = self->tx_buff.head;\r\nself->tx_buff.len = async_wrap_skb(skb, self->tx_buff.data,\r\nself->tx_buff.truesize);\r\ndev->stats.tx_bytes += self->tx_buff.len;\r\nswitch_bank(iobase, BANK0);\r\noutb(IER_TXLDL_IE, iobase+IER);\r\noutb(bank, iobase+BSR);\r\nnetif_trans_update(dev);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t nsc_ircc_hard_xmit_fir(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct nsc_ircc_cb *self;\r\nunsigned long flags;\r\nint iobase;\r\n__s32 speed;\r\n__u8 bank;\r\nint mtt, diff;\r\nself = netdev_priv(dev);\r\niobase = self->io.fir_base;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&self->lock, flags);\r\nspeed = irda_get_next_speed(skb);\r\nif ((speed != self->io.speed) && (speed != -1)) {\r\nif (!skb->len) {\r\nif(self->tx_fifo.len == 0) {\r\nnsc_ircc_change_speed(self, speed);\r\nnetif_wake_queue(dev);\r\n} else {\r\nself->new_speed = speed;\r\n}\r\nnetif_trans_update(dev);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n} else {\r\nself->new_speed = speed;\r\n}\r\n}\r\nbank = inb(iobase+BSR);\r\nself->tx_fifo.queue[self->tx_fifo.free].start = self->tx_fifo.tail;\r\nself->tx_fifo.queue[self->tx_fifo.free].len = skb->len;\r\nself->tx_fifo.tail += skb->len;\r\ndev->stats.tx_bytes += skb->len;\r\nskb_copy_from_linear_data(skb, self->tx_fifo.queue[self->tx_fifo.free].start,\r\nskb->len);\r\nself->tx_fifo.len++;\r\nself->tx_fifo.free++;\r\nif (self->tx_fifo.len == 1) {\r\nmtt = irda_get_mtt(skb);\r\nif (mtt) {\r\ndiff = ktime_us_delta(ktime_get(), self->stamp);\r\nif (mtt > diff) {\r\nmtt -= diff;\r\nif (mtt > 125) {\r\nmtt = mtt / 125;\r\nswitch_bank(iobase, BANK4);\r\noutb(mtt & 0xff, iobase+TMRL);\r\noutb((mtt >> 8) & 0x0f, iobase+TMRH);\r\noutb(IRCR1_TMR_EN, iobase+IRCR1);\r\nself->io.direction = IO_XMIT;\r\nswitch_bank(iobase, BANK0);\r\noutb(IER_TMR_IE, iobase+IER);\r\ngoto out;\r\n} else\r\nudelay(mtt);\r\n}\r\n}\r\nswitch_bank(iobase, BANK0);\r\noutb(IER_DMA_IE, iobase+IER);\r\nnsc_ircc_dma_xmit(self, iobase);\r\n}\r\nout:\r\nif ((self->tx_fifo.free < MAX_TX_WINDOW) && (self->new_speed == 0))\r\nnetif_wake_queue(self->netdev);\r\noutb(bank, iobase+BSR);\r\nnetif_trans_update(dev);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void nsc_ircc_dma_xmit(struct nsc_ircc_cb *self, int iobase)\r\n{\r\nint bsr;\r\nbsr = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\noutb(inb(iobase+MCR) & ~MCR_DMA_EN, iobase+MCR);\r\nself->io.direction = IO_XMIT;\r\nswitch_bank(iobase, BANK2);\r\noutb(ECR1_DMASWP|ECR1_DMANF|ECR1_EXT_SL, iobase+ECR1);\r\nirda_setup_dma(self->io.dma,\r\n((u8 *)self->tx_fifo.queue[self->tx_fifo.ptr].start -\r\nself->tx_buff.head) + self->tx_buff_dma,\r\nself->tx_fifo.queue[self->tx_fifo.ptr].len,\r\nDMA_TX_MODE);\r\nswitch_bank(iobase, BANK0);\r\noutb(inb(iobase+MCR)|MCR_TX_DFR|MCR_DMA_EN|MCR_IR_PLS, iobase+MCR);\r\noutb(bsr, iobase+BSR);\r\n}\r\nstatic int nsc_ircc_pio_write(int iobase, __u8 *buf, int len, int fifo_size)\r\n{\r\nint actual = 0;\r\n__u8 bank;\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\nif (!(inb_p(iobase+LSR) & LSR_TXEMP)) {\r\npr_debug("%s(), warning, FIFO not empty yet!\n",\r\n__func__);\r\nfifo_size -= 17;\r\n}\r\nwhile ((fifo_size-- > 0) && (actual < len)) {\r\noutb(buf[actual++], iobase+TXD);\r\n}\r\npr_debug("%s(), fifo_size %d ; %d sent of %d\n",\r\n__func__, fifo_size, actual, len);\r\noutb(bank, iobase+BSR);\r\nreturn actual;\r\n}\r\nstatic int nsc_ircc_dma_xmit_complete(struct nsc_ircc_cb *self)\r\n{\r\nint iobase;\r\n__u8 bank;\r\nint ret = TRUE;\r\niobase = self->io.fir_base;\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\noutb(inb(iobase+MCR) & ~MCR_DMA_EN, iobase+MCR);\r\nif (inb(iobase+ASCR) & ASCR_TXUR) {\r\nself->netdev->stats.tx_errors++;\r\nself->netdev->stats.tx_fifo_errors++;\r\noutb(ASCR_TXUR, iobase+ASCR);\r\n} else {\r\nself->netdev->stats.tx_packets++;\r\n}\r\nself->tx_fifo.ptr++;\r\nself->tx_fifo.len--;\r\nif (self->tx_fifo.len) {\r\nnsc_ircc_dma_xmit(self, iobase);\r\nret = FALSE;\r\n} else {\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\n}\r\nif ((self->tx_fifo.free < MAX_TX_WINDOW) && (self->new_speed == 0)) {\r\nnetif_wake_queue(self->netdev);\r\n}\r\noutb(bank, iobase+BSR);\r\nreturn ret;\r\n}\r\nstatic int nsc_ircc_dma_receive(struct nsc_ircc_cb *self)\r\n{\r\nint iobase;\r\n__u8 bsr;\r\niobase = self->io.fir_base;\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\nbsr = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\noutb(inb(iobase+MCR) & ~MCR_DMA_EN, iobase+MCR);\r\nswitch_bank(iobase, BANK2);\r\noutb(ECR1_DMANF|ECR1_EXT_SL, iobase+ECR1);\r\nself->io.direction = IO_RECV;\r\nself->rx_buff.data = self->rx_buff.head;\r\nswitch_bank(iobase, BANK0);\r\noutb(FCR_RXSR|FCR_FIFO_EN, iobase+FCR);\r\nself->st_fifo.len = self->st_fifo.pending_bytes = 0;\r\nself->st_fifo.tail = self->st_fifo.head = 0;\r\nirda_setup_dma(self->io.dma, self->rx_buff_dma, self->rx_buff.truesize,\r\nDMA_RX_MODE);\r\nswitch_bank(iobase, BANK0);\r\noutb(inb(iobase+MCR)|MCR_DMA_EN, iobase+MCR);\r\noutb(bsr, iobase+BSR);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_dma_receive_complete(struct nsc_ircc_cb *self, int iobase)\r\n{\r\nstruct st_fifo *st_fifo;\r\nstruct sk_buff *skb;\r\n__u8 status;\r\n__u8 bank;\r\nint len;\r\nst_fifo = &self->st_fifo;\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK5);\r\nwhile ((status = inb(iobase+FRM_ST)) & FRM_ST_VLD) {\r\nlen = inb(iobase+RFLFL) | ((inb(iobase+RFLFH) & 0x1f) << 8);\r\nif (st_fifo->tail >= MAX_RX_WINDOW) {\r\npr_debug("%s(), window is full!\n", __func__);\r\ncontinue;\r\n}\r\nst_fifo->entries[st_fifo->tail].status = status;\r\nst_fifo->entries[st_fifo->tail].len = len;\r\nst_fifo->pending_bytes += len;\r\nst_fifo->tail++;\r\nst_fifo->len++;\r\n}\r\nwhile (st_fifo->len > 0) {\r\nstatus = st_fifo->entries[st_fifo->head].status;\r\nlen = st_fifo->entries[st_fifo->head].len;\r\nst_fifo->pending_bytes -= len;\r\nst_fifo->head++;\r\nst_fifo->len--;\r\nif (status & FRM_ST_ERR_MSK) {\r\nif (status & FRM_ST_LOST_FR) {\r\nself->netdev->stats.rx_errors += len;\r\n} else {\r\nself->netdev->stats.rx_errors++;\r\nself->rx_buff.data += len;\r\nif (status & FRM_ST_MAX_LEN)\r\nself->netdev->stats.rx_length_errors++;\r\nif (status & FRM_ST_PHY_ERR)\r\nself->netdev->stats.rx_frame_errors++;\r\nif (status & FRM_ST_BAD_CRC)\r\nself->netdev->stats.rx_crc_errors++;\r\n}\r\nif (status & FRM_ST_OVR1)\r\nself->netdev->stats.rx_fifo_errors++;\r\nif (status & FRM_ST_OVR2)\r\nself->netdev->stats.rx_fifo_errors++;\r\n} else {\r\nif (st_fifo->pending_bytes < self->io.fifo_size) {\r\nswitch_bank(iobase, BANK0);\r\nif (inb(iobase+LSR) & LSR_RXDA) {\r\nst_fifo->head--;\r\nst_fifo->len++;\r\nst_fifo->pending_bytes += len;\r\nst_fifo->entries[st_fifo->head].status = status;\r\nst_fifo->entries[st_fifo->head].len = len;\r\nswitch_bank(iobase, BANK4);\r\noutb(0x02, iobase+TMRL);\r\noutb(0x00, iobase+TMRH);\r\noutb(IRCR1_TMR_EN, iobase+IRCR1);\r\noutb(bank, iobase+BSR);\r\nreturn FALSE;\r\n}\r\n}\r\nself->stamp = ktime_get();\r\nskb = dev_alloc_skb(len+1);\r\nif (skb == NULL) {\r\nself->netdev->stats.rx_dropped++;\r\noutb(bank, iobase+BSR);\r\nreturn FALSE;\r\n}\r\nskb_reserve(skb, 1);\r\nif (self->io.speed < 4000000) {\r\nskb_put(skb, len-2);\r\nskb_copy_to_linear_data(skb,\r\nself->rx_buff.data,\r\nlen - 2);\r\n} else {\r\nskb_put(skb, len-4);\r\nskb_copy_to_linear_data(skb,\r\nself->rx_buff.data,\r\nlen - 4);\r\n}\r\nself->rx_buff.data += len;\r\nself->netdev->stats.rx_bytes += len;\r\nself->netdev->stats.rx_packets++;\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\n}\r\n}\r\noutb(bank, iobase+BSR);\r\nreturn TRUE;\r\n}\r\nstatic void nsc_ircc_pio_receive(struct nsc_ircc_cb *self)\r\n{\r\n__u8 byte;\r\nint iobase;\r\niobase = self->io.fir_base;\r\ndo {\r\nbyte = inb(iobase+RXD);\r\nasync_unwrap_char(self->netdev, &self->netdev->stats,\r\n&self->rx_buff, byte);\r\n} while (inb(iobase+LSR) & LSR_RXDA);\r\n}\r\nstatic void nsc_ircc_sir_interrupt(struct nsc_ircc_cb *self, int eir)\r\n{\r\nint actual;\r\nif (eir & EIR_TXLDL_EV) {\r\nactual = nsc_ircc_pio_write(self->io.fir_base,\r\nself->tx_buff.data,\r\nself->tx_buff.len,\r\nself->io.fifo_size);\r\nself->tx_buff.data += actual;\r\nself->tx_buff.len -= actual;\r\nself->io.direction = IO_XMIT;\r\nif (self->tx_buff.len > 0)\r\nself->ier = IER_TXLDL_IE;\r\nelse {\r\nself->netdev->stats.tx_packets++;\r\nnetif_wake_queue(self->netdev);\r\nself->ier = IER_TXEMP_IE;\r\n}\r\n}\r\nif (eir & EIR_TXEMP_EV) {\r\nself->io.direction = IO_RECV;\r\nself->ier = IER_RXHDL_IE;\r\nif (self->new_speed) {\r\npr_debug("%s(), Changing speed!\n", __func__);\r\nself->ier = nsc_ircc_change_speed(self,\r\nself->new_speed);\r\nself->new_speed = 0;\r\nnetif_wake_queue(self->netdev);\r\nif (self->io.speed > 115200) {\r\nreturn;\r\n}\r\n}\r\n}\r\nif (eir & EIR_RXHDL_EV) {\r\nnsc_ircc_pio_receive(self);\r\nself->ier = IER_RXHDL_IE;\r\n}\r\n}\r\nstatic void nsc_ircc_fir_interrupt(struct nsc_ircc_cb *self, int iobase,\r\nint eir)\r\n{\r\n__u8 bank;\r\nbank = inb(iobase+BSR);\r\nif (eir & EIR_SFIF_EV) {\r\nif (nsc_ircc_dma_receive_complete(self, iobase)) {\r\nself->ier = IER_SFIF_IE;\r\n} else {\r\nself->ier = IER_SFIF_IE | IER_TMR_IE;\r\n}\r\n} else if (eir & EIR_TMR_EV) {\r\nswitch_bank(iobase, BANK4);\r\noutb(0, iobase+IRCR1);\r\nswitch_bank(iobase, BANK0);\r\noutb(ASCR_CTE, iobase+ASCR);\r\nif (self->io.direction == IO_XMIT) {\r\nnsc_ircc_dma_xmit(self, iobase);\r\nself->ier = IER_DMA_IE;\r\n} else {\r\nif (nsc_ircc_dma_receive_complete(self, iobase)) {\r\nself->ier = IER_SFIF_IE;\r\n} else {\r\nself->ier = IER_SFIF_IE | IER_TMR_IE;\r\n}\r\n}\r\n} else if (eir & EIR_DMA_EV) {\r\nif (nsc_ircc_dma_xmit_complete(self)) {\r\nif(self->new_speed != 0) {\r\nself->ier = IER_TXEMP_IE;\r\n} else {\r\nif (irda_device_txqueue_empty(self->netdev)) {\r\nnsc_ircc_dma_receive(self);\r\nself->ier = IER_SFIF_IE;\r\n} else\r\nnet_warn_ratelimited("%s(), potential Tx queue lockup !\n",\r\n__func__);\r\n}\r\n} else {\r\nself->ier = IER_DMA_IE;\r\n}\r\n} else if (eir & EIR_TXEMP_EV) {\r\nself->ier = nsc_ircc_change_speed(self, self->new_speed);\r\nself->new_speed = 0;\r\nnetif_wake_queue(self->netdev);\r\n}\r\noutb(bank, iobase+BSR);\r\n}\r\nstatic irqreturn_t nsc_ircc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct nsc_ircc_cb *self;\r\n__u8 bsr, eir;\r\nint iobase;\r\nself = netdev_priv(dev);\r\nspin_lock(&self->lock);\r\niobase = self->io.fir_base;\r\nbsr = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\nself->ier = inb(iobase+IER);\r\neir = inb(iobase+EIR) & self->ier;\r\noutb(0, iobase+IER);\r\nif (eir) {\r\nif (self->io.speed > 115200)\r\nnsc_ircc_fir_interrupt(self, iobase, eir);\r\nelse\r\nnsc_ircc_sir_interrupt(self, eir);\r\n}\r\noutb(self->ier, iobase+IER);\r\noutb(bsr, iobase+BSR);\r\nspin_unlock(&self->lock);\r\nreturn IRQ_RETVAL(eir);\r\n}\r\nstatic int nsc_ircc_is_receiving(struct nsc_ircc_cb *self)\r\n{\r\nunsigned long flags;\r\nint status = FALSE;\r\nint iobase;\r\n__u8 bank;\r\nIRDA_ASSERT(self != NULL, return FALSE;);\r\nspin_lock_irqsave(&self->lock, flags);\r\nif (self->io.speed > 115200) {\r\niobase = self->io.fir_base;\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK2);\r\nif ((inb(iobase+RXFLV) & 0x3f) != 0) {\r\nstatus = TRUE;\r\n}\r\noutb(bank, iobase+BSR);\r\n} else\r\nstatus = (self->rx_buff.state != OUTSIDE_FRAME);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nreturn status;\r\n}\r\nstatic int nsc_ircc_net_open(struct net_device *dev)\r\n{\r\nstruct nsc_ircc_cb *self;\r\nint iobase;\r\nchar hwname[32];\r\n__u8 bank;\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return 0;);\r\niobase = self->io.fir_base;\r\nif (request_irq(self->io.irq, nsc_ircc_interrupt, 0, dev->name, dev)) {\r\nnet_warn_ratelimited("%s, unable to allocate irq=%d\n",\r\ndriver_name, self->io.irq);\r\nreturn -EAGAIN;\r\n}\r\nif (request_dma(self->io.dma, dev->name)) {\r\nnet_warn_ratelimited("%s, unable to allocate dma=%d\n",\r\ndriver_name, self->io.dma);\r\nfree_irq(self->io.irq, dev);\r\nreturn -EAGAIN;\r\n}\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\noutb(IER_LS_IE | IER_RXHDL_IE, iobase+IER);\r\noutb(bank, iobase+BSR);\r\nnetif_start_queue(dev);\r\nsprintf(hwname, "NSC-FIR @ 0x%03x", self->io.fir_base);\r\nself->irlap = irlap_open(dev, &self->qos, hwname);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_net_close(struct net_device *dev)\r\n{\r\nstruct nsc_ircc_cb *self;\r\nint iobase;\r\n__u8 bank;\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return 0;);\r\nnetif_stop_queue(dev);\r\nif (self->irlap)\r\nirlap_close(self->irlap);\r\nself->irlap = NULL;\r\niobase = self->io.fir_base;\r\ndisable_dma(self->io.dma);\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\noutb(0, iobase+IER);\r\nfree_irq(self->io.irq, dev);\r\nfree_dma(self->io.dma);\r\noutb(bank, iobase+BSR);\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_net_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nstruct nsc_ircc_cb *self;\r\nunsigned long flags;\r\nint ret = 0;\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\npr_debug("%s(), %s, (cmd=0x%X)\n", __func__, dev->name, cmd);\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&self->lock, flags);\r\nnsc_ircc_change_speed(self, irq->ifr_baudrate);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nirda_device_set_media_busy(self->netdev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nirq->ifr_receiving = nsc_ircc_is_receiving(self);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int nsc_ircc_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct nsc_ircc_cb *self = platform_get_drvdata(dev);\r\nint bank;\r\nunsigned long flags;\r\nint iobase = self->io.fir_base;\r\nif (self->io.suspended)\r\nreturn 0;\r\npr_debug("%s, Suspending\n", driver_name);\r\nrtnl_lock();\r\nif (netif_running(self->netdev)) {\r\nnetif_device_detach(self->netdev);\r\nspin_lock_irqsave(&self->lock, flags);\r\nbank = inb(iobase+BSR);\r\nswitch_bank(iobase, BANK0);\r\noutb(0, iobase+IER);\r\noutb(bank, iobase+BSR);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nfree_irq(self->io.irq, self->netdev);\r\ndisable_dma(self->io.dma);\r\n}\r\nself->io.suspended = 1;\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int nsc_ircc_resume(struct platform_device *dev)\r\n{\r\nstruct nsc_ircc_cb *self = platform_get_drvdata(dev);\r\nunsigned long flags;\r\nif (!self->io.suspended)\r\nreturn 0;\r\npr_debug("%s, Waking up\n", driver_name);\r\nrtnl_lock();\r\nnsc_ircc_setup(&self->io);\r\nnsc_ircc_init_dongle_interface(self->io.fir_base, self->io.dongle_id);\r\nif (netif_running(self->netdev)) {\r\nif (request_irq(self->io.irq, nsc_ircc_interrupt, 0,\r\nself->netdev->name, self->netdev)) {\r\nnet_warn_ratelimited("%s, unable to allocate irq=%d\n",\r\ndriver_name, self->io.irq);\r\nunregister_netdevice(self->netdev);\r\n} else {\r\nspin_lock_irqsave(&self->lock, flags);\r\nnsc_ircc_change_speed(self, self->io.speed);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nnetif_device_attach(self->netdev);\r\n}\r\n} else {\r\nspin_lock_irqsave(&self->lock, flags);\r\nnsc_ircc_change_speed(self, 9600);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\n}\r\nself->io.suspended = 0;\r\nrtnl_unlock();\r\nreturn 0;\r\n}
