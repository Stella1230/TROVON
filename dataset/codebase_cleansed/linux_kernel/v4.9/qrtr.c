static inline struct qrtr_sock *qrtr_sk(struct sock *sk)\r\n{\r\nBUILD_BUG_ON(offsetof(struct qrtr_sock, sk) != 0);\r\nreturn container_of(sk, struct qrtr_sock, sk);\r\n}\r\nstatic void __qrtr_node_release(struct kref *kref)\r\n{\r\nstruct qrtr_node *node = container_of(kref, struct qrtr_node, ref);\r\nif (node->nid != QRTR_EP_NID_AUTO)\r\nradix_tree_delete(&qrtr_nodes, node->nid);\r\nlist_del(&node->item);\r\nmutex_unlock(&qrtr_node_lock);\r\nskb_queue_purge(&node->rx_queue);\r\nkfree(node);\r\n}\r\nstatic struct qrtr_node *qrtr_node_acquire(struct qrtr_node *node)\r\n{\r\nif (node)\r\nkref_get(&node->ref);\r\nreturn node;\r\n}\r\nstatic void qrtr_node_release(struct qrtr_node *node)\r\n{\r\nif (!node)\r\nreturn;\r\nkref_put_mutex(&node->ref, __qrtr_node_release, &qrtr_node_lock);\r\n}\r\nstatic int qrtr_node_enqueue(struct qrtr_node *node, struct sk_buff *skb)\r\n{\r\nint rc = -ENODEV;\r\nmutex_lock(&node->ep_lock);\r\nif (node->ep)\r\nrc = node->ep->xmit(node->ep, skb);\r\nelse\r\nkfree_skb(skb);\r\nmutex_unlock(&node->ep_lock);\r\nreturn rc;\r\n}\r\nstatic struct qrtr_node *qrtr_node_lookup(unsigned int nid)\r\n{\r\nstruct qrtr_node *node;\r\nmutex_lock(&qrtr_node_lock);\r\nnode = radix_tree_lookup(&qrtr_nodes, nid);\r\nnode = qrtr_node_acquire(node);\r\nmutex_unlock(&qrtr_node_lock);\r\nreturn node;\r\n}\r\nstatic void qrtr_node_assign(struct qrtr_node *node, unsigned int nid)\r\n{\r\nif (node->nid != QRTR_EP_NID_AUTO || nid == QRTR_EP_NID_AUTO)\r\nreturn;\r\nmutex_lock(&qrtr_node_lock);\r\nradix_tree_insert(&qrtr_nodes, nid, node);\r\nnode->nid = nid;\r\nmutex_unlock(&qrtr_node_lock);\r\n}\r\nint qrtr_endpoint_post(struct qrtr_endpoint *ep, const void *data, size_t len)\r\n{\r\nstruct qrtr_node *node = ep->node;\r\nconst struct qrtr_hdr *phdr = data;\r\nstruct sk_buff *skb;\r\nunsigned int psize;\r\nunsigned int size;\r\nunsigned int type;\r\nunsigned int ver;\r\nunsigned int dst;\r\nif (len < QRTR_HDR_SIZE || len & 3)\r\nreturn -EINVAL;\r\nver = le32_to_cpu(phdr->version);\r\nsize = le32_to_cpu(phdr->size);\r\ntype = le32_to_cpu(phdr->type);\r\ndst = le32_to_cpu(phdr->dst_port_id);\r\npsize = (size + 3) & ~3;\r\nif (ver != QRTR_PROTO_VER)\r\nreturn -EINVAL;\r\nif (len != psize + QRTR_HDR_SIZE)\r\nreturn -EINVAL;\r\nif (dst != QRTR_PORT_CTRL && type != QRTR_TYPE_DATA)\r\nreturn -EINVAL;\r\nskb = netdev_alloc_skb(NULL, len);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_reset_transport_header(skb);\r\nmemcpy(skb_put(skb, len), data, len);\r\nskb_queue_tail(&node->rx_queue, skb);\r\nschedule_work(&node->work);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *qrtr_alloc_resume_tx(u32 src_node,\r\nu32 dst_node, u32 port)\r\n{\r\nconst int pkt_len = 20;\r\nstruct qrtr_hdr *hdr;\r\nstruct sk_buff *skb;\r\nu32 *buf;\r\nskb = alloc_skb(QRTR_HDR_SIZE + pkt_len, GFP_KERNEL);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reset_transport_header(skb);\r\nhdr = (struct qrtr_hdr *)skb_put(skb, QRTR_HDR_SIZE);\r\nhdr->version = cpu_to_le32(QRTR_PROTO_VER);\r\nhdr->type = cpu_to_le32(QRTR_TYPE_RESUME_TX);\r\nhdr->src_node_id = cpu_to_le32(src_node);\r\nhdr->src_port_id = cpu_to_le32(QRTR_PORT_CTRL);\r\nhdr->confirm_rx = cpu_to_le32(0);\r\nhdr->size = cpu_to_le32(pkt_len);\r\nhdr->dst_node_id = cpu_to_le32(dst_node);\r\nhdr->dst_port_id = cpu_to_le32(QRTR_PORT_CTRL);\r\nbuf = (u32 *)skb_put(skb, pkt_len);\r\nmemset(buf, 0, pkt_len);\r\nbuf[0] = cpu_to_le32(QRTR_TYPE_RESUME_TX);\r\nbuf[1] = cpu_to_le32(src_node);\r\nbuf[2] = cpu_to_le32(port);\r\nreturn skb;\r\n}\r\nstatic void qrtr_node_rx_work(struct work_struct *work)\r\n{\r\nstruct qrtr_node *node = container_of(work, struct qrtr_node, work);\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&node->rx_queue)) != NULL) {\r\nconst struct qrtr_hdr *phdr;\r\nu32 dst_node, dst_port;\r\nstruct qrtr_sock *ipc;\r\nu32 src_node;\r\nint confirm;\r\nphdr = (const struct qrtr_hdr *)skb_transport_header(skb);\r\nsrc_node = le32_to_cpu(phdr->src_node_id);\r\ndst_node = le32_to_cpu(phdr->dst_node_id);\r\ndst_port = le32_to_cpu(phdr->dst_port_id);\r\nconfirm = !!phdr->confirm_rx;\r\nqrtr_node_assign(node, src_node);\r\nipc = qrtr_port_lookup(dst_port);\r\nif (!ipc) {\r\nkfree_skb(skb);\r\n} else {\r\nif (sock_queue_rcv_skb(&ipc->sk, skb))\r\nkfree_skb(skb);\r\nqrtr_port_put(ipc);\r\n}\r\nif (confirm) {\r\nskb = qrtr_alloc_resume_tx(dst_node, node->nid, dst_port);\r\nif (!skb)\r\nbreak;\r\nif (qrtr_node_enqueue(node, skb))\r\nbreak;\r\n}\r\n}\r\n}\r\nint qrtr_endpoint_register(struct qrtr_endpoint *ep, unsigned int nid)\r\n{\r\nstruct qrtr_node *node;\r\nif (!ep || !ep->xmit)\r\nreturn -EINVAL;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nINIT_WORK(&node->work, qrtr_node_rx_work);\r\nkref_init(&node->ref);\r\nmutex_init(&node->ep_lock);\r\nskb_queue_head_init(&node->rx_queue);\r\nnode->nid = QRTR_EP_NID_AUTO;\r\nnode->ep = ep;\r\nqrtr_node_assign(node, nid);\r\nmutex_lock(&qrtr_node_lock);\r\nlist_add(&node->item, &qrtr_all_nodes);\r\nmutex_unlock(&qrtr_node_lock);\r\nep->node = node;\r\nreturn 0;\r\n}\r\nvoid qrtr_endpoint_unregister(struct qrtr_endpoint *ep)\r\n{\r\nstruct qrtr_node *node = ep->node;\r\nmutex_lock(&node->ep_lock);\r\nnode->ep = NULL;\r\nmutex_unlock(&node->ep_lock);\r\nqrtr_node_release(node);\r\nep->node = NULL;\r\n}\r\nstatic struct qrtr_sock *qrtr_port_lookup(int port)\r\n{\r\nstruct qrtr_sock *ipc;\r\nif (port == QRTR_PORT_CTRL)\r\nport = 0;\r\nmutex_lock(&qrtr_port_lock);\r\nipc = idr_find(&qrtr_ports, port);\r\nif (ipc)\r\nsock_hold(&ipc->sk);\r\nmutex_unlock(&qrtr_port_lock);\r\nreturn ipc;\r\n}\r\nstatic void qrtr_port_put(struct qrtr_sock *ipc)\r\n{\r\nsock_put(&ipc->sk);\r\n}\r\nstatic void qrtr_port_remove(struct qrtr_sock *ipc)\r\n{\r\nint port = ipc->us.sq_port;\r\nif (port == QRTR_PORT_CTRL)\r\nport = 0;\r\n__sock_put(&ipc->sk);\r\nmutex_lock(&qrtr_port_lock);\r\nidr_remove(&qrtr_ports, port);\r\nmutex_unlock(&qrtr_port_lock);\r\n}\r\nstatic int qrtr_port_assign(struct qrtr_sock *ipc, int *port)\r\n{\r\nint rc;\r\nmutex_lock(&qrtr_port_lock);\r\nif (!*port) {\r\nrc = idr_alloc(&qrtr_ports, ipc,\r\nQRTR_MIN_EPH_SOCKET, QRTR_MAX_EPH_SOCKET + 1,\r\nGFP_ATOMIC);\r\nif (rc >= 0)\r\n*port = rc;\r\n} else if (*port < QRTR_MIN_EPH_SOCKET && !capable(CAP_NET_ADMIN)) {\r\nrc = -EACCES;\r\n} else if (*port == QRTR_PORT_CTRL) {\r\nrc = idr_alloc(&qrtr_ports, ipc, 0, 1, GFP_ATOMIC);\r\n} else {\r\nrc = idr_alloc(&qrtr_ports, ipc, *port, *port + 1, GFP_ATOMIC);\r\nif (rc >= 0)\r\n*port = rc;\r\n}\r\nmutex_unlock(&qrtr_port_lock);\r\nif (rc == -ENOSPC)\r\nreturn -EADDRINUSE;\r\nelse if (rc < 0)\r\nreturn rc;\r\nsock_hold(&ipc->sk);\r\nreturn 0;\r\n}\r\nstatic int __qrtr_bind(struct socket *sock,\r\nconst struct sockaddr_qrtr *addr, int zapped)\r\n{\r\nstruct qrtr_sock *ipc = qrtr_sk(sock->sk);\r\nstruct sock *sk = sock->sk;\r\nint port;\r\nint rc;\r\nif (!zapped && addr->sq_port == ipc->us.sq_port)\r\nreturn 0;\r\nport = addr->sq_port;\r\nrc = qrtr_port_assign(ipc, &port);\r\nif (rc)\r\nreturn rc;\r\nif (!zapped)\r\nqrtr_port_remove(ipc);\r\nipc->us.sq_port = port;\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nreturn 0;\r\n}\r\nstatic int qrtr_autobind(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_qrtr addr;\r\nif (!sock_flag(sk, SOCK_ZAPPED))\r\nreturn 0;\r\naddr.sq_family = AF_QIPCRTR;\r\naddr.sq_node = qrtr_local_nid;\r\naddr.sq_port = 0;\r\nreturn __qrtr_bind(sock, &addr, 1);\r\n}\r\nstatic int qrtr_bind(struct socket *sock, struct sockaddr *saddr, int len)\r\n{\r\nDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);\r\nstruct qrtr_sock *ipc = qrtr_sk(sock->sk);\r\nstruct sock *sk = sock->sk;\r\nint rc;\r\nif (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)\r\nreturn -EINVAL;\r\nif (addr->sq_node != ipc->us.sq_node)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nrc = __qrtr_bind(sock, addr, sock_flag(sk, SOCK_ZAPPED));\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int qrtr_local_enqueue(struct qrtr_node *node, struct sk_buff *skb)\r\n{\r\nconst struct qrtr_hdr *phdr;\r\nstruct qrtr_sock *ipc;\r\nphdr = (const struct qrtr_hdr *)skb_transport_header(skb);\r\nipc = qrtr_port_lookup(le32_to_cpu(phdr->dst_port_id));\r\nif (!ipc || &ipc->sk == skb->sk) {\r\nkfree_skb(skb);\r\nreturn -ENODEV;\r\n}\r\nif (sock_queue_rcv_skb(&ipc->sk, skb)) {\r\nqrtr_port_put(ipc);\r\nkfree_skb(skb);\r\nreturn -ENOSPC;\r\n}\r\nqrtr_port_put(ipc);\r\nreturn 0;\r\n}\r\nstatic int qrtr_bcast_enqueue(struct qrtr_node *node, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skbn;\r\nmutex_lock(&qrtr_node_lock);\r\nlist_for_each_entry(node, &qrtr_all_nodes, item) {\r\nskbn = skb_clone(skb, GFP_KERNEL);\r\nif (!skbn)\r\nbreak;\r\nskb_set_owner_w(skbn, skb->sk);\r\nqrtr_node_enqueue(node, skbn);\r\n}\r\nmutex_unlock(&qrtr_node_lock);\r\nqrtr_local_enqueue(node, skb);\r\nreturn 0;\r\n}\r\nstatic int qrtr_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\r\n{\r\nDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, msg->msg_name);\r\nint (*enqueue_fn)(struct qrtr_node *, struct sk_buff *);\r\nstruct qrtr_sock *ipc = qrtr_sk(sock->sk);\r\nstruct sock *sk = sock->sk;\r\nstruct qrtr_node *node;\r\nstruct qrtr_hdr *hdr;\r\nstruct sk_buff *skb;\r\nsize_t plen;\r\nint rc;\r\nif (msg->msg_flags & ~(MSG_DONTWAIT))\r\nreturn -EINVAL;\r\nif (len > 65535)\r\nreturn -EMSGSIZE;\r\nlock_sock(sk);\r\nif (addr) {\r\nif (msg->msg_namelen < sizeof(*addr)) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nif (addr->sq_family != AF_QIPCRTR) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nrc = qrtr_autobind(sock);\r\nif (rc) {\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\n} else if (sk->sk_state == TCP_ESTABLISHED) {\r\naddr = &ipc->peer;\r\n} else {\r\nrelease_sock(sk);\r\nreturn -ENOTCONN;\r\n}\r\nnode = NULL;\r\nif (addr->sq_node == QRTR_NODE_BCAST) {\r\nenqueue_fn = qrtr_bcast_enqueue;\r\n} else if (addr->sq_node == ipc->us.sq_node) {\r\nenqueue_fn = qrtr_local_enqueue;\r\n} else {\r\nenqueue_fn = qrtr_node_enqueue;\r\nnode = qrtr_node_lookup(addr->sq_node);\r\nif (!node) {\r\nrelease_sock(sk);\r\nreturn -ECONNRESET;\r\n}\r\n}\r\nplen = (len + 3) & ~3;\r\nskb = sock_alloc_send_skb(sk, plen + QRTR_HDR_SIZE,\r\nmsg->msg_flags & MSG_DONTWAIT, &rc);\r\nif (!skb)\r\ngoto out_node;\r\nskb_reset_transport_header(skb);\r\nskb_put(skb, len + QRTR_HDR_SIZE);\r\nhdr = (struct qrtr_hdr *)skb_transport_header(skb);\r\nhdr->version = cpu_to_le32(QRTR_PROTO_VER);\r\nhdr->src_node_id = cpu_to_le32(ipc->us.sq_node);\r\nhdr->src_port_id = cpu_to_le32(ipc->us.sq_port);\r\nhdr->confirm_rx = cpu_to_le32(0);\r\nhdr->size = cpu_to_le32(len);\r\nhdr->dst_node_id = cpu_to_le32(addr->sq_node);\r\nhdr->dst_port_id = cpu_to_le32(addr->sq_port);\r\nrc = skb_copy_datagram_from_iter(skb, QRTR_HDR_SIZE,\r\n&msg->msg_iter, len);\r\nif (rc) {\r\nkfree_skb(skb);\r\ngoto out_node;\r\n}\r\nif (plen != len) {\r\nskb_pad(skb, plen - len);\r\nskb_put(skb, plen - len);\r\n}\r\nif (ipc->us.sq_port == QRTR_PORT_CTRL) {\r\nif (len < 4) {\r\nrc = -EINVAL;\r\nkfree_skb(skb);\r\ngoto out_node;\r\n}\r\nskb_copy_bits(skb, QRTR_HDR_SIZE, &hdr->type, 4);\r\n} else {\r\nhdr->type = cpu_to_le32(QRTR_TYPE_DATA);\r\n}\r\nrc = enqueue_fn(node, skb);\r\nif (rc >= 0)\r\nrc = len;\r\nout_node:\r\nqrtr_node_release(node);\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int qrtr_recvmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t size, int flags)\r\n{\r\nDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, msg->msg_name);\r\nconst struct qrtr_hdr *phdr;\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nint copied, rc;\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nrelease_sock(sk);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\r\nflags & MSG_DONTWAIT, &rc);\r\nif (!skb) {\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nphdr = (const struct qrtr_hdr *)skb_transport_header(skb);\r\ncopied = le32_to_cpu(phdr->size);\r\nif (copied > size) {\r\ncopied = size;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nrc = skb_copy_datagram_msg(skb, QRTR_HDR_SIZE, msg, copied);\r\nif (rc < 0)\r\ngoto out;\r\nrc = copied;\r\nif (addr) {\r\naddr->sq_family = AF_QIPCRTR;\r\naddr->sq_node = le32_to_cpu(phdr->src_node_id);\r\naddr->sq_port = le32_to_cpu(phdr->src_port_id);\r\nmsg->msg_namelen = sizeof(*addr);\r\n}\r\nout:\r\nskb_free_datagram(sk, skb);\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int qrtr_connect(struct socket *sock, struct sockaddr *saddr,\r\nint len, int flags)\r\n{\r\nDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);\r\nstruct qrtr_sock *ipc = qrtr_sk(sock->sk);\r\nstruct sock *sk = sock->sk;\r\nint rc;\r\nif (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nsk->sk_state = TCP_CLOSE;\r\nsock->state = SS_UNCONNECTED;\r\nrc = qrtr_autobind(sock);\r\nif (rc) {\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nipc->peer = *addr;\r\nsock->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nstatic int qrtr_getname(struct socket *sock, struct sockaddr *saddr,\r\nint *len, int peer)\r\n{\r\nstruct qrtr_sock *ipc = qrtr_sk(sock->sk);\r\nstruct sockaddr_qrtr qaddr;\r\nstruct sock *sk = sock->sk;\r\nlock_sock(sk);\r\nif (peer) {\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nrelease_sock(sk);\r\nreturn -ENOTCONN;\r\n}\r\nqaddr = ipc->peer;\r\n} else {\r\nqaddr = ipc->us;\r\n}\r\nrelease_sock(sk);\r\n*len = sizeof(qaddr);\r\nqaddr.sq_family = AF_QIPCRTR;\r\nmemcpy(saddr, &qaddr, sizeof(qaddr));\r\nreturn 0;\r\n}\r\nstatic int qrtr_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nstruct qrtr_sock *ipc = qrtr_sk(sock->sk);\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_qrtr *sq;\r\nstruct sk_buff *skb;\r\nstruct ifreq ifr;\r\nlong len = 0;\r\nint rc = 0;\r\nlock_sock(sk);\r\nswitch (cmd) {\r\ncase TIOCOUTQ:\r\nlen = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (len < 0)\r\nlen = 0;\r\nrc = put_user(len, (int __user *)argp);\r\nbreak;\r\ncase TIOCINQ:\r\nskb = skb_peek(&sk->sk_receive_queue);\r\nif (skb)\r\nlen = skb->len - QRTR_HDR_SIZE;\r\nrc = put_user(len, (int __user *)argp);\r\nbreak;\r\ncase SIOCGIFADDR:\r\nif (copy_from_user(&ifr, argp, sizeof(ifr))) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nsq = (struct sockaddr_qrtr *)&ifr.ifr_addr;\r\n*sq = ipc->us;\r\nif (copy_to_user(argp, &ifr, sizeof(ifr))) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nbreak;\r\ncase SIOCGSTAMP:\r\nrc = sock_get_timestamp(sk, argp);\r\nbreak;\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\nrc = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int qrtr_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct qrtr_sock *ipc;\r\nif (!sk)\r\nreturn 0;\r\nlock_sock(sk);\r\nipc = qrtr_sk(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\nsock->sk = NULL;\r\nif (!sock_flag(sk, SOCK_ZAPPED))\r\nqrtr_port_remove(ipc);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int qrtr_create(struct net *net, struct socket *sock,\r\nint protocol, int kern)\r\n{\r\nstruct qrtr_sock *ipc;\r\nstruct sock *sk;\r\nif (sock->type != SOCK_DGRAM)\r\nreturn -EPROTOTYPE;\r\nsk = sk_alloc(net, AF_QIPCRTR, GFP_KERNEL, &qrtr_proto, kern);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\nsock_init_data(sock, sk);\r\nsock->ops = &qrtr_proto_ops;\r\nipc = qrtr_sk(sk);\r\nipc->us.sq_family = AF_QIPCRTR;\r\nipc->us.sq_node = qrtr_local_nid;\r\nipc->us.sq_port = 0;\r\nreturn 0;\r\n}\r\nstatic int qrtr_addr_doit(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct nlattr *tb[IFA_MAX + 1];\r\nstruct ifaddrmsg *ifm;\r\nint rc;\r\nif (!netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (!netlink_capable(skb, CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nASSERT_RTNL();\r\nrc = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, qrtr_policy);\r\nif (rc < 0)\r\nreturn rc;\r\nifm = nlmsg_data(nlh);\r\nif (!tb[IFA_LOCAL])\r\nreturn -EINVAL;\r\nqrtr_local_nid = nla_get_u32(tb[IFA_LOCAL]);\r\nreturn 0;\r\n}\r\nstatic int __init qrtr_proto_init(void)\r\n{\r\nint rc;\r\nrc = proto_register(&qrtr_proto, 1);\r\nif (rc)\r\nreturn rc;\r\nrc = sock_register(&qrtr_family);\r\nif (rc) {\r\nproto_unregister(&qrtr_proto);\r\nreturn rc;\r\n}\r\nrtnl_register(PF_QIPCRTR, RTM_NEWADDR, qrtr_addr_doit, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic void __exit qrtr_proto_fini(void)\r\n{\r\nrtnl_unregister(PF_QIPCRTR, RTM_NEWADDR);\r\nsock_unregister(qrtr_family.family);\r\nproto_unregister(&qrtr_proto);\r\n}
