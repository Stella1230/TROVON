static\r\nstruct iio_sw_trigger_type *__iio_find_sw_trigger_type(const char *name,\r\nunsigned len)\r\n{\r\nstruct iio_sw_trigger_type *t = NULL, *iter;\r\nlist_for_each_entry(iter, &iio_trigger_types_list, list)\r\nif (!strcmp(iter->name, name)) {\r\nt = iter;\r\nbreak;\r\n}\r\nreturn t;\r\n}\r\nint iio_register_sw_trigger_type(struct iio_sw_trigger_type *t)\r\n{\r\nstruct iio_sw_trigger_type *iter;\r\nint ret = 0;\r\nmutex_lock(&iio_trigger_types_lock);\r\niter = __iio_find_sw_trigger_type(t->name, strlen(t->name));\r\nif (iter)\r\nret = -EBUSY;\r\nelse\r\nlist_add_tail(&t->list, &iio_trigger_types_list);\r\nmutex_unlock(&iio_trigger_types_lock);\r\nif (ret)\r\nreturn ret;\r\nt->group = configfs_register_default_group(iio_triggers_group, t->name,\r\n&iio_trigger_type_group_type);\r\nif (IS_ERR(t->group))\r\nret = PTR_ERR(t->group);\r\nreturn ret;\r\n}\r\nvoid iio_unregister_sw_trigger_type(struct iio_sw_trigger_type *t)\r\n{\r\nstruct iio_sw_trigger_type *iter;\r\nmutex_lock(&iio_trigger_types_lock);\r\niter = __iio_find_sw_trigger_type(t->name, strlen(t->name));\r\nif (iter)\r\nlist_del(&t->list);\r\nmutex_unlock(&iio_trigger_types_lock);\r\nconfigfs_unregister_default_group(t->group);\r\n}\r\nstatic\r\nstruct iio_sw_trigger_type *iio_get_sw_trigger_type(const char *name)\r\n{\r\nstruct iio_sw_trigger_type *t;\r\nmutex_lock(&iio_trigger_types_lock);\r\nt = __iio_find_sw_trigger_type(name, strlen(name));\r\nif (t && !try_module_get(t->owner))\r\nt = NULL;\r\nmutex_unlock(&iio_trigger_types_lock);\r\nreturn t;\r\n}\r\nstruct iio_sw_trigger *iio_sw_trigger_create(const char *type, const char *name)\r\n{\r\nstruct iio_sw_trigger *t;\r\nstruct iio_sw_trigger_type *tt;\r\ntt = iio_get_sw_trigger_type(type);\r\nif (!tt) {\r\npr_err("Invalid trigger type: %s\n", type);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nt = tt->ops->probe(name);\r\nif (IS_ERR(t))\r\ngoto out_module_put;\r\nt->trigger_type = tt;\r\nreturn t;\r\nout_module_put:\r\nmodule_put(tt->owner);\r\nreturn t;\r\n}\r\nvoid iio_sw_trigger_destroy(struct iio_sw_trigger *t)\r\n{\r\nstruct iio_sw_trigger_type *tt = t->trigger_type;\r\ntt->ops->remove(t);\r\nmodule_put(tt->owner);\r\n}\r\nstatic struct config_group *trigger_make_group(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct iio_sw_trigger *t;\r\nt = iio_sw_trigger_create(group->cg_item.ci_name, name);\r\nif (IS_ERR(t))\r\nreturn ERR_CAST(t);\r\nconfig_item_set_name(&t->group.cg_item, "%s", name);\r\nreturn &t->group;\r\n}\r\nstatic void trigger_drop_group(struct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct iio_sw_trigger *t = to_iio_sw_trigger(item);\r\niio_sw_trigger_destroy(t);\r\nconfig_item_put(item);\r\n}\r\nstatic int __init iio_sw_trigger_init(void)\r\n{\r\niio_triggers_group =\r\nconfigfs_register_default_group(&iio_configfs_subsys.su_group,\r\n"triggers",\r\n&iio_triggers_group_type);\r\nreturn PTR_ERR_OR_ZERO(iio_triggers_group);\r\n}\r\nstatic void __exit iio_sw_trigger_exit(void)\r\n{\r\nconfigfs_unregister_default_group(iio_triggers_group);\r\n}
