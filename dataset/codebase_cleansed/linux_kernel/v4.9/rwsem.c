void __sched down_read(struct rw_semaphore *sem)\r\n{\r\nmight_sleep();\r\nrwsem_acquire_read(&sem->dep_map, 0, 0, _RET_IP_);\r\nLOCK_CONTENDED(sem, __down_read_trylock, __down_read);\r\nrwsem_set_reader_owned(sem);\r\n}\r\nint down_read_trylock(struct rw_semaphore *sem)\r\n{\r\nint ret = __down_read_trylock(sem);\r\nif (ret == 1) {\r\nrwsem_acquire_read(&sem->dep_map, 0, 1, _RET_IP_);\r\nrwsem_set_reader_owned(sem);\r\n}\r\nreturn ret;\r\n}\r\nvoid __sched down_write(struct rw_semaphore *sem)\r\n{\r\nmight_sleep();\r\nrwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\r\nLOCK_CONTENDED(sem, __down_write_trylock, __down_write);\r\nrwsem_set_owner(sem);\r\n}\r\nint __sched down_write_killable(struct rw_semaphore *sem)\r\n{\r\nmight_sleep();\r\nrwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\r\nif (LOCK_CONTENDED_RETURN(sem, __down_write_trylock, __down_write_killable)) {\r\nrwsem_release(&sem->dep_map, 1, _RET_IP_);\r\nreturn -EINTR;\r\n}\r\nrwsem_set_owner(sem);\r\nreturn 0;\r\n}\r\nint down_write_trylock(struct rw_semaphore *sem)\r\n{\r\nint ret = __down_write_trylock(sem);\r\nif (ret == 1) {\r\nrwsem_acquire(&sem->dep_map, 0, 1, _RET_IP_);\r\nrwsem_set_owner(sem);\r\n}\r\nreturn ret;\r\n}\r\nvoid up_read(struct rw_semaphore *sem)\r\n{\r\nrwsem_release(&sem->dep_map, 1, _RET_IP_);\r\n__up_read(sem);\r\n}\r\nvoid up_write(struct rw_semaphore *sem)\r\n{\r\nrwsem_release(&sem->dep_map, 1, _RET_IP_);\r\nrwsem_clear_owner(sem);\r\n__up_write(sem);\r\n}\r\nvoid downgrade_write(struct rw_semaphore *sem)\r\n{\r\nrwsem_set_reader_owned(sem);\r\n__downgrade_write(sem);\r\n}\r\nvoid down_read_nested(struct rw_semaphore *sem, int subclass)\r\n{\r\nmight_sleep();\r\nrwsem_acquire_read(&sem->dep_map, subclass, 0, _RET_IP_);\r\nLOCK_CONTENDED(sem, __down_read_trylock, __down_read);\r\nrwsem_set_reader_owned(sem);\r\n}\r\nvoid _down_write_nest_lock(struct rw_semaphore *sem, struct lockdep_map *nest)\r\n{\r\nmight_sleep();\r\nrwsem_acquire_nest(&sem->dep_map, 0, 0, nest, _RET_IP_);\r\nLOCK_CONTENDED(sem, __down_write_trylock, __down_write);\r\nrwsem_set_owner(sem);\r\n}\r\nvoid down_read_non_owner(struct rw_semaphore *sem)\r\n{\r\nmight_sleep();\r\n__down_read(sem);\r\n}\r\nvoid down_write_nested(struct rw_semaphore *sem, int subclass)\r\n{\r\nmight_sleep();\r\nrwsem_acquire(&sem->dep_map, subclass, 0, _RET_IP_);\r\nLOCK_CONTENDED(sem, __down_write_trylock, __down_write);\r\nrwsem_set_owner(sem);\r\n}\r\nint __sched down_write_killable_nested(struct rw_semaphore *sem, int subclass)\r\n{\r\nmight_sleep();\r\nrwsem_acquire(&sem->dep_map, subclass, 0, _RET_IP_);\r\nif (LOCK_CONTENDED_RETURN(sem, __down_write_trylock, __down_write_killable)) {\r\nrwsem_release(&sem->dep_map, 1, _RET_IP_);\r\nreturn -EINTR;\r\n}\r\nrwsem_set_owner(sem);\r\nreturn 0;\r\n}\r\nvoid up_read_non_owner(struct rw_semaphore *sem)\r\n{\r\n__up_read(sem);\r\n}
