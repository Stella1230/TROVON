static ssize_t usbip_debug_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%lx\n", usbip_debug_flag);\r\n}\r\nstatic ssize_t usbip_debug_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nif (sscanf(buf, "%lx", &usbip_debug_flag) != 1)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic void usbip_dump_buffer(char *buff, int bufflen)\r\n{\r\nprint_hex_dump(KERN_DEBUG, "usbip-core", DUMP_PREFIX_OFFSET, 16, 4,\r\nbuff, bufflen, false);\r\n}\r\nstatic void usbip_dump_pipe(unsigned int p)\r\n{\r\nunsigned char type = usb_pipetype(p);\r\nunsigned char ep = usb_pipeendpoint(p);\r\nunsigned char dev = usb_pipedevice(p);\r\nunsigned char dir = usb_pipein(p);\r\npr_debug("dev(%d) ep(%d) [%s] ", dev, ep, dir ? "IN" : "OUT");\r\nswitch (type) {\r\ncase PIPE_ISOCHRONOUS:\r\npr_debug("ISO\n");\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\npr_debug("INT\n");\r\nbreak;\r\ncase PIPE_CONTROL:\r\npr_debug("CTRL\n");\r\nbreak;\r\ncase PIPE_BULK:\r\npr_debug("BULK\n");\r\nbreak;\r\ndefault:\r\npr_debug("ERR\n");\r\nbreak;\r\n}\r\n}\r\nstatic void usbip_dump_usb_device(struct usb_device *udev)\r\n{\r\nstruct device *dev = &udev->dev;\r\nint i;\r\ndev_dbg(dev, " devnum(%d) devpath(%s) usb speed(%s)",\r\nudev->devnum, udev->devpath, usb_speed_string(udev->speed));\r\npr_debug("tt %p, ttport %d\n", udev->tt, udev->ttport);\r\ndev_dbg(dev, " ");\r\nfor (i = 0; i < 16; i++)\r\npr_debug(" %2u", i);\r\npr_debug("\n");\r\ndev_dbg(dev, " toggle0(IN) :");\r\nfor (i = 0; i < 16; i++)\r\npr_debug(" %2u", (udev->toggle[0] & (1 << i)) ? 1 : 0);\r\npr_debug("\n");\r\ndev_dbg(dev, " toggle1(OUT):");\r\nfor (i = 0; i < 16; i++)\r\npr_debug(" %2u", (udev->toggle[1] & (1 << i)) ? 1 : 0);\r\npr_debug("\n");\r\ndev_dbg(dev, " epmaxp_in :");\r\nfor (i = 0; i < 16; i++) {\r\nif (udev->ep_in[i])\r\npr_debug(" %2u",\r\nle16_to_cpu(udev->ep_in[i]->desc.wMaxPacketSize));\r\n}\r\npr_debug("\n");\r\ndev_dbg(dev, " epmaxp_out :");\r\nfor (i = 0; i < 16; i++) {\r\nif (udev->ep_out[i])\r\npr_debug(" %2u",\r\nle16_to_cpu(udev->ep_out[i]->desc.wMaxPacketSize));\r\n}\r\npr_debug("\n");\r\ndev_dbg(dev, "parent %p, bus %p\n", udev->parent, udev->bus);\r\ndev_dbg(dev,\r\n"descriptor %p, config %p, actconfig %p, rawdescriptors %p\n",\r\n&udev->descriptor, udev->config,\r\nudev->actconfig, udev->rawdescriptors);\r\ndev_dbg(dev, "have_langid %d, string_langid %d\n",\r\nudev->have_langid, udev->string_langid);\r\ndev_dbg(dev, "maxchild %d\n", udev->maxchild);\r\n}\r\nstatic void usbip_dump_request_type(__u8 rt)\r\n{\r\nswitch (rt & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\npr_debug("DEVICE");\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\npr_debug("INTERF");\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\npr_debug("ENDPOI");\r\nbreak;\r\ncase USB_RECIP_OTHER:\r\npr_debug("OTHER ");\r\nbreak;\r\ndefault:\r\npr_debug("------");\r\nbreak;\r\n}\r\n}\r\nstatic void usbip_dump_usb_ctrlrequest(struct usb_ctrlrequest *cmd)\r\n{\r\nif (!cmd) {\r\npr_debug(" : null pointer\n");\r\nreturn;\r\n}\r\npr_debug(" ");\r\npr_debug("bRequestType(%02X) bRequest(%02X) wValue(%04X) wIndex(%04X) wLength(%04X) ",\r\ncmd->bRequestType, cmd->bRequest,\r\ncmd->wValue, cmd->wIndex, cmd->wLength);\r\npr_debug("\n ");\r\nif ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\npr_debug("STANDARD ");\r\nswitch (cmd->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\npr_debug("GET_STATUS\n");\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\npr_debug("CLEAR_FEAT\n");\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\npr_debug("SET_FEAT\n");\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\npr_debug("SET_ADDRRS\n");\r\nbreak;\r\ncase USB_REQ_GET_DESCRIPTOR:\r\npr_debug("GET_DESCRI\n");\r\nbreak;\r\ncase USB_REQ_SET_DESCRIPTOR:\r\npr_debug("SET_DESCRI\n");\r\nbreak;\r\ncase USB_REQ_GET_CONFIGURATION:\r\npr_debug("GET_CONFIG\n");\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\npr_debug("SET_CONFIG\n");\r\nbreak;\r\ncase USB_REQ_GET_INTERFACE:\r\npr_debug("GET_INTERF\n");\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\npr_debug("SET_INTERF\n");\r\nbreak;\r\ncase USB_REQ_SYNCH_FRAME:\r\npr_debug("SYNC_FRAME\n");\r\nbreak;\r\ndefault:\r\npr_debug("REQ(%02X)\n", cmd->bRequest);\r\nbreak;\r\n}\r\nusbip_dump_request_type(cmd->bRequestType);\r\n} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {\r\npr_debug("CLASS\n");\r\n} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR) {\r\npr_debug("VENDOR\n");\r\n} else if ((cmd->bRequestType & USB_TYPE_MASK) == USB_TYPE_RESERVED) {\r\npr_debug("RESERVED\n");\r\n}\r\n}\r\nvoid usbip_dump_urb(struct urb *urb)\r\n{\r\nstruct device *dev;\r\nif (!urb) {\r\npr_debug("urb: null pointer!!\n");\r\nreturn;\r\n}\r\nif (!urb->dev) {\r\npr_debug("urb->dev: null pointer!!\n");\r\nreturn;\r\n}\r\ndev = &urb->dev->dev;\r\ndev_dbg(dev, " urb :%p\n", urb);\r\ndev_dbg(dev, " dev :%p\n", urb->dev);\r\nusbip_dump_usb_device(urb->dev);\r\ndev_dbg(dev, " pipe :%08x ", urb->pipe);\r\nusbip_dump_pipe(urb->pipe);\r\ndev_dbg(dev, " status :%d\n", urb->status);\r\ndev_dbg(dev, " transfer_flags :%08X\n", urb->transfer_flags);\r\ndev_dbg(dev, " transfer_buffer :%p\n", urb->transfer_buffer);\r\ndev_dbg(dev, " transfer_buffer_length:%d\n",\r\nurb->transfer_buffer_length);\r\ndev_dbg(dev, " actual_length :%d\n", urb->actual_length);\r\ndev_dbg(dev, " setup_packet :%p\n", urb->setup_packet);\r\nif (urb->setup_packet && usb_pipetype(urb->pipe) == PIPE_CONTROL)\r\nusbip_dump_usb_ctrlrequest(\r\n(struct usb_ctrlrequest *)urb->setup_packet);\r\ndev_dbg(dev, " start_frame :%d\n", urb->start_frame);\r\ndev_dbg(dev, " number_of_packets :%d\n", urb->number_of_packets);\r\ndev_dbg(dev, " interval :%d\n", urb->interval);\r\ndev_dbg(dev, " error_count :%d\n", urb->error_count);\r\ndev_dbg(dev, " context :%p\n", urb->context);\r\ndev_dbg(dev, " complete :%p\n", urb->complete);\r\n}\r\nvoid usbip_dump_header(struct usbip_header *pdu)\r\n{\r\npr_debug("BASE: cmd %u seq %u devid %u dir %u ep %u\n",\r\npdu->base.command,\r\npdu->base.seqnum,\r\npdu->base.devid,\r\npdu->base.direction,\r\npdu->base.ep);\r\nswitch (pdu->base.command) {\r\ncase USBIP_CMD_SUBMIT:\r\npr_debug("USBIP_CMD_SUBMIT: x_flags %u x_len %u sf %u #p %d iv %d\n",\r\npdu->u.cmd_submit.transfer_flags,\r\npdu->u.cmd_submit.transfer_buffer_length,\r\npdu->u.cmd_submit.start_frame,\r\npdu->u.cmd_submit.number_of_packets,\r\npdu->u.cmd_submit.interval);\r\nbreak;\r\ncase USBIP_CMD_UNLINK:\r\npr_debug("USBIP_CMD_UNLINK: seq %u\n",\r\npdu->u.cmd_unlink.seqnum);\r\nbreak;\r\ncase USBIP_RET_SUBMIT:\r\npr_debug("USBIP_RET_SUBMIT: st %d al %u sf %d #p %d ec %d\n",\r\npdu->u.ret_submit.status,\r\npdu->u.ret_submit.actual_length,\r\npdu->u.ret_submit.start_frame,\r\npdu->u.ret_submit.number_of_packets,\r\npdu->u.ret_submit.error_count);\r\nbreak;\r\ncase USBIP_RET_UNLINK:\r\npr_debug("USBIP_RET_UNLINK: status %d\n",\r\npdu->u.ret_unlink.status);\r\nbreak;\r\ndefault:\r\npr_err("unknown command\n");\r\nbreak;\r\n}\r\n}\r\nint usbip_recv(struct socket *sock, void *buf, int size)\r\n{\r\nint result;\r\nstruct msghdr msg;\r\nstruct kvec iov;\r\nint total = 0;\r\nchar *bp = buf;\r\nint osize = size;\r\nusbip_dbg_xmit("enter\n");\r\nif (!sock || !buf || !size) {\r\npr_err("invalid arg, sock %p buff %p size %d\n", sock, buf,\r\nsize);\r\nreturn -EINVAL;\r\n}\r\ndo {\r\nsock->sk->sk_allocation = GFP_NOIO;\r\niov.iov_base = buf;\r\niov.iov_len = size;\r\nmsg.msg_name = NULL;\r\nmsg.msg_namelen = 0;\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = MSG_NOSIGNAL;\r\nresult = kernel_recvmsg(sock, &msg, &iov, 1, size, MSG_WAITALL);\r\nif (result <= 0) {\r\npr_debug("receive sock %p buf %p size %u ret %d total %d\n",\r\nsock, buf, size, result, total);\r\ngoto err;\r\n}\r\nsize -= result;\r\nbuf += result;\r\ntotal += result;\r\n} while (size > 0);\r\nif (usbip_dbg_flag_xmit) {\r\nif (!in_interrupt())\r\npr_debug("%-10s:", current->comm);\r\nelse\r\npr_debug("interrupt :");\r\npr_debug("receiving....\n");\r\nusbip_dump_buffer(bp, osize);\r\npr_debug("received, osize %d ret %d size %d total %d\n",\r\nosize, result, size, total);\r\n}\r\nreturn total;\r\nerr:\r\nreturn result;\r\n}\r\nstatic unsigned int tweak_transfer_flags(unsigned int flags)\r\n{\r\nflags &= ~URB_NO_TRANSFER_DMA_MAP;\r\nreturn flags;\r\n}\r\nstatic void usbip_pack_cmd_submit(struct usbip_header *pdu, struct urb *urb,\r\nint pack)\r\n{\r\nstruct usbip_header_cmd_submit *spdu = &pdu->u.cmd_submit;\r\nif (pack) {\r\nspdu->transfer_flags =\r\ntweak_transfer_flags(urb->transfer_flags);\r\nspdu->transfer_buffer_length = urb->transfer_buffer_length;\r\nspdu->start_frame = urb->start_frame;\r\nspdu->number_of_packets = urb->number_of_packets;\r\nspdu->interval = urb->interval;\r\n} else {\r\nurb->transfer_flags = spdu->transfer_flags;\r\nurb->transfer_buffer_length = spdu->transfer_buffer_length;\r\nurb->start_frame = spdu->start_frame;\r\nurb->number_of_packets = spdu->number_of_packets;\r\nurb->interval = spdu->interval;\r\n}\r\n}\r\nstatic void usbip_pack_ret_submit(struct usbip_header *pdu, struct urb *urb,\r\nint pack)\r\n{\r\nstruct usbip_header_ret_submit *rpdu = &pdu->u.ret_submit;\r\nif (pack) {\r\nrpdu->status = urb->status;\r\nrpdu->actual_length = urb->actual_length;\r\nrpdu->start_frame = urb->start_frame;\r\nrpdu->number_of_packets = urb->number_of_packets;\r\nrpdu->error_count = urb->error_count;\r\n} else {\r\nurb->status = rpdu->status;\r\nurb->actual_length = rpdu->actual_length;\r\nurb->start_frame = rpdu->start_frame;\r\nurb->number_of_packets = rpdu->number_of_packets;\r\nurb->error_count = rpdu->error_count;\r\n}\r\n}\r\nvoid usbip_pack_pdu(struct usbip_header *pdu, struct urb *urb, int cmd,\r\nint pack)\r\n{\r\nswitch (cmd) {\r\ncase USBIP_CMD_SUBMIT:\r\nusbip_pack_cmd_submit(pdu, urb, pack);\r\nbreak;\r\ncase USBIP_RET_SUBMIT:\r\nusbip_pack_ret_submit(pdu, urb, pack);\r\nbreak;\r\ndefault:\r\npr_err("unknown command\n");\r\nbreak;\r\n}\r\n}\r\nstatic void correct_endian_basic(struct usbip_header_basic *base, int send)\r\n{\r\nif (send) {\r\nbase->command = cpu_to_be32(base->command);\r\nbase->seqnum = cpu_to_be32(base->seqnum);\r\nbase->devid = cpu_to_be32(base->devid);\r\nbase->direction = cpu_to_be32(base->direction);\r\nbase->ep = cpu_to_be32(base->ep);\r\n} else {\r\nbase->command = be32_to_cpu(base->command);\r\nbase->seqnum = be32_to_cpu(base->seqnum);\r\nbase->devid = be32_to_cpu(base->devid);\r\nbase->direction = be32_to_cpu(base->direction);\r\nbase->ep = be32_to_cpu(base->ep);\r\n}\r\n}\r\nstatic void correct_endian_cmd_submit(struct usbip_header_cmd_submit *pdu,\r\nint send)\r\n{\r\nif (send) {\r\npdu->transfer_flags = cpu_to_be32(pdu->transfer_flags);\r\ncpu_to_be32s(&pdu->transfer_buffer_length);\r\ncpu_to_be32s(&pdu->start_frame);\r\ncpu_to_be32s(&pdu->number_of_packets);\r\ncpu_to_be32s(&pdu->interval);\r\n} else {\r\npdu->transfer_flags = be32_to_cpu(pdu->transfer_flags);\r\nbe32_to_cpus(&pdu->transfer_buffer_length);\r\nbe32_to_cpus(&pdu->start_frame);\r\nbe32_to_cpus(&pdu->number_of_packets);\r\nbe32_to_cpus(&pdu->interval);\r\n}\r\n}\r\nstatic void correct_endian_ret_submit(struct usbip_header_ret_submit *pdu,\r\nint send)\r\n{\r\nif (send) {\r\ncpu_to_be32s(&pdu->status);\r\ncpu_to_be32s(&pdu->actual_length);\r\ncpu_to_be32s(&pdu->start_frame);\r\ncpu_to_be32s(&pdu->number_of_packets);\r\ncpu_to_be32s(&pdu->error_count);\r\n} else {\r\nbe32_to_cpus(&pdu->status);\r\nbe32_to_cpus(&pdu->actual_length);\r\nbe32_to_cpus(&pdu->start_frame);\r\nbe32_to_cpus(&pdu->number_of_packets);\r\nbe32_to_cpus(&pdu->error_count);\r\n}\r\n}\r\nstatic void correct_endian_cmd_unlink(struct usbip_header_cmd_unlink *pdu,\r\nint send)\r\n{\r\nif (send)\r\npdu->seqnum = cpu_to_be32(pdu->seqnum);\r\nelse\r\npdu->seqnum = be32_to_cpu(pdu->seqnum);\r\n}\r\nstatic void correct_endian_ret_unlink(struct usbip_header_ret_unlink *pdu,\r\nint send)\r\n{\r\nif (send)\r\ncpu_to_be32s(&pdu->status);\r\nelse\r\nbe32_to_cpus(&pdu->status);\r\n}\r\nvoid usbip_header_correct_endian(struct usbip_header *pdu, int send)\r\n{\r\n__u32 cmd = 0;\r\nif (send)\r\ncmd = pdu->base.command;\r\ncorrect_endian_basic(&pdu->base, send);\r\nif (!send)\r\ncmd = pdu->base.command;\r\nswitch (cmd) {\r\ncase USBIP_CMD_SUBMIT:\r\ncorrect_endian_cmd_submit(&pdu->u.cmd_submit, send);\r\nbreak;\r\ncase USBIP_RET_SUBMIT:\r\ncorrect_endian_ret_submit(&pdu->u.ret_submit, send);\r\nbreak;\r\ncase USBIP_CMD_UNLINK:\r\ncorrect_endian_cmd_unlink(&pdu->u.cmd_unlink, send);\r\nbreak;\r\ncase USBIP_RET_UNLINK:\r\ncorrect_endian_ret_unlink(&pdu->u.ret_unlink, send);\r\nbreak;\r\ndefault:\r\npr_err("unknown command\n");\r\nbreak;\r\n}\r\n}\r\nstatic void usbip_iso_packet_correct_endian(\r\nstruct usbip_iso_packet_descriptor *iso, int send)\r\n{\r\nif (send) {\r\niso->offset = cpu_to_be32(iso->offset);\r\niso->length = cpu_to_be32(iso->length);\r\niso->status = cpu_to_be32(iso->status);\r\niso->actual_length = cpu_to_be32(iso->actual_length);\r\n} else {\r\niso->offset = be32_to_cpu(iso->offset);\r\niso->length = be32_to_cpu(iso->length);\r\niso->status = be32_to_cpu(iso->status);\r\niso->actual_length = be32_to_cpu(iso->actual_length);\r\n}\r\n}\r\nstatic void usbip_pack_iso(struct usbip_iso_packet_descriptor *iso,\r\nstruct usb_iso_packet_descriptor *uiso, int pack)\r\n{\r\nif (pack) {\r\niso->offset = uiso->offset;\r\niso->length = uiso->length;\r\niso->status = uiso->status;\r\niso->actual_length = uiso->actual_length;\r\n} else {\r\nuiso->offset = iso->offset;\r\nuiso->length = iso->length;\r\nuiso->status = iso->status;\r\nuiso->actual_length = iso->actual_length;\r\n}\r\n}\r\nstruct usbip_iso_packet_descriptor*\r\nusbip_alloc_iso_desc_pdu(struct urb *urb, ssize_t *bufflen)\r\n{\r\nstruct usbip_iso_packet_descriptor *iso;\r\nint np = urb->number_of_packets;\r\nssize_t size = np * sizeof(*iso);\r\nint i;\r\niso = kzalloc(size, GFP_KERNEL);\r\nif (!iso)\r\nreturn NULL;\r\nfor (i = 0; i < np; i++) {\r\nusbip_pack_iso(&iso[i], &urb->iso_frame_desc[i], 1);\r\nusbip_iso_packet_correct_endian(&iso[i], 1);\r\n}\r\n*bufflen = size;\r\nreturn iso;\r\n}\r\nint usbip_recv_iso(struct usbip_device *ud, struct urb *urb)\r\n{\r\nvoid *buff;\r\nstruct usbip_iso_packet_descriptor *iso;\r\nint np = urb->number_of_packets;\r\nint size = np * sizeof(*iso);\r\nint i;\r\nint ret;\r\nint total_length = 0;\r\nif (!usb_pipeisoc(urb->pipe))\r\nreturn 0;\r\nif (np == 0)\r\nreturn 0;\r\nbuff = kzalloc(size, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nret = usbip_recv(ud->tcp_socket, buff, size);\r\nif (ret != size) {\r\ndev_err(&urb->dev->dev, "recv iso_frame_descriptor, %d\n",\r\nret);\r\nkfree(buff);\r\nif (ud->side == USBIP_STUB || ud->side == USBIP_VUDC)\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\r\nelse\r\nusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\r\nreturn -EPIPE;\r\n}\r\niso = (struct usbip_iso_packet_descriptor *) buff;\r\nfor (i = 0; i < np; i++) {\r\nusbip_iso_packet_correct_endian(&iso[i], 0);\r\nusbip_pack_iso(&iso[i], &urb->iso_frame_desc[i], 0);\r\ntotal_length += urb->iso_frame_desc[i].actual_length;\r\n}\r\nkfree(buff);\r\nif (total_length != urb->actual_length) {\r\ndev_err(&urb->dev->dev,\r\n"total length of iso packets %d not equal to actual length of buffer %d\n",\r\ntotal_length, urb->actual_length);\r\nif (ud->side == USBIP_STUB || ud->side == USBIP_VUDC)\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\r\nelse\r\nusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\r\nreturn -EPIPE;\r\n}\r\nreturn ret;\r\n}\r\nvoid usbip_pad_iso(struct usbip_device *ud, struct urb *urb)\r\n{\r\nint np = urb->number_of_packets;\r\nint i;\r\nint actualoffset = urb->actual_length;\r\nif (!usb_pipeisoc(urb->pipe))\r\nreturn;\r\nif (np == 0 || urb->actual_length == 0)\r\nreturn;\r\nif (urb->actual_length == urb->transfer_buffer_length)\r\nreturn;\r\nfor (i = np-1; i > 0; i--) {\r\nactualoffset -= urb->iso_frame_desc[i].actual_length;\r\nmemmove(urb->transfer_buffer + urb->iso_frame_desc[i].offset,\r\nurb->transfer_buffer + actualoffset,\r\nurb->iso_frame_desc[i].actual_length);\r\n}\r\n}\r\nint usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\r\n{\r\nint ret;\r\nint size;\r\nif (ud->side == USBIP_STUB || ud->side == USBIP_VUDC) {\r\nif (usb_pipein(urb->pipe))\r\nreturn 0;\r\nsize = urb->transfer_buffer_length;\r\n} else {\r\nif (usb_pipeout(urb->pipe))\r\nreturn 0;\r\nsize = urb->actual_length;\r\n}\r\nif (!(size > 0))\r\nreturn 0;\r\nif (size > urb->transfer_buffer_length) {\r\nif (ud->side == USBIP_STUB) {\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\r\nreturn 0;\r\n} else {\r\nusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\r\nreturn -EPIPE;\r\n}\r\n}\r\nret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\r\nif (ret != size) {\r\ndev_err(&urb->dev->dev, "recv xbuf, %d\n", ret);\r\nif (ud->side == USBIP_STUB || ud->side == USBIP_VUDC) {\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\r\n} else {\r\nusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\r\nreturn -EPIPE;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init usbip_core_init(void)\r\n{\r\nint ret;\r\npr_info(DRIVER_DESC " v" USBIP_VERSION "\n");\r\nret = usbip_init_eh();\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void __exit usbip_core_exit(void)\r\n{\r\nusbip_finish_eh();\r\nreturn;\r\n}
