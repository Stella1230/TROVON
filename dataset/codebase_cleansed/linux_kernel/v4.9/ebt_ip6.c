static bool\r\nebt_ip6_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct ebt_ip6_info *info = par->matchinfo;\r\nconst struct ipv6hdr *ih6;\r\nstruct ipv6hdr _ip6h;\r\nconst union pkthdr *pptr;\r\nunion pkthdr _pkthdr;\r\nih6 = skb_header_pointer(skb, 0, sizeof(_ip6h), &_ip6h);\r\nif (ih6 == NULL)\r\nreturn false;\r\nif ((info->bitmask & EBT_IP6_TCLASS) &&\r\nNF_INVF(info, EBT_IP6_TCLASS,\r\ninfo->tclass != ipv6_get_dsfield(ih6)))\r\nreturn false;\r\nif (((info->bitmask & EBT_IP6_SOURCE) &&\r\nNF_INVF(info, EBT_IP6_SOURCE,\r\nipv6_masked_addr_cmp(&ih6->saddr, &info->smsk,\r\n&info->saddr))) ||\r\n((info->bitmask & EBT_IP6_DEST) &&\r\nNF_INVF(info, EBT_IP6_DEST,\r\nipv6_masked_addr_cmp(&ih6->daddr, &info->dmsk,\r\n&info->daddr))))\r\nreturn false;\r\nif (info->bitmask & EBT_IP6_PROTO) {\r\nuint8_t nexthdr = ih6->nexthdr;\r\n__be16 frag_off;\r\nint offset_ph;\r\noffset_ph = ipv6_skip_exthdr(skb, sizeof(_ip6h), &nexthdr, &frag_off);\r\nif (offset_ph == -1)\r\nreturn false;\r\nif (NF_INVF(info, EBT_IP6_PROTO, info->protocol != nexthdr))\r\nreturn false;\r\nif (!(info->bitmask & (EBT_IP6_DPORT |\r\nEBT_IP6_SPORT | EBT_IP6_ICMP6)))\r\nreturn true;\r\npptr = skb_header_pointer(skb, offset_ph, sizeof(_pkthdr),\r\n&_pkthdr);\r\nif (pptr == NULL)\r\nreturn false;\r\nif (info->bitmask & EBT_IP6_DPORT) {\r\nu16 dst = ntohs(pptr->tcpudphdr.dst);\r\nif (NF_INVF(info, EBT_IP6_DPORT,\r\ndst < info->dport[0] ||\r\ndst > info->dport[1]))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_IP6_SPORT) {\r\nu16 src = ntohs(pptr->tcpudphdr.src);\r\nif (NF_INVF(info, EBT_IP6_SPORT,\r\nsrc < info->sport[0] ||\r\nsrc > info->sport[1]))\r\nreturn false;\r\n}\r\nif ((info->bitmask & EBT_IP6_ICMP6) &&\r\nNF_INVF(info, EBT_IP6_ICMP6,\r\npptr->icmphdr.type < info->icmpv6_type[0] ||\r\npptr->icmphdr.type > info->icmpv6_type[1] ||\r\npptr->icmphdr.code < info->icmpv6_code[0] ||\r\npptr->icmphdr.code > info->icmpv6_code[1]))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int ebt_ip6_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ebt_entry *e = par->entryinfo;\r\nstruct ebt_ip6_info *info = par->matchinfo;\r\nif (e->ethproto != htons(ETH_P_IPV6) || e->invflags & EBT_IPROTO)\r\nreturn -EINVAL;\r\nif (info->bitmask & ~EBT_IP6_MASK || info->invflags & ~EBT_IP6_MASK)\r\nreturn -EINVAL;\r\nif (info->bitmask & (EBT_IP6_DPORT | EBT_IP6_SPORT)) {\r\nif (info->invflags & EBT_IP6_PROTO)\r\nreturn -EINVAL;\r\nif (info->protocol != IPPROTO_TCP &&\r\ninfo->protocol != IPPROTO_UDP &&\r\ninfo->protocol != IPPROTO_UDPLITE &&\r\ninfo->protocol != IPPROTO_SCTP &&\r\ninfo->protocol != IPPROTO_DCCP)\r\nreturn -EINVAL;\r\n}\r\nif (info->bitmask & EBT_IP6_DPORT && info->dport[0] > info->dport[1])\r\nreturn -EINVAL;\r\nif (info->bitmask & EBT_IP6_SPORT && info->sport[0] > info->sport[1])\r\nreturn -EINVAL;\r\nif (info->bitmask & EBT_IP6_ICMP6) {\r\nif ((info->invflags & EBT_IP6_PROTO) ||\r\ninfo->protocol != IPPROTO_ICMPV6)\r\nreturn -EINVAL;\r\nif (info->icmpv6_type[0] > info->icmpv6_type[1] ||\r\ninfo->icmpv6_code[0] > info->icmpv6_code[1])\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ebt_ip6_init(void)\r\n{\r\nreturn xt_register_match(&ebt_ip6_mt_reg);\r\n}\r\nstatic void __exit ebt_ip6_fini(void)\r\n{\r\nxt_unregister_match(&ebt_ip6_mt_reg);\r\n}
