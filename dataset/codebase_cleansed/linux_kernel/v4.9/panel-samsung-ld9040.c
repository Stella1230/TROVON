static inline struct ld9040 *panel_to_ld9040(struct drm_panel *panel)\r\n{\r\nreturn container_of(panel, struct ld9040, panel);\r\n}\r\nstatic int ld9040_clear_error(struct ld9040 *ctx)\r\n{\r\nint ret = ctx->error;\r\nctx->error = 0;\r\nreturn ret;\r\n}\r\nstatic int ld9040_spi_write_word(struct ld9040 *ctx, u16 data)\r\n{\r\nstruct spi_device *spi = to_spi_device(ctx->dev);\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.tx_buf = &data,\r\n};\r\nstruct spi_message msg;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nreturn spi_sync(spi, &msg);\r\n}\r\nstatic void ld9040_dcs_write(struct ld9040 *ctx, const u8 *data, size_t len)\r\n{\r\nint ret = 0;\r\nif (ctx->error < 0 || len == 0)\r\nreturn;\r\ndev_dbg(ctx->dev, "writing dcs seq: %*ph\n", (int)len, data);\r\nret = ld9040_spi_write_word(ctx, *data);\r\nwhile (!ret && --len) {\r\n++data;\r\nret = ld9040_spi_write_word(ctx, *data | 0x100);\r\n}\r\nif (ret) {\r\ndev_err(ctx->dev, "error %d writing dcs seq: %*ph\n", ret,\r\n(int)len, data);\r\nctx->error = ret;\r\n}\r\nusleep_range(300, 310);\r\n}\r\nstatic void ld9040_brightness_set(struct ld9040 *ctx)\r\n{\r\nld9040_dcs_write(ctx, ld9040_gammas[ctx->brightness],\r\nARRAY_SIZE(ld9040_gammas[ctx->brightness]));\r\nld9040_dcs_write_seq_static(ctx, MCS_GAMMA_CTRL, 0x02, 0x5a);\r\n}\r\nstatic void ld9040_init(struct ld9040 *ctx)\r\n{\r\nld9040_dcs_write_seq_static(ctx, MCS_USER_SETTING, 0x5a, 0x5a);\r\nld9040_dcs_write_seq_static(ctx, MCS_PANEL_CONDITION,\r\n0x05, 0x65, 0x96, 0x71, 0x7d, 0x19, 0x3b, 0x0d,\r\n0x19, 0x7e, 0x0d, 0xe2, 0x00, 0x00, 0x7e, 0x7d,\r\n0x07, 0x07, 0x20, 0x20, 0x20, 0x02, 0x02);\r\nld9040_dcs_write_seq_static(ctx, MCS_DISPCTL,\r\n0x02, 0x08, 0x08, 0x10, 0x10);\r\nld9040_dcs_write_seq_static(ctx, MCS_MANPWR, 0x04);\r\nld9040_dcs_write_seq_static(ctx, MCS_POWER_CTRL,\r\n0x0a, 0x87, 0x25, 0x6a, 0x44, 0x02, 0x88);\r\nld9040_dcs_write_seq_static(ctx, MCS_ELVSS_ON, 0x0d, 0x00, 0x16);\r\nld9040_dcs_write_seq_static(ctx, MCS_GTCON, 0x09, 0x00, 0x00);\r\nld9040_brightness_set(ctx);\r\nld9040_dcs_write_seq_static(ctx, MIPI_DCS_EXIT_SLEEP_MODE);\r\nld9040_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_ON);\r\n}\r\nstatic int ld9040_power_on(struct ld9040 *ctx)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(ctx->power_on_delay);\r\ngpiod_set_value(ctx->reset_gpio, 0);\r\nmsleep(ctx->reset_delay);\r\ngpiod_set_value(ctx->reset_gpio, 1);\r\nmsleep(ctx->reset_delay);\r\nreturn 0;\r\n}\r\nstatic int ld9040_power_off(struct ld9040 *ctx)\r\n{\r\nreturn regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\r\n}\r\nstatic int ld9040_disable(struct drm_panel *panel)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ld9040_unprepare(struct drm_panel *panel)\r\n{\r\nstruct ld9040 *ctx = panel_to_ld9040(panel);\r\nmsleep(120);\r\nld9040_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_OFF);\r\nld9040_dcs_write_seq_static(ctx, MIPI_DCS_ENTER_SLEEP_MODE);\r\nmsleep(40);\r\nld9040_clear_error(ctx);\r\nreturn ld9040_power_off(ctx);\r\n}\r\nstatic int ld9040_prepare(struct drm_panel *panel)\r\n{\r\nstruct ld9040 *ctx = panel_to_ld9040(panel);\r\nint ret;\r\nret = ld9040_power_on(ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nld9040_init(ctx);\r\nret = ld9040_clear_error(ctx);\r\nif (ret < 0)\r\nld9040_unprepare(panel);\r\nreturn ret;\r\n}\r\nstatic int ld9040_enable(struct drm_panel *panel)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ld9040_get_modes(struct drm_panel *panel)\r\n{\r\nstruct drm_connector *connector = panel->connector;\r\nstruct ld9040 *ctx = panel_to_ld9040(panel);\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_create(connector->dev);\r\nif (!mode) {\r\nDRM_ERROR("failed to create a new display mode\n");\r\nreturn 0;\r\n}\r\ndrm_display_mode_from_videomode(&ctx->vm, mode);\r\nmode->width_mm = ctx->width_mm;\r\nmode->height_mm = ctx->height_mm;\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\nstatic int ld9040_parse_dt(struct ld9040 *ctx)\r\n{\r\nstruct device *dev = ctx->dev;\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\nret = of_get_videomode(np, &ctx->vm, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nof_property_read_u32(np, "power-on-delay", &ctx->power_on_delay);\r\nof_property_read_u32(np, "reset-delay", &ctx->reset_delay);\r\nof_property_read_u32(np, "panel-width-mm", &ctx->width_mm);\r\nof_property_read_u32(np, "panel-height-mm", &ctx->height_mm);\r\nreturn 0;\r\n}\r\nstatic int ld9040_probe(struct spi_device *spi)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct ld9040 *ctx;\r\nint ret;\r\nctx = devm_kzalloc(dev, sizeof(struct ld9040), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, ctx);\r\nctx->dev = dev;\r\nctx->brightness = ARRAY_SIZE(ld9040_gammas) - 1;\r\nret = ld9040_parse_dt(ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nctx->supplies[0].supply = "vdd3";\r\nctx->supplies[1].supply = "vci";\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),\r\nctx->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\nctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(ctx->reset_gpio)) {\r\ndev_err(dev, "cannot get reset-gpios %ld\n",\r\nPTR_ERR(ctx->reset_gpio));\r\nreturn PTR_ERR(ctx->reset_gpio);\r\n}\r\nspi->bits_per_word = 9;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\ndev_err(dev, "spi setup failed.\n");\r\nreturn ret;\r\n}\r\ndrm_panel_init(&ctx->panel);\r\nctx->panel.dev = dev;\r\nctx->panel.funcs = &ld9040_drm_funcs;\r\nreturn drm_panel_add(&ctx->panel);\r\n}\r\nstatic int ld9040_remove(struct spi_device *spi)\r\n{\r\nstruct ld9040 *ctx = spi_get_drvdata(spi);\r\nld9040_power_off(ctx);\r\ndrm_panel_remove(&ctx->panel);\r\nreturn 0;\r\n}
