static struct cpu_map *cpu_map__default_new(void)\r\n{\r\nstruct cpu_map *cpus;\r\nint nr_cpus;\r\nnr_cpus = sysconf(_SC_NPROCESSORS_ONLN);\r\nif (nr_cpus < 0)\r\nreturn NULL;\r\ncpus = malloc(sizeof(*cpus) + nr_cpus * sizeof(int));\r\nif (cpus != NULL) {\r\nint i;\r\nfor (i = 0; i < nr_cpus; ++i)\r\ncpus->map[i] = i;\r\ncpus->nr = nr_cpus;\r\natomic_set(&cpus->refcnt, 1);\r\n}\r\nreturn cpus;\r\n}\r\nstatic struct cpu_map *cpu_map__trim_new(int nr_cpus, int *tmp_cpus)\r\n{\r\nsize_t payload_size = nr_cpus * sizeof(int);\r\nstruct cpu_map *cpus = malloc(sizeof(*cpus) + payload_size);\r\nif (cpus != NULL) {\r\ncpus->nr = nr_cpus;\r\nmemcpy(cpus->map, tmp_cpus, payload_size);\r\natomic_set(&cpus->refcnt, 1);\r\n}\r\nreturn cpus;\r\n}\r\nstruct cpu_map *cpu_map__read(FILE *file)\r\n{\r\nstruct cpu_map *cpus = NULL;\r\nint nr_cpus = 0;\r\nint *tmp_cpus = NULL, *tmp;\r\nint max_entries = 0;\r\nint n, cpu, prev;\r\nchar sep;\r\nsep = 0;\r\nprev = -1;\r\nfor (;;) {\r\nn = fscanf(file, "%u%c", &cpu, &sep);\r\nif (n <= 0)\r\nbreak;\r\nif (prev >= 0) {\r\nint new_max = nr_cpus + cpu - prev - 1;\r\nif (new_max >= max_entries) {\r\nmax_entries = new_max + MAX_NR_CPUS / 2;\r\ntmp = realloc(tmp_cpus, max_entries * sizeof(int));\r\nif (tmp == NULL)\r\ngoto out_free_tmp;\r\ntmp_cpus = tmp;\r\n}\r\nwhile (++prev < cpu)\r\ntmp_cpus[nr_cpus++] = prev;\r\n}\r\nif (nr_cpus == max_entries) {\r\nmax_entries += MAX_NR_CPUS;\r\ntmp = realloc(tmp_cpus, max_entries * sizeof(int));\r\nif (tmp == NULL)\r\ngoto out_free_tmp;\r\ntmp_cpus = tmp;\r\n}\r\ntmp_cpus[nr_cpus++] = cpu;\r\nif (n == 2 && sep == '-')\r\nprev = cpu;\r\nelse\r\nprev = -1;\r\nif (n == 1 || sep == '\n')\r\nbreak;\r\n}\r\nif (nr_cpus > 0)\r\ncpus = cpu_map__trim_new(nr_cpus, tmp_cpus);\r\nelse\r\ncpus = cpu_map__default_new();\r\nout_free_tmp:\r\nfree(tmp_cpus);\r\nreturn cpus;\r\n}\r\nstatic struct cpu_map *cpu_map__read_all_cpu_map(void)\r\n{\r\nstruct cpu_map *cpus = NULL;\r\nFILE *onlnf;\r\nonlnf = fopen("/sys/devices/system/cpu/online", "r");\r\nif (!onlnf)\r\nreturn cpu_map__default_new();\r\ncpus = cpu_map__read(onlnf);\r\nfclose(onlnf);\r\nreturn cpus;\r\n}\r\nstruct cpu_map *cpu_map__new(const char *cpu_list)\r\n{\r\nstruct cpu_map *cpus = NULL;\r\nunsigned long start_cpu, end_cpu = 0;\r\nchar *p = NULL;\r\nint i, nr_cpus = 0;\r\nint *tmp_cpus = NULL, *tmp;\r\nint max_entries = 0;\r\nif (!cpu_list)\r\nreturn cpu_map__read_all_cpu_map();\r\nif (!isdigit(*cpu_list))\r\ngoto out;\r\nwhile (isdigit(*cpu_list)) {\r\np = NULL;\r\nstart_cpu = strtoul(cpu_list, &p, 0);\r\nif (start_cpu >= INT_MAX\r\n|| (*p != '\0' && *p != ',' && *p != '-'))\r\ngoto invalid;\r\nif (*p == '-') {\r\ncpu_list = ++p;\r\np = NULL;\r\nend_cpu = strtoul(cpu_list, &p, 0);\r\nif (end_cpu >= INT_MAX || (*p != '\0' && *p != ','))\r\ngoto invalid;\r\nif (end_cpu < start_cpu)\r\ngoto invalid;\r\n} else {\r\nend_cpu = start_cpu;\r\n}\r\nfor (; start_cpu <= end_cpu; start_cpu++) {\r\nfor (i = 0; i < nr_cpus; i++)\r\nif (tmp_cpus[i] == (int)start_cpu)\r\ngoto invalid;\r\nif (nr_cpus == max_entries) {\r\nmax_entries += MAX_NR_CPUS;\r\ntmp = realloc(tmp_cpus, max_entries * sizeof(int));\r\nif (tmp == NULL)\r\ngoto invalid;\r\ntmp_cpus = tmp;\r\n}\r\ntmp_cpus[nr_cpus++] = (int)start_cpu;\r\n}\r\nif (*p)\r\n++p;\r\ncpu_list = p;\r\n}\r\nif (nr_cpus > 0)\r\ncpus = cpu_map__trim_new(nr_cpus, tmp_cpus);\r\nelse\r\ncpus = cpu_map__default_new();\r\ninvalid:\r\nfree(tmp_cpus);\r\nout:\r\nreturn cpus;\r\n}\r\nstatic struct cpu_map *cpu_map__from_entries(struct cpu_map_entries *cpus)\r\n{\r\nstruct cpu_map *map;\r\nmap = cpu_map__empty_new(cpus->nr);\r\nif (map) {\r\nunsigned i;\r\nfor (i = 0; i < cpus->nr; i++) {\r\nif (cpus->cpu[i] == (u16) -1)\r\nmap->map[i] = -1;\r\nelse\r\nmap->map[i] = (int) cpus->cpu[i];\r\n}\r\n}\r\nreturn map;\r\n}\r\nstatic struct cpu_map *cpu_map__from_mask(struct cpu_map_mask *mask)\r\n{\r\nstruct cpu_map *map;\r\nint nr, nbits = mask->nr * mask->long_size * BITS_PER_BYTE;\r\nnr = bitmap_weight(mask->mask, nbits);\r\nmap = cpu_map__empty_new(nr);\r\nif (map) {\r\nint cpu, i = 0;\r\nfor_each_set_bit(cpu, mask->mask, nbits)\r\nmap->map[i++] = cpu;\r\n}\r\nreturn map;\r\n}\r\nstruct cpu_map *cpu_map__new_data(struct cpu_map_data *data)\r\n{\r\nif (data->type == PERF_CPU_MAP__CPUS)\r\nreturn cpu_map__from_entries((struct cpu_map_entries *)data->data);\r\nelse\r\nreturn cpu_map__from_mask((struct cpu_map_mask *)data->data);\r\n}\r\nsize_t cpu_map__fprintf(struct cpu_map *map, FILE *fp)\r\n{\r\n#define BUFSIZE 1024\r\nchar buf[BUFSIZE];\r\ncpu_map__snprint(map, buf, sizeof(buf));\r\nreturn fprintf(fp, "%s\n", buf);\r\n#undef BUFSIZE\r\n}\r\nstruct cpu_map *cpu_map__dummy_new(void)\r\n{\r\nstruct cpu_map *cpus = malloc(sizeof(*cpus) + sizeof(int));\r\nif (cpus != NULL) {\r\ncpus->nr = 1;\r\ncpus->map[0] = -1;\r\natomic_set(&cpus->refcnt, 1);\r\n}\r\nreturn cpus;\r\n}\r\nstruct cpu_map *cpu_map__empty_new(int nr)\r\n{\r\nstruct cpu_map *cpus = malloc(sizeof(*cpus) + sizeof(int) * nr);\r\nif (cpus != NULL) {\r\nint i;\r\ncpus->nr = nr;\r\nfor (i = 0; i < nr; i++)\r\ncpus->map[i] = -1;\r\natomic_set(&cpus->refcnt, 1);\r\n}\r\nreturn cpus;\r\n}\r\nstatic void cpu_map__delete(struct cpu_map *map)\r\n{\r\nif (map) {\r\nWARN_ONCE(atomic_read(&map->refcnt) != 0,\r\n"cpu_map refcnt unbalanced\n");\r\nfree(map);\r\n}\r\n}\r\nstruct cpu_map *cpu_map__get(struct cpu_map *map)\r\n{\r\nif (map)\r\natomic_inc(&map->refcnt);\r\nreturn map;\r\n}\r\nvoid cpu_map__put(struct cpu_map *map)\r\n{\r\nif (map && atomic_dec_and_test(&map->refcnt))\r\ncpu_map__delete(map);\r\n}\r\nstatic int cpu__get_topology_int(int cpu, const char *name, int *value)\r\n{\r\nchar path[PATH_MAX];\r\nsnprintf(path, PATH_MAX,\r\n"devices/system/cpu/cpu%d/topology/%s", cpu, name);\r\nreturn sysfs__read_int(path, value);\r\n}\r\nint cpu_map__get_socket_id(int cpu)\r\n{\r\nint value, ret = cpu__get_topology_int(cpu, "physical_package_id", &value);\r\nreturn ret ?: value;\r\n}\r\nint cpu_map__get_socket(struct cpu_map *map, int idx, void *data __maybe_unused)\r\n{\r\nint cpu;\r\nif (idx > map->nr)\r\nreturn -1;\r\ncpu = map->map[idx];\r\nreturn cpu_map__get_socket_id(cpu);\r\n}\r\nstatic int cmp_ids(const void *a, const void *b)\r\n{\r\nreturn *(int *)a - *(int *)b;\r\n}\r\nint cpu_map__build_map(struct cpu_map *cpus, struct cpu_map **res,\r\nint (*f)(struct cpu_map *map, int cpu, void *data),\r\nvoid *data)\r\n{\r\nstruct cpu_map *c;\r\nint nr = cpus->nr;\r\nint cpu, s1, s2;\r\nc = calloc(1, sizeof(*c) + nr * sizeof(int));\r\nif (!c)\r\nreturn -1;\r\nfor (cpu = 0; cpu < nr; cpu++) {\r\ns1 = f(cpus, cpu, data);\r\nfor (s2 = 0; s2 < c->nr; s2++) {\r\nif (s1 == c->map[s2])\r\nbreak;\r\n}\r\nif (s2 == c->nr) {\r\nc->map[c->nr] = s1;\r\nc->nr++;\r\n}\r\n}\r\nqsort(c->map, c->nr, sizeof(int), cmp_ids);\r\natomic_set(&c->refcnt, 1);\r\n*res = c;\r\nreturn 0;\r\n}\r\nint cpu_map__get_core_id(int cpu)\r\n{\r\nint value, ret = cpu__get_topology_int(cpu, "core_id", &value);\r\nreturn ret ?: value;\r\n}\r\nint cpu_map__get_core(struct cpu_map *map, int idx, void *data)\r\n{\r\nint cpu, s;\r\nif (idx > map->nr)\r\nreturn -1;\r\ncpu = map->map[idx];\r\ncpu = cpu_map__get_core_id(cpu);\r\ns = cpu_map__get_socket(map, idx, data);\r\nif (s == -1)\r\nreturn -1;\r\nreturn (s << 16) | (cpu & 0xffff);\r\n}\r\nint cpu_map__build_socket_map(struct cpu_map *cpus, struct cpu_map **sockp)\r\n{\r\nreturn cpu_map__build_map(cpus, sockp, cpu_map__get_socket, NULL);\r\n}\r\nint cpu_map__build_core_map(struct cpu_map *cpus, struct cpu_map **corep)\r\n{\r\nreturn cpu_map__build_map(cpus, corep, cpu_map__get_core, NULL);\r\n}\r\nstatic int get_max_num(char *path, int *max)\r\n{\r\nsize_t num;\r\nchar *buf;\r\nint err = 0;\r\nif (filename__read_str(path, &buf, &num))\r\nreturn -1;\r\nbuf[num] = '\0';\r\nwhile (--num) {\r\nif ((buf[num] == ',') || (buf[num] == '-')) {\r\nnum++;\r\nbreak;\r\n}\r\n}\r\nif (sscanf(&buf[num], "%d", max) < 1) {\r\nerr = -1;\r\ngoto out;\r\n}\r\n(*max)++;\r\nout:\r\nfree(buf);\r\nreturn err;\r\n}\r\nstatic void set_max_cpu_num(void)\r\n{\r\nconst char *mnt;\r\nchar path[PATH_MAX];\r\nint ret = -1;\r\nmax_cpu_num = 4096;\r\nmnt = sysfs__mountpoint();\r\nif (!mnt)\r\ngoto out;\r\nret = snprintf(path, PATH_MAX, "%s/devices/system/cpu/possible", mnt);\r\nif (ret == PATH_MAX) {\r\npr_err("sysfs path crossed PATH_MAX(%d) size\n", PATH_MAX);\r\ngoto out;\r\n}\r\nret = get_max_num(path, &max_cpu_num);\r\nout:\r\nif (ret)\r\npr_err("Failed to read max cpus, using default of %d\n", max_cpu_num);\r\n}\r\nstatic void set_max_node_num(void)\r\n{\r\nconst char *mnt;\r\nchar path[PATH_MAX];\r\nint ret = -1;\r\nmax_node_num = 8;\r\nmnt = sysfs__mountpoint();\r\nif (!mnt)\r\ngoto out;\r\nret = snprintf(path, PATH_MAX, "%s/devices/system/node/possible", mnt);\r\nif (ret == PATH_MAX) {\r\npr_err("sysfs path crossed PATH_MAX(%d) size\n", PATH_MAX);\r\ngoto out;\r\n}\r\nret = get_max_num(path, &max_node_num);\r\nout:\r\nif (ret)\r\npr_err("Failed to read max nodes, using default of %d\n", max_node_num);\r\n}\r\nint cpu__max_node(void)\r\n{\r\nif (unlikely(!max_node_num))\r\nset_max_node_num();\r\nreturn max_node_num;\r\n}\r\nint cpu__max_cpu(void)\r\n{\r\nif (unlikely(!max_cpu_num))\r\nset_max_cpu_num();\r\nreturn max_cpu_num;\r\n}\r\nint cpu__get_node(int cpu)\r\n{\r\nif (unlikely(cpunode_map == NULL)) {\r\npr_debug("cpu_map not initialized\n");\r\nreturn -1;\r\n}\r\nreturn cpunode_map[cpu];\r\n}\r\nstatic int init_cpunode_map(void)\r\n{\r\nint i;\r\nset_max_cpu_num();\r\nset_max_node_num();\r\ncpunode_map = calloc(max_cpu_num, sizeof(int));\r\nif (!cpunode_map) {\r\npr_err("%s: calloc failed\n", __func__);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < max_cpu_num; i++)\r\ncpunode_map[i] = -1;\r\nreturn 0;\r\n}\r\nint cpu__setup_cpunode_map(void)\r\n{\r\nstruct dirent *dent1, *dent2;\r\nDIR *dir1, *dir2;\r\nunsigned int cpu, mem;\r\nchar buf[PATH_MAX];\r\nchar path[PATH_MAX];\r\nconst char *mnt;\r\nint n;\r\nif (init_cpunode_map())\r\nreturn -1;\r\nmnt = sysfs__mountpoint();\r\nif (!mnt)\r\nreturn 0;\r\nn = snprintf(path, PATH_MAX, "%s/devices/system/node", mnt);\r\nif (n == PATH_MAX) {\r\npr_err("sysfs path crossed PATH_MAX(%d) size\n", PATH_MAX);\r\nreturn -1;\r\n}\r\ndir1 = opendir(path);\r\nif (!dir1)\r\nreturn 0;\r\nwhile ((dent1 = readdir(dir1)) != NULL) {\r\nif (dent1->d_type != DT_DIR || sscanf(dent1->d_name, "node%u", &mem) < 1)\r\ncontinue;\r\nn = snprintf(buf, PATH_MAX, "%s/%s", path, dent1->d_name);\r\nif (n == PATH_MAX) {\r\npr_err("sysfs path crossed PATH_MAX(%d) size\n", PATH_MAX);\r\ncontinue;\r\n}\r\ndir2 = opendir(buf);\r\nif (!dir2)\r\ncontinue;\r\nwhile ((dent2 = readdir(dir2)) != NULL) {\r\nif (dent2->d_type != DT_LNK || sscanf(dent2->d_name, "cpu%u", &cpu) < 1)\r\ncontinue;\r\ncpunode_map[cpu] = mem;\r\n}\r\nclosedir(dir2);\r\n}\r\nclosedir(dir1);\r\nreturn 0;\r\n}\r\nbool cpu_map__has(struct cpu_map *cpus, int cpu)\r\n{\r\nreturn cpu_map__idx(cpus, cpu) != -1;\r\n}\r\nint cpu_map__idx(struct cpu_map *cpus, int cpu)\r\n{\r\nint i;\r\nfor (i = 0; i < cpus->nr; ++i) {\r\nif (cpus->map[i] == cpu)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nint cpu_map__cpu(struct cpu_map *cpus, int idx)\r\n{\r\nreturn cpus->map[idx];\r\n}\r\nsize_t cpu_map__snprint(struct cpu_map *map, char *buf, size_t size)\r\n{\r\nint i, cpu, start = -1;\r\nbool first = true;\r\nsize_t ret = 0;\r\n#define COMMA first ? "" : ","\r\nfor (i = 0; i < map->nr + 1; i++) {\r\nbool last = i == map->nr;\r\ncpu = last ? INT_MAX : map->map[i];\r\nif (start == -1) {\r\nstart = i;\r\nif (last) {\r\nret += snprintf(buf + ret, size - ret,\r\n"%s%d", COMMA,\r\nmap->map[i]);\r\n}\r\n} else if (((i - start) != (cpu - map->map[start])) || last) {\r\nint end = i - 1;\r\nif (start == end) {\r\nret += snprintf(buf + ret, size - ret,\r\n"%s%d", COMMA,\r\nmap->map[start]);\r\n} else {\r\nret += snprintf(buf + ret, size - ret,\r\n"%s%d-%d", COMMA,\r\nmap->map[start], map->map[end]);\r\n}\r\nfirst = false;\r\nstart = i;\r\n}\r\n}\r\n#undef COMMA\r\npr_debug("cpumask list: %s\n", buf);\r\nreturn ret;\r\n}
