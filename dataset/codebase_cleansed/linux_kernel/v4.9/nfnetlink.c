void nfnl_lock(__u8 subsys_id)\r\n{\r\nmutex_lock(&table[subsys_id].mutex);\r\n}\r\nvoid nfnl_unlock(__u8 subsys_id)\r\n{\r\nmutex_unlock(&table[subsys_id].mutex);\r\n}\r\nbool lockdep_nfnl_is_held(u8 subsys_id)\r\n{\r\nreturn lockdep_is_held(&table[subsys_id].mutex);\r\n}\r\nint nfnetlink_subsys_register(const struct nfnetlink_subsystem *n)\r\n{\r\nnfnl_lock(n->subsys_id);\r\nif (table[n->subsys_id].subsys) {\r\nnfnl_unlock(n->subsys_id);\r\nreturn -EBUSY;\r\n}\r\nrcu_assign_pointer(table[n->subsys_id].subsys, n);\r\nnfnl_unlock(n->subsys_id);\r\nreturn 0;\r\n}\r\nint nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n)\r\n{\r\nnfnl_lock(n->subsys_id);\r\ntable[n->subsys_id].subsys = NULL;\r\nnfnl_unlock(n->subsys_id);\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nstatic inline const struct nfnetlink_subsystem *nfnetlink_get_subsys(u_int16_t type)\r\n{\r\nu_int8_t subsys_id = NFNL_SUBSYS_ID(type);\r\nif (subsys_id >= NFNL_SUBSYS_COUNT)\r\nreturn NULL;\r\nreturn rcu_dereference(table[subsys_id].subsys);\r\n}\r\nstatic inline const struct nfnl_callback *\r\nnfnetlink_find_client(u_int16_t type, const struct nfnetlink_subsystem *ss)\r\n{\r\nu_int8_t cb_id = NFNL_MSG_TYPE(type);\r\nif (cb_id >= ss->cb_count)\r\nreturn NULL;\r\nreturn &ss->cb[cb_id];\r\n}\r\nint nfnetlink_has_listeners(struct net *net, unsigned int group)\r\n{\r\nreturn netlink_has_listeners(net->nfnl, group);\r\n}\r\nint nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,\r\nunsigned int group, int echo, gfp_t flags)\r\n{\r\nreturn nlmsg_notify(net->nfnl, skb, portid, group, echo, flags);\r\n}\r\nint nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error)\r\n{\r\nreturn netlink_set_err(net->nfnl, portid, group, error);\r\n}\r\nint nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid,\r\nint flags)\r\n{\r\nreturn netlink_unicast(net->nfnl, skb, portid, flags);\r\n}\r\nstatic int nfnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nconst struct nfnl_callback *nc;\r\nconst struct nfnetlink_subsystem *ss;\r\nint type, err;\r\nif (nlmsg_len(nlh) < sizeof(struct nfgenmsg))\r\nreturn 0;\r\ntype = nlh->nlmsg_type;\r\nreplay:\r\nrcu_read_lock();\r\nss = nfnetlink_get_subsys(type);\r\nif (!ss) {\r\n#ifdef CONFIG_MODULES\r\nrcu_read_unlock();\r\nrequest_module("nfnetlink-subsys-%d", NFNL_SUBSYS_ID(type));\r\nrcu_read_lock();\r\nss = nfnetlink_get_subsys(type);\r\nif (!ss)\r\n#endif\r\n{\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\n}\r\nnc = nfnetlink_find_client(type, ss);\r\nif (!nc) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\n{\r\nint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\r\nu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\r\nstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\r\nstruct nlattr *attr = (void *)nlh + min_len;\r\nint attrlen = nlh->nlmsg_len - min_len;\r\n__u8 subsys_id = NFNL_SUBSYS_ID(type);\r\nerr = nla_parse(cda, ss->cb[cb_id].attr_count,\r\nattr, attrlen, ss->cb[cb_id].policy);\r\nif (err < 0) {\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nif (nc->call_rcu) {\r\nerr = nc->call_rcu(net, net->nfnl, skb, nlh,\r\n(const struct nlattr **)cda);\r\nrcu_read_unlock();\r\n} else {\r\nrcu_read_unlock();\r\nnfnl_lock(subsys_id);\r\nif (nfnl_dereference_protected(subsys_id) != ss ||\r\nnfnetlink_find_client(type, ss) != nc)\r\nerr = -EAGAIN;\r\nelse if (nc->call)\r\nerr = nc->call(net, net->nfnl, skb, nlh,\r\n(const struct nlattr **)cda);\r\nelse\r\nerr = -EINVAL;\r\nnfnl_unlock(subsys_id);\r\n}\r\nif (err == -EAGAIN)\r\ngoto replay;\r\nreturn err;\r\n}\r\n}\r\nstatic int nfnl_err_add(struct list_head *list, struct nlmsghdr *nlh, int err)\r\n{\r\nstruct nfnl_err *nfnl_err;\r\nnfnl_err = kmalloc(sizeof(struct nfnl_err), GFP_KERNEL);\r\nif (nfnl_err == NULL)\r\nreturn -ENOMEM;\r\nnfnl_err->nlh = nlh;\r\nnfnl_err->err = err;\r\nlist_add_tail(&nfnl_err->head, list);\r\nreturn 0;\r\n}\r\nstatic void nfnl_err_del(struct nfnl_err *nfnl_err)\r\n{\r\nlist_del(&nfnl_err->head);\r\nkfree(nfnl_err);\r\n}\r\nstatic void nfnl_err_reset(struct list_head *err_list)\r\n{\r\nstruct nfnl_err *nfnl_err, *next;\r\nlist_for_each_entry_safe(nfnl_err, next, err_list, head)\r\nnfnl_err_del(nfnl_err);\r\n}\r\nstatic void nfnl_err_deliver(struct list_head *err_list, struct sk_buff *skb)\r\n{\r\nstruct nfnl_err *nfnl_err, *next;\r\nlist_for_each_entry_safe(nfnl_err, next, err_list, head) {\r\nnetlink_ack(skb, nfnl_err->nlh, nfnl_err->err);\r\nnfnl_err_del(nfnl_err);\r\n}\r\n}\r\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nu_int16_t subsys_id)\r\n{\r\nstruct sk_buff *oskb = skb;\r\nstruct net *net = sock_net(skb->sk);\r\nconst struct nfnetlink_subsystem *ss;\r\nconst struct nfnl_callback *nc;\r\nstatic LIST_HEAD(err_list);\r\nu32 status;\r\nint err;\r\nif (subsys_id >= NFNL_SUBSYS_COUNT)\r\nreturn netlink_ack(skb, nlh, -EINVAL);\r\nreplay:\r\nstatus = 0;\r\nskb = netlink_skb_clone(oskb, GFP_KERNEL);\r\nif (!skb)\r\nreturn netlink_ack(oskb, nlh, -ENOMEM);\r\nnfnl_lock(subsys_id);\r\nss = nfnl_dereference_protected(subsys_id);\r\nif (!ss) {\r\n#ifdef CONFIG_MODULES\r\nnfnl_unlock(subsys_id);\r\nrequest_module("nfnetlink-subsys-%d", subsys_id);\r\nnfnl_lock(subsys_id);\r\nss = nfnl_dereference_protected(subsys_id);\r\nif (!ss)\r\n#endif\r\n{\r\nnfnl_unlock(subsys_id);\r\nnetlink_ack(oskb, nlh, -EOPNOTSUPP);\r\nreturn kfree_skb(skb);\r\n}\r\n}\r\nif (!ss->commit || !ss->abort) {\r\nnfnl_unlock(subsys_id);\r\nnetlink_ack(oskb, nlh, -EOPNOTSUPP);\r\nreturn kfree_skb(skb);\r\n}\r\nwhile (skb->len >= nlmsg_total_size(0)) {\r\nint msglen, type;\r\nnlh = nlmsg_hdr(skb);\r\nerr = 0;\r\nif (nlh->nlmsg_len < NLMSG_HDRLEN ||\r\nskb->len < nlh->nlmsg_len ||\r\nnlmsg_len(nlh) < sizeof(struct nfgenmsg)) {\r\nnfnl_err_reset(&err_list);\r\nstatus |= NFNL_BATCH_FAILURE;\r\ngoto done;\r\n}\r\nif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\r\nerr = -EINVAL;\r\ngoto ack;\r\n}\r\ntype = nlh->nlmsg_type;\r\nif (type == NFNL_MSG_BATCH_BEGIN) {\r\nnfnl_err_reset(&err_list);\r\nstatus |= NFNL_BATCH_FAILURE;\r\ngoto done;\r\n} else if (type == NFNL_MSG_BATCH_END) {\r\nstatus |= NFNL_BATCH_DONE;\r\ngoto done;\r\n} else if (type < NLMSG_MIN_TYPE) {\r\nerr = -EINVAL;\r\ngoto ack;\r\n}\r\nif (NFNL_SUBSYS_ID(type) != subsys_id) {\r\nerr = -EINVAL;\r\ngoto ack;\r\n}\r\nnc = nfnetlink_find_client(type, ss);\r\nif (!nc) {\r\nerr = -EINVAL;\r\ngoto ack;\r\n}\r\n{\r\nint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\r\nu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\r\nstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\r\nstruct nlattr *attr = (void *)nlh + min_len;\r\nint attrlen = nlh->nlmsg_len - min_len;\r\nerr = nla_parse(cda, ss->cb[cb_id].attr_count,\r\nattr, attrlen, ss->cb[cb_id].policy);\r\nif (err < 0)\r\ngoto ack;\r\nif (nc->call_batch) {\r\nerr = nc->call_batch(net, net->nfnl, skb, nlh,\r\n(const struct nlattr **)cda);\r\n}\r\nif (err == -EAGAIN) {\r\nstatus |= NFNL_BATCH_REPLAY;\r\ngoto next;\r\n}\r\n}\r\nack:\r\nif (nlh->nlmsg_flags & NLM_F_ACK || err) {\r\nif (nfnl_err_add(&err_list, nlh, err) < 0) {\r\nnfnl_err_reset(&err_list);\r\nnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\r\nstatus |= NFNL_BATCH_FAILURE;\r\ngoto done;\r\n}\r\nif (err)\r\nstatus |= NFNL_BATCH_FAILURE;\r\n}\r\nnext:\r\nmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\r\nif (msglen > skb->len)\r\nmsglen = skb->len;\r\nskb_pull(skb, msglen);\r\n}\r\ndone:\r\nif (status & NFNL_BATCH_REPLAY) {\r\nss->abort(net, oskb);\r\nnfnl_err_reset(&err_list);\r\nnfnl_unlock(subsys_id);\r\nkfree_skb(skb);\r\ngoto replay;\r\n} else if (status == NFNL_BATCH_DONE) {\r\nss->commit(net, oskb);\r\n} else {\r\nss->abort(net, oskb);\r\n}\r\nnfnl_err_deliver(&err_list, oskb);\r\nnfnl_unlock(subsys_id);\r\nkfree_skb(skb);\r\n}\r\nstatic void nfnetlink_rcv(struct sk_buff *skb)\r\n{\r\nstruct nlmsghdr *nlh = nlmsg_hdr(skb);\r\nu_int16_t res_id;\r\nint msglen;\r\nif (nlh->nlmsg_len < NLMSG_HDRLEN ||\r\nskb->len < nlh->nlmsg_len)\r\nreturn;\r\nif (!netlink_net_capable(skb, CAP_NET_ADMIN)) {\r\nnetlink_ack(skb, nlh, -EPERM);\r\nreturn;\r\n}\r\nif (nlh->nlmsg_type == NFNL_MSG_BATCH_BEGIN) {\r\nstruct nfgenmsg *nfgenmsg;\r\nmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\r\nif (msglen > skb->len)\r\nmsglen = skb->len;\r\nif (nlh->nlmsg_len < NLMSG_HDRLEN ||\r\nskb->len < NLMSG_HDRLEN + sizeof(struct nfgenmsg))\r\nreturn;\r\nnfgenmsg = nlmsg_data(nlh);\r\nskb_pull(skb, msglen);\r\nif (nfgenmsg->res_id == NFNL_SUBSYS_NFTABLES)\r\nres_id = NFNL_SUBSYS_NFTABLES;\r\nelse\r\nres_id = ntohs(nfgenmsg->res_id);\r\nnfnetlink_rcv_batch(skb, nlh, res_id);\r\n} else {\r\nnetlink_rcv_skb(skb, &nfnetlink_rcv_msg);\r\n}\r\n}\r\nstatic int nfnetlink_bind(struct net *net, int group)\r\n{\r\nconst struct nfnetlink_subsystem *ss;\r\nint type;\r\nif (group <= NFNLGRP_NONE || group > NFNLGRP_MAX)\r\nreturn 0;\r\ntype = nfnl_group2type[group];\r\nrcu_read_lock();\r\nss = nfnetlink_get_subsys(type << 8);\r\nrcu_read_unlock();\r\nif (!ss)\r\nrequest_module("nfnetlink-subsys-%d", type);\r\nreturn 0;\r\n}\r\nstatic int __net_init nfnetlink_net_init(struct net *net)\r\n{\r\nstruct sock *nfnl;\r\nstruct netlink_kernel_cfg cfg = {\r\n.groups = NFNLGRP_MAX,\r\n.input = nfnetlink_rcv,\r\n#ifdef CONFIG_MODULES\r\n.bind = nfnetlink_bind,\r\n#endif\r\n};\r\nnfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);\r\nif (!nfnl)\r\nreturn -ENOMEM;\r\nnet->nfnl_stash = nfnl;\r\nrcu_assign_pointer(net->nfnl, nfnl);\r\nreturn 0;\r\n}\r\nstatic void __net_exit nfnetlink_net_exit_batch(struct list_head *net_exit_list)\r\n{\r\nstruct net *net;\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nRCU_INIT_POINTER(net->nfnl, NULL);\r\nsynchronize_net();\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nnetlink_kernel_release(net->nfnl_stash);\r\n}\r\nstatic int __init nfnetlink_init(void)\r\n{\r\nint i;\r\nfor (i = NFNLGRP_NONE + 1; i <= NFNLGRP_MAX; i++)\r\nBUG_ON(nfnl_group2type[i] == NFNL_SUBSYS_NONE);\r\nfor (i=0; i<NFNL_SUBSYS_COUNT; i++)\r\nmutex_init(&table[i].mutex);\r\npr_info("Netfilter messages via NETLINK v%s.\n", nfversion);\r\nreturn register_pernet_subsys(&nfnetlink_net_ops);\r\n}\r\nstatic void __exit nfnetlink_exit(void)\r\n{\r\npr_info("Removing netfilter NETLINK layer.\n");\r\nunregister_pernet_subsys(&nfnetlink_net_ops);\r\n}
