static inline void zpci_err_clp(unsigned int rsp, int rc)\r\n{\r\nstruct {\r\nunsigned int rsp;\r\nint rc;\r\n} __packed data = {rsp, rc};\r\nzpci_err_hex(&data, sizeof(data));\r\n}\r\nstatic inline int clp_get_ilp(unsigned long *ilp)\r\n{\r\nunsigned long mask;\r\nint cc = 3;\r\nasm volatile (\r\n" .insn rrf,0xb9a00000,%[mask],%[cmd],8,0\n"\r\n"0: ipm %[cc]\n"\r\n" srl %[cc],28\n"\r\n"1:\n"\r\nEX_TABLE(0b, 1b)\r\n: [cc] "+d" (cc), [mask] "=d" (mask) : [cmd] "a" (1)\r\n: "cc");\r\n*ilp = mask;\r\nreturn cc;\r\n}\r\nstatic inline int clp_req(void *data, unsigned int lps)\r\n{\r\nstruct { u8 _[CLP_BLK_SIZE]; } *req = data;\r\nu64 ignored;\r\nint cc = 3;\r\nasm volatile (\r\n" .insn rrf,0xb9a00000,%[ign],%[req],0,%[lps]\n"\r\n"0: ipm %[cc]\n"\r\n" srl %[cc],28\n"\r\n"1:\n"\r\nEX_TABLE(0b, 1b)\r\n: [cc] "+d" (cc), [ign] "=d" (ignored), "+m" (*req)\r\n: [req] "a" (req), [lps] "i" (lps)\r\n: "cc");\r\nreturn cc;\r\n}\r\nstatic void *clp_alloc_block(gfp_t gfp_mask)\r\n{\r\nreturn (void *) __get_free_pages(gfp_mask, get_order(CLP_BLK_SIZE));\r\n}\r\nstatic void clp_free_block(void *ptr)\r\n{\r\nfree_pages((unsigned long) ptr, get_order(CLP_BLK_SIZE));\r\n}\r\nstatic void clp_store_query_pci_fngrp(struct zpci_dev *zdev,\r\nstruct clp_rsp_query_pci_grp *response)\r\n{\r\nzdev->tlb_refresh = response->refresh;\r\nzdev->dma_mask = response->dasm;\r\nzdev->msi_addr = response->msia;\r\nzdev->max_msi = response->noi;\r\nzdev->fmb_update = response->mui;\r\nswitch (response->version) {\r\ncase 1:\r\nzdev->max_bus_speed = PCIE_SPEED_5_0GT;\r\nbreak;\r\ndefault:\r\nzdev->max_bus_speed = PCI_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic int clp_query_pci_fngrp(struct zpci_dev *zdev, u8 pfgid)\r\n{\r\nstruct clp_req_rsp_query_pci_grp *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nmemset(rrb, 0, sizeof(*rrb));\r\nrrb->request.hdr.len = sizeof(rrb->request);\r\nrrb->request.hdr.cmd = CLP_QUERY_PCI_FNGRP;\r\nrrb->response.hdr.len = sizeof(rrb->response);\r\nrrb->request.pfgid = pfgid;\r\nrc = clp_req(rrb, CLP_LPS_PCI);\r\nif (!rc && rrb->response.hdr.rsp == CLP_RC_OK)\r\nclp_store_query_pci_fngrp(zdev, &rrb->response);\r\nelse {\r\nzpci_err("Q PCI FGRP:\n");\r\nzpci_err_clp(rrb->response.hdr.rsp, rc);\r\nrc = -EIO;\r\n}\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nstatic int clp_store_query_pci_fn(struct zpci_dev *zdev,\r\nstruct clp_rsp_query_pci *response)\r\n{\r\nint i;\r\nfor (i = 0; i < PCI_BAR_COUNT; i++) {\r\nzdev->bars[i].val = le32_to_cpu(response->bar[i]);\r\nzdev->bars[i].size = response->bar_size[i];\r\n}\r\nzdev->start_dma = response->sdma;\r\nzdev->end_dma = response->edma;\r\nzdev->pchid = response->pchid;\r\nzdev->pfgid = response->pfgid;\r\nzdev->pft = response->pft;\r\nzdev->vfn = response->vfn;\r\nzdev->uid = response->uid;\r\nmemcpy(zdev->pfip, response->pfip, sizeof(zdev->pfip));\r\nif (response->util_str_avail) {\r\nmemcpy(zdev->util_str, response->util_str,\r\nsizeof(zdev->util_str));\r\n}\r\nreturn 0;\r\n}\r\nstatic int clp_query_pci_fn(struct zpci_dev *zdev, u32 fh)\r\n{\r\nstruct clp_req_rsp_query_pci *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nmemset(rrb, 0, sizeof(*rrb));\r\nrrb->request.hdr.len = sizeof(rrb->request);\r\nrrb->request.hdr.cmd = CLP_QUERY_PCI_FN;\r\nrrb->response.hdr.len = sizeof(rrb->response);\r\nrrb->request.fh = fh;\r\nrc = clp_req(rrb, CLP_LPS_PCI);\r\nif (!rc && rrb->response.hdr.rsp == CLP_RC_OK) {\r\nrc = clp_store_query_pci_fn(zdev, &rrb->response);\r\nif (rc)\r\ngoto out;\r\nrc = clp_query_pci_fngrp(zdev, rrb->response.pfgid);\r\n} else {\r\nzpci_err("Q PCI FN:\n");\r\nzpci_err_clp(rrb->response.hdr.rsp, rc);\r\nrc = -EIO;\r\n}\r\nout:\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nint clp_add_pci_device(u32 fid, u32 fh, int configured)\r\n{\r\nstruct zpci_dev *zdev;\r\nint rc;\r\nzpci_dbg(3, "add fid:%x, fh:%x, c:%d\n", fid, fh, configured);\r\nzdev = kzalloc(sizeof(*zdev), GFP_KERNEL);\r\nif (!zdev)\r\nreturn -ENOMEM;\r\nzdev->fh = fh;\r\nzdev->fid = fid;\r\nrc = clp_query_pci_fn(zdev, fh);\r\nif (rc)\r\ngoto error;\r\nif (configured)\r\nzdev->state = ZPCI_FN_STATE_CONFIGURED;\r\nelse\r\nzdev->state = ZPCI_FN_STATE_STANDBY;\r\nrc = zpci_create_device(zdev);\r\nif (rc)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nkfree(zdev);\r\nreturn rc;\r\n}\r\nstatic int clp_set_pci_fn(u32 *fh, u8 nr_dma_as, u8 command)\r\n{\r\nstruct clp_req_rsp_set_pci *rrb;\r\nint rc, retries = 100;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\ndo {\r\nmemset(rrb, 0, sizeof(*rrb));\r\nrrb->request.hdr.len = sizeof(rrb->request);\r\nrrb->request.hdr.cmd = CLP_SET_PCI_FN;\r\nrrb->response.hdr.len = sizeof(rrb->response);\r\nrrb->request.fh = *fh;\r\nrrb->request.oc = command;\r\nrrb->request.ndas = nr_dma_as;\r\nrc = clp_req(rrb, CLP_LPS_PCI);\r\nif (rrb->response.hdr.rsp == CLP_RC_SETPCIFN_BUSY) {\r\nretries--;\r\nif (retries < 0)\r\nbreak;\r\nmsleep(20);\r\n}\r\n} while (rrb->response.hdr.rsp == CLP_RC_SETPCIFN_BUSY);\r\nif (!rc && rrb->response.hdr.rsp == CLP_RC_OK)\r\n*fh = rrb->response.fh;\r\nelse {\r\nzpci_err("Set PCI FN:\n");\r\nzpci_err_clp(rrb->response.hdr.rsp, rc);\r\nrc = -EIO;\r\n}\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nint clp_enable_fh(struct zpci_dev *zdev, u8 nr_dma_as)\r\n{\r\nu32 fh = zdev->fh;\r\nint rc;\r\nrc = clp_set_pci_fn(&fh, nr_dma_as, CLP_SET_ENABLE_PCI_FN);\r\nif (!rc)\r\nzdev->fh = fh;\r\nzpci_dbg(3, "ena fid:%x, fh:%x, rc:%d\n", zdev->fid, zdev->fh, rc);\r\nreturn rc;\r\n}\r\nint clp_disable_fh(struct zpci_dev *zdev)\r\n{\r\nu32 fh = zdev->fh;\r\nint rc;\r\nif (!zdev_enabled(zdev))\r\nreturn 0;\r\nrc = clp_set_pci_fn(&fh, 0, CLP_SET_DISABLE_PCI_FN);\r\nif (!rc)\r\nzdev->fh = fh;\r\nzpci_dbg(3, "dis fid:%x, fh:%x, rc:%d\n", zdev->fid, zdev->fh, rc);\r\nreturn rc;\r\n}\r\nstatic int clp_list_pci(struct clp_req_rsp_list_pci *rrb,\r\nvoid (*cb)(struct clp_fh_list_entry *entry))\r\n{\r\nu64 resume_token = 0;\r\nint entries, i, rc;\r\ndo {\r\nmemset(rrb, 0, sizeof(*rrb));\r\nrrb->request.hdr.len = sizeof(rrb->request);\r\nrrb->request.hdr.cmd = CLP_LIST_PCI;\r\nrrb->response.hdr.len = CLP_BLK_SIZE - LIST_PCI_HDR_LEN;\r\nrrb->request.resume_token = resume_token;\r\nrc = clp_req(rrb, CLP_LPS_PCI);\r\nif (rc || rrb->response.hdr.rsp != CLP_RC_OK) {\r\nzpci_err("List PCI FN:\n");\r\nzpci_err_clp(rrb->response.hdr.rsp, rc);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nWARN_ON_ONCE(rrb->response.entry_size !=\r\nsizeof(struct clp_fh_list_entry));\r\nentries = (rrb->response.hdr.len - LIST_PCI_HDR_LEN) /\r\nrrb->response.entry_size;\r\nresume_token = rrb->response.resume_token;\r\nfor (i = 0; i < entries; i++)\r\ncb(&rrb->response.fh_list[i]);\r\n} while (resume_token);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __clp_add(struct clp_fh_list_entry *entry)\r\n{\r\nif (!entry->vendor_id)\r\nreturn;\r\nclp_add_pci_device(entry->fid, entry->fh, entry->config_state);\r\n}\r\nstatic void __clp_rescan(struct clp_fh_list_entry *entry)\r\n{\r\nstruct zpci_dev *zdev;\r\nif (!entry->vendor_id)\r\nreturn;\r\nzdev = get_zdev_by_fid(entry->fid);\r\nif (!zdev) {\r\nclp_add_pci_device(entry->fid, entry->fh, entry->config_state);\r\nreturn;\r\n}\r\nif (!entry->config_state) {\r\nzpci_stop_device(zdev);\r\n}\r\n}\r\nstatic void __clp_update(struct clp_fh_list_entry *entry)\r\n{\r\nstruct zpci_dev *zdev;\r\nif (!entry->vendor_id)\r\nreturn;\r\nzdev = get_zdev_by_fid(entry->fid);\r\nif (!zdev)\r\nreturn;\r\nzdev->fh = entry->fh;\r\n}\r\nint clp_scan_pci_devices(void)\r\n{\r\nstruct clp_req_rsp_list_pci *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nrc = clp_list_pci(rrb, __clp_add);\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nint clp_rescan_pci_devices(void)\r\n{\r\nstruct clp_req_rsp_list_pci *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nrc = clp_list_pci(rrb, __clp_rescan);\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nint clp_rescan_pci_devices_simple(void)\r\n{\r\nstruct clp_req_rsp_list_pci *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_NOWAIT);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nrc = clp_list_pci(rrb, __clp_update);\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nstatic int clp_base_slpc(struct clp_req *req, struct clp_req_rsp_slpc *lpcb)\r\n{\r\nunsigned long limit = PAGE_SIZE - sizeof(lpcb->request);\r\nif (lpcb->request.hdr.len != sizeof(lpcb->request) ||\r\nlpcb->response.hdr.len > limit)\r\nreturn -EINVAL;\r\nreturn clp_req(lpcb, CLP_LPS_BASE) ? -EOPNOTSUPP : 0;\r\n}\r\nstatic int clp_base_command(struct clp_req *req, struct clp_req_hdr *lpcb)\r\n{\r\nswitch (lpcb->cmd) {\r\ncase 0x0001:\r\nreturn clp_base_slpc(req, (void *) lpcb);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int clp_pci_slpc(struct clp_req *req, struct clp_req_rsp_slpc *lpcb)\r\n{\r\nunsigned long limit = PAGE_SIZE - sizeof(lpcb->request);\r\nif (lpcb->request.hdr.len != sizeof(lpcb->request) ||\r\nlpcb->response.hdr.len > limit)\r\nreturn -EINVAL;\r\nreturn clp_req(lpcb, CLP_LPS_PCI) ? -EOPNOTSUPP : 0;\r\n}\r\nstatic int clp_pci_list(struct clp_req *req, struct clp_req_rsp_list_pci *lpcb)\r\n{\r\nunsigned long limit = PAGE_SIZE - sizeof(lpcb->request);\r\nif (lpcb->request.hdr.len != sizeof(lpcb->request) ||\r\nlpcb->response.hdr.len > limit)\r\nreturn -EINVAL;\r\nif (lpcb->request.reserved2 != 0)\r\nreturn -EINVAL;\r\nreturn clp_req(lpcb, CLP_LPS_PCI) ? -EOPNOTSUPP : 0;\r\n}\r\nstatic int clp_pci_query(struct clp_req *req,\r\nstruct clp_req_rsp_query_pci *lpcb)\r\n{\r\nunsigned long limit = PAGE_SIZE - sizeof(lpcb->request);\r\nif (lpcb->request.hdr.len != sizeof(lpcb->request) ||\r\nlpcb->response.hdr.len > limit)\r\nreturn -EINVAL;\r\nif (lpcb->request.reserved2 != 0 || lpcb->request.reserved3 != 0)\r\nreturn -EINVAL;\r\nreturn clp_req(lpcb, CLP_LPS_PCI) ? -EOPNOTSUPP : 0;\r\n}\r\nstatic int clp_pci_query_grp(struct clp_req *req,\r\nstruct clp_req_rsp_query_pci_grp *lpcb)\r\n{\r\nunsigned long limit = PAGE_SIZE - sizeof(lpcb->request);\r\nif (lpcb->request.hdr.len != sizeof(lpcb->request) ||\r\nlpcb->response.hdr.len > limit)\r\nreturn -EINVAL;\r\nif (lpcb->request.reserved2 != 0 || lpcb->request.reserved3 != 0 ||\r\nlpcb->request.reserved4 != 0)\r\nreturn -EINVAL;\r\nreturn clp_req(lpcb, CLP_LPS_PCI) ? -EOPNOTSUPP : 0;\r\n}\r\nstatic int clp_pci_command(struct clp_req *req, struct clp_req_hdr *lpcb)\r\n{\r\nswitch (lpcb->cmd) {\r\ncase 0x0001:\r\nreturn clp_pci_slpc(req, (void *) lpcb);\r\ncase 0x0002:\r\nreturn clp_pci_list(req, (void *) lpcb);\r\ncase 0x0003:\r\nreturn clp_pci_query(req, (void *) lpcb);\r\ncase 0x0004:\r\nreturn clp_pci_query_grp(req, (void *) lpcb);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int clp_normal_command(struct clp_req *req)\r\n{\r\nstruct clp_req_hdr *lpcb;\r\nvoid __user *uptr;\r\nint rc;\r\nrc = -EINVAL;\r\nif (req->lps != 0 && req->lps != 2)\r\ngoto out;\r\nrc = -ENOMEM;\r\nlpcb = clp_alloc_block(GFP_KERNEL);\r\nif (!lpcb)\r\ngoto out;\r\nrc = -EFAULT;\r\nuptr = (void __force __user *)(unsigned long) req->data_p;\r\nif (copy_from_user(lpcb, uptr, PAGE_SIZE) != 0)\r\ngoto out_free;\r\nrc = -EINVAL;\r\nif (lpcb->fmt != 0 || lpcb->reserved1 != 0 || lpcb->reserved2 != 0)\r\ngoto out_free;\r\nswitch (req->lps) {\r\ncase 0:\r\nrc = clp_base_command(req, lpcb);\r\nbreak;\r\ncase 2:\r\nrc = clp_pci_command(req, lpcb);\r\nbreak;\r\n}\r\nif (rc)\r\ngoto out_free;\r\nrc = -EFAULT;\r\nif (copy_to_user(uptr, lpcb, PAGE_SIZE) != 0)\r\ngoto out_free;\r\nrc = 0;\r\nout_free:\r\nclp_free_block(lpcb);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int clp_immediate_command(struct clp_req *req)\r\n{\r\nvoid __user *uptr;\r\nunsigned long ilp;\r\nint exists;\r\nif (req->cmd > 1 || clp_get_ilp(&ilp) != 0)\r\nreturn -EINVAL;\r\nuptr = (void __force __user *)(unsigned long) req->data_p;\r\nif (req->cmd == 0) {\r\nexists = test_bit_inv(req->lps, &ilp);\r\nreturn put_user(exists, (int __user *) uptr);\r\n}\r\nreturn put_user(ilp, (unsigned long __user *) uptr);\r\n}\r\nstatic long clp_misc_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct clp_req req;\r\nvoid __user *argp;\r\nif (cmd != CLP_SYNC)\r\nreturn -EINVAL;\r\nargp = is_compat_task() ? compat_ptr(arg) : (void __user *) arg;\r\nif (copy_from_user(&req, argp, sizeof(req)))\r\nreturn -EFAULT;\r\nif (req.r != 0)\r\nreturn -EINVAL;\r\nreturn req.c ? clp_immediate_command(&req) : clp_normal_command(&req);\r\n}\r\nstatic int clp_misc_release(struct inode *inode, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init clp_misc_init(void)\r\n{\r\nreturn misc_register(&clp_misc_device);\r\n}
