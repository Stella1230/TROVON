static int ca_set_slot_descr(void)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ca_set_pid(void)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void put_command_and_length(u8 *data, int command, int length)\r\n{\r\ndata[0] = (command >> 16) & 0xff;\r\ndata[1] = (command >> 8) & 0xff;\r\ndata[2] = command & 0xff;\r\ndata[3] = length;\r\n}\r\nstatic void put_checksum(u8 *check_string, int length)\r\n{\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Computing string checksum.");\r\ndprintk(verbose, DST_CA_DEBUG, 1, " -> string length : 0x%02x", length);\r\ncheck_string[length] = dst_check_sum (check_string, length);\r\ndprintk(verbose, DST_CA_DEBUG, 1, " -> checksum : 0x%02x", check_string[length]);\r\n}\r\nstatic int dst_ci_command(struct dst_state* state, u8 * data, u8 *ca_string, u8 len, int read)\r\n{\r\nu8 reply;\r\nmutex_lock(&state->dst_mutex);\r\ndst_comm_init(state);\r\nmsleep(65);\r\nif (write_dst(state, data, len)) {\r\ndprintk(verbose, DST_CA_INFO, 1, " Write not successful, trying to recover");\r\ndst_error_recovery(state);\r\ngoto error;\r\n}\r\nif ((dst_pio_disable(state)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " DST PIO disable failed.");\r\ngoto error;\r\n}\r\nif (read_dst(state, &reply, GET_ACK) < 0) {\r\ndprintk(verbose, DST_CA_INFO, 1, " Read not successful, trying to recover");\r\ndst_error_recovery(state);\r\ngoto error;\r\n}\r\nif (read) {\r\nif (! dst_wait_dst_ready(state, LONG_DELAY)) {\r\ndprintk(verbose, DST_CA_NOTICE, 1, " 8820 not ready");\r\ngoto error;\r\n}\r\nif (read_dst(state, ca_string, 128) < 0) {\r\ndprintk(verbose, DST_CA_INFO, 1, " Read not successful, trying to recover");\r\ndst_error_recovery(state);\r\ngoto error;\r\n}\r\n}\r\nmutex_unlock(&state->dst_mutex);\r\nreturn 0;\r\nerror:\r\nmutex_unlock(&state->dst_mutex);\r\nreturn -EIO;\r\n}\r\nstatic int dst_put_ci(struct dst_state *state, u8 *data, int len, u8 *ca_string, int read)\r\n{\r\nu8 dst_ca_comm_err = 0;\r\nwhile (dst_ca_comm_err < RETRIES) {\r\ndprintk(verbose, DST_CA_NOTICE, 1, " Put Command");\r\nif (dst_ci_command(state, data, ca_string, len, read)) {\r\ndst_error_recovery(state);\r\ndst_ca_comm_err++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif(dst_ca_comm_err == RETRIES)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int ca_get_app_info(struct dst_state *state)\r\n{\r\nint length, str_length;\r\nstatic u8 command[8] = {0x07, 0x40, 0x01, 0x00, 0x01, 0x00, 0x00, 0xff};\r\nput_checksum(&command[0], command[0]);\r\nif ((dst_put_ci(state, command, sizeof(command), state->messages, GET_REPLY)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->dst_put_ci FAILED !");\r\nreturn -1;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->dst_put_ci SUCCESS !");\r\ndprintk(verbose, DST_CA_INFO, 1, " ================================ CI Module Application Info ======================================");\r\ndprintk(verbose, DST_CA_INFO, 1, " Application Type=[%d], Application Vendor=[%d], Vendor Code=[%d]\n%s: Application info=[%s]",\r\nstate->messages[7], (state->messages[8] << 8) | state->messages[9],\r\n(state->messages[10] << 8) | state->messages[11], __func__, (char *)(&state->messages[12]));\r\ndprintk(verbose, DST_CA_INFO, 1, " ==================================================================================================");\r\nlength = state->messages[5];\r\nstr_length = length - 6;\r\nif (str_length < 0) {\r\nstr_length = 0;\r\ndprintk(verbose, DST_CA_ERROR, 1, "Invalid string length returned in ca_get_app_info(). Recovering.");\r\n}\r\nput_command_and_length(&state->messages[0], CA_APP_INFO, length);\r\nmemmove(&state->messages[4], &state->messages[7], 5);\r\nstate->messages[9] = str_length;\r\nmemmove(&state->messages[10], &state->messages[12], str_length);\r\nreturn 0;\r\n}\r\nstatic int ca_get_ca_info(struct dst_state *state)\r\n{\r\nint srcPtr, dstPtr, i, num_ids;\r\nstatic u8 slot_command[8] = {0x07, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff};\r\nconst int in_system_id_pos = 8, out_system_id_pos = 4, in_num_ids_pos = 7;\r\nput_checksum(&slot_command[0], slot_command[0]);\r\nif ((dst_put_ci(state, slot_command, sizeof (slot_command), state->messages, GET_REPLY)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->dst_put_ci FAILED !");\r\nreturn -1;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->dst_put_ci SUCCESS !");\r\ndprintk(verbose, DST_CA_INFO, 0, " DST data = [");\r\nfor (i = 0; i < state->messages[0] + 1; i++) {\r\ndprintk(verbose, DST_CA_INFO, 0, " 0x%02x", state->messages[i]);\r\n}\r\ndprintk(verbose, DST_CA_INFO, 0, "]\n");\r\nnum_ids = state->messages[in_num_ids_pos];\r\nif (num_ids >= 100) {\r\nnum_ids = 100;\r\ndprintk(verbose, DST_CA_ERROR, 1, "Invalid number of ids (>100). Recovering.");\r\n}\r\nput_command_and_length(&state->messages[0], CA_INFO, num_ids * 2);\r\ndprintk(verbose, DST_CA_INFO, 0, " CA_INFO = [");\r\nsrcPtr = in_system_id_pos;\r\ndstPtr = out_system_id_pos;\r\nfor(i = 0; i < num_ids; i++) {\r\ndprintk(verbose, DST_CA_INFO, 0, " 0x%02x%02x", state->messages[srcPtr + 0], state->messages[srcPtr + 1]);\r\nstate->messages[dstPtr + 0] = state->messages[srcPtr + 0];\r\nstate->messages[dstPtr + 1] = state->messages[srcPtr + 1];\r\nsrcPtr += 2;\r\ndstPtr += 2;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 0, "]\n");\r\nreturn 0;\r\n}\r\nstatic int ca_get_slot_caps(struct dst_state *state, struct ca_caps *p_ca_caps, void __user *arg)\r\n{\r\nint i;\r\nu8 slot_cap[256];\r\nstatic u8 slot_command[8] = {0x07, 0x40, 0x02, 0x00, 0x02, 0x00, 0x00, 0xff};\r\nput_checksum(&slot_command[0], slot_command[0]);\r\nif ((dst_put_ci(state, slot_command, sizeof (slot_command), slot_cap, GET_REPLY)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->dst_put_ci FAILED !");\r\nreturn -1;\r\n}\r\ndprintk(verbose, DST_CA_NOTICE, 1, " -->dst_put_ci SUCCESS !");\r\ndprintk(verbose, DST_CA_INFO, 1, " Slot cap = [%d]", slot_cap[7]);\r\ndprintk(verbose, DST_CA_INFO, 0, "===================================\n");\r\nfor (i = 0; i < slot_cap[0] + 1; i++)\r\ndprintk(verbose, DST_CA_INFO, 0, " %d", slot_cap[i]);\r\ndprintk(verbose, DST_CA_INFO, 0, "\n");\r\np_ca_caps->slot_num = 1;\r\np_ca_caps->slot_type = 1;\r\np_ca_caps->descr_num = slot_cap[7];\r\np_ca_caps->descr_type = 1;\r\nif (copy_to_user(arg, p_ca_caps, sizeof (struct ca_caps)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ca_get_slot_descr(struct dst_state *state, struct ca_msg *p_ca_message, void __user *arg)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ca_get_slot_info(struct dst_state *state, struct ca_slot_info *p_ca_slot_info, void __user *arg)\r\n{\r\nint i;\r\nstatic u8 slot_command[8] = {0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff};\r\nu8 *slot_info = state->messages;\r\nput_checksum(&slot_command[0], 7);\r\nif ((dst_put_ci(state, slot_command, sizeof (slot_command), slot_info, GET_REPLY)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->dst_put_ci FAILED !");\r\nreturn -1;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->dst_put_ci SUCCESS !");\r\ndprintk(verbose, DST_CA_INFO, 1, " Slot info = [%d]", slot_info[3]);\r\ndprintk(verbose, DST_CA_INFO, 0, "===================================\n");\r\nfor (i = 0; i < 8; i++)\r\ndprintk(verbose, DST_CA_INFO, 0, " %d", slot_info[i]);\r\ndprintk(verbose, DST_CA_INFO, 0, "\n");\r\nif (slot_info[4] & 0x80) {\r\np_ca_slot_info->flags = CA_CI_MODULE_PRESENT;\r\np_ca_slot_info->num = 1;\r\np_ca_slot_info->type = CA_CI;\r\n} else if (slot_info[4] & 0x40) {\r\np_ca_slot_info->flags = CA_CI_MODULE_READY;\r\np_ca_slot_info->num = 1;\r\np_ca_slot_info->type = CA_CI;\r\n} else\r\np_ca_slot_info->flags = 0;\r\nif (copy_to_user(arg, p_ca_slot_info, sizeof (struct ca_slot_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ca_get_message(struct dst_state *state, struct ca_msg *p_ca_message, void __user *arg)\r\n{\r\nu8 i = 0;\r\nu32 command = 0;\r\nif (copy_from_user(p_ca_message, arg, sizeof (struct ca_msg)))\r\nreturn -EFAULT;\r\ndprintk(verbose, DST_CA_NOTICE, 1, " Message = [%*ph]",\r\n3, p_ca_message->msg);\r\nfor (i = 0; i < 3; i++) {\r\ncommand = command | p_ca_message->msg[i];\r\nif (i < 2)\r\ncommand = command << 8;\r\n}\r\ndprintk(verbose, DST_CA_NOTICE, 1, " Command=[0x%x]", command);\r\nswitch (command) {\r\ncase CA_APP_INFO:\r\nmemcpy(p_ca_message->msg, state->messages, 128);\r\nif (copy_to_user(arg, p_ca_message, sizeof (struct ca_msg)) )\r\nreturn -EFAULT;\r\nbreak;\r\ncase CA_INFO:\r\nmemcpy(p_ca_message->msg, state->messages, 128);\r\nif (copy_to_user(arg, p_ca_message, sizeof (struct ca_msg)) )\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_dst_tag(struct dst_state *state, struct ca_msg *p_ca_message, struct ca_msg *hw_buffer, u32 length)\r\n{\r\nif (state->dst_hw_cap & DST_TYPE_HAS_SESSION) {\r\nhw_buffer->msg[2] = p_ca_message->msg[1];\r\nhw_buffer->msg[3] = p_ca_message->msg[2];\r\n} else {\r\nif (length > 247) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " Message too long ! *** Bailing Out *** !");\r\nreturn -1;\r\n}\r\nhw_buffer->msg[0] = (length & 0xff) + 7;\r\nhw_buffer->msg[1] = 0x40;\r\nhw_buffer->msg[2] = 0x03;\r\nhw_buffer->msg[3] = 0x00;\r\nhw_buffer->msg[4] = 0x03;\r\nhw_buffer->msg[5] = length & 0xff;\r\nhw_buffer->msg[6] = 0x00;\r\nmemcpy(&hw_buffer->msg[7], &p_ca_message->msg[4], length);\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_to_8820(struct dst_state *state, struct ca_msg *hw_buffer, u8 length, u8 reply)\r\n{\r\nif ((dst_put_ci(state, hw_buffer->msg, length, hw_buffer->msg, reply)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " DST-CI Command failed.");\r\ndprintk(verbose, DST_CA_NOTICE, 1, " Resetting DST.");\r\nrdc_reset_state(state);\r\nreturn -1;\r\n}\r\ndprintk(verbose, DST_CA_NOTICE, 1, " DST-CI Command success.");\r\nreturn 0;\r\n}\r\nstatic u32 asn_1_decode(u8 *asn_1_array)\r\n{\r\nu8 length_field = 0, word_count = 0, count = 0;\r\nu32 length = 0;\r\nlength_field = asn_1_array[0];\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Length field=[%02x]", length_field);\r\nif (length_field < 0x80) {\r\nlength = length_field & 0x7f;\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Length=[%02x]\n", length);\r\n} else {\r\nword_count = length_field & 0x7f;\r\nfor (count = 0; count < word_count; count++) {\r\nlength = length << 8;\r\nlength += asn_1_array[count + 1];\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Length=[%04x]", length);\r\n}\r\n}\r\nreturn length;\r\n}\r\nstatic int debug_string(u8 *msg, u32 length, u32 offset)\r\n{\r\nu32 i;\r\ndprintk(verbose, DST_CA_DEBUG, 0, " String=[ ");\r\nfor (i = offset; i < length; i++)\r\ndprintk(verbose, DST_CA_DEBUG, 0, "%02x ", msg[i]);\r\ndprintk(verbose, DST_CA_DEBUG, 0, "]\n");\r\nreturn 0;\r\n}\r\nstatic int ca_set_pmt(struct dst_state *state, struct ca_msg *p_ca_message, struct ca_msg *hw_buffer, u8 reply, u8 query)\r\n{\r\nu32 length = 0;\r\nu8 tag_length = 8;\r\nlength = asn_1_decode(&p_ca_message->msg[3]);\r\ndprintk(verbose, DST_CA_DEBUG, 1, " CA Message length=[%d]", length);\r\ndebug_string(&p_ca_message->msg[4], length, 0);\r\nmemset(hw_buffer->msg, '\0', length);\r\nhandle_dst_tag(state, p_ca_message, hw_buffer, length);\r\nput_checksum(hw_buffer->msg, hw_buffer->msg[0]);\r\ndebug_string(hw_buffer->msg, (length + tag_length), 0);\r\nwrite_to_8820(state, hw_buffer, (length + tag_length), reply);\r\nreturn 0;\r\n}\r\nstatic int dst_check_ca_pmt(struct dst_state *state, struct ca_msg *p_ca_message, struct ca_msg *hw_buffer)\r\n{\r\nint ca_pmt_reply_test = 0;\r\nif (ca_pmt_reply_test) {\r\nif ((ca_set_pmt(state, p_ca_message, hw_buffer, 1, GET_REPLY)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " ca_set_pmt.. failed !");\r\nreturn -1;\r\n}\r\ndprintk(verbose, DST_CA_ERROR, 1, " Not there yet");\r\n}\r\nif (!ca_pmt_reply_test) {\r\nif ((ca_set_pmt(state, p_ca_message, hw_buffer, 0, NO_REPLY)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " ca_set_pmt.. failed !");\r\nreturn -1;\r\n}\r\ndprintk(verbose, DST_CA_NOTICE, 1, " ca_set_pmt.. success !");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ca_send_message(struct dst_state *state, struct ca_msg *p_ca_message, void __user *arg)\r\n{\r\nint i = 0;\r\nu32 command = 0;\r\nstruct ca_msg *hw_buffer;\r\nint result = 0;\r\nif ((hw_buffer = kmalloc(sizeof (struct ca_msg), GFP_KERNEL)) == NULL) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " Memory allocation failure");\r\nreturn -ENOMEM;\r\n}\r\ndprintk(verbose, DST_CA_DEBUG, 1, " ");\r\nif (copy_from_user(p_ca_message, arg, sizeof (struct ca_msg))) {\r\nresult = -EFAULT;\r\ngoto free_mem_and_exit;\r\n}\r\ncommand = 0;\r\nfor (i = 0; i < 3; i++) {\r\ncommand = command | p_ca_message->msg[i];\r\nif (i < 2)\r\ncommand = command << 8;\r\n}\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Command=[0x%x]\n", command);\r\nswitch (command) {\r\ncase CA_PMT:\r\ndprintk(verbose, DST_CA_DEBUG, 1, "Command = SEND_CA_PMT");\r\nif ((ca_set_pmt(state, p_ca_message, hw_buffer, 0, 0)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_PMT Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_PMT Success !");\r\nbreak;\r\ncase CA_PMT_REPLY:\r\ndprintk(verbose, DST_CA_INFO, 1, "Command = CA_PMT_REPLY");\r\nif ((dst_check_ca_pmt(state, p_ca_message, hw_buffer)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_PMT_REPLY Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_PMT_REPLY Success !");\r\nbreak;\r\ncase CA_APP_INFO_ENQUIRY:\r\ndprintk(verbose, DST_CA_INFO, 1, " Getting Cam Application information");\r\nif ((ca_get_app_info(state)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_APP_INFO_ENQUIRY Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_APP_INFO_ENQUIRY Success !");\r\nbreak;\r\ncase CA_INFO_ENQUIRY:\r\ndprintk(verbose, DST_CA_INFO, 1, " Getting CA Information");\r\nif ((ca_get_ca_info(state)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_INFO_ENQUIRY Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_INFO_ENQUIRY Success !");\r\nbreak;\r\n}\r\nfree_mem_and_exit:\r\nkfree (hw_buffer);\r\nreturn result;\r\n}\r\nstatic long dst_ca_ioctl(struct file *file, unsigned int cmd, unsigned long ioctl_arg)\r\n{\r\nstruct dvb_device *dvbdev;\r\nstruct dst_state *state;\r\nstruct ca_slot_info *p_ca_slot_info;\r\nstruct ca_caps *p_ca_caps;\r\nstruct ca_msg *p_ca_message;\r\nvoid __user *arg = (void __user *)ioctl_arg;\r\nint result = 0;\r\nmutex_lock(&dst_ca_mutex);\r\ndvbdev = file->private_data;\r\nstate = (struct dst_state *)dvbdev->priv;\r\np_ca_message = kmalloc(sizeof (struct ca_msg), GFP_KERNEL);\r\np_ca_slot_info = kmalloc(sizeof (struct ca_slot_info), GFP_KERNEL);\r\np_ca_caps = kmalloc(sizeof (struct ca_caps), GFP_KERNEL);\r\nif (!p_ca_message || !p_ca_slot_info || !p_ca_caps) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " Memory allocation failure");\r\nresult = -ENOMEM;\r\ngoto free_mem_and_exit;\r\n}\r\nswitch (cmd) {\r\ncase CA_SEND_MSG:\r\ndprintk(verbose, DST_CA_INFO, 1, " Sending message");\r\nif ((ca_send_message(state, p_ca_message, arg)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_SEND_MSG Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\nbreak;\r\ncase CA_GET_MSG:\r\ndprintk(verbose, DST_CA_INFO, 1, " Getting message");\r\nif ((ca_get_message(state, p_ca_message, arg)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_GET_MSG Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_GET_MSG Success !");\r\nbreak;\r\ncase CA_RESET:\r\ndprintk(verbose, DST_CA_ERROR, 1, " Resetting DST");\r\ndst_error_bailout(state);\r\nmsleep(4000);\r\nbreak;\r\ncase CA_GET_SLOT_INFO:\r\ndprintk(verbose, DST_CA_INFO, 1, " Getting Slot info");\r\nif ((ca_get_slot_info(state, p_ca_slot_info, arg)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_GET_SLOT_INFO Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_GET_SLOT_INFO Success !");\r\nbreak;\r\ncase CA_GET_CAP:\r\ndprintk(verbose, DST_CA_INFO, 1, " Getting Slot capabilities");\r\nif ((ca_get_slot_caps(state, p_ca_caps, arg)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_GET_CAP Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_GET_CAP Success !");\r\nbreak;\r\ncase CA_GET_DESCR_INFO:\r\ndprintk(verbose, DST_CA_INFO, 1, " Getting descrambler description");\r\nif ((ca_get_slot_descr(state, p_ca_message, arg)) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_GET_DESCR_INFO Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_GET_DESCR_INFO Success !");\r\nbreak;\r\ncase CA_SET_DESCR:\r\ndprintk(verbose, DST_CA_INFO, 1, " Setting descrambler");\r\nif ((ca_set_slot_descr()) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_SET_DESCR Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_SET_DESCR Success !");\r\nbreak;\r\ncase CA_SET_PID:\r\ndprintk(verbose, DST_CA_INFO, 1, " Setting PID");\r\nif ((ca_set_pid()) < 0) {\r\ndprintk(verbose, DST_CA_ERROR, 1, " -->CA_SET_PID Failed !");\r\nresult = -1;\r\ngoto free_mem_and_exit;\r\n}\r\ndprintk(verbose, DST_CA_INFO, 1, " -->CA_SET_PID Success !");\r\ndefault:\r\nresult = -EOPNOTSUPP;\r\n}\r\nfree_mem_and_exit:\r\nkfree (p_ca_message);\r\nkfree (p_ca_slot_info);\r\nkfree (p_ca_caps);\r\nmutex_unlock(&dst_ca_mutex);\r\nreturn result;\r\n}\r\nstatic int dst_ca_open(struct inode *inode, struct file *file)\r\n{\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Device opened [%p] ", file);\r\nreturn 0;\r\n}\r\nstatic int dst_ca_release(struct inode *inode, struct file *file)\r\n{\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Device closed.");\r\nreturn 0;\r\n}\r\nstatic ssize_t dst_ca_read(struct file *file, char __user *buffer, size_t length, loff_t *offset)\r\n{\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Device read.");\r\nreturn 0;\r\n}\r\nstatic ssize_t dst_ca_write(struct file *file, const char __user *buffer, size_t length, loff_t *offset)\r\n{\r\ndprintk(verbose, DST_CA_DEBUG, 1, " Device write.");\r\nreturn 0;\r\n}\r\nstruct dvb_device *dst_ca_attach(struct dst_state *dst, struct dvb_adapter *dvb_adapter)\r\n{\r\nstruct dvb_device *dvbdev;\r\ndprintk(verbose, DST_CA_ERROR, 1, "registering DST-CA device");\r\nif (dvb_register_device(dvb_adapter, &dvbdev, &dvbdev_ca, dst,\r\nDVB_DEVICE_CA, 0) == 0) {\r\ndst->dst_ca = dvbdev;\r\nreturn dst->dst_ca;\r\n}\r\nreturn NULL;\r\n}
