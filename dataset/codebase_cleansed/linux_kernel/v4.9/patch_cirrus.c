static inline int cs_vendor_coef_get(struct hda_codec *codec, unsigned int idx)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nsnd_hda_codec_write(codec, spec->vendor_nid, 0,\r\nAC_VERB_SET_COEF_INDEX, idx);\r\nreturn snd_hda_codec_read(codec, spec->vendor_nid, 0,\r\nAC_VERB_GET_PROC_COEF, 0);\r\n}\r\nstatic inline void cs_vendor_coef_set(struct hda_codec *codec, unsigned int idx,\r\nunsigned int coef)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nsnd_hda_codec_write(codec, spec->vendor_nid, 0,\r\nAC_VERB_SET_COEF_INDEX, idx);\r\nsnd_hda_codec_write(codec, spec->vendor_nid, 0,\r\nAC_VERB_SET_PROC_COEF, coef);\r\n}\r\nstatic void cs_automute(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nspec->gen.master_mute = !!(spec->spdif_present && spec->sense_b);\r\nsnd_hda_gen_update_outputs(codec);\r\nif (spec->gpio_eapd_hp || spec->gpio_eapd_speaker) {\r\nif (spec->gen.automute_speaker)\r\nspec->gpio_data = spec->gen.hp_jack_present ?\r\nspec->gpio_eapd_hp : spec->gpio_eapd_speaker;\r\nelse\r\nspec->gpio_data =\r\nspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\r\nsnd_hda_codec_write(codec, 0x01, 0,\r\nAC_VERB_SET_GPIO_DATA, spec->gpio_data);\r\n}\r\n}\r\nstatic bool is_active_pin(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int val;\r\nval = snd_hda_codec_get_pincfg(codec, nid);\r\nreturn (get_defcfg_connect(val) != AC_JACK_PORT_NONE);\r\n}\r\nstatic void init_input_coef(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nunsigned int coef;\r\nif (spec->vendor_nid == CS420X_VENDOR_NID) {\r\ncoef = cs_vendor_coef_get(codec, IDX_BEEP_CFG);\r\nif (is_active_pin(codec, CS_DMIC2_PIN_NID))\r\ncoef |= 1 << 4;\r\nif (is_active_pin(codec, CS_DMIC1_PIN_NID))\r\ncoef |= 1 << 3;\r\ncs_vendor_coef_set(codec, IDX_BEEP_CFG, coef);\r\n}\r\n}\r\nstatic void init_digital_coef(struct hda_codec *codec)\r\n{\r\nunsigned int coef;\r\ncoef = 0x0002;\r\ncoef |= 0x0008;\r\nif (is_active_pin(codec, CS_DIG_OUT2_PIN_NID))\r\ncoef |= 0x4000;\r\ncs_vendor_coef_set(codec, IDX_SPDIF_CTL, coef);\r\n}\r\nstatic int cs_init(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nif (spec->vendor_nid == CS420X_VENDOR_NID) {\r\nsnd_hda_sequence_write(codec, cs_errata_init_verbs);\r\nsnd_hda_sequence_write(codec, cs_coef_init_verbs);\r\n} else if (spec->vendor_nid == CS4208_VENDOR_NID) {\r\nsnd_hda_sequence_write(codec, cs4208_coef_init_verbs);\r\n}\r\nsnd_hda_gen_init(codec);\r\nif (spec->gpio_mask) {\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_MASK,\r\nspec->gpio_mask);\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DIRECTION,\r\nspec->gpio_dir);\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA,\r\nspec->gpio_data);\r\n}\r\nif (spec->vendor_nid == CS420X_VENDOR_NID) {\r\ninit_input_coef(codec);\r\ninit_digital_coef(codec);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs_build_controls(struct hda_codec *codec)\r\n{\r\nint err;\r\nerr = snd_hda_gen_build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_BUILD);\r\nreturn 0;\r\n}\r\nstatic int cs_parse_auto_config(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nint err;\r\nint i;\r\nerr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->gen.dyn_adc_switch) {\r\nunsigned int done = 0;\r\nfor (i = 0; i < spec->gen.input_mux.num_items; i++) {\r\nint idx = spec->gen.dyn_adc_idx[i];\r\nif (done & (1 << idx))\r\ncontinue;\r\nsnd_hda_gen_fix_pin_power(codec,\r\nspec->gen.adc_nids[idx]);\r\ndone |= 1 << idx;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cs420x_fixup_gpio_13(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nstruct cs_spec *spec = codec->spec;\r\nspec->gpio_eapd_hp = 2;\r\nspec->gpio_eapd_speaker = 8;\r\nspec->gpio_mask = spec->gpio_dir =\r\nspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\r\n}\r\n}\r\nstatic void cs420x_fixup_gpio_23(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nstruct cs_spec *spec = codec->spec;\r\nspec->gpio_eapd_hp = 4;\r\nspec->gpio_eapd_speaker = 8;\r\nspec->gpio_mask = spec->gpio_dir =\r\nspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\r\n}\r\n}\r\nstatic struct cs_spec *cs_alloc_spec(struct hda_codec *codec, int vendor_nid)\r\n{\r\nstruct cs_spec *spec;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn NULL;\r\ncodec->spec = spec;\r\nspec->vendor_nid = vendor_nid;\r\ncodec->power_save_node = 1;\r\nsnd_hda_gen_spec_init(&spec->gen);\r\nreturn spec;\r\n}\r\nstatic int patch_cs420x(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec;\r\nint err;\r\nspec = cs_alloc_spec(codec, CS420X_VENDOR_NID);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->patch_ops = cs_patch_ops;\r\nspec->gen.automute_hook = cs_automute;\r\ncodec->single_adc_amp = 1;\r\nsnd_hda_pick_fixup(codec, cs420x_models, cs420x_fixup_tbl,\r\ncs420x_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = cs_parse_auto_config(codec);\r\nif (err < 0)\r\ngoto error;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\nerror:\r\ncs_free(codec);\r\nreturn err;\r\n}\r\nstatic void cs4208_fixup_gpio0(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\nstruct cs_spec *spec = codec->spec;\r\nspec->gpio_eapd_hp = 0;\r\nspec->gpio_eapd_speaker = 1;\r\nspec->gpio_mask = spec->gpio_dir =\r\nspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\r\n}\r\n}\r\nstatic void cs4208_fixup_mac(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action != HDA_FIXUP_ACT_PRE_PROBE)\r\nreturn;\r\ncodec->fixup_id = HDA_FIXUP_ID_NOT_SET;\r\nsnd_hda_pick_fixup(codec, NULL, cs4208_mac_fixup_tbl, cs4208_fixups);\r\nif (codec->fixup_id == HDA_FIXUP_ID_NOT_SET)\r\ncodec->fixup_id = CS4208_GPIO0;\r\nsnd_hda_apply_fixup(codec, action);\r\n}\r\nstatic void cs4208_fixup_macmini(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstatic const struct hda_pintbl pincfgs[] = {\r\n{ 0x18, 0x00ab9150 },\r\n{ 0x21, 0x004be140 },\r\n{ }\r\n};\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE) {\r\ncodec->inv_jack_detect = 1;\r\nsnd_hda_apply_pincfgs(codec, pincfgs);\r\n}\r\n}\r\nstatic int cs4208_spdif_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cs_spec *spec = codec->spec;\r\nhda_nid_t pin = spec->gen.autocfg.dig_out_pins[0];\r\nint pinctl = ucontrol->value.integer.value[0] ? PIN_OUT : 0;\r\nsnd_hda_set_pin_ctl_cache(codec, pin, pinctl);\r\nreturn spec->spdif_sw_put(kcontrol, ucontrol);\r\n}\r\nstatic void cs4208_fixup_spdif_switch(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_BUILD) {\r\nstruct cs_spec *spec = codec->spec;\r\nstruct snd_kcontrol *kctl;\r\nif (!spec->gen.autocfg.dig_out_pins[0])\r\nreturn;\r\nkctl = snd_hda_find_mixer_ctl(codec, "IEC958 Playback Switch");\r\nif (!kctl)\r\nreturn;\r\nspec->spdif_sw_put = kctl->put;\r\nkctl->put = cs4208_spdif_sw_put;\r\n}\r\n}\r\nstatic void cs4208_fix_amp_caps(struct hda_codec *codec, hda_nid_t adc)\r\n{\r\nunsigned int caps;\r\ncaps = query_amp_caps(codec, adc, HDA_INPUT);\r\ncaps &= ~(AC_AMPCAP_OFFSET);\r\ncaps |= 0x02;\r\nsnd_hda_override_amp_caps(codec, adc, HDA_INPUT, caps);\r\n}\r\nstatic int patch_cs4208(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec;\r\nint err;\r\nspec = cs_alloc_spec(codec, CS4208_VENDOR_NID);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->patch_ops = cs_patch_ops;\r\nspec->gen.automute_hook = cs_automute;\r\nspec->gen.out_vol_mask = 1ULL << 0x10;\r\nsnd_hda_pick_fixup(codec, cs4208_models, cs4208_fixup_tbl,\r\ncs4208_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nsnd_hda_override_wcaps(codec, 0x18,\r\nget_wcaps(codec, 0x18) | AC_WCAP_STEREO);\r\ncs4208_fix_amp_caps(codec, 0x18);\r\ncs4208_fix_amp_caps(codec, 0x1b);\r\ncs4208_fix_amp_caps(codec, 0x1c);\r\nerr = cs_parse_auto_config(codec);\r\nif (err < 0)\r\ngoto error;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\nerror:\r\ncs_free(codec);\r\nreturn err;\r\n}\r\nstatic void cs421x_fixup_sense_b(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\nspec->sense_b = 1;\r\n}\r\nstatic int cs421x_boost_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 3;\r\nreturn 0;\r\n}\r\nstatic int cs421x_boost_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\ncs_vendor_coef_get(codec, CS421X_IDX_SPK_CTL) & 0x0003;\r\nreturn 0;\r\n}\r\nstatic int cs421x_boost_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int vol = ucontrol->value.integer.value[0];\r\nunsigned int coef =\r\ncs_vendor_coef_get(codec, CS421X_IDX_SPK_CTL);\r\nunsigned int original_coef = coef;\r\ncoef &= ~0x0003;\r\ncoef |= (vol & 0x0003);\r\nif (original_coef == coef)\r\nreturn 0;\r\nelse {\r\ncs_vendor_coef_set(codec, CS421X_IDX_SPK_CTL, coef);\r\nreturn 1;\r\n}\r\n}\r\nstatic void cs4210_pinmux_init(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nunsigned int def_conf, coef;\r\ncoef = cs_vendor_coef_get(codec, CS421X_IDX_DEV_CFG);\r\nif (spec->gpio_mask)\r\ncoef |= 0x0008;\r\nelse\r\ncoef &= ~0x0008;\r\nif (spec->sense_b)\r\ncoef |= 0x0010;\r\nelse\r\ncoef &= ~0x0010;\r\ncs_vendor_coef_set(codec, CS421X_IDX_DEV_CFG, coef);\r\nif ((spec->gpio_mask || spec->sense_b) &&\r\nis_active_pin(codec, CS421X_DMIC_PIN_NID)) {\r\ndef_conf = snd_hda_codec_get_pincfg(codec, CS421X_DMIC_PIN_NID);\r\ndef_conf &= ~AC_DEFCFG_PORT_CONN;\r\ndef_conf |= (AC_JACK_PORT_NONE << AC_DEFCFG_PORT_CONN_SHIFT);\r\nsnd_hda_codec_set_pincfg(codec, CS421X_DMIC_PIN_NID, def_conf);\r\n}\r\n}\r\nstatic void cs4210_spdif_automute(struct hda_codec *codec,\r\nstruct hda_jack_callback *tbl)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nbool spdif_present = false;\r\nhda_nid_t spdif_pin = spec->gen.autocfg.dig_out_pins[0];\r\nif (!spec->spdif_detect ||\r\nspec->vendor_nid != CS4210_VENDOR_NID)\r\nreturn;\r\nspdif_present = snd_hda_jack_detect(codec, spdif_pin);\r\nif (spdif_present == spec->spdif_present)\r\nreturn;\r\nspec->spdif_present = spdif_present;\r\nsnd_hda_set_pin_ctl(codec, spdif_pin, spdif_present ? PIN_OUT : 0);\r\ncs_automute(codec);\r\n}\r\nstatic void parse_cs421x_digital(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\r\nint i;\r\nfor (i = 0; i < cfg->dig_outs; i++) {\r\nhda_nid_t nid = cfg->dig_out_pins[i];\r\nif (get_wcaps(codec, nid) & AC_WCAP_UNSOL_CAP) {\r\nspec->spdif_detect = 1;\r\nsnd_hda_jack_detect_enable_callback(codec, nid,\r\ncs4210_spdif_automute);\r\n}\r\n}\r\n}\r\nstatic int cs421x_init(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nif (spec->vendor_nid == CS4210_VENDOR_NID) {\r\nsnd_hda_sequence_write(codec, cs421x_coef_init_verbs);\r\nsnd_hda_sequence_write(codec, cs421x_coef_init_verbs_A1_silicon_fixes);\r\ncs4210_pinmux_init(codec);\r\n}\r\nsnd_hda_gen_init(codec);\r\nif (spec->gpio_mask) {\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_MASK,\r\nspec->gpio_mask);\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DIRECTION,\r\nspec->gpio_dir);\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA,\r\nspec->gpio_data);\r\n}\r\ninit_input_coef(codec);\r\ncs4210_spdif_automute(codec, NULL);\r\nreturn 0;\r\n}\r\nstatic int cs421x_build_controls(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nint err;\r\nerr = snd_hda_gen_build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->gen.autocfg.speaker_outs &&\r\nspec->vendor_nid == CS4210_VENDOR_NID) {\r\nerr = snd_hda_ctl_add(codec, 0,\r\nsnd_ctl_new1(&cs421x_speaker_boost_ctl, codec));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fix_volume_caps(struct hda_codec *codec, hda_nid_t dac)\r\n{\r\nunsigned int caps;\r\ncaps = query_amp_caps(codec, dac, HDA_OUTPUT);\r\ncaps &= ~(0x7f << AC_AMPCAP_NUM_STEPS_SHIFT);\r\ncaps |= ((caps >> AC_AMPCAP_OFFSET_SHIFT) & 0x7f)\r\n<< AC_AMPCAP_NUM_STEPS_SHIFT;\r\nsnd_hda_override_amp_caps(codec, dac, HDA_OUTPUT, caps);\r\n}\r\nstatic int cs421x_parse_auto_config(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nhda_nid_t dac = CS4210_DAC_NID;\r\nint err;\r\nfix_volume_caps(codec, dac);\r\nerr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\r\nif (err < 0)\r\nreturn err;\r\nparse_cs421x_digital(codec);\r\nreturn 0;\r\n}\r\nstatic int cs421x_suspend(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nunsigned int coef;\r\nsnd_hda_shutup_pins(codec);\r\nsnd_hda_codec_write(codec, CS4210_DAC_NID, 0,\r\nAC_VERB_SET_POWER_STATE, AC_PWRST_D3);\r\nsnd_hda_codec_write(codec, CS4210_ADC_NID, 0,\r\nAC_VERB_SET_POWER_STATE, AC_PWRST_D3);\r\nif (spec->vendor_nid == CS4210_VENDOR_NID) {\r\ncoef = cs_vendor_coef_get(codec, CS421X_IDX_DEV_CFG);\r\ncoef |= 0x0004;\r\ncs_vendor_coef_set(codec, CS421X_IDX_DEV_CFG, coef);\r\n}\r\nreturn 0;\r\n}\r\nstatic int patch_cs4210(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec;\r\nint err;\r\nspec = cs_alloc_spec(codec, CS4210_VENDOR_NID);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->patch_ops = cs421x_patch_ops;\r\nspec->gen.automute_hook = cs_automute;\r\nsnd_hda_pick_fixup(codec, cs421x_models, cs421x_fixup_tbl,\r\ncs421x_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\ncs4210_pinmux_init(codec);\r\nerr = cs421x_parse_auto_config(codec);\r\nif (err < 0)\r\ngoto error;\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);\r\nreturn 0;\r\nerror:\r\ncs_free(codec);\r\nreturn err;\r\n}\r\nstatic int patch_cs4213(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec;\r\nint err;\r\nspec = cs_alloc_spec(codec, CS4213_VENDOR_NID);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->patch_ops = cs421x_patch_ops;\r\nerr = cs421x_parse_auto_config(codec);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ncs_free(codec);\r\nreturn err;\r\n}
