static struct resource *pnp_find_resource(struct pnp_dev *dev,\r\nunsigned char rule,\r\nunsigned long type,\r\nunsigned int bar)\r\n{\r\nstruct resource *res = pnp_get_resource(dev, type, bar);\r\nif (res) {\r\nres->flags &= ~IORESOURCE_BITS;\r\nres->flags |= rule & IORESOURCE_BITS;\r\n}\r\nreturn res;\r\n}\r\nstatic int pnp_assign_port(struct pnp_dev *dev, struct pnp_port *rule, int idx)\r\n{\r\nstruct resource *res, local_res;\r\nres = pnp_find_resource(dev, rule->flags, IORESOURCE_IO, idx);\r\nif (res) {\r\npnp_dbg(&dev->dev, " io %d already set to %#llx-%#llx "\r\n"flags %#lx\n", idx, (unsigned long long) res->start,\r\n(unsigned long long) res->end, res->flags);\r\nreturn 0;\r\n}\r\nres = &local_res;\r\nres->flags = rule->flags | IORESOURCE_AUTO;\r\nres->start = 0;\r\nres->end = 0;\r\nif (!rule->size) {\r\nres->flags |= IORESOURCE_DISABLED;\r\npnp_dbg(&dev->dev, " io %d disabled\n", idx);\r\ngoto __add;\r\n}\r\nres->start = rule->min;\r\nres->end = res->start + rule->size - 1;\r\nwhile (!pnp_check_port(dev, res)) {\r\nres->start += rule->align;\r\nres->end = res->start + rule->size - 1;\r\nif (res->start > rule->max || !rule->align) {\r\npnp_dbg(&dev->dev, " couldn't assign io %d "\r\n"(min %#llx max %#llx)\n", idx,\r\n(unsigned long long) rule->min,\r\n(unsigned long long) rule->max);\r\nreturn -EBUSY;\r\n}\r\n}\r\n__add:\r\npnp_add_io_resource(dev, res->start, res->end, res->flags);\r\nreturn 0;\r\n}\r\nstatic int pnp_assign_mem(struct pnp_dev *dev, struct pnp_mem *rule, int idx)\r\n{\r\nstruct resource *res, local_res;\r\nres = pnp_find_resource(dev, rule->flags, IORESOURCE_MEM, idx);\r\nif (res) {\r\npnp_dbg(&dev->dev, " mem %d already set to %#llx-%#llx "\r\n"flags %#lx\n", idx, (unsigned long long) res->start,\r\n(unsigned long long) res->end, res->flags);\r\nreturn 0;\r\n}\r\nres = &local_res;\r\nres->flags = rule->flags | IORESOURCE_AUTO;\r\nres->start = 0;\r\nres->end = 0;\r\nif (!(rule->flags & IORESOURCE_MEM_WRITEABLE))\r\nres->flags |= IORESOURCE_READONLY;\r\nif (rule->flags & IORESOURCE_MEM_RANGELENGTH)\r\nres->flags |= IORESOURCE_RANGELENGTH;\r\nif (rule->flags & IORESOURCE_MEM_SHADOWABLE)\r\nres->flags |= IORESOURCE_SHADOWABLE;\r\nif (!rule->size) {\r\nres->flags |= IORESOURCE_DISABLED;\r\npnp_dbg(&dev->dev, " mem %d disabled\n", idx);\r\ngoto __add;\r\n}\r\nres->start = rule->min;\r\nres->end = res->start + rule->size - 1;\r\nwhile (!pnp_check_mem(dev, res)) {\r\nres->start += rule->align;\r\nres->end = res->start + rule->size - 1;\r\nif (res->start > rule->max || !rule->align) {\r\npnp_dbg(&dev->dev, " couldn't assign mem %d "\r\n"(min %#llx max %#llx)\n", idx,\r\n(unsigned long long) rule->min,\r\n(unsigned long long) rule->max);\r\nreturn -EBUSY;\r\n}\r\n}\r\n__add:\r\npnp_add_mem_resource(dev, res->start, res->end, res->flags);\r\nreturn 0;\r\n}\r\nstatic int pnp_assign_irq(struct pnp_dev *dev, struct pnp_irq *rule, int idx)\r\n{\r\nstruct resource *res, local_res;\r\nint i;\r\nstatic unsigned short xtab[16] = {\r\n5, 10, 11, 12, 9, 14, 15, 7, 3, 4, 13, 0, 1, 6, 8, 2\r\n};\r\nres = pnp_find_resource(dev, rule->flags, IORESOURCE_IRQ, idx);\r\nif (res) {\r\npnp_dbg(&dev->dev, " irq %d already set to %d flags %#lx\n",\r\nidx, (int) res->start, res->flags);\r\nreturn 0;\r\n}\r\nres = &local_res;\r\nres->flags = rule->flags | IORESOURCE_AUTO;\r\nres->start = -1;\r\nres->end = -1;\r\nif (bitmap_empty(rule->map.bits, PNP_IRQ_NR)) {\r\nres->flags |= IORESOURCE_DISABLED;\r\npnp_dbg(&dev->dev, " irq %d disabled\n", idx);\r\ngoto __add;\r\n}\r\nres->start = find_next_bit(rule->map.bits, PNP_IRQ_NR, 16);\r\nif (res->start < PNP_IRQ_NR) {\r\nres->end = res->start;\r\ngoto __add;\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nif (test_bit(xtab[i], rule->map.bits)) {\r\nres->start = res->end = xtab[i];\r\nif (pnp_check_irq(dev, res))\r\ngoto __add;\r\n}\r\n}\r\nif (rule->flags & IORESOURCE_IRQ_OPTIONAL) {\r\nres->start = -1;\r\nres->end = -1;\r\nres->flags |= IORESOURCE_DISABLED;\r\npnp_dbg(&dev->dev, " irq %d disabled (optional)\n", idx);\r\ngoto __add;\r\n}\r\npnp_dbg(&dev->dev, " couldn't assign irq %d\n", idx);\r\nreturn -EBUSY;\r\n__add:\r\npnp_add_irq_resource(dev, res->start, res->flags);\r\nreturn 0;\r\n}\r\nstatic int pnp_assign_dma(struct pnp_dev *dev, struct pnp_dma *rule, int idx)\r\n{\r\nstruct resource *res, local_res;\r\nint i;\r\nstatic unsigned short xtab[8] = {\r\n1, 3, 5, 6, 7, 0, 2, 4\r\n};\r\nres = pnp_find_resource(dev, rule->flags, IORESOURCE_DMA, idx);\r\nif (res) {\r\npnp_dbg(&dev->dev, " dma %d already set to %d flags %#lx\n",\r\nidx, (int) res->start, res->flags);\r\nreturn 0;\r\n}\r\nres = &local_res;\r\nres->flags = rule->flags | IORESOURCE_AUTO;\r\nres->start = -1;\r\nres->end = -1;\r\nif (!rule->map) {\r\nres->flags |= IORESOURCE_DISABLED;\r\npnp_dbg(&dev->dev, " dma %d disabled\n", idx);\r\ngoto __add;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif (rule->map & (1 << xtab[i])) {\r\nres->start = res->end = xtab[i];\r\nif (pnp_check_dma(dev, res))\r\ngoto __add;\r\n}\r\n}\r\npnp_dbg(&dev->dev, " couldn't assign dma %d\n", idx);\r\nreturn -EBUSY;\r\n__add:\r\npnp_add_dma_resource(dev, res->start, res->flags);\r\nreturn 0;\r\n}\r\nvoid pnp_init_resources(struct pnp_dev *dev)\r\n{\r\npnp_free_resources(dev);\r\n}\r\nstatic void pnp_clean_resource_table(struct pnp_dev *dev)\r\n{\r\nstruct pnp_resource *pnp_res, *tmp;\r\nlist_for_each_entry_safe(pnp_res, tmp, &dev->resources, list) {\r\nif (pnp_res->res.flags & IORESOURCE_AUTO)\r\npnp_free_resource(pnp_res);\r\n}\r\n}\r\nstatic int pnp_assign_resources(struct pnp_dev *dev, int set)\r\n{\r\nstruct pnp_option *option;\r\nint nport = 0, nmem = 0, nirq = 0;\r\nint ndma __maybe_unused = 0;\r\nint ret = 0;\r\npnp_dbg(&dev->dev, "pnp_assign_resources, try dependent set %d\n", set);\r\nmutex_lock(&pnp_res_mutex);\r\npnp_clean_resource_table(dev);\r\nlist_for_each_entry(option, &dev->options, list) {\r\nif (pnp_option_is_dependent(option) &&\r\npnp_option_set(option) != set)\r\ncontinue;\r\nswitch (option->type) {\r\ncase IORESOURCE_IO:\r\nret = pnp_assign_port(dev, &option->u.port, nport++);\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nret = pnp_assign_mem(dev, &option->u.mem, nmem++);\r\nbreak;\r\ncase IORESOURCE_IRQ:\r\nret = pnp_assign_irq(dev, &option->u.irq, nirq++);\r\nbreak;\r\n#ifdef CONFIG_ISA_DMA_API\r\ncase IORESOURCE_DMA:\r\nret = pnp_assign_dma(dev, &option->u.dma, ndma++);\r\nbreak;\r\n#endif\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret < 0)\r\nbreak;\r\n}\r\nmutex_unlock(&pnp_res_mutex);\r\nif (ret < 0) {\r\npnp_dbg(&dev->dev, "pnp_assign_resources failed (%d)\n", ret);\r\npnp_clean_resource_table(dev);\r\n} else\r\ndbg_pnp_show_resources(dev, "pnp_assign_resources succeeded");\r\nreturn ret;\r\n}\r\nint pnp_auto_config_dev(struct pnp_dev *dev)\r\n{\r\nint i, ret;\r\nif (!pnp_can_configure(dev)) {\r\npnp_dbg(&dev->dev, "configuration not supported\n");\r\nreturn -ENODEV;\r\n}\r\nret = pnp_assign_resources(dev, 0);\r\nif (ret == 0)\r\nreturn 0;\r\nfor (i = 1; i < dev->num_dependent_sets; i++) {\r\nret = pnp_assign_resources(dev, i);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\ndev_err(&dev->dev, "unable to assign resources\n");\r\nreturn ret;\r\n}\r\nint pnp_start_dev(struct pnp_dev *dev)\r\n{\r\nif (!pnp_can_write(dev)) {\r\npnp_dbg(&dev->dev, "activation not supported\n");\r\nreturn -EINVAL;\r\n}\r\ndbg_pnp_show_resources(dev, "pnp_start_dev");\r\nif (dev->protocol->set(dev) < 0) {\r\ndev_err(&dev->dev, "activation failed\n");\r\nreturn -EIO;\r\n}\r\ndev_info(&dev->dev, "activated\n");\r\nreturn 0;\r\n}\r\nint pnp_stop_dev(struct pnp_dev *dev)\r\n{\r\nif (!pnp_can_disable(dev)) {\r\npnp_dbg(&dev->dev, "disabling not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (dev->protocol->disable(dev) < 0) {\r\ndev_err(&dev->dev, "disable failed\n");\r\nreturn -EIO;\r\n}\r\ndev_info(&dev->dev, "disabled\n");\r\nreturn 0;\r\n}\r\nint pnp_activate_dev(struct pnp_dev *dev)\r\n{\r\nint error;\r\nif (dev->active)\r\nreturn 0;\r\nif (pnp_auto_config_dev(dev))\r\nreturn -EBUSY;\r\nerror = pnp_start_dev(dev);\r\nif (error)\r\nreturn error;\r\ndev->active = 1;\r\nreturn 0;\r\n}\r\nint pnp_disable_dev(struct pnp_dev *dev)\r\n{\r\nint error;\r\nif (!dev->active)\r\nreturn 0;\r\nerror = pnp_stop_dev(dev);\r\nif (error)\r\nreturn error;\r\ndev->active = 0;\r\nmutex_lock(&pnp_res_mutex);\r\npnp_clean_resource_table(dev);\r\nmutex_unlock(&pnp_res_mutex);\r\nreturn 0;\r\n}
