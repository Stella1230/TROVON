static struct lapbethdev *lapbeth_get_x25_dev(struct net_device *dev)\r\n{\r\nstruct lapbethdev *lapbeth;\r\nlist_for_each_entry_rcu(lapbeth, &lapbeth_devices, node) {\r\nif (lapbeth->ethdev == dev)\r\nreturn lapbeth;\r\n}\r\nreturn NULL;\r\n}\r\nstatic __inline__ int dev_is_ethdev(struct net_device *dev)\r\n{\r\nreturn dev->type == ARPHRD_ETHER && strncmp(dev->name, "dummy", 5);\r\n}\r\nstatic int lapbeth_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *ptype, struct net_device *orig_dev)\r\n{\r\nint len, err;\r\nstruct lapbethdev *lapbeth;\r\nif (dev_net(dev) != &init_net)\r\ngoto drop;\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\r\nreturn NET_RX_DROP;\r\nif (!pskb_may_pull(skb, 2))\r\ngoto drop;\r\nrcu_read_lock();\r\nlapbeth = lapbeth_get_x25_dev(dev);\r\nif (!lapbeth)\r\ngoto drop_unlock;\r\nif (!netif_running(lapbeth->axdev))\r\ngoto drop_unlock;\r\nlen = skb->data[0] + skb->data[1] * 256;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nskb_pull(skb, 2);\r\nskb_trim(skb, len);\r\nif ((err = lapb_data_received(lapbeth->axdev, skb)) != LAPB_OK) {\r\nprintk(KERN_DEBUG "lapbether: lapb_data_received err - %d\n", err);\r\ngoto drop_unlock;\r\n}\r\nout:\r\nrcu_read_unlock();\r\nreturn 0;\r\ndrop_unlock:\r\nkfree_skb(skb);\r\ngoto out;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int lapbeth_data_indication(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nunsigned char *ptr;\r\nskb_push(skb, 1);\r\nif (skb_cow(skb, 1))\r\nreturn NET_RX_DROP;\r\nptr = skb->data;\r\n*ptr = X25_IFACE_DATA;\r\nskb->protocol = x25_type_trans(skb, dev);\r\nreturn netif_rx(skb);\r\n}\r\nstatic netdev_tx_t lapbeth_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nint err;\r\nif (!netif_running(dev))\r\ngoto drop;\r\nswitch (skb->data[0]) {\r\ncase X25_IFACE_DATA:\r\nbreak;\r\ncase X25_IFACE_CONNECT:\r\nif ((err = lapb_connect_request(dev)) != LAPB_OK)\r\npr_err("lapb_connect_request error: %d\n", err);\r\ngoto drop;\r\ncase X25_IFACE_DISCONNECT:\r\nif ((err = lapb_disconnect_request(dev)) != LAPB_OK)\r\npr_err("lapb_disconnect_request err: %d\n", err);\r\ndefault:\r\ngoto drop;\r\n}\r\nskb_pull(skb, 1);\r\nif ((err = lapb_data_request(dev, skb)) != LAPB_OK) {\r\npr_err("lapb_data_request error - %d\n", err);\r\ngoto drop;\r\n}\r\nout:\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic void lapbeth_data_transmit(struct net_device *ndev, struct sk_buff *skb)\r\n{\r\nstruct lapbethdev *lapbeth = netdev_priv(ndev);\r\nunsigned char *ptr;\r\nstruct net_device *dev;\r\nint size = skb->len;\r\nskb->protocol = htons(ETH_P_X25);\r\nptr = skb_push(skb, 2);\r\n*ptr++ = size % 256;\r\n*ptr++ = size / 256;\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += size;\r\nskb->dev = dev = lapbeth->ethdev;\r\ndev_hard_header(skb, dev, ETH_P_DEC, bcast_addr, NULL, 0);\r\ndev_queue_xmit(skb);\r\n}\r\nstatic void lapbeth_connected(struct net_device *dev, int reason)\r\n{\r\nunsigned char *ptr;\r\nstruct sk_buff *skb = dev_alloc_skb(1);\r\nif (!skb) {\r\npr_err("out of memory\n");\r\nreturn;\r\n}\r\nptr = skb_put(skb, 1);\r\n*ptr = X25_IFACE_CONNECT;\r\nskb->protocol = x25_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\nstatic void lapbeth_disconnected(struct net_device *dev, int reason)\r\n{\r\nunsigned char *ptr;\r\nstruct sk_buff *skb = dev_alloc_skb(1);\r\nif (!skb) {\r\npr_err("out of memory\n");\r\nreturn;\r\n}\r\nptr = skb_put(skb, 1);\r\n*ptr = X25_IFACE_DISCONNECT;\r\nskb->protocol = x25_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\nstatic int lapbeth_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = addr;\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int lapbeth_open(struct net_device *dev)\r\n{\r\nint err;\r\nif ((err = lapb_register(dev, &lapbeth_callbacks)) != LAPB_OK) {\r\npr_err("lapb_register error: %d\n", err);\r\nreturn -ENODEV;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int lapbeth_close(struct net_device *dev)\r\n{\r\nint err;\r\nnetif_stop_queue(dev);\r\nif ((err = lapb_unregister(dev)) != LAPB_OK)\r\npr_err("lapb_unregister error: %d\n", err);\r\nreturn 0;\r\n}\r\nstatic void lapbeth_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &lapbeth_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->type = ARPHRD_X25;\r\ndev->hard_header_len = 3;\r\ndev->mtu = 1000;\r\ndev->addr_len = 0;\r\n}\r\nstatic int lapbeth_new_device(struct net_device *dev)\r\n{\r\nstruct net_device *ndev;\r\nstruct lapbethdev *lapbeth;\r\nint rc = -ENOMEM;\r\nASSERT_RTNL();\r\nndev = alloc_netdev(sizeof(*lapbeth), "lapb%d", NET_NAME_UNKNOWN,\r\nlapbeth_setup);\r\nif (!ndev)\r\ngoto out;\r\nlapbeth = netdev_priv(ndev);\r\nlapbeth->axdev = ndev;\r\ndev_hold(dev);\r\nlapbeth->ethdev = dev;\r\nrc = -EIO;\r\nif (register_netdevice(ndev))\r\ngoto fail;\r\nlist_add_rcu(&lapbeth->node, &lapbeth_devices);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nfail:\r\ndev_put(dev);\r\nfree_netdev(ndev);\r\nkfree(lapbeth);\r\ngoto out;\r\n}\r\nstatic void lapbeth_free_device(struct lapbethdev *lapbeth)\r\n{\r\ndev_put(lapbeth->ethdev);\r\nlist_del_rcu(&lapbeth->node);\r\nunregister_netdevice(lapbeth->axdev);\r\n}\r\nstatic int lapbeth_device_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct lapbethdev *lapbeth;\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (dev_net(dev) != &init_net)\r\nreturn NOTIFY_DONE;\r\nif (!dev_is_ethdev(dev))\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nif (lapbeth_get_x25_dev(dev) == NULL)\r\nlapbeth_new_device(dev);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nlapbeth = lapbeth_get_x25_dev(dev);\r\nif (lapbeth)\r\ndev_close(lapbeth->axdev);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nlapbeth = lapbeth_get_x25_dev(dev);\r\nif (lapbeth)\r\nlapbeth_free_device(lapbeth);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init lapbeth_init_driver(void)\r\n{\r\ndev_add_pack(&lapbeth_packet_type);\r\nregister_netdevice_notifier(&lapbeth_dev_notifier);\r\nprintk(banner);\r\nreturn 0;\r\n}\r\nstatic void __exit lapbeth_cleanup_driver(void)\r\n{\r\nstruct lapbethdev *lapbeth;\r\nstruct list_head *entry, *tmp;\r\ndev_remove_pack(&lapbeth_packet_type);\r\nunregister_netdevice_notifier(&lapbeth_dev_notifier);\r\nrtnl_lock();\r\nlist_for_each_safe(entry, tmp, &lapbeth_devices) {\r\nlapbeth = list_entry(entry, struct lapbethdev, node);\r\ndev_put(lapbeth->ethdev);\r\nunregister_netdevice(lapbeth->axdev);\r\n}\r\nrtnl_unlock();\r\n}
