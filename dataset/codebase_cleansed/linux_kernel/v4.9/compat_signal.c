static inline void sigset_to_sigset32(unsigned long *set64,\r\ncompat_sigset_word *set32)\r\n{\r\nset32[0] = (compat_sigset_word) set64[0];\r\nset32[1] = (compat_sigset_word)(set64[0] >> 32);\r\n}\r\nstatic inline void sigset32_to_sigset(compat_sigset_word *set32,\r\nunsigned long *set64)\r\n{\r\nset64[0] = (unsigned long) set32[0] | ((unsigned long) set32[1] << 32);\r\n}\r\nint copy_siginfo_to_user32(compat_siginfo_t __user *to, const siginfo_t *from)\r\n{\r\nint err;\r\nerr = __put_user(from->si_signo, &to->si_signo);\r\nerr |= __put_user(from->si_errno, &to->si_errno);\r\nerr |= __put_user((short)from->si_code, &to->si_code);\r\nif (from->si_code < 0)\r\nerr |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad, SI_PAD_SIZE);\r\nelse {\r\nswitch (from->si_code >> 16) {\r\ncase __SI_RT >> 16:\r\ncase __SI_MESGQ >> 16:\r\nerr |= __put_user(from->si_int, &to->si_int);\r\ncase __SI_KILL >> 16:\r\nerr |= __put_user(from->si_pid, &to->si_pid);\r\nerr |= __put_user(from->si_uid, &to->si_uid);\r\nbreak;\r\ncase __SI_CHLD >> 16:\r\nerr |= __put_user(from->si_pid, &to->si_pid);\r\nerr |= __put_user(from->si_uid, &to->si_uid);\r\nerr |= __put_user(from->si_utime, &to->si_utime);\r\nerr |= __put_user(from->si_stime, &to->si_stime);\r\nerr |= __put_user(from->si_status, &to->si_status);\r\nbreak;\r\ncase __SI_FAULT >> 16:\r\nerr |= __put_user((unsigned long) from->si_addr,\r\n&to->si_addr);\r\nbreak;\r\ncase __SI_POLL >> 16:\r\nerr |= __put_user(from->si_band, &to->si_band);\r\nerr |= __put_user(from->si_fd, &to->si_fd);\r\nbreak;\r\ncase __SI_TIMER >> 16:\r\nerr |= __put_user(from->si_tid, &to->si_tid);\r\nerr |= __put_user(from->si_overrun, &to->si_overrun);\r\nerr |= __put_user(from->si_int, &to->si_int);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn err ? -EFAULT : 0;\r\n}\r\nint copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)\r\n{\r\nint err;\r\nu32 tmp;\r\nerr = __get_user(to->si_signo, &from->si_signo);\r\nerr |= __get_user(to->si_errno, &from->si_errno);\r\nerr |= __get_user(to->si_code, &from->si_code);\r\nif (to->si_code < 0)\r\nerr |= __copy_from_user(&to->_sifields._pad, &from->_sifields._pad, SI_PAD_SIZE);\r\nelse {\r\nswitch (to->si_code >> 16) {\r\ncase __SI_RT >> 16:\r\ncase __SI_MESGQ >> 16:\r\nerr |= __get_user(to->si_int, &from->si_int);\r\ncase __SI_KILL >> 16:\r\nerr |= __get_user(to->si_pid, &from->si_pid);\r\nerr |= __get_user(to->si_uid, &from->si_uid);\r\nbreak;\r\ncase __SI_CHLD >> 16:\r\nerr |= __get_user(to->si_pid, &from->si_pid);\r\nerr |= __get_user(to->si_uid, &from->si_uid);\r\nerr |= __get_user(to->si_utime, &from->si_utime);\r\nerr |= __get_user(to->si_stime, &from->si_stime);\r\nerr |= __get_user(to->si_status, &from->si_status);\r\nbreak;\r\ncase __SI_FAULT >> 16:\r\nerr |= __get_user(tmp, &from->si_addr);\r\nto->si_addr = (void __force __user *)\r\n(u64) (tmp & PSW32_ADDR_INSN);\r\nbreak;\r\ncase __SI_POLL >> 16:\r\nerr |= __get_user(to->si_band, &from->si_band);\r\nerr |= __get_user(to->si_fd, &from->si_fd);\r\nbreak;\r\ncase __SI_TIMER >> 16:\r\nerr |= __get_user(to->si_tid, &from->si_tid);\r\nerr |= __get_user(to->si_overrun, &from->si_overrun);\r\nerr |= __get_user(to->si_int, &from->si_int);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn err ? -EFAULT : 0;\r\n}\r\nstatic void store_sigregs(void)\r\n{\r\nsave_access_regs(current->thread.acrs);\r\nsave_fpu_regs();\r\n}\r\nstatic void load_sigregs(void)\r\n{\r\nrestore_access_regs(current->thread.acrs);\r\n}\r\nstatic int save_sigregs32(struct pt_regs *regs, _sigregs32 __user *sregs)\r\n{\r\n_sigregs32 user_sregs;\r\nint i;\r\nuser_sregs.regs.psw.mask = (__u32)(regs->psw.mask >> 32);\r\nuser_sregs.regs.psw.mask &= PSW32_MASK_USER | PSW32_MASK_RI;\r\nuser_sregs.regs.psw.mask |= PSW32_USER_BITS;\r\nuser_sregs.regs.psw.addr = (__u32) regs->psw.addr |\r\n(__u32)(regs->psw.mask & PSW_MASK_BA);\r\nfor (i = 0; i < NUM_GPRS; i++)\r\nuser_sregs.regs.gprs[i] = (__u32) regs->gprs[i];\r\nmemcpy(&user_sregs.regs.acrs, current->thread.acrs,\r\nsizeof(user_sregs.regs.acrs));\r\nfpregs_store((_s390_fp_regs *) &user_sregs.fpregs, &current->thread.fpu);\r\nif (__copy_to_user(sregs, &user_sregs, sizeof(_sigregs32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int restore_sigregs32(struct pt_regs *regs,_sigregs32 __user *sregs)\r\n{\r\n_sigregs32 user_sregs;\r\nint i;\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nif (__copy_from_user(&user_sregs, &sregs->regs, sizeof(user_sregs)))\r\nreturn -EFAULT;\r\nif (!is_ri_task(current) && (user_sregs.regs.psw.mask & PSW32_MASK_RI))\r\nreturn -EINVAL;\r\nif (test_fp_ctl(user_sregs.fpregs.fpc))\r\nreturn -EINVAL;\r\nregs->psw.mask = (regs->psw.mask & ~(PSW_MASK_USER | PSW_MASK_RI)) |\r\n(__u64)(user_sregs.regs.psw.mask & PSW32_MASK_USER) << 32 |\r\n(__u64)(user_sregs.regs.psw.mask & PSW32_MASK_RI) << 32 |\r\n(__u64)(user_sregs.regs.psw.addr & PSW32_ADDR_AMODE);\r\nif ((regs->psw.mask & PSW_MASK_ASC) == PSW_ASC_HOME)\r\nregs->psw.mask = PSW_ASC_PRIMARY |\r\n(regs->psw.mask & ~PSW_MASK_ASC);\r\nregs->psw.addr = (__u64)(user_sregs.regs.psw.addr & PSW32_ADDR_INSN);\r\nfor (i = 0; i < NUM_GPRS; i++)\r\nregs->gprs[i] = (__u64) user_sregs.regs.gprs[i];\r\nmemcpy(&current->thread.acrs, &user_sregs.regs.acrs,\r\nsizeof(current->thread.acrs));\r\nfpregs_load((_s390_fp_regs *) &user_sregs.fpregs, &current->thread.fpu);\r\nclear_pt_regs_flag(regs, PIF_SYSCALL);\r\nreturn 0;\r\n}\r\nstatic int save_sigregs_ext32(struct pt_regs *regs,\r\n_sigregs_ext32 __user *sregs_ext)\r\n{\r\n__u32 gprs_high[NUM_GPRS];\r\n__u64 vxrs[__NUM_VXRS_LOW];\r\nint i;\r\nfor (i = 0; i < NUM_GPRS; i++)\r\ngprs_high[i] = regs->gprs[i] >> 32;\r\nif (__copy_to_user(&sregs_ext->gprs_high, &gprs_high,\r\nsizeof(sregs_ext->gprs_high)))\r\nreturn -EFAULT;\r\nif (MACHINE_HAS_VX) {\r\nfor (i = 0; i < __NUM_VXRS_LOW; i++)\r\nvxrs[i] = *((__u64 *)(current->thread.fpu.vxrs + i) + 1);\r\nif (__copy_to_user(&sregs_ext->vxrs_low, vxrs,\r\nsizeof(sregs_ext->vxrs_low)) ||\r\n__copy_to_user(&sregs_ext->vxrs_high,\r\ncurrent->thread.fpu.vxrs + __NUM_VXRS_LOW,\r\nsizeof(sregs_ext->vxrs_high)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int restore_sigregs_ext32(struct pt_regs *regs,\r\n_sigregs_ext32 __user *sregs_ext)\r\n{\r\n__u32 gprs_high[NUM_GPRS];\r\n__u64 vxrs[__NUM_VXRS_LOW];\r\nint i;\r\nif (__copy_from_user(&gprs_high, &sregs_ext->gprs_high,\r\nsizeof(sregs_ext->gprs_high)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < NUM_GPRS; i++)\r\n*(__u32 *)&regs->gprs[i] = gprs_high[i];\r\nif (MACHINE_HAS_VX) {\r\nif (__copy_from_user(vxrs, &sregs_ext->vxrs_low,\r\nsizeof(sregs_ext->vxrs_low)) ||\r\n__copy_from_user(current->thread.fpu.vxrs + __NUM_VXRS_LOW,\r\n&sregs_ext->vxrs_high,\r\nsizeof(sregs_ext->vxrs_high)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < __NUM_VXRS_LOW; i++)\r\n*((__u64 *)(current->thread.fpu.vxrs + i) + 1) = vxrs[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void __user *\r\nget_sigframe(struct k_sigaction *ka, struct pt_regs * regs, size_t frame_size)\r\n{\r\nunsigned long sp;\r\nsp = (unsigned long) A(regs->gprs[15]);\r\nif (on_sig_stack(sp) && !on_sig_stack((sp - frame_size) & -8UL))\r\nreturn (void __user *) -1UL;\r\nif (ka->sa.sa_flags & SA_ONSTACK) {\r\nif (! sas_ss_flags(sp))\r\nsp = current->sas_ss_sp + current->sas_ss_size;\r\n}\r\nreturn (void __user *)((sp - frame_size) & -8ul);\r\n}\r\nstatic int setup_frame32(struct ksignal *ksig, sigset_t *set,\r\nstruct pt_regs *regs)\r\n{\r\nint sig = ksig->sig;\r\nsigframe32 __user *frame;\r\nstruct sigcontext32 sc;\r\nunsigned long restorer;\r\nsize_t frame_size;\r\nframe_size = sizeof(*frame) - sizeof(frame->sregs_ext.__reserved);\r\nif (!MACHINE_HAS_VX)\r\nframe_size -= sizeof(frame->sregs_ext.vxrs_low) +\r\nsizeof(frame->sregs_ext.vxrs_high);\r\nframe = get_sigframe(&ksig->ka, regs, frame_size);\r\nif (frame == (void __user *) -1UL)\r\nreturn -EFAULT;\r\nif (__put_user(regs->gprs[15], (unsigned int __user *) frame))\r\nreturn -EFAULT;\r\nsigset_to_sigset32(set->sig, sc.oldmask);\r\nsc.sregs = (__u32)(unsigned long __force) &frame->sregs;\r\nif (__copy_to_user(&frame->sc, &sc, sizeof(frame->sc)))\r\nreturn -EFAULT;\r\nstore_sigregs();\r\nif (save_sigregs32(regs, &frame->sregs))\r\nreturn -EFAULT;\r\nif (__put_user(regs->gprs[2], (int __force __user *) &frame->signo))\r\nreturn -EFAULT;\r\nif (save_sigregs_ext32(regs, &frame->sregs_ext))\r\nreturn -EFAULT;\r\nif (ksig->ka.sa.sa_flags & SA_RESTORER) {\r\nrestorer = (unsigned long __force)\r\nksig->ka.sa.sa_restorer | PSW32_ADDR_AMODE;\r\n} else {\r\n__u16 __user *svc = (void __user *) frame + frame_size - 2;\r\nif (__put_user(S390_SYSCALL_OPCODE | __NR_sigreturn, svc))\r\nreturn -EFAULT;\r\nrestorer = (unsigned long __force) svc | PSW32_ADDR_AMODE;\r\n}\r\nregs->gprs[14] = restorer;\r\nregs->gprs[15] = (__force __u64) frame;\r\nregs->psw.mask = PSW_MASK_BA |\r\n(PSW_USER_BITS & PSW_MASK_ASC) |\r\n(regs->psw.mask & ~PSW_MASK_ASC);\r\nregs->psw.addr = (__force __u64) ksig->ka.sa.sa_handler;\r\nregs->gprs[2] = sig;\r\nregs->gprs[3] = (__force __u64) &frame->sc;\r\nif (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\r\nsig == SIGTRAP || sig == SIGFPE) {\r\nregs->gprs[4] = regs->int_code & 127;\r\nregs->gprs[5] = regs->int_parm_long;\r\nregs->gprs[6] = task_thread_info(current)->last_break;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_rt_frame32(struct ksignal *ksig, sigset_t *set,\r\nstruct pt_regs *regs)\r\n{\r\ncompat_sigset_t cset;\r\nrt_sigframe32 __user *frame;\r\nunsigned long restorer;\r\nsize_t frame_size;\r\nu32 uc_flags;\r\nframe_size = sizeof(*frame) -\r\nsizeof(frame->uc.uc_mcontext_ext.__reserved);\r\nuc_flags = UC_GPRS_HIGH;\r\nif (MACHINE_HAS_VX) {\r\nuc_flags |= UC_VXRS;\r\n} else\r\nframe_size -= sizeof(frame->uc.uc_mcontext_ext.vxrs_low) +\r\nsizeof(frame->uc.uc_mcontext_ext.vxrs_high);\r\nframe = get_sigframe(&ksig->ka, regs, frame_size);\r\nif (frame == (void __user *) -1UL)\r\nreturn -EFAULT;\r\nif (__put_user(regs->gprs[15], (unsigned int __force __user *) frame))\r\nreturn -EFAULT;\r\nif (ksig->ka.sa.sa_flags & SA_RESTORER) {\r\nrestorer = (unsigned long __force)\r\nksig->ka.sa.sa_restorer | PSW32_ADDR_AMODE;\r\n} else {\r\n__u16 __user *svc = &frame->svc_insn;\r\nif (__put_user(S390_SYSCALL_OPCODE | __NR_rt_sigreturn, svc))\r\nreturn -EFAULT;\r\nrestorer = (unsigned long __force) svc | PSW32_ADDR_AMODE;\r\n}\r\nif (copy_siginfo_to_user32(&frame->info, &ksig->info))\r\nreturn -EFAULT;\r\nstore_sigregs();\r\nsigset_to_sigset32(set->sig, cset.sig);\r\nif (__put_user(uc_flags, &frame->uc.uc_flags) ||\r\n__put_user(0, &frame->uc.uc_link) ||\r\n__compat_save_altstack(&frame->uc.uc_stack, regs->gprs[15]) ||\r\nsave_sigregs32(regs, &frame->uc.uc_mcontext) ||\r\n__copy_to_user(&frame->uc.uc_sigmask, &cset, sizeof(cset)) ||\r\nsave_sigregs_ext32(regs, &frame->uc.uc_mcontext_ext))\r\nreturn -EFAULT;\r\nregs->gprs[14] = restorer;\r\nregs->gprs[15] = (__force __u64) frame;\r\nregs->psw.mask = PSW_MASK_BA |\r\n(PSW_USER_BITS & PSW_MASK_ASC) |\r\n(regs->psw.mask & ~PSW_MASK_ASC);\r\nregs->psw.addr = (__u64 __force) ksig->ka.sa.sa_handler;\r\nregs->gprs[2] = ksig->sig;\r\nregs->gprs[3] = (__force __u64) &frame->info;\r\nregs->gprs[4] = (__force __u64) &frame->uc;\r\nregs->gprs[5] = task_thread_info(current)->last_break;\r\nreturn 0;\r\n}\r\nvoid handle_signal32(struct ksignal *ksig, sigset_t *oldset,\r\nstruct pt_regs *regs)\r\n{\r\nint ret;\r\nif (ksig->ka.sa.sa_flags & SA_SIGINFO)\r\nret = setup_rt_frame32(ksig, oldset, regs);\r\nelse\r\nret = setup_frame32(ksig, oldset, regs);\r\nsignal_setup_done(ret, ksig, test_thread_flag(TIF_SINGLE_STEP));\r\n}
