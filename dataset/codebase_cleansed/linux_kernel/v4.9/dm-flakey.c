static int parse_features(struct dm_arg_set *as, struct flakey_c *fc,\r\nstruct dm_target *ti)\r\n{\r\nint r;\r\nunsigned argc;\r\nconst char *arg_name;\r\nstatic struct dm_arg _args[] = {\r\n{0, 6, "Invalid number of feature args"},\r\n{1, UINT_MAX, "Invalid corrupt bio byte"},\r\n{0, 255, "Invalid corrupt value to write into bio byte (0-255)"},\r\n{0, UINT_MAX, "Invalid corrupt bio flags mask"},\r\n};\r\nif (!as->argc)\r\nreturn 0;\r\nr = dm_read_arg_group(_args, as, &argc, &ti->error);\r\nif (r)\r\nreturn r;\r\nwhile (argc) {\r\narg_name = dm_shift_arg(as);\r\nargc--;\r\nif (!strcasecmp(arg_name, "drop_writes")) {\r\nif (test_and_set_bit(DROP_WRITES, &fc->flags)) {\r\nti->error = "Feature drop_writes duplicated";\r\nreturn -EINVAL;\r\n}\r\ncontinue;\r\n}\r\nif (!strcasecmp(arg_name, "corrupt_bio_byte")) {\r\nif (!argc) {\r\nti->error = "Feature corrupt_bio_byte requires parameters";\r\nreturn -EINVAL;\r\n}\r\nr = dm_read_arg(_args + 1, as, &fc->corrupt_bio_byte, &ti->error);\r\nif (r)\r\nreturn r;\r\nargc--;\r\narg_name = dm_shift_arg(as);\r\nif (!strcasecmp(arg_name, "w"))\r\nfc->corrupt_bio_rw = WRITE;\r\nelse if (!strcasecmp(arg_name, "r"))\r\nfc->corrupt_bio_rw = READ;\r\nelse {\r\nti->error = "Invalid corrupt bio direction (r or w)";\r\nreturn -EINVAL;\r\n}\r\nargc--;\r\nr = dm_read_arg(_args + 2, as, &fc->corrupt_bio_value, &ti->error);\r\nif (r)\r\nreturn r;\r\nargc--;\r\nr = dm_read_arg(_args + 3, as, &fc->corrupt_bio_flags, &ti->error);\r\nif (r)\r\nreturn r;\r\nargc--;\r\ncontinue;\r\n}\r\nti->error = "Unrecognised flakey feature requested";\r\nreturn -EINVAL;\r\n}\r\nif (test_bit(DROP_WRITES, &fc->flags) && (fc->corrupt_bio_rw == WRITE)) {\r\nti->error = "drop_writes is incompatible with corrupt_bio_byte with the WRITE flag set";\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flakey_ctr(struct dm_target *ti, unsigned int argc, char **argv)\r\n{\r\nstatic struct dm_arg _args[] = {\r\n{0, UINT_MAX, "Invalid up interval"},\r\n{0, UINT_MAX, "Invalid down interval"},\r\n};\r\nint r;\r\nstruct flakey_c *fc;\r\nunsigned long long tmpll;\r\nstruct dm_arg_set as;\r\nconst char *devname;\r\nchar dummy;\r\nas.argc = argc;\r\nas.argv = argv;\r\nif (argc < 4) {\r\nti->error = "Invalid argument count";\r\nreturn -EINVAL;\r\n}\r\nfc = kzalloc(sizeof(*fc), GFP_KERNEL);\r\nif (!fc) {\r\nti->error = "Cannot allocate context";\r\nreturn -ENOMEM;\r\n}\r\nfc->start_time = jiffies;\r\ndevname = dm_shift_arg(&as);\r\nr = -EINVAL;\r\nif (sscanf(dm_shift_arg(&as), "%llu%c", &tmpll, &dummy) != 1) {\r\nti->error = "Invalid device sector";\r\ngoto bad;\r\n}\r\nfc->start = tmpll;\r\nr = dm_read_arg(_args, &as, &fc->up_interval, &ti->error);\r\nif (r)\r\ngoto bad;\r\nr = dm_read_arg(_args, &as, &fc->down_interval, &ti->error);\r\nif (r)\r\ngoto bad;\r\nif (!(fc->up_interval + fc->down_interval)) {\r\nti->error = "Total (up + down) interval is zero";\r\ngoto bad;\r\n}\r\nif (fc->up_interval + fc->down_interval < fc->up_interval) {\r\nti->error = "Interval overflow";\r\ngoto bad;\r\n}\r\nr = parse_features(&as, fc, ti);\r\nif (r)\r\ngoto bad;\r\nr = dm_get_device(ti, devname, dm_table_get_mode(ti->table), &fc->dev);\r\nif (r) {\r\nti->error = "Device lookup failed";\r\ngoto bad;\r\n}\r\nti->num_flush_bios = 1;\r\nti->num_discard_bios = 1;\r\nti->per_io_data_size = sizeof(struct per_bio_data);\r\nti->private = fc;\r\nreturn 0;\r\nbad:\r\nkfree(fc);\r\nreturn r;\r\n}\r\nstatic void flakey_dtr(struct dm_target *ti)\r\n{\r\nstruct flakey_c *fc = ti->private;\r\ndm_put_device(ti, fc->dev);\r\nkfree(fc);\r\n}\r\nstatic sector_t flakey_map_sector(struct dm_target *ti, sector_t bi_sector)\r\n{\r\nstruct flakey_c *fc = ti->private;\r\nreturn fc->start + dm_target_offset(ti, bi_sector);\r\n}\r\nstatic void flakey_map_bio(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct flakey_c *fc = ti->private;\r\nbio->bi_bdev = fc->dev->bdev;\r\nif (bio_sectors(bio))\r\nbio->bi_iter.bi_sector =\r\nflakey_map_sector(ti, bio->bi_iter.bi_sector);\r\n}\r\nstatic void corrupt_bio_data(struct bio *bio, struct flakey_c *fc)\r\n{\r\nunsigned bio_bytes = bio_cur_bytes(bio);\r\nchar *data = bio_data(bio);\r\nif (data && bio_bytes >= fc->corrupt_bio_byte) {\r\ndata[fc->corrupt_bio_byte - 1] = fc->corrupt_bio_value;\r\nDMDEBUG("Corrupting data bio=%p by writing %u to byte %u "\r\n"(rw=%c bi_opf=%u bi_sector=%llu cur_bytes=%u)\n",\r\nbio, fc->corrupt_bio_value, fc->corrupt_bio_byte,\r\n(bio_data_dir(bio) == WRITE) ? 'w' : 'r', bio->bi_opf,\r\n(unsigned long long)bio->bi_iter.bi_sector, bio_bytes);\r\n}\r\n}\r\nstatic int flakey_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct flakey_c *fc = ti->private;\r\nunsigned elapsed;\r\nstruct per_bio_data *pb = dm_per_bio_data(bio, sizeof(struct per_bio_data));\r\npb->bio_submitted = false;\r\nelapsed = (jiffies - fc->start_time) / HZ;\r\nif (elapsed % (fc->up_interval + fc->down_interval) >= fc->up_interval) {\r\npb->bio_submitted = true;\r\nif (bio_data_dir(bio) == READ) {\r\nif (!fc->corrupt_bio_byte && !test_bit(DROP_WRITES, &fc->flags))\r\nreturn -EIO;\r\ngoto map_bio;\r\n}\r\nif (test_bit(DROP_WRITES, &fc->flags)) {\r\nbio_endio(bio);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\nif (fc->corrupt_bio_byte && (fc->corrupt_bio_rw == WRITE)) {\r\nif (all_corrupt_bio_flags_match(bio, fc))\r\ncorrupt_bio_data(bio, fc);\r\ngoto map_bio;\r\n}\r\nreturn -EIO;\r\n}\r\nmap_bio:\r\nflakey_map_bio(ti, bio);\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nstatic int flakey_end_io(struct dm_target *ti, struct bio *bio, int error)\r\n{\r\nstruct flakey_c *fc = ti->private;\r\nstruct per_bio_data *pb = dm_per_bio_data(bio, sizeof(struct per_bio_data));\r\nif (!error && pb->bio_submitted && (bio_data_dir(bio) == READ)) {\r\nif (fc->corrupt_bio_byte && (fc->corrupt_bio_rw == READ) &&\r\nall_corrupt_bio_flags_match(bio, fc)) {\r\ncorrupt_bio_data(bio, fc);\r\n} else if (!test_bit(DROP_WRITES, &fc->flags)) {\r\nreturn -EIO;\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic void flakey_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nunsigned sz = 0;\r\nstruct flakey_c *fc = ti->private;\r\nunsigned drop_writes;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nresult[0] = '\0';\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%s %llu %u %u ", fc->dev->name,\r\n(unsigned long long)fc->start, fc->up_interval,\r\nfc->down_interval);\r\ndrop_writes = test_bit(DROP_WRITES, &fc->flags);\r\nDMEMIT("%u ", drop_writes + (fc->corrupt_bio_byte > 0) * 5);\r\nif (drop_writes)\r\nDMEMIT("drop_writes ");\r\nif (fc->corrupt_bio_byte)\r\nDMEMIT("corrupt_bio_byte %u %c %u %u ",\r\nfc->corrupt_bio_byte,\r\n(fc->corrupt_bio_rw == WRITE) ? 'w' : 'r',\r\nfc->corrupt_bio_value, fc->corrupt_bio_flags);\r\nbreak;\r\n}\r\n}\r\nstatic int flakey_prepare_ioctl(struct dm_target *ti,\r\nstruct block_device **bdev, fmode_t *mode)\r\n{\r\nstruct flakey_c *fc = ti->private;\r\n*bdev = fc->dev->bdev;\r\nif (fc->start ||\r\nti->len != i_size_read((*bdev)->bd_inode) >> SECTOR_SHIFT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int flakey_iterate_devices(struct dm_target *ti, iterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct flakey_c *fc = ti->private;\r\nreturn fn(ti, fc->dev, fc->start, ti->len, data);\r\n}\r\nstatic int __init dm_flakey_init(void)\r\n{\r\nint r = dm_register_target(&flakey_target);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nreturn r;\r\n}\r\nstatic void __exit dm_flakey_exit(void)\r\n{\r\ndm_unregister_target(&flakey_target);\r\n}
