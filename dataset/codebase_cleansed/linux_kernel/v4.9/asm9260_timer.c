static int asm9260_timer_set_next_event(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\nwritel_relaxed(delta, priv.base + HW_MR0);\r\nwritel_relaxed(BM_C0_EN, priv.base + HW_TCR + SET_REG);\r\nreturn 0;\r\n}\r\nstatic inline void __asm9260_timer_shutdown(struct clock_event_device *evt)\r\n{\r\nwritel_relaxed(BM_C0_EN, priv.base + HW_TCR + CLR_REG);\r\n}\r\nstatic int asm9260_timer_shutdown(struct clock_event_device *evt)\r\n{\r\n__asm9260_timer_shutdown(evt);\r\nreturn 0;\r\n}\r\nstatic int asm9260_timer_set_oneshot(struct clock_event_device *evt)\r\n{\r\n__asm9260_timer_shutdown(evt);\r\nwritel_relaxed(BM_MCR_RES_EN(0) | BM_MCR_STOP_EN(0),\r\npriv.base + HW_MCR + SET_REG);\r\nreturn 0;\r\n}\r\nstatic int asm9260_timer_set_periodic(struct clock_event_device *evt)\r\n{\r\n__asm9260_timer_shutdown(evt);\r\nwritel_relaxed(BM_MCR_RES_EN(0) | BM_MCR_STOP_EN(0),\r\npriv.base + HW_MCR + CLR_REG);\r\nwritel_relaxed(priv.ticks_per_jiffy, priv.base + HW_MR0);\r\nwritel_relaxed(BM_C0_EN, priv.base + HW_TCR + SET_REG);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t asm9260_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nevt->event_handler(evt);\r\nwritel_relaxed(BM_IR_MR0, priv.base + HW_IR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init asm9260_timer_init(struct device_node *np)\r\n{\r\nint irq;\r\nstruct clk *clk;\r\nint ret;\r\nunsigned long rate;\r\npriv.base = of_io_request_and_map(np, 0, np->name);\r\nif (IS_ERR(priv.base)) {\r\npr_err("%s: unable to map resource", np->name);\r\nreturn PTR_ERR(priv.base);\r\n}\r\nclk = of_clk_get(np, 0);\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("Failed to enable clk!\n");\r\nreturn ret;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nret = request_irq(irq, asm9260_timer_interrupt, IRQF_TIMER,\r\nDRIVER_NAME, &event_dev);\r\nif (ret) {\r\npr_err("Failed to setup irq!\n");\r\nreturn ret;\r\n}\r\nwritel_relaxed(BM_DIR_DEFAULT, priv.base + HW_DIR);\r\nwritel_relaxed(BM_PR_DISABLE, priv.base + HW_PR);\r\nwritel_relaxed(BM_CTCR_DEFAULT, priv.base + HW_CTCR);\r\nwritel_relaxed(BM_MCR_INT_EN(0) , priv.base + HW_MCR);\r\nrate = clk_get_rate(clk);\r\nclocksource_mmio_init(priv.base + HW_TC1, DRIVER_NAME, rate,\r\n200, 32, clocksource_mmio_readl_up);\r\nwritel_relaxed(0xffffffff, priv.base + HW_MR1);\r\nwritel_relaxed(BM_C1_EN, priv.base + HW_TCR + SET_REG);\r\npriv.ticks_per_jiffy = DIV_ROUND_CLOSEST(rate, HZ);\r\nevent_dev.cpumask = cpumask_of(0);\r\nclockevents_config_and_register(&event_dev, rate, 0x2c00, 0xfffffffe);\r\nreturn 0;\r\n}
