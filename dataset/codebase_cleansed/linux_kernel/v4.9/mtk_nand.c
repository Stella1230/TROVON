static inline struct mtk_nfc_nand_chip *to_mtk_nand(struct nand_chip *nand)\r\n{\r\nreturn container_of(nand, struct mtk_nfc_nand_chip, nand);\r\n}\r\nstatic inline u8 *data_ptr(struct nand_chip *chip, const u8 *p, int i)\r\n{\r\nreturn (u8 *)p + i * chip->ecc.size;\r\n}\r\nstatic inline u8 *oob_ptr(struct nand_chip *chip, int i)\r\n{\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nu8 *poi;\r\nif (i < mtk_nand->bad_mark.sec)\r\npoi = chip->oob_poi + (i + 1) * mtk_nand->fdm.reg_size;\r\nelse if (i == mtk_nand->bad_mark.sec)\r\npoi = chip->oob_poi;\r\nelse\r\npoi = chip->oob_poi + i * mtk_nand->fdm.reg_size;\r\nreturn poi;\r\n}\r\nstatic inline int mtk_data_len(struct nand_chip *chip)\r\n{\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nreturn chip->ecc.size + mtk_nand->spare_per_sector;\r\n}\r\nstatic inline u8 *mtk_data_ptr(struct nand_chip *chip, int i)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nreturn nfc->buffer + i * mtk_data_len(chip);\r\n}\r\nstatic inline u8 *mtk_oob_ptr(struct nand_chip *chip, int i)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nreturn nfc->buffer + i * mtk_data_len(chip) + chip->ecc.size;\r\n}\r\nstatic inline void nfi_writel(struct mtk_nfc *nfc, u32 val, u32 reg)\r\n{\r\nwritel(val, nfc->regs + reg);\r\n}\r\nstatic inline void nfi_writew(struct mtk_nfc *nfc, u16 val, u32 reg)\r\n{\r\nwritew(val, nfc->regs + reg);\r\n}\r\nstatic inline void nfi_writeb(struct mtk_nfc *nfc, u8 val, u32 reg)\r\n{\r\nwriteb(val, nfc->regs + reg);\r\n}\r\nstatic inline u32 nfi_readl(struct mtk_nfc *nfc, u32 reg)\r\n{\r\nreturn readl_relaxed(nfc->regs + reg);\r\n}\r\nstatic inline u16 nfi_readw(struct mtk_nfc *nfc, u32 reg)\r\n{\r\nreturn readw_relaxed(nfc->regs + reg);\r\n}\r\nstatic inline u8 nfi_readb(struct mtk_nfc *nfc, u32 reg)\r\n{\r\nreturn readb_relaxed(nfc->regs + reg);\r\n}\r\nstatic void mtk_nfc_hw_reset(struct mtk_nfc *nfc)\r\n{\r\nstruct device *dev = nfc->dev;\r\nu32 val;\r\nint ret;\r\nnfi_writel(nfc, CON_FIFO_FLUSH | CON_NFI_RST, NFI_CON);\r\nret = readl_poll_timeout(nfc->regs + NFI_MASTER_STA, val,\r\n!(val & MASTER_STA_MASK), 50,\r\nMTK_RESET_TIMEOUT);\r\nif (ret)\r\ndev_warn(dev, "master active in reset [0x%x] = 0x%x\n",\r\nNFI_MASTER_STA, val);\r\nnfi_writel(nfc, CON_FIFO_FLUSH | CON_NFI_RST, NFI_CON);\r\nnfi_writew(nfc, STAR_DE, NFI_STRDATA);\r\n}\r\nstatic int mtk_nfc_send_command(struct mtk_nfc *nfc, u8 command)\r\n{\r\nstruct device *dev = nfc->dev;\r\nu32 val;\r\nint ret;\r\nnfi_writel(nfc, command, NFI_CMD);\r\nret = readl_poll_timeout_atomic(nfc->regs + NFI_STA, val,\r\n!(val & STA_CMD), 10, MTK_TIMEOUT);\r\nif (ret) {\r\ndev_warn(dev, "nfi core timed out entering command mode\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_nfc_send_address(struct mtk_nfc *nfc, int addr)\r\n{\r\nstruct device *dev = nfc->dev;\r\nu32 val;\r\nint ret;\r\nnfi_writel(nfc, addr, NFI_COLADDR);\r\nnfi_writel(nfc, 0, NFI_ROWADDR);\r\nnfi_writew(nfc, 1, NFI_ADDRNOB);\r\nret = readl_poll_timeout_atomic(nfc->regs + NFI_STA, val,\r\n!(val & STA_ADDR), 10, MTK_TIMEOUT);\r\nif (ret) {\r\ndev_warn(dev, "nfi core timed out entering address mode\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_nfc_hw_runtime_config(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nu32 fmt, spare;\r\nif (!mtd->writesize)\r\nreturn 0;\r\nspare = mtk_nand->spare_per_sector;\r\nswitch (mtd->writesize) {\r\ncase 512:\r\nfmt = PAGEFMT_512_2K | PAGEFMT_SEC_SEL_512;\r\nbreak;\r\ncase KB(2):\r\nif (chip->ecc.size == 512)\r\nfmt = PAGEFMT_2K_4K | PAGEFMT_SEC_SEL_512;\r\nelse\r\nfmt = PAGEFMT_512_2K;\r\nbreak;\r\ncase KB(4):\r\nif (chip->ecc.size == 512)\r\nfmt = PAGEFMT_4K_8K | PAGEFMT_SEC_SEL_512;\r\nelse\r\nfmt = PAGEFMT_2K_4K;\r\nbreak;\r\ncase KB(8):\r\nif (chip->ecc.size == 512)\r\nfmt = PAGEFMT_8K_16K | PAGEFMT_SEC_SEL_512;\r\nelse\r\nfmt = PAGEFMT_4K_8K;\r\nbreak;\r\ncase KB(16):\r\nfmt = PAGEFMT_8K_16K;\r\nbreak;\r\ndefault:\r\ndev_err(nfc->dev, "invalid page len: %d\n", mtd->writesize);\r\nreturn -EINVAL;\r\n}\r\nif (chip->ecc.size == 1024)\r\nspare >>= 1;\r\nswitch (spare) {\r\ncase 16:\r\nfmt |= (PAGEFMT_SPARE_16 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 26:\r\nfmt |= (PAGEFMT_SPARE_26 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 27:\r\nfmt |= (PAGEFMT_SPARE_27 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 28:\r\nfmt |= (PAGEFMT_SPARE_28 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 32:\r\nfmt |= (PAGEFMT_SPARE_32 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 36:\r\nfmt |= (PAGEFMT_SPARE_36 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 40:\r\nfmt |= (PAGEFMT_SPARE_40 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 44:\r\nfmt |= (PAGEFMT_SPARE_44 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 48:\r\nfmt |= (PAGEFMT_SPARE_48 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 49:\r\nfmt |= (PAGEFMT_SPARE_49 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 50:\r\nfmt |= (PAGEFMT_SPARE_50 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 51:\r\nfmt |= (PAGEFMT_SPARE_51 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 52:\r\nfmt |= (PAGEFMT_SPARE_52 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 62:\r\nfmt |= (PAGEFMT_SPARE_62 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 63:\r\nfmt |= (PAGEFMT_SPARE_63 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ncase 64:\r\nfmt |= (PAGEFMT_SPARE_64 << PAGEFMT_SPARE_SHIFT);\r\nbreak;\r\ndefault:\r\ndev_err(nfc->dev, "invalid spare per sector %d\n", spare);\r\nreturn -EINVAL;\r\n}\r\nfmt |= mtk_nand->fdm.reg_size << PAGEFMT_FDM_SHIFT;\r\nfmt |= mtk_nand->fdm.ecc_size << PAGEFMT_FDM_ECC_SHIFT;\r\nnfi_writew(nfc, fmt, NFI_PAGEFMT);\r\nnfc->ecc_cfg.strength = chip->ecc.strength;\r\nnfc->ecc_cfg.len = chip->ecc.size + mtk_nand->fdm.ecc_size;\r\nreturn 0;\r\n}\r\nstatic void mtk_nfc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand = mtd_to_nand(mtd);\r\nstruct mtk_nfc *nfc = nand_get_controller_data(nand);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(nand);\r\nif (chip < 0)\r\nreturn;\r\nmtk_nfc_hw_runtime_config(mtd);\r\nnfi_writel(nfc, mtk_nand->sels[chip], NFI_CSEL);\r\n}\r\nstatic int mtk_nfc_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(mtd_to_nand(mtd));\r\nif (nfi_readl(nfc, NFI_STA) & STA_BUSY)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void mtk_nfc_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned int ctrl)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(mtd_to_nand(mtd));\r\nif (ctrl & NAND_ALE) {\r\nmtk_nfc_send_address(nfc, dat);\r\n} else if (ctrl & NAND_CLE) {\r\nmtk_nfc_hw_reset(nfc);\r\nnfi_writew(nfc, CNFG_OP_CUST, NFI_CNFG);\r\nmtk_nfc_send_command(nfc, dat);\r\n}\r\n}\r\nstatic inline void mtk_nfc_wait_ioready(struct mtk_nfc *nfc)\r\n{\r\nint rc;\r\nu8 val;\r\nrc = readb_poll_timeout_atomic(nfc->regs + NFI_PIO_DIRDY, val,\r\nval & PIO_DI_RDY, 10, MTK_TIMEOUT);\r\nif (rc < 0)\r\ndev_err(nfc->dev, "data not ready\n");\r\n}\r\nstatic inline u8 mtk_nfc_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nu32 reg;\r\nreg = nfi_readl(nfc, NFI_STA) & NFI_FSM_MASK;\r\nif (reg != NFI_FSM_CUSTDATA) {\r\nreg = nfi_readw(nfc, NFI_CNFG);\r\nreg |= CNFG_BYTE_RW | CNFG_READ_EN;\r\nnfi_writew(nfc, reg, NFI_CNFG);\r\nreg = (MTK_MAX_SECTOR << CON_SEC_SHIFT) | CON_BRD;\r\nnfi_writel(nfc, reg, NFI_CON);\r\nnfi_writew(nfc, STAR_EN, NFI_STRDATA);\r\n}\r\nmtk_nfc_wait_ioready(nfc);\r\nreturn nfi_readb(nfc, NFI_DATAR);\r\n}\r\nstatic void mtk_nfc_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = mtk_nfc_read_byte(mtd);\r\n}\r\nstatic void mtk_nfc_write_byte(struct mtd_info *mtd, u8 byte)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(mtd_to_nand(mtd));\r\nu32 reg;\r\nreg = nfi_readl(nfc, NFI_STA) & NFI_FSM_MASK;\r\nif (reg != NFI_FSM_CUSTDATA) {\r\nreg = nfi_readw(nfc, NFI_CNFG) | CNFG_BYTE_RW;\r\nnfi_writew(nfc, reg, NFI_CNFG);\r\nreg = MTK_MAX_SECTOR << CON_SEC_SHIFT | CON_BWR;\r\nnfi_writel(nfc, reg, NFI_CON);\r\nnfi_writew(nfc, STAR_EN, NFI_STRDATA);\r\n}\r\nmtk_nfc_wait_ioready(nfc);\r\nnfi_writeb(nfc, byte, NFI_DATAW);\r\n}\r\nstatic void mtk_nfc_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nmtk_nfc_write_byte(mtd, buf[i]);\r\n}\r\nstatic int mtk_nfc_sector_encode(struct nand_chip *chip, u8 *data)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nint size = chip->ecc.size + mtk_nand->fdm.reg_size;\r\nnfc->ecc_cfg.mode = ECC_DMA_MODE;\r\nnfc->ecc_cfg.op = ECC_ENCODE;\r\nreturn mtk_ecc_encode(nfc->ecc, &nfc->ecc_cfg, data, size);\r\n}\r\nstatic void mtk_nfc_no_bad_mark_swap(struct mtd_info *a, u8 *b, int c)\r\n{\r\n}\r\nstatic void mtk_nfc_bad_mark_swap(struct mtd_info *mtd, u8 *buf, int raw)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mtk_nfc_nand_chip *nand = to_mtk_nand(chip);\r\nu32 bad_pos = nand->bad_mark.pos;\r\nif (raw)\r\nbad_pos += nand->bad_mark.sec * mtk_data_len(chip);\r\nelse\r\nbad_pos += nand->bad_mark.sec * chip->ecc.size;\r\nswap(chip->oob_poi[0], buf[bad_pos]);\r\n}\r\nstatic int mtk_nfc_format_subpage(struct mtd_info *mtd, u32 offset,\r\nu32 len, const u8 *buf)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\r\nu32 start, end;\r\nint i, ret;\r\nstart = offset / chip->ecc.size;\r\nend = DIV_ROUND_UP(offset + len, chip->ecc.size);\r\nmemset(nfc->buffer, 0xff, mtd->writesize + mtd->oobsize);\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\nmemcpy(mtk_data_ptr(chip, i), data_ptr(chip, buf, i),\r\nchip->ecc.size);\r\nif (start > i || i >= end)\r\ncontinue;\r\nif (i == mtk_nand->bad_mark.sec)\r\nmtk_nand->bad_mark.bm_swap(mtd, nfc->buffer, 1);\r\nmemcpy(mtk_oob_ptr(chip, i), oob_ptr(chip, i), fdm->reg_size);\r\nret = mtk_nfc_sector_encode(chip, mtk_data_ptr(chip, i));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_nfc_format_page(struct mtd_info *mtd, const u8 *buf)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\r\nu32 i;\r\nmemset(nfc->buffer, 0xff, mtd->writesize + mtd->oobsize);\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\nif (buf)\r\nmemcpy(mtk_data_ptr(chip, i), data_ptr(chip, buf, i),\r\nchip->ecc.size);\r\nif (i == mtk_nand->bad_mark.sec)\r\nmtk_nand->bad_mark.bm_swap(mtd, nfc->buffer, 1);\r\nmemcpy(mtk_oob_ptr(chip, i), oob_ptr(chip, i), fdm->reg_size);\r\n}\r\n}\r\nstatic inline void mtk_nfc_read_fdm(struct nand_chip *chip, u32 start,\r\nu32 sectors)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\r\nu32 vall, valm;\r\nu8 *oobptr;\r\nint i, j;\r\nfor (i = 0; i < sectors; i++) {\r\noobptr = oob_ptr(chip, start + i);\r\nvall = nfi_readl(nfc, NFI_FDML(i));\r\nvalm = nfi_readl(nfc, NFI_FDMM(i));\r\nfor (j = 0; j < fdm->reg_size; j++)\r\noobptr[j] = (j >= 4 ? valm : vall) >> ((j % 4) * 8);\r\n}\r\n}\r\nstatic inline void mtk_nfc_write_fdm(struct nand_chip *chip)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\r\nu32 vall, valm;\r\nu8 *oobptr;\r\nint i, j;\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\noobptr = oob_ptr(chip, i);\r\nvall = 0;\r\nvalm = 0;\r\nfor (j = 0; j < 8; j++) {\r\nif (j < 4)\r\nvall |= (j < fdm->reg_size ? oobptr[j] : 0xff)\r\n<< (j * 8);\r\nelse\r\nvalm |= (j < fdm->reg_size ? oobptr[j] : 0xff)\r\n<< ((j - 4) * 8);\r\n}\r\nnfi_writel(nfc, vall, NFI_FDML(i));\r\nnfi_writel(nfc, valm, NFI_FDMM(i));\r\n}\r\n}\r\nstatic int mtk_nfc_do_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst u8 *buf, int page, int len)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct device *dev = nfc->dev;\r\ndma_addr_t addr;\r\nu32 reg;\r\nint ret;\r\naddr = dma_map_single(dev, (void *)buf, len, DMA_TO_DEVICE);\r\nret = dma_mapping_error(nfc->dev, addr);\r\nif (ret) {\r\ndev_err(nfc->dev, "dma mapping error\n");\r\nreturn -EINVAL;\r\n}\r\nreg = nfi_readw(nfc, NFI_CNFG) | CNFG_AHB | CNFG_DMA_BURST_EN;\r\nnfi_writew(nfc, reg, NFI_CNFG);\r\nnfi_writel(nfc, chip->ecc.steps << CON_SEC_SHIFT, NFI_CON);\r\nnfi_writel(nfc, lower_32_bits(addr), NFI_STRADDR);\r\nnfi_writew(nfc, INTR_AHB_DONE_EN, NFI_INTR_EN);\r\ninit_completion(&nfc->done);\r\nreg = nfi_readl(nfc, NFI_CON) | CON_BWR;\r\nnfi_writel(nfc, reg, NFI_CON);\r\nnfi_writew(nfc, STAR_EN, NFI_STRDATA);\r\nret = wait_for_completion_timeout(&nfc->done, msecs_to_jiffies(500));\r\nif (!ret) {\r\ndev_err(dev, "program ahb done timeout\n");\r\nnfi_writew(nfc, 0, NFI_INTR_EN);\r\nret = -ETIMEDOUT;\r\ngoto timeout;\r\n}\r\nret = readl_poll_timeout_atomic(nfc->regs + NFI_ADDRCNTR, reg,\r\nADDRCNTR_SEC(reg) >= chip->ecc.steps,\r\n10, MTK_TIMEOUT);\r\nif (ret)\r\ndev_err(dev, "hwecc write timeout\n");\r\ntimeout:\r\ndma_unmap_single(nfc->dev, addr, len, DMA_TO_DEVICE);\r\nnfi_writel(nfc, 0, NFI_CON);\r\nreturn ret;\r\n}\r\nstatic int mtk_nfc_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst u8 *buf, int page, int raw)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nsize_t len;\r\nconst u8 *bufpoi;\r\nu32 reg;\r\nint ret;\r\nif (!raw) {\r\nreg = nfi_readw(nfc, NFI_CNFG) | CNFG_AUTO_FMT_EN;\r\nnfi_writew(nfc, reg | CNFG_HW_ECC_EN, NFI_CNFG);\r\nnfc->ecc_cfg.op = ECC_ENCODE;\r\nnfc->ecc_cfg.mode = ECC_NFI_MODE;\r\nret = mtk_ecc_enable(nfc->ecc, &nfc->ecc_cfg);\r\nif (ret) {\r\nreg = nfi_readw(nfc, NFI_CNFG);\r\nreg &= ~(CNFG_AUTO_FMT_EN | CNFG_HW_ECC_EN);\r\nnfi_writew(nfc, reg, NFI_CNFG);\r\nreturn ret;\r\n}\r\nmemcpy(nfc->buffer, buf, mtd->writesize);\r\nmtk_nand->bad_mark.bm_swap(mtd, nfc->buffer, raw);\r\nbufpoi = nfc->buffer;\r\nmtk_nfc_write_fdm(chip);\r\n} else {\r\nbufpoi = buf;\r\n}\r\nlen = mtd->writesize + (raw ? mtd->oobsize : 0);\r\nret = mtk_nfc_do_write_page(mtd, chip, bufpoi, page, len);\r\nif (!raw)\r\nmtk_ecc_disable(nfc->ecc);\r\nreturn ret;\r\n}\r\nstatic int mtk_nfc_write_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const u8 *buf,\r\nint oob_on, int page)\r\n{\r\nreturn mtk_nfc_write_page(mtd, chip, buf, page, 0);\r\n}\r\nstatic int mtk_nfc_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst u8 *buf, int oob_on, int pg)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nmtk_nfc_format_page(mtd, buf);\r\nreturn mtk_nfc_write_page(mtd, chip, nfc->buffer, pg, 1);\r\n}\r\nstatic int mtk_nfc_write_subpage_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, u32 offset,\r\nu32 data_len, const u8 *buf,\r\nint oob_on, int page)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nint ret;\r\nret = mtk_nfc_format_subpage(mtd, offset, data_len, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mtk_nfc_write_page(mtd, chip, nfc->buffer, page, 1);\r\n}\r\nstatic int mtk_nfc_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nint ret;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);\r\nret = mtk_nfc_write_page_raw(mtd, chip, NULL, 1, page);\r\nif (ret < 0)\r\nreturn -EIO;\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nret = chip->waitfunc(mtd, chip);\r\nreturn ret & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic int mtk_nfc_update_ecc_stats(struct mtd_info *mtd, u8 *buf, u32 sectors)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nstruct mtk_ecc_stats stats;\r\nint rc, i;\r\nrc = nfi_readl(nfc, NFI_STA) & STA_EMP_PAGE;\r\nif (rc) {\r\nmemset(buf, 0xff, sectors * chip->ecc.size);\r\nfor (i = 0; i < sectors; i++)\r\nmemset(oob_ptr(chip, i), 0xff, mtk_nand->fdm.reg_size);\r\nreturn 0;\r\n}\r\nmtk_ecc_get_stats(nfc->ecc, &stats, sectors);\r\nmtd->ecc_stats.corrected += stats.corrected;\r\nmtd->ecc_stats.failed += stats.failed;\r\nreturn stats.bitflips;\r\n}\r\nstatic int mtk_nfc_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,\r\nu32 data_offs, u32 readlen,\r\nu8 *bufpoi, int page, int raw)\r\n{\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nu32 spare = mtk_nand->spare_per_sector;\r\nu32 column, sectors, start, end, reg;\r\ndma_addr_t addr;\r\nint bitflips;\r\nsize_t len;\r\nu8 *buf;\r\nint rc;\r\nstart = data_offs / chip->ecc.size;\r\nend = DIV_ROUND_UP(data_offs + readlen, chip->ecc.size);\r\nsectors = end - start;\r\ncolumn = start * (chip->ecc.size + spare);\r\nlen = sectors * chip->ecc.size + (raw ? sectors * spare : 0);\r\nbuf = bufpoi + start * chip->ecc.size;\r\nif (column != 0)\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, column, -1);\r\naddr = dma_map_single(nfc->dev, buf, len, DMA_FROM_DEVICE);\r\nrc = dma_mapping_error(nfc->dev, addr);\r\nif (rc) {\r\ndev_err(nfc->dev, "dma mapping error\n");\r\nreturn -EINVAL;\r\n}\r\nreg = nfi_readw(nfc, NFI_CNFG);\r\nreg |= CNFG_READ_EN | CNFG_DMA_BURST_EN | CNFG_AHB;\r\nif (!raw) {\r\nreg |= CNFG_AUTO_FMT_EN | CNFG_HW_ECC_EN;\r\nnfi_writew(nfc, reg, NFI_CNFG);\r\nnfc->ecc_cfg.mode = ECC_NFI_MODE;\r\nnfc->ecc_cfg.sectors = sectors;\r\nnfc->ecc_cfg.op = ECC_DECODE;\r\nrc = mtk_ecc_enable(nfc->ecc, &nfc->ecc_cfg);\r\nif (rc) {\r\ndev_err(nfc->dev, "ecc enable\n");\r\nreg &= ~(CNFG_DMA_BURST_EN | CNFG_AHB | CNFG_READ_EN |\r\nCNFG_AUTO_FMT_EN | CNFG_HW_ECC_EN);\r\nnfi_writew(nfc, reg, NFI_CNFG);\r\ndma_unmap_single(nfc->dev, addr, len, DMA_FROM_DEVICE);\r\nreturn rc;\r\n}\r\n} else {\r\nnfi_writew(nfc, reg, NFI_CNFG);\r\n}\r\nnfi_writel(nfc, sectors << CON_SEC_SHIFT, NFI_CON);\r\nnfi_writew(nfc, INTR_AHB_DONE_EN, NFI_INTR_EN);\r\nnfi_writel(nfc, lower_32_bits(addr), NFI_STRADDR);\r\ninit_completion(&nfc->done);\r\nreg = nfi_readl(nfc, NFI_CON) | CON_BRD;\r\nnfi_writel(nfc, reg, NFI_CON);\r\nnfi_writew(nfc, STAR_EN, NFI_STRDATA);\r\nrc = wait_for_completion_timeout(&nfc->done, msecs_to_jiffies(500));\r\nif (!rc)\r\ndev_warn(nfc->dev, "read ahb/dma done timeout\n");\r\nrc = readl_poll_timeout_atomic(nfc->regs + NFI_BYTELEN, reg,\r\nADDRCNTR_SEC(reg) >= sectors, 10,\r\nMTK_TIMEOUT);\r\nif (rc < 0) {\r\ndev_err(nfc->dev, "subpage done timeout\n");\r\nbitflips = -EIO;\r\n} else {\r\nbitflips = 0;\r\nif (!raw) {\r\nrc = mtk_ecc_wait_done(nfc->ecc, ECC_DECODE);\r\nbitflips = rc < 0 ? -ETIMEDOUT :\r\nmtk_nfc_update_ecc_stats(mtd, buf, sectors);\r\nmtk_nfc_read_fdm(chip, start, sectors);\r\n}\r\n}\r\ndma_unmap_single(nfc->dev, addr, len, DMA_FROM_DEVICE);\r\nif (raw)\r\ngoto done;\r\nmtk_ecc_disable(nfc->ecc);\r\nif (clamp(mtk_nand->bad_mark.sec, start, end) == mtk_nand->bad_mark.sec)\r\nmtk_nand->bad_mark.bm_swap(mtd, bufpoi, raw);\r\ndone:\r\nnfi_writel(nfc, 0, NFI_CON);\r\nreturn bitflips;\r\n}\r\nstatic int mtk_nfc_read_subpage_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, u32 off,\r\nu32 len, u8 *p, int pg)\r\n{\r\nreturn mtk_nfc_read_subpage(mtd, chip, off, len, p, pg, 0);\r\n}\r\nstatic int mtk_nfc_read_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, u8 *p,\r\nint oob_on, int pg)\r\n{\r\nreturn mtk_nfc_read_subpage(mtd, chip, 0, mtd->writesize, p, pg, 0);\r\n}\r\nstatic int mtk_nfc_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nu8 *buf, int oob_on, int page)\r\n{\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nstruct mtk_nfc *nfc = nand_get_controller_data(chip);\r\nstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\r\nint i, ret;\r\nmemset(nfc->buffer, 0xff, mtd->writesize + mtd->oobsize);\r\nret = mtk_nfc_read_subpage(mtd, chip, 0, mtd->writesize, nfc->buffer,\r\npage, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\nmemcpy(oob_ptr(chip, i), mtk_oob_ptr(chip, i), fdm->reg_size);\r\nif (i == mtk_nand->bad_mark.sec)\r\nmtk_nand->bad_mark.bm_swap(mtd, nfc->buffer, 1);\r\nif (buf)\r\nmemcpy(data_ptr(chip, buf, i), mtk_data_ptr(chip, i),\r\nchip->ecc.size);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mtk_nfc_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nreturn mtk_nfc_read_page_raw(mtd, chip, NULL, 1, page);\r\n}\r\nstatic inline void mtk_nfc_hw_init(struct mtk_nfc *nfc)\r\n{\r\nnfi_writel(nfc, 0x10804211, NFI_ACCCON);\r\nnfi_writew(nfc, 0xf1, NFI_CNRNB);\r\nnfi_writew(nfc, PAGEFMT_8K_16K, NFI_PAGEFMT);\r\nmtk_nfc_hw_reset(nfc);\r\nnfi_readl(nfc, NFI_INTR_STA);\r\nnfi_writel(nfc, 0, NFI_INTR_EN);\r\n}\r\nstatic irqreturn_t mtk_nfc_irq(int irq, void *id)\r\n{\r\nstruct mtk_nfc *nfc = id;\r\nu16 sta, ien;\r\nsta = nfi_readw(nfc, NFI_INTR_STA);\r\nien = nfi_readw(nfc, NFI_INTR_EN);\r\nif (!(sta & ien))\r\nreturn IRQ_NONE;\r\nnfi_writew(nfc, ~sta & ien, NFI_INTR_EN);\r\ncomplete(&nfc->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mtk_nfc_enable_clk(struct device *dev, struct mtk_nfc_clk *clk)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(clk->nfi_clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable nfi clk\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(clk->pad_clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable pad clk\n");\r\nclk_disable_unprepare(clk->nfi_clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_nfc_disable_clk(struct mtk_nfc_clk *clk)\r\n{\r\nclk_disable_unprepare(clk->nfi_clk);\r\nclk_disable_unprepare(clk->pad_clk);\r\n}\r\nstatic int mtk_nfc_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oob_region)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\r\nu32 eccsteps;\r\neccsteps = mtd->writesize / chip->ecc.size;\r\nif (section >= eccsteps)\r\nreturn -ERANGE;\r\noob_region->length = fdm->reg_size - fdm->ecc_size;\r\noob_region->offset = section * fdm->reg_size + fdm->ecc_size;\r\nreturn 0;\r\n}\r\nstatic int mtk_nfc_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oob_region)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\r\nu32 eccsteps;\r\nif (section)\r\nreturn -ERANGE;\r\neccsteps = mtd->writesize / chip->ecc.size;\r\noob_region->offset = mtk_nand->fdm.reg_size * eccsteps;\r\noob_region->length = mtd->oobsize - oob_region->offset;\r\nreturn 0;\r\n}\r\nstatic void mtk_nfc_set_fdm(struct mtk_nfc_fdm *fdm, struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd_to_nand(mtd);\r\nstruct mtk_nfc_nand_chip *chip = to_mtk_nand(nand);\r\nu32 ecc_bytes;\r\necc_bytes = DIV_ROUND_UP(nand->ecc.strength * ECC_PARITY_BITS, 8);\r\nfdm->reg_size = chip->spare_per_sector - ecc_bytes;\r\nif (fdm->reg_size > NFI_FDM_MAX_SIZE)\r\nfdm->reg_size = NFI_FDM_MAX_SIZE;\r\nfdm->ecc_size = 1;\r\n}\r\nstatic void mtk_nfc_set_bad_mark_ctl(struct mtk_nfc_bad_mark_ctl *bm_ctl,\r\nstruct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd_to_nand(mtd);\r\nif (mtd->writesize == 512) {\r\nbm_ctl->bm_swap = mtk_nfc_no_bad_mark_swap;\r\n} else {\r\nbm_ctl->bm_swap = mtk_nfc_bad_mark_swap;\r\nbm_ctl->sec = mtd->writesize / mtk_data_len(nand);\r\nbm_ctl->pos = mtd->writesize % mtk_data_len(nand);\r\n}\r\n}\r\nstatic void mtk_nfc_set_spare_per_sector(u32 *sps, struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd_to_nand(mtd);\r\nu32 spare[] = {16, 26, 27, 28, 32, 36, 40, 44,\r\n48, 49, 50, 51, 52, 62, 63, 64};\r\nu32 eccsteps, i;\r\neccsteps = mtd->writesize / nand->ecc.size;\r\n*sps = mtd->oobsize / eccsteps;\r\nif (nand->ecc.size == 1024)\r\n*sps >>= 1;\r\nfor (i = 0; i < ARRAY_SIZE(spare); i++) {\r\nif (*sps <= spare[i]) {\r\nif (!i)\r\n*sps = spare[i];\r\nelse if (*sps != spare[i])\r\n*sps = spare[i - 1];\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(spare))\r\n*sps = spare[ARRAY_SIZE(spare) - 1];\r\nif (nand->ecc.size == 1024)\r\n*sps <<= 1;\r\n}\r\nstatic int mtk_nfc_ecc_init(struct device *dev, struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd_to_nand(mtd);\r\nu32 spare;\r\nint free;\r\nif (nand->ecc.mode != NAND_ECC_HW) {\r\ndev_err(dev, "ecc.mode not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!nand->ecc.size || !nand->ecc.strength) {\r\nnand->ecc.strength = nand->ecc_strength_ds;\r\nnand->ecc.size = nand->ecc_step_ds;\r\nif (nand->ecc.size < 1024) {\r\nif (mtd->writesize > 512) {\r\nnand->ecc.size = 1024;\r\nnand->ecc.strength <<= 1;\r\n} else {\r\nnand->ecc.size = 512;\r\n}\r\n} else {\r\nnand->ecc.size = 1024;\r\n}\r\nmtk_nfc_set_spare_per_sector(&spare, mtd);\r\nfree = ((nand->ecc.strength * ECC_PARITY_BITS) + 7) >> 3;\r\nfree = spare - free;\r\nif (free > NFI_FDM_MAX_SIZE) {\r\nspare -= NFI_FDM_MAX_SIZE;\r\nnand->ecc.strength = (spare << 3) / ECC_PARITY_BITS;\r\n} else if (free < 0) {\r\nspare -= NFI_FDM_MIN_SIZE;\r\nnand->ecc.strength = (spare << 3) / ECC_PARITY_BITS;\r\n}\r\n}\r\nmtk_ecc_adjust_strength(&nand->ecc.strength);\r\ndev_info(dev, "eccsize %d eccstrength %d\n",\r\nnand->ecc.size, nand->ecc.strength);\r\nreturn 0;\r\n}\r\nstatic int mtk_nfc_nand_chip_init(struct device *dev, struct mtk_nfc *nfc,\r\nstruct device_node *np)\r\n{\r\nstruct mtk_nfc_nand_chip *chip;\r\nstruct nand_chip *nand;\r\nstruct mtd_info *mtd;\r\nint nsels, len;\r\nu32 tmp;\r\nint ret;\r\nint i;\r\nif (!of_get_property(np, "reg", &nsels))\r\nreturn -ENODEV;\r\nnsels /= sizeof(u32);\r\nif (!nsels || nsels > MTK_NAND_MAX_NSELS) {\r\ndev_err(dev, "invalid reg property size %d\n", nsels);\r\nreturn -EINVAL;\r\n}\r\nchip = devm_kzalloc(dev, sizeof(*chip) + nsels * sizeof(u8),\r\nGFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->nsels = nsels;\r\nfor (i = 0; i < nsels; i++) {\r\nret = of_property_read_u32_index(np, "reg", i, &tmp);\r\nif (ret) {\r\ndev_err(dev, "reg property failure : %d\n", ret);\r\nreturn ret;\r\n}\r\nchip->sels[i] = tmp;\r\n}\r\nnand = &chip->nand;\r\nnand->controller = &nfc->controller;\r\nnand_set_flash_node(nand, np);\r\nnand_set_controller_data(nand, nfc);\r\nnand->options |= NAND_USE_BOUNCE_BUFFER | NAND_SUBPAGE_READ;\r\nnand->dev_ready = mtk_nfc_dev_ready;\r\nnand->select_chip = mtk_nfc_select_chip;\r\nnand->write_byte = mtk_nfc_write_byte;\r\nnand->write_buf = mtk_nfc_write_buf;\r\nnand->read_byte = mtk_nfc_read_byte;\r\nnand->read_buf = mtk_nfc_read_buf;\r\nnand->cmd_ctrl = mtk_nfc_cmd_ctrl;\r\nnand->ecc.mode = NAND_ECC_HW;\r\nnand->ecc.write_subpage = mtk_nfc_write_subpage_hwecc;\r\nnand->ecc.write_page_raw = mtk_nfc_write_page_raw;\r\nnand->ecc.write_page = mtk_nfc_write_page_hwecc;\r\nnand->ecc.write_oob_raw = mtk_nfc_write_oob_std;\r\nnand->ecc.write_oob = mtk_nfc_write_oob_std;\r\nnand->ecc.read_subpage = mtk_nfc_read_subpage_hwecc;\r\nnand->ecc.read_page_raw = mtk_nfc_read_page_raw;\r\nnand->ecc.read_page = mtk_nfc_read_page_hwecc;\r\nnand->ecc.read_oob_raw = mtk_nfc_read_oob_std;\r\nnand->ecc.read_oob = mtk_nfc_read_oob_std;\r\nmtd = nand_to_mtd(nand);\r\nmtd->owner = THIS_MODULE;\r\nmtd->dev.parent = dev;\r\nmtd->name = MTK_NAME;\r\nmtd_set_ooblayout(mtd, &mtk_nfc_ooblayout_ops);\r\nmtk_nfc_hw_init(nfc);\r\nret = nand_scan_ident(mtd, nsels, NULL);\r\nif (ret)\r\nreturn -ENODEV;\r\nif (nand->bbt_options & NAND_BBT_USE_FLASH)\r\nnand->bbt_options |= NAND_BBT_NO_OOB;\r\nret = mtk_nfc_ecc_init(dev, mtd);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (nand->options & NAND_BUSWIDTH_16) {\r\ndev_err(dev, "16bits buswidth not supported");\r\nreturn -EINVAL;\r\n}\r\nmtk_nfc_set_spare_per_sector(&chip->spare_per_sector, mtd);\r\nmtk_nfc_set_fdm(&chip->fdm, mtd);\r\nmtk_nfc_set_bad_mark_ctl(&chip->bad_mark, mtd);\r\nlen = mtd->writesize + mtd->oobsize;\r\nnfc->buffer = devm_kzalloc(dev, len, GFP_KERNEL);\r\nif (!nfc->buffer)\r\nreturn -ENOMEM;\r\nret = nand_scan_tail(mtd);\r\nif (ret)\r\nreturn -ENODEV;\r\nret = mtd_device_parse_register(mtd, NULL, NULL, NULL, 0);\r\nif (ret) {\r\ndev_err(dev, "mtd parse partition error\n");\r\nnand_release(mtd);\r\nreturn ret;\r\n}\r\nlist_add_tail(&chip->node, &nfc->chips);\r\nreturn 0;\r\n}\r\nstatic int mtk_nfc_nand_chips_init(struct device *dev, struct mtk_nfc *nfc)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *nand_np;\r\nint ret;\r\nfor_each_child_of_node(np, nand_np) {\r\nret = mtk_nfc_nand_chip_init(dev, nfc, nand_np);\r\nif (ret) {\r\nof_node_put(nand_np);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_nfc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct mtk_nfc *nfc;\r\nstruct resource *res;\r\nint ret, irq;\r\nnfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);\r\nif (!nfc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&nfc->controller.lock);\r\ninit_waitqueue_head(&nfc->controller.wq);\r\nINIT_LIST_HEAD(&nfc->chips);\r\nnfc->ecc = of_mtk_ecc_get(np);\r\nif (IS_ERR(nfc->ecc))\r\nreturn PTR_ERR(nfc->ecc);\r\nelse if (!nfc->ecc)\r\nreturn -ENODEV;\r\nnfc->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnfc->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(nfc->regs)) {\r\nret = PTR_ERR(nfc->regs);\r\ndev_err(dev, "no nfi base\n");\r\ngoto release_ecc;\r\n}\r\nnfc->clk.nfi_clk = devm_clk_get(dev, "nfi_clk");\r\nif (IS_ERR(nfc->clk.nfi_clk)) {\r\ndev_err(dev, "no clk\n");\r\nret = PTR_ERR(nfc->clk.nfi_clk);\r\ngoto release_ecc;\r\n}\r\nnfc->clk.pad_clk = devm_clk_get(dev, "pad_clk");\r\nif (IS_ERR(nfc->clk.pad_clk)) {\r\ndev_err(dev, "no pad clk\n");\r\nret = PTR_ERR(nfc->clk.pad_clk);\r\ngoto release_ecc;\r\n}\r\nret = mtk_nfc_enable_clk(dev, &nfc->clk);\r\nif (ret)\r\ngoto release_ecc;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "no nfi irq resource\n");\r\nret = -EINVAL;\r\ngoto clk_disable;\r\n}\r\nret = devm_request_irq(dev, irq, mtk_nfc_irq, 0x0, "mtk-nand", nfc);\r\nif (ret) {\r\ndev_err(dev, "failed to request nfi irq\n");\r\ngoto clk_disable;\r\n}\r\nret = dma_set_mask(dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(dev, "failed to set dma mask\n");\r\ngoto clk_disable;\r\n}\r\nplatform_set_drvdata(pdev, nfc);\r\nret = mtk_nfc_nand_chips_init(dev, nfc);\r\nif (ret) {\r\ndev_err(dev, "failed to init nand chips\n");\r\ngoto clk_disable;\r\n}\r\nreturn 0;\r\nclk_disable:\r\nmtk_nfc_disable_clk(&nfc->clk);\r\nrelease_ecc:\r\nmtk_ecc_release(nfc->ecc);\r\nreturn ret;\r\n}\r\nstatic int mtk_nfc_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_nfc *nfc = platform_get_drvdata(pdev);\r\nstruct mtk_nfc_nand_chip *chip;\r\nwhile (!list_empty(&nfc->chips)) {\r\nchip = list_first_entry(&nfc->chips, struct mtk_nfc_nand_chip,\r\nnode);\r\nnand_release(nand_to_mtd(&chip->nand));\r\nlist_del(&chip->node);\r\n}\r\nmtk_ecc_release(nfc->ecc);\r\nmtk_nfc_disable_clk(&nfc->clk);\r\nreturn 0;\r\n}\r\nstatic int mtk_nfc_suspend(struct device *dev)\r\n{\r\nstruct mtk_nfc *nfc = dev_get_drvdata(dev);\r\nmtk_nfc_disable_clk(&nfc->clk);\r\nreturn 0;\r\n}\r\nstatic int mtk_nfc_resume(struct device *dev)\r\n{\r\nstruct mtk_nfc *nfc = dev_get_drvdata(dev);\r\nstruct mtk_nfc_nand_chip *chip;\r\nstruct nand_chip *nand;\r\nstruct mtd_info *mtd;\r\nint ret;\r\nu32 i;\r\nudelay(200);\r\nret = mtk_nfc_enable_clk(dev, &nfc->clk);\r\nif (ret)\r\nreturn ret;\r\nmtk_nfc_hw_init(nfc);\r\nlist_for_each_entry(chip, &nfc->chips, node) {\r\nnand = &chip->nand;\r\nmtd = nand_to_mtd(nand);\r\nfor (i = 0; i < chip->nsels; i++) {\r\nnand->select_chip(mtd, i);\r\nnand->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\n}\r\n}\r\nreturn 0;\r\n}
