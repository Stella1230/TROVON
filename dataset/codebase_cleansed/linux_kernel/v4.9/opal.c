void opal_configure_cores(void)\r\n{\r\n#ifdef __BIG_ENDIAN__\r\nopal_reinit_cpus(OPAL_REINIT_CPUS_HILE_BE);\r\n#else\r\nopal_reinit_cpus(OPAL_REINIT_CPUS_HILE_LE);\r\n#endif\r\nif (cur_cpu_spec->cpu_restore)\r\ncur_cpu_spec->cpu_restore();\r\n}\r\nint __init early_init_dt_scan_opal(unsigned long node,\r\nconst char *uname, int depth, void *data)\r\n{\r\nconst void *basep, *entryp, *sizep;\r\nint basesz, entrysz, runtimesz;\r\nif (depth != 1 || strcmp(uname, "ibm,opal") != 0)\r\nreturn 0;\r\nbasep = of_get_flat_dt_prop(node, "opal-base-address", &basesz);\r\nentryp = of_get_flat_dt_prop(node, "opal-entry-address", &entrysz);\r\nsizep = of_get_flat_dt_prop(node, "opal-runtime-size", &runtimesz);\r\nif (!basep || !entryp || !sizep)\r\nreturn 1;\r\nopal.base = of_read_number(basep, basesz/4);\r\nopal.entry = of_read_number(entryp, entrysz/4);\r\nopal.size = of_read_number(sizep, runtimesz/4);\r\npr_debug("OPAL Base = 0x%llx (basep=%p basesz=%d)\n",\r\nopal.base, basep, basesz);\r\npr_debug("OPAL Entry = 0x%llx (entryp=%p basesz=%d)\n",\r\nopal.entry, entryp, entrysz);\r\npr_debug("OPAL Entry = 0x%llx (sizep=%p runtimesz=%d)\n",\r\nopal.size, sizep, runtimesz);\r\nif (of_flat_dt_is_compatible(node, "ibm,opal-v3")) {\r\npowerpc_firmware_features |= FW_FEATURE_OPAL;\r\npr_info("OPAL detected !\n");\r\n} else {\r\npanic("OPAL != V3 detected, no longer supported.\n");\r\n}\r\nreturn 1;\r\n}\r\nint __init early_init_dt_scan_recoverable_ranges(unsigned long node,\r\nconst char *uname, int depth, void *data)\r\n{\r\nint i, psize, size;\r\nconst __be32 *prop;\r\nif (depth != 1 || strcmp(uname, "ibm,opal") != 0)\r\nreturn 0;\r\nprop = of_get_flat_dt_prop(node, "mcheck-recoverable-ranges", &psize);\r\nif (!prop)\r\nreturn 1;\r\npr_debug("Found machine check recoverable ranges.\n");\r\nmc_recoverable_range_len = psize / (sizeof(*prop) * 5);\r\nif (!mc_recoverable_range_len)\r\nreturn 1;\r\nsize = mc_recoverable_range_len *\r\nsizeof(struct mcheck_recoverable_range);\r\nmc_recoverable_range =__va(memblock_alloc_base(size, __alignof__(u64),\r\nppc64_rma_size));\r\nmemset(mc_recoverable_range, 0, size);\r\nfor (i = 0; i < mc_recoverable_range_len; i++) {\r\nmc_recoverable_range[i].start_addr =\r\nof_read_number(prop + (i * 5) + 0, 2);\r\nmc_recoverable_range[i].end_addr =\r\nmc_recoverable_range[i].start_addr +\r\nof_read_number(prop + (i * 5) + 2, 1);\r\nmc_recoverable_range[i].recover_addr =\r\nof_read_number(prop + (i * 5) + 3, 2);\r\npr_debug("Machine check recoverable range: %llx..%llx: %llx\n",\r\nmc_recoverable_range[i].start_addr,\r\nmc_recoverable_range[i].end_addr,\r\nmc_recoverable_range[i].recover_addr);\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init opal_register_exception_handlers(void)\r\n{\r\n#ifdef __BIG_ENDIAN__\r\nu64 glue;\r\nif (!(powerpc_firmware_features & FW_FEATURE_OPAL))\r\nreturn -ENODEV;\r\nglue = 0x7000;\r\nif (!opal_check_token(OPAL_HANDLE_HMI)) {\r\npr_info("Old firmware detected, OPAL handles HMIs.\n");\r\nopal_register_exception_handler(\r\nOPAL_HYPERVISOR_MAINTENANCE_HANDLER,\r\n0, glue);\r\nglue += 128;\r\n}\r\nopal_register_exception_handler(OPAL_SOFTPATCH_HANDLER, 0, glue);\r\n#endif\r\nreturn 0;\r\n}\r\nint opal_message_notifier_register(enum opal_msg_type msg_type,\r\nstruct notifier_block *nb)\r\n{\r\nif (!nb || msg_type >= OPAL_MSG_TYPE_MAX) {\r\npr_warning("%s: Invalid arguments, msg_type:%d\n",\r\n__func__, msg_type);\r\nreturn -EINVAL;\r\n}\r\nreturn atomic_notifier_chain_register(\r\n&opal_msg_notifier_head[msg_type], nb);\r\n}\r\nint opal_message_notifier_unregister(enum opal_msg_type msg_type,\r\nstruct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_unregister(\r\n&opal_msg_notifier_head[msg_type], nb);\r\n}\r\nstatic void opal_message_do_notify(uint32_t msg_type, void *msg)\r\n{\r\natomic_notifier_call_chain(&opal_msg_notifier_head[msg_type],\r\nmsg_type, msg);\r\n}\r\nstatic void opal_handle_message(void)\r\n{\r\ns64 ret;\r\nstatic struct opal_msg msg;\r\nu32 type;\r\nret = opal_get_msg(__pa(&msg), sizeof(msg));\r\nif (ret == OPAL_RESOURCE)\r\nreturn;\r\nif (ret) {\r\npr_warning("%s: Failed to retrieve opal message, err=%lld\n",\r\n__func__, ret);\r\nreturn;\r\n}\r\ntype = be32_to_cpu(msg.msg_type);\r\nif (type >= OPAL_MSG_TYPE_MAX) {\r\npr_warn_once("%s: Unknown message type: %u\n", __func__, type);\r\nreturn;\r\n}\r\nopal_message_do_notify(type, (void *)&msg);\r\n}\r\nstatic irqreturn_t opal_message_notify(int irq, void *data)\r\n{\r\nopal_handle_message();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init opal_message_init(void)\r\n{\r\nint ret, i, irq;\r\nfor (i = 0; i < OPAL_MSG_TYPE_MAX; i++)\r\nATOMIC_INIT_NOTIFIER_HEAD(&opal_msg_notifier_head[i]);\r\nirq = opal_event_request(ilog2(OPAL_EVENT_MSG_PENDING));\r\nif (!irq) {\r\npr_err("%s: Can't register OPAL event irq (%d)\n",\r\n__func__, irq);\r\nreturn irq;\r\n}\r\nret = request_irq(irq, opal_message_notify,\r\nIRQ_TYPE_LEVEL_HIGH, "opal-msg", NULL);\r\nif (ret) {\r\npr_err("%s: Can't request OPAL event irq (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint opal_get_chars(uint32_t vtermno, char *buf, int count)\r\n{\r\ns64 rc;\r\n__be64 evt, len;\r\nif (!opal.entry)\r\nreturn -ENODEV;\r\nopal_poll_events(&evt);\r\nif ((be64_to_cpu(evt) & OPAL_EVENT_CONSOLE_INPUT) == 0)\r\nreturn 0;\r\nlen = cpu_to_be64(count);\r\nrc = opal_console_read(vtermno, &len, buf);\r\nif (rc == OPAL_SUCCESS)\r\nreturn be64_to_cpu(len);\r\nreturn 0;\r\n}\r\nint opal_put_chars(uint32_t vtermno, const char *data, int total_len)\r\n{\r\nint written = 0;\r\n__be64 olen;\r\ns64 len, rc;\r\nunsigned long flags;\r\n__be64 evt;\r\nif (!opal.entry)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&opal_write_lock, flags);\r\nrc = opal_console_write_buffer_space(vtermno, &olen);\r\nlen = be64_to_cpu(olen);\r\nif (rc || len < total_len) {\r\nspin_unlock_irqrestore(&opal_write_lock, flags);\r\nif (rc)\r\nreturn total_len;\r\nopal_poll_events(NULL);\r\nreturn -EAGAIN;\r\n}\r\nrc = OPAL_BUSY;\r\nwhile(total_len > 0 && (rc == OPAL_BUSY ||\r\nrc == OPAL_BUSY_EVENT || rc == OPAL_SUCCESS)) {\r\nolen = cpu_to_be64(total_len);\r\nrc = opal_console_write(vtermno, &olen, data);\r\nlen = be64_to_cpu(olen);\r\nif (rc != OPAL_SUCCESS && rc != OPAL_BUSY &&\r\nrc != OPAL_BUSY_EVENT) {\r\nwritten = total_len;\r\nbreak;\r\n}\r\nif (rc == OPAL_SUCCESS) {\r\ntotal_len -= len;\r\ndata += len;\r\nwritten += len;\r\n}\r\ndo\r\nopal_poll_events(&evt);\r\nwhile(rc == OPAL_SUCCESS &&\r\n(be64_to_cpu(evt) & OPAL_EVENT_CONSOLE_OUTPUT));\r\n}\r\nspin_unlock_irqrestore(&opal_write_lock, flags);\r\nreturn written;\r\n}\r\nstatic int opal_recover_mce(struct pt_regs *regs,\r\nstruct machine_check_event *evt)\r\n{\r\nint recovered = 0;\r\nuint64_t ea = get_mce_fault_addr(evt);\r\nif (!(regs->msr & MSR_RI)) {\r\npr_err("Machine check interrupt unrecoverable: MSR(RI=0)\n");\r\nrecovered = 0;\r\n} else if (evt->disposition == MCE_DISPOSITION_RECOVERED) {\r\nrecovered = 1;\r\n} else if (ea && !is_kernel_addr(ea)) {\r\nif (user_mode(regs) && !is_global_init(current)) {\r\n_exception(SIGBUS, regs, BUS_MCEERR_AR, regs->nip);\r\nrecovered = 1;\r\n} else\r\nrecovered = 0;\r\n} else if (user_mode(regs) && !is_global_init(current) &&\r\nevt->severity == MCE_SEV_ERROR_SYNC) {\r\n_exception(SIGBUS, regs, BUS_MCEERR_AR, regs->nip);\r\nrecovered = 1;\r\n}\r\nreturn recovered;\r\n}\r\nint opal_machine_check(struct pt_regs *regs)\r\n{\r\nstruct machine_check_event evt;\r\nint ret;\r\nif (!get_mce_event(&evt, MCE_EVENT_RELEASE))\r\nreturn 0;\r\nif (evt.version != MCE_V1) {\r\npr_err("Machine Check Exception, Unknown event version %d !\n",\r\nevt.version);\r\nreturn 0;\r\n}\r\nmachine_check_print_event_info(&evt);\r\nif (opal_recover_mce(regs, &evt))\r\nreturn 1;\r\nret = opal_cec_reboot2(OPAL_REBOOT_PLATFORM_ERROR,\r\n"Unrecoverable Machine Check exception");\r\nif (ret == OPAL_UNSUPPORTED) {\r\npr_emerg("Reboot type %d not supported\n",\r\nOPAL_REBOOT_PLATFORM_ERROR);\r\n}\r\npanic("PowerNV Unrecovered Machine Check");\r\nreturn 0;\r\n}\r\nint opal_hmi_exception_early(struct pt_regs *regs)\r\n{\r\ns64 rc;\r\nrc = opal_handle_hmi();\r\nif (rc == OPAL_SUCCESS) {\r\nlocal_paca->hmi_event_available = 1;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint opal_handle_hmi_exception(struct pt_regs *regs)\r\n{\r\ns64 rc;\r\n__be64 evt = 0;\r\nif (!local_paca->hmi_event_available)\r\nreturn 0;\r\nlocal_paca->hmi_event_available = 0;\r\nrc = opal_poll_events(&evt);\r\nif (rc == OPAL_SUCCESS && evt)\r\nopal_handle_events(be64_to_cpu(evt));\r\nreturn 1;\r\n}\r\nstatic uint64_t find_recovery_address(uint64_t nip)\r\n{\r\nint i;\r\nfor (i = 0; i < mc_recoverable_range_len; i++)\r\nif ((nip >= mc_recoverable_range[i].start_addr) &&\r\n(nip < mc_recoverable_range[i].end_addr))\r\nreturn mc_recoverable_range[i].recover_addr;\r\nreturn 0;\r\n}\r\nbool opal_mce_check_early_recovery(struct pt_regs *regs)\r\n{\r\nuint64_t recover_addr = 0;\r\nif (!opal.base || !opal.size)\r\ngoto out;\r\nif ((regs->nip >= opal.base) &&\r\n(regs->nip < (opal.base + opal.size)))\r\nrecover_addr = find_recovery_address(regs->nip);\r\nif (recover_addr)\r\nregs->nip = recover_addr;\r\nout:\r\nreturn !!recover_addr;\r\n}\r\nstatic int opal_sysfs_init(void)\r\n{\r\nopal_kobj = kobject_create_and_add("opal", firmware_kobj);\r\nif (!opal_kobj) {\r\npr_warn("kobject_create_and_add opal failed\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t symbol_map_read(struct file *fp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nreturn memory_read_from_buffer(buf, count, &off, bin_attr->private,\r\nbin_attr->size);\r\n}\r\nstatic void opal_export_symmap(void)\r\n{\r\nconst __be64 *syms;\r\nunsigned int size;\r\nstruct device_node *fw;\r\nint rc;\r\nfw = of_find_node_by_path("/ibm,opal/firmware");\r\nif (!fw)\r\nreturn;\r\nsyms = of_get_property(fw, "symbol-map", &size);\r\nif (!syms || size != 2 * sizeof(__be64))\r\nreturn;\r\nbin_attr_symbol_map.private = __va(be64_to_cpu(syms[0]));\r\nbin_attr_symbol_map.size = be64_to_cpu(syms[1]);\r\nrc = sysfs_create_bin_file(opal_kobj, &bin_attr_symbol_map);\r\nif (rc)\r\npr_warn("Error %d creating OPAL symbols file\n", rc);\r\n}\r\nstatic void __init opal_dump_region_init(void)\r\n{\r\nvoid *addr;\r\nuint64_t size;\r\nint rc;\r\nif (!opal_check_token(OPAL_REGISTER_DUMP_REGION))\r\nreturn;\r\naddr = log_buf_addr_get();\r\nif (addr == NULL)\r\nreturn;\r\nsize = log_buf_len_get();\r\nif (size == 0)\r\nreturn;\r\nrc = opal_register_dump_region(OPAL_DUMP_REGION_LOG_BUF,\r\n__pa(addr), size);\r\nif (rc && rc != OPAL_UNSUPPORTED)\r\npr_warn("DUMP: Failed to register kernel log buffer. "\r\n"rc = %d\n", rc);\r\n}\r\nstatic void opal_pdev_init(struct device_node *opal_node,\r\nconst char *compatible)\r\n{\r\nstruct device_node *np;\r\nfor_each_child_of_node(opal_node, np)\r\nif (of_device_is_compatible(np, compatible))\r\nof_platform_device_create(np, NULL, NULL);\r\n}\r\nstatic void opal_i2c_create_devs(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "ibm,opal-i2c")\r\nof_platform_device_create(np, NULL, NULL);\r\n}\r\nstatic int kopald(void *unused)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(opal_heartbeat) + 1;\r\n__be64 events;\r\nset_freezable();\r\ndo {\r\ntry_to_freeze();\r\nopal_poll_events(&events);\r\nopal_handle_events(be64_to_cpu(events));\r\nschedule_timeout_interruptible(timeout);\r\n} while (!kthread_should_stop());\r\nreturn 0;\r\n}\r\nvoid opal_wake_poller(void)\r\n{\r\nif (kopald_tsk)\r\nwake_up_process(kopald_tsk);\r\n}\r\nstatic void opal_init_heartbeat(void)\r\n{\r\nif (of_property_read_u32(opal_node, "ibm,heartbeat-ms",\r\n&opal_heartbeat) != 0)\r\nopal_heartbeat = 0;\r\nif (opal_heartbeat)\r\nkopald_tsk = kthread_run(kopald, NULL, "kopald");\r\n}\r\nstatic int __init opal_init(void)\r\n{\r\nstruct device_node *np, *consoles, *leds;\r\nint rc;\r\nopal_node = of_find_node_by_path("/ibm,opal");\r\nif (!opal_node) {\r\npr_warn("Device node not found\n");\r\nreturn -ENODEV;\r\n}\r\nconsoles = of_find_node_by_path("/ibm,opal/consoles");\r\nif (consoles) {\r\nfor_each_child_of_node(consoles, np) {\r\nif (strcmp(np->name, "serial"))\r\ncontinue;\r\nof_platform_device_create(np, NULL, NULL);\r\n}\r\nof_node_put(consoles);\r\n}\r\nopal_message_init();\r\nopal_async_comp_init();\r\nopal_sensor_init();\r\nopal_hmi_handler_init();\r\nopal_i2c_create_devs();\r\nopal_init_heartbeat();\r\nleds = of_find_node_by_path("/ibm,opal/leds");\r\nif (leds) {\r\nof_platform_device_create(leds, "opal_leds", NULL);\r\nof_node_put(leds);\r\n}\r\nopal_msglog_init();\r\nrc = opal_sysfs_init();\r\nif (rc == 0) {\r\nopal_export_symmap();\r\nopal_dump_region_init();\r\nrc = opal_elog_init();\r\nopal_flash_update_init();\r\nopal_platform_dump_init();\r\nopal_sys_param_init();\r\nopal_msglog_sysfs_init();\r\n}\r\nopal_pdev_init(opal_node, "ibm,opal-ipmi");\r\nopal_pdev_init(opal_node, "ibm,opal-flash");\r\nopal_pdev_init(opal_node, "ibm,opal-prd");\r\nopal_pdev_init(opal_node, "ibm,opal-oppanel");\r\nopal_kmsg_init();\r\nreturn 0;\r\n}\r\nvoid opal_shutdown(void)\r\n{\r\nlong rc = OPAL_BUSY;\r\nopal_event_shutdown();\r\nwhile (rc == OPAL_BUSY || rc == OPAL_BUSY_EVENT) {\r\nrc = opal_sync_host_reboot();\r\nif (rc == OPAL_BUSY)\r\nopal_poll_events(NULL);\r\nelse\r\nmdelay(10);\r\n}\r\nif (opal_check_token(OPAL_UNREGISTER_DUMP_REGION))\r\nopal_unregister_dump_region(OPAL_DUMP_REGION_LOG_BUF);\r\n}\r\nstruct opal_sg_list *opal_vmalloc_to_sg_list(void *vmalloc_addr,\r\nunsigned long vmalloc_size)\r\n{\r\nstruct opal_sg_list *sg, *first = NULL;\r\nunsigned long i = 0;\r\nsg = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!sg)\r\ngoto nomem;\r\nfirst = sg;\r\nwhile (vmalloc_size > 0) {\r\nuint64_t data = vmalloc_to_pfn(vmalloc_addr) << PAGE_SHIFT;\r\nuint64_t length = min(vmalloc_size, PAGE_SIZE);\r\nsg->entry[i].data = cpu_to_be64(data);\r\nsg->entry[i].length = cpu_to_be64(length);\r\ni++;\r\nif (i >= SG_ENTRIES_PER_NODE) {\r\nstruct opal_sg_list *next;\r\nnext = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!next)\r\ngoto nomem;\r\nsg->length = cpu_to_be64(\r\ni * sizeof(struct opal_sg_entry) + 16);\r\ni = 0;\r\nsg->next = cpu_to_be64(__pa(next));\r\nsg = next;\r\n}\r\nvmalloc_addr += length;\r\nvmalloc_size -= length;\r\n}\r\nsg->length = cpu_to_be64(i * sizeof(struct opal_sg_entry) + 16);\r\nreturn first;\r\nnomem:\r\npr_err("%s : Failed to allocate memory\n", __func__);\r\nopal_free_sg_list(first);\r\nreturn NULL;\r\n}\r\nvoid opal_free_sg_list(struct opal_sg_list *sg)\r\n{\r\nwhile (sg) {\r\nuint64_t next = be64_to_cpu(sg->next);\r\nkfree(sg);\r\nif (next)\r\nsg = __va(next);\r\nelse\r\nsg = NULL;\r\n}\r\n}\r\nint opal_error_code(int rc)\r\n{\r\nswitch (rc) {\r\ncase OPAL_SUCCESS: return 0;\r\ncase OPAL_PARAMETER: return -EINVAL;\r\ncase OPAL_ASYNC_COMPLETION: return -EINPROGRESS;\r\ncase OPAL_BUSY_EVENT: return -EBUSY;\r\ncase OPAL_NO_MEM: return -ENOMEM;\r\ncase OPAL_PERMISSION: return -EPERM;\r\ncase OPAL_UNSUPPORTED: return -EIO;\r\ncase OPAL_HARDWARE: return -EIO;\r\ncase OPAL_INTERNAL_ERROR: return -EIO;\r\ndefault:\r\npr_err("%s: unexpected OPAL error %d\n", __func__, rc);\r\nreturn -EIO;\r\n}\r\n}
