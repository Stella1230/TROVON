static void create_key(const char *prefix, const char *postfix,\r\nconst char *name, char *buf, int len)\r\n{\r\nif (prefix && postfix)\r\nsnprintf(buf, len, "%s%s%s", prefix, name, postfix);\r\nelse if (prefix)\r\nsnprintf(buf, len, "%s%s", prefix, name);\r\nelse if (postfix)\r\nsnprintf(buf, len, "%s%s", name, postfix);\r\nelse\r\nsnprintf(buf, len, "%s", name);\r\n}\r\nstatic int get_nvram_var(const char *prefix, const char *postfix,\r\nconst char *name, char *buf, int len, bool fallback)\r\n{\r\nchar key[40];\r\nint err;\r\ncreate_key(prefix, postfix, name, key, sizeof(key));\r\nerr = bcm47xx_nvram_getenv(key, buf, len);\r\nif (fallback && err == -ENOENT && prefix) {\r\ncreate_key(NULL, postfix, name, key, sizeof(key));\r\nerr = bcm47xx_nvram_getenv(key, buf, len);\r\n}\r\nreturn err;\r\n}\r\nstatic void nvram_read_u32_2(const char *prefix, const char *name,\r\nu16 *val_lo, u16 *val_hi, bool fallback)\r\n{\r\nchar buf[100];\r\nint err;\r\nu32 val;\r\nerr = get_nvram_var(prefix, NULL, name, buf, sizeof(buf), fallback);\r\nif (err < 0)\r\nreturn;\r\nerr = kstrtou32(strim(buf), 0, &val);\r\nif (err) {\r\npr_warn("can not parse nvram name %s%s with value %s got %i\n",\r\nprefix, name, buf, err);\r\nreturn;\r\n}\r\n*val_lo = (val & 0x0000FFFFU);\r\n*val_hi = (val & 0xFFFF0000U) >> 16;\r\n}\r\nstatic void nvram_read_leddc(const char *prefix, const char *name,\r\nu8 *leddc_on_time, u8 *leddc_off_time,\r\nbool fallback)\r\n{\r\nchar buf[100];\r\nint err;\r\nu32 val;\r\nerr = get_nvram_var(prefix, NULL, name, buf, sizeof(buf), fallback);\r\nif (err < 0)\r\nreturn;\r\nerr = kstrtou32(strim(buf), 0, &val);\r\nif (err) {\r\npr_warn("can not parse nvram name %s%s with value %s got %i\n",\r\nprefix, name, buf, err);\r\nreturn;\r\n}\r\nif (val == 0xffff || val == 0xffffffff)\r\nreturn;\r\n*leddc_on_time = val & 0xff;\r\n*leddc_off_time = (val >> 16) & 0xff;\r\n}\r\nstatic void bcm47xx_nvram_parse_macaddr(char *buf, u8 macaddr[6])\r\n{\r\nif (strchr(buf, ':'))\r\nsscanf(buf, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &macaddr[0],\r\n&macaddr[1], &macaddr[2], &macaddr[3], &macaddr[4],\r\n&macaddr[5]);\r\nelse if (strchr(buf, '-'))\r\nsscanf(buf, "%hhx-%hhx-%hhx-%hhx-%hhx-%hhx", &macaddr[0],\r\n&macaddr[1], &macaddr[2], &macaddr[3], &macaddr[4],\r\n&macaddr[5]);\r\nelse\r\npr_warn("Can not parse mac address: %s\n", buf);\r\n}\r\nstatic void nvram_read_macaddr(const char *prefix, const char *name,\r\nu8 val[6], bool fallback)\r\n{\r\nchar buf[100];\r\nint err;\r\nerr = get_nvram_var(prefix, NULL, name, buf, sizeof(buf), fallback);\r\nif (err < 0)\r\nreturn;\r\nbcm47xx_nvram_parse_macaddr(buf, val);\r\n}\r\nstatic void nvram_read_alpha2(const char *prefix, const char *name,\r\nchar val[2], bool fallback)\r\n{\r\nchar buf[10];\r\nint err;\r\nerr = get_nvram_var(prefix, NULL, name, buf, sizeof(buf), fallback);\r\nif (err < 0)\r\nreturn;\r\nif (buf[0] == '0')\r\nreturn;\r\nif (strlen(buf) > 2) {\r\npr_warn("alpha2 is too long %s\n", buf);\r\nreturn;\r\n}\r\nmemcpy(val, buf, 2);\r\n}\r\nstatic void bcm47xx_sprom_fill_auto(struct ssb_sprom *sprom,\r\nconst char *prefix, bool fallback)\r\n{\r\nconst char *pre = prefix;\r\nbool fb = fallback;\r\nENTRY(0xfffffffe, u16, pre, "devid", dev_id, 0, fallback);\r\nENTRY(0xfffffffe, u16, pre, "boardrev", board_rev, 0, true);\r\nENTRY(0xfffffffe, u32, pre, "boardflags", boardflags, 0, fb);\r\nENTRY(0xfffffff0, u32, pre, "boardflags2", boardflags2, 0, fb);\r\nENTRY(0xfffff800, u32, pre, "boardflags3", boardflags3, 0, fb);\r\nENTRY(0x00000002, u16, pre, "boardflags", boardflags_lo, 0, fb);\r\nENTRY(0xfffffffc, u16, pre, "boardtype", board_type, 0, true);\r\nENTRY(0xfffffffe, u16, pre, "boardnum", board_num, 0, fb);\r\nENTRY(0x00000002, u8, pre, "cc", country_code, 0, fb);\r\nENTRY(0xfffffff8, u8, pre, "regrev", regrev, 0, fb);\r\nENTRY(0xfffffffe, u8, pre, "ledbh0", gpio0, 0xff, fb);\r\nENTRY(0xfffffffe, u8, pre, "ledbh1", gpio1, 0xff, fb);\r\nENTRY(0xfffffffe, u8, pre, "ledbh2", gpio2, 0xff, fb);\r\nENTRY(0xfffffffe, u8, pre, "ledbh3", gpio3, 0xff, fb);\r\nENTRY(0x0000070e, u16, pre, "pa0b0", pa0b0, 0, fb);\r\nENTRY(0x0000070e, u16, pre, "pa0b1", pa0b1, 0, fb);\r\nENTRY(0x0000070e, u16, pre, "pa0b2", pa0b2, 0, fb);\r\nENTRY(0x0000070e, u8, pre, "pa0itssit", itssi_bg, 0, fb);\r\nENTRY(0x0000070e, u8, pre, "pa0maxpwr", maxpwr_bg, 0, fb);\r\nENTRY(0x0000070c, u8, pre, "opo", opo, 0, fb);\r\nENTRY(0xfffffffe, u8, pre, "aa2g", ant_available_bg, 0, fb);\r\nENTRY(0xfffffffe, u8, pre, "aa5g", ant_available_a, 0, fb);\r\nENTRY(0x000007fe, s8, pre, "ag0", antenna_gain.a0, 0, fb);\r\nENTRY(0x000007fe, s8, pre, "ag1", antenna_gain.a1, 0, fb);\r\nENTRY(0x000007f0, s8, pre, "ag2", antenna_gain.a2, 0, fb);\r\nENTRY(0x000007f0, s8, pre, "ag3", antenna_gain.a3, 0, fb);\r\nENTRY(0x0000070e, u16, pre, "pa1b0", pa1b0, 0, fb);\r\nENTRY(0x0000070e, u16, pre, "pa1b1", pa1b1, 0, fb);\r\nENTRY(0x0000070e, u16, pre, "pa1b2", pa1b2, 0, fb);\r\nENTRY(0x0000070c, u16, pre, "pa1lob0", pa1lob0, 0, fb);\r\nENTRY(0x0000070c, u16, pre, "pa1lob1", pa1lob1, 0, fb);\r\nENTRY(0x0000070c, u16, pre, "pa1lob2", pa1lob2, 0, fb);\r\nENTRY(0x0000070c, u16, pre, "pa1hib0", pa1hib0, 0, fb);\r\nENTRY(0x0000070c, u16, pre, "pa1hib1", pa1hib1, 0, fb);\r\nENTRY(0x0000070c, u16, pre, "pa1hib2", pa1hib2, 0, fb);\r\nENTRY(0x0000070e, u8, pre, "pa1itssit", itssi_a, 0, fb);\r\nENTRY(0x0000070e, u8, pre, "pa1maxpwr", maxpwr_a, 0, fb);\r\nENTRY(0x0000070c, u8, pre, "pa1lomaxpwr", maxpwr_al, 0, fb);\r\nENTRY(0x0000070c, u8, pre, "pa1himaxpwr", maxpwr_ah, 0, fb);\r\nENTRY(0x00000708, u8, pre, "bxa2g", bxa2g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "rssisav2g", rssisav2g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "rssismc2g", rssismc2g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "rssismf2g", rssismf2g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "bxa5g", bxa5g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "rssisav5g", rssisav5g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "rssismc5g", rssismc5g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "rssismf5g", rssismf5g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "tri2g", tri2g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "tri5g", tri5g, 0, fb);\r\nENTRY(0x00000708, u8, pre, "tri5gl", tri5gl, 0, fb);\r\nENTRY(0x00000708, u8, pre, "tri5gh", tri5gh, 0, fb);\r\nENTRY(0x00000708, s8, pre, "rxpo2g", rxpo2g, 0, fb);\r\nENTRY(0x00000708, s8, pre, "rxpo5g", rxpo5g, 0, fb);\r\nENTRY(0xfffffff0, u8, pre, "txchain", txchain, 0xf, fb);\r\nENTRY(0xfffffff0, u8, pre, "rxchain", rxchain, 0xf, fb);\r\nENTRY(0xfffffff0, u8, pre, "antswitch", antswitch, 0xff, fb);\r\nENTRY(0x00000700, u8, pre, "tssipos2g", fem.ghz2.tssipos, 0, fb);\r\nENTRY(0x00000700, u8, pre, "extpagain2g", fem.ghz2.extpa_gain, 0, fb);\r\nENTRY(0x00000700, u8, pre, "pdetrange2g", fem.ghz2.pdet_range, 0, fb);\r\nENTRY(0x00000700, u8, pre, "triso2g", fem.ghz2.tr_iso, 0, fb);\r\nENTRY(0x00000700, u8, pre, "antswctl2g", fem.ghz2.antswlut, 0, fb);\r\nENTRY(0x00000700, u8, pre, "tssipos5g", fem.ghz5.tssipos, 0, fb);\r\nENTRY(0x00000700, u8, pre, "extpagain5g", fem.ghz5.extpa_gain, 0, fb);\r\nENTRY(0x00000700, u8, pre, "pdetrange5g", fem.ghz5.pdet_range, 0, fb);\r\nENTRY(0x00000700, u8, pre, "triso5g", fem.ghz5.tr_iso, 0, fb);\r\nENTRY(0x00000700, u8, pre, "antswctl5g", fem.ghz5.antswlut, 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid2ga0", txpid2g[0], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid2ga1", txpid2g[1], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid2ga2", txpid2g[2], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid2ga3", txpid2g[3], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5ga0", txpid5g[0], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5ga1", txpid5g[1], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5ga2", txpid5g[2], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5ga3", txpid5g[3], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5gla0", txpid5gl[0], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5gla1", txpid5gl[1], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5gla2", txpid5gl[2], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5gla3", txpid5gl[3], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5gha0", txpid5gh[0], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5gha1", txpid5gh[1], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5gha2", txpid5gh[2], 0, fb);\r\nENTRY(0x000000f0, u8, pre, "txpid5gha3", txpid5gh[3], 0, fb);\r\nENTRY(0xffffff00, u8, pre, "tempthresh", tempthresh, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "tempoffset", tempoffset, 0, fb);\r\nENTRY(0xffffff00, u16, pre, "rawtempsense", rawtempsense, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "measpower", measpower, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "tempsense_slope", tempsense_slope, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "tempcorrx", tempcorrx, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "tempsense_option", tempsense_option, 0, fb);\r\nENTRY(0x00000700, u8, pre, "freqoffset_corr", freqoffset_corr, 0, fb);\r\nENTRY(0x00000700, u8, pre, "iqcal_swp_dis", iqcal_swp_dis, 0, fb);\r\nENTRY(0x00000700, u8, pre, "hw_iqcal_en", hw_iqcal_en, 0, fb);\r\nENTRY(0x00000700, u8, pre, "elna2g", elna2g, 0, fb);\r\nENTRY(0x00000700, u8, pre, "elna5g", elna5g, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "phycal_tempdelta", phycal_tempdelta, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "temps_period", temps_period, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "temps_hysteresis", temps_hysteresis, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "measpower1", measpower1, 0, fb);\r\nENTRY(0xffffff00, u8, pre, "measpower2", measpower2, 0, fb);\r\nENTRY(0x000001f0, u16, pre, "cck2gpo", cck2gpo, 0, fb);\r\nENTRY(0x000001f0, u32, pre, "ofdm2gpo", ofdm2gpo, 0, fb);\r\nENTRY(0x000001f0, u32, pre, "ofdm5gpo", ofdm5gpo, 0, fb);\r\nENTRY(0x000001f0, u32, pre, "ofdm5glpo", ofdm5glpo, 0, fb);\r\nENTRY(0x000001f0, u32, pre, "ofdm5ghpo", ofdm5ghpo, 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs2gpo0", mcs2gpo[0], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs2gpo1", mcs2gpo[1], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs2gpo2", mcs2gpo[2], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs2gpo3", mcs2gpo[3], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs2gpo4", mcs2gpo[4], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs2gpo5", mcs2gpo[5], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs2gpo6", mcs2gpo[6], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs2gpo7", mcs2gpo[7], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5gpo0", mcs5gpo[0], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5gpo1", mcs5gpo[1], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5gpo2", mcs5gpo[2], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5gpo3", mcs5gpo[3], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5gpo4", mcs5gpo[4], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5gpo5", mcs5gpo[5], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5gpo6", mcs5gpo[6], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5gpo7", mcs5gpo[7], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5glpo0", mcs5glpo[0], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5glpo1", mcs5glpo[1], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5glpo2", mcs5glpo[2], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5glpo3", mcs5glpo[3], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5glpo4", mcs5glpo[4], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5glpo5", mcs5glpo[5], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5glpo6", mcs5glpo[6], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5glpo7", mcs5glpo[7], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5ghpo0", mcs5ghpo[0], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5ghpo1", mcs5ghpo[1], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5ghpo2", mcs5ghpo[2], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5ghpo3", mcs5ghpo[3], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5ghpo4", mcs5ghpo[4], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5ghpo5", mcs5ghpo[5], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5ghpo6", mcs5ghpo[6], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "mcs5ghpo7", mcs5ghpo[7], 0, fb);\r\nENTRY(0x000001f0, u16, pre, "cddpo", cddpo, 0, fb);\r\nENTRY(0x000001f0, u16, pre, "stbcpo", stbcpo, 0, fb);\r\nENTRY(0x000001f0, u16, pre, "bw40po", bw40po, 0, fb);\r\nENTRY(0x000001f0, u16, pre, "bwduppo", bwduppo, 0, fb);\r\nENTRY(0xfffffe00, u16, pre, "cckbw202gpo", cckbw202gpo, 0, fb);\r\nENTRY(0xfffffe00, u16, pre, "cckbw20ul2gpo", cckbw20ul2gpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "legofdmbw202gpo", legofdmbw202gpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "legofdmbw20ul2gpo", legofdmbw20ul2gpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "legofdmbw205glpo", legofdmbw205glpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "legofdmbw20ul5glpo", legofdmbw20ul5glpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "legofdmbw205gmpo", legofdmbw205gmpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "legofdmbw20ul5gmpo", legofdmbw20ul5gmpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "legofdmbw205ghpo", legofdmbw205ghpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "legofdmbw20ul5ghpo", legofdmbw20ul5ghpo, 0, fb);\r\nENTRY(0xfffffe00, u32, pre, "mcsbw202gpo", mcsbw202gpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "mcsbw20ul2gpo", mcsbw20ul2gpo, 0, fb);\r\nENTRY(0xfffffe00, u32, pre, "mcsbw402gpo", mcsbw402gpo, 0, fb);\r\nENTRY(0xfffffe00, u32, pre, "mcsbw205glpo", mcsbw205glpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "mcsbw20ul5glpo", mcsbw20ul5glpo, 0, fb);\r\nENTRY(0xfffffe00, u32, pre, "mcsbw405glpo", mcsbw405glpo, 0, fb);\r\nENTRY(0xfffffe00, u32, pre, "mcsbw205gmpo", mcsbw205gmpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "mcsbw20ul5gmpo", mcsbw20ul5gmpo, 0, fb);\r\nENTRY(0xfffffe00, u32, pre, "mcsbw405gmpo", mcsbw405gmpo, 0, fb);\r\nENTRY(0xfffffe00, u32, pre, "mcsbw205ghpo", mcsbw205ghpo, 0, fb);\r\nENTRY(0x00000600, u32, pre, "mcsbw20ul5ghpo", mcsbw20ul5ghpo, 0, fb);\r\nENTRY(0xfffffe00, u32, pre, "mcsbw405ghpo", mcsbw405ghpo, 0, fb);\r\nENTRY(0x00000600, u16, pre, "mcs32po", mcs32po, 0, fb);\r\nENTRY(0x00000600, u16, pre, "legofdm40duppo", legofdm40duppo, 0, fb);\r\nENTRY(0x00000700, u8, pre, "pcieingress_war", pcieingress_war, 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr2ga0", rxgainerr2ga[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr2ga1", rxgainerr2ga[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr2ga2", rxgainerr2ga[2], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gla0", rxgainerr5gla[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gla1", rxgainerr5gla[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gla2", rxgainerr5gla[2], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gma0", rxgainerr5gma[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gma1", rxgainerr5gma[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gma2", rxgainerr5gma[2], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gha0", rxgainerr5gha[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gha1", rxgainerr5gha[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gha2", rxgainerr5gha[2], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gua0", rxgainerr5gua[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gua1", rxgainerr5gua[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "rxgainerr5gua2", rxgainerr5gua[2], 0, fb);\r\nENTRY(0xfffffe00, u8, pre, "sar2g", sar2g, 0, fb);\r\nENTRY(0xfffffe00, u8, pre, "sar5g", sar5g, 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl2ga0", noiselvl2ga[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl2ga1", noiselvl2ga[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl2ga2", noiselvl2ga[2], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gla0", noiselvl5gla[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gla1", noiselvl5gla[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gla2", noiselvl5gla[2], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gma0", noiselvl5gma[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gma1", noiselvl5gma[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gma2", noiselvl5gma[2], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gha0", noiselvl5gha[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gha1", noiselvl5gha[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gha2", noiselvl5gha[2], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gua0", noiselvl5gua[0], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gua1", noiselvl5gua[1], 0, fb);\r\nENTRY(0x00000700, u8, pre, "noiselvl5gua2", noiselvl5gua[2], 0, fb);\r\n}\r\nstatic void bcm47xx_fill_sprom_path_r4589(struct ssb_sprom *sprom,\r\nconst char *prefix, bool fallback)\r\n{\r\nchar postfix[2];\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(sprom->core_pwr_info); i++) {\r\nstruct ssb_sprom_core_pwr_info *pwr_info;\r\npwr_info = &sprom->core_pwr_info[i];\r\nsnprintf(postfix, sizeof(postfix), "%i", i);\r\nnvram_read_u8(prefix, postfix, "maxp2ga",\r\n&pwr_info->maxpwr_2g, 0, fallback);\r\nnvram_read_u8(prefix, postfix, "itt2ga",\r\n&pwr_info->itssi_2g, 0, fallback);\r\nnvram_read_u8(prefix, postfix, "itt5ga",\r\n&pwr_info->itssi_5g, 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa2gw0a",\r\n&pwr_info->pa_2g[0], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa2gw1a",\r\n&pwr_info->pa_2g[1], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa2gw2a",\r\n&pwr_info->pa_2g[2], 0, fallback);\r\nnvram_read_u8(prefix, postfix, "maxp5ga",\r\n&pwr_info->maxpwr_5g, 0, fallback);\r\nnvram_read_u8(prefix, postfix, "maxp5gha",\r\n&pwr_info->maxpwr_5gh, 0, fallback);\r\nnvram_read_u8(prefix, postfix, "maxp5gla",\r\n&pwr_info->maxpwr_5gl, 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5gw0a",\r\n&pwr_info->pa_5g[0], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5gw1a",\r\n&pwr_info->pa_5g[1], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5gw2a",\r\n&pwr_info->pa_5g[2], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5glw0a",\r\n&pwr_info->pa_5gl[0], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5glw1a",\r\n&pwr_info->pa_5gl[1], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5glw2a",\r\n&pwr_info->pa_5gl[2], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5ghw0a",\r\n&pwr_info->pa_5gh[0], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5ghw1a",\r\n&pwr_info->pa_5gh[1], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5ghw2a",\r\n&pwr_info->pa_5gh[2], 0, fallback);\r\n}\r\n}\r\nstatic void bcm47xx_fill_sprom_path_r45(struct ssb_sprom *sprom,\r\nconst char *prefix, bool fallback)\r\n{\r\nchar postfix[2];\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(sprom->core_pwr_info); i++) {\r\nstruct ssb_sprom_core_pwr_info *pwr_info;\r\npwr_info = &sprom->core_pwr_info[i];\r\nsnprintf(postfix, sizeof(postfix), "%i", i);\r\nnvram_read_u16(prefix, postfix, "pa2gw3a",\r\n&pwr_info->pa_2g[3], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5gw3a",\r\n&pwr_info->pa_5g[3], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5glw3a",\r\n&pwr_info->pa_5gl[3], 0, fallback);\r\nnvram_read_u16(prefix, postfix, "pa5ghw3a",\r\n&pwr_info->pa_5gh[3], 0, fallback);\r\n}\r\n}\r\nstatic bool bcm47xx_is_valid_mac(u8 *mac)\r\n{\r\nreturn mac && !(mac[0] == 0x00 && mac[1] == 0x90 && mac[2] == 0x4c);\r\n}\r\nstatic int bcm47xx_increase_mac_addr(u8 *mac, u8 num)\r\n{\r\nu8 *oui = mac + ETH_ALEN/2 - 1;\r\nu8 *p = mac + ETH_ALEN - 1;\r\ndo {\r\n(*p) += num;\r\nif (*p > num)\r\nbreak;\r\np--;\r\nnum = 1;\r\n} while (p != oui);\r\nif (p == oui) {\r\npr_err("unable to fetch mac address\n");\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm47xx_fill_sprom_ethernet(struct ssb_sprom *sprom,\r\nconst char *prefix, bool fallback)\r\n{\r\nbool fb = fallback;\r\nnvram_read_macaddr(prefix, "et0macaddr", sprom->et0mac, fallback);\r\nnvram_read_u8(prefix, NULL, "et0mdcport", &sprom->et0mdcport, 0,\r\nfallback);\r\nnvram_read_u8(prefix, NULL, "et0phyaddr", &sprom->et0phyaddr, 0,\r\nfallback);\r\nnvram_read_macaddr(prefix, "et1macaddr", sprom->et1mac, fallback);\r\nnvram_read_u8(prefix, NULL, "et1mdcport", &sprom->et1mdcport, 0,\r\nfallback);\r\nnvram_read_u8(prefix, NULL, "et1phyaddr", &sprom->et1phyaddr, 0,\r\nfallback);\r\nnvram_read_macaddr(prefix, "et2macaddr", sprom->et2mac, fb);\r\nnvram_read_u8(prefix, NULL, "et2mdcport", &sprom->et2mdcport, 0, fb);\r\nnvram_read_u8(prefix, NULL, "et2phyaddr", &sprom->et2phyaddr, 0, fb);\r\nnvram_read_macaddr(prefix, "macaddr", sprom->il0mac, fallback);\r\nnvram_read_macaddr(prefix, "il0macaddr", sprom->il0mac, fallback);\r\nif (!bcm47xx_is_valid_mac(sprom->il0mac)) {\r\nu8 mac[6];\r\nnvram_read_macaddr(NULL, "et0macaddr", mac, false);\r\nif (bcm47xx_is_valid_mac(mac)) {\r\nint err = bcm47xx_increase_mac_addr(mac, mac_addr_used);\r\nif (!err) {\r\nether_addr_copy(sprom->il0mac, mac);\r\nmac_addr_used++;\r\n}\r\n}\r\n}\r\n}\r\nstatic void bcm47xx_fill_board_data(struct ssb_sprom *sprom, const char *prefix,\r\nbool fallback)\r\n{\r\nnvram_read_u32_2(prefix, "boardflags", &sprom->boardflags_lo,\r\n&sprom->boardflags_hi, fallback);\r\nnvram_read_u32_2(prefix, "boardflags2", &sprom->boardflags2_lo,\r\n&sprom->boardflags2_hi, fallback);\r\n}\r\nvoid bcm47xx_fill_sprom(struct ssb_sprom *sprom, const char *prefix,\r\nbool fallback)\r\n{\r\nbcm47xx_fill_sprom_ethernet(sprom, prefix, fallback);\r\nbcm47xx_fill_board_data(sprom, prefix, fallback);\r\nnvram_read_u8(prefix, NULL, "sromrev", &sprom->revision, 0, fallback);\r\nnvram_read_alpha2(prefix, "ccode", sprom->alpha2, fallback);\r\nif (sprom->revision >= 3)\r\nnvram_read_leddc(prefix, "leddc", &sprom->leddc_on_time,\r\n&sprom->leddc_off_time, fallback);\r\nswitch (sprom->revision) {\r\ncase 4:\r\ncase 5:\r\nbcm47xx_fill_sprom_path_r4589(sprom, prefix, fallback);\r\nbcm47xx_fill_sprom_path_r45(sprom, prefix, fallback);\r\nbreak;\r\ncase 8:\r\ncase 9:\r\nbcm47xx_fill_sprom_path_r4589(sprom, prefix, fallback);\r\nbreak;\r\n}\r\nbcm47xx_sprom_fill_auto(sprom, prefix, fallback);\r\n}\r\nstatic int bcm47xx_get_sprom_ssb(struct ssb_bus *bus, struct ssb_sprom *out)\r\n{\r\nchar prefix[10];\r\nswitch (bus->bustype) {\r\ncase SSB_BUSTYPE_SSB:\r\nbcm47xx_fill_sprom(out, NULL, false);\r\nreturn 0;\r\ncase SSB_BUSTYPE_PCI:\r\nmemset(out, 0, sizeof(struct ssb_sprom));\r\nsnprintf(prefix, sizeof(prefix), "pci/%u/%u/",\r\nbus->host_pci->bus->number + 1,\r\nPCI_SLOT(bus->host_pci->devfn));\r\nbcm47xx_fill_sprom(out, prefix, false);\r\nreturn 0;\r\ndefault:\r\npr_warn("Unable to fill SPROM for given bustype.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void bcm47xx_sprom_apply_prefix_alias(char *prefix, size_t prefix_size)\r\n{\r\nsize_t prefix_len = strlen(prefix);\r\nsize_t short_len = prefix_len - 1;\r\nchar nvram_var[10];\r\nchar buf[20];\r\nint i;\r\nif (prefix_len <= 0 || prefix[prefix_len - 1] != '/')\r\nreturn;\r\nfor (i = 0; i < 3; i++) {\r\nif (snprintf(nvram_var, sizeof(nvram_var), "devpath%d", i) <= 0)\r\ncontinue;\r\nif (bcm47xx_nvram_getenv(nvram_var, buf, sizeof(buf)) < 0)\r\ncontinue;\r\nif (!strcmp(buf, prefix) ||\r\n(short_len && strlen(buf) == short_len && !strncmp(buf, prefix, short_len))) {\r\nsnprintf(prefix, prefix_size, "%d:", i);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int bcm47xx_get_sprom_bcma(struct bcma_bus *bus, struct ssb_sprom *out)\r\n{\r\nstruct bcma_boardinfo *binfo = &bus->boardinfo;\r\nstruct bcma_device *core;\r\nchar buf[10];\r\nchar *prefix;\r\nbool fallback = false;\r\nswitch (bus->hosttype) {\r\ncase BCMA_HOSTTYPE_PCI:\r\nmemset(out, 0, sizeof(struct ssb_sprom));\r\nif (IS_ENABLED(CONFIG_BCM47XX))\r\nsnprintf(buf, sizeof(buf), "pci/%u/%u/",\r\nbus->host_pci->bus->number + 1,\r\nPCI_SLOT(bus->host_pci->devfn));\r\nelse\r\nsnprintf(buf, sizeof(buf), "pci/%u/%u/",\r\npci_domain_nr(bus->host_pci->bus) + 1,\r\nbus->host_pci->bus->number);\r\nbcm47xx_sprom_apply_prefix_alias(buf, sizeof(buf));\r\nprefix = buf;\r\nbreak;\r\ncase BCMA_HOSTTYPE_SOC:\r\nmemset(out, 0, sizeof(struct ssb_sprom));\r\ncore = bcma_find_core(bus, BCMA_CORE_80211);\r\nif (core) {\r\nsnprintf(buf, sizeof(buf), "sb/%u/",\r\ncore->core_index);\r\nprefix = buf;\r\nfallback = true;\r\n} else {\r\nprefix = NULL;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("Unable to fill SPROM for given bustype.\n");\r\nreturn -EINVAL;\r\n}\r\nnvram_read_u16(prefix, NULL, "boardvendor", &binfo->vendor, 0, true);\r\nif (!binfo->vendor)\r\nbinfo->vendor = SSB_BOARDVENDOR_BCM;\r\nnvram_read_u16(prefix, NULL, "boardtype", &binfo->type, 0, true);\r\nbcm47xx_fill_sprom(out, prefix, fallback);\r\nreturn 0;\r\n}\r\nint bcm47xx_sprom_register_fallbacks(void)\r\n{\r\nif (bcm47xx_sprom_registered)\r\nreturn 0;\r\n#if IS_BUILTIN(CONFIG_SSB) && IS_ENABLED(CONFIG_SSB_SPROM)\r\nif (ssb_arch_register_fallback_sprom(&bcm47xx_get_sprom_ssb))\r\npr_warn("Failed to register ssb SPROM handler\n");\r\n#endif\r\n#if IS_BUILTIN(CONFIG_BCMA)\r\nif (bcma_arch_register_fallback_sprom(&bcm47xx_get_sprom_bcma))\r\npr_warn("Failed to register bcma SPROM handler\n");\r\n#endif\r\nbcm47xx_sprom_registered = 1;\r\nreturn 0;\r\n}
