static inline int coda_is_initialized(struct coda_dev *dev)\r\n{\r\nreturn coda_read(dev, CODA_REG_BIT_CUR_PC) != 0;\r\n}\r\nstatic inline unsigned long coda_isbusy(struct coda_dev *dev)\r\n{\r\nreturn coda_read(dev, CODA_REG_BIT_BUSY);\r\n}\r\nstatic int coda_wait_timeout(struct coda_dev *dev)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nwhile (coda_isbusy(dev)) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void coda_command_async(struct coda_ctx *ctx, int cmd)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nif (dev->devtype->product == CODA_960 ||\r\ndev->devtype->product == CODA_7541) {\r\ncoda_write(dev, ctx->bit_stream_param,\r\nCODA_REG_BIT_BIT_STREAM_PARAM);\r\ncoda_write(dev, ctx->frm_dis_flg,\r\nCODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\r\ncoda_write(dev, ctx->frame_mem_ctrl,\r\nCODA_REG_BIT_FRAME_MEM_CTRL);\r\ncoda_write(dev, ctx->workbuf.paddr, CODA_REG_BIT_WORK_BUF_ADDR);\r\n}\r\nif (dev->devtype->product == CODA_960) {\r\ncoda_write(dev, 1, CODA9_GDI_WPROT_ERR_CLR);\r\ncoda_write(dev, 0, CODA9_GDI_WPROT_RGN_EN);\r\n}\r\ncoda_write(dev, CODA_REG_BIT_BUSY_FLAG, CODA_REG_BIT_BUSY);\r\ncoda_write(dev, ctx->idx, CODA_REG_BIT_RUN_INDEX);\r\ncoda_write(dev, ctx->params.codec_mode, CODA_REG_BIT_RUN_COD_STD);\r\ncoda_write(dev, ctx->params.codec_mode_aux, CODA7_REG_BIT_RUN_AUX_STD);\r\ntrace_coda_bit_run(ctx, cmd);\r\ncoda_write(dev, cmd, CODA_REG_BIT_RUN_COMMAND);\r\n}\r\nstatic int coda_command_sync(struct coda_ctx *ctx, int cmd)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nint ret;\r\ncoda_command_async(ctx, cmd);\r\nret = coda_wait_timeout(dev);\r\ntrace_coda_bit_done(ctx);\r\nreturn ret;\r\n}\r\nint coda_hw_reset(struct coda_ctx *ctx)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nunsigned long timeout;\r\nunsigned int idx;\r\nint ret;\r\nif (!dev->rstc)\r\nreturn -ENOENT;\r\nidx = coda_read(dev, CODA_REG_BIT_RUN_INDEX);\r\nif (dev->devtype->product == CODA_960) {\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\ncoda_write(dev, 0x11, CODA9_GDI_BUS_CTRL);\r\nwhile (coda_read(dev, CODA9_GDI_BUS_STATUS) != 0x77) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIME;\r\ncpu_relax();\r\n}\r\n}\r\nret = reset_control_reset(dev->rstc);\r\nif (ret < 0)\r\nreturn ret;\r\nif (dev->devtype->product == CODA_960)\r\ncoda_write(dev, 0x00, CODA9_GDI_BUS_CTRL);\r\ncoda_write(dev, CODA_REG_BIT_BUSY_FLAG, CODA_REG_BIT_BUSY);\r\ncoda_write(dev, CODA_REG_RUN_ENABLE, CODA_REG_BIT_CODE_RUN);\r\nret = coda_wait_timeout(dev);\r\ncoda_write(dev, idx, CODA_REG_BIT_RUN_INDEX);\r\nreturn ret;\r\n}\r\nstatic void coda_kfifo_sync_from_device(struct coda_ctx *ctx)\r\n{\r\nstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 rd_ptr;\r\nrd_ptr = coda_read(dev, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\r\nkfifo->out = (kfifo->in & ~kfifo->mask) |\r\n(rd_ptr - ctx->bitstream.paddr);\r\nif (kfifo->out > kfifo->in)\r\nkfifo->out -= kfifo->mask + 1;\r\n}\r\nstatic void coda_kfifo_sync_to_device_full(struct coda_ctx *ctx)\r\n{\r\nstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 rd_ptr, wr_ptr;\r\nrd_ptr = ctx->bitstream.paddr + (kfifo->out & kfifo->mask);\r\ncoda_write(dev, rd_ptr, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\r\nwr_ptr = ctx->bitstream.paddr + (kfifo->in & kfifo->mask);\r\ncoda_write(dev, wr_ptr, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\r\n}\r\nstatic void coda_kfifo_sync_to_device_write(struct coda_ctx *ctx)\r\n{\r\nstruct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 wr_ptr;\r\nwr_ptr = ctx->bitstream.paddr + (kfifo->in & kfifo->mask);\r\ncoda_write(dev, wr_ptr, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\r\n}\r\nstatic int coda_bitstream_queue(struct coda_ctx *ctx,\r\nstruct vb2_v4l2_buffer *src_buf)\r\n{\r\nu32 src_size = vb2_get_plane_payload(&src_buf->vb2_buf, 0);\r\nu32 n;\r\nn = kfifo_in(&ctx->bitstream_fifo,\r\nvb2_plane_vaddr(&src_buf->vb2_buf, 0), src_size);\r\nif (n < src_size)\r\nreturn -ENOSPC;\r\nsrc_buf->sequence = ctx->qsequence++;\r\nreturn 0;\r\n}\r\nstatic bool coda_bitstream_try_queue(struct coda_ctx *ctx,\r\nstruct vb2_v4l2_buffer *src_buf)\r\n{\r\nint ret;\r\nif (coda_get_bitstream_payload(ctx) +\r\nvb2_get_plane_payload(&src_buf->vb2_buf, 0) + 512 >=\r\nctx->bitstream.size)\r\nreturn false;\r\nif (vb2_plane_vaddr(&src_buf->vb2_buf, 0) == NULL) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "trying to queue empty buffer\n");\r\nreturn true;\r\n}\r\nret = coda_bitstream_queue(ctx, src_buf);\r\nif (ret < 0) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "bitstream buffer overflow\n");\r\nreturn false;\r\n}\r\nif (ctx == v4l2_m2m_get_curr_priv(ctx->dev->m2m_dev))\r\ncoda_kfifo_sync_to_device_write(ctx);\r\nctx->hold = false;\r\nreturn true;\r\n}\r\nvoid coda_fill_bitstream(struct coda_ctx *ctx, bool streaming)\r\n{\r\nstruct vb2_v4l2_buffer *src_buf;\r\nstruct coda_buffer_meta *meta;\r\nunsigned long flags;\r\nu32 start;\r\nif (ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG)\r\nreturn;\r\nwhile (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) > 0) {\r\nif (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG &&\r\n(coda_get_bitstream_payload(ctx) >= 512) && !ctx->hold)\r\nbreak;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\nif (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG &&\r\n!coda_jpeg_check_buffer(ctx, &src_buf->vb2_buf)) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"dropping invalid JPEG frame %d\n",\r\nctx->qsequence);\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nv4l2_m2m_buf_done(src_buf, streaming ?\r\nVB2_BUF_STATE_ERROR :\r\nVB2_BUF_STATE_QUEUED);\r\ncontinue;\r\n}\r\nif (!vb2_get_plane_payload(&src_buf->vb2_buf, 0)) {\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\r\ncontinue;\r\n}\r\nstart = ctx->bitstream_fifo.kfifo.in &\r\nctx->bitstream_fifo.kfifo.mask;\r\nif (coda_bitstream_try_queue(ctx, src_buf)) {\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nmeta = kmalloc(sizeof(*meta), GFP_KERNEL);\r\nif (meta) {\r\nmeta->sequence = src_buf->sequence;\r\nmeta->timecode = src_buf->timecode;\r\nmeta->timestamp = src_buf->vb2_buf.timestamp;\r\nmeta->start = start;\r\nmeta->end = ctx->bitstream_fifo.kfifo.in &\r\nctx->bitstream_fifo.kfifo.mask;\r\nspin_lock_irqsave(&ctx->buffer_meta_lock,\r\nflags);\r\nlist_add_tail(&meta->list,\r\n&ctx->buffer_meta_list);\r\nctx->num_metas++;\r\nspin_unlock_irqrestore(&ctx->buffer_meta_lock,\r\nflags);\r\ntrace_coda_bit_queue(ctx, src_buf, meta);\r\n}\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid coda_bit_stream_end_flag(struct coda_ctx *ctx)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;\r\nif ((dev->devtype->product == CODA_960) &&\r\ncoda_isbusy(dev) &&\r\n(ctx->idx == coda_read(dev, CODA_REG_BIT_RUN_INDEX))) {\r\ncoda_write(dev, ctx->bit_stream_param,\r\nCODA_REG_BIT_BIT_STREAM_PARAM);\r\n}\r\n}\r\nstatic void coda_parabuf_write(struct coda_ctx *ctx, int index, u32 value)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 *p = ctx->parabuf.vaddr;\r\nif (dev->devtype->product == CODA_DX6)\r\np[index] = value;\r\nelse\r\np[index ^ 1] = value;\r\n}\r\nstatic inline int coda_alloc_context_buf(struct coda_ctx *ctx,\r\nstruct coda_aux_buf *buf, size_t size,\r\nconst char *name)\r\n{\r\nreturn coda_alloc_aux_buf(ctx->dev, buf, size, name, ctx->debugfs_entry);\r\n}\r\nstatic void coda_free_framebuffers(struct coda_ctx *ctx)\r\n{\r\nint i;\r\nfor (i = 0; i < CODA_MAX_FRAMEBUFFERS; i++)\r\ncoda_free_aux_buf(ctx->dev, &ctx->internal_frames[i]);\r\n}\r\nstatic int coda_alloc_framebuffers(struct coda_ctx *ctx,\r\nstruct coda_q_data *q_data, u32 fourcc)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nint width, height;\r\nint ysize;\r\nint ret;\r\nint i;\r\nif (ctx->codec && (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 ||\r\nctx->codec->dst_fourcc == V4L2_PIX_FMT_H264)) {\r\nwidth = round_up(q_data->width, 16);\r\nheight = round_up(q_data->height, 16);\r\n} else {\r\nwidth = round_up(q_data->width, 8);\r\nheight = q_data->height;\r\n}\r\nysize = width * height;\r\nfor (i = 0; i < ctx->num_internal_frames; i++) {\r\nsize_t size;\r\nchar *name;\r\nif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP)\r\nsize = round_up(ysize, 4096) + ysize / 2;\r\nelse\r\nsize = ysize + ysize / 2;\r\nif (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 &&\r\ndev->devtype->product != CODA_DX6)\r\nsize += ysize / 4;\r\nname = kasprintf(GFP_KERNEL, "fb%d", i);\r\nret = coda_alloc_context_buf(ctx, &ctx->internal_frames[i],\r\nsize, name);\r\nkfree(name);\r\nif (ret < 0) {\r\ncoda_free_framebuffers(ctx);\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < ctx->num_internal_frames; i++) {\r\nu32 y, cb, cr;\r\ny = ctx->internal_frames[i].paddr;\r\ncb = y + ysize;\r\ncr = y + ysize + ysize/4;\r\nif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP) {\r\ncb = round_up(cb, 4096);\r\ncr = 0;\r\ny = (y & 0xfffff000) | cb >> 20;\r\ncb = (cb & 0x000ff000) << 12;\r\n}\r\ncoda_parabuf_write(ctx, i * 3 + 0, y);\r\ncoda_parabuf_write(ctx, i * 3 + 1, cb);\r\ncoda_parabuf_write(ctx, i * 3 + 2, cr);\r\nif (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 &&\r\ndev->devtype->product != CODA_DX6)\r\ncoda_parabuf_write(ctx, 96 + i,\r\nctx->internal_frames[i].paddr +\r\nysize + ysize/4 + ysize/4);\r\n}\r\nif ((dev->devtype->product != CODA_DX6) &&\r\n(ctx->codec->src_fourcc == V4L2_PIX_FMT_MPEG4))\r\ncoda_parabuf_write(ctx, 97, ctx->internal_frames[0].paddr +\r\nysize + ysize/4 + ysize/4);\r\nreturn 0;\r\n}\r\nstatic void coda_free_context_buffers(struct coda_ctx *ctx)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\ncoda_free_aux_buf(dev, &ctx->slicebuf);\r\ncoda_free_aux_buf(dev, &ctx->psbuf);\r\nif (dev->devtype->product != CODA_DX6)\r\ncoda_free_aux_buf(dev, &ctx->workbuf);\r\ncoda_free_aux_buf(dev, &ctx->parabuf);\r\n}\r\nstatic int coda_alloc_context_buffers(struct coda_ctx *ctx,\r\nstruct coda_q_data *q_data)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nsize_t size;\r\nint ret;\r\nif (!ctx->parabuf.vaddr) {\r\nret = coda_alloc_context_buf(ctx, &ctx->parabuf,\r\nCODA_PARA_BUF_SIZE, "parabuf");\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (dev->devtype->product == CODA_DX6)\r\nreturn 0;\r\nif (!ctx->slicebuf.vaddr && q_data->fourcc == V4L2_PIX_FMT_H264) {\r\nsize = (DIV_ROUND_UP(q_data->width, 16) *\r\nDIV_ROUND_UP(q_data->height, 16)) * 3200 / 8 + 512;\r\nret = coda_alloc_context_buf(ctx, &ctx->slicebuf, size,\r\n"slicebuf");\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (!ctx->psbuf.vaddr && dev->devtype->product == CODA_7541) {\r\nret = coda_alloc_context_buf(ctx, &ctx->psbuf,\r\nCODA7_PS_BUF_SIZE, "psbuf");\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (!ctx->workbuf.vaddr) {\r\nsize = dev->devtype->workbuf_size;\r\nif (dev->devtype->product == CODA_960 &&\r\nq_data->fourcc == V4L2_PIX_FMT_H264)\r\nsize += CODA9_PS_SAVE_SIZE;\r\nret = coda_alloc_context_buf(ctx, &ctx->workbuf, size,\r\n"workbuf");\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ncoda_free_context_buffers(ctx);\r\nreturn ret;\r\n}\r\nstatic int coda_encode_header(struct coda_ctx *ctx, struct vb2_v4l2_buffer *buf,\r\nint header_code, u8 *header, int *size)\r\n{\r\nstruct vb2_buffer *vb = &buf->vb2_buf;\r\nstruct coda_dev *dev = ctx->dev;\r\nsize_t bufsize;\r\nint ret;\r\nint i;\r\nif (dev->devtype->product == CODA_960)\r\nmemset(vb2_plane_vaddr(vb, 0), 0, 64);\r\ncoda_write(dev, vb2_dma_contig_plane_dma_addr(vb, 0),\r\nCODA_CMD_ENC_HEADER_BB_START);\r\nbufsize = vb2_plane_size(vb, 0);\r\nif (dev->devtype->product == CODA_960)\r\nbufsize /= 1024;\r\ncoda_write(dev, bufsize, CODA_CMD_ENC_HEADER_BB_SIZE);\r\ncoda_write(dev, header_code, CODA_CMD_ENC_HEADER_CODE);\r\nret = coda_command_sync(ctx, CODA_COMMAND_ENCODE_HEADER);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "CODA_COMMAND_ENCODE_HEADER timeout\n");\r\nreturn ret;\r\n}\r\nif (dev->devtype->product == CODA_960) {\r\nfor (i = 63; i > 0; i--)\r\nif (((char *)vb2_plane_vaddr(vb, 0))[i] != 0)\r\nbreak;\r\n*size = i + 1;\r\n} else {\r\n*size = coda_read(dev, CODA_REG_BIT_WR_PTR(ctx->reg_idx)) -\r\ncoda_read(dev, CODA_CMD_ENC_HEADER_BB_START);\r\n}\r\nmemcpy(header, vb2_plane_vaddr(vb, 0), *size);\r\nreturn 0;\r\n}\r\nstatic phys_addr_t coda_iram_alloc(struct coda_iram_info *iram, size_t size)\r\n{\r\nphys_addr_t ret;\r\nsize = round_up(size, 1024);\r\nif (size > iram->remaining)\r\nreturn 0;\r\niram->remaining -= size;\r\nret = iram->next_paddr;\r\niram->next_paddr += size;\r\nreturn ret;\r\n}\r\nstatic void coda_setup_iram(struct coda_ctx *ctx)\r\n{\r\nstruct coda_iram_info *iram_info = &ctx->iram_info;\r\nstruct coda_dev *dev = ctx->dev;\r\nint w64, w128;\r\nint mb_width;\r\nint dbk_bits;\r\nint bit_bits;\r\nint ip_bits;\r\nmemset(iram_info, 0, sizeof(*iram_info));\r\niram_info->next_paddr = dev->iram.paddr;\r\niram_info->remaining = dev->iram.size;\r\nif (!dev->iram.vaddr)\r\nreturn;\r\nswitch (dev->devtype->product) {\r\ncase CODA_7541:\r\ndbk_bits = CODA7_USE_HOST_DBK_ENABLE | CODA7_USE_DBK_ENABLE;\r\nbit_bits = CODA7_USE_HOST_BIT_ENABLE | CODA7_USE_BIT_ENABLE;\r\nip_bits = CODA7_USE_HOST_IP_ENABLE | CODA7_USE_IP_ENABLE;\r\nbreak;\r\ncase CODA_960:\r\ndbk_bits = CODA9_USE_HOST_DBK_ENABLE | CODA9_USE_DBK_ENABLE;\r\nbit_bits = CODA9_USE_HOST_BIT_ENABLE | CODA7_USE_BIT_ENABLE;\r\nip_bits = CODA9_USE_HOST_IP_ENABLE | CODA7_USE_IP_ENABLE;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (ctx->inst_type == CODA_INST_ENCODER) {\r\nstruct coda_q_data *q_data_src;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nmb_width = DIV_ROUND_UP(q_data_src->width, 16);\r\nw128 = mb_width * 128;\r\nw64 = mb_width * 64;\r\nif (dev->devtype->product == CODA_7541) {\r\niram_info->search_ram_size = round_up(mb_width * 16 *\r\n36 + 2048, 1024);\r\niram_info->search_ram_paddr = coda_iram_alloc(iram_info,\r\niram_info->search_ram_size);\r\nif (!iram_info->search_ram_paddr) {\r\npr_err("IRAM is smaller than the search ram size\n");\r\ngoto out;\r\n}\r\niram_info->axi_sram_use |= CODA7_USE_HOST_ME_ENABLE |\r\nCODA7_USE_ME_ENABLE;\r\n}\r\niram_info->buf_dbk_y_use = coda_iram_alloc(iram_info, w64);\r\niram_info->buf_dbk_c_use = coda_iram_alloc(iram_info, w64);\r\nif (!iram_info->buf_dbk_c_use)\r\ngoto out;\r\niram_info->axi_sram_use |= dbk_bits;\r\niram_info->buf_bit_use = coda_iram_alloc(iram_info, w128);\r\nif (!iram_info->buf_bit_use)\r\ngoto out;\r\niram_info->axi_sram_use |= bit_bits;\r\niram_info->buf_ip_ac_dc_use = coda_iram_alloc(iram_info, w128);\r\nif (!iram_info->buf_ip_ac_dc_use)\r\ngoto out;\r\niram_info->axi_sram_use |= ip_bits;\r\n} else if (ctx->inst_type == CODA_INST_DECODER) {\r\nstruct coda_q_data *q_data_dst;\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nmb_width = DIV_ROUND_UP(q_data_dst->width, 16);\r\nw128 = mb_width * 128;\r\niram_info->buf_dbk_y_use = coda_iram_alloc(iram_info, w128);\r\niram_info->buf_dbk_c_use = coda_iram_alloc(iram_info, w128);\r\nif (!iram_info->buf_dbk_c_use)\r\ngoto out;\r\niram_info->axi_sram_use |= dbk_bits;\r\niram_info->buf_bit_use = coda_iram_alloc(iram_info, w128);\r\nif (!iram_info->buf_bit_use)\r\ngoto out;\r\niram_info->axi_sram_use |= bit_bits;\r\niram_info->buf_ip_ac_dc_use = coda_iram_alloc(iram_info, w128);\r\nif (!iram_info->buf_ip_ac_dc_use)\r\ngoto out;\r\niram_info->axi_sram_use |= ip_bits;\r\n}\r\nout:\r\nif (!(iram_info->axi_sram_use & CODA7_USE_HOST_IP_ENABLE))\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"IRAM smaller than needed\n");\r\nif (dev->devtype->product == CODA_7541) {\r\nif (ctx->inst_type == CODA_INST_DECODER) {\r\niram_info->axi_sram_use &= ~(CODA7_USE_HOST_IP_ENABLE |\r\nCODA7_USE_IP_ENABLE);\r\n} else {\r\niram_info->axi_sram_use &= ~(CODA7_USE_HOST_IP_ENABLE |\r\nCODA7_USE_HOST_DBK_ENABLE |\r\nCODA7_USE_IP_ENABLE |\r\nCODA7_USE_DBK_ENABLE);\r\n}\r\n}\r\n}\r\nstatic bool coda_firmware_supported(u32 vernum)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(coda_supported_firmwares); i++)\r\nif (vernum == coda_supported_firmwares[i])\r\nreturn true;\r\nreturn false;\r\n}\r\nint coda_check_firmware(struct coda_dev *dev)\r\n{\r\nu16 product, major, minor, release;\r\nu32 data;\r\nint ret;\r\nret = clk_prepare_enable(dev->clk_per);\r\nif (ret)\r\ngoto err_clk_per;\r\nret = clk_prepare_enable(dev->clk_ahb);\r\nif (ret)\r\ngoto err_clk_ahb;\r\ncoda_write(dev, 0, CODA_CMD_FIRMWARE_VERNUM);\r\ncoda_write(dev, CODA_REG_BIT_BUSY_FLAG, CODA_REG_BIT_BUSY);\r\ncoda_write(dev, 0, CODA_REG_BIT_RUN_INDEX);\r\ncoda_write(dev, 0, CODA_REG_BIT_RUN_COD_STD);\r\ncoda_write(dev, CODA_COMMAND_FIRMWARE_GET, CODA_REG_BIT_RUN_COMMAND);\r\nif (coda_wait_timeout(dev)) {\r\nv4l2_err(&dev->v4l2_dev, "firmware get command error\n");\r\nret = -EIO;\r\ngoto err_run_cmd;\r\n}\r\nif (dev->devtype->product == CODA_960) {\r\ndata = coda_read(dev, CODA9_CMD_FIRMWARE_CODE_REV);\r\nv4l2_info(&dev->v4l2_dev, "Firmware code revision: %d\n",\r\ndata);\r\n}\r\ndata = coda_read(dev, CODA_CMD_FIRMWARE_VERNUM);\r\nproduct = CODA_FIRMWARE_PRODUCT(data);\r\nmajor = CODA_FIRMWARE_MAJOR(data);\r\nminor = CODA_FIRMWARE_MINOR(data);\r\nrelease = CODA_FIRMWARE_RELEASE(data);\r\nclk_disable_unprepare(dev->clk_per);\r\nclk_disable_unprepare(dev->clk_ahb);\r\nif (product != dev->devtype->product) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"Wrong firmware. Hw: %s, Fw: %s, Version: %u.%u.%u\n",\r\ncoda_product_name(dev->devtype->product),\r\ncoda_product_name(product), major, minor, release);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(&dev->v4l2_dev, "Initialized %s.\n",\r\ncoda_product_name(product));\r\nif (coda_firmware_supported(data)) {\r\nv4l2_info(&dev->v4l2_dev, "Firmware version: %u.%u.%u\n",\r\nmajor, minor, release);\r\n} else {\r\nv4l2_warn(&dev->v4l2_dev,\r\n"Unsupported firmware version: %u.%u.%u\n",\r\nmajor, minor, release);\r\n}\r\nreturn 0;\r\nerr_run_cmd:\r\nclk_disable_unprepare(dev->clk_ahb);\r\nerr_clk_ahb:\r\nclk_disable_unprepare(dev->clk_per);\r\nerr_clk_per:\r\nreturn ret;\r\n}\r\nstatic void coda9_set_frame_cache(struct coda_ctx *ctx, u32 fourcc)\r\n{\r\nu32 cache_size, cache_config;\r\nif (ctx->tiled_map_type == GDI_LINEAR_FRAME_MAP) {\r\ncache_size = 0x20262024;\r\ncache_config = 2 << CODA9_CACHE_PAGEMERGE_OFFSET;\r\n} else {\r\ncache_size = 0x02440243;\r\ncache_config = 1 << CODA9_CACHE_PAGEMERGE_OFFSET;\r\n}\r\ncoda_write(ctx->dev, cache_size, CODA9_CMD_SET_FRAME_CACHE_SIZE);\r\nif (fourcc == V4L2_PIX_FMT_NV12) {\r\ncache_config |= 32 << CODA9_CACHE_LUMA_BUFFER_SIZE_OFFSET |\r\n16 << CODA9_CACHE_CR_BUFFER_SIZE_OFFSET |\r\n0 << CODA9_CACHE_CB_BUFFER_SIZE_OFFSET;\r\n} else {\r\ncache_config |= 32 << CODA9_CACHE_LUMA_BUFFER_SIZE_OFFSET |\r\n8 << CODA9_CACHE_CR_BUFFER_SIZE_OFFSET |\r\n8 << CODA9_CACHE_CB_BUFFER_SIZE_OFFSET;\r\n}\r\ncoda_write(ctx->dev, cache_config, CODA9_CMD_SET_FRAME_CACHE_CONFIG);\r\n}\r\nstatic int coda_encoder_reqbufs(struct coda_ctx *ctx,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct coda_q_data *q_data_src;\r\nint ret;\r\nif (rb->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn 0;\r\nif (rb->count) {\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nret = coda_alloc_context_buffers(ctx, q_data_src);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\ncoda_free_context_buffers(ctx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int coda_start_encoding(struct coda_ctx *ctx)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2_dev;\r\nstruct coda_q_data *q_data_src, *q_data_dst;\r\nu32 bitstream_buf, bitstream_size;\r\nstruct vb2_v4l2_buffer *buf;\r\nint gamma, ret, value;\r\nu32 dst_fourcc;\r\nint num_fb;\r\nu32 stride;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\ndst_fourcc = q_data_dst->fourcc;\r\nbuf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nbitstream_buf = vb2_dma_contig_plane_dma_addr(&buf->vb2_buf, 0);\r\nbitstream_size = q_data_dst->sizeimage;\r\nif (!coda_is_initialized(dev)) {\r\nv4l2_err(v4l2_dev, "coda is not initialized.\n");\r\nreturn -EFAULT;\r\n}\r\nif (dst_fourcc == V4L2_PIX_FMT_JPEG) {\r\nif (!ctx->params.jpeg_qmat_tab[0])\r\nctx->params.jpeg_qmat_tab[0] = kmalloc(64, GFP_KERNEL);\r\nif (!ctx->params.jpeg_qmat_tab[1])\r\nctx->params.jpeg_qmat_tab[1] = kmalloc(64, GFP_KERNEL);\r\ncoda_set_jpeg_compression_quality(ctx, ctx->params.jpeg_quality);\r\n}\r\nmutex_lock(&dev->coda_mutex);\r\ncoda_write(dev, ctx->parabuf.paddr, CODA_REG_BIT_PARA_BUF_ADDR);\r\ncoda_write(dev, bitstream_buf, CODA_REG_BIT_RD_PTR(ctx->reg_idx));\r\ncoda_write(dev, bitstream_buf, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\ncoda_write(dev, CODADX6_STREAM_BUF_DYNALLOC_EN |\r\nCODADX6_STREAM_BUF_PIC_RESET, CODA_REG_BIT_STREAM_CTRL);\r\nbreak;\r\ncase CODA_960:\r\ncoda_write(dev, 0, CODA9_GDI_WPROT_RGN_EN);\r\ncase CODA_7541:\r\ncoda_write(dev, CODA7_STREAM_BUF_DYNALLOC_EN |\r\nCODA7_STREAM_BUF_PIC_RESET, CODA_REG_BIT_STREAM_CTRL);\r\nbreak;\r\n}\r\nctx->frame_mem_ctrl &= ~(CODA_FRAME_CHROMA_INTERLEAVE | (0x3 << 9) |\r\nCODA9_FRAME_TILED2LINEAR);\r\nif (q_data_src->fourcc == V4L2_PIX_FMT_NV12)\r\nctx->frame_mem_ctrl |= CODA_FRAME_CHROMA_INTERLEAVE;\r\nif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP)\r\nctx->frame_mem_ctrl |= (0x3 << 9) | CODA9_FRAME_TILED2LINEAR;\r\ncoda_write(dev, ctx->frame_mem_ctrl, CODA_REG_BIT_FRAME_MEM_CTRL);\r\nif (dev->devtype->product == CODA_DX6) {\r\ncoda_write(dev, dev->iram.paddr,\r\nCODADX6_REG_BIT_SEARCH_RAM_BASE_ADDR);\r\n}\r\nvalue = 0;\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\nvalue = (q_data_src->width & CODADX6_PICWIDTH_MASK)\r\n<< CODADX6_PICWIDTH_OFFSET;\r\nvalue |= (q_data_src->height & CODADX6_PICHEIGHT_MASK)\r\n<< CODA_PICHEIGHT_OFFSET;\r\nbreak;\r\ncase CODA_7541:\r\nif (dst_fourcc == V4L2_PIX_FMT_H264) {\r\nvalue = (round_up(q_data_src->width, 16) &\r\nCODA7_PICWIDTH_MASK) << CODA7_PICWIDTH_OFFSET;\r\nvalue |= (round_up(q_data_src->height, 16) &\r\nCODA7_PICHEIGHT_MASK) << CODA_PICHEIGHT_OFFSET;\r\nbreak;\r\n}\r\ncase CODA_960:\r\nvalue = (q_data_src->width & CODA7_PICWIDTH_MASK)\r\n<< CODA7_PICWIDTH_OFFSET;\r\nvalue |= (q_data_src->height & CODA7_PICHEIGHT_MASK)\r\n<< CODA_PICHEIGHT_OFFSET;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_SRC_SIZE);\r\nif (dst_fourcc == V4L2_PIX_FMT_JPEG)\r\nctx->params.framerate = 0;\r\ncoda_write(dev, ctx->params.framerate,\r\nCODA_CMD_ENC_SEQ_SRC_F_RATE);\r\nctx->params.codec_mode = ctx->codec->mode;\r\nswitch (dst_fourcc) {\r\ncase V4L2_PIX_FMT_MPEG4:\r\nif (dev->devtype->product == CODA_960)\r\ncoda_write(dev, CODA9_STD_MPEG4,\r\nCODA_CMD_ENC_SEQ_COD_STD);\r\nelse\r\ncoda_write(dev, CODA_STD_MPEG4,\r\nCODA_CMD_ENC_SEQ_COD_STD);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_MP4_PARA);\r\nbreak;\r\ncase V4L2_PIX_FMT_H264:\r\nif (dev->devtype->product == CODA_960)\r\ncoda_write(dev, CODA9_STD_H264,\r\nCODA_CMD_ENC_SEQ_COD_STD);\r\nelse\r\ncoda_write(dev, CODA_STD_H264,\r\nCODA_CMD_ENC_SEQ_COD_STD);\r\nif (ctx->params.h264_deblk_enabled) {\r\nvalue = ((ctx->params.h264_deblk_alpha &\r\nCODA_264PARAM_DEBLKFILTEROFFSETALPHA_MASK) <<\r\nCODA_264PARAM_DEBLKFILTEROFFSETALPHA_OFFSET) |\r\n((ctx->params.h264_deblk_beta &\r\nCODA_264PARAM_DEBLKFILTEROFFSETBETA_MASK) <<\r\nCODA_264PARAM_DEBLKFILTEROFFSETBETA_OFFSET);\r\n} else {\r\nvalue = 1 << CODA_264PARAM_DISABLEDEBLK_OFFSET;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_264_PARA);\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_JPG_PARA);\r\ncoda_write(dev, ctx->params.jpeg_restart_interval,\r\nCODA_CMD_ENC_SEQ_JPG_RST_INTERVAL);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_JPG_THUMB_EN);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_JPG_THUMB_SIZE);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_JPG_THUMB_OFFSET);\r\ncoda_jpeg_write_tables(ctx);\r\nbreak;\r\ndefault:\r\nv4l2_err(v4l2_dev,\r\n"dst format (0x%08x) invalid.\n", dst_fourcc);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (dst_fourcc != V4L2_PIX_FMT_JPEG) {\r\nswitch (ctx->params.slice_mode) {\r\ncase V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE:\r\nvalue = 0;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB:\r\nvalue = (ctx->params.slice_max_mb &\r\nCODA_SLICING_SIZE_MASK)\r\n<< CODA_SLICING_SIZE_OFFSET;\r\nvalue |= (1 & CODA_SLICING_UNIT_MASK)\r\n<< CODA_SLICING_UNIT_OFFSET;\r\nvalue |= 1 & CODA_SLICING_MODE_MASK;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES:\r\nvalue = (ctx->params.slice_max_bits &\r\nCODA_SLICING_SIZE_MASK)\r\n<< CODA_SLICING_SIZE_OFFSET;\r\nvalue |= (0 & CODA_SLICING_UNIT_MASK)\r\n<< CODA_SLICING_UNIT_OFFSET;\r\nvalue |= 1 & CODA_SLICING_MODE_MASK;\r\nbreak;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_SLICE_MODE);\r\nvalue = ctx->params.gop_size & CODA_GOP_SIZE_MASK;\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_GOP_SIZE);\r\n}\r\nif (ctx->params.bitrate) {\r\nvalue = (ctx->params.bitrate & CODA_RATECONTROL_BITRATE_MASK)\r\n<< CODA_RATECONTROL_BITRATE_OFFSET;\r\nvalue |= 1 & CODA_RATECONTROL_ENABLE_MASK;\r\nvalue |= (ctx->params.vbv_delay &\r\nCODA_RATECONTROL_INITIALDELAY_MASK)\r\n<< CODA_RATECONTROL_INITIALDELAY_OFFSET;\r\nif (dev->devtype->product == CODA_960)\r\nvalue |= BIT(31);\r\n} else {\r\nvalue = 0;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_RC_PARA);\r\ncoda_write(dev, ctx->params.vbv_size, CODA_CMD_ENC_SEQ_RC_BUF_SIZE);\r\ncoda_write(dev, ctx->params.intra_refresh,\r\nCODA_CMD_ENC_SEQ_INTRA_REFRESH);\r\ncoda_write(dev, bitstream_buf, CODA_CMD_ENC_SEQ_BB_START);\r\ncoda_write(dev, bitstream_size / 1024, CODA_CMD_ENC_SEQ_BB_SIZE);\r\nvalue = 0;\r\nif (dev->devtype->product == CODA_960)\r\ngamma = CODA9_DEFAULT_GAMMA;\r\nelse\r\ngamma = CODA_DEFAULT_GAMMA;\r\nif (gamma > 0) {\r\ncoda_write(dev, (gamma & CODA_GAMMA_MASK) << CODA_GAMMA_OFFSET,\r\nCODA_CMD_ENC_SEQ_RC_GAMMA);\r\n}\r\nif (ctx->params.h264_min_qp || ctx->params.h264_max_qp) {\r\ncoda_write(dev,\r\nctx->params.h264_min_qp << CODA_QPMIN_OFFSET |\r\nctx->params.h264_max_qp << CODA_QPMAX_OFFSET,\r\nCODA_CMD_ENC_SEQ_RC_QP_MIN_MAX);\r\n}\r\nif (dev->devtype->product == CODA_960) {\r\nif (ctx->params.h264_max_qp)\r\nvalue |= 1 << CODA9_OPTION_RCQPMAX_OFFSET;\r\nif (CODA_DEFAULT_GAMMA > 0)\r\nvalue |= 1 << CODA9_OPTION_GAMMA_OFFSET;\r\n} else {\r\nif (CODA_DEFAULT_GAMMA > 0) {\r\nif (dev->devtype->product == CODA_DX6)\r\nvalue |= 1 << CODADX6_OPTION_GAMMA_OFFSET;\r\nelse\r\nvalue |= 1 << CODA7_OPTION_GAMMA_OFFSET;\r\n}\r\nif (ctx->params.h264_min_qp)\r\nvalue |= 1 << CODA7_OPTION_RCQPMIN_OFFSET;\r\nif (ctx->params.h264_max_qp)\r\nvalue |= 1 << CODA7_OPTION_RCQPMAX_OFFSET;\r\n}\r\ncoda_write(dev, value, CODA_CMD_ENC_SEQ_OPTION);\r\ncoda_write(dev, 0, CODA_CMD_ENC_SEQ_RC_INTERVAL_MODE);\r\ncoda_setup_iram(ctx);\r\nif (dst_fourcc == V4L2_PIX_FMT_H264) {\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\nvalue = FMO_SLICE_SAVE_BUF_SIZE << 7;\r\ncoda_write(dev, value, CODADX6_CMD_ENC_SEQ_FMO);\r\nbreak;\r\ncase CODA_7541:\r\ncoda_write(dev, ctx->iram_info.search_ram_paddr,\r\nCODA7_CMD_ENC_SEQ_SEARCH_BASE);\r\ncoda_write(dev, ctx->iram_info.search_ram_size,\r\nCODA7_CMD_ENC_SEQ_SEARCH_SIZE);\r\nbreak;\r\ncase CODA_960:\r\ncoda_write(dev, 0, CODA9_CMD_ENC_SEQ_ME_OPTION);\r\ncoda_write(dev, 0, CODA9_CMD_ENC_SEQ_INTRA_WEIGHT);\r\n}\r\n}\r\nret = coda_command_sync(ctx, CODA_COMMAND_SEQ_INIT);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "CODA_COMMAND_SEQ_INIT timeout\n");\r\ngoto out;\r\n}\r\nif (coda_read(dev, CODA_RET_ENC_SEQ_SUCCESS) == 0) {\r\nv4l2_err(v4l2_dev, "CODA_COMMAND_SEQ_INIT failed\n");\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nctx->initialized = 1;\r\nif (dst_fourcc != V4L2_PIX_FMT_JPEG) {\r\nif (dev->devtype->product == CODA_960)\r\nctx->num_internal_frames = 4;\r\nelse\r\nctx->num_internal_frames = 2;\r\nret = coda_alloc_framebuffers(ctx, q_data_src, dst_fourcc);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "failed to allocate framebuffers\n");\r\ngoto out;\r\n}\r\nnum_fb = 2;\r\nstride = q_data_src->bytesperline;\r\n} else {\r\nctx->num_internal_frames = 0;\r\nnum_fb = 0;\r\nstride = 0;\r\n}\r\ncoda_write(dev, num_fb, CODA_CMD_SET_FRAME_BUF_NUM);\r\ncoda_write(dev, stride, CODA_CMD_SET_FRAME_BUF_STRIDE);\r\nif (dev->devtype->product == CODA_7541) {\r\ncoda_write(dev, q_data_src->bytesperline,\r\nCODA7_CMD_SET_FRAME_SOURCE_BUF_STRIDE);\r\n}\r\nif (dev->devtype->product != CODA_DX6) {\r\ncoda_write(dev, ctx->iram_info.buf_bit_use,\r\nCODA7_CMD_SET_FRAME_AXI_BIT_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_ip_ac_dc_use,\r\nCODA7_CMD_SET_FRAME_AXI_IPACDC_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_dbk_y_use,\r\nCODA7_CMD_SET_FRAME_AXI_DBKY_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_dbk_c_use,\r\nCODA7_CMD_SET_FRAME_AXI_DBKC_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_ovl_use,\r\nCODA7_CMD_SET_FRAME_AXI_OVL_ADDR);\r\nif (dev->devtype->product == CODA_960) {\r\ncoda_write(dev, ctx->iram_info.buf_btp_use,\r\nCODA9_CMD_SET_FRAME_AXI_BTP_ADDR);\r\ncoda9_set_frame_cache(ctx, q_data_src->fourcc);\r\ncoda_write(dev, ctx->internal_frames[2].paddr,\r\nCODA9_CMD_SET_FRAME_SUBSAMP_A);\r\ncoda_write(dev, ctx->internal_frames[3].paddr,\r\nCODA9_CMD_SET_FRAME_SUBSAMP_B);\r\n}\r\n}\r\nret = coda_command_sync(ctx, CODA_COMMAND_SET_FRAME_BUF);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "CODA_COMMAND_SET_FRAME_BUF timeout\n");\r\ngoto out;\r\n}\r\nbuf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nswitch (dst_fourcc) {\r\ncase V4L2_PIX_FMT_H264:\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_H264_SPS,\r\n&ctx->vpu_header[0][0],\r\n&ctx->vpu_header_size[0]);\r\nif (ret < 0)\r\ngoto out;\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_H264_PPS,\r\n&ctx->vpu_header[1][0],\r\n&ctx->vpu_header_size[1]);\r\nif (ret < 0)\r\ngoto out;\r\nctx->vpu_header_size[2] = coda_h264_padding(\r\n(ctx->vpu_header_size[0] +\r\nctx->vpu_header_size[1]),\r\nctx->vpu_header[2]);\r\nbreak;\r\ncase V4L2_PIX_FMT_MPEG4:\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VOS,\r\n&ctx->vpu_header[0][0],\r\n&ctx->vpu_header_size[0]);\r\nif (ret < 0)\r\ngoto out;\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VIS,\r\n&ctx->vpu_header[1][0],\r\n&ctx->vpu_header_size[1]);\r\nif (ret < 0)\r\ngoto out;\r\nret = coda_encode_header(ctx, buf, CODA_HEADER_MP4V_VOL,\r\n&ctx->vpu_header[2][0],\r\n&ctx->vpu_header_size[2]);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&dev->coda_mutex);\r\nreturn ret;\r\n}\r\nstatic int coda_prepare_encode(struct coda_ctx *ctx)\r\n{\r\nstruct coda_q_data *q_data_src, *q_data_dst;\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nstruct coda_dev *dev = ctx->dev;\r\nint force_ipicture;\r\nint quant_param = 0;\r\nu32 pic_stream_buffer_addr, pic_stream_buffer_size;\r\nu32 rot_mode = 0;\r\nu32 dst_fourcc;\r\nu32 reg;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\ndst_fourcc = q_data_dst->fourcc;\r\nsrc_buf->sequence = ctx->osequence;\r\ndst_buf->sequence = ctx->osequence;\r\nctx->osequence++;\r\nif (src_buf->sequence % ctx->params.gop_size) {\r\nsrc_buf->flags |= V4L2_BUF_FLAG_PFRAME;\r\nsrc_buf->flags &= ~V4L2_BUF_FLAG_KEYFRAME;\r\n} else {\r\nsrc_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\r\nsrc_buf->flags &= ~V4L2_BUF_FLAG_PFRAME;\r\n}\r\nif (dev->devtype->product == CODA_960)\r\ncoda_set_gdi_regs(ctx);\r\nif (src_buf->sequence == 0) {\r\npic_stream_buffer_addr =\r\nvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0) +\r\nctx->vpu_header_size[0] +\r\nctx->vpu_header_size[1] +\r\nctx->vpu_header_size[2];\r\npic_stream_buffer_size = q_data_dst->sizeimage -\r\nctx->vpu_header_size[0] -\r\nctx->vpu_header_size[1] -\r\nctx->vpu_header_size[2];\r\nmemcpy(vb2_plane_vaddr(&dst_buf->vb2_buf, 0),\r\n&ctx->vpu_header[0][0], ctx->vpu_header_size[0]);\r\nmemcpy(vb2_plane_vaddr(&dst_buf->vb2_buf, 0)\r\n+ ctx->vpu_header_size[0], &ctx->vpu_header[1][0],\r\nctx->vpu_header_size[1]);\r\nmemcpy(vb2_plane_vaddr(&dst_buf->vb2_buf, 0)\r\n+ ctx->vpu_header_size[0] + ctx->vpu_header_size[1],\r\n&ctx->vpu_header[2][0], ctx->vpu_header_size[2]);\r\n} else {\r\npic_stream_buffer_addr =\r\nvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\r\npic_stream_buffer_size = q_data_dst->sizeimage;\r\n}\r\nif (src_buf->flags & V4L2_BUF_FLAG_KEYFRAME) {\r\nforce_ipicture = 1;\r\nswitch (dst_fourcc) {\r\ncase V4L2_PIX_FMT_H264:\r\nquant_param = ctx->params.h264_intra_qp;\r\nbreak;\r\ncase V4L2_PIX_FMT_MPEG4:\r\nquant_param = ctx->params.mpeg4_intra_qp;\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\nquant_param = 30;\r\nbreak;\r\ndefault:\r\nv4l2_warn(&ctx->dev->v4l2_dev,\r\n"cannot set intra qp, fmt not supported\n");\r\nbreak;\r\n}\r\n} else {\r\nforce_ipicture = 0;\r\nswitch (dst_fourcc) {\r\ncase V4L2_PIX_FMT_H264:\r\nquant_param = ctx->params.h264_inter_qp;\r\nbreak;\r\ncase V4L2_PIX_FMT_MPEG4:\r\nquant_param = ctx->params.mpeg4_inter_qp;\r\nbreak;\r\ndefault:\r\nv4l2_warn(&ctx->dev->v4l2_dev,\r\n"cannot set inter qp, fmt not supported\n");\r\nbreak;\r\n}\r\n}\r\nif (ctx->params.rot_mode)\r\nrot_mode = CODA_ROT_MIR_ENABLE | ctx->params.rot_mode;\r\ncoda_write(dev, rot_mode, CODA_CMD_ENC_PIC_ROT_MODE);\r\ncoda_write(dev, quant_param, CODA_CMD_ENC_PIC_QS);\r\nif (dev->devtype->product == CODA_960) {\r\ncoda_write(dev, 4, CODA9_CMD_ENC_PIC_SRC_INDEX);\r\ncoda_write(dev, q_data_src->width, CODA9_CMD_ENC_PIC_SRC_STRIDE);\r\ncoda_write(dev, 0, CODA9_CMD_ENC_PIC_SUB_FRAME_SYNC);\r\nreg = CODA9_CMD_ENC_PIC_SRC_ADDR_Y;\r\n} else {\r\nreg = CODA_CMD_ENC_PIC_SRC_ADDR_Y;\r\n}\r\ncoda_write_base(ctx, q_data_src, src_buf, reg);\r\ncoda_write(dev, force_ipicture << 1 & 0x2,\r\nCODA_CMD_ENC_PIC_OPTION);\r\ncoda_write(dev, pic_stream_buffer_addr, CODA_CMD_ENC_PIC_BB_START);\r\ncoda_write(dev, pic_stream_buffer_size / 1024,\r\nCODA_CMD_ENC_PIC_BB_SIZE);\r\nif (!ctx->streamon_out) {\r\nctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;\r\ncoda_write(dev, ctx->bit_stream_param,\r\nCODA_REG_BIT_BIT_STREAM_PARAM);\r\n}\r\nif (dev->devtype->product != CODA_DX6)\r\ncoda_write(dev, ctx->iram_info.axi_sram_use,\r\nCODA7_REG_BIT_AXI_SRAM_USE);\r\ntrace_coda_enc_pic_run(ctx, src_buf);\r\ncoda_command_async(ctx, CODA_COMMAND_PIC_RUN);\r\nreturn 0;\r\n}\r\nstatic void coda_finish_encode(struct coda_ctx *ctx)\r\n{\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nstruct coda_dev *dev = ctx->dev;\r\nu32 wr_ptr, start_ptr;\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\ntrace_coda_enc_pic_done(ctx, dst_buf);\r\nstart_ptr = coda_read(dev, CODA_CMD_ENC_PIC_BB_START);\r\nwr_ptr = coda_read(dev, CODA_REG_BIT_WR_PTR(ctx->reg_idx));\r\nif (dst_buf->sequence == 0) {\r\nvb2_set_plane_payload(&dst_buf->vb2_buf, 0, wr_ptr - start_ptr +\r\nctx->vpu_header_size[0] +\r\nctx->vpu_header_size[1] +\r\nctx->vpu_header_size[2]);\r\n} else {\r\nvb2_set_plane_payload(&dst_buf->vb2_buf, 0, wr_ptr - start_ptr);\r\n}\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev, "frame size = %u\n",\r\nwr_ptr - start_ptr);\r\ncoda_read(dev, CODA_RET_ENC_PIC_SLICE_NUM);\r\ncoda_read(dev, CODA_RET_ENC_PIC_FLAG);\r\nif (coda_read(dev, CODA_RET_ENC_PIC_TYPE) == 0) {\r\ndst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;\r\ndst_buf->flags &= ~V4L2_BUF_FLAG_PFRAME;\r\n} else {\r\ndst_buf->flags |= V4L2_BUF_FLAG_PFRAME;\r\ndst_buf->flags &= ~V4L2_BUF_FLAG_KEYFRAME;\r\n}\r\ndst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\r\ndst_buf->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_buf->flags |=\r\nsrc_buf->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_buf->timecode = src_buf->timecode;\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\ncoda_m2m_buf_done(ctx, dst_buf, VB2_BUF_STATE_DONE);\r\nctx->gopcounter--;\r\nif (ctx->gopcounter < 0)\r\nctx->gopcounter = ctx->params.gop_size - 1;\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"job finished: encoding frame (%d) (%s)\n",\r\ndst_buf->sequence,\r\n(dst_buf->flags & V4L2_BUF_FLAG_KEYFRAME) ?\r\n"KEYFRAME" : "PFRAME");\r\n}\r\nstatic void coda_seq_end_work(struct work_struct *work)\r\n{\r\nstruct coda_ctx *ctx = container_of(work, struct coda_ctx, seq_end_work);\r\nstruct coda_dev *dev = ctx->dev;\r\nmutex_lock(&ctx->buffer_mutex);\r\nmutex_lock(&dev->coda_mutex);\r\nif (ctx->initialized == 0)\r\ngoto out;\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"%d: %s: sent command 'SEQ_END' to coda\n", ctx->idx,\r\n__func__);\r\nif (coda_command_sync(ctx, CODA_COMMAND_SEQ_END)) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"CODA_COMMAND_SEQ_END failed\n");\r\n}\r\nif (dev->devtype->product == CODA_960)\r\ncoda_hw_reset(ctx);\r\nkfifo_init(&ctx->bitstream_fifo,\r\nctx->bitstream.vaddr, ctx->bitstream.size);\r\ncoda_free_framebuffers(ctx);\r\nctx->initialized = 0;\r\nout:\r\nmutex_unlock(&dev->coda_mutex);\r\nmutex_unlock(&ctx->buffer_mutex);\r\n}\r\nstatic void coda_bit_release(struct coda_ctx *ctx)\r\n{\r\nmutex_lock(&ctx->buffer_mutex);\r\ncoda_free_framebuffers(ctx);\r\ncoda_free_context_buffers(ctx);\r\ncoda_free_bitstream_buffer(ctx);\r\nmutex_unlock(&ctx->buffer_mutex);\r\n}\r\nstatic int coda_alloc_bitstream_buffer(struct coda_ctx *ctx,\r\nstruct coda_q_data *q_data)\r\n{\r\nif (ctx->bitstream.vaddr)\r\nreturn 0;\r\nctx->bitstream.size = roundup_pow_of_two(q_data->sizeimage * 2);\r\nctx->bitstream.vaddr = dma_alloc_wc(&ctx->dev->plat_dev->dev,\r\nctx->bitstream.size,\r\n&ctx->bitstream.paddr, GFP_KERNEL);\r\nif (!ctx->bitstream.vaddr) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"failed to allocate bitstream ringbuffer");\r\nreturn -ENOMEM;\r\n}\r\nkfifo_init(&ctx->bitstream_fifo,\r\nctx->bitstream.vaddr, ctx->bitstream.size);\r\nreturn 0;\r\n}\r\nstatic void coda_free_bitstream_buffer(struct coda_ctx *ctx)\r\n{\r\nif (ctx->bitstream.vaddr == NULL)\r\nreturn;\r\ndma_free_wc(&ctx->dev->plat_dev->dev, ctx->bitstream.size,\r\nctx->bitstream.vaddr, ctx->bitstream.paddr);\r\nctx->bitstream.vaddr = NULL;\r\nkfifo_init(&ctx->bitstream_fifo, NULL, 0);\r\n}\r\nstatic int coda_decoder_reqbufs(struct coda_ctx *ctx,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct coda_q_data *q_data_src;\r\nint ret;\r\nif (rb->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn 0;\r\nif (rb->count) {\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nret = coda_alloc_context_buffers(ctx, q_data_src);\r\nif (ret < 0)\r\nreturn ret;\r\nret = coda_alloc_bitstream_buffer(ctx, q_data_src);\r\nif (ret < 0) {\r\ncoda_free_context_buffers(ctx);\r\nreturn ret;\r\n}\r\n} else {\r\ncoda_free_bitstream_buffer(ctx);\r\ncoda_free_context_buffers(ctx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __coda_start_decoding(struct coda_ctx *ctx)\r\n{\r\nstruct coda_q_data *q_data_src, *q_data_dst;\r\nu32 bitstream_buf, bitstream_size;\r\nstruct coda_dev *dev = ctx->dev;\r\nint width, height;\r\nu32 src_fourcc, dst_fourcc;\r\nu32 val;\r\nint ret;\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nbitstream_buf = ctx->bitstream.paddr;\r\nbitstream_size = ctx->bitstream.size;\r\nsrc_fourcc = q_data_src->fourcc;\r\ndst_fourcc = q_data_dst->fourcc;\r\ncoda_write(dev, ctx->parabuf.paddr, CODA_REG_BIT_PARA_BUF_ADDR);\r\ncoda_kfifo_sync_to_device_full(ctx);\r\nctx->frame_mem_ctrl &= ~(CODA_FRAME_CHROMA_INTERLEAVE | (0x3 << 9) |\r\nCODA9_FRAME_TILED2LINEAR);\r\nif (dst_fourcc == V4L2_PIX_FMT_NV12)\r\nctx->frame_mem_ctrl |= CODA_FRAME_CHROMA_INTERLEAVE;\r\nif (ctx->tiled_map_type == GDI_TILED_FRAME_MB_RASTER_MAP)\r\nctx->frame_mem_ctrl |= (0x3 << 9) | CODA9_FRAME_TILED2LINEAR;\r\ncoda_write(dev, ctx->frame_mem_ctrl, CODA_REG_BIT_FRAME_MEM_CTRL);\r\nctx->display_idx = -1;\r\nctx->frm_dis_flg = 0;\r\ncoda_write(dev, 0, CODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\r\ncoda_write(dev, CODA_BIT_DEC_SEQ_INIT_ESCAPE,\r\nCODA_REG_BIT_BIT_STREAM_PARAM);\r\ncoda_write(dev, bitstream_buf, CODA_CMD_DEC_SEQ_BB_START);\r\ncoda_write(dev, bitstream_size / 1024, CODA_CMD_DEC_SEQ_BB_SIZE);\r\nval = 0;\r\nif ((dev->devtype->product == CODA_7541) ||\r\n(dev->devtype->product == CODA_960))\r\nval |= CODA_REORDER_ENABLE;\r\nif (ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG)\r\nval |= CODA_NO_INT_ENABLE;\r\ncoda_write(dev, val, CODA_CMD_DEC_SEQ_OPTION);\r\nctx->params.codec_mode = ctx->codec->mode;\r\nif (dev->devtype->product == CODA_960 &&\r\nsrc_fourcc == V4L2_PIX_FMT_MPEG4)\r\nctx->params.codec_mode_aux = CODA_MP4_AUX_MPEG4;\r\nelse\r\nctx->params.codec_mode_aux = 0;\r\nif (src_fourcc == V4L2_PIX_FMT_H264) {\r\nif (dev->devtype->product == CODA_7541) {\r\ncoda_write(dev, ctx->psbuf.paddr,\r\nCODA_CMD_DEC_SEQ_PS_BB_START);\r\ncoda_write(dev, (CODA7_PS_BUF_SIZE / 1024),\r\nCODA_CMD_DEC_SEQ_PS_BB_SIZE);\r\n}\r\nif (dev->devtype->product == CODA_960) {\r\ncoda_write(dev, 0, CODA_CMD_DEC_SEQ_X264_MV_EN);\r\ncoda_write(dev, 512, CODA_CMD_DEC_SEQ_SPP_CHUNK_SIZE);\r\n}\r\n}\r\nif (dev->devtype->product != CODA_960)\r\ncoda_write(dev, 0, CODA_CMD_DEC_SEQ_SRC_SIZE);\r\nif (coda_command_sync(ctx, CODA_COMMAND_SEQ_INIT)) {\r\nv4l2_err(&dev->v4l2_dev, "CODA_COMMAND_SEQ_INIT timeout\n");\r\ncoda_write(dev, 0, CODA_REG_BIT_BIT_STREAM_PARAM);\r\nreturn -ETIMEDOUT;\r\n}\r\nctx->initialized = 1;\r\ncoda_kfifo_sync_from_device(ctx);\r\ncoda_write(dev, 0, CODA_REG_BIT_BIT_STREAM_PARAM);\r\nif (coda_read(dev, CODA_RET_DEC_SEQ_SUCCESS) == 0) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"CODA_COMMAND_SEQ_INIT failed, error code = %d\n",\r\ncoda_read(dev, CODA_RET_DEC_SEQ_ERR_REASON));\r\nreturn -EAGAIN;\r\n}\r\nval = coda_read(dev, CODA_RET_DEC_SEQ_SRC_SIZE);\r\nif (dev->devtype->product == CODA_DX6) {\r\nwidth = (val >> CODADX6_PICWIDTH_OFFSET) & CODADX6_PICWIDTH_MASK;\r\nheight = val & CODADX6_PICHEIGHT_MASK;\r\n} else {\r\nwidth = (val >> CODA7_PICWIDTH_OFFSET) & CODA7_PICWIDTH_MASK;\r\nheight = val & CODA7_PICHEIGHT_MASK;\r\n}\r\nif (width > q_data_dst->bytesperline || height > q_data_dst->height) {\r\nv4l2_err(&dev->v4l2_dev, "stream is %dx%d, not %dx%d\n",\r\nwidth, height, q_data_dst->bytesperline,\r\nq_data_dst->height);\r\nreturn -EINVAL;\r\n}\r\nwidth = round_up(width, 16);\r\nheight = round_up(height, 16);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev, "%s instance %d now: %dx%d\n",\r\n__func__, ctx->idx, width, height);\r\nctx->num_internal_frames = coda_read(dev, CODA_RET_DEC_SEQ_FRAME_NEED);\r\nif (ctx->num_internal_frames > CODA_MAX_FRAMEBUFFERS) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"not enough framebuffers to decode (%d < %d)\n",\r\nCODA_MAX_FRAMEBUFFERS, ctx->num_internal_frames);\r\nreturn -EINVAL;\r\n}\r\nif (src_fourcc == V4L2_PIX_FMT_H264) {\r\nu32 left_right;\r\nu32 top_bottom;\r\nleft_right = coda_read(dev, CODA_RET_DEC_SEQ_CROP_LEFT_RIGHT);\r\ntop_bottom = coda_read(dev, CODA_RET_DEC_SEQ_CROP_TOP_BOTTOM);\r\nq_data_dst->rect.left = (left_right >> 10) & 0x3ff;\r\nq_data_dst->rect.top = (top_bottom >> 10) & 0x3ff;\r\nq_data_dst->rect.width = width - q_data_dst->rect.left -\r\n(left_right & 0x3ff);\r\nq_data_dst->rect.height = height - q_data_dst->rect.top -\r\n(top_bottom & 0x3ff);\r\n}\r\nret = coda_alloc_framebuffers(ctx, q_data_dst, src_fourcc);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "failed to allocate framebuffers\n");\r\nreturn ret;\r\n}\r\ncoda_write(dev, ctx->num_internal_frames, CODA_CMD_SET_FRAME_BUF_NUM);\r\ncoda_write(dev, width, CODA_CMD_SET_FRAME_BUF_STRIDE);\r\nif (dev->devtype->product != CODA_DX6) {\r\ncoda_setup_iram(ctx);\r\ncoda_write(dev, ctx->iram_info.buf_bit_use,\r\nCODA7_CMD_SET_FRAME_AXI_BIT_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_ip_ac_dc_use,\r\nCODA7_CMD_SET_FRAME_AXI_IPACDC_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_dbk_y_use,\r\nCODA7_CMD_SET_FRAME_AXI_DBKY_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_dbk_c_use,\r\nCODA7_CMD_SET_FRAME_AXI_DBKC_ADDR);\r\ncoda_write(dev, ctx->iram_info.buf_ovl_use,\r\nCODA7_CMD_SET_FRAME_AXI_OVL_ADDR);\r\nif (dev->devtype->product == CODA_960) {\r\ncoda_write(dev, ctx->iram_info.buf_btp_use,\r\nCODA9_CMD_SET_FRAME_AXI_BTP_ADDR);\r\ncoda_write(dev, -1, CODA9_CMD_SET_FRAME_DELAY);\r\ncoda9_set_frame_cache(ctx, dst_fourcc);\r\n}\r\n}\r\nif (src_fourcc == V4L2_PIX_FMT_H264) {\r\ncoda_write(dev, ctx->slicebuf.paddr,\r\nCODA_CMD_SET_FRAME_SLICE_BB_START);\r\ncoda_write(dev, ctx->slicebuf.size / 1024,\r\nCODA_CMD_SET_FRAME_SLICE_BB_SIZE);\r\n}\r\nif (dev->devtype->product == CODA_7541) {\r\nint max_mb_x = 1920 / 16;\r\nint max_mb_y = 1088 / 16;\r\nint max_mb_num = max_mb_x * max_mb_y;\r\ncoda_write(dev, max_mb_num << 16 | max_mb_x << 8 | max_mb_y,\r\nCODA7_CMD_SET_FRAME_MAX_DEC_SIZE);\r\n} else if (dev->devtype->product == CODA_960) {\r\nint max_mb_x = 1920 / 16;\r\nint max_mb_y = 1088 / 16;\r\nint max_mb_num = max_mb_x * max_mb_y;\r\ncoda_write(dev, max_mb_num << 16 | max_mb_x << 8 | max_mb_y,\r\nCODA9_CMD_SET_FRAME_MAX_DEC_SIZE);\r\n}\r\nif (coda_command_sync(ctx, CODA_COMMAND_SET_FRAME_BUF)) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"CODA_COMMAND_SET_FRAME_BUF timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int coda_start_decoding(struct coda_ctx *ctx)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nint ret;\r\nmutex_lock(&dev->coda_mutex);\r\nret = __coda_start_decoding(ctx);\r\nmutex_unlock(&dev->coda_mutex);\r\nreturn ret;\r\n}\r\nstatic int coda_prepare_decode(struct coda_ctx *ctx)\r\n{\r\nstruct vb2_v4l2_buffer *dst_buf;\r\nstruct coda_dev *dev = ctx->dev;\r\nstruct coda_q_data *q_data_dst;\r\nstruct coda_buffer_meta *meta;\r\nunsigned long flags;\r\nu32 reg_addr, reg_stride;\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nmutex_lock(&ctx->bitstream_mutex);\r\ncoda_fill_bitstream(ctx, true);\r\nmutex_unlock(&ctx->bitstream_mutex);\r\nif (coda_get_bitstream_payload(ctx) < 512 &&\r\n(!(ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG))) {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"bitstream payload: %d, skipping\n",\r\ncoda_get_bitstream_payload(ctx));\r\nv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);\r\nreturn -EAGAIN;\r\n}\r\nif (!ctx->initialized) {\r\nint ret = __coda_start_decoding(ctx);\r\nif (ret < 0) {\r\nv4l2_err(&dev->v4l2_dev, "failed to start decoding\n");\r\nv4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);\r\nreturn -EAGAIN;\r\n} else {\r\nctx->initialized = 1;\r\n}\r\n}\r\nif (dev->devtype->product == CODA_960)\r\ncoda_set_gdi_regs(ctx);\r\nif (dev->devtype->product == CODA_960) {\r\ncoda_write(dev, CODA_MAX_FRAMEBUFFERS + dst_buf->vb2_buf.index,\r\nCODA9_CMD_DEC_PIC_ROT_INDEX);\r\nreg_addr = CODA9_CMD_DEC_PIC_ROT_ADDR_Y;\r\nreg_stride = CODA9_CMD_DEC_PIC_ROT_STRIDE;\r\n} else {\r\nreg_addr = CODA_CMD_DEC_PIC_ROT_ADDR_Y;\r\nreg_stride = CODA_CMD_DEC_PIC_ROT_STRIDE;\r\n}\r\ncoda_write_base(ctx, q_data_dst, dst_buf, reg_addr);\r\ncoda_write(dev, q_data_dst->bytesperline, reg_stride);\r\ncoda_write(dev, CODA_ROT_MIR_ENABLE | ctx->params.rot_mode,\r\nCODA_CMD_DEC_PIC_ROT_MODE);\r\nswitch (dev->devtype->product) {\r\ncase CODA_DX6:\r\ncase CODA_7541:\r\ncoda_write(dev, CODA_PRE_SCAN_EN, CODA_CMD_DEC_PIC_OPTION);\r\nbreak;\r\ncase CODA_960:\r\ncoda_write(dev, (1 << 10), CODA_CMD_DEC_PIC_OPTION);\r\nbreak;\r\n}\r\ncoda_write(dev, 0, CODA_CMD_DEC_PIC_SKIP_NUM);\r\ncoda_write(dev, 0, CODA_CMD_DEC_PIC_BB_START);\r\ncoda_write(dev, 0, CODA_CMD_DEC_PIC_START_BYTE);\r\nif (dev->devtype->product != CODA_DX6)\r\ncoda_write(dev, ctx->iram_info.axi_sram_use,\r\nCODA7_REG_BIT_AXI_SRAM_USE);\r\nspin_lock_irqsave(&ctx->buffer_meta_lock, flags);\r\nmeta = list_first_entry_or_null(&ctx->buffer_meta_list,\r\nstruct coda_buffer_meta, list);\r\nif (meta && ctx->codec->src_fourcc == V4L2_PIX_FMT_JPEG) {\r\nif (meta->end == (ctx->bitstream_fifo.kfifo.in &\r\nctx->bitstream_fifo.kfifo.mask)) {\r\nstatic unsigned char buf[512];\r\nunsigned int pad;\r\npad = ((0 - meta->end) & 0xff) + 256;\r\nmemset(buf, 0xff, sizeof(buf));\r\nkfifo_in(&ctx->bitstream_fifo, buf, pad);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ctx->buffer_meta_lock, flags);\r\ncoda_kfifo_sync_to_device_full(ctx);\r\ncoda_write(dev, 0, CODA_RET_DEC_PIC_SUCCESS);\r\ntrace_coda_dec_pic_run(ctx, meta);\r\ncoda_command_async(ctx, CODA_COMMAND_PIC_RUN);\r\nreturn 0;\r\n}\r\nstatic void coda_finish_decode(struct coda_ctx *ctx)\r\n{\r\nstruct coda_dev *dev = ctx->dev;\r\nstruct coda_q_data *q_data_src;\r\nstruct coda_q_data *q_data_dst;\r\nstruct vb2_v4l2_buffer *dst_buf;\r\nstruct coda_buffer_meta *meta;\r\nunsigned long payload;\r\nunsigned long flags;\r\nint width, height;\r\nint decoded_idx;\r\nint display_idx;\r\nu32 src_fourcc;\r\nint success;\r\nu32 err_mb;\r\nu32 val;\r\ncoda_kfifo_sync_from_device(ctx);\r\nif (ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG) {\r\nif (coda_get_bitstream_payload(ctx) >= ctx->bitstream.size - 512)\r\nkfifo_init(&ctx->bitstream_fifo,\r\nctx->bitstream.vaddr, ctx->bitstream.size);\r\n}\r\nq_data_src = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nsrc_fourcc = q_data_src->fourcc;\r\nval = coda_read(dev, CODA_RET_DEC_PIC_SUCCESS);\r\nif (val != 1)\r\npr_err("DEC_PIC_SUCCESS = %d\n", val);\r\nsuccess = val & 0x1;\r\nif (!success)\r\nv4l2_err(&dev->v4l2_dev, "decode failed\n");\r\nif (src_fourcc == V4L2_PIX_FMT_H264) {\r\nif (val & (1 << 3))\r\nv4l2_err(&dev->v4l2_dev,\r\n"insufficient PS buffer space (%d bytes)\n",\r\nctx->psbuf.size);\r\nif (val & (1 << 2))\r\nv4l2_err(&dev->v4l2_dev,\r\n"insufficient slice buffer space (%d bytes)\n",\r\nctx->slicebuf.size);\r\n}\r\nval = coda_read(dev, CODA_RET_DEC_PIC_SIZE);\r\nwidth = (val >> 16) & 0xffff;\r\nheight = val & 0xffff;\r\nq_data_dst = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nif (src_fourcc == V4L2_PIX_FMT_H264) {\r\nu32 left_right;\r\nu32 top_bottom;\r\nleft_right = coda_read(dev, CODA_RET_DEC_PIC_CROP_LEFT_RIGHT);\r\ntop_bottom = coda_read(dev, CODA_RET_DEC_PIC_CROP_TOP_BOTTOM);\r\nif (left_right == 0xffffffff && top_bottom == 0xffffffff) {\r\n} else {\r\nstruct v4l2_rect *rect = &q_data_dst->rect;\r\nrect->left = left_right >> 16 & 0xffff;\r\nrect->top = top_bottom >> 16 & 0xffff;\r\nrect->width = width - rect->left -\r\n(left_right & 0xffff);\r\nrect->height = height - rect->top -\r\n(top_bottom & 0xffff);\r\n}\r\n} else {\r\n}\r\nerr_mb = coda_read(dev, CODA_RET_DEC_PIC_ERR_MB);\r\nif (err_mb > 0)\r\nv4l2_err(&dev->v4l2_dev,\r\n"errors in %d macroblocks\n", err_mb);\r\nif (dev->devtype->product == CODA_7541) {\r\nval = coda_read(dev, CODA_RET_DEC_PIC_OPTION);\r\nif (val == 0) {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"prescan failed: %d\n", val);\r\nctx->hold = true;\r\nreturn;\r\n}\r\n}\r\nctx->frm_dis_flg = coda_read(dev,\r\nCODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\r\nif (ctx->display_idx >= 0 &&\r\nctx->display_idx < ctx->num_internal_frames) {\r\nctx->frm_dis_flg &= ~(1 << ctx->display_idx);\r\ncoda_write(dev, ctx->frm_dis_flg,\r\nCODA_REG_BIT_FRM_DIS_FLG(ctx->reg_idx));\r\n}\r\ndecoded_idx = coda_read(dev, CODA_RET_DEC_PIC_CUR_IDX);\r\ndisplay_idx = coda_read(dev, CODA_RET_DEC_PIC_FRAME_IDX);\r\nif (decoded_idx == -1) {\r\nif (display_idx >= 0 && display_idx < ctx->num_internal_frames)\r\nctx->sequence_offset++;\r\nelse if (ctx->display_idx < 0)\r\nctx->hold = true;\r\n} else if (decoded_idx == -2) {\r\n} else if (decoded_idx < 0 || decoded_idx >= ctx->num_internal_frames) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"decoded frame index out of range: %d\n", decoded_idx);\r\n} else {\r\nval = coda_read(dev, CODA_RET_DEC_PIC_FRAME_NUM) - 1;\r\nval -= ctx->sequence_offset;\r\nspin_lock_irqsave(&ctx->buffer_meta_lock, flags);\r\nif (!list_empty(&ctx->buffer_meta_list)) {\r\nmeta = list_first_entry(&ctx->buffer_meta_list,\r\nstruct coda_buffer_meta, list);\r\nlist_del(&meta->list);\r\nctx->num_metas--;\r\nspin_unlock_irqrestore(&ctx->buffer_meta_lock, flags);\r\nif ((val & 0xffff) != (meta->sequence & 0xffff)) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"sequence number mismatch (%d(%d) != %d)\n",\r\nval, ctx->sequence_offset,\r\nmeta->sequence);\r\n}\r\nctx->frame_metas[decoded_idx] = *meta;\r\nkfree(meta);\r\n} else {\r\nspin_unlock_irqrestore(&ctx->buffer_meta_lock, flags);\r\nv4l2_err(&dev->v4l2_dev, "empty timestamp list!\n");\r\nmemset(&ctx->frame_metas[decoded_idx], 0,\r\nsizeof(struct coda_buffer_meta));\r\nctx->frame_metas[decoded_idx].sequence = val;\r\nctx->sequence_offset++;\r\n}\r\ntrace_coda_dec_pic_done(ctx, &ctx->frame_metas[decoded_idx]);\r\nval = coda_read(dev, CODA_RET_DEC_PIC_TYPE) & 0x7;\r\nif (val == 0)\r\nctx->frame_types[decoded_idx] = V4L2_BUF_FLAG_KEYFRAME;\r\nelse if (val == 1)\r\nctx->frame_types[decoded_idx] = V4L2_BUF_FLAG_PFRAME;\r\nelse\r\nctx->frame_types[decoded_idx] = V4L2_BUF_FLAG_BFRAME;\r\nctx->frame_errors[decoded_idx] = err_mb;\r\n}\r\nif (display_idx == -1) {\r\nctx->hold = true;\r\n} else if (display_idx == -3) {\r\n} else if (display_idx < 0 || display_idx >= ctx->num_internal_frames) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"presentation frame index out of range: %d\n",\r\ndisplay_idx);\r\n}\r\nif (ctx->display_idx >= 0 &&\r\nctx->display_idx < ctx->num_internal_frames) {\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\ndst_buf->sequence = ctx->osequence++;\r\ndst_buf->flags &= ~(V4L2_BUF_FLAG_KEYFRAME |\r\nV4L2_BUF_FLAG_PFRAME |\r\nV4L2_BUF_FLAG_BFRAME);\r\ndst_buf->flags |= ctx->frame_types[ctx->display_idx];\r\nmeta = &ctx->frame_metas[ctx->display_idx];\r\ndst_buf->timecode = meta->timecode;\r\ndst_buf->vb2_buf.timestamp = meta->timestamp;\r\ntrace_coda_dec_rot_done(ctx, dst_buf, meta);\r\nswitch (q_data_dst->fourcc) {\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_YVU420:\r\ncase V4L2_PIX_FMT_NV12:\r\ndefault:\r\npayload = width * height * 3 / 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\npayload = width * height * 2;\r\nbreak;\r\n}\r\nvb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload);\r\ncoda_m2m_buf_done(ctx, dst_buf, ctx->frame_errors[display_idx] ?\r\nVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"job finished: decoding frame (%d) (%s)\n",\r\ndst_buf->sequence,\r\n(dst_buf->flags & V4L2_BUF_FLAG_KEYFRAME) ?\r\n"KEYFRAME" : "PFRAME");\r\n} else {\r\nv4l2_dbg(1, coda_debug, &dev->v4l2_dev,\r\n"job finished: no frame decoded\n");\r\n}\r\nctx->display_idx = display_idx;\r\n}\r\nirqreturn_t coda_irq_handler(int irq, void *data)\r\n{\r\nstruct coda_dev *dev = data;\r\nstruct coda_ctx *ctx;\r\ncoda_read(dev, CODA_REG_BIT_INT_STATUS);\r\ncoda_write(dev, CODA_REG_BIT_INT_CLEAR_SET,\r\nCODA_REG_BIT_INT_CLEAR);\r\nctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);\r\nif (ctx == NULL) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"Instance released before the end of transaction\n");\r\nmutex_unlock(&dev->coda_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\ntrace_coda_bit_done(ctx);\r\nif (ctx->aborting) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"task has been aborted\n");\r\n}\r\nif (coda_isbusy(ctx->dev)) {\r\nv4l2_dbg(1, coda_debug, &ctx->dev->v4l2_dev,\r\n"coda is still busy!!!!\n");\r\nreturn IRQ_NONE;\r\n}\r\ncomplete(&ctx->completion);\r\nreturn IRQ_HANDLED;\r\n}
