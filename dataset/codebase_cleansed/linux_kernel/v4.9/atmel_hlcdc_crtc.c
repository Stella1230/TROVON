static inline struct atmel_hlcdc_crtc_state *\r\ndrm_crtc_state_to_atmel_hlcdc_crtc_state(struct drm_crtc_state *state)\r\n{\r\nreturn container_of(state, struct atmel_hlcdc_crtc_state, base);\r\n}\r\nstatic inline struct atmel_hlcdc_crtc *\r\ndrm_crtc_to_atmel_hlcdc_crtc(struct drm_crtc *crtc)\r\n{\r\nreturn container_of(crtc, struct atmel_hlcdc_crtc, base);\r\n}\r\nstatic void atmel_hlcdc_crtc_mode_set_nofb(struct drm_crtc *c)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nstruct regmap *regmap = crtc->dc->hlcdc->regmap;\r\nstruct drm_display_mode *adj = &c->state->adjusted_mode;\r\nstruct atmel_hlcdc_crtc_state *state;\r\nunsigned long mode_rate;\r\nstruct videomode vm;\r\nunsigned long prate;\r\nunsigned int cfg;\r\nint div;\r\nvm.vfront_porch = adj->crtc_vsync_start - adj->crtc_vdisplay;\r\nvm.vback_porch = adj->crtc_vtotal - adj->crtc_vsync_end;\r\nvm.vsync_len = adj->crtc_vsync_end - adj->crtc_vsync_start;\r\nvm.hfront_porch = adj->crtc_hsync_start - adj->crtc_hdisplay;\r\nvm.hback_porch = adj->crtc_htotal - adj->crtc_hsync_end;\r\nvm.hsync_len = adj->crtc_hsync_end - adj->crtc_hsync_start;\r\nregmap_write(regmap, ATMEL_HLCDC_CFG(1),\r\n(vm.hsync_len - 1) | ((vm.vsync_len - 1) << 16));\r\nregmap_write(regmap, ATMEL_HLCDC_CFG(2),\r\n(vm.vfront_porch - 1) | (vm.vback_porch << 16));\r\nregmap_write(regmap, ATMEL_HLCDC_CFG(3),\r\n(vm.hfront_porch - 1) | ((vm.hback_porch - 1) << 16));\r\nregmap_write(regmap, ATMEL_HLCDC_CFG(4),\r\n(adj->crtc_hdisplay - 1) |\r\n((adj->crtc_vdisplay - 1) << 16));\r\ncfg = 0;\r\nprate = clk_get_rate(crtc->dc->hlcdc->sys_clk);\r\nmode_rate = adj->crtc_clock * 1000;\r\nif ((prate / 2) < mode_rate) {\r\nprate *= 2;\r\ncfg |= ATMEL_HLCDC_CLKSEL;\r\n}\r\ndiv = DIV_ROUND_UP(prate, mode_rate);\r\nif (div < 2)\r\ndiv = 2;\r\ncfg |= ATMEL_HLCDC_CLKDIV(div);\r\nregmap_update_bits(regmap, ATMEL_HLCDC_CFG(0),\r\nATMEL_HLCDC_CLKSEL | ATMEL_HLCDC_CLKDIV_MASK |\r\nATMEL_HLCDC_CLKPOL, cfg);\r\ncfg = 0;\r\nif (adj->flags & DRM_MODE_FLAG_NVSYNC)\r\ncfg |= ATMEL_HLCDC_VSPOL;\r\nif (adj->flags & DRM_MODE_FLAG_NHSYNC)\r\ncfg |= ATMEL_HLCDC_HSPOL;\r\nstate = drm_crtc_state_to_atmel_hlcdc_crtc_state(c->state);\r\ncfg |= state->output_mode << 8;\r\nregmap_update_bits(regmap, ATMEL_HLCDC_CFG(5),\r\nATMEL_HLCDC_HSPOL | ATMEL_HLCDC_VSPOL |\r\nATMEL_HLCDC_VSPDLYS | ATMEL_HLCDC_VSPDLYE |\r\nATMEL_HLCDC_DISPPOL | ATMEL_HLCDC_DISPDLY |\r\nATMEL_HLCDC_VSPSU | ATMEL_HLCDC_VSPHO |\r\nATMEL_HLCDC_GUARDTIME_MASK | ATMEL_HLCDC_MODE_MASK,\r\ncfg);\r\n}\r\nstatic bool atmel_hlcdc_crtc_mode_fixup(struct drm_crtc *c,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nreturn atmel_hlcdc_dc_mode_valid(crtc->dc, adjusted_mode) == MODE_OK;\r\n}\r\nstatic void atmel_hlcdc_crtc_disable(struct drm_crtc *c)\r\n{\r\nstruct drm_device *dev = c->dev;\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nstruct regmap *regmap = crtc->dc->hlcdc->regmap;\r\nunsigned int status;\r\nif (!crtc->enabled)\r\nreturn;\r\ndrm_crtc_vblank_off(c);\r\npm_runtime_get_sync(dev->dev);\r\nregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_DISP);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n(status & ATMEL_HLCDC_DISP))\r\ncpu_relax();\r\nregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_SYNC);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n(status & ATMEL_HLCDC_SYNC))\r\ncpu_relax();\r\nregmap_write(regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_PIXEL_CLK);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n(status & ATMEL_HLCDC_PIXEL_CLK))\r\ncpu_relax();\r\nclk_disable_unprepare(crtc->dc->hlcdc->sys_clk);\r\npinctrl_pm_select_sleep_state(dev->dev);\r\npm_runtime_allow(dev->dev);\r\npm_runtime_put_sync(dev->dev);\r\ncrtc->enabled = false;\r\n}\r\nstatic void atmel_hlcdc_crtc_enable(struct drm_crtc *c)\r\n{\r\nstruct drm_device *dev = c->dev;\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nstruct regmap *regmap = crtc->dc->hlcdc->regmap;\r\nunsigned int status;\r\nif (crtc->enabled)\r\nreturn;\r\npm_runtime_get_sync(dev->dev);\r\npm_runtime_forbid(dev->dev);\r\npinctrl_pm_select_default_state(dev->dev);\r\nclk_prepare_enable(crtc->dc->hlcdc->sys_clk);\r\nregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_PIXEL_CLK);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n!(status & ATMEL_HLCDC_PIXEL_CLK))\r\ncpu_relax();\r\nregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_SYNC);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n!(status & ATMEL_HLCDC_SYNC))\r\ncpu_relax();\r\nregmap_write(regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_DISP);\r\nwhile (!regmap_read(regmap, ATMEL_HLCDC_SR, &status) &&\r\n!(status & ATMEL_HLCDC_DISP))\r\ncpu_relax();\r\npm_runtime_put_sync(dev->dev);\r\ndrm_crtc_vblank_on(c);\r\ncrtc->enabled = true;\r\n}\r\nvoid atmel_hlcdc_crtc_suspend(struct drm_crtc *c)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nif (crtc->enabled) {\r\natmel_hlcdc_crtc_disable(c);\r\ncrtc->enabled = true;\r\n}\r\n}\r\nvoid atmel_hlcdc_crtc_resume(struct drm_crtc *c)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nif (crtc->enabled) {\r\ncrtc->enabled = false;\r\natmel_hlcdc_crtc_enable(c);\r\n}\r\n}\r\nstatic int atmel_hlcdc_crtc_select_output_mode(struct drm_crtc_state *state)\r\n{\r\nunsigned int output_fmts = ATMEL_HLCDC_OUTPUT_MODE_MASK;\r\nstruct atmel_hlcdc_crtc_state *hstate;\r\nstruct drm_connector_state *cstate;\r\nstruct drm_connector *connector;\r\nstruct atmel_hlcdc_crtc *crtc;\r\nint i;\r\ncrtc = drm_crtc_to_atmel_hlcdc_crtc(state->crtc);\r\nfor_each_connector_in_state(state->state, connector, cstate, i) {\r\nstruct drm_display_info *info = &connector->display_info;\r\nunsigned int supported_fmts = 0;\r\nint j;\r\nif (!cstate->crtc)\r\ncontinue;\r\nfor (j = 0; j < info->num_bus_formats; j++) {\r\nswitch (info->bus_formats[j]) {\r\ncase MEDIA_BUS_FMT_RGB444_1X12:\r\nsupported_fmts |= ATMEL_HLCDC_RGB444_OUTPUT;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB565_1X16:\r\nsupported_fmts |= ATMEL_HLCDC_RGB565_OUTPUT;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB666_1X18:\r\nsupported_fmts |= ATMEL_HLCDC_RGB666_OUTPUT;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\nsupported_fmts |= ATMEL_HLCDC_RGB888_OUTPUT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (crtc->dc->desc->conflicting_output_formats)\r\noutput_fmts &= supported_fmts;\r\nelse\r\noutput_fmts |= supported_fmts;\r\n}\r\nif (!output_fmts)\r\nreturn -EINVAL;\r\nhstate = drm_crtc_state_to_atmel_hlcdc_crtc_state(state);\r\nhstate->output_mode = fls(output_fmts) - 1;\r\nreturn 0;\r\n}\r\nstatic int atmel_hlcdc_crtc_atomic_check(struct drm_crtc *c,\r\nstruct drm_crtc_state *s)\r\n{\r\nint ret;\r\nret = atmel_hlcdc_crtc_select_output_mode(s);\r\nif (ret)\r\nreturn ret;\r\nret = atmel_hlcdc_plane_prepare_disc_area(s);\r\nif (ret)\r\nreturn ret;\r\nreturn atmel_hlcdc_plane_prepare_ahb_routing(s);\r\n}\r\nstatic void atmel_hlcdc_crtc_atomic_begin(struct drm_crtc *c,\r\nstruct drm_crtc_state *old_s)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\nif (c->state->event) {\r\nc->state->event->pipe = drm_crtc_index(c);\r\nWARN_ON(drm_crtc_vblank_get(c) != 0);\r\ncrtc->event = c->state->event;\r\nc->state->event = NULL;\r\n}\r\n}\r\nstatic void atmel_hlcdc_crtc_atomic_flush(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_s)\r\n{\r\n}\r\nstatic void atmel_hlcdc_crtc_destroy(struct drm_crtc *c)\r\n{\r\nstruct atmel_hlcdc_crtc *crtc = drm_crtc_to_atmel_hlcdc_crtc(c);\r\ndrm_crtc_cleanup(c);\r\nkfree(crtc);\r\n}\r\nstatic void atmel_hlcdc_crtc_finish_page_flip(struct atmel_hlcdc_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->base.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (crtc->event) {\r\ndrm_crtc_send_vblank_event(&crtc->base, crtc->event);\r\ndrm_crtc_vblank_put(&crtc->base);\r\ncrtc->event = NULL;\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nvoid atmel_hlcdc_crtc_irq(struct drm_crtc *c)\r\n{\r\ndrm_crtc_handle_vblank(c);\r\natmel_hlcdc_crtc_finish_page_flip(drm_crtc_to_atmel_hlcdc_crtc(c));\r\n}\r\nstatic void atmel_hlcdc_crtc_reset(struct drm_crtc *crtc)\r\n{\r\nstruct atmel_hlcdc_crtc_state *state;\r\nif (crtc->state) {\r\n__drm_atomic_helper_crtc_destroy_state(crtc->state);\r\nstate = drm_crtc_state_to_atmel_hlcdc_crtc_state(crtc->state);\r\nkfree(state);\r\ncrtc->state = NULL;\r\n}\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (state) {\r\ncrtc->state = &state->base;\r\ncrtc->state->crtc = crtc;\r\n}\r\n}\r\nstatic struct drm_crtc_state *\r\natmel_hlcdc_crtc_duplicate_state(struct drm_crtc *crtc)\r\n{\r\nstruct atmel_hlcdc_crtc_state *state, *cur;\r\nif (WARN_ON(!crtc->state))\r\nreturn NULL;\r\nstate = kmalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\n__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\r\ncur = drm_crtc_state_to_atmel_hlcdc_crtc_state(crtc->state);\r\nstate->output_mode = cur->output_mode;\r\nreturn &state->base;\r\n}\r\nstatic void atmel_hlcdc_crtc_destroy_state(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *s)\r\n{\r\nstruct atmel_hlcdc_crtc_state *state;\r\nstate = drm_crtc_state_to_atmel_hlcdc_crtc_state(s);\r\n__drm_atomic_helper_crtc_destroy_state(s);\r\nkfree(state);\r\n}\r\nint atmel_hlcdc_crtc_create(struct drm_device *dev)\r\n{\r\nstruct atmel_hlcdc_dc *dc = dev->dev_private;\r\nstruct atmel_hlcdc_planes *planes = dc->planes;\r\nstruct atmel_hlcdc_crtc *crtc;\r\nint ret;\r\nint i;\r\ncrtc = kzalloc(sizeof(*crtc), GFP_KERNEL);\r\nif (!crtc)\r\nreturn -ENOMEM;\r\ncrtc->dc = dc;\r\nret = drm_crtc_init_with_planes(dev, &crtc->base,\r\n&planes->primary->base,\r\nplanes->cursor ? &planes->cursor->base : NULL,\r\n&atmel_hlcdc_crtc_funcs, NULL);\r\nif (ret < 0)\r\ngoto fail;\r\ncrtc->id = drm_crtc_index(&crtc->base);\r\nif (planes->cursor)\r\nplanes->cursor->base.possible_crtcs = 1 << crtc->id;\r\nfor (i = 0; i < planes->noverlays; i++)\r\nplanes->overlays[i]->base.possible_crtcs = 1 << crtc->id;\r\ndrm_crtc_helper_add(&crtc->base, &lcdc_crtc_helper_funcs);\r\ndrm_crtc_vblank_reset(&crtc->base);\r\ndc->crtc = &crtc->base;\r\nreturn 0;\r\nfail:\r\natmel_hlcdc_crtc_destroy(&crtc->base);\r\nreturn ret;\r\n}
