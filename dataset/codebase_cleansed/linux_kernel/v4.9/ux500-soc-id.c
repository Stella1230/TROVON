static unsigned int __init ux500_read_asicid(phys_addr_t addr)\r\n{\r\nvoid __iomem *virt = ioremap(addr, 4);\r\nunsigned int asicid;\r\nif (!virt)\r\nreturn 0;\r\nasicid = readl(virt);\r\niounmap(virt);\r\nreturn asicid;\r\n}\r\nstatic void ux500_print_soc_info(unsigned int asicid)\r\n{\r\nunsigned int rev = dbx500_id.revision;\r\npr_info("DB%4x ", dbx500_id.partnumber);\r\nif (rev == 0x01)\r\npr_cont("Early Drop");\r\nelse if (rev >= 0xA0)\r\npr_cont("v%d.%d" , (rev >> 4) - 0xA + 1, rev & 0xf);\r\nelse\r\npr_cont("Unknown");\r\npr_cont(" [%#010x]\n", asicid);\r\n}\r\nstatic unsigned int partnumber(unsigned int asicid)\r\n{\r\nreturn (asicid >> 8) & 0xffff;\r\n}\r\nstatic void __init ux500_setup_id(void)\r\n{\r\nunsigned int cpuid = read_cpuid_id();\r\nunsigned int asicid = 0;\r\nphys_addr_t addr = 0;\r\nswitch (cpuid) {\r\ncase 0x410fc090:\r\ncase 0x411fc091:\r\naddr = 0x9001FFF4;\r\nbreak;\r\ncase 0x412fc091:\r\nasicid = ux500_read_asicid(0x9001DBF4);\r\nif (partnumber(asicid) == 0x8500 ||\r\npartnumber(asicid) == 0x8520)\r\nbreak;\r\naddr = 0x9001FFF4;\r\nbreak;\r\ncase 0x413fc090:\r\naddr = 0xFFFFDBF4;\r\nbreak;\r\n}\r\nif (addr)\r\nasicid = ux500_read_asicid(addr);\r\nif (!asicid) {\r\npr_err("Unable to identify SoC\n");\r\nBUG();\r\n}\r\ndbx500_id.process = asicid >> 24;\r\ndbx500_id.partnumber = partnumber(asicid);\r\ndbx500_id.revision = asicid & 0xff;\r\nux500_print_soc_info(asicid);\r\n}\r\nstatic const char * __init ux500_get_machine(void)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "DB%4x", dbx500_id.partnumber);\r\n}\r\nstatic const char * __init ux500_get_family(void)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "ux500");\r\n}\r\nstatic const char * __init ux500_get_revision(void)\r\n{\r\nunsigned int rev = dbx500_id.revision;\r\nif (rev == 0x01)\r\nreturn kasprintf(GFP_KERNEL, "%s", "ED");\r\nelse if (rev >= 0xA0)\r\nreturn kasprintf(GFP_KERNEL, "%d.%d",\r\n(rev >> 4) - 0xA + 1, rev & 0xf);\r\nreturn kasprintf(GFP_KERNEL, "%s", "Unknown");\r\n}\r\nstatic ssize_t ux500_get_process(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nif (dbx500_id.process == 0x00)\r\nreturn sprintf(buf, "Standard\n");\r\nreturn sprintf(buf, "%02xnm\n", dbx500_id.process);\r\n}\r\nstatic const char *db8500_read_soc_id(struct device_node *backupram)\r\n{\r\nvoid __iomem *base;\r\nvoid __iomem *uid;\r\nconst char *retstr;\r\nbase = of_iomap(backupram, 0);\r\nif (!base)\r\nreturn NULL;\r\nuid = base + 0x1fc0;\r\nadd_device_randomness(uid, 0x14);\r\nretstr = kasprintf(GFP_KERNEL, "%08x%08x%08x%08x%08x",\r\nreadl((u32 *)uid+0),\r\nreadl((u32 *)uid+1), readl((u32 *)uid+2),\r\nreadl((u32 *)uid+3), readl((u32 *)uid+4));\r\niounmap(base);\r\nreturn retstr;\r\n}\r\nstatic void __init soc_info_populate(struct soc_device_attribute *soc_dev_attr,\r\nstruct device_node *backupram)\r\n{\r\nsoc_dev_attr->soc_id = db8500_read_soc_id(backupram);\r\nsoc_dev_attr->machine = ux500_get_machine();\r\nsoc_dev_attr->family = ux500_get_family();\r\nsoc_dev_attr->revision = ux500_get_revision();\r\n}\r\nstatic int __init ux500_soc_device_init(void)\r\n{\r\nstruct device *parent;\r\nstruct soc_device *soc_dev;\r\nstruct soc_device_attribute *soc_dev_attr;\r\nstruct device_node *backupram;\r\nbackupram = of_find_compatible_node(NULL, NULL, "ste,dbx500-backupram");\r\nif (!backupram)\r\nreturn 0;\r\nux500_setup_id();\r\nsoc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);\r\nif (!soc_dev_attr)\r\nreturn -ENOMEM;\r\nsoc_info_populate(soc_dev_attr, backupram);\r\nsoc_dev = soc_device_register(soc_dev_attr);\r\nif (IS_ERR(soc_dev)) {\r\nkfree(soc_dev_attr);\r\nreturn PTR_ERR(soc_dev);\r\n}\r\nparent = soc_device_to_device(soc_dev);\r\ndevice_create_file(parent, &ux500_soc_attr);\r\nreturn 0;\r\n}
