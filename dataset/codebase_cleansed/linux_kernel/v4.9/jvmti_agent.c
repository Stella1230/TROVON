static inline pid_t gettid(void)\r\n{\r\nreturn (pid_t)syscall(__NR_gettid);\r\n}\r\nstatic int get_e_machine(struct jitheader *hdr)\r\n{\r\nssize_t sret;\r\nchar id[16];\r\nint fd, ret = -1;\r\nstruct {\r\nuint16_t e_type;\r\nuint16_t e_machine;\r\n} info;\r\nfd = open("/proc/self/exe", O_RDONLY);\r\nif (fd == -1)\r\nreturn -1;\r\nsret = read(fd, id, sizeof(id));\r\nif (sret != sizeof(id))\r\ngoto error;\r\nif (id[0] != 0x7f || id[1] != 'E' || id[2] != 'L' || id[3] != 'F')\r\ngoto error;\r\nsret = read(fd, &info, sizeof(info));\r\nif (sret != sizeof(info))\r\ngoto error;\r\nhdr->elf_mach = info.e_machine;\r\nret = 0;\r\nerror:\r\nclose(fd);\r\nreturn ret;\r\n}\r\nstatic inline uint64_t\r\nget_arch_timestamp(void)\r\n{\r\n#if defined(__i386__) || defined(__x86_64__)\r\nunsigned int low, high;\r\nasm volatile("rdtsc" : "=a" (low), "=d" (high));\r\nreturn low | ((uint64_t)high) << 32;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic inline uint64_t\r\ntimespec_to_ns(const struct timespec *ts)\r\n{\r\nreturn ((uint64_t) ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec;\r\n}\r\nstatic inline uint64_t\r\nperf_get_timestamp(void)\r\n{\r\nstruct timespec ts;\r\nint ret;\r\nif (use_arch_timestamp)\r\nreturn get_arch_timestamp();\r\nret = clock_gettime(perf_clk_id, &ts);\r\nif (ret)\r\nreturn 0;\r\nreturn timespec_to_ns(&ts);\r\n}\r\nstatic int\r\ndebug_cache_init(void)\r\n{\r\nchar str[32];\r\nchar *base, *p;\r\nstruct tm tm;\r\ntime_t t;\r\nint ret;\r\ntime(&t);\r\nlocaltime_r(&t, &tm);\r\nbase = getenv("JITDUMPDIR");\r\nif (!base)\r\nbase = getenv("HOME");\r\nif (!base)\r\nbase = ".";\r\nstrftime(str, sizeof(str), JIT_LANG"-jit-%Y%m%d", &tm);\r\nsnprintf(jit_path, PATH_MAX - 1, "%s/.debug/", base);\r\nret = mkdir(jit_path, 0755);\r\nif (ret == -1) {\r\nif (errno != EEXIST) {\r\nwarn("jvmti: cannot create jit cache dir %s", jit_path);\r\nreturn -1;\r\n}\r\n}\r\nsnprintf(jit_path, PATH_MAX - 1, "%s/.debug/jit", base);\r\nret = mkdir(jit_path, 0755);\r\nif (ret == -1) {\r\nif (errno != EEXIST) {\r\nwarn("cannot create jit cache dir %s", jit_path);\r\nreturn -1;\r\n}\r\n}\r\nsnprintf(jit_path, PATH_MAX - 1, "%s/.debug/jit/%s.XXXXXXXX", base, str);\r\np = mkdtemp(jit_path);\r\nif (p != jit_path) {\r\nwarn("cannot create jit cache dir %s", jit_path);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nperf_open_marker_file(int fd)\r\n{\r\nlong pgsz;\r\npgsz = sysconf(_SC_PAGESIZE);\r\nif (pgsz == -1)\r\nreturn -1;\r\nmarker_addr = mmap(NULL, pgsz, PROT_READ|PROT_EXEC, MAP_PRIVATE, fd, 0);\r\nreturn (marker_addr == MAP_FAILED) ? -1 : 0;\r\n}\r\nstatic void\r\nperf_close_marker_file(void)\r\n{\r\nlong pgsz;\r\nif (!marker_addr)\r\nreturn;\r\npgsz = sysconf(_SC_PAGESIZE);\r\nif (pgsz == -1)\r\nreturn;\r\nmunmap(marker_addr, pgsz);\r\n}\r\nstatic void\r\ninit_arch_timestamp(void)\r\n{\r\nchar *str = getenv("JITDUMP_USE_ARCH_TIMESTAMP");\r\nif (!str || !*str || !strcmp(str, "0"))\r\nreturn;\r\nuse_arch_timestamp = 1;\r\n}\r\nvoid *jvmti_open(void)\r\n{\r\nint pad_cnt;\r\nchar dump_path[PATH_MAX];\r\nstruct jitheader header;\r\nint fd;\r\nFILE *fp;\r\ninit_arch_timestamp();\r\nif (!perf_get_timestamp()) {\r\nif (use_arch_timestamp)\r\nwarnx("jvmti: arch timestamp not supported");\r\nelse\r\nwarnx("jvmti: kernel does not support %d clock id", perf_clk_id);\r\n}\r\nmemset(&header, 0, sizeof(header));\r\ndebug_cache_init();\r\nsnprintf(dump_path, PATH_MAX, "%s/jit-%i.dump", jit_path, getpid());\r\nfd = open(dump_path, O_CREAT|O_TRUNC|O_RDWR, 0666);\r\nif (fd == -1)\r\nreturn NULL;\r\nif (perf_open_marker_file(fd)) {\r\nwarnx("jvmti: failed to create marker file");\r\nreturn NULL;\r\n}\r\nfp = fdopen(fd, "w+");\r\nif (!fp) {\r\nwarn("jvmti: cannot create %s", dump_path);\r\nclose(fd);\r\ngoto error;\r\n}\r\nwarnx("jvmti: jitdump in %s", dump_path);\r\nif (get_e_machine(&header)) {\r\nwarn("get_e_machine failed\n");\r\ngoto error;\r\n}\r\nheader.magic = JITHEADER_MAGIC;\r\nheader.version = JITHEADER_VERSION;\r\nheader.total_size = sizeof(header);\r\nheader.pid = getpid();\r\npad_cnt = PADDING_8ALIGNED(header.total_size);\r\nheader.total_size += pad_cnt;\r\nheader.timestamp = perf_get_timestamp();\r\nif (use_arch_timestamp)\r\nheader.flags |= JITDUMP_FLAGS_ARCH_TIMESTAMP;\r\nif (!fwrite(&header, sizeof(header), 1, fp)) {\r\nwarn("jvmti: cannot write dumpfile header");\r\ngoto error;\r\n}\r\nif (pad_cnt && !fwrite(pad_bytes, pad_cnt, 1, fp)) {\r\nwarn("jvmti: cannot write dumpfile header padding");\r\ngoto error;\r\n}\r\nreturn fp;\r\nerror:\r\nfclose(fp);\r\nreturn NULL;\r\n}\r\nint\r\njvmti_close(void *agent)\r\n{\r\nstruct jr_code_close rec;\r\nFILE *fp = agent;\r\nif (!fp) {\r\nwarnx("jvmti: incalid fd in close_agent");\r\nreturn -1;\r\n}\r\nrec.p.id = JIT_CODE_CLOSE;\r\nrec.p.total_size = sizeof(rec);\r\nrec.p.timestamp = perf_get_timestamp();\r\nif (!fwrite(&rec, sizeof(rec), 1, fp))\r\nreturn -1;\r\nfclose(fp);\r\nfp = NULL;\r\nperf_close_marker_file();\r\nreturn 0;\r\n}\r\nint\r\njvmti_write_code(void *agent, char const *sym,\r\nuint64_t vma, void const *code, unsigned int const size)\r\n{\r\nstatic int code_generation = 1;\r\nstruct jr_code_load rec;\r\nsize_t sym_len;\r\nsize_t padding_count;\r\nFILE *fp = agent;\r\nint ret = -1;\r\nif (size == 0)\r\nreturn 0;\r\nif (!fp) {\r\nwarnx("jvmti: invalid fd in write_native_code");\r\nreturn -1;\r\n}\r\nsym_len = strlen(sym) + 1;\r\nrec.p.id = JIT_CODE_LOAD;\r\nrec.p.total_size = sizeof(rec) + sym_len;\r\npadding_count = PADDING_8ALIGNED(rec.p.total_size);\r\nrec.p. total_size += padding_count;\r\nrec.p.timestamp = perf_get_timestamp();\r\nrec.code_size = size;\r\nrec.vma = vma;\r\nrec.code_addr = vma;\r\nrec.pid = getpid();\r\nrec.tid = gettid();\r\nif (code)\r\nrec.p.total_size += size;\r\nflockfile(fp);\r\nrec.code_index = code_generation++;\r\nret = fwrite_unlocked(&rec, sizeof(rec), 1, fp);\r\nfwrite_unlocked(sym, sym_len, 1, fp);\r\nif (padding_count)\r\nfwrite_unlocked(pad_bytes, padding_count, 1, fp);\r\nif (code)\r\nfwrite_unlocked(code, size, 1, fp);\r\nfunlockfile(fp);\r\nret = 0;\r\nreturn ret;\r\n}\r\nint\r\njvmti_write_debug_info(void *agent, uint64_t code, const char *file,\r\njvmti_line_info_t *li, int nr_lines)\r\n{\r\nstruct jr_code_debug_info rec;\r\nsize_t sret, len, size, flen;\r\nsize_t padding_count;\r\nuint64_t addr;\r\nconst char *fn = file;\r\nFILE *fp = agent;\r\nint i;\r\nif (!nr_lines)\r\nreturn 0;\r\nif (!fp) {\r\nwarnx("jvmti: invalid fd in write_debug_info");\r\nreturn -1;\r\n}\r\nflen = strlen(file) + 1;\r\nrec.p.id = JIT_CODE_DEBUG_INFO;\r\nsize = sizeof(rec);\r\nrec.p.timestamp = perf_get_timestamp();\r\nrec.code_addr = (uint64_t)(uintptr_t)code;\r\nrec.nr_entry = nr_lines;\r\nsize += nr_lines * sizeof(struct debug_entry);\r\nsize += flen * nr_lines;\r\npadding_count = PADDING_8ALIGNED(size);\r\nrec.p.total_size = size + padding_count;\r\nflockfile(fp);\r\nsret = fwrite_unlocked(&rec, sizeof(rec), 1, fp);\r\nif (sret != 1)\r\ngoto error;\r\nfor (i = 0; i < nr_lines; i++) {\r\naddr = (uint64_t)li[i].pc;\r\nlen = sizeof(addr);\r\nsret = fwrite_unlocked(&addr, len, 1, fp);\r\nif (sret != 1)\r\ngoto error;\r\nlen = sizeof(li[0].line_number);\r\nsret = fwrite_unlocked(&li[i].line_number, len, 1, fp);\r\nif (sret != 1)\r\ngoto error;\r\nlen = sizeof(li[0].discrim);\r\nsret = fwrite_unlocked(&li[i].discrim, len, 1, fp);\r\nif (sret != 1)\r\ngoto error;\r\nsret = fwrite_unlocked(fn, flen, 1, fp);\r\nif (sret != 1)\r\ngoto error;\r\n}\r\nif (padding_count) {\r\nsret = fwrite_unlocked(pad_bytes, padding_count, 1, fp);\r\nif (sret != 1)\r\ngoto error;\r\n}\r\nfunlockfile(fp);\r\nreturn 0;\r\nerror:\r\nfunlockfile(fp);\r\nreturn -1;\r\n}
