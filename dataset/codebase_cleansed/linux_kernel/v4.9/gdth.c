static void ser_init()\r\n{\r\nunsigned port=COM_BASE;\r\noutb(0x80,port+3);\r\noutb(0,port+1);\r\noutb(6, port);\r\noutb(3,port+3);\r\noutb(0,port+1);\r\n}\r\nstatic void ser_puts(char *str)\r\n{\r\nchar *ptr;\r\nser_init();\r\nfor (ptr=str;*ptr;++ptr)\r\nser_putc(*ptr);\r\n}\r\nstatic void ser_putc(char c)\r\n{\r\nunsigned port=COM_BASE;\r\nwhile ((inb(port+5) & 0x20)==0);\r\noutb(c,port);\r\nif (c==0x0a)\r\n{\r\nwhile ((inb(port+5) & 0x20)==0);\r\noutb(0x0d,port);\r\n}\r\n}\r\nstatic int ser_printk(const char *fmt, ...)\r\n{\r\nva_list args;\r\nint i;\r\nva_start(args,fmt);\r\ni = vsprintf(strbuf,fmt,args);\r\nser_puts(strbuf);\r\nva_end(args);\r\nreturn i;\r\n}\r\nstatic gdth_ha_str *gdth_find_ha(int hanum)\r\n{\r\ngdth_ha_str *ha;\r\nlist_for_each_entry(ha, &gdth_instances, list)\r\nif (hanum == ha->hanum)\r\nreturn ha;\r\nreturn NULL;\r\n}\r\nstatic struct gdth_cmndinfo *gdth_get_cmndinfo(gdth_ha_str *ha)\r\n{\r\nstruct gdth_cmndinfo *priv = NULL;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nfor (i=0; i<GDTH_MAXCMDS; ++i) {\r\nif (ha->cmndinfo[i].index == 0) {\r\npriv = &ha->cmndinfo[i];\r\nmemset(priv, 0, sizeof(*priv));\r\npriv->index = i+1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn priv;\r\n}\r\nstatic void gdth_put_cmndinfo(struct gdth_cmndinfo *priv)\r\n{\r\nBUG_ON(!priv);\r\npriv->index = 0;\r\n}\r\nstatic void gdth_delay(int milliseconds)\r\n{\r\nif (milliseconds == 0) {\r\nudelay(1);\r\n} else {\r\nmdelay(milliseconds);\r\n}\r\n}\r\nstatic void gdth_scsi_done(struct scsi_cmnd *scp)\r\n{\r\nstruct gdth_cmndinfo *cmndinfo = gdth_cmnd_priv(scp);\r\nint internal_command = cmndinfo->internal_command;\r\nTRACE2(("gdth_scsi_done()\n"));\r\ngdth_put_cmndinfo(cmndinfo);\r\nscp->host_scribble = NULL;\r\nif (internal_command)\r\ncomplete((struct completion *)scp->request);\r\nelse\r\nscp->scsi_done(scp);\r\n}\r\nint __gdth_execute(struct scsi_device *sdev, gdth_cmd_str *gdtcmd, char *cmnd,\r\nint timeout, u32 *info)\r\n{\r\ngdth_ha_str *ha = shost_priv(sdev->host);\r\nScsi_Cmnd *scp;\r\nstruct gdth_cmndinfo cmndinfo;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nint rval;\r\nscp = kzalloc(sizeof(*scp), GFP_KERNEL);\r\nif (!scp)\r\nreturn -ENOMEM;\r\nscp->sense_buffer = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\r\nif (!scp->sense_buffer) {\r\nkfree(scp);\r\nreturn -ENOMEM;\r\n}\r\nscp->device = sdev;\r\nmemset(&cmndinfo, 0, sizeof(cmndinfo));\r\nscp->request = (struct request *)&wait;\r\nscp->cmd_len = 12;\r\nscp->cmnd = cmnd;\r\ncmndinfo.priority = IOCTL_PRI;\r\ncmndinfo.internal_cmd_str = gdtcmd;\r\ncmndinfo.internal_command = 1;\r\nTRACE(("__gdth_execute() cmd 0x%x\n", scp->cmnd[0]));\r\n__gdth_queuecommand(ha, scp, &cmndinfo);\r\nwait_for_completion(&wait);\r\nrval = cmndinfo.status;\r\nif (info)\r\n*info = cmndinfo.info;\r\nkfree(scp->sense_buffer);\r\nkfree(scp);\r\nreturn rval;\r\n}\r\nint gdth_execute(struct Scsi_Host *shost, gdth_cmd_str *gdtcmd, char *cmnd,\r\nint timeout, u32 *info)\r\n{\r\nstruct scsi_device *sdev = scsi_get_host_dev(shost);\r\nint rval = __gdth_execute(sdev, gdtcmd, cmnd, timeout, info);\r\nscsi_free_host_dev(sdev);\r\nreturn rval;\r\n}\r\nstatic void gdth_eval_mapping(u32 size, u32 *cyls, int *heads, int *secs)\r\n{\r\n*cyls = size /HEADS/SECS;\r\nif (*cyls <= MAXCYLS) {\r\n*heads = HEADS;\r\n*secs = SECS;\r\n} else {\r\n*cyls = size /MEDHEADS/MEDSECS;\r\nif (*cyls <= MAXCYLS) {\r\n*heads = MEDHEADS;\r\n*secs = MEDSECS;\r\n} else {\r\n*cyls = size /BIGHEADS/BIGSECS;\r\n*heads = BIGHEADS;\r\n*secs = BIGSECS;\r\n}\r\n}\r\n}\r\nstatic int __init gdth_search_eisa(u16 eisa_adr)\r\n{\r\nu32 id;\r\nTRACE(("gdth_search_eisa() adr. %x\n",eisa_adr));\r\nid = inl(eisa_adr+ID0REG);\r\nif (id == GDT3A_ID || id == GDT3B_ID) {\r\nif ((inb(eisa_adr+EISAREG) & 8) == 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nif (id == GDT3_ID)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init gdth_search_isa(u32 bios_adr)\r\n{\r\nvoid __iomem *addr;\r\nu32 id;\r\nTRACE(("gdth_search_isa() bios adr. %x\n",bios_adr));\r\nif ((addr = ioremap(bios_adr+BIOS_ID_OFFS, sizeof(u32))) != NULL) {\r\nid = readl(addr);\r\niounmap(addr);\r\nif (id == GDT2_ID)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool gdth_search_vortex(u16 device)\r\n{\r\nif (device <= PCI_DEVICE_ID_VORTEX_GDT6555)\r\nreturn true;\r\nif (device >= PCI_DEVICE_ID_VORTEX_GDT6x17RP &&\r\ndevice <= PCI_DEVICE_ID_VORTEX_GDTMAXRP)\r\nreturn true;\r\nif (device == PCI_DEVICE_ID_VORTEX_GDTNEWRX ||\r\ndevice == PCI_DEVICE_ID_VORTEX_GDTNEWRX2)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void gdth_pci_remove_one(struct pci_dev *pdev)\r\n{\r\ngdth_ha_str *ha = pci_get_drvdata(pdev);\r\nlist_del(&ha->list);\r\ngdth_remove_one(ha);\r\npci_disable_device(pdev);\r\n}\r\nstatic int gdth_pci_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nu16 vendor = pdev->vendor;\r\nu16 device = pdev->device;\r\nunsigned long base0, base1, base2;\r\nint rc;\r\ngdth_pci_str gdth_pcistr;\r\ngdth_ha_str *ha = NULL;\r\nTRACE(("gdth_search_dev() cnt %d vendor %x device %x\n",\r\ngdth_ctr_count, vendor, device));\r\nmemset(&gdth_pcistr, 0, sizeof(gdth_pcistr));\r\nif (vendor == PCI_VENDOR_ID_VORTEX && !gdth_search_vortex(device))\r\nreturn -ENODEV;\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (gdth_ctr_count >= MAXHA)\r\nreturn -EBUSY;\r\ngdth_pcistr.pdev = pdev;\r\nbase0 = pci_resource_flags(pdev, 0);\r\nbase1 = pci_resource_flags(pdev, 1);\r\nbase2 = pci_resource_flags(pdev, 2);\r\nif (device <= PCI_DEVICE_ID_VORTEX_GDT6000B ||\r\ndevice >= PCI_DEVICE_ID_VORTEX_GDT6x17RP) {\r\nif (!(base0 & IORESOURCE_MEM))\r\nreturn -ENODEV;\r\ngdth_pcistr.dpmem = pci_resource_start(pdev, 0);\r\n} else {\r\nif (!(base0 & IORESOURCE_MEM) ||\r\n!(base2 & IORESOURCE_MEM) ||\r\n!(base1 & IORESOURCE_IO))\r\nreturn -ENODEV;\r\ngdth_pcistr.dpmem = pci_resource_start(pdev, 2);\r\ngdth_pcistr.io = pci_resource_start(pdev, 1);\r\n}\r\nTRACE2(("Controller found at %d/%d, irq %d, dpmem 0x%lx\n",\r\ngdth_pcistr.pdev->bus->number,\r\nPCI_SLOT(gdth_pcistr.pdev->devfn),\r\ngdth_pcistr.irq,\r\ngdth_pcistr.dpmem));\r\nrc = gdth_pci_probe_one(&gdth_pcistr, &ha);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int __init gdth_init_eisa(u16 eisa_adr,gdth_ha_str *ha)\r\n{\r\nu32 retries,id;\r\nu8 prot_ver,eisacf,i,irq_found;\r\nTRACE(("gdth_init_eisa() adr. %x\n",eisa_adr));\r\noutb(0xff,eisa_adr+EDOORREG);\r\noutb(0x00,eisa_adr+EDENABREG);\r\noutb(0x00,eisa_adr+EINTENABREG);\r\noutb(0xff,eisa_adr+LDOORREG);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (inb(eisa_adr+EDOORREG) != 0xff) {\r\nif (--retries == 0) {\r\nprintk("GDT-EISA: Initialization error (DEINIT failed)\n");\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\nTRACE2(("wait for DEINIT: retries=%d\n",retries));\r\n}\r\nprot_ver = inb(eisa_adr+MAILBOXREG);\r\noutb(0xff,eisa_adr+EDOORREG);\r\nif (prot_ver != PROTOCOL_VERSION) {\r\nprintk("GDT-EISA: Illegal protocol version\n");\r\nreturn 0;\r\n}\r\nha->bmic = eisa_adr;\r\nha->brd_phys = (u32)eisa_adr >> 12;\r\noutl(0,eisa_adr+MAILBOXREG);\r\noutl(0,eisa_adr+MAILBOXREG+4);\r\noutl(0,eisa_adr+MAILBOXREG+8);\r\noutl(0,eisa_adr+MAILBOXREG+12);\r\nif ((id = inl(eisa_adr+ID0REG)) == GDT3_ID) {\r\nha->oem_id = OEM_ID_ICP;\r\nha->type = GDT_EISA;\r\nha->stype = id;\r\noutl(1,eisa_adr+MAILBOXREG+8);\r\noutb(0xfe,eisa_adr+LDOORREG);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (inb(eisa_adr+EDOORREG) != 0xfe) {\r\nif (--retries == 0) {\r\nprintk("GDT-EISA: Initialization error (get IRQ failed)\n");\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nha->irq = inb(eisa_adr+MAILBOXREG);\r\noutb(0xff,eisa_adr+EDOORREG);\r\nTRACE2(("GDT3000/3020: IRQ=%d\n",ha->irq));\r\nif (ha->irq == 0) {\r\nTRACE2(("Unknown IRQ, use IRQ table from cmd line !\n"));\r\nfor (i = 0, irq_found = FALSE;\r\ni < MAXHA && irq[i] != 0xff; ++i) {\r\nif (irq[i]==10 || irq[i]==11 || irq[i]==12 || irq[i]==14) {\r\nirq_found = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (irq_found) {\r\nha->irq = irq[i];\r\nirq[i] = 0;\r\nprintk("GDT-EISA: Can not detect controller IRQ,\n");\r\nprintk("Use IRQ setting from command line (IRQ = %d)\n",\r\nha->irq);\r\n} else {\r\nprintk("GDT-EISA: Initialization error (unknown IRQ), Enable\n");\r\nprintk("the controller BIOS or use command line parameters\n");\r\nreturn 0;\r\n}\r\n}\r\n} else {\r\neisacf = inb(eisa_adr+EISAREG) & 7;\r\nif (eisacf > 4)\r\neisacf -= 4;\r\nha->irq = gdth_irq_tab[eisacf];\r\nha->oem_id = OEM_ID_ICP;\r\nha->type = GDT_EISA;\r\nha->stype = id;\r\n}\r\nha->dma64_support = 0;\r\nreturn 1;\r\n}\r\nstatic int __init gdth_init_isa(u32 bios_adr,gdth_ha_str *ha)\r\n{\r\nregister gdt2_dpram_str __iomem *dp2_ptr;\r\nint i;\r\nu8 irq_drq,prot_ver;\r\nu32 retries;\r\nTRACE(("gdth_init_isa() bios adr. %x\n",bios_adr));\r\nha->brd = ioremap(bios_adr, sizeof(gdt2_dpram_str));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-ISA: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\ndp2_ptr = ha->brd;\r\nwriteb(1, &dp2_ptr->io.memlock);\r\nmemset_io(&dp2_ptr->u, 0, sizeof(dp2_ptr->u));\r\nif (readl(&dp2_ptr->u) != 0) {\r\nprintk("GDT-ISA: Initialization error (DPMEM write error)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\nwriteb(0xff, &dp2_ptr->io.irqdel);\r\nwriteb(0x00, &dp2_ptr->io.irqen);\r\nwriteb(0x00, &dp2_ptr->u.ic.S_Status);\r\nwriteb(0x00, &dp2_ptr->u.ic.Cmd_Index);\r\nirq_drq = readb(&dp2_ptr->io.rq);\r\nfor (i=0; i<3; ++i) {\r\nif ((irq_drq & 1)==0)\r\nbreak;\r\nirq_drq >>= 1;\r\n}\r\nha->drq = gdth_drq_tab[i];\r\nirq_drq = readb(&dp2_ptr->io.rq) >> 3;\r\nfor (i=1; i<5; ++i) {\r\nif ((irq_drq & 1)==0)\r\nbreak;\r\nirq_drq >>= 1;\r\n}\r\nha->irq = gdth_irq_tab[i];\r\nwritel(bios_adr, &dp2_ptr->u.ic.S_Info[0]);\r\nwriteb(0xff, &dp2_ptr->u.ic.S_Cmd_Indx);\r\nwriteb(0, &dp2_ptr->io.event);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp2_ptr->u.ic.S_Status) != 0xff) {\r\nif (--retries == 0) {\r\nprintk("GDT-ISA: Initialization error (DEINIT failed)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nprot_ver = (u8)readl(&dp2_ptr->u.ic.S_Info[0]);\r\nwriteb(0, &dp2_ptr->u.ic.Status);\r\nwriteb(0xff, &dp2_ptr->io.irqdel);\r\nif (prot_ver != PROTOCOL_VERSION) {\r\nprintk("GDT-ISA: Illegal protocol version\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\nha->oem_id = OEM_ID_ICP;\r\nha->type = GDT_ISA;\r\nha->ic_all_size = sizeof(dp2_ptr->u);\r\nha->stype= GDT2_ID;\r\nha->brd_phys = bios_adr >> 4;\r\nwritel(0x00, &dp2_ptr->u.ic.S_Info[0]);\r\nwritel(0x00, &dp2_ptr->u.ic.S_Info[1]);\r\nwritel(0x01, &dp2_ptr->u.ic.S_Info[2]);\r\nwritel(0x00, &dp2_ptr->u.ic.S_Info[3]);\r\nwriteb(0xfe, &dp2_ptr->u.ic.S_Cmd_Indx);\r\nwriteb(0, &dp2_ptr->io.event);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp2_ptr->u.ic.S_Status) != 0xfe) {\r\nif (--retries == 0) {\r\nprintk("GDT-ISA: Initialization error\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nwriteb(0, &dp2_ptr->u.ic.Status);\r\nwriteb(0xff, &dp2_ptr->io.irqdel);\r\nha->dma64_support = 0;\r\nreturn 1;\r\n}\r\nstatic int gdth_init_pci(struct pci_dev *pdev, gdth_pci_str *pcistr,\r\ngdth_ha_str *ha)\r\n{\r\nregister gdt6_dpram_str __iomem *dp6_ptr;\r\nregister gdt6c_dpram_str __iomem *dp6c_ptr;\r\nregister gdt6m_dpram_str __iomem *dp6m_ptr;\r\nu32 retries;\r\nu8 prot_ver;\r\nu16 command;\r\nint i, found = FALSE;\r\nTRACE(("gdth_init_pci()\n"));\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL)\r\nha->oem_id = OEM_ID_INTEL;\r\nelse\r\nha->oem_id = OEM_ID_ICP;\r\nha->brd_phys = (pdev->bus->number << 8) | (pdev->devfn & 0xf8);\r\nha->stype = (u32)pdev->device;\r\nha->irq = pdev->irq;\r\nha->pdev = pdev;\r\nif (ha->pdev->device <= PCI_DEVICE_ID_VORTEX_GDT6000B) {\r\nTRACE2(("init_pci() dpmem %lx irq %d\n",pcistr->dpmem,ha->irq));\r\nha->brd = ioremap(pcistr->dpmem, sizeof(gdt6_dpram_str));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\ndp6_ptr = ha->brd;\r\nwritel(DPMEM_MAGIC, &dp6_ptr->u);\r\nif (readl(&dp6_ptr->u) != DPMEM_MAGIC) {\r\nprintk("GDT-PCI: Cannot access DPMEM at 0x%lx (shadowed?)\n",\r\npcistr->dpmem);\r\nfound = FALSE;\r\nfor (i = 0xC8000; i < 0xE8000; i += 0x4000) {\r\niounmap(ha->brd);\r\nha->brd = ioremap(i, sizeof(u16));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\nif (readw(ha->brd) != 0xffff) {\r\nTRACE2(("init_pci_old() address 0x%x busy\n", i));\r\ncontinue;\r\n}\r\niounmap(ha->brd);\r\npci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, i);\r\nha->brd = ioremap(i, sizeof(gdt6_dpram_str));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\ndp6_ptr = ha->brd;\r\nwritel(DPMEM_MAGIC, &dp6_ptr->u);\r\nif (readl(&dp6_ptr->u) == DPMEM_MAGIC) {\r\nprintk("GDT-PCI: Use free address at 0x%x\n", i);\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nprintk("GDT-PCI: No free address found!\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\n}\r\nmemset_io(&dp6_ptr->u, 0, sizeof(dp6_ptr->u));\r\nif (readl(&dp6_ptr->u) != 0) {\r\nprintk("GDT-PCI: Initialization error (DPMEM write error)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\nwriteb(0xff, &dp6_ptr->io.irqdel);\r\nwriteb(0x00, &dp6_ptr->io.irqen);\r\nwriteb(0x00, &dp6_ptr->u.ic.S_Status);\r\nwriteb(0x00, &dp6_ptr->u.ic.Cmd_Index);\r\nwritel(pcistr->dpmem, &dp6_ptr->u.ic.S_Info[0]);\r\nwriteb(0xff, &dp6_ptr->u.ic.S_Cmd_Indx);\r\nwriteb(0, &dp6_ptr->io.event);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp6_ptr->u.ic.S_Status) != 0xff) {\r\nif (--retries == 0) {\r\nprintk("GDT-PCI: Initialization error (DEINIT failed)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nprot_ver = (u8)readl(&dp6_ptr->u.ic.S_Info[0]);\r\nwriteb(0, &dp6_ptr->u.ic.S_Status);\r\nwriteb(0xff, &dp6_ptr->io.irqdel);\r\nif (prot_ver != PROTOCOL_VERSION) {\r\nprintk("GDT-PCI: Illegal protocol version\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\nha->type = GDT_PCI;\r\nha->ic_all_size = sizeof(dp6_ptr->u);\r\nwritel(0x00, &dp6_ptr->u.ic.S_Info[0]);\r\nwritel(0x00, &dp6_ptr->u.ic.S_Info[1]);\r\nwritel(0x00, &dp6_ptr->u.ic.S_Info[2]);\r\nwritel(0x00, &dp6_ptr->u.ic.S_Info[3]);\r\nwriteb(0xfe, &dp6_ptr->u.ic.S_Cmd_Indx);\r\nwriteb(0, &dp6_ptr->io.event);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp6_ptr->u.ic.S_Status) != 0xfe) {\r\nif (--retries == 0) {\r\nprintk("GDT-PCI: Initialization error\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nwriteb(0, &dp6_ptr->u.ic.S_Status);\r\nwriteb(0xff, &dp6_ptr->io.irqdel);\r\nha->dma64_support = 0;\r\n} else if (ha->pdev->device <= PCI_DEVICE_ID_VORTEX_GDT6555) {\r\nha->plx = (gdt6c_plx_regs *)pcistr->io;\r\nTRACE2(("init_pci_new() dpmem %lx irq %d\n",\r\npcistr->dpmem,ha->irq));\r\nha->brd = ioremap(pcistr->dpmem, sizeof(gdt6c_dpram_str));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ndp6c_ptr = ha->brd;\r\nwritel(DPMEM_MAGIC, &dp6c_ptr->u);\r\nif (readl(&dp6c_ptr->u) != DPMEM_MAGIC) {\r\nprintk("GDT-PCI: Cannot access DPMEM at 0x%lx (shadowed?)\n",\r\npcistr->dpmem);\r\nfound = FALSE;\r\nfor (i = 0xC8000; i < 0xE8000; i += 0x4000) {\r\niounmap(ha->brd);\r\nha->brd = ioremap(i, sizeof(u16));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\nif (readw(ha->brd) != 0xffff) {\r\nTRACE2(("init_pci_plx() address 0x%x busy\n", i));\r\ncontinue;\r\n}\r\niounmap(ha->brd);\r\npci_write_config_dword(pdev, PCI_BASE_ADDRESS_2, i);\r\nha->brd = ioremap(i, sizeof(gdt6c_dpram_str));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\ndp6c_ptr = ha->brd;\r\nwritel(DPMEM_MAGIC, &dp6c_ptr->u);\r\nif (readl(&dp6c_ptr->u) == DPMEM_MAGIC) {\r\nprintk("GDT-PCI: Use free address at 0x%x\n", i);\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nprintk("GDT-PCI: No free address found!\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\n}\r\nmemset_io(&dp6c_ptr->u, 0, sizeof(dp6c_ptr->u));\r\nif (readl(&dp6c_ptr->u) != 0) {\r\nprintk("GDT-PCI: Initialization error (DPMEM write error)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\noutb(0x00,PTR2USHORT(&ha->plx->control1));\r\noutb(0xff,PTR2USHORT(&ha->plx->edoor_reg));\r\nwriteb(0x00, &dp6c_ptr->u.ic.S_Status);\r\nwriteb(0x00, &dp6c_ptr->u.ic.Cmd_Index);\r\nwritel(pcistr->dpmem, &dp6c_ptr->u.ic.S_Info[0]);\r\nwriteb(0xff, &dp6c_ptr->u.ic.S_Cmd_Indx);\r\noutb(1,PTR2USHORT(&ha->plx->ldoor_reg));\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp6c_ptr->u.ic.S_Status) != 0xff) {\r\nif (--retries == 0) {\r\nprintk("GDT-PCI: Initialization error (DEINIT failed)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nprot_ver = (u8)readl(&dp6c_ptr->u.ic.S_Info[0]);\r\nwriteb(0, &dp6c_ptr->u.ic.Status);\r\nif (prot_ver != PROTOCOL_VERSION) {\r\nprintk("GDT-PCI: Illegal protocol version\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\nha->type = GDT_PCINEW;\r\nha->ic_all_size = sizeof(dp6c_ptr->u);\r\nwritel(0x00, &dp6c_ptr->u.ic.S_Info[0]);\r\nwritel(0x00, &dp6c_ptr->u.ic.S_Info[1]);\r\nwritel(0x00, &dp6c_ptr->u.ic.S_Info[2]);\r\nwritel(0x00, &dp6c_ptr->u.ic.S_Info[3]);\r\nwriteb(0xfe, &dp6c_ptr->u.ic.S_Cmd_Indx);\r\noutb(1,PTR2USHORT(&ha->plx->ldoor_reg));\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp6c_ptr->u.ic.S_Status) != 0xfe) {\r\nif (--retries == 0) {\r\nprintk("GDT-PCI: Initialization error\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nwriteb(0, &dp6c_ptr->u.ic.S_Status);\r\nha->dma64_support = 0;\r\n} else {\r\nTRACE2(("init_pci_mpr() dpmem %lx irq %d\n",pcistr->dpmem,ha->irq));\r\nha->brd = ioremap(pcistr->dpmem, sizeof(gdt6m_dpram_str));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\npci_read_config_word(pdev, PCI_COMMAND, &command);\r\ncommand |= 6;\r\npci_write_config_word(pdev, PCI_COMMAND, command);\r\ngdth_delay(1);\r\ndp6m_ptr = ha->brd;\r\nwhile( ((int)readb(&dp6m_ptr->i960r.sema0_reg) ) & 3 )\r\ngdth_delay(1);\r\nwritel(DPMEM_MAGIC, &dp6m_ptr->u);\r\nif (readl(&dp6m_ptr->u) != DPMEM_MAGIC) {\r\nprintk("GDT-PCI: Cannot access DPMEM at 0x%lx (shadowed?)\n",\r\npcistr->dpmem);\r\nfound = FALSE;\r\nfor (i = 0xC8000; i < 0xE8000; i += 0x4000) {\r\niounmap(ha->brd);\r\nha->brd = ioremap(i, sizeof(u16));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\nif (readw(ha->brd) != 0xffff) {\r\nTRACE2(("init_pci_mpr() address 0x%x busy\n", i));\r\ncontinue;\r\n}\r\niounmap(ha->brd);\r\npci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, i);\r\nha->brd = ioremap(i, sizeof(gdt6m_dpram_str));\r\nif (ha->brd == NULL) {\r\nprintk("GDT-PCI: Initialization error (DPMEM remap error)\n");\r\nreturn 0;\r\n}\r\ndp6m_ptr = ha->brd;\r\nwritel(DPMEM_MAGIC, &dp6m_ptr->u);\r\nif (readl(&dp6m_ptr->u) == DPMEM_MAGIC) {\r\nprintk("GDT-PCI: Use free address at 0x%x\n", i);\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nprintk("GDT-PCI: No free address found!\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\n}\r\nmemset_io(&dp6m_ptr->u, 0, sizeof(dp6m_ptr->u));\r\nwriteb(readb(&dp6m_ptr->i960r.edoor_en_reg) | 4,\r\n&dp6m_ptr->i960r.edoor_en_reg);\r\nwriteb(0xff, &dp6m_ptr->i960r.edoor_reg);\r\nwriteb(0x00, &dp6m_ptr->u.ic.S_Status);\r\nwriteb(0x00, &dp6m_ptr->u.ic.Cmd_Index);\r\nwritel(pcistr->dpmem, &dp6m_ptr->u.ic.S_Info[0]);\r\nwriteb(0xff, &dp6m_ptr->u.ic.S_Cmd_Indx);\r\nwriteb(1, &dp6m_ptr->i960r.ldoor_reg);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp6m_ptr->u.ic.S_Status) != 0xff) {\r\nif (--retries == 0) {\r\nprintk("GDT-PCI: Initialization error (DEINIT failed)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nprot_ver = (u8)readl(&dp6m_ptr->u.ic.S_Info[0]);\r\nwriteb(0, &dp6m_ptr->u.ic.S_Status);\r\nif (prot_ver != PROTOCOL_VERSION) {\r\nprintk("GDT-PCI: Illegal protocol version\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\nha->type = GDT_PCIMPR;\r\nha->ic_all_size = sizeof(dp6m_ptr->u);\r\nwritel(0x00, &dp6m_ptr->u.ic.S_Info[0]);\r\nwritel(0x00, &dp6m_ptr->u.ic.S_Info[1]);\r\nwritel(0x00, &dp6m_ptr->u.ic.S_Info[2]);\r\nwritel(0x00, &dp6m_ptr->u.ic.S_Info[3]);\r\nwriteb(0xfe, &dp6m_ptr->u.ic.S_Cmd_Indx);\r\nwriteb(1, &dp6m_ptr->i960r.ldoor_reg);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp6m_ptr->u.ic.S_Status) != 0xfe) {\r\nif (--retries == 0) {\r\nprintk("GDT-PCI: Initialization error\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nwriteb(0, &dp6m_ptr->u.ic.S_Status);\r\nwriteb(0xfd, &dp6m_ptr->u.ic.S_Cmd_Indx);\r\nwriteb(1, &dp6m_ptr->i960r.ldoor_reg);\r\nretries = INIT_RETRIES;\r\ngdth_delay(20);\r\nwhile (readb(&dp6m_ptr->u.ic.S_Status) != 0xfd) {\r\nif (--retries == 0) {\r\nprintk("GDT-PCI: Initialization error (DEINIT failed)\n");\r\niounmap(ha->brd);\r\nreturn 0;\r\n}\r\ngdth_delay(1);\r\n}\r\nprot_ver = (u8)(readl(&dp6m_ptr->u.ic.S_Info[0]) >> 16);\r\nwriteb(0, &dp6m_ptr->u.ic.S_Status);\r\nif (prot_ver < 0x2b)\r\nha->dma64_support = 0;\r\nelse\r\nha->dma64_support = 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic void gdth_enable_int(gdth_ha_str *ha)\r\n{\r\nunsigned long flags;\r\ngdt2_dpram_str __iomem *dp2_ptr;\r\ngdt6_dpram_str __iomem *dp6_ptr;\r\ngdt6m_dpram_str __iomem *dp6m_ptr;\r\nTRACE(("gdth_enable_int() hanum %d\n",ha->hanum));\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nif (ha->type == GDT_EISA) {\r\noutb(0xff, ha->bmic + EDOORREG);\r\noutb(0xff, ha->bmic + EDENABREG);\r\noutb(0x01, ha->bmic + EINTENABREG);\r\n} else if (ha->type == GDT_ISA) {\r\ndp2_ptr = ha->brd;\r\nwriteb(1, &dp2_ptr->io.irqdel);\r\nwriteb(0, &dp2_ptr->u.ic.Cmd_Index);\r\nwriteb(1, &dp2_ptr->io.irqen);\r\n} else if (ha->type == GDT_PCI) {\r\ndp6_ptr = ha->brd;\r\nwriteb(1, &dp6_ptr->io.irqdel);\r\nwriteb(0, &dp6_ptr->u.ic.Cmd_Index);\r\nwriteb(1, &dp6_ptr->io.irqen);\r\n} else if (ha->type == GDT_PCINEW) {\r\noutb(0xff, PTR2USHORT(&ha->plx->edoor_reg));\r\noutb(0x03, PTR2USHORT(&ha->plx->control1));\r\n} else if (ha->type == GDT_PCIMPR) {\r\ndp6m_ptr = ha->brd;\r\nwriteb(0xff, &dp6m_ptr->i960r.edoor_reg);\r\nwriteb(readb(&dp6m_ptr->i960r.edoor_en_reg) & ~4,\r\n&dp6m_ptr->i960r.edoor_en_reg);\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n}\r\nstatic u8 gdth_get_status(gdth_ha_str *ha)\r\n{\r\nu8 IStatus = 0;\r\nTRACE(("gdth_get_status() irq %d ctr_count %d\n", ha->irq, gdth_ctr_count));\r\nif (ha->type == GDT_EISA)\r\nIStatus = inb((u16)ha->bmic + EDOORREG);\r\nelse if (ha->type == GDT_ISA)\r\nIStatus =\r\nreadb(&((gdt2_dpram_str __iomem *)ha->brd)->u.ic.Cmd_Index);\r\nelse if (ha->type == GDT_PCI)\r\nIStatus =\r\nreadb(&((gdt6_dpram_str __iomem *)ha->brd)->u.ic.Cmd_Index);\r\nelse if (ha->type == GDT_PCINEW)\r\nIStatus = inb(PTR2USHORT(&ha->plx->edoor_reg));\r\nelse if (ha->type == GDT_PCIMPR)\r\nIStatus =\r\nreadb(&((gdt6m_dpram_str __iomem *)ha->brd)->i960r.edoor_reg);\r\nreturn IStatus;\r\n}\r\nstatic int gdth_test_busy(gdth_ha_str *ha)\r\n{\r\nregister int gdtsema0 = 0;\r\nTRACE(("gdth_test_busy() hanum %d\n", ha->hanum));\r\nif (ha->type == GDT_EISA)\r\ngdtsema0 = (int)inb(ha->bmic + SEMA0REG);\r\nelse if (ha->type == GDT_ISA)\r\ngdtsema0 = (int)readb(&((gdt2_dpram_str __iomem *)ha->brd)->u.ic.Sema0);\r\nelse if (ha->type == GDT_PCI)\r\ngdtsema0 = (int)readb(&((gdt6_dpram_str __iomem *)ha->brd)->u.ic.Sema0);\r\nelse if (ha->type == GDT_PCINEW)\r\ngdtsema0 = (int)inb(PTR2USHORT(&ha->plx->sema0_reg));\r\nelse if (ha->type == GDT_PCIMPR)\r\ngdtsema0 =\r\n(int)readb(&((gdt6m_dpram_str __iomem *)ha->brd)->i960r.sema0_reg);\r\nreturn (gdtsema0 & 1);\r\n}\r\nstatic int gdth_get_cmd_index(gdth_ha_str *ha)\r\n{\r\nint i;\r\nTRACE(("gdth_get_cmd_index() hanum %d\n", ha->hanum));\r\nfor (i=0; i<GDTH_MAXCMDS; ++i) {\r\nif (ha->cmd_tab[i].cmnd == UNUSED_CMND) {\r\nha->cmd_tab[i].cmnd = ha->pccb->RequestBuffer;\r\nha->cmd_tab[i].service = ha->pccb->Service;\r\nha->pccb->CommandIndex = (u32)i+2;\r\nreturn (i+2);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void gdth_set_sema0(gdth_ha_str *ha)\r\n{\r\nTRACE(("gdth_set_sema0() hanum %d\n", ha->hanum));\r\nif (ha->type == GDT_EISA) {\r\noutb(1, ha->bmic + SEMA0REG);\r\n} else if (ha->type == GDT_ISA) {\r\nwriteb(1, &((gdt2_dpram_str __iomem *)ha->brd)->u.ic.Sema0);\r\n} else if (ha->type == GDT_PCI) {\r\nwriteb(1, &((gdt6_dpram_str __iomem *)ha->brd)->u.ic.Sema0);\r\n} else if (ha->type == GDT_PCINEW) {\r\noutb(1, PTR2USHORT(&ha->plx->sema0_reg));\r\n} else if (ha->type == GDT_PCIMPR) {\r\nwriteb(1, &((gdt6m_dpram_str __iomem *)ha->brd)->i960r.sema0_reg);\r\n}\r\n}\r\nstatic void gdth_copy_command(gdth_ha_str *ha)\r\n{\r\nregister gdth_cmd_str *cmd_ptr;\r\nregister gdt6m_dpram_str __iomem *dp6m_ptr;\r\nregister gdt6c_dpram_str __iomem *dp6c_ptr;\r\ngdt6_dpram_str __iomem *dp6_ptr;\r\ngdt2_dpram_str __iomem *dp2_ptr;\r\nu16 cp_count,dp_offset,cmd_no;\r\nTRACE(("gdth_copy_command() hanum %d\n", ha->hanum));\r\ncp_count = ha->cmd_len;\r\ndp_offset= ha->cmd_offs_dpmem;\r\ncmd_no = ha->cmd_cnt;\r\ncmd_ptr = ha->pccb;\r\n++ha->cmd_cnt;\r\nif (ha->type == GDT_EISA)\r\nreturn;\r\nif (cp_count & 3)\r\ncp_count += (4 - (cp_count & 3));\r\nha->cmd_offs_dpmem += cp_count;\r\nif (ha->type == GDT_ISA) {\r\ndp2_ptr = ha->brd;\r\nwritew(dp_offset + DPMEM_COMMAND_OFFSET,\r\n&dp2_ptr->u.ic.comm_queue[cmd_no].offset);\r\nwritew((u16)cmd_ptr->Service,\r\n&dp2_ptr->u.ic.comm_queue[cmd_no].serv_id);\r\nmemcpy_toio(&dp2_ptr->u.ic.gdt_dpr_cmd[dp_offset],cmd_ptr,cp_count);\r\n} else if (ha->type == GDT_PCI) {\r\ndp6_ptr = ha->brd;\r\nwritew(dp_offset + DPMEM_COMMAND_OFFSET,\r\n&dp6_ptr->u.ic.comm_queue[cmd_no].offset);\r\nwritew((u16)cmd_ptr->Service,\r\n&dp6_ptr->u.ic.comm_queue[cmd_no].serv_id);\r\nmemcpy_toio(&dp6_ptr->u.ic.gdt_dpr_cmd[dp_offset],cmd_ptr,cp_count);\r\n} else if (ha->type == GDT_PCINEW) {\r\ndp6c_ptr = ha->brd;\r\nwritew(dp_offset + DPMEM_COMMAND_OFFSET,\r\n&dp6c_ptr->u.ic.comm_queue[cmd_no].offset);\r\nwritew((u16)cmd_ptr->Service,\r\n&dp6c_ptr->u.ic.comm_queue[cmd_no].serv_id);\r\nmemcpy_toio(&dp6c_ptr->u.ic.gdt_dpr_cmd[dp_offset],cmd_ptr,cp_count);\r\n} else if (ha->type == GDT_PCIMPR) {\r\ndp6m_ptr = ha->brd;\r\nwritew(dp_offset + DPMEM_COMMAND_OFFSET,\r\n&dp6m_ptr->u.ic.comm_queue[cmd_no].offset);\r\nwritew((u16)cmd_ptr->Service,\r\n&dp6m_ptr->u.ic.comm_queue[cmd_no].serv_id);\r\nmemcpy_toio(&dp6m_ptr->u.ic.gdt_dpr_cmd[dp_offset],cmd_ptr,cp_count);\r\n}\r\n}\r\nstatic void gdth_release_event(gdth_ha_str *ha)\r\n{\r\nTRACE(("gdth_release_event() hanum %d\n", ha->hanum));\r\n#ifdef GDTH_STATISTICS\r\n{\r\nu32 i,j;\r\nfor (i=0,j=0; j<GDTH_MAXCMDS; ++j) {\r\nif (ha->cmd_tab[j].cmnd != UNUSED_CMND)\r\n++i;\r\n}\r\nif (max_index < i) {\r\nmax_index = i;\r\nTRACE3(("GDT: max_index = %d\n",(u16)i));\r\n}\r\n}\r\n#endif\r\nif (ha->pccb->OpCode == GDT_INIT)\r\nha->pccb->Service |= 0x80;\r\nif (ha->type == GDT_EISA) {\r\nif (ha->pccb->OpCode == GDT_INIT)\r\noutl(ha->ccb_phys, ha->bmic + MAILBOXREG);\r\noutb(ha->pccb->Service, ha->bmic + LDOORREG);\r\n} else if (ha->type == GDT_ISA) {\r\nwriteb(0, &((gdt2_dpram_str __iomem *)ha->brd)->io.event);\r\n} else if (ha->type == GDT_PCI) {\r\nwriteb(0, &((gdt6_dpram_str __iomem *)ha->brd)->io.event);\r\n} else if (ha->type == GDT_PCINEW) {\r\noutb(1, PTR2USHORT(&ha->plx->ldoor_reg));\r\n} else if (ha->type == GDT_PCIMPR) {\r\nwriteb(1, &((gdt6m_dpram_str __iomem *)ha->brd)->i960r.ldoor_reg);\r\n}\r\n}\r\nstatic int gdth_wait(gdth_ha_str *ha, int index, u32 time)\r\n{\r\nint answer_found = FALSE;\r\nint wait_index = 0;\r\nTRACE(("gdth_wait() hanum %d index %d time %d\n", ha->hanum, index, time));\r\nif (index == 0)\r\nreturn 1;\r\ndo {\r\n__gdth_interrupt(ha, true, &wait_index);\r\nif (wait_index == index) {\r\nanswer_found = TRUE;\r\nbreak;\r\n}\r\ngdth_delay(1);\r\n} while (--time);\r\nwhile (gdth_test_busy(ha))\r\ngdth_delay(0);\r\nreturn (answer_found);\r\n}\r\nstatic int gdth_internal_cmd(gdth_ha_str *ha, u8 service, u16 opcode,\r\nu32 p1, u64 p2, u64 p3)\r\n{\r\nregister gdth_cmd_str *cmd_ptr;\r\nint retries,index;\r\nTRACE2(("gdth_internal_cmd() service %d opcode %d\n",service,opcode));\r\ncmd_ptr = ha->pccb;\r\nmemset((char*)cmd_ptr,0,sizeof(gdth_cmd_str));\r\nfor (retries = INIT_RETRIES;;) {\r\ncmd_ptr->Service = service;\r\ncmd_ptr->RequestBuffer = INTERNAL_CMND;\r\nif (!(index=gdth_get_cmd_index(ha))) {\r\nTRACE(("GDT: No free command index found\n"));\r\nreturn 0;\r\n}\r\ngdth_set_sema0(ha);\r\ncmd_ptr->OpCode = opcode;\r\ncmd_ptr->BoardNode = LOCALBOARD;\r\nif (service == CACHESERVICE) {\r\nif (opcode == GDT_IOCTL) {\r\ncmd_ptr->u.ioctl.subfunc = p1;\r\ncmd_ptr->u.ioctl.channel = (u32)p2;\r\ncmd_ptr->u.ioctl.param_size = (u16)p3;\r\ncmd_ptr->u.ioctl.p_param = ha->scratch_phys;\r\n} else {\r\nif (ha->cache_feat & GDT_64BIT) {\r\ncmd_ptr->u.cache64.DeviceNo = (u16)p1;\r\ncmd_ptr->u.cache64.BlockNo = p2;\r\n} else {\r\ncmd_ptr->u.cache.DeviceNo = (u16)p1;\r\ncmd_ptr->u.cache.BlockNo = (u32)p2;\r\n}\r\n}\r\n} else if (service == SCSIRAWSERVICE) {\r\nif (ha->raw_feat & GDT_64BIT) {\r\ncmd_ptr->u.raw64.direction = p1;\r\ncmd_ptr->u.raw64.bus = (u8)p2;\r\ncmd_ptr->u.raw64.target = (u8)p3;\r\ncmd_ptr->u.raw64.lun = (u8)(p3 >> 8);\r\n} else {\r\ncmd_ptr->u.raw.direction = p1;\r\ncmd_ptr->u.raw.bus = (u8)p2;\r\ncmd_ptr->u.raw.target = (u8)p3;\r\ncmd_ptr->u.raw.lun = (u8)(p3 >> 8);\r\n}\r\n} else if (service == SCREENSERVICE) {\r\nif (opcode == GDT_REALTIME) {\r\n*(u32 *)&cmd_ptr->u.screen.su.data[0] = p1;\r\n*(u32 *)&cmd_ptr->u.screen.su.data[4] = (u32)p2;\r\n*(u32 *)&cmd_ptr->u.screen.su.data[8] = (u32)p3;\r\n}\r\n}\r\nha->cmd_len = sizeof(gdth_cmd_str);\r\nha->cmd_offs_dpmem = 0;\r\nha->cmd_cnt = 0;\r\ngdth_copy_command(ha);\r\ngdth_release_event(ha);\r\ngdth_delay(20);\r\nif (!gdth_wait(ha, index, INIT_TIMEOUT)) {\r\nprintk("GDT: Initialization error (timeout service %d)\n",service);\r\nreturn 0;\r\n}\r\nif (ha->status != S_BSY || --retries == 0)\r\nbreak;\r\ngdth_delay(1);\r\n}\r\nreturn (ha->status != S_OK ? 0:1);\r\n}\r\nstatic int gdth_search_drives(gdth_ha_str *ha)\r\n{\r\nu16 cdev_cnt, i;\r\nint ok;\r\nu32 bus_no, drv_cnt, drv_no, j;\r\ngdth_getch_str *chn;\r\ngdth_drlist_str *drl;\r\ngdth_iochan_str *ioc;\r\ngdth_raw_iochan_str *iocr;\r\ngdth_arcdl_str *alst;\r\ngdth_alist_str *alst2;\r\ngdth_oem_str_ioctl *oemstr;\r\n#ifdef INT_COAL\r\ngdth_perf_modes *pmod;\r\n#endif\r\n#ifdef GDTH_RTC\r\nu8 rtc[12];\r\nunsigned long flags;\r\n#endif\r\nTRACE(("gdth_search_drives() hanum %d\n", ha->hanum));\r\nok = 0;\r\nha->screen_feat = 0;\r\nif (!force_dma32) {\r\nok = gdth_internal_cmd(ha, SCREENSERVICE, GDT_X_INIT_SCR, 0, 0, 0);\r\nif (ok)\r\nha->screen_feat = GDT_64BIT;\r\n}\r\nif (force_dma32 || (!ok && ha->status == (u16)S_NOFUNC))\r\nok = gdth_internal_cmd(ha, SCREENSERVICE, GDT_INIT, 0, 0, 0);\r\nif (!ok) {\r\nprintk("GDT-HA %d: Initialization error screen service (code %d)\n",\r\nha->hanum, ha->status);\r\nreturn 0;\r\n}\r\nTRACE2(("gdth_search_drives(): SCREENSERVICE initialized\n"));\r\n#ifdef GDTH_RTC\r\nspin_lock_irqsave(&rtc_lock, flags);\r\nfor (j = 0; j < 1000000; ++j)\r\nif (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP)\r\nbreak;\r\nfor (j = 0; j < 1000000; ++j)\r\nif (!(CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP))\r\nbreak;\r\ndo {\r\nfor (j = 0; j < 12; ++j)\r\nrtc[j] = CMOS_READ(j);\r\n} while (rtc[0] != CMOS_READ(0));\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\nTRACE2(("gdth_search_drives(): RTC: %x/%x/%x\n",*(u32 *)&rtc[0],\r\n*(u32 *)&rtc[4], *(u32 *)&rtc[8]));\r\ngdth_internal_cmd(ha, SCREENSERVICE, GDT_REALTIME, *(u32 *)&rtc[0],\r\n*(u32 *)&rtc[4], *(u32 *)&rtc[8]);\r\n#endif\r\ngdth_internal_cmd(ha, CACHESERVICE, GDT_UNFREEZE_IO, 0, 0, 0);\r\nha->cache_feat = 0;\r\nif (!force_dma32) {\r\nok = gdth_internal_cmd(ha, CACHESERVICE, GDT_X_INIT_HOST, LINUX_OS,\r\n0, 0);\r\nif (ok)\r\nha->cache_feat = GDT_64BIT;\r\n}\r\nif (force_dma32 || (!ok && ha->status == (u16)S_NOFUNC))\r\nok = gdth_internal_cmd(ha, CACHESERVICE, GDT_INIT, LINUX_OS, 0, 0);\r\nif (!ok) {\r\nprintk("GDT-HA %d: Initialization error cache service (code %d)\n",\r\nha->hanum, ha->status);\r\nreturn 0;\r\n}\r\nTRACE2(("gdth_search_drives(): CACHESERVICE initialized\n"));\r\ncdev_cnt = (u16)ha->info;\r\nha->fw_vers = ha->service;\r\n#ifdef INT_COAL\r\nif (ha->type == GDT_PCIMPR) {\r\npmod = (gdth_perf_modes *)ha->pscratch;\r\npmod->version = 1;\r\npmod->st_mode = 1;\r\n*((u64 *)&pmod->st_buff_addr1) = ha->coal_stat_phys;\r\npmod->st_buff_indx1 = COALINDEX;\r\npmod->st_buff_addr2 = 0;\r\npmod->st_buff_u_addr2 = 0;\r\npmod->st_buff_indx2 = 0;\r\npmod->st_buff_size = sizeof(gdth_coal_status) * MAXOFFSETS;\r\npmod->cmd_mode = 0;\r\npmod->cmd_buff_addr1 = 0;\r\npmod->cmd_buff_u_addr1 = 0;\r\npmod->cmd_buff_indx1 = 0;\r\npmod->cmd_buff_addr2 = 0;\r\npmod->cmd_buff_u_addr2 = 0;\r\npmod->cmd_buff_indx2 = 0;\r\npmod->cmd_buff_size = 0;\r\npmod->reserved1 = 0;\r\npmod->reserved2 = 0;\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL, SET_PERF_MODES,\r\nINVALID_CHANNEL,sizeof(gdth_perf_modes))) {\r\nprintk("GDT-HA %d: Interrupt coalescing activated\n", ha->hanum);\r\n}\r\n}\r\n#endif\r\niocr = (gdth_raw_iochan_str *)ha->pscratch;\r\niocr->hdr.version = 0xffffffff;\r\niocr->hdr.list_entries = MAXBUS;\r\niocr->hdr.first_chan = 0;\r\niocr->hdr.last_chan = MAXBUS-1;\r\niocr->hdr.list_offset = GDTOFFSOF(gdth_raw_iochan_str, list[0]);\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL, IOCHAN_RAW_DESC,\r\nINVALID_CHANNEL,sizeof(gdth_raw_iochan_str))) {\r\nTRACE2(("IOCHAN_RAW_DESC supported!\n"));\r\nha->bus_cnt = iocr->hdr.chan_count;\r\nfor (bus_no = 0; bus_no < ha->bus_cnt; ++bus_no) {\r\nif (iocr->list[bus_no].proc_id < MAXID)\r\nha->bus_id[bus_no] = iocr->list[bus_no].proc_id;\r\nelse\r\nha->bus_id[bus_no] = 0xff;\r\n}\r\n} else {\r\nchn = (gdth_getch_str *)ha->pscratch;\r\nfor (bus_no = 0; bus_no < MAXBUS; ++bus_no) {\r\nchn->channel_no = bus_no;\r\nif (!gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL,\r\nSCSI_CHAN_CNT | L_CTRL_PATTERN,\r\nIO_CHANNEL | INVALID_CHANNEL,\r\nsizeof(gdth_getch_str))) {\r\nif (bus_no == 0) {\r\nprintk("GDT-HA %d: Error detecting channel count (0x%x)\n",\r\nha->hanum, ha->status);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nif (chn->siop_id < MAXID)\r\nha->bus_id[bus_no] = chn->siop_id;\r\nelse\r\nha->bus_id[bus_no] = 0xff;\r\n}\r\nha->bus_cnt = (u8)bus_no;\r\n}\r\nTRACE2(("gdth_search_drives() %d channels\n",ha->bus_cnt));\r\nif (!gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL, CACHE_INFO,\r\nINVALID_CHANNEL,sizeof(gdth_cinfo_str))) {\r\nprintk("GDT-HA %d: Initialization error cache service (code %d)\n",\r\nha->hanum, ha->status);\r\nreturn 0;\r\n}\r\nha->cpar = ((gdth_cinfo_str *)ha->pscratch)->cpar;\r\nTRACE2(("gdth_search_drives() cinfo: vs %x sta %d str %d dw %d b %d\n",\r\nha->cpar.version,ha->cpar.state,ha->cpar.strategy,\r\nha->cpar.write_back,ha->cpar.block_size));\r\nha->more_proc = FALSE;\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL, BOARD_INFO,\r\nINVALID_CHANNEL,sizeof(gdth_binfo_str))) {\r\nmemcpy(&ha->binfo, (gdth_binfo_str *)ha->pscratch,\r\nsizeof(gdth_binfo_str));\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL, BOARD_FEATURES,\r\nINVALID_CHANNEL,sizeof(gdth_bfeat_str))) {\r\nTRACE2(("BOARD_INFO/BOARD_FEATURES supported\n"));\r\nha->bfeat = *(gdth_bfeat_str *)ha->pscratch;\r\nha->more_proc = TRUE;\r\n}\r\n} else {\r\nTRACE2(("BOARD_INFO requires firmware >= 1.10/2.08\n"));\r\nstrcpy(ha->binfo.type_string, gdth_ctr_name(ha));\r\n}\r\nTRACE2(("Controller name: %s\n",ha->binfo.type_string));\r\nif (ha->more_proc) {\r\nioc = (gdth_iochan_str *)ha->pscratch;\r\nioc->hdr.version = 0xffffffff;\r\nioc->hdr.list_entries = MAXBUS;\r\nioc->hdr.first_chan = 0;\r\nioc->hdr.last_chan = MAXBUS-1;\r\nioc->hdr.list_offset = GDTOFFSOF(gdth_iochan_str, list[0]);\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL, IOCHAN_DESC,\r\nINVALID_CHANNEL,sizeof(gdth_iochan_str))) {\r\nfor (bus_no = 0; bus_no < ha->bus_cnt; ++bus_no) {\r\nha->raw[bus_no].address = ioc->list[bus_no].address;\r\nha->raw[bus_no].local_no = ioc->list[bus_no].local_no;\r\n}\r\n} else {\r\nfor (bus_no = 0; bus_no < ha->bus_cnt; ++bus_no) {\r\nha->raw[bus_no].address = IO_CHANNEL;\r\nha->raw[bus_no].local_no = bus_no;\r\n}\r\n}\r\nfor (bus_no = 0; bus_no < ha->bus_cnt; ++bus_no) {\r\nchn = (gdth_getch_str *)ha->pscratch;\r\nchn->channel_no = ha->raw[bus_no].local_no;\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL,\r\nSCSI_CHAN_CNT | L_CTRL_PATTERN,\r\nha->raw[bus_no].address | INVALID_CHANNEL,\r\nsizeof(gdth_getch_str))) {\r\nha->raw[bus_no].pdev_cnt = chn->drive_cnt;\r\nTRACE2(("Channel %d: %d phys. drives\n",\r\nbus_no,chn->drive_cnt));\r\n}\r\nif (ha->raw[bus_no].pdev_cnt > 0) {\r\ndrl = (gdth_drlist_str *)ha->pscratch;\r\ndrl->sc_no = ha->raw[bus_no].local_no;\r\ndrl->sc_cnt = ha->raw[bus_no].pdev_cnt;\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL,\r\nSCSI_DR_LIST | L_CTRL_PATTERN,\r\nha->raw[bus_no].address | INVALID_CHANNEL,\r\nsizeof(gdth_drlist_str))) {\r\nfor (j = 0; j < ha->raw[bus_no].pdev_cnt; ++j)\r\nha->raw[bus_no].id_list[j] = drl->sc_list[j];\r\n} else {\r\nha->raw[bus_no].pdev_cnt = 0;\r\n}\r\n}\r\n}\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL, CACHE_DRV_CNT,\r\nINVALID_CHANNEL,sizeof(u32))) {\r\ndrv_cnt = *(u32 *)ha->pscratch;\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL, CACHE_DRV_LIST,\r\nINVALID_CHANNEL,drv_cnt * sizeof(u32))) {\r\nfor (j = 0; j < drv_cnt; ++j) {\r\ndrv_no = ((u32 *)ha->pscratch)[j];\r\nif (drv_no < MAX_LDRIVES) {\r\nha->hdr[drv_no].is_logdrv = TRUE;\r\nTRACE2(("Drive %d is log. drive\n",drv_no));\r\n}\r\n}\r\n}\r\nalst = (gdth_arcdl_str *)ha->pscratch;\r\nalst->entries_avail = MAX_LDRIVES;\r\nalst->first_entry = 0;\r\nalst->list_offset = GDTOFFSOF(gdth_arcdl_str, list[0]);\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL,\r\nARRAY_DRV_LIST2 | LA_CTRL_PATTERN,\r\nINVALID_CHANNEL, sizeof(gdth_arcdl_str) +\r\n(alst->entries_avail-1) * sizeof(gdth_alist_str))) {\r\nfor (j = 0; j < alst->entries_init; ++j) {\r\nha->hdr[j].is_arraydrv = alst->list[j].is_arrayd;\r\nha->hdr[j].is_master = alst->list[j].is_master;\r\nha->hdr[j].is_parity = alst->list[j].is_parity;\r\nha->hdr[j].is_hotfix = alst->list[j].is_hotfix;\r\nha->hdr[j].master_no = alst->list[j].cd_handle;\r\n}\r\n} else if (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL,\r\nARRAY_DRV_LIST | LA_CTRL_PATTERN,\r\n0, 35 * sizeof(gdth_alist_str))) {\r\nfor (j = 0; j < 35; ++j) {\r\nalst2 = &((gdth_alist_str *)ha->pscratch)[j];\r\nha->hdr[j].is_arraydrv = alst2->is_arrayd;\r\nha->hdr[j].is_master = alst2->is_master;\r\nha->hdr[j].is_parity = alst2->is_parity;\r\nha->hdr[j].is_hotfix = alst2->is_hotfix;\r\nha->hdr[j].master_no = alst2->cd_handle;\r\n}\r\n}\r\n}\r\n}\r\nha->raw_feat = 0;\r\nif (!force_dma32) {\r\nok = gdth_internal_cmd(ha, SCSIRAWSERVICE, GDT_X_INIT_RAW, 0, 0, 0);\r\nif (ok)\r\nha->raw_feat = GDT_64BIT;\r\n}\r\nif (force_dma32 || (!ok && ha->status == (u16)S_NOFUNC))\r\nok = gdth_internal_cmd(ha, SCSIRAWSERVICE, GDT_INIT, 0, 0, 0);\r\nif (!ok) {\r\nprintk("GDT-HA %d: Initialization error raw service (code %d)\n",\r\nha->hanum, ha->status);\r\nreturn 0;\r\n}\r\nTRACE2(("gdth_search_drives(): RAWSERVICE initialized\n"));\r\nif (gdth_internal_cmd(ha, SCSIRAWSERVICE, GDT_SET_FEAT, SCATTER_GATHER,\r\n0, 0)) {\r\nTRACE2(("gdth_search_drives(): set features RAWSERVICE OK\n"));\r\nif (gdth_internal_cmd(ha, SCSIRAWSERVICE, GDT_GET_FEAT, 0, 0, 0)) {\r\nTRACE2(("gdth_search_dr(): get feat RAWSERVICE %d\n",\r\nha->info));\r\nha->raw_feat |= (u16)ha->info;\r\n}\r\n}\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_SET_FEAT, 0,\r\nSCATTER_GATHER,0)) {\r\nTRACE2(("gdth_search_drives(): set features CACHESERVICE OK\n"));\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_GET_FEAT, 0, 0, 0)) {\r\nTRACE2(("gdth_search_dr(): get feat CACHESERV. %d\n",\r\nha->info));\r\nha->cache_feat |= (u16)ha->info;\r\n}\r\n}\r\nif (reserve_mode != 0) {\r\ngdth_internal_cmd(ha, SCSIRAWSERVICE, GDT_RESERVE_ALL,\r\nreserve_mode == 1 ? 1 : 3, 0, 0);\r\nTRACE2(("gdth_search_drives(): RESERVE_ALL code %d\n",\r\nha->status));\r\n}\r\nfor (i = 0; i < MAX_RES_ARGS; i += 4) {\r\nif (reserve_list[i] == ha->hanum && reserve_list[i+1] < ha->bus_cnt &&\r\nreserve_list[i+2] < ha->tid_cnt && reserve_list[i+3] < MAXLUN) {\r\nTRACE2(("gdth_search_drives(): reserve ha %d bus %d id %d lun %d\n",\r\nreserve_list[i], reserve_list[i+1],\r\nreserve_list[i+2], reserve_list[i+3]));\r\nif (!gdth_internal_cmd(ha, SCSIRAWSERVICE, GDT_RESERVE, 0,\r\nreserve_list[i+1], reserve_list[i+2] |\r\n(reserve_list[i+3] << 8))) {\r\nprintk("GDT-HA %d: Error raw service (RESERVE, code %d)\n",\r\nha->hanum, ha->status);\r\n}\r\n}\r\n}\r\noemstr = (gdth_oem_str_ioctl *)ha->pscratch;\r\noemstr->params.ctl_version = 0x01;\r\noemstr->params.buffer_size = sizeof(oemstr->text);\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_IOCTL,\r\nCACHE_READ_OEM_STRING_RECORD,INVALID_CHANNEL,\r\nsizeof(gdth_oem_str_ioctl))) {\r\nTRACE2(("gdth_search_drives(): CACHE_READ_OEM_STRING_RECORD OK\n"));\r\nprintk("GDT-HA %d: Vendor: %s Name: %s\n",\r\nha->hanum, oemstr->text.oem_company_name, ha->binfo.type_string);\r\nstrlcpy(ha->oem_name,oemstr->text.scsi_host_drive_inquiry_vendor_id,\r\nsizeof(ha->oem_name));\r\n} else {\r\nTRACE2(("gdth_search_drives(): CACHE_READ_OEM_STRING_RECORD failed\n"));\r\nprintk("GDT-HA %d: Name: %s\n",\r\nha->hanum, ha->binfo.type_string);\r\nif (ha->oem_id == OEM_ID_INTEL)\r\nstrlcpy(ha->oem_name,"Intel ", sizeof(ha->oem_name));\r\nelse\r\nstrlcpy(ha->oem_name,"ICP ", sizeof(ha->oem_name));\r\n}\r\nfor (i = 0; i < cdev_cnt; ++i)\r\ngdth_analyse_hdrive(ha, i);\r\nTRACE(("gdth_search_drives() OK\n"));\r\nreturn 1;\r\n}\r\nstatic int gdth_analyse_hdrive(gdth_ha_str *ha, u16 hdrive)\r\n{\r\nu32 drv_cyls;\r\nint drv_hds, drv_secs;\r\nTRACE(("gdth_analyse_hdrive() hanum %d drive %d\n", ha->hanum, hdrive));\r\nif (hdrive >= MAX_HDRIVES)\r\nreturn 0;\r\nif (!gdth_internal_cmd(ha, CACHESERVICE, GDT_INFO, hdrive, 0, 0))\r\nreturn 0;\r\nha->hdr[hdrive].present = TRUE;\r\nha->hdr[hdrive].size = ha->info;\r\nha->hdr[hdrive].size &= ~SECS32;\r\nif (ha->info2 == 0) {\r\ngdth_eval_mapping(ha->hdr[hdrive].size,&drv_cyls,&drv_hds,&drv_secs);\r\n} else {\r\ndrv_hds = ha->info2 & 0xff;\r\ndrv_secs = (ha->info2 >> 8) & 0xff;\r\ndrv_cyls = (u32)ha->hdr[hdrive].size / drv_hds / drv_secs;\r\n}\r\nha->hdr[hdrive].heads = (u8)drv_hds;\r\nha->hdr[hdrive].secs = (u8)drv_secs;\r\nha->hdr[hdrive].size = drv_cyls * drv_hds * drv_secs;\r\nif (ha->cache_feat & GDT_64BIT) {\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_X_INFO, hdrive, 0, 0)\r\n&& ha->info2 != 0) {\r\nha->hdr[hdrive].size = ((u64)ha->info2 << 32) | ha->info;\r\n}\r\n}\r\nTRACE2(("gdth_search_dr() cdr. %d size %d hds %d scs %d\n",\r\nhdrive,ha->hdr[hdrive].size,drv_hds,drv_secs));\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_DEVTYPE, hdrive, 0, 0)) {\r\nTRACE2(("gdth_search_dr() cache drive %d devtype %d\n",\r\nhdrive,ha->info));\r\nha->hdr[hdrive].devtype = (u16)ha->info;\r\n}\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_CLUST_INFO, hdrive, 0, 0)) {\r\nTRACE2(("gdth_search_dr() cache drive %d cluster info %d\n",\r\nhdrive,ha->info));\r\nif (!shared_access)\r\nha->hdr[hdrive].cluster_type = (u8)ha->info;\r\n}\r\nif (gdth_internal_cmd(ha, CACHESERVICE, GDT_RW_ATTRIBS, hdrive, 0, 0)) {\r\nTRACE2(("gdth_search_dr() cache drive %d r/w attrib. %d\n",\r\nhdrive,ha->info));\r\nha->hdr[hdrive].rw_attribs = (u8)ha->info;\r\n}\r\nreturn 1;\r\n}\r\nstatic void gdth_putq(gdth_ha_str *ha, Scsi_Cmnd *scp, u8 priority)\r\n{\r\nstruct gdth_cmndinfo *cmndinfo = gdth_cmnd_priv(scp);\r\nregister Scsi_Cmnd *pscp;\r\nregister Scsi_Cmnd *nscp;\r\nunsigned long flags;\r\nTRACE(("gdth_putq() priority %d\n",priority));\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nif (!cmndinfo->internal_command)\r\ncmndinfo->priority = priority;\r\nif (ha->req_first==NULL) {\r\nha->req_first = scp;\r\nscp->SCp.ptr = NULL;\r\n} else {\r\npscp = ha->req_first;\r\nnscp = (Scsi_Cmnd *)pscp->SCp.ptr;\r\nwhile (nscp && gdth_cmnd_priv(nscp)->priority <= priority) {\r\npscp = nscp;\r\nnscp = (Scsi_Cmnd *)pscp->SCp.ptr;\r\n}\r\npscp->SCp.ptr = (char *)scp;\r\nscp->SCp.ptr = (char *)nscp;\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n#ifdef GDTH_STATISTICS\r\nflags = 0;\r\nfor (nscp=ha->req_first; nscp; nscp=(Scsi_Cmnd*)nscp->SCp.ptr)\r\n++flags;\r\nif (max_rq < flags) {\r\nmax_rq = flags;\r\nTRACE3(("GDT: max_rq = %d\n",(u16)max_rq));\r\n}\r\n#endif\r\n}\r\nstatic void gdth_next(gdth_ha_str *ha)\r\n{\r\nregister Scsi_Cmnd *pscp;\r\nregister Scsi_Cmnd *nscp;\r\nu8 b, t, l, firsttime;\r\nu8 this_cmd, next_cmd;\r\nunsigned long flags = 0;\r\nint cmd_index;\r\nTRACE(("gdth_next() hanum %d\n", ha->hanum));\r\nif (!gdth_polling)\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->cmd_cnt = ha->cmd_offs_dpmem = 0;\r\nthis_cmd = firsttime = TRUE;\r\nnext_cmd = gdth_polling ? FALSE:TRUE;\r\ncmd_index = 0;\r\nfor (nscp = pscp = ha->req_first; nscp; nscp = (Scsi_Cmnd *)nscp->SCp.ptr) {\r\nstruct gdth_cmndinfo *nscp_cmndinfo = gdth_cmnd_priv(nscp);\r\nif (nscp != pscp && nscp != (Scsi_Cmnd *)pscp->SCp.ptr)\r\npscp = (Scsi_Cmnd *)pscp->SCp.ptr;\r\nif (!nscp_cmndinfo->internal_command) {\r\nb = nscp->device->channel;\r\nt = nscp->device->id;\r\nl = nscp->device->lun;\r\nif (nscp_cmndinfo->priority >= DEFAULT_PRI) {\r\nif ((b != ha->virt_bus && ha->raw[BUS_L2P(ha,b)].lock) ||\r\n(b == ha->virt_bus && t < MAX_HDRIVES && ha->hdr[t].lock))\r\ncontinue;\r\n}\r\n} else\r\nb = t = l = 0;\r\nif (firsttime) {\r\nif (gdth_test_busy(ha)) {\r\nTRACE(("gdth_next() controller %d busy !\n", ha->hanum));\r\nif (!gdth_polling) {\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn;\r\n}\r\nwhile (gdth_test_busy(ha))\r\ngdth_delay(1);\r\n}\r\nfirsttime = FALSE;\r\n}\r\nif (!nscp_cmndinfo->internal_command) {\r\nif (nscp_cmndinfo->phase == -1) {\r\nnscp_cmndinfo->phase = CACHESERVICE;\r\nif (nscp->cmnd[0] == TEST_UNIT_READY) {\r\nTRACE2(("TEST_UNIT_READY Bus %d Id %d LUN %d\n",\r\nb, t, l));\r\nif ((ha->scan_mode & 0x0f) == 0) {\r\nif (b == 0 && t == 0 && l == 0) {\r\nha->scan_mode |= 1;\r\nTRACE2(("Scan mode: 0x%x\n", ha->scan_mode));\r\n}\r\n} else if ((ha->scan_mode & 0x0f) == 1) {\r\nif (b == 0 && ((t == 0 && l == 1) ||\r\n(t == 1 && l == 0))) {\r\nnscp_cmndinfo->OpCode = GDT_SCAN_START;\r\nnscp_cmndinfo->phase = ((ha->scan_mode & 0x10 ? 1:0) << 8)\r\n| SCSIRAWSERVICE;\r\nha->scan_mode = 0x12;\r\nTRACE2(("Scan mode: 0x%x (SCAN_START)\n",\r\nha->scan_mode));\r\n} else {\r\nha->scan_mode &= 0x10;\r\nTRACE2(("Scan mode: 0x%x\n", ha->scan_mode));\r\n}\r\n} else if (ha->scan_mode == 0x12) {\r\nif (b == ha->bus_cnt && t == ha->tid_cnt-1) {\r\nnscp_cmndinfo->phase = SCSIRAWSERVICE;\r\nnscp_cmndinfo->OpCode = GDT_SCAN_END;\r\nha->scan_mode &= 0x10;\r\nTRACE2(("Scan mode: 0x%x (SCAN_END)\n",\r\nha->scan_mode));\r\n}\r\n}\r\n}\r\nif (b == ha->virt_bus && nscp->cmnd[0] != INQUIRY &&\r\nnscp->cmnd[0] != READ_CAPACITY && nscp->cmnd[0] != MODE_SENSE &&\r\n(ha->hdr[t].cluster_type & CLUSTER_DRIVE)) {\r\nnscp_cmndinfo->OpCode = GDT_CLUST_INFO;\r\n}\r\n}\r\n}\r\nif (nscp_cmndinfo->OpCode != -1) {\r\nif ((nscp_cmndinfo->phase & 0xff) == CACHESERVICE) {\r\nif (!(cmd_index=gdth_fill_cache_cmd(ha, nscp, t)))\r\nthis_cmd = FALSE;\r\nnext_cmd = FALSE;\r\n} else if ((nscp_cmndinfo->phase & 0xff) == SCSIRAWSERVICE) {\r\nif (!(cmd_index=gdth_fill_raw_cmd(ha, nscp, BUS_L2P(ha, b))))\r\nthis_cmd = FALSE;\r\nnext_cmd = FALSE;\r\n} else {\r\nmemset((char*)nscp->sense_buffer,0,16);\r\nnscp->sense_buffer[0] = 0x70;\r\nnscp->sense_buffer[2] = NOT_READY;\r\nnscp->result = (DID_OK << 16) | (CHECK_CONDITION << 1);\r\nif (!nscp_cmndinfo->wait_for_completion)\r\nnscp_cmndinfo->wait_for_completion++;\r\nelse\r\ngdth_scsi_done(nscp);\r\n}\r\n} else if (gdth_cmnd_priv(nscp)->internal_command) {\r\nif (!(cmd_index=gdth_special_cmd(ha, nscp)))\r\nthis_cmd = FALSE;\r\nnext_cmd = FALSE;\r\n} else if (b != ha->virt_bus) {\r\nif (ha->raw[BUS_L2P(ha,b)].io_cnt[t] >= GDTH_MAX_RAW ||\r\n!(cmd_index=gdth_fill_raw_cmd(ha, nscp, BUS_L2P(ha, b))))\r\nthis_cmd = FALSE;\r\nelse\r\nha->raw[BUS_L2P(ha,b)].io_cnt[t]++;\r\n} else if (t >= MAX_HDRIVES || !ha->hdr[t].present || l != 0) {\r\nTRACE2(("Command 0x%x to bus %d id %d lun %d -> IGNORE\n",\r\nnscp->cmnd[0], b, t, l));\r\nnscp->result = DID_BAD_TARGET << 16;\r\nif (!nscp_cmndinfo->wait_for_completion)\r\nnscp_cmndinfo->wait_for_completion++;\r\nelse\r\ngdth_scsi_done(nscp);\r\n} else {\r\nswitch (nscp->cmnd[0]) {\r\ncase TEST_UNIT_READY:\r\ncase INQUIRY:\r\ncase REQUEST_SENSE:\r\ncase READ_CAPACITY:\r\ncase VERIFY:\r\ncase START_STOP:\r\ncase MODE_SENSE:\r\ncase SERVICE_ACTION_IN_16:\r\nTRACE(("cache cmd %x/%x/%x/%x/%x/%x\n",nscp->cmnd[0],\r\nnscp->cmnd[1],nscp->cmnd[2],nscp->cmnd[3],\r\nnscp->cmnd[4],nscp->cmnd[5]));\r\nif (ha->hdr[t].media_changed && nscp->cmnd[0] != INQUIRY) {\r\nTRACE2(("cmd 0x%x target %d: UNIT_ATTENTION\n",\r\nnscp->cmnd[0], t));\r\nha->hdr[t].media_changed = FALSE;\r\nmemset((char*)nscp->sense_buffer,0,16);\r\nnscp->sense_buffer[0] = 0x70;\r\nnscp->sense_buffer[2] = UNIT_ATTENTION;\r\nnscp->result = (DID_OK << 16) | (CHECK_CONDITION << 1);\r\nif (!nscp_cmndinfo->wait_for_completion)\r\nnscp_cmndinfo->wait_for_completion++;\r\nelse\r\ngdth_scsi_done(nscp);\r\n} else if (gdth_internal_cache_cmd(ha, nscp))\r\ngdth_scsi_done(nscp);\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\nTRACE(("cache cmd %x/%x/%x/%x/%x/%x\n",nscp->cmnd[0],\r\nnscp->cmnd[1],nscp->cmnd[2],nscp->cmnd[3],\r\nnscp->cmnd[4],nscp->cmnd[5]));\r\nif ( (nscp->cmnd[4]&1) && !(ha->hdr[t].devtype&1) ) {\r\nTRACE(("Prevent r. nonremov. drive->do nothing\n"));\r\nnscp->result = DID_OK << 16;\r\nnscp->sense_buffer[0] = 0;\r\nif (!nscp_cmndinfo->wait_for_completion)\r\nnscp_cmndinfo->wait_for_completion++;\r\nelse\r\ngdth_scsi_done(nscp);\r\n} else {\r\nnscp->cmnd[3] = (ha->hdr[t].devtype&1) ? 1:0;\r\nTRACE(("Prevent/allow r. %d rem. drive %d\n",\r\nnscp->cmnd[4],nscp->cmnd[3]));\r\nif (!(cmd_index=gdth_fill_cache_cmd(ha, nscp, t)))\r\nthis_cmd = FALSE;\r\n}\r\nbreak;\r\ncase RESERVE:\r\ncase RELEASE:\r\nTRACE2(("cache cmd %s\n",nscp->cmnd[0] == RESERVE ?\r\n"RESERVE" : "RELEASE"));\r\nif (!(cmd_index=gdth_fill_cache_cmd(ha, nscp, t)))\r\nthis_cmd = FALSE;\r\nbreak;\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase READ_16:\r\ncase WRITE_16:\r\nif (ha->hdr[t].media_changed) {\r\nTRACE2(("cmd 0x%x target %d: UNIT_ATTENTION\n",\r\nnscp->cmnd[0], t));\r\nha->hdr[t].media_changed = FALSE;\r\nmemset((char*)nscp->sense_buffer,0,16);\r\nnscp->sense_buffer[0] = 0x70;\r\nnscp->sense_buffer[2] = UNIT_ATTENTION;\r\nnscp->result = (DID_OK << 16) | (CHECK_CONDITION << 1);\r\nif (!nscp_cmndinfo->wait_for_completion)\r\nnscp_cmndinfo->wait_for_completion++;\r\nelse\r\ngdth_scsi_done(nscp);\r\n} else if (!(cmd_index=gdth_fill_cache_cmd(ha, nscp, t)))\r\nthis_cmd = FALSE;\r\nbreak;\r\ndefault:\r\nTRACE2(("cache cmd %x/%x/%x/%x/%x/%x unknown\n",nscp->cmnd[0],\r\nnscp->cmnd[1],nscp->cmnd[2],nscp->cmnd[3],\r\nnscp->cmnd[4],nscp->cmnd[5]));\r\nprintk("GDT-HA %d: Unknown SCSI command 0x%x to cache service !\n",\r\nha->hanum, nscp->cmnd[0]);\r\nnscp->result = DID_ABORT << 16;\r\nif (!nscp_cmndinfo->wait_for_completion)\r\nnscp_cmndinfo->wait_for_completion++;\r\nelse\r\ngdth_scsi_done(nscp);\r\nbreak;\r\n}\r\n}\r\nif (!this_cmd)\r\nbreak;\r\nif (nscp == ha->req_first)\r\nha->req_first = pscp = (Scsi_Cmnd *)nscp->SCp.ptr;\r\nelse\r\npscp->SCp.ptr = nscp->SCp.ptr;\r\nif (!next_cmd)\r\nbreak;\r\n}\r\nif (ha->cmd_cnt > 0) {\r\ngdth_release_event(ha);\r\n}\r\nif (!gdth_polling)\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nif (gdth_polling && ha->cmd_cnt > 0) {\r\nif (!gdth_wait(ha, cmd_index, POLL_TIMEOUT))\r\nprintk("GDT-HA %d: Command %d timed out !\n",\r\nha->hanum, cmd_index);\r\n}\r\n}\r\nstatic void gdth_copy_internal_data(gdth_ha_str *ha, Scsi_Cmnd *scp,\r\nchar *buffer, u16 count)\r\n{\r\nu16 cpcount,i, max_sg = scsi_sg_count(scp);\r\nu16 cpsum,cpnow;\r\nstruct scatterlist *sl;\r\nchar *address;\r\ncpcount = min_t(u16, count, scsi_bufflen(scp));\r\nif (cpcount) {\r\ncpsum=0;\r\nscsi_for_each_sg(scp, sl, max_sg, i) {\r\nunsigned long flags;\r\ncpnow = (u16)sl->length;\r\nTRACE(("copy_internal() now %d sum %d count %d %d\n",\r\ncpnow, cpsum, cpcount, scsi_bufflen(scp)));\r\nif (cpsum+cpnow > cpcount)\r\ncpnow = cpcount - cpsum;\r\ncpsum += cpnow;\r\nif (!sg_page(sl)) {\r\nprintk("GDT-HA %d: invalid sc/gt element in gdth_copy_internal_data()\n",\r\nha->hanum);\r\nreturn;\r\n}\r\nlocal_irq_save(flags);\r\naddress = kmap_atomic(sg_page(sl)) + sl->offset;\r\nmemcpy(address, buffer, cpnow);\r\nflush_dcache_page(sg_page(sl));\r\nkunmap_atomic(address);\r\nlocal_irq_restore(flags);\r\nif (cpsum == cpcount)\r\nbreak;\r\nbuffer += cpnow;\r\n}\r\n} else if (count) {\r\nprintk("GDT-HA %d: SCSI command with no buffers but data transfer expected!\n",\r\nha->hanum);\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic int gdth_internal_cache_cmd(gdth_ha_str *ha, Scsi_Cmnd *scp)\r\n{\r\nu8 t;\r\ngdth_inq_data inq;\r\ngdth_rdcap_data rdc;\r\ngdth_sense_data sd;\r\ngdth_modep_data mpd;\r\nstruct gdth_cmndinfo *cmndinfo = gdth_cmnd_priv(scp);\r\nt = scp->device->id;\r\nTRACE(("gdth_internal_cache_cmd() cmd 0x%x hdrive %d\n",\r\nscp->cmnd[0],t));\r\nscp->result = DID_OK << 16;\r\nscp->sense_buffer[0] = 0;\r\nswitch (scp->cmnd[0]) {\r\ncase TEST_UNIT_READY:\r\ncase VERIFY:\r\ncase START_STOP:\r\nTRACE2(("Test/Verify/Start hdrive %d\n",t));\r\nbreak;\r\ncase INQUIRY:\r\nTRACE2(("Inquiry hdrive %d devtype %d\n",\r\nt,ha->hdr[t].devtype));\r\ninq.type_qual = (ha->hdr[t].devtype&4) ? TYPE_ROM:TYPE_DISK;\r\ninq.modif_rmb = 0x00;\r\nif ((ha->hdr[t].devtype & 1) ||\r\n(ha->hdr[t].cluster_type & CLUSTER_DRIVE))\r\ninq.modif_rmb = 0x80;\r\ninq.version = 2;\r\ninq.resp_aenc = 2;\r\ninq.add_length= 32;\r\nstrcpy(inq.vendor,ha->oem_name);\r\nsprintf(inq.product,"Host Drive #%02d",t);\r\nstrcpy(inq.revision," ");\r\ngdth_copy_internal_data(ha, scp, (char*)&inq, sizeof(gdth_inq_data));\r\nbreak;\r\ncase REQUEST_SENSE:\r\nTRACE2(("Request sense hdrive %d\n",t));\r\nsd.errorcode = 0x70;\r\nsd.segno = 0x00;\r\nsd.key = NO_SENSE;\r\nsd.info = 0;\r\nsd.add_length= 0;\r\ngdth_copy_internal_data(ha, scp, (char*)&sd, sizeof(gdth_sense_data));\r\nbreak;\r\ncase MODE_SENSE:\r\nTRACE2(("Mode sense hdrive %d\n",t));\r\nmemset((char*)&mpd,0,sizeof(gdth_modep_data));\r\nmpd.hd.data_length = sizeof(gdth_modep_data);\r\nmpd.hd.dev_par = (ha->hdr[t].devtype&2) ? 0x80:0;\r\nmpd.hd.bd_length = sizeof(mpd.bd);\r\nmpd.bd.block_length[0] = (SECTOR_SIZE & 0x00ff0000) >> 16;\r\nmpd.bd.block_length[1] = (SECTOR_SIZE & 0x0000ff00) >> 8;\r\nmpd.bd.block_length[2] = (SECTOR_SIZE & 0x000000ff);\r\ngdth_copy_internal_data(ha, scp, (char*)&mpd, sizeof(gdth_modep_data));\r\nbreak;\r\ncase READ_CAPACITY:\r\nTRACE2(("Read capacity hdrive %d\n",t));\r\nif (ha->hdr[t].size > (u64)0xffffffff)\r\nrdc.last_block_no = 0xffffffff;\r\nelse\r\nrdc.last_block_no = cpu_to_be32(ha->hdr[t].size-1);\r\nrdc.block_length = cpu_to_be32(SECTOR_SIZE);\r\ngdth_copy_internal_data(ha, scp, (char*)&rdc, sizeof(gdth_rdcap_data));\r\nbreak;\r\ncase SERVICE_ACTION_IN_16:\r\nif ((scp->cmnd[1] & 0x1f) == SAI_READ_CAPACITY_16 &&\r\n(ha->cache_feat & GDT_64BIT)) {\r\ngdth_rdcap16_data rdc16;\r\nTRACE2(("Read capacity (16) hdrive %d\n",t));\r\nrdc16.last_block_no = cpu_to_be64(ha->hdr[t].size-1);\r\nrdc16.block_length = cpu_to_be32(SECTOR_SIZE);\r\ngdth_copy_internal_data(ha, scp, (char*)&rdc16,\r\nsizeof(gdth_rdcap16_data));\r\n} else {\r\nscp->result = DID_ABORT << 16;\r\n}\r\nbreak;\r\ndefault:\r\nTRACE2(("Internal cache cmd 0x%x unknown\n",scp->cmnd[0]));\r\nbreak;\r\n}\r\nif (!cmndinfo->wait_for_completion)\r\ncmndinfo->wait_for_completion++;\r\nelse\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int gdth_fill_cache_cmd(gdth_ha_str *ha, Scsi_Cmnd *scp, u16 hdrive)\r\n{\r\nregister gdth_cmd_str *cmdp;\r\nstruct gdth_cmndinfo *cmndinfo = gdth_cmnd_priv(scp);\r\nu32 cnt, blockcnt;\r\nu64 no, blockno;\r\nint i, cmd_index, read_write, sgcnt, mode64;\r\ncmdp = ha->pccb;\r\nTRACE(("gdth_fill_cache_cmd() cmd 0x%x cmdsize %d hdrive %d\n",\r\nscp->cmnd[0],scp->cmd_len,hdrive));\r\nif (ha->type==GDT_EISA && ha->cmd_cnt>0)\r\nreturn 0;\r\nmode64 = (ha->cache_feat & GDT_64BIT) ? TRUE : FALSE;\r\ncmdp->Service = CACHESERVICE;\r\ncmdp->RequestBuffer = scp;\r\nif (!(cmd_index=gdth_get_cmd_index(ha))) {\r\nTRACE(("GDT: No free command index found\n"));\r\nreturn 0;\r\n}\r\nif (ha->cmd_cnt == 0)\r\ngdth_set_sema0(ha);\r\nread_write = 0;\r\nif (cmndinfo->OpCode != -1)\r\ncmdp->OpCode = cmndinfo->OpCode;\r\nelse if (scp->cmnd[0] == RESERVE)\r\ncmdp->OpCode = GDT_RESERVE_DRV;\r\nelse if (scp->cmnd[0] == RELEASE)\r\ncmdp->OpCode = GDT_RELEASE_DRV;\r\nelse if (scp->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\r\nif (scp->cmnd[4] & 1)\r\ncmdp->OpCode = GDT_MOUNT;\r\nelse if (scp->cmnd[3] & 1)\r\ncmdp->OpCode = GDT_UNMOUNT;\r\nelse\r\ncmdp->OpCode = GDT_FLUSH;\r\n} else if (scp->cmnd[0] == WRITE_6 || scp->cmnd[0] == WRITE_10 ||\r\nscp->cmnd[0] == WRITE_12 || scp->cmnd[0] == WRITE_16\r\n) {\r\nread_write = 1;\r\nif (gdth_write_through || ((ha->hdr[hdrive].rw_attribs & 1) &&\r\n(ha->cache_feat & GDT_WR_THROUGH)))\r\ncmdp->OpCode = GDT_WRITE_THR;\r\nelse\r\ncmdp->OpCode = GDT_WRITE;\r\n} else {\r\nread_write = 2;\r\ncmdp->OpCode = GDT_READ;\r\n}\r\ncmdp->BoardNode = LOCALBOARD;\r\nif (mode64) {\r\ncmdp->u.cache64.DeviceNo = hdrive;\r\ncmdp->u.cache64.BlockNo = 1;\r\ncmdp->u.cache64.sg_canz = 0;\r\n} else {\r\ncmdp->u.cache.DeviceNo = hdrive;\r\ncmdp->u.cache.BlockNo = 1;\r\ncmdp->u.cache.sg_canz = 0;\r\n}\r\nif (read_write) {\r\nif (scp->cmd_len == 16) {\r\nmemcpy(&no, &scp->cmnd[2], sizeof(u64));\r\nblockno = be64_to_cpu(no);\r\nmemcpy(&cnt, &scp->cmnd[10], sizeof(u32));\r\nblockcnt = be32_to_cpu(cnt);\r\n} else if (scp->cmd_len == 10) {\r\nmemcpy(&no, &scp->cmnd[2], sizeof(u32));\r\nblockno = be32_to_cpu(no);\r\nmemcpy(&cnt, &scp->cmnd[7], sizeof(u16));\r\nblockcnt = be16_to_cpu(cnt);\r\n} else {\r\nmemcpy(&no, &scp->cmnd[0], sizeof(u32));\r\nblockno = be32_to_cpu(no) & 0x001fffffUL;\r\nblockcnt= scp->cmnd[4]==0 ? 0x100 : scp->cmnd[4];\r\n}\r\nif (mode64) {\r\ncmdp->u.cache64.BlockNo = blockno;\r\ncmdp->u.cache64.BlockCnt = blockcnt;\r\n} else {\r\ncmdp->u.cache.BlockNo = (u32)blockno;\r\ncmdp->u.cache.BlockCnt = blockcnt;\r\n}\r\nif (scsi_bufflen(scp)) {\r\ncmndinfo->dma_dir = (read_write == 1 ?\r\nPCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);\r\nsgcnt = pci_map_sg(ha->pdev, scsi_sglist(scp), scsi_sg_count(scp),\r\ncmndinfo->dma_dir);\r\nif (mode64) {\r\nstruct scatterlist *sl;\r\ncmdp->u.cache64.DestAddr= (u64)-1;\r\ncmdp->u.cache64.sg_canz = sgcnt;\r\nscsi_for_each_sg(scp, sl, sgcnt, i) {\r\ncmdp->u.cache64.sg_lst[i].sg_ptr = sg_dma_address(sl);\r\n#ifdef GDTH_DMA_STATISTICS\r\nif (cmdp->u.cache64.sg_lst[i].sg_ptr > (u64)0xffffffff)\r\nha->dma64_cnt++;\r\nelse\r\nha->dma32_cnt++;\r\n#endif\r\ncmdp->u.cache64.sg_lst[i].sg_len = sg_dma_len(sl);\r\n}\r\n} else {\r\nstruct scatterlist *sl;\r\ncmdp->u.cache.DestAddr= 0xffffffff;\r\ncmdp->u.cache.sg_canz = sgcnt;\r\nscsi_for_each_sg(scp, sl, sgcnt, i) {\r\ncmdp->u.cache.sg_lst[i].sg_ptr = sg_dma_address(sl);\r\n#ifdef GDTH_DMA_STATISTICS\r\nha->dma32_cnt++;\r\n#endif\r\ncmdp->u.cache.sg_lst[i].sg_len = sg_dma_len(sl);\r\n}\r\n}\r\n#ifdef GDTH_STATISTICS\r\nif (max_sg < (u32)sgcnt) {\r\nmax_sg = (u32)sgcnt;\r\nTRACE3(("GDT: max_sg = %d\n",max_sg));\r\n}\r\n#endif\r\n}\r\n}\r\nif (mode64) {\r\nTRACE(("cache cmd: addr. %x sganz %x sgptr0 %x sglen0 %x\n",\r\ncmdp->u.cache64.DestAddr,cmdp->u.cache64.sg_canz,\r\ncmdp->u.cache64.sg_lst[0].sg_ptr,\r\ncmdp->u.cache64.sg_lst[0].sg_len));\r\nTRACE(("cache cmd: cmd %d blockno. %d, blockcnt %d\n",\r\ncmdp->OpCode,cmdp->u.cache64.BlockNo,cmdp->u.cache64.BlockCnt));\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.cache64.sg_lst) +\r\n(u16)cmdp->u.cache64.sg_canz * sizeof(gdth_sg64_str);\r\n} else {\r\nTRACE(("cache cmd: addr. %x sganz %x sgptr0 %x sglen0 %x\n",\r\ncmdp->u.cache.DestAddr,cmdp->u.cache.sg_canz,\r\ncmdp->u.cache.sg_lst[0].sg_ptr,\r\ncmdp->u.cache.sg_lst[0].sg_len));\r\nTRACE(("cache cmd: cmd %d blockno. %d, blockcnt %d\n",\r\ncmdp->OpCode,cmdp->u.cache.BlockNo,cmdp->u.cache.BlockCnt));\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.cache.sg_lst) +\r\n(u16)cmdp->u.cache.sg_canz * sizeof(gdth_sg_str);\r\n}\r\nif (ha->cmd_len & 3)\r\nha->cmd_len += (4 - (ha->cmd_len & 3));\r\nif (ha->cmd_cnt > 0) {\r\nif ((ha->cmd_offs_dpmem + ha->cmd_len + DPMEM_COMMAND_OFFSET) >\r\nha->ic_all_size) {\r\nTRACE2(("gdth_fill_cache() DPMEM overflow\n"));\r\nha->cmd_tab[cmd_index-2].cmnd = UNUSED_CMND;\r\nreturn 0;\r\n}\r\n}\r\ngdth_copy_command(ha);\r\nreturn cmd_index;\r\n}\r\nstatic int gdth_fill_raw_cmd(gdth_ha_str *ha, Scsi_Cmnd *scp, u8 b)\r\n{\r\nregister gdth_cmd_str *cmdp;\r\nu16 i;\r\ndma_addr_t sense_paddr;\r\nint cmd_index, sgcnt, mode64;\r\nu8 t,l;\r\nstruct page *page;\r\nunsigned long offset;\r\nstruct gdth_cmndinfo *cmndinfo;\r\nt = scp->device->id;\r\nl = scp->device->lun;\r\ncmdp = ha->pccb;\r\nTRACE(("gdth_fill_raw_cmd() cmd 0x%x bus %d ID %d LUN %d\n",\r\nscp->cmnd[0],b,t,l));\r\nif (ha->type==GDT_EISA && ha->cmd_cnt>0)\r\nreturn 0;\r\nmode64 = (ha->raw_feat & GDT_64BIT) ? TRUE : FALSE;\r\ncmdp->Service = SCSIRAWSERVICE;\r\ncmdp->RequestBuffer = scp;\r\nif (!(cmd_index=gdth_get_cmd_index(ha))) {\r\nTRACE(("GDT: No free command index found\n"));\r\nreturn 0;\r\n}\r\nif (ha->cmd_cnt == 0)\r\ngdth_set_sema0(ha);\r\ncmndinfo = gdth_cmnd_priv(scp);\r\nif (cmndinfo->OpCode != -1) {\r\ncmdp->OpCode = cmndinfo->OpCode;\r\ncmdp->BoardNode = LOCALBOARD;\r\nif (mode64) {\r\ncmdp->u.raw64.direction = (cmndinfo->phase >> 8);\r\nTRACE2(("special raw cmd 0x%x param 0x%x\n",\r\ncmdp->OpCode, cmdp->u.raw64.direction));\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.raw64.sg_lst);\r\n} else {\r\ncmdp->u.raw.direction = (cmndinfo->phase >> 8);\r\nTRACE2(("special raw cmd 0x%x param 0x%x\n",\r\ncmdp->OpCode, cmdp->u.raw.direction));\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.raw.sg_lst);\r\n}\r\n} else {\r\npage = virt_to_page(scp->sense_buffer);\r\noffset = (unsigned long)scp->sense_buffer & ~PAGE_MASK;\r\nsense_paddr = pci_map_page(ha->pdev,page,offset,\r\n16,PCI_DMA_FROMDEVICE);\r\ncmndinfo->sense_paddr = sense_paddr;\r\ncmdp->OpCode = GDT_WRITE;\r\ncmdp->BoardNode = LOCALBOARD;\r\nif (mode64) {\r\ncmdp->u.raw64.reserved = 0;\r\ncmdp->u.raw64.mdisc_time = 0;\r\ncmdp->u.raw64.mcon_time = 0;\r\ncmdp->u.raw64.clen = scp->cmd_len;\r\ncmdp->u.raw64.target = t;\r\ncmdp->u.raw64.lun = l;\r\ncmdp->u.raw64.bus = b;\r\ncmdp->u.raw64.priority = 0;\r\ncmdp->u.raw64.sdlen = scsi_bufflen(scp);\r\ncmdp->u.raw64.sense_len = 16;\r\ncmdp->u.raw64.sense_data = sense_paddr;\r\ncmdp->u.raw64.direction =\r\ngdth_direction_tab[scp->cmnd[0]]==DOU ? GDTH_DATA_OUT:GDTH_DATA_IN;\r\nmemcpy(cmdp->u.raw64.cmd,scp->cmnd,16);\r\ncmdp->u.raw64.sg_ranz = 0;\r\n} else {\r\ncmdp->u.raw.reserved = 0;\r\ncmdp->u.raw.mdisc_time = 0;\r\ncmdp->u.raw.mcon_time = 0;\r\ncmdp->u.raw.clen = scp->cmd_len;\r\ncmdp->u.raw.target = t;\r\ncmdp->u.raw.lun = l;\r\ncmdp->u.raw.bus = b;\r\ncmdp->u.raw.priority = 0;\r\ncmdp->u.raw.link_p = 0;\r\ncmdp->u.raw.sdlen = scsi_bufflen(scp);\r\ncmdp->u.raw.sense_len = 16;\r\ncmdp->u.raw.sense_data = sense_paddr;\r\ncmdp->u.raw.direction =\r\ngdth_direction_tab[scp->cmnd[0]]==DOU ? GDTH_DATA_OUT:GDTH_DATA_IN;\r\nmemcpy(cmdp->u.raw.cmd,scp->cmnd,12);\r\ncmdp->u.raw.sg_ranz = 0;\r\n}\r\nif (scsi_bufflen(scp)) {\r\ncmndinfo->dma_dir = PCI_DMA_BIDIRECTIONAL;\r\nsgcnt = pci_map_sg(ha->pdev, scsi_sglist(scp), scsi_sg_count(scp),\r\ncmndinfo->dma_dir);\r\nif (mode64) {\r\nstruct scatterlist *sl;\r\ncmdp->u.raw64.sdata = (u64)-1;\r\ncmdp->u.raw64.sg_ranz = sgcnt;\r\nscsi_for_each_sg(scp, sl, sgcnt, i) {\r\ncmdp->u.raw64.sg_lst[i].sg_ptr = sg_dma_address(sl);\r\n#ifdef GDTH_DMA_STATISTICS\r\nif (cmdp->u.raw64.sg_lst[i].sg_ptr > (u64)0xffffffff)\r\nha->dma64_cnt++;\r\nelse\r\nha->dma32_cnt++;\r\n#endif\r\ncmdp->u.raw64.sg_lst[i].sg_len = sg_dma_len(sl);\r\n}\r\n} else {\r\nstruct scatterlist *sl;\r\ncmdp->u.raw.sdata = 0xffffffff;\r\ncmdp->u.raw.sg_ranz = sgcnt;\r\nscsi_for_each_sg(scp, sl, sgcnt, i) {\r\ncmdp->u.raw.sg_lst[i].sg_ptr = sg_dma_address(sl);\r\n#ifdef GDTH_DMA_STATISTICS\r\nha->dma32_cnt++;\r\n#endif\r\ncmdp->u.raw.sg_lst[i].sg_len = sg_dma_len(sl);\r\n}\r\n}\r\n#ifdef GDTH_STATISTICS\r\nif (max_sg < sgcnt) {\r\nmax_sg = sgcnt;\r\nTRACE3(("GDT: max_sg = %d\n",sgcnt));\r\n}\r\n#endif\r\n}\r\nif (mode64) {\r\nTRACE(("raw cmd: addr. %x sganz %x sgptr0 %x sglen0 %x\n",\r\ncmdp->u.raw64.sdata,cmdp->u.raw64.sg_ranz,\r\ncmdp->u.raw64.sg_lst[0].sg_ptr,\r\ncmdp->u.raw64.sg_lst[0].sg_len));\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.raw64.sg_lst) +\r\n(u16)cmdp->u.raw64.sg_ranz * sizeof(gdth_sg64_str);\r\n} else {\r\nTRACE(("raw cmd: addr. %x sganz %x sgptr0 %x sglen0 %x\n",\r\ncmdp->u.raw.sdata,cmdp->u.raw.sg_ranz,\r\ncmdp->u.raw.sg_lst[0].sg_ptr,\r\ncmdp->u.raw.sg_lst[0].sg_len));\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.raw.sg_lst) +\r\n(u16)cmdp->u.raw.sg_ranz * sizeof(gdth_sg_str);\r\n}\r\n}\r\nif (ha->cmd_len & 3)\r\nha->cmd_len += (4 - (ha->cmd_len & 3));\r\nif (ha->cmd_cnt > 0) {\r\nif ((ha->cmd_offs_dpmem + ha->cmd_len + DPMEM_COMMAND_OFFSET) >\r\nha->ic_all_size) {\r\nTRACE2(("gdth_fill_raw() DPMEM overflow\n"));\r\nha->cmd_tab[cmd_index-2].cmnd = UNUSED_CMND;\r\nreturn 0;\r\n}\r\n}\r\ngdth_copy_command(ha);\r\nreturn cmd_index;\r\n}\r\nstatic int gdth_special_cmd(gdth_ha_str *ha, Scsi_Cmnd *scp)\r\n{\r\nregister gdth_cmd_str *cmdp;\r\nstruct gdth_cmndinfo *cmndinfo = gdth_cmnd_priv(scp);\r\nint cmd_index;\r\ncmdp= ha->pccb;\r\nTRACE2(("gdth_special_cmd(): "));\r\nif (ha->type==GDT_EISA && ha->cmd_cnt>0)\r\nreturn 0;\r\n*cmdp = *cmndinfo->internal_cmd_str;\r\ncmdp->RequestBuffer = scp;\r\nif (!(cmd_index=gdth_get_cmd_index(ha))) {\r\nTRACE(("GDT: No free command index found\n"));\r\nreturn 0;\r\n}\r\nif (ha->cmd_cnt == 0)\r\ngdth_set_sema0(ha);\r\nif (cmdp->OpCode == GDT_IOCTL) {\r\nTRACE2(("IOCTL\n"));\r\nha->cmd_len =\r\nGDTOFFSOF(gdth_cmd_str,u.ioctl.p_param) + sizeof(u64);\r\n} else if (cmdp->Service == CACHESERVICE) {\r\nTRACE2(("cache command %d\n",cmdp->OpCode));\r\nif (ha->cache_feat & GDT_64BIT)\r\nha->cmd_len =\r\nGDTOFFSOF(gdth_cmd_str,u.cache64.sg_lst) + sizeof(gdth_sg64_str);\r\nelse\r\nha->cmd_len =\r\nGDTOFFSOF(gdth_cmd_str,u.cache.sg_lst) + sizeof(gdth_sg_str);\r\n} else if (cmdp->Service == SCSIRAWSERVICE) {\r\nTRACE2(("raw command %d\n",cmdp->OpCode));\r\nif (ha->raw_feat & GDT_64BIT)\r\nha->cmd_len =\r\nGDTOFFSOF(gdth_cmd_str,u.raw64.sg_lst) + sizeof(gdth_sg64_str);\r\nelse\r\nha->cmd_len =\r\nGDTOFFSOF(gdth_cmd_str,u.raw.sg_lst) + sizeof(gdth_sg_str);\r\n}\r\nif (ha->cmd_len & 3)\r\nha->cmd_len += (4 - (ha->cmd_len & 3));\r\nif (ha->cmd_cnt > 0) {\r\nif ((ha->cmd_offs_dpmem + ha->cmd_len + DPMEM_COMMAND_OFFSET) >\r\nha->ic_all_size) {\r\nTRACE2(("gdth_special_cmd() DPMEM overflow\n"));\r\nha->cmd_tab[cmd_index-2].cmnd = UNUSED_CMND;\r\nreturn 0;\r\n}\r\n}\r\ngdth_copy_command(ha);\r\nreturn cmd_index;\r\n}\r\nstatic gdth_evt_str *gdth_store_event(gdth_ha_str *ha, u16 source,\r\nu16 idx, gdth_evt_data *evt)\r\n{\r\ngdth_evt_str *e;\r\nTRACE2(("gdth_store_event() source %d idx %d\n", source, idx));\r\nif (source == 0)\r\nreturn NULL;\r\nif (ebuffer[elastidx].event_source == source &&\r\nebuffer[elastidx].event_idx == idx &&\r\n((evt->size != 0 && ebuffer[elastidx].event_data.size != 0 &&\r\n!memcmp((char *)&ebuffer[elastidx].event_data.eu,\r\n(char *)&evt->eu, evt->size)) ||\r\n(evt->size == 0 && ebuffer[elastidx].event_data.size == 0 &&\r\n!strcmp((char *)&ebuffer[elastidx].event_data.event_string,\r\n(char *)&evt->event_string)))) {\r\ne = &ebuffer[elastidx];\r\ne->last_stamp = (u32)ktime_get_real_seconds();\r\n++e->same_count;\r\n} else {\r\nif (ebuffer[elastidx].event_source != 0) {\r\n++elastidx;\r\nif (elastidx == MAX_EVENTS)\r\nelastidx = 0;\r\nif (elastidx == eoldidx) {\r\n++eoldidx;\r\nif (eoldidx == MAX_EVENTS)\r\neoldidx = 0;\r\n}\r\n}\r\ne = &ebuffer[elastidx];\r\ne->event_source = source;\r\ne->event_idx = idx;\r\ne->first_stamp = e->last_stamp = (u32)ktime_get_real_seconds();\r\ne->same_count = 1;\r\ne->event_data = *evt;\r\ne->application = 0;\r\n}\r\nreturn e;\r\n}\r\nstatic int gdth_read_event(gdth_ha_str *ha, int handle, gdth_evt_str *estr)\r\n{\r\ngdth_evt_str *e;\r\nint eindex;\r\nunsigned long flags;\r\nTRACE2(("gdth_read_event() handle %d\n", handle));\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nif (handle == -1)\r\neindex = eoldidx;\r\nelse\r\neindex = handle;\r\nestr->event_source = 0;\r\nif (eindex < 0 || eindex >= MAX_EVENTS) {\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn eindex;\r\n}\r\ne = &ebuffer[eindex];\r\nif (e->event_source != 0) {\r\nif (eindex != elastidx) {\r\nif (++eindex == MAX_EVENTS)\r\neindex = 0;\r\n} else {\r\neindex = -1;\r\n}\r\nmemcpy(estr, e, sizeof(gdth_evt_str));\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn eindex;\r\n}\r\nstatic void gdth_readapp_event(gdth_ha_str *ha,\r\nu8 application, gdth_evt_str *estr)\r\n{\r\ngdth_evt_str *e;\r\nint eindex;\r\nunsigned long flags;\r\nu8 found = FALSE;\r\nTRACE2(("gdth_readapp_event() app. %d\n", application));\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\neindex = eoldidx;\r\nfor (;;) {\r\ne = &ebuffer[eindex];\r\nif (e->event_source == 0)\r\nbreak;\r\nif ((e->application & application) == 0) {\r\ne->application |= application;\r\nfound = TRUE;\r\nbreak;\r\n}\r\nif (eindex == elastidx)\r\nbreak;\r\nif (++eindex == MAX_EVENTS)\r\neindex = 0;\r\n}\r\nif (found)\r\nmemcpy(estr, e, sizeof(gdth_evt_str));\r\nelse\r\nestr->event_source = 0;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n}\r\nstatic void gdth_clear_events(void)\r\n{\r\nTRACE(("gdth_clear_events()"));\r\neoldidx = elastidx = 0;\r\nebuffer[0].event_source = 0;\r\n}\r\nstatic irqreturn_t __gdth_interrupt(gdth_ha_str *ha,\r\nint gdth_from_wait, int* pIndex)\r\n{\r\ngdt6m_dpram_str __iomem *dp6m_ptr = NULL;\r\ngdt6_dpram_str __iomem *dp6_ptr;\r\ngdt2_dpram_str __iomem *dp2_ptr;\r\nScsi_Cmnd *scp;\r\nint rval, i;\r\nu8 IStatus;\r\nu16 Service;\r\nunsigned long flags = 0;\r\n#ifdef INT_COAL\r\nint coalesced = FALSE;\r\nint next = FALSE;\r\ngdth_coal_status *pcs = NULL;\r\nint act_int_coal = 0;\r\n#endif\r\nTRACE(("gdth_interrupt() IRQ %d\n", ha->irq));\r\nif (gdth_polling) {\r\nif (!gdth_from_wait) {\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif (!gdth_polling)\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nIStatus = gdth_get_status(ha);\r\nif (IStatus == 0) {\r\nif (!gdth_polling)\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\n#ifdef GDTH_STATISTICS\r\n++act_ints;\r\n#endif\r\n#ifdef INT_COAL\r\nif (IStatus == COALINDEX) {\r\npcs = ha->coal_stat;\r\ncoalesced = TRUE;\r\nnext = TRUE;\r\n}\r\ndo {\r\nif (coalesced) {\r\nIStatus = (u8)(pcs->status & 0xff);\r\n}\r\n#endif\r\nif (ha->type == GDT_EISA) {\r\nif (IStatus & 0x80) {\r\nIStatus &= ~0x80;\r\nha->status = inw(ha->bmic + MAILBOXREG+8);\r\nTRACE2(("gdth_interrupt() error %d/%d\n",IStatus,ha->status));\r\n} else\r\nha->status = S_OK;\r\nha->info = inl(ha->bmic + MAILBOXREG+12);\r\nha->service = inw(ha->bmic + MAILBOXREG+10);\r\nha->info2 = inl(ha->bmic + MAILBOXREG+4);\r\noutb(0xff, ha->bmic + EDOORREG);\r\noutb(0x00, ha->bmic + SEMA1REG);\r\n} else if (ha->type == GDT_ISA) {\r\ndp2_ptr = ha->brd;\r\nif (IStatus & 0x80) {\r\nIStatus &= ~0x80;\r\nha->status = readw(&dp2_ptr->u.ic.Status);\r\nTRACE2(("gdth_interrupt() error %d/%d\n",IStatus,ha->status));\r\n} else\r\nha->status = S_OK;\r\nha->info = readl(&dp2_ptr->u.ic.Info[0]);\r\nha->service = readw(&dp2_ptr->u.ic.Service);\r\nha->info2 = readl(&dp2_ptr->u.ic.Info[1]);\r\nwriteb(0xff, &dp2_ptr->io.irqdel);\r\nwriteb(0, &dp2_ptr->u.ic.Cmd_Index);\r\nwriteb(0, &dp2_ptr->io.Sema1);\r\n} else if (ha->type == GDT_PCI) {\r\ndp6_ptr = ha->brd;\r\nif (IStatus & 0x80) {\r\nIStatus &= ~0x80;\r\nha->status = readw(&dp6_ptr->u.ic.Status);\r\nTRACE2(("gdth_interrupt() error %d/%d\n",IStatus,ha->status));\r\n} else\r\nha->status = S_OK;\r\nha->info = readl(&dp6_ptr->u.ic.Info[0]);\r\nha->service = readw(&dp6_ptr->u.ic.Service);\r\nha->info2 = readl(&dp6_ptr->u.ic.Info[1]);\r\nwriteb(0xff, &dp6_ptr->io.irqdel);\r\nwriteb(0, &dp6_ptr->u.ic.Cmd_Index);\r\nwriteb(0, &dp6_ptr->io.Sema1);\r\n} else if (ha->type == GDT_PCINEW) {\r\nif (IStatus & 0x80) {\r\nIStatus &= ~0x80;\r\nha->status = inw(PTR2USHORT(&ha->plx->status));\r\nTRACE2(("gdth_interrupt() error %d/%d\n",IStatus,ha->status));\r\n} else\r\nha->status = S_OK;\r\nha->info = inl(PTR2USHORT(&ha->plx->info[0]));\r\nha->service = inw(PTR2USHORT(&ha->plx->service));\r\nha->info2 = inl(PTR2USHORT(&ha->plx->info[1]));\r\noutb(0xff, PTR2USHORT(&ha->plx->edoor_reg));\r\noutb(0x00, PTR2USHORT(&ha->plx->sema1_reg));\r\n} else if (ha->type == GDT_PCIMPR) {\r\ndp6m_ptr = ha->brd;\r\nif (IStatus & 0x80) {\r\nIStatus &= ~0x80;\r\n#ifdef INT_COAL\r\nif (coalesced)\r\nha->status = pcs->ext_status & 0xffff;\r\nelse\r\n#endif\r\nha->status = readw(&dp6m_ptr->i960r.status);\r\nTRACE2(("gdth_interrupt() error %d/%d\n",IStatus,ha->status));\r\n} else\r\nha->status = S_OK;\r\n#ifdef INT_COAL\r\nif (coalesced) {\r\nha->info = pcs->info0;\r\nha->info2 = pcs->info1;\r\nha->service = (pcs->ext_status >> 16) & 0xffff;\r\n} else\r\n#endif\r\n{\r\nha->info = readl(&dp6m_ptr->i960r.info[0]);\r\nha->service = readw(&dp6m_ptr->i960r.service);\r\nha->info2 = readl(&dp6m_ptr->i960r.info[1]);\r\n}\r\nif (IStatus == ASYNCINDEX) {\r\nif (ha->service != SCREENSERVICE &&\r\n(ha->fw_vers & 0xff) >= 0x1a) {\r\nha->dvr.severity = readb\r\n(&((gdt6m_dpram_str __iomem *)ha->brd)->i960r.severity);\r\nfor (i = 0; i < 256; ++i) {\r\nha->dvr.event_string[i] = readb\r\n(&((gdt6m_dpram_str __iomem *)ha->brd)->i960r.evt_str[i]);\r\nif (ha->dvr.event_string[i] == 0)\r\nbreak;\r\n}\r\n}\r\n}\r\n#ifdef INT_COAL\r\nif (!coalesced)\r\n#endif\r\n{\r\nwriteb(0xff, &dp6m_ptr->i960r.edoor_reg);\r\nwriteb(0, &dp6m_ptr->i960r.sema1_reg);\r\n}\r\n} else {\r\nTRACE2(("gdth_interrupt() unknown controller type\n"));\r\nif (!gdth_polling)\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nTRACE(("gdth_interrupt() index %d stat %d info %d\n",\r\nIStatus,ha->status,ha->info));\r\nif (gdth_from_wait) {\r\n*pIndex = (int)IStatus;\r\n}\r\nif (IStatus == ASYNCINDEX) {\r\nTRACE2(("gdth_interrupt() async. event\n"));\r\ngdth_async_event(ha);\r\nif (!gdth_polling)\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\ngdth_next(ha);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (IStatus == SPEZINDEX) {\r\nTRACE2(("Service unknown or not initialized !\n"));\r\nha->dvr.size = sizeof(ha->dvr.eu.driver);\r\nha->dvr.eu.driver.ionode = ha->hanum;\r\ngdth_store_event(ha, ES_DRIVER, 4, &ha->dvr);\r\nif (!gdth_polling)\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nscp = ha->cmd_tab[IStatus-2].cmnd;\r\nService = ha->cmd_tab[IStatus-2].service;\r\nha->cmd_tab[IStatus-2].cmnd = UNUSED_CMND;\r\nif (scp == UNUSED_CMND) {\r\nTRACE2(("gdth_interrupt() index to unused command (%d)\n",IStatus));\r\nha->dvr.size = sizeof(ha->dvr.eu.driver);\r\nha->dvr.eu.driver.ionode = ha->hanum;\r\nha->dvr.eu.driver.index = IStatus;\r\ngdth_store_event(ha, ES_DRIVER, 1, &ha->dvr);\r\nif (!gdth_polling)\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (scp == INTERNAL_CMND) {\r\nTRACE(("gdth_interrupt() answer to internal command\n"));\r\nif (!gdth_polling)\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nTRACE(("gdth_interrupt() sync. status\n"));\r\nrval = gdth_sync_event(ha,Service,IStatus,scp);\r\nif (!gdth_polling)\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nif (rval == 2) {\r\ngdth_putq(ha, scp, gdth_cmnd_priv(scp)->priority);\r\n} else if (rval == 1) {\r\ngdth_scsi_done(scp);\r\n}\r\n#ifdef INT_COAL\r\nif (coalesced) {\r\n++pcs;\r\n#ifdef GDTH_STATISTICS\r\n++act_int_coal;\r\nif (act_int_coal > max_int_coal) {\r\nmax_int_coal = act_int_coal;\r\nprintk("GDT: max_int_coal = %d\n",(u16)max_int_coal);\r\n}\r\n#endif\r\nif (pcs->status == 0)\r\nnext = FALSE;\r\n}\r\n} while (next);\r\nif (ha->type == GDT_PCIMPR && coalesced) {\r\nwriteb(0xff, &dp6m_ptr->i960r.edoor_reg);\r\nwriteb(0, &dp6m_ptr->i960r.sema1_reg);\r\n}\r\n#endif\r\ngdth_next(ha);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t gdth_interrupt(int irq, void *dev_id)\r\n{\r\ngdth_ha_str *ha = dev_id;\r\nreturn __gdth_interrupt(ha, false, NULL);\r\n}\r\nstatic int gdth_sync_event(gdth_ha_str *ha, int service, u8 index,\r\nScsi_Cmnd *scp)\r\n{\r\ngdth_msg_str *msg;\r\ngdth_cmd_str *cmdp;\r\nu8 b, t;\r\nstruct gdth_cmndinfo *cmndinfo = gdth_cmnd_priv(scp);\r\ncmdp = ha->pccb;\r\nTRACE(("gdth_sync_event() serv %d status %d\n",\r\nservice,ha->status));\r\nif (service == SCREENSERVICE) {\r\nmsg = ha->pmsg;\r\nTRACE(("len: %d, answer: %d, ext: %d, alen: %d\n",\r\nmsg->msg_len,msg->msg_answer,msg->msg_ext,msg->msg_alen));\r\nif (msg->msg_len > MSGLEN+1)\r\nmsg->msg_len = MSGLEN+1;\r\nif (msg->msg_len)\r\nif (!(msg->msg_answer && msg->msg_ext)) {\r\nmsg->msg_text[msg->msg_len] = '\0';\r\nprintk("%s",msg->msg_text);\r\n}\r\nif (msg->msg_ext && !msg->msg_answer) {\r\nwhile (gdth_test_busy(ha))\r\ngdth_delay(0);\r\ncmdp->Service = SCREENSERVICE;\r\ncmdp->RequestBuffer = SCREEN_CMND;\r\ngdth_get_cmd_index(ha);\r\ngdth_set_sema0(ha);\r\ncmdp->OpCode = GDT_READ;\r\ncmdp->BoardNode = LOCALBOARD;\r\ncmdp->u.screen.reserved = 0;\r\ncmdp->u.screen.su.msg.msg_handle= msg->msg_handle;\r\ncmdp->u.screen.su.msg.msg_addr = ha->msg_phys;\r\nha->cmd_offs_dpmem = 0;\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.screen.su.msg.msg_addr)\r\n+ sizeof(u64);\r\nha->cmd_cnt = 0;\r\ngdth_copy_command(ha);\r\ngdth_release_event(ha);\r\nreturn 0;\r\n}\r\nif (msg->msg_answer && msg->msg_alen) {\r\nif (msg->msg_alen == 1) {\r\nmsg->msg_alen = 0;\r\nmsg->msg_len = 1;\r\nmsg->msg_text[0] = 0;\r\n} else {\r\nmsg->msg_alen -= 2;\r\nmsg->msg_len = 2;\r\nmsg->msg_text[0] = 1;\r\nmsg->msg_text[1] = 0;\r\n}\r\nmsg->msg_ext = 0;\r\nmsg->msg_answer = 0;\r\nwhile (gdth_test_busy(ha))\r\ngdth_delay(0);\r\ncmdp->Service = SCREENSERVICE;\r\ncmdp->RequestBuffer = SCREEN_CMND;\r\ngdth_get_cmd_index(ha);\r\ngdth_set_sema0(ha);\r\ncmdp->OpCode = GDT_WRITE;\r\ncmdp->BoardNode = LOCALBOARD;\r\ncmdp->u.screen.reserved = 0;\r\ncmdp->u.screen.su.msg.msg_handle= msg->msg_handle;\r\ncmdp->u.screen.su.msg.msg_addr = ha->msg_phys;\r\nha->cmd_offs_dpmem = 0;\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.screen.su.msg.msg_addr)\r\n+ sizeof(u64);\r\nha->cmd_cnt = 0;\r\ngdth_copy_command(ha);\r\ngdth_release_event(ha);\r\nreturn 0;\r\n}\r\nprintk("\n");\r\n} else {\r\nb = scp->device->channel;\r\nt = scp->device->id;\r\nif (cmndinfo->OpCode == -1 && b != ha->virt_bus) {\r\nha->raw[BUS_L2P(ha,b)].io_cnt[t]--;\r\n}\r\nif (ha->status == S_BSY) {\r\nTRACE2(("Controller busy -> retry !\n"));\r\nif (cmndinfo->OpCode == GDT_MOUNT)\r\ncmndinfo->OpCode = GDT_CLUST_INFO;\r\nreturn 2;\r\n}\r\nif (scsi_bufflen(scp))\r\npci_unmap_sg(ha->pdev, scsi_sglist(scp), scsi_sg_count(scp),\r\ncmndinfo->dma_dir);\r\nif (cmndinfo->sense_paddr)\r\npci_unmap_page(ha->pdev, cmndinfo->sense_paddr, 16,\r\nPCI_DMA_FROMDEVICE);\r\nif (ha->status == S_OK) {\r\ncmndinfo->status = S_OK;\r\ncmndinfo->info = ha->info;\r\nif (cmndinfo->OpCode != -1) {\r\nTRACE2(("gdth_sync_event(): special cmd 0x%x OK\n",\r\ncmndinfo->OpCode));\r\nif (cmndinfo->OpCode == GDT_CLUST_INFO) {\r\nha->hdr[t].cluster_type = (u8)ha->info;\r\nif (!(ha->hdr[t].cluster_type &\r\nCLUSTER_MOUNTED)) {\r\ncmndinfo->OpCode = GDT_MOUNT;\r\nif (ha->hdr[t].cluster_type &\r\nCLUSTER_RESERVED) {\r\ncmndinfo->phase = -2;\r\n}\r\n} else {\r\ncmndinfo->OpCode = -1;\r\n}\r\n} else {\r\nif (cmndinfo->OpCode == GDT_MOUNT) {\r\nha->hdr[t].cluster_type |= CLUSTER_MOUNTED;\r\nha->hdr[t].media_changed = TRUE;\r\n} else if (cmndinfo->OpCode == GDT_UNMOUNT) {\r\nha->hdr[t].cluster_type &= ~CLUSTER_MOUNTED;\r\nha->hdr[t].media_changed = TRUE;\r\n}\r\ncmndinfo->OpCode = -1;\r\n}\r\ncmndinfo->priority = HIGH_PRI;\r\nreturn 2;\r\n} else {\r\nif (scp->cmnd[0] == RESERVE) {\r\nha->hdr[t].cluster_type |= CLUSTER_RESERVED;\r\n} else if (scp->cmnd[0] == RELEASE) {\r\nha->hdr[t].cluster_type &= ~CLUSTER_RESERVED;\r\n}\r\nscp->result = DID_OK << 16;\r\nscp->sense_buffer[0] = 0;\r\n}\r\n} else {\r\ncmndinfo->status = ha->status;\r\ncmndinfo->info = ha->info;\r\nif (cmndinfo->OpCode != -1) {\r\nTRACE2(("gdth_sync_event(): special cmd 0x%x error 0x%x\n",\r\ncmndinfo->OpCode, ha->status));\r\nif (cmndinfo->OpCode == GDT_SCAN_START ||\r\ncmndinfo->OpCode == GDT_SCAN_END) {\r\ncmndinfo->OpCode = -1;\r\ncmndinfo->priority = HIGH_PRI;\r\nreturn 2;\r\n}\r\nmemset((char*)scp->sense_buffer,0,16);\r\nscp->sense_buffer[0] = 0x70;\r\nscp->sense_buffer[2] = NOT_READY;\r\nscp->result = (DID_OK << 16) | (CHECK_CONDITION << 1);\r\n} else if (service == CACHESERVICE) {\r\nif (ha->status == S_CACHE_UNKNOWN &&\r\n(ha->hdr[t].cluster_type &\r\nCLUSTER_RESERVE_STATE) == CLUSTER_RESERVE_STATE) {\r\nha->hdr[t].cluster_type &= ~CLUSTER_RESERVED;\r\n}\r\nmemset((char*)scp->sense_buffer,0,16);\r\nif (ha->status == (u16)S_CACHE_RESERV) {\r\nscp->result = (DID_OK << 16) | (RESERVATION_CONFLICT << 1);\r\n} else {\r\nscp->sense_buffer[0] = 0x70;\r\nscp->sense_buffer[2] = NOT_READY;\r\nscp->result = (DID_OK << 16) | (CHECK_CONDITION << 1);\r\n}\r\nif (!cmndinfo->internal_command) {\r\nha->dvr.size = sizeof(ha->dvr.eu.sync);\r\nha->dvr.eu.sync.ionode = ha->hanum;\r\nha->dvr.eu.sync.service = service;\r\nha->dvr.eu.sync.status = ha->status;\r\nha->dvr.eu.sync.info = ha->info;\r\nha->dvr.eu.sync.hostdrive = t;\r\nif (ha->status >= 0x8000)\r\ngdth_store_event(ha, ES_SYNC, 0, &ha->dvr);\r\nelse\r\ngdth_store_event(ha, ES_SYNC, service, &ha->dvr);\r\n}\r\n} else {\r\nif (ha->status != S_RAW_SCSI || ha->info >= 0x100) {\r\nscp->result = DID_BAD_TARGET << 16;\r\n} else {\r\nscp->result = (DID_OK << 16) | ha->info;\r\n}\r\n}\r\n}\r\nif (!cmndinfo->wait_for_completion)\r\ncmndinfo->wait_for_completion++;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gdth_async_event(gdth_ha_str *ha)\r\n{\r\ngdth_cmd_str *cmdp;\r\nint cmd_index;\r\ncmdp= ha->pccb;\r\nTRACE2(("gdth_async_event() ha %d serv %d\n",\r\nha->hanum, ha->service));\r\nif (ha->service == SCREENSERVICE) {\r\nif (ha->status == MSG_REQUEST) {\r\nwhile (gdth_test_busy(ha))\r\ngdth_delay(0);\r\ncmdp->Service = SCREENSERVICE;\r\ncmdp->RequestBuffer = SCREEN_CMND;\r\ncmd_index = gdth_get_cmd_index(ha);\r\ngdth_set_sema0(ha);\r\ncmdp->OpCode = GDT_READ;\r\ncmdp->BoardNode = LOCALBOARD;\r\ncmdp->u.screen.reserved = 0;\r\ncmdp->u.screen.su.msg.msg_handle= MSG_INV_HANDLE;\r\ncmdp->u.screen.su.msg.msg_addr = ha->msg_phys;\r\nha->cmd_offs_dpmem = 0;\r\nha->cmd_len = GDTOFFSOF(gdth_cmd_str,u.screen.su.msg.msg_addr)\r\n+ sizeof(u64);\r\nha->cmd_cnt = 0;\r\ngdth_copy_command(ha);\r\nif (ha->type == GDT_EISA)\r\nprintk("[EISA slot %d] ",(u16)ha->brd_phys);\r\nelse if (ha->type == GDT_ISA)\r\nprintk("[DPMEM 0x%4X] ",(u16)ha->brd_phys);\r\nelse\r\nprintk("[PCI %d/%d] ",(u16)(ha->brd_phys>>8),\r\n(u16)((ha->brd_phys>>3)&0x1f));\r\ngdth_release_event(ha);\r\n}\r\n} else {\r\nif (ha->type == GDT_PCIMPR &&\r\n(ha->fw_vers & 0xff) >= 0x1a) {\r\nha->dvr.size = 0;\r\nha->dvr.eu.async.ionode = ha->hanum;\r\nha->dvr.eu.async.status = ha->status;\r\n} else {\r\nha->dvr.size = sizeof(ha->dvr.eu.async);\r\nha->dvr.eu.async.ionode = ha->hanum;\r\nha->dvr.eu.async.service = ha->service;\r\nha->dvr.eu.async.status = ha->status;\r\nha->dvr.eu.async.info = ha->info;\r\n*(u32 *)ha->dvr.eu.async.scsi_coord = ha->info2;\r\n}\r\ngdth_store_event( ha, ES_ASYNC, ha->service, &ha->dvr );\r\ngdth_log_event( &ha->dvr, NULL );\r\nif (ha->service == CACHESERVICE && ha->status == 56) {\r\nTRACE2(("gdth_async_event(): new host drive %d created\n",\r\n(u16)ha->info));\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void gdth_log_event(gdth_evt_data *dvr, char *buffer)\r\n{\r\ngdth_stackframe stack;\r\nchar *f = NULL;\r\nint i,j;\r\nTRACE2(("gdth_log_event()\n"));\r\nif (dvr->size == 0) {\r\nif (buffer == NULL) {\r\nprintk("Adapter %d: %s\n",dvr->eu.async.ionode,dvr->event_string);\r\n} else {\r\nsprintf(buffer,"Adapter %d: %s\n",\r\ndvr->eu.async.ionode,dvr->event_string);\r\n}\r\n} else if (dvr->eu.async.service == CACHESERVICE &&\r\nINDEX_OK(dvr->eu.async.status, async_cache_tab)) {\r\nTRACE2(("GDT: Async. event cache service, event no.: %d\n",\r\ndvr->eu.async.status));\r\nf = async_cache_tab[dvr->eu.async.status];\r\nfor (j=0,i=1; i < f[0]; i+=2) {\r\nswitch (f[i+1]) {\r\ncase 4:\r\nstack.b[j++] = *(u32*)&dvr->eu.stream[(int)f[i]];\r\nbreak;\r\ncase 2:\r\nstack.b[j++] = *(u16*)&dvr->eu.stream[(int)f[i]];\r\nbreak;\r\ncase 1:\r\nstack.b[j++] = *(u8*)&dvr->eu.stream[(int)f[i]];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (buffer == NULL) {\r\nprintk(&f[(int)f[0]],stack);\r\nprintk("\n");\r\n} else {\r\nsprintf(buffer,&f[(int)f[0]],stack);\r\n}\r\n} else {\r\nif (buffer == NULL) {\r\nprintk("GDT HA %u, Unknown async. event service %d event no. %d\n",\r\ndvr->eu.async.ionode,dvr->eu.async.service,dvr->eu.async.status);\r\n} else {\r\nsprintf(buffer,"GDT HA %u, Unknown async. event service %d event no. %d",\r\ndvr->eu.async.ionode,dvr->eu.async.service,dvr->eu.async.status);\r\n}\r\n}\r\n}\r\nstatic void gdth_timeout(unsigned long data)\r\n{\r\nu32 i;\r\nScsi_Cmnd *nscp;\r\ngdth_ha_str *ha;\r\nunsigned long flags;\r\nif(unlikely(list_empty(&gdth_instances))) {\r\ngdth_timer_running = 0;\r\nreturn;\r\n}\r\nha = list_first_entry(&gdth_instances, gdth_ha_str, list);\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nfor (act_stats=0,i=0; i<GDTH_MAXCMDS; ++i)\r\nif (ha->cmd_tab[i].cmnd != UNUSED_CMND)\r\n++act_stats;\r\nfor (act_rq=0,nscp=ha->req_first; nscp; nscp=(Scsi_Cmnd*)nscp->SCp.ptr)\r\n++act_rq;\r\nTRACE2(("gdth_to(): ints %d, ios %d, act_stats %d, act_rq %d\n",\r\nact_ints, act_ios, act_stats, act_rq));\r\nact_ints = act_ios = 0;\r\ngdth_timer.expires = jiffies + 30 * HZ;\r\nadd_timer(&gdth_timer);\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n}\r\nstatic void gdth_timer_init(void)\r\n{\r\nif (gdth_timer_running)\r\nreturn;\r\ngdth_timer_running = 1;\r\nTRACE2(("gdth_detect(): Initializing timer !\n"));\r\ngdth_timer.expires = jiffies + HZ;\r\ngdth_timer.data = 0L;\r\ngdth_timer.function = gdth_timeout;\r\nadd_timer(&gdth_timer);\r\n}\r\nstatic inline void gdth_timer_init(void)\r\n{\r\n}\r\nstatic void __init internal_setup(char *str,int *ints)\r\n{\r\nint i, argc;\r\nchar *cur_str, *argv;\r\nTRACE2(("internal_setup() str %s ints[0] %d\n",\r\nstr ? str:"NULL", ints ? ints[0]:0));\r\nif (ints) {\r\nargc = ints[0];\r\nif (argc > 0) {\r\nif (argc > MAXHA)\r\nargc = MAXHA;\r\nfor (i = 0; i < argc; ++i)\r\nirq[i] = ints[i+1];\r\n}\r\n}\r\nargv = str;\r\nwhile (argv && (cur_str = strchr(argv, ':'))) {\r\nint val = 0, c = *++cur_str;\r\nif (c == 'n' || c == 'N')\r\nval = 0;\r\nelse if (c == 'y' || c == 'Y')\r\nval = 1;\r\nelse\r\nval = (int)simple_strtoul(cur_str, NULL, 0);\r\nif (!strncmp(argv, "disable:", 8))\r\ndisable = val;\r\nelse if (!strncmp(argv, "reserve_mode:", 13))\r\nreserve_mode = val;\r\nelse if (!strncmp(argv, "reverse_scan:", 13))\r\nreverse_scan = val;\r\nelse if (!strncmp(argv, "hdr_channel:", 12))\r\nhdr_channel = val;\r\nelse if (!strncmp(argv, "max_ids:", 8))\r\nmax_ids = val;\r\nelse if (!strncmp(argv, "rescan:", 7))\r\nrescan = val;\r\nelse if (!strncmp(argv, "shared_access:", 14))\r\nshared_access = val;\r\nelse if (!strncmp(argv, "probe_eisa_isa:", 15))\r\nprobe_eisa_isa = val;\r\nelse if (!strncmp(argv, "reserve_list:", 13)) {\r\nreserve_list[0] = val;\r\nfor (i = 1; i < MAX_RES_ARGS; i++) {\r\ncur_str = strchr(cur_str, ',');\r\nif (!cur_str)\r\nbreak;\r\nif (!isdigit((int)*++cur_str)) {\r\n--cur_str;\r\nbreak;\r\n}\r\nreserve_list[i] =\r\n(int)simple_strtoul(cur_str, NULL, 0);\r\n}\r\nif (!cur_str)\r\nbreak;\r\nargv = ++cur_str;\r\ncontinue;\r\n}\r\nif ((argv = strchr(argv, ',')))\r\n++argv;\r\n}\r\n}\r\nint __init option_setup(char *str)\r\n{\r\nint ints[MAXHA];\r\nchar *cur = str;\r\nint i = 1;\r\nTRACE2(("option_setup() str %s\n", str ? str:"NULL"));\r\nwhile (cur && isdigit(*cur) && i < MAXHA) {\r\nints[i++] = simple_strtoul(cur, NULL, 0);\r\nif ((cur = strchr(cur, ',')) != NULL) cur++;\r\n}\r\nints[0] = i - 1;\r\ninternal_setup(cur, ints);\r\nreturn 1;\r\n}\r\nstatic const char *gdth_ctr_name(gdth_ha_str *ha)\r\n{\r\nTRACE2(("gdth_ctr_name()\n"));\r\nif (ha->type == GDT_EISA) {\r\nswitch (ha->stype) {\r\ncase GDT3_ID:\r\nreturn("GDT3000/3020");\r\ncase GDT3A_ID:\r\nreturn("GDT3000A/3020A/3050A");\r\ncase GDT3B_ID:\r\nreturn("GDT3000B/3010A");\r\n}\r\n} else if (ha->type == GDT_ISA) {\r\nreturn("GDT2000/2020");\r\n} else if (ha->type == GDT_PCI) {\r\nswitch (ha->pdev->device) {\r\ncase PCI_DEVICE_ID_VORTEX_GDT60x0:\r\nreturn("GDT6000/6020/6050");\r\ncase PCI_DEVICE_ID_VORTEX_GDT6000B:\r\nreturn("GDT6000B/6010");\r\n}\r\n}\r\nreturn("");\r\n}\r\nstatic const char *gdth_info(struct Scsi_Host *shp)\r\n{\r\ngdth_ha_str *ha = shost_priv(shp);\r\nTRACE2(("gdth_info()\n"));\r\nreturn ((const char *)ha->binfo.type_string);\r\n}\r\nstatic enum blk_eh_timer_return gdth_timed_out(struct scsi_cmnd *scp)\r\n{\r\ngdth_ha_str *ha = shost_priv(scp->device->host);\r\nstruct gdth_cmndinfo *cmndinfo = gdth_cmnd_priv(scp);\r\nu8 b, t;\r\nunsigned long flags;\r\nenum blk_eh_timer_return retval = BLK_EH_NOT_HANDLED;\r\nTRACE(("%s() cmd 0x%x\n", scp->cmnd[0], __func__));\r\nb = scp->device->channel;\r\nt = scp->device->id;\r\nif (++cmndinfo->timeout_count < 6)\r\nretval = BLK_EH_RESET_TIMER;\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nif ((b != ha->virt_bus && ha->raw[BUS_L2P(ha, b)].lock) ||\r\n(b == ha->virt_bus && t < MAX_HDRIVES && ha->hdr[t].lock)) {\r\nTRACE2(("%s(): locked IO, reset timeout\n", __func__));\r\nretval = BLK_EH_RESET_TIMER;\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int gdth_eh_bus_reset(Scsi_Cmnd *scp)\r\n{\r\ngdth_ha_str *ha = shost_priv(scp->device->host);\r\nint i;\r\nunsigned long flags;\r\nScsi_Cmnd *cmnd;\r\nu8 b;\r\nTRACE2(("gdth_eh_bus_reset()\n"));\r\nb = scp->device->channel;\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nfor (i = 0; i < GDTH_MAXCMDS; ++i) {\r\ncmnd = ha->cmd_tab[i].cmnd;\r\nif (!SPECIAL_SCP(cmnd) && cmnd->device->channel == b)\r\nha->cmd_tab[i].cmnd = UNUSED_CMND;\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nif (b == ha->virt_bus) {\r\nfor (i = 0; i < MAX_HDRIVES; ++i) {\r\nif (ha->hdr[i].present) {\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\ngdth_polling = TRUE;\r\nwhile (gdth_test_busy(ha))\r\ngdth_delay(0);\r\nif (gdth_internal_cmd(ha, CACHESERVICE,\r\nGDT_CLUST_RESET, i, 0, 0))\r\nha->hdr[i].cluster_type &= ~CLUSTER_RESERVED;\r\ngdth_polling = FALSE;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n}\r\n}\r\n} else {\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nfor (i = 0; i < MAXID; ++i)\r\nha->raw[BUS_L2P(ha,b)].io_cnt[i] = 0;\r\ngdth_polling = TRUE;\r\nwhile (gdth_test_busy(ha))\r\ngdth_delay(0);\r\ngdth_internal_cmd(ha, SCSIRAWSERVICE, GDT_RESET_BUS,\r\nBUS_L2P(ha,b), 0, 0);\r\ngdth_polling = FALSE;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int gdth_bios_param(struct scsi_device *sdev,struct block_device *bdev,sector_t cap,int *ip)\r\n{\r\nu8 b, t;\r\ngdth_ha_str *ha = shost_priv(sdev->host);\r\nstruct scsi_device *sd;\r\nunsigned capacity;\r\nsd = sdev;\r\ncapacity = cap;\r\nb = sd->channel;\r\nt = sd->id;\r\nTRACE2(("gdth_bios_param() ha %d bus %d target %d\n", ha->hanum, b, t));\r\nif (b != ha->virt_bus || ha->hdr[t].heads == 0) {\r\nTRACE2(("Evaluate mapping\n"));\r\ngdth_eval_mapping(capacity,&ip[2],&ip[0],&ip[1]);\r\n} else {\r\nip[0] = ha->hdr[t].heads;\r\nip[1] = ha->hdr[t].secs;\r\nip[2] = capacity / ip[0] / ip[1];\r\n}\r\nTRACE2(("gdth_bios_param(): %d heads, %d secs, %d cyls\n",\r\nip[0],ip[1],ip[2]));\r\nreturn 0;\r\n}\r\nstatic int gdth_queuecommand_lck(struct scsi_cmnd *scp,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\ngdth_ha_str *ha = shost_priv(scp->device->host);\r\nstruct gdth_cmndinfo *cmndinfo;\r\nTRACE(("gdth_queuecommand() cmd 0x%x\n", scp->cmnd[0]));\r\ncmndinfo = gdth_get_cmndinfo(ha);\r\nBUG_ON(!cmndinfo);\r\nscp->scsi_done = done;\r\ncmndinfo->timeout_count = 0;\r\ncmndinfo->priority = DEFAULT_PRI;\r\nreturn __gdth_queuecommand(ha, scp, cmndinfo);\r\n}\r\nstatic int gdth_open(struct inode *inode, struct file *filep)\r\n{\r\ngdth_ha_str *ha;\r\nmutex_lock(&gdth_mutex);\r\nlist_for_each_entry(ha, &gdth_instances, list) {\r\nif (!ha->sdev)\r\nha->sdev = scsi_get_host_dev(ha->shost);\r\n}\r\nmutex_unlock(&gdth_mutex);\r\nTRACE(("gdth_open()\n"));\r\nreturn 0;\r\n}\r\nstatic int gdth_close(struct inode *inode, struct file *filep)\r\n{\r\nTRACE(("gdth_close()\n"));\r\nreturn 0;\r\n}\r\nstatic int ioc_event(void __user *arg)\r\n{\r\ngdth_ioctl_event evt;\r\ngdth_ha_str *ha;\r\nunsigned long flags;\r\nif (copy_from_user(&evt, arg, sizeof(gdth_ioctl_event)))\r\nreturn -EFAULT;\r\nha = gdth_find_ha(evt.ionode);\r\nif (!ha)\r\nreturn -EFAULT;\r\nif (evt.erase == 0xff) {\r\nif (evt.event.event_source == ES_TEST)\r\nevt.event.event_data.size=sizeof(evt.event.event_data.eu.test);\r\nelse if (evt.event.event_source == ES_DRIVER)\r\nevt.event.event_data.size=sizeof(evt.event.event_data.eu.driver);\r\nelse if (evt.event.event_source == ES_SYNC)\r\nevt.event.event_data.size=sizeof(evt.event.event_data.eu.sync);\r\nelse\r\nevt.event.event_data.size=sizeof(evt.event.event_data.eu.async);\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\ngdth_store_event(ha, evt.event.event_source, evt.event.event_idx,\r\n&evt.event.event_data);\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n} else if (evt.erase == 0xfe) {\r\ngdth_clear_events();\r\n} else if (evt.erase == 0) {\r\nevt.handle = gdth_read_event(ha, evt.handle, &evt.event);\r\n} else {\r\ngdth_readapp_event(ha, evt.erase, &evt.event);\r\n}\r\nif (copy_to_user(arg, &evt, sizeof(gdth_ioctl_event)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ioc_lockdrv(void __user *arg)\r\n{\r\ngdth_ioctl_lockdrv ldrv;\r\nu8 i, j;\r\nunsigned long flags;\r\ngdth_ha_str *ha;\r\nif (copy_from_user(&ldrv, arg, sizeof(gdth_ioctl_lockdrv)))\r\nreturn -EFAULT;\r\nha = gdth_find_ha(ldrv.ionode);\r\nif (!ha)\r\nreturn -EFAULT;\r\nfor (i = 0; i < ldrv.drive_cnt && i < MAX_HDRIVES; ++i) {\r\nj = ldrv.drives[i];\r\nif (j >= MAX_HDRIVES || !ha->hdr[j].present)\r\ncontinue;\r\nif (ldrv.lock) {\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->hdr[j].lock = 1;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\ngdth_wait_completion(ha, ha->bus_cnt, j);\r\n} else {\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->hdr[j].lock = 0;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\ngdth_next(ha);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioc_resetdrv(void __user *arg, char *cmnd)\r\n{\r\ngdth_ioctl_reset res;\r\ngdth_cmd_str cmd;\r\ngdth_ha_str *ha;\r\nint rval;\r\nif (copy_from_user(&res, arg, sizeof(gdth_ioctl_reset)) ||\r\nres.number >= MAX_HDRIVES)\r\nreturn -EFAULT;\r\nha = gdth_find_ha(res.ionode);\r\nif (!ha)\r\nreturn -EFAULT;\r\nif (!ha->hdr[res.number].present)\r\nreturn 0;\r\nmemset(&cmd, 0, sizeof(gdth_cmd_str));\r\ncmd.Service = CACHESERVICE;\r\ncmd.OpCode = GDT_CLUST_RESET;\r\nif (ha->cache_feat & GDT_64BIT)\r\ncmd.u.cache64.DeviceNo = res.number;\r\nelse\r\ncmd.u.cache.DeviceNo = res.number;\r\nrval = __gdth_execute(ha->sdev, &cmd, cmnd, 30, NULL);\r\nif (rval < 0)\r\nreturn rval;\r\nres.status = rval;\r\nif (copy_to_user(arg, &res, sizeof(gdth_ioctl_reset)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ioc_general(void __user *arg, char *cmnd)\r\n{\r\ngdth_ioctl_general gen;\r\nchar *buf = NULL;\r\nu64 paddr;\r\ngdth_ha_str *ha;\r\nint rval;\r\nif (copy_from_user(&gen, arg, sizeof(gdth_ioctl_general)))\r\nreturn -EFAULT;\r\nha = gdth_find_ha(gen.ionode);\r\nif (!ha)\r\nreturn -EFAULT;\r\nif (gen.data_len > INT_MAX)\r\nreturn -EINVAL;\r\nif (gen.sense_len > INT_MAX)\r\nreturn -EINVAL;\r\nif (gen.data_len + gen.sense_len > INT_MAX)\r\nreturn -EINVAL;\r\nif (gen.data_len + gen.sense_len != 0) {\r\nif (!(buf = gdth_ioctl_alloc(ha, gen.data_len + gen.sense_len,\r\nFALSE, &paddr)))\r\nreturn -EFAULT;\r\nif (copy_from_user(buf, arg + sizeof(gdth_ioctl_general),\r\ngen.data_len + gen.sense_len)) {\r\ngdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);\r\nreturn -EFAULT;\r\n}\r\nif (gen.command.OpCode == GDT_IOCTL) {\r\ngen.command.u.ioctl.p_param = paddr;\r\n} else if (gen.command.Service == CACHESERVICE) {\r\nif (ha->cache_feat & GDT_64BIT) {\r\ngen.command.u.cache64.BlockCnt = gen.command.u.cache.BlockCnt;\r\ngen.command.u.cache64.BlockNo = gen.command.u.cache.BlockNo;\r\ngen.command.u.cache64.DeviceNo = gen.command.u.cache.DeviceNo;\r\nif (ha->cache_feat & SCATTER_GATHER) {\r\ngen.command.u.cache64.DestAddr = (u64)-1;\r\ngen.command.u.cache64.sg_canz = 1;\r\ngen.command.u.cache64.sg_lst[0].sg_ptr = paddr;\r\ngen.command.u.cache64.sg_lst[0].sg_len = gen.data_len;\r\ngen.command.u.cache64.sg_lst[1].sg_len = 0;\r\n} else {\r\ngen.command.u.cache64.DestAddr = paddr;\r\ngen.command.u.cache64.sg_canz = 0;\r\n}\r\n} else {\r\nif (ha->cache_feat & SCATTER_GATHER) {\r\ngen.command.u.cache.DestAddr = 0xffffffff;\r\ngen.command.u.cache.sg_canz = 1;\r\ngen.command.u.cache.sg_lst[0].sg_ptr = (u32)paddr;\r\ngen.command.u.cache.sg_lst[0].sg_len = gen.data_len;\r\ngen.command.u.cache.sg_lst[1].sg_len = 0;\r\n} else {\r\ngen.command.u.cache.DestAddr = paddr;\r\ngen.command.u.cache.sg_canz = 0;\r\n}\r\n}\r\n} else if (gen.command.Service == SCSIRAWSERVICE) {\r\nif (ha->raw_feat & GDT_64BIT) {\r\nchar cmd[16];\r\ngen.command.u.raw64.sense_len = gen.command.u.raw.sense_len;\r\ngen.command.u.raw64.bus = gen.command.u.raw.bus;\r\ngen.command.u.raw64.lun = gen.command.u.raw.lun;\r\ngen.command.u.raw64.target = gen.command.u.raw.target;\r\nmemcpy(cmd, gen.command.u.raw.cmd, 16);\r\nmemcpy(gen.command.u.raw64.cmd, cmd, 16);\r\ngen.command.u.raw64.clen = gen.command.u.raw.clen;\r\ngen.command.u.raw64.sdlen = gen.command.u.raw.sdlen;\r\ngen.command.u.raw64.direction = gen.command.u.raw.direction;\r\nif (ha->raw_feat & SCATTER_GATHER) {\r\ngen.command.u.raw64.sdata = (u64)-1;\r\ngen.command.u.raw64.sg_ranz = 1;\r\ngen.command.u.raw64.sg_lst[0].sg_ptr = paddr;\r\ngen.command.u.raw64.sg_lst[0].sg_len = gen.data_len;\r\ngen.command.u.raw64.sg_lst[1].sg_len = 0;\r\n} else {\r\ngen.command.u.raw64.sdata = paddr;\r\ngen.command.u.raw64.sg_ranz = 0;\r\n}\r\ngen.command.u.raw64.sense_data = paddr + gen.data_len;\r\n} else {\r\nif (ha->raw_feat & SCATTER_GATHER) {\r\ngen.command.u.raw.sdata = 0xffffffff;\r\ngen.command.u.raw.sg_ranz = 1;\r\ngen.command.u.raw.sg_lst[0].sg_ptr = (u32)paddr;\r\ngen.command.u.raw.sg_lst[0].sg_len = gen.data_len;\r\ngen.command.u.raw.sg_lst[1].sg_len = 0;\r\n} else {\r\ngen.command.u.raw.sdata = paddr;\r\ngen.command.u.raw.sg_ranz = 0;\r\n}\r\ngen.command.u.raw.sense_data = (u32)paddr + gen.data_len;\r\n}\r\n} else {\r\ngdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);\r\nreturn -EFAULT;\r\n}\r\n}\r\nrval = __gdth_execute(ha->sdev, &gen.command, cmnd, gen.timeout, &gen.info);\r\nif (rval < 0) {\r\ngdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);\r\nreturn rval;\r\n}\r\ngen.status = rval;\r\nif (copy_to_user(arg + sizeof(gdth_ioctl_general), buf,\r\ngen.data_len + gen.sense_len)) {\r\ngdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);\r\nreturn -EFAULT;\r\n}\r\nif (copy_to_user(arg, &gen,\r\nsizeof(gdth_ioctl_general) - sizeof(gdth_cmd_str))) {\r\ngdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);\r\nreturn -EFAULT;\r\n}\r\ngdth_ioctl_free(ha, gen.data_len+gen.sense_len, buf, paddr);\r\nreturn 0;\r\n}\r\nstatic int ioc_hdrlist(void __user *arg, char *cmnd)\r\n{\r\ngdth_ioctl_rescan *rsc;\r\ngdth_cmd_str *cmd;\r\ngdth_ha_str *ha;\r\nu8 i;\r\nint rc = -ENOMEM;\r\nu32 cluster_type = 0;\r\nrsc = kmalloc(sizeof(*rsc), GFP_KERNEL);\r\ncmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!rsc || !cmd)\r\ngoto free_fail;\r\nif (copy_from_user(rsc, arg, sizeof(gdth_ioctl_rescan)) ||\r\n(NULL == (ha = gdth_find_ha(rsc->ionode)))) {\r\nrc = -EFAULT;\r\ngoto free_fail;\r\n}\r\nmemset(cmd, 0, sizeof(gdth_cmd_str));\r\nfor (i = 0; i < MAX_HDRIVES; ++i) {\r\nif (!ha->hdr[i].present) {\r\nrsc->hdr_list[i].bus = 0xff;\r\ncontinue;\r\n}\r\nrsc->hdr_list[i].bus = ha->virt_bus;\r\nrsc->hdr_list[i].target = i;\r\nrsc->hdr_list[i].lun = 0;\r\nrsc->hdr_list[i].cluster_type = ha->hdr[i].cluster_type;\r\nif (ha->hdr[i].cluster_type & CLUSTER_DRIVE) {\r\ncmd->Service = CACHESERVICE;\r\ncmd->OpCode = GDT_CLUST_INFO;\r\nif (ha->cache_feat & GDT_64BIT)\r\ncmd->u.cache64.DeviceNo = i;\r\nelse\r\ncmd->u.cache.DeviceNo = i;\r\nif (__gdth_execute(ha->sdev, cmd, cmnd, 30, &cluster_type) == S_OK)\r\nrsc->hdr_list[i].cluster_type = cluster_type;\r\n}\r\n}\r\nif (copy_to_user(arg, rsc, sizeof(gdth_ioctl_rescan)))\r\nrc = -EFAULT;\r\nelse\r\nrc = 0;\r\nfree_fail:\r\nkfree(rsc);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int ioc_rescan(void __user *arg, char *cmnd)\r\n{\r\ngdth_ioctl_rescan *rsc;\r\ngdth_cmd_str *cmd;\r\nu16 i, status, hdr_cnt;\r\nu32 info;\r\nint cyls, hds, secs;\r\nint rc = -ENOMEM;\r\nunsigned long flags;\r\ngdth_ha_str *ha;\r\nrsc = kmalloc(sizeof(*rsc), GFP_KERNEL);\r\ncmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd || !rsc)\r\ngoto free_fail;\r\nif (copy_from_user(rsc, arg, sizeof(gdth_ioctl_rescan)) ||\r\n(NULL == (ha = gdth_find_ha(rsc->ionode)))) {\r\nrc = -EFAULT;\r\ngoto free_fail;\r\n}\r\nmemset(cmd, 0, sizeof(gdth_cmd_str));\r\nif (rsc->flag == 0) {\r\ncmd->Service = CACHESERVICE;\r\nif (ha->cache_feat & GDT_64BIT) {\r\ncmd->OpCode = GDT_X_INIT_HOST;\r\ncmd->u.cache64.DeviceNo = LINUX_OS;\r\n} else {\r\ncmd->OpCode = GDT_INIT;\r\ncmd->u.cache.DeviceNo = LINUX_OS;\r\n}\r\nstatus = __gdth_execute(ha->sdev, cmd, cmnd, 30, &info);\r\ni = 0;\r\nhdr_cnt = (status == S_OK ? (u16)info : 0);\r\n} else {\r\ni = rsc->hdr_no;\r\nhdr_cnt = i + 1;\r\n}\r\nfor (; i < hdr_cnt && i < MAX_HDRIVES; ++i) {\r\ncmd->Service = CACHESERVICE;\r\ncmd->OpCode = GDT_INFO;\r\nif (ha->cache_feat & GDT_64BIT)\r\ncmd->u.cache64.DeviceNo = i;\r\nelse\r\ncmd->u.cache.DeviceNo = i;\r\nstatus = __gdth_execute(ha->sdev, cmd, cmnd, 30, &info);\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nrsc->hdr_list[i].bus = ha->virt_bus;\r\nrsc->hdr_list[i].target = i;\r\nrsc->hdr_list[i].lun = 0;\r\nif (status != S_OK) {\r\nha->hdr[i].present = FALSE;\r\n} else {\r\nha->hdr[i].present = TRUE;\r\nha->hdr[i].size = info;\r\nha->hdr[i].size &= ~SECS32;\r\ngdth_eval_mapping(ha->hdr[i].size,&cyls,&hds,&secs);\r\nha->hdr[i].heads = hds;\r\nha->hdr[i].secs = secs;\r\nha->hdr[i].size = cyls * hds * secs;\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nif (status != S_OK)\r\ncontinue;\r\ncmd->Service = CACHESERVICE;\r\ncmd->OpCode = GDT_DEVTYPE;\r\nif (ha->cache_feat & GDT_64BIT)\r\ncmd->u.cache64.DeviceNo = i;\r\nelse\r\ncmd->u.cache.DeviceNo = i;\r\nstatus = __gdth_execute(ha->sdev, cmd, cmnd, 30, &info);\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->hdr[i].devtype = (status == S_OK ? (u16)info : 0);\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\ncmd->Service = CACHESERVICE;\r\ncmd->OpCode = GDT_CLUST_INFO;\r\nif (ha->cache_feat & GDT_64BIT)\r\ncmd->u.cache64.DeviceNo = i;\r\nelse\r\ncmd->u.cache.DeviceNo = i;\r\nstatus = __gdth_execute(ha->sdev, cmd, cmnd, 30, &info);\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->hdr[i].cluster_type =\r\n((status == S_OK && !shared_access) ? (u16)info : 0);\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nrsc->hdr_list[i].cluster_type = ha->hdr[i].cluster_type;\r\ncmd->Service = CACHESERVICE;\r\ncmd->OpCode = GDT_RW_ATTRIBS;\r\nif (ha->cache_feat & GDT_64BIT)\r\ncmd->u.cache64.DeviceNo = i;\r\nelse\r\ncmd->u.cache.DeviceNo = i;\r\nstatus = __gdth_execute(ha->sdev, cmd, cmnd, 30, &info);\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->hdr[i].rw_attribs = (status == S_OK ? (u16)info : 0);\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n}\r\nif (copy_to_user(arg, rsc, sizeof(gdth_ioctl_rescan)))\r\nrc = -EFAULT;\r\nelse\r\nrc = 0;\r\nfree_fail:\r\nkfree(rsc);\r\nkfree(cmd);\r\nreturn rc;\r\n}\r\nstatic int gdth_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\ngdth_ha_str *ha;\r\nScsi_Cmnd *scp;\r\nunsigned long flags;\r\nchar cmnd[MAX_COMMAND_SIZE];\r\nvoid __user *argp = (void __user *)arg;\r\nmemset(cmnd, 0xff, 12);\r\nTRACE(("gdth_ioctl() cmd 0x%x\n", cmd));\r\nswitch (cmd) {\r\ncase GDTIOCTL_CTRCNT:\r\n{\r\nint cnt = gdth_ctr_count;\r\nif (put_user(cnt, (int __user *)argp))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase GDTIOCTL_DRVERS:\r\n{\r\nint ver = (GDTH_VERSION<<8) | GDTH_SUBVERSION;\r\nif (put_user(ver, (int __user *)argp))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase GDTIOCTL_OSVERS:\r\n{\r\ngdth_ioctl_osvers osv;\r\nosv.version = (u8)(LINUX_VERSION_CODE >> 16);\r\nosv.subversion = (u8)(LINUX_VERSION_CODE >> 8);\r\nosv.revision = (u16)(LINUX_VERSION_CODE & 0xff);\r\nif (copy_to_user(argp, &osv, sizeof(gdth_ioctl_osvers)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase GDTIOCTL_CTRTYPE:\r\n{\r\ngdth_ioctl_ctrtype ctrt;\r\nif (copy_from_user(&ctrt, argp, sizeof(gdth_ioctl_ctrtype)) ||\r\n(NULL == (ha = gdth_find_ha(ctrt.ionode))))\r\nreturn -EFAULT;\r\nif (ha->type == GDT_ISA || ha->type == GDT_EISA) {\r\nctrt.type = (u8)((ha->stype>>20) - 0x10);\r\n} else {\r\nif (ha->type != GDT_PCIMPR) {\r\nctrt.type = (u8)((ha->stype<<4) + 6);\r\n} else {\r\nctrt.type =\r\n(ha->oem_id == OEM_ID_INTEL ? 0xfd : 0xfe);\r\nif (ha->stype >= 0x300)\r\nctrt.ext_type = 0x6000 | ha->pdev->subsystem_device;\r\nelse\r\nctrt.ext_type = 0x6000 | ha->stype;\r\n}\r\nctrt.device_id = ha->pdev->device;\r\nctrt.sub_device_id = ha->pdev->subsystem_device;\r\n}\r\nctrt.info = ha->brd_phys;\r\nctrt.oem_id = ha->oem_id;\r\nif (copy_to_user(argp, &ctrt, sizeof(gdth_ioctl_ctrtype)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase GDTIOCTL_GENERAL:\r\nreturn ioc_general(argp, cmnd);\r\ncase GDTIOCTL_EVENT:\r\nreturn ioc_event(argp);\r\ncase GDTIOCTL_LOCKDRV:\r\nreturn ioc_lockdrv(argp);\r\ncase GDTIOCTL_LOCKCHN:\r\n{\r\ngdth_ioctl_lockchn lchn;\r\nu8 i, j;\r\nif (copy_from_user(&lchn, argp, sizeof(gdth_ioctl_lockchn)) ||\r\n(NULL == (ha = gdth_find_ha(lchn.ionode))))\r\nreturn -EFAULT;\r\ni = lchn.channel;\r\nif (i < ha->bus_cnt) {\r\nif (lchn.lock) {\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->raw[i].lock = 1;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nfor (j = 0; j < ha->tid_cnt; ++j)\r\ngdth_wait_completion(ha, i, j);\r\n} else {\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->raw[i].lock = 0;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nfor (j = 0; j < ha->tid_cnt; ++j)\r\ngdth_next(ha);\r\n}\r\n}\r\nbreak;\r\n}\r\ncase GDTIOCTL_RESCAN:\r\nreturn ioc_rescan(argp, cmnd);\r\ncase GDTIOCTL_HDRLIST:\r\nreturn ioc_hdrlist(argp, cmnd);\r\ncase GDTIOCTL_RESET_BUS:\r\n{\r\ngdth_ioctl_reset res;\r\nint rval;\r\nif (copy_from_user(&res, argp, sizeof(gdth_ioctl_reset)) ||\r\n(NULL == (ha = gdth_find_ha(res.ionode))))\r\nreturn -EFAULT;\r\nscp = kzalloc(sizeof(*scp), GFP_KERNEL);\r\nif (!scp)\r\nreturn -ENOMEM;\r\nscp->device = ha->sdev;\r\nscp->cmd_len = 12;\r\nscp->device->channel = res.number;\r\nrval = gdth_eh_bus_reset(scp);\r\nres.status = (rval == SUCCESS ? S_OK : S_GENERR);\r\nkfree(scp);\r\nif (copy_to_user(argp, &res, sizeof(gdth_ioctl_reset)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase GDTIOCTL_RESET_DRV:\r\nreturn ioc_resetdrv(argp, cmnd);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic long gdth_unlocked_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&gdth_mutex);\r\nret = gdth_ioctl(file, cmd, arg);\r\nmutex_unlock(&gdth_mutex);\r\nreturn ret;\r\n}\r\nstatic void gdth_flush(gdth_ha_str *ha)\r\n{\r\nint i;\r\ngdth_cmd_str gdtcmd;\r\nchar cmnd[MAX_COMMAND_SIZE];\r\nmemset(cmnd, 0xff, MAX_COMMAND_SIZE);\r\nTRACE2(("gdth_flush() hanum %d\n", ha->hanum));\r\nfor (i = 0; i < MAX_HDRIVES; ++i) {\r\nif (ha->hdr[i].present) {\r\ngdtcmd.BoardNode = LOCALBOARD;\r\ngdtcmd.Service = CACHESERVICE;\r\ngdtcmd.OpCode = GDT_FLUSH;\r\nif (ha->cache_feat & GDT_64BIT) {\r\ngdtcmd.u.cache64.DeviceNo = i;\r\ngdtcmd.u.cache64.BlockNo = 1;\r\ngdtcmd.u.cache64.sg_canz = 0;\r\n} else {\r\ngdtcmd.u.cache.DeviceNo = i;\r\ngdtcmd.u.cache.BlockNo = 1;\r\ngdtcmd.u.cache.sg_canz = 0;\r\n}\r\nTRACE2(("gdth_flush(): flush ha %d drive %d\n", ha->hanum, i));\r\ngdth_execute(ha->shost, &gdtcmd, cmnd, 30, NULL);\r\n}\r\n}\r\n}\r\nstatic int gdth_slave_configure(struct scsi_device *sdev)\r\n{\r\nsdev->skip_ms_page_3f = 1;\r\nsdev->skip_ms_page_8 = 1;\r\nreturn 0;\r\n}\r\nstatic int __init gdth_isa_probe_one(u32 isa_bios)\r\n{\r\nstruct Scsi_Host *shp;\r\ngdth_ha_str *ha;\r\ndma_addr_t scratch_dma_handle = 0;\r\nint error, i;\r\nif (!gdth_search_isa(isa_bios))\r\nreturn -ENXIO;\r\nshp = scsi_host_alloc(&gdth_template, sizeof(gdth_ha_str));\r\nif (!shp)\r\nreturn -ENOMEM;\r\nha = shost_priv(shp);\r\nerror = -ENODEV;\r\nif (!gdth_init_isa(isa_bios,ha))\r\ngoto out_host_put;\r\nprintk("Configuring GDT-ISA HA at BIOS 0x%05X IRQ %u DRQ %u\n",\r\nisa_bios, ha->irq, ha->drq);\r\nerror = request_irq(ha->irq, gdth_interrupt, 0, "gdth", ha);\r\nif (error) {\r\nprintk("GDT-ISA: Unable to allocate IRQ\n");\r\ngoto out_host_put;\r\n}\r\nerror = request_dma(ha->drq, "gdth");\r\nif (error) {\r\nprintk("GDT-ISA: Unable to allocate DMA channel\n");\r\ngoto out_free_irq;\r\n}\r\nset_dma_mode(ha->drq,DMA_MODE_CASCADE);\r\nenable_dma(ha->drq);\r\nshp->unchecked_isa_dma = 1;\r\nshp->irq = ha->irq;\r\nshp->dma_channel = ha->drq;\r\nha->hanum = gdth_ctr_count++;\r\nha->shost = shp;\r\nha->pccb = &ha->cmdext;\r\nha->ccb_phys = 0L;\r\nha->pdev = NULL;\r\nerror = -ENOMEM;\r\nha->pscratch = pci_alloc_consistent(ha->pdev, GDTH_SCRATCH,\r\n&scratch_dma_handle);\r\nif (!ha->pscratch)\r\ngoto out_dec_counters;\r\nha->scratch_phys = scratch_dma_handle;\r\nha->pmsg = pci_alloc_consistent(ha->pdev, sizeof(gdth_msg_str),\r\n&scratch_dma_handle);\r\nif (!ha->pmsg)\r\ngoto out_free_pscratch;\r\nha->msg_phys = scratch_dma_handle;\r\n#ifdef INT_COAL\r\nha->coal_stat = pci_alloc_consistent(ha->pdev,\r\nsizeof(gdth_coal_status) * MAXOFFSETS,\r\n&scratch_dma_handle);\r\nif (!ha->coal_stat)\r\ngoto out_free_pmsg;\r\nha->coal_stat_phys = scratch_dma_handle;\r\n#endif\r\nha->scratch_busy = FALSE;\r\nha->req_first = NULL;\r\nha->tid_cnt = MAX_HDRIVES;\r\nif (max_ids > 0 && max_ids < ha->tid_cnt)\r\nha->tid_cnt = max_ids;\r\nfor (i = 0; i < GDTH_MAXCMDS; ++i)\r\nha->cmd_tab[i].cmnd = UNUSED_CMND;\r\nha->scan_mode = rescan ? 0x10 : 0;\r\nerror = -ENODEV;\r\nif (!gdth_search_drives(ha)) {\r\nprintk("GDT-ISA: Error during device scan\n");\r\ngoto out_free_coal_stat;\r\n}\r\nif (hdr_channel < 0 || hdr_channel > ha->bus_cnt)\r\nhdr_channel = ha->bus_cnt;\r\nha->virt_bus = hdr_channel;\r\nif (ha->cache_feat & ha->raw_feat & ha->screen_feat & GDT_64BIT)\r\nshp->max_cmd_len = 16;\r\nshp->max_id = ha->tid_cnt;\r\nshp->max_lun = MAXLUN;\r\nshp->max_channel = ha->bus_cnt;\r\nspin_lock_init(&ha->smp_lock);\r\ngdth_enable_int(ha);\r\nerror = scsi_add_host(shp, NULL);\r\nif (error)\r\ngoto out_free_coal_stat;\r\nlist_add_tail(&ha->list, &gdth_instances);\r\ngdth_timer_init();\r\nscsi_scan_host(shp);\r\nreturn 0;\r\nout_free_coal_stat:\r\n#ifdef INT_COAL\r\npci_free_consistent(ha->pdev, sizeof(gdth_coal_status) * MAXOFFSETS,\r\nha->coal_stat, ha->coal_stat_phys);\r\nout_free_pmsg:\r\n#endif\r\npci_free_consistent(ha->pdev, sizeof(gdth_msg_str),\r\nha->pmsg, ha->msg_phys);\r\nout_free_pscratch:\r\npci_free_consistent(ha->pdev, GDTH_SCRATCH,\r\nha->pscratch, ha->scratch_phys);\r\nout_dec_counters:\r\ngdth_ctr_count--;\r\nout_free_irq:\r\nfree_irq(ha->irq, ha);\r\nout_host_put:\r\nscsi_host_put(shp);\r\nreturn error;\r\n}\r\nstatic int __init gdth_eisa_probe_one(u16 eisa_slot)\r\n{\r\nstruct Scsi_Host *shp;\r\ngdth_ha_str *ha;\r\ndma_addr_t scratch_dma_handle = 0;\r\nint error, i;\r\nif (!gdth_search_eisa(eisa_slot))\r\nreturn -ENXIO;\r\nshp = scsi_host_alloc(&gdth_template, sizeof(gdth_ha_str));\r\nif (!shp)\r\nreturn -ENOMEM;\r\nha = shost_priv(shp);\r\nerror = -ENODEV;\r\nif (!gdth_init_eisa(eisa_slot,ha))\r\ngoto out_host_put;\r\nprintk("Configuring GDT-EISA HA at Slot %d IRQ %u\n",\r\neisa_slot >> 12, ha->irq);\r\nerror = request_irq(ha->irq, gdth_interrupt, 0, "gdth", ha);\r\nif (error) {\r\nprintk("GDT-EISA: Unable to allocate IRQ\n");\r\ngoto out_host_put;\r\n}\r\nshp->unchecked_isa_dma = 0;\r\nshp->irq = ha->irq;\r\nshp->dma_channel = 0xff;\r\nha->hanum = gdth_ctr_count++;\r\nha->shost = shp;\r\nTRACE2(("EISA detect Bus 0: hanum %d\n", ha->hanum));\r\nha->pccb = &ha->cmdext;\r\nha->ccb_phys = 0L;\r\nerror = -ENOMEM;\r\nha->pdev = NULL;\r\nha->pscratch = pci_alloc_consistent(ha->pdev, GDTH_SCRATCH,\r\n&scratch_dma_handle);\r\nif (!ha->pscratch)\r\ngoto out_free_irq;\r\nha->scratch_phys = scratch_dma_handle;\r\nha->pmsg = pci_alloc_consistent(ha->pdev, sizeof(gdth_msg_str),\r\n&scratch_dma_handle);\r\nif (!ha->pmsg)\r\ngoto out_free_pscratch;\r\nha->msg_phys = scratch_dma_handle;\r\n#ifdef INT_COAL\r\nha->coal_stat = pci_alloc_consistent(ha->pdev,\r\nsizeof(gdth_coal_status) * MAXOFFSETS,\r\n&scratch_dma_handle);\r\nif (!ha->coal_stat)\r\ngoto out_free_pmsg;\r\nha->coal_stat_phys = scratch_dma_handle;\r\n#endif\r\nha->ccb_phys = pci_map_single(ha->pdev,ha->pccb,\r\nsizeof(gdth_cmd_str), PCI_DMA_BIDIRECTIONAL);\r\nif (!ha->ccb_phys)\r\ngoto out_free_coal_stat;\r\nha->scratch_busy = FALSE;\r\nha->req_first = NULL;\r\nha->tid_cnt = MAX_HDRIVES;\r\nif (max_ids > 0 && max_ids < ha->tid_cnt)\r\nha->tid_cnt = max_ids;\r\nfor (i = 0; i < GDTH_MAXCMDS; ++i)\r\nha->cmd_tab[i].cmnd = UNUSED_CMND;\r\nha->scan_mode = rescan ? 0x10 : 0;\r\nif (!gdth_search_drives(ha)) {\r\nprintk("GDT-EISA: Error during device scan\n");\r\nerror = -ENODEV;\r\ngoto out_free_ccb_phys;\r\n}\r\nif (hdr_channel < 0 || hdr_channel > ha->bus_cnt)\r\nhdr_channel = ha->bus_cnt;\r\nha->virt_bus = hdr_channel;\r\nif (ha->cache_feat & ha->raw_feat & ha->screen_feat & GDT_64BIT)\r\nshp->max_cmd_len = 16;\r\nshp->max_id = ha->tid_cnt;\r\nshp->max_lun = MAXLUN;\r\nshp->max_channel = ha->bus_cnt;\r\nspin_lock_init(&ha->smp_lock);\r\ngdth_enable_int(ha);\r\nerror = scsi_add_host(shp, NULL);\r\nif (error)\r\ngoto out_free_ccb_phys;\r\nlist_add_tail(&ha->list, &gdth_instances);\r\ngdth_timer_init();\r\nscsi_scan_host(shp);\r\nreturn 0;\r\nout_free_ccb_phys:\r\npci_unmap_single(ha->pdev,ha->ccb_phys, sizeof(gdth_cmd_str),\r\nPCI_DMA_BIDIRECTIONAL);\r\nout_free_coal_stat:\r\n#ifdef INT_COAL\r\npci_free_consistent(ha->pdev, sizeof(gdth_coal_status) * MAXOFFSETS,\r\nha->coal_stat, ha->coal_stat_phys);\r\nout_free_pmsg:\r\n#endif\r\npci_free_consistent(ha->pdev, sizeof(gdth_msg_str),\r\nha->pmsg, ha->msg_phys);\r\nout_free_pscratch:\r\npci_free_consistent(ha->pdev, GDTH_SCRATCH,\r\nha->pscratch, ha->scratch_phys);\r\nout_free_irq:\r\nfree_irq(ha->irq, ha);\r\ngdth_ctr_count--;\r\nout_host_put:\r\nscsi_host_put(shp);\r\nreturn error;\r\n}\r\nstatic int gdth_pci_probe_one(gdth_pci_str *pcistr, gdth_ha_str **ha_out)\r\n{\r\nstruct Scsi_Host *shp;\r\ngdth_ha_str *ha;\r\ndma_addr_t scratch_dma_handle = 0;\r\nint error, i;\r\nstruct pci_dev *pdev = pcistr->pdev;\r\n*ha_out = NULL;\r\nshp = scsi_host_alloc(&gdth_template, sizeof(gdth_ha_str));\r\nif (!shp)\r\nreturn -ENOMEM;\r\nha = shost_priv(shp);\r\nerror = -ENODEV;\r\nif (!gdth_init_pci(pdev, pcistr, ha))\r\ngoto out_host_put;\r\nprintk("Configuring GDT-PCI HA at %d/%d IRQ %u\n",\r\npdev->bus->number,\r\nPCI_SLOT(pdev->devfn),\r\nha->irq);\r\nerror = request_irq(ha->irq, gdth_interrupt,\r\nIRQF_SHARED, "gdth", ha);\r\nif (error) {\r\nprintk("GDT-PCI: Unable to allocate IRQ\n");\r\ngoto out_host_put;\r\n}\r\nshp->unchecked_isa_dma = 0;\r\nshp->irq = ha->irq;\r\nshp->dma_channel = 0xff;\r\nha->hanum = gdth_ctr_count++;\r\nha->shost = shp;\r\nha->pccb = &ha->cmdext;\r\nha->ccb_phys = 0L;\r\nerror = -ENOMEM;\r\nha->pscratch = pci_alloc_consistent(ha->pdev, GDTH_SCRATCH,\r\n&scratch_dma_handle);\r\nif (!ha->pscratch)\r\ngoto out_free_irq;\r\nha->scratch_phys = scratch_dma_handle;\r\nha->pmsg = pci_alloc_consistent(ha->pdev, sizeof(gdth_msg_str),\r\n&scratch_dma_handle);\r\nif (!ha->pmsg)\r\ngoto out_free_pscratch;\r\nha->msg_phys = scratch_dma_handle;\r\n#ifdef INT_COAL\r\nha->coal_stat = pci_alloc_consistent(ha->pdev,\r\nsizeof(gdth_coal_status) * MAXOFFSETS,\r\n&scratch_dma_handle);\r\nif (!ha->coal_stat)\r\ngoto out_free_pmsg;\r\nha->coal_stat_phys = scratch_dma_handle;\r\n#endif\r\nha->scratch_busy = FALSE;\r\nha->req_first = NULL;\r\nha->tid_cnt = pdev->device >= 0x200 ? MAXID : MAX_HDRIVES;\r\nif (max_ids > 0 && max_ids < ha->tid_cnt)\r\nha->tid_cnt = max_ids;\r\nfor (i = 0; i < GDTH_MAXCMDS; ++i)\r\nha->cmd_tab[i].cmnd = UNUSED_CMND;\r\nha->scan_mode = rescan ? 0x10 : 0;\r\nerror = -ENODEV;\r\nif (!gdth_search_drives(ha)) {\r\nprintk("GDT-PCI %d: Error during device scan\n", ha->hanum);\r\ngoto out_free_coal_stat;\r\n}\r\nif (hdr_channel < 0 || hdr_channel > ha->bus_cnt)\r\nhdr_channel = ha->bus_cnt;\r\nha->virt_bus = hdr_channel;\r\nif (!(ha->cache_feat & ha->raw_feat & ha->screen_feat & GDT_64BIT) ||\r\n!ha->dma64_support) {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_WARNING "GDT-PCI %d: "\r\n"Unable to set 32-bit DMA\n", ha->hanum);\r\ngoto out_free_coal_stat;\r\n}\r\n} else {\r\nshp->max_cmd_len = 16;\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\nprintk("GDT-PCI %d: 64-bit DMA enabled\n", ha->hanum);\r\n} else if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_WARNING "GDT-PCI %d: "\r\n"Unable to set 64/32-bit DMA\n", ha->hanum);\r\ngoto out_free_coal_stat;\r\n}\r\n}\r\nshp->max_id = ha->tid_cnt;\r\nshp->max_lun = MAXLUN;\r\nshp->max_channel = ha->bus_cnt;\r\nspin_lock_init(&ha->smp_lock);\r\ngdth_enable_int(ha);\r\nerror = scsi_add_host(shp, &pdev->dev);\r\nif (error)\r\ngoto out_free_coal_stat;\r\nlist_add_tail(&ha->list, &gdth_instances);\r\npci_set_drvdata(ha->pdev, ha);\r\ngdth_timer_init();\r\nscsi_scan_host(shp);\r\n*ha_out = ha;\r\nreturn 0;\r\nout_free_coal_stat:\r\n#ifdef INT_COAL\r\npci_free_consistent(ha->pdev, sizeof(gdth_coal_status) * MAXOFFSETS,\r\nha->coal_stat, ha->coal_stat_phys);\r\nout_free_pmsg:\r\n#endif\r\npci_free_consistent(ha->pdev, sizeof(gdth_msg_str),\r\nha->pmsg, ha->msg_phys);\r\nout_free_pscratch:\r\npci_free_consistent(ha->pdev, GDTH_SCRATCH,\r\nha->pscratch, ha->scratch_phys);\r\nout_free_irq:\r\nfree_irq(ha->irq, ha);\r\ngdth_ctr_count--;\r\nout_host_put:\r\nscsi_host_put(shp);\r\nreturn error;\r\n}\r\nstatic void gdth_remove_one(gdth_ha_str *ha)\r\n{\r\nstruct Scsi_Host *shp = ha->shost;\r\nTRACE2(("gdth_remove_one()\n"));\r\nscsi_remove_host(shp);\r\ngdth_flush(ha);\r\nif (ha->sdev) {\r\nscsi_free_host_dev(ha->sdev);\r\nha->sdev = NULL;\r\n}\r\nif (shp->irq)\r\nfree_irq(shp->irq,ha);\r\n#ifdef CONFIG_ISA\r\nif (shp->dma_channel != 0xff)\r\nfree_dma(shp->dma_channel);\r\n#endif\r\n#ifdef INT_COAL\r\nif (ha->coal_stat)\r\npci_free_consistent(ha->pdev, sizeof(gdth_coal_status) *\r\nMAXOFFSETS, ha->coal_stat, ha->coal_stat_phys);\r\n#endif\r\nif (ha->pscratch)\r\npci_free_consistent(ha->pdev, GDTH_SCRATCH,\r\nha->pscratch, ha->scratch_phys);\r\nif (ha->pmsg)\r\npci_free_consistent(ha->pdev, sizeof(gdth_msg_str),\r\nha->pmsg, ha->msg_phys);\r\nif (ha->ccb_phys)\r\npci_unmap_single(ha->pdev,ha->ccb_phys,\r\nsizeof(gdth_cmd_str),PCI_DMA_BIDIRECTIONAL);\r\nscsi_host_put(shp);\r\n}\r\nstatic int gdth_halt(struct notifier_block *nb, unsigned long event, void *buf)\r\n{\r\ngdth_ha_str *ha;\r\nTRACE2(("gdth_halt() event %d\n", (int)event));\r\nif (event != SYS_RESTART && event != SYS_HALT && event != SYS_POWER_OFF)\r\nreturn NOTIFY_DONE;\r\nlist_for_each_entry(ha, &gdth_instances, list)\r\ngdth_flush(ha);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init gdth_init(void)\r\n{\r\nif (disable) {\r\nprintk("GDT-HA: Controller driver disabled from"\r\n" command line !\n");\r\nreturn 0;\r\n}\r\nprintk("GDT-HA: Storage RAID Controller Driver. Version: %s\n",\r\nGDTH_VERSION_STR);\r\ngdth_polling = TRUE;\r\ngdth_clear_events();\r\ninit_timer(&gdth_timer);\r\nif (probe_eisa_isa) {\r\n#ifdef CONFIG_ISA\r\nu32 isa_bios;\r\nfor (isa_bios = 0xc8000UL; isa_bios <= 0xd8000UL;\r\nisa_bios += 0x8000UL)\r\ngdth_isa_probe_one(isa_bios);\r\n#endif\r\n#ifdef CONFIG_EISA\r\n{\r\nu16 eisa_slot;\r\nfor (eisa_slot = 0x1000; eisa_slot <= 0x8000;\r\neisa_slot += 0x1000)\r\ngdth_eisa_probe_one(eisa_slot);\r\n}\r\n#endif\r\n}\r\n#ifdef CONFIG_PCI\r\nif (pci_register_driver(&gdth_pci_driver)) {\r\ngdth_ha_str *ha;\r\nlist_for_each_entry(ha, &gdth_instances, list)\r\ngdth_remove_one(ha);\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nTRACE2(("gdth_detect() %d controller detected\n", gdth_ctr_count));\r\nmajor = register_chrdev(0,"gdth", &gdth_fops);\r\nregister_reboot_notifier(&gdth_notifier);\r\ngdth_polling = FALSE;\r\nreturn 0;\r\n}\r\nstatic void __exit gdth_exit(void)\r\n{\r\ngdth_ha_str *ha;\r\nunregister_chrdev(major, "gdth");\r\nunregister_reboot_notifier(&gdth_notifier);\r\n#ifdef GDTH_STATISTICS\r\ndel_timer_sync(&gdth_timer);\r\n#endif\r\n#ifdef CONFIG_PCI\r\npci_unregister_driver(&gdth_pci_driver);\r\n#endif\r\nlist_for_each_entry(ha, &gdth_instances, list)\r\ngdth_remove_one(ha);\r\n}
