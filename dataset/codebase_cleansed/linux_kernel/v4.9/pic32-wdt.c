static inline bool pic32_wdt_is_win_enabled(struct pic32_wdt *wdt)\r\n{\r\nreturn !!(readl(wdt->regs + WDTCON_REG) & WDTCON_WIN_EN);\r\n}\r\nstatic inline u32 pic32_wdt_get_post_scaler(struct pic32_wdt *wdt)\r\n{\r\nu32 v = readl(wdt->regs + WDTCON_REG);\r\nreturn (v >> WDTCON_RMPS_SHIFT) & WDTCON_RMPS_MASK;\r\n}\r\nstatic inline u32 pic32_wdt_get_clk_id(struct pic32_wdt *wdt)\r\n{\r\nu32 v = readl(wdt->regs + WDTCON_REG);\r\nreturn (v >> WDTCON_RMCS_SHIFT) & WDTCON_RMCS_MASK;\r\n}\r\nstatic int pic32_wdt_bootstatus(struct pic32_wdt *wdt)\r\n{\r\nu32 v = readl(wdt->rst_base);\r\nwritel(RESETCON_WDT_TIMEOUT, PIC32_CLR(wdt->rst_base));\r\nreturn v & RESETCON_WDT_TIMEOUT;\r\n}\r\nstatic u32 pic32_wdt_get_timeout_secs(struct pic32_wdt *wdt, struct device *dev)\r\n{\r\nunsigned long rate;\r\nu32 period, ps, terminal;\r\nrate = clk_get_rate(wdt->clk);\r\ndev_dbg(dev, "wdt: clk_id %d, clk_rate %lu (prescale)\n",\r\npic32_wdt_get_clk_id(wdt), rate);\r\nrate >>= 5;\r\nif (!rate)\r\nreturn 0;\r\nps = pic32_wdt_get_post_scaler(wdt);\r\nterminal = BIT(ps);\r\nperiod = terminal / rate;\r\ndev_dbg(dev,\r\n"wdt: clk_rate %lu (postscale) / terminal %d, timeout %dsec\n",\r\nrate, terminal, period);\r\nreturn period;\r\n}\r\nstatic void pic32_wdt_keepalive(struct pic32_wdt *wdt)\r\n{\r\nwritew(WDTCON_CLR_KEY, wdt->regs + WDTCON_REG + 2);\r\n}\r\nstatic int pic32_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct pic32_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwritel(WDTCON_ON, PIC32_SET(wdt->regs + WDTCON_REG));\r\npic32_wdt_keepalive(wdt);\r\nreturn 0;\r\n}\r\nstatic int pic32_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct pic32_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwritel(WDTCON_ON, PIC32_CLR(wdt->regs + WDTCON_REG));\r\nnop();\r\nreturn 0;\r\n}\r\nstatic int pic32_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct pic32_wdt *wdt = watchdog_get_drvdata(wdd);\r\npic32_wdt_keepalive(wdt);\r\nreturn 0;\r\n}\r\nstatic int pic32_wdt_drv_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct watchdog_device *wdd = &pic32_wdd;\r\nstruct pic32_wdt *wdt;\r\nstruct resource *mem;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(wdt->regs))\r\nreturn PTR_ERR(wdt->regs);\r\nwdt->rst_base = devm_ioremap(&pdev->dev, PIC32_BASE_RESET, 0x10);\r\nif (!wdt->rst_base)\r\nreturn -ENOMEM;\r\nwdt->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(wdt->clk)) {\r\ndev_err(&pdev->dev, "clk not found\n");\r\nreturn PTR_ERR(wdt->clk);\r\n}\r\nret = clk_prepare_enable(wdt->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk enable failed\n");\r\nreturn ret;\r\n}\r\nif (pic32_wdt_is_win_enabled(wdt)) {\r\ndev_err(&pdev->dev, "windowed-clear mode is not supported.\n");\r\nret = -ENODEV;\r\ngoto out_disable_clk;\r\n}\r\nwdd->timeout = pic32_wdt_get_timeout_secs(wdt, &pdev->dev);\r\nif (!wdd->timeout) {\r\ndev_err(&pdev->dev,\r\n"failed to read watchdog register timeout\n");\r\nret = -EINVAL;\r\ngoto out_disable_clk;\r\n}\r\ndev_info(&pdev->dev, "timeout %d\n", wdd->timeout);\r\nwdd->bootstatus = pic32_wdt_bootstatus(wdt) ? WDIOF_CARDRESET : 0;\r\nwatchdog_set_nowayout(wdd, WATCHDOG_NOWAYOUT);\r\nwatchdog_set_drvdata(wdd, wdt);\r\nret = watchdog_register_device(wdd);\r\nif (ret) {\r\ndev_err(&pdev->dev, "watchdog register failed, err %d\n", ret);\r\ngoto out_disable_clk;\r\n}\r\nplatform_set_drvdata(pdev, wdd);\r\nreturn 0;\r\nout_disable_clk:\r\nclk_disable_unprepare(wdt->clk);\r\nreturn ret;\r\n}\r\nstatic int pic32_wdt_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct watchdog_device *wdd = platform_get_drvdata(pdev);\r\nstruct pic32_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwatchdog_unregister_device(wdd);\r\nclk_disable_unprepare(wdt->clk);\r\nreturn 0;\r\n}
