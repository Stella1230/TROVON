static int mt2701_dai_num_to_i2s(struct mtk_base_afe *afe, int num)\r\n{\r\nint val = num - MT2701_IO_I2S;\r\nif (val < 0 || val >= MT2701_I2S_NUM) {\r\ndev_err(afe->dev, "%s, num not available, num %d, val %d\n",\r\n__func__, num, val);\r\nreturn -EINVAL;\r\n}\r\nreturn val;\r\n}\r\nstatic int mt2701_afe_i2s_fs(unsigned int sample_rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mt2701_afe_i2s_rates); i++)\r\nif (mt2701_afe_i2s_rates[i].rate == sample_rate)\r\nreturn mt2701_afe_i2s_rates[i].regvalue;\r\nreturn -EINVAL;\r\n}\r\nstatic int mt2701_afe_i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt2701_afe_private *afe_priv = afe->platform_priv;\r\nint i2s_num = mt2701_dai_num_to_i2s(afe, dai->id);\r\nint clk_num = MT2701_AUD_AUD_I2S1_MCLK + i2s_num;\r\nint ret = 0;\r\nif (i2s_num < 0)\r\nreturn i2s_num;\r\nret = clk_prepare_enable(afe_priv->clocks[clk_num]);\r\nif (ret)\r\ndev_err(afe->dev, "Failed to enable mclk for I2S: %d\n",\r\ni2s_num);\r\nreturn ret;\r\n}\r\nstatic int mt2701_afe_i2s_path_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai,\r\nint dir_invert)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt2701_afe_private *afe_priv = afe->platform_priv;\r\nint i2s_num = mt2701_dai_num_to_i2s(afe, dai->id);\r\nstruct mt2701_i2s_path *i2s_path;\r\nconst struct mt2701_i2s_data *i2s_data;\r\nint stream_dir = substream->stream;\r\nif (i2s_num < 0)\r\nreturn i2s_num;\r\ni2s_path = &afe_priv->i2s_path[i2s_num];\r\nif (dir_invert) {\r\nif (stream_dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nstream_dir = SNDRV_PCM_STREAM_CAPTURE;\r\nelse\r\nstream_dir = SNDRV_PCM_STREAM_PLAYBACK;\r\n}\r\ni2s_data = i2s_path->i2s_data[stream_dir];\r\ni2s_path->on[stream_dir]--;\r\nif (i2s_path->on[stream_dir] < 0) {\r\ndev_warn(afe->dev, "i2s_path->on: %d, dir: %d\n",\r\ni2s_path->on[stream_dir], stream_dir);\r\ni2s_path->on[stream_dir] = 0;\r\n}\r\nif (i2s_path->on[stream_dir])\r\nreturn 0;\r\nregmap_update_bits(afe->regmap, i2s_data->i2s_ctrl_reg,\r\nASYS_I2S_CON_I2S_EN, 0);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON4,\r\n1 << i2s_data->i2s_pwn_shift,\r\n1 << i2s_data->i2s_pwn_shift);\r\nreturn 0;\r\n}\r\nstatic void mt2701_afe_i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt2701_afe_private *afe_priv = afe->platform_priv;\r\nint i2s_num = mt2701_dai_num_to_i2s(afe, dai->id);\r\nstruct mt2701_i2s_path *i2s_path;\r\nint clk_num = MT2701_AUD_AUD_I2S1_MCLK + i2s_num;\r\nif (i2s_num < 0)\r\nreturn;\r\ni2s_path = &afe_priv->i2s_path[i2s_num];\r\nif (i2s_path->occupied[substream->stream])\r\ni2s_path->occupied[substream->stream] = 0;\r\nelse\r\ngoto I2S_UNSTART;\r\nmt2701_afe_i2s_path_shutdown(substream, dai, 0);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nmt2701_afe_i2s_path_shutdown(substream, dai, 1);\r\nI2S_UNSTART:\r\nclk_disable_unprepare(afe_priv->clocks[clk_num]);\r\n}\r\nstatic int mt2701_i2s_path_prepare_enable(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai,\r\nint dir_invert)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt2701_afe_private *afe_priv = afe->platform_priv;\r\nint i2s_num = mt2701_dai_num_to_i2s(afe, dai->id);\r\nstruct mt2701_i2s_path *i2s_path;\r\nconst struct mt2701_i2s_data *i2s_data;\r\nstruct snd_pcm_runtime * const runtime = substream->runtime;\r\nint reg, fs, w_len = 1;\r\nint stream_dir = substream->stream;\r\nunsigned int mask = 0, val = 0;\r\nif (i2s_num < 0)\r\nreturn i2s_num;\r\ni2s_path = &afe_priv->i2s_path[i2s_num];\r\nif (dir_invert) {\r\nif (stream_dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nstream_dir = SNDRV_PCM_STREAM_CAPTURE;\r\nelse\r\nstream_dir = SNDRV_PCM_STREAM_PLAYBACK;\r\n}\r\ni2s_data = i2s_path->i2s_data[stream_dir];\r\ni2s_path->on[stream_dir]++;\r\nif (i2s_path->on[stream_dir] != 1)\r\nreturn 0;\r\nfs = mt2701_afe_i2s_fs(runtime->rate);\r\nmask = ASYS_I2S_CON_FS |\r\nASYS_I2S_CON_I2S_COUPLE_MODE |\r\nASYS_I2S_CON_I2S_MODE |\r\nASYS_I2S_CON_WIDE_MODE;\r\nval = ASYS_I2S_CON_FS_SET(fs) |\r\nASYS_I2S_CON_I2S_MODE |\r\nASYS_I2S_CON_WIDE_MODE_SET(w_len);\r\nif (stream_dir == SNDRV_PCM_STREAM_CAPTURE) {\r\nmask |= ASYS_I2S_IN_PHASE_FIX;\r\nval |= ASYS_I2S_IN_PHASE_FIX;\r\n}\r\nregmap_update_bits(afe->regmap, i2s_data->i2s_ctrl_reg, mask, val);\r\nif (stream_dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nreg = ASMO_TIMING_CON1;\r\nelse\r\nreg = ASMI_TIMING_CON1;\r\nregmap_update_bits(afe->regmap, reg,\r\ni2s_data->i2s_asrc_fs_mask\r\n<< i2s_data->i2s_asrc_fs_shift,\r\nfs << i2s_data->i2s_asrc_fs_shift);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON4,\r\n1 << i2s_data->i2s_pwn_shift,\r\n0 << i2s_data->i2s_pwn_shift);\r\nregmap_update_bits(afe->regmap, i2s_data->i2s_ctrl_reg,\r\nASYS_I2S_CON_RESET, ASYS_I2S_CON_RESET);\r\nudelay(1);\r\nregmap_update_bits(afe->regmap, i2s_data->i2s_ctrl_reg,\r\nASYS_I2S_CON_RESET, 0);\r\nudelay(1);\r\nregmap_update_bits(afe->regmap, i2s_data->i2s_ctrl_reg,\r\nASYS_I2S_CON_I2S_EN, ASYS_I2S_CON_I2S_EN);\r\nreturn 0;\r\n}\r\nstatic int mt2701_afe_i2s_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint clk_domain;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt2701_afe_private *afe_priv = afe->platform_priv;\r\nint i2s_num = mt2701_dai_num_to_i2s(afe, dai->id);\r\nstruct mt2701_i2s_path *i2s_path;\r\nint mclk_rate;\r\nif (i2s_num < 0)\r\nreturn i2s_num;\r\ni2s_path = &afe_priv->i2s_path[i2s_num];\r\nmclk_rate = i2s_path->mclk_rate;\r\nif (i2s_path->occupied[substream->stream])\r\nreturn -EBUSY;\r\ni2s_path->occupied[substream->stream] = 1;\r\nif (MT2701_PLL_DOMAIN_0_RATE % mclk_rate == 0) {\r\nclk_domain = 0;\r\n} else if (MT2701_PLL_DOMAIN_1_RATE % mclk_rate == 0) {\r\nclk_domain = 1;\r\n} else {\r\ndev_err(dai->dev, "%s() bad mclk rate %d\n",\r\n__func__, mclk_rate);\r\nreturn -EINVAL;\r\n}\r\nmt2701_mclk_configuration(afe, i2s_num, clk_domain, mclk_rate);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmt2701_i2s_path_prepare_enable(substream, dai, 0);\r\n} else {\r\nmt2701_i2s_path_prepare_enable(substream, dai, 1);\r\nmt2701_i2s_path_prepare_enable(substream, dai, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt2701_afe_i2s_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct mtk_base_afe *afe = dev_get_drvdata(dai->dev);\r\nstruct mt2701_afe_private *afe_priv = afe->platform_priv;\r\nint i2s_num = mt2701_dai_num_to_i2s(afe, dai->id);\r\nif (i2s_num < 0)\r\nreturn i2s_num;\r\nif (dir == SND_SOC_CLOCK_IN) {\r\ndev_warn(dai->dev,\r\n"%s() warning: mt2701 doesn't support mclk input\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nafe_priv->i2s_path[i2s_num].mclk_rate = freq;\r\nreturn 0;\r\n}\r\nstatic int mt2701_btmrg_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt2701_afe_private *afe_priv = afe->platform_priv;\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON4,\r\nAUDIO_TOP_CON4_PDN_MRGIF, 0);\r\nafe_priv->mrg_enable[substream->stream] = 1;\r\nreturn 0;\r\n}\r\nstatic int mt2701_btmrg_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nint stream_fs;\r\nu32 val, msk;\r\nstream_fs = params_rate(params);\r\nif ((stream_fs != 8000) && (stream_fs != 16000)) {\r\ndev_err(afe->dev, "%s() btmgr not supprt this stream_fs %d\n",\r\n__func__, stream_fs);\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(afe->regmap, AFE_MRGIF_CON,\r\nAFE_MRGIF_CON_I2S_MODE_MASK,\r\nAFE_MRGIF_CON_I2S_MODE_32K);\r\nval = AFE_DAIBT_CON0_BT_FUNC_EN | AFE_DAIBT_CON0_BT_FUNC_RDY\r\n| AFE_DAIBT_CON0_MRG_USE;\r\nmsk = val;\r\nif (stream_fs == 16000)\r\nval |= AFE_DAIBT_CON0_BT_WIDE_MODE_EN;\r\nmsk |= AFE_DAIBT_CON0_BT_WIDE_MODE_EN;\r\nregmap_update_bits(afe->regmap, AFE_DAIBT_CON0, msk, val);\r\nregmap_update_bits(afe->regmap, AFE_DAIBT_CON0,\r\nAFE_DAIBT_CON0_DAIBT_EN,\r\nAFE_DAIBT_CON0_DAIBT_EN);\r\nregmap_update_bits(afe->regmap, AFE_MRGIF_CON,\r\nAFE_MRGIF_CON_MRG_I2S_EN,\r\nAFE_MRGIF_CON_MRG_I2S_EN);\r\nregmap_update_bits(afe->regmap, AFE_MRGIF_CON,\r\nAFE_MRGIF_CON_MRG_EN,\r\nAFE_MRGIF_CON_MRG_EN);\r\nreturn 0;\r\n}\r\nstatic void mt2701_btmrg_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt2701_afe_private *afe_priv = afe->platform_priv;\r\nif (!afe_priv->mrg_enable[!substream->stream]) {\r\nregmap_update_bits(afe->regmap, AFE_DAIBT_CON0,\r\nAFE_DAIBT_CON0_DAIBT_EN, 0);\r\nregmap_update_bits(afe->regmap, AFE_MRGIF_CON,\r\nAFE_MRGIF_CON_MRG_EN, 0);\r\nregmap_update_bits(afe->regmap, AFE_MRGIF_CON,\r\nAFE_MRGIF_CON_MRG_I2S_EN, 0);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON4,\r\nAUDIO_TOP_CON4_PDN_MRGIF,\r\nAUDIO_TOP_CON4_PDN_MRGIF);\r\n}\r\nafe_priv->mrg_enable[substream->stream] = 0;\r\n}\r\nstatic int mt2701_simple_fe_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nint stream_dir = substream->stream;\r\nint memif_num = rtd->cpu_dai->id;\r\nstruct mtk_base_afe_memif *memif_tmp;\r\nif (stream_dir == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmemif_tmp = &afe->memif[MT2701_MEMIF_DLM];\r\nif (memif_tmp->substream) {\r\ndev_warn(afe->dev, "%s memif is not available, stream_dir %d, memif_num %d\n",\r\n__func__, stream_dir, memif_num);\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn mtk_afe_fe_startup(substream, dai);\r\n}\r\nstatic int mt2701_simple_fe_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nint stream_dir = substream->stream;\r\nif (stream_dir == SNDRV_PCM_STREAM_PLAYBACK) {\r\nregmap_update_bits(afe->regmap,\r\nAFE_MEMIF_PBUF_SIZE,\r\nAFE_MEMIF_PBUF_SIZE_DLM_MASK,\r\nAFE_MEMIF_PBUF_SIZE_PAIR_INTERLEAVE);\r\n}\r\nreturn mtk_afe_fe_hw_params(substream, params, dai);\r\n}\r\nstatic int mt2701_dlm_fe_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_base_afe_memif *memif_tmp;\r\nconst struct mtk_base_memif_data *memif_data;\r\nint i;\r\nfor (i = MT2701_MEMIF_DL1; i < MT2701_MEMIF_DL_SINGLE_NUM; ++i) {\r\nmemif_tmp = &afe->memif[i];\r\nif (memif_tmp->substream)\r\nreturn -EBUSY;\r\n}\r\nfor (i = MT2701_MEMIF_DL1; i < MT2701_MEMIF_DL_SINGLE_NUM; ++i) {\r\nmemif_data = afe->memif[i].data;\r\nregmap_update_bits(afe->regmap,\r\nmemif_data->agent_disable_reg,\r\n1 << memif_data->agent_disable_shift,\r\n0 << memif_data->agent_disable_shift);\r\n}\r\nreturn mtk_afe_fe_startup(substream, dai);\r\n}\r\nstatic void mt2701_dlm_fe_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nconst struct mtk_base_memif_data *memif_data;\r\nint i;\r\nfor (i = MT2701_MEMIF_DL1; i < MT2701_MEMIF_DL_SINGLE_NUM; ++i) {\r\nmemif_data = afe->memif[i].data;\r\nregmap_update_bits(afe->regmap,\r\nmemif_data->agent_disable_reg,\r\n1 << memif_data->agent_disable_shift,\r\n1 << memif_data->agent_disable_shift);\r\n}\r\nreturn mtk_afe_fe_shutdown(substream, dai);\r\n}\r\nstatic int mt2701_dlm_fe_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nint channels = params_channels(params);\r\nregmap_update_bits(afe->regmap,\r\nAFE_MEMIF_PBUF_SIZE,\r\nAFE_MEMIF_PBUF_SIZE_DLM_MASK,\r\nAFE_MEMIF_PBUF_SIZE_FULL_INTERLEAVE);\r\nregmap_update_bits(afe->regmap,\r\nAFE_MEMIF_PBUF_SIZE,\r\nAFE_MEMIF_PBUF_SIZE_DLM_BYTE_MASK,\r\nAFE_MEMIF_PBUF_SIZE_DLM_32BYTES);\r\nregmap_update_bits(afe->regmap,\r\nAFE_MEMIF_PBUF_SIZE,\r\nAFE_MEMIF_PBUF_SIZE_DLM_CH_MASK,\r\nAFE_MEMIF_PBUF_SIZE_DLM_CH(channels));\r\nreturn mtk_afe_fe_hw_params(substream, params, dai);\r\n}\r\nstatic int mt2701_dlm_fe_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_base_afe_memif *memif_tmp = &afe->memif[MT2701_MEMIF_DL1];\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nregmap_update_bits(afe->regmap, memif_tmp->data->enable_reg,\r\n1 << memif_tmp->data->enable_shift,\r\n1 << memif_tmp->data->enable_shift);\r\nmtk_afe_fe_trigger(substream, cmd, dai);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nmtk_afe_fe_trigger(substream, cmd, dai);\r\nregmap_update_bits(afe->regmap, memif_tmp->data->enable_reg,\r\n1 << memif_tmp->data->enable_shift, 0);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mt2701_memif_fs(struct snd_pcm_substream *substream,\r\nunsigned int rate)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nint fs;\r\nif (rtd->cpu_dai->id != MT2701_MEMIF_ULBT)\r\nfs = mt2701_afe_i2s_fs(rate);\r\nelse\r\nfs = (rate == 16000 ? 1 : 0);\r\nreturn fs;\r\n}\r\nstatic int mt2701_irq_fs(struct snd_pcm_substream *substream, unsigned int rate)\r\n{\r\nreturn mt2701_afe_i2s_fs(rate);\r\n}\r\nstatic irqreturn_t mt2701_asys_isr(int irq_id, void *dev)\r\n{\r\nint id;\r\nstruct mtk_base_afe *afe = dev;\r\nstruct mtk_base_afe_memif *memif;\r\nstruct mtk_base_afe_irq *irq;\r\nu32 status;\r\nregmap_read(afe->regmap, ASYS_IRQ_STATUS, &status);\r\nregmap_write(afe->regmap, ASYS_IRQ_CLR, status);\r\nfor (id = 0; id < MT2701_MEMIF_NUM; ++id) {\r\nmemif = &afe->memif[id];\r\nif (memif->irq_usage < 0)\r\ncontinue;\r\nirq = &afe->irqs[memif->irq_usage];\r\nif (status & 1 << (irq->irq_data->irq_clr_shift))\r\nsnd_pcm_period_elapsed(memif->substream);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mt2701_afe_runtime_suspend(struct device *dev)\r\n{\r\nstruct mtk_base_afe *afe = dev_get_drvdata(dev);\r\nmt2701_afe_disable_clock(afe);\r\nreturn 0;\r\n}\r\nstatic int mt2701_afe_runtime_resume(struct device *dev)\r\n{\r\nstruct mtk_base_afe *afe = dev_get_drvdata(dev);\r\nreturn mt2701_afe_enable_clock(afe);\r\n}\r\nstatic int mt2701_afe_pcm_dev_probe(struct platform_device *pdev)\r\n{\r\nint ret, i;\r\nunsigned int irq_id;\r\nstruct mtk_base_afe *afe;\r\nstruct mt2701_afe_private *afe_priv;\r\nstruct resource *res;\r\nstruct device *dev;\r\nret = 0;\r\nafe = devm_kzalloc(&pdev->dev, sizeof(*afe), GFP_KERNEL);\r\nif (!afe)\r\nreturn -ENOMEM;\r\nafe->platform_priv = devm_kzalloc(&pdev->dev, sizeof(*afe_priv),\r\nGFP_KERNEL);\r\nif (!afe->platform_priv)\r\nreturn -ENOMEM;\r\nafe_priv = afe->platform_priv;\r\nafe->dev = &pdev->dev;\r\ndev = afe->dev;\r\nirq_id = platform_get_irq(pdev, 0);\r\nif (!irq_id) {\r\ndev_err(dev, "%s no irq found\n", dev->of_node->name);\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(dev, irq_id, mt2701_asys_isr,\r\nIRQF_TRIGGER_NONE, "asys-isr", (void *)afe);\r\nif (ret) {\r\ndev_err(dev, "could not request_irq for asys-isr\n");\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nafe->base_addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(afe->base_addr))\r\nreturn PTR_ERR(afe->base_addr);\r\nafe->regmap = devm_regmap_init_mmio(&pdev->dev, afe->base_addr,\r\n&mt2701_afe_regmap_config);\r\nif (IS_ERR(afe->regmap))\r\nreturn PTR_ERR(afe->regmap);\r\nmutex_init(&afe->irq_alloc_lock);\r\nafe->memif_size = MT2701_MEMIF_NUM;\r\nafe->memif = devm_kcalloc(dev, afe->memif_size, sizeof(*afe->memif),\r\nGFP_KERNEL);\r\nif (!afe->memif)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < afe->memif_size; i++) {\r\nafe->memif[i].data = &memif_data[i];\r\nafe->memif[i].irq_usage = -1;\r\n}\r\nafe->irqs_size = MT2701_IRQ_ASYS_END;\r\nafe->irqs = devm_kcalloc(dev, afe->irqs_size, sizeof(*afe->irqs),\r\nGFP_KERNEL);\r\nif (!afe->irqs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < afe->irqs_size; i++)\r\nafe->irqs[i].irq_data = &irq_data[i];\r\nfor (i = 0; i < MT2701_I2S_NUM; i++) {\r\nafe_priv->i2s_path[i].i2s_data[I2S_OUT]\r\n= &mt2701_i2s_data[i][I2S_OUT];\r\nafe_priv->i2s_path[i].i2s_data[I2S_IN]\r\n= &mt2701_i2s_data[i][I2S_IN];\r\n}\r\nafe->mtk_afe_hardware = &mt2701_afe_hardware;\r\nafe->memif_fs = mt2701_memif_fs;\r\nafe->irq_fs = mt2701_irq_fs;\r\nafe->reg_back_up_list = mt2701_afe_backup_list;\r\nafe->reg_back_up_list_num = ARRAY_SIZE(mt2701_afe_backup_list);\r\nafe->runtime_resume = mt2701_afe_runtime_resume;\r\nafe->runtime_suspend = mt2701_afe_runtime_suspend;\r\nret = mt2701_init_clock(afe);\r\nif (ret) {\r\ndev_err(dev, "init clock error\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, afe);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev))\r\ngoto err_pm_disable;\r\nret = snd_soc_register_platform(&pdev->dev, &mtk_afe_pcm_platform);\r\nif (ret) {\r\ndev_warn(dev, "err_platform\n");\r\ngoto err_platform;\r\n}\r\nret = snd_soc_register_component(&pdev->dev,\r\n&mt2701_afe_pcm_dai_component,\r\nmt2701_afe_pcm_dais,\r\nARRAY_SIZE(mt2701_afe_pcm_dais));\r\nif (ret) {\r\ndev_warn(dev, "err_dai_component\n");\r\ngoto err_dai_component;\r\n}\r\nmt2701_afe_runtime_resume(&pdev->dev);\r\nreturn 0;\r\nerr_dai_component:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nerr_platform:\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int mt2701_afe_pcm_dev_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_base_afe *afe = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nmt2701_afe_runtime_suspend(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nmt2701_afe_disable_clock(afe);\r\nreturn 0;\r\n}
