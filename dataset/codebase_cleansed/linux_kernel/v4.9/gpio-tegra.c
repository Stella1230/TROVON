static inline void tegra_gpio_writel(struct tegra_gpio_info *tgi,\r\nu32 val, u32 reg)\r\n{\r\n__raw_writel(val, tgi->regs + reg);\r\n}\r\nstatic inline u32 tegra_gpio_readl(struct tegra_gpio_info *tgi, u32 reg)\r\n{\r\nreturn __raw_readl(tgi->regs + reg);\r\n}\r\nstatic int tegra_gpio_compose(int bank, int port, int bit)\r\n{\r\nreturn (bank << 5) | ((port & 0x3) << 3) | (bit & 0x7);\r\n}\r\nstatic void tegra_gpio_mask_write(struct tegra_gpio_info *tgi, u32 reg,\r\nint gpio, int value)\r\n{\r\nu32 val;\r\nval = 0x100 << GPIO_BIT(gpio);\r\nif (value)\r\nval |= 1 << GPIO_BIT(gpio);\r\ntegra_gpio_writel(tgi, val, reg);\r\n}\r\nstatic void tegra_gpio_enable(struct tegra_gpio_info *tgi, int gpio)\r\n{\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_CNF(tgi, gpio), gpio, 1);\r\n}\r\nstatic void tegra_gpio_disable(struct tegra_gpio_info *tgi, int gpio)\r\n{\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_CNF(tgi, gpio), gpio, 0);\r\n}\r\nstatic int tegra_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(offset);\r\n}\r\nstatic void tegra_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\r\npinctrl_free_gpio(offset);\r\ntegra_gpio_disable(tgi, offset);\r\n}\r\nstatic void tegra_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_OUT(tgi, offset), offset, value);\r\n}\r\nstatic int tegra_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\r\nint bval = BIT(GPIO_BIT(offset));\r\nif (tegra_gpio_readl(tgi, GPIO_OE(tgi, offset)) & bval)\r\nreturn !!(tegra_gpio_readl(tgi, GPIO_OUT(tgi, offset)) & bval);\r\nreturn !!(tegra_gpio_readl(tgi, GPIO_IN(tgi, offset)) & bval);\r\n}\r\nstatic int tegra_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_OE(tgi, offset), offset, 0);\r\ntegra_gpio_enable(tgi, offset);\r\nreturn 0;\r\n}\r\nstatic int tegra_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\r\ntegra_gpio_set(chip, offset, value);\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_OE(tgi, offset), offset, 1);\r\ntegra_gpio_enable(tgi, offset);\r\nreturn 0;\r\n}\r\nstatic int tegra_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\r\nu32 pin_mask = BIT(GPIO_BIT(offset));\r\nu32 cnf, oe;\r\ncnf = tegra_gpio_readl(tgi, GPIO_CNF(tgi, offset));\r\nif (!(cnf & pin_mask))\r\nreturn -EINVAL;\r\noe = tegra_gpio_readl(tgi, GPIO_OE(tgi, offset));\r\nreturn (oe & pin_mask) ? GPIOF_DIR_OUT : GPIOF_DIR_IN;\r\n}\r\nstatic int tegra_gpio_set_debounce(struct gpio_chip *chip, unsigned int offset,\r\nunsigned int debounce)\r\n{\r\nstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\r\nstruct tegra_gpio_bank *bank = &tgi->bank_info[GPIO_BANK(offset)];\r\nunsigned int debounce_ms = DIV_ROUND_UP(debounce, 1000);\r\nunsigned long flags;\r\nint port;\r\nif (!debounce_ms) {\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_DBC_EN(tgi, offset),\r\noffset, 0);\r\nreturn 0;\r\n}\r\ndebounce_ms = min(debounce_ms, 255U);\r\nport = GPIO_PORT(offset);\r\nspin_lock_irqsave(&bank->dbc_lock[port], flags);\r\nif (bank->dbc_cnt[port] < debounce_ms) {\r\ntegra_gpio_writel(tgi, debounce_ms, GPIO_DBC_CNT(tgi, offset));\r\nbank->dbc_cnt[port] = debounce_ms;\r\n}\r\nspin_unlock_irqrestore(&bank->dbc_lock[port], flags);\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_DBC_EN(tgi, offset), offset, 1);\r\nreturn 0;\r\n}\r\nstatic int tegra_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct tegra_gpio_info *tgi = gpiochip_get_data(chip);\r\nreturn irq_find_mapping(tgi->irq_domain, offset);\r\n}\r\nstatic void tegra_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct tegra_gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nstruct tegra_gpio_info *tgi = bank->tgi;\r\nint gpio = d->hwirq;\r\ntegra_gpio_writel(tgi, 1 << GPIO_BIT(gpio), GPIO_INT_CLR(tgi, gpio));\r\n}\r\nstatic void tegra_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct tegra_gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nstruct tegra_gpio_info *tgi = bank->tgi;\r\nint gpio = d->hwirq;\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_INT_ENB(tgi, gpio), gpio, 0);\r\n}\r\nstatic void tegra_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct tegra_gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nstruct tegra_gpio_info *tgi = bank->tgi;\r\nint gpio = d->hwirq;\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_INT_ENB(tgi, gpio), gpio, 1);\r\n}\r\nstatic int tegra_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nint gpio = d->hwirq;\r\nstruct tegra_gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nstruct tegra_gpio_info *tgi = bank->tgi;\r\nint port = GPIO_PORT(gpio);\r\nint lvl_type;\r\nint val;\r\nunsigned long flags;\r\nint ret;\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nlvl_type = GPIO_INT_LVL_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nlvl_type = GPIO_INT_LVL_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nlvl_type = GPIO_INT_LVL_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nlvl_type = GPIO_INT_LVL_LEVEL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nlvl_type = GPIO_INT_LVL_LEVEL_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = gpiochip_lock_as_irq(&tgi->gc, gpio);\r\nif (ret) {\r\ndev_err(tgi->dev,\r\n"unable to lock Tegra GPIO %d as IRQ\n", gpio);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&bank->lvl_lock[port], flags);\r\nval = tegra_gpio_readl(tgi, GPIO_INT_LVL(tgi, gpio));\r\nval &= ~(GPIO_INT_LVL_MASK << GPIO_BIT(gpio));\r\nval |= lvl_type << GPIO_BIT(gpio);\r\ntegra_gpio_writel(tgi, val, GPIO_INT_LVL(tgi, gpio));\r\nspin_unlock_irqrestore(&bank->lvl_lock[port], flags);\r\ntegra_gpio_mask_write(tgi, GPIO_MSK_OE(tgi, gpio), gpio, 0);\r\ntegra_gpio_enable(tgi, gpio);\r\nif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\r\nirq_set_handler_locked(d, handle_level_irq);\r\nelse if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic void tegra_gpio_irq_shutdown(struct irq_data *d)\r\n{\r\nstruct tegra_gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nstruct tegra_gpio_info *tgi = bank->tgi;\r\nint gpio = d->hwirq;\r\ngpiochip_unlock_as_irq(&tgi->gc, gpio);\r\n}\r\nstatic void tegra_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nint port;\r\nint pin;\r\nint unmasked = 0;\r\nint gpio;\r\nu32 lvl;\r\nunsigned long sta;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct tegra_gpio_bank *bank = irq_desc_get_handler_data(desc);\r\nstruct tegra_gpio_info *tgi = bank->tgi;\r\nchained_irq_enter(chip, desc);\r\nfor (port = 0; port < 4; port++) {\r\ngpio = tegra_gpio_compose(bank->bank, port, 0);\r\nsta = tegra_gpio_readl(tgi, GPIO_INT_STA(tgi, gpio)) &\r\ntegra_gpio_readl(tgi, GPIO_INT_ENB(tgi, gpio));\r\nlvl = tegra_gpio_readl(tgi, GPIO_INT_LVL(tgi, gpio));\r\nfor_each_set_bit(pin, &sta, 8) {\r\ntegra_gpio_writel(tgi, 1 << pin,\r\nGPIO_INT_CLR(tgi, gpio));\r\nif (lvl & (0x100 << pin)) {\r\nunmasked = 1;\r\nchained_irq_exit(chip, desc);\r\n}\r\ngeneric_handle_irq(gpio_to_irq(gpio + pin));\r\n}\r\n}\r\nif (!unmasked)\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int tegra_gpio_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tegra_gpio_info *tgi = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nint b;\r\nint p;\r\nlocal_irq_save(flags);\r\nfor (b = 0; b < tgi->bank_count; b++) {\r\nstruct tegra_gpio_bank *bank = &tgi->bank_info[b];\r\nfor (p = 0; p < ARRAY_SIZE(bank->oe); p++) {\r\nunsigned int gpio = (b<<5) | (p<<3);\r\ntegra_gpio_writel(tgi, bank->cnf[p],\r\nGPIO_CNF(tgi, gpio));\r\nif (tgi->soc->debounce_supported) {\r\ntegra_gpio_writel(tgi, bank->dbc_cnt[p],\r\nGPIO_DBC_CNT(tgi, gpio));\r\ntegra_gpio_writel(tgi, bank->dbc_enb[p],\r\nGPIO_MSK_DBC_EN(tgi, gpio));\r\n}\r\ntegra_gpio_writel(tgi, bank->out[p],\r\nGPIO_OUT(tgi, gpio));\r\ntegra_gpio_writel(tgi, bank->oe[p],\r\nGPIO_OE(tgi, gpio));\r\ntegra_gpio_writel(tgi, bank->int_lvl[p],\r\nGPIO_INT_LVL(tgi, gpio));\r\ntegra_gpio_writel(tgi, bank->int_enb[p],\r\nGPIO_INT_ENB(tgi, gpio));\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int tegra_gpio_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tegra_gpio_info *tgi = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nint b;\r\nint p;\r\nlocal_irq_save(flags);\r\nfor (b = 0; b < tgi->bank_count; b++) {\r\nstruct tegra_gpio_bank *bank = &tgi->bank_info[b];\r\nfor (p = 0; p < ARRAY_SIZE(bank->oe); p++) {\r\nunsigned int gpio = (b<<5) | (p<<3);\r\nbank->cnf[p] = tegra_gpio_readl(tgi,\r\nGPIO_CNF(tgi, gpio));\r\nbank->out[p] = tegra_gpio_readl(tgi,\r\nGPIO_OUT(tgi, gpio));\r\nbank->oe[p] = tegra_gpio_readl(tgi,\r\nGPIO_OE(tgi, gpio));\r\nif (tgi->soc->debounce_supported) {\r\nbank->dbc_enb[p] = tegra_gpio_readl(tgi,\r\nGPIO_MSK_DBC_EN(tgi, gpio));\r\nbank->dbc_enb[p] = (bank->dbc_enb[p] << 8) |\r\nbank->dbc_enb[p];\r\n}\r\nbank->int_enb[p] = tegra_gpio_readl(tgi,\r\nGPIO_INT_ENB(tgi, gpio));\r\nbank->int_lvl[p] = tegra_gpio_readl(tgi,\r\nGPIO_INT_LVL(tgi, gpio));\r\ntegra_gpio_writel(tgi, bank->wake_enb[p],\r\nGPIO_INT_ENB(tgi, gpio));\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int tegra_gpio_irq_set_wake(struct irq_data *d, unsigned int enable)\r\n{\r\nstruct tegra_gpio_bank *bank = irq_data_get_irq_chip_data(d);\r\nint gpio = d->hwirq;\r\nu32 port, bit, mask;\r\nport = GPIO_PORT(gpio);\r\nbit = GPIO_BIT(gpio);\r\nmask = BIT(bit);\r\nif (enable)\r\nbank->wake_enb[port] |= mask;\r\nelse\r\nbank->wake_enb[port] &= ~mask;\r\nreturn irq_set_irq_wake(bank->irq, enable);\r\n}\r\nstatic int dbg_gpio_show(struct seq_file *s, void *unused)\r\n{\r\nstruct tegra_gpio_info *tgi = s->private;\r\nint i;\r\nint j;\r\nfor (i = 0; i < tgi->bank_count; i++) {\r\nfor (j = 0; j < 4; j++) {\r\nint gpio = tegra_gpio_compose(i, j, 0);\r\nseq_printf(s,\r\n"%d:%d %02x %02x %02x %02x %02x %02x %06x\n",\r\ni, j,\r\ntegra_gpio_readl(tgi, GPIO_CNF(tgi, gpio)),\r\ntegra_gpio_readl(tgi, GPIO_OE(tgi, gpio)),\r\ntegra_gpio_readl(tgi, GPIO_OUT(tgi, gpio)),\r\ntegra_gpio_readl(tgi, GPIO_IN(tgi, gpio)),\r\ntegra_gpio_readl(tgi, GPIO_INT_STA(tgi, gpio)),\r\ntegra_gpio_readl(tgi, GPIO_INT_ENB(tgi, gpio)),\r\ntegra_gpio_readl(tgi, GPIO_INT_LVL(tgi, gpio)));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dbg_gpio_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dbg_gpio_show, inode->i_private);\r\n}\r\nstatic void tegra_gpio_debuginit(struct tegra_gpio_info *tgi)\r\n{\r\n(void) debugfs_create_file("tegra_gpio", S_IRUGO,\r\nNULL, tgi, &debug_fops);\r\n}\r\nstatic inline void tegra_gpio_debuginit(struct tegra_gpio_info *tgi)\r\n{\r\n}\r\nstatic int tegra_gpio_probe(struct platform_device *pdev)\r\n{\r\nconst struct tegra_gpio_soc_config *config;\r\nstruct tegra_gpio_info *tgi;\r\nstruct resource *res;\r\nstruct tegra_gpio_bank *bank;\r\nint ret;\r\nint gpio;\r\nint i;\r\nint j;\r\nconfig = of_device_get_match_data(&pdev->dev);\r\nif (!config) {\r\ndev_err(&pdev->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\ntgi = devm_kzalloc(&pdev->dev, sizeof(*tgi), GFP_KERNEL);\r\nif (!tgi)\r\nreturn -ENODEV;\r\ntgi->soc = config;\r\ntgi->dev = &pdev->dev;\r\nfor (;;) {\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ,\r\ntgi->bank_count);\r\nif (!res)\r\nbreak;\r\ntgi->bank_count++;\r\n}\r\nif (!tgi->bank_count) {\r\ndev_err(&pdev->dev, "Missing IRQ resource\n");\r\nreturn -ENODEV;\r\n}\r\ntgi->gc.label = "tegra-gpio";\r\ntgi->gc.request = tegra_gpio_request;\r\ntgi->gc.free = tegra_gpio_free;\r\ntgi->gc.direction_input = tegra_gpio_direction_input;\r\ntgi->gc.get = tegra_gpio_get;\r\ntgi->gc.direction_output = tegra_gpio_direction_output;\r\ntgi->gc.set = tegra_gpio_set;\r\ntgi->gc.get_direction = tegra_gpio_get_direction;\r\ntgi->gc.to_irq = tegra_gpio_to_irq;\r\ntgi->gc.base = 0;\r\ntgi->gc.ngpio = tgi->bank_count * 32;\r\ntgi->gc.parent = &pdev->dev;\r\ntgi->gc.of_node = pdev->dev.of_node;\r\ntgi->ic.name = "GPIO";\r\ntgi->ic.irq_ack = tegra_gpio_irq_ack;\r\ntgi->ic.irq_mask = tegra_gpio_irq_mask;\r\ntgi->ic.irq_unmask = tegra_gpio_irq_unmask;\r\ntgi->ic.irq_set_type = tegra_gpio_irq_set_type;\r\ntgi->ic.irq_shutdown = tegra_gpio_irq_shutdown;\r\n#ifdef CONFIG_PM_SLEEP\r\ntgi->ic.irq_set_wake = tegra_gpio_irq_set_wake;\r\n#endif\r\nplatform_set_drvdata(pdev, tgi);\r\nif (config->debounce_supported)\r\ntgi->gc.set_debounce = tegra_gpio_set_debounce;\r\ntgi->bank_info = devm_kzalloc(&pdev->dev, tgi->bank_count *\r\nsizeof(*tgi->bank_info), GFP_KERNEL);\r\nif (!tgi->bank_info)\r\nreturn -ENODEV;\r\ntgi->irq_domain = irq_domain_add_linear(pdev->dev.of_node,\r\ntgi->gc.ngpio,\r\n&irq_domain_simple_ops, NULL);\r\nif (!tgi->irq_domain)\r\nreturn -ENODEV;\r\nfor (i = 0; i < tgi->bank_count; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, i);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Missing IRQ resource\n");\r\nreturn -ENODEV;\r\n}\r\nbank = &tgi->bank_info[i];\r\nbank->bank = i;\r\nbank->irq = res->start;\r\nbank->tgi = tgi;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntgi->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tgi->regs))\r\nreturn PTR_ERR(tgi->regs);\r\nfor (i = 0; i < tgi->bank_count; i++) {\r\nfor (j = 0; j < 4; j++) {\r\nint gpio = tegra_gpio_compose(i, j, 0);\r\ntegra_gpio_writel(tgi, 0x00, GPIO_INT_ENB(tgi, gpio));\r\n}\r\n}\r\nret = devm_gpiochip_add_data(&pdev->dev, &tgi->gc, tgi);\r\nif (ret < 0) {\r\nirq_domain_remove(tgi->irq_domain);\r\nreturn ret;\r\n}\r\nfor (gpio = 0; gpio < tgi->gc.ngpio; gpio++) {\r\nint irq = irq_create_mapping(tgi->irq_domain, gpio);\r\nbank = &tgi->bank_info[GPIO_BANK(gpio)];\r\nirq_set_lockdep_class(irq, &gpio_lock_class);\r\nirq_set_chip_data(irq, bank);\r\nirq_set_chip_and_handler(irq, &tgi->ic, handle_simple_irq);\r\n}\r\nfor (i = 0; i < tgi->bank_count; i++) {\r\nbank = &tgi->bank_info[i];\r\nirq_set_chained_handler_and_data(bank->irq,\r\ntegra_gpio_irq_handler, bank);\r\nfor (j = 0; j < 4; j++) {\r\nspin_lock_init(&bank->lvl_lock[j]);\r\nspin_lock_init(&bank->dbc_lock[j]);\r\n}\r\n}\r\ntegra_gpio_debuginit(tgi);\r\nreturn 0;\r\n}\r\nstatic int __init tegra_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&tegra_gpio_driver);\r\n}
