static int alloc_emuframe(void)\r\n{\r\nmm_context_t *mm_ctx = &current->mm->context;\r\nint idx;\r\nretry:\r\nspin_lock(&mm_ctx->bd_emupage_lock);\r\nif (!mm_ctx->bd_emupage_allocmap) {\r\nmm_ctx->bd_emupage_allocmap =\r\nkcalloc(BITS_TO_LONGS(emupage_frame_count),\r\nsizeof(unsigned long),\r\nGFP_ATOMIC);\r\nif (!mm_ctx->bd_emupage_allocmap) {\r\nidx = BD_EMUFRAME_NONE;\r\ngoto out_unlock;\r\n}\r\n}\r\nidx = bitmap_find_free_region(mm_ctx->bd_emupage_allocmap,\r\nemupage_frame_count, 0);\r\nif (idx < 0) {\r\nspin_unlock(&mm_ctx->bd_emupage_lock);\r\nif (!wait_event_killable(mm_ctx->bd_emupage_queue,\r\n!bitmap_full(mm_ctx->bd_emupage_allocmap,\r\nemupage_frame_count)))\r\ngoto retry;\r\nreturn BD_EMUFRAME_NONE;\r\n}\r\npr_debug("allocate emuframe %d to %d\n", idx, current->pid);\r\nout_unlock:\r\nspin_unlock(&mm_ctx->bd_emupage_lock);\r\nreturn idx;\r\n}\r\nstatic void free_emuframe(int idx, struct mm_struct *mm)\r\n{\r\nmm_context_t *mm_ctx = &mm->context;\r\nspin_lock(&mm_ctx->bd_emupage_lock);\r\npr_debug("free emuframe %d from %d\n", idx, current->pid);\r\nbitmap_clear(mm_ctx->bd_emupage_allocmap, idx, 1);\r\nwake_up(&mm_ctx->bd_emupage_queue);\r\nspin_unlock(&mm_ctx->bd_emupage_lock);\r\n}\r\nstatic bool within_emuframe(struct pt_regs *regs)\r\n{\r\nunsigned long base = (unsigned long)dsemul_page();\r\nif (regs->cp0_epc < base)\r\nreturn false;\r\nif (regs->cp0_epc >= (base + PAGE_SIZE))\r\nreturn false;\r\nreturn true;\r\n}\r\nbool dsemul_thread_cleanup(struct task_struct *tsk)\r\n{\r\nint fr_idx;\r\nfr_idx = atomic_xchg(&tsk->thread.bd_emu_frame, BD_EMUFRAME_NONE);\r\nif (fr_idx == BD_EMUFRAME_NONE)\r\nreturn false;\r\ntask_lock(tsk);\r\nif (tsk->mm)\r\nfree_emuframe(fr_idx, tsk->mm);\r\ntask_unlock(tsk);\r\nreturn true;\r\n}\r\nbool dsemul_thread_rollback(struct pt_regs *regs)\r\n{\r\nstruct emuframe __user *fr;\r\nint fr_idx;\r\nif (!within_emuframe(regs))\r\nreturn false;\r\nfr_idx = atomic_read(&current->thread.bd_emu_frame);\r\nif (fr_idx == BD_EMUFRAME_NONE)\r\nreturn false;\r\nfr = &dsemul_page()[fr_idx];\r\nif (msk_isa16_mode(regs->cp0_epc) == (unsigned long)&fr->emul)\r\nregs->cp0_epc = current->thread.bd_emu_branch_pc;\r\nelse if (msk_isa16_mode(regs->cp0_epc) == (unsigned long)&fr->badinst)\r\nregs->cp0_epc = current->thread.bd_emu_cont_pc;\r\natomic_set(&current->thread.bd_emu_frame, BD_EMUFRAME_NONE);\r\nfree_emuframe(fr_idx, current->mm);\r\nreturn true;\r\n}\r\nvoid dsemul_mm_cleanup(struct mm_struct *mm)\r\n{\r\nmm_context_t *mm_ctx = &mm->context;\r\nkfree(mm_ctx->bd_emupage_allocmap);\r\n}\r\nint mips_dsemul(struct pt_regs *regs, mips_instruction ir,\r\nunsigned long branch_pc, unsigned long cont_pc)\r\n{\r\nint isa16 = get_isa16_mode(regs->cp0_epc);\r\nmips_instruction break_math;\r\nstruct emuframe __user *fr;\r\nint err, fr_idx;\r\nif (ir == 0)\r\nreturn -1;\r\nif (isa16) {\r\nunion mips_instruction insn = { .word = ir };\r\nif ((ir >> 16) == MM_NOP16)\r\nreturn -1;\r\nif (insn.mm_a_format.opcode == mm_addiupc_op) {\r\nunsigned int rs;\r\ns32 v;\r\nrs = (((insn.mm_a_format.rs + 0xe) & 0xf) + 2);\r\nv = regs->cp0_epc & ~3;\r\nv += insn.mm_a_format.simmediate << 2;\r\nregs->regs[rs] = (long)v;\r\nreturn -1;\r\n}\r\n}\r\npr_debug("dsemul 0x%08lx cont at 0x%08lx\n", regs->cp0_epc, cont_pc);\r\nfr_idx = atomic_read(&current->thread.bd_emu_frame);\r\nif (fr_idx == BD_EMUFRAME_NONE)\r\nfr_idx = alloc_emuframe();\r\nif (fr_idx == BD_EMUFRAME_NONE)\r\nreturn SIGBUS;\r\nfr = &dsemul_page()[fr_idx];\r\nbreak_math = BREAK_MATH(isa16);\r\nif (isa16) {\r\nerr = __put_user(ir >> 16,\r\n(u16 __user *)(&fr->emul));\r\nerr |= __put_user(ir & 0xffff,\r\n(u16 __user *)((long)(&fr->emul) + 2));\r\nerr |= __put_user(break_math >> 16,\r\n(u16 __user *)(&fr->badinst));\r\nerr |= __put_user(break_math & 0xffff,\r\n(u16 __user *)((long)(&fr->badinst) + 2));\r\n} else {\r\nerr = __put_user(ir, &fr->emul);\r\nerr |= __put_user(break_math, &fr->badinst);\r\n}\r\nif (unlikely(err)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\nfree_emuframe(fr_idx, current->mm);\r\nreturn SIGBUS;\r\n}\r\ncurrent->thread.bd_emu_branch_pc = branch_pc;\r\ncurrent->thread.bd_emu_cont_pc = cont_pc;\r\natomic_set(&current->thread.bd_emu_frame, fr_idx);\r\nregs->cp0_epc = (unsigned long)&fr->emul | isa16;\r\nflush_cache_sigtramp((unsigned long)&fr->emul);\r\nreturn 0;\r\n}\r\nbool do_dsemulret(struct pt_regs *xcp)\r\n{\r\nif (!dsemul_thread_cleanup(current)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\nreturn false;\r\n}\r\nxcp->cp0_epc = current->thread.bd_emu_cont_pc;\r\npr_debug("dsemulret to 0x%08lx\n", xcp->cp0_epc);\r\nMIPS_FPU_EMU_INC_STATS(ds_emul);\r\nreturn true;\r\n}
