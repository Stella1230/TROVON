static void wilc_sdio_interrupt(struct sdio_func *func)\r\n{\r\nsdio_release_host(func);\r\nwilc_handle_isr(sdio_get_drvdata(func));\r\nsdio_claim_host(func);\r\n}\r\nstatic int wilc_sdio_cmd52(struct wilc *wilc, struct sdio_cmd52 *cmd)\r\n{\r\nstruct sdio_func *func = container_of(wilc->dev, struct sdio_func, dev);\r\nint ret;\r\nu8 data;\r\nsdio_claim_host(func);\r\nfunc->num = cmd->function;\r\nif (cmd->read_write) {\r\nif (cmd->raw) {\r\nsdio_writeb(func, cmd->data, cmd->address, &ret);\r\ndata = sdio_readb(func, cmd->address, &ret);\r\ncmd->data = data;\r\n} else {\r\nsdio_writeb(func, cmd->data, cmd->address, &ret);\r\n}\r\n} else {\r\ndata = sdio_readb(func, cmd->address, &ret);\r\ncmd->data = data;\r\n}\r\nsdio_release_host(func);\r\nif (ret)\r\ndev_err(&func->dev, "wilc_sdio_cmd52..failed, err(%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int wilc_sdio_cmd53(struct wilc *wilc, struct sdio_cmd53 *cmd)\r\n{\r\nstruct sdio_func *func = container_of(wilc->dev, struct sdio_func, dev);\r\nint size, ret;\r\nsdio_claim_host(func);\r\nfunc->num = cmd->function;\r\nfunc->cur_blksize = cmd->block_size;\r\nif (cmd->block_mode)\r\nsize = cmd->count * cmd->block_size;\r\nelse\r\nsize = cmd->count;\r\nif (cmd->read_write) {\r\nret = sdio_memcpy_toio(func, cmd->address,\r\n(void *)cmd->buffer, size);\r\n} else {\r\nret = sdio_memcpy_fromio(func, (void *)cmd->buffer,\r\ncmd->address, size);\r\n}\r\nsdio_release_host(func);\r\nif (ret)\r\ndev_err(&func->dev, "wilc_sdio_cmd53..failed, err(%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int linux_sdio_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nstruct wilc *wilc;\r\nint gpio, ret;\r\ngpio = -1;\r\nif (IS_ENABLED(CONFIG_WILC1000_HW_OOB_INTR)) {\r\ngpio = of_get_gpio(func->dev.of_node, 0);\r\nif (gpio < 0)\r\ngpio = GPIO_NUM;\r\n}\r\ndev_dbg(&func->dev, "Initializing netdev\n");\r\nret = wilc_netdev_init(&wilc, &func->dev, HIF_SDIO, gpio,\r\n&wilc_hif_sdio);\r\nif (ret) {\r\ndev_err(&func->dev, "Couldn't initialize netdev\n");\r\nreturn ret;\r\n}\r\nsdio_set_drvdata(func, wilc);\r\nwilc->dev = &func->dev;\r\ndev_info(&func->dev, "Driver Initializing success\n");\r\nreturn 0;\r\n}\r\nstatic void linux_sdio_remove(struct sdio_func *func)\r\n{\r\nwilc_netdev_cleanup(sdio_get_drvdata(func));\r\n}\r\nstatic int sdio_reset(struct wilc *wilc)\r\n{\r\nstruct sdio_cmd52 cmd;\r\nint ret;\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0x6;\r\ncmd.data = 0x8;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Fail cmd 52, reset cmd ...\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wilc_sdio_suspend(struct device *dev)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(dev);\r\nstruct wilc *wilc = sdio_get_drvdata(func);\r\nint ret;\r\ndev_info(dev, "sdio suspend\n");\r\nchip_wakeup(wilc);\r\nif (!wilc->suspend_event) {\r\nwilc_chip_sleep_manually(wilc);\r\n} else {\r\nhost_sleep_notify(wilc);\r\nchip_allow_sleep(wilc);\r\n}\r\nret = sdio_reset(wilc);\r\nif (ret) {\r\ndev_err(&func->dev, "Fail reset sdio\n");\r\nreturn ret;\r\n}\r\nsdio_claim_host(func);\r\nreturn 0;\r\n}\r\nstatic int wilc_sdio_resume(struct device *dev)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(dev);\r\nstruct wilc *wilc = sdio_get_drvdata(func);\r\ndev_info(dev, "sdio resume\n");\r\nsdio_release_host(func);\r\nchip_wakeup(wilc);\r\nsdio_init(wilc, true);\r\nif (wilc->suspend_event)\r\nhost_wakeup_notify(wilc);\r\nchip_allow_sleep(wilc);\r\nreturn 0;\r\n}\r\nstatic int wilc_sdio_enable_interrupt(struct wilc *dev)\r\n{\r\nstruct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);\r\nint ret = 0;\r\nsdio_claim_host(func);\r\nret = sdio_claim_irq(func, wilc_sdio_interrupt);\r\nsdio_release_host(func);\r\nif (ret < 0) {\r\ndev_err(&func->dev, "can't claim sdio_irq, err(%d)\n", ret);\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic void wilc_sdio_disable_interrupt(struct wilc *dev)\r\n{\r\nstruct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);\r\nint ret;\r\ndev_dbg(&func->dev, "wilc_sdio_disable_interrupt IN\n");\r\nsdio_claim_host(func);\r\nret = sdio_release_irq(func);\r\nif (ret < 0)\r\ndev_err(&func->dev, "can't release sdio_irq, err(%d)\n", ret);\r\nsdio_release_host(func);\r\ndev_info(&func->dev, "wilc_sdio_disable_interrupt OUT\n");\r\n}\r\nstatic int sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nstruct sdio_cmd52 cmd;\r\nint ret;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0x10c;\r\ncmd.data = (u8)adr;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Failed cmd52, set 0x10c data...\n");\r\ngoto _fail_;\r\n}\r\ncmd.address = 0x10d;\r\ncmd.data = (u8)(adr >> 8);\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Failed cmd52, set 0x10d data...\n");\r\ngoto _fail_;\r\n}\r\ncmd.address = 0x10e;\r\ncmd.data = (u8)(adr >> 16);\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Failed cmd52, set 0x10e data...\n");\r\ngoto _fail_;\r\n}\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_set_func0_block_size(struct wilc *wilc, u32 block_size)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nstruct sdio_cmd52 cmd;\r\nint ret;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0x10;\r\ncmd.data = (u8)block_size;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Failed cmd52, set 0x10 data...\n");\r\ngoto _fail_;\r\n}\r\ncmd.address = 0x11;\r\ncmd.data = (u8)(block_size >> 8);\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Failed cmd52, set 0x11 data...\n");\r\ngoto _fail_;\r\n}\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_set_func1_block_size(struct wilc *wilc, u32 block_size)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nstruct sdio_cmd52 cmd;\r\nint ret;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0x110;\r\ncmd.data = (u8)block_size;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Failed cmd52, set 0x110 data...\n");\r\ngoto _fail_;\r\n}\r\ncmd.address = 0x111;\r\ncmd.data = (u8)(block_size >> 8);\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Failed cmd52, set 0x111 data...\n");\r\ngoto _fail_;\r\n}\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nint ret;\r\ndata = cpu_to_le32(data);\r\nif ((addr >= 0xf0) && (addr <= 0xff)) {\r\nstruct sdio_cmd52 cmd;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = addr;\r\ncmd.data = data;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd 52, read reg (%08x) ...\n", addr);\r\ngoto _fail_;\r\n}\r\n} else {\r\nstruct sdio_cmd53 cmd;\r\nif (!sdio_set_func0_csa_address(wilc, addr))\r\ngoto _fail_;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.address = 0x10f;\r\ncmd.block_mode = 0;\r\ncmd.increment = 1;\r\ncmd.count = 4;\r\ncmd.buffer = (u8 *)&data;\r\ncmd.block_size = g_sdio.block_size;\r\nret = wilc_sdio_cmd53(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd53, write reg (%08x)...\n", addr);\r\ngoto _fail_;\r\n}\r\n}\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nu32 block_size = g_sdio.block_size;\r\nstruct sdio_cmd53 cmd;\r\nint nblk, nleft, ret;\r\ncmd.read_write = 1;\r\nif (addr > 0) {\r\nif (size & 0x3) {\r\nsize += 4;\r\nsize &= ~0x3;\r\n}\r\ncmd.function = 0;\r\ncmd.address = 0x10f;\r\n} else {\r\nif (size & 0x3) {\r\nsize += 4;\r\nsize &= ~0x3;\r\n}\r\ncmd.function = 1;\r\ncmd.address = 0;\r\n}\r\nnblk = size / block_size;\r\nnleft = size % block_size;\r\nif (nblk > 0) {\r\ncmd.block_mode = 1;\r\ncmd.increment = 1;\r\ncmd.count = nblk;\r\ncmd.buffer = buf;\r\ncmd.block_size = block_size;\r\nif (addr > 0) {\r\nif (!sdio_set_func0_csa_address(wilc, addr))\r\ngoto _fail_;\r\n}\r\nret = wilc_sdio_cmd53(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd53 [%x], block send...\n", addr);\r\ngoto _fail_;\r\n}\r\nif (addr > 0)\r\naddr += nblk * block_size;\r\nbuf += nblk * block_size;\r\n}\r\nif (nleft > 0) {\r\ncmd.block_mode = 0;\r\ncmd.increment = 1;\r\ncmd.count = nleft;\r\ncmd.buffer = buf;\r\ncmd.block_size = block_size;\r\nif (addr > 0) {\r\nif (!sdio_set_func0_csa_address(wilc, addr))\r\ngoto _fail_;\r\n}\r\nret = wilc_sdio_cmd53(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd53 [%x], bytes send...\n", addr);\r\ngoto _fail_;\r\n}\r\n}\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nint ret;\r\nif ((addr >= 0xf0) && (addr <= 0xff)) {\r\nstruct sdio_cmd52 cmd;\r\ncmd.read_write = 0;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = addr;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd 52, read reg (%08x) ...\n", addr);\r\ngoto _fail_;\r\n}\r\n*data = cmd.data;\r\n} else {\r\nstruct sdio_cmd53 cmd;\r\nif (!sdio_set_func0_csa_address(wilc, addr))\r\ngoto _fail_;\r\ncmd.read_write = 0;\r\ncmd.function = 0;\r\ncmd.address = 0x10f;\r\ncmd.block_mode = 0;\r\ncmd.increment = 1;\r\ncmd.count = 4;\r\ncmd.buffer = (u8 *)data;\r\ncmd.block_size = g_sdio.block_size;\r\nret = wilc_sdio_cmd53(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd53, read reg (%08x)...\n", addr);\r\ngoto _fail_;\r\n}\r\n}\r\n*data = cpu_to_le32(*data);\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nu32 block_size = g_sdio.block_size;\r\nstruct sdio_cmd53 cmd;\r\nint nblk, nleft, ret;\r\ncmd.read_write = 0;\r\nif (addr > 0) {\r\nif (size & 0x3) {\r\nsize += 4;\r\nsize &= ~0x3;\r\n}\r\ncmd.function = 0;\r\ncmd.address = 0x10f;\r\n} else {\r\nif (size & 0x3) {\r\nsize += 4;\r\nsize &= ~0x3;\r\n}\r\ncmd.function = 1;\r\ncmd.address = 0;\r\n}\r\nnblk = size / block_size;\r\nnleft = size % block_size;\r\nif (nblk > 0) {\r\ncmd.block_mode = 1;\r\ncmd.increment = 1;\r\ncmd.count = nblk;\r\ncmd.buffer = buf;\r\ncmd.block_size = block_size;\r\nif (addr > 0) {\r\nif (!sdio_set_func0_csa_address(wilc, addr))\r\ngoto _fail_;\r\n}\r\nret = wilc_sdio_cmd53(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd53 [%x], block read...\n", addr);\r\ngoto _fail_;\r\n}\r\nif (addr > 0)\r\naddr += nblk * block_size;\r\nbuf += nblk * block_size;\r\n}\r\nif (nleft > 0) {\r\ncmd.block_mode = 0;\r\ncmd.increment = 1;\r\ncmd.count = nleft;\r\ncmd.buffer = buf;\r\ncmd.block_size = block_size;\r\nif (addr > 0) {\r\nif (!sdio_set_func0_csa_address(wilc, addr))\r\ngoto _fail_;\r\n}\r\nret = wilc_sdio_cmd53(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd53 [%x], bytes read...\n", addr);\r\ngoto _fail_;\r\n}\r\n}\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_deinit(struct wilc *wilc)\r\n{\r\nreturn 1;\r\n}\r\nstatic int sdio_init(struct wilc *wilc, bool resume)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nstruct sdio_cmd52 cmd;\r\nint loop, ret;\r\nu32 chipid;\r\nif (!resume) {\r\nmemset(&g_sdio, 0, sizeof(struct wilc_sdio));\r\ng_sdio.irq_gpio = wilc->dev_irq_num;\r\n}\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 1;\r\ncmd.address = 0x100;\r\ncmd.data = 0x80;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Fail cmd 52, enable csa...\n");\r\ngoto _fail_;\r\n}\r\nif (!sdio_set_func0_block_size(wilc, WILC_SDIO_BLOCK_SIZE)) {\r\ndev_err(&func->dev, "Fail cmd 52, set func 0 block size...\n");\r\ngoto _fail_;\r\n}\r\ng_sdio.block_size = WILC_SDIO_BLOCK_SIZE;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 1;\r\ncmd.address = 0x2;\r\ncmd.data = 0x2;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Fail cmd 52, set IOE register...\n");\r\ngoto _fail_;\r\n}\r\ncmd.read_write = 0;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0x3;\r\nloop = 3;\r\ndo {\r\ncmd.data = 0;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Fail cmd 52, get IOR register...\n");\r\ngoto _fail_;\r\n}\r\nif (cmd.data == 0x2)\r\nbreak;\r\n} while (loop--);\r\nif (loop <= 0) {\r\ndev_err(&func->dev, "Fail func 1 is not ready...\n");\r\ngoto _fail_;\r\n}\r\nif (!sdio_set_func1_block_size(wilc, WILC_SDIO_BLOCK_SIZE)) {\r\ndev_err(&func->dev, "Fail set func 1 block size...\n");\r\ngoto _fail_;\r\n}\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 1;\r\ncmd.address = 0x4;\r\ncmd.data = 0x3;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev, "Fail cmd 52, set IEN register...\n");\r\ngoto _fail_;\r\n}\r\nif (!resume) {\r\nif (!sdio_read_reg(wilc, 0x1000, &chipid)) {\r\ndev_err(&func->dev, "Fail cmd read chip id...\n");\r\ngoto _fail_;\r\n}\r\ndev_err(&func->dev, "chipid (%08x)\n", chipid);\r\nif ((chipid & 0xfff) > 0x2a0)\r\ng_sdio.has_thrpt_enh3 = 1;\r\nelse\r\ng_sdio.has_thrpt_enh3 = 0;\r\ndev_info(&func->dev, "has_thrpt_enh3 = %d...\n",\r\ng_sdio.has_thrpt_enh3);\r\n}\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_read_size(struct wilc *wilc, u32 *size)\r\n{\r\nu32 tmp;\r\nstruct sdio_cmd52 cmd;\r\ncmd.read_write = 0;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0xf2;\r\ncmd.data = 0;\r\nwilc_sdio_cmd52(wilc, &cmd);\r\ntmp = cmd.data;\r\ncmd.address = 0xf3;\r\ncmd.data = 0;\r\nwilc_sdio_cmd52(wilc, &cmd);\r\ntmp |= (cmd.data << 8);\r\n*size = tmp;\r\nreturn 1;\r\n}\r\nstatic int sdio_read_int(struct wilc *wilc, u32 *int_status)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nu32 tmp;\r\nstruct sdio_cmd52 cmd;\r\nsdio_read_size(wilc, &tmp);\r\nif (!g_sdio.irq_gpio) {\r\nint i;\r\ncmd.function = 1;\r\ncmd.address = 0x04;\r\ncmd.data = 0;\r\nwilc_sdio_cmd52(wilc, &cmd);\r\nif (cmd.data & BIT(0))\r\ntmp |= INT_0;\r\nif (cmd.data & BIT(2))\r\ntmp |= INT_1;\r\nif (cmd.data & BIT(3))\r\ntmp |= INT_2;\r\nif (cmd.data & BIT(4))\r\ntmp |= INT_3;\r\nif (cmd.data & BIT(5))\r\ntmp |= INT_4;\r\nif (cmd.data & BIT(6))\r\ntmp |= INT_5;\r\nfor (i = g_sdio.nint; i < MAX_NUM_INT; i++) {\r\nif ((tmp >> (IRG_FLAGS_OFFSET + i)) & 0x1) {\r\ndev_err(&func->dev,\r\n"Unexpected interrupt (1) : tmp=%x, data=%x\n",\r\ntmp, cmd.data);\r\nbreak;\r\n}\r\n}\r\n} else {\r\nu32 irq_flags;\r\ncmd.read_write = 0;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0xf7;\r\ncmd.data = 0;\r\nwilc_sdio_cmd52(wilc, &cmd);\r\nirq_flags = cmd.data & 0x1f;\r\ntmp |= ((irq_flags >> 0) << IRG_FLAGS_OFFSET);\r\n}\r\n*int_status = tmp;\r\nreturn 1;\r\n}\r\nstatic int sdio_clear_int_ext(struct wilc *wilc, u32 val)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nint ret;\r\nif (g_sdio.has_thrpt_enh3) {\r\nu32 reg;\r\nif (g_sdio.irq_gpio) {\r\nu32 flags;\r\nflags = val & (BIT(MAX_NUN_INT_THRPT_ENH2) - 1);\r\nreg = flags;\r\n} else {\r\nreg = 0;\r\n}\r\nif ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)\r\nreg |= BIT(5);\r\nif ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)\r\nreg |= BIT(6);\r\nif ((val & EN_VMM) == EN_VMM)\r\nreg |= BIT(7);\r\nif (reg) {\r\nstruct sdio_cmd52 cmd;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0xf8;\r\ncmd.data = reg;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd52, set 0xf8 data (%d) ...\n",\r\n__LINE__);\r\ngoto _fail_;\r\n}\r\n}\r\n} else {\r\nif (g_sdio.irq_gpio) {\r\nu32 flags;\r\nflags = val & (BIT(MAX_NUM_INT) - 1);\r\nif (flags) {\r\nint i;\r\nret = 1;\r\nfor (i = 0; i < g_sdio.nint; i++) {\r\nif (flags & 1) {\r\nstruct sdio_cmd52 cmd;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0xf8;\r\ncmd.data = BIT(i);\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd52, set 0xf8 data (%d) ...\n",\r\n__LINE__);\r\ngoto _fail_;\r\n}\r\n}\r\nif (!ret)\r\nbreak;\r\nflags >>= 1;\r\n}\r\nif (!ret)\r\ngoto _fail_;\r\nfor (i = g_sdio.nint; i < MAX_NUM_INT; i++) {\r\nif (flags & 1)\r\ndev_err(&func->dev,\r\n"Unexpected interrupt cleared %d...\n",\r\ni);\r\nflags >>= 1;\r\n}\r\n}\r\n}\r\n{\r\nu32 vmm_ctl;\r\nvmm_ctl = 0;\r\nif ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)\r\nvmm_ctl |= BIT(0);\r\nif ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)\r\nvmm_ctl |= BIT(1);\r\nif ((val & EN_VMM) == EN_VMM)\r\nvmm_ctl |= BIT(2);\r\nif (vmm_ctl) {\r\nstruct sdio_cmd52 cmd;\r\ncmd.read_write = 1;\r\ncmd.function = 0;\r\ncmd.raw = 0;\r\ncmd.address = 0xf6;\r\ncmd.data = vmm_ctl;\r\nret = wilc_sdio_cmd52(wilc, &cmd);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Failed cmd52, set 0xf6 data (%d) ...\n",\r\n__LINE__);\r\ngoto _fail_;\r\n}\r\n}\r\n}\r\n}\r\nreturn 1;\r\n_fail_:\r\nreturn 0;\r\n}\r\nstatic int sdio_sync_ext(struct wilc *wilc, int nint)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\r\nu32 reg;\r\nif (nint > MAX_NUM_INT) {\r\ndev_err(&func->dev, "Too many interrupts (%d)...\n", nint);\r\nreturn 0;\r\n}\r\nif (nint > MAX_NUN_INT_THRPT_ENH2) {\r\ndev_err(&func->dev,\r\n"Cannot support more than 5 interrupts when has_thrpt_enh2=1.\n");\r\nreturn 0;\r\n}\r\ng_sdio.nint = nint;\r\nif (!sdio_read_reg(wilc, WILC_MISC, &reg)) {\r\ndev_err(&func->dev, "Failed read misc reg...\n");\r\nreturn 0;\r\n}\r\nreg &= ~BIT(8);\r\nif (!sdio_write_reg(wilc, WILC_MISC, reg)) {\r\ndev_err(&func->dev, "Failed write misc reg...\n");\r\nreturn 0;\r\n}\r\nif (g_sdio.irq_gpio) {\r\nu32 reg;\r\nint ret, i;\r\nret = sdio_read_reg(wilc, WILC_PIN_MUX_0, &reg);\r\nif (!ret) {\r\ndev_err(&func->dev, "Failed read reg (%08x)...\n",\r\nWILC_PIN_MUX_0);\r\nreturn 0;\r\n}\r\nreg |= BIT(8);\r\nret = sdio_write_reg(wilc, WILC_PIN_MUX_0, reg);\r\nif (!ret) {\r\ndev_err(&func->dev, "Failed write reg (%08x)...\n",\r\nWILC_PIN_MUX_0);\r\nreturn 0;\r\n}\r\nret = sdio_read_reg(wilc, WILC_INTR_ENABLE, &reg);\r\nif (!ret) {\r\ndev_err(&func->dev, "Failed read reg (%08x)...\n",\r\nWILC_INTR_ENABLE);\r\nreturn 0;\r\n}\r\nfor (i = 0; (i < 5) && (nint > 0); i++, nint--)\r\nreg |= BIT((27 + i));\r\nret = sdio_write_reg(wilc, WILC_INTR_ENABLE, reg);\r\nif (!ret) {\r\ndev_err(&func->dev, "Failed write reg (%08x)...\n",\r\nWILC_INTR_ENABLE);\r\nreturn 0;\r\n}\r\nif (nint) {\r\nret = sdio_read_reg(wilc, WILC_INTR2_ENABLE, &reg);\r\nif (!ret) {\r\ndev_err(&func->dev,\r\n"Failed read reg (%08x)...\n",\r\nWILC_INTR2_ENABLE);\r\nreturn 0;\r\n}\r\nfor (i = 0; (i < 3) && (nint > 0); i++, nint--)\r\nreg |= BIT(i);\r\nret = sdio_read_reg(wilc, WILC_INTR2_ENABLE, &reg);\r\nif (!ret) {\r\ndev_err(&func->dev,\r\n"Failed write reg (%08x)...\n",\r\nWILC_INTR2_ENABLE);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}
