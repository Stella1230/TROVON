static unsigned bitbang_txrx_8(\r\nstruct spi_device *spi,\r\nu32 (*txrx_word)(struct spi_device *spi,\r\nunsigned nsecs,\r\nu32 word, u8 bits),\r\nunsigned ns,\r\nstruct spi_transfer *t\r\n) {\r\nunsigned bits = t->bits_per_word;\r\nunsigned count = t->len;\r\nconst u8 *tx = t->tx_buf;\r\nu8 *rx = t->rx_buf;\r\nwhile (likely(count > 0)) {\r\nu8 word = 0;\r\nif (tx)\r\nword = *tx++;\r\nword = txrx_word(spi, ns, word, bits);\r\nif (rx)\r\n*rx++ = word;\r\ncount -= 1;\r\n}\r\nreturn t->len - count;\r\n}\r\nstatic unsigned bitbang_txrx_16(\r\nstruct spi_device *spi,\r\nu32 (*txrx_word)(struct spi_device *spi,\r\nunsigned nsecs,\r\nu32 word, u8 bits),\r\nunsigned ns,\r\nstruct spi_transfer *t\r\n) {\r\nunsigned bits = t->bits_per_word;\r\nunsigned count = t->len;\r\nconst u16 *tx = t->tx_buf;\r\nu16 *rx = t->rx_buf;\r\nwhile (likely(count > 1)) {\r\nu16 word = 0;\r\nif (tx)\r\nword = *tx++;\r\nword = txrx_word(spi, ns, word, bits);\r\nif (rx)\r\n*rx++ = word;\r\ncount -= 2;\r\n}\r\nreturn t->len - count;\r\n}\r\nstatic unsigned bitbang_txrx_32(\r\nstruct spi_device *spi,\r\nu32 (*txrx_word)(struct spi_device *spi,\r\nunsigned nsecs,\r\nu32 word, u8 bits),\r\nunsigned ns,\r\nstruct spi_transfer *t\r\n) {\r\nunsigned bits = t->bits_per_word;\r\nunsigned count = t->len;\r\nconst u32 *tx = t->tx_buf;\r\nu32 *rx = t->rx_buf;\r\nwhile (likely(count > 3)) {\r\nu32 word = 0;\r\nif (tx)\r\nword = *tx++;\r\nword = txrx_word(spi, ns, word, bits);\r\nif (rx)\r\n*rx++ = word;\r\ncount -= 4;\r\n}\r\nreturn t->len - count;\r\n}\r\nint spi_bitbang_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct spi_bitbang_cs *cs = spi->controller_state;\r\nu8 bits_per_word;\r\nu32 hz;\r\nif (t) {\r\nbits_per_word = t->bits_per_word;\r\nhz = t->speed_hz;\r\n} else {\r\nbits_per_word = 0;\r\nhz = 0;\r\n}\r\nif (!bits_per_word)\r\nbits_per_word = spi->bits_per_word;\r\nif (bits_per_word <= 8)\r\ncs->txrx_bufs = bitbang_txrx_8;\r\nelse if (bits_per_word <= 16)\r\ncs->txrx_bufs = bitbang_txrx_16;\r\nelse if (bits_per_word <= 32)\r\ncs->txrx_bufs = bitbang_txrx_32;\r\nelse\r\nreturn -EINVAL;\r\nif (!hz)\r\nhz = spi->max_speed_hz;\r\nif (hz) {\r\ncs->nsecs = (1000000000/2) / hz;\r\nif (cs->nsecs > (MAX_UDELAY_MS * 1000 * 1000))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint spi_bitbang_setup(struct spi_device *spi)\r\n{\r\nstruct spi_bitbang_cs *cs = spi->controller_state;\r\nstruct spi_bitbang *bitbang;\r\nbitbang = spi_master_get_devdata(spi->master);\r\nif (!cs) {\r\ncs = kzalloc(sizeof(*cs), GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\nspi->controller_state = cs;\r\n}\r\ncs->txrx_word = bitbang->txrx_word[spi->mode & (SPI_CPOL|SPI_CPHA)];\r\nif (!cs->txrx_word)\r\nreturn -EINVAL;\r\nif (bitbang->setup_transfer) {\r\nint retval = bitbang->setup_transfer(spi, NULL);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\ndev_dbg(&spi->dev, "%s, %u nsec/bit\n", __func__, 2 * cs->nsecs);\r\nmutex_lock(&bitbang->lock);\r\nif (!bitbang->busy) {\r\nbitbang->chipselect(spi, BITBANG_CS_INACTIVE);\r\nndelay(cs->nsecs);\r\n}\r\nmutex_unlock(&bitbang->lock);\r\nreturn 0;\r\n}\r\nvoid spi_bitbang_cleanup(struct spi_device *spi)\r\n{\r\nkfree(spi->controller_state);\r\n}\r\nstatic int spi_bitbang_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct spi_bitbang_cs *cs = spi->controller_state;\r\nunsigned nsecs = cs->nsecs;\r\nreturn cs->txrx_bufs(spi, cs->txrx_word, nsecs, t);\r\n}\r\nstatic int spi_bitbang_prepare_hardware(struct spi_master *spi)\r\n{\r\nstruct spi_bitbang *bitbang;\r\nbitbang = spi_master_get_devdata(spi);\r\nmutex_lock(&bitbang->lock);\r\nbitbang->busy = 1;\r\nmutex_unlock(&bitbang->lock);\r\nreturn 0;\r\n}\r\nstatic int spi_bitbang_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct spi_bitbang *bitbang = spi_master_get_devdata(master);\r\nint status = 0;\r\nif (bitbang->setup_transfer) {\r\nstatus = bitbang->setup_transfer(spi, transfer);\r\nif (status < 0)\r\ngoto out;\r\n}\r\nif (transfer->len)\r\nstatus = bitbang->txrx_bufs(spi, transfer);\r\nif (status == transfer->len)\r\nstatus = 0;\r\nelse if (status >= 0)\r\nstatus = -EREMOTEIO;\r\nout:\r\nspi_finalize_current_transfer(master);\r\nreturn status;\r\n}\r\nstatic int spi_bitbang_unprepare_hardware(struct spi_master *spi)\r\n{\r\nstruct spi_bitbang *bitbang;\r\nbitbang = spi_master_get_devdata(spi);\r\nmutex_lock(&bitbang->lock);\r\nbitbang->busy = 0;\r\nmutex_unlock(&bitbang->lock);\r\nreturn 0;\r\n}\r\nstatic void spi_bitbang_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nstruct spi_bitbang *bitbang = spi_master_get_devdata(spi->master);\r\nenable = (!!(spi->mode & SPI_CS_HIGH) == enable);\r\nndelay(SPI_BITBANG_CS_DELAY);\r\nbitbang->chipselect(spi, enable ? BITBANG_CS_ACTIVE :\r\nBITBANG_CS_INACTIVE);\r\nndelay(SPI_BITBANG_CS_DELAY);\r\n}\r\nint spi_bitbang_start(struct spi_bitbang *bitbang)\r\n{\r\nstruct spi_master *master = bitbang->master;\r\nint ret;\r\nif (!master || !bitbang->chipselect)\r\nreturn -EINVAL;\r\nmutex_init(&bitbang->lock);\r\nif (!master->mode_bits)\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | bitbang->flags;\r\nif (master->transfer || master->transfer_one_message)\r\nreturn -EINVAL;\r\nmaster->prepare_transfer_hardware = spi_bitbang_prepare_hardware;\r\nmaster->unprepare_transfer_hardware = spi_bitbang_unprepare_hardware;\r\nmaster->transfer_one = spi_bitbang_transfer_one;\r\nmaster->set_cs = spi_bitbang_set_cs;\r\nif (!bitbang->txrx_bufs) {\r\nbitbang->use_dma = 0;\r\nbitbang->txrx_bufs = spi_bitbang_bufs;\r\nif (!master->setup) {\r\nif (!bitbang->setup_transfer)\r\nbitbang->setup_transfer =\r\nspi_bitbang_setup_transfer;\r\nmaster->setup = spi_bitbang_setup;\r\nmaster->cleanup = spi_bitbang_cleanup;\r\n}\r\n}\r\nret = spi_register_master(spi_master_get(master));\r\nif (ret)\r\nspi_master_put(master);\r\nreturn 0;\r\n}\r\nvoid spi_bitbang_stop(struct spi_bitbang *bitbang)\r\n{\r\nspi_unregister_master(bitbang->master);\r\n}
