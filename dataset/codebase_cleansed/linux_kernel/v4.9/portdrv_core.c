static int __init pciehp_setup(char *str)\r\n{\r\nif (!strncmp(str, "nomsi", 5))\r\npciehp_msi_disabled = true;\r\nreturn 1;\r\n}\r\nstatic void release_pcie_device(struct device *dev)\r\n{\r\nkfree(to_pcie_device(dev));\r\n}\r\nstatic int pcie_port_msix_add_entry(\r\nstruct msix_entry *entries, int new_entry, int nr_entries)\r\n{\r\nint j;\r\nfor (j = 0; j < nr_entries; j++)\r\nif (entries[j].entry == new_entry)\r\nreturn j;\r\nentries[j].entry = new_entry;\r\nreturn j;\r\n}\r\nstatic int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)\r\n{\r\nstruct msix_entry *msix_entries;\r\nint idx[PCIE_PORT_DEVICE_MAXSERVICES];\r\nint nr_entries, status, pos, i, nvec;\r\nu16 reg16;\r\nu32 reg32;\r\nnr_entries = pci_msix_vec_count(dev);\r\nif (nr_entries < 0)\r\nreturn nr_entries;\r\nBUG_ON(!nr_entries);\r\nif (nr_entries > PCIE_PORT_MAX_MSIX_ENTRIES)\r\nnr_entries = PCIE_PORT_MAX_MSIX_ENTRIES;\r\nmsix_entries = kzalloc(sizeof(*msix_entries) * nr_entries, GFP_KERNEL);\r\nif (!msix_entries)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nr_entries; i++)\r\nmsix_entries[i].entry = i;\r\nstatus = pci_enable_msix_exact(dev, msix_entries, nr_entries);\r\nif (status)\r\ngoto Exit;\r\nfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)\r\nidx[i] = -1;\r\nstatus = -EIO;\r\nnvec = 0;\r\nif (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {\r\nint entry;\r\npcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);\r\nentry = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;\r\nif (entry >= nr_entries)\r\ngoto Error;\r\ni = pcie_port_msix_add_entry(msix_entries, entry, nvec);\r\nif (i == nvec)\r\nnvec++;\r\nidx[PCIE_PORT_SERVICE_PME_SHIFT] = i;\r\nidx[PCIE_PORT_SERVICE_HP_SHIFT] = i;\r\n}\r\nif (mask & PCIE_PORT_SERVICE_AER) {\r\nint entry;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\npci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);\r\nentry = reg32 >> 27;\r\nif (entry >= nr_entries)\r\ngoto Error;\r\ni = pcie_port_msix_add_entry(msix_entries, entry, nvec);\r\nif (i == nvec)\r\nnvec++;\r\nidx[PCIE_PORT_SERVICE_AER_SHIFT] = i;\r\n}\r\nif (nvec == nr_entries) {\r\nstatus = 0;\r\n} else {\r\npci_disable_msix(dev);\r\nstatus = pci_enable_msix_exact(dev, msix_entries, nvec);\r\nif (status)\r\ngoto Exit;\r\n}\r\nfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)\r\nvectors[i] = idx[i] >= 0 ? msix_entries[idx[i]].vector : -1;\r\nExit:\r\nkfree(msix_entries);\r\nreturn status;\r\nError:\r\npci_disable_msix(dev);\r\ngoto Exit;\r\n}\r\nstatic int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)\r\n{\r\nint i, irq = -1;\r\nif (((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi()) ||\r\n((mask & PCIE_PORT_SERVICE_HP) && pciehp_no_msi())) {\r\nif (dev->irq)\r\nirq = dev->irq;\r\ngoto no_msi;\r\n}\r\nif (!pcie_port_enable_msix(dev, irqs, mask))\r\nreturn 0;\r\nif (!pci_enable_msi(dev) || dev->irq)\r\nirq = dev->irq;\r\nno_msi:\r\nfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)\r\nirqs[i] = irq;\r\nirqs[PCIE_PORT_SERVICE_VC_SHIFT] = -1;\r\nif (irq < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void cleanup_service_irqs(struct pci_dev *dev)\r\n{\r\nif (dev->msix_enabled)\r\npci_disable_msix(dev);\r\nelse if (dev->msi_enabled)\r\npci_disable_msi(dev);\r\n}\r\nstatic int get_port_device_capability(struct pci_dev *dev)\r\n{\r\nint services = 0;\r\nint cap_mask = 0;\r\nif (pcie_ports_disabled)\r\nreturn 0;\r\ncap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP\r\n| PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_DPC;\r\nif (pci_aer_available())\r\ncap_mask |= PCIE_PORT_SERVICE_AER;\r\nif (pcie_ports_auto)\r\npcie_port_platform_notify(dev, &cap_mask);\r\nif ((cap_mask & PCIE_PORT_SERVICE_HP) && dev->is_hotplug_bridge) {\r\nservices |= PCIE_PORT_SERVICE_HP;\r\npcie_capability_clear_word(dev, PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);\r\n}\r\nif ((cap_mask & PCIE_PORT_SERVICE_AER)\r\n&& pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR)) {\r\nservices |= PCIE_PORT_SERVICE_AER;\r\npci_disable_pcie_error_reporting(dev);\r\n}\r\nif (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))\r\nservices |= PCIE_PORT_SERVICE_VC;\r\nif ((cap_mask & PCIE_PORT_SERVICE_PME)\r\n&& pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {\r\nservices |= PCIE_PORT_SERVICE_PME;\r\npcie_pme_interrupt_enable(dev, false);\r\n}\r\nif (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC))\r\nservices |= PCIE_PORT_SERVICE_DPC;\r\nreturn services;\r\n}\r\nstatic int pcie_device_init(struct pci_dev *pdev, int service, int irq)\r\n{\r\nint retval;\r\nstruct pcie_device *pcie;\r\nstruct device *device;\r\npcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\npcie->port = pdev;\r\npcie->irq = irq;\r\npcie->service = service;\r\ndevice = &pcie->device;\r\ndevice->bus = &pcie_port_bus_type;\r\ndevice->release = release_pcie_device;\r\ndev_set_name(device, "%s:pcie%03x",\r\npci_name(pdev),\r\nget_descriptor_id(pci_pcie_type(pdev), service));\r\ndevice->parent = &pdev->dev;\r\ndevice_enable_async_suspend(device);\r\nretval = device_register(device);\r\nif (retval) {\r\nput_device(device);\r\nreturn retval;\r\n}\r\npm_runtime_no_callbacks(device);\r\nreturn 0;\r\n}\r\nint pcie_port_device_register(struct pci_dev *dev)\r\n{\r\nint status, capabilities, i, nr_service;\r\nint irqs[PCIE_PORT_DEVICE_MAXSERVICES];\r\nstatus = pci_enable_device(dev);\r\nif (status)\r\nreturn status;\r\ncapabilities = get_port_device_capability(dev);\r\nif (!capabilities)\r\nreturn 0;\r\npci_set_master(dev);\r\nstatus = init_service_irqs(dev, irqs, capabilities);\r\nif (status) {\r\ncapabilities &= PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_HP;\r\nif (!capabilities)\r\ngoto error_disable;\r\n}\r\nstatus = -ENODEV;\r\nnr_service = 0;\r\nfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {\r\nint service = 1 << i;\r\nif (!(capabilities & service))\r\ncontinue;\r\nif (!pcie_device_init(dev, service, irqs[i]))\r\nnr_service++;\r\n}\r\nif (!nr_service)\r\ngoto error_cleanup_irqs;\r\nreturn 0;\r\nerror_cleanup_irqs:\r\ncleanup_service_irqs(dev);\r\nerror_disable:\r\npci_disable_device(dev);\r\nreturn status;\r\n}\r\nstatic int suspend_iter(struct device *dev, void *data)\r\n{\r\nstruct pcie_port_service_driver *service_driver;\r\nif ((dev->bus == &pcie_port_bus_type) && dev->driver) {\r\nservice_driver = to_service_driver(dev->driver);\r\nif (service_driver->suspend)\r\nservice_driver->suspend(to_pcie_device(dev));\r\n}\r\nreturn 0;\r\n}\r\nint pcie_port_device_suspend(struct device *dev)\r\n{\r\nreturn device_for_each_child(dev, NULL, suspend_iter);\r\n}\r\nstatic int resume_iter(struct device *dev, void *data)\r\n{\r\nstruct pcie_port_service_driver *service_driver;\r\nif ((dev->bus == &pcie_port_bus_type) &&\r\n(dev->driver)) {\r\nservice_driver = to_service_driver(dev->driver);\r\nif (service_driver->resume)\r\nservice_driver->resume(to_pcie_device(dev));\r\n}\r\nreturn 0;\r\n}\r\nint pcie_port_device_resume(struct device *dev)\r\n{\r\nreturn device_for_each_child(dev, NULL, resume_iter);\r\n}\r\nstatic int remove_iter(struct device *dev, void *data)\r\n{\r\nif (dev->bus == &pcie_port_bus_type)\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nvoid pcie_port_device_remove(struct pci_dev *dev)\r\n{\r\ndevice_for_each_child(&dev->dev, NULL, remove_iter);\r\ncleanup_service_irqs(dev);\r\npci_disable_device(dev);\r\n}\r\nstatic int pcie_port_probe_service(struct device *dev)\r\n{\r\nstruct pcie_device *pciedev;\r\nstruct pcie_port_service_driver *driver;\r\nint status;\r\nif (!dev || !dev->driver)\r\nreturn -ENODEV;\r\ndriver = to_service_driver(dev->driver);\r\nif (!driver || !driver->probe)\r\nreturn -ENODEV;\r\npciedev = to_pcie_device(dev);\r\nstatus = driver->probe(pciedev);\r\nif (status)\r\nreturn status;\r\ndev_printk(KERN_DEBUG, dev, "service driver %s loaded\n", driver->name);\r\nget_device(dev);\r\nreturn 0;\r\n}\r\nstatic int pcie_port_remove_service(struct device *dev)\r\n{\r\nstruct pcie_device *pciedev;\r\nstruct pcie_port_service_driver *driver;\r\nif (!dev || !dev->driver)\r\nreturn 0;\r\npciedev = to_pcie_device(dev);\r\ndriver = to_service_driver(dev->driver);\r\nif (driver && driver->remove) {\r\ndev_printk(KERN_DEBUG, dev, "unloading service driver %s\n",\r\ndriver->name);\r\ndriver->remove(pciedev);\r\nput_device(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_port_shutdown_service(struct device *dev) {}\r\nint pcie_port_service_register(struct pcie_port_service_driver *new)\r\n{\r\nif (pcie_ports_disabled)\r\nreturn -ENODEV;\r\nnew->driver.name = new->name;\r\nnew->driver.bus = &pcie_port_bus_type;\r\nnew->driver.probe = pcie_port_probe_service;\r\nnew->driver.remove = pcie_port_remove_service;\r\nnew->driver.shutdown = pcie_port_shutdown_service;\r\nreturn driver_register(&new->driver);\r\n}\r\nvoid pcie_port_service_unregister(struct pcie_port_service_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}
