static inline void\r\nmv_cesa_ablkcipher_req_iter_init(struct mv_cesa_ablkcipher_dma_iter *iter,\r\nstruct ablkcipher_request *req)\r\n{\r\nmv_cesa_req_dma_iter_init(&iter->base, req->nbytes);\r\nmv_cesa_sg_dma_iter_init(&iter->src, req->src, DMA_TO_DEVICE);\r\nmv_cesa_sg_dma_iter_init(&iter->dst, req->dst, DMA_FROM_DEVICE);\r\n}\r\nstatic inline bool\r\nmv_cesa_ablkcipher_req_iter_next_op(struct mv_cesa_ablkcipher_dma_iter *iter)\r\n{\r\niter->src.op_offset = 0;\r\niter->dst.op_offset = 0;\r\nreturn mv_cesa_req_dma_iter_next_op(&iter->base);\r\n}\r\nstatic inline void\r\nmv_cesa_ablkcipher_dma_cleanup(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nif (req->dst != req->src) {\r\ndma_unmap_sg(cesa_dev->dev, req->dst, creq->dst_nents,\r\nDMA_FROM_DEVICE);\r\ndma_unmap_sg(cesa_dev->dev, req->src, creq->src_nents,\r\nDMA_TO_DEVICE);\r\n} else {\r\ndma_unmap_sg(cesa_dev->dev, req->src, creq->src_nents,\r\nDMA_BIDIRECTIONAL);\r\n}\r\nmv_cesa_dma_cleanup(&creq->base);\r\n}\r\nstatic inline void mv_cesa_ablkcipher_cleanup(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\r\nmv_cesa_ablkcipher_dma_cleanup(req);\r\n}\r\nstatic void mv_cesa_ablkcipher_std_step(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nstruct mv_cesa_ablkcipher_std_req *sreq = &creq->std;\r\nstruct mv_cesa_engine *engine = creq->base.engine;\r\nsize_t len = min_t(size_t, req->nbytes - sreq->offset,\r\nCESA_SA_SRAM_PAYLOAD_SIZE);\r\nmv_cesa_adjust_op(engine, &sreq->op);\r\nmemcpy_toio(engine->sram, &sreq->op, sizeof(sreq->op));\r\nlen = sg_pcopy_to_buffer(req->src, creq->src_nents,\r\nengine->sram + CESA_SA_DATA_SRAM_OFFSET,\r\nlen, sreq->offset);\r\nsreq->size = len;\r\nmv_cesa_set_crypt_op_len(&sreq->op, len);\r\nif (!sreq->skip_ctx) {\r\nmemcpy_toio(engine->sram, &sreq->op, sizeof(sreq->op));\r\nsreq->skip_ctx = true;\r\n} else {\r\nmemcpy_toio(engine->sram, &sreq->op, sizeof(sreq->op.desc));\r\n}\r\nmv_cesa_set_int_mask(engine, CESA_SA_INT_ACCEL0_DONE);\r\nwritel_relaxed(CESA_SA_CFG_PARA_DIS, engine->regs + CESA_SA_CFG);\r\nBUG_ON(readl(engine->regs + CESA_SA_CMD) &\r\nCESA_SA_CMD_EN_CESA_SA_ACCL0);\r\nwritel(CESA_SA_CMD_EN_CESA_SA_ACCL0, engine->regs + CESA_SA_CMD);\r\n}\r\nstatic int mv_cesa_ablkcipher_std_process(struct ablkcipher_request *req,\r\nu32 status)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nstruct mv_cesa_ablkcipher_std_req *sreq = &creq->std;\r\nstruct mv_cesa_engine *engine = creq->base.engine;\r\nsize_t len;\r\nlen = sg_pcopy_from_buffer(req->dst, creq->dst_nents,\r\nengine->sram + CESA_SA_DATA_SRAM_OFFSET,\r\nsreq->size, sreq->offset);\r\nsreq->offset += len;\r\nif (sreq->offset < req->nbytes)\r\nreturn -EINPROGRESS;\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ablkcipher_process(struct crypto_async_request *req,\r\nu32 status)\r\n{\r\nstruct ablkcipher_request *ablkreq = ablkcipher_request_cast(req);\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(ablkreq);\r\nstruct mv_cesa_req *basereq = &creq->base;\r\nif (mv_cesa_req_get_type(basereq) == CESA_STD_REQ)\r\nreturn mv_cesa_ablkcipher_std_process(ablkreq, status);\r\nreturn mv_cesa_dma_process(basereq, status);\r\n}\r\nstatic void mv_cesa_ablkcipher_step(struct crypto_async_request *req)\r\n{\r\nstruct ablkcipher_request *ablkreq = ablkcipher_request_cast(req);\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(ablkreq);\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\r\nmv_cesa_dma_step(&creq->base);\r\nelse\r\nmv_cesa_ablkcipher_std_step(ablkreq);\r\n}\r\nstatic inline void\r\nmv_cesa_ablkcipher_dma_prepare(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nstruct mv_cesa_req *basereq = &creq->base;\r\nmv_cesa_dma_prepare(basereq, basereq->engine);\r\n}\r\nstatic inline void\r\nmv_cesa_ablkcipher_std_prepare(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nstruct mv_cesa_ablkcipher_std_req *sreq = &creq->std;\r\nsreq->size = 0;\r\nsreq->offset = 0;\r\n}\r\nstatic inline void mv_cesa_ablkcipher_prepare(struct crypto_async_request *req,\r\nstruct mv_cesa_engine *engine)\r\n{\r\nstruct ablkcipher_request *ablkreq = ablkcipher_request_cast(req);\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(ablkreq);\r\ncreq->base.engine = engine;\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\r\nmv_cesa_ablkcipher_dma_prepare(ablkreq);\r\nelse\r\nmv_cesa_ablkcipher_std_prepare(ablkreq);\r\n}\r\nstatic inline void\r\nmv_cesa_ablkcipher_req_cleanup(struct crypto_async_request *req)\r\n{\r\nstruct ablkcipher_request *ablkreq = ablkcipher_request_cast(req);\r\nmv_cesa_ablkcipher_cleanup(ablkreq);\r\n}\r\nstatic void\r\nmv_cesa_ablkcipher_complete(struct crypto_async_request *req)\r\n{\r\nstruct ablkcipher_request *ablkreq = ablkcipher_request_cast(req);\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(ablkreq);\r\nstruct mv_cesa_engine *engine = creq->base.engine;\r\nunsigned int ivsize;\r\natomic_sub(ablkreq->nbytes, &engine->load);\r\nivsize = crypto_ablkcipher_ivsize(crypto_ablkcipher_reqtfm(ablkreq));\r\nif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ) {\r\nstruct mv_cesa_req *basereq;\r\nbasereq = &creq->base;\r\nmemcpy(ablkreq->info, basereq->chain.last->data, ivsize);\r\n} else {\r\nmemcpy_fromio(ablkreq->info,\r\nengine->sram + CESA_SA_CRYPT_IV_SRAM_OFFSET,\r\nivsize);\r\n}\r\n}\r\nstatic int mv_cesa_ablkcipher_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct mv_cesa_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->base.ops = &mv_cesa_ablkcipher_req_ops;\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct mv_cesa_ablkcipher_req);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_aes_setkey(struct crypto_ablkcipher *cipher, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct mv_cesa_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint remaining;\r\nint offset;\r\nint ret;\r\nint i;\r\nret = crypto_aes_expand_key(&ctx->aes, key, len);\r\nif (ret) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn ret;\r\n}\r\nremaining = (ctx->aes.key_length - 16) / 4;\r\noffset = ctx->aes.key_length + 24 - remaining;\r\nfor (i = 0; i < remaining; i++)\r\nctx->aes.key_dec[4 + i] =\r\ncpu_to_le32(ctx->aes.key_enc[offset + i]);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_des_setkey(struct crypto_ablkcipher *cipher, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct mv_cesa_des_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 tmp[DES_EXPKEY_WORDS];\r\nint ret;\r\nif (len != DES_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nret = des_ekey(tmp, key);\r\nif (!ret && (tfm->crt_flags & CRYPTO_TFM_REQ_WEAK_KEY)) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, DES_KEY_SIZE);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_des3_ede_setkey(struct crypto_ablkcipher *cipher,\r\nconst u8 *key, unsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct mv_cesa_des_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (len != DES3_EDE_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, DES3_EDE_KEY_SIZE);\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ablkcipher_dma_req_init(struct ablkcipher_request *req,\r\nconst struct mv_cesa_op_ctx *op_templ)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\ngfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\r\nGFP_KERNEL : GFP_ATOMIC;\r\nstruct mv_cesa_req *basereq = &creq->base;\r\nstruct mv_cesa_ablkcipher_dma_iter iter;\r\nbool skip_ctx = false;\r\nint ret;\r\nunsigned int ivsize;\r\nbasereq->chain.first = NULL;\r\nbasereq->chain.last = NULL;\r\nif (req->src != req->dst) {\r\nret = dma_map_sg(cesa_dev->dev, req->src, creq->src_nents,\r\nDMA_TO_DEVICE);\r\nif (!ret)\r\nreturn -ENOMEM;\r\nret = dma_map_sg(cesa_dev->dev, req->dst, creq->dst_nents,\r\nDMA_FROM_DEVICE);\r\nif (!ret) {\r\nret = -ENOMEM;\r\ngoto err_unmap_src;\r\n}\r\n} else {\r\nret = dma_map_sg(cesa_dev->dev, req->src, creq->src_nents,\r\nDMA_BIDIRECTIONAL);\r\nif (!ret)\r\nreturn -ENOMEM;\r\n}\r\nmv_cesa_tdma_desc_iter_init(&basereq->chain);\r\nmv_cesa_ablkcipher_req_iter_init(&iter, req);\r\ndo {\r\nstruct mv_cesa_op_ctx *op;\r\nop = mv_cesa_dma_add_op(&basereq->chain, op_templ, skip_ctx, flags);\r\nif (IS_ERR(op)) {\r\nret = PTR_ERR(op);\r\ngoto err_free_tdma;\r\n}\r\nskip_ctx = true;\r\nmv_cesa_set_crypt_op_len(op, iter.base.op_len);\r\nret = mv_cesa_dma_add_op_transfers(&basereq->chain, &iter.base,\r\n&iter.src, flags);\r\nif (ret)\r\ngoto err_free_tdma;\r\nret = mv_cesa_dma_add_dummy_launch(&basereq->chain, flags);\r\nif (ret)\r\ngoto err_free_tdma;\r\nret = mv_cesa_dma_add_op_transfers(&basereq->chain, &iter.base,\r\n&iter.dst, flags);\r\nif (ret)\r\ngoto err_free_tdma;\r\n} while (mv_cesa_ablkcipher_req_iter_next_op(&iter));\r\nivsize = crypto_ablkcipher_ivsize(crypto_ablkcipher_reqtfm(req));\r\nret = mv_cesa_dma_add_iv_op(&basereq->chain, CESA_SA_CRYPT_IV_SRAM_OFFSET,\r\nivsize, CESA_TDMA_SRC_IN_SRAM, flags);\r\nif (ret)\r\ngoto err_free_tdma;\r\nbasereq->chain.last->flags |= CESA_TDMA_END_OF_REQ;\r\nreturn 0;\r\nerr_free_tdma:\r\nmv_cesa_dma_cleanup(basereq);\r\nif (req->dst != req->src)\r\ndma_unmap_sg(cesa_dev->dev, req->dst, creq->dst_nents,\r\nDMA_FROM_DEVICE);\r\nerr_unmap_src:\r\ndma_unmap_sg(cesa_dev->dev, req->src, creq->src_nents,\r\nreq->dst != req->src ? DMA_TO_DEVICE : DMA_BIDIRECTIONAL);\r\nreturn ret;\r\n}\r\nstatic inline int\r\nmv_cesa_ablkcipher_std_req_init(struct ablkcipher_request *req,\r\nconst struct mv_cesa_op_ctx *op_templ)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nstruct mv_cesa_ablkcipher_std_req *sreq = &creq->std;\r\nstruct mv_cesa_req *basereq = &creq->base;\r\nsreq->op = *op_templ;\r\nsreq->skip_ctx = false;\r\nbasereq->chain.first = NULL;\r\nbasereq->chain.last = NULL;\r\nreturn 0;\r\n}\r\nstatic int mv_cesa_ablkcipher_req_init(struct ablkcipher_request *req,\r\nstruct mv_cesa_op_ctx *tmpl)\r\n{\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);\r\nunsigned int blksize = crypto_ablkcipher_blocksize(tfm);\r\nint ret;\r\nif (!IS_ALIGNED(req->nbytes, blksize))\r\nreturn -EINVAL;\r\ncreq->src_nents = sg_nents_for_len(req->src, req->nbytes);\r\nif (creq->src_nents < 0) {\r\ndev_err(cesa_dev->dev, "Invalid number of src SG");\r\nreturn creq->src_nents;\r\n}\r\ncreq->dst_nents = sg_nents_for_len(req->dst, req->nbytes);\r\nif (creq->dst_nents < 0) {\r\ndev_err(cesa_dev->dev, "Invalid number of dst SG");\r\nreturn creq->dst_nents;\r\n}\r\nmv_cesa_update_op_cfg(tmpl, CESA_SA_DESC_CFG_OP_CRYPT_ONLY,\r\nCESA_SA_DESC_CFG_OP_MSK);\r\nif (cesa_dev->caps->has_tdma)\r\nret = mv_cesa_ablkcipher_dma_req_init(req, tmpl);\r\nelse\r\nret = mv_cesa_ablkcipher_std_req_init(req, tmpl);\r\nreturn ret;\r\n}\r\nstatic int mv_cesa_ablkcipher_queue_req(struct ablkcipher_request *req,\r\nstruct mv_cesa_op_ctx *tmpl)\r\n{\r\nint ret;\r\nstruct mv_cesa_ablkcipher_req *creq = ablkcipher_request_ctx(req);\r\nstruct mv_cesa_engine *engine;\r\nret = mv_cesa_ablkcipher_req_init(req, tmpl);\r\nif (ret)\r\nreturn ret;\r\nengine = mv_cesa_select_engine(req->nbytes);\r\nmv_cesa_ablkcipher_prepare(&req->base, engine);\r\nret = mv_cesa_queue_req(&req->base, &creq->base);\r\nif (mv_cesa_req_needs_cleanup(&req->base, ret))\r\nmv_cesa_ablkcipher_cleanup(req);\r\nreturn ret;\r\n}\r\nstatic int mv_cesa_des_op(struct ablkcipher_request *req,\r\nstruct mv_cesa_op_ctx *tmpl)\r\n{\r\nstruct mv_cesa_des_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nmv_cesa_update_op_cfg(tmpl, CESA_SA_DESC_CFG_CRYPTM_DES,\r\nCESA_SA_DESC_CFG_CRYPTM_MSK);\r\nmemcpy(tmpl->ctx.blkcipher.key, ctx->key, DES_KEY_SIZE);\r\nreturn mv_cesa_ablkcipher_queue_req(req, tmpl);\r\n}\r\nstatic int mv_cesa_ecb_des_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl,\r\nCESA_SA_DESC_CFG_CRYPTCM_ECB |\r\nCESA_SA_DESC_CFG_DIR_ENC);\r\nreturn mv_cesa_des_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_ecb_des_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl,\r\nCESA_SA_DESC_CFG_CRYPTCM_ECB |\r\nCESA_SA_DESC_CFG_DIR_DEC);\r\nreturn mv_cesa_des_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_cbc_des_op(struct ablkcipher_request *req,\r\nstruct mv_cesa_op_ctx *tmpl)\r\n{\r\nmv_cesa_update_op_cfg(tmpl, CESA_SA_DESC_CFG_CRYPTCM_CBC,\r\nCESA_SA_DESC_CFG_CRYPTCM_MSK);\r\nmemcpy(tmpl->ctx.blkcipher.iv, req->info, DES_BLOCK_SIZE);\r\nreturn mv_cesa_des_op(req, tmpl);\r\n}\r\nstatic int mv_cesa_cbc_des_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_DIR_ENC);\r\nreturn mv_cesa_cbc_des_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_cbc_des_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_DIR_DEC);\r\nreturn mv_cesa_cbc_des_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_des3_op(struct ablkcipher_request *req,\r\nstruct mv_cesa_op_ctx *tmpl)\r\n{\r\nstruct mv_cesa_des3_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nmv_cesa_update_op_cfg(tmpl, CESA_SA_DESC_CFG_CRYPTM_3DES,\r\nCESA_SA_DESC_CFG_CRYPTM_MSK);\r\nmemcpy(tmpl->ctx.blkcipher.key, ctx->key, DES3_EDE_KEY_SIZE);\r\nreturn mv_cesa_ablkcipher_queue_req(req, tmpl);\r\n}\r\nstatic int mv_cesa_ecb_des3_ede_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl,\r\nCESA_SA_DESC_CFG_CRYPTCM_ECB |\r\nCESA_SA_DESC_CFG_3DES_EDE |\r\nCESA_SA_DESC_CFG_DIR_ENC);\r\nreturn mv_cesa_des3_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_ecb_des3_ede_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl,\r\nCESA_SA_DESC_CFG_CRYPTCM_ECB |\r\nCESA_SA_DESC_CFG_3DES_EDE |\r\nCESA_SA_DESC_CFG_DIR_DEC);\r\nreturn mv_cesa_des3_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_cbc_des3_op(struct ablkcipher_request *req,\r\nstruct mv_cesa_op_ctx *tmpl)\r\n{\r\nmemcpy(tmpl->ctx.blkcipher.iv, req->info, DES3_EDE_BLOCK_SIZE);\r\nreturn mv_cesa_des3_op(req, tmpl);\r\n}\r\nstatic int mv_cesa_cbc_des3_ede_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl,\r\nCESA_SA_DESC_CFG_CRYPTCM_CBC |\r\nCESA_SA_DESC_CFG_3DES_EDE |\r\nCESA_SA_DESC_CFG_DIR_ENC);\r\nreturn mv_cesa_cbc_des3_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_cbc_des3_ede_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl,\r\nCESA_SA_DESC_CFG_CRYPTCM_CBC |\r\nCESA_SA_DESC_CFG_3DES_EDE |\r\nCESA_SA_DESC_CFG_DIR_DEC);\r\nreturn mv_cesa_cbc_des3_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_aes_op(struct ablkcipher_request *req,\r\nstruct mv_cesa_op_ctx *tmpl)\r\n{\r\nstruct mv_cesa_aes_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nint i;\r\nu32 *key;\r\nu32 cfg;\r\ncfg = CESA_SA_DESC_CFG_CRYPTM_AES;\r\nif (mv_cesa_get_op_cfg(tmpl) & CESA_SA_DESC_CFG_DIR_DEC)\r\nkey = ctx->aes.key_dec;\r\nelse\r\nkey = ctx->aes.key_enc;\r\nfor (i = 0; i < ctx->aes.key_length / sizeof(u32); i++)\r\ntmpl->ctx.blkcipher.key[i] = cpu_to_le32(key[i]);\r\nif (ctx->aes.key_length == 24)\r\ncfg |= CESA_SA_DESC_CFG_AES_LEN_192;\r\nelse if (ctx->aes.key_length == 32)\r\ncfg |= CESA_SA_DESC_CFG_AES_LEN_256;\r\nmv_cesa_update_op_cfg(tmpl, cfg,\r\nCESA_SA_DESC_CFG_CRYPTM_MSK |\r\nCESA_SA_DESC_CFG_AES_LEN_MSK);\r\nreturn mv_cesa_ablkcipher_queue_req(req, tmpl);\r\n}\r\nstatic int mv_cesa_ecb_aes_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl,\r\nCESA_SA_DESC_CFG_CRYPTCM_ECB |\r\nCESA_SA_DESC_CFG_DIR_ENC);\r\nreturn mv_cesa_aes_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_ecb_aes_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl,\r\nCESA_SA_DESC_CFG_CRYPTCM_ECB |\r\nCESA_SA_DESC_CFG_DIR_DEC);\r\nreturn mv_cesa_aes_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_cbc_aes_op(struct ablkcipher_request *req,\r\nstruct mv_cesa_op_ctx *tmpl)\r\n{\r\nmv_cesa_update_op_cfg(tmpl, CESA_SA_DESC_CFG_CRYPTCM_CBC,\r\nCESA_SA_DESC_CFG_CRYPTCM_MSK);\r\nmemcpy(tmpl->ctx.blkcipher.iv, req->info, AES_BLOCK_SIZE);\r\nreturn mv_cesa_aes_op(req, tmpl);\r\n}\r\nstatic int mv_cesa_cbc_aes_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_DIR_ENC);\r\nreturn mv_cesa_cbc_aes_op(req, &tmpl);\r\n}\r\nstatic int mv_cesa_cbc_aes_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct mv_cesa_op_ctx tmpl;\r\nmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_DIR_DEC);\r\nreturn mv_cesa_cbc_aes_op(req, &tmpl);\r\n}
