void exec_cmd_init(const char *exec_name, const char *prefix,\r\nconst char *exec_path, const char *exec_path_env)\r\n{\r\nsubcmd_config.exec_name = exec_name;\r\nsubcmd_config.prefix = prefix;\r\nsubcmd_config.exec_path = exec_path;\r\nsubcmd_config.exec_path_env = exec_path_env;\r\n}\r\nstatic int is_absolute_path(const char *path)\r\n{\r\nreturn path[0] == '/';\r\n}\r\nstatic const char *get_pwd_cwd(void)\r\n{\r\nstatic char cwd[PATH_MAX + 1];\r\nchar *pwd;\r\nstruct stat cwd_stat, pwd_stat;\r\nif (getcwd(cwd, PATH_MAX) == NULL)\r\nreturn NULL;\r\npwd = getenv("PWD");\r\nif (pwd && strcmp(pwd, cwd)) {\r\nstat(cwd, &cwd_stat);\r\nif (!stat(pwd, &pwd_stat) &&\r\npwd_stat.st_dev == cwd_stat.st_dev &&\r\npwd_stat.st_ino == cwd_stat.st_ino) {\r\nstrlcpy(cwd, pwd, PATH_MAX);\r\n}\r\n}\r\nreturn cwd;\r\n}\r\nstatic const char *make_nonrelative_path(const char *path)\r\n{\r\nstatic char buf[PATH_MAX + 1];\r\nif (is_absolute_path(path)) {\r\nif (strlcpy(buf, path, PATH_MAX) >= PATH_MAX)\r\ndie("Too long path: %.*s", 60, path);\r\n} else {\r\nconst char *cwd = get_pwd_cwd();\r\nif (!cwd)\r\ndie("Cannot determine the current working directory");\r\nif (snprintf(buf, PATH_MAX, "%s/%s", cwd, path) >= PATH_MAX)\r\ndie("Too long path: %.*s", 60, path);\r\n}\r\nreturn buf;\r\n}\r\nchar *system_path(const char *path)\r\n{\r\nchar *buf = NULL;\r\nif (is_absolute_path(path))\r\nreturn strdup(path);\r\nastrcatf(&buf, "%s/%s", subcmd_config.prefix, path);\r\nreturn buf;\r\n}\r\nconst char *extract_argv0_path(const char *argv0)\r\n{\r\nconst char *slash;\r\nif (!argv0 || !*argv0)\r\nreturn NULL;\r\nslash = argv0 + strlen(argv0);\r\nwhile (argv0 <= slash && !is_dir_sep(*slash))\r\nslash--;\r\nif (slash >= argv0) {\r\nargv0_path = strndup(argv0, slash - argv0);\r\nreturn argv0_path ? slash + 1 : NULL;\r\n}\r\nreturn argv0;\r\n}\r\nvoid set_argv_exec_path(const char *exec_path)\r\n{\r\nargv_exec_path = exec_path;\r\nsetenv(subcmd_config.exec_path_env, exec_path, 1);\r\n}\r\nchar *get_argv_exec_path(void)\r\n{\r\nchar *env;\r\nif (argv_exec_path)\r\nreturn strdup(argv_exec_path);\r\nenv = getenv(subcmd_config.exec_path_env);\r\nif (env && *env)\r\nreturn strdup(env);\r\nreturn system_path(subcmd_config.exec_path);\r\n}\r\nstatic void add_path(char **out, const char *path)\r\n{\r\nif (path && *path) {\r\nif (is_absolute_path(path))\r\nastrcat(out, path);\r\nelse\r\nastrcat(out, make_nonrelative_path(path));\r\nastrcat(out, ":");\r\n}\r\n}\r\nvoid setup_path(void)\r\n{\r\nconst char *old_path = getenv("PATH");\r\nchar *new_path = NULL;\r\nchar *tmp = get_argv_exec_path();\r\nadd_path(&new_path, tmp);\r\nadd_path(&new_path, argv0_path);\r\nfree(tmp);\r\nif (old_path)\r\nastrcat(&new_path, old_path);\r\nelse\r\nastrcat(&new_path, "/usr/local/bin:/usr/bin:/bin");\r\nsetenv("PATH", new_path, 1);\r\nfree(new_path);\r\n}\r\nstatic const char **prepare_exec_cmd(const char **argv)\r\n{\r\nint argc;\r\nconst char **nargv;\r\nfor (argc = 0; argv[argc]; argc++)\r\n;\r\nnargv = malloc(sizeof(*nargv) * (argc + 2));\r\nnargv[0] = subcmd_config.exec_name;\r\nfor (argc = 0; argv[argc]; argc++)\r\nnargv[argc + 1] = argv[argc];\r\nnargv[argc + 1] = NULL;\r\nreturn nargv;\r\n}\r\nint execv_cmd(const char **argv) {\r\nconst char **nargv = prepare_exec_cmd(argv);\r\nexecvp(subcmd_config.exec_name, (char **)nargv);\r\nfree(nargv);\r\nreturn -1;\r\n}\r\nint execl_cmd(const char *cmd,...)\r\n{\r\nint argc;\r\nconst char *argv[MAX_ARGS + 1];\r\nconst char *arg;\r\nva_list param;\r\nva_start(param, cmd);\r\nargv[0] = cmd;\r\nargc = 1;\r\nwhile (argc < MAX_ARGS) {\r\narg = argv[argc++] = va_arg(param, char *);\r\nif (!arg)\r\nbreak;\r\n}\r\nva_end(param);\r\nif (MAX_ARGS <= argc) {\r\nfprintf(stderr, " Error: too many args to run %s\n", cmd);\r\nreturn -1;\r\n}\r\nargv[argc] = NULL;\r\nreturn execv_cmd(argv);\r\n}
