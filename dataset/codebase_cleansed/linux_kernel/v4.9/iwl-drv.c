static void iwl_free_fw_desc(struct iwl_drv *drv, struct fw_desc *desc)\r\n{\r\nvfree(desc->data);\r\ndesc->data = NULL;\r\ndesc->len = 0;\r\n}\r\nstatic void iwl_free_fw_img(struct iwl_drv *drv, struct fw_img *img)\r\n{\r\nint i;\r\nfor (i = 0; i < IWL_UCODE_SECTION_MAX; i++)\r\niwl_free_fw_desc(drv, &img->sec[i]);\r\n}\r\nstatic void iwl_dealloc_ucode(struct iwl_drv *drv)\r\n{\r\nint i;\r\nkfree(drv->fw.dbg_dest_tlv);\r\nfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg_conf_tlv); i++)\r\nkfree(drv->fw.dbg_conf_tlv[i]);\r\nfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg_trigger_tlv); i++)\r\nkfree(drv->fw.dbg_trigger_tlv[i]);\r\nfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg_mem_tlv); i++)\r\nkfree(drv->fw.dbg_mem_tlv[i]);\r\nfor (i = 0; i < IWL_UCODE_TYPE_MAX; i++)\r\niwl_free_fw_img(drv, drv->fw.img + i);\r\n}\r\nstatic int iwl_alloc_fw_desc(struct iwl_drv *drv, struct fw_desc *desc,\r\nstruct fw_sec *sec)\r\n{\r\nvoid *data;\r\ndesc->data = NULL;\r\nif (!sec || !sec->size)\r\nreturn -EINVAL;\r\ndata = vmalloc(sec->size);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndesc->len = sec->size;\r\ndesc->offset = sec->offset;\r\nmemcpy(data, sec->data, desc->len);\r\ndesc->data = data;\r\nreturn 0;\r\n}\r\nstatic int iwl_request_firmware(struct iwl_drv *drv, bool first)\r\n{\r\nconst char *name_pre = drv->cfg->fw_name_pre;\r\nchar tag[8];\r\nif (first) {\r\ndrv->fw_index = drv->cfg->ucode_api_max;\r\nsprintf(tag, "%d", drv->fw_index);\r\n} else {\r\ndrv->fw_index--;\r\nsprintf(tag, "%d", drv->fw_index);\r\n}\r\nif (drv->fw_index < drv->cfg->ucode_api_min) {\r\nIWL_ERR(drv, "no suitable firmware found!\n");\r\nreturn -ENOENT;\r\n}\r\nsnprintf(drv->firmware_name, sizeof(drv->firmware_name), "%s%s.ucode",\r\nname_pre, tag);\r\nIWL_DEBUG_INFO(drv, "attempting to load firmware '%s'\n",\r\ndrv->firmware_name);\r\nreturn request_firmware_nowait(THIS_MODULE, 1, drv->firmware_name,\r\ndrv->trans->dev,\r\nGFP_KERNEL, drv, iwl_req_fw_callback);\r\n}\r\nstatic struct fw_sec *get_sec(struct iwl_firmware_pieces *pieces,\r\nenum iwl_ucode_type type,\r\nint sec)\r\n{\r\nreturn &pieces->img[type].sec[sec];\r\n}\r\nstatic void set_sec_data(struct iwl_firmware_pieces *pieces,\r\nenum iwl_ucode_type type,\r\nint sec,\r\nconst void *data)\r\n{\r\npieces->img[type].sec[sec].data = data;\r\n}\r\nstatic void set_sec_size(struct iwl_firmware_pieces *pieces,\r\nenum iwl_ucode_type type,\r\nint sec,\r\nsize_t size)\r\n{\r\npieces->img[type].sec[sec].size = size;\r\n}\r\nstatic size_t get_sec_size(struct iwl_firmware_pieces *pieces,\r\nenum iwl_ucode_type type,\r\nint sec)\r\n{\r\nreturn pieces->img[type].sec[sec].size;\r\n}\r\nstatic void set_sec_offset(struct iwl_firmware_pieces *pieces,\r\nenum iwl_ucode_type type,\r\nint sec,\r\nu32 offset)\r\n{\r\npieces->img[type].sec[sec].offset = offset;\r\n}\r\nstatic int iwl_store_cscheme(struct iwl_fw *fw, const u8 *data, const u32 len)\r\n{\r\nint i, j;\r\nstruct iwl_fw_cscheme_list *l = (struct iwl_fw_cscheme_list *)data;\r\nstruct iwl_fw_cipher_scheme *fwcs;\r\nif (len < sizeof(*l) ||\r\nlen < sizeof(l->size) + l->size * sizeof(l->cs[0]))\r\nreturn -EINVAL;\r\nfor (i = 0, j = 0; i < IWL_UCODE_MAX_CS && i < l->size; i++) {\r\nfwcs = &l->cs[j];\r\nif (!fwcs->cipher)\r\ncontinue;\r\nfw->cs[j++] = *fwcs;\r\n}\r\nreturn 0;\r\n}\r\nstatic void iwl_store_gscan_capa(struct iwl_fw *fw, const u8 *data,\r\nconst u32 len)\r\n{\r\nstruct iwl_fw_gscan_capabilities *fw_capa = (void *)data;\r\nstruct iwl_gscan_capabilities *capa = &fw->gscan_capa;\r\ncapa->max_scan_cache_size = le32_to_cpu(fw_capa->max_scan_cache_size);\r\ncapa->max_scan_buckets = le32_to_cpu(fw_capa->max_scan_buckets);\r\ncapa->max_ap_cache_per_scan =\r\nle32_to_cpu(fw_capa->max_ap_cache_per_scan);\r\ncapa->max_rssi_sample_size = le32_to_cpu(fw_capa->max_rssi_sample_size);\r\ncapa->max_scan_reporting_threshold =\r\nle32_to_cpu(fw_capa->max_scan_reporting_threshold);\r\ncapa->max_hotlist_aps = le32_to_cpu(fw_capa->max_hotlist_aps);\r\ncapa->max_significant_change_aps =\r\nle32_to_cpu(fw_capa->max_significant_change_aps);\r\ncapa->max_bssid_history_entries =\r\nle32_to_cpu(fw_capa->max_bssid_history_entries);\r\ncapa->max_hotlist_ssids = le32_to_cpu(fw_capa->max_hotlist_ssids);\r\ncapa->max_number_epno_networks =\r\nle32_to_cpu(fw_capa->max_number_epno_networks);\r\ncapa->max_number_epno_networks_by_ssid =\r\nle32_to_cpu(fw_capa->max_number_epno_networks_by_ssid);\r\ncapa->max_number_of_white_listed_ssid =\r\nle32_to_cpu(fw_capa->max_number_of_white_listed_ssid);\r\ncapa->max_number_of_black_listed_ssid =\r\nle32_to_cpu(fw_capa->max_number_of_black_listed_ssid);\r\n}\r\nstatic int iwl_store_ucode_sec(struct iwl_firmware_pieces *pieces,\r\nconst void *data, enum iwl_ucode_type type,\r\nint size)\r\n{\r\nstruct fw_img_parsing *img;\r\nstruct fw_sec *sec;\r\nstruct fw_sec_parsing *sec_parse;\r\nif (WARN_ON(!pieces || !data || type >= IWL_UCODE_TYPE_MAX))\r\nreturn -1;\r\nsec_parse = (struct fw_sec_parsing *)data;\r\nimg = &pieces->img[type];\r\nsec = &img->sec[img->sec_counter];\r\nsec->offset = le32_to_cpu(sec_parse->offset);\r\nsec->data = sec_parse->data;\r\nsec->size = size - sizeof(sec_parse->offset);\r\n++img->sec_counter;\r\nreturn 0;\r\n}\r\nstatic int iwl_set_default_calib(struct iwl_drv *drv, const u8 *data)\r\n{\r\nstruct iwl_tlv_calib_data *def_calib =\r\n(struct iwl_tlv_calib_data *)data;\r\nu32 ucode_type = le32_to_cpu(def_calib->ucode_type);\r\nif (ucode_type >= IWL_UCODE_TYPE_MAX) {\r\nIWL_ERR(drv, "Wrong ucode_type %u for default calibration.\n",\r\nucode_type);\r\nreturn -EINVAL;\r\n}\r\ndrv->fw.default_calib[ucode_type].flow_trigger =\r\ndef_calib->calib.flow_trigger;\r\ndrv->fw.default_calib[ucode_type].event_trigger =\r\ndef_calib->calib.event_trigger;\r\nreturn 0;\r\n}\r\nstatic int iwl_set_ucode_api_flags(struct iwl_drv *drv, const u8 *data,\r\nstruct iwl_ucode_capabilities *capa)\r\n{\r\nconst struct iwl_ucode_api *ucode_api = (void *)data;\r\nu32 api_index = le32_to_cpu(ucode_api->api_index);\r\nu32 api_flags = le32_to_cpu(ucode_api->api_flags);\r\nint i;\r\nif (api_index >= DIV_ROUND_UP(NUM_IWL_UCODE_TLV_API, 32)) {\r\nIWL_ERR(drv,\r\n"api flags index %d larger than supported by driver\n",\r\napi_index);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 32; i++) {\r\nif (api_flags & BIT(i))\r\n__set_bit(i + 32 * api_index, capa->_api);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iwl_set_ucode_capabilities(struct iwl_drv *drv, const u8 *data,\r\nstruct iwl_ucode_capabilities *capa)\r\n{\r\nconst struct iwl_ucode_capa *ucode_capa = (void *)data;\r\nu32 api_index = le32_to_cpu(ucode_capa->api_index);\r\nu32 api_flags = le32_to_cpu(ucode_capa->api_capa);\r\nint i;\r\nif (api_index >= DIV_ROUND_UP(NUM_IWL_UCODE_TLV_CAPA, 32)) {\r\nIWL_ERR(drv,\r\n"capa flags index %d larger than supported by driver\n",\r\napi_index);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 32; i++) {\r\nif (api_flags & BIT(i))\r\n__set_bit(i + 32 * api_index, capa->_capa);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iwl_parse_v1_v2_firmware(struct iwl_drv *drv,\r\nconst struct firmware *ucode_raw,\r\nstruct iwl_firmware_pieces *pieces)\r\n{\r\nstruct iwl_ucode_header *ucode = (void *)ucode_raw->data;\r\nu32 api_ver, hdr_size, build;\r\nchar buildstr[25];\r\nconst u8 *src;\r\ndrv->fw.ucode_ver = le32_to_cpu(ucode->ver);\r\napi_ver = IWL_UCODE_API(drv->fw.ucode_ver);\r\nswitch (api_ver) {\r\ndefault:\r\nhdr_size = 28;\r\nif (ucode_raw->size < hdr_size) {\r\nIWL_ERR(drv, "File size too small!\n");\r\nreturn -EINVAL;\r\n}\r\nbuild = le32_to_cpu(ucode->u.v2.build);\r\nset_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST,\r\nle32_to_cpu(ucode->u.v2.inst_size));\r\nset_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA,\r\nle32_to_cpu(ucode->u.v2.data_size));\r\nset_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST,\r\nle32_to_cpu(ucode->u.v2.init_size));\r\nset_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA,\r\nle32_to_cpu(ucode->u.v2.init_data_size));\r\nsrc = ucode->u.v2.data;\r\nbreak;\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nhdr_size = 24;\r\nif (ucode_raw->size < hdr_size) {\r\nIWL_ERR(drv, "File size too small!\n");\r\nreturn -EINVAL;\r\n}\r\nbuild = 0;\r\nset_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST,\r\nle32_to_cpu(ucode->u.v1.inst_size));\r\nset_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA,\r\nle32_to_cpu(ucode->u.v1.data_size));\r\nset_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST,\r\nle32_to_cpu(ucode->u.v1.init_size));\r\nset_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA,\r\nle32_to_cpu(ucode->u.v1.init_data_size));\r\nsrc = ucode->u.v1.data;\r\nbreak;\r\n}\r\nif (build)\r\nsprintf(buildstr, " build %u", build);\r\nelse\r\nbuildstr[0] = '\0';\r\nsnprintf(drv->fw.fw_version,\r\nsizeof(drv->fw.fw_version),\r\n"%u.%u.%u.%u%s",\r\nIWL_UCODE_MAJOR(drv->fw.ucode_ver),\r\nIWL_UCODE_MINOR(drv->fw.ucode_ver),\r\nIWL_UCODE_API(drv->fw.ucode_ver),\r\nIWL_UCODE_SERIAL(drv->fw.ucode_ver),\r\nbuildstr);\r\nif (ucode_raw->size != hdr_size +\r\nget_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST) +\r\nget_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA) +\r\nget_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST) +\r\nget_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA)) {\r\nIWL_ERR(drv,\r\n"uCode file size %d does not match expected size\n",\r\n(int)ucode_raw->size);\r\nreturn -EINVAL;\r\n}\r\nset_sec_data(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST, src);\r\nsrc += get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST);\r\nset_sec_offset(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST,\r\nIWLAGN_RTC_INST_LOWER_BOUND);\r\nset_sec_data(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA, src);\r\nsrc += get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA);\r\nset_sec_offset(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA,\r\nIWLAGN_RTC_DATA_LOWER_BOUND);\r\nset_sec_data(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST, src);\r\nsrc += get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST);\r\nset_sec_offset(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST,\r\nIWLAGN_RTC_INST_LOWER_BOUND);\r\nset_sec_data(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA, src);\r\nsrc += get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA);\r\nset_sec_offset(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA,\r\nIWLAGN_RTC_DATA_LOWER_BOUND);\r\nreturn 0;\r\n}\r\nstatic int iwl_parse_tlv_firmware(struct iwl_drv *drv,\r\nconst struct firmware *ucode_raw,\r\nstruct iwl_firmware_pieces *pieces,\r\nstruct iwl_ucode_capabilities *capa,\r\nbool *usniffer_images)\r\n{\r\nstruct iwl_tlv_ucode_header *ucode = (void *)ucode_raw->data;\r\nstruct iwl_ucode_tlv *tlv;\r\nsize_t len = ucode_raw->size;\r\nconst u8 *data;\r\nu32 tlv_len;\r\nu32 usniffer_img;\r\nenum iwl_ucode_tlv_type tlv_type;\r\nconst u8 *tlv_data;\r\nchar buildstr[25];\r\nu32 build, paging_mem_size;\r\nint num_of_cpus;\r\nbool usniffer_req = false;\r\nbool gscan_capa = false;\r\nif (len < sizeof(*ucode)) {\r\nIWL_ERR(drv, "uCode has invalid length: %zd\n", len);\r\nreturn -EINVAL;\r\n}\r\nif (ucode->magic != cpu_to_le32(IWL_TLV_UCODE_MAGIC)) {\r\nIWL_ERR(drv, "invalid uCode magic: 0X%x\n",\r\nle32_to_cpu(ucode->magic));\r\nreturn -EINVAL;\r\n}\r\ndrv->fw.ucode_ver = le32_to_cpu(ucode->ver);\r\nmemcpy(drv->fw.human_readable, ucode->human_readable,\r\nsizeof(drv->fw.human_readable));\r\nbuild = le32_to_cpu(ucode->build);\r\nif (build)\r\nsprintf(buildstr, " build %u", build);\r\nelse\r\nbuildstr[0] = '\0';\r\nsnprintf(drv->fw.fw_version,\r\nsizeof(drv->fw.fw_version),\r\n"%u.%u.%u.%u%s",\r\nIWL_UCODE_MAJOR(drv->fw.ucode_ver),\r\nIWL_UCODE_MINOR(drv->fw.ucode_ver),\r\nIWL_UCODE_API(drv->fw.ucode_ver),\r\nIWL_UCODE_SERIAL(drv->fw.ucode_ver),\r\nbuildstr);\r\ndata = ucode->data;\r\nlen -= sizeof(*ucode);\r\nwhile (len >= sizeof(*tlv)) {\r\nlen -= sizeof(*tlv);\r\ntlv = (void *)data;\r\ntlv_len = le32_to_cpu(tlv->length);\r\ntlv_type = le32_to_cpu(tlv->type);\r\ntlv_data = tlv->data;\r\nif (len < tlv_len) {\r\nIWL_ERR(drv, "invalid TLV len: %zd/%u\n",\r\nlen, tlv_len);\r\nreturn -EINVAL;\r\n}\r\nlen -= ALIGN(tlv_len, 4);\r\ndata += sizeof(*tlv) + ALIGN(tlv_len, 4);\r\nswitch (tlv_type) {\r\ncase IWL_UCODE_TLV_INST:\r\nset_sec_data(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_INST, tlv_data);\r\nset_sec_size(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_INST, tlv_len);\r\nset_sec_offset(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_INST,\r\nIWLAGN_RTC_INST_LOWER_BOUND);\r\nbreak;\r\ncase IWL_UCODE_TLV_DATA:\r\nset_sec_data(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_DATA, tlv_data);\r\nset_sec_size(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_DATA, tlv_len);\r\nset_sec_offset(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_DATA,\r\nIWLAGN_RTC_DATA_LOWER_BOUND);\r\nbreak;\r\ncase IWL_UCODE_TLV_INIT:\r\nset_sec_data(pieces, IWL_UCODE_INIT,\r\nIWL_UCODE_SECTION_INST, tlv_data);\r\nset_sec_size(pieces, IWL_UCODE_INIT,\r\nIWL_UCODE_SECTION_INST, tlv_len);\r\nset_sec_offset(pieces, IWL_UCODE_INIT,\r\nIWL_UCODE_SECTION_INST,\r\nIWLAGN_RTC_INST_LOWER_BOUND);\r\nbreak;\r\ncase IWL_UCODE_TLV_INIT_DATA:\r\nset_sec_data(pieces, IWL_UCODE_INIT,\r\nIWL_UCODE_SECTION_DATA, tlv_data);\r\nset_sec_size(pieces, IWL_UCODE_INIT,\r\nIWL_UCODE_SECTION_DATA, tlv_len);\r\nset_sec_offset(pieces, IWL_UCODE_INIT,\r\nIWL_UCODE_SECTION_DATA,\r\nIWLAGN_RTC_DATA_LOWER_BOUND);\r\nbreak;\r\ncase IWL_UCODE_TLV_BOOT:\r\nIWL_ERR(drv, "Found unexpected BOOT ucode\n");\r\nbreak;\r\ncase IWL_UCODE_TLV_PROBE_MAX_LEN:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\ncapa->max_probe_length =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_PAN:\r\nif (tlv_len)\r\ngoto invalid_tlv_len;\r\ncapa->flags |= IWL_UCODE_TLV_FLAGS_PAN;\r\nbreak;\r\ncase IWL_UCODE_TLV_FLAGS:\r\nif (tlv_len < sizeof(u32))\r\ngoto invalid_tlv_len;\r\nif (tlv_len % sizeof(u32))\r\ngoto invalid_tlv_len;\r\ncapa->flags = le32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_API_CHANGES_SET:\r\nif (tlv_len != sizeof(struct iwl_ucode_api))\r\ngoto invalid_tlv_len;\r\nif (iwl_set_ucode_api_flags(drv, tlv_data, capa))\r\ngoto tlv_error;\r\nbreak;\r\ncase IWL_UCODE_TLV_ENABLED_CAPABILITIES:\r\nif (tlv_len != sizeof(struct iwl_ucode_capa))\r\ngoto invalid_tlv_len;\r\nif (iwl_set_ucode_capabilities(drv, tlv_data, capa))\r\ngoto tlv_error;\r\nbreak;\r\ncase IWL_UCODE_TLV_INIT_EVTLOG_PTR:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\npieces->init_evtlog_ptr =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_INIT_EVTLOG_SIZE:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\npieces->init_evtlog_size =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_INIT_ERRLOG_PTR:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\npieces->init_errlog_ptr =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_RUNT_EVTLOG_PTR:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\npieces->inst_evtlog_ptr =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_RUNT_EVTLOG_SIZE:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\npieces->inst_evtlog_size =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_RUNT_ERRLOG_PTR:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\npieces->inst_errlog_ptr =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_ENHANCE_SENS_TBL:\r\nif (tlv_len)\r\ngoto invalid_tlv_len;\r\ndrv->fw.enhance_sensitivity_table = true;\r\nbreak;\r\ncase IWL_UCODE_TLV_WOWLAN_INST:\r\nset_sec_data(pieces, IWL_UCODE_WOWLAN,\r\nIWL_UCODE_SECTION_INST, tlv_data);\r\nset_sec_size(pieces, IWL_UCODE_WOWLAN,\r\nIWL_UCODE_SECTION_INST, tlv_len);\r\nset_sec_offset(pieces, IWL_UCODE_WOWLAN,\r\nIWL_UCODE_SECTION_INST,\r\nIWLAGN_RTC_INST_LOWER_BOUND);\r\nbreak;\r\ncase IWL_UCODE_TLV_WOWLAN_DATA:\r\nset_sec_data(pieces, IWL_UCODE_WOWLAN,\r\nIWL_UCODE_SECTION_DATA, tlv_data);\r\nset_sec_size(pieces, IWL_UCODE_WOWLAN,\r\nIWL_UCODE_SECTION_DATA, tlv_len);\r\nset_sec_offset(pieces, IWL_UCODE_WOWLAN,\r\nIWL_UCODE_SECTION_DATA,\r\nIWLAGN_RTC_DATA_LOWER_BOUND);\r\nbreak;\r\ncase IWL_UCODE_TLV_PHY_CALIBRATION_SIZE:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\ncapa->standard_phy_calibration_size =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_SEC_RT:\r\niwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_REGULAR,\r\ntlv_len);\r\ndrv->fw.type = IWL_FW_MVM;\r\nbreak;\r\ncase IWL_UCODE_TLV_SEC_INIT:\r\niwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_INIT,\r\ntlv_len);\r\ndrv->fw.type = IWL_FW_MVM;\r\nbreak;\r\ncase IWL_UCODE_TLV_SEC_WOWLAN:\r\niwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_WOWLAN,\r\ntlv_len);\r\ndrv->fw.type = IWL_FW_MVM;\r\nbreak;\r\ncase IWL_UCODE_TLV_DEF_CALIB:\r\nif (tlv_len != sizeof(struct iwl_tlv_calib_data))\r\ngoto invalid_tlv_len;\r\nif (iwl_set_default_calib(drv, tlv_data))\r\ngoto tlv_error;\r\nbreak;\r\ncase IWL_UCODE_TLV_PHY_SKU:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\ndrv->fw.phy_config = le32_to_cpup((__le32 *)tlv_data);\r\ndrv->fw.valid_tx_ant = (drv->fw.phy_config &\r\nFW_PHY_CFG_TX_CHAIN) >>\r\nFW_PHY_CFG_TX_CHAIN_POS;\r\ndrv->fw.valid_rx_ant = (drv->fw.phy_config &\r\nFW_PHY_CFG_RX_CHAIN) >>\r\nFW_PHY_CFG_RX_CHAIN_POS;\r\nbreak;\r\ncase IWL_UCODE_TLV_SECURE_SEC_RT:\r\niwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_REGULAR,\r\ntlv_len);\r\ndrv->fw.type = IWL_FW_MVM;\r\nbreak;\r\ncase IWL_UCODE_TLV_SECURE_SEC_INIT:\r\niwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_INIT,\r\ntlv_len);\r\ndrv->fw.type = IWL_FW_MVM;\r\nbreak;\r\ncase IWL_UCODE_TLV_SECURE_SEC_WOWLAN:\r\niwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_WOWLAN,\r\ntlv_len);\r\ndrv->fw.type = IWL_FW_MVM;\r\nbreak;\r\ncase IWL_UCODE_TLV_NUM_OF_CPU:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\nnum_of_cpus =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nif (num_of_cpus == 2) {\r\ndrv->fw.img[IWL_UCODE_REGULAR].is_dual_cpus =\r\ntrue;\r\ndrv->fw.img[IWL_UCODE_INIT].is_dual_cpus =\r\ntrue;\r\ndrv->fw.img[IWL_UCODE_WOWLAN].is_dual_cpus =\r\ntrue;\r\n} else if ((num_of_cpus > 2) || (num_of_cpus < 1)) {\r\nIWL_ERR(drv, "Driver support upto 2 CPUs\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IWL_UCODE_TLV_CSCHEME:\r\nif (iwl_store_cscheme(&drv->fw, tlv_data, tlv_len))\r\ngoto invalid_tlv_len;\r\nbreak;\r\ncase IWL_UCODE_TLV_N_SCAN_CHANNELS:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\ncapa->n_scan_channels =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_FW_VERSION: {\r\n__le32 *ptr = (void *)tlv_data;\r\nu32 major, minor;\r\nu8 local_comp;\r\nif (tlv_len != sizeof(u32) * 3)\r\ngoto invalid_tlv_len;\r\nmajor = le32_to_cpup(ptr++);\r\nminor = le32_to_cpup(ptr++);\r\nlocal_comp = le32_to_cpup(ptr);\r\nsnprintf(drv->fw.fw_version,\r\nsizeof(drv->fw.fw_version), "%u.%u.%u",\r\nmajor, minor, local_comp);\r\nbreak;\r\n}\r\ncase IWL_UCODE_TLV_FW_DBG_DEST: {\r\nstruct iwl_fw_dbg_dest_tlv *dest = (void *)tlv_data;\r\nif (pieces->dbg_dest_tlv) {\r\nIWL_ERR(drv,\r\n"dbg destination ignored, already exists\n");\r\nbreak;\r\n}\r\npieces->dbg_dest_tlv = dest;\r\nIWL_INFO(drv, "Found debug destination: %s\n",\r\nget_fw_dbg_mode_string(dest->monitor_mode));\r\ndrv->fw.dbg_dest_reg_num =\r\ntlv_len - offsetof(struct iwl_fw_dbg_dest_tlv,\r\nreg_ops);\r\ndrv->fw.dbg_dest_reg_num /=\r\nsizeof(drv->fw.dbg_dest_tlv->reg_ops[0]);\r\nbreak;\r\n}\r\ncase IWL_UCODE_TLV_FW_DBG_CONF: {\r\nstruct iwl_fw_dbg_conf_tlv *conf = (void *)tlv_data;\r\nif (!pieces->dbg_dest_tlv) {\r\nIWL_ERR(drv,\r\n"Ignore dbg config %d - no destination configured\n",\r\nconf->id);\r\nbreak;\r\n}\r\nif (conf->id >= ARRAY_SIZE(drv->fw.dbg_conf_tlv)) {\r\nIWL_ERR(drv,\r\n"Skip unknown configuration: %d\n",\r\nconf->id);\r\nbreak;\r\n}\r\nif (pieces->dbg_conf_tlv[conf->id]) {\r\nIWL_ERR(drv,\r\n"Ignore duplicate dbg config %d\n",\r\nconf->id);\r\nbreak;\r\n}\r\nif (conf->usniffer)\r\nusniffer_req = true;\r\nIWL_INFO(drv, "Found debug configuration: %d\n",\r\nconf->id);\r\npieces->dbg_conf_tlv[conf->id] = conf;\r\npieces->dbg_conf_tlv_len[conf->id] = tlv_len;\r\nbreak;\r\n}\r\ncase IWL_UCODE_TLV_FW_DBG_TRIGGER: {\r\nstruct iwl_fw_dbg_trigger_tlv *trigger =\r\n(void *)tlv_data;\r\nu32 trigger_id = le32_to_cpu(trigger->id);\r\nif (trigger_id >= ARRAY_SIZE(drv->fw.dbg_trigger_tlv)) {\r\nIWL_ERR(drv,\r\n"Skip unknown trigger: %u\n",\r\ntrigger->id);\r\nbreak;\r\n}\r\nif (pieces->dbg_trigger_tlv[trigger_id]) {\r\nIWL_ERR(drv,\r\n"Ignore duplicate dbg trigger %u\n",\r\ntrigger->id);\r\nbreak;\r\n}\r\nIWL_INFO(drv, "Found debug trigger: %u\n", trigger->id);\r\npieces->dbg_trigger_tlv[trigger_id] = trigger;\r\npieces->dbg_trigger_tlv_len[trigger_id] = tlv_len;\r\nbreak;\r\n}\r\ncase IWL_UCODE_TLV_SEC_RT_USNIFFER:\r\n*usniffer_images = true;\r\niwl_store_ucode_sec(pieces, tlv_data,\r\nIWL_UCODE_REGULAR_USNIFFER,\r\ntlv_len);\r\nbreak;\r\ncase IWL_UCODE_TLV_PAGING:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\npaging_mem_size = le32_to_cpup((__le32 *)tlv_data);\r\nIWL_DEBUG_FW(drv,\r\n"Paging: paging enabled (size = %u bytes)\n",\r\npaging_mem_size);\r\nif (paging_mem_size > MAX_PAGING_IMAGE_SIZE) {\r\nIWL_ERR(drv,\r\n"Paging: driver supports up to %lu bytes for paging image\n",\r\nMAX_PAGING_IMAGE_SIZE);\r\nreturn -EINVAL;\r\n}\r\nif (paging_mem_size & (FW_PAGING_SIZE - 1)) {\r\nIWL_ERR(drv,\r\n"Paging: image isn't multiple %lu\n",\r\nFW_PAGING_SIZE);\r\nreturn -EINVAL;\r\n}\r\ndrv->fw.img[IWL_UCODE_REGULAR].paging_mem_size =\r\npaging_mem_size;\r\nusniffer_img = IWL_UCODE_REGULAR_USNIFFER;\r\ndrv->fw.img[usniffer_img].paging_mem_size =\r\npaging_mem_size;\r\nbreak;\r\ncase IWL_UCODE_TLV_SDIO_ADMA_ADDR:\r\nif (tlv_len != sizeof(u32))\r\ngoto invalid_tlv_len;\r\ndrv->fw.sdio_adma_addr =\r\nle32_to_cpup((__le32 *)tlv_data);\r\nbreak;\r\ncase IWL_UCODE_TLV_FW_GSCAN_CAPA:\r\nif (tlv_len < sizeof(struct iwl_fw_gscan_capabilities))\r\nbreak;\r\niwl_store_gscan_capa(&drv->fw, tlv_data, tlv_len);\r\ngscan_capa = true;\r\nbreak;\r\ncase IWL_UCODE_TLV_FW_MEM_SEG: {\r\nstruct iwl_fw_dbg_mem_seg_tlv *dbg_mem =\r\n(void *)tlv_data;\r\nu32 type;\r\nif (tlv_len != (sizeof(*dbg_mem)))\r\ngoto invalid_tlv_len;\r\ntype = le32_to_cpu(dbg_mem->data_type);\r\ndrv->fw.dbg_dynamic_mem = true;\r\nif (type >= ARRAY_SIZE(drv->fw.dbg_mem_tlv)) {\r\nIWL_ERR(drv,\r\n"Skip unknown dbg mem segment: %u\n",\r\ndbg_mem->data_type);\r\nbreak;\r\n}\r\nif (pieces->dbg_mem_tlv[type]) {\r\nIWL_ERR(drv,\r\n"Ignore duplicate mem segment: %u\n",\r\ndbg_mem->data_type);\r\nbreak;\r\n}\r\nIWL_DEBUG_INFO(drv, "Found debug memory segment: %u\n",\r\ndbg_mem->data_type);\r\npieces->dbg_mem_tlv[type] = dbg_mem;\r\nbreak;\r\n}\r\ndefault:\r\nIWL_DEBUG_INFO(drv, "unknown TLV: %d\n", tlv_type);\r\nbreak;\r\n}\r\n}\r\nif (!fw_has_capa(capa, IWL_UCODE_TLV_CAPA_USNIFFER_UNIFIED) &&\r\nusniffer_req && !*usniffer_images) {\r\nIWL_ERR(drv,\r\n"user selected to work with usniffer but usniffer image isn't available in ucode package\n");\r\nreturn -EINVAL;\r\n}\r\nif (len) {\r\nIWL_ERR(drv, "invalid TLV after parsing: %zd\n", len);\r\niwl_print_hex_dump(drv, IWL_DL_FW, (u8 *)data, len);\r\nreturn -EINVAL;\r\n}\r\nif (fw_has_capa(capa, IWL_UCODE_TLV_CAPA_GSCAN_SUPPORT) &&\r\n!gscan_capa) {\r\nIWL_DEBUG_INFO(drv,\r\n"GSCAN is supported but capabilities TLV is unavailable\n");\r\n__clear_bit((__force long)IWL_UCODE_TLV_CAPA_GSCAN_SUPPORT,\r\ncapa->_capa);\r\n}\r\nreturn 0;\r\ninvalid_tlv_len:\r\nIWL_ERR(drv, "TLV %d has invalid size: %u\n", tlv_type, tlv_len);\r\ntlv_error:\r\niwl_print_hex_dump(drv, IWL_DL_FW, tlv_data, tlv_len);\r\nreturn -EINVAL;\r\n}\r\nstatic int iwl_alloc_ucode(struct iwl_drv *drv,\r\nstruct iwl_firmware_pieces *pieces,\r\nenum iwl_ucode_type type)\r\n{\r\nint i;\r\nfor (i = 0;\r\ni < IWL_UCODE_SECTION_MAX && get_sec_size(pieces, type, i);\r\ni++)\r\nif (iwl_alloc_fw_desc(drv, &(drv->fw.img[type].sec[i]),\r\nget_sec(pieces, type, i)))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int validate_sec_sizes(struct iwl_drv *drv,\r\nstruct iwl_firmware_pieces *pieces,\r\nconst struct iwl_cfg *cfg)\r\n{\r\nIWL_DEBUG_INFO(drv, "f/w package hdr runtime inst size = %Zd\n",\r\nget_sec_size(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_INST));\r\nIWL_DEBUG_INFO(drv, "f/w package hdr runtime data size = %Zd\n",\r\nget_sec_size(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_DATA));\r\nIWL_DEBUG_INFO(drv, "f/w package hdr init inst size = %Zd\n",\r\nget_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST));\r\nIWL_DEBUG_INFO(drv, "f/w package hdr init data size = %Zd\n",\r\nget_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA));\r\nif (get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST) >\r\ncfg->max_inst_size) {\r\nIWL_ERR(drv, "uCode instr len %Zd too large to fit in\n",\r\nget_sec_size(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_INST));\r\nreturn -1;\r\n}\r\nif (get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA) >\r\ncfg->max_data_size) {\r\nIWL_ERR(drv, "uCode data len %Zd too large to fit in\n",\r\nget_sec_size(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_DATA));\r\nreturn -1;\r\n}\r\nif (get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST) >\r\ncfg->max_inst_size) {\r\nIWL_ERR(drv, "uCode init instr len %Zd too large to fit in\n",\r\nget_sec_size(pieces, IWL_UCODE_INIT,\r\nIWL_UCODE_SECTION_INST));\r\nreturn -1;\r\n}\r\nif (get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA) >\r\ncfg->max_data_size) {\r\nIWL_ERR(drv, "uCode init data len %Zd too large to fit in\n",\r\nget_sec_size(pieces, IWL_UCODE_REGULAR,\r\nIWL_UCODE_SECTION_DATA));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct iwl_op_mode *\r\n_iwl_op_mode_start(struct iwl_drv *drv, struct iwlwifi_opmode_table *op)\r\n{\r\nconst struct iwl_op_mode_ops *ops = op->ops;\r\nstruct dentry *dbgfs_dir = NULL;\r\nstruct iwl_op_mode *op_mode = NULL;\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\ndrv->dbgfs_op_mode = debugfs_create_dir(op->name,\r\ndrv->dbgfs_drv);\r\nif (!drv->dbgfs_op_mode) {\r\nIWL_ERR(drv,\r\n"failed to create opmode debugfs directory\n");\r\nreturn op_mode;\r\n}\r\ndbgfs_dir = drv->dbgfs_op_mode;\r\n#endif\r\nop_mode = ops->start(drv->trans, drv->cfg, &drv->fw, dbgfs_dir);\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\nif (!op_mode) {\r\ndebugfs_remove_recursive(drv->dbgfs_op_mode);\r\ndrv->dbgfs_op_mode = NULL;\r\n}\r\n#endif\r\nreturn op_mode;\r\n}\r\nstatic void _iwl_op_mode_stop(struct iwl_drv *drv)\r\n{\r\nif (drv->op_mode) {\r\niwl_op_mode_stop(drv->op_mode);\r\ndrv->op_mode = NULL;\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\ndebugfs_remove_recursive(drv->dbgfs_op_mode);\r\ndrv->dbgfs_op_mode = NULL;\r\n#endif\r\n}\r\n}\r\nstatic void iwl_req_fw_callback(const struct firmware *ucode_raw, void *context)\r\n{\r\nstruct iwl_drv *drv = context;\r\nstruct iwl_fw *fw = &drv->fw;\r\nstruct iwl_ucode_header *ucode;\r\nstruct iwlwifi_opmode_table *op;\r\nint err;\r\nstruct iwl_firmware_pieces *pieces;\r\nconst unsigned int api_max = drv->cfg->ucode_api_max;\r\nconst unsigned int api_min = drv->cfg->ucode_api_min;\r\nsize_t trigger_tlv_sz[FW_DBG_TRIGGER_MAX];\r\nu32 api_ver;\r\nint i;\r\nbool load_module = false;\r\nbool usniffer_images = false;\r\nfw->ucode_capa.max_probe_length = IWL_DEFAULT_MAX_PROBE_LENGTH;\r\nfw->ucode_capa.standard_phy_calibration_size =\r\nIWL_DEFAULT_STANDARD_PHY_CALIBRATE_TBL_SIZE;\r\nfw->ucode_capa.n_scan_channels = IWL_DEFAULT_SCAN_CHANNELS;\r\npieces = kzalloc(sizeof(*pieces), GFP_KERNEL);\r\nif (!pieces)\r\nreturn;\r\nif (!ucode_raw)\r\ngoto try_again;\r\nIWL_DEBUG_INFO(drv, "Loaded firmware file '%s' (%zd bytes).\n",\r\ndrv->firmware_name, ucode_raw->size);\r\nif (ucode_raw->size < 4) {\r\nIWL_ERR(drv, "File size way too small!\n");\r\ngoto try_again;\r\n}\r\nucode = (struct iwl_ucode_header *)ucode_raw->data;\r\nif (ucode->ver)\r\nerr = iwl_parse_v1_v2_firmware(drv, ucode_raw, pieces);\r\nelse\r\nerr = iwl_parse_tlv_firmware(drv, ucode_raw, pieces,\r\n&fw->ucode_capa, &usniffer_images);\r\nif (err)\r\ngoto try_again;\r\nif (fw_has_api(&drv->fw.ucode_capa, IWL_UCODE_TLV_API_NEW_VERSION))\r\napi_ver = drv->fw.ucode_ver;\r\nelse\r\napi_ver = IWL_UCODE_API(drv->fw.ucode_ver);\r\nif (api_ver < api_min || api_ver > api_max) {\r\nIWL_ERR(drv,\r\n"Driver unable to support your firmware API. "\r\n"Driver supports v%u, firmware is v%u.\n",\r\napi_max, api_ver);\r\ngoto try_again;\r\n}\r\nif (fw->type == IWL_FW_DVM && validate_sec_sizes(drv, pieces, drv->cfg))\r\ngoto try_again;\r\nfor (i = 0; i < IWL_UCODE_TYPE_MAX; i++)\r\nif (iwl_alloc_ucode(drv, pieces, i))\r\ngoto out_free_fw;\r\nif (pieces->dbg_dest_tlv) {\r\ndrv->fw.dbg_dest_tlv =\r\nkmemdup(pieces->dbg_dest_tlv,\r\nsizeof(*pieces->dbg_dest_tlv) +\r\nsizeof(pieces->dbg_dest_tlv->reg_ops[0]) *\r\ndrv->fw.dbg_dest_reg_num, GFP_KERNEL);\r\nif (!drv->fw.dbg_dest_tlv)\r\ngoto out_free_fw;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg_conf_tlv); i++) {\r\nif (pieces->dbg_conf_tlv[i]) {\r\ndrv->fw.dbg_conf_tlv_len[i] =\r\npieces->dbg_conf_tlv_len[i];\r\ndrv->fw.dbg_conf_tlv[i] =\r\nkmemdup(pieces->dbg_conf_tlv[i],\r\ndrv->fw.dbg_conf_tlv_len[i],\r\nGFP_KERNEL);\r\nif (!drv->fw.dbg_conf_tlv[i])\r\ngoto out_free_fw;\r\n}\r\n}\r\nmemset(&trigger_tlv_sz, 0xff, sizeof(trigger_tlv_sz));\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_MISSED_BEACONS] =\r\nsizeof(struct iwl_fw_dbg_trigger_missed_bcon);\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_CHANNEL_SWITCH] = 0;\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_FW_NOTIF] =\r\nsizeof(struct iwl_fw_dbg_trigger_cmd);\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_MLME] =\r\nsizeof(struct iwl_fw_dbg_trigger_mlme);\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_STATS] =\r\nsizeof(struct iwl_fw_dbg_trigger_stats);\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_RSSI] =\r\nsizeof(struct iwl_fw_dbg_trigger_low_rssi);\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_TXQ_TIMERS] =\r\nsizeof(struct iwl_fw_dbg_trigger_txq_timer);\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_TIME_EVENT] =\r\nsizeof(struct iwl_fw_dbg_trigger_time_event);\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_BA] =\r\nsizeof(struct iwl_fw_dbg_trigger_ba);\r\ntrigger_tlv_sz[FW_DBG_TRIGGER_TDLS] =\r\nsizeof(struct iwl_fw_dbg_trigger_tdls);\r\nfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg_trigger_tlv); i++) {\r\nif (pieces->dbg_trigger_tlv[i]) {\r\nif (WARN_ON(pieces->dbg_trigger_tlv_len[i] <\r\n(trigger_tlv_sz[i] +\r\nsizeof(struct iwl_fw_dbg_trigger_tlv))))\r\ngoto out_free_fw;\r\ndrv->fw.dbg_trigger_tlv_len[i] =\r\npieces->dbg_trigger_tlv_len[i];\r\ndrv->fw.dbg_trigger_tlv[i] =\r\nkmemdup(pieces->dbg_trigger_tlv[i],\r\ndrv->fw.dbg_trigger_tlv_len[i],\r\nGFP_KERNEL);\r\nif (!drv->fw.dbg_trigger_tlv[i])\r\ngoto out_free_fw;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg_mem_tlv); i++) {\r\nif (pieces->dbg_mem_tlv[i]) {\r\ndrv->fw.dbg_mem_tlv[i] =\r\nkmemdup(pieces->dbg_mem_tlv[i],\r\nsizeof(*drv->fw.dbg_mem_tlv[i]),\r\nGFP_KERNEL);\r\nif (!drv->fw.dbg_mem_tlv[i])\r\ngoto out_free_fw;\r\n}\r\n}\r\nfw->init_evtlog_ptr = pieces->init_evtlog_ptr;\r\nif (pieces->init_evtlog_size)\r\nfw->init_evtlog_size = (pieces->init_evtlog_size - 16)/12;\r\nelse\r\nfw->init_evtlog_size =\r\ndrv->cfg->base_params->max_event_log_size;\r\nfw->init_errlog_ptr = pieces->init_errlog_ptr;\r\nfw->inst_evtlog_ptr = pieces->inst_evtlog_ptr;\r\nif (pieces->inst_evtlog_size)\r\nfw->inst_evtlog_size = (pieces->inst_evtlog_size - 16)/12;\r\nelse\r\nfw->inst_evtlog_size =\r\ndrv->cfg->base_params->max_event_log_size;\r\nfw->inst_errlog_ptr = pieces->inst_errlog_ptr;\r\nif (fw->ucode_capa.standard_phy_calibration_size >\r\nIWL_MAX_PHY_CALIBRATE_TBL_SIZE)\r\nfw->ucode_capa.standard_phy_calibration_size =\r\nIWL_MAX_STANDARD_PHY_CALIBRATE_TBL_SIZE;\r\nrelease_firmware(ucode_raw);\r\nmutex_lock(&iwlwifi_opmode_table_mtx);\r\nswitch (fw->type) {\r\ncase IWL_FW_DVM:\r\nop = &iwlwifi_opmode_table[DVM_OP_MODE];\r\nbreak;\r\ndefault:\r\nWARN(1, "Invalid fw type %d\n", fw->type);\r\ncase IWL_FW_MVM:\r\nop = &iwlwifi_opmode_table[MVM_OP_MODE];\r\nbreak;\r\n}\r\nIWL_INFO(drv, "loaded firmware version %s op_mode %s\n",\r\ndrv->fw.fw_version, op->name);\r\nlist_add_tail(&drv->list, &op->drv);\r\nif (op->ops) {\r\ndrv->op_mode = _iwl_op_mode_start(drv, op);\r\nif (!drv->op_mode) {\r\nmutex_unlock(&iwlwifi_opmode_table_mtx);\r\ngoto out_unbind;\r\n}\r\n} else {\r\nload_module = true;\r\n}\r\nmutex_unlock(&iwlwifi_opmode_table_mtx);\r\ncomplete(&drv->request_firmware_complete);\r\nif (load_module) {\r\nerr = request_module("%s", op->name);\r\n#ifdef CONFIG_IWLWIFI_OPMODE_MODULAR\r\nif (err)\r\nIWL_ERR(drv,\r\n"failed to load module %s (error %d), is dynamic loading enabled?\n",\r\nop->name, err);\r\n#endif\r\n}\r\nkfree(pieces);\r\nreturn;\r\ntry_again:\r\nrelease_firmware(ucode_raw);\r\nif (iwl_request_firmware(drv, false))\r\ngoto out_unbind;\r\nkfree(pieces);\r\nreturn;\r\nout_free_fw:\r\nIWL_ERR(drv, "failed to allocate pci memory\n");\r\niwl_dealloc_ucode(drv);\r\nrelease_firmware(ucode_raw);\r\nout_unbind:\r\nkfree(pieces);\r\ncomplete(&drv->request_firmware_complete);\r\ndevice_release_driver(drv->trans->dev);\r\n}\r\nstruct iwl_drv *iwl_drv_start(struct iwl_trans *trans,\r\nconst struct iwl_cfg *cfg)\r\n{\r\nstruct iwl_drv *drv;\r\nint ret;\r\ndrv = kzalloc(sizeof(*drv), GFP_KERNEL);\r\nif (!drv) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndrv->trans = trans;\r\ndrv->dev = trans->dev;\r\ndrv->cfg = cfg;\r\ninit_completion(&drv->request_firmware_complete);\r\nINIT_LIST_HEAD(&drv->list);\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\ndrv->dbgfs_drv = debugfs_create_dir(dev_name(trans->dev),\r\niwl_dbgfs_root);\r\nif (!drv->dbgfs_drv) {\r\nIWL_ERR(drv, "failed to create debugfs directory\n");\r\nret = -ENOMEM;\r\ngoto err_free_drv;\r\n}\r\ndrv->trans->dbgfs_dir = debugfs_create_dir("trans", drv->dbgfs_drv);\r\nif (!drv->trans->dbgfs_dir) {\r\nIWL_ERR(drv, "failed to create transport debugfs directory\n");\r\nret = -ENOMEM;\r\ngoto err_free_dbgfs;\r\n}\r\n#endif\r\nret = iwl_request_firmware(drv, true);\r\nif (ret) {\r\nIWL_ERR(trans, "Couldn't request the fw\n");\r\ngoto err_fw;\r\n}\r\nreturn drv;\r\nerr_fw:\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\nerr_free_dbgfs:\r\ndebugfs_remove_recursive(drv->dbgfs_drv);\r\nerr_free_drv:\r\n#endif\r\nkfree(drv);\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid iwl_drv_stop(struct iwl_drv *drv)\r\n{\r\nwait_for_completion(&drv->request_firmware_complete);\r\n_iwl_op_mode_stop(drv);\r\niwl_dealloc_ucode(drv);\r\nmutex_lock(&iwlwifi_opmode_table_mtx);\r\nif (!list_empty(&drv->list))\r\nlist_del(&drv->list);\r\nmutex_unlock(&iwlwifi_opmode_table_mtx);\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\ndebugfs_remove_recursive(drv->dbgfs_drv);\r\n#endif\r\nkfree(drv);\r\n}\r\nint iwl_opmode_register(const char *name, const struct iwl_op_mode_ops *ops)\r\n{\r\nint i;\r\nstruct iwl_drv *drv;\r\nstruct iwlwifi_opmode_table *op;\r\nmutex_lock(&iwlwifi_opmode_table_mtx);\r\nfor (i = 0; i < ARRAY_SIZE(iwlwifi_opmode_table); i++) {\r\nop = &iwlwifi_opmode_table[i];\r\nif (strcmp(op->name, name))\r\ncontinue;\r\nop->ops = ops;\r\nlist_for_each_entry(drv, &op->drv, list)\r\ndrv->op_mode = _iwl_op_mode_start(drv, op);\r\nmutex_unlock(&iwlwifi_opmode_table_mtx);\r\nreturn 0;\r\n}\r\nmutex_unlock(&iwlwifi_opmode_table_mtx);\r\nreturn -EIO;\r\n}\r\nvoid iwl_opmode_deregister(const char *name)\r\n{\r\nint i;\r\nstruct iwl_drv *drv;\r\nmutex_lock(&iwlwifi_opmode_table_mtx);\r\nfor (i = 0; i < ARRAY_SIZE(iwlwifi_opmode_table); i++) {\r\nif (strcmp(iwlwifi_opmode_table[i].name, name))\r\ncontinue;\r\niwlwifi_opmode_table[i].ops = NULL;\r\nlist_for_each_entry(drv, &iwlwifi_opmode_table[i].drv, list)\r\n_iwl_op_mode_stop(drv);\r\nmutex_unlock(&iwlwifi_opmode_table_mtx);\r\nreturn;\r\n}\r\nmutex_unlock(&iwlwifi_opmode_table_mtx);\r\n}\r\nstatic int __init iwl_drv_init(void)\r\n{\r\nint i;\r\nmutex_init(&iwlwifi_opmode_table_mtx);\r\nfor (i = 0; i < ARRAY_SIZE(iwlwifi_opmode_table); i++)\r\nINIT_LIST_HEAD(&iwlwifi_opmode_table[i].drv);\r\npr_info(DRV_DESCRIPTION "\n");\r\npr_info(DRV_COPYRIGHT "\n");\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\niwl_dbgfs_root = debugfs_create_dir(DRV_NAME, NULL);\r\nif (!iwl_dbgfs_root)\r\nreturn -EFAULT;\r\n#endif\r\nreturn iwl_pci_register_driver();\r\n}\r\nstatic void __exit iwl_drv_exit(void)\r\n{\r\niwl_pci_unregister_driver();\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\ndebugfs_remove_recursive(iwl_dbgfs_root);\r\n#endif\r\n}
