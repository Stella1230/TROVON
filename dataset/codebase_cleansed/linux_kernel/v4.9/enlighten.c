int xen_remap_domain_gfn_array(struct vm_area_struct *vma,\r\nunsigned long addr,\r\nxen_pfn_t *gfn, int nr,\r\nint *err_ptr, pgprot_t prot,\r\nunsigned domid,\r\nstruct page **pages)\r\n{\r\nreturn xen_xlate_remap_gfn_array(vma, addr, gfn, nr, err_ptr,\r\nprot, domid, pages);\r\n}\r\nint xen_remap_domain_gfn_range(struct vm_area_struct *vma,\r\nunsigned long addr,\r\nxen_pfn_t gfn, int nr,\r\npgprot_t prot, unsigned domid,\r\nstruct page **pages)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint xen_unmap_domain_gfn_range(struct vm_area_struct *vma,\r\nint nr, struct page **pages)\r\n{\r\nreturn xen_xlate_unmap_gfn_range(vma, nr, pages);\r\n}\r\nstatic void xen_read_wallclock(struct timespec64 *ts)\r\n{\r\nu32 version;\r\nstruct timespec64 now, ts_monotonic;\r\nstruct shared_info *s = HYPERVISOR_shared_info;\r\nstruct pvclock_wall_clock *wall_clock = &(s->wc);\r\ndo {\r\nversion = wall_clock->version;\r\nrmb();\r\nnow.tv_sec = ((uint64_t)wall_clock->sec_hi << 32) | wall_clock->sec;\r\nnow.tv_nsec = wall_clock->nsec;\r\nrmb();\r\n} while ((wall_clock->version & 1) || (version != wall_clock->version));\r\nktime_get_ts64(&ts_monotonic);\r\n*ts = timespec64_add(now, ts_monotonic);\r\n}\r\nstatic int xen_pvclock_gtod_notify(struct notifier_block *nb,\r\nunsigned long was_set, void *priv)\r\n{\r\nstatic struct timespec64 next_sync;\r\nstruct xen_platform_op op;\r\nstruct timespec64 now, system_time;\r\nstruct timekeeper *tk = priv;\r\nnow.tv_sec = tk->xtime_sec;\r\nnow.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\r\nsystem_time = timespec64_add(now, tk->wall_to_monotonic);\r\nif (!was_set && timespec64_compare(&now, &next_sync) < 0)\r\nreturn NOTIFY_OK;\r\nop.cmd = XENPF_settime64;\r\nop.u.settime64.mbz = 0;\r\nop.u.settime64.secs = now.tv_sec;\r\nop.u.settime64.nsecs = now.tv_nsec;\r\nop.u.settime64.system_time = timespec64_to_ns(&system_time);\r\n(void)HYPERVISOR_platform_op(&op);\r\nnext_sync = now;\r\nnext_sync.tv_sec += 11 * 60;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int xen_starting_cpu(unsigned int cpu)\r\n{\r\nstruct vcpu_register_vcpu_info info;\r\nstruct vcpu_info *vcpup;\r\nint err;\r\nif (per_cpu(xen_vcpu, cpu) != NULL)\r\ngoto after_register_vcpu_info;\r\npr_info("Xen: initializing cpu%d\n", cpu);\r\nvcpup = per_cpu_ptr(xen_vcpu_info, cpu);\r\ninfo.mfn = virt_to_gfn(vcpup);\r\ninfo.offset = xen_offset_in_page(vcpup);\r\nerr = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_info, xen_vcpu_nr(cpu),\r\n&info);\r\nBUG_ON(err);\r\nper_cpu(xen_vcpu, cpu) = vcpup;\r\nxen_setup_runstate_info(cpu);\r\nafter_register_vcpu_info:\r\nenable_percpu_irq(xen_events_irq, 0);\r\nreturn 0;\r\n}\r\nstatic int xen_dying_cpu(unsigned int cpu)\r\n{\r\ndisable_percpu_irq(xen_events_irq);\r\nreturn 0;\r\n}\r\nstatic void xen_restart(enum reboot_mode reboot_mode, const char *cmd)\r\n{\r\nstruct sched_shutdown r = { .reason = SHUTDOWN_reboot };\r\nint rc;\r\nrc = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);\r\nBUG_ON(rc);\r\n}\r\nstatic void xen_power_off(void)\r\n{\r\nstruct sched_shutdown r = { .reason = SHUTDOWN_poweroff };\r\nint rc;\r\nrc = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);\r\nBUG_ON(rc);\r\n}\r\nstatic irqreturn_t xen_arm_callback(int irq, void *arg)\r\n{\r\nxen_hvm_evtchn_do_upcall();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init fdt_find_hyper_node(unsigned long node, const char *uname,\r\nint depth, void *data)\r\n{\r\nconst void *s = NULL;\r\nint len;\r\nif (depth != 1 || strcmp(uname, "hypervisor") != 0)\r\nreturn 0;\r\nif (of_flat_dt_is_compatible(node, hyper_node.compat))\r\nhyper_node.found = true;\r\ns = of_get_flat_dt_prop(node, "compatible", &len);\r\nif (strlen(hyper_node.prefix) + 3 < len &&\r\n!strncmp(hyper_node.prefix, s, strlen(hyper_node.prefix)))\r\nhyper_node.version = s + strlen(hyper_node.prefix);\r\nif (IS_ENABLED(CONFIG_XEN_EFI)) {\r\nif ((of_get_flat_dt_subnode_by_name(node, "uefi") > 0) &&\r\n!efi_runtime_disabled())\r\nset_bit(EFI_RUNTIME_SERVICES, &efi.flags);\r\n}\r\nreturn 0;\r\n}\r\nvoid __init xen_early_init(void)\r\n{\r\nof_scan_flat_dt(fdt_find_hyper_node, NULL);\r\nif (!hyper_node.found) {\r\npr_debug("No Xen support\n");\r\nreturn;\r\n}\r\nif (hyper_node.version == NULL) {\r\npr_debug("Xen version not found\n");\r\nreturn;\r\n}\r\npr_info("Xen %s support found\n", hyper_node.version);\r\nxen_domain_type = XEN_HVM_DOMAIN;\r\nxen_setup_features();\r\nif (xen_feature(XENFEAT_dom0))\r\nxen_start_info->flags |= SIF_INITDOMAIN|SIF_PRIVILEGED;\r\nelse\r\nxen_start_info->flags &= ~(SIF_INITDOMAIN|SIF_PRIVILEGED);\r\nif (!console_set_on_cmdline && !xen_initial_domain())\r\nadd_preferred_console("hvc", 0, NULL);\r\n}\r\nstatic void __init xen_acpi_guest_init(void)\r\n{\r\n#ifdef CONFIG_ACPI\r\nstruct xen_hvm_param a;\r\nint interrupt, trigger, polarity;\r\na.domid = DOMID_SELF;\r\na.index = HVM_PARAM_CALLBACK_IRQ;\r\nif (HYPERVISOR_hvm_op(HVMOP_get_param, &a)\r\n|| (a.value >> 56) != HVM_PARAM_CALLBACK_TYPE_PPI) {\r\nxen_events_irq = 0;\r\nreturn;\r\n}\r\ninterrupt = a.value & 0xff;\r\ntrigger = ((a.value >> 8) & 0x1) ? ACPI_EDGE_SENSITIVE\r\n: ACPI_LEVEL_SENSITIVE;\r\npolarity = ((a.value >> 8) & 0x2) ? ACPI_ACTIVE_LOW\r\n: ACPI_ACTIVE_HIGH;\r\nxen_events_irq = acpi_register_gsi(NULL, interrupt, trigger, polarity);\r\n#endif\r\n}\r\nstatic void __init xen_dt_guest_init(void)\r\n{\r\nstruct device_node *xen_node;\r\nxen_node = of_find_compatible_node(NULL, NULL, "xen,xen");\r\nif (!xen_node) {\r\npr_err("Xen support was detected before, but it has disappeared\n");\r\nreturn;\r\n}\r\nxen_events_irq = irq_of_parse_and_map(xen_node, 0);\r\n}\r\nstatic int __init xen_guest_init(void)\r\n{\r\nstruct xen_add_to_physmap xatp;\r\nstruct shared_info *shared_info_page = NULL;\r\nint cpu;\r\nif (!xen_domain())\r\nreturn 0;\r\nif (!acpi_disabled)\r\nxen_acpi_guest_init();\r\nelse\r\nxen_dt_guest_init();\r\nif (!xen_events_irq) {\r\npr_err("Xen event channel interrupt not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (efi_enabled(EFI_RUNTIME_SERVICES))\r\nxen_efi_runtime_setup();\r\nshared_info_page = (struct shared_info *)get_zeroed_page(GFP_KERNEL);\r\nif (!shared_info_page) {\r\npr_err("not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nxatp.domid = DOMID_SELF;\r\nxatp.idx = 0;\r\nxatp.space = XENMAPSPACE_shared_info;\r\nxatp.gpfn = virt_to_gfn(shared_info_page);\r\nif (HYPERVISOR_memory_op(XENMEM_add_to_physmap, &xatp))\r\nBUG();\r\nHYPERVISOR_shared_info = (struct shared_info *)shared_info_page;\r\nxen_vcpu_info = __alloc_percpu(sizeof(struct vcpu_info),\r\nsizeof(struct vcpu_info));\r\nif (xen_vcpu_info == NULL)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(cpu)\r\nper_cpu(xen_vcpu_id, cpu) = cpu;\r\nxen_auto_xlat_grant_frames.count = gnttab_max_grant_frames();\r\nif (xen_xlate_map_ballooned_pages(&xen_auto_xlat_grant_frames.pfn,\r\n&xen_auto_xlat_grant_frames.vaddr,\r\nxen_auto_xlat_grant_frames.count)) {\r\nfree_percpu(xen_vcpu_info);\r\nreturn -ENOMEM;\r\n}\r\ngnttab_init();\r\nif (!xen_initial_domain())\r\nxenbus_probe(NULL);\r\ndisable_cpuidle();\r\ndisable_cpufreq();\r\nxen_init_IRQ();\r\nif (request_percpu_irq(xen_events_irq, xen_arm_callback,\r\n"events", &xen_vcpu)) {\r\npr_err("Error request IRQ %d\n", xen_events_irq);\r\nreturn -EINVAL;\r\n}\r\nxen_time_setup_guest();\r\nif (xen_initial_domain())\r\npvclock_gtod_register_notifier(&xen_pvclock_gtod_notifier);\r\nreturn cpuhp_setup_state(CPUHP_AP_ARM_XEN_STARTING,\r\n"AP_ARM_XEN_STARTING", xen_starting_cpu,\r\nxen_dying_cpu);\r\n}\r\nstatic int __init xen_pm_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\npm_power_off = xen_power_off;\r\narm_pm_restart = xen_restart;\r\nif (!xen_initial_domain()) {\r\nstruct timespec64 ts;\r\nxen_read_wallclock(&ts);\r\ndo_settimeofday64(&ts);\r\n}\r\nreturn 0;\r\n}\r\nvoid xen_arch_pre_suspend(void) { }\r\nvoid xen_arch_post_suspend(int suspend_cancelled) { }\r\nvoid xen_timer_resume(void) { }\r\nvoid xen_arch_resume(void) { }\r\nvoid xen_arch_suspend(void) { }
