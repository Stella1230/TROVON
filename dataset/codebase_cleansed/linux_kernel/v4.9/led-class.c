static ssize_t brightness_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nled_update_brightness(led_cdev);\r\nreturn sprintf(buf, "%u\n", led_cdev->brightness);\r\n}\r\nstatic ssize_t brightness_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nunsigned long state;\r\nssize_t ret;\r\nmutex_lock(&led_cdev->led_access);\r\nif (led_sysfs_is_disabled(led_cdev)) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nret = kstrtoul(buf, 10, &state);\r\nif (ret)\r\ngoto unlock;\r\nif (state == LED_OFF)\r\nled_trigger_remove(led_cdev);\r\nled_set_brightness(led_cdev, state);\r\nret = size;\r\nunlock:\r\nmutex_unlock(&led_cdev->led_access);\r\nreturn ret;\r\n}\r\nstatic ssize_t max_brightness_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", led_cdev->max_brightness);\r\n}\r\nvoid led_classdev_suspend(struct led_classdev *led_cdev)\r\n{\r\nled_cdev->flags |= LED_SUSPENDED;\r\nled_set_brightness_nopm(led_cdev, 0);\r\n}\r\nvoid led_classdev_resume(struct led_classdev *led_cdev)\r\n{\r\nled_set_brightness_nopm(led_cdev, led_cdev->brightness);\r\nif (led_cdev->flash_resume)\r\nled_cdev->flash_resume(led_cdev);\r\nled_cdev->flags &= ~LED_SUSPENDED;\r\n}\r\nstatic int led_suspend(struct device *dev)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nif (led_cdev->flags & LED_CORE_SUSPENDRESUME)\r\nled_classdev_suspend(led_cdev);\r\nreturn 0;\r\n}\r\nstatic int led_resume(struct device *dev)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nif (led_cdev->flags & LED_CORE_SUSPENDRESUME)\r\nled_classdev_resume(led_cdev);\r\nreturn 0;\r\n}\r\nstatic int match_name(struct device *dev, const void *data)\r\n{\r\nif (!dev_name(dev))\r\nreturn 0;\r\nreturn !strcmp(dev_name(dev), (char *)data);\r\n}\r\nstatic int led_classdev_next_name(const char *init_name, char *name,\r\nsize_t len)\r\n{\r\nunsigned int i = 0;\r\nint ret = 0;\r\nstruct device *dev;\r\nstrlcpy(name, init_name, len);\r\nwhile ((ret < len) &&\r\n(dev = class_find_device(leds_class, NULL, name, match_name))) {\r\nput_device(dev);\r\nret = snprintf(name, len, "%s_%u", init_name, ++i);\r\n}\r\nif (ret >= len)\r\nreturn -ENOMEM;\r\nreturn i;\r\n}\r\nint led_classdev_register(struct device *parent, struct led_classdev *led_cdev)\r\n{\r\nchar name[64];\r\nint ret;\r\nret = led_classdev_next_name(led_cdev->name, name, sizeof(name));\r\nif (ret < 0)\r\nreturn ret;\r\nled_cdev->dev = device_create_with_groups(leds_class, parent, 0,\r\nled_cdev, led_cdev->groups, "%s", name);\r\nif (IS_ERR(led_cdev->dev))\r\nreturn PTR_ERR(led_cdev->dev);\r\nif (ret)\r\ndev_warn(parent, "Led %s renamed to %s due to name collision",\r\nled_cdev->name, dev_name(led_cdev->dev));\r\n#ifdef CONFIG_LEDS_TRIGGERS\r\ninit_rwsem(&led_cdev->trigger_lock);\r\n#endif\r\nmutex_init(&led_cdev->led_access);\r\ndown_write(&leds_list_lock);\r\nlist_add_tail(&led_cdev->node, &leds_list);\r\nup_write(&leds_list_lock);\r\nif (!led_cdev->max_brightness)\r\nled_cdev->max_brightness = LED_FULL;\r\nled_update_brightness(led_cdev);\r\nled_init_core(led_cdev);\r\n#ifdef CONFIG_LEDS_TRIGGERS\r\nled_trigger_set_default(led_cdev);\r\n#endif\r\ndev_dbg(parent, "Registered led device: %s\n",\r\nled_cdev->name);\r\nreturn 0;\r\n}\r\nvoid led_classdev_unregister(struct led_classdev *led_cdev)\r\n{\r\n#ifdef CONFIG_LEDS_TRIGGERS\r\ndown_write(&led_cdev->trigger_lock);\r\nif (led_cdev->trigger)\r\nled_trigger_set(led_cdev, NULL);\r\nup_write(&led_cdev->trigger_lock);\r\n#endif\r\nled_cdev->flags |= LED_UNREGISTERING;\r\nled_stop_software_blink(led_cdev);\r\nled_set_brightness(led_cdev, LED_OFF);\r\nflush_work(&led_cdev->set_brightness_work);\r\ndevice_unregister(led_cdev->dev);\r\ndown_write(&leds_list_lock);\r\nlist_del(&led_cdev->node);\r\nup_write(&leds_list_lock);\r\nmutex_destroy(&led_cdev->led_access);\r\n}\r\nstatic void devm_led_classdev_release(struct device *dev, void *res)\r\n{\r\nled_classdev_unregister(*(struct led_classdev **)res);\r\n}\r\nint devm_led_classdev_register(struct device *parent,\r\nstruct led_classdev *led_cdev)\r\n{\r\nstruct led_classdev **dr;\r\nint rc;\r\ndr = devres_alloc(devm_led_classdev_release, sizeof(*dr), GFP_KERNEL);\r\nif (!dr)\r\nreturn -ENOMEM;\r\nrc = led_classdev_register(parent, led_cdev);\r\nif (rc) {\r\ndevres_free(dr);\r\nreturn rc;\r\n}\r\n*dr = led_cdev;\r\ndevres_add(parent, dr);\r\nreturn 0;\r\n}\r\nstatic int devm_led_classdev_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct led_cdev **p = res;\r\nif (WARN_ON(!p || !*p))\r\nreturn 0;\r\nreturn *p == data;\r\n}\r\nvoid devm_led_classdev_unregister(struct device *dev,\r\nstruct led_classdev *led_cdev)\r\n{\r\nWARN_ON(devres_release(dev,\r\ndevm_led_classdev_release,\r\ndevm_led_classdev_match, led_cdev));\r\n}\r\nstatic int __init leds_init(void)\r\n{\r\nleds_class = class_create(THIS_MODULE, "leds");\r\nif (IS_ERR(leds_class))\r\nreturn PTR_ERR(leds_class);\r\nleds_class->pm = &leds_class_dev_pm_ops;\r\nleds_class->dev_groups = led_groups;\r\nreturn 0;\r\n}\r\nstatic void __exit leds_exit(void)\r\n{\r\nclass_destroy(leds_class);\r\n}
