static ssize_t proc_scsi_host_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct Scsi_Host *shost = PDE_DATA(file_inode(file));\r\nssize_t ret = -ENOMEM;\r\nchar *page;\r\nif (count > PROC_BLOCK_SIZE)\r\nreturn -EOVERFLOW;\r\nif (!shost->hostt->write_info)\r\nreturn -EINVAL;\r\npage = (char *)__get_free_page(GFP_KERNEL);\r\nif (page) {\r\nret = -EFAULT;\r\nif (copy_from_user(page, buf, count))\r\ngoto out;\r\nret = shost->hostt->write_info(shost, page, count);\r\n}\r\nout:\r\nfree_page((unsigned long)page);\r\nreturn ret;\r\n}\r\nstatic int proc_scsi_show(struct seq_file *m, void *v)\r\n{\r\nstruct Scsi_Host *shost = m->private;\r\nreturn shost->hostt->show_info(m, shost);\r\n}\r\nstatic int proc_scsi_host_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open_size(file, proc_scsi_show, PDE_DATA(inode),\r\n4 * PAGE_SIZE);\r\n}\r\nvoid scsi_proc_hostdir_add(struct scsi_host_template *sht)\r\n{\r\nif (!sht->show_info)\r\nreturn;\r\nmutex_lock(&global_host_template_mutex);\r\nif (!sht->present++) {\r\nsht->proc_dir = proc_mkdir(sht->proc_name, proc_scsi);\r\nif (!sht->proc_dir)\r\nprintk(KERN_ERR "%s: proc_mkdir failed for %s\n",\r\n__func__, sht->proc_name);\r\n}\r\nmutex_unlock(&global_host_template_mutex);\r\n}\r\nvoid scsi_proc_hostdir_rm(struct scsi_host_template *sht)\r\n{\r\nif (!sht->show_info)\r\nreturn;\r\nmutex_lock(&global_host_template_mutex);\r\nif (!--sht->present && sht->proc_dir) {\r\nremove_proc_entry(sht->proc_name, proc_scsi);\r\nsht->proc_dir = NULL;\r\n}\r\nmutex_unlock(&global_host_template_mutex);\r\n}\r\nvoid scsi_proc_host_add(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_host_template *sht = shost->hostt;\r\nstruct proc_dir_entry *p;\r\nchar name[10];\r\nif (!sht->proc_dir)\r\nreturn;\r\nsprintf(name,"%d", shost->host_no);\r\np = proc_create_data(name, S_IRUGO | S_IWUSR,\r\nsht->proc_dir, &proc_scsi_fops, shost);\r\nif (!p)\r\nprintk(KERN_ERR "%s: Failed to register host %d in"\r\n"%s\n", __func__, shost->host_no,\r\nsht->proc_name);\r\n}\r\nvoid scsi_proc_host_rm(struct Scsi_Host *shost)\r\n{\r\nchar name[10];\r\nif (!shost->hostt->proc_dir)\r\nreturn;\r\nsprintf(name,"%d", shost->host_no);\r\nremove_proc_entry(name, shost->hostt->proc_dir);\r\n}\r\nstatic int proc_print_scsidevice(struct device *dev, void *data)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct seq_file *s = data;\r\nint i;\r\nif (!scsi_is_sdev_device(dev))\r\ngoto out;\r\nsdev = to_scsi_device(dev);\r\nseq_printf(s,\r\n"Host: scsi%d Channel: %02d Id: %02d Lun: %02llu\n Vendor: ",\r\nsdev->host->host_no, sdev->channel, sdev->id, sdev->lun);\r\nfor (i = 0; i < 8; i++) {\r\nif (sdev->vendor[i] >= 0x20)\r\nseq_putc(s, sdev->vendor[i]);\r\nelse\r\nseq_putc(s, ' ');\r\n}\r\nseq_puts(s, " Model: ");\r\nfor (i = 0; i < 16; i++) {\r\nif (sdev->model[i] >= 0x20)\r\nseq_putc(s, sdev->model[i]);\r\nelse\r\nseq_putc(s, ' ');\r\n}\r\nseq_puts(s, " Rev: ");\r\nfor (i = 0; i < 4; i++) {\r\nif (sdev->rev[i] >= 0x20)\r\nseq_putc(s, sdev->rev[i]);\r\nelse\r\nseq_putc(s, ' ');\r\n}\r\nseq_putc(s, '\n');\r\nseq_printf(s, " Type: %s ", scsi_device_type(sdev->type));\r\nseq_printf(s, " ANSI SCSI revision: %02x",\r\nsdev->scsi_level - (sdev->scsi_level > 1));\r\nif (sdev->scsi_level == 2)\r\nseq_puts(s, " CCS\n");\r\nelse\r\nseq_putc(s, '\n');\r\nout:\r\nreturn 0;\r\n}\r\nstatic int scsi_add_single_device(uint host, uint channel, uint id, uint lun)\r\n{\r\nstruct Scsi_Host *shost;\r\nint error = -ENXIO;\r\nshost = scsi_host_lookup(host);\r\nif (!shost)\r\nreturn error;\r\nif (shost->transportt->user_scan)\r\nerror = shost->transportt->user_scan(shost, channel, id, lun);\r\nelse\r\nerror = scsi_scan_host_selected(shost, channel, id, lun,\r\nSCSI_SCAN_MANUAL);\r\nscsi_host_put(shost);\r\nreturn error;\r\n}\r\nstatic int scsi_remove_single_device(uint host, uint channel, uint id, uint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct Scsi_Host *shost;\r\nint error = -ENXIO;\r\nshost = scsi_host_lookup(host);\r\nif (!shost)\r\nreturn error;\r\nsdev = scsi_device_lookup(shost, channel, id, lun);\r\nif (sdev) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\nerror = 0;\r\n}\r\nscsi_host_put(shost);\r\nreturn error;\r\n}\r\nstatic ssize_t proc_scsi_write(struct file *file, const char __user *buf,\r\nsize_t length, loff_t *ppos)\r\n{\r\nint host, channel, id, lun;\r\nchar *buffer, *p;\r\nint err;\r\nif (!buf || length > PAGE_SIZE)\r\nreturn -EINVAL;\r\nbuffer = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nerr = -EFAULT;\r\nif (copy_from_user(buffer, buf, length))\r\ngoto out;\r\nerr = -EINVAL;\r\nif (length < PAGE_SIZE)\r\nbuffer[length] = '\0';\r\nelse if (buffer[PAGE_SIZE-1])\r\ngoto out;\r\nif (!strncmp("scsi add-single-device", buffer, 22)) {\r\np = buffer + 23;\r\nhost = simple_strtoul(p, &p, 0);\r\nchannel = simple_strtoul(p + 1, &p, 0);\r\nid = simple_strtoul(p + 1, &p, 0);\r\nlun = simple_strtoul(p + 1, &p, 0);\r\nerr = scsi_add_single_device(host, channel, id, lun);\r\n} else if (!strncmp("scsi remove-single-device", buffer, 25)) {\r\np = buffer + 26;\r\nhost = simple_strtoul(p, &p, 0);\r\nchannel = simple_strtoul(p + 1, &p, 0);\r\nid = simple_strtoul(p + 1, &p, 0);\r\nlun = simple_strtoul(p + 1, &p, 0);\r\nerr = scsi_remove_single_device(host, channel, id, lun);\r\n}\r\nif (!err)\r\nerr = length;\r\nout:\r\nfree_page((unsigned long)buffer);\r\nreturn err;\r\n}\r\nstatic int always_match(struct device *dev, void *data)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline struct device *next_scsi_device(struct device *start)\r\n{\r\nstruct device *next = bus_find_device(&scsi_bus_type, start, NULL,\r\nalways_match);\r\nput_device(start);\r\nreturn next;\r\n}\r\nstatic void *scsi_seq_start(struct seq_file *sfile, loff_t *pos)\r\n{\r\nstruct device *dev = NULL;\r\nloff_t n = *pos;\r\nwhile ((dev = next_scsi_device(dev))) {\r\nif (!n--)\r\nbreak;\r\nsfile->private++;\r\n}\r\nreturn dev;\r\n}\r\nstatic void *scsi_seq_next(struct seq_file *sfile, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nsfile->private++;\r\nreturn next_scsi_device(v);\r\n}\r\nstatic void scsi_seq_stop(struct seq_file *sfile, void *v)\r\n{\r\nput_device(v);\r\n}\r\nstatic int scsi_seq_show(struct seq_file *sfile, void *dev)\r\n{\r\nif (!sfile->private)\r\nseq_puts(sfile, "Attached devices:\n");\r\nreturn proc_print_scsidevice(dev, sfile);\r\n}\r\nstatic int proc_scsi_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &scsi_seq_ops);\r\n}\r\nint __init scsi_init_procfs(void)\r\n{\r\nstruct proc_dir_entry *pde;\r\nproc_scsi = proc_mkdir("scsi", NULL);\r\nif (!proc_scsi)\r\ngoto err1;\r\npde = proc_create("scsi/scsi", 0, NULL, &proc_scsi_operations);\r\nif (!pde)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nremove_proc_entry("scsi", NULL);\r\nerr1:\r\nreturn -ENOMEM;\r\n}\r\nvoid scsi_exit_procfs(void)\r\n{\r\nremove_proc_entry("scsi/scsi", NULL);\r\nremove_proc_entry("scsi", NULL);\r\n}
