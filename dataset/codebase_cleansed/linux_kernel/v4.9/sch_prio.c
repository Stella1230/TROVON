static struct Qdisc *\r\nprio_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nu32 band = skb->priority;\r\nstruct tcf_result res;\r\nstruct tcf_proto *fl;\r\nint err;\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\r\nif (TC_H_MAJ(skb->priority) != sch->handle) {\r\nfl = rcu_dereference_bh(q->filter_list);\r\nerr = tc_classify(skb, fl, &res, false);\r\n#ifdef CONFIG_NET_CLS_ACT\r\nswitch (err) {\r\ncase TC_ACT_STOLEN:\r\ncase TC_ACT_QUEUED:\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\r\ncase TC_ACT_SHOT:\r\nreturn NULL;\r\n}\r\n#endif\r\nif (!fl || err < 0) {\r\nif (TC_H_MAJ(band))\r\nband = 0;\r\nreturn q->queues[q->prio2band[band & TC_PRIO_MAX]];\r\n}\r\nband = res.classid;\r\n}\r\nband = TC_H_MIN(band) - 1;\r\nif (band >= q->bands)\r\nreturn q->queues[q->prio2band[0]];\r\nreturn q->queues[band];\r\n}\r\nstatic int\r\nprio_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)\r\n{\r\nstruct Qdisc *qdisc;\r\nint ret;\r\nqdisc = prio_classify(skb, sch, &ret);\r\n#ifdef CONFIG_NET_CLS_ACT\r\nif (qdisc == NULL) {\r\nif (ret & __NET_XMIT_BYPASS)\r\nqdisc_qstats_drop(sch);\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\n#endif\r\nret = qdisc_enqueue(skb, qdisc, to_free);\r\nif (ret == NET_XMIT_SUCCESS) {\r\nqdisc_qstats_backlog_inc(sch, skb);\r\nsch->q.qlen++;\r\nreturn NET_XMIT_SUCCESS;\r\n}\r\nif (net_xmit_drop_count(ret))\r\nqdisc_qstats_drop(sch);\r\nreturn ret;\r\n}\r\nstatic struct sk_buff *prio_peek(struct Qdisc *sch)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nint prio;\r\nfor (prio = 0; prio < q->bands; prio++) {\r\nstruct Qdisc *qdisc = q->queues[prio];\r\nstruct sk_buff *skb = qdisc->ops->peek(qdisc);\r\nif (skb)\r\nreturn skb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *prio_dequeue(struct Qdisc *sch)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nint prio;\r\nfor (prio = 0; prio < q->bands; prio++) {\r\nstruct Qdisc *qdisc = q->queues[prio];\r\nstruct sk_buff *skb = qdisc_dequeue_peeked(qdisc);\r\nif (skb) {\r\nqdisc_bstats_update(sch, skb);\r\nqdisc_qstats_backlog_dec(sch, skb);\r\nsch->q.qlen--;\r\nreturn skb;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nprio_reset(struct Qdisc *sch)\r\n{\r\nint prio;\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nfor (prio = 0; prio < q->bands; prio++)\r\nqdisc_reset(q->queues[prio]);\r\nsch->qstats.backlog = 0;\r\nsch->q.qlen = 0;\r\n}\r\nstatic void\r\nprio_destroy(struct Qdisc *sch)\r\n{\r\nint prio;\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\ntcf_destroy_chain(&q->filter_list);\r\nfor (prio = 0; prio < q->bands; prio++)\r\nqdisc_destroy(q->queues[prio]);\r\n}\r\nstatic int prio_tune(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *queues[TCQ_PRIO_BANDS];\r\nint oldbands = q->bands, i;\r\nstruct tc_prio_qopt *qopt;\r\nif (nla_len(opt) < sizeof(*qopt))\r\nreturn -EINVAL;\r\nqopt = nla_data(opt);\r\nif (qopt->bands > TCQ_PRIO_BANDS || qopt->bands < 2)\r\nreturn -EINVAL;\r\nfor (i = 0; i <= TC_PRIO_MAX; i++) {\r\nif (qopt->priomap[i] >= qopt->bands)\r\nreturn -EINVAL;\r\n}\r\nfor (i = oldbands; i < qopt->bands; i++) {\r\nqueues[i] = qdisc_create_dflt(sch->dev_queue, &pfifo_qdisc_ops,\r\nTC_H_MAKE(sch->handle, i + 1));\r\nif (!queues[i]) {\r\nwhile (i > oldbands)\r\nqdisc_destroy(queues[--i]);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nsch_tree_lock(sch);\r\nq->bands = qopt->bands;\r\nmemcpy(q->prio2band, qopt->priomap, TC_PRIO_MAX+1);\r\nfor (i = q->bands; i < oldbands; i++) {\r\nstruct Qdisc *child = q->queues[i];\r\nqdisc_tree_reduce_backlog(child, child->q.qlen,\r\nchild->qstats.backlog);\r\nqdisc_destroy(child);\r\n}\r\nfor (i = oldbands; i < q->bands; i++)\r\nq->queues[i] = queues[i];\r\nsch_tree_unlock(sch);\r\nreturn 0;\r\n}\r\nstatic int prio_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nif (!opt)\r\nreturn -EINVAL;\r\nreturn prio_tune(sch, opt);\r\n}\r\nstatic int prio_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tc_prio_qopt opt;\r\nopt.bands = q->bands;\r\nmemcpy(&opt.priomap, q->prio2band, TC_PRIO_MAX + 1);\r\nif (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int prio_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\r\nstruct Qdisc **old)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = arg - 1;\r\nif (new == NULL)\r\nnew = &noop_qdisc;\r\n*old = qdisc_replace(sch, new, &q->queues[band]);\r\nreturn 0;\r\n}\r\nstatic struct Qdisc *\r\nprio_leaf(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = arg - 1;\r\nreturn q->queues[band];\r\n}\r\nstatic unsigned long prio_get(struct Qdisc *sch, u32 classid)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = TC_H_MIN(classid);\r\nif (band - 1 >= q->bands)\r\nreturn 0;\r\nreturn band;\r\n}\r\nstatic unsigned long prio_bind(struct Qdisc *sch, unsigned long parent, u32 classid)\r\n{\r\nreturn prio_get(sch, classid);\r\n}\r\nstatic void prio_put(struct Qdisc *q, unsigned long cl)\r\n{\r\n}\r\nstatic int prio_dump_class(struct Qdisc *sch, unsigned long cl, struct sk_buff *skb,\r\nstruct tcmsg *tcm)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\ntcm->tcm_handle |= TC_H_MIN(cl);\r\ntcm->tcm_info = q->queues[cl-1]->handle;\r\nreturn 0;\r\n}\r\nstatic int prio_dump_class_stats(struct Qdisc *sch, unsigned long cl,\r\nstruct gnet_dump *d)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *cl_q;\r\ncl_q = q->queues[cl - 1];\r\nif (gnet_stats_copy_basic(qdisc_root_sleeping_running(sch),\r\nd, NULL, &cl_q->bstats) < 0 ||\r\ngnet_stats_copy_queue(d, NULL, &cl_q->qstats, cl_q->q.qlen) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void prio_walk(struct Qdisc *sch, struct qdisc_walker *arg)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nint prio;\r\nif (arg->stop)\r\nreturn;\r\nfor (prio = 0; prio < q->bands; prio++) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(sch, prio + 1, arg) < 0) {\r\narg->stop = 1;\r\nbreak;\r\n}\r\narg->count++;\r\n}\r\n}\r\nstatic struct tcf_proto __rcu **prio_find_tcf(struct Qdisc *sch,\r\nunsigned long cl)\r\n{\r\nstruct prio_sched_data *q = qdisc_priv(sch);\r\nif (cl)\r\nreturn NULL;\r\nreturn &q->filter_list;\r\n}\r\nstatic int __init prio_module_init(void)\r\n{\r\nreturn register_qdisc(&prio_qdisc_ops);\r\n}\r\nstatic void __exit prio_module_exit(void)\r\n{\r\nunregister_qdisc(&prio_qdisc_ops);\r\n}
