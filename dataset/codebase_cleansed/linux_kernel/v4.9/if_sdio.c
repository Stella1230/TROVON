static u16 if_sdio_read_scratch(struct if_sdio_card *card, int *err)\r\n{\r\nint ret;\r\nu16 scratch;\r\nscratch = sdio_readb(card->func, card->scratch_reg, &ret);\r\nif (!ret)\r\nscratch |= sdio_readb(card->func, card->scratch_reg + 1,\r\n&ret) << 8;\r\nif (err)\r\n*err = ret;\r\nif (ret)\r\nreturn 0xffff;\r\nreturn scratch;\r\n}\r\nstatic u8 if_sdio_read_rx_unit(struct if_sdio_card *card)\r\n{\r\nint ret;\r\nu8 rx_unit;\r\nrx_unit = sdio_readb(card->func, IF_SDIO_RX_UNIT, &ret);\r\nif (ret)\r\nrx_unit = 0;\r\nreturn rx_unit;\r\n}\r\nstatic u16 if_sdio_read_rx_len(struct if_sdio_card *card, int *err)\r\n{\r\nint ret;\r\nu16 rx_len;\r\nswitch (card->model) {\r\ncase MODEL_8385:\r\ncase MODEL_8686:\r\nrx_len = if_sdio_read_scratch(card, &ret);\r\nbreak;\r\ncase MODEL_8688:\r\ndefault:\r\nrx_len = sdio_readb(card->func, IF_SDIO_RX_LEN, &ret);\r\nif (!ret)\r\nrx_len <<= card->rx_unit;\r\nelse\r\nrx_len = 0xffff;\r\nbreak;\r\n}\r\nif (err)\r\n*err = ret;\r\nreturn rx_len;\r\n}\r\nstatic int if_sdio_handle_cmd(struct if_sdio_card *card,\r\nu8 *buffer, unsigned size)\r\n{\r\nstruct lbs_private *priv = card->priv;\r\nint ret;\r\nunsigned long flags;\r\nu8 i;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nif (size > LBS_CMD_BUFFER_SIZE) {\r\nlbs_deb_sdio("response packet too large (%d bytes)\n",\r\n(int)size);\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\ni = (priv->resp_idx == 0) ? 1 : 0;\r\nBUG_ON(priv->resp_len[i]);\r\npriv->resp_len[i] = size;\r\nmemcpy(priv->resp_buf[i], buffer, size);\r\nlbs_notify_command_response(priv, i);\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\nret = 0;\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_handle_data(struct if_sdio_card *card,\r\nu8 *buffer, unsigned size)\r\n{\r\nint ret;\r\nstruct sk_buff *skb;\r\nchar *data;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nif (size > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {\r\nlbs_deb_sdio("response packet too large (%d bytes)\n",\r\n(int)size);\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\nskb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE + NET_IP_ALIGN);\r\nif (!skb) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nskb_reserve(skb, NET_IP_ALIGN);\r\ndata = skb_put(skb, size);\r\nmemcpy(data, buffer, size);\r\nlbs_process_rxed_packet(card->priv, skb);\r\nret = 0;\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_handle_event(struct if_sdio_card *card,\r\nu8 *buffer, unsigned size)\r\n{\r\nint ret;\r\nu32 event;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nif (card->model == MODEL_8385) {\r\nevent = sdio_readb(card->func, IF_SDIO_EVENT, &ret);\r\nif (ret)\r\ngoto out;\r\nevent >>= 3;\r\n} else {\r\nif (size < 4) {\r\nlbs_deb_sdio("event packet too small (%d bytes)\n",\r\n(int)size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nevent = buffer[3] << 24;\r\nevent |= buffer[2] << 16;\r\nevent |= buffer[1] << 8;\r\nevent |= buffer[0] << 0;\r\n}\r\nlbs_queue_event(card->priv, event & 0xFF);\r\nret = 0;\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_wait_status(struct if_sdio_card *card, const u8 condition)\r\n{\r\nu8 status;\r\nunsigned long timeout;\r\nint ret = 0;\r\ntimeout = jiffies + HZ;\r\nwhile (1) {\r\nstatus = sdio_readb(card->func, IF_SDIO_STATUS, &ret);\r\nif (ret)\r\nreturn ret;\r\nif ((status & condition) == condition)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nmdelay(1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int if_sdio_card_to_host(struct if_sdio_card *card)\r\n{\r\nint ret;\r\nu16 size, type, chunk;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nsize = if_sdio_read_rx_len(card, &ret);\r\nif (ret)\r\ngoto out;\r\nif (size < 4) {\r\nlbs_deb_sdio("invalid packet size (%d bytes) from firmware\n",\r\n(int)size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = if_sdio_wait_status(card, IF_SDIO_IO_RDY);\r\nif (ret)\r\ngoto out;\r\nchunk = sdio_align_size(card->func, size);\r\nret = sdio_readsb(card->func, card->buffer, card->ioport, chunk);\r\nif (ret)\r\ngoto out;\r\nchunk = card->buffer[0] | (card->buffer[1] << 8);\r\ntype = card->buffer[2] | (card->buffer[3] << 8);\r\nlbs_deb_sdio("packet of type %d and size %d bytes\n",\r\n(int)type, (int)chunk);\r\nif (chunk > size) {\r\nlbs_deb_sdio("packet fragment (%d > %d)\n",\r\n(int)chunk, (int)size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (chunk < size) {\r\nlbs_deb_sdio("packet fragment (%d < %d)\n",\r\n(int)chunk, (int)size);\r\n}\r\nswitch (type) {\r\ncase MVMS_CMD:\r\nret = if_sdio_handle_cmd(card, card->buffer + 4, chunk - 4);\r\nif (ret)\r\ngoto out;\r\nbreak;\r\ncase MVMS_DAT:\r\nret = if_sdio_handle_data(card, card->buffer + 4, chunk - 4);\r\nif (ret)\r\ngoto out;\r\nbreak;\r\ncase MVMS_EVENT:\r\nret = if_sdio_handle_event(card, card->buffer + 4, chunk - 4);\r\nif (ret)\r\ngoto out;\r\nbreak;\r\ndefault:\r\nlbs_deb_sdio("invalid type (%d) from firmware\n",\r\n(int)type);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nif (ret)\r\npr_err("problem fetching packet from firmware\n");\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void if_sdio_host_to_card_worker(struct work_struct *work)\r\n{\r\nstruct if_sdio_card *card;\r\nstruct if_sdio_packet *packet;\r\nint ret;\r\nunsigned long flags;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\ncard = container_of(work, struct if_sdio_card, packet_worker);\r\nwhile (1) {\r\nspin_lock_irqsave(&card->lock, flags);\r\npacket = card->packets;\r\nif (packet)\r\ncard->packets = packet->next;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (!packet)\r\nbreak;\r\nsdio_claim_host(card->func);\r\nret = if_sdio_wait_status(card, IF_SDIO_IO_RDY);\r\nif (ret == 0) {\r\nret = sdio_writesb(card->func, card->ioport,\r\npacket->buffer, packet->nb);\r\n}\r\nif (ret)\r\npr_err("error %d sending packet to firmware\n", ret);\r\nsdio_release_host(card->func);\r\nkfree(packet);\r\n}\r\nlbs_deb_leave(LBS_DEB_SDIO);\r\n}\r\nstatic int if_sdio_prog_helper(struct if_sdio_card *card,\r\nconst struct firmware *fw)\r\n{\r\nint ret;\r\nunsigned long timeout;\r\nu8 *chunk_buffer;\r\nu32 chunk_size;\r\nconst u8 *firmware;\r\nsize_t size;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nchunk_buffer = kzalloc(64, GFP_KERNEL);\r\nif (!chunk_buffer) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsdio_claim_host(card->func);\r\nret = sdio_set_block_size(card->func, 32);\r\nif (ret)\r\ngoto release;\r\nfirmware = fw->data;\r\nsize = fw->size;\r\nwhile (size) {\r\nret = if_sdio_wait_status(card, FW_DL_READY_STATUS);\r\nif (ret)\r\ngoto release;\r\nmdelay(2);\r\nchunk_size = min_t(size_t, size, 60);\r\n*((__le32*)chunk_buffer) = cpu_to_le32(chunk_size);\r\nmemcpy(chunk_buffer + 4, firmware, chunk_size);\r\nret = sdio_writesb(card->func, card->ioport,\r\nchunk_buffer, 64);\r\nif (ret)\r\ngoto release;\r\nfirmware += chunk_size;\r\nsize -= chunk_size;\r\n}\r\nmemset(chunk_buffer, 0, 4);\r\nret = sdio_writesb(card->func, card->ioport, chunk_buffer, 64);\r\nif (ret)\r\ngoto release;\r\nlbs_deb_sdio("waiting for helper to boot...\n");\r\ntimeout = jiffies + HZ;\r\nwhile (1) {\r\nu16 req_size;\r\nreq_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);\r\nif (ret)\r\ngoto release;\r\nreq_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;\r\nif (ret)\r\ngoto release;\r\nif (req_size != 0)\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\nret = -ETIMEDOUT;\r\ngoto release;\r\n}\r\nmsleep(10);\r\n}\r\nret = 0;\r\nrelease:\r\nsdio_release_host(card->func);\r\nkfree(chunk_buffer);\r\nout:\r\nif (ret)\r\npr_err("failed to load helper firmware\n");\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_prog_real(struct if_sdio_card *card,\r\nconst struct firmware *fw)\r\n{\r\nint ret;\r\nunsigned long timeout;\r\nu8 *chunk_buffer;\r\nu32 chunk_size;\r\nconst u8 *firmware;\r\nsize_t size, req_size;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nchunk_buffer = kzalloc(512, GFP_KERNEL);\r\nif (!chunk_buffer) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsdio_claim_host(card->func);\r\nret = sdio_set_block_size(card->func, 32);\r\nif (ret)\r\ngoto release;\r\nfirmware = fw->data;\r\nsize = fw->size;\r\nwhile (size) {\r\ntimeout = jiffies + HZ;\r\nwhile (1) {\r\nret = if_sdio_wait_status(card, FW_DL_READY_STATUS);\r\nif (ret)\r\ngoto release;\r\nreq_size = sdio_readb(card->func, IF_SDIO_RD_BASE,\r\n&ret);\r\nif (ret)\r\ngoto release;\r\nreq_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1,\r\n&ret) << 8;\r\nif (ret)\r\ngoto release;\r\nif ((size != fw->size) || (req_size > 2))\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\nret = -ETIMEDOUT;\r\ngoto release;\r\n}\r\nmdelay(1);\r\n}\r\nif (req_size == 0) {\r\nlbs_deb_sdio("firmware helper gave up early\n");\r\nret = -EIO;\r\ngoto release;\r\n}\r\nif (req_size & 0x01) {\r\nlbs_deb_sdio("firmware helper signalled error\n");\r\nret = -EIO;\r\ngoto release;\r\n}\r\nif (req_size > size)\r\nreq_size = size;\r\nwhile (req_size) {\r\nchunk_size = min_t(size_t, req_size, 512);\r\nmemcpy(chunk_buffer, firmware, chunk_size);\r\nret = sdio_writesb(card->func, card->ioport,\r\nchunk_buffer, roundup(chunk_size, 32));\r\nif (ret)\r\ngoto release;\r\nfirmware += chunk_size;\r\nsize -= chunk_size;\r\nreq_size -= chunk_size;\r\n}\r\n}\r\nret = 0;\r\nlbs_deb_sdio("waiting for firmware to boot...\n");\r\ntimeout = jiffies + HZ;\r\nwhile (1) {\r\nu16 scratch;\r\nscratch = if_sdio_read_scratch(card, &ret);\r\nif (ret)\r\ngoto release;\r\nif (scratch == IF_SDIO_FIRMWARE_OK)\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\nret = -ETIMEDOUT;\r\ngoto release;\r\n}\r\nmsleep(10);\r\n}\r\nret = 0;\r\nrelease:\r\nsdio_release_host(card->func);\r\nkfree(chunk_buffer);\r\nout:\r\nif (ret)\r\npr_err("failed to load firmware\n");\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void if_sdio_do_prog_firmware(struct lbs_private *priv, int ret,\r\nconst struct firmware *helper,\r\nconst struct firmware *mainfw)\r\n{\r\nstruct if_sdio_card *card = priv->card;\r\nif (ret) {\r\npr_err("failed to find firmware (%d)\n", ret);\r\nreturn;\r\n}\r\nret = if_sdio_prog_helper(card, helper);\r\nif (ret)\r\nreturn;\r\nlbs_deb_sdio("Helper firmware loaded\n");\r\nret = if_sdio_prog_real(card, mainfw);\r\nif (ret)\r\nreturn;\r\nlbs_deb_sdio("Firmware loaded\n");\r\nif_sdio_finish_power_on(card);\r\n}\r\nstatic int if_sdio_prog_firmware(struct if_sdio_card *card)\r\n{\r\nint ret;\r\nu16 scratch;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nsdio_claim_host(card->func);\r\nsdio_writeb(card->func, 0x00, IF_SDIO_H_INT_MASK, &ret);\r\nsdio_release_host(card->func);\r\nsdio_claim_host(card->func);\r\nscratch = if_sdio_read_scratch(card, &ret);\r\nsdio_release_host(card->func);\r\nlbs_deb_sdio("firmware status = %#x\n", scratch);\r\nlbs_deb_sdio("scratch ret = %d\n", ret);\r\nif (ret)\r\ngoto out;\r\nif (scratch == IF_SDIO_FIRMWARE_OK) {\r\nlbs_deb_sdio("firmware already loaded\n");\r\nif_sdio_finish_power_on(card);\r\nreturn 0;\r\n} else if ((card->model == MODEL_8686) && (scratch & 0x7fff)) {\r\nlbs_deb_sdio("firmware may be running\n");\r\nif_sdio_finish_power_on(card);\r\nreturn 0;\r\n}\r\nret = lbs_get_firmware_async(card->priv, &card->func->dev, card->model,\r\nfw_table, if_sdio_do_prog_firmware);\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void if_sdio_finish_power_on(struct if_sdio_card *card)\r\n{\r\nstruct sdio_func *func = card->func;\r\nstruct lbs_private *priv = card->priv;\r\nint ret;\r\nsdio_claim_host(func);\r\nsdio_set_block_size(card->func, IF_SDIO_BLOCK_SIZE);\r\nif ((card->model != MODEL_8385)\r\n&& (card->model != MODEL_8686))\r\ncard->rx_unit = if_sdio_read_rx_unit(card);\r\nelse\r\ncard->rx_unit = 0;\r\nret = sdio_claim_irq(func, if_sdio_interrupt);\r\nif (ret)\r\ngoto release;\r\nsdio_writeb(func, 0x0f, IF_SDIO_H_INT_MASK, &ret);\r\nif (ret)\r\ngoto release_irq;\r\nsdio_release_host(func);\r\npriv->fw_ready = 1;\r\nif (card->model == MODEL_8688) {\r\nstruct cmd_header cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nlbs_deb_sdio("send function INIT command\n");\r\nif (__lbs_cmd(priv, CMD_FUNC_INIT, &cmd, sizeof(cmd),\r\nlbs_cmd_copyback, (unsigned long) &cmd))\r\nnetdev_alert(priv->dev, "CMD_FUNC_INIT cmd failed\n");\r\n}\r\nwake_up(&card->pwron_waitq);\r\nif (!card->started) {\r\nret = lbs_start_card(priv);\r\nif_sdio_power_off(card);\r\nif (ret == 0) {\r\ncard->started = true;\r\npm_runtime_put(&func->dev);\r\n}\r\n}\r\nreturn;\r\nrelease_irq:\r\nsdio_release_irq(func);\r\nrelease:\r\nsdio_release_host(func);\r\n}\r\nstatic int if_sdio_power_on(struct if_sdio_card *card)\r\n{\r\nstruct sdio_func *func = card->func;\r\nstruct mmc_host *host = func->card->host;\r\nint ret;\r\nsdio_claim_host(func);\r\nret = sdio_enable_func(func);\r\nif (ret)\r\ngoto release;\r\nif ((card->model == MODEL_8686) &&\r\n(host->caps & MMC_CAP_SDIO_IRQ) &&\r\n(host->ios.bus_width == MMC_BUS_WIDTH_1)) {\r\nu8 reg;\r\nfunc->card->quirks |= MMC_QUIRK_LENIENT_FN0;\r\nreg = sdio_f0_readb(func, SDIO_CCCR_IF, &ret);\r\nif (ret)\r\ngoto disable;\r\nreg |= SDIO_BUS_ECSI;\r\nsdio_f0_writeb(func, reg, SDIO_CCCR_IF, &ret);\r\nif (ret)\r\ngoto disable;\r\n}\r\ncard->ioport = sdio_readb(func, IF_SDIO_IOPORT, &ret);\r\nif (ret)\r\ngoto disable;\r\ncard->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 1, &ret) << 8;\r\nif (ret)\r\ngoto disable;\r\ncard->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 2, &ret) << 16;\r\nif (ret)\r\ngoto disable;\r\nsdio_release_host(func);\r\nret = if_sdio_prog_firmware(card);\r\nif (ret) {\r\nsdio_claim_host(func);\r\ngoto disable;\r\n}\r\nreturn 0;\r\ndisable:\r\nsdio_disable_func(func);\r\nrelease:\r\nsdio_release_host(func);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_power_off(struct if_sdio_card *card)\r\n{\r\nstruct sdio_func *func = card->func;\r\nstruct lbs_private *priv = card->priv;\r\npriv->fw_ready = 0;\r\nsdio_claim_host(func);\r\nsdio_release_irq(func);\r\nsdio_disable_func(func);\r\nsdio_release_host(func);\r\nreturn 0;\r\n}\r\nstatic int if_sdio_host_to_card(struct lbs_private *priv,\r\nu8 type, u8 *buf, u16 nb)\r\n{\r\nint ret;\r\nstruct if_sdio_card *card;\r\nstruct if_sdio_packet *packet, *cur;\r\nu16 size;\r\nunsigned long flags;\r\nlbs_deb_enter_args(LBS_DEB_SDIO, "type %d, bytes %d", type, nb);\r\ncard = priv->card;\r\nif (nb > (65536 - sizeof(struct if_sdio_packet) - 4)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nsize = sdio_align_size(card->func, nb + 4);\r\npacket = kzalloc(sizeof(struct if_sdio_packet) + size,\r\nGFP_ATOMIC);\r\nif (!packet) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npacket->next = NULL;\r\npacket->nb = size;\r\npacket->buffer[0] = (nb + 4) & 0xff;\r\npacket->buffer[1] = ((nb + 4) >> 8) & 0xff;\r\npacket->buffer[2] = type;\r\npacket->buffer[3] = 0;\r\nmemcpy(packet->buffer + 4, buf, nb);\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (!card->packets)\r\ncard->packets = packet;\r\nelse {\r\ncur = card->packets;\r\nwhile (cur->next)\r\ncur = cur->next;\r\ncur->next = packet;\r\n}\r\nswitch (type) {\r\ncase MVMS_CMD:\r\npriv->dnld_sent = DNLD_CMD_SENT;\r\nbreak;\r\ncase MVMS_DAT:\r\npriv->dnld_sent = DNLD_DATA_SENT;\r\nbreak;\r\ndefault:\r\nlbs_deb_sdio("unknown packet type %d\n", (int)type);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nqueue_work(card->workqueue, &card->packet_worker);\r\nret = 0;\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_enter_deep_sleep(struct lbs_private *priv)\r\n{\r\nint ret = -1;\r\nstruct cmd_header cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nlbs_deb_sdio("send DEEP_SLEEP command\n");\r\nret = __lbs_cmd(priv, CMD_802_11_DEEP_SLEEP, &cmd, sizeof(cmd),\r\nlbs_cmd_copyback, (unsigned long) &cmd);\r\nif (ret)\r\nnetdev_err(priv->dev, "DEEP_SLEEP cmd failed\n");\r\nmdelay(200);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_exit_deep_sleep(struct lbs_private *priv)\r\n{\r\nstruct if_sdio_card *card = priv->card;\r\nint ret = -1;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nsdio_claim_host(card->func);\r\nsdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);\r\nif (ret)\r\nnetdev_err(priv->dev, "sdio_writeb failed!\n");\r\nsdio_release_host(card->func);\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_reset_deep_sleep_wakeup(struct lbs_private *priv)\r\n{\r\nstruct if_sdio_card *card = priv->card;\r\nint ret = -1;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nsdio_claim_host(card->func);\r\nsdio_writeb(card->func, 0, CONFIGURATION_REG, &ret);\r\nif (ret)\r\nnetdev_err(priv->dev, "sdio_writeb failed!\n");\r\nsdio_release_host(card->func);\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void if_sdio_reset_card_worker(struct work_struct *work)\r\n{\r\npr_info("Resetting card...");\r\nmmc_remove_host(reset_host);\r\nmmc_add_host(reset_host);\r\n}\r\nstatic void if_sdio_reset_card(struct lbs_private *priv)\r\n{\r\nstruct if_sdio_card *card = priv->card;\r\nif (work_pending(&card_reset_work))\r\nreturn;\r\nreset_host = card->func->card->host;\r\nschedule_work(&card_reset_work);\r\n}\r\nstatic int if_sdio_power_save(struct lbs_private *priv)\r\n{\r\nstruct if_sdio_card *card = priv->card;\r\nint ret;\r\nflush_workqueue(card->workqueue);\r\nret = if_sdio_power_off(card);\r\npm_runtime_put_sync(&card->func->dev);\r\nreturn ret;\r\n}\r\nstatic int if_sdio_power_restore(struct lbs_private *priv)\r\n{\r\nstruct if_sdio_card *card = priv->card;\r\nint r;\r\npm_runtime_get_sync(&card->func->dev);\r\nr = if_sdio_power_on(card);\r\nif (r)\r\nreturn r;\r\nwait_event(card->pwron_waitq, priv->fw_ready);\r\nreturn 0;\r\n}\r\nstatic void if_sdio_interrupt(struct sdio_func *func)\r\n{\r\nint ret;\r\nstruct if_sdio_card *card;\r\nu8 cause;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\ncard = sdio_get_drvdata(func);\r\ncause = sdio_readb(card->func, IF_SDIO_H_INT_STATUS, &ret);\r\nif (ret || !cause)\r\ngoto out;\r\nlbs_deb_sdio("interrupt: 0x%X\n", (unsigned)cause);\r\nsdio_writeb(card->func, ~cause, IF_SDIO_H_INT_STATUS, &ret);\r\nif (ret)\r\ngoto out;\r\ncard->priv->is_activity_detected = 1;\r\nif (cause & IF_SDIO_H_INT_DNLD)\r\nlbs_host_to_card_done(card->priv);\r\nif (cause & IF_SDIO_H_INT_UPLD) {\r\nret = if_sdio_card_to_host(card);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\n}\r\nstatic int if_sdio_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nstruct if_sdio_card *card;\r\nstruct lbs_private *priv;\r\nint ret, i;\r\nunsigned int model;\r\nstruct if_sdio_packet *packet;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nfor (i = 0;i < func->card->num_info;i++) {\r\nif (sscanf(func->card->info[i],\r\n"802.11 SDIO ID: %x", &model) == 1)\r\nbreak;\r\nif (sscanf(func->card->info[i],\r\n"ID: %x", &model) == 1)\r\nbreak;\r\nif (!strcmp(func->card->info[i], "IBIS Wireless SDIO Card")) {\r\nmodel = MODEL_8385;\r\nbreak;\r\n}\r\n}\r\nif (i == func->card->num_info) {\r\npr_err("unable to identify card model\n");\r\nreturn -ENODEV;\r\n}\r\ncard = kzalloc(sizeof(struct if_sdio_card), GFP_KERNEL);\r\nif (!card)\r\nreturn -ENOMEM;\r\ncard->func = func;\r\ncard->model = model;\r\nswitch (card->model) {\r\ncase MODEL_8385:\r\ncard->scratch_reg = IF_SDIO_SCRATCH_OLD;\r\nbreak;\r\ncase MODEL_8686:\r\ncard->scratch_reg = IF_SDIO_SCRATCH;\r\nbreak;\r\ncase MODEL_8688:\r\ndefault:\r\ncard->scratch_reg = IF_SDIO_FW_STATUS;\r\nbreak;\r\n}\r\nspin_lock_init(&card->lock);\r\ncard->workqueue = alloc_workqueue("libertas_sdio", WQ_MEM_RECLAIM, 0);\r\nINIT_WORK(&card->packet_worker, if_sdio_host_to_card_worker);\r\ninit_waitqueue_head(&card->pwron_waitq);\r\nfor (i = 0; i < ARRAY_SIZE(fw_table); i++) {\r\nif (card->model == fw_table[i].model)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fw_table)) {\r\npr_err("unknown card model 0x%x\n", card->model);\r\nret = -ENODEV;\r\ngoto free;\r\n}\r\nsdio_set_drvdata(func, card);\r\nlbs_deb_sdio("class = 0x%X, vendor = 0x%X, "\r\n"device = 0x%X, model = 0x%X, ioport = 0x%X\n",\r\nfunc->class, func->vendor, func->device,\r\nmodel, (unsigned)card->ioport);\r\npriv = lbs_add_card(card, &func->dev);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\ncard->priv = priv;\r\npriv->card = card;\r\npriv->hw_host_to_card = if_sdio_host_to_card;\r\npriv->enter_deep_sleep = if_sdio_enter_deep_sleep;\r\npriv->exit_deep_sleep = if_sdio_exit_deep_sleep;\r\npriv->reset_deep_sleep_wakeup = if_sdio_reset_deep_sleep_wakeup;\r\npriv->reset_card = if_sdio_reset_card;\r\npriv->power_save = if_sdio_power_save;\r\npriv->power_restore = if_sdio_power_restore;\r\npriv->is_polling = !(func->card->host->caps & MMC_CAP_SDIO_IRQ);\r\nret = if_sdio_power_on(card);\r\nif (ret)\r\ngoto err_activate_card;\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\nerr_activate_card:\r\nflush_workqueue(card->workqueue);\r\nlbs_remove_card(priv);\r\nfree:\r\ndestroy_workqueue(card->workqueue);\r\nwhile (card->packets) {\r\npacket = card->packets;\r\ncard->packets = card->packets->next;\r\nkfree(packet);\r\n}\r\nkfree(card);\r\ngoto out;\r\n}\r\nstatic void if_sdio_remove(struct sdio_func *func)\r\n{\r\nstruct if_sdio_card *card;\r\nstruct if_sdio_packet *packet;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\ncard = sdio_get_drvdata(func);\r\npm_runtime_get_noresume(&func->dev);\r\nif (user_rmmod && (card->model == MODEL_8688)) {\r\nstruct cmd_header cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nlbs_deb_sdio("send function SHUTDOWN command\n");\r\nif (__lbs_cmd(card->priv, CMD_FUNC_SHUTDOWN,\r\n&cmd, sizeof(cmd), lbs_cmd_copyback,\r\n(unsigned long) &cmd))\r\npr_alert("CMD_FUNC_SHUTDOWN cmd failed\n");\r\n}\r\nlbs_deb_sdio("call remove card\n");\r\nlbs_stop_card(card->priv);\r\nlbs_remove_card(card->priv);\r\ndestroy_workqueue(card->workqueue);\r\nwhile (card->packets) {\r\npacket = card->packets;\r\ncard->packets = card->packets->next;\r\nkfree(packet);\r\n}\r\nkfree(card);\r\nlbs_deb_leave(LBS_DEB_SDIO);\r\n}\r\nstatic int if_sdio_suspend(struct device *dev)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(dev);\r\nint ret;\r\nstruct if_sdio_card *card = sdio_get_drvdata(func);\r\nmmc_pm_flag_t flags = sdio_get_host_pm_caps(func);\r\nif (!lbs_iface_active(card->priv))\r\nreturn -ENOSYS;\r\ndev_info(dev, "%s: suspend: PM flags = 0x%x\n",\r\nsdio_func_id(func), flags);\r\nif (card->priv->wol_criteria == EHS_REMOVE_WAKEUP) {\r\ndev_info(dev, "Suspend without wake params -- powering down card\n");\r\nreturn -ENOSYS;\r\n}\r\nif (!(flags & MMC_PM_KEEP_POWER)) {\r\ndev_err(dev, "%s: cannot remain alive while host is suspended\n",\r\nsdio_func_id(func));\r\nreturn -ENOSYS;\r\n}\r\nret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\r\nif (ret)\r\nreturn ret;\r\nret = lbs_suspend(card->priv);\r\nif (ret)\r\nreturn ret;\r\nreturn sdio_set_host_pm_flags(func, MMC_PM_WAKE_SDIO_IRQ);\r\n}\r\nstatic int if_sdio_resume(struct device *dev)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(dev);\r\nstruct if_sdio_card *card = sdio_get_drvdata(func);\r\nint ret;\r\ndev_info(dev, "%s: resume: we're back\n", sdio_func_id(func));\r\nret = lbs_resume(card->priv);\r\nreturn ret;\r\n}\r\nstatic int __init if_sdio_init_module(void)\r\n{\r\nint ret = 0;\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nprintk(KERN_INFO "libertas_sdio: Libertas SDIO driver\n");\r\nprintk(KERN_INFO "libertas_sdio: Copyright Pierre Ossman\n");\r\nret = sdio_register_driver(&if_sdio_driver);\r\nuser_rmmod = 0;\r\nlbs_deb_leave_args(LBS_DEB_SDIO, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit if_sdio_exit_module(void)\r\n{\r\nlbs_deb_enter(LBS_DEB_SDIO);\r\nuser_rmmod = 1;\r\ncancel_work_sync(&card_reset_work);\r\nsdio_unregister_driver(&if_sdio_driver);\r\nlbs_deb_leave(LBS_DEB_SDIO);\r\n}
