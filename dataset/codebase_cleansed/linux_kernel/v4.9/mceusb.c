static int mceusb_cmd_datasize(u8 cmd, u8 subcmd)\r\n{\r\nint datasize = 0;\r\nswitch (cmd) {\r\ncase MCE_CMD_NULL:\r\nif (subcmd == MCE_CMD_PORT_SYS)\r\ndatasize = 1;\r\nbreak;\r\ncase MCE_CMD_PORT_SYS:\r\nswitch (subcmd) {\r\ncase MCE_RSP_GETPORTSTATUS:\r\ndatasize = 5;\r\nbreak;\r\ncase MCE_RSP_EQWAKEVERSION:\r\ndatasize = 4;\r\nbreak;\r\ncase MCE_CMD_G_REVISION:\r\ndatasize = 2;\r\nbreak;\r\ncase MCE_RSP_EQWAKESUPPORT:\r\ncase MCE_RSP_GETWAKESOURCE:\r\ncase MCE_RSP_EQDEVDETAILS:\r\ncase MCE_RSP_EQEMVER:\r\ndatasize = 1;\r\nbreak;\r\n}\r\ncase MCE_CMD_PORT_IR:\r\nswitch (subcmd) {\r\ncase MCE_CMD_UNKNOWN:\r\ncase MCE_RSP_EQIRCFS:\r\ncase MCE_RSP_EQIRTIMEOUT:\r\ncase MCE_RSP_EQIRRXCFCNT:\r\ncase MCE_RSP_EQIRNUMPORTS:\r\ndatasize = 2;\r\nbreak;\r\ncase MCE_CMD_SIG_END:\r\ncase MCE_RSP_EQIRTXPORTS:\r\ncase MCE_RSP_EQIRRXPORTEN:\r\ndatasize = 1;\r\nbreak;\r\n}\r\n}\r\nreturn datasize;\r\n}\r\nstatic void mceusb_dev_printdata(struct mceusb_dev *ir, char *buf,\r\nint offset, int len, bool out)\r\n{\r\n#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)\r\nchar *inout;\r\nu8 cmd, subcmd, data1, data2, data3, data4;\r\nstruct device *dev = ir->dev;\r\nint start, skip = 0;\r\nu32 carrier, period;\r\nif (ir->flags.microsoft_gen1 && !out && !offset)\r\nskip = 2;\r\nif (len <= skip)\r\nreturn;\r\ndev_dbg(dev, "%cx data: %*ph (length=%d)",\r\n(out ? 't' : 'r'), min(len, USB_BUFLEN), buf, len);\r\ninout = out ? "Request" : "Got";\r\nstart = offset + skip;\r\ncmd = buf[start] & 0xff;\r\nsubcmd = buf[start + 1] & 0xff;\r\ndata1 = buf[start + 2] & 0xff;\r\ndata2 = buf[start + 3] & 0xff;\r\ndata3 = buf[start + 4] & 0xff;\r\ndata4 = buf[start + 5] & 0xff;\r\nswitch (cmd) {\r\ncase MCE_CMD_NULL:\r\nif (subcmd == MCE_CMD_NULL)\r\nbreak;\r\nif ((subcmd == MCE_CMD_PORT_SYS) &&\r\n(data1 == MCE_CMD_RESUME))\r\ndev_dbg(dev, "Device resume requested");\r\nelse\r\ndev_dbg(dev, "Unknown command 0x%02x 0x%02x",\r\ncmd, subcmd);\r\nbreak;\r\ncase MCE_CMD_PORT_SYS:\r\nswitch (subcmd) {\r\ncase MCE_RSP_EQEMVER:\r\nif (!out)\r\ndev_dbg(dev, "Emulator interface version %x",\r\ndata1);\r\nbreak;\r\ncase MCE_CMD_G_REVISION:\r\nif (len == 2)\r\ndev_dbg(dev, "Get hw/sw rev?");\r\nelse\r\ndev_dbg(dev, "hw/sw rev %*ph",\r\n4, &buf[start + 2]);\r\nbreak;\r\ncase MCE_CMD_RESUME:\r\ndev_dbg(dev, "Device resume requested");\r\nbreak;\r\ncase MCE_RSP_CMD_ILLEGAL:\r\ndev_dbg(dev, "Illegal PORT_SYS command");\r\nbreak;\r\ncase MCE_RSP_EQWAKEVERSION:\r\nif (!out)\r\ndev_dbg(dev, "Wake version, proto: 0x%02x, "\r\n"payload: 0x%02x, address: 0x%02x, "\r\n"version: 0x%02x",\r\ndata1, data2, data3, data4);\r\nbreak;\r\ncase MCE_RSP_GETPORTSTATUS:\r\nif (!out)\r\ndev_dbg(dev, "TX port %d: blaster is%s connected",\r\ndata1 + 1, data4 ? " not" : "");\r\nbreak;\r\ncase MCE_CMD_FLASHLED:\r\ndev_dbg(dev, "Attempting to flash LED");\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown command 0x%02x 0x%02x",\r\ncmd, subcmd);\r\nbreak;\r\n}\r\nbreak;\r\ncase MCE_CMD_PORT_IR:\r\nswitch (subcmd) {\r\ncase MCE_CMD_SIG_END:\r\ndev_dbg(dev, "End of signal");\r\nbreak;\r\ncase MCE_CMD_PING:\r\ndev_dbg(dev, "Ping");\r\nbreak;\r\ncase MCE_CMD_UNKNOWN:\r\ndev_dbg(dev, "Resp to 9f 05 of 0x%02x 0x%02x",\r\ndata1, data2);\r\nbreak;\r\ncase MCE_RSP_EQIRCFS:\r\nperiod = DIV_ROUND_CLOSEST(\r\n(1U << data1 * 2) * (data2 + 1), 10);\r\nif (!period)\r\nbreak;\r\ncarrier = (1000 * 1000) / period;\r\ndev_dbg(dev, "%s carrier of %u Hz (period %uus)",\r\ninout, carrier, period);\r\nbreak;\r\ncase MCE_CMD_GETIRCFS:\r\ndev_dbg(dev, "Get carrier mode and freq");\r\nbreak;\r\ncase MCE_RSP_EQIRTXPORTS:\r\ndev_dbg(dev, "%s transmit blaster mask of 0x%02x",\r\ninout, data1);\r\nbreak;\r\ncase MCE_RSP_EQIRTIMEOUT:\r\nperiod = ((data1 << 8) | data2) * MCE_TIME_UNIT / 1000;\r\ndev_dbg(dev, "%s receive timeout of %d ms",\r\ninout, period);\r\nbreak;\r\ncase MCE_CMD_GETIRTIMEOUT:\r\ndev_dbg(dev, "Get receive timeout");\r\nbreak;\r\ncase MCE_CMD_GETIRTXPORTS:\r\ndev_dbg(dev, "Get transmit blaster mask");\r\nbreak;\r\ncase MCE_RSP_EQIRRXPORTEN:\r\ndev_dbg(dev, "%s %s-range receive sensor in use",\r\ninout, data1 == 0x02 ? "short" : "long");\r\nbreak;\r\ncase MCE_CMD_GETIRRXPORTEN:\r\nif (out)\r\ndev_dbg(dev, "Get receive sensor");\r\nelse if (ir->learning_enabled)\r\ndev_dbg(dev, "RX pulse count: %d",\r\n((data1 << 8) | data2));\r\nbreak;\r\ncase MCE_RSP_EQIRNUMPORTS:\r\nif (out)\r\nbreak;\r\ndev_dbg(dev, "Num TX ports: %x, num RX ports: %x",\r\ndata1, data2);\r\nbreak;\r\ncase MCE_RSP_CMD_ILLEGAL:\r\ndev_dbg(dev, "Illegal PORT_IR command");\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown command 0x%02x 0x%02x",\r\ncmd, subcmd);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cmd == MCE_IRDATA_TRAILER)\r\ndev_dbg(dev, "End of raw IR data");\r\nelse if ((cmd != MCE_CMD_PORT_IR) &&\r\n((cmd & MCE_PORT_MASK) == MCE_COMMAND_IRDATA))\r\ndev_dbg(dev, "Raw IR data, %d pulse/space samples", ir->rem);\r\n#endif\r\n}\r\nstatic void mce_async_callback(struct urb *urb)\r\n{\r\nstruct mceusb_dev *ir;\r\nint len;\r\nif (!urb)\r\nreturn;\r\nir = urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\nlen = urb->actual_length;\r\nmceusb_dev_printdata(ir, urb->transfer_buffer, 0, len, true);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -EILSEQ:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ncase -EPIPE:\r\ndefault:\r\ndev_err(ir->dev, "Error: request urb status = %d", urb->status);\r\nbreak;\r\n}\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\nstatic void mce_request_packet(struct mceusb_dev *ir, unsigned char *data,\r\nint size, int urb_type)\r\n{\r\nint res, pipe;\r\nstruct urb *async_urb;\r\nstruct device *dev = ir->dev;\r\nunsigned char *async_buf;\r\nif (urb_type == MCEUSB_TX) {\r\nasync_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (unlikely(!async_urb)) {\r\ndev_err(dev, "Error, couldn't allocate urb!\n");\r\nreturn;\r\n}\r\nasync_buf = kzalloc(size, GFP_KERNEL);\r\nif (!async_buf) {\r\ndev_err(dev, "Error, couldn't allocate buf!\n");\r\nusb_free_urb(async_urb);\r\nreturn;\r\n}\r\nif (usb_endpoint_xfer_int(ir->usb_ep_out)) {\r\npipe = usb_sndintpipe(ir->usbdev,\r\nir->usb_ep_out->bEndpointAddress);\r\nusb_fill_int_urb(async_urb, ir->usbdev, pipe, async_buf,\r\nsize, mce_async_callback, ir,\r\nir->usb_ep_out->bInterval);\r\n} else {\r\npipe = usb_sndbulkpipe(ir->usbdev,\r\nir->usb_ep_out->bEndpointAddress);\r\nusb_fill_bulk_urb(async_urb, ir->usbdev, pipe,\r\nasync_buf, size, mce_async_callback,\r\nir);\r\n}\r\nmemcpy(async_buf, data, size);\r\n} else if (urb_type == MCEUSB_RX) {\r\nasync_urb = ir->urb_in;\r\nir->send_flags = RECV_FLAG_IN_PROGRESS;\r\n} else {\r\ndev_err(dev, "Error! Unknown urb type %d\n", urb_type);\r\nreturn;\r\n}\r\ndev_dbg(dev, "receive request called (size=%#x)", size);\r\nasync_urb->transfer_buffer_length = size;\r\nasync_urb->dev = ir->usbdev;\r\nres = usb_submit_urb(async_urb, GFP_ATOMIC);\r\nif (res) {\r\ndev_err(dev, "receive request FAILED! (res=%d)", res);\r\nreturn;\r\n}\r\ndev_dbg(dev, "receive request complete (res=%d)", res);\r\n}\r\nstatic void mce_async_out(struct mceusb_dev *ir, unsigned char *data, int size)\r\n{\r\nint rsize = sizeof(DEVICE_RESUME);\r\nif (ir->need_reset) {\r\nir->need_reset = false;\r\nmce_request_packet(ir, DEVICE_RESUME, rsize, MCEUSB_TX);\r\nmsleep(10);\r\n}\r\nmce_request_packet(ir, data, size, MCEUSB_TX);\r\nmsleep(10);\r\n}\r\nstatic void mce_flush_rx_buffer(struct mceusb_dev *ir, int size)\r\n{\r\nmce_request_packet(ir, NULL, size, MCEUSB_RX);\r\n}\r\nstatic int mceusb_tx_ir(struct rc_dev *dev, unsigned *txbuf, unsigned count)\r\n{\r\nstruct mceusb_dev *ir = dev->priv;\r\nint i, length, ret = 0;\r\nint cmdcount = 0;\r\nunsigned char cmdbuf[MCE_CMDBUF_SIZE];\r\ncmdbuf[cmdcount++] = MCE_CMD_PORT_IR;\r\ncmdbuf[cmdcount++] = MCE_CMD_SETIRTXPORTS;\r\ncmdbuf[cmdcount++] = ir->tx_mask;\r\nmce_async_out(ir, cmdbuf, cmdcount);\r\ncmdcount = 0;\r\nfor (i = 0; (i < count) && (cmdcount < MCE_CMDBUF_SIZE); i++) {\r\ntxbuf[i] = txbuf[i] / MCE_TIME_UNIT;\r\ndo {\r\nif ((cmdcount < MCE_CMDBUF_SIZE) &&\r\n(cmdcount % MCE_CODE_LENGTH) == 0)\r\ncmdbuf[cmdcount++] = MCE_IRDATA_HEADER;\r\nif (cmdcount < MCE_CMDBUF_SIZE)\r\ncmdbuf[cmdcount++] =\r\n(txbuf[i] < MCE_PULSE_BIT ?\r\ntxbuf[i] : MCE_MAX_PULSE_LENGTH) |\r\n(i & 1 ? 0x00 : MCE_PULSE_BIT);\r\nelse {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n} while ((txbuf[i] > MCE_MAX_PULSE_LENGTH) &&\r\n(txbuf[i] -= MCE_MAX_PULSE_LENGTH));\r\n}\r\nif (cmdcount >= MCE_CMDBUF_SIZE) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlength = cmdcount % MCE_CODE_LENGTH;\r\ncmdbuf[cmdcount - length] -= MCE_CODE_LENGTH - length;\r\ncmdbuf[cmdcount++] = MCE_IRDATA_TRAILER;\r\nmce_async_out(ir, cmdbuf, cmdcount);\r\nout:\r\nreturn ret ? ret : count;\r\n}\r\nstatic int mceusb_set_tx_mask(struct rc_dev *dev, u32 mask)\r\n{\r\nstruct mceusb_dev *ir = dev->priv;\r\nint emitters = ir->num_txports ? ir->num_txports : 2;\r\nif (mask >= (1 << emitters))\r\nreturn emitters;\r\nif (ir->flags.tx_mask_normal)\r\nir->tx_mask = mask;\r\nelse\r\nir->tx_mask = (mask != MCE_DEFAULT_TX_MASK ?\r\nmask ^ MCE_DEFAULT_TX_MASK : mask) << 1;\r\nreturn 0;\r\n}\r\nstatic int mceusb_set_tx_carrier(struct rc_dev *dev, u32 carrier)\r\n{\r\nstruct mceusb_dev *ir = dev->priv;\r\nint clk = 10000000;\r\nint prescaler = 0, divisor = 0;\r\nunsigned char cmdbuf[4] = { MCE_CMD_PORT_IR,\r\nMCE_CMD_SETIRCFS, 0x00, 0x00 };\r\nif (ir->carrier != carrier) {\r\nif (carrier == 0) {\r\nir->carrier = carrier;\r\ncmdbuf[2] = MCE_CMD_SIG_END;\r\ncmdbuf[3] = MCE_IRDATA_TRAILER;\r\ndev_dbg(ir->dev, "disabling carrier modulation");\r\nmce_async_out(ir, cmdbuf, sizeof(cmdbuf));\r\nreturn carrier;\r\n}\r\nfor (prescaler = 0; prescaler < 4; ++prescaler) {\r\ndivisor = (clk >> (2 * prescaler)) / carrier;\r\nif (divisor <= 0xff) {\r\nir->carrier = carrier;\r\ncmdbuf[2] = prescaler;\r\ncmdbuf[3] = divisor;\r\ndev_dbg(ir->dev, "requesting %u HZ carrier",\r\ncarrier);\r\nmce_async_out(ir, cmdbuf, sizeof(cmdbuf));\r\nreturn carrier;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mceusb_handle_command(struct mceusb_dev *ir, int index)\r\n{\r\nu8 hi = ir->buf_in[index + 1] & 0xff;\r\nu8 lo = ir->buf_in[index + 2] & 0xff;\r\nswitch (ir->buf_in[index]) {\r\ncase MCE_RSP_GETPORTSTATUS:\r\nif ((ir->buf_in[index + 4] & 0xff) == 0x00)\r\nir->txports_cabled |= 1 << hi;\r\nbreak;\r\ncase MCE_RSP_EQIRTIMEOUT:\r\nir->rc->timeout = US_TO_NS((hi << 8 | lo) * MCE_TIME_UNIT);\r\nbreak;\r\ncase MCE_RSP_EQIRNUMPORTS:\r\nir->num_txports = hi;\r\nir->num_rxports = lo;\r\nbreak;\r\ncase MCE_RSP_EQEMVER:\r\nir->emver = hi;\r\nbreak;\r\ncase MCE_RSP_EQIRTXPORTS:\r\nir->tx_mask = hi;\r\nbreak;\r\ncase MCE_RSP_EQIRRXPORTEN:\r\nir->learning_enabled = ((hi & 0x02) == 0x02);\r\nir->rxports_active = hi;\r\nbreak;\r\ncase MCE_RSP_CMD_ILLEGAL:\r\nir->need_reset = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void mceusb_process_ir_data(struct mceusb_dev *ir, int buf_len)\r\n{\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nbool event = false;\r\nint i = 0;\r\nif (ir->flags.microsoft_gen1)\r\ni = 2;\r\nif (buf_len <= i)\r\nreturn;\r\nfor (; i < buf_len; i++) {\r\nswitch (ir->parser_state) {\r\ncase SUBCMD:\r\nir->rem = mceusb_cmd_datasize(ir->cmd, ir->buf_in[i]);\r\nmceusb_dev_printdata(ir, ir->buf_in, i - 1,\r\nir->rem + 2, false);\r\nmceusb_handle_command(ir, i);\r\nir->parser_state = CMD_DATA;\r\nbreak;\r\ncase PARSE_IRDATA:\r\nir->rem--;\r\ninit_ir_raw_event(&rawir);\r\nrawir.pulse = ((ir->buf_in[i] & MCE_PULSE_BIT) != 0);\r\nrawir.duration = (ir->buf_in[i] & MCE_PULSE_MASK)\r\n* US_TO_NS(MCE_TIME_UNIT);\r\ndev_dbg(ir->dev, "Storing %s with duration %d",\r\nrawir.pulse ? "pulse" : "space",\r\nrawir.duration);\r\nif (ir_raw_event_store_with_filter(ir->rc, &rawir))\r\nevent = true;\r\nbreak;\r\ncase CMD_DATA:\r\nir->rem--;\r\nbreak;\r\ncase CMD_HEADER:\r\nir->cmd = ir->buf_in[i];\r\nif ((ir->cmd == MCE_CMD_PORT_IR) ||\r\n((ir->cmd & MCE_PORT_MASK) !=\r\nMCE_COMMAND_IRDATA)) {\r\nir->parser_state = SUBCMD;\r\ncontinue;\r\n}\r\nir->rem = (ir->cmd & MCE_PACKET_LENGTH_MASK);\r\nmceusb_dev_printdata(ir, ir->buf_in,\r\ni, ir->rem + 1, false);\r\nif (ir->rem)\r\nir->parser_state = PARSE_IRDATA;\r\nelse\r\nir_raw_event_reset(ir->rc);\r\nbreak;\r\n}\r\nif (ir->parser_state != CMD_HEADER && !ir->rem)\r\nir->parser_state = CMD_HEADER;\r\n}\r\nif (event) {\r\ndev_dbg(ir->dev, "processed IR data");\r\nir_raw_event_handle(ir->rc);\r\n}\r\n}\r\nstatic void mceusb_dev_recv(struct urb *urb)\r\n{\r\nstruct mceusb_dev *ir;\r\nint buf_len;\r\nif (!urb)\r\nreturn;\r\nir = urb->context;\r\nif (!ir) {\r\nusb_unlink_urb(urb);\r\nreturn;\r\n}\r\nbuf_len = urb->actual_length;\r\nif (ir->send_flags == RECV_FLAG_IN_PROGRESS) {\r\nir->send_flags = SEND_FLAG_COMPLETE;\r\ndev_dbg(ir->dev, "setup answer received %d bytes\n",\r\nbuf_len);\r\n}\r\nswitch (urb->status) {\r\ncase 0:\r\nmceusb_process_ir_data(ir, buf_len);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -EILSEQ:\r\ncase -ESHUTDOWN:\r\nusb_unlink_urb(urb);\r\nreturn;\r\ncase -EPIPE:\r\ndefault:\r\ndev_err(ir->dev, "Error: urb status = %d", urb->status);\r\nbreak;\r\n}\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic void mceusb_get_emulator_version(struct mceusb_dev *ir)\r\n{\r\nir->emver = 1;\r\nmce_async_out(ir, GET_EMVER, sizeof(GET_EMVER));\r\n}\r\nstatic void mceusb_gen1_init(struct mceusb_dev *ir)\r\n{\r\nint ret;\r\nstruct device *dev = ir->dev;\r\nchar *data;\r\ndata = kzalloc(USB_CTRL_MSG_SZ, GFP_KERNEL);\r\nif (!data) {\r\ndev_err(dev, "%s: memory allocation failed!", __func__);\r\nreturn;\r\n}\r\nret = usb_control_msg(ir->usbdev, usb_rcvctrlpipe(ir->usbdev, 0),\r\nUSB_REQ_SET_ADDRESS, USB_TYPE_VENDOR, 0, 0,\r\ndata, USB_CTRL_MSG_SZ, HZ * 3);\r\ndev_dbg(dev, "set address - ret = %d", ret);\r\ndev_dbg(dev, "set address - data[0] = %d, data[1] = %d",\r\ndata[0], data[1]);\r\nret = usb_control_msg(ir->usbdev, usb_sndctrlpipe(ir->usbdev, 0),\r\nUSB_REQ_SET_FEATURE, USB_TYPE_VENDOR,\r\n0xc04e, 0x0000, NULL, 0, HZ * 3);\r\ndev_dbg(dev, "set feature - ret = %d", ret);\r\nret = usb_control_msg(ir->usbdev, usb_sndctrlpipe(ir->usbdev, 0),\r\n4, USB_TYPE_VENDOR,\r\n0x0808, 0x0000, NULL, 0, HZ * 3);\r\ndev_dbg(dev, "set char length - retB = %d", ret);\r\nret = usb_control_msg(ir->usbdev, usb_sndctrlpipe(ir->usbdev, 0),\r\n2, USB_TYPE_VENDOR,\r\n0x0000, 0x0100, NULL, 0, HZ * 3);\r\ndev_dbg(dev, "set handshake - retC = %d", ret);\r\nmce_async_out(ir, DEVICE_RESUME, sizeof(DEVICE_RESUME));\r\nmce_async_out(ir, GET_REVISION, sizeof(GET_REVISION));\r\nkfree(data);\r\n}\r\nstatic void mceusb_gen2_init(struct mceusb_dev *ir)\r\n{\r\nmce_async_out(ir, DEVICE_RESUME, sizeof(DEVICE_RESUME));\r\nmce_async_out(ir, GET_WAKEVERSION, sizeof(GET_WAKEVERSION));\r\nmce_async_out(ir, GET_UNKNOWN2, sizeof(GET_UNKNOWN2));\r\n}\r\nstatic void mceusb_get_parameters(struct mceusb_dev *ir)\r\n{\r\nint i;\r\nunsigned char cmdbuf[3] = { MCE_CMD_PORT_SYS,\r\nMCE_CMD_GETPORTSTATUS, 0x00 };\r\nir->num_txports = 2;\r\nir->num_rxports = 2;\r\nmce_async_out(ir, GET_NUM_PORTS, sizeof(GET_NUM_PORTS));\r\nmce_async_out(ir, GET_CARRIER_FREQ, sizeof(GET_CARRIER_FREQ));\r\nif (ir->num_txports && !ir->flags.no_tx)\r\nmce_async_out(ir, GET_TX_BITMASK, sizeof(GET_TX_BITMASK));\r\nmce_async_out(ir, GET_RX_TIMEOUT, sizeof(GET_RX_TIMEOUT));\r\nmce_async_out(ir, GET_RX_SENSOR, sizeof(GET_RX_SENSOR));\r\nfor (i = 0; i < ir->num_txports; i++) {\r\ncmdbuf[2] = i;\r\nmce_async_out(ir, cmdbuf, sizeof(cmdbuf));\r\n}\r\n}\r\nstatic void mceusb_flash_led(struct mceusb_dev *ir)\r\n{\r\nif (ir->emver < 2)\r\nreturn;\r\nmce_async_out(ir, FLASH_LED, sizeof(FLASH_LED));\r\n}\r\nstatic struct rc_dev *mceusb_init_rc_dev(struct mceusb_dev *ir)\r\n{\r\nstruct usb_device *udev = ir->usbdev;\r\nstruct device *dev = ir->dev;\r\nstruct rc_dev *rc;\r\nint ret;\r\nrc = rc_allocate_device();\r\nif (!rc) {\r\ndev_err(dev, "remote dev allocation failed");\r\ngoto out;\r\n}\r\nsnprintf(ir->name, sizeof(ir->name), "%s (%04x:%04x)",\r\nmceusb_model[ir->model].name ?\r\nmceusb_model[ir->model].name :\r\n"Media Center Ed. eHome Infrared Remote Transceiver",\r\nle16_to_cpu(ir->usbdev->descriptor.idVendor),\r\nle16_to_cpu(ir->usbdev->descriptor.idProduct));\r\nusb_make_path(ir->usbdev, ir->phys, sizeof(ir->phys));\r\nrc->input_name = ir->name;\r\nrc->input_phys = ir->phys;\r\nusb_to_input_id(ir->usbdev, &rc->input_id);\r\nrc->dev.parent = dev;\r\nrc->priv = ir;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->allowed_protocols = RC_BIT_ALL;\r\nrc->timeout = MS_TO_NS(100);\r\nif (!ir->flags.no_tx) {\r\nrc->s_tx_mask = mceusb_set_tx_mask;\r\nrc->s_tx_carrier = mceusb_set_tx_carrier;\r\nrc->tx_ir = mceusb_tx_ir;\r\n}\r\nrc->driver_name = DRIVER_NAME;\r\nswitch (le16_to_cpu(udev->descriptor.idVendor)) {\r\ncase VENDOR_HAUPPAUGE:\r\nrc->map_name = RC_MAP_HAUPPAUGE;\r\nbreak;\r\ncase VENDOR_PCTV:\r\nrc->map_name = RC_MAP_PINNACLE_PCTV_HD;\r\nbreak;\r\ndefault:\r\nrc->map_name = RC_MAP_RC6_MCE;\r\n}\r\nif (mceusb_model[ir->model].rc_map)\r\nrc->map_name = mceusb_model[ir->model].rc_map;\r\nret = rc_register_device(rc);\r\nif (ret < 0) {\r\ndev_err(dev, "remote dev registration failed");\r\ngoto out;\r\n}\r\nreturn rc;\r\nout:\r\nrc_free_device(rc);\r\nreturn NULL;\r\n}\r\nstatic int mceusb_dev_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *idesc;\r\nstruct usb_endpoint_descriptor *ep = NULL;\r\nstruct usb_endpoint_descriptor *ep_in = NULL;\r\nstruct usb_endpoint_descriptor *ep_out = NULL;\r\nstruct mceusb_dev *ir = NULL;\r\nint pipe, maxp, i;\r\nchar buf[63], name[128] = "";\r\nenum mceusb_model_type model = id->driver_info;\r\nbool is_gen3;\r\nbool is_microsoft_gen1;\r\nbool tx_mask_normal;\r\nint ir_intfnum;\r\ndev_dbg(&intf->dev, "%s called", __func__);\r\nidesc = intf->cur_altsetting;\r\nis_gen3 = mceusb_model[model].mce_gen3;\r\nis_microsoft_gen1 = mceusb_model[model].mce_gen1;\r\ntx_mask_normal = mceusb_model[model].tx_mask_normal;\r\nir_intfnum = mceusb_model[model].ir_intfnum;\r\nif (idesc->desc.bInterfaceNumber != ir_intfnum)\r\nreturn -ENODEV;\r\nfor (i = 0; i < idesc->desc.bNumEndpoints; ++i) {\r\nep = &idesc->endpoint[i].desc;\r\nif (ep_in == NULL) {\r\nif (usb_endpoint_is_bulk_in(ep)) {\r\nep_in = ep;\r\ndev_dbg(&intf->dev, "acceptable bulk inbound endpoint found\n");\r\n} else if (usb_endpoint_is_int_in(ep)) {\r\nep_in = ep;\r\nep_in->bInterval = 1;\r\ndev_dbg(&intf->dev, "acceptable interrupt inbound endpoint found\n");\r\n}\r\n}\r\nif (ep_out == NULL) {\r\nif (usb_endpoint_is_bulk_out(ep)) {\r\nep_out = ep;\r\ndev_dbg(&intf->dev, "acceptable bulk outbound endpoint found\n");\r\n} else if (usb_endpoint_is_int_out(ep)) {\r\nep_out = ep;\r\nep_out->bInterval = 1;\r\ndev_dbg(&intf->dev, "acceptable interrupt outbound endpoint found\n");\r\n}\r\n}\r\n}\r\nif (ep_in == NULL) {\r\ndev_dbg(&intf->dev, "inbound and/or endpoint not found");\r\nreturn -ENODEV;\r\n}\r\nif (usb_endpoint_xfer_int(ep_in))\r\npipe = usb_rcvintpipe(dev, ep_in->bEndpointAddress);\r\nelse\r\npipe = usb_rcvbulkpipe(dev, ep_in->bEndpointAddress);\r\nmaxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));\r\nir = kzalloc(sizeof(struct mceusb_dev), GFP_KERNEL);\r\nif (!ir)\r\ngoto mem_alloc_fail;\r\nir->buf_in = usb_alloc_coherent(dev, maxp, GFP_ATOMIC, &ir->dma_in);\r\nif (!ir->buf_in)\r\ngoto buf_in_alloc_fail;\r\nir->urb_in = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ir->urb_in)\r\ngoto urb_in_alloc_fail;\r\nir->usbdev = usb_get_dev(dev);\r\nir->dev = &intf->dev;\r\nir->len_in = maxp;\r\nir->flags.microsoft_gen1 = is_microsoft_gen1;\r\nir->flags.tx_mask_normal = tx_mask_normal;\r\nir->flags.no_tx = mceusb_model[model].no_tx;\r\nir->model = model;\r\nir->usb_ep_out = ep_out;\r\nif (dev->descriptor.iManufacturer\r\n&& usb_string(dev, dev->descriptor.iManufacturer,\r\nbuf, sizeof(buf)) > 0)\r\nstrlcpy(name, buf, sizeof(name));\r\nif (dev->descriptor.iProduct\r\n&& usb_string(dev, dev->descriptor.iProduct,\r\nbuf, sizeof(buf)) > 0)\r\nsnprintf(name + strlen(name), sizeof(name) - strlen(name),\r\n" %s", buf);\r\nir->rc = mceusb_init_rc_dev(ir);\r\nif (!ir->rc)\r\ngoto rc_dev_fail;\r\nusb_fill_int_urb(ir->urb_in, dev, pipe, ir->buf_in, maxp,\r\nmceusb_dev_recv, ir, ep_in->bInterval);\r\nir->urb_in->transfer_dma = ir->dma_in;\r\nir->urb_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\ndev_dbg(&intf->dev, "Flushing receive buffers\n");\r\nmce_flush_rx_buffer(ir, maxp);\r\nmceusb_get_emulator_version(ir);\r\nif (ir->flags.microsoft_gen1)\r\nmceusb_gen1_init(ir);\r\nelse if (!is_gen3)\r\nmceusb_gen2_init(ir);\r\nmceusb_get_parameters(ir);\r\nmceusb_flash_led(ir);\r\nif (!ir->flags.no_tx)\r\nmceusb_set_tx_mask(ir->rc, MCE_DEFAULT_TX_MASK);\r\nusb_set_intfdata(intf, ir);\r\ndevice_set_wakeup_capable(ir->dev, true);\r\ndevice_set_wakeup_enable(ir->dev, true);\r\ndev_info(&intf->dev, "Registered %s with mce emulator interface version %x",\r\nname, ir->emver);\r\ndev_info(&intf->dev, "%x tx ports (0x%x cabled) and %x rx sensors (0x%x active)",\r\nir->num_txports, ir->txports_cabled,\r\nir->num_rxports, ir->rxports_active);\r\nreturn 0;\r\nrc_dev_fail:\r\nusb_put_dev(ir->usbdev);\r\nusb_free_urb(ir->urb_in);\r\nurb_in_alloc_fail:\r\nusb_free_coherent(dev, maxp, ir->buf_in, ir->dma_in);\r\nbuf_in_alloc_fail:\r\nkfree(ir);\r\nmem_alloc_fail:\r\ndev_err(&intf->dev, "%s: device setup failed!", __func__);\r\nreturn -ENOMEM;\r\n}\r\nstatic void mceusb_dev_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct mceusb_dev *ir = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (!ir)\r\nreturn;\r\nir->usbdev = NULL;\r\nrc_unregister_device(ir->rc);\r\nusb_kill_urb(ir->urb_in);\r\nusb_free_urb(ir->urb_in);\r\nusb_free_coherent(dev, ir->len_in, ir->buf_in, ir->dma_in);\r\nusb_put_dev(dev);\r\nkfree(ir);\r\n}\r\nstatic int mceusb_dev_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct mceusb_dev *ir = usb_get_intfdata(intf);\r\ndev_info(ir->dev, "suspend");\r\nusb_kill_urb(ir->urb_in);\r\nreturn 0;\r\n}\r\nstatic int mceusb_dev_resume(struct usb_interface *intf)\r\n{\r\nstruct mceusb_dev *ir = usb_get_intfdata(intf);\r\ndev_info(ir->dev, "resume");\r\nif (usb_submit_urb(ir->urb_in, GFP_ATOMIC))\r\nreturn -EIO;\r\nreturn 0;\r\n}
