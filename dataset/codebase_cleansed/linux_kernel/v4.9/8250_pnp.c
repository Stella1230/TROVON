static bool check_name(const char *name)\r\n{\r\nconst char **tmp;\r\nfor (tmp = modem_names; *tmp; tmp++)\r\nif (strstr(name, *tmp))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool check_resources(struct pnp_dev *dev)\r\n{\r\nstatic const resource_size_t base[] = {0x2f8, 0x3f8, 0x2e8, 0x3e8};\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(base); i++) {\r\nif (pnp_possible_config(dev, IORESOURCE_IO, base[i], 8))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int serial_pnp_guess_board(struct pnp_dev *dev)\r\n{\r\nif (!(check_name(pnp_dev_name(dev)) ||\r\n(dev->card && check_name(dev->card->name))))\r\nreturn -ENODEV;\r\nif (check_resources(dev))\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nserial_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *dev_id)\r\n{\r\nstruct uart_8250_port uart, *port;\r\nint ret, line, flags = dev_id->driver_data;\r\nif (flags & UNKNOWN_DEV) {\r\nret = serial_pnp_guess_board(dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmemset(&uart, 0, sizeof(uart));\r\nif (pnp_irq_valid(dev, 0))\r\nuart.port.irq = pnp_irq(dev, 0);\r\nif ((flags & CIR_PORT) && pnp_port_valid(dev, 2)) {\r\nuart.port.iobase = pnp_port_start(dev, 2);\r\nuart.port.iotype = UPIO_PORT;\r\n} else if (pnp_port_valid(dev, 0)) {\r\nuart.port.iobase = pnp_port_start(dev, 0);\r\nuart.port.iotype = UPIO_PORT;\r\n} else if (pnp_mem_valid(dev, 0)) {\r\nuart.port.mapbase = pnp_mem_start(dev, 0);\r\nuart.port.iotype = UPIO_MEM;\r\nuart.port.flags = UPF_IOREMAP;\r\n} else\r\nreturn -ENODEV;\r\ndev_dbg(&dev->dev,\r\n"Setup PNP port: port %lx, mem %pa, irq %d, type %d\n",\r\nuart.port.iobase, &uart.port.mapbase,\r\nuart.port.irq, uart.port.iotype);\r\nif (flags & CIR_PORT) {\r\nuart.port.flags |= UPF_FIXED_PORT | UPF_FIXED_TYPE;\r\nuart.port.type = PORT_8250_CIR;\r\n}\r\nuart.port.flags |= UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;\r\nif (pnp_irq_flags(dev, 0) & IORESOURCE_IRQ_SHAREABLE)\r\nuart.port.flags |= UPF_SHARE_IRQ;\r\nuart.port.uartclk = 1843200;\r\nuart.port.dev = &dev->dev;\r\nline = serial8250_register_8250_port(&uart);\r\nif (line < 0 || (flags & CIR_PORT))\r\nreturn -ENODEV;\r\nport = serial8250_get_port(line);\r\nif (uart_console(&port->port))\r\ndev->capabilities |= PNP_CONSOLE;\r\npnp_set_drvdata(dev, (void *)((long)line + 1));\r\nreturn 0;\r\n}\r\nstatic void serial_pnp_remove(struct pnp_dev *dev)\r\n{\r\nlong line = (long)pnp_get_drvdata(dev);\r\ndev->capabilities &= ~PNP_CONSOLE;\r\nif (line)\r\nserial8250_unregister_port(line - 1);\r\n}\r\nstatic int serial_pnp_suspend(struct pnp_dev *dev, pm_message_t state)\r\n{\r\nlong line = (long)pnp_get_drvdata(dev);\r\nif (!line)\r\nreturn -ENODEV;\r\nserial8250_suspend_port(line - 1);\r\nreturn 0;\r\n}\r\nstatic int serial_pnp_resume(struct pnp_dev *dev)\r\n{\r\nlong line = (long)pnp_get_drvdata(dev);\r\nif (!line)\r\nreturn -ENODEV;\r\nserial8250_resume_port(line - 1);\r\nreturn 0;\r\n}\r\nint serial8250_pnp_init(void)\r\n{\r\nreturn pnp_register_driver(&serial_pnp_driver);\r\n}\r\nvoid serial8250_pnp_exit(void)\r\n{\r\npnp_unregister_driver(&serial_pnp_driver);\r\n}
