static\r\nstruct idletimer_tg *__idletimer_tg_find_by_label(const char *label)\r\n{\r\nstruct idletimer_tg *entry;\r\nBUG_ON(!label);\r\nlist_for_each_entry(entry, &idletimer_tg_list, entry) {\r\nif (!strcmp(label, entry->attr.attr.name))\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic ssize_t idletimer_tg_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct idletimer_tg *timer;\r\nunsigned long expires = 0;\r\nmutex_lock(&list_mutex);\r\ntimer = __idletimer_tg_find_by_label(attr->name);\r\nif (timer)\r\nexpires = timer->timer.expires;\r\nmutex_unlock(&list_mutex);\r\nif (time_after(expires, jiffies))\r\nreturn sprintf(buf, "%u\n",\r\njiffies_to_msecs(expires - jiffies) / 1000);\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic void idletimer_tg_work(struct work_struct *work)\r\n{\r\nstruct idletimer_tg *timer = container_of(work, struct idletimer_tg,\r\nwork);\r\nsysfs_notify(idletimer_tg_kobj, NULL, timer->attr.attr.name);\r\n}\r\nstatic void idletimer_tg_expired(unsigned long data)\r\n{\r\nstruct idletimer_tg *timer = (struct idletimer_tg *) data;\r\npr_debug("timer %s expired\n", timer->attr.attr.name);\r\nschedule_work(&timer->work);\r\n}\r\nstatic int idletimer_tg_create(struct idletimer_tg_info *info)\r\n{\r\nint ret;\r\ninfo->timer = kmalloc(sizeof(*info->timer), GFP_KERNEL);\r\nif (!info->timer) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsysfs_attr_init(&info->timer->attr.attr);\r\ninfo->timer->attr.attr.name = kstrdup(info->label, GFP_KERNEL);\r\nif (!info->timer->attr.attr.name) {\r\nret = -ENOMEM;\r\ngoto out_free_timer;\r\n}\r\ninfo->timer->attr.attr.mode = S_IRUGO;\r\ninfo->timer->attr.show = idletimer_tg_show;\r\nret = sysfs_create_file(idletimer_tg_kobj, &info->timer->attr.attr);\r\nif (ret < 0) {\r\npr_debug("couldn't add file to sysfs");\r\ngoto out_free_attr;\r\n}\r\nlist_add(&info->timer->entry, &idletimer_tg_list);\r\nsetup_timer(&info->timer->timer, idletimer_tg_expired,\r\n(unsigned long) info->timer);\r\ninfo->timer->refcnt = 1;\r\nmod_timer(&info->timer->timer,\r\nmsecs_to_jiffies(info->timeout * 1000) + jiffies);\r\nINIT_WORK(&info->timer->work, idletimer_tg_work);\r\nreturn 0;\r\nout_free_attr:\r\nkfree(info->timer->attr.attr.name);\r\nout_free_timer:\r\nkfree(info->timer);\r\nout:\r\nreturn ret;\r\n}\r\nstatic unsigned int idletimer_tg_target(struct sk_buff *skb,\r\nconst struct xt_action_param *par)\r\n{\r\nconst struct idletimer_tg_info *info = par->targinfo;\r\npr_debug("resetting timer %s, timeout period %u\n",\r\ninfo->label, info->timeout);\r\nBUG_ON(!info->timer);\r\nmod_timer(&info->timer->timer,\r\nmsecs_to_jiffies(info->timeout * 1000) + jiffies);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int idletimer_tg_checkentry(const struct xt_tgchk_param *par)\r\n{\r\nstruct idletimer_tg_info *info = par->targinfo;\r\nint ret;\r\npr_debug("checkentry targinfo%s\n", info->label);\r\nif (info->timeout == 0) {\r\npr_debug("timeout value is zero\n");\r\nreturn -EINVAL;\r\n}\r\nif (info->label[0] == '\0' ||\r\nstrnlen(info->label,\r\nMAX_IDLETIMER_LABEL_SIZE) == MAX_IDLETIMER_LABEL_SIZE) {\r\npr_debug("label is empty or not nul-terminated\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&list_mutex);\r\ninfo->timer = __idletimer_tg_find_by_label(info->label);\r\nif (info->timer) {\r\ninfo->timer->refcnt++;\r\nmod_timer(&info->timer->timer,\r\nmsecs_to_jiffies(info->timeout * 1000) + jiffies);\r\npr_debug("increased refcnt of timer %s to %u\n",\r\ninfo->label, info->timer->refcnt);\r\n} else {\r\nret = idletimer_tg_create(info);\r\nif (ret < 0) {\r\npr_debug("failed to create timer\n");\r\nmutex_unlock(&list_mutex);\r\nreturn ret;\r\n}\r\n}\r\nmutex_unlock(&list_mutex);\r\nreturn 0;\r\n}\r\nstatic void idletimer_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nconst struct idletimer_tg_info *info = par->targinfo;\r\npr_debug("destroy targinfo %s\n", info->label);\r\nmutex_lock(&list_mutex);\r\nif (--info->timer->refcnt == 0) {\r\npr_debug("deleting timer %s\n", info->label);\r\nlist_del(&info->timer->entry);\r\ndel_timer_sync(&info->timer->timer);\r\ncancel_work_sync(&info->timer->work);\r\nsysfs_remove_file(idletimer_tg_kobj, &info->timer->attr.attr);\r\nkfree(info->timer->attr.attr.name);\r\nkfree(info->timer);\r\n} else {\r\npr_debug("decreased refcnt of timer %s to %u\n",\r\ninfo->label, info->timer->refcnt);\r\n}\r\nmutex_unlock(&list_mutex);\r\n}\r\nstatic int __init idletimer_tg_init(void)\r\n{\r\nint err;\r\nidletimer_tg_class = class_create(THIS_MODULE, "xt_idletimer");\r\nerr = PTR_ERR(idletimer_tg_class);\r\nif (IS_ERR(idletimer_tg_class)) {\r\npr_debug("couldn't register device class\n");\r\ngoto out;\r\n}\r\nidletimer_tg_device = device_create(idletimer_tg_class, NULL,\r\nMKDEV(0, 0), NULL, "timers");\r\nerr = PTR_ERR(idletimer_tg_device);\r\nif (IS_ERR(idletimer_tg_device)) {\r\npr_debug("couldn't register system device\n");\r\ngoto out_class;\r\n}\r\nidletimer_tg_kobj = &idletimer_tg_device->kobj;\r\nerr = xt_register_target(&idletimer_tg);\r\nif (err < 0) {\r\npr_debug("couldn't register xt target\n");\r\ngoto out_dev;\r\n}\r\nreturn 0;\r\nout_dev:\r\ndevice_destroy(idletimer_tg_class, MKDEV(0, 0));\r\nout_class:\r\nclass_destroy(idletimer_tg_class);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit idletimer_tg_exit(void)\r\n{\r\nxt_unregister_target(&idletimer_tg);\r\ndevice_destroy(idletimer_tg_class, MKDEV(0, 0));\r\nclass_destroy(idletimer_tg_class);\r\n}
