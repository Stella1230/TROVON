static inline bool synth_readable(void)\r\n{\r\nsynth_status = inb_p(speakup_info.port_tts + UART_RX);\r\nreturn (synth_status & TTS_READABLE) != 0;\r\n}\r\nstatic inline bool synth_writable(void)\r\n{\r\nsynth_status = inb_p(speakup_info.port_tts + UART_RX);\r\nreturn (synth_status & TTS_WRITABLE) != 0;\r\n}\r\nstatic inline bool synth_full(void)\r\n{\r\nsynth_status = inb_p(speakup_info.port_tts + UART_RX);\r\nreturn (synth_status & TTS_ALMOST_FULL) != 0;\r\n}\r\nstatic void spk_out(const char ch)\r\n{\r\nint timeout = SPK_XMITR_TIMEOUT;\r\nwhile (!synth_writable()) {\r\nif (!--timeout)\r\nbreak;\r\nudelay(1);\r\n}\r\noutb_p(ch, speakup_info.port_tts);\r\ntimeout = SPK_XMITR_TIMEOUT;\r\nwhile (synth_writable()) {\r\nif (!--timeout)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nstatic void do_catch_up(struct spk_synth *synth)\r\n{\r\nu_char ch;\r\nunsigned long flags;\r\nunsigned long jiff_max;\r\nstruct var_t *jiffy_delta;\r\nstruct var_t *delay_time;\r\nint jiffy_delta_val;\r\nint delay_time_val;\r\njiffy_delta = spk_get_var(JIFFY);\r\ndelay_time = spk_get_var(DELAY);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\njiff_max = jiffies + jiffy_delta_val;\r\nwhile (!kthread_should_stop()) {\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nif (speakup_info.flushing) {\r\nspeakup_info.flushing = 0;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nsynth->flush(synth);\r\ncontinue;\r\n}\r\nif (synth_buffer_empty()) {\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nbreak;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\ndelay_time_val = delay_time->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (synth_full()) {\r\nschedule_timeout(msecs_to_jiffies(delay_time_val));\r\ncontinue;\r\n}\r\nset_current_state(TASK_RUNNING);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nch = synth_buffer_getc();\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (ch == '\n')\r\nch = PROCSPEECH;\r\nspk_out(ch);\r\nif (time_after_eq(jiffies, jiff_max) && (ch == SPACE)) {\r\nspk_out(PROCSPEECH);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\ndelay_time_val = delay_time->u.n.value;\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nschedule_timeout(msecs_to_jiffies(delay_time_val));\r\njiff_max = jiffies + jiffy_delta_val;\r\n}\r\n}\r\nspk_out(PROCSPEECH);\r\n}\r\nstatic const char *synth_immediate(struct spk_synth *synth, const char *buf)\r\n{\r\nu_char ch;\r\nwhile ((ch = (u_char)*buf)) {\r\nif (synth_full())\r\nreturn buf;\r\nif (ch == '\n')\r\nch = PROCSPEECH;\r\nspk_out(ch);\r\nbuf++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void synth_flush(struct spk_synth *synth)\r\n{\r\noutb_p(SYNTH_CLEAR, speakup_info.port_tts);\r\nwhile (synth_writable())\r\ncpu_relax();\r\n}\r\nstatic char synth_read_tts(void)\r\n{\r\nu_char ch;\r\nwhile (!synth_readable())\r\ncpu_relax();\r\nch = synth_status & 0x7f;\r\noutb_p(ch, speakup_info.port_tts);\r\nwhile (synth_readable())\r\ncpu_relax();\r\nreturn (char) ch;\r\n}\r\nstatic struct synth_settings *synth_interrogate(struct spk_synth *synth)\r\n{\r\nu_char *t;\r\nstatic char buf[sizeof(struct synth_settings) + 1];\r\nint total, i;\r\nstatic struct synth_settings status;\r\nsynth_immediate(synth, "\x18\x01?");\r\nfor (total = 0, i = 0; i < 50; i++) {\r\nbuf[total] = synth_read_tts();\r\nif (total > 2 && buf[total] == 0x7f)\r\nbreak;\r\nif (total < sizeof(struct synth_settings))\r\ntotal++;\r\n}\r\nt = buf;\r\nstatus.serial_number = t[0] + t[1]*256;\r\nt += 2;\r\nfor (i = 0; *t != '\r'; t++) {\r\nstatus.rom_version[i] = *t;\r\nif (i < sizeof(status.rom_version)-1)\r\ni++;\r\n}\r\nstatus.rom_version[i] = 0;\r\nt++;\r\nstatus.mode = *t++;\r\nstatus.punc_level = *t++;\r\nstatus.formant_freq = *t++;\r\nstatus.pitch = *t++;\r\nstatus.speed = *t++;\r\nstatus.volume = *t++;\r\nstatus.tone = *t++;\r\nstatus.expression = *t++;\r\nstatus.ext_dict_loaded = *t++;\r\nstatus.ext_dict_status = *t++;\r\nstatus.free_ram = *t++;\r\nstatus.articulation = *t++;\r\nstatus.reverb = *t++;\r\nstatus.eob = *t++;\r\nreturn &status;\r\n}\r\nstatic int synth_probe(struct spk_synth *synth)\r\n{\r\nunsigned int port_val = 0;\r\nint i = 0;\r\nstruct synth_settings *sp;\r\npr_info("Probing for DoubleTalk.\n");\r\nif (port_forced) {\r\nspeakup_info.port_tts = port_forced;\r\npr_info("probe forced to %x by kernel command line\n",\r\nspeakup_info.port_tts);\r\nif ((port_forced & 0xf) != 0xf)\r\npr_info("warning: port base should probably end with f\n");\r\nif (synth_request_region(speakup_info.port_tts-1,\r\nSYNTH_IO_EXTENT)) {\r\npr_warn("sorry, port already reserved\n");\r\nreturn -EBUSY;\r\n}\r\nport_val = inw(speakup_info.port_tts-1);\r\nsynth_lpc = speakup_info.port_tts-1;\r\n} else {\r\nfor (i = 0; synth_portlist[i]; i++) {\r\nif (synth_request_region(synth_portlist[i],\r\nSYNTH_IO_EXTENT))\r\ncontinue;\r\nport_val = inw(synth_portlist[i]) & 0xfbff;\r\nif (port_val == 0x107f) {\r\nsynth_lpc = synth_portlist[i];\r\nspeakup_info.port_tts = synth_lpc+1;\r\nbreak;\r\n}\r\nsynth_release_region(synth_portlist[i],\r\nSYNTH_IO_EXTENT);\r\n}\r\n}\r\nport_val &= 0xfbff;\r\nif (port_val != 0x107f) {\r\npr_info("DoubleTalk PC: not found\n");\r\nif (synth_lpc)\r\nsynth_release_region(synth_lpc, SYNTH_IO_EXTENT);\r\nreturn -ENODEV;\r\n}\r\nwhile (inw_p(synth_lpc) != 0x147f)\r\ncpu_relax();\r\nsp = synth_interrogate(synth);\r\npr_info("%s: %03x-%03x, ROM ver %s, s/n %u, driver: %s\n",\r\nsynth->long_name, synth_lpc, synth_lpc+SYNTH_IO_EXTENT - 1,\r\nsp->rom_version, sp->serial_number, synth->version);\r\nsynth->alive = 1;\r\nreturn 0;\r\n}\r\nstatic void dtlk_release(void)\r\n{\r\nif (speakup_info.port_tts)\r\nsynth_release_region(speakup_info.port_tts-1, SYNTH_IO_EXTENT);\r\nspeakup_info.port_tts = 0;\r\n}
