static void snd_virmidi_init_event(struct snd_virmidi *vmidi,\r\nstruct snd_seq_event *ev)\r\n{\r\nmemset(ev, 0, sizeof(*ev));\r\nev->source.port = vmidi->port;\r\nswitch (vmidi->seq_mode) {\r\ncase SNDRV_VIRMIDI_SEQ_DISPATCH:\r\nev->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\r\nbreak;\r\ncase SNDRV_VIRMIDI_SEQ_ATTACH:\r\nev->dest.client = vmidi->client;\r\nev->dest.port = vmidi->port;\r\nbreak;\r\n}\r\nev->type = SNDRV_SEQ_EVENT_NONE;\r\n}\r\nstatic int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,\r\nstruct snd_seq_event *ev)\r\n{\r\nstruct snd_virmidi *vmidi;\r\nunsigned char msg[4];\r\nint len;\r\nread_lock(&rdev->filelist_lock);\r\nlist_for_each_entry(vmidi, &rdev->filelist, list) {\r\nif (!vmidi->trigger)\r\ncontinue;\r\nif (ev->type == SNDRV_SEQ_EVENT_SYSEX) {\r\nif ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE)\r\ncontinue;\r\nsnd_seq_dump_var_event(ev, (snd_seq_dump_func_t)snd_rawmidi_receive, vmidi->substream);\r\n} else {\r\nlen = snd_midi_event_decode(vmidi->parser, msg, sizeof(msg), ev);\r\nif (len > 0)\r\nsnd_rawmidi_receive(vmidi->substream, msg, len);\r\n}\r\n}\r\nread_unlock(&rdev->filelist_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_event_input(struct snd_seq_event *ev, int direct,\r\nvoid *private_data, int atomic, int hop)\r\n{\r\nstruct snd_virmidi_dev *rdev;\r\nrdev = private_data;\r\nif (!(rdev->flags & SNDRV_VIRMIDI_USE))\r\nreturn 0;\r\nreturn snd_virmidi_dev_receive_event(rdev, ev);\r\n}\r\nstatic void snd_virmidi_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct snd_virmidi *vmidi = substream->runtime->private_data;\r\nif (up) {\r\nvmidi->trigger = 1;\r\n} else {\r\nvmidi->trigger = 0;\r\n}\r\n}\r\nstatic void snd_virmidi_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct snd_virmidi *vmidi = substream->runtime->private_data;\r\nint count, res;\r\nunsigned char buf[32], *pbuf;\r\nunsigned long flags;\r\nif (up) {\r\nvmidi->trigger = 1;\r\nif (vmidi->seq_mode == SNDRV_VIRMIDI_SEQ_DISPATCH &&\r\n!(vmidi->rdev->flags & SNDRV_VIRMIDI_SUBSCRIBE)) {\r\nwhile (snd_rawmidi_transmit(substream, buf,\r\nsizeof(buf)) > 0) {\r\n}\r\nreturn;\r\n}\r\nif (vmidi->event.type != SNDRV_SEQ_EVENT_NONE) {\r\nif (snd_seq_kernel_client_dispatch(vmidi->client, &vmidi->event, in_atomic(), 0) < 0)\r\nreturn;\r\nvmidi->event.type = SNDRV_SEQ_EVENT_NONE;\r\n}\r\nspin_lock_irqsave(&substream->runtime->lock, flags);\r\nwhile (1) {\r\ncount = __snd_rawmidi_transmit_peek(substream, buf, sizeof(buf));\r\nif (count <= 0)\r\nbreak;\r\npbuf = buf;\r\nwhile (count > 0) {\r\nres = snd_midi_event_encode(vmidi->parser, pbuf, count, &vmidi->event);\r\nif (res < 0) {\r\nsnd_midi_event_reset_encode(vmidi->parser);\r\ncontinue;\r\n}\r\n__snd_rawmidi_transmit_ack(substream, res);\r\npbuf += res;\r\ncount -= res;\r\nif (vmidi->event.type != SNDRV_SEQ_EVENT_NONE) {\r\nif (snd_seq_kernel_client_dispatch(vmidi->client, &vmidi->event, in_atomic(), 0) < 0)\r\ngoto out;\r\nvmidi->event.type = SNDRV_SEQ_EVENT_NONE;\r\n}\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&substream->runtime->lock, flags);\r\n} else {\r\nvmidi->trigger = 0;\r\n}\r\n}\r\nstatic int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_virmidi_dev *rdev = substream->rmidi->private_data;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nstruct snd_virmidi *vmidi;\r\nunsigned long flags;\r\nvmidi = kzalloc(sizeof(*vmidi), GFP_KERNEL);\r\nif (vmidi == NULL)\r\nreturn -ENOMEM;\r\nvmidi->substream = substream;\r\nif (snd_midi_event_new(0, &vmidi->parser) < 0) {\r\nkfree(vmidi);\r\nreturn -ENOMEM;\r\n}\r\nvmidi->seq_mode = rdev->seq_mode;\r\nvmidi->client = rdev->client;\r\nvmidi->port = rdev->port;\r\nruntime->private_data = vmidi;\r\nwrite_lock_irqsave(&rdev->filelist_lock, flags);\r\nlist_add_tail(&vmidi->list, &rdev->filelist);\r\nwrite_unlock_irqrestore(&rdev->filelist_lock, flags);\r\nvmidi->rdev = rdev;\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_virmidi_dev *rdev = substream->rmidi->private_data;\r\nstruct snd_rawmidi_runtime *runtime = substream->runtime;\r\nstruct snd_virmidi *vmidi;\r\nvmidi = kzalloc(sizeof(*vmidi), GFP_KERNEL);\r\nif (vmidi == NULL)\r\nreturn -ENOMEM;\r\nvmidi->substream = substream;\r\nif (snd_midi_event_new(MAX_MIDI_EVENT_BUF, &vmidi->parser) < 0) {\r\nkfree(vmidi);\r\nreturn -ENOMEM;\r\n}\r\nvmidi->seq_mode = rdev->seq_mode;\r\nvmidi->client = rdev->client;\r\nvmidi->port = rdev->port;\r\nsnd_virmidi_init_event(vmidi, &vmidi->event);\r\nvmidi->rdev = rdev;\r\nruntime->private_data = vmidi;\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_virmidi_dev *rdev = substream->rmidi->private_data;\r\nstruct snd_virmidi *vmidi = substream->runtime->private_data;\r\nwrite_lock_irq(&rdev->filelist_lock);\r\nlist_del(&vmidi->list);\r\nwrite_unlock_irq(&rdev->filelist_lock);\r\nsnd_midi_event_free(vmidi->parser);\r\nsubstream->runtime->private_data = NULL;\r\nkfree(vmidi);\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_virmidi *vmidi = substream->runtime->private_data;\r\nsnd_midi_event_free(vmidi->parser);\r\nsubstream->runtime->private_data = NULL;\r\nkfree(vmidi);\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_subscribe(void *private_data,\r\nstruct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_virmidi_dev *rdev;\r\nrdev = private_data;\r\nif (!try_module_get(rdev->card->module))\r\nreturn -EFAULT;\r\nrdev->flags |= SNDRV_VIRMIDI_SUBSCRIBE;\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_unsubscribe(void *private_data,\r\nstruct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_virmidi_dev *rdev;\r\nrdev = private_data;\r\nrdev->flags &= ~SNDRV_VIRMIDI_SUBSCRIBE;\r\nmodule_put(rdev->card->module);\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_use(void *private_data,\r\nstruct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_virmidi_dev *rdev;\r\nrdev = private_data;\r\nif (!try_module_get(rdev->card->module))\r\nreturn -EFAULT;\r\nrdev->flags |= SNDRV_VIRMIDI_USE;\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_unuse(void *private_data,\r\nstruct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_virmidi_dev *rdev;\r\nrdev = private_data;\r\nrdev->flags &= ~SNDRV_VIRMIDI_USE;\r\nmodule_put(rdev->card->module);\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_dev_attach_seq(struct snd_virmidi_dev *rdev)\r\n{\r\nint client;\r\nstruct snd_seq_port_callback pcallbacks;\r\nstruct snd_seq_port_info *pinfo;\r\nint err;\r\nif (rdev->client >= 0)\r\nreturn 0;\r\npinfo = kzalloc(sizeof(*pinfo), GFP_KERNEL);\r\nif (!pinfo) {\r\nerr = -ENOMEM;\r\ngoto __error;\r\n}\r\nclient = snd_seq_create_kernel_client(rdev->card, rdev->device,\r\n"%s %d-%d", rdev->rmidi->name,\r\nrdev->card->number,\r\nrdev->device);\r\nif (client < 0) {\r\nerr = client;\r\ngoto __error;\r\n}\r\nrdev->client = client;\r\npinfo->addr.client = client;\r\nsprintf(pinfo->name, "VirMIDI %d-%d", rdev->card->number, rdev->device);\r\npinfo->capability |= SNDRV_SEQ_PORT_CAP_WRITE | SNDRV_SEQ_PORT_CAP_SYNC_WRITE | SNDRV_SEQ_PORT_CAP_SUBS_WRITE;\r\npinfo->capability |= SNDRV_SEQ_PORT_CAP_READ | SNDRV_SEQ_PORT_CAP_SYNC_READ | SNDRV_SEQ_PORT_CAP_SUBS_READ;\r\npinfo->capability |= SNDRV_SEQ_PORT_CAP_DUPLEX;\r\npinfo->type = SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC\r\n| SNDRV_SEQ_PORT_TYPE_SOFTWARE\r\n| SNDRV_SEQ_PORT_TYPE_PORT;\r\npinfo->midi_channels = 16;\r\nmemset(&pcallbacks, 0, sizeof(pcallbacks));\r\npcallbacks.owner = THIS_MODULE;\r\npcallbacks.private_data = rdev;\r\npcallbacks.subscribe = snd_virmidi_subscribe;\r\npcallbacks.unsubscribe = snd_virmidi_unsubscribe;\r\npcallbacks.use = snd_virmidi_use;\r\npcallbacks.unuse = snd_virmidi_unuse;\r\npcallbacks.event_input = snd_virmidi_event_input;\r\npinfo->kernel = &pcallbacks;\r\nerr = snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_CREATE_PORT, pinfo);\r\nif (err < 0) {\r\nsnd_seq_delete_kernel_client(client);\r\nrdev->client = -1;\r\ngoto __error;\r\n}\r\nrdev->port = pinfo->addr.port;\r\nerr = 0;\r\n__error:\r\nkfree(pinfo);\r\nreturn err;\r\n}\r\nstatic void snd_virmidi_dev_detach_seq(struct snd_virmidi_dev *rdev)\r\n{\r\nif (rdev->client >= 0) {\r\nsnd_seq_delete_kernel_client(rdev->client);\r\nrdev->client = -1;\r\n}\r\n}\r\nstatic int snd_virmidi_dev_register(struct snd_rawmidi *rmidi)\r\n{\r\nstruct snd_virmidi_dev *rdev = rmidi->private_data;\r\nint err;\r\nswitch (rdev->seq_mode) {\r\ncase SNDRV_VIRMIDI_SEQ_DISPATCH:\r\nerr = snd_virmidi_dev_attach_seq(rdev);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase SNDRV_VIRMIDI_SEQ_ATTACH:\r\nif (rdev->client == 0)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\npr_err("ALSA: seq_virmidi: seq_mode is not set: %d\n", rdev->seq_mode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_virmidi_dev_unregister(struct snd_rawmidi *rmidi)\r\n{\r\nstruct snd_virmidi_dev *rdev = rmidi->private_data;\r\nif (rdev->seq_mode == SNDRV_VIRMIDI_SEQ_DISPATCH)\r\nsnd_virmidi_dev_detach_seq(rdev);\r\nreturn 0;\r\n}\r\nstatic void snd_virmidi_free(struct snd_rawmidi *rmidi)\r\n{\r\nstruct snd_virmidi_dev *rdev = rmidi->private_data;\r\nkfree(rdev);\r\n}\r\nint snd_virmidi_new(struct snd_card *card, int device, struct snd_rawmidi **rrmidi)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nstruct snd_virmidi_dev *rdev;\r\nint err;\r\n*rrmidi = NULL;\r\nif ((err = snd_rawmidi_new(card, "VirMidi", device,\r\n16,\r\n16,\r\n&rmidi)) < 0)\r\nreturn err;\r\nstrcpy(rmidi->name, rmidi->id);\r\nrdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\r\nif (rdev == NULL) {\r\nsnd_device_free(card, rmidi);\r\nreturn -ENOMEM;\r\n}\r\nrdev->card = card;\r\nrdev->rmidi = rmidi;\r\nrdev->device = device;\r\nrdev->client = -1;\r\nrwlock_init(&rdev->filelist_lock);\r\nINIT_LIST_HEAD(&rdev->filelist);\r\nrdev->seq_mode = SNDRV_VIRMIDI_SEQ_DISPATCH;\r\nrmidi->private_data = rdev;\r\nrmidi->private_free = snd_virmidi_free;\r\nrmidi->ops = &snd_virmidi_global_ops;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_virmidi_input_ops);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_virmidi_output_ops);\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\n*rrmidi = rmidi;\r\nreturn 0;\r\n}\r\nstatic int __init alsa_virmidi_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_virmidi_exit(void)\r\n{\r\n}
