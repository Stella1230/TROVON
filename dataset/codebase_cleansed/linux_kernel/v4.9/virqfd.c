static int __init vfio_virqfd_init(void)\r\n{\r\nvfio_irqfd_cleanup_wq =\r\ncreate_singlethread_workqueue("vfio-irqfd-cleanup");\r\nif (!vfio_irqfd_cleanup_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __exit vfio_virqfd_exit(void)\r\n{\r\ndestroy_workqueue(vfio_irqfd_cleanup_wq);\r\n}\r\nstatic void virqfd_deactivate(struct virqfd *virqfd)\r\n{\r\nqueue_work(vfio_irqfd_cleanup_wq, &virqfd->shutdown);\r\n}\r\nstatic int virqfd_wakeup(wait_queue_t *wait, unsigned mode, int sync, void *key)\r\n{\r\nstruct virqfd *virqfd = container_of(wait, struct virqfd, wait);\r\nunsigned long flags = (unsigned long)key;\r\nif (flags & POLLIN) {\r\nif ((!virqfd->handler ||\r\nvirqfd->handler(virqfd->opaque, virqfd->data)) &&\r\nvirqfd->thread)\r\nschedule_work(&virqfd->inject);\r\n}\r\nif (flags & POLLHUP) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&virqfd_lock, flags);\r\nif (*(virqfd->pvirqfd) == virqfd) {\r\n*(virqfd->pvirqfd) = NULL;\r\nvirqfd_deactivate(virqfd);\r\n}\r\nspin_unlock_irqrestore(&virqfd_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void virqfd_ptable_queue_proc(struct file *file,\r\nwait_queue_head_t *wqh, poll_table *pt)\r\n{\r\nstruct virqfd *virqfd = container_of(pt, struct virqfd, pt);\r\nadd_wait_queue(wqh, &virqfd->wait);\r\n}\r\nstatic void virqfd_shutdown(struct work_struct *work)\r\n{\r\nstruct virqfd *virqfd = container_of(work, struct virqfd, shutdown);\r\nu64 cnt;\r\neventfd_ctx_remove_wait_queue(virqfd->eventfd, &virqfd->wait, &cnt);\r\nflush_work(&virqfd->inject);\r\neventfd_ctx_put(virqfd->eventfd);\r\nkfree(virqfd);\r\n}\r\nstatic void virqfd_inject(struct work_struct *work)\r\n{\r\nstruct virqfd *virqfd = container_of(work, struct virqfd, inject);\r\nif (virqfd->thread)\r\nvirqfd->thread(virqfd->opaque, virqfd->data);\r\n}\r\nint vfio_virqfd_enable(void *opaque,\r\nint (*handler)(void *, void *),\r\nvoid (*thread)(void *, void *),\r\nvoid *data, struct virqfd **pvirqfd, int fd)\r\n{\r\nstruct fd irqfd;\r\nstruct eventfd_ctx *ctx;\r\nstruct virqfd *virqfd;\r\nint ret = 0;\r\nunsigned int events;\r\nvirqfd = kzalloc(sizeof(*virqfd), GFP_KERNEL);\r\nif (!virqfd)\r\nreturn -ENOMEM;\r\nvirqfd->pvirqfd = pvirqfd;\r\nvirqfd->opaque = opaque;\r\nvirqfd->handler = handler;\r\nvirqfd->thread = thread;\r\nvirqfd->data = data;\r\nINIT_WORK(&virqfd->shutdown, virqfd_shutdown);\r\nINIT_WORK(&virqfd->inject, virqfd_inject);\r\nirqfd = fdget(fd);\r\nif (!irqfd.file) {\r\nret = -EBADF;\r\ngoto err_fd;\r\n}\r\nctx = eventfd_ctx_fileget(irqfd.file);\r\nif (IS_ERR(ctx)) {\r\nret = PTR_ERR(ctx);\r\ngoto err_ctx;\r\n}\r\nvirqfd->eventfd = ctx;\r\nspin_lock_irq(&virqfd_lock);\r\nif (*pvirqfd) {\r\nspin_unlock_irq(&virqfd_lock);\r\nret = -EBUSY;\r\ngoto err_busy;\r\n}\r\n*pvirqfd = virqfd;\r\nspin_unlock_irq(&virqfd_lock);\r\ninit_waitqueue_func_entry(&virqfd->wait, virqfd_wakeup);\r\ninit_poll_funcptr(&virqfd->pt, virqfd_ptable_queue_proc);\r\nevents = irqfd.file->f_op->poll(irqfd.file, &virqfd->pt);\r\nif (events & POLLIN) {\r\nif ((!handler || handler(opaque, data)) && thread)\r\nschedule_work(&virqfd->inject);\r\n}\r\nfdput(irqfd);\r\nreturn 0;\r\nerr_busy:\r\neventfd_ctx_put(ctx);\r\nerr_ctx:\r\nfdput(irqfd);\r\nerr_fd:\r\nkfree(virqfd);\r\nreturn ret;\r\n}\r\nvoid vfio_virqfd_disable(struct virqfd **pvirqfd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&virqfd_lock, flags);\r\nif (*pvirqfd) {\r\nvirqfd_deactivate(*pvirqfd);\r\n*pvirqfd = NULL;\r\n}\r\nspin_unlock_irqrestore(&virqfd_lock, flags);\r\nflush_workqueue(vfio_irqfd_cleanup_wq);\r\n}
