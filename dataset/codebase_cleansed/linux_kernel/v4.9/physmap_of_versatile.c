static int ap_flash_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *ebi;\r\nstatic void __iomem *ebi_base;\r\nu32 val;\r\nint ret;\r\nebi = of_find_matching_node(NULL, ebi_match);\r\nif (!ebi) {\r\nreturn -ENODEV;\r\n}\r\nebi_base = of_iomap(ebi, 0);\r\nif (!ebi_base)\r\nreturn -ENODEV;\r\nret = regmap_write(syscon_regmap,\r\nINTEGRATOR_SC_CTRLC_OFFSET,\r\nINTEGRATOR_SC_CTRL_FLVPPEN | INTEGRATOR_SC_CTRL_FLWP);\r\nif (ret)\r\ndev_err(&pdev->dev, "error clearing Integrator VPP/WP\n");\r\nwritel(INTEGRATOR_EBI_LOCK_VAL, ebi_base + INTEGRATOR_EBI_LOCK_OFFSET);\r\nval = readl(ebi_base + INTEGRATOR_EBI_CSR1_OFFSET);\r\nval |= INTEGRATOR_EBI_WRITE_ENABLE;\r\nwritel(val, ebi_base + INTEGRATOR_EBI_CSR1_OFFSET);\r\nwritel(0, ebi_base + INTEGRATOR_EBI_LOCK_OFFSET);\r\niounmap(ebi_base);\r\nreturn 0;\r\n}\r\nstatic void ap_flash_set_vpp(struct map_info *map, int on)\r\n{\r\nint ret;\r\nif (on) {\r\nret = regmap_write(syscon_regmap,\r\nINTEGRATOR_SC_CTRLS_OFFSET,\r\nINTEGRATOR_SC_CTRL_FLVPPEN | INTEGRATOR_SC_CTRL_FLWP);\r\nif (ret)\r\npr_err("error enabling AP VPP\n");\r\n} else {\r\nret = regmap_write(syscon_regmap,\r\nINTEGRATOR_SC_CTRLC_OFFSET,\r\nINTEGRATOR_SC_CTRL_FLVPPEN | INTEGRATOR_SC_CTRL_FLWP);\r\nif (ret)\r\npr_err("error disabling AP VPP\n");\r\n}\r\n}\r\nstatic void cp_flash_set_vpp(struct map_info *map, int on)\r\n{\r\nint ret;\r\nif (on) {\r\nret = regmap_update_bits(syscon_regmap,\r\nINTCP_FLASHPROG_OFFSET,\r\nCINTEGRATOR_FLMASK,\r\nCINTEGRATOR_FLVPPEN | CINTEGRATOR_FLWREN);\r\nif (ret)\r\npr_err("error setting CP VPP\n");\r\n} else {\r\nret = regmap_update_bits(syscon_regmap,\r\nINTCP_FLASHPROG_OFFSET,\r\nCINTEGRATOR_FLMASK,\r\n0);\r\nif (ret)\r\npr_err("error setting CP VPP\n");\r\n}\r\n}\r\nstatic void versatile_flash_set_vpp(struct map_info *map, int on)\r\n{\r\nint ret;\r\nret = regmap_update_bits(syscon_regmap, VERSATILE_SYS_FLASH_OFFSET,\r\n0x01, !!on);\r\nif (ret)\r\npr_err("error setting Versatile VPP\n");\r\n}\r\nint of_flash_probe_versatile(struct platform_device *pdev,\r\nstruct device_node *np,\r\nstruct map_info *map)\r\n{\r\nstruct device_node *sysnp;\r\nconst struct of_device_id *devid;\r\nstruct regmap *rmap;\r\nstatic enum versatile_flashprot versatile_flashprot;\r\nint ret;\r\nif (!of_device_is_compatible(np, "arm,versatile-flash"))\r\nreturn 0;\r\nif (!syscon_regmap) {\r\nsysnp = of_find_matching_node_and_match(NULL,\r\nsyscon_match,\r\n&devid);\r\nif (!sysnp)\r\nreturn -ENODEV;\r\nversatile_flashprot = (enum versatile_flashprot)devid->data;\r\nrmap = syscon_node_to_regmap(sysnp);\r\nif (IS_ERR(rmap))\r\nreturn PTR_ERR(rmap);\r\nsyscon_regmap = rmap;\r\n}\r\nswitch (versatile_flashprot) {\r\ncase INTEGRATOR_AP_FLASHPROT:\r\nret = ap_flash_init(pdev);\r\nif (ret)\r\nreturn ret;\r\nmap->set_vpp = ap_flash_set_vpp;\r\ndev_info(&pdev->dev, "Integrator/AP flash protection\n");\r\nbreak;\r\ncase INTEGRATOR_CP_FLASHPROT:\r\nmap->set_vpp = cp_flash_set_vpp;\r\ndev_info(&pdev->dev, "Integrator/CP flash protection\n");\r\nbreak;\r\ncase VERSATILE_FLASHPROT:\r\ncase REALVIEW_FLASHPROT:\r\nmap->set_vpp = versatile_flash_set_vpp;\r\ndev_info(&pdev->dev, "versatile/realview flash protection\n");\r\nbreak;\r\ndefault:\r\ndev_info(&pdev->dev, "device marked as Versatile flash "\r\n"but no system controller was found\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}
