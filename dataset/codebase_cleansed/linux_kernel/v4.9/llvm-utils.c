int perf_llvm_config(const char *var, const char *value)\r\n{\r\nif (prefixcmp(var, "llvm."))\r\nreturn 0;\r\nvar += sizeof("llvm.") - 1;\r\nif (!strcmp(var, "clang-path"))\r\nllvm_param.clang_path = strdup(value);\r\nelse if (!strcmp(var, "clang-bpf-cmd-template"))\r\nllvm_param.clang_bpf_cmd_template = strdup(value);\r\nelse if (!strcmp(var, "clang-opt"))\r\nllvm_param.clang_opt = strdup(value);\r\nelse if (!strcmp(var, "kbuild-dir"))\r\nllvm_param.kbuild_dir = strdup(value);\r\nelse if (!strcmp(var, "kbuild-opts"))\r\nllvm_param.kbuild_opts = strdup(value);\r\nelse if (!strcmp(var, "dump-obj"))\r\nllvm_param.dump_obj = !!perf_config_bool(var, value);\r\nelse\r\nreturn -1;\r\nllvm_param.user_set_param = true;\r\nreturn 0;\r\n}\r\nstatic int\r\nsearch_program(const char *def, const char *name,\r\nchar *output)\r\n{\r\nchar *env, *path, *tmp = NULL;\r\nchar buf[PATH_MAX];\r\nint ret;\r\noutput[0] = '\0';\r\nif (def && def[0] != '\0') {\r\nif (def[0] == '/') {\r\nif (access(def, F_OK) == 0) {\r\nstrlcpy(output, def, PATH_MAX);\r\nreturn 0;\r\n}\r\n} else if (def[0] != '\0')\r\nname = def;\r\n}\r\nenv = getenv("PATH");\r\nif (!env)\r\nreturn -1;\r\nenv = strdup(env);\r\nif (!env)\r\nreturn -1;\r\nret = -ENOENT;\r\npath = strtok_r(env, ":", &tmp);\r\nwhile (path) {\r\nscnprintf(buf, sizeof(buf), "%s/%s", path, name);\r\nif (access(buf, F_OK) == 0) {\r\nstrlcpy(output, buf, PATH_MAX);\r\nret = 0;\r\nbreak;\r\n}\r\npath = strtok_r(NULL, ":", &tmp);\r\n}\r\nfree(env);\r\nreturn ret;\r\n}\r\nstatic int\r\nread_from_pipe(const char *cmd, void **p_buf, size_t *p_read_sz)\r\n{\r\nint err = 0;\r\nvoid *buf = NULL;\r\nFILE *file = NULL;\r\nsize_t read_sz = 0, buf_sz = 0;\r\nchar serr[STRERR_BUFSIZE];\r\nfile = popen(cmd, "r");\r\nif (!file) {\r\npr_err("ERROR: unable to popen cmd: %s\n",\r\nstr_error_r(errno, serr, sizeof(serr)));\r\nreturn -EINVAL;\r\n}\r\nwhile (!feof(file) && !ferror(file)) {\r\nif (buf_sz - read_sz < READ_SIZE + 1) {\r\nvoid *new_buf;\r\nbuf_sz = read_sz + READ_SIZE + 1;\r\nnew_buf = realloc(buf, buf_sz);\r\nif (!new_buf) {\r\npr_err("ERROR: failed to realloc memory\n");\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nbuf = new_buf;\r\n}\r\nread_sz += fread(buf + read_sz, 1, READ_SIZE, file);\r\n}\r\nif (buf_sz - read_sz < 1) {\r\npr_err("ERROR: internal error\n");\r\nerr = -EINVAL;\r\ngoto errout;\r\n}\r\nif (ferror(file)) {\r\npr_err("ERROR: error occurred when reading from pipe: %s\n",\r\nstr_error_r(errno, serr, sizeof(serr)));\r\nerr = -EIO;\r\ngoto errout;\r\n}\r\nerr = WEXITSTATUS(pclose(file));\r\nfile = NULL;\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto errout;\r\n}\r\n((char *)buf)[read_sz] = '\0';\r\nif (!p_buf)\r\nfree(buf);\r\nelse\r\n*p_buf = buf;\r\nif (p_read_sz)\r\n*p_read_sz = read_sz;\r\nreturn 0;\r\nerrout:\r\nif (file)\r\npclose(file);\r\nfree(buf);\r\nif (p_buf)\r\n*p_buf = NULL;\r\nif (p_read_sz)\r\n*p_read_sz = 0;\r\nreturn err;\r\n}\r\nstatic inline void\r\nforce_set_env(const char *var, const char *value)\r\n{\r\nif (value) {\r\nsetenv(var, value, 1);\r\npr_debug("set env: %s=%s\n", var, value);\r\n} else {\r\nunsetenv(var);\r\npr_debug("unset env: %s\n", var);\r\n}\r\n}\r\nstatic void\r\nversion_notice(void)\r\n{\r\npr_err(\r\n" \tLLVM 3.7 or newer is required. Which can be found from http://llvm.org\n"\r\n" \tYou may want to try git trunk:\n"\r\n" \t\tgit clone http://llvm.org/git/llvm.git\n"\r\n" \t\t and\n"\r\n" \t\tgit clone http://llvm.org/git/clang.git\n\n"\r\n" \tOr fetch the latest clang/llvm 3.7 from pre-built llvm packages for\n"\r\n" \tdebian/ubuntu:\n"\r\n" \t\thttp://llvm.org/apt\n\n"\r\n" \tIf you are using old version of clang, change 'clang-bpf-cmd-template'\n"\r\n" \toption in [llvm] section of ~/.perfconfig to:\n\n"\r\n" \t \"$CLANG_EXEC $CLANG_OPTIONS $KERNEL_INC_OPTIONS \\\n"\r\n" \t -working-directory $WORKING_DIR -c $CLANG_SOURCE \\\n"\r\n" \t -emit-llvm -o - | /path/to/llc -march=bpf -filetype=obj -o -\"\n"\r\n" \t(Replace /path/to/llc with path to your llc)\n\n"\r\n);\r\n}\r\nstatic int detect_kbuild_dir(char **kbuild_dir)\r\n{\r\nconst char *test_dir = llvm_param.kbuild_dir;\r\nconst char *prefix_dir = "";\r\nconst char *suffix_dir = "";\r\nchar *autoconf_path;\r\nint err;\r\nif (!test_dir) {\r\nchar release[128];\r\nerr = fetch_kernel_version(NULL, release,\r\nsizeof(release));\r\nif (err)\r\nreturn -EINVAL;\r\ntest_dir = release;\r\nprefix_dir = "/lib/modules/";\r\nsuffix_dir = "/build";\r\n}\r\nerr = asprintf(&autoconf_path, "%s%s%s/include/generated/autoconf.h",\r\nprefix_dir, test_dir, suffix_dir);\r\nif (err < 0)\r\nreturn -ENOMEM;\r\nif (access(autoconf_path, R_OK) == 0) {\r\nfree(autoconf_path);\r\nerr = asprintf(kbuild_dir, "%s%s%s", prefix_dir, test_dir,\r\nsuffix_dir);\r\nif (err < 0)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nfree(autoconf_path);\r\nreturn -ENOENT;\r\n}\r\nstatic inline void\r\nget_kbuild_opts(char **kbuild_dir, char **kbuild_include_opts)\r\n{\r\nint err;\r\nif (!kbuild_dir || !kbuild_include_opts)\r\nreturn;\r\n*kbuild_dir = NULL;\r\n*kbuild_include_opts = NULL;\r\nif (llvm_param.kbuild_dir && !llvm_param.kbuild_dir[0]) {\r\npr_debug("[llvm.kbuild-dir] is set to \"\" deliberately.\n");\r\npr_debug("Skip kbuild options detection.\n");\r\nreturn;\r\n}\r\nerr = detect_kbuild_dir(kbuild_dir);\r\nif (err) {\r\npr_warning(\r\n"WARNING:\tunable to get correct kernel building directory.\n"\r\n"Hint:\tSet correct kbuild directory using 'kbuild-dir' option in [llvm]\n"\r\n" \tsection of ~/.perfconfig or set it to \"\" to suppress kbuild\n"\r\n" \tdetection.\n\n");\r\nreturn;\r\n}\r\npr_debug("Kernel build dir is set to %s\n", *kbuild_dir);\r\nforce_set_env("KBUILD_DIR", *kbuild_dir);\r\nforce_set_env("KBUILD_OPTS", llvm_param.kbuild_opts);\r\nerr = read_from_pipe(kinc_fetch_script,\r\n(void **)kbuild_include_opts,\r\nNULL);\r\nif (err) {\r\npr_warning(\r\n"WARNING:\tunable to get kernel include directories from '%s'\n"\r\n"Hint:\tTry set clang include options using 'clang-bpf-cmd-template'\n"\r\n" \toption in [llvm] section of ~/.perfconfig and set 'kbuild-dir'\n"\r\n" \toption in [llvm] to \"\" to suppress this detection.\n\n",\r\n*kbuild_dir);\r\nfree(*kbuild_dir);\r\n*kbuild_dir = NULL;\r\nreturn;\r\n}\r\npr_debug("include option is set to %s\n", *kbuild_include_opts);\r\n}\r\nstatic void\r\ndump_obj(const char *path, void *obj_buf, size_t size)\r\n{\r\nchar *obj_path = strdup(path);\r\nFILE *fp;\r\nchar *p;\r\nif (!obj_path) {\r\npr_warning("WARNING: No enough memory, skip object dumping\n");\r\nreturn;\r\n}\r\np = strrchr(obj_path, '.');\r\nif (!p || (strcmp(p, ".c") != 0)) {\r\npr_warning("WARNING: invalid llvm source path: '%s', skip object dumping\n",\r\nobj_path);\r\ngoto out;\r\n}\r\np[1] = 'o';\r\nfp = fopen(obj_path, "wb");\r\nif (!fp) {\r\npr_warning("WARNING: failed to open '%s': %s, skip object dumping\n",\r\nobj_path, strerror(errno));\r\ngoto out;\r\n}\r\npr_info("LLVM: dumping %s\n", obj_path);\r\nif (fwrite(obj_buf, size, 1, fp) != 1)\r\npr_warning("WARNING: failed to write to file '%s': %s, skip object dumping\n",\r\nobj_path, strerror(errno));\r\nfclose(fp);\r\nout:\r\nfree(obj_path);\r\n}\r\nint llvm__compile_bpf(const char *path, void **p_obj_buf,\r\nsize_t *p_obj_buf_sz)\r\n{\r\nsize_t obj_buf_sz;\r\nvoid *obj_buf = NULL;\r\nint err, nr_cpus_avail;\r\nunsigned int kernel_version;\r\nchar linux_version_code_str[64];\r\nconst char *clang_opt = llvm_param.clang_opt;\r\nchar clang_path[PATH_MAX], abspath[PATH_MAX], nr_cpus_avail_str[64];\r\nchar serr[STRERR_BUFSIZE];\r\nchar *kbuild_dir = NULL, *kbuild_include_opts = NULL;\r\nconst char *template = llvm_param.clang_bpf_cmd_template;\r\nif (path[0] != '-' && realpath(path, abspath) == NULL) {\r\nerr = errno;\r\npr_err("ERROR: problems with path %s: %s\n",\r\npath, str_error_r(err, serr, sizeof(serr)));\r\nreturn -err;\r\n}\r\nif (!template)\r\ntemplate = CLANG_BPF_CMD_DEFAULT_TEMPLATE;\r\nerr = search_program(llvm_param.clang_path,\r\n"clang", clang_path);\r\nif (err) {\r\npr_err(\r\n"ERROR:\tunable to find clang.\n"\r\n"Hint:\tTry to install latest clang/llvm to support BPF. Check your $PATH\n"\r\n" \tand 'clang-path' option in [llvm] section of ~/.perfconfig.\n");\r\nversion_notice();\r\nreturn -ENOENT;\r\n}\r\nget_kbuild_opts(&kbuild_dir, &kbuild_include_opts);\r\nnr_cpus_avail = sysconf(_SC_NPROCESSORS_CONF);\r\nif (nr_cpus_avail <= 0) {\r\npr_err(\r\n"WARNING:\tunable to get available CPUs in this system: %s\n"\r\n" \tUse 128 instead.\n", str_error_r(errno, serr, sizeof(serr)));\r\nnr_cpus_avail = 128;\r\n}\r\nsnprintf(nr_cpus_avail_str, sizeof(nr_cpus_avail_str), "%d",\r\nnr_cpus_avail);\r\nif (fetch_kernel_version(&kernel_version, NULL, 0))\r\nkernel_version = 0;\r\nsnprintf(linux_version_code_str, sizeof(linux_version_code_str),\r\n"0x%x", kernel_version);\r\nforce_set_env("NR_CPUS", nr_cpus_avail_str);\r\nforce_set_env("LINUX_VERSION_CODE", linux_version_code_str);\r\nforce_set_env("CLANG_EXEC", clang_path);\r\nforce_set_env("CLANG_OPTIONS", clang_opt);\r\nforce_set_env("KERNEL_INC_OPTIONS", kbuild_include_opts);\r\nforce_set_env("WORKING_DIR", kbuild_dir ? : ".");\r\nforce_set_env("CLANG_SOURCE",\r\n(path[0] == '-') ? path : abspath);\r\npr_debug("llvm compiling command template: %s\n", template);\r\nerr = read_from_pipe(template, &obj_buf, &obj_buf_sz);\r\nif (err) {\r\npr_err("ERROR:\tunable to compile %s\n", path);\r\npr_err("Hint:\tCheck error message shown above.\n");\r\npr_err("Hint:\tYou can also pre-compile it into .o using:\n");\r\npr_err(" \t\tclang -target bpf -O2 -c %s\n", path);\r\npr_err(" \twith proper -I and -D options.\n");\r\ngoto errout;\r\n}\r\nfree(kbuild_dir);\r\nfree(kbuild_include_opts);\r\nif (llvm_param.dump_obj)\r\ndump_obj(path, obj_buf, obj_buf_sz);\r\nif (!p_obj_buf)\r\nfree(obj_buf);\r\nelse\r\n*p_obj_buf = obj_buf;\r\nif (p_obj_buf_sz)\r\n*p_obj_buf_sz = obj_buf_sz;\r\nreturn 0;\r\nerrout:\r\nfree(kbuild_dir);\r\nfree(kbuild_include_opts);\r\nfree(obj_buf);\r\nif (p_obj_buf)\r\n*p_obj_buf = NULL;\r\nif (p_obj_buf_sz)\r\n*p_obj_buf_sz = 0;\r\nreturn err;\r\n}\r\nint llvm__search_clang(void)\r\n{\r\nchar clang_path[PATH_MAX];\r\nreturn search_program(llvm_param.clang_path, "clang", clang_path);\r\n}
