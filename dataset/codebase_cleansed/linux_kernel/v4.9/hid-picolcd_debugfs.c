static int picolcd_debug_reset_show(struct seq_file *f, void *p)\r\n{\r\nif (picolcd_fbinfo((struct picolcd_data *)f->private))\r\nseq_printf(f, "all fb\n");\r\nelse\r\nseq_printf(f, "all\n");\r\nreturn 0;\r\n}\r\nstatic int picolcd_debug_reset_open(struct inode *inode, struct file *f)\r\n{\r\nreturn single_open(f, picolcd_debug_reset_show, inode->i_private);\r\n}\r\nstatic ssize_t picolcd_debug_reset_write(struct file *f, const char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct picolcd_data *data = ((struct seq_file *)f->private_data)->private;\r\nchar buf[32];\r\nsize_t cnt = min(count, sizeof(buf)-1);\r\nif (copy_from_user(buf, user_buf, cnt))\r\nreturn -EFAULT;\r\nwhile (cnt > 0 && (buf[cnt-1] == ' ' || buf[cnt-1] == '\n'))\r\ncnt--;\r\nbuf[cnt] = '\0';\r\nif (strcmp(buf, "all") == 0) {\r\npicolcd_reset(data->hdev);\r\npicolcd_fb_reset(data, 1);\r\n} else if (strcmp(buf, "fb") == 0) {\r\npicolcd_fb_reset(data, 1);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t picolcd_debug_eeprom_read(struct file *f, char __user *u,\r\nsize_t s, loff_t *off)\r\n{\r\nstruct picolcd_data *data = f->private_data;\r\nstruct picolcd_pending *resp;\r\nu8 raw_data[3];\r\nssize_t ret = -EIO;\r\nif (s == 0)\r\nreturn -EINVAL;\r\nif (*off > 0x0ff)\r\nreturn 0;\r\nraw_data[0] = *off & 0xff;\r\nraw_data[1] = (*off >> 8) & 0xff;\r\nraw_data[2] = s < 20 ? s : 20;\r\nif (*off + raw_data[2] > 0xff)\r\nraw_data[2] = 0x100 - *off;\r\nresp = picolcd_send_and_wait(data->hdev, REPORT_EE_READ, raw_data,\r\nsizeof(raw_data));\r\nif (!resp)\r\nreturn -EIO;\r\nif (resp->in_report && resp->in_report->id == REPORT_EE_DATA) {\r\nret = resp->raw_data[2];\r\nif (ret > s)\r\nret = s;\r\nif (copy_to_user(u, resp->raw_data+3, ret))\r\nret = -EFAULT;\r\nelse\r\n*off += ret;\r\n}\r\nkfree(resp);\r\nreturn ret;\r\n}\r\nstatic ssize_t picolcd_debug_eeprom_write(struct file *f, const char __user *u,\r\nsize_t s, loff_t *off)\r\n{\r\nstruct picolcd_data *data = f->private_data;\r\nstruct picolcd_pending *resp;\r\nssize_t ret = -EIO;\r\nu8 raw_data[23];\r\nif (s == 0)\r\nreturn -EINVAL;\r\nif (*off > 0x0ff)\r\nreturn -ENOSPC;\r\nmemset(raw_data, 0, sizeof(raw_data));\r\nraw_data[0] = *off & 0xff;\r\nraw_data[1] = (*off >> 8) & 0xff;\r\nraw_data[2] = min_t(size_t, 20, s);\r\nif (*off + raw_data[2] > 0xff)\r\nraw_data[2] = 0x100 - *off;\r\nif (copy_from_user(raw_data+3, u, min((u8)20, raw_data[2])))\r\nreturn -EFAULT;\r\nresp = picolcd_send_and_wait(data->hdev, REPORT_EE_WRITE, raw_data,\r\nsizeof(raw_data));\r\nif (!resp)\r\nreturn -EIO;\r\nif (resp->in_report && resp->in_report->id == REPORT_EE_DATA) {\r\nif (memcmp(raw_data, resp->raw_data, 3+raw_data[2]) == 0) {\r\n*off += raw_data[2];\r\nret = raw_data[2];\r\n}\r\n}\r\nkfree(resp);\r\nreturn ret;\r\n}\r\nstatic int _picolcd_flash_setaddr(struct picolcd_data *data, u8 *buf, long off)\r\n{\r\nbuf[0] = off & 0xff;\r\nbuf[1] = (off >> 8) & 0xff;\r\nif (data->addr_sz == 3)\r\nbuf[2] = (off >> 16) & 0xff;\r\nreturn data->addr_sz == 2 ? 2 : 3;\r\n}\r\nstatic ssize_t _picolcd_flash_read(struct picolcd_data *data, int report_id,\r\nchar __user *u, size_t s, loff_t *off)\r\n{\r\nstruct picolcd_pending *resp;\r\nu8 raw_data[4];\r\nssize_t ret = 0;\r\nint len_off, err = -EIO;\r\nwhile (s > 0) {\r\nerr = -EIO;\r\nlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\r\nraw_data[len_off] = s > 32 ? 32 : s;\r\nresp = picolcd_send_and_wait(data->hdev, report_id, raw_data, len_off+1);\r\nif (!resp || !resp->in_report)\r\ngoto skip;\r\nif (resp->in_report->id == REPORT_MEMORY ||\r\nresp->in_report->id == REPORT_BL_READ_MEMORY) {\r\nif (memcmp(raw_data, resp->raw_data, len_off+1) != 0)\r\ngoto skip;\r\nif (copy_to_user(u+ret, resp->raw_data+len_off+1, raw_data[len_off])) {\r\nerr = -EFAULT;\r\ngoto skip;\r\n}\r\n*off += raw_data[len_off];\r\ns -= raw_data[len_off];\r\nret += raw_data[len_off];\r\nerr = 0;\r\n}\r\nskip:\r\nkfree(resp);\r\nif (err)\r\nreturn ret > 0 ? ret : err;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t picolcd_debug_flash_read(struct file *f, char __user *u,\r\nsize_t s, loff_t *off)\r\n{\r\nstruct picolcd_data *data = f->private_data;\r\nif (s == 0)\r\nreturn -EINVAL;\r\nif (*off > 0x05fff)\r\nreturn 0;\r\nif (*off + s > 0x05fff)\r\ns = 0x06000 - *off;\r\nif (data->status & PICOLCD_BOOTLOADER)\r\nreturn _picolcd_flash_read(data, REPORT_BL_READ_MEMORY, u, s, off);\r\nelse\r\nreturn _picolcd_flash_read(data, REPORT_READ_MEMORY, u, s, off);\r\n}\r\nstatic ssize_t _picolcd_flash_erase64(struct picolcd_data *data, int report_id,\r\nloff_t *off)\r\n{\r\nstruct picolcd_pending *resp;\r\nu8 raw_data[3];\r\nint len_off;\r\nssize_t ret = -EIO;\r\nif (*off & 0x3f)\r\nreturn -EINVAL;\r\nlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\r\nresp = picolcd_send_and_wait(data->hdev, report_id, raw_data, len_off);\r\nif (!resp || !resp->in_report)\r\ngoto skip;\r\nif (resp->in_report->id == REPORT_MEMORY ||\r\nresp->in_report->id == REPORT_BL_ERASE_MEMORY) {\r\nif (memcmp(raw_data, resp->raw_data, len_off) != 0)\r\ngoto skip;\r\nret = 0;\r\n}\r\nskip:\r\nkfree(resp);\r\nreturn ret;\r\n}\r\nstatic ssize_t _picolcd_flash_write(struct picolcd_data *data, int report_id,\r\nconst char __user *u, size_t s, loff_t *off)\r\n{\r\nstruct picolcd_pending *resp;\r\nu8 raw_data[36];\r\nssize_t ret = 0;\r\nint len_off, err = -EIO;\r\nwhile (s > 0) {\r\nerr = -EIO;\r\nlen_off = _picolcd_flash_setaddr(data, raw_data, *off);\r\nraw_data[len_off] = s > 32 ? 32 : s;\r\nif (copy_from_user(raw_data+len_off+1, u, raw_data[len_off])) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nresp = picolcd_send_and_wait(data->hdev, report_id, raw_data,\r\nlen_off+1+raw_data[len_off]);\r\nif (!resp || !resp->in_report)\r\ngoto skip;\r\nif (resp->in_report->id == REPORT_MEMORY ||\r\nresp->in_report->id == REPORT_BL_WRITE_MEMORY) {\r\nif (memcmp(raw_data, resp->raw_data, len_off+1+raw_data[len_off]) != 0)\r\ngoto skip;\r\n*off += raw_data[len_off];\r\ns -= raw_data[len_off];\r\nret += raw_data[len_off];\r\nerr = 0;\r\n}\r\nskip:\r\nkfree(resp);\r\nif (err)\r\nbreak;\r\n}\r\nreturn ret > 0 ? ret : err;\r\n}\r\nstatic ssize_t picolcd_debug_flash_write(struct file *f, const char __user *u,\r\nsize_t s, loff_t *off)\r\n{\r\nstruct picolcd_data *data = f->private_data;\r\nssize_t err, ret = 0;\r\nint report_erase, report_write;\r\nif (s == 0)\r\nreturn -EINVAL;\r\nif (*off > 0x5fff)\r\nreturn -ENOSPC;\r\nif (s & 0x3f)\r\nreturn -EINVAL;\r\nif (*off & 0x3f)\r\nreturn -EINVAL;\r\nif (data->status & PICOLCD_BOOTLOADER) {\r\nreport_erase = REPORT_BL_ERASE_MEMORY;\r\nreport_write = REPORT_BL_WRITE_MEMORY;\r\n} else {\r\nreport_erase = REPORT_ERASE_MEMORY;\r\nreport_write = REPORT_WRITE_MEMORY;\r\n}\r\nmutex_lock(&data->mutex_flash);\r\nwhile (s > 0) {\r\nerr = _picolcd_flash_erase64(data, report_erase, off);\r\nif (err)\r\nbreak;\r\nerr = _picolcd_flash_write(data, report_write, u, 64, off);\r\nif (err < 0)\r\nbreak;\r\nret += err;\r\n*off += err;\r\ns -= err;\r\nif (err != 64)\r\nbreak;\r\n}\r\nmutex_unlock(&data->mutex_flash);\r\nreturn ret > 0 ? ret : err;\r\n}\r\nstatic void dump_buff_as_hex(char *dst, size_t dst_sz, const u8 *data,\r\nconst size_t data_len)\r\n{\r\nint i, j;\r\nfor (i = j = 0; i < data_len && j + 4 < dst_sz; i++) {\r\ndst[j++] = hex_asc[(data[i] >> 4) & 0x0f];\r\ndst[j++] = hex_asc[data[i] & 0x0f];\r\ndst[j++] = ' ';\r\n}\r\ndst[j] = '\0';\r\nif (j > 0)\r\ndst[j-1] = '\n';\r\nif (i < data_len && j > 2)\r\ndst[j-2] = dst[j-3] = '.';\r\n}\r\nvoid picolcd_debug_out_report(struct picolcd_data *data,\r\nstruct hid_device *hdev, struct hid_report *report)\r\n{\r\nu8 *raw_data;\r\nint raw_size = (report->size >> 3) + 1;\r\nchar *buff;\r\n#define BUFF_SZ 256\r\nif (list_empty(&hdev->debug_list))\r\nreturn;\r\nbuff = kmalloc(BUFF_SZ, GFP_ATOMIC);\r\nif (!buff)\r\nreturn;\r\nraw_data = hid_alloc_report_buf(report, GFP_ATOMIC);\r\nif (!raw_data) {\r\nkfree(buff);\r\nreturn;\r\n}\r\nsnprintf(buff, BUFF_SZ, "\nout report %d (size %d) = ",\r\nreport->id, raw_size);\r\nhid_debug_event(hdev, buff);\r\nraw_data[0] = report->id;\r\nhid_output_report(report, raw_data);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data, raw_size);\r\nhid_debug_event(hdev, buff);\r\nswitch (report->id) {\r\ncase REPORT_LED_STATE:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_LED_STATE", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tGPO state: 0x%02x\n", raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_BRIGHTNESS:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_BRIGHTNESS", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tBrightness: 0x%02x\n", raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_CONTRAST:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_CONTRAST", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tContrast: 0x%02x\n", raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_RESET:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_RESET", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tDuration: 0x%02x%02x (%dms)\n",\r\nraw_data[2], raw_data[1], raw_data[2] << 8 | raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_LCD_CMD:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_LCD_CMD", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_LCD_DATA:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_LCD_CMD", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_LCD_CMD_DATA:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_LCD_CMD", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_EE_READ:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_EE_READ", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_EE_WRITE:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_EE_WRITE", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[3] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[3] + 4 <= raw_size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_ERASE_MEMORY:\r\ncase REPORT_BL_ERASE_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_ERASE_MEMORY", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nswitch (data->addr_sz) {\r\ncase 2:\r\nsnprintf(buff, BUFF_SZ, "\tAddress inside 64 byte block: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nbreak;\r\ncase 3:\r\nsnprintf(buff, BUFF_SZ, "\tAddress inside 64 byte block: 0x%02x%02x%02x\n",\r\nraw_data[3], raw_data[2], raw_data[1]);\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "\tNot supported\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_READ_MEMORY:\r\ncase REPORT_BL_READ_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_READ_MEMORY", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nswitch (data->addr_sz) {\r\ncase 2:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nbreak;\r\ncase 3:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x%02x\n",\r\nraw_data[3], raw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[4]);\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "\tNot supported\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_WRITE_MEMORY:\r\ncase REPORT_BL_WRITE_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_WRITE_MEMORY", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nswitch (data->addr_sz) {\r\ncase 2:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[3] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[3] + 4 <= raw_size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nbreak;\r\ncase 3:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x%02x\n",\r\nraw_data[3], raw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[4]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[4] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[4] + 5 <= raw_size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+5, raw_data[4]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "\tNot supported\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_SPLASH_RESTART:\r\nbreak;\r\ncase REPORT_EXIT_KEYBOARD:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_EXIT_KEYBOARD", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tRestart delay: %dms (0x%02x%02x)\n",\r\nraw_data[1] | (raw_data[2] << 8),\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_VERSION:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_VERSION", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_DEVID:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_DEVID", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_SPLASH_SIZE:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_SPLASH_SIZE", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_HOOK_VERSION:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_HOOK_VERSION", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_EXIT_FLASHER:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"REPORT_VERSION", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tRestart delay: %dms (0x%02x%02x)\n",\r\nraw_data[1] | (raw_data[2] << 8),\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "out report %s (%d, size=%d)\n",\r\n"<unknown>", report->id, raw_size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\n}\r\nwake_up_interruptible(&hdev->debug_wait);\r\nkfree(raw_data);\r\nkfree(buff);\r\n}\r\nvoid picolcd_debug_raw_event(struct picolcd_data *data,\r\nstruct hid_device *hdev, struct hid_report *report,\r\nu8 *raw_data, int size)\r\n{\r\nchar *buff;\r\n#define BUFF_SZ 256\r\nif (list_empty(&hdev->debug_list))\r\nreturn;\r\nbuff = kmalloc(BUFF_SZ, GFP_ATOMIC);\r\nif (!buff)\r\nreturn;\r\nswitch (report->id) {\r\ncase REPORT_ERROR_CODE:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_ERROR_CODE", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[2] < ARRAY_SIZE(error_codes))\r\nsnprintf(buff, BUFF_SZ, "\tError code 0x%02x (%s) in reply to report 0x%02x\n",\r\nraw_data[2], error_codes[raw_data[2]], raw_data[1]);\r\nelse\r\nsnprintf(buff, BUFF_SZ, "\tError code 0x%02x in reply to report 0x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_KEY_STATE:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_KEY_STATE", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[1] == 0)\r\nsnprintf(buff, BUFF_SZ, "\tNo key pressed\n");\r\nelse if (raw_data[2] == 0)\r\nsnprintf(buff, BUFF_SZ, "\tOne key pressed: 0x%02x (%d)\n",\r\nraw_data[1], raw_data[1]);\r\nelse\r\nsnprintf(buff, BUFF_SZ, "\tTwo keys pressed: 0x%02x (%d), 0x%02x (%d)\n",\r\nraw_data[1], raw_data[1], raw_data[2], raw_data[2]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_IR_DATA:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_IR_DATA", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[1] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tUnexpectedly 0 data length\n");\r\nhid_debug_event(hdev, buff);\r\n} else if (raw_data[1] + 1 <= size) {\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n\tIR Data: ",\r\nraw_data[1]);\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+2, raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tOverflowing data length: %d\n",\r\nraw_data[1]-1);\r\nhid_debug_event(hdev, buff);\r\n}\r\nbreak;\r\ncase REPORT_EE_DATA:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_EE_DATA", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[3] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\nhid_debug_event(hdev, buff);\r\n} else if (raw_data[3] + 4 <= size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\nhid_debug_event(hdev, buff);\r\n}\r\nbreak;\r\ncase REPORT_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_MEMORY", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nswitch (data->addr_sz) {\r\ncase 2:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[3] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[3] + 4 <= size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+4, raw_data[3]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nbreak;\r\ncase 3:\r\nsnprintf(buff, BUFF_SZ, "\tData address: 0x%02x%02x%02x\n",\r\nraw_data[3], raw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tData length: %d\n", raw_data[4]);\r\nhid_debug_event(hdev, buff);\r\nif (raw_data[4] == 0) {\r\nsnprintf(buff, BUFF_SZ, "\tNo data\n");\r\n} else if (raw_data[4] + 5 <= size) {\r\nsnprintf(buff, BUFF_SZ, "\tData: ");\r\nhid_debug_event(hdev, buff);\r\ndump_buff_as_hex(buff, BUFF_SZ, raw_data+5, raw_data[4]);\r\n} else {\r\nsnprintf(buff, BUFF_SZ, "\tData overflowed\n");\r\n}\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "\tNot supported\n");\r\n}\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_VERSION:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_VERSION", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tFirmware version: %d.%d\n",\r\nraw_data[2], raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_BL_ERASE_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_BL_ERASE_MEMORY", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_BL_READ_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_BL_READ_MEMORY", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_BL_WRITE_MEMORY:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_BL_WRITE_MEMORY", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_DEVID:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_DEVID", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tSerial: 0x%02x%02x%02x%02x\n",\r\nraw_data[1], raw_data[2], raw_data[3], raw_data[4]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tType: 0x%02x\n",\r\nraw_data[5]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_SPLASH_SIZE:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_SPLASH_SIZE", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tTotal splash space: %d\n",\r\n(raw_data[2] << 8) | raw_data[1]);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tUsed splash space: %d\n",\r\n(raw_data[4] << 8) | raw_data[3]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ncase REPORT_HOOK_VERSION:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"REPORT_HOOK_VERSION", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nsnprintf(buff, BUFF_SZ, "\tFirmware version: %d.%d\n",\r\nraw_data[1], raw_data[2]);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\ndefault:\r\nsnprintf(buff, BUFF_SZ, "report %s (%d, size=%d)\n",\r\n"<unknown>", report->id, size-1);\r\nhid_debug_event(hdev, buff);\r\nbreak;\r\n}\r\nwake_up_interruptible(&hdev->debug_wait);\r\nkfree(buff);\r\n}\r\nvoid picolcd_init_devfs(struct picolcd_data *data,\r\nstruct hid_report *eeprom_r, struct hid_report *eeprom_w,\r\nstruct hid_report *flash_r, struct hid_report *flash_w,\r\nstruct hid_report *reset)\r\n{\r\nstruct hid_device *hdev = data->hdev;\r\nmutex_init(&data->mutex_flash);\r\nif (reset)\r\ndata->debug_reset = debugfs_create_file("reset", 0600,\r\nhdev->debug_dir, data, &picolcd_debug_reset_fops);\r\nif (eeprom_r || eeprom_w)\r\ndata->debug_eeprom = debugfs_create_file("eeprom",\r\n(eeprom_w ? S_IWUSR : 0) | (eeprom_r ? S_IRUSR : 0),\r\nhdev->debug_dir, data, &picolcd_debug_eeprom_fops);\r\nif (flash_r && flash_r->maxfield == 1 && flash_r->field[0]->report_size == 8)\r\ndata->addr_sz = flash_r->field[0]->report_count - 1;\r\nelse\r\ndata->addr_sz = -1;\r\nif (data->addr_sz == 2 || data->addr_sz == 3) {\r\ndata->debug_flash = debugfs_create_file("flash",\r\n(flash_w ? S_IWUSR : 0) | (flash_r ? S_IRUSR : 0),\r\nhdev->debug_dir, data, &picolcd_debug_flash_fops);\r\n} else if (flash_r || flash_w)\r\nhid_warn(hdev, "Unexpected FLASH access reports, please submit rdesc for review\n");\r\n}\r\nvoid picolcd_exit_devfs(struct picolcd_data *data)\r\n{\r\nstruct dentry *dent;\r\ndent = data->debug_reset;\r\ndata->debug_reset = NULL;\r\ndebugfs_remove(dent);\r\ndent = data->debug_eeprom;\r\ndata->debug_eeprom = NULL;\r\ndebugfs_remove(dent);\r\ndent = data->debug_flash;\r\ndata->debug_flash = NULL;\r\ndebugfs_remove(dent);\r\nmutex_destroy(&data->mutex_flash);\r\n}
