static inline u8 pn533_ext_checksum(u16 value)\r\n{\r\nreturn ~(u8)(((value & 0xFF00) >> 8) + (u8)(value & 0xFF)) + 1;\r\n}\r\nstatic inline u8 pn533_std_checksum(u8 value)\r\n{\r\nreturn ~value + 1;\r\n}\r\nstatic u8 pn533_std_data_checksum(u8 *data, int datalen)\r\n{\r\nu8 sum = 0;\r\nint i;\r\nfor (i = 0; i < datalen; i++)\r\nsum += data[i];\r\nreturn pn533_std_checksum(sum);\r\n}\r\nstatic void pn533_std_tx_frame_init(void *_frame, u8 cmd_code)\r\n{\r\nstruct pn533_std_frame *frame = _frame;\r\nframe->preamble = 0;\r\nframe->start_frame = cpu_to_be16(PN533_STD_FRAME_SOF);\r\nPN533_STD_FRAME_IDENTIFIER(frame) = PN533_STD_FRAME_DIR_OUT;\r\nPN533_FRAME_CMD(frame) = cmd_code;\r\nframe->datalen = 2;\r\n}\r\nstatic void pn533_std_tx_frame_finish(void *_frame)\r\n{\r\nstruct pn533_std_frame *frame = _frame;\r\nframe->datalen_checksum = pn533_std_checksum(frame->datalen);\r\nPN533_STD_FRAME_CHECKSUM(frame) =\r\npn533_std_data_checksum(frame->data, frame->datalen);\r\nPN533_STD_FRAME_POSTAMBLE(frame) = 0;\r\n}\r\nstatic void pn533_std_tx_update_payload_len(void *_frame, int len)\r\n{\r\nstruct pn533_std_frame *frame = _frame;\r\nframe->datalen += len;\r\n}\r\nstatic bool pn533_std_rx_frame_is_valid(void *_frame, struct pn533 *dev)\r\n{\r\nu8 checksum;\r\nstruct pn533_std_frame *stdf = _frame;\r\nif (stdf->start_frame != cpu_to_be16(PN533_STD_FRAME_SOF))\r\nreturn false;\r\nif (likely(!PN533_STD_IS_EXTENDED(stdf))) {\r\ndev->ops->rx_header_len = PN533_STD_FRAME_HEADER_LEN;\r\nchecksum = pn533_std_checksum(stdf->datalen);\r\nif (checksum != stdf->datalen_checksum)\r\nreturn false;\r\nchecksum = pn533_std_data_checksum(stdf->data, stdf->datalen);\r\nif (checksum != PN533_STD_FRAME_CHECKSUM(stdf))\r\nreturn false;\r\n} else {\r\nstruct pn533_ext_frame *eif = _frame;\r\ndev->ops->rx_header_len = PN533_EXT_FRAME_HEADER_LEN;\r\nchecksum = pn533_ext_checksum(be16_to_cpu(eif->datalen));\r\nif (checksum != eif->datalen_checksum)\r\nreturn false;\r\nchecksum = pn533_std_data_checksum(eif->data,\r\nbe16_to_cpu(eif->datalen));\r\nif (checksum != PN533_EXT_FRAME_CHECKSUM(eif))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool pn533_rx_frame_is_ack(void *_frame)\r\n{\r\nstruct pn533_std_frame *frame = _frame;\r\nif (frame->start_frame != cpu_to_be16(PN533_STD_FRAME_SOF))\r\nreturn false;\r\nif (frame->datalen != 0 || frame->datalen_checksum != 0xFF)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline int pn533_std_rx_frame_size(void *frame)\r\n{\r\nstruct pn533_std_frame *f = frame;\r\nif (PN533_STD_IS_EXTENDED(f)) {\r\nstruct pn533_ext_frame *eif = frame;\r\nreturn sizeof(struct pn533_ext_frame)\r\n+ be16_to_cpu(eif->datalen) + PN533_STD_FRAME_TAIL_LEN;\r\n}\r\nreturn sizeof(struct pn533_std_frame) + f->datalen +\r\nPN533_STD_FRAME_TAIL_LEN;\r\n}\r\nstatic u8 pn533_std_get_cmd_code(void *frame)\r\n{\r\nstruct pn533_std_frame *f = frame;\r\nstruct pn533_ext_frame *eif = frame;\r\nif (PN533_STD_IS_EXTENDED(f))\r\nreturn PN533_FRAME_CMD(eif);\r\nelse\r\nreturn PN533_FRAME_CMD(f);\r\n}\r\nbool pn533_rx_frame_is_cmd_response(struct pn533 *dev, void *frame)\r\n{\r\nreturn (dev->ops->get_cmd_code(frame) ==\r\nPN533_CMD_RESPONSE(dev->cmd->code));\r\n}\r\nstatic void pn533_build_cmd_frame(struct pn533 *dev, u8 cmd_code,\r\nstruct sk_buff *skb)\r\n{\r\nint payload_len = skb->len;\r\nstruct pn533_frame_ops *ops = dev->ops;\r\nskb_push(skb, ops->tx_header_len);\r\nskb_put(skb, ops->tx_tail_len);\r\nops->tx_frame_init(skb->data, cmd_code);\r\nops->tx_update_payload_len(skb->data, payload_len);\r\nops->tx_frame_finish(skb->data);\r\n}\r\nstatic int pn533_send_async_complete(struct pn533 *dev)\r\n{\r\nstruct pn533_cmd *cmd = dev->cmd;\r\nint status = cmd->status;\r\nstruct sk_buff *req = cmd->req;\r\nstruct sk_buff *resp = cmd->resp;\r\nint rc;\r\ndev_kfree_skb(req);\r\nif (status < 0) {\r\nrc = cmd->complete_cb(dev, cmd->complete_cb_context,\r\nERR_PTR(status));\r\ndev_kfree_skb(resp);\r\ngoto done;\r\n}\r\nskb_pull(resp, dev->ops->rx_header_len);\r\nskb_trim(resp, resp->len - dev->ops->rx_tail_len);\r\nrc = cmd->complete_cb(dev, cmd->complete_cb_context, resp);\r\ndone:\r\nkfree(cmd);\r\ndev->cmd = NULL;\r\nreturn rc;\r\n}\r\nstatic int __pn533_send_async(struct pn533 *dev, u8 cmd_code,\r\nstruct sk_buff *req,\r\npn533_send_async_complete_t complete_cb,\r\nvoid *complete_cb_context)\r\n{\r\nstruct pn533_cmd *cmd;\r\nint rc = 0;\r\ndev_dbg(dev->dev, "Sending command 0x%x\n", cmd_code);\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->code = cmd_code;\r\ncmd->req = req;\r\ncmd->complete_cb = complete_cb;\r\ncmd->complete_cb_context = complete_cb_context;\r\npn533_build_cmd_frame(dev, cmd_code, req);\r\nmutex_lock(&dev->cmd_lock);\r\nif (!dev->cmd_pending) {\r\nrc = dev->phy_ops->send_frame(dev, req);\r\nif (rc)\r\ngoto error;\r\ndev->cmd_pending = 1;\r\ndev->cmd = cmd;\r\ngoto unlock;\r\n}\r\ndev_dbg(dev->dev, "%s Queueing command 0x%x\n",\r\n__func__, cmd_code);\r\nINIT_LIST_HEAD(&cmd->queue);\r\nlist_add_tail(&cmd->queue, &dev->cmd_queue);\r\ngoto unlock;\r\nerror:\r\nkfree(cmd);\r\nunlock:\r\nmutex_unlock(&dev->cmd_lock);\r\nreturn rc;\r\n}\r\nstatic int pn533_send_data_async(struct pn533 *dev, u8 cmd_code,\r\nstruct sk_buff *req,\r\npn533_send_async_complete_t complete_cb,\r\nvoid *complete_cb_context)\r\n{\r\nint rc;\r\nrc = __pn533_send_async(dev, cmd_code, req, complete_cb,\r\ncomplete_cb_context);\r\nreturn rc;\r\n}\r\nstatic int pn533_send_cmd_async(struct pn533 *dev, u8 cmd_code,\r\nstruct sk_buff *req,\r\npn533_send_async_complete_t complete_cb,\r\nvoid *complete_cb_context)\r\n{\r\nint rc;\r\nrc = __pn533_send_async(dev, cmd_code, req, complete_cb,\r\ncomplete_cb_context);\r\nreturn rc;\r\n}\r\nstatic int pn533_send_cmd_direct_async(struct pn533 *dev, u8 cmd_code,\r\nstruct sk_buff *req,\r\npn533_send_async_complete_t complete_cb,\r\nvoid *complete_cb_context)\r\n{\r\nstruct pn533_cmd *cmd;\r\nint rc;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->code = cmd_code;\r\ncmd->req = req;\r\ncmd->complete_cb = complete_cb;\r\ncmd->complete_cb_context = complete_cb_context;\r\npn533_build_cmd_frame(dev, cmd_code, req);\r\nrc = dev->phy_ops->send_frame(dev, req);\r\nif (rc < 0)\r\nkfree(cmd);\r\nelse\r\ndev->cmd = cmd;\r\nreturn rc;\r\n}\r\nstatic void pn533_wq_cmd_complete(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, cmd_complete_work);\r\nint rc;\r\nrc = pn533_send_async_complete(dev);\r\nif (rc != -EINPROGRESS)\r\nqueue_work(dev->wq, &dev->cmd_work);\r\n}\r\nstatic void pn533_wq_cmd(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, cmd_work);\r\nstruct pn533_cmd *cmd;\r\nint rc;\r\nmutex_lock(&dev->cmd_lock);\r\nif (list_empty(&dev->cmd_queue)) {\r\ndev->cmd_pending = 0;\r\nmutex_unlock(&dev->cmd_lock);\r\nreturn;\r\n}\r\ncmd = list_first_entry(&dev->cmd_queue, struct pn533_cmd, queue);\r\nlist_del(&cmd->queue);\r\nmutex_unlock(&dev->cmd_lock);\r\nrc = dev->phy_ops->send_frame(dev, cmd->req);\r\nif (rc < 0) {\r\ndev_kfree_skb(cmd->req);\r\nkfree(cmd);\r\nreturn;\r\n}\r\ndev->cmd = cmd;\r\n}\r\nstatic int pn533_send_sync_complete(struct pn533 *dev, void *_arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct pn533_sync_cmd_response *arg = _arg;\r\narg->resp = resp;\r\ncomplete(&arg->done);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *pn533_send_cmd_sync(struct pn533 *dev, u8 cmd_code,\r\nstruct sk_buff *req)\r\n{\r\nint rc;\r\nstruct pn533_sync_cmd_response arg;\r\ninit_completion(&arg.done);\r\nrc = pn533_send_cmd_async(dev, cmd_code, req,\r\npn533_send_sync_complete, &arg);\r\nif (rc) {\r\ndev_kfree_skb(req);\r\nreturn ERR_PTR(rc);\r\n}\r\nwait_for_completion(&arg.done);\r\nreturn arg.resp;\r\n}\r\nstatic struct sk_buff *pn533_alloc_skb(struct pn533 *dev, unsigned int size)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(dev->ops->tx_header_len +\r\nsize +\r\ndev->ops->tx_tail_len, GFP_KERNEL);\r\nif (skb)\r\nskb_reserve(skb, dev->ops->tx_header_len);\r\nreturn skb;\r\n}\r\nstatic bool pn533_target_type_a_is_valid(struct pn533_target_type_a *type_a,\r\nint target_data_len)\r\n{\r\nu8 ssd;\r\nu8 platconf;\r\nif (target_data_len < sizeof(struct pn533_target_type_a))\r\nreturn false;\r\nssd = PN533_TYPE_A_SENS_RES_SSD(type_a->sens_res);\r\nplatconf = PN533_TYPE_A_SENS_RES_PLATCONF(type_a->sens_res);\r\nif ((ssd == PN533_TYPE_A_SENS_RES_SSD_JEWEL &&\r\nplatconf != PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL) ||\r\n(ssd != PN533_TYPE_A_SENS_RES_SSD_JEWEL &&\r\nplatconf == PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL))\r\nreturn false;\r\nif (PN533_TYPE_A_SEL_CASCADE(type_a->sel_res) != 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int pn533_target_found_type_a(struct nfc_target *nfc_tgt, u8 *tgt_data,\r\nint tgt_data_len)\r\n{\r\nstruct pn533_target_type_a *tgt_type_a;\r\ntgt_type_a = (struct pn533_target_type_a *)tgt_data;\r\nif (!pn533_target_type_a_is_valid(tgt_type_a, tgt_data_len))\r\nreturn -EPROTO;\r\nswitch (PN533_TYPE_A_SEL_PROT(tgt_type_a->sel_res)) {\r\ncase PN533_TYPE_A_SEL_PROT_MIFARE:\r\nnfc_tgt->supported_protocols = NFC_PROTO_MIFARE_MASK;\r\nbreak;\r\ncase PN533_TYPE_A_SEL_PROT_ISO14443:\r\nnfc_tgt->supported_protocols = NFC_PROTO_ISO14443_MASK;\r\nbreak;\r\ncase PN533_TYPE_A_SEL_PROT_DEP:\r\nnfc_tgt->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\r\nbreak;\r\ncase PN533_TYPE_A_SEL_PROT_ISO14443_DEP:\r\nnfc_tgt->supported_protocols = NFC_PROTO_ISO14443_MASK |\r\nNFC_PROTO_NFC_DEP_MASK;\r\nbreak;\r\n}\r\nnfc_tgt->sens_res = be16_to_cpu(tgt_type_a->sens_res);\r\nnfc_tgt->sel_res = tgt_type_a->sel_res;\r\nnfc_tgt->nfcid1_len = tgt_type_a->nfcid_len;\r\nmemcpy(nfc_tgt->nfcid1, tgt_type_a->nfcid_data, nfc_tgt->nfcid1_len);\r\nreturn 0;\r\n}\r\nstatic bool pn533_target_felica_is_valid(struct pn533_target_felica *felica,\r\nint target_data_len)\r\n{\r\nif (target_data_len < sizeof(struct pn533_target_felica))\r\nreturn false;\r\nif (felica->opcode != PN533_FELICA_OPC_SENSF_RES)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int pn533_target_found_felica(struct nfc_target *nfc_tgt, u8 *tgt_data,\r\nint tgt_data_len)\r\n{\r\nstruct pn533_target_felica *tgt_felica;\r\ntgt_felica = (struct pn533_target_felica *)tgt_data;\r\nif (!pn533_target_felica_is_valid(tgt_felica, tgt_data_len))\r\nreturn -EPROTO;\r\nif ((tgt_felica->nfcid2[0] == PN533_FELICA_SENSF_NFCID2_DEP_B1) &&\r\n(tgt_felica->nfcid2[1] == PN533_FELICA_SENSF_NFCID2_DEP_B2))\r\nnfc_tgt->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\r\nelse\r\nnfc_tgt->supported_protocols = NFC_PROTO_FELICA_MASK;\r\nmemcpy(nfc_tgt->sensf_res, &tgt_felica->opcode, 9);\r\nnfc_tgt->sensf_res_len = 9;\r\nmemcpy(nfc_tgt->nfcid2, tgt_felica->nfcid2, NFC_NFCID2_MAXSIZE);\r\nnfc_tgt->nfcid2_len = NFC_NFCID2_MAXSIZE;\r\nreturn 0;\r\n}\r\nstatic bool pn533_target_jewel_is_valid(struct pn533_target_jewel *jewel,\r\nint target_data_len)\r\n{\r\nu8 ssd;\r\nu8 platconf;\r\nif (target_data_len < sizeof(struct pn533_target_jewel))\r\nreturn false;\r\nssd = PN533_TYPE_A_SENS_RES_SSD(jewel->sens_res);\r\nplatconf = PN533_TYPE_A_SENS_RES_PLATCONF(jewel->sens_res);\r\nif ((ssd == PN533_TYPE_A_SENS_RES_SSD_JEWEL &&\r\nplatconf != PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL) ||\r\n(ssd != PN533_TYPE_A_SENS_RES_SSD_JEWEL &&\r\nplatconf == PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int pn533_target_found_jewel(struct nfc_target *nfc_tgt, u8 *tgt_data,\r\nint tgt_data_len)\r\n{\r\nstruct pn533_target_jewel *tgt_jewel;\r\ntgt_jewel = (struct pn533_target_jewel *)tgt_data;\r\nif (!pn533_target_jewel_is_valid(tgt_jewel, tgt_data_len))\r\nreturn -EPROTO;\r\nnfc_tgt->supported_protocols = NFC_PROTO_JEWEL_MASK;\r\nnfc_tgt->sens_res = be16_to_cpu(tgt_jewel->sens_res);\r\nnfc_tgt->nfcid1_len = 4;\r\nmemcpy(nfc_tgt->nfcid1, tgt_jewel->jewelid, nfc_tgt->nfcid1_len);\r\nreturn 0;\r\n}\r\nstatic bool pn533_target_type_b_is_valid(struct pn533_target_type_b *type_b,\r\nint target_data_len)\r\n{\r\nif (target_data_len < sizeof(struct pn533_target_type_b))\r\nreturn false;\r\nif (type_b->sensb_res.opcode != PN533_TYPE_B_OPC_SENSB_RES)\r\nreturn false;\r\nif (PN533_TYPE_B_PROT_TYPE(type_b->sensb_res.prot_info.fsci_type) &\r\nPN533_TYPE_B_PROT_TYPE_RFU_MASK)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int pn533_target_found_type_b(struct nfc_target *nfc_tgt, u8 *tgt_data,\r\nint tgt_data_len)\r\n{\r\nstruct pn533_target_type_b *tgt_type_b;\r\ntgt_type_b = (struct pn533_target_type_b *)tgt_data;\r\nif (!pn533_target_type_b_is_valid(tgt_type_b, tgt_data_len))\r\nreturn -EPROTO;\r\nnfc_tgt->supported_protocols = NFC_PROTO_ISO14443_B_MASK;\r\nreturn 0;\r\n}\r\nstatic int pn533_target_found(struct pn533 *dev, u8 tg, u8 *tgdata,\r\nint tgdata_len)\r\n{\r\nstruct nfc_target nfc_tgt;\r\nint rc;\r\ndev_dbg(dev->dev, "%s: modulation=%d\n",\r\n__func__, dev->poll_mod_curr);\r\nif (tg != 1)\r\nreturn -EPROTO;\r\nmemset(&nfc_tgt, 0, sizeof(struct nfc_target));\r\nswitch (dev->poll_mod_curr) {\r\ncase PN533_POLL_MOD_106KBPS_A:\r\nrc = pn533_target_found_type_a(&nfc_tgt, tgdata, tgdata_len);\r\nbreak;\r\ncase PN533_POLL_MOD_212KBPS_FELICA:\r\ncase PN533_POLL_MOD_424KBPS_FELICA:\r\nrc = pn533_target_found_felica(&nfc_tgt, tgdata, tgdata_len);\r\nbreak;\r\ncase PN533_POLL_MOD_106KBPS_JEWEL:\r\nrc = pn533_target_found_jewel(&nfc_tgt, tgdata, tgdata_len);\r\nbreak;\r\ncase PN533_POLL_MOD_847KBPS_B:\r\nrc = pn533_target_found_type_b(&nfc_tgt, tgdata, tgdata_len);\r\nbreak;\r\ndefault:\r\nnfc_err(dev->dev,\r\n"Unknown current poll modulation\n");\r\nreturn -EPROTO;\r\n}\r\nif (rc)\r\nreturn rc;\r\nif (!(nfc_tgt.supported_protocols & dev->poll_protocols)) {\r\ndev_dbg(dev->dev,\r\n"The Tg found doesn't have the desired protocol\n");\r\nreturn -EAGAIN;\r\n}\r\ndev_dbg(dev->dev,\r\n"Target found - supported protocols: 0x%x\n",\r\nnfc_tgt.supported_protocols);\r\ndev->tgt_available_prots = nfc_tgt.supported_protocols;\r\npn533_poll_reset_mod_list(dev);\r\nnfc_targets_found(dev->nfc_dev, &nfc_tgt, 1);\r\nreturn 0;\r\n}\r\nstatic inline void pn533_poll_next_mod(struct pn533 *dev)\r\n{\r\ndev->poll_mod_curr = (dev->poll_mod_curr + 1) % dev->poll_mod_count;\r\n}\r\nstatic void pn533_poll_reset_mod_list(struct pn533 *dev)\r\n{\r\ndev->poll_mod_count = 0;\r\n}\r\nstatic void pn533_poll_add_mod(struct pn533 *dev, u8 mod_index)\r\n{\r\ndev->poll_mod_active[dev->poll_mod_count] =\r\n(struct pn533_poll_modulations *)&poll_mod[mod_index];\r\ndev->poll_mod_count++;\r\n}\r\nstatic void pn533_poll_create_mod_list(struct pn533 *dev,\r\nu32 im_protocols, u32 tm_protocols)\r\n{\r\npn533_poll_reset_mod_list(dev);\r\nif ((im_protocols & NFC_PROTO_MIFARE_MASK) ||\r\n(im_protocols & NFC_PROTO_ISO14443_MASK) ||\r\n(im_protocols & NFC_PROTO_NFC_DEP_MASK))\r\npn533_poll_add_mod(dev, PN533_POLL_MOD_106KBPS_A);\r\nif (im_protocols & NFC_PROTO_FELICA_MASK ||\r\nim_protocols & NFC_PROTO_NFC_DEP_MASK) {\r\npn533_poll_add_mod(dev, PN533_POLL_MOD_212KBPS_FELICA);\r\npn533_poll_add_mod(dev, PN533_POLL_MOD_424KBPS_FELICA);\r\n}\r\nif (im_protocols & NFC_PROTO_JEWEL_MASK)\r\npn533_poll_add_mod(dev, PN533_POLL_MOD_106KBPS_JEWEL);\r\nif (im_protocols & NFC_PROTO_ISO14443_B_MASK)\r\npn533_poll_add_mod(dev, PN533_POLL_MOD_847KBPS_B);\r\nif (tm_protocols)\r\npn533_poll_add_mod(dev, PN533_LISTEN_MOD);\r\n}\r\nstatic int pn533_start_poll_complete(struct pn533 *dev, struct sk_buff *resp)\r\n{\r\nu8 nbtg, tg, *tgdata;\r\nint rc, tgdata_len;\r\nif (dev->poll_protocols & NFC_PROTO_NFC_DEP_MASK)\r\ndev->poll_dep = 1;\r\nnbtg = resp->data[0];\r\ntg = resp->data[1];\r\ntgdata = &resp->data[2];\r\ntgdata_len = resp->len - 2;\r\nif (nbtg) {\r\nrc = pn533_target_found(dev, tg, tgdata, tgdata_len);\r\nif (rc == 0)\r\nreturn 0;\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic struct sk_buff *pn533_alloc_poll_tg_frame(struct pn533 *dev)\r\n{\r\nstruct sk_buff *skb;\r\nu8 *felica, *nfcid3, *gb;\r\nu8 *gbytes = dev->gb;\r\nsize_t gbytes_len = dev->gb_len;\r\nu8 felica_params[18] = {0x1, 0xfe,\r\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0xff, 0xff};\r\nu8 mifare_params[6] = {0x1, 0x1,\r\n0x0, 0x0, 0x0,\r\n0x40};\r\nunsigned int skb_len = 36 +\r\ngbytes_len +\r\n1;\r\nskb = pn533_alloc_skb(dev, skb_len);\r\nif (!skb)\r\nreturn NULL;\r\n*skb_put(skb, 1) = PN533_INIT_TARGET_DEP;\r\nmemcpy(skb_put(skb, 6), mifare_params, 6);\r\nfelica = skb_put(skb, 18);\r\nmemcpy(felica, felica_params, 18);\r\nget_random_bytes(felica + 2, 6);\r\nnfcid3 = skb_put(skb, 10);\r\nmemset(nfcid3, 0, 10);\r\nmemcpy(nfcid3, felica, 8);\r\n*skb_put(skb, 1) = gbytes_len;\r\ngb = skb_put(skb, gbytes_len);\r\nmemcpy(gb, gbytes, gbytes_len);\r\n*skb_put(skb, 1) = 0;\r\nreturn skb;\r\n}\r\nstatic int pn533_tm_get_data_complete(struct pn533 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct sk_buff *skb;\r\nu8 status, ret, mi;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (IS_ERR(resp)) {\r\nskb_queue_purge(&dev->resp_q);\r\nreturn PTR_ERR(resp);\r\n}\r\nstatus = resp->data[0];\r\nret = status & PN533_CMD_RET_MASK;\r\nmi = status & PN533_CMD_MI_MASK;\r\nskb_pull(resp, sizeof(status));\r\nif (ret != PN533_CMD_RET_SUCCESS) {\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nskb_queue_tail(&dev->resp_q, resp);\r\nif (mi) {\r\nqueue_work(dev->wq, &dev->mi_tm_rx_work);\r\nreturn -EINPROGRESS;\r\n}\r\nskb = pn533_build_response(dev);\r\nif (!skb) {\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nreturn nfc_tm_data_received(dev->nfc_dev, skb);\r\nerror:\r\nnfc_tm_deactivated(dev->nfc_dev);\r\ndev->tgt_mode = 0;\r\nskb_queue_purge(&dev->resp_q);\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic void pn533_wq_tm_mi_recv(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, mi_tm_rx_work);\r\nstruct sk_buff *skb;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb = pn533_alloc_skb(dev, 0);\r\nif (!skb)\r\nreturn;\r\nrc = pn533_send_cmd_direct_async(dev,\r\nPN533_CMD_TG_GET_DATA,\r\nskb,\r\npn533_tm_get_data_complete,\r\nNULL);\r\nif (rc < 0)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void pn533_wq_tm_mi_send(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, mi_tm_tx_work);\r\nstruct sk_buff *skb;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb = skb_dequeue(&dev->fragment_skb);\r\nif (skb == NULL) {\r\nskb_queue_head_init(&dev->fragment_skb);\r\ngoto error;\r\n}\r\nif (skb_queue_len(&dev->fragment_skb) == 0) {\r\nrc = pn533_send_cmd_direct_async(dev, PN533_CMD_TG_SET_DATA,\r\nskb, pn533_tm_send_complete, NULL);\r\n} else\r\nrc = pn533_send_cmd_direct_async(dev,\r\nPN533_CMD_TG_SET_META_DATA,\r\nskb, pn533_tm_send_complete, NULL);\r\nif (rc == 0)\r\nreturn;\r\ndev_err(dev->dev,\r\n"Error %d when trying to perform set meta data_exchange", rc);\r\ndev_kfree_skb(skb);\r\nerror:\r\ndev->phy_ops->send_ack(dev, GFP_KERNEL);\r\nqueue_work(dev->wq, &dev->cmd_work);\r\n}\r\nstatic void pn533_wq_tg_get_data(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, tg_work);\r\nstruct sk_buff *skb;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb = pn533_alloc_skb(dev, 0);\r\nif (!skb)\r\nreturn;\r\nrc = pn533_send_data_async(dev, PN533_CMD_TG_GET_DATA, skb,\r\npn533_tm_get_data_complete, NULL);\r\nif (rc < 0)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic int pn533_init_target_complete(struct pn533 *dev, struct sk_buff *resp)\r\n{\r\nu8 mode, *cmd, comm_mode = NFC_COMM_PASSIVE, *gb;\r\nsize_t gb_len;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (resp->len < ATR_REQ_GB_OFFSET + 1)\r\nreturn -EINVAL;\r\nmode = resp->data[0];\r\ncmd = &resp->data[1];\r\ndev_dbg(dev->dev, "Target mode 0x%x len %d\n",\r\nmode, resp->len);\r\nif ((mode & PN533_INIT_TARGET_RESP_FRAME_MASK) ==\r\nPN533_INIT_TARGET_RESP_ACTIVE)\r\ncomm_mode = NFC_COMM_ACTIVE;\r\nif ((mode & PN533_INIT_TARGET_RESP_DEP) == 0)\r\nreturn -EOPNOTSUPP;\r\ngb = cmd + ATR_REQ_GB_OFFSET;\r\ngb_len = resp->len - (ATR_REQ_GB_OFFSET + 1);\r\nrc = nfc_tm_activated(dev->nfc_dev, NFC_PROTO_NFC_DEP_MASK,\r\ncomm_mode, gb, gb_len);\r\nif (rc < 0) {\r\nnfc_err(dev->dev,\r\n"Error when signaling target activation\n");\r\nreturn rc;\r\n}\r\ndev->tgt_mode = 1;\r\nqueue_work(dev->wq, &dev->tg_work);\r\nreturn 0;\r\n}\r\nstatic void pn533_listen_mode_timer(unsigned long data)\r\n{\r\nstruct pn533 *dev = (struct pn533 *)data;\r\ndev_dbg(dev->dev, "Listen mode timeout\n");\r\ndev->cancel_listen = 1;\r\npn533_poll_next_mod(dev);\r\nqueue_delayed_work(dev->wq, &dev->poll_work,\r\nmsecs_to_jiffies(PN533_POLL_INTERVAL));\r\n}\r\nstatic int pn533_rf_complete(struct pn533 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nint rc = 0;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nnfc_err(dev->dev, "RF setting error %d\n", rc);\r\nreturn rc;\r\n}\r\nqueue_delayed_work(dev->wq, &dev->poll_work,\r\nmsecs_to_jiffies(PN533_POLL_INTERVAL));\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic void pn533_wq_rf(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, rf_work);\r\nstruct sk_buff *skb;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb = pn533_alloc_skb(dev, 2);\r\nif (!skb)\r\nreturn;\r\n*skb_put(skb, 1) = PN533_CFGITEM_RF_FIELD;\r\n*skb_put(skb, 1) = PN533_CFGITEM_RF_FIELD_AUTO_RFCA;\r\nrc = pn533_send_cmd_async(dev, PN533_CMD_RF_CONFIGURATION, skb,\r\npn533_rf_complete, NULL);\r\nif (rc < 0) {\r\ndev_kfree_skb(skb);\r\nnfc_err(dev->dev, "RF setting error %d\n", rc);\r\n}\r\n}\r\nstatic int pn533_poll_dep_complete(struct pn533 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct pn533_cmd_jump_dep_response *rsp;\r\nstruct nfc_target nfc_target;\r\nu8 target_gt_len;\r\nint rc;\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nrsp = (struct pn533_cmd_jump_dep_response *)resp->data;\r\nrc = rsp->status & PN533_CMD_RET_MASK;\r\nif (rc != PN533_CMD_RET_SUCCESS) {\r\nqueue_work(dev->wq, &dev->rf_work);\r\ndev_kfree_skb(resp);\r\nreturn 0;\r\n}\r\ndev_dbg(dev->dev, "Creating new target");\r\nnfc_target.supported_protocols = NFC_PROTO_NFC_DEP_MASK;\r\nnfc_target.nfcid1_len = 10;\r\nmemcpy(nfc_target.nfcid1, rsp->nfcid3t, nfc_target.nfcid1_len);\r\nrc = nfc_targets_found(dev->nfc_dev, &nfc_target, 1);\r\nif (rc)\r\ngoto error;\r\ndev->tgt_available_prots = 0;\r\ndev->tgt_active_prot = NFC_PROTO_NFC_DEP;\r\ntarget_gt_len = resp->len - 17;\r\nrc = nfc_set_remote_general_bytes(dev->nfc_dev,\r\nrsp->gt, target_gt_len);\r\nif (!rc) {\r\nrc = nfc_dep_link_is_up(dev->nfc_dev,\r\ndev->nfc_dev->targets[0].idx,\r\n0, NFC_RF_INITIATOR);\r\nif (!rc)\r\npn533_poll_reset_mod_list(dev);\r\n}\r\nerror:\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic int pn533_poll_dep(struct nfc_dev *nfc_dev)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nstruct sk_buff *skb;\r\nint rc, skb_len;\r\nu8 *next, nfcid3[NFC_NFCID3_MAXSIZE];\r\nu8 passive_data[PASSIVE_DATA_LEN] = {0x00, 0xff, 0xff, 0x00, 0x3};\r\ndev_dbg(dev->dev, "%s", __func__);\r\nif (!dev->gb) {\r\ndev->gb = nfc_get_local_general_bytes(nfc_dev, &dev->gb_len);\r\nif (!dev->gb || !dev->gb_len) {\r\ndev->poll_dep = 0;\r\nqueue_work(dev->wq, &dev->rf_work);\r\n}\r\n}\r\nskb_len = 3 + dev->gb_len;\r\nskb_len += PASSIVE_DATA_LEN;\r\nskb_len += NFC_NFCID3_MAXSIZE;\r\nnfcid3[0] = 0x1;\r\nnfcid3[1] = 0xfe;\r\nget_random_bytes(nfcid3 + 2, 6);\r\nskb = pn533_alloc_skb(dev, skb_len);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, 1) = 0x01;\r\n*skb_put(skb, 1) = 0x02;\r\nnext = skb_put(skb, 1);\r\n*next = 0;\r\nmemcpy(skb_put(skb, PASSIVE_DATA_LEN), passive_data, PASSIVE_DATA_LEN);\r\n*next |= 1;\r\nmemcpy(skb_put(skb, NFC_NFCID3_MAXSIZE), nfcid3,\r\nNFC_NFCID3_MAXSIZE);\r\n*next |= 2;\r\nmemcpy(skb_put(skb, dev->gb_len), dev->gb, dev->gb_len);\r\n*next |= 4;\r\nrc = pn533_send_cmd_async(dev, PN533_CMD_IN_JUMP_FOR_DEP, skb,\r\npn533_poll_dep_complete, NULL);\r\nif (rc < 0)\r\ndev_kfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic int pn533_poll_complete(struct pn533 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct pn533_poll_modulations *cur_mod;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nnfc_err(dev->dev, "%s Poll complete error %d\n",\r\n__func__, rc);\r\nif (rc == -ENOENT) {\r\nif (dev->poll_mod_count != 0)\r\nreturn rc;\r\ngoto stop_poll;\r\n} else if (rc < 0) {\r\nnfc_err(dev->dev,\r\n"Error %d when running poll\n", rc);\r\ngoto stop_poll;\r\n}\r\n}\r\ncur_mod = dev->poll_mod_active[dev->poll_mod_curr];\r\nif (cur_mod->len == 0) {\r\ndel_timer(&dev->listen_timer);\r\nrc = pn533_init_target_complete(dev, resp);\r\ngoto done;\r\n}\r\nrc = pn533_start_poll_complete(dev, resp);\r\nif (!rc)\r\ngoto done;\r\nif (!dev->poll_mod_count) {\r\ndev_dbg(dev->dev, "Polling has been stopped\n");\r\ngoto done;\r\n}\r\npn533_poll_next_mod(dev);\r\nqueue_work(dev->wq, &dev->rf_work);\r\ndone:\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\nstop_poll:\r\nnfc_err(dev->dev, "Polling operation has been stopped\n");\r\npn533_poll_reset_mod_list(dev);\r\ndev->poll_protocols = 0;\r\nreturn rc;\r\n}\r\nstatic struct sk_buff *pn533_alloc_poll_in_frame(struct pn533 *dev,\r\nstruct pn533_poll_modulations *mod)\r\n{\r\nstruct sk_buff *skb;\r\nskb = pn533_alloc_skb(dev, mod->len);\r\nif (!skb)\r\nreturn NULL;\r\nmemcpy(skb_put(skb, mod->len), &mod->data, mod->len);\r\nreturn skb;\r\n}\r\nstatic int pn533_send_poll_frame(struct pn533 *dev)\r\n{\r\nstruct pn533_poll_modulations *mod;\r\nstruct sk_buff *skb;\r\nint rc;\r\nu8 cmd_code;\r\nmod = dev->poll_mod_active[dev->poll_mod_curr];\r\ndev_dbg(dev->dev, "%s mod len %d\n",\r\n__func__, mod->len);\r\nif ((dev->poll_protocols & NFC_PROTO_NFC_DEP_MASK) && dev->poll_dep) {\r\ndev->poll_dep = 0;\r\nreturn pn533_poll_dep(dev->nfc_dev);\r\n}\r\nif (mod->len == 0) {\r\ncmd_code = PN533_CMD_TG_INIT_AS_TARGET;\r\nskb = pn533_alloc_poll_tg_frame(dev);\r\n} else {\r\ncmd_code = PN533_CMD_IN_LIST_PASSIVE_TARGET;\r\nskb = pn533_alloc_poll_in_frame(dev, mod);\r\n}\r\nif (!skb) {\r\nnfc_err(dev->dev, "Failed to allocate skb\n");\r\nreturn -ENOMEM;\r\n}\r\nrc = pn533_send_cmd_async(dev, cmd_code, skb, pn533_poll_complete,\r\nNULL);\r\nif (rc < 0) {\r\ndev_kfree_skb(skb);\r\nnfc_err(dev->dev, "Polling loop error %d\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void pn533_wq_poll(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, poll_work.work);\r\nstruct pn533_poll_modulations *cur_mod;\r\nint rc;\r\ncur_mod = dev->poll_mod_active[dev->poll_mod_curr];\r\ndev_dbg(dev->dev,\r\n"%s cancel_listen %d modulation len %d\n",\r\n__func__, dev->cancel_listen, cur_mod->len);\r\nif (dev->cancel_listen == 1) {\r\ndev->cancel_listen = 0;\r\ndev->phy_ops->abort_cmd(dev, GFP_ATOMIC);\r\n}\r\nrc = pn533_send_poll_frame(dev);\r\nif (rc)\r\nreturn;\r\nif (cur_mod->len == 0 && dev->poll_mod_count > 1)\r\nmod_timer(&dev->listen_timer, jiffies + PN533_LISTEN_TIME * HZ);\r\n}\r\nstatic int pn533_start_poll(struct nfc_dev *nfc_dev,\r\nu32 im_protocols, u32 tm_protocols)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nstruct pn533_poll_modulations *cur_mod;\r\nu8 rand_mod;\r\nint rc;\r\ndev_dbg(dev->dev,\r\n"%s: im protocols 0x%x tm protocols 0x%x\n",\r\n__func__, im_protocols, tm_protocols);\r\nif (dev->tgt_active_prot) {\r\nnfc_err(dev->dev,\r\n"Cannot poll with a target already activated\n");\r\nreturn -EBUSY;\r\n}\r\nif (dev->tgt_mode) {\r\nnfc_err(dev->dev,\r\n"Cannot poll while already being activated\n");\r\nreturn -EBUSY;\r\n}\r\nif (tm_protocols) {\r\ndev->gb = nfc_get_local_general_bytes(nfc_dev, &dev->gb_len);\r\nif (dev->gb == NULL)\r\ntm_protocols = 0;\r\n}\r\npn533_poll_create_mod_list(dev, im_protocols, tm_protocols);\r\ndev->poll_protocols = im_protocols;\r\ndev->listen_protocols = tm_protocols;\r\nget_random_bytes(&rand_mod, sizeof(rand_mod));\r\nrand_mod %= dev->poll_mod_count;\r\ndev->poll_mod_curr = rand_mod;\r\ncur_mod = dev->poll_mod_active[dev->poll_mod_curr];\r\nrc = pn533_send_poll_frame(dev);\r\nif (!rc && cur_mod->len == 0 && dev->poll_mod_count > 1)\r\nmod_timer(&dev->listen_timer, jiffies + PN533_LISTEN_TIME * HZ);\r\nreturn rc;\r\n}\r\nstatic void pn533_stop_poll(struct nfc_dev *nfc_dev)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\ndel_timer(&dev->listen_timer);\r\nif (!dev->poll_mod_count) {\r\ndev_dbg(dev->dev,\r\n"Polling operation was not running\n");\r\nreturn;\r\n}\r\ndev->phy_ops->abort_cmd(dev, GFP_KERNEL);\r\nflush_delayed_work(&dev->poll_work);\r\npn533_poll_reset_mod_list(dev);\r\n}\r\nstatic int pn533_activate_target_nfcdep(struct pn533 *dev)\r\n{\r\nstruct pn533_cmd_activate_response *rsp;\r\nu16 gt_len;\r\nint rc;\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb = pn533_alloc_skb(dev, sizeof(u8) * 2);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, sizeof(u8)) = 1;\r\n*skb_put(skb, sizeof(u8)) = 0;\r\nresp = pn533_send_cmd_sync(dev, PN533_CMD_IN_ATR, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nrsp = (struct pn533_cmd_activate_response *)resp->data;\r\nrc = rsp->status & PN533_CMD_RET_MASK;\r\nif (rc != PN533_CMD_RET_SUCCESS) {\r\nnfc_err(dev->dev,\r\n"Target activation failed (error 0x%x)\n", rc);\r\ndev_kfree_skb(resp);\r\nreturn -EIO;\r\n}\r\ngt_len = resp->len - 16;\r\nrc = nfc_set_remote_general_bytes(dev->nfc_dev, rsp->gt, gt_len);\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic int pn533_activate_target(struct nfc_dev *nfc_dev,\r\nstruct nfc_target *target, u32 protocol)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nint rc;\r\ndev_dbg(dev->dev, "%s: protocol=%u\n", __func__, protocol);\r\nif (dev->poll_mod_count) {\r\nnfc_err(dev->dev,\r\n"Cannot activate while polling\n");\r\nreturn -EBUSY;\r\n}\r\nif (dev->tgt_active_prot) {\r\nnfc_err(dev->dev,\r\n"There is already an active target\n");\r\nreturn -EBUSY;\r\n}\r\nif (!dev->tgt_available_prots) {\r\nnfc_err(dev->dev,\r\n"There is no available target to activate\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(dev->tgt_available_prots & (1 << protocol))) {\r\nnfc_err(dev->dev,\r\n"Target doesn't support requested proto %u\n",\r\nprotocol);\r\nreturn -EINVAL;\r\n}\r\nif (protocol == NFC_PROTO_NFC_DEP) {\r\nrc = pn533_activate_target_nfcdep(dev);\r\nif (rc) {\r\nnfc_err(dev->dev,\r\n"Activating target with DEP failed %d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\ndev->tgt_active_prot = protocol;\r\ndev->tgt_available_prots = 0;\r\nreturn 0;\r\n}\r\nstatic int pn533_deactivate_target_complete(struct pn533 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nint rc = 0;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\nnfc_err(dev->dev, "Target release error %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = resp->data[0] & PN533_CMD_RET_MASK;\r\nif (rc != PN533_CMD_RET_SUCCESS)\r\nnfc_err(dev->dev,\r\n"Error 0x%x when releasing the target\n", rc);\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic void pn533_deactivate_target(struct nfc_dev *nfc_dev,\r\nstruct nfc_target *target, u8 mode)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nstruct sk_buff *skb;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (!dev->tgt_active_prot) {\r\nnfc_err(dev->dev, "There is no active target\n");\r\nreturn;\r\n}\r\ndev->tgt_active_prot = 0;\r\nskb_queue_purge(&dev->resp_q);\r\nskb = pn533_alloc_skb(dev, sizeof(u8));\r\nif (!skb)\r\nreturn;\r\n*skb_put(skb, 1) = 1;\r\nrc = pn533_send_cmd_async(dev, PN533_CMD_IN_RELEASE, skb,\r\npn533_deactivate_target_complete, NULL);\r\nif (rc < 0) {\r\ndev_kfree_skb(skb);\r\nnfc_err(dev->dev, "Target release error %d\n", rc);\r\n}\r\n}\r\nstatic int pn533_in_dep_link_up_complete(struct pn533 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct pn533_cmd_jump_dep_response *rsp;\r\nu8 target_gt_len;\r\nint rc;\r\nu8 active = *(u8 *)arg;\r\nkfree(arg);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nif (dev->tgt_available_prots &&\r\n!(dev->tgt_available_prots & (1 << NFC_PROTO_NFC_DEP))) {\r\nnfc_err(dev->dev,\r\n"The target does not support DEP\n");\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nrsp = (struct pn533_cmd_jump_dep_response *)resp->data;\r\nrc = rsp->status & PN533_CMD_RET_MASK;\r\nif (rc != PN533_CMD_RET_SUCCESS) {\r\nnfc_err(dev->dev,\r\n"Bringing DEP link up failed (error 0x%x)\n", rc);\r\ngoto error;\r\n}\r\nif (!dev->tgt_available_prots) {\r\nstruct nfc_target nfc_target;\r\ndev_dbg(dev->dev, "Creating new target\n");\r\nnfc_target.supported_protocols = NFC_PROTO_NFC_DEP_MASK;\r\nnfc_target.nfcid1_len = 10;\r\nmemcpy(nfc_target.nfcid1, rsp->nfcid3t, nfc_target.nfcid1_len);\r\nrc = nfc_targets_found(dev->nfc_dev, &nfc_target, 1);\r\nif (rc)\r\ngoto error;\r\ndev->tgt_available_prots = 0;\r\n}\r\ndev->tgt_active_prot = NFC_PROTO_NFC_DEP;\r\ntarget_gt_len = resp->len - 17;\r\nrc = nfc_set_remote_general_bytes(dev->nfc_dev,\r\nrsp->gt, target_gt_len);\r\nif (rc == 0)\r\nrc = nfc_dep_link_is_up(dev->nfc_dev,\r\ndev->nfc_dev->targets[0].idx,\r\n!active, NFC_RF_INITIATOR);\r\nerror:\r\ndev_kfree_skb(resp);\r\nreturn rc;\r\n}\r\nstatic int pn533_dep_link_up(struct nfc_dev *nfc_dev, struct nfc_target *target,\r\nu8 comm_mode, u8 *gb, size_t gb_len)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nstruct sk_buff *skb;\r\nint rc, skb_len;\r\nu8 *next, *arg, nfcid3[NFC_NFCID3_MAXSIZE];\r\nu8 passive_data[PASSIVE_DATA_LEN] = {0x00, 0xff, 0xff, 0x00, 0x3};\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (dev->poll_mod_count) {\r\nnfc_err(dev->dev,\r\n"Cannot bring the DEP link up while polling\n");\r\nreturn -EBUSY;\r\n}\r\nif (dev->tgt_active_prot) {\r\nnfc_err(dev->dev,\r\n"There is already an active target\n");\r\nreturn -EBUSY;\r\n}\r\nskb_len = 3 + gb_len;\r\nskb_len += PASSIVE_DATA_LEN;\r\nskb_len += NFC_NFCID3_MAXSIZE;\r\nif (target && !target->nfcid2_len) {\r\nnfcid3[0] = 0x1;\r\nnfcid3[1] = 0xfe;\r\nget_random_bytes(nfcid3 + 2, 6);\r\n}\r\nskb = pn533_alloc_skb(dev, skb_len);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, 1) = !comm_mode;\r\n*skb_put(skb, 1) = 0x02;\r\nnext = skb_put(skb, 1);\r\n*next = 0;\r\nmemcpy(skb_put(skb, PASSIVE_DATA_LEN), passive_data, PASSIVE_DATA_LEN);\r\n*next |= 1;\r\nif (target && target->nfcid2_len)\r\nmemcpy(skb_put(skb, NFC_NFCID3_MAXSIZE), target->nfcid2,\r\ntarget->nfcid2_len);\r\nelse\r\nmemcpy(skb_put(skb, NFC_NFCID3_MAXSIZE), nfcid3,\r\nNFC_NFCID3_MAXSIZE);\r\n*next |= 2;\r\nif (gb != NULL && gb_len > 0) {\r\nmemcpy(skb_put(skb, gb_len), gb, gb_len);\r\n*next |= 4;\r\n} else {\r\n*next = 0;\r\n}\r\narg = kmalloc(sizeof(*arg), GFP_KERNEL);\r\nif (!arg) {\r\ndev_kfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\n*arg = !comm_mode;\r\npn533_rf_field(dev->nfc_dev, 0);\r\nrc = pn533_send_cmd_async(dev, PN533_CMD_IN_JUMP_FOR_DEP, skb,\r\npn533_in_dep_link_up_complete, arg);\r\nif (rc < 0) {\r\ndev_kfree_skb(skb);\r\nkfree(arg);\r\n}\r\nreturn rc;\r\n}\r\nstatic int pn533_dep_link_down(struct nfc_dev *nfc_dev)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\npn533_poll_reset_mod_list(dev);\r\nif (dev->tgt_mode || dev->tgt_active_prot)\r\ndev->phy_ops->abort_cmd(dev, GFP_KERNEL);\r\ndev->tgt_active_prot = 0;\r\ndev->tgt_mode = 0;\r\nskb_queue_purge(&dev->resp_q);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *pn533_build_response(struct pn533 *dev)\r\n{\r\nstruct sk_buff *skb, *tmp, *t;\r\nunsigned int skb_len = 0, tmp_len = 0;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (skb_queue_empty(&dev->resp_q))\r\nreturn NULL;\r\nif (skb_queue_len(&dev->resp_q) == 1) {\r\nskb = skb_dequeue(&dev->resp_q);\r\ngoto out;\r\n}\r\nskb_queue_walk_safe(&dev->resp_q, tmp, t)\r\nskb_len += tmp->len;\r\ndev_dbg(dev->dev, "%s total length %d\n",\r\n__func__, skb_len);\r\nskb = alloc_skb(skb_len, GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto out;\r\nskb_put(skb, skb_len);\r\nskb_queue_walk_safe(&dev->resp_q, tmp, t) {\r\nmemcpy(skb->data + tmp_len, tmp->data, tmp->len);\r\ntmp_len += tmp->len;\r\n}\r\nout:\r\nskb_queue_purge(&dev->resp_q);\r\nreturn skb;\r\n}\r\nstatic int pn533_data_exchange_complete(struct pn533 *dev, void *_arg,\r\nstruct sk_buff *resp)\r\n{\r\nstruct pn533_data_exchange_arg *arg = _arg;\r\nstruct sk_buff *skb;\r\nint rc = 0;\r\nu8 status, ret, mi;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (IS_ERR(resp)) {\r\nrc = PTR_ERR(resp);\r\ngoto _error;\r\n}\r\nstatus = resp->data[0];\r\nret = status & PN533_CMD_RET_MASK;\r\nmi = status & PN533_CMD_MI_MASK;\r\nskb_pull(resp, sizeof(status));\r\nif (ret != PN533_CMD_RET_SUCCESS) {\r\nnfc_err(dev->dev,\r\n"Exchanging data failed (error 0x%x)\n", ret);\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nskb_queue_tail(&dev->resp_q, resp);\r\nif (mi) {\r\ndev->cmd_complete_mi_arg = arg;\r\nqueue_work(dev->wq, &dev->mi_rx_work);\r\nreturn -EINPROGRESS;\r\n}\r\nif (skb_queue_len(&dev->fragment_skb) > 0) {\r\ndev->cmd_complete_dep_arg = arg;\r\nqueue_work(dev->wq, &dev->mi_tx_work);\r\nreturn -EINPROGRESS;\r\n}\r\nskb = pn533_build_response(dev);\r\nif (!skb) {\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\narg->cb(arg->cb_context, skb, 0);\r\nkfree(arg);\r\nreturn 0;\r\nerror:\r\ndev_kfree_skb(resp);\r\n_error:\r\nskb_queue_purge(&dev->resp_q);\r\narg->cb(arg->cb_context, NULL, rc);\r\nkfree(arg);\r\nreturn rc;\r\n}\r\nvoid pn533_recv_frame(struct pn533 *dev, struct sk_buff *skb, int status)\r\n{\r\nif (!dev->cmd)\r\ngoto sched_wq;\r\ndev->cmd->status = status;\r\nif (status != 0) {\r\ndev_dbg(dev->dev, "%s: Error received: %d\n", __func__, status);\r\ngoto sched_wq;\r\n}\r\nif (skb == NULL) {\r\npr_err("NULL Frame -> link is dead\n");\r\ngoto sched_wq;\r\n}\r\nif (pn533_rx_frame_is_ack(skb->data)) {\r\ndev_dbg(dev->dev, "%s: Received ACK frame\n", __func__);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nprint_hex_dump_debug("PN533 RX: ", DUMP_PREFIX_NONE, 16, 1, skb->data,\r\ndev->ops->rx_frame_size(skb->data), false);\r\nif (!dev->ops->rx_is_frame_valid(skb->data, dev)) {\r\nnfc_err(dev->dev, "Received an invalid frame\n");\r\ndev->cmd->status = -EIO;\r\n} else if (!pn533_rx_frame_is_cmd_response(dev, skb->data)) {\r\nnfc_err(dev->dev, "It it not the response to the last command\n");\r\ndev->cmd->status = -EIO;\r\n}\r\ndev->cmd->resp = skb;\r\nsched_wq:\r\nqueue_work(dev->wq, &dev->cmd_complete_work);\r\n}\r\nstatic int pn533_fill_fragment_skbs(struct pn533 *dev, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *frag;\r\nint frag_size;\r\ndo {\r\nif (skb->len > PN533_CMD_DATAFRAME_MAXLEN)\r\nfrag_size = PN533_CMD_DATAFRAME_MAXLEN;\r\nelse\r\nfrag_size = skb->len;\r\nfrag = pn533_alloc_skb(dev, frag_size);\r\nif (!frag) {\r\nskb_queue_purge(&dev->fragment_skb);\r\nbreak;\r\n}\r\nif (!dev->tgt_mode) {\r\nskb_reserve(frag, 1);\r\nif (frag_size == PN533_CMD_DATAFRAME_MAXLEN)\r\n*skb_push(frag, sizeof(u8)) =\r\n(PN533_CMD_MI_MASK | 1);\r\nelse\r\n*skb_push(frag, sizeof(u8)) = 1;\r\n}\r\nmemcpy(skb_put(frag, frag_size), skb->data, frag_size);\r\nskb_pull(skb, frag_size);\r\nskb_queue_tail(&dev->fragment_skb, frag);\r\n} while (skb->len > 0);\r\ndev_kfree_skb(skb);\r\nreturn skb_queue_len(&dev->fragment_skb);\r\n}\r\nstatic int pn533_transceive(struct nfc_dev *nfc_dev,\r\nstruct nfc_target *target, struct sk_buff *skb,\r\ndata_exchange_cb_t cb, void *cb_context)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nstruct pn533_data_exchange_arg *arg = NULL;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (!dev->tgt_active_prot) {\r\nnfc_err(dev->dev,\r\n"Can't exchange data if there is no active target\n");\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\narg = kmalloc(sizeof(*arg), GFP_KERNEL);\r\nif (!arg) {\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\narg->cb = cb;\r\narg->cb_context = cb_context;\r\nswitch (dev->device_type) {\r\ncase PN533_DEVICE_PASORI:\r\nif (dev->tgt_active_prot == NFC_PROTO_FELICA) {\r\nrc = pn533_send_data_async(dev, PN533_CMD_IN_COMM_THRU,\r\nskb,\r\npn533_data_exchange_complete,\r\narg);\r\nbreak;\r\n}\r\ndefault:\r\nif (skb->len > PN533_CMD_DATAEXCH_DATA_MAXLEN) {\r\nrc = pn533_fill_fragment_skbs(dev, skb);\r\nif (rc <= 0)\r\ngoto error;\r\nskb = skb_dequeue(&dev->fragment_skb);\r\nif (!skb) {\r\nrc = -EIO;\r\ngoto error;\r\n}\r\n} else {\r\n*skb_push(skb, sizeof(u8)) = 1;\r\n}\r\nrc = pn533_send_data_async(dev, PN533_CMD_IN_DATA_EXCHANGE,\r\nskb, pn533_data_exchange_complete,\r\narg);\r\nbreak;\r\n}\r\nif (rc < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nkfree(arg);\r\ndev_kfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic int pn533_tm_send_complete(struct pn533 *dev, void *arg,\r\nstruct sk_buff *resp)\r\n{\r\nu8 status;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nstatus = resp->data[0];\r\nif (skb_queue_len(&dev->fragment_skb) > 0) {\r\nqueue_work(dev->wq, &dev->mi_tm_tx_work);\r\nreturn -EINPROGRESS;\r\n}\r\ndev_kfree_skb(resp);\r\nif (status != 0) {\r\nnfc_tm_deactivated(dev->nfc_dev);\r\ndev->tgt_mode = 0;\r\nreturn 0;\r\n}\r\nqueue_work(dev->wq, &dev->tg_work);\r\nreturn 0;\r\n}\r\nstatic int pn533_tm_send(struct nfc_dev *nfc_dev, struct sk_buff *skb)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nif (skb->len > PN533_CMD_DATAEXCH_DATA_MAXLEN) {\r\nrc = pn533_fill_fragment_skbs(dev, skb);\r\nif (rc <= 0)\r\ngoto error;\r\nskb = skb_dequeue(&dev->fragment_skb);\r\nif (!skb) {\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nrc = pn533_send_data_async(dev, PN533_CMD_TG_SET_META_DATA, skb,\r\npn533_tm_send_complete, NULL);\r\n} else {\r\nrc = pn533_send_data_async(dev, PN533_CMD_TG_SET_DATA, skb,\r\npn533_tm_send_complete, NULL);\r\n}\r\nerror:\r\nif (rc < 0) {\r\ndev_kfree_skb(skb);\r\nskb_queue_purge(&dev->fragment_skb);\r\n}\r\nreturn rc;\r\n}\r\nstatic void pn533_wq_mi_recv(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, mi_rx_work);\r\nstruct sk_buff *skb;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb = pn533_alloc_skb(dev, PN533_CMD_DATAEXCH_HEAD_LEN);\r\nif (!skb)\r\ngoto error;\r\nswitch (dev->device_type) {\r\ncase PN533_DEVICE_PASORI:\r\nif (dev->tgt_active_prot == NFC_PROTO_FELICA) {\r\nrc = pn533_send_cmd_direct_async(dev,\r\nPN533_CMD_IN_COMM_THRU,\r\nskb,\r\npn533_data_exchange_complete,\r\ndev->cmd_complete_mi_arg);\r\nbreak;\r\n}\r\ndefault:\r\n*skb_put(skb, sizeof(u8)) = 1;\r\nrc = pn533_send_cmd_direct_async(dev,\r\nPN533_CMD_IN_DATA_EXCHANGE,\r\nskb,\r\npn533_data_exchange_complete,\r\ndev->cmd_complete_mi_arg);\r\nbreak;\r\n}\r\nif (rc == 0)\r\nreturn;\r\nnfc_err(dev->dev,\r\n"Error %d when trying to perform data_exchange\n", rc);\r\ndev_kfree_skb(skb);\r\nkfree(dev->cmd_complete_mi_arg);\r\nerror:\r\ndev->phy_ops->send_ack(dev, GFP_KERNEL);\r\nqueue_work(dev->wq, &dev->cmd_work);\r\n}\r\nstatic void pn533_wq_mi_send(struct work_struct *work)\r\n{\r\nstruct pn533 *dev = container_of(work, struct pn533, mi_tx_work);\r\nstruct sk_buff *skb;\r\nint rc;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb = skb_dequeue(&dev->fragment_skb);\r\nif (skb == NULL) {\r\nskb_queue_head_init(&dev->fragment_skb);\r\ngoto error;\r\n}\r\nswitch (dev->device_type) {\r\ncase PN533_DEVICE_PASORI:\r\nif (dev->tgt_active_prot != NFC_PROTO_FELICA) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\nrc = pn533_send_cmd_direct_async(dev, PN533_CMD_IN_COMM_THRU,\r\nskb,\r\npn533_data_exchange_complete,\r\ndev->cmd_complete_dep_arg);\r\nbreak;\r\ndefault:\r\nrc = pn533_send_cmd_direct_async(dev,\r\nPN533_CMD_IN_DATA_EXCHANGE,\r\nskb,\r\npn533_data_exchange_complete,\r\ndev->cmd_complete_dep_arg);\r\nbreak;\r\n}\r\nif (rc == 0)\r\nreturn;\r\nnfc_err(dev->dev,\r\n"Error %d when trying to perform data_exchange\n", rc);\r\ndev_kfree_skb(skb);\r\nkfree(dev->cmd_complete_dep_arg);\r\nerror:\r\ndev->phy_ops->send_ack(dev, GFP_KERNEL);\r\nqueue_work(dev->wq, &dev->cmd_work);\r\n}\r\nstatic int pn533_set_configuration(struct pn533 *dev, u8 cfgitem, u8 *cfgdata,\r\nu8 cfgdata_len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nint skb_len;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb_len = sizeof(cfgitem) + cfgdata_len;\r\nskb = pn533_alloc_skb(dev, skb_len);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, sizeof(cfgitem)) = cfgitem;\r\nmemcpy(skb_put(skb, cfgdata_len), cfgdata, cfgdata_len);\r\nresp = pn533_send_cmd_sync(dev, PN533_CMD_RF_CONFIGURATION, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\ndev_kfree_skb(resp);\r\nreturn 0;\r\n}\r\nstatic int pn533_get_firmware_version(struct pn533 *dev,\r\nstruct pn533_fw_version *fv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nskb = pn533_alloc_skb(dev, 0);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nresp = pn533_send_cmd_sync(dev, PN533_CMD_GET_FIRMWARE_VERSION, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\nfv->ic = resp->data[0];\r\nfv->ver = resp->data[1];\r\nfv->rev = resp->data[2];\r\nfv->support = resp->data[3];\r\ndev_kfree_skb(resp);\r\nreturn 0;\r\n}\r\nstatic int pn533_pasori_fw_reset(struct pn533 *dev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\ndev_dbg(dev->dev, "%s\n", __func__);\r\nskb = pn533_alloc_skb(dev, sizeof(u8));\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, sizeof(u8)) = 0x1;\r\nresp = pn533_send_cmd_sync(dev, 0x18, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\ndev_kfree_skb(resp);\r\nreturn 0;\r\n}\r\nstatic int pn533_rf_field(struct nfc_dev *nfc_dev, u8 rf)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nu8 rf_field = !!rf;\r\nint rc;\r\nrf_field |= PN533_CFGITEM_RF_FIELD_AUTO_RFCA;\r\nrc = pn533_set_configuration(dev, PN533_CFGITEM_RF_FIELD,\r\n(u8 *)&rf_field, 1);\r\nif (rc) {\r\nnfc_err(dev->dev, "Error on setting RF field\n");\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic int pn532_sam_configuration(struct nfc_dev *nfc_dev)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nstruct sk_buff *skb;\r\nstruct sk_buff *resp;\r\nskb = pn533_alloc_skb(dev, 1);\r\nif (!skb)\r\nreturn -ENOMEM;\r\n*skb_put(skb, 1) = 0x01;\r\nresp = pn533_send_cmd_sync(dev, PN533_CMD_SAM_CONFIGURATION, skb);\r\nif (IS_ERR(resp))\r\nreturn PTR_ERR(resp);\r\ndev_kfree_skb(resp);\r\nreturn 0;\r\n}\r\nstatic int pn533_dev_up(struct nfc_dev *nfc_dev)\r\n{\r\nstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\r\nif (dev->device_type == PN533_DEVICE_PN532) {\r\nint rc = pn532_sam_configuration(nfc_dev);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn pn533_rf_field(nfc_dev, 1);\r\n}\r\nstatic int pn533_dev_down(struct nfc_dev *nfc_dev)\r\n{\r\nreturn pn533_rf_field(nfc_dev, 0);\r\n}\r\nstatic int pn533_setup(struct pn533 *dev)\r\n{\r\nstruct pn533_config_max_retries max_retries;\r\nstruct pn533_config_timing timing;\r\nu8 pasori_cfg[3] = {0x08, 0x01, 0x08};\r\nint rc;\r\nswitch (dev->device_type) {\r\ncase PN533_DEVICE_STD:\r\ncase PN533_DEVICE_PASORI:\r\ncase PN533_DEVICE_ACR122U:\r\ncase PN533_DEVICE_PN532:\r\nmax_retries.mx_rty_atr = 0x2;\r\nmax_retries.mx_rty_psl = 0x1;\r\nmax_retries.mx_rty_passive_act =\r\nPN533_CONFIG_MAX_RETRIES_NO_RETRY;\r\ntiming.rfu = PN533_CONFIG_TIMING_102;\r\ntiming.atr_res_timeout = PN533_CONFIG_TIMING_102;\r\ntiming.dep_timeout = PN533_CONFIG_TIMING_204;\r\nbreak;\r\ndefault:\r\nnfc_err(dev->dev, "Unknown device type %d\n",\r\ndev->device_type);\r\nreturn -EINVAL;\r\n}\r\nrc = pn533_set_configuration(dev, PN533_CFGITEM_MAX_RETRIES,\r\n(u8 *)&max_retries, sizeof(max_retries));\r\nif (rc) {\r\nnfc_err(dev->dev,\r\n"Error on setting MAX_RETRIES config\n");\r\nreturn rc;\r\n}\r\nrc = pn533_set_configuration(dev, PN533_CFGITEM_TIMING,\r\n(u8 *)&timing, sizeof(timing));\r\nif (rc) {\r\nnfc_err(dev->dev, "Error on setting RF timings\n");\r\nreturn rc;\r\n}\r\nswitch (dev->device_type) {\r\ncase PN533_DEVICE_STD:\r\ncase PN533_DEVICE_PN532:\r\nbreak;\r\ncase PN533_DEVICE_PASORI:\r\npn533_pasori_fw_reset(dev);\r\nrc = pn533_set_configuration(dev, PN533_CFGITEM_PASORI,\r\npasori_cfg, 3);\r\nif (rc) {\r\nnfc_err(dev->dev,\r\n"Error while settings PASORI config\n");\r\nreturn rc;\r\n}\r\npn533_pasori_fw_reset(dev);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstruct pn533 *pn533_register_device(u32 device_type,\r\nu32 protocols,\r\nenum pn533_protocol_type protocol_type,\r\nvoid *phy,\r\nstruct pn533_phy_ops *phy_ops,\r\nstruct pn533_frame_ops *fops,\r\nstruct device *dev,\r\nstruct device *parent)\r\n{\r\nstruct pn533_fw_version fw_ver;\r\nstruct pn533 *priv;\r\nint rc = -ENOMEM;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn ERR_PTR(-ENOMEM);\r\npriv->phy = phy;\r\npriv->phy_ops = phy_ops;\r\npriv->dev = dev;\r\nif (fops != NULL)\r\npriv->ops = fops;\r\nelse\r\npriv->ops = &pn533_std_frame_ops;\r\npriv->protocol_type = protocol_type;\r\npriv->device_type = device_type;\r\nmutex_init(&priv->cmd_lock);\r\nINIT_WORK(&priv->cmd_work, pn533_wq_cmd);\r\nINIT_WORK(&priv->cmd_complete_work, pn533_wq_cmd_complete);\r\nINIT_WORK(&priv->mi_rx_work, pn533_wq_mi_recv);\r\nINIT_WORK(&priv->mi_tx_work, pn533_wq_mi_send);\r\nINIT_WORK(&priv->tg_work, pn533_wq_tg_get_data);\r\nINIT_WORK(&priv->mi_tm_rx_work, pn533_wq_tm_mi_recv);\r\nINIT_WORK(&priv->mi_tm_tx_work, pn533_wq_tm_mi_send);\r\nINIT_DELAYED_WORK(&priv->poll_work, pn533_wq_poll);\r\nINIT_WORK(&priv->rf_work, pn533_wq_rf);\r\npriv->wq = alloc_ordered_workqueue("pn533", 0);\r\nif (priv->wq == NULL)\r\ngoto error;\r\ninit_timer(&priv->listen_timer);\r\npriv->listen_timer.data = (unsigned long) priv;\r\npriv->listen_timer.function = pn533_listen_mode_timer;\r\nskb_queue_head_init(&priv->resp_q);\r\nskb_queue_head_init(&priv->fragment_skb);\r\nINIT_LIST_HEAD(&priv->cmd_queue);\r\nmemset(&fw_ver, 0, sizeof(fw_ver));\r\nrc = pn533_get_firmware_version(priv, &fw_ver);\r\nif (rc < 0)\r\ngoto destroy_wq;\r\nnfc_info(dev, "NXP PN5%02X firmware ver %d.%d now attached\n",\r\nfw_ver.ic, fw_ver.ver, fw_ver.rev);\r\npriv->nfc_dev = nfc_allocate_device(&pn533_nfc_ops, protocols,\r\npriv->ops->tx_header_len +\r\nPN533_CMD_DATAEXCH_HEAD_LEN,\r\npriv->ops->tx_tail_len);\r\nif (!priv->nfc_dev) {\r\nrc = -ENOMEM;\r\ngoto destroy_wq;\r\n}\r\nnfc_set_parent_dev(priv->nfc_dev, parent);\r\nnfc_set_drvdata(priv->nfc_dev, priv);\r\nrc = nfc_register_device(priv->nfc_dev);\r\nif (rc)\r\ngoto free_nfc_dev;\r\nrc = pn533_setup(priv);\r\nif (rc)\r\ngoto unregister_nfc_dev;\r\nreturn priv;\r\nunregister_nfc_dev:\r\nnfc_unregister_device(priv->nfc_dev);\r\nfree_nfc_dev:\r\nnfc_free_device(priv->nfc_dev);\r\ndestroy_wq:\r\ndestroy_workqueue(priv->wq);\r\nerror:\r\nkfree(priv);\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid pn533_unregister_device(struct pn533 *priv)\r\n{\r\nstruct pn533_cmd *cmd, *n;\r\nnfc_unregister_device(priv->nfc_dev);\r\nnfc_free_device(priv->nfc_dev);\r\nflush_delayed_work(&priv->poll_work);\r\ndestroy_workqueue(priv->wq);\r\nskb_queue_purge(&priv->resp_q);\r\ndel_timer(&priv->listen_timer);\r\nlist_for_each_entry_safe(cmd, n, &priv->cmd_queue, queue) {\r\nlist_del(&cmd->queue);\r\nkfree(cmd);\r\n}\r\nkfree(priv);\r\n}
