static void add_channel_to_table(struct st_data_s *st_gdata,\r\nstruct st_proto_s *new_proto)\r\n{\r\npr_info("%s: id %d\n", __func__, new_proto->chnl_id);\r\nst_gdata->list[new_proto->chnl_id] = new_proto;\r\nst_gdata->is_registered[new_proto->chnl_id] = true;\r\n}\r\nstatic void remove_channel_from_table(struct st_data_s *st_gdata,\r\nstruct st_proto_s *proto)\r\n{\r\npr_info("%s: id %d\n", __func__, proto->chnl_id);\r\nst_gdata->is_registered[proto->chnl_id] = false;\r\n}\r\nint st_get_uart_wr_room(struct st_data_s *st_gdata)\r\n{\r\nstruct tty_struct *tty;\r\nif (unlikely(st_gdata == NULL || st_gdata->tty == NULL)) {\r\npr_err("tty unavailable to perform write");\r\nreturn -1;\r\n}\r\ntty = st_gdata->tty;\r\nreturn tty->ops->write_room(tty);\r\n}\r\nint st_int_write(struct st_data_s *st_gdata,\r\nconst unsigned char *data, int count)\r\n{\r\nstruct tty_struct *tty;\r\nif (unlikely(st_gdata == NULL || st_gdata->tty == NULL)) {\r\npr_err("tty unavailable to perform write");\r\nreturn -EINVAL;\r\n}\r\ntty = st_gdata->tty;\r\n#ifdef VERBOSE\r\nprint_hex_dump(KERN_DEBUG, "<out<", DUMP_PREFIX_NONE,\r\n16, 1, data, count, 0);\r\n#endif\r\nreturn tty->ops->write(tty, data, count);\r\n}\r\nstatic void st_send_frame(unsigned char chnl_id, struct st_data_s *st_gdata)\r\n{\r\npr_debug(" %s(prot:%d) ", __func__, chnl_id);\r\nif (unlikely\r\n(st_gdata == NULL || st_gdata->rx_skb == NULL\r\n|| st_gdata->is_registered[chnl_id] == false)) {\r\npr_err("chnl_id %d not registered, no data to send?",\r\nchnl_id);\r\nkfree_skb(st_gdata->rx_skb);\r\nreturn;\r\n}\r\nif (likely(st_gdata->list[chnl_id]->recv != NULL)) {\r\nif (unlikely\r\n(st_gdata->list[chnl_id]->recv\r\n(st_gdata->list[chnl_id]->priv_data, st_gdata->rx_skb)\r\n!= 0)) {\r\npr_err(" proto stack %d's ->recv failed", chnl_id);\r\nkfree_skb(st_gdata->rx_skb);\r\nreturn;\r\n}\r\n} else {\r\npr_err(" proto stack %d's ->recv null", chnl_id);\r\nkfree_skb(st_gdata->rx_skb);\r\n}\r\nreturn;\r\n}\r\nstatic void st_reg_complete(struct st_data_s *st_gdata, int err)\r\n{\r\nunsigned char i = 0;\r\npr_info(" %s ", __func__);\r\nfor (i = 0; i < ST_MAX_CHANNELS; i++) {\r\nif (likely(st_gdata != NULL &&\r\nst_gdata->is_registered[i] == true &&\r\nst_gdata->list[i]->reg_complete_cb != NULL)) {\r\nst_gdata->list[i]->reg_complete_cb\r\n(st_gdata->list[i]->priv_data, err);\r\npr_info("protocol %d's cb sent %d\n", i, err);\r\nif (err) {\r\nst_gdata->is_registered[i] = false;\r\nif (st_gdata->protos_registered)\r\nst_gdata->protos_registered--;\r\n}\r\n}\r\n}\r\n}\r\nstatic inline int st_check_data_len(struct st_data_s *st_gdata,\r\nunsigned char chnl_id, int len)\r\n{\r\nint room = skb_tailroom(st_gdata->rx_skb);\r\npr_debug("len %d room %d", len, room);\r\nif (!len) {\r\nst_send_frame(chnl_id, st_gdata);\r\n} else if (len > room) {\r\npr_err("Data length is too large len %d room %d", len,\r\nroom);\r\nkfree_skb(st_gdata->rx_skb);\r\n} else {\r\nst_gdata->rx_state = ST_W4_DATA;\r\nst_gdata->rx_count = len;\r\nreturn len;\r\n}\r\nst_gdata->rx_state = ST_W4_PACKET_TYPE;\r\nst_gdata->rx_skb = NULL;\r\nst_gdata->rx_count = 0;\r\nst_gdata->rx_chnl = 0;\r\nreturn 0;\r\n}\r\nstatic inline void st_wakeup_ack(struct st_data_s *st_gdata,\r\nunsigned char cmd)\r\n{\r\nstruct sk_buff *waiting_skb;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nwhile ((waiting_skb = skb_dequeue(&st_gdata->tx_waitq)))\r\nskb_queue_tail(&st_gdata->txq, waiting_skb);\r\nst_ll_sleep_state(st_gdata, (unsigned long)cmd);\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nst_tx_wakeup(st_gdata);\r\n}\r\nvoid st_int_recv(void *disc_data,\r\nconst unsigned char *data, long count)\r\n{\r\nchar *ptr;\r\nstruct st_proto_s *proto;\r\nunsigned short payload_len = 0;\r\nint len = 0;\r\nunsigned char type = 0;\r\nunsigned char *plen;\r\nstruct st_data_s *st_gdata = (struct st_data_s *)disc_data;\r\nunsigned long flags;\r\nptr = (char *)data;\r\nif (unlikely(ptr == NULL) || (st_gdata == NULL)) {\r\npr_err(" received null from TTY ");\r\nreturn;\r\n}\r\npr_debug("count %ld rx_state %ld"\r\n"rx_count %ld", count, st_gdata->rx_state,\r\nst_gdata->rx_count);\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nwhile (count) {\r\nif (st_gdata->rx_count) {\r\nlen = min_t(unsigned int, st_gdata->rx_count, count);\r\nmemcpy(skb_put(st_gdata->rx_skb, len), ptr, len);\r\nst_gdata->rx_count -= len;\r\ncount -= len;\r\nptr += len;\r\nif (st_gdata->rx_count)\r\ncontinue;\r\nswitch (st_gdata->rx_state) {\r\ncase ST_W4_DATA:\r\npr_debug("Complete pkt received");\r\nst_send_frame(st_gdata->rx_chnl, st_gdata);\r\nst_gdata->rx_state = ST_W4_PACKET_TYPE;\r\nst_gdata->rx_skb = NULL;\r\ncontinue;\r\ncase ST_W4_HEADER:\r\nproto = st_gdata->list[st_gdata->rx_chnl];\r\nplen =\r\n&st_gdata->rx_skb->data\r\n[proto->offset_len_in_hdr];\r\npr_debug("plen pointing to %x\n", *plen);\r\nif (proto->len_size == 1)\r\npayload_len = *(unsigned char *)plen;\r\nelse if (proto->len_size == 2)\r\npayload_len =\r\n__le16_to_cpu(*(unsigned short *)plen);\r\nelse\r\npr_info("%s: invalid length "\r\n"for id %d\n",\r\n__func__, proto->chnl_id);\r\nst_check_data_len(st_gdata, proto->chnl_id,\r\npayload_len);\r\npr_debug("off %d, pay len %d\n",\r\nproto->offset_len_in_hdr, payload_len);\r\ncontinue;\r\n}\r\n}\r\nswitch (*ptr) {\r\ncase LL_SLEEP_IND:\r\ncase LL_SLEEP_ACK:\r\ncase LL_WAKE_UP_IND:\r\npr_debug("PM packet");\r\nst_ll_sleep_state(st_gdata, *ptr);\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nif (st_ll_getstate(st_gdata) == ST_LL_AWAKE)\r\nst_wakeup_ack(st_gdata, LL_WAKE_UP_ACK);\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nptr++;\r\ncount--;\r\ncontinue;\r\ncase LL_WAKE_UP_ACK:\r\npr_debug("PM packet");\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nst_wakeup_ack(st_gdata, *ptr);\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nptr++;\r\ncount--;\r\ncontinue;\r\ndefault:\r\ntype = *ptr;\r\nif ((type >= ST_MAX_CHANNELS) ||\r\n(st_gdata->list[type] == NULL)) {\r\npr_err("chip/interface misbehavior: "\r\n"dropping frame starting "\r\n"with 0x%02x\n", type);\r\ngoto done;\r\n}\r\nst_gdata->rx_skb = alloc_skb(\r\nst_gdata->list[type]->max_frame_size,\r\nGFP_ATOMIC);\r\nif (st_gdata->rx_skb == NULL) {\r\npr_err("out of memory: dropping\n");\r\ngoto done;\r\n}\r\nskb_reserve(st_gdata->rx_skb,\r\nst_gdata->list[type]->reserve);\r\nst_gdata->rx_skb->cb[0] = type;\r\nst_gdata->rx_skb->cb[1] = 0;\r\nst_gdata->rx_chnl = *ptr;\r\nst_gdata->rx_state = ST_W4_HEADER;\r\nst_gdata->rx_count = st_gdata->list[type]->hdr_len;\r\npr_debug("rx_count %ld\n", st_gdata->rx_count);\r\n};\r\nptr++;\r\ncount--;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\npr_debug("done %s", __func__);\r\nreturn;\r\n}\r\nstatic struct sk_buff *st_int_dequeue(struct st_data_s *st_gdata)\r\n{\r\nstruct sk_buff *returning_skb;\r\npr_debug("%s", __func__);\r\nif (st_gdata->tx_skb != NULL) {\r\nreturning_skb = st_gdata->tx_skb;\r\nst_gdata->tx_skb = NULL;\r\nreturn returning_skb;\r\n}\r\nreturn skb_dequeue(&st_gdata->txq);\r\n}\r\nstatic void st_int_enqueue(struct st_data_s *st_gdata, struct sk_buff *skb)\r\n{\r\nunsigned long flags = 0;\r\npr_debug("%s", __func__);\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nswitch (st_ll_getstate(st_gdata)) {\r\ncase ST_LL_AWAKE:\r\npr_debug("ST LL is AWAKE, sending normally");\r\nskb_queue_tail(&st_gdata->txq, skb);\r\nbreak;\r\ncase ST_LL_ASLEEP_TO_AWAKE:\r\nskb_queue_tail(&st_gdata->tx_waitq, skb);\r\nbreak;\r\ncase ST_LL_AWAKE_TO_ASLEEP:\r\npr_err("ST LL is illegal state(%ld),"\r\n"purging received skb.", st_ll_getstate(st_gdata));\r\nkfree_skb(skb);\r\nbreak;\r\ncase ST_LL_ASLEEP:\r\nskb_queue_tail(&st_gdata->tx_waitq, skb);\r\nst_ll_wakeup(st_gdata);\r\nbreak;\r\ndefault:\r\npr_err("ST LL is illegal state(%ld),"\r\n"purging received skb.", st_ll_getstate(st_gdata));\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\npr_debug("done %s", __func__);\r\nreturn;\r\n}\r\nstatic void work_fn_write_wakeup(struct work_struct *work)\r\n{\r\nstruct st_data_s *st_gdata = container_of(work, struct st_data_s,\r\nwork_write_wakeup);\r\nst_tx_wakeup((void *)st_gdata);\r\n}\r\nvoid st_tx_wakeup(struct st_data_s *st_data)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\npr_debug("%s", __func__);\r\nif (test_and_set_bit(ST_TX_SENDING, &st_data->tx_state)) {\r\npr_debug("ST already sending");\r\nset_bit(ST_TX_WAKEUP, &st_data->tx_state);\r\nreturn;\r\n}\r\ndo {\r\nclear_bit(ST_TX_WAKEUP, &st_data->tx_state);\r\nwhile ((skb = st_int_dequeue(st_data))) {\r\nint len;\r\nspin_lock_irqsave(&st_data->lock, flags);\r\nset_bit(TTY_DO_WRITE_WAKEUP, &st_data->tty->flags);\r\nlen = st_int_write(st_data, skb->data, skb->len);\r\nskb_pull(skb, len);\r\nif (skb->len) {\r\nst_data->tx_skb = skb;\r\nspin_unlock_irqrestore(&st_data->lock, flags);\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\nspin_unlock_irqrestore(&st_data->lock, flags);\r\n}\r\n} while (test_bit(ST_TX_WAKEUP, &st_data->tx_state));\r\nclear_bit(ST_TX_SENDING, &st_data->tx_state);\r\n}\r\nvoid kim_st_list_protocols(struct st_data_s *st_gdata, void *buf)\r\n{\r\nseq_printf(buf, "[%d]\nBT=%c\nFM=%c\nGPS=%c\n",\r\nst_gdata->protos_registered,\r\nst_gdata->is_registered[0x04] == true ? 'R' : 'U',\r\nst_gdata->is_registered[0x08] == true ? 'R' : 'U',\r\nst_gdata->is_registered[0x09] == true ? 'R' : 'U');\r\n}\r\nlong st_register(struct st_proto_s *new_proto)\r\n{\r\nstruct st_data_s *st_gdata;\r\nlong err = 0;\r\nunsigned long flags = 0;\r\nst_kim_ref(&st_gdata, 0);\r\nif (st_gdata == NULL || new_proto == NULL || new_proto->recv == NULL\r\n|| new_proto->reg_complete_cb == NULL) {\r\npr_err("gdata/new_proto/recv or reg_complete_cb not ready");\r\nreturn -EINVAL;\r\n}\r\nif (new_proto->chnl_id >= ST_MAX_CHANNELS) {\r\npr_err("chnl_id %d not supported", new_proto->chnl_id);\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nif (st_gdata->is_registered[new_proto->chnl_id] == true) {\r\npr_err("chnl_id %d already registered", new_proto->chnl_id);\r\nreturn -EALREADY;\r\n}\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nif (test_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state)) {\r\npr_info(" ST_REG_IN_PROGRESS:%d ", new_proto->chnl_id);\r\nadd_channel_to_table(st_gdata, new_proto);\r\nst_gdata->protos_registered++;\r\nnew_proto->write = st_write;\r\nset_bit(ST_REG_PENDING, &st_gdata->st_state);\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nreturn -EINPROGRESS;\r\n} else if (st_gdata->protos_registered == ST_EMPTY) {\r\npr_info(" chnl_id list empty :%d ", new_proto->chnl_id);\r\nset_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state);\r\nst_recv = st_kim_recv;\r\nst_ll_enable(st_gdata);\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nerr = st_kim_start(st_gdata->kim_data);\r\nif (err != 0) {\r\nclear_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state);\r\nif ((st_gdata->protos_registered != ST_EMPTY) &&\r\n(test_bit(ST_REG_PENDING, &st_gdata->st_state))) {\r\npr_err(" KIM failure complete callback ");\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nst_reg_complete(st_gdata, err);\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nclear_bit(ST_REG_PENDING, &st_gdata->st_state);\r\n}\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nclear_bit(ST_REG_IN_PROGRESS, &st_gdata->st_state);\r\nst_recv = st_int_recv;\r\nif ((st_gdata->protos_registered != ST_EMPTY) &&\r\n(test_bit(ST_REG_PENDING, &st_gdata->st_state))) {\r\npr_debug(" call reg complete callback ");\r\nst_reg_complete(st_gdata, 0);\r\n}\r\nclear_bit(ST_REG_PENDING, &st_gdata->st_state);\r\nif (st_gdata->is_registered[new_proto->chnl_id] == true) {\r\npr_err(" proto %d already registered ",\r\nnew_proto->chnl_id);\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nreturn -EALREADY;\r\n}\r\nadd_channel_to_table(st_gdata, new_proto);\r\nst_gdata->protos_registered++;\r\nnew_proto->write = st_write;\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nreturn err;\r\n}\r\nelse {\r\nadd_channel_to_table(st_gdata, new_proto);\r\nst_gdata->protos_registered++;\r\nnew_proto->write = st_write;\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nreturn err;\r\n}\r\n}\r\nlong st_unregister(struct st_proto_s *proto)\r\n{\r\nlong err = 0;\r\nunsigned long flags = 0;\r\nstruct st_data_s *st_gdata;\r\npr_debug("%s: %d ", __func__, proto->chnl_id);\r\nst_kim_ref(&st_gdata, 0);\r\nif (!st_gdata || proto->chnl_id >= ST_MAX_CHANNELS) {\r\npr_err(" chnl_id %d not supported", proto->chnl_id);\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nif (st_gdata->is_registered[proto->chnl_id] == false) {\r\npr_err(" chnl_id %d not registered", proto->chnl_id);\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nif (st_gdata->protos_registered)\r\nst_gdata->protos_registered--;\r\nremove_channel_from_table(st_gdata, proto);\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nif ((st_gdata->protos_registered == ST_EMPTY) &&\r\n(!test_bit(ST_REG_PENDING, &st_gdata->st_state))) {\r\npr_info(" all chnl_ids unregistered ");\r\nif (st_gdata->tty) {\r\ntty_ldisc_flush(st_gdata->tty);\r\nstop_tty(st_gdata->tty);\r\n}\r\nst_kim_stop(st_gdata->kim_data);\r\nst_ll_disable(st_gdata);\r\n}\r\nreturn err;\r\n}\r\nlong st_write(struct sk_buff *skb)\r\n{\r\nstruct st_data_s *st_gdata;\r\nlong len;\r\nst_kim_ref(&st_gdata, 0);\r\nif (unlikely(skb == NULL || st_gdata == NULL\r\n|| st_gdata->tty == NULL)) {\r\npr_err("data/tty unavailable to perform write");\r\nreturn -EINVAL;\r\n}\r\npr_debug("%d to be written", skb->len);\r\nlen = skb->len;\r\nst_int_enqueue(st_gdata, skb);\r\nst_tx_wakeup(st_gdata);\r\nreturn len;\r\n}\r\nstatic int st_tty_open(struct tty_struct *tty)\r\n{\r\nint err = 0;\r\nstruct st_data_s *st_gdata;\r\npr_info("%s ", __func__);\r\nst_kim_ref(&st_gdata, 0);\r\nst_gdata->tty = tty;\r\ntty->disc_data = st_gdata;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\ntty->receive_room = 65536;\r\ntty_ldisc_flush(tty);\r\ntty_driver_flush_buffer(tty);\r\nst_kim_complete(st_gdata->kim_data);\r\npr_debug("done %s", __func__);\r\nreturn err;\r\n}\r\nstatic void st_tty_close(struct tty_struct *tty)\r\n{\r\nunsigned char i = ST_MAX_CHANNELS;\r\nunsigned long flags = 0;\r\nstruct st_data_s *st_gdata = tty->disc_data;\r\npr_info("%s ", __func__);\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nfor (i = ST_BT; i < ST_MAX_CHANNELS; i++) {\r\nif (st_gdata->is_registered[i] == true)\r\npr_err("%d not un-registered", i);\r\nst_gdata->list[i] = NULL;\r\nst_gdata->is_registered[i] = false;\r\n}\r\nst_gdata->protos_registered = 0;\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\nst_kim_complete(st_gdata->kim_data);\r\nst_gdata->tty = NULL;\r\ntty_ldisc_flush(tty);\r\ntty_driver_flush_buffer(tty);\r\nspin_lock_irqsave(&st_gdata->lock, flags);\r\nskb_queue_purge(&st_gdata->txq);\r\nskb_queue_purge(&st_gdata->tx_waitq);\r\nst_gdata->rx_count = 0;\r\nst_gdata->rx_state = ST_W4_PACKET_TYPE;\r\nkfree_skb(st_gdata->rx_skb);\r\nst_gdata->rx_skb = NULL;\r\nspin_unlock_irqrestore(&st_gdata->lock, flags);\r\npr_debug("%s: done ", __func__);\r\n}\r\nstatic void st_tty_receive(struct tty_struct *tty, const unsigned char *data,\r\nchar *tty_flags, int count)\r\n{\r\n#ifdef VERBOSE\r\nprint_hex_dump(KERN_DEBUG, ">in>", DUMP_PREFIX_NONE,\r\n16, 1, data, count, 0);\r\n#endif\r\nst_recv(tty->disc_data, data, count);\r\npr_debug("done %s", __func__);\r\n}\r\nstatic void st_tty_wakeup(struct tty_struct *tty)\r\n{\r\nstruct st_data_s *st_gdata = tty->disc_data;\r\npr_debug("%s ", __func__);\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nschedule_work(&st_gdata->work_write_wakeup);\r\n}\r\nstatic void st_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct st_data_s *st_gdata = tty->disc_data;\r\npr_debug("%s ", __func__);\r\nkfree_skb(st_gdata->tx_skb);\r\nst_gdata->tx_skb = NULL;\r\ntty_driver_flush_buffer(tty);\r\nreturn;\r\n}\r\nint st_core_init(struct st_data_s **core_data)\r\n{\r\nstruct st_data_s *st_gdata;\r\nlong err;\r\nerr = tty_register_ldisc(N_TI_WL, &st_ldisc_ops);\r\nif (err) {\r\npr_err("error registering %d line discipline %ld",\r\nN_TI_WL, err);\r\nreturn err;\r\n}\r\npr_debug("registered n_shared line discipline");\r\nst_gdata = kzalloc(sizeof(struct st_data_s), GFP_KERNEL);\r\nif (!st_gdata) {\r\npr_err("memory allocation failed");\r\nerr = tty_unregister_ldisc(N_TI_WL);\r\nif (err)\r\npr_err("unable to un-register ldisc %ld", err);\r\nerr = -ENOMEM;\r\nreturn err;\r\n}\r\nskb_queue_head_init(&st_gdata->txq);\r\nskb_queue_head_init(&st_gdata->tx_waitq);\r\nspin_lock_init(&st_gdata->lock);\r\nerr = st_ll_init(st_gdata);\r\nif (err) {\r\npr_err("error during st_ll initialization(%ld)", err);\r\nkfree(st_gdata);\r\nerr = tty_unregister_ldisc(N_TI_WL);\r\nif (err)\r\npr_err("unable to un-register ldisc");\r\nreturn err;\r\n}\r\nINIT_WORK(&st_gdata->work_write_wakeup, work_fn_write_wakeup);\r\n*core_data = st_gdata;\r\nreturn 0;\r\n}\r\nvoid st_core_exit(struct st_data_s *st_gdata)\r\n{\r\nlong err;\r\nerr = st_ll_deinit(st_gdata);\r\nif (err)\r\npr_err("error during deinit of ST LL %ld", err);\r\nif (st_gdata != NULL) {\r\nskb_queue_purge(&st_gdata->txq);\r\nskb_queue_purge(&st_gdata->tx_waitq);\r\nkfree_skb(st_gdata->rx_skb);\r\nkfree_skb(st_gdata->tx_skb);\r\nerr = tty_unregister_ldisc(N_TI_WL);\r\nif (err)\r\npr_err("unable to un-register ldisc %ld", err);\r\nkfree(st_gdata);\r\n}\r\n}
