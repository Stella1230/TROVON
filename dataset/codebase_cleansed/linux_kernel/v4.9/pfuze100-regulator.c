static int pfuze100_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nstruct pfuze_chip *pfuze100 = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nunsigned int ramp_bits;\r\nint ret;\r\nif (id < PFUZE100_SWBST) {\r\nramp_delay = 12500 / ramp_delay;\r\nramp_bits = (ramp_delay >> 1) - (ramp_delay >> 3);\r\nret = regmap_update_bits(pfuze100->regmap,\r\nrdev->desc->vsel_reg + 4,\r\n0xc0, ramp_bits << 6);\r\nif (ret < 0)\r\ndev_err(pfuze100->dev, "ramp failed, err %d\n", ret);\r\n} else\r\nret = -EACCES;\r\nreturn ret;\r\n}\r\nstatic int pfuze_parse_regulators_dt(struct pfuze_chip *chip)\r\n{\r\nstruct device *dev = chip->dev;\r\nstruct device_node *np, *parent;\r\nint ret;\r\nnp = of_node_get(dev->of_node);\r\nif (!np)\r\nreturn -EINVAL;\r\nparent = of_get_child_by_name(np, "regulators");\r\nif (!parent) {\r\ndev_err(dev, "regulators node not found\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (chip->chip_id) {\r\ncase PFUZE3000:\r\npfuze_matches = pfuze3000_matches;\r\nret = of_regulator_match(dev, parent, pfuze3000_matches,\r\nARRAY_SIZE(pfuze3000_matches));\r\nbreak;\r\ncase PFUZE200:\r\npfuze_matches = pfuze200_matches;\r\nret = of_regulator_match(dev, parent, pfuze200_matches,\r\nARRAY_SIZE(pfuze200_matches));\r\nbreak;\r\ncase PFUZE100:\r\ndefault:\r\npfuze_matches = pfuze100_matches;\r\nret = of_regulator_match(dev, parent, pfuze100_matches,\r\nARRAY_SIZE(pfuze100_matches));\r\nbreak;\r\n}\r\nof_node_put(parent);\r\nif (ret < 0) {\r\ndev_err(dev, "Error parsing regulator init data: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct regulator_init_data *match_init_data(int index)\r\n{\r\nreturn pfuze_matches[index].init_data;\r\n}\r\nstatic inline struct device_node *match_of_node(int index)\r\n{\r\nreturn pfuze_matches[index].of_node;\r\n}\r\nstatic int pfuze_parse_regulators_dt(struct pfuze_chip *chip)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline struct regulator_init_data *match_init_data(int index)\r\n{\r\nreturn NULL;\r\n}\r\nstatic inline struct device_node *match_of_node(int index)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int pfuze_identify(struct pfuze_chip *pfuze_chip)\r\n{\r\nunsigned int value;\r\nint ret;\r\nret = regmap_read(pfuze_chip->regmap, PFUZE100_DEVICEID, &value);\r\nif (ret)\r\nreturn ret;\r\nif (((value & 0x0f) == 0x8) && (pfuze_chip->chip_id == PFUZE100)) {\r\ndev_info(pfuze_chip->dev, "Assuming misprogrammed ID=0x8");\r\n} else if ((value & 0x0f) != pfuze_chip->chip_id &&\r\n(value & 0xf0) >> 4 != pfuze_chip->chip_id) {\r\ndev_warn(pfuze_chip->dev, "Illegal ID: %x\n", value);\r\nreturn -ENODEV;\r\n}\r\nret = regmap_read(pfuze_chip->regmap, PFUZE100_REVID, &value);\r\nif (ret)\r\nreturn ret;\r\ndev_info(pfuze_chip->dev,\r\n"Full layer: %x, Metal layer: %x\n",\r\n(value & 0xf0) >> 4, value & 0x0f);\r\nret = regmap_read(pfuze_chip->regmap, PFUZE100_FABID, &value);\r\nif (ret)\r\nreturn ret;\r\ndev_info(pfuze_chip->dev, "FAB: %x, FIN: %x\n",\r\n(value & 0xc) >> 2, value & 0x3);\r\nreturn 0;\r\n}\r\nstatic int pfuze100_regulator_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pfuze_chip *pfuze_chip;\r\nstruct pfuze_regulator_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct regulator_config config = { };\r\nint i, ret;\r\nconst struct of_device_id *match;\r\nu32 regulator_num;\r\nu32 sw_check_start, sw_check_end, sw_hi = 0x40;\r\npfuze_chip = devm_kzalloc(&client->dev, sizeof(*pfuze_chip),\r\nGFP_KERNEL);\r\nif (!pfuze_chip)\r\nreturn -ENOMEM;\r\nif (client->dev.of_node) {\r\nmatch = of_match_device(of_match_ptr(pfuze_dt_ids),\r\n&client->dev);\r\nif (!match) {\r\ndev_err(&client->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\npfuze_chip->chip_id = (int)(long)match->data;\r\n} else if (id) {\r\npfuze_chip->chip_id = id->driver_data;\r\n} else {\r\ndev_err(&client->dev, "No dts match or id table match found\n");\r\nreturn -ENODEV;\r\n}\r\ni2c_set_clientdata(client, pfuze_chip);\r\npfuze_chip->dev = &client->dev;\r\npfuze_chip->regmap = devm_regmap_init_i2c(client, &pfuze_regmap_config);\r\nif (IS_ERR(pfuze_chip->regmap)) {\r\nret = PTR_ERR(pfuze_chip->regmap);\r\ndev_err(&client->dev,\r\n"regmap allocation failed with err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = pfuze_identify(pfuze_chip);\r\nif (ret) {\r\ndev_err(&client->dev, "unrecognized pfuze chip ID!\n");\r\nreturn ret;\r\n}\r\nswitch (pfuze_chip->chip_id) {\r\ncase PFUZE3000:\r\npfuze_chip->pfuze_regulators = pfuze3000_regulators;\r\nregulator_num = ARRAY_SIZE(pfuze3000_regulators);\r\nsw_check_start = PFUZE3000_SW2;\r\nsw_check_end = PFUZE3000_SW2;\r\nsw_hi = 1 << 3;\r\nbreak;\r\ncase PFUZE200:\r\npfuze_chip->pfuze_regulators = pfuze200_regulators;\r\nregulator_num = ARRAY_SIZE(pfuze200_regulators);\r\nsw_check_start = PFUZE200_SW2;\r\nsw_check_end = PFUZE200_SW3B;\r\nbreak;\r\ncase PFUZE100:\r\ndefault:\r\npfuze_chip->pfuze_regulators = pfuze100_regulators;\r\nregulator_num = ARRAY_SIZE(pfuze100_regulators);\r\nsw_check_start = PFUZE100_SW2;\r\nsw_check_end = PFUZE100_SW4;\r\nbreak;\r\n}\r\ndev_info(&client->dev, "pfuze%s found.\n",\r\n(pfuze_chip->chip_id == PFUZE100) ? "100" :\r\n((pfuze_chip->chip_id == PFUZE200) ? "200" : "3000"));\r\nmemcpy(pfuze_chip->regulator_descs, pfuze_chip->pfuze_regulators,\r\nsizeof(pfuze_chip->regulator_descs));\r\nret = pfuze_parse_regulators_dt(pfuze_chip);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < regulator_num; i++) {\r\nstruct regulator_init_data *init_data;\r\nstruct regulator_desc *desc;\r\nint val;\r\ndesc = &pfuze_chip->regulator_descs[i].desc;\r\nif (pdata)\r\ninit_data = pdata->init_data[i];\r\nelse\r\ninit_data = match_init_data(i);\r\nif (i >= sw_check_start && i <= sw_check_end) {\r\nregmap_read(pfuze_chip->regmap, desc->vsel_reg, &val);\r\nif (val & sw_hi) {\r\nif (pfuze_chip->chip_id == PFUZE3000) {\r\ndesc->volt_table = pfuze3000_sw2hi;\r\ndesc->n_voltages = ARRAY_SIZE(pfuze3000_sw2hi);\r\n} else {\r\ndesc->min_uV = 800000;\r\ndesc->uV_step = 50000;\r\ndesc->n_voltages = 51;\r\n}\r\n}\r\n}\r\nconfig.dev = &client->dev;\r\nconfig.init_data = init_data;\r\nconfig.driver_data = pfuze_chip;\r\nconfig.of_node = match_of_node(i);\r\nconfig.ena_gpio = -EINVAL;\r\npfuze_chip->regulators[i] =\r\ndevm_regulator_register(&client->dev, desc, &config);\r\nif (IS_ERR(pfuze_chip->regulators[i])) {\r\ndev_err(&client->dev, "register regulator%s failed\n",\r\npfuze_chip->pfuze_regulators[i].desc.name);\r\nreturn PTR_ERR(pfuze_chip->regulators[i]);\r\n}\r\n}\r\nreturn 0;\r\n}
