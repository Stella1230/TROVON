struct ipx_route *ipxrtr_lookup(__be32 net)\r\n{\r\nstruct ipx_route *r;\r\nread_lock_bh(&ipx_routes_lock);\r\nlist_for_each_entry(r, &ipx_routes, node)\r\nif (r->ir_net == net) {\r\nipxrtr_hold(r);\r\ngoto unlock;\r\n}\r\nr = NULL;\r\nunlock:\r\nread_unlock_bh(&ipx_routes_lock);\r\nreturn r;\r\n}\r\nint ipxrtr_add_route(__be32 network, struct ipx_interface *intrfc,\r\nunsigned char *node)\r\n{\r\nstruct ipx_route *rt;\r\nint rc;\r\nrt = ipxrtr_lookup(network);\r\nif (!rt) {\r\nrt = kmalloc(sizeof(*rt), GFP_ATOMIC);\r\nrc = -EAGAIN;\r\nif (!rt)\r\ngoto out;\r\natomic_set(&rt->refcnt, 1);\r\nipxrtr_hold(rt);\r\nwrite_lock_bh(&ipx_routes_lock);\r\nlist_add(&rt->node, &ipx_routes);\r\nwrite_unlock_bh(&ipx_routes_lock);\r\n} else {\r\nrc = -EEXIST;\r\nif (intrfc == ipx_internal_net)\r\ngoto out_put;\r\n}\r\nrt->ir_net = network;\r\nrt->ir_intrfc = intrfc;\r\nif (!node) {\r\nmemset(rt->ir_router_node, '\0', IPX_NODE_LEN);\r\nrt->ir_routed = 0;\r\n} else {\r\nmemcpy(rt->ir_router_node, node, IPX_NODE_LEN);\r\nrt->ir_routed = 1;\r\n}\r\nrc = 0;\r\nout_put:\r\nipxrtr_put(rt);\r\nout:\r\nreturn rc;\r\n}\r\nvoid ipxrtr_del_routes(struct ipx_interface *intrfc)\r\n{\r\nstruct ipx_route *r, *tmp;\r\nwrite_lock_bh(&ipx_routes_lock);\r\nlist_for_each_entry_safe(r, tmp, &ipx_routes, node)\r\nif (r->ir_intrfc == intrfc) {\r\nlist_del(&r->node);\r\nipxrtr_put(r);\r\n}\r\nwrite_unlock_bh(&ipx_routes_lock);\r\n}\r\nstatic int ipxrtr_create(struct ipx_route_definition *rd)\r\n{\r\nstruct ipx_interface *intrfc;\r\nint rc = -ENETUNREACH;\r\nintrfc = ipxitf_find_using_net(rd->ipx_router_network);\r\nif (!intrfc)\r\ngoto out;\r\nrc = ipxrtr_add_route(rd->ipx_network, intrfc, rd->ipx_router_node);\r\nipxitf_put(intrfc);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ipxrtr_delete(__be32 net)\r\n{\r\nstruct ipx_route *r, *tmp;\r\nint rc;\r\nwrite_lock_bh(&ipx_routes_lock);\r\nlist_for_each_entry_safe(r, tmp, &ipx_routes, node)\r\nif (r->ir_net == net) {\r\nrc = -EPERM;\r\nif (!r->ir_routed)\r\ngoto out;\r\nlist_del(&r->node);\r\nipxrtr_put(r);\r\nrc = 0;\r\ngoto out;\r\n}\r\nrc = -ENOENT;\r\nout:\r\nwrite_unlock_bh(&ipx_routes_lock);\r\nreturn rc;\r\n}\r\nint ipxrtr_route_skb(struct sk_buff *skb)\r\n{\r\nstruct ipxhdr *ipx = ipx_hdr(skb);\r\nstruct ipx_route *r = ipxrtr_lookup(IPX_SKB_CB(skb)->ipx_dest_net);\r\nif (!r) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nipxitf_hold(r->ir_intrfc);\r\nipxitf_send(r->ir_intrfc, skb, r->ir_routed ?\r\nr->ir_router_node : ipx->ipx_dest.node);\r\nipxitf_put(r->ir_intrfc);\r\nipxrtr_put(r);\r\nreturn 0;\r\n}\r\nint ipxrtr_route_packet(struct sock *sk, struct sockaddr_ipx *usipx,\r\nstruct msghdr *msg, size_t len, int noblock)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ipx_sock *ipxs = ipx_sk(sk);\r\nstruct ipx_interface *intrfc;\r\nstruct ipxhdr *ipx;\r\nsize_t size;\r\nint ipx_offset;\r\nstruct ipx_route *rt = NULL;\r\nint rc;\r\nif (!usipx->sipx_network && ipx_primary_net) {\r\nusipx->sipx_network = ipx_primary_net->if_netnum;\r\nintrfc = ipx_primary_net;\r\n} else {\r\nrt = ipxrtr_lookup(usipx->sipx_network);\r\nrc = -ENETUNREACH;\r\nif (!rt)\r\ngoto out;\r\nintrfc = rt->ir_intrfc;\r\n}\r\nipxitf_hold(intrfc);\r\nipx_offset = intrfc->if_ipx_offset;\r\nsize = sizeof(struct ipxhdr) + len + ipx_offset;\r\nskb = sock_alloc_send_skb(sk, size, noblock, &rc);\r\nif (!skb)\r\ngoto out_put;\r\nskb_reserve(skb, ipx_offset);\r\nskb->sk = sk;\r\nskb_reset_network_header(skb);\r\nskb_reset_transport_header(skb);\r\nskb_put(skb, sizeof(struct ipxhdr));\r\nipx = ipx_hdr(skb);\r\nipx->ipx_pktsize = htons(len + sizeof(struct ipxhdr));\r\nIPX_SKB_CB(skb)->ipx_tctrl = 0;\r\nipx->ipx_type = usipx->sipx_type;\r\nIPX_SKB_CB(skb)->last_hop.index = -1;\r\n#ifdef CONFIG_IPX_INTERN\r\nIPX_SKB_CB(skb)->ipx_source_net = ipxs->intrfc->if_netnum;\r\nmemcpy(ipx->ipx_source.node, ipxs->node, IPX_NODE_LEN);\r\n#else\r\nrc = ntohs(ipxs->port);\r\nif (rc == 0x453 || rc == 0x452) {\r\nIPX_SKB_CB(skb)->ipx_source_net = intrfc->if_netnum;\r\nmemcpy(ipx->ipx_source.node, intrfc->if_node, IPX_NODE_LEN);\r\n} else {\r\nIPX_SKB_CB(skb)->ipx_source_net = ipxs->intrfc->if_netnum;\r\nmemcpy(ipx->ipx_source.node, ipxs->intrfc->if_node,\r\nIPX_NODE_LEN);\r\n}\r\n#endif\r\nipx->ipx_source.sock = ipxs->port;\r\nIPX_SKB_CB(skb)->ipx_dest_net = usipx->sipx_network;\r\nmemcpy(ipx->ipx_dest.node, usipx->sipx_node, IPX_NODE_LEN);\r\nipx->ipx_dest.sock = usipx->sipx_port;\r\nrc = memcpy_from_msg(skb_put(skb, len), msg, len);\r\nif (rc) {\r\nkfree_skb(skb);\r\ngoto out_put;\r\n}\r\nif (sk->sk_no_check_tx ||\r\nintrfc->if_dlink_type == htons(IPX_FRAME_8023))\r\nipx->ipx_checksum = htons(0xFFFF);\r\nelse\r\nipx->ipx_checksum = ipx_cksum(ipx, len + sizeof(struct ipxhdr));\r\nrc = ipxitf_send(intrfc, skb, (rt && rt->ir_routed) ?\r\nrt->ir_router_node : ipx->ipx_dest.node);\r\nout_put:\r\nipxitf_put(intrfc);\r\nif (rt)\r\nipxrtr_put(rt);\r\nout:\r\nreturn rc;\r\n}\r\nint ipxrtr_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nstruct rtentry rt;\r\nstruct sockaddr_ipx *sg, *st;\r\nint rc = -EFAULT;\r\nif (copy_from_user(&rt, arg, sizeof(rt)))\r\ngoto out;\r\nsg = (struct sockaddr_ipx *)&rt.rt_gateway;\r\nst = (struct sockaddr_ipx *)&rt.rt_dst;\r\nrc = -EINVAL;\r\nif (!(rt.rt_flags & RTF_GATEWAY) ||\r\nsg->sipx_family != AF_IPX ||\r\nst->sipx_family != AF_IPX)\r\ngoto out;\r\nswitch (cmd) {\r\ncase SIOCDELRT:\r\nrc = ipxrtr_delete(st->sipx_network);\r\nbreak;\r\ncase SIOCADDRT: {\r\nstruct ipx_route_definition f;\r\nf.ipx_network = st->sipx_network;\r\nf.ipx_router_network = sg->sipx_network;\r\nmemcpy(f.ipx_router_node, sg->sipx_node, IPX_NODE_LEN);\r\nrc = ipxrtr_create(&f);\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}
