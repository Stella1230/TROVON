static unsigned int a21_wdt_get_bootstatus(struct a21_wdt_drv *drv)\r\n{\r\nint reset = 0;\r\nreset |= gpio_get_value(drv->gpios[GPIO_WD_RST0]) ? (1 << 0) : 0;\r\nreset |= gpio_get_value(drv->gpios[GPIO_WD_RST1]) ? (1 << 1) : 0;\r\nreset |= gpio_get_value(drv->gpios[GPIO_WD_RST2]) ? (1 << 2) : 0;\r\nreturn reset;\r\n}\r\nstatic int a21_wdt_start(struct watchdog_device *wdt)\r\n{\r\nstruct a21_wdt_drv *drv = watchdog_get_drvdata(wdt);\r\nmutex_lock(&drv->lock);\r\ngpio_set_value(drv->gpios[GPIO_WD_ENAB], 1);\r\nmutex_unlock(&drv->lock);\r\nreturn 0;\r\n}\r\nstatic int a21_wdt_stop(struct watchdog_device *wdt)\r\n{\r\nstruct a21_wdt_drv *drv = watchdog_get_drvdata(wdt);\r\nmutex_lock(&drv->lock);\r\ngpio_set_value(drv->gpios[GPIO_WD_ENAB], 0);\r\nmutex_unlock(&drv->lock);\r\nreturn 0;\r\n}\r\nstatic int a21_wdt_ping(struct watchdog_device *wdt)\r\n{\r\nstruct a21_wdt_drv *drv = watchdog_get_drvdata(wdt);\r\nmutex_lock(&drv->lock);\r\ngpio_set_value(drv->gpios[GPIO_WD_TRIG], 0);\r\nndelay(10);\r\ngpio_set_value(drv->gpios[GPIO_WD_TRIG], 1);\r\nmutex_unlock(&drv->lock);\r\nreturn 0;\r\n}\r\nstatic int a21_wdt_set_timeout(struct watchdog_device *wdt,\r\nunsigned int timeout)\r\n{\r\nstruct a21_wdt_drv *drv = watchdog_get_drvdata(wdt);\r\nif (timeout != 1 && timeout != 30) {\r\ndev_err(wdt->parent, "Only 1 and 30 allowed as timeout\n");\r\nreturn -EINVAL;\r\n}\r\nif (timeout == 30 && wdt->timeout == 1) {\r\ndev_err(wdt->parent,\r\n"Transition from fast to slow mode not allowed\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&drv->lock);\r\nif (timeout == 1)\r\ngpio_set_value(drv->gpios[GPIO_WD_FAST], 1);\r\nelse\r\ngpio_set_value(drv->gpios[GPIO_WD_FAST], 0);\r\nwdt->timeout = timeout;\r\nmutex_unlock(&drv->lock);\r\nreturn 0;\r\n}\r\nstatic int a21_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node;\r\nstruct a21_wdt_drv *drv;\r\nunsigned int reset = 0;\r\nint num_gpios;\r\nint ret;\r\nint i;\r\ndrv = devm_kzalloc(&pdev->dev, sizeof(struct a21_wdt_drv), GFP_KERNEL);\r\nif (!drv)\r\nreturn -ENOMEM;\r\nnode = pdev->dev.of_node;\r\nnum_gpios = of_gpio_count(node);\r\nif (num_gpios != NUM_GPIOS) {\r\ndev_err(&pdev->dev, "gpios DT property wrong, got %d want %d",\r\nnum_gpios, NUM_GPIOS);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < num_gpios; i++) {\r\nint val;\r\nval = of_get_gpio(node, i);\r\nif (val < 0)\r\nreturn val;\r\ndrv->gpios[i] = val;\r\n}\r\nfor (i = 0; i < num_gpios; i++) {\r\nret = devm_gpio_request(&pdev->dev, drv->gpios[i],\r\n"MEN A21 Watchdog");\r\nif (ret)\r\nreturn ret;\r\nif (i < GPIO_WD_RST0)\r\nret = gpio_direction_output(drv->gpios[i],\r\ngpio_get_value(drv->gpios[i]));\r\nelse\r\nret = gpio_direction_input(drv->gpios[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmutex_init(&drv->lock);\r\nwatchdog_init_timeout(&a21_wdt, 30, &pdev->dev);\r\nwatchdog_set_nowayout(&a21_wdt, nowayout);\r\nwatchdog_set_drvdata(&a21_wdt, drv);\r\na21_wdt.parent = &pdev->dev;\r\nreset = a21_wdt_get_bootstatus(drv);\r\nif (reset == 2)\r\na21_wdt.bootstatus |= WDIOF_EXTERN1;\r\nelse if (reset == 4)\r\na21_wdt.bootstatus |= WDIOF_CARDRESET;\r\nelse if (reset == 5)\r\na21_wdt.bootstatus |= WDIOF_POWERUNDER;\r\nelse if (reset == 7)\r\na21_wdt.bootstatus |= WDIOF_EXTERN2;\r\ndrv->wdt = a21_wdt;\r\ndev_set_drvdata(&pdev->dev, drv);\r\nret = watchdog_register_device(&a21_wdt);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot register watchdog device\n");\r\ngoto err_register_wd;\r\n}\r\ndev_info(&pdev->dev, "MEN A21 watchdog timer driver enabled\n");\r\nreturn 0;\r\nerr_register_wd:\r\nmutex_destroy(&drv->lock);\r\nreturn ret;\r\n}\r\nstatic int a21_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct a21_wdt_drv *drv = dev_get_drvdata(&pdev->dev);\r\ndev_warn(&pdev->dev,\r\n"Unregistering A21 watchdog driver, board may reboot\n");\r\nwatchdog_unregister_device(&drv->wdt);\r\nmutex_destroy(&drv->lock);\r\nreturn 0;\r\n}\r\nstatic void a21_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct a21_wdt_drv *drv = dev_get_drvdata(&pdev->dev);\r\ngpio_set_value(drv->gpios[GPIO_WD_ENAB], 0);\r\n}
