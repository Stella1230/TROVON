static void poll_finished(void)\r\n{\r\nint down;\r\nint key;\r\nunsigned char scode;\r\nswitch (hil_dev.data[0]) {\r\ncase 0x40:\r\ndown = (hil_dev.data[1] & 1) == 0;\r\nscode = hil_dev.data[1] >> 1;\r\nkey = hphilkeyb_keycode[scode];\r\ninput_report_key(hil_dev.dev, key, down);\r\nbreak;\r\n}\r\nhil_dev.curdev = 0;\r\n}\r\nstatic inline void handle_status(unsigned char s, unsigned char c)\r\n{\r\nif (c & 0x8) {\r\nif (c & 0x10)\r\npoll_finished();\r\n} else {\r\nif (c & 0x10) {\r\nif (hil_dev.curdev)\r\npoll_finished();\r\nhil_dev.curdev = c & 7;\r\nhil_dev.ptr = 0;\r\n}\r\n}\r\n}\r\nstatic inline void handle_data(unsigned char s, unsigned char c)\r\n{\r\nif (hil_dev.curdev) {\r\nhil_dev.data[hil_dev.ptr++] = c;\r\nhil_dev.ptr &= 15;\r\n}\r\n}\r\nstatic irqreturn_t hil_interrupt(int irq, void *handle)\r\n{\r\nunsigned char s, c;\r\ns = hil_status();\r\nc = hil_read_data();\r\nswitch (s >> 4) {\r\ncase 0x5:\r\nhandle_status(s, c);\r\nbreak;\r\ncase 0x6:\r\nhandle_data(s, c);\r\nbreak;\r\ncase 0x4:\r\nhil_dev.s = s;\r\nhil_dev.c = c;\r\nmb();\r\nhil_dev.valid = 1;\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void hil_do(unsigned char cmd, unsigned char *data, unsigned int len)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hil_dev.lock, flags);\r\nwhile (hil_busy())\r\n;\r\nhil_command(cmd);\r\nwhile (len--) {\r\nwhile (hil_busy())\r\n;\r\nhil_write_data(*(data++));\r\n}\r\nspin_unlock_irqrestore(&hil_dev.lock, flags);\r\n}\r\nstatic int hil_keyb_init(void)\r\n{\r\nunsigned char c;\r\nunsigned int i, kbid;\r\nwait_queue_head_t hil_wait;\r\nint err;\r\nif (hil_dev.dev)\r\nreturn -ENODEV;\r\ninit_waitqueue_head(&hil_wait);\r\nspin_lock_init(&hil_dev.lock);\r\nhil_dev.dev = input_allocate_device();\r\nif (!hil_dev.dev)\r\nreturn -ENOMEM;\r\nerr = request_irq(HIL_IRQ, hil_interrupt, 0, "hil", hil_dev.dev_id);\r\nif (err) {\r\nprintk(KERN_ERR "HIL: Can't get IRQ\n");\r\ngoto err1;\r\n}\r\nhil_do(HIL_INTON, NULL, 0);\r\nhil_dev.valid = 0;\r\nhil_do(HIL_READKBDSADR, NULL, 0);\r\nwait_event_interruptible_timeout(hil_wait, hil_dev.valid, 3 * HZ);\r\nif (!hil_dev.valid)\r\nprintk(KERN_WARNING "HIL: timed out, assuming no keyboard present\n");\r\nc = hil_dev.c;\r\nhil_dev.valid = 0;\r\nif (c == 0) {\r\nkbid = -1;\r\nprintk(KERN_WARNING "HIL: no keyboard present\n");\r\n} else {\r\nkbid = ffz(~c);\r\nprintk(KERN_INFO "HIL: keyboard found at id %d\n", kbid);\r\n}\r\nc = 0;\r\nhil_do(HIL_WRITEKBDSADR, &c, 1);\r\nfor (i = 0; i < HIL_KEYCODES_SET1_TBLSIZE; i++)\r\nif (hphilkeyb_keycode[i] != KEY_RESERVED)\r\n__set_bit(hphilkeyb_keycode[i], hil_dev.dev->keybit);\r\nhil_dev.dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\nhil_dev.dev->ledbit[0] = BIT_MASK(LED_NUML) | BIT_MASK(LED_CAPSL) |\r\nBIT_MASK(LED_SCROLLL);\r\nhil_dev.dev->keycodemax = HIL_KEYCODES_SET1_TBLSIZE;\r\nhil_dev.dev->keycodesize= sizeof(hphilkeyb_keycode[0]);\r\nhil_dev.dev->keycode = hphilkeyb_keycode;\r\nhil_dev.dev->name = "HIL keyboard";\r\nhil_dev.dev->phys = "hpkbd/input0";\r\nhil_dev.dev->id.bustype = BUS_HIL;\r\nhil_dev.dev->id.vendor = PCI_VENDOR_ID_HP;\r\nhil_dev.dev->id.product = 0x0001;\r\nhil_dev.dev->id.version = 0x0010;\r\nerr = input_register_device(hil_dev.dev);\r\nif (err) {\r\nprintk(KERN_ERR "HIL: Can't register device\n");\r\ngoto err2;\r\n}\r\nprintk(KERN_INFO "input: %s, ID %d at 0x%08lx (irq %d) found and attached\n",\r\nhil_dev.dev->name, kbid, HILBASE, HIL_IRQ);\r\nreturn 0;\r\nerr2:\r\nhil_do(HIL_INTOFF, NULL, 0);\r\nfree_irq(HIL_IRQ, hil_dev.dev_id);\r\nerr1:\r\ninput_free_device(hil_dev.dev);\r\nhil_dev.dev = NULL;\r\nreturn err;\r\n}\r\nstatic void hil_keyb_exit(void)\r\n{\r\nif (HIL_IRQ)\r\nfree_irq(HIL_IRQ, hil_dev.dev_id);\r\nhil_do(HIL_INTOFF, NULL, 0);\r\ninput_unregister_device(hil_dev.dev);\r\nhil_dev.dev = NULL;\r\n}\r\nstatic int hil_probe_chip(struct parisc_device *dev)\r\n{\r\nif (hil_dev.dev)\r\nreturn -ENODEV;\r\nif (!dev->irq) {\r\nprintk(KERN_WARNING "HIL: IRQ not found for HIL bus at 0x%p\n",\r\n(void *)dev->hpa.start);\r\nreturn -ENODEV;\r\n}\r\nhil_base = dev->hpa.start;\r\nhil_irq = dev->irq;\r\nhil_dev.dev_id = dev;\r\nprintk(KERN_INFO "Found HIL bus at 0x%08lx, IRQ %d\n", hil_base, hil_irq);\r\nreturn hil_keyb_init();\r\n}\r\nstatic int hil_remove_chip(struct parisc_device *dev)\r\n{\r\nhil_keyb_exit();\r\nreturn 0;\r\n}\r\nstatic int __init hil_init(void)\r\n{\r\nreturn register_parisc_driver(&hil_driver);\r\n}\r\nstatic void __exit hil_exit(void)\r\n{\r\nunregister_parisc_driver(&hil_driver);\r\n}\r\nstatic int __init hil_init(void)\r\n{\r\nint error;\r\nif (hil_dev.dev)\r\nreturn -EBUSY;\r\nif (!MACH_IS_HP300)\r\nreturn -ENODEV;\r\nif (!hwreg_present((void *)(HILBASE + HIL_DATA))) {\r\nprintk(KERN_ERR "HIL: hardware register was not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (!request_region(HILBASE + HIL_DATA, 2, "hil")) {\r\nprintk(KERN_ERR "HIL: IOPORT region already used\n");\r\nreturn -EIO;\r\n}\r\nerror = hil_keyb_init();\r\nif (error) {\r\nrelease_region(HILBASE + HIL_DATA, 2);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hil_exit(void)\r\n{\r\nhil_keyb_exit();\r\nrelease_region(HILBASE + HIL_DATA, 2);\r\n}
