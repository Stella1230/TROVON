u32 rxe_icrc_hdr(struct rxe_pkt_info *pkt, struct sk_buff *skb)\r\n{\r\nunsigned int bth_offset = 0;\r\nstruct iphdr *ip4h = NULL;\r\nstruct ipv6hdr *ip6h = NULL;\r\nstruct udphdr *udph;\r\nstruct rxe_bth *bth;\r\nint crc;\r\nint length;\r\nint hdr_size = sizeof(struct udphdr) +\r\n(skb->protocol == htons(ETH_P_IP) ?\r\nsizeof(struct iphdr) : sizeof(struct ipv6hdr));\r\nu8 pshdr[sizeof(struct udphdr) +\r\nsizeof(struct ipv6hdr) +\r\nRXE_BTH_BYTES];\r\ncrc = 0xdebb20e3;\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nmemcpy(pshdr, ip_hdr(skb), hdr_size);\r\nip4h = (struct iphdr *)pshdr;\r\nudph = (struct udphdr *)(ip4h + 1);\r\nip4h->ttl = 0xff;\r\nip4h->check = CSUM_MANGLED_0;\r\nip4h->tos = 0xff;\r\n} else {\r\nmemcpy(pshdr, ipv6_hdr(skb), hdr_size);\r\nip6h = (struct ipv6hdr *)pshdr;\r\nudph = (struct udphdr *)(ip6h + 1);\r\nmemset(ip6h->flow_lbl, 0xff, sizeof(ip6h->flow_lbl));\r\nip6h->priority = 0xf;\r\nip6h->hop_limit = 0xff;\r\n}\r\nudph->check = CSUM_MANGLED_0;\r\nbth_offset += hdr_size;\r\nmemcpy(&pshdr[bth_offset], pkt->hdr, RXE_BTH_BYTES);\r\nbth = (struct rxe_bth *)&pshdr[bth_offset];\r\nbth->qpn |= cpu_to_be32(~BTH_QPN_MASK);\r\nlength = hdr_size + RXE_BTH_BYTES;\r\ncrc = crc32_le(crc, pshdr, length);\r\ncrc = crc32_le(crc, pkt->hdr + RXE_BTH_BYTES,\r\nrxe_opcode[pkt->opcode].length - RXE_BTH_BYTES);\r\nreturn crc;\r\n}
