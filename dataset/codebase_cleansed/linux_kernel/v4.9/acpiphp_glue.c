static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)\r\n{\r\nstruct acpiphp_context *context;\r\ncontext = kzalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context)\r\nreturn NULL;\r\ncontext->refcount = 1;\r\ncontext->hp.notify = acpiphp_hotplug_notify;\r\ncontext->hp.fixup = acpiphp_post_dock_fixup;\r\nacpi_set_hp_context(adev, &context->hp);\r\nreturn context;\r\n}\r\nstatic struct acpiphp_context *acpiphp_get_context(struct acpi_device *adev)\r\n{\r\nstruct acpiphp_context *context;\r\nif (!adev->hp)\r\nreturn NULL;\r\ncontext = to_acpiphp_context(adev->hp);\r\ncontext->refcount++;\r\nreturn context;\r\n}\r\nstatic void acpiphp_put_context(struct acpiphp_context *context)\r\n{\r\nif (--context->refcount)\r\nreturn;\r\nWARN_ON(context->bridge);\r\ncontext->hp.self->hp = NULL;\r\nkfree(context);\r\n}\r\nstatic inline void get_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nkref_get(&bridge->ref);\r\n}\r\nstatic inline void put_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nkref_put(&bridge->ref, free_bridge);\r\n}\r\nstatic struct acpiphp_context *acpiphp_grab_context(struct acpi_device *adev)\r\n{\r\nstruct acpiphp_context *context;\r\nacpi_lock_hp_context();\r\ncontext = acpiphp_get_context(adev);\r\nif (!context || context->func.parent->is_going_away) {\r\nacpi_unlock_hp_context();\r\nreturn NULL;\r\n}\r\nget_bridge(context->func.parent);\r\nacpiphp_put_context(context);\r\nacpi_unlock_hp_context();\r\nreturn context;\r\n}\r\nstatic void acpiphp_let_context_go(struct acpiphp_context *context)\r\n{\r\nput_bridge(context->func.parent);\r\n}\r\nstatic void free_bridge(struct kref *kref)\r\n{\r\nstruct acpiphp_context *context;\r\nstruct acpiphp_bridge *bridge;\r\nstruct acpiphp_slot *slot, *next;\r\nstruct acpiphp_func *func, *tmp;\r\nacpi_lock_hp_context();\r\nbridge = container_of(kref, struct acpiphp_bridge, ref);\r\nlist_for_each_entry_safe(slot, next, &bridge->slots, node) {\r\nlist_for_each_entry_safe(func, tmp, &slot->funcs, sibling)\r\nacpiphp_put_context(func_to_context(func));\r\nkfree(slot);\r\n}\r\ncontext = bridge->context;\r\nif (context) {\r\nput_bridge(context->func.parent);\r\ncontext->bridge = NULL;\r\nacpiphp_put_context(context);\r\n}\r\nput_device(&bridge->pci_bus->dev);\r\npci_dev_put(bridge->pci_dev);\r\nkfree(bridge);\r\nacpi_unlock_hp_context();\r\n}\r\nstatic void acpiphp_post_dock_fixup(struct acpi_device *adev)\r\n{\r\nstruct acpiphp_context *context = acpiphp_grab_context(adev);\r\nstruct pci_bus *bus;\r\nu32 buses;\r\nif (!context)\r\nreturn;\r\nbus = context->func.slot->bus;\r\nif (!bus->self)\r\ngoto out;\r\npci_read_config_dword(bus->self, PCI_PRIMARY_BUS, &buses);\r\nif (((buses >> 8) & 0xff) != bus->busn_res.start) {\r\nbuses = (buses & 0xff000000)\r\n| ((unsigned int)(bus->primary) << 0)\r\n| ((unsigned int)(bus->busn_res.start) << 8)\r\n| ((unsigned int)(bus->busn_res.end) << 16);\r\npci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);\r\n}\r\nout:\r\nacpiphp_let_context_go(context);\r\n}\r\nstatic bool device_is_managed_by_native_pciehp(struct pci_dev *pdev)\r\n{\r\nu32 reg32;\r\nacpi_handle tmp;\r\nstruct acpi_pci_root *root;\r\nif (pcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &reg32))\r\nreturn false;\r\nif (!(reg32 & PCI_EXP_SLTCAP_HPC))\r\nreturn false;\r\ntmp = acpi_find_root_bridge_handle(pdev);\r\nif (!tmp)\r\nreturn false;\r\nroot = acpi_pci_find_root(tmp);\r\nif (!root)\r\nreturn false;\r\nif (!(root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic acpi_status acpiphp_add_context(acpi_handle handle, u32 lvl, void *data,\r\nvoid **rv)\r\n{\r\nstruct acpiphp_bridge *bridge = data;\r\nstruct acpiphp_context *context;\r\nstruct acpi_device *adev;\r\nstruct acpiphp_slot *slot;\r\nstruct acpiphp_func *newfunc;\r\nacpi_status status = AE_OK;\r\nunsigned long long adr;\r\nint device, function;\r\nstruct pci_bus *pbus = bridge->pci_bus;\r\nstruct pci_dev *pdev = bridge->pci_dev;\r\nu32 val;\r\nstatus = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND)\r\nacpi_handle_warn(handle,\r\n"can't evaluate _ADR (%#x)\n", status);\r\nreturn AE_OK;\r\n}\r\nif (acpi_bus_get_device(handle, &adev))\r\nreturn AE_OK;\r\ndevice = (adr >> 16) & 0xffff;\r\nfunction = adr & 0xffff;\r\nacpi_lock_hp_context();\r\ncontext = acpiphp_init_context(adev);\r\nif (!context) {\r\nacpi_unlock_hp_context();\r\nacpi_handle_err(handle, "No hotplug context\n");\r\nreturn AE_NOT_EXIST;\r\n}\r\nnewfunc = &context->func;\r\nnewfunc->function = function;\r\nnewfunc->parent = bridge;\r\nacpi_unlock_hp_context();\r\nif (!is_dock_device(adev) && acpi_has_method(handle, "_EJ0"))\r\nnewfunc->flags = FUNC_HAS_EJ0;\r\nif (acpi_has_method(handle, "_STA"))\r\nnewfunc->flags |= FUNC_HAS_STA;\r\nlist_for_each_entry(slot, &bridge->slots, node)\r\nif (slot->device == device)\r\ngoto slot_found;\r\nslot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);\r\nif (!slot) {\r\nacpi_lock_hp_context();\r\nacpiphp_put_context(context);\r\nacpi_unlock_hp_context();\r\nreturn AE_NO_MEMORY;\r\n}\r\nslot->bus = bridge->pci_bus;\r\nslot->device = device;\r\nINIT_LIST_HEAD(&slot->funcs);\r\nlist_add_tail(&slot->node, &bridge->slots);\r\nif ((acpi_pci_check_ejectable(pbus, handle) || is_dock_device(adev))\r\n&& !(pdev && device_is_managed_by_native_pciehp(pdev))) {\r\nunsigned long long sun;\r\nint retval;\r\nbridge->nr_slots++;\r\nstatus = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);\r\nif (ACPI_FAILURE(status))\r\nsun = bridge->nr_slots;\r\npr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",\r\nsun, pci_domain_nr(pbus), pbus->number, device);\r\nretval = acpiphp_register_hotplug_slot(slot, sun);\r\nif (retval) {\r\nslot->slot = NULL;\r\nbridge->nr_slots--;\r\nif (retval == -EBUSY)\r\npr_warn("Slot %llu already registered by another hotplug driver\n", sun);\r\nelse\r\npr_warn("acpiphp_register_hotplug_slot failed (err code = 0x%x)\n", retval);\r\n}\r\n}\r\nslot_found:\r\nnewfunc->slot = slot;\r\nlist_add_tail(&newfunc->sibling, &slot->funcs);\r\nif (pci_bus_read_dev_vendor_id(pbus, PCI_DEVFN(device, function),\r\n&val, 60*1000))\r\nslot->flags |= SLOT_ENABLED;\r\nreturn AE_OK;\r\n}\r\nstatic void cleanup_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nstruct acpiphp_slot *slot;\r\nstruct acpiphp_func *func;\r\nlist_for_each_entry(slot, &bridge->slots, node) {\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nstruct acpi_device *adev = func_to_acpi_device(func);\r\nacpi_lock_hp_context();\r\nadev->hp->notify = NULL;\r\nadev->hp->fixup = NULL;\r\nacpi_unlock_hp_context();\r\n}\r\nslot->flags |= SLOT_IS_GOING_AWAY;\r\nif (slot->slot)\r\nacpiphp_unregister_hotplug_slot(slot);\r\n}\r\nmutex_lock(&bridge_mutex);\r\nlist_del(&bridge->list);\r\nmutex_unlock(&bridge_mutex);\r\nacpi_lock_hp_context();\r\nbridge->is_going_away = true;\r\nacpi_unlock_hp_context();\r\n}\r\nstatic unsigned char acpiphp_max_busnr(struct pci_bus *bus)\r\n{\r\nstruct pci_bus *tmp;\r\nunsigned char max, n;\r\nmax = bus->busn_res.start;\r\nlist_for_each_entry(tmp, &bus->children, node) {\r\nn = pci_bus_max_busnr(tmp);\r\nif (n > max)\r\nmax = n;\r\n}\r\nreturn max;\r\n}\r\nstatic void acpiphp_set_acpi_region(struct acpiphp_slot *slot)\r\n{\r\nstruct acpiphp_func *func;\r\nunion acpi_object params[2];\r\nstruct acpi_object_list arg_list;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\narg_list.count = 2;\r\narg_list.pointer = params;\r\nparams[0].type = ACPI_TYPE_INTEGER;\r\nparams[0].integer.value = ACPI_ADR_SPACE_PCI_CONFIG;\r\nparams[1].type = ACPI_TYPE_INTEGER;\r\nparams[1].integer.value = 1;\r\nacpi_evaluate_object(func_to_handle(func), "_REG", &arg_list,\r\nNULL);\r\n}\r\n}\r\nstatic void check_hotplug_bridge(struct acpiphp_slot *slot, struct pci_dev *dev)\r\n{\r\nstruct acpiphp_func *func;\r\nif (dev->is_hotplug_bridge)\r\nreturn;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (PCI_FUNC(dev->devfn) == func->function) {\r\ndev->is_hotplug_bridge = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int acpiphp_rescan_slot(struct acpiphp_slot *slot)\r\n{\r\nstruct acpiphp_func *func;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nstruct acpi_device *adev = func_to_acpi_device(func);\r\nacpi_bus_scan(adev->handle);\r\nif (acpi_device_enumerated(adev))\r\nacpi_device_set_power(adev, ACPI_STATE_D0);\r\n}\r\nreturn pci_scan_slot(slot->bus, PCI_DEVFN(slot->device, 0));\r\n}\r\nstatic void enable_slot(struct acpiphp_slot *slot)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_bus *bus = slot->bus;\r\nstruct acpiphp_func *func;\r\nint max, pass;\r\nLIST_HEAD(add_list);\r\nacpiphp_rescan_slot(slot);\r\nmax = acpiphp_max_busnr(bus);\r\nfor (pass = 0; pass < 2; pass++) {\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) != slot->device)\r\ncontinue;\r\nif (pci_is_bridge(dev)) {\r\nmax = pci_scan_bridge(bus, dev, max, pass);\r\nif (pass && dev->subordinate) {\r\ncheck_hotplug_bridge(slot, dev);\r\npcibios_resource_survey_bus(dev->subordinate);\r\n__pci_bus_size_bridges(dev->subordinate,\r\n&add_list);\r\n}\r\n}\r\n}\r\n}\r\n__pci_bus_assign_resources(bus, &add_list, NULL);\r\nacpiphp_sanitize_bus(bus);\r\npcie_bus_configure_settings(bus);\r\nacpiphp_set_acpi_region(slot);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (!dev->is_added)\r\ndev->current_state = PCI_D0;\r\n}\r\npci_bus_add_devices(bus);\r\nslot->flags |= SLOT_ENABLED;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\ndev = pci_get_slot(bus, PCI_DEVFN(slot->device,\r\nfunc->function));\r\nif (!dev) {\r\nslot->flags &= (~SLOT_ENABLED);\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic void disable_slot(struct acpiphp_slot *slot)\r\n{\r\nstruct pci_bus *bus = slot->bus;\r\nstruct pci_dev *dev, *prev;\r\nstruct acpiphp_func *func;\r\nlist_for_each_entry_safe_reverse(dev, prev, &bus->devices, bus_list)\r\nif (PCI_SLOT(dev->devfn) == slot->device)\r\npci_stop_and_remove_bus_device(dev);\r\nlist_for_each_entry(func, &slot->funcs, sibling)\r\nacpi_bus_trim(func_to_acpi_device(func));\r\nslot->flags &= (~SLOT_ENABLED);\r\n}\r\nstatic bool slot_no_hotplug(struct acpiphp_slot *slot)\r\n{\r\nstruct pci_bus *bus = slot->bus;\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) == slot->device && dev->ignore_hotplug)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic unsigned int get_slot_status(struct acpiphp_slot *slot)\r\n{\r\nunsigned long long sta = 0;\r\nstruct acpiphp_func *func;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->flags & FUNC_HAS_STA) {\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(func_to_handle(func),\r\n"_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && sta)\r\nbreak;\r\n} else {\r\nu32 dvid;\r\npci_bus_read_config_dword(slot->bus,\r\nPCI_DEVFN(slot->device,\r\nfunc->function),\r\nPCI_VENDOR_ID, &dvid);\r\nif (dvid != 0xffffffff) {\r\nsta = ACPI_STA_ALL;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn (unsigned int)sta;\r\n}\r\nstatic inline bool device_status_valid(unsigned int sta)\r\n{\r\nunsigned int mask = ACPI_STA_DEVICE_ENABLED | ACPI_STA_DEVICE_FUNCTIONING;\r\nreturn (sta & mask) == mask;\r\n}\r\nstatic void trim_stale_devices(struct pci_dev *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\r\nstruct pci_bus *bus = dev->subordinate;\r\nbool alive = dev->ignore_hotplug;\r\nif (adev) {\r\nacpi_status status;\r\nunsigned long long sta;\r\nstatus = acpi_evaluate_integer(adev->handle, "_STA", NULL, &sta);\r\nalive = alive || (ACPI_SUCCESS(status) && device_status_valid(sta));\r\n}\r\nif (!alive)\r\nalive = pci_device_is_present(dev);\r\nif (!alive) {\r\npci_stop_and_remove_bus_device(dev);\r\nif (adev)\r\nacpi_bus_trim(adev);\r\n} else if (bus) {\r\nstruct pci_dev *child, *tmp;\r\npm_runtime_get_sync(&dev->dev);\r\nlist_for_each_entry_safe_reverse(child, tmp, &bus->devices, bus_list)\r\ntrim_stale_devices(child);\r\npm_runtime_put(&dev->dev);\r\n}\r\n}\r\nstatic void acpiphp_check_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nstruct acpiphp_slot *slot;\r\nif (bridge->is_going_away)\r\nreturn;\r\nif (bridge->pci_dev)\r\npm_runtime_get_sync(&bridge->pci_dev->dev);\r\nlist_for_each_entry(slot, &bridge->slots, node) {\r\nstruct pci_bus *bus = slot->bus;\r\nstruct pci_dev *dev, *tmp;\r\nif (slot_no_hotplug(slot)) {\r\n;\r\n} else if (device_status_valid(get_slot_status(slot))) {\r\nlist_for_each_entry_safe_reverse(dev, tmp,\r\n&bus->devices, bus_list)\r\nif (PCI_SLOT(dev->devfn) == slot->device)\r\ntrim_stale_devices(dev);\r\nenable_slot(slot);\r\n} else {\r\ndisable_slot(slot);\r\n}\r\n}\r\nif (bridge->pci_dev)\r\npm_runtime_put(&bridge->pci_dev->dev);\r\n}\r\nstatic void acpiphp_sanitize_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev, *tmp;\r\nint i;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM;\r\nlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\r\nfor (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {\r\nstruct resource *res = &dev->resource[i];\r\nif ((res->flags & type_mask) && !res->start &&\r\nres->end) {\r\npci_stop_and_remove_bus_device(dev);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nvoid acpiphp_check_host_bridge(struct acpi_device *adev)\r\n{\r\nstruct acpiphp_bridge *bridge = NULL;\r\nacpi_lock_hp_context();\r\nif (adev->hp) {\r\nbridge = to_acpiphp_root_context(adev->hp)->root_bridge;\r\nif (bridge)\r\nget_bridge(bridge);\r\n}\r\nacpi_unlock_hp_context();\r\nif (bridge) {\r\npci_lock_rescan_remove();\r\nacpiphp_check_bridge(bridge);\r\npci_unlock_rescan_remove();\r\nput_bridge(bridge);\r\n}\r\n}\r\nstatic void hotplug_event(u32 type, struct acpiphp_context *context)\r\n{\r\nacpi_handle handle = context->hp.self->handle;\r\nstruct acpiphp_func *func = &context->func;\r\nstruct acpiphp_slot *slot = func->slot;\r\nstruct acpiphp_bridge *bridge;\r\nacpi_lock_hp_context();\r\nbridge = context->bridge;\r\nif (bridge)\r\nget_bridge(bridge);\r\nacpi_unlock_hp_context();\r\npci_lock_rescan_remove();\r\nswitch (type) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\nacpi_handle_debug(handle, "Bus check in %s()\n", __func__);\r\nif (bridge)\r\nacpiphp_check_bridge(bridge);\r\nelse if (!(slot->flags & SLOT_IS_GOING_AWAY))\r\nenable_slot(slot);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nacpi_handle_debug(handle, "Device check in %s()\n", __func__);\r\nif (bridge) {\r\nacpiphp_check_bridge(bridge);\r\n} else if (!(slot->flags & SLOT_IS_GOING_AWAY)) {\r\nif (acpiphp_rescan_slot(slot))\r\nacpiphp_check_bridge(func->parent);\r\n}\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\nacpi_handle_debug(handle, "Eject request in %s()\n", __func__);\r\nacpiphp_disable_and_eject_slot(slot);\r\nbreak;\r\n}\r\npci_unlock_rescan_remove();\r\nif (bridge)\r\nput_bridge(bridge);\r\n}\r\nstatic int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type)\r\n{\r\nstruct acpiphp_context *context;\r\ncontext = acpiphp_grab_context(adev);\r\nif (!context)\r\nreturn -ENODATA;\r\nhotplug_event(type, context);\r\nacpiphp_let_context_go(context);\r\nreturn 0;\r\n}\r\nvoid acpiphp_enumerate_slots(struct pci_bus *bus)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nstruct acpi_device *adev;\r\nacpi_handle handle;\r\nacpi_status status;\r\nif (acpiphp_disabled)\r\nreturn;\r\nadev = ACPI_COMPANION(bus->bridge);\r\nif (!adev)\r\nreturn;\r\nhandle = adev->handle;\r\nbridge = kzalloc(sizeof(struct acpiphp_bridge), GFP_KERNEL);\r\nif (!bridge) {\r\nacpi_handle_err(handle, "No memory for bridge object\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&bridge->slots);\r\nkref_init(&bridge->ref);\r\nbridge->pci_dev = pci_dev_get(bus->self);\r\nbridge->pci_bus = bus;\r\nget_device(&bus->dev);\r\nacpi_lock_hp_context();\r\nif (pci_is_root_bus(bridge->pci_bus)) {\r\nstruct acpiphp_root_context *root_context;\r\nroot_context = kzalloc(sizeof(*root_context), GFP_KERNEL);\r\nif (!root_context)\r\ngoto err;\r\nroot_context->root_bridge = bridge;\r\nacpi_set_hp_context(adev, &root_context->hp);\r\n} else {\r\nstruct acpiphp_context *context;\r\ncontext = acpiphp_get_context(adev);\r\nif (!context)\r\ngoto err;\r\nbridge->context = context;\r\ncontext->bridge = bridge;\r\nget_bridge(context->func.parent);\r\n}\r\nacpi_unlock_hp_context();\r\nmutex_lock(&bridge_mutex);\r\nlist_add(&bridge->list, &bridge_list);\r\nmutex_unlock(&bridge_mutex);\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\r\nacpiphp_add_context, NULL, bridge, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_handle_err(handle, "failed to register slots\n");\r\ncleanup_bridge(bridge);\r\nput_bridge(bridge);\r\n}\r\nreturn;\r\nerr:\r\nacpi_unlock_hp_context();\r\nput_device(&bus->dev);\r\npci_dev_put(bridge->pci_dev);\r\nkfree(bridge);\r\n}\r\nstatic void acpiphp_drop_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nif (pci_is_root_bus(bridge->pci_bus)) {\r\nstruct acpiphp_root_context *root_context;\r\nstruct acpi_device *adev;\r\nacpi_lock_hp_context();\r\nadev = ACPI_COMPANION(bridge->pci_bus->bridge);\r\nroot_context = to_acpiphp_root_context(adev->hp);\r\nadev->hp = NULL;\r\nacpi_unlock_hp_context();\r\nkfree(root_context);\r\n}\r\ncleanup_bridge(bridge);\r\nput_bridge(bridge);\r\n}\r\nvoid acpiphp_remove_slots(struct pci_bus *bus)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nif (acpiphp_disabled)\r\nreturn;\r\nmutex_lock(&bridge_mutex);\r\nlist_for_each_entry(bridge, &bridge_list, list)\r\nif (bridge->pci_bus == bus) {\r\nmutex_unlock(&bridge_mutex);\r\nacpiphp_drop_bridge(bridge);\r\nreturn;\r\n}\r\nmutex_unlock(&bridge_mutex);\r\n}\r\nint acpiphp_enable_slot(struct acpiphp_slot *slot)\r\n{\r\npci_lock_rescan_remove();\r\nif (slot->flags & SLOT_IS_GOING_AWAY) {\r\npci_unlock_rescan_remove();\r\nreturn -ENODEV;\r\n}\r\nif (!(slot->flags & SLOT_ENABLED))\r\nenable_slot(slot);\r\npci_unlock_rescan_remove();\r\nreturn 0;\r\n}\r\nstatic int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot)\r\n{\r\nstruct acpiphp_func *func;\r\nif (slot->flags & SLOT_IS_GOING_AWAY)\r\nreturn -ENODEV;\r\ndisable_slot(slot);\r\nlist_for_each_entry(func, &slot->funcs, sibling)\r\nif (func->flags & FUNC_HAS_EJ0) {\r\nacpi_handle handle = func_to_handle(func);\r\nif (ACPI_FAILURE(acpi_evaluate_ej0(handle)))\r\nacpi_handle_err(handle, "_EJ0 failed\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint acpiphp_disable_slot(struct acpiphp_slot *slot)\r\n{\r\nint ret;\r\nacpi_scan_lock_acquire();\r\npci_lock_rescan_remove();\r\nret = acpiphp_disable_and_eject_slot(slot);\r\npci_unlock_rescan_remove();\r\nacpi_scan_lock_release();\r\nreturn ret;\r\n}\r\nu8 acpiphp_get_power_status(struct acpiphp_slot *slot)\r\n{\r\nreturn (slot->flags & SLOT_ENABLED);\r\n}\r\nu8 acpiphp_get_latch_status(struct acpiphp_slot *slot)\r\n{\r\nreturn !(get_slot_status(slot) & ACPI_STA_DEVICE_UI);\r\n}\r\nu8 acpiphp_get_adapter_status(struct acpiphp_slot *slot)\r\n{\r\nreturn !!get_slot_status(slot);\r\n}
