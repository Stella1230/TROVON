static int ath9k_hw_ar9287_get_eeprom_ver(struct ath_hw *ah)\r\n{\r\nreturn (ah->eeprom.map9287.baseEepHeader.version >> 12) & 0xF;\r\n}\r\nstatic int ath9k_hw_ar9287_get_eeprom_rev(struct ath_hw *ah)\r\n{\r\nreturn (ah->eeprom.map9287.baseEepHeader.version) & 0xFFF;\r\n}\r\nstatic bool __ath9k_hw_ar9287_fill_eeprom(struct ath_hw *ah)\r\n{\r\nstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\r\nu16 *eep_data;\r\nint addr, eep_start_loc = AR9287_EEP_START_LOC;\r\neep_data = (u16 *)eep;\r\nfor (addr = 0; addr < SIZE_EEPROM_AR9287; addr++) {\r\nif (!ath9k_hw_nvram_read(ah, addr + eep_start_loc, eep_data))\r\nreturn false;\r\neep_data++;\r\n}\r\nreturn true;\r\n}\r\nstatic bool __ath9k_hw_usb_ar9287_fill_eeprom(struct ath_hw *ah)\r\n{\r\nu16 *eep_data = (u16 *)&ah->eeprom.map9287;\r\nath9k_hw_usb_gen_fill_eeprom(ah, eep_data,\r\nAR9287_HTC_EEP_START_LOC,\r\nSIZE_EEPROM_AR9287);\r\nreturn true;\r\n}\r\nstatic bool ath9k_hw_ar9287_fill_eeprom(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (!ath9k_hw_use_flash(ah)) {\r\nath_dbg(common, EEPROM, "Reading from EEPROM, not flash\n");\r\n}\r\nif (common->bus_ops->ath_bus_type == ATH_USB)\r\nreturn __ath9k_hw_usb_ar9287_fill_eeprom(ah);\r\nelse\r\nreturn __ath9k_hw_ar9287_fill_eeprom(ah);\r\n}\r\nstatic u32 ar9287_dump_modal_eeprom(char *buf, u32 len, u32 size,\r\nstruct modal_eep_ar9287_header *modal_hdr)\r\n{\r\nPR_EEP("Chain0 Ant. Control", modal_hdr->antCtrlChain[0]);\r\nPR_EEP("Chain1 Ant. Control", modal_hdr->antCtrlChain[1]);\r\nPR_EEP("Ant. Common Control", modal_hdr->antCtrlCommon);\r\nPR_EEP("Chain0 Ant. Gain", modal_hdr->antennaGainCh[0]);\r\nPR_EEP("Chain1 Ant. Gain", modal_hdr->antennaGainCh[1]);\r\nPR_EEP("Switch Settle", modal_hdr->switchSettling);\r\nPR_EEP("Chain0 TxRxAtten", modal_hdr->txRxAttenCh[0]);\r\nPR_EEP("Chain1 TxRxAtten", modal_hdr->txRxAttenCh[1]);\r\nPR_EEP("Chain0 RxTxMargin", modal_hdr->rxTxMarginCh[0]);\r\nPR_EEP("Chain1 RxTxMargin", modal_hdr->rxTxMarginCh[1]);\r\nPR_EEP("ADC Desired size", modal_hdr->adcDesiredSize);\r\nPR_EEP("txEndToXpaOff", modal_hdr->txEndToXpaOff);\r\nPR_EEP("txEndToRxOn", modal_hdr->txEndToRxOn);\r\nPR_EEP("txFrameToXpaOn", modal_hdr->txFrameToXpaOn);\r\nPR_EEP("CCA Threshold)", modal_hdr->thresh62);\r\nPR_EEP("Chain0 NF Threshold", modal_hdr->noiseFloorThreshCh[0]);\r\nPR_EEP("Chain1 NF Threshold", modal_hdr->noiseFloorThreshCh[1]);\r\nPR_EEP("xpdGain", modal_hdr->xpdGain);\r\nPR_EEP("External PD", modal_hdr->xpd);\r\nPR_EEP("Chain0 I Coefficient", modal_hdr->iqCalICh[0]);\r\nPR_EEP("Chain1 I Coefficient", modal_hdr->iqCalICh[1]);\r\nPR_EEP("Chain0 Q Coefficient", modal_hdr->iqCalQCh[0]);\r\nPR_EEP("Chain1 Q Coefficient", modal_hdr->iqCalQCh[1]);\r\nPR_EEP("pdGainOverlap", modal_hdr->pdGainOverlap);\r\nPR_EEP("xPA Bias Level", modal_hdr->xpaBiasLvl);\r\nPR_EEP("txFrameToDataStart", modal_hdr->txFrameToDataStart);\r\nPR_EEP("txFrameToPaOn", modal_hdr->txFrameToPaOn);\r\nPR_EEP("HT40 Power Inc.", modal_hdr->ht40PowerIncForPdadc);\r\nPR_EEP("Chain0 bswAtten", modal_hdr->bswAtten[0]);\r\nPR_EEP("Chain1 bswAtten", modal_hdr->bswAtten[1]);\r\nPR_EEP("Chain0 bswMargin", modal_hdr->bswMargin[0]);\r\nPR_EEP("Chain1 bswMargin", modal_hdr->bswMargin[1]);\r\nPR_EEP("HT40 Switch Settle", modal_hdr->swSettleHt40);\r\nPR_EEP("AR92x7 Version", modal_hdr->version);\r\nPR_EEP("DriverBias1", modal_hdr->db1);\r\nPR_EEP("DriverBias2", modal_hdr->db1);\r\nPR_EEP("CCK OutputBias", modal_hdr->ob_cck);\r\nPR_EEP("PSK OutputBias", modal_hdr->ob_psk);\r\nPR_EEP("QAM OutputBias", modal_hdr->ob_qam);\r\nPR_EEP("PAL_OFF OutputBias", modal_hdr->ob_pal_off);\r\nreturn len;\r\n}\r\nstatic u32 ath9k_hw_ar9287_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\r\nu8 *buf, u32 len, u32 size)\r\n{\r\nstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\r\nstruct base_eep_ar9287_header *pBase = &eep->baseEepHeader;\r\nif (!dump_base_hdr) {\r\nlen += scnprintf(buf + len, size - len,\r\n"%20s :\n", "2GHz modal Header");\r\nlen = ar9287_dump_modal_eeprom(buf, len, size,\r\n&eep->modalHeader);\r\ngoto out;\r\n}\r\nPR_EEP("Major Version", pBase->version >> 12);\r\nPR_EEP("Minor Version", pBase->version & 0xFFF);\r\nPR_EEP("Checksum", pBase->checksum);\r\nPR_EEP("Length", pBase->length);\r\nPR_EEP("RegDomain1", pBase->regDmn[0]);\r\nPR_EEP("RegDomain2", pBase->regDmn[1]);\r\nPR_EEP("TX Mask", pBase->txMask);\r\nPR_EEP("RX Mask", pBase->rxMask);\r\nPR_EEP("Allow 5GHz", !!(pBase->opCapFlags & AR5416_OPFLAGS_11A));\r\nPR_EEP("Allow 2GHz", !!(pBase->opCapFlags & AR5416_OPFLAGS_11G));\r\nPR_EEP("Disable 2GHz HT20", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_2G_HT20));\r\nPR_EEP("Disable 2GHz HT40", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_2G_HT40));\r\nPR_EEP("Disable 5Ghz HT20", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_5G_HT20));\r\nPR_EEP("Disable 5Ghz HT40", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_5G_HT40));\r\nPR_EEP("Big Endian", !!(pBase->eepMisc & 0x01));\r\nPR_EEP("Cal Bin Major Ver", (pBase->binBuildNumber >> 24) & 0xFF);\r\nPR_EEP("Cal Bin Minor Ver", (pBase->binBuildNumber >> 16) & 0xFF);\r\nPR_EEP("Cal Bin Build", (pBase->binBuildNumber >> 8) & 0xFF);\r\nPR_EEP("Power Table Offset", pBase->pwrTableOffset);\r\nPR_EEP("OpenLoop Power Ctrl", pBase->openLoopPwrCntl);\r\nlen += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",\r\npBase->macAddr);\r\nout:\r\nif (len > size)\r\nlen = size;\r\nreturn len;\r\n}\r\nstatic u32 ath9k_hw_ar9287_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\r\nu8 *buf, u32 len, u32 size)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ath9k_hw_ar9287_check_eeprom(struct ath_hw *ah)\r\n{\r\nu32 el, integer;\r\nu16 word;\r\nint i, err;\r\nbool need_swap;\r\nstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\r\nerr = ath9k_hw_nvram_swap_data(ah, &need_swap, SIZE_EEPROM_AR9287);\r\nif (err)\r\nreturn err;\r\nif (need_swap)\r\nel = swab16(eep->baseEepHeader.length);\r\nelse\r\nel = eep->baseEepHeader.length;\r\nel = min(el / sizeof(u16), SIZE_EEPROM_AR9287);\r\nif (!ath9k_hw_nvram_validate_checksum(ah, el))\r\nreturn -EINVAL;\r\nif (need_swap) {\r\nword = swab16(eep->baseEepHeader.length);\r\neep->baseEepHeader.length = word;\r\nword = swab16(eep->baseEepHeader.checksum);\r\neep->baseEepHeader.checksum = word;\r\nword = swab16(eep->baseEepHeader.version);\r\neep->baseEepHeader.version = word;\r\nword = swab16(eep->baseEepHeader.regDmn[0]);\r\neep->baseEepHeader.regDmn[0] = word;\r\nword = swab16(eep->baseEepHeader.regDmn[1]);\r\neep->baseEepHeader.regDmn[1] = word;\r\nword = swab16(eep->baseEepHeader.rfSilent);\r\neep->baseEepHeader.rfSilent = word;\r\nword = swab16(eep->baseEepHeader.blueToothOptions);\r\neep->baseEepHeader.blueToothOptions = word;\r\nword = swab16(eep->baseEepHeader.deviceCap);\r\neep->baseEepHeader.deviceCap = word;\r\ninteger = swab32(eep->modalHeader.antCtrlCommon);\r\neep->modalHeader.antCtrlCommon = integer;\r\nfor (i = 0; i < AR9287_MAX_CHAINS; i++) {\r\ninteger = swab32(eep->modalHeader.antCtrlChain[i]);\r\neep->modalHeader.antCtrlChain[i] = integer;\r\n}\r\nfor (i = 0; i < AR_EEPROM_MODAL_SPURS; i++) {\r\nword = swab16(eep->modalHeader.spurChans[i].spurChan);\r\neep->modalHeader.spurChans[i].spurChan = word;\r\n}\r\n}\r\nif (!ath9k_hw_nvram_check_version(ah, AR9287_EEP_VER,\r\nAR5416_EEP_NO_BACK_VER))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic u32 ath9k_hw_ar9287_get_eeprom(struct ath_hw *ah,\r\nenum eeprom_param param)\r\n{\r\nstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\r\nstruct modal_eep_ar9287_header *pModal = &eep->modalHeader;\r\nstruct base_eep_ar9287_header *pBase = &eep->baseEepHeader;\r\nu16 ver_minor;\r\nver_minor = pBase->version & AR9287_EEP_VER_MINOR_MASK;\r\nswitch (param) {\r\ncase EEP_NFTHRESH_2:\r\nreturn pModal->noiseFloorThreshCh[0];\r\ncase EEP_MAC_LSW:\r\nreturn get_unaligned_be16(pBase->macAddr);\r\ncase EEP_MAC_MID:\r\nreturn get_unaligned_be16(pBase->macAddr + 2);\r\ncase EEP_MAC_MSW:\r\nreturn get_unaligned_be16(pBase->macAddr + 4);\r\ncase EEP_REG_0:\r\nreturn pBase->regDmn[0];\r\ncase EEP_OP_CAP:\r\nreturn pBase->deviceCap;\r\ncase EEP_OP_MODE:\r\nreturn pBase->opCapFlags;\r\ncase EEP_RF_SILENT:\r\nreturn pBase->rfSilent;\r\ncase EEP_MINOR_REV:\r\nreturn ver_minor;\r\ncase EEP_TX_MASK:\r\nreturn pBase->txMask;\r\ncase EEP_RX_MASK:\r\nreturn pBase->rxMask;\r\ncase EEP_DEV_TYPE:\r\nreturn pBase->deviceType;\r\ncase EEP_OL_PWRCTRL:\r\nreturn pBase->openLoopPwrCntl;\r\ncase EEP_TEMPSENSE_SLOPE:\r\nif (ver_minor >= AR9287_EEP_MINOR_VER_2)\r\nreturn pBase->tempSensSlope;\r\nelse\r\nreturn 0;\r\ncase EEP_TEMPSENSE_SLOPE_PAL_ON:\r\nif (ver_minor >= AR9287_EEP_MINOR_VER_3)\r\nreturn pBase->tempSensSlopePalOn;\r\nelse\r\nreturn 0;\r\ncase EEP_ANTENNA_GAIN_2G:\r\nreturn max_t(u8, pModal->antennaGainCh[0],\r\npModal->antennaGainCh[1]);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void ar9287_eeprom_get_tx_gain_index(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nstruct cal_data_op_loop_ar9287 *pRawDatasetOpLoop,\r\nu8 *pCalChans, u16 availPiers, int8_t *pPwr)\r\n{\r\nu16 idxL = 0, idxR = 0, numPiers;\r\nbool match;\r\nstruct chan_centers centers;\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nfor (numPiers = 0; numPiers < availPiers; numPiers++) {\r\nif (pCalChans[numPiers] == AR5416_BCHAN_UNUSED)\r\nbreak;\r\n}\r\nmatch = ath9k_hw_get_lower_upper_index(\r\n(u8)FREQ2FBIN(centers.synth_center, IS_CHAN_2GHZ(chan)),\r\npCalChans, numPiers, &idxL, &idxR);\r\nif (match) {\r\n*pPwr = (int8_t) pRawDatasetOpLoop[idxL].pwrPdg[0][0];\r\n} else {\r\n*pPwr = ((int8_t) pRawDatasetOpLoop[idxL].pwrPdg[0][0] +\r\n(int8_t) pRawDatasetOpLoop[idxR].pwrPdg[0][0])/2;\r\n}\r\n}\r\nstatic void ar9287_eeprom_olpc_set_pdadcs(struct ath_hw *ah,\r\nint32_t txPower, u16 chain)\r\n{\r\nu32 tmpVal;\r\nu32 a;\r\ntmpVal = REG_READ(ah, 0xa270);\r\ntmpVal = tmpVal & 0xFCFFFFFF;\r\ntmpVal = tmpVal | (0x3 << 24);\r\nREG_WRITE(ah, 0xa270, tmpVal);\r\ntmpVal = REG_READ(ah, 0xb270);\r\ntmpVal = tmpVal & 0xFCFFFFFF;\r\ntmpVal = tmpVal | (0x3 << 24);\r\nREG_WRITE(ah, 0xb270, tmpVal);\r\nif (chain == 0) {\r\ntmpVal = REG_READ(ah, 0xa398);\r\ntmpVal = tmpVal & 0xff00ffff;\r\na = (txPower)&0xff;\r\ntmpVal = tmpVal | (a << 16);\r\nREG_WRITE(ah, 0xa398, tmpVal);\r\n}\r\nif (chain == 1) {\r\ntmpVal = REG_READ(ah, 0xb398);\r\ntmpVal = tmpVal & 0xff00ffff;\r\na = (txPower)&0xff;\r\ntmpVal = tmpVal | (a << 16);\r\nREG_WRITE(ah, 0xb398, tmpVal);\r\n}\r\n}\r\nstatic void ath9k_hw_set_ar9287_power_cal_table(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct cal_data_per_freq_ar9287 *pRawDataset;\r\nstruct cal_data_op_loop_ar9287 *pRawDatasetOpenLoop;\r\nu8 *pCalBChans = NULL;\r\nu16 pdGainOverlap_t2;\r\nu8 pdadcValues[AR5416_NUM_PDADC_VALUES];\r\nu16 gainBoundaries[AR5416_PD_GAINS_IN_MASK];\r\nu16 numPiers = 0, i, j;\r\nu16 numXpdGain, xpdMask;\r\nu16 xpdGainValues[AR5416_NUM_PD_GAINS] = {0, 0, 0, 0};\r\nu32 reg32, regOffset, regChainOffset, regval;\r\nint16_t diff = 0;\r\nstruct ar9287_eeprom *pEepData = &ah->eeprom.map9287;\r\nxpdMask = pEepData->modalHeader.xpdGain;\r\nif ((pEepData->baseEepHeader.version & AR9287_EEP_VER_MINOR_MASK) >=\r\nAR9287_EEP_MINOR_VER_2)\r\npdGainOverlap_t2 = pEepData->modalHeader.pdGainOverlap;\r\nelse\r\npdGainOverlap_t2 = (u16)(MS(REG_READ(ah, AR_PHY_TPCRG5),\r\nAR_PHY_TPCRG5_PD_GAIN_OVERLAP));\r\nif (IS_CHAN_2GHZ(chan)) {\r\npCalBChans = pEepData->calFreqPier2G;\r\nnumPiers = AR9287_NUM_2G_CAL_PIERS;\r\nif (ath9k_hw_ar9287_get_eeprom(ah, EEP_OL_PWRCTRL)) {\r\npRawDatasetOpenLoop =\r\n(struct cal_data_op_loop_ar9287 *)pEepData->calPierData2G[0];\r\nah->initPDADC = pRawDatasetOpenLoop->vpdPdg[0][0];\r\n}\r\n}\r\nnumXpdGain = 0;\r\nfor (i = 1; i <= AR5416_PD_GAINS_IN_MASK; i++) {\r\nif ((xpdMask >> (AR5416_PD_GAINS_IN_MASK - i)) & 1) {\r\nif (numXpdGain >= AR5416_NUM_PD_GAINS)\r\nbreak;\r\nxpdGainValues[numXpdGain] =\r\n(u16)(AR5416_PD_GAINS_IN_MASK-i);\r\nnumXpdGain++;\r\n}\r\n}\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_NUM_PD_GAIN,\r\n(numXpdGain - 1) & 0x3);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_1,\r\nxpdGainValues[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_2,\r\nxpdGainValues[1]);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_3,\r\nxpdGainValues[2]);\r\nfor (i = 0; i < AR9287_MAX_CHAINS; i++) {\r\nregChainOffset = i * 0x1000;\r\nif (pEepData->baseEepHeader.txMask & (1 << i)) {\r\npRawDatasetOpenLoop =\r\n(struct cal_data_op_loop_ar9287 *)pEepData->calPierData2G[i];\r\nif (ath9k_hw_ar9287_get_eeprom(ah, EEP_OL_PWRCTRL)) {\r\nint8_t txPower;\r\nar9287_eeprom_get_tx_gain_index(ah, chan,\r\npRawDatasetOpenLoop,\r\npCalBChans, numPiers,\r\n&txPower);\r\nar9287_eeprom_olpc_set_pdadcs(ah, txPower, i);\r\n} else {\r\npRawDataset =\r\n(struct cal_data_per_freq_ar9287 *)\r\npEepData->calPierData2G[i];\r\nath9k_hw_get_gain_boundaries_pdadcs(ah, chan,\r\npRawDataset,\r\npCalBChans, numPiers,\r\npdGainOverlap_t2,\r\ngainBoundaries,\r\npdadcValues,\r\nnumXpdGain);\r\n}\r\nENABLE_REGWRITE_BUFFER(ah);\r\nif (i == 0) {\r\nif (!ath9k_hw_ar9287_get_eeprom(ah,\r\nEEP_OL_PWRCTRL)) {\r\nregval = SM(pdGainOverlap_t2,\r\nAR_PHY_TPCRG5_PD_GAIN_OVERLAP)\r\n| SM(gainBoundaries[0],\r\nAR_PHY_TPCRG5_PD_GAIN_BOUNDARY_1)\r\n| SM(gainBoundaries[1],\r\nAR_PHY_TPCRG5_PD_GAIN_BOUNDARY_2)\r\n| SM(gainBoundaries[2],\r\nAR_PHY_TPCRG5_PD_GAIN_BOUNDARY_3)\r\n| SM(gainBoundaries[3],\r\nAR_PHY_TPCRG5_PD_GAIN_BOUNDARY_4);\r\nREG_WRITE(ah,\r\nAR_PHY_TPCRG5 + regChainOffset,\r\nregval);\r\n}\r\n}\r\nif ((int32_t)AR9287_PWR_TABLE_OFFSET_DB !=\r\npEepData->baseEepHeader.pwrTableOffset) {\r\ndiff = (u16)(pEepData->baseEepHeader.pwrTableOffset -\r\n(int32_t)AR9287_PWR_TABLE_OFFSET_DB);\r\ndiff *= 2;\r\nfor (j = 0; j < ((u16)AR5416_NUM_PDADC_VALUES-diff); j++)\r\npdadcValues[j] = pdadcValues[j+diff];\r\nfor (j = (u16)(AR5416_NUM_PDADC_VALUES-diff);\r\nj < AR5416_NUM_PDADC_VALUES; j++)\r\npdadcValues[j] =\r\npdadcValues[AR5416_NUM_PDADC_VALUES-diff];\r\n}\r\nif (!ath9k_hw_ar9287_get_eeprom(ah, EEP_OL_PWRCTRL)) {\r\nregOffset = AR_PHY_BASE +\r\n(672 << 2) + regChainOffset;\r\nfor (j = 0; j < 32; j++) {\r\nreg32 = get_unaligned_le32(&pdadcValues[4 * j]);\r\nREG_WRITE(ah, regOffset, reg32);\r\nregOffset += 4;\r\n}\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\n}\r\n}\r\nstatic void ath9k_hw_set_ar9287_power_per_rate_table(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nint16_t *ratesArray,\r\nu16 cfgCtl,\r\nu16 antenna_reduction,\r\nu16 powerLimit)\r\n{\r\n#define CMP_CTL \\r\n(((cfgCtl & ~CTL_MODE_M) | (pCtlMode[ctlMode] & CTL_MODE_M)) == \\r\npEepData->ctlIndex[i])\r\n#define CMP_NO_CTL \\r\n(((cfgCtl & ~CTL_MODE_M) | (pCtlMode[ctlMode] & CTL_MODE_M)) == \\r\n((pEepData->ctlIndex[i] & CTL_MODE_M) | SD_NO_CTL))\r\nu16 twiceMaxEdgePower;\r\nint i;\r\nstruct cal_ctl_data_ar9287 *rep;\r\nstruct cal_target_power_leg targetPowerOfdm = {0, {0, 0, 0, 0} },\r\ntargetPowerCck = {0, {0, 0, 0, 0} };\r\nstruct cal_target_power_leg targetPowerOfdmExt = {0, {0, 0, 0, 0} },\r\ntargetPowerCckExt = {0, {0, 0, 0, 0} };\r\nstruct cal_target_power_ht targetPowerHt20,\r\ntargetPowerHt40 = {0, {0, 0, 0, 0} };\r\nu16 scaledPower = 0, minCtlPower;\r\nstatic const u16 ctlModesFor11g[] = {\r\nCTL_11B, CTL_11G, CTL_2GHT20,\r\nCTL_11B_EXT, CTL_11G_EXT, CTL_2GHT40\r\n};\r\nu16 numCtlModes = 0;\r\nconst u16 *pCtlMode = NULL;\r\nu16 ctlMode, freq;\r\nstruct chan_centers centers;\r\nint tx_chainmask;\r\nu16 twiceMinEdgePower;\r\nstruct ar9287_eeprom *pEepData = &ah->eeprom.map9287;\r\ntx_chainmask = ah->txchainmask;\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nscaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,\r\nantenna_reduction);\r\nif (IS_CHAN_2GHZ(chan)) {\r\nnumCtlModes =\r\nARRAY_SIZE(ctlModesFor11g) - SUB_NUM_CTL_MODES_AT_2G_40;\r\npCtlMode = ctlModesFor11g;\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPowerCck,\r\nAR9287_NUM_2G_CCK_TARGET_POWERS,\r\n&targetPowerCck, 4, false);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPower2G,\r\nAR9287_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerOfdm, 4, false);\r\nath9k_hw_get_target_powers(ah, chan,\r\npEepData->calTargetPower2GHT20,\r\nAR9287_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerHt20, 8, false);\r\nif (IS_CHAN_HT40(chan)) {\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11g);\r\nath9k_hw_get_target_powers(ah, chan,\r\npEepData->calTargetPower2GHT40,\r\nAR9287_NUM_2G_40_TARGET_POWERS,\r\n&targetPowerHt40, 8, true);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPowerCck,\r\nAR9287_NUM_2G_CCK_TARGET_POWERS,\r\n&targetPowerCckExt, 4, true);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPower2G,\r\nAR9287_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerOfdmExt, 4, true);\r\n}\r\n}\r\nfor (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {\r\nbool isHt40CtlMode =\r\n(pCtlMode[ctlMode] == CTL_2GHT40) ? true : false;\r\nif (isHt40CtlMode)\r\nfreq = centers.synth_center;\r\nelse if (pCtlMode[ctlMode] & EXT_ADDITIVE)\r\nfreq = centers.ext_center;\r\nelse\r\nfreq = centers.ctl_center;\r\ntwiceMaxEdgePower = MAX_RATE_POWER;\r\nfor (i = 0; (i < AR9287_NUM_CTLS) && pEepData->ctlIndex[i]; i++) {\r\nstruct cal_ctl_edges *pRdEdgesPower;\r\nif (CMP_CTL || CMP_NO_CTL) {\r\nrep = &(pEepData->ctlData[i]);\r\npRdEdgesPower =\r\nrep->ctlEdges[ar5416_get_ntxchains(tx_chainmask) - 1];\r\ntwiceMinEdgePower = ath9k_hw_get_max_edge_power(freq,\r\npRdEdgesPower,\r\nIS_CHAN_2GHZ(chan),\r\nAR5416_NUM_BAND_EDGES);\r\nif ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL) {\r\ntwiceMaxEdgePower = min(twiceMaxEdgePower,\r\ntwiceMinEdgePower);\r\n} else {\r\ntwiceMaxEdgePower = twiceMinEdgePower;\r\nbreak;\r\n}\r\n}\r\n}\r\nminCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);\r\nswitch (pCtlMode[ctlMode]) {\r\ncase CTL_11B:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerCck.tPow2x); i++) {\r\ntargetPowerCck.tPow2x[i] =\r\n(u8)min((u16)targetPowerCck.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_11A:\r\ncase CTL_11G:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerOfdm.tPow2x); i++) {\r\ntargetPowerOfdm.tPow2x[i] =\r\n(u8)min((u16)targetPowerOfdm.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_5GHT20:\r\ncase CTL_2GHT20:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++) {\r\ntargetPowerHt20.tPow2x[i] =\r\n(u8)min((u16)targetPowerHt20.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_11B_EXT:\r\ntargetPowerCckExt.tPow2x[0] =\r\n(u8)min((u16)targetPowerCckExt.tPow2x[0],\r\nminCtlPower);\r\nbreak;\r\ncase CTL_11A_EXT:\r\ncase CTL_11G_EXT:\r\ntargetPowerOfdmExt.tPow2x[0] =\r\n(u8)min((u16)targetPowerOfdmExt.tPow2x[0],\r\nminCtlPower);\r\nbreak;\r\ncase CTL_5GHT40:\r\ncase CTL_2GHT40:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\r\ntargetPowerHt40.tPow2x[i] =\r\n(u8)min((u16)targetPowerHt40.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nratesArray[rate6mb] =\r\nratesArray[rate9mb] =\r\nratesArray[rate12mb] =\r\nratesArray[rate18mb] =\r\nratesArray[rate24mb] = targetPowerOfdm.tPow2x[0];\r\nratesArray[rate36mb] = targetPowerOfdm.tPow2x[1];\r\nratesArray[rate48mb] = targetPowerOfdm.tPow2x[2];\r\nratesArray[rate54mb] = targetPowerOfdm.tPow2x[3];\r\nratesArray[rateXr] = targetPowerOfdm.tPow2x[0];\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++)\r\nratesArray[rateHt20_0 + i] = targetPowerHt20.tPow2x[i];\r\nif (IS_CHAN_2GHZ(chan)) {\r\nratesArray[rate1l] = targetPowerCck.tPow2x[0];\r\nratesArray[rate2s] =\r\nratesArray[rate2l] = targetPowerCck.tPow2x[1];\r\nratesArray[rate5_5s] =\r\nratesArray[rate5_5l] = targetPowerCck.tPow2x[2];\r\nratesArray[rate11s] =\r\nratesArray[rate11l] = targetPowerCck.tPow2x[3];\r\n}\r\nif (IS_CHAN_HT40(chan)) {\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++)\r\nratesArray[rateHt40_0 + i] = targetPowerHt40.tPow2x[i];\r\nratesArray[rateDupOfdm] = targetPowerHt40.tPow2x[0];\r\nratesArray[rateDupCck] = targetPowerHt40.tPow2x[0];\r\nratesArray[rateExtOfdm] = targetPowerOfdmExt.tPow2x[0];\r\nif (IS_CHAN_2GHZ(chan))\r\nratesArray[rateExtCck] = targetPowerCckExt.tPow2x[0];\r\n}\r\n#undef CMP_CTL\r\n#undef CMP_NO_CTL\r\n}\r\nstatic void ath9k_hw_ar9287_set_txpower(struct ath_hw *ah,\r\nstruct ath9k_channel *chan, u16 cfgCtl,\r\nu8 twiceAntennaReduction,\r\nu8 powerLimit, bool test)\r\n{\r\nstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\r\nstruct ar9287_eeprom *pEepData = &ah->eeprom.map9287;\r\nstruct modal_eep_ar9287_header *pModal = &pEepData->modalHeader;\r\nint16_t ratesArray[Ar5416RateSize];\r\nu8 ht40PowerIncForPdadc = 2;\r\nint i;\r\nmemset(ratesArray, 0, sizeof(ratesArray));\r\nif ((pEepData->baseEepHeader.version & AR9287_EEP_VER_MINOR_MASK) >=\r\nAR9287_EEP_MINOR_VER_2)\r\nht40PowerIncForPdadc = pModal->ht40PowerIncForPdadc;\r\nath9k_hw_set_ar9287_power_per_rate_table(ah, chan,\r\n&ratesArray[0], cfgCtl,\r\ntwiceAntennaReduction,\r\npowerLimit);\r\nath9k_hw_set_ar9287_power_cal_table(ah, chan);\r\nregulatory->max_power_level = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ratesArray); i++) {\r\nif (ratesArray[i] > MAX_RATE_POWER)\r\nratesArray[i] = MAX_RATE_POWER;\r\nif (ratesArray[i] > regulatory->max_power_level)\r\nregulatory->max_power_level = ratesArray[i];\r\n}\r\nath9k_hw_update_regulatory_maxpower(ah);\r\nif (test)\r\nreturn;\r\nfor (i = 0; i < Ar5416RateSize; i++)\r\nratesArray[i] -= AR9287_PWR_TABLE_OFFSET_DB * 2;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE1,\r\nATH9K_POW_SM(ratesArray[rate18mb], 24)\r\n| ATH9K_POW_SM(ratesArray[rate12mb], 16)\r\n| ATH9K_POW_SM(ratesArray[rate9mb], 8)\r\n| ATH9K_POW_SM(ratesArray[rate6mb], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE2,\r\nATH9K_POW_SM(ratesArray[rate54mb], 24)\r\n| ATH9K_POW_SM(ratesArray[rate48mb], 16)\r\n| ATH9K_POW_SM(ratesArray[rate36mb], 8)\r\n| ATH9K_POW_SM(ratesArray[rate24mb], 0));\r\nif (IS_CHAN_2GHZ(chan)) {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE3,\r\nATH9K_POW_SM(ratesArray[rate2s], 24)\r\n| ATH9K_POW_SM(ratesArray[rate2l], 16)\r\n| ATH9K_POW_SM(ratesArray[rateXr], 8)\r\n| ATH9K_POW_SM(ratesArray[rate1l], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE4,\r\nATH9K_POW_SM(ratesArray[rate11s], 24)\r\n| ATH9K_POW_SM(ratesArray[rate11l], 16)\r\n| ATH9K_POW_SM(ratesArray[rate5_5s], 8)\r\n| ATH9K_POW_SM(ratesArray[rate5_5l], 0));\r\n}\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE5,\r\nATH9K_POW_SM(ratesArray[rateHt20_3], 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_2], 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_1], 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_0], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE6,\r\nATH9K_POW_SM(ratesArray[rateHt20_7], 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_6], 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_5], 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_4], 0));\r\nif (IS_CHAN_HT40(chan)) {\r\nif (ath9k_hw_ar9287_get_eeprom(ah, EEP_OL_PWRCTRL)) {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE7,\r\nATH9K_POW_SM(ratesArray[rateHt40_3], 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_2], 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_1], 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_0], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE8,\r\nATH9K_POW_SM(ratesArray[rateHt40_7], 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_6], 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_5], 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_4], 0));\r\n} else {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE7,\r\nATH9K_POW_SM(ratesArray[rateHt40_3] +\r\nht40PowerIncForPdadc, 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_2] +\r\nht40PowerIncForPdadc, 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_1] +\r\nht40PowerIncForPdadc, 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_0] +\r\nht40PowerIncForPdadc, 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE8,\r\nATH9K_POW_SM(ratesArray[rateHt40_7] +\r\nht40PowerIncForPdadc, 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_6] +\r\nht40PowerIncForPdadc, 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_5] +\r\nht40PowerIncForPdadc, 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_4] +\r\nht40PowerIncForPdadc, 0));\r\n}\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE9,\r\nATH9K_POW_SM(ratesArray[rateExtOfdm], 24)\r\n| ATH9K_POW_SM(ratesArray[rateExtCck], 16)\r\n| ATH9K_POW_SM(ratesArray[rateDupOfdm], 8)\r\n| ATH9K_POW_SM(ratesArray[rateDupCck], 0));\r\n}\r\nif (ah->tpc_enabled) {\r\nint ht40_delta;\r\nht40_delta = (IS_CHAN_HT40(chan)) ? ht40PowerIncForPdadc : 0;\r\nar5008_hw_init_rate_txpower(ah, ratesArray, chan, ht40_delta);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX,\r\nMAX_RATE_POWER | AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE);\r\n} else {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX, MAX_RATE_POWER);\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nstatic void ath9k_hw_ar9287_set_board_values(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\r\nstruct modal_eep_ar9287_header *pModal = &eep->modalHeader;\r\nu32 regChainOffset, regval;\r\nu8 txRxAttenLocal;\r\nint i;\r\npModal = &eep->modalHeader;\r\nREG_WRITE(ah, AR_PHY_SWITCH_COM, pModal->antCtrlCommon);\r\nfor (i = 0; i < AR9287_MAX_CHAINS; i++) {\r\nregChainOffset = i * 0x1000;\r\nREG_WRITE(ah, AR_PHY_SWITCH_CHAIN_0 + regChainOffset,\r\npModal->antCtrlChain[i]);\r\nREG_WRITE(ah, AR_PHY_TIMING_CTRL4(0) + regChainOffset,\r\n(REG_READ(ah, AR_PHY_TIMING_CTRL4(0) + regChainOffset)\r\n& ~(AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF |\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF)) |\r\nSM(pModal->iqCalICh[i],\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF) |\r\nSM(pModal->iqCalQCh[i],\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF));\r\ntxRxAttenLocal = pModal->txRxAttenCh[i];\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nAR_PHY_GAIN_2GHZ_XATTEN1_MARGIN,\r\npModal->bswMargin[i]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\r\nAR_PHY_GAIN_2GHZ_XATTEN1_DB,\r\npModal->bswAtten[i]);\r\nREG_RMW_FIELD(ah, AR_PHY_RXGAIN + regChainOffset,\r\nAR9280_PHY_RXGAIN_TXRX_ATTEN,\r\ntxRxAttenLocal);\r\nREG_RMW_FIELD(ah, AR_PHY_RXGAIN + regChainOffset,\r\nAR9280_PHY_RXGAIN_TXRX_MARGIN,\r\npModal->rxTxMarginCh[i]);\r\n}\r\nif (IS_CHAN_HT40(chan))\r\nREG_RMW_FIELD(ah, AR_PHY_SETTLING,\r\nAR_PHY_SETTLING_SWITCH, pModal->swSettleHt40);\r\nelse\r\nREG_RMW_FIELD(ah, AR_PHY_SETTLING,\r\nAR_PHY_SETTLING_SWITCH, pModal->switchSettling);\r\nREG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ,\r\nAR_PHY_DESIRED_SZ_ADC, pModal->adcDesiredSize);\r\nREG_WRITE(ah, AR_PHY_RF_CTL4,\r\nSM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAA_OFF)\r\n| SM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAB_OFF)\r\n| SM(pModal->txFrameToXpaOn, AR_PHY_RF_CTL4_FRAME_XPAA_ON)\r\n| SM(pModal->txFrameToXpaOn, AR_PHY_RF_CTL4_FRAME_XPAB_ON));\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL3,\r\nAR_PHY_TX_END_TO_A2_RX_ON, pModal->txEndToRxOn);\r\nREG_RMW_FIELD(ah, AR_PHY_CCA,\r\nAR9280_PHY_CCA_THRESH62, pModal->thresh62);\r\nREG_RMW_FIELD(ah, AR_PHY_EXT_CCA0,\r\nAR_PHY_EXT_CCA0_THRESH62, pModal->thresh62);\r\nregval = REG_READ(ah, AR9287_AN_RF2G3_CH0);\r\nregval &= ~(AR9287_AN_RF2G3_DB1 |\r\nAR9287_AN_RF2G3_DB2 |\r\nAR9287_AN_RF2G3_OB_CCK |\r\nAR9287_AN_RF2G3_OB_PSK |\r\nAR9287_AN_RF2G3_OB_QAM |\r\nAR9287_AN_RF2G3_OB_PAL_OFF);\r\nregval |= (SM(pModal->db1, AR9287_AN_RF2G3_DB1) |\r\nSM(pModal->db2, AR9287_AN_RF2G3_DB2) |\r\nSM(pModal->ob_cck, AR9287_AN_RF2G3_OB_CCK) |\r\nSM(pModal->ob_psk, AR9287_AN_RF2G3_OB_PSK) |\r\nSM(pModal->ob_qam, AR9287_AN_RF2G3_OB_QAM) |\r\nSM(pModal->ob_pal_off, AR9287_AN_RF2G3_OB_PAL_OFF));\r\nath9k_hw_analog_shift_regwrite(ah, AR9287_AN_RF2G3_CH0, regval);\r\nregval = REG_READ(ah, AR9287_AN_RF2G3_CH1);\r\nregval &= ~(AR9287_AN_RF2G3_DB1 |\r\nAR9287_AN_RF2G3_DB2 |\r\nAR9287_AN_RF2G3_OB_CCK |\r\nAR9287_AN_RF2G3_OB_PSK |\r\nAR9287_AN_RF2G3_OB_QAM |\r\nAR9287_AN_RF2G3_OB_PAL_OFF);\r\nregval |= (SM(pModal->db1, AR9287_AN_RF2G3_DB1) |\r\nSM(pModal->db2, AR9287_AN_RF2G3_DB2) |\r\nSM(pModal->ob_cck, AR9287_AN_RF2G3_OB_CCK) |\r\nSM(pModal->ob_psk, AR9287_AN_RF2G3_OB_PSK) |\r\nSM(pModal->ob_qam, AR9287_AN_RF2G3_OB_QAM) |\r\nSM(pModal->ob_pal_off, AR9287_AN_RF2G3_OB_PAL_OFF));\r\nath9k_hw_analog_shift_regwrite(ah, AR9287_AN_RF2G3_CH1, regval);\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL2,\r\nAR_PHY_TX_END_DATA_START, pModal->txFrameToDataStart);\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL2,\r\nAR_PHY_TX_END_PA_ON, pModal->txFrameToPaOn);\r\nath9k_hw_analog_shift_rmw(ah, AR9287_AN_TOP2,\r\nAR9287_AN_TOP2_XPABIAS_LVL,\r\nAR9287_AN_TOP2_XPABIAS_LVL_S,\r\npModal->xpaBiasLvl);\r\n}\r\nstatic u16 ath9k_hw_ar9287_get_spur_channel(struct ath_hw *ah,\r\nu16 i, bool is2GHz)\r\n{\r\nreturn ah->eeprom.map9287.modalHeader.spurChans[i].spurChan;\r\n}
