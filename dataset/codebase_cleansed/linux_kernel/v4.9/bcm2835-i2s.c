static void bcm2835_i2s_start_clock(struct bcm2835_i2s_dev *dev)\r\n{\r\nunsigned int master = dev->fmt & SND_SOC_DAIFMT_MASTER_MASK;\r\nif (dev->clk_prepared)\r\nreturn;\r\nswitch (master) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nclk_prepare_enable(dev->clk);\r\ndev->clk_prepared = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void bcm2835_i2s_stop_clock(struct bcm2835_i2s_dev *dev)\r\n{\r\nif (dev->clk_prepared)\r\nclk_disable_unprepare(dev->clk);\r\ndev->clk_prepared = false;\r\n}\r\nstatic void bcm2835_i2s_clear_fifos(struct bcm2835_i2s_dev *dev,\r\nbool tx, bool rx)\r\n{\r\nint timeout = 1000;\r\nuint32_t syncval;\r\nuint32_t csreg;\r\nuint32_t i2s_active_state;\r\nbool clk_was_prepared;\r\nuint32_t off;\r\nuint32_t clr;\r\noff = tx ? BCM2835_I2S_TXON : 0;\r\noff |= rx ? BCM2835_I2S_RXON : 0;\r\nclr = tx ? BCM2835_I2S_TXCLR : 0;\r\nclr |= rx ? BCM2835_I2S_RXCLR : 0;\r\nregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &csreg);\r\ni2s_active_state = csreg & (BCM2835_I2S_RXON | BCM2835_I2S_TXON);\r\nclk_was_prepared = dev->clk_prepared;\r\nif (!clk_was_prepared)\r\nbcm2835_i2s_start_clock(dev);\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, off, 0);\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, clr, clr);\r\nregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &syncval);\r\nsyncval &= BCM2835_I2S_SYNC;\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\r\nBCM2835_I2S_SYNC, ~syncval);\r\nwhile (--timeout) {\r\nregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &csreg);\r\nif ((csreg & BCM2835_I2S_SYNC) != syncval)\r\nbreak;\r\n}\r\nif (!timeout)\r\ndev_err(dev->dev, "I2S SYNC error!\n");\r\nif (!clk_was_prepared)\r\nbcm2835_i2s_stop_clock(dev);\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\r\nBCM2835_I2S_RXON | BCM2835_I2S_TXON, i2s_active_state);\r\n}\r\nstatic int bcm2835_i2s_set_dai_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\ndev->fmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int bcm2835_i2s_set_dai_bclk_ratio(struct snd_soc_dai *dai,\r\nunsigned int ratio)\r\n{\r\nstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\ndev->bclk_ratio = ratio;\r\nreturn 0;\r\n}\r\nstatic int bcm2835_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nunsigned int sampling_rate = params_rate(params);\r\nunsigned int data_length, data_delay, bclk_ratio;\r\nunsigned int ch1pos, ch2pos, mode, format;\r\nuint32_t csreg;\r\nregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &csreg);\r\nif (csreg & (BCM2835_I2S_TXON | BCM2835_I2S_RXON))\r\nreturn 0;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndata_length = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ndata_length = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndata_length = 32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (dev->bclk_ratio)\r\nbclk_ratio = dev->bclk_ratio;\r\nelse\r\nbclk_ratio = 2 * data_length;\r\nswitch (dev->fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nclk_set_rate(dev->clk, sampling_rate * bclk_ratio);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nformat = BCM2835_I2S_CHEN;\r\nif (data_length >= 24)\r\nformat |= BCM2835_I2S_CHWEX;\r\nformat |= BCM2835_I2S_CHWID((data_length-8)&0xf);\r\nswitch (dev->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ndata_delay = 1;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "%s:bad format\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nch1pos = data_delay;\r\nch2pos = bclk_ratio / 2 + data_delay;\r\nswitch (params_channels(params)) {\r\ncase 2:\r\nformat = BCM2835_I2S_CH1(format) | BCM2835_I2S_CH2(format);\r\nformat |= BCM2835_I2S_CH1(BCM2835_I2S_CHPOS(ch1pos));\r\nformat |= BCM2835_I2S_CH2(BCM2835_I2S_CHPOS(ch2pos));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_write(dev->i2s_regmap, BCM2835_I2S_RXC_A_REG, format);\r\nregmap_write(dev->i2s_regmap, BCM2835_I2S_TXC_A_REG, format);\r\nmode = 0;\r\nif (data_length <= 16) {\r\nmode |= BCM2835_I2S_FTXP | BCM2835_I2S_FRXP;\r\n}\r\nmode |= BCM2835_I2S_FLEN(bclk_ratio - 1);\r\nmode |= BCM2835_I2S_FSLEN(bclk_ratio / 2);\r\nswitch (dev->fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nmode |= BCM2835_I2S_CLKM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nmode |= BCM2835_I2S_FSM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmode |= BCM2835_I2S_CLKM;\r\nmode |= BCM2835_I2S_FSM;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "%s:bad master\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (dev->fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nmode |= BCM2835_I2S_CLKI;\r\nmode |= BCM2835_I2S_FSI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nmode |= BCM2835_I2S_CLKI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nmode |= BCM2835_I2S_FSI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_write(dev->i2s_regmap, BCM2835_I2S_MODE_A_REG, mode);\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\r\nBCM2835_I2S_RXTHR(1)\r\n| BCM2835_I2S_TXTHR(1)\r\n| BCM2835_I2S_DMAEN, 0xffffffff);\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_DREQ_A_REG,\r\nBCM2835_I2S_TX_PANIC(0x10)\r\n| BCM2835_I2S_RX_PANIC(0x30)\r\n| BCM2835_I2S_TX(0x30)\r\n| BCM2835_I2S_RX(0x20), 0xffffffff);\r\nbcm2835_i2s_clear_fifos(dev, true, true);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_i2s_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nuint32_t cs_reg;\r\nbcm2835_i2s_start_clock(dev);\r\nregmap_read(dev->i2s_regmap, BCM2835_I2S_CS_A_REG, &cs_reg);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK\r\n&& !(cs_reg & BCM2835_I2S_TXE))\r\nbcm2835_i2s_clear_fifos(dev, true, false);\r\nelse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE\r\n&& (cs_reg & BCM2835_I2S_RXD))\r\nbcm2835_i2s_clear_fifos(dev, false, true);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_i2s_stop(struct bcm2835_i2s_dev *dev,\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nuint32_t mask;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nmask = BCM2835_I2S_RXON;\r\nelse\r\nmask = BCM2835_I2S_TXON;\r\nregmap_update_bits(dev->i2s_regmap,\r\nBCM2835_I2S_CS_A_REG, mask, 0);\r\nif (!dai->active && !(dev->fmt & SND_SOC_DAIFMT_CONT))\r\nbcm2835_i2s_stop_clock(dev);\r\n}\r\nstatic int bcm2835_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nuint32_t mask;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nbcm2835_i2s_start_clock(dev);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nmask = BCM2835_I2S_RXON;\r\nelse\r\nmask = BCM2835_I2S_TXON;\r\nregmap_update_bits(dev->i2s_regmap,\r\nBCM2835_I2S_CS_A_REG, mask, mask);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nbcm2835_i2s_stop(dev, substream, dai);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm2835_i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nif (dai->active)\r\nreturn 0;\r\nbcm2835_i2s_stop_clock(dev);\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\r\nBCM2835_I2S_EN, BCM2835_I2S_EN);\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\r\nBCM2835_I2S_STBY, BCM2835_I2S_STBY);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nbcm2835_i2s_stop(dev, substream, dai);\r\nif (dai->active)\r\nreturn;\r\nregmap_update_bits(dev->i2s_regmap, BCM2835_I2S_CS_A_REG,\r\nBCM2835_I2S_EN, 0);\r\nbcm2835_i2s_stop_clock(dev);\r\n}\r\nstatic int bcm2835_i2s_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct bcm2835_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai,\r\n&dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK],\r\n&dev->dma_data[SNDRV_PCM_STREAM_CAPTURE]);\r\nreturn 0;\r\n}\r\nstatic bool bcm2835_i2s_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase BCM2835_I2S_CS_A_REG:\r\ncase BCM2835_I2S_FIFO_A_REG:\r\ncase BCM2835_I2S_INTSTC_A_REG:\r\ncase BCM2835_I2S_GRAY_REG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic bool bcm2835_i2s_precious_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase BCM2835_I2S_FIFO_A_REG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic int bcm2835_i2s_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm2835_i2s_dev *dev;\r\nint ret;\r\nstruct resource *mem;\r\nvoid __iomem *base;\r\nconst __be32 *addr;\r\ndma_addr_t dma_base;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev),\r\nGFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->clk_prepared = false;\r\ndev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\ndev_err(&pdev->dev, "could not get clk: %ld\n",\r\nPTR_ERR(dev->clk));\r\nreturn PTR_ERR(dev->clk);\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndev->i2s_regmap = devm_regmap_init_mmio(&pdev->dev, base,\r\n&bcm2835_regmap_config);\r\nif (IS_ERR(dev->i2s_regmap))\r\nreturn PTR_ERR(dev->i2s_regmap);\r\naddr = of_get_address(pdev->dev.of_node, 0, NULL, NULL);\r\nif (!addr) {\r\ndev_err(&pdev->dev, "could not get DMA-register address\n");\r\nreturn -EINVAL;\r\n}\r\ndma_base = be32_to_cpup(addr);\r\ndev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr =\r\ndma_base + BCM2835_I2S_FIFO_A_REG;\r\ndev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr =\r\ndma_base + BCM2835_I2S_FIFO_A_REG;\r\ndev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].addr_width =\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndev->dma_data[SNDRV_PCM_STREAM_CAPTURE].addr_width =\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].maxburst = 2;\r\ndev->dma_data[SNDRV_PCM_STREAM_CAPTURE].maxburst = 2;\r\ndev->dma_data[SNDRV_PCM_STREAM_PLAYBACK].flags =\r\nSND_DMAENGINE_PCM_DAI_FLAG_PACK;\r\ndev->dma_data[SNDRV_PCM_STREAM_CAPTURE].flags =\r\nSND_DMAENGINE_PCM_DAI_FLAG_PACK;\r\ndev->bclk_ratio = 0;\r\ndev->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, dev);\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&bcm2835_i2s_component, &bcm2835_i2s_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register DAI: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register PCM: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
