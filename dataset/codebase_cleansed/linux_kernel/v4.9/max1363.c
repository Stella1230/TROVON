static const struct max1363_mode\r\n*max1363_match_mode(const unsigned long *mask,\r\nconst struct max1363_chip_info *ci)\r\n{\r\nint i;\r\nif (mask)\r\nfor (i = 0; i < ci->num_modes; i++)\r\nif (bitmap_subset(mask,\r\nmax1363_mode_table[ci->mode_list[i]].\r\nmodemask,\r\nMAX1363_MAX_CHANNELS))\r\nreturn &max1363_mode_table[ci->mode_list[i]];\r\nreturn NULL;\r\n}\r\nstatic int max1363_smbus_send(const struct i2c_client *client, const char *buf,\r\nint count)\r\n{\r\nint i, err;\r\nfor (i = err = 0; err == 0 && i < count; ++i)\r\nerr = i2c_smbus_write_byte(client, buf[i]);\r\nreturn err ? err : count;\r\n}\r\nstatic int max1363_smbus_recv(const struct i2c_client *client, char *buf,\r\nint count)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; ++i) {\r\nret = i2c_smbus_read_byte(client);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf[i] = ret;\r\n}\r\nreturn count;\r\n}\r\nstatic int max1363_write_basic_config(struct max1363_state *st)\r\n{\r\nu8 tx_buf[2] = { st->setupbyte, st->configbyte };\r\nreturn st->send(st->client, tx_buf, 2);\r\n}\r\nstatic int max1363_set_scan_mode(struct max1363_state *st)\r\n{\r\nst->configbyte &= ~(MAX1363_CHANNEL_SEL_MASK\r\n| MAX1363_SCAN_MASK\r\n| MAX1363_SE_DE_MASK);\r\nst->configbyte |= st->current_mode->conf;\r\nreturn max1363_write_basic_config(st);\r\n}\r\nstatic int max1363_read_single_chan(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nlong m)\r\n{\r\nint ret = 0;\r\ns32 data;\r\nu8 rxbuf[2];\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nstruct i2c_client *client = st->client;\r\nmutex_lock(&indio_dev->mlock);\r\nif (st->monitor_on || iio_buffer_enabled(indio_dev)) {\r\nret = -EBUSY;\r\ngoto error_ret;\r\n}\r\nif (st->current_mode != &max1363_mode_table[chan->address]) {\r\nst->current_mode = &max1363_mode_table[chan->address];\r\nret = max1363_set_scan_mode(st);\r\nif (ret < 0)\r\ngoto error_ret;\r\n}\r\nif (st->chip_info->bits != 8) {\r\ndata = st->recv(client, rxbuf, 2);\r\nif (data < 0) {\r\nret = data;\r\ngoto error_ret;\r\n}\r\ndata = (rxbuf[1] | rxbuf[0] << 8) &\r\n((1 << st->chip_info->bits) - 1);\r\n} else {\r\ndata = st->recv(client, rxbuf, 1);\r\nif (data < 0) {\r\nret = data;\r\ngoto error_ret;\r\n}\r\ndata = rxbuf[0];\r\n}\r\n*val = data;\r\nerror_ret:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int max1363_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nint ret;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = max1363_read_single_chan(indio_dev, chan, val, m);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = st->vref_uv / 1000;\r\n*val2 = st->chip_info->bits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t max1363_monitor_show_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct max1363_state *st = iio_priv(dev_to_iio_dev(dev));\r\nreturn sprintf(buf, "%d\n", max1363_monitor_speeds[st->monitor_speed]);\r\n}\r\nstatic ssize_t max1363_monitor_store_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nint i, ret;\r\nunsigned long val;\r\nbool found = false;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(max1363_monitor_speeds); i++)\r\nif (val == max1363_monitor_speeds[i]) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nst->monitor_speed = i;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn 0;\r\n}\r\nstatic int max1363_read_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info, int *val,\r\nint *val2)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nif (dir == IIO_EV_DIR_FALLING)\r\n*val = st->thresh_low[chan->channel];\r\nelse\r\n*val = st->thresh_high[chan->channel];\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int max1363_write_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info, int val,\r\nint val2)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nswitch (st->chip_info->bits) {\r\ncase 10:\r\nif (val > 0x3FF)\r\nreturn -EINVAL;\r\nbreak;\r\ncase 12:\r\nif (val > 0xFFF)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nswitch (dir) {\r\ncase IIO_EV_DIR_FALLING:\r\nst->thresh_low[chan->channel] = val;\r\nbreak;\r\ncase IIO_EV_DIR_RISING:\r\nst->thresh_high[chan->channel] = val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t max1363_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\ns64 timestamp = iio_get_time_ns(indio_dev);\r\nunsigned long mask, loc;\r\nu8 rx;\r\nu8 tx[2] = { st->setupbyte,\r\nMAX1363_MON_INT_ENABLE | (st->monitor_speed << 1) | 0xF0 };\r\nst->recv(st->client, &rx, 1);\r\nmask = rx;\r\nfor_each_set_bit(loc, &mask, 8)\r\niio_push_event(indio_dev, max1363_event_codes[loc], timestamp);\r\nst->send(st->client, tx, 2);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max1363_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nint val;\r\nint number = chan->channel;\r\nmutex_lock(&indio_dev->mlock);\r\nif (dir == IIO_EV_DIR_FALLING)\r\nval = (1 << number) & st->mask_low;\r\nelse\r\nval = (1 << number) & st->mask_high;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn val;\r\n}\r\nstatic int max1363_monitor_mode_update(struct max1363_state *st, int enabled)\r\n{\r\nu8 *tx_buf;\r\nint ret, i = 3, j;\r\nunsigned long numelements;\r\nint len;\r\nconst long *modemask;\r\nif (!enabled) {\r\nst->setupbyte &= ~MAX1363_SETUP_MONITOR_SETUP;\r\nst->configbyte &= ~MAX1363_SCAN_MASK;\r\nst->monitor_on = false;\r\nreturn max1363_write_basic_config(st);\r\n}\r\nst->setupbyte |= MAX1363_SETUP_MONITOR_SETUP;\r\nst->configbyte &= ~(MAX1363_CHANNEL_SEL_MASK\r\n| MAX1363_SCAN_MASK\r\n| MAX1363_SE_DE_MASK);\r\nst->configbyte |= MAX1363_CONFIG_SCAN_MONITOR_MODE;\r\nif ((st->mask_low | st->mask_high) & 0x0F) {\r\nst->configbyte |= max1363_mode_table[s0to3].conf;\r\nmodemask = max1363_mode_table[s0to3].modemask;\r\n} else if ((st->mask_low | st->mask_high) & 0x30) {\r\nst->configbyte |= max1363_mode_table[d0m1to2m3].conf;\r\nmodemask = max1363_mode_table[d0m1to2m3].modemask;\r\n} else {\r\nst->configbyte |= max1363_mode_table[d1m0to3m2].conf;\r\nmodemask = max1363_mode_table[d1m0to3m2].modemask;\r\n}\r\nnumelements = bitmap_weight(modemask, MAX1363_MAX_CHANNELS);\r\nlen = 3 * numelements + 3;\r\ntx_buf = kmalloc(len, GFP_KERNEL);\r\nif (!tx_buf) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\ntx_buf[0] = st->configbyte;\r\ntx_buf[1] = st->setupbyte;\r\ntx_buf[2] = (st->monitor_speed << 1);\r\nfor (j = 0; j < 8; j++)\r\nif (test_bit(j, modemask)) {\r\nif (st->mask_low & (1 << j)) {\r\ntx_buf[i] = (st->thresh_low[j] >> 4) & 0xFF;\r\ntx_buf[i + 1] = (st->thresh_low[j] << 4) & 0xF0;\r\n} else if (j < 4) {\r\ntx_buf[i] = 0;\r\ntx_buf[i + 1] = 0;\r\n} else {\r\ntx_buf[i] = 0x80;\r\ntx_buf[i + 1] = 0;\r\n}\r\nif (st->mask_high & (1 << j)) {\r\ntx_buf[i + 1] |=\r\n(st->thresh_high[j] >> 8) & 0x0F;\r\ntx_buf[i + 2] = st->thresh_high[j] & 0xFF;\r\n} else if (j < 4) {\r\ntx_buf[i + 1] |= 0x0F;\r\ntx_buf[i + 2] = 0xFF;\r\n} else {\r\ntx_buf[i + 1] |= 0x07;\r\ntx_buf[i + 2] = 0xFF;\r\n}\r\ni += 3;\r\n}\r\nret = st->send(st->client, tx_buf, len);\r\nif (ret < 0)\r\ngoto error_ret;\r\nif (ret != len) {\r\nret = -EIO;\r\ngoto error_ret;\r\n}\r\ntx_buf[0] = st->setupbyte;\r\ntx_buf[1] = MAX1363_MON_INT_ENABLE | (st->monitor_speed << 1) | 0xF0;\r\nret = st->send(st->client, tx_buf, 2);\r\nif (ret < 0)\r\ngoto error_ret;\r\nif (ret != 2) {\r\nret = -EIO;\r\ngoto error_ret;\r\n}\r\nret = 0;\r\nst->monitor_on = true;\r\nerror_ret:\r\nkfree(tx_buf);\r\nreturn ret;\r\n}\r\nstatic inline int __max1363_check_event_mask(int thismask, int checkmask)\r\n{\r\nint ret = 0;\r\nif (thismask < 4) {\r\nif (checkmask & ~0x0F) {\r\nret = -EBUSY;\r\ngoto error_ret;\r\n}\r\n} else if (thismask < 6) {\r\nif (checkmask & ~0x30) {\r\nret = -EBUSY;\r\ngoto error_ret;\r\n}\r\n} else if (checkmask & ~0xC0)\r\nret = -EBUSY;\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int max1363_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, int state)\r\n{\r\nint ret = 0;\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nu16 unifiedmask;\r\nint number = chan->channel;\r\nmutex_lock(&indio_dev->mlock);\r\nunifiedmask = st->mask_low | st->mask_high;\r\nif (dir == IIO_EV_DIR_FALLING) {\r\nif (state == 0)\r\nst->mask_low &= ~(1 << number);\r\nelse {\r\nret = __max1363_check_event_mask((1 << number),\r\nunifiedmask);\r\nif (ret)\r\ngoto error_ret;\r\nst->mask_low |= (1 << number);\r\n}\r\n} else {\r\nif (state == 0)\r\nst->mask_high &= ~(1 << number);\r\nelse {\r\nret = __max1363_check_event_mask((1 << number),\r\nunifiedmask);\r\nif (ret)\r\ngoto error_ret;\r\nst->mask_high |= (1 << number);\r\n}\r\n}\r\nmax1363_monitor_mode_update(st, !!(st->mask_high | st->mask_low));\r\nerror_ret:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int max1363_update_scan_mode(struct iio_dev *indio_dev,\r\nconst unsigned long *scan_mask)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nst->current_mode = max1363_match_mode(scan_mask, st->chip_info);\r\nif (!st->current_mode)\r\nreturn -EINVAL;\r\nmax1363_set_scan_mode(st);\r\nreturn 0;\r\n}\r\nstatic int max1363_initial_setup(struct max1363_state *st)\r\n{\r\nst->setupbyte = MAX1363_SETUP_INT_CLOCK\r\n| MAX1363_SETUP_UNIPOLAR\r\n| MAX1363_SETUP_NORESET;\r\nif (st->vref)\r\nst->setupbyte |= MAX1363_SETUP_AIN3_IS_REF_EXT_TO_REF;\r\nelse\r\nst->setupbyte |= MAX1363_SETUP_POWER_UP_INT_REF\r\n| MAX1363_SETUP_AIN3_IS_AIN3_REF_IS_INT;\r\nst->setupbyte = MAX1363_SETUP_BYTE(st->setupbyte);\r\nst->current_mode = &max1363_mode_table[st->chip_info->default_mode];\r\nst->configbyte = MAX1363_CONFIG_BYTE(st->configbyte);\r\nreturn max1363_set_scan_mode(st);\r\n}\r\nstatic int max1363_alloc_scan_masks(struct iio_dev *indio_dev)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nunsigned long *masks;\r\nint i;\r\nmasks = devm_kzalloc(&indio_dev->dev,\r\nBITS_TO_LONGS(MAX1363_MAX_CHANNELS) * sizeof(long) *\r\n(st->chip_info->num_modes + 1), GFP_KERNEL);\r\nif (!masks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < st->chip_info->num_modes; i++)\r\nbitmap_copy(masks + BITS_TO_LONGS(MAX1363_MAX_CHANNELS)*i,\r\nmax1363_mode_table[st->chip_info->mode_list[i]]\r\n.modemask, MAX1363_MAX_CHANNELS);\r\nindio_dev->available_scan_masks = masks;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t max1363_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\n__u8 *rxbuf;\r\nint b_sent;\r\nsize_t d_size;\r\nunsigned long numvals = bitmap_weight(st->current_mode->modemask,\r\nMAX1363_MAX_CHANNELS);\r\nif (st->chip_info->bits != 8)\r\nd_size = numvals*2;\r\nelse\r\nd_size = numvals;\r\nif (indio_dev->scan_timestamp) {\r\nd_size += sizeof(s64);\r\nif (d_size % sizeof(s64))\r\nd_size += sizeof(s64) - (d_size % sizeof(s64));\r\n}\r\nif (numvals == 0)\r\ngoto done;\r\nrxbuf = kmalloc(d_size, GFP_KERNEL);\r\nif (rxbuf == NULL)\r\ngoto done;\r\nif (st->chip_info->bits != 8)\r\nb_sent = st->recv(st->client, rxbuf, numvals * 2);\r\nelse\r\nb_sent = st->recv(st->client, rxbuf, numvals);\r\nif (b_sent < 0)\r\ngoto done_free;\r\niio_push_to_buffers_with_timestamp(indio_dev, rxbuf,\r\niio_get_time_ns(indio_dev));\r\ndone_free:\r\nkfree(rxbuf);\r\ndone:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max1363_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct max1363_state *st;\r\nstruct iio_dev *indio_dev;\r\nstruct regulator *vref;\r\nconst struct of_device_id *match;\r\nindio_dev = devm_iio_device_alloc(&client->dev,\r\nsizeof(struct max1363_state));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nindio_dev->dev.of_node = client->dev.of_node;\r\nret = iio_map_array_register(indio_dev, client->dev.platform_data);\r\nif (ret < 0)\r\nreturn ret;\r\nst = iio_priv(indio_dev);\r\nst->reg = devm_regulator_get(&client->dev, "vcc");\r\nif (IS_ERR(st->reg)) {\r\nret = PTR_ERR(st->reg);\r\ngoto error_unregister_map;\r\n}\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\ngoto error_unregister_map;\r\ni2c_set_clientdata(client, indio_dev);\r\nmatch = of_match_device(of_match_ptr(max1363_of_match),\r\n&client->dev);\r\nif (match)\r\nst->chip_info = of_device_get_match_data(&client->dev);\r\nelse\r\nst->chip_info = &max1363_chip_info_tbl[id->driver_data];\r\nst->client = client;\r\nst->vref_uv = st->chip_info->int_vref_mv * 1000;\r\nvref = devm_regulator_get_optional(&client->dev, "vref");\r\nif (!IS_ERR(vref)) {\r\nint vref_uv;\r\nret = regulator_enable(vref);\r\nif (ret)\r\ngoto error_disable_reg;\r\nst->vref = vref;\r\nvref_uv = regulator_get_voltage(vref);\r\nif (vref_uv <= 0) {\r\nret = -EINVAL;\r\ngoto error_disable_reg;\r\n}\r\nst->vref_uv = vref_uv;\r\n}\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nst->send = i2c_master_send;\r\nst->recv = i2c_master_recv;\r\n} else if (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)\r\n&& st->chip_info->bits == 8) {\r\nst->send = max1363_smbus_send;\r\nst->recv = max1363_smbus_recv;\r\n} else {\r\nret = -EOPNOTSUPP;\r\ngoto error_disable_reg;\r\n}\r\nret = max1363_alloc_scan_masks(indio_dev);\r\nif (ret)\r\ngoto error_disable_reg;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->dev.of_node = client->dev.of_node;\r\nindio_dev->name = id->name;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\nindio_dev->info = st->chip_info->info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = max1363_initial_setup(st);\r\nif (ret < 0)\r\ngoto error_disable_reg;\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\n&max1363_trigger_handler, NULL);\r\nif (ret)\r\ngoto error_disable_reg;\r\nif (client->irq) {\r\nret = devm_request_threaded_irq(&client->dev, st->client->irq,\r\nNULL,\r\n&max1363_event_handler,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"max1363_event",\r\nindio_dev);\r\nif (ret)\r\ngoto error_uninit_buffer;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto error_uninit_buffer;\r\nreturn 0;\r\nerror_uninit_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerror_disable_reg:\r\nif (st->vref)\r\nregulator_disable(st->vref);\r\nregulator_disable(st->reg);\r\nerror_unregister_map:\r\niio_map_array_unregister(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int max1363_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nif (st->vref)\r\nregulator_disable(st->vref);\r\nregulator_disable(st->reg);\r\niio_map_array_unregister(indio_dev);\r\nreturn 0;\r\n}
