void stp_policy_node_get_ranges(struct stp_policy_node *policy_node,\r\nunsigned int *mstart, unsigned int *mend,\r\nunsigned int *cstart, unsigned int *cend)\r\n{\r\n*mstart = policy_node->first_master;\r\n*mend = policy_node->last_master;\r\n*cstart = policy_node->first_channel;\r\n*cend = policy_node->last_channel;\r\n}\r\nstatic inline char *stp_policy_node_name(struct stp_policy_node *policy_node)\r\n{\r\nreturn policy_node->group.cg_item.ci_name ? : "<none>";\r\n}\r\nstatic inline struct stp_policy *to_stp_policy(struct config_item *item)\r\n{\r\nreturn item ?\r\ncontainer_of(to_config_group(item), struct stp_policy, group) :\r\nNULL;\r\n}\r\nstatic inline struct stp_policy_node *\r\nto_stp_policy_node(struct config_item *item)\r\n{\r\nreturn item ?\r\ncontainer_of(to_config_group(item), struct stp_policy_node,\r\ngroup) :\r\nNULL;\r\n}\r\nstatic ssize_t\r\nstp_policy_node_masters_show(struct config_item *item, char *page)\r\n{\r\nstruct stp_policy_node *policy_node = to_stp_policy_node(item);\r\nssize_t count;\r\ncount = sprintf(page, "%u %u\n", policy_node->first_master,\r\npolicy_node->last_master);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstp_policy_node_masters_store(struct config_item *item, const char *page,\r\nsize_t count)\r\n{\r\nstruct stp_policy_node *policy_node = to_stp_policy_node(item);\r\nunsigned int first, last;\r\nstruct stm_device *stm;\r\nchar *p = (char *)page;\r\nssize_t ret = -ENODEV;\r\nif (sscanf(p, "%u %u", &first, &last) != 2)\r\nreturn -EINVAL;\r\nmutex_lock(&stp_policy_subsys.su_mutex);\r\nstm = policy_node->policy->stm;\r\nif (!stm)\r\ngoto unlock;\r\nif (first > last || first < stm->data->sw_start ||\r\nlast > stm->data->sw_end) {\r\nret = -ERANGE;\r\ngoto unlock;\r\n}\r\nret = count;\r\npolicy_node->first_master = first;\r\npolicy_node->last_master = last;\r\nunlock:\r\nmutex_unlock(&stp_policy_subsys.su_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nstp_policy_node_channels_show(struct config_item *item, char *page)\r\n{\r\nstruct stp_policy_node *policy_node = to_stp_policy_node(item);\r\nssize_t count;\r\ncount = sprintf(page, "%u %u\n", policy_node->first_channel,\r\npolicy_node->last_channel);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstp_policy_node_channels_store(struct config_item *item, const char *page,\r\nsize_t count)\r\n{\r\nstruct stp_policy_node *policy_node = to_stp_policy_node(item);\r\nunsigned int first, last;\r\nstruct stm_device *stm;\r\nchar *p = (char *)page;\r\nssize_t ret = -ENODEV;\r\nif (sscanf(p, "%u %u", &first, &last) != 2)\r\nreturn -EINVAL;\r\nmutex_lock(&stp_policy_subsys.su_mutex);\r\nstm = policy_node->policy->stm;\r\nif (!stm)\r\ngoto unlock;\r\nif (first > INT_MAX || last > INT_MAX || first > last ||\r\nlast >= stm->data->sw_nchannels) {\r\nret = -ERANGE;\r\ngoto unlock;\r\n}\r\nret = count;\r\npolicy_node->first_channel = first;\r\npolicy_node->last_channel = last;\r\nunlock:\r\nmutex_unlock(&stp_policy_subsys.su_mutex);\r\nreturn ret;\r\n}\r\nstatic void stp_policy_node_release(struct config_item *item)\r\n{\r\nkfree(to_stp_policy_node(item));\r\n}\r\nstatic struct config_group *\r\nstp_policy_node_make(struct config_group *group, const char *name)\r\n{\r\nstruct stp_policy_node *policy_node, *parent_node;\r\nstruct stp_policy *policy;\r\nif (group->cg_item.ci_type == &stp_policy_type) {\r\npolicy = container_of(group, struct stp_policy, group);\r\n} else {\r\nparent_node = container_of(group, struct stp_policy_node,\r\ngroup);\r\npolicy = parent_node->policy;\r\n}\r\nif (!policy->stm)\r\nreturn ERR_PTR(-ENODEV);\r\npolicy_node = kzalloc(sizeof(struct stp_policy_node), GFP_KERNEL);\r\nif (!policy_node)\r\nreturn ERR_PTR(-ENOMEM);\r\nconfig_group_init_type_name(&policy_node->group, name,\r\n&stp_policy_node_type);\r\npolicy_node->policy = policy;\r\npolicy_node->first_master = policy->stm->data->sw_start;\r\npolicy_node->last_master = policy->stm->data->sw_end;\r\npolicy_node->first_channel = 0;\r\npolicy_node->last_channel = policy->stm->data->sw_nchannels - 1;\r\nreturn &policy_node->group;\r\n}\r\nstatic void\r\nstp_policy_node_drop(struct config_group *group, struct config_item *item)\r\n{\r\nconfig_item_put(item);\r\n}\r\nstatic ssize_t stp_policy_device_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct stp_policy *policy = to_stp_policy(item);\r\nssize_t count;\r\ncount = sprintf(page, "%s\n",\r\n(policy && policy->stm) ?\r\npolicy->stm->data->name :\r\n"<none>");\r\nreturn count;\r\n}\r\nvoid stp_policy_unbind(struct stp_policy *policy)\r\n{\r\nstruct stm_device *stm = policy->stm;\r\nif (WARN_ON_ONCE(!policy->stm))\r\nreturn;\r\nlockdep_assert_held(&stm->policy_mutex);\r\nstm->policy = NULL;\r\npolicy->stm = NULL;\r\nstm_put_device(stm);\r\n}\r\nstatic void stp_policy_release(struct config_item *item)\r\n{\r\nstruct stp_policy *policy = to_stp_policy(item);\r\nstruct stm_device *stm = policy->stm;\r\nif (!stm)\r\nreturn;\r\nmutex_lock(&stm->policy_mutex);\r\nstp_policy_unbind(policy);\r\nmutex_unlock(&stm->policy_mutex);\r\nkfree(policy);\r\n}\r\nstatic struct config_group *\r\nstp_policies_make(struct config_group *group, const char *name)\r\n{\r\nstruct config_group *ret;\r\nstruct stm_device *stm;\r\nchar *devname, *p;\r\ndevname = kasprintf(GFP_KERNEL, "%s", name);\r\nif (!devname)\r\nreturn ERR_PTR(-ENOMEM);\r\np = strrchr(devname, '.');\r\nif (!p) {\r\nkfree(devname);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n*p = '\0';\r\nstm = stm_find_device(devname);\r\nkfree(devname);\r\nif (!stm)\r\nreturn ERR_PTR(-ENODEV);\r\nmutex_lock(&stm->policy_mutex);\r\nif (stm->policy) {\r\nret = ERR_PTR(-EBUSY);\r\ngoto unlock_policy;\r\n}\r\nstm->policy = kzalloc(sizeof(*stm->policy), GFP_KERNEL);\r\nif (!stm->policy) {\r\nret = ERR_PTR(-ENOMEM);\r\ngoto unlock_policy;\r\n}\r\nconfig_group_init_type_name(&stm->policy->group, name,\r\n&stp_policy_type);\r\nstm->policy->stm = stm;\r\nret = &stm->policy->group;\r\nunlock_policy:\r\nmutex_unlock(&stm->policy_mutex);\r\nif (IS_ERR(ret))\r\nstm_put_device(stm);\r\nreturn ret;\r\n}\r\nstatic struct stp_policy_node *\r\n__stp_policy_node_lookup(struct stp_policy *policy, char *s)\r\n{\r\nstruct stp_policy_node *policy_node, *ret;\r\nstruct list_head *head = &policy->group.cg_children;\r\nstruct config_item *item;\r\nchar *start, *end = s;\r\nif (list_empty(head))\r\nreturn NULL;\r\nitem = list_entry(head->next, struct config_item, ci_entry);\r\nret = to_stp_policy_node(item);\r\nnext:\r\nfor (;;) {\r\nstart = strsep(&end, "/");\r\nif (!start)\r\nbreak;\r\nif (!*start)\r\ncontinue;\r\nlist_for_each_entry(item, head, ci_entry) {\r\npolicy_node = to_stp_policy_node(item);\r\nif (!strcmp(start,\r\npolicy_node->group.cg_item.ci_name)) {\r\nret = policy_node;\r\nif (!end)\r\ngoto out;\r\nhead = &policy_node->group.cg_children;\r\ngoto next;\r\n}\r\n}\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstruct stp_policy_node *\r\nstp_policy_node_lookup(struct stm_device *stm, char *s)\r\n{\r\nstruct stp_policy_node *policy_node = NULL;\r\nmutex_lock(&stp_policy_subsys.su_mutex);\r\nmutex_lock(&stm->policy_mutex);\r\nif (stm->policy)\r\npolicy_node = __stp_policy_node_lookup(stm->policy, s);\r\nmutex_unlock(&stm->policy_mutex);\r\nif (policy_node)\r\nconfig_item_get(&policy_node->group.cg_item);\r\nmutex_unlock(&stp_policy_subsys.su_mutex);\r\nreturn policy_node;\r\n}\r\nvoid stp_policy_node_put(struct stp_policy_node *policy_node)\r\n{\r\nconfig_item_put(&policy_node->group.cg_item);\r\n}\r\nint __init stp_configfs_init(void)\r\n{\r\nint err;\r\nconfig_group_init(&stp_policy_subsys.su_group);\r\nmutex_init(&stp_policy_subsys.su_mutex);\r\nerr = configfs_register_subsystem(&stp_policy_subsys);\r\nreturn err;\r\n}\r\nvoid __exit stp_configfs_exit(void)\r\n{\r\nconfigfs_unregister_subsystem(&stp_policy_subsys);\r\n}
