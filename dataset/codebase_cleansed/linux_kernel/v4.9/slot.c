static ssize_t pci_slot_attr_show(struct kobject *kobj,\r\nstruct attribute *attr, char *buf)\r\n{\r\nstruct pci_slot *slot = to_pci_slot(kobj);\r\nstruct pci_slot_attribute *attribute = to_pci_slot_attr(attr);\r\nreturn attribute->show ? attribute->show(slot, buf) : -EIO;\r\n}\r\nstatic ssize_t pci_slot_attr_store(struct kobject *kobj,\r\nstruct attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct pci_slot *slot = to_pci_slot(kobj);\r\nstruct pci_slot_attribute *attribute = to_pci_slot_attr(attr);\r\nreturn attribute->store ? attribute->store(slot, buf, len) : -EIO;\r\n}\r\nstatic ssize_t address_read_file(struct pci_slot *slot, char *buf)\r\n{\r\nif (slot->number == 0xff)\r\nreturn sprintf(buf, "%04x:%02x\n",\r\npci_domain_nr(slot->bus),\r\nslot->bus->number);\r\nelse\r\nreturn sprintf(buf, "%04x:%02x:%02x\n",\r\npci_domain_nr(slot->bus),\r\nslot->bus->number,\r\nslot->number);\r\n}\r\nstatic ssize_t bus_speed_read(enum pci_bus_speed speed, char *buf)\r\n{\r\nconst char *speed_string;\r\nif (speed < ARRAY_SIZE(pci_bus_speed_strings))\r\nspeed_string = pci_bus_speed_strings[speed];\r\nelse\r\nspeed_string = "Unknown";\r\nreturn sprintf(buf, "%s\n", speed_string);\r\n}\r\nstatic ssize_t max_speed_read_file(struct pci_slot *slot, char *buf)\r\n{\r\nreturn bus_speed_read(slot->bus->max_bus_speed, buf);\r\n}\r\nstatic ssize_t cur_speed_read_file(struct pci_slot *slot, char *buf)\r\n{\r\nreturn bus_speed_read(slot->bus->cur_bus_speed, buf);\r\n}\r\nstatic void pci_slot_release(struct kobject *kobj)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_slot *slot = to_pci_slot(kobj);\r\ndev_dbg(&slot->bus->dev, "dev %02x, released physical slot %s\n",\r\nslot->number, pci_slot_name(slot));\r\ndown_read(&pci_bus_sem);\r\nlist_for_each_entry(dev, &slot->bus->devices, bus_list)\r\nif (PCI_SLOT(dev->devfn) == slot->number)\r\ndev->slot = NULL;\r\nup_read(&pci_bus_sem);\r\nlist_del(&slot->list);\r\nkfree(slot);\r\n}\r\nstatic char *make_slot_name(const char *name)\r\n{\r\nchar *new_name;\r\nint len, max, dup;\r\nnew_name = kstrdup(name, GFP_KERNEL);\r\nif (!new_name)\r\nreturn NULL;\r\nlen = strlen(name) + 2;\r\nmax = 1;\r\ndup = 1;\r\nfor (;;) {\r\nstruct kobject *dup_slot;\r\ndup_slot = kset_find_obj(pci_slots_kset, new_name);\r\nif (!dup_slot)\r\nbreak;\r\nkobject_put(dup_slot);\r\nif (dup == max) {\r\nlen++;\r\nmax *= 10;\r\nkfree(new_name);\r\nnew_name = kmalloc(len, GFP_KERNEL);\r\nif (!new_name)\r\nbreak;\r\n}\r\nsprintf(new_name, "%s-%d", name, dup++);\r\n}\r\nreturn new_name;\r\n}\r\nstatic int rename_slot(struct pci_slot *slot, const char *name)\r\n{\r\nint result = 0;\r\nchar *slot_name;\r\nif (strcmp(pci_slot_name(slot), name) == 0)\r\nreturn result;\r\nslot_name = make_slot_name(name);\r\nif (!slot_name)\r\nreturn -ENOMEM;\r\nresult = kobject_rename(&slot->kobj, slot_name);\r\nkfree(slot_name);\r\nreturn result;\r\n}\r\nvoid pci_dev_assign_slot(struct pci_dev *dev)\r\n{\r\nstruct pci_slot *slot;\r\nmutex_lock(&pci_slot_mutex);\r\nlist_for_each_entry(slot, &dev->bus->slots, list)\r\nif (PCI_SLOT(dev->devfn) == slot->number)\r\ndev->slot = slot;\r\nmutex_unlock(&pci_slot_mutex);\r\n}\r\nstatic struct pci_slot *get_slot(struct pci_bus *parent, int slot_nr)\r\n{\r\nstruct pci_slot *slot;\r\nlist_for_each_entry(slot, &parent->slots, list)\r\nif (slot->number == slot_nr) {\r\nkobject_get(&slot->kobj);\r\nreturn slot;\r\n}\r\nreturn NULL;\r\n}\r\nstruct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,\r\nconst char *name,\r\nstruct hotplug_slot *hotplug)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_slot *slot;\r\nint err = 0;\r\nchar *slot_name = NULL;\r\nmutex_lock(&pci_slot_mutex);\r\nif (slot_nr == -1)\r\ngoto placeholder;\r\nslot = get_slot(parent, slot_nr);\r\nif (slot) {\r\nif (hotplug) {\r\nif ((err = slot->hotplug ? -EBUSY : 0)\r\n|| (err = rename_slot(slot, name))) {\r\nkobject_put(&slot->kobj);\r\nslot = NULL;\r\ngoto err;\r\n}\r\n}\r\ngoto out;\r\n}\r\nplaceholder:\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nslot->bus = parent;\r\nslot->number = slot_nr;\r\nslot->kobj.kset = pci_slots_kset;\r\nslot_name = make_slot_name(name);\r\nif (!slot_name) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nerr = kobject_init_and_add(&slot->kobj, &pci_slot_ktype, NULL,\r\n"%s", slot_name);\r\nif (err)\r\ngoto err;\r\nINIT_LIST_HEAD(&slot->list);\r\nlist_add(&slot->list, &parent->slots);\r\ndown_read(&pci_bus_sem);\r\nlist_for_each_entry(dev, &parent->devices, bus_list)\r\nif (PCI_SLOT(dev->devfn) == slot_nr)\r\ndev->slot = slot;\r\nup_read(&pci_bus_sem);\r\ndev_dbg(&parent->dev, "dev %02x, created physical slot %s\n",\r\nslot_nr, pci_slot_name(slot));\r\nout:\r\nkfree(slot_name);\r\nmutex_unlock(&pci_slot_mutex);\r\nreturn slot;\r\nerr:\r\nkfree(slot);\r\nslot = ERR_PTR(err);\r\ngoto out;\r\n}\r\nvoid pci_destroy_slot(struct pci_slot *slot)\r\n{\r\ndev_dbg(&slot->bus->dev, "dev %02x, dec refcount to %d\n",\r\nslot->number, atomic_read(&slot->kobj.kref.refcount) - 1);\r\nmutex_lock(&pci_slot_mutex);\r\nkobject_put(&slot->kobj);\r\nmutex_unlock(&pci_slot_mutex);\r\n}\r\nvoid pci_hp_create_module_link(struct pci_slot *pci_slot)\r\n{\r\nstruct hotplug_slot *slot = pci_slot->hotplug;\r\nstruct kobject *kobj = NULL;\r\nint ret;\r\nif (!slot || !slot->ops)\r\nreturn;\r\nkobj = kset_find_obj(module_kset, slot->ops->mod_name);\r\nif (!kobj)\r\nreturn;\r\nret = sysfs_create_link(&pci_slot->kobj, kobj, "module");\r\nif (ret)\r\ndev_err(&pci_slot->bus->dev, "Error creating sysfs link (%d)\n",\r\nret);\r\nkobject_put(kobj);\r\n}\r\nvoid pci_hp_remove_module_link(struct pci_slot *pci_slot)\r\n{\r\nsysfs_remove_link(&pci_slot->kobj, "module");\r\n}\r\nstatic int pci_slot_init(void)\r\n{\r\nstruct kset *pci_bus_kset;\r\npci_bus_kset = bus_get_kset(&pci_bus_type);\r\npci_slots_kset = kset_create_and_add("slots", NULL,\r\n&pci_bus_kset->kobj);\r\nif (!pci_slots_kset) {\r\nprintk(KERN_ERR "PCI: Slot initialization failure\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}
