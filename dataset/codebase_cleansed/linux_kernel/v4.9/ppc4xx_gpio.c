static int ppc4xx_gpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct ppc4xx_gpio __iomem *regs = mm_gc->regs;\r\nreturn !!(in_be32(&regs->ir) & GPIO_MASK(gpio));\r\n}\r\nstatic inline void\r\n__ppc4xx_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct ppc4xx_gpio __iomem *regs = mm_gc->regs;\r\nif (val)\r\nsetbits32(&regs->or, GPIO_MASK(gpio));\r\nelse\r\nclrbits32(&regs->or, GPIO_MASK(gpio));\r\n}\r\nstatic void\r\nppc4xx_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct ppc4xx_gpio_chip *chip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\n__ppc4xx_gpio_set(gc, gpio, val);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\npr_debug("%s: gpio: %d val: %d\n", __func__, gpio, val);\r\n}\r\nstatic int ppc4xx_gpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct ppc4xx_gpio_chip *chip = gpiochip_get_data(gc);\r\nstruct ppc4xx_gpio __iomem *regs = mm_gc->regs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nclrbits32(&regs->odr, GPIO_MASK(gpio));\r\nclrbits32(&regs->tcr, GPIO_MASK(gpio));\r\nif (gpio < 16) {\r\nclrbits32(&regs->osrl, GPIO_MASK2(gpio));\r\nclrbits32(&regs->tsrl, GPIO_MASK2(gpio));\r\n} else {\r\nclrbits32(&regs->osrh, GPIO_MASK2(gpio));\r\nclrbits32(&regs->tsrh, GPIO_MASK2(gpio));\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nppc4xx_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct ppc4xx_gpio_chip *chip = gpiochip_get_data(gc);\r\nstruct ppc4xx_gpio __iomem *regs = mm_gc->regs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\n__ppc4xx_gpio_set(gc, gpio, val);\r\nclrbits32(&regs->odr, GPIO_MASK(gpio));\r\nsetbits32(&regs->tcr, GPIO_MASK(gpio));\r\nif (gpio < 16) {\r\nclrbits32(&regs->osrl, GPIO_MASK2(gpio));\r\nclrbits32(&regs->tsrl, GPIO_MASK2(gpio));\r\n} else {\r\nclrbits32(&regs->osrh, GPIO_MASK2(gpio));\r\nclrbits32(&regs->tsrh, GPIO_MASK2(gpio));\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\npr_debug("%s: gpio: %d val: %d\n", __func__, gpio, val);\r\nreturn 0;\r\n}\r\nstatic int __init ppc4xx_add_gpiochips(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "ibm,ppc4xx-gpio") {\r\nint ret;\r\nstruct ppc4xx_gpio_chip *ppc4xx_gc;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct gpio_chip *gc;\r\nppc4xx_gc = kzalloc(sizeof(*ppc4xx_gc), GFP_KERNEL);\r\nif (!ppc4xx_gc) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nspin_lock_init(&ppc4xx_gc->lock);\r\nmm_gc = &ppc4xx_gc->mm_gc;\r\ngc = &mm_gc->gc;\r\ngc->ngpio = 32;\r\ngc->direction_input = ppc4xx_gpio_dir_in;\r\ngc->direction_output = ppc4xx_gpio_dir_out;\r\ngc->get = ppc4xx_gpio_get;\r\ngc->set = ppc4xx_gpio_set;\r\nret = of_mm_gpiochip_add_data(np, mm_gc, ppc4xx_gc);\r\nif (ret)\r\ngoto err;\r\ncontinue;\r\nerr:\r\npr_err("%s: registration failed with status %d\n",\r\nnp->full_name, ret);\r\nkfree(ppc4xx_gc);\r\n}\r\nreturn 0;\r\n}
