static unsigned long clk_frac_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_frac *frac = to_clk_frac(hw);\r\nu32 div;\r\nu64 tmp_rate;\r\ndiv = readl_relaxed(frac->reg) >> frac->shift;\r\ndiv &= (1 << frac->width) - 1;\r\ntmp_rate = (u64)parent_rate * div;\r\nreturn tmp_rate >> frac->width;\r\n}\r\nstatic long clk_frac_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_frac *frac = to_clk_frac(hw);\r\nunsigned long parent_rate = *prate;\r\nu32 div;\r\nu64 tmp, tmp_rate, result;\r\nif (rate > parent_rate)\r\nreturn -EINVAL;\r\ntmp = rate;\r\ntmp <<= frac->width;\r\ndo_div(tmp, parent_rate);\r\ndiv = tmp;\r\nif (!div)\r\nreturn -EINVAL;\r\ntmp_rate = (u64)parent_rate * div;\r\nresult = tmp_rate >> frac->width;\r\nif ((result << frac->width) < tmp_rate)\r\nresult += 1;\r\nreturn result;\r\n}\r\nstatic int clk_frac_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_frac *frac = to_clk_frac(hw);\r\nunsigned long flags;\r\nu32 div, val;\r\nu64 tmp;\r\nif (rate > parent_rate)\r\nreturn -EINVAL;\r\ntmp = rate;\r\ntmp <<= frac->width;\r\ndo_div(tmp, parent_rate);\r\ndiv = tmp;\r\nif (!div)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&mxs_lock, flags);\r\nval = readl_relaxed(frac->reg);\r\nval &= ~(((1 << frac->width) - 1) << frac->shift);\r\nval |= div << frac->shift;\r\nwritel_relaxed(val, frac->reg);\r\nspin_unlock_irqrestore(&mxs_lock, flags);\r\nreturn mxs_clk_wait(frac->reg, frac->busy);\r\n}\r\nstruct clk *mxs_clk_frac(const char *name, const char *parent_name,\r\nvoid __iomem *reg, u8 shift, u8 width, u8 busy)\r\n{\r\nstruct clk_frac *frac;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nfrac = kzalloc(sizeof(*frac), GFP_KERNEL);\r\nif (!frac)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &clk_frac_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.parent_names = (parent_name ? &parent_name: NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nfrac->reg = reg;\r\nfrac->shift = shift;\r\nfrac->width = width;\r\nfrac->busy = busy;\r\nfrac->hw.init = &init;\r\nclk = clk_register(NULL, &frac->hw);\r\nif (IS_ERR(clk))\r\nkfree(frac);\r\nreturn clk;\r\n}
