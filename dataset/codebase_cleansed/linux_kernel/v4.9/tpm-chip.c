int tpm_try_get_ops(struct tpm_chip *chip)\r\n{\r\nint rc = -EIO;\r\nget_device(&chip->dev);\r\ndown_read(&chip->ops_sem);\r\nif (!chip->ops)\r\ngoto out_lock;\r\nreturn 0;\r\nout_lock:\r\nup_read(&chip->ops_sem);\r\nput_device(&chip->dev);\r\nreturn rc;\r\n}\r\nvoid tpm_put_ops(struct tpm_chip *chip)\r\n{\r\nup_read(&chip->ops_sem);\r\nput_device(&chip->dev);\r\n}\r\nstruct tpm_chip *tpm_chip_find_get(int chip_num)\r\n{\r\nstruct tpm_chip *chip, *res = NULL;\r\nint chip_prev;\r\nmutex_lock(&idr_lock);\r\nif (chip_num == TPM_ANY_NUM) {\r\nchip_num = 0;\r\ndo {\r\nchip_prev = chip_num;\r\nchip = idr_get_next(&dev_nums_idr, &chip_num);\r\nif (chip && !tpm_try_get_ops(chip)) {\r\nres = chip;\r\nbreak;\r\n}\r\n} while (chip_prev != chip_num);\r\n} else {\r\nchip = idr_find_slowpath(&dev_nums_idr, chip_num);\r\nif (chip && !tpm_try_get_ops(chip))\r\nres = chip;\r\n}\r\nmutex_unlock(&idr_lock);\r\nreturn res;\r\n}\r\nstatic void tpm_dev_release(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = container_of(dev, struct tpm_chip, dev);\r\nmutex_lock(&idr_lock);\r\nidr_remove(&dev_nums_idr, chip->dev_num);\r\nmutex_unlock(&idr_lock);\r\nkfree(chip);\r\n}\r\nstruct tpm_chip *tpm_chip_alloc(struct device *dev,\r\nconst struct tpm_class_ops *ops)\r\n{\r\nstruct tpm_chip *chip;\r\nint rc;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&chip->tpm_mutex);\r\ninit_rwsem(&chip->ops_sem);\r\nchip->ops = ops;\r\nmutex_lock(&idr_lock);\r\nrc = idr_alloc(&dev_nums_idr, NULL, 0, TPM_NUM_DEVICES, GFP_KERNEL);\r\nmutex_unlock(&idr_lock);\r\nif (rc < 0) {\r\ndev_err(dev, "No available tpm device numbers\n");\r\nkfree(chip);\r\nreturn ERR_PTR(rc);\r\n}\r\nchip->dev_num = rc;\r\ndevice_initialize(&chip->dev);\r\nchip->dev.class = tpm_class;\r\nchip->dev.release = tpm_dev_release;\r\nchip->dev.parent = dev;\r\nchip->dev.groups = chip->groups;\r\nif (chip->dev_num == 0)\r\nchip->dev.devt = MKDEV(MISC_MAJOR, TPM_MINOR);\r\nelse\r\nchip->dev.devt = MKDEV(MAJOR(tpm_devt), chip->dev_num);\r\nrc = dev_set_name(&chip->dev, "tpm%d", chip->dev_num);\r\nif (rc)\r\ngoto out;\r\nif (!dev)\r\nchip->flags |= TPM_CHIP_FLAG_VIRTUAL;\r\ncdev_init(&chip->cdev, &tpm_fops);\r\nchip->cdev.owner = THIS_MODULE;\r\nchip->cdev.kobj.parent = &chip->dev.kobj;\r\nreturn chip;\r\nout:\r\nput_device(&chip->dev);\r\nreturn ERR_PTR(rc);\r\n}\r\nstruct tpm_chip *tpmm_chip_alloc(struct device *pdev,\r\nconst struct tpm_class_ops *ops)\r\n{\r\nstruct tpm_chip *chip;\r\nint rc;\r\nchip = tpm_chip_alloc(pdev, ops);\r\nif (IS_ERR(chip))\r\nreturn chip;\r\nrc = devm_add_action_or_reset(pdev,\r\n(void (*)(void *)) put_device,\r\n&chip->dev);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\ndev_set_drvdata(pdev, chip);\r\nreturn chip;\r\n}\r\nstatic int tpm_add_char_device(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nrc = cdev_add(&chip->cdev, chip->dev.devt, 1);\r\nif (rc) {\r\ndev_err(&chip->dev,\r\n"unable to cdev_add() %s, major %d, minor %d, err=%d\n",\r\ndev_name(&chip->dev), MAJOR(chip->dev.devt),\r\nMINOR(chip->dev.devt), rc);\r\nreturn rc;\r\n}\r\nrc = device_add(&chip->dev);\r\nif (rc) {\r\ndev_err(&chip->dev,\r\n"unable to device_register() %s, major %d, minor %d, err=%d\n",\r\ndev_name(&chip->dev), MAJOR(chip->dev.devt),\r\nMINOR(chip->dev.devt), rc);\r\ncdev_del(&chip->cdev);\r\nreturn rc;\r\n}\r\nmutex_lock(&idr_lock);\r\nidr_replace(&dev_nums_idr, chip, chip->dev_num);\r\nmutex_unlock(&idr_lock);\r\nreturn rc;\r\n}\r\nstatic void tpm_del_char_device(struct tpm_chip *chip)\r\n{\r\ncdev_del(&chip->cdev);\r\ndevice_del(&chip->dev);\r\nmutex_lock(&idr_lock);\r\nidr_replace(&dev_nums_idr, NULL, chip->dev_num);\r\nmutex_unlock(&idr_lock);\r\ndown_write(&chip->ops_sem);\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ntpm2_shutdown(chip, TPM2_SU_CLEAR);\r\nchip->ops = NULL;\r\nup_write(&chip->ops_sem);\r\n}\r\nstatic int tpm1_chip_register(struct tpm_chip *chip)\r\n{\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\nreturn 0;\r\ntpm_sysfs_add_device(chip);\r\nchip->bios_dir = tpm_bios_log_setup(dev_name(&chip->dev));\r\nreturn 0;\r\n}\r\nstatic void tpm1_chip_unregister(struct tpm_chip *chip)\r\n{\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\nreturn;\r\nif (chip->bios_dir)\r\ntpm_bios_log_teardown(chip->bios_dir);\r\n}\r\nstatic void tpm_del_legacy_sysfs(struct tpm_chip *chip)\r\n{\r\nstruct attribute **i;\r\nif (chip->flags & (TPM_CHIP_FLAG_TPM2 | TPM_CHIP_FLAG_VIRTUAL))\r\nreturn;\r\nsysfs_remove_link(&chip->dev.parent->kobj, "ppi");\r\nfor (i = chip->groups[0]->attrs; *i != NULL; ++i)\r\nsysfs_remove_link(&chip->dev.parent->kobj, (*i)->name);\r\n}\r\nstatic int tpm_add_legacy_sysfs(struct tpm_chip *chip)\r\n{\r\nstruct attribute **i;\r\nint rc;\r\nif (chip->flags & (TPM_CHIP_FLAG_TPM2 | TPM_CHIP_FLAG_VIRTUAL))\r\nreturn 0;\r\nrc = __compat_only_sysfs_link_entry_to_kobj(\r\n&chip->dev.parent->kobj, &chip->dev.kobj, "ppi");\r\nif (rc && rc != -ENOENT)\r\nreturn rc;\r\nfor (i = chip->groups[0]->attrs; *i != NULL; ++i) {\r\nrc = __compat_only_sysfs_link_entry_to_kobj(\r\n&chip->dev.parent->kobj, &chip->dev.kobj, (*i)->name);\r\nif (rc) {\r\ntpm_del_legacy_sysfs(chip);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint tpm_chip_register(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nif (chip->ops->flags & TPM_OPS_AUTO_STARTUP) {\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\nrc = tpm2_auto_startup(chip);\r\nelse\r\nrc = tpm1_auto_startup(chip);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = tpm1_chip_register(chip);\r\nif (rc)\r\nreturn rc;\r\ntpm_add_ppi(chip);\r\nrc = tpm_add_char_device(chip);\r\nif (rc) {\r\ntpm1_chip_unregister(chip);\r\nreturn rc;\r\n}\r\nchip->flags |= TPM_CHIP_FLAG_REGISTERED;\r\nrc = tpm_add_legacy_sysfs(chip);\r\nif (rc) {\r\ntpm_chip_unregister(chip);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid tpm_chip_unregister(struct tpm_chip *chip)\r\n{\r\nif (!(chip->flags & TPM_CHIP_FLAG_REGISTERED))\r\nreturn;\r\ntpm_del_legacy_sysfs(chip);\r\ntpm1_chip_unregister(chip);\r\ntpm_del_char_device(chip);\r\n}
