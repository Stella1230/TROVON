static int\r\nperf_event_set_period(struct hw_perf_event *hwc, u64 min, u64 max, u64 *hw_period)\r\n{\r\ns64 left = local64_read(&hwc->period_left);\r\ns64 period = hwc->sample_period;\r\nint overflow = 0;\r\nif (unlikely(left <= -period)) {\r\nleft = period;\r\nlocal64_set(&hwc->period_left, left);\r\nhwc->last_period = period;\r\noverflow = 1;\r\n}\r\nif (unlikely(left < (s64)min)) {\r\nleft += period;\r\nlocal64_set(&hwc->period_left, left);\r\nhwc->last_period = period;\r\noverflow = 1;\r\n}\r\nif (left > max) {\r\nleft -= max;\r\nif (left > max)\r\nleft = max;\r\nelse if (left < min)\r\nleft = min;\r\n}\r\n*hw_period = (u64)left;\r\nreturn overflow;\r\n}\r\nstatic int\r\nperf_event_try_update(struct perf_event *event, u64 new_raw_count, int width)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nint shift = 64 - width;\r\nu64 prev_raw_count;\r\nu64 delta;\r\nprev_raw_count = local64_read(&hwc->prev_count);\r\nif (local64_cmpxchg(&hwc->prev_count, prev_raw_count,\r\nnew_raw_count) != prev_raw_count)\r\nreturn 0;\r\ndelta = (new_raw_count << shift) - (prev_raw_count << shift);\r\ndelta >>= shift;\r\nlocal64_add(delta, &event->count);\r\nlocal64_sub(delta, &hwc->period_left);\r\nreturn 1;\r\n}\r\nstatic struct perf_ibs *get_ibs_pmu(int type)\r\n{\r\nif (perf_ibs_fetch.pmu.type == type)\r\nreturn &perf_ibs_fetch;\r\nif (perf_ibs_op.pmu.type == type)\r\nreturn &perf_ibs_op;\r\nreturn NULL;\r\n}\r\nstatic int perf_ibs_precise_event(struct perf_event *event, u64 *config)\r\n{\r\nswitch (event->attr.precise_ip) {\r\ncase 0:\r\nreturn -ENOENT;\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (event->attr.type) {\r\ncase PERF_TYPE_HARDWARE:\r\nswitch (event->attr.config) {\r\ncase PERF_COUNT_HW_CPU_CYCLES:\r\n*config = 0;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase PERF_TYPE_RAW:\r\nswitch (event->attr.config) {\r\ncase 0x0076:\r\n*config = 0;\r\nreturn 0;\r\ncase 0x00C1:\r\n*config = IBS_OP_CNT_CTL;\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int perf_ibs_init(struct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nstruct perf_ibs *perf_ibs;\r\nu64 max_cnt, config;\r\nint ret;\r\nperf_ibs = get_ibs_pmu(event->attr.type);\r\nif (perf_ibs) {\r\nconfig = event->attr.config;\r\n} else {\r\nperf_ibs = &perf_ibs_op;\r\nret = perf_ibs_precise_event(event, &config);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (event->pmu != &perf_ibs->pmu)\r\nreturn -ENOENT;\r\nif (perf_flags(&event->attr) & perf_flags(&ibs_notsupp))\r\nreturn -EINVAL;\r\nif (config & ~perf_ibs->config_mask)\r\nreturn -EINVAL;\r\nif (hwc->sample_period) {\r\nif (config & perf_ibs->cnt_mask)\r\nreturn -EINVAL;\r\nif (!event->attr.sample_freq && hwc->sample_period & 0x0f)\r\nreturn -EINVAL;\r\nhwc->sample_period &= ~0x0FULL;\r\nif (!hwc->sample_period)\r\nhwc->sample_period = 0x10;\r\n} else {\r\nmax_cnt = config & perf_ibs->cnt_mask;\r\nconfig &= ~perf_ibs->cnt_mask;\r\nevent->attr.sample_period = max_cnt << 4;\r\nhwc->sample_period = event->attr.sample_period;\r\n}\r\nif (!hwc->sample_period)\r\nreturn -EINVAL;\r\nhwc->last_period = hwc->sample_period;\r\nlocal64_set(&hwc->period_left, hwc->sample_period);\r\nhwc->config_base = perf_ibs->msr;\r\nhwc->config = config;\r\nreturn 0;\r\n}\r\nstatic int perf_ibs_set_period(struct perf_ibs *perf_ibs,\r\nstruct hw_perf_event *hwc, u64 *period)\r\n{\r\nint overflow;\r\noverflow = perf_event_set_period(hwc, 1<<4, perf_ibs->max_period, period);\r\nlocal64_set(&hwc->prev_count, 0);\r\nreturn overflow;\r\n}\r\nstatic u64 get_ibs_fetch_count(u64 config)\r\n{\r\nreturn (config & IBS_FETCH_CNT) >> 12;\r\n}\r\nstatic u64 get_ibs_op_count(u64 config)\r\n{\r\nu64 count = 0;\r\nif (config & IBS_OP_VAL)\r\ncount += (config & IBS_OP_MAX_CNT) << 4;\r\nif (ibs_caps & IBS_CAPS_RDWROPCNT)\r\ncount += (config & IBS_OP_CUR_CNT) >> 32;\r\nreturn count;\r\n}\r\nstatic void\r\nperf_ibs_event_update(struct perf_ibs *perf_ibs, struct perf_event *event,\r\nu64 *config)\r\n{\r\nu64 count = perf_ibs->get_count(*config);\r\nwhile (!perf_event_try_update(event, count, 64)) {\r\nrdmsrl(event->hw.config_base, *config);\r\ncount = perf_ibs->get_count(*config);\r\n}\r\n}\r\nstatic inline void perf_ibs_enable_event(struct perf_ibs *perf_ibs,\r\nstruct hw_perf_event *hwc, u64 config)\r\n{\r\nwrmsrl(hwc->config_base, hwc->config | config | perf_ibs->enable_mask);\r\n}\r\nstatic inline void perf_ibs_disable_event(struct perf_ibs *perf_ibs,\r\nstruct hw_perf_event *hwc, u64 config)\r\n{\r\nconfig &= ~perf_ibs->cnt_mask;\r\nwrmsrl(hwc->config_base, config);\r\nconfig &= ~perf_ibs->enable_mask;\r\nwrmsrl(hwc->config_base, config);\r\n}\r\nstatic void perf_ibs_start(struct perf_event *event, int flags)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nstruct perf_ibs *perf_ibs = container_of(event->pmu, struct perf_ibs, pmu);\r\nstruct cpu_perf_ibs *pcpu = this_cpu_ptr(perf_ibs->pcpu);\r\nu64 period;\r\nif (WARN_ON_ONCE(!(hwc->state & PERF_HES_STOPPED)))\r\nreturn;\r\nWARN_ON_ONCE(!(hwc->state & PERF_HES_UPTODATE));\r\nhwc->state = 0;\r\nperf_ibs_set_period(perf_ibs, hwc, &period);\r\nset_bit(IBS_STARTED, pcpu->state);\r\nclear_bit(IBS_STOPPING, pcpu->state);\r\nperf_ibs_enable_event(perf_ibs, hwc, period >> 4);\r\nperf_event_update_userpage(event);\r\n}\r\nstatic void perf_ibs_stop(struct perf_event *event, int flags)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nstruct perf_ibs *perf_ibs = container_of(event->pmu, struct perf_ibs, pmu);\r\nstruct cpu_perf_ibs *pcpu = this_cpu_ptr(perf_ibs->pcpu);\r\nu64 config;\r\nint stopping;\r\nif (test_and_set_bit(IBS_STOPPING, pcpu->state))\r\nreturn;\r\nstopping = test_bit(IBS_STARTED, pcpu->state);\r\nif (!stopping && (hwc->state & PERF_HES_UPTODATE))\r\nreturn;\r\nrdmsrl(hwc->config_base, config);\r\nif (stopping) {\r\nset_bit(IBS_STOPPED, pcpu->state);\r\nperf_ibs_disable_event(perf_ibs, hwc, config);\r\nclear_bit(IBS_STARTED, pcpu->state);\r\nWARN_ON_ONCE(hwc->state & PERF_HES_STOPPED);\r\nhwc->state |= PERF_HES_STOPPED;\r\n}\r\nif (hwc->state & PERF_HES_UPTODATE)\r\nreturn;\r\nconfig &= ~perf_ibs->valid_mask;\r\nperf_ibs_event_update(perf_ibs, event, &config);\r\nhwc->state |= PERF_HES_UPTODATE;\r\n}\r\nstatic int perf_ibs_add(struct perf_event *event, int flags)\r\n{\r\nstruct perf_ibs *perf_ibs = container_of(event->pmu, struct perf_ibs, pmu);\r\nstruct cpu_perf_ibs *pcpu = this_cpu_ptr(perf_ibs->pcpu);\r\nif (test_and_set_bit(IBS_ENABLED, pcpu->state))\r\nreturn -ENOSPC;\r\nevent->hw.state = PERF_HES_UPTODATE | PERF_HES_STOPPED;\r\npcpu->event = event;\r\nif (flags & PERF_EF_START)\r\nperf_ibs_start(event, PERF_EF_RELOAD);\r\nreturn 0;\r\n}\r\nstatic void perf_ibs_del(struct perf_event *event, int flags)\r\n{\r\nstruct perf_ibs *perf_ibs = container_of(event->pmu, struct perf_ibs, pmu);\r\nstruct cpu_perf_ibs *pcpu = this_cpu_ptr(perf_ibs->pcpu);\r\nif (!test_and_clear_bit(IBS_ENABLED, pcpu->state))\r\nreturn;\r\nperf_ibs_stop(event, PERF_EF_UPDATE);\r\npcpu->event = NULL;\r\nperf_event_update_userpage(event);\r\n}\r\nstatic void perf_ibs_read(struct perf_event *event) { }\r\nstatic int perf_ibs_handle_irq(struct perf_ibs *perf_ibs, struct pt_regs *iregs)\r\n{\r\nstruct cpu_perf_ibs *pcpu = this_cpu_ptr(perf_ibs->pcpu);\r\nstruct perf_event *event = pcpu->event;\r\nstruct hw_perf_event *hwc = &event->hw;\r\nstruct perf_sample_data data;\r\nstruct perf_raw_record raw;\r\nstruct pt_regs regs;\r\nstruct perf_ibs_data ibs_data;\r\nint offset, size, check_rip, offset_max, throttle = 0;\r\nunsigned int msr;\r\nu64 *buf, *config, period;\r\nif (!test_bit(IBS_STARTED, pcpu->state)) {\r\nfail:\r\nif (test_and_clear_bit(IBS_STOPPED, pcpu->state))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nmsr = hwc->config_base;\r\nbuf = ibs_data.regs;\r\nrdmsrl(msr, *buf);\r\nif (!(*buf++ & perf_ibs->valid_mask))\r\ngoto fail;\r\nconfig = &ibs_data.regs[0];\r\nperf_ibs_event_update(perf_ibs, event, config);\r\nperf_sample_data_init(&data, 0, hwc->last_period);\r\nif (!perf_ibs_set_period(perf_ibs, hwc, &period))\r\ngoto out;\r\nibs_data.caps = ibs_caps;\r\nsize = 1;\r\noffset = 1;\r\ncheck_rip = (perf_ibs == &perf_ibs_op && (ibs_caps & IBS_CAPS_RIPINVALIDCHK));\r\nif (event->attr.sample_type & PERF_SAMPLE_RAW)\r\noffset_max = perf_ibs->offset_max;\r\nelse if (check_rip)\r\noffset_max = 2;\r\nelse\r\noffset_max = 1;\r\ndo {\r\nrdmsrl(msr + offset, *buf++);\r\nsize++;\r\noffset = find_next_bit(perf_ibs->offset_mask,\r\nperf_ibs->offset_max,\r\noffset + 1);\r\n} while (offset < offset_max);\r\nif (event->attr.sample_type & PERF_SAMPLE_RAW) {\r\nif (ibs_caps & IBS_CAPS_BRNTRGT) {\r\nrdmsrl(MSR_AMD64_IBSBRTARGET, *buf++);\r\nsize++;\r\n}\r\nif (ibs_caps & IBS_CAPS_OPDATA4) {\r\nrdmsrl(MSR_AMD64_IBSOPDATA4, *buf++);\r\nsize++;\r\n}\r\n}\r\nibs_data.size = sizeof(u64) * size;\r\nregs = *iregs;\r\nif (check_rip && (ibs_data.regs[2] & IBS_RIP_INVALID)) {\r\nregs.flags &= ~PERF_EFLAGS_EXACT;\r\n} else {\r\nset_linear_ip(&regs, ibs_data.regs[1]);\r\nregs.flags |= PERF_EFLAGS_EXACT;\r\n}\r\nif (event->attr.sample_type & PERF_SAMPLE_RAW) {\r\nraw = (struct perf_raw_record){\r\n.frag = {\r\n.size = sizeof(u32) + ibs_data.size,\r\n.data = ibs_data.data,\r\n},\r\n};\r\ndata.raw = &raw;\r\n}\r\nthrottle = perf_event_overflow(event, &data, &regs);\r\nout:\r\nif (throttle)\r\nperf_ibs_stop(event, 0);\r\nelse\r\nperf_ibs_enable_event(perf_ibs, hwc, period >> 4);\r\nperf_event_update_userpage(event);\r\nreturn 1;\r\n}\r\nstatic int\r\nperf_ibs_nmi_handler(unsigned int cmd, struct pt_regs *regs)\r\n{\r\nu64 stamp = sched_clock();\r\nint handled = 0;\r\nhandled += perf_ibs_handle_irq(&perf_ibs_fetch, regs);\r\nhandled += perf_ibs_handle_irq(&perf_ibs_op, regs);\r\nif (handled)\r\ninc_irq_stat(apic_perf_irqs);\r\nperf_sample_event_took(sched_clock() - stamp);\r\nreturn handled;\r\n}\r\nstatic __init int perf_ibs_pmu_init(struct perf_ibs *perf_ibs, char *name)\r\n{\r\nstruct cpu_perf_ibs __percpu *pcpu;\r\nint ret;\r\npcpu = alloc_percpu(struct cpu_perf_ibs);\r\nif (!pcpu)\r\nreturn -ENOMEM;\r\nperf_ibs->pcpu = pcpu;\r\nif (perf_ibs->format_attrs[0]) {\r\nmemset(&perf_ibs->format_group, 0, sizeof(perf_ibs->format_group));\r\nperf_ibs->format_group.name = "format";\r\nperf_ibs->format_group.attrs = perf_ibs->format_attrs;\r\nmemset(&perf_ibs->attr_groups, 0, sizeof(perf_ibs->attr_groups));\r\nperf_ibs->attr_groups[0] = &perf_ibs->format_group;\r\nperf_ibs->pmu.attr_groups = perf_ibs->attr_groups;\r\n}\r\nret = perf_pmu_register(&perf_ibs->pmu, name, -1);\r\nif (ret) {\r\nperf_ibs->pcpu = NULL;\r\nfree_percpu(pcpu);\r\n}\r\nreturn ret;\r\n}\r\nstatic __init void perf_event_ibs_init(void)\r\n{\r\nstruct attribute **attr = ibs_op_format_attrs;\r\nperf_ibs_pmu_init(&perf_ibs_fetch, "ibs_fetch");\r\nif (ibs_caps & IBS_CAPS_OPCNT) {\r\nperf_ibs_op.config_mask |= IBS_OP_CNT_CTL;\r\n*attr++ = &format_attr_cnt_ctl.attr;\r\n}\r\nperf_ibs_pmu_init(&perf_ibs_op, "ibs_op");\r\nregister_nmi_handler(NMI_LOCAL, perf_ibs_nmi_handler, 0, "perf_ibs");\r\npr_info("perf: AMD IBS detected (0x%08x)\n", ibs_caps);\r\n}\r\nstatic __init void perf_event_ibs_init(void) { }\r\nstatic __init u32 __get_ibs_caps(void)\r\n{\r\nu32 caps;\r\nunsigned int max_level;\r\nif (!boot_cpu_has(X86_FEATURE_IBS))\r\nreturn 0;\r\nmax_level = cpuid_eax(0x80000000);\r\nif (max_level < IBS_CPUID_FEATURES)\r\nreturn IBS_CAPS_DEFAULT;\r\ncaps = cpuid_eax(IBS_CPUID_FEATURES);\r\nif (!(caps & IBS_CAPS_AVAIL))\r\nreturn IBS_CAPS_DEFAULT;\r\nreturn caps;\r\n}\r\nu32 get_ibs_caps(void)\r\n{\r\nreturn ibs_caps;\r\n}\r\nstatic inline int get_eilvt(int offset)\r\n{\r\nreturn !setup_APIC_eilvt(offset, 0, APIC_EILVT_MSG_NMI, 1);\r\n}\r\nstatic inline int put_eilvt(int offset)\r\n{\r\nreturn !setup_APIC_eilvt(offset, 0, 0, 1);\r\n}\r\nstatic inline int ibs_eilvt_valid(void)\r\n{\r\nint offset;\r\nu64 val;\r\nint valid = 0;\r\npreempt_disable();\r\nrdmsrl(MSR_AMD64_IBSCTL, val);\r\noffset = val & IBSCTL_LVT_OFFSET_MASK;\r\nif (!(val & IBSCTL_LVT_OFFSET_VALID)) {\r\npr_err(FW_BUG "cpu %d, invalid IBS interrupt offset %d (MSR%08X=0x%016llx)\n",\r\nsmp_processor_id(), offset, MSR_AMD64_IBSCTL, val);\r\ngoto out;\r\n}\r\nif (!get_eilvt(offset)) {\r\npr_err(FW_BUG "cpu %d, IBS interrupt offset %d not available (MSR%08X=0x%016llx)\n",\r\nsmp_processor_id(), offset, MSR_AMD64_IBSCTL, val);\r\ngoto out;\r\n}\r\nvalid = 1;\r\nout:\r\npreempt_enable();\r\nreturn valid;\r\n}\r\nstatic int setup_ibs_ctl(int ibs_eilvt_off)\r\n{\r\nstruct pci_dev *cpu_cfg;\r\nint nodes;\r\nu32 value = 0;\r\nnodes = 0;\r\ncpu_cfg = NULL;\r\ndo {\r\ncpu_cfg = pci_get_device(PCI_VENDOR_ID_AMD,\r\nPCI_DEVICE_ID_AMD_10H_NB_MISC,\r\ncpu_cfg);\r\nif (!cpu_cfg)\r\nbreak;\r\n++nodes;\r\npci_write_config_dword(cpu_cfg, IBSCTL, ibs_eilvt_off\r\n| IBSCTL_LVT_OFFSET_VALID);\r\npci_read_config_dword(cpu_cfg, IBSCTL, &value);\r\nif (value != (ibs_eilvt_off | IBSCTL_LVT_OFFSET_VALID)) {\r\npci_dev_put(cpu_cfg);\r\npr_debug("Failed to setup IBS LVT offset, IBSCTL = 0x%08x\n",\r\nvalue);\r\nreturn -EINVAL;\r\n}\r\n} while (1);\r\nif (!nodes) {\r\npr_debug("No CPU node configured for IBS\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void force_ibs_eilvt_setup(void)\r\n{\r\nint offset;\r\nint ret;\r\npreempt_disable();\r\nfor (offset = 1; offset < APIC_EILVT_NR_MAX; offset++) {\r\nif (get_eilvt(offset))\r\nbreak;\r\n}\r\npreempt_enable();\r\nif (offset == APIC_EILVT_NR_MAX) {\r\npr_debug("No EILVT entry available\n");\r\nreturn;\r\n}\r\nret = setup_ibs_ctl(offset);\r\nif (ret)\r\ngoto out;\r\nif (!ibs_eilvt_valid())\r\ngoto out;\r\npr_info("IBS: LVT offset %d assigned\n", offset);\r\nreturn;\r\nout:\r\npreempt_disable();\r\nput_eilvt(offset);\r\npreempt_enable();\r\nreturn;\r\n}\r\nstatic void ibs_eilvt_setup(void)\r\n{\r\nif (boot_cpu_data.x86 == 0x10)\r\nforce_ibs_eilvt_setup();\r\n}\r\nstatic inline int get_ibs_lvt_offset(void)\r\n{\r\nu64 val;\r\nrdmsrl(MSR_AMD64_IBSCTL, val);\r\nif (!(val & IBSCTL_LVT_OFFSET_VALID))\r\nreturn -EINVAL;\r\nreturn val & IBSCTL_LVT_OFFSET_MASK;\r\n}\r\nstatic void setup_APIC_ibs(void)\r\n{\r\nint offset;\r\noffset = get_ibs_lvt_offset();\r\nif (offset < 0)\r\ngoto failed;\r\nif (!setup_APIC_eilvt(offset, 0, APIC_EILVT_MSG_NMI, 0))\r\nreturn;\r\nfailed:\r\npr_warn("perf: IBS APIC setup failed on cpu #%d\n",\r\nsmp_processor_id());\r\n}\r\nstatic void clear_APIC_ibs(void)\r\n{\r\nint offset;\r\noffset = get_ibs_lvt_offset();\r\nif (offset >= 0)\r\nsetup_APIC_eilvt(offset, 0, APIC_EILVT_MSG_FIX, 1);\r\n}\r\nstatic int x86_pmu_amd_ibs_starting_cpu(unsigned int cpu)\r\n{\r\nsetup_APIC_ibs();\r\nreturn 0;\r\n}\r\nstatic int perf_ibs_suspend(void)\r\n{\r\nclear_APIC_ibs();\r\nreturn 0;\r\n}\r\nstatic void perf_ibs_resume(void)\r\n{\r\nibs_eilvt_setup();\r\nsetup_APIC_ibs();\r\n}\r\nstatic void perf_ibs_pm_init(void)\r\n{\r\nregister_syscore_ops(&perf_ibs_syscore_ops);\r\n}\r\nstatic inline void perf_ibs_pm_init(void) { }\r\nstatic int x86_pmu_amd_ibs_dying_cpu(unsigned int cpu)\r\n{\r\nclear_APIC_ibs();\r\nreturn 0;\r\n}\r\nstatic __init int amd_ibs_init(void)\r\n{\r\nu32 caps;\r\ncaps = __get_ibs_caps();\r\nif (!caps)\r\nreturn -ENODEV;\r\nibs_eilvt_setup();\r\nif (!ibs_eilvt_valid())\r\nreturn -EINVAL;\r\nperf_ibs_pm_init();\r\nibs_caps = caps;\r\nsmp_mb();\r\ncpuhp_setup_state(CPUHP_AP_PERF_X86_AMD_IBS_STARTING,\r\n"AP_PERF_X86_AMD_IBS_STARTING",\r\nx86_pmu_amd_ibs_starting_cpu,\r\nx86_pmu_amd_ibs_dying_cpu);\r\nperf_event_ibs_init();\r\nreturn 0;\r\n}
