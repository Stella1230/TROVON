static\r\nvoid msm_write(struct uart_port *port, unsigned int val, unsigned int off)\r\n{\r\nwritel_relaxed(val, port->membase + off);\r\n}\r\nstatic\r\nunsigned int msm_read(struct uart_port *port, unsigned int off)\r\n{\r\nreturn readl_relaxed(port->membase + off);\r\n}\r\nstatic void msm_serial_set_mnd_regs_tcxo(struct uart_port *port)\r\n{\r\nmsm_write(port, 0x06, UART_MREG);\r\nmsm_write(port, 0xF1, UART_NREG);\r\nmsm_write(port, 0x0F, UART_DREG);\r\nmsm_write(port, 0x1A, UART_MNDREG);\r\nport->uartclk = 1843200;\r\n}\r\nstatic void msm_serial_set_mnd_regs_tcxoby4(struct uart_port *port)\r\n{\r\nmsm_write(port, 0x18, UART_MREG);\r\nmsm_write(port, 0xF6, UART_NREG);\r\nmsm_write(port, 0x0F, UART_DREG);\r\nmsm_write(port, 0x0A, UART_MNDREG);\r\nport->uartclk = 1843200;\r\n}\r\nstatic void msm_serial_set_mnd_regs(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nif (msm_port->is_uartdm)\r\nreturn;\r\nif (port->uartclk == 19200000)\r\nmsm_serial_set_mnd_regs_tcxo(port);\r\nelse if (port->uartclk == 4800000)\r\nmsm_serial_set_mnd_regs_tcxoby4(port);\r\n}\r\nstatic void msm_stop_dma(struct uart_port *port, struct msm_dma *dma)\r\n{\r\nstruct device *dev = port->dev;\r\nunsigned int mapped;\r\nu32 val;\r\nmapped = dma->count;\r\ndma->count = 0;\r\ndmaengine_terminate_all(dma->chan);\r\nval = msm_read(port, UARTDM_DMEN);\r\nval &= ~dma->enable_bit;\r\nmsm_write(port, val, UARTDM_DMEN);\r\nif (mapped)\r\ndma_unmap_single(dev, dma->phys, mapped, dma->dir);\r\n}\r\nstatic void msm_release_dma(struct msm_port *msm_port)\r\n{\r\nstruct msm_dma *dma;\r\ndma = &msm_port->tx_dma;\r\nif (dma->chan) {\r\nmsm_stop_dma(&msm_port->uart, dma);\r\ndma_release_channel(dma->chan);\r\n}\r\nmemset(dma, 0, sizeof(*dma));\r\ndma = &msm_port->rx_dma;\r\nif (dma->chan) {\r\nmsm_stop_dma(&msm_port->uart, dma);\r\ndma_release_channel(dma->chan);\r\nkfree(dma->virt);\r\n}\r\nmemset(dma, 0, sizeof(*dma));\r\n}\r\nstatic void msm_request_tx_dma(struct msm_port *msm_port, resource_size_t base)\r\n{\r\nstruct device *dev = msm_port->uart.dev;\r\nstruct dma_slave_config conf;\r\nstruct msm_dma *dma;\r\nu32 crci = 0;\r\nint ret;\r\ndma = &msm_port->tx_dma;\r\ndma->chan = dma_request_slave_channel_reason(dev, "tx");\r\nif (IS_ERR(dma->chan))\r\ngoto no_tx;\r\nof_property_read_u32(dev->of_node, "qcom,tx-crci", &crci);\r\nmemset(&conf, 0, sizeof(conf));\r\nconf.direction = DMA_MEM_TO_DEV;\r\nconf.device_fc = true;\r\nconf.dst_addr = base + UARTDM_TF;\r\nconf.dst_maxburst = UARTDM_BURST_SIZE;\r\nconf.slave_id = crci;\r\nret = dmaengine_slave_config(dma->chan, &conf);\r\nif (ret)\r\ngoto rel_tx;\r\ndma->dir = DMA_TO_DEVICE;\r\nif (msm_port->is_uartdm < UARTDM_1P4)\r\ndma->enable_bit = UARTDM_DMEN_TX_DM_ENABLE;\r\nelse\r\ndma->enable_bit = UARTDM_DMEN_TX_BAM_ENABLE;\r\nreturn;\r\nrel_tx:\r\ndma_release_channel(dma->chan);\r\nno_tx:\r\nmemset(dma, 0, sizeof(*dma));\r\n}\r\nstatic void msm_request_rx_dma(struct msm_port *msm_port, resource_size_t base)\r\n{\r\nstruct device *dev = msm_port->uart.dev;\r\nstruct dma_slave_config conf;\r\nstruct msm_dma *dma;\r\nu32 crci = 0;\r\nint ret;\r\ndma = &msm_port->rx_dma;\r\ndma->chan = dma_request_slave_channel_reason(dev, "rx");\r\nif (IS_ERR(dma->chan))\r\ngoto no_rx;\r\nof_property_read_u32(dev->of_node, "qcom,rx-crci", &crci);\r\ndma->virt = kzalloc(UARTDM_RX_SIZE, GFP_KERNEL);\r\nif (!dma->virt)\r\ngoto rel_rx;\r\nmemset(&conf, 0, sizeof(conf));\r\nconf.direction = DMA_DEV_TO_MEM;\r\nconf.device_fc = true;\r\nconf.src_addr = base + UARTDM_RF;\r\nconf.src_maxburst = UARTDM_BURST_SIZE;\r\nconf.slave_id = crci;\r\nret = dmaengine_slave_config(dma->chan, &conf);\r\nif (ret)\r\ngoto err;\r\ndma->dir = DMA_FROM_DEVICE;\r\nif (msm_port->is_uartdm < UARTDM_1P4)\r\ndma->enable_bit = UARTDM_DMEN_RX_DM_ENABLE;\r\nelse\r\ndma->enable_bit = UARTDM_DMEN_RX_BAM_ENABLE;\r\nreturn;\r\nerr:\r\nkfree(dma->virt);\r\nrel_rx:\r\ndma_release_channel(dma->chan);\r\nno_rx:\r\nmemset(dma, 0, sizeof(*dma));\r\n}\r\nstatic inline void msm_wait_for_xmitr(struct uart_port *port)\r\n{\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_EMPTY)) {\r\nif (msm_read(port, UART_ISR) & UART_ISR_TX_READY)\r\nbreak;\r\nudelay(1);\r\n}\r\nmsm_write(port, UART_CR_CMD_RESET_TX_READY, UART_CR);\r\n}\r\nstatic void msm_stop_tx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr &= ~UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_start_tx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nstruct msm_dma *dma = &msm_port->tx_dma;\r\nif (dma->count)\r\nreturn;\r\nmsm_port->imr |= UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_reset_dm_count(struct uart_port *port, int count)\r\n{\r\nmsm_wait_for_xmitr(port);\r\nmsm_write(port, count, UARTDM_NCF_TX);\r\nmsm_read(port, UARTDM_NCF_TX);\r\n}\r\nstatic void msm_complete_tx_dma(void *args)\r\n{\r\nstruct msm_port *msm_port = args;\r\nstruct uart_port *port = &msm_port->uart;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct msm_dma *dma = &msm_port->tx_dma;\r\nstruct dma_tx_state state;\r\nenum dma_status status;\r\nunsigned long flags;\r\nunsigned int count;\r\nu32 val;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (!dma->count)\r\ngoto done;\r\nstatus = dmaengine_tx_status(dma->chan, dma->cookie, &state);\r\ndma_unmap_single(port->dev, dma->phys, dma->count, dma->dir);\r\nval = msm_read(port, UARTDM_DMEN);\r\nval &= ~dma->enable_bit;\r\nmsm_write(port, val, UARTDM_DMEN);\r\nif (msm_port->is_uartdm > UARTDM_1P3) {\r\nmsm_write(port, UART_CR_CMD_RESET_TX, UART_CR);\r\nmsm_write(port, UART_CR_TX_ENABLE, UART_CR);\r\n}\r\ncount = dma->count - state.residue;\r\nport->icount.tx += count;\r\ndma->count = 0;\r\nxmit->tail += count;\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\nmsm_port->imr |= UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nmsm_handle_tx(port);\r\ndone:\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int msm_handle_tx_dma(struct msm_port *msm_port, unsigned int count)\r\n{\r\nstruct circ_buf *xmit = &msm_port->uart.state->xmit;\r\nstruct uart_port *port = &msm_port->uart;\r\nstruct msm_dma *dma = &msm_port->tx_dma;\r\nvoid *cpu_addr;\r\nint ret;\r\nu32 val;\r\ncpu_addr = &xmit->buf[xmit->tail];\r\ndma->phys = dma_map_single(port->dev, cpu_addr, count, dma->dir);\r\nret = dma_mapping_error(port->dev, dma->phys);\r\nif (ret)\r\nreturn ret;\r\ndma->desc = dmaengine_prep_slave_single(dma->chan, dma->phys,\r\ncount, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT |\r\nDMA_PREP_FENCE);\r\nif (!dma->desc) {\r\nret = -EIO;\r\ngoto unmap;\r\n}\r\ndma->desc->callback = msm_complete_tx_dma;\r\ndma->desc->callback_param = msm_port;\r\ndma->cookie = dmaengine_submit(dma->desc);\r\nret = dma_submit_error(dma->cookie);\r\nif (ret)\r\ngoto unmap;\r\nmsm_port->imr &= ~UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\ndma->count = count;\r\nval = msm_read(port, UARTDM_DMEN);\r\nval |= dma->enable_bit;\r\nif (msm_port->is_uartdm < UARTDM_1P4)\r\nmsm_write(port, val, UARTDM_DMEN);\r\nmsm_reset_dm_count(port, count);\r\nif (msm_port->is_uartdm > UARTDM_1P3)\r\nmsm_write(port, val, UARTDM_DMEN);\r\ndma_async_issue_pending(dma->chan);\r\nreturn 0;\r\nunmap:\r\ndma_unmap_single(port->dev, dma->phys, count, dma->dir);\r\nreturn ret;\r\n}\r\nstatic void msm_complete_rx_dma(void *args)\r\n{\r\nstruct msm_port *msm_port = args;\r\nstruct uart_port *port = &msm_port->uart;\r\nstruct tty_port *tport = &port->state->port;\r\nstruct msm_dma *dma = &msm_port->rx_dma;\r\nint count = 0, i, sysrq;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (!dma->count)\r\ngoto done;\r\nval = msm_read(port, UARTDM_DMEN);\r\nval &= ~dma->enable_bit;\r\nmsm_write(port, val, UARTDM_DMEN);\r\nif (msm_read(port, UART_SR) & UART_SR_OVERRUN) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\n}\r\ncount = msm_read(port, UARTDM_RX_TOTAL_SNAP);\r\nport->icount.rx += count;\r\ndma->count = 0;\r\ndma_unmap_single(port->dev, dma->phys, UARTDM_RX_SIZE, dma->dir);\r\nfor (i = 0; i < count; i++) {\r\nchar flag = TTY_NORMAL;\r\nif (msm_port->break_detected && dma->virt[i] == 0) {\r\nport->icount.brk++;\r\nflag = TTY_BREAK;\r\nmsm_port->break_detected = false;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (!(port->read_status_mask & UART_SR_RX_BREAK))\r\nflag = TTY_NORMAL;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nsysrq = uart_handle_sysrq_char(port, dma->virt[i]);\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (!sysrq)\r\ntty_insert_flip_char(tport, dma->virt[i], flag);\r\n}\r\nmsm_start_rx_dma(msm_port);\r\ndone:\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (count)\r\ntty_flip_buffer_push(tport);\r\n}\r\nstatic void msm_start_rx_dma(struct msm_port *msm_port)\r\n{\r\nstruct msm_dma *dma = &msm_port->rx_dma;\r\nstruct uart_port *uart = &msm_port->uart;\r\nu32 val;\r\nint ret;\r\nif (!dma->chan)\r\nreturn;\r\ndma->phys = dma_map_single(uart->dev, dma->virt,\r\nUARTDM_RX_SIZE, dma->dir);\r\nret = dma_mapping_error(uart->dev, dma->phys);\r\nif (ret)\r\nreturn;\r\ndma->desc = dmaengine_prep_slave_single(dma->chan, dma->phys,\r\nUARTDM_RX_SIZE, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT);\r\nif (!dma->desc)\r\ngoto unmap;\r\ndma->desc->callback = msm_complete_rx_dma;\r\ndma->desc->callback_param = msm_port;\r\ndma->cookie = dmaengine_submit(dma->desc);\r\nret = dma_submit_error(dma->cookie);\r\nif (ret)\r\ngoto unmap;\r\nmsm_port->imr &= ~(UART_IMR_RXLEV | UART_IMR_RXSTALE);\r\nif (msm_port->is_uartdm < UARTDM_1P4)\r\nmsm_port->imr |= UART_IMR_RXSTALE;\r\nmsm_write(uart, msm_port->imr, UART_IMR);\r\ndma->count = UARTDM_RX_SIZE;\r\ndma_async_issue_pending(dma->chan);\r\nmsm_write(uart, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(uart, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);\r\nval = msm_read(uart, UARTDM_DMEN);\r\nval |= dma->enable_bit;\r\nif (msm_port->is_uartdm < UARTDM_1P4)\r\nmsm_write(uart, val, UARTDM_DMEN);\r\nmsm_write(uart, UARTDM_RX_SIZE, UARTDM_DMRX);\r\nif (msm_port->is_uartdm > UARTDM_1P3)\r\nmsm_write(uart, val, UARTDM_DMEN);\r\nreturn;\r\nunmap:\r\ndma_unmap_single(uart->dev, dma->phys, UARTDM_RX_SIZE, dma->dir);\r\n}\r\nstatic void msm_stop_rx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nstruct msm_dma *dma = &msm_port->rx_dma;\r\nmsm_port->imr &= ~(UART_IMR_RXLEV | UART_IMR_RXSTALE);\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nif (dma->chan)\r\nmsm_stop_dma(port, dma);\r\n}\r\nstatic void msm_enable_ms(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr |= UART_IMR_DELTA_CTS;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_handle_rx_dm(struct uart_port *port, unsigned int misr)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned int sr;\r\nint count = 0;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nif ((msm_read(port, UART_SR) & UART_SR_OVERRUN)) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\n}\r\nif (misr & UART_IMR_RXSTALE) {\r\ncount = msm_read(port, UARTDM_RX_TOTAL_SNAP) -\r\nmsm_port->old_snap_state;\r\nmsm_port->old_snap_state = 0;\r\n} else {\r\ncount = 4 * (msm_read(port, UART_RFWR));\r\nmsm_port->old_snap_state += count;\r\n}\r\nport->icount.rx += count;\r\nwhile (count > 0) {\r\nunsigned char buf[4];\r\nint sysrq, r_count, i;\r\nsr = msm_read(port, UART_SR);\r\nif ((sr & UART_SR_RX_READY) == 0) {\r\nmsm_port->old_snap_state -= count;\r\nbreak;\r\n}\r\nioread32_rep(port->membase + UARTDM_RF, buf, 1);\r\nr_count = min_t(int, count, sizeof(buf));\r\nfor (i = 0; i < r_count; i++) {\r\nchar flag = TTY_NORMAL;\r\nif (msm_port->break_detected && buf[i] == 0) {\r\nport->icount.brk++;\r\nflag = TTY_BREAK;\r\nmsm_port->break_detected = false;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (!(port->read_status_mask & UART_SR_RX_BREAK))\r\nflag = TTY_NORMAL;\r\nspin_unlock(&port->lock);\r\nsysrq = uart_handle_sysrq_char(port, buf[i]);\r\nspin_lock(&port->lock);\r\nif (!sysrq)\r\ntty_insert_flip_char(tport, buf[i], flag);\r\n}\r\ncount -= r_count;\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\nif (misr & (UART_IMR_RXSTALE))\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);\r\nmsm_start_rx_dma(msm_port);\r\n}\r\nstatic void msm_handle_rx(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned int sr;\r\nif ((msm_read(port, UART_SR) & UART_SR_OVERRUN)) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\n}\r\nwhile ((sr = msm_read(port, UART_SR)) & UART_SR_RX_READY) {\r\nunsigned int c;\r\nchar flag = TTY_NORMAL;\r\nint sysrq;\r\nc = msm_read(port, UART_RF);\r\nif (sr & UART_SR_RX_BREAK) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (sr & UART_SR_PAR_FRAME_ERR) {\r\nport->icount.frame++;\r\n} else {\r\nport->icount.rx++;\r\n}\r\nsr &= port->read_status_mask;\r\nif (sr & UART_SR_RX_BREAK)\r\nflag = TTY_BREAK;\r\nelse if (sr & UART_SR_PAR_FRAME_ERR)\r\nflag = TTY_FRAME;\r\nspin_unlock(&port->lock);\r\nsysrq = uart_handle_sysrq_char(port, c);\r\nspin_lock(&port->lock);\r\nif (!sysrq)\r\ntty_insert_flip_char(tport, c, flag);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\n}\r\nstatic void msm_handle_tx_pio(struct uart_port *port, unsigned int tx_count)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int num_chars;\r\nunsigned int tf_pointer = 0;\r\nvoid __iomem *tf;\r\nif (msm_port->is_uartdm)\r\ntf = port->membase + UARTDM_TF;\r\nelse\r\ntf = port->membase + UART_TF;\r\nif (tx_count && msm_port->is_uartdm)\r\nmsm_reset_dm_count(port, tx_count);\r\nwhile (tf_pointer < tx_count) {\r\nint i;\r\nchar buf[4] = { 0 };\r\nif (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\nbreak;\r\nif (msm_port->is_uartdm)\r\nnum_chars = min(tx_count - tf_pointer,\r\n(unsigned int)sizeof(buf));\r\nelse\r\nnum_chars = 1;\r\nfor (i = 0; i < num_chars; i++) {\r\nbuf[i] = xmit->buf[xmit->tail + i];\r\nport->icount.tx++;\r\n}\r\niowrite32_rep(tf, buf, 1);\r\nxmit->tail = (xmit->tail + num_chars) & (UART_XMIT_SIZE - 1);\r\ntf_pointer += num_chars;\r\n}\r\nif (uart_circ_empty(xmit))\r\nmsm_stop_tx(port);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void msm_handle_tx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nstruct circ_buf *xmit = &msm_port->uart.state->xmit;\r\nstruct msm_dma *dma = &msm_port->tx_dma;\r\nunsigned int pio_count, dma_count, dma_min;\r\nvoid __iomem *tf;\r\nint err = 0;\r\nif (port->x_char) {\r\nif (msm_port->is_uartdm)\r\ntf = port->membase + UARTDM_TF;\r\nelse\r\ntf = port->membase + UART_TF;\r\nif (msm_port->is_uartdm)\r\nmsm_reset_dm_count(port, 1);\r\niowrite8_rep(tf, &port->x_char, 1);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nmsm_stop_tx(port);\r\nreturn;\r\n}\r\npio_count = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\ndma_count = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\ndma_min = 1;\r\nif (msm_port->is_uartdm > UARTDM_1P3) {\r\ndma_count = UARTDM_TX_AIGN(dma_count);\r\ndma_min = UARTDM_BURST_SIZE;\r\n} else {\r\nif (dma_count > UARTDM_TX_MAX)\r\ndma_count = UARTDM_TX_MAX;\r\n}\r\nif (pio_count > port->fifosize)\r\npio_count = port->fifosize;\r\nif (!dma->chan || dma_count < dma_min)\r\nmsm_handle_tx_pio(port, pio_count);\r\nelse\r\nerr = msm_handle_tx_dma(msm_port, dma_count);\r\nif (err)\r\nmsm_handle_tx_pio(port, pio_count);\r\n}\r\nstatic void msm_handle_delta_cts(struct uart_port *port)\r\n{\r\nmsm_write(port, UART_CR_CMD_RESET_CTS, UART_CR);\r\nport->icount.cts++;\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t msm_uart_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nstruct msm_dma *dma = &msm_port->rx_dma;\r\nunsigned long flags;\r\nunsigned int misr;\r\nu32 val;\r\nspin_lock_irqsave(&port->lock, flags);\r\nmisr = msm_read(port, UART_MISR);\r\nmsm_write(port, 0, UART_IMR);\r\nif (misr & UART_IMR_RXBREAK_START) {\r\nmsm_port->break_detected = true;\r\nmsm_write(port, UART_CR_CMD_RESET_RXBREAK_START, UART_CR);\r\n}\r\nif (misr & (UART_IMR_RXLEV | UART_IMR_RXSTALE)) {\r\nif (dma->count) {\r\nval = UART_CR_CMD_STALE_EVENT_DISABLE;\r\nmsm_write(port, val, UART_CR);\r\nval = UART_CR_CMD_RESET_STALE_INT;\r\nmsm_write(port, val, UART_CR);\r\ndmaengine_terminate_all(dma->chan);\r\n} else if (msm_port->is_uartdm) {\r\nmsm_handle_rx_dm(port, misr);\r\n} else {\r\nmsm_handle_rx(port);\r\n}\r\n}\r\nif (misr & UART_IMR_TXLEV)\r\nmsm_handle_tx(port);\r\nif (misr & UART_IMR_DELTA_CTS)\r\nmsm_handle_delta_cts(port);\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int msm_tx_empty(struct uart_port *port)\r\n{\r\nreturn (msm_read(port, UART_SR) & UART_SR_TX_EMPTY) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int msm_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR | TIOCM_RTS;\r\n}\r\nstatic void msm_reset(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_write(port, UART_CR_CMD_RESET_RX, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_TX, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_BREAK_INT, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_CTS, UART_CR);\r\nmsm_write(port, UART_CR_CMD_SET_RFR, UART_CR);\r\nif (msm_port->is_uartdm)\r\nmsm_write(port, 0, UARTDM_DMEN);\r\n}\r\nstatic void msm_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned int mr;\r\nmr = msm_read(port, UART_MR1);\r\nif (!(mctrl & TIOCM_RTS)) {\r\nmr &= ~UART_MR1_RX_RDY_CTL;\r\nmsm_write(port, mr, UART_MR1);\r\nmsm_write(port, UART_CR_CMD_RESET_RFR, UART_CR);\r\n} else {\r\nmr |= UART_MR1_RX_RDY_CTL;\r\nmsm_write(port, mr, UART_MR1);\r\n}\r\n}\r\nstatic void msm_break_ctl(struct uart_port *port, int break_ctl)\r\n{\r\nif (break_ctl)\r\nmsm_write(port, UART_CR_CMD_START_BREAK, UART_CR);\r\nelse\r\nmsm_write(port, UART_CR_CMD_STOP_BREAK, UART_CR);\r\n}\r\nstatic const struct msm_baud_map *\r\nmsm_find_best_baud(struct uart_port *port, unsigned int baud,\r\nunsigned long *rate)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int divisor, result;\r\nunsigned long target, old, best_rate = 0, diff, best_diff = ULONG_MAX;\r\nconst struct msm_baud_map *entry, *end, *best;\r\nstatic const struct msm_baud_map table[] = {\r\n{ 1, 0xff, 31 },\r\n{ 2, 0xee, 16 },\r\n{ 3, 0xdd, 8 },\r\n{ 4, 0xcc, 6 },\r\n{ 6, 0xbb, 6 },\r\n{ 8, 0xaa, 6 },\r\n{ 12, 0x99, 6 },\r\n{ 16, 0x88, 1 },\r\n{ 24, 0x77, 1 },\r\n{ 32, 0x66, 1 },\r\n{ 48, 0x55, 1 },\r\n{ 96, 0x44, 1 },\r\n{ 192, 0x33, 1 },\r\n{ 384, 0x22, 1 },\r\n{ 768, 0x11, 1 },\r\n{ 1536, 0x00, 1 },\r\n};\r\nbest = table;\r\ntarget = clk_round_rate(msm_port->clk, 16 * baud);\r\ndivisor = DIV_ROUND_CLOSEST(target, 16 * baud);\r\nend = table + ARRAY_SIZE(table);\r\nentry = table;\r\nwhile (entry < end) {\r\nif (entry->divisor <= divisor) {\r\nresult = target / entry->divisor / 16;\r\ndiff = abs(result - baud);\r\nif (diff < best_diff) {\r\nbest_diff = diff;\r\nbest = entry;\r\nbest_rate = target;\r\n}\r\nif (result == baud)\r\nbreak;\r\n} else if (entry->divisor > divisor) {\r\nold = target;\r\ntarget = clk_round_rate(msm_port->clk, old + 1);\r\nif (target == old)\r\nbreak;\r\nentry = table;\r\ndivisor = DIV_ROUND_CLOSEST(target, 16 * baud);\r\ncontinue;\r\n}\r\nentry++;\r\n}\r\n*rate = best_rate;\r\nreturn best;\r\n}\r\nstatic int msm_set_baud_rate(struct uart_port *port, unsigned int baud,\r\nunsigned long *saved_flags)\r\n{\r\nunsigned int rxstale, watermark, mask;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nconst struct msm_baud_map *entry;\r\nunsigned long flags, rate;\r\nflags = *saved_flags;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nentry = msm_find_best_baud(port, baud, &rate);\r\nclk_set_rate(msm_port->clk, rate);\r\nbaud = rate / 16 / entry->divisor;\r\nspin_lock_irqsave(&port->lock, flags);\r\n*saved_flags = flags;\r\nport->uartclk = rate;\r\nmsm_write(port, entry->code, UART_CSR);\r\nrxstale = entry->rxstale;\r\nwatermark = UART_IPR_STALE_LSB & rxstale;\r\nif (msm_port->is_uartdm) {\r\nmask = UART_DM_IPR_STALE_TIMEOUT_MSB;\r\n} else {\r\nwatermark |= UART_IPR_RXSTALE_LAST;\r\nmask = UART_IPR_STALE_TIMEOUT_MSB;\r\n}\r\nwatermark |= mask & (rxstale << 2);\r\nmsm_write(port, watermark, UART_IPR);\r\nwatermark = (port->fifosize * 3) / 4;\r\nmsm_write(port, watermark, UART_RFWR);\r\nmsm_write(port, 10, UART_TFWR);\r\nmsm_write(port, UART_CR_CMD_PROTECTION_EN, UART_CR);\r\nmsm_reset(port);\r\nmsm_write(port, UART_CR_TX_ENABLE | UART_CR_RX_ENABLE, UART_CR);\r\nmsm_port->imr = UART_IMR_RXLEV | UART_IMR_RXSTALE |\r\nUART_IMR_CURRENT_CTS | UART_IMR_RXBREAK_START;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nif (msm_port->is_uartdm) {\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);\r\n}\r\nreturn baud;\r\n}\r\nstatic void msm_init_clock(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nclk_prepare_enable(msm_port->clk);\r\nclk_prepare_enable(msm_port->pclk);\r\nmsm_serial_set_mnd_regs(port);\r\n}\r\nstatic int msm_startup(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int data, rfr_level, mask;\r\nint ret;\r\nsnprintf(msm_port->name, sizeof(msm_port->name),\r\n"msm_serial%d", port->line);\r\nret = request_irq(port->irq, msm_uart_irq, IRQF_TRIGGER_HIGH,\r\nmsm_port->name, port);\r\nif (unlikely(ret))\r\nreturn ret;\r\nmsm_init_clock(port);\r\nif (likely(port->fifosize > 12))\r\nrfr_level = port->fifosize - 12;\r\nelse\r\nrfr_level = port->fifosize;\r\ndata = msm_read(port, UART_MR1);\r\nif (msm_port->is_uartdm)\r\nmask = UART_DM_MR1_AUTO_RFR_LEVEL1;\r\nelse\r\nmask = UART_MR1_AUTO_RFR_LEVEL1;\r\ndata &= ~mask;\r\ndata &= ~UART_MR1_AUTO_RFR_LEVEL0;\r\ndata |= mask & (rfr_level << 2);\r\ndata |= UART_MR1_AUTO_RFR_LEVEL0 & rfr_level;\r\nmsm_write(port, data, UART_MR1);\r\nif (msm_port->is_uartdm) {\r\nmsm_request_tx_dma(msm_port, msm_port->uart.mapbase);\r\nmsm_request_rx_dma(msm_port, msm_port->uart.mapbase);\r\n}\r\nreturn 0;\r\n}\r\nstatic void msm_shutdown(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr = 0;\r\nmsm_write(port, 0, UART_IMR);\r\nif (msm_port->is_uartdm)\r\nmsm_release_dma(msm_port);\r\nclk_disable_unprepare(msm_port->clk);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void msm_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nstruct msm_dma *dma = &msm_port->rx_dma;\r\nunsigned long flags;\r\nunsigned int baud, mr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (dma->chan)\r\nmsm_stop_dma(port, dma);\r\nbaud = uart_get_baud_rate(port, termios, old, 300, 4000000);\r\nbaud = msm_set_baud_rate(port, baud, &flags);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nmr = msm_read(port, UART_MR2);\r\nmr &= ~UART_MR2_PARITY_MODE;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & PARODD)\r\nmr |= UART_MR2_PARITY_MODE_ODD;\r\nelse if (termios->c_cflag & CMSPAR)\r\nmr |= UART_MR2_PARITY_MODE_SPACE;\r\nelse\r\nmr |= UART_MR2_PARITY_MODE_EVEN;\r\n}\r\nmr &= ~UART_MR2_BITS_PER_CHAR;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nmr |= UART_MR2_BITS_PER_CHAR_5;\r\nbreak;\r\ncase CS6:\r\nmr |= UART_MR2_BITS_PER_CHAR_6;\r\nbreak;\r\ncase CS7:\r\nmr |= UART_MR2_BITS_PER_CHAR_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nmr |= UART_MR2_BITS_PER_CHAR_8;\r\nbreak;\r\n}\r\nmr &= ~(UART_MR2_STOP_BIT_LEN_ONE | UART_MR2_STOP_BIT_LEN_TWO);\r\nif (termios->c_cflag & CSTOPB)\r\nmr |= UART_MR2_STOP_BIT_LEN_TWO;\r\nelse\r\nmr |= UART_MR2_STOP_BIT_LEN_ONE;\r\nmsm_write(port, mr, UART_MR2);\r\nmr = msm_read(port, UART_MR1);\r\nmr &= ~(UART_MR1_CTS_CTL | UART_MR1_RX_RDY_CTL);\r\nif (termios->c_cflag & CRTSCTS) {\r\nmr |= UART_MR1_CTS_CTL;\r\nmr |= UART_MR1_RX_RDY_CTL;\r\n}\r\nmsm_write(port, mr, UART_MR1);\r\nport->read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UART_SR_PAR_FRAME_ERR;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= UART_SR_RX_BREAK;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nmsm_start_rx_dma(msm_port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *msm_type(struct uart_port *port)\r\n{\r\nreturn "MSM";\r\n}\r\nstatic void msm_release_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *uart_resource;\r\nresource_size_t size;\r\nuart_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!uart_resource))\r\nreturn;\r\nsize = resource_size(uart_resource);\r\nrelease_mem_region(port->mapbase, size);\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nstatic int msm_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *uart_resource;\r\nresource_size_t size;\r\nint ret;\r\nuart_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!uart_resource))\r\nreturn -ENXIO;\r\nsize = resource_size(uart_resource);\r\nif (!request_mem_region(port->mapbase, size, "msm_serial"))\r\nreturn -EBUSY;\r\nport->membase = ioremap(port->mapbase, size);\r\nif (!port->membase) {\r\nret = -EBUSY;\r\ngoto fail_release_port;\r\n}\r\nreturn 0;\r\nfail_release_port:\r\nrelease_mem_region(port->mapbase, size);\r\nreturn ret;\r\n}\r\nstatic void msm_config_port(struct uart_port *port, int flags)\r\n{\r\nint ret;\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_MSM;\r\nret = msm_request_port(port);\r\nif (ret)\r\nreturn;\r\n}\r\n}\r\nstatic int msm_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif (unlikely(ser->type != PORT_UNKNOWN && ser->type != PORT_MSM))\r\nreturn -EINVAL;\r\nif (unlikely(port->irq != ser->irq))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void msm_power(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nswitch (state) {\r\ncase 0:\r\nclk_prepare_enable(msm_port->clk);\r\nclk_prepare_enable(msm_port->pclk);\r\nbreak;\r\ncase 3:\r\nclk_disable_unprepare(msm_port->clk);\r\nclk_disable_unprepare(msm_port->pclk);\r\nbreak;\r\ndefault:\r\npr_err("msm_serial: Unknown PM state %d\n", state);\r\n}\r\n}\r\nstatic int msm_poll_get_char_single(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int rf_reg = msm_port->is_uartdm ? UARTDM_RF : UART_RF;\r\nif (!(msm_read(port, UART_SR) & UART_SR_RX_READY))\r\nreturn NO_POLL_CHAR;\r\nreturn msm_read(port, rf_reg) & 0xff;\r\n}\r\nstatic int msm_poll_get_char_dm(struct uart_port *port)\r\n{\r\nint c;\r\nstatic u32 slop;\r\nstatic int count;\r\nunsigned char *sp = (unsigned char *)&slop;\r\nif (count) {\r\nc = sp[sizeof(slop) - count];\r\ncount--;\r\n} else if (!(msm_read(port, UART_SR) & UART_SR_RX_READY)) {\r\ncount = msm_read(port, UARTDM_RXFS);\r\ncount = (count >> UARTDM_RXFS_BUF_SHIFT) & UARTDM_RXFS_BUF_MASK;\r\nif (count) {\r\nmsm_write(port, UART_CR_CMD_FORCE_STALE, UART_CR);\r\nslop = msm_read(port, UARTDM_RF);\r\nc = sp[0];\r\ncount--;\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE,\r\nUART_CR);\r\n} else {\r\nc = NO_POLL_CHAR;\r\n}\r\n} else {\r\nslop = msm_read(port, UARTDM_RF);\r\nc = sp[0];\r\ncount = sizeof(slop) - 1;\r\n}\r\nreturn c;\r\n}\r\nstatic int msm_poll_get_char(struct uart_port *port)\r\n{\r\nu32 imr;\r\nint c;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nimr = msm_read(port, UART_IMR);\r\nmsm_write(port, 0, UART_IMR);\r\nif (msm_port->is_uartdm)\r\nc = msm_poll_get_char_dm(port);\r\nelse\r\nc = msm_poll_get_char_single(port);\r\nmsm_write(port, imr, UART_IMR);\r\nreturn c;\r\n}\r\nstatic void msm_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nu32 imr;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nimr = msm_read(port, UART_IMR);\r\nmsm_write(port, 0, UART_IMR);\r\nif (msm_port->is_uartdm)\r\nmsm_reset_dm_count(port, 1);\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\ncpu_relax();\r\nmsm_write(port, c, msm_port->is_uartdm ? UARTDM_TF : UART_TF);\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\ncpu_relax();\r\nmsm_write(port, imr, UART_IMR);\r\n}\r\nstatic inline struct uart_port *msm_get_port_from_line(unsigned int line)\r\n{\r\nreturn &msm_uart_ports[line].uart;\r\n}\r\nstatic void __msm_console_write(struct uart_port *port, const char *s,\r\nunsigned int count, bool is_uartdm)\r\n{\r\nint i;\r\nint num_newlines = 0;\r\nbool replaced = false;\r\nvoid __iomem *tf;\r\nif (is_uartdm)\r\ntf = port->membase + UARTDM_TF;\r\nelse\r\ntf = port->membase + UART_TF;\r\nfor (i = 0; i < count; i++)\r\nif (s[i] == '\n')\r\nnum_newlines++;\r\ncount += num_newlines;\r\nspin_lock(&port->lock);\r\nif (is_uartdm)\r\nmsm_reset_dm_count(port, count);\r\ni = 0;\r\nwhile (i < count) {\r\nint j;\r\nunsigned int num_chars;\r\nchar buf[4] = { 0 };\r\nif (is_uartdm)\r\nnum_chars = min(count - i, (unsigned int)sizeof(buf));\r\nelse\r\nnum_chars = 1;\r\nfor (j = 0; j < num_chars; j++) {\r\nchar c = *s;\r\nif (c == '\n' && !replaced) {\r\nbuf[j] = '\r';\r\nj++;\r\nreplaced = true;\r\n}\r\nif (j < num_chars) {\r\nbuf[j] = c;\r\ns++;\r\nreplaced = false;\r\n}\r\n}\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\ncpu_relax();\r\niowrite32_rep(tf, buf, 1);\r\ni += num_chars;\r\n}\r\nspin_unlock(&port->lock);\r\n}\r\nstatic void msm_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port;\r\nstruct msm_port *msm_port;\r\nBUG_ON(co->index < 0 || co->index >= UART_NR);\r\nport = msm_get_port_from_line(co->index);\r\nmsm_port = UART_TO_MSM(port);\r\n__msm_console_write(port, s, count, msm_port->is_uartdm);\r\n}\r\nstatic int __init msm_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (unlikely(co->index >= UART_NR || co->index < 0))\r\nreturn -ENXIO;\r\nport = msm_get_port_from_line(co->index);\r\nif (unlikely(!port->membase))\r\nreturn -ENXIO;\r\nmsm_init_clock(port);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\npr_info("msm_serial: console setup on port #%d\n", port->line);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic void\r\nmsm_serial_early_write(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\n__msm_console_write(&dev->port, s, n, false);\r\n}\r\nstatic int __init\r\nmsm_serial_early_console_setup(struct earlycon_device *device, const char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = msm_serial_early_write;\r\nreturn 0;\r\n}\r\nstatic void\r\nmsm_serial_early_write_dm(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\n__msm_console_write(&dev->port, s, n, true);\r\n}\r\nstatic int __init\r\nmsm_serial_early_console_setup_dm(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = msm_serial_early_write_dm;\r\nreturn 0;\r\n}\r\nstatic int msm_serial_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_port *msm_port;\r\nstruct resource *resource;\r\nstruct uart_port *port;\r\nconst struct of_device_id *id;\r\nint irq, line;\r\nif (pdev->dev.of_node)\r\nline = of_alias_get_id(pdev->dev.of_node, "serial");\r\nelse\r\nline = pdev->id;\r\nif (line < 0)\r\nline = atomic_inc_return(&msm_uart_next_id) - 1;\r\nif (unlikely(line < 0 || line >= UART_NR))\r\nreturn -ENXIO;\r\ndev_info(&pdev->dev, "msm_serial: detected port #%d\n", line);\r\nport = msm_get_port_from_line(line);\r\nport->dev = &pdev->dev;\r\nmsm_port = UART_TO_MSM(port);\r\nid = of_match_device(msm_uartdm_table, &pdev->dev);\r\nif (id)\r\nmsm_port->is_uartdm = (unsigned long)id->data;\r\nelse\r\nmsm_port->is_uartdm = 0;\r\nmsm_port->clk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(msm_port->clk))\r\nreturn PTR_ERR(msm_port->clk);\r\nif (msm_port->is_uartdm) {\r\nmsm_port->pclk = devm_clk_get(&pdev->dev, "iface");\r\nif (IS_ERR(msm_port->pclk))\r\nreturn PTR_ERR(msm_port->pclk);\r\n}\r\nport->uartclk = clk_get_rate(msm_port->clk);\r\ndev_info(&pdev->dev, "uartclk = %d\n", port->uartclk);\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!resource))\r\nreturn -ENXIO;\r\nport->mapbase = resource->start;\r\nirq = platform_get_irq(pdev, 0);\r\nif (unlikely(irq < 0))\r\nreturn -ENXIO;\r\nport->irq = irq;\r\nplatform_set_drvdata(pdev, port);\r\nreturn uart_add_one_port(&msm_uart_driver, port);\r\n}\r\nstatic int msm_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&msm_uart_driver, port);\r\nreturn 0;\r\n}\r\nstatic int __init msm_serial_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&msm_uart_driver);\r\nif (unlikely(ret))\r\nreturn ret;\r\nret = platform_driver_register(&msm_platform_driver);\r\nif (unlikely(ret))\r\nuart_unregister_driver(&msm_uart_driver);\r\npr_info("msm_serial: driver initialized\n");\r\nreturn ret;\r\n}\r\nstatic void __exit msm_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&msm_platform_driver);\r\nuart_unregister_driver(&msm_uart_driver);\r\n}
