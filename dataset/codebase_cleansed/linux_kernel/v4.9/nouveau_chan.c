int\r\nnouveau_channel_idle(struct nouveau_channel *chan)\r\n{\r\nif (likely(chan && chan->fence)) {\r\nstruct nouveau_cli *cli = (void *)chan->user.client;\r\nstruct nouveau_fence *fence = NULL;\r\nint ret;\r\nret = nouveau_fence_new(chan, false, &fence);\r\nif (!ret) {\r\nret = nouveau_fence_wait(fence, false, false);\r\nnouveau_fence_unref(&fence);\r\n}\r\nif (ret) {\r\nNV_PRINTK(err, cli, "failed to idle channel %d [%s]\n",\r\nchan->chid, nvxx_client(&cli->base)->name);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_channel_del(struct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_channel *chan = *pchan;\r\nif (chan) {\r\nif (chan->fence)\r\nnouveau_fence(chan->drm)->context_del(chan);\r\nnvif_object_fini(&chan->nvsw);\r\nnvif_object_fini(&chan->gart);\r\nnvif_object_fini(&chan->vram);\r\nnvif_object_fini(&chan->user);\r\nnvif_object_fini(&chan->push.ctxdma);\r\nnouveau_bo_vma_del(chan->push.buffer, &chan->push.vma);\r\nnouveau_bo_unmap(chan->push.buffer);\r\nif (chan->push.buffer && chan->push.buffer->pin_refcnt)\r\nnouveau_bo_unpin(chan->push.buffer);\r\nnouveau_bo_ref(NULL, &chan->push.buffer);\r\nkfree(chan);\r\n}\r\n*pchan = NULL;\r\n}\r\nstatic int\r\nnouveau_channel_prep(struct nouveau_drm *drm, struct nvif_device *device,\r\nu32 size, struct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_cli *cli = (void *)device->object.client;\r\nstruct nvkm_mmu *mmu = nvxx_mmu(device);\r\nstruct nv_dma_v0 args = {};\r\nstruct nouveau_channel *chan;\r\nu32 target;\r\nint ret;\r\nchan = *pchan = kzalloc(sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn -ENOMEM;\r\nchan->device = device;\r\nchan->drm = drm;\r\ntarget = TTM_PL_FLAG_TT | TTM_PL_FLAG_UNCACHED;\r\nif (nouveau_vram_pushbuf)\r\ntarget = TTM_PL_FLAG_VRAM;\r\nret = nouveau_bo_new(drm->dev, size, 0, target, 0, 0, NULL, NULL,\r\n&chan->push.buffer);\r\nif (ret == 0) {\r\nret = nouveau_bo_pin(chan->push.buffer, target, false);\r\nif (ret == 0)\r\nret = nouveau_bo_map(chan->push.buffer);\r\n}\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nchan->push.vma.offset = chan->push.buffer->bo.offset;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nret = nouveau_bo_vma_add(chan->push.buffer, cli->vm,\r\n&chan->push.vma);\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = cli->vm->mmu->limit - 1;\r\n} else\r\nif (chan->push.buffer->bo.mem.mem_type == TTM_PL_VRAM) {\r\nif (device->info.family == NV_DEVICE_INFO_V0_TNT) {\r\nargs.target = NV_DMA_V0_TARGET_PCI;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = nvxx_device(device)->func->\r\nresource_addr(nvxx_device(device), 1);\r\nargs.limit = args.start + device->info.ram_user - 1;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VRAM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = device->info.ram_user - 1;\r\n}\r\n} else {\r\nif (chan->drm->agp.bridge) {\r\nargs.target = NV_DMA_V0_TARGET_AGP;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = chan->drm->agp.base;\r\nargs.limit = chan->drm->agp.base +\r\nchan->drm->agp.size - 1;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = mmu->limit - 1;\r\n}\r\n}\r\nret = nvif_object_init(&device->object, 0, NV_DMA_FROM_MEMORY,\r\n&args, sizeof(args), &chan->push.ctxdma);\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_channel_ind(struct nouveau_drm *drm, struct nvif_device *device,\r\nu32 engine, struct nouveau_channel **pchan)\r\n{\r\nstatic const u16 oclasses[] = { PASCAL_CHANNEL_GPFIFO_A,\r\nMAXWELL_CHANNEL_GPFIFO_A,\r\nKEPLER_CHANNEL_GPFIFO_B,\r\nKEPLER_CHANNEL_GPFIFO_A,\r\nFERMI_CHANNEL_GPFIFO,\r\nG82_CHANNEL_GPFIFO,\r\nNV50_CHANNEL_GPFIFO,\r\n0 };\r\nconst u16 *oclass = oclasses;\r\nunion {\r\nstruct nv50_channel_gpfifo_v0 nv50;\r\nstruct fermi_channel_gpfifo_v0 fermi;\r\nstruct kepler_channel_gpfifo_a_v0 kepler;\r\n} args;\r\nstruct nouveau_channel *chan;\r\nu32 size;\r\nint ret;\r\nret = nouveau_channel_prep(drm, device, 0x12000, &chan);\r\n*pchan = chan;\r\nif (ret)\r\nreturn ret;\r\ndo {\r\nif (oclass[0] >= KEPLER_CHANNEL_GPFIFO_A) {\r\nargs.kepler.version = 0;\r\nargs.kepler.engines = engine;\r\nargs.kepler.ilength = 0x02000;\r\nargs.kepler.ioffset = 0x10000 + chan->push.vma.offset;\r\nargs.kepler.vm = 0;\r\nsize = sizeof(args.kepler);\r\n} else\r\nif (oclass[0] >= FERMI_CHANNEL_GPFIFO) {\r\nargs.fermi.version = 0;\r\nargs.fermi.ilength = 0x02000;\r\nargs.fermi.ioffset = 0x10000 + chan->push.vma.offset;\r\nargs.fermi.vm = 0;\r\nsize = sizeof(args.fermi);\r\n} else {\r\nargs.nv50.version = 0;\r\nargs.nv50.ilength = 0x02000;\r\nargs.nv50.ioffset = 0x10000 + chan->push.vma.offset;\r\nargs.nv50.pushbuf = nvif_handle(&chan->push.ctxdma);\r\nargs.nv50.vm = 0;\r\nsize = sizeof(args.nv50);\r\n}\r\nret = nvif_object_init(&device->object, 0, *oclass++,\r\n&args, size, &chan->user);\r\nif (ret == 0) {\r\nif (chan->user.oclass >= KEPLER_CHANNEL_GPFIFO_A)\r\nchan->chid = args.kepler.chid;\r\nelse\r\nif (chan->user.oclass >= FERMI_CHANNEL_GPFIFO)\r\nchan->chid = args.fermi.chid;\r\nelse\r\nchan->chid = args.nv50.chid;\r\nreturn ret;\r\n}\r\n} while (*oclass);\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_channel_dma(struct nouveau_drm *drm, struct nvif_device *device,\r\nstruct nouveau_channel **pchan)\r\n{\r\nstatic const u16 oclasses[] = { NV40_CHANNEL_DMA,\r\nNV17_CHANNEL_DMA,\r\nNV10_CHANNEL_DMA,\r\nNV03_CHANNEL_DMA,\r\n0 };\r\nconst u16 *oclass = oclasses;\r\nstruct nv03_channel_dma_v0 args;\r\nstruct nouveau_channel *chan;\r\nint ret;\r\nret = nouveau_channel_prep(drm, device, 0x10000, &chan);\r\n*pchan = chan;\r\nif (ret)\r\nreturn ret;\r\nargs.version = 0;\r\nargs.pushbuf = nvif_handle(&chan->push.ctxdma);\r\nargs.offset = chan->push.vma.offset;\r\ndo {\r\nret = nvif_object_init(&device->object, 0, *oclass++,\r\n&args, sizeof(args), &chan->user);\r\nif (ret == 0) {\r\nchan->chid = args.chid;\r\nreturn ret;\r\n}\r\n} while (ret && *oclass);\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_channel_init(struct nouveau_channel *chan, u32 vram, u32 gart)\r\n{\r\nstruct nvif_device *device = chan->device;\r\nstruct nouveau_cli *cli = (void *)chan->user.client;\r\nstruct nvkm_mmu *mmu = nvxx_mmu(device);\r\nstruct nv_dma_v0 args = {};\r\nint ret, i;\r\nnvif_object_map(&chan->user);\r\nif (device->info.family < NV_DEVICE_INFO_V0_FERMI) {\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = cli->vm->mmu->limit - 1;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VRAM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = device->info.ram_user - 1;\r\n}\r\nret = nvif_object_init(&chan->user, vram, NV_DMA_IN_MEMORY,\r\n&args, sizeof(args), &chan->vram);\r\nif (ret)\r\nreturn ret;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = cli->vm->mmu->limit - 1;\r\n} else\r\nif (chan->drm->agp.bridge) {\r\nargs.target = NV_DMA_V0_TARGET_AGP;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = chan->drm->agp.base;\r\nargs.limit = chan->drm->agp.base +\r\nchan->drm->agp.size - 1;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = mmu->limit - 1;\r\n}\r\nret = nvif_object_init(&chan->user, gart, NV_DMA_IN_MEMORY,\r\n&args, sizeof(args), &chan->gart);\r\nif (ret)\r\nreturn ret;\r\n}\r\nswitch (chan->user.oclass & 0x00ff) {\r\ncase 0x006b:\r\ncase 0x006e:\r\nchan->user_put = 0x40;\r\nchan->user_get = 0x44;\r\nchan->dma.max = (0x10000 / 4) - 2;\r\nbreak;\r\ndefault:\r\nchan->user_put = 0x40;\r\nchan->user_get = 0x44;\r\nchan->user_get_hi = 0x60;\r\nchan->dma.ib_base = 0x10000 / 4;\r\nchan->dma.ib_max = (0x02000 / 8) - 1;\r\nchan->dma.ib_put = 0;\r\nchan->dma.ib_free = chan->dma.ib_max - chan->dma.ib_put;\r\nchan->dma.max = chan->dma.ib_base;\r\nbreak;\r\n}\r\nchan->dma.put = 0;\r\nchan->dma.cur = chan->dma.put;\r\nchan->dma.free = chan->dma.max - chan->dma.cur;\r\nret = RING_SPACE(chan, NOUVEAU_DMA_SKIPS);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < NOUVEAU_DMA_SKIPS; i++)\r\nOUT_RING(chan, 0x00000000);\r\nif (device->info.family < NV_DEVICE_INFO_V0_CELSIUS) {\r\nret = nvif_object_init(&chan->user, 0x006e,\r\nNVIF_CLASS_SW_NV04,\r\nNULL, 0, &chan->nvsw);\r\nif (ret)\r\nreturn ret;\r\nret = RING_SPACE(chan, 2);\r\nif (ret)\r\nreturn ret;\r\nBEGIN_NV04(chan, NvSubSw, 0x0000, 1);\r\nOUT_RING (chan, chan->nvsw.handle);\r\nFIRE_RING (chan);\r\n}\r\nreturn nouveau_fence(chan->drm)->context_new(chan);\r\n}\r\nint\r\nnouveau_channel_new(struct nouveau_drm *drm, struct nvif_device *device,\r\nu32 arg0, u32 arg1, struct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_cli *cli = (void *)device->object.client;\r\nbool super;\r\nint ret;\r\nsuper = cli->base.super;\r\ncli->base.super = true;\r\nret = nouveau_channel_ind(drm, device, arg0, pchan);\r\nif (ret) {\r\nNV_PRINTK(dbg, cli, "ib channel create, %d\n", ret);\r\nret = nouveau_channel_dma(drm, device, pchan);\r\nif (ret) {\r\nNV_PRINTK(dbg, cli, "dma channel create, %d\n", ret);\r\ngoto done;\r\n}\r\n}\r\nret = nouveau_channel_init(*pchan, arg0, arg1);\r\nif (ret) {\r\nNV_PRINTK(err, cli, "channel failed to initialise, %d\n", ret);\r\nnouveau_channel_del(pchan);\r\n}\r\ndone:\r\ncli->base.super = super;\r\nreturn ret;\r\n}
