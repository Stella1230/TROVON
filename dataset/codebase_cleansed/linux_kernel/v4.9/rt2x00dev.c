u32 rt2x00lib_get_bssidx(struct rt2x00_dev *rt2x00dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nif (rt2x00dev->intf_sta_count)\r\nreturn 0;\r\nreturn vif->addr[5] & (rt2x00dev->ops->max_ap_intf - 1);\r\n}\r\nint rt2x00lib_enable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint status;\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn 0;\r\nrt2x00queue_init_queues(rt2x00dev);\r\nstatus =\r\nrt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_ON);\r\nif (status)\r\nreturn status;\r\nrt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_IRQ_ON);\r\nrt2x00leds_led_radio(rt2x00dev, true);\r\nrt2x00led_led_activity(rt2x00dev, true);\r\nset_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags);\r\nrt2x00queue_start_queues(rt2x00dev);\r\nrt2x00link_start_tuner(rt2x00dev);\r\nrt2x00link_start_agc(rt2x00dev);\r\nif (rt2x00_has_cap_vco_recalibration(rt2x00dev))\r\nrt2x00link_start_vcocal(rt2x00dev);\r\nrt2x00link_start_watchdog(rt2x00dev);\r\nreturn 0;\r\n}\r\nvoid rt2x00lib_disable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (!test_and_clear_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn;\r\nrt2x00link_stop_watchdog(rt2x00dev);\r\nrt2x00link_stop_agc(rt2x00dev);\r\nif (rt2x00_has_cap_vco_recalibration(rt2x00dev))\r\nrt2x00link_stop_vcocal(rt2x00dev);\r\nrt2x00link_stop_tuner(rt2x00dev);\r\nrt2x00queue_stop_queues(rt2x00dev);\r\nrt2x00queue_flush_queues(rt2x00dev, true);\r\nrt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_OFF);\r\nrt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_IRQ_OFF);\r\nrt2x00led_led_activity(rt2x00dev, false);\r\nrt2x00leds_led_radio(rt2x00dev, false);\r\n}\r\nstatic void rt2x00lib_intf_scheduled_iter(void *data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = data;\r\nstruct rt2x00_intf *intf = vif_to_intf(vif);\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn;\r\nif (test_and_clear_bit(DELAYED_UPDATE_BEACON, &intf->delayed_flags)) {\r\nmutex_lock(&intf->beacon_skb_mutex);\r\nrt2x00queue_update_beacon(rt2x00dev, vif);\r\nmutex_unlock(&intf->beacon_skb_mutex);\r\n}\r\n}\r\nstatic void rt2x00lib_intf_scheduled(struct work_struct *work)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(work, struct rt2x00_dev, intf_work);\r\nieee80211_iterate_active_interfaces(rt2x00dev->hw,\r\nIEEE80211_IFACE_ITER_RESUME_ALL,\r\nrt2x00lib_intf_scheduled_iter,\r\nrt2x00dev);\r\n}\r\nstatic void rt2x00lib_autowakeup(struct work_struct *work)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(work, struct rt2x00_dev, autowakeup_work.work);\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn;\r\nif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))\r\nrt2x00_err(rt2x00dev, "Device failed to wakeup\n");\r\nclear_bit(CONFIG_POWERSAVING, &rt2x00dev->flags);\r\n}\r\nstatic void rt2x00lib_bc_buffer_iter(void *data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ieee80211_tx_control control = {};\r\nstruct rt2x00_dev *rt2x00dev = data;\r\nstruct sk_buff *skb;\r\nif (vif->type != NL80211_IFTYPE_AP)\r\nreturn;\r\nskb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);\r\nwhile (skb) {\r\nrt2x00mac_tx(rt2x00dev->hw, &control, skb);\r\nskb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);\r\n}\r\n}\r\nstatic void rt2x00lib_beaconupdate_iter(void *data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = data;\r\nif (vif->type != NL80211_IFTYPE_AP &&\r\nvif->type != NL80211_IFTYPE_ADHOC &&\r\nvif->type != NL80211_IFTYPE_MESH_POINT &&\r\nvif->type != NL80211_IFTYPE_WDS)\r\nreturn;\r\nWARN_ON(rt2x00_is_usb(rt2x00dev));\r\nrt2x00queue_update_beacon(rt2x00dev, vif);\r\n}\r\nvoid rt2x00lib_beacondone(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn;\r\nieee80211_iterate_active_interfaces_atomic(\r\nrt2x00dev->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\r\nrt2x00lib_bc_buffer_iter, rt2x00dev);\r\nif (rt2x00_has_cap_pre_tbtt_interrupt(rt2x00dev))\r\nreturn;\r\nieee80211_iterate_active_interfaces_atomic(\r\nrt2x00dev->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\r\nrt2x00lib_beaconupdate_iter, rt2x00dev);\r\n}\r\nvoid rt2x00lib_pretbtt(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn;\r\nieee80211_iterate_active_interfaces_atomic(\r\nrt2x00dev->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\r\nrt2x00lib_beaconupdate_iter, rt2x00dev);\r\n}\r\nvoid rt2x00lib_dmastart(struct queue_entry *entry)\r\n{\r\nset_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags);\r\nrt2x00queue_index_inc(entry, Q_INDEX);\r\n}\r\nvoid rt2x00lib_dmadone(struct queue_entry *entry)\r\n{\r\nset_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags);\r\nclear_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags);\r\nrt2x00queue_index_inc(entry, Q_INDEX_DMA_DONE);\r\n}\r\nstatic inline int rt2x00lib_txdone_bar_status(struct queue_entry *entry)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct ieee80211_bar *bar = (void *) entry->skb->data;\r\nstruct rt2x00_bar_list_entry *bar_entry;\r\nint ret;\r\nif (likely(!ieee80211_is_back_req(bar->frame_control)))\r\nreturn 0;\r\nret = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(bar_entry, &rt2x00dev->bar_list, list) {\r\nif (bar_entry->entry != entry)\r\ncontinue;\r\nspin_lock_bh(&rt2x00dev->bar_list_lock);\r\nret = bar_entry->block_acked;\r\nlist_del_rcu(&bar_entry->list);\r\nspin_unlock_bh(&rt2x00dev->bar_list_lock);\r\nkfree_rcu(bar_entry, head);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nvoid rt2x00lib_txdone(struct queue_entry *entry,\r\nstruct txdone_entry_desc *txdesc)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(entry->skb);\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nunsigned int header_length, i;\r\nu8 rate_idx, rate_flags, retry_rates;\r\nu8 skbdesc_flags = skbdesc->flags;\r\nbool success;\r\nrt2x00queue_unmap_skb(entry);\r\nskb_pull(entry->skb, rt2x00dev->extra_tx_headroom);\r\nskbdesc->flags &= ~SKBDESC_DESC_IN_SKB;\r\nheader_length = ieee80211_get_hdrlen_from_skb(entry->skb);\r\nif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_L2PAD))\r\nrt2x00queue_remove_l2pad(entry->skb, header_length);\r\nif (rt2x00_has_cap_hw_crypto(rt2x00dev))\r\nrt2x00crypto_tx_insert_iv(entry->skb, header_length);\r\nrt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_TXDONE, entry->skb);\r\nsuccess =\r\nrt2x00lib_txdone_bar_status(entry) ||\r\ntest_bit(TXDONE_SUCCESS, &txdesc->flags) ||\r\ntest_bit(TXDONE_UNKNOWN, &txdesc->flags);\r\nrt2x00dev->link.qual.tx_success += success;\r\nrt2x00dev->link.qual.tx_failed += !success;\r\nrate_idx = skbdesc->tx_rate_idx;\r\nrate_flags = skbdesc->tx_rate_flags;\r\nretry_rates = test_bit(TXDONE_FALLBACK, &txdesc->flags) ?\r\n(txdesc->retry + 1) : 1;\r\nmemset(&tx_info->status, 0, sizeof(tx_info->status));\r\ntx_info->status.ack_signal = 0;\r\nfor (i = 0; i < retry_rates && i < IEEE80211_TX_MAX_RATES; i++) {\r\ntx_info->status.rates[i].idx = rate_idx - i;\r\ntx_info->status.rates[i].flags = rate_flags;\r\nif (rate_idx - i == 0) {\r\ntx_info->status.rates[i].count = retry_rates - i;\r\ni++;\r\nbreak;\r\n}\r\ntx_info->status.rates[i].count = 1;\r\n}\r\nif (i < (IEEE80211_TX_MAX_RATES - 1))\r\ntx_info->status.rates[i].idx = -1;\r\nif (!(tx_info->flags & IEEE80211_TX_CTL_NO_ACK)) {\r\nif (success)\r\ntx_info->flags |= IEEE80211_TX_STAT_ACK;\r\nelse\r\nrt2x00dev->low_level_stats.dot11ACKFailureCount++;\r\n}\r\nif (test_bit(TXDONE_AMPDU, &txdesc->flags) ||\r\ntx_info->flags & IEEE80211_TX_CTL_AMPDU) {\r\ntx_info->flags |= IEEE80211_TX_STAT_AMPDU;\r\ntx_info->status.ampdu_len = 1;\r\ntx_info->status.ampdu_ack_len = success ? 1 : 0;\r\nif (!success)\r\ntx_info->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;\r\n}\r\nif (rate_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\r\nif (success)\r\nrt2x00dev->low_level_stats.dot11RTSSuccessCount++;\r\nelse\r\nrt2x00dev->low_level_stats.dot11RTSFailureCount++;\r\n}\r\nif (!(skbdesc_flags & SKBDESC_NOT_MAC80211)) {\r\nif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_TASKLET_CONTEXT))\r\nieee80211_tx_status(rt2x00dev->hw, entry->skb);\r\nelse\r\nieee80211_tx_status_ni(rt2x00dev->hw, entry->skb);\r\n} else\r\ndev_kfree_skb_any(entry->skb);\r\nentry->skb = NULL;\r\nentry->flags = 0;\r\nrt2x00dev->ops->lib->clear_entry(entry);\r\nrt2x00queue_index_inc(entry, Q_INDEX_DONE);\r\nspin_lock_bh(&entry->queue->tx_lock);\r\nif (!rt2x00queue_threshold(entry->queue))\r\nrt2x00queue_unpause_queue(entry->queue);\r\nspin_unlock_bh(&entry->queue->tx_lock);\r\n}\r\nvoid rt2x00lib_txdone_noinfo(struct queue_entry *entry, u32 status)\r\n{\r\nstruct txdone_entry_desc txdesc;\r\ntxdesc.flags = 0;\r\n__set_bit(status, &txdesc.flags);\r\ntxdesc.retry = 0;\r\nrt2x00lib_txdone(entry, &txdesc);\r\n}\r\nstatic u8 *rt2x00lib_find_ie(u8 *data, unsigned int len, u8 ie)\r\n{\r\nstruct ieee80211_mgmt *mgmt = (void *)data;\r\nu8 *pos, *end;\r\npos = (u8 *)mgmt->u.beacon.variable;\r\nend = data + len;\r\nwhile (pos < end) {\r\nif (pos + 2 + pos[1] > end)\r\nreturn NULL;\r\nif (pos[0] == ie)\r\nreturn pos;\r\npos += 2 + pos[1];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void rt2x00lib_sleep(struct work_struct *work)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(work, struct rt2x00_dev, sleep_work);\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn;\r\nif (!test_bit(CONFIG_POWERSAVING, &rt2x00dev->flags))\r\nrt2x00lib_config(rt2x00dev, &rt2x00dev->hw->conf,\r\nIEEE80211_CONF_CHANGE_PS);\r\n}\r\nstatic void rt2x00lib_rxdone_check_ba(struct rt2x00_dev *rt2x00dev,\r\nstruct sk_buff *skb,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct rt2x00_bar_list_entry *entry;\r\nstruct ieee80211_bar *ba = (void *)skb->data;\r\nif (likely(!ieee80211_is_back(ba->frame_control)))\r\nreturn;\r\nif (rxdesc->size < sizeof(*ba) + FCS_LEN)\r\nreturn;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(entry, &rt2x00dev->bar_list, list) {\r\nif (ba->start_seq_num != entry->start_seq_num)\r\ncontinue;\r\n#define TID_CHECK(a, b) ( \\r\n((a) & cpu_to_le16(IEEE80211_BAR_CTRL_TID_INFO_MASK)) == \\r\n((b) & cpu_to_le16(IEEE80211_BAR_CTRL_TID_INFO_MASK))) \\r\nif (!TID_CHECK(ba->control, entry->control))\r\ncontinue;\r\n#undef TID_CHECK\r\nif (!ether_addr_equal_64bits(ba->ra, entry->ta))\r\ncontinue;\r\nif (!ether_addr_equal_64bits(ba->ta, entry->ra))\r\ncontinue;\r\nspin_lock_bh(&rt2x00dev->bar_list_lock);\r\nentry->block_acked = 1;\r\nspin_unlock_bh(&rt2x00dev->bar_list_lock);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void rt2x00lib_rxdone_check_ps(struct rt2x00_dev *rt2x00dev,\r\nstruct sk_buff *skb,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct ieee80211_hdr *hdr = (void *) skb->data;\r\nstruct ieee80211_tim_ie *tim_ie;\r\nu8 *tim;\r\nu8 tim_len;\r\nbool cam;\r\nif (likely(!ieee80211_is_beacon(hdr->frame_control) ||\r\n!(rt2x00dev->hw->conf.flags & IEEE80211_CONF_PS)))\r\nreturn;\r\nif (skb->len <= 40 + FCS_LEN)\r\nreturn;\r\nif (!(rxdesc->dev_flags & RXDONE_MY_BSS) ||\r\n!rt2x00dev->aid)\r\nreturn;\r\nrt2x00dev->last_beacon = jiffies;\r\ntim = rt2x00lib_find_ie(skb->data, skb->len - FCS_LEN, WLAN_EID_TIM);\r\nif (!tim)\r\nreturn;\r\nif (tim[1] < sizeof(*tim_ie))\r\nreturn;\r\ntim_len = tim[1];\r\ntim_ie = (struct ieee80211_tim_ie *) &tim[2];\r\ncam = ieee80211_check_tim(tim_ie, tim_len, rt2x00dev->aid);\r\ncam |= (tim_ie->bitmap_ctrl & 0x01);\r\nif (!cam && !test_bit(CONFIG_POWERSAVING, &rt2x00dev->flags))\r\nqueue_work(rt2x00dev->workqueue, &rt2x00dev->sleep_work);\r\n}\r\nstatic int rt2x00lib_rxdone_read_signal(struct rt2x00_dev *rt2x00dev,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nconst struct rt2x00_rate *rate;\r\nunsigned int i;\r\nint signal = rxdesc->signal;\r\nint type = (rxdesc->dev_flags & RXDONE_SIGNAL_MASK);\r\nswitch (rxdesc->rate_mode) {\r\ncase RATE_MODE_CCK:\r\ncase RATE_MODE_OFDM:\r\nif (rxdesc->dev_flags & RXDONE_SIGNAL_MCS)\r\nsignal = RATE_MCS(rxdesc->rate_mode, signal);\r\nsband = &rt2x00dev->bands[rt2x00dev->curr_band];\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nrate = rt2x00_get_rate(sband->bitrates[i].hw_value);\r\nif (((type == RXDONE_SIGNAL_PLCP) &&\r\n(rate->plcp == signal)) ||\r\n((type == RXDONE_SIGNAL_BITRATE) &&\r\n(rate->bitrate == signal)) ||\r\n((type == RXDONE_SIGNAL_MCS) &&\r\n(rate->mcs == signal))) {\r\nreturn i;\r\n}\r\n}\r\nbreak;\r\ncase RATE_MODE_HT_MIX:\r\ncase RATE_MODE_HT_GREENFIELD:\r\nif (signal >= 0 && signal <= 76)\r\nreturn signal;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrt2x00_warn(rt2x00dev, "Frame received with unrecognized signal, mode=0x%.4x, signal=0x%.4x, type=%d\n",\r\nrxdesc->rate_mode, signal, type);\r\nreturn 0;\r\n}\r\nvoid rt2x00lib_rxdone(struct queue_entry *entry, gfp_t gfp)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct rxdone_entry_desc rxdesc;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_rx_status *rx_status;\r\nunsigned int header_length;\r\nint rate_idx;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) ||\r\n!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\ngoto submit_entry;\r\nif (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags))\r\ngoto submit_entry;\r\nskb = rt2x00queue_alloc_rxskb(entry, gfp);\r\nif (!skb)\r\ngoto submit_entry;\r\nrt2x00queue_unmap_skb(entry);\r\nmemset(&rxdesc, 0, sizeof(rxdesc));\r\nrt2x00dev->ops->lib->fill_rxdone(entry, &rxdesc);\r\nif (unlikely(rxdesc.size == 0 ||\r\nrxdesc.size > entry->queue->data_size)) {\r\nrt2x00_err(rt2x00dev, "Wrong frame size %d max %d\n",\r\nrxdesc.size, entry->queue->data_size);\r\ndev_kfree_skb(entry->skb);\r\ngoto renew_skb;\r\n}\r\nheader_length = ieee80211_get_hdrlen_from_skb(entry->skb);\r\nif ((rxdesc.dev_flags & RXDONE_CRYPTO_IV) &&\r\n(rxdesc.flags & RX_FLAG_IV_STRIPPED))\r\nrt2x00crypto_rx_insert_iv(entry->skb, header_length,\r\n&rxdesc);\r\nelse if (header_length &&\r\n(rxdesc.size > header_length) &&\r\n(rxdesc.dev_flags & RXDONE_L2PAD))\r\nrt2x00queue_remove_l2pad(entry->skb, header_length);\r\nskb_trim(entry->skb, rxdesc.size);\r\nrate_idx = rt2x00lib_rxdone_read_signal(rt2x00dev, &rxdesc);\r\nif (rxdesc.rate_mode == RATE_MODE_HT_MIX ||\r\nrxdesc.rate_mode == RATE_MODE_HT_GREENFIELD)\r\nrxdesc.flags |= RX_FLAG_HT;\r\nrt2x00lib_rxdone_check_ps(rt2x00dev, entry->skb, &rxdesc);\r\nrt2x00lib_rxdone_check_ba(rt2x00dev, entry->skb, &rxdesc);\r\nrt2x00link_update_stats(rt2x00dev, entry->skb, &rxdesc);\r\nrt2x00debug_update_crypto(rt2x00dev, &rxdesc);\r\nrt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_RXDONE, entry->skb);\r\nrx_status = IEEE80211_SKB_RXCB(entry->skb);\r\nmemset(rx_status, 0, sizeof(*rx_status));\r\nrx_status->mactime = rxdesc.timestamp;\r\nrx_status->band = rt2x00dev->curr_band;\r\nrx_status->freq = rt2x00dev->curr_freq;\r\nrx_status->rate_idx = rate_idx;\r\nrx_status->signal = rxdesc.rssi;\r\nrx_status->flag = rxdesc.flags;\r\nrx_status->antenna = rt2x00dev->link.ant.active.rx;\r\nieee80211_rx_ni(rt2x00dev->hw, entry->skb);\r\nrenew_skb:\r\nentry->skb = skb;\r\nsubmit_entry:\r\nentry->flags = 0;\r\nrt2x00queue_index_inc(entry, Q_INDEX_DONE);\r\nif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&\r\ntest_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt2x00dev->ops->lib->clear_entry(entry);\r\n}\r\nstatic void rt2x00lib_channel(struct ieee80211_channel *entry,\r\nconst int channel, const int tx_power,\r\nconst int value)\r\n{\r\nentry->band = channel <= 14 ? NL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\r\nentry->center_freq = ieee80211_channel_to_frequency(channel,\r\nentry->band);\r\nentry->hw_value = value;\r\nentry->max_power = tx_power;\r\nentry->max_antenna_gain = 0xff;\r\n}\r\nstatic void rt2x00lib_rate(struct ieee80211_rate *entry,\r\nconst u16 index, const struct rt2x00_rate *rate)\r\n{\r\nentry->flags = 0;\r\nentry->bitrate = rate->bitrate;\r\nentry->hw_value = index;\r\nentry->hw_value_short = index;\r\nif (rate->flags & DEV_RATE_SHORT_PREAMBLE)\r\nentry->flags |= IEEE80211_RATE_SHORT_PREAMBLE;\r\n}\r\nstatic int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,\r\nstruct hw_mode_spec *spec)\r\n{\r\nstruct ieee80211_hw *hw = rt2x00dev->hw;\r\nstruct ieee80211_channel *channels;\r\nstruct ieee80211_rate *rates;\r\nunsigned int num_rates;\r\nunsigned int i;\r\nnum_rates = 0;\r\nif (spec->supported_rates & SUPPORT_RATE_CCK)\r\nnum_rates += 4;\r\nif (spec->supported_rates & SUPPORT_RATE_OFDM)\r\nnum_rates += 8;\r\nchannels = kcalloc(spec->num_channels, sizeof(*channels), GFP_KERNEL);\r\nif (!channels)\r\nreturn -ENOMEM;\r\nrates = kcalloc(num_rates, sizeof(*rates), GFP_KERNEL);\r\nif (!rates)\r\ngoto exit_free_channels;\r\nfor (i = 0; i < num_rates; i++)\r\nrt2x00lib_rate(&rates[i], i, rt2x00_get_rate(i));\r\nfor (i = 0; i < spec->num_channels; i++) {\r\nrt2x00lib_channel(&channels[i],\r\nspec->channels[i].channel,\r\nspec->channels_info[i].max_power, i);\r\n}\r\nif (spec->supported_bands & SUPPORT_BAND_2GHZ) {\r\nrt2x00dev->bands[NL80211_BAND_2GHZ].n_channels = 14;\r\nrt2x00dev->bands[NL80211_BAND_2GHZ].n_bitrates = num_rates;\r\nrt2x00dev->bands[NL80211_BAND_2GHZ].channels = channels;\r\nrt2x00dev->bands[NL80211_BAND_2GHZ].bitrates = rates;\r\nhw->wiphy->bands[NL80211_BAND_2GHZ] =\r\n&rt2x00dev->bands[NL80211_BAND_2GHZ];\r\nmemcpy(&rt2x00dev->bands[NL80211_BAND_2GHZ].ht_cap,\r\n&spec->ht, sizeof(spec->ht));\r\n}\r\nif (spec->supported_bands & SUPPORT_BAND_5GHZ) {\r\nrt2x00dev->bands[NL80211_BAND_5GHZ].n_channels =\r\nspec->num_channels - 14;\r\nrt2x00dev->bands[NL80211_BAND_5GHZ].n_bitrates =\r\nnum_rates - 4;\r\nrt2x00dev->bands[NL80211_BAND_5GHZ].channels = &channels[14];\r\nrt2x00dev->bands[NL80211_BAND_5GHZ].bitrates = &rates[4];\r\nhw->wiphy->bands[NL80211_BAND_5GHZ] =\r\n&rt2x00dev->bands[NL80211_BAND_5GHZ];\r\nmemcpy(&rt2x00dev->bands[NL80211_BAND_5GHZ].ht_cap,\r\n&spec->ht, sizeof(spec->ht));\r\n}\r\nreturn 0;\r\nexit_free_channels:\r\nkfree(channels);\r\nrt2x00_err(rt2x00dev, "Allocation ieee80211 modes failed\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic void rt2x00lib_remove_hw(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (test_bit(DEVICE_STATE_REGISTERED_HW, &rt2x00dev->flags))\r\nieee80211_unregister_hw(rt2x00dev->hw);\r\nif (likely(rt2x00dev->hw->wiphy->bands[NL80211_BAND_2GHZ])) {\r\nkfree(rt2x00dev->hw->wiphy->bands[NL80211_BAND_2GHZ]->channels);\r\nkfree(rt2x00dev->hw->wiphy->bands[NL80211_BAND_2GHZ]->bitrates);\r\nrt2x00dev->hw->wiphy->bands[NL80211_BAND_2GHZ] = NULL;\r\nrt2x00dev->hw->wiphy->bands[NL80211_BAND_5GHZ] = NULL;\r\n}\r\nkfree(rt2x00dev->spec.channels_info);\r\n}\r\nstatic int rt2x00lib_probe_hw(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct hw_mode_spec *spec = &rt2x00dev->spec;\r\nint status;\r\nif (test_bit(DEVICE_STATE_REGISTERED_HW, &rt2x00dev->flags))\r\nreturn 0;\r\nstatus = rt2x00lib_probe_hw_modes(rt2x00dev, spec);\r\nif (status)\r\nreturn status;\r\nrt2x00dev->hw->queues = rt2x00dev->ops->tx_queues;\r\nrt2x00dev->hw->extra_tx_headroom =\r\nmax_t(unsigned int, IEEE80211_TX_STATUS_HEADROOM,\r\nrt2x00dev->extra_tx_headroom);\r\nif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_L2PAD))\r\nrt2x00dev->hw->extra_tx_headroom += RT2X00_L2PAD_SIZE;\r\nelse if (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DMA))\r\nrt2x00dev->hw->extra_tx_headroom += RT2X00_ALIGN_SIZE;\r\nrt2x00dev->hw->sta_data_size = sizeof(struct rt2x00_sta);\r\nif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_TXSTATUS_FIFO)) {\r\nint kfifo_size =\r\nroundup_pow_of_two(rt2x00dev->ops->tx_queues *\r\nrt2x00dev->tx->limit *\r\nsizeof(u32));\r\nstatus = kfifo_alloc(&rt2x00dev->txstatus_fifo, kfifo_size,\r\nGFP_KERNEL);\r\nif (status)\r\nreturn status;\r\n}\r\n#define RT2X00_TASKLET_INIT(taskletname) \\r\nif (rt2x00dev->ops->lib->taskletname) { \\r\ntasklet_init(&rt2x00dev->taskletname, \\r\nrt2x00dev->ops->lib->taskletname, \\r\n(unsigned long)rt2x00dev); \\r\n}\r\nRT2X00_TASKLET_INIT(txstatus_tasklet);\r\nRT2X00_TASKLET_INIT(pretbtt_tasklet);\r\nRT2X00_TASKLET_INIT(tbtt_tasklet);\r\nRT2X00_TASKLET_INIT(rxdone_tasklet);\r\nRT2X00_TASKLET_INIT(autowake_tasklet);\r\n#undef RT2X00_TASKLET_INIT\r\nstatus = ieee80211_register_hw(rt2x00dev->hw);\r\nif (status)\r\nreturn status;\r\nset_bit(DEVICE_STATE_REGISTERED_HW, &rt2x00dev->flags);\r\nreturn 0;\r\n}\r\nstatic void rt2x00lib_uninitialize(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (!test_and_clear_bit(DEVICE_STATE_INITIALIZED, &rt2x00dev->flags))\r\nreturn;\r\nif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DELAYED_RFKILL))\r\nrt2x00rfkill_unregister(rt2x00dev);\r\nrt2x00dev->ops->lib->uninitialize(rt2x00dev);\r\nrt2x00queue_uninitialize(rt2x00dev);\r\n}\r\nstatic int rt2x00lib_initialize(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint status;\r\nif (test_bit(DEVICE_STATE_INITIALIZED, &rt2x00dev->flags))\r\nreturn 0;\r\nstatus = rt2x00queue_initialize(rt2x00dev);\r\nif (status)\r\nreturn status;\r\nstatus = rt2x00dev->ops->lib->initialize(rt2x00dev);\r\nif (status) {\r\nrt2x00queue_uninitialize(rt2x00dev);\r\nreturn status;\r\n}\r\nset_bit(DEVICE_STATE_INITIALIZED, &rt2x00dev->flags);\r\nif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DELAYED_RFKILL))\r\nrt2x00rfkill_register(rt2x00dev);\r\nreturn 0;\r\n}\r\nint rt2x00lib_start(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint retval;\r\nif (test_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags))\r\nreturn 0;\r\nretval = rt2x00lib_load_firmware(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nretval = rt2x00lib_initialize(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nrt2x00dev->intf_ap_count = 0;\r\nrt2x00dev->intf_sta_count = 0;\r\nrt2x00dev->intf_associated = 0;\r\nretval = rt2x00lib_enable_radio(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nset_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags);\r\nreturn 0;\r\n}\r\nvoid rt2x00lib_stop(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (!test_and_clear_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags))\r\nreturn;\r\nrt2x00lib_disable_radio(rt2x00dev);\r\nrt2x00dev->intf_ap_count = 0;\r\nrt2x00dev->intf_sta_count = 0;\r\nrt2x00dev->intf_associated = 0;\r\n}\r\nstatic inline void rt2x00lib_set_if_combinations(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct ieee80211_iface_limit *if_limit;\r\nstruct ieee80211_iface_combination *if_combination;\r\nif (rt2x00dev->ops->max_ap_intf < 2)\r\nreturn;\r\nif_limit = &rt2x00dev->if_limits_ap;\r\nif_limit->max = rt2x00dev->ops->max_ap_intf;\r\nif_limit->types = BIT(NL80211_IFTYPE_AP);\r\n#ifdef CONFIG_MAC80211_MESH\r\nif_limit->types |= BIT(NL80211_IFTYPE_MESH_POINT);\r\n#endif\r\nif_combination = &rt2x00dev->if_combinations[IF_COMB_AP];\r\nif_combination->limits = if_limit;\r\nif_combination->n_limits = 1;\r\nif_combination->max_interfaces = if_limit->max;\r\nif_combination->num_different_channels = 1;\r\nrt2x00dev->hw->wiphy->iface_combinations = rt2x00dev->if_combinations;\r\nrt2x00dev->hw->wiphy->n_iface_combinations = 1;\r\n}\r\nstatic unsigned int rt2x00dev_extra_tx_headroom(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (WARN_ON(!rt2x00dev->tx))\r\nreturn 0;\r\nif (rt2x00_is_usb(rt2x00dev))\r\nreturn rt2x00dev->tx[0].winfo_size + rt2x00dev->tx[0].desc_size;\r\nreturn rt2x00dev->tx[0].winfo_size;\r\n}\r\nint rt2x00lib_probe_dev(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint retval = -ENOMEM;\r\nrt2x00lib_set_if_combinations(rt2x00dev);\r\nif (rt2x00dev->ops->drv_data_size > 0) {\r\nrt2x00dev->drv_data = kzalloc(rt2x00dev->ops->drv_data_size,\r\nGFP_KERNEL);\r\nif (!rt2x00dev->drv_data) {\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\n}\r\nspin_lock_init(&rt2x00dev->irqmask_lock);\r\nmutex_init(&rt2x00dev->csr_mutex);\r\nINIT_LIST_HEAD(&rt2x00dev->bar_list);\r\nspin_lock_init(&rt2x00dev->bar_list_lock);\r\nset_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\r\nrt2x00dev->hw->vif_data_size = sizeof(struct rt2x00_intf);\r\nrt2x00dev->hw->wiphy->addr_mask[ETH_ALEN - 1] =\r\n(rt2x00dev->ops->max_ap_intf - 1);\r\nrt2x00dev->workqueue =\r\nalloc_ordered_workqueue("%s", 0, wiphy_name(rt2x00dev->hw->wiphy));\r\nif (!rt2x00dev->workqueue) {\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\nINIT_WORK(&rt2x00dev->intf_work, rt2x00lib_intf_scheduled);\r\nINIT_DELAYED_WORK(&rt2x00dev->autowakeup_work, rt2x00lib_autowakeup);\r\nINIT_WORK(&rt2x00dev->sleep_work, rt2x00lib_sleep);\r\nretval = rt2x00dev->ops->lib->probe_hw(rt2x00dev);\r\nif (retval) {\r\nrt2x00_err(rt2x00dev, "Failed to allocate device\n");\r\ngoto exit;\r\n}\r\nretval = rt2x00queue_allocate(rt2x00dev);\r\nif (retval)\r\ngoto exit;\r\nrt2x00dev->extra_tx_headroom = rt2x00dev_extra_tx_headroom(rt2x00dev);\r\nrt2x00dev->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\r\nif (rt2x00dev->bcn->limit > 0)\r\nrt2x00dev->hw->wiphy->interface_modes |=\r\nBIT(NL80211_IFTYPE_ADHOC) |\r\nBIT(NL80211_IFTYPE_AP) |\r\n#ifdef CONFIG_MAC80211_MESH\r\nBIT(NL80211_IFTYPE_MESH_POINT) |\r\n#endif\r\nBIT(NL80211_IFTYPE_WDS);\r\nrt2x00dev->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\r\nretval = rt2x00lib_probe_hw(rt2x00dev);\r\nif (retval) {\r\nrt2x00_err(rt2x00dev, "Failed to initialize hw\n");\r\ngoto exit;\r\n}\r\nrt2x00link_register(rt2x00dev);\r\nrt2x00leds_register(rt2x00dev);\r\nrt2x00debug_register(rt2x00dev);\r\nif (!rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DELAYED_RFKILL))\r\nrt2x00rfkill_register(rt2x00dev);\r\nreturn 0;\r\nexit:\r\nrt2x00lib_remove_dev(rt2x00dev);\r\nreturn retval;\r\n}\r\nvoid rt2x00lib_remove_dev(struct rt2x00_dev *rt2x00dev)\r\n{\r\nclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\r\nif (!rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DELAYED_RFKILL))\r\nrt2x00rfkill_unregister(rt2x00dev);\r\nrt2x00lib_disable_radio(rt2x00dev);\r\ncancel_work_sync(&rt2x00dev->intf_work);\r\ncancel_delayed_work_sync(&rt2x00dev->autowakeup_work);\r\ncancel_work_sync(&rt2x00dev->sleep_work);\r\n#ifdef CONFIG_RT2X00_LIB_USB\r\nif (rt2x00_is_usb(rt2x00dev)) {\r\nusb_kill_anchored_urbs(rt2x00dev->anchor);\r\nhrtimer_cancel(&rt2x00dev->txstatus_timer);\r\ncancel_work_sync(&rt2x00dev->rxdone_work);\r\ncancel_work_sync(&rt2x00dev->txdone_work);\r\n}\r\n#endif\r\nif (rt2x00dev->workqueue)\r\ndestroy_workqueue(rt2x00dev->workqueue);\r\nkfifo_free(&rt2x00dev->txstatus_fifo);\r\ntasklet_kill(&rt2x00dev->txstatus_tasklet);\r\ntasklet_kill(&rt2x00dev->pretbtt_tasklet);\r\ntasklet_kill(&rt2x00dev->tbtt_tasklet);\r\ntasklet_kill(&rt2x00dev->rxdone_tasklet);\r\ntasklet_kill(&rt2x00dev->autowake_tasklet);\r\nrt2x00lib_uninitialize(rt2x00dev);\r\nrt2x00debug_deregister(rt2x00dev);\r\nrt2x00leds_unregister(rt2x00dev);\r\nrt2x00lib_remove_hw(rt2x00dev);\r\nrt2x00lib_free_firmware(rt2x00dev);\r\nrt2x00queue_free(rt2x00dev);\r\nkfree(rt2x00dev->drv_data);\r\n}\r\nint rt2x00lib_suspend(struct rt2x00_dev *rt2x00dev, pm_message_t state)\r\n{\r\nrt2x00_dbg(rt2x00dev, "Going to sleep\n");\r\nif (!test_and_clear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn 0;\r\nrt2x00lib_uninitialize(rt2x00dev);\r\nrt2x00leds_suspend(rt2x00dev);\r\nrt2x00debug_deregister(rt2x00dev);\r\nif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_SLEEP))\r\nrt2x00_warn(rt2x00dev, "Device failed to enter sleep state, continue suspending\n");\r\nreturn 0;\r\n}\r\nint rt2x00lib_resume(struct rt2x00_dev *rt2x00dev)\r\n{\r\nrt2x00_dbg(rt2x00dev, "Waking up\n");\r\nrt2x00debug_register(rt2x00dev);\r\nrt2x00leds_resume(rt2x00dev);\r\nset_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\r\nreturn 0;\r\n}
