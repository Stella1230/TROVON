static void extent_trunc(struct inode *inode, struct extent_position *epos,\r\nstruct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\r\nuint32_t nelen)\r\n{\r\nstruct kernel_lb_addr neloc = {};\r\nint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\r\ninode->i_sb->s_blocksize_bits;\r\nint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\r\ninode->i_sb->s_blocksize_bits;\r\nif (nelen) {\r\nif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\r\nudf_free_blocks(inode->i_sb, inode, eloc, 0,\r\nlast_block);\r\netype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\r\n} else\r\nneloc = *eloc;\r\nnelen = (etype << 30) | nelen;\r\n}\r\nif (elen != nelen) {\r\nudf_write_aext(inode, epos, &neloc, nelen, 0);\r\nif (last_block - first_block > 0) {\r\nif (etype == (EXT_RECORDED_ALLOCATED >> 30))\r\nmark_inode_dirty(inode);\r\nif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\r\nudf_free_blocks(inode->i_sb, inode, eloc,\r\nfirst_block,\r\nlast_block - first_block);\r\n}\r\n}\r\n}\r\nvoid udf_truncate_tail_extent(struct inode *inode)\r\n{\r\nstruct extent_position epos = {};\r\nstruct kernel_lb_addr eloc;\r\nuint32_t elen, nelen;\r\nuint64_t lbcount = 0;\r\nint8_t etype = -1, netype;\r\nint adsize;\r\nstruct udf_inode_info *iinfo = UDF_I(inode);\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\r\ninode->i_size == iinfo->i_lenExtents)\r\nreturn;\r\nif (inode->i_nlink == 0)\r\nreturn;\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\r\nadsize = sizeof(struct short_ad);\r\nelse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\r\nadsize = sizeof(struct long_ad);\r\nelse\r\nBUG();\r\nwhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\r\netype = netype;\r\nlbcount += elen;\r\nif (lbcount > inode->i_size) {\r\nif (lbcount - inode->i_size >= inode->i_sb->s_blocksize)\r\nudf_warn(inode->i_sb,\r\n"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\n",\r\n(unsigned)inode->i_ino,\r\n(long long)inode->i_size,\r\n(long long)lbcount,\r\n(unsigned)eloc.logicalBlockNum,\r\n(unsigned)elen);\r\nnelen = elen - (lbcount - inode->i_size);\r\nepos.offset -= adsize;\r\nextent_trunc(inode, &epos, &eloc, etype, elen, nelen);\r\nepos.offset += adsize;\r\nif (udf_next_aext(inode, &epos, &eloc, &elen, 1) != -1)\r\nudf_err(inode->i_sb,\r\n"Extent after EOF in inode %u\n",\r\n(unsigned)inode->i_ino);\r\nbreak;\r\n}\r\n}\r\niinfo->i_lenExtents = inode->i_size;\r\nbrelse(epos.bh);\r\n}\r\nvoid udf_discard_prealloc(struct inode *inode)\r\n{\r\nstruct extent_position epos = { NULL, 0, {0, 0} };\r\nstruct kernel_lb_addr eloc;\r\nuint32_t elen;\r\nuint64_t lbcount = 0;\r\nint8_t etype = -1, netype;\r\nint adsize;\r\nstruct udf_inode_info *iinfo = UDF_I(inode);\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\r\ninode->i_size == iinfo->i_lenExtents)\r\nreturn;\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\r\nadsize = sizeof(struct short_ad);\r\nelse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\r\nadsize = sizeof(struct long_ad);\r\nelse\r\nadsize = 0;\r\nepos.block = iinfo->i_location;\r\nwhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\r\netype = netype;\r\nlbcount += elen;\r\n}\r\nif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\r\nepos.offset -= adsize;\r\nlbcount -= elen;\r\nextent_trunc(inode, &epos, &eloc, etype, elen, 0);\r\nif (!epos.bh) {\r\niinfo->i_lenAlloc =\r\nepos.offset -\r\nudf_file_entry_alloc_offset(inode);\r\nmark_inode_dirty(inode);\r\n} else {\r\nstruct allocExtDesc *aed =\r\n(struct allocExtDesc *)(epos.bh->b_data);\r\naed->lengthAllocDescs =\r\ncpu_to_le32(epos.offset -\r\nsizeof(struct allocExtDesc));\r\nif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\r\nUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\r\nudf_update_tag(epos.bh->b_data, epos.offset);\r\nelse\r\nudf_update_tag(epos.bh->b_data,\r\nsizeof(struct allocExtDesc));\r\nmark_buffer_dirty_inode(epos.bh, inode);\r\n}\r\n}\r\niinfo->i_lenExtents = lbcount;\r\nbrelse(epos.bh);\r\n}\r\nstatic void udf_update_alloc_ext_desc(struct inode *inode,\r\nstruct extent_position *epos,\r\nu32 lenalloc)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct udf_sb_info *sbi = UDF_SB(sb);\r\nstruct allocExtDesc *aed = (struct allocExtDesc *) (epos->bh->b_data);\r\nint len = sizeof(struct allocExtDesc);\r\naed->lengthAllocDescs = cpu_to_le32(lenalloc);\r\nif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT) || sbi->s_udfrev >= 0x0201)\r\nlen += lenalloc;\r\nudf_update_tag(epos->bh->b_data, len);\r\nmark_buffer_dirty_inode(epos->bh, inode);\r\n}\r\nvoid udf_truncate_extents(struct inode *inode)\r\n{\r\nstruct extent_position epos;\r\nstruct kernel_lb_addr eloc, neloc = {};\r\nuint32_t elen, nelen = 0, indirect_ext_len = 0, lenalloc;\r\nint8_t etype;\r\nstruct super_block *sb = inode->i_sb;\r\nsector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;\r\nloff_t byte_offset;\r\nint adsize;\r\nstruct udf_inode_info *iinfo = UDF_I(inode);\r\nif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\r\nadsize = sizeof(struct short_ad);\r\nelse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\r\nadsize = sizeof(struct long_ad);\r\nelse\r\nBUG();\r\netype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\r\nbyte_offset = (offset << sb->s_blocksize_bits) +\r\n(inode->i_size & (sb->s_blocksize - 1));\r\nif (etype == -1) {\r\nWARN_ON(byte_offset);\r\nreturn;\r\n}\r\nepos.offset -= adsize;\r\nextent_trunc(inode, &epos, &eloc, etype, elen, byte_offset);\r\nepos.offset += adsize;\r\nif (byte_offset)\r\nlenalloc = epos.offset;\r\nelse\r\nlenalloc = epos.offset - adsize;\r\nif (!epos.bh)\r\nlenalloc -= udf_file_entry_alloc_offset(inode);\r\nelse\r\nlenalloc -= sizeof(struct allocExtDesc);\r\nwhile ((etype = udf_current_aext(inode, &epos, &eloc,\r\n&elen, 0)) != -1) {\r\nif (etype == (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\r\nudf_write_aext(inode, &epos, &neloc, nelen, 0);\r\nif (indirect_ext_len) {\r\nBUG_ON(!epos.bh);\r\nudf_free_blocks(sb, NULL, &epos.block,\r\n0, indirect_ext_len);\r\n} else if (!epos.bh) {\r\niinfo->i_lenAlloc = lenalloc;\r\nmark_inode_dirty(inode);\r\n} else\r\nudf_update_alloc_ext_desc(inode,\r\n&epos, lenalloc);\r\nbrelse(epos.bh);\r\nepos.offset = sizeof(struct allocExtDesc);\r\nepos.block = eloc;\r\nepos.bh = udf_tread(sb,\r\nudf_get_lb_pblock(sb, &eloc, 0));\r\nif (elen)\r\nindirect_ext_len =\r\n(elen + sb->s_blocksize - 1) >>\r\nsb->s_blocksize_bits;\r\nelse\r\nindirect_ext_len = 1;\r\n} else {\r\nextent_trunc(inode, &epos, &eloc, etype, elen, 0);\r\nepos.offset += adsize;\r\n}\r\n}\r\nif (indirect_ext_len) {\r\nBUG_ON(!epos.bh);\r\nudf_free_blocks(sb, NULL, &epos.block, 0, indirect_ext_len);\r\n} else if (!epos.bh) {\r\niinfo->i_lenAlloc = lenalloc;\r\nmark_inode_dirty(inode);\r\n} else\r\nudf_update_alloc_ext_desc(inode, &epos, lenalloc);\r\niinfo->i_lenExtents = inode->i_size;\r\nbrelse(epos.bh);\r\n}
