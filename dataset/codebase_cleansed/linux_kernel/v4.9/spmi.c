static void spmi_dev_release(struct device *dev)\r\n{\r\nstruct spmi_device *sdev = to_spmi_device(dev);\r\nkfree(sdev);\r\n}\r\nstatic void spmi_ctrl_release(struct device *dev)\r\n{\r\nstruct spmi_controller *ctrl = to_spmi_controller(dev);\r\nida_simple_remove(&ctrl_ida, ctrl->nr);\r\nkfree(ctrl);\r\n}\r\nstatic int spmi_device_match(struct device *dev, struct device_driver *drv)\r\n{\r\nif (of_driver_match_device(dev, drv))\r\nreturn 1;\r\nif (drv->name)\r\nreturn strncmp(dev_name(dev), drv->name,\r\nSPMI_NAME_SIZE) == 0;\r\nreturn 0;\r\n}\r\nint spmi_device_add(struct spmi_device *sdev)\r\n{\r\nstruct spmi_controller *ctrl = sdev->ctrl;\r\nint err;\r\ndev_set_name(&sdev->dev, "%d-%02x", ctrl->nr, sdev->usid);\r\nerr = device_add(&sdev->dev);\r\nif (err < 0) {\r\ndev_err(&sdev->dev, "Can't add %s, status %d\n",\r\ndev_name(&sdev->dev), err);\r\ngoto err_device_add;\r\n}\r\ndev_dbg(&sdev->dev, "device %s registered\n", dev_name(&sdev->dev));\r\nerr_device_add:\r\nreturn err;\r\n}\r\nvoid spmi_device_remove(struct spmi_device *sdev)\r\n{\r\ndevice_unregister(&sdev->dev);\r\n}\r\nstatic inline int\r\nspmi_cmd(struct spmi_controller *ctrl, u8 opcode, u8 sid)\r\n{\r\nint ret;\r\nif (!ctrl || !ctrl->cmd || ctrl->dev.type != &spmi_ctrl_type)\r\nreturn -EINVAL;\r\nret = ctrl->cmd(ctrl, opcode, sid);\r\ntrace_spmi_cmd(opcode, sid, ret);\r\nreturn ret;\r\n}\r\nstatic inline int spmi_read_cmd(struct spmi_controller *ctrl, u8 opcode,\r\nu8 sid, u16 addr, u8 *buf, size_t len)\r\n{\r\nint ret;\r\nif (!ctrl || !ctrl->read_cmd || ctrl->dev.type != &spmi_ctrl_type)\r\nreturn -EINVAL;\r\ntrace_spmi_read_begin(opcode, sid, addr);\r\nret = ctrl->read_cmd(ctrl, opcode, sid, addr, buf, len);\r\ntrace_spmi_read_end(opcode, sid, addr, ret, len, buf);\r\nreturn ret;\r\n}\r\nstatic inline int spmi_write_cmd(struct spmi_controller *ctrl, u8 opcode,\r\nu8 sid, u16 addr, const u8 *buf, size_t len)\r\n{\r\nint ret;\r\nif (!ctrl || !ctrl->write_cmd || ctrl->dev.type != &spmi_ctrl_type)\r\nreturn -EINVAL;\r\ntrace_spmi_write_begin(opcode, sid, addr, len, buf);\r\nret = ctrl->write_cmd(ctrl, opcode, sid, addr, buf, len);\r\ntrace_spmi_write_end(opcode, sid, addr, ret);\r\nreturn ret;\r\n}\r\nint spmi_register_read(struct spmi_device *sdev, u8 addr, u8 *buf)\r\n{\r\nif (addr > 0x1F)\r\nreturn -EINVAL;\r\nreturn spmi_read_cmd(sdev->ctrl, SPMI_CMD_READ, sdev->usid, addr,\r\nbuf, 1);\r\n}\r\nint spmi_ext_register_read(struct spmi_device *sdev, u8 addr, u8 *buf,\r\nsize_t len)\r\n{\r\nif (len == 0 || len > 16)\r\nreturn -EINVAL;\r\nreturn spmi_read_cmd(sdev->ctrl, SPMI_CMD_EXT_READ, sdev->usid, addr,\r\nbuf, len);\r\n}\r\nint spmi_ext_register_readl(struct spmi_device *sdev, u16 addr, u8 *buf,\r\nsize_t len)\r\n{\r\nif (len == 0 || len > 8)\r\nreturn -EINVAL;\r\nreturn spmi_read_cmd(sdev->ctrl, SPMI_CMD_EXT_READL, sdev->usid, addr,\r\nbuf, len);\r\n}\r\nint spmi_register_write(struct spmi_device *sdev, u8 addr, u8 data)\r\n{\r\nif (addr > 0x1F)\r\nreturn -EINVAL;\r\nreturn spmi_write_cmd(sdev->ctrl, SPMI_CMD_WRITE, sdev->usid, addr,\r\n&data, 1);\r\n}\r\nint spmi_register_zero_write(struct spmi_device *sdev, u8 data)\r\n{\r\nreturn spmi_write_cmd(sdev->ctrl, SPMI_CMD_ZERO_WRITE, sdev->usid, 0,\r\n&data, 1);\r\n}\r\nint spmi_ext_register_write(struct spmi_device *sdev, u8 addr, const u8 *buf,\r\nsize_t len)\r\n{\r\nif (len == 0 || len > 16)\r\nreturn -EINVAL;\r\nreturn spmi_write_cmd(sdev->ctrl, SPMI_CMD_EXT_WRITE, sdev->usid, addr,\r\nbuf, len);\r\n}\r\nint spmi_ext_register_writel(struct spmi_device *sdev, u16 addr, const u8 *buf,\r\nsize_t len)\r\n{\r\nif (len == 0 || len > 8)\r\nreturn -EINVAL;\r\nreturn spmi_write_cmd(sdev->ctrl, SPMI_CMD_EXT_WRITEL, sdev->usid,\r\naddr, buf, len);\r\n}\r\nint spmi_command_reset(struct spmi_device *sdev)\r\n{\r\nreturn spmi_cmd(sdev->ctrl, SPMI_CMD_RESET, sdev->usid);\r\n}\r\nint spmi_command_sleep(struct spmi_device *sdev)\r\n{\r\nreturn spmi_cmd(sdev->ctrl, SPMI_CMD_SLEEP, sdev->usid);\r\n}\r\nint spmi_command_wakeup(struct spmi_device *sdev)\r\n{\r\nreturn spmi_cmd(sdev->ctrl, SPMI_CMD_WAKEUP, sdev->usid);\r\n}\r\nint spmi_command_shutdown(struct spmi_device *sdev)\r\n{\r\nreturn spmi_cmd(sdev->ctrl, SPMI_CMD_SHUTDOWN, sdev->usid);\r\n}\r\nstatic int spmi_drv_probe(struct device *dev)\r\n{\r\nconst struct spmi_driver *sdrv = to_spmi_driver(dev->driver);\r\nstruct spmi_device *sdev = to_spmi_device(dev);\r\nint err;\r\npm_runtime_get_noresume(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nerr = sdrv->probe(sdev);\r\nif (err)\r\ngoto fail_probe;\r\nreturn 0;\r\nfail_probe:\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_put_noidle(dev);\r\nreturn err;\r\n}\r\nstatic int spmi_drv_remove(struct device *dev)\r\n{\r\nconst struct spmi_driver *sdrv = to_spmi_driver(dev->driver);\r\npm_runtime_get_sync(dev);\r\nsdrv->remove(to_spmi_device(dev));\r\npm_runtime_put_noidle(dev);\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_put_noidle(dev);\r\nreturn 0;\r\n}\r\nstruct spmi_device *spmi_device_alloc(struct spmi_controller *ctrl)\r\n{\r\nstruct spmi_device *sdev;\r\nsdev = kzalloc(sizeof(*sdev), GFP_KERNEL);\r\nif (!sdev)\r\nreturn NULL;\r\nsdev->ctrl = ctrl;\r\ndevice_initialize(&sdev->dev);\r\nsdev->dev.parent = &ctrl->dev;\r\nsdev->dev.bus = &spmi_bus_type;\r\nsdev->dev.type = &spmi_dev_type;\r\nreturn sdev;\r\n}\r\nstruct spmi_controller *spmi_controller_alloc(struct device *parent,\r\nsize_t size)\r\n{\r\nstruct spmi_controller *ctrl;\r\nint id;\r\nif (WARN_ON(!parent))\r\nreturn NULL;\r\nctrl = kzalloc(sizeof(*ctrl) + size, GFP_KERNEL);\r\nif (!ctrl)\r\nreturn NULL;\r\ndevice_initialize(&ctrl->dev);\r\nctrl->dev.type = &spmi_ctrl_type;\r\nctrl->dev.bus = &spmi_bus_type;\r\nctrl->dev.parent = parent;\r\nctrl->dev.of_node = parent->of_node;\r\nspmi_controller_set_drvdata(ctrl, &ctrl[1]);\r\nid = ida_simple_get(&ctrl_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\ndev_err(parent,\r\n"unable to allocate SPMI controller identifier.\n");\r\nspmi_controller_put(ctrl);\r\nreturn NULL;\r\n}\r\nctrl->nr = id;\r\ndev_set_name(&ctrl->dev, "spmi-%d", id);\r\ndev_dbg(&ctrl->dev, "allocated controller 0x%p id %d\n", ctrl, id);\r\nreturn ctrl;\r\n}\r\nstatic void of_spmi_register_devices(struct spmi_controller *ctrl)\r\n{\r\nstruct device_node *node;\r\nint err;\r\nif (!ctrl->dev.of_node)\r\nreturn;\r\nfor_each_available_child_of_node(ctrl->dev.of_node, node) {\r\nstruct spmi_device *sdev;\r\nu32 reg[2];\r\ndev_dbg(&ctrl->dev, "adding child %s\n", node->full_name);\r\nerr = of_property_read_u32_array(node, "reg", reg, 2);\r\nif (err) {\r\ndev_err(&ctrl->dev,\r\n"node %s err (%d) does not have 'reg' property\n",\r\nnode->full_name, err);\r\ncontinue;\r\n}\r\nif (reg[1] != SPMI_USID) {\r\ndev_err(&ctrl->dev,\r\n"node %s contains unsupported 'reg' entry\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\nif (reg[0] >= SPMI_MAX_SLAVE_ID) {\r\ndev_err(&ctrl->dev,\r\n"invalid usid on node %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\ndev_dbg(&ctrl->dev, "read usid %02x\n", reg[0]);\r\nsdev = spmi_device_alloc(ctrl);\r\nif (!sdev)\r\ncontinue;\r\nsdev->dev.of_node = node;\r\nsdev->usid = (u8) reg[0];\r\nerr = spmi_device_add(sdev);\r\nif (err) {\r\ndev_err(&sdev->dev,\r\n"failure adding device. status %d\n", err);\r\nspmi_device_put(sdev);\r\n}\r\n}\r\n}\r\nint spmi_controller_add(struct spmi_controller *ctrl)\r\n{\r\nint ret;\r\nif (WARN_ON(!is_registered))\r\nreturn -EAGAIN;\r\nret = device_add(&ctrl->dev);\r\nif (ret)\r\nreturn ret;\r\nif (IS_ENABLED(CONFIG_OF))\r\nof_spmi_register_devices(ctrl);\r\ndev_dbg(&ctrl->dev, "spmi-%d registered: dev:%p\n",\r\nctrl->nr, &ctrl->dev);\r\nreturn 0;\r\n}\r\nstatic int spmi_ctrl_remove_device(struct device *dev, void *data)\r\n{\r\nstruct spmi_device *spmidev = to_spmi_device(dev);\r\nif (dev->type == &spmi_dev_type)\r\nspmi_device_remove(spmidev);\r\nreturn 0;\r\n}\r\nvoid spmi_controller_remove(struct spmi_controller *ctrl)\r\n{\r\nint dummy;\r\nif (!ctrl)\r\nreturn;\r\ndummy = device_for_each_child(&ctrl->dev, NULL,\r\nspmi_ctrl_remove_device);\r\ndevice_del(&ctrl->dev);\r\n}\r\nint __spmi_driver_register(struct spmi_driver *sdrv, struct module *owner)\r\n{\r\nsdrv->driver.bus = &spmi_bus_type;\r\nsdrv->driver.owner = owner;\r\nreturn driver_register(&sdrv->driver);\r\n}\r\nstatic void __exit spmi_exit(void)\r\n{\r\nbus_unregister(&spmi_bus_type);\r\n}\r\nstatic int __init spmi_init(void)\r\n{\r\nint ret;\r\nret = bus_register(&spmi_bus_type);\r\nif (ret)\r\nreturn ret;\r\nis_registered = true;\r\nreturn 0;\r\n}
