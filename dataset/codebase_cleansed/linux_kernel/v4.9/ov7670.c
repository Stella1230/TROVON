static inline struct ov7670_info *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ov7670_info, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct ov7670_info, hdl)->sd;\r\n}\r\nstatic int ov7670_read_smbus(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char *value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret >= 0) {\r\n*value = (unsigned char)ret;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_write_smbus(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret = i2c_smbus_write_byte_data(client, reg, value);\r\nif (reg == REG_COM7 && (value & COM7_RESET))\r\nmsleep(5);\r\nreturn ret;\r\n}\r\nstatic int ov7670_read_i2c(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char *value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 data = reg;\r\nstruct i2c_msg msg;\r\nint ret;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 1;\r\nmsg.buf = &data;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Error %d on register write\n", ret);\r\nreturn ret;\r\n}\r\nmsg.flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret >= 0) {\r\n*value = data;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_write_i2c(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct i2c_msg msg;\r\nunsigned char data[2] = { reg, value };\r\nint ret;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nmsg.buf = data;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret > 0)\r\nret = 0;\r\nif (reg == REG_COM7 && (value & COM7_RESET))\r\nmsleep(5);\r\nreturn ret;\r\n}\r\nstatic int ov7670_read(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char *value)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nif (info->use_smbus)\r\nreturn ov7670_read_smbus(sd, reg, value);\r\nelse\r\nreturn ov7670_read_i2c(sd, reg, value);\r\n}\r\nstatic int ov7670_write(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char value)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nif (info->use_smbus)\r\nreturn ov7670_write_smbus(sd, reg, value);\r\nelse\r\nreturn ov7670_write_i2c(sd, reg, value);\r\n}\r\nstatic int ov7670_write_array(struct v4l2_subdev *sd, struct regval_list *vals)\r\n{\r\nwhile (vals->reg_num != 0xff || vals->value != 0xff) {\r\nint ret = ov7670_write(sd, vals->reg_num, vals->value);\r\nif (ret < 0)\r\nreturn ret;\r\nvals++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov7670_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nov7670_write(sd, REG_COM7, COM7_RESET);\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int ov7670_init(struct v4l2_subdev *sd, u32 val)\r\n{\r\nreturn ov7670_write_array(sd, ov7670_default_regs);\r\n}\r\nstatic int ov7670_detect(struct v4l2_subdev *sd)\r\n{\r\nunsigned char v;\r\nint ret;\r\nret = ov7670_init(sd, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov7670_read(sd, REG_MIDH, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v != 0x7f)\r\nreturn -ENODEV;\r\nret = ov7670_read(sd, REG_MIDL, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v != 0xa2)\r\nreturn -ENODEV;\r\nret = ov7670_read(sd, REG_PID, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v != 0x76)\r\nreturn -ENODEV;\r\nret = ov7670_read(sd, REG_VER, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v != 0x73)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void ov7675_get_framerate(struct v4l2_subdev *sd,\r\nstruct v4l2_fract *tpf)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nu32 clkrc = info->clkrc;\r\nint pll_factor;\r\nif (info->pll_bypass)\r\npll_factor = 1;\r\nelse\r\npll_factor = PLL_FACTOR;\r\nclkrc++;\r\nif (info->fmt->mbus_code == MEDIA_BUS_FMT_SBGGR8_1X8)\r\nclkrc = (clkrc >> 1);\r\ntpf->numerator = 1;\r\ntpf->denominator = (5 * pll_factor * info->clock_speed) /\r\n(4 * clkrc);\r\n}\r\nstatic int ov7675_set_framerate(struct v4l2_subdev *sd,\r\nstruct v4l2_fract *tpf)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nu32 clkrc;\r\nint pll_factor;\r\nint ret;\r\nif (info->pll_bypass) {\r\npll_factor = 1;\r\nret = ov7670_write(sd, REG_DBLV, DBLV_BYPASS);\r\n} else {\r\npll_factor = PLL_FACTOR;\r\nret = ov7670_write(sd, REG_DBLV, DBLV_X4);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nif (tpf->numerator == 0 || tpf->denominator == 0) {\r\nclkrc = 0;\r\n} else {\r\nclkrc = (5 * pll_factor * info->clock_speed * tpf->numerator) /\r\n(4 * tpf->denominator);\r\nif (info->fmt->mbus_code == MEDIA_BUS_FMT_SBGGR8_1X8)\r\nclkrc = (clkrc << 1);\r\nclkrc--;\r\n}\r\nif (clkrc <= 0)\r\nclkrc = CLK_EXT;\r\nelse if (clkrc > CLK_SCALE)\r\nclkrc = CLK_SCALE;\r\ninfo->clkrc = clkrc;\r\nov7675_get_framerate(sd, tpf);\r\nret = ov7670_write(sd, REG_CLKRC, info->clkrc);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ov7670_write(sd, REG_DBLV, DBLV_X4);\r\n}\r\nstatic void ov7670_get_framerate_legacy(struct v4l2_subdev *sd,\r\nstruct v4l2_fract *tpf)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\ntpf->numerator = 1;\r\ntpf->denominator = info->clock_speed;\r\nif ((info->clkrc & CLK_EXT) == 0 && (info->clkrc & CLK_SCALE) > 1)\r\ntpf->denominator /= (info->clkrc & CLK_SCALE);\r\n}\r\nstatic int ov7670_set_framerate_legacy(struct v4l2_subdev *sd,\r\nstruct v4l2_fract *tpf)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nint div;\r\nif (tpf->numerator == 0 || tpf->denominator == 0)\r\ndiv = 1;\r\nelse\r\ndiv = (tpf->numerator * info->clock_speed) / tpf->denominator;\r\nif (div == 0)\r\ndiv = 1;\r\nelse if (div > CLK_SCALE)\r\ndiv = CLK_SCALE;\r\ninfo->clkrc = (info->clkrc & 0x80) | div;\r\ntpf->numerator = 1;\r\ntpf->denominator = info->clock_speed / div;\r\nreturn ov7670_write(sd, REG_CLKRC, info->clkrc);\r\n}\r\nstatic int ov7670_set_hw(struct v4l2_subdev *sd, int hstart, int hstop,\r\nint vstart, int vstop)\r\n{\r\nint ret;\r\nunsigned char v;\r\nret = ov7670_write(sd, REG_HSTART, (hstart >> 3) & 0xff);\r\nret += ov7670_write(sd, REG_HSTOP, (hstop >> 3) & 0xff);\r\nret += ov7670_read(sd, REG_HREF, &v);\r\nv = (v & 0xc0) | ((hstop & 0x7) << 3) | (hstart & 0x7);\r\nmsleep(10);\r\nret += ov7670_write(sd, REG_HREF, v);\r\nret += ov7670_write(sd, REG_VSTART, (vstart >> 2) & 0xff);\r\nret += ov7670_write(sd, REG_VSTOP, (vstop >> 2) & 0xff);\r\nret += ov7670_read(sd, REG_VREF, &v);\r\nv = (v & 0xf0) | ((vstop & 0x3) << 2) | (vstart & 0x3);\r\nmsleep(10);\r\nret += ov7670_write(sd, REG_VREF, v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad || code->index >= N_OV7670_FMTS)\r\nreturn -EINVAL;\r\ncode->code = ov7670_formats[code->index].mbus_code;\r\nreturn 0;\r\n}\r\nstatic int ov7670_try_fmt_internal(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nstruct ov7670_format_struct **ret_fmt,\r\nstruct ov7670_win_size **ret_wsize)\r\n{\r\nint index, i;\r\nstruct ov7670_win_size *wsize;\r\nstruct ov7670_info *info = to_state(sd);\r\nunsigned int n_win_sizes = info->devtype->n_win_sizes;\r\nunsigned int win_sizes_limit = n_win_sizes;\r\nfor (index = 0; index < N_OV7670_FMTS; index++)\r\nif (ov7670_formats[index].mbus_code == fmt->code)\r\nbreak;\r\nif (index >= N_OV7670_FMTS) {\r\nindex = 0;\r\nfmt->code = ov7670_formats[0].mbus_code;\r\n}\r\nif (ret_fmt != NULL)\r\n*ret_fmt = ov7670_formats + index;\r\nfmt->field = V4L2_FIELD_NONE;\r\nif (info->min_width || info->min_height)\r\nfor (i = 0; i < n_win_sizes; i++) {\r\nwsize = info->devtype->win_sizes + i;\r\nif (wsize->width < info->min_width ||\r\nwsize->height < info->min_height) {\r\nwin_sizes_limit = i;\r\nbreak;\r\n}\r\n}\r\nfor (wsize = info->devtype->win_sizes;\r\nwsize < info->devtype->win_sizes + win_sizes_limit; wsize++)\r\nif (fmt->width >= wsize->width && fmt->height >= wsize->height)\r\nbreak;\r\nif (wsize >= info->devtype->win_sizes + win_sizes_limit)\r\nwsize--;\r\nif (ret_wsize != NULL)\r\n*ret_wsize = wsize;\r\nfmt->width = wsize->width;\r\nfmt->height = wsize->height;\r\nfmt->colorspace = ov7670_formats[index].colorspace;\r\nreturn 0;\r\n}\r\nstatic int ov7670_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct ov7670_format_struct *ovfmt;\r\nstruct ov7670_win_size *wsize;\r\nstruct ov7670_info *info = to_state(sd);\r\nunsigned char com7;\r\nint ret;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nret = ov7670_try_fmt_internal(sd, &format->format, NULL, NULL);\r\nif (ret)\r\nreturn ret;\r\ncfg->try_fmt = format->format;\r\nreturn 0;\r\n}\r\nret = ov7670_try_fmt_internal(sd, &format->format, &ovfmt, &wsize);\r\nif (ret)\r\nreturn ret;\r\ncom7 = ovfmt->regs[0].value;\r\ncom7 |= wsize->com7_bit;\r\nov7670_write(sd, REG_COM7, com7);\r\nov7670_write_array(sd, ovfmt->regs + 1);\r\nov7670_set_hw(sd, wsize->hstart, wsize->hstop, wsize->vstart,\r\nwsize->vstop);\r\nret = 0;\r\nif (wsize->regs)\r\nret = ov7670_write_array(sd, wsize->regs);\r\ninfo->fmt = ovfmt;\r\nif (ret == 0)\r\nret = ov7670_write(sd, REG_CLKRC, info->clkrc);\r\nreturn 0;\r\n}\r\nstatic int ov7670_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nstruct ov7670_info *info = to_state(sd);\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemset(cp, 0, sizeof(struct v4l2_captureparm));\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ninfo->devtype->get_framerate(sd, &cp->timeperframe);\r\nreturn 0;\r\n}\r\nstatic int ov7670_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nstruct v4l2_fract *tpf = &cp->timeperframe;\r\nstruct ov7670_info *info = to_state(sd);\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cp->extendedmode != 0)\r\nreturn -EINVAL;\r\nreturn info->devtype->set_framerate(sd, tpf);\r\n}\r\nstatic int ov7670_enum_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_interval_enum *fie)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nunsigned int n_win_sizes = info->devtype->n_win_sizes;\r\nint i;\r\nif (fie->pad)\r\nreturn -EINVAL;\r\nif (fie->index >= ARRAY_SIZE(ov7670_frame_rates))\r\nreturn -EINVAL;\r\nfor (i = 0; i < n_win_sizes; i++) {\r\nstruct ov7670_win_size *win = &info->devtype->win_sizes[i];\r\nif (info->min_width && win->width < info->min_width)\r\ncontinue;\r\nif (info->min_height && win->height < info->min_height)\r\ncontinue;\r\nif (fie->width == win->width && fie->height == win->height)\r\nbreak;\r\n}\r\nif (i == n_win_sizes)\r\nreturn -EINVAL;\r\nfie->interval.numerator = 1;\r\nfie->interval.denominator = ov7670_frame_rates[fie->index];\r\nreturn 0;\r\n}\r\nstatic int ov7670_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nint i;\r\nint num_valid = -1;\r\n__u32 index = fse->index;\r\nunsigned int n_win_sizes = info->devtype->n_win_sizes;\r\nif (fse->pad)\r\nreturn -EINVAL;\r\nfor (i = 0; i < n_win_sizes; i++) {\r\nstruct ov7670_win_size *win = &info->devtype->win_sizes[i];\r\nif (info->min_width && win->width < info->min_width)\r\ncontinue;\r\nif (info->min_height && win->height < info->min_height)\r\ncontinue;\r\nif (index == ++num_valid) {\r\nfse->min_width = fse->max_width = win->width;\r\nfse->min_height = fse->max_height = win->height;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov7670_store_cmatrix(struct v4l2_subdev *sd,\r\nint matrix[CMATRIX_LEN])\r\n{\r\nint i, ret;\r\nunsigned char signbits = 0;\r\nret = ov7670_read(sd, REG_CMATRIX_SIGN, &signbits);\r\nsignbits &= 0xc0;\r\nfor (i = 0; i < CMATRIX_LEN; i++) {\r\nunsigned char raw;\r\nif (matrix[i] < 0) {\r\nsignbits |= (1 << i);\r\nif (matrix[i] < -255)\r\nraw = 0xff;\r\nelse\r\nraw = (-1 * matrix[i]) & 0xff;\r\n}\r\nelse {\r\nif (matrix[i] > 255)\r\nraw = 0xff;\r\nelse\r\nraw = matrix[i] & 0xff;\r\n}\r\nret += ov7670_write(sd, REG_CMATRIX_BASE + i, raw);\r\n}\r\nret += ov7670_write(sd, REG_CMATRIX_SIGN, signbits);\r\nreturn ret;\r\n}\r\nstatic int ov7670_sine(int theta)\r\n{\r\nint chs = 1;\r\nint sine;\r\nif (theta < 0) {\r\ntheta = -theta;\r\nchs = -1;\r\n}\r\nif (theta <= 90)\r\nsine = ov7670_sin_table[theta/SIN_STEP];\r\nelse {\r\ntheta -= 90;\r\nsine = 1000 - ov7670_sin_table[theta/SIN_STEP];\r\n}\r\nreturn sine*chs;\r\n}\r\nstatic int ov7670_cosine(int theta)\r\n{\r\ntheta = 90 - theta;\r\nif (theta > 180)\r\ntheta -= 360;\r\nelse if (theta < -180)\r\ntheta += 360;\r\nreturn ov7670_sine(theta);\r\n}\r\nstatic void ov7670_calc_cmatrix(struct ov7670_info *info,\r\nint matrix[CMATRIX_LEN], int sat, int hue)\r\n{\r\nint i;\r\nfor (i = 0; i < CMATRIX_LEN; i++)\r\nmatrix[i] = (info->fmt->cmatrix[i] * sat) >> 7;\r\nif (hue != 0) {\r\nint sinth, costh, tmpmatrix[CMATRIX_LEN];\r\nmemcpy(tmpmatrix, matrix, CMATRIX_LEN*sizeof(int));\r\nsinth = ov7670_sine(hue);\r\ncosth = ov7670_cosine(hue);\r\nmatrix[0] = (matrix[3]*sinth + matrix[0]*costh)/1000;\r\nmatrix[1] = (matrix[4]*sinth + matrix[1]*costh)/1000;\r\nmatrix[2] = (matrix[5]*sinth + matrix[2]*costh)/1000;\r\nmatrix[3] = (matrix[3]*costh - matrix[0]*sinth)/1000;\r\nmatrix[4] = (matrix[4]*costh - matrix[1]*sinth)/1000;\r\nmatrix[5] = (matrix[5]*costh - matrix[2]*sinth)/1000;\r\n}\r\n}\r\nstatic int ov7670_s_sat_hue(struct v4l2_subdev *sd, int sat, int hue)\r\n{\r\nstruct ov7670_info *info = to_state(sd);\r\nint matrix[CMATRIX_LEN];\r\nint ret;\r\nov7670_calc_cmatrix(info, matrix, sat, hue);\r\nret = ov7670_store_cmatrix(sd, matrix);\r\nreturn ret;\r\n}\r\nstatic unsigned char ov7670_abs_to_sm(unsigned char v)\r\n{\r\nif (v > 127)\r\nreturn v & 0x7f;\r\nreturn (128 - v) | 0x80;\r\n}\r\nstatic int ov7670_s_brightness(struct v4l2_subdev *sd, int value)\r\n{\r\nunsigned char com8 = 0, v;\r\nint ret;\r\nov7670_read(sd, REG_COM8, &com8);\r\ncom8 &= ~COM8_AEC;\r\nov7670_write(sd, REG_COM8, com8);\r\nv = ov7670_abs_to_sm(value);\r\nret = ov7670_write(sd, REG_BRIGHT, v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_contrast(struct v4l2_subdev *sd, int value)\r\n{\r\nreturn ov7670_write(sd, REG_CONTRAS, (unsigned char) value);\r\n}\r\nstatic int ov7670_s_hflip(struct v4l2_subdev *sd, int value)\r\n{\r\nunsigned char v = 0;\r\nint ret;\r\nret = ov7670_read(sd, REG_MVFP, &v);\r\nif (value)\r\nv |= MVFP_MIRROR;\r\nelse\r\nv &= ~MVFP_MIRROR;\r\nmsleep(10);\r\nret += ov7670_write(sd, REG_MVFP, v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_vflip(struct v4l2_subdev *sd, int value)\r\n{\r\nunsigned char v = 0;\r\nint ret;\r\nret = ov7670_read(sd, REG_MVFP, &v);\r\nif (value)\r\nv |= MVFP_FLIP;\r\nelse\r\nv &= ~MVFP_FLIP;\r\nmsleep(10);\r\nret += ov7670_write(sd, REG_MVFP, v);\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_gain(struct v4l2_subdev *sd, __s32 *value)\r\n{\r\nint ret;\r\nunsigned char gain;\r\nret = ov7670_read(sd, REG_GAIN, &gain);\r\n*value = gain;\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_gain(struct v4l2_subdev *sd, int value)\r\n{\r\nint ret;\r\nunsigned char com8;\r\nret = ov7670_write(sd, REG_GAIN, value & 0xff);\r\nif (ret == 0) {\r\nret = ov7670_read(sd, REG_COM8, &com8);\r\nret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AGC);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_autogain(struct v4l2_subdev *sd, int value)\r\n{\r\nint ret;\r\nunsigned char com8;\r\nret = ov7670_read(sd, REG_COM8, &com8);\r\nif (ret == 0) {\r\nif (value)\r\ncom8 |= COM8_AGC;\r\nelse\r\ncom8 &= ~COM8_AGC;\r\nret = ov7670_write(sd, REG_COM8, com8);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_exp(struct v4l2_subdev *sd, int value)\r\n{\r\nint ret;\r\nunsigned char com1, com8, aech, aechh;\r\nret = ov7670_read(sd, REG_COM1, &com1) +\r\nov7670_read(sd, REG_COM8, &com8) +\r\nov7670_read(sd, REG_AECHH, &aechh);\r\nif (ret)\r\nreturn ret;\r\ncom1 = (com1 & 0xfc) | (value & 0x03);\r\naech = (value >> 2) & 0xff;\r\naechh = (aechh & 0xc0) | ((value >> 10) & 0x3f);\r\nret = ov7670_write(sd, REG_COM1, com1) +\r\nov7670_write(sd, REG_AECH, aech) +\r\nov7670_write(sd, REG_AECHH, aechh);\r\nif (ret == 0)\r\nret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AEC);\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_autoexp(struct v4l2_subdev *sd,\r\nenum v4l2_exposure_auto_type value)\r\n{\r\nint ret;\r\nunsigned char com8;\r\nret = ov7670_read(sd, REG_COM8, &com8);\r\nif (ret == 0) {\r\nif (value == V4L2_EXPOSURE_AUTO)\r\ncom8 |= COM8_AEC;\r\nelse\r\ncom8 &= ~COM8_AEC;\r\nret = ov7670_write(sd, REG_COM8, com8);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov7670_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct ov7670_info *info = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nreturn ov7670_g_gain(sd, &info->gain->val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov7670_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct ov7670_info *info = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn ov7670_s_brightness(sd, ctrl->val);\r\ncase V4L2_CID_CONTRAST:\r\nreturn ov7670_s_contrast(sd, ctrl->val);\r\ncase V4L2_CID_SATURATION:\r\nreturn ov7670_s_sat_hue(sd,\r\ninfo->saturation->val, info->hue->val);\r\ncase V4L2_CID_VFLIP:\r\nreturn ov7670_s_vflip(sd, ctrl->val);\r\ncase V4L2_CID_HFLIP:\r\nreturn ov7670_s_hflip(sd, ctrl->val);\r\ncase V4L2_CID_AUTOGAIN:\r\nif (!ctrl->val) {\r\nreturn ov7670_s_gain(sd, info->gain->val);\r\n}\r\nreturn ov7670_s_autogain(sd, ctrl->val);\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nif (ctrl->val == V4L2_EXPOSURE_MANUAL) {\r\nreturn ov7670_s_exp(sd, info->exposure->val);\r\n}\r\nreturn ov7670_s_autoexp(sd, ctrl->val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov7670_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nunsigned char val = 0;\r\nint ret;\r\nret = ov7670_read(sd, reg->reg & 0xff, &val);\r\nreg->val = val;\r\nreg->size = 1;\r\nreturn ret;\r\n}\r\nstatic int ov7670_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\r\n{\r\nov7670_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int ov7670_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct v4l2_fract tpf;\r\nstruct v4l2_subdev *sd;\r\nstruct ov7670_info *info;\r\nint ret;\r\ninfo = devm_kzalloc(&client->dev, sizeof(*info), GFP_KERNEL);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\nsd = &info->sd;\r\nv4l2_i2c_subdev_init(sd, client, &ov7670_ops);\r\ninfo->clock_speed = 30;\r\nif (client->dev.platform_data) {\r\nstruct ov7670_config *config = client->dev.platform_data;\r\ninfo->min_width = config->min_width;\r\ninfo->min_height = config->min_height;\r\ninfo->use_smbus = config->use_smbus;\r\nif (config->clock_speed)\r\ninfo->clock_speed = config->clock_speed;\r\nif (config->pll_bypass && id->driver_data != MODEL_OV7670)\r\ninfo->pll_bypass = true;\r\nif (config->pclk_hb_disable)\r\ninfo->pclk_hb_disable = true;\r\n}\r\nret = ov7670_detect(sd);\r\nif (ret) {\r\nv4l_dbg(1, debug, client,\r\n"chip found @ 0x%x (%s) is not an ov7670 chip.\n",\r\nclient->addr << 1, client->adapter->name);\r\nreturn ret;\r\n}\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\ninfo->devtype = &ov7670_devdata[id->driver_data];\r\ninfo->fmt = &ov7670_formats[0];\r\ninfo->clkrc = 0;\r\ntpf.numerator = 1;\r\ntpf.denominator = 30;\r\ninfo->devtype->set_framerate(sd, &tpf);\r\nif (info->pclk_hb_disable)\r\nov7670_write(sd, REG_COM10, COM10_PCLK_HB);\r\nv4l2_ctrl_handler_init(&info->hdl, 10);\r\nv4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\ninfo->saturation = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 256, 1, 128);\r\ninfo->hue = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_HUE, -180, 180, 5, 0);\r\ninfo->gain = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 128);\r\ninfo->auto_gain = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\ninfo->exposure = v4l2_ctrl_new_std(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 65535, 1, 500);\r\ninfo->auto_exposure = v4l2_ctrl_new_std_menu(&info->hdl, &ov7670_ctrl_ops,\r\nV4L2_CID_EXPOSURE_AUTO, V4L2_EXPOSURE_MANUAL, 0,\r\nV4L2_EXPOSURE_AUTO);\r\nsd->ctrl_handler = &info->hdl;\r\nif (info->hdl.error) {\r\nint err = info->hdl.error;\r\nv4l2_ctrl_handler_free(&info->hdl);\r\nreturn err;\r\n}\r\nv4l2_ctrl_auto_cluster(2, &info->auto_gain, 0, true);\r\nv4l2_ctrl_auto_cluster(2, &info->auto_exposure,\r\nV4L2_EXPOSURE_MANUAL, false);\r\nv4l2_ctrl_cluster(2, &info->saturation);\r\nv4l2_ctrl_handler_setup(&info->hdl);\r\nreturn 0;\r\n}\r\nstatic int ov7670_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ov7670_info *info = to_state(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&info->hdl);\r\nreturn 0;\r\n}
