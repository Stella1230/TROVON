static inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\r\n{\r\nreturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\r\n}\r\nstatic void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)\r\n{\r\nconst char **perms;\r\nint i, perm;\r\nif (av == 0) {\r\naudit_log_format(ab, " null");\r\nreturn;\r\n}\r\nBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\r\nperms = secclass_map[tclass-1].perms;\r\naudit_log_format(ab, " {");\r\ni = 0;\r\nperm = 1;\r\nwhile (i < (sizeof(av) * 8)) {\r\nif ((perm & av) && perms[i]) {\r\naudit_log_format(ab, " %s", perms[i]);\r\nav &= ~perm;\r\n}\r\ni++;\r\nperm <<= 1;\r\n}\r\nif (av)\r\naudit_log_format(ab, " 0x%x", av);\r\naudit_log_format(ab, " }");\r\n}\r\nstatic void avc_dump_query(struct audit_buffer *ab, u32 ssid, u32 tsid, u16 tclass)\r\n{\r\nint rc;\r\nchar *scontext;\r\nu32 scontext_len;\r\nrc = security_sid_to_context(ssid, &scontext, &scontext_len);\r\nif (rc)\r\naudit_log_format(ab, "ssid=%d", ssid);\r\nelse {\r\naudit_log_format(ab, "scontext=%s", scontext);\r\nkfree(scontext);\r\n}\r\nrc = security_sid_to_context(tsid, &scontext, &scontext_len);\r\nif (rc)\r\naudit_log_format(ab, " tsid=%d", tsid);\r\nelse {\r\naudit_log_format(ab, " tcontext=%s", scontext);\r\nkfree(scontext);\r\n}\r\nBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\r\naudit_log_format(ab, " tclass=%s", secclass_map[tclass-1].name);\r\n}\r\nvoid __init avc_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\r\nINIT_HLIST_HEAD(&avc_cache.slots[i]);\r\nspin_lock_init(&avc_cache.slots_lock[i]);\r\n}\r\natomic_set(&avc_cache.active_nodes, 0);\r\natomic_set(&avc_cache.lru_hint, 0);\r\navc_node_cachep = kmem_cache_create("avc_node", sizeof(struct avc_node),\r\n0, SLAB_PANIC, NULL);\r\navc_xperms_cachep = kmem_cache_create("avc_xperms_node",\r\nsizeof(struct avc_xperms_node),\r\n0, SLAB_PANIC, NULL);\r\navc_xperms_decision_cachep = kmem_cache_create(\r\n"avc_xperms_decision_node",\r\nsizeof(struct avc_xperms_decision_node),\r\n0, SLAB_PANIC, NULL);\r\navc_xperms_data_cachep = kmem_cache_create("avc_xperms_data",\r\nsizeof(struct extended_perms_data),\r\n0, SLAB_PANIC, NULL);\r\naudit_log(current->audit_context, GFP_KERNEL, AUDIT_KERNEL, "AVC INITIALIZED\n");\r\n}\r\nint avc_get_hash_stats(char *page)\r\n{\r\nint i, chain_len, max_chain_len, slots_used;\r\nstruct avc_node *node;\r\nstruct hlist_head *head;\r\nrcu_read_lock();\r\nslots_used = 0;\r\nmax_chain_len = 0;\r\nfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\r\nhead = &avc_cache.slots[i];\r\nif (!hlist_empty(head)) {\r\nslots_used++;\r\nchain_len = 0;\r\nhlist_for_each_entry_rcu(node, head, list)\r\nchain_len++;\r\nif (chain_len > max_chain_len)\r\nmax_chain_len = chain_len;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn scnprintf(page, PAGE_SIZE, "entries: %d\nbuckets used: %d/%d\n"\r\n"longest chain: %d\n",\r\natomic_read(&avc_cache.active_nodes),\r\nslots_used, AVC_CACHE_SLOTS, max_chain_len);\r\n}\r\nstatic struct extended_perms_decision *avc_xperms_decision_lookup(u8 driver,\r\nstruct avc_xperms_node *xp_node)\r\n{\r\nstruct avc_xperms_decision_node *xpd_node;\r\nlist_for_each_entry(xpd_node, &xp_node->xpd_head, xpd_list) {\r\nif (xpd_node->xpd.driver == driver)\r\nreturn &xpd_node->xpd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline unsigned int\r\navc_xperms_has_perm(struct extended_perms_decision *xpd,\r\nu8 perm, u8 which)\r\n{\r\nunsigned int rc = 0;\r\nif ((which == XPERMS_ALLOWED) &&\r\n(xpd->used & XPERMS_ALLOWED))\r\nrc = security_xperm_test(xpd->allowed->p, perm);\r\nelse if ((which == XPERMS_AUDITALLOW) &&\r\n(xpd->used & XPERMS_AUDITALLOW))\r\nrc = security_xperm_test(xpd->auditallow->p, perm);\r\nelse if ((which == XPERMS_DONTAUDIT) &&\r\n(xpd->used & XPERMS_DONTAUDIT))\r\nrc = security_xperm_test(xpd->dontaudit->p, perm);\r\nreturn rc;\r\n}\r\nstatic void avc_xperms_allow_perm(struct avc_xperms_node *xp_node,\r\nu8 driver, u8 perm)\r\n{\r\nstruct extended_perms_decision *xpd;\r\nsecurity_xperm_set(xp_node->xp.drivers.p, driver);\r\nxpd = avc_xperms_decision_lookup(driver, xp_node);\r\nif (xpd && xpd->allowed)\r\nsecurity_xperm_set(xpd->allowed->p, perm);\r\n}\r\nstatic void avc_xperms_decision_free(struct avc_xperms_decision_node *xpd_node)\r\n{\r\nstruct extended_perms_decision *xpd;\r\nxpd = &xpd_node->xpd;\r\nif (xpd->allowed)\r\nkmem_cache_free(avc_xperms_data_cachep, xpd->allowed);\r\nif (xpd->auditallow)\r\nkmem_cache_free(avc_xperms_data_cachep, xpd->auditallow);\r\nif (xpd->dontaudit)\r\nkmem_cache_free(avc_xperms_data_cachep, xpd->dontaudit);\r\nkmem_cache_free(avc_xperms_decision_cachep, xpd_node);\r\n}\r\nstatic void avc_xperms_free(struct avc_xperms_node *xp_node)\r\n{\r\nstruct avc_xperms_decision_node *xpd_node, *tmp;\r\nif (!xp_node)\r\nreturn;\r\nlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\r\nlist_del(&xpd_node->xpd_list);\r\navc_xperms_decision_free(xpd_node);\r\n}\r\nkmem_cache_free(avc_xperms_cachep, xp_node);\r\n}\r\nstatic void avc_copy_xperms_decision(struct extended_perms_decision *dest,\r\nstruct extended_perms_decision *src)\r\n{\r\ndest->driver = src->driver;\r\ndest->used = src->used;\r\nif (dest->used & XPERMS_ALLOWED)\r\nmemcpy(dest->allowed->p, src->allowed->p,\r\nsizeof(src->allowed->p));\r\nif (dest->used & XPERMS_AUDITALLOW)\r\nmemcpy(dest->auditallow->p, src->auditallow->p,\r\nsizeof(src->auditallow->p));\r\nif (dest->used & XPERMS_DONTAUDIT)\r\nmemcpy(dest->dontaudit->p, src->dontaudit->p,\r\nsizeof(src->dontaudit->p));\r\n}\r\nstatic inline void avc_quick_copy_xperms_decision(u8 perm,\r\nstruct extended_perms_decision *dest,\r\nstruct extended_perms_decision *src)\r\n{\r\nu8 i = perm >> 5;\r\ndest->used = src->used;\r\nif (dest->used & XPERMS_ALLOWED)\r\ndest->allowed->p[i] = src->allowed->p[i];\r\nif (dest->used & XPERMS_AUDITALLOW)\r\ndest->auditallow->p[i] = src->auditallow->p[i];\r\nif (dest->used & XPERMS_DONTAUDIT)\r\ndest->dontaudit->p[i] = src->dontaudit->p[i];\r\n}\r\nstatic struct avc_xperms_decision_node\r\n*avc_xperms_decision_alloc(u8 which)\r\n{\r\nstruct avc_xperms_decision_node *xpd_node;\r\nstruct extended_perms_decision *xpd;\r\nxpd_node = kmem_cache_zalloc(avc_xperms_decision_cachep,\r\nGFP_ATOMIC | __GFP_NOMEMALLOC);\r\nif (!xpd_node)\r\nreturn NULL;\r\nxpd = &xpd_node->xpd;\r\nif (which & XPERMS_ALLOWED) {\r\nxpd->allowed = kmem_cache_zalloc(avc_xperms_data_cachep,\r\nGFP_ATOMIC | __GFP_NOMEMALLOC);\r\nif (!xpd->allowed)\r\ngoto error;\r\n}\r\nif (which & XPERMS_AUDITALLOW) {\r\nxpd->auditallow = kmem_cache_zalloc(avc_xperms_data_cachep,\r\nGFP_ATOMIC | __GFP_NOMEMALLOC);\r\nif (!xpd->auditallow)\r\ngoto error;\r\n}\r\nif (which & XPERMS_DONTAUDIT) {\r\nxpd->dontaudit = kmem_cache_zalloc(avc_xperms_data_cachep,\r\nGFP_ATOMIC | __GFP_NOMEMALLOC);\r\nif (!xpd->dontaudit)\r\ngoto error;\r\n}\r\nreturn xpd_node;\r\nerror:\r\navc_xperms_decision_free(xpd_node);\r\nreturn NULL;\r\n}\r\nstatic int avc_add_xperms_decision(struct avc_node *node,\r\nstruct extended_perms_decision *src)\r\n{\r\nstruct avc_xperms_decision_node *dest_xpd;\r\nnode->ae.xp_node->xp.len++;\r\ndest_xpd = avc_xperms_decision_alloc(src->used);\r\nif (!dest_xpd)\r\nreturn -ENOMEM;\r\navc_copy_xperms_decision(&dest_xpd->xpd, src);\r\nlist_add(&dest_xpd->xpd_list, &node->ae.xp_node->xpd_head);\r\nreturn 0;\r\n}\r\nstatic struct avc_xperms_node *avc_xperms_alloc(void)\r\n{\r\nstruct avc_xperms_node *xp_node;\r\nxp_node = kmem_cache_zalloc(avc_xperms_cachep,\r\nGFP_ATOMIC|__GFP_NOMEMALLOC);\r\nif (!xp_node)\r\nreturn xp_node;\r\nINIT_LIST_HEAD(&xp_node->xpd_head);\r\nreturn xp_node;\r\n}\r\nstatic int avc_xperms_populate(struct avc_node *node,\r\nstruct avc_xperms_node *src)\r\n{\r\nstruct avc_xperms_node *dest;\r\nstruct avc_xperms_decision_node *dest_xpd;\r\nstruct avc_xperms_decision_node *src_xpd;\r\nif (src->xp.len == 0)\r\nreturn 0;\r\ndest = avc_xperms_alloc();\r\nif (!dest)\r\nreturn -ENOMEM;\r\nmemcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p));\r\ndest->xp.len = src->xp.len;\r\nlist_for_each_entry(src_xpd, &src->xpd_head, xpd_list) {\r\ndest_xpd = avc_xperms_decision_alloc(src_xpd->xpd.used);\r\nif (!dest_xpd)\r\ngoto error;\r\navc_copy_xperms_decision(&dest_xpd->xpd, &src_xpd->xpd);\r\nlist_add(&dest_xpd->xpd_list, &dest->xpd_head);\r\n}\r\nnode->ae.xp_node = dest;\r\nreturn 0;\r\nerror:\r\navc_xperms_free(dest);\r\nreturn -ENOMEM;\r\n}\r\nstatic inline u32 avc_xperms_audit_required(u32 requested,\r\nstruct av_decision *avd,\r\nstruct extended_perms_decision *xpd,\r\nu8 perm,\r\nint result,\r\nu32 *deniedp)\r\n{\r\nu32 denied, audited;\r\ndenied = requested & ~avd->allowed;\r\nif (unlikely(denied)) {\r\naudited = denied & avd->auditdeny;\r\nif (audited && xpd) {\r\nif (avc_xperms_has_perm(xpd, perm, XPERMS_DONTAUDIT))\r\naudited &= ~requested;\r\n}\r\n} else if (result) {\r\naudited = denied = requested;\r\n} else {\r\naudited = requested & avd->auditallow;\r\nif (audited && xpd) {\r\nif (!avc_xperms_has_perm(xpd, perm, XPERMS_AUDITALLOW))\r\naudited &= ~requested;\r\n}\r\n}\r\n*deniedp = denied;\r\nreturn audited;\r\n}\r\nstatic inline int avc_xperms_audit(u32 ssid, u32 tsid, u16 tclass,\r\nu32 requested, struct av_decision *avd,\r\nstruct extended_perms_decision *xpd,\r\nu8 perm, int result,\r\nstruct common_audit_data *ad)\r\n{\r\nu32 audited, denied;\r\naudited = avc_xperms_audit_required(\r\nrequested, avd, xpd, perm, result, &denied);\r\nif (likely(!audited))\r\nreturn 0;\r\nreturn slow_avc_audit(ssid, tsid, tclass, requested,\r\naudited, denied, result, ad, 0);\r\n}\r\nstatic void avc_node_free(struct rcu_head *rhead)\r\n{\r\nstruct avc_node *node = container_of(rhead, struct avc_node, rhead);\r\navc_xperms_free(node->ae.xp_node);\r\nkmem_cache_free(avc_node_cachep, node);\r\navc_cache_stats_incr(frees);\r\n}\r\nstatic void avc_node_delete(struct avc_node *node)\r\n{\r\nhlist_del_rcu(&node->list);\r\ncall_rcu(&node->rhead, avc_node_free);\r\natomic_dec(&avc_cache.active_nodes);\r\n}\r\nstatic void avc_node_kill(struct avc_node *node)\r\n{\r\navc_xperms_free(node->ae.xp_node);\r\nkmem_cache_free(avc_node_cachep, node);\r\navc_cache_stats_incr(frees);\r\natomic_dec(&avc_cache.active_nodes);\r\n}\r\nstatic void avc_node_replace(struct avc_node *new, struct avc_node *old)\r\n{\r\nhlist_replace_rcu(&old->list, &new->list);\r\ncall_rcu(&old->rhead, avc_node_free);\r\natomic_dec(&avc_cache.active_nodes);\r\n}\r\nstatic inline int avc_reclaim_node(void)\r\n{\r\nstruct avc_node *node;\r\nint hvalue, try, ecx;\r\nunsigned long flags;\r\nstruct hlist_head *head;\r\nspinlock_t *lock;\r\nfor (try = 0, ecx = 0; try < AVC_CACHE_SLOTS; try++) {\r\nhvalue = atomic_inc_return(&avc_cache.lru_hint) & (AVC_CACHE_SLOTS - 1);\r\nhead = &avc_cache.slots[hvalue];\r\nlock = &avc_cache.slots_lock[hvalue];\r\nif (!spin_trylock_irqsave(lock, flags))\r\ncontinue;\r\nrcu_read_lock();\r\nhlist_for_each_entry(node, head, list) {\r\navc_node_delete(node);\r\navc_cache_stats_incr(reclaims);\r\necx++;\r\nif (ecx >= AVC_CACHE_RECLAIM) {\r\nrcu_read_unlock();\r\nspin_unlock_irqrestore(lock, flags);\r\ngoto out;\r\n}\r\n}\r\nrcu_read_unlock();\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nout:\r\nreturn ecx;\r\n}\r\nstatic struct avc_node *avc_alloc_node(void)\r\n{\r\nstruct avc_node *node;\r\nnode = kmem_cache_zalloc(avc_node_cachep, GFP_ATOMIC|__GFP_NOMEMALLOC);\r\nif (!node)\r\ngoto out;\r\nINIT_HLIST_NODE(&node->list);\r\navc_cache_stats_incr(allocations);\r\nif (atomic_inc_return(&avc_cache.active_nodes) > avc_cache_threshold)\r\navc_reclaim_node();\r\nout:\r\nreturn node;\r\n}\r\nstatic void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\r\n{\r\nnode->ae.ssid = ssid;\r\nnode->ae.tsid = tsid;\r\nnode->ae.tclass = tclass;\r\nmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\r\n}\r\nstatic inline struct avc_node *avc_search_node(u32 ssid, u32 tsid, u16 tclass)\r\n{\r\nstruct avc_node *node, *ret = NULL;\r\nint hvalue;\r\nstruct hlist_head *head;\r\nhvalue = avc_hash(ssid, tsid, tclass);\r\nhead = &avc_cache.slots[hvalue];\r\nhlist_for_each_entry_rcu(node, head, list) {\r\nif (ssid == node->ae.ssid &&\r\ntclass == node->ae.tclass &&\r\ntsid == node->ae.tsid) {\r\nret = node;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\r\n{\r\nstruct avc_node *node;\r\navc_cache_stats_incr(lookups);\r\nnode = avc_search_node(ssid, tsid, tclass);\r\nif (node)\r\nreturn node;\r\navc_cache_stats_incr(misses);\r\nreturn NULL;\r\n}\r\nstatic int avc_latest_notif_update(int seqno, int is_insert)\r\n{\r\nint ret = 0;\r\nstatic DEFINE_SPINLOCK(notif_lock);\r\nunsigned long flag;\r\nspin_lock_irqsave(&notif_lock, flag);\r\nif (is_insert) {\r\nif (seqno < avc_cache.latest_notif) {\r\nprintk(KERN_WARNING "SELinux: avc: seqno %d < latest_notif %d\n",\r\nseqno, avc_cache.latest_notif);\r\nret = -EAGAIN;\r\n}\r\n} else {\r\nif (seqno > avc_cache.latest_notif)\r\navc_cache.latest_notif = seqno;\r\n}\r\nspin_unlock_irqrestore(&notif_lock, flag);\r\nreturn ret;\r\n}\r\nstatic struct avc_node *avc_insert(u32 ssid, u32 tsid, u16 tclass,\r\nstruct av_decision *avd,\r\nstruct avc_xperms_node *xp_node)\r\n{\r\nstruct avc_node *pos, *node = NULL;\r\nint hvalue;\r\nunsigned long flag;\r\nif (avc_latest_notif_update(avd->seqno, 1))\r\ngoto out;\r\nnode = avc_alloc_node();\r\nif (node) {\r\nstruct hlist_head *head;\r\nspinlock_t *lock;\r\nint rc = 0;\r\nhvalue = avc_hash(ssid, tsid, tclass);\r\navc_node_populate(node, ssid, tsid, tclass, avd);\r\nrc = avc_xperms_populate(node, xp_node);\r\nif (rc) {\r\nkmem_cache_free(avc_node_cachep, node);\r\nreturn NULL;\r\n}\r\nhead = &avc_cache.slots[hvalue];\r\nlock = &avc_cache.slots_lock[hvalue];\r\nspin_lock_irqsave(lock, flag);\r\nhlist_for_each_entry(pos, head, list) {\r\nif (pos->ae.ssid == ssid &&\r\npos->ae.tsid == tsid &&\r\npos->ae.tclass == tclass) {\r\navc_node_replace(node, pos);\r\ngoto found;\r\n}\r\n}\r\nhlist_add_head_rcu(&node->list, head);\r\nfound:\r\nspin_unlock_irqrestore(lock, flag);\r\n}\r\nout:\r\nreturn node;\r\n}\r\nstatic void avc_audit_pre_callback(struct audit_buffer *ab, void *a)\r\n{\r\nstruct common_audit_data *ad = a;\r\naudit_log_format(ab, "avc: %s ",\r\nad->selinux_audit_data->denied ? "denied" : "granted");\r\navc_dump_av(ab, ad->selinux_audit_data->tclass,\r\nad->selinux_audit_data->audited);\r\naudit_log_format(ab, " for ");\r\n}\r\nstatic void avc_audit_post_callback(struct audit_buffer *ab, void *a)\r\n{\r\nstruct common_audit_data *ad = a;\r\naudit_log_format(ab, " ");\r\navc_dump_query(ab, ad->selinux_audit_data->ssid,\r\nad->selinux_audit_data->tsid,\r\nad->selinux_audit_data->tclass);\r\nif (ad->selinux_audit_data->denied) {\r\naudit_log_format(ab, " permissive=%u",\r\nad->selinux_audit_data->result ? 0 : 1);\r\n}\r\n}\r\nnoinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\r\nu32 requested, u32 audited, u32 denied, int result,\r\nstruct common_audit_data *a,\r\nunsigned flags)\r\n{\r\nstruct common_audit_data stack_data;\r\nstruct selinux_audit_data sad;\r\nif (!a) {\r\na = &stack_data;\r\na->type = LSM_AUDIT_DATA_NONE;\r\n}\r\nif ((a->type == LSM_AUDIT_DATA_INODE) &&\r\n(flags & MAY_NOT_BLOCK))\r\nreturn -ECHILD;\r\nsad.tclass = tclass;\r\nsad.requested = requested;\r\nsad.ssid = ssid;\r\nsad.tsid = tsid;\r\nsad.audited = audited;\r\nsad.denied = denied;\r\nsad.result = result;\r\na->selinux_audit_data = &sad;\r\ncommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\r\nreturn 0;\r\n}\r\nint __init avc_add_callback(int (*callback)(u32 event), u32 events)\r\n{\r\nstruct avc_callback_node *c;\r\nint rc = 0;\r\nc = kmalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nc->callback = callback;\r\nc->events = events;\r\nc->next = avc_callbacks;\r\navc_callbacks = c;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int avc_update_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,\r\nu32 tsid, u16 tclass, u32 seqno,\r\nstruct extended_perms_decision *xpd,\r\nu32 flags)\r\n{\r\nint hvalue, rc = 0;\r\nunsigned long flag;\r\nstruct avc_node *pos, *node, *orig = NULL;\r\nstruct hlist_head *head;\r\nspinlock_t *lock;\r\nnode = avc_alloc_node();\r\nif (!node) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nhvalue = avc_hash(ssid, tsid, tclass);\r\nhead = &avc_cache.slots[hvalue];\r\nlock = &avc_cache.slots_lock[hvalue];\r\nspin_lock_irqsave(lock, flag);\r\nhlist_for_each_entry(pos, head, list) {\r\nif (ssid == pos->ae.ssid &&\r\ntsid == pos->ae.tsid &&\r\ntclass == pos->ae.tclass &&\r\nseqno == pos->ae.avd.seqno){\r\norig = pos;\r\nbreak;\r\n}\r\n}\r\nif (!orig) {\r\nrc = -ENOENT;\r\navc_node_kill(node);\r\ngoto out_unlock;\r\n}\r\navc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\r\nif (orig->ae.xp_node) {\r\nrc = avc_xperms_populate(node, orig->ae.xp_node);\r\nif (rc) {\r\nkmem_cache_free(avc_node_cachep, node);\r\ngoto out_unlock;\r\n}\r\n}\r\nswitch (event) {\r\ncase AVC_CALLBACK_GRANT:\r\nnode->ae.avd.allowed |= perms;\r\nif (node->ae.xp_node && (flags & AVC_EXTENDED_PERMS))\r\navc_xperms_allow_perm(node->ae.xp_node, driver, xperm);\r\nbreak;\r\ncase AVC_CALLBACK_TRY_REVOKE:\r\ncase AVC_CALLBACK_REVOKE:\r\nnode->ae.avd.allowed &= ~perms;\r\nbreak;\r\ncase AVC_CALLBACK_AUDITALLOW_ENABLE:\r\nnode->ae.avd.auditallow |= perms;\r\nbreak;\r\ncase AVC_CALLBACK_AUDITALLOW_DISABLE:\r\nnode->ae.avd.auditallow &= ~perms;\r\nbreak;\r\ncase AVC_CALLBACK_AUDITDENY_ENABLE:\r\nnode->ae.avd.auditdeny |= perms;\r\nbreak;\r\ncase AVC_CALLBACK_AUDITDENY_DISABLE:\r\nnode->ae.avd.auditdeny &= ~perms;\r\nbreak;\r\ncase AVC_CALLBACK_ADD_XPERMS:\r\navc_add_xperms_decision(node, xpd);\r\nbreak;\r\n}\r\navc_node_replace(node, orig);\r\nout_unlock:\r\nspin_unlock_irqrestore(lock, flag);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void avc_flush(void)\r\n{\r\nstruct hlist_head *head;\r\nstruct avc_node *node;\r\nspinlock_t *lock;\r\nunsigned long flag;\r\nint i;\r\nfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\r\nhead = &avc_cache.slots[i];\r\nlock = &avc_cache.slots_lock[i];\r\nspin_lock_irqsave(lock, flag);\r\nrcu_read_lock();\r\nhlist_for_each_entry(node, head, list)\r\navc_node_delete(node);\r\nrcu_read_unlock();\r\nspin_unlock_irqrestore(lock, flag);\r\n}\r\n}\r\nint avc_ss_reset(u32 seqno)\r\n{\r\nstruct avc_callback_node *c;\r\nint rc = 0, tmprc;\r\navc_flush();\r\nfor (c = avc_callbacks; c; c = c->next) {\r\nif (c->events & AVC_CALLBACK_RESET) {\r\ntmprc = c->callback(AVC_CALLBACK_RESET);\r\nif (!rc)\r\nrc = tmprc;\r\n}\r\n}\r\navc_latest_notif_update(seqno, 0);\r\nreturn rc;\r\n}\r\nstatic noinline int avc_denied(u32 ssid, u32 tsid,\r\nu16 tclass, u32 requested,\r\nu8 driver, u8 xperm, unsigned flags,\r\nstruct av_decision *avd)\r\n{\r\nif (flags & AVC_STRICT)\r\nreturn -EACCES;\r\nif (selinux_enforcing && !(avd->flags & AVD_FLAGS_PERMISSIVE))\r\nreturn -EACCES;\r\navc_update_node(AVC_CALLBACK_GRANT, requested, driver, xperm, ssid,\r\ntsid, tclass, avd->seqno, NULL, flags);\r\nreturn 0;\r\n}\r\nint avc_has_extended_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,\r\nu8 driver, u8 xperm, struct common_audit_data *ad)\r\n{\r\nstruct avc_node *node;\r\nstruct av_decision avd;\r\nu32 denied;\r\nstruct extended_perms_decision local_xpd;\r\nstruct extended_perms_decision *xpd = NULL;\r\nstruct extended_perms_data allowed;\r\nstruct extended_perms_data auditallow;\r\nstruct extended_perms_data dontaudit;\r\nstruct avc_xperms_node local_xp_node;\r\nstruct avc_xperms_node *xp_node;\r\nint rc = 0, rc2;\r\nxp_node = &local_xp_node;\r\nBUG_ON(!requested);\r\nrcu_read_lock();\r\nnode = avc_lookup(ssid, tsid, tclass);\r\nif (unlikely(!node)) {\r\nnode = avc_compute_av(ssid, tsid, tclass, &avd, xp_node);\r\n} else {\r\nmemcpy(&avd, &node->ae.avd, sizeof(avd));\r\nxp_node = node->ae.xp_node;\r\n}\r\nif (!xp_node || !xp_node->xp.len)\r\ngoto decision;\r\nlocal_xpd.allowed = &allowed;\r\nlocal_xpd.auditallow = &auditallow;\r\nlocal_xpd.dontaudit = &dontaudit;\r\nxpd = avc_xperms_decision_lookup(driver, xp_node);\r\nif (unlikely(!xpd)) {\r\nif (!security_xperm_test(xp_node->xp.drivers.p, driver)) {\r\navd.allowed &= ~requested;\r\ngoto decision;\r\n}\r\nrcu_read_unlock();\r\nsecurity_compute_xperms_decision(ssid, tsid, tclass, driver,\r\n&local_xpd);\r\nrcu_read_lock();\r\navc_update_node(AVC_CALLBACK_ADD_XPERMS, requested, driver, xperm,\r\nssid, tsid, tclass, avd.seqno, &local_xpd, 0);\r\n} else {\r\navc_quick_copy_xperms_decision(xperm, &local_xpd, xpd);\r\n}\r\nxpd = &local_xpd;\r\nif (!avc_xperms_has_perm(xpd, xperm, XPERMS_ALLOWED))\r\navd.allowed &= ~requested;\r\ndecision:\r\ndenied = requested & ~(avd.allowed);\r\nif (unlikely(denied))\r\nrc = avc_denied(ssid, tsid, tclass, requested, driver, xperm,\r\nAVC_EXTENDED_PERMS, &avd);\r\nrcu_read_unlock();\r\nrc2 = avc_xperms_audit(ssid, tsid, tclass, requested,\r\n&avd, xpd, xperm, rc, ad);\r\nif (rc2)\r\nreturn rc2;\r\nreturn rc;\r\n}\r\ninline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\r\nu16 tclass, u32 requested,\r\nunsigned flags,\r\nstruct av_decision *avd)\r\n{\r\nstruct avc_node *node;\r\nstruct avc_xperms_node xp_node;\r\nint rc = 0;\r\nu32 denied;\r\nBUG_ON(!requested);\r\nrcu_read_lock();\r\nnode = avc_lookup(ssid, tsid, tclass);\r\nif (unlikely(!node))\r\nnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\r\nelse\r\nmemcpy(avd, &node->ae.avd, sizeof(*avd));\r\ndenied = requested & ~(avd->allowed);\r\nif (unlikely(denied))\r\nrc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\r\nu32 requested, struct common_audit_data *auditdata)\r\n{\r\nstruct av_decision avd;\r\nint rc, rc2;\r\nrc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\r\nrc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\r\nif (rc2)\r\nreturn rc2;\r\nreturn rc;\r\n}\r\nint avc_has_perm_flags(u32 ssid, u32 tsid, u16 tclass,\r\nu32 requested, struct common_audit_data *auditdata,\r\nint flags)\r\n{\r\nstruct av_decision avd;\r\nint rc, rc2;\r\nrc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\r\nrc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc,\r\nauditdata, flags);\r\nif (rc2)\r\nreturn rc2;\r\nreturn rc;\r\n}\r\nu32 avc_policy_seqno(void)\r\n{\r\nreturn avc_cache.latest_notif;\r\n}\r\nvoid avc_disable(void)\r\n{\r\nif (avc_node_cachep) {\r\navc_flush();\r\n}\r\n}
