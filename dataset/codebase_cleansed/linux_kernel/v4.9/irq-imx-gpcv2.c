u32 imx_gpcv2_get_wakeup_source(u32 **sources)\r\n{\r\nif (!imx_gpcv2_instance)\r\nreturn 0;\r\nif (sources)\r\n*sources = imx_gpcv2_instance->wakeup_sources;\r\nreturn IMR_NUM;\r\n}\r\nstatic int gpcv2_wakeup_source_save(void)\r\n{\r\nstruct gpcv2_irqchip_data *cd;\r\nvoid __iomem *reg;\r\nint i;\r\ncd = imx_gpcv2_instance;\r\nif (!cd)\r\nreturn 0;\r\nfor (i = 0; i < IMR_NUM; i++) {\r\nreg = cd->gpc_base + cd->cpu2wakeup + i * 4;\r\ncd->saved_irq_mask[i] = readl_relaxed(reg);\r\nwritel_relaxed(cd->wakeup_sources[i], reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void gpcv2_wakeup_source_restore(void)\r\n{\r\nstruct gpcv2_irqchip_data *cd;\r\nvoid __iomem *reg;\r\nint i;\r\ncd = imx_gpcv2_instance;\r\nif (!cd)\r\nreturn;\r\nfor (i = 0; i < IMR_NUM; i++) {\r\nreg = cd->gpc_base + cd->cpu2wakeup + i * 4;\r\nwritel_relaxed(cd->saved_irq_mask[i], reg);\r\n}\r\n}\r\nstatic int imx_gpcv2_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct gpcv2_irqchip_data *cd = d->chip_data;\r\nunsigned int idx = d->hwirq / 32;\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 mask, val;\r\nraw_spin_lock_irqsave(&cd->rlock, flags);\r\nreg = cd->gpc_base + cd->cpu2wakeup + idx * 4;\r\nmask = 1 << d->hwirq % 32;\r\nval = cd->wakeup_sources[idx];\r\ncd->wakeup_sources[idx] = on ? (val & ~mask) : (val | mask);\r\nraw_spin_unlock_irqrestore(&cd->rlock, flags);\r\nreturn 0;\r\n}\r\nstatic void imx_gpcv2_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpcv2_irqchip_data *cd = d->chip_data;\r\nvoid __iomem *reg;\r\nu32 val;\r\nraw_spin_lock(&cd->rlock);\r\nreg = cd->gpc_base + cd->cpu2wakeup + d->hwirq / 32 * 4;\r\nval = readl_relaxed(reg);\r\nval &= ~(1 << d->hwirq % 32);\r\nwritel_relaxed(val, reg);\r\nraw_spin_unlock(&cd->rlock);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic void imx_gpcv2_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpcv2_irqchip_data *cd = d->chip_data;\r\nvoid __iomem *reg;\r\nu32 val;\r\nraw_spin_lock(&cd->rlock);\r\nreg = cd->gpc_base + cd->cpu2wakeup + d->hwirq / 32 * 4;\r\nval = readl_relaxed(reg);\r\nval |= 1 << (d->hwirq % 32);\r\nwritel_relaxed(val, reg);\r\nraw_spin_unlock(&cd->rlock);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic int imx_gpcv2_domain_translate(struct irq_domain *d,\r\nstruct irq_fwspec *fwspec,\r\nunsigned long *hwirq,\r\nunsigned int *type)\r\n{\r\nif (is_of_node(fwspec->fwnode)) {\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\n*hwirq = fwspec->param[1];\r\n*type = fwspec->param[2];\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int imx_gpcv2_domain_alloc(struct irq_domain *domain,\r\nunsigned int irq, unsigned int nr_irqs,\r\nvoid *data)\r\n{\r\nstruct irq_fwspec *fwspec = data;\r\nstruct irq_fwspec parent_fwspec;\r\nirq_hw_number_t hwirq;\r\nunsigned int type;\r\nint err;\r\nint i;\r\nerr = imx_gpcv2_domain_translate(domain, fwspec, &hwirq, &type);\r\nif (err)\r\nreturn err;\r\nif (hwirq >= GPC_MAX_IRQS)\r\nreturn -EINVAL;\r\nfor (i = 0; i < nr_irqs; i++) {\r\nirq_domain_set_hwirq_and_chip(domain, irq + i, hwirq + i,\r\n&gpcv2_irqchip_data_chip, domain->host_data);\r\n}\r\nparent_fwspec = *fwspec;\r\nparent_fwspec.fwnode = domain->parent->fwnode;\r\nreturn irq_domain_alloc_irqs_parent(domain, irq, nr_irqs,\r\n&parent_fwspec);\r\n}\r\nstatic int __init imx_gpcv2_irqchip_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct irq_domain *parent_domain, *domain;\r\nstruct gpcv2_irqchip_data *cd;\r\nint i;\r\nif (!parent) {\r\npr_err("%s: no parent, giving up\n", node->full_name);\r\nreturn -ENODEV;\r\n}\r\nparent_domain = irq_find_host(parent);\r\nif (!parent_domain) {\r\npr_err("%s: unable to get parent domain\n", node->full_name);\r\nreturn -ENXIO;\r\n}\r\ncd = kzalloc(sizeof(struct gpcv2_irqchip_data), GFP_KERNEL);\r\nif (!cd) {\r\npr_err("kzalloc failed!\n");\r\nreturn -ENOMEM;\r\n}\r\ncd->gpc_base = of_iomap(node, 0);\r\nif (!cd->gpc_base) {\r\npr_err("fsl-gpcv2: unable to map gpc registers\n");\r\nkfree(cd);\r\nreturn -ENOMEM;\r\n}\r\ndomain = irq_domain_add_hierarchy(parent_domain, 0, GPC_MAX_IRQS,\r\nnode, &gpcv2_irqchip_data_domain_ops, cd);\r\nif (!domain) {\r\niounmap(cd->gpc_base);\r\nkfree(cd);\r\nreturn -ENOMEM;\r\n}\r\nirq_set_default_host(domain);\r\nfor (i = 0; i < IMR_NUM; i++) {\r\nwritel_relaxed(~0, cd->gpc_base + GPC_IMR1_CORE0 + i * 4);\r\nwritel_relaxed(~0, cd->gpc_base + GPC_IMR1_CORE1 + i * 4);\r\ncd->wakeup_sources[i] = ~0;\r\n}\r\ncd->cpu2wakeup = GPC_IMR1_CORE0;\r\nwritel_relaxed(~0x1, cd->gpc_base + cd->cpu2wakeup);\r\nimx_gpcv2_instance = cd;\r\nregister_syscore_ops(&imx_gpcv2_syscore_ops);\r\nreturn 0;\r\n}
