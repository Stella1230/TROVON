static void\r\nfs3270_wake_up(struct raw3270_request *rq, void *data)\r\n{\r\nwake_up((wait_queue_head_t *) data);\r\n}\r\nstatic inline int\r\nfs3270_working(struct fs3270 *fp)\r\n{\r\nreturn fp->active && raw3270_request_final(fp->init);\r\n}\r\nstatic int\r\nfs3270_do_io(struct raw3270_view *view, struct raw3270_request *rq)\r\n{\r\nstruct fs3270 *fp;\r\nint rc;\r\nfp = (struct fs3270 *) view;\r\nrq->callback = fs3270_wake_up;\r\nrq->callback_data = &fp->wait;\r\ndo {\r\nif (!fs3270_working(fp)) {\r\nrc = wait_event_interruptible(fp->wait,\r\nfs3270_working(fp));\r\nif (rc != 0)\r\nbreak;\r\n}\r\nrc = raw3270_start(view, rq);\r\nif (rc == 0) {\r\nwait_event(fp->wait, raw3270_request_final(rq));\r\n}\r\n} while (rc == -EACCES);\r\nreturn rc;\r\n}\r\nstatic void\r\nfs3270_reset_callback(struct raw3270_request *rq, void *data)\r\n{\r\nstruct fs3270 *fp;\r\nfp = (struct fs3270 *) rq->view;\r\nraw3270_request_reset(rq);\r\nwake_up(&fp->wait);\r\n}\r\nstatic void\r\nfs3270_restore_callback(struct raw3270_request *rq, void *data)\r\n{\r\nstruct fs3270 *fp;\r\nfp = (struct fs3270 *) rq->view;\r\nif (rq->rc != 0 || rq->rescnt != 0) {\r\nif (fp->fs_pid)\r\nkill_pid(fp->fs_pid, SIGHUP, 1);\r\n}\r\nfp->rdbuf_size = 0;\r\nraw3270_request_reset(rq);\r\nwake_up(&fp->wait);\r\n}\r\nstatic int\r\nfs3270_activate(struct raw3270_view *view)\r\n{\r\nstruct fs3270 *fp;\r\nchar *cp;\r\nint rc;\r\nfp = (struct fs3270 *) view;\r\nif (!raw3270_request_final(fp->init))\r\nreturn 0;\r\nif (fp->rdbuf_size == 0) {\r\nraw3270_request_set_cmd(fp->init, TC_EWRITEA);\r\nfp->init->callback = fs3270_reset_callback;\r\n} else {\r\nraw3270_request_set_cmd(fp->init, TC_EWRITEA);\r\nraw3270_request_set_idal(fp->init, fp->rdbuf);\r\nfp->init->ccw.count = fp->rdbuf_size;\r\ncp = fp->rdbuf->data[0];\r\ncp[0] = TW_KR;\r\ncp[1] = TO_SBA;\r\ncp[2] = cp[6];\r\ncp[3] = cp[7];\r\ncp[4] = TO_IC;\r\ncp[5] = TO_SBA;\r\ncp[6] = 0x40;\r\ncp[7] = 0x40;\r\nfp->init->rescnt = 0;\r\nfp->init->callback = fs3270_restore_callback;\r\n}\r\nrc = fp->init->rc = raw3270_start_locked(view, fp->init);\r\nif (rc)\r\nfp->init->callback(fp->init, NULL);\r\nelse\r\nfp->active = 1;\r\nreturn rc;\r\n}\r\nstatic void\r\nfs3270_save_callback(struct raw3270_request *rq, void *data)\r\n{\r\nstruct fs3270 *fp;\r\nfp = (struct fs3270 *) rq->view;\r\nfp->rdbuf->data[0] -= 5;\r\nfp->rdbuf->size += 5;\r\nif (rq->rc != 0 || rq->rescnt == 0) {\r\nif (fp->fs_pid)\r\nkill_pid(fp->fs_pid, SIGHUP, 1);\r\nfp->rdbuf_size = 0;\r\n} else\r\nfp->rdbuf_size = fp->rdbuf->size - rq->rescnt;\r\nraw3270_request_reset(rq);\r\nwake_up(&fp->wait);\r\n}\r\nstatic void\r\nfs3270_deactivate(struct raw3270_view *view)\r\n{\r\nstruct fs3270 *fp;\r\nfp = (struct fs3270 *) view;\r\nfp->active = 0;\r\nif (!raw3270_request_final(fp->init))\r\nreturn;\r\nraw3270_request_set_cmd(fp->init, TC_RDBUF);\r\nfp->rdbuf->data[0] += 5;\r\nfp->rdbuf->size -= 5;\r\nraw3270_request_set_idal(fp->init, fp->rdbuf);\r\nfp->init->rescnt = 0;\r\nfp->init->callback = fs3270_save_callback;\r\nfp->init->rc = raw3270_start_locked(view, fp->init);\r\nif (fp->init->rc)\r\nfp->init->callback(fp->init, NULL);\r\n}\r\nstatic void\r\nfs3270_irq(struct fs3270 *fp, struct raw3270_request *rq, struct irb *irb)\r\n{\r\nif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\r\nfp->attention = 1;\r\nwake_up(&fp->wait);\r\n}\r\nif (rq) {\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\r\nrq->rc = -EIO;\r\nelse\r\nrq->rescnt = irb->scsw.cmd.count;\r\n}\r\n}\r\nstatic ssize_t\r\nfs3270_read(struct file *filp, char __user *data, size_t count, loff_t *off)\r\n{\r\nstruct fs3270 *fp;\r\nstruct raw3270_request *rq;\r\nstruct idal_buffer *ib;\r\nssize_t rc;\r\nif (count == 0 || count > 65535)\r\nreturn -EINVAL;\r\nfp = filp->private_data;\r\nif (!fp)\r\nreturn -ENODEV;\r\nib = idal_buffer_alloc(count, 0);\r\nif (IS_ERR(ib))\r\nreturn -ENOMEM;\r\nrq = raw3270_request_alloc(0);\r\nif (!IS_ERR(rq)) {\r\nif (fp->read_command == 0 && fp->write_command != 0)\r\nfp->read_command = 6;\r\nraw3270_request_set_cmd(rq, fp->read_command ? : 2);\r\nraw3270_request_set_idal(rq, ib);\r\nrc = wait_event_interruptible(fp->wait, fp->attention);\r\nfp->attention = 0;\r\nif (rc == 0) {\r\nrc = fs3270_do_io(&fp->view, rq);\r\nif (rc == 0) {\r\ncount -= rq->rescnt;\r\nif (idal_buffer_to_user(ib, data, count) != 0)\r\nrc = -EFAULT;\r\nelse\r\nrc = count;\r\n}\r\n}\r\nraw3270_request_free(rq);\r\n} else\r\nrc = PTR_ERR(rq);\r\nidal_buffer_free(ib);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nfs3270_write(struct file *filp, const char __user *data, size_t count, loff_t *off)\r\n{\r\nstruct fs3270 *fp;\r\nstruct raw3270_request *rq;\r\nstruct idal_buffer *ib;\r\nint write_command;\r\nssize_t rc;\r\nfp = filp->private_data;\r\nif (!fp)\r\nreturn -ENODEV;\r\nib = idal_buffer_alloc(count, 0);\r\nif (IS_ERR(ib))\r\nreturn -ENOMEM;\r\nrq = raw3270_request_alloc(0);\r\nif (!IS_ERR(rq)) {\r\nif (idal_buffer_from_user(ib, data, count) == 0) {\r\nwrite_command = fp->write_command ? : 1;\r\nif (write_command == 5)\r\nwrite_command = 13;\r\nraw3270_request_set_cmd(rq, write_command);\r\nraw3270_request_set_idal(rq, ib);\r\nrc = fs3270_do_io(&fp->view, rq);\r\nif (rc == 0)\r\nrc = count - rq->rescnt;\r\n} else\r\nrc = -EFAULT;\r\nraw3270_request_free(rq);\r\n} else\r\nrc = PTR_ERR(rq);\r\nidal_buffer_free(ib);\r\nreturn rc;\r\n}\r\nstatic long\r\nfs3270_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nchar __user *argp;\r\nstruct fs3270 *fp;\r\nstruct raw3270_iocb iocb;\r\nint rc;\r\nfp = filp->private_data;\r\nif (!fp)\r\nreturn -ENODEV;\r\nif (is_compat_task())\r\nargp = compat_ptr(arg);\r\nelse\r\nargp = (char __user *)arg;\r\nrc = 0;\r\nmutex_lock(&fs3270_mutex);\r\nswitch (cmd) {\r\ncase TUBICMD:\r\nfp->read_command = arg;\r\nbreak;\r\ncase TUBOCMD:\r\nfp->write_command = arg;\r\nbreak;\r\ncase TUBGETI:\r\nrc = put_user(fp->read_command, argp);\r\nbreak;\r\ncase TUBGETO:\r\nrc = put_user(fp->write_command, argp);\r\nbreak;\r\ncase TUBGETMOD:\r\niocb.model = fp->view.model;\r\niocb.line_cnt = fp->view.rows;\r\niocb.col_cnt = fp->view.cols;\r\niocb.pf_cnt = 24;\r\niocb.re_cnt = 20;\r\niocb.map = 0;\r\nif (copy_to_user(argp, &iocb, sizeof(struct raw3270_iocb)))\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nmutex_unlock(&fs3270_mutex);\r\nreturn rc;\r\n}\r\nstatic struct fs3270 *\r\nfs3270_alloc_view(void)\r\n{\r\nstruct fs3270 *fp;\r\nfp = kzalloc(sizeof(struct fs3270),GFP_KERNEL);\r\nif (!fp)\r\nreturn ERR_PTR(-ENOMEM);\r\nfp->init = raw3270_request_alloc(0);\r\nif (IS_ERR(fp->init)) {\r\nkfree(fp);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn fp;\r\n}\r\nstatic void\r\nfs3270_free_view(struct raw3270_view *view)\r\n{\r\nstruct fs3270 *fp;\r\nfp = (struct fs3270 *) view;\r\nif (fp->rdbuf)\r\nidal_buffer_free(fp->rdbuf);\r\nraw3270_request_free(((struct fs3270 *) view)->init);\r\nkfree(view);\r\n}\r\nstatic void\r\nfs3270_release(struct raw3270_view *view)\r\n{\r\nstruct fs3270 *fp;\r\nfp = (struct fs3270 *) view;\r\nif (fp->fs_pid)\r\nkill_pid(fp->fs_pid, SIGHUP, 1);\r\n}\r\nstatic int\r\nfs3270_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct fs3270 *fp;\r\nstruct idal_buffer *ib;\r\nint minor, rc = 0;\r\nif (imajor(file_inode(filp)) != IBM_FS3270_MAJOR)\r\nreturn -ENODEV;\r\nminor = iminor(file_inode(filp));\r\nif (minor == 0) {\r\nstruct tty_struct *tty = get_current_tty();\r\nif (!tty || tty->driver->major != IBM_TTY3270_MAJOR) {\r\ntty_kref_put(tty);\r\nreturn -ENODEV;\r\n}\r\nminor = tty->index;\r\ntty_kref_put(tty);\r\n}\r\nmutex_lock(&fs3270_mutex);\r\nfp = (struct fs3270 *) raw3270_find_view(&fs3270_fn, minor);\r\nif (!IS_ERR(fp)) {\r\nraw3270_put_view(&fp->view);\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nfp = fs3270_alloc_view();\r\nif (IS_ERR(fp)) {\r\nrc = PTR_ERR(fp);\r\ngoto out;\r\n}\r\ninit_waitqueue_head(&fp->wait);\r\nfp->fs_pid = get_pid(task_pid(current));\r\nrc = raw3270_add_view(&fp->view, &fs3270_fn, minor);\r\nif (rc) {\r\nfs3270_free_view(&fp->view);\r\ngoto out;\r\n}\r\nib = idal_buffer_alloc(2*fp->view.rows*fp->view.cols + 5, 0);\r\nif (IS_ERR(ib)) {\r\nraw3270_put_view(&fp->view);\r\nraw3270_del_view(&fp->view);\r\nrc = PTR_ERR(ib);\r\ngoto out;\r\n}\r\nfp->rdbuf = ib;\r\nrc = raw3270_activate_view(&fp->view);\r\nif (rc) {\r\nraw3270_put_view(&fp->view);\r\nraw3270_del_view(&fp->view);\r\ngoto out;\r\n}\r\nnonseekable_open(inode, filp);\r\nfilp->private_data = fp;\r\nout:\r\nmutex_unlock(&fs3270_mutex);\r\nreturn rc;\r\n}\r\nstatic int\r\nfs3270_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct fs3270 *fp;\r\nfp = filp->private_data;\r\nfilp->private_data = NULL;\r\nif (fp) {\r\nput_pid(fp->fs_pid);\r\nfp->fs_pid = NULL;\r\nraw3270_reset(&fp->view);\r\nraw3270_put_view(&fp->view);\r\nraw3270_del_view(&fp->view);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fs3270_create_cb(int minor)\r\n{\r\n__register_chrdev(IBM_FS3270_MAJOR, minor, 1, "tub", &fs3270_fops);\r\ndevice_create(class3270, NULL, MKDEV(IBM_FS3270_MAJOR, minor),\r\nNULL, "3270/tub%d", minor);\r\n}\r\nstatic void fs3270_destroy_cb(int minor)\r\n{\r\ndevice_destroy(class3270, MKDEV(IBM_FS3270_MAJOR, minor));\r\n__unregister_chrdev(IBM_FS3270_MAJOR, minor, 1, "tub");\r\n}\r\nstatic int __init\r\nfs3270_init(void)\r\n{\r\nint rc;\r\nrc = __register_chrdev(IBM_FS3270_MAJOR, 0, 1, "fs3270", &fs3270_fops);\r\nif (rc)\r\nreturn rc;\r\ndevice_create(class3270, NULL, MKDEV(IBM_FS3270_MAJOR, 0),\r\nNULL, "3270/tub");\r\nraw3270_register_notifier(&fs3270_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nfs3270_exit(void)\r\n{\r\nraw3270_unregister_notifier(&fs3270_notifier);\r\ndevice_destroy(class3270, MKDEV(IBM_FS3270_MAJOR, 0));\r\n__unregister_chrdev(IBM_FS3270_MAJOR, 0, 1, "fs3270");\r\n}
