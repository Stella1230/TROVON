static u8 sunxi_sid_read_byte(const struct sunxi_sid *sid,\r\nconst unsigned int offset)\r\n{\r\nu32 sid_key;\r\nsid_key = ioread32be(sid->base + round_down(offset, 4));\r\nsid_key >>= (offset % 4) * 8;\r\nreturn sid_key;\r\n}\r\nstatic int sunxi_sid_read(void *context, unsigned int offset,\r\nvoid *val, size_t bytes)\r\n{\r\nstruct sunxi_sid *sid = context;\r\nu8 *buf = val;\r\nwhile (bytes--)\r\n*buf++ = sunxi_sid_read_byte(sid, offset++);\r\nreturn 0;\r\n}\r\nstatic int sunxi_sid_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct nvmem_device *nvmem;\r\nstruct sunxi_sid *sid;\r\nint ret, i, size;\r\nchar *randomness;\r\nsid = devm_kzalloc(dev, sizeof(*sid), GFP_KERNEL);\r\nif (!sid)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsid->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(sid->base))\r\nreturn PTR_ERR(sid->base);\r\nsize = resource_size(res) - 1;\r\neconfig.size = resource_size(res);\r\neconfig.dev = dev;\r\neconfig.reg_read = sunxi_sid_read;\r\neconfig.priv = sid;\r\nnvmem = nvmem_register(&econfig);\r\nif (IS_ERR(nvmem))\r\nreturn PTR_ERR(nvmem);\r\nrandomness = kzalloc(sizeof(u8) * (size), GFP_KERNEL);\r\nif (!randomness) {\r\nret = -EINVAL;\r\ngoto err_unreg_nvmem;\r\n}\r\nfor (i = 0; i < size; i++)\r\nrandomness[i] = sunxi_sid_read_byte(sid, i);\r\nadd_device_randomness(randomness, size);\r\nkfree(randomness);\r\nplatform_set_drvdata(pdev, nvmem);\r\nreturn 0;\r\nerr_unreg_nvmem:\r\nnvmem_unregister(nvmem);\r\nreturn ret;\r\n}\r\nstatic int sunxi_sid_remove(struct platform_device *pdev)\r\n{\r\nstruct nvmem_device *nvmem = platform_get_drvdata(pdev);\r\nreturn nvmem_unregister(nvmem);\r\n}
