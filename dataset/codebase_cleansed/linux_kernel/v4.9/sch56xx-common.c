static inline int superio_inb(int base, int reg)\r\n{\r\noutb(reg, base);\r\nreturn inb(base + 1);\r\n}\r\nstatic inline int superio_enter(int base)\r\n{\r\nif (!request_muxed_region(base, 2, "sch56xx")) {\r\npr_err("I/O address 0x%04x already in use\n", base);\r\nreturn -EBUSY;\r\n}\r\noutb(SIO_UNLOCK_KEY, base);\r\nreturn 0;\r\n}\r\nstatic inline void superio_select(int base, int ld)\r\n{\r\noutb(SIO_REG_LDSEL, base);\r\noutb(ld, base + 1);\r\n}\r\nstatic inline void superio_exit(int base)\r\n{\r\noutb(SIO_LOCK_KEY, base);\r\nrelease_region(base, 2);\r\n}\r\nstatic int sch56xx_send_cmd(u16 addr, u8 cmd, u16 reg, u8 v)\r\n{\r\nu8 val;\r\nint i;\r\nconst int max_busy_polls = 64;\r\nconst int max_lazy_polls = 32;\r\nval = inb(addr + 1);\r\noutb(val, addr + 1);\r\noutb(0x00, addr + 2);\r\noutb(0x80, addr + 3);\r\noutb(cmd, addr + 4);\r\noutb(0x01, addr + 5);\r\noutb(0x04, addr + 2);\r\nif (cmd == SCH56XX_CMD_WRITE)\r\noutb(v, addr + 4);\r\noutb(reg & 0xff, addr + 6);\r\noutb(reg >> 8, addr + 7);\r\noutb(0x01, addr);\r\nfor (i = 0; i < max_busy_polls + max_lazy_polls; i++) {\r\nif (i >= max_busy_polls)\r\nmsleep(1);\r\nval = inb(addr + 8);\r\nif (val)\r\noutb(val, addr + 8);\r\nif (val & 0x01)\r\nbreak;\r\n}\r\nif (i == max_busy_polls + max_lazy_polls) {\r\npr_err("Max retries exceeded reading virtual register 0x%04hx (%d)\n",\r\nreg, 1);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < max_busy_polls; i++) {\r\nval = inb(addr + 1);\r\nif (val == 0x01)\r\nbreak;\r\nif (i == 0)\r\npr_warn("EC reports: 0x%02x reading virtual register 0x%04hx\n",\r\n(unsigned int)val, reg);\r\n}\r\nif (i == max_busy_polls) {\r\npr_err("Max retries exceeded reading virtual register 0x%04hx (%d)\n",\r\nreg, 2);\r\nreturn -EIO;\r\n}\r\nif (cmd == SCH56XX_CMD_READ)\r\nreturn inb(addr + 4);\r\nreturn 0;\r\n}\r\nint sch56xx_read_virtual_reg(u16 addr, u16 reg)\r\n{\r\nreturn sch56xx_send_cmd(addr, SCH56XX_CMD_READ, reg, 0);\r\n}\r\nint sch56xx_write_virtual_reg(u16 addr, u16 reg, u8 val)\r\n{\r\nreturn sch56xx_send_cmd(addr, SCH56XX_CMD_WRITE, reg, val);\r\n}\r\nint sch56xx_read_virtual_reg16(u16 addr, u16 reg)\r\n{\r\nint lsb, msb;\r\nlsb = sch56xx_read_virtual_reg(addr, reg);\r\nif (lsb < 0)\r\nreturn lsb;\r\nmsb = sch56xx_read_virtual_reg(addr, reg + 1);\r\nif (msb < 0)\r\nreturn msb;\r\nreturn lsb | (msb << 8);\r\n}\r\nint sch56xx_read_virtual_reg12(u16 addr, u16 msb_reg, u16 lsn_reg,\r\nint high_nibble)\r\n{\r\nint msb, lsn;\r\nmsb = sch56xx_read_virtual_reg(addr, msb_reg);\r\nif (msb < 0)\r\nreturn msb;\r\nlsn = sch56xx_read_virtual_reg(addr, lsn_reg);\r\nif (lsn < 0)\r\nreturn lsn;\r\nif (high_nibble)\r\nreturn (msb << 4) | (lsn >> 4);\r\nelse\r\nreturn (msb << 4) | (lsn & 0x0f);\r\n}\r\nstatic int watchdog_set_timeout(struct watchdog_device *wddev,\r\nunsigned int timeout)\r\n{\r\nstruct sch56xx_watchdog_data *data = watchdog_get_drvdata(wddev);\r\nunsigned int resolution;\r\nu8 control;\r\nint ret;\r\nif (timeout <= 255)\r\nresolution = 1;\r\nelse\r\nresolution = 60;\r\nif (timeout < resolution || timeout > (resolution * 255))\r\nreturn -EINVAL;\r\nif (resolution == 1)\r\ncontrol = data->watchdog_control | SCH56XX_WDOG_TIME_BASE_SEC;\r\nelse\r\ncontrol = data->watchdog_control & ~SCH56XX_WDOG_TIME_BASE_SEC;\r\nif (data->watchdog_control != control) {\r\nmutex_lock(data->io_lock);\r\nret = sch56xx_write_virtual_reg(data->addr,\r\nSCH56XX_REG_WDOG_CONTROL,\r\ncontrol);\r\nmutex_unlock(data->io_lock);\r\nif (ret)\r\nreturn ret;\r\ndata->watchdog_control = control;\r\n}\r\ndata->watchdog_preset = DIV_ROUND_UP(timeout, resolution);\r\nwddev->timeout = data->watchdog_preset * resolution;\r\nreturn 0;\r\n}\r\nstatic int watchdog_start(struct watchdog_device *wddev)\r\n{\r\nstruct sch56xx_watchdog_data *data = watchdog_get_drvdata(wddev);\r\nint ret;\r\nu8 val;\r\nmutex_lock(data->io_lock);\r\nret = sch56xx_write_virtual_reg(data->addr, SCH56XX_REG_WDOG_PRESET,\r\ndata->watchdog_preset);\r\nif (ret)\r\ngoto leave;\r\nval = data->watchdog_output_enable | SCH56XX_WDOG_OUTPUT_ENABLE;\r\nret = sch56xx_write_virtual_reg(data->addr,\r\nSCH56XX_REG_WDOG_OUTPUT_ENABLE, val);\r\nif (ret)\r\ngoto leave;\r\ndata->watchdog_output_enable = val;\r\nval = inb(data->addr + 9);\r\nif (val & 0x01)\r\noutb(0x01, data->addr + 9);\r\nleave:\r\nmutex_unlock(data->io_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_trigger(struct watchdog_device *wddev)\r\n{\r\nstruct sch56xx_watchdog_data *data = watchdog_get_drvdata(wddev);\r\nint ret;\r\nmutex_lock(data->io_lock);\r\nret = sch56xx_write_virtual_reg(data->addr, SCH56XX_REG_WDOG_PRESET,\r\ndata->watchdog_preset);\r\nmutex_unlock(data->io_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_stop(struct watchdog_device *wddev)\r\n{\r\nstruct sch56xx_watchdog_data *data = watchdog_get_drvdata(wddev);\r\nint ret = 0;\r\nu8 val;\r\nval = data->watchdog_output_enable & ~SCH56XX_WDOG_OUTPUT_ENABLE;\r\nmutex_lock(data->io_lock);\r\nret = sch56xx_write_virtual_reg(data->addr,\r\nSCH56XX_REG_WDOG_OUTPUT_ENABLE, val);\r\nmutex_unlock(data->io_lock);\r\nif (ret)\r\nreturn ret;\r\ndata->watchdog_output_enable = val;\r\nreturn 0;\r\n}\r\nstruct sch56xx_watchdog_data *sch56xx_watchdog_register(struct device *parent,\r\nu16 addr, u32 revision, struct mutex *io_lock, int check_enabled)\r\n{\r\nstruct sch56xx_watchdog_data *data;\r\nint err, control, output_enable;\r\nmutex_lock(io_lock);\r\ncontrol =\r\nsch56xx_read_virtual_reg(addr, SCH56XX_REG_WDOG_CONTROL);\r\noutput_enable =\r\nsch56xx_read_virtual_reg(addr, SCH56XX_REG_WDOG_OUTPUT_ENABLE);\r\nmutex_unlock(io_lock);\r\nif (control < 0)\r\nreturn NULL;\r\nif (output_enable < 0)\r\nreturn NULL;\r\nif (check_enabled && !(output_enable & SCH56XX_WDOG_OUTPUT_ENABLE)) {\r\npr_warn("Watchdog not enabled by BIOS, not registering\n");\r\nreturn NULL;\r\n}\r\ndata = kzalloc(sizeof(struct sch56xx_watchdog_data), GFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\ndata->addr = addr;\r\ndata->io_lock = io_lock;\r\nstrlcpy(data->wdinfo.identity, "sch56xx watchdog",\r\nsizeof(data->wdinfo.identity));\r\ndata->wdinfo.firmware_version = revision;\r\ndata->wdinfo.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT;\r\nif (!nowayout)\r\ndata->wdinfo.options |= WDIOF_MAGICCLOSE;\r\ndata->wddev.info = &data->wdinfo;\r\ndata->wddev.ops = &watchdog_ops;\r\ndata->wddev.parent = parent;\r\ndata->wddev.timeout = 60;\r\ndata->wddev.min_timeout = 1;\r\ndata->wddev.max_timeout = 255 * 60;\r\nif (nowayout)\r\nset_bit(WDOG_NO_WAY_OUT, &data->wddev.status);\r\nif (output_enable & SCH56XX_WDOG_OUTPUT_ENABLE)\r\nset_bit(WDOG_ACTIVE, &data->wddev.status);\r\nif (control & SCH56XX_WDOG_TIME_BASE_SEC)\r\ndata->watchdog_preset = 60;\r\nelse\r\ndata->watchdog_preset = 1;\r\ndata->watchdog_control = control;\r\ndata->watchdog_output_enable = output_enable;\r\nwatchdog_set_drvdata(&data->wddev, data);\r\nerr = watchdog_register_device(&data->wddev);\r\nif (err) {\r\npr_err("Registering watchdog chardev: %d\n", err);\r\nkfree(data);\r\nreturn NULL;\r\n}\r\nreturn data;\r\n}\r\nvoid sch56xx_watchdog_unregister(struct sch56xx_watchdog_data *data)\r\n{\r\nwatchdog_unregister_device(&data->wddev);\r\nkfree(data);\r\n}\r\nstatic int __init sch56xx_find(int sioaddr, const char **name)\r\n{\r\nu8 devid;\r\nunsigned short address;\r\nint err;\r\nerr = superio_enter(sioaddr);\r\nif (err)\r\nreturn err;\r\ndevid = superio_inb(sioaddr, SIO_REG_DEVID);\r\nswitch (devid) {\r\ncase SIO_SCH5627_ID:\r\n*name = "sch5627";\r\nbreak;\r\ncase SIO_SCH5636_ID:\r\n*name = "sch5636";\r\nbreak;\r\ndefault:\r\npr_debug("Unsupported device id: 0x%02x\n",\r\n(unsigned int)devid);\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nsuperio_select(sioaddr, SIO_SCH56XX_LD_EM);\r\nif (!(superio_inb(sioaddr, SIO_REG_ENABLE) & 0x01)) {\r\npr_warn("Device not activated\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\naddress = superio_inb(sioaddr, SIO_REG_ADDR) |\r\nsuperio_inb(sioaddr, SIO_REG_ADDR + 1) << 8;\r\nif (address == 0) {\r\npr_warn("Base address not set\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nerr = address;\r\nexit:\r\nsuperio_exit(sioaddr);\r\nreturn err;\r\n}\r\nstatic int __init sch56xx_device_add(int address, const char *name)\r\n{\r\nstruct resource res = {\r\n.start = address,\r\n.end = address + REGION_LENGTH - 1,\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\nsch56xx_pdev = platform_device_alloc(name, address);\r\nif (!sch56xx_pdev)\r\nreturn -ENOMEM;\r\nres.name = sch56xx_pdev->name;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err)\r\ngoto exit_device_put;\r\nerr = platform_device_add_resources(sch56xx_pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed\n");\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(sch56xx_pdev);\r\nif (err) {\r\npr_err("Device addition failed\n");\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(sch56xx_pdev);\r\nreturn err;\r\n}\r\nstatic int __init sch56xx_init(void)\r\n{\r\nint address;\r\nconst char *name = NULL;\r\naddress = sch56xx_find(0x4e, &name);\r\nif (address < 0)\r\naddress = sch56xx_find(0x2e, &name);\r\nif (address < 0)\r\nreturn address;\r\nreturn sch56xx_device_add(address, name);\r\n}\r\nstatic void __exit sch56xx_exit(void)\r\n{\r\nplatform_device_unregister(sch56xx_pdev);\r\n}
