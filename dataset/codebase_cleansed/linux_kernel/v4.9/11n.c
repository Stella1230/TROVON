int mwifiex_fill_cap_info(struct mwifiex_private *priv, u8 radio_type,\r\nstruct ieee80211_ht_cap *ht_cap)\r\n{\r\nuint16_t ht_ext_cap = le16_to_cpu(ht_cap->extended_ht_cap_info);\r\nstruct ieee80211_supported_band *sband =\r\npriv->wdev.wiphy->bands[radio_type];\r\nif (WARN_ON_ONCE(!sband)) {\r\nmwifiex_dbg(priv->adapter, ERROR, "Invalid radio type!\n");\r\nreturn -EINVAL;\r\n}\r\nht_cap->ampdu_params_info =\r\n(sband->ht_cap.ampdu_factor &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR) |\r\n((sband->ht_cap.ampdu_density <<\r\nIEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT) &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY);\r\nmemcpy((u8 *)&ht_cap->mcs, &sband->ht_cap.mcs,\r\nsizeof(sband->ht_cap.mcs));\r\nif (priv->bss_mode == NL80211_IFTYPE_STATION ||\r\n(sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&\r\n(priv->adapter->sec_chan_offset !=\r\nIEEE80211_HT_PARAM_CHA_SEC_NONE)))\r\nSETHT_MCS32(ht_cap->mcs.rx_mask);\r\nht_ext_cap &= ~IEEE80211_HT_EXT_CAP_RD_RESPONDER;\r\nht_cap->cap_info = cpu_to_le16(sband->ht_cap.cap);\r\nht_cap->extended_ht_cap_info = cpu_to_le16(ht_ext_cap);\r\nif (ISSUPP_BEAMFORMING(priv->adapter->hw_dot_11n_dev_cap))\r\nht_cap->tx_BF_cap_info = cpu_to_le32(MWIFIEX_DEF_11N_TX_BF_CAP);\r\nreturn 0;\r\n}\r\nstatic struct mwifiex_tx_ba_stream_tbl *\r\nmwifiex_get_ba_status(struct mwifiex_private *priv,\r\nenum mwifiex_ba_status ba_status)\r\n{\r\nstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);\r\nlist_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {\r\nif (tx_ba_tsr_tbl->ba_status == ba_status) {\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock,\r\nflags);\r\nreturn tx_ba_tsr_tbl;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock, flags);\r\nreturn NULL;\r\n}\r\nint mwifiex_ret_11n_delba(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nint tid;\r\nstruct mwifiex_tx_ba_stream_tbl *tx_ba_tbl;\r\nstruct host_cmd_ds_11n_delba *del_ba = &resp->params.del_ba;\r\nuint16_t del_ba_param_set = le16_to_cpu(del_ba->del_ba_param_set);\r\ntid = del_ba_param_set >> DELBA_TID_POS;\r\nif (del_ba->del_result == BA_RESULT_SUCCESS) {\r\nmwifiex_del_ba_tbl(priv, tid, del_ba->peer_mac_addr,\r\nTYPE_DELBA_SENT,\r\nINITIATOR_BIT(del_ba_param_set));\r\ntx_ba_tbl = mwifiex_get_ba_status(priv, BA_SETUP_INPROGRESS);\r\nif (tx_ba_tbl)\r\nmwifiex_send_addba(priv, tx_ba_tbl->tid,\r\ntx_ba_tbl->ra);\r\n} else {\r\nif (!INITIATOR_BIT(del_ba_param_set))\r\nreturn 0;\r\nmwifiex_create_ba_tbl(priv, del_ba->peer_mac_addr, tid,\r\nBA_SETUP_INPROGRESS);\r\ntx_ba_tbl = mwifiex_get_ba_status(priv, BA_SETUP_INPROGRESS);\r\nif (tx_ba_tbl)\r\nmwifiex_del_ba_tbl(priv, tx_ba_tbl->tid, tx_ba_tbl->ra,\r\nTYPE_DELBA_SENT, true);\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_ret_11n_addba_req(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nint tid, tid_down;\r\nstruct host_cmd_ds_11n_addba_rsp *add_ba_rsp = &resp->params.add_ba_rsp;\r\nstruct mwifiex_tx_ba_stream_tbl *tx_ba_tbl;\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nu16 block_ack_param_set = le16_to_cpu(add_ba_rsp->block_ack_param_set);\r\nadd_ba_rsp->ssn = cpu_to_le16((le16_to_cpu(add_ba_rsp->ssn))\r\n& SSN_MASK);\r\ntid = (block_ack_param_set & IEEE80211_ADDBA_PARAM_TID_MASK)\r\n>> BLOCKACKPARAM_TID_POS;\r\ntid_down = mwifiex_wmm_downgrade_tid(priv, tid);\r\nra_list = mwifiex_wmm_get_ralist_node(priv, tid_down, add_ba_rsp->\r\npeer_mac_addr);\r\nif (le16_to_cpu(add_ba_rsp->status_code) != BA_RESULT_SUCCESS) {\r\nif (ra_list) {\r\nra_list->ba_status = BA_SETUP_NONE;\r\nra_list->amsdu_in_ampdu = false;\r\n}\r\nmwifiex_del_ba_tbl(priv, tid, add_ba_rsp->peer_mac_addr,\r\nTYPE_DELBA_SENT, true);\r\nif (add_ba_rsp->add_rsp_result != BA_RESULT_TIMEOUT)\r\npriv->aggr_prio_tbl[tid].ampdu_ap =\r\nBA_STREAM_NOT_ALLOWED;\r\nreturn 0;\r\n}\r\ntx_ba_tbl = mwifiex_get_ba_tbl(priv, tid, add_ba_rsp->peer_mac_addr);\r\nif (tx_ba_tbl) {\r\nmwifiex_dbg(priv->adapter, EVENT, "info: BA stream complete\n");\r\ntx_ba_tbl->ba_status = BA_SETUP_COMPLETE;\r\nif ((block_ack_param_set & BLOCKACKPARAM_AMSDU_SUPP_MASK) &&\r\npriv->add_ba_param.tx_amsdu &&\r\n(priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\r\ntx_ba_tbl->amsdu = true;\r\nelse\r\ntx_ba_tbl->amsdu = false;\r\nif (ra_list) {\r\nra_list->amsdu_in_ampdu = tx_ba_tbl->amsdu;\r\nra_list->ba_status = BA_SETUP_COMPLETE;\r\n}\r\n} else {\r\nmwifiex_dbg(priv->adapter, ERROR, "BA stream not created\n");\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_cmd_recfg_tx_buf(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd, int cmd_action,\r\nu16 *buf_size)\r\n{\r\nstruct host_cmd_ds_txbuf_cfg *tx_buf = &cmd->params.tx_buf;\r\nu16 action = (u16) cmd_action;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_RECONFIGURE_TX_BUFF);\r\ncmd->size =\r\ncpu_to_le16(sizeof(struct host_cmd_ds_txbuf_cfg) + S_DS_GEN);\r\ntx_buf->action = cpu_to_le16(action);\r\nswitch (action) {\r\ncase HostCmd_ACT_GEN_SET:\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"cmd: set tx_buf=%d\n", *buf_size);\r\ntx_buf->buff_size = cpu_to_le16(*buf_size);\r\nbreak;\r\ncase HostCmd_ACT_GEN_GET:\r\ndefault:\r\ntx_buf->buff_size = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_cmd_amsdu_aggr_ctrl(struct host_cmd_ds_command *cmd,\r\nint cmd_action,\r\nstruct mwifiex_ds_11n_amsdu_aggr_ctrl *aa_ctrl)\r\n{\r\nstruct host_cmd_ds_amsdu_aggr_ctrl *amsdu_ctrl =\r\n&cmd->params.amsdu_aggr_ctrl;\r\nu16 action = (u16) cmd_action;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_AMSDU_AGGR_CTRL);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_amsdu_aggr_ctrl)\r\n+ S_DS_GEN);\r\namsdu_ctrl->action = cpu_to_le16(action);\r\nswitch (action) {\r\ncase HostCmd_ACT_GEN_SET:\r\namsdu_ctrl->enable = cpu_to_le16(aa_ctrl->enable);\r\namsdu_ctrl->curr_buf_size = 0;\r\nbreak;\r\ncase HostCmd_ACT_GEN_GET:\r\ndefault:\r\namsdu_ctrl->curr_buf_size = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_cmd_11n_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd, u16 cmd_action,\r\nstruct mwifiex_ds_11n_tx_cfg *txcfg)\r\n{\r\nstruct host_cmd_ds_11n_cfg *htcfg = &cmd->params.htcfg;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_11N_CFG);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_11n_cfg) + S_DS_GEN);\r\nhtcfg->action = cpu_to_le16(cmd_action);\r\nhtcfg->ht_tx_cap = cpu_to_le16(txcfg->tx_htcap);\r\nhtcfg->ht_tx_info = cpu_to_le16(txcfg->tx_htinfo);\r\nif (priv->adapter->is_hw_11ac_capable)\r\nhtcfg->misc_config = cpu_to_le16(txcfg->misc_config);\r\nreturn 0;\r\n}\r\nint\r\nmwifiex_cmd_append_11n_tlv(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc,\r\nu8 **buffer)\r\n{\r\nstruct mwifiex_ie_types_htcap *ht_cap;\r\nstruct mwifiex_ie_types_htinfo *ht_info;\r\nstruct mwifiex_ie_types_chan_list_param_set *chan_list;\r\nstruct mwifiex_ie_types_2040bssco *bss_co_2040;\r\nstruct mwifiex_ie_types_extcap *ext_cap;\r\nint ret_len = 0;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee_types_header *hdr;\r\nu8 radio_type;\r\nif (!buffer || !*buffer)\r\nreturn ret_len;\r\nradio_type = mwifiex_band_to_radio_type((u8) bss_desc->bss_band);\r\nsband = priv->wdev.wiphy->bands[radio_type];\r\nif (bss_desc->bcn_ht_cap) {\r\nht_cap = (struct mwifiex_ie_types_htcap *) *buffer;\r\nmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\r\nht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\r\nht_cap->header.len =\r\ncpu_to_le16(sizeof(struct ieee80211_ht_cap));\r\nmemcpy((u8 *) ht_cap + sizeof(struct mwifiex_ie_types_header),\r\n(u8 *)bss_desc->bcn_ht_cap,\r\nle16_to_cpu(ht_cap->header.len));\r\nmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\r\n*buffer += sizeof(struct mwifiex_ie_types_htcap);\r\nret_len += sizeof(struct mwifiex_ie_types_htcap);\r\n}\r\nif (bss_desc->bcn_ht_oper) {\r\nif (priv->bss_mode == NL80211_IFTYPE_ADHOC) {\r\nht_info = (struct mwifiex_ie_types_htinfo *) *buffer;\r\nmemset(ht_info, 0,\r\nsizeof(struct mwifiex_ie_types_htinfo));\r\nht_info->header.type =\r\ncpu_to_le16(WLAN_EID_HT_OPERATION);\r\nht_info->header.len =\r\ncpu_to_le16(\r\nsizeof(struct ieee80211_ht_operation));\r\nmemcpy((u8 *) ht_info +\r\nsizeof(struct mwifiex_ie_types_header),\r\n(u8 *)bss_desc->bcn_ht_oper,\r\nle16_to_cpu(ht_info->header.len));\r\nif (!(sband->ht_cap.cap &\r\nIEEE80211_HT_CAP_SUP_WIDTH_20_40))\r\nht_info->ht_oper.ht_param &=\r\n~(IEEE80211_HT_PARAM_CHAN_WIDTH_ANY |\r\nIEEE80211_HT_PARAM_CHA_SEC_OFFSET);\r\n*buffer += sizeof(struct mwifiex_ie_types_htinfo);\r\nret_len += sizeof(struct mwifiex_ie_types_htinfo);\r\n}\r\nchan_list =\r\n(struct mwifiex_ie_types_chan_list_param_set *) *buffer;\r\nmemset(chan_list, 0,\r\nsizeof(struct mwifiex_ie_types_chan_list_param_set));\r\nchan_list->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\r\nchan_list->header.len = cpu_to_le16(\r\nsizeof(struct mwifiex_ie_types_chan_list_param_set) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nchan_list->chan_scan_param[0].chan_number =\r\nbss_desc->bcn_ht_oper->primary_chan;\r\nchan_list->chan_scan_param[0].radio_type =\r\nmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\r\nif (sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&\r\nbss_desc->bcn_ht_oper->ht_param &\r\nIEEE80211_HT_PARAM_CHAN_WIDTH_ANY)\r\nSET_SECONDARYCHAN(chan_list->chan_scan_param[0].\r\nradio_type,\r\n(bss_desc->bcn_ht_oper->ht_param &\r\nIEEE80211_HT_PARAM_CHA_SEC_OFFSET));\r\n*buffer += sizeof(struct mwifiex_ie_types_chan_list_param_set);\r\nret_len += sizeof(struct mwifiex_ie_types_chan_list_param_set);\r\n}\r\nif (bss_desc->bcn_bss_co_2040) {\r\nbss_co_2040 = (struct mwifiex_ie_types_2040bssco *) *buffer;\r\nmemset(bss_co_2040, 0,\r\nsizeof(struct mwifiex_ie_types_2040bssco));\r\nbss_co_2040->header.type = cpu_to_le16(WLAN_EID_BSS_COEX_2040);\r\nbss_co_2040->header.len =\r\ncpu_to_le16(sizeof(bss_co_2040->bss_co_2040));\r\nmemcpy((u8 *) bss_co_2040 +\r\nsizeof(struct mwifiex_ie_types_header),\r\nbss_desc->bcn_bss_co_2040 +\r\nsizeof(struct ieee_types_header),\r\nle16_to_cpu(bss_co_2040->header.len));\r\n*buffer += sizeof(struct mwifiex_ie_types_2040bssco);\r\nret_len += sizeof(struct mwifiex_ie_types_2040bssco);\r\n}\r\nif (bss_desc->bcn_ext_cap) {\r\nhdr = (void *)bss_desc->bcn_ext_cap;\r\next_cap = (struct mwifiex_ie_types_extcap *) *buffer;\r\nmemset(ext_cap, 0, sizeof(struct mwifiex_ie_types_extcap));\r\next_cap->header.type = cpu_to_le16(WLAN_EID_EXT_CAPABILITY);\r\next_cap->header.len = cpu_to_le16(hdr->len);\r\nmemcpy((u8 *)ext_cap->ext_capab,\r\nbss_desc->bcn_ext_cap + sizeof(struct ieee_types_header),\r\nle16_to_cpu(ext_cap->header.len));\r\nif (hdr->len > 3 &&\r\next_cap->ext_capab[3] & WLAN_EXT_CAPA4_INTERWORKING_ENABLED)\r\npriv->hs2_enabled = true;\r\nelse\r\npriv->hs2_enabled = false;\r\n*buffer += sizeof(struct mwifiex_ie_types_extcap) + hdr->len;\r\nret_len += sizeof(struct mwifiex_ie_types_extcap) + hdr->len;\r\n}\r\nreturn ret_len;\r\n}\r\nstatic int mwifiex_is_tx_ba_stream_ptr_valid(struct mwifiex_private *priv,\r\nstruct mwifiex_tx_ba_stream_tbl *tx_tbl_ptr)\r\n{\r\nstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl;\r\nlist_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {\r\nif (tx_ba_tsr_tbl == tx_tbl_ptr)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid mwifiex_11n_delete_tx_ba_stream_tbl_entry(struct mwifiex_private *priv,\r\nstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl)\r\n{\r\nif (!tx_ba_tsr_tbl &&\r\nmwifiex_is_tx_ba_stream_ptr_valid(priv, tx_ba_tsr_tbl))\r\nreturn;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: tx_ba_tsr_tbl %p\n", tx_ba_tsr_tbl);\r\nlist_del(&tx_ba_tsr_tbl->list);\r\nkfree(tx_ba_tsr_tbl);\r\n}\r\nvoid mwifiex_11n_delete_all_tx_ba_stream_tbl(struct mwifiex_private *priv)\r\n{\r\nint i;\r\nstruct mwifiex_tx_ba_stream_tbl *del_tbl_ptr, *tmp_node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);\r\nlist_for_each_entry_safe(del_tbl_ptr, tmp_node,\r\n&priv->tx_ba_stream_tbl_ptr, list)\r\nmwifiex_11n_delete_tx_ba_stream_tbl_entry(priv, del_tbl_ptr);\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock, flags);\r\nINIT_LIST_HEAD(&priv->tx_ba_stream_tbl_ptr);\r\nfor (i = 0; i < MAX_NUM_TID; ++i)\r\npriv->aggr_prio_tbl[i].ampdu_ap =\r\npriv->aggr_prio_tbl[i].ampdu_user;\r\n}\r\nstruct mwifiex_tx_ba_stream_tbl *\r\nmwifiex_get_ba_tbl(struct mwifiex_private *priv, int tid, u8 *ra)\r\n{\r\nstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);\r\nlist_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {\r\nif (ether_addr_equal_unaligned(tx_ba_tsr_tbl->ra, ra) &&\r\ntx_ba_tsr_tbl->tid == tid) {\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock,\r\nflags);\r\nreturn tx_ba_tsr_tbl;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock, flags);\r\nreturn NULL;\r\n}\r\nvoid mwifiex_create_ba_tbl(struct mwifiex_private *priv, u8 *ra, int tid,\r\nenum mwifiex_ba_status ba_status)\r\n{\r\nstruct mwifiex_tx_ba_stream_tbl *new_node;\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nunsigned long flags;\r\nint tid_down;\r\nif (!mwifiex_get_ba_tbl(priv, tid, ra)) {\r\nnew_node = kzalloc(sizeof(struct mwifiex_tx_ba_stream_tbl),\r\nGFP_ATOMIC);\r\nif (!new_node)\r\nreturn;\r\ntid_down = mwifiex_wmm_downgrade_tid(priv, tid);\r\nra_list = mwifiex_wmm_get_ralist_node(priv, tid_down, ra);\r\nif (ra_list) {\r\nra_list->ba_status = ba_status;\r\nra_list->amsdu_in_ampdu = false;\r\n}\r\nINIT_LIST_HEAD(&new_node->list);\r\nnew_node->tid = tid;\r\nnew_node->ba_status = ba_status;\r\nmemcpy(new_node->ra, ra, ETH_ALEN);\r\nspin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);\r\nlist_add_tail(&new_node->list, &priv->tx_ba_stream_tbl_ptr);\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock, flags);\r\n}\r\n}\r\nint mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\r\n{\r\nstruct host_cmd_ds_11n_addba_req add_ba_req;\r\nu32 tx_win_size = priv->add_ba_param.tx_win_size;\r\nstatic u8 dialog_tok;\r\nint ret;\r\nunsigned long flags;\r\nu16 block_ack_param_set;\r\nmwifiex_dbg(priv->adapter, CMD, "cmd: %s: tid %d\n", __func__, tid);\r\nif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\r\nISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\r\npriv->adapter->is_hw_11ac_capable &&\r\nmemcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\r\nstruct mwifiex_sta_node *sta_ptr;\r\nspin_lock_irqsave(&priv->sta_list_spinlock, flags);\r\nsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\r\nif (!sta_ptr) {\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"BA setup with unknown TDLS peer %pM!\n",\r\npeer_mac);\r\nreturn -1;\r\n}\r\nif (sta_ptr->is_11ac_enabled)\r\ntx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\n}\r\nblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\r\ntx_win_size << BLOCKACKPARAM_WINSIZE_POS |\r\nIMMEDIATE_BLOCK_ACK);\r\nif (priv->add_ba_param.tx_amsdu &&\r\n(priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\r\nblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\r\nadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\r\nadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\r\n++dialog_tok;\r\nif (dialog_tok == 0)\r\ndialog_tok = 1;\r\nadd_ba_req.dialog_token = dialog_tok;\r\nmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\r\n0, 0, &add_ba_req, false);\r\nreturn ret;\r\n}\r\nint mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\r\nint initiator)\r\n{\r\nstruct host_cmd_ds_11n_delba delba;\r\nint ret;\r\nuint16_t del_ba_param_set;\r\nmemset(&delba, 0, sizeof(delba));\r\ndelba.del_ba_param_set = cpu_to_le16(tid << DELBA_TID_POS);\r\ndel_ba_param_set = le16_to_cpu(delba.del_ba_param_set);\r\nif (initiator)\r\ndel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\r\nelse\r\ndel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\r\nmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\r\nret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\r\nHostCmd_ACT_GEN_SET, 0, &delba, false);\r\nreturn ret;\r\n}\r\nvoid mwifiex_11n_delba(struct mwifiex_private *priv, int tid)\r\n{\r\nstruct mwifiex_rx_reorder_tbl *rx_reor_tbl_ptr;\r\nif (list_empty(&priv->rx_reorder_tbl_ptr)) {\r\ndev_dbg(priv->adapter->dev,\r\n"mwifiex_11n_delba: rx_reorder_tbl_ptr empty\n");\r\nreturn;\r\n}\r\nlist_for_each_entry(rx_reor_tbl_ptr, &priv->rx_reorder_tbl_ptr, list) {\r\nif (rx_reor_tbl_ptr->tid == tid) {\r\ndev_dbg(priv->adapter->dev,\r\n"Send delba to tid=%d, %pM\n",\r\ntid, rx_reor_tbl_ptr->ta);\r\nmwifiex_send_delba(priv, tid, rx_reor_tbl_ptr->ta, 0);\r\nreturn;\r\n}\r\n}\r\n}\r\nvoid mwifiex_11n_delete_ba_stream(struct mwifiex_private *priv, u8 *del_ba)\r\n{\r\nstruct host_cmd_ds_11n_delba *cmd_del_ba =\r\n(struct host_cmd_ds_11n_delba *) del_ba;\r\nuint16_t del_ba_param_set = le16_to_cpu(cmd_del_ba->del_ba_param_set);\r\nint tid;\r\ntid = del_ba_param_set >> DELBA_TID_POS;\r\nmwifiex_del_ba_tbl(priv, tid, cmd_del_ba->peer_mac_addr,\r\nTYPE_DELBA_RECEIVE, INITIATOR_BIT(del_ba_param_set));\r\n}\r\nint mwifiex_get_rx_reorder_tbl(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_rx_reorder_tbl *buf)\r\n{\r\nint i;\r\nstruct mwifiex_ds_rx_reorder_tbl *rx_reo_tbl = buf;\r\nstruct mwifiex_rx_reorder_tbl *rx_reorder_tbl_ptr;\r\nint count = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\nlist_for_each_entry(rx_reorder_tbl_ptr, &priv->rx_reorder_tbl_ptr,\r\nlist) {\r\nrx_reo_tbl->tid = (u16) rx_reorder_tbl_ptr->tid;\r\nmemcpy(rx_reo_tbl->ta, rx_reorder_tbl_ptr->ta, ETH_ALEN);\r\nrx_reo_tbl->start_win = rx_reorder_tbl_ptr->start_win;\r\nrx_reo_tbl->win_size = rx_reorder_tbl_ptr->win_size;\r\nfor (i = 0; i < rx_reorder_tbl_ptr->win_size; ++i) {\r\nif (rx_reorder_tbl_ptr->rx_reorder_ptr[i])\r\nrx_reo_tbl->buffer[i] = true;\r\nelse\r\nrx_reo_tbl->buffer[i] = false;\r\n}\r\nrx_reo_tbl++;\r\ncount++;\r\nif (count >= MWIFIEX_MAX_RX_BASTREAM_SUPPORTED)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, flags);\r\nreturn count;\r\n}\r\nint mwifiex_get_tx_ba_stream_tbl(struct mwifiex_private *priv,\r\nstruct mwifiex_ds_tx_ba_stream_tbl *buf)\r\n{\r\nstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl;\r\nstruct mwifiex_ds_tx_ba_stream_tbl *rx_reo_tbl = buf;\r\nint count = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);\r\nlist_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {\r\nrx_reo_tbl->tid = (u16) tx_ba_tsr_tbl->tid;\r\nmwifiex_dbg(priv->adapter, DATA, "data: %s tid=%d\n",\r\n__func__, rx_reo_tbl->tid);\r\nmemcpy(rx_reo_tbl->ra, tx_ba_tsr_tbl->ra, ETH_ALEN);\r\nrx_reo_tbl->amsdu = tx_ba_tsr_tbl->amsdu;\r\nrx_reo_tbl++;\r\ncount++;\r\nif (count >= MWIFIEX_MAX_TX_BASTREAM_SUPPORTED)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock, flags);\r\nreturn count;\r\n}\r\nvoid mwifiex_del_tx_ba_stream_tbl_by_ra(struct mwifiex_private *priv, u8 *ra)\r\n{\r\nstruct mwifiex_tx_ba_stream_tbl *tbl, *tmp;\r\nunsigned long flags;\r\nif (!ra)\r\nreturn;\r\nspin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);\r\nlist_for_each_entry_safe(tbl, tmp, &priv->tx_ba_stream_tbl_ptr, list) {\r\nif (!memcmp(tbl->ra, ra, ETH_ALEN)) {\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock,\r\nflags);\r\nmwifiex_11n_delete_tx_ba_stream_tbl_entry(priv, tbl);\r\nspin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock, flags);\r\nreturn;\r\n}\r\nvoid mwifiex_set_ba_params(struct mwifiex_private *priv)\r\n{\r\npriv->add_ba_param.timeout = MWIFIEX_DEFAULT_BLOCK_ACK_TIMEOUT;\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\r\npriv->add_ba_param.tx_win_size =\r\nMWIFIEX_UAP_AMPDU_DEF_TXWINSIZE;\r\npriv->add_ba_param.rx_win_size =\r\nMWIFIEX_UAP_AMPDU_DEF_RXWINSIZE;\r\n} else {\r\npriv->add_ba_param.tx_win_size =\r\nMWIFIEX_STA_AMPDU_DEF_TXWINSIZE;\r\npriv->add_ba_param.rx_win_size =\r\nMWIFIEX_STA_AMPDU_DEF_RXWINSIZE;\r\n}\r\npriv->add_ba_param.tx_amsdu = true;\r\npriv->add_ba_param.rx_amsdu = true;\r\nreturn;\r\n}\r\nu8 mwifiex_get_sec_chan_offset(int chan)\r\n{\r\nu8 sec_offset;\r\nswitch (chan) {\r\ncase 36:\r\ncase 44:\r\ncase 52:\r\ncase 60:\r\ncase 100:\r\ncase 108:\r\ncase 116:\r\ncase 124:\r\ncase 132:\r\ncase 140:\r\ncase 149:\r\ncase 157:\r\nsec_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\r\nbreak;\r\ncase 40:\r\ncase 48:\r\ncase 56:\r\ncase 64:\r\ncase 104:\r\ncase 112:\r\ncase 120:\r\ncase 128:\r\ncase 136:\r\ncase 144:\r\ncase 153:\r\ncase 161:\r\nsec_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\r\nbreak;\r\ncase 165:\r\ndefault:\r\nsec_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\r\nbreak;\r\n}\r\nreturn sec_offset;\r\n}\r\nstatic void\r\nmwifiex_send_delba_txbastream_tbl(struct mwifiex_private *priv, u8 tid)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_tx_ba_stream_tbl *tx_ba_stream_tbl_ptr;\r\nif (list_empty(&priv->tx_ba_stream_tbl_ptr))\r\nreturn;\r\nlist_for_each_entry(tx_ba_stream_tbl_ptr,\r\n&priv->tx_ba_stream_tbl_ptr, list) {\r\nif (tx_ba_stream_tbl_ptr->ba_status == BA_SETUP_COMPLETE) {\r\nif (tid == tx_ba_stream_tbl_ptr->tid) {\r\ndev_dbg(adapter->dev,\r\n"Tx:Send delba to tid=%d, %pM\n", tid,\r\ntx_ba_stream_tbl_ptr->ra);\r\nmwifiex_send_delba(priv,\r\ntx_ba_stream_tbl_ptr->tid,\r\ntx_ba_stream_tbl_ptr->ra, 1);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nvoid mwifiex_update_ampdu_txwinsize(struct mwifiex_adapter *adapter)\r\n{\r\nu8 i;\r\nu32 tx_win_size;\r\nstruct mwifiex_private *priv;\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\nif (!adapter->priv[i])\r\ncontinue;\r\npriv = adapter->priv[i];\r\ntx_win_size = priv->add_ba_param.tx_win_size;\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_STA)\r\npriv->add_ba_param.tx_win_size =\r\nMWIFIEX_STA_AMPDU_DEF_TXWINSIZE;\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_P2P)\r\npriv->add_ba_param.tx_win_size =\r\nMWIFIEX_STA_AMPDU_DEF_TXWINSIZE;\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_UAP)\r\npriv->add_ba_param.tx_win_size =\r\nMWIFIEX_UAP_AMPDU_DEF_TXWINSIZE;\r\nif (adapter->coex_win_size) {\r\nif (adapter->coex_tx_win_size)\r\npriv->add_ba_param.tx_win_size =\r\nadapter->coex_tx_win_size;\r\n}\r\nif (tx_win_size != priv->add_ba_param.tx_win_size) {\r\nif (!priv->media_connected)\r\ncontinue;\r\nfor (i = 0; i < MAX_NUM_TID; i++)\r\nmwifiex_send_delba_txbastream_tbl(priv, i);\r\n}\r\n}\r\n}
