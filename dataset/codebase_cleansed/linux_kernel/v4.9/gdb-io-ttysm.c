void __init gdbstub_io_init(void)\r\n{\r\nuint16_t scxctr;\r\nint tmp;\r\nswitch (gdbstub_port->clock_src) {\r\ncase MNSCx_CLOCK_SRC_IOCLK:\r\ngdbstub_port->ioclk = MN10300_IOCLK;\r\nbreak;\r\n#ifdef MN10300_IOBCLK\r\ncase MNSCx_CLOCK_SRC_IOBCLK:\r\ngdbstub_port->ioclk = MN10300_IOBCLK;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\ngdbstub_io_set_baud(115200);\r\nset_intr_level(gdbstub_port->rx_irq,\r\nNUM2GxICR_LEVEL(CONFIG_DEBUGGER_IRQ_LEVEL));\r\nset_intr_level(gdbstub_port->tx_irq,\r\nNUM2GxICR_LEVEL(CONFIG_DEBUGGER_IRQ_LEVEL));\r\nset_intr_stub(NUM2EXCEP_IRQ_LEVEL(CONFIG_DEBUGGER_IRQ_LEVEL),\r\ngdbstub_io_rx_handler);\r\n*gdbstub_port->rx_icr |= GxICR_ENABLE;\r\ntmp = *gdbstub_port->rx_icr;\r\nscxctr = SC01CTR_CLN_8BIT;\r\nswitch (gdbstub_port->div_timer) {\r\ncase MNSCx_DIV_TIMER_16BIT:\r\nscxctr |= SC0CTR_CK_TM8UFLOW_8;\r\nbreak;\r\ncase MNSCx_DIV_TIMER_8BIT:\r\nscxctr |= SC0CTR_CK_TM2UFLOW_8;\r\nbreak;\r\n}\r\nscxctr |= SC01CTR_TXE | SC01CTR_RXE;\r\n*gdbstub_port->_control = scxctr;\r\ntmp = *gdbstub_port->_control;\r\narch_local_change_intr_mask_level(\r\nNUM2EPSW_IM(CONFIG_DEBUGGER_IRQ_LEVEL + 1));\r\n}\r\nvoid gdbstub_io_set_baud(unsigned baud)\r\n{\r\nconst unsigned bits = 10;\r\nunsigned long ioclk = gdbstub_port->ioclk;\r\nunsigned xdiv, tmp;\r\nuint16_t tmxbr;\r\nuint8_t tmxmd;\r\nif (!baud) {\r\nbaud = 9600;\r\n} else if (baud == 134) {\r\nbaud = 269;\r\nxdiv = 2;\r\n}\r\ntry_alternative:\r\nxdiv = 1;\r\nswitch (gdbstub_port->div_timer) {\r\ncase MNSCx_DIV_TIMER_16BIT:\r\ntmxmd = TM8MD_SRC_IOCLK;\r\ntmxbr = tmp = (ioclk / (baud * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 65535)\r\ngoto timer_okay;\r\ntmxmd = TM8MD_SRC_IOCLK_8;\r\ntmxbr = tmp = (ioclk / (baud * 8 * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 65535)\r\ngoto timer_okay;\r\ntmxmd = TM8MD_SRC_IOCLK_32;\r\ntmxbr = tmp = (ioclk / (baud * 32 * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 65535)\r\ngoto timer_okay;\r\nbreak;\r\ncase MNSCx_DIV_TIMER_8BIT:\r\ntmxmd = TM2MD_SRC_IOCLK;\r\ntmxbr = tmp = (ioclk / (baud * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 255)\r\ngoto timer_okay;\r\ntmxmd = TM2MD_SRC_IOCLK_8;\r\ntmxbr = tmp = (ioclk / (baud * 8 * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 255)\r\ngoto timer_okay;\r\ntmxmd = TM2MD_SRC_IOCLK_32;\r\ntmxbr = tmp = (ioclk / (baud * 32 * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 255)\r\ngoto timer_okay;\r\nbreak;\r\n}\r\nbaud = 9600;\r\ngoto try_alternative;\r\ntimer_okay:\r\ngdbstub_port->uart.timeout = (2 * bits * HZ) / baud;\r\ngdbstub_port->uart.timeout += HZ / 50;\r\nswitch (gdbstub_port->div_timer) {\r\ncase MNSCx_DIV_TIMER_16BIT:\r\n*gdbstub_port->_tmxmd = 0;\r\n*gdbstub_port->_tmxbr = tmxbr;\r\n*gdbstub_port->_tmxmd = TM8MD_INIT_COUNTER;\r\n*gdbstub_port->_tmxmd = tmxmd | TM8MD_COUNT_ENABLE;\r\nbreak;\r\ncase MNSCx_DIV_TIMER_8BIT:\r\n*gdbstub_port->_tmxmd = 0;\r\n*(volatile u8 *) gdbstub_port->_tmxbr = (u8)tmxbr;\r\n*gdbstub_port->_tmxmd = TM2MD_INIT_COUNTER;\r\n*gdbstub_port->_tmxmd = tmxmd | TM2MD_COUNT_ENABLE;\r\nbreak;\r\n}\r\n}\r\nint gdbstub_io_rx_char(unsigned char *_ch, int nonblock)\r\n{\r\nunsigned ix;\r\nu8 ch, st;\r\n#if defined(CONFIG_MN10300_WD_TIMER)\r\nint cpu;\r\n#endif\r\n*_ch = 0xff;\r\nif (gdbstub_rx_unget) {\r\n*_ch = gdbstub_rx_unget;\r\ngdbstub_rx_unget = 0;\r\nreturn 0;\r\n}\r\ntry_again:\r\nix = gdbstub_rx_outp;\r\nbarrier();\r\nif (ix == gdbstub_rx_inp) {\r\nif (nonblock)\r\nreturn -EAGAIN;\r\n#ifdef CONFIG_MN10300_WD_TIMER\r\nfor (cpu = 0; cpu < NR_CPUS; cpu++)\r\nwatchdog_alert_counter[cpu] = 0;\r\n#endif\r\ngoto try_again;\r\n}\r\nch = gdbstub_rx_buffer[ix++];\r\nst = gdbstub_rx_buffer[ix++];\r\nbarrier();\r\ngdbstub_rx_outp = ix & (PAGE_SIZE - 1);\r\nst &= SC01STR_RXF | SC01STR_RBF | SC01STR_FEF | SC01STR_PEF |\r\nSC01STR_OEF;\r\nif (st & SC01STR_FEF && ch == 0) {\r\nswitch (gdbstub_port->rx_brk) {\r\ncase 0: gdbstub_port->rx_brk = 1; goto try_again;\r\ncase 1: gdbstub_port->rx_brk = 2; goto try_again;\r\ncase 2:\r\ngdbstub_port->rx_brk = 3;\r\ngdbstub_proto("### GDB MNSERIAL Rx Break Detected"\r\n" ###\n");\r\nreturn -EINTR;\r\ndefault:\r\ngoto try_again;\r\n}\r\n} else if (st & SC01STR_FEF) {\r\nif (gdbstub_port->rx_brk)\r\ngoto try_again;\r\ngdbstub_proto("### GDB MNSERIAL Framing Error ###\n");\r\nreturn -EIO;\r\n} else if (st & SC01STR_OEF) {\r\nif (gdbstub_port->rx_brk)\r\ngoto try_again;\r\ngdbstub_proto("### GDB MNSERIAL Overrun Error ###\n");\r\nreturn -EIO;\r\n} else if (st & SC01STR_PEF) {\r\nif (gdbstub_port->rx_brk)\r\ngoto try_again;\r\ngdbstub_proto("### GDB MNSERIAL Parity Error ###\n");\r\nreturn -EIO;\r\n} else {\r\nif (gdbstub_port->rx_brk == 3) {\r\nswitch (ch) {\r\ncase 0xFF:\r\ncase 0xFE:\r\ncase 0xFC:\r\ncase 0xF8:\r\ncase 0xF0:\r\ncase 0xE0:\r\ncase 0xC0:\r\ncase 0x80:\r\ncase 0x00:\r\ngdbstub_port->rx_brk = 0;\r\ngoto try_again;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ngdbstub_port->rx_brk = 0;\r\ngdbstub_io("### GDB Rx %02x (st=%02x) ###\n", ch, st);\r\n*_ch = ch & 0x7f;\r\nreturn 0;\r\n}\r\n}\r\nvoid gdbstub_io_tx_char(unsigned char ch)\r\n{\r\nwhile (*gdbstub_port->_status & SC01STR_TBF)\r\ncontinue;\r\nif (ch == 0x0a) {\r\n*(u8 *) gdbstub_port->_txb = 0x0d;\r\nwhile (*gdbstub_port->_status & SC01STR_TBF)\r\ncontinue;\r\n}\r\n*(u8 *) gdbstub_port->_txb = ch;\r\n}\r\nvoid gdbstub_io_tx_flush(void)\r\n{\r\nwhile (*gdbstub_port->_status & (SC01STR_TBF | SC01STR_TXF))\r\ncontinue;\r\n}
