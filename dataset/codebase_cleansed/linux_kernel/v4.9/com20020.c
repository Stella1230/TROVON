static void com20020_copy_from_card(struct net_device *dev, int bufnum,\r\nint offset, void *buf, int count)\r\n{\r\nint ioaddr = dev->base_addr, ofs = 512 * bufnum + offset;\r\narcnet_outb((ofs >> 8) | RDDATAflag | AUTOINCflag,\r\nioaddr, COM20020_REG_W_ADDR_HI);\r\narcnet_outb(ofs & 0xff, ioaddr, COM20020_REG_W_ADDR_LO);\r\nTIME(dev, "insb", count,\r\narcnet_insb(ioaddr, COM20020_REG_RW_MEMDATA, buf, count));\r\n}\r\nstatic void com20020_copy_to_card(struct net_device *dev, int bufnum,\r\nint offset, void *buf, int count)\r\n{\r\nint ioaddr = dev->base_addr, ofs = 512 * bufnum + offset;\r\narcnet_outb((ofs >> 8) | AUTOINCflag, ioaddr, COM20020_REG_W_ADDR_HI);\r\narcnet_outb(ofs & 0xff, ioaddr, COM20020_REG_W_ADDR_LO);\r\nTIME(dev, "outsb", count,\r\narcnet_outsb(ioaddr, COM20020_REG_RW_MEMDATA, buf, count));\r\n}\r\nint com20020_check(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr, status;\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\narcnet_outb(XTOcfg(3) | RESETcfg, ioaddr, COM20020_REG_W_CONFIG);\r\nudelay(5);\r\narcnet_outb(XTOcfg(3), ioaddr, COM20020_REG_W_CONFIG);\r\nmdelay(RESETtime);\r\nlp->setup = lp->clockm ? 0 : (lp->clockp << 1);\r\nlp->setup2 = (lp->clockm << 4) | 8;\r\nlp->setup = lp->setup | P1MODE;\r\ncom20020_set_subaddress(lp, ioaddr, SUB_SETUP1);\r\narcnet_outb(lp->setup, ioaddr, COM20020_REG_W_XREG);\r\nif (lp->clockm != 0) {\r\ncom20020_set_subaddress(lp, ioaddr, SUB_SETUP2);\r\narcnet_outb(lp->setup2, ioaddr, COM20020_REG_W_XREG);\r\nmdelay(1);\r\narcnet_outb(STARTIOcmd, ioaddr, COM20020_REG_W_COMMAND);\r\n}\r\nlp->config = (lp->timeout << 3) | (lp->backplane << 2) | SUB_NODE;\r\narcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\r\narcnet_outb(0x42, ioaddr, COM20020_REG_W_XREG);\r\nstatus = arcnet_inb(ioaddr, COM20020_REG_R_STATUS);\r\nif ((status & 0x99) != (NORXflag | TXFREEflag | RESETflag)) {\r\narc_printk(D_NORMAL, dev, "status invalid (%Xh).\n", status);\r\nreturn -ENODEV;\r\n}\r\narc_printk(D_INIT_REASONS, dev, "status after reset: %X\n", status);\r\narcnet_outb(CFLAGScmd | RESETclear | CONFIGclear,\r\nioaddr, COM20020_REG_W_COMMAND);\r\nstatus = arcnet_inb(ioaddr, COM20020_REG_R_STATUS);\r\narc_printk(D_INIT_REASONS, dev, "status after reset acknowledged: %X\n",\r\nstatus);\r\narcnet_outb(0 | RDDATAflag | AUTOINCflag,\r\nioaddr, COM20020_REG_W_ADDR_HI);\r\narcnet_outb(0, ioaddr, COM20020_REG_W_ADDR_LO);\r\nstatus = arcnet_inb(ioaddr, COM20020_REG_RW_MEMDATA);\r\nif (status != TESTvalue) {\r\narc_printk(D_NORMAL, dev, "Signature byte not found (%02Xh != D1h).\n",\r\nstatus);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int com20020_set_hwaddr(struct net_device *dev, void *addr)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct sockaddr *hwaddr = addr;\r\nmemcpy(dev->dev_addr, hwaddr->sa_data, 1);\r\ncom20020_set_subaddress(lp, ioaddr, SUB_NODE);\r\narcnet_outb(dev->dev_addr[0], ioaddr, COM20020_REG_W_XREG);\r\nreturn 0;\r\n}\r\nstatic int com20020_netdev_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nlp->config |= TXENcfg;\r\narcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\r\nreturn arcnet_open(dev);\r\n}\r\nstatic int com20020_netdev_close(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\narcnet_close(dev);\r\nlp->config &= ~TXENcfg;\r\narcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\r\nreturn 0;\r\n}\r\nint com20020_found(struct net_device *dev, int shared)\r\n{\r\nstruct arcnet_local *lp;\r\nint ioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nlp->hw.owner = THIS_MODULE;\r\nlp->hw.command = com20020_command;\r\nlp->hw.status = com20020_status;\r\nlp->hw.intmask = com20020_setmask;\r\nlp->hw.reset = com20020_reset;\r\nlp->hw.copy_to_card = com20020_copy_to_card;\r\nlp->hw.copy_from_card = com20020_copy_from_card;\r\nlp->hw.close = com20020_close;\r\nif (!dev->dev_addr[0])\r\ndev->dev_addr[0] = arcnet_inb(ioaddr, 8);\r\ncom20020_set_subaddress(lp, ioaddr, SUB_SETUP1);\r\narcnet_outb(lp->setup, ioaddr, COM20020_REG_W_XREG);\r\nif (lp->card_flags & ARC_CAN_10MBIT) {\r\ncom20020_set_subaddress(lp, ioaddr, SUB_SETUP2);\r\narcnet_outb(lp->setup2, ioaddr, COM20020_REG_W_XREG);\r\nmdelay(1);\r\narcnet_outb(STARTIOcmd, ioaddr, COM20020_REG_W_COMMAND);\r\n}\r\nlp->config = (lp->timeout << 3) | (lp->backplane << 2) | SUB_NODE;\r\narcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\r\narcnet_outb(dev->dev_addr[0], ioaddr, COM20020_REG_W_XREG);\r\nif (request_irq(dev->irq, arcnet_interrupt, shared,\r\n"arcnet (COM20020)", dev)) {\r\narc_printk(D_NORMAL, dev, "Can't get IRQ %d!\n", dev->irq);\r\nreturn -ENODEV;\r\n}\r\ndev->base_addr = ioaddr;\r\narc_printk(D_NORMAL, dev, "%s: station %02Xh found at %03lXh, IRQ %d.\n",\r\nlp->card_name, dev->dev_addr[0], dev->base_addr, dev->irq);\r\nif (lp->backplane)\r\narc_printk(D_NORMAL, dev, "Using backplane mode.\n");\r\nif (lp->timeout != 3)\r\narc_printk(D_NORMAL, dev, "Using extended timeout value of %d\n",\r\nlp->timeout);\r\narc_printk(D_NORMAL, dev, "Using CKP %d - data rate %s\n",\r\nlp->setup >> 1,\r\nclockrates[3 -\r\n((lp->setup2 & 0xF0) >> 4) +\r\n((lp->setup & 0x0F) >> 1)]);\r\nif (register_netdev(dev)) {\r\nfree_irq(dev->irq, dev);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int com20020_reset(struct net_device *dev, int really_reset)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nu_int ioaddr = dev->base_addr;\r\nu_char inbyte;\r\narc_printk(D_DEBUG, dev, "%s: %d: %s: dev: %p, lp: %p, dev->name: %s\n",\r\n__FILE__, __LINE__, __func__, dev, lp, dev->name);\r\narc_printk(D_INIT, dev, "Resetting %s (status=%02Xh)\n",\r\ndev->name, arcnet_inb(ioaddr, COM20020_REG_R_STATUS));\r\narc_printk(D_DEBUG, dev, "%s: %d: %s\n", __FILE__, __LINE__, __func__);\r\nlp->config |= (lp->timeout << 3) | (lp->backplane << 2);\r\narcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\r\narc_printk(D_DEBUG, dev, "%s: %d: %s\n", __FILE__, __LINE__, __func__);\r\nif (really_reset) {\r\narcnet_outb(lp->config | RESETcfg, ioaddr, COM20020_REG_W_CONFIG);\r\nudelay(5);\r\narcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\r\nmdelay(RESETtime * 2);\r\n}\r\narc_printk(D_DEBUG, dev, "%s: %d: %s\n", __FILE__, __LINE__, __func__);\r\narcnet_outb(CFLAGScmd | RESETclear | CONFIGclear,\r\nioaddr, COM20020_REG_W_COMMAND);\r\narc_printk(D_DEBUG, dev, "%s: %d: %s\n", __FILE__, __LINE__, __func__);\r\ncom20020_copy_from_card(dev, 0, 0, &inbyte, 1);\r\narc_printk(D_DEBUG, dev, "%s: %d: %s\n", __FILE__, __LINE__, __func__);\r\nif (inbyte != TESTvalue) {\r\narc_printk(D_DEBUG, dev, "%s: %d: %s\n",\r\n__FILE__, __LINE__, __func__);\r\narc_printk(D_NORMAL, dev, "reset failed: TESTvalue not present.\n");\r\nreturn 1;\r\n}\r\narcnet_outb(CONFIGcmd | EXTconf, ioaddr, COM20020_REG_W_COMMAND);\r\narc_printk(D_DEBUG, dev, "%s: %d: %s\n", __FILE__, __LINE__, __func__);\r\nreturn 0;\r\n}\r\nstatic void com20020_setmask(struct net_device *dev, int mask)\r\n{\r\nu_int ioaddr = dev->base_addr;\r\narc_printk(D_DURING, dev, "Setting mask to %x at %x\n", mask, ioaddr);\r\narcnet_outb(mask, ioaddr, COM20020_REG_W_INTMASK);\r\n}\r\nstatic void com20020_command(struct net_device *dev, int cmd)\r\n{\r\nu_int ioaddr = dev->base_addr;\r\narcnet_outb(cmd, ioaddr, COM20020_REG_W_COMMAND);\r\n}\r\nstatic int com20020_status(struct net_device *dev)\r\n{\r\nu_int ioaddr = dev->base_addr;\r\nreturn arcnet_inb(ioaddr, COM20020_REG_R_STATUS) +\r\n(arcnet_inb(ioaddr, COM20020_REG_R_DIAGSTAT) << 8);\r\n}\r\nstatic void com20020_close(struct net_device *dev)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nlp->config &= ~TXENcfg;\r\narcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\r\n}\r\nstatic void com20020_set_mc_list(struct net_device *dev)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif ((dev->flags & IFF_PROMISC) && (dev->flags & IFF_UP)) {\r\nif (!(lp->setup & PROMISCset))\r\narc_printk(D_NORMAL, dev, "Setting promiscuous flag...\n");\r\ncom20020_set_subaddress(lp, ioaddr, SUB_SETUP1);\r\nlp->setup |= PROMISCset;\r\narcnet_outb(lp->setup, ioaddr, COM20020_REG_W_XREG);\r\n} else {\r\nif ((lp->setup & PROMISCset))\r\narc_printk(D_NORMAL, dev, "Resetting promiscuous flag...\n");\r\ncom20020_set_subaddress(lp, ioaddr, SUB_SETUP1);\r\nlp->setup &= ~PROMISCset;\r\narcnet_outb(lp->setup, ioaddr, COM20020_REG_W_XREG);\r\n}\r\n}\r\nstatic int __init com20020_module_init(void)\r\n{\r\nif (BUGLVL(D_NORMAL))\r\npr_info("%s\n", "COM20020 chipset support (by David Woodhouse et al.)");\r\nreturn 0;\r\n}\r\nstatic void __exit com20020_module_exit(void)\r\n{\r\n}
