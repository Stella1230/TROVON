static inline u32 pctl_readl(struct pistachio_pinctrl *pctl, u32 reg)\r\n{\r\nreturn readl(pctl->base + reg);\r\n}\r\nstatic inline void pctl_writel(struct pistachio_pinctrl *pctl, u32 val, u32 reg)\r\n{\r\nwritel(val, pctl->base + reg);\r\n}\r\nstatic inline struct pistachio_gpio_bank *irqd_to_bank(struct irq_data *d)\r\n{\r\nreturn gpiochip_get_data(irq_data_get_irq_chip_data(d));\r\n}\r\nstatic inline u32 gpio_readl(struct pistachio_gpio_bank *bank, u32 reg)\r\n{\r\nreturn readl(bank->base + reg);\r\n}\r\nstatic inline void gpio_writel(struct pistachio_gpio_bank *bank, u32 val,\r\nu32 reg)\r\n{\r\nwritel(val, bank->base + reg);\r\n}\r\nstatic inline void gpio_mask_writel(struct pistachio_gpio_bank *bank,\r\nu32 reg, unsigned int bit, u32 val)\r\n{\r\ngpio_writel(bank, (0x10000 | val) << bit, reg);\r\n}\r\nstatic inline void gpio_enable(struct pistachio_gpio_bank *bank,\r\nunsigned offset)\r\n{\r\ngpio_mask_writel(bank, GPIO_BIT_EN, offset, 1);\r\n}\r\nstatic inline void gpio_disable(struct pistachio_gpio_bank *bank,\r\nunsigned offset)\r\n{\r\ngpio_mask_writel(bank, GPIO_BIT_EN, offset, 0);\r\n}\r\nstatic int pistachio_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->ngroups;\r\n}\r\nstatic const char *pistachio_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->groups[group].name;\r\n}\r\nstatic int pistachio_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &pctl->groups[group].pin;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int pistachio_pinmux_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->nfunctions;\r\n}\r\nstatic const char *\r\npistachio_pinmux_get_function_name(struct pinctrl_dev *pctldev, unsigned func)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->functions[func].name;\r\n}\r\nstatic int pistachio_pinmux_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned func,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctl->functions[func].groups;\r\n*num_groups = pctl->functions[func].ngroups;\r\nreturn 0;\r\n}\r\nstatic int pistachio_pinmux_enable(struct pinctrl_dev *pctldev,\r\nunsigned func, unsigned group)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct pistachio_pin_group *pg = &pctl->groups[group];\r\nconst struct pistachio_function *pf = &pctl->functions[func];\r\nstruct pinctrl_gpio_range *range;\r\nunsigned int i;\r\nu32 val;\r\nif (pg->mux_reg > 0) {\r\nfor (i = 0; i < ARRAY_SIZE(pg->mux_option); i++) {\r\nif (pg->mux_option[i] == func)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(pg->mux_option)) {\r\ndev_err(pctl->dev, "Cannot mux pin %u to function %u\n",\r\ngroup, func);\r\nreturn -EINVAL;\r\n}\r\nval = pctl_readl(pctl, pg->mux_reg);\r\nval &= ~(pg->mux_mask << pg->mux_shift);\r\nval |= i << pg->mux_shift;\r\npctl_writel(pctl, val, pg->mux_reg);\r\nif (pf->scenarios) {\r\nfor (i = 0; i < pf->nscenarios; i++) {\r\nif (pf->scenarios[i] == group)\r\nbreak;\r\n}\r\nif (WARN_ON(i == pf->nscenarios))\r\nreturn -EINVAL;\r\nval = pctl_readl(pctl, pf->scenario_reg);\r\nval &= ~(pf->scenario_mask << pf->scenario_shift);\r\nval |= i << pf->scenario_shift;\r\npctl_writel(pctl, val, pf->scenario_reg);\r\n}\r\n}\r\nrange = pinctrl_find_gpio_range_from_pin(pctl->pctldev, pg->pin);\r\nif (range)\r\ngpio_disable(gpiochip_get_data(range->gc), pg->pin - range->pin_base);\r\nreturn 0;\r\n}\r\nstatic int pistachio_pinconf_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nu32 val, arg;\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nval = pctl_readl(pctl, PADS_SCHMITT_EN_REG(pin));\r\narg = !!(val & PADS_SCHMITT_EN_BIT(pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\nval = pctl_readl(pctl, PADS_PU_PD_REG(pin)) >>\r\nPADS_PU_PD_SHIFT(pin);\r\narg = (val & PADS_PU_PD_MASK) == PADS_PU_PD_HIGHZ;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nval = pctl_readl(pctl, PADS_PU_PD_REG(pin)) >>\r\nPADS_PU_PD_SHIFT(pin);\r\narg = (val & PADS_PU_PD_MASK) == PADS_PU_PD_UP;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nval = pctl_readl(pctl, PADS_PU_PD_REG(pin)) >>\r\nPADS_PU_PD_SHIFT(pin);\r\narg = (val & PADS_PU_PD_MASK) == PADS_PU_PD_DOWN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\nval = pctl_readl(pctl, PADS_PU_PD_REG(pin)) >>\r\nPADS_PU_PD_SHIFT(pin);\r\narg = (val & PADS_PU_PD_MASK) == PADS_PU_PD_BUS;\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nval = pctl_readl(pctl, PADS_SLEW_RATE_REG(pin));\r\narg = !!(val & PADS_SLEW_RATE_BIT(pin));\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nval = pctl_readl(pctl, PADS_DRIVE_STRENGTH_REG(pin)) >>\r\nPADS_DRIVE_STRENGTH_SHIFT(pin);\r\nswitch (val & PADS_DRIVE_STRENGTH_MASK) {\r\ncase PADS_DRIVE_STRENGTH_2MA:\r\narg = 2;\r\nbreak;\r\ncase PADS_DRIVE_STRENGTH_4MA:\r\narg = 4;\r\nbreak;\r\ncase PADS_DRIVE_STRENGTH_8MA:\r\narg = 8;\r\nbreak;\r\ncase PADS_DRIVE_STRENGTH_12MA:\r\ndefault:\r\narg = 12;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(pctl->dev, "Property %u not supported\n", param);\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int pistachio_pinconf_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct pistachio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nu32 drv, val, arg;\r\nunsigned int i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nval = pctl_readl(pctl, PADS_SCHMITT_EN_REG(pin));\r\nif (arg)\r\nval |= PADS_SCHMITT_EN_BIT(pin);\r\nelse\r\nval &= ~PADS_SCHMITT_EN_BIT(pin);\r\npctl_writel(pctl, val, PADS_SCHMITT_EN_REG(pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\nval = pctl_readl(pctl, PADS_PU_PD_REG(pin));\r\nval &= ~(PADS_PU_PD_MASK << PADS_PU_PD_SHIFT(pin));\r\nval |= PADS_PU_PD_HIGHZ << PADS_PU_PD_SHIFT(pin);\r\npctl_writel(pctl, val, PADS_PU_PD_REG(pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nval = pctl_readl(pctl, PADS_PU_PD_REG(pin));\r\nval &= ~(PADS_PU_PD_MASK << PADS_PU_PD_SHIFT(pin));\r\nval |= PADS_PU_PD_UP << PADS_PU_PD_SHIFT(pin);\r\npctl_writel(pctl, val, PADS_PU_PD_REG(pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nval = pctl_readl(pctl, PADS_PU_PD_REG(pin));\r\nval &= ~(PADS_PU_PD_MASK << PADS_PU_PD_SHIFT(pin));\r\nval |= PADS_PU_PD_DOWN << PADS_PU_PD_SHIFT(pin);\r\npctl_writel(pctl, val, PADS_PU_PD_REG(pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\nval = pctl_readl(pctl, PADS_PU_PD_REG(pin));\r\nval &= ~(PADS_PU_PD_MASK << PADS_PU_PD_SHIFT(pin));\r\nval |= PADS_PU_PD_BUS << PADS_PU_PD_SHIFT(pin);\r\npctl_writel(pctl, val, PADS_PU_PD_REG(pin));\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nval = pctl_readl(pctl, PADS_SLEW_RATE_REG(pin));\r\nif (arg)\r\nval |= PADS_SLEW_RATE_BIT(pin);\r\nelse\r\nval &= ~PADS_SLEW_RATE_BIT(pin);\r\npctl_writel(pctl, val, PADS_SLEW_RATE_REG(pin));\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nval = pctl_readl(pctl, PADS_DRIVE_STRENGTH_REG(pin));\r\nval &= ~(PADS_DRIVE_STRENGTH_MASK <<\r\nPADS_DRIVE_STRENGTH_SHIFT(pin));\r\nswitch (arg) {\r\ncase 2:\r\ndrv = PADS_DRIVE_STRENGTH_2MA;\r\nbreak;\r\ncase 4:\r\ndrv = PADS_DRIVE_STRENGTH_4MA;\r\nbreak;\r\ncase 8:\r\ndrv = PADS_DRIVE_STRENGTH_8MA;\r\nbreak;\r\ncase 12:\r\ndrv = PADS_DRIVE_STRENGTH_12MA;\r\nbreak;\r\ndefault:\r\ndev_err(pctl->dev,\r\n"Drive strength %umA not supported\n",\r\narg);\r\nreturn -EINVAL;\r\n}\r\nval |= drv << PADS_DRIVE_STRENGTH_SHIFT(pin);\r\npctl_writel(pctl, val, PADS_DRIVE_STRENGTH_REG(pin));\r\nbreak;\r\ndefault:\r\ndev_err(pctl->dev, "Property %u not supported\n",\r\nparam);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pistachio_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pistachio_gpio_bank *bank = gpiochip_get_data(chip);\r\nreturn !(gpio_readl(bank, GPIO_OUTPUT_EN) & BIT(offset));\r\n}\r\nstatic int pistachio_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pistachio_gpio_bank *bank = gpiochip_get_data(chip);\r\nu32 reg;\r\nif (gpio_readl(bank, GPIO_OUTPUT_EN) & BIT(offset))\r\nreg = GPIO_OUTPUT;\r\nelse\r\nreg = GPIO_INPUT;\r\nreturn !!(gpio_readl(bank, reg) & BIT(offset));\r\n}\r\nstatic void pistachio_gpio_set(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct pistachio_gpio_bank *bank = gpiochip_get_data(chip);\r\ngpio_mask_writel(bank, GPIO_OUTPUT, offset, !!value);\r\n}\r\nstatic int pistachio_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct pistachio_gpio_bank *bank = gpiochip_get_data(chip);\r\ngpio_mask_writel(bank, GPIO_OUTPUT_EN, offset, 0);\r\ngpio_enable(bank, offset);\r\nreturn 0;\r\n}\r\nstatic int pistachio_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct pistachio_gpio_bank *bank = gpiochip_get_data(chip);\r\npistachio_gpio_set(chip, offset, value);\r\ngpio_mask_writel(bank, GPIO_OUTPUT_EN, offset, 1);\r\ngpio_enable(bank, offset);\r\nreturn 0;\r\n}\r\nstatic void pistachio_gpio_irq_ack(struct irq_data *data)\r\n{\r\nstruct pistachio_gpio_bank *bank = irqd_to_bank(data);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_STATUS, data->hwirq, 0);\r\n}\r\nstatic void pistachio_gpio_irq_mask(struct irq_data *data)\r\n{\r\nstruct pistachio_gpio_bank *bank = irqd_to_bank(data);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_EN, data->hwirq, 0);\r\n}\r\nstatic void pistachio_gpio_irq_unmask(struct irq_data *data)\r\n{\r\nstruct pistachio_gpio_bank *bank = irqd_to_bank(data);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_EN, data->hwirq, 1);\r\n}\r\nstatic unsigned int pistachio_gpio_irq_startup(struct irq_data *data)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\r\npistachio_gpio_direction_input(chip, data->hwirq);\r\npistachio_gpio_irq_unmask(data);\r\nreturn 0;\r\n}\r\nstatic int pistachio_gpio_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct pistachio_gpio_bank *bank = irqd_to_bank(data);\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ngpio_mask_writel(bank, GPIO_INPUT_POLARITY, data->hwirq, 1);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_TYPE, data->hwirq,\r\nGPIO_INTERRUPT_TYPE_EDGE);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_EDGE, data->hwirq,\r\nGPIO_INTERRUPT_EDGE_SINGLE);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ngpio_mask_writel(bank, GPIO_INPUT_POLARITY, data->hwirq, 0);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_TYPE, data->hwirq,\r\nGPIO_INTERRUPT_TYPE_EDGE);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_EDGE, data->hwirq,\r\nGPIO_INTERRUPT_EDGE_SINGLE);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_TYPE, data->hwirq,\r\nGPIO_INTERRUPT_TYPE_EDGE);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_EDGE, data->hwirq,\r\nGPIO_INTERRUPT_EDGE_DUAL);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ngpio_mask_writel(bank, GPIO_INPUT_POLARITY, data->hwirq, 1);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_TYPE, data->hwirq,\r\nGPIO_INTERRUPT_TYPE_LEVEL);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ngpio_mask_writel(bank, GPIO_INPUT_POLARITY, data->hwirq, 0);\r\ngpio_mask_writel(bank, GPIO_INTERRUPT_TYPE, data->hwirq,\r\nGPIO_INTERRUPT_TYPE_LEVEL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (type & IRQ_TYPE_LEVEL_MASK)\r\nirq_set_handler_locked(data, handle_level_irq);\r\nelse\r\nirq_set_handler_locked(data, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic void pistachio_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct pistachio_gpio_bank *bank = gpiochip_get_data(gc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned long pending;\r\nunsigned int pin;\r\nchained_irq_enter(chip, desc);\r\npending = gpio_readl(bank, GPIO_INTERRUPT_STATUS) &\r\ngpio_readl(bank, GPIO_INTERRUPT_EN);\r\nfor_each_set_bit(pin, &pending, 16)\r\ngeneric_handle_irq(irq_linear_revmap(gc->irqdomain, pin));\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int pistachio_gpio_register(struct pistachio_pinctrl *pctl)\r\n{\r\nstruct device_node *node = pctl->dev->of_node;\r\nstruct pistachio_gpio_bank *bank;\r\nunsigned int i;\r\nint irq, ret = 0;\r\nfor (i = 0; i < pctl->nbanks; i++) {\r\nchar child_name[sizeof("gpioXX")];\r\nstruct device_node *child;\r\nsnprintf(child_name, sizeof(child_name), "gpio%d", i);\r\nchild = of_get_child_by_name(node, child_name);\r\nif (!child) {\r\ndev_err(pctl->dev, "No node for bank %u\n", i);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (!of_find_property(child, "gpio-controller", NULL)) {\r\ndev_err(pctl->dev,\r\n"No gpio-controller property for bank %u\n", i);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nirq = irq_of_parse_and_map(child, 0);\r\nif (irq < 0) {\r\ndev_err(pctl->dev, "No IRQ for bank %u: %d\n", i, irq);\r\nret = irq;\r\ngoto err;\r\n}\r\nbank = &pctl->gpio_banks[i];\r\nbank->pctl = pctl;\r\nbank->base = pctl->base + GPIO_BANK_BASE(i);\r\nbank->gpio_chip.parent = pctl->dev;\r\nbank->gpio_chip.of_node = child;\r\nret = gpiochip_add_data(&bank->gpio_chip, bank);\r\nif (ret < 0) {\r\ndev_err(pctl->dev, "Failed to add GPIO chip %u: %d\n",\r\ni, ret);\r\ngoto err;\r\n}\r\nret = gpiochip_irqchip_add(&bank->gpio_chip, &bank->irq_chip,\r\n0, handle_level_irq, IRQ_TYPE_NONE);\r\nif (ret < 0) {\r\ndev_err(pctl->dev, "Failed to add IRQ chip %u: %d\n",\r\ni, ret);\r\ngpiochip_remove(&bank->gpio_chip);\r\ngoto err;\r\n}\r\ngpiochip_set_chained_irqchip(&bank->gpio_chip, &bank->irq_chip,\r\nirq, pistachio_gpio_irq_handler);\r\nret = gpiochip_add_pin_range(&bank->gpio_chip,\r\ndev_name(pctl->dev), 0,\r\nbank->pin_base, bank->npins);\r\nif (ret < 0) {\r\ndev_err(pctl->dev, "Failed to add GPIO range %u: %d\n",\r\ni, ret);\r\ngpiochip_remove(&bank->gpio_chip);\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfor (; i > 0; i--) {\r\nbank = &pctl->gpio_banks[i - 1];\r\ngpiochip_remove(&bank->gpio_chip);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pistachio_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct pistachio_pinctrl *pctl;\r\nstruct resource *res;\r\npctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\r\nif (!pctl)\r\nreturn -ENOMEM;\r\npctl->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, pctl);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npctl->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pctl->base))\r\nreturn PTR_ERR(pctl->base);\r\npctl->pins = pistachio_pins;\r\npctl->npins = ARRAY_SIZE(pistachio_pins);\r\npctl->functions = pistachio_functions;\r\npctl->nfunctions = ARRAY_SIZE(pistachio_functions);\r\npctl->groups = pistachio_groups;\r\npctl->ngroups = ARRAY_SIZE(pistachio_groups);\r\npctl->gpio_banks = pistachio_gpio_banks;\r\npctl->nbanks = ARRAY_SIZE(pistachio_gpio_banks);\r\npistachio_pinctrl_desc.pins = pctl->pins;\r\npistachio_pinctrl_desc.npins = pctl->npins;\r\npctl->pctldev = devm_pinctrl_register(&pdev->dev, &pistachio_pinctrl_desc,\r\npctl);\r\nif (IS_ERR(pctl->pctldev)) {\r\ndev_err(&pdev->dev, "Failed to register pinctrl device\n");\r\nreturn PTR_ERR(pctl->pctldev);\r\n}\r\nreturn pistachio_gpio_register(pctl);\r\n}\r\nstatic int __init pistachio_pinctrl_register(void)\r\n{\r\nreturn platform_driver_register(&pistachio_pinctrl_driver);\r\n}
