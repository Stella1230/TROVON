static int default_finish_suspend(unsigned long cpu_state)\r\n{\r\nomap_do_wfi();\r\nreturn 0;\r\n}\r\nstatic void dummy_cpu_resume(void)\r\n{}\r\nstatic void dummy_scu_prepare(unsigned int cpu_id, unsigned int cpu_state)\r\n{}\r\nstatic inline void set_cpu_wakeup_addr(unsigned int cpu_id, u32 addr)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\nif (pm_info->wkup_sar_addr)\r\nwritel_relaxed(addr, pm_info->wkup_sar_addr);\r\n}\r\nstatic void scu_pwrst_prepare(unsigned int cpu_id, unsigned int cpu_state)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\nu32 scu_pwr_st;\r\nswitch (cpu_state) {\r\ncase PWRDM_POWER_RET:\r\nscu_pwr_st = SCU_PM_DORMANT;\r\nbreak;\r\ncase PWRDM_POWER_OFF:\r\nscu_pwr_st = SCU_PM_POWEROFF;\r\nbreak;\r\ncase PWRDM_POWER_ON:\r\ncase PWRDM_POWER_INACTIVE:\r\ndefault:\r\nscu_pwr_st = SCU_PM_NORMAL;\r\nbreak;\r\n}\r\nif (pm_info->scu_sar_addr)\r\nwritel_relaxed(scu_pwr_st, pm_info->scu_sar_addr);\r\n}\r\nstatic inline void mpuss_clear_prev_logic_pwrst(void)\r\n{\r\nu32 reg;\r\nreg = omap4_prminst_read_inst_reg(OMAP4430_PRM_PARTITION,\r\nOMAP4430_PRM_MPU_INST, OMAP4_RM_MPU_MPU_CONTEXT_OFFSET);\r\nomap4_prminst_write_inst_reg(reg, OMAP4430_PRM_PARTITION,\r\nOMAP4430_PRM_MPU_INST, OMAP4_RM_MPU_MPU_CONTEXT_OFFSET);\r\n}\r\nstatic inline void cpu_clear_prev_logic_pwrst(unsigned int cpu_id)\r\n{\r\nu32 reg;\r\nif (cpu_id) {\r\nreg = omap4_prcm_mpu_read_inst_reg(OMAP4430_PRCM_MPU_CPU1_INST,\r\ncpu_context_offset);\r\nomap4_prcm_mpu_write_inst_reg(reg, OMAP4430_PRCM_MPU_CPU1_INST,\r\ncpu_context_offset);\r\n} else {\r\nreg = omap4_prcm_mpu_read_inst_reg(OMAP4430_PRCM_MPU_CPU0_INST,\r\ncpu_context_offset);\r\nomap4_prcm_mpu_write_inst_reg(reg, OMAP4430_PRCM_MPU_CPU0_INST,\r\ncpu_context_offset);\r\n}\r\n}\r\nstatic void l2x0_pwrst_prepare(unsigned int cpu_id, unsigned int save_state)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\nif (pm_info->l2x0_sar_addr)\r\nwritel_relaxed(save_state, pm_info->l2x0_sar_addr);\r\n}\r\nstatic void __init save_l2x0_context(void)\r\n{\r\nvoid __iomem *l2x0_base = omap4_get_l2cache_base();\r\nif (l2x0_base && sar_base) {\r\nwritel_relaxed(l2x0_saved_regs.aux_ctrl,\r\nsar_base + L2X0_AUXCTRL_OFFSET);\r\nwritel_relaxed(l2x0_saved_regs.prefetch_ctrl,\r\nsar_base + L2X0_PREFETCH_CTRL_OFFSET);\r\n}\r\n}\r\nstatic void __init save_l2x0_context(void)\r\n{}\r\nint omap4_enter_lowpower(unsigned int cpu, unsigned int power_state)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu);\r\nunsigned int save_state = 0, cpu_logic_state = PWRDM_POWER_RET;\r\nunsigned int wakeup_cpu;\r\nif (omap_rev() == OMAP4430_REV_ES1_0)\r\nreturn -ENXIO;\r\nswitch (power_state) {\r\ncase PWRDM_POWER_ON:\r\ncase PWRDM_POWER_INACTIVE:\r\nsave_state = 0;\r\nbreak;\r\ncase PWRDM_POWER_OFF:\r\ncpu_logic_state = PWRDM_POWER_OFF;\r\nsave_state = 1;\r\nbreak;\r\ncase PWRDM_POWER_RET:\r\nif (IS_PM44XX_ERRATUM(PM_OMAP4_CPU_OSWR_DISABLE)) {\r\nsave_state = 0;\r\nbreak;\r\n}\r\ndefault:\r\nWARN_ON(1);\r\nreturn -ENXIO;\r\n}\r\npwrdm_pre_transition(NULL);\r\nmpuss_clear_prev_logic_pwrst();\r\nif ((pwrdm_read_next_pwrst(mpuss_pd) == PWRDM_POWER_RET) &&\r\n(pwrdm_read_logic_retst(mpuss_pd) == PWRDM_POWER_OFF))\r\nsave_state = 2;\r\ncpu_clear_prev_logic_pwrst(cpu);\r\npwrdm_set_next_pwrst(pm_info->pwrdm, power_state);\r\npwrdm_set_logic_retst(pm_info->pwrdm, cpu_logic_state);\r\nset_cpu_wakeup_addr(cpu, virt_to_phys(omap_pm_ops.resume));\r\nomap_pm_ops.scu_prepare(cpu, power_state);\r\nl2x0_pwrst_prepare(cpu, save_state);\r\nif (save_state)\r\ncpu_suspend(save_state, omap_pm_ops.finish_suspend);\r\nelse\r\nomap_pm_ops.finish_suspend(save_state);\r\nif (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD) && cpu)\r\ngic_dist_enable();\r\nwakeup_cpu = smp_processor_id();\r\npwrdm_set_next_pwrst(pm_info->pwrdm, PWRDM_POWER_ON);\r\npwrdm_post_transition(NULL);\r\nreturn 0;\r\n}\r\nint omap4_hotplug_cpu(unsigned int cpu, unsigned int power_state)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu);\r\nunsigned int cpu_state = 0;\r\nif (omap_rev() == OMAP4430_REV_ES1_0)\r\nreturn -ENXIO;\r\npower_state = pwrdm_get_valid_lp_state(pm_info->pwrdm,\r\nfalse, power_state);\r\nif (power_state == PWRDM_POWER_OFF)\r\ncpu_state = 1;\r\npwrdm_clear_all_prev_pwrst(pm_info->pwrdm);\r\npwrdm_set_next_pwrst(pm_info->pwrdm, power_state);\r\nset_cpu_wakeup_addr(cpu, virt_to_phys(omap_pm_ops.hotplug_restart));\r\nomap_pm_ops.scu_prepare(cpu, power_state);\r\nomap_pm_ops.finish_suspend(cpu_state);\r\npwrdm_set_next_pwrst(pm_info->pwrdm, PWRDM_POWER_ON);\r\nreturn 0;\r\n}\r\nstatic void enable_mercury_retention_mode(void)\r\n{\r\nu32 reg;\r\nreg = omap4_prcm_mpu_read_inst_reg(OMAP54XX_PRCM_MPU_DEVICE_INST,\r\nOMAP54XX_PRCM_MPU_PRM_PSCON_COUNT_OFFSET);\r\nreg |= BIT(24) | BIT(25);\r\nomap4_prcm_mpu_write_inst_reg(reg, OMAP54XX_PRCM_MPU_DEVICE_INST,\r\nOMAP54XX_PRCM_MPU_PRM_PSCON_COUNT_OFFSET);\r\n}\r\nint __init omap4_mpuss_init(void)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info;\r\nif (omap_rev() == OMAP4430_REV_ES1_0) {\r\nWARN(1, "Power Management not supported on OMAP4430 ES1.0\n");\r\nreturn -ENODEV;\r\n}\r\npm_info = &per_cpu(omap4_pm_info, 0x0);\r\nif (sar_base) {\r\npm_info->scu_sar_addr = sar_base + SCU_OFFSET0;\r\npm_info->wkup_sar_addr = sar_base +\r\nCPU0_WAKEUP_NS_PA_ADDR_OFFSET;\r\npm_info->l2x0_sar_addr = sar_base + L2X0_SAVE_OFFSET0;\r\n}\r\npm_info->pwrdm = pwrdm_lookup("cpu0_pwrdm");\r\nif (!pm_info->pwrdm) {\r\npr_err("Lookup failed for CPU0 pwrdm\n");\r\nreturn -ENODEV;\r\n}\r\npwrdm_clear_all_prev_pwrst(pm_info->pwrdm);\r\ncpu_clear_prev_logic_pwrst(0);\r\npwrdm_set_next_pwrst(pm_info->pwrdm, PWRDM_POWER_ON);\r\npm_info = &per_cpu(omap4_pm_info, 0x1);\r\nif (sar_base) {\r\npm_info->scu_sar_addr = sar_base + SCU_OFFSET1;\r\npm_info->wkup_sar_addr = sar_base +\r\nCPU1_WAKEUP_NS_PA_ADDR_OFFSET;\r\npm_info->l2x0_sar_addr = sar_base + L2X0_SAVE_OFFSET1;\r\n}\r\npm_info->pwrdm = pwrdm_lookup("cpu1_pwrdm");\r\nif (!pm_info->pwrdm) {\r\npr_err("Lookup failed for CPU1 pwrdm\n");\r\nreturn -ENODEV;\r\n}\r\npwrdm_clear_all_prev_pwrst(pm_info->pwrdm);\r\ncpu_clear_prev_logic_pwrst(1);\r\npwrdm_set_next_pwrst(pm_info->pwrdm, PWRDM_POWER_ON);\r\nmpuss_pd = pwrdm_lookup("mpu_pwrdm");\r\nif (!mpuss_pd) {\r\npr_err("Failed to lookup MPUSS power domain\n");\r\nreturn -ENODEV;\r\n}\r\npwrdm_clear_all_prev_pwrst(mpuss_pd);\r\nmpuss_clear_prev_logic_pwrst();\r\nif (sar_base) {\r\nwritel_relaxed((omap_type() != OMAP2_DEVICE_TYPE_GP) ? 1 : 0,\r\nsar_base + OMAP_TYPE_OFFSET);\r\nsave_l2x0_context();\r\n}\r\nif (cpu_is_omap44xx()) {\r\nomap_pm_ops.finish_suspend = omap4_finish_suspend;\r\nomap_pm_ops.resume = omap4_cpu_resume;\r\nomap_pm_ops.scu_prepare = scu_pwrst_prepare;\r\nomap_pm_ops.hotplug_restart = omap4_secondary_startup;\r\ncpu_context_offset = OMAP4_RM_CPU0_CPU0_CONTEXT_OFFSET;\r\n} else if (soc_is_omap54xx() || soc_is_dra7xx()) {\r\ncpu_context_offset = OMAP54XX_RM_CPU0_CPU0_CONTEXT_OFFSET;\r\nenable_mercury_retention_mode();\r\n}\r\nif (cpu_is_omap446x())\r\nomap_pm_ops.hotplug_restart = omap4460_secondary_startup;\r\nreturn 0;\r\n}\r\nvoid __init omap4_mpuss_early_init(void)\r\n{\r\nunsigned long startup_pa;\r\nif (!cpu_is_omap44xx())\r\nreturn;\r\nsar_base = omap4_get_sar_ram_base();\r\nif (cpu_is_omap443x())\r\nstartup_pa = virt_to_phys(omap4_secondary_startup);\r\nelse\r\nstartup_pa = virt_to_phys(omap4460_secondary_startup);\r\nwritel_relaxed(startup_pa, sar_base + CPU1_WAKEUP_NS_PA_ADDR_OFFSET);\r\n}
