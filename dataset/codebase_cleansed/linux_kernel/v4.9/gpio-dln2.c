static int dln2_gpio_get_pin_count(struct platform_device *pdev)\r\n{\r\nint ret;\r\n__le16 count;\r\nint len = sizeof(count);\r\nret = dln2_transfer_rx(pdev, DLN2_GPIO_GET_PIN_COUNT, &count, &len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (len < sizeof(count))\r\nreturn -EPROTO;\r\nreturn le16_to_cpu(count);\r\n}\r\nstatic int dln2_gpio_pin_cmd(struct dln2_gpio *dln2, int cmd, unsigned pin)\r\n{\r\nstruct dln2_gpio_pin req = {\r\n.pin = cpu_to_le16(pin),\r\n};\r\nreturn dln2_transfer_tx(dln2->pdev, cmd, &req, sizeof(req));\r\n}\r\nstatic int dln2_gpio_pin_val(struct dln2_gpio *dln2, int cmd, unsigned int pin)\r\n{\r\nint ret;\r\nstruct dln2_gpio_pin req = {\r\n.pin = cpu_to_le16(pin),\r\n};\r\nstruct dln2_gpio_pin_val rsp;\r\nint len = sizeof(rsp);\r\nret = dln2_transfer(dln2->pdev, cmd, &req, sizeof(req), &rsp, &len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (len < sizeof(rsp) || req.pin != rsp.pin)\r\nreturn -EPROTO;\r\nreturn rsp.value;\r\n}\r\nstatic int dln2_gpio_pin_get_in_val(struct dln2_gpio *dln2, unsigned int pin)\r\n{\r\nint ret;\r\nret = dln2_gpio_pin_val(dln2, DLN2_GPIO_PIN_GET_VAL, pin);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!ret;\r\n}\r\nstatic int dln2_gpio_pin_get_out_val(struct dln2_gpio *dln2, unsigned int pin)\r\n{\r\nint ret;\r\nret = dln2_gpio_pin_val(dln2, DLN2_GPIO_PIN_GET_OUT_VAL, pin);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!ret;\r\n}\r\nstatic int dln2_gpio_pin_set_out_val(struct dln2_gpio *dln2,\r\nunsigned int pin, int value)\r\n{\r\nstruct dln2_gpio_pin_val req = {\r\n.pin = cpu_to_le16(pin),\r\n.value = value,\r\n};\r\nreturn dln2_transfer_tx(dln2->pdev, DLN2_GPIO_PIN_SET_OUT_VAL, &req,\r\nsizeof(req));\r\n}\r\nstatic int dln2_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\r\nstruct dln2_gpio_pin req = {\r\n.pin = cpu_to_le16(offset),\r\n};\r\nstruct dln2_gpio_pin_val rsp;\r\nint len = sizeof(rsp);\r\nint ret;\r\nret = dln2_gpio_pin_cmd(dln2, DLN2_GPIO_PIN_ENABLE, offset);\r\nif (ret < 0)\r\nreturn ret;\r\nret = dln2_transfer(dln2->pdev, DLN2_GPIO_PIN_GET_DIRECTION,\r\n&req, sizeof(req), &rsp, &len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (len < sizeof(rsp) || req.pin != rsp.pin) {\r\nret = -EPROTO;\r\ngoto out_disable;\r\n}\r\nswitch (rsp.value) {\r\ncase DLN2_GPIO_DIRECTION_IN:\r\nclear_bit(offset, dln2->output_enabled);\r\nreturn 0;\r\ncase DLN2_GPIO_DIRECTION_OUT:\r\nset_bit(offset, dln2->output_enabled);\r\nreturn 0;\r\ndefault:\r\nret = -EPROTO;\r\ngoto out_disable;\r\n}\r\nout_disable:\r\ndln2_gpio_pin_cmd(dln2, DLN2_GPIO_PIN_DISABLE, offset);\r\nreturn ret;\r\n}\r\nstatic void dln2_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\r\ndln2_gpio_pin_cmd(dln2, DLN2_GPIO_PIN_DISABLE, offset);\r\n}\r\nstatic int dln2_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\r\nif (test_bit(offset, dln2->output_enabled))\r\nreturn GPIOF_DIR_OUT;\r\nreturn GPIOF_DIR_IN;\r\n}\r\nstatic int dln2_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\r\nint dir;\r\ndir = dln2_gpio_get_direction(chip, offset);\r\nif (dir < 0)\r\nreturn dir;\r\nif (dir == GPIOF_DIR_IN)\r\nreturn dln2_gpio_pin_get_in_val(dln2, offset);\r\nreturn dln2_gpio_pin_get_out_val(dln2, offset);\r\n}\r\nstatic void dln2_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\r\ndln2_gpio_pin_set_out_val(dln2, offset, value);\r\n}\r\nstatic int dln2_gpio_set_direction(struct gpio_chip *chip, unsigned offset,\r\nunsigned dir)\r\n{\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\r\nstruct dln2_gpio_pin_val req = {\r\n.pin = cpu_to_le16(offset),\r\n.value = dir,\r\n};\r\nint ret;\r\nret = dln2_transfer_tx(dln2->pdev, DLN2_GPIO_PIN_SET_DIRECTION,\r\n&req, sizeof(req));\r\nif (ret < 0)\r\nreturn ret;\r\nif (dir == DLN2_GPIO_DIRECTION_OUT)\r\nset_bit(offset, dln2->output_enabled);\r\nelse\r\nclear_bit(offset, dln2->output_enabled);\r\nreturn ret;\r\n}\r\nstatic int dln2_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn dln2_gpio_set_direction(chip, offset, DLN2_GPIO_DIRECTION_IN);\r\n}\r\nstatic int dln2_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\r\nint ret;\r\nret = dln2_gpio_pin_set_out_val(dln2, offset, value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn dln2_gpio_set_direction(chip, offset, DLN2_GPIO_DIRECTION_OUT);\r\n}\r\nstatic int dln2_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,\r\nunsigned debounce)\r\n{\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(chip);\r\n__le32 duration = cpu_to_le32(debounce);\r\nreturn dln2_transfer_tx(dln2->pdev, DLN2_GPIO_SET_DEBOUNCE,\r\n&duration, sizeof(duration));\r\n}\r\nstatic int dln2_gpio_set_event_cfg(struct dln2_gpio *dln2, unsigned pin,\r\nunsigned type, unsigned period)\r\n{\r\nstruct {\r\n__le16 pin;\r\nu8 type;\r\n__le16 period;\r\n} __packed req = {\r\n.pin = cpu_to_le16(pin),\r\n.type = type,\r\n.period = cpu_to_le16(period),\r\n};\r\nreturn dln2_transfer_tx(dln2->pdev, DLN2_GPIO_PIN_SET_EVENT_CFG,\r\n&req, sizeof(req));\r\n}\r\nstatic void dln2_irq_unmask(struct irq_data *irqd)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\r\nint pin = irqd_to_hwirq(irqd);\r\nset_bit(pin, dln2->unmasked_irqs);\r\n}\r\nstatic void dln2_irq_mask(struct irq_data *irqd)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\r\nint pin = irqd_to_hwirq(irqd);\r\nclear_bit(pin, dln2->unmasked_irqs);\r\n}\r\nstatic int dln2_irq_set_type(struct irq_data *irqd, unsigned type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\r\nint pin = irqd_to_hwirq(irqd);\r\nswitch (type) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ndln2->irq_type[pin] = DLN2_GPIO_EVENT_LVL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ndln2->irq_type[pin] = DLN2_GPIO_EVENT_LVL_LOW;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ndln2->irq_type[pin] = DLN2_GPIO_EVENT_CHANGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ndln2->irq_type[pin] = DLN2_GPIO_EVENT_CHANGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ndln2->irq_type[pin] = DLN2_GPIO_EVENT_CHANGE_FALLING;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dln2_irq_bus_lock(struct irq_data *irqd)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\r\nmutex_lock(&dln2->irq_lock);\r\n}\r\nstatic void dln2_irq_bus_unlock(struct irq_data *irqd)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(irqd);\r\nstruct dln2_gpio *dln2 = gpiochip_get_data(gc);\r\nint pin = irqd_to_hwirq(irqd);\r\nint enabled, unmasked;\r\nunsigned type;\r\nint ret;\r\nenabled = test_bit(pin, dln2->enabled_irqs);\r\nunmasked = test_bit(pin, dln2->unmasked_irqs);\r\nif (enabled != unmasked) {\r\nif (unmasked) {\r\ntype = dln2->irq_type[pin] & DLN2_GPIO_EVENT_MASK;\r\nset_bit(pin, dln2->enabled_irqs);\r\n} else {\r\ntype = DLN2_GPIO_EVENT_NONE;\r\nclear_bit(pin, dln2->enabled_irqs);\r\n}\r\nret = dln2_gpio_set_event_cfg(dln2, pin, type, 0);\r\nif (ret)\r\ndev_err(dln2->gpio.parent, "failed to set event\n");\r\n}\r\nmutex_unlock(&dln2->irq_lock);\r\n}\r\nstatic void dln2_gpio_event(struct platform_device *pdev, u16 echo,\r\nconst void *data, int len)\r\n{\r\nint pin, irq;\r\nconst struct {\r\n__le16 count;\r\n__u8 type;\r\n__le16 pin;\r\n__u8 value;\r\n} __packed *event = data;\r\nstruct dln2_gpio *dln2 = platform_get_drvdata(pdev);\r\nif (len < sizeof(*event)) {\r\ndev_err(dln2->gpio.parent, "short event message\n");\r\nreturn;\r\n}\r\npin = le16_to_cpu(event->pin);\r\nif (pin >= dln2->gpio.ngpio) {\r\ndev_err(dln2->gpio.parent, "out of bounds pin %d\n", pin);\r\nreturn;\r\n}\r\nirq = irq_find_mapping(dln2->gpio.irqdomain, pin);\r\nif (!irq) {\r\ndev_err(dln2->gpio.parent, "pin %d not mapped to IRQ\n", pin);\r\nreturn;\r\n}\r\nswitch (dln2->irq_type[pin]) {\r\ncase DLN2_GPIO_EVENT_CHANGE_RISING:\r\nif (event->value)\r\ngeneric_handle_irq(irq);\r\nbreak;\r\ncase DLN2_GPIO_EVENT_CHANGE_FALLING:\r\nif (!event->value)\r\ngeneric_handle_irq(irq);\r\nbreak;\r\ndefault:\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\nstatic int dln2_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct dln2_gpio *dln2;\r\nstruct device *dev = &pdev->dev;\r\nint pins;\r\nint ret;\r\npins = dln2_gpio_get_pin_count(pdev);\r\nif (pins < 0) {\r\ndev_err(dev, "failed to get pin count: %d\n", pins);\r\nreturn pins;\r\n}\r\nif (pins > DLN2_GPIO_MAX_PINS) {\r\npins = DLN2_GPIO_MAX_PINS;\r\ndev_warn(dev, "clamping pins to %d\n", DLN2_GPIO_MAX_PINS);\r\n}\r\ndln2 = devm_kzalloc(&pdev->dev, sizeof(*dln2), GFP_KERNEL);\r\nif (!dln2)\r\nreturn -ENOMEM;\r\nmutex_init(&dln2->irq_lock);\r\ndln2->pdev = pdev;\r\ndln2->gpio.label = "dln2";\r\ndln2->gpio.parent = dev;\r\ndln2->gpio.owner = THIS_MODULE;\r\ndln2->gpio.base = -1;\r\ndln2->gpio.ngpio = pins;\r\ndln2->gpio.can_sleep = true;\r\ndln2->gpio.irq_not_threaded = true;\r\ndln2->gpio.set = dln2_gpio_set;\r\ndln2->gpio.get = dln2_gpio_get;\r\ndln2->gpio.request = dln2_gpio_request;\r\ndln2->gpio.free = dln2_gpio_free;\r\ndln2->gpio.get_direction = dln2_gpio_get_direction;\r\ndln2->gpio.direction_input = dln2_gpio_direction_input;\r\ndln2->gpio.direction_output = dln2_gpio_direction_output;\r\ndln2->gpio.set_debounce = dln2_gpio_set_debounce;\r\nplatform_set_drvdata(pdev, dln2);\r\nret = devm_gpiochip_add_data(dev, &dln2->gpio, dln2);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to add gpio chip: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = gpiochip_irqchip_add(&dln2->gpio, &dln2_gpio_irqchip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to add irq chip: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = dln2_register_event_cb(pdev, DLN2_GPIO_CONDITION_MET_EV,\r\ndln2_gpio_event);\r\nif (ret) {\r\ndev_err(dev, "failed to register event cb: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dln2_gpio_remove(struct platform_device *pdev)\r\n{\r\ndln2_unregister_event_cb(pdev, DLN2_GPIO_CONDITION_MET_EV);\r\nreturn 0;\r\n}
