static void report_key(struct input_dev *input, unsigned keycode)\r\n{\r\npr_debug(APANEL ": report key %#x\n", keycode);\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\n}\r\nstatic void apanel_poll(struct input_polled_dev *ipdev)\r\n{\r\nstruct apanel *ap = ipdev->private;\r\nstruct input_dev *idev = ipdev->input;\r\nu8 cmd = device_chip[APANEL_DEV_APPBTN] == CHIP_OZ992C ? 0 : 8;\r\ns32 data;\r\nint i;\r\ndata = i2c_smbus_read_word_data(ap->client, cmd);\r\nif (data < 0)\r\nreturn;\r\ni2c_smbus_write_word_data(ap->client, cmd, 0);\r\nif (!data)\r\nreturn;\r\ndev_dbg(&idev->dev, APANEL ": data %#x\n", data);\r\nfor (i = 0; i < idev->keycodemax; i++)\r\nif ((1u << i) & data)\r\nreport_key(idev, ap->keymap[i]);\r\n}\r\nstatic void led_update(struct work_struct *work)\r\n{\r\nstruct apanel *ap = container_of(work, struct apanel, led_work);\r\ni2c_smbus_write_word_data(ap->client, 0x10, ap->led_bits);\r\n}\r\nstatic void mail_led_set(struct led_classdev *led,\r\nenum led_brightness value)\r\n{\r\nstruct apanel *ap = container_of(led, struct apanel, mail_led);\r\nif (value != LED_OFF)\r\nap->led_bits |= 0x8000;\r\nelse\r\nap->led_bits &= ~0x8000;\r\nschedule_work(&ap->led_work);\r\n}\r\nstatic int apanel_remove(struct i2c_client *client)\r\n{\r\nstruct apanel *ap = i2c_get_clientdata(client);\r\nif (device_chip[APANEL_DEV_LED] != CHIP_NONE)\r\nled_classdev_unregister(&ap->mail_led);\r\ninput_unregister_polled_device(ap->ipdev);\r\ninput_free_polled_device(ap->ipdev);\r\nreturn 0;\r\n}\r\nstatic void apanel_shutdown(struct i2c_client *client)\r\n{\r\napanel_remove(client);\r\n}\r\nstatic int apanel_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct apanel *ap;\r\nstruct input_polled_dev *ipdev;\r\nstruct input_dev *idev;\r\nu8 cmd = device_chip[APANEL_DEV_APPBTN] == CHIP_OZ992C ? 0 : 8;\r\nint i, err = -ENOMEM;\r\nap = &apanel;\r\nipdev = input_allocate_polled_device();\r\nif (!ipdev)\r\ngoto out1;\r\nap->ipdev = ipdev;\r\nap->client = client;\r\ni2c_set_clientdata(client, ap);\r\nerr = i2c_smbus_write_word_data(client, cmd, 0);\r\nif (err) {\r\ndev_warn(&client->dev, APANEL ": smbus write error %d\n",\r\nerr);\r\ngoto out3;\r\n}\r\nipdev->poll = apanel_poll;\r\nipdev->poll_interval = POLL_INTERVAL_DEFAULT;\r\nipdev->private = ap;\r\nidev = ipdev->input;\r\nidev->name = APANEL_NAME " buttons";\r\nidev->phys = "apanel/input0";\r\nidev->id.bustype = BUS_HOST;\r\nidev->dev.parent = &client->dev;\r\nset_bit(EV_KEY, idev->evbit);\r\nidev->keycode = ap->keymap;\r\nidev->keycodesize = sizeof(ap->keymap[0]);\r\nidev->keycodemax = (device_chip[APANEL_DEV_CDBTN] != CHIP_NONE) ? 12 : 4;\r\nfor (i = 0; i < idev->keycodemax; i++)\r\nif (ap->keymap[i])\r\nset_bit(ap->keymap[i], idev->keybit);\r\nerr = input_register_polled_device(ipdev);\r\nif (err)\r\ngoto out3;\r\nINIT_WORK(&ap->led_work, led_update);\r\nif (device_chip[APANEL_DEV_LED] != CHIP_NONE) {\r\nerr = led_classdev_register(&client->dev, &ap->mail_led);\r\nif (err)\r\ngoto out4;\r\n}\r\nreturn 0;\r\nout4:\r\ninput_unregister_polled_device(ipdev);\r\nout3:\r\ninput_free_polled_device(ipdev);\r\nout1:\r\nreturn err;\r\n}\r\nstatic __init const void __iomem *bios_signature(const void __iomem *bios)\r\n{\r\nssize_t offset;\r\nconst unsigned char signature[] = "FJKEYINF";\r\nfor (offset = 0; offset < 0x10000; offset += 0x10) {\r\nif (check_signature(bios + offset, signature,\r\nsizeof(signature)-1))\r\nreturn bios + offset;\r\n}\r\npr_notice(APANEL ": Fujitsu BIOS signature '%s' not found...\n",\r\nsignature);\r\nreturn NULL;\r\n}\r\nstatic int __init apanel_init(void)\r\n{\r\nvoid __iomem *bios;\r\nconst void __iomem *p;\r\nu8 devno;\r\nunsigned char i2c_addr;\r\nint found = 0;\r\nbios = ioremap(0xF0000, 0x10000);\r\np = bios_signature(bios);\r\nif (!p) {\r\niounmap(bios);\r\nreturn -ENODEV;\r\n}\r\np += 8;\r\ni2c_addr = readb(p + 3) >> 1;\r\nfor ( ; (devno = readb(p)) & 0x7f; p += 4) {\r\nunsigned char method, slave, chip;\r\nmethod = readb(p + 1);\r\nchip = readb(p + 2);\r\nslave = readb(p + 3) >> 1;\r\nif (slave != i2c_addr) {\r\npr_notice(APANEL ": only one SMBus slave "\r\n"address supported, skipping device...\n");\r\ncontinue;\r\n}\r\nswitch (devno) {\r\ncase 6:\r\ndevno = APANEL_DEV_APPBTN;\r\nbreak;\r\ncase 7:\r\ndevno = APANEL_DEV_LED;\r\nbreak;\r\n}\r\nif (devno >= APANEL_DEV_MAX)\r\npr_notice(APANEL ": unknown device %u found\n", devno);\r\nelse if (device_chip[devno] != CHIP_NONE)\r\npr_warning(APANEL ": duplicate entry for devno %u\n", devno);\r\nelse if (method != 1 && method != 2 && method != 4) {\r\npr_notice(APANEL ": unknown method %u for devno %u\n",\r\nmethod, devno);\r\n} else {\r\ndevice_chip[devno] = (enum apanel_chip) chip;\r\n++found;\r\n}\r\n}\r\niounmap(bios);\r\nif (found == 0) {\r\npr_info(APANEL ": no input devices reported by BIOS\n");\r\nreturn -EIO;\r\n}\r\nreturn i2c_add_driver(&apanel_driver);\r\n}\r\nstatic void __exit apanel_cleanup(void)\r\n{\r\ni2c_del_driver(&apanel_driver);\r\n}
