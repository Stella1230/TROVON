int snd_fw_transaction(struct fw_unit *unit, int tcode,\r\nu64 offset, void *buffer, size_t length,\r\nunsigned int flags)\r\n{\r\nstruct fw_device *device = fw_parent_device(unit);\r\nint generation, rcode, tries = 0;\r\ngeneration = flags & FW_GENERATION_MASK;\r\nfor (;;) {\r\nif (!(flags & FW_FIXED_GENERATION)) {\r\ngeneration = device->generation;\r\nsmp_rmb();\r\n}\r\nrcode = fw_run_transaction(device->card, tcode,\r\ndevice->node_id, generation,\r\ndevice->max_speed, offset,\r\nbuffer, length);\r\nif (rcode == RCODE_COMPLETE)\r\nreturn 0;\r\nif (rcode == RCODE_GENERATION && (flags & FW_FIXED_GENERATION))\r\nreturn -EAGAIN;\r\nif (rcode_is_permanent_error(rcode) || ++tries >= 3) {\r\nif (!(flags & FW_QUIET))\r\ndev_err(&unit->device,\r\n"transaction failed: %s\n",\r\nfw_rcode_string(rcode));\r\nreturn -EIO;\r\n}\r\nmsleep(ERROR_RETRY_DELAY_MS);\r\n}\r\n}\r\nvoid snd_fw_schedule_registration(struct fw_unit *unit,\r\nstruct delayed_work *dwork)\r\n{\r\nu64 now, delay;\r\nnow = get_jiffies_64();\r\ndelay = fw_parent_device(unit)->card->reset_jiffies\r\n+ msecs_to_jiffies(PROBE_DELAY_MS);\r\nif (time_after64(delay, now))\r\ndelay -= now;\r\nelse\r\ndelay = 0;\r\nmod_delayed_work(system_wq, dwork, delay);\r\n}\r\nstatic void async_midi_port_callback(struct fw_card *card, int rcode,\r\nvoid *data, size_t length,\r\nvoid *callback_data)\r\n{\r\nstruct snd_fw_async_midi_port *port = callback_data;\r\nstruct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);\r\nif (substream == NULL)\r\nreturn;\r\nif (rcode == RCODE_COMPLETE)\r\nsnd_rawmidi_transmit_ack(substream, port->consume_bytes);\r\nelse if (!rcode_is_permanent_error(rcode))\r\nport->next_ktime = ktime_set(0, 0);\r\nelse\r\nport->error = true;\r\nport->idling = true;\r\nif (!snd_rawmidi_transmit_empty(substream))\r\nschedule_work(&port->work);\r\n}\r\nstatic void midi_port_work(struct work_struct *work)\r\n{\r\nstruct snd_fw_async_midi_port *port =\r\ncontainer_of(work, struct snd_fw_async_midi_port, work);\r\nstruct snd_rawmidi_substream *substream = ACCESS_ONCE(port->substream);\r\nint generation;\r\nint type;\r\nif (!port->idling || port->error)\r\nreturn;\r\nif (substream == NULL || snd_rawmidi_transmit_empty(substream))\r\nreturn;\r\nif (ktime_after(port->next_ktime, ktime_get())) {\r\nschedule_work(&port->work);\r\nreturn;\r\n}\r\nmemset(port->buf, 0, port->len);\r\nport->consume_bytes = port->fill(substream, port->buf);\r\nif (port->consume_bytes <= 0) {\r\nif (port->consume_bytes == 0) {\r\nport->next_ktime = ktime_set(0, 0);\r\nschedule_work(&port->work);\r\n} else {\r\nport->error = true;\r\n}\r\nreturn;\r\n}\r\nif (port->len == 4)\r\ntype = TCODE_WRITE_QUADLET_REQUEST;\r\nelse\r\ntype = TCODE_WRITE_BLOCK_REQUEST;\r\nport->next_ktime = ktime_add_ns(ktime_get(),\r\nport->consume_bytes * 8 * NSEC_PER_SEC / 31250);\r\nport->idling = false;\r\ngeneration = port->parent->generation;\r\nsmp_rmb();\r\nfw_send_request(port->parent->card, &port->transaction, type,\r\nport->parent->node_id, generation,\r\nport->parent->max_speed, port->addr,\r\nport->buf, port->len, async_midi_port_callback,\r\nport);\r\n}\r\nint snd_fw_async_midi_port_init(struct snd_fw_async_midi_port *port,\r\nstruct fw_unit *unit, u64 addr, unsigned int len,\r\nsnd_fw_async_midi_port_fill fill)\r\n{\r\nport->len = DIV_ROUND_UP(len, 4) * 4;\r\nport->buf = kzalloc(port->len, GFP_KERNEL);\r\nif (port->buf == NULL)\r\nreturn -ENOMEM;\r\nport->parent = fw_parent_device(unit);\r\nport->addr = addr;\r\nport->fill = fill;\r\nport->idling = true;\r\nport->next_ktime = ktime_set(0, 0);\r\nport->error = false;\r\nINIT_WORK(&port->work, midi_port_work);\r\nreturn 0;\r\n}\r\nvoid snd_fw_async_midi_port_destroy(struct snd_fw_async_midi_port *port)\r\n{\r\nsnd_fw_async_midi_port_finish(port);\r\ncancel_work_sync(&port->work);\r\nkfree(port->buf);\r\n}
