static bool fw_get_builtin_firmware(struct firmware *fw, const char *name,\r\nvoid *buf, size_t size)\r\n{\r\nstruct builtin_fw *b_fw;\r\nfor (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) {\r\nif (strcmp(name, b_fw->name) == 0) {\r\nfw->size = b_fw->size;\r\nfw->data = b_fw->data;\r\nif (buf && fw->size <= size)\r\nmemcpy(buf, fw->data, fw->size);\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool fw_is_builtin_firmware(const struct firmware *fw)\r\n{\r\nstruct builtin_fw *b_fw;\r\nfor (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++)\r\nif (fw->data == b_fw->data)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool fw_get_builtin_firmware(struct firmware *fw,\r\nconst char *name, void *buf,\r\nsize_t size)\r\n{\r\nreturn false;\r\n}\r\nstatic inline bool fw_is_builtin_firmware(const struct firmware *fw)\r\n{\r\nreturn false;\r\n}\r\nstatic inline long firmware_loading_timeout(void)\r\n{\r\nreturn loading_timeout > 0 ? loading_timeout * HZ : MAX_JIFFY_OFFSET;\r\n}\r\nstatic struct firmware_buf *__allocate_fw_buf(const char *fw_name,\r\nstruct firmware_cache *fwc,\r\nvoid *dbuf, size_t size)\r\n{\r\nstruct firmware_buf *buf;\r\nbuf = kzalloc(sizeof(*buf), GFP_ATOMIC);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->fw_id = kstrdup_const(fw_name, GFP_ATOMIC);\r\nif (!buf->fw_id) {\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nkref_init(&buf->ref);\r\nbuf->fwc = fwc;\r\nbuf->data = dbuf;\r\nbuf->allocated_size = size;\r\ninit_completion(&buf->completion);\r\n#ifdef CONFIG_FW_LOADER_USER_HELPER\r\nINIT_LIST_HEAD(&buf->pending_list);\r\n#endif\r\npr_debug("%s: fw-%s buf=%p\n", __func__, fw_name, buf);\r\nreturn buf;\r\n}\r\nstatic struct firmware_buf *__fw_lookup_buf(const char *fw_name)\r\n{\r\nstruct firmware_buf *tmp;\r\nstruct firmware_cache *fwc = &fw_cache;\r\nlist_for_each_entry(tmp, &fwc->head, list)\r\nif (!strcmp(tmp->fw_id, fw_name))\r\nreturn tmp;\r\nreturn NULL;\r\n}\r\nstatic int fw_lookup_and_allocate_buf(const char *fw_name,\r\nstruct firmware_cache *fwc,\r\nstruct firmware_buf **buf, void *dbuf,\r\nsize_t size)\r\n{\r\nstruct firmware_buf *tmp;\r\nspin_lock(&fwc->lock);\r\ntmp = __fw_lookup_buf(fw_name);\r\nif (tmp) {\r\nkref_get(&tmp->ref);\r\nspin_unlock(&fwc->lock);\r\n*buf = tmp;\r\nreturn 1;\r\n}\r\ntmp = __allocate_fw_buf(fw_name, fwc, dbuf, size);\r\nif (tmp)\r\nlist_add(&tmp->list, &fwc->head);\r\nspin_unlock(&fwc->lock);\r\n*buf = tmp;\r\nreturn tmp ? 0 : -ENOMEM;\r\n}\r\nstatic void __fw_free_buf(struct kref *ref)\r\n__releases(&fwc->lock\r\nstatic void fw_free_buf(struct firmware_buf *buf)\r\n{\r\nstruct firmware_cache *fwc = buf->fwc;\r\nspin_lock(&fwc->lock);\r\nif (!kref_put(&buf->ref, __fw_free_buf))\r\nspin_unlock(&fwc->lock);\r\n}\r\nstatic void fw_finish_direct_load(struct device *device,\r\nstruct firmware_buf *buf)\r\n{\r\nmutex_lock(&fw_lock);\r\nset_bit(FW_STATUS_DONE, &buf->status);\r\ncomplete_all(&buf->completion);\r\nmutex_unlock(&fw_lock);\r\n}\r\nstatic int\r\nfw_get_filesystem_firmware(struct device *device, struct firmware_buf *buf)\r\n{\r\nloff_t size;\r\nint i, len;\r\nint rc = -ENOENT;\r\nchar *path;\r\nenum kernel_read_file_id id = READING_FIRMWARE;\r\nsize_t msize = INT_MAX;\r\nif (buf->data) {\r\nid = READING_FIRMWARE_PREALLOC_BUFFER;\r\nmsize = buf->allocated_size;\r\n}\r\npath = __getname();\r\nif (!path)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(fw_path); i++) {\r\nif (!fw_path[i][0])\r\ncontinue;\r\nlen = snprintf(path, PATH_MAX, "%s/%s",\r\nfw_path[i], buf->fw_id);\r\nif (len >= PATH_MAX) {\r\nrc = -ENAMETOOLONG;\r\nbreak;\r\n}\r\nbuf->size = 0;\r\nrc = kernel_read_file_from_path(path, &buf->data, &size, msize,\r\nid);\r\nif (rc) {\r\nif (rc == -ENOENT)\r\ndev_dbg(device, "loading %s failed with error %d\n",\r\npath, rc);\r\nelse\r\ndev_warn(device, "loading %s failed with error %d\n",\r\npath, rc);\r\ncontinue;\r\n}\r\ndev_dbg(device, "direct-loading %s\n", buf->fw_id);\r\nbuf->size = size;\r\nfw_finish_direct_load(device, buf);\r\nbreak;\r\n}\r\n__putname(path);\r\nreturn rc;\r\n}\r\nstatic void firmware_free_data(const struct firmware *fw)\r\n{\r\nif (!fw->priv) {\r\nvfree(fw->data);\r\nreturn;\r\n}\r\nfw_free_buf(fw->priv);\r\n}\r\nstatic void fw_set_page_data(struct firmware_buf *buf, struct firmware *fw)\r\n{\r\nfw->priv = buf;\r\n#ifdef CONFIG_FW_LOADER_USER_HELPER\r\nfw->pages = buf->pages;\r\n#endif\r\nfw->size = buf->size;\r\nfw->data = buf->data;\r\npr_debug("%s: fw-%s buf=%p data=%p size=%u\n",\r\n__func__, buf->fw_id, buf, buf->data,\r\n(unsigned int)buf->size);\r\n}\r\nstatic void fw_name_devm_release(struct device *dev, void *res)\r\n{\r\nstruct fw_name_devm *fwn = res;\r\nif (fwn->magic == (unsigned long)&fw_cache)\r\npr_debug("%s: fw_name-%s devm-%p released\n",\r\n__func__, fwn->name, res);\r\nkfree_const(fwn->name);\r\n}\r\nstatic int fw_devm_match(struct device *dev, void *res,\r\nvoid *match_data)\r\n{\r\nstruct fw_name_devm *fwn = res;\r\nreturn (fwn->magic == (unsigned long)&fw_cache) &&\r\n!strcmp(fwn->name, match_data);\r\n}\r\nstatic struct fw_name_devm *fw_find_devm_name(struct device *dev,\r\nconst char *name)\r\n{\r\nstruct fw_name_devm *fwn;\r\nfwn = devres_find(dev, fw_name_devm_release,\r\nfw_devm_match, (void *)name);\r\nreturn fwn;\r\n}\r\nstatic int fw_add_devm_name(struct device *dev, const char *name)\r\n{\r\nstruct fw_name_devm *fwn;\r\nfwn = fw_find_devm_name(dev, name);\r\nif (fwn)\r\nreturn 1;\r\nfwn = devres_alloc(fw_name_devm_release, sizeof(struct fw_name_devm),\r\nGFP_KERNEL);\r\nif (!fwn)\r\nreturn -ENOMEM;\r\nfwn->name = kstrdup_const(name, GFP_KERNEL);\r\nif (!fwn->name) {\r\ndevres_free(fwn);\r\nreturn -ENOMEM;\r\n}\r\nfwn->magic = (unsigned long)&fw_cache;\r\ndevres_add(dev, fwn);\r\nreturn 0;\r\n}\r\nstatic int fw_add_devm_name(struct device *dev, const char *name)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct firmware_priv *to_firmware_priv(struct device *dev)\r\n{\r\nreturn container_of(dev, struct firmware_priv, dev);\r\n}\r\nstatic void __fw_load_abort(struct firmware_buf *buf)\r\n{\r\nif (test_bit(FW_STATUS_DONE, &buf->status))\r\nreturn;\r\nlist_del_init(&buf->pending_list);\r\nset_bit(FW_STATUS_ABORT, &buf->status);\r\ncomplete_all(&buf->completion);\r\n}\r\nstatic void fw_load_abort(struct firmware_priv *fw_priv)\r\n{\r\nstruct firmware_buf *buf = fw_priv->buf;\r\n__fw_load_abort(buf);\r\nfw_priv->buf = NULL;\r\n}\r\nstatic int fw_shutdown_notify(struct notifier_block *unused1,\r\nunsigned long unused2, void *unused3)\r\n{\r\nmutex_lock(&fw_lock);\r\nwhile (!list_empty(&pending_fw_head))\r\n__fw_load_abort(list_first_entry(&pending_fw_head,\r\nstruct firmware_buf,\r\npending_list));\r\nmutex_unlock(&fw_lock);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic ssize_t timeout_show(struct class *class, struct class_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", loading_timeout);\r\n}\r\nstatic ssize_t timeout_store(struct class *class, struct class_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nloading_timeout = simple_strtol(buf, NULL, 10);\r\nif (loading_timeout < 0)\r\nloading_timeout = 0;\r\nreturn count;\r\n}\r\nstatic void fw_dev_release(struct device *dev)\r\n{\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nkfree(fw_priv);\r\n}\r\nstatic int do_firmware_uevent(struct firmware_priv *fw_priv, struct kobj_uevent_env *env)\r\n{\r\nif (add_uevent_var(env, "FIRMWARE=%s", fw_priv->buf->fw_id))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "TIMEOUT=%i", loading_timeout))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "ASYNC=%d", fw_priv->nowait))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nint err = 0;\r\nmutex_lock(&fw_lock);\r\nif (fw_priv->buf)\r\nerr = do_firmware_uevent(fw_priv, env);\r\nmutex_unlock(&fw_lock);\r\nreturn err;\r\n}\r\nstatic ssize_t firmware_loading_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nint loading = 0;\r\nmutex_lock(&fw_lock);\r\nif (fw_priv->buf)\r\nloading = test_bit(FW_STATUS_LOADING, &fw_priv->buf->status);\r\nmutex_unlock(&fw_lock);\r\nreturn sprintf(buf, "%d\n", loading);\r\n}\r\nstatic int fw_map_pages_buf(struct firmware_buf *buf)\r\n{\r\nif (!buf->is_paged_buf)\r\nreturn 0;\r\nvunmap(buf->data);\r\nbuf->data = vmap(buf->pages, buf->nr_pages, 0, PAGE_KERNEL_RO);\r\nif (!buf->data)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic ssize_t firmware_loading_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nstruct firmware_buf *fw_buf;\r\nssize_t written = count;\r\nint loading = simple_strtol(buf, NULL, 10);\r\nint i;\r\nmutex_lock(&fw_lock);\r\nfw_buf = fw_priv->buf;\r\nif (!fw_buf)\r\ngoto out;\r\nswitch (loading) {\r\ncase 1:\r\nif (!test_bit(FW_STATUS_DONE, &fw_buf->status)) {\r\nfor (i = 0; i < fw_buf->nr_pages; i++)\r\n__free_page(fw_buf->pages[i]);\r\nvfree(fw_buf->pages);\r\nfw_buf->pages = NULL;\r\nfw_buf->page_array_size = 0;\r\nfw_buf->nr_pages = 0;\r\nset_bit(FW_STATUS_LOADING, &fw_buf->status);\r\n}\r\nbreak;\r\ncase 0:\r\nif (test_bit(FW_STATUS_LOADING, &fw_buf->status)) {\r\nint rc;\r\nset_bit(FW_STATUS_DONE, &fw_buf->status);\r\nclear_bit(FW_STATUS_LOADING, &fw_buf->status);\r\nrc = fw_map_pages_buf(fw_buf);\r\nif (rc)\r\ndev_err(dev, "%s: map pages failed\n",\r\n__func__);\r\nelse\r\nrc = security_kernel_post_read_file(NULL,\r\nfw_buf->data, fw_buf->size,\r\nREADING_FIRMWARE);\r\nlist_del_init(&fw_buf->pending_list);\r\nif (rc) {\r\nset_bit(FW_STATUS_ABORT, &fw_buf->status);\r\nwritten = rc;\r\n}\r\ncomplete_all(&fw_buf->completion);\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(dev, "%s: unexpected value (%d)\n", __func__, loading);\r\ncase -1:\r\nfw_load_abort(fw_priv);\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&fw_lock);\r\nreturn written;\r\n}\r\nstatic void firmware_rw_buf(struct firmware_buf *buf, char *buffer,\r\nloff_t offset, size_t count, bool read)\r\n{\r\nif (read)\r\nmemcpy(buffer, buf->data + offset, count);\r\nelse\r\nmemcpy(buf->data + offset, buffer, count);\r\n}\r\nstatic void firmware_rw(struct firmware_buf *buf, char *buffer,\r\nloff_t offset, size_t count, bool read)\r\n{\r\nwhile (count) {\r\nvoid *page_data;\r\nint page_nr = offset >> PAGE_SHIFT;\r\nint page_ofs = offset & (PAGE_SIZE-1);\r\nint page_cnt = min_t(size_t, PAGE_SIZE - page_ofs, count);\r\npage_data = kmap(buf->pages[page_nr]);\r\nif (read)\r\nmemcpy(buffer, page_data + page_ofs, page_cnt);\r\nelse\r\nmemcpy(page_data + page_ofs, buffer, page_cnt);\r\nkunmap(buf->pages[page_nr]);\r\nbuffer += page_cnt;\r\noffset += page_cnt;\r\ncount -= page_cnt;\r\n}\r\n}\r\nstatic ssize_t firmware_data_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t offset, size_t count)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nstruct firmware_buf *buf;\r\nssize_t ret_count;\r\nmutex_lock(&fw_lock);\r\nbuf = fw_priv->buf;\r\nif (!buf || test_bit(FW_STATUS_DONE, &buf->status)) {\r\nret_count = -ENODEV;\r\ngoto out;\r\n}\r\nif (offset > buf->size) {\r\nret_count = 0;\r\ngoto out;\r\n}\r\nif (count > buf->size - offset)\r\ncount = buf->size - offset;\r\nret_count = count;\r\nif (buf->data)\r\nfirmware_rw_buf(buf, buffer, offset, count, true);\r\nelse\r\nfirmware_rw(buf, buffer, offset, count, true);\r\nout:\r\nmutex_unlock(&fw_lock);\r\nreturn ret_count;\r\n}\r\nstatic int fw_realloc_buffer(struct firmware_priv *fw_priv, int min_size)\r\n{\r\nstruct firmware_buf *buf = fw_priv->buf;\r\nint pages_needed = PAGE_ALIGN(min_size) >> PAGE_SHIFT;\r\nif (buf->page_array_size < pages_needed) {\r\nint new_array_size = max(pages_needed,\r\nbuf->page_array_size * 2);\r\nstruct page **new_pages;\r\nnew_pages = vmalloc(new_array_size * sizeof(void *));\r\nif (!new_pages) {\r\nfw_load_abort(fw_priv);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(new_pages, buf->pages,\r\nbuf->page_array_size * sizeof(void *));\r\nmemset(&new_pages[buf->page_array_size], 0, sizeof(void *) *\r\n(new_array_size - buf->page_array_size));\r\nvfree(buf->pages);\r\nbuf->pages = new_pages;\r\nbuf->page_array_size = new_array_size;\r\n}\r\nwhile (buf->nr_pages < pages_needed) {\r\nbuf->pages[buf->nr_pages] =\r\nalloc_page(GFP_KERNEL | __GFP_HIGHMEM);\r\nif (!buf->pages[buf->nr_pages]) {\r\nfw_load_abort(fw_priv);\r\nreturn -ENOMEM;\r\n}\r\nbuf->nr_pages++;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t firmware_data_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t offset, size_t count)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct firmware_priv *fw_priv = to_firmware_priv(dev);\r\nstruct firmware_buf *buf;\r\nssize_t retval;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nmutex_lock(&fw_lock);\r\nbuf = fw_priv->buf;\r\nif (!buf || test_bit(FW_STATUS_DONE, &buf->status)) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (buf->data) {\r\nif (offset + count > buf->allocated_size) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nfirmware_rw_buf(buf, buffer, offset, count, false);\r\nretval = count;\r\n} else {\r\nretval = fw_realloc_buffer(fw_priv, offset + count);\r\nif (retval)\r\ngoto out;\r\nretval = count;\r\nfirmware_rw(buf, buffer, offset, count, false);\r\n}\r\nbuf->size = max_t(size_t, offset + count, buf->size);\r\nout:\r\nmutex_unlock(&fw_lock);\r\nreturn retval;\r\n}\r\nstatic struct firmware_priv *\r\nfw_create_instance(struct firmware *firmware, const char *fw_name,\r\nstruct device *device, unsigned int opt_flags)\r\n{\r\nstruct firmware_priv *fw_priv;\r\nstruct device *f_dev;\r\nfw_priv = kzalloc(sizeof(*fw_priv), GFP_KERNEL);\r\nif (!fw_priv) {\r\nfw_priv = ERR_PTR(-ENOMEM);\r\ngoto exit;\r\n}\r\nfw_priv->nowait = !!(opt_flags & FW_OPT_NOWAIT);\r\nfw_priv->fw = firmware;\r\nf_dev = &fw_priv->dev;\r\ndevice_initialize(f_dev);\r\ndev_set_name(f_dev, "%s", fw_name);\r\nf_dev->parent = device;\r\nf_dev->class = &firmware_class;\r\nf_dev->groups = fw_dev_attr_groups;\r\nexit:\r\nreturn fw_priv;\r\n}\r\nstatic int _request_firmware_load(struct firmware_priv *fw_priv,\r\nunsigned int opt_flags, long timeout)\r\n{\r\nint retval = 0;\r\nstruct device *f_dev = &fw_priv->dev;\r\nstruct firmware_buf *buf = fw_priv->buf;\r\nif (!buf->data)\r\nbuf->is_paged_buf = true;\r\ndev_set_uevent_suppress(f_dev, true);\r\nretval = device_add(f_dev);\r\nif (retval) {\r\ndev_err(f_dev, "%s: device_register failed\n", __func__);\r\ngoto err_put_dev;\r\n}\r\nmutex_lock(&fw_lock);\r\nlist_add(&buf->pending_list, &pending_fw_head);\r\nmutex_unlock(&fw_lock);\r\nif (opt_flags & FW_OPT_UEVENT) {\r\nbuf->need_uevent = true;\r\ndev_set_uevent_suppress(f_dev, false);\r\ndev_dbg(f_dev, "firmware: requesting %s\n", buf->fw_id);\r\nkobject_uevent(&fw_priv->dev.kobj, KOBJ_ADD);\r\n} else {\r\ntimeout = MAX_JIFFY_OFFSET;\r\n}\r\nretval = wait_for_completion_interruptible_timeout(&buf->completion,\r\ntimeout);\r\nif (retval == -ERESTARTSYS || !retval) {\r\nmutex_lock(&fw_lock);\r\nfw_load_abort(fw_priv);\r\nmutex_unlock(&fw_lock);\r\n} else if (retval > 0) {\r\nretval = 0;\r\n}\r\nif (is_fw_load_aborted(buf))\r\nretval = -EAGAIN;\r\nelse if (buf->is_paged_buf && !buf->data)\r\nretval = -ENOMEM;\r\ndevice_del(f_dev);\r\nerr_put_dev:\r\nput_device(f_dev);\r\nreturn retval;\r\n}\r\nstatic int fw_load_from_user_helper(struct firmware *firmware,\r\nconst char *name, struct device *device,\r\nunsigned int opt_flags, long timeout)\r\n{\r\nstruct firmware_priv *fw_priv;\r\nfw_priv = fw_create_instance(firmware, name, device, opt_flags);\r\nif (IS_ERR(fw_priv))\r\nreturn PTR_ERR(fw_priv);\r\nfw_priv->buf = firmware->priv;\r\nreturn _request_firmware_load(fw_priv, opt_flags, timeout);\r\n}\r\nstatic void kill_requests_without_uevent(void)\r\n{\r\nstruct firmware_buf *buf;\r\nstruct firmware_buf *next;\r\nmutex_lock(&fw_lock);\r\nlist_for_each_entry_safe(buf, next, &pending_fw_head, pending_list) {\r\nif (!buf->need_uevent)\r\n__fw_load_abort(buf);\r\n}\r\nmutex_unlock(&fw_lock);\r\n}\r\nstatic inline int\r\nfw_load_from_user_helper(struct firmware *firmware, const char *name,\r\nstruct device *device, unsigned int opt_flags,\r\nlong timeout)\r\n{\r\nreturn -ENOENT;\r\n}\r\nstatic inline void kill_requests_without_uevent(void) { }\r\nstatic int sync_cached_firmware_buf(struct firmware_buf *buf)\r\n{\r\nint ret = 0;\r\nmutex_lock(&fw_lock);\r\nwhile (!test_bit(FW_STATUS_DONE, &buf->status)) {\r\nif (is_fw_load_aborted(buf)) {\r\nret = -ENOENT;\r\nbreak;\r\n}\r\nmutex_unlock(&fw_lock);\r\nret = wait_for_completion_interruptible(&buf->completion);\r\nmutex_lock(&fw_lock);\r\n}\r\nmutex_unlock(&fw_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\n_request_firmware_prepare(struct firmware **firmware_p, const char *name,\r\nstruct device *device, void *dbuf, size_t size)\r\n{\r\nstruct firmware *firmware;\r\nstruct firmware_buf *buf;\r\nint ret;\r\n*firmware_p = firmware = kzalloc(sizeof(*firmware), GFP_KERNEL);\r\nif (!firmware) {\r\ndev_err(device, "%s: kmalloc(struct firmware) failed\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nif (fw_get_builtin_firmware(firmware, name, dbuf, size)) {\r\ndev_dbg(device, "using built-in %s\n", name);\r\nreturn 0;\r\n}\r\nret = fw_lookup_and_allocate_buf(name, &fw_cache, &buf, dbuf, size);\r\nfirmware->priv = buf;\r\nif (ret > 0) {\r\nret = sync_cached_firmware_buf(buf);\r\nif (!ret) {\r\nfw_set_page_data(buf, firmware);\r\nreturn 0;\r\n}\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 1;\r\n}\r\nstatic int assign_firmware_buf(struct firmware *fw, struct device *device,\r\nunsigned int opt_flags)\r\n{\r\nstruct firmware_buf *buf = fw->priv;\r\nmutex_lock(&fw_lock);\r\nif (!buf->size || is_fw_load_aborted(buf)) {\r\nmutex_unlock(&fw_lock);\r\nreturn -ENOENT;\r\n}\r\nif (device && (opt_flags & FW_OPT_UEVENT) &&\r\n!(opt_flags & FW_OPT_NOCACHE))\r\nfw_add_devm_name(device, buf->fw_id);\r\nif (!(opt_flags & FW_OPT_NOCACHE) &&\r\nbuf->fwc->state == FW_LOADER_START_CACHE) {\r\nif (fw_cache_piggyback_on_request(buf->fw_id))\r\nkref_get(&buf->ref);\r\n}\r\nfw_set_page_data(buf, fw);\r\nmutex_unlock(&fw_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\n_request_firmware(const struct firmware **firmware_p, const char *name,\r\nstruct device *device, void *buf, size_t size,\r\nunsigned int opt_flags)\r\n{\r\nstruct firmware *fw = NULL;\r\nlong timeout;\r\nint ret;\r\nif (!firmware_p)\r\nreturn -EINVAL;\r\nif (!name || name[0] == '\0') {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = _request_firmware_prepare(&fw, name, device, buf, size);\r\nif (ret <= 0)\r\ngoto out;\r\nret = 0;\r\ntimeout = firmware_loading_timeout();\r\nif (opt_flags & FW_OPT_NOWAIT) {\r\ntimeout = usermodehelper_read_lock_wait(timeout);\r\nif (!timeout) {\r\ndev_dbg(device, "firmware: %s loading timed out\n",\r\nname);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n} else {\r\nret = usermodehelper_read_trylock();\r\nif (WARN_ON(ret)) {\r\ndev_err(device, "firmware: %s will not be loaded\n",\r\nname);\r\ngoto out;\r\n}\r\n}\r\nret = fw_get_filesystem_firmware(device, fw->priv);\r\nif (ret) {\r\nif (!(opt_flags & FW_OPT_NO_WARN))\r\ndev_warn(device,\r\n"Direct firmware load for %s failed with error %d\n",\r\nname, ret);\r\nif (opt_flags & FW_OPT_USERHELPER) {\r\ndev_warn(device, "Falling back to user helper\n");\r\nret = fw_load_from_user_helper(fw, name, device,\r\nopt_flags, timeout);\r\n}\r\n}\r\nif (!ret)\r\nret = assign_firmware_buf(fw, device, opt_flags);\r\nusermodehelper_read_unlock();\r\nout:\r\nif (ret < 0) {\r\nrelease_firmware(fw);\r\nfw = NULL;\r\n}\r\n*firmware_p = fw;\r\nreturn ret;\r\n}\r\nint\r\nrequest_firmware(const struct firmware **firmware_p, const char *name,\r\nstruct device *device)\r\n{\r\nint ret;\r\n__module_get(THIS_MODULE);\r\nret = _request_firmware(firmware_p, name, device, NULL, 0,\r\nFW_OPT_UEVENT | FW_OPT_FALLBACK);\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nint request_firmware_direct(const struct firmware **firmware_p,\r\nconst char *name, struct device *device)\r\n{\r\nint ret;\r\n__module_get(THIS_MODULE);\r\nret = _request_firmware(firmware_p, name, device, NULL, 0,\r\nFW_OPT_UEVENT | FW_OPT_NO_WARN);\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nint\r\nrequest_firmware_into_buf(const struct firmware **firmware_p, const char *name,\r\nstruct device *device, void *buf, size_t size)\r\n{\r\nint ret;\r\n__module_get(THIS_MODULE);\r\nret = _request_firmware(firmware_p, name, device, buf, size,\r\nFW_OPT_UEVENT | FW_OPT_FALLBACK |\r\nFW_OPT_NOCACHE);\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nvoid release_firmware(const struct firmware *fw)\r\n{\r\nif (fw) {\r\nif (!fw_is_builtin_firmware(fw))\r\nfirmware_free_data(fw);\r\nkfree(fw);\r\n}\r\n}\r\nstatic void request_firmware_work_func(struct work_struct *work)\r\n{\r\nstruct firmware_work *fw_work;\r\nconst struct firmware *fw;\r\nfw_work = container_of(work, struct firmware_work, work);\r\n_request_firmware(&fw, fw_work->name, fw_work->device, NULL, 0,\r\nfw_work->opt_flags);\r\nfw_work->cont(fw, fw_work->context);\r\nput_device(fw_work->device);\r\nmodule_put(fw_work->module);\r\nkfree_const(fw_work->name);\r\nkfree(fw_work);\r\n}\r\nint\r\nrequest_firmware_nowait(\r\nstruct module *module, bool uevent,\r\nconst char *name, struct device *device, gfp_t gfp, void *context,\r\nvoid (*cont)(const struct firmware *fw, void *context))\r\n{\r\nstruct firmware_work *fw_work;\r\nfw_work = kzalloc(sizeof(struct firmware_work), gfp);\r\nif (!fw_work)\r\nreturn -ENOMEM;\r\nfw_work->module = module;\r\nfw_work->name = kstrdup_const(name, gfp);\r\nif (!fw_work->name) {\r\nkfree(fw_work);\r\nreturn -ENOMEM;\r\n}\r\nfw_work->device = device;\r\nfw_work->context = context;\r\nfw_work->cont = cont;\r\nfw_work->opt_flags = FW_OPT_NOWAIT | FW_OPT_FALLBACK |\r\n(uevent ? FW_OPT_UEVENT : FW_OPT_USERHELPER);\r\nif (!try_module_get(module)) {\r\nkfree_const(fw_work->name);\r\nkfree(fw_work);\r\nreturn -EFAULT;\r\n}\r\nget_device(fw_work->device);\r\nINIT_WORK(&fw_work->work, request_firmware_work_func);\r\nschedule_work(&fw_work->work);\r\nreturn 0;\r\n}\r\nstatic int cache_firmware(const char *fw_name)\r\n{\r\nint ret;\r\nconst struct firmware *fw;\r\npr_debug("%s: %s\n", __func__, fw_name);\r\nret = request_firmware(&fw, fw_name, NULL);\r\nif (!ret)\r\nkfree(fw);\r\npr_debug("%s: %s ret=%d\n", __func__, fw_name, ret);\r\nreturn ret;\r\n}\r\nstatic struct firmware_buf *fw_lookup_buf(const char *fw_name)\r\n{\r\nstruct firmware_buf *tmp;\r\nstruct firmware_cache *fwc = &fw_cache;\r\nspin_lock(&fwc->lock);\r\ntmp = __fw_lookup_buf(fw_name);\r\nspin_unlock(&fwc->lock);\r\nreturn tmp;\r\n}\r\nstatic int uncache_firmware(const char *fw_name)\r\n{\r\nstruct firmware_buf *buf;\r\nstruct firmware fw;\r\npr_debug("%s: %s\n", __func__, fw_name);\r\nif (fw_get_builtin_firmware(&fw, fw_name, NULL, 0))\r\nreturn 0;\r\nbuf = fw_lookup_buf(fw_name);\r\nif (buf) {\r\nfw_free_buf(buf);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct fw_cache_entry *alloc_fw_cache_entry(const char *name)\r\n{\r\nstruct fw_cache_entry *fce;\r\nfce = kzalloc(sizeof(*fce), GFP_ATOMIC);\r\nif (!fce)\r\ngoto exit;\r\nfce->name = kstrdup_const(name, GFP_ATOMIC);\r\nif (!fce->name) {\r\nkfree(fce);\r\nfce = NULL;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn fce;\r\n}\r\nstatic int __fw_entry_found(const char *name)\r\n{\r\nstruct firmware_cache *fwc = &fw_cache;\r\nstruct fw_cache_entry *fce;\r\nlist_for_each_entry(fce, &fwc->fw_names, list) {\r\nif (!strcmp(fce->name, name))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fw_cache_piggyback_on_request(const char *name)\r\n{\r\nstruct firmware_cache *fwc = &fw_cache;\r\nstruct fw_cache_entry *fce;\r\nint ret = 0;\r\nspin_lock(&fwc->name_lock);\r\nif (__fw_entry_found(name))\r\ngoto found;\r\nfce = alloc_fw_cache_entry(name);\r\nif (fce) {\r\nret = 1;\r\nlist_add(&fce->list, &fwc->fw_names);\r\npr_debug("%s: fw: %s\n", __func__, name);\r\n}\r\nfound:\r\nspin_unlock(&fwc->name_lock);\r\nreturn ret;\r\n}\r\nstatic void free_fw_cache_entry(struct fw_cache_entry *fce)\r\n{\r\nkfree_const(fce->name);\r\nkfree(fce);\r\n}\r\nstatic void __async_dev_cache_fw_image(void *fw_entry,\r\nasync_cookie_t cookie)\r\n{\r\nstruct fw_cache_entry *fce = fw_entry;\r\nstruct firmware_cache *fwc = &fw_cache;\r\nint ret;\r\nret = cache_firmware(fce->name);\r\nif (ret) {\r\nspin_lock(&fwc->name_lock);\r\nlist_del(&fce->list);\r\nspin_unlock(&fwc->name_lock);\r\nfree_fw_cache_entry(fce);\r\n}\r\n}\r\nstatic void dev_create_fw_entry(struct device *dev, void *res,\r\nvoid *data)\r\n{\r\nstruct fw_name_devm *fwn = res;\r\nconst char *fw_name = fwn->name;\r\nstruct list_head *head = data;\r\nstruct fw_cache_entry *fce;\r\nfce = alloc_fw_cache_entry(fw_name);\r\nif (fce)\r\nlist_add(&fce->list, head);\r\n}\r\nstatic int devm_name_match(struct device *dev, void *res,\r\nvoid *match_data)\r\n{\r\nstruct fw_name_devm *fwn = res;\r\nreturn (fwn->magic == (unsigned long)match_data);\r\n}\r\nstatic void dev_cache_fw_image(struct device *dev, void *data)\r\n{\r\nLIST_HEAD(todo);\r\nstruct fw_cache_entry *fce;\r\nstruct fw_cache_entry *fce_next;\r\nstruct firmware_cache *fwc = &fw_cache;\r\ndevres_for_each_res(dev, fw_name_devm_release,\r\ndevm_name_match, &fw_cache,\r\ndev_create_fw_entry, &todo);\r\nlist_for_each_entry_safe(fce, fce_next, &todo, list) {\r\nlist_del(&fce->list);\r\nspin_lock(&fwc->name_lock);\r\nif (!__fw_entry_found(fce->name)) {\r\nlist_add(&fce->list, &fwc->fw_names);\r\n} else {\r\nfree_fw_cache_entry(fce);\r\nfce = NULL;\r\n}\r\nspin_unlock(&fwc->name_lock);\r\nif (fce)\r\nasync_schedule_domain(__async_dev_cache_fw_image,\r\n(void *)fce,\r\n&fw_cache_domain);\r\n}\r\n}\r\nstatic void __device_uncache_fw_images(void)\r\n{\r\nstruct firmware_cache *fwc = &fw_cache;\r\nstruct fw_cache_entry *fce;\r\nspin_lock(&fwc->name_lock);\r\nwhile (!list_empty(&fwc->fw_names)) {\r\nfce = list_entry(fwc->fw_names.next,\r\nstruct fw_cache_entry, list);\r\nlist_del(&fce->list);\r\nspin_unlock(&fwc->name_lock);\r\nuncache_firmware(fce->name);\r\nfree_fw_cache_entry(fce);\r\nspin_lock(&fwc->name_lock);\r\n}\r\nspin_unlock(&fwc->name_lock);\r\n}\r\nstatic void device_cache_fw_images(void)\r\n{\r\nstruct firmware_cache *fwc = &fw_cache;\r\nint old_timeout;\r\nDEFINE_WAIT(wait);\r\npr_debug("%s\n", __func__);\r\ncancel_delayed_work_sync(&fwc->work);\r\nold_timeout = loading_timeout;\r\nloading_timeout = 10;\r\nmutex_lock(&fw_lock);\r\nfwc->state = FW_LOADER_START_CACHE;\r\ndpm_for_each_dev(NULL, dev_cache_fw_image);\r\nmutex_unlock(&fw_lock);\r\nasync_synchronize_full_domain(&fw_cache_domain);\r\nloading_timeout = old_timeout;\r\n}\r\nstatic void device_uncache_fw_images(void)\r\n{\r\npr_debug("%s\n", __func__);\r\n__device_uncache_fw_images();\r\n}\r\nstatic void device_uncache_fw_images_work(struct work_struct *work)\r\n{\r\ndevice_uncache_fw_images();\r\n}\r\nstatic void device_uncache_fw_images_delay(unsigned long delay)\r\n{\r\nqueue_delayed_work(system_power_efficient_wq, &fw_cache.work,\r\nmsecs_to_jiffies(delay));\r\n}\r\nstatic int fw_pm_notify(struct notifier_block *notify_block,\r\nunsigned long mode, void *unused)\r\n{\r\nswitch (mode) {\r\ncase PM_HIBERNATION_PREPARE:\r\ncase PM_SUSPEND_PREPARE:\r\ncase PM_RESTORE_PREPARE:\r\nkill_requests_without_uevent();\r\ndevice_cache_fw_images();\r\nbreak;\r\ncase PM_POST_SUSPEND:\r\ncase PM_POST_HIBERNATION:\r\ncase PM_POST_RESTORE:\r\nmutex_lock(&fw_lock);\r\nfw_cache.state = FW_LOADER_NO_CACHE;\r\nmutex_unlock(&fw_lock);\r\ndevice_uncache_fw_images_delay(10 * MSEC_PER_SEC);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fw_suspend(void)\r\n{\r\nfw_cache.state = FW_LOADER_NO_CACHE;\r\nreturn 0;\r\n}\r\nstatic int fw_cache_piggyback_on_request(const char *name)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init fw_cache_init(void)\r\n{\r\nspin_lock_init(&fw_cache.lock);\r\nINIT_LIST_HEAD(&fw_cache.head);\r\nfw_cache.state = FW_LOADER_NO_CACHE;\r\n#ifdef CONFIG_PM_SLEEP\r\nspin_lock_init(&fw_cache.name_lock);\r\nINIT_LIST_HEAD(&fw_cache.fw_names);\r\nINIT_DELAYED_WORK(&fw_cache.work,\r\ndevice_uncache_fw_images_work);\r\nfw_cache.pm_notify.notifier_call = fw_pm_notify;\r\nregister_pm_notifier(&fw_cache.pm_notify);\r\nregister_syscore_ops(&fw_syscore_ops);\r\n#endif\r\n}\r\nstatic int __init firmware_class_init(void)\r\n{\r\nfw_cache_init();\r\n#ifdef CONFIG_FW_LOADER_USER_HELPER\r\nregister_reboot_notifier(&fw_shutdown_nb);\r\nreturn class_register(&firmware_class);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void __exit firmware_class_exit(void)\r\n{\r\n#ifdef CONFIG_PM_SLEEP\r\nunregister_syscore_ops(&fw_syscore_ops);\r\nunregister_pm_notifier(&fw_cache.pm_notify);\r\n#endif\r\n#ifdef CONFIG_FW_LOADER_USER_HELPER\r\nunregister_reboot_notifier(&fw_shutdown_nb);\r\nclass_unregister(&firmware_class);\r\n#endif\r\n}
