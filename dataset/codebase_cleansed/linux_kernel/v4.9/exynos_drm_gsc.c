static int gsc_sw_reset(struct gsc_context *ctx)\r\n{\r\nu32 cfg;\r\nint count = GSC_RESET_TIMEOUT;\r\ncfg = (GSC_SW_RESET_SRESET);\r\ngsc_write(cfg, GSC_SW_RESET);\r\nwhile (count--) {\r\ncfg = gsc_read(GSC_SW_RESET);\r\nif (!cfg)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (cfg) {\r\nDRM_ERROR("failed to reset gsc h/w.\n");\r\nreturn -EBUSY;\r\n}\r\ncfg = gsc_read(GSC_IN_BASE_ADDR_Y_MASK);\r\ncfg |= (GSC_IN_BASE_ADDR_MASK |\r\nGSC_IN_BASE_ADDR_PINGPONG(0));\r\ngsc_write(cfg, GSC_IN_BASE_ADDR_Y_MASK);\r\ngsc_write(cfg, GSC_IN_BASE_ADDR_CB_MASK);\r\ngsc_write(cfg, GSC_IN_BASE_ADDR_CR_MASK);\r\ncfg = gsc_read(GSC_OUT_BASE_ADDR_Y_MASK);\r\ncfg |= (GSC_OUT_BASE_ADDR_MASK |\r\nGSC_OUT_BASE_ADDR_PINGPONG(0));\r\ngsc_write(cfg, GSC_OUT_BASE_ADDR_Y_MASK);\r\ngsc_write(cfg, GSC_OUT_BASE_ADDR_CB_MASK);\r\ngsc_write(cfg, GSC_OUT_BASE_ADDR_CR_MASK);\r\nreturn 0;\r\n}\r\nstatic void gsc_set_gscblk_fimd_wb(struct gsc_context *ctx, bool enable)\r\n{\r\nunsigned int gscblk_cfg;\r\nif (!ctx->sysreg)\r\nreturn;\r\nregmap_read(ctx->sysreg, SYSREG_GSCBLK_CFG1, &gscblk_cfg);\r\nif (enable)\r\ngscblk_cfg |= GSC_BLK_DISP1WB_DEST(ctx->id) |\r\nGSC_BLK_GSCL_WB_IN_SRC_SEL(ctx->id) |\r\nGSC_BLK_SW_RESET_WB_DEST(ctx->id);\r\nelse\r\ngscblk_cfg |= GSC_BLK_PXLASYNC_LO_MASK_WB(ctx->id);\r\nregmap_write(ctx->sysreg, SYSREG_GSCBLK_CFG1, gscblk_cfg);\r\n}\r\nstatic void gsc_handle_irq(struct gsc_context *ctx, bool enable,\r\nbool overflow, bool done)\r\n{\r\nu32 cfg;\r\nDRM_DEBUG_KMS("enable[%d]overflow[%d]level[%d]\n",\r\nenable, overflow, done);\r\ncfg = gsc_read(GSC_IRQ);\r\ncfg |= (GSC_IRQ_OR_MASK | GSC_IRQ_FRMDONE_MASK);\r\nif (enable)\r\ncfg |= GSC_IRQ_ENABLE;\r\nelse\r\ncfg &= ~GSC_IRQ_ENABLE;\r\nif (overflow)\r\ncfg &= ~GSC_IRQ_OR_MASK;\r\nelse\r\ncfg |= GSC_IRQ_OR_MASK;\r\nif (done)\r\ncfg &= ~GSC_IRQ_FRMDONE_MASK;\r\nelse\r\ncfg |= GSC_IRQ_FRMDONE_MASK;\r\ngsc_write(cfg, GSC_IRQ);\r\n}\r\nstatic int gsc_src_set_fmt(struct device *dev, u32 fmt)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("fmt[0x%x]\n", fmt);\r\ncfg = gsc_read(GSC_IN_CON);\r\ncfg &= ~(GSC_IN_RGB_TYPE_MASK | GSC_IN_YUV422_1P_ORDER_MASK |\r\nGSC_IN_CHROMA_ORDER_MASK | GSC_IN_FORMAT_MASK |\r\nGSC_IN_TILE_TYPE_MASK | GSC_IN_TILE_MODE |\r\nGSC_IN_CHROM_STRIDE_SEL_MASK | GSC_IN_RB_SWAP_MASK);\r\nswitch (fmt) {\r\ncase DRM_FORMAT_RGB565:\r\ncfg |= GSC_IN_RGB565;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\ncfg |= GSC_IN_XRGB8888;\r\nbreak;\r\ncase DRM_FORMAT_BGRX8888:\r\ncfg |= (GSC_IN_XRGB8888 | GSC_IN_RB_SWAP);\r\nbreak;\r\ncase DRM_FORMAT_YUYV:\r\ncfg |= (GSC_IN_YUV422_1P |\r\nGSC_IN_YUV422_1P_ORDER_LSB_Y |\r\nGSC_IN_CHROMA_ORDER_CBCR);\r\nbreak;\r\ncase DRM_FORMAT_YVYU:\r\ncfg |= (GSC_IN_YUV422_1P |\r\nGSC_IN_YUV422_1P_ORDER_LSB_Y |\r\nGSC_IN_CHROMA_ORDER_CRCB);\r\nbreak;\r\ncase DRM_FORMAT_UYVY:\r\ncfg |= (GSC_IN_YUV422_1P |\r\nGSC_IN_YUV422_1P_OEDER_LSB_C |\r\nGSC_IN_CHROMA_ORDER_CBCR);\r\nbreak;\r\ncase DRM_FORMAT_VYUY:\r\ncfg |= (GSC_IN_YUV422_1P |\r\nGSC_IN_YUV422_1P_OEDER_LSB_C |\r\nGSC_IN_CHROMA_ORDER_CRCB);\r\nbreak;\r\ncase DRM_FORMAT_NV21:\r\ncase DRM_FORMAT_NV61:\r\ncfg |= (GSC_IN_CHROMA_ORDER_CRCB |\r\nGSC_IN_YUV420_2P);\r\nbreak;\r\ncase DRM_FORMAT_YUV422:\r\ncfg |= GSC_IN_YUV422_3P;\r\nbreak;\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\ncfg |= GSC_IN_YUV420_3P;\r\nbreak;\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_NV16:\r\ncfg |= (GSC_IN_CHROMA_ORDER_CBCR |\r\nGSC_IN_YUV420_2P);\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid target yuv order 0x%x.\n", fmt);\r\nreturn -EINVAL;\r\n}\r\ngsc_write(cfg, GSC_IN_CON);\r\nreturn 0;\r\n}\r\nstatic int gsc_src_set_transf(struct device *dev,\r\nenum drm_exynos_degree degree,\r\nenum drm_exynos_flip flip, bool *swap)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("degree[%d]flip[0x%x]\n", degree, flip);\r\ncfg = gsc_read(GSC_IN_CON);\r\ncfg &= ~GSC_IN_ROT_MASK;\r\nswitch (degree) {\r\ncase EXYNOS_DRM_DEGREE_0:\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg |= GSC_IN_ROT_XFLIP;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg |= GSC_IN_ROT_YFLIP;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_90:\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg |= GSC_IN_ROT_90_XFLIP;\r\nelse if (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg |= GSC_IN_ROT_90_YFLIP;\r\nelse\r\ncfg |= GSC_IN_ROT_90;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_180:\r\ncfg |= GSC_IN_ROT_180;\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg &= ~GSC_IN_ROT_XFLIP;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg &= ~GSC_IN_ROT_YFLIP;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_270:\r\ncfg |= GSC_IN_ROT_270;\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg &= ~GSC_IN_ROT_XFLIP;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg &= ~GSC_IN_ROT_YFLIP;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid degree value %d.\n", degree);\r\nreturn -EINVAL;\r\n}\r\ngsc_write(cfg, GSC_IN_CON);\r\nctx->rotation = (cfg & GSC_IN_ROT_90) ? 1 : 0;\r\n*swap = ctx->rotation;\r\nreturn 0;\r\n}\r\nstatic int gsc_src_set_size(struct device *dev, int swap,\r\nstruct drm_exynos_pos *pos, struct drm_exynos_sz *sz)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct drm_exynos_pos img_pos = *pos;\r\nstruct gsc_scaler *sc = &ctx->sc;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("swap[%d]x[%d]y[%d]w[%d]h[%d]\n",\r\nswap, pos->x, pos->y, pos->w, pos->h);\r\nif (swap) {\r\nimg_pos.w = pos->h;\r\nimg_pos.h = pos->w;\r\n}\r\ncfg = (GSC_SRCIMG_OFFSET_X(img_pos.x) |\r\nGSC_SRCIMG_OFFSET_Y(img_pos.y));\r\ngsc_write(cfg, GSC_SRCIMG_OFFSET);\r\ncfg = (GSC_CROPPED_WIDTH(img_pos.w) |\r\nGSC_CROPPED_HEIGHT(img_pos.h));\r\ngsc_write(cfg, GSC_CROPPED_SIZE);\r\nDRM_DEBUG_KMS("hsize[%d]vsize[%d]\n", sz->hsize, sz->vsize);\r\ncfg = gsc_read(GSC_SRCIMG_SIZE);\r\ncfg &= ~(GSC_SRCIMG_HEIGHT_MASK |\r\nGSC_SRCIMG_WIDTH_MASK);\r\ncfg |= (GSC_SRCIMG_WIDTH(sz->hsize) |\r\nGSC_SRCIMG_HEIGHT(sz->vsize));\r\ngsc_write(cfg, GSC_SRCIMG_SIZE);\r\ncfg = gsc_read(GSC_IN_CON);\r\ncfg &= ~GSC_IN_RGB_TYPE_MASK;\r\nDRM_DEBUG_KMS("width[%d]range[%d]\n", pos->w, sc->range);\r\nif (pos->w >= GSC_WIDTH_ITU_709)\r\nif (sc->range)\r\ncfg |= GSC_IN_RGB_HD_WIDE;\r\nelse\r\ncfg |= GSC_IN_RGB_HD_NARROW;\r\nelse\r\nif (sc->range)\r\ncfg |= GSC_IN_RGB_SD_WIDE;\r\nelse\r\ncfg |= GSC_IN_RGB_SD_NARROW;\r\ngsc_write(cfg, GSC_IN_CON);\r\nreturn 0;\r\n}\r\nstatic int gsc_src_set_buf_seq(struct gsc_context *ctx, u32 buf_id,\r\nenum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nbool masked;\r\nu32 cfg;\r\nu32 mask = 0x00000001 << buf_id;\r\nDRM_DEBUG_KMS("buf_id[%d]buf_type[%d]\n", buf_id, buf_type);\r\ncfg = gsc_read(GSC_IN_BASE_ADDR_Y_MASK);\r\nswitch (buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\nmasked = false;\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\nmasked = true;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid buf ctrl parameter.\n");\r\nreturn -EINVAL;\r\n}\r\ncfg &= ~mask;\r\ncfg |= masked << buf_id;\r\ngsc_write(cfg, GSC_IN_BASE_ADDR_Y_MASK);\r\ngsc_write(cfg, GSC_IN_BASE_ADDR_CB_MASK);\r\ngsc_write(cfg, GSC_IN_BASE_ADDR_CR_MASK);\r\nreturn 0;\r\n}\r\nstatic int gsc_src_set_addr(struct device *dev,\r\nstruct drm_exynos_ipp_buf_info *buf_info, u32 buf_id,\r\nenum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_property *property;\r\nif (!c_node) {\r\nDRM_ERROR("failed to get c_node.\n");\r\nreturn -EFAULT;\r\n}\r\nproperty = &c_node->property;\r\nDRM_DEBUG_KMS("prop_id[%d]buf_id[%d]buf_type[%d]\n",\r\nproperty->prop_id, buf_id, buf_type);\r\nif (buf_id > GSC_MAX_SRC) {\r\ndev_info(ippdrv->dev, "invalid buf_id %d.\n", buf_id);\r\nreturn -EINVAL;\r\n}\r\nswitch (buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\ngsc_write(buf_info->base[EXYNOS_DRM_PLANAR_Y],\r\nGSC_IN_BASE_ADDR_Y(buf_id));\r\ngsc_write(buf_info->base[EXYNOS_DRM_PLANAR_CB],\r\nGSC_IN_BASE_ADDR_CB(buf_id));\r\ngsc_write(buf_info->base[EXYNOS_DRM_PLANAR_CR],\r\nGSC_IN_BASE_ADDR_CR(buf_id));\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\ngsc_write(0x0, GSC_IN_BASE_ADDR_Y(buf_id));\r\ngsc_write(0x0, GSC_IN_BASE_ADDR_CB(buf_id));\r\ngsc_write(0x0, GSC_IN_BASE_ADDR_CR(buf_id));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn gsc_src_set_buf_seq(ctx, buf_id, buf_type);\r\n}\r\nstatic int gsc_dst_set_fmt(struct device *dev, u32 fmt)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("fmt[0x%x]\n", fmt);\r\ncfg = gsc_read(GSC_OUT_CON);\r\ncfg &= ~(GSC_OUT_RGB_TYPE_MASK | GSC_OUT_YUV422_1P_ORDER_MASK |\r\nGSC_OUT_CHROMA_ORDER_MASK | GSC_OUT_FORMAT_MASK |\r\nGSC_OUT_CHROM_STRIDE_SEL_MASK | GSC_OUT_RB_SWAP_MASK |\r\nGSC_OUT_GLOBAL_ALPHA_MASK);\r\nswitch (fmt) {\r\ncase DRM_FORMAT_RGB565:\r\ncfg |= GSC_OUT_RGB565;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\ncfg |= GSC_OUT_XRGB8888;\r\nbreak;\r\ncase DRM_FORMAT_BGRX8888:\r\ncfg |= (GSC_OUT_XRGB8888 | GSC_OUT_RB_SWAP);\r\nbreak;\r\ncase DRM_FORMAT_YUYV:\r\ncfg |= (GSC_OUT_YUV422_1P |\r\nGSC_OUT_YUV422_1P_ORDER_LSB_Y |\r\nGSC_OUT_CHROMA_ORDER_CBCR);\r\nbreak;\r\ncase DRM_FORMAT_YVYU:\r\ncfg |= (GSC_OUT_YUV422_1P |\r\nGSC_OUT_YUV422_1P_ORDER_LSB_Y |\r\nGSC_OUT_CHROMA_ORDER_CRCB);\r\nbreak;\r\ncase DRM_FORMAT_UYVY:\r\ncfg |= (GSC_OUT_YUV422_1P |\r\nGSC_OUT_YUV422_1P_OEDER_LSB_C |\r\nGSC_OUT_CHROMA_ORDER_CBCR);\r\nbreak;\r\ncase DRM_FORMAT_VYUY:\r\ncfg |= (GSC_OUT_YUV422_1P |\r\nGSC_OUT_YUV422_1P_OEDER_LSB_C |\r\nGSC_OUT_CHROMA_ORDER_CRCB);\r\nbreak;\r\ncase DRM_FORMAT_NV21:\r\ncase DRM_FORMAT_NV61:\r\ncfg |= (GSC_OUT_CHROMA_ORDER_CRCB | GSC_OUT_YUV420_2P);\r\nbreak;\r\ncase DRM_FORMAT_YUV422:\r\ncase DRM_FORMAT_YUV420:\r\ncase DRM_FORMAT_YVU420:\r\ncfg |= GSC_OUT_YUV420_3P;\r\nbreak;\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_NV16:\r\ncfg |= (GSC_OUT_CHROMA_ORDER_CBCR |\r\nGSC_OUT_YUV420_2P);\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid target yuv order 0x%x.\n", fmt);\r\nreturn -EINVAL;\r\n}\r\ngsc_write(cfg, GSC_OUT_CON);\r\nreturn 0;\r\n}\r\nstatic int gsc_dst_set_transf(struct device *dev,\r\nenum drm_exynos_degree degree,\r\nenum drm_exynos_flip flip, bool *swap)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("degree[%d]flip[0x%x]\n", degree, flip);\r\ncfg = gsc_read(GSC_IN_CON);\r\ncfg &= ~GSC_IN_ROT_MASK;\r\nswitch (degree) {\r\ncase EXYNOS_DRM_DEGREE_0:\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg |= GSC_IN_ROT_XFLIP;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg |= GSC_IN_ROT_YFLIP;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_90:\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg |= GSC_IN_ROT_90_XFLIP;\r\nelse if (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg |= GSC_IN_ROT_90_YFLIP;\r\nelse\r\ncfg |= GSC_IN_ROT_90;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_180:\r\ncfg |= GSC_IN_ROT_180;\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg &= ~GSC_IN_ROT_XFLIP;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg &= ~GSC_IN_ROT_YFLIP;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_270:\r\ncfg |= GSC_IN_ROT_270;\r\nif (flip & EXYNOS_DRM_FLIP_VERTICAL)\r\ncfg &= ~GSC_IN_ROT_XFLIP;\r\nif (flip & EXYNOS_DRM_FLIP_HORIZONTAL)\r\ncfg &= ~GSC_IN_ROT_YFLIP;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid degree value %d.\n", degree);\r\nreturn -EINVAL;\r\n}\r\ngsc_write(cfg, GSC_IN_CON);\r\nctx->rotation = (cfg & GSC_IN_ROT_90) ? 1 : 0;\r\n*swap = ctx->rotation;\r\nreturn 0;\r\n}\r\nstatic int gsc_get_ratio_shift(u32 src, u32 dst, u32 *ratio)\r\n{\r\nDRM_DEBUG_KMS("src[%d]dst[%d]\n", src, dst);\r\nif (src >= dst * 8) {\r\nDRM_ERROR("failed to make ratio and shift.\n");\r\nreturn -EINVAL;\r\n} else if (src >= dst * 4)\r\n*ratio = 4;\r\nelse if (src >= dst * 2)\r\n*ratio = 2;\r\nelse\r\n*ratio = 1;\r\nreturn 0;\r\n}\r\nstatic void gsc_get_prescaler_shfactor(u32 hratio, u32 vratio, u32 *shfactor)\r\n{\r\nif (hratio == 4 && vratio == 4)\r\n*shfactor = 4;\r\nelse if ((hratio == 4 && vratio == 2) ||\r\n(hratio == 2 && vratio == 4))\r\n*shfactor = 3;\r\nelse if ((hratio == 4 && vratio == 1) ||\r\n(hratio == 1 && vratio == 4) ||\r\n(hratio == 2 && vratio == 2))\r\n*shfactor = 2;\r\nelse if (hratio == 1 && vratio == 1)\r\n*shfactor = 0;\r\nelse\r\n*shfactor = 1;\r\n}\r\nstatic int gsc_set_prescaler(struct gsc_context *ctx, struct gsc_scaler *sc,\r\nstruct drm_exynos_pos *src, struct drm_exynos_pos *dst)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nu32 cfg;\r\nu32 src_w, src_h, dst_w, dst_h;\r\nint ret = 0;\r\nsrc_w = src->w;\r\nsrc_h = src->h;\r\nif (ctx->rotation) {\r\ndst_w = dst->h;\r\ndst_h = dst->w;\r\n} else {\r\ndst_w = dst->w;\r\ndst_h = dst->h;\r\n}\r\nret = gsc_get_ratio_shift(src_w, dst_w, &sc->pre_hratio);\r\nif (ret) {\r\ndev_err(ippdrv->dev, "failed to get ratio horizontal.\n");\r\nreturn ret;\r\n}\r\nret = gsc_get_ratio_shift(src_h, dst_h, &sc->pre_vratio);\r\nif (ret) {\r\ndev_err(ippdrv->dev, "failed to get ratio vertical.\n");\r\nreturn ret;\r\n}\r\nDRM_DEBUG_KMS("pre_hratio[%d]pre_vratio[%d]\n",\r\nsc->pre_hratio, sc->pre_vratio);\r\nsc->main_hratio = (src_w << 16) / dst_w;\r\nsc->main_vratio = (src_h << 16) / dst_h;\r\nDRM_DEBUG_KMS("main_hratio[%ld]main_vratio[%ld]\n",\r\nsc->main_hratio, sc->main_vratio);\r\ngsc_get_prescaler_shfactor(sc->pre_hratio, sc->pre_vratio,\r\n&sc->pre_shfactor);\r\nDRM_DEBUG_KMS("pre_shfactor[%d]\n", sc->pre_shfactor);\r\ncfg = (GSC_PRESC_SHFACTOR(sc->pre_shfactor) |\r\nGSC_PRESC_H_RATIO(sc->pre_hratio) |\r\nGSC_PRESC_V_RATIO(sc->pre_vratio));\r\ngsc_write(cfg, GSC_PRE_SCALE_RATIO);\r\nreturn ret;\r\n}\r\nstatic void gsc_set_h_coef(struct gsc_context *ctx, unsigned long main_hratio)\r\n{\r\nint i, j, k, sc_ratio;\r\nif (main_hratio <= GSC_SC_UP_MAX_RATIO)\r\nsc_ratio = 0;\r\nelse if (main_hratio <= GSC_SC_DOWN_RATIO_7_8)\r\nsc_ratio = 1;\r\nelse if (main_hratio <= GSC_SC_DOWN_RATIO_6_8)\r\nsc_ratio = 2;\r\nelse if (main_hratio <= GSC_SC_DOWN_RATIO_5_8)\r\nsc_ratio = 3;\r\nelse if (main_hratio <= GSC_SC_DOWN_RATIO_4_8)\r\nsc_ratio = 4;\r\nelse if (main_hratio <= GSC_SC_DOWN_RATIO_3_8)\r\nsc_ratio = 5;\r\nelse\r\nsc_ratio = 6;\r\nfor (i = 0; i < GSC_COEF_PHASE; i++)\r\nfor (j = 0; j < GSC_COEF_H_8T; j++)\r\nfor (k = 0; k < GSC_COEF_DEPTH; k++)\r\ngsc_write(h_coef_8t[sc_ratio][i][j],\r\nGSC_HCOEF(i, j, k));\r\n}\r\nstatic void gsc_set_v_coef(struct gsc_context *ctx, unsigned long main_vratio)\r\n{\r\nint i, j, k, sc_ratio;\r\nif (main_vratio <= GSC_SC_UP_MAX_RATIO)\r\nsc_ratio = 0;\r\nelse if (main_vratio <= GSC_SC_DOWN_RATIO_7_8)\r\nsc_ratio = 1;\r\nelse if (main_vratio <= GSC_SC_DOWN_RATIO_6_8)\r\nsc_ratio = 2;\r\nelse if (main_vratio <= GSC_SC_DOWN_RATIO_5_8)\r\nsc_ratio = 3;\r\nelse if (main_vratio <= GSC_SC_DOWN_RATIO_4_8)\r\nsc_ratio = 4;\r\nelse if (main_vratio <= GSC_SC_DOWN_RATIO_3_8)\r\nsc_ratio = 5;\r\nelse\r\nsc_ratio = 6;\r\nfor (i = 0; i < GSC_COEF_PHASE; i++)\r\nfor (j = 0; j < GSC_COEF_V_4T; j++)\r\nfor (k = 0; k < GSC_COEF_DEPTH; k++)\r\ngsc_write(v_coef_4t[sc_ratio][i][j],\r\nGSC_VCOEF(i, j, k));\r\n}\r\nstatic void gsc_set_scaler(struct gsc_context *ctx, struct gsc_scaler *sc)\r\n{\r\nu32 cfg;\r\nDRM_DEBUG_KMS("main_hratio[%ld]main_vratio[%ld]\n",\r\nsc->main_hratio, sc->main_vratio);\r\ngsc_set_h_coef(ctx, sc->main_hratio);\r\ncfg = GSC_MAIN_H_RATIO_VALUE(sc->main_hratio);\r\ngsc_write(cfg, GSC_MAIN_H_RATIO);\r\ngsc_set_v_coef(ctx, sc->main_vratio);\r\ncfg = GSC_MAIN_V_RATIO_VALUE(sc->main_vratio);\r\ngsc_write(cfg, GSC_MAIN_V_RATIO);\r\n}\r\nstatic int gsc_dst_set_size(struct device *dev, int swap,\r\nstruct drm_exynos_pos *pos, struct drm_exynos_sz *sz)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct drm_exynos_pos img_pos = *pos;\r\nstruct gsc_scaler *sc = &ctx->sc;\r\nu32 cfg;\r\nDRM_DEBUG_KMS("swap[%d]x[%d]y[%d]w[%d]h[%d]\n",\r\nswap, pos->x, pos->y, pos->w, pos->h);\r\nif (swap) {\r\nimg_pos.w = pos->h;\r\nimg_pos.h = pos->w;\r\n}\r\ncfg = (GSC_DSTIMG_OFFSET_X(pos->x) |\r\nGSC_DSTIMG_OFFSET_Y(pos->y));\r\ngsc_write(cfg, GSC_DSTIMG_OFFSET);\r\ncfg = (GSC_SCALED_WIDTH(img_pos.w) | GSC_SCALED_HEIGHT(img_pos.h));\r\ngsc_write(cfg, GSC_SCALED_SIZE);\r\nDRM_DEBUG_KMS("hsize[%d]vsize[%d]\n", sz->hsize, sz->vsize);\r\ncfg = gsc_read(GSC_DSTIMG_SIZE);\r\ncfg &= ~(GSC_DSTIMG_HEIGHT_MASK |\r\nGSC_DSTIMG_WIDTH_MASK);\r\ncfg |= (GSC_DSTIMG_WIDTH(sz->hsize) |\r\nGSC_DSTIMG_HEIGHT(sz->vsize));\r\ngsc_write(cfg, GSC_DSTIMG_SIZE);\r\ncfg = gsc_read(GSC_OUT_CON);\r\ncfg &= ~GSC_OUT_RGB_TYPE_MASK;\r\nDRM_DEBUG_KMS("width[%d]range[%d]\n", pos->w, sc->range);\r\nif (pos->w >= GSC_WIDTH_ITU_709)\r\nif (sc->range)\r\ncfg |= GSC_OUT_RGB_HD_WIDE;\r\nelse\r\ncfg |= GSC_OUT_RGB_HD_NARROW;\r\nelse\r\nif (sc->range)\r\ncfg |= GSC_OUT_RGB_SD_WIDE;\r\nelse\r\ncfg |= GSC_OUT_RGB_SD_NARROW;\r\ngsc_write(cfg, GSC_OUT_CON);\r\nreturn 0;\r\n}\r\nstatic int gsc_dst_get_buf_seq(struct gsc_context *ctx)\r\n{\r\nu32 cfg, i, buf_num = GSC_REG_SZ;\r\nu32 mask = 0x00000001;\r\ncfg = gsc_read(GSC_OUT_BASE_ADDR_Y_MASK);\r\nfor (i = 0; i < GSC_REG_SZ; i++)\r\nif (cfg & (mask << i))\r\nbuf_num--;\r\nDRM_DEBUG_KMS("buf_num[%d]\n", buf_num);\r\nreturn buf_num;\r\n}\r\nstatic int gsc_dst_set_buf_seq(struct gsc_context *ctx, u32 buf_id,\r\nenum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nbool masked;\r\nu32 cfg;\r\nu32 mask = 0x00000001 << buf_id;\r\nint ret = 0;\r\nDRM_DEBUG_KMS("buf_id[%d]buf_type[%d]\n", buf_id, buf_type);\r\nmutex_lock(&ctx->lock);\r\ncfg = gsc_read(GSC_OUT_BASE_ADDR_Y_MASK);\r\nswitch (buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\nmasked = false;\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\nmasked = true;\r\nbreak;\r\ndefault:\r\ndev_err(ippdrv->dev, "invalid buf ctrl parameter.\n");\r\nret = -EINVAL;\r\ngoto err_unlock;\r\n}\r\ncfg &= ~mask;\r\ncfg |= masked << buf_id;\r\ngsc_write(cfg, GSC_OUT_BASE_ADDR_Y_MASK);\r\ngsc_write(cfg, GSC_OUT_BASE_ADDR_CB_MASK);\r\ngsc_write(cfg, GSC_OUT_BASE_ADDR_CR_MASK);\r\nif (buf_type == IPP_BUF_ENQUEUE &&\r\ngsc_dst_get_buf_seq(ctx) >= GSC_BUF_START)\r\ngsc_handle_irq(ctx, true, false, true);\r\nif (buf_type == IPP_BUF_DEQUEUE &&\r\ngsc_dst_get_buf_seq(ctx) <= GSC_BUF_STOP)\r\ngsc_handle_irq(ctx, false, false, true);\r\nerr_unlock:\r\nmutex_unlock(&ctx->lock);\r\nreturn ret;\r\n}\r\nstatic int gsc_dst_set_addr(struct device *dev,\r\nstruct drm_exynos_ipp_buf_info *buf_info, u32 buf_id,\r\nenum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_property *property;\r\nif (!c_node) {\r\nDRM_ERROR("failed to get c_node.\n");\r\nreturn -EFAULT;\r\n}\r\nproperty = &c_node->property;\r\nDRM_DEBUG_KMS("prop_id[%d]buf_id[%d]buf_type[%d]\n",\r\nproperty->prop_id, buf_id, buf_type);\r\nif (buf_id > GSC_MAX_DST) {\r\ndev_info(ippdrv->dev, "invalid buf_id %d.\n", buf_id);\r\nreturn -EINVAL;\r\n}\r\nswitch (buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\ngsc_write(buf_info->base[EXYNOS_DRM_PLANAR_Y],\r\nGSC_OUT_BASE_ADDR_Y(buf_id));\r\ngsc_write(buf_info->base[EXYNOS_DRM_PLANAR_CB],\r\nGSC_OUT_BASE_ADDR_CB(buf_id));\r\ngsc_write(buf_info->base[EXYNOS_DRM_PLANAR_CR],\r\nGSC_OUT_BASE_ADDR_CR(buf_id));\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\ngsc_write(0x0, GSC_OUT_BASE_ADDR_Y(buf_id));\r\ngsc_write(0x0, GSC_OUT_BASE_ADDR_CB(buf_id));\r\ngsc_write(0x0, GSC_OUT_BASE_ADDR_CR(buf_id));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn gsc_dst_set_buf_seq(ctx, buf_id, buf_type);\r\n}\r\nstatic int gsc_clk_ctrl(struct gsc_context *ctx, bool enable)\r\n{\r\nDRM_DEBUG_KMS("enable[%d]\n", enable);\r\nif (enable) {\r\nclk_prepare_enable(ctx->gsc_clk);\r\nctx->suspended = false;\r\n} else {\r\nclk_disable_unprepare(ctx->gsc_clk);\r\nctx->suspended = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gsc_get_src_buf_index(struct gsc_context *ctx)\r\n{\r\nu32 cfg, curr_index, i;\r\nu32 buf_id = GSC_MAX_SRC;\r\nint ret;\r\nDRM_DEBUG_KMS("gsc id[%d]\n", ctx->id);\r\ncfg = gsc_read(GSC_IN_BASE_ADDR_Y_MASK);\r\ncurr_index = GSC_IN_CURR_GET_INDEX(cfg);\r\nfor (i = curr_index; i < GSC_MAX_SRC; i++) {\r\nif (!((cfg >> i) & 0x1)) {\r\nbuf_id = i;\r\nbreak;\r\n}\r\n}\r\nif (buf_id == GSC_MAX_SRC) {\r\nDRM_ERROR("failed to get in buffer index.\n");\r\nreturn -EINVAL;\r\n}\r\nret = gsc_src_set_buf_seq(ctx, buf_id, IPP_BUF_DEQUEUE);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to dequeue.\n");\r\nreturn ret;\r\n}\r\nDRM_DEBUG_KMS("cfg[0x%x]curr_index[%d]buf_id[%d]\n", cfg,\r\ncurr_index, buf_id);\r\nreturn buf_id;\r\n}\r\nstatic int gsc_get_dst_buf_index(struct gsc_context *ctx)\r\n{\r\nu32 cfg, curr_index, i;\r\nu32 buf_id = GSC_MAX_DST;\r\nint ret;\r\nDRM_DEBUG_KMS("gsc id[%d]\n", ctx->id);\r\ncfg = gsc_read(GSC_OUT_BASE_ADDR_Y_MASK);\r\ncurr_index = GSC_OUT_CURR_GET_INDEX(cfg);\r\nfor (i = curr_index; i < GSC_MAX_DST; i++) {\r\nif (!((cfg >> i) & 0x1)) {\r\nbuf_id = i;\r\nbreak;\r\n}\r\n}\r\nif (buf_id == GSC_MAX_DST) {\r\nDRM_ERROR("failed to get out buffer index.\n");\r\nreturn -EINVAL;\r\n}\r\nret = gsc_dst_set_buf_seq(ctx, buf_id, IPP_BUF_DEQUEUE);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to dequeue.\n");\r\nreturn ret;\r\n}\r\nDRM_DEBUG_KMS("cfg[0x%x]curr_index[%d]buf_id[%d]\n", cfg,\r\ncurr_index, buf_id);\r\nreturn buf_id;\r\n}\r\nstatic irqreturn_t gsc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct gsc_context *ctx = dev_id;\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_event_work *event_work =\r\nc_node->event_work;\r\nu32 status;\r\nint buf_id[EXYNOS_DRM_OPS_MAX];\r\nDRM_DEBUG_KMS("gsc id[%d]\n", ctx->id);\r\nstatus = gsc_read(GSC_IRQ);\r\nif (status & GSC_IRQ_STATUS_OR_IRQ) {\r\ndev_err(ippdrv->dev, "occurred overflow at %d, status 0x%x.\n",\r\nctx->id, status);\r\nreturn IRQ_NONE;\r\n}\r\nif (status & GSC_IRQ_STATUS_OR_FRM_DONE) {\r\ndev_dbg(ippdrv->dev, "occurred frame done at %d, status 0x%x.\n",\r\nctx->id, status);\r\nbuf_id[EXYNOS_DRM_OPS_SRC] = gsc_get_src_buf_index(ctx);\r\nif (buf_id[EXYNOS_DRM_OPS_SRC] < 0)\r\nreturn IRQ_HANDLED;\r\nbuf_id[EXYNOS_DRM_OPS_DST] = gsc_get_dst_buf_index(ctx);\r\nif (buf_id[EXYNOS_DRM_OPS_DST] < 0)\r\nreturn IRQ_HANDLED;\r\nDRM_DEBUG_KMS("buf_id_src[%d]buf_id_dst[%d]\n",\r\nbuf_id[EXYNOS_DRM_OPS_SRC], buf_id[EXYNOS_DRM_OPS_DST]);\r\nevent_work->ippdrv = ippdrv;\r\nevent_work->buf_id[EXYNOS_DRM_OPS_SRC] =\r\nbuf_id[EXYNOS_DRM_OPS_SRC];\r\nevent_work->buf_id[EXYNOS_DRM_OPS_DST] =\r\nbuf_id[EXYNOS_DRM_OPS_DST];\r\nqueue_work(ippdrv->event_workq, &event_work->work);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gsc_init_prop_list(struct exynos_drm_ippdrv *ippdrv)\r\n{\r\nstruct drm_exynos_ipp_prop_list *prop_list = &ippdrv->prop_list;\r\nprop_list->version = 1;\r\nprop_list->writeback = 1;\r\nprop_list->refresh_min = GSC_REFRESH_MIN;\r\nprop_list->refresh_max = GSC_REFRESH_MAX;\r\nprop_list->flip = (1 << EXYNOS_DRM_FLIP_VERTICAL) |\r\n(1 << EXYNOS_DRM_FLIP_HORIZONTAL);\r\nprop_list->degree = (1 << EXYNOS_DRM_DEGREE_0) |\r\n(1 << EXYNOS_DRM_DEGREE_90) |\r\n(1 << EXYNOS_DRM_DEGREE_180) |\r\n(1 << EXYNOS_DRM_DEGREE_270);\r\nprop_list->csc = 1;\r\nprop_list->crop = 1;\r\nprop_list->crop_max.hsize = GSC_CROP_MAX;\r\nprop_list->crop_max.vsize = GSC_CROP_MAX;\r\nprop_list->crop_min.hsize = GSC_CROP_MIN;\r\nprop_list->crop_min.vsize = GSC_CROP_MIN;\r\nprop_list->scale = 1;\r\nprop_list->scale_max.hsize = GSC_SCALE_MAX;\r\nprop_list->scale_max.vsize = GSC_SCALE_MAX;\r\nprop_list->scale_min.hsize = GSC_SCALE_MIN;\r\nprop_list->scale_min.vsize = GSC_SCALE_MIN;\r\nreturn 0;\r\n}\r\nstatic inline bool gsc_check_drm_flip(enum drm_exynos_flip flip)\r\n{\r\nswitch (flip) {\r\ncase EXYNOS_DRM_FLIP_NONE:\r\ncase EXYNOS_DRM_FLIP_VERTICAL:\r\ncase EXYNOS_DRM_FLIP_HORIZONTAL:\r\ncase EXYNOS_DRM_FLIP_BOTH:\r\nreturn true;\r\ndefault:\r\nDRM_DEBUG_KMS("invalid flip\n");\r\nreturn false;\r\n}\r\n}\r\nstatic int gsc_ippdrv_check_property(struct device *dev,\r\nstruct drm_exynos_ipp_property *property)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_prop_list *pp = &ippdrv->prop_list;\r\nstruct drm_exynos_ipp_config *config;\r\nstruct drm_exynos_pos *pos;\r\nstruct drm_exynos_sz *sz;\r\nbool swap;\r\nint i;\r\nfor_each_ipp_ops(i) {\r\nif ((i == EXYNOS_DRM_OPS_SRC) &&\r\n(property->cmd == IPP_CMD_WB))\r\ncontinue;\r\nconfig = &property->config[i];\r\npos = &config->pos;\r\nsz = &config->sz;\r\nif (!gsc_check_drm_flip(config->flip)) {\r\nDRM_ERROR("invalid flip.\n");\r\ngoto err_property;\r\n}\r\nswitch (config->degree) {\r\ncase EXYNOS_DRM_DEGREE_90:\r\ncase EXYNOS_DRM_DEGREE_270:\r\nswap = true;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_0:\r\ncase EXYNOS_DRM_DEGREE_180:\r\nswap = false;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid degree.\n");\r\ngoto err_property;\r\n}\r\nif ((pos->x + pos->w > sz->hsize) ||\r\n(pos->y + pos->h > sz->vsize)) {\r\nDRM_ERROR("out of buf bound.\n");\r\ngoto err_property;\r\n}\r\nif ((i == EXYNOS_DRM_OPS_SRC) && (pp->crop)) {\r\nif (swap) {\r\nif ((pos->h < pp->crop_min.hsize) ||\r\n(sz->vsize > pp->crop_max.hsize) ||\r\n(pos->w < pp->crop_min.vsize) ||\r\n(sz->hsize > pp->crop_max.vsize)) {\r\nDRM_ERROR("out of crop size.\n");\r\ngoto err_property;\r\n}\r\n} else {\r\nif ((pos->w < pp->crop_min.hsize) ||\r\n(sz->hsize > pp->crop_max.hsize) ||\r\n(pos->h < pp->crop_min.vsize) ||\r\n(sz->vsize > pp->crop_max.vsize)) {\r\nDRM_ERROR("out of crop size.\n");\r\ngoto err_property;\r\n}\r\n}\r\n}\r\nif ((i == EXYNOS_DRM_OPS_DST) && (pp->scale)) {\r\nif (swap) {\r\nif ((pos->h < pp->scale_min.hsize) ||\r\n(sz->vsize > pp->scale_max.hsize) ||\r\n(pos->w < pp->scale_min.vsize) ||\r\n(sz->hsize > pp->scale_max.vsize)) {\r\nDRM_ERROR("out of scale size.\n");\r\ngoto err_property;\r\n}\r\n} else {\r\nif ((pos->w < pp->scale_min.hsize) ||\r\n(sz->hsize > pp->scale_max.hsize) ||\r\n(pos->h < pp->scale_min.vsize) ||\r\n(sz->vsize > pp->scale_max.vsize)) {\r\nDRM_ERROR("out of scale size.\n");\r\ngoto err_property;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerr_property:\r\nfor_each_ipp_ops(i) {\r\nif ((i == EXYNOS_DRM_OPS_SRC) &&\r\n(property->cmd == IPP_CMD_WB))\r\ncontinue;\r\nconfig = &property->config[i];\r\npos = &config->pos;\r\nsz = &config->sz;\r\nDRM_ERROR("[%s]f[%d]r[%d]pos[%d %d %d %d]sz[%d %d]\n",\r\ni ? "dst" : "src", config->flip, config->degree,\r\npos->x, pos->y, pos->w, pos->h,\r\nsz->hsize, sz->vsize);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int gsc_ippdrv_reset(struct device *dev)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct gsc_scaler *sc = &ctx->sc;\r\nint ret;\r\nret = gsc_sw_reset(ctx);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to reset hardware.\n");\r\nreturn ret;\r\n}\r\nmemset(&ctx->sc, 0x0, sizeof(ctx->sc));\r\nsc->range = true;\r\nreturn 0;\r\n}\r\nstatic int gsc_ippdrv_start(struct device *dev, enum drm_exynos_ipp_cmd cmd)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_property *property;\r\nstruct drm_exynos_ipp_config *config;\r\nstruct drm_exynos_pos img_pos[EXYNOS_DRM_OPS_MAX];\r\nstruct drm_exynos_ipp_set_wb set_wb;\r\nu32 cfg;\r\nint ret, i;\r\nDRM_DEBUG_KMS("cmd[%d]\n", cmd);\r\nif (!c_node) {\r\nDRM_ERROR("failed to get c_node.\n");\r\nreturn -EINVAL;\r\n}\r\nproperty = &c_node->property;\r\ngsc_handle_irq(ctx, true, false, true);\r\nfor_each_ipp_ops(i) {\r\nconfig = &property->config[i];\r\nimg_pos[i] = config->pos;\r\n}\r\nswitch (cmd) {\r\ncase IPP_CMD_M2M:\r\ncfg = gsc_read(GSC_ENABLE);\r\ncfg &= ~(GSC_ENABLE_ON_CLEAR_MASK |\r\nGSC_ENABLE_CLK_GATE_MODE_MASK);\r\ncfg |= GSC_ENABLE_ON_CLEAR_ONESHOT;\r\ngsc_write(cfg, GSC_ENABLE);\r\ncfg = gsc_read(GSC_IN_CON);\r\ncfg &= ~(GSC_IN_PATH_MASK | GSC_IN_LOCAL_SEL_MASK);\r\ncfg |= GSC_IN_PATH_MEMORY;\r\ngsc_write(cfg, GSC_IN_CON);\r\ncfg = gsc_read(GSC_OUT_CON);\r\ncfg |= GSC_OUT_PATH_MEMORY;\r\ngsc_write(cfg, GSC_OUT_CON);\r\nbreak;\r\ncase IPP_CMD_WB:\r\nset_wb.enable = 1;\r\nset_wb.refresh = property->refresh_rate;\r\ngsc_set_gscblk_fimd_wb(ctx, set_wb.enable);\r\nexynos_drm_ippnb_send_event(IPP_SET_WRITEBACK, (void *)&set_wb);\r\ncfg = gsc_read(GSC_IN_CON);\r\ncfg &= ~(GSC_IN_PATH_MASK | GSC_IN_LOCAL_SEL_MASK);\r\ncfg |= (GSC_IN_PATH_LOCAL | GSC_IN_LOCAL_FIMD_WB);\r\ngsc_write(cfg, GSC_IN_CON);\r\ncfg = gsc_read(GSC_OUT_CON);\r\ncfg |= GSC_OUT_PATH_MEMORY;\r\ngsc_write(cfg, GSC_OUT_CON);\r\nbreak;\r\ncase IPP_CMD_OUTPUT:\r\ncfg = gsc_read(GSC_IN_CON);\r\ncfg &= ~(GSC_IN_PATH_MASK | GSC_IN_LOCAL_SEL_MASK);\r\ncfg |= GSC_IN_PATH_MEMORY;\r\ngsc_write(cfg, GSC_IN_CON);\r\ncfg = gsc_read(GSC_OUT_CON);\r\ncfg |= GSC_OUT_PATH_MEMORY;\r\ngsc_write(cfg, GSC_OUT_CON);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ndev_err(dev, "invalid operations.\n");\r\nreturn ret;\r\n}\r\nret = gsc_set_prescaler(ctx, &ctx->sc,\r\n&img_pos[EXYNOS_DRM_OPS_SRC],\r\n&img_pos[EXYNOS_DRM_OPS_DST]);\r\nif (ret) {\r\ndev_err(dev, "failed to set precalser.\n");\r\nreturn ret;\r\n}\r\ngsc_set_scaler(ctx, &ctx->sc);\r\ncfg = gsc_read(GSC_ENABLE);\r\ncfg |= GSC_ENABLE_ON;\r\ngsc_write(cfg, GSC_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void gsc_ippdrv_stop(struct device *dev, enum drm_exynos_ipp_cmd cmd)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct drm_exynos_ipp_set_wb set_wb = {0, 0};\r\nu32 cfg;\r\nDRM_DEBUG_KMS("cmd[%d]\n", cmd);\r\nswitch (cmd) {\r\ncase IPP_CMD_M2M:\r\nbreak;\r\ncase IPP_CMD_WB:\r\ngsc_set_gscblk_fimd_wb(ctx, set_wb.enable);\r\nexynos_drm_ippnb_send_event(IPP_SET_WRITEBACK, (void *)&set_wb);\r\nbreak;\r\ncase IPP_CMD_OUTPUT:\r\ndefault:\r\ndev_err(dev, "invalid operations.\n");\r\nbreak;\r\n}\r\ngsc_handle_irq(ctx, false, false, true);\r\ngsc_write(0xff, GSC_OUT_BASE_ADDR_Y_MASK);\r\ngsc_write(0xff, GSC_OUT_BASE_ADDR_CB_MASK);\r\ngsc_write(0xff, GSC_OUT_BASE_ADDR_CR_MASK);\r\ncfg = gsc_read(GSC_ENABLE);\r\ncfg &= ~GSC_ENABLE_ON;\r\ngsc_write(cfg, GSC_ENABLE);\r\n}\r\nstatic int gsc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct gsc_context *ctx;\r\nstruct resource *res;\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nint ret;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nif (dev->of_node) {\r\nctx->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"samsung,sysreg");\r\nif (IS_ERR(ctx->sysreg)) {\r\ndev_warn(dev, "failed to get system register.\n");\r\nctx->sysreg = NULL;\r\n}\r\n}\r\nctx->gsc_clk = devm_clk_get(dev, "gscl");\r\nif (IS_ERR(ctx->gsc_clk)) {\r\ndev_err(dev, "failed to get gsc clock.\n");\r\nreturn PTR_ERR(ctx->gsc_clk);\r\n}\r\nctx->regs_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nctx->regs = devm_ioremap_resource(dev, ctx->regs_res);\r\nif (IS_ERR(ctx->regs))\r\nreturn PTR_ERR(ctx->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to request irq resource.\n");\r\nreturn -ENOENT;\r\n}\r\nctx->irq = res->start;\r\nret = devm_request_threaded_irq(dev, ctx->irq, NULL, gsc_irq_handler,\r\nIRQF_ONESHOT, "drm_gsc", ctx);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to request irq.\n");\r\nreturn ret;\r\n}\r\nctx->id = pdev->id;\r\nippdrv = &ctx->ippdrv;\r\nippdrv->dev = dev;\r\nippdrv->ops[EXYNOS_DRM_OPS_SRC] = &gsc_src_ops;\r\nippdrv->ops[EXYNOS_DRM_OPS_DST] = &gsc_dst_ops;\r\nippdrv->check_property = gsc_ippdrv_check_property;\r\nippdrv->reset = gsc_ippdrv_reset;\r\nippdrv->start = gsc_ippdrv_start;\r\nippdrv->stop = gsc_ippdrv_stop;\r\nret = gsc_init_prop_list(ippdrv);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to init property list.\n");\r\nreturn ret;\r\n}\r\nDRM_DEBUG_KMS("id[%d]ippdrv[%p]\n", ctx->id, ippdrv);\r\nmutex_init(&ctx->lock);\r\nplatform_set_drvdata(pdev, ctx);\r\npm_runtime_enable(dev);\r\nret = exynos_drm_ippdrv_register(ippdrv);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register drm gsc device.\n");\r\ngoto err_ippdrv_register;\r\n}\r\ndev_info(dev, "drm gsc registered successfully.\n");\r\nreturn 0;\r\nerr_ippdrv_register:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int gsc_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &ctx->ippdrv;\r\nexynos_drm_ippdrv_unregister(ippdrv);\r\nmutex_destroy(&ctx->lock);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_disable(dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused gsc_runtime_suspend(struct device *dev)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nDRM_DEBUG_KMS("id[%d]\n", ctx->id);\r\nreturn gsc_clk_ctrl(ctx, false);\r\n}\r\nstatic int __maybe_unused gsc_runtime_resume(struct device *dev)\r\n{\r\nstruct gsc_context *ctx = get_gsc_context(dev);\r\nDRM_DEBUG_KMS("id[%d]\n", ctx->id);\r\nreturn gsc_clk_ctrl(ctx, true);\r\n}
