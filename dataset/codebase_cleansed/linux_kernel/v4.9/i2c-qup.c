static irqreturn_t qup_i2c_interrupt(int irq, void *dev)\r\n{\r\nstruct qup_i2c_dev *qup = dev;\r\nu32 bus_err;\r\nu32 qup_err;\r\nu32 opflags;\r\nbus_err = readl(qup->base + QUP_I2C_STATUS);\r\nqup_err = readl(qup->base + QUP_ERROR_FLAGS);\r\nopflags = readl(qup->base + QUP_OPERATIONAL);\r\nif (!qup->msg) {\r\nwritel(QUP_RESET_STATE, qup->base + QUP_STATE);\r\nreturn IRQ_HANDLED;\r\n}\r\nbus_err &= I2C_STATUS_ERROR_MASK;\r\nqup_err &= QUP_STATUS_ERROR_FLAGS;\r\nif (qup_err)\r\nwritel(qup_err, qup->base + QUP_ERROR_FLAGS);\r\nif (bus_err)\r\nwritel(bus_err, qup->base + QUP_I2C_STATUS);\r\nif (qup_err || bus_err) {\r\nwritel(QUP_RESET_STATE, qup->base + QUP_STATE);\r\ngoto done;\r\n}\r\nif (opflags & QUP_IN_SVC_FLAG)\r\nwritel(QUP_IN_SVC_FLAG, qup->base + QUP_OPERATIONAL);\r\nif (opflags & QUP_OUT_SVC_FLAG)\r\nwritel(QUP_OUT_SVC_FLAG, qup->base + QUP_OPERATIONAL);\r\ndone:\r\nqup->qup_err = qup_err;\r\nqup->bus_err = bus_err;\r\ncomplete(&qup->xfer);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int qup_i2c_poll_state_mask(struct qup_i2c_dev *qup,\r\nu32 req_state, u32 req_mask)\r\n{\r\nint retries = 1;\r\nu32 state;\r\ndo {\r\nstate = readl(qup->base + QUP_STATE);\r\nif (state & QUP_STATE_VALID &&\r\n(state & req_mask) == req_state)\r\nreturn 0;\r\nudelay(1);\r\n} while (retries--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int qup_i2c_poll_state(struct qup_i2c_dev *qup, u32 req_state)\r\n{\r\nreturn qup_i2c_poll_state_mask(qup, req_state, QUP_STATE_MASK);\r\n}\r\nstatic void qup_i2c_flush(struct qup_i2c_dev *qup)\r\n{\r\nu32 val = readl(qup->base + QUP_STATE);\r\nval |= QUP_I2C_FLUSH;\r\nwritel(val, qup->base + QUP_STATE);\r\n}\r\nstatic int qup_i2c_poll_state_valid(struct qup_i2c_dev *qup)\r\n{\r\nreturn qup_i2c_poll_state_mask(qup, 0, 0);\r\n}\r\nstatic int qup_i2c_poll_state_i2c_master(struct qup_i2c_dev *qup)\r\n{\r\nreturn qup_i2c_poll_state_mask(qup, QUP_I2C_MAST_GEN, QUP_I2C_MAST_GEN);\r\n}\r\nstatic int qup_i2c_change_state(struct qup_i2c_dev *qup, u32 state)\r\n{\r\nif (qup_i2c_poll_state_valid(qup) != 0)\r\nreturn -EIO;\r\nwritel(state, qup->base + QUP_STATE);\r\nif (qup_i2c_poll_state(qup, state) != 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int qup_i2c_wait_ready(struct qup_i2c_dev *qup, int op, bool val,\r\nint len)\r\n{\r\nunsigned long timeout;\r\nu32 opflags;\r\nu32 status;\r\nu32 shift = __ffs(op);\r\nint ret = 0;\r\nlen *= qup->one_byte_t;\r\ntimeout = jiffies + len * 4;\r\nfor (;;) {\r\nopflags = readl(qup->base + QUP_OPERATIONAL);\r\nstatus = readl(qup->base + QUP_I2C_STATUS);\r\nif (((opflags & op) >> shift) == val) {\r\nif ((op == QUP_OUT_NOT_EMPTY) && qup->is_last) {\r\nif (!(status & I2C_STATUS_BUS_ACTIVE)) {\r\nret = 0;\r\ngoto done;\r\n}\r\n} else {\r\nret = 0;\r\ngoto done;\r\n}\r\n}\r\nif (time_after(jiffies, timeout)) {\r\nret = -ETIMEDOUT;\r\ngoto done;\r\n}\r\nusleep_range(len, len * 2);\r\n}\r\ndone:\r\nif (qup->bus_err || qup->qup_err)\r\nret = (qup->bus_err & QUP_I2C_NACK_FLAG) ? -ENXIO : -EIO;\r\nreturn ret;\r\n}\r\nstatic void qup_i2c_set_write_mode_v2(struct qup_i2c_dev *qup,\r\nstruct i2c_msg *msg)\r\n{\r\nint total = msg->len + qup->blk.tx_tag_len;\r\ntotal |= qup->config_run;\r\nif (total < qup->out_fifo_sz) {\r\nwritel(QUP_REPACK_EN, qup->base + QUP_IO_MODE);\r\nwritel(total, qup->base + QUP_MX_WRITE_CNT);\r\n} else {\r\nwritel(QUP_OUTPUT_BLK_MODE | QUP_REPACK_EN,\r\nqup->base + QUP_IO_MODE);\r\nwritel(total, qup->base + QUP_MX_OUTPUT_CNT);\r\n}\r\n}\r\nstatic void qup_i2c_set_write_mode(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nint total = msg->len + 1;\r\nif (total < qup->out_fifo_sz) {\r\nwritel(QUP_REPACK_EN, qup->base + QUP_IO_MODE);\r\nwritel(total, qup->base + QUP_MX_WRITE_CNT);\r\n} else {\r\nwritel(QUP_OUTPUT_BLK_MODE | QUP_REPACK_EN,\r\nqup->base + QUP_IO_MODE);\r\nwritel(total, qup->base + QUP_MX_OUTPUT_CNT);\r\n}\r\n}\r\nstatic int check_for_fifo_space(struct qup_i2c_dev *qup)\r\n{\r\nint ret;\r\nret = qup_i2c_change_state(qup, QUP_PAUSE_STATE);\r\nif (ret)\r\ngoto out;\r\nret = qup_i2c_wait_ready(qup, QUP_OUT_FULL,\r\nRESET_BIT, 4 * ONE_BYTE);\r\nif (ret) {\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nif (ret)\r\ngoto out;\r\nret = qup_i2c_wait_ready(qup, QUP_OUT_NOT_EMPTY,\r\nRESET_BIT, 256 * ONE_BYTE);\r\nif (ret) {\r\ndev_err(qup->dev, "timeout for fifo out full");\r\ngoto out;\r\n}\r\nret = qup_i2c_change_state(qup, QUP_PAUSE_STATE);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_issue_write(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nu32 addr = msg->addr << 1;\r\nu32 qup_tag;\r\nint idx;\r\nu32 val;\r\nint ret = 0;\r\nif (qup->pos == 0) {\r\nval = QUP_TAG_START | addr;\r\nidx = 1;\r\n} else {\r\nval = 0;\r\nidx = 0;\r\n}\r\nwhile (qup->pos < msg->len) {\r\nret = check_for_fifo_space(qup);\r\nif (ret)\r\nreturn ret;\r\nif (qup->pos == msg->len - 1)\r\nqup_tag = QUP_TAG_STOP;\r\nelse\r\nqup_tag = QUP_TAG_DATA;\r\nif (idx & 1)\r\nval |= (qup_tag | msg->buf[qup->pos]) << QUP_MSW_SHIFT;\r\nelse\r\nval = qup_tag | msg->buf[qup->pos];\r\nif (idx & 1 || qup->pos == msg->len - 1)\r\nwritel(val, qup->base + QUP_OUT_FIFO_BASE);\r\nqup->pos++;\r\nidx++;\r\n}\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nreturn ret;\r\n}\r\nstatic void qup_i2c_set_blk_data(struct qup_i2c_dev *qup,\r\nstruct i2c_msg *msg)\r\n{\r\nmemset(&qup->blk, 0, sizeof(qup->blk));\r\nqup->blk.data_len = msg->len;\r\nqup->blk.count = (msg->len + QUP_READ_LIMIT - 1) / QUP_READ_LIMIT;\r\nqup->blk.tx_tag_len = 4 + (qup->blk.count - 1) * 2;\r\nif (msg->flags & I2C_M_RD)\r\nqup->blk.rx_tag_len = qup->blk.count * 2;\r\n}\r\nstatic int qup_i2c_send_data(struct qup_i2c_dev *qup, int tlen, u8 *tbuf,\r\nint dlen, u8 *dbuf)\r\n{\r\nu32 val = 0, idx = 0, pos = 0, i = 0, t;\r\nint len = tlen + dlen;\r\nu8 *buf = tbuf;\r\nint ret = 0;\r\nwhile (len > 0) {\r\nret = check_for_fifo_space(qup);\r\nif (ret)\r\nreturn ret;\r\nt = (len >= 4) ? 4 : len;\r\nwhile (idx < t) {\r\nif (!i && (pos >= tlen)) {\r\nbuf = dbuf;\r\npos = 0;\r\ni = 1;\r\n}\r\nval |= buf[pos++] << (idx++ * 8);\r\n}\r\nwritel(val, qup->base + QUP_OUT_FIFO_BASE);\r\nidx = 0;\r\nval = 0;\r\nlen -= 4;\r\n}\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_get_data_len(struct qup_i2c_dev *qup)\r\n{\r\nint data_len;\r\nif (qup->blk.data_len > QUP_READ_LIMIT)\r\ndata_len = QUP_READ_LIMIT;\r\nelse\r\ndata_len = qup->blk.data_len;\r\nreturn data_len;\r\n}\r\nstatic int qup_i2c_set_tags(u8 *tags, struct qup_i2c_dev *qup,\r\nstruct i2c_msg *msg, int is_dma)\r\n{\r\nu16 addr = i2c_8bit_addr_from_msg(msg);\r\nint len = 0;\r\nint data_len;\r\nint last = (qup->blk.pos == (qup->blk.count - 1)) && (qup->is_last);\r\nif (qup->blk.pos == 0) {\r\ntags[len++] = QUP_TAG_V2_START;\r\ntags[len++] = addr & 0xff;\r\nif (msg->flags & I2C_M_TEN)\r\ntags[len++] = addr >> 8;\r\n}\r\nif (last) {\r\nif (msg->flags & I2C_M_RD)\r\ntags[len++] = QUP_TAG_V2_DATARD_STOP;\r\nelse\r\ntags[len++] = QUP_TAG_V2_DATAWR_STOP;\r\n} else {\r\nif (msg->flags & I2C_M_RD)\r\ntags[len++] = QUP_TAG_V2_DATARD;\r\nelse\r\ntags[len++] = QUP_TAG_V2_DATAWR;\r\n}\r\ndata_len = qup_i2c_get_data_len(qup);\r\nif (data_len == QUP_READ_LIMIT)\r\ntags[len++] = 0;\r\nelse\r\ntags[len++] = data_len;\r\nif ((msg->flags & I2C_M_RD) && last && is_dma) {\r\ntags[len++] = QUP_BAM_INPUT_EOT;\r\ntags[len++] = QUP_BAM_FLUSH_STOP;\r\n}\r\nreturn len;\r\n}\r\nstatic int qup_i2c_issue_xfer_v2(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nint data_len = 0, tag_len, index;\r\nint ret;\r\ntag_len = qup_i2c_set_tags(qup->blk.tags, qup, msg, 0);\r\nindex = msg->len - qup->blk.data_len;\r\nif (!(msg->flags & I2C_M_RD))\r\ndata_len = qup_i2c_get_data_len(qup);\r\nret = qup_i2c_send_data(qup, tag_len, qup->blk.tags,\r\ndata_len, &msg->buf[index]);\r\nqup->blk.data_len -= data_len;\r\nreturn ret;\r\n}\r\nstatic void qup_i2c_bam_cb(void *data)\r\n{\r\nstruct qup_i2c_dev *qup = data;\r\ncomplete(&qup->xfer);\r\n}\r\nstatic int qup_sg_set_buf(struct scatterlist *sg, void *buf,\r\nunsigned int buflen, struct qup_i2c_dev *qup,\r\nint dir)\r\n{\r\nint ret;\r\nsg_set_buf(sg, buf, buflen);\r\nret = dma_map_sg(qup->dev, sg, 1, dir);\r\nif (!ret)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void qup_i2c_rel_dma(struct qup_i2c_dev *qup)\r\n{\r\nif (qup->btx.dma)\r\ndma_release_channel(qup->btx.dma);\r\nif (qup->brx.dma)\r\ndma_release_channel(qup->brx.dma);\r\nqup->btx.dma = NULL;\r\nqup->brx.dma = NULL;\r\n}\r\nstatic int qup_i2c_req_dma(struct qup_i2c_dev *qup)\r\n{\r\nint err;\r\nif (!qup->btx.dma) {\r\nqup->btx.dma = dma_request_slave_channel_reason(qup->dev, "tx");\r\nif (IS_ERR(qup->btx.dma)) {\r\nerr = PTR_ERR(qup->btx.dma);\r\nqup->btx.dma = NULL;\r\ndev_err(qup->dev, "\n tx channel not available");\r\nreturn err;\r\n}\r\n}\r\nif (!qup->brx.dma) {\r\nqup->brx.dma = dma_request_slave_channel_reason(qup->dev, "rx");\r\nif (IS_ERR(qup->brx.dma)) {\r\ndev_err(qup->dev, "\n rx channel not available");\r\nerr = PTR_ERR(qup->brx.dma);\r\nqup->brx.dma = NULL;\r\nqup_i2c_rel_dma(qup);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qup_i2c_bam_do_xfer(struct qup_i2c_dev *qup, struct i2c_msg *msg,\r\nint num)\r\n{\r\nstruct dma_async_tx_descriptor *txd, *rxd = NULL;\r\nint ret = 0, idx = 0, limit = QUP_READ_LIMIT;\r\ndma_cookie_t cookie_rx, cookie_tx;\r\nu32 rx_nents = 0, tx_nents = 0, len, blocks, rem;\r\nu32 i, tlen, tx_len, tx_buf = 0, rx_buf = 0, off = 0;\r\nu8 *tags;\r\nwhile (idx < num) {\r\ntx_len = 0, len = 0, i = 0;\r\nqup->is_last = (idx == (num - 1));\r\nqup_i2c_set_blk_data(qup, msg);\r\nblocks = qup->blk.count;\r\nrem = msg->len - (blocks - 1) * limit;\r\nif (msg->flags & I2C_M_RD) {\r\nrx_nents += (blocks * 2) + 1;\r\ntx_nents += 1;\r\nwhile (qup->blk.pos < blocks) {\r\ntlen = (i == (blocks - 1)) ? rem : limit;\r\ntags = &qup->start_tag.start[off + len];\r\nlen += qup_i2c_set_tags(tags, qup, msg, 1);\r\nqup->blk.data_len -= tlen;\r\nret = qup_sg_set_buf(&qup->brx.sg[rx_buf++],\r\n&qup->brx.tag.start[0],\r\n2, qup, DMA_FROM_DEVICE);\r\nif (ret)\r\nreturn ret;\r\nret = qup_sg_set_buf(&qup->brx.sg[rx_buf++],\r\n&msg->buf[limit * i],\r\ntlen, qup,\r\nDMA_FROM_DEVICE);\r\nif (ret)\r\nreturn ret;\r\ni++;\r\nqup->blk.pos = i;\r\n}\r\nret = qup_sg_set_buf(&qup->btx.sg[tx_buf++],\r\n&qup->start_tag.start[off],\r\nlen, qup, DMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\noff += len;\r\nret = qup_sg_set_buf(&qup->brx.sg[rx_buf++],\r\n&qup->brx.tag.start[0],\r\n2, qup, DMA_FROM_DEVICE);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ntx_nents += (blocks * 2);\r\nwhile (qup->blk.pos < blocks) {\r\ntlen = (i == (blocks - 1)) ? rem : limit;\r\ntags = &qup->start_tag.start[off + tx_len];\r\nlen = qup_i2c_set_tags(tags, qup, msg, 1);\r\nqup->blk.data_len -= tlen;\r\nret = qup_sg_set_buf(&qup->btx.sg[tx_buf++],\r\ntags, len,\r\nqup, DMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\ntx_len += len;\r\nret = qup_sg_set_buf(&qup->btx.sg[tx_buf++],\r\n&msg->buf[limit * i],\r\ntlen, qup, DMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\ni++;\r\nqup->blk.pos = i;\r\n}\r\noff += tx_len;\r\nif (idx == (num - 1)) {\r\nlen = 1;\r\nif (rx_nents) {\r\nqup->btx.tag.start[0] =\r\nQUP_BAM_INPUT_EOT;\r\nlen++;\r\n}\r\nqup->btx.tag.start[len - 1] =\r\nQUP_BAM_FLUSH_STOP;\r\nret = qup_sg_set_buf(&qup->btx.sg[tx_buf++],\r\n&qup->btx.tag.start[0],\r\nlen, qup, DMA_TO_DEVICE);\r\nif (ret)\r\nreturn ret;\r\ntx_nents += 1;\r\n}\r\n}\r\nidx++;\r\nmsg++;\r\n}\r\ntxd = dmaengine_prep_slave_sg(qup->btx.dma, qup->btx.sg, tx_nents,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_PREP_FENCE);\r\nif (!txd) {\r\ndev_err(qup->dev, "failed to get tx desc\n");\r\nret = -EINVAL;\r\ngoto desc_err;\r\n}\r\nif (!rx_nents) {\r\ntxd->callback = qup_i2c_bam_cb;\r\ntxd->callback_param = qup;\r\n}\r\ncookie_tx = dmaengine_submit(txd);\r\nif (dma_submit_error(cookie_tx)) {\r\nret = -EINVAL;\r\ngoto desc_err;\r\n}\r\ndma_async_issue_pending(qup->btx.dma);\r\nif (rx_nents) {\r\nrxd = dmaengine_prep_slave_sg(qup->brx.dma, qup->brx.sg,\r\nrx_nents, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT);\r\nif (!rxd) {\r\ndev_err(qup->dev, "failed to get rx desc\n");\r\nret = -EINVAL;\r\ndmaengine_terminate_all(qup->btx.dma);\r\ngoto desc_err;\r\n}\r\nrxd->callback = qup_i2c_bam_cb;\r\nrxd->callback_param = qup;\r\ncookie_rx = dmaengine_submit(rxd);\r\nif (dma_submit_error(cookie_rx)) {\r\nret = -EINVAL;\r\ngoto desc_err;\r\n}\r\ndma_async_issue_pending(qup->brx.dma);\r\n}\r\nif (!wait_for_completion_timeout(&qup->xfer, TOUT_MAX * HZ)) {\r\ndev_err(qup->dev, "normal trans timed out\n");\r\nret = -ETIMEDOUT;\r\n}\r\nif (ret || qup->bus_err || qup->qup_err) {\r\nif (qup_i2c_change_state(qup, QUP_RUN_STATE)) {\r\ndev_err(qup->dev, "change to run state timed out");\r\ngoto desc_err;\r\n}\r\nif (rx_nents)\r\nwritel(QUP_BAM_INPUT_EOT,\r\nqup->base + QUP_OUT_FIFO_BASE);\r\nwritel(QUP_BAM_FLUSH_STOP, qup->base + QUP_OUT_FIFO_BASE);\r\nqup_i2c_flush(qup);\r\nif (!wait_for_completion_timeout(&qup->xfer, HZ))\r\ndev_err(qup->dev, "flush timed out\n");\r\nqup_i2c_rel_dma(qup);\r\nret = (qup->bus_err & QUP_I2C_NACK_FLAG) ? -ENXIO : -EIO;\r\n}\r\ndesc_err:\r\ndma_unmap_sg(qup->dev, qup->btx.sg, tx_nents, DMA_TO_DEVICE);\r\nif (rx_nents)\r\ndma_unmap_sg(qup->dev, qup->brx.sg, rx_nents,\r\nDMA_FROM_DEVICE);\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_bam_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\r\nint num)\r\n{\r\nstruct qup_i2c_dev *qup = i2c_get_adapdata(adap);\r\nint ret = 0;\r\nenable_irq(qup->irq);\r\nret = qup_i2c_req_dma(qup);\r\nif (ret)\r\ngoto out;\r\nwritel(0, qup->base + QUP_MX_INPUT_CNT);\r\nwritel(0, qup->base + QUP_MX_OUTPUT_CNT);\r\nwritel(QUP_REPACK_EN | QUP_BAM_MODE, qup->base + QUP_IO_MODE);\r\nwritel((0x3 << 8), qup->base + QUP_OPERATIONAL_MASK);\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nif (ret)\r\ngoto out;\r\nwritel(qup->clk_ctl, qup->base + QUP_I2C_CLK_CTL);\r\nqup->msg = msg;\r\nret = qup_i2c_bam_do_xfer(qup, qup->msg, num);\r\nout:\r\ndisable_irq(qup->irq);\r\nqup->msg = NULL;\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_wait_for_complete(struct qup_i2c_dev *qup,\r\nstruct i2c_msg *msg)\r\n{\r\nunsigned long left;\r\nint ret = 0;\r\nleft = wait_for_completion_timeout(&qup->xfer, HZ);\r\nif (!left) {\r\nwritel(1, qup->base + QUP_SW_RESET);\r\nret = -ETIMEDOUT;\r\n}\r\nif (qup->bus_err || qup->qup_err)\r\nret = (qup->bus_err & QUP_I2C_NACK_FLAG) ? -ENXIO : -EIO;\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_write_one_v2(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nint ret = 0;\r\nqup->msg = msg;\r\nqup->pos = 0;\r\nenable_irq(qup->irq);\r\nqup_i2c_set_blk_data(qup, msg);\r\nqup_i2c_set_write_mode_v2(qup, msg);\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nif (ret)\r\ngoto err;\r\nwritel(qup->clk_ctl, qup->base + QUP_I2C_CLK_CTL);\r\ndo {\r\nret = qup_i2c_issue_xfer_v2(qup, msg);\r\nif (ret)\r\ngoto err;\r\nret = qup_i2c_wait_for_complete(qup, msg);\r\nif (ret)\r\ngoto err;\r\nqup->blk.pos++;\r\n} while (qup->blk.pos < qup->blk.count);\r\nret = qup_i2c_wait_ready(qup, QUP_OUT_NOT_EMPTY, RESET_BIT, ONE_BYTE);\r\nerr:\r\ndisable_irq(qup->irq);\r\nqup->msg = NULL;\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_write_one(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nint ret;\r\nqup->msg = msg;\r\nqup->pos = 0;\r\nenable_irq(qup->irq);\r\nqup_i2c_set_write_mode(qup, msg);\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nif (ret)\r\ngoto err;\r\nwritel(qup->clk_ctl, qup->base + QUP_I2C_CLK_CTL);\r\ndo {\r\nret = qup_i2c_change_state(qup, QUP_PAUSE_STATE);\r\nif (ret)\r\ngoto err;\r\nret = qup_i2c_issue_write(qup, msg);\r\nif (ret)\r\ngoto err;\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nif (ret)\r\ngoto err;\r\nret = qup_i2c_wait_for_complete(qup, msg);\r\nif (ret)\r\ngoto err;\r\n} while (qup->pos < msg->len);\r\nret = qup_i2c_wait_ready(qup, QUP_OUT_NOT_EMPTY, RESET_BIT, ONE_BYTE);\r\nerr:\r\ndisable_irq(qup->irq);\r\nqup->msg = NULL;\r\nreturn ret;\r\n}\r\nstatic void qup_i2c_set_read_mode(struct qup_i2c_dev *qup, int len)\r\n{\r\nif (len < qup->in_fifo_sz) {\r\nwritel(QUP_REPACK_EN, qup->base + QUP_IO_MODE);\r\nwritel(len, qup->base + QUP_MX_READ_CNT);\r\n} else {\r\nwritel(QUP_INPUT_BLK_MODE | QUP_REPACK_EN,\r\nqup->base + QUP_IO_MODE);\r\nwritel(len, qup->base + QUP_MX_INPUT_CNT);\r\n}\r\n}\r\nstatic void qup_i2c_set_read_mode_v2(struct qup_i2c_dev *qup, int len)\r\n{\r\nint tx_len = qup->blk.tx_tag_len;\r\nlen += qup->blk.rx_tag_len;\r\nlen |= qup->config_run;\r\ntx_len |= qup->config_run;\r\nif (len < qup->in_fifo_sz) {\r\nwritel(QUP_REPACK_EN, qup->base + QUP_IO_MODE);\r\nwritel(tx_len, qup->base + QUP_MX_WRITE_CNT);\r\nwritel(len, qup->base + QUP_MX_READ_CNT);\r\n} else {\r\nwritel(QUP_INPUT_BLK_MODE | QUP_REPACK_EN,\r\nqup->base + QUP_IO_MODE);\r\nwritel(tx_len, qup->base + QUP_MX_OUTPUT_CNT);\r\nwritel(len, qup->base + QUP_MX_INPUT_CNT);\r\n}\r\n}\r\nstatic void qup_i2c_issue_read(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nu32 addr, len, val;\r\naddr = i2c_8bit_addr_from_msg(msg);\r\nlen = (msg->len == QUP_READ_LIMIT) ? 0 : msg->len;\r\nval = ((QUP_TAG_REC | len) << QUP_MSW_SHIFT) | QUP_TAG_START | addr;\r\nwritel(val, qup->base + QUP_OUT_FIFO_BASE);\r\n}\r\nstatic int qup_i2c_read_fifo(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nu32 val = 0;\r\nint idx;\r\nint ret = 0;\r\nfor (idx = 0; qup->pos < msg->len; idx++) {\r\nif ((idx & 1) == 0) {\r\nret = qup_i2c_wait_ready(qup, QUP_IN_NOT_EMPTY,\r\nSET_BIT, 4 * ONE_BYTE);\r\nif (ret)\r\nreturn ret;\r\nval = readl(qup->base + QUP_IN_FIFO_BASE);\r\nmsg->buf[qup->pos++] = val & 0xFF;\r\n} else {\r\nmsg->buf[qup->pos++] = val >> QUP_MSW_SHIFT;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_read_fifo_v2(struct qup_i2c_dev *qup,\r\nstruct i2c_msg *msg)\r\n{\r\nu32 val;\r\nint idx, pos = 0, ret = 0, total;\r\ntotal = qup_i2c_get_data_len(qup);\r\nwhile (pos < (total + 2)) {\r\nret = qup_i2c_wait_ready(qup, QUP_IN_NOT_EMPTY,\r\nSET_BIT, 4 * ONE_BYTE);\r\nif (ret) {\r\ndev_err(qup->dev, "timeout for fifo not empty");\r\nreturn ret;\r\n}\r\nval = readl(qup->base + QUP_IN_FIFO_BASE);\r\nfor (idx = 0; idx < 4; idx++, val >>= 8, pos++) {\r\nif (pos < 2)\r\ncontinue;\r\nif (pos >= (total + 2))\r\ngoto out;\r\nmsg->buf[qup->pos++] = val & 0xff;\r\n}\r\n}\r\nout:\r\nqup->blk.data_len -= total;\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_read_one_v2(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nint ret = 0;\r\nqup->msg = msg;\r\nqup->pos = 0;\r\nenable_irq(qup->irq);\r\nqup_i2c_set_blk_data(qup, msg);\r\nqup_i2c_set_read_mode_v2(qup, msg->len);\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nif (ret)\r\ngoto err;\r\nwritel(qup->clk_ctl, qup->base + QUP_I2C_CLK_CTL);\r\ndo {\r\nret = qup_i2c_issue_xfer_v2(qup, msg);\r\nif (ret)\r\ngoto err;\r\nret = qup_i2c_wait_for_complete(qup, msg);\r\nif (ret)\r\ngoto err;\r\nret = qup_i2c_read_fifo_v2(qup, msg);\r\nif (ret)\r\ngoto err;\r\nqup->blk.pos++;\r\n} while (qup->blk.pos < qup->blk.count);\r\nerr:\r\ndisable_irq(qup->irq);\r\nqup->msg = NULL;\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_read_one(struct qup_i2c_dev *qup, struct i2c_msg *msg)\r\n{\r\nint ret;\r\nqup->msg = msg;\r\nqup->pos = 0;\r\nenable_irq(qup->irq);\r\nqup_i2c_set_read_mode(qup, msg->len);\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nif (ret)\r\ngoto err;\r\nwritel(qup->clk_ctl, qup->base + QUP_I2C_CLK_CTL);\r\nret = qup_i2c_change_state(qup, QUP_PAUSE_STATE);\r\nif (ret)\r\ngoto err;\r\nqup_i2c_issue_read(qup, msg);\r\nret = qup_i2c_change_state(qup, QUP_RUN_STATE);\r\nif (ret)\r\ngoto err;\r\ndo {\r\nret = qup_i2c_wait_for_complete(qup, msg);\r\nif (ret)\r\ngoto err;\r\nret = qup_i2c_read_fifo(qup, msg);\r\nif (ret)\r\ngoto err;\r\n} while (qup->pos < msg->len);\r\nerr:\r\ndisable_irq(qup->irq);\r\nqup->msg = NULL;\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[],\r\nint num)\r\n{\r\nstruct qup_i2c_dev *qup = i2c_get_adapdata(adap);\r\nint ret, idx;\r\nret = pm_runtime_get_sync(qup->dev);\r\nif (ret < 0)\r\ngoto out;\r\nqup->bus_err = 0;\r\nqup->qup_err = 0;\r\nwritel(1, qup->base + QUP_SW_RESET);\r\nret = qup_i2c_poll_state(qup, QUP_RESET_STATE);\r\nif (ret)\r\ngoto out;\r\nwritel(I2C_MINI_CORE | I2C_N_VAL, qup->base + QUP_CONFIG);\r\nfor (idx = 0; idx < num; idx++) {\r\nif (msgs[idx].len == 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (qup_i2c_poll_state_i2c_master(qup)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (msgs[idx].flags & I2C_M_RD)\r\nret = qup_i2c_read_one(qup, &msgs[idx]);\r\nelse\r\nret = qup_i2c_write_one(qup, &msgs[idx]);\r\nif (ret)\r\nbreak;\r\nret = qup_i2c_change_state(qup, QUP_RESET_STATE);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret == 0)\r\nret = num;\r\nout:\r\npm_runtime_mark_last_busy(qup->dev);\r\npm_runtime_put_autosuspend(qup->dev);\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_xfer_v2(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[],\r\nint num)\r\n{\r\nstruct qup_i2c_dev *qup = i2c_get_adapdata(adap);\r\nint ret, len, idx = 0, use_dma = 0;\r\nqup->bus_err = 0;\r\nqup->qup_err = 0;\r\nret = pm_runtime_get_sync(qup->dev);\r\nif (ret < 0)\r\ngoto out;\r\nwritel(1, qup->base + QUP_SW_RESET);\r\nret = qup_i2c_poll_state(qup, QUP_RESET_STATE);\r\nif (ret)\r\ngoto out;\r\nwritel(I2C_MINI_CORE | I2C_N_VAL_V2, qup->base + QUP_CONFIG);\r\nwritel(QUP_V2_TAGS_EN, qup->base + QUP_I2C_MASTER_GEN);\r\nif ((qup->is_dma)) {\r\nfor (idx = 0; idx < num; idx++) {\r\nif (msgs[idx].len == 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlen = (msgs[idx].len > qup->out_fifo_sz) ||\r\n(msgs[idx].len > qup->in_fifo_sz);\r\nif ((!is_vmalloc_addr(msgs[idx].buf)) && len) {\r\nuse_dma = 1;\r\n} else {\r\nuse_dma = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nidx = 0;\r\ndo {\r\nif (msgs[idx].len == 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (qup_i2c_poll_state_i2c_master(qup)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nqup->is_last = (idx == (num - 1));\r\nif (idx)\r\nqup->config_run = QUP_I2C_MX_CONFIG_DURING_RUN;\r\nelse\r\nqup->config_run = 0;\r\nreinit_completion(&qup->xfer);\r\nif (use_dma) {\r\nret = qup_i2c_bam_xfer(adap, &msgs[idx], num);\r\n} else {\r\nif (msgs[idx].flags & I2C_M_RD)\r\nret = qup_i2c_read_one_v2(qup, &msgs[idx]);\r\nelse\r\nret = qup_i2c_write_one_v2(qup, &msgs[idx]);\r\n}\r\n} while ((idx++ < (num - 1)) && !use_dma && !ret);\r\nif (!ret)\r\nret = qup_i2c_change_state(qup, QUP_RESET_STATE);\r\nif (ret == 0)\r\nret = num;\r\nout:\r\npm_runtime_mark_last_busy(qup->dev);\r\npm_runtime_put_autosuspend(qup->dev);\r\nreturn ret;\r\n}\r\nstatic u32 qup_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\r\n}\r\nstatic void qup_i2c_enable_clocks(struct qup_i2c_dev *qup)\r\n{\r\nclk_prepare_enable(qup->clk);\r\nclk_prepare_enable(qup->pclk);\r\n}\r\nstatic void qup_i2c_disable_clocks(struct qup_i2c_dev *qup)\r\n{\r\nu32 config;\r\nqup_i2c_change_state(qup, QUP_RESET_STATE);\r\nclk_disable_unprepare(qup->clk);\r\nconfig = readl(qup->base + QUP_CONFIG);\r\nconfig |= QUP_CLOCK_AUTO_GATE;\r\nwritel(config, qup->base + QUP_CONFIG);\r\nclk_disable_unprepare(qup->pclk);\r\n}\r\nstatic int qup_i2c_probe(struct platform_device *pdev)\r\n{\r\nstatic const int blk_sizes[] = {4, 16, 32};\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct qup_i2c_dev *qup;\r\nunsigned long one_bit_t;\r\nstruct resource *res;\r\nu32 io_mode, hw_ver, size;\r\nint ret, fs_div, hs_div;\r\nint src_clk_freq;\r\nu32 clk_freq = 100000;\r\nint blocks;\r\nqup = devm_kzalloc(&pdev->dev, sizeof(*qup), GFP_KERNEL);\r\nif (!qup)\r\nreturn -ENOMEM;\r\nqup->dev = &pdev->dev;\r\ninit_completion(&qup->xfer);\r\nplatform_set_drvdata(pdev, qup);\r\nof_property_read_u32(node, "clock-frequency", &clk_freq);\r\nif (of_device_is_compatible(pdev->dev.of_node, "qcom,i2c-qup-v1.1.1")) {\r\nqup->adap.algo = &qup_i2c_algo;\r\nqup->adap.quirks = &qup_i2c_quirks;\r\n} else {\r\nqup->adap.algo = &qup_i2c_algo_v2;\r\nret = qup_i2c_req_dma(qup);\r\nif (ret == -EPROBE_DEFER)\r\ngoto fail_dma;\r\nelse if (ret != 0)\r\ngoto nodma;\r\nblocks = (MX_BLOCKS << 1) + 1;\r\nqup->btx.sg = devm_kzalloc(&pdev->dev,\r\nsizeof(*qup->btx.sg) * blocks,\r\nGFP_KERNEL);\r\nif (!qup->btx.sg) {\r\nret = -ENOMEM;\r\ngoto fail_dma;\r\n}\r\nsg_init_table(qup->btx.sg, blocks);\r\nqup->brx.sg = devm_kzalloc(&pdev->dev,\r\nsizeof(*qup->brx.sg) * blocks,\r\nGFP_KERNEL);\r\nif (!qup->brx.sg) {\r\nret = -ENOMEM;\r\ngoto fail_dma;\r\n}\r\nsg_init_table(qup->brx.sg, blocks);\r\nsize = blocks * 2 + 5;\r\nqup->start_tag.start = devm_kzalloc(&pdev->dev,\r\nsize, GFP_KERNEL);\r\nif (!qup->start_tag.start) {\r\nret = -ENOMEM;\r\ngoto fail_dma;\r\n}\r\nqup->brx.tag.start = devm_kzalloc(&pdev->dev, 2, GFP_KERNEL);\r\nif (!qup->brx.tag.start) {\r\nret = -ENOMEM;\r\ngoto fail_dma;\r\n}\r\nqup->btx.tag.start = devm_kzalloc(&pdev->dev, 2, GFP_KERNEL);\r\nif (!qup->btx.tag.start) {\r\nret = -ENOMEM;\r\ngoto fail_dma;\r\n}\r\nqup->is_dma = true;\r\n}\r\nnodma:\r\nif (!clk_freq || clk_freq > 400000) {\r\ndev_err(qup->dev, "clock frequency not supported %d\n",\r\nclk_freq);\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nqup->base = devm_ioremap_resource(qup->dev, res);\r\nif (IS_ERR(qup->base))\r\nreturn PTR_ERR(qup->base);\r\nqup->irq = platform_get_irq(pdev, 0);\r\nif (qup->irq < 0) {\r\ndev_err(qup->dev, "No IRQ defined\n");\r\nreturn qup->irq;\r\n}\r\nqup->clk = devm_clk_get(qup->dev, "core");\r\nif (IS_ERR(qup->clk)) {\r\ndev_err(qup->dev, "Could not get core clock\n");\r\nreturn PTR_ERR(qup->clk);\r\n}\r\nqup->pclk = devm_clk_get(qup->dev, "iface");\r\nif (IS_ERR(qup->pclk)) {\r\ndev_err(qup->dev, "Could not get iface clock\n");\r\nreturn PTR_ERR(qup->pclk);\r\n}\r\nqup_i2c_enable_clocks(qup);\r\nwritel(1, qup->base + QUP_SW_RESET);\r\nret = qup_i2c_poll_state_valid(qup);\r\nif (ret)\r\ngoto fail;\r\nret = devm_request_irq(qup->dev, qup->irq, qup_i2c_interrupt,\r\nIRQF_TRIGGER_HIGH, "i2c_qup", qup);\r\nif (ret) {\r\ndev_err(qup->dev, "Request %d IRQ failed\n", qup->irq);\r\ngoto fail;\r\n}\r\ndisable_irq(qup->irq);\r\nhw_ver = readl(qup->base + QUP_HW_VERSION);\r\ndev_dbg(qup->dev, "Revision %x\n", hw_ver);\r\nio_mode = readl(qup->base + QUP_IO_MODE);\r\nsize = QUP_OUTPUT_BLOCK_SIZE(io_mode);\r\nif (size >= ARRAY_SIZE(blk_sizes)) {\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nqup->out_blk_sz = blk_sizes[size] / 2;\r\nsize = QUP_INPUT_BLOCK_SIZE(io_mode);\r\nif (size >= ARRAY_SIZE(blk_sizes)) {\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nqup->in_blk_sz = blk_sizes[size] / 2;\r\nsize = QUP_OUTPUT_FIFO_SIZE(io_mode);\r\nqup->out_fifo_sz = qup->out_blk_sz * (2 << size);\r\nsize = QUP_INPUT_FIFO_SIZE(io_mode);\r\nqup->in_fifo_sz = qup->in_blk_sz * (2 << size);\r\nsrc_clk_freq = clk_get_rate(qup->clk);\r\nfs_div = ((src_clk_freq / clk_freq) / 2) - 3;\r\nhs_div = 3;\r\nqup->clk_ctl = (hs_div << 8) | (fs_div & 0xff);\r\none_bit_t = (USEC_PER_SEC / clk_freq) + 1;\r\nqup->one_byte_t = one_bit_t * 9;\r\ndev_dbg(qup->dev, "IN:block:%d, fifo:%d, OUT:block:%d, fifo:%d\n",\r\nqup->in_blk_sz, qup->in_fifo_sz,\r\nqup->out_blk_sz, qup->out_fifo_sz);\r\ni2c_set_adapdata(&qup->adap, qup);\r\nqup->adap.dev.parent = qup->dev;\r\nqup->adap.dev.of_node = pdev->dev.of_node;\r\nqup->is_last = true;\r\nstrlcpy(qup->adap.name, "QUP I2C adapter", sizeof(qup->adap.name));\r\npm_runtime_set_autosuspend_delay(qup->dev, MSEC_PER_SEC);\r\npm_runtime_use_autosuspend(qup->dev);\r\npm_runtime_set_active(qup->dev);\r\npm_runtime_enable(qup->dev);\r\nret = i2c_add_adapter(&qup->adap);\r\nif (ret)\r\ngoto fail_runtime;\r\nreturn 0;\r\nfail_runtime:\r\npm_runtime_disable(qup->dev);\r\npm_runtime_set_suspended(qup->dev);\r\nfail:\r\nqup_i2c_disable_clocks(qup);\r\nfail_dma:\r\nif (qup->btx.dma)\r\ndma_release_channel(qup->btx.dma);\r\nif (qup->brx.dma)\r\ndma_release_channel(qup->brx.dma);\r\nreturn ret;\r\n}\r\nstatic int qup_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct qup_i2c_dev *qup = platform_get_drvdata(pdev);\r\nif (qup->is_dma) {\r\ndma_release_channel(qup->btx.dma);\r\ndma_release_channel(qup->brx.dma);\r\n}\r\ndisable_irq(qup->irq);\r\nqup_i2c_disable_clocks(qup);\r\ni2c_del_adapter(&qup->adap);\r\npm_runtime_disable(qup->dev);\r\npm_runtime_set_suspended(qup->dev);\r\nreturn 0;\r\n}\r\nstatic int qup_i2c_pm_suspend_runtime(struct device *device)\r\n{\r\nstruct qup_i2c_dev *qup = dev_get_drvdata(device);\r\ndev_dbg(device, "pm_runtime: suspending...\n");\r\nqup_i2c_disable_clocks(qup);\r\nreturn 0;\r\n}\r\nstatic int qup_i2c_pm_resume_runtime(struct device *device)\r\n{\r\nstruct qup_i2c_dev *qup = dev_get_drvdata(device);\r\ndev_dbg(device, "pm_runtime: resuming...\n");\r\nqup_i2c_enable_clocks(qup);\r\nreturn 0;\r\n}\r\nstatic int qup_i2c_suspend(struct device *device)\r\n{\r\nif (!pm_runtime_suspended(device))\r\nreturn qup_i2c_pm_suspend_runtime(device);\r\nreturn 0;\r\n}\r\nstatic int qup_i2c_resume(struct device *device)\r\n{\r\nqup_i2c_pm_resume_runtime(device);\r\npm_runtime_mark_last_busy(device);\r\npm_request_autosuspend(device);\r\nreturn 0;\r\n}
