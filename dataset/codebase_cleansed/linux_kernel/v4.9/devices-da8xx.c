int __init da830_register_edma(struct edma_rsv_info *rsv)\r\n{\r\nstruct platform_device *edma_pdev;\r\nda8xx_edma0_pdata.rsv = rsv;\r\nda8xx_edma0_pdata.slave_map = da830_edma_map;\r\nda8xx_edma0_pdata.slavecnt = ARRAY_SIZE(da830_edma_map);\r\nedma_pdev = platform_device_register_full(&da8xx_edma0_device);\r\nreturn IS_ERR(edma_pdev) ? PTR_ERR(edma_pdev) : 0;\r\n}\r\nint __init da850_register_edma(struct edma_rsv_info *rsv[2])\r\n{\r\nstruct platform_device *edma_pdev;\r\nif (rsv) {\r\nda8xx_edma0_pdata.rsv = rsv[0];\r\nda850_edma1_pdata.rsv = rsv[1];\r\n}\r\nda8xx_edma0_pdata.slave_map = da850_edma0_map;\r\nda8xx_edma0_pdata.slavecnt = ARRAY_SIZE(da850_edma0_map);\r\nedma_pdev = platform_device_register_full(&da8xx_edma0_device);\r\nif (IS_ERR(edma_pdev)) {\r\npr_warn("%s: Failed to register eDMA0\n", __func__);\r\nreturn PTR_ERR(edma_pdev);\r\n}\r\nda850_edma1_pdata.slave_map = da850_edma1_map;\r\nda850_edma1_pdata.slavecnt = ARRAY_SIZE(da850_edma1_map);\r\nedma_pdev = platform_device_register_full(&da850_edma1_device);\r\nreturn IS_ERR(edma_pdev) ? PTR_ERR(edma_pdev) : 0;\r\n}\r\nint __init da8xx_register_i2c(int instance,\r\nstruct davinci_i2c_platform_data *pdata)\r\n{\r\nstruct platform_device *pdev;\r\nif (instance == 0)\r\npdev = &da8xx_i2c_device0;\r\nelse if (instance == 1)\r\npdev = &da8xx_i2c_device1;\r\nelse\r\nreturn -EINVAL;\r\npdev->dev.platform_data = pdata;\r\nreturn platform_device_register(pdev);\r\n}\r\nvoid da8xx_restart(enum reboot_mode mode, const char *cmd)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device_by_name(&platform_bus_type, NULL, "davinci-wdt");\r\nif (!dev) {\r\npr_err("%s: failed to find watchdog device\n", __func__);\r\nreturn;\r\n}\r\ndavinci_watchdog_reset(to_platform_device(dev));\r\n}\r\nint __init da8xx_register_watchdog(void)\r\n{\r\nreturn platform_device_register(&da8xx_wdt_device);\r\n}\r\nint __init da8xx_register_emac(void)\r\n{\r\nint ret;\r\nret = platform_device_register(&da8xx_mdio_device);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn platform_device_register(&da8xx_emac_device);\r\n}\r\nvoid __init da8xx_register_mcasp(int id, struct snd_platform_data *pdata)\r\n{\r\nstruct platform_device *pdev;\r\nswitch (id) {\r\ncase 0:\r\npdev = &da850_mcasp_device;\r\nbreak;\r\ncase 1:\r\nif (!cpu_is_davinci_da830())\r\nreturn;\r\npdev = &da830_mcasp1_device;\r\nbreak;\r\ncase 2:\r\nif (!cpu_is_davinci_da830())\r\nreturn;\r\npdev = &da830_mcasp2_device;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\npdev->dev.platform_data = pdata;\r\nplatform_device_register(pdev);\r\n}\r\nint __init da8xx_register_uio_pruss(void)\r\n{\r\nda8xx_uio_pruss_pdata.sram_pool = sram_get_gen_pool();\r\nreturn platform_device_register(&da8xx_uio_pruss_dev);\r\n}\r\nint __init da8xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata)\r\n{\r\nda8xx_lcdc_device.dev.platform_data = pdata;\r\nreturn platform_device_register(&da8xx_lcdc_device);\r\n}\r\nint __init da8xx_register_gpio(void *pdata)\r\n{\r\nda8xx_gpio_device.dev.platform_data = pdata;\r\nreturn platform_device_register(&da8xx_gpio_device);\r\n}\r\nint __init da8xx_register_mmcsd0(struct davinci_mmc_config *config)\r\n{\r\nda8xx_mmcsd0_device.dev.platform_data = config;\r\nreturn platform_device_register(&da8xx_mmcsd0_device);\r\n}\r\nint __init da850_register_mmcsd1(struct davinci_mmc_config *config)\r\n{\r\nda850_mmcsd1_device.dev.platform_data = config;\r\nreturn platform_device_register(&da850_mmcsd1_device);\r\n}\r\nstatic int __init early_rproc_mem(char *p)\r\n{\r\nchar *endp;\r\nif (p == NULL)\r\nreturn 0;\r\nrproc_size = memparse(p, &endp);\r\nif (*endp == '@')\r\nrproc_base = memparse(endp + 1, NULL);\r\nreturn 0;\r\n}\r\nvoid __init da8xx_rproc_reserve_cma(void)\r\n{\r\nint ret;\r\nif (!rproc_base || !rproc_size) {\r\npr_err("%s: 'rproc_mem=nn@address' badly specified\n"\r\n" 'nn' and 'address' must both be non-zero\n",\r\n__func__);\r\nreturn;\r\n}\r\npr_info("%s: reserving 0x%lx @ 0x%lx...\n",\r\n__func__, rproc_size, (unsigned long)rproc_base);\r\nret = dma_declare_contiguous(&da8xx_dsp.dev, rproc_size, rproc_base, 0);\r\nif (ret)\r\npr_err("%s: dma_declare_contiguous failed %d\n", __func__, ret);\r\n}\r\nvoid __init da8xx_rproc_reserve_cma(void)\r\n{\r\n}\r\nint __init da8xx_register_rproc(void)\r\n{\r\nint ret;\r\nret = platform_device_register(&da8xx_dsp);\r\nif (ret)\r\npr_err("%s: can't register DSP device: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint da8xx_register_rtc(void)\r\n{\r\nreturn platform_device_register(&da8xx_rtc_device);\r\n}\r\nvoid __iomem * __init da8xx_get_mem_ctlr(void)\r\n{\r\nif (da8xx_ddr2_ctlr_base)\r\nreturn da8xx_ddr2_ctlr_base;\r\nda8xx_ddr2_ctlr_base = ioremap(DA8XX_DDR2_CTL_BASE, SZ_32K);\r\nif (!da8xx_ddr2_ctlr_base)\r\npr_warn("%s: Unable to map DDR2 controller", __func__);\r\nreturn da8xx_ddr2_ctlr_base;\r\n}\r\nint __init da8xx_register_cpuidle(void)\r\n{\r\nda8xx_cpuidle_pdata.ddr2_ctlr_base = da8xx_get_mem_ctlr();\r\nreturn platform_device_register(&da8xx_cpuidle_device);\r\n}\r\nint __init da8xx_register_spi_bus(int instance, unsigned num_chipselect)\r\n{\r\nif (instance < 0 || instance > 1)\r\nreturn -EINVAL;\r\nda8xx_spi_pdata[instance].num_chipselect = num_chipselect;\r\nif (instance == 1 && cpu_is_davinci_da850()) {\r\nda8xx_spi1_resources[0].start = DA850_SPI1_BASE;\r\nda8xx_spi1_resources[0].end = DA850_SPI1_BASE + SZ_4K - 1;\r\n}\r\nreturn platform_device_register(&da8xx_spi_device[instance]);\r\n}\r\nint __init da850_register_sata(unsigned long refclkpn)\r\n{\r\nBUG_ON(refclkpn != 100 * 1000 * 1000);\r\nreturn platform_device_register(&da850_sata_device);\r\n}
