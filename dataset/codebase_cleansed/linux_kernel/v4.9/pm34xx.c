static void omap3_core_save_context(void)\r\n{\r\nomap3_ctrl_save_padconf();\r\nomap_ctrl_writel(omap_ctrl_readl(OMAP343X_PADCONF_ETK_D14),\r\nOMAP343X_CONTROL_MEM_WKUP + 0x2a0);\r\nomap_intc_save_context();\r\nomap3_gpmc_save_context();\r\nomap3_control_save_context();\r\nomap_dma_global_context_save();\r\n}\r\nstatic void omap3_core_restore_context(void)\r\n{\r\nomap3_control_restore_context();\r\nomap3_gpmc_restore_context();\r\nomap_intc_restore_context();\r\nomap_dma_global_context_restore();\r\n}\r\nstatic void omap3_save_secure_ram_context(void)\r\n{\r\nu32 ret;\r\nint mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);\r\nif (omap_type() != OMAP2_DEVICE_TYPE_GP) {\r\npwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);\r\nret = _omap_save_secure_sram((u32 *)(unsigned long)\r\n__pa(omap3_secure_ram_storage));\r\npwrdm_set_next_pwrst(mpu_pwrdm, mpu_next_state);\r\nif (ret) {\r\npr_err("save_secure_sram() returns %08x\n", ret);\r\nwhile (1)\r\n;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t _prcm_int_handle_io(int irq, void *unused)\r\n{\r\nint c;\r\nc = omap_prm_clear_mod_irqs(WKUP_MOD, 1, OMAP3430_ST_IO_MASK |\r\nOMAP3430_ST_IO_CHAIN_MASK);\r\nreturn c ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic irqreturn_t _prcm_int_handle_wakeup(int irq, void *unused)\r\n{\r\nint c;\r\nc = omap_prm_clear_mod_irqs(WKUP_MOD, 1, ~(OMAP3430_ST_IO_MASK |\r\nOMAP3430_ST_IO_CHAIN_MASK));\r\nc += omap_prm_clear_mod_irqs(CORE_MOD, 1, ~0);\r\nc += omap_prm_clear_mod_irqs(OMAP3430_PER_MOD, 1, ~0);\r\nif (omap_rev() > OMAP3430_REV_ES1_0) {\r\nc += omap_prm_clear_mod_irqs(CORE_MOD, 3, ~0);\r\nc += omap_prm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1, ~0);\r\n}\r\nreturn c ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void omap34xx_save_context(u32 *save)\r\n{\r\nu32 val;\r\nasm("mrc p15, 0, %0, c1, c0, 1" : "=r" (val));\r\n*save++ = 1;\r\n*save++ = val;\r\nasm("mrc p15, 1, %0, c9, c0, 2" : "=r" (val));\r\n*save++ = 1;\r\n*save++ = val;\r\n}\r\nstatic int omap34xx_do_sram_idle(unsigned long save_state)\r\n{\r\nomap34xx_cpu_suspend(save_state);\r\nreturn 0;\r\n}\r\nvoid omap_sram_idle(void)\r\n{\r\nint save_state = 0;\r\nint mpu_next_state = PWRDM_POWER_ON;\r\nint per_next_state = PWRDM_POWER_ON;\r\nint core_next_state = PWRDM_POWER_ON;\r\nint per_going_off;\r\nu32 sdrc_pwr = 0;\r\nmpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);\r\nswitch (mpu_next_state) {\r\ncase PWRDM_POWER_ON:\r\ncase PWRDM_POWER_RET:\r\nsave_state = 0;\r\nbreak;\r\ncase PWRDM_POWER_OFF:\r\nsave_state = 3;\r\nbreak;\r\ndefault:\r\npr_err("Invalid mpu state in sram_idle\n");\r\nreturn;\r\n}\r\nif (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)\r\npwrdm_set_next_pwrst(neon_pwrdm, mpu_next_state);\r\nper_next_state = pwrdm_read_next_pwrst(per_pwrdm);\r\ncore_next_state = pwrdm_read_next_pwrst(core_pwrdm);\r\npwrdm_pre_transition(NULL);\r\nif (per_next_state < PWRDM_POWER_ON) {\r\nper_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;\r\nomap2_gpio_prepare_for_idle(per_going_off);\r\n}\r\nif (core_next_state < PWRDM_POWER_ON) {\r\nif (core_next_state == PWRDM_POWER_OFF) {\r\nomap3_core_save_context();\r\nomap3_cm_save_context();\r\n}\r\n}\r\nomap3_vc_set_pmic_signaling(core_next_state);\r\nomap3_intc_prepare_idle();\r\nif (cpu_is_omap3430() && omap_rev() >= OMAP3430_REV_ES3_0 &&\r\n(omap_type() == OMAP2_DEVICE_TYPE_EMU ||\r\nomap_type() == OMAP2_DEVICE_TYPE_SEC) &&\r\ncore_next_state == PWRDM_POWER_OFF)\r\nsdrc_pwr = sdrc_read_reg(SDRC_POWER);\r\nif (save_state)\r\nomap34xx_save_context(omap3_arm_context);\r\nif (save_state == 1 || save_state == 3)\r\ncpu_suspend(save_state, omap34xx_do_sram_idle);\r\nelse\r\nomap34xx_do_sram_idle(save_state);\r\nif (cpu_is_omap3430() && omap_rev() >= OMAP3430_REV_ES3_0 &&\r\n(omap_type() == OMAP2_DEVICE_TYPE_EMU ||\r\nomap_type() == OMAP2_DEVICE_TYPE_SEC) &&\r\ncore_next_state == PWRDM_POWER_OFF)\r\nsdrc_write_reg(sdrc_pwr, SDRC_POWER);\r\nif (core_next_state < PWRDM_POWER_ON &&\r\npwrdm_read_prev_pwrst(core_pwrdm) == PWRDM_POWER_OFF) {\r\nomap3_core_restore_context();\r\nomap3_cm_restore_context();\r\nomap3_sram_restore_context();\r\nomap2_sms_restore_context();\r\n} else {\r\nomap3_intc_resume_idle();\r\n}\r\npwrdm_post_transition(NULL);\r\nif (per_next_state < PWRDM_POWER_ON)\r\nomap2_gpio_resume_after_idle();\r\n}\r\nstatic void omap3_pm_idle(void)\r\n{\r\nif (omap_irq_pending())\r\nreturn;\r\ntrace_cpu_idle_rcuidle(1, smp_processor_id());\r\nomap_sram_idle();\r\ntrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());\r\n}\r\nstatic int omap3_pm_suspend(void)\r\n{\r\nstruct power_state *pwrst;\r\nint state, ret = 0;\r\nlist_for_each_entry(pwrst, &pwrst_list, node)\r\npwrst->saved_state = pwrdm_read_next_pwrst(pwrst->pwrdm);\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nif (omap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state))\r\ngoto restore;\r\nif (pwrdm_clear_all_prev_pwrst(pwrst->pwrdm))\r\ngoto restore;\r\n}\r\nomap3_intc_suspend();\r\nomap_sram_idle();\r\nrestore:\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nstate = pwrdm_read_prev_pwrst(pwrst->pwrdm);\r\nif (state > pwrst->next_state) {\r\npr_info("Powerdomain (%s) didn't enter target state %d\n",\r\npwrst->pwrdm->name, pwrst->next_state);\r\nret = -1;\r\n}\r\nomap_set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);\r\n}\r\nif (ret)\r\npr_err("Could not enter target state in pm_suspend\n");\r\nelse\r\npr_info("Successfully put all powerdomains to target state\n");\r\nreturn ret;\r\n}\r\nstatic void __init prcm_setup_regs(void)\r\n{\r\nomap3_ctrl_init();\r\nomap3_prm_init_pm(cpu_is_omap3630(), omap3_has_iva());\r\n}\r\nvoid omap3_pm_off_mode_enable(int enable)\r\n{\r\nstruct power_state *pwrst;\r\nu32 state;\r\nif (enable)\r\nstate = PWRDM_POWER_OFF;\r\nelse\r\nstate = PWRDM_POWER_RET;\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nif (IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583) &&\r\npwrst->pwrdm == core_pwrdm &&\r\nstate == PWRDM_POWER_OFF) {\r\npwrst->next_state = PWRDM_POWER_RET;\r\npr_warn("%s: Core OFF disabled due to errata i583\n",\r\n__func__);\r\n} else {\r\npwrst->next_state = state;\r\n}\r\nomap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);\r\n}\r\n}\r\nint omap3_pm_get_suspend_state(struct powerdomain *pwrdm)\r\n{\r\nstruct power_state *pwrst;\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nif (pwrst->pwrdm == pwrdm)\r\nreturn pwrst->next_state;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint omap3_pm_set_suspend_state(struct powerdomain *pwrdm, int state)\r\n{\r\nstruct power_state *pwrst;\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nif (pwrst->pwrdm == pwrdm) {\r\npwrst->next_state = state;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)\r\n{\r\nstruct power_state *pwrst;\r\nif (!pwrdm->pwrsts)\r\nreturn 0;\r\npwrst = kmalloc(sizeof(struct power_state), GFP_ATOMIC);\r\nif (!pwrst)\r\nreturn -ENOMEM;\r\npwrst->pwrdm = pwrdm;\r\npwrst->next_state = PWRDM_POWER_RET;\r\nlist_add(&pwrst->node, &pwrst_list);\r\nif (pwrdm_has_hdwr_sar(pwrdm))\r\npwrdm_enable_hdwr_sar(pwrdm);\r\nreturn omap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);\r\n}\r\nvoid omap_push_sram_idle(void)\r\n{\r\nomap3_do_wfi_sram = omap_sram_push(omap3_do_wfi, omap3_do_wfi_sz);\r\nif (omap_type() != OMAP2_DEVICE_TYPE_GP)\r\n_omap_save_secure_sram = omap_sram_push(save_secure_ram_context,\r\nsave_secure_ram_context_sz);\r\n}\r\nstatic void __init pm_errata_configure(void)\r\n{\r\nif (cpu_is_omap3630()) {\r\npm34xx_errata |= PM_RTA_ERRATUM_i608;\r\nenable_omap3630_toggle_l2_on_restore();\r\nif (omap_rev() < OMAP3630_REV_ES1_2)\r\npm34xx_errata |= (PM_SDRC_WAKEUP_ERRATUM_i583 |\r\nPM_PER_MEMORIES_ERRATUM_i582);\r\n} else if (cpu_is_omap34xx()) {\r\npm34xx_errata |= PM_PER_MEMORIES_ERRATUM_i582;\r\n}\r\n}\r\nint __init omap3_pm_init(void)\r\n{\r\nstruct power_state *pwrst, *tmp;\r\nstruct clockdomain *neon_clkdm, *mpu_clkdm, *per_clkdm, *wkup_clkdm;\r\nint ret;\r\nif (!omap3_has_io_chain_ctrl())\r\npr_warn("PM: no software I/O chain control; some wakeups may be lost\n");\r\npm_errata_configure();\r\nprcm_setup_regs();\r\nret = request_irq(omap_prcm_event_to_irq("wkup"),\r\n_prcm_int_handle_wakeup, IRQF_NO_SUSPEND, "pm_wkup", NULL);\r\nif (ret) {\r\npr_err("pm: Failed to request pm_wkup irq\n");\r\ngoto err1;\r\n}\r\nret = request_irq(omap_prcm_event_to_irq("io"),\r\n_prcm_int_handle_io, IRQF_SHARED | IRQF_NO_SUSPEND, "pm_io",\r\nomap3_pm_init);\r\nenable_irq(omap_prcm_event_to_irq("io"));\r\nif (ret) {\r\npr_err("pm: Failed to request pm_io irq\n");\r\ngoto err2;\r\n}\r\nret = pwrdm_for_each(pwrdms_setup, NULL);\r\nif (ret) {\r\npr_err("Failed to setup powerdomains\n");\r\ngoto err3;\r\n}\r\n(void) clkdm_for_each(omap_pm_clkdms_setup, NULL);\r\nmpu_pwrdm = pwrdm_lookup("mpu_pwrdm");\r\nif (mpu_pwrdm == NULL) {\r\npr_err("Failed to get mpu_pwrdm\n");\r\nret = -EINVAL;\r\ngoto err3;\r\n}\r\nneon_pwrdm = pwrdm_lookup("neon_pwrdm");\r\nper_pwrdm = pwrdm_lookup("per_pwrdm");\r\ncore_pwrdm = pwrdm_lookup("core_pwrdm");\r\nneon_clkdm = clkdm_lookup("neon_clkdm");\r\nmpu_clkdm = clkdm_lookup("mpu_clkdm");\r\nper_clkdm = clkdm_lookup("per_clkdm");\r\nwkup_clkdm = clkdm_lookup("wkup_clkdm");\r\nomap_common_suspend_init(omap3_pm_suspend);\r\narm_pm_idle = omap3_pm_idle;\r\nomap3_idle_init();\r\nif (IS_PM34XX_ERRATUM(PM_RTA_ERRATUM_i608))\r\nomap3630_ctrl_disable_rta();\r\nif (IS_PM34XX_ERRATUM(PM_PER_MEMORIES_ERRATUM_i582))\r\nclkdm_add_wkdep(per_clkdm, wkup_clkdm);\r\nclkdm_add_wkdep(neon_clkdm, mpu_clkdm);\r\nif (omap_type() != OMAP2_DEVICE_TYPE_GP) {\r\nomap3_secure_ram_storage =\r\nkmalloc(0x803F, GFP_KERNEL);\r\nif (!omap3_secure_ram_storage)\r\npr_err("Memory allocation failed when allocating for secure sram context\n");\r\nlocal_irq_disable();\r\nomap_dma_global_context_save();\r\nomap3_save_secure_ram_context();\r\nomap_dma_global_context_restore();\r\nlocal_irq_enable();\r\n}\r\nomap3_save_scratchpad_contents();\r\nreturn ret;\r\nerr3:\r\nlist_for_each_entry_safe(pwrst, tmp, &pwrst_list, node) {\r\nlist_del(&pwrst->node);\r\nkfree(pwrst);\r\n}\r\nfree_irq(omap_prcm_event_to_irq("io"), omap3_pm_init);\r\nerr2:\r\nfree_irq(omap_prcm_event_to_irq("wkup"), NULL);\r\nerr1:\r\nreturn ret;\r\n}
