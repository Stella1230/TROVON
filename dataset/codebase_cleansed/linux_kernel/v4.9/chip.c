static void brcmf_chip_sb_corerev(struct brcmf_chip_priv *ci,\r\nstruct brcmf_core *core)\r\n{\r\nu32 regdata;\r\nregdata = ci->ops->read32(ci->ctx, CORE_SB(core->base, sbidhigh));\r\ncore->rev = SBCOREREV(regdata);\r\n}\r\nstatic bool brcmf_chip_sb_iscoreup(struct brcmf_core_priv *core)\r\n{\r\nstruct brcmf_chip_priv *ci;\r\nu32 regdata;\r\nu32 address;\r\nci = core->chip;\r\naddress = CORE_SB(core->pub.base, sbtmstatelow);\r\nregdata = ci->ops->read32(ci->ctx, address);\r\nregdata &= (SSB_TMSLOW_RESET | SSB_TMSLOW_REJECT |\r\nSSB_IMSTATE_REJECT | SSB_TMSLOW_CLOCK);\r\nreturn SSB_TMSLOW_CLOCK == regdata;\r\n}\r\nstatic bool brcmf_chip_ai_iscoreup(struct brcmf_core_priv *core)\r\n{\r\nstruct brcmf_chip_priv *ci;\r\nu32 regdata;\r\nbool ret;\r\nci = core->chip;\r\nregdata = ci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);\r\nret = (regdata & (BCMA_IOCTL_FGC | BCMA_IOCTL_CLK)) == BCMA_IOCTL_CLK;\r\nregdata = ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL);\r\nret = ret && ((regdata & BCMA_RESET_CTL_RESET) == 0);\r\nreturn ret;\r\n}\r\nstatic void brcmf_chip_sb_coredisable(struct brcmf_core_priv *core,\r\nu32 prereset, u32 reset)\r\n{\r\nstruct brcmf_chip_priv *ci;\r\nu32 val, base;\r\nci = core->chip;\r\nbase = core->pub.base;\r\nval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\r\nif (val & SSB_TMSLOW_RESET)\r\nreturn;\r\nval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\r\nif ((val & SSB_TMSLOW_CLOCK) != 0) {\r\nval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\r\nci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\r\nval | SSB_TMSLOW_REJECT);\r\nval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\r\nudelay(1);\r\nSPINWAIT((ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatehigh))\r\n& SSB_TMSHIGH_BUSY), 100000);\r\nval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatehigh));\r\nif (val & SSB_TMSHIGH_BUSY)\r\nbrcmf_err("core state still busy\n");\r\nval = ci->ops->read32(ci->ctx, CORE_SB(base, sbidlow));\r\nif (val & SSB_IDLOW_INITIATOR) {\r\nval = ci->ops->read32(ci->ctx,\r\nCORE_SB(base, sbimstate));\r\nval |= SSB_IMSTATE_REJECT;\r\nci->ops->write32(ci->ctx,\r\nCORE_SB(base, sbimstate), val);\r\nval = ci->ops->read32(ci->ctx,\r\nCORE_SB(base, sbimstate));\r\nudelay(1);\r\nSPINWAIT((ci->ops->read32(ci->ctx,\r\nCORE_SB(base, sbimstate)) &\r\nSSB_IMSTATE_BUSY), 100000);\r\n}\r\nval = SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |\r\nSSB_TMSLOW_REJECT | SSB_TMSLOW_RESET;\r\nci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow), val);\r\nval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\r\nudelay(10);\r\nval = ci->ops->read32(ci->ctx, CORE_SB(base, sbidlow));\r\nif (val & SSB_IDLOW_INITIATOR) {\r\nval = ci->ops->read32(ci->ctx,\r\nCORE_SB(base, sbimstate));\r\nval &= ~SSB_IMSTATE_REJECT;\r\nci->ops->write32(ci->ctx,\r\nCORE_SB(base, sbimstate), val);\r\n}\r\n}\r\nci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\r\n(SSB_TMSLOW_REJECT | SSB_TMSLOW_RESET));\r\nudelay(1);\r\n}\r\nstatic void brcmf_chip_ai_coredisable(struct brcmf_core_priv *core,\r\nu32 prereset, u32 reset)\r\n{\r\nstruct brcmf_chip_priv *ci;\r\nu32 regdata;\r\nci = core->chip;\r\nregdata = ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL);\r\nif ((regdata & BCMA_RESET_CTL_RESET) != 0)\r\ngoto in_reset_configure;\r\nci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,\r\nprereset | BCMA_IOCTL_FGC | BCMA_IOCTL_CLK);\r\nci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);\r\nci->ops->write32(ci->ctx, core->wrapbase + BCMA_RESET_CTL,\r\nBCMA_RESET_CTL_RESET);\r\nusleep_range(10, 20);\r\nSPINWAIT(ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL) !=\r\nBCMA_RESET_CTL_RESET, 300);\r\nin_reset_configure:\r\nci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,\r\nreset | BCMA_IOCTL_FGC | BCMA_IOCTL_CLK);\r\nci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);\r\n}\r\nstatic void brcmf_chip_sb_resetcore(struct brcmf_core_priv *core, u32 prereset,\r\nu32 reset, u32 postreset)\r\n{\r\nstruct brcmf_chip_priv *ci;\r\nu32 regdata;\r\nu32 base;\r\nci = core->chip;\r\nbase = core->pub.base;\r\nbrcmf_chip_sb_coredisable(core, 0, 0);\r\nci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\r\nSSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |\r\nSSB_TMSLOW_RESET);\r\nregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\r\nudelay(1);\r\nregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatehigh));\r\nif (regdata & SSB_TMSHIGH_SERR)\r\nci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatehigh), 0);\r\nregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbimstate));\r\nif (regdata & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO)) {\r\nregdata &= ~(SSB_IMSTATE_IBE | SSB_IMSTATE_TO);\r\nci->ops->write32(ci->ctx, CORE_SB(base, sbimstate), regdata);\r\n}\r\nci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\r\nSSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK);\r\nregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\r\nudelay(1);\r\nci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\r\nSSB_TMSLOW_CLOCK);\r\nregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\r\nudelay(1);\r\n}\r\nstatic void brcmf_chip_ai_resetcore(struct brcmf_core_priv *core, u32 prereset,\r\nu32 reset, u32 postreset)\r\n{\r\nstruct brcmf_chip_priv *ci;\r\nint count;\r\nci = core->chip;\r\nbrcmf_chip_ai_coredisable(core, prereset, reset);\r\ncount = 0;\r\nwhile (ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL) &\r\nBCMA_RESET_CTL_RESET) {\r\nci->ops->write32(ci->ctx, core->wrapbase + BCMA_RESET_CTL, 0);\r\ncount++;\r\nif (count > 50)\r\nbreak;\r\nusleep_range(40, 60);\r\n}\r\nci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,\r\npostreset | BCMA_IOCTL_CLK);\r\nci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);\r\n}\r\nstatic char *brcmf_chip_name(uint chipid, char *buf, uint len)\r\n{\r\nconst char *fmt;\r\nfmt = ((chipid > 0xa000) || (chipid < 0x4000)) ? "%d" : "%x";\r\nsnprintf(buf, len, fmt, chipid);\r\nreturn buf;\r\n}\r\nstatic struct brcmf_core *brcmf_chip_add_core(struct brcmf_chip_priv *ci,\r\nu16 coreid, u32 base,\r\nu32 wrapbase)\r\n{\r\nstruct brcmf_core_priv *core;\r\ncore = kzalloc(sizeof(*core), GFP_KERNEL);\r\nif (!core)\r\nreturn ERR_PTR(-ENOMEM);\r\ncore->pub.id = coreid;\r\ncore->pub.base = base;\r\ncore->chip = ci;\r\ncore->wrapbase = wrapbase;\r\nlist_add_tail(&core->list, &ci->cores);\r\nreturn &core->pub;\r\n}\r\nstatic int brcmf_chip_cores_check(struct brcmf_chip_priv *ci)\r\n{\r\nstruct brcmf_core_priv *core;\r\nbool need_socram = false;\r\nbool has_socram = false;\r\nbool cpu_found = false;\r\nint idx = 1;\r\nlist_for_each_entry(core, &ci->cores, list) {\r\nbrcmf_dbg(INFO, " [%-2d] core 0x%x:%-2d base 0x%08x wrap 0x%08x\n",\r\nidx++, core->pub.id, core->pub.rev, core->pub.base,\r\ncore->wrapbase);\r\nswitch (core->pub.id) {\r\ncase BCMA_CORE_ARM_CM3:\r\ncpu_found = true;\r\nneed_socram = true;\r\nbreak;\r\ncase BCMA_CORE_INTERNAL_MEM:\r\nhas_socram = true;\r\nbreak;\r\ncase BCMA_CORE_ARM_CR4:\r\ncpu_found = true;\r\nbreak;\r\ncase BCMA_CORE_ARM_CA7:\r\ncpu_found = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (!cpu_found) {\r\nbrcmf_err("CPU core not detected\n");\r\nreturn -ENXIO;\r\n}\r\nif (need_socram && !has_socram) {\r\nbrcmf_err("RAM core not provided with ARM CM3 core\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 brcmf_chip_core_read32(struct brcmf_core_priv *core, u16 reg)\r\n{\r\nreturn core->chip->ops->read32(core->chip->ctx, core->pub.base + reg);\r\n}\r\nstatic void brcmf_chip_core_write32(struct brcmf_core_priv *core,\r\nu16 reg, u32 val)\r\n{\r\ncore->chip->ops->write32(core->chip->ctx, core->pub.base + reg, val);\r\n}\r\nstatic bool brcmf_chip_socram_banksize(struct brcmf_core_priv *core, u8 idx,\r\nu32 *banksize)\r\n{\r\nu32 bankinfo;\r\nu32 bankidx = (SOCRAM_MEMTYPE_RAM << SOCRAM_BANKIDX_MEMTYPE_SHIFT);\r\nbankidx |= idx;\r\nbrcmf_chip_core_write32(core, SOCRAMREGOFFS(bankidx), bankidx);\r\nbankinfo = brcmf_chip_core_read32(core, SOCRAMREGOFFS(bankinfo));\r\n*banksize = (bankinfo & SOCRAM_BANKINFO_SZMASK) + 1;\r\n*banksize *= SOCRAM_BANKINFO_SZBASE;\r\nreturn !!(bankinfo & SOCRAM_BANKINFO_RETNTRAM_MASK);\r\n}\r\nstatic void brcmf_chip_socram_ramsize(struct brcmf_core_priv *sr, u32 *ramsize,\r\nu32 *srsize)\r\n{\r\nu32 coreinfo;\r\nuint nb, banksize, lss;\r\nbool retent;\r\nint i;\r\n*ramsize = 0;\r\n*srsize = 0;\r\nif (WARN_ON(sr->pub.rev < 4))\r\nreturn;\r\nif (!brcmf_chip_iscoreup(&sr->pub))\r\nbrcmf_chip_resetcore(&sr->pub, 0, 0, 0);\r\ncoreinfo = brcmf_chip_core_read32(sr, SOCRAMREGOFFS(coreinfo));\r\nnb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;\r\nif ((sr->pub.rev <= 7) || (sr->pub.rev == 12)) {\r\nbanksize = (coreinfo & SRCI_SRBSZ_MASK);\r\nlss = (coreinfo & SRCI_LSS_MASK) >> SRCI_LSS_SHIFT;\r\nif (lss != 0)\r\nnb--;\r\n*ramsize = nb * (1 << (banksize + SR_BSZ_BASE));\r\nif (lss != 0)\r\n*ramsize += (1 << ((lss - 1) + SR_BSZ_BASE));\r\n} else {\r\nnb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;\r\nfor (i = 0; i < nb; i++) {\r\nretent = brcmf_chip_socram_banksize(sr, i, &banksize);\r\n*ramsize += banksize;\r\nif (retent)\r\n*srsize += banksize;\r\n}\r\n}\r\nswitch (sr->chip->pub.chip) {\r\ncase BRCM_CC_4334_CHIP_ID:\r\nif (sr->chip->pub.chiprev < 2)\r\n*srsize = (32 * 1024);\r\nbreak;\r\ncase BRCM_CC_43430_CHIP_ID:\r\n*srsize = (64 * 1024);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic u32 brcmf_chip_sysmem_ramsize(struct brcmf_core_priv *sysmem)\r\n{\r\nu32 memsize = 0;\r\nu32 coreinfo;\r\nu32 idx;\r\nu32 nb;\r\nu32 banksize;\r\nif (!brcmf_chip_iscoreup(&sysmem->pub))\r\nbrcmf_chip_resetcore(&sysmem->pub, 0, 0, 0);\r\ncoreinfo = brcmf_chip_core_read32(sysmem, SYSMEMREGOFFS(coreinfo));\r\nnb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;\r\nfor (idx = 0; idx < nb; idx++) {\r\nbrcmf_chip_socram_banksize(sysmem, idx, &banksize);\r\nmemsize += banksize;\r\n}\r\nreturn memsize;\r\n}\r\nstatic u32 brcmf_chip_tcm_ramsize(struct brcmf_core_priv *cr4)\r\n{\r\nu32 corecap;\r\nu32 memsize = 0;\r\nu32 nab;\r\nu32 nbb;\r\nu32 totb;\r\nu32 bxinfo;\r\nu32 idx;\r\ncorecap = brcmf_chip_core_read32(cr4, ARMCR4_CAP);\r\nnab = (corecap & ARMCR4_TCBANB_MASK) >> ARMCR4_TCBANB_SHIFT;\r\nnbb = (corecap & ARMCR4_TCBBNB_MASK) >> ARMCR4_TCBBNB_SHIFT;\r\ntotb = nab + nbb;\r\nfor (idx = 0; idx < totb; idx++) {\r\nbrcmf_chip_core_write32(cr4, ARMCR4_BANKIDX, idx);\r\nbxinfo = brcmf_chip_core_read32(cr4, ARMCR4_BANKINFO);\r\nmemsize += ((bxinfo & ARMCR4_BSZ_MASK) + 1) * ARMCR4_BSZ_MULT;\r\n}\r\nreturn memsize;\r\n}\r\nstatic u32 brcmf_chip_tcm_rambase(struct brcmf_chip_priv *ci)\r\n{\r\nswitch (ci->pub.chip) {\r\ncase BRCM_CC_4345_CHIP_ID:\r\nreturn 0x198000;\r\ncase BRCM_CC_4335_CHIP_ID:\r\ncase BRCM_CC_4339_CHIP_ID:\r\ncase BRCM_CC_4350_CHIP_ID:\r\ncase BRCM_CC_4354_CHIP_ID:\r\ncase BRCM_CC_4356_CHIP_ID:\r\ncase BRCM_CC_43567_CHIP_ID:\r\ncase BRCM_CC_43569_CHIP_ID:\r\ncase BRCM_CC_43570_CHIP_ID:\r\ncase BRCM_CC_4358_CHIP_ID:\r\ncase BRCM_CC_4359_CHIP_ID:\r\ncase BRCM_CC_43602_CHIP_ID:\r\ncase BRCM_CC_4371_CHIP_ID:\r\nreturn 0x180000;\r\ncase BRCM_CC_43465_CHIP_ID:\r\ncase BRCM_CC_43525_CHIP_ID:\r\ncase BRCM_CC_4365_CHIP_ID:\r\ncase BRCM_CC_4366_CHIP_ID:\r\nreturn 0x200000;\r\ndefault:\r\nbrcmf_err("unknown chip: %s\n", ci->pub.name);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmf_chip_get_raminfo(struct brcmf_chip_priv *ci)\r\n{\r\nstruct brcmf_core_priv *mem_core;\r\nstruct brcmf_core *mem;\r\nmem = brcmf_chip_get_core(&ci->pub, BCMA_CORE_ARM_CR4);\r\nif (mem) {\r\nmem_core = container_of(mem, struct brcmf_core_priv, pub);\r\nci->pub.ramsize = brcmf_chip_tcm_ramsize(mem_core);\r\nci->pub.rambase = brcmf_chip_tcm_rambase(ci);\r\nif (!ci->pub.rambase) {\r\nbrcmf_err("RAM base not provided with ARM CR4 core\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nmem = brcmf_chip_get_core(&ci->pub, BCMA_CORE_SYS_MEM);\r\nif (mem) {\r\nmem_core = container_of(mem, struct brcmf_core_priv,\r\npub);\r\nci->pub.ramsize = brcmf_chip_sysmem_ramsize(mem_core);\r\nci->pub.rambase = brcmf_chip_tcm_rambase(ci);\r\nif (!ci->pub.rambase) {\r\nbrcmf_err("RAM base not provided with ARM CA7 core\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nmem = brcmf_chip_get_core(&ci->pub,\r\nBCMA_CORE_INTERNAL_MEM);\r\nif (!mem) {\r\nbrcmf_err("No memory cores found\n");\r\nreturn -ENOMEM;\r\n}\r\nmem_core = container_of(mem, struct brcmf_core_priv,\r\npub);\r\nbrcmf_chip_socram_ramsize(mem_core, &ci->pub.ramsize,\r\n&ci->pub.srsize);\r\n}\r\n}\r\nbrcmf_dbg(INFO, "RAM: base=0x%x size=%d (0x%x) sr=%d (0x%x)\n",\r\nci->pub.rambase, ci->pub.ramsize, ci->pub.ramsize,\r\nci->pub.srsize, ci->pub.srsize);\r\nif (!ci->pub.ramsize) {\r\nbrcmf_err("RAM size is undetermined\n");\r\nreturn -ENOMEM;\r\n}\r\nif (ci->pub.ramsize > BRCMF_CHIP_MAX_MEMSIZE) {\r\nbrcmf_err("RAM size is incorrect\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 brcmf_chip_dmp_get_desc(struct brcmf_chip_priv *ci, u32 *eromaddr,\r\nu8 *type)\r\n{\r\nu32 val;\r\nval = ci->ops->read32(ci->ctx, *eromaddr);\r\n*eromaddr += 4;\r\nif (!type)\r\nreturn val;\r\n*type = (val & DMP_DESC_TYPE_MSK);\r\nif ((*type & ~DMP_DESC_ADDRSIZE_GT32) == DMP_DESC_ADDRESS)\r\n*type = DMP_DESC_ADDRESS;\r\nreturn val;\r\n}\r\nstatic int brcmf_chip_dmp_get_regaddr(struct brcmf_chip_priv *ci, u32 *eromaddr,\r\nu32 *regbase, u32 *wrapbase)\r\n{\r\nu8 desc;\r\nu32 val;\r\nu8 mpnum = 0;\r\nu8 stype, sztype, wraptype;\r\n*regbase = 0;\r\n*wrapbase = 0;\r\nval = brcmf_chip_dmp_get_desc(ci, eromaddr, &desc);\r\nif (desc == DMP_DESC_MASTER_PORT) {\r\nmpnum = (val & DMP_MASTER_PORT_NUM) >> DMP_MASTER_PORT_NUM_S;\r\nwraptype = DMP_SLAVE_TYPE_MWRAP;\r\n} else if (desc == DMP_DESC_ADDRESS) {\r\n*eromaddr -= 4;\r\nwraptype = DMP_SLAVE_TYPE_SWRAP;\r\n} else {\r\n*eromaddr -= 4;\r\nreturn -EILSEQ;\r\n}\r\ndo {\r\ndo {\r\nval = brcmf_chip_dmp_get_desc(ci, eromaddr, &desc);\r\nif (desc == DMP_DESC_EOT) {\r\n*eromaddr -= 4;\r\nreturn -EFAULT;\r\n}\r\n} while (desc != DMP_DESC_ADDRESS &&\r\ndesc != DMP_DESC_COMPONENT);\r\nif (desc == DMP_DESC_COMPONENT) {\r\n*eromaddr -= 4;\r\nreturn 0;\r\n}\r\nif (val & DMP_DESC_ADDRSIZE_GT32)\r\nbrcmf_chip_dmp_get_desc(ci, eromaddr, NULL);\r\nsztype = (val & DMP_SLAVE_SIZE_TYPE) >> DMP_SLAVE_SIZE_TYPE_S;\r\nif (sztype == DMP_SLAVE_SIZE_DESC) {\r\nval = brcmf_chip_dmp_get_desc(ci, eromaddr, NULL);\r\nif (val & DMP_DESC_ADDRSIZE_GT32)\r\nbrcmf_chip_dmp_get_desc(ci, eromaddr, NULL);\r\n}\r\nif (sztype != DMP_SLAVE_SIZE_4K)\r\ncontinue;\r\nstype = (val & DMP_SLAVE_TYPE) >> DMP_SLAVE_TYPE_S;\r\nif (*regbase == 0 && stype == DMP_SLAVE_TYPE_SLAVE)\r\n*regbase = val & DMP_SLAVE_ADDR_BASE;\r\nif (*wrapbase == 0 && stype == wraptype)\r\n*wrapbase = val & DMP_SLAVE_ADDR_BASE;\r\n} while (*regbase == 0 || *wrapbase == 0);\r\nreturn 0;\r\n}\r\nstatic\r\nint brcmf_chip_dmp_erom_scan(struct brcmf_chip_priv *ci)\r\n{\r\nstruct brcmf_core *core;\r\nu32 eromaddr;\r\nu8 desc_type = 0;\r\nu32 val;\r\nu16 id;\r\nu8 nmp, nsp, nmw, nsw, rev;\r\nu32 base, wrap;\r\nint err;\r\neromaddr = ci->ops->read32(ci->ctx, CORE_CC_REG(SI_ENUM_BASE, eromptr));\r\nwhile (desc_type != DMP_DESC_EOT) {\r\nval = brcmf_chip_dmp_get_desc(ci, &eromaddr, &desc_type);\r\nif (!(val & DMP_DESC_VALID))\r\ncontinue;\r\nif (desc_type == DMP_DESC_EMPTY)\r\ncontinue;\r\nif (desc_type != DMP_DESC_COMPONENT)\r\ncontinue;\r\nid = (val & DMP_COMP_PARTNUM) >> DMP_COMP_PARTNUM_S;\r\nval = brcmf_chip_dmp_get_desc(ci, &eromaddr, &desc_type);\r\nif (WARN_ON((val & DMP_DESC_TYPE_MSK) != DMP_DESC_COMPONENT))\r\nreturn -EFAULT;\r\nnmp = (val & DMP_COMP_NUM_MPORT) >> DMP_COMP_NUM_MPORT_S;\r\nnsp = (val & DMP_COMP_NUM_SPORT) >> DMP_COMP_NUM_SPORT_S;\r\nnmw = (val & DMP_COMP_NUM_MWRAP) >> DMP_COMP_NUM_MWRAP_S;\r\nnsw = (val & DMP_COMP_NUM_SWRAP) >> DMP_COMP_NUM_SWRAP_S;\r\nrev = (val & DMP_COMP_REVISION) >> DMP_COMP_REVISION_S;\r\nif (nmw + nsw == 0 &&\r\nid != BCMA_CORE_PMU)\r\ncontinue;\r\nerr = brcmf_chip_dmp_get_regaddr(ci, &eromaddr, &base, &wrap);\r\nif (err)\r\ncontinue;\r\ncore = brcmf_chip_add_core(ci, id, base, wrap);\r\nif (IS_ERR(core))\r\nreturn PTR_ERR(core);\r\ncore->rev = rev;\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmf_chip_recognition(struct brcmf_chip_priv *ci)\r\n{\r\nstruct brcmf_core *core;\r\nu32 regdata;\r\nu32 socitype;\r\nint ret;\r\nregdata = ci->ops->read32(ci->ctx, CORE_CC_REG(SI_ENUM_BASE, chipid));\r\nci->pub.chip = regdata & CID_ID_MASK;\r\nci->pub.chiprev = (regdata & CID_REV_MASK) >> CID_REV_SHIFT;\r\nsocitype = (regdata & CID_TYPE_MASK) >> CID_TYPE_SHIFT;\r\nbrcmf_chip_name(ci->pub.chip, ci->pub.name, sizeof(ci->pub.name));\r\nbrcmf_dbg(INFO, "found %s chip: BCM%s, rev=%d\n",\r\nsocitype == SOCI_SB ? "SB" : "AXI", ci->pub.name,\r\nci->pub.chiprev);\r\nif (socitype == SOCI_SB) {\r\nif (ci->pub.chip != BRCM_CC_4329_CHIP_ID) {\r\nbrcmf_err("SB chip is not supported\n");\r\nreturn -ENODEV;\r\n}\r\nci->iscoreup = brcmf_chip_sb_iscoreup;\r\nci->coredisable = brcmf_chip_sb_coredisable;\r\nci->resetcore = brcmf_chip_sb_resetcore;\r\ncore = brcmf_chip_add_core(ci, BCMA_CORE_CHIPCOMMON,\r\nSI_ENUM_BASE, 0);\r\nbrcmf_chip_sb_corerev(ci, core);\r\ncore = brcmf_chip_add_core(ci, BCMA_CORE_SDIO_DEV,\r\nBCM4329_CORE_BUS_BASE, 0);\r\nbrcmf_chip_sb_corerev(ci, core);\r\ncore = brcmf_chip_add_core(ci, BCMA_CORE_INTERNAL_MEM,\r\nBCM4329_CORE_SOCRAM_BASE, 0);\r\nbrcmf_chip_sb_corerev(ci, core);\r\ncore = brcmf_chip_add_core(ci, BCMA_CORE_ARM_CM3,\r\nBCM4329_CORE_ARM_BASE, 0);\r\nbrcmf_chip_sb_corerev(ci, core);\r\ncore = brcmf_chip_add_core(ci, BCMA_CORE_80211, 0x18001000, 0);\r\nbrcmf_chip_sb_corerev(ci, core);\r\n} else if (socitype == SOCI_AI) {\r\nci->iscoreup = brcmf_chip_ai_iscoreup;\r\nci->coredisable = brcmf_chip_ai_coredisable;\r\nci->resetcore = brcmf_chip_ai_resetcore;\r\nbrcmf_chip_dmp_erom_scan(ci);\r\n} else {\r\nbrcmf_err("chip backplane type %u is not supported\n",\r\nsocitype);\r\nreturn -ENODEV;\r\n}\r\nret = brcmf_chip_cores_check(ci);\r\nif (ret)\r\nreturn ret;\r\nbrcmf_chip_set_passive(&ci->pub);\r\nif (ci->ops->reset) {\r\nci->ops->reset(ci->ctx, &ci->pub);\r\nbrcmf_chip_set_passive(&ci->pub);\r\n}\r\nreturn brcmf_chip_get_raminfo(ci);\r\n}\r\nstatic void brcmf_chip_disable_arm(struct brcmf_chip_priv *chip, u16 id)\r\n{\r\nstruct brcmf_core *core;\r\nstruct brcmf_core_priv *cpu;\r\nu32 val;\r\ncore = brcmf_chip_get_core(&chip->pub, id);\r\nif (!core)\r\nreturn;\r\nswitch (id) {\r\ncase BCMA_CORE_ARM_CM3:\r\nbrcmf_chip_coredisable(core, 0, 0);\r\nbreak;\r\ncase BCMA_CORE_ARM_CR4:\r\ncase BCMA_CORE_ARM_CA7:\r\ncpu = container_of(core, struct brcmf_core_priv, pub);\r\nval = chip->ops->read32(chip->ctx, cpu->wrapbase + BCMA_IOCTL);\r\nval &= ARMCR4_BCMA_IOCTL_CPUHALT;\r\nbrcmf_chip_resetcore(core, val, ARMCR4_BCMA_IOCTL_CPUHALT,\r\nARMCR4_BCMA_IOCTL_CPUHALT);\r\nbreak;\r\ndefault:\r\nbrcmf_err("unknown id: %u\n", id);\r\nbreak;\r\n}\r\n}\r\nstatic int brcmf_chip_setup(struct brcmf_chip_priv *chip)\r\n{\r\nstruct brcmf_chip *pub;\r\nstruct brcmf_core_priv *cc;\r\nstruct brcmf_core *pmu;\r\nu32 base;\r\nu32 val;\r\nint ret = 0;\r\npub = &chip->pub;\r\ncc = list_first_entry(&chip->cores, struct brcmf_core_priv, list);\r\nbase = cc->pub.base;\r\npub->cc_caps = chip->ops->read32(chip->ctx,\r\nCORE_CC_REG(base, capabilities));\r\npub->cc_caps_ext = chip->ops->read32(chip->ctx,\r\nCORE_CC_REG(base,\r\ncapabilities_ext));\r\npmu = brcmf_chip_get_pmu(pub);\r\nif (pub->cc_caps & CC_CAP_PMU) {\r\nval = chip->ops->read32(chip->ctx,\r\nCORE_CC_REG(pmu->base, pmucapabilities));\r\npub->pmurev = val & PCAP_REV_MASK;\r\npub->pmucaps = val;\r\n}\r\nbrcmf_dbg(INFO, "ccrev=%d, pmurev=%d, pmucaps=0x%x\n",\r\ncc->pub.rev, pub->pmurev, pub->pmucaps);\r\nif (chip->ops->setup)\r\nret = chip->ops->setup(chip->ctx, pub);\r\nreturn ret;\r\n}\r\nstruct brcmf_chip *brcmf_chip_attach(void *ctx,\r\nconst struct brcmf_buscore_ops *ops)\r\n{\r\nstruct brcmf_chip_priv *chip;\r\nint err = 0;\r\nif (WARN_ON(!ops->read32))\r\nerr = -EINVAL;\r\nif (WARN_ON(!ops->write32))\r\nerr = -EINVAL;\r\nif (WARN_ON(!ops->prepare))\r\nerr = -EINVAL;\r\nif (WARN_ON(!ops->activate))\r\nerr = -EINVAL;\r\nif (err < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&chip->cores);\r\nchip->num_cores = 0;\r\nchip->ops = ops;\r\nchip->ctx = ctx;\r\nerr = ops->prepare(ctx);\r\nif (err < 0)\r\ngoto fail;\r\nerr = brcmf_chip_recognition(chip);\r\nif (err < 0)\r\ngoto fail;\r\nerr = brcmf_chip_setup(chip);\r\nif (err < 0)\r\ngoto fail;\r\nreturn &chip->pub;\r\nfail:\r\nbrcmf_chip_detach(&chip->pub);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid brcmf_chip_detach(struct brcmf_chip *pub)\r\n{\r\nstruct brcmf_chip_priv *chip;\r\nstruct brcmf_core_priv *core;\r\nstruct brcmf_core_priv *tmp;\r\nchip = container_of(pub, struct brcmf_chip_priv, pub);\r\nlist_for_each_entry_safe(core, tmp, &chip->cores, list) {\r\nlist_del(&core->list);\r\nkfree(core);\r\n}\r\nkfree(chip);\r\n}\r\nstruct brcmf_core *brcmf_chip_get_core(struct brcmf_chip *pub, u16 coreid)\r\n{\r\nstruct brcmf_chip_priv *chip;\r\nstruct brcmf_core_priv *core;\r\nchip = container_of(pub, struct brcmf_chip_priv, pub);\r\nlist_for_each_entry(core, &chip->cores, list)\r\nif (core->pub.id == coreid)\r\nreturn &core->pub;\r\nreturn NULL;\r\n}\r\nstruct brcmf_core *brcmf_chip_get_chipcommon(struct brcmf_chip *pub)\r\n{\r\nstruct brcmf_chip_priv *chip;\r\nstruct brcmf_core_priv *cc;\r\nchip = container_of(pub, struct brcmf_chip_priv, pub);\r\ncc = list_first_entry(&chip->cores, struct brcmf_core_priv, list);\r\nif (WARN_ON(!cc || cc->pub.id != BCMA_CORE_CHIPCOMMON))\r\nreturn brcmf_chip_get_core(pub, BCMA_CORE_CHIPCOMMON);\r\nreturn &cc->pub;\r\n}\r\nstruct brcmf_core *brcmf_chip_get_pmu(struct brcmf_chip *pub)\r\n{\r\nstruct brcmf_core *cc = brcmf_chip_get_chipcommon(pub);\r\nstruct brcmf_core *pmu;\r\nif (cc->rev >= 35 &&\r\npub->cc_caps_ext & BCMA_CC_CAP_EXT_AOB_PRESENT) {\r\npmu = brcmf_chip_get_core(pub, BCMA_CORE_PMU);\r\nif (pmu)\r\nreturn pmu;\r\n}\r\nreturn cc;\r\n}\r\nbool brcmf_chip_iscoreup(struct brcmf_core *pub)\r\n{\r\nstruct brcmf_core_priv *core;\r\ncore = container_of(pub, struct brcmf_core_priv, pub);\r\nreturn core->chip->iscoreup(core);\r\n}\r\nvoid brcmf_chip_coredisable(struct brcmf_core *pub, u32 prereset, u32 reset)\r\n{\r\nstruct brcmf_core_priv *core;\r\ncore = container_of(pub, struct brcmf_core_priv, pub);\r\ncore->chip->coredisable(core, prereset, reset);\r\n}\r\nvoid brcmf_chip_resetcore(struct brcmf_core *pub, u32 prereset, u32 reset,\r\nu32 postreset)\r\n{\r\nstruct brcmf_core_priv *core;\r\ncore = container_of(pub, struct brcmf_core_priv, pub);\r\ncore->chip->resetcore(core, prereset, reset, postreset);\r\n}\r\nstatic void\r\nbrcmf_chip_cm3_set_passive(struct brcmf_chip_priv *chip)\r\n{\r\nstruct brcmf_core *core;\r\nstruct brcmf_core_priv *sr;\r\nbrcmf_chip_disable_arm(chip, BCMA_CORE_ARM_CM3);\r\ncore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_80211);\r\nbrcmf_chip_resetcore(core, D11_BCMA_IOCTL_PHYRESET |\r\nD11_BCMA_IOCTL_PHYCLOCKEN,\r\nD11_BCMA_IOCTL_PHYCLOCKEN,\r\nD11_BCMA_IOCTL_PHYCLOCKEN);\r\ncore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_INTERNAL_MEM);\r\nbrcmf_chip_resetcore(core, 0, 0, 0);\r\nif (chip->pub.chip == BRCM_CC_43430_CHIP_ID) {\r\nsr = container_of(core, struct brcmf_core_priv, pub);\r\nbrcmf_chip_core_write32(sr, SOCRAMREGOFFS(bankidx), 3);\r\nbrcmf_chip_core_write32(sr, SOCRAMREGOFFS(bankpda), 0);\r\n}\r\n}\r\nstatic bool brcmf_chip_cm3_set_active(struct brcmf_chip_priv *chip)\r\n{\r\nstruct brcmf_core *core;\r\ncore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_INTERNAL_MEM);\r\nif (!brcmf_chip_iscoreup(core)) {\r\nbrcmf_err("SOCRAM core is down after reset?\n");\r\nreturn false;\r\n}\r\nchip->ops->activate(chip->ctx, &chip->pub, 0);\r\ncore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CM3);\r\nbrcmf_chip_resetcore(core, 0, 0, 0);\r\nreturn true;\r\n}\r\nstatic inline void\r\nbrcmf_chip_cr4_set_passive(struct brcmf_chip_priv *chip)\r\n{\r\nstruct brcmf_core *core;\r\nbrcmf_chip_disable_arm(chip, BCMA_CORE_ARM_CR4);\r\ncore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_80211);\r\nbrcmf_chip_resetcore(core, D11_BCMA_IOCTL_PHYRESET |\r\nD11_BCMA_IOCTL_PHYCLOCKEN,\r\nD11_BCMA_IOCTL_PHYCLOCKEN,\r\nD11_BCMA_IOCTL_PHYCLOCKEN);\r\n}\r\nstatic bool brcmf_chip_cr4_set_active(struct brcmf_chip_priv *chip, u32 rstvec)\r\n{\r\nstruct brcmf_core *core;\r\nchip->ops->activate(chip->ctx, &chip->pub, rstvec);\r\ncore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CR4);\r\nbrcmf_chip_resetcore(core, ARMCR4_BCMA_IOCTL_CPUHALT, 0, 0);\r\nreturn true;\r\n}\r\nstatic inline void\r\nbrcmf_chip_ca7_set_passive(struct brcmf_chip_priv *chip)\r\n{\r\nstruct brcmf_core *core;\r\nbrcmf_chip_disable_arm(chip, BCMA_CORE_ARM_CA7);\r\ncore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_80211);\r\nbrcmf_chip_resetcore(core, D11_BCMA_IOCTL_PHYRESET |\r\nD11_BCMA_IOCTL_PHYCLOCKEN,\r\nD11_BCMA_IOCTL_PHYCLOCKEN,\r\nD11_BCMA_IOCTL_PHYCLOCKEN);\r\n}\r\nstatic bool brcmf_chip_ca7_set_active(struct brcmf_chip_priv *chip, u32 rstvec)\r\n{\r\nstruct brcmf_core *core;\r\nchip->ops->activate(chip->ctx, &chip->pub, rstvec);\r\ncore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CA7);\r\nbrcmf_chip_resetcore(core, ARMCR4_BCMA_IOCTL_CPUHALT, 0, 0);\r\nreturn true;\r\n}\r\nvoid brcmf_chip_set_passive(struct brcmf_chip *pub)\r\n{\r\nstruct brcmf_chip_priv *chip;\r\nstruct brcmf_core *arm;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nchip = container_of(pub, struct brcmf_chip_priv, pub);\r\narm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CR4);\r\nif (arm) {\r\nbrcmf_chip_cr4_set_passive(chip);\r\nreturn;\r\n}\r\narm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CA7);\r\nif (arm) {\r\nbrcmf_chip_ca7_set_passive(chip);\r\nreturn;\r\n}\r\narm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CM3);\r\nif (arm) {\r\nbrcmf_chip_cm3_set_passive(chip);\r\nreturn;\r\n}\r\n}\r\nbool brcmf_chip_set_active(struct brcmf_chip *pub, u32 rstvec)\r\n{\r\nstruct brcmf_chip_priv *chip;\r\nstruct brcmf_core *arm;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nchip = container_of(pub, struct brcmf_chip_priv, pub);\r\narm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CR4);\r\nif (arm)\r\nreturn brcmf_chip_cr4_set_active(chip, rstvec);\r\narm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CA7);\r\nif (arm)\r\nreturn brcmf_chip_ca7_set_active(chip, rstvec);\r\narm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CM3);\r\nif (arm)\r\nreturn brcmf_chip_cm3_set_active(chip);\r\nreturn false;\r\n}\r\nbool brcmf_chip_sr_capable(struct brcmf_chip *pub)\r\n{\r\nu32 base, addr, reg, pmu_cc3_mask = ~0;\r\nstruct brcmf_chip_priv *chip;\r\nstruct brcmf_core *pmu = brcmf_chip_get_pmu(pub);\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (pub->pmurev < 17)\r\nreturn false;\r\nbase = brcmf_chip_get_chipcommon(pub)->base;\r\nchip = container_of(pub, struct brcmf_chip_priv, pub);\r\nswitch (pub->chip) {\r\ncase BRCM_CC_4354_CHIP_ID:\r\ncase BRCM_CC_4356_CHIP_ID:\r\npmu_cc3_mask = BIT(2);\r\ncase BRCM_CC_43241_CHIP_ID:\r\ncase BRCM_CC_4335_CHIP_ID:\r\ncase BRCM_CC_4339_CHIP_ID:\r\naddr = CORE_CC_REG(pmu->base, chipcontrol_addr);\r\nchip->ops->write32(chip->ctx, addr, 3);\r\naddr = CORE_CC_REG(pmu->base, chipcontrol_data);\r\nreg = chip->ops->read32(chip->ctx, addr);\r\nreturn (reg & pmu_cc3_mask) != 0;\r\ncase BRCM_CC_43430_CHIP_ID:\r\naddr = CORE_CC_REG(base, sr_control1);\r\nreg = chip->ops->read32(chip->ctx, addr);\r\nreturn reg != 0;\r\ndefault:\r\naddr = CORE_CC_REG(pmu->base, pmucapabilities_ext);\r\nreg = chip->ops->read32(chip->ctx, addr);\r\nif ((reg & PCAPEXT_SR_SUPPORTED_MASK) == 0)\r\nreturn false;\r\naddr = CORE_CC_REG(pmu->base, retention_ctl);\r\nreg = chip->ops->read32(chip->ctx, addr);\r\nreturn (reg & (PMU_RCTL_MACPHY_DISABLE_MASK |\r\nPMU_RCTL_LOGIC_DISABLE_MASK)) == 0;\r\n}\r\n}
