static void mxser_enable_must_enchance_mode(unsigned long baseio)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr |= MOXA_MUST_EFR_EFRB_ENABLE;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_disable_must_enchance_mode(unsigned long baseio)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_EFRB_ENABLE;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_set_must_xon1_value(unsigned long baseio, u8 value)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_BANK_MASK;\r\nefr |= MOXA_MUST_EFR_BANK0;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(value, baseio + MOXA_MUST_XON1_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_set_must_xoff1_value(unsigned long baseio, u8 value)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_BANK_MASK;\r\nefr |= MOXA_MUST_EFR_BANK0;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(value, baseio + MOXA_MUST_XOFF1_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_set_must_fifo_value(struct mxser_port *info)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(info->ioaddr + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, info->ioaddr + UART_LCR);\r\nefr = inb(info->ioaddr + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_BANK_MASK;\r\nefr |= MOXA_MUST_EFR_BANK1;\r\noutb(efr, info->ioaddr + MOXA_MUST_EFR_REGISTER);\r\noutb((u8)info->rx_high_water, info->ioaddr + MOXA_MUST_RBRTH_REGISTER);\r\noutb((u8)info->rx_trigger, info->ioaddr + MOXA_MUST_RBRTI_REGISTER);\r\noutb((u8)info->rx_low_water, info->ioaddr + MOXA_MUST_RBRTL_REGISTER);\r\noutb(oldlcr, info->ioaddr + UART_LCR);\r\n}\r\nstatic void mxser_set_must_enum_value(unsigned long baseio, u8 value)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_BANK_MASK;\r\nefr |= MOXA_MUST_EFR_BANK2;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(value, baseio + MOXA_MUST_ENUM_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_get_must_hardware_id(unsigned long baseio, u8 *pId)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_BANK_MASK;\r\nefr |= MOXA_MUST_EFR_BANK2;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\n*pId = inb(baseio + MOXA_MUST_HWID_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void SET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(unsigned long baseio)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_SF_MASK;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_enable_must_tx_software_flow_control(unsigned long baseio)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_SF_TX_MASK;\r\nefr |= MOXA_MUST_EFR_SF_TX1;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_disable_must_tx_software_flow_control(unsigned long baseio)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_SF_TX_MASK;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_enable_must_rx_software_flow_control(unsigned long baseio)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_SF_RX_MASK;\r\nefr |= MOXA_MUST_EFR_SF_RX1;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic void mxser_disable_must_rx_software_flow_control(unsigned long baseio)\r\n{\r\nu8 oldlcr;\r\nu8 efr;\r\noldlcr = inb(baseio + UART_LCR);\r\noutb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);\r\nefr = inb(baseio + MOXA_MUST_EFR_REGISTER);\r\nefr &= ~MOXA_MUST_EFR_SF_RX_MASK;\r\noutb(efr, baseio + MOXA_MUST_EFR_REGISTER);\r\noutb(oldlcr, baseio + UART_LCR);\r\n}\r\nstatic int CheckIsMoxaMust(unsigned long io)\r\n{\r\nu8 oldmcr, hwid;\r\nint i;\r\noutb(0, io + UART_LCR);\r\nmxser_disable_must_enchance_mode(io);\r\noldmcr = inb(io + UART_MCR);\r\noutb(0, io + UART_MCR);\r\nmxser_set_must_xon1_value(io, 0x11);\r\nif ((hwid = inb(io + UART_MCR)) != 0) {\r\noutb(oldmcr, io + UART_MCR);\r\nreturn MOXA_OTHER_UART;\r\n}\r\nmxser_get_must_hardware_id(io, &hwid);\r\nfor (i = 1; i < UART_INFO_NUM; i++) {\r\nif (hwid == Gpci_uart_info[i].type)\r\nreturn (int)hwid;\r\n}\r\nreturn MOXA_OTHER_UART;\r\n}\r\nstatic void process_txrx_fifo(struct mxser_port *info)\r\n{\r\nint i;\r\nif ((info->type == PORT_16450) || (info->type == PORT_8250)) {\r\ninfo->rx_trigger = 1;\r\ninfo->rx_high_water = 1;\r\ninfo->rx_low_water = 1;\r\ninfo->xmit_fifo_size = 1;\r\n} else\r\nfor (i = 0; i < UART_INFO_NUM; i++)\r\nif (info->board->chip_flag == Gpci_uart_info[i].type) {\r\ninfo->rx_trigger = Gpci_uart_info[i].rx_trigger;\r\ninfo->rx_low_water = Gpci_uart_info[i].rx_low_water;\r\ninfo->rx_high_water = Gpci_uart_info[i].rx_high_water;\r\ninfo->xmit_fifo_size = Gpci_uart_info[i].xmit_fifo_size;\r\nbreak;\r\n}\r\n}\r\nstatic unsigned char mxser_get_msr(int baseaddr, int mode, int port)\r\n{\r\nstatic unsigned char mxser_msr[MXSER_PORTS + 1];\r\nunsigned char status = 0;\r\nstatus = inb(baseaddr + UART_MSR);\r\nmxser_msr[port] &= 0x0F;\r\nmxser_msr[port] |= status;\r\nstatus = mxser_msr[port];\r\nif (mode)\r\nmxser_msr[port] = 0;\r\nreturn status;\r\n}\r\nstatic int mxser_carrier_raised(struct tty_port *port)\r\n{\r\nstruct mxser_port *mp = container_of(port, struct mxser_port, port);\r\nreturn (inb(mp->ioaddr + UART_MSR) & UART_MSR_DCD)?1:0;\r\n}\r\nstatic void mxser_dtr_rts(struct tty_port *port, int on)\r\n{\r\nstruct mxser_port *mp = container_of(port, struct mxser_port, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&mp->slock, flags);\r\nif (on)\r\noutb(inb(mp->ioaddr + UART_MCR) |\r\nUART_MCR_DTR | UART_MCR_RTS, mp->ioaddr + UART_MCR);\r\nelse\r\noutb(inb(mp->ioaddr + UART_MCR)&~(UART_MCR_DTR | UART_MCR_RTS),\r\nmp->ioaddr + UART_MCR);\r\nspin_unlock_irqrestore(&mp->slock, flags);\r\n}\r\nstatic int mxser_set_baud(struct tty_struct *tty, long newspd)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nint quot = 0, baud;\r\nunsigned char cval;\r\nif (!info->ioaddr)\r\nreturn -1;\r\nif (newspd > info->max_baud)\r\nreturn -1;\r\nif (newspd == 134) {\r\nquot = 2 * info->baud_base / 269;\r\ntty_encode_baud_rate(tty, 134, 134);\r\n} else if (newspd) {\r\nquot = info->baud_base / newspd;\r\nif (quot == 0)\r\nquot = 1;\r\nbaud = info->baud_base/quot;\r\ntty_encode_baud_rate(tty, baud, baud);\r\n} else {\r\nquot = 0;\r\n}\r\ninfo->timeout = ((info->xmit_fifo_size * HZ * 10 * quot) / info->baud_base);\r\ninfo->timeout += HZ / 50;\r\nif (quot) {\r\ninfo->MCR |= UART_MCR_DTR;\r\noutb(info->MCR, info->ioaddr + UART_MCR);\r\n} else {\r\ninfo->MCR &= ~UART_MCR_DTR;\r\noutb(info->MCR, info->ioaddr + UART_MCR);\r\nreturn 0;\r\n}\r\ncval = inb(info->ioaddr + UART_LCR);\r\noutb(cval | UART_LCR_DLAB, info->ioaddr + UART_LCR);\r\noutb(quot & 0xff, info->ioaddr + UART_DLL);\r\noutb(quot >> 8, info->ioaddr + UART_DLM);\r\noutb(cval, info->ioaddr + UART_LCR);\r\n#ifdef BOTHER\r\nif (C_BAUD(tty) == BOTHER) {\r\nquot = info->baud_base % newspd;\r\nquot *= 8;\r\nif (quot % newspd > newspd / 2) {\r\nquot /= newspd;\r\nquot++;\r\n} else\r\nquot /= newspd;\r\nmxser_set_must_enum_value(info->ioaddr, quot);\r\n} else\r\n#endif\r\nmxser_set_must_enum_value(info->ioaddr, 0);\r\nreturn 0;\r\n}\r\nstatic int mxser_change_speed(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned cflag, cval, fcr;\r\nint ret = 0;\r\nunsigned char status;\r\ncflag = tty->termios.c_cflag;\r\nif (!info->ioaddr)\r\nreturn ret;\r\nif (mxser_set_baud_method[tty->index] == 0)\r\nmxser_set_baud(tty, tty_get_baud_rate(tty));\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\ncval = 0x00;\r\nbreak;\r\ncase CS6:\r\ncval = 0x01;\r\nbreak;\r\ncase CS7:\r\ncval = 0x02;\r\nbreak;\r\ncase CS8:\r\ncval = 0x03;\r\nbreak;\r\ndefault:\r\ncval = 0x00;\r\nbreak;\r\n}\r\nif (cflag & CSTOPB)\r\ncval |= 0x04;\r\nif (cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nif (cflag & CMSPAR)\r\ncval |= UART_LCR_SPAR;\r\nif ((info->type == PORT_8250) || (info->type == PORT_16450)) {\r\nif (info->board->chip_flag) {\r\nfcr = UART_FCR_ENABLE_FIFO;\r\nfcr |= MOXA_MUST_FCR_GDA_MODE_ENABLE;\r\nmxser_set_must_fifo_value(info);\r\n} else\r\nfcr = 0;\r\n} else {\r\nfcr = UART_FCR_ENABLE_FIFO;\r\nif (info->board->chip_flag) {\r\nfcr |= MOXA_MUST_FCR_GDA_MODE_ENABLE;\r\nmxser_set_must_fifo_value(info);\r\n} else {\r\nswitch (info->rx_trigger) {\r\ncase 1:\r\nfcr |= UART_FCR_TRIGGER_1;\r\nbreak;\r\ncase 4:\r\nfcr |= UART_FCR_TRIGGER_4;\r\nbreak;\r\ncase 8:\r\nfcr |= UART_FCR_TRIGGER_8;\r\nbreak;\r\ndefault:\r\nfcr |= UART_FCR_TRIGGER_14;\r\nbreak;\r\n}\r\n}\r\n}\r\ninfo->IER &= ~UART_IER_MSI;\r\ninfo->MCR &= ~UART_MCR_AFE;\r\ntty_port_set_cts_flow(&info->port, cflag & CRTSCTS);\r\nif (cflag & CRTSCTS) {\r\ninfo->IER |= UART_IER_MSI;\r\nif ((info->type == PORT_16550A) || (info->board->chip_flag)) {\r\ninfo->MCR |= UART_MCR_AFE;\r\n} else {\r\nstatus = inb(info->ioaddr + UART_MSR);\r\nif (tty->hw_stopped) {\r\nif (status & UART_MSR_CTS) {\r\ntty->hw_stopped = 0;\r\nif (info->type != PORT_16550A &&\r\n!info->board->chip_flag) {\r\noutb(info->IER & ~UART_IER_THRI,\r\ninfo->ioaddr +\r\nUART_IER);\r\ninfo->IER |= UART_IER_THRI;\r\noutb(info->IER, info->ioaddr +\r\nUART_IER);\r\n}\r\ntty_wakeup(tty);\r\n}\r\n} else {\r\nif (!(status & UART_MSR_CTS)) {\r\ntty->hw_stopped = 1;\r\nif ((info->type != PORT_16550A) &&\r\n(!info->board->chip_flag)) {\r\ninfo->IER &= ~UART_IER_THRI;\r\noutb(info->IER, info->ioaddr +\r\nUART_IER);\r\n}\r\n}\r\n}\r\n}\r\n}\r\noutb(info->MCR, info->ioaddr + UART_MCR);\r\ntty_port_set_check_carrier(&info->port, ~cflag & CLOCAL);\r\nif (~cflag & CLOCAL)\r\ninfo->IER |= UART_IER_MSI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\ninfo->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (I_INPCK(tty))\r\ninfo->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (I_BRKINT(tty) || I_PARMRK(tty))\r\ninfo->read_status_mask |= UART_LSR_BI;\r\ninfo->ignore_status_mask = 0;\r\nif (I_IGNBRK(tty)) {\r\ninfo->ignore_status_mask |= UART_LSR_BI;\r\ninfo->read_status_mask |= UART_LSR_BI;\r\nif (I_IGNPAR(tty)) {\r\ninfo->ignore_status_mask |=\r\nUART_LSR_OE |\r\nUART_LSR_PE |\r\nUART_LSR_FE;\r\ninfo->read_status_mask |=\r\nUART_LSR_OE |\r\nUART_LSR_PE |\r\nUART_LSR_FE;\r\n}\r\n}\r\nif (info->board->chip_flag) {\r\nmxser_set_must_xon1_value(info->ioaddr, START_CHAR(tty));\r\nmxser_set_must_xoff1_value(info->ioaddr, STOP_CHAR(tty));\r\nif (I_IXON(tty)) {\r\nmxser_enable_must_rx_software_flow_control(\r\ninfo->ioaddr);\r\n} else {\r\nmxser_disable_must_rx_software_flow_control(\r\ninfo->ioaddr);\r\n}\r\nif (I_IXOFF(tty)) {\r\nmxser_enable_must_tx_software_flow_control(\r\ninfo->ioaddr);\r\n} else {\r\nmxser_disable_must_tx_software_flow_control(\r\ninfo->ioaddr);\r\n}\r\n}\r\noutb(fcr, info->ioaddr + UART_FCR);\r\noutb(cval, info->ioaddr + UART_LCR);\r\nreturn ret;\r\n}\r\nstatic void mxser_check_modem_status(struct tty_struct *tty,\r\nstruct mxser_port *port, int status)\r\n{\r\nif (status & UART_MSR_TERI)\r\nport->icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nport->icount.dsr++;\r\nif (status & UART_MSR_DDCD)\r\nport->icount.dcd++;\r\nif (status & UART_MSR_DCTS)\r\nport->icount.cts++;\r\nport->mon_data.modem_status = status;\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\nif (tty_port_check_carrier(&port->port) && (status & UART_MSR_DDCD)) {\r\nif (status & UART_MSR_DCD)\r\nwake_up_interruptible(&port->port.open_wait);\r\n}\r\nif (tty_port_cts_enabled(&port->port)) {\r\nif (tty->hw_stopped) {\r\nif (status & UART_MSR_CTS) {\r\ntty->hw_stopped = 0;\r\nif ((port->type != PORT_16550A) &&\r\n(!port->board->chip_flag)) {\r\noutb(port->IER & ~UART_IER_THRI,\r\nport->ioaddr + UART_IER);\r\nport->IER |= UART_IER_THRI;\r\noutb(port->IER, port->ioaddr +\r\nUART_IER);\r\n}\r\ntty_wakeup(tty);\r\n}\r\n} else {\r\nif (!(status & UART_MSR_CTS)) {\r\ntty->hw_stopped = 1;\r\nif (port->type != PORT_16550A &&\r\n!port->board->chip_flag) {\r\nport->IER &= ~UART_IER_THRI;\r\noutb(port->IER, port->ioaddr +\r\nUART_IER);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int mxser_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = container_of(port, struct mxser_port, port);\r\nunsigned long page;\r\nunsigned long flags;\r\npage = __get_free_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&info->slock, flags);\r\nif (!info->ioaddr || !info->type) {\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nfree_page(page);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nreturn 0;\r\n}\r\ninfo->port.xmit_buf = (unsigned char *) page;\r\nif (info->board->chip_flag)\r\noutb((UART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT |\r\nMOXA_MUST_FCR_GDA_MODE_ENABLE), info->ioaddr + UART_FCR);\r\nelse\r\noutb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),\r\ninfo->ioaddr + UART_FCR);\r\nif (inb(info->ioaddr + UART_LSR) == 0xff) {\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nif (capable(CAP_SYS_ADMIN)) {\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nreturn 0;\r\n} else\r\nreturn -ENODEV;\r\n}\r\n(void) inb(info->ioaddr + UART_LSR);\r\n(void) inb(info->ioaddr + UART_RX);\r\n(void) inb(info->ioaddr + UART_IIR);\r\n(void) inb(info->ioaddr + UART_MSR);\r\noutb(UART_LCR_WLEN8, info->ioaddr + UART_LCR);\r\ninfo->MCR = UART_MCR_DTR | UART_MCR_RTS;\r\noutb(info->MCR, info->ioaddr + UART_MCR);\r\ninfo->IER = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI;\r\nif (info->board->chip_flag)\r\ninfo->IER |= MOXA_MUST_IER_EGDAI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\n(void) inb(info->ioaddr + UART_LSR);\r\n(void) inb(info->ioaddr + UART_RX);\r\n(void) inb(info->ioaddr + UART_IIR);\r\n(void) inb(info->ioaddr + UART_MSR);\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\nmxser_change_speed(tty, NULL);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nreturn 0;\r\n}\r\nstatic void mxser_shutdown_port(struct tty_port *port)\r\n{\r\nstruct mxser_port *info = container_of(port, struct mxser_port, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->slock, flags);\r\nwake_up_interruptible(&info->port.delta_msr_wait);\r\nif (info->port.xmit_buf) {\r\nfree_page((unsigned long) info->port.xmit_buf);\r\ninfo->port.xmit_buf = NULL;\r\n}\r\ninfo->IER = 0;\r\noutb(0x00, info->ioaddr + UART_IER);\r\nif (info->board->chip_flag)\r\noutb(UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT |\r\nMOXA_MUST_FCR_GDA_MODE_ENABLE,\r\ninfo->ioaddr + UART_FCR);\r\nelse\r\noutb(UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,\r\ninfo->ioaddr + UART_FCR);\r\n(void) inb(info->ioaddr + UART_RX);\r\nif (info->board->chip_flag)\r\nSET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(info->ioaddr);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\nstatic int mxser_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct mxser_port *info;\r\nint line;\r\nline = tty->index;\r\nif (line == MXSER_PORTS)\r\nreturn 0;\r\ninfo = &mxser_boards[line / MXSER_PORTS_PER_BOARD].ports[line % MXSER_PORTS_PER_BOARD];\r\nif (!info->ioaddr)\r\nreturn -ENODEV;\r\ntty->driver_data = info;\r\nreturn tty_port_open(&info->port, tty, filp);\r\n}\r\nstatic void mxser_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nchar fcr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->slock, flags);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\nfcr = inb(info->ioaddr + UART_FCR);\r\noutb((fcr | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),\r\ninfo->ioaddr + UART_FCR);\r\noutb(fcr, info->ioaddr + UART_FCR);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void mxser_close_port(struct tty_port *port)\r\n{\r\nstruct mxser_port *info = container_of(port, struct mxser_port, port);\r\nunsigned long timeout;\r\ninfo->IER &= ~UART_IER_RLSI;\r\nif (info->board->chip_flag)\r\ninfo->IER &= ~MOXA_MUST_RECV_ISR;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\ntimeout = jiffies + HZ;\r\nwhile (!(inb(info->ioaddr + UART_LSR) & UART_LSR_TEMT)) {\r\nschedule_timeout_interruptible(5);\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\n}\r\n}\r\nstatic void mxser_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nstruct tty_port *port = &info->port;\r\nif (tty->index == MXSER_PORTS || info == NULL)\r\nreturn;\r\nif (tty_port_close_start(port, tty, filp) == 0)\r\nreturn;\r\ninfo->closing = 1;\r\nmutex_lock(&port->mutex);\r\nmxser_close_port(port);\r\nmxser_flush_buffer(tty);\r\nif (tty_port_initialized(port) && C_HUPCL(tty))\r\ntty_port_lower_dtr_rts(port);\r\nmxser_shutdown_port(port);\r\ntty_port_set_initialized(port, 0);\r\nmutex_unlock(&port->mutex);\r\ninfo->closing = 0;\r\ntty_port_close_end(port, tty);\r\ntty_port_tty_set(port, NULL);\r\n}\r\nstatic int mxser_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nint c, total = 0;\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long flags;\r\nif (!info->port.xmit_buf)\r\nreturn 0;\r\nwhile (1) {\r\nc = min_t(int, count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,\r\nSERIAL_XMIT_SIZE - info->xmit_head));\r\nif (c <= 0)\r\nbreak;\r\nmemcpy(info->port.xmit_buf + info->xmit_head, buf, c);\r\nspin_lock_irqsave(&info->slock, flags);\r\ninfo->xmit_head = (info->xmit_head + c) &\r\n(SERIAL_XMIT_SIZE - 1);\r\ninfo->xmit_cnt += c;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nbuf += c;\r\ncount -= c;\r\ntotal += c;\r\n}\r\nif (info->xmit_cnt && !tty->stopped) {\r\nif (!tty->hw_stopped ||\r\n(info->type == PORT_16550A) ||\r\n(info->board->chip_flag)) {\r\nspin_lock_irqsave(&info->slock, flags);\r\noutb(info->IER & ~UART_IER_THRI, info->ioaddr +\r\nUART_IER);\r\ninfo->IER |= UART_IER_THRI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\n}\r\nreturn total;\r\n}\r\nstatic int mxser_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long flags;\r\nif (!info->port.xmit_buf)\r\nreturn 0;\r\nif (info->xmit_cnt >= SERIAL_XMIT_SIZE - 1)\r\nreturn 0;\r\nspin_lock_irqsave(&info->slock, flags);\r\ninfo->port.xmit_buf[info->xmit_head++] = ch;\r\ninfo->xmit_head &= SERIAL_XMIT_SIZE - 1;\r\ninfo->xmit_cnt++;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nif (!tty->stopped) {\r\nif (!tty->hw_stopped ||\r\n(info->type == PORT_16550A) ||\r\ninfo->board->chip_flag) {\r\nspin_lock_irqsave(&info->slock, flags);\r\noutb(info->IER & ~UART_IER_THRI, info->ioaddr + UART_IER);\r\ninfo->IER |= UART_IER_THRI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void mxser_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long flags;\r\nif (info->xmit_cnt <= 0 || tty->stopped || !info->port.xmit_buf ||\r\n(tty->hw_stopped && info->type != PORT_16550A &&\r\n!info->board->chip_flag))\r\nreturn;\r\nspin_lock_irqsave(&info->slock, flags);\r\noutb(info->IER & ~UART_IER_THRI, info->ioaddr + UART_IER);\r\ninfo->IER |= UART_IER_THRI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\nstatic int mxser_write_room(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nint ret;\r\nret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;\r\nreturn ret < 0 ? 0 : ret;\r\n}\r\nstatic int mxser_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nreturn info->xmit_cnt;\r\n}\r\nstatic int mxser_get_serial_info(struct tty_struct *tty,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nstruct serial_struct tmp = {\r\n.type = info->type,\r\n.line = tty->index,\r\n.port = info->ioaddr,\r\n.irq = info->board->irq,\r\n.flags = info->port.flags,\r\n.baud_base = info->baud_base,\r\n.close_delay = info->port.close_delay,\r\n.closing_wait = info->port.closing_wait,\r\n.custom_divisor = info->custom_divisor,\r\n};\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int mxser_set_serial_info(struct tty_struct *tty,\r\nstruct serial_struct __user *new_info)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nstruct tty_port *port = &info->port;\r\nstruct serial_struct new_serial;\r\nspeed_t baud;\r\nunsigned long sl_flags;\r\nunsigned int flags;\r\nint retval = 0;\r\nif (!new_info || !info->ioaddr)\r\nreturn -ENODEV;\r\nif (copy_from_user(&new_serial, new_info, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nif (new_serial.irq != info->board->irq ||\r\nnew_serial.port != info->ioaddr)\r\nreturn -EINVAL;\r\nflags = port->flags & ASYNC_SPD_MASK;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif ((new_serial.baud_base != info->baud_base) ||\r\n(new_serial.close_delay != info->port.close_delay) ||\r\n((new_serial.flags & ~ASYNC_USR_MASK) != (info->port.flags & ~ASYNC_USR_MASK)))\r\nreturn -EPERM;\r\ninfo->port.flags = ((info->port.flags & ~ASYNC_USR_MASK) |\r\n(new_serial.flags & ASYNC_USR_MASK));\r\n} else {\r\nport->flags = ((port->flags & ~ASYNC_FLAGS) |\r\n(new_serial.flags & ASYNC_FLAGS));\r\nport->close_delay = new_serial.close_delay * HZ / 100;\r\nport->closing_wait = new_serial.closing_wait * HZ / 100;\r\nport->low_latency = (port->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nif ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST &&\r\n(new_serial.baud_base != info->baud_base ||\r\nnew_serial.custom_divisor !=\r\ninfo->custom_divisor)) {\r\nif (new_serial.custom_divisor == 0)\r\nreturn -EINVAL;\r\nbaud = new_serial.baud_base / new_serial.custom_divisor;\r\ntty_encode_baud_rate(tty, baud, baud);\r\n}\r\n}\r\ninfo->type = new_serial.type;\r\nprocess_txrx_fifo(info);\r\nif (tty_port_initialized(port)) {\r\nif (flags != (port->flags & ASYNC_SPD_MASK)) {\r\nspin_lock_irqsave(&info->slock, sl_flags);\r\nmxser_change_speed(tty, NULL);\r\nspin_unlock_irqrestore(&info->slock, sl_flags);\r\n}\r\n} else {\r\nretval = mxser_activate(port, tty);\r\nif (retval == 0)\r\ntty_port_set_initialized(port, 1);\r\n}\r\nreturn retval;\r\n}\r\nstatic int mxser_get_lsr_info(struct mxser_port *info,\r\nunsigned int __user *value)\r\n{\r\nunsigned char status;\r\nunsigned int result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->slock, flags);\r\nstatus = inb(info->ioaddr + UART_LSR);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nresult = ((status & UART_LSR_TEMT) ? TIOCSER_TEMT : 0);\r\nreturn put_user(result, value);\r\n}\r\nstatic int mxser_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned char control, status;\r\nunsigned long flags;\r\nif (tty->index == MXSER_PORTS)\r\nreturn -ENOIOCTLCMD;\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\ncontrol = info->MCR;\r\nspin_lock_irqsave(&info->slock, flags);\r\nstatus = inb(info->ioaddr + UART_MSR);\r\nif (status & UART_MSR_ANY_DELTA)\r\nmxser_check_modem_status(tty, info, status);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nreturn ((control & UART_MCR_RTS) ? TIOCM_RTS : 0) |\r\n((control & UART_MCR_DTR) ? TIOCM_DTR : 0) |\r\n((status & UART_MSR_DCD) ? TIOCM_CAR : 0) |\r\n((status & UART_MSR_RI) ? TIOCM_RNG : 0) |\r\n((status & UART_MSR_DSR) ? TIOCM_DSR : 0) |\r\n((status & UART_MSR_CTS) ? TIOCM_CTS : 0);\r\n}\r\nstatic int mxser_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long flags;\r\nif (tty->index == MXSER_PORTS)\r\nreturn -ENOIOCTLCMD;\r\nif (tty_io_error(tty))\r\nreturn -EIO;\r\nspin_lock_irqsave(&info->slock, flags);\r\nif (set & TIOCM_RTS)\r\ninfo->MCR |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->MCR |= UART_MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->MCR &= ~UART_MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->MCR &= ~UART_MCR_DTR;\r\noutb(info->MCR, info->ioaddr + UART_MCR);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init mxser_program_mode(int port)\r\n{\r\nint id, i, j, n;\r\noutb(0, port);\r\noutb(0, port);\r\noutb(0, port);\r\n(void)inb(port);\r\n(void)inb(port);\r\noutb(0, port);\r\n(void)inb(port);\r\nid = inb(port + 1) & 0x1F;\r\nif ((id != C168_ASIC_ID) &&\r\n(id != C104_ASIC_ID) &&\r\n(id != C102_ASIC_ID) &&\r\n(id != CI132_ASIC_ID) &&\r\n(id != CI134_ASIC_ID) &&\r\n(id != CI104J_ASIC_ID))\r\nreturn -1;\r\nfor (i = 0, j = 0; i < 4; i++) {\r\nn = inb(port + 2);\r\nif (n == 'M') {\r\nj = 1;\r\n} else if ((j == 1) && (n == 1)) {\r\nj = 2;\r\nbreak;\r\n} else\r\nj = 0;\r\n}\r\nif (j != 2)\r\nid = -2;\r\nreturn id;\r\n}\r\nstatic void __init mxser_normal_mode(int port)\r\n{\r\nint i, n;\r\noutb(0xA5, port + 1);\r\noutb(0x80, port + 3);\r\noutb(12, port + 0);\r\noutb(0, port + 1);\r\noutb(0x03, port + 3);\r\noutb(0x13, port + 4);\r\nfor (i = 0; i < 16; i++) {\r\nn = inb(port + 5);\r\nif ((n & 0x61) == 0x60)\r\nbreak;\r\nif ((n & 1) == 1)\r\n(void)inb(port);\r\n}\r\noutb(0x00, port + 4);\r\n}\r\nstatic int __init mxser_read_register(int port, unsigned short *regs)\r\n{\r\nint i, k, value, id;\r\nunsigned int j;\r\nid = mxser_program_mode(port);\r\nif (id < 0)\r\nreturn id;\r\nfor (i = 0; i < 14; i++) {\r\nk = (i & 0x3F) | 0x180;\r\nfor (j = 0x100; j > 0; j >>= 1) {\r\noutb(CHIP_CS, port);\r\nif (k & j) {\r\noutb(CHIP_CS | CHIP_DO, port);\r\noutb(CHIP_CS | CHIP_DO | CHIP_SK, port);\r\n} else {\r\noutb(CHIP_CS, port);\r\noutb(CHIP_CS | CHIP_SK, port);\r\n}\r\n}\r\n(void)inb(port);\r\nvalue = 0;\r\nfor (k = 0, j = 0x8000; k < 16; k++, j >>= 1) {\r\noutb(CHIP_CS, port);\r\noutb(CHIP_CS | CHIP_SK, port);\r\nif (inb(port) & CHIP_DI)\r\nvalue |= j;\r\n}\r\nregs[i] = value;\r\noutb(0, port);\r\n}\r\nmxser_normal_mode(port);\r\nreturn id;\r\n}\r\nstatic int mxser_ioctl_special(unsigned int cmd, void __user *argp)\r\n{\r\nstruct mxser_port *ip;\r\nstruct tty_port *port;\r\nstruct tty_struct *tty;\r\nint result, status;\r\nunsigned int i, j;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase MOXA_GET_MAJOR:\r\nprintk_ratelimited(KERN_WARNING "mxser: '%s' uses deprecated ioctl "\r\n"%x (GET_MAJOR), fix your userspace\n",\r\ncurrent->comm, cmd);\r\nreturn put_user(ttymajor, (int __user *)argp);\r\ncase MOXA_CHKPORTENABLE:\r\nresult = 0;\r\nfor (i = 0; i < MXSER_BOARDS; i++)\r\nfor (j = 0; j < MXSER_PORTS_PER_BOARD; j++)\r\nif (mxser_boards[i].ports[j].ioaddr)\r\nresult |= (1 << i);\r\nreturn put_user(result, (unsigned long __user *)argp);\r\ncase MOXA_GETDATACOUNT:\r\nif (copy_to_user(argp, &mxvar_log, sizeof(mxvar_log)))\r\nret = -EFAULT;\r\nreturn ret;\r\ncase MOXA_GETMSTATUS: {\r\nstruct mxser_mstatus ms, __user *msu = argp;\r\nfor (i = 0; i < MXSER_BOARDS; i++)\r\nfor (j = 0; j < MXSER_PORTS_PER_BOARD; j++) {\r\nip = &mxser_boards[i].ports[j];\r\nport = &ip->port;\r\nmemset(&ms, 0, sizeof(ms));\r\nmutex_lock(&port->mutex);\r\nif (!ip->ioaddr)\r\ngoto copy;\r\ntty = tty_port_tty_get(port);\r\nif (!tty)\r\nms.cflag = ip->normal_termios.c_cflag;\r\nelse\r\nms.cflag = tty->termios.c_cflag;\r\ntty_kref_put(tty);\r\nspin_lock_irq(&ip->slock);\r\nstatus = inb(ip->ioaddr + UART_MSR);\r\nspin_unlock_irq(&ip->slock);\r\nif (status & UART_MSR_DCD)\r\nms.dcd = 1;\r\nif (status & UART_MSR_DSR)\r\nms.dsr = 1;\r\nif (status & UART_MSR_CTS)\r\nms.cts = 1;\r\ncopy:\r\nmutex_unlock(&port->mutex);\r\nif (copy_to_user(msu, &ms, sizeof(ms)))\r\nreturn -EFAULT;\r\nmsu++;\r\n}\r\nreturn 0;\r\n}\r\ncase MOXA_ASPP_MON_EXT: {\r\nstruct mxser_mon_ext *me;\r\nunsigned int cflag, iflag, p;\r\nu8 opmode;\r\nme = kzalloc(sizeof(*me), GFP_KERNEL);\r\nif (!me)\r\nreturn -ENOMEM;\r\nfor (i = 0, p = 0; i < MXSER_BOARDS; i++) {\r\nfor (j = 0; j < MXSER_PORTS_PER_BOARD; j++, p++) {\r\nif (p >= ARRAY_SIZE(me->rx_cnt)) {\r\ni = MXSER_BOARDS;\r\nbreak;\r\n}\r\nip = &mxser_boards[i].ports[j];\r\nport = &ip->port;\r\nmutex_lock(&port->mutex);\r\nif (!ip->ioaddr) {\r\nmutex_unlock(&port->mutex);\r\ncontinue;\r\n}\r\nspin_lock_irq(&ip->slock);\r\nstatus = mxser_get_msr(ip->ioaddr, 0, p);\r\nif (status & UART_MSR_TERI)\r\nip->icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nip->icount.dsr++;\r\nif (status & UART_MSR_DDCD)\r\nip->icount.dcd++;\r\nif (status & UART_MSR_DCTS)\r\nip->icount.cts++;\r\nip->mon_data.modem_status = status;\r\nme->rx_cnt[p] = ip->mon_data.rxcnt;\r\nme->tx_cnt[p] = ip->mon_data.txcnt;\r\nme->up_rxcnt[p] = ip->mon_data.up_rxcnt;\r\nme->up_txcnt[p] = ip->mon_data.up_txcnt;\r\nme->modem_status[p] =\r\nip->mon_data.modem_status;\r\nspin_unlock_irq(&ip->slock);\r\ntty = tty_port_tty_get(&ip->port);\r\nif (!tty) {\r\ncflag = ip->normal_termios.c_cflag;\r\niflag = ip->normal_termios.c_iflag;\r\nme->baudrate[p] = tty_termios_baud_rate(&ip->normal_termios);\r\n} else {\r\ncflag = tty->termios.c_cflag;\r\niflag = tty->termios.c_iflag;\r\nme->baudrate[p] = tty_get_baud_rate(tty);\r\n}\r\ntty_kref_put(tty);\r\nme->databits[p] = cflag & CSIZE;\r\nme->stopbits[p] = cflag & CSTOPB;\r\nme->parity[p] = cflag & (PARENB | PARODD |\r\nCMSPAR);\r\nif (cflag & CRTSCTS)\r\nme->flowctrl[p] |= 0x03;\r\nif (iflag & (IXON | IXOFF))\r\nme->flowctrl[p] |= 0x0C;\r\nif (ip->type == PORT_16550A)\r\nme->fifo[p] = 1;\r\nif (ip->board->chip_flag == MOXA_MUST_MU860_HWID) {\r\nopmode = inb(ip->opmode_ioaddr)>>((p % 4) * 2);\r\nopmode &= OP_MODE_MASK;\r\n} else {\r\nopmode = RS232_MODE;\r\n}\r\nme->iftype[p] = opmode;\r\nmutex_unlock(&port->mutex);\r\n}\r\n}\r\nif (copy_to_user(argp, me, sizeof(*me)))\r\nret = -EFAULT;\r\nkfree(me);\r\nreturn ret;\r\n}\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxser_cflags_changed(struct mxser_port *info, unsigned long arg,\r\nstruct async_icount *cprev)\r\n{\r\nstruct async_icount cnow;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&info->slock, flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nret = ((arg & TIOCM_RNG) && (cnow.rng != cprev->rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev->dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev->dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev->cts));\r\n*cprev = cnow;\r\nreturn ret;\r\n}\r\nstatic int mxser_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nstruct tty_port *port = &info->port;\r\nstruct async_icount cnow;\r\nunsigned long flags;\r\nvoid __user *argp = (void __user *)arg;\r\nint retval;\r\nif (tty->index == MXSER_PORTS)\r\nreturn mxser_ioctl_special(cmd, argp);\r\nif (cmd == MOXA_SET_OP_MODE || cmd == MOXA_GET_OP_MODE) {\r\nint p;\r\nunsigned long opmode;\r\nstatic unsigned char ModeMask[] = { 0xfc, 0xf3, 0xcf, 0x3f };\r\nint shiftbit;\r\nunsigned char val, mask;\r\nif (info->board->chip_flag != MOXA_MUST_MU860_HWID)\r\nreturn -EFAULT;\r\np = tty->index % 4;\r\nif (cmd == MOXA_SET_OP_MODE) {\r\nif (get_user(opmode, (int __user *) argp))\r\nreturn -EFAULT;\r\nif (opmode != RS232_MODE &&\r\nopmode != RS485_2WIRE_MODE &&\r\nopmode != RS422_MODE &&\r\nopmode != RS485_4WIRE_MODE)\r\nreturn -EFAULT;\r\nmask = ModeMask[p];\r\nshiftbit = p * 2;\r\nspin_lock_irq(&info->slock);\r\nval = inb(info->opmode_ioaddr);\r\nval &= mask;\r\nval |= (opmode << shiftbit);\r\noutb(val, info->opmode_ioaddr);\r\nspin_unlock_irq(&info->slock);\r\n} else {\r\nshiftbit = p * 2;\r\nspin_lock_irq(&info->slock);\r\nopmode = inb(info->opmode_ioaddr) >> shiftbit;\r\nspin_unlock_irq(&info->slock);\r\nopmode &= OP_MODE_MASK;\r\nif (put_user(opmode, (int __user *)argp))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nif (cmd != TIOCGSERIAL && cmd != TIOCMIWAIT && tty_io_error(tty))\r\nreturn -EIO;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmutex_lock(&port->mutex);\r\nretval = mxser_get_serial_info(tty, argp);\r\nmutex_unlock(&port->mutex);\r\nreturn retval;\r\ncase TIOCSSERIAL:\r\nmutex_lock(&port->mutex);\r\nretval = mxser_set_serial_info(tty, argp);\r\nmutex_unlock(&port->mutex);\r\nreturn retval;\r\ncase TIOCSERGETLSR:\r\nreturn mxser_get_lsr_info(info, argp);\r\ncase TIOCMIWAIT:\r\nspin_lock_irqsave(&info->slock, flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nreturn wait_event_interruptible(info->port.delta_msr_wait,\r\nmxser_cflags_changed(info, arg, &cnow));\r\ncase MOXA_HighSpeedOn:\r\nreturn put_user(info->baud_base != 115200 ? 1 : 0, (int __user *)argp);\r\ncase MOXA_SDS_RSTICOUNTER:\r\nspin_lock_irq(&info->slock);\r\ninfo->mon_data.rxcnt = 0;\r\ninfo->mon_data.txcnt = 0;\r\nspin_unlock_irq(&info->slock);\r\nreturn 0;\r\ncase MOXA_ASPP_OQUEUE:{\r\nint len, lsr;\r\nlen = mxser_chars_in_buffer(tty);\r\nspin_lock_irq(&info->slock);\r\nlsr = inb(info->ioaddr + UART_LSR) & UART_LSR_THRE;\r\nspin_unlock_irq(&info->slock);\r\nlen += (lsr ? 0 : 1);\r\nreturn put_user(len, (int __user *)argp);\r\n}\r\ncase MOXA_ASPP_MON: {\r\nint mcr, status;\r\nspin_lock_irq(&info->slock);\r\nstatus = mxser_get_msr(info->ioaddr, 1, tty->index);\r\nmxser_check_modem_status(tty, info, status);\r\nmcr = inb(info->ioaddr + UART_MCR);\r\nspin_unlock_irq(&info->slock);\r\nif (mcr & MOXA_MUST_MCR_XON_FLAG)\r\ninfo->mon_data.hold_reason &= ~NPPI_NOTIFY_XOFFHOLD;\r\nelse\r\ninfo->mon_data.hold_reason |= NPPI_NOTIFY_XOFFHOLD;\r\nif (mcr & MOXA_MUST_MCR_TX_XON)\r\ninfo->mon_data.hold_reason &= ~NPPI_NOTIFY_XOFFXENT;\r\nelse\r\ninfo->mon_data.hold_reason |= NPPI_NOTIFY_XOFFXENT;\r\nif (tty->hw_stopped)\r\ninfo->mon_data.hold_reason |= NPPI_NOTIFY_CTSHOLD;\r\nelse\r\ninfo->mon_data.hold_reason &= ~NPPI_NOTIFY_CTSHOLD;\r\nif (copy_to_user(argp, &info->mon_data,\r\nsizeof(struct mxser_mon)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase MOXA_ASPP_LSTATUS: {\r\nif (put_user(info->err_shadow, (unsigned char __user *)argp))\r\nreturn -EFAULT;\r\ninfo->err_shadow = 0;\r\nreturn 0;\r\n}\r\ncase MOXA_SET_BAUD_METHOD: {\r\nint method;\r\nif (get_user(method, (int __user *)argp))\r\nreturn -EFAULT;\r\nmxser_set_baud_method[tty->index] = method;\r\nreturn put_user(method, (int __user *)argp);\r\n}\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxser_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nstruct async_icount cnow;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->slock, flags);\r\ncnow = info->icount;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nicount->frame = cnow.frame;\r\nicount->brk = cnow.brk;\r\nicount->overrun = cnow.overrun;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nicount->parity = cnow.parity;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nreturn 0;\r\n}\r\nstatic void mxser_stoprx(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\ninfo->ldisc_stop_rx = 1;\r\nif (I_IXOFF(tty)) {\r\nif (info->board->chip_flag) {\r\ninfo->IER &= ~MOXA_MUST_RECV_ISR;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\n} else {\r\ninfo->x_char = STOP_CHAR(tty);\r\noutb(0, info->ioaddr + UART_IER);\r\ninfo->IER |= UART_IER_THRI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\n}\r\n}\r\nif (C_CRTSCTS(tty)) {\r\ninfo->MCR &= ~UART_MCR_RTS;\r\noutb(info->MCR, info->ioaddr + UART_MCR);\r\n}\r\n}\r\nstatic void mxser_throttle(struct tty_struct *tty)\r\n{\r\nmxser_stoprx(tty);\r\n}\r\nstatic void mxser_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\ninfo->ldisc_stop_rx = 0;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse {\r\nif (info->board->chip_flag) {\r\ninfo->IER |= MOXA_MUST_RECV_ISR;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\n} else {\r\ninfo->x_char = START_CHAR(tty);\r\noutb(0, info->ioaddr + UART_IER);\r\ninfo->IER |= UART_IER_THRI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\n}\r\n}\r\n}\r\nif (C_CRTSCTS(tty)) {\r\ninfo->MCR |= UART_MCR_RTS;\r\noutb(info->MCR, info->ioaddr + UART_MCR);\r\n}\r\n}\r\nstatic void mxser_stop(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->slock, flags);\r\nif (info->IER & UART_IER_THRI) {\r\ninfo->IER &= ~UART_IER_THRI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\n}\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\nstatic void mxser_start(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->slock, flags);\r\nif (info->xmit_cnt && info->port.xmit_buf) {\r\noutb(info->IER & ~UART_IER_THRI, info->ioaddr + UART_IER);\r\ninfo->IER |= UART_IER_THRI;\r\noutb(info->IER, info->ioaddr + UART_IER);\r\n}\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\nstatic void mxser_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->slock, flags);\r\nmxser_change_speed(tty, old_termios);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nif ((old_termios->c_cflag & CRTSCTS) && !C_CRTSCTS(tty)) {\r\ntty->hw_stopped = 0;\r\nmxser_start(tty);\r\n}\r\nif ((old_termios->c_iflag & IXON) && !I_IXON(tty)) {\r\ntty->stopped = 0;\r\nif (info->board->chip_flag) {\r\nspin_lock_irqsave(&info->slock, flags);\r\nmxser_disable_must_rx_software_flow_control(\r\ninfo->ioaddr);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\nmxser_start(tty);\r\n}\r\n}\r\nstatic void mxser_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long orig_jiffies, char_time;\r\nunsigned long flags;\r\nint lsr;\r\nif (info->type == PORT_UNKNOWN)\r\nreturn;\r\nif (info->xmit_fifo_size == 0)\r\nreturn;\r\norig_jiffies = jiffies;\r\nchar_time = (info->timeout - HZ / 50) / info->xmit_fifo_size;\r\nchar_time = char_time / 5;\r\nif (char_time == 0)\r\nchar_time = 1;\r\nif (timeout && timeout < char_time)\r\nchar_time = timeout;\r\nif (!timeout || timeout > 2 * info->timeout)\r\ntimeout = 2 * info->timeout;\r\nspin_lock_irqsave(&info->slock, flags);\r\nwhile (!((lsr = inb(info->ioaddr + UART_LSR)) & UART_LSR_TEMT)) {\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nschedule_timeout_interruptible(char_time);\r\nspin_lock_irqsave(&info->slock, flags);\r\nif (signal_pending(current))\r\nbreak;\r\nif (timeout && time_after(jiffies, orig_jiffies + timeout))\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nset_current_state(TASK_RUNNING);\r\n}\r\nstatic void mxser_hangup(struct tty_struct *tty)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nmxser_flush_buffer(tty);\r\ntty_port_hangup(&info->port);\r\n}\r\nstatic int mxser_rs_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct mxser_port *info = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->slock, flags);\r\nif (break_state == -1)\r\noutb(inb(info->ioaddr + UART_LCR) | UART_LCR_SBC,\r\ninfo->ioaddr + UART_LCR);\r\nelse\r\noutb(inb(info->ioaddr + UART_LCR) & ~UART_LCR_SBC,\r\ninfo->ioaddr + UART_LCR);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nreturn 0;\r\n}\r\nstatic void mxser_receive_chars(struct tty_struct *tty,\r\nstruct mxser_port *port, int *status)\r\n{\r\nunsigned char ch, gdl;\r\nint ignored = 0;\r\nint cnt = 0;\r\nint recv_room;\r\nint max = 256;\r\nrecv_room = tty->receive_room;\r\nif (recv_room == 0 && !port->ldisc_stop_rx)\r\nmxser_stoprx(tty);\r\nif (port->board->chip_flag != MOXA_OTHER_UART) {\r\nif (*status & UART_LSR_SPECIAL)\r\ngoto intr_old;\r\nif (port->board->chip_flag == MOXA_MUST_MU860_HWID &&\r\n(*status & MOXA_MUST_LSR_RERR))\r\ngoto intr_old;\r\nif (*status & MOXA_MUST_LSR_RERR)\r\ngoto intr_old;\r\ngdl = inb(port->ioaddr + MOXA_MUST_GDL_REGISTER);\r\nif (port->board->chip_flag == MOXA_MUST_MU150_HWID)\r\ngdl &= MOXA_MUST_GDL_MASK;\r\nif (gdl >= recv_room) {\r\nif (!port->ldisc_stop_rx)\r\nmxser_stoprx(tty);\r\n}\r\nwhile (gdl--) {\r\nch = inb(port->ioaddr + UART_RX);\r\ntty_insert_flip_char(&port->port, ch, 0);\r\ncnt++;\r\n}\r\ngoto end_intr;\r\n}\r\nintr_old:\r\ndo {\r\nif (max-- < 0)\r\nbreak;\r\nch = inb(port->ioaddr + UART_RX);\r\nif (port->board->chip_flag && (*status & UART_LSR_OE))\r\noutb(0x23, port->ioaddr + UART_FCR);\r\n*status &= port->read_status_mask;\r\nif (*status & port->ignore_status_mask) {\r\nif (++ignored > 100)\r\nbreak;\r\n} else {\r\nchar flag = 0;\r\nif (*status & UART_LSR_SPECIAL) {\r\nif (*status & UART_LSR_BI) {\r\nflag = TTY_BREAK;\r\nport->icount.brk++;\r\nif (port->port.flags & ASYNC_SAK)\r\ndo_SAK(tty);\r\n} else if (*status & UART_LSR_PE) {\r\nflag = TTY_PARITY;\r\nport->icount.parity++;\r\n} else if (*status & UART_LSR_FE) {\r\nflag = TTY_FRAME;\r\nport->icount.frame++;\r\n} else if (*status & UART_LSR_OE) {\r\nflag = TTY_OVERRUN;\r\nport->icount.overrun++;\r\n} else\r\nflag = TTY_BREAK;\r\n}\r\ntty_insert_flip_char(&port->port, ch, flag);\r\ncnt++;\r\nif (cnt >= recv_room) {\r\nif (!port->ldisc_stop_rx)\r\nmxser_stoprx(tty);\r\nbreak;\r\n}\r\n}\r\nif (port->board->chip_flag)\r\nbreak;\r\n*status = inb(port->ioaddr + UART_LSR);\r\n} while (*status & UART_LSR_DR);\r\nend_intr:\r\nmxvar_log.rxcnt[tty->index] += cnt;\r\nport->mon_data.rxcnt += cnt;\r\nport->mon_data.up_rxcnt += cnt;\r\nspin_unlock(&port->slock);\r\ntty_flip_buffer_push(&port->port);\r\nspin_lock(&port->slock);\r\n}\r\nstatic void mxser_transmit_chars(struct tty_struct *tty, struct mxser_port *port)\r\n{\r\nint count, cnt;\r\nif (port->x_char) {\r\noutb(port->x_char, port->ioaddr + UART_TX);\r\nport->x_char = 0;\r\nmxvar_log.txcnt[tty->index]++;\r\nport->mon_data.txcnt++;\r\nport->mon_data.up_txcnt++;\r\nport->icount.tx++;\r\nreturn;\r\n}\r\nif (port->port.xmit_buf == NULL)\r\nreturn;\r\nif (port->xmit_cnt <= 0 || tty->stopped ||\r\n(tty->hw_stopped &&\r\n(port->type != PORT_16550A) &&\r\n(!port->board->chip_flag))) {\r\nport->IER &= ~UART_IER_THRI;\r\noutb(port->IER, port->ioaddr + UART_IER);\r\nreturn;\r\n}\r\ncnt = port->xmit_cnt;\r\ncount = port->xmit_fifo_size;\r\ndo {\r\noutb(port->port.xmit_buf[port->xmit_tail++],\r\nport->ioaddr + UART_TX);\r\nport->xmit_tail = port->xmit_tail & (SERIAL_XMIT_SIZE - 1);\r\nif (--port->xmit_cnt <= 0)\r\nbreak;\r\n} while (--count > 0);\r\nmxvar_log.txcnt[tty->index] += (cnt - port->xmit_cnt);\r\nport->mon_data.txcnt += (cnt - port->xmit_cnt);\r\nport->mon_data.up_txcnt += (cnt - port->xmit_cnt);\r\nport->icount.tx += (cnt - port->xmit_cnt);\r\nif (port->xmit_cnt < WAKEUP_CHARS)\r\ntty_wakeup(tty);\r\nif (port->xmit_cnt <= 0) {\r\nport->IER &= ~UART_IER_THRI;\r\noutb(port->IER, port->ioaddr + UART_IER);\r\n}\r\n}\r\nstatic irqreturn_t mxser_interrupt(int irq, void *dev_id)\r\n{\r\nint status, iir, i;\r\nstruct mxser_board *brd = NULL;\r\nstruct mxser_port *port;\r\nint max, irqbits, bits, msr;\r\nunsigned int int_cnt, pass_counter = 0;\r\nint handled = IRQ_NONE;\r\nstruct tty_struct *tty;\r\nfor (i = 0; i < MXSER_BOARDS; i++)\r\nif (dev_id == &mxser_boards[i]) {\r\nbrd = dev_id;\r\nbreak;\r\n}\r\nif (i == MXSER_BOARDS)\r\ngoto irq_stop;\r\nif (brd == NULL)\r\ngoto irq_stop;\r\nmax = brd->info->nports;\r\nwhile (pass_counter++ < MXSER_ISR_PASS_LIMIT) {\r\nirqbits = inb(brd->vector) & brd->vector_mask;\r\nif (irqbits == brd->vector_mask)\r\nbreak;\r\nhandled = IRQ_HANDLED;\r\nfor (i = 0, bits = 1; i < max; i++, irqbits |= bits, bits <<= 1) {\r\nif (irqbits == brd->vector_mask)\r\nbreak;\r\nif (bits & irqbits)\r\ncontinue;\r\nport = &brd->ports[i];\r\nint_cnt = 0;\r\nspin_lock(&port->slock);\r\ndo {\r\niir = inb(port->ioaddr + UART_IIR);\r\nif (iir & UART_IIR_NO_INT)\r\nbreak;\r\niir &= MOXA_MUST_IIR_MASK;\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty || port->closing ||\r\n!tty_port_initialized(&port->port)) {\r\nstatus = inb(port->ioaddr + UART_LSR);\r\noutb(0x27, port->ioaddr + UART_FCR);\r\ninb(port->ioaddr + UART_MSR);\r\ntty_kref_put(tty);\r\nbreak;\r\n}\r\nstatus = inb(port->ioaddr + UART_LSR);\r\nif (status & UART_LSR_PE)\r\nport->err_shadow |= NPPI_NOTIFY_PARITY;\r\nif (status & UART_LSR_FE)\r\nport->err_shadow |= NPPI_NOTIFY_FRAMING;\r\nif (status & UART_LSR_OE)\r\nport->err_shadow |=\r\nNPPI_NOTIFY_HW_OVERRUN;\r\nif (status & UART_LSR_BI)\r\nport->err_shadow |= NPPI_NOTIFY_BREAK;\r\nif (port->board->chip_flag) {\r\nif (iir == MOXA_MUST_IIR_GDA ||\r\niir == MOXA_MUST_IIR_RDA ||\r\niir == MOXA_MUST_IIR_RTO ||\r\niir == MOXA_MUST_IIR_LSR)\r\nmxser_receive_chars(tty, port,\r\n&status);\r\n} else {\r\nstatus &= port->read_status_mask;\r\nif (status & UART_LSR_DR)\r\nmxser_receive_chars(tty, port,\r\n&status);\r\n}\r\nmsr = inb(port->ioaddr + UART_MSR);\r\nif (msr & UART_MSR_ANY_DELTA)\r\nmxser_check_modem_status(tty, port, msr);\r\nif (port->board->chip_flag) {\r\nif (iir == 0x02 && (status &\r\nUART_LSR_THRE))\r\nmxser_transmit_chars(tty, port);\r\n} else {\r\nif (status & UART_LSR_THRE)\r\nmxser_transmit_chars(tty, port);\r\n}\r\ntty_kref_put(tty);\r\n} while (int_cnt++ < MXSER_ISR_PASS_LIMIT);\r\nspin_unlock(&port->slock);\r\n}\r\n}\r\nirq_stop:\r\nreturn handled;\r\n}\r\nstatic bool mxser_overlapping_vector(struct mxser_board *brd)\r\n{\r\nreturn allow_overlapping_vector &&\r\nbrd->vector >= brd->ports[0].ioaddr &&\r\nbrd->vector < brd->ports[0].ioaddr + 8 * brd->info->nports;\r\n}\r\nstatic int mxser_request_vector(struct mxser_board *brd)\r\n{\r\nif (mxser_overlapping_vector(brd))\r\nreturn 0;\r\nreturn request_region(brd->vector, 1, "mxser(vector)") ? 0 : -EIO;\r\n}\r\nstatic void mxser_release_vector(struct mxser_board *brd)\r\n{\r\nif (mxser_overlapping_vector(brd))\r\nreturn;\r\nrelease_region(brd->vector, 1);\r\n}\r\nstatic void mxser_release_ISA_res(struct mxser_board *brd)\r\n{\r\nrelease_region(brd->ports[0].ioaddr, 8 * brd->info->nports);\r\nmxser_release_vector(brd);\r\n}\r\nstatic int mxser_initbrd(struct mxser_board *brd,\r\nstruct pci_dev *pdev)\r\n{\r\nstruct mxser_port *info;\r\nunsigned int i;\r\nint retval;\r\nprintk(KERN_INFO "mxser: max. baud rate = %d bps\n",\r\nbrd->ports[0].max_baud);\r\nfor (i = 0; i < brd->info->nports; i++) {\r\ninfo = &brd->ports[i];\r\ntty_port_init(&info->port);\r\ninfo->port.ops = &mxser_port_ops;\r\ninfo->board = brd;\r\ninfo->stop_rx = 0;\r\ninfo->ldisc_stop_rx = 0;\r\nif (brd->chip_flag != MOXA_OTHER_UART)\r\nmxser_enable_must_enchance_mode(info->ioaddr);\r\ninfo->type = brd->uart_type;\r\nprocess_txrx_fifo(info);\r\ninfo->custom_divisor = info->baud_base * 16;\r\ninfo->port.close_delay = 5 * HZ / 10;\r\ninfo->port.closing_wait = 30 * HZ;\r\ninfo->normal_termios = mxvar_sdriver->init_termios;\r\nmemset(&info->mon_data, 0, sizeof(struct mxser_mon));\r\ninfo->err_shadow = 0;\r\nspin_lock_init(&info->slock);\r\noutb(inb(info->ioaddr + UART_IER) & 0xf0,\r\ninfo->ioaddr + UART_IER);\r\n}\r\nretval = request_irq(brd->irq, mxser_interrupt, IRQF_SHARED, "mxser",\r\nbrd);\r\nif (retval) {\r\nfor (i = 0; i < brd->info->nports; i++)\r\ntty_port_destroy(&brd->ports[i].port);\r\nprintk(KERN_ERR "Board %s: Request irq failed, IRQ (%d) may "\r\n"conflict with another device.\n",\r\nbrd->info->name, brd->irq);\r\n}\r\nreturn retval;\r\n}\r\nstatic void mxser_board_remove(struct mxser_board *brd)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < brd->info->nports; i++) {\r\ntty_unregister_device(mxvar_sdriver, brd->idx + i);\r\ntty_port_destroy(&brd->ports[i].port);\r\n}\r\nfree_irq(brd->irq, brd);\r\n}\r\nstatic int __init mxser_get_ISA_conf(int cap, struct mxser_board *brd)\r\n{\r\nint id, i, bits, ret;\r\nunsigned short regs[16], irq;\r\nunsigned char scratch, scratch2;\r\nbrd->chip_flag = MOXA_OTHER_UART;\r\nid = mxser_read_register(cap, regs);\r\nswitch (id) {\r\ncase C168_ASIC_ID:\r\nbrd->info = &mxser_cards[0];\r\nbreak;\r\ncase C104_ASIC_ID:\r\nbrd->info = &mxser_cards[1];\r\nbreak;\r\ncase CI104J_ASIC_ID:\r\nbrd->info = &mxser_cards[2];\r\nbreak;\r\ncase C102_ASIC_ID:\r\nbrd->info = &mxser_cards[5];\r\nbreak;\r\ncase CI132_ASIC_ID:\r\nbrd->info = &mxser_cards[6];\r\nbreak;\r\ncase CI134_ASIC_ID:\r\nbrd->info = &mxser_cards[7];\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nirq = 0;\r\nif (brd->info->nports == 2 || (brd->info->flags & MXSER_HAS2)) {\r\nirq = regs[9] & 0xF000;\r\nirq = irq | (irq >> 4);\r\nif (irq != (regs[9] & 0xFF00))\r\ngoto err_irqconflict;\r\n} else if (brd->info->nports == 4) {\r\nirq = regs[9] & 0xF000;\r\nirq = irq | (irq >> 4);\r\nirq = irq | (irq >> 8);\r\nif (irq != regs[9])\r\ngoto err_irqconflict;\r\n} else if (brd->info->nports == 8) {\r\nirq = regs[9] & 0xF000;\r\nirq = irq | (irq >> 4);\r\nirq = irq | (irq >> 8);\r\nif ((irq != regs[9]) || (irq != regs[10]))\r\ngoto err_irqconflict;\r\n}\r\nif (!irq) {\r\nprintk(KERN_ERR "mxser: interrupt number unset\n");\r\nreturn -EIO;\r\n}\r\nbrd->irq = ((int)(irq & 0xF000) >> 12);\r\nfor (i = 0; i < 8; i++)\r\nbrd->ports[i].ioaddr = (int) regs[i + 1] & 0xFFF8;\r\nif ((regs[12] & 0x80) == 0) {\r\nprintk(KERN_ERR "mxser: invalid interrupt vector\n");\r\nreturn -EIO;\r\n}\r\nbrd->vector = (int)regs[11];\r\nif (id == 1)\r\nbrd->vector_mask = 0x00FF;\r\nelse\r\nbrd->vector_mask = 0x000F;\r\nfor (i = 7, bits = 0x0100; i >= 0; i--, bits <<= 1) {\r\nif (regs[12] & bits) {\r\nbrd->ports[i].baud_base = 921600;\r\nbrd->ports[i].max_baud = 921600;\r\n} else {\r\nbrd->ports[i].baud_base = 115200;\r\nbrd->ports[i].max_baud = 115200;\r\n}\r\n}\r\nscratch2 = inb(cap + UART_LCR) & (~UART_LCR_DLAB);\r\noutb(scratch2 | UART_LCR_DLAB, cap + UART_LCR);\r\noutb(0, cap + UART_EFR);\r\noutb(scratch2, cap + UART_LCR);\r\noutb(UART_FCR_ENABLE_FIFO, cap + UART_FCR);\r\nscratch = inb(cap + UART_IIR);\r\nif (scratch & 0xC0)\r\nbrd->uart_type = PORT_16550A;\r\nelse\r\nbrd->uart_type = PORT_16450;\r\nif (!request_region(brd->ports[0].ioaddr, 8 * brd->info->nports,\r\n"mxser(IO)")) {\r\nprintk(KERN_ERR "mxser: can't request ports I/O region: "\r\n"0x%.8lx-0x%.8lx\n",\r\nbrd->ports[0].ioaddr, brd->ports[0].ioaddr +\r\n8 * brd->info->nports - 1);\r\nreturn -EIO;\r\n}\r\nret = mxser_request_vector(brd);\r\nif (ret) {\r\nrelease_region(brd->ports[0].ioaddr, 8 * brd->info->nports);\r\nprintk(KERN_ERR "mxser: can't request interrupt vector region: "\r\n"0x%.8lx-0x%.8lx\n",\r\nbrd->ports[0].ioaddr, brd->ports[0].ioaddr +\r\n8 * brd->info->nports - 1);\r\nreturn ret;\r\n}\r\nreturn brd->info->nports;\r\nerr_irqconflict:\r\nprintk(KERN_ERR "mxser: invalid interrupt number\n");\r\nreturn -EIO;\r\n}\r\nstatic int mxser_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\n#ifdef CONFIG_PCI\r\nstruct mxser_board *brd;\r\nunsigned int i, j;\r\nunsigned long ioaddress;\r\nstruct device *tty_dev;\r\nint retval = -EINVAL;\r\nfor (i = 0; i < MXSER_BOARDS; i++)\r\nif (mxser_boards[i].info == NULL)\r\nbreak;\r\nif (i >= MXSER_BOARDS) {\r\ndev_err(&pdev->dev, "too many boards found (maximum %d), board "\r\n"not configured\n", MXSER_BOARDS);\r\ngoto err;\r\n}\r\nbrd = &mxser_boards[i];\r\nbrd->idx = i * MXSER_PORTS_PER_BOARD;\r\ndev_info(&pdev->dev, "found MOXA %s board (BusNo=%d, DevNo=%d)\n",\r\nmxser_cards[ent->driver_data].name,\r\npdev->bus->number, PCI_SLOT(pdev->devfn));\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "PCI enable failed\n");\r\ngoto err;\r\n}\r\nioaddress = pci_resource_start(pdev, 2);\r\nretval = pci_request_region(pdev, 2, "mxser(IO)");\r\nif (retval)\r\ngoto err_dis;\r\nbrd->info = &mxser_cards[ent->driver_data];\r\nfor (i = 0; i < brd->info->nports; i++)\r\nbrd->ports[i].ioaddr = ioaddress + 8 * i;\r\nioaddress = pci_resource_start(pdev, 3);\r\nretval = pci_request_region(pdev, 3, "mxser(vector)");\r\nif (retval)\r\ngoto err_zero;\r\nbrd->vector = ioaddress;\r\nbrd->irq = pdev->irq;\r\nbrd->chip_flag = CheckIsMoxaMust(brd->ports[0].ioaddr);\r\nbrd->uart_type = PORT_16550A;\r\nbrd->vector_mask = 0;\r\nfor (i = 0; i < brd->info->nports; i++) {\r\nfor (j = 0; j < UART_INFO_NUM; j++) {\r\nif (Gpci_uart_info[j].type == brd->chip_flag) {\r\nbrd->ports[i].max_baud =\r\nGpci_uart_info[j].max_baud;\r\nif (brd->info->flags & MXSER_HIGHBAUD)\r\nbrd->ports[i].max_baud = 921600;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (brd->chip_flag == MOXA_MUST_MU860_HWID) {\r\nfor (i = 0; i < brd->info->nports; i++) {\r\nif (i < 4)\r\nbrd->ports[i].opmode_ioaddr = ioaddress + 4;\r\nelse\r\nbrd->ports[i].opmode_ioaddr = ioaddress + 0x0c;\r\n}\r\noutb(0, ioaddress + 4);\r\noutb(0, ioaddress + 0x0c);\r\n}\r\nfor (i = 0; i < brd->info->nports; i++) {\r\nbrd->vector_mask |= (1 << i);\r\nbrd->ports[i].baud_base = 921600;\r\n}\r\nretval = mxser_initbrd(brd, pdev);\r\nif (retval)\r\ngoto err_rel3;\r\nfor (i = 0; i < brd->info->nports; i++) {\r\ntty_dev = tty_port_register_device(&brd->ports[i].port,\r\nmxvar_sdriver, brd->idx + i, &pdev->dev);\r\nif (IS_ERR(tty_dev)) {\r\nretval = PTR_ERR(tty_dev);\r\nfor (; i > 0; i--)\r\ntty_unregister_device(mxvar_sdriver,\r\nbrd->idx + i - 1);\r\ngoto err_relbrd;\r\n}\r\n}\r\npci_set_drvdata(pdev, brd);\r\nreturn 0;\r\nerr_relbrd:\r\nfor (i = 0; i < brd->info->nports; i++)\r\ntty_port_destroy(&brd->ports[i].port);\r\nfree_irq(brd->irq, brd);\r\nerr_rel3:\r\npci_release_region(pdev, 3);\r\nerr_zero:\r\nbrd->info = NULL;\r\npci_release_region(pdev, 2);\r\nerr_dis:\r\npci_disable_device(pdev);\r\nerr:\r\nreturn retval;\r\n#else\r\nreturn -ENODEV;\r\n#endif\r\n}\r\nstatic void mxser_remove(struct pci_dev *pdev)\r\n{\r\n#ifdef CONFIG_PCI\r\nstruct mxser_board *brd = pci_get_drvdata(pdev);\r\nmxser_board_remove(brd);\r\npci_release_region(pdev, 2);\r\npci_release_region(pdev, 3);\r\npci_disable_device(pdev);\r\nbrd->info = NULL;\r\n#endif\r\n}\r\nstatic int __init mxser_module_init(void)\r\n{\r\nstruct mxser_board *brd;\r\nstruct device *tty_dev;\r\nunsigned int b, i, m;\r\nint retval;\r\nmxvar_sdriver = alloc_tty_driver(MXSER_PORTS + 1);\r\nif (!mxvar_sdriver)\r\nreturn -ENOMEM;\r\nprintk(KERN_INFO "MOXA Smartio/Industio family driver version %s\n",\r\nMXSER_VERSION);\r\nmxvar_sdriver->name = "ttyMI";\r\nmxvar_sdriver->major = ttymajor;\r\nmxvar_sdriver->minor_start = 0;\r\nmxvar_sdriver->type = TTY_DRIVER_TYPE_SERIAL;\r\nmxvar_sdriver->subtype = SERIAL_TYPE_NORMAL;\r\nmxvar_sdriver->init_termios = tty_std_termios;\r\nmxvar_sdriver->init_termios.c_cflag = B9600|CS8|CREAD|HUPCL|CLOCAL;\r\nmxvar_sdriver->flags = TTY_DRIVER_REAL_RAW|TTY_DRIVER_DYNAMIC_DEV;\r\ntty_set_operations(mxvar_sdriver, &mxser_ops);\r\nretval = tty_register_driver(mxvar_sdriver);\r\nif (retval) {\r\nprintk(KERN_ERR "Couldn't install MOXA Smartio/Industio family "\r\n"tty driver !\n");\r\ngoto err_put;\r\n}\r\nfor (m = 0, b = 0; b < MXSER_BOARDS; b++) {\r\nif (!ioaddr[b])\r\ncontinue;\r\nbrd = &mxser_boards[m];\r\nretval = mxser_get_ISA_conf(ioaddr[b], brd);\r\nif (retval <= 0) {\r\nbrd->info = NULL;\r\ncontinue;\r\n}\r\nprintk(KERN_INFO "mxser: found MOXA %s board (CAP=0x%lx)\n",\r\nbrd->info->name, ioaddr[b]);\r\nif (mxser_initbrd(brd, NULL) < 0) {\r\nmxser_release_ISA_res(brd);\r\nbrd->info = NULL;\r\ncontinue;\r\n}\r\nbrd->idx = m * MXSER_PORTS_PER_BOARD;\r\nfor (i = 0; i < brd->info->nports; i++) {\r\ntty_dev = tty_port_register_device(&brd->ports[i].port,\r\nmxvar_sdriver, brd->idx + i, NULL);\r\nif (IS_ERR(tty_dev)) {\r\nfor (; i > 0; i--)\r\ntty_unregister_device(mxvar_sdriver,\r\nbrd->idx + i - 1);\r\nfor (i = 0; i < brd->info->nports; i++)\r\ntty_port_destroy(&brd->ports[i].port);\r\nfree_irq(brd->irq, brd);\r\nmxser_release_ISA_res(brd);\r\nbrd->info = NULL;\r\nbreak;\r\n}\r\n}\r\nif (brd->info == NULL)\r\ncontinue;\r\nm++;\r\n}\r\nretval = pci_register_driver(&mxser_driver);\r\nif (retval) {\r\nprintk(KERN_ERR "mxser: can't register pci driver\n");\r\nif (!m) {\r\nretval = -ENODEV;\r\ngoto err_unr;\r\n}\r\n}\r\nreturn 0;\r\nerr_unr:\r\ntty_unregister_driver(mxvar_sdriver);\r\nerr_put:\r\nput_tty_driver(mxvar_sdriver);\r\nreturn retval;\r\n}\r\nstatic void __exit mxser_module_exit(void)\r\n{\r\nunsigned int i;\r\npci_unregister_driver(&mxser_driver);\r\nfor (i = 0; i < MXSER_BOARDS; i++)\r\nif (mxser_boards[i].info != NULL)\r\nmxser_board_remove(&mxser_boards[i]);\r\ntty_unregister_driver(mxvar_sdriver);\r\nput_tty_driver(mxvar_sdriver);\r\nfor (i = 0; i < MXSER_BOARDS; i++)\r\nif (mxser_boards[i].info != NULL)\r\nmxser_release_ISA_res(&mxser_boards[i]);\r\n}
