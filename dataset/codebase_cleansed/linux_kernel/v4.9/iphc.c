static inline void\r\nlowpan_iphc_uncompress_802154_lladdr(struct in6_addr *ipaddr,\r\nconst void *lladdr)\r\n{\r\nconst struct ieee802154_addr *addr = lladdr;\r\nu8 eui64[EUI64_ADDR_LEN];\r\nswitch (addr->mode) {\r\ncase IEEE802154_ADDR_LONG:\r\nieee802154_le64_to_be64(eui64, &addr->extended_addr);\r\nlowpan_iphc_uncompress_eui64_lladdr(ipaddr, eui64);\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nipaddr->s6_addr[11] = 0xFF;\r\nipaddr->s6_addr[12] = 0xFE;\r\nieee802154_le16_to_be16(&ipaddr->s6_addr16[7],\r\n&addr->short_addr);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\n}\r\nstatic struct lowpan_iphc_ctx *\r\nlowpan_iphc_ctx_get_by_id(const struct net_device *dev, u8 id)\r\n{\r\nstruct lowpan_iphc_ctx *ret = &lowpan_dev(dev)->ctx.table[id];\r\nif (!lowpan_iphc_ctx_is_active(ret))\r\nreturn NULL;\r\nreturn ret;\r\n}\r\nstatic struct lowpan_iphc_ctx *\r\nlowpan_iphc_ctx_get_by_addr(const struct net_device *dev,\r\nconst struct in6_addr *addr)\r\n{\r\nstruct lowpan_iphc_ctx *table = lowpan_dev(dev)->ctx.table;\r\nstruct lowpan_iphc_ctx *ret = NULL;\r\nstruct in6_addr addr_pfx;\r\nu8 addr_plen;\r\nint i;\r\nfor (i = 0; i < LOWPAN_IPHC_CTX_TABLE_SIZE; i++) {\r\nif (!lowpan_iphc_ctx_is_active(&table[i]) ||\r\n!lowpan_iphc_ctx_is_compression(&table[i]))\r\ncontinue;\r\nipv6_addr_prefix(&addr_pfx, addr, table[i].plen);\r\nif (table[i].plen < 64)\r\naddr_plen = 64;\r\nelse\r\naddr_plen = table[i].plen;\r\nif (ipv6_prefix_equal(&addr_pfx, &table[i].pfx, addr_plen)) {\r\nif (!ret) {\r\nret = &table[i];\r\ncontinue;\r\n}\r\nif (table[i].plen > ret->plen)\r\nret = &table[i];\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic struct lowpan_iphc_ctx *\r\nlowpan_iphc_ctx_get_by_mcast_addr(const struct net_device *dev,\r\nconst struct in6_addr *addr)\r\n{\r\nstruct lowpan_iphc_ctx *table = lowpan_dev(dev)->ctx.table;\r\nstruct lowpan_iphc_ctx *ret = NULL;\r\nstruct in6_addr addr_mcast, network_pfx = {};\r\nint i;\r\nmemcpy(&addr_mcast, addr, sizeof(*addr));\r\nfor (i = 0; i < LOWPAN_IPHC_CTX_TABLE_SIZE; i++) {\r\nif (!lowpan_iphc_ctx_is_active(&table[i]) ||\r\n!lowpan_iphc_ctx_is_compression(&table[i]))\r\ncontinue;\r\naddr_mcast.s6_addr[3] = table[i].plen;\r\nipv6_addr_prefix(&network_pfx, &table[i].pfx,\r\ntable[i].plen);\r\nmemcpy(&addr_mcast.s6_addr[4], &network_pfx, 8);\r\nif (ipv6_addr_equal(addr, &addr_mcast)) {\r\nret = &table[i];\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int lowpan_iphc_uncompress_addr(struct sk_buff *skb,\r\nconst struct net_device *dev,\r\nstruct in6_addr *ipaddr,\r\nu8 address_mode, const void *lladdr)\r\n{\r\nbool fail;\r\nswitch (address_mode) {\r\ncase LOWPAN_IPHC_DAM_00:\r\nfail = lowpan_fetch_skb(skb, ipaddr->s6_addr, 16);\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_01:\r\ncase LOWPAN_IPHC_DAM_01:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[8], 8);\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_10:\r\ncase LOWPAN_IPHC_DAM_10:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nipaddr->s6_addr[11] = 0xFF;\r\nipaddr->s6_addr[12] = 0xFE;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[14], 2);\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_11:\r\ncase LOWPAN_IPHC_DAM_11:\r\nfail = false;\r\nswitch (lowpan_dev(dev)->lltype) {\r\ncase LOWPAN_LLTYPE_IEEE802154:\r\nlowpan_iphc_uncompress_802154_lladdr(ipaddr, lladdr);\r\nbreak;\r\ndefault:\r\nlowpan_iphc_uncompress_eui64_lladdr(ipaddr, lladdr);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\npr_debug("Invalid address mode value: 0x%x\n", address_mode);\r\nreturn -EINVAL;\r\n}\r\nif (fail) {\r\npr_debug("Failed to fetch skb data\n");\r\nreturn -EIO;\r\n}\r\nraw_dump_inline(NULL, "Reconstructed ipv6 addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic int lowpan_iphc_uncompress_ctx_addr(struct sk_buff *skb,\r\nconst struct net_device *dev,\r\nconst struct lowpan_iphc_ctx *ctx,\r\nstruct in6_addr *ipaddr,\r\nu8 address_mode, const void *lladdr)\r\n{\r\nbool fail;\r\nswitch (address_mode) {\r\ncase LOWPAN_IPHC_DAM_00:\r\nfail = false;\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_01:\r\ncase LOWPAN_IPHC_DAM_01:\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[8], 8);\r\nipv6_addr_prefix_copy(ipaddr, &ctx->pfx, ctx->plen);\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_10:\r\ncase LOWPAN_IPHC_DAM_10:\r\nipaddr->s6_addr[11] = 0xFF;\r\nipaddr->s6_addr[12] = 0xFE;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[14], 2);\r\nipv6_addr_prefix_copy(ipaddr, &ctx->pfx, ctx->plen);\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_11:\r\ncase LOWPAN_IPHC_DAM_11:\r\nfail = false;\r\nswitch (lowpan_dev(dev)->lltype) {\r\ncase LOWPAN_LLTYPE_IEEE802154:\r\nlowpan_iphc_uncompress_802154_lladdr(ipaddr, lladdr);\r\nbreak;\r\ndefault:\r\nlowpan_iphc_uncompress_eui64_lladdr(ipaddr, lladdr);\r\nbreak;\r\n}\r\nipv6_addr_prefix_copy(ipaddr, &ctx->pfx, ctx->plen);\r\nbreak;\r\ndefault:\r\npr_debug("Invalid sam value: 0x%x\n", address_mode);\r\nreturn -EINVAL;\r\n}\r\nif (fail) {\r\npr_debug("Failed to fetch skb data\n");\r\nreturn -EIO;\r\n}\r\nraw_dump_inline(NULL,\r\n"Reconstructed context based ipv6 src addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic int lowpan_uncompress_multicast_daddr(struct sk_buff *skb,\r\nstruct in6_addr *ipaddr,\r\nu8 address_mode)\r\n{\r\nbool fail;\r\nswitch (address_mode) {\r\ncase LOWPAN_IPHC_DAM_00:\r\nfail = lowpan_fetch_skb(skb, ipaddr->s6_addr, 16);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_01:\r\nipaddr->s6_addr[0] = 0xFF;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 1);\r\nfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[11], 5);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_10:\r\nipaddr->s6_addr[0] = 0xFF;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 1);\r\nfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[13], 3);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_11:\r\nipaddr->s6_addr[0] = 0xFF;\r\nipaddr->s6_addr[1] = 0x02;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[15], 1);\r\nbreak;\r\ndefault:\r\npr_debug("DAM value has a wrong value: 0x%x\n", address_mode);\r\nreturn -EINVAL;\r\n}\r\nif (fail) {\r\npr_debug("Failed to fetch skb data\n");\r\nreturn -EIO;\r\n}\r\nraw_dump_inline(NULL, "Reconstructed ipv6 multicast addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic int lowpan_uncompress_multicast_ctx_daddr(struct sk_buff *skb,\r\nstruct lowpan_iphc_ctx *ctx,\r\nstruct in6_addr *ipaddr,\r\nu8 address_mode)\r\n{\r\nstruct in6_addr network_pfx = {};\r\nbool fail;\r\nipaddr->s6_addr[0] = 0xFF;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 2);\r\nfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[12], 4);\r\nif (fail)\r\nreturn -EIO;\r\nipaddr->s6_addr[3] = ctx->plen;\r\nipv6_addr_prefix(&network_pfx, &ctx->pfx, ctx->plen);\r\nmemcpy(&ipaddr->s6_addr[4], &network_pfx, 8);\r\nreturn 0;\r\n}\r\nstatic inline void lowpan_iphc_tf_set_ecn(struct ipv6hdr *hdr, const u8 *tf)\r\n{\r\nu8 ecn = tf[0] & 0xc0;\r\nhdr->flow_lbl[0] |= (ecn >> 2);\r\n}\r\nstatic inline void lowpan_iphc_tf_set_dscp(struct ipv6hdr *hdr, const u8 *tf)\r\n{\r\nu8 dscp = tf[0] & 0x3f;\r\nhdr->priority |= ((dscp & 0x3c) >> 2);\r\nhdr->flow_lbl[0] |= ((dscp & 0x03) << 6);\r\n}\r\nstatic inline void lowpan_iphc_tf_set_lbl(struct ipv6hdr *hdr, const u8 *lbl)\r\n{\r\nhdr->flow_lbl[0] |= lbl[0] & 0x0f;\r\nmemcpy(&hdr->flow_lbl[1], &lbl[1], 2);\r\n}\r\nstatic int lowpan_iphc_tf_decompress(struct sk_buff *skb, struct ipv6hdr *hdr,\r\nu8 val)\r\n{\r\nu8 tf[4];\r\nswitch (val) {\r\ncase LOWPAN_IPHC_TF_00:\r\nif (lowpan_fetch_skb(skb, tf, 4))\r\nreturn -EINVAL;\r\nlowpan_iphc_tf_set_ecn(hdr, tf);\r\nlowpan_iphc_tf_set_dscp(hdr, tf);\r\nlowpan_iphc_tf_set_lbl(hdr, &tf[1]);\r\nbreak;\r\ncase LOWPAN_IPHC_TF_01:\r\nif (lowpan_fetch_skb(skb, tf, 3))\r\nreturn -EINVAL;\r\nlowpan_iphc_tf_set_ecn(hdr, tf);\r\nlowpan_iphc_tf_set_lbl(hdr, &tf[0]);\r\nbreak;\r\ncase LOWPAN_IPHC_TF_10:\r\nif (lowpan_fetch_skb(skb, tf, 1))\r\nreturn -EINVAL;\r\nlowpan_iphc_tf_set_ecn(hdr, tf);\r\nlowpan_iphc_tf_set_dscp(hdr, tf);\r\nbreak;\r\ncase LOWPAN_IPHC_TF_11:\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint lowpan_header_decompress(struct sk_buff *skb, const struct net_device *dev,\r\nconst void *daddr, const void *saddr)\r\n{\r\nstruct ipv6hdr hdr = {};\r\nstruct lowpan_iphc_ctx *ci;\r\nu8 iphc0, iphc1, cid = 0;\r\nint err;\r\nraw_dump_table(__func__, "raw skb data dump uncompressed",\r\nskb->data, skb->len);\r\nif (lowpan_fetch_skb(skb, &iphc0, sizeof(iphc0)) ||\r\nlowpan_fetch_skb(skb, &iphc1, sizeof(iphc1)))\r\nreturn -EINVAL;\r\nhdr.version = 6;\r\nif (iphc1 & LOWPAN_IPHC_CID) {\r\nif (lowpan_fetch_skb(skb, &cid, sizeof(cid)))\r\nreturn -EINVAL;\r\n}\r\nerr = lowpan_iphc_tf_decompress(skb, &hdr,\r\niphc0 & LOWPAN_IPHC_TF_MASK);\r\nif (err < 0)\r\nreturn err;\r\nif (!(iphc0 & LOWPAN_IPHC_NH)) {\r\nif (lowpan_fetch_skb(skb, &hdr.nexthdr, sizeof(hdr.nexthdr)))\r\nreturn -EINVAL;\r\npr_debug("NH flag is set, next header carried inline: %02x\n",\r\nhdr.nexthdr);\r\n}\r\nif ((iphc0 & LOWPAN_IPHC_HLIM_MASK) != LOWPAN_IPHC_HLIM_00) {\r\nhdr.hop_limit = lowpan_ttl_values[iphc0 & LOWPAN_IPHC_HLIM_MASK];\r\n} else {\r\nif (lowpan_fetch_skb(skb, &hdr.hop_limit,\r\nsizeof(hdr.hop_limit)))\r\nreturn -EINVAL;\r\n}\r\nif (iphc1 & LOWPAN_IPHC_SAC) {\r\nspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\r\nci = lowpan_iphc_ctx_get_by_id(dev, LOWPAN_IPHC_CID_SCI(cid));\r\nif (!ci) {\r\nspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\r\nreturn -EINVAL;\r\n}\r\npr_debug("SAC bit is set. Handle context based source address.\n");\r\nerr = lowpan_iphc_uncompress_ctx_addr(skb, dev, ci, &hdr.saddr,\r\niphc1 & LOWPAN_IPHC_SAM_MASK,\r\nsaddr);\r\nspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\r\n} else {\r\npr_debug("source address stateless compression\n");\r\nerr = lowpan_iphc_uncompress_addr(skb, dev, &hdr.saddr,\r\niphc1 & LOWPAN_IPHC_SAM_MASK,\r\nsaddr);\r\n}\r\nif (err)\r\nreturn -EINVAL;\r\nswitch (iphc1 & (LOWPAN_IPHC_M | LOWPAN_IPHC_DAC)) {\r\ncase LOWPAN_IPHC_M | LOWPAN_IPHC_DAC:\r\nspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\r\nci = lowpan_iphc_ctx_get_by_id(dev, LOWPAN_IPHC_CID_DCI(cid));\r\nif (!ci) {\r\nspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\r\nreturn -EINVAL;\r\n}\r\npr_debug("dest: context-based mcast compression\n");\r\nerr = lowpan_uncompress_multicast_ctx_daddr(skb, ci,\r\n&hdr.daddr,\r\niphc1 & LOWPAN_IPHC_DAM_MASK);\r\nspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\r\nbreak;\r\ncase LOWPAN_IPHC_M:\r\nerr = lowpan_uncompress_multicast_daddr(skb, &hdr.daddr,\r\niphc1 & LOWPAN_IPHC_DAM_MASK);\r\nbreak;\r\ncase LOWPAN_IPHC_DAC:\r\nspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\r\nci = lowpan_iphc_ctx_get_by_id(dev, LOWPAN_IPHC_CID_DCI(cid));\r\nif (!ci) {\r\nspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\r\nreturn -EINVAL;\r\n}\r\npr_debug("DAC bit is set. Handle context based destination address.\n");\r\nerr = lowpan_iphc_uncompress_ctx_addr(skb, dev, ci, &hdr.daddr,\r\niphc1 & LOWPAN_IPHC_DAM_MASK,\r\ndaddr);\r\nspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\r\nbreak;\r\ndefault:\r\nerr = lowpan_iphc_uncompress_addr(skb, dev, &hdr.daddr,\r\niphc1 & LOWPAN_IPHC_DAM_MASK,\r\ndaddr);\r\npr_debug("dest: stateless compression mode %d dest %pI6c\n",\r\niphc1 & LOWPAN_IPHC_DAM_MASK, &hdr.daddr);\r\nbreak;\r\n}\r\nif (err)\r\nreturn -EINVAL;\r\nif (iphc0 & LOWPAN_IPHC_NH) {\r\nerr = lowpan_nhc_do_uncompression(skb, dev, &hdr);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nerr = skb_cow(skb, sizeof(hdr));\r\nif (unlikely(err))\r\nreturn err;\r\n}\r\nswitch (lowpan_dev(dev)->lltype) {\r\ncase LOWPAN_LLTYPE_IEEE802154:\r\nif (lowpan_802154_cb(skb)->d_size)\r\nhdr.payload_len = htons(lowpan_802154_cb(skb)->d_size -\r\nsizeof(struct ipv6hdr));\r\nelse\r\nhdr.payload_len = htons(skb->len);\r\nbreak;\r\ndefault:\r\nhdr.payload_len = htons(skb->len);\r\nbreak;\r\n}\r\npr_debug("skb headroom size = %d, data length = %d\n",\r\nskb_headroom(skb), skb->len);\r\npr_debug("IPv6 header dump:\n\tversion = %d\n\tlength = %d\n\t"\r\n"nexthdr = 0x%02x\n\thop_lim = %d\n\tdest = %pI6c\n",\r\nhdr.version, ntohs(hdr.payload_len), hdr.nexthdr,\r\nhdr.hop_limit, &hdr.daddr);\r\nskb_push(skb, sizeof(hdr));\r\nskb_reset_network_header(skb);\r\nskb_copy_to_linear_data(skb, &hdr, sizeof(hdr));\r\nraw_dump_table(__func__, "raw header dump", (u8 *)&hdr, sizeof(hdr));\r\nreturn 0;\r\n}\r\nstatic inline bool\r\nlowpan_iphc_compress_ctx_802154_lladdr(const struct in6_addr *ipaddr,\r\nconst struct lowpan_iphc_ctx *ctx,\r\nconst void *lladdr)\r\n{\r\nconst struct ieee802154_addr *addr = lladdr;\r\nunsigned char extended_addr[EUI64_ADDR_LEN];\r\nbool lladdr_compress = false;\r\nstruct in6_addr tmp = {};\r\nswitch (addr->mode) {\r\ncase IEEE802154_ADDR_LONG:\r\nieee802154_le64_to_be64(&extended_addr, &addr->extended_addr);\r\nmemcpy(&tmp.s6_addr[8], &extended_addr, EUI64_ADDR_LEN);\r\ntmp.s6_addr[8] ^= 0x02;\r\nipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\r\nif (ipv6_addr_equal(&tmp, ipaddr))\r\nlladdr_compress = true;\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\ntmp.s6_addr[11] = 0xFF;\r\ntmp.s6_addr[12] = 0xFE;\r\nieee802154_le16_to_be16(&tmp.s6_addr16[7],\r\n&addr->short_addr);\r\nipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\r\nif (ipv6_addr_equal(&tmp, ipaddr))\r\nlladdr_compress = true;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\nreturn lladdr_compress;\r\n}\r\nstatic u8 lowpan_compress_ctx_addr(u8 **hc_ptr, const struct net_device *dev,\r\nconst struct in6_addr *ipaddr,\r\nconst struct lowpan_iphc_ctx *ctx,\r\nconst unsigned char *lladdr, bool sam)\r\n{\r\nstruct in6_addr tmp = {};\r\nu8 dam;\r\nswitch (lowpan_dev(dev)->lltype) {\r\ncase LOWPAN_LLTYPE_IEEE802154:\r\nif (lowpan_iphc_compress_ctx_802154_lladdr(ipaddr, ctx,\r\nlladdr)) {\r\ndam = LOWPAN_IPHC_DAM_11;\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\nmemcpy(&tmp.s6_addr[8], lladdr, EUI64_ADDR_LEN);\r\ntmp.s6_addr[8] ^= 0x02;\r\nipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\r\nif (ipv6_addr_equal(&tmp, ipaddr)) {\r\ndam = LOWPAN_IPHC_DAM_11;\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.s6_addr[11] = 0xFF;\r\ntmp.s6_addr[12] = 0xFE;\r\nmemcpy(&tmp.s6_addr[14], &ipaddr->s6_addr[14], 2);\r\nipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\r\nif (ipv6_addr_equal(&tmp, ipaddr)) {\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[14], 2);\r\ndam = LOWPAN_IPHC_DAM_10;\r\ngoto out;\r\n}\r\nmemset(&tmp, 0, sizeof(tmp));\r\nmemcpy(&tmp.s6_addr[8], &ipaddr->s6_addr[8], 8);\r\nipv6_addr_prefix_copy(&tmp, &ctx->pfx, ctx->plen);\r\nif (ipv6_addr_equal(&tmp, ipaddr)) {\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[8], 8);\r\ndam = LOWPAN_IPHC_DAM_01;\r\ngoto out;\r\n}\r\nWARN_ONCE(1, "context found but no address mode matched\n");\r\nreturn LOWPAN_IPHC_DAM_00;\r\nout:\r\nif (sam)\r\nreturn lowpan_iphc_dam_to_sam_value[dam];\r\nelse\r\nreturn dam;\r\n}\r\nstatic inline bool\r\nlowpan_iphc_compress_802154_lladdr(const struct in6_addr *ipaddr,\r\nconst void *lladdr)\r\n{\r\nconst struct ieee802154_addr *addr = lladdr;\r\nunsigned char extended_addr[EUI64_ADDR_LEN];\r\nbool lladdr_compress = false;\r\nstruct in6_addr tmp = {};\r\nswitch (addr->mode) {\r\ncase IEEE802154_ADDR_LONG:\r\nieee802154_le64_to_be64(&extended_addr, &addr->extended_addr);\r\nif (is_addr_mac_addr_based(ipaddr, extended_addr))\r\nlladdr_compress = true;\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\ntmp.s6_addr[0] = 0xFE;\r\ntmp.s6_addr[1] = 0x80;\r\ntmp.s6_addr[11] = 0xFF;\r\ntmp.s6_addr[12] = 0xFE;\r\nieee802154_le16_to_be16(&tmp.s6_addr16[7],\r\n&addr->short_addr);\r\nif (ipv6_addr_equal(&tmp, ipaddr))\r\nlladdr_compress = true;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\nreturn lladdr_compress;\r\n}\r\nstatic u8 lowpan_compress_addr_64(u8 **hc_ptr, const struct net_device *dev,\r\nconst struct in6_addr *ipaddr,\r\nconst unsigned char *lladdr, bool sam)\r\n{\r\nu8 dam = LOWPAN_IPHC_DAM_01;\r\nswitch (lowpan_dev(dev)->lltype) {\r\ncase LOWPAN_LLTYPE_IEEE802154:\r\nif (lowpan_iphc_compress_802154_lladdr(ipaddr, lladdr)) {\r\ndam = LOWPAN_IPHC_DAM_11;\r\npr_debug("address compression 0 bits\n");\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\nif (is_addr_mac_addr_based(ipaddr, lladdr)) {\r\ndam = LOWPAN_IPHC_DAM_11;\r\npr_debug("address compression 0 bits\n");\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\nif (lowpan_is_iid_16_bit_compressable(ipaddr)) {\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr16[7], 2);\r\ndam = LOWPAN_IPHC_DAM_10;\r\nraw_dump_inline(NULL, "Compressed ipv6 addr is (16 bits)",\r\n*hc_ptr - 2, 2);\r\ngoto out;\r\n}\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr16[4], 8);\r\nraw_dump_inline(NULL, "Compressed ipv6 addr is (64 bits)",\r\n*hc_ptr - 8, 8);\r\nout:\r\nif (sam)\r\nreturn lowpan_iphc_dam_to_sam_value[dam];\r\nelse\r\nreturn dam;\r\n}\r\nstatic inline u8 lowpan_iphc_get_tc(const struct ipv6hdr *hdr)\r\n{\r\nu8 dscp, ecn;\r\ndscp = (hdr->priority << 2) | ((hdr->flow_lbl[0] & 0xc0) >> 6);\r\necn = (hdr->flow_lbl[0] & 0x30);\r\npr_debug("ecn 0x%02x dscp 0x%02x\n", ecn >> 4, dscp);\r\nreturn (ecn << 2) | dscp;\r\n}\r\nstatic inline bool lowpan_iphc_is_flow_lbl_zero(const struct ipv6hdr *hdr)\r\n{\r\nreturn ((!(hdr->flow_lbl[0] & 0x0f)) &&\r\n!hdr->flow_lbl[1] && !hdr->flow_lbl[2]);\r\n}\r\nstatic u8 lowpan_iphc_tf_compress(u8 **hc_ptr, const struct ipv6hdr *hdr)\r\n{\r\nu8 tc = lowpan_iphc_get_tc(hdr), tf[4], val;\r\npr_debug("tc 0x%02x\n", tc);\r\nif (lowpan_iphc_is_flow_lbl_zero(hdr)) {\r\nif (!tc) {\r\nval = LOWPAN_IPHC_TF_11;\r\n} else {\r\nlowpan_push_hc_data(hc_ptr, &tc, sizeof(tc));\r\nval = LOWPAN_IPHC_TF_10;\r\n}\r\n} else {\r\nif (!(tc & 0x3f)) {\r\nmemcpy(&tf[0], &hdr->flow_lbl[0], 3);\r\ntf[0] &= ~0xf0;\r\ntf[0] |= (tc & 0xc0);\r\nlowpan_push_hc_data(hc_ptr, tf, 3);\r\nval = LOWPAN_IPHC_TF_01;\r\n} else {\r\nmemcpy(&tf[0], &tc, sizeof(tc));\r\nmemcpy(&tf[1], &hdr->flow_lbl[0], 3);\r\ntf[1] &= ~0xf0;\r\nlowpan_push_hc_data(hc_ptr, tf, 4);\r\nval = LOWPAN_IPHC_TF_00;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic u8 lowpan_iphc_mcast_ctx_addr_compress(u8 **hc_ptr,\r\nconst struct lowpan_iphc_ctx *ctx,\r\nconst struct in6_addr *ipaddr)\r\n{\r\nu8 data[6];\r\nmemcpy(data, &ipaddr->s6_addr[1], 2);\r\nmemcpy(&data[1], &ipaddr->s6_addr[11], 4);\r\nlowpan_push_hc_data(hc_ptr, data, 6);\r\nreturn LOWPAN_IPHC_DAM_00;\r\n}\r\nstatic u8 lowpan_iphc_mcast_addr_compress(u8 **hc_ptr,\r\nconst struct in6_addr *ipaddr)\r\n{\r\nu8 val;\r\nif (lowpan_is_mcast_addr_compressable8(ipaddr)) {\r\npr_debug("compressed to 1 octet\n");\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[15], 1);\r\nval = LOWPAN_IPHC_DAM_11;\r\n} else if (lowpan_is_mcast_addr_compressable32(ipaddr)) {\r\npr_debug("compressed to 4 octets\n");\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[1], 1);\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[13], 3);\r\nval = LOWPAN_IPHC_DAM_10;\r\n} else if (lowpan_is_mcast_addr_compressable48(ipaddr)) {\r\npr_debug("compressed to 6 octets\n");\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[1], 1);\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[11], 5);\r\nval = LOWPAN_IPHC_DAM_01;\r\n} else {\r\npr_debug("using full address\n");\r\nlowpan_push_hc_data(hc_ptr, ipaddr->s6_addr, 16);\r\nval = LOWPAN_IPHC_DAM_00;\r\n}\r\nreturn val;\r\n}\r\nint lowpan_header_compress(struct sk_buff *skb, const struct net_device *dev,\r\nconst void *daddr, const void *saddr)\r\n{\r\nu8 iphc0, iphc1, *hc_ptr, cid = 0;\r\nstruct ipv6hdr *hdr;\r\nu8 head[LOWPAN_IPHC_MAX_HC_BUF_LEN] = {};\r\nstruct lowpan_iphc_ctx *dci, *sci, dci_entry, sci_entry;\r\nint ret, ipv6_daddr_type, ipv6_saddr_type;\r\nif (skb->protocol != htons(ETH_P_IPV6))\r\nreturn -EINVAL;\r\nhdr = ipv6_hdr(skb);\r\nhc_ptr = head + 2;\r\npr_debug("IPv6 header dump:\n\tversion = %d\n\tlength = %d\n"\r\n"\tnexthdr = 0x%02x\n\thop_lim = %d\n\tdest = %pI6c\n",\r\nhdr->version, ntohs(hdr->payload_len), hdr->nexthdr,\r\nhdr->hop_limit, &hdr->daddr);\r\nraw_dump_table(__func__, "raw skb network header dump",\r\nskb_network_header(skb), sizeof(struct ipv6hdr));\r\niphc0 = LOWPAN_DISPATCH_IPHC;\r\niphc1 = 0;\r\nraw_dump_table(__func__, "sending raw skb network uncompressed packet",\r\nskb->data, skb->len);\r\nipv6_daddr_type = ipv6_addr_type(&hdr->daddr);\r\nspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\r\nif (ipv6_daddr_type & IPV6_ADDR_MULTICAST)\r\ndci = lowpan_iphc_ctx_get_by_mcast_addr(dev, &hdr->daddr);\r\nelse\r\ndci = lowpan_iphc_ctx_get_by_addr(dev, &hdr->daddr);\r\nif (dci) {\r\nmemcpy(&dci_entry, dci, sizeof(*dci));\r\ncid |= dci->id;\r\n}\r\nspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\r\nspin_lock_bh(&lowpan_dev(dev)->ctx.lock);\r\nsci = lowpan_iphc_ctx_get_by_addr(dev, &hdr->saddr);\r\nif (sci) {\r\nmemcpy(&sci_entry, sci, sizeof(*sci));\r\ncid |= (sci->id << 4);\r\n}\r\nspin_unlock_bh(&lowpan_dev(dev)->ctx.lock);\r\nif (cid) {\r\niphc1 |= LOWPAN_IPHC_CID;\r\nlowpan_push_hc_data(&hc_ptr, &cid, sizeof(cid));\r\n}\r\niphc0 |= lowpan_iphc_tf_compress(&hc_ptr, hdr);\r\nret = lowpan_nhc_check_compression(skb, hdr, &hc_ptr);\r\nif (ret == -ENOENT)\r\nlowpan_push_hc_data(&hc_ptr, &hdr->nexthdr,\r\nsizeof(hdr->nexthdr));\r\nelse\r\niphc0 |= LOWPAN_IPHC_NH;\r\nswitch (hdr->hop_limit) {\r\ncase 1:\r\niphc0 |= LOWPAN_IPHC_HLIM_01;\r\nbreak;\r\ncase 64:\r\niphc0 |= LOWPAN_IPHC_HLIM_10;\r\nbreak;\r\ncase 255:\r\niphc0 |= LOWPAN_IPHC_HLIM_11;\r\nbreak;\r\ndefault:\r\nlowpan_push_hc_data(&hc_ptr, &hdr->hop_limit,\r\nsizeof(hdr->hop_limit));\r\n}\r\nipv6_saddr_type = ipv6_addr_type(&hdr->saddr);\r\nif (ipv6_saddr_type == IPV6_ADDR_ANY) {\r\npr_debug("source address is unspecified, setting SAC\n");\r\niphc1 |= LOWPAN_IPHC_SAC;\r\n} else {\r\nif (sci) {\r\niphc1 |= lowpan_compress_ctx_addr(&hc_ptr, dev,\r\n&hdr->saddr,\r\n&sci_entry, saddr,\r\ntrue);\r\niphc1 |= LOWPAN_IPHC_SAC;\r\n} else {\r\nif (ipv6_saddr_type & IPV6_ADDR_LINKLOCAL &&\r\nlowpan_is_linklocal_zero_padded(hdr->saddr)) {\r\niphc1 |= lowpan_compress_addr_64(&hc_ptr, dev,\r\n&hdr->saddr,\r\nsaddr, true);\r\npr_debug("source address unicast link-local %pI6c iphc1 0x%02x\n",\r\n&hdr->saddr, iphc1);\r\n} else {\r\npr_debug("send the full source address\n");\r\nlowpan_push_hc_data(&hc_ptr,\r\nhdr->saddr.s6_addr, 16);\r\n}\r\n}\r\n}\r\nif (ipv6_daddr_type & IPV6_ADDR_MULTICAST) {\r\npr_debug("destination address is multicast: ");\r\niphc1 |= LOWPAN_IPHC_M;\r\nif (dci) {\r\niphc1 |= lowpan_iphc_mcast_ctx_addr_compress(&hc_ptr,\r\n&dci_entry,\r\n&hdr->daddr);\r\niphc1 |= LOWPAN_IPHC_DAC;\r\n} else {\r\niphc1 |= lowpan_iphc_mcast_addr_compress(&hc_ptr,\r\n&hdr->daddr);\r\n}\r\n} else {\r\nif (dci) {\r\niphc1 |= lowpan_compress_ctx_addr(&hc_ptr, dev,\r\n&hdr->daddr,\r\n&dci_entry, daddr,\r\nfalse);\r\niphc1 |= LOWPAN_IPHC_DAC;\r\n} else {\r\nif (ipv6_daddr_type & IPV6_ADDR_LINKLOCAL &&\r\nlowpan_is_linklocal_zero_padded(hdr->daddr)) {\r\niphc1 |= lowpan_compress_addr_64(&hc_ptr, dev,\r\n&hdr->daddr,\r\ndaddr, false);\r\npr_debug("dest address unicast link-local %pI6c iphc1 0x%02x\n",\r\n&hdr->daddr, iphc1);\r\n} else {\r\npr_debug("dest address unicast %pI6c\n",\r\n&hdr->daddr);\r\nlowpan_push_hc_data(&hc_ptr,\r\nhdr->daddr.s6_addr, 16);\r\n}\r\n}\r\n}\r\nif (iphc0 & LOWPAN_IPHC_NH) {\r\nret = lowpan_nhc_do_compression(skb, hdr, &hc_ptr);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nhead[0] = iphc0;\r\nhead[1] = iphc1;\r\nskb_pull(skb, sizeof(struct ipv6hdr));\r\nskb_reset_transport_header(skb);\r\nmemcpy(skb_push(skb, hc_ptr - head), head, hc_ptr - head);\r\nskb_reset_network_header(skb);\r\npr_debug("header len %d skb %u\n", (int)(hc_ptr - head), skb->len);\r\nraw_dump_table(__func__, "raw skb data dump compressed",\r\nskb->data, skb->len);\r\nreturn 0;\r\n}
