static inline struct saa7706h_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa7706h_state, sd);\r\n}\r\nstatic int saa7706h_i2c_send(struct i2c_client *client, const u8 *data, int len)\r\n{\r\nint err = i2c_master_send(client, data, len);\r\nif (err == len)\r\nreturn 0;\r\nreturn err > 0 ? -EIO : err;\r\n}\r\nstatic int saa7706h_i2c_transfer(struct i2c_client *client,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nint err = i2c_transfer(client->adapter, msgs, num);\r\nif (err == num)\r\nreturn 0;\r\nreturn err > 0 ? -EIO : err;\r\n}\r\nstatic int saa7706h_set_reg24(struct v4l2_subdev *sd, u16 reg, u32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 buf[5];\r\nint pos = 0;\r\nbuf[pos++] = reg >> 8;\r\nbuf[pos++] = reg;\r\nbuf[pos++] = val >> 16;\r\nbuf[pos++] = val >> 8;\r\nbuf[pos++] = val;\r\nreturn saa7706h_i2c_send(client, buf, pos);\r\n}\r\nstatic int saa7706h_set_reg24_err(struct v4l2_subdev *sd, u16 reg, u32 val,\r\nint *err)\r\n{\r\nreturn *err ? *err : saa7706h_set_reg24(sd, reg, val);\r\n}\r\nstatic int saa7706h_set_reg16(struct v4l2_subdev *sd, u16 reg, u16 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 buf[4];\r\nint pos = 0;\r\nbuf[pos++] = reg >> 8;\r\nbuf[pos++] = reg;\r\nbuf[pos++] = val >> 8;\r\nbuf[pos++] = val;\r\nreturn saa7706h_i2c_send(client, buf, pos);\r\n}\r\nstatic int saa7706h_set_reg16_err(struct v4l2_subdev *sd, u16 reg, u16 val,\r\nint *err)\r\n{\r\nreturn *err ? *err : saa7706h_set_reg16(sd, reg, val);\r\n}\r\nstatic int saa7706h_get_reg16(struct v4l2_subdev *sd, u16 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 buf[2];\r\nint err;\r\nu8 regaddr[] = {reg >> 8, reg};\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = client->addr,\r\n.len = sizeof(regaddr),\r\n.buf = regaddr\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(buf),\r\n.buf = buf\r\n}\r\n};\r\nerr = saa7706h_i2c_transfer(client, msg, ARRAY_SIZE(msg));\r\nif (err)\r\nreturn err;\r\nreturn buf[0] << 8 | buf[1];\r\n}\r\nstatic int saa7706h_unmute(struct v4l2_subdev *sd)\r\n{\r\nstruct saa7706h_state *state = to_state(sd);\r\nint err = 0;\r\nerr = saa7706h_set_reg16_err(sd, SAA7706H_REG_CTRL,\r\nSAA7706H_CTRL_PLL3_62975MHZ | SAA7706H_CTRL_PC_RESET_DSP1 |\r\nSAA7706H_CTRL_PC_RESET_DSP2, &err);\r\nmsleep(1);\r\nerr = saa7706h_set_reg16_err(sd, SAA7706H_REG_CTRL,\r\nSAA7706H_CTRL_PLL3_62975MHZ, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_EVALUATION, 0, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CL_GEN1, 0x040022, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CL_GEN2,\r\nSAA7706H_CL_GEN2_WSEDGE_FALLING, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CL_GEN4, 0x024080, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_SEL, 0x200080, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_IAC, 0xf4caed, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CLK_SET, 0x124334, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_CLK_COEFF, 0x004a1a,\r\n&err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_INPUT_SENS, 0x0071c7,\r\n&err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_PHONE_NAV_AUDIO,\r\n0x0e22ff, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_IO_CONF_DSP2, 0x001ff8,\r\n&err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_STATUS_DSP2, 0x080003,\r\n&err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_REG_PC_DSP2, 0x000004, &err);\r\nerr = saa7706h_set_reg16_err(sd, SAA7706H_DSP1_MOD0, 0x0c6c, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_MPTR0, 0x000b4b, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP1_MODPNTR, 0x000600, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP1_MODPNTR, 0x0000c0, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_CONTLLCW, 0x000819,\r\n&err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_CONTLLCW, 0x00085a,\r\n&err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_BUSAMP, 0x7fffff,\r\n&err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_FDACPNTR, 0x2000cb,\r\n&err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_IIS1PNTR, 0x2000cb,\r\n&err);\r\nerr = saa7706h_set_reg16_err(sd, SAA7706H_DSP2_YMEM_PVGA, 0x0f80, &err);\r\nerr = saa7706h_set_reg16_err(sd, SAA7706H_DSP2_YMEM_PVAT1, 0x0800,\r\n&err);\r\nerr = saa7706h_set_reg16_err(sd, SAA7706H_DSP2_YMEM_PVAT, 0x0800, &err);\r\nerr = saa7706h_set_reg24_err(sd, SAA7706H_DSP2_XMEM_CONTLLCW, 0x000905,\r\n&err);\r\nif (!err)\r\nstate->muted = 0;\r\nreturn err;\r\n}\r\nstatic int saa7706h_mute(struct v4l2_subdev *sd)\r\n{\r\nstruct saa7706h_state *state = to_state(sd);\r\nint err;\r\nerr = saa7706h_set_reg16(sd, SAA7706H_REG_CTRL,\r\nSAA7706H_CTRL_PLL3_62975MHZ | SAA7706H_CTRL_PC_RESET_DSP1 |\r\nSAA7706H_CTRL_PC_RESET_DSP2);\r\nif (!err)\r\nstate->muted = 1;\r\nreturn err;\r\n}\r\nstatic int saa7706h_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct saa7706h_state *state =\r\ncontainer_of(ctrl->handler, struct saa7706h_state, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->val)\r\nreturn saa7706h_mute(&state->sd);\r\nreturn saa7706h_unmute(&state->sd);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int saa7706h_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct saa7706h_state *state;\r\nstruct v4l2_subdev *sd;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nstate = kzalloc(sizeof(struct saa7706h_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &empty_ops);\r\nv4l2_ctrl_handler_init(&state->hdl, 4);\r\nv4l2_ctrl_new_std(&state->hdl, &saa7706h_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nsd->ctrl_handler = &state->hdl;\r\nerr = state->hdl.error;\r\nif (err)\r\ngoto err;\r\nerr = saa7706h_get_reg16(sd, SAA7706H_DSP1_ROM_VER);\r\nif (err < 0)\r\ngoto err;\r\nif (err != SUPPORTED_DSP1_ROM_VER)\r\nv4l2_warn(sd, "Unknown DSP1 ROM code version: 0x%x\n", err);\r\nstate->muted = 1;\r\nerr = saa7706h_mute(sd);\r\nif (err)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(to_state(sd));\r\nprintk(KERN_ERR DRIVER_NAME ": Failed to probe: %d\n", err);\r\nreturn err;\r\n}\r\nstatic int saa7706h_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct saa7706h_state *state = to_state(sd);\r\nsaa7706h_mute(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}
