static char *hmcdrv_dev_name(struct device *dev, umode_t *mode)\r\n{\r\nchar *nodename = NULL;\r\nconst char *devname = dev_name(dev);\r\nif (devname)\r\nnodename = kasprintf(GFP_KERNEL, "%s", devname);\r\nif (mode)\r\n*mode = hmcdrv_dev.mode;\r\nreturn nodename;\r\n}\r\nstatic int hmcdrv_dev_open(struct inode *inode, struct file *fp)\r\n{\r\nint rc;\r\nif (fp->f_flags & O_NONBLOCK)\r\nreturn -EINVAL;\r\nif ((fp->f_flags & O_ACCMODE) == O_RDONLY)\r\nreturn -EINVAL;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -ENODEV;\r\nfp->private_data = NULL;\r\nrc = hmcdrv_ftp_startup();\r\nif (rc)\r\nmodule_put(THIS_MODULE);\r\npr_debug("open file '/dev/%pD' with return code %d\n", fp, rc);\r\nreturn rc;\r\n}\r\nstatic int hmcdrv_dev_release(struct inode *inode, struct file *fp)\r\n{\r\npr_debug("closing file '/dev/%pD'\n", fp);\r\nkfree(fp->private_data);\r\nfp->private_data = NULL;\r\nhmcdrv_ftp_shutdown();\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nstatic loff_t hmcdrv_dev_seek(struct file *fp, loff_t pos, int whence)\r\n{\r\nswitch (whence) {\r\ncase SEEK_CUR:\r\npos += fp->f_pos;\r\nbreak;\r\ncase SEEK_SET:\r\nbreak;\r\ncase SEEK_END:\r\nif (fp->private_data) {\r\nkfree(fp->private_data);\r\nfp->private_data = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (fp->f_pos != pos)\r\n++fp->f_version;\r\nfp->f_pos = pos;\r\nreturn pos;\r\n}\r\nstatic ssize_t hmcdrv_dev_transfer(char __kernel *cmd, loff_t offset,\r\nchar __user *buf, size_t len)\r\n{\r\nssize_t retlen;\r\nunsigned trials = HMCDRV_DEV_BUSY_RETRIES;\r\ndo {\r\nretlen = hmcdrv_ftp_cmd(cmd, offset, buf, len);\r\nif (retlen != -EBUSY)\r\nbreak;\r\nmsleep(HMCDRV_DEV_BUSY_DELAY);\r\n} while (--trials > 0);\r\nreturn retlen;\r\n}\r\nstatic ssize_t hmcdrv_dev_read(struct file *fp, char __user *ubuf,\r\nsize_t len, loff_t *pos)\r\n{\r\nssize_t retlen;\r\nif (((fp->f_flags & O_ACCMODE) == O_WRONLY) ||\r\n(fp->private_data == NULL)) {\r\nreturn -EBADF;\r\n}\r\nretlen = hmcdrv_dev_transfer((char *) fp->private_data,\r\n*pos, ubuf, len);\r\npr_debug("read from file '/dev/%pD' at %lld returns %zd/%zu\n",\r\nfp, (long long) *pos, retlen, len);\r\nif (retlen > 0)\r\n*pos += retlen;\r\nreturn retlen;\r\n}\r\nstatic ssize_t hmcdrv_dev_write(struct file *fp, const char __user *ubuf,\r\nsize_t len, loff_t *pos)\r\n{\r\nssize_t retlen;\r\npr_debug("writing file '/dev/%pD' at pos. %lld with length %zd\n",\r\nfp, (long long) *pos, len);\r\nif (!fp->private_data) {\r\nfp->private_data = kmalloc(len + 1, GFP_KERNEL);\r\nif (!fp->private_data)\r\nreturn -ENOMEM;\r\nif (!copy_from_user(fp->private_data, ubuf, len)) {\r\n((char *)fp->private_data)[len] = '\0';\r\nreturn len;\r\n}\r\nkfree(fp->private_data);\r\nfp->private_data = NULL;\r\nreturn -EFAULT;\r\n}\r\nretlen = hmcdrv_dev_transfer((char *) fp->private_data,\r\n*pos, (char __user *) ubuf, len);\r\nif (retlen > 0)\r\n*pos += retlen;\r\npr_debug("write to file '/dev/%pD' returned %zd\n", fp, retlen);\r\nreturn retlen;\r\n}\r\nint hmcdrv_dev_init(void)\r\n{\r\nint rc;\r\n#ifdef HMCDRV_DEV_CLASS\r\nstruct device *dev;\r\nrc = alloc_chrdev_region(&hmcdrv_dev_no, 0, 1, HMCDRV_DEV_NAME);\r\nif (rc)\r\ngoto out_err;\r\ncdev_init(&hmcdrv_dev.dev, &hmcdrv_dev_fops);\r\nhmcdrv_dev.dev.owner = THIS_MODULE;\r\nrc = cdev_add(&hmcdrv_dev.dev, hmcdrv_dev_no, 1);\r\nif (rc)\r\ngoto out_unreg;\r\nhmcdrv_dev_class = class_create(THIS_MODULE, HMCDRV_DEV_CLASS);\r\nif (IS_ERR(hmcdrv_dev_class)) {\r\nrc = PTR_ERR(hmcdrv_dev_class);\r\ngoto out_devdel;\r\n}\r\nhmcdrv_dev.mode = 0;\r\nhmcdrv_dev_class->devnode = hmcdrv_dev_name;\r\ndev = device_create(hmcdrv_dev_class, NULL, hmcdrv_dev_no, NULL,\r\n"%s", HMCDRV_DEV_NAME);\r\nif (!IS_ERR(dev))\r\nreturn 0;\r\nrc = PTR_ERR(dev);\r\nclass_destroy(hmcdrv_dev_class);\r\nhmcdrv_dev_class = NULL;\r\nout_devdel:\r\ncdev_del(&hmcdrv_dev.dev);\r\nout_unreg:\r\nunregister_chrdev_region(hmcdrv_dev_no, 1);\r\nout_err:\r\n#else\r\nhmcdrv_dev.dev.minor = MISC_DYNAMIC_MINOR;\r\nhmcdrv_dev.dev.name = HMCDRV_DEV_NAME;\r\nhmcdrv_dev.dev.fops = &hmcdrv_dev_fops;\r\nhmcdrv_dev.dev.mode = 0;\r\nrc = misc_register(&hmcdrv_dev.dev);\r\n#endif\r\nreturn rc;\r\n}\r\nvoid hmcdrv_dev_exit(void)\r\n{\r\n#ifdef HMCDRV_DEV_CLASS\r\nif (!IS_ERR_OR_NULL(hmcdrv_dev_class)) {\r\ndevice_destroy(hmcdrv_dev_class, hmcdrv_dev_no);\r\nclass_destroy(hmcdrv_dev_class);\r\n}\r\ncdev_del(&hmcdrv_dev.dev);\r\nunregister_chrdev_region(hmcdrv_dev_no, 1);\r\n#else\r\nmisc_deregister(&hmcdrv_dev.dev);\r\n#endif\r\n}
