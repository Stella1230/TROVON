static void save_rx_toggle(struct cppi41_dma_channel *cppi41_channel)\r\n{\r\nu16 csr;\r\nu8 toggle;\r\nif (cppi41_channel->is_tx)\r\nreturn;\r\nif (!is_host_active(cppi41_channel->controller->musb))\r\nreturn;\r\ncsr = musb_readw(cppi41_channel->hw_ep->regs, MUSB_RXCSR);\r\ntoggle = csr & MUSB_RXCSR_H_DATATOGGLE ? 1 : 0;\r\ncppi41_channel->usb_toggle = toggle;\r\n}\r\nstatic void update_rx_toggle(struct cppi41_dma_channel *cppi41_channel)\r\n{\r\nstruct musb_hw_ep *hw_ep = cppi41_channel->hw_ep;\r\nstruct musb *musb = hw_ep->musb;\r\nu16 csr;\r\nu8 toggle;\r\nif (cppi41_channel->is_tx)\r\nreturn;\r\nif (!is_host_active(musb))\r\nreturn;\r\nmusb_ep_select(musb->mregs, hw_ep->epnum);\r\ncsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\r\ntoggle = csr & MUSB_RXCSR_H_DATATOGGLE ? 1 : 0;\r\nif (!toggle && toggle == cppi41_channel->usb_toggle) {\r\ncsr |= MUSB_RXCSR_H_DATATOGGLE | MUSB_RXCSR_H_WR_DATATOGGLE;\r\nmusb_writew(cppi41_channel->hw_ep->regs, MUSB_RXCSR, csr);\r\nmusb_dbg(cppi41_channel->controller->musb,\r\n"Restoring DATA1 toggle.");\r\n}\r\ncppi41_channel->usb_toggle = toggle;\r\n}\r\nstatic bool musb_is_tx_fifo_empty(struct musb_hw_ep *hw_ep)\r\n{\r\nu8 epnum = hw_ep->epnum;\r\nstruct musb *musb = hw_ep->musb;\r\nvoid __iomem *epio = musb->endpoints[epnum].regs;\r\nu16 csr;\r\nmusb_ep_select(musb->mregs, hw_ep->epnum);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nif (csr & MUSB_TXCSR_TXPKTRDY)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void cppi41_trans_done(struct cppi41_dma_channel *cppi41_channel)\r\n{\r\nstruct musb_hw_ep *hw_ep = cppi41_channel->hw_ep;\r\nstruct musb *musb = hw_ep->musb;\r\nvoid __iomem *epio = hw_ep->regs;\r\nu16 csr;\r\nif (!cppi41_channel->prog_len ||\r\n(cppi41_channel->channel.status == MUSB_DMA_STATUS_FREE)) {\r\ncppi41_channel->channel.actual_len =\r\ncppi41_channel->transferred;\r\ncppi41_channel->channel.status = MUSB_DMA_STATUS_FREE;\r\ncppi41_channel->channel.rx_packet_done = true;\r\nif (cppi41_channel->tx_zlp && (cppi41_channel->transferred %\r\ncppi41_channel->packet_sz) == 0) {\r\nmusb_ep_select(musb->mregs, hw_ep->epnum);\r\ncsr = MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n}\r\ntrace_musb_cppi41_done(cppi41_channel);\r\nmusb_dma_completion(musb, hw_ep->epnum, cppi41_channel->is_tx);\r\n} else {\r\nstruct dma_chan *dc = cppi41_channel->dc;\r\nstruct dma_async_tx_descriptor *dma_desc;\r\nenum dma_transfer_direction direction;\r\nu32 remain_bytes;\r\ncppi41_channel->buf_addr += cppi41_channel->packet_sz;\r\nremain_bytes = cppi41_channel->total_len;\r\nremain_bytes -= cppi41_channel->transferred;\r\nremain_bytes = min(remain_bytes, cppi41_channel->packet_sz);\r\ncppi41_channel->prog_len = remain_bytes;\r\ndirection = cppi41_channel->is_tx ? DMA_MEM_TO_DEV\r\n: DMA_DEV_TO_MEM;\r\ndma_desc = dmaengine_prep_slave_single(dc,\r\ncppi41_channel->buf_addr,\r\nremain_bytes,\r\ndirection,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (WARN_ON(!dma_desc))\r\nreturn;\r\ndma_desc->callback = cppi41_dma_callback;\r\ndma_desc->callback_param = &cppi41_channel->channel;\r\ncppi41_channel->cookie = dma_desc->tx_submit(dma_desc);\r\ntrace_musb_cppi41_cont(cppi41_channel);\r\ndma_async_issue_pending(dc);\r\nif (!cppi41_channel->is_tx) {\r\nmusb_ep_select(musb->mregs, hw_ep->epnum);\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\ncsr |= MUSB_RXCSR_H_REQPKT;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\n}\r\n}\r\nstatic enum hrtimer_restart cppi41_recheck_tx_req(struct hrtimer *timer)\r\n{\r\nstruct cppi41_dma_controller *controller;\r\nstruct cppi41_dma_channel *cppi41_channel, *n;\r\nstruct musb *musb;\r\nunsigned long flags;\r\nenum hrtimer_restart ret = HRTIMER_NORESTART;\r\ncontroller = container_of(timer, struct cppi41_dma_controller,\r\nearly_tx);\r\nmusb = controller->musb;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nlist_for_each_entry_safe(cppi41_channel, n, &controller->early_tx_list,\r\ntx_check) {\r\nbool empty;\r\nstruct musb_hw_ep *hw_ep = cppi41_channel->hw_ep;\r\nempty = musb_is_tx_fifo_empty(hw_ep);\r\nif (empty) {\r\nlist_del_init(&cppi41_channel->tx_check);\r\ncppi41_trans_done(cppi41_channel);\r\n}\r\n}\r\nif (!list_empty(&controller->early_tx_list) &&\r\n!hrtimer_is_queued(&controller->early_tx)) {\r\nret = HRTIMER_RESTART;\r\nhrtimer_forward_now(&controller->early_tx,\r\nktime_set(0, 20 * NSEC_PER_USEC));\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void cppi41_dma_callback(void *private_data)\r\n{\r\nstruct dma_channel *channel = private_data;\r\nstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\r\nstruct musb_hw_ep *hw_ep = cppi41_channel->hw_ep;\r\nstruct cppi41_dma_controller *controller;\r\nstruct musb *musb = hw_ep->musb;\r\nunsigned long flags;\r\nstruct dma_tx_state txstate;\r\nu32 transferred;\r\nint is_hs = 0;\r\nbool empty;\r\nspin_lock_irqsave(&musb->lock, flags);\r\ndmaengine_tx_status(cppi41_channel->dc, cppi41_channel->cookie,\r\n&txstate);\r\ntransferred = cppi41_channel->prog_len - txstate.residue;\r\ncppi41_channel->transferred += transferred;\r\ntrace_musb_cppi41_gb(cppi41_channel);\r\nupdate_rx_toggle(cppi41_channel);\r\nif (cppi41_channel->transferred == cppi41_channel->total_len ||\r\ntransferred < cppi41_channel->packet_sz)\r\ncppi41_channel->prog_len = 0;\r\nif (cppi41_channel->is_tx)\r\nempty = musb_is_tx_fifo_empty(hw_ep);\r\nif (!cppi41_channel->is_tx || empty) {\r\ncppi41_trans_done(cppi41_channel);\r\ngoto out;\r\n}\r\ncontroller = cppi41_channel->controller;\r\nif (is_host_active(musb)) {\r\nif (musb->port1_status & USB_PORT_STAT_HIGH_SPEED)\r\nis_hs = 1;\r\n} else {\r\nif (musb->g.speed == USB_SPEED_HIGH)\r\nis_hs = 1;\r\n}\r\nif (is_hs) {\r\nunsigned wait = 25;\r\ndo {\r\nempty = musb_is_tx_fifo_empty(hw_ep);\r\nif (empty) {\r\ncppi41_trans_done(cppi41_channel);\r\ngoto out;\r\n}\r\nwait--;\r\nif (!wait)\r\nbreak;\r\ncpu_relax();\r\n} while (1);\r\n}\r\nlist_add_tail(&cppi41_channel->tx_check,\r\n&controller->early_tx_list);\r\nif (!hrtimer_is_queued(&controller->early_tx)) {\r\nunsigned long usecs = cppi41_channel->total_len / 10;\r\nhrtimer_start_range_ns(&controller->early_tx,\r\nktime_set(0, usecs * NSEC_PER_USEC),\r\n20 * NSEC_PER_USEC,\r\nHRTIMER_MODE_REL);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic u32 update_ep_mode(unsigned ep, unsigned mode, u32 old)\r\n{\r\nunsigned shift;\r\nshift = (ep - 1) * 2;\r\nold &= ~(3 << shift);\r\nold |= mode << shift;\r\nreturn old;\r\n}\r\nstatic void cppi41_set_dma_mode(struct cppi41_dma_channel *cppi41_channel,\r\nunsigned mode)\r\n{\r\nstruct cppi41_dma_controller *controller = cppi41_channel->controller;\r\nu32 port;\r\nu32 new_mode;\r\nu32 old_mode;\r\nif (cppi41_channel->is_tx)\r\nold_mode = controller->tx_mode;\r\nelse\r\nold_mode = controller->rx_mode;\r\nport = cppi41_channel->port_num;\r\nnew_mode = update_ep_mode(port, mode, old_mode);\r\nif (new_mode == old_mode)\r\nreturn;\r\nif (cppi41_channel->is_tx) {\r\ncontroller->tx_mode = new_mode;\r\nmusb_writel(controller->musb->ctrl_base, USB_CTRL_TX_MODE,\r\nnew_mode);\r\n} else {\r\ncontroller->rx_mode = new_mode;\r\nmusb_writel(controller->musb->ctrl_base, USB_CTRL_RX_MODE,\r\nnew_mode);\r\n}\r\n}\r\nstatic void cppi41_set_autoreq_mode(struct cppi41_dma_channel *cppi41_channel,\r\nunsigned mode)\r\n{\r\nstruct cppi41_dma_controller *controller = cppi41_channel->controller;\r\nu32 port;\r\nu32 new_mode;\r\nu32 old_mode;\r\nold_mode = controller->auto_req;\r\nport = cppi41_channel->port_num;\r\nnew_mode = update_ep_mode(port, mode, old_mode);\r\nif (new_mode == old_mode)\r\nreturn;\r\ncontroller->auto_req = new_mode;\r\nmusb_writel(controller->musb->ctrl_base, USB_CTRL_AUTOREQ, new_mode);\r\n}\r\nstatic bool cppi41_configure_channel(struct dma_channel *channel,\r\nu16 packet_sz, u8 mode,\r\ndma_addr_t dma_addr, u32 len)\r\n{\r\nstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\r\nstruct dma_chan *dc = cppi41_channel->dc;\r\nstruct dma_async_tx_descriptor *dma_desc;\r\nenum dma_transfer_direction direction;\r\nstruct musb *musb = cppi41_channel->controller->musb;\r\nunsigned use_gen_rndis = 0;\r\ncppi41_channel->buf_addr = dma_addr;\r\ncppi41_channel->total_len = len;\r\ncppi41_channel->transferred = 0;\r\ncppi41_channel->packet_sz = packet_sz;\r\ncppi41_channel->tx_zlp = (cppi41_channel->is_tx && mode) ? 1 : 0;\r\nif (cppi41_channel->is_tx)\r\nuse_gen_rndis = 1;\r\nif (use_gen_rndis) {\r\nif (len > packet_sz) {\r\nmusb_writel(musb->ctrl_base,\r\nRNDIS_REG(cppi41_channel->port_num), len);\r\ncppi41_set_dma_mode(cppi41_channel,\r\nEP_MODE_DMA_GEN_RNDIS);\r\ncppi41_set_autoreq_mode(cppi41_channel,\r\nEP_MODE_AUTOREQ_ALL_NEOP);\r\n} else {\r\nmusb_writel(musb->ctrl_base,\r\nRNDIS_REG(cppi41_channel->port_num), 0);\r\ncppi41_set_dma_mode(cppi41_channel,\r\nEP_MODE_DMA_TRANSPARENT);\r\ncppi41_set_autoreq_mode(cppi41_channel,\r\nEP_MODE_AUTOREQ_NONE);\r\n}\r\n} else {\r\ncppi41_set_dma_mode(cppi41_channel, EP_MODE_DMA_TRANSPARENT);\r\ncppi41_set_autoreq_mode(cppi41_channel, EP_MODE_AUTOREQ_NONE);\r\nlen = min_t(u32, packet_sz, len);\r\n}\r\ncppi41_channel->prog_len = len;\r\ndirection = cppi41_channel->is_tx ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;\r\ndma_desc = dmaengine_prep_slave_single(dc, dma_addr, len, direction,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!dma_desc)\r\nreturn false;\r\ndma_desc->callback = cppi41_dma_callback;\r\ndma_desc->callback_param = channel;\r\ncppi41_channel->cookie = dma_desc->tx_submit(dma_desc);\r\ncppi41_channel->channel.rx_packet_done = false;\r\ntrace_musb_cppi41_config(cppi41_channel);\r\nsave_rx_toggle(cppi41_channel);\r\ndma_async_issue_pending(dc);\r\nreturn true;\r\n}\r\nstatic struct dma_channel *cppi41_dma_channel_allocate(struct dma_controller *c,\r\nstruct musb_hw_ep *hw_ep, u8 is_tx)\r\n{\r\nstruct cppi41_dma_controller *controller = container_of(c,\r\nstruct cppi41_dma_controller, controller);\r\nstruct cppi41_dma_channel *cppi41_channel = NULL;\r\nu8 ch_num = hw_ep->epnum - 1;\r\nif (ch_num >= MUSB_DMA_NUM_CHANNELS)\r\nreturn NULL;\r\nif (is_tx)\r\ncppi41_channel = &controller->tx_channel[ch_num];\r\nelse\r\ncppi41_channel = &controller->rx_channel[ch_num];\r\nif (!cppi41_channel->dc)\r\nreturn NULL;\r\nif (cppi41_channel->is_allocated)\r\nreturn NULL;\r\ncppi41_channel->hw_ep = hw_ep;\r\ncppi41_channel->is_allocated = 1;\r\ntrace_musb_cppi41_alloc(cppi41_channel);\r\nreturn &cppi41_channel->channel;\r\n}\r\nstatic void cppi41_dma_channel_release(struct dma_channel *channel)\r\n{\r\nstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\r\ntrace_musb_cppi41_free(cppi41_channel);\r\nif (cppi41_channel->is_allocated) {\r\ncppi41_channel->is_allocated = 0;\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nchannel->actual_len = 0;\r\n}\r\n}\r\nstatic int cppi41_dma_channel_program(struct dma_channel *channel,\r\nu16 packet_sz, u8 mode,\r\ndma_addr_t dma_addr, u32 len)\r\n{\r\nint ret;\r\nstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\r\nint hb_mult = 0;\r\nBUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||\r\nchannel->status == MUSB_DMA_STATUS_BUSY);\r\nif (is_host_active(cppi41_channel->controller->musb)) {\r\nif (cppi41_channel->is_tx)\r\nhb_mult = cppi41_channel->hw_ep->out_qh->hb_mult;\r\nelse\r\nhb_mult = cppi41_channel->hw_ep->in_qh->hb_mult;\r\n}\r\nchannel->status = MUSB_DMA_STATUS_BUSY;\r\nchannel->actual_len = 0;\r\nif (hb_mult)\r\npacket_sz = hb_mult * (packet_sz & 0x7FF);\r\nret = cppi41_configure_channel(channel, packet_sz, mode, dma_addr, len);\r\nif (!ret)\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nreturn ret;\r\n}\r\nstatic int cppi41_is_compatible(struct dma_channel *channel, u16 maxpacket,\r\nvoid *buf, u32 length)\r\n{\r\nstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\r\nstruct cppi41_dma_controller *controller = cppi41_channel->controller;\r\nstruct musb *musb = controller->musb;\r\nif (is_host_active(musb)) {\r\nWARN_ON(1);\r\nreturn 1;\r\n}\r\nif (cppi41_channel->hw_ep->ep_in.type != USB_ENDPOINT_XFER_BULK)\r\nreturn 0;\r\nif (cppi41_channel->is_tx)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int cppi41_dma_channel_abort(struct dma_channel *channel)\r\n{\r\nstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\r\nstruct cppi41_dma_controller *controller = cppi41_channel->controller;\r\nstruct musb *musb = controller->musb;\r\nvoid __iomem *epio = cppi41_channel->hw_ep->regs;\r\nint tdbit;\r\nint ret;\r\nunsigned is_tx;\r\nu16 csr;\r\nis_tx = cppi41_channel->is_tx;\r\ntrace_musb_cppi41_abort(cppi41_channel);\r\nif (cppi41_channel->channel.status == MUSB_DMA_STATUS_FREE)\r\nreturn 0;\r\nlist_del_init(&cppi41_channel->tx_check);\r\nif (is_tx) {\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\ncsr &= ~MUSB_TXCSR_DMAENAB;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n} else {\r\ncppi41_set_autoreq_mode(cppi41_channel, EP_MODE_AUTOREQ_NONE);\r\nudelay(250);\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\ncsr &= ~(MUSB_RXCSR_H_REQPKT | MUSB_RXCSR_DMAENAB);\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nudelay(50);\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\nif (csr & MUSB_RXCSR_RXPKTRDY) {\r\ncsr |= MUSB_RXCSR_FLUSHFIFO;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\n}\r\ntdbit = 1 << cppi41_channel->port_num;\r\nif (is_tx)\r\ntdbit <<= 16;\r\ndo {\r\nif (is_tx)\r\nmusb_writel(musb->ctrl_base, USB_TDOWN, tdbit);\r\nret = dmaengine_terminate_all(cppi41_channel->dc);\r\n} while (ret == -EAGAIN);\r\nif (is_tx) {\r\nmusb_writel(musb->ctrl_base, USB_TDOWN, tdbit);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nif (csr & MUSB_TXCSR_TXPKTRDY) {\r\ncsr |= MUSB_TXCSR_FLUSHFIFO;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n}\r\n}\r\ncppi41_channel->channel.status = MUSB_DMA_STATUS_FREE;\r\nreturn 0;\r\n}\r\nstatic void cppi41_release_all_dma_chans(struct cppi41_dma_controller *ctrl)\r\n{\r\nstruct dma_chan *dc;\r\nint i;\r\nfor (i = 0; i < MUSB_DMA_NUM_CHANNELS; i++) {\r\ndc = ctrl->tx_channel[i].dc;\r\nif (dc)\r\ndma_release_channel(dc);\r\ndc = ctrl->rx_channel[i].dc;\r\nif (dc)\r\ndma_release_channel(dc);\r\n}\r\n}\r\nstatic void cppi41_dma_controller_stop(struct cppi41_dma_controller *controller)\r\n{\r\ncppi41_release_all_dma_chans(controller);\r\n}\r\nstatic int cppi41_dma_controller_start(struct cppi41_dma_controller *controller)\r\n{\r\nstruct musb *musb = controller->musb;\r\nstruct device *dev = musb->controller;\r\nstruct device_node *np = dev->parent->of_node;\r\nstruct cppi41_dma_channel *cppi41_channel;\r\nint count;\r\nint i;\r\nint ret;\r\ncount = of_property_count_strings(np, "dma-names");\r\nif (count < 0)\r\nreturn count;\r\nfor (i = 0; i < count; i++) {\r\nstruct dma_chan *dc;\r\nstruct dma_channel *musb_dma;\r\nconst char *str;\r\nunsigned is_tx;\r\nunsigned int port;\r\nret = of_property_read_string_index(np, "dma-names", i, &str);\r\nif (ret)\r\ngoto err;\r\nif (strstarts(str, "tx"))\r\nis_tx = 1;\r\nelse if (strstarts(str, "rx"))\r\nis_tx = 0;\r\nelse {\r\ndev_err(dev, "Wrong dmatype %s\n", str);\r\ngoto err;\r\n}\r\nret = kstrtouint(str + 2, 0, &port);\r\nif (ret)\r\ngoto err;\r\nret = -EINVAL;\r\nif (port > MUSB_DMA_NUM_CHANNELS || !port)\r\ngoto err;\r\nif (is_tx)\r\ncppi41_channel = &controller->tx_channel[port - 1];\r\nelse\r\ncppi41_channel = &controller->rx_channel[port - 1];\r\ncppi41_channel->controller = controller;\r\ncppi41_channel->port_num = port;\r\ncppi41_channel->is_tx = is_tx;\r\nINIT_LIST_HEAD(&cppi41_channel->tx_check);\r\nmusb_dma = &cppi41_channel->channel;\r\nmusb_dma->private_data = cppi41_channel;\r\nmusb_dma->status = MUSB_DMA_STATUS_FREE;\r\nmusb_dma->max_len = SZ_4M;\r\ndc = dma_request_slave_channel(dev->parent, str);\r\nif (!dc) {\r\ndev_err(dev, "Failed to request %s.\n", str);\r\nret = -EPROBE_DEFER;\r\ngoto err;\r\n}\r\ncppi41_channel->dc = dc;\r\n}\r\nreturn 0;\r\nerr:\r\ncppi41_release_all_dma_chans(controller);\r\nreturn ret;\r\n}\r\nvoid cppi41_dma_controller_destroy(struct dma_controller *c)\r\n{\r\nstruct cppi41_dma_controller *controller = container_of(c,\r\nstruct cppi41_dma_controller, controller);\r\nhrtimer_cancel(&controller->early_tx);\r\ncppi41_dma_controller_stop(controller);\r\nkfree(controller);\r\n}\r\nstruct dma_controller *\r\ncppi41_dma_controller_create(struct musb *musb, void __iomem *base)\r\n{\r\nstruct cppi41_dma_controller *controller;\r\nint ret = 0;\r\nif (!musb->controller->parent->of_node) {\r\ndev_err(musb->controller, "Need DT for the DMA engine.\n");\r\nreturn NULL;\r\n}\r\ncontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\r\nif (!controller)\r\ngoto kzalloc_fail;\r\nhrtimer_init(&controller->early_tx, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\ncontroller->early_tx.function = cppi41_recheck_tx_req;\r\nINIT_LIST_HEAD(&controller->early_tx_list);\r\ncontroller->musb = musb;\r\ncontroller->controller.channel_alloc = cppi41_dma_channel_allocate;\r\ncontroller->controller.channel_release = cppi41_dma_channel_release;\r\ncontroller->controller.channel_program = cppi41_dma_channel_program;\r\ncontroller->controller.channel_abort = cppi41_dma_channel_abort;\r\ncontroller->controller.is_compatible = cppi41_is_compatible;\r\nret = cppi41_dma_controller_start(controller);\r\nif (ret)\r\ngoto plat_get_fail;\r\nreturn &controller->controller;\r\nplat_get_fail:\r\nkfree(controller);\r\nkzalloc_fail:\r\nif (ret == -EPROBE_DEFER)\r\nreturn ERR_PTR(ret);\r\nreturn NULL;\r\n}
