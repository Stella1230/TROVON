static int qeth_l3_isxdigit(char *buf)\r\n{\r\nwhile (*buf) {\r\nif (!isxdigit(*buf++))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void qeth_l3_ipaddr4_to_string(const __u8 *addr, char *buf)\r\n{\r\nsprintf(buf, "%pI4", addr);\r\n}\r\nstatic int qeth_l3_string_to_ipaddr4(const char *buf, __u8 *addr)\r\n{\r\nint count = 0, rc = 0;\r\nunsigned int in[4];\r\nchar c;\r\nrc = sscanf(buf, "%u.%u.%u.%u%c",\r\n&in[0], &in[1], &in[2], &in[3], &c);\r\nif (rc != 4 && (rc != 5 || c != '\n'))\r\nreturn -EINVAL;\r\nfor (count = 0; count < 4; count++) {\r\nif (in[count] > 255)\r\nreturn -EINVAL;\r\naddr[count] = in[count];\r\n}\r\nreturn 0;\r\n}\r\nstatic void qeth_l3_ipaddr6_to_string(const __u8 *addr, char *buf)\r\n{\r\nsprintf(buf, "%pI6", addr);\r\n}\r\nstatic int qeth_l3_string_to_ipaddr6(const char *buf, __u8 *addr)\r\n{\r\nconst char *end, *end_tmp, *start;\r\n__u16 *in;\r\nchar num[5];\r\nint num2, cnt, out, found, save_cnt;\r\nunsigned short in_tmp[8] = {0, };\r\ncnt = out = found = save_cnt = num2 = 0;\r\nend = start = buf;\r\nin = (__u16 *) addr;\r\nmemset(in, 0, 16);\r\nwhile (*end) {\r\nend = strchr(start, ':');\r\nif (end == NULL) {\r\nend = buf + strlen(buf);\r\nend_tmp = strchr(start, '\n');\r\nif (end_tmp != NULL)\r\nend = end_tmp;\r\nout = 1;\r\n}\r\nif ((end - start)) {\r\nmemset(num, 0, 5);\r\nif ((end - start) > 4)\r\nreturn -EINVAL;\r\nmemcpy(num, start, end - start);\r\nif (!qeth_l3_isxdigit(num))\r\nreturn -EINVAL;\r\nsscanf(start, "%x", &num2);\r\nif (found)\r\nin_tmp[save_cnt++] = num2;\r\nelse\r\nin[cnt++] = num2;\r\nif (out)\r\nbreak;\r\n} else {\r\nif (found)\r\nreturn -EINVAL;\r\nfound = 1;\r\n}\r\nstart = ++end;\r\n}\r\nif (cnt + save_cnt > 8)\r\nreturn -EINVAL;\r\ncnt = 7;\r\nwhile (save_cnt)\r\nin[cnt--] = in_tmp[--save_cnt];\r\nreturn 0;\r\n}\r\nvoid qeth_l3_ipaddr_to_string(enum qeth_prot_versions proto, const __u8 *addr,\r\nchar *buf)\r\n{\r\nif (proto == QETH_PROT_IPV4)\r\nqeth_l3_ipaddr4_to_string(addr, buf);\r\nelse if (proto == QETH_PROT_IPV6)\r\nqeth_l3_ipaddr6_to_string(addr, buf);\r\n}\r\nint qeth_l3_string_to_ipaddr(const char *buf, enum qeth_prot_versions proto,\r\n__u8 *addr)\r\n{\r\nif (proto == QETH_PROT_IPV4)\r\nreturn qeth_l3_string_to_ipaddr4(buf, addr);\r\nelse if (proto == QETH_PROT_IPV6)\r\nreturn qeth_l3_string_to_ipaddr6(buf, addr);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic void qeth_l3_convert_addr_to_bits(u8 *addr, u8 *bits, int len)\r\n{\r\nint i, j;\r\nu8 octet;\r\nfor (i = 0; i < len; ++i) {\r\noctet = addr[i];\r\nfor (j = 7; j >= 0; --j) {\r\nbits[i*8 + j] = octet & 1;\r\noctet >>= 1;\r\n}\r\n}\r\n}\r\nint qeth_l3_is_addr_covered_by_ipato(struct qeth_card *card,\r\nstruct qeth_ipaddr *addr)\r\n{\r\nstruct qeth_ipato_entry *ipatoe;\r\nu8 addr_bits[128] = {0, };\r\nu8 ipatoe_bits[128] = {0, };\r\nint rc = 0;\r\nif (!card->ipato.enabled)\r\nreturn 0;\r\nqeth_l3_convert_addr_to_bits((u8 *) &addr->u, addr_bits,\r\n(addr->proto == QETH_PROT_IPV4)? 4:16);\r\nlist_for_each_entry(ipatoe, &card->ipato.entries, entry) {\r\nif (addr->proto != ipatoe->proto)\r\ncontinue;\r\nqeth_l3_convert_addr_to_bits(ipatoe->addr, ipatoe_bits,\r\n(ipatoe->proto == QETH_PROT_IPV4) ?\r\n4 : 16);\r\nif (addr->proto == QETH_PROT_IPV4)\r\nrc = !memcmp(addr_bits, ipatoe_bits,\r\nmin(32, ipatoe->mask_bits));\r\nelse\r\nrc = !memcmp(addr_bits, ipatoe_bits,\r\nmin(128, ipatoe->mask_bits));\r\nif (rc)\r\nbreak;\r\n}\r\nif ((addr->proto == QETH_PROT_IPV4) && card->ipato.invert4)\r\nrc = !rc;\r\nelse if ((addr->proto == QETH_PROT_IPV6) && card->ipato.invert6)\r\nrc = !rc;\r\nreturn rc;\r\n}\r\ninline int\r\nqeth_l3_ipaddrs_is_equal(struct qeth_ipaddr *addr1, struct qeth_ipaddr *addr2)\r\n{\r\nreturn addr1->proto == addr2->proto &&\r\n!memcmp(&addr1->u, &addr2->u, sizeof(addr1->u)) &&\r\n!memcmp(&addr1->mac, &addr2->mac, sizeof(addr1->mac));\r\n}\r\nstatic struct qeth_ipaddr *\r\nqeth_l3_ip_from_hash(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)\r\n{\r\nstruct qeth_ipaddr *addr;\r\nif (tmp_addr->is_multicast) {\r\nhash_for_each_possible(card->ip_mc_htable, addr,\r\nhnode, qeth_l3_ipaddr_hash(tmp_addr))\r\nif (qeth_l3_ipaddrs_is_equal(tmp_addr, addr))\r\nreturn addr;\r\n} else {\r\nhash_for_each_possible(card->ip_htable, addr,\r\nhnode, qeth_l3_ipaddr_hash(tmp_addr))\r\nif (qeth_l3_ipaddrs_is_equal(tmp_addr, addr))\r\nreturn addr;\r\n}\r\nreturn NULL;\r\n}\r\nint qeth_l3_delete_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)\r\n{\r\nint rc = 0;\r\nstruct qeth_ipaddr *addr;\r\nQETH_CARD_TEXT(card, 4, "delip");\r\nif (tmp_addr->proto == QETH_PROT_IPV4)\r\nQETH_CARD_HEX(card, 4, &tmp_addr->u.a4.addr, 4);\r\nelse {\r\nQETH_CARD_HEX(card, 4, &tmp_addr->u.a6.addr, 8);\r\nQETH_CARD_HEX(card, 4, ((char *)&tmp_addr->u.a6.addr) + 8, 8);\r\n}\r\naddr = qeth_l3_ip_from_hash(card, tmp_addr);\r\nif (!addr)\r\nreturn -ENOENT;\r\naddr->ref_counter--;\r\nif (addr->type == QETH_IP_TYPE_NORMAL && addr->ref_counter > 0)\r\nreturn rc;\r\nif (addr->in_progress)\r\nreturn -EINPROGRESS;\r\nif (!qeth_card_hw_is_reachable(card)) {\r\naddr->disp_flag = QETH_DISP_ADDR_DELETE;\r\nreturn 0;\r\n}\r\nrc = qeth_l3_deregister_addr_entry(card, addr);\r\nhash_del(&addr->hnode);\r\nkfree(addr);\r\nreturn rc;\r\n}\r\nint qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)\r\n{\r\nint rc = 0;\r\nstruct qeth_ipaddr *addr;\r\nQETH_CARD_TEXT(card, 4, "addip");\r\nif (tmp_addr->proto == QETH_PROT_IPV4)\r\nQETH_CARD_HEX(card, 4, &tmp_addr->u.a4.addr, 4);\r\nelse {\r\nQETH_CARD_HEX(card, 4, &tmp_addr->u.a6.addr, 8);\r\nQETH_CARD_HEX(card, 4, ((char *)&tmp_addr->u.a6.addr) + 8, 8);\r\n}\r\naddr = qeth_l3_ip_from_hash(card, tmp_addr);\r\nif (!addr) {\r\naddr = qeth_l3_get_addr_buffer(tmp_addr->proto);\r\nif (!addr)\r\nreturn -ENOMEM;\r\nmemcpy(addr, tmp_addr, sizeof(struct qeth_ipaddr));\r\naddr->ref_counter = 1;\r\nif (addr->type == QETH_IP_TYPE_NORMAL &&\r\nqeth_l3_is_addr_covered_by_ipato(card, addr)) {\r\nQETH_CARD_TEXT(card, 2, "tkovaddr");\r\naddr->set_flags |= QETH_IPA_SETIP_TAKEOVER_FLAG;\r\n}\r\nhash_add(card->ip_htable, &addr->hnode,\r\nqeth_l3_ipaddr_hash(addr));\r\nif (!qeth_card_hw_is_reachable(card)) {\r\naddr->disp_flag = QETH_DISP_ADDR_ADD;\r\nreturn 0;\r\n}\r\nif (addr->proto == QETH_PROT_IPV4) {\r\naddr->in_progress = 1;\r\nspin_unlock_bh(&card->ip_lock);\r\nrc = qeth_l3_register_addr_entry(card, addr);\r\nspin_lock_bh(&card->ip_lock);\r\naddr->in_progress = 0;\r\n} else\r\nrc = qeth_l3_register_addr_entry(card, addr);\r\nif (!rc || (rc == IPA_RC_DUPLICATE_IP_ADDRESS) ||\r\n(rc == IPA_RC_LAN_OFFLINE)) {\r\naddr->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\r\nif (addr->ref_counter < 1) {\r\nqeth_l3_delete_ip(card, addr);\r\nkfree(addr);\r\n}\r\n} else {\r\nhash_del(&addr->hnode);\r\nkfree(addr);\r\n}\r\n} else {\r\nif (addr->type == QETH_IP_TYPE_NORMAL)\r\naddr->ref_counter++;\r\n}\r\nreturn rc;\r\n}\r\nstruct qeth_ipaddr *qeth_l3_get_addr_buffer(\r\nenum qeth_prot_versions prot)\r\n{\r\nstruct qeth_ipaddr *addr;\r\naddr = kzalloc(sizeof(struct qeth_ipaddr), GFP_ATOMIC);\r\nif (!addr)\r\nreturn NULL;\r\naddr->type = QETH_IP_TYPE_NORMAL;\r\naddr->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\r\naddr->proto = prot;\r\nreturn addr;\r\n}\r\nstatic void qeth_l3_clear_ip_htable(struct qeth_card *card, int recover)\r\n{\r\nstruct qeth_ipaddr *addr;\r\nstruct hlist_node *tmp;\r\nint i;\r\nQETH_CARD_TEXT(card, 4, "clearip");\r\nif (recover && card->options.sniffer)\r\nreturn;\r\nspin_lock_bh(&card->ip_lock);\r\nhash_for_each_safe(card->ip_htable, i, tmp, addr, hnode) {\r\nif (!recover) {\r\nhash_del(&addr->hnode);\r\nkfree(addr);\r\ncontinue;\r\n}\r\naddr->disp_flag = QETH_DISP_ADDR_ADD;\r\n}\r\nspin_unlock_bh(&card->ip_lock);\r\nspin_lock_bh(&card->mclock);\r\nhash_for_each_safe(card->ip_mc_htable, i, tmp, addr, hnode) {\r\nhash_del(&addr->hnode);\r\nkfree(addr);\r\n}\r\nspin_unlock_bh(&card->mclock);\r\n}\r\nstatic void qeth_l3_recover_ip(struct qeth_card *card)\r\n{\r\nstruct qeth_ipaddr *addr;\r\nstruct hlist_node *tmp;\r\nint i;\r\nint rc;\r\nQETH_CARD_TEXT(card, 4, "recovrip");\r\nspin_lock_bh(&card->ip_lock);\r\nhash_for_each_safe(card->ip_htable, i, tmp, addr, hnode) {\r\nif (addr->disp_flag == QETH_DISP_ADDR_DELETE) {\r\nqeth_l3_deregister_addr_entry(card, addr);\r\nhash_del(&addr->hnode);\r\nkfree(addr);\r\n} else if (addr->disp_flag == QETH_DISP_ADDR_ADD) {\r\nif (addr->proto == QETH_PROT_IPV4) {\r\naddr->in_progress = 1;\r\nspin_unlock_bh(&card->ip_lock);\r\nrc = qeth_l3_register_addr_entry(card, addr);\r\nspin_lock_bh(&card->ip_lock);\r\naddr->in_progress = 0;\r\n} else\r\nrc = qeth_l3_register_addr_entry(card, addr);\r\nif (!rc) {\r\naddr->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\r\nif (addr->ref_counter < 1)\r\nqeth_l3_delete_ip(card, addr);\r\n} else {\r\nhash_del(&addr->hnode);\r\nkfree(addr);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&card->ip_lock);\r\n}\r\nstatic int qeth_l3_send_setdelmc(struct qeth_card *card,\r\nstruct qeth_ipaddr *addr, int ipacmd)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 4, "setdelmc");\r\niob = qeth_get_ipacmd_buffer(card, ipacmd, addr->proto);\r\nif (!iob)\r\nreturn -ENOMEM;\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\nmemcpy(&cmd->data.setdelipm.mac, addr->mac, OSA_ADDR_LEN);\r\nif (addr->proto == QETH_PROT_IPV6)\r\nmemcpy(cmd->data.setdelipm.ip6, &addr->u.a6.addr,\r\nsizeof(struct in6_addr));\r\nelse\r\nmemcpy(&cmd->data.setdelipm.ip4, &addr->u.a4.addr, 4);\r\nrc = qeth_send_ipa_cmd(card, iob, NULL, NULL);\r\nreturn rc;\r\n}\r\nstatic void qeth_l3_fill_netmask(u8 *netmask, unsigned int len)\r\n{\r\nint i, j;\r\nfor (i = 0; i < 16; i++) {\r\nj = (len) - (i * 8);\r\nif (j >= 8)\r\nnetmask[i] = 0xff;\r\nelse if (j > 0)\r\nnetmask[i] = (u8)(0xFF00 >> j);\r\nelse\r\nnetmask[i] = 0;\r\n}\r\n}\r\nstatic int qeth_l3_send_setdelip(struct qeth_card *card,\r\nstruct qeth_ipaddr *addr, int ipacmd, unsigned int flags)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\n__u8 netmask[16];\r\nQETH_CARD_TEXT(card, 4, "setdelip");\r\nQETH_CARD_TEXT_(card, 4, "flags%02X", flags);\r\niob = qeth_get_ipacmd_buffer(card, ipacmd, addr->proto);\r\nif (!iob)\r\nreturn -ENOMEM;\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\nif (addr->proto == QETH_PROT_IPV6) {\r\nmemcpy(cmd->data.setdelip6.ip_addr, &addr->u.a6.addr,\r\nsizeof(struct in6_addr));\r\nqeth_l3_fill_netmask(netmask, addr->u.a6.pfxlen);\r\nmemcpy(cmd->data.setdelip6.mask, netmask,\r\nsizeof(struct in6_addr));\r\ncmd->data.setdelip6.flags = flags;\r\n} else {\r\nmemcpy(cmd->data.setdelip4.ip_addr, &addr->u.a4.addr, 4);\r\nmemcpy(cmd->data.setdelip4.mask, &addr->u.a4.mask, 4);\r\ncmd->data.setdelip4.flags = flags;\r\n}\r\nrc = qeth_send_ipa_cmd(card, iob, NULL, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_send_setrouting(struct qeth_card *card,\r\nenum qeth_routing_types type, enum qeth_prot_versions prot)\r\n{\r\nint rc;\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_CARD_TEXT(card, 4, "setroutg");\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETRTG, prot);\r\nif (!iob)\r\nreturn -ENOMEM;\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.setrtg.type = (type);\r\nrc = qeth_send_ipa_cmd(card, iob, NULL, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_correct_routing_type(struct qeth_card *card,\r\nenum qeth_routing_types *type, enum qeth_prot_versions prot)\r\n{\r\nif (card->info.type == QETH_CARD_TYPE_IQD) {\r\nswitch (*type) {\r\ncase NO_ROUTER:\r\ncase PRIMARY_CONNECTOR:\r\ncase SECONDARY_CONNECTOR:\r\ncase MULTICAST_ROUTER:\r\nreturn 0;\r\ndefault:\r\ngoto out_inval;\r\n}\r\n} else {\r\nswitch (*type) {\r\ncase NO_ROUTER:\r\ncase PRIMARY_ROUTER:\r\ncase SECONDARY_ROUTER:\r\nreturn 0;\r\ncase MULTICAST_ROUTER:\r\nif (qeth_is_ipafunc_supported(card, prot,\r\nIPA_OSA_MC_ROUTER))\r\nreturn 0;\r\ndefault:\r\ngoto out_inval;\r\n}\r\n}\r\nout_inval:\r\n*type = NO_ROUTER;\r\nreturn -EINVAL;\r\n}\r\nint qeth_l3_setrouting_v4(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "setrtg4");\r\nrc = qeth_l3_correct_routing_type(card, &card->options.route4.type,\r\nQETH_PROT_IPV4);\r\nif (rc)\r\nreturn rc;\r\nrc = qeth_l3_send_setrouting(card, card->options.route4.type,\r\nQETH_PROT_IPV4);\r\nif (rc) {\r\ncard->options.route4.type = NO_ROUTER;\r\nQETH_DBF_MESSAGE(2, "Error (0x%04x) while setting routing type"\r\n" on %s. Type set to 'no router'.\n", rc,\r\nQETH_CARD_IFNAME(card));\r\n}\r\nreturn rc;\r\n}\r\nint qeth_l3_setrouting_v6(struct qeth_card *card)\r\n{\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 3, "setrtg6");\r\n#ifdef CONFIG_QETH_IPV6\r\nif (!qeth_is_supported(card, IPA_IPV6))\r\nreturn 0;\r\nrc = qeth_l3_correct_routing_type(card, &card->options.route6.type,\r\nQETH_PROT_IPV6);\r\nif (rc)\r\nreturn rc;\r\nrc = qeth_l3_send_setrouting(card, card->options.route6.type,\r\nQETH_PROT_IPV6);\r\nif (rc) {\r\ncard->options.route6.type = NO_ROUTER;\r\nQETH_DBF_MESSAGE(2, "Error (0x%04x) while setting routing type"\r\n" on %s. Type set to 'no router'.\n", rc,\r\nQETH_CARD_IFNAME(card));\r\n}\r\n#endif\r\nreturn rc;\r\n}\r\nstatic void qeth_l3_clear_ipato_list(struct qeth_card *card)\r\n{\r\nstruct qeth_ipato_entry *ipatoe, *tmp;\r\nspin_lock_bh(&card->ip_lock);\r\nlist_for_each_entry_safe(ipatoe, tmp, &card->ipato.entries, entry) {\r\nlist_del(&ipatoe->entry);\r\nkfree(ipatoe);\r\n}\r\nspin_unlock_bh(&card->ip_lock);\r\n}\r\nint qeth_l3_add_ipato_entry(struct qeth_card *card,\r\nstruct qeth_ipato_entry *new)\r\n{\r\nstruct qeth_ipato_entry *ipatoe;\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 2, "addipato");\r\nspin_lock_bh(&card->ip_lock);\r\nlist_for_each_entry(ipatoe, &card->ipato.entries, entry) {\r\nif (ipatoe->proto != new->proto)\r\ncontinue;\r\nif (!memcmp(ipatoe->addr, new->addr,\r\n(ipatoe->proto == QETH_PROT_IPV4)? 4:16) &&\r\n(ipatoe->mask_bits == new->mask_bits)) {\r\nrc = -EEXIST;\r\nbreak;\r\n}\r\n}\r\nif (!rc)\r\nlist_add_tail(&new->entry, &card->ipato.entries);\r\nspin_unlock_bh(&card->ip_lock);\r\nreturn rc;\r\n}\r\nvoid qeth_l3_del_ipato_entry(struct qeth_card *card,\r\nenum qeth_prot_versions proto, u8 *addr, int mask_bits)\r\n{\r\nstruct qeth_ipato_entry *ipatoe, *tmp;\r\nQETH_CARD_TEXT(card, 2, "delipato");\r\nspin_lock_bh(&card->ip_lock);\r\nlist_for_each_entry_safe(ipatoe, tmp, &card->ipato.entries, entry) {\r\nif (ipatoe->proto != proto)\r\ncontinue;\r\nif (!memcmp(ipatoe->addr, addr,\r\n(proto == QETH_PROT_IPV4)? 4:16) &&\r\n(ipatoe->mask_bits == mask_bits)) {\r\nlist_del(&ipatoe->entry);\r\nkfree(ipatoe);\r\n}\r\n}\r\nspin_unlock_bh(&card->ip_lock);\r\n}\r\nint qeth_l3_add_vipa(struct qeth_card *card, enum qeth_prot_versions proto,\r\nconst u8 *addr)\r\n{\r\nstruct qeth_ipaddr *ipaddr;\r\nint rc = 0;\r\nipaddr = qeth_l3_get_addr_buffer(proto);\r\nif (ipaddr) {\r\nif (proto == QETH_PROT_IPV4) {\r\nQETH_CARD_TEXT(card, 2, "addvipa4");\r\nmemcpy(&ipaddr->u.a4.addr, addr, 4);\r\nipaddr->u.a4.mask = 0;\r\n} else if (proto == QETH_PROT_IPV6) {\r\nQETH_CARD_TEXT(card, 2, "addvipa6");\r\nmemcpy(&ipaddr->u.a6.addr, addr, 16);\r\nipaddr->u.a6.pfxlen = 0;\r\n}\r\nipaddr->type = QETH_IP_TYPE_VIPA;\r\nipaddr->set_flags = QETH_IPA_SETIP_VIPA_FLAG;\r\nipaddr->del_flags = QETH_IPA_DELIP_VIPA_FLAG;\r\n} else\r\nreturn -ENOMEM;\r\nspin_lock_bh(&card->ip_lock);\r\nif (qeth_l3_ip_from_hash(card, ipaddr))\r\nrc = -EEXIST;\r\nelse\r\nqeth_l3_add_ip(card, ipaddr);\r\nspin_unlock_bh(&card->ip_lock);\r\nkfree(ipaddr);\r\nreturn rc;\r\n}\r\nvoid qeth_l3_del_vipa(struct qeth_card *card, enum qeth_prot_versions proto,\r\nconst u8 *addr)\r\n{\r\nstruct qeth_ipaddr *ipaddr;\r\nipaddr = qeth_l3_get_addr_buffer(proto);\r\nif (ipaddr) {\r\nif (proto == QETH_PROT_IPV4) {\r\nQETH_CARD_TEXT(card, 2, "delvipa4");\r\nmemcpy(&ipaddr->u.a4.addr, addr, 4);\r\nipaddr->u.a4.mask = 0;\r\n} else if (proto == QETH_PROT_IPV6) {\r\nQETH_CARD_TEXT(card, 2, "delvipa6");\r\nmemcpy(&ipaddr->u.a6.addr, addr, 16);\r\nipaddr->u.a6.pfxlen = 0;\r\n}\r\nipaddr->type = QETH_IP_TYPE_VIPA;\r\n} else\r\nreturn;\r\nspin_lock_bh(&card->ip_lock);\r\nqeth_l3_delete_ip(card, ipaddr);\r\nspin_unlock_bh(&card->ip_lock);\r\nkfree(ipaddr);\r\n}\r\nint qeth_l3_add_rxip(struct qeth_card *card, enum qeth_prot_versions proto,\r\nconst u8 *addr)\r\n{\r\nstruct qeth_ipaddr *ipaddr;\r\nint rc = 0;\r\nipaddr = qeth_l3_get_addr_buffer(proto);\r\nif (ipaddr) {\r\nif (proto == QETH_PROT_IPV4) {\r\nQETH_CARD_TEXT(card, 2, "addrxip4");\r\nmemcpy(&ipaddr->u.a4.addr, addr, 4);\r\nipaddr->u.a4.mask = 0;\r\n} else if (proto == QETH_PROT_IPV6) {\r\nQETH_CARD_TEXT(card, 2, "addrxip6");\r\nmemcpy(&ipaddr->u.a6.addr, addr, 16);\r\nipaddr->u.a6.pfxlen = 0;\r\n}\r\nipaddr->type = QETH_IP_TYPE_RXIP;\r\nipaddr->set_flags = QETH_IPA_SETIP_TAKEOVER_FLAG;\r\nipaddr->del_flags = 0;\r\n} else\r\nreturn -ENOMEM;\r\nspin_lock_bh(&card->ip_lock);\r\nif (qeth_l3_ip_from_hash(card, ipaddr))\r\nrc = -EEXIST;\r\nelse\r\nqeth_l3_add_ip(card, ipaddr);\r\nspin_unlock_bh(&card->ip_lock);\r\nkfree(ipaddr);\r\nreturn rc;\r\n}\r\nvoid qeth_l3_del_rxip(struct qeth_card *card, enum qeth_prot_versions proto,\r\nconst u8 *addr)\r\n{\r\nstruct qeth_ipaddr *ipaddr;\r\nipaddr = qeth_l3_get_addr_buffer(proto);\r\nif (ipaddr) {\r\nif (proto == QETH_PROT_IPV4) {\r\nQETH_CARD_TEXT(card, 2, "addrxip4");\r\nmemcpy(&ipaddr->u.a4.addr, addr, 4);\r\nipaddr->u.a4.mask = 0;\r\n} else if (proto == QETH_PROT_IPV6) {\r\nQETH_CARD_TEXT(card, 2, "addrxip6");\r\nmemcpy(&ipaddr->u.a6.addr, addr, 16);\r\nipaddr->u.a6.pfxlen = 0;\r\n}\r\nipaddr->type = QETH_IP_TYPE_RXIP;\r\n} else\r\nreturn;\r\nspin_lock_bh(&card->ip_lock);\r\nqeth_l3_delete_ip(card, ipaddr);\r\nspin_unlock_bh(&card->ip_lock);\r\nkfree(ipaddr);\r\n}\r\nstatic int qeth_l3_register_addr_entry(struct qeth_card *card,\r\nstruct qeth_ipaddr *addr)\r\n{\r\nchar buf[50];\r\nint rc = 0;\r\nint cnt = 3;\r\nif (addr->proto == QETH_PROT_IPV4) {\r\nQETH_CARD_TEXT(card, 2, "setaddr4");\r\nQETH_CARD_HEX(card, 3, &addr->u.a4.addr, sizeof(int));\r\n} else if (addr->proto == QETH_PROT_IPV6) {\r\nQETH_CARD_TEXT(card, 2, "setaddr6");\r\nQETH_CARD_HEX(card, 3, &addr->u.a6.addr, 8);\r\nQETH_CARD_HEX(card, 3, ((char *)&addr->u.a6.addr) + 8, 8);\r\n} else {\r\nQETH_CARD_TEXT(card, 2, "setaddr?");\r\nQETH_CARD_HEX(card, 3, addr, sizeof(struct qeth_ipaddr));\r\n}\r\ndo {\r\nif (addr->is_multicast)\r\nrc = qeth_l3_send_setdelmc(card, addr, IPA_CMD_SETIPM);\r\nelse\r\nrc = qeth_l3_send_setdelip(card, addr, IPA_CMD_SETIP,\r\naddr->set_flags);\r\nif (rc)\r\nQETH_CARD_TEXT(card, 2, "failed");\r\n} while ((--cnt > 0) && rc);\r\nif (rc) {\r\nQETH_CARD_TEXT(card, 2, "FAILED");\r\nqeth_l3_ipaddr_to_string(addr->proto, (u8 *)&addr->u, buf);\r\ndev_warn(&card->gdev->dev,\r\n"Registering IP address %s failed\n", buf);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_deregister_addr_entry(struct qeth_card *card,\r\nstruct qeth_ipaddr *addr)\r\n{\r\nint rc = 0;\r\nif (addr->proto == QETH_PROT_IPV4) {\r\nQETH_CARD_TEXT(card, 2, "deladdr4");\r\nQETH_CARD_HEX(card, 3, &addr->u.a4.addr, sizeof(int));\r\n} else if (addr->proto == QETH_PROT_IPV6) {\r\nQETH_CARD_TEXT(card, 2, "deladdr6");\r\nQETH_CARD_HEX(card, 3, &addr->u.a6.addr, 8);\r\nQETH_CARD_HEX(card, 3, ((char *)&addr->u.a6.addr) + 8, 8);\r\n} else {\r\nQETH_CARD_TEXT(card, 2, "deladdr?");\r\nQETH_CARD_HEX(card, 3, addr, sizeof(struct qeth_ipaddr));\r\n}\r\nif (addr->is_multicast)\r\nrc = qeth_l3_send_setdelmc(card, addr, IPA_CMD_DELIPM);\r\nelse\r\nrc = qeth_l3_send_setdelip(card, addr, IPA_CMD_DELIP,\r\naddr->del_flags);\r\nif (rc)\r\nQETH_CARD_TEXT(card, 2, "failed");\r\nreturn rc;\r\n}\r\nstatic inline u8 qeth_l3_get_qeth_hdr_flags4(int cast_type)\r\n{\r\nif (cast_type == RTN_MULTICAST)\r\nreturn QETH_CAST_MULTICAST;\r\nif (cast_type == RTN_BROADCAST)\r\nreturn QETH_CAST_BROADCAST;\r\nreturn QETH_CAST_UNICAST;\r\n}\r\nstatic inline u8 qeth_l3_get_qeth_hdr_flags6(int cast_type)\r\n{\r\nu8 ct = QETH_HDR_PASSTHRU | QETH_HDR_IPV6;\r\nif (cast_type == RTN_MULTICAST)\r\nreturn ct | QETH_CAST_MULTICAST;\r\nif (cast_type == RTN_ANYCAST)\r\nreturn ct | QETH_CAST_ANYCAST;\r\nif (cast_type == RTN_BROADCAST)\r\nreturn ct | QETH_CAST_BROADCAST;\r\nreturn ct | QETH_CAST_UNICAST;\r\n}\r\nstatic int qeth_l3_setadapter_parms(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_DBF_TEXT(SETUP, 2, "setadprm");\r\nif (!qeth_is_supported(card, IPA_SETADAPTERPARMS)) {\r\ndev_info(&card->gdev->dev,\r\n"set adapter parameters not supported.\n");\r\nQETH_DBF_TEXT(SETUP, 2, " notsupp");\r\nreturn 0;\r\n}\r\nrc = qeth_query_setadapterparms(card);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "%s couldn't set adapter parameters: "\r\n"0x%x\n", dev_name(&card->gdev->dev), rc);\r\nreturn rc;\r\n}\r\nif (qeth_adp_supported(card, IPA_SETADP_ALTER_MAC_ADDRESS)) {\r\nrc = qeth_setadpparms_change_macaddr(card);\r\nif (rc)\r\ndev_warn(&card->gdev->dev, "Reading the adapter MAC"\r\n" address failed\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_send_simple_setassparms_ipv6(struct qeth_card *card,\r\nenum qeth_ipa_funcs ipa_func, __u16 cmd_code)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_CARD_TEXT(card, 4, "simassp6");\r\niob = qeth_get_setassparms_cmd(card, ipa_func, cmd_code,\r\n0, QETH_PROT_IPV6);\r\nif (!iob)\r\nreturn -ENOMEM;\r\nrc = qeth_send_setassparms(card, iob, 0, 0,\r\nqeth_setassparms_cb, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_start_ipa_arp_processing(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "ipaarp");\r\nif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\r\ndev_info(&card->gdev->dev,\r\n"ARP processing not supported on %s!\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn 0;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_ARP_PROCESSING,\r\nIPA_CMD_ASS_START, 0);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev,\r\n"Starting ARP processing support for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_start_ipa_ip_fragmentation(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "ipaipfrg");\r\nif (!qeth_is_supported(card, IPA_IP_FRAGMENTATION)) {\r\ndev_info(&card->gdev->dev,\r\n"Hardware IP fragmentation not supported on %s\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_IP_FRAGMENTATION,\r\nIPA_CMD_ASS_START, 0);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev,\r\n"Starting IP fragmentation support for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\n} else\r\ndev_info(&card->gdev->dev,\r\n"Hardware IP fragmentation enabled \n");\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_start_ipa_source_mac(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "stsrcmac");\r\nif (!qeth_is_supported(card, IPA_SOURCE_MAC)) {\r\ndev_info(&card->gdev->dev,\r\n"Inbound source MAC-address not supported on %s\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_SOURCE_MAC,\r\nIPA_CMD_ASS_START, 0);\r\nif (rc)\r\ndev_warn(&card->gdev->dev,\r\n"Starting source MAC-address support for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_start_ipa_vlan(struct qeth_card *card)\r\n{\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 3, "strtvlan");\r\nif (!qeth_is_supported(card, IPA_FULL_VLAN)) {\r\ndev_info(&card->gdev->dev,\r\n"VLAN not supported on %s\n", QETH_CARD_IFNAME(card));\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_VLAN_PRIO,\r\nIPA_CMD_ASS_START, 0);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev,\r\n"Starting VLAN support for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\n} else {\r\ndev_info(&card->gdev->dev, "VLAN enabled\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_start_ipa_multicast(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "stmcast");\r\nif (!qeth_is_supported(card, IPA_MULTICASTING)) {\r\ndev_info(&card->gdev->dev,\r\n"Multicast not supported on %s\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_MULTICASTING,\r\nIPA_CMD_ASS_START, 0);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev,\r\n"Starting multicast support for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\n} else {\r\ndev_info(&card->gdev->dev, "Multicast enabled\n");\r\ncard->dev->flags |= IFF_MULTICAST;\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_softsetup_ipv6(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "softipv6");\r\nif (card->info.type == QETH_CARD_TYPE_IQD)\r\ngoto out;\r\nrc = qeth_query_ipassists(card, QETH_PROT_IPV6);\r\nif (rc) {\r\ndev_err(&card->gdev->dev,\r\n"Activating IPv6 support for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn rc;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_IPV6,\r\nIPA_CMD_ASS_START, 3);\r\nif (rc) {\r\ndev_err(&card->gdev->dev,\r\n"Activating IPv6 support for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn rc;\r\n}\r\nrc = qeth_l3_send_simple_setassparms_ipv6(card, IPA_IPV6,\r\nIPA_CMD_ASS_START);\r\nif (rc) {\r\ndev_err(&card->gdev->dev,\r\n"Activating IPv6 support for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn rc;\r\n}\r\nrc = qeth_l3_send_simple_setassparms_ipv6(card, IPA_PASSTHRU,\r\nIPA_CMD_ASS_START);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev,\r\n"Enabling the passthrough mode for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\nreturn rc;\r\n}\r\nout:\r\ndev_info(&card->gdev->dev, "IPV6 enabled\n");\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_start_ipa_ipv6(struct qeth_card *card)\r\n{\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 3, "strtipv6");\r\nif (!qeth_is_supported(card, IPA_IPV6)) {\r\ndev_info(&card->gdev->dev,\r\n"IPv6 not supported on %s\n", QETH_CARD_IFNAME(card));\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_QETH_IPV6\r\nrc = qeth_l3_softsetup_ipv6(card);\r\n#endif\r\nreturn rc ;\r\n}\r\nstatic int qeth_l3_start_ipa_broadcast(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "stbrdcst");\r\ncard->info.broadcast_capable = 0;\r\nif (!qeth_is_supported(card, IPA_FILTERING)) {\r\ndev_info(&card->gdev->dev,\r\n"Broadcast not supported on %s\n",\r\nQETH_CARD_IFNAME(card));\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_FILTERING,\r\nIPA_CMD_ASS_START, 0);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev, "Enabling broadcast filtering for "\r\n"%s failed\n", QETH_CARD_IFNAME(card));\r\ngoto out;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_FILTERING,\r\nIPA_CMD_ASS_CONFIGURE, 1);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev,\r\n"Setting up broadcast filtering for %s failed\n",\r\nQETH_CARD_IFNAME(card));\r\ngoto out;\r\n}\r\ncard->info.broadcast_capable = QETH_BROADCAST_WITH_ECHO;\r\ndev_info(&card->gdev->dev, "Broadcast enabled\n");\r\nrc = qeth_send_simple_setassparms(card, IPA_FILTERING,\r\nIPA_CMD_ASS_ENABLE, 1);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev, "Setting up broadcast echo "\r\n"filtering for %s failed\n", QETH_CARD_IFNAME(card));\r\ngoto out;\r\n}\r\ncard->info.broadcast_capable = QETH_BROADCAST_WITHOUT_ECHO;\r\nout:\r\nif (card->info.broadcast_capable)\r\ncard->dev->flags |= IFF_BROADCAST;\r\nelse\r\ncard->dev->flags &= ~IFF_BROADCAST;\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_start_ipassists(struct qeth_card *card)\r\n{\r\nQETH_CARD_TEXT(card, 3, "strtipas");\r\nif (qeth_set_access_ctrl_online(card, 0))\r\nreturn -EIO;\r\nqeth_l3_start_ipa_arp_processing(card);\r\nqeth_l3_start_ipa_ip_fragmentation(card);\r\nqeth_l3_start_ipa_source_mac(card);\r\nqeth_l3_start_ipa_vlan(card);\r\nqeth_l3_start_ipa_multicast(card);\r\nqeth_l3_start_ipa_ipv6(card);\r\nqeth_l3_start_ipa_broadcast(card);\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_iqd_read_initial_mac_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nif (cmd->hdr.return_code == 0)\r\nmemcpy(card->dev->dev_addr,\r\ncmd->data.create_destroy_addr.unique_id, ETH_ALEN);\r\nelse\r\neth_random_addr(card->dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_iqd_read_initial_mac(struct qeth_card *card)\r\n{\r\nint rc = 0;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_DBF_TEXT(SETUP, 2, "hsrmac");\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_CREATE_ADDR,\r\nQETH_PROT_IPV6);\r\nif (!iob)\r\nreturn -ENOMEM;\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\n*((__u16 *) &cmd->data.create_destroy_addr.unique_id[6]) =\r\ncard->info.unique_id;\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_l3_iqd_read_initial_mac_cb,\r\nNULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_get_unique_id_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nif (cmd->hdr.return_code == 0)\r\ncard->info.unique_id = *((__u16 *)\r\n&cmd->data.create_destroy_addr.unique_id[6]);\r\nelse {\r\ncard->info.unique_id = UNIQUE_ID_IF_CREATE_ADDR_FAILED |\r\nUNIQUE_ID_NOT_BY_CARD;\r\ndev_warn(&card->gdev->dev, "The network adapter failed to "\r\n"generate a unique ID\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_get_unique_id(struct qeth_card *card)\r\n{\r\nint rc = 0;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_DBF_TEXT(SETUP, 2, "guniqeid");\r\nif (!qeth_is_supported(card, IPA_IPV6)) {\r\ncard->info.unique_id = UNIQUE_ID_IF_CREATE_ADDR_FAILED |\r\nUNIQUE_ID_NOT_BY_CARD;\r\nreturn 0;\r\n}\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_CREATE_ADDR,\r\nQETH_PROT_IPV6);\r\nif (!iob)\r\nreturn -ENOMEM;\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\n*((__u16 *) &cmd->data.create_destroy_addr.unique_id[6]) =\r\ncard->info.unique_id;\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_l3_get_unique_id_cb, NULL);\r\nreturn rc;\r\n}\r\nstatic int\r\nqeth_diags_trace_cb(struct qeth_card *card, struct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\n__u16 rc;\r\nQETH_DBF_TEXT(SETUP, 2, "diastrcb");\r\ncmd = (struct qeth_ipa_cmd *)data;\r\nrc = cmd->hdr.return_code;\r\nif (rc)\r\nQETH_CARD_TEXT_(card, 2, "dxter%x", rc);\r\nswitch (cmd->data.diagass.action) {\r\ncase QETH_DIAGS_CMD_TRACE_QUERY:\r\nbreak;\r\ncase QETH_DIAGS_CMD_TRACE_DISABLE:\r\nswitch (rc) {\r\ncase 0:\r\ncase IPA_RC_INVALID_SUBCMD:\r\ncard->info.promisc_mode = SET_PROMISC_MODE_OFF;\r\ndev_info(&card->gdev->dev, "The HiperSockets network "\r\n"traffic analyzer is deactivated\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase QETH_DIAGS_CMD_TRACE_ENABLE:\r\nswitch (rc) {\r\ncase 0:\r\ncard->info.promisc_mode = SET_PROMISC_MODE_ON;\r\ndev_info(&card->gdev->dev, "The HiperSockets network "\r\n"traffic analyzer is activated\n");\r\nbreak;\r\ncase IPA_RC_HARDWARE_AUTH_ERROR:\r\ndev_warn(&card->gdev->dev, "The device is not "\r\n"authorized to run as a HiperSockets network "\r\n"traffic analyzer\n");\r\nbreak;\r\ncase IPA_RC_TRACE_ALREADY_ACTIVE:\r\ndev_warn(&card->gdev->dev, "A HiperSockets "\r\n"network traffic analyzer is already "\r\n"active in the HiperSockets LAN\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nQETH_DBF_MESSAGE(2, "Unknown sniffer action (0x%04x) on %s\n",\r\ncmd->data.diagass.action, QETH_CARD_IFNAME(card));\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqeth_diags_trace(struct qeth_card *card, enum qeth_diags_trace_cmds diags_cmd)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_DBF_TEXT(SETUP, 2, "diagtrac");\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_SET_DIAG_ASS, 0);\r\nif (!iob)\r\nreturn -ENOMEM;\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.diagass.subcmd_len = 16;\r\ncmd->data.diagass.subcmd = QETH_DIAGS_CMD_TRACE;\r\ncmd->data.diagass.type = QETH_DIAGS_TYPE_HIPERSOCKET;\r\ncmd->data.diagass.action = diags_cmd;\r\nreturn qeth_send_ipa_cmd(card, iob, qeth_diags_trace_cb, NULL);\r\n}\r\nstatic void qeth_l3_get_mac_for_ipm(__u32 ipm, char *mac)\r\n{\r\nip_eth_mc_map(ipm, mac);\r\n}\r\nstatic void qeth_l3_mark_all_mc_to_be_deleted(struct qeth_card *card)\r\n{\r\nstruct qeth_ipaddr *addr;\r\nint i;\r\nhash_for_each(card->ip_mc_htable, i, addr, hnode)\r\naddr->disp_flag = QETH_DISP_ADDR_DELETE;\r\n}\r\nstatic void qeth_l3_add_all_new_mc(struct qeth_card *card)\r\n{\r\nstruct qeth_ipaddr *addr;\r\nstruct hlist_node *tmp;\r\nint i;\r\nint rc;\r\nhash_for_each_safe(card->ip_mc_htable, i, tmp, addr, hnode) {\r\nif (addr->disp_flag == QETH_DISP_ADDR_ADD) {\r\nrc = qeth_l3_register_addr_entry(card, addr);\r\nif (!rc || (rc == IPA_RC_LAN_OFFLINE))\r\naddr->ref_counter = 1;\r\nelse {\r\nhash_del(&addr->hnode);\r\nkfree(addr);\r\n}\r\n}\r\n}\r\n}\r\nstatic void qeth_l3_delete_nonused_mc(struct qeth_card *card)\r\n{\r\nstruct qeth_ipaddr *addr;\r\nstruct hlist_node *tmp;\r\nint i;\r\nint rc;\r\nhash_for_each_safe(card->ip_mc_htable, i, tmp, addr, hnode) {\r\nif (addr->disp_flag == QETH_DISP_ADDR_DELETE) {\r\nrc = qeth_l3_deregister_addr_entry(card, addr);\r\nif (!rc || (rc == IPA_RC_MC_ADDR_NOT_FOUND)) {\r\nhash_del(&addr->hnode);\r\nkfree(addr);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nqeth_l3_add_mc_to_hash(struct qeth_card *card, struct in_device *in4_dev)\r\n{\r\nstruct ip_mc_list *im4;\r\nstruct qeth_ipaddr *tmp, *ipm;\r\nchar buf[MAX_ADDR_LEN];\r\nQETH_CARD_TEXT(card, 4, "addmc");\r\ntmp = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);\r\nif (!tmp)\r\nreturn;\r\nfor (im4 = rcu_dereference(in4_dev->mc_list); im4 != NULL;\r\nim4 = rcu_dereference(im4->next_rcu)) {\r\nqeth_l3_get_mac_for_ipm(im4->multiaddr, buf);\r\ntmp->u.a4.addr = im4->multiaddr;\r\nmemcpy(tmp->mac, buf, sizeof(tmp->mac));\r\nipm = qeth_l3_ip_from_hash(card, tmp);\r\nif (ipm) {\r\nipm->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\r\n} else {\r\nipm = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);\r\nif (!ipm)\r\ncontinue;\r\nmemcpy(ipm->mac, buf, sizeof(tmp->mac));\r\nipm->u.a4.addr = im4->multiaddr;\r\nipm->is_multicast = 1;\r\nipm->disp_flag = QETH_DISP_ADDR_ADD;\r\nhash_add(card->ip_mc_htable,\r\n&ipm->hnode, qeth_l3_ipaddr_hash(ipm));\r\n}\r\n}\r\nkfree(tmp);\r\n}\r\nstatic void qeth_l3_add_vlan_mc(struct qeth_card *card)\r\n{\r\nstruct in_device *in_dev;\r\nu16 vid;\r\nQETH_CARD_TEXT(card, 4, "addmcvl");\r\nif (!qeth_is_supported(card, IPA_FULL_VLAN))\r\nreturn;\r\nfor_each_set_bit(vid, card->active_vlans, VLAN_N_VID) {\r\nstruct net_device *netdev;\r\nnetdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q),\r\nvid);\r\nif (netdev == NULL ||\r\n!(netdev->flags & IFF_UP))\r\ncontinue;\r\nin_dev = __in_dev_get_rcu(netdev);\r\nif (!in_dev)\r\ncontinue;\r\nqeth_l3_add_mc_to_hash(card, in_dev);\r\n}\r\n}\r\nstatic void qeth_l3_add_multicast_ipv4(struct qeth_card *card)\r\n{\r\nstruct in_device *in4_dev;\r\nQETH_CARD_TEXT(card, 4, "chkmcv4");\r\nrcu_read_lock();\r\nin4_dev = __in_dev_get_rcu(card->dev);\r\nif (in4_dev == NULL)\r\ngoto unlock;\r\nqeth_l3_add_mc_to_hash(card, in4_dev);\r\nqeth_l3_add_vlan_mc(card);\r\nunlock:\r\nrcu_read_unlock();\r\n}\r\nstatic void\r\nqeth_l3_add_mc6_to_hash(struct qeth_card *card, struct inet6_dev *in6_dev)\r\n{\r\nstruct qeth_ipaddr *ipm;\r\nstruct ifmcaddr6 *im6;\r\nstruct qeth_ipaddr *tmp;\r\nchar buf[MAX_ADDR_LEN];\r\nQETH_CARD_TEXT(card, 4, "addmc6");\r\ntmp = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);\r\nif (!tmp)\r\nreturn;\r\nfor (im6 = in6_dev->mc_list; im6 != NULL; im6 = im6->next) {\r\nndisc_mc_map(&im6->mca_addr, buf, in6_dev->dev, 0);\r\nmemcpy(tmp->mac, buf, sizeof(tmp->mac));\r\nmemcpy(&tmp->u.a6.addr, &im6->mca_addr.s6_addr,\r\nsizeof(struct in6_addr));\r\ntmp->is_multicast = 1;\r\nipm = qeth_l3_ip_from_hash(card, tmp);\r\nif (ipm) {\r\nipm->disp_flag = QETH_DISP_ADDR_DO_NOTHING;\r\ncontinue;\r\n}\r\nipm = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);\r\nif (!ipm)\r\ncontinue;\r\nmemcpy(ipm->mac, buf, OSA_ADDR_LEN);\r\nmemcpy(&ipm->u.a6.addr, &im6->mca_addr.s6_addr,\r\nsizeof(struct in6_addr));\r\nipm->is_multicast = 1;\r\nipm->disp_flag = QETH_DISP_ADDR_ADD;\r\nhash_add(card->ip_mc_htable,\r\n&ipm->hnode, qeth_l3_ipaddr_hash(ipm));\r\n}\r\nkfree(tmp);\r\n}\r\nstatic void qeth_l3_add_vlan_mc6(struct qeth_card *card)\r\n{\r\nstruct inet6_dev *in_dev;\r\nu16 vid;\r\nQETH_CARD_TEXT(card, 4, "admc6vl");\r\nif (!qeth_is_supported(card, IPA_FULL_VLAN))\r\nreturn;\r\nfor_each_set_bit(vid, card->active_vlans, VLAN_N_VID) {\r\nstruct net_device *netdev;\r\nnetdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q),\r\nvid);\r\nif (netdev == NULL ||\r\n!(netdev->flags & IFF_UP))\r\ncontinue;\r\nin_dev = in6_dev_get(netdev);\r\nif (!in_dev)\r\ncontinue;\r\nread_lock_bh(&in_dev->lock);\r\nqeth_l3_add_mc6_to_hash(card, in_dev);\r\nread_unlock_bh(&in_dev->lock);\r\nin6_dev_put(in_dev);\r\n}\r\n}\r\nstatic void qeth_l3_add_multicast_ipv6(struct qeth_card *card)\r\n{\r\nstruct inet6_dev *in6_dev;\r\nQETH_CARD_TEXT(card, 4, "chkmcv6");\r\nif (!qeth_is_supported(card, IPA_IPV6))\r\nreturn ;\r\nin6_dev = in6_dev_get(card->dev);\r\nif (!in6_dev)\r\nreturn;\r\nrcu_read_lock();\r\nread_lock_bh(&in6_dev->lock);\r\nqeth_l3_add_mc6_to_hash(card, in6_dev);\r\nqeth_l3_add_vlan_mc6(card);\r\nread_unlock_bh(&in6_dev->lock);\r\nrcu_read_unlock();\r\nin6_dev_put(in6_dev);\r\n}\r\nstatic void qeth_l3_free_vlan_addresses4(struct qeth_card *card,\r\nunsigned short vid)\r\n{\r\nstruct in_device *in_dev;\r\nstruct in_ifaddr *ifa;\r\nstruct qeth_ipaddr *addr;\r\nstruct net_device *netdev;\r\nQETH_CARD_TEXT(card, 4, "frvaddr4");\r\nnetdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q), vid);\r\nif (!netdev)\r\nreturn;\r\nin_dev = in_dev_get(netdev);\r\nif (!in_dev)\r\nreturn;\r\naddr = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);\r\nif (!addr)\r\nreturn;\r\nspin_lock_bh(&card->ip_lock);\r\nfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\r\naddr->u.a4.addr = ifa->ifa_address;\r\naddr->u.a4.mask = ifa->ifa_mask;\r\naddr->type = QETH_IP_TYPE_NORMAL;\r\nqeth_l3_delete_ip(card, addr);\r\n}\r\nspin_unlock_bh(&card->ip_lock);\r\nkfree(addr);\r\nin_dev_put(in_dev);\r\n}\r\nstatic void qeth_l3_free_vlan_addresses6(struct qeth_card *card,\r\nunsigned short vid)\r\n{\r\n#ifdef CONFIG_QETH_IPV6\r\nstruct inet6_dev *in6_dev;\r\nstruct inet6_ifaddr *ifa;\r\nstruct qeth_ipaddr *addr;\r\nstruct net_device *netdev;\r\nQETH_CARD_TEXT(card, 4, "frvaddr6");\r\nnetdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q), vid);\r\nif (!netdev)\r\nreturn;\r\nin6_dev = in6_dev_get(netdev);\r\nif (!in6_dev)\r\nreturn;\r\naddr = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);\r\nif (!addr)\r\nreturn;\r\nspin_lock_bh(&card->ip_lock);\r\nlist_for_each_entry(ifa, &in6_dev->addr_list, if_list) {\r\nmemcpy(&addr->u.a6.addr, &ifa->addr,\r\nsizeof(struct in6_addr));\r\naddr->u.a6.pfxlen = ifa->prefix_len;\r\naddr->type = QETH_IP_TYPE_NORMAL;\r\nqeth_l3_delete_ip(card, addr);\r\n}\r\nspin_unlock_bh(&card->ip_lock);\r\nkfree(addr);\r\nin6_dev_put(in6_dev);\r\n#endif\r\n}\r\nstatic void qeth_l3_free_vlan_addresses(struct qeth_card *card,\r\nunsigned short vid)\r\n{\r\nrcu_read_lock();\r\nqeth_l3_free_vlan_addresses4(card, vid);\r\nqeth_l3_free_vlan_addresses6(card, vid);\r\nrcu_read_unlock();\r\n}\r\nstatic int qeth_l3_vlan_rx_add_vid(struct net_device *dev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nset_bit(vid, card->active_vlans);\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_vlan_rx_kill_vid(struct net_device *dev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nQETH_CARD_TEXT_(card, 4, "kid:%d", vid);\r\nif (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {\r\nQETH_CARD_TEXT(card, 3, "kidREC");\r\nreturn 0;\r\n}\r\nqeth_l3_free_vlan_addresses(card, vid);\r\nclear_bit(vid, card->active_vlans);\r\nqeth_l3_set_multicast_list(card->dev);\r\nreturn 0;\r\n}\r\nstatic inline int qeth_l3_rebuild_skb(struct qeth_card *card,\r\nstruct sk_buff *skb, struct qeth_hdr *hdr,\r\nunsigned short *vlan_id)\r\n{\r\n__be16 prot;\r\nstruct iphdr *ip_hdr;\r\nunsigned char tg_addr[MAX_ADDR_LEN];\r\nint is_vlan = 0;\r\nif (!(hdr->hdr.l3.flags & QETH_HDR_PASSTHRU)) {\r\nprot = htons((hdr->hdr.l3.flags & QETH_HDR_IPV6)? ETH_P_IPV6 :\r\nETH_P_IP);\r\nswitch (hdr->hdr.l3.flags & QETH_HDR_CAST_MASK) {\r\ncase QETH_CAST_MULTICAST:\r\nswitch (prot) {\r\n#ifdef CONFIG_QETH_IPV6\r\ncase __constant_htons(ETH_P_IPV6):\r\nndisc_mc_map((struct in6_addr *)\r\nskb->data + 24,\r\ntg_addr, card->dev, 0);\r\nbreak;\r\n#endif\r\ncase __constant_htons(ETH_P_IP):\r\nip_hdr = (struct iphdr *)skb->data;\r\nip_eth_mc_map(ip_hdr->daddr, tg_addr);\r\nbreak;\r\ndefault:\r\nmemcpy(tg_addr, card->dev->broadcast,\r\ncard->dev->addr_len);\r\n}\r\ncard->stats.multicast++;\r\nskb->pkt_type = PACKET_MULTICAST;\r\nbreak;\r\ncase QETH_CAST_BROADCAST:\r\nmemcpy(tg_addr, card->dev->broadcast,\r\ncard->dev->addr_len);\r\ncard->stats.multicast++;\r\nskb->pkt_type = PACKET_BROADCAST;\r\nbreak;\r\ncase QETH_CAST_UNICAST:\r\ncase QETH_CAST_ANYCAST:\r\ncase QETH_CAST_NOCAST:\r\ndefault:\r\nif (card->options.sniffer)\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nelse\r\nskb->pkt_type = PACKET_HOST;\r\nmemcpy(tg_addr, card->dev->dev_addr,\r\ncard->dev->addr_len);\r\n}\r\nif (hdr->hdr.l3.ext_flags & QETH_HDR_EXT_SRC_MAC_ADDR)\r\ncard->dev->header_ops->create(skb, card->dev, prot,\r\ntg_addr, &hdr->hdr.l3.dest_addr[2],\r\ncard->dev->addr_len);\r\nelse\r\ncard->dev->header_ops->create(skb, card->dev, prot,\r\ntg_addr, "FAKELL", card->dev->addr_len);\r\n}\r\nskb->protocol = eth_type_trans(skb, card->dev);\r\nif (hdr->hdr.l3.ext_flags &\r\n(QETH_HDR_EXT_VLAN_FRAME | QETH_HDR_EXT_INCLUDE_VLAN_TAG)) {\r\n*vlan_id = (hdr->hdr.l3.ext_flags & QETH_HDR_EXT_VLAN_FRAME) ?\r\nhdr->hdr.l3.vlan_id : *((u16 *)&hdr->hdr.l3.dest_addr[12]);\r\nis_vlan = 1;\r\n}\r\nif (card->dev->features & NETIF_F_RXCSUM) {\r\nif ((hdr->hdr.l3.ext_flags &\r\n(QETH_HDR_EXT_CSUM_HDR_REQ |\r\nQETH_HDR_EXT_CSUM_TRANSP_REQ)) ==\r\n(QETH_HDR_EXT_CSUM_HDR_REQ |\r\nQETH_HDR_EXT_CSUM_TRANSP_REQ))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb->ip_summed = CHECKSUM_NONE;\r\n} else\r\nskb->ip_summed = CHECKSUM_NONE;\r\nreturn is_vlan;\r\n}\r\nstatic int qeth_l3_process_inbound_buffer(struct qeth_card *card,\r\nint budget, int *done)\r\n{\r\nint work_done = 0;\r\nstruct sk_buff *skb;\r\nstruct qeth_hdr *hdr;\r\n__u16 vlan_tag = 0;\r\nint is_vlan;\r\nunsigned int len;\r\n__u16 magic;\r\n*done = 0;\r\nWARN_ON_ONCE(!budget);\r\nwhile (budget) {\r\nskb = qeth_core_get_next_skb(card,\r\n&card->qdio.in_q->bufs[card->rx.b_index],\r\n&card->rx.b_element, &card->rx.e_offset, &hdr);\r\nif (!skb) {\r\n*done = 1;\r\nbreak;\r\n}\r\nskb->dev = card->dev;\r\nswitch (hdr->hdr.l3.id) {\r\ncase QETH_HEADER_TYPE_LAYER3:\r\nmagic = *(__u16 *)skb->data;\r\nif ((card->info.type == QETH_CARD_TYPE_IQD) &&\r\n(magic == ETH_P_AF_IUCV)) {\r\nskb->protocol = ETH_P_AF_IUCV;\r\nskb->pkt_type = PACKET_HOST;\r\nskb->mac_header = NET_SKB_PAD;\r\nskb->dev = card->dev;\r\nlen = skb->len;\r\ncard->dev->header_ops->create(skb, card->dev, 0,\r\ncard->dev->dev_addr, "FAKELL",\r\ncard->dev->addr_len);\r\nnetif_receive_skb(skb);\r\n} else {\r\nis_vlan = qeth_l3_rebuild_skb(card, skb, hdr,\r\n&vlan_tag);\r\nlen = skb->len;\r\nif (is_vlan && !card->options.sniffer)\r\n__vlan_hwaccel_put_tag(skb,\r\nhtons(ETH_P_8021Q), vlan_tag);\r\nnapi_gro_receive(&card->napi, skb);\r\n}\r\nbreak;\r\ncase QETH_HEADER_TYPE_LAYER2:\r\nskb->pkt_type = PACKET_HOST;\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nlen = skb->len;\r\nnetif_receive_skb(skb);\r\nbreak;\r\ndefault:\r\ndev_kfree_skb_any(skb);\r\nQETH_CARD_TEXT(card, 3, "inbunkno");\r\nQETH_DBF_HEX(CTRL, 3, hdr, QETH_DBF_CTRL_LEN);\r\ncontinue;\r\n}\r\nwork_done++;\r\nbudget--;\r\ncard->stats.rx_packets++;\r\ncard->stats.rx_bytes += len;\r\n}\r\nreturn work_done;\r\n}\r\nstatic int qeth_l3_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct qeth_card *card = container_of(napi, struct qeth_card, napi);\r\nint work_done = 0;\r\nstruct qeth_qdio_buffer *buffer;\r\nint done;\r\nint new_budget = budget;\r\nif (card->options.performance_stats) {\r\ncard->perf_stats.inbound_cnt++;\r\ncard->perf_stats.inbound_start_time = qeth_get_micros();\r\n}\r\nwhile (1) {\r\nif (!card->rx.b_count) {\r\ncard->rx.qdio_err = 0;\r\ncard->rx.b_count = qdio_get_next_buffers(\r\ncard->data.ccwdev, 0, &card->rx.b_index,\r\n&card->rx.qdio_err);\r\nif (card->rx.b_count <= 0) {\r\ncard->rx.b_count = 0;\r\nbreak;\r\n}\r\ncard->rx.b_element =\r\n&card->qdio.in_q->bufs[card->rx.b_index]\r\n.buffer->element[0];\r\ncard->rx.e_offset = 0;\r\n}\r\nwhile (card->rx.b_count) {\r\nbuffer = &card->qdio.in_q->bufs[card->rx.b_index];\r\nif (!(card->rx.qdio_err &&\r\nqeth_check_qdio_errors(card, buffer->buffer,\r\ncard->rx.qdio_err, "qinerr")))\r\nwork_done += qeth_l3_process_inbound_buffer(\r\ncard, new_budget, &done);\r\nelse\r\ndone = 1;\r\nif (done) {\r\nif (card->options.performance_stats)\r\ncard->perf_stats.bufs_rec++;\r\nqeth_put_buffer_pool_entry(card,\r\nbuffer->pool_entry);\r\nqeth_queue_input_buffer(card, card->rx.b_index);\r\ncard->rx.b_count--;\r\nif (card->rx.b_count) {\r\ncard->rx.b_index =\r\n(card->rx.b_index + 1) %\r\nQDIO_MAX_BUFFERS_PER_Q;\r\ncard->rx.b_element =\r\n&card->qdio.in_q\r\n->bufs[card->rx.b_index]\r\n.buffer->element[0];\r\ncard->rx.e_offset = 0;\r\n}\r\n}\r\nif (work_done >= budget)\r\ngoto out;\r\nelse\r\nnew_budget = budget - work_done;\r\n}\r\n}\r\nnapi_complete(napi);\r\nif (qdio_start_irq(card->data.ccwdev, 0))\r\nnapi_schedule(&card->napi);\r\nout:\r\nif (card->options.performance_stats)\r\ncard->perf_stats.inbound_time += qeth_get_micros() -\r\ncard->perf_stats.inbound_start_time;\r\nreturn work_done;\r\n}\r\nstatic int qeth_l3_verify_vlan_dev(struct net_device *dev,\r\nstruct qeth_card *card)\r\n{\r\nint rc = 0;\r\nu16 vid;\r\nfor_each_set_bit(vid, card->active_vlans, VLAN_N_VID) {\r\nstruct net_device *netdev;\r\nrcu_read_lock();\r\nnetdev = __vlan_find_dev_deep_rcu(card->dev, htons(ETH_P_8021Q),\r\nvid);\r\nrcu_read_unlock();\r\nif (netdev == dev) {\r\nrc = QETH_VLAN_CARD;\r\nbreak;\r\n}\r\n}\r\nif (rc && !(vlan_dev_real_dev(dev)->ml_priv == (void *)card))\r\nreturn 0;\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_verify_dev(struct net_device *dev)\r\n{\r\nstruct qeth_card *card;\r\nint rc = 0;\r\nunsigned long flags;\r\nread_lock_irqsave(&qeth_core_card_list.rwlock, flags);\r\nlist_for_each_entry(card, &qeth_core_card_list.list, list) {\r\nif (card->dev == dev) {\r\nrc = QETH_REAL_CARD;\r\nbreak;\r\n}\r\nrc = qeth_l3_verify_vlan_dev(dev, card);\r\nif (rc)\r\nbreak;\r\n}\r\nread_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\r\nreturn rc;\r\n}\r\nstatic struct qeth_card *qeth_l3_get_card_from_dev(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = NULL;\r\nint rc;\r\nrc = qeth_l3_verify_dev(dev);\r\nif (rc == QETH_REAL_CARD)\r\ncard = dev->ml_priv;\r\nelse if (rc == QETH_VLAN_CARD)\r\ncard = vlan_dev_real_dev(dev)->ml_priv;\r\nif (card && card->options.layer2)\r\ncard = NULL;\r\nif (card)\r\nQETH_CARD_TEXT_(card, 4, "%d", rc);\r\nreturn card ;\r\n}\r\nstatic void qeth_l3_stop_card(struct qeth_card *card, int recovery_mode)\r\n{\r\nQETH_DBF_TEXT(SETUP, 2, "stopcard");\r\nQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\r\nqeth_set_allowed_threads(card, 0, 1);\r\nif (card->options.sniffer &&\r\n(card->info.promisc_mode == SET_PROMISC_MODE_ON))\r\nqeth_diags_trace(card, QETH_DIAGS_CMD_TRACE_DISABLE);\r\nif (card->read.state == CH_STATE_UP &&\r\ncard->write.state == CH_STATE_UP &&\r\n(card->state == CARD_STATE_UP)) {\r\nif (recovery_mode)\r\nqeth_l3_stop(card->dev);\r\nelse {\r\nrtnl_lock();\r\ndev_close(card->dev);\r\nrtnl_unlock();\r\n}\r\ncard->state = CARD_STATE_SOFTSETUP;\r\n}\r\nif (card->state == CARD_STATE_SOFTSETUP) {\r\nqeth_l3_clear_ip_htable(card, 1);\r\nqeth_clear_ipacmd_list(card);\r\ncard->state = CARD_STATE_HARDSETUP;\r\n}\r\nif (card->state == CARD_STATE_HARDSETUP) {\r\nqeth_qdio_clear_card(card, 0);\r\nqeth_clear_qdio_buffers(card);\r\nqeth_clear_working_pool_list(card);\r\ncard->state = CARD_STATE_DOWN;\r\n}\r\nif (card->state == CARD_STATE_DOWN) {\r\nqeth_clear_cmd_buffers(&card->read);\r\nqeth_clear_cmd_buffers(&card->write);\r\n}\r\n}\r\nstatic void\r\nqeth_l3_handle_promisc_mode(struct qeth_card *card)\r\n{\r\nstruct net_device *dev = card->dev;\r\nif (((dev->flags & IFF_PROMISC) &&\r\n(card->info.promisc_mode == SET_PROMISC_MODE_ON)) ||\r\n(!(dev->flags & IFF_PROMISC) &&\r\n(card->info.promisc_mode == SET_PROMISC_MODE_OFF)))\r\nreturn;\r\nif (card->info.guestlan) {\r\nif (qeth_adp_supported(card, IPA_SETADP_SET_PROMISC_MODE))\r\nqeth_setadp_promisc_mode(card);\r\n} else if (card->options.sniffer &&\r\nqeth_adp_supported(card, IPA_SETADP_SET_DIAG_ASSIST)) {\r\nif (dev->flags & IFF_PROMISC) {\r\nQETH_CARD_TEXT(card, 3, "+promisc");\r\nqeth_diags_trace(card, QETH_DIAGS_CMD_TRACE_ENABLE);\r\n} else {\r\nQETH_CARD_TEXT(card, 3, "-promisc");\r\nqeth_diags_trace(card, QETH_DIAGS_CMD_TRACE_DISABLE);\r\n}\r\n}\r\n}\r\nstatic void qeth_l3_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nQETH_CARD_TEXT(card, 3, "setmulti");\r\nif (qeth_threads_running(card, QETH_RECOVER_THREAD) &&\r\n(card->state != CARD_STATE_UP))\r\nreturn;\r\nif (!card->options.sniffer) {\r\nspin_lock_bh(&card->mclock);\r\nqeth_l3_mark_all_mc_to_be_deleted(card);\r\nqeth_l3_add_multicast_ipv4(card);\r\n#ifdef CONFIG_QETH_IPV6\r\nqeth_l3_add_multicast_ipv6(card);\r\n#endif\r\nqeth_l3_delete_nonused_mc(card);\r\nqeth_l3_add_all_new_mc(card);\r\nspin_unlock_bh(&card->mclock);\r\nif (!qeth_adp_supported(card, IPA_SETADP_SET_PROMISC_MODE))\r\nreturn;\r\n}\r\nqeth_l3_handle_promisc_mode(card);\r\n}\r\nstatic const char *qeth_l3_arp_get_error_cause(int *rc)\r\n{\r\nswitch (*rc) {\r\ncase QETH_IPA_ARP_RC_FAILED:\r\n*rc = -EIO;\r\nreturn "operation failed";\r\ncase QETH_IPA_ARP_RC_NOTSUPP:\r\n*rc = -EOPNOTSUPP;\r\nreturn "operation not supported";\r\ncase QETH_IPA_ARP_RC_OUT_OF_RANGE:\r\n*rc = -EINVAL;\r\nreturn "argument out of range";\r\ncase QETH_IPA_ARP_RC_Q_NOTSUPP:\r\n*rc = -EOPNOTSUPP;\r\nreturn "query operation not supported";\r\ncase QETH_IPA_ARP_RC_Q_NO_DATA:\r\n*rc = -ENOENT;\r\nreturn "no query data available";\r\ndefault:\r\nreturn "unknown error";\r\n}\r\n}\r\nstatic int qeth_l3_arp_set_no_entries(struct qeth_card *card, int no_entries)\r\n{\r\nint tmp;\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "arpstnoe");\r\nif (card->info.guestlan)\r\nreturn -EOPNOTSUPP;\r\nif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_ARP_PROCESSING,\r\nIPA_CMD_ASS_ARP_SET_NO_ENTRIES,\r\nno_entries);\r\nif (rc) {\r\ntmp = rc;\r\nQETH_DBF_MESSAGE(2, "Could not set number of ARP entries on "\r\n"%s: %s (0x%x/%d)\n", QETH_CARD_IFNAME(card),\r\nqeth_l3_arp_get_error_cause(&rc), tmp, tmp);\r\n}\r\nreturn rc;\r\n}\r\nstatic __u32 get_arp_entry_size(struct qeth_card *card,\r\nstruct qeth_arp_query_data *qdata,\r\nstruct qeth_arp_entrytype *type, __u8 strip_entries)\r\n{\r\n__u32 rc;\r\n__u8 is_hsi;\r\nis_hsi = qdata->reply_bits == 5;\r\nif (type->ip == QETHARP_IP_ADDR_V4) {\r\nQETH_CARD_TEXT(card, 4, "arpev4");\r\nif (strip_entries) {\r\nrc = is_hsi ? sizeof(struct qeth_arp_qi_entry5_short) :\r\nsizeof(struct qeth_arp_qi_entry7_short);\r\n} else {\r\nrc = is_hsi ? sizeof(struct qeth_arp_qi_entry5) :\r\nsizeof(struct qeth_arp_qi_entry7);\r\n}\r\n} else if (type->ip == QETHARP_IP_ADDR_V6) {\r\nQETH_CARD_TEXT(card, 4, "arpev6");\r\nif (strip_entries) {\r\nrc = is_hsi ?\r\nsizeof(struct qeth_arp_qi_entry5_short_ipv6) :\r\nsizeof(struct qeth_arp_qi_entry7_short_ipv6);\r\n} else {\r\nrc = is_hsi ?\r\nsizeof(struct qeth_arp_qi_entry5_ipv6) :\r\nsizeof(struct qeth_arp_qi_entry7_ipv6);\r\n}\r\n} else {\r\nQETH_CARD_TEXT(card, 4, "arpinv");\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int arpentry_matches_prot(struct qeth_arp_entrytype *type, __u16 prot)\r\n{\r\nreturn (type->ip == QETHARP_IP_ADDR_V4 && prot == QETH_PROT_IPV4) ||\r\n(type->ip == QETHARP_IP_ADDR_V6 && prot == QETH_PROT_IPV6);\r\n}\r\nstatic int qeth_l3_arp_query_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_arp_query_data *qdata;\r\nstruct qeth_arp_query_info *qinfo;\r\nint i;\r\nint e;\r\nint entrybytes_done;\r\nint stripped_bytes;\r\n__u8 do_strip_entries;\r\nQETH_CARD_TEXT(card, 3, "arpquecb");\r\nqinfo = (struct qeth_arp_query_info *) reply->param;\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nQETH_CARD_TEXT_(card, 4, "%i", cmd->hdr.prot_version);\r\nif (cmd->hdr.return_code) {\r\nQETH_CARD_TEXT(card, 4, "arpcberr");\r\nQETH_CARD_TEXT_(card, 4, "%i", cmd->hdr.return_code);\r\nreturn 0;\r\n}\r\nif (cmd->data.setassparms.hdr.return_code) {\r\ncmd->hdr.return_code = cmd->data.setassparms.hdr.return_code;\r\nQETH_CARD_TEXT(card, 4, "setaperr");\r\nQETH_CARD_TEXT_(card, 4, "%i", cmd->hdr.return_code);\r\nreturn 0;\r\n}\r\nqdata = &cmd->data.setassparms.data.query_arp;\r\nQETH_CARD_TEXT_(card, 4, "anoen%i", qdata->no_entries);\r\ndo_strip_entries = (qinfo->mask_bits & QETH_QARP_STRIP_ENTRIES) > 0;\r\nstripped_bytes = do_strip_entries ? QETH_QARP_MEDIASPECIFIC_BYTES : 0;\r\nentrybytes_done = 0;\r\nfor (e = 0; e < qdata->no_entries; ++e) {\r\nchar *cur_entry;\r\n__u32 esize;\r\nstruct qeth_arp_entrytype *etype;\r\ncur_entry = &qdata->data + entrybytes_done;\r\netype = &((struct qeth_arp_qi_entry5 *) cur_entry)->type;\r\nif (!arpentry_matches_prot(etype, cmd->hdr.prot_version)) {\r\nQETH_CARD_TEXT(card, 4, "pmis");\r\nQETH_CARD_TEXT_(card, 4, "%i", etype->ip);\r\nbreak;\r\n}\r\nesize = get_arp_entry_size(card, qdata, etype,\r\ndo_strip_entries);\r\nQETH_CARD_TEXT_(card, 5, "esz%i", esize);\r\nif (!esize)\r\nbreak;\r\nif ((qinfo->udata_len - qinfo->udata_offset) < esize) {\r\nQETH_CARD_TEXT_(card, 4, "qaer3%i", -ENOMEM);\r\ncmd->hdr.return_code = IPA_RC_ENOMEM;\r\ngoto out_error;\r\n}\r\nmemcpy(qinfo->udata + qinfo->udata_offset,\r\n&qdata->data + entrybytes_done + stripped_bytes,\r\nesize);\r\nentrybytes_done += esize + stripped_bytes;\r\nqinfo->udata_offset += esize;\r\n++qinfo->no_entries;\r\n}\r\nif (cmd->data.setassparms.hdr.seq_no <\r\ncmd->data.setassparms.hdr.number_of_replies)\r\nreturn 1;\r\nQETH_CARD_TEXT_(card, 4, "nove%i", qinfo->no_entries);\r\nmemcpy(qinfo->udata, &qinfo->no_entries, 4);\r\nif (qinfo->mask_bits & QETH_QARP_STRIP_ENTRIES)\r\nqdata->reply_bits |= QETH_QARP_STRIP_ENTRIES;\r\nmemcpy(qinfo->udata + QETH_QARP_MASK_OFFSET, &qdata->reply_bits, 2);\r\nQETH_CARD_TEXT_(card, 4, "rc%i", 0);\r\nreturn 0;\r\nout_error:\r\ni = 0;\r\nmemcpy(qinfo->udata, &i, 4);\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_send_ipa_arp_cmd(struct qeth_card *card,\r\nstruct qeth_cmd_buffer *iob, int len,\r\nint (*reply_cb)(struct qeth_card *, struct qeth_reply *,\r\nunsigned long),\r\nvoid *reply_param)\r\n{\r\nQETH_CARD_TEXT(card, 4, "sendarp");\r\nmemcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);\r\nmemcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),\r\n&card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\r\nreturn qeth_send_control_data(card, IPA_PDU_HEADER_SIZE + len, iob,\r\nreply_cb, reply_param);\r\n}\r\nstatic int qeth_l3_query_arp_cache_info(struct qeth_card *card,\r\nenum qeth_prot_versions prot,\r\nstruct qeth_arp_query_info *qinfo)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nint tmp;\r\nint rc;\r\nQETH_CARD_TEXT_(card, 3, "qarpipv%i", prot);\r\niob = qeth_get_setassparms_cmd(card, IPA_ARP_PROCESSING,\r\nIPA_CMD_ASS_ARP_QUERY_INFO,\r\nsizeof(struct qeth_arp_query_data)\r\n- sizeof(char),\r\nprot);\r\nif (!iob)\r\nreturn -ENOMEM;\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.setassparms.data.query_arp.request_bits = 0x000F;\r\ncmd->data.setassparms.data.query_arp.reply_bits = 0;\r\ncmd->data.setassparms.data.query_arp.no_entries = 0;\r\nrc = qeth_l3_send_ipa_arp_cmd(card, iob,\r\nQETH_SETASS_BASE_LEN+QETH_ARP_CMD_LEN,\r\nqeth_l3_arp_query_cb, (void *)qinfo);\r\nif (rc) {\r\ntmp = rc;\r\nQETH_DBF_MESSAGE(2,\r\n"Error while querying ARP cache on %s: %s "\r\n"(0x%x/%d)\n", QETH_CARD_IFNAME(card),\r\nqeth_l3_arp_get_error_cause(&rc), tmp, tmp);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_arp_query(struct qeth_card *card, char __user *udata)\r\n{\r\nstruct qeth_arp_query_info qinfo = {0, };\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "arpquery");\r\nif (!qeth_is_supported(card,\r\nIPA_ARP_PROCESSING)) {\r\nQETH_CARD_TEXT(card, 3, "arpqnsup");\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (copy_from_user(&qinfo, udata, 6)) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\r\nif (!qinfo.udata) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nqinfo.udata_offset = QETH_QARP_ENTRIES_OFFSET;\r\nrc = qeth_l3_query_arp_cache_info(card, QETH_PROT_IPV4, &qinfo);\r\nif (rc) {\r\nif (copy_to_user(udata, qinfo.udata, 4))\r\nrc = -EFAULT;\r\ngoto free_and_out;\r\n}\r\n#ifdef CONFIG_QETH_IPV6\r\nif (qinfo.mask_bits & QETH_QARP_WITH_IPV6) {\r\nqeth_l3_query_arp_cache_info(card, QETH_PROT_IPV6, &qinfo);\r\n}\r\n#endif\r\nif (copy_to_user(udata, qinfo.udata, qinfo.udata_len)) {\r\nQETH_CARD_TEXT(card, 4, "qactf");\r\nrc = -EFAULT;\r\ngoto free_and_out;\r\n}\r\nQETH_CARD_TEXT(card, 4, "qacts");\r\nfree_and_out:\r\nkfree(qinfo.udata);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_arp_add_entry(struct qeth_card *card,\r\nstruct qeth_arp_cache_entry *entry)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nchar buf[16];\r\nint tmp;\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "arpadent");\r\nif (card->info.guestlan)\r\nreturn -EOPNOTSUPP;\r\nif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\niob = qeth_get_setassparms_cmd(card, IPA_ARP_PROCESSING,\r\nIPA_CMD_ASS_ARP_ADD_ENTRY,\r\nsizeof(struct qeth_arp_cache_entry),\r\nQETH_PROT_IPV4);\r\nif (!iob)\r\nreturn -ENOMEM;\r\nrc = qeth_send_setassparms(card, iob,\r\nsizeof(struct qeth_arp_cache_entry),\r\n(unsigned long) entry,\r\nqeth_setassparms_cb, NULL);\r\nif (rc) {\r\ntmp = rc;\r\nqeth_l3_ipaddr4_to_string((u8 *)entry->ipaddr, buf);\r\nQETH_DBF_MESSAGE(2, "Could not add ARP entry for address %s "\r\n"on %s: %s (0x%x/%d)\n", buf, QETH_CARD_IFNAME(card),\r\nqeth_l3_arp_get_error_cause(&rc), tmp, tmp);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_arp_remove_entry(struct qeth_card *card,\r\nstruct qeth_arp_cache_entry *entry)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nchar buf[16] = {0, };\r\nint tmp;\r\nint rc;\r\nQETH_CARD_TEXT(card, 3, "arprment");\r\nif (card->info.guestlan)\r\nreturn -EOPNOTSUPP;\r\nif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nmemcpy(buf, entry, 12);\r\niob = qeth_get_setassparms_cmd(card, IPA_ARP_PROCESSING,\r\nIPA_CMD_ASS_ARP_REMOVE_ENTRY,\r\n12,\r\nQETH_PROT_IPV4);\r\nif (!iob)\r\nreturn -ENOMEM;\r\nrc = qeth_send_setassparms(card, iob,\r\n12, (unsigned long)buf,\r\nqeth_setassparms_cb, NULL);\r\nif (rc) {\r\ntmp = rc;\r\nmemset(buf, 0, 16);\r\nqeth_l3_ipaddr4_to_string((u8 *)entry->ipaddr, buf);\r\nQETH_DBF_MESSAGE(2, "Could not delete ARP entry for address %s"\r\n" on %s: %s (0x%x/%d)\n", buf, QETH_CARD_IFNAME(card),\r\nqeth_l3_arp_get_error_cause(&rc), tmp, tmp);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_arp_flush_cache(struct qeth_card *card)\r\n{\r\nint rc;\r\nint tmp;\r\nQETH_CARD_TEXT(card, 3, "arpflush");\r\nif (card->info.guestlan || (card->info.type == QETH_CARD_TYPE_IQD))\r\nreturn -EOPNOTSUPP;\r\nif (!qeth_is_supported(card, IPA_ARP_PROCESSING)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = qeth_send_simple_setassparms(card, IPA_ARP_PROCESSING,\r\nIPA_CMD_ASS_ARP_FLUSH_CACHE, 0);\r\nif (rc) {\r\ntmp = rc;\r\nQETH_DBF_MESSAGE(2, "Could not flush ARP cache on %s: %s "\r\n"(0x%x/%d)\n", QETH_CARD_IFNAME(card),\r\nqeth_l3_arp_get_error_cause(&rc), tmp, tmp);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nstruct qeth_arp_cache_entry arp_entry;\r\nstruct mii_ioctl_data *mii_data;\r\nint rc = 0;\r\nif (!card)\r\nreturn -ENODEV;\r\nif (!qeth_card_hw_is_reachable(card))\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase SIOC_QETH_ARP_SET_NO_ENTRIES:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\nrc = qeth_l3_arp_set_no_entries(card, rq->ifr_ifru.ifru_ivalue);\r\nbreak;\r\ncase SIOC_QETH_ARP_QUERY_INFO:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\nrc = qeth_l3_arp_query(card, rq->ifr_ifru.ifru_data);\r\nbreak;\r\ncase SIOC_QETH_ARP_ADD_ENTRY:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\nif (copy_from_user(&arp_entry, rq->ifr_ifru.ifru_data,\r\nsizeof(struct qeth_arp_cache_entry)))\r\nrc = -EFAULT;\r\nelse\r\nrc = qeth_l3_arp_add_entry(card, &arp_entry);\r\nbreak;\r\ncase SIOC_QETH_ARP_REMOVE_ENTRY:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\nif (copy_from_user(&arp_entry, rq->ifr_ifru.ifru_data,\r\nsizeof(struct qeth_arp_cache_entry)))\r\nrc = -EFAULT;\r\nelse\r\nrc = qeth_l3_arp_remove_entry(card, &arp_entry);\r\nbreak;\r\ncase SIOC_QETH_ARP_FLUSH_CACHE:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\nrc = qeth_l3_arp_flush_cache(card);\r\nbreak;\r\ncase SIOC_QETH_ADP_SET_SNMP_CONTROL:\r\nrc = qeth_snmp_command(card, rq->ifr_ifru.ifru_data);\r\nbreak;\r\ncase SIOC_QETH_GET_CARD_TYPE:\r\nif ((card->info.type == QETH_CARD_TYPE_OSD ||\r\ncard->info.type == QETH_CARD_TYPE_OSX) &&\r\n!card->info.guestlan)\r\nreturn 1;\r\nreturn 0;\r\nbreak;\r\ncase SIOCGMIIPHY:\r\nmii_data = if_mii(rq);\r\nmii_data->phy_id = 0;\r\nbreak;\r\ncase SIOCGMIIREG:\r\nmii_data = if_mii(rq);\r\nif (mii_data->phy_id != 0)\r\nrc = -EINVAL;\r\nelse\r\nmii_data->val_out = qeth_mdio_read(dev,\r\nmii_data->phy_id,\r\nmii_data->reg_num);\r\nbreak;\r\ncase SIOC_QETH_QUERY_OAT:\r\nrc = qeth_query_oat_command(card, rq->ifr_ifru.ifru_data);\r\nbreak;\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\n}\r\nif (rc)\r\nQETH_CARD_TEXT_(card, 2, "ioce%d", rc);\r\nreturn rc;\r\n}\r\nint inline qeth_l3_get_cast_type(struct qeth_card *card, struct sk_buff *skb)\r\n{\r\nint cast_type = RTN_UNSPEC;\r\nstruct neighbour *n = NULL;\r\nstruct dst_entry *dst;\r\nrcu_read_lock();\r\ndst = skb_dst(skb);\r\nif (dst)\r\nn = dst_neigh_lookup_skb(dst, skb);\r\nif (n) {\r\ncast_type = n->type;\r\nrcu_read_unlock();\r\nneigh_release(n);\r\nif ((cast_type == RTN_BROADCAST) ||\r\n(cast_type == RTN_MULTICAST) ||\r\n(cast_type == RTN_ANYCAST))\r\nreturn cast_type;\r\nelse\r\nreturn RTN_UNSPEC;\r\n}\r\nrcu_read_unlock();\r\nif (skb->protocol == ETH_P_IPV6)\r\nreturn (skb_network_header(skb)[24] == 0xff) ?\r\nRTN_MULTICAST : 0;\r\nelse if (skb->protocol == ETH_P_IP)\r\nreturn ((skb_network_header(skb)[16] & 0xf0) == 0xe0) ?\r\nRTN_MULTICAST : 0;\r\nif (!memcmp(skb->data, skb->dev->broadcast, 6))\r\nreturn RTN_BROADCAST;\r\nelse {\r\nu16 hdr_mac;\r\nhdr_mac = *((u16 *)skb->data);\r\nswitch (card->info.link_type) {\r\ncase QETH_LINK_TYPE_HSTR:\r\ncase QETH_LINK_TYPE_LANE_TR:\r\nif ((hdr_mac == QETH_TR_MAC_NC) ||\r\n(hdr_mac == QETH_TR_MAC_C))\r\nreturn RTN_MULTICAST;\r\nbreak;\r\ndefault:\r\nif ((hdr_mac == QETH_ETH_MAC_V4) ||\r\n(hdr_mac == QETH_ETH_MAC_V6))\r\nreturn RTN_MULTICAST;\r\n}\r\n}\r\nreturn cast_type;\r\n}\r\nstatic void qeth_l3_fill_af_iucv_hdr(struct qeth_card *card,\r\nstruct qeth_hdr *hdr, struct sk_buff *skb)\r\n{\r\nchar daddr[16];\r\nstruct af_iucv_trans_hdr *iucv_hdr;\r\nskb_pull(skb, 14);\r\ncard->dev->header_ops->create(skb, card->dev, 0,\r\ncard->dev->dev_addr, card->dev->dev_addr,\r\ncard->dev->addr_len);\r\nskb_pull(skb, 14);\r\niucv_hdr = (struct af_iucv_trans_hdr *)skb->data;\r\nmemset(hdr, 0, sizeof(struct qeth_hdr));\r\nhdr->hdr.l3.id = QETH_HEADER_TYPE_LAYER3;\r\nhdr->hdr.l3.ext_flags = 0;\r\nhdr->hdr.l3.length = skb->len;\r\nhdr->hdr.l3.flags = QETH_HDR_IPV6 | QETH_CAST_UNICAST;\r\nmemset(daddr, 0, sizeof(daddr));\r\ndaddr[0] = 0xfe;\r\ndaddr[1] = 0x80;\r\nmemcpy(&daddr[8], iucv_hdr->destUserID, 8);\r\nmemcpy(hdr->hdr.l3.dest_addr, daddr, 16);\r\n}\r\nstatic void qeth_l3_fill_header(struct qeth_card *card, struct qeth_hdr *hdr,\r\nstruct sk_buff *skb, int ipv, int cast_type)\r\n{\r\nstruct dst_entry *dst;\r\nmemset(hdr, 0, sizeof(struct qeth_hdr));\r\nhdr->hdr.l3.id = QETH_HEADER_TYPE_LAYER3;\r\nhdr->hdr.l3.ext_flags = 0;\r\nif (skb_vlan_tag_present(skb)) {\r\nif ((ipv == 4) || (card->info.type == QETH_CARD_TYPE_IQD))\r\nhdr->hdr.l3.ext_flags = QETH_HDR_EXT_VLAN_FRAME;\r\nelse\r\nhdr->hdr.l3.ext_flags = QETH_HDR_EXT_INCLUDE_VLAN_TAG;\r\nhdr->hdr.l3.vlan_id = skb_vlan_tag_get(skb);\r\n}\r\nhdr->hdr.l3.length = skb->len - sizeof(struct qeth_hdr);\r\nrcu_read_lock();\r\ndst = skb_dst(skb);\r\nif (ipv == 4) {\r\nstruct rtable *rt = (struct rtable *) dst;\r\n__be32 *pkey = &ip_hdr(skb)->daddr;\r\nif (rt->rt_gateway)\r\npkey = &rt->rt_gateway;\r\nhdr->hdr.l3.flags = qeth_l3_get_qeth_hdr_flags4(cast_type);\r\nmemset(hdr->hdr.l3.dest_addr, 0, 12);\r\n*((__be32 *) (&hdr->hdr.l3.dest_addr[12])) = *pkey;\r\n} else if (ipv == 6) {\r\nstruct rt6_info *rt = (struct rt6_info *) dst;\r\nstruct in6_addr *pkey = &ipv6_hdr(skb)->daddr;\r\nif (!ipv6_addr_any(&rt->rt6i_gateway))\r\npkey = &rt->rt6i_gateway;\r\nhdr->hdr.l3.flags = qeth_l3_get_qeth_hdr_flags6(cast_type);\r\nif (card->info.type == QETH_CARD_TYPE_IQD)\r\nhdr->hdr.l3.flags &= ~QETH_HDR_PASSTHRU;\r\nmemcpy(hdr->hdr.l3.dest_addr, pkey, 16);\r\n} else {\r\nif (!memcmp(skb->data + sizeof(struct qeth_hdr),\r\nskb->dev->broadcast, 6)) {\r\nhdr->hdr.l3.flags = QETH_CAST_BROADCAST |\r\nQETH_HDR_PASSTHRU;\r\n} else {\r\nhdr->hdr.l3.flags = (cast_type == RTN_MULTICAST) ?\r\nQETH_CAST_MULTICAST | QETH_HDR_PASSTHRU :\r\nQETH_CAST_UNICAST | QETH_HDR_PASSTHRU;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic inline void qeth_l3_hdr_csum(struct qeth_card *card,\r\nstruct qeth_hdr *hdr, struct sk_buff *skb)\r\n{\r\nstruct iphdr *iph = ip_hdr(skb);\r\nif (iph->protocol == IPPROTO_UDP)\r\nhdr->hdr.l3.ext_flags |= QETH_HDR_EXT_UDP;\r\nhdr->hdr.l3.ext_flags |= QETH_HDR_EXT_CSUM_TRANSP_REQ |\r\nQETH_HDR_EXT_CSUM_HDR_REQ;\r\niph->check = 0;\r\nif (card->options.performance_stats)\r\ncard->perf_stats.tx_csum++;\r\n}\r\nstatic void qeth_tso_fill_header(struct qeth_card *card,\r\nstruct qeth_hdr *qhdr, struct sk_buff *skb)\r\n{\r\nstruct qeth_hdr_tso *hdr = (struct qeth_hdr_tso *)qhdr;\r\nstruct tcphdr *tcph = tcp_hdr(skb);\r\nstruct iphdr *iph = ip_hdr(skb);\r\nstruct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nhdr->hdr.hdr.l3.id = QETH_HEADER_TYPE_TSO;\r\nhdr->hdr.hdr.l3.length = skb->len - sizeof(struct qeth_hdr_tso);\r\nhdr->ext.hdr_tot_len = (__u16) sizeof(struct qeth_hdr_ext_tso);\r\nhdr->ext.imb_hdr_no = 1;\r\nhdr->ext.hdr_type = 1;\r\nhdr->ext.hdr_version = 1;\r\nhdr->ext.hdr_len = 28;\r\nhdr->ext.mss = skb_shinfo(skb)->gso_size;\r\nhdr->ext.dg_hdr_len = (__u16)(iph->ihl*4 + tcph->doff*4);\r\nhdr->ext.payload_len = (__u16)(skb->len - hdr->ext.dg_hdr_len -\r\nsizeof(struct qeth_hdr_tso));\r\ntcph->check = 0;\r\nif (skb->protocol == ETH_P_IPV6) {\r\nip6h->payload_len = 0;\r\ntcph->check = ~csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\r\n0, IPPROTO_TCP, 0);\r\n} else {\r\ntcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\r\n0, IPPROTO_TCP, 0);\r\niph->tot_len = 0;\r\niph->check = 0;\r\n}\r\n}\r\nstatic int qeth_l3_get_elements_no_tso(struct qeth_card *card,\r\nstruct sk_buff *skb, int extra_elems)\r\n{\r\naddr_t tcpdptr = (addr_t)tcp_hdr(skb) + tcp_hdrlen(skb);\r\nint elements = qeth_get_elements_for_range(\r\ntcpdptr,\r\n(addr_t)skb->data + skb_headlen(skb)) +\r\nqeth_get_elements_for_frags(skb);\r\nif ((elements + extra_elems) > QETH_MAX_BUFFER_ELEMENTS(card)) {\r\nQETH_DBF_MESSAGE(2,\r\n"Invalid size of TSO IP packet (Number=%d / Length=%d). Discarded.\n",\r\nelements + extra_elems, skb->len);\r\nreturn 0;\r\n}\r\nreturn elements;\r\n}\r\nstatic int qeth_l3_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint rc;\r\nu16 *tag;\r\nstruct qeth_hdr *hdr = NULL;\r\nint hdr_elements = 0;\r\nint elements;\r\nstruct qeth_card *card = dev->ml_priv;\r\nstruct sk_buff *new_skb = NULL;\r\nint ipv = qeth_get_ip_version(skb);\r\nint cast_type = qeth_l3_get_cast_type(card, skb);\r\nstruct qeth_qdio_out_q *queue =\r\ncard->qdio.out_qs[card->qdio.do_prio_queueing\r\n|| (cast_type && card->info.is_multicast_different) ?\r\nqeth_get_priority_queue(card, skb, ipv, cast_type) :\r\ncard->qdio.default_out_queue];\r\nint tx_bytes = skb->len;\r\nbool use_tso;\r\nint data_offset = -1;\r\nint nr_frags;\r\nif (((card->info.type == QETH_CARD_TYPE_IQD) &&\r\n(((card->options.cq != QETH_CQ_ENABLED) && !ipv) ||\r\n((card->options.cq == QETH_CQ_ENABLED) &&\r\n(skb->protocol != ETH_P_AF_IUCV)))) ||\r\ncard->options.sniffer)\r\ngoto tx_drop;\r\nif ((card->state != CARD_STATE_UP) || !card->lan_online) {\r\ncard->stats.tx_carrier_errors++;\r\ngoto tx_drop;\r\n}\r\nif ((cast_type == RTN_BROADCAST) &&\r\n(card->info.broadcast_capable == 0))\r\ngoto tx_drop;\r\nif (card->options.performance_stats) {\r\ncard->perf_stats.outbound_cnt++;\r\ncard->perf_stats.outbound_start_time = qeth_get_micros();\r\n}\r\nuse_tso = skb_is_gso(skb) &&\r\n(qeth_get_ip_protocol(skb) == IPPROTO_TCP) && (ipv == 4);\r\nif ((card->info.type == QETH_CARD_TYPE_IQD) &&\r\n!skb_is_nonlinear(skb)) {\r\nnew_skb = skb;\r\nif (new_skb->protocol == ETH_P_AF_IUCV)\r\ndata_offset = 0;\r\nelse\r\ndata_offset = ETH_HLEN;\r\nhdr = kmem_cache_alloc(qeth_core_header_cache, GFP_ATOMIC);\r\nif (!hdr)\r\ngoto tx_drop;\r\nhdr_elements++;\r\n} else {\r\nnew_skb = skb_realloc_headroom(skb, sizeof(struct qeth_hdr_tso)\r\n+ VLAN_HLEN);\r\nif (!new_skb)\r\ngoto tx_drop;\r\n}\r\nif (card->info.type == QETH_CARD_TYPE_IQD) {\r\nif (data_offset < 0)\r\nskb_pull(new_skb, ETH_HLEN);\r\n} else {\r\nif (ipv == 4) {\r\nskb_pull(new_skb, ETH_HLEN);\r\n}\r\nif (ipv != 4 && skb_vlan_tag_present(new_skb)) {\r\nskb_push(new_skb, VLAN_HLEN);\r\nskb_copy_to_linear_data(new_skb, new_skb->data + 4, 4);\r\nskb_copy_to_linear_data_offset(new_skb, 4,\r\nnew_skb->data + 8, 4);\r\nskb_copy_to_linear_data_offset(new_skb, 8,\r\nnew_skb->data + 12, 4);\r\ntag = (u16 *)(new_skb->data + 12);\r\n*tag = __constant_htons(ETH_P_8021Q);\r\n*(tag + 1) = htons(skb_vlan_tag_get(new_skb));\r\n}\r\n}\r\nnetif_stop_queue(dev);\r\nif ((card->info.type != QETH_CARD_TYPE_IQD) &&\r\n((use_tso && !qeth_l3_get_elements_no_tso(card, new_skb, 1)) ||\r\n(!use_tso && !qeth_get_elements_no(card, new_skb, 0)))) {\r\nint lin_rc = skb_linearize(new_skb);\r\nif (card->options.performance_stats) {\r\nif (lin_rc)\r\ncard->perf_stats.tx_linfail++;\r\nelse\r\ncard->perf_stats.tx_lin++;\r\n}\r\nif (lin_rc)\r\ngoto tx_drop;\r\n}\r\nif (use_tso) {\r\nhdr = (struct qeth_hdr *)skb_push(new_skb,\r\nsizeof(struct qeth_hdr_tso));\r\nmemset(hdr, 0, sizeof(struct qeth_hdr_tso));\r\nqeth_l3_fill_header(card, hdr, new_skb, ipv, cast_type);\r\nqeth_tso_fill_header(card, hdr, new_skb);\r\nhdr_elements++;\r\n} else {\r\nif (data_offset < 0) {\r\nhdr = (struct qeth_hdr *)skb_push(new_skb,\r\nsizeof(struct qeth_hdr));\r\nqeth_l3_fill_header(card, hdr, new_skb, ipv,\r\ncast_type);\r\n} else {\r\nif (new_skb->protocol == ETH_P_AF_IUCV)\r\nqeth_l3_fill_af_iucv_hdr(card, hdr, new_skb);\r\nelse {\r\nqeth_l3_fill_header(card, hdr, new_skb, ipv,\r\ncast_type);\r\nhdr->hdr.l3.length = new_skb->len - data_offset;\r\n}\r\n}\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nqeth_l3_hdr_csum(card, hdr, new_skb);\r\n}\r\nelements = use_tso ?\r\nqeth_l3_get_elements_no_tso(card, new_skb, hdr_elements) :\r\nqeth_get_elements_no(card, new_skb, hdr_elements);\r\nif (!elements) {\r\nif (data_offset >= 0)\r\nkmem_cache_free(qeth_core_header_cache, hdr);\r\ngoto tx_drop;\r\n}\r\nelements += hdr_elements;\r\nif (card->info.type != QETH_CARD_TYPE_IQD) {\r\nint len;\r\nif (use_tso)\r\nlen = ((unsigned long)tcp_hdr(new_skb) +\r\ntcp_hdrlen(new_skb)) -\r\n(unsigned long)new_skb->data;\r\nelse\r\nlen = sizeof(struct qeth_hdr_layer3);\r\nif (qeth_hdr_chk_and_bounce(new_skb, &hdr, len))\r\ngoto tx_drop;\r\nrc = qeth_do_send_packet(card, queue, new_skb, hdr, elements);\r\n} else\r\nrc = qeth_do_send_packet_fast(card, queue, new_skb, hdr,\r\nelements, data_offset, 0);\r\nif (!rc) {\r\ncard->stats.tx_packets++;\r\ncard->stats.tx_bytes += tx_bytes;\r\nif (new_skb != skb)\r\ndev_kfree_skb_any(skb);\r\nif (card->options.performance_stats) {\r\nnr_frags = skb_shinfo(new_skb)->nr_frags;\r\nif (use_tso) {\r\ncard->perf_stats.large_send_bytes += tx_bytes;\r\ncard->perf_stats.large_send_cnt++;\r\n}\r\nif (nr_frags) {\r\ncard->perf_stats.sg_skbs_sent++;\r\ncard->perf_stats.sg_frags_sent += nr_frags + 1;\r\n}\r\n}\r\nrc = NETDEV_TX_OK;\r\n} else {\r\nif (data_offset >= 0)\r\nkmem_cache_free(qeth_core_header_cache, hdr);\r\nif (rc == -EBUSY) {\r\nif (new_skb != skb)\r\ndev_kfree_skb_any(new_skb);\r\nreturn NETDEV_TX_BUSY;\r\n} else\r\ngoto tx_drop;\r\n}\r\nnetif_wake_queue(dev);\r\nif (card->options.performance_stats)\r\ncard->perf_stats.outbound_time += qeth_get_micros() -\r\ncard->perf_stats.outbound_start_time;\r\nreturn rc;\r\ntx_drop:\r\ncard->stats.tx_dropped++;\r\ncard->stats.tx_errors++;\r\nif ((new_skb != skb) && new_skb)\r\ndev_kfree_skb_any(new_skb);\r\ndev_kfree_skb_any(skb);\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int __qeth_l3_open(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 4, "qethopen");\r\nif (card->state == CARD_STATE_UP)\r\nreturn rc;\r\nif (card->state != CARD_STATE_SOFTSETUP)\r\nreturn -ENODEV;\r\ncard->data.state = CH_STATE_UP;\r\ncard->state = CARD_STATE_UP;\r\nnetif_start_queue(dev);\r\nif (qdio_stop_irq(card->data.ccwdev, 0) >= 0) {\r\nnapi_enable(&card->napi);\r\nnapi_schedule(&card->napi);\r\n} else\r\nrc = -EIO;\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_open(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nQETH_CARD_TEXT(card, 5, "qethope_");\r\nif (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {\r\nQETH_CARD_TEXT(card, 3, "openREC");\r\nreturn -ERESTARTSYS;\r\n}\r\nreturn __qeth_l3_open(dev);\r\n}\r\nstatic int qeth_l3_stop(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nQETH_CARD_TEXT(card, 4, "qethstop");\r\nnetif_tx_disable(dev);\r\nif (card->state == CARD_STATE_UP) {\r\ncard->state = CARD_STATE_SOFTSETUP;\r\nnapi_disable(&card->napi);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_neigh_setup_noarp(struct neighbour *n)\r\n{\r\nn->nud_state = NUD_NOARP;\r\nmemcpy(n->ha, "FAKELL", 6);\r\nn->output = n->ops->connected_output;\r\nreturn 0;\r\n}\r\nstatic int\r\nqeth_l3_neigh_setup(struct net_device *dev, struct neigh_parms *np)\r\n{\r\nif (np->tbl->family == AF_INET)\r\nnp->neigh_setup = qeth_l3_neigh_setup_noarp;\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_setup_netdev(struct qeth_card *card)\r\n{\r\nint rc;\r\nif (card->info.type == QETH_CARD_TYPE_OSD ||\r\ncard->info.type == QETH_CARD_TYPE_OSX) {\r\nif ((card->info.link_type == QETH_LINK_TYPE_LANE_TR) ||\r\n(card->info.link_type == QETH_LINK_TYPE_HSTR)) {\r\npr_info("qeth_l3: ignoring TR device\n");\r\nreturn -ENODEV;\r\n} else {\r\ncard->dev = alloc_etherdev(0);\r\nif (!card->dev)\r\nreturn -ENODEV;\r\ncard->dev->netdev_ops = &qeth_l3_osa_netdev_ops;\r\nqeth_l3_get_unique_id(card);\r\nif (!(card->info.unique_id & UNIQUE_ID_NOT_BY_CARD))\r\ncard->dev->dev_id = card->info.unique_id &\r\n0xffff;\r\nif (!card->info.guestlan) {\r\ncard->dev->hw_features = NETIF_F_SG |\r\nNETIF_F_RXCSUM | NETIF_F_IP_CSUM |\r\nNETIF_F_TSO;\r\ncard->dev->vlan_features = NETIF_F_SG |\r\nNETIF_F_RXCSUM | NETIF_F_IP_CSUM |\r\nNETIF_F_TSO;\r\n}\r\n}\r\n} else if (card->info.type == QETH_CARD_TYPE_IQD) {\r\ncard->dev = alloc_netdev(0, "hsi%d", NET_NAME_UNKNOWN,\r\nether_setup);\r\nif (!card->dev)\r\nreturn -ENODEV;\r\ncard->dev->flags |= IFF_NOARP;\r\ncard->dev->netdev_ops = &qeth_l3_netdev_ops;\r\nrc = qeth_l3_iqd_read_initial_mac(card);\r\nif (rc)\r\nreturn rc;\r\nif (card->options.hsuid[0])\r\nmemcpy(card->dev->perm_addr, card->options.hsuid, 9);\r\n} else\r\nreturn -ENODEV;\r\ncard->dev->ml_priv = card;\r\ncard->dev->watchdog_timeo = QETH_TX_TIMEOUT;\r\ncard->dev->mtu = card->info.initial_mtu;\r\ncard->dev->ethtool_ops = &qeth_l3_ethtool_ops;\r\ncard->dev->features |= NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_HW_VLAN_CTAG_FILTER;\r\nnetif_keep_dst(card->dev);\r\ncard->dev->gso_max_size = (QETH_MAX_BUFFER_ELEMENTS(card) - 1) *\r\nPAGE_SIZE;\r\nSET_NETDEV_DEV(card->dev, &card->gdev->dev);\r\nnetif_napi_add(card->dev, &card->napi, qeth_l3_poll, QETH_NAPI_WEIGHT);\r\nnetif_carrier_off(card->dev);\r\nreturn register_netdev(card->dev);\r\n}\r\nstatic int qeth_l3_probe_device(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nqeth_l3_create_device_attributes(&gdev->dev);\r\ncard->options.layer2 = 0;\r\ncard->info.hwtrap = 0;\r\nreturn 0;\r\n}\r\nstatic void qeth_l3_remove_device(struct ccwgroup_device *cgdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&cgdev->dev);\r\nqeth_l3_remove_device_attributes(&cgdev->dev);\r\nqeth_set_allowed_threads(card, 0, 1);\r\nwait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);\r\nif (cgdev->state == CCWGROUP_ONLINE)\r\nqeth_l3_set_offline(cgdev);\r\nif (card->dev) {\r\nnetif_napi_del(&card->napi);\r\nunregister_netdev(card->dev);\r\ncard->dev = NULL;\r\n}\r\nqeth_l3_clear_ip_htable(card, 0);\r\nqeth_l3_clear_ipato_list(card);\r\nreturn;\r\n}\r\nstatic int __qeth_l3_set_online(struct ccwgroup_device *gdev, int recovery_mode)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nint rc = 0;\r\nenum qeth_card_states recover_flag;\r\nmutex_lock(&card->discipline_mutex);\r\nmutex_lock(&card->conf_mutex);\r\nQETH_DBF_TEXT(SETUP, 2, "setonlin");\r\nQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\r\nrecover_flag = card->state;\r\nrc = qeth_core_hardsetup_card(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "2err%04x", rc);\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n}\r\nif (!card->dev && qeth_l3_setup_netdev(card)) {\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n}\r\nif (qeth_is_diagass_supported(card, QETH_DIAGS_CMD_TRAP)) {\r\nif (card->info.hwtrap &&\r\nqeth_hw_trap(card, QETH_DIAGS_TRAP_ARM))\r\ncard->info.hwtrap = 0;\r\n} else\r\ncard->info.hwtrap = 0;\r\ncard->state = CARD_STATE_HARDSETUP;\r\nmemset(&card->rx, 0, sizeof(struct qeth_rx));\r\nqeth_print_status_message(card);\r\nQETH_DBF_TEXT(SETUP, 2, "softsetp");\r\nrc = qeth_send_startlan(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\nif (rc == 0xe080) {\r\ndev_warn(&card->gdev->dev,\r\n"The LAN is offline\n");\r\ncard->lan_online = 0;\r\ngoto contin;\r\n}\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n} else\r\ncard->lan_online = 1;\r\ncontin:\r\nrc = qeth_l3_setadapter_parms(card);\r\nif (rc)\r\nQETH_DBF_TEXT_(SETUP, 2, "2err%04x", rc);\r\nif (!card->options.sniffer) {\r\nrc = qeth_l3_start_ipassists(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "3err%d", rc);\r\ngoto out_remove;\r\n}\r\nrc = qeth_l3_setrouting_v4(card);\r\nif (rc)\r\nQETH_DBF_TEXT_(SETUP, 2, "4err%04x", rc);\r\nrc = qeth_l3_setrouting_v6(card);\r\nif (rc)\r\nQETH_DBF_TEXT_(SETUP, 2, "5err%04x", rc);\r\n}\r\nnetif_tx_disable(card->dev);\r\nrc = qeth_init_qdio_queues(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "6err%d", rc);\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n}\r\ncard->state = CARD_STATE_SOFTSETUP;\r\nqeth_set_allowed_threads(card, 0xffffffff, 0);\r\nqeth_l3_recover_ip(card);\r\nif (card->lan_online)\r\nnetif_carrier_on(card->dev);\r\nelse\r\nnetif_carrier_off(card->dev);\r\nif (recover_flag == CARD_STATE_RECOVER) {\r\nrtnl_lock();\r\nif (recovery_mode)\r\n__qeth_l3_open(card->dev);\r\nelse\r\ndev_open(card->dev);\r\nqeth_l3_set_multicast_list(card->dev);\r\nqeth_recover_features(card->dev);\r\nrtnl_unlock();\r\n}\r\nqeth_trace_features(card);\r\nkobject_uevent(&gdev->dev.kobj, KOBJ_CHANGE);\r\nmutex_unlock(&card->conf_mutex);\r\nmutex_unlock(&card->discipline_mutex);\r\nreturn 0;\r\nout_remove:\r\nqeth_l3_stop_card(card, 0);\r\nccw_device_set_offline(CARD_DDEV(card));\r\nccw_device_set_offline(CARD_WDEV(card));\r\nccw_device_set_offline(CARD_RDEV(card));\r\nqdio_free(CARD_DDEV(card));\r\nif (recover_flag == CARD_STATE_RECOVER)\r\ncard->state = CARD_STATE_RECOVER;\r\nelse\r\ncard->state = CARD_STATE_DOWN;\r\nmutex_unlock(&card->conf_mutex);\r\nmutex_unlock(&card->discipline_mutex);\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_set_online(struct ccwgroup_device *gdev)\r\n{\r\nreturn __qeth_l3_set_online(gdev, 0);\r\n}\r\nstatic int __qeth_l3_set_offline(struct ccwgroup_device *cgdev,\r\nint recovery_mode)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&cgdev->dev);\r\nint rc = 0, rc2 = 0, rc3 = 0;\r\nenum qeth_card_states recover_flag;\r\nmutex_lock(&card->discipline_mutex);\r\nmutex_lock(&card->conf_mutex);\r\nQETH_DBF_TEXT(SETUP, 3, "setoffl");\r\nQETH_DBF_HEX(SETUP, 3, &card, sizeof(void *));\r\nif (card->dev && netif_carrier_ok(card->dev))\r\nnetif_carrier_off(card->dev);\r\nrecover_flag = card->state;\r\nif ((!recovery_mode && card->info.hwtrap) || card->info.hwtrap == 2) {\r\nqeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\r\ncard->info.hwtrap = 1;\r\n}\r\nqeth_l3_stop_card(card, recovery_mode);\r\nif ((card->options.cq == QETH_CQ_ENABLED) && card->dev) {\r\nrtnl_lock();\r\ncall_netdevice_notifiers(NETDEV_REBOOT, card->dev);\r\nrtnl_unlock();\r\n}\r\nrc = ccw_device_set_offline(CARD_DDEV(card));\r\nrc2 = ccw_device_set_offline(CARD_WDEV(card));\r\nrc3 = ccw_device_set_offline(CARD_RDEV(card));\r\nif (!rc)\r\nrc = (rc2) ? rc2 : rc3;\r\nif (rc)\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\nqdio_free(CARD_DDEV(card));\r\nif (recover_flag == CARD_STATE_UP)\r\ncard->state = CARD_STATE_RECOVER;\r\nkobject_uevent(&cgdev->dev.kobj, KOBJ_CHANGE);\r\nmutex_unlock(&card->conf_mutex);\r\nmutex_unlock(&card->discipline_mutex);\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_set_offline(struct ccwgroup_device *cgdev)\r\n{\r\nreturn __qeth_l3_set_offline(cgdev, 0);\r\n}\r\nstatic int qeth_l3_recover(void *ptr)\r\n{\r\nstruct qeth_card *card;\r\nint rc = 0;\r\ncard = (struct qeth_card *) ptr;\r\nQETH_CARD_TEXT(card, 2, "recover1");\r\nQETH_CARD_HEX(card, 2, &card, sizeof(void *));\r\nif (!qeth_do_run_thread(card, QETH_RECOVER_THREAD))\r\nreturn 0;\r\nQETH_CARD_TEXT(card, 2, "recover2");\r\ndev_warn(&card->gdev->dev,\r\n"A recovery process has been started for the device\n");\r\nqeth_set_recovery_task(card);\r\n__qeth_l3_set_offline(card->gdev, 1);\r\nrc = __qeth_l3_set_online(card->gdev, 1);\r\nif (!rc)\r\ndev_info(&card->gdev->dev,\r\n"Device successfully recovered!\n");\r\nelse {\r\nqeth_close_dev(card);\r\ndev_warn(&card->gdev->dev, "The qeth device driver "\r\n"failed to recover an error on the device\n");\r\n}\r\nqeth_clear_recovery_task(card);\r\nqeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);\r\nqeth_clear_thread_running_bit(card, QETH_RECOVER_THREAD);\r\nreturn 0;\r\n}\r\nstatic void qeth_l3_shutdown(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nqeth_set_allowed_threads(card, 0, 1);\r\nif ((gdev->state == CCWGROUP_ONLINE) && card->info.hwtrap)\r\nqeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\r\nqeth_qdio_clear_card(card, 0);\r\nqeth_clear_qdio_buffers(card);\r\nqdio_free(CARD_DDEV(card));\r\n}\r\nstatic int qeth_l3_pm_suspend(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nif (card->dev)\r\nnetif_device_detach(card->dev);\r\nqeth_set_allowed_threads(card, 0, 1);\r\nwait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);\r\nif (gdev->state == CCWGROUP_OFFLINE)\r\nreturn 0;\r\nif (card->state == CARD_STATE_UP) {\r\nif (card->info.hwtrap)\r\nqeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\r\n__qeth_l3_set_offline(card->gdev, 1);\r\n} else\r\n__qeth_l3_set_offline(card->gdev, 0);\r\nreturn 0;\r\n}\r\nstatic int qeth_l3_pm_resume(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nint rc = 0;\r\nif (gdev->state == CCWGROUP_OFFLINE)\r\ngoto out;\r\nif (card->state == CARD_STATE_RECOVER) {\r\nrc = __qeth_l3_set_online(card->gdev, 1);\r\nif (rc) {\r\nrtnl_lock();\r\ndev_close(card->dev);\r\nrtnl_unlock();\r\n}\r\n} else\r\nrc = __qeth_l3_set_online(card->gdev, 0);\r\nout:\r\nqeth_set_allowed_threads(card, 0xffffffff, 0);\r\nif (card->dev)\r\nnetif_device_attach(card->dev);\r\nif (rc)\r\ndev_warn(&card->gdev->dev, "The qeth device driver "\r\n"failed to recover an error on the device\n");\r\nreturn rc;\r\n}\r\nstatic int qeth_l3_control_event(struct qeth_card *card,\r\nstruct qeth_ipa_cmd *cmd)\r\n{\r\nreturn 1;\r\n}\r\nstatic int qeth_l3_ip_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\r\nstruct net_device *dev = (struct net_device *)ifa->ifa_dev->dev;\r\nstruct qeth_ipaddr *addr;\r\nstruct qeth_card *card;\r\nif (dev_net(dev) != &init_net)\r\nreturn NOTIFY_DONE;\r\ncard = qeth_l3_get_card_from_dev(dev);\r\nif (!card)\r\nreturn NOTIFY_DONE;\r\nQETH_CARD_TEXT(card, 3, "ipevent");\r\naddr = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);\r\nif (addr) {\r\naddr->u.a4.addr = ifa->ifa_address;\r\naddr->u.a4.mask = ifa->ifa_mask;\r\naddr->type = QETH_IP_TYPE_NORMAL;\r\n} else\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nspin_lock_bh(&card->ip_lock);\r\nqeth_l3_add_ip(card, addr);\r\nspin_unlock_bh(&card->ip_lock);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nspin_lock_bh(&card->ip_lock);\r\nqeth_l3_delete_ip(card, addr);\r\nspin_unlock_bh(&card->ip_lock);\r\nbreak;\r\n}\r\nkfree(addr);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int qeth_l3_ip6_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\r\nstruct net_device *dev = (struct net_device *)ifa->idev->dev;\r\nstruct qeth_ipaddr *addr;\r\nstruct qeth_card *card;\r\ncard = qeth_l3_get_card_from_dev(dev);\r\nif (!card)\r\nreturn NOTIFY_DONE;\r\nQETH_CARD_TEXT(card, 3, "ip6event");\r\nif (!qeth_is_supported(card, IPA_IPV6))\r\nreturn NOTIFY_DONE;\r\naddr = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);\r\nif (addr) {\r\nmemcpy(&addr->u.a6.addr, &ifa->addr, sizeof(struct in6_addr));\r\naddr->u.a6.pfxlen = ifa->prefix_len;\r\naddr->type = QETH_IP_TYPE_NORMAL;\r\n} else\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nspin_lock_bh(&card->ip_lock);\r\nqeth_l3_add_ip(card, addr);\r\nspin_unlock_bh(&card->ip_lock);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nspin_lock_bh(&card->ip_lock);\r\nqeth_l3_delete_ip(card, addr);\r\nspin_unlock_bh(&card->ip_lock);\r\nbreak;\r\n}\r\nkfree(addr);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int qeth_l3_register_notifiers(void)\r\n{\r\nint rc;\r\nQETH_DBF_TEXT(SETUP, 5, "regnotif");\r\nrc = register_inetaddr_notifier(&qeth_l3_ip_notifier);\r\nif (rc)\r\nreturn rc;\r\n#ifdef CONFIG_QETH_IPV6\r\nrc = register_inet6addr_notifier(&qeth_l3_ip6_notifier);\r\nif (rc) {\r\nunregister_inetaddr_notifier(&qeth_l3_ip_notifier);\r\nreturn rc;\r\n}\r\n#else\r\npr_warn("There is no IPv6 support for the layer 3 discipline\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void qeth_l3_unregister_notifiers(void)\r\n{\r\nQETH_DBF_TEXT(SETUP, 5, "unregnot");\r\nWARN_ON(unregister_inetaddr_notifier(&qeth_l3_ip_notifier));\r\n#ifdef CONFIG_QETH_IPV6\r\nWARN_ON(unregister_inet6addr_notifier(&qeth_l3_ip6_notifier));\r\n#endif\r\n}\r\nstatic int __init qeth_l3_init(void)\r\n{\r\nint rc = 0;\r\npr_info("register layer 3 discipline\n");\r\nrc = qeth_l3_register_notifiers();\r\nreturn rc;\r\n}\r\nstatic void __exit qeth_l3_exit(void)\r\n{\r\nqeth_l3_unregister_notifiers();\r\npr_info("unregister layer 3 discipline\n");\r\n}
