void scsi_eh_wakeup(struct Scsi_Host *shost)\r\n{\r\nif (atomic_read(&shost->host_busy) == shost->host_failed) {\r\ntrace_scsi_eh_wakeup(shost);\r\nwake_up_process(shost->ehandler);\r\nSCSI_LOG_ERROR_RECOVERY(5, shost_printk(KERN_INFO, shost,\r\n"Waking error handler thread\n"));\r\n}\r\n}\r\nvoid scsi_schedule_eh(struct Scsi_Host *shost)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_set_state(shost, SHOST_RECOVERY) == 0 ||\r\nscsi_host_set_state(shost, SHOST_CANCEL_RECOVERY) == 0) {\r\nshost->host_eh_scheduled++;\r\nscsi_eh_wakeup(shost);\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nstatic int scsi_host_eh_past_deadline(struct Scsi_Host *shost)\r\n{\r\nif (!shost->last_reset || shost->eh_deadline == -1)\r\nreturn 0;\r\nif (time_before(jiffies, shost->last_reset + shost->eh_deadline) &&\r\nshost->eh_deadline > -1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid\r\nscmd_eh_abort_handler(struct work_struct *work)\r\n{\r\nstruct scsi_cmnd *scmd =\r\ncontainer_of(work, struct scsi_cmnd, abort_work.work);\r\nstruct scsi_device *sdev = scmd->device;\r\nint rtn;\r\nif (scsi_host_eh_past_deadline(sdev->host)) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"eh timeout, not aborting\n"));\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"aborting command\n"));\r\nrtn = scsi_try_to_abort_cmd(sdev->host->hostt, scmd);\r\nif (rtn == SUCCESS) {\r\nset_host_byte(scmd, DID_TIME_OUT);\r\nif (scsi_host_eh_past_deadline(sdev->host)) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"eh timeout, not retrying "\r\n"aborted command\n"));\r\n} else if (!scsi_noretry_cmd(scmd) &&\r\n(++scmd->retries <= scmd->allowed)) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_WARNING, scmd,\r\n"retry aborted command\n"));\r\nscsi_queue_insert(scmd, SCSI_MLQUEUE_EH_RETRY);\r\nreturn;\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_WARNING, scmd,\r\n"finish aborted command\n"));\r\nscsi_finish_command(scmd);\r\nreturn;\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"cmd abort %s\n",\r\n(rtn == FAST_IO_FAIL) ?\r\n"not send" : "failed"));\r\n}\r\n}\r\nif (!scsi_eh_scmd_add(scmd, 0)) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_WARNING, scmd,\r\n"terminate aborted command\n"));\r\nset_host_byte(scmd, DID_TIME_OUT);\r\nscsi_finish_command(scmd);\r\n}\r\n}\r\nstatic int\r\nscsi_abort_command(struct scsi_cmnd *scmd)\r\n{\r\nstruct scsi_device *sdev = scmd->device;\r\nstruct Scsi_Host *shost = sdev->host;\r\nunsigned long flags;\r\nif (scmd->eh_eflags & SCSI_EH_ABORT_SCHEDULED) {\r\nscmd->eh_eflags &= ~SCSI_EH_ABORT_SCHEDULED;\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"previous abort failed\n"));\r\nBUG_ON(delayed_work_pending(&scmd->abort_work));\r\nreturn FAILED;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_in_recovery(shost)) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"not aborting, host in recovery\n"));\r\nreturn FAILED;\r\n}\r\nif (shost->eh_deadline != -1 && !shost->last_reset)\r\nshost->last_reset = jiffies;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscmd->eh_eflags |= SCSI_EH_ABORT_SCHEDULED;\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd, "abort scheduled\n"));\r\nqueue_delayed_work(shost->tmf_work_q, &scmd->abort_work, HZ / 100);\r\nreturn SUCCESS;\r\n}\r\nint scsi_eh_scmd_add(struct scsi_cmnd *scmd, int eh_flag)\r\n{\r\nstruct Scsi_Host *shost = scmd->device->host;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!shost->ehandler)\r\nreturn 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_set_state(shost, SHOST_RECOVERY))\r\nif (scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY))\r\ngoto out_unlock;\r\nif (shost->eh_deadline != -1 && !shost->last_reset)\r\nshost->last_reset = jiffies;\r\nret = 1;\r\nif (scmd->eh_eflags & SCSI_EH_ABORT_SCHEDULED)\r\neh_flag &= ~SCSI_EH_CANCEL_CMD;\r\nscmd->eh_eflags |= eh_flag;\r\nlist_add_tail(&scmd->eh_entry, &shost->eh_cmd_q);\r\nshost->host_failed++;\r\nscsi_eh_wakeup(shost);\r\nout_unlock:\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn ret;\r\n}\r\nenum blk_eh_timer_return scsi_times_out(struct request *req)\r\n{\r\nstruct scsi_cmnd *scmd = req->special;\r\nenum blk_eh_timer_return rtn = BLK_EH_NOT_HANDLED;\r\nstruct Scsi_Host *host = scmd->device->host;\r\ntrace_scsi_dispatch_cmd_timeout(scmd);\r\nscsi_log_completion(scmd, TIMEOUT_ERROR);\r\nif (host->eh_deadline != -1 && !host->last_reset)\r\nhost->last_reset = jiffies;\r\nif (host->transportt->eh_timed_out)\r\nrtn = host->transportt->eh_timed_out(scmd);\r\nelse if (host->hostt->eh_timed_out)\r\nrtn = host->hostt->eh_timed_out(scmd);\r\nif (rtn == BLK_EH_NOT_HANDLED) {\r\nif (!host->hostt->no_async_abort &&\r\nscsi_abort_command(scmd) == SUCCESS)\r\nreturn BLK_EH_NOT_HANDLED;\r\nset_host_byte(scmd, DID_TIME_OUT);\r\nif (!scsi_eh_scmd_add(scmd, SCSI_EH_CANCEL_CMD))\r\nrtn = BLK_EH_HANDLED;\r\n}\r\nreturn rtn;\r\n}\r\nint scsi_block_when_processing_errors(struct scsi_device *sdev)\r\n{\r\nint online;\r\nwait_event(sdev->host->host_wait, !scsi_host_in_recovery(sdev->host));\r\nonline = scsi_device_online(sdev);\r\nSCSI_LOG_ERROR_RECOVERY(5, sdev_printk(KERN_INFO, sdev,\r\n"%s: rtn: %d\n", __func__, online));\r\nreturn online;\r\n}\r\nstatic inline void scsi_eh_prt_fail_stats(struct Scsi_Host *shost,\r\nstruct list_head *work_q)\r\n{\r\nstruct scsi_cmnd *scmd;\r\nstruct scsi_device *sdev;\r\nint total_failures = 0;\r\nint cmd_failed = 0;\r\nint cmd_cancel = 0;\r\nint devices_failed = 0;\r\nshost_for_each_device(sdev, shost) {\r\nlist_for_each_entry(scmd, work_q, eh_entry) {\r\nif (scmd->device == sdev) {\r\n++total_failures;\r\nif (scmd->eh_eflags & SCSI_EH_CANCEL_CMD)\r\n++cmd_cancel;\r\nelse\r\n++cmd_failed;\r\n}\r\n}\r\nif (cmd_cancel || cmd_failed) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: cmds failed: %d, cancel: %d\n",\r\n__func__, cmd_failed,\r\ncmd_cancel));\r\ncmd_cancel = 0;\r\ncmd_failed = 0;\r\n++devices_failed;\r\n}\r\n}\r\nSCSI_LOG_ERROR_RECOVERY(2, shost_printk(KERN_INFO, shost,\r\n"Total of %d commands on %d"\r\n" devices require eh work\n",\r\ntotal_failures, devices_failed));\r\n}\r\nstatic void scsi_report_lun_change(struct scsi_device *sdev)\r\n{\r\nsdev->sdev_target->expecting_lun_change = 1;\r\n}\r\nstatic void scsi_report_sense(struct scsi_device *sdev,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nenum scsi_device_event evt_type = SDEV_EVT_MAXBITS;\r\nif (sshdr->sense_key == UNIT_ATTENTION) {\r\nif (sshdr->asc == 0x3f && sshdr->ascq == 0x03) {\r\nevt_type = SDEV_EVT_INQUIRY_CHANGE_REPORTED;\r\nsdev_printk(KERN_WARNING, sdev,\r\n"Inquiry data has changed");\r\n} else if (sshdr->asc == 0x3f && sshdr->ascq == 0x0e) {\r\nevt_type = SDEV_EVT_LUN_CHANGE_REPORTED;\r\nscsi_report_lun_change(sdev);\r\nsdev_printk(KERN_WARNING, sdev,\r\n"Warning! Received an indication that the "\r\n"LUN assignments on this target have "\r\n"changed. The Linux SCSI layer does not "\r\n"automatically remap LUN assignments.\n");\r\n} else if (sshdr->asc == 0x3f)\r\nsdev_printk(KERN_WARNING, sdev,\r\n"Warning! Received an indication that the "\r\n"operating parameters on this target have "\r\n"changed. The Linux SCSI layer does not "\r\n"automatically adjust these parameters.\n");\r\nif (sshdr->asc == 0x38 && sshdr->ascq == 0x07) {\r\nevt_type = SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED;\r\nsdev_printk(KERN_WARNING, sdev,\r\n"Warning! Received an indication that the "\r\n"LUN reached a thin provisioning soft "\r\n"threshold.\n");\r\n}\r\nif (sshdr->asc == 0x2a && sshdr->ascq == 0x01) {\r\nevt_type = SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED;\r\nsdev_printk(KERN_WARNING, sdev,\r\n"Mode parameters changed");\r\n} else if (sshdr->asc == 0x2a && sshdr->ascq == 0x06) {\r\nevt_type = SDEV_EVT_ALUA_STATE_CHANGE_REPORTED;\r\nsdev_printk(KERN_WARNING, sdev,\r\n"Asymmetric access state changed");\r\n} else if (sshdr->asc == 0x2a && sshdr->ascq == 0x09) {\r\nevt_type = SDEV_EVT_CAPACITY_CHANGE_REPORTED;\r\nsdev_printk(KERN_WARNING, sdev,\r\n"Capacity data has changed");\r\n} else if (sshdr->asc == 0x2a)\r\nsdev_printk(KERN_WARNING, sdev,\r\n"Parameters changed");\r\n}\r\nif (evt_type != SDEV_EVT_MAXBITS) {\r\nset_bit(evt_type, sdev->pending_events);\r\nschedule_work(&sdev->event_work);\r\n}\r\n}\r\nint scsi_check_sense(struct scsi_cmnd *scmd)\r\n{\r\nstruct scsi_device *sdev = scmd->device;\r\nstruct scsi_sense_hdr sshdr;\r\nif (! scsi_command_normalize_sense(scmd, &sshdr))\r\nreturn FAILED;\r\nscsi_report_sense(sdev, &sshdr);\r\nif (scsi_sense_is_deferred(&sshdr))\r\nreturn NEEDS_RETRY;\r\nif (sdev->handler && sdev->handler->check_sense) {\r\nint rc;\r\nrc = sdev->handler->check_sense(sdev, &sshdr);\r\nif (rc != SCSI_RETURN_NOT_HANDLED)\r\nreturn rc;\r\n}\r\nif (scmd->cmnd[0] == TEST_UNIT_READY && scmd->scsi_done != scsi_eh_done)\r\nreturn SUCCESS;\r\nif (sshdr.response_code == 0x70) {\r\nif (scmd->sense_buffer[2] & 0xe0)\r\nreturn SUCCESS;\r\n} else {\r\nif ((sshdr.additional_length > 3) &&\r\n(scmd->sense_buffer[8] == 0x4) &&\r\n(scmd->sense_buffer[11] & 0xe0))\r\nreturn SUCCESS;\r\n}\r\nswitch (sshdr.sense_key) {\r\ncase NO_SENSE:\r\nreturn SUCCESS;\r\ncase RECOVERED_ERROR:\r\nreturn SUCCESS;\r\ncase ABORTED_COMMAND:\r\nif (sshdr.asc == 0x10)\r\nreturn SUCCESS;\r\nreturn NEEDS_RETRY;\r\ncase NOT_READY:\r\ncase UNIT_ATTENTION:\r\nif (scmd->device->expecting_cc_ua) {\r\nif (sshdr.asc != 0x28 || sshdr.ascq != 0x00) {\r\nscmd->device->expecting_cc_ua = 0;\r\nreturn NEEDS_RETRY;\r\n}\r\n}\r\nif (scmd->device->sdev_target->expecting_lun_change &&\r\nsshdr.asc == 0x3f && sshdr.ascq == 0x0e)\r\nreturn NEEDS_RETRY;\r\nif ((sshdr.asc == 0x04) && (sshdr.ascq == 0x01))\r\nreturn NEEDS_RETRY;\r\nif (scmd->device->allow_restart &&\r\n(sshdr.asc == 0x04) && (sshdr.ascq == 0x02))\r\nreturn FAILED;\r\nreturn SUCCESS;\r\ncase DATA_PROTECT:\r\nif (sshdr.asc == 0x27 && sshdr.ascq == 0x07) {\r\nset_host_byte(scmd, DID_ALLOC_FAILURE);\r\nreturn SUCCESS;\r\n}\r\ncase COPY_ABORTED:\r\ncase VOLUME_OVERFLOW:\r\ncase MISCOMPARE:\r\ncase BLANK_CHECK:\r\nset_host_byte(scmd, DID_TARGET_FAILURE);\r\nreturn SUCCESS;\r\ncase MEDIUM_ERROR:\r\nif (sshdr.asc == 0x11 ||\r\nsshdr.asc == 0x13 ||\r\nsshdr.asc == 0x14) {\r\nset_host_byte(scmd, DID_MEDIUM_ERROR);\r\nreturn SUCCESS;\r\n}\r\nreturn NEEDS_RETRY;\r\ncase HARDWARE_ERROR:\r\nif (scmd->device->retry_hwerror)\r\nreturn ADD_TO_MLQUEUE;\r\nelse\r\nset_host_byte(scmd, DID_TARGET_FAILURE);\r\ncase ILLEGAL_REQUEST:\r\nif (sshdr.asc == 0x20 ||\r\nsshdr.asc == 0x21 ||\r\nsshdr.asc == 0x24 ||\r\nsshdr.asc == 0x26) {\r\nset_host_byte(scmd, DID_TARGET_FAILURE);\r\n}\r\nreturn SUCCESS;\r\ndefault:\r\nreturn SUCCESS;\r\n}\r\n}\r\nstatic void scsi_handle_queue_ramp_up(struct scsi_device *sdev)\r\n{\r\nstruct scsi_host_template *sht = sdev->host->hostt;\r\nstruct scsi_device *tmp_sdev;\r\nif (!sht->track_queue_depth ||\r\nsdev->queue_depth >= sdev->max_queue_depth)\r\nreturn;\r\nif (time_before(jiffies,\r\nsdev->last_queue_ramp_up + sdev->queue_ramp_up_period))\r\nreturn;\r\nif (time_before(jiffies,\r\nsdev->last_queue_full_time + sdev->queue_ramp_up_period))\r\nreturn;\r\nshost_for_each_device(tmp_sdev, sdev->host) {\r\nif (tmp_sdev->channel != sdev->channel ||\r\ntmp_sdev->id != sdev->id ||\r\ntmp_sdev->queue_depth == sdev->max_queue_depth)\r\ncontinue;\r\nscsi_change_queue_depth(tmp_sdev, tmp_sdev->queue_depth + 1);\r\nsdev->last_queue_ramp_up = jiffies;\r\n}\r\n}\r\nstatic void scsi_handle_queue_full(struct scsi_device *sdev)\r\n{\r\nstruct scsi_host_template *sht = sdev->host->hostt;\r\nstruct scsi_device *tmp_sdev;\r\nif (!sht->track_queue_depth)\r\nreturn;\r\nshost_for_each_device(tmp_sdev, sdev->host) {\r\nif (tmp_sdev->channel != sdev->channel ||\r\ntmp_sdev->id != sdev->id)\r\ncontinue;\r\nscsi_track_queue_full(tmp_sdev, tmp_sdev->queue_depth - 1);\r\n}\r\n}\r\nstatic int scsi_eh_completed_normally(struct scsi_cmnd *scmd)\r\n{\r\nif (host_byte(scmd->result) == DID_RESET) {\r\nreturn scsi_check_sense(scmd);\r\n}\r\nif (host_byte(scmd->result) != DID_OK)\r\nreturn FAILED;\r\nif (msg_byte(scmd->result) != COMMAND_COMPLETE)\r\nreturn FAILED;\r\nswitch (status_byte(scmd->result)) {\r\ncase GOOD:\r\nscsi_handle_queue_ramp_up(scmd->device);\r\ncase COMMAND_TERMINATED:\r\nreturn SUCCESS;\r\ncase CHECK_CONDITION:\r\nreturn scsi_check_sense(scmd);\r\ncase CONDITION_GOOD:\r\ncase INTERMEDIATE_GOOD:\r\ncase INTERMEDIATE_C_GOOD:\r\nreturn SUCCESS;\r\ncase RESERVATION_CONFLICT:\r\nif (scmd->cmnd[0] == TEST_UNIT_READY)\r\nreturn SUCCESS;\r\nreturn FAILED;\r\ncase QUEUE_FULL:\r\nscsi_handle_queue_full(scmd->device);\r\ncase BUSY:\r\nreturn NEEDS_RETRY;\r\ndefault:\r\nreturn FAILED;\r\n}\r\nreturn FAILED;\r\n}\r\nstatic void scsi_eh_done(struct scsi_cmnd *scmd)\r\n{\r\nstruct completion *eh_action;\r\nSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\r\n"%s result: %x\n", __func__, scmd->result));\r\neh_action = scmd->device->host->eh_action;\r\nif (eh_action)\r\ncomplete(eh_action);\r\n}\r\nstatic int scsi_try_host_reset(struct scsi_cmnd *scmd)\r\n{\r\nunsigned long flags;\r\nint rtn;\r\nstruct Scsi_Host *host = scmd->device->host;\r\nstruct scsi_host_template *hostt = host->hostt;\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, host, "Snd Host RST\n"));\r\nif (!hostt->eh_host_reset_handler)\r\nreturn FAILED;\r\nrtn = hostt->eh_host_reset_handler(scmd);\r\nif (rtn == SUCCESS) {\r\nif (!hostt->skip_settle_delay)\r\nssleep(HOST_RESET_SETTLE_TIME);\r\nspin_lock_irqsave(host->host_lock, flags);\r\nscsi_report_bus_reset(host, scmd_channel(scmd));\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int scsi_try_bus_reset(struct scsi_cmnd *scmd)\r\n{\r\nunsigned long flags;\r\nint rtn;\r\nstruct Scsi_Host *host = scmd->device->host;\r\nstruct scsi_host_template *hostt = host->hostt;\r\nSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\r\n"%s: Snd Bus RST\n", __func__));\r\nif (!hostt->eh_bus_reset_handler)\r\nreturn FAILED;\r\nrtn = hostt->eh_bus_reset_handler(scmd);\r\nif (rtn == SUCCESS) {\r\nif (!hostt->skip_settle_delay)\r\nssleep(BUS_RESET_SETTLE_TIME);\r\nspin_lock_irqsave(host->host_lock, flags);\r\nscsi_report_bus_reset(host, scmd_channel(scmd));\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\n}\r\nreturn rtn;\r\n}\r\nstatic void __scsi_report_device_reset(struct scsi_device *sdev, void *data)\r\n{\r\nsdev->was_reset = 1;\r\nsdev->expecting_cc_ua = 1;\r\n}\r\nstatic int scsi_try_target_reset(struct scsi_cmnd *scmd)\r\n{\r\nunsigned long flags;\r\nint rtn;\r\nstruct Scsi_Host *host = scmd->device->host;\r\nstruct scsi_host_template *hostt = host->hostt;\r\nif (!hostt->eh_target_reset_handler)\r\nreturn FAILED;\r\nrtn = hostt->eh_target_reset_handler(scmd);\r\nif (rtn == SUCCESS) {\r\nspin_lock_irqsave(host->host_lock, flags);\r\n__starget_for_each_device(scsi_target(scmd->device), NULL,\r\n__scsi_report_device_reset);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int scsi_try_bus_device_reset(struct scsi_cmnd *scmd)\r\n{\r\nint rtn;\r\nstruct scsi_host_template *hostt = scmd->device->host->hostt;\r\nif (!hostt->eh_device_reset_handler)\r\nreturn FAILED;\r\nrtn = hostt->eh_device_reset_handler(scmd);\r\nif (rtn == SUCCESS)\r\n__scsi_report_device_reset(scmd->device, NULL);\r\nreturn rtn;\r\n}\r\nstatic int scsi_try_to_abort_cmd(struct scsi_host_template *hostt,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nif (!hostt->eh_abort_handler)\r\nreturn FAILED;\r\nreturn hostt->eh_abort_handler(scmd);\r\n}\r\nstatic void scsi_abort_eh_cmnd(struct scsi_cmnd *scmd)\r\n{\r\nif (scsi_try_to_abort_cmd(scmd->device->host->hostt, scmd) != SUCCESS)\r\nif (scsi_try_bus_device_reset(scmd) != SUCCESS)\r\nif (scsi_try_target_reset(scmd) != SUCCESS)\r\nif (scsi_try_bus_reset(scmd) != SUCCESS)\r\nscsi_try_host_reset(scmd);\r\n}\r\nvoid scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,\r\nunsigned char *cmnd, int cmnd_size, unsigned sense_bytes)\r\n{\r\nstruct scsi_device *sdev = scmd->device;\r\nses->cmd_len = scmd->cmd_len;\r\nses->cmnd = scmd->cmnd;\r\nses->data_direction = scmd->sc_data_direction;\r\nses->sdb = scmd->sdb;\r\nses->next_rq = scmd->request->next_rq;\r\nses->result = scmd->result;\r\nses->underflow = scmd->underflow;\r\nses->prot_op = scmd->prot_op;\r\nscmd->prot_op = SCSI_PROT_NORMAL;\r\nscmd->eh_eflags = 0;\r\nscmd->cmnd = ses->eh_cmnd;\r\nmemset(scmd->cmnd, 0, BLK_MAX_CDB);\r\nmemset(&scmd->sdb, 0, sizeof(scmd->sdb));\r\nscmd->request->next_rq = NULL;\r\nscmd->result = 0;\r\nif (sense_bytes) {\r\nscmd->sdb.length = min_t(unsigned, SCSI_SENSE_BUFFERSIZE,\r\nsense_bytes);\r\nsg_init_one(&ses->sense_sgl, scmd->sense_buffer,\r\nscmd->sdb.length);\r\nscmd->sdb.table.sgl = &ses->sense_sgl;\r\nscmd->sc_data_direction = DMA_FROM_DEVICE;\r\nscmd->sdb.table.nents = scmd->sdb.table.orig_nents = 1;\r\nscmd->cmnd[0] = REQUEST_SENSE;\r\nscmd->cmnd[4] = scmd->sdb.length;\r\nscmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);\r\n} else {\r\nscmd->sc_data_direction = DMA_NONE;\r\nif (cmnd) {\r\nBUG_ON(cmnd_size > BLK_MAX_CDB);\r\nmemcpy(scmd->cmnd, cmnd, cmnd_size);\r\nscmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);\r\n}\r\n}\r\nscmd->underflow = 0;\r\nif (sdev->scsi_level <= SCSI_2 && sdev->scsi_level != SCSI_UNKNOWN)\r\nscmd->cmnd[1] = (scmd->cmnd[1] & 0x1f) |\r\n(sdev->lun << 5 & 0xe0);\r\nmemset(scmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\n}\r\nvoid scsi_eh_restore_cmnd(struct scsi_cmnd* scmd, struct scsi_eh_save *ses)\r\n{\r\nscmd->cmd_len = ses->cmd_len;\r\nscmd->cmnd = ses->cmnd;\r\nscmd->sc_data_direction = ses->data_direction;\r\nscmd->sdb = ses->sdb;\r\nscmd->request->next_rq = ses->next_rq;\r\nscmd->result = ses->result;\r\nscmd->underflow = ses->underflow;\r\nscmd->prot_op = ses->prot_op;\r\n}\r\nstatic int scsi_send_eh_cmnd(struct scsi_cmnd *scmd, unsigned char *cmnd,\r\nint cmnd_size, int timeout, unsigned sense_bytes)\r\n{\r\nstruct scsi_device *sdev = scmd->device;\r\nstruct Scsi_Host *shost = sdev->host;\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nunsigned long timeleft = timeout;\r\nstruct scsi_eh_save ses;\r\nconst unsigned long stall_for = msecs_to_jiffies(100);\r\nint rtn;\r\nretry:\r\nscsi_eh_prep_cmnd(scmd, &ses, cmnd, cmnd_size, sense_bytes);\r\nshost->eh_action = &done;\r\nscsi_log_send(scmd);\r\nscmd->scsi_done = scsi_eh_done;\r\nrtn = shost->hostt->queuecommand(shost, scmd);\r\nif (rtn) {\r\nif (timeleft > stall_for) {\r\nscsi_eh_restore_cmnd(scmd, &ses);\r\ntimeleft -= stall_for;\r\nmsleep(jiffies_to_msecs(stall_for));\r\ngoto retry;\r\n}\r\ntimeleft = 0;\r\nrtn = FAILED;\r\n} else {\r\ntimeleft = wait_for_completion_timeout(&done, timeout);\r\nrtn = SUCCESS;\r\n}\r\nshost->eh_action = NULL;\r\nscsi_log_completion(scmd, rtn);\r\nSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\r\n"%s timeleft: %ld\n",\r\n__func__, timeleft));\r\nif (timeleft) {\r\nrtn = scsi_eh_completed_normally(scmd);\r\nSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\r\n"%s: scsi_eh_completed_normally %x\n", __func__, rtn));\r\nswitch (rtn) {\r\ncase SUCCESS:\r\ncase NEEDS_RETRY:\r\ncase FAILED:\r\nbreak;\r\ncase ADD_TO_MLQUEUE:\r\nrtn = NEEDS_RETRY;\r\nbreak;\r\ndefault:\r\nrtn = FAILED;\r\nbreak;\r\n}\r\n} else if (rtn != FAILED) {\r\nscsi_abort_eh_cmnd(scmd);\r\nrtn = FAILED;\r\n}\r\nscsi_eh_restore_cmnd(scmd, &ses);\r\nreturn rtn;\r\n}\r\nstatic int scsi_request_sense(struct scsi_cmnd *scmd)\r\n{\r\nreturn scsi_send_eh_cmnd(scmd, NULL, 0, scmd->device->eh_timeout, ~0);\r\n}\r\nstatic int scsi_eh_action(struct scsi_cmnd *scmd, int rtn)\r\n{\r\nif (scmd->request->cmd_type != REQ_TYPE_BLOCK_PC) {\r\nstruct scsi_driver *sdrv = scsi_cmd_to_driver(scmd);\r\nif (sdrv->eh_action)\r\nrtn = sdrv->eh_action(scmd, rtn);\r\n}\r\nreturn rtn;\r\n}\r\nvoid scsi_eh_finish_cmd(struct scsi_cmnd *scmd, struct list_head *done_q)\r\n{\r\nscmd->eh_eflags = 0;\r\nlist_move_tail(&scmd->eh_entry, done_q);\r\n}\r\nint scsi_eh_get_sense(struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nstruct Scsi_Host *shost;\r\nint rtn;\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nif ((scmd->eh_eflags & SCSI_EH_CANCEL_CMD) ||\r\n(scmd->eh_eflags & SCSI_EH_ABORT_SCHEDULED) ||\r\nSCSI_SENSE_VALID(scmd))\r\ncontinue;\r\nshost = scmd->device->host;\r\nif (scsi_host_eh_past_deadline(shost)) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"%s: skip request sense, past eh deadline\n",\r\ncurrent->comm));\r\nbreak;\r\n}\r\nif (status_byte(scmd->result) != CHECK_CONDITION)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(2, scmd_printk(KERN_INFO, scmd,\r\n"%s: requesting sense\n",\r\ncurrent->comm));\r\nrtn = scsi_request_sense(scmd);\r\nif (rtn != SUCCESS)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\r\n"sense requested, result %x\n", scmd->result));\r\nSCSI_LOG_ERROR_RECOVERY(3, scsi_print_sense(scmd));\r\nrtn = scsi_decide_disposition(scmd);\r\nif (rtn == SUCCESS)\r\nscmd->retries = scmd->allowed;\r\nelse if (rtn != NEEDS_RETRY)\r\ncontinue;\r\nscsi_eh_finish_cmd(scmd, done_q);\r\n}\r\nreturn list_empty(work_q);\r\n}\r\nstatic int scsi_eh_tur(struct scsi_cmnd *scmd)\r\n{\r\nstatic unsigned char tur_command[6] = {TEST_UNIT_READY, 0, 0, 0, 0, 0};\r\nint retry_cnt = 1, rtn;\r\nretry_tur:\r\nrtn = scsi_send_eh_cmnd(scmd, tur_command, 6,\r\nscmd->device->eh_timeout, 0);\r\nSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\r\n"%s return: %x\n", __func__, rtn));\r\nswitch (rtn) {\r\ncase NEEDS_RETRY:\r\nif (retry_cnt--)\r\ngoto retry_tur;\r\ncase SUCCESS:\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int scsi_eh_test_devices(struct list_head *cmd_list,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q, int try_stu)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nstruct scsi_device *sdev;\r\nint finish_cmds;\r\nwhile (!list_empty(cmd_list)) {\r\nscmd = list_entry(cmd_list->next, struct scsi_cmnd, eh_entry);\r\nsdev = scmd->device;\r\nif (!try_stu) {\r\nif (scsi_host_eh_past_deadline(sdev->host)) {\r\nlist_splice_init(cmd_list, work_q);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: skip test device, past eh deadline",\r\ncurrent->comm));\r\nbreak;\r\n}\r\n}\r\nfinish_cmds = !scsi_device_online(scmd->device) ||\r\n(try_stu && !scsi_eh_try_stu(scmd) &&\r\n!scsi_eh_tur(scmd)) ||\r\n!scsi_eh_tur(scmd);\r\nlist_for_each_entry_safe(scmd, next, cmd_list, eh_entry)\r\nif (scmd->device == sdev) {\r\nif (finish_cmds &&\r\n(try_stu ||\r\nscsi_eh_action(scmd, SUCCESS) == SUCCESS))\r\nscsi_eh_finish_cmd(scmd, done_q);\r\nelse\r\nlist_move_tail(&scmd->eh_entry, work_q);\r\n}\r\n}\r\nreturn list_empty(work_q);\r\n}\r\nstatic int scsi_eh_abort_cmds(struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nLIST_HEAD(check_list);\r\nint rtn;\r\nstruct Scsi_Host *shost;\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nif (!(scmd->eh_eflags & SCSI_EH_CANCEL_CMD))\r\ncontinue;\r\nshost = scmd->device->host;\r\nif (scsi_host_eh_past_deadline(shost)) {\r\nlist_splice_init(&check_list, work_q);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"%s: skip aborting cmd, past eh deadline\n",\r\ncurrent->comm));\r\nreturn list_empty(work_q);\r\n}\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"%s: aborting cmd\n", current->comm));\r\nrtn = scsi_try_to_abort_cmd(shost->hostt, scmd);\r\nif (rtn == FAILED) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"%s: aborting cmd failed\n",\r\ncurrent->comm));\r\nlist_splice_init(&check_list, work_q);\r\nreturn list_empty(work_q);\r\n}\r\nscmd->eh_eflags &= ~SCSI_EH_CANCEL_CMD;\r\nif (rtn == FAST_IO_FAIL)\r\nscsi_eh_finish_cmd(scmd, done_q);\r\nelse\r\nlist_move_tail(&scmd->eh_entry, &check_list);\r\n}\r\nreturn scsi_eh_test_devices(&check_list, work_q, done_q, 0);\r\n}\r\nstatic int scsi_eh_try_stu(struct scsi_cmnd *scmd)\r\n{\r\nstatic unsigned char stu_command[6] = {START_STOP, 0, 0, 0, 1, 0};\r\nif (scmd->device->allow_restart) {\r\nint i, rtn = NEEDS_RETRY;\r\nfor (i = 0; rtn == NEEDS_RETRY && i < 2; i++)\r\nrtn = scsi_send_eh_cmnd(scmd, stu_command, 6, scmd->device->request_queue->rq_timeout, 0);\r\nif (rtn == SUCCESS)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int scsi_eh_stu(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *stu_scmd, *next;\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, shost) {\r\nif (scsi_host_eh_past_deadline(shost)) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: skip START_UNIT, past eh deadline\n",\r\ncurrent->comm));\r\nbreak;\r\n}\r\nstu_scmd = NULL;\r\nlist_for_each_entry(scmd, work_q, eh_entry)\r\nif (scmd->device == sdev && SCSI_SENSE_VALID(scmd) &&\r\nscsi_check_sense(scmd) == FAILED ) {\r\nstu_scmd = scmd;\r\nbreak;\r\n}\r\nif (!stu_scmd)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: Sending START_UNIT\n",\r\ncurrent->comm));\r\nif (!scsi_eh_try_stu(stu_scmd)) {\r\nif (!scsi_device_online(sdev) ||\r\n!scsi_eh_tur(stu_scmd)) {\r\nlist_for_each_entry_safe(scmd, next,\r\nwork_q, eh_entry) {\r\nif (scmd->device == sdev &&\r\nscsi_eh_action(scmd, SUCCESS) == SUCCESS)\r\nscsi_eh_finish_cmd(scmd, done_q);\r\n}\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: START_UNIT failed\n",\r\ncurrent->comm));\r\n}\r\n}\r\nreturn list_empty(work_q);\r\n}\r\nstatic int scsi_eh_bus_device_reset(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *bdr_scmd, *next;\r\nstruct scsi_device *sdev;\r\nint rtn;\r\nshost_for_each_device(sdev, shost) {\r\nif (scsi_host_eh_past_deadline(shost)) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: skip BDR, past eh deadline\n",\r\ncurrent->comm));\r\nbreak;\r\n}\r\nbdr_scmd = NULL;\r\nlist_for_each_entry(scmd, work_q, eh_entry)\r\nif (scmd->device == sdev) {\r\nbdr_scmd = scmd;\r\nbreak;\r\n}\r\nif (!bdr_scmd)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: Sending BDR\n", current->comm));\r\nrtn = scsi_try_bus_device_reset(bdr_scmd);\r\nif (rtn == SUCCESS || rtn == FAST_IO_FAIL) {\r\nif (!scsi_device_online(sdev) ||\r\nrtn == FAST_IO_FAIL ||\r\n!scsi_eh_tur(bdr_scmd)) {\r\nlist_for_each_entry_safe(scmd, next,\r\nwork_q, eh_entry) {\r\nif (scmd->device == sdev &&\r\nscsi_eh_action(scmd, rtn) != FAILED)\r\nscsi_eh_finish_cmd(scmd,\r\ndone_q);\r\n}\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: BDR failed\n", current->comm));\r\n}\r\n}\r\nreturn list_empty(work_q);\r\n}\r\nstatic int scsi_eh_target_reset(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nLIST_HEAD(tmp_list);\r\nLIST_HEAD(check_list);\r\nlist_splice_init(work_q, &tmp_list);\r\nwhile (!list_empty(&tmp_list)) {\r\nstruct scsi_cmnd *next, *scmd;\r\nint rtn;\r\nunsigned int id;\r\nif (scsi_host_eh_past_deadline(shost)) {\r\nlist_splice_init(&check_list, work_q);\r\nlist_splice_init(&tmp_list, work_q);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: Skip target reset, past eh deadline\n",\r\ncurrent->comm));\r\nreturn list_empty(work_q);\r\n}\r\nscmd = list_entry(tmp_list.next, struct scsi_cmnd, eh_entry);\r\nid = scmd_id(scmd);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: Sending target reset to target %d\n",\r\ncurrent->comm, id));\r\nrtn = scsi_try_target_reset(scmd);\r\nif (rtn != SUCCESS && rtn != FAST_IO_FAIL)\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: Target reset failed"\r\n" target: %d\n",\r\ncurrent->comm, id));\r\nlist_for_each_entry_safe(scmd, next, &tmp_list, eh_entry) {\r\nif (scmd_id(scmd) != id)\r\ncontinue;\r\nif (rtn == SUCCESS)\r\nlist_move_tail(&scmd->eh_entry, &check_list);\r\nelse if (rtn == FAST_IO_FAIL)\r\nscsi_eh_finish_cmd(scmd, done_q);\r\nelse\r\nlist_move(&scmd->eh_entry, work_q);\r\n}\r\n}\r\nreturn scsi_eh_test_devices(&check_list, work_q, done_q, 0);\r\n}\r\nstatic int scsi_eh_bus_reset(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *chan_scmd, *next;\r\nLIST_HEAD(check_list);\r\nunsigned int channel;\r\nint rtn;\r\nfor (channel = 0; channel <= shost->max_channel; channel++) {\r\nif (scsi_host_eh_past_deadline(shost)) {\r\nlist_splice_init(&check_list, work_q);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: skip BRST, past eh deadline\n",\r\ncurrent->comm));\r\nreturn list_empty(work_q);\r\n}\r\nchan_scmd = NULL;\r\nlist_for_each_entry(scmd, work_q, eh_entry) {\r\nif (channel == scmd_channel(scmd)) {\r\nchan_scmd = scmd;\r\nbreak;\r\n}\r\n}\r\nif (!chan_scmd)\r\ncontinue;\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: Sending BRST chan: %d\n",\r\ncurrent->comm, channel));\r\nrtn = scsi_try_bus_reset(chan_scmd);\r\nif (rtn == SUCCESS || rtn == FAST_IO_FAIL) {\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nif (channel == scmd_channel(scmd)) {\r\nif (rtn == FAST_IO_FAIL)\r\nscsi_eh_finish_cmd(scmd,\r\ndone_q);\r\nelse\r\nlist_move_tail(&scmd->eh_entry,\r\n&check_list);\r\n}\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: BRST failed chan: %d\n",\r\ncurrent->comm, channel));\r\n}\r\n}\r\nreturn scsi_eh_test_devices(&check_list, work_q, done_q, 0);\r\n}\r\nstatic int scsi_eh_host_reset(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nLIST_HEAD(check_list);\r\nint rtn;\r\nif (!list_empty(work_q)) {\r\nscmd = list_entry(work_q->next,\r\nstruct scsi_cmnd, eh_entry);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: Sending HRST\n",\r\ncurrent->comm));\r\nrtn = scsi_try_host_reset(scmd);\r\nif (rtn == SUCCESS) {\r\nlist_splice_init(work_q, &check_list);\r\n} else if (rtn == FAST_IO_FAIL) {\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nscsi_eh_finish_cmd(scmd, done_q);\r\n}\r\n} else {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"%s: HRST failed\n",\r\ncurrent->comm));\r\n}\r\n}\r\nreturn scsi_eh_test_devices(&check_list, work_q, done_q, 1);\r\n}\r\nstatic void scsi_eh_offline_sdevs(struct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\r\nsdev_printk(KERN_INFO, scmd->device, "Device offlined - "\r\n"not ready after error recovery\n");\r\nscsi_device_set_state(scmd->device, SDEV_OFFLINE);\r\nif (scmd->eh_eflags & SCSI_EH_CANCEL_CMD) {\r\n}\r\nscsi_eh_finish_cmd(scmd, done_q);\r\n}\r\nreturn;\r\n}\r\nint scsi_noretry_cmd(struct scsi_cmnd *scmd)\r\n{\r\nswitch (host_byte(scmd->result)) {\r\ncase DID_OK:\r\nbreak;\r\ncase DID_TIME_OUT:\r\ngoto check_type;\r\ncase DID_BUS_BUSY:\r\nreturn (scmd->request->cmd_flags & REQ_FAILFAST_TRANSPORT);\r\ncase DID_PARITY:\r\nreturn (scmd->request->cmd_flags & REQ_FAILFAST_DEV);\r\ncase DID_ERROR:\r\nif (msg_byte(scmd->result) == COMMAND_COMPLETE &&\r\nstatus_byte(scmd->result) == RESERVATION_CONFLICT)\r\nreturn 0;\r\ncase DID_SOFT_ERROR:\r\nreturn (scmd->request->cmd_flags & REQ_FAILFAST_DRIVER);\r\n}\r\nif (status_byte(scmd->result) != CHECK_CONDITION)\r\nreturn 0;\r\ncheck_type:\r\nif (scmd->request->cmd_flags & REQ_FAILFAST_DEV ||\r\nscmd->request->cmd_type == REQ_TYPE_BLOCK_PC)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nint scsi_decide_disposition(struct scsi_cmnd *scmd)\r\n{\r\nint rtn;\r\nif (!scsi_device_online(scmd->device)) {\r\nSCSI_LOG_ERROR_RECOVERY(5, scmd_printk(KERN_INFO, scmd,\r\n"%s: device offline - report as SUCCESS\n", __func__));\r\nreturn SUCCESS;\r\n}\r\nswitch (host_byte(scmd->result)) {\r\ncase DID_PASSTHROUGH:\r\nscmd->result &= 0xff00ffff;\r\nreturn SUCCESS;\r\ncase DID_OK:\r\nbreak;\r\ncase DID_ABORT:\r\nif (scmd->eh_eflags & SCSI_EH_ABORT_SCHEDULED) {\r\nset_host_byte(scmd, DID_TIME_OUT);\r\nreturn SUCCESS;\r\n}\r\ncase DID_NO_CONNECT:\r\ncase DID_BAD_TARGET:\r\nreturn SUCCESS;\r\ncase DID_SOFT_ERROR:\r\ngoto maybe_retry;\r\ncase DID_IMM_RETRY:\r\nreturn NEEDS_RETRY;\r\ncase DID_REQUEUE:\r\nreturn ADD_TO_MLQUEUE;\r\ncase DID_TRANSPORT_DISRUPTED:\r\ngoto maybe_retry;\r\ncase DID_TRANSPORT_FAILFAST:\r\nreturn SUCCESS;\r\ncase DID_ERROR:\r\nif (msg_byte(scmd->result) == COMMAND_COMPLETE &&\r\nstatus_byte(scmd->result) == RESERVATION_CONFLICT)\r\nbreak;\r\ncase DID_BUS_BUSY:\r\ncase DID_PARITY:\r\ngoto maybe_retry;\r\ncase DID_TIME_OUT:\r\nif ((scmd->cmnd[0] == TEST_UNIT_READY ||\r\nscmd->cmnd[0] == INQUIRY)) {\r\nreturn SUCCESS;\r\n} else {\r\nreturn FAILED;\r\n}\r\ncase DID_RESET:\r\nreturn SUCCESS;\r\ndefault:\r\nreturn FAILED;\r\n}\r\nif (msg_byte(scmd->result) != COMMAND_COMPLETE)\r\nreturn FAILED;\r\nswitch (status_byte(scmd->result)) {\r\ncase QUEUE_FULL:\r\nscsi_handle_queue_full(scmd->device);\r\ncase BUSY:\r\nreturn ADD_TO_MLQUEUE;\r\ncase GOOD:\r\nif (scmd->cmnd[0] == REPORT_LUNS)\r\nscmd->device->sdev_target->expecting_lun_change = 0;\r\nscsi_handle_queue_ramp_up(scmd->device);\r\ncase COMMAND_TERMINATED:\r\nreturn SUCCESS;\r\ncase TASK_ABORTED:\r\ngoto maybe_retry;\r\ncase CHECK_CONDITION:\r\nrtn = scsi_check_sense(scmd);\r\nif (rtn == NEEDS_RETRY)\r\ngoto maybe_retry;\r\nreturn rtn;\r\ncase CONDITION_GOOD:\r\ncase INTERMEDIATE_GOOD:\r\ncase INTERMEDIATE_C_GOOD:\r\ncase ACA_ACTIVE:\r\nreturn SUCCESS;\r\ncase RESERVATION_CONFLICT:\r\nsdev_printk(KERN_INFO, scmd->device,\r\n"reservation conflict\n");\r\nset_host_byte(scmd, DID_NEXUS_FAILURE);\r\nreturn SUCCESS;\r\ndefault:\r\nreturn FAILED;\r\n}\r\nreturn FAILED;\r\nmaybe_retry:\r\nif ((++scmd->retries) <= scmd->allowed\r\n&& !scsi_noretry_cmd(scmd)) {\r\nreturn NEEDS_RETRY;\r\n} else {\r\nreturn SUCCESS;\r\n}\r\n}\r\nstatic void eh_lock_door_done(struct request *req, int uptodate)\r\n{\r\n__blk_put_request(req->q, req);\r\n}\r\nstatic void scsi_eh_lock_door(struct scsi_device *sdev)\r\n{\r\nstruct request *req;\r\nreq = blk_get_request(sdev->request_queue, READ, GFP_KERNEL);\r\nif (IS_ERR(req))\r\nreturn;\r\nblk_rq_set_block_pc(req);\r\nreq->cmd[0] = ALLOW_MEDIUM_REMOVAL;\r\nreq->cmd[1] = 0;\r\nreq->cmd[2] = 0;\r\nreq->cmd[3] = 0;\r\nreq->cmd[4] = SCSI_REMOVAL_PREVENT;\r\nreq->cmd[5] = 0;\r\nreq->cmd_len = COMMAND_SIZE(req->cmd[0]);\r\nreq->cmd_flags |= REQ_QUIET;\r\nreq->timeout = 10 * HZ;\r\nreq->retries = 5;\r\nblk_execute_rq_nowait(req->q, NULL, req, 1, eh_lock_door_done);\r\n}\r\nstatic void scsi_restart_operations(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nshost_for_each_device(sdev, shost) {\r\nif (scsi_device_online(sdev) && sdev->was_reset && sdev->locked) {\r\nscsi_eh_lock_door(sdev);\r\nsdev->was_reset = 0;\r\n}\r\n}\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost, "waking up host to restart\n"));\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_set_state(shost, SHOST_RUNNING))\r\nif (scsi_host_set_state(shost, SHOST_CANCEL))\r\nBUG_ON(scsi_host_set_state(shost, SHOST_DEL));\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nwake_up(&shost->host_wait);\r\nscsi_run_host_queues(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (shost->host_eh_scheduled)\r\nif (scsi_host_set_state(shost, SHOST_RECOVERY))\r\nWARN_ON(scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY));\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nvoid scsi_eh_ready_devs(struct Scsi_Host *shost,\r\nstruct list_head *work_q,\r\nstruct list_head *done_q)\r\n{\r\nif (!scsi_eh_stu(shost, work_q, done_q))\r\nif (!scsi_eh_bus_device_reset(shost, work_q, done_q))\r\nif (!scsi_eh_target_reset(shost, work_q, done_q))\r\nif (!scsi_eh_bus_reset(shost, work_q, done_q))\r\nif (!scsi_eh_host_reset(shost, work_q, done_q))\r\nscsi_eh_offline_sdevs(work_q,\r\ndone_q);\r\n}\r\nvoid scsi_eh_flush_done_q(struct list_head *done_q)\r\n{\r\nstruct scsi_cmnd *scmd, *next;\r\nlist_for_each_entry_safe(scmd, next, done_q, eh_entry) {\r\nlist_del_init(&scmd->eh_entry);\r\nif (scsi_device_online(scmd->device) &&\r\n!scsi_noretry_cmd(scmd) &&\r\n(++scmd->retries <= scmd->allowed)) {\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"%s: flush retry cmd\n",\r\ncurrent->comm));\r\nscsi_queue_insert(scmd, SCSI_MLQUEUE_EH_RETRY);\r\n} else {\r\nif (!scmd->result)\r\nscmd->result |= (DRIVER_TIMEOUT << 24);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nscmd_printk(KERN_INFO, scmd,\r\n"%s: flush finish cmd\n",\r\ncurrent->comm));\r\nscsi_finish_command(scmd);\r\n}\r\n}\r\n}\r\nstatic void scsi_unjam_host(struct Scsi_Host *shost)\r\n{\r\nunsigned long flags;\r\nLIST_HEAD(eh_work_q);\r\nLIST_HEAD(eh_done_q);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_splice_init(&shost->eh_cmd_q, &eh_work_q);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nSCSI_LOG_ERROR_RECOVERY(1, scsi_eh_prt_fail_stats(shost, &eh_work_q));\r\nif (!scsi_eh_get_sense(&eh_work_q, &eh_done_q))\r\nif (!scsi_eh_abort_cmds(&eh_work_q, &eh_done_q))\r\nscsi_eh_ready_devs(shost, &eh_work_q, &eh_done_q);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (shost->eh_deadline != -1)\r\nshost->last_reset = 0;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_eh_flush_done_q(&eh_done_q);\r\n}\r\nint scsi_error_handler(void *data)\r\n{\r\nstruct Scsi_Host *shost = data;\r\nwhile (true) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (kthread_should_stop())\r\nbreak;\r\nif ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||\r\nshost->host_failed != atomic_read(&shost->host_busy)) {\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nshost_printk(KERN_INFO, shost,\r\n"scsi_eh_%d: sleeping\n",\r\nshost->host_no));\r\nschedule();\r\ncontinue;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nshost_printk(KERN_INFO, shost,\r\n"scsi_eh_%d: waking up %d/%d/%d\n",\r\nshost->host_no, shost->host_eh_scheduled,\r\nshost->host_failed,\r\natomic_read(&shost->host_busy)));\r\nif (!shost->eh_noresume && scsi_autopm_get_host(shost) != 0) {\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nshost_printk(KERN_ERR, shost,\r\n"scsi_eh_%d: unable to autoresume\n",\r\nshost->host_no));\r\ncontinue;\r\n}\r\nif (shost->transportt->eh_strategy_handler)\r\nshost->transportt->eh_strategy_handler(shost);\r\nelse\r\nscsi_unjam_host(shost);\r\nshost->host_failed = 0;\r\nscsi_restart_operations(shost);\r\nif (!shost->eh_noresume)\r\nscsi_autopm_put_host(shost);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nshost_printk(KERN_INFO, shost,\r\n"Error handler scsi_eh_%d exiting\n",\r\nshost->host_no));\r\nshost->ehandler = NULL;\r\nreturn 0;\r\n}\r\nvoid scsi_report_bus_reset(struct Scsi_Host *shost, int channel)\r\n{\r\nstruct scsi_device *sdev;\r\n__shost_for_each_device(sdev, shost) {\r\nif (channel == sdev_channel(sdev))\r\n__scsi_report_device_reset(sdev, NULL);\r\n}\r\n}\r\nvoid scsi_report_device_reset(struct Scsi_Host *shost, int channel, int target)\r\n{\r\nstruct scsi_device *sdev;\r\n__shost_for_each_device(sdev, shost) {\r\nif (channel == sdev_channel(sdev) &&\r\ntarget == sdev_id(sdev))\r\n__scsi_report_device_reset(sdev, NULL);\r\n}\r\n}\r\nstatic void\r\nscsi_reset_provider_done_command(struct scsi_cmnd *scmd)\r\n{\r\n}\r\nint\r\nscsi_ioctl_reset(struct scsi_device *dev, int __user *arg)\r\n{\r\nstruct scsi_cmnd *scmd;\r\nstruct Scsi_Host *shost = dev->host;\r\nstruct request req;\r\nunsigned long flags;\r\nint error = 0, rtn, val;\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nerror = get_user(val, arg);\r\nif (error)\r\nreturn error;\r\nif (scsi_autopm_get_host(shost) < 0)\r\nreturn -EIO;\r\nerror = -EIO;\r\nscmd = scsi_get_command(dev, GFP_KERNEL);\r\nif (!scmd)\r\ngoto out_put_autopm_host;\r\nblk_rq_init(NULL, &req);\r\nscmd->request = &req;\r\nscmd->cmnd = req.cmd;\r\nscmd->scsi_done = scsi_reset_provider_done_command;\r\nmemset(&scmd->sdb, 0, sizeof(scmd->sdb));\r\nscmd->cmd_len = 0;\r\nscmd->sc_data_direction = DMA_BIDIRECTIONAL;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nshost->tmf_in_progress = 1;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nswitch (val & ~SG_SCSI_RESET_NO_ESCALATE) {\r\ncase SG_SCSI_RESET_NOTHING:\r\nrtn = SUCCESS;\r\nbreak;\r\ncase SG_SCSI_RESET_DEVICE:\r\nrtn = scsi_try_bus_device_reset(scmd);\r\nif (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))\r\nbreak;\r\ncase SG_SCSI_RESET_TARGET:\r\nrtn = scsi_try_target_reset(scmd);\r\nif (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))\r\nbreak;\r\ncase SG_SCSI_RESET_BUS:\r\nrtn = scsi_try_bus_reset(scmd);\r\nif (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))\r\nbreak;\r\ncase SG_SCSI_RESET_HOST:\r\nrtn = scsi_try_host_reset(scmd);\r\nif (rtn == SUCCESS)\r\nbreak;\r\ndefault:\r\nrtn = FAILED;\r\nbreak;\r\n}\r\nerror = (rtn == SUCCESS) ? 0 : -EIO;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nshost->tmf_in_progress = 0;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nSCSI_LOG_ERROR_RECOVERY(3,\r\nshost_printk(KERN_INFO, shost,\r\n"waking up host to restart after TMF\n"));\r\nwake_up(&shost->host_wait);\r\nscsi_run_host_queues(shost);\r\nscsi_put_command(scmd);\r\nout_put_autopm_host:\r\nscsi_autopm_put_host(shost);\r\nreturn error;\r\n}\r\nbool scsi_command_normalize_sense(const struct scsi_cmnd *cmd,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nreturn scsi_normalize_sense(cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, sshdr);\r\n}\r\nint scsi_get_sense_info_fld(const u8 * sense_buffer, int sb_len,\r\nu64 * info_out)\r\n{\r\nint j;\r\nconst u8 * ucp;\r\nu64 ull;\r\nif (sb_len < 7)\r\nreturn 0;\r\nswitch (sense_buffer[0] & 0x7f) {\r\ncase 0x70:\r\ncase 0x71:\r\nif (sense_buffer[0] & 0x80) {\r\n*info_out = (sense_buffer[3] << 24) +\r\n(sense_buffer[4] << 16) +\r\n(sense_buffer[5] << 8) + sense_buffer[6];\r\nreturn 1;\r\n} else\r\nreturn 0;\r\ncase 0x72:\r\ncase 0x73:\r\nucp = scsi_sense_desc_find(sense_buffer, sb_len,\r\n0 );\r\nif (ucp && (0xa == ucp[1])) {\r\null = 0;\r\nfor (j = 0; j < 8; ++j) {\r\nif (j > 0)\r\null <<= 8;\r\null |= ucp[4 + j];\r\n}\r\n*info_out = ull;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}
