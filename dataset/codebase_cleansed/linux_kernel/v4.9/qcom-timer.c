static irqreturn_t msm_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nif (clockevent_state_oneshot(evt)) {\r\nu32 ctrl = readl_relaxed(event_base + TIMER_ENABLE);\r\nctrl &= ~TIMER_ENABLE_EN;\r\nwritel_relaxed(ctrl, event_base + TIMER_ENABLE);\r\n}\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int msm_timer_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nu32 ctrl = readl_relaxed(event_base + TIMER_ENABLE);\r\nctrl &= ~TIMER_ENABLE_EN;\r\nwritel_relaxed(ctrl, event_base + TIMER_ENABLE);\r\nwritel_relaxed(ctrl, event_base + TIMER_CLEAR);\r\nwritel_relaxed(cycles, event_base + TIMER_MATCH_VAL);\r\nif (sts_base)\r\nwhile (readl_relaxed(sts_base) & TIMER_STS_GPT0_CLR_PEND)\r\ncpu_relax();\r\nwritel_relaxed(ctrl | TIMER_ENABLE_EN, event_base + TIMER_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int msm_timer_shutdown(struct clock_event_device *evt)\r\n{\r\nu32 ctrl;\r\nctrl = readl_relaxed(event_base + TIMER_ENABLE);\r\nctrl &= ~(TIMER_ENABLE_EN | TIMER_ENABLE_CLR_ON_MATCH_EN);\r\nwritel_relaxed(ctrl, event_base + TIMER_ENABLE);\r\nreturn 0;\r\n}\r\nstatic notrace cycle_t msm_read_timer_count(struct clocksource *cs)\r\n{\r\nreturn readl_relaxed(source_base + TIMER_COUNT_VAL);\r\n}\r\nstatic int msm_local_timer_starting_cpu(unsigned int cpu)\r\n{\r\nstruct clock_event_device *evt = per_cpu_ptr(msm_evt, cpu);\r\nint err;\r\nevt->irq = msm_timer_irq;\r\nevt->name = "msm_timer";\r\nevt->features = CLOCK_EVT_FEAT_ONESHOT;\r\nevt->rating = 200;\r\nevt->set_state_shutdown = msm_timer_shutdown;\r\nevt->set_state_oneshot = msm_timer_shutdown;\r\nevt->tick_resume = msm_timer_shutdown;\r\nevt->set_next_event = msm_timer_set_next_event;\r\nevt->cpumask = cpumask_of(cpu);\r\nclockevents_config_and_register(evt, GPT_HZ, 4, 0xffffffff);\r\nif (msm_timer_has_ppi) {\r\nenable_percpu_irq(evt->irq, IRQ_TYPE_EDGE_RISING);\r\n} else {\r\nerr = request_irq(evt->irq, msm_timer_interrupt,\r\nIRQF_TIMER | IRQF_NOBALANCING |\r\nIRQF_TRIGGER_RISING, "gp_timer", evt);\r\nif (err)\r\npr_err("request_irq failed\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_local_timer_dying_cpu(unsigned int cpu)\r\n{\r\nstruct clock_event_device *evt = per_cpu_ptr(msm_evt, cpu);\r\nevt->set_state_shutdown(evt);\r\ndisable_percpu_irq(evt->irq);\r\nreturn 0;\r\n}\r\nstatic u64 notrace msm_sched_clock_read(void)\r\n{\r\nreturn msm_clocksource.read(&msm_clocksource);\r\n}\r\nstatic unsigned long msm_read_current_timer(void)\r\n{\r\nreturn msm_clocksource.read(&msm_clocksource);\r\n}\r\nstatic int __init msm_timer_init(u32 dgt_hz, int sched_bits, int irq,\r\nbool percpu)\r\n{\r\nstruct clocksource *cs = &msm_clocksource;\r\nint res = 0;\r\nmsm_timer_irq = irq;\r\nmsm_timer_has_ppi = percpu;\r\nmsm_evt = alloc_percpu(struct clock_event_device);\r\nif (!msm_evt) {\r\npr_err("memory allocation failed for clockevents\n");\r\ngoto err;\r\n}\r\nif (percpu)\r\nres = request_percpu_irq(irq, msm_timer_interrupt,\r\n"gp_timer", msm_evt);\r\nif (res) {\r\npr_err("request_percpu_irq failed\n");\r\n} else {\r\nres = cpuhp_setup_state(CPUHP_AP_QCOM_TIMER_STARTING,\r\n"AP_QCOM_TIMER_STARTING",\r\nmsm_local_timer_starting_cpu,\r\nmsm_local_timer_dying_cpu);\r\nif (res) {\r\nfree_percpu_irq(irq, msm_evt);\r\ngoto err;\r\n}\r\n}\r\nerr:\r\nwritel_relaxed(TIMER_ENABLE_EN, source_base + TIMER_ENABLE);\r\nres = clocksource_register_hz(cs, dgt_hz);\r\nif (res)\r\npr_err("clocksource_register failed\n");\r\nsched_clock_register(msm_sched_clock_read, sched_bits, dgt_hz);\r\nmsm_delay_timer.freq = dgt_hz;\r\nregister_current_timer_delay(&msm_delay_timer);\r\nreturn res;\r\n}\r\nstatic int __init msm_dt_timer_init(struct device_node *np)\r\n{\r\nu32 freq;\r\nint irq, ret;\r\nstruct resource res;\r\nu32 percpu_offset;\r\nvoid __iomem *base;\r\nvoid __iomem *cpu0_base;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_err("Failed to map event base\n");\r\nreturn -ENXIO;\r\n}\r\nirq = irq_of_parse_and_map(np, 1);\r\nif (irq <= 0) {\r\npr_err("Can't get irq\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(np, "cpu-offset", &percpu_offset))\r\npercpu_offset = 0;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret) {\r\npr_err("Failed to parse DGT resource\n");\r\nreturn ret;\r\n}\r\ncpu0_base = ioremap(res.start + percpu_offset, resource_size(&res));\r\nif (!cpu0_base) {\r\npr_err("Failed to map source base\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(np, "clock-frequency", &freq)) {\r\npr_err("Unknown frequency\n");\r\nreturn -EINVAL;\r\n}\r\nevent_base = base + 0x4;\r\nsts_base = base + 0x88;\r\nsource_base = cpu0_base + 0x24;\r\nfreq /= 4;\r\nwritel_relaxed(DGT_CLK_CTL_DIV_4, source_base + DGT_CLK_CTL);\r\nreturn msm_timer_init(freq, 32, irq, !!percpu_offset);\r\n}
