static inline struct tpm_tis_tcg_phy *to_tpm_tis_tcg_phy(struct tpm_tis_data *data)\r\n{\r\nreturn container_of(data, struct tpm_tis_tcg_phy, priv);\r\n}\r\nstatic int has_hid(struct acpi_device *dev, const char *hid)\r\n{\r\nstruct acpi_hardware_id *id;\r\nlist_for_each_entry(id, &dev->pnp.ids, list)\r\nif (!strcmp(hid, id->id))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int is_itpm(struct acpi_device *dev)\r\n{\r\nreturn has_hid(dev, "INTC0102");\r\n}\r\nstatic inline int is_itpm(struct acpi_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_read_bytes(struct tpm_tis_data *data, u32 addr, u16 len,\r\nu8 *result)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\nwhile (len--)\r\n*result++ = ioread8(phy->iobase + addr);\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,\r\nu8 *value)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\nwhile (len--)\r\niowrite8(*value++, phy->iobase + addr);\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_read16(struct tpm_tis_data *data, u32 addr, u16 *result)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\n*result = ioread16(phy->iobase + addr);\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_read32(struct tpm_tis_data *data, u32 addr, u32 *result)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\n*result = ioread32(phy->iobase + addr);\r\nreturn 0;\r\n}\r\nstatic int tpm_tcg_write32(struct tpm_tis_data *data, u32 addr, u32 value)\r\n{\r\nstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\r\niowrite32(value, phy->iobase + addr);\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info,\r\nacpi_handle acpi_dev_handle)\r\n{\r\nstruct tpm_tis_tcg_phy *phy;\r\nint irq = -1;\r\nphy = devm_kzalloc(dev, sizeof(struct tpm_tis_tcg_phy), GFP_KERNEL);\r\nif (phy == NULL)\r\nreturn -ENOMEM;\r\nphy->iobase = devm_ioremap_resource(dev, &tpm_info->res);\r\nif (IS_ERR(phy->iobase))\r\nreturn PTR_ERR(phy->iobase);\r\nif (interrupts)\r\nirq = tpm_info->irq;\r\nif (itpm)\r\nphy->priv.flags |= TPM_TIS_ITPM_POSSIBLE;\r\nreturn tpm_tis_core_init(dev, &phy->priv, irq, &tpm_tcg,\r\nacpi_dev_handle);\r\n}\r\nstatic int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,\r\nconst struct pnp_device_id *pnp_id)\r\n{\r\nstruct tpm_info tpm_info = {};\r\nacpi_handle acpi_dev_handle = NULL;\r\nstruct resource *res;\r\nres = pnp_get_resource(pnp_dev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\ntpm_info.res = *res;\r\nif (pnp_irq_valid(pnp_dev, 0))\r\ntpm_info.irq = pnp_irq(pnp_dev, 0);\r\nelse\r\ntpm_info.irq = -1;\r\nif (pnp_acpi_device(pnp_dev)) {\r\nif (is_itpm(pnp_acpi_device(pnp_dev)))\r\nitpm = true;\r\nacpi_dev_handle = ACPI_HANDLE(&pnp_dev->dev);\r\n}\r\nreturn tpm_tis_init(&pnp_dev->dev, &tpm_info, acpi_dev_handle);\r\n}\r\nstatic void tpm_tis_pnp_remove(struct pnp_dev *dev)\r\n{\r\nstruct tpm_chip *chip = pnp_get_drvdata(dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\n}\r\nstatic int tpm_check_resource(struct acpi_resource *ares, void *data)\r\n{\r\nstruct tpm_info *tpm_info = (struct tpm_info *) data;\r\nstruct resource res;\r\nif (acpi_dev_resource_interrupt(ares, 0, &res))\r\ntpm_info->irq = res.start;\r\nelse if (acpi_dev_resource_memory(ares, &res)) {\r\ntpm_info->res = res;\r\ntpm_info->res.name = NULL;\r\n}\r\nreturn 1;\r\n}\r\nstatic int tpm_tis_acpi_init(struct acpi_device *acpi_dev)\r\n{\r\nstruct acpi_table_tpm2 *tbl;\r\nacpi_status st;\r\nstruct list_head resources;\r\nstruct tpm_info tpm_info = {};\r\nint ret;\r\nst = acpi_get_table(ACPI_SIG_TPM2, 1,\r\n(struct acpi_table_header **) &tbl);\r\nif (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {\r\ndev_err(&acpi_dev->dev,\r\nFW_BUG "failed to get TPM2 ACPI table\n");\r\nreturn -EINVAL;\r\n}\r\nif (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)\r\nreturn -ENODEV;\r\nINIT_LIST_HEAD(&resources);\r\ntpm_info.irq = -1;\r\nret = acpi_dev_get_resources(acpi_dev, &resources, tpm_check_resource,\r\n&tpm_info);\r\nif (ret < 0)\r\nreturn ret;\r\nacpi_dev_free_resource_list(&resources);\r\nif (resource_type(&tpm_info.res) != IORESOURCE_MEM) {\r\ndev_err(&acpi_dev->dev,\r\nFW_BUG "TPM2 ACPI table does not define a memory resource\n");\r\nreturn -EINVAL;\r\n}\r\nif (is_itpm(acpi_dev))\r\nitpm = true;\r\nreturn tpm_tis_init(&acpi_dev->dev, &tpm_info, acpi_dev->handle);\r\n}\r\nstatic int tpm_tis_acpi_remove(struct acpi_device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&dev->dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_plat_probe(struct platform_device *pdev)\r\n{\r\nstruct tpm_info tpm_info = {};\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\ntpm_info.res = *res;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res) {\r\ntpm_info.irq = res->start;\r\n} else {\r\nif (pdev == force_pdev)\r\ntpm_info.irq = -1;\r\nelse\r\ntpm_info.irq = 0;\r\n}\r\nreturn tpm_tis_init(&pdev->dev, &tpm_info, NULL);\r\n}\r\nstatic int tpm_tis_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&pdev->dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_force_device(void)\r\n{\r\nstruct platform_device *pdev;\r\nstatic const struct resource x86_resources[] = {\r\n{\r\n.start = 0xFED40000,\r\n.end = 0xFED40000 + TIS_MEM_LEN - 1,\r\n.flags = IORESOURCE_MEM,\r\n},\r\n};\r\nif (!force)\r\nreturn 0;\r\npdev = platform_device_register_simple("tpm_tis", -1, x86_resources,\r\nARRAY_SIZE(x86_resources));\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nforce_pdev = pdev;\r\nreturn 0;\r\n}\r\nstatic int __init init_tis(void)\r\n{\r\nint rc;\r\nrc = tpm_tis_force_device();\r\nif (rc)\r\ngoto err_force;\r\nrc = platform_driver_register(&tis_drv);\r\nif (rc)\r\ngoto err_platform;\r\n#ifdef CONFIG_ACPI\r\nrc = acpi_bus_register_driver(&tis_acpi_driver);\r\nif (rc)\r\ngoto err_acpi;\r\n#endif\r\nif (IS_ENABLED(CONFIG_PNP)) {\r\nrc = pnp_register_driver(&tis_pnp_driver);\r\nif (rc)\r\ngoto err_pnp;\r\n}\r\nreturn 0;\r\nerr_pnp:\r\n#ifdef CONFIG_ACPI\r\nacpi_bus_unregister_driver(&tis_acpi_driver);\r\nerr_acpi:\r\n#endif\r\nplatform_device_unregister(force_pdev);\r\nerr_platform:\r\nif (force_pdev)\r\nplatform_device_unregister(force_pdev);\r\nerr_force:\r\nreturn rc;\r\n}\r\nstatic void __exit cleanup_tis(void)\r\n{\r\npnp_unregister_driver(&tis_pnp_driver);\r\n#ifdef CONFIG_ACPI\r\nacpi_bus_unregister_driver(&tis_acpi_driver);\r\n#endif\r\nplatform_driver_unregister(&tis_drv);\r\nif (force_pdev)\r\nplatform_device_unregister(force_pdev);\r\n}
