static int synps_edac_geterror_info(void __iomem *base,\r\nstruct synps_ecc_status *p)\r\n{\r\nu32 regval, clearval = 0;\r\nregval = readl(base + STAT_OFST);\r\nif (!regval)\r\nreturn 1;\r\np->ce_cnt = (regval & STAT_CECNT_MASK) >> STAT_CECNT_SHIFT;\r\np->ue_cnt = regval & STAT_UECNT_MASK;\r\nregval = readl(base + CE_LOG_OFST);\r\nif (!(p->ce_cnt && (regval & LOG_VALID)))\r\ngoto ue_err;\r\np->ceinfo.bitpos = (regval & CE_LOG_BITPOS_MASK) >> CE_LOG_BITPOS_SHIFT;\r\nregval = readl(base + CE_ADDR_OFST);\r\np->ceinfo.row = (regval & ADDR_ROW_MASK) >> ADDR_ROW_SHIFT;\r\np->ceinfo.col = regval & ADDR_COL_MASK;\r\np->ceinfo.bank = (regval & ADDR_BANK_MASK) >> ADDR_BANK_SHIFT;\r\np->ceinfo.data = readl(base + CE_DATA_31_0_OFST);\r\nedac_dbg(3, "ce bit position: %d data: %d\n", p->ceinfo.bitpos,\r\np->ceinfo.data);\r\nclearval = ECC_CTRL_CLR_CE_ERR;\r\nue_err:\r\nregval = readl(base + UE_LOG_OFST);\r\nif (!(p->ue_cnt && (regval & LOG_VALID)))\r\ngoto out;\r\nregval = readl(base + UE_ADDR_OFST);\r\np->ueinfo.row = (regval & ADDR_ROW_MASK) >> ADDR_ROW_SHIFT;\r\np->ueinfo.col = regval & ADDR_COL_MASK;\r\np->ueinfo.bank = (regval & ADDR_BANK_MASK) >> ADDR_BANK_SHIFT;\r\np->ueinfo.data = readl(base + UE_DATA_31_0_OFST);\r\nclearval |= ECC_CTRL_CLR_UE_ERR;\r\nout:\r\nwritel(clearval, base + ECC_CTRL_OFST);\r\nwritel(0x0, base + ECC_CTRL_OFST);\r\nreturn 0;\r\n}\r\nstatic void synps_edac_handle_error(struct mem_ctl_info *mci,\r\nstruct synps_ecc_status *p)\r\n{\r\nstruct synps_edac_priv *priv = mci->pvt_info;\r\nstruct ecc_error_info *pinf;\r\nif (p->ce_cnt) {\r\npinf = &p->ceinfo;\r\nsnprintf(priv->message, SYNPS_EDAC_MSG_SIZE,\r\n"DDR ECC error type :%s Row %d Bank %d Col %d ",\r\n"CE", pinf->row, pinf->bank, pinf->col);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci,\r\np->ce_cnt, 0, 0, 0, 0, 0, -1,\r\npriv->message, "");\r\n}\r\nif (p->ue_cnt) {\r\npinf = &p->ueinfo;\r\nsnprintf(priv->message, SYNPS_EDAC_MSG_SIZE,\r\n"DDR ECC error type :%s Row %d Bank %d Col %d ",\r\n"UE", pinf->row, pinf->bank, pinf->col);\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci,\r\np->ue_cnt, 0, 0, 0, 0, 0, -1,\r\npriv->message, "");\r\n}\r\nmemset(p, 0, sizeof(*p));\r\n}\r\nstatic void synps_edac_check(struct mem_ctl_info *mci)\r\n{\r\nstruct synps_edac_priv *priv = mci->pvt_info;\r\nint status;\r\nstatus = synps_edac_geterror_info(priv->baseaddr, &priv->stat);\r\nif (status)\r\nreturn;\r\npriv->ce_cnt += priv->stat.ce_cnt;\r\npriv->ue_cnt += priv->stat.ue_cnt;\r\nsynps_edac_handle_error(mci, &priv->stat);\r\nedac_dbg(3, "Total error count ce %d ue %d\n",\r\npriv->ce_cnt, priv->ue_cnt);\r\n}\r\nstatic enum dev_type synps_edac_get_dtype(const void __iomem *base)\r\n{\r\nenum dev_type dt;\r\nu32 width;\r\nwidth = readl(base + CTRL_OFST);\r\nwidth = (width & CTRL_BW_MASK) >> CTRL_BW_SHIFT;\r\nswitch (width) {\r\ncase DDRCTL_WDTH_16:\r\ndt = DEV_X2;\r\nbreak;\r\ncase DDRCTL_WDTH_32:\r\ndt = DEV_X4;\r\nbreak;\r\ndefault:\r\ndt = DEV_UNKNOWN;\r\n}\r\nreturn dt;\r\n}\r\nstatic bool synps_edac_get_eccstate(void __iomem *base)\r\n{\r\nenum dev_type dt;\r\nu32 ecctype;\r\nbool state = false;\r\ndt = synps_edac_get_dtype(base);\r\nif (dt == DEV_UNKNOWN)\r\nreturn state;\r\necctype = readl(base + SCRUB_OFST) & SCRUB_MODE_MASK;\r\nif ((ecctype == SCRUB_MODE_SECDED) && (dt == DEV_X2))\r\nstate = true;\r\nreturn state;\r\n}\r\nstatic u32 synps_edac_get_memsize(void)\r\n{\r\nstruct sysinfo inf;\r\nsi_meminfo(&inf);\r\nreturn inf.totalram * inf.mem_unit;\r\n}\r\nstatic enum mem_type synps_edac_get_mtype(const void __iomem *base)\r\n{\r\nenum mem_type mt;\r\nu32 memtype;\r\nmemtype = readl(base + T_ZQ_OFST);\r\nif (memtype & T_ZQ_DDRMODE_MASK)\r\nmt = MEM_DDR3;\r\nelse\r\nmt = MEM_DDR2;\r\nreturn mt;\r\n}\r\nstatic int synps_edac_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct csrow_info *csi;\r\nstruct dimm_info *dimm;\r\nstruct synps_edac_priv *priv = mci->pvt_info;\r\nu32 size;\r\nint row, j;\r\nfor (row = 0; row < mci->nr_csrows; row++) {\r\ncsi = mci->csrows[row];\r\nsize = synps_edac_get_memsize();\r\nfor (j = 0; j < csi->nr_channels; j++) {\r\ndimm = csi->channels[j]->dimm;\r\ndimm->edac_mode = EDAC_FLAG_SECDED;\r\ndimm->mtype = synps_edac_get_mtype(priv->baseaddr);\r\ndimm->nr_pages = (size >> PAGE_SHIFT) / csi->nr_channels;\r\ndimm->grain = SYNPS_EDAC_ERR_GRAIN;\r\ndimm->dtype = synps_edac_get_dtype(priv->baseaddr);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int synps_edac_mc_init(struct mem_ctl_info *mci,\r\nstruct platform_device *pdev)\r\n{\r\nint status;\r\nstruct synps_edac_priv *priv;\r\nmci->pdev = &pdev->dev;\r\npriv = mci->pvt_info;\r\nplatform_set_drvdata(pdev, mci);\r\nmci->mtype_cap = MEM_FLAG_DDR3 | MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->scrub_cap = SCRUB_HW_SRC;\r\nmci->scrub_mode = SCRUB_NONE;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->ctl_name = "synps_ddr_controller";\r\nmci->dev_name = SYNPS_EDAC_MOD_STRING;\r\nmci->mod_name = SYNPS_EDAC_MOD_VER;\r\nmci->mod_ver = "1";\r\nedac_op_state = EDAC_OPSTATE_POLL;\r\nmci->edac_check = synps_edac_check;\r\nmci->ctl_page_to_phys = NULL;\r\nstatus = synps_edac_init_csrows(mci);\r\nreturn status;\r\n}\r\nstatic int synps_edac_mc_probe(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct synps_edac_priv *priv;\r\nint rc;\r\nstruct resource *res;\r\nvoid __iomem *baseaddr;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbaseaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(baseaddr))\r\nreturn PTR_ERR(baseaddr);\r\nif (!synps_edac_get_eccstate(baseaddr)) {\r\nedac_printk(KERN_INFO, EDAC_MC, "ECC not enabled\n");\r\nreturn -ENXIO;\r\n}\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = SYNPS_EDAC_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = SYNPS_EDAC_NR_CHANS;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\r\nsizeof(struct synps_edac_priv));\r\nif (!mci) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Failed memory allocation for mc instance\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = mci->pvt_info;\r\npriv->baseaddr = baseaddr;\r\nrc = synps_edac_mc_init(mci, pdev);\r\nif (rc) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Failed to initialize instance\n");\r\ngoto free_edac_mc;\r\n}\r\nrc = edac_mc_add_mc(mci);\r\nif (rc) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Failed to register with EDAC core\n");\r\ngoto free_edac_mc;\r\n}\r\nwritel(0x0, baseaddr + ECC_CTRL_OFST);\r\nreturn rc;\r\nfree_edac_mc:\r\nedac_mc_free(mci);\r\nreturn rc;\r\n}\r\nstatic int synps_edac_mc_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\nedac_mc_del_mc(&pdev->dev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}
