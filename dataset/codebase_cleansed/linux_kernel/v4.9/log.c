static char *batadv_log_char_addr(struct batadv_priv_debug_log *debug_log,\r\nsize_t idx)\r\n{\r\nreturn &debug_log->log_buff[idx & BATADV_LOG_BUFF_MASK];\r\n}\r\nstatic void batadv_emit_log_char(struct batadv_priv_debug_log *debug_log,\r\nchar c)\r\n{\r\nchar *char_addr;\r\nchar_addr = batadv_log_char_addr(debug_log, debug_log->log_end);\r\n*char_addr = c;\r\ndebug_log->log_end++;\r\nif (debug_log->log_end - debug_log->log_start > batadv_log_buff_len)\r\ndebug_log->log_start = debug_log->log_end - batadv_log_buff_len;\r\n}\r\nstatic int batadv_fdebug_log(struct batadv_priv_debug_log *debug_log,\r\nconst char *fmt, ...)\r\n{\r\nva_list args;\r\nstatic char debug_log_buf[256];\r\nchar *p;\r\nif (!debug_log)\r\nreturn 0;\r\nspin_lock_bh(&debug_log->lock);\r\nva_start(args, fmt);\r\nvscnprintf(debug_log_buf, sizeof(debug_log_buf), fmt, args);\r\nva_end(args);\r\nfor (p = debug_log_buf; *p != 0; p++)\r\nbatadv_emit_log_char(debug_log, *p);\r\nspin_unlock_bh(&debug_log->lock);\r\nwake_up(&debug_log->queue_wait);\r\nreturn 0;\r\n}\r\nint batadv_debug_log(struct batadv_priv *bat_priv, const char *fmt, ...)\r\n{\r\nva_list args;\r\nchar tmp_log_buf[256];\r\nva_start(args, fmt);\r\nvscnprintf(tmp_log_buf, sizeof(tmp_log_buf), fmt, args);\r\nbatadv_fdebug_log(bat_priv->debug_log, "[%10u] %s",\r\njiffies_to_msecs(jiffies), tmp_log_buf);\r\nva_end(args);\r\nreturn 0;\r\n}\r\nstatic int batadv_log_open(struct inode *inode, struct file *file)\r\n{\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -EBUSY;\r\nnonseekable_open(inode, file);\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic int batadv_log_release(struct inode *inode, struct file *file)\r\n{\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nstatic bool batadv_log_empty(struct batadv_priv_debug_log *debug_log)\r\n{\r\nreturn !(debug_log->log_start - debug_log->log_end);\r\n}\r\nstatic ssize_t batadv_log_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct batadv_priv *bat_priv = file->private_data;\r\nstruct batadv_priv_debug_log *debug_log = bat_priv->debug_log;\r\nint error, i = 0;\r\nchar *char_addr;\r\nchar c;\r\nif ((file->f_flags & O_NONBLOCK) && batadv_log_empty(debug_log))\r\nreturn -EAGAIN;\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (count == 0)\r\nreturn 0;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nerror = wait_event_interruptible(debug_log->queue_wait,\r\n(!batadv_log_empty(debug_log)));\r\nif (error)\r\nreturn error;\r\nspin_lock_bh(&debug_log->lock);\r\nwhile ((!error) && (i < count) &&\r\n(debug_log->log_start != debug_log->log_end)) {\r\nchar_addr = batadv_log_char_addr(debug_log,\r\ndebug_log->log_start);\r\nc = *char_addr;\r\ndebug_log->log_start++;\r\nspin_unlock_bh(&debug_log->lock);\r\nerror = __put_user(c, buf);\r\nspin_lock_bh(&debug_log->lock);\r\nbuf++;\r\ni++;\r\n}\r\nspin_unlock_bh(&debug_log->lock);\r\nif (!error)\r\nreturn i;\r\nreturn error;\r\n}\r\nstatic unsigned int batadv_log_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct batadv_priv *bat_priv = file->private_data;\r\nstruct batadv_priv_debug_log *debug_log = bat_priv->debug_log;\r\npoll_wait(file, &debug_log->queue_wait, wait);\r\nif (!batadv_log_empty(debug_log))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nint batadv_debug_log_setup(struct batadv_priv *bat_priv)\r\n{\r\nstruct dentry *d;\r\nif (!bat_priv->debug_dir)\r\ngoto err;\r\nbat_priv->debug_log = kzalloc(sizeof(*bat_priv->debug_log), GFP_ATOMIC);\r\nif (!bat_priv->debug_log)\r\ngoto err;\r\nspin_lock_init(&bat_priv->debug_log->lock);\r\ninit_waitqueue_head(&bat_priv->debug_log->queue_wait);\r\nd = debugfs_create_file("log", S_IFREG | S_IRUSR,\r\nbat_priv->debug_dir, bat_priv,\r\n&batadv_log_fops);\r\nif (!d)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nvoid batadv_debug_log_cleanup(struct batadv_priv *bat_priv)\r\n{\r\nkfree(bat_priv->debug_log);\r\nbat_priv->debug_log = NULL;\r\n}
