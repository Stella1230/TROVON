static u32 bmp280_compensate_humidity(struct bmp280_data *data,\r\ns32 adc_humidity)\r\n{\r\nstruct device *dev = data->dev;\r\nunsigned int H1, H3, tmp;\r\nint H2, H4, H5, H6, ret, var;\r\nret = regmap_read(data->regmap, BMP280_REG_COMP_H1, &H1);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read H1 comp value\n");\r\nreturn ret;\r\n}\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_H2, &tmp, 2);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read H2 comp value\n");\r\nreturn ret;\r\n}\r\nH2 = sign_extend32(le16_to_cpu(tmp), 15);\r\nret = regmap_read(data->regmap, BMP280_REG_COMP_H3, &H3);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read H3 comp value\n");\r\nreturn ret;\r\n}\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_H4, &tmp, 2);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read H4 comp value\n");\r\nreturn ret;\r\n}\r\nH4 = sign_extend32(((be16_to_cpu(tmp) >> 4) & 0xff0) |\r\n(be16_to_cpu(tmp) & 0xf), 11);\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_H5, &tmp, 2);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read H5 comp value\n");\r\nreturn ret;\r\n}\r\nH5 = sign_extend32(((le16_to_cpu(tmp) >> 4) & 0xfff), 11);\r\nret = regmap_read(data->regmap, BMP280_REG_COMP_H6, &tmp);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read H6 comp value\n");\r\nreturn ret;\r\n}\r\nH6 = sign_extend32(tmp, 7);\r\nvar = ((s32)data->t_fine) - 76800;\r\nvar = ((((adc_humidity << 14) - (H4 << 20) - (H5 * var)) + 16384) >> 15)\r\n* (((((((var * H6) >> 10) * (((var * H3) >> 11) + 32768)) >> 10)\r\n+ 2097152) * H2 + 8192) >> 14);\r\nvar -= ((((var >> 15) * (var >> 15)) >> 7) * H1) >> 4;\r\nreturn var >> 12;\r\n}\r\nstatic s32 bmp280_compensate_temp(struct bmp280_data *data,\r\ns32 adc_temp)\r\n{\r\nint ret;\r\ns32 var1, var2;\r\n__le16 buf[BMP280_COMP_TEMP_REG_COUNT / 2];\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_TEMP_START,\r\nbuf, BMP280_COMP_TEMP_REG_COUNT);\r\nif (ret < 0) {\r\ndev_err(data->dev,\r\n"failed to read temperature calibration parameters\n");\r\nreturn ret;\r\n}\r\nvar1 = (((adc_temp >> 3) - ((s32)le16_to_cpu(buf[T1]) << 1)) *\r\n((s32)(s16)le16_to_cpu(buf[T2]))) >> 11;\r\nvar2 = (((((adc_temp >> 4) - ((s32)le16_to_cpu(buf[T1]))) *\r\n((adc_temp >> 4) - ((s32)le16_to_cpu(buf[T1])))) >> 12) *\r\n((s32)(s16)le16_to_cpu(buf[T3]))) >> 14;\r\ndata->t_fine = var1 + var2;\r\nreturn (data->t_fine * 5 + 128) >> 8;\r\n}\r\nstatic u32 bmp280_compensate_press(struct bmp280_data *data,\r\ns32 adc_press)\r\n{\r\nint ret;\r\ns64 var1, var2, p;\r\n__le16 buf[BMP280_COMP_PRESS_REG_COUNT / 2];\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_COMP_PRESS_START,\r\nbuf, BMP280_COMP_PRESS_REG_COUNT);\r\nif (ret < 0) {\r\ndev_err(data->dev,\r\n"failed to read pressure calibration parameters\n");\r\nreturn ret;\r\n}\r\nvar1 = ((s64)data->t_fine) - 128000;\r\nvar2 = var1 * var1 * (s64)(s16)le16_to_cpu(buf[P6]);\r\nvar2 += (var1 * (s64)(s16)le16_to_cpu(buf[P5])) << 17;\r\nvar2 += ((s64)(s16)le16_to_cpu(buf[P4])) << 35;\r\nvar1 = ((var1 * var1 * (s64)(s16)le16_to_cpu(buf[P3])) >> 8) +\r\n((var1 * (s64)(s16)le16_to_cpu(buf[P2])) << 12);\r\nvar1 = ((((s64)1) << 47) + var1) * ((s64)le16_to_cpu(buf[P1])) >> 33;\r\nif (var1 == 0)\r\nreturn 0;\r\np = ((((s64)1048576 - adc_press) << 31) - var2) * 3125;\r\np = div64_s64(p, var1);\r\nvar1 = (((s64)(s16)le16_to_cpu(buf[P9])) * (p >> 13) * (p >> 13)) >> 25;\r\nvar2 = (((s64)(s16)le16_to_cpu(buf[P8])) * p) >> 19;\r\np = ((p + var1 + var2) >> 8) + (((s64)(s16)le16_to_cpu(buf[P7])) << 4);\r\nreturn (u32)p;\r\n}\r\nstatic int bmp280_read_temp(struct bmp280_data *data,\r\nint *val)\r\n{\r\nint ret;\r\n__be32 tmp = 0;\r\ns32 adc_temp, comp_temp;\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_TEMP_MSB,\r\n(u8 *) &tmp, 3);\r\nif (ret < 0) {\r\ndev_err(data->dev, "failed to read temperature\n");\r\nreturn ret;\r\n}\r\nadc_temp = be32_to_cpu(tmp) >> 12;\r\ncomp_temp = bmp280_compensate_temp(data, adc_temp);\r\nif (val) {\r\n*val = comp_temp * 10;\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmp280_read_press(struct bmp280_data *data,\r\nint *val, int *val2)\r\n{\r\nint ret;\r\n__be32 tmp = 0;\r\ns32 adc_press;\r\nu32 comp_press;\r\nret = bmp280_read_temp(data, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_PRESS_MSB,\r\n(u8 *) &tmp, 3);\r\nif (ret < 0) {\r\ndev_err(data->dev, "failed to read pressure\n");\r\nreturn ret;\r\n}\r\nadc_press = be32_to_cpu(tmp) >> 12;\r\ncomp_press = bmp280_compensate_press(data, adc_press);\r\n*val = comp_press;\r\n*val2 = 256000;\r\nreturn IIO_VAL_FRACTIONAL;\r\n}\r\nstatic int bmp280_read_humid(struct bmp280_data *data, int *val, int *val2)\r\n{\r\nint ret;\r\n__be16 tmp = 0;\r\ns32 adc_humidity;\r\nu32 comp_humidity;\r\nret = bmp280_read_temp(data, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_bulk_read(data->regmap, BMP280_REG_HUMIDITY_MSB,\r\n(u8 *) &tmp, 2);\r\nif (ret < 0) {\r\ndev_err(data->dev, "failed to read humidity\n");\r\nreturn ret;\r\n}\r\nadc_humidity = be16_to_cpu(tmp);\r\ncomp_humidity = bmp280_compensate_humidity(data, adc_humidity);\r\n*val = comp_humidity;\r\n*val2 = 1024;\r\nreturn IIO_VAL_FRACTIONAL;\r\n}\r\nstatic int bmp280_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret;\r\nstruct bmp280_data *data = iio_priv(indio_dev);\r\npm_runtime_get_sync(data->dev);\r\nmutex_lock(&data->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_HUMIDITYRELATIVE:\r\nret = data->chip_info->read_humid(data, val, val2);\r\nbreak;\r\ncase IIO_PRESSURE:\r\nret = data->chip_info->read_press(data, val, val2);\r\nbreak;\r\ncase IIO_TEMP:\r\nret = data->chip_info->read_temp(data, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\r\nswitch (chan->type) {\r\ncase IIO_HUMIDITYRELATIVE:\r\n*val = 1 << data->oversampling_humid;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_PRESSURE:\r\n*val = 1 << data->oversampling_press;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_TEMP:\r\n*val = 1 << data->oversampling_temp;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&data->lock);\r\npm_runtime_mark_last_busy(data->dev);\r\npm_runtime_put_autosuspend(data->dev);\r\nreturn ret;\r\n}\r\nstatic int bmp280_write_oversampling_ratio_humid(struct bmp280_data *data,\r\nint val)\r\n{\r\nint i;\r\nconst int *avail = data->chip_info->oversampling_humid_avail;\r\nconst int n = data->chip_info->num_oversampling_humid_avail;\r\nfor (i = 0; i < n; i++) {\r\nif (avail[i] == val) {\r\ndata->oversampling_humid = ilog2(val);\r\nreturn data->chip_info->chip_config(data);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bmp280_write_oversampling_ratio_temp(struct bmp280_data *data,\r\nint val)\r\n{\r\nint i;\r\nconst int *avail = data->chip_info->oversampling_temp_avail;\r\nconst int n = data->chip_info->num_oversampling_temp_avail;\r\nfor (i = 0; i < n; i++) {\r\nif (avail[i] == val) {\r\ndata->oversampling_temp = ilog2(val);\r\nreturn data->chip_info->chip_config(data);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bmp280_write_oversampling_ratio_press(struct bmp280_data *data,\r\nint val)\r\n{\r\nint i;\r\nconst int *avail = data->chip_info->oversampling_press_avail;\r\nconst int n = data->chip_info->num_oversampling_press_avail;\r\nfor (i = 0; i < n; i++) {\r\nif (avail[i] == val) {\r\ndata->oversampling_press = ilog2(val);\r\nreturn data->chip_info->chip_config(data);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int bmp280_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nint ret = 0;\r\nstruct bmp280_data *data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\r\npm_runtime_get_sync(data->dev);\r\nmutex_lock(&data->lock);\r\nswitch (chan->type) {\r\ncase IIO_HUMIDITYRELATIVE:\r\nret = bmp280_write_oversampling_ratio_humid(data, val);\r\nbreak;\r\ncase IIO_PRESSURE:\r\nret = bmp280_write_oversampling_ratio_press(data, val);\r\nbreak;\r\ncase IIO_TEMP:\r\nret = bmp280_write_oversampling_ratio_temp(data, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&data->lock);\r\npm_runtime_mark_last_busy(data->dev);\r\npm_runtime_put_autosuspend(data->dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t bmp280_show_avail(char *buf, const int *vals, const int n)\r\n{\r\nsize_t len = 0;\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%d ", vals[i]);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t bmp280_show_temp_oversampling_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bmp280_data *data = iio_priv(dev_to_iio_dev(dev));\r\nreturn bmp280_show_avail(buf, data->chip_info->oversampling_temp_avail,\r\ndata->chip_info->num_oversampling_temp_avail);\r\n}\r\nstatic ssize_t bmp280_show_press_oversampling_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bmp280_data *data = iio_priv(dev_to_iio_dev(dev));\r\nreturn bmp280_show_avail(buf, data->chip_info->oversampling_press_avail,\r\ndata->chip_info->num_oversampling_press_avail);\r\n}\r\nstatic int bmp280_chip_config(struct bmp280_data *data)\r\n{\r\nint ret;\r\nu8 osrs = BMP280_OSRS_TEMP_X(data->oversampling_temp + 1) |\r\nBMP280_OSRS_PRESS_X(data->oversampling_press + 1);\r\nret = regmap_update_bits(data->regmap, BMP280_REG_CTRL_MEAS,\r\nBMP280_OSRS_TEMP_MASK |\r\nBMP280_OSRS_PRESS_MASK |\r\nBMP280_MODE_MASK,\r\nosrs | BMP280_MODE_NORMAL);\r\nif (ret < 0) {\r\ndev_err(data->dev,\r\n"failed to write ctrl_meas register\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(data->regmap, BMP280_REG_CONFIG,\r\nBMP280_FILTER_MASK,\r\nBMP280_FILTER_4X);\r\nif (ret < 0) {\r\ndev_err(data->dev,\r\n"failed to write config register\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int bme280_chip_config(struct bmp280_data *data)\r\n{\r\nint ret = bmp280_chip_config(data);\r\nu8 osrs = BMP280_OSRS_HUMIDITIY_X(data->oversampling_humid + 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_update_bits(data->regmap, BMP280_REG_CTRL_HUMIDITY,\r\nBMP280_OSRS_HUMIDITY_MASK, osrs);\r\n}\r\nstatic int bmp180_measure(struct bmp280_data *data, u8 ctrl_meas)\r\n{\r\nint ret;\r\nconst int conversion_time_max[] = { 4500, 7500, 13500, 25500 };\r\nunsigned int delay_us;\r\nunsigned int ctrl;\r\nif (data->use_eoc)\r\ninit_completion(&data->done);\r\nret = regmap_write(data->regmap, BMP280_REG_CTRL_MEAS, ctrl_meas);\r\nif (ret)\r\nreturn ret;\r\nif (data->use_eoc) {\r\nret = wait_for_completion_timeout(&data->done,\r\n1 + msecs_to_jiffies(100));\r\nif (!ret)\r\ndev_err(data->dev, "timeout waiting for completion\n");\r\n} else {\r\nif (ctrl_meas == BMP180_MEAS_TEMP)\r\ndelay_us = 4500;\r\nelse\r\ndelay_us =\r\nconversion_time_max[data->oversampling_press];\r\nusleep_range(delay_us, delay_us + 1000);\r\n}\r\nret = regmap_read(data->regmap, BMP280_REG_CTRL_MEAS, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nif (ctrl & BMP180_MEAS_SCO)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int bmp180_read_adc_temp(struct bmp280_data *data, int *val)\r\n{\r\nint ret;\r\n__be16 tmp = 0;\r\nret = bmp180_measure(data, BMP180_MEAS_TEMP);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_bulk_read(data->regmap, BMP180_REG_OUT_MSB, (u8 *)&tmp, 2);\r\nif (ret)\r\nreturn ret;\r\n*val = be16_to_cpu(tmp);\r\nreturn 0;\r\n}\r\nstatic int bmp180_read_calib(struct bmp280_data *data,\r\nstruct bmp180_calib *calib)\r\n{\r\nint ret;\r\nint i;\r\n__be16 buf[BMP180_REG_CALIB_COUNT / 2];\r\nret = regmap_bulk_read(data->regmap, BMP180_REG_CALIB_START, buf,\r\nsizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(buf); i++) {\r\nif (buf[i] == cpu_to_be16(0) || buf[i] == cpu_to_be16(0xffff))\r\nreturn -EIO;\r\n}\r\nadd_device_randomness(buf, sizeof(buf));\r\ncalib->AC1 = be16_to_cpu(buf[AC1]);\r\ncalib->AC2 = be16_to_cpu(buf[AC2]);\r\ncalib->AC3 = be16_to_cpu(buf[AC3]);\r\ncalib->AC4 = be16_to_cpu(buf[AC4]);\r\ncalib->AC5 = be16_to_cpu(buf[AC5]);\r\ncalib->AC6 = be16_to_cpu(buf[AC6]);\r\ncalib->B1 = be16_to_cpu(buf[B1]);\r\ncalib->B2 = be16_to_cpu(buf[B2]);\r\ncalib->MB = be16_to_cpu(buf[MB]);\r\ncalib->MC = be16_to_cpu(buf[MC]);\r\ncalib->MD = be16_to_cpu(buf[MD]);\r\nreturn 0;\r\n}\r\nstatic s32 bmp180_compensate_temp(struct bmp280_data *data, s32 adc_temp)\r\n{\r\ns32 x1, x2;\r\nstruct bmp180_calib *calib = &data->calib;\r\nx1 = ((adc_temp - calib->AC6) * calib->AC5) >> 15;\r\nx2 = (calib->MC << 11) / (x1 + calib->MD);\r\ndata->t_fine = x1 + x2;\r\nreturn (data->t_fine + 8) >> 4;\r\n}\r\nstatic int bmp180_read_temp(struct bmp280_data *data, int *val)\r\n{\r\nint ret;\r\ns32 adc_temp, comp_temp;\r\nret = bmp180_read_adc_temp(data, &adc_temp);\r\nif (ret)\r\nreturn ret;\r\ncomp_temp = bmp180_compensate_temp(data, adc_temp);\r\nif (val) {\r\n*val = comp_temp * 100;\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmp180_read_adc_press(struct bmp280_data *data, int *val)\r\n{\r\nint ret;\r\n__be32 tmp = 0;\r\nu8 oss = data->oversampling_press;\r\nret = bmp180_measure(data, BMP180_MEAS_PRESS_X(oss));\r\nif (ret)\r\nreturn ret;\r\nret = regmap_bulk_read(data->regmap, BMP180_REG_OUT_MSB, (u8 *)&tmp, 3);\r\nif (ret)\r\nreturn ret;\r\n*val = (be32_to_cpu(tmp) >> 8) >> (8 - oss);\r\nreturn 0;\r\n}\r\nstatic u32 bmp180_compensate_press(struct bmp280_data *data, s32 adc_press)\r\n{\r\ns32 x1, x2, x3, p;\r\ns32 b3, b6;\r\nu32 b4, b7;\r\ns32 oss = data->oversampling_press;\r\nstruct bmp180_calib *calib = &data->calib;\r\nb6 = data->t_fine - 4000;\r\nx1 = (calib->B2 * (b6 * b6 >> 12)) >> 11;\r\nx2 = calib->AC2 * b6 >> 11;\r\nx3 = x1 + x2;\r\nb3 = ((((s32)calib->AC1 * 4 + x3) << oss) + 2) / 4;\r\nx1 = calib->AC3 * b6 >> 13;\r\nx2 = (calib->B1 * ((b6 * b6) >> 12)) >> 16;\r\nx3 = (x1 + x2 + 2) >> 2;\r\nb4 = calib->AC4 * (u32)(x3 + 32768) >> 15;\r\nb7 = ((u32)adc_press - b3) * (50000 >> oss);\r\nif (b7 < 0x80000000)\r\np = (b7 * 2) / b4;\r\nelse\r\np = (b7 / b4) * 2;\r\nx1 = (p >> 8) * (p >> 8);\r\nx1 = (x1 * 3038) >> 16;\r\nx2 = (-7357 * p) >> 16;\r\nreturn p + ((x1 + x2 + 3791) >> 4);\r\n}\r\nstatic int bmp180_read_press(struct bmp280_data *data,\r\nint *val, int *val2)\r\n{\r\nint ret;\r\ns32 adc_press;\r\nu32 comp_press;\r\nret = bmp180_read_temp(data, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = bmp180_read_adc_press(data, &adc_press);\r\nif (ret)\r\nreturn ret;\r\ncomp_press = bmp180_compensate_press(data, adc_press);\r\n*val = comp_press;\r\n*val2 = 1000;\r\nreturn IIO_VAL_FRACTIONAL;\r\n}\r\nstatic int bmp180_chip_config(struct bmp280_data *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bmp085_eoc_irq(int irq, void *d)\r\n{\r\nstruct bmp280_data *data = d;\r\ncomplete(&data->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bmp085_fetch_eoc_irq(struct device *dev,\r\nconst char *name,\r\nint irq,\r\nstruct bmp280_data *data)\r\n{\r\nunsigned long irq_trig;\r\nint ret;\r\nirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\r\nif (irq_trig != IRQF_TRIGGER_RISING) {\r\ndev_err(dev, "non-rising trigger given for EOC interrupt, "\r\n"trying to enforce it\n");\r\nirq_trig = IRQF_TRIGGER_RISING;\r\n}\r\nret = devm_request_threaded_irq(dev,\r\nirq,\r\nbmp085_eoc_irq,\r\nNULL,\r\nirq_trig,\r\nname,\r\ndata);\r\nif (ret) {\r\ndev_err(dev, "unable to request DRDY IRQ\n");\r\nreturn 0;\r\n}\r\ndata->use_eoc = true;\r\nreturn 0;\r\n}\r\nint bmp280_common_probe(struct device *dev,\r\nstruct regmap *regmap,\r\nunsigned int chip,\r\nconst char *name,\r\nint irq)\r\n{\r\nint ret;\r\nstruct iio_dev *indio_dev;\r\nstruct bmp280_data *data;\r\nunsigned int chip_id;\r\nstruct gpio_desc *gpiod;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\nmutex_init(&data->lock);\r\ndata->dev = dev;\r\nindio_dev->dev.parent = dev;\r\nindio_dev->name = name;\r\nindio_dev->channels = bmp280_channels;\r\nindio_dev->info = &bmp280_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nswitch (chip) {\r\ncase BMP180_CHIP_ID:\r\nindio_dev->num_channels = 2;\r\ndata->chip_info = &bmp180_chip_info;\r\ndata->oversampling_press = ilog2(8);\r\ndata->oversampling_temp = ilog2(1);\r\ndata->start_up_time = 10;\r\nbreak;\r\ncase BMP280_CHIP_ID:\r\nindio_dev->num_channels = 2;\r\ndata->chip_info = &bmp280_chip_info;\r\ndata->oversampling_press = ilog2(16);\r\ndata->oversampling_temp = ilog2(2);\r\ndata->start_up_time = 2;\r\nbreak;\r\ncase BME280_CHIP_ID:\r\nindio_dev->num_channels = 3;\r\ndata->chip_info = &bme280_chip_info;\r\ndata->oversampling_press = ilog2(16);\r\ndata->oversampling_humid = ilog2(16);\r\ndata->oversampling_temp = ilog2(2);\r\ndata->start_up_time = 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndata->vddd = devm_regulator_get(dev, "vddd");\r\nif (IS_ERR(data->vddd)) {\r\ndev_err(dev, "failed to get VDDD regulator\n");\r\nreturn PTR_ERR(data->vddd);\r\n}\r\nret = regulator_enable(data->vddd);\r\nif (ret) {\r\ndev_err(dev, "failed to enable VDDD regulator\n");\r\nreturn ret;\r\n}\r\ndata->vdda = devm_regulator_get(dev, "vdda");\r\nif (IS_ERR(data->vdda)) {\r\ndev_err(dev, "failed to get VDDA regulator\n");\r\nret = PTR_ERR(data->vdda);\r\ngoto out_disable_vddd;\r\n}\r\nret = regulator_enable(data->vdda);\r\nif (ret) {\r\ndev_err(dev, "failed to enable VDDA regulator\n");\r\ngoto out_disable_vddd;\r\n}\r\nmdelay(data->start_up_time);\r\ngpiod = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);\r\nif (!IS_ERR(gpiod)) {\r\ndev_info(dev, "release reset\n");\r\ngpiod_set_value(gpiod, 0);\r\n}\r\ndata->regmap = regmap;\r\nret = regmap_read(regmap, BMP280_REG_ID, &chip_id);\r\nif (ret < 0)\r\ngoto out_disable_vdda;\r\nif (chip_id != chip) {\r\ndev_err(dev, "bad chip id: expected %x got %x\n",\r\nchip, chip_id);\r\nret = -EINVAL;\r\ngoto out_disable_vdda;\r\n}\r\nret = data->chip_info->chip_config(data);\r\nif (ret < 0)\r\ngoto out_disable_vdda;\r\ndev_set_drvdata(dev, indio_dev);\r\nif (chip_id == BMP180_CHIP_ID) {\r\nret = bmp180_read_calib(data, &data->calib);\r\nif (ret < 0) {\r\ndev_err(data->dev,\r\n"failed to read calibration coefficients\n");\r\ngoto out_disable_vdda;\r\n}\r\n}\r\nif (irq > 0 || (chip_id == BMP180_CHIP_ID)) {\r\nret = bmp085_fetch_eoc_irq(dev, name, irq, data);\r\nif (ret)\r\ngoto out_disable_vdda;\r\n}\r\npm_runtime_get_noresume(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_set_autosuspend_delay(dev, data->start_up_time *100);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_put(dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto out_runtime_pm_disable;\r\nreturn 0;\r\nout_runtime_pm_disable:\r\npm_runtime_get_sync(data->dev);\r\npm_runtime_put_noidle(data->dev);\r\npm_runtime_disable(data->dev);\r\nout_disable_vdda:\r\nregulator_disable(data->vdda);\r\nout_disable_vddd:\r\nregulator_disable(data->vddd);\r\nreturn ret;\r\n}\r\nint bmp280_common_remove(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmp280_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\npm_runtime_get_sync(data->dev);\r\npm_runtime_put_noidle(data->dev);\r\npm_runtime_disable(data->dev);\r\nregulator_disable(data->vdda);\r\nregulator_disable(data->vddd);\r\nreturn 0;\r\n}\r\nstatic int bmp280_runtime_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmp280_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_disable(data->vdda);\r\nif (ret)\r\nreturn ret;\r\nreturn regulator_disable(data->vddd);\r\n}\r\nstatic int bmp280_runtime_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct bmp280_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_enable(data->vddd);\r\nif (ret)\r\nreturn ret;\r\nret = regulator_enable(data->vdda);\r\nif (ret)\r\nreturn ret;\r\nmsleep(data->start_up_time);\r\nreturn data->chip_info->chip_config(data);\r\n}
