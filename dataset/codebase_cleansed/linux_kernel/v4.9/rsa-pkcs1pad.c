static const struct rsa_asn1_template *rsa_lookup_asn1(const char *name)\r\n{\r\nconst struct rsa_asn1_template *p;\r\nfor (p = rsa_asn1_templates; p->name; p++)\r\nif (strcmp(name, p->name) == 0)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic int pkcs1pad_set_pub_key(struct crypto_akcipher *tfm, const void *key,\r\nunsigned int keylen)\r\n{\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nint err;\r\nctx->key_size = 0;\r\nerr = crypto_akcipher_set_pub_key(ctx->child, key, keylen);\r\nif (err)\r\nreturn err;\r\nerr = crypto_akcipher_maxsize(ctx->child);\r\nif (err < 0)\r\nreturn err;\r\nif (err > PAGE_SIZE)\r\nreturn -ENOTSUPP;\r\nctx->key_size = err;\r\nreturn 0;\r\n}\r\nstatic int pkcs1pad_set_priv_key(struct crypto_akcipher *tfm, const void *key,\r\nunsigned int keylen)\r\n{\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nint err;\r\nctx->key_size = 0;\r\nerr = crypto_akcipher_set_priv_key(ctx->child, key, keylen);\r\nif (err)\r\nreturn err;\r\nerr = crypto_akcipher_maxsize(ctx->child);\r\nif (err < 0)\r\nreturn err;\r\nif (err > PAGE_SIZE)\r\nreturn -ENOTSUPP;\r\nctx->key_size = err;\r\nreturn 0;\r\n}\r\nstatic int pkcs1pad_get_max_size(struct crypto_akcipher *tfm)\r\n{\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nreturn ctx->key_size ?: -EINVAL;\r\n}\r\nstatic void pkcs1pad_sg_set_buf(struct scatterlist *sg, void *buf, size_t len,\r\nstruct scatterlist *next)\r\n{\r\nint nsegs = next ? 2 : 1;\r\nsg_init_table(sg, nsegs);\r\nsg_set_buf(sg, buf, len);\r\nif (next)\r\nsg_chain(sg, nsegs, next);\r\n}\r\nstatic int pkcs1pad_encrypt_sign_complete(struct akcipher_request *req, int err)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\r\nunsigned int pad_len;\r\nunsigned int len;\r\nu8 *out_buf;\r\nif (err)\r\ngoto out;\r\nlen = req_ctx->child_req.dst_len;\r\npad_len = ctx->key_size - len;\r\nif (likely(!pad_len))\r\ngoto out;\r\nout_buf = kzalloc(ctx->key_size, GFP_ATOMIC);\r\nerr = -ENOMEM;\r\nif (!out_buf)\r\ngoto out;\r\nsg_copy_to_buffer(req->dst, sg_nents_for_len(req->dst, len),\r\nout_buf + pad_len, len);\r\nsg_copy_from_buffer(req->dst,\r\nsg_nents_for_len(req->dst, ctx->key_size),\r\nout_buf, ctx->key_size);\r\nkzfree(out_buf);\r\nout:\r\nreq->dst_len = ctx->key_size;\r\nkfree(req_ctx->in_buf);\r\nreturn err;\r\n}\r\nstatic void pkcs1pad_encrypt_sign_complete_cb(\r\nstruct crypto_async_request *child_async_req, int err)\r\n{\r\nstruct akcipher_request *req = child_async_req->data;\r\nstruct crypto_async_request async_req;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nasync_req.data = req->base.data;\r\nasync_req.tfm = crypto_akcipher_tfm(crypto_akcipher_reqtfm(req));\r\nasync_req.flags = child_async_req->flags;\r\nreq->base.complete(&async_req,\r\npkcs1pad_encrypt_sign_complete(req, err));\r\n}\r\nstatic int pkcs1pad_encrypt(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\r\nint err;\r\nunsigned int i, ps_end;\r\nif (!ctx->key_size)\r\nreturn -EINVAL;\r\nif (req->src_len > ctx->key_size - 11)\r\nreturn -EOVERFLOW;\r\nif (req->dst_len < ctx->key_size) {\r\nreq->dst_len = ctx->key_size;\r\nreturn -EOVERFLOW;\r\n}\r\nreq_ctx->in_buf = kmalloc(ctx->key_size - 1 - req->src_len,\r\nGFP_KERNEL);\r\nif (!req_ctx->in_buf)\r\nreturn -ENOMEM;\r\nps_end = ctx->key_size - req->src_len - 2;\r\nreq_ctx->in_buf[0] = 0x02;\r\nfor (i = 1; i < ps_end; i++)\r\nreq_ctx->in_buf[i] = 1 + prandom_u32_max(255);\r\nreq_ctx->in_buf[ps_end] = 0x00;\r\npkcs1pad_sg_set_buf(req_ctx->in_sg, req_ctx->in_buf,\r\nctx->key_size - 1 - req->src_len, req->src);\r\nreq_ctx->out_buf = kmalloc(ctx->key_size, GFP_KERNEL);\r\nif (!req_ctx->out_buf) {\r\nkfree(req_ctx->in_buf);\r\nreturn -ENOMEM;\r\n}\r\npkcs1pad_sg_set_buf(req_ctx->out_sg, req_ctx->out_buf,\r\nctx->key_size, NULL);\r\nakcipher_request_set_tfm(&req_ctx->child_req, ctx->child);\r\nakcipher_request_set_callback(&req_ctx->child_req, req->base.flags,\r\npkcs1pad_encrypt_sign_complete_cb, req);\r\nakcipher_request_set_crypt(&req_ctx->child_req, req_ctx->in_sg,\r\nreq->dst, ctx->key_size - 1, req->dst_len);\r\nerr = crypto_akcipher_encrypt(&req_ctx->child_req);\r\nif (err != -EINPROGRESS &&\r\n(err != -EBUSY ||\r\n!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)))\r\nreturn pkcs1pad_encrypt_sign_complete(req, err);\r\nreturn err;\r\n}\r\nstatic int pkcs1pad_decrypt_complete(struct akcipher_request *req, int err)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\r\nunsigned int dst_len;\r\nunsigned int pos;\r\nu8 *out_buf;\r\nif (err)\r\ngoto done;\r\nerr = -EINVAL;\r\ndst_len = req_ctx->child_req.dst_len;\r\nif (dst_len < ctx->key_size - 1)\r\ngoto done;\r\nout_buf = req_ctx->out_buf;\r\nif (dst_len == ctx->key_size) {\r\nif (out_buf[0] != 0x00)\r\ngoto done;\r\ndst_len--;\r\nout_buf++;\r\n}\r\nif (out_buf[0] != 0x02)\r\ngoto done;\r\nfor (pos = 1; pos < dst_len; pos++)\r\nif (out_buf[pos] == 0x00)\r\nbreak;\r\nif (pos < 9 || pos == dst_len)\r\ngoto done;\r\npos++;\r\nerr = 0;\r\nif (req->dst_len < dst_len - pos)\r\nerr = -EOVERFLOW;\r\nreq->dst_len = dst_len - pos;\r\nif (!err)\r\nsg_copy_from_buffer(req->dst,\r\nsg_nents_for_len(req->dst, req->dst_len),\r\nout_buf + pos, req->dst_len);\r\ndone:\r\nkzfree(req_ctx->out_buf);\r\nreturn err;\r\n}\r\nstatic void pkcs1pad_decrypt_complete_cb(\r\nstruct crypto_async_request *child_async_req, int err)\r\n{\r\nstruct akcipher_request *req = child_async_req->data;\r\nstruct crypto_async_request async_req;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nasync_req.data = req->base.data;\r\nasync_req.tfm = crypto_akcipher_tfm(crypto_akcipher_reqtfm(req));\r\nasync_req.flags = child_async_req->flags;\r\nreq->base.complete(&async_req, pkcs1pad_decrypt_complete(req, err));\r\n}\r\nstatic int pkcs1pad_decrypt(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\r\nint err;\r\nif (!ctx->key_size || req->src_len != ctx->key_size)\r\nreturn -EINVAL;\r\nreq_ctx->out_buf = kmalloc(ctx->key_size, GFP_KERNEL);\r\nif (!req_ctx->out_buf)\r\nreturn -ENOMEM;\r\npkcs1pad_sg_set_buf(req_ctx->out_sg, req_ctx->out_buf,\r\nctx->key_size, NULL);\r\nakcipher_request_set_tfm(&req_ctx->child_req, ctx->child);\r\nakcipher_request_set_callback(&req_ctx->child_req, req->base.flags,\r\npkcs1pad_decrypt_complete_cb, req);\r\nakcipher_request_set_crypt(&req_ctx->child_req, req->src,\r\nreq_ctx->out_sg, req->src_len,\r\nctx->key_size);\r\nerr = crypto_akcipher_decrypt(&req_ctx->child_req);\r\nif (err != -EINPROGRESS &&\r\n(err != -EBUSY ||\r\n!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)))\r\nreturn pkcs1pad_decrypt_complete(req, err);\r\nreturn err;\r\n}\r\nstatic int pkcs1pad_sign(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\r\nstruct akcipher_instance *inst = akcipher_alg_instance(tfm);\r\nstruct pkcs1pad_inst_ctx *ictx = akcipher_instance_ctx(inst);\r\nconst struct rsa_asn1_template *digest_info = ictx->digest_info;\r\nint err;\r\nunsigned int ps_end, digest_size = 0;\r\nif (!ctx->key_size)\r\nreturn -EINVAL;\r\ndigest_size = digest_info->size;\r\nif (req->src_len + digest_size > ctx->key_size - 11)\r\nreturn -EOVERFLOW;\r\nif (req->dst_len < ctx->key_size) {\r\nreq->dst_len = ctx->key_size;\r\nreturn -EOVERFLOW;\r\n}\r\nreq_ctx->in_buf = kmalloc(ctx->key_size - 1 - req->src_len,\r\nGFP_KERNEL);\r\nif (!req_ctx->in_buf)\r\nreturn -ENOMEM;\r\nps_end = ctx->key_size - digest_size - req->src_len - 2;\r\nreq_ctx->in_buf[0] = 0x01;\r\nmemset(req_ctx->in_buf + 1, 0xff, ps_end - 1);\r\nreq_ctx->in_buf[ps_end] = 0x00;\r\nmemcpy(req_ctx->in_buf + ps_end + 1, digest_info->data,\r\ndigest_info->size);\r\npkcs1pad_sg_set_buf(req_ctx->in_sg, req_ctx->in_buf,\r\nctx->key_size - 1 - req->src_len, req->src);\r\nakcipher_request_set_tfm(&req_ctx->child_req, ctx->child);\r\nakcipher_request_set_callback(&req_ctx->child_req, req->base.flags,\r\npkcs1pad_encrypt_sign_complete_cb, req);\r\nakcipher_request_set_crypt(&req_ctx->child_req, req_ctx->in_sg,\r\nreq->dst, ctx->key_size - 1, req->dst_len);\r\nerr = crypto_akcipher_sign(&req_ctx->child_req);\r\nif (err != -EINPROGRESS &&\r\n(err != -EBUSY ||\r\n!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)))\r\nreturn pkcs1pad_encrypt_sign_complete(req, err);\r\nreturn err;\r\n}\r\nstatic int pkcs1pad_verify_complete(struct akcipher_request *req, int err)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\r\nstruct akcipher_instance *inst = akcipher_alg_instance(tfm);\r\nstruct pkcs1pad_inst_ctx *ictx = akcipher_instance_ctx(inst);\r\nconst struct rsa_asn1_template *digest_info = ictx->digest_info;\r\nunsigned int dst_len;\r\nunsigned int pos;\r\nu8 *out_buf;\r\nif (err)\r\ngoto done;\r\nerr = -EINVAL;\r\ndst_len = req_ctx->child_req.dst_len;\r\nif (dst_len < ctx->key_size - 1)\r\ngoto done;\r\nout_buf = req_ctx->out_buf;\r\nif (dst_len == ctx->key_size) {\r\nif (out_buf[0] != 0x00)\r\ngoto done;\r\ndst_len--;\r\nout_buf++;\r\n}\r\nerr = -EBADMSG;\r\nif (out_buf[0] != 0x01)\r\ngoto done;\r\nfor (pos = 1; pos < dst_len; pos++)\r\nif (out_buf[pos] != 0xff)\r\nbreak;\r\nif (pos < 9 || pos == dst_len || out_buf[pos] != 0x00)\r\ngoto done;\r\npos++;\r\nif (memcmp(out_buf + pos, digest_info->data, digest_info->size))\r\ngoto done;\r\npos += digest_info->size;\r\nerr = 0;\r\nif (req->dst_len < dst_len - pos)\r\nerr = -EOVERFLOW;\r\nreq->dst_len = dst_len - pos;\r\nif (!err)\r\nsg_copy_from_buffer(req->dst,\r\nsg_nents_for_len(req->dst, req->dst_len),\r\nout_buf + pos, req->dst_len);\r\ndone:\r\nkzfree(req_ctx->out_buf);\r\nreturn err;\r\n}\r\nstatic void pkcs1pad_verify_complete_cb(\r\nstruct crypto_async_request *child_async_req, int err)\r\n{\r\nstruct akcipher_request *req = child_async_req->data;\r\nstruct crypto_async_request async_req;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nasync_req.data = req->base.data;\r\nasync_req.tfm = crypto_akcipher_tfm(crypto_akcipher_reqtfm(req));\r\nasync_req.flags = child_async_req->flags;\r\nreq->base.complete(&async_req, pkcs1pad_verify_complete(req, err));\r\n}\r\nstatic int pkcs1pad_verify(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct pkcs1pad_request *req_ctx = akcipher_request_ctx(req);\r\nint err;\r\nif (!ctx->key_size || req->src_len < ctx->key_size)\r\nreturn -EINVAL;\r\nreq_ctx->out_buf = kmalloc(ctx->key_size, GFP_KERNEL);\r\nif (!req_ctx->out_buf)\r\nreturn -ENOMEM;\r\npkcs1pad_sg_set_buf(req_ctx->out_sg, req_ctx->out_buf,\r\nctx->key_size, NULL);\r\nakcipher_request_set_tfm(&req_ctx->child_req, ctx->child);\r\nakcipher_request_set_callback(&req_ctx->child_req, req->base.flags,\r\npkcs1pad_verify_complete_cb, req);\r\nakcipher_request_set_crypt(&req_ctx->child_req, req->src,\r\nreq_ctx->out_sg, req->src_len,\r\nctx->key_size);\r\nerr = crypto_akcipher_verify(&req_ctx->child_req);\r\nif (err != -EINPROGRESS &&\r\n(err != -EBUSY ||\r\n!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)))\r\nreturn pkcs1pad_verify_complete(req, err);\r\nreturn err;\r\n}\r\nstatic int pkcs1pad_init_tfm(struct crypto_akcipher *tfm)\r\n{\r\nstruct akcipher_instance *inst = akcipher_alg_instance(tfm);\r\nstruct pkcs1pad_inst_ctx *ictx = akcipher_instance_ctx(inst);\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct crypto_akcipher *child_tfm;\r\nchild_tfm = crypto_spawn_akcipher(&ictx->spawn);\r\nif (IS_ERR(child_tfm))\r\nreturn PTR_ERR(child_tfm);\r\nctx->child = child_tfm;\r\nreturn 0;\r\n}\r\nstatic void pkcs1pad_exit_tfm(struct crypto_akcipher *tfm)\r\n{\r\nstruct pkcs1pad_ctx *ctx = akcipher_tfm_ctx(tfm);\r\ncrypto_free_akcipher(ctx->child);\r\n}\r\nstatic void pkcs1pad_free(struct akcipher_instance *inst)\r\n{\r\nstruct pkcs1pad_inst_ctx *ctx = akcipher_instance_ctx(inst);\r\nstruct crypto_akcipher_spawn *spawn = &ctx->spawn;\r\ncrypto_drop_akcipher(spawn);\r\nkfree(inst);\r\n}\r\nstatic int pkcs1pad_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nconst struct rsa_asn1_template *digest_info;\r\nstruct crypto_attr_type *algt;\r\nstruct akcipher_instance *inst;\r\nstruct pkcs1pad_inst_ctx *ctx;\r\nstruct crypto_akcipher_spawn *spawn;\r\nstruct akcipher_alg *rsa_alg;\r\nconst char *rsa_alg_name;\r\nconst char *hash_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AKCIPHER) & algt->mask)\r\nreturn -EINVAL;\r\nrsa_alg_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(rsa_alg_name))\r\nreturn PTR_ERR(rsa_alg_name);\r\nhash_name = crypto_attr_alg_name(tb[2]);\r\nif (IS_ERR(hash_name))\r\nreturn PTR_ERR(hash_name);\r\ndigest_info = rsa_lookup_asn1(hash_name);\r\nif (!digest_info)\r\nreturn -EINVAL;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\nctx = akcipher_instance_ctx(inst);\r\nspawn = &ctx->spawn;\r\nctx->digest_info = digest_info;\r\ncrypto_set_spawn(&spawn->base, akcipher_crypto_instance(inst));\r\nerr = crypto_grab_akcipher(spawn, rsa_alg_name, 0,\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (err)\r\ngoto out_free_inst;\r\nrsa_alg = crypto_spawn_akcipher_alg(spawn);\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"pkcs1pad(%s,%s)", rsa_alg->base.cra_name, hash_name) >=\r\nCRYPTO_MAX_ALG_NAME ||\r\nsnprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"pkcs1pad(%s,%s)",\r\nrsa_alg->base.cra_driver_name, hash_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_alg;\r\ninst->alg.base.cra_flags = rsa_alg->base.cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = rsa_alg->base.cra_priority;\r\ninst->alg.base.cra_ctxsize = sizeof(struct pkcs1pad_ctx);\r\ninst->alg.init = pkcs1pad_init_tfm;\r\ninst->alg.exit = pkcs1pad_exit_tfm;\r\ninst->alg.encrypt = pkcs1pad_encrypt;\r\ninst->alg.decrypt = pkcs1pad_decrypt;\r\ninst->alg.sign = pkcs1pad_sign;\r\ninst->alg.verify = pkcs1pad_verify;\r\ninst->alg.set_pub_key = pkcs1pad_set_pub_key;\r\ninst->alg.set_priv_key = pkcs1pad_set_priv_key;\r\ninst->alg.max_size = pkcs1pad_get_max_size;\r\ninst->alg.reqsize = sizeof(struct pkcs1pad_request) + rsa_alg->reqsize;\r\ninst->free = pkcs1pad_free;\r\nerr = akcipher_register_instance(tmpl, inst);\r\nif (err)\r\ngoto out_drop_alg;\r\nreturn 0;\r\nout_drop_alg:\r\ncrypto_drop_akcipher(spawn);\r\nout_free_inst:\r\nkfree(inst);\r\nreturn err;\r\n}
