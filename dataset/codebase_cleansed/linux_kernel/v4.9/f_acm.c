static inline struct f_acm *func_to_acm(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_acm, port.func);\r\n}\r\nstatic inline struct f_acm *port_to_acm(struct gserial *p)\r\n{\r\nreturn container_of(p, struct f_acm, port);\r\n}\r\nstatic void acm_complete_set_line_coding(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct f_acm *acm = ep->driver_data;\r\nstruct usb_composite_dev *cdev = acm->port.func.config->cdev;\r\nif (req->status != 0) {\r\ndev_dbg(&cdev->gadget->dev, "acm ttyGS%d completion, err %d\n",\r\nacm->port_num, req->status);\r\nreturn;\r\n}\r\nif (req->actual != sizeof(acm->port_line_coding)) {\r\ndev_dbg(&cdev->gadget->dev, "acm ttyGS%d short resp, len %d\n",\r\nacm->port_num, req->actual);\r\nusb_ep_set_halt(ep);\r\n} else {\r\nstruct usb_cdc_line_coding *value = req->buf;\r\nacm->port_line_coding = *value;\r\n}\r\n}\r\nstatic int acm_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_REQ_SET_LINE_CODING:\r\nif (w_length != sizeof(struct usb_cdc_line_coding)\r\n|| w_index != acm->ctrl_id)\r\ngoto invalid;\r\nvalue = w_length;\r\ncdev->gadget->ep0->driver_data = acm;\r\nreq->complete = acm_complete_set_line_coding;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_REQ_GET_LINE_CODING:\r\nif (w_index != acm->ctrl_id)\r\ngoto invalid;\r\nvalue = min_t(unsigned, w_length,\r\nsizeof(struct usb_cdc_line_coding));\r\nmemcpy(req->buf, &acm->port_line_coding, value);\r\nbreak;\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_REQ_SET_CONTROL_LINE_STATE:\r\nif (w_index != acm->ctrl_id)\r\ngoto invalid;\r\nvalue = 0;\r\nacm->port_handshake_bits = w_value;\r\nbreak;\r\ndefault:\r\ninvalid:\r\ndev_vdbg(&cdev->gadget->dev,\r\n"invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\ndev_dbg(&cdev->gadget->dev,\r\n"acm ttyGS%d req%02x.%02x v%04x i%04x l%d\n",\r\nacm->port_num, ctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = 0;\r\nreq->length = value;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(cdev, "acm response on ttyGS%d, err %d\n",\r\nacm->port_num, value);\r\n}\r\nreturn value;\r\n}\r\nstatic int acm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (intf == acm->ctrl_id) {\r\ndev_vdbg(&cdev->gadget->dev,\r\n"reset acm control interface %d\n", intf);\r\nusb_ep_disable(acm->notify);\r\nif (!acm->notify->desc)\r\nif (config_ep_by_speed(cdev->gadget, f, acm->notify))\r\nreturn -EINVAL;\r\nusb_ep_enable(acm->notify);\r\n} else if (intf == acm->data_id) {\r\nif (acm->notify->enabled) {\r\ndev_dbg(&cdev->gadget->dev,\r\n"reset acm ttyGS%d\n", acm->port_num);\r\ngserial_disconnect(&acm->port);\r\n}\r\nif (!acm->port.in->desc || !acm->port.out->desc) {\r\ndev_dbg(&cdev->gadget->dev,\r\n"activate acm ttyGS%d\n", acm->port_num);\r\nif (config_ep_by_speed(cdev->gadget, f,\r\nacm->port.in) ||\r\nconfig_ep_by_speed(cdev->gadget, f,\r\nacm->port.out)) {\r\nacm->port.in->desc = NULL;\r\nacm->port.out->desc = NULL;\r\nreturn -EINVAL;\r\n}\r\n}\r\ngserial_connect(&acm->port, acm->port_num);\r\n} else\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void acm_disable(struct usb_function *f)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\ndev_dbg(&cdev->gadget->dev, "acm ttyGS%d deactivated\n", acm->port_num);\r\ngserial_disconnect(&acm->port);\r\nusb_ep_disable(acm->notify);\r\n}\r\nstatic int acm_cdc_notify(struct f_acm *acm, u8 type, u16 value,\r\nvoid *data, unsigned length)\r\n{\r\nstruct usb_ep *ep = acm->notify;\r\nstruct usb_request *req;\r\nstruct usb_cdc_notification *notify;\r\nconst unsigned len = sizeof(*notify) + length;\r\nvoid *buf;\r\nint status;\r\nreq = acm->notify_req;\r\nacm->notify_req = NULL;\r\nacm->pending = false;\r\nreq->length = len;\r\nnotify = req->buf;\r\nbuf = notify + 1;\r\nnotify->bmRequestType = USB_DIR_IN | USB_TYPE_CLASS\r\n| USB_RECIP_INTERFACE;\r\nnotify->bNotificationType = type;\r\nnotify->wValue = cpu_to_le16(value);\r\nnotify->wIndex = cpu_to_le16(acm->ctrl_id);\r\nnotify->wLength = cpu_to_le16(length);\r\nmemcpy(buf, data, length);\r\nspin_unlock(&acm->lock);\r\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nspin_lock(&acm->lock);\r\nif (status < 0) {\r\nERROR(acm->port.func.config->cdev,\r\n"acm ttyGS%d can't notify serial state, %d\n",\r\nacm->port_num, status);\r\nacm->notify_req = req;\r\n}\r\nreturn status;\r\n}\r\nstatic int acm_notify_serial_state(struct f_acm *acm)\r\n{\r\nstruct usb_composite_dev *cdev = acm->port.func.config->cdev;\r\nint status;\r\nspin_lock(&acm->lock);\r\nif (acm->notify_req) {\r\ndev_dbg(&cdev->gadget->dev, "acm ttyGS%d serial state %04x\n",\r\nacm->port_num, acm->serial_state);\r\nstatus = acm_cdc_notify(acm, USB_CDC_NOTIFY_SERIAL_STATE,\r\n0, &acm->serial_state, sizeof(acm->serial_state));\r\n} else {\r\nacm->pending = true;\r\nstatus = 0;\r\n}\r\nspin_unlock(&acm->lock);\r\nreturn status;\r\n}\r\nstatic void acm_cdc_notify_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_acm *acm = req->context;\r\nu8 doit = false;\r\nspin_lock(&acm->lock);\r\nif (req->status != -ESHUTDOWN)\r\ndoit = acm->pending;\r\nacm->notify_req = req;\r\nspin_unlock(&acm->lock);\r\nif (doit)\r\nacm_notify_serial_state(acm);\r\n}\r\nstatic void acm_connect(struct gserial *port)\r\n{\r\nstruct f_acm *acm = port_to_acm(port);\r\nacm->serial_state |= ACM_CTRL_DSR | ACM_CTRL_DCD;\r\nacm_notify_serial_state(acm);\r\n}\r\nstatic void acm_disconnect(struct gserial *port)\r\n{\r\nstruct f_acm *acm = port_to_acm(port);\r\nacm->serial_state &= ~(ACM_CTRL_DSR | ACM_CTRL_DCD);\r\nacm_notify_serial_state(acm);\r\n}\r\nstatic int acm_send_break(struct gserial *port, int duration)\r\n{\r\nstruct f_acm *acm = port_to_acm(port);\r\nu16 state;\r\nstate = acm->serial_state;\r\nstate &= ~ACM_CTRL_BRK;\r\nif (duration)\r\nstate |= ACM_CTRL_BRK;\r\nacm->serial_state = state;\r\nreturn acm_notify_serial_state(acm);\r\n}\r\nstatic int\r\nacm_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_acm *acm = func_to_acm(f);\r\nstruct usb_string *us;\r\nint status;\r\nstruct usb_ep *ep;\r\nus = usb_gstrings_attach(cdev, acm_strings,\r\nARRAY_SIZE(acm_string_defs));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\nacm_control_interface_desc.iInterface = us[ACM_CTRL_IDX].id;\r\nacm_data_interface_desc.iInterface = us[ACM_DATA_IDX].id;\r\nacm_iad_descriptor.iFunction = us[ACM_IAD_IDX].id;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nacm->ctrl_id = status;\r\nacm_iad_descriptor.bFirstInterface = status;\r\nacm_control_interface_desc.bInterfaceNumber = status;\r\nacm_union_desc .bMasterInterface0 = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nacm->data_id = status;\r\nacm_data_interface_desc.bInterfaceNumber = status;\r\nacm_union_desc.bSlaveInterface0 = status;\r\nacm_call_mgmt_descriptor.bDataInterface = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &acm_fs_in_desc);\r\nif (!ep)\r\ngoto fail;\r\nacm->port.in = ep;\r\nep = usb_ep_autoconfig(cdev->gadget, &acm_fs_out_desc);\r\nif (!ep)\r\ngoto fail;\r\nacm->port.out = ep;\r\nep = usb_ep_autoconfig(cdev->gadget, &acm_fs_notify_desc);\r\nif (!ep)\r\ngoto fail;\r\nacm->notify = ep;\r\nacm->notify_req = gs_alloc_req(ep,\r\nsizeof(struct usb_cdc_notification) + 2,\r\nGFP_KERNEL);\r\nif (!acm->notify_req)\r\ngoto fail;\r\nacm->notify_req->complete = acm_cdc_notify_complete;\r\nacm->notify_req->context = acm;\r\nacm_hs_in_desc.bEndpointAddress = acm_fs_in_desc.bEndpointAddress;\r\nacm_hs_out_desc.bEndpointAddress = acm_fs_out_desc.bEndpointAddress;\r\nacm_hs_notify_desc.bEndpointAddress =\r\nacm_fs_notify_desc.bEndpointAddress;\r\nacm_ss_in_desc.bEndpointAddress = acm_fs_in_desc.bEndpointAddress;\r\nacm_ss_out_desc.bEndpointAddress = acm_fs_out_desc.bEndpointAddress;\r\nstatus = usb_assign_descriptors(f, acm_fs_function, acm_hs_function,\r\nacm_ss_function, NULL);\r\nif (status)\r\ngoto fail;\r\ndev_dbg(&cdev->gadget->dev,\r\n"acm ttyGS%d: %s speed IN/%s OUT/%s NOTIFY/%s\n",\r\nacm->port_num,\r\ngadget_is_superspeed(c->cdev->gadget) ? "super" :\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\nacm->port.in->name, acm->port.out->name,\r\nacm->notify->name);\r\nreturn 0;\r\nfail:\r\nif (acm->notify_req)\r\ngs_free_req(acm->notify, acm->notify_req);\r\nERROR(cdev, "%s/%p: can't bind, err %d\n", f->name, f, status);\r\nreturn status;\r\n}\r\nstatic void acm_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nacm_string_defs[0].id = 0;\r\nusb_free_all_descriptors(f);\r\nif (acm->notify_req)\r\ngs_free_req(acm->notify, acm->notify_req);\r\n}\r\nstatic void acm_free_func(struct usb_function *f)\r\n{\r\nstruct f_acm *acm = func_to_acm(f);\r\nkfree(acm);\r\n}\r\nstatic struct usb_function *acm_alloc_func(struct usb_function_instance *fi)\r\n{\r\nstruct f_serial_opts *opts;\r\nstruct f_acm *acm;\r\nacm = kzalloc(sizeof(*acm), GFP_KERNEL);\r\nif (!acm)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&acm->lock);\r\nacm->port.connect = acm_connect;\r\nacm->port.disconnect = acm_disconnect;\r\nacm->port.send_break = acm_send_break;\r\nacm->port.func.name = "acm";\r\nacm->port.func.strings = acm_strings;\r\nacm->port.func.bind = acm_bind;\r\nacm->port.func.set_alt = acm_set_alt;\r\nacm->port.func.setup = acm_setup;\r\nacm->port.func.disable = acm_disable;\r\nopts = container_of(fi, struct f_serial_opts, func_inst);\r\nacm->port_num = opts->port_num;\r\nacm->port.func.unbind = acm_unbind;\r\nacm->port.func.free_func = acm_free_func;\r\nreturn &acm->port.func;\r\n}\r\nstatic inline struct f_serial_opts *to_f_serial_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_serial_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void acm_attr_release(struct config_item *item)\r\n{\r\nstruct f_serial_opts *opts = to_f_serial_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic ssize_t f_acm_port_num_show(struct config_item *item, char *page)\r\n{\r\nreturn sprintf(page, "%u\n", to_f_serial_opts(item)->port_num);\r\n}\r\nstatic void acm_free_instance(struct usb_function_instance *fi)\r\n{\r\nstruct f_serial_opts *opts;\r\nopts = container_of(fi, struct f_serial_opts, func_inst);\r\ngserial_free_line(opts->port_num);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *acm_alloc_instance(void)\r\n{\r\nstruct f_serial_opts *opts;\r\nint ret;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts->func_inst.free_func_inst = acm_free_instance;\r\nret = gserial_alloc_line(&opts->port_num);\r\nif (ret) {\r\nkfree(opts);\r\nreturn ERR_PTR(ret);\r\n}\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&acm_func_type);\r\nreturn &opts->func_inst;\r\n}
