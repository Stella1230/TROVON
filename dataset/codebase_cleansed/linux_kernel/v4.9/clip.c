static int to_atmarpd(enum atmarp_ctrl_type type, int itf, __be32 ip)\r\n{\r\nstruct sock *sk;\r\nstruct atmarp_ctrl *ctrl;\r\nstruct sk_buff *skb;\r\npr_debug("(%d)\n", type);\r\nif (!atmarpd)\r\nreturn -EUNATCH;\r\nskb = alloc_skb(sizeof(struct atmarp_ctrl), GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nctrl = (struct atmarp_ctrl *)skb_put(skb, sizeof(struct atmarp_ctrl));\r\nctrl->type = type;\r\nctrl->itf_num = itf;\r\nctrl->ip = ip;\r\natm_force_charge(atmarpd, skb->truesize);\r\nsk = sk_atm(atmarpd);\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_data_ready(sk);\r\nreturn 0;\r\n}\r\nstatic void link_vcc(struct clip_vcc *clip_vcc, struct atmarp_entry *entry)\r\n{\r\npr_debug("%p to entry %p (neigh %p)\n", clip_vcc, entry, entry->neigh);\r\nclip_vcc->entry = entry;\r\nclip_vcc->xoff = 0;\r\nclip_vcc->next = entry->vccs;\r\nentry->vccs = clip_vcc;\r\nentry->neigh->used = jiffies;\r\n}\r\nstatic void unlink_clip_vcc(struct clip_vcc *clip_vcc)\r\n{\r\nstruct atmarp_entry *entry = clip_vcc->entry;\r\nstruct clip_vcc **walk;\r\nif (!entry) {\r\npr_crit("!clip_vcc->entry (clip_vcc %p)\n", clip_vcc);\r\nreturn;\r\n}\r\nnetif_tx_lock_bh(entry->neigh->dev);\r\nentry->neigh->used = jiffies;\r\nfor (walk = &entry->vccs; *walk; walk = &(*walk)->next)\r\nif (*walk == clip_vcc) {\r\nint error;\r\n*walk = clip_vcc->next;\r\nclip_vcc->entry = NULL;\r\nif (clip_vcc->xoff)\r\nnetif_wake_queue(entry->neigh->dev);\r\nif (entry->vccs)\r\ngoto out;\r\nentry->expires = jiffies - 1;\r\nerror = neigh_update(entry->neigh, NULL, NUD_NONE,\r\nNEIGH_UPDATE_F_ADMIN);\r\nif (error)\r\npr_crit("neigh_update failed with %d\n", error);\r\ngoto out;\r\n}\r\npr_crit("ATMARP: failed (entry %p, vcc 0x%p)\n", entry, clip_vcc);\r\nout:\r\nnetif_tx_unlock_bh(entry->neigh->dev);\r\n}\r\nstatic int neigh_check_cb(struct neighbour *n)\r\n{\r\nstruct atmarp_entry *entry = neighbour_priv(n);\r\nstruct clip_vcc *cv;\r\nif (n->ops != &clip_neigh_ops)\r\nreturn 0;\r\nfor (cv = entry->vccs; cv; cv = cv->next) {\r\nunsigned long exp = cv->last_use + cv->idle_timeout;\r\nif (cv->idle_timeout && time_after(jiffies, exp)) {\r\npr_debug("releasing vcc %p->%p of entry %p\n",\r\ncv, cv->vcc, entry);\r\nvcc_release_async(cv->vcc, -ETIMEDOUT);\r\n}\r\n}\r\nif (entry->vccs || time_before(jiffies, entry->expires))\r\nreturn 0;\r\nif (atomic_read(&n->refcnt) > 1) {\r\nstruct sk_buff *skb;\r\npr_debug("destruction postponed with ref %d\n",\r\natomic_read(&n->refcnt));\r\nwhile ((skb = skb_dequeue(&n->arp_queue)) != NULL)\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\npr_debug("expired neigh %p\n", n);\r\nreturn 1;\r\n}\r\nstatic void idle_timer_check(unsigned long dummy)\r\n{\r\nwrite_lock(&arp_tbl.lock);\r\n__neigh_for_each_release(&arp_tbl, neigh_check_cb);\r\nmod_timer(&idle_timer, jiffies + CLIP_CHECK_INTERVAL * HZ);\r\nwrite_unlock(&arp_tbl.lock);\r\n}\r\nstatic int clip_arp_rcv(struct sk_buff *skb)\r\n{\r\nstruct atm_vcc *vcc;\r\npr_debug("\n");\r\nvcc = ATM_SKB(skb)->vcc;\r\nif (!vcc || !atm_charge(vcc, skb->truesize)) {\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\npr_debug("pushing to %p\n", vcc);\r\npr_debug("using %p\n", CLIP_VCC(vcc)->old_push);\r\nCLIP_VCC(vcc)->old_push(vcc, skb);\r\nreturn 0;\r\n}\r\nstatic void clip_push(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct clip_vcc *clip_vcc = CLIP_VCC(vcc);\r\npr_debug("\n");\r\nif (!clip_devs) {\r\natm_return(vcc, skb->truesize);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (!skb) {\r\npr_debug("removing VCC %p\n", clip_vcc);\r\nif (clip_vcc->entry)\r\nunlink_clip_vcc(clip_vcc);\r\nclip_vcc->old_push(vcc, NULL);\r\nkfree(clip_vcc);\r\nreturn;\r\n}\r\natm_return(vcc, skb->truesize);\r\nskb->dev = clip_vcc->entry ? clip_vcc->entry->neigh->dev : clip_devs;\r\nif (!skb->dev) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nATM_SKB(skb)->vcc = vcc;\r\nskb_reset_mac_header(skb);\r\nif (!clip_vcc->encap ||\r\nskb->len < RFC1483LLC_LEN ||\r\nmemcmp(skb->data, llc_oui, sizeof(llc_oui)))\r\nskb->protocol = htons(ETH_P_IP);\r\nelse {\r\nskb->protocol = ((__be16 *)skb->data)[3];\r\nskb_pull(skb, RFC1483LLC_LEN);\r\nif (skb->protocol == htons(ETH_P_ARP)) {\r\nskb->dev->stats.rx_packets++;\r\nskb->dev->stats.rx_bytes += skb->len;\r\nclip_arp_rcv(skb);\r\nreturn;\r\n}\r\n}\r\nclip_vcc->last_use = jiffies;\r\nskb->dev->stats.rx_packets++;\r\nskb->dev->stats.rx_bytes += skb->len;\r\nmemset(ATM_SKB(skb), 0, sizeof(struct atm_skb_data));\r\nnetif_rx(skb);\r\n}\r\nstatic void clip_pop(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct clip_vcc *clip_vcc = CLIP_VCC(vcc);\r\nstruct net_device *dev = skb->dev;\r\nint old;\r\nunsigned long flags;\r\npr_debug("(vcc %p)\n", vcc);\r\nclip_vcc->old_pop(vcc, skb);\r\nif (!dev)\r\nreturn;\r\nspin_lock_irqsave(&PRIV(dev)->xoff_lock, flags);\r\nif (atm_may_send(vcc, 0)) {\r\nold = xchg(&clip_vcc->xoff, 0);\r\nif (old)\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&PRIV(dev)->xoff_lock, flags);\r\n}\r\nstatic void clip_neigh_solicit(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\n__be32 *ip = (__be32 *) neigh->primary_key;\r\npr_debug("(neigh %p, skb %p)\n", neigh, skb);\r\nto_atmarpd(act_need, PRIV(neigh->dev)->number, *ip);\r\n}\r\nstatic void clip_neigh_error(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\n#ifndef CONFIG_ATM_CLIP_NO_ICMP\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_UNREACH, 0);\r\n#endif\r\nkfree_skb(skb);\r\n}\r\nstatic int clip_constructor(struct net_device *dev, struct neighbour *neigh)\r\n{\r\nstruct atmarp_entry *entry = neighbour_priv(neigh);\r\nif (neigh->tbl->family != AF_INET)\r\nreturn -EINVAL;\r\nif (neigh->type != RTN_UNICAST)\r\nreturn -EINVAL;\r\nneigh->nud_state = NUD_NONE;\r\nneigh->ops = &clip_neigh_ops;\r\nneigh->output = neigh->ops->output;\r\nentry->neigh = neigh;\r\nentry->vccs = NULL;\r\nentry->expires = jiffies - 1;\r\nreturn 0;\r\n}\r\nstatic int clip_encap(struct atm_vcc *vcc, int mode)\r\n{\r\nif (!CLIP_VCC(vcc))\r\nreturn -EBADFD;\r\nCLIP_VCC(vcc)->encap = mode;\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t clip_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct clip_priv *clip_priv = PRIV(dev);\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct atmarp_entry *entry;\r\nstruct neighbour *n;\r\nstruct atm_vcc *vcc;\r\nstruct rtable *rt;\r\n__be32 *daddr;\r\nint old;\r\nunsigned long flags;\r\npr_debug("(skb %p)\n", skb);\r\nif (!dst) {\r\npr_err("skb_dst(skb) == NULL\n");\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nrt = (struct rtable *) dst;\r\nif (rt->rt_gateway)\r\ndaddr = &rt->rt_gateway;\r\nelse\r\ndaddr = &ip_hdr(skb)->daddr;\r\nn = dst_neigh_lookup(dst, daddr);\r\nif (!n) {\r\npr_err("NO NEIGHBOUR !\n");\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nentry = neighbour_priv(n);\r\nif (!entry->vccs) {\r\nif (time_after(jiffies, entry->expires)) {\r\nentry->expires = jiffies + ATMARP_RETRY_DELAY * HZ;\r\nto_atmarpd(act_need, PRIV(dev)->number, *((__be32 *)n->primary_key));\r\n}\r\nif (entry->neigh->arp_queue.qlen < ATMARP_MAX_UNRES_PACKETS)\r\nskb_queue_tail(&entry->neigh->arp_queue, skb);\r\nelse {\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\n}\r\ngoto out_release_neigh;\r\n}\r\npr_debug("neigh %p, vccs %p\n", entry, entry->vccs);\r\nATM_SKB(skb)->vcc = vcc = entry->vccs->vcc;\r\npr_debug("using neighbour %p, vcc %p\n", n, vcc);\r\nif (entry->vccs->encap) {\r\nvoid *here;\r\nhere = skb_push(skb, RFC1483LLC_LEN);\r\nmemcpy(here, llc_oui, sizeof(llc_oui));\r\n((__be16 *) here)[3] = skb->protocol;\r\n}\r\natomic_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);\r\nATM_SKB(skb)->atm_options = vcc->atm_options;\r\nentry->vccs->last_use = jiffies;\r\npr_debug("atm_skb(%p)->vcc(%p)->dev(%p)\n", skb, vcc, vcc->dev);\r\nold = xchg(&entry->vccs->xoff, 1);\r\nif (old) {\r\npr_warn("XOFF->XOFF transition\n");\r\ngoto out_release_neigh;\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nvcc->send(vcc, skb);\r\nif (atm_may_send(vcc, 0)) {\r\nentry->vccs->xoff = 0;\r\ngoto out_release_neigh;\r\n}\r\nspin_lock_irqsave(&clip_priv->xoff_lock, flags);\r\nnetif_stop_queue(dev);\r\nbarrier();\r\nif (!entry->vccs->xoff)\r\nnetif_start_queue(dev);\r\nspin_unlock_irqrestore(&clip_priv->xoff_lock, flags);\r\nout_release_neigh:\r\nneigh_release(n);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int clip_mkip(struct atm_vcc *vcc, int timeout)\r\n{\r\nstruct clip_vcc *clip_vcc;\r\nif (!vcc->push)\r\nreturn -EBADFD;\r\nclip_vcc = kmalloc(sizeof(struct clip_vcc), GFP_KERNEL);\r\nif (!clip_vcc)\r\nreturn -ENOMEM;\r\npr_debug("%p vcc %p\n", clip_vcc, vcc);\r\nclip_vcc->vcc = vcc;\r\nvcc->user_back = clip_vcc;\r\nset_bit(ATM_VF_IS_CLIP, &vcc->flags);\r\nclip_vcc->entry = NULL;\r\nclip_vcc->xoff = 0;\r\nclip_vcc->encap = 1;\r\nclip_vcc->last_use = jiffies;\r\nclip_vcc->idle_timeout = timeout * HZ;\r\nclip_vcc->old_push = vcc->push;\r\nclip_vcc->old_pop = vcc->pop;\r\nvcc->push = clip_push;\r\nvcc->pop = clip_pop;\r\nvcc_process_recv_queue(vcc);\r\nreturn 0;\r\n}\r\nstatic int clip_setentry(struct atm_vcc *vcc, __be32 ip)\r\n{\r\nstruct neighbour *neigh;\r\nstruct atmarp_entry *entry;\r\nint error;\r\nstruct clip_vcc *clip_vcc;\r\nstruct rtable *rt;\r\nif (vcc->push != clip_push) {\r\npr_warn("non-CLIP VCC\n");\r\nreturn -EBADF;\r\n}\r\nclip_vcc = CLIP_VCC(vcc);\r\nif (!ip) {\r\nif (!clip_vcc->entry) {\r\npr_err("hiding hidden ATMARP entry\n");\r\nreturn 0;\r\n}\r\npr_debug("remove\n");\r\nunlink_clip_vcc(clip_vcc);\r\nreturn 0;\r\n}\r\nrt = ip_route_output(&init_net, ip, 0, 1, 0);\r\nif (IS_ERR(rt))\r\nreturn PTR_ERR(rt);\r\nneigh = __neigh_lookup(&arp_tbl, &ip, rt->dst.dev, 1);\r\nip_rt_put(rt);\r\nif (!neigh)\r\nreturn -ENOMEM;\r\nentry = neighbour_priv(neigh);\r\nif (entry != clip_vcc->entry) {\r\nif (!clip_vcc->entry)\r\npr_debug("add\n");\r\nelse {\r\npr_debug("update\n");\r\nunlink_clip_vcc(clip_vcc);\r\n}\r\nlink_vcc(clip_vcc, entry);\r\n}\r\nerror = neigh_update(neigh, llc_oui, NUD_PERMANENT,\r\nNEIGH_UPDATE_F_OVERRIDE | NEIGH_UPDATE_F_ADMIN);\r\nneigh_release(neigh);\r\nreturn error;\r\n}\r\nstatic void clip_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &clip_netdev_ops;\r\ndev->type = ARPHRD_ATM;\r\ndev->neigh_priv_len = sizeof(struct atmarp_entry);\r\ndev->hard_header_len = RFC1483LLC_LEN;\r\ndev->mtu = RFC1626_MTU;\r\ndev->tx_queue_len = 100;\r\nnetif_keep_dst(dev);\r\n}\r\nstatic int clip_create(int number)\r\n{\r\nstruct net_device *dev;\r\nstruct clip_priv *clip_priv;\r\nint error;\r\nif (number != -1) {\r\nfor (dev = clip_devs; dev; dev = PRIV(dev)->next)\r\nif (PRIV(dev)->number == number)\r\nreturn -EEXIST;\r\n} else {\r\nnumber = 0;\r\nfor (dev = clip_devs; dev; dev = PRIV(dev)->next)\r\nif (PRIV(dev)->number >= number)\r\nnumber = PRIV(dev)->number + 1;\r\n}\r\ndev = alloc_netdev(sizeof(struct clip_priv), "", NET_NAME_UNKNOWN,\r\nclip_setup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nclip_priv = PRIV(dev);\r\nsprintf(dev->name, "atm%d", number);\r\nspin_lock_init(&clip_priv->xoff_lock);\r\nclip_priv->number = number;\r\nerror = register_netdev(dev);\r\nif (error) {\r\nfree_netdev(dev);\r\nreturn error;\r\n}\r\nclip_priv->next = clip_devs;\r\nclip_devs = dev;\r\npr_debug("registered (net:%s)\n", dev->name);\r\nreturn number;\r\n}\r\nstatic int clip_device_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (event == NETDEV_UNREGISTER)\r\nreturn NOTIFY_DONE;\r\nif (dev->type != ARPHRD_ATM || dev->netdev_ops != &clip_netdev_ops)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\npr_debug("NETDEV_UP\n");\r\nto_atmarpd(act_up, PRIV(dev)->number, 0);\r\nbreak;\r\ncase NETDEV_GOING_DOWN:\r\npr_debug("NETDEV_DOWN\n");\r\nto_atmarpd(act_down, PRIV(dev)->number, 0);\r\nbreak;\r\ncase NETDEV_CHANGE:\r\ncase NETDEV_CHANGEMTU:\r\npr_debug("NETDEV_CHANGE*\n");\r\nto_atmarpd(act_change, PRIV(dev)->number, 0);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int clip_inet_event(struct notifier_block *this, unsigned long event,\r\nvoid *ifa)\r\n{\r\nstruct in_device *in_dev;\r\nstruct netdev_notifier_info info;\r\nin_dev = ((struct in_ifaddr *)ifa)->ifa_dev;\r\nif (event != NETDEV_UP)\r\nreturn NOTIFY_DONE;\r\nnetdev_notifier_info_init(&info, in_dev->dev);\r\nreturn clip_device_event(this, NETDEV_CHANGE, &info);\r\n}\r\nstatic void atmarpd_close(struct atm_vcc *vcc)\r\n{\r\npr_debug("\n");\r\nrtnl_lock();\r\natmarpd = NULL;\r\nskb_queue_purge(&sk_atm(vcc)->sk_receive_queue);\r\nrtnl_unlock();\r\npr_debug("(done)\n");\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int atm_init_atmarp(struct atm_vcc *vcc)\r\n{\r\nrtnl_lock();\r\nif (atmarpd) {\r\nrtnl_unlock();\r\nreturn -EADDRINUSE;\r\n}\r\nmod_timer(&idle_timer, jiffies + CLIP_CHECK_INTERVAL * HZ);\r\natmarpd = vcc;\r\nset_bit(ATM_VF_META, &vcc->flags);\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\nvcc->dev = &atmarpd_dev;\r\nvcc_insert_socket(sk_atm(vcc));\r\nvcc->push = NULL;\r\nvcc->pop = NULL;\r\nvcc->push_oam = NULL;\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int clip_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct atm_vcc *vcc = ATM_SD(sock);\r\nint err = 0;\r\nswitch (cmd) {\r\ncase SIOCMKCLIP:\r\ncase ATMARPD_CTRL:\r\ncase ATMARP_MKIP:\r\ncase ATMARP_SETENTRY:\r\ncase ATMARP_ENCAP:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nswitch (cmd) {\r\ncase SIOCMKCLIP:\r\nerr = clip_create(arg);\r\nbreak;\r\ncase ATMARPD_CTRL:\r\nerr = atm_init_atmarp(vcc);\r\nif (!err) {\r\nsock->state = SS_CONNECTED;\r\n__module_get(THIS_MODULE);\r\n}\r\nbreak;\r\ncase ATMARP_MKIP:\r\nerr = clip_mkip(vcc, arg);\r\nbreak;\r\ncase ATMARP_SETENTRY:\r\nerr = clip_setentry(vcc, (__force __be32)arg);\r\nbreak;\r\ncase ATMARP_ENCAP:\r\nerr = clip_encap(vcc, arg);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void svc_addr(struct seq_file *seq, struct sockaddr_atmsvc *addr)\r\n{\r\nstatic int code[] = { 1, 2, 10, 6, 1, 0 };\r\nstatic int e164[] = { 1, 8, 4, 6, 1, 0 };\r\nif (*addr->sas_addr.pub) {\r\nseq_printf(seq, "%s", addr->sas_addr.pub);\r\nif (*addr->sas_addr.prv)\r\nseq_putc(seq, '+');\r\n} else if (!*addr->sas_addr.prv) {\r\nseq_printf(seq, "%s", "(none)");\r\nreturn;\r\n}\r\nif (*addr->sas_addr.prv) {\r\nunsigned char *prv = addr->sas_addr.prv;\r\nint *fields;\r\nint i, j;\r\nfields = *prv == ATM_AFI_E164 ? e164 : code;\r\nfor (i = 0; fields[i]; i++) {\r\nfor (j = fields[i]; j; j--)\r\nseq_printf(seq, "%02X", *prv++);\r\nif (fields[i + 1])\r\nseq_putc(seq, '.');\r\n}\r\n}\r\n}\r\nstatic void atmarp_info(struct seq_file *seq, struct neighbour *n,\r\nstruct atmarp_entry *entry, struct clip_vcc *clip_vcc)\r\n{\r\nstruct net_device *dev = n->dev;\r\nunsigned long exp;\r\nchar buf[17];\r\nint svc, llc, off;\r\nsvc = ((clip_vcc == SEQ_NO_VCC_TOKEN) ||\r\n(sk_atm(clip_vcc->vcc)->sk_family == AF_ATMSVC));\r\nllc = ((clip_vcc == SEQ_NO_VCC_TOKEN) || clip_vcc->encap);\r\nif (clip_vcc == SEQ_NO_VCC_TOKEN)\r\nexp = entry->neigh->used;\r\nelse\r\nexp = clip_vcc->last_use;\r\nexp = (jiffies - exp) / HZ;\r\nseq_printf(seq, "%-6s%-4s%-4s%5ld ",\r\ndev->name, svc ? "SVC" : "PVC", llc ? "LLC" : "NULL", exp);\r\noff = scnprintf(buf, sizeof(buf) - 1, "%pI4", n->primary_key);\r\nwhile (off < 16)\r\nbuf[off++] = ' ';\r\nbuf[off] = '\0';\r\nseq_printf(seq, "%s", buf);\r\nif (clip_vcc == SEQ_NO_VCC_TOKEN) {\r\nif (time_before(jiffies, entry->expires))\r\nseq_printf(seq, "(resolving)\n");\r\nelse\r\nseq_printf(seq, "(expired, ref %d)\n",\r\natomic_read(&entry->neigh->refcnt));\r\n} else if (!svc) {\r\nseq_printf(seq, "%d.%d.%d\n",\r\nclip_vcc->vcc->dev->number,\r\nclip_vcc->vcc->vpi, clip_vcc->vcc->vci);\r\n} else {\r\nsvc_addr(seq, &clip_vcc->vcc->remote);\r\nseq_putc(seq, '\n');\r\n}\r\n}\r\nstatic struct clip_vcc *clip_seq_next_vcc(struct atmarp_entry *e,\r\nstruct clip_vcc *curr)\r\n{\r\nif (!curr) {\r\ncurr = e->vccs;\r\nif (!curr)\r\nreturn SEQ_NO_VCC_TOKEN;\r\nreturn curr;\r\n}\r\nif (curr == SEQ_NO_VCC_TOKEN)\r\nreturn NULL;\r\ncurr = curr->next;\r\nreturn curr;\r\n}\r\nstatic void *clip_seq_vcc_walk(struct clip_seq_state *state,\r\nstruct atmarp_entry *e, loff_t * pos)\r\n{\r\nstruct clip_vcc *vcc = state->vcc;\r\nvcc = clip_seq_next_vcc(e, vcc);\r\nif (vcc && pos != NULL) {\r\nwhile (*pos) {\r\nvcc = clip_seq_next_vcc(e, vcc);\r\nif (!vcc)\r\nbreak;\r\n--(*pos);\r\n}\r\n}\r\nstate->vcc = vcc;\r\nreturn vcc;\r\n}\r\nstatic void *clip_seq_sub_iter(struct neigh_seq_state *_state,\r\nstruct neighbour *n, loff_t * pos)\r\n{\r\nstruct clip_seq_state *state = (struct clip_seq_state *)_state;\r\nif (n->dev->type != ARPHRD_ATM)\r\nreturn NULL;\r\nreturn clip_seq_vcc_walk(state, neighbour_priv(n), pos);\r\n}\r\nstatic void *clip_seq_start(struct seq_file *seq, loff_t * pos)\r\n{\r\nstruct clip_seq_state *state = seq->private;\r\nstate->ns.neigh_sub_iter = clip_seq_sub_iter;\r\nreturn neigh_seq_start(seq, pos, &arp_tbl, NEIGH_SEQ_NEIGH_ONLY);\r\n}\r\nstatic int clip_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstatic char atm_arp_banner[] =\r\n"IPitf TypeEncp Idle IP address ATM address\n";\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, atm_arp_banner);\r\n} else {\r\nstruct clip_seq_state *state = seq->private;\r\nstruct clip_vcc *vcc = state->vcc;\r\nstruct neighbour *n = v;\r\natmarp_info(seq, n, neighbour_priv(n), vcc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int arp_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &arp_seq_ops,\r\nsizeof(struct clip_seq_state));\r\n}\r\nstatic int __init atm_clip_init(void)\r\n{\r\nregister_atm_ioctl(&clip_ioctl_ops);\r\nregister_netdevice_notifier(&clip_dev_notifier);\r\nregister_inetaddr_notifier(&clip_inet_notifier);\r\nsetup_timer(&idle_timer, idle_timer_check, 0);\r\n#ifdef CONFIG_PROC_FS\r\n{\r\nstruct proc_dir_entry *p;\r\np = proc_create("arp", S_IRUGO, atm_proc_root, &arp_seq_fops);\r\nif (!p) {\r\npr_err("Unable to initialize /proc/net/atm/arp\n");\r\natm_clip_exit_noproc();\r\nreturn -ENOMEM;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void atm_clip_exit_noproc(void)\r\n{\r\nstruct net_device *dev, *next;\r\nunregister_inetaddr_notifier(&clip_inet_notifier);\r\nunregister_netdevice_notifier(&clip_dev_notifier);\r\nderegister_atm_ioctl(&clip_ioctl_ops);\r\ndel_timer_sync(&idle_timer);\r\ndev = clip_devs;\r\nwhile (dev) {\r\nnext = PRIV(dev)->next;\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\ndev = next;\r\n}\r\n}\r\nstatic void __exit atm_clip_exit(void)\r\n{\r\nremove_proc_entry("arp", atm_proc_root);\r\natm_clip_exit_noproc();\r\n}
