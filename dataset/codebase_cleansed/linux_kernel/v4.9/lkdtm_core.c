static unsigned int jp_do_irq(unsigned int irq)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic irqreturn_t jp_handle_irq_event(unsigned int irq,\r\nstruct irqaction *action)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic void jp_tasklet_action(struct softirq_action *a)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\n}\r\nstatic void jp_ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\n}\r\nstatic unsigned long jp_shrink_inactive_list(unsigned long max_scan,\r\nstruct zone *zone,\r\nstruct scan_control *sc)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int jp_hrtimer_start(struct hrtimer *timer, ktime_t tim,\r\nconst enum hrtimer_mode mode)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int jp_scsi_dispatch_cmd(struct scsi_cmnd *cmd)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic int jp_generic_ide_ioctl(ide_drive_t *drive, struct file *file,\r\nstruct block_device *bdev, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nlkdtm_handler();\r\njprobe_return();\r\nreturn 0;\r\n}\r\nstatic struct crashtype *find_crashtype(const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(crashtypes); i++) {\r\nif (!strcmp(name, crashtypes[i].name))\r\nreturn &crashtypes[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic noinline void lkdtm_do_action(struct crashtype *crashtype)\r\n{\r\nBUG_ON(!crashtype || !crashtype->func);\r\ncrashtype->func();\r\n}\r\nstatic int lkdtm_register_cpoint(struct crashpoint *crashpoint,\r\nstruct crashtype *crashtype)\r\n{\r\nint ret;\r\nif (!crashpoint->jprobe.kp.symbol_name) {\r\nlkdtm_do_action(crashtype);\r\nreturn 0;\r\n}\r\nif (lkdtm_jprobe != NULL)\r\nunregister_jprobe(lkdtm_jprobe);\r\nlkdtm_crashpoint = crashpoint;\r\nlkdtm_crashtype = crashtype;\r\nlkdtm_jprobe = &crashpoint->jprobe;\r\nret = register_jprobe(lkdtm_jprobe);\r\nif (ret < 0) {\r\npr_info("Couldn't register jprobe %s\n",\r\ncrashpoint->jprobe.kp.symbol_name);\r\nlkdtm_jprobe = NULL;\r\nlkdtm_crashpoint = NULL;\r\nlkdtm_crashtype = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void lkdtm_handler(void)\r\n{\r\nunsigned long flags;\r\nbool do_it = false;\r\nBUG_ON(!lkdtm_crashpoint || !lkdtm_crashtype);\r\nspin_lock_irqsave(&crash_count_lock, flags);\r\ncrash_count--;\r\npr_info("Crash point %s of type %s hit, trigger in %d rounds\n",\r\nlkdtm_crashpoint->name, lkdtm_crashtype->name, crash_count);\r\nif (crash_count == 0) {\r\ndo_it = true;\r\ncrash_count = cpoint_count;\r\n}\r\nspin_unlock_irqrestore(&crash_count_lock, flags);\r\nif (do_it)\r\nlkdtm_do_action(lkdtm_crashtype);\r\n}\r\nstatic ssize_t lkdtm_debugfs_entry(struct file *f,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct crashpoint *crashpoint = file_inode(f)->i_private;\r\nstruct crashtype *crashtype = NULL;\r\nchar *buf;\r\nint err;\r\nif (count >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, user_buf, count)) {\r\nfree_page((unsigned long) buf);\r\nreturn -EFAULT;\r\n}\r\nbuf[count] = '\0';\r\nstrim(buf);\r\ncrashtype = find_crashtype(buf);\r\nfree_page((unsigned long)buf);\r\nif (!crashtype)\r\nreturn -EINVAL;\r\nerr = lkdtm_register_cpoint(crashpoint, crashtype);\r\nif (err < 0)\r\nreturn err;\r\n*off += count;\r\nreturn count;\r\n}\r\nstatic ssize_t lkdtm_debugfs_read(struct file *f, char __user *user_buf,\r\nsize_t count, loff_t *off)\r\n{\r\nchar *buf;\r\nint i, n, out;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nn = snprintf(buf, PAGE_SIZE, "Available crash types:\n");\r\nfor (i = 0; i < ARRAY_SIZE(crashtypes); i++) {\r\nn += snprintf(buf + n, PAGE_SIZE - n, "%s\n",\r\ncrashtypes[i].name);\r\n}\r\nbuf[n] = '\0';\r\nout = simple_read_from_buffer(user_buf, count, off,\r\nbuf, n);\r\nfree_page((unsigned long) buf);\r\nreturn out;\r\n}\r\nstatic int lkdtm_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t direct_entry(struct file *f, const char __user *user_buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct crashtype *crashtype;\r\nchar *buf;\r\nif (count >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nbuf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, user_buf, count)) {\r\nfree_page((unsigned long) buf);\r\nreturn -EFAULT;\r\n}\r\nbuf[count] = '\0';\r\nstrim(buf);\r\ncrashtype = find_crashtype(buf);\r\nfree_page((unsigned long) buf);\r\nif (!crashtype)\r\nreturn -EINVAL;\r\npr_info("Performing direct entry %s\n", crashtype->name);\r\nlkdtm_do_action(crashtype);\r\n*off += count;\r\nreturn count;\r\n}\r\nstatic int __init lkdtm_module_init(void)\r\n{\r\nstruct crashpoint *crashpoint = NULL;\r\nstruct crashtype *crashtype = NULL;\r\nint ret = -EINVAL;\r\nint i;\r\nif ((cpoint_type || cpoint_name) && !(cpoint_type && cpoint_name)) {\r\npr_err("Need both cpoint_type and cpoint_name or neither\n");\r\nreturn -EINVAL;\r\n}\r\nif (cpoint_type) {\r\ncrashtype = find_crashtype(cpoint_type);\r\nif (!crashtype) {\r\npr_err("Unknown crashtype '%s'\n", cpoint_type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (cpoint_name) {\r\nfor (i = 0; i < ARRAY_SIZE(crashpoints); i++) {\r\nif (!strcmp(cpoint_name, crashpoints[i].name))\r\ncrashpoint = &crashpoints[i];\r\n}\r\nif (!crashpoint) {\r\npr_err("Invalid crashpoint %s\n", cpoint_name);\r\nreturn -EINVAL;\r\n}\r\n}\r\n#ifdef CONFIG_KPROBES\r\ncrash_count = cpoint_count;\r\n#endif\r\nlkdtm_bugs_init(&recur_count);\r\nlkdtm_perms_init();\r\nlkdtm_usercopy_init();\r\nlkdtm_debugfs_root = debugfs_create_dir("provoke-crash", NULL);\r\nif (!lkdtm_debugfs_root) {\r\npr_err("creating root dir failed\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(crashpoints); i++) {\r\nstruct crashpoint *cur = &crashpoints[i];\r\nstruct dentry *de;\r\nde = debugfs_create_file(cur->name, 0644, lkdtm_debugfs_root,\r\ncur, &cur->fops);\r\nif (de == NULL) {\r\npr_err("could not create crashpoint %s\n", cur->name);\r\ngoto out_err;\r\n}\r\n}\r\nif (crashpoint) {\r\nret = lkdtm_register_cpoint(crashpoint, crashtype);\r\nif (ret < 0) {\r\npr_info("Invalid crashpoint %s\n", crashpoint->name);\r\ngoto out_err;\r\n}\r\npr_info("Crash point %s of type %s registered\n",\r\ncrashpoint->name, cpoint_type);\r\n} else {\r\npr_info("No crash points registered, enable through debugfs\n");\r\n}\r\nreturn 0;\r\nout_err:\r\ndebugfs_remove_recursive(lkdtm_debugfs_root);\r\nreturn ret;\r\n}\r\nstatic void __exit lkdtm_module_exit(void)\r\n{\r\ndebugfs_remove_recursive(lkdtm_debugfs_root);\r\nlkdtm_usercopy_exit();\r\nunregister_jprobe(lkdtm_jprobe);\r\npr_info("Crash point unregistered\n");\r\n}
