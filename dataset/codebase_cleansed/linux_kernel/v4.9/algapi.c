static inline int crypto_set_driver_name(struct crypto_alg *alg)\r\n{\r\nstatic const char suffix[] = "-generic";\r\nchar *driver_name = alg->cra_driver_name;\r\nint len;\r\nif (*driver_name)\r\nreturn 0;\r\nlen = strlcpy(driver_name, alg->cra_name, CRYPTO_MAX_ALG_NAME);\r\nif (len + sizeof(suffix) > CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nmemcpy(driver_name + len, suffix, sizeof(suffix));\r\nreturn 0;\r\n}\r\nstatic inline void crypto_check_module_sig(struct module *mod)\r\n{\r\nif (fips_enabled && mod && !module_sig_ok(mod))\r\npanic("Module %s signature verification failed in FIPS mode\n",\r\nmodule_name(mod));\r\n}\r\nstatic int crypto_check_alg(struct crypto_alg *alg)\r\n{\r\ncrypto_check_module_sig(alg->cra_module);\r\nif (alg->cra_alignmask & (alg->cra_alignmask + 1))\r\nreturn -EINVAL;\r\nif (alg->cra_blocksize > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\nif (alg->cra_priority < 0)\r\nreturn -EINVAL;\r\natomic_set(&alg->cra_refcnt, 1);\r\nreturn crypto_set_driver_name(alg);\r\n}\r\nstatic void crypto_free_instance(struct crypto_instance *inst)\r\n{\r\nif (!inst->alg.cra_type->free) {\r\ninst->tmpl->free(inst);\r\nreturn;\r\n}\r\ninst->alg.cra_type->free(inst);\r\n}\r\nstatic void crypto_destroy_instance(struct crypto_alg *alg)\r\n{\r\nstruct crypto_instance *inst = (void *)alg;\r\nstruct crypto_template *tmpl = inst->tmpl;\r\ncrypto_free_instance(inst);\r\ncrypto_tmpl_put(tmpl);\r\n}\r\nstatic struct list_head *crypto_more_spawns(struct crypto_alg *alg,\r\nstruct list_head *stack,\r\nstruct list_head *top,\r\nstruct list_head *secondary_spawns)\r\n{\r\nstruct crypto_spawn *spawn, *n;\r\nspawn = list_first_entry_or_null(stack, struct crypto_spawn, list);\r\nif (!spawn)\r\nreturn NULL;\r\nn = list_next_entry(spawn, list);\r\nif (spawn->alg && &n->list != stack && !n->alg)\r\nn->alg = (n->list.next == stack) ? alg :\r\n&list_next_entry(n, list)->inst->alg;\r\nlist_move(&spawn->list, secondary_spawns);\r\nreturn &n->list == stack ? top : &n->inst->alg.cra_users;\r\n}\r\nstatic void crypto_remove_instance(struct crypto_instance *inst,\r\nstruct list_head *list)\r\n{\r\nstruct crypto_template *tmpl = inst->tmpl;\r\nif (crypto_is_dead(&inst->alg))\r\nreturn;\r\ninst->alg.cra_flags |= CRYPTO_ALG_DEAD;\r\nif (hlist_unhashed(&inst->list))\r\nreturn;\r\nif (!tmpl || !crypto_tmpl_get(tmpl))\r\nreturn;\r\ncrypto_notify(CRYPTO_MSG_ALG_UNREGISTER, &inst->alg);\r\nlist_move(&inst->alg.cra_list, list);\r\nhlist_del(&inst->list);\r\ninst->alg.cra_destroy = crypto_destroy_instance;\r\nBUG_ON(!list_empty(&inst->alg.cra_users));\r\n}\r\nvoid crypto_remove_spawns(struct crypto_alg *alg, struct list_head *list,\r\nstruct crypto_alg *nalg)\r\n{\r\nu32 new_type = (nalg ?: alg)->cra_flags;\r\nstruct crypto_spawn *spawn, *n;\r\nLIST_HEAD(secondary_spawns);\r\nstruct list_head *spawns;\r\nLIST_HEAD(stack);\r\nLIST_HEAD(top);\r\nspawns = &alg->cra_users;\r\nlist_for_each_entry_safe(spawn, n, spawns, list) {\r\nif ((spawn->alg->cra_flags ^ new_type) & spawn->mask)\r\ncontinue;\r\nlist_move(&spawn->list, &top);\r\n}\r\nspawns = &top;\r\ndo {\r\nwhile (!list_empty(spawns)) {\r\nstruct crypto_instance *inst;\r\nspawn = list_first_entry(spawns, struct crypto_spawn,\r\nlist);\r\ninst = spawn->inst;\r\nBUG_ON(&inst->alg == alg);\r\nlist_move(&spawn->list, &stack);\r\nif (&inst->alg == nalg)\r\nbreak;\r\nspawn->alg = NULL;\r\nspawns = &inst->alg.cra_users;\r\n}\r\n} while ((spawns = crypto_more_spawns(alg, &stack, &top,\r\n&secondary_spawns)));\r\nlist_for_each_entry_safe(spawn, n, &secondary_spawns, list) {\r\nif (spawn->alg)\r\nlist_move(&spawn->list, &spawn->alg->cra_users);\r\nelse\r\ncrypto_remove_instance(spawn->inst, list);\r\n}\r\n}\r\nstatic struct crypto_larval *__crypto_register_alg(struct crypto_alg *alg)\r\n{\r\nstruct crypto_alg *q;\r\nstruct crypto_larval *larval;\r\nint ret = -EAGAIN;\r\nif (crypto_is_dead(alg))\r\ngoto err;\r\nINIT_LIST_HEAD(&alg->cra_users);\r\nalg->cra_flags &= ~CRYPTO_ALG_TESTED;\r\nret = -EEXIST;\r\nlist_for_each_entry(q, &crypto_alg_list, cra_list) {\r\nif (q == alg)\r\ngoto err;\r\nif (crypto_is_moribund(q))\r\ncontinue;\r\nif (crypto_is_larval(q)) {\r\nif (!strcmp(alg->cra_driver_name, q->cra_driver_name))\r\ngoto err;\r\ncontinue;\r\n}\r\nif (!strcmp(q->cra_driver_name, alg->cra_name) ||\r\n!strcmp(q->cra_name, alg->cra_driver_name))\r\ngoto err;\r\n}\r\nlarval = crypto_larval_alloc(alg->cra_name,\r\nalg->cra_flags | CRYPTO_ALG_TESTED, 0);\r\nif (IS_ERR(larval))\r\ngoto out;\r\nret = -ENOENT;\r\nlarval->adult = crypto_mod_get(alg);\r\nif (!larval->adult)\r\ngoto free_larval;\r\natomic_set(&larval->alg.cra_refcnt, 1);\r\nmemcpy(larval->alg.cra_driver_name, alg->cra_driver_name,\r\nCRYPTO_MAX_ALG_NAME);\r\nlarval->alg.cra_priority = alg->cra_priority;\r\nlist_add(&alg->cra_list, &crypto_alg_list);\r\nlist_add(&larval->alg.cra_list, &crypto_alg_list);\r\nout:\r\nreturn larval;\r\nfree_larval:\r\nkfree(larval);\r\nerr:\r\nlarval = ERR_PTR(ret);\r\ngoto out;\r\n}\r\nvoid crypto_alg_tested(const char *name, int err)\r\n{\r\nstruct crypto_larval *test;\r\nstruct crypto_alg *alg;\r\nstruct crypto_alg *q;\r\nLIST_HEAD(list);\r\ndown_write(&crypto_alg_sem);\r\nlist_for_each_entry(q, &crypto_alg_list, cra_list) {\r\nif (crypto_is_moribund(q) || !crypto_is_larval(q))\r\ncontinue;\r\ntest = (struct crypto_larval *)q;\r\nif (!strcmp(q->cra_driver_name, name))\r\ngoto found;\r\n}\r\nprintk(KERN_ERR "alg: Unexpected test result for %s: %d\n", name, err);\r\ngoto unlock;\r\nfound:\r\nq->cra_flags |= CRYPTO_ALG_DEAD;\r\nalg = test->adult;\r\nif (err || list_empty(&alg->cra_list))\r\ngoto complete;\r\nalg->cra_flags |= CRYPTO_ALG_TESTED;\r\nlist_for_each_entry(q, &crypto_alg_list, cra_list) {\r\nif (q == alg)\r\ncontinue;\r\nif (crypto_is_moribund(q))\r\ncontinue;\r\nif (crypto_is_larval(q)) {\r\nstruct crypto_larval *larval = (void *)q;\r\nif (strcmp(alg->cra_name, q->cra_name) &&\r\nstrcmp(alg->cra_driver_name, q->cra_name))\r\ncontinue;\r\nif (larval->adult)\r\ncontinue;\r\nif ((q->cra_flags ^ alg->cra_flags) & larval->mask)\r\ncontinue;\r\nif (!crypto_mod_get(alg))\r\ncontinue;\r\nlarval->adult = alg;\r\ncontinue;\r\n}\r\nif (strcmp(alg->cra_name, q->cra_name))\r\ncontinue;\r\nif (strcmp(alg->cra_driver_name, q->cra_driver_name) &&\r\nq->cra_priority > alg->cra_priority)\r\ncontinue;\r\ncrypto_remove_spawns(q, &list, alg);\r\n}\r\ncomplete:\r\ncomplete_all(&test->completion);\r\nunlock:\r\nup_write(&crypto_alg_sem);\r\ncrypto_remove_final(&list);\r\n}\r\nvoid crypto_remove_final(struct list_head *list)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_alg *n;\r\nlist_for_each_entry_safe(alg, n, list, cra_list) {\r\nlist_del_init(&alg->cra_list);\r\ncrypto_alg_put(alg);\r\n}\r\n}\r\nstatic void crypto_wait_for_test(struct crypto_larval *larval)\r\n{\r\nint err;\r\nerr = crypto_probing_notify(CRYPTO_MSG_ALG_REGISTER, larval->adult);\r\nif (err != NOTIFY_STOP) {\r\nif (WARN_ON(err != NOTIFY_DONE))\r\ngoto out;\r\ncrypto_alg_tested(larval->alg.cra_driver_name, 0);\r\n}\r\nerr = wait_for_completion_killable(&larval->completion);\r\nWARN_ON(err);\r\nout:\r\ncrypto_larval_kill(&larval->alg);\r\n}\r\nint crypto_register_alg(struct crypto_alg *alg)\r\n{\r\nstruct crypto_larval *larval;\r\nint err;\r\nerr = crypto_check_alg(alg);\r\nif (err)\r\nreturn err;\r\ndown_write(&crypto_alg_sem);\r\nlarval = __crypto_register_alg(alg);\r\nup_write(&crypto_alg_sem);\r\nif (IS_ERR(larval))\r\nreturn PTR_ERR(larval);\r\ncrypto_wait_for_test(larval);\r\nreturn 0;\r\n}\r\nstatic int crypto_remove_alg(struct crypto_alg *alg, struct list_head *list)\r\n{\r\nif (unlikely(list_empty(&alg->cra_list)))\r\nreturn -ENOENT;\r\nalg->cra_flags |= CRYPTO_ALG_DEAD;\r\ncrypto_notify(CRYPTO_MSG_ALG_UNREGISTER, alg);\r\nlist_del_init(&alg->cra_list);\r\ncrypto_remove_spawns(alg, list, NULL);\r\nreturn 0;\r\n}\r\nint crypto_unregister_alg(struct crypto_alg *alg)\r\n{\r\nint ret;\r\nLIST_HEAD(list);\r\ndown_write(&crypto_alg_sem);\r\nret = crypto_remove_alg(alg, &list);\r\nup_write(&crypto_alg_sem);\r\nif (ret)\r\nreturn ret;\r\nBUG_ON(atomic_read(&alg->cra_refcnt) != 1);\r\nif (alg->cra_destroy)\r\nalg->cra_destroy(alg);\r\ncrypto_remove_final(&list);\r\nreturn 0;\r\n}\r\nint crypto_register_algs(struct crypto_alg *algs, int count)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nret = crypto_register_alg(&algs[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (--i; i >= 0; --i)\r\ncrypto_unregister_alg(&algs[i]);\r\nreturn ret;\r\n}\r\nint crypto_unregister_algs(struct crypto_alg *algs, int count)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nret = crypto_unregister_alg(&algs[i]);\r\nif (ret)\r\npr_err("Failed to unregister %s %s: %d\n",\r\nalgs[i].cra_driver_name, algs[i].cra_name, ret);\r\n}\r\nreturn 0;\r\n}\r\nint crypto_register_template(struct crypto_template *tmpl)\r\n{\r\nstruct crypto_template *q;\r\nint err = -EEXIST;\r\ndown_write(&crypto_alg_sem);\r\ncrypto_check_module_sig(tmpl->module);\r\nlist_for_each_entry(q, &crypto_template_list, list) {\r\nif (q == tmpl)\r\ngoto out;\r\n}\r\nlist_add(&tmpl->list, &crypto_template_list);\r\ncrypto_notify(CRYPTO_MSG_TMPL_REGISTER, tmpl);\r\nerr = 0;\r\nout:\r\nup_write(&crypto_alg_sem);\r\nreturn err;\r\n}\r\nvoid crypto_unregister_template(struct crypto_template *tmpl)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct hlist_node *n;\r\nstruct hlist_head *list;\r\nLIST_HEAD(users);\r\ndown_write(&crypto_alg_sem);\r\nBUG_ON(list_empty(&tmpl->list));\r\nlist_del_init(&tmpl->list);\r\nlist = &tmpl->instances;\r\nhlist_for_each_entry(inst, list, list) {\r\nint err = crypto_remove_alg(&inst->alg, &users);\r\nBUG_ON(err);\r\n}\r\ncrypto_notify(CRYPTO_MSG_TMPL_UNREGISTER, tmpl);\r\nup_write(&crypto_alg_sem);\r\nhlist_for_each_entry_safe(inst, n, list, list) {\r\nBUG_ON(atomic_read(&inst->alg.cra_refcnt) != 1);\r\ncrypto_free_instance(inst);\r\n}\r\ncrypto_remove_final(&users);\r\n}\r\nstatic struct crypto_template *__crypto_lookup_template(const char *name)\r\n{\r\nstruct crypto_template *q, *tmpl = NULL;\r\ndown_read(&crypto_alg_sem);\r\nlist_for_each_entry(q, &crypto_template_list, list) {\r\nif (strcmp(q->name, name))\r\ncontinue;\r\nif (unlikely(!crypto_tmpl_get(q)))\r\ncontinue;\r\ntmpl = q;\r\nbreak;\r\n}\r\nup_read(&crypto_alg_sem);\r\nreturn tmpl;\r\n}\r\nstruct crypto_template *crypto_lookup_template(const char *name)\r\n{\r\nreturn try_then_request_module(__crypto_lookup_template(name),\r\n"crypto-%s", name);\r\n}\r\nint crypto_register_instance(struct crypto_template *tmpl,\r\nstruct crypto_instance *inst)\r\n{\r\nstruct crypto_larval *larval;\r\nint err;\r\nerr = crypto_check_alg(&inst->alg);\r\nif (err)\r\nreturn err;\r\ninst->alg.cra_module = tmpl->module;\r\ninst->alg.cra_flags |= CRYPTO_ALG_INSTANCE;\r\nif (unlikely(!crypto_mod_get(&inst->alg)))\r\nreturn -EAGAIN;\r\ndown_write(&crypto_alg_sem);\r\nlarval = __crypto_register_alg(&inst->alg);\r\nif (IS_ERR(larval))\r\ngoto unlock;\r\nhlist_add_head(&inst->list, &tmpl->instances);\r\ninst->tmpl = tmpl;\r\nunlock:\r\nup_write(&crypto_alg_sem);\r\nerr = PTR_ERR(larval);\r\nif (IS_ERR(larval))\r\ngoto err;\r\ncrypto_wait_for_test(larval);\r\nif (!(inst->alg.cra_flags & CRYPTO_ALG_TESTED))\r\ncrypto_unregister_instance(inst);\r\nerr = 0;\r\nerr:\r\ncrypto_mod_put(&inst->alg);\r\nreturn err;\r\n}\r\nint crypto_unregister_instance(struct crypto_instance *inst)\r\n{\r\nLIST_HEAD(list);\r\ndown_write(&crypto_alg_sem);\r\ncrypto_remove_spawns(&inst->alg, &list, NULL);\r\ncrypto_remove_instance(inst, &list);\r\nup_write(&crypto_alg_sem);\r\ncrypto_remove_final(&list);\r\nreturn 0;\r\n}\r\nint crypto_init_spawn(struct crypto_spawn *spawn, struct crypto_alg *alg,\r\nstruct crypto_instance *inst, u32 mask)\r\n{\r\nint err = -EAGAIN;\r\nspawn->inst = inst;\r\nspawn->mask = mask;\r\ndown_write(&crypto_alg_sem);\r\nif (!crypto_is_moribund(alg)) {\r\nlist_add(&spawn->list, &alg->cra_users);\r\nspawn->alg = alg;\r\nerr = 0;\r\n}\r\nup_write(&crypto_alg_sem);\r\nreturn err;\r\n}\r\nint crypto_init_spawn2(struct crypto_spawn *spawn, struct crypto_alg *alg,\r\nstruct crypto_instance *inst,\r\nconst struct crypto_type *frontend)\r\n{\r\nint err = -EINVAL;\r\nif ((alg->cra_flags ^ frontend->type) & frontend->maskset)\r\ngoto out;\r\nspawn->frontend = frontend;\r\nerr = crypto_init_spawn(spawn, alg, inst, frontend->maskset);\r\nout:\r\nreturn err;\r\n}\r\nint crypto_grab_spawn(struct crypto_spawn *spawn, const char *name,\r\nu32 type, u32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nint err;\r\nalg = crypto_find_alg(name, spawn->frontend, type, mask);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\nerr = crypto_init_spawn(spawn, alg, spawn->inst, mask);\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nvoid crypto_drop_spawn(struct crypto_spawn *spawn)\r\n{\r\nif (!spawn->alg)\r\nreturn;\r\ndown_write(&crypto_alg_sem);\r\nlist_del(&spawn->list);\r\nup_write(&crypto_alg_sem);\r\n}\r\nstatic struct crypto_alg *crypto_spawn_alg(struct crypto_spawn *spawn)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_alg *alg2;\r\ndown_read(&crypto_alg_sem);\r\nalg = spawn->alg;\r\nalg2 = alg;\r\nif (alg2)\r\nalg2 = crypto_mod_get(alg2);\r\nup_read(&crypto_alg_sem);\r\nif (!alg2) {\r\nif (alg)\r\ncrypto_shoot_alg(alg);\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nreturn alg;\r\n}\r\nstruct crypto_tfm *crypto_spawn_tfm(struct crypto_spawn *spawn, u32 type,\r\nu32 mask)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_tfm *tfm;\r\nalg = crypto_spawn_alg(spawn);\r\nif (IS_ERR(alg))\r\nreturn ERR_CAST(alg);\r\ntfm = ERR_PTR(-EINVAL);\r\nif (unlikely((alg->cra_flags ^ type) & mask))\r\ngoto out_put_alg;\r\ntfm = __crypto_alloc_tfm(alg, type, mask);\r\nif (IS_ERR(tfm))\r\ngoto out_put_alg;\r\nreturn tfm;\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn tfm;\r\n}\r\nvoid *crypto_spawn_tfm2(struct crypto_spawn *spawn)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_tfm *tfm;\r\nalg = crypto_spawn_alg(spawn);\r\nif (IS_ERR(alg))\r\nreturn ERR_CAST(alg);\r\ntfm = crypto_create_tfm(alg, spawn->frontend);\r\nif (IS_ERR(tfm))\r\ngoto out_put_alg;\r\nreturn tfm;\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn tfm;\r\n}\r\nint crypto_register_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&crypto_chain, nb);\r\n}\r\nint crypto_unregister_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&crypto_chain, nb);\r\n}\r\nstruct crypto_attr_type *crypto_get_attr_type(struct rtattr **tb)\r\n{\r\nstruct rtattr *rta = tb[0];\r\nstruct crypto_attr_type *algt;\r\nif (!rta)\r\nreturn ERR_PTR(-ENOENT);\r\nif (RTA_PAYLOAD(rta) < sizeof(*algt))\r\nreturn ERR_PTR(-EINVAL);\r\nif (rta->rta_type != CRYPTOA_TYPE)\r\nreturn ERR_PTR(-EINVAL);\r\nalgt = RTA_DATA(rta);\r\nreturn algt;\r\n}\r\nint crypto_check_attr_type(struct rtattr **tb, u32 type)\r\n{\r\nstruct crypto_attr_type *algt;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ type) & algt->mask)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nconst char *crypto_attr_alg_name(struct rtattr *rta)\r\n{\r\nstruct crypto_attr_alg *alga;\r\nif (!rta)\r\nreturn ERR_PTR(-ENOENT);\r\nif (RTA_PAYLOAD(rta) < sizeof(*alga))\r\nreturn ERR_PTR(-EINVAL);\r\nif (rta->rta_type != CRYPTOA_ALG)\r\nreturn ERR_PTR(-EINVAL);\r\nalga = RTA_DATA(rta);\r\nalga->name[CRYPTO_MAX_ALG_NAME - 1] = 0;\r\nreturn alga->name;\r\n}\r\nstruct crypto_alg *crypto_attr_alg2(struct rtattr *rta,\r\nconst struct crypto_type *frontend,\r\nu32 type, u32 mask)\r\n{\r\nconst char *name;\r\nname = crypto_attr_alg_name(rta);\r\nif (IS_ERR(name))\r\nreturn ERR_CAST(name);\r\nreturn crypto_find_alg(name, frontend, type, mask);\r\n}\r\nint crypto_attr_u32(struct rtattr *rta, u32 *num)\r\n{\r\nstruct crypto_attr_u32 *nu32;\r\nif (!rta)\r\nreturn -ENOENT;\r\nif (RTA_PAYLOAD(rta) < sizeof(*nu32))\r\nreturn -EINVAL;\r\nif (rta->rta_type != CRYPTOA_U32)\r\nreturn -EINVAL;\r\nnu32 = RTA_DATA(rta);\r\n*num = nu32->num;\r\nreturn 0;\r\n}\r\nint crypto_inst_setname(struct crypto_instance *inst, const char *name,\r\nstruct crypto_alg *alg)\r\n{\r\nif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME, "%s(%s)", name,\r\nalg->cra_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME, "%s(%s)",\r\nname, alg->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nreturn 0;\r\n}\r\nvoid *crypto_alloc_instance2(const char *name, struct crypto_alg *alg,\r\nunsigned int head)\r\n{\r\nstruct crypto_instance *inst;\r\nchar *p;\r\nint err;\r\np = kzalloc(head + sizeof(*inst) + sizeof(struct crypto_spawn),\r\nGFP_KERNEL);\r\nif (!p)\r\nreturn ERR_PTR(-ENOMEM);\r\ninst = (void *)(p + head);\r\nerr = crypto_inst_setname(inst, name, alg);\r\nif (err)\r\ngoto err_free_inst;\r\nreturn p;\r\nerr_free_inst:\r\nkfree(p);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct crypto_instance *crypto_alloc_instance(const char *name,\r\nstruct crypto_alg *alg)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct crypto_spawn *spawn;\r\nint err;\r\ninst = crypto_alloc_instance2(name, alg, 0);\r\nif (IS_ERR(inst))\r\ngoto out;\r\nspawn = crypto_instance_ctx(inst);\r\nerr = crypto_init_spawn(spawn, alg, inst,\r\nCRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_ASYNC);\r\nif (err)\r\ngoto err_free_inst;\r\nreturn inst;\r\nerr_free_inst:\r\nkfree(inst);\r\ninst = ERR_PTR(err);\r\nout:\r\nreturn inst;\r\n}\r\nvoid crypto_init_queue(struct crypto_queue *queue, unsigned int max_qlen)\r\n{\r\nINIT_LIST_HEAD(&queue->list);\r\nqueue->backlog = &queue->list;\r\nqueue->qlen = 0;\r\nqueue->max_qlen = max_qlen;\r\n}\r\nint crypto_enqueue_request(struct crypto_queue *queue,\r\nstruct crypto_async_request *request)\r\n{\r\nint err = -EINPROGRESS;\r\nif (unlikely(queue->qlen >= queue->max_qlen)) {\r\nerr = -EBUSY;\r\nif (!(request->flags & CRYPTO_TFM_REQ_MAY_BACKLOG))\r\ngoto out;\r\nif (queue->backlog == &queue->list)\r\nqueue->backlog = &request->list;\r\n}\r\nqueue->qlen++;\r\nlist_add_tail(&request->list, &queue->list);\r\nout:\r\nreturn err;\r\n}\r\nstruct crypto_async_request *crypto_dequeue_request(struct crypto_queue *queue)\r\n{\r\nstruct list_head *request;\r\nif (unlikely(!queue->qlen))\r\nreturn NULL;\r\nqueue->qlen--;\r\nif (queue->backlog != &queue->list)\r\nqueue->backlog = queue->backlog->next;\r\nrequest = queue->list.next;\r\nlist_del(request);\r\nreturn list_entry(request, struct crypto_async_request, list);\r\n}\r\nint crypto_tfm_in_queue(struct crypto_queue *queue, struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_async_request *req;\r\nlist_for_each_entry(req, &queue->list, list) {\r\nif (req->tfm == tfm)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void crypto_inc_byte(u8 *a, unsigned int size)\r\n{\r\nu8 *b = (a + size);\r\nu8 c;\r\nfor (; size; size--) {\r\nc = *--b + 1;\r\n*b = c;\r\nif (c)\r\nbreak;\r\n}\r\n}\r\nvoid crypto_inc(u8 *a, unsigned int size)\r\n{\r\n__be32 *b = (__be32 *)(a + size);\r\nu32 c;\r\nfor (; size >= 4; size -= 4) {\r\nc = be32_to_cpu(*--b) + 1;\r\n*b = cpu_to_be32(c);\r\nif (c)\r\nreturn;\r\n}\r\ncrypto_inc_byte(a, size);\r\n}\r\nstatic inline void crypto_xor_byte(u8 *a, const u8 *b, unsigned int size)\r\n{\r\nfor (; size; size--)\r\n*a++ ^= *b++;\r\n}\r\nvoid crypto_xor(u8 *dst, const u8 *src, unsigned int size)\r\n{\r\nu32 *a = (u32 *)dst;\r\nu32 *b = (u32 *)src;\r\nfor (; size >= 4; size -= 4)\r\n*a++ ^= *b++;\r\ncrypto_xor_byte((u8 *)a, (u8 *)b, size);\r\n}\r\nunsigned int crypto_alg_extsize(struct crypto_alg *alg)\r\n{\r\nreturn alg->cra_ctxsize +\r\n(alg->cra_alignmask & ~(crypto_tfm_ctx_alignment() - 1));\r\n}\r\nint crypto_type_has_alg(const char *name, const struct crypto_type *frontend,\r\nu32 type, u32 mask)\r\n{\r\nint ret = 0;\r\nstruct crypto_alg *alg = crypto_find_alg(name, frontend, type, mask);\r\nif (!IS_ERR(alg)) {\r\ncrypto_mod_put(alg);\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init crypto_algapi_init(void)\r\n{\r\ncrypto_init_proc();\r\nreturn 0;\r\n}\r\nstatic void __exit crypto_algapi_exit(void)\r\n{\r\ncrypto_exit_proc();\r\n}
