static int max732x_writeb(struct max732x_chip *chip, int group_a, uint8_t val)\r\n{\r\nstruct i2c_client *client;\r\nint ret;\r\nclient = group_a ? chip->client_group_a : chip->client_group_b;\r\nret = i2c_smbus_write_byte(client, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed writing\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max732x_readb(struct max732x_chip *chip, int group_a, uint8_t *val)\r\n{\r\nstruct i2c_client *client;\r\nint ret;\r\nclient = group_a ? chip->client_group_a : chip->client_group_b;\r\nret = i2c_smbus_read_byte(client);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed reading\n");\r\nreturn ret;\r\n}\r\n*val = (uint8_t)ret;\r\nreturn 0;\r\n}\r\nstatic inline int is_group_a(struct max732x_chip *chip, unsigned off)\r\n{\r\nreturn (1u << off) & chip->mask_group_a;\r\n}\r\nstatic int max732x_gpio_get_value(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nuint8_t reg_val;\r\nint ret;\r\nret = max732x_readb(chip, is_group_a(chip, off), &reg_val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(reg_val & (1u << (off & 0x7)));\r\n}\r\nstatic void max732x_gpio_set_mask(struct gpio_chip *gc, unsigned off, int mask,\r\nint val)\r\n{\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nuint8_t reg_out;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nreg_out = (off > 7) ? chip->reg_out[1] : chip->reg_out[0];\r\nreg_out = (reg_out & ~mask) | (val & mask);\r\nret = max732x_writeb(chip, is_group_a(chip, off), reg_out);\r\nif (ret < 0)\r\ngoto out;\r\nif (off > 7)\r\nchip->reg_out[1] = reg_out;\r\nelse\r\nchip->reg_out[0] = reg_out;\r\nout:\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic void max732x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)\r\n{\r\nunsigned base = off & ~0x7;\r\nuint8_t mask = 1u << (off & 0x7);\r\nmax732x_gpio_set_mask(gc, base, mask, val << (off & 0x7));\r\n}\r\nstatic void max732x_gpio_set_multiple(struct gpio_chip *gc,\r\nunsigned long *mask, unsigned long *bits)\r\n{\r\nunsigned mask_lo = mask[0] & 0xff;\r\nunsigned mask_hi = (mask[0] >> 8) & 0xff;\r\nif (mask_lo)\r\nmax732x_gpio_set_mask(gc, 0, mask_lo, bits[0] & 0xff);\r\nif (mask_hi)\r\nmax732x_gpio_set_mask(gc, 8, mask_hi, (bits[0] >> 8) & 0xff);\r\n}\r\nstatic int max732x_gpio_direction_input(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nunsigned int mask = 1u << off;\r\nif ((mask & chip->dir_input) == 0) {\r\ndev_dbg(&chip->client->dev, "%s port %d is output only\n",\r\nchip->client->name, off);\r\nreturn -EACCES;\r\n}\r\nif ((mask & chip->dir_output))\r\nmax732x_gpio_set_value(gc, off, 1);\r\nreturn 0;\r\n}\r\nstatic int max732x_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned off, int val)\r\n{\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nunsigned int mask = 1u << off;\r\nif ((mask & chip->dir_output) == 0) {\r\ndev_dbg(&chip->client->dev, "%s port %d is input only\n",\r\nchip->client->name, off);\r\nreturn -EACCES;\r\n}\r\nmax732x_gpio_set_value(gc, off, val);\r\nreturn 0;\r\n}\r\nstatic int max732x_writew(struct max732x_chip *chip, uint16_t val)\r\n{\r\nint ret;\r\nval = cpu_to_le16(val);\r\nret = i2c_master_send(chip->client_group_a, (char *)&val, 2);\r\nif (ret < 0) {\r\ndev_err(&chip->client_group_a->dev, "failed writing\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max732x_readw(struct max732x_chip *chip, uint16_t *val)\r\n{\r\nint ret;\r\nret = i2c_master_recv(chip->client_group_a, (char *)val, 2);\r\nif (ret < 0) {\r\ndev_err(&chip->client_group_a->dev, "failed reading\n");\r\nreturn ret;\r\n}\r\n*val = le16_to_cpu(*val);\r\nreturn 0;\r\n}\r\nstatic void max732x_irq_update_mask(struct max732x_chip *chip)\r\n{\r\nuint16_t msg;\r\nif (chip->irq_mask == chip->irq_mask_cur)\r\nreturn;\r\nchip->irq_mask = chip->irq_mask_cur;\r\nif (chip->irq_features == INT_NO_MASK)\r\nreturn;\r\nmutex_lock(&chip->lock);\r\nswitch (chip->irq_features) {\r\ncase INT_INDEP_MASK:\r\nmsg = (chip->irq_mask << 8) | chip->reg_out[0];\r\nmax732x_writew(chip, msg);\r\nbreak;\r\ncase INT_MERGED_MASK:\r\nmsg = chip->irq_mask | chip->reg_out[0];\r\nmax732x_writeb(chip, 1, (uint8_t)msg);\r\nbreak;\r\n}\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic void max732x_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nchip->irq_mask_cur &= ~(1 << d->hwirq);\r\n}\r\nstatic void max732x_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nchip->irq_mask_cur |= 1 << d->hwirq;\r\n}\r\nstatic void max732x_irq_bus_lock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nmutex_lock(&chip->irq_lock);\r\nchip->irq_mask_cur = chip->irq_mask;\r\n}\r\nstatic void max732x_irq_bus_sync_unlock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nuint16_t new_irqs;\r\nuint16_t level;\r\nmax732x_irq_update_mask(chip);\r\nnew_irqs = chip->irq_trig_fall | chip->irq_trig_raise;\r\nwhile (new_irqs) {\r\nlevel = __ffs(new_irqs);\r\nmax732x_gpio_direction_input(&chip->gpio_chip, level);\r\nnew_irqs &= ~(1 << level);\r\n}\r\nmutex_unlock(&chip->irq_lock);\r\n}\r\nstatic int max732x_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct max732x_chip *chip = gpiochip_get_data(gc);\r\nuint16_t off = d->hwirq;\r\nuint16_t mask = 1 << off;\r\nif (!(mask & chip->dir_input)) {\r\ndev_dbg(&chip->client->dev, "%s port %d is output only\n",\r\nchip->client->name, off);\r\nreturn -EACCES;\r\n}\r\nif (!(type & IRQ_TYPE_EDGE_BOTH)) {\r\ndev_err(&chip->client->dev, "irq %d: unsupported type %d\n",\r\nd->irq, type);\r\nreturn -EINVAL;\r\n}\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nchip->irq_trig_fall |= mask;\r\nelse\r\nchip->irq_trig_fall &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nchip->irq_trig_raise |= mask;\r\nelse\r\nchip->irq_trig_raise &= ~mask;\r\nreturn 0;\r\n}\r\nstatic int max732x_irq_set_wake(struct irq_data *data, unsigned int on)\r\n{\r\nstruct max732x_chip *chip = irq_data_get_irq_chip_data(data);\r\nirq_set_irq_wake(chip->client->irq, on);\r\nreturn 0;\r\n}\r\nstatic uint8_t max732x_irq_pending(struct max732x_chip *chip)\r\n{\r\nuint8_t cur_stat;\r\nuint8_t old_stat;\r\nuint8_t trigger;\r\nuint8_t pending;\r\nuint16_t status;\r\nint ret;\r\nret = max732x_readw(chip, &status);\r\nif (ret)\r\nreturn 0;\r\ntrigger = status >> 8;\r\ntrigger &= chip->irq_mask;\r\nif (!trigger)\r\nreturn 0;\r\ncur_stat = status & 0xFF;\r\ncur_stat &= chip->irq_mask;\r\nold_stat = cur_stat ^ trigger;\r\npending = (old_stat & chip->irq_trig_fall) |\r\n(cur_stat & chip->irq_trig_raise);\r\npending &= trigger;\r\nreturn pending;\r\n}\r\nstatic irqreturn_t max732x_irq_handler(int irq, void *devid)\r\n{\r\nstruct max732x_chip *chip = devid;\r\nuint8_t pending;\r\nuint8_t level;\r\npending = max732x_irq_pending(chip);\r\nif (!pending)\r\nreturn IRQ_HANDLED;\r\ndo {\r\nlevel = __ffs(pending);\r\nhandle_nested_irq(irq_find_mapping(chip->gpio_chip.irqdomain,\r\nlevel));\r\npending &= ~(1 << level);\r\n} while (pending);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max732x_irq_setup(struct max732x_chip *chip,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nstruct max732x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nint has_irq = max732x_features[id->driver_data] >> 32;\r\nint irq_base = 0;\r\nint ret;\r\nif (((pdata && pdata->irq_base) || client->irq)\r\n&& has_irq != INT_NONE) {\r\nif (pdata)\r\nirq_base = pdata->irq_base;\r\nchip->irq_features = has_irq;\r\nmutex_init(&chip->irq_lock);\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, max732x_irq_handler, IRQF_ONESHOT |\r\nIRQF_TRIGGER_FALLING | IRQF_SHARED,\r\ndev_name(&client->dev), chip);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to request irq %d\n",\r\nclient->irq);\r\nreturn ret;\r\n}\r\nret = gpiochip_irqchip_add(&chip->gpio_chip,\r\n&max732x_irq_chip,\r\nirq_base,\r\nhandle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"could not connect irqchip to gpiochip\n");\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(&chip->gpio_chip,\r\n&max732x_irq_chip,\r\nclient->irq,\r\nNULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max732x_irq_setup(struct max732x_chip *chip,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nstruct max732x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nint has_irq = max732x_features[id->driver_data] >> 32;\r\nif (((pdata && pdata->irq_base) || client->irq) && has_irq != INT_NONE)\r\ndev_warn(&client->dev, "interrupt support not compiled in\n");\r\nreturn 0;\r\n}\r\nstatic int max732x_setup_gpio(struct max732x_chip *chip,\r\nconst struct i2c_device_id *id,\r\nunsigned gpio_start)\r\n{\r\nstruct gpio_chip *gc = &chip->gpio_chip;\r\nuint32_t id_data = (uint32_t)max732x_features[id->driver_data];\r\nint i, port = 0;\r\nfor (i = 0; i < 16; i++, id_data >>= 2) {\r\nunsigned int mask = 1 << port;\r\nswitch (id_data & 0x3) {\r\ncase PORT_OUTPUT:\r\nchip->dir_output |= mask;\r\nbreak;\r\ncase PORT_INPUT:\r\nchip->dir_input |= mask;\r\nbreak;\r\ncase PORT_OPENDRAIN:\r\nchip->dir_output |= mask;\r\nchip->dir_input |= mask;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (i < 8)\r\nchip->mask_group_a |= mask;\r\nport++;\r\n}\r\nif (chip->dir_input)\r\ngc->direction_input = max732x_gpio_direction_input;\r\nif (chip->dir_output) {\r\ngc->direction_output = max732x_gpio_direction_output;\r\ngc->set = max732x_gpio_set_value;\r\ngc->set_multiple = max732x_gpio_set_multiple;\r\n}\r\ngc->get = max732x_gpio_get_value;\r\ngc->can_sleep = true;\r\ngc->base = gpio_start;\r\ngc->ngpio = port;\r\ngc->label = chip->client->name;\r\ngc->parent = &chip->client->dev;\r\ngc->owner = THIS_MODULE;\r\nreturn port;\r\n}\r\nstatic struct max732x_platform_data *of_gpio_max732x(struct device *dev)\r\n{\r\nstruct max732x_platform_data *pdata;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\npdata->gpio_base = -1;\r\nreturn pdata;\r\n}\r\nstatic int max732x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max732x_platform_data *pdata;\r\nstruct device_node *node;\r\nstruct max732x_chip *chip;\r\nstruct i2c_client *c;\r\nuint16_t addr_a, addr_b;\r\nint ret, nr_port;\r\npdata = dev_get_platdata(&client->dev);\r\nnode = client->dev.of_node;\r\nif (!pdata && node)\r\npdata = of_gpio_max732x(&client->dev);\r\nif (!pdata) {\r\ndev_dbg(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->client = client;\r\nnr_port = max732x_setup_gpio(chip, id, pdata->gpio_base);\r\nchip->gpio_chip.parent = &client->dev;\r\naddr_a = (client->addr & 0x0f) | 0x60;\r\naddr_b = (client->addr & 0x0f) | 0x50;\r\nswitch (client->addr & 0x70) {\r\ncase 0x60:\r\nchip->client_group_a = client;\r\nif (nr_port > 8) {\r\nc = i2c_new_dummy(client->adapter, addr_b);\r\nchip->client_group_b = chip->client_dummy = c;\r\n}\r\nbreak;\r\ncase 0x50:\r\nchip->client_group_b = client;\r\nif (nr_port > 8) {\r\nc = i2c_new_dummy(client->adapter, addr_a);\r\nchip->client_group_a = chip->client_dummy = c;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "invalid I2C address specified %02x\n",\r\nclient->addr);\r\nret = -EINVAL;\r\ngoto out_failed;\r\n}\r\nif (nr_port > 8 && !chip->client_dummy) {\r\ndev_err(&client->dev,\r\n"Failed to allocate second group I2C device\n");\r\nret = -ENODEV;\r\ngoto out_failed;\r\n}\r\nmutex_init(&chip->lock);\r\nret = max732x_readb(chip, is_group_a(chip, 0), &chip->reg_out[0]);\r\nif (ret)\r\ngoto out_failed;\r\nif (nr_port > 8) {\r\nret = max732x_readb(chip, is_group_a(chip, 8), &chip->reg_out[1]);\r\nif (ret)\r\ngoto out_failed;\r\n}\r\nret = gpiochip_add_data(&chip->gpio_chip, chip);\r\nif (ret)\r\ngoto out_failed;\r\nret = max732x_irq_setup(chip, id);\r\nif (ret) {\r\ngpiochip_remove(&chip->gpio_chip);\r\ngoto out_failed;\r\n}\r\nif (pdata && pdata->setup) {\r\nret = pdata->setup(client, chip->gpio_chip.base,\r\nchip->gpio_chip.ngpio, pdata->context);\r\nif (ret < 0)\r\ndev_warn(&client->dev, "setup failed, %d\n", ret);\r\n}\r\ni2c_set_clientdata(client, chip);\r\nreturn 0;\r\nout_failed:\r\nif (chip->client_dummy)\r\ni2c_unregister_device(chip->client_dummy);\r\nreturn ret;\r\n}\r\nstatic int max732x_remove(struct i2c_client *client)\r\n{\r\nstruct max732x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct max732x_chip *chip = i2c_get_clientdata(client);\r\nif (pdata && pdata->teardown) {\r\nint ret;\r\nret = pdata->teardown(client, chip->gpio_chip.base,\r\nchip->gpio_chip.ngpio, pdata->context);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "%s failed, %d\n",\r\n"teardown", ret);\r\nreturn ret;\r\n}\r\n}\r\ngpiochip_remove(&chip->gpio_chip);\r\nif (chip->client_dummy)\r\ni2c_unregister_device(chip->client_dummy);\r\nreturn 0;\r\n}\r\nstatic int __init max732x_init(void)\r\n{\r\nreturn i2c_add_driver(&max732x_driver);\r\n}\r\nstatic void __exit max732x_exit(void)\r\n{\r\ni2c_del_driver(&max732x_driver);\r\n}
