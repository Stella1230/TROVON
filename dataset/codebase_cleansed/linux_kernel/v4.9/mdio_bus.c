int mdiobus_register_device(struct mdio_device *mdiodev)\r\n{\r\nif (mdiodev->bus->mdio_map[mdiodev->addr])\r\nreturn -EBUSY;\r\nmdiodev->bus->mdio_map[mdiodev->addr] = mdiodev;\r\nreturn 0;\r\n}\r\nint mdiobus_unregister_device(struct mdio_device *mdiodev)\r\n{\r\nif (mdiodev->bus->mdio_map[mdiodev->addr] != mdiodev)\r\nreturn -EINVAL;\r\nmdiodev->bus->mdio_map[mdiodev->addr] = NULL;\r\nreturn 0;\r\n}\r\nstruct phy_device *mdiobus_get_phy(struct mii_bus *bus, int addr)\r\n{\r\nstruct mdio_device *mdiodev = bus->mdio_map[addr];\r\nif (!mdiodev)\r\nreturn NULL;\r\nif (!(mdiodev->flags & MDIO_DEVICE_FLAG_PHY))\r\nreturn NULL;\r\nreturn container_of(mdiodev, struct phy_device, mdio);\r\n}\r\nbool mdiobus_is_registered_device(struct mii_bus *bus, int addr)\r\n{\r\nreturn bus->mdio_map[addr];\r\n}\r\nstruct mii_bus *mdiobus_alloc_size(size_t size)\r\n{\r\nstruct mii_bus *bus;\r\nsize_t aligned_size = ALIGN(sizeof(*bus), NETDEV_ALIGN);\r\nsize_t alloc_size;\r\nint i;\r\nif (size)\r\nalloc_size = aligned_size + size;\r\nelse\r\nalloc_size = sizeof(*bus);\r\nbus = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!bus)\r\nreturn NULL;\r\nbus->state = MDIOBUS_ALLOCATED;\r\nif (size)\r\nbus->priv = (void *)bus + aligned_size;\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nbus->irq[i] = PHY_POLL;\r\nreturn bus;\r\n}\r\nstatic void _devm_mdiobus_free(struct device *dev, void *res)\r\n{\r\nmdiobus_free(*(struct mii_bus **)res);\r\n}\r\nstatic int devm_mdiobus_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct mii_bus **r = res;\r\nif (WARN_ON(!r || !*r))\r\nreturn 0;\r\nreturn *r == data;\r\n}\r\nstruct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv)\r\n{\r\nstruct mii_bus **ptr, *bus;\r\nptr = devres_alloc(_devm_mdiobus_free, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn NULL;\r\nbus = mdiobus_alloc_size(sizeof_priv);\r\nif (bus) {\r\n*ptr = bus;\r\ndevres_add(dev, ptr);\r\n} else {\r\ndevres_free(ptr);\r\n}\r\nreturn bus;\r\n}\r\nvoid devm_mdiobus_free(struct device *dev, struct mii_bus *bus)\r\n{\r\nint rc;\r\nrc = devres_release(dev, _devm_mdiobus_free,\r\ndevm_mdiobus_match, bus);\r\nWARN_ON(rc);\r\n}\r\nstatic void mdiobus_release(struct device *d)\r\n{\r\nstruct mii_bus *bus = to_mii_bus(d);\r\nBUG_ON(bus->state != MDIOBUS_RELEASED &&\r\nbus->state != MDIOBUS_ALLOCATED);\r\nkfree(bus);\r\n}\r\nstatic int of_mdio_bus_match(struct device *dev, const void *mdio_bus_np)\r\n{\r\nreturn dev->of_node == mdio_bus_np;\r\n}\r\nstruct mii_bus *of_mdio_find_bus(struct device_node *mdio_bus_np)\r\n{\r\nstruct device *d;\r\nif (!mdio_bus_np)\r\nreturn NULL;\r\nd = class_find_device(&mdio_bus_class, NULL, mdio_bus_np,\r\nof_mdio_bus_match);\r\nreturn d ? to_mii_bus(d) : NULL;\r\n}\r\nstatic void of_mdiobus_link_mdiodev(struct mii_bus *bus,\r\nstruct mdio_device *mdiodev)\r\n{\r\nstruct device *dev = &mdiodev->dev;\r\nstruct device_node *child;\r\nif (dev->of_node || !bus->dev.of_node)\r\nreturn;\r\nfor_each_available_child_of_node(bus->dev.of_node, child) {\r\nint addr;\r\nint ret;\r\nret = of_property_read_u32(child, "reg", &addr);\r\nif (ret < 0) {\r\ndev_err(dev, "%s has invalid MDIO address\n",\r\nchild->full_name);\r\ncontinue;\r\n}\r\nif (addr >= PHY_MAX_ADDR) {\r\ndev_err(dev, "%s MDIO address %i is too large\n",\r\nchild->full_name, addr);\r\ncontinue;\r\n}\r\nif (addr == mdiodev->addr) {\r\ndev->of_node = child;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic inline void of_mdiobus_link_mdiodev(struct mii_bus *mdio,\r\nstruct mdio_device *mdiodev)\r\n{\r\n}\r\nint __mdiobus_register(struct mii_bus *bus, struct module *owner)\r\n{\r\nstruct mdio_device *mdiodev;\r\nint i, err;\r\nif (NULL == bus || NULL == bus->name ||\r\nNULL == bus->read || NULL == bus->write)\r\nreturn -EINVAL;\r\nBUG_ON(bus->state != MDIOBUS_ALLOCATED &&\r\nbus->state != MDIOBUS_UNREGISTERED);\r\nbus->owner = owner;\r\nbus->dev.parent = bus->parent;\r\nbus->dev.class = &mdio_bus_class;\r\nbus->dev.groups = NULL;\r\ndev_set_name(&bus->dev, "%s", bus->id);\r\nerr = device_register(&bus->dev);\r\nif (err) {\r\npr_err("mii_bus %s failed to register\n", bus->id);\r\nput_device(&bus->dev);\r\nreturn -EINVAL;\r\n}\r\nmutex_init(&bus->mdio_lock);\r\nif (bus->reset)\r\nbus->reset(bus);\r\nfor (i = 0; i < PHY_MAX_ADDR; i++) {\r\nif ((bus->phy_mask & (1 << i)) == 0) {\r\nstruct phy_device *phydev;\r\nphydev = mdiobus_scan(bus, i);\r\nif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV)) {\r\nerr = PTR_ERR(phydev);\r\ngoto error;\r\n}\r\n}\r\n}\r\nbus->state = MDIOBUS_REGISTERED;\r\npr_info("%s: probed\n", bus->name);\r\nreturn 0;\r\nerror:\r\nwhile (--i >= 0) {\r\nmdiodev = bus->mdio_map[i];\r\nif (!mdiodev)\r\ncontinue;\r\nmdiodev->device_remove(mdiodev);\r\nmdiodev->device_free(mdiodev);\r\n}\r\ndevice_del(&bus->dev);\r\nreturn err;\r\n}\r\nvoid mdiobus_unregister(struct mii_bus *bus)\r\n{\r\nstruct mdio_device *mdiodev;\r\nint i;\r\nBUG_ON(bus->state != MDIOBUS_REGISTERED);\r\nbus->state = MDIOBUS_UNREGISTERED;\r\nfor (i = 0; i < PHY_MAX_ADDR; i++) {\r\nmdiodev = bus->mdio_map[i];\r\nif (!mdiodev)\r\ncontinue;\r\nmdiodev->device_remove(mdiodev);\r\nmdiodev->device_free(mdiodev);\r\n}\r\ndevice_del(&bus->dev);\r\n}\r\nvoid mdiobus_free(struct mii_bus *bus)\r\n{\r\nif (bus->state == MDIOBUS_ALLOCATED) {\r\nkfree(bus);\r\nreturn;\r\n}\r\nBUG_ON(bus->state != MDIOBUS_UNREGISTERED);\r\nbus->state = MDIOBUS_RELEASED;\r\nput_device(&bus->dev);\r\n}\r\nstruct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)\r\n{\r\nstruct phy_device *phydev;\r\nint err;\r\nphydev = get_phy_device(bus, addr, false);\r\nif (IS_ERR(phydev))\r\nreturn phydev;\r\nof_mdiobus_link_mdiodev(bus, &phydev->mdio);\r\nerr = phy_device_register(phydev);\r\nif (err) {\r\nphy_device_free(phydev);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nreturn phydev;\r\n}\r\nint mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum)\r\n{\r\nint retval;\r\nBUG_ON(in_interrupt());\r\nmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\r\nretval = bus->read(bus, addr, regnum);\r\nmutex_unlock(&bus->mdio_lock);\r\nreturn retval;\r\n}\r\nint mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\r\n{\r\nint retval;\r\nBUG_ON(in_interrupt());\r\nmutex_lock(&bus->mdio_lock);\r\nretval = bus->read(bus, addr, regnum);\r\nmutex_unlock(&bus->mdio_lock);\r\nreturn retval;\r\n}\r\nint mdiobus_write_nested(struct mii_bus *bus, int addr, u32 regnum, u16 val)\r\n{\r\nint err;\r\nBUG_ON(in_interrupt());\r\nmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\r\nerr = bus->write(bus, addr, regnum, val);\r\nmutex_unlock(&bus->mdio_lock);\r\nreturn err;\r\n}\r\nint mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val)\r\n{\r\nint err;\r\nBUG_ON(in_interrupt());\r\nmutex_lock(&bus->mdio_lock);\r\nerr = bus->write(bus, addr, regnum, val);\r\nmutex_unlock(&bus->mdio_lock);\r\nreturn err;\r\n}\r\nstatic int mdio_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct mdio_device *mdio = to_mdio_device(dev);\r\nif (of_driver_match_device(dev, drv))\r\nreturn 1;\r\nif (mdio->bus_match)\r\nreturn mdio->bus_match(dev, drv);\r\nreturn 0;\r\n}\r\nstatic int mdio_bus_suspend(struct device *dev)\r\n{\r\nstruct mdio_device *mdio = to_mdio_device(dev);\r\nif (mdio->pm_ops && mdio->pm_ops->suspend)\r\nreturn mdio->pm_ops->suspend(dev);\r\nreturn 0;\r\n}\r\nstatic int mdio_bus_resume(struct device *dev)\r\n{\r\nstruct mdio_device *mdio = to_mdio_device(dev);\r\nif (mdio->pm_ops && mdio->pm_ops->resume)\r\nreturn mdio->pm_ops->resume(dev);\r\nreturn 0;\r\n}\r\nstatic int mdio_bus_restore(struct device *dev)\r\n{\r\nstruct mdio_device *mdio = to_mdio_device(dev);\r\nif (mdio->pm_ops && mdio->pm_ops->restore)\r\nreturn mdio->pm_ops->restore(dev);\r\nreturn 0;\r\n}\r\nint __init mdio_bus_init(void)\r\n{\r\nint ret;\r\nret = class_register(&mdio_bus_class);\r\nif (!ret) {\r\nret = bus_register(&mdio_bus_type);\r\nif (ret)\r\nclass_unregister(&mdio_bus_class);\r\n}\r\nreturn ret;\r\n}\r\nvoid mdio_bus_exit(void)\r\n{\r\nclass_unregister(&mdio_bus_class);\r\nbus_unregister(&mdio_bus_type);\r\n}
