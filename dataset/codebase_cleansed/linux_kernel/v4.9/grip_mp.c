static int bit_parity(u32 pkt)\r\n{\r\nint x = pkt ^ (pkt >> 16);\r\nx ^= x >> 8;\r\nx ^= x >> 4;\r\nx ^= x >> 2;\r\nx ^= x >> 1;\r\nreturn x & 1;\r\n}\r\nstatic inline int poll_until(u8 onbits, u8 offbits, int u_sec, struct gameport* gp, u8 *data)\r\n{\r\nint i, nloops;\r\nnloops = gameport_time(gp, u_sec);\r\nfor (i = 0; i < nloops; i++) {\r\n*data = gameport_read(gp);\r\nif ((*data & onbits) == onbits &&\r\n(~(*data) & offbits) == offbits)\r\nreturn 1;\r\n}\r\ndbg("gameport timed out after %d microseconds.\n", u_sec);\r\nreturn 0;\r\n}\r\nstatic int mp_io(struct gameport* gameport, int sendflags, int sendcode, u32 *packet)\r\n{\r\nu8 raw_data;\r\nu8 data_mask;\r\nu32 pkt;\r\nint bits_per_read;\r\nint portvals = 0;\r\nint i;\r\n*packet = 0;\r\nraw_data = gameport_read(gameport);\r\nif (raw_data & 1)\r\nreturn IO_RETRY;\r\nfor (i = 0; i < 64; i++) {\r\nraw_data = gameport_read(gameport);\r\nportvals |= 1 << ((raw_data >> 4) & 3);\r\n}\r\nif (portvals == 1) {\r\nraw_data = gameport_read(gameport);\r\nportvals = raw_data & 0xf0;\r\nif (raw_data & 0x31)\r\nreturn IO_RESET;\r\ngameport_trigger(gameport);\r\nif (!poll_until(0x10, 0, 308, gameport, &raw_data))\r\nreturn IO_RESET;\r\n} else\r\nreturn IO_RETRY;\r\nif (raw_data & 0x20) {\r\nportvals |= raw_data >> 4;\r\nif (portvals != 0xb)\r\nreturn 0;\r\ndata_mask = 7;\r\nbits_per_read = 3;\r\npkt = (PACKET_FULL | PACKET_IO_FAST) >> 28;\r\n} else {\r\ndata_mask = 1;\r\nbits_per_read = 1;\r\npkt = (PACKET_FULL | PACKET_IO_SLOW) >> 28;\r\n}\r\nwhile (1) {\r\nif (!poll_until(0, 0x10, 77, gameport, &raw_data))\r\nreturn IO_RESET;\r\nraw_data = (raw_data >> 5) & data_mask;\r\nif (pkt & PACKET_FULL)\r\nbreak;\r\npkt = (pkt << bits_per_read) | raw_data;\r\nif (!poll_until(0x10, 0, 77, gameport, &raw_data))\r\nreturn IO_RESET;\r\n}\r\nif (raw_data)\r\nreturn IO_RESET;\r\nif (bits_per_read == 3) {\r\npkt = (pkt & 0xffff0000) | ((pkt << 1) & 0xffff);\r\npkt = (pkt >> 2) | 0xf0000000;\r\n}\r\nif (bit_parity(pkt) == 1)\r\nreturn IO_RESET;\r\nif (!poll_until(0x30, 0, 77, gameport, &raw_data))\r\nreturn IO_RESET;\r\nraw_data = gameport_read(gameport);\r\nif (raw_data & 1)\r\nreturn IO_RESET;\r\ngameport_trigger(gameport);\r\nif (!poll_until(0, 0x20, 77, gameport, &raw_data))\r\nreturn IO_RESET;\r\n*packet = pkt;\r\nif ((sendflags == 0) || ((sendflags & IO_RETRY) && !(pkt & PACKET_MP_DONE)))\r\nreturn IO_GOT_PACKET;\r\nif (pkt & PACKET_MP_MORE)\r\nreturn IO_GOT_PACKET | IO_RETRY;\r\nif (!poll_until(0x20, 0, 77, gameport, &raw_data))\r\nreturn IO_GOT_PACKET | IO_RESET;\r\nraw_data = gameport_read(gameport);\r\nif (raw_data & 1)\r\nreturn IO_GOT_PACKET | IO_RESET;\r\ngameport_trigger(gameport);\r\ndo {\r\nif (!poll_until(0x20, 0x10, 116, gameport, &raw_data))\r\nreturn IO_GOT_PACKET | IO_RESET;\r\nif (!poll_until(0x30, 0, 193, gameport, &raw_data))\r\nreturn IO_GOT_PACKET | IO_RESET;\r\nif (raw_data & 1)\r\nreturn IO_GOT_PACKET | IO_RESET;\r\nif (sendcode & 1)\r\ngameport_trigger(gameport);\r\nsendcode >>= 1;\r\n} while (sendcode);\r\nreturn IO_GOT_PACKET | IO_MODE_FAST;\r\n}\r\nstatic int multiport_io(struct gameport* gameport, int sendflags, int sendcode, u32 *packet)\r\n{\r\nint status;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nstatus = mp_io(gameport, sendflags, sendcode, packet);\r\nlocal_irq_restore(flags);\r\nreturn status;\r\n}\r\nstatic int dig_mode_start(struct gameport *gameport, u32 *packet)\r\n{\r\nint i;\r\nint flags, tries = 0, bads = 0;\r\nfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\r\nif (init_seq[i])\r\ngameport_trigger(gameport);\r\nudelay(GRIP_INIT_DELAY);\r\n}\r\nfor (i = 0; i < 16; i++)\r\nudelay(GRIP_INIT_DELAY);\r\nwhile (tries < 64 && bads < 8) {\r\nflags = multiport_io(gameport, IO_RESET, 0x27, packet);\r\nif (flags & IO_MODE_FAST)\r\nreturn 1;\r\nif (flags & IO_RETRY)\r\ntries++;\r\nelse\r\nbads++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_and_decode_packet(struct grip_mp *grip, int flags)\r\n{\r\nstruct grip_port *port;\r\nu32 packet;\r\nint joytype = 0;\r\nint slot;\r\nflags &= IO_RESET | IO_RETRY;\r\nflags = multiport_io(grip->gameport, flags, 0, &packet);\r\ngrip->reads++;\r\nif (packet & PACKET_MP_DONE)\r\nflags |= IO_DONE;\r\nif (flags && !(flags & IO_GOT_PACKET)) {\r\ngrip->bads++;\r\nreturn flags;\r\n}\r\nslot = ((packet >> 21) & 0xf) - 1;\r\nif ((slot < 0) || (slot > 3))\r\nreturn flags;\r\nport = grip->port[slot];\r\njoytype = (packet >> 16) & 0x1f;\r\nif (!joytype) {\r\nif (port->registered) {\r\nprintk(KERN_INFO "grip_mp: removing %s, slot %d\n",\r\ngrip_name[port->mode], slot);\r\ninput_unregister_device(port->dev);\r\nport->registered = 0;\r\n}\r\ndbg("Reset: grip multiport slot %d\n", slot);\r\nport->mode = GRIP_MODE_RESET;\r\nflags |= IO_SLOT_CHANGE;\r\nreturn flags;\r\n}\r\nif (joytype == 0x1f) {\r\nint dir = (packet >> 8) & 0xf;\r\nport->buttons = (~packet) & 0xff;\r\nport->yaxes = ((axis_map[dir] >> 2) & 3) - 1;\r\nport->xaxes = (axis_map[dir] & 3) - 1;\r\nport->dirty = 1;\r\nif (port->mode == GRIP_MODE_RESET)\r\nflags |= IO_SLOT_CHANGE;\r\nport->mode = GRIP_MODE_GP;\r\nif (!port->registered) {\r\ndbg("New Grip pad in multiport slot %d.\n", slot);\r\nif (register_slot(slot, grip)) {\r\nport->mode = GRIP_MODE_RESET;\r\nport->dirty = 0;\r\n}\r\n}\r\nreturn flags;\r\n}\r\n{\r\nstatic int strange_code = 0;\r\nif (strange_code != joytype) {\r\nprintk(KERN_INFO "Possible non-grip pad/joystick detected.\n");\r\nprintk(KERN_INFO "Got joy type 0x%x and packet 0x%x.\n", joytype, packet);\r\nstrange_code = joytype;\r\n}\r\n}\r\nreturn flags;\r\n}\r\nstatic int slots_valid(struct grip_mp *grip)\r\n{\r\nint flags, slot, invalid = 0, active = 0;\r\nflags = get_and_decode_packet(grip, 0);\r\nif (!(flags & IO_GOT_PACKET))\r\nreturn 0;\r\nfor (slot = 0; slot < 4; slot++) {\r\nif (grip->port[slot]->mode == GRIP_MODE_RESET)\r\ninvalid = 1;\r\nif (grip->port[slot]->mode != GRIP_MODE_NONE)\r\nactive = 1;\r\n}\r\nif (!active)\r\nreturn (flags & IO_DONE) ? 1 : 0;\r\nreturn invalid ? 0 : 1;\r\n}\r\nstatic int multiport_init(struct grip_mp *grip)\r\n{\r\nint dig_mode, initialized = 0, tries = 0;\r\nu32 packet;\r\ndig_mode = dig_mode_start(grip->gameport, &packet);\r\nwhile (!dig_mode && tries < 4) {\r\ndig_mode = dig_mode_start(grip->gameport, &packet);\r\ntries++;\r\n}\r\nif (dig_mode)\r\ndbg("multiport_init(): digital mode activated.\n");\r\nelse {\r\ndbg("multiport_init(): unable to activate digital mode.\n");\r\nreturn 0;\r\n}\r\nfor (tries = 0; tries < 4096; tries++) {\r\nif (slots_valid(grip)) {\r\ninitialized = 1;\r\nbreak;\r\n}\r\n}\r\ndbg("multiport_init(): initialized == %d\n", initialized);\r\nreturn initialized;\r\n}\r\nstatic void report_slot(struct grip_mp *grip, int slot)\r\n{\r\nstruct grip_port *port = grip->port[slot];\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\ninput_report_key(port->dev, grip_btn_gp[i], (port->buttons >> i) & 1);\r\ninput_report_abs(port->dev, ABS_X, port->xaxes);\r\ninput_report_abs(port->dev, ABS_Y, port->yaxes);\r\ninput_sync(port->dev);\r\nport->dirty = 0;\r\n}\r\nstatic void grip_poll(struct gameport *gameport)\r\n{\r\nstruct grip_mp *grip = gameport_get_drvdata(gameport);\r\nint i, npkts, flags;\r\nfor (npkts = 0; npkts < 4; npkts++) {\r\nflags = IO_RETRY;\r\nfor (i = 0; i < 32; i++) {\r\nflags = get_and_decode_packet(grip, flags);\r\nif ((flags & IO_GOT_PACKET) || !(flags & IO_RETRY))\r\nbreak;\r\n}\r\nif (flags & IO_DONE)\r\nbreak;\r\n}\r\nfor (i = 0; i < 4; i++)\r\nif (grip->port[i]->dirty)\r\nreport_slot(grip, i);\r\n}\r\nstatic int grip_open(struct input_dev *dev)\r\n{\r\nstruct grip_mp *grip = input_get_drvdata(dev);\r\ngameport_start_polling(grip->gameport);\r\nreturn 0;\r\n}\r\nstatic void grip_close(struct input_dev *dev)\r\n{\r\nstruct grip_mp *grip = input_get_drvdata(dev);\r\ngameport_stop_polling(grip->gameport);\r\n}\r\nstatic int register_slot(int slot, struct grip_mp *grip)\r\n{\r\nstruct grip_port *port = grip->port[slot];\r\nstruct input_dev *input_dev;\r\nint j, t;\r\nint err;\r\nport->dev = input_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ninput_dev->name = grip_name[port->mode];\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;\r\ninput_dev->id.product = 0x0100 + port->mode;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &grip->gameport->dev;\r\ninput_set_drvdata(input_dev, grip);\r\ninput_dev->open = grip_open;\r\ninput_dev->close = grip_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (j = 0; (t = grip_abs[port->mode][j]) >= 0; j++)\r\ninput_set_abs_params(input_dev, t, -1, 1, 0, 0);\r\nfor (j = 0; (t = grip_btn[port->mode][j]) >= 0; j++)\r\nif (t > 0)\r\nset_bit(t, input_dev->keybit);\r\nerr = input_register_device(port->dev);\r\nif (err) {\r\ninput_free_device(port->dev);\r\nreturn err;\r\n}\r\nport->registered = 1;\r\nif (port->dirty)\r\nreport_slot(grip, slot);\r\nreturn 0;\r\n}\r\nstatic int grip_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nstruct grip_mp *grip;\r\nint err;\r\nif (!(grip = kzalloc(sizeof(struct grip_mp), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\ngrip->gameport = gameport;\r\ngameport_set_drvdata(gameport, grip);\r\nerr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\nif (err)\r\ngoto fail1;\r\ngameport_set_poll_handler(gameport, grip_poll);\r\ngameport_set_poll_interval(gameport, 20);\r\nif (!multiport_init(grip)) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\nif (!grip->port[0]->mode && !grip->port[1]->mode && !grip->port[2]->mode && !grip->port[3]->mode) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\nreturn 0;\r\nfail2: gameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\nkfree(grip);\r\nreturn err;\r\n}\r\nstatic void grip_disconnect(struct gameport *gameport)\r\n{\r\nstruct grip_mp *grip = gameport_get_drvdata(gameport);\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nif (grip->port[i]->registered)\r\ninput_unregister_device(grip->port[i]->dev);\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nkfree(grip);\r\n}
