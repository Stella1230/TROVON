static void byd_report_input(struct psmouse *psmouse)\r\n{\r\nstruct byd_data *priv = psmouse->private;\r\nstruct input_dev *dev = psmouse->dev;\r\ninput_report_key(dev, BTN_TOUCH, priv->touch);\r\ninput_report_key(dev, BTN_TOOL_FINGER, priv->touch);\r\ninput_report_abs(dev, ABS_X, priv->abs_x);\r\ninput_report_abs(dev, ABS_Y, priv->abs_y);\r\ninput_report_key(dev, BTN_LEFT, priv->btn_left);\r\ninput_report_key(dev, BTN_RIGHT, priv->btn_right);\r\ninput_sync(dev);\r\n}\r\nstatic void byd_clear_touch(unsigned long data)\r\n{\r\nstruct psmouse *psmouse = (struct psmouse *)data;\r\nstruct byd_data *priv = psmouse->private;\r\nserio_pause_rx(psmouse->ps2dev.serio);\r\npriv->touch = false;\r\nbyd_report_input(psmouse);\r\nserio_continue_rx(psmouse->ps2dev.serio);\r\npriv->abs_x = BYD_PAD_WIDTH / 2;\r\npriv->abs_y = BYD_PAD_HEIGHT / 2;\r\n}\r\nstatic psmouse_ret_t byd_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct byd_data *priv = psmouse->private;\r\nu8 *pkt = psmouse->packet;\r\nif (psmouse->pktcnt > 0 && !(pkt[0] & PS2_ALWAYS_1)) {\r\npsmouse_warn(psmouse, "Always_1 bit not 1. pkt[0] = %02x\n",\r\npkt[0]);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (psmouse->pktcnt < psmouse->pktsize)\r\nreturn PSMOUSE_GOOD_DATA;\r\nswitch (pkt[3]) {\r\ncase BYD_PACKET_ABSOLUTE:\r\nif (!priv->touch) {\r\ntypeof(jiffies) tap_time =\r\npriv->last_touch_time + BYD_TOUCH_TIMEOUT;\r\npriv->touch = time_after(jiffies, tap_time);\r\npriv->abs_x = pkt[1] * (BYD_PAD_WIDTH / 256);\r\npriv->abs_y = (255 - pkt[2]) * (BYD_PAD_HEIGHT / 256);\r\n}\r\nbreak;\r\ncase BYD_PACKET_RELATIVE: {\r\nu32 signx = pkt[0] & PS2_X_SIGN ? ~0xFF : 0;\r\nu32 signy = pkt[0] & PS2_Y_SIGN ? ~0xFF : 0;\r\ns32 dx = signx | (int) pkt[1];\r\ns32 dy = signy | (int) pkt[2];\r\npriv->abs_x += dx * BYD_DT;\r\npriv->abs_y -= dy * BYD_DT;\r\npriv->touch = true;\r\nbreak;\r\n}\r\ndefault:\r\npsmouse_warn(psmouse,\r\n"Unrecognized Z: pkt = %02x %02x %02x %02x\n",\r\npsmouse->packet[0], psmouse->packet[1],\r\npsmouse->packet[2], psmouse->packet[3]);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\npriv->btn_left = pkt[0] & PS2_LEFT;\r\npriv->btn_right = pkt[0] & PS2_RIGHT;\r\nbyd_report_input(psmouse);\r\nif (priv->touch) {\r\npriv->last_touch_time = jiffies;\r\nmod_timer(&priv->timer, jiffies + BYD_TOUCH_TIMEOUT);\r\n}\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nstatic int byd_reset_touchpad(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nu8 param[4];\r\nsize_t i;\r\nconst struct {\r\nu16 command;\r\nu8 arg;\r\n} seq[] = {\r\n{ PSMOUSE_CMD_SETRATE, 0xC8 },\r\n{ PSMOUSE_CMD_SETRATE, 0x64 },\r\n{ PSMOUSE_CMD_SETRATE, 0x50 },\r\n{ PSMOUSE_CMD_GETID, 0 },\r\n{ PSMOUSE_CMD_ENABLE, 0 },\r\n{ 0x10E2, 0x00 },\r\n{ 0x10E0, 0x02 },\r\n{ 0x14E0, 0x01 },\r\n{ BYD_CMD_SET_HANDEDNESS, 0x01 },\r\n{ BYD_CMD_SET_PHYSICAL_BUTTONS, 0x04 },\r\n{ BYD_CMD_SET_TAP, 0x02 },\r\n{ BYD_CMD_SET_ONE_FINGER_SCROLL, 0x04 },\r\n{ BYD_CMD_SET_ONE_FINGER_SCROLL_FUNC, 0x04 },\r\n{ BYD_CMD_SET_EDGE_MOTION, 0x01 },\r\n{ BYD_CMD_SET_PALM_CHECK, 0x00 },\r\n{ BYD_CMD_SET_MULTITOUCH, 0x02 },\r\n{ BYD_CMD_SET_TWO_FINGER_SCROLL, 0x04 },\r\n{ BYD_CMD_SET_TWO_FINGER_SCROLL_FUNC, 0x04 },\r\n{ BYD_CMD_SET_LEFT_EDGE_REGION, 0x00 },\r\n{ BYD_CMD_SET_TOP_EDGE_REGION, 0x00 },\r\n{ BYD_CMD_SET_RIGHT_EDGE_REGION, 0x00 },\r\n{ BYD_CMD_SET_BOTTOM_EDGE_REGION, 0x00 },\r\n{ BYD_CMD_SET_ABSOLUTE_MODE, 0x02 },\r\n{ 0x10E0, 0x00 },\r\n{ 0x10E2, 0x01 },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(seq); ++i) {\r\nmemset(param, 0, sizeof(param));\r\nparam[0] = seq[i].arg;\r\nif (ps2_command(ps2dev, param, seq[i].command))\r\nreturn -EIO;\r\n}\r\npsmouse_set_state(psmouse, PSMOUSE_ACTIVATED);\r\nreturn 0;\r\n}\r\nstatic int byd_reconnect(struct psmouse *psmouse)\r\n{\r\nint retry = 0, error = 0;\r\npsmouse_dbg(psmouse, "Reconnect\n");\r\ndo {\r\npsmouse_reset(psmouse);\r\nif (retry)\r\nssleep(1);\r\nerror = byd_detect(psmouse, 0);\r\n} while (error && ++retry < 3);\r\nif (error)\r\nreturn error;\r\npsmouse_dbg(psmouse, "Reconnected after %d attempts\n", retry);\r\nerror = byd_reset_touchpad(psmouse);\r\nif (error) {\r\npsmouse_err(psmouse, "Unable to initialize device\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void byd_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct byd_data *priv = psmouse->private;\r\nif (priv) {\r\ndel_timer(&priv->timer);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\n}\r\n}\r\nint byd_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nu8 param[4] = {0x03, 0x00, 0x00, 0x00};\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES))\r\nreturn -1;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES))\r\nreturn -1;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES))\r\nreturn -1;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRES))\r\nreturn -1;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\nif (param[1] != 0x03 || param[2] != 0x64)\r\nreturn -ENODEV;\r\npsmouse_dbg(psmouse, "BYD touchpad detected\n");\r\nif (set_properties) {\r\npsmouse->vendor = "BYD";\r\npsmouse->name = "TouchPad";\r\n}\r\nreturn 0;\r\n}\r\nint byd_init(struct psmouse *psmouse)\r\n{\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct byd_data *priv;\r\nif (psmouse_reset(psmouse))\r\nreturn -EIO;\r\nif (byd_reset_touchpad(psmouse))\r\nreturn -EIO;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nsetup_timer(&priv->timer, byd_clear_touch, (unsigned long) psmouse);\r\npsmouse->private = priv;\r\npsmouse->disconnect = byd_disconnect;\r\npsmouse->reconnect = byd_reconnect;\r\npsmouse->protocol_handler = byd_process_byte;\r\npsmouse->pktsize = 4;\r\npsmouse->resync_time = 0;\r\n__set_bit(INPUT_PROP_POINTER, dev->propbit);\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(BTN_TOOL_FINGER, dev->keybit);\r\n__set_bit(BTN_LEFT, dev->keybit);\r\n__set_bit(BTN_RIGHT, dev->keybit);\r\n__clear_bit(BTN_MIDDLE, dev->keybit);\r\n__set_bit(EV_ABS, dev->evbit);\r\ninput_set_abs_params(dev, ABS_X, 0, BYD_PAD_WIDTH, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, 0, BYD_PAD_HEIGHT, 0, 0);\r\ninput_abs_set_res(dev, ABS_X, BYD_PAD_RESOLUTION);\r\ninput_abs_set_res(dev, ABS_Y, BYD_PAD_RESOLUTION);\r\n__clear_bit(EV_REL, dev->evbit);\r\n__clear_bit(REL_X, dev->relbit);\r\n__clear_bit(REL_Y, dev->relbit);\r\nreturn 0;\r\n}
