static void midi_input_escaped_byte(struct snd_rawmidi_substream *stream,\r\nu8 byte)\r\n{\r\nu8 nibbles[2];\r\nnibbles[0] = byte >> 4;\r\nnibbles[1] = byte & 0x0f;\r\nsnd_rawmidi_receive(stream, nibbles, 2);\r\n}\r\nstatic void midi_input_byte(struct fw_scs1x *scs,\r\nstruct snd_rawmidi_substream *stream, u8 byte)\r\n{\r\nconst u8 eox = 0xf7;\r\nif (scs->input_escape_count > 0) {\r\nmidi_input_escaped_byte(stream, byte);\r\nscs->input_escape_count--;\r\nif (scs->input_escape_count == 0)\r\nsnd_rawmidi_receive(stream, &eox, sizeof(eox));\r\n} else if (byte == 0xf9) {\r\nsnd_rawmidi_receive(stream, sysex_escape_prefix,\r\nARRAY_SIZE(sysex_escape_prefix));\r\nmidi_input_escaped_byte(stream, 0x00);\r\nmidi_input_escaped_byte(stream, 0xf9);\r\nscs->input_escape_count = 3;\r\n} else {\r\nsnd_rawmidi_receive(stream, &byte, 1);\r\n}\r\n}\r\nstatic void midi_input_packet(struct fw_scs1x *scs,\r\nstruct snd_rawmidi_substream *stream,\r\nconst u8 *data, unsigned int bytes)\r\n{\r\nunsigned int i;\r\nconst u8 eox = 0xf7;\r\nif (data[0] == HSS1394_TAG_USER_DATA) {\r\nfor (i = 1; i < bytes; ++i)\r\nmidi_input_byte(scs, stream, data[i]);\r\n} else {\r\nsnd_rawmidi_receive(stream, sysex_escape_prefix,\r\nARRAY_SIZE(sysex_escape_prefix));\r\nfor (i = 0; i < bytes; ++i)\r\nmidi_input_escaped_byte(stream, data[i]);\r\nsnd_rawmidi_receive(stream, &eox, sizeof(eox));\r\n}\r\n}\r\nstatic void handle_hss(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source, int generation,\r\nunsigned long long offset, void *data, size_t length,\r\nvoid *callback_data)\r\n{\r\nstruct fw_scs1x *scs = callback_data;\r\nstruct snd_rawmidi_substream *stream;\r\nint rcode;\r\nif (offset != scs->hss_handler.offset) {\r\nrcode = RCODE_ADDRESS_ERROR;\r\ngoto end;\r\n}\r\nif (tcode != TCODE_WRITE_QUADLET_REQUEST &&\r\ntcode != TCODE_WRITE_BLOCK_REQUEST) {\r\nrcode = RCODE_TYPE_ERROR;\r\ngoto end;\r\n}\r\nif (length >= 1) {\r\nstream = ACCESS_ONCE(scs->input);\r\nif (stream)\r\nmidi_input_packet(scs, stream, data, length);\r\n}\r\nrcode = RCODE_COMPLETE;\r\nend:\r\nfw_send_response(card, request, rcode);\r\n}\r\nstatic void scs_write_callback(struct fw_card *card, int rcode,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct fw_scs1x *scs = callback_data;\r\nif (!rcode_is_permanent_error(rcode)) {\r\nif (rcode == RCODE_COMPLETE)\r\nscs->transaction_bytes = 0;\r\n} else {\r\nscs->error = true;\r\n}\r\nscs->transaction_running = false;\r\nschedule_work(&scs->work);\r\n}\r\nstatic bool is_valid_running_status(u8 status)\r\n{\r\nreturn status >= 0x80 && status <= 0xef;\r\n}\r\nstatic bool is_one_byte_cmd(u8 status)\r\n{\r\nreturn status == 0xf6 ||\r\nstatus >= 0xf8;\r\n}\r\nstatic bool is_two_bytes_cmd(u8 status)\r\n{\r\nreturn (status >= 0xc0 && status <= 0xdf) ||\r\nstatus == 0xf1 ||\r\nstatus == 0xf3;\r\n}\r\nstatic bool is_three_bytes_cmd(u8 status)\r\n{\r\nreturn (status >= 0x80 && status <= 0xbf) ||\r\n(status >= 0xe0 && status <= 0xef) ||\r\nstatus == 0xf2;\r\n}\r\nstatic bool is_invalid_cmd(u8 status)\r\n{\r\nreturn status == 0xf4 ||\r\nstatus == 0xf5 ||\r\nstatus == 0xf9 ||\r\nstatus == 0xfd;\r\n}\r\nstatic void scs_output_work(struct work_struct *work)\r\n{\r\nstruct fw_scs1x *scs = container_of(work, struct fw_scs1x, work);\r\nstruct snd_rawmidi_substream *stream;\r\nunsigned int i;\r\nu8 byte;\r\nint generation;\r\nif (scs->transaction_running)\r\nreturn;\r\nstream = ACCESS_ONCE(scs->output);\r\nif (!stream || scs->error) {\r\nscs->output_idle = true;\r\nwake_up(&scs->idle_wait);\r\nreturn;\r\n}\r\nif (scs->transaction_bytes > 0)\r\ngoto retry;\r\ni = scs->output_bytes;\r\nfor (;;) {\r\nif (snd_rawmidi_transmit(stream, &byte, 1) != 1) {\r\nscs->output_bytes = i;\r\nscs->output_idle = true;\r\nwake_up(&scs->idle_wait);\r\nreturn;\r\n}\r\nif (scs->output_escaped && byte < 0x80) {\r\nif (scs->output_escape_high_nibble) {\r\nif (i < HSS1394_MAX_PACKET_SIZE) {\r\nscs->buffer[i] = byte << 4;\r\nscs->output_escape_high_nibble = false;\r\n}\r\n} else {\r\nscs->buffer[i++] |= byte & 0x0f;\r\nscs->output_escape_high_nibble = true;\r\n}\r\n} else if (byte < 0x80) {\r\nif (i == 1) {\r\nif (!is_valid_running_status(\r\nscs->output_status))\r\ncontinue;\r\nscs->buffer[0] = HSS1394_TAG_USER_DATA;\r\nscs->buffer[i++] = scs->output_status;\r\n}\r\nscs->buffer[i++] = byte;\r\nif ((i == 3 && is_two_bytes_cmd(scs->output_status)) ||\r\n(i == 4 && is_three_bytes_cmd(scs->output_status)))\r\nbreak;\r\nif (i == 1 + ARRAY_SIZE(sysex_escape_prefix) &&\r\n!memcmp(scs->buffer + 1, sysex_escape_prefix,\r\nARRAY_SIZE(sysex_escape_prefix))) {\r\nscs->output_escaped = true;\r\nscs->output_escape_high_nibble = true;\r\ni = 0;\r\n}\r\nif (i >= HSS1394_MAX_PACKET_SIZE)\r\ni = 1;\r\n} else if (byte == 0xf7) {\r\nif (scs->output_escaped) {\r\nif (i >= 1 && scs->output_escape_high_nibble &&\r\nscs->buffer[0] !=\r\nHSS1394_TAG_CHANGE_ADDRESS)\r\nbreak;\r\n} else {\r\nif (i > 1 && scs->output_status == 0xf0) {\r\nscs->buffer[i++] = 0xf7;\r\nbreak;\r\n}\r\n}\r\ni = 1;\r\nscs->output_escaped = false;\r\n} else if (!is_invalid_cmd(byte) && byte < 0xf8) {\r\ni = 1;\r\nscs->buffer[0] = HSS1394_TAG_USER_DATA;\r\nscs->buffer[i++] = byte;\r\nscs->output_status = byte;\r\nscs->output_escaped = false;\r\nif (is_one_byte_cmd(byte))\r\nbreak;\r\n}\r\n}\r\nscs->output_bytes = 1;\r\nscs->output_escaped = false;\r\nscs->transaction_bytes = i;\r\nretry:\r\nscs->transaction_running = true;\r\ngeneration = scs->fw_dev->generation;\r\nsmp_rmb();\r\nfw_send_request(scs->fw_dev->card, &scs->transaction,\r\nTCODE_WRITE_BLOCK_REQUEST, scs->fw_dev->node_id,\r\ngeneration, scs->fw_dev->max_speed, HSS1394_ADDRESS,\r\nscs->buffer, scs->transaction_bytes,\r\nscs_write_callback, scs);\r\n}\r\nstatic int midi_capture_open(struct snd_rawmidi_substream *stream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int midi_capture_close(struct snd_rawmidi_substream *stream)\r\n{\r\nreturn 0;\r\n}\r\nstatic void midi_capture_trigger(struct snd_rawmidi_substream *stream, int up)\r\n{\r\nstruct fw_scs1x *scs = stream->rmidi->private_data;\r\nif (up) {\r\nscs->input_escape_count = 0;\r\nACCESS_ONCE(scs->input) = stream;\r\n} else {\r\nACCESS_ONCE(scs->input) = NULL;\r\n}\r\n}\r\nstatic int midi_playback_open(struct snd_rawmidi_substream *stream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int midi_playback_close(struct snd_rawmidi_substream *stream)\r\n{\r\nreturn 0;\r\n}\r\nstatic void midi_playback_trigger(struct snd_rawmidi_substream *stream, int up)\r\n{\r\nstruct fw_scs1x *scs = stream->rmidi->private_data;\r\nif (up) {\r\nscs->output_status = 0;\r\nscs->output_bytes = 1;\r\nscs->output_escaped = false;\r\nscs->output_idle = false;\r\nscs->transaction_bytes = 0;\r\nscs->error = false;\r\nACCESS_ONCE(scs->output) = stream;\r\nschedule_work(&scs->work);\r\n} else {\r\nACCESS_ONCE(scs->output) = NULL;\r\n}\r\n}\r\nstatic void midi_playback_drain(struct snd_rawmidi_substream *stream)\r\n{\r\nstruct fw_scs1x *scs = stream->rmidi->private_data;\r\nwait_event(scs->idle_wait, scs->output_idle);\r\n}\r\nstatic int register_address(struct snd_oxfw *oxfw)\r\n{\r\nstruct fw_scs1x *scs = oxfw->spec;\r\n__be64 data;\r\ndata = cpu_to_be64(((u64)HSS1394_TAG_CHANGE_ADDRESS << 56) |\r\nscs->hss_handler.offset);\r\nreturn snd_fw_transaction(oxfw->unit, TCODE_WRITE_BLOCK_REQUEST,\r\nHSS1394_ADDRESS, &data, sizeof(data), 0);\r\n}\r\nstatic void remove_scs1x(struct snd_rawmidi *rmidi)\r\n{\r\nstruct fw_scs1x *scs = rmidi->private_data;\r\nfw_core_remove_address_handler(&scs->hss_handler);\r\n}\r\nvoid snd_oxfw_scs1x_update(struct snd_oxfw *oxfw)\r\n{\r\nregister_address(oxfw);\r\n}\r\nint snd_oxfw_scs1x_add(struct snd_oxfw *oxfw)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nstruct fw_scs1x *scs;\r\nint err;\r\nscs = kzalloc(sizeof(struct fw_scs1x), GFP_KERNEL);\r\nif (scs == NULL)\r\nreturn -ENOMEM;\r\nscs->fw_dev = fw_parent_device(oxfw->unit);\r\noxfw->spec = scs;\r\nscs->hss_handler.length = HSS1394_MAX_PACKET_SIZE;\r\nscs->hss_handler.address_callback = handle_hss;\r\nscs->hss_handler.callback_data = scs;\r\nerr = fw_core_add_address_handler(&scs->hss_handler,\r\n&fw_high_memory_region);\r\nif (err < 0)\r\nreturn err;\r\nerr = register_address(oxfw);\r\nif (err < 0)\r\ngoto err_allocated;\r\nerr = snd_rawmidi_new(oxfw->card, "SCS.1x", 0, 1, 1, &rmidi);\r\nif (err < 0)\r\ngoto err_allocated;\r\nrmidi->private_data = scs;\r\nrmidi->private_free = remove_scs1x;\r\nsnprintf(rmidi->name, sizeof(rmidi->name),\r\n"%s MIDI", oxfw->card->shortname);\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\r\n&midi_capture_ops);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\r\n&midi_playback_ops);\r\nINIT_WORK(&scs->work, scs_output_work);\r\ninit_waitqueue_head(&scs->idle_wait);\r\nscs->output_idle = true;\r\nreturn 0;\r\nerr_allocated:\r\nfw_core_remove_address_handler(&scs->hss_handler);\r\nreturn err;\r\n}
