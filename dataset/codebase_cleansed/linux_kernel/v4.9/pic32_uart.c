static inline void pic32_wait_deplete_txbuf(struct pic32_sport *sport)\r\n{\r\nwhile (!(pic32_uart_readl(sport, PIC32_UART_STA) & PIC32_UART_STA_TRMT))\r\nudelay(1);\r\n}\r\nstatic inline int pic32_enable_clock(struct pic32_sport *sport)\r\n{\r\nint ret = clk_prepare_enable(sport->clk);\r\nif (ret)\r\nreturn ret;\r\nsport->ref_clk++;\r\nreturn 0;\r\n}\r\nstatic inline void pic32_disable_clock(struct pic32_sport *sport)\r\n{\r\nsport->ref_clk--;\r\nclk_disable_unprepare(sport->clk);\r\n}\r\nstatic unsigned int pic32_uart_tx_empty(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nu32 val = pic32_uart_readl(sport, PIC32_UART_STA);\r\nreturn (val & PIC32_UART_STA_TRMT) ? 1 : 0;\r\n}\r\nstatic void pic32_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nif (mctrl & TIOCM_LOOP)\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\r\nPIC32_UART_MODE_LPBK);\r\nelse\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_LPBK);\r\n}\r\nstatic unsigned int get_cts_state(struct pic32_sport *sport)\r\n{\r\nif (gpio_is_valid(sport->cts_gpio))\r\nreturn !gpio_get_value(sport->cts_gpio);\r\nreturn 1;\r\n}\r\nstatic unsigned int pic32_uart_get_mctrl(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nunsigned int mctrl = 0;\r\nif (!sport->hw_flow_ctrl)\r\nmctrl |= TIOCM_CTS;\r\nelse if (get_cts_state(sport))\r\nmctrl |= TIOCM_CTS;\r\nmctrl |= TIOCM_CD;\r\nmctrl |= TIOCM_DSR;\r\nreturn mctrl;\r\n}\r\nstatic inline void pic32_uart_irqtxen(struct pic32_sport *sport, u8 en)\r\n{\r\nif (en && !tx_irq_enabled(sport)) {\r\nenable_irq(sport->irq_tx);\r\ntx_irq_enabled(sport) = 1;\r\n} else if (!en && tx_irq_enabled(sport)) {\r\ndisable_irq_nosync(sport->irq_tx);\r\ntx_irq_enabled(sport) = 0;\r\n}\r\n}\r\nstatic void pic32_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nif (!(pic32_uart_readl(sport, PIC32_UART_MODE) & PIC32_UART_MODE_ON))\r\nreturn;\r\nif (!(pic32_uart_readl(sport, PIC32_UART_STA) & PIC32_UART_STA_UTXEN))\r\nreturn;\r\npic32_wait_deplete_txbuf(sport);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\r\nPIC32_UART_STA_UTXEN);\r\npic32_uart_irqtxen(sport, 0);\r\n}\r\nstatic void pic32_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\npic32_uart_irqtxen(sport, 1);\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_STA),\r\nPIC32_UART_STA_UTXEN);\r\n}\r\nstatic void pic32_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\ndisable_irq(sport->irq_rx);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\r\nPIC32_UART_STA_URXEN);\r\n}\r\nstatic void pic32_uart_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (ctl)\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_STA),\r\nPIC32_UART_STA_UTXBRK);\r\nelse\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\r\nPIC32_UART_STA_UTXBRK);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *pic32_uart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_PIC32) ? PIC32_DEV_NAME : NULL;\r\n}\r\nstatic void pic32_uart_do_rx(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nstruct tty_port *tty;\r\nunsigned int max_count;\r\nmax_count = PIC32_UART_RX_FIFO_DEPTH;\r\nspin_lock(&port->lock);\r\ntty = &port->state->port;\r\ndo {\r\nu32 sta_reg, c;\r\nchar flag;\r\nsta_reg = pic32_uart_readl(sport, PIC32_UART_STA);\r\nif (unlikely(sta_reg & PIC32_UART_STA_OERR)) {\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\r\nPIC32_UART_STA_OERR);\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\n}\r\nif (!(sta_reg & PIC32_UART_STA_URXDA))\r\nbreak;\r\nc = pic32_uart_readl(sport, PIC32_UART_RX);\r\nport->icount.rx++;\r\nflag = TTY_NORMAL;\r\nc &= 0xff;\r\nif (unlikely((sta_reg & PIC32_UART_STA_PERR) ||\r\n(sta_reg & PIC32_UART_STA_FERR))) {\r\nif (sta_reg & PIC32_UART_STA_PERR)\r\nport->icount.parity++;\r\nif (sta_reg & PIC32_UART_STA_FERR)\r\nport->icount.frame++;\r\nsta_reg &= port->read_status_mask;\r\nif (sta_reg & PIC32_UART_STA_FERR)\r\nflag = TTY_FRAME;\r\nif (sta_reg & PIC32_UART_STA_PERR)\r\nflag = TTY_PARITY;\r\n}\r\nif (uart_handle_sysrq_char(port, c))\r\ncontinue;\r\nif ((sta_reg & port->ignore_status_mask) == 0)\r\ntty_insert_flip_char(tty, c, flag);\r\n} while (--max_count);\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic void pic32_uart_do_tx(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int max_count = PIC32_UART_TX_FIFO_DEPTH;\r\nif (port->x_char) {\r\npic32_uart_writel(sport, PIC32_UART_TX, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_tx_stopped(port)) {\r\npic32_uart_stop_tx(port);\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit))\r\ngoto txq_empty;\r\nwhile (!(PIC32_UART_STA_UTXBF &\r\npic32_uart_readl(sport, PIC32_UART_STA))) {\r\nunsigned int c = xmit->buf[xmit->tail];\r\npic32_uart_writel(sport, PIC32_UART_TX, c);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\nif (--max_count == 0)\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\ngoto txq_empty;\r\nreturn;\r\ntxq_empty:\r\npic32_uart_irqtxen(sport, 0);\r\n}\r\nstatic irqreturn_t pic32_uart_rx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\npic32_uart_do_rx(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pic32_uart_tx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\npic32_uart_do_tx(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pic32_uart_fault_interrupt(int irq, void *dev_id)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pic32_uart_en_and_unmask(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_STA),\r\nPIC32_UART_STA_UTXEN | PIC32_UART_STA_URXEN);\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\r\nPIC32_UART_MODE_ON);\r\n}\r\nstatic void pic32_uart_dsbl_and_mask(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\npic32_wait_deplete_txbuf(sport);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\r\nPIC32_UART_STA_UTXEN | PIC32_UART_STA_URXEN);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_ON);\r\n}\r\nstatic int pic32_uart_startup(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nu32 dflt_baud = (port->uartclk / PIC32_UART_DFLT_BRATE / 16) - 1;\r\nunsigned long flags;\r\nint ret;\r\nlocal_irq_save(flags);\r\nret = pic32_enable_clock(sport);\r\nif (ret) {\r\nlocal_irq_restore(flags);\r\ngoto out_done;\r\n}\r\npic32_uart_writel(sport, PIC32_UART_MODE, 0);\r\npic32_uart_writel(sport, PIC32_UART_STA, 0);\r\npic32_uart_dsbl_and_mask(port);\r\npic32_uart_writel(sport, PIC32_UART_BRG, dflt_baud);\r\nlocal_irq_restore(flags);\r\ntx_irq_enabled(sport) = 0;\r\nsport->irq_fault_name = kasprintf(GFP_KERNEL, "%s%d-fault",\r\npic32_uart_type(port),\r\nsport->idx);\r\nif (!sport->irq_fault_name) {\r\ndev_err(port->dev, "%s: kasprintf err!", __func__);\r\nret = -ENOMEM;\r\ngoto out_done;\r\n}\r\nirq_set_status_flags(sport->irq_fault, IRQ_NOAUTOEN);\r\nret = request_irq(sport->irq_fault, pic32_uart_fault_interrupt,\r\nsport->irqflags_fault, sport->irq_fault_name, port);\r\nif (ret) {\r\ndev_err(port->dev, "%s: request irq(%d) err! ret:%d name:%s\n",\r\n__func__, sport->irq_fault, ret,\r\npic32_uart_type(port));\r\ngoto out_f;\r\n}\r\nsport->irq_rx_name = kasprintf(GFP_KERNEL, "%s%d-rx",\r\npic32_uart_type(port),\r\nsport->idx);\r\nif (!sport->irq_rx_name) {\r\ndev_err(port->dev, "%s: kasprintf err!", __func__);\r\nret = -ENOMEM;\r\ngoto out_f;\r\n}\r\nirq_set_status_flags(sport->irq_rx, IRQ_NOAUTOEN);\r\nret = request_irq(sport->irq_rx, pic32_uart_rx_interrupt,\r\nsport->irqflags_rx, sport->irq_rx_name, port);\r\nif (ret) {\r\ndev_err(port->dev, "%s: request irq(%d) err! ret:%d name:%s\n",\r\n__func__, sport->irq_rx, ret,\r\npic32_uart_type(port));\r\ngoto out_r;\r\n}\r\nsport->irq_tx_name = kasprintf(GFP_KERNEL, "%s%d-tx",\r\npic32_uart_type(port),\r\nsport->idx);\r\nif (!sport->irq_tx_name) {\r\ndev_err(port->dev, "%s: kasprintf err!", __func__);\r\nret = -ENOMEM;\r\ngoto out_r;\r\n}\r\nirq_set_status_flags(sport->irq_tx, IRQ_NOAUTOEN);\r\nret = request_irq(sport->irq_tx, pic32_uart_tx_interrupt,\r\nsport->irqflags_tx, sport->irq_tx_name, port);\r\nif (ret) {\r\ndev_err(port->dev, "%s: request irq(%d) err! ret:%d name:%s\n",\r\n__func__, sport->irq_tx, ret,\r\npic32_uart_type(port));\r\ngoto out_t;\r\n}\r\nlocal_irq_save(flags);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\r\nPIC32_UART_STA_URXISEL1 | PIC32_UART_STA_URXISEL0);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_STA),\r\nPIC32_UART_STA_UTXISEL1);\r\npic32_uart_en_and_unmask(port);\r\nenable_irq(sport->irq_rx);\r\nreturn 0;\r\nout_t:\r\nkfree(sport->irq_tx_name);\r\nfree_irq(sport->irq_tx, sport);\r\nout_r:\r\nkfree(sport->irq_rx_name);\r\nfree_irq(sport->irq_rx, sport);\r\nout_f:\r\nkfree(sport->irq_fault_name);\r\nfree_irq(sport->irq_fault, sport);\r\nout_done:\r\nreturn ret;\r\n}\r\nstatic void pic32_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\npic32_uart_dsbl_and_mask(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\npic32_disable_clock(sport);\r\nfree_irq(sport->irq_fault, port);\r\nfree_irq(sport->irq_tx, port);\r\nfree_irq(sport->irq_rx, port);\r\n}\r\nstatic void pic32_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nunsigned int baud;\r\nunsigned int quot;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\npic32_uart_dsbl_and_mask(port);\r\nif (new->c_cflag & CSTOPB)\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\r\nPIC32_UART_MODE_STSEL);\r\nelse\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_STSEL);\r\nif (new->c_cflag & PARENB) {\r\nif (new->c_cflag & PARODD) {\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\r\nPIC32_UART_MODE_PDSEL1);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_PDSEL0);\r\n} else {\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\r\nPIC32_UART_MODE_PDSEL0);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_PDSEL1);\r\n}\r\n} else {\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_PDSEL1 |\r\nPIC32_UART_MODE_PDSEL0);\r\n}\r\nif ((new->c_cflag & CRTSCTS) && sport->hw_flow_ctrl) {\r\npic32_uart_writel(sport, PIC32_SET(PIC32_UART_MODE),\r\nPIC32_UART_MODE_UEN1);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_UEN0);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_RTSMD);\r\n} else {\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_UEN1);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_UEN0);\r\npic32_uart_writel(sport, PIC32_CLR(PIC32_UART_MODE),\r\nPIC32_UART_MODE_RTSMD);\r\n}\r\nnew->c_cflag |= CS8;\r\nnew->c_cflag &= ~CMSPAR;\r\nbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\r\nquot = uart_get_divisor(port, baud) - 1;\r\npic32_uart_writel(sport, PIC32_UART_BRG, quot);\r\nuart_update_timeout(port, new->c_cflag, baud);\r\nif (tty_termios_baud_rate(new))\r\ntty_termios_encode_baud_rate(new, baud, baud);\r\npic32_uart_en_and_unmask(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int pic32_uart_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *res_mem;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!res_mem))\r\nreturn -EINVAL;\r\nif (!request_mem_region(port->mapbase, resource_size(res_mem),\r\n"pic32_uart_mem"))\r\nreturn -EBUSY;\r\nport->membase = devm_ioremap_nocache(port->dev, port->mapbase,\r\nresource_size(res_mem));\r\nif (!port->membase) {\r\ndev_err(port->dev, "Unable to map registers\n");\r\nrelease_mem_region(port->mapbase, resource_size(res_mem));\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pic32_uart_release_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *res_mem;\r\nunsigned int res_size;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!res_mem))\r\nreturn;\r\nres_size = resource_size(res_mem);\r\nrelease_mem_region(port->mapbase, res_size);\r\n}\r\nstatic void pic32_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nif (pic32_uart_request_port(port))\r\nreturn;\r\nport->type = PORT_PIC32;\r\n}\r\n}\r\nstatic int pic32_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *serinfo)\r\n{\r\nif (port->type != PORT_PIC32)\r\nreturn -EINVAL;\r\nif (port->irq != serinfo->irq)\r\nreturn -EINVAL;\r\nif (port->iotype != serinfo->io_type)\r\nreturn -EINVAL;\r\nif (port->mapbase != (unsigned long)serinfo->iomem_base)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void pic32_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nif (!(pic32_uart_readl(sport, PIC32_UART_MODE) & PIC32_UART_MODE_ON))\r\nreturn;\r\nif (!(pic32_uart_readl(sport, PIC32_UART_STA) & PIC32_UART_STA_UTXEN))\r\nreturn;\r\npic32_wait_deplete_txbuf(sport);\r\npic32_uart_writel(sport, PIC32_UART_TX, ch & 0xff);\r\n}\r\nstatic void pic32_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct pic32_sport *sport = pic32_sports[co->index];\r\nstruct uart_port *port = pic32_get_port(sport);\r\nuart_console_write(port, s, count, pic32_console_putchar);\r\n}\r\nstatic int pic32_console_setup(struct console *co, char *options)\r\n{\r\nstruct pic32_sport *sport;\r\nstruct uart_port *port = NULL;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret = 0;\r\nif (unlikely(co->index < 0 || co->index >= PIC32_MAX_UARTS))\r\nreturn -ENODEV;\r\nsport = pic32_sports[co->index];\r\nif (!sport)\r\nreturn -ENODEV;\r\nport = pic32_get_port(sport);\r\nret = pic32_enable_clock(sport);\r\nif (ret)\r\nreturn ret;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init pic32_console_init(void)\r\n{\r\nregister_console(&pic32_console);\r\nreturn 0;\r\n}\r\nstatic inline bool is_pic32_console_port(struct uart_port *port)\r\n{\r\nreturn port->cons && port->cons->index == port->line;\r\n}\r\nstatic int __init pic32_late_console_init(void)\r\n{\r\nif (!(pic32_console.flags & CON_ENABLED))\r\nregister_console(&pic32_console);\r\nreturn 0;\r\n}\r\nstatic int pic32_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pic32_sport *sport;\r\nint uart_idx = 0;\r\nstruct resource *res_mem;\r\nstruct uart_port *port;\r\nint ret;\r\nuart_idx = of_alias_get_id(np, "serial");\r\nif (uart_idx < 0 || uart_idx >= PIC32_MAX_UARTS)\r\nreturn -EINVAL;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_mem)\r\nreturn -EINVAL;\r\nsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\r\nif (!sport)\r\nreturn -ENOMEM;\r\nsport->idx = uart_idx;\r\nsport->irq_fault = irq_of_parse_and_map(np, 0);\r\nsport->irqflags_fault = IRQF_NO_THREAD;\r\nsport->irq_rx = irq_of_parse_and_map(np, 1);\r\nsport->irqflags_rx = IRQF_NO_THREAD;\r\nsport->irq_tx = irq_of_parse_and_map(np, 2);\r\nsport->irqflags_tx = IRQF_NO_THREAD;\r\nsport->clk = devm_clk_get(&pdev->dev, NULL);\r\nsport->cts_gpio = -EINVAL;\r\nsport->dev = &pdev->dev;\r\nsport->hw_flow_ctrl = false;\r\nsport->cts_gpio = of_get_named_gpio(np, "cts-gpios", 0);\r\nif (gpio_is_valid(sport->cts_gpio)) {\r\nsport->hw_flow_ctrl = true;\r\nret = devm_gpio_request(sport->dev,\r\nsport->cts_gpio, "CTS");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"error requesting CTS GPIO\n");\r\ngoto err;\r\n}\r\nret = gpio_direction_input(sport->cts_gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "error setting CTS GPIO\n");\r\ngoto err;\r\n}\r\n}\r\npic32_sports[uart_idx] = sport;\r\nport = &sport->port;\r\nmemset(port, 0, sizeof(*port));\r\nport->iotype = UPIO_MEM;\r\nport->mapbase = res_mem->start;\r\nport->ops = &pic32_uart_ops;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->dev = &pdev->dev;\r\nport->fifosize = PIC32_UART_TX_FIFO_DEPTH;\r\nport->uartclk = clk_get_rate(sport->clk);\r\nport->line = uart_idx;\r\nret = uart_add_one_port(&pic32_uart_driver, port);\r\nif (ret) {\r\nport->membase = NULL;\r\ndev_err(port->dev, "%s: uart add port error!\n", __func__);\r\ngoto err;\r\n}\r\n#ifdef CONFIG_SERIAL_PIC32_CONSOLE\r\nif (is_pic32_console_port(port) &&\r\n(pic32_console.flags & CON_ENABLED)) {\r\npic32_disable_clock(sport);\r\n}\r\n#endif\r\nplatform_set_drvdata(pdev, port);\r\ndev_info(&pdev->dev, "%s: uart(%d) driver initialized.\n",\r\n__func__, uart_idx);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int pic32_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct pic32_sport *sport = to_pic32_sport(port);\r\nuart_remove_one_port(&pic32_uart_driver, port);\r\npic32_disable_clock(sport);\r\nplatform_set_drvdata(pdev, NULL);\r\npic32_sports[sport->idx] = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init pic32_uart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&pic32_uart_driver);\r\nif (ret) {\r\npr_err("failed to register %s:%d\n",\r\npic32_uart_driver.driver_name, ret);\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&pic32_uart_platform_driver);\r\nif (ret) {\r\npr_err("fail to register pic32 uart\n");\r\nuart_unregister_driver(&pic32_uart_driver);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit pic32_uart_exit(void)\r\n{\r\n#ifdef CONFIG_SERIAL_PIC32_CONSOLE\r\nunregister_console(&pic32_console);\r\n#endif\r\nplatform_driver_unregister(&pic32_uart_platform_driver);\r\nuart_unregister_driver(&pic32_uart_driver);\r\n}
