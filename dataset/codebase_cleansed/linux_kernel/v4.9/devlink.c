static struct net *devlink_net(const struct devlink *devlink)\r\n{\r\nreturn read_pnet(&devlink->_net);\r\n}\r\nstatic void devlink_net_set(struct devlink *devlink, struct net *net)\r\n{\r\nwrite_pnet(&devlink->_net, net);\r\n}\r\nstatic struct devlink *devlink_get_from_attrs(struct net *net,\r\nstruct nlattr **attrs)\r\n{\r\nstruct devlink *devlink;\r\nchar *busname;\r\nchar *devname;\r\nif (!attrs[DEVLINK_ATTR_BUS_NAME] || !attrs[DEVLINK_ATTR_DEV_NAME])\r\nreturn ERR_PTR(-EINVAL);\r\nbusname = nla_data(attrs[DEVLINK_ATTR_BUS_NAME]);\r\ndevname = nla_data(attrs[DEVLINK_ATTR_DEV_NAME]);\r\nlist_for_each_entry(devlink, &devlink_list, list) {\r\nif (strcmp(devlink->dev->bus->name, busname) == 0 &&\r\nstrcmp(dev_name(devlink->dev), devname) == 0 &&\r\nnet_eq(devlink_net(devlink), net))\r\nreturn devlink;\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic struct devlink *devlink_get_from_info(struct genl_info *info)\r\n{\r\nreturn devlink_get_from_attrs(genl_info_net(info), info->attrs);\r\n}\r\nstatic struct devlink_port *devlink_port_get_by_index(struct devlink *devlink,\r\nint port_index)\r\n{\r\nstruct devlink_port *devlink_port;\r\nlist_for_each_entry(devlink_port, &devlink->port_list, list) {\r\nif (devlink_port->index == port_index)\r\nreturn devlink_port;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool devlink_port_index_exists(struct devlink *devlink, int port_index)\r\n{\r\nreturn devlink_port_get_by_index(devlink, port_index);\r\n}\r\nstatic struct devlink_port *devlink_port_get_from_attrs(struct devlink *devlink,\r\nstruct nlattr **attrs)\r\n{\r\nif (attrs[DEVLINK_ATTR_PORT_INDEX]) {\r\nu32 port_index = nla_get_u32(attrs[DEVLINK_ATTR_PORT_INDEX]);\r\nstruct devlink_port *devlink_port;\r\ndevlink_port = devlink_port_get_by_index(devlink, port_index);\r\nif (!devlink_port)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn devlink_port;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic struct devlink_port *devlink_port_get_from_info(struct devlink *devlink,\r\nstruct genl_info *info)\r\n{\r\nreturn devlink_port_get_from_attrs(devlink, info->attrs);\r\n}\r\nstatic u16 devlink_sb_pool_count(struct devlink_sb *devlink_sb)\r\n{\r\nreturn devlink_sb->ingress_pools_count + devlink_sb->egress_pools_count;\r\n}\r\nstatic struct devlink_sb *devlink_sb_get_by_index(struct devlink *devlink,\r\nunsigned int sb_index)\r\n{\r\nstruct devlink_sb *devlink_sb;\r\nlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\r\nif (devlink_sb->index == sb_index)\r\nreturn devlink_sb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool devlink_sb_index_exists(struct devlink *devlink,\r\nunsigned int sb_index)\r\n{\r\nreturn devlink_sb_get_by_index(devlink, sb_index);\r\n}\r\nstatic struct devlink_sb *devlink_sb_get_from_attrs(struct devlink *devlink,\r\nstruct nlattr **attrs)\r\n{\r\nif (attrs[DEVLINK_ATTR_SB_INDEX]) {\r\nu32 sb_index = nla_get_u32(attrs[DEVLINK_ATTR_SB_INDEX]);\r\nstruct devlink_sb *devlink_sb;\r\ndevlink_sb = devlink_sb_get_by_index(devlink, sb_index);\r\nif (!devlink_sb)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn devlink_sb;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic struct devlink_sb *devlink_sb_get_from_info(struct devlink *devlink,\r\nstruct genl_info *info)\r\n{\r\nreturn devlink_sb_get_from_attrs(devlink, info->attrs);\r\n}\r\nstatic int devlink_sb_pool_index_get_from_attrs(struct devlink_sb *devlink_sb,\r\nstruct nlattr **attrs,\r\nu16 *p_pool_index)\r\n{\r\nu16 val;\r\nif (!attrs[DEVLINK_ATTR_SB_POOL_INDEX])\r\nreturn -EINVAL;\r\nval = nla_get_u16(attrs[DEVLINK_ATTR_SB_POOL_INDEX]);\r\nif (val >= devlink_sb_pool_count(devlink_sb))\r\nreturn -EINVAL;\r\n*p_pool_index = val;\r\nreturn 0;\r\n}\r\nstatic int devlink_sb_pool_index_get_from_info(struct devlink_sb *devlink_sb,\r\nstruct genl_info *info,\r\nu16 *p_pool_index)\r\n{\r\nreturn devlink_sb_pool_index_get_from_attrs(devlink_sb, info->attrs,\r\np_pool_index);\r\n}\r\nstatic int\r\ndevlink_sb_pool_type_get_from_attrs(struct nlattr **attrs,\r\nenum devlink_sb_pool_type *p_pool_type)\r\n{\r\nu8 val;\r\nif (!attrs[DEVLINK_ATTR_SB_POOL_TYPE])\r\nreturn -EINVAL;\r\nval = nla_get_u8(attrs[DEVLINK_ATTR_SB_POOL_TYPE]);\r\nif (val != DEVLINK_SB_POOL_TYPE_INGRESS &&\r\nval != DEVLINK_SB_POOL_TYPE_EGRESS)\r\nreturn -EINVAL;\r\n*p_pool_type = val;\r\nreturn 0;\r\n}\r\nstatic int\r\ndevlink_sb_pool_type_get_from_info(struct genl_info *info,\r\nenum devlink_sb_pool_type *p_pool_type)\r\n{\r\nreturn devlink_sb_pool_type_get_from_attrs(info->attrs, p_pool_type);\r\n}\r\nstatic int\r\ndevlink_sb_th_type_get_from_attrs(struct nlattr **attrs,\r\nenum devlink_sb_threshold_type *p_th_type)\r\n{\r\nu8 val;\r\nif (!attrs[DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE])\r\nreturn -EINVAL;\r\nval = nla_get_u8(attrs[DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE]);\r\nif (val != DEVLINK_SB_THRESHOLD_TYPE_STATIC &&\r\nval != DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC)\r\nreturn -EINVAL;\r\n*p_th_type = val;\r\nreturn 0;\r\n}\r\nstatic int\r\ndevlink_sb_th_type_get_from_info(struct genl_info *info,\r\nenum devlink_sb_threshold_type *p_th_type)\r\n{\r\nreturn devlink_sb_th_type_get_from_attrs(info->attrs, p_th_type);\r\n}\r\nstatic int\r\ndevlink_sb_tc_index_get_from_attrs(struct devlink_sb *devlink_sb,\r\nstruct nlattr **attrs,\r\nenum devlink_sb_pool_type pool_type,\r\nu16 *p_tc_index)\r\n{\r\nu16 val;\r\nif (!attrs[DEVLINK_ATTR_SB_TC_INDEX])\r\nreturn -EINVAL;\r\nval = nla_get_u16(attrs[DEVLINK_ATTR_SB_TC_INDEX]);\r\nif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS &&\r\nval >= devlink_sb->ingress_tc_count)\r\nreturn -EINVAL;\r\nif (pool_type == DEVLINK_SB_POOL_TYPE_EGRESS &&\r\nval >= devlink_sb->egress_tc_count)\r\nreturn -EINVAL;\r\n*p_tc_index = val;\r\nreturn 0;\r\n}\r\nstatic int\r\ndevlink_sb_tc_index_get_from_info(struct devlink_sb *devlink_sb,\r\nstruct genl_info *info,\r\nenum devlink_sb_pool_type pool_type,\r\nu16 *p_tc_index)\r\n{\r\nreturn devlink_sb_tc_index_get_from_attrs(devlink_sb, info->attrs,\r\npool_type, p_tc_index);\r\n}\r\nstatic int devlink_nl_pre_doit(const struct genl_ops *ops,\r\nstruct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct devlink *devlink;\r\nmutex_lock(&devlink_mutex);\r\ndevlink = devlink_get_from_info(info);\r\nif (IS_ERR(devlink)) {\r\nmutex_unlock(&devlink_mutex);\r\nreturn PTR_ERR(devlink);\r\n}\r\nif (ops->internal_flags & DEVLINK_NL_FLAG_NEED_DEVLINK) {\r\ninfo->user_ptr[0] = devlink;\r\n} else if (ops->internal_flags & DEVLINK_NL_FLAG_NEED_PORT) {\r\nstruct devlink_port *devlink_port;\r\nmutex_lock(&devlink_port_mutex);\r\ndevlink_port = devlink_port_get_from_info(devlink, info);\r\nif (IS_ERR(devlink_port)) {\r\nmutex_unlock(&devlink_port_mutex);\r\nmutex_unlock(&devlink_mutex);\r\nreturn PTR_ERR(devlink_port);\r\n}\r\ninfo->user_ptr[0] = devlink_port;\r\n}\r\nif (ops->internal_flags & DEVLINK_NL_FLAG_LOCK_PORTS) {\r\nmutex_lock(&devlink_port_mutex);\r\n}\r\nif (ops->internal_flags & DEVLINK_NL_FLAG_NEED_SB) {\r\nstruct devlink_sb *devlink_sb;\r\ndevlink_sb = devlink_sb_get_from_info(devlink, info);\r\nif (IS_ERR(devlink_sb)) {\r\nif (ops->internal_flags & DEVLINK_NL_FLAG_NEED_PORT)\r\nmutex_unlock(&devlink_port_mutex);\r\nmutex_unlock(&devlink_mutex);\r\nreturn PTR_ERR(devlink_sb);\r\n}\r\ninfo->user_ptr[1] = devlink_sb;\r\n}\r\nreturn 0;\r\n}\r\nstatic void devlink_nl_post_doit(const struct genl_ops *ops,\r\nstruct sk_buff *skb, struct genl_info *info)\r\n{\r\nif (ops->internal_flags & DEVLINK_NL_FLAG_NEED_PORT ||\r\nops->internal_flags & DEVLINK_NL_FLAG_LOCK_PORTS)\r\nmutex_unlock(&devlink_port_mutex);\r\nmutex_unlock(&devlink_mutex);\r\n}\r\nstatic int devlink_nl_put_handle(struct sk_buff *msg, struct devlink *devlink)\r\n{\r\nif (nla_put_string(msg, DEVLINK_ATTR_BUS_NAME, devlink->dev->bus->name))\r\nreturn -EMSGSIZE;\r\nif (nla_put_string(msg, DEVLINK_ATTR_DEV_NAME, dev_name(devlink->dev)))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int devlink_nl_fill(struct sk_buff *msg, struct devlink *devlink,\r\nenum devlink_command cmd, u32 portid,\r\nu32 seq, int flags)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (devlink_nl_put_handle(msg, devlink))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void devlink_notify(struct devlink *devlink, enum devlink_command cmd)\r\n{\r\nstruct sk_buff *msg;\r\nint err;\r\nWARN_ON(cmd != DEVLINK_CMD_NEW && cmd != DEVLINK_CMD_DEL);\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn;\r\nerr = devlink_nl_fill(msg, devlink, cmd, 0, 0, 0);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn;\r\n}\r\ngenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\r\nmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\r\n}\r\nstatic int devlink_nl_port_fill(struct sk_buff *msg, struct devlink *devlink,\r\nstruct devlink_port *devlink_port,\r\nenum devlink_command cmd, u32 portid,\r\nu32 seq, int flags)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (devlink_nl_put_handle(msg, devlink))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX, devlink_port->index))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_PORT_TYPE, devlink_port->type))\r\ngoto nla_put_failure;\r\nif (devlink_port->desired_type != DEVLINK_PORT_TYPE_NOTSET &&\r\nnla_put_u16(msg, DEVLINK_ATTR_PORT_DESIRED_TYPE,\r\ndevlink_port->desired_type))\r\ngoto nla_put_failure;\r\nif (devlink_port->type == DEVLINK_PORT_TYPE_ETH) {\r\nstruct net_device *netdev = devlink_port->type_dev;\r\nif (netdev &&\r\n(nla_put_u32(msg, DEVLINK_ATTR_PORT_NETDEV_IFINDEX,\r\nnetdev->ifindex) ||\r\nnla_put_string(msg, DEVLINK_ATTR_PORT_NETDEV_NAME,\r\nnetdev->name)))\r\ngoto nla_put_failure;\r\n}\r\nif (devlink_port->type == DEVLINK_PORT_TYPE_IB) {\r\nstruct ib_device *ibdev = devlink_port->type_dev;\r\nif (ibdev &&\r\nnla_put_string(msg, DEVLINK_ATTR_PORT_IBDEV_NAME,\r\nibdev->name))\r\ngoto nla_put_failure;\r\n}\r\nif (devlink_port->split &&\r\nnla_put_u32(msg, DEVLINK_ATTR_PORT_SPLIT_GROUP,\r\ndevlink_port->split_group))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void devlink_port_notify(struct devlink_port *devlink_port,\r\nenum devlink_command cmd)\r\n{\r\nstruct devlink *devlink = devlink_port->devlink;\r\nstruct sk_buff *msg;\r\nint err;\r\nif (!devlink_port->registered)\r\nreturn;\r\nWARN_ON(cmd != DEVLINK_CMD_PORT_NEW && cmd != DEVLINK_CMD_PORT_DEL);\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn;\r\nerr = devlink_nl_port_fill(msg, devlink, devlink_port, cmd, 0, 0, 0);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn;\r\n}\r\ngenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\r\nmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\r\n}\r\nstatic int devlink_nl_cmd_get_doit(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nstruct sk_buff *msg;\r\nint err;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nerr = devlink_nl_fill(msg, devlink, DEVLINK_CMD_NEW,\r\ninfo->snd_portid, info->snd_seq, 0);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn err;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int devlink_nl_cmd_get_dumpit(struct sk_buff *msg,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct devlink *devlink;\r\nint start = cb->args[0];\r\nint idx = 0;\r\nint err;\r\nmutex_lock(&devlink_mutex);\r\nlist_for_each_entry(devlink, &devlink_list, list) {\r\nif (!net_eq(devlink_net(devlink), sock_net(msg->sk)))\r\ncontinue;\r\nif (idx < start) {\r\nidx++;\r\ncontinue;\r\n}\r\nerr = devlink_nl_fill(msg, devlink, DEVLINK_CMD_NEW,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI);\r\nif (err)\r\ngoto out;\r\nidx++;\r\n}\r\nout:\r\nmutex_unlock(&devlink_mutex);\r\ncb->args[0] = idx;\r\nreturn msg->len;\r\n}\r\nstatic int devlink_nl_cmd_port_get_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink_port *devlink_port = info->user_ptr[0];\r\nstruct devlink *devlink = devlink_port->devlink;\r\nstruct sk_buff *msg;\r\nint err;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nerr = devlink_nl_port_fill(msg, devlink, devlink_port,\r\nDEVLINK_CMD_PORT_NEW,\r\ninfo->snd_portid, info->snd_seq, 0);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn err;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int devlink_nl_cmd_port_get_dumpit(struct sk_buff *msg,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct devlink *devlink;\r\nstruct devlink_port *devlink_port;\r\nint start = cb->args[0];\r\nint idx = 0;\r\nint err;\r\nmutex_lock(&devlink_mutex);\r\nmutex_lock(&devlink_port_mutex);\r\nlist_for_each_entry(devlink, &devlink_list, list) {\r\nif (!net_eq(devlink_net(devlink), sock_net(msg->sk)))\r\ncontinue;\r\nlist_for_each_entry(devlink_port, &devlink->port_list, list) {\r\nif (idx < start) {\r\nidx++;\r\ncontinue;\r\n}\r\nerr = devlink_nl_port_fill(msg, devlink, devlink_port,\r\nDEVLINK_CMD_NEW,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNLM_F_MULTI);\r\nif (err)\r\ngoto out;\r\nidx++;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&devlink_port_mutex);\r\nmutex_unlock(&devlink_mutex);\r\ncb->args[0] = idx;\r\nreturn msg->len;\r\n}\r\nstatic int devlink_port_type_set(struct devlink *devlink,\r\nstruct devlink_port *devlink_port,\r\nenum devlink_port_type port_type)\r\n{\r\nint err;\r\nif (devlink->ops && devlink->ops->port_type_set) {\r\nif (port_type == DEVLINK_PORT_TYPE_NOTSET)\r\nreturn -EINVAL;\r\nerr = devlink->ops->port_type_set(devlink_port, port_type);\r\nif (err)\r\nreturn err;\r\ndevlink_port->desired_type = port_type;\r\ndevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_NEW);\r\nreturn 0;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int devlink_nl_cmd_port_set_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink_port *devlink_port = info->user_ptr[0];\r\nstruct devlink *devlink = devlink_port->devlink;\r\nint err;\r\nif (info->attrs[DEVLINK_ATTR_PORT_TYPE]) {\r\nenum devlink_port_type port_type;\r\nport_type = nla_get_u16(info->attrs[DEVLINK_ATTR_PORT_TYPE]);\r\nerr = devlink_port_type_set(devlink, devlink_port, port_type);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int devlink_port_split(struct devlink *devlink,\r\nu32 port_index, u32 count)\r\n{\r\nif (devlink->ops && devlink->ops->port_split)\r\nreturn devlink->ops->port_split(devlink, port_index, count);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int devlink_nl_cmd_port_split_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nu32 port_index;\r\nu32 count;\r\nif (!info->attrs[DEVLINK_ATTR_PORT_INDEX] ||\r\n!info->attrs[DEVLINK_ATTR_PORT_SPLIT_COUNT])\r\nreturn -EINVAL;\r\nport_index = nla_get_u32(info->attrs[DEVLINK_ATTR_PORT_INDEX]);\r\ncount = nla_get_u32(info->attrs[DEVLINK_ATTR_PORT_SPLIT_COUNT]);\r\nreturn devlink_port_split(devlink, port_index, count);\r\n}\r\nstatic int devlink_port_unsplit(struct devlink *devlink, u32 port_index)\r\n{\r\nif (devlink->ops && devlink->ops->port_unsplit)\r\nreturn devlink->ops->port_unsplit(devlink, port_index);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int devlink_nl_cmd_port_unsplit_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nu32 port_index;\r\nif (!info->attrs[DEVLINK_ATTR_PORT_INDEX])\r\nreturn -EINVAL;\r\nport_index = nla_get_u32(info->attrs[DEVLINK_ATTR_PORT_INDEX]);\r\nreturn devlink_port_unsplit(devlink, port_index);\r\n}\r\nstatic int devlink_nl_sb_fill(struct sk_buff *msg, struct devlink *devlink,\r\nstruct devlink_sb *devlink_sb,\r\nenum devlink_command cmd, u32 portid,\r\nu32 seq, int flags)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (devlink_nl_put_handle(msg, devlink))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_INDEX, devlink_sb->index))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_SIZE, devlink_sb->size))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_SB_INGRESS_POOL_COUNT,\r\ndevlink_sb->ingress_pools_count))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_SB_EGRESS_POOL_COUNT,\r\ndevlink_sb->egress_pools_count))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_SB_INGRESS_TC_COUNT,\r\ndevlink_sb->ingress_tc_count))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_SB_EGRESS_TC_COUNT,\r\ndevlink_sb->egress_tc_count))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int devlink_nl_cmd_sb_get_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nstruct sk_buff *msg;\r\nint err;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nerr = devlink_nl_sb_fill(msg, devlink, devlink_sb,\r\nDEVLINK_CMD_SB_NEW,\r\ninfo->snd_portid, info->snd_seq, 0);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn err;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int devlink_nl_cmd_sb_get_dumpit(struct sk_buff *msg,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct devlink *devlink;\r\nstruct devlink_sb *devlink_sb;\r\nint start = cb->args[0];\r\nint idx = 0;\r\nint err;\r\nmutex_lock(&devlink_mutex);\r\nlist_for_each_entry(devlink, &devlink_list, list) {\r\nif (!net_eq(devlink_net(devlink), sock_net(msg->sk)))\r\ncontinue;\r\nlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\r\nif (idx < start) {\r\nidx++;\r\ncontinue;\r\n}\r\nerr = devlink_nl_sb_fill(msg, devlink, devlink_sb,\r\nDEVLINK_CMD_SB_NEW,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNLM_F_MULTI);\r\nif (err)\r\ngoto out;\r\nidx++;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&devlink_mutex);\r\ncb->args[0] = idx;\r\nreturn msg->len;\r\n}\r\nstatic int devlink_nl_sb_pool_fill(struct sk_buff *msg, struct devlink *devlink,\r\nstruct devlink_sb *devlink_sb,\r\nu16 pool_index, enum devlink_command cmd,\r\nu32 portid, u32 seq, int flags)\r\n{\r\nstruct devlink_sb_pool_info pool_info;\r\nvoid *hdr;\r\nint err;\r\nerr = devlink->ops->sb_pool_get(devlink, devlink_sb->index,\r\npool_index, &pool_info);\r\nif (err)\r\nreturn err;\r\nhdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (devlink_nl_put_handle(msg, devlink))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_INDEX, devlink_sb->index))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_SB_POOL_INDEX, pool_index))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(msg, DEVLINK_ATTR_SB_POOL_TYPE, pool_info.pool_type))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_POOL_SIZE, pool_info.size))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(msg, DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE,\r\npool_info.threshold_type))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int devlink_nl_cmd_sb_pool_get_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nstruct sk_buff *msg;\r\nu16 pool_index;\r\nint err;\r\nerr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\r\n&pool_index);\r\nif (err)\r\nreturn err;\r\nif (!devlink->ops || !devlink->ops->sb_pool_get)\r\nreturn -EOPNOTSUPP;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nerr = devlink_nl_sb_pool_fill(msg, devlink, devlink_sb, pool_index,\r\nDEVLINK_CMD_SB_POOL_NEW,\r\ninfo->snd_portid, info->snd_seq, 0);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn err;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int __sb_pool_get_dumpit(struct sk_buff *msg, int start, int *p_idx,\r\nstruct devlink *devlink,\r\nstruct devlink_sb *devlink_sb,\r\nu32 portid, u32 seq)\r\n{\r\nu16 pool_count = devlink_sb_pool_count(devlink_sb);\r\nu16 pool_index;\r\nint err;\r\nfor (pool_index = 0; pool_index < pool_count; pool_index++) {\r\nif (*p_idx < start) {\r\n(*p_idx)++;\r\ncontinue;\r\n}\r\nerr = devlink_nl_sb_pool_fill(msg, devlink,\r\ndevlink_sb,\r\npool_index,\r\nDEVLINK_CMD_SB_POOL_NEW,\r\nportid, seq, NLM_F_MULTI);\r\nif (err)\r\nreturn err;\r\n(*p_idx)++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int devlink_nl_cmd_sb_pool_get_dumpit(struct sk_buff *msg,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct devlink *devlink;\r\nstruct devlink_sb *devlink_sb;\r\nint start = cb->args[0];\r\nint idx = 0;\r\nint err;\r\nmutex_lock(&devlink_mutex);\r\nlist_for_each_entry(devlink, &devlink_list, list) {\r\nif (!net_eq(devlink_net(devlink), sock_net(msg->sk)) ||\r\n!devlink->ops || !devlink->ops->sb_pool_get)\r\ncontinue;\r\nlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\r\nerr = __sb_pool_get_dumpit(msg, start, &idx, devlink,\r\ndevlink_sb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq);\r\nif (err && err != -EOPNOTSUPP)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&devlink_mutex);\r\ncb->args[0] = idx;\r\nreturn msg->len;\r\n}\r\nstatic int devlink_sb_pool_set(struct devlink *devlink, unsigned int sb_index,\r\nu16 pool_index, u32 size,\r\nenum devlink_sb_threshold_type threshold_type)\r\n{\r\nconst struct devlink_ops *ops = devlink->ops;\r\nif (ops && ops->sb_pool_set)\r\nreturn ops->sb_pool_set(devlink, sb_index, pool_index,\r\nsize, threshold_type);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int devlink_nl_cmd_sb_pool_set_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nenum devlink_sb_threshold_type threshold_type;\r\nu16 pool_index;\r\nu32 size;\r\nint err;\r\nerr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\r\n&pool_index);\r\nif (err)\r\nreturn err;\r\nerr = devlink_sb_th_type_get_from_info(info, &threshold_type);\r\nif (err)\r\nreturn err;\r\nif (!info->attrs[DEVLINK_ATTR_SB_POOL_SIZE])\r\nreturn -EINVAL;\r\nsize = nla_get_u32(info->attrs[DEVLINK_ATTR_SB_POOL_SIZE]);\r\nreturn devlink_sb_pool_set(devlink, devlink_sb->index,\r\npool_index, size, threshold_type);\r\n}\r\nstatic int devlink_nl_sb_port_pool_fill(struct sk_buff *msg,\r\nstruct devlink *devlink,\r\nstruct devlink_port *devlink_port,\r\nstruct devlink_sb *devlink_sb,\r\nu16 pool_index,\r\nenum devlink_command cmd,\r\nu32 portid, u32 seq, int flags)\r\n{\r\nconst struct devlink_ops *ops = devlink->ops;\r\nu32 threshold;\r\nvoid *hdr;\r\nint err;\r\nerr = ops->sb_port_pool_get(devlink_port, devlink_sb->index,\r\npool_index, &threshold);\r\nif (err)\r\nreturn err;\r\nhdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (devlink_nl_put_handle(msg, devlink))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX, devlink_port->index))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_INDEX, devlink_sb->index))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_SB_POOL_INDEX, pool_index))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_THRESHOLD, threshold))\r\ngoto nla_put_failure;\r\nif (ops->sb_occ_port_pool_get) {\r\nu32 cur;\r\nu32 max;\r\nerr = ops->sb_occ_port_pool_get(devlink_port, devlink_sb->index,\r\npool_index, &cur, &max);\r\nif (err && err != -EOPNOTSUPP)\r\nreturn err;\r\nif (!err) {\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_OCC_CUR, cur))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_OCC_MAX, max))\r\ngoto nla_put_failure;\r\n}\r\n}\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int devlink_nl_cmd_sb_port_pool_get_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink_port *devlink_port = info->user_ptr[0];\r\nstruct devlink *devlink = devlink_port->devlink;\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nstruct sk_buff *msg;\r\nu16 pool_index;\r\nint err;\r\nerr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\r\n&pool_index);\r\nif (err)\r\nreturn err;\r\nif (!devlink->ops || !devlink->ops->sb_port_pool_get)\r\nreturn -EOPNOTSUPP;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nerr = devlink_nl_sb_port_pool_fill(msg, devlink, devlink_port,\r\ndevlink_sb, pool_index,\r\nDEVLINK_CMD_SB_PORT_POOL_NEW,\r\ninfo->snd_portid, info->snd_seq, 0);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn err;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int __sb_port_pool_get_dumpit(struct sk_buff *msg, int start, int *p_idx,\r\nstruct devlink *devlink,\r\nstruct devlink_sb *devlink_sb,\r\nu32 portid, u32 seq)\r\n{\r\nstruct devlink_port *devlink_port;\r\nu16 pool_count = devlink_sb_pool_count(devlink_sb);\r\nu16 pool_index;\r\nint err;\r\nlist_for_each_entry(devlink_port, &devlink->port_list, list) {\r\nfor (pool_index = 0; pool_index < pool_count; pool_index++) {\r\nif (*p_idx < start) {\r\n(*p_idx)++;\r\ncontinue;\r\n}\r\nerr = devlink_nl_sb_port_pool_fill(msg, devlink,\r\ndevlink_port,\r\ndevlink_sb,\r\npool_index,\r\nDEVLINK_CMD_SB_PORT_POOL_NEW,\r\nportid, seq,\r\nNLM_F_MULTI);\r\nif (err)\r\nreturn err;\r\n(*p_idx)++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int devlink_nl_cmd_sb_port_pool_get_dumpit(struct sk_buff *msg,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct devlink *devlink;\r\nstruct devlink_sb *devlink_sb;\r\nint start = cb->args[0];\r\nint idx = 0;\r\nint err;\r\nmutex_lock(&devlink_mutex);\r\nmutex_lock(&devlink_port_mutex);\r\nlist_for_each_entry(devlink, &devlink_list, list) {\r\nif (!net_eq(devlink_net(devlink), sock_net(msg->sk)) ||\r\n!devlink->ops || !devlink->ops->sb_port_pool_get)\r\ncontinue;\r\nlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\r\nerr = __sb_port_pool_get_dumpit(msg, start, &idx,\r\ndevlink, devlink_sb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq);\r\nif (err && err != -EOPNOTSUPP)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&devlink_port_mutex);\r\nmutex_unlock(&devlink_mutex);\r\ncb->args[0] = idx;\r\nreturn msg->len;\r\n}\r\nstatic int devlink_sb_port_pool_set(struct devlink_port *devlink_port,\r\nunsigned int sb_index, u16 pool_index,\r\nu32 threshold)\r\n{\r\nconst struct devlink_ops *ops = devlink_port->devlink->ops;\r\nif (ops && ops->sb_port_pool_set)\r\nreturn ops->sb_port_pool_set(devlink_port, sb_index,\r\npool_index, threshold);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int devlink_nl_cmd_sb_port_pool_set_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink_port *devlink_port = info->user_ptr[0];\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nu16 pool_index;\r\nu32 threshold;\r\nint err;\r\nerr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\r\n&pool_index);\r\nif (err)\r\nreturn err;\r\nif (!info->attrs[DEVLINK_ATTR_SB_THRESHOLD])\r\nreturn -EINVAL;\r\nthreshold = nla_get_u32(info->attrs[DEVLINK_ATTR_SB_THRESHOLD]);\r\nreturn devlink_sb_port_pool_set(devlink_port, devlink_sb->index,\r\npool_index, threshold);\r\n}\r\nstatic int\r\ndevlink_nl_sb_tc_pool_bind_fill(struct sk_buff *msg, struct devlink *devlink,\r\nstruct devlink_port *devlink_port,\r\nstruct devlink_sb *devlink_sb, u16 tc_index,\r\nenum devlink_sb_pool_type pool_type,\r\nenum devlink_command cmd,\r\nu32 portid, u32 seq, int flags)\r\n{\r\nconst struct devlink_ops *ops = devlink->ops;\r\nu16 pool_index;\r\nu32 threshold;\r\nvoid *hdr;\r\nint err;\r\nerr = ops->sb_tc_pool_bind_get(devlink_port, devlink_sb->index,\r\ntc_index, pool_type,\r\n&pool_index, &threshold);\r\nif (err)\r\nreturn err;\r\nhdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (devlink_nl_put_handle(msg, devlink))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX, devlink_port->index))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_INDEX, devlink_sb->index))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_SB_TC_INDEX, tc_index))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(msg, DEVLINK_ATTR_SB_POOL_TYPE, pool_type))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_SB_POOL_INDEX, pool_index))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_THRESHOLD, threshold))\r\ngoto nla_put_failure;\r\nif (ops->sb_occ_tc_port_bind_get) {\r\nu32 cur;\r\nu32 max;\r\nerr = ops->sb_occ_tc_port_bind_get(devlink_port,\r\ndevlink_sb->index,\r\ntc_index, pool_type,\r\n&cur, &max);\r\nif (err && err != -EOPNOTSUPP)\r\nreturn err;\r\nif (!err) {\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_OCC_CUR, cur))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, DEVLINK_ATTR_SB_OCC_MAX, max))\r\ngoto nla_put_failure;\r\n}\r\n}\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int devlink_nl_cmd_sb_tc_pool_bind_get_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink_port *devlink_port = info->user_ptr[0];\r\nstruct devlink *devlink = devlink_port->devlink;\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nstruct sk_buff *msg;\r\nenum devlink_sb_pool_type pool_type;\r\nu16 tc_index;\r\nint err;\r\nerr = devlink_sb_pool_type_get_from_info(info, &pool_type);\r\nif (err)\r\nreturn err;\r\nerr = devlink_sb_tc_index_get_from_info(devlink_sb, info,\r\npool_type, &tc_index);\r\nif (err)\r\nreturn err;\r\nif (!devlink->ops || !devlink->ops->sb_tc_pool_bind_get)\r\nreturn -EOPNOTSUPP;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nerr = devlink_nl_sb_tc_pool_bind_fill(msg, devlink, devlink_port,\r\ndevlink_sb, tc_index, pool_type,\r\nDEVLINK_CMD_SB_TC_POOL_BIND_NEW,\r\ninfo->snd_portid,\r\ninfo->snd_seq, 0);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn err;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int __sb_tc_pool_bind_get_dumpit(struct sk_buff *msg,\r\nint start, int *p_idx,\r\nstruct devlink *devlink,\r\nstruct devlink_sb *devlink_sb,\r\nu32 portid, u32 seq)\r\n{\r\nstruct devlink_port *devlink_port;\r\nu16 tc_index;\r\nint err;\r\nlist_for_each_entry(devlink_port, &devlink->port_list, list) {\r\nfor (tc_index = 0;\r\ntc_index < devlink_sb->ingress_tc_count; tc_index++) {\r\nif (*p_idx < start) {\r\n(*p_idx)++;\r\ncontinue;\r\n}\r\nerr = devlink_nl_sb_tc_pool_bind_fill(msg, devlink,\r\ndevlink_port,\r\ndevlink_sb,\r\ntc_index,\r\nDEVLINK_SB_POOL_TYPE_INGRESS,\r\nDEVLINK_CMD_SB_TC_POOL_BIND_NEW,\r\nportid, seq,\r\nNLM_F_MULTI);\r\nif (err)\r\nreturn err;\r\n(*p_idx)++;\r\n}\r\nfor (tc_index = 0;\r\ntc_index < devlink_sb->egress_tc_count; tc_index++) {\r\nif (*p_idx < start) {\r\n(*p_idx)++;\r\ncontinue;\r\n}\r\nerr = devlink_nl_sb_tc_pool_bind_fill(msg, devlink,\r\ndevlink_port,\r\ndevlink_sb,\r\ntc_index,\r\nDEVLINK_SB_POOL_TYPE_EGRESS,\r\nDEVLINK_CMD_SB_TC_POOL_BIND_NEW,\r\nportid, seq,\r\nNLM_F_MULTI);\r\nif (err)\r\nreturn err;\r\n(*p_idx)++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndevlink_nl_cmd_sb_tc_pool_bind_get_dumpit(struct sk_buff *msg,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct devlink *devlink;\r\nstruct devlink_sb *devlink_sb;\r\nint start = cb->args[0];\r\nint idx = 0;\r\nint err;\r\nmutex_lock(&devlink_mutex);\r\nmutex_lock(&devlink_port_mutex);\r\nlist_for_each_entry(devlink, &devlink_list, list) {\r\nif (!net_eq(devlink_net(devlink), sock_net(msg->sk)) ||\r\n!devlink->ops || !devlink->ops->sb_tc_pool_bind_get)\r\ncontinue;\r\nlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\r\nerr = __sb_tc_pool_bind_get_dumpit(msg, start, &idx,\r\ndevlink,\r\ndevlink_sb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq);\r\nif (err && err != -EOPNOTSUPP)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&devlink_port_mutex);\r\nmutex_unlock(&devlink_mutex);\r\ncb->args[0] = idx;\r\nreturn msg->len;\r\n}\r\nstatic int devlink_sb_tc_pool_bind_set(struct devlink_port *devlink_port,\r\nunsigned int sb_index, u16 tc_index,\r\nenum devlink_sb_pool_type pool_type,\r\nu16 pool_index, u32 threshold)\r\n{\r\nconst struct devlink_ops *ops = devlink_port->devlink->ops;\r\nif (ops && ops->sb_tc_pool_bind_set)\r\nreturn ops->sb_tc_pool_bind_set(devlink_port, sb_index,\r\ntc_index, pool_type,\r\npool_index, threshold);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int devlink_nl_cmd_sb_tc_pool_bind_set_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink_port *devlink_port = info->user_ptr[0];\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nenum devlink_sb_pool_type pool_type;\r\nu16 tc_index;\r\nu16 pool_index;\r\nu32 threshold;\r\nint err;\r\nerr = devlink_sb_pool_type_get_from_info(info, &pool_type);\r\nif (err)\r\nreturn err;\r\nerr = devlink_sb_tc_index_get_from_info(devlink_sb, info,\r\npool_type, &tc_index);\r\nif (err)\r\nreturn err;\r\nerr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\r\n&pool_index);\r\nif (err)\r\nreturn err;\r\nif (!info->attrs[DEVLINK_ATTR_SB_THRESHOLD])\r\nreturn -EINVAL;\r\nthreshold = nla_get_u32(info->attrs[DEVLINK_ATTR_SB_THRESHOLD]);\r\nreturn devlink_sb_tc_pool_bind_set(devlink_port, devlink_sb->index,\r\ntc_index, pool_type,\r\npool_index, threshold);\r\n}\r\nstatic int devlink_nl_cmd_sb_occ_snapshot_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nconst struct devlink_ops *ops = devlink->ops;\r\nif (ops && ops->sb_occ_snapshot)\r\nreturn ops->sb_occ_snapshot(devlink, devlink_sb->index);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int devlink_nl_cmd_sb_occ_max_clear_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nstruct devlink_sb *devlink_sb = info->user_ptr[1];\r\nconst struct devlink_ops *ops = devlink->ops;\r\nif (ops && ops->sb_occ_max_clear)\r\nreturn ops->sb_occ_max_clear(devlink, devlink_sb->index);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int devlink_eswitch_fill(struct sk_buff *msg, struct devlink *devlink,\r\nenum devlink_command cmd, u32 portid,\r\nu32 seq, int flags, u16 mode)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (devlink_nl_put_handle(msg, devlink))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(msg, DEVLINK_ATTR_ESWITCH_MODE, mode))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int devlink_nl_cmd_eswitch_mode_get_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nconst struct devlink_ops *ops = devlink->ops;\r\nstruct sk_buff *msg;\r\nu16 mode;\r\nint err;\r\nif (!ops || !ops->eswitch_mode_get)\r\nreturn -EOPNOTSUPP;\r\nerr = ops->eswitch_mode_get(devlink, &mode);\r\nif (err)\r\nreturn err;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nerr = devlink_eswitch_fill(msg, devlink, DEVLINK_CMD_ESWITCH_MODE_GET,\r\ninfo->snd_portid, info->snd_seq, 0, mode);\r\nif (err) {\r\nnlmsg_free(msg);\r\nreturn err;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int devlink_nl_cmd_eswitch_mode_set_doit(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct devlink *devlink = info->user_ptr[0];\r\nconst struct devlink_ops *ops = devlink->ops;\r\nu16 mode;\r\nif (!info->attrs[DEVLINK_ATTR_ESWITCH_MODE])\r\nreturn -EINVAL;\r\nmode = nla_get_u16(info->attrs[DEVLINK_ATTR_ESWITCH_MODE]);\r\nif (ops && ops->eswitch_mode_set)\r\nreturn ops->eswitch_mode_set(devlink, mode);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstruct devlink *devlink_alloc(const struct devlink_ops *ops, size_t priv_size)\r\n{\r\nstruct devlink *devlink;\r\ndevlink = kzalloc(sizeof(*devlink) + priv_size, GFP_KERNEL);\r\nif (!devlink)\r\nreturn NULL;\r\ndevlink->ops = ops;\r\ndevlink_net_set(devlink, &init_net);\r\nINIT_LIST_HEAD(&devlink->port_list);\r\nINIT_LIST_HEAD(&devlink->sb_list);\r\nreturn devlink;\r\n}\r\nint devlink_register(struct devlink *devlink, struct device *dev)\r\n{\r\nmutex_lock(&devlink_mutex);\r\ndevlink->dev = dev;\r\nlist_add_tail(&devlink->list, &devlink_list);\r\ndevlink_notify(devlink, DEVLINK_CMD_NEW);\r\nmutex_unlock(&devlink_mutex);\r\nreturn 0;\r\n}\r\nvoid devlink_unregister(struct devlink *devlink)\r\n{\r\nmutex_lock(&devlink_mutex);\r\ndevlink_notify(devlink, DEVLINK_CMD_DEL);\r\nlist_del(&devlink->list);\r\nmutex_unlock(&devlink_mutex);\r\n}\r\nvoid devlink_free(struct devlink *devlink)\r\n{\r\nkfree(devlink);\r\n}\r\nint devlink_port_register(struct devlink *devlink,\r\nstruct devlink_port *devlink_port,\r\nunsigned int port_index)\r\n{\r\nmutex_lock(&devlink_port_mutex);\r\nif (devlink_port_index_exists(devlink, port_index)) {\r\nmutex_unlock(&devlink_port_mutex);\r\nreturn -EEXIST;\r\n}\r\ndevlink_port->devlink = devlink;\r\ndevlink_port->index = port_index;\r\ndevlink_port->registered = true;\r\nlist_add_tail(&devlink_port->list, &devlink->port_list);\r\nmutex_unlock(&devlink_port_mutex);\r\ndevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_NEW);\r\nreturn 0;\r\n}\r\nvoid devlink_port_unregister(struct devlink_port *devlink_port)\r\n{\r\ndevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_DEL);\r\nmutex_lock(&devlink_port_mutex);\r\nlist_del(&devlink_port->list);\r\nmutex_unlock(&devlink_port_mutex);\r\n}\r\nstatic void __devlink_port_type_set(struct devlink_port *devlink_port,\r\nenum devlink_port_type type,\r\nvoid *type_dev)\r\n{\r\ndevlink_port->type = type;\r\ndevlink_port->type_dev = type_dev;\r\ndevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_NEW);\r\n}\r\nvoid devlink_port_type_eth_set(struct devlink_port *devlink_port,\r\nstruct net_device *netdev)\r\n{\r\nreturn __devlink_port_type_set(devlink_port,\r\nDEVLINK_PORT_TYPE_ETH, netdev);\r\n}\r\nvoid devlink_port_type_ib_set(struct devlink_port *devlink_port,\r\nstruct ib_device *ibdev)\r\n{\r\nreturn __devlink_port_type_set(devlink_port,\r\nDEVLINK_PORT_TYPE_IB, ibdev);\r\n}\r\nvoid devlink_port_type_clear(struct devlink_port *devlink_port)\r\n{\r\nreturn __devlink_port_type_set(devlink_port,\r\nDEVLINK_PORT_TYPE_NOTSET, NULL);\r\n}\r\nvoid devlink_port_split_set(struct devlink_port *devlink_port,\r\nu32 split_group)\r\n{\r\ndevlink_port->split = true;\r\ndevlink_port->split_group = split_group;\r\ndevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_NEW);\r\n}\r\nint devlink_sb_register(struct devlink *devlink, unsigned int sb_index,\r\nu32 size, u16 ingress_pools_count,\r\nu16 egress_pools_count, u16 ingress_tc_count,\r\nu16 egress_tc_count)\r\n{\r\nstruct devlink_sb *devlink_sb;\r\nint err = 0;\r\nmutex_lock(&devlink_mutex);\r\nif (devlink_sb_index_exists(devlink, sb_index)) {\r\nerr = -EEXIST;\r\ngoto unlock;\r\n}\r\ndevlink_sb = kzalloc(sizeof(*devlink_sb), GFP_KERNEL);\r\nif (!devlink_sb) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\ndevlink_sb->index = sb_index;\r\ndevlink_sb->size = size;\r\ndevlink_sb->ingress_pools_count = ingress_pools_count;\r\ndevlink_sb->egress_pools_count = egress_pools_count;\r\ndevlink_sb->ingress_tc_count = ingress_tc_count;\r\ndevlink_sb->egress_tc_count = egress_tc_count;\r\nlist_add_tail(&devlink_sb->list, &devlink->sb_list);\r\nunlock:\r\nmutex_unlock(&devlink_mutex);\r\nreturn err;\r\n}\r\nvoid devlink_sb_unregister(struct devlink *devlink, unsigned int sb_index)\r\n{\r\nstruct devlink_sb *devlink_sb;\r\nmutex_lock(&devlink_mutex);\r\ndevlink_sb = devlink_sb_get_by_index(devlink, sb_index);\r\nWARN_ON(!devlink_sb);\r\nlist_del(&devlink_sb->list);\r\nmutex_unlock(&devlink_mutex);\r\nkfree(devlink_sb);\r\n}\r\nstatic int __init devlink_module_init(void)\r\n{\r\nreturn genl_register_family_with_ops_groups(&devlink_nl_family,\r\ndevlink_nl_ops,\r\ndevlink_nl_mcgrps);\r\n}\r\nstatic void __exit devlink_module_exit(void)\r\n{\r\ngenl_unregister_family(&devlink_nl_family);\r\n}
