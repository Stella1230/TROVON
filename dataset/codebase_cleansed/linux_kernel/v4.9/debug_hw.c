static unsigned int show_channel_command(struct output *o, u32 val)\r\n{\r\nunsigned int mask, subop;\r\nswitch (val >> 28) {\r\ncase HOST1X_OPCODE_SETCLASS:\r\nmask = val & 0x3f;\r\nif (mask) {\r\nhost1x_debug_output(o, "SETCL(class=%03x, offset=%03x, mask=%02x, [",\r\nval >> 6 & 0x3ff,\r\nval >> 16 & 0xfff, mask);\r\nreturn hweight8(mask);\r\n}\r\nhost1x_debug_output(o, "SETCL(class=%03x)\n", val >> 6 & 0x3ff);\r\nreturn 0;\r\ncase HOST1X_OPCODE_INCR:\r\nhost1x_debug_output(o, "INCR(offset=%03x, [",\r\nval >> 16 & 0xfff);\r\nreturn val & 0xffff;\r\ncase HOST1X_OPCODE_NONINCR:\r\nhost1x_debug_output(o, "NONINCR(offset=%03x, [",\r\nval >> 16 & 0xfff);\r\nreturn val & 0xffff;\r\ncase HOST1X_OPCODE_MASK:\r\nmask = val & 0xffff;\r\nhost1x_debug_output(o, "MASK(offset=%03x, mask=%03x, [",\r\nval >> 16 & 0xfff, mask);\r\nreturn hweight16(mask);\r\ncase HOST1X_OPCODE_IMM:\r\nhost1x_debug_output(o, "IMM(offset=%03x, data=%03x)\n",\r\nval >> 16 & 0xfff, val & 0xffff);\r\nreturn 0;\r\ncase HOST1X_OPCODE_RESTART:\r\nhost1x_debug_output(o, "RESTART(offset=%08x)\n", val << 4);\r\nreturn 0;\r\ncase HOST1X_OPCODE_GATHER:\r\nhost1x_debug_output(o, "GATHER(offset=%03x, insert=%d, type=%d, count=%04x, addr=[",\r\nval >> 16 & 0xfff, val >> 15 & 0x1,\r\nval >> 14 & 0x1, val & 0x3fff);\r\nreturn 1;\r\ncase HOST1X_OPCODE_EXTEND:\r\nsubop = val >> 24 & 0xf;\r\nif (subop == HOST1X_OPCODE_EXTEND_ACQUIRE_MLOCK)\r\nhost1x_debug_output(o, "ACQUIRE_MLOCK(index=%d)\n",\r\nval & 0xff);\r\nelse if (subop == HOST1X_OPCODE_EXTEND_RELEASE_MLOCK)\r\nhost1x_debug_output(o, "RELEASE_MLOCK(index=%d)\n",\r\nval & 0xff);\r\nelse\r\nhost1x_debug_output(o, "EXTEND_UNKNOWN(%08x)\n", val);\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void show_gather(struct output *o, phys_addr_t phys_addr,\r\nunsigned int words, struct host1x_cdma *cdma,\r\nphys_addr_t pin_addr, u32 *map_addr)\r\n{\r\nu32 offset = phys_addr - pin_addr;\r\nunsigned int data_count = 0, i;\r\nif (offset > HOST1X_DEBUG_MAX_PAGE_OFFSET) {\r\nhost1x_debug_output(o, "[address mismatch]\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < words; i++) {\r\nu32 addr = phys_addr + i * 4;\r\nu32 val = *(map_addr + offset / 4 + i);\r\nif (!data_count) {\r\nhost1x_debug_output(o, "%08x: %08x:", addr, val);\r\ndata_count = show_channel_command(o, val);\r\n} else {\r\nhost1x_debug_output(o, "%08x%s", val,\r\ndata_count > 0 ? ", " : "])\n");\r\ndata_count--;\r\n}\r\n}\r\n}\r\nstatic void show_channel_gathers(struct output *o, struct host1x_cdma *cdma)\r\n{\r\nstruct host1x_job *job;\r\nlist_for_each_entry(job, &cdma->sync_queue, list) {\r\nunsigned int i;\r\nhost1x_debug_output(o, "\n%p: JOB, syncpt_id=%d, syncpt_val=%d, first_get=%08x, timeout=%d num_slots=%d, num_handles=%d\n",\r\njob, job->syncpt_id, job->syncpt_end,\r\njob->first_get, job->timeout,\r\njob->num_slots, job->num_unpins);\r\nfor (i = 0; i < job->num_gathers; i++) {\r\nstruct host1x_job_gather *g = &job->gathers[i];\r\nu32 *mapped;\r\nif (job->gather_copy_mapped)\r\nmapped = (u32 *)job->gather_copy_mapped;\r\nelse\r\nmapped = host1x_bo_mmap(g->bo);\r\nif (!mapped) {\r\nhost1x_debug_output(o, "[could not mmap]\n");\r\ncontinue;\r\n}\r\nhost1x_debug_output(o, " GATHER at %pad+%#x, %d words\n",\r\n&g->base, g->offset, g->words);\r\nshow_gather(o, g->base + g->offset, g->words, cdma,\r\ng->base, mapped);\r\nif (!job->gather_copy_mapped)\r\nhost1x_bo_munmap(g->bo, mapped);\r\n}\r\n}\r\n}\r\nstatic void host1x_debug_show_channel_cdma(struct host1x *host,\r\nstruct host1x_channel *ch,\r\nstruct output *o)\r\n{\r\nstruct host1x_cdma *cdma = &ch->cdma;\r\nu32 dmaput, dmaget, dmactrl;\r\nu32 cbstat, cbread;\r\nu32 val, base, baseval;\r\ndmaput = host1x_ch_readl(ch, HOST1X_CHANNEL_DMAPUT);\r\ndmaget = host1x_ch_readl(ch, HOST1X_CHANNEL_DMAGET);\r\ndmactrl = host1x_ch_readl(ch, HOST1X_CHANNEL_DMACTRL);\r\ncbread = host1x_sync_readl(host, HOST1X_SYNC_CBREAD(ch->id));\r\ncbstat = host1x_sync_readl(host, HOST1X_SYNC_CBSTAT(ch->id));\r\nhost1x_debug_output(o, "%u-%s: ", ch->id, dev_name(ch->dev));\r\nif (HOST1X_CHANNEL_DMACTRL_DMASTOP_V(dmactrl) ||\r\n!ch->cdma.push_buffer.mapped) {\r\nhost1x_debug_output(o, "inactive\n\n");\r\nreturn;\r\n}\r\nif (HOST1X_SYNC_CBSTAT_CBCLASS_V(cbstat) == HOST1X_CLASS_HOST1X &&\r\nHOST1X_SYNC_CBSTAT_CBOFFSET_V(cbstat) ==\r\nHOST1X_UCLASS_WAIT_SYNCPT)\r\nhost1x_debug_output(o, "waiting on syncpt %d val %d\n",\r\ncbread >> 24, cbread & 0xffffff);\r\nelse if (HOST1X_SYNC_CBSTAT_CBCLASS_V(cbstat) ==\r\nHOST1X_CLASS_HOST1X &&\r\nHOST1X_SYNC_CBSTAT_CBOFFSET_V(cbstat) ==\r\nHOST1X_UCLASS_WAIT_SYNCPT_BASE) {\r\nbase = (cbread >> 16) & 0xff;\r\nbaseval =\r\nhost1x_sync_readl(host, HOST1X_SYNC_SYNCPT_BASE(base));\r\nval = cbread & 0xffff;\r\nhost1x_debug_output(o, "waiting on syncpt %d val %d (base %d = %d; offset = %d)\n",\r\ncbread >> 24, baseval + val, base,\r\nbaseval, val);\r\n} else\r\nhost1x_debug_output(o, "active class %02x, offset %04x, val %08x\n",\r\nHOST1X_SYNC_CBSTAT_CBCLASS_V(cbstat),\r\nHOST1X_SYNC_CBSTAT_CBOFFSET_V(cbstat),\r\ncbread);\r\nhost1x_debug_output(o, "DMAPUT %08x, DMAGET %08x, DMACTL %08x\n",\r\ndmaput, dmaget, dmactrl);\r\nhost1x_debug_output(o, "CBREAD %08x, CBSTAT %08x\n", cbread, cbstat);\r\nshow_channel_gathers(o, cdma);\r\nhost1x_debug_output(o, "\n");\r\n}\r\nstatic void host1x_debug_show_channel_fifo(struct host1x *host,\r\nstruct host1x_channel *ch,\r\nstruct output *o)\r\n{\r\nu32 val, rd_ptr, wr_ptr, start, end;\r\nunsigned int data_count = 0;\r\nhost1x_debug_output(o, "%u: fifo:\n", ch->id);\r\nval = host1x_ch_readl(ch, HOST1X_CHANNEL_FIFOSTAT);\r\nhost1x_debug_output(o, "FIFOSTAT %08x\n", val);\r\nif (HOST1X_CHANNEL_FIFOSTAT_CFEMPTY_V(val)) {\r\nhost1x_debug_output(o, "[empty]\n");\r\nreturn;\r\n}\r\nhost1x_sync_writel(host, 0x0, HOST1X_SYNC_CFPEEK_CTRL);\r\nhost1x_sync_writel(host, HOST1X_SYNC_CFPEEK_CTRL_ENA_F(1) |\r\nHOST1X_SYNC_CFPEEK_CTRL_CHANNR_F(ch->id),\r\nHOST1X_SYNC_CFPEEK_CTRL);\r\nval = host1x_sync_readl(host, HOST1X_SYNC_CFPEEK_PTRS);\r\nrd_ptr = HOST1X_SYNC_CFPEEK_PTRS_CF_RD_PTR_V(val);\r\nwr_ptr = HOST1X_SYNC_CFPEEK_PTRS_CF_WR_PTR_V(val);\r\nval = host1x_sync_readl(host, HOST1X_SYNC_CF_SETUP(ch->id));\r\nstart = HOST1X_SYNC_CF_SETUP_BASE_V(val);\r\nend = HOST1X_SYNC_CF_SETUP_LIMIT_V(val);\r\ndo {\r\nhost1x_sync_writel(host, 0x0, HOST1X_SYNC_CFPEEK_CTRL);\r\nhost1x_sync_writel(host, HOST1X_SYNC_CFPEEK_CTRL_ENA_F(1) |\r\nHOST1X_SYNC_CFPEEK_CTRL_CHANNR_F(ch->id) |\r\nHOST1X_SYNC_CFPEEK_CTRL_ADDR_F(rd_ptr),\r\nHOST1X_SYNC_CFPEEK_CTRL);\r\nval = host1x_sync_readl(host, HOST1X_SYNC_CFPEEK_READ);\r\nif (!data_count) {\r\nhost1x_debug_output(o, "%08x:", val);\r\ndata_count = show_channel_command(o, val);\r\n} else {\r\nhost1x_debug_output(o, "%08x%s", val,\r\ndata_count > 0 ? ", " : "])\n");\r\ndata_count--;\r\n}\r\nif (rd_ptr == end)\r\nrd_ptr = start;\r\nelse\r\nrd_ptr++;\r\n} while (rd_ptr != wr_ptr);\r\nif (data_count)\r\nhost1x_debug_output(o, ", ...])\n");\r\nhost1x_debug_output(o, "\n");\r\nhost1x_sync_writel(host, 0x0, HOST1X_SYNC_CFPEEK_CTRL);\r\n}\r\nstatic void host1x_debug_show_mlocks(struct host1x *host, struct output *o)\r\n{\r\nunsigned int i;\r\nhost1x_debug_output(o, "---- mlocks ----\n");\r\nfor (i = 0; i < host1x_syncpt_nb_mlocks(host); i++) {\r\nu32 owner =\r\nhost1x_sync_readl(host, HOST1X_SYNC_MLOCK_OWNER(i));\r\nif (HOST1X_SYNC_MLOCK_OWNER_CH_OWNS_V(owner))\r\nhost1x_debug_output(o, "%u: locked by channel %u\n",\r\ni, HOST1X_SYNC_MLOCK_OWNER_CHID_V(owner));\r\nelse if (HOST1X_SYNC_MLOCK_OWNER_CPU_OWNS_V(owner))\r\nhost1x_debug_output(o, "%u: locked by cpu\n", i);\r\nelse\r\nhost1x_debug_output(o, "%u: unlocked\n", i);\r\n}\r\nhost1x_debug_output(o, "\n");\r\n}
