static void __init l1sram_init(void)\r\n{\r\nunsigned int cpu;\r\nunsigned long reserve;\r\n#ifdef CONFIG_SMP\r\nreserve = 0;\r\n#else\r\nreserve = sizeof(struct l1_scratch_task_info);\r\n#endif\r\nfor (cpu = 0; cpu < num_possible_cpus(); ++cpu) {\r\nper_cpu(free_l1_ssram_head, cpu).next =\r\nkmem_cache_alloc(sram_piece_cache, GFP_KERNEL);\r\nif (!per_cpu(free_l1_ssram_head, cpu).next) {\r\nprintk(KERN_INFO "Fail to initialize Scratchpad data SRAM.\n");\r\nreturn;\r\n}\r\nper_cpu(free_l1_ssram_head, cpu).next->paddr = (void *)get_l1_scratch_start_cpu(cpu) + reserve;\r\nper_cpu(free_l1_ssram_head, cpu).next->size = L1_SCRATCH_LENGTH - reserve;\r\nper_cpu(free_l1_ssram_head, cpu).next->pid = 0;\r\nper_cpu(free_l1_ssram_head, cpu).next->next = NULL;\r\nper_cpu(used_l1_ssram_head, cpu).next = NULL;\r\nspin_lock_init(&per_cpu(l1sram_lock, cpu));\r\nprintk(KERN_INFO "Blackfin Scratchpad data SRAM: %d KB\n",\r\nL1_SCRATCH_LENGTH >> 10);\r\n}\r\n}\r\nstatic void __init l1_data_sram_init(void)\r\n{\r\n#if L1_DATA_A_LENGTH != 0 || L1_DATA_B_LENGTH != 0\r\nunsigned int cpu;\r\n#endif\r\n#if L1_DATA_A_LENGTH != 0\r\nfor (cpu = 0; cpu < num_possible_cpus(); ++cpu) {\r\nper_cpu(free_l1_data_A_sram_head, cpu).next =\r\nkmem_cache_alloc(sram_piece_cache, GFP_KERNEL);\r\nif (!per_cpu(free_l1_data_A_sram_head, cpu).next) {\r\nprintk(KERN_INFO "Fail to initialize L1 Data A SRAM.\n");\r\nreturn;\r\n}\r\nper_cpu(free_l1_data_A_sram_head, cpu).next->paddr =\r\n(void *)get_l1_data_a_start_cpu(cpu) + (_ebss_l1 - _sdata_l1);\r\nper_cpu(free_l1_data_A_sram_head, cpu).next->size =\r\nL1_DATA_A_LENGTH - (_ebss_l1 - _sdata_l1);\r\nper_cpu(free_l1_data_A_sram_head, cpu).next->pid = 0;\r\nper_cpu(free_l1_data_A_sram_head, cpu).next->next = NULL;\r\nper_cpu(used_l1_data_A_sram_head, cpu).next = NULL;\r\nprintk(KERN_INFO "Blackfin L1 Data A SRAM: %d KB (%d KB free)\n",\r\nL1_DATA_A_LENGTH >> 10,\r\nper_cpu(free_l1_data_A_sram_head, cpu).next->size >> 10);\r\n}\r\n#endif\r\n#if L1_DATA_B_LENGTH != 0\r\nfor (cpu = 0; cpu < num_possible_cpus(); ++cpu) {\r\nper_cpu(free_l1_data_B_sram_head, cpu).next =\r\nkmem_cache_alloc(sram_piece_cache, GFP_KERNEL);\r\nif (!per_cpu(free_l1_data_B_sram_head, cpu).next) {\r\nprintk(KERN_INFO "Fail to initialize L1 Data B SRAM.\n");\r\nreturn;\r\n}\r\nper_cpu(free_l1_data_B_sram_head, cpu).next->paddr =\r\n(void *)get_l1_data_b_start_cpu(cpu) + (_ebss_b_l1 - _sdata_b_l1);\r\nper_cpu(free_l1_data_B_sram_head, cpu).next->size =\r\nL1_DATA_B_LENGTH - (_ebss_b_l1 - _sdata_b_l1);\r\nper_cpu(free_l1_data_B_sram_head, cpu).next->pid = 0;\r\nper_cpu(free_l1_data_B_sram_head, cpu).next->next = NULL;\r\nper_cpu(used_l1_data_B_sram_head, cpu).next = NULL;\r\nprintk(KERN_INFO "Blackfin L1 Data B SRAM: %d KB (%d KB free)\n",\r\nL1_DATA_B_LENGTH >> 10,\r\nper_cpu(free_l1_data_B_sram_head, cpu).next->size >> 10);\r\n}\r\n#endif\r\n#if L1_DATA_A_LENGTH != 0 || L1_DATA_B_LENGTH != 0\r\nfor (cpu = 0; cpu < num_possible_cpus(); ++cpu)\r\nspin_lock_init(&per_cpu(l1_data_sram_lock, cpu));\r\n#endif\r\n}\r\nstatic void __init l1_inst_sram_init(void)\r\n{\r\n#if L1_CODE_LENGTH != 0\r\nunsigned int cpu;\r\nfor (cpu = 0; cpu < num_possible_cpus(); ++cpu) {\r\nper_cpu(free_l1_inst_sram_head, cpu).next =\r\nkmem_cache_alloc(sram_piece_cache, GFP_KERNEL);\r\nif (!per_cpu(free_l1_inst_sram_head, cpu).next) {\r\nprintk(KERN_INFO "Failed to initialize L1 Instruction SRAM\n");\r\nreturn;\r\n}\r\nper_cpu(free_l1_inst_sram_head, cpu).next->paddr =\r\n(void *)get_l1_code_start_cpu(cpu) + (_etext_l1 - _stext_l1);\r\nper_cpu(free_l1_inst_sram_head, cpu).next->size =\r\nL1_CODE_LENGTH - (_etext_l1 - _stext_l1);\r\nper_cpu(free_l1_inst_sram_head, cpu).next->pid = 0;\r\nper_cpu(free_l1_inst_sram_head, cpu).next->next = NULL;\r\nper_cpu(used_l1_inst_sram_head, cpu).next = NULL;\r\nprintk(KERN_INFO "Blackfin L1 Instruction SRAM: %d KB (%d KB free)\n",\r\nL1_CODE_LENGTH >> 10,\r\nper_cpu(free_l1_inst_sram_head, cpu).next->size >> 10);\r\nspin_lock_init(&per_cpu(l1_inst_sram_lock, cpu));\r\n}\r\n#endif\r\n}\r\nstatic irqreturn_t l2_ecc_err(int irq, void *dev_id)\r\n{\r\nint status;\r\nprintk(KERN_ERR "L2 ecc error happened\n");\r\nstatus = bfin_read32(L2CTL0_STAT);\r\nif (status & 0x1)\r\nprintk(KERN_ERR "Core channel error type:0x%x, addr:0x%x\n",\r\nbfin_read32(L2CTL0_ET0), bfin_read32(L2CTL0_EADDR0));\r\nif (status & 0x2)\r\nprintk(KERN_ERR "System channel error type:0x%x, addr:0x%x\n",\r\nbfin_read32(L2CTL0_ET1), bfin_read32(L2CTL0_EADDR1));\r\nstatus = status >> 8;\r\nif (status)\r\nprintk(KERN_ERR "L2 Bank%d error, addr:0x%x\n",\r\nstatus, bfin_read32(L2CTL0_ERRADDR0 + status));\r\npanic("L2 Ecc error");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init l2_sram_init(void)\r\n{\r\n#if L2_LENGTH != 0\r\n#ifdef __ADSPBF60x__\r\nint ret;\r\nret = request_irq(IRQ_L2CTL0_ECC_ERR, l2_ecc_err, 0, "l2-ecc-err",\r\nNULL);\r\nif (unlikely(ret < 0)) {\r\nprintk(KERN_INFO "Fail to request l2 ecc error interrupt");\r\nreturn;\r\n}\r\n#endif\r\nfree_l2_sram_head.next =\r\nkmem_cache_alloc(sram_piece_cache, GFP_KERNEL);\r\nif (!free_l2_sram_head.next) {\r\nprintk(KERN_INFO "Fail to initialize L2 SRAM.\n");\r\nreturn;\r\n}\r\nfree_l2_sram_head.next->paddr =\r\n(void *)L2_START + (_ebss_l2 - _stext_l2);\r\nfree_l2_sram_head.next->size =\r\nL2_LENGTH - (_ebss_l2 - _stext_l2);\r\nfree_l2_sram_head.next->pid = 0;\r\nfree_l2_sram_head.next->next = NULL;\r\nused_l2_sram_head.next = NULL;\r\nprintk(KERN_INFO "Blackfin L2 SRAM: %d KB (%d KB free)\n",\r\nL2_LENGTH >> 10,\r\nfree_l2_sram_head.next->size >> 10);\r\nspin_lock_init(&l2_sram_lock);\r\n#endif\r\n}\r\nstatic int __init bfin_sram_init(void)\r\n{\r\nsram_piece_cache = kmem_cache_create("sram_piece_cache",\r\nsizeof(struct sram_piece),\r\n0, SLAB_PANIC, NULL);\r\nl1sram_init();\r\nl1_data_sram_init();\r\nl1_inst_sram_init();\r\nl2_sram_init();\r\nreturn 0;\r\n}\r\nstatic void *_sram_alloc(size_t size, struct sram_piece *pfree_head,\r\nstruct sram_piece *pused_head)\r\n{\r\nstruct sram_piece *pslot, *plast, *pavail;\r\nif (size <= 0 || !pfree_head || !pused_head)\r\nreturn NULL;\r\nsize = (size + 3) & ~3;\r\npslot = pfree_head->next;\r\nplast = pfree_head;\r\nwhile (pslot != NULL && size > pslot->size) {\r\nplast = pslot;\r\npslot = pslot->next;\r\n}\r\nif (!pslot)\r\nreturn NULL;\r\nif (pslot->size == size) {\r\nplast->next = pslot->next;\r\npavail = pslot;\r\n} else {\r\npavail = kmem_cache_alloc(sram_piece_cache, GFP_ATOMIC);\r\nif (!pavail)\r\nreturn NULL;\r\npavail->paddr = pslot->paddr;\r\npavail->size = size;\r\npslot->paddr += size;\r\npslot->size -= size;\r\n}\r\npavail->pid = current->pid;\r\npslot = pused_head->next;\r\nplast = pused_head;\r\nwhile (pslot != NULL && pavail->paddr < pslot->paddr) {\r\nplast = pslot;\r\npslot = pslot->next;\r\n}\r\npavail->next = pslot;\r\nplast->next = pavail;\r\nreturn pavail->paddr;\r\n}\r\nstatic void *_sram_alloc_max(struct sram_piece *pfree_head,\r\nstruct sram_piece *pused_head,\r\nunsigned long *psize)\r\n{\r\nstruct sram_piece *pslot, *pmax;\r\nif (!pfree_head || !pused_head)\r\nreturn NULL;\r\npmax = pslot = pfree_head->next;\r\nwhile (pslot != NULL) {\r\nif (pslot->size > pmax->size)\r\npmax = pslot;\r\npslot = pslot->next;\r\n}\r\nif (!pmax)\r\nreturn NULL;\r\n*psize = pmax->size;\r\nreturn _sram_alloc(*psize, pfree_head, pused_head);\r\n}\r\nstatic int _sram_free(const void *addr,\r\nstruct sram_piece *pfree_head,\r\nstruct sram_piece *pused_head)\r\n{\r\nstruct sram_piece *pslot, *plast, *pavail;\r\nif (!pfree_head || !pused_head)\r\nreturn -1;\r\npslot = pused_head->next;\r\nplast = pused_head;\r\nwhile (pslot != NULL && pslot->paddr != addr) {\r\nplast = pslot;\r\npslot = pslot->next;\r\n}\r\nif (!pslot)\r\nreturn -1;\r\nplast->next = pslot->next;\r\npavail = pslot;\r\npavail->pid = 0;\r\npslot = pfree_head->next;\r\nplast = pfree_head;\r\nwhile (pslot != NULL && addr > pslot->paddr) {\r\nplast = pslot;\r\npslot = pslot->next;\r\n}\r\nif (plast != pfree_head && plast->paddr + plast->size == pavail->paddr) {\r\nplast->size += pavail->size;\r\nkmem_cache_free(sram_piece_cache, pavail);\r\n} else {\r\npavail->next = plast->next;\r\nplast->next = pavail;\r\nplast = pavail;\r\n}\r\nif (pslot && plast->paddr + plast->size == pslot->paddr) {\r\nplast->size += pslot->size;\r\nplast->next = pslot->next;\r\nkmem_cache_free(sram_piece_cache, pslot);\r\n}\r\nreturn 0;\r\n}\r\nint sram_free(const void *addr)\r\n{\r\n#if L1_CODE_LENGTH != 0\r\nif (addr >= (void *)get_l1_code_start()\r\n&& addr < (void *)(get_l1_code_start() + L1_CODE_LENGTH))\r\nreturn l1_inst_sram_free(addr);\r\nelse\r\n#endif\r\n#if L1_DATA_A_LENGTH != 0\r\nif (addr >= (void *)get_l1_data_a_start()\r\n&& addr < (void *)(get_l1_data_a_start() + L1_DATA_A_LENGTH))\r\nreturn l1_data_A_sram_free(addr);\r\nelse\r\n#endif\r\n#if L1_DATA_B_LENGTH != 0\r\nif (addr >= (void *)get_l1_data_b_start()\r\n&& addr < (void *)(get_l1_data_b_start() + L1_DATA_B_LENGTH))\r\nreturn l1_data_B_sram_free(addr);\r\nelse\r\n#endif\r\n#if L2_LENGTH != 0\r\nif (addr >= (void *)L2_START\r\n&& addr < (void *)(L2_START + L2_LENGTH))\r\nreturn l2_sram_free(addr);\r\nelse\r\n#endif\r\nreturn -1;\r\n}\r\nvoid *l1_data_A_sram_alloc(size_t size)\r\n{\r\n#if L1_DATA_A_LENGTH != 0\r\nunsigned long flags;\r\nvoid *addr;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1_data_sram_lock, cpu), flags);\r\naddr = _sram_alloc(size, &per_cpu(free_l1_data_A_sram_head, cpu),\r\n&per_cpu(used_l1_data_A_sram_head, cpu));\r\nspin_unlock_irqrestore(&per_cpu(l1_data_sram_lock, cpu), flags);\r\npr_debug("Allocated address in l1_data_A_sram_alloc is 0x%lx+0x%lx\n",\r\n(long unsigned int)addr, size);\r\nreturn addr;\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\nint l1_data_A_sram_free(const void *addr)\r\n{\r\n#if L1_DATA_A_LENGTH != 0\r\nunsigned long flags;\r\nint ret;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1_data_sram_lock, cpu), flags);\r\nret = _sram_free(addr, &per_cpu(free_l1_data_A_sram_head, cpu),\r\n&per_cpu(used_l1_data_A_sram_head, cpu));\r\nspin_unlock_irqrestore(&per_cpu(l1_data_sram_lock, cpu), flags);\r\nreturn ret;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nvoid *l1_data_B_sram_alloc(size_t size)\r\n{\r\n#if L1_DATA_B_LENGTH != 0\r\nunsigned long flags;\r\nvoid *addr;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1_data_sram_lock, cpu), flags);\r\naddr = _sram_alloc(size, &per_cpu(free_l1_data_B_sram_head, cpu),\r\n&per_cpu(used_l1_data_B_sram_head, cpu));\r\nspin_unlock_irqrestore(&per_cpu(l1_data_sram_lock, cpu), flags);\r\npr_debug("Allocated address in l1_data_B_sram_alloc is 0x%lx+0x%lx\n",\r\n(long unsigned int)addr, size);\r\nreturn addr;\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\nint l1_data_B_sram_free(const void *addr)\r\n{\r\n#if L1_DATA_B_LENGTH != 0\r\nunsigned long flags;\r\nint ret;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1_data_sram_lock, cpu), flags);\r\nret = _sram_free(addr, &per_cpu(free_l1_data_B_sram_head, cpu),\r\n&per_cpu(used_l1_data_B_sram_head, cpu));\r\nspin_unlock_irqrestore(&per_cpu(l1_data_sram_lock, cpu), flags);\r\nreturn ret;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nvoid *l1_data_sram_alloc(size_t size)\r\n{\r\nvoid *addr = l1_data_A_sram_alloc(size);\r\nif (!addr)\r\naddr = l1_data_B_sram_alloc(size);\r\nreturn addr;\r\n}\r\nvoid *l1_data_sram_zalloc(size_t size)\r\n{\r\nvoid *addr = l1_data_sram_alloc(size);\r\nif (addr)\r\nmemset(addr, 0x00, size);\r\nreturn addr;\r\n}\r\nint l1_data_sram_free(const void *addr)\r\n{\r\nint ret;\r\nret = l1_data_A_sram_free(addr);\r\nif (ret == -1)\r\nret = l1_data_B_sram_free(addr);\r\nreturn ret;\r\n}\r\nvoid *l1_inst_sram_alloc(size_t size)\r\n{\r\n#if L1_CODE_LENGTH != 0\r\nunsigned long flags;\r\nvoid *addr;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1_inst_sram_lock, cpu), flags);\r\naddr = _sram_alloc(size, &per_cpu(free_l1_inst_sram_head, cpu),\r\n&per_cpu(used_l1_inst_sram_head, cpu));\r\nspin_unlock_irqrestore(&per_cpu(l1_inst_sram_lock, cpu), flags);\r\npr_debug("Allocated address in l1_inst_sram_alloc is 0x%lx+0x%lx\n",\r\n(long unsigned int)addr, size);\r\nreturn addr;\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\nint l1_inst_sram_free(const void *addr)\r\n{\r\n#if L1_CODE_LENGTH != 0\r\nunsigned long flags;\r\nint ret;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1_inst_sram_lock, cpu), flags);\r\nret = _sram_free(addr, &per_cpu(free_l1_inst_sram_head, cpu),\r\n&per_cpu(used_l1_inst_sram_head, cpu));\r\nspin_unlock_irqrestore(&per_cpu(l1_inst_sram_lock, cpu), flags);\r\nreturn ret;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nvoid *l1sram_alloc(size_t size)\r\n{\r\nunsigned long flags;\r\nvoid *addr;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1sram_lock, cpu), flags);\r\naddr = _sram_alloc(size, &per_cpu(free_l1_ssram_head, cpu),\r\n&per_cpu(used_l1_ssram_head, cpu));\r\nspin_unlock_irqrestore(&per_cpu(l1sram_lock, cpu), flags);\r\nreturn addr;\r\n}\r\nvoid *l1sram_alloc_max(size_t *psize)\r\n{\r\nunsigned long flags;\r\nvoid *addr;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1sram_lock, cpu), flags);\r\naddr = _sram_alloc_max(&per_cpu(free_l1_ssram_head, cpu),\r\n&per_cpu(used_l1_ssram_head, cpu), psize);\r\nspin_unlock_irqrestore(&per_cpu(l1sram_lock, cpu), flags);\r\nreturn addr;\r\n}\r\nint l1sram_free(const void *addr)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nspin_lock_irqsave(&per_cpu(l1sram_lock, cpu), flags);\r\nret = _sram_free(addr, &per_cpu(free_l1_ssram_head, cpu),\r\n&per_cpu(used_l1_ssram_head, cpu));\r\nspin_unlock_irqrestore(&per_cpu(l1sram_lock, cpu), flags);\r\nreturn ret;\r\n}\r\nvoid *l2_sram_alloc(size_t size)\r\n{\r\n#if L2_LENGTH != 0\r\nunsigned long flags;\r\nvoid *addr;\r\nspin_lock_irqsave(&l2_sram_lock, flags);\r\naddr = _sram_alloc(size, &free_l2_sram_head,\r\n&used_l2_sram_head);\r\nspin_unlock_irqrestore(&l2_sram_lock, flags);\r\npr_debug("Allocated address in l2_sram_alloc is 0x%lx+0x%lx\n",\r\n(long unsigned int)addr, size);\r\nreturn addr;\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\nvoid *l2_sram_zalloc(size_t size)\r\n{\r\nvoid *addr = l2_sram_alloc(size);\r\nif (addr)\r\nmemset(addr, 0x00, size);\r\nreturn addr;\r\n}\r\nint l2_sram_free(const void *addr)\r\n{\r\n#if L2_LENGTH != 0\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&l2_sram_lock, flags);\r\nret = _sram_free(addr, &free_l2_sram_head,\r\n&used_l2_sram_head);\r\nspin_unlock_irqrestore(&l2_sram_lock, flags);\r\nreturn ret;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nint sram_free_with_lsl(const void *addr)\r\n{\r\nstruct sram_list_struct *lsl, **tmp;\r\nstruct mm_struct *mm = current->mm;\r\nint ret = -1;\r\nfor (tmp = &mm->context.sram_list; *tmp; tmp = &(*tmp)->next)\r\nif ((*tmp)->addr == addr) {\r\nlsl = *tmp;\r\nret = sram_free(addr);\r\n*tmp = lsl->next;\r\nkfree(lsl);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid *sram_alloc_with_lsl(size_t size, unsigned long flags)\r\n{\r\nvoid *addr = NULL;\r\nstruct sram_list_struct *lsl = NULL;\r\nstruct mm_struct *mm = current->mm;\r\nlsl = kzalloc(sizeof(struct sram_list_struct), GFP_KERNEL);\r\nif (!lsl)\r\nreturn NULL;\r\nif (flags & L1_INST_SRAM)\r\naddr = l1_inst_sram_alloc(size);\r\nif (addr == NULL && (flags & L1_DATA_A_SRAM))\r\naddr = l1_data_A_sram_alloc(size);\r\nif (addr == NULL && (flags & L1_DATA_B_SRAM))\r\naddr = l1_data_B_sram_alloc(size);\r\nif (addr == NULL && (flags & L2_SRAM))\r\naddr = l2_sram_alloc(size);\r\nif (addr == NULL) {\r\nkfree(lsl);\r\nreturn NULL;\r\n}\r\nlsl->addr = addr;\r\nlsl->length = size;\r\nlsl->next = mm->context.sram_list;\r\nmm->context.sram_list = lsl;\r\nreturn addr;\r\n}\r\nstatic int _sram_proc_show(struct seq_file *m, const char *desc,\r\nstruct sram_piece *pfree_head,\r\nstruct sram_piece *pused_head)\r\n{\r\nstruct sram_piece *pslot;\r\nif (!pfree_head || !pused_head)\r\nreturn -1;\r\nseq_printf(m, "--- SRAM %-14s Size PID State \n", desc);\r\npslot = pused_head->next;\r\nwhile (pslot != NULL) {\r\nseq_printf(m, "%p-%p %10i %5i %-10s\n",\r\npslot->paddr, pslot->paddr + pslot->size,\r\npslot->size, pslot->pid, "ALLOCATED");\r\npslot = pslot->next;\r\n}\r\npslot = pfree_head->next;\r\nwhile (pslot != NULL) {\r\nseq_printf(m, "%p-%p %10i %5i %-10s\n",\r\npslot->paddr, pslot->paddr + pslot->size,\r\npslot->size, pslot->pid, "FREE");\r\npslot = pslot->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sram_proc_show(struct seq_file *m, void *v)\r\n{\r\nunsigned int cpu;\r\nfor (cpu = 0; cpu < num_possible_cpus(); ++cpu) {\r\nif (_sram_proc_show(m, "Scratchpad",\r\n&per_cpu(free_l1_ssram_head, cpu), &per_cpu(used_l1_ssram_head, cpu)))\r\ngoto not_done;\r\n#if L1_DATA_A_LENGTH != 0\r\nif (_sram_proc_show(m, "L1 Data A",\r\n&per_cpu(free_l1_data_A_sram_head, cpu),\r\n&per_cpu(used_l1_data_A_sram_head, cpu)))\r\ngoto not_done;\r\n#endif\r\n#if L1_DATA_B_LENGTH != 0\r\nif (_sram_proc_show(m, "L1 Data B",\r\n&per_cpu(free_l1_data_B_sram_head, cpu),\r\n&per_cpu(used_l1_data_B_sram_head, cpu)))\r\ngoto not_done;\r\n#endif\r\n#if L1_CODE_LENGTH != 0\r\nif (_sram_proc_show(m, "L1 Instruction",\r\n&per_cpu(free_l1_inst_sram_head, cpu),\r\n&per_cpu(used_l1_inst_sram_head, cpu)))\r\ngoto not_done;\r\n#endif\r\n}\r\n#if L2_LENGTH != 0\r\nif (_sram_proc_show(m, "L2", &free_l2_sram_head, &used_l2_sram_head))\r\ngoto not_done;\r\n#endif\r\nnot_done:\r\nreturn 0;\r\n}\r\nstatic int sram_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sram_proc_show, NULL);\r\n}\r\nstatic int __init sram_proc_init(void)\r\n{\r\nstruct proc_dir_entry *ptr;\r\nptr = proc_create("sram", S_IRUGO, NULL, &sram_proc_ops);\r\nif (!ptr) {\r\nprintk(KERN_WARNING "unable to create /proc/sram\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}
