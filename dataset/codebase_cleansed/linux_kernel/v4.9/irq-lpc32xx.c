static inline u32 lpc32xx_ic_read(struct lpc32xx_irq_chip *ic, u32 reg)\r\n{\r\nreturn readl_relaxed(ic->base + reg);\r\n}\r\nstatic inline void lpc32xx_ic_write(struct lpc32xx_irq_chip *ic,\r\nu32 reg, u32 val)\r\n{\r\nwritel_relaxed(val, ic->base + reg);\r\n}\r\nstatic void lpc32xx_irq_mask(struct irq_data *d)\r\n{\r\nstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\r\nu32 val, mask = BIT(d->hwirq);\r\nval = lpc32xx_ic_read(ic, LPC32XX_INTC_MASK) & ~mask;\r\nlpc32xx_ic_write(ic, LPC32XX_INTC_MASK, val);\r\n}\r\nstatic void lpc32xx_irq_unmask(struct irq_data *d)\r\n{\r\nstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\r\nu32 val, mask = BIT(d->hwirq);\r\nval = lpc32xx_ic_read(ic, LPC32XX_INTC_MASK) | mask;\r\nlpc32xx_ic_write(ic, LPC32XX_INTC_MASK, val);\r\n}\r\nstatic void lpc32xx_irq_ack(struct irq_data *d)\r\n{\r\nstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\r\nu32 mask = BIT(d->hwirq);\r\nlpc32xx_ic_write(ic, LPC32XX_INTC_RAW, mask);\r\n}\r\nstatic int lpc32xx_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct lpc32xx_irq_chip *ic = irq_data_get_irq_chip_data(d);\r\nu32 val, mask = BIT(d->hwirq);\r\nbool high, edge;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nedge = true;\r\nhigh = true;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nedge = true;\r\nhigh = false;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nedge = false;\r\nhigh = true;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nedge = false;\r\nhigh = false;\r\nbreak;\r\ndefault:\r\npr_info("unsupported irq type %d\n", type);\r\nreturn -EINVAL;\r\n}\r\nirqd_set_trigger_type(d, type);\r\nval = lpc32xx_ic_read(ic, LPC32XX_INTC_POL);\r\nif (high)\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\nlpc32xx_ic_write(ic, LPC32XX_INTC_POL, val);\r\nval = lpc32xx_ic_read(ic, LPC32XX_INTC_TYPE);\r\nif (edge) {\r\nval |= mask;\r\nirq_set_handler_locked(d, handle_edge_irq);\r\n} else {\r\nval &= ~mask;\r\nirq_set_handler_locked(d, handle_level_irq);\r\n}\r\nlpc32xx_ic_write(ic, LPC32XX_INTC_TYPE, val);\r\nreturn 0;\r\n}\r\nstatic void __exception_irq_entry lpc32xx_handle_irq(struct pt_regs *regs)\r\n{\r\nstruct lpc32xx_irq_chip *ic = lpc32xx_mic_irqc;\r\nu32 hwirq = lpc32xx_ic_read(ic, LPC32XX_INTC_STAT), irq;\r\nwhile (hwirq) {\r\nirq = __ffs(hwirq);\r\nhwirq &= ~BIT(irq);\r\nhandle_domain_irq(lpc32xx_mic_irqc->domain, irq, regs);\r\n}\r\n}\r\nstatic void lpc32xx_sic_handler(struct irq_desc *desc)\r\n{\r\nstruct lpc32xx_irq_chip *ic = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nu32 hwirq = lpc32xx_ic_read(ic, LPC32XX_INTC_STAT), irq;\r\nchained_irq_enter(chip, desc);\r\nwhile (hwirq) {\r\nirq = __ffs(hwirq);\r\nhwirq &= ~BIT(irq);\r\ngeneric_handle_irq(irq_find_mapping(ic->domain, irq));\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int lpc32xx_irq_domain_map(struct irq_domain *id, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct lpc32xx_irq_chip *ic = id->host_data;\r\nirq_set_chip_data(virq, ic);\r\nirq_set_chip_and_handler(virq, &ic->chip, handle_level_irq);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_noprobe(virq);\r\nreturn 0;\r\n}\r\nstatic void lpc32xx_irq_domain_unmap(struct irq_domain *id, unsigned int virq)\r\n{\r\nirq_set_chip_and_handler(virq, NULL, NULL);\r\n}\r\nstatic int __init lpc32xx_of_ic_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct lpc32xx_irq_chip *irqc;\r\nbool is_mic = of_device_is_compatible(node, "nxp,lpc3220-mic");\r\nconst __be32 *reg = of_get_property(node, "reg", NULL);\r\nu32 parent_irq, i, addr = reg ? be32_to_cpu(*reg) : 0;\r\nirqc = kzalloc(sizeof(*irqc), GFP_KERNEL);\r\nif (!irqc)\r\nreturn -ENOMEM;\r\nirqc->base = of_iomap(node, 0);\r\nif (!irqc->base) {\r\npr_err("%s: unable to map registers\n", node->full_name);\r\nkfree(irqc);\r\nreturn -EINVAL;\r\n}\r\nirqc->chip.irq_ack = lpc32xx_irq_ack;\r\nirqc->chip.irq_mask = lpc32xx_irq_mask;\r\nirqc->chip.irq_unmask = lpc32xx_irq_unmask;\r\nirqc->chip.irq_set_type = lpc32xx_irq_set_type;\r\nif (is_mic)\r\nirqc->chip.name = kasprintf(GFP_KERNEL, "%08x.mic", addr);\r\nelse\r\nirqc->chip.name = kasprintf(GFP_KERNEL, "%08x.sic", addr);\r\nirqc->domain = irq_domain_add_linear(node, NR_LPC32XX_IC_IRQS,\r\n&lpc32xx_irq_domain_ops, irqc);\r\nif (!irqc->domain) {\r\npr_err("unable to add irq domain\n");\r\niounmap(irqc->base);\r\nkfree(irqc->chip.name);\r\nkfree(irqc);\r\nreturn -ENODEV;\r\n}\r\nif (is_mic) {\r\nlpc32xx_mic_irqc = irqc;\r\nset_handle_irq(lpc32xx_handle_irq);\r\n} else {\r\nfor (i = 0; i < of_irq_count(node); i++) {\r\nparent_irq = irq_of_parse_and_map(node, i);\r\nif (parent_irq)\r\nirq_set_chained_handler_and_data(parent_irq,\r\nlpc32xx_sic_handler, irqc);\r\n}\r\n}\r\nlpc32xx_ic_write(irqc, LPC32XX_INTC_MASK, 0x00);\r\nlpc32xx_ic_write(irqc, LPC32XX_INTC_POL, 0x00);\r\nlpc32xx_ic_write(irqc, LPC32XX_INTC_TYPE, 0x00);\r\nreturn 0;\r\n}
