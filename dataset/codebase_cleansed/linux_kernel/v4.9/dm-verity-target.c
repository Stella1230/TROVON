static void dm_bufio_alloc_callback(struct dm_buffer *buf)\r\n{\r\nstruct buffer_aux *aux = dm_bufio_get_aux_data(buf);\r\naux->hash_verified = 0;\r\n}\r\nstatic sector_t verity_map_sector(struct dm_verity *v, sector_t bi_sector)\r\n{\r\nreturn v->data_start + dm_target_offset(v->ti, bi_sector);\r\n}\r\nstatic sector_t verity_position_at_level(struct dm_verity *v, sector_t block,\r\nint level)\r\n{\r\nreturn block >> (level * v->hash_per_block_bits);\r\n}\r\nstatic int verity_hash_init(struct dm_verity *v, struct shash_desc *desc)\r\n{\r\nint r;\r\ndesc->tfm = v->tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nr = crypto_shash_init(desc);\r\nif (unlikely(r < 0)) {\r\nDMERR("crypto_shash_init failed: %d", r);\r\nreturn r;\r\n}\r\nif (likely(v->version >= 1)) {\r\nr = crypto_shash_update(desc, v->salt, v->salt_size);\r\nif (unlikely(r < 0)) {\r\nDMERR("crypto_shash_update failed: %d", r);\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int verity_hash_update(struct dm_verity *v, struct shash_desc *desc,\r\nconst u8 *data, size_t len)\r\n{\r\nint r = crypto_shash_update(desc, data, len);\r\nif (unlikely(r < 0))\r\nDMERR("crypto_shash_update failed: %d", r);\r\nreturn r;\r\n}\r\nstatic int verity_hash_final(struct dm_verity *v, struct shash_desc *desc,\r\nu8 *digest)\r\n{\r\nint r;\r\nif (unlikely(!v->version)) {\r\nr = crypto_shash_update(desc, v->salt, v->salt_size);\r\nif (r < 0) {\r\nDMERR("crypto_shash_update failed: %d", r);\r\nreturn r;\r\n}\r\n}\r\nr = crypto_shash_final(desc, digest);\r\nif (unlikely(r < 0))\r\nDMERR("crypto_shash_final failed: %d", r);\r\nreturn r;\r\n}\r\nint verity_hash(struct dm_verity *v, struct shash_desc *desc,\r\nconst u8 *data, size_t len, u8 *digest)\r\n{\r\nint r;\r\nr = verity_hash_init(v, desc);\r\nif (unlikely(r < 0))\r\nreturn r;\r\nr = verity_hash_update(v, desc, data, len);\r\nif (unlikely(r < 0))\r\nreturn r;\r\nreturn verity_hash_final(v, desc, digest);\r\n}\r\nstatic void verity_hash_at_level(struct dm_verity *v, sector_t block, int level,\r\nsector_t *hash_block, unsigned *offset)\r\n{\r\nsector_t position = verity_position_at_level(v, block, level);\r\nunsigned idx;\r\n*hash_block = v->hash_level_block[level] + (position >> v->hash_per_block_bits);\r\nif (!offset)\r\nreturn;\r\nidx = position & ((1 << v->hash_per_block_bits) - 1);\r\nif (!v->version)\r\n*offset = idx * v->digest_size;\r\nelse\r\n*offset = idx << (v->hash_dev_block_bits - v->hash_per_block_bits);\r\n}\r\nstatic int verity_handle_err(struct dm_verity *v, enum verity_block_type type,\r\nunsigned long long block)\r\n{\r\nchar verity_env[DM_VERITY_ENV_LENGTH];\r\nchar *envp[] = { verity_env, NULL };\r\nconst char *type_str = "";\r\nstruct mapped_device *md = dm_table_get_md(v->ti->table);\r\nv->hash_failed = 1;\r\nif (v->corrupted_errs >= DM_VERITY_MAX_CORRUPTED_ERRS)\r\ngoto out;\r\nv->corrupted_errs++;\r\nswitch (type) {\r\ncase DM_VERITY_BLOCK_TYPE_DATA:\r\ntype_str = "data";\r\nbreak;\r\ncase DM_VERITY_BLOCK_TYPE_METADATA:\r\ntype_str = "metadata";\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nDMERR("%s: %s block %llu is corrupted", v->data_dev->name, type_str,\r\nblock);\r\nif (v->corrupted_errs == DM_VERITY_MAX_CORRUPTED_ERRS)\r\nDMERR("%s: reached maximum errors", v->data_dev->name);\r\nsnprintf(verity_env, DM_VERITY_ENV_LENGTH, "%s=%d,%llu",\r\nDM_VERITY_ENV_VAR_NAME, type, block);\r\nkobject_uevent_env(&disk_to_dev(dm_disk(md))->kobj, KOBJ_CHANGE, envp);\r\nout:\r\nif (v->mode == DM_VERITY_MODE_LOGGING)\r\nreturn 0;\r\nif (v->mode == DM_VERITY_MODE_RESTART)\r\nkernel_restart("dm-verity device corrupted");\r\nreturn 1;\r\n}\r\nstatic int verity_verify_level(struct dm_verity *v, struct dm_verity_io *io,\r\nsector_t block, int level, bool skip_unverified,\r\nu8 *want_digest)\r\n{\r\nstruct dm_buffer *buf;\r\nstruct buffer_aux *aux;\r\nu8 *data;\r\nint r;\r\nsector_t hash_block;\r\nunsigned offset;\r\nverity_hash_at_level(v, block, level, &hash_block, &offset);\r\ndata = dm_bufio_read(v->bufio, hash_block, &buf);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\naux = dm_bufio_get_aux_data(buf);\r\nif (!aux->hash_verified) {\r\nif (skip_unverified) {\r\nr = 1;\r\ngoto release_ret_r;\r\n}\r\nr = verity_hash(v, verity_io_hash_desc(v, io),\r\ndata, 1 << v->hash_dev_block_bits,\r\nverity_io_real_digest(v, io));\r\nif (unlikely(r < 0))\r\ngoto release_ret_r;\r\nif (likely(memcmp(verity_io_real_digest(v, io), want_digest,\r\nv->digest_size) == 0))\r\naux->hash_verified = 1;\r\nelse if (verity_fec_decode(v, io,\r\nDM_VERITY_BLOCK_TYPE_METADATA,\r\nhash_block, data, NULL) == 0)\r\naux->hash_verified = 1;\r\nelse if (verity_handle_err(v,\r\nDM_VERITY_BLOCK_TYPE_METADATA,\r\nhash_block)) {\r\nr = -EIO;\r\ngoto release_ret_r;\r\n}\r\n}\r\ndata += offset;\r\nmemcpy(want_digest, data, v->digest_size);\r\nr = 0;\r\nrelease_ret_r:\r\ndm_bufio_release(buf);\r\nreturn r;\r\n}\r\nint verity_hash_for_block(struct dm_verity *v, struct dm_verity_io *io,\r\nsector_t block, u8 *digest, bool *is_zero)\r\n{\r\nint r = 0, i;\r\nif (likely(v->levels)) {\r\nr = verity_verify_level(v, io, block, 0, true, digest);\r\nif (likely(r <= 0))\r\ngoto out;\r\n}\r\nmemcpy(digest, v->root_digest, v->digest_size);\r\nfor (i = v->levels - 1; i >= 0; i--) {\r\nr = verity_verify_level(v, io, block, i, false, digest);\r\nif (unlikely(r))\r\ngoto out;\r\n}\r\nout:\r\nif (!r && v->zero_digest)\r\n*is_zero = !memcmp(v->zero_digest, digest, v->digest_size);\r\nelse\r\n*is_zero = false;\r\nreturn r;\r\n}\r\nint verity_for_bv_block(struct dm_verity *v, struct dm_verity_io *io,\r\nstruct bvec_iter *iter,\r\nint (*process)(struct dm_verity *v,\r\nstruct dm_verity_io *io, u8 *data,\r\nsize_t len))\r\n{\r\nunsigned todo = 1 << v->data_dev_block_bits;\r\nstruct bio *bio = dm_bio_from_per_bio_data(io, v->ti->per_io_data_size);\r\ndo {\r\nint r;\r\nu8 *page;\r\nunsigned len;\r\nstruct bio_vec bv = bio_iter_iovec(bio, *iter);\r\npage = kmap_atomic(bv.bv_page);\r\nlen = bv.bv_len;\r\nif (likely(len >= todo))\r\nlen = todo;\r\nr = process(v, io, page + bv.bv_offset, len);\r\nkunmap_atomic(page);\r\nif (r < 0)\r\nreturn r;\r\nbio_advance_iter(bio, iter, len);\r\ntodo -= len;\r\n} while (todo);\r\nreturn 0;\r\n}\r\nstatic int verity_bv_hash_update(struct dm_verity *v, struct dm_verity_io *io,\r\nu8 *data, size_t len)\r\n{\r\nreturn verity_hash_update(v, verity_io_hash_desc(v, io), data, len);\r\n}\r\nstatic int verity_bv_zero(struct dm_verity *v, struct dm_verity_io *io,\r\nu8 *data, size_t len)\r\n{\r\nmemset(data, 0, len);\r\nreturn 0;\r\n}\r\nstatic int verity_verify_io(struct dm_verity_io *io)\r\n{\r\nbool is_zero;\r\nstruct dm_verity *v = io->v;\r\nstruct bvec_iter start;\r\nunsigned b;\r\nfor (b = 0; b < io->n_blocks; b++) {\r\nint r;\r\nstruct shash_desc *desc = verity_io_hash_desc(v, io);\r\nr = verity_hash_for_block(v, io, io->block + b,\r\nverity_io_want_digest(v, io),\r\n&is_zero);\r\nif (unlikely(r < 0))\r\nreturn r;\r\nif (is_zero) {\r\nr = verity_for_bv_block(v, io, &io->iter,\r\nverity_bv_zero);\r\nif (unlikely(r < 0))\r\nreturn r;\r\ncontinue;\r\n}\r\nr = verity_hash_init(v, desc);\r\nif (unlikely(r < 0))\r\nreturn r;\r\nstart = io->iter;\r\nr = verity_for_bv_block(v, io, &io->iter, verity_bv_hash_update);\r\nif (unlikely(r < 0))\r\nreturn r;\r\nr = verity_hash_final(v, desc, verity_io_real_digest(v, io));\r\nif (unlikely(r < 0))\r\nreturn r;\r\nif (likely(memcmp(verity_io_real_digest(v, io),\r\nverity_io_want_digest(v, io), v->digest_size) == 0))\r\ncontinue;\r\nelse if (verity_fec_decode(v, io, DM_VERITY_BLOCK_TYPE_DATA,\r\nio->block + b, NULL, &start) == 0)\r\ncontinue;\r\nelse if (verity_handle_err(v, DM_VERITY_BLOCK_TYPE_DATA,\r\nio->block + b))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void verity_finish_io(struct dm_verity_io *io, int error)\r\n{\r\nstruct dm_verity *v = io->v;\r\nstruct bio *bio = dm_bio_from_per_bio_data(io, v->ti->per_io_data_size);\r\nbio->bi_end_io = io->orig_bi_end_io;\r\nbio->bi_error = error;\r\nverity_fec_finish_io(io);\r\nbio_endio(bio);\r\n}\r\nstatic void verity_work(struct work_struct *w)\r\n{\r\nstruct dm_verity_io *io = container_of(w, struct dm_verity_io, work);\r\nverity_finish_io(io, verity_verify_io(io));\r\n}\r\nstatic void verity_end_io(struct bio *bio)\r\n{\r\nstruct dm_verity_io *io = bio->bi_private;\r\nif (bio->bi_error && !verity_fec_is_enabled(io->v)) {\r\nverity_finish_io(io, bio->bi_error);\r\nreturn;\r\n}\r\nINIT_WORK(&io->work, verity_work);\r\nqueue_work(io->v->verify_wq, &io->work);\r\n}\r\nstatic void verity_prefetch_io(struct work_struct *work)\r\n{\r\nstruct dm_verity_prefetch_work *pw =\r\ncontainer_of(work, struct dm_verity_prefetch_work, work);\r\nstruct dm_verity *v = pw->v;\r\nint i;\r\nfor (i = v->levels - 2; i >= 0; i--) {\r\nsector_t hash_block_start;\r\nsector_t hash_block_end;\r\nverity_hash_at_level(v, pw->block, i, &hash_block_start, NULL);\r\nverity_hash_at_level(v, pw->block + pw->n_blocks - 1, i, &hash_block_end, NULL);\r\nif (!i) {\r\nunsigned cluster = ACCESS_ONCE(dm_verity_prefetch_cluster);\r\ncluster >>= v->data_dev_block_bits;\r\nif (unlikely(!cluster))\r\ngoto no_prefetch_cluster;\r\nif (unlikely(cluster & (cluster - 1)))\r\ncluster = 1 << __fls(cluster);\r\nhash_block_start &= ~(sector_t)(cluster - 1);\r\nhash_block_end |= cluster - 1;\r\nif (unlikely(hash_block_end >= v->hash_blocks))\r\nhash_block_end = v->hash_blocks - 1;\r\n}\r\nno_prefetch_cluster:\r\ndm_bufio_prefetch(v->bufio, hash_block_start,\r\nhash_block_end - hash_block_start + 1);\r\n}\r\nkfree(pw);\r\n}\r\nstatic void verity_submit_prefetch(struct dm_verity *v, struct dm_verity_io *io)\r\n{\r\nstruct dm_verity_prefetch_work *pw;\r\npw = kmalloc(sizeof(struct dm_verity_prefetch_work),\r\nGFP_NOIO | __GFP_NORETRY | __GFP_NOMEMALLOC | __GFP_NOWARN);\r\nif (!pw)\r\nreturn;\r\nINIT_WORK(&pw->work, verity_prefetch_io);\r\npw->v = v;\r\npw->block = io->block;\r\npw->n_blocks = io->n_blocks;\r\nqueue_work(v->verify_wq, &pw->work);\r\n}\r\nstatic int verity_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nstruct dm_verity_io *io;\r\nbio->bi_bdev = v->data_dev->bdev;\r\nbio->bi_iter.bi_sector = verity_map_sector(v, bio->bi_iter.bi_sector);\r\nif (((unsigned)bio->bi_iter.bi_sector | bio_sectors(bio)) &\r\n((1 << (v->data_dev_block_bits - SECTOR_SHIFT)) - 1)) {\r\nDMERR_LIMIT("unaligned io");\r\nreturn -EIO;\r\n}\r\nif (bio_end_sector(bio) >>\r\n(v->data_dev_block_bits - SECTOR_SHIFT) > v->data_blocks) {\r\nDMERR_LIMIT("io out of range");\r\nreturn -EIO;\r\n}\r\nif (bio_data_dir(bio) == WRITE)\r\nreturn -EIO;\r\nio = dm_per_bio_data(bio, ti->per_io_data_size);\r\nio->v = v;\r\nio->orig_bi_end_io = bio->bi_end_io;\r\nio->block = bio->bi_iter.bi_sector >> (v->data_dev_block_bits - SECTOR_SHIFT);\r\nio->n_blocks = bio->bi_iter.bi_size >> v->data_dev_block_bits;\r\nbio->bi_end_io = verity_end_io;\r\nbio->bi_private = io;\r\nio->iter = bio->bi_iter;\r\nverity_fec_init_io(io);\r\nverity_submit_prefetch(v, io);\r\ngeneric_make_request(bio);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\nstatic void verity_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nunsigned args = 0;\r\nunsigned sz = 0;\r\nunsigned x;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("%c", v->hash_failed ? 'C' : 'V');\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%u %s %s %u %u %llu %llu %s ",\r\nv->version,\r\nv->data_dev->name,\r\nv->hash_dev->name,\r\n1 << v->data_dev_block_bits,\r\n1 << v->hash_dev_block_bits,\r\n(unsigned long long)v->data_blocks,\r\n(unsigned long long)v->hash_start,\r\nv->alg_name\r\n);\r\nfor (x = 0; x < v->digest_size; x++)\r\nDMEMIT("%02x", v->root_digest[x]);\r\nDMEMIT(" ");\r\nif (!v->salt_size)\r\nDMEMIT("-");\r\nelse\r\nfor (x = 0; x < v->salt_size; x++)\r\nDMEMIT("%02x", v->salt[x]);\r\nif (v->mode != DM_VERITY_MODE_EIO)\r\nargs++;\r\nif (verity_fec_is_enabled(v))\r\nargs += DM_VERITY_OPTS_FEC;\r\nif (v->zero_digest)\r\nargs++;\r\nif (!args)\r\nreturn;\r\nDMEMIT(" %u", args);\r\nif (v->mode != DM_VERITY_MODE_EIO) {\r\nDMEMIT(" ");\r\nswitch (v->mode) {\r\ncase DM_VERITY_MODE_LOGGING:\r\nDMEMIT(DM_VERITY_OPT_LOGGING);\r\nbreak;\r\ncase DM_VERITY_MODE_RESTART:\r\nDMEMIT(DM_VERITY_OPT_RESTART);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nif (v->zero_digest)\r\nDMEMIT(" " DM_VERITY_OPT_IGN_ZEROES);\r\nsz = verity_fec_status_table(v, sz, result, maxlen);\r\nbreak;\r\n}\r\n}\r\nstatic int verity_prepare_ioctl(struct dm_target *ti,\r\nstruct block_device **bdev, fmode_t *mode)\r\n{\r\nstruct dm_verity *v = ti->private;\r\n*bdev = v->data_dev->bdev;\r\nif (v->data_start ||\r\nti->len != i_size_read(v->data_dev->bdev->bd_inode) >> SECTOR_SHIFT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int verity_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nreturn fn(ti, v->data_dev, v->data_start, ti->len, data);\r\n}\r\nstatic void verity_io_hints(struct dm_target *ti, struct queue_limits *limits)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nif (limits->logical_block_size < 1 << v->data_dev_block_bits)\r\nlimits->logical_block_size = 1 << v->data_dev_block_bits;\r\nif (limits->physical_block_size < 1 << v->data_dev_block_bits)\r\nlimits->physical_block_size = 1 << v->data_dev_block_bits;\r\nblk_limits_io_min(limits, limits->logical_block_size);\r\n}\r\nstatic void verity_dtr(struct dm_target *ti)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nif (v->verify_wq)\r\ndestroy_workqueue(v->verify_wq);\r\nif (v->bufio)\r\ndm_bufio_client_destroy(v->bufio);\r\nkfree(v->salt);\r\nkfree(v->root_digest);\r\nkfree(v->zero_digest);\r\nif (v->tfm)\r\ncrypto_free_shash(v->tfm);\r\nkfree(v->alg_name);\r\nif (v->hash_dev)\r\ndm_put_device(ti, v->hash_dev);\r\nif (v->data_dev)\r\ndm_put_device(ti, v->data_dev);\r\nverity_fec_dtr(v);\r\nkfree(v);\r\n}\r\nstatic int verity_alloc_zero_digest(struct dm_verity *v)\r\n{\r\nint r = -ENOMEM;\r\nstruct shash_desc *desc;\r\nu8 *zero_data;\r\nv->zero_digest = kmalloc(v->digest_size, GFP_KERNEL);\r\nif (!v->zero_digest)\r\nreturn r;\r\ndesc = kmalloc(v->shash_descsize, GFP_KERNEL);\r\nif (!desc)\r\nreturn r;\r\nzero_data = kzalloc(1 << v->data_dev_block_bits, GFP_KERNEL);\r\nif (!zero_data)\r\ngoto out;\r\nr = verity_hash(v, desc, zero_data, 1 << v->data_dev_block_bits,\r\nv->zero_digest);\r\nout:\r\nkfree(desc);\r\nkfree(zero_data);\r\nreturn r;\r\n}\r\nstatic int verity_parse_opt_args(struct dm_arg_set *as, struct dm_verity *v)\r\n{\r\nint r;\r\nunsigned argc;\r\nstruct dm_target *ti = v->ti;\r\nconst char *arg_name;\r\nstatic struct dm_arg _args[] = {\r\n{0, DM_VERITY_OPTS_MAX, "Invalid number of feature args"},\r\n};\r\nr = dm_read_arg_group(_args, as, &argc, &ti->error);\r\nif (r)\r\nreturn -EINVAL;\r\nif (!argc)\r\nreturn 0;\r\ndo {\r\narg_name = dm_shift_arg(as);\r\nargc--;\r\nif (!strcasecmp(arg_name, DM_VERITY_OPT_LOGGING)) {\r\nv->mode = DM_VERITY_MODE_LOGGING;\r\ncontinue;\r\n} else if (!strcasecmp(arg_name, DM_VERITY_OPT_RESTART)) {\r\nv->mode = DM_VERITY_MODE_RESTART;\r\ncontinue;\r\n} else if (!strcasecmp(arg_name, DM_VERITY_OPT_IGN_ZEROES)) {\r\nr = verity_alloc_zero_digest(v);\r\nif (r) {\r\nti->error = "Cannot allocate zero digest";\r\nreturn r;\r\n}\r\ncontinue;\r\n} else if (verity_is_fec_opt_arg(arg_name)) {\r\nr = verity_fec_parse_opt_args(as, v, &argc, arg_name);\r\nif (r)\r\nreturn r;\r\ncontinue;\r\n}\r\nti->error = "Unrecognized verity feature request";\r\nreturn -EINVAL;\r\n} while (argc && !r);\r\nreturn r;\r\n}\r\nstatic int verity_ctr(struct dm_target *ti, unsigned argc, char **argv)\r\n{\r\nstruct dm_verity *v;\r\nstruct dm_arg_set as;\r\nunsigned int num;\r\nunsigned long long num_ll;\r\nint r;\r\nint i;\r\nsector_t hash_position;\r\nchar dummy;\r\nv = kzalloc(sizeof(struct dm_verity), GFP_KERNEL);\r\nif (!v) {\r\nti->error = "Cannot allocate verity structure";\r\nreturn -ENOMEM;\r\n}\r\nti->private = v;\r\nv->ti = ti;\r\nr = verity_fec_ctr_alloc(v);\r\nif (r)\r\ngoto bad;\r\nif ((dm_table_get_mode(ti->table) & ~FMODE_READ)) {\r\nti->error = "Device must be readonly";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nif (argc < 10) {\r\nti->error = "Not enough arguments";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nif (sscanf(argv[0], "%u%c", &num, &dummy) != 1 ||\r\nnum > 1) {\r\nti->error = "Invalid version";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->version = num;\r\nr = dm_get_device(ti, argv[1], FMODE_READ, &v->data_dev);\r\nif (r) {\r\nti->error = "Data device lookup failed";\r\ngoto bad;\r\n}\r\nr = dm_get_device(ti, argv[2], FMODE_READ, &v->hash_dev);\r\nif (r) {\r\nti->error = "Data device lookup failed";\r\ngoto bad;\r\n}\r\nif (sscanf(argv[3], "%u%c", &num, &dummy) != 1 ||\r\n!num || (num & (num - 1)) ||\r\nnum < bdev_logical_block_size(v->data_dev->bdev) ||\r\nnum > PAGE_SIZE) {\r\nti->error = "Invalid data device block size";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->data_dev_block_bits = __ffs(num);\r\nif (sscanf(argv[4], "%u%c", &num, &dummy) != 1 ||\r\n!num || (num & (num - 1)) ||\r\nnum < bdev_logical_block_size(v->hash_dev->bdev) ||\r\nnum > INT_MAX) {\r\nti->error = "Invalid hash device block size";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->hash_dev_block_bits = __ffs(num);\r\nif (sscanf(argv[5], "%llu%c", &num_ll, &dummy) != 1 ||\r\n(sector_t)(num_ll << (v->data_dev_block_bits - SECTOR_SHIFT))\r\n>> (v->data_dev_block_bits - SECTOR_SHIFT) != num_ll) {\r\nti->error = "Invalid data blocks";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->data_blocks = num_ll;\r\nif (ti->len > (v->data_blocks << (v->data_dev_block_bits - SECTOR_SHIFT))) {\r\nti->error = "Data device is too small";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nif (sscanf(argv[6], "%llu%c", &num_ll, &dummy) != 1 ||\r\n(sector_t)(num_ll << (v->hash_dev_block_bits - SECTOR_SHIFT))\r\n>> (v->hash_dev_block_bits - SECTOR_SHIFT) != num_ll) {\r\nti->error = "Invalid hash start";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->hash_start = num_ll;\r\nv->alg_name = kstrdup(argv[7], GFP_KERNEL);\r\nif (!v->alg_name) {\r\nti->error = "Cannot allocate algorithm name";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nv->tfm = crypto_alloc_shash(v->alg_name, 0, 0);\r\nif (IS_ERR(v->tfm)) {\r\nti->error = "Cannot initialize hash function";\r\nr = PTR_ERR(v->tfm);\r\nv->tfm = NULL;\r\ngoto bad;\r\n}\r\nv->digest_size = crypto_shash_digestsize(v->tfm);\r\nif ((1 << v->hash_dev_block_bits) < v->digest_size * 2) {\r\nti->error = "Digest size too big";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->shash_descsize =\r\nsizeof(struct shash_desc) + crypto_shash_descsize(v->tfm);\r\nv->root_digest = kmalloc(v->digest_size, GFP_KERNEL);\r\nif (!v->root_digest) {\r\nti->error = "Cannot allocate root digest";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nif (strlen(argv[8]) != v->digest_size * 2 ||\r\nhex2bin(v->root_digest, argv[8], v->digest_size)) {\r\nti->error = "Invalid root digest";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nif (strcmp(argv[9], "-")) {\r\nv->salt_size = strlen(argv[9]) / 2;\r\nv->salt = kmalloc(v->salt_size, GFP_KERNEL);\r\nif (!v->salt) {\r\nti->error = "Cannot allocate salt";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nif (strlen(argv[9]) != v->salt_size * 2 ||\r\nhex2bin(v->salt, argv[9], v->salt_size)) {\r\nti->error = "Invalid salt";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\n}\r\nargv += 10;\r\nargc -= 10;\r\nif (argc) {\r\nas.argc = argc;\r\nas.argv = argv;\r\nr = verity_parse_opt_args(&as, v);\r\nif (r < 0)\r\ngoto bad;\r\n}\r\nv->hash_per_block_bits =\r\n__fls((1 << v->hash_dev_block_bits) / v->digest_size);\r\nv->levels = 0;\r\nif (v->data_blocks)\r\nwhile (v->hash_per_block_bits * v->levels < 64 &&\r\n(unsigned long long)(v->data_blocks - 1) >>\r\n(v->hash_per_block_bits * v->levels))\r\nv->levels++;\r\nif (v->levels > DM_VERITY_MAX_LEVELS) {\r\nti->error = "Too many tree levels";\r\nr = -E2BIG;\r\ngoto bad;\r\n}\r\nhash_position = v->hash_start;\r\nfor (i = v->levels - 1; i >= 0; i--) {\r\nsector_t s;\r\nv->hash_level_block[i] = hash_position;\r\ns = (v->data_blocks + ((sector_t)1 << ((i + 1) * v->hash_per_block_bits)) - 1)\r\n>> ((i + 1) * v->hash_per_block_bits);\r\nif (hash_position + s < hash_position) {\r\nti->error = "Hash device offset overflow";\r\nr = -E2BIG;\r\ngoto bad;\r\n}\r\nhash_position += s;\r\n}\r\nv->hash_blocks = hash_position;\r\nv->bufio = dm_bufio_client_create(v->hash_dev->bdev,\r\n1 << v->hash_dev_block_bits, 1, sizeof(struct buffer_aux),\r\ndm_bufio_alloc_callback, NULL);\r\nif (IS_ERR(v->bufio)) {\r\nti->error = "Cannot initialize dm-bufio";\r\nr = PTR_ERR(v->bufio);\r\nv->bufio = NULL;\r\ngoto bad;\r\n}\r\nif (dm_bufio_get_device_size(v->bufio) < v->hash_blocks) {\r\nti->error = "Hash device is too small";\r\nr = -E2BIG;\r\ngoto bad;\r\n}\r\nv->verify_wq = alloc_workqueue("kverityd", WQ_CPU_INTENSIVE | WQ_MEM_RECLAIM | WQ_UNBOUND, num_online_cpus());\r\nif (!v->verify_wq) {\r\nti->error = "Cannot allocate workqueue";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nti->per_io_data_size = sizeof(struct dm_verity_io) +\r\nv->shash_descsize + v->digest_size * 2;\r\nr = verity_fec_ctr(v);\r\nif (r)\r\ngoto bad;\r\nti->per_io_data_size = roundup(ti->per_io_data_size,\r\n__alignof__(struct dm_verity_io));\r\nreturn 0;\r\nbad:\r\nverity_dtr(ti);\r\nreturn r;\r\n}\r\nstatic int __init dm_verity_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&verity_target);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nreturn r;\r\n}\r\nstatic void __exit dm_verity_exit(void)\r\n{\r\ndm_unregister_target(&verity_target);\r\n}
