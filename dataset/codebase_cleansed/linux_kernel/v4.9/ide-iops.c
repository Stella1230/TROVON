void SELECT_MASK(ide_drive_t *drive, int mask)\r\n{\r\nconst struct ide_port_ops *port_ops = drive->hwif->port_ops;\r\nif (port_ops && port_ops->maskproc)\r\nport_ops->maskproc(drive, mask);\r\n}\r\nu8 ide_read_error(ide_drive_t *drive)\r\n{\r\nstruct ide_taskfile tf;\r\ndrive->hwif->tp_ops->tf_read(drive, &tf, IDE_VALID_ERROR);\r\nreturn tf.error;\r\n}\r\nvoid ide_fix_driveid(u16 *id)\r\n{\r\n#ifndef __LITTLE_ENDIAN\r\n# ifdef __BIG_ENDIAN\r\nint i;\r\nfor (i = 0; i < 256; i++)\r\nid[i] = __le16_to_cpu(id[i]);\r\n# else\r\n# error "Please fix <asm/byteorder.h>"\r\n# endif\r\n#endif\r\n}\r\nvoid ide_fixstring(u8 *s, const int bytecount, const int byteswap)\r\n{\r\nu8 *p, *end = &s[bytecount & ~1];\r\nif (byteswap) {\r\nfor (p = s ; p != end ; p += 2)\r\nbe16_to_cpus((u16 *) p);\r\n}\r\np = s;\r\nwhile (s != end && *s == ' ')\r\n++s;\r\nwhile (s != end && *s) {\r\nif (*s++ != ' ' || (s != end && *s && *s != ' '))\r\n*p++ = *(s-1);\r\n}\r\nwhile (p != end)\r\n*p++ = '\0';\r\n}\r\nint __ide_wait_stat(ide_drive_t *drive, u8 good, u8 bad,\r\nunsigned long timeout, u8 *rstat)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nunsigned long flags;\r\nint i;\r\nu8 stat;\r\nudelay(1);\r\nstat = tp_ops->read_status(hwif);\r\nif (stat & ATA_BUSY) {\r\nlocal_save_flags(flags);\r\nlocal_irq_enable_in_hardirq();\r\ntimeout += jiffies;\r\nwhile ((stat = tp_ops->read_status(hwif)) & ATA_BUSY) {\r\nif (time_after(jiffies, timeout)) {\r\nstat = tp_ops->read_status(hwif);\r\nif ((stat & ATA_BUSY) == 0)\r\nbreak;\r\nlocal_irq_restore(flags);\r\n*rstat = stat;\r\nreturn -EBUSY;\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nfor (i = 0; i < 10; i++) {\r\nudelay(1);\r\nstat = tp_ops->read_status(hwif);\r\nif (OK_STAT(stat, good, bad)) {\r\n*rstat = stat;\r\nreturn 0;\r\n}\r\n}\r\n*rstat = stat;\r\nreturn -EFAULT;\r\n}\r\nint ide_wait_stat(ide_startstop_t *startstop, ide_drive_t *drive, u8 good,\r\nu8 bad, unsigned long timeout)\r\n{\r\nint err;\r\nu8 stat;\r\nif (drive->max_failures && (drive->failures > drive->max_failures)) {\r\n*startstop = ide_stopped;\r\nreturn 1;\r\n}\r\nerr = __ide_wait_stat(drive, good, bad, timeout, &stat);\r\nif (err) {\r\nchar *s = (err == -EBUSY) ? "status timeout" : "status error";\r\n*startstop = ide_error(drive, s, stat);\r\n}\r\nreturn err;\r\n}\r\nint ide_in_drive_list(u16 *id, const struct drive_list_entry *table)\r\n{\r\nfor ( ; table->id_model; table++)\r\nif ((!strcmp(table->id_model, (char *)&id[ATA_ID_PROD])) &&\r\n(!table->id_firmware ||\r\nstrstr((char *)&id[ATA_ID_FW_REV], table->id_firmware)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nu8 eighty_ninty_three(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu16 *id = drive->id;\r\nint ivb = ide_in_drive_list(id, ivb_list);\r\nif (hwif->cbl == ATA_CBL_SATA || hwif->cbl == ATA_CBL_PATA40_SHORT)\r\nreturn 1;\r\nif (ivb)\r\nprintk(KERN_DEBUG "%s: skipping word 93 validity check\n",\r\ndrive->name);\r\nif (ata_id_is_sata(id) && !ivb)\r\nreturn 1;\r\nif (hwif->cbl != ATA_CBL_PATA80 && !ivb)\r\ngoto no_80w;\r\nif (id[ATA_ID_HW_CONFIG] & 0x4000)\r\nreturn 1;\r\nif (ivb) {\r\nconst char *model = (char *)&id[ATA_ID_PROD];\r\nif (strstr(model, "TSSTcorp CDDVDW SH-S202")) {\r\nif (hwif->cbl == ATA_CBL_PATA80)\r\nreturn 1;\r\n} else {\r\nif (id[ATA_ID_HW_CONFIG] & 0x2000)\r\nreturn 1;\r\n}\r\n}\r\nno_80w:\r\nif (drive->dev_flags & IDE_DFLAG_UDMA33_WARNED)\r\nreturn 0;\r\nprintk(KERN_WARNING "%s: %s side 80-wire cable detection failed, "\r\n"limiting max speed to UDMA33\n",\r\ndrive->name,\r\nhwif->cbl == ATA_CBL_PATA80 ? "drive" : "host");\r\ndrive->dev_flags |= IDE_DFLAG_UDMA33_WARNED;\r\nreturn 0;\r\n}\r\nvoid ide_check_nien_quirk_list(ide_drive_t *drive)\r\n{\r\nconst char **list, *m = (char *)&drive->id[ATA_ID_PROD];\r\nfor (list = nien_quirk_list; *list != NULL; list++)\r\nif (strstr(m, *list) != NULL) {\r\ndrive->dev_flags |= IDE_DFLAG_NIEN_QUIRK;\r\nreturn;\r\n}\r\n}\r\nint ide_driveid_update(ide_drive_t *drive)\r\n{\r\nu16 *id;\r\nint rc;\r\nid = kmalloc(SECTOR_SIZE, GFP_ATOMIC);\r\nif (id == NULL)\r\nreturn 0;\r\nSELECT_MASK(drive, 1);\r\nrc = ide_dev_read_id(drive, ATA_CMD_ID_ATA, id, 1);\r\nSELECT_MASK(drive, 0);\r\nif (rc)\r\ngoto out_err;\r\ndrive->id[ATA_ID_UDMA_MODES] = id[ATA_ID_UDMA_MODES];\r\ndrive->id[ATA_ID_MWDMA_MODES] = id[ATA_ID_MWDMA_MODES];\r\ndrive->id[ATA_ID_SWDMA_MODES] = id[ATA_ID_SWDMA_MODES];\r\ndrive->id[ATA_ID_CFA_MODES] = id[ATA_ID_CFA_MODES];\r\nkfree(id);\r\nreturn 1;\r\nout_err:\r\nif (rc == 2)\r\nprintk(KERN_ERR "%s: %s: bad status\n", drive->name, __func__);\r\nkfree(id);\r\nreturn 0;\r\n}\r\nint ide_config_drive_speed(ide_drive_t *drive, u8 speed)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nstruct ide_taskfile tf;\r\nu16 *id = drive->id, i;\r\nint error = 0;\r\nu8 stat;\r\n#ifdef CONFIG_BLK_DEV_IDEDMA\r\nif (hwif->dma_ops)\r\nhwif->dma_ops->dma_host_set(drive, 0);\r\n#endif\r\nif ((speed & 0xf8) == XFER_PIO_0 && ata_id_has_iordy(drive->id) == 0)\r\ngoto skip;\r\nudelay(1);\r\ntp_ops->dev_select(drive);\r\nSELECT_MASK(drive, 1);\r\nudelay(1);\r\ntp_ops->write_devctl(hwif, ATA_NIEN | ATA_DEVCTL_OBS);\r\nmemset(&tf, 0, sizeof(tf));\r\ntf.feature = SETFEATURES_XFER;\r\ntf.nsect = speed;\r\ntp_ops->tf_load(drive, &tf, IDE_VALID_FEATURE | IDE_VALID_NSECT);\r\ntp_ops->exec_command(hwif, ATA_CMD_SET_FEATURES);\r\nif (drive->dev_flags & IDE_DFLAG_NIEN_QUIRK)\r\ntp_ops->write_devctl(hwif, ATA_DEVCTL_OBS);\r\nerror = __ide_wait_stat(drive, drive->ready_stat,\r\nATA_BUSY | ATA_DRQ | ATA_ERR,\r\nWAIT_CMD, &stat);\r\nSELECT_MASK(drive, 0);\r\nif (error) {\r\n(void) ide_dump_status(drive, "set_drive_speed_status", stat);\r\nreturn error;\r\n}\r\nif (speed >= XFER_SW_DMA_0) {\r\nid[ATA_ID_UDMA_MODES] &= ~0xFF00;\r\nid[ATA_ID_MWDMA_MODES] &= ~0x0700;\r\nid[ATA_ID_SWDMA_MODES] &= ~0x0700;\r\nif (ata_id_is_cfa(id))\r\nid[ATA_ID_CFA_MODES] &= ~0x0E00;\r\n} else if (ata_id_is_cfa(id))\r\nid[ATA_ID_CFA_MODES] &= ~0x01C0;\r\nskip:\r\n#ifdef CONFIG_BLK_DEV_IDEDMA\r\nif (speed >= XFER_SW_DMA_0 && (drive->dev_flags & IDE_DFLAG_USING_DMA))\r\nhwif->dma_ops->dma_host_set(drive, 1);\r\nelse if (hwif->dma_ops)\r\nide_dma_off_quietly(drive);\r\n#endif\r\nif (speed >= XFER_UDMA_0) {\r\ni = 1 << (speed - XFER_UDMA_0);\r\nid[ATA_ID_UDMA_MODES] |= (i << 8 | i);\r\n} else if (ata_id_is_cfa(id) && speed >= XFER_MW_DMA_3) {\r\ni = speed - XFER_MW_DMA_2;\r\nid[ATA_ID_CFA_MODES] |= i << 9;\r\n} else if (speed >= XFER_MW_DMA_0) {\r\ni = 1 << (speed - XFER_MW_DMA_0);\r\nid[ATA_ID_MWDMA_MODES] |= (i << 8 | i);\r\n} else if (speed >= XFER_SW_DMA_0) {\r\ni = 1 << (speed - XFER_SW_DMA_0);\r\nid[ATA_ID_SWDMA_MODES] |= (i << 8 | i);\r\n} else if (ata_id_is_cfa(id) && speed >= XFER_PIO_5) {\r\ni = speed - XFER_PIO_4;\r\nid[ATA_ID_CFA_MODES] |= i << 6;\r\n}\r\nif (!drive->init_speed)\r\ndrive->init_speed = speed;\r\ndrive->current_speed = speed;\r\nreturn error;\r\n}\r\nvoid __ide_set_handler(ide_drive_t *drive, ide_handler_t *handler,\r\nunsigned int timeout)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nBUG_ON(hwif->handler);\r\nhwif->handler = handler;\r\nhwif->timer.expires = jiffies + timeout;\r\nhwif->req_gen_timer = hwif->req_gen;\r\nadd_timer(&hwif->timer);\r\n}\r\nvoid ide_set_handler(ide_drive_t *drive, ide_handler_t *handler,\r\nunsigned int timeout)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hwif->lock, flags);\r\n__ide_set_handler(drive, handler, timeout);\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\n}\r\nvoid ide_execute_command(ide_drive_t *drive, struct ide_cmd *cmd,\r\nide_handler_t *handler, unsigned timeout)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hwif->lock, flags);\r\nif ((cmd->protocol != ATAPI_PROT_DMA &&\r\ncmd->protocol != ATAPI_PROT_PIO) ||\r\n(drive->atapi_flags & IDE_AFLAG_DRQ_INTERRUPT))\r\n__ide_set_handler(drive, handler, timeout);\r\nhwif->tp_ops->exec_command(hwif, cmd->tf.command);\r\nndelay(400);\r\nspin_unlock_irqrestore(&hwif->lock, flags);\r\n}\r\nint ide_wait_not_busy(ide_hwif_t *hwif, unsigned long timeout)\r\n{\r\nu8 stat = 0;\r\nwhile (timeout--) {\r\nmdelay(1);\r\nstat = hwif->tp_ops->read_status(hwif);\r\nif ((stat & ATA_BUSY) == 0)\r\nreturn 0;\r\nif (stat == 0xff)\r\nreturn -ENODEV;\r\ntouch_softlockup_watchdog();\r\ntouch_nmi_watchdog();\r\n}\r\nreturn -EBUSY;\r\n}
