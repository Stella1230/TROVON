void iscsit_set_dataout_sequence_values(\r\nstruct iscsi_cmd *cmd)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nif (cmd->unsolicited_data) {\r\ncmd->seq_start_offset = cmd->write_data_done;\r\ncmd->seq_end_offset = (cmd->write_data_done +\r\n((cmd->se_cmd.data_length >\r\nconn->sess->sess_ops->FirstBurstLength) ?\r\nconn->sess->sess_ops->FirstBurstLength : cmd->se_cmd.data_length));\r\nreturn;\r\n}\r\nif (!conn->sess->sess_ops->DataSequenceInOrder)\r\nreturn;\r\nif (!cmd->seq_start_offset && !cmd->seq_end_offset) {\r\ncmd->seq_start_offset = cmd->write_data_done;\r\ncmd->seq_end_offset = (cmd->se_cmd.data_length >\r\nconn->sess->sess_ops->MaxBurstLength) ?\r\n(cmd->write_data_done +\r\nconn->sess->sess_ops->MaxBurstLength) : cmd->se_cmd.data_length;\r\n} else {\r\ncmd->seq_start_offset = cmd->seq_end_offset;\r\ncmd->seq_end_offset = ((cmd->seq_end_offset +\r\nconn->sess->sess_ops->MaxBurstLength) >=\r\ncmd->se_cmd.data_length) ? cmd->se_cmd.data_length :\r\n(cmd->seq_end_offset +\r\nconn->sess->sess_ops->MaxBurstLength);\r\n}\r\n}\r\nstatic int iscsit_dataout_within_command_recovery_check(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nif ((cmd->cmd_flags & ICF_WITHIN_COMMAND_RECOVERY) &&\r\ncmd->write_data_done != be32_to_cpu(hdr->offset))\r\ngoto dump;\r\ncmd->cmd_flags &= ~ICF_WITHIN_COMMAND_RECOVERY;\r\n} else {\r\nstruct iscsi_seq *seq;\r\nseq = iscsit_get_seq_holder(cmd, be32_to_cpu(hdr->offset),\r\npayload_length);\r\nif (!seq)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\ncmd->seq_ptr = seq;\r\nif (conn->sess->sess_ops->DataPDUInOrder) {\r\nif (seq->status ==\r\nDATAOUT_SEQUENCE_WITHIN_COMMAND_RECOVERY &&\r\n(seq->offset != be32_to_cpu(hdr->offset) ||\r\nseq->data_sn != be32_to_cpu(hdr->datasn)))\r\ngoto dump;\r\n} else {\r\nif (seq->status ==\r\nDATAOUT_SEQUENCE_WITHIN_COMMAND_RECOVERY &&\r\nseq->data_sn != be32_to_cpu(hdr->datasn))\r\ngoto dump;\r\n}\r\nif (seq->status == DATAOUT_SEQUENCE_COMPLETE)\r\ngoto dump;\r\nif (seq->status != DATAOUT_SEQUENCE_COMPLETE)\r\nseq->status = 0;\r\n}\r\nreturn DATAOUT_NORMAL;\r\ndump:\r\npr_err("Dumping DataOUT PDU Offset: %u Length: %d DataSN:"\r\n" 0x%08x\n", hdr->offset, payload_length, hdr->datasn);\r\nreturn iscsit_dump_data_payload(conn, payload_length, 1);\r\n}\r\nstatic int iscsit_dataout_check_unsolicited_sequence(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nu32 first_burst_len;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif ((be32_to_cpu(hdr->offset) < cmd->seq_start_offset) ||\r\n((be32_to_cpu(hdr->offset) + payload_length) > cmd->seq_end_offset)) {\r\npr_err("Command ITT: 0x%08x with Offset: %u,"\r\n" Length: %u outside of Unsolicited Sequence %u:%u while"\r\n" DataSequenceInOrder=Yes.\n", cmd->init_task_tag,\r\nbe32_to_cpu(hdr->offset), payload_length, cmd->seq_start_offset,\r\ncmd->seq_end_offset);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\nfirst_burst_len = (cmd->first_burst_len + payload_length);\r\nif (first_burst_len > conn->sess->sess_ops->FirstBurstLength) {\r\npr_err("Total %u bytes exceeds FirstBurstLength: %u"\r\n" for this Unsolicited DataOut Burst.\n",\r\nfirst_burst_len, conn->sess->sess_ops->FirstBurstLength);\r\ntransport_send_check_condition_and_sense(&cmd->se_cmd,\r\nTCM_INCORRECT_AMOUNT_OF_DATA, 0);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\nif (hdr->flags & ISCSI_FLAG_CMD_FINAL) {\r\nif (!conn->sess->sess_ops->DataPDUInOrder)\r\ngoto out;\r\nif ((first_burst_len != cmd->se_cmd.data_length) &&\r\n(first_burst_len != conn->sess->sess_ops->FirstBurstLength)) {\r\npr_err("Unsolicited non-immediate data"\r\n" received %u does not equal FirstBurstLength: %u, and"\r\n" does not equal ExpXferLen %u.\n", first_burst_len,\r\nconn->sess->sess_ops->FirstBurstLength,\r\ncmd->se_cmd.data_length);\r\ntransport_send_check_condition_and_sense(&cmd->se_cmd,\r\nTCM_INCORRECT_AMOUNT_OF_DATA, 0);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\n} else {\r\nif (first_burst_len == conn->sess->sess_ops->FirstBurstLength) {\r\npr_err("Command ITT: 0x%08x reached"\r\n" FirstBurstLength: %u, but ISCSI_FLAG_CMD_FINAL is not set. protocol"\r\n" error.\n", cmd->init_task_tag,\r\nconn->sess->sess_ops->FirstBurstLength);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\nif (first_burst_len == cmd->se_cmd.data_length) {\r\npr_err("Command ITT: 0x%08x reached"\r\n" ExpXferLen: %u, but ISCSI_FLAG_CMD_FINAL is not set. protocol"\r\n" error.\n", cmd->init_task_tag, cmd->se_cmd.data_length);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\n}\r\nout:\r\nreturn DATAOUT_NORMAL;\r\n}\r\nstatic int iscsit_dataout_check_sequence(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nu32 next_burst_len;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_seq *seq = NULL;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nif ((be32_to_cpu(hdr->offset) < cmd->seq_start_offset) ||\r\n((be32_to_cpu(hdr->offset) + payload_length) > cmd->seq_end_offset)) {\r\npr_err("Command ITT: 0x%08x with Offset: %u,"\r\n" Length: %u outside of Sequence %u:%u while"\r\n" DataSequenceInOrder=Yes.\n", cmd->init_task_tag,\r\nbe32_to_cpu(hdr->offset), payload_length, cmd->seq_start_offset,\r\ncmd->seq_end_offset);\r\nif (iscsit_dump_data_payload(conn, payload_length, 1) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nreturn DATAOUT_WITHIN_COMMAND_RECOVERY;\r\n}\r\nnext_burst_len = (cmd->next_burst_len + payload_length);\r\n} else {\r\nseq = iscsit_get_seq_holder(cmd, be32_to_cpu(hdr->offset),\r\npayload_length);\r\nif (!seq)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\ncmd->seq_ptr = seq;\r\nif (seq->status == DATAOUT_SEQUENCE_COMPLETE) {\r\nif (iscsit_dump_data_payload(conn, payload_length, 1) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nreturn DATAOUT_WITHIN_COMMAND_RECOVERY;\r\n}\r\nnext_burst_len = (seq->next_burst_len + payload_length);\r\n}\r\nif (next_burst_len > conn->sess->sess_ops->MaxBurstLength) {\r\npr_err("Command ITT: 0x%08x, NextBurstLength: %u and"\r\n" Length: %u exceeds MaxBurstLength: %u. protocol"\r\n" error.\n", cmd->init_task_tag,\r\n(next_burst_len - payload_length),\r\npayload_length, conn->sess->sess_ops->MaxBurstLength);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\nif (hdr->flags & ISCSI_FLAG_CMD_FINAL) {\r\nif (!conn->sess->sess_ops->DataPDUInOrder)\r\ngoto out;\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nif ((next_burst_len <\r\nconn->sess->sess_ops->MaxBurstLength) &&\r\n((cmd->write_data_done + payload_length) <\r\ncmd->se_cmd.data_length)) {\r\npr_err("Command ITT: 0x%08x set ISCSI_FLAG_CMD_FINAL"\r\n" before end of DataOUT sequence, protocol"\r\n" error.\n", cmd->init_task_tag);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\n} else {\r\nif (next_burst_len < seq->xfer_len) {\r\npr_err("Command ITT: 0x%08x set ISCSI_FLAG_CMD_FINAL"\r\n" before end of DataOUT sequence, protocol"\r\n" error.\n", cmd->init_task_tag);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\n}\r\n} else {\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nif (next_burst_len ==\r\nconn->sess->sess_ops->MaxBurstLength) {\r\npr_err("Command ITT: 0x%08x reached"\r\n" MaxBurstLength: %u, but ISCSI_FLAG_CMD_FINAL is"\r\n" not set, protocol error.", cmd->init_task_tag,\r\nconn->sess->sess_ops->MaxBurstLength);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\nif ((cmd->write_data_done + payload_length) ==\r\ncmd->se_cmd.data_length) {\r\npr_err("Command ITT: 0x%08x reached"\r\n" last DataOUT PDU in sequence but ISCSI_FLAG_"\r\n"CMD_FINAL is not set, protocol error.\n",\r\ncmd->init_task_tag);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\n} else {\r\nif (next_burst_len == seq->xfer_len) {\r\npr_err("Command ITT: 0x%08x reached"\r\n" last DataOUT PDU in sequence but ISCSI_FLAG_"\r\n"CMD_FINAL is not set, protocol error.\n",\r\ncmd->init_task_tag);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\n}\r\n}\r\nout:\r\nreturn DATAOUT_NORMAL;\r\n}\r\nstatic int iscsit_dataout_check_datasn(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nu32 data_sn = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (conn->sess->sess_ops->DataSequenceInOrder)\r\ndata_sn = cmd->data_sn;\r\nelse {\r\nstruct iscsi_seq *seq = cmd->seq_ptr;\r\ndata_sn = seq->data_sn;\r\n}\r\nif (be32_to_cpu(hdr->datasn) > data_sn) {\r\npr_err("Command ITT: 0x%08x, received DataSN: 0x%08x"\r\n" higher than expected 0x%08x.\n", cmd->init_task_tag,\r\nbe32_to_cpu(hdr->datasn), data_sn);\r\ngoto recover;\r\n} else if (be32_to_cpu(hdr->datasn) < data_sn) {\r\npr_err("Command ITT: 0x%08x, received DataSN: 0x%08x"\r\n" lower than expected 0x%08x, discarding payload.\n",\r\ncmd->init_task_tag, be32_to_cpu(hdr->datasn), data_sn);\r\ngoto dump;\r\n}\r\nreturn DATAOUT_NORMAL;\r\nrecover:\r\nif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\r\npr_err("Unable to perform within-command recovery"\r\n" while ERL=0.\n");\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\ndump:\r\nif (iscsit_dump_data_payload(conn, payload_length, 1) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nreturn DATAOUT_WITHIN_COMMAND_RECOVERY;\r\n}\r\nstatic int iscsit_dataout_pre_datapduinorder_yes(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nint dump = 0, recovery = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nif (be32_to_cpu(hdr->offset) != cmd->write_data_done) {\r\npr_err("Command ITT: 0x%08x, received offset"\r\n" %u different than expected %u.\n", cmd->init_task_tag,\r\nbe32_to_cpu(hdr->offset), cmd->write_data_done);\r\nrecovery = 1;\r\ngoto recover;\r\n}\r\n} else {\r\nstruct iscsi_seq *seq = cmd->seq_ptr;\r\nif (be32_to_cpu(hdr->offset) > seq->offset) {\r\npr_err("Command ITT: 0x%08x, received offset"\r\n" %u greater than expected %u.\n", cmd->init_task_tag,\r\nbe32_to_cpu(hdr->offset), seq->offset);\r\nrecovery = 1;\r\ngoto recover;\r\n} else if (be32_to_cpu(hdr->offset) < seq->offset) {\r\npr_err("Command ITT: 0x%08x, received offset"\r\n" %u less than expected %u, discarding payload.\n",\r\ncmd->init_task_tag, be32_to_cpu(hdr->offset),\r\nseq->offset);\r\ndump = 1;\r\ngoto dump;\r\n}\r\n}\r\nreturn DATAOUT_NORMAL;\r\nrecover:\r\nif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\r\npr_err("Unable to perform within-command recovery"\r\n" while ERL=0.\n");\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\ndump:\r\nif (iscsit_dump_data_payload(conn, payload_length, 1) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nreturn (recovery) ? iscsit_recover_dataout_sequence(cmd,\r\nbe32_to_cpu(hdr->offset), payload_length) :\r\n(dump) ? DATAOUT_WITHIN_COMMAND_RECOVERY : DATAOUT_NORMAL;\r\n}\r\nstatic int iscsit_dataout_pre_datapduinorder_no(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_pdu *pdu;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\npdu = iscsit_get_pdu_holder(cmd, be32_to_cpu(hdr->offset),\r\npayload_length);\r\nif (!pdu)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\ncmd->pdu_ptr = pdu;\r\nswitch (pdu->status) {\r\ncase ISCSI_PDU_NOT_RECEIVED:\r\ncase ISCSI_PDU_CRC_FAILED:\r\ncase ISCSI_PDU_TIMED_OUT:\r\nbreak;\r\ncase ISCSI_PDU_RECEIVED_OK:\r\npr_err("Command ITT: 0x%08x received already gotten"\r\n" Offset: %u, Length: %u\n", cmd->init_task_tag,\r\nbe32_to_cpu(hdr->offset), payload_length);\r\nreturn iscsit_dump_data_payload(cmd->conn, payload_length, 1);\r\ndefault:\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\nreturn DATAOUT_NORMAL;\r\n}\r\nstatic int iscsit_dataout_update_r2t(struct iscsi_cmd *cmd, u32 offset, u32 length)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nif (cmd->unsolicited_data)\r\nreturn 0;\r\nr2t = iscsit_get_r2t_for_eos(cmd, offset, length);\r\nif (!r2t)\r\nreturn -1;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nr2t->seq_complete = 1;\r\ncmd->outstanding_r2ts--;\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn 0;\r\n}\r\nstatic int iscsit_dataout_update_datapduinorder_no(\r\nstruct iscsi_cmd *cmd,\r\nu32 data_sn,\r\nint f_bit)\r\n{\r\nint ret = 0;\r\nstruct iscsi_pdu *pdu = cmd->pdu_ptr;\r\npdu->data_sn = data_sn;\r\nswitch (pdu->status) {\r\ncase ISCSI_PDU_NOT_RECEIVED:\r\npdu->status = ISCSI_PDU_RECEIVED_OK;\r\nbreak;\r\ncase ISCSI_PDU_CRC_FAILED:\r\npdu->status = ISCSI_PDU_RECEIVED_OK;\r\nbreak;\r\ncase ISCSI_PDU_TIMED_OUT:\r\npdu->status = ISCSI_PDU_RECEIVED_OK;\r\nbreak;\r\ndefault:\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\nif (f_bit) {\r\nret = iscsit_dataout_datapduinorder_no_fbit(cmd, pdu);\r\nif (ret == DATAOUT_CANNOT_RECOVER)\r\nreturn ret;\r\n}\r\nreturn DATAOUT_NORMAL;\r\n}\r\nstatic int iscsit_dataout_post_crc_passed(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nint ret, send_r2t = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_seq *seq = NULL;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (cmd->unsolicited_data) {\r\nif ((cmd->first_burst_len + payload_length) ==\r\nconn->sess->sess_ops->FirstBurstLength) {\r\nif (iscsit_dataout_update_r2t(cmd, be32_to_cpu(hdr->offset),\r\npayload_length) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nsend_r2t = 1;\r\n}\r\nif (!conn->sess->sess_ops->DataPDUInOrder) {\r\nret = iscsit_dataout_update_datapduinorder_no(cmd,\r\nbe32_to_cpu(hdr->datasn),\r\n(hdr->flags & ISCSI_FLAG_CMD_FINAL));\r\nif (ret == DATAOUT_CANNOT_RECOVER)\r\nreturn ret;\r\n}\r\ncmd->first_burst_len += payload_length;\r\nif (conn->sess->sess_ops->DataSequenceInOrder)\r\ncmd->data_sn++;\r\nelse {\r\nseq = cmd->seq_ptr;\r\nseq->data_sn++;\r\nseq->offset += payload_length;\r\n}\r\nif (send_r2t) {\r\nif (seq)\r\nseq->status = DATAOUT_SEQUENCE_COMPLETE;\r\ncmd->first_burst_len = 0;\r\ncmd->unsolicited_data = 0;\r\n}\r\n} else {\r\nif (conn->sess->sess_ops->DataSequenceInOrder) {\r\nif ((cmd->next_burst_len + payload_length) ==\r\nconn->sess->sess_ops->MaxBurstLength) {\r\nif (iscsit_dataout_update_r2t(cmd,\r\nbe32_to_cpu(hdr->offset),\r\npayload_length) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nsend_r2t = 1;\r\n}\r\nif (!conn->sess->sess_ops->DataPDUInOrder) {\r\nret = iscsit_dataout_update_datapduinorder_no(\r\ncmd, be32_to_cpu(hdr->datasn),\r\n(hdr->flags & ISCSI_FLAG_CMD_FINAL));\r\nif (ret == DATAOUT_CANNOT_RECOVER)\r\nreturn ret;\r\n}\r\ncmd->next_burst_len += payload_length;\r\ncmd->data_sn++;\r\nif (send_r2t)\r\ncmd->next_burst_len = 0;\r\n} else {\r\nseq = cmd->seq_ptr;\r\nif ((seq->next_burst_len + payload_length) ==\r\nseq->xfer_len) {\r\nif (iscsit_dataout_update_r2t(cmd,\r\nbe32_to_cpu(hdr->offset),\r\npayload_length) < 0)\r\nreturn DATAOUT_CANNOT_RECOVER;\r\nsend_r2t = 1;\r\n}\r\nif (!conn->sess->sess_ops->DataPDUInOrder) {\r\nret = iscsit_dataout_update_datapduinorder_no(\r\ncmd, be32_to_cpu(hdr->datasn),\r\n(hdr->flags & ISCSI_FLAG_CMD_FINAL));\r\nif (ret == DATAOUT_CANNOT_RECOVER)\r\nreturn ret;\r\n}\r\nseq->data_sn++;\r\nseq->offset += payload_length;\r\nseq->next_burst_len += payload_length;\r\nif (send_r2t) {\r\nseq->next_burst_len = 0;\r\nseq->status = DATAOUT_SEQUENCE_COMPLETE;\r\n}\r\n}\r\n}\r\nif (send_r2t && conn->sess->sess_ops->DataSequenceInOrder)\r\ncmd->data_sn = 0;\r\ncmd->write_data_done += payload_length;\r\nif (cmd->write_data_done == cmd->se_cmd.data_length)\r\nreturn DATAOUT_SEND_TO_TRANSPORT;\r\nelse if (send_r2t)\r\nreturn DATAOUT_SEND_R2T;\r\nelse\r\nreturn DATAOUT_NORMAL;\r\n}\r\nstatic int iscsit_dataout_post_crc_failed(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct iscsi_pdu *pdu;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (conn->sess->sess_ops->DataPDUInOrder)\r\ngoto recover;\r\npdu = cmd->pdu_ptr;\r\nswitch (pdu->status) {\r\ncase ISCSI_PDU_NOT_RECEIVED:\r\npdu->status = ISCSI_PDU_CRC_FAILED;\r\nbreak;\r\ncase ISCSI_PDU_CRC_FAILED:\r\nbreak;\r\ncase ISCSI_PDU_TIMED_OUT:\r\npdu->status = ISCSI_PDU_CRC_FAILED;\r\nbreak;\r\ndefault:\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\nrecover:\r\nreturn iscsit_recover_dataout_sequence(cmd, be32_to_cpu(hdr->offset),\r\npayload_length);\r\n}\r\nint iscsit_check_pre_dataout(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf)\r\n{\r\nint ret;\r\nstruct iscsi_conn *conn = cmd->conn;\r\nret = iscsit_dataout_within_command_recovery_check(cmd, buf);\r\nif ((ret == DATAOUT_WITHIN_COMMAND_RECOVERY) ||\r\n(ret == DATAOUT_CANNOT_RECOVER))\r\nreturn ret;\r\nret = iscsit_dataout_check_datasn(cmd, buf);\r\nif ((ret == DATAOUT_WITHIN_COMMAND_RECOVERY) ||\r\n(ret == DATAOUT_CANNOT_RECOVER))\r\nreturn ret;\r\nif (cmd->unsolicited_data) {\r\nret = iscsit_dataout_check_unsolicited_sequence(cmd, buf);\r\nif ((ret == DATAOUT_WITHIN_COMMAND_RECOVERY) ||\r\n(ret == DATAOUT_CANNOT_RECOVER))\r\nreturn ret;\r\n} else {\r\nret = iscsit_dataout_check_sequence(cmd, buf);\r\nif ((ret == DATAOUT_WITHIN_COMMAND_RECOVERY) ||\r\n(ret == DATAOUT_CANNOT_RECOVER))\r\nreturn ret;\r\n}\r\nreturn (conn->sess->sess_ops->DataPDUInOrder) ?\r\niscsit_dataout_pre_datapduinorder_yes(cmd, buf) :\r\niscsit_dataout_pre_datapduinorder_no(cmd, buf);\r\n}\r\nint iscsit_check_post_dataout(\r\nstruct iscsi_cmd *cmd,\r\nunsigned char *buf,\r\nu8 data_crc_failed)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\ncmd->dataout_timeout_retries = 0;\r\nif (!data_crc_failed)\r\nreturn iscsit_dataout_post_crc_passed(cmd, buf);\r\nelse {\r\nif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\r\npr_err("Unable to recover from DataOUT CRC"\r\n" failure while ERL=0, closing session.\n");\r\niscsit_reject_cmd(cmd, ISCSI_REASON_DATA_DIGEST_ERROR,\r\nbuf);\r\nreturn DATAOUT_CANNOT_RECOVER;\r\n}\r\niscsit_reject_cmd(cmd, ISCSI_REASON_DATA_DIGEST_ERROR, buf);\r\nreturn iscsit_dataout_post_crc_failed(cmd, buf);\r\n}\r\n}\r\nstatic void iscsit_handle_time2retain_timeout(unsigned long data)\r\n{\r\nstruct iscsi_session *sess = (struct iscsi_session *) data;\r\nstruct iscsi_portal_group *tpg = sess->tpg;\r\nstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\r\nspin_lock_bh(&se_tpg->session_lock);\r\nif (sess->time2retain_timer_flags & ISCSI_TF_STOP) {\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nreturn;\r\n}\r\nif (atomic_read(&sess->session_reinstatement)) {\r\npr_err("Exiting Time2Retain handler because"\r\n" session_reinstatement=1\n");\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nreturn;\r\n}\r\nsess->time2retain_timer_flags |= ISCSI_TF_EXPIRED;\r\npr_err("Time2Retain timer expired for SID: %u, cleaning up"\r\n" iSCSI session.\n", sess->sid);\r\n{\r\nstruct iscsi_tiqn *tiqn = tpg->tpg_tiqn;\r\nif (tiqn) {\r\nspin_lock(&tiqn->sess_err_stats.lock);\r\nstrcpy(tiqn->sess_err_stats.last_sess_fail_rem_name,\r\n(void *)sess->sess_ops->InitiatorName);\r\ntiqn->sess_err_stats.last_sess_failure_type =\r\nISCSI_SESS_ERR_CXN_TIMEOUT;\r\ntiqn->sess_err_stats.cxn_timeout_errors++;\r\natomic_long_inc(&sess->conn_timeout_errors);\r\nspin_unlock(&tiqn->sess_err_stats.lock);\r\n}\r\n}\r\nspin_unlock_bh(&se_tpg->session_lock);\r\niscsit_close_session(sess);\r\n}\r\nvoid iscsit_start_time2retain_handler(struct iscsi_session *sess)\r\n{\r\nint tpg_active;\r\nspin_lock(&sess->tpg->tpg_state_lock);\r\ntpg_active = (sess->tpg->tpg_state == TPG_STATE_ACTIVE);\r\nspin_unlock(&sess->tpg->tpg_state_lock);\r\nif (!tpg_active)\r\nreturn;\r\nif (sess->time2retain_timer_flags & ISCSI_TF_RUNNING)\r\nreturn;\r\npr_debug("Starting Time2Retain timer for %u seconds on"\r\n" SID: %u\n", sess->sess_ops->DefaultTime2Retain, sess->sid);\r\ninit_timer(&sess->time2retain_timer);\r\nsess->time2retain_timer.expires =\r\n(get_jiffies_64() + sess->sess_ops->DefaultTime2Retain * HZ);\r\nsess->time2retain_timer.data = (unsigned long)sess;\r\nsess->time2retain_timer.function = iscsit_handle_time2retain_timeout;\r\nsess->time2retain_timer_flags &= ~ISCSI_TF_STOP;\r\nsess->time2retain_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&sess->time2retain_timer);\r\n}\r\nint iscsit_stop_time2retain_timer(struct iscsi_session *sess)\r\n{\r\nstruct iscsi_portal_group *tpg = sess->tpg;\r\nstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\r\nif (sess->time2retain_timer_flags & ISCSI_TF_EXPIRED)\r\nreturn -1;\r\nif (!(sess->time2retain_timer_flags & ISCSI_TF_RUNNING))\r\nreturn 0;\r\nsess->time2retain_timer_flags |= ISCSI_TF_STOP;\r\nspin_unlock(&se_tpg->session_lock);\r\ndel_timer_sync(&sess->time2retain_timer);\r\nspin_lock(&se_tpg->session_lock);\r\nsess->time2retain_timer_flags &= ~ISCSI_TF_RUNNING;\r\npr_debug("Stopped Time2Retain Timer for SID: %u\n",\r\nsess->sid);\r\nreturn 0;\r\n}\r\nvoid iscsit_connection_reinstatement_rcfr(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->state_lock);\r\nif (atomic_read(&conn->connection_exit)) {\r\nspin_unlock_bh(&conn->state_lock);\r\ngoto sleep;\r\n}\r\nif (atomic_read(&conn->transport_failed)) {\r\nspin_unlock_bh(&conn->state_lock);\r\ngoto sleep;\r\n}\r\nspin_unlock_bh(&conn->state_lock);\r\nif (conn->tx_thread && conn->tx_thread_active)\r\nsend_sig(SIGINT, conn->tx_thread, 1);\r\nif (conn->rx_thread && conn->rx_thread_active)\r\nsend_sig(SIGINT, conn->rx_thread, 1);\r\nsleep:\r\nwait_for_completion(&conn->conn_wait_rcfr_comp);\r\ncomplete(&conn->conn_post_wait_comp);\r\n}\r\nvoid iscsit_cause_connection_reinstatement(struct iscsi_conn *conn, int sleep)\r\n{\r\nspin_lock_bh(&conn->state_lock);\r\nif (atomic_read(&conn->connection_exit)) {\r\nspin_unlock_bh(&conn->state_lock);\r\nreturn;\r\n}\r\nif (atomic_read(&conn->transport_failed)) {\r\nspin_unlock_bh(&conn->state_lock);\r\nreturn;\r\n}\r\nif (atomic_read(&conn->connection_reinstatement)) {\r\nspin_unlock_bh(&conn->state_lock);\r\nreturn;\r\n}\r\nif (conn->tx_thread && conn->tx_thread_active)\r\nsend_sig(SIGINT, conn->tx_thread, 1);\r\nif (conn->rx_thread && conn->rx_thread_active)\r\nsend_sig(SIGINT, conn->rx_thread, 1);\r\natomic_set(&conn->connection_reinstatement, 1);\r\nif (!sleep) {\r\nspin_unlock_bh(&conn->state_lock);\r\nreturn;\r\n}\r\natomic_set(&conn->sleep_on_conn_wait_comp, 1);\r\nspin_unlock_bh(&conn->state_lock);\r\nwait_for_completion(&conn->conn_wait_comp);\r\ncomplete(&conn->conn_post_wait_comp);\r\n}\r\nvoid iscsit_fall_back_to_erl0(struct iscsi_session *sess)\r\n{\r\npr_debug("Falling back to ErrorRecoveryLevel=0 for SID:"\r\n" %u\n", sess->sid);\r\natomic_set(&sess->session_fall_back_to_erl0, 1);\r\n}\r\nstatic void iscsit_handle_connection_cleanup(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nif ((sess->sess_ops->ErrorRecoveryLevel == 2) &&\r\n!atomic_read(&sess->session_reinstatement) &&\r\n!atomic_read(&sess->session_fall_back_to_erl0))\r\niscsit_connection_recovery_transport_reset(conn);\r\nelse {\r\npr_debug("Performing cleanup for failed iSCSI"\r\n" Connection ID: %hu from %s\n", conn->cid,\r\nsess->sess_ops->InitiatorName);\r\niscsit_close_connection(conn);\r\n}\r\n}\r\nvoid iscsit_take_action_for_connection_exit(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->state_lock);\r\nif (atomic_read(&conn->connection_exit)) {\r\nspin_unlock_bh(&conn->state_lock);\r\nreturn;\r\n}\r\natomic_set(&conn->connection_exit, 1);\r\nif (conn->conn_state == TARG_CONN_STATE_IN_LOGOUT) {\r\nspin_unlock_bh(&conn->state_lock);\r\niscsit_close_connection(conn);\r\nreturn;\r\n}\r\nif (conn->conn_state == TARG_CONN_STATE_CLEANUP_WAIT) {\r\nspin_unlock_bh(&conn->state_lock);\r\nreturn;\r\n}\r\npr_debug("Moving to TARG_CONN_STATE_CLEANUP_WAIT.\n");\r\nconn->conn_state = TARG_CONN_STATE_CLEANUP_WAIT;\r\nspin_unlock_bh(&conn->state_lock);\r\niscsit_handle_connection_cleanup(conn);\r\n}
