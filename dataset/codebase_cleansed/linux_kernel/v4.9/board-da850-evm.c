static void da850_evm_m25p80_notify_add(struct mtd_info *mtd)\r\n{\r\nchar *mac_addr = davinci_soc_info.emac_pdata->mac_addr;\r\nsize_t retlen;\r\nif (!strcmp(mtd->name, "MAC-Address")) {\r\nmtd_read(mtd, 0, ETH_ALEN, &retlen, mac_addr);\r\nif (retlen == ETH_ALEN)\r\npr_info("Read MAC addr from SPI Flash: %pM\n",\r\nmac_addr);\r\n}\r\n}\r\nstatic void da850_evm_setup_mac_addr(void)\r\n{\r\nregister_mtd_user(&da850evm_spi_notifier);\r\n}\r\nstatic void da850_evm_setup_mac_addr(void) { }\r\nstatic void __init da850_evm_init_nor(void)\r\n{\r\nvoid __iomem *aemif_addr;\r\naemif_addr = ioremap(DA8XX_AEMIF_CTL_BASE, SZ_32K);\r\nwritel(readl(aemif_addr + DA8XX_AEMIF_CE2CFG_OFFSET) |\r\nDA8XX_AEMIF_ASIZE_16BIT,\r\naemif_addr + DA8XX_AEMIF_CE2CFG_OFFSET);\r\niounmap(aemif_addr);\r\n}\r\nstatic inline void da850_evm_setup_nor_nand(void)\r\n{\r\nint ret = 0;\r\nif (!HAS_MMC) {\r\nret = davinci_cfg_reg_list(da850_evm_nand_pins);\r\nif (ret)\r\npr_warn("%s: NAND mux setup failed: %d\n",\r\n__func__, ret);\r\nret = davinci_cfg_reg_list(da850_evm_nor_pins);\r\nif (ret)\r\npr_warn("%s: NOR mux setup failed: %d\n",\r\n__func__, ret);\r\nda850_evm_init_nor();\r\nplatform_add_devices(da850_evm_devices,\r\nARRAY_SIZE(da850_evm_devices));\r\nif (davinci_aemif_setup(&da850_evm_nandflash_device))\r\npr_warn("%s: Cannot configure AEMIF.\n", __func__);\r\n}\r\n}\r\nstatic inline void da850_evm_setup_emac_rmii(int rmii_sel)\r\n{\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nsoc_info->emac_pdata->rmii_en = 1;\r\ngpio_set_value_cansleep(rmii_sel, 0);\r\n}\r\nstatic inline void da850_evm_setup_emac_rmii(int rmii_sel) { }\r\nstatic void da850_evm_ui_keys_init(unsigned gpio)\r\n{\r\nint i;\r\nstruct gpio_keys_button *button;\r\nfor (i = 0; i < DA850_N_UI_PB; i++) {\r\nbutton = &da850_evm_ui_keys[i];\r\nbutton->code = KEY_F8 - i;\r\nbutton->desc = da850_evm_ui_exp[DA850_EVM_UI_EXP_PB8 + i];\r\nbutton->gpio = gpio + DA850_EVM_UI_EXP_PB8 + i;\r\n}\r\n}\r\nstatic inline void da850_evm_setup_video_port(int video_sel)\r\n{\r\ngpio_set_value_cansleep(video_sel, 0);\r\n}\r\nstatic inline void da850_evm_setup_video_port(int video_sel) { }\r\nstatic int da850_evm_ui_expander_setup(struct i2c_client *client, unsigned gpio,\r\nunsigned ngpio, void *c)\r\n{\r\nint sel_a, sel_b, sel_c, ret;\r\nsel_a = gpio + DA850_EVM_UI_EXP_SEL_A;\r\nsel_b = gpio + DA850_EVM_UI_EXP_SEL_B;\r\nsel_c = gpio + DA850_EVM_UI_EXP_SEL_C;\r\nret = gpio_request(sel_a, da850_evm_ui_exp[DA850_EVM_UI_EXP_SEL_A]);\r\nif (ret) {\r\npr_warn("Cannot open UI expander pin %d\n", sel_a);\r\ngoto exp_setup_sela_fail;\r\n}\r\nret = gpio_request(sel_b, da850_evm_ui_exp[DA850_EVM_UI_EXP_SEL_B]);\r\nif (ret) {\r\npr_warn("Cannot open UI expander pin %d\n", sel_b);\r\ngoto exp_setup_selb_fail;\r\n}\r\nret = gpio_request(sel_c, da850_evm_ui_exp[DA850_EVM_UI_EXP_SEL_C]);\r\nif (ret) {\r\npr_warn("Cannot open UI expander pin %d\n", sel_c);\r\ngoto exp_setup_selc_fail;\r\n}\r\ngpio_direction_output(sel_a, 1);\r\ngpio_direction_output(sel_b, 1);\r\ngpio_direction_output(sel_c, 1);\r\nda850_evm_ui_keys_init(gpio);\r\nret = platform_device_register(&da850_evm_ui_keys_device);\r\nif (ret) {\r\npr_warn("Could not register UI GPIO expander push-buttons");\r\ngoto exp_setup_keys_fail;\r\n}\r\npr_info("DA850/OMAP-L138 EVM UI card detected\n");\r\nda850_evm_setup_nor_nand();\r\nda850_evm_setup_emac_rmii(sel_a);\r\nda850_evm_setup_video_port(sel_c);\r\nreturn 0;\r\nexp_setup_keys_fail:\r\ngpio_free(sel_c);\r\nexp_setup_selc_fail:\r\ngpio_free(sel_b);\r\nexp_setup_selb_fail:\r\ngpio_free(sel_a);\r\nexp_setup_sela_fail:\r\nreturn ret;\r\n}\r\nstatic int da850_evm_ui_expander_teardown(struct i2c_client *client,\r\nunsigned gpio, unsigned ngpio, void *c)\r\n{\r\nplatform_device_unregister(&da850_evm_ui_keys_device);\r\ngpio_set_value_cansleep(gpio + DA850_EVM_UI_EXP_SEL_C, 1);\r\ngpio_set_value_cansleep(gpio + DA850_EVM_UI_EXP_SEL_B, 1);\r\ngpio_set_value_cansleep(gpio + DA850_EVM_UI_EXP_SEL_A, 1);\r\ngpio_free(gpio + DA850_EVM_UI_EXP_SEL_C);\r\ngpio_free(gpio + DA850_EVM_UI_EXP_SEL_B);\r\ngpio_free(gpio + DA850_EVM_UI_EXP_SEL_A);\r\nreturn 0;\r\n}\r\nstatic void da850_evm_bb_keys_init(unsigned gpio)\r\n{\r\nint i;\r\nstruct gpio_keys_button *button;\r\nbutton = &da850_evm_bb_keys[0];\r\nbutton->desc = da850_evm_bb_exp[DA850_EVM_BB_EXP_USER_PB1];\r\nbutton->gpio = gpio + DA850_EVM_BB_EXP_USER_PB1;\r\nfor (i = 0; i < DA850_N_BB_USER_SW; i++) {\r\nbutton = &da850_evm_bb_keys[i + 1];\r\nbutton->code = SW_LID + i;\r\nbutton->desc = da850_evm_bb_exp[DA850_EVM_BB_EXP_USER_SW1 + i];\r\nbutton->gpio = gpio + DA850_EVM_BB_EXP_USER_SW1 + i;\r\n}\r\n}\r\nstatic void da850_evm_bb_leds_init(unsigned gpio)\r\n{\r\nint i;\r\nstruct gpio_led *led;\r\nfor (i = 0; i < DA850_N_BB_USER_LED; i++) {\r\nled = &da850_evm_bb_leds[i];\r\nled->gpio = gpio + DA850_EVM_BB_EXP_USER_LED2 + i;\r\nled->name =\r\nda850_evm_bb_exp[DA850_EVM_BB_EXP_USER_LED2 + i];\r\n}\r\n}\r\nstatic int da850_evm_bb_expander_setup(struct i2c_client *client,\r\nunsigned gpio, unsigned ngpio,\r\nvoid *c)\r\n{\r\nint ret;\r\nda850_evm_bb_keys_init(gpio);\r\nret = platform_device_register(&da850_evm_bb_keys_device);\r\nif (ret) {\r\npr_warn("Could not register baseboard GPIO expander keys");\r\ngoto io_exp_setup_sw_fail;\r\n}\r\nda850_evm_bb_leds_init(gpio);\r\nret = platform_device_register(&da850_evm_bb_leds_device);\r\nif (ret) {\r\npr_warn("Could not register baseboard GPIO expander LEDs");\r\ngoto io_exp_setup_leds_fail;\r\n}\r\nreturn 0;\r\nio_exp_setup_leds_fail:\r\nplatform_device_unregister(&da850_evm_bb_keys_device);\r\nio_exp_setup_sw_fail:\r\nreturn ret;\r\n}\r\nstatic int da850_evm_bb_expander_teardown(struct i2c_client *client,\r\nunsigned gpio, unsigned ngpio, void *c)\r\n{\r\nplatform_device_unregister(&da850_evm_bb_leds_device);\r\nplatform_device_unregister(&da850_evm_bb_keys_device);\r\nreturn 0;\r\n}\r\nstatic int da850_evm_mmc_get_ro(int index)\r\n{\r\nreturn gpio_get_value(DA850_MMCSD_WP_PIN);\r\n}\r\nstatic int da850_evm_mmc_get_cd(int index)\r\n{\r\nreturn !gpio_get_value(DA850_MMCSD_CD_PIN);\r\n}\r\nstatic void da850_panel_power_ctrl(int val)\r\n{\r\ngpio_set_value(DA850_LCD_BL_PIN, val);\r\ngpio_set_value(DA850_LCD_PWR_PIN, val);\r\n}\r\nstatic int da850_lcd_hw_init(void)\r\n{\r\nint status;\r\nstatus = gpio_request(DA850_LCD_BL_PIN, "lcd bl\n");\r\nif (status < 0)\r\nreturn status;\r\nstatus = gpio_request(DA850_LCD_PWR_PIN, "lcd pwr\n");\r\nif (status < 0) {\r\ngpio_free(DA850_LCD_BL_PIN);\r\nreturn status;\r\n}\r\ngpio_direction_output(DA850_LCD_BL_PIN, 0);\r\ngpio_direction_output(DA850_LCD_PWR_PIN, 0);\r\nda850_panel_power_ctrl(0);\r\nda850_panel_power_ctrl(1);\r\nreturn 0;\r\n}\r\nstatic int __init pmic_tps65070_init(void)\r\n{\r\nreturn i2c_register_board_info(1, da850_evm_tps65070_info,\r\nARRAY_SIZE(da850_evm_tps65070_info));\r\n}\r\nstatic int __init da850_evm_config_emac(void)\r\n{\r\nvoid __iomem *cfg_chip3_base;\r\nint ret;\r\nu32 val;\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nu8 rmii_en = soc_info->emac_pdata->rmii_en;\r\nif (!machine_is_davinci_da850_evm())\r\nreturn 0;\r\ncfg_chip3_base = DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG);\r\nval = __raw_readl(cfg_chip3_base);\r\nif (rmii_en) {\r\nval |= BIT(8);\r\nret = davinci_cfg_reg_list(da850_evm_rmii_pins);\r\npr_info("EMAC: RMII PHY configured, MII PHY will not be"\r\n" functional\n");\r\n} else {\r\nval &= ~BIT(8);\r\nret = davinci_cfg_reg_list(da850_evm_mii_pins);\r\npr_info("EMAC: MII PHY configured, RMII PHY will not be"\r\n" functional\n");\r\n}\r\nif (ret)\r\npr_warn("%s: CPGMAC/RMII mux setup failed: %d\n",\r\n__func__, ret);\r\n__raw_writel(val, cfg_chip3_base);\r\nret = davinci_cfg_reg(DA850_GPIO2_6);\r\nif (ret)\r\npr_warn("%s:GPIO(2,6) mux setup failed\n", __func__);\r\nret = gpio_request(DA850_MII_MDIO_CLKEN_PIN, "mdio_clk_en");\r\nif (ret) {\r\npr_warn("Cannot open GPIO %d\n", DA850_MII_MDIO_CLKEN_PIN);\r\nreturn ret;\r\n}\r\ngpio_direction_output(DA850_MII_MDIO_CLKEN_PIN, rmii_en);\r\nsoc_info->emac_pdata->phy_id = DA850_EVM_PHY_ID;\r\nret = da8xx_register_emac();\r\nif (ret)\r\npr_warn("%s: EMAC registration failed: %d\n", __func__, ret);\r\nreturn 0;\r\n}\r\nstatic __init int da850_evm_init_cpufreq(void)\r\n{\r\nswitch (system_rev & 0xF) {\r\ncase 3:\r\nda850_max_speed = 456000;\r\nbreak;\r\ncase 2:\r\nda850_max_speed = 408000;\r\nbreak;\r\ncase 1:\r\nda850_max_speed = 372000;\r\nbreak;\r\n}\r\nreturn da850_register_cpufreq("pll0_sysclk3");\r\n}\r\nstatic __init int da850_evm_init_cpufreq(void) { return 0; }\r\nstatic __init void da850_vpif_init(void)\r\n{\r\nint ret;\r\nret = da850_register_vpif();\r\nif (ret)\r\npr_warn("da850_evm_init: VPIF setup failed: %d\n", ret);\r\nret = davinci_cfg_reg_list(da850_vpif_capture_pins);\r\nif (ret)\r\npr_warn("da850_evm_init: VPIF capture mux setup failed: %d\n",\r\nret);\r\nret = da850_register_vpif_capture(&da850_vpif_capture_config);\r\nif (ret)\r\npr_warn("da850_evm_init: VPIF capture setup failed: %d\n", ret);\r\nret = davinci_cfg_reg_list(da850_vpif_display_pins);\r\nif (ret)\r\npr_warn("da850_evm_init: VPIF display mux setup failed: %d\n",\r\nret);\r\nret = da850_register_vpif_display(&da850_vpif_display_config);\r\nif (ret)\r\npr_warn("da850_evm_init: VPIF display setup failed: %d\n", ret);\r\n}\r\nstatic __init void da850_vpif_init(void) {}\r\nstatic __init void da850_evm_init(void)\r\n{\r\nint ret;\r\nret = da850_register_gpio();\r\nif (ret)\r\npr_warn("%s: GPIO init failed: %d\n", __func__, ret);\r\nregulator_register_fixed(0, fixed_supplies, ARRAY_SIZE(fixed_supplies));\r\nret = pmic_tps65070_init();\r\nif (ret)\r\npr_warn("%s: TPS65070 PMIC init failed: %d\n", __func__, ret);\r\nret = da850_register_edma(da850_edma_rsv);\r\nif (ret)\r\npr_warn("%s: EDMA registration failed: %d\n", __func__, ret);\r\nret = davinci_cfg_reg_list(da850_i2c0_pins);\r\nif (ret)\r\npr_warn("%s: I2C0 mux setup failed: %d\n", __func__, ret);\r\nret = da8xx_register_i2c(0, &da850_evm_i2c_0_pdata);\r\nif (ret)\r\npr_warn("%s: I2C0 registration failed: %d\n", __func__, ret);\r\nret = da8xx_register_watchdog();\r\nif (ret)\r\npr_warn("%s: watchdog registration failed: %d\n",\r\n__func__, ret);\r\nif (HAS_MMC) {\r\nret = davinci_cfg_reg_list(da850_evm_mmcsd0_pins);\r\nif (ret)\r\npr_warn("%s: MMCSD0 mux setup failed: %d\n",\r\n__func__, ret);\r\nret = gpio_request(DA850_MMCSD_CD_PIN, "MMC CD\n");\r\nif (ret)\r\npr_warn("%s: can not open GPIO %d\n",\r\n__func__, DA850_MMCSD_CD_PIN);\r\ngpio_direction_input(DA850_MMCSD_CD_PIN);\r\nret = gpio_request(DA850_MMCSD_WP_PIN, "MMC WP\n");\r\nif (ret)\r\npr_warn("%s: can not open GPIO %d\n",\r\n__func__, DA850_MMCSD_WP_PIN);\r\ngpio_direction_input(DA850_MMCSD_WP_PIN);\r\nret = da8xx_register_mmcsd0(&da850_mmc_config);\r\nif (ret)\r\npr_warn("%s: MMCSD0 registration failed: %d\n",\r\n__func__, ret);\r\n}\r\ndavinci_serial_init(da8xx_serial_device);\r\ni2c_register_board_info(1, da850_evm_i2c_devices,\r\nARRAY_SIZE(da850_evm_i2c_devices));\r\n__raw_writel(0, IO_ADDRESS(DA8XX_UART1_BASE) + 0x30);\r\n__raw_writel(0, IO_ADDRESS(DA8XX_UART0_BASE) + 0x30);\r\nret = davinci_cfg_reg_list(da850_evm_mcasp_pins);\r\nif (ret)\r\npr_warn("%s: McASP mux setup failed: %d\n", __func__, ret);\r\nda850_evm_snd_data.sram_pool = sram_get_gen_pool();\r\nda8xx_register_mcasp(0, &da850_evm_snd_data);\r\nret = davinci_cfg_reg_list(da850_lcdcntl_pins);\r\nif (ret)\r\npr_warn("%s: LCDC mux setup failed: %d\n", __func__, ret);\r\nret = da8xx_register_uio_pruss();\r\nif (ret)\r\npr_warn("da850_evm_init: pruss initialization failed: %d\n",\r\nret);\r\nret = davinci_cfg_reg_list(da850_evm_lcdc_pins);\r\nif (ret)\r\npr_warn("%s: EVM specific LCD mux setup failed: %d\n",\r\n__func__, ret);\r\nret = da850_lcd_hw_init();\r\nif (ret)\r\npr_warn("%s: LCD initialization failed: %d\n", __func__, ret);\r\nsharp_lk043t1dg01_pdata.panel_power_ctrl = da850_panel_power_ctrl,\r\nret = da8xx_register_lcdc(&sharp_lk043t1dg01_pdata);\r\nif (ret)\r\npr_warn("%s: LCDC registration failed: %d\n", __func__, ret);\r\nret = da8xx_register_rtc();\r\nif (ret)\r\npr_warn("%s: RTC setup failed: %d\n", __func__, ret);\r\nret = da850_evm_init_cpufreq();\r\nif (ret)\r\npr_warn("%s: cpufreq registration failed: %d\n", __func__, ret);\r\nret = da8xx_register_cpuidle();\r\nif (ret)\r\npr_warn("%s: cpuidle registration failed: %d\n", __func__, ret);\r\nret = da850_register_pm(&da850_pm_device);\r\nif (ret)\r\npr_warn("%s: suspend registration failed: %d\n", __func__, ret);\r\nda850_vpif_init();\r\nret = spi_register_board_info(da850evm_spi_info,\r\nARRAY_SIZE(da850evm_spi_info));\r\nif (ret)\r\npr_warn("%s: spi info registration failed: %d\n", __func__,\r\nret);\r\nret = da8xx_register_spi_bus(1, ARRAY_SIZE(da850evm_spi_info));\r\nif (ret)\r\npr_warn("%s: SPI 1 registration failed: %d\n", __func__, ret);\r\nret = da850_register_sata(DA850EVM_SATA_REFCLKPN_RATE);\r\nif (ret)\r\npr_warn("%s: SATA registration failed: %d\n", __func__, ret);\r\nda850_evm_setup_mac_addr();\r\nret = da8xx_register_rproc();\r\nif (ret)\r\npr_warn("%s: dsp/rproc registration failed: %d\n",\r\n__func__, ret);\r\n}\r\nstatic int __init da850_evm_console_init(void)\r\n{\r\nif (!machine_is_davinci_da850_evm())\r\nreturn 0;\r\nreturn add_preferred_console("ttyS", 2, "115200");\r\n}\r\nstatic void __init da850_evm_map_io(void)\r\n{\r\nda850_init();\r\n}
