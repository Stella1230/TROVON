static u32 get_msglevel(struct net_device *dev)\r\n{\r\nreturn netdev2adap(dev)->msg_enable;\r\n}\r\nstatic void set_msglevel(struct net_device *dev, u32 val)\r\n{\r\nnetdev2adap(dev)->msg_enable = val;\r\n}\r\nstatic int get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(stats_strings) +\r\nARRAY_SIZE(adapter_stats_strings) +\r\nARRAY_SIZE(channel_stats_strings) +\r\nARRAY_SIZE(loopback_stats_strings);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int get_regs_len(struct net_device *dev)\r\n{\r\nstruct adapter *adap = netdev2adap(dev);\r\nreturn t4_get_regs_len(adap);\r\n}\r\nstatic int get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn EEPROMSIZE;\r\n}\r\nstatic void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct adapter *adapter = netdev2adap(dev);\r\nu32 exprom_vers;\r\nstrlcpy(info->driver, cxgb4_driver_name, sizeof(info->driver));\r\nstrlcpy(info->version, cxgb4_driver_version,\r\nsizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(adapter->pdev),\r\nsizeof(info->bus_info));\r\ninfo->regdump_len = get_regs_len(dev);\r\nif (!adapter->params.fw_vers)\r\nstrcpy(info->fw_version, "N/A");\r\nelse\r\nsnprintf(info->fw_version, sizeof(info->fw_version),\r\n"%u.%u.%u.%u, TP %u.%u.%u.%u",\r\nFW_HDR_FW_VER_MAJOR_G(adapter->params.fw_vers),\r\nFW_HDR_FW_VER_MINOR_G(adapter->params.fw_vers),\r\nFW_HDR_FW_VER_MICRO_G(adapter->params.fw_vers),\r\nFW_HDR_FW_VER_BUILD_G(adapter->params.fw_vers),\r\nFW_HDR_FW_VER_MAJOR_G(adapter->params.tp_vers),\r\nFW_HDR_FW_VER_MINOR_G(adapter->params.tp_vers),\r\nFW_HDR_FW_VER_MICRO_G(adapter->params.tp_vers),\r\nFW_HDR_FW_VER_BUILD_G(adapter->params.tp_vers));\r\nif (!t4_get_exprom_version(adapter, &exprom_vers))\r\nsnprintf(info->erom_version, sizeof(info->erom_version),\r\n"%u.%u.%u.%u",\r\nFW_HDR_FW_VER_MAJOR_G(exprom_vers),\r\nFW_HDR_FW_VER_MINOR_G(exprom_vers),\r\nFW_HDR_FW_VER_MICRO_G(exprom_vers),\r\nFW_HDR_FW_VER_BUILD_G(exprom_vers));\r\n}\r\nstatic void get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nif (stringset == ETH_SS_STATS) {\r\nmemcpy(data, stats_strings, sizeof(stats_strings));\r\ndata += sizeof(stats_strings);\r\nmemcpy(data, adapter_stats_strings,\r\nsizeof(adapter_stats_strings));\r\ndata += sizeof(adapter_stats_strings);\r\nmemcpy(data, channel_stats_strings,\r\nsizeof(channel_stats_strings));\r\ndata += sizeof(channel_stats_strings);\r\nmemcpy(data, loopback_stats_strings,\r\nsizeof(loopback_stats_strings));\r\n}\r\n}\r\nstatic void collect_sge_port_stats(const struct adapter *adap,\r\nconst struct port_info *p,\r\nstruct queue_port_stats *s)\r\n{\r\nint i;\r\nconst struct sge_eth_txq *tx = &adap->sge.ethtxq[p->first_qset];\r\nconst struct sge_eth_rxq *rx = &adap->sge.ethrxq[p->first_qset];\r\nmemset(s, 0, sizeof(*s));\r\nfor (i = 0; i < p->nqsets; i++, rx++, tx++) {\r\ns->tso += tx->tso;\r\ns->tx_csum += tx->tx_cso;\r\ns->rx_csum += rx->stats.rx_cso;\r\ns->vlan_ex += rx->stats.vlan_ex;\r\ns->vlan_ins += tx->vlan_ins;\r\ns->gro_pkts += rx->stats.lro_pkts;\r\ns->gro_merged += rx->stats.lro_merged;\r\n}\r\n}\r\nstatic void collect_adapter_stats(struct adapter *adap, struct adapter_stats *s)\r\n{\r\nstruct tp_tcp_stats v4, v6;\r\nstruct tp_rdma_stats rdma_stats;\r\nstruct tp_err_stats err_stats;\r\nstruct tp_usm_stats usm_stats;\r\nu64 val1, val2;\r\nmemset(s, 0, sizeof(*s));\r\nspin_lock(&adap->stats_lock);\r\nt4_tp_get_tcp_stats(adap, &v4, &v6);\r\nt4_tp_get_rdma_stats(adap, &rdma_stats);\r\nt4_get_usm_stats(adap, &usm_stats);\r\nt4_tp_get_err_stats(adap, &err_stats);\r\nspin_unlock(&adap->stats_lock);\r\ns->db_drop = adap->db_stats.db_drop;\r\ns->db_full = adap->db_stats.db_full;\r\ns->db_empty = adap->db_stats.db_empty;\r\ns->tcp_v4_out_rsts = v4.tcp_out_rsts;\r\ns->tcp_v4_in_segs = v4.tcp_in_segs;\r\ns->tcp_v4_out_segs = v4.tcp_out_segs;\r\ns->tcp_v4_retrans_segs = v4.tcp_retrans_segs;\r\ns->tcp_v6_out_rsts = v6.tcp_out_rsts;\r\ns->tcp_v6_in_segs = v6.tcp_in_segs;\r\ns->tcp_v6_out_segs = v6.tcp_out_segs;\r\ns->tcp_v6_retrans_segs = v6.tcp_retrans_segs;\r\nif (is_offload(adap)) {\r\ns->frames = usm_stats.frames;\r\ns->octets = usm_stats.octets;\r\ns->drops = usm_stats.drops;\r\ns->rqe_dfr_mod = rdma_stats.rqe_dfr_mod;\r\ns->rqe_dfr_pkt = rdma_stats.rqe_dfr_pkt;\r\n}\r\ns->ofld_no_neigh = err_stats.ofld_no_neigh;\r\ns->ofld_cong_defer = err_stats.ofld_cong_defer;\r\nif (!is_t4(adap->params.chip)) {\r\nint v;\r\nv = t4_read_reg(adap, SGE_STAT_CFG_A);\r\nif (STATSOURCE_T5_G(v) == 7) {\r\nval2 = t4_read_reg(adap, SGE_STAT_MATCH_A);\r\nval1 = t4_read_reg(adap, SGE_STAT_TOTAL_A);\r\ns->wc_success = val1 - val2;\r\ns->wc_fail = val2;\r\n}\r\n}\r\n}\r\nstatic void collect_channel_stats(struct adapter *adap, struct channel_stats *s,\r\nu8 i)\r\n{\r\nstruct tp_cpl_stats cpl_stats;\r\nstruct tp_err_stats err_stats;\r\nstruct tp_fcoe_stats fcoe_stats;\r\nmemset(s, 0, sizeof(*s));\r\nspin_lock(&adap->stats_lock);\r\nt4_tp_get_cpl_stats(adap, &cpl_stats);\r\nt4_tp_get_err_stats(adap, &err_stats);\r\nt4_get_fcoe_stats(adap, i, &fcoe_stats);\r\nspin_unlock(&adap->stats_lock);\r\ns->cpl_req = cpl_stats.req[i];\r\ns->cpl_rsp = cpl_stats.rsp[i];\r\ns->mac_in_errs = err_stats.mac_in_errs[i];\r\ns->hdr_in_errs = err_stats.hdr_in_errs[i];\r\ns->tcp_in_errs = err_stats.tcp_in_errs[i];\r\ns->tcp6_in_errs = err_stats.tcp6_in_errs[i];\r\ns->tnl_cong_drops = err_stats.tnl_cong_drops[i];\r\ns->tnl_tx_drops = err_stats.tnl_tx_drops[i];\r\ns->ofld_vlan_drops = err_stats.ofld_vlan_drops[i];\r\ns->ofld_chan_drops = err_stats.ofld_chan_drops[i];\r\ns->octets_ddp = fcoe_stats.octets_ddp;\r\ns->frames_ddp = fcoe_stats.frames_ddp;\r\ns->frames_drop = fcoe_stats.frames_drop;\r\n}\r\nstatic void get_stats(struct net_device *dev, struct ethtool_stats *stats,\r\nu64 *data)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nstruct lb_port_stats s;\r\nint i;\r\nu64 *p0;\r\nt4_get_port_stats_offset(adapter, pi->tx_chan,\r\n(struct port_stats *)data,\r\n&pi->stats_base);\r\ndata += sizeof(struct port_stats) / sizeof(u64);\r\ncollect_sge_port_stats(adapter, pi, (struct queue_port_stats *)data);\r\ndata += sizeof(struct queue_port_stats) / sizeof(u64);\r\ncollect_adapter_stats(adapter, (struct adapter_stats *)data);\r\ndata += sizeof(struct adapter_stats) / sizeof(u64);\r\n*data++ = (u64)pi->port_id;\r\ncollect_channel_stats(adapter, (struct channel_stats *)data,\r\npi->port_id);\r\ndata += sizeof(struct channel_stats) / sizeof(u64);\r\n*data++ = (u64)pi->port_id;\r\nmemset(&s, 0, sizeof(s));\r\nt4_get_lb_stats(adapter, pi->port_id, &s);\r\np0 = &s.octets;\r\nfor (i = 0; i < ARRAY_SIZE(loopback_stats_strings) - 1; i++)\r\n*data++ = (unsigned long long)*p0++;\r\n}\r\nstatic void get_regs(struct net_device *dev, struct ethtool_regs *regs,\r\nvoid *buf)\r\n{\r\nstruct adapter *adap = netdev2adap(dev);\r\nsize_t buf_size;\r\nbuf_size = t4_get_regs_len(adap);\r\nregs->version = mk_adap_vers(adap);\r\nt4_get_regs(adap, buf, buf_size);\r\n}\r\nstatic int restart_autoneg(struct net_device *dev)\r\n{\r\nstruct port_info *p = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EAGAIN;\r\nif (p->link_cfg.autoneg != AUTONEG_ENABLE)\r\nreturn -EINVAL;\r\nt4_restart_aneg(p->adapter, p->adapter->pf, p->tx_chan);\r\nreturn 0;\r\n}\r\nstatic int identify_port(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nunsigned int val;\r\nstruct adapter *adap = netdev2adap(dev);\r\nif (state == ETHTOOL_ID_ACTIVE)\r\nval = 0xffff;\r\nelse if (state == ETHTOOL_ID_INACTIVE)\r\nval = 0;\r\nelse\r\nreturn -EINVAL;\r\nreturn t4_identify_port(adap, adap->pf, netdev2pinfo(dev)->viid, val);\r\n}\r\nstatic int from_fw_port_mod_type(enum fw_port_type port_type,\r\nenum fw_port_module_type mod_type)\r\n{\r\nif (port_type == FW_PORT_TYPE_BT_SGMII ||\r\nport_type == FW_PORT_TYPE_BT_XFI ||\r\nport_type == FW_PORT_TYPE_BT_XAUI) {\r\nreturn PORT_TP;\r\n} else if (port_type == FW_PORT_TYPE_FIBER_XFI ||\r\nport_type == FW_PORT_TYPE_FIBER_XAUI) {\r\nreturn PORT_FIBRE;\r\n} else if (port_type == FW_PORT_TYPE_SFP ||\r\nport_type == FW_PORT_TYPE_QSFP_10G ||\r\nport_type == FW_PORT_TYPE_QSA ||\r\nport_type == FW_PORT_TYPE_QSFP) {\r\nif (mod_type == FW_PORT_MOD_TYPE_LR ||\r\nmod_type == FW_PORT_MOD_TYPE_SR ||\r\nmod_type == FW_PORT_MOD_TYPE_ER ||\r\nmod_type == FW_PORT_MOD_TYPE_LRM)\r\nreturn PORT_FIBRE;\r\nelse if (mod_type == FW_PORT_MOD_TYPE_TWINAX_PASSIVE ||\r\nmod_type == FW_PORT_MOD_TYPE_TWINAX_ACTIVE)\r\nreturn PORT_DA;\r\nelse\r\nreturn PORT_OTHER;\r\n}\r\nreturn PORT_OTHER;\r\n}\r\nstatic unsigned int speed_to_fw_caps(int speed)\r\n{\r\nif (speed == 100)\r\nreturn FW_PORT_CAP_SPEED_100M;\r\nif (speed == 1000)\r\nreturn FW_PORT_CAP_SPEED_1G;\r\nif (speed == 10000)\r\nreturn FW_PORT_CAP_SPEED_10G;\r\nif (speed == 25000)\r\nreturn FW_PORT_CAP_SPEED_25G;\r\nif (speed == 40000)\r\nreturn FW_PORT_CAP_SPEED_40G;\r\nif (speed == 100000)\r\nreturn FW_PORT_CAP_SPEED_100G;\r\nreturn 0;\r\n}\r\nstatic void fw_caps_to_lmm(enum fw_port_type port_type,\r\nunsigned int fw_caps,\r\nunsigned long *link_mode_mask)\r\n{\r\n#define SET_LMM(__lmm_name) __set_bit(ETHTOOL_LINK_MODE_ ## __lmm_name \\r\n## _BIT, link_mode_mask)\r\n#define FW_CAPS_TO_LMM(__fw_name, __lmm_name) \\r\ndo { \\r\nif (fw_caps & FW_PORT_CAP_ ## __fw_name) \\r\nSET_LMM(__lmm_name); \\r\n} while (0)\r\nswitch (port_type) {\r\ncase FW_PORT_TYPE_BT_SGMII:\r\ncase FW_PORT_TYPE_BT_XFI:\r\ncase FW_PORT_TYPE_BT_XAUI:\r\nSET_LMM(TP);\r\nFW_CAPS_TO_LMM(SPEED_100M, 100baseT_Full);\r\nFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\r\nFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_KX4:\r\ncase FW_PORT_TYPE_KX:\r\nSET_LMM(Backplane);\r\nFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\r\nFW_CAPS_TO_LMM(SPEED_10G, 10000baseKX4_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_KR:\r\nSET_LMM(Backplane);\r\nSET_LMM(10000baseKR_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_BP_AP:\r\nSET_LMM(Backplane);\r\nSET_LMM(10000baseR_FEC);\r\nSET_LMM(10000baseKR_Full);\r\nSET_LMM(1000baseKX_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_BP4_AP:\r\nSET_LMM(Backplane);\r\nSET_LMM(10000baseR_FEC);\r\nSET_LMM(10000baseKR_Full);\r\nSET_LMM(1000baseKX_Full);\r\nSET_LMM(10000baseKX4_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_FIBER_XFI:\r\ncase FW_PORT_TYPE_FIBER_XAUI:\r\ncase FW_PORT_TYPE_SFP:\r\ncase FW_PORT_TYPE_QSFP_10G:\r\ncase FW_PORT_TYPE_QSA:\r\nSET_LMM(FIBRE);\r\nFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\r\nFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_BP40_BA:\r\ncase FW_PORT_TYPE_QSFP:\r\nSET_LMM(FIBRE);\r\nSET_LMM(40000baseSR4_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_CR_QSFP:\r\ncase FW_PORT_TYPE_SFP28:\r\nSET_LMM(FIBRE);\r\nSET_LMM(25000baseCR_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_KR4_100G:\r\ncase FW_PORT_TYPE_CR4_QSFP:\r\nSET_LMM(FIBRE);\r\nSET_LMM(100000baseCR4_Full);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nFW_CAPS_TO_LMM(ANEG, Autoneg);\r\nFW_CAPS_TO_LMM(802_3_PAUSE, Pause);\r\nFW_CAPS_TO_LMM(802_3_ASM_DIR, Asym_Pause);\r\n#undef FW_CAPS_TO_LMM\r\n#undef SET_LMM\r\n}\r\nstatic unsigned int lmm_to_fw_caps(const unsigned long *link_mode_mask)\r\n{\r\nunsigned int fw_caps = 0;\r\n#define LMM_TO_FW_CAPS(__lmm_name, __fw_name) \\r\ndo { \\r\nif (test_bit(ETHTOOL_LINK_MODE_ ## __lmm_name ## _BIT, \\r\nlink_mode_mask)) \\r\nfw_caps |= FW_PORT_CAP_ ## __fw_name; \\r\n} while (0)\r\nLMM_TO_FW_CAPS(100baseT_Full, SPEED_100M);\r\nLMM_TO_FW_CAPS(1000baseT_Full, SPEED_1G);\r\nLMM_TO_FW_CAPS(10000baseT_Full, SPEED_10G);\r\nLMM_TO_FW_CAPS(40000baseSR4_Full, SPEED_40G);\r\nLMM_TO_FW_CAPS(25000baseCR_Full, SPEED_25G);\r\nLMM_TO_FW_CAPS(100000baseCR4_Full, SPEED_100G);\r\n#undef LMM_TO_FW_CAPS\r\nreturn fw_caps;\r\n}\r\nstatic int get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *link_ksettings)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nstruct ethtool_link_settings *base = &link_ksettings->base;\r\nethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\r\nethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\r\nethtool_link_ksettings_zero_link_mode(link_ksettings, lp_advertising);\r\nbase->port = from_fw_port_mod_type(pi->port_type, pi->mod_type);\r\nif (pi->mdio_addr >= 0) {\r\nbase->phy_address = pi->mdio_addr;\r\nbase->mdio_support = (pi->port_type == FW_PORT_TYPE_BT_SGMII\r\n? ETH_MDIO_SUPPORTS_C22\r\n: ETH_MDIO_SUPPORTS_C45);\r\n} else {\r\nbase->phy_address = 255;\r\nbase->mdio_support = 0;\r\n}\r\nfw_caps_to_lmm(pi->port_type, pi->link_cfg.supported,\r\nlink_ksettings->link_modes.supported);\r\nfw_caps_to_lmm(pi->port_type, pi->link_cfg.advertising,\r\nlink_ksettings->link_modes.advertising);\r\nfw_caps_to_lmm(pi->port_type, pi->link_cfg.lp_advertising,\r\nlink_ksettings->link_modes.lp_advertising);\r\nif (netif_carrier_ok(dev)) {\r\nbase->speed = pi->link_cfg.speed;\r\nbase->duplex = DUPLEX_FULL;\r\n} else {\r\nbase->speed = SPEED_UNKNOWN;\r\nbase->duplex = DUPLEX_UNKNOWN;\r\n}\r\nbase->autoneg = pi->link_cfg.autoneg;\r\nif (pi->link_cfg.supported & FW_PORT_CAP_ANEG)\r\nethtool_link_ksettings_add_link_mode(link_ksettings,\r\nsupported, Autoneg);\r\nif (pi->link_cfg.autoneg)\r\nethtool_link_ksettings_add_link_mode(link_ksettings,\r\nadvertising, Autoneg);\r\nreturn 0;\r\n}\r\nstatic int set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings\r\n*link_ksettings)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct link_config *lc = &pi->link_cfg;\r\nconst struct ethtool_link_settings *base = &link_ksettings->base;\r\nstruct link_config old_lc;\r\nunsigned int fw_caps;\r\nint ret = 0;\r\nif (base->duplex != DUPLEX_FULL)\r\nreturn -EINVAL;\r\nif (!(lc->supported & FW_PORT_CAP_ANEG)) {\r\nif (base->autoneg == AUTONEG_DISABLE &&\r\n(lc->supported & speed_to_fw_caps(base->speed)))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nold_lc = *lc;\r\nif (base->autoneg == AUTONEG_DISABLE) {\r\nfw_caps = speed_to_fw_caps(base->speed);\r\nif (!(lc->supported & fw_caps))\r\nreturn -EINVAL;\r\nlc->requested_speed = fw_caps;\r\nlc->advertising = 0;\r\n} else {\r\nfw_caps =\r\nlmm_to_fw_caps(link_ksettings->link_modes.advertising);\r\nif (!(lc->supported & fw_caps))\r\nreturn -EINVAL;\r\nlc->requested_speed = 0;\r\nlc->advertising = fw_caps | FW_PORT_CAP_ANEG;\r\n}\r\nlc->autoneg = base->autoneg;\r\nret = t4_link_l1cfg(pi->adapter, pi->adapter->mbox, pi->tx_chan, lc);\r\nif (ret)\r\n*lc = old_lc;\r\nreturn ret;\r\n}\r\nstatic void get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *epause)\r\n{\r\nstruct port_info *p = netdev_priv(dev);\r\nepause->autoneg = (p->link_cfg.requested_fc & PAUSE_AUTONEG) != 0;\r\nepause->rx_pause = (p->link_cfg.fc & PAUSE_RX) != 0;\r\nepause->tx_pause = (p->link_cfg.fc & PAUSE_TX) != 0;\r\n}\r\nstatic int set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *epause)\r\n{\r\nstruct port_info *p = netdev_priv(dev);\r\nstruct link_config *lc = &p->link_cfg;\r\nif (epause->autoneg == AUTONEG_DISABLE)\r\nlc->requested_fc = 0;\r\nelse if (lc->supported & FW_PORT_CAP_ANEG)\r\nlc->requested_fc = PAUSE_AUTONEG;\r\nelse\r\nreturn -EINVAL;\r\nif (epause->rx_pause)\r\nlc->requested_fc |= PAUSE_RX;\r\nif (epause->tx_pause)\r\nlc->requested_fc |= PAUSE_TX;\r\nif (netif_running(dev))\r\nreturn t4_link_l1cfg(p->adapter, p->adapter->mbox, p->tx_chan,\r\nlc);\r\nreturn 0;\r\n}\r\nstatic void get_sge_param(struct net_device *dev, struct ethtool_ringparam *e)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nconst struct sge *s = &pi->adapter->sge;\r\ne->rx_max_pending = MAX_RX_BUFFERS;\r\ne->rx_mini_max_pending = MAX_RSPQ_ENTRIES;\r\ne->rx_jumbo_max_pending = 0;\r\ne->tx_max_pending = MAX_TXQ_ENTRIES;\r\ne->rx_pending = s->ethrxq[pi->first_qset].fl.size - 8;\r\ne->rx_mini_pending = s->ethrxq[pi->first_qset].rspq.size;\r\ne->rx_jumbo_pending = 0;\r\ne->tx_pending = s->ethtxq[pi->first_qset].q.size;\r\n}\r\nstatic int set_sge_param(struct net_device *dev, struct ethtool_ringparam *e)\r\n{\r\nint i;\r\nconst struct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nstruct sge *s = &adapter->sge;\r\nif (e->rx_pending > MAX_RX_BUFFERS || e->rx_jumbo_pending ||\r\ne->tx_pending > MAX_TXQ_ENTRIES ||\r\ne->rx_mini_pending > MAX_RSPQ_ENTRIES ||\r\ne->rx_mini_pending < MIN_RSPQ_ENTRIES ||\r\ne->rx_pending < MIN_FL_ENTRIES || e->tx_pending < MIN_TXQ_ENTRIES)\r\nreturn -EINVAL;\r\nif (adapter->flags & FULL_INIT_DONE)\r\nreturn -EBUSY;\r\nfor (i = 0; i < pi->nqsets; ++i) {\r\ns->ethtxq[pi->first_qset + i].q.size = e->tx_pending;\r\ns->ethrxq[pi->first_qset + i].fl.size = e->rx_pending + 8;\r\ns->ethrxq[pi->first_qset + i].rspq.size = e->rx_mini_pending;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_rx_intr_params(struct net_device *dev,\r\nunsigned int us, unsigned int cnt)\r\n{\r\nint i, err;\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adap = pi->adapter;\r\nstruct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];\r\nfor (i = 0; i < pi->nqsets; i++, q++) {\r\nerr = cxgb4_set_rspq_intr_params(&q->rspq, us, cnt);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_adaptive_rx_setting(struct net_device *dev, int adaptive_rx)\r\n{\r\nint i;\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adap = pi->adapter;\r\nstruct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];\r\nfor (i = 0; i < pi->nqsets; i++, q++)\r\nq->rspq.adaptive_rx = adaptive_rx;\r\nreturn 0;\r\n}\r\nstatic int get_adaptive_rx_setting(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adap = pi->adapter;\r\nstruct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];\r\nreturn q->rspq.adaptive_rx;\r\n}\r\nstatic int set_coalesce(struct net_device *dev, struct ethtool_coalesce *c)\r\n{\r\nset_adaptive_rx_setting(dev, c->use_adaptive_rx_coalesce);\r\nreturn set_rx_intr_params(dev, c->rx_coalesce_usecs,\r\nc->rx_max_coalesced_frames);\r\n}\r\nstatic int get_coalesce(struct net_device *dev, struct ethtool_coalesce *c)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nconst struct adapter *adap = pi->adapter;\r\nconst struct sge_rspq *rq = &adap->sge.ethrxq[pi->first_qset].rspq;\r\nc->rx_coalesce_usecs = qtimer_val(adap, rq);\r\nc->rx_max_coalesced_frames = (rq->intr_params & QINTR_CNT_EN_F) ?\r\nadap->sge.counter_val[rq->pktcnt_idx] : 0;\r\nc->use_adaptive_rx_coalesce = get_adaptive_rx_setting(dev);\r\nreturn 0;\r\n}\r\nstatic int eeprom_ptov(unsigned int phys_addr, unsigned int fn, unsigned int sz)\r\n{\r\nfn *= sz;\r\nif (phys_addr < 1024)\r\nreturn phys_addr + (31 << 10);\r\nif (phys_addr < 1024 + fn)\r\nreturn 31744 - fn + phys_addr - 1024;\r\nif (phys_addr < EEPROMSIZE)\r\nreturn phys_addr - 1024 - fn;\r\nreturn -EINVAL;\r\n}\r\nstatic int eeprom_rd_phys(struct adapter *adap, unsigned int phys_addr, u32 *v)\r\n{\r\nint vaddr = eeprom_ptov(phys_addr, adap->pf, EEPROMPFSIZE);\r\nif (vaddr >= 0)\r\nvaddr = pci_read_vpd(adap->pdev, vaddr, sizeof(u32), v);\r\nreturn vaddr < 0 ? vaddr : 0;\r\n}\r\nstatic int eeprom_wr_phys(struct adapter *adap, unsigned int phys_addr, u32 v)\r\n{\r\nint vaddr = eeprom_ptov(phys_addr, adap->pf, EEPROMPFSIZE);\r\nif (vaddr >= 0)\r\nvaddr = pci_write_vpd(adap->pdev, vaddr, sizeof(u32), &v);\r\nreturn vaddr < 0 ? vaddr : 0;\r\n}\r\nstatic int get_eeprom(struct net_device *dev, struct ethtool_eeprom *e,\r\nu8 *data)\r\n{\r\nint i, err = 0;\r\nstruct adapter *adapter = netdev2adap(dev);\r\nu8 *buf = t4_alloc_mem(EEPROMSIZE);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ne->magic = EEPROM_MAGIC;\r\nfor (i = e->offset & ~3; !err && i < e->offset + e->len; i += 4)\r\nerr = eeprom_rd_phys(adapter, i, (u32 *)&buf[i]);\r\nif (!err)\r\nmemcpy(data, buf + e->offset, e->len);\r\nt4_free_mem(buf);\r\nreturn err;\r\n}\r\nstatic int set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\r\nu8 *data)\r\n{\r\nu8 *buf;\r\nint err = 0;\r\nu32 aligned_offset, aligned_len, *p;\r\nstruct adapter *adapter = netdev2adap(dev);\r\nif (eeprom->magic != EEPROM_MAGIC)\r\nreturn -EINVAL;\r\naligned_offset = eeprom->offset & ~3;\r\naligned_len = (eeprom->len + (eeprom->offset & 3) + 3) & ~3;\r\nif (adapter->pf > 0) {\r\nu32 start = 1024 + adapter->pf * EEPROMPFSIZE;\r\nif (aligned_offset < start ||\r\naligned_offset + aligned_len > start + EEPROMPFSIZE)\r\nreturn -EPERM;\r\n}\r\nif (aligned_offset != eeprom->offset || aligned_len != eeprom->len) {\r\nbuf = t4_alloc_mem(aligned_len);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nerr = eeprom_rd_phys(adapter, aligned_offset, (u32 *)buf);\r\nif (!err && aligned_len > 4)\r\nerr = eeprom_rd_phys(adapter,\r\naligned_offset + aligned_len - 4,\r\n(u32 *)&buf[aligned_len - 4]);\r\nif (err)\r\ngoto out;\r\nmemcpy(buf + (eeprom->offset & 3), data, eeprom->len);\r\n} else {\r\nbuf = data;\r\n}\r\nerr = t4_seeprom_wp(adapter, false);\r\nif (err)\r\ngoto out;\r\nfor (p = (u32 *)buf; !err && aligned_len; aligned_len -= 4, p++) {\r\nerr = eeprom_wr_phys(adapter, aligned_offset, *p);\r\naligned_offset += 4;\r\n}\r\nif (!err)\r\nerr = t4_seeprom_wp(adapter, true);\r\nout:\r\nif (buf != data)\r\nt4_free_mem(buf);\r\nreturn err;\r\n}\r\nstatic int set_flash(struct net_device *netdev, struct ethtool_flash *ef)\r\n{\r\nint ret;\r\nconst struct firmware *fw;\r\nstruct adapter *adap = netdev2adap(netdev);\r\nunsigned int mbox = PCIE_FW_MASTER_M + 1;\r\nu32 pcie_fw;\r\nunsigned int master;\r\nu8 master_vld = 0;\r\npcie_fw = t4_read_reg(adap, PCIE_FW_A);\r\nmaster = PCIE_FW_MASTER_G(pcie_fw);\r\nif (pcie_fw & PCIE_FW_MASTER_VLD_F)\r\nmaster_vld = 1;\r\nif (master_vld && (master != adap->pf)) {\r\ndev_warn(adap->pdev_dev,\r\n"cxgb4 driver needs to be loaded as MASTER to support FW flash\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nef->data[sizeof(ef->data) - 1] = '\0';\r\nret = request_firmware(&fw, ef->data, adap->pdev_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nif (adap->flags & FULL_INIT_DONE)\r\nmbox = adap->mbox;\r\nret = t4_fw_upgrade(adap, mbox, fw->data, fw->size, 1);\r\nrelease_firmware(fw);\r\nif (!ret)\r\ndev_info(adap->pdev_dev,\r\n"loaded firmware %s, reload cxgb4 driver\n", ef->data);\r\nreturn ret;\r\n}\r\nstatic int get_ts_info(struct net_device *dev, struct ethtool_ts_info *ts_info)\r\n{\r\nts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE;\r\nts_info->so_timestamping |= SOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\nts_info->phc_index = -1;\r\nreturn 0;\r\n}\r\nstatic u32 get_rss_table_size(struct net_device *dev)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nreturn pi->rss_size;\r\n}\r\nstatic int get_rss_table(struct net_device *dev, u32 *p, u8 *key, u8 *hfunc)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nunsigned int n = pi->rss_size;\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nif (!p)\r\nreturn 0;\r\nwhile (n--)\r\np[n] = pi->rss[n];\r\nreturn 0;\r\n}\r\nstatic int set_rss_table(struct net_device *dev, const u32 *p, const u8 *key,\r\nconst u8 hfunc)\r\n{\r\nunsigned int i;\r\nstruct port_info *pi = netdev_priv(dev);\r\nif (key ||\r\n(hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\r\nreturn -EOPNOTSUPP;\r\nif (!p)\r\nreturn 0;\r\nif (pi->adapter->flags & FULL_INIT_DONE) {\r\nfor (i = 0; i < pi->rss_size; i++)\r\npi->rss[i] = p[i];\r\nreturn cxgb4_write_rss(pi, pi->rss);\r\n}\r\nreturn -EPERM;\r\n}\r\nstatic int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\r\nu32 *rules)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nswitch (info->cmd) {\r\ncase ETHTOOL_GRXFH: {\r\nunsigned int v = pi->rss_mode;\r\ninfo->data = 0;\r\nswitch (info->flow_type) {\r\ncase TCP_V4_FLOW:\r\nif (v & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nelse if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nif ((v & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F) &&\r\n(v & FW_RSS_VI_CONFIG_CMD_UDPEN_F))\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nelse if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\ncase IPV4_FLOW:\r\nif (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\nif (v & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nelse if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif ((v & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F) &&\r\n(v & FW_RSS_VI_CONFIG_CMD_UDPEN_F))\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3;\r\nelse if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase SCTP_V6_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase IPV6_FLOW:\r\nif (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)\r\ninfo->data = RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\ncase ETHTOOL_GRXRINGS:\r\ninfo->data = pi->nqsets;\r\nreturn 0;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid cxgb4_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &cxgb_ethtool_ops;\r\n}
