static void do_nothing(void)\r\n{\r\nreturn;\r\n}\r\nstatic void do_overwritten(void)\r\n{\r\npr_info("do_overwritten wasn't overwritten!\n");\r\nreturn;\r\n}\r\nstatic noinline void execute_location(void *dst, bool write)\r\n{\r\nvoid (*func)(void) = dst;\r\npr_info("attempting ok execution at %p\n", do_nothing);\r\ndo_nothing();\r\nif (write == CODE_WRITE) {\r\nmemcpy(dst, do_nothing, EXEC_SIZE);\r\nflush_icache_range((unsigned long)dst,\r\n(unsigned long)dst + EXEC_SIZE);\r\n}\r\npr_info("attempting bad execution at %p\n", func);\r\nfunc();\r\n}\r\nstatic void execute_user_location(void *dst)\r\n{\r\nvoid (*func)(void) = dst;\r\npr_info("attempting ok execution at %p\n", do_nothing);\r\ndo_nothing();\r\nif (copy_to_user((void __user *)dst, do_nothing, EXEC_SIZE))\r\nreturn;\r\nflush_icache_range((unsigned long)dst, (unsigned long)dst + EXEC_SIZE);\r\npr_info("attempting bad execution at %p\n", func);\r\nfunc();\r\n}\r\nvoid lkdtm_WRITE_RO(void)\r\n{\r\nunsigned long *ptr = (unsigned long *)&rodata;\r\npr_info("attempting bad rodata write at %p\n", ptr);\r\n*ptr ^= 0xabcd1234;\r\n}\r\nvoid lkdtm_WRITE_RO_AFTER_INIT(void)\r\n{\r\nunsigned long *ptr = &ro_after_init;\r\nif ((*ptr & 0xAA) != 0xAA) {\r\npr_info("%p was NOT written during init!?\n", ptr);\r\nreturn;\r\n}\r\npr_info("attempting bad ro_after_init write at %p\n", ptr);\r\n*ptr ^= 0xabcd1234;\r\n}\r\nvoid lkdtm_WRITE_KERN(void)\r\n{\r\nsize_t size;\r\nunsigned char *ptr;\r\nsize = (unsigned long)do_overwritten - (unsigned long)do_nothing;\r\nptr = (unsigned char *)do_overwritten;\r\npr_info("attempting bad %zu byte write at %p\n", size, ptr);\r\nmemcpy(ptr, (unsigned char *)do_nothing, size);\r\nflush_icache_range((unsigned long)ptr, (unsigned long)(ptr + size));\r\ndo_overwritten();\r\n}\r\nvoid lkdtm_EXEC_DATA(void)\r\n{\r\nexecute_location(data_area, CODE_WRITE);\r\n}\r\nvoid lkdtm_EXEC_STACK(void)\r\n{\r\nu8 stack_area[EXEC_SIZE];\r\nexecute_location(stack_area, CODE_WRITE);\r\n}\r\nvoid lkdtm_EXEC_KMALLOC(void)\r\n{\r\nu32 *kmalloc_area = kmalloc(EXEC_SIZE, GFP_KERNEL);\r\nexecute_location(kmalloc_area, CODE_WRITE);\r\nkfree(kmalloc_area);\r\n}\r\nvoid lkdtm_EXEC_VMALLOC(void)\r\n{\r\nu32 *vmalloc_area = vmalloc(EXEC_SIZE);\r\nexecute_location(vmalloc_area, CODE_WRITE);\r\nvfree(vmalloc_area);\r\n}\r\nvoid lkdtm_EXEC_RODATA(void)\r\n{\r\nexecute_location(lkdtm_rodata_do_nothing, CODE_AS_IS);\r\n}\r\nvoid lkdtm_EXEC_USERSPACE(void)\r\n{\r\nunsigned long user_addr;\r\nuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_ANONYMOUS | MAP_PRIVATE, 0);\r\nif (user_addr >= TASK_SIZE) {\r\npr_warn("Failed to allocate user memory\n");\r\nreturn;\r\n}\r\nexecute_user_location((void *)user_addr);\r\nvm_munmap(user_addr, PAGE_SIZE);\r\n}\r\nvoid lkdtm_ACCESS_USERSPACE(void)\r\n{\r\nunsigned long user_addr, tmp = 0;\r\nunsigned long *ptr;\r\nuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_ANONYMOUS | MAP_PRIVATE, 0);\r\nif (user_addr >= TASK_SIZE) {\r\npr_warn("Failed to allocate user memory\n");\r\nreturn;\r\n}\r\nif (copy_to_user((void __user *)user_addr, &tmp, sizeof(tmp))) {\r\npr_warn("copy_to_user failed\n");\r\nvm_munmap(user_addr, PAGE_SIZE);\r\nreturn;\r\n}\r\nptr = (unsigned long *)user_addr;\r\npr_info("attempting bad read at %p\n", ptr);\r\ntmp = *ptr;\r\ntmp += 0xc0dec0de;\r\npr_info("attempting bad write at %p\n", ptr);\r\n*ptr = tmp;\r\nvm_munmap(user_addr, PAGE_SIZE);\r\n}\r\nvoid __init lkdtm_perms_init(void)\r\n{\r\nro_after_init |= 0xAA;\r\n}
