static int ebc_c384_wdt_start(struct watchdog_device *wdev)\r\n{\r\nunsigned t = wdev->timeout;\r\nif (t > 255)\r\nt = DIV_ROUND_UP(t, 60);\r\noutb(t, PET_ADDR);\r\nreturn 0;\r\n}\r\nstatic int ebc_c384_wdt_stop(struct watchdog_device *wdev)\r\n{\r\noutb(0x00, PET_ADDR);\r\nreturn 0;\r\n}\r\nstatic int ebc_c384_wdt_set_timeout(struct watchdog_device *wdev, unsigned t)\r\n{\r\nif (t > 255) {\r\nwdev->timeout = roundup(t, 60);\r\noutb(0x00, CFG_ADDR);\r\n} else {\r\nwdev->timeout = t;\r\noutb(0x80, CFG_ADDR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ebc_c384_wdt_probe(struct device *dev, unsigned int id)\r\n{\r\nstruct watchdog_device *wdd;\r\nif (!devm_request_region(dev, BASE_ADDR, ADDR_EXTENT, dev_name(dev))) {\r\ndev_err(dev, "Unable to lock port addresses (0x%X-0x%X)\n",\r\nBASE_ADDR, BASE_ADDR + ADDR_EXTENT);\r\nreturn -EBUSY;\r\n}\r\nwdd = devm_kzalloc(dev, sizeof(*wdd), GFP_KERNEL);\r\nif (!wdd)\r\nreturn -ENOMEM;\r\nwdd->info = &ebc_c384_wdt_info;\r\nwdd->ops = &ebc_c384_wdt_ops;\r\nwdd->timeout = WATCHDOG_TIMEOUT;\r\nwdd->min_timeout = 1;\r\nwdd->max_timeout = WATCHDOG_MAX_TIMEOUT;\r\nwatchdog_set_nowayout(wdd, nowayout);\r\nif (watchdog_init_timeout(wdd, timeout, dev))\r\ndev_warn(dev, "Invalid timeout (%u seconds), using default (%u seconds)\n",\r\ntimeout, WATCHDOG_TIMEOUT);\r\ndev_set_drvdata(dev, wdd);\r\nreturn watchdog_register_device(wdd);\r\n}\r\nstatic int ebc_c384_wdt_remove(struct device *dev, unsigned int id)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nwatchdog_unregister_device(wdd);\r\nreturn 0;\r\n}\r\nstatic int __init ebc_c384_wdt_init(void)\r\n{\r\nif (!dmi_match(DMI_BOARD_NAME, "EBC-C384 SBC"))\r\nreturn -ENODEV;\r\nreturn isa_register_driver(&ebc_c384_wdt_driver, 1);\r\n}\r\nstatic void __exit ebc_c384_wdt_exit(void)\r\n{\r\nisa_unregister_driver(&ebc_c384_wdt_driver);\r\n}
