static struct vxfs_direct *\r\nvxfs_find_entry(struct inode *ip, struct dentry *dp, struct page **ppp)\r\n{\r\nu_long bsize = ip->i_sb->s_blocksize;\r\nconst char *name = dp->d_name.name;\r\nint namelen = dp->d_name.len;\r\nloff_t limit = VXFS_DIRROUND(ip->i_size);\r\nstruct vxfs_direct *de_exit = NULL;\r\nloff_t pos = 0;\r\nstruct vxfs_sb_info *sbi = VXFS_SBI(ip->i_sb);\r\nwhile (pos < limit) {\r\nstruct page *pp;\r\nchar *kaddr;\r\nint pg_ofs = pos & ~PAGE_MASK;\r\npp = vxfs_get_page(ip->i_mapping, pos >> PAGE_SHIFT);\r\nif (IS_ERR(pp))\r\nreturn NULL;\r\nkaddr = (char *)page_address(pp);\r\nwhile (pg_ofs < PAGE_SIZE && pos < limit) {\r\nstruct vxfs_direct *de;\r\nif ((pos & (bsize - 1)) < 4) {\r\nstruct vxfs_dirblk *dbp =\r\n(struct vxfs_dirblk *)\r\n(kaddr + (pos & ~PAGE_MASK));\r\nint overhead = VXFS_DIRBLKOV(sbi, dbp);\r\npos += overhead;\r\npg_ofs += overhead;\r\n}\r\nde = (struct vxfs_direct *)(kaddr + pg_ofs);\r\nif (!de->d_reclen) {\r\npos += bsize - 1;\r\npos &= ~(bsize - 1);\r\nbreak;\r\n}\r\npg_ofs += fs16_to_cpu(sbi, de->d_reclen);\r\npos += fs16_to_cpu(sbi, de->d_reclen);\r\nif (!de->d_ino)\r\ncontinue;\r\nif (namelen != fs16_to_cpu(sbi, de->d_namelen))\r\ncontinue;\r\nif (!memcmp(name, de->d_name, namelen)) {\r\n*ppp = pp;\r\nde_exit = de;\r\nbreak;\r\n}\r\n}\r\nif (!de_exit)\r\nvxfs_put_page(pp);\r\nelse\r\nbreak;\r\n}\r\nreturn de_exit;\r\n}\r\nstatic ino_t\r\nvxfs_inode_by_name(struct inode *dip, struct dentry *dp)\r\n{\r\nstruct vxfs_direct *de;\r\nstruct page *pp;\r\nino_t ino = 0;\r\nde = vxfs_find_entry(dip, dp, &pp);\r\nif (de) {\r\nino = fs32_to_cpu(VXFS_SBI(dip->i_sb), de->d_ino);\r\nkunmap(pp);\r\nput_page(pp);\r\n}\r\nreturn (ino);\r\n}\r\nstatic struct dentry *\r\nvxfs_lookup(struct inode *dip, struct dentry *dp, unsigned int flags)\r\n{\r\nstruct inode *ip = NULL;\r\nino_t ino;\r\nif (dp->d_name.len > VXFS_NAMELEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nino = vxfs_inode_by_name(dip, dp);\r\nif (ino) {\r\nip = vxfs_iget(dip->i_sb, ino);\r\nif (IS_ERR(ip))\r\nreturn ERR_CAST(ip);\r\n}\r\nd_add(dp, ip);\r\nreturn NULL;\r\n}\r\nstatic int\r\nvxfs_readdir(struct file *fp, struct dir_context *ctx)\r\n{\r\nstruct inode *ip = file_inode(fp);\r\nstruct super_block *sbp = ip->i_sb;\r\nu_long bsize = sbp->s_blocksize;\r\nloff_t pos, limit;\r\nstruct vxfs_sb_info *sbi = VXFS_SBI(sbp);\r\nif (ctx->pos == 0) {\r\nif (!dir_emit_dot(fp, ctx))\r\ngoto out;\r\nctx->pos++;\r\n}\r\nif (ctx->pos == 1) {\r\nif (!dir_emit(ctx, "..", 2, VXFS_INO(ip)->vii_dotdot, DT_DIR))\r\ngoto out;\r\nctx->pos++;\r\n}\r\nlimit = VXFS_DIRROUND(ip->i_size);\r\nif (ctx->pos > limit)\r\ngoto out;\r\npos = ctx->pos & ~3L;\r\nwhile (pos < limit) {\r\nstruct page *pp;\r\nchar *kaddr;\r\nint pg_ofs = pos & ~PAGE_MASK;\r\nint rc = 0;\r\npp = vxfs_get_page(ip->i_mapping, pos >> PAGE_SHIFT);\r\nif (IS_ERR(pp))\r\nreturn -ENOMEM;\r\nkaddr = (char *)page_address(pp);\r\nwhile (pg_ofs < PAGE_SIZE && pos < limit) {\r\nstruct vxfs_direct *de;\r\nif ((pos & (bsize - 1)) < 4) {\r\nstruct vxfs_dirblk *dbp =\r\n(struct vxfs_dirblk *)\r\n(kaddr + (pos & ~PAGE_MASK));\r\nint overhead = VXFS_DIRBLKOV(sbi, dbp);\r\npos += overhead;\r\npg_ofs += overhead;\r\n}\r\nde = (struct vxfs_direct *)(kaddr + pg_ofs);\r\nif (!de->d_reclen) {\r\npos += bsize - 1;\r\npos &= ~(bsize - 1);\r\nbreak;\r\n}\r\npg_ofs += fs16_to_cpu(sbi, de->d_reclen);\r\npos += fs16_to_cpu(sbi, de->d_reclen);\r\nif (!de->d_ino)\r\ncontinue;\r\nrc = dir_emit(ctx, de->d_name,\r\nfs16_to_cpu(sbi, de->d_namelen),\r\nfs32_to_cpu(sbi, de->d_ino),\r\nDT_UNKNOWN);\r\nif (!rc) {\r\npos -= fs16_to_cpu(sbi, de->d_reclen);\r\nbreak;\r\n}\r\n}\r\nvxfs_put_page(pp);\r\nif (!rc)\r\nbreak;\r\n}\r\nctx->pos = pos | 2;\r\nout:\r\nreturn 0;\r\n}
