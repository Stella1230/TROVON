static inline int scpi_to_linux_errno(int errno)\r\n{\r\nif (errno >= SCPI_SUCCESS && errno < SCPI_ERR_MAX)\r\nreturn scpi_linux_errmap[errno];\r\nreturn -EIO;\r\n}\r\nstatic void scpi_process_cmd(struct scpi_chan *ch, u32 cmd)\r\n{\r\nunsigned long flags;\r\nstruct scpi_xfer *t, *match = NULL;\r\nspin_lock_irqsave(&ch->rx_lock, flags);\r\nif (list_empty(&ch->rx_pending)) {\r\nspin_unlock_irqrestore(&ch->rx_lock, flags);\r\nreturn;\r\n}\r\nlist_for_each_entry(t, &ch->rx_pending, node)\r\nif (CMD_XTRACT_UNIQ(t->cmd) == CMD_XTRACT_UNIQ(cmd)) {\r\nlist_del(&t->node);\r\nmatch = t;\r\nbreak;\r\n}\r\nif (match && !completion_done(&match->done)) {\r\nstruct scpi_shared_mem *mem = ch->rx_payload;\r\nunsigned int len = min(match->rx_len, CMD_SIZE(cmd));\r\nmatch->status = le32_to_cpu(mem->status);\r\nmemcpy_fromio(match->rx_buf, mem->payload, len);\r\nif (match->rx_len > len)\r\nmemset(match->rx_buf + len, 0, match->rx_len - len);\r\ncomplete(&match->done);\r\n}\r\nspin_unlock_irqrestore(&ch->rx_lock, flags);\r\n}\r\nstatic void scpi_handle_remote_msg(struct mbox_client *c, void *msg)\r\n{\r\nstruct scpi_chan *ch = container_of(c, struct scpi_chan, cl);\r\nstruct scpi_shared_mem *mem = ch->rx_payload;\r\nu32 cmd = le32_to_cpu(mem->command);\r\nscpi_process_cmd(ch, cmd);\r\n}\r\nstatic void scpi_tx_prepare(struct mbox_client *c, void *msg)\r\n{\r\nunsigned long flags;\r\nstruct scpi_xfer *t = msg;\r\nstruct scpi_chan *ch = container_of(c, struct scpi_chan, cl);\r\nstruct scpi_shared_mem *mem = (struct scpi_shared_mem *)ch->tx_payload;\r\nif (t->tx_buf)\r\nmemcpy_toio(mem->payload, t->tx_buf, t->tx_len);\r\nif (t->rx_buf) {\r\nif (!(++ch->token))\r\n++ch->token;\r\nADD_SCPI_TOKEN(t->cmd, ch->token);\r\nspin_lock_irqsave(&ch->rx_lock, flags);\r\nlist_add_tail(&t->node, &ch->rx_pending);\r\nspin_unlock_irqrestore(&ch->rx_lock, flags);\r\n}\r\nmem->command = cpu_to_le32(t->cmd);\r\n}\r\nstatic struct scpi_xfer *get_scpi_xfer(struct scpi_chan *ch)\r\n{\r\nstruct scpi_xfer *t;\r\nmutex_lock(&ch->xfers_lock);\r\nif (list_empty(&ch->xfers_list)) {\r\nmutex_unlock(&ch->xfers_lock);\r\nreturn NULL;\r\n}\r\nt = list_first_entry(&ch->xfers_list, struct scpi_xfer, node);\r\nlist_del(&t->node);\r\nmutex_unlock(&ch->xfers_lock);\r\nreturn t;\r\n}\r\nstatic void put_scpi_xfer(struct scpi_xfer *t, struct scpi_chan *ch)\r\n{\r\nmutex_lock(&ch->xfers_lock);\r\nlist_add_tail(&t->node, &ch->xfers_list);\r\nmutex_unlock(&ch->xfers_lock);\r\n}\r\nstatic int scpi_send_message(u8 cmd, void *tx_buf, unsigned int tx_len,\r\nvoid *rx_buf, unsigned int rx_len)\r\n{\r\nint ret;\r\nu8 chan;\r\nstruct scpi_xfer *msg;\r\nstruct scpi_chan *scpi_chan;\r\nchan = atomic_inc_return(&scpi_info->next_chan) % scpi_info->num_chans;\r\nscpi_chan = scpi_info->channels + chan;\r\nmsg = get_scpi_xfer(scpi_chan);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->slot = BIT(SCPI_SLOT);\r\nmsg->cmd = PACK_SCPI_CMD(cmd, tx_len);\r\nmsg->tx_buf = tx_buf;\r\nmsg->tx_len = tx_len;\r\nmsg->rx_buf = rx_buf;\r\nmsg->rx_len = rx_len;\r\ninit_completion(&msg->done);\r\nret = mbox_send_message(scpi_chan->chan, msg);\r\nif (ret < 0 || !rx_buf)\r\ngoto out;\r\nif (!wait_for_completion_timeout(&msg->done, MAX_RX_TIMEOUT))\r\nret = -ETIMEDOUT;\r\nelse\r\nret = msg->status;\r\nout:\r\nif (ret < 0 && rx_buf)\r\nscpi_process_cmd(scpi_chan, msg->cmd);\r\nput_scpi_xfer(msg, scpi_chan);\r\nreturn ret > 0 ? scpi_to_linux_errno(ret) : ret;\r\n}\r\nstatic u32 scpi_get_version(void)\r\n{\r\nreturn scpi_info->protocol_version;\r\n}\r\nstatic int\r\nscpi_clk_get_range(u16 clk_id, unsigned long *min, unsigned long *max)\r\n{\r\nint ret;\r\nstruct clk_get_info clk;\r\n__le16 le_clk_id = cpu_to_le16(clk_id);\r\nret = scpi_send_message(SCPI_CMD_GET_CLOCK_INFO, &le_clk_id,\r\nsizeof(le_clk_id), &clk, sizeof(clk));\r\nif (!ret) {\r\n*min = le32_to_cpu(clk.min_rate);\r\n*max = le32_to_cpu(clk.max_rate);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned long scpi_clk_get_val(u16 clk_id)\r\n{\r\nint ret;\r\nstruct clk_get_value clk;\r\n__le16 le_clk_id = cpu_to_le16(clk_id);\r\nret = scpi_send_message(SCPI_CMD_GET_CLOCK_VALUE, &le_clk_id,\r\nsizeof(le_clk_id), &clk, sizeof(clk));\r\nreturn ret ? ret : le32_to_cpu(clk.rate);\r\n}\r\nstatic int scpi_clk_set_val(u16 clk_id, unsigned long rate)\r\n{\r\nint stat;\r\nstruct clk_set_value clk = {\r\n.id = cpu_to_le16(clk_id),\r\n.rate = cpu_to_le32(rate)\r\n};\r\nreturn scpi_send_message(SCPI_CMD_SET_CLOCK_VALUE, &clk, sizeof(clk),\r\n&stat, sizeof(stat));\r\n}\r\nstatic int scpi_dvfs_get_idx(u8 domain)\r\n{\r\nint ret;\r\nu8 dvfs_idx;\r\nret = scpi_send_message(SCPI_CMD_GET_DVFS, &domain, sizeof(domain),\r\n&dvfs_idx, sizeof(dvfs_idx));\r\nreturn ret ? ret : dvfs_idx;\r\n}\r\nstatic int scpi_dvfs_set_idx(u8 domain, u8 index)\r\n{\r\nint stat;\r\nstruct dvfs_set dvfs = {domain, index};\r\nreturn scpi_send_message(SCPI_CMD_SET_DVFS, &dvfs, sizeof(dvfs),\r\n&stat, sizeof(stat));\r\n}\r\nstatic int opp_cmp_func(const void *opp1, const void *opp2)\r\n{\r\nconst struct scpi_opp *t1 = opp1, *t2 = opp2;\r\nreturn t1->freq - t2->freq;\r\n}\r\nstatic struct scpi_dvfs_info *scpi_dvfs_get_info(u8 domain)\r\n{\r\nstruct scpi_dvfs_info *info;\r\nstruct scpi_opp *opp;\r\nstruct dvfs_info buf;\r\nint ret, i;\r\nif (domain >= MAX_DVFS_DOMAINS)\r\nreturn ERR_PTR(-EINVAL);\r\nif (scpi_info->dvfs[domain])\r\nreturn scpi_info->dvfs[domain];\r\nret = scpi_send_message(SCPI_CMD_GET_DVFS_INFO, &domain, sizeof(domain),\r\n&buf, sizeof(buf));\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\ninfo->count = DVFS_OPP_COUNT(buf.header);\r\ninfo->latency = DVFS_LATENCY(buf.header) * 1000;\r\ninfo->opps = kcalloc(info->count, sizeof(*opp), GFP_KERNEL);\r\nif (!info->opps) {\r\nkfree(info);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfor (i = 0, opp = info->opps; i < info->count; i++, opp++) {\r\nopp->freq = le32_to_cpu(buf.opps[i].freq);\r\nopp->m_volt = le32_to_cpu(buf.opps[i].m_volt);\r\n}\r\nsort(info->opps, info->count, sizeof(*opp), opp_cmp_func, NULL);\r\nscpi_info->dvfs[domain] = info;\r\nreturn info;\r\n}\r\nstatic int scpi_sensor_get_capability(u16 *sensors)\r\n{\r\nstruct sensor_capabilities cap_buf;\r\nint ret;\r\nret = scpi_send_message(SCPI_CMD_SENSOR_CAPABILITIES, NULL, 0, &cap_buf,\r\nsizeof(cap_buf));\r\nif (!ret)\r\n*sensors = le16_to_cpu(cap_buf.sensors);\r\nreturn ret;\r\n}\r\nstatic int scpi_sensor_get_info(u16 sensor_id, struct scpi_sensor_info *info)\r\n{\r\n__le16 id = cpu_to_le16(sensor_id);\r\nstruct _scpi_sensor_info _info;\r\nint ret;\r\nret = scpi_send_message(SCPI_CMD_SENSOR_INFO, &id, sizeof(id),\r\n&_info, sizeof(_info));\r\nif (!ret) {\r\nmemcpy(info, &_info, sizeof(*info));\r\ninfo->sensor_id = le16_to_cpu(_info.sensor_id);\r\n}\r\nreturn ret;\r\n}\r\nstatic int scpi_sensor_get_value(u16 sensor, u64 *val)\r\n{\r\n__le16 id = cpu_to_le16(sensor);\r\nstruct sensor_value buf;\r\nint ret;\r\nret = scpi_send_message(SCPI_CMD_SENSOR_VALUE, &id, sizeof(id),\r\n&buf, sizeof(buf));\r\nif (!ret)\r\n*val = (u64)le32_to_cpu(buf.hi_val) << 32 |\r\nle32_to_cpu(buf.lo_val);\r\nreturn ret;\r\n}\r\nstatic int scpi_device_get_power_state(u16 dev_id)\r\n{\r\nint ret;\r\nu8 pstate;\r\n__le16 id = cpu_to_le16(dev_id);\r\nret = scpi_send_message(SCPI_CMD_GET_DEVICE_PWR_STATE, &id,\r\nsizeof(id), &pstate, sizeof(pstate));\r\nreturn ret ? ret : pstate;\r\n}\r\nstatic int scpi_device_set_power_state(u16 dev_id, u8 pstate)\r\n{\r\nint stat;\r\nstruct dev_pstate_set dev_set = {\r\n.dev_id = cpu_to_le16(dev_id),\r\n.pstate = pstate,\r\n};\r\nreturn scpi_send_message(SCPI_CMD_SET_DEVICE_PWR_STATE, &dev_set,\r\nsizeof(dev_set), &stat, sizeof(stat));\r\n}\r\nstruct scpi_ops *get_scpi_ops(void)\r\n{\r\nreturn scpi_info ? scpi_info->scpi_ops : NULL;\r\n}\r\nstatic int scpi_init_versions(struct scpi_drvinfo *info)\r\n{\r\nint ret;\r\nstruct scp_capabilities caps;\r\nret = scpi_send_message(SCPI_CMD_SCPI_CAPABILITIES, NULL, 0,\r\n&caps, sizeof(caps));\r\nif (!ret) {\r\ninfo->protocol_version = le32_to_cpu(caps.protocol_version);\r\ninfo->firmware_version = le32_to_cpu(caps.platform_version);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t protocol_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scpi_drvinfo *scpi_info = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d.%d\n",\r\nPROTOCOL_REV_MAJOR(scpi_info->protocol_version),\r\nPROTOCOL_REV_MINOR(scpi_info->protocol_version));\r\n}\r\nstatic ssize_t firmware_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scpi_drvinfo *scpi_info = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d.%d.%d\n",\r\nFW_REV_MAJOR(scpi_info->firmware_version),\r\nFW_REV_MINOR(scpi_info->firmware_version),\r\nFW_REV_PATCH(scpi_info->firmware_version));\r\n}\r\nstatic void\r\nscpi_free_channels(struct device *dev, struct scpi_chan *pchan, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count && pchan->chan; i++, pchan++) {\r\nmbox_free_channel(pchan->chan);\r\ndevm_kfree(dev, pchan->xfers);\r\ndevm_iounmap(dev, pchan->rx_payload);\r\n}\r\n}\r\nstatic int scpi_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct device *dev = &pdev->dev;\r\nstruct scpi_drvinfo *info = platform_get_drvdata(pdev);\r\nscpi_info = NULL;\r\nof_platform_depopulate(dev);\r\nsysfs_remove_groups(&dev->kobj, versions_groups);\r\nscpi_free_channels(dev, info->channels, info->num_chans);\r\nplatform_set_drvdata(pdev, NULL);\r\nfor (i = 0; i < MAX_DVFS_DOMAINS && info->dvfs[i]; i++) {\r\nkfree(info->dvfs[i]->opps);\r\nkfree(info->dvfs[i]);\r\n}\r\ndevm_kfree(dev, info->channels);\r\ndevm_kfree(dev, info);\r\nreturn 0;\r\n}\r\nstatic int scpi_alloc_xfer_list(struct device *dev, struct scpi_chan *ch)\r\n{\r\nint i;\r\nstruct scpi_xfer *xfers;\r\nxfers = devm_kzalloc(dev, MAX_SCPI_XFERS * sizeof(*xfers), GFP_KERNEL);\r\nif (!xfers)\r\nreturn -ENOMEM;\r\nch->xfers = xfers;\r\nfor (i = 0; i < MAX_SCPI_XFERS; i++, xfers++)\r\nlist_add_tail(&xfers->node, &ch->xfers_list);\r\nreturn 0;\r\n}\r\nstatic int scpi_probe(struct platform_device *pdev)\r\n{\r\nint count, idx, ret;\r\nstruct resource res;\r\nstruct scpi_chan *scpi_chan;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nscpi_info = devm_kzalloc(dev, sizeof(*scpi_info), GFP_KERNEL);\r\nif (!scpi_info)\r\nreturn -ENOMEM;\r\ncount = of_count_phandle_with_args(np, "mboxes", "#mbox-cells");\r\nif (count < 0) {\r\ndev_err(dev, "no mboxes property in '%s'\n", np->full_name);\r\nreturn -ENODEV;\r\n}\r\nscpi_chan = devm_kcalloc(dev, count, sizeof(*scpi_chan), GFP_KERNEL);\r\nif (!scpi_chan)\r\nreturn -ENOMEM;\r\nfor (idx = 0; idx < count; idx++) {\r\nresource_size_t size;\r\nstruct scpi_chan *pchan = scpi_chan + idx;\r\nstruct mbox_client *cl = &pchan->cl;\r\nstruct device_node *shmem = of_parse_phandle(np, "shmem", idx);\r\nret = of_address_to_resource(shmem, 0, &res);\r\nof_node_put(shmem);\r\nif (ret) {\r\ndev_err(dev, "failed to get SCPI payload mem resource\n");\r\ngoto err;\r\n}\r\nsize = resource_size(&res);\r\npchan->rx_payload = devm_ioremap(dev, res.start, size);\r\nif (!pchan->rx_payload) {\r\ndev_err(dev, "failed to ioremap SCPI payload\n");\r\nret = -EADDRNOTAVAIL;\r\ngoto err;\r\n}\r\npchan->tx_payload = pchan->rx_payload + (size >> 1);\r\ncl->dev = dev;\r\ncl->rx_callback = scpi_handle_remote_msg;\r\ncl->tx_prepare = scpi_tx_prepare;\r\ncl->tx_block = true;\r\ncl->tx_tout = 20;\r\ncl->knows_txdone = false;\r\nINIT_LIST_HEAD(&pchan->rx_pending);\r\nINIT_LIST_HEAD(&pchan->xfers_list);\r\nspin_lock_init(&pchan->rx_lock);\r\nmutex_init(&pchan->xfers_lock);\r\nret = scpi_alloc_xfer_list(dev, pchan);\r\nif (!ret) {\r\npchan->chan = mbox_request_channel(cl, idx);\r\nif (!IS_ERR(pchan->chan))\r\ncontinue;\r\nret = PTR_ERR(pchan->chan);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get channel%d err %d\n",\r\nidx, ret);\r\n}\r\nerr:\r\nscpi_free_channels(dev, scpi_chan, idx);\r\nscpi_info = NULL;\r\nreturn ret;\r\n}\r\nscpi_info->channels = scpi_chan;\r\nscpi_info->num_chans = count;\r\nplatform_set_drvdata(pdev, scpi_info);\r\nret = scpi_init_versions(scpi_info);\r\nif (ret) {\r\ndev_err(dev, "incorrect or no SCP firmware found\n");\r\nscpi_remove(pdev);\r\nreturn ret;\r\n}\r\n_dev_info(dev, "SCP Protocol %d.%d Firmware %d.%d.%d version\n",\r\nPROTOCOL_REV_MAJOR(scpi_info->protocol_version),\r\nPROTOCOL_REV_MINOR(scpi_info->protocol_version),\r\nFW_REV_MAJOR(scpi_info->firmware_version),\r\nFW_REV_MINOR(scpi_info->firmware_version),\r\nFW_REV_PATCH(scpi_info->firmware_version));\r\nscpi_info->scpi_ops = &scpi_ops;\r\nret = sysfs_create_groups(&dev->kobj, versions_groups);\r\nif (ret)\r\ndev_err(dev, "unable to create sysfs version group\n");\r\nreturn of_platform_populate(dev->of_node, NULL, NULL, dev);\r\n}
