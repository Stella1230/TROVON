static int _to_tm_wday(u8 lp8788_wday)\r\n{\r\nint i;\r\nif (lp8788_wday == 0)\r\nreturn 0;\r\nfor (i = 0; i < MAX_WDAY_BITS; i++) {\r\nif ((lp8788_wday >> i) == LP8788_WDAY_SET)\r\nbreak;\r\n}\r\nreturn i + 1;\r\n}\r\nstatic inline int _to_lp8788_wday(int tm_wday)\r\n{\r\nreturn LP8788_WDAY_SET << (tm_wday - 1);\r\n}\r\nstatic void lp8788_rtc_unlock(struct lp8788 *lp)\r\n{\r\nlp8788_write_byte(lp, LP8788_RTC_UNLOCK, RTC_UNLOCK);\r\nlp8788_write_byte(lp, LP8788_RTC_UNLOCK, RTC_LATCH);\r\n}\r\nstatic int lp8788_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\r\nstruct lp8788 *lp = rtc->lp;\r\nu8 data[LPTIME_MAX];\r\nint ret;\r\nlp8788_rtc_unlock(lp);\r\nret = lp8788_read_multi_bytes(lp, LP8788_RTC_SEC, data, LPTIME_MAX);\r\nif (ret)\r\nreturn ret;\r\ntm->tm_sec = data[LPTIME_SEC];\r\ntm->tm_min = data[LPTIME_MIN];\r\ntm->tm_hour = data[LPTIME_HOUR];\r\ntm->tm_mday = data[LPTIME_MDAY];\r\ntm->tm_mon = data[LPTIME_MON] - LP8788_MONTH_OFFSET;\r\ntm->tm_year = data[LPTIME_YEAR] + LP8788_BASE_YEAR - 1900;\r\ntm->tm_wday = _to_tm_wday(data[LPTIME_WDAY]);\r\nreturn 0;\r\n}\r\nstatic int lp8788_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\r\nstruct lp8788 *lp = rtc->lp;\r\nu8 data[LPTIME_MAX - 1];\r\nint ret, i, year;\r\nyear = tm->tm_year + 1900 - LP8788_BASE_YEAR;\r\nif (year < 0) {\r\ndev_err(lp->dev, "invalid year: %d\n", year);\r\nreturn -EINVAL;\r\n}\r\ndata[LPTIME_SEC] = tm->tm_sec;\r\ndata[LPTIME_MIN] = tm->tm_min;\r\ndata[LPTIME_HOUR] = tm->tm_hour;\r\ndata[LPTIME_MDAY] = tm->tm_mday;\r\ndata[LPTIME_MON] = tm->tm_mon + LP8788_MONTH_OFFSET;\r\ndata[LPTIME_YEAR] = year;\r\nfor (i = 0; i < ARRAY_SIZE(data); i++) {\r\nret = lp8788_write_byte(lp, LP8788_RTC_SEC + i, data[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8788_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\r\nstruct lp8788 *lp = rtc->lp;\r\nstruct rtc_time *tm = &alarm->time;\r\nu8 addr, data[LPTIME_MAX];\r\nint ret;\r\naddr = addr_alarm_sec[rtc->alarm];\r\nret = lp8788_read_multi_bytes(lp, addr, data, LPTIME_MAX);\r\nif (ret)\r\nreturn ret;\r\ntm->tm_sec = data[LPTIME_SEC];\r\ntm->tm_min = data[LPTIME_MIN];\r\ntm->tm_hour = data[LPTIME_HOUR];\r\ntm->tm_mday = data[LPTIME_MDAY];\r\ntm->tm_mon = data[LPTIME_MON] - LP8788_MONTH_OFFSET;\r\ntm->tm_year = data[LPTIME_YEAR] + LP8788_BASE_YEAR - 1900;\r\ntm->tm_wday = _to_tm_wday(data[LPTIME_WDAY]);\r\nalarm->enabled = data[LPTIME_WDAY] & LP8788_ALM_EN_M;\r\nreturn 0;\r\n}\r\nstatic int lp8788_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\r\nstruct lp8788 *lp = rtc->lp;\r\nstruct rtc_time *tm = &alarm->time;\r\nu8 addr, data[LPTIME_MAX];\r\nint ret, i, year;\r\nyear = tm->tm_year + 1900 - LP8788_BASE_YEAR;\r\nif (year < 0) {\r\ndev_err(lp->dev, "invalid year: %d\n", year);\r\nreturn -EINVAL;\r\n}\r\ndata[LPTIME_SEC] = tm->tm_sec;\r\ndata[LPTIME_MIN] = tm->tm_min;\r\ndata[LPTIME_HOUR] = tm->tm_hour;\r\ndata[LPTIME_MDAY] = tm->tm_mday;\r\ndata[LPTIME_MON] = tm->tm_mon + LP8788_MONTH_OFFSET;\r\ndata[LPTIME_YEAR] = year;\r\ndata[LPTIME_WDAY] = _to_lp8788_wday(tm->tm_wday);\r\nfor (i = 0; i < ARRAY_SIZE(data); i++) {\r\naddr = addr_alarm_sec[rtc->alarm] + i;\r\nret = lp8788_write_byte(lp, addr, data[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nalarm->enabled = 1;\r\naddr = addr_alarm_en[rtc->alarm];\r\nreturn lp8788_update_bits(lp, addr, LP8788_ALM_EN_M,\r\nalarm->enabled << LP8788_ALM_EN_S);\r\n}\r\nstatic int lp8788_alarm_irq_enable(struct device *dev, unsigned int enable)\r\n{\r\nstruct lp8788_rtc *rtc = dev_get_drvdata(dev);\r\nstruct lp8788 *lp = rtc->lp;\r\nu8 mask, shift;\r\nif (!rtc->irq)\r\nreturn -EIO;\r\nmask = mask_alarm_en[rtc->alarm];\r\nshift = shift_alarm_en[rtc->alarm];\r\nreturn lp8788_update_bits(lp, LP8788_INTEN_3, mask, enable << shift);\r\n}\r\nstatic irqreturn_t lp8788_alarm_irq_handler(int irq, void *ptr)\r\n{\r\nstruct lp8788_rtc *rtc = ptr;\r\nrtc_update_irq(rtc->rdev, 1, ALARM_IRQ_FLAG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lp8788_alarm_irq_register(struct platform_device *pdev,\r\nstruct lp8788_rtc *rtc)\r\n{\r\nstruct resource *r;\r\nstruct lp8788 *lp = rtc->lp;\r\nstruct irq_domain *irqdm = lp->irqdm;\r\nint irq;\r\nrtc->irq = 0;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, LP8788_ALM_IRQ);\r\nif (!r)\r\nreturn 0;\r\nif (rtc->alarm == LP8788_ALARM_1)\r\nirq = r->start;\r\nelse\r\nirq = r->end;\r\nrtc->irq = irq_create_mapping(irqdm, irq);\r\nreturn devm_request_threaded_irq(&pdev->dev, rtc->irq, NULL,\r\nlp8788_alarm_irq_handler,\r\n0, LP8788_ALM_IRQ, rtc);\r\n}\r\nstatic int lp8788_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\r\nstruct lp8788_rtc *rtc;\r\nstruct device *dev = &pdev->dev;\r\nrtc = devm_kzalloc(dev, sizeof(struct lp8788_rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nrtc->lp = lp;\r\nrtc->alarm = lp->pdata ? lp->pdata->alarm_sel : DEFAULT_ALARM_SEL;\r\nplatform_set_drvdata(pdev, rtc);\r\ndevice_init_wakeup(dev, 1);\r\nrtc->rdev = devm_rtc_device_register(dev, "lp8788_rtc",\r\n&lp8788_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rdev)) {\r\ndev_err(dev, "can not register rtc device\n");\r\nreturn PTR_ERR(rtc->rdev);\r\n}\r\nif (lp8788_alarm_irq_register(pdev, rtc))\r\ndev_warn(lp->dev, "no rtc irq handler\n");\r\nreturn 0;\r\n}
