static struct nouveau_abi16 *\r\nnouveau_abi16(struct drm_file *file_priv)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nif (!cli->abi16) {\r\nstruct nouveau_abi16 *abi16;\r\ncli->abi16 = abi16 = kzalloc(sizeof(*abi16), GFP_KERNEL);\r\nif (cli->abi16) {\r\nstruct nv_device_v0 args = {\r\n.device = ~0ULL,\r\n};\r\nINIT_LIST_HEAD(&abi16->channels);\r\nif (nvif_device_init(&cli->base.object, 0, NV_DEVICE,\r\n&args, sizeof(args),\r\n&abi16->device) == 0)\r\nreturn cli->abi16;\r\nkfree(cli->abi16);\r\ncli->abi16 = NULL;\r\n}\r\n}\r\nreturn cli->abi16;\r\n}\r\nstruct nouveau_abi16 *\r\nnouveau_abi16_get(struct drm_file *file_priv)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nmutex_lock(&cli->mutex);\r\nif (nouveau_abi16(file_priv))\r\nreturn cli->abi16;\r\nmutex_unlock(&cli->mutex);\r\nreturn NULL;\r\n}\r\nint\r\nnouveau_abi16_put(struct nouveau_abi16 *abi16, int ret)\r\n{\r\nstruct nouveau_cli *cli = (void *)abi16->device.object.client;\r\nmutex_unlock(&cli->mutex);\r\nreturn ret;\r\n}\r\ns32\r\nnouveau_abi16_swclass(struct nouveau_drm *drm)\r\n{\r\nswitch (drm->device.info.family) {\r\ncase NV_DEVICE_INFO_V0_TNT:\r\nreturn NVIF_CLASS_SW_NV04;\r\ncase NV_DEVICE_INFO_V0_CELSIUS:\r\ncase NV_DEVICE_INFO_V0_KELVIN:\r\ncase NV_DEVICE_INFO_V0_RANKINE:\r\ncase NV_DEVICE_INFO_V0_CURIE:\r\nreturn NVIF_CLASS_SW_NV10;\r\ncase NV_DEVICE_INFO_V0_TESLA:\r\nreturn NVIF_CLASS_SW_NV50;\r\ncase NV_DEVICE_INFO_V0_FERMI:\r\ncase NV_DEVICE_INFO_V0_KEPLER:\r\ncase NV_DEVICE_INFO_V0_MAXWELL:\r\ncase NV_DEVICE_INFO_V0_PASCAL:\r\nreturn NVIF_CLASS_SW_GF100;\r\n}\r\nreturn 0x0000;\r\n}\r\nstatic void\r\nnouveau_abi16_ntfy_fini(struct nouveau_abi16_chan *chan,\r\nstruct nouveau_abi16_ntfy *ntfy)\r\n{\r\nnvif_object_fini(&ntfy->object);\r\nnvkm_mm_free(&chan->heap, &ntfy->node);\r\nlist_del(&ntfy->head);\r\nkfree(ntfy);\r\n}\r\nstatic void\r\nnouveau_abi16_chan_fini(struct nouveau_abi16 *abi16,\r\nstruct nouveau_abi16_chan *chan)\r\n{\r\nstruct nouveau_abi16_ntfy *ntfy, *temp;\r\nif (chan->chan && chan->ntfy)\r\nnouveau_channel_idle(chan->chan);\r\nlist_for_each_entry_safe(ntfy, temp, &chan->notifiers, head) {\r\nnouveau_abi16_ntfy_fini(chan, ntfy);\r\n}\r\nif (chan->ntfy) {\r\nnouveau_bo_vma_del(chan->ntfy, &chan->ntfy_vma);\r\nnouveau_bo_unpin(chan->ntfy);\r\ndrm_gem_object_unreference_unlocked(&chan->ntfy->gem);\r\n}\r\nif (chan->heap.block_size)\r\nnvkm_mm_fini(&chan->heap);\r\nif (chan->chan) {\r\nnouveau_channel_idle(chan->chan);\r\nnouveau_channel_del(&chan->chan);\r\n}\r\nlist_del(&chan->head);\r\nkfree(chan);\r\n}\r\nvoid\r\nnouveau_abi16_fini(struct nouveau_abi16 *abi16)\r\n{\r\nstruct nouveau_cli *cli = (void *)abi16->device.object.client;\r\nstruct nouveau_abi16_chan *chan, *temp;\r\nlist_for_each_entry_safe(chan, temp, &abi16->channels, head) {\r\nnouveau_abi16_chan_fini(abi16, chan);\r\n}\r\nnvif_device_fini(&abi16->device);\r\nkfree(cli->abi16);\r\ncli->abi16 = NULL;\r\n}\r\nint\r\nnouveau_abi16_ioctl_getparam(ABI16_IOCTL_ARGS)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_device *device = &drm->device;\r\nstruct nvkm_gr *gr = nvxx_gr(device);\r\nstruct drm_nouveau_getparam *getparam = data;\r\nswitch (getparam->param) {\r\ncase NOUVEAU_GETPARAM_CHIPSET_ID:\r\ngetparam->value = device->info.chipset;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PCI_VENDOR:\r\nif (nvxx_device(device)->func->pci)\r\ngetparam->value = dev->pdev->vendor;\r\nelse\r\ngetparam->value = 0;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PCI_DEVICE:\r\nif (nvxx_device(device)->func->pci)\r\ngetparam->value = dev->pdev->device;\r\nelse\r\ngetparam->value = 0;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_BUS_TYPE:\r\nif (!nvxx_device(device)->func->pci)\r\ngetparam->value = 3;\r\nelse\r\nif (drm_pci_device_is_agp(dev))\r\ngetparam->value = 0;\r\nelse\r\nif (!pci_is_pcie(dev->pdev))\r\ngetparam->value = 1;\r\nelse\r\ngetparam->value = 2;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_FB_SIZE:\r\ngetparam->value = drm->gem.vram_available;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_AGP_SIZE:\r\ngetparam->value = drm->gem.gart_available;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_VM_VRAM_BASE:\r\ngetparam->value = 0;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PTIMER_TIME:\r\ngetparam->value = nvif_device_time(device);\r\nbreak;\r\ncase NOUVEAU_GETPARAM_HAS_BO_USAGE:\r\ngetparam->value = 1;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_HAS_PAGEFLIP:\r\ngetparam->value = 1;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_GRAPH_UNITS:\r\ngetparam->value = nvkm_gr_units(gr);\r\nbreak;\r\ndefault:\r\nNV_PRINTK(dbg, cli, "unknown parameter %lld\n", getparam->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_abi16_ioctl_setparam(ABI16_IOCTL_ARGS)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint\r\nnouveau_abi16_ioctl_channel_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_channel_alloc *init = data;\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nvif_device *device;\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (!drm->channel)\r\nreturn nouveau_abi16_put(abi16, -ENODEV);\r\ndevice = &abi16->device;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_KEPLER) {\r\nif (init->fb_ctxdma_handle != ~0)\r\ninit->fb_ctxdma_handle = NVA06F_V0_ENGINE_GR;\r\nelse {\r\ninit->fb_ctxdma_handle = 0;\r\n#define _(A,B) if (init->tt_ctxdma_handle & (A)) init->fb_ctxdma_handle |= (B)\r\n_(0x01, NVA06F_V0_ENGINE_GR);\r\n_(0x02, NVA06F_V0_ENGINE_MSPDEC);\r\n_(0x04, NVA06F_V0_ENGINE_MSPPP);\r\n_(0x08, NVA06F_V0_ENGINE_MSVLD);\r\n_(0x10, NVA06F_V0_ENGINE_CE0);\r\n_(0x20, NVA06F_V0_ENGINE_CE1);\r\n_(0x40, NVA06F_V0_ENGINE_MSENC);\r\n#undef _\r\n}\r\ninit->tt_ctxdma_handle = 0;\r\nif (init->fb_ctxdma_handle == NVA06F_V0_ENGINE_GR)\r\ninit->tt_ctxdma_handle = 1;\r\n}\r\nif (init->fb_ctxdma_handle == ~0 || init->tt_ctxdma_handle == ~0)\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nchan = kzalloc(sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOMEM);\r\nINIT_LIST_HEAD(&chan->notifiers);\r\nlist_add(&chan->head, &abi16->channels);\r\nret = nouveau_channel_new(drm, device, init->fb_ctxdma_handle,\r\ninit->tt_ctxdma_handle, &chan->chan);\r\nif (ret)\r\ngoto done;\r\ninit->channel = chan->chan->chid;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA)\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_VRAM |\r\nNOUVEAU_GEM_DOMAIN_GART;\r\nelse\r\nif (chan->chan->push.buffer->bo.mem.mem_type == TTM_PL_VRAM)\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_VRAM;\r\nelse\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_GART;\r\nif (device->info.family < NV_DEVICE_INFO_V0_CELSIUS) {\r\ninit->subchan[0].handle = 0x00000000;\r\ninit->subchan[0].grclass = 0x0000;\r\ninit->subchan[1].handle = chan->chan->nvsw.handle;\r\ninit->subchan[1].grclass = 0x506e;\r\ninit->nr_subchan = 2;\r\n}\r\nret = nouveau_gem_new(dev, PAGE_SIZE, 0, NOUVEAU_GEM_DOMAIN_GART,\r\n0, 0, &chan->ntfy);\r\nif (ret == 0)\r\nret = nouveau_bo_pin(chan->ntfy, TTM_PL_FLAG_TT, false);\r\nif (ret)\r\ngoto done;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nret = nouveau_bo_vma_add(chan->ntfy, cli->vm,\r\n&chan->ntfy_vma);\r\nif (ret)\r\ngoto done;\r\n}\r\nret = drm_gem_handle_create(file_priv, &chan->ntfy->gem,\r\n&init->notifier_handle);\r\nif (ret)\r\ngoto done;\r\nret = nvkm_mm_init(&chan->heap, 0, PAGE_SIZE, 1);\r\ndone:\r\nif (ret)\r\nnouveau_abi16_chan_fini(abi16, chan);\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nstatic struct nouveau_abi16_chan *\r\nnouveau_abi16_chan(struct nouveau_abi16 *abi16, int channel)\r\n{\r\nstruct nouveau_abi16_chan *chan;\r\nlist_for_each_entry(chan, &abi16->channels, head) {\r\nif (chan->chan->chid == channel)\r\nreturn chan;\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nnouveau_abi16_usif(struct drm_file *file_priv, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nvif_ioctl_v0 v0;\r\n} *args = data;\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nouveau_abi16 *abi16;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nswitch (args->v0.type) {\r\ncase NVIF_IOCTL_V0_NEW:\r\ncase NVIF_IOCTL_V0_MTHD:\r\ncase NVIF_IOCTL_V0_SCLASS:\r\nbreak;\r\ndefault:\r\nreturn -EACCES;\r\n}\r\n} else\r\nreturn ret;\r\nif (!(abi16 = nouveau_abi16(file_priv)))\r\nreturn -ENOMEM;\r\nif (args->v0.token != ~0ULL) {\r\nif (!(chan = nouveau_abi16_chan(abi16, args->v0.token)))\r\nreturn -EINVAL;\r\nargs->v0.object = nvif_handle(&chan->chan->user);\r\nargs->v0.owner = NVIF_IOCTL_V0_OWNER_ANY;\r\nreturn 0;\r\n}\r\nargs->v0.object = nvif_handle(&abi16->device.object);\r\nargs->v0.owner = NVIF_IOCTL_V0_OWNER_ANY;\r\nreturn 0;\r\n}\r\nint\r\nnouveau_abi16_ioctl_channel_free(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_channel_free *req = data;\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\r\nstruct nouveau_abi16_chan *chan;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nchan = nouveau_abi16_chan(abi16, req->channel);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOENT);\r\nnouveau_abi16_chan_fini(abi16, chan);\r\nreturn nouveau_abi16_put(abi16, 0);\r\n}\r\nint\r\nnouveau_abi16_ioctl_grobj_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_grobj_alloc *init = data;\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nouveau_abi16_ntfy *ntfy;\r\nstruct nvif_client *client;\r\nstruct nvif_sclass *sclass;\r\ns32 oclass = 0;\r\nint ret, i;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (init->handle == ~0)\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nclient = abi16->device.object.client;\r\nchan = nouveau_abi16_chan(abi16, init->channel);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOENT);\r\nret = nvif_object_sclass_get(&chan->chan->user, &sclass);\r\nif (ret < 0)\r\nreturn nouveau_abi16_put(abi16, ret);\r\nif ((init->class & 0x00ff) == 0x006e) {\r\nfor (i = 0; !oclass && i < ret; i++) {\r\nswitch (sclass[i].oclass) {\r\ncase NVIF_CLASS_SW_NV04:\r\ncase NVIF_CLASS_SW_NV10:\r\ncase NVIF_CLASS_SW_NV50:\r\ncase NVIF_CLASS_SW_GF100:\r\noclass = sclass[i].oclass;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n} else\r\nif ((init->class & 0x00ff) == 0x00b1) {\r\nfor (i = 0; i < ret; i++) {\r\nif ((sclass[i].oclass & 0x00ff) == 0x00b1) {\r\noclass = sclass[i].oclass;\r\nbreak;\r\n}\r\n}\r\n} else\r\nif ((init->class & 0x00ff) == 0x00b2) {\r\nfor (i = 0; i < ret; i++) {\r\nif ((sclass[i].oclass & 0x00ff) == 0x00b2) {\r\noclass = sclass[i].oclass;\r\nbreak;\r\n}\r\n}\r\n} else\r\nif ((init->class & 0x00ff) == 0x00b3) {\r\nfor (i = 0; i < ret; i++) {\r\nif ((sclass[i].oclass & 0x00ff) == 0x00b3) {\r\noclass = sclass[i].oclass;\r\nbreak;\r\n}\r\n}\r\n} else {\r\noclass = init->class;\r\n}\r\nnvif_object_sclass_put(&sclass);\r\nif (!oclass)\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nntfy = kzalloc(sizeof(*ntfy), GFP_KERNEL);\r\nif (!ntfy)\r\nreturn nouveau_abi16_put(abi16, -ENOMEM);\r\nlist_add(&ntfy->head, &chan->notifiers);\r\nclient->route = NVDRM_OBJECT_ABI16;\r\nret = nvif_object_init(&chan->chan->user, init->handle, oclass,\r\nNULL, 0, &ntfy->object);\r\nclient->route = NVDRM_OBJECT_NVIF;\r\nif (ret)\r\nnouveau_abi16_ntfy_fini(chan, ntfy);\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nint\r\nnouveau_abi16_ioctl_notifierobj_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_notifierobj_alloc *info = data;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nouveau_abi16_ntfy *ntfy;\r\nstruct nvif_device *device = &abi16->device;\r\nstruct nvif_client *client;\r\nstruct nv_dma_v0 args = {};\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (unlikely(device->info.family >= NV_DEVICE_INFO_V0_FERMI))\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nclient = abi16->device.object.client;\r\nchan = nouveau_abi16_chan(abi16, info->channel);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOENT);\r\nntfy = kzalloc(sizeof(*ntfy), GFP_KERNEL);\r\nif (!ntfy)\r\nreturn nouveau_abi16_put(abi16, -ENOMEM);\r\nlist_add(&ntfy->head, &chan->notifiers);\r\nret = nvkm_mm_head(&chan->heap, 0, 1, info->size, info->size, 1,\r\n&ntfy->node);\r\nif (ret)\r\ngoto done;\r\nargs.start = ntfy->node->offset;\r\nargs.limit = ntfy->node->offset + ntfy->node->length - 1;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_VM;\r\nargs.start += chan->ntfy_vma.offset;\r\nargs.limit += chan->ntfy_vma.offset;\r\n} else\r\nif (drm->agp.bridge) {\r\nargs.target = NV_DMA_V0_TARGET_AGP;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start += drm->agp.base + chan->ntfy->bo.offset;\r\nargs.limit += drm->agp.base + chan->ntfy->bo.offset;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start += chan->ntfy->bo.offset;\r\nargs.limit += chan->ntfy->bo.offset;\r\n}\r\nclient->route = NVDRM_OBJECT_ABI16;\r\nclient->super = true;\r\nret = nvif_object_init(&chan->chan->user, info->handle,\r\nNV_DMA_IN_MEMORY, &args, sizeof(args),\r\n&ntfy->object);\r\nclient->super = false;\r\nclient->route = NVDRM_OBJECT_NVIF;\r\nif (ret)\r\ngoto done;\r\ninfo->offset = ntfy->node->offset;\r\ndone:\r\nif (ret)\r\nnouveau_abi16_ntfy_fini(chan, ntfy);\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nint\r\nnouveau_abi16_ioctl_gpuobj_free(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_gpuobj_free *fini = data;\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nouveau_abi16_ntfy *ntfy;\r\nint ret = -ENOENT;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nchan = nouveau_abi16_chan(abi16, fini->channel);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nnouveau_channel_idle(chan->chan);\r\nlist_for_each_entry(ntfy, &chan->notifiers, head) {\r\nif (ntfy->object.handle == fini->handle) {\r\nnouveau_abi16_ntfy_fini(chan, ntfy);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}
