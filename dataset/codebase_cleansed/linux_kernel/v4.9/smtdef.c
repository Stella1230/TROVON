void smt_reset_defaults(struct s_smc *smc, int level)\r\n{\r\nstruct smt_config *smt ;\r\nint i ;\r\nu_long smt_boot_time;\r\nsmt_init_mib(smc,level) ;\r\nsmc->os.smc_version = SMC_VERSION ;\r\nsmt_boot_time = smt_get_time();\r\nfor( i = 0; i < NUMMACS; i++ )\r\nsmc->sm.last_tok_time[i] = smt_boot_time ;\r\nsmt = &smc->s ;\r\nsmt->attach_s = 0 ;\r\nsmt->build_ring_map = 1 ;\r\nsmt->sas = SMT_DAS ;\r\nsmt->numphys = NUMPHYS ;\r\nsmt->pcm_tb_min = DEFAULT_TB_MIN ;\r\nsmt->pcm_tb_max = DEFAULT_TB_MAX ;\r\nsmt->pcm_c_min = DEFAULT_C_MIN ;\r\nsmt->pcm_t_out = DEFAULT_T_OUT ;\r\nsmt->pcm_tl_min = DEFAULT_TL_MIN ;\r\nsmt->pcm_lc_short = DEFAULT_LC_SHORT ;\r\nsmt->pcm_lc_medium = DEFAULT_LC_MEDIUM ;\r\nsmt->pcm_lc_long = DEFAULT_LC_LONG ;\r\nsmt->pcm_lc_extended = DEFAULT_LC_EXTENDED ;\r\nsmt->pcm_t_next_9 = DEFAULT_T_NEXT_9 ;\r\nsmt->pcm_ns_max = DEFAULT_NS_MAX ;\r\nsmt->ecm_i_max = DEFAULT_I_MAX ;\r\nsmt->ecm_in_max = DEFAULT_IN_MAX ;\r\nsmt->ecm_td_min = DEFAULT_TD_MIN ;\r\nsmt->ecm_test_done = DEFAULT_TEST_DONE ;\r\nsmt->ecm_check_poll = DEFAULT_CHECK_POLL ;\r\nsmt->rmt_t_non_op = DEFAULT_T_NON_OP ;\r\nsmt->rmt_t_stuck = DEFAULT_T_STUCK ;\r\nsmt->rmt_t_direct = DEFAULT_T_DIRECT ;\r\nsmt->rmt_t_jam = DEFAULT_T_JAM ;\r\nsmt->rmt_t_announce = DEFAULT_T_ANNOUNCE ;\r\nsmt->rmt_t_poll = DEFAULT_POLL ;\r\nsmt->rmt_dup_mac_behavior = FALSE ;\r\nsmt->mac_d_max = DEFAULT_D_MAX ;\r\nsmt->lct_short = DEFAULT_LCT_SHORT ;\r\nsmt->lct_medium = DEFAULT_LCT_MEDIUM ;\r\nsmt->lct_long = DEFAULT_LCT_LONG ;\r\nsmt->lct_extended = DEFAULT_LCT_EXTEND ;\r\n#ifndef SLIM_SMT\r\n#ifdef ESS\r\nif (level == 0) {\r\nsmc->ess.sync_bw_available = FALSE ;\r\nsmc->mib.fddiESSPayload = 0 ;\r\nsmc->mib.fddiESSOverhead = 0 ;\r\nsmc->mib.fddiESSMaxTNeg = (u_long)(- MS2BCLK(25)) ;\r\nsmc->mib.fddiESSMinSegmentSize = 1 ;\r\nsmc->mib.fddiESSCategory = SB_STATIC ;\r\nsmc->mib.fddiESSSynchTxMode = FALSE ;\r\nsmc->ess.raf_act_timer_poll = FALSE ;\r\nsmc->ess.timer_count = 7 ;\r\n}\r\nsmc->ess.local_sba_active = FALSE ;\r\nsmc->ess.sba_reply_pend = NULL ;\r\n#endif\r\n#ifdef SBA\r\nsmt_init_sba(smc,level) ;\r\n#endif\r\n#endif\r\n#ifdef TAG_MODE\r\nif (level == 0) {\r\nsmc->hw.pci_fix_value = 0 ;\r\n}\r\n#endif\r\n}\r\nstatic void smt_init_mib(struct s_smc *smc, int level)\r\n{\r\nstruct fddi_mib *mib ;\r\nstruct fddi_mib_p *pm ;\r\nint port ;\r\nint path ;\r\nmib = &smc->mib ;\r\nif (level == 0) {\r\nmemset(((char *)smc)+\r\nsizeof(struct s_smt_os)+sizeof(struct s_smt_hw), 0,\r\nsizeof(struct s_smc) -\r\nsizeof(struct s_smt_os) - sizeof(struct s_smt_hw)) ;\r\n}\r\nelse {\r\nmib->fddiSMTRemoteDisconnectFlag = 0 ;\r\nmib->fddiSMTPeerWrapFlag = 0 ;\r\n}\r\nmib->fddiSMTOpVersionId = 2 ;\r\nmib->fddiSMTHiVersionId = 2 ;\r\nmib->fddiSMTLoVersionId = 2 ;\r\nmemcpy((char *) mib->fddiSMTManufacturerData,man_data,32) ;\r\nif (level == 0) {\r\nstrcpy(mib->fddiSMTUserData,OEM_USER_DATA) ;\r\n}\r\nmib->fddiSMTMIBVersionId = 1 ;\r\nmib->fddiSMTMac_Ct = NUMMACS ;\r\nmib->fddiSMTConnectionPolicy = POLICY_MM | POLICY_AA | POLICY_BB ;\r\nmib->fddiSMTAvailablePaths = MIB_PATH_P | MIB_PATH_S ;\r\nmib->fddiSMTConfigCapabilities = 0 ;\r\nmib->fddiSMTTT_Notify = 10 ;\r\nmib->fddiSMTStatRptPolicy = TRUE ;\r\nmib->fddiSMTTrace_MaxExpiration = SEC2MIB(7) ;\r\nmib->fddiSMTMACIndexes = INDEX_MAC ;\r\nmib->fddiSMTStationStatus = MIB_SMT_STASTA_SEPA ;\r\nmib->m[MAC0].fddiMACIndex = INDEX_MAC ;\r\nmib->m[MAC0].fddiMACFrameStatusFunctions = FSC_TYPE0 ;\r\nmib->m[MAC0].fddiMACRequestedPaths =\r\nMIB_P_PATH_LOCAL |\r\nMIB_P_PATH_SEC_ALTER |\r\nMIB_P_PATH_PRIM_ALTER ;\r\nmib->m[MAC0].fddiMACAvailablePaths = MIB_PATH_P ;\r\nmib->m[MAC0].fddiMACCurrentPath = MIB_PATH_PRIMARY ;\r\nmib->m[MAC0].fddiMACT_MaxCapabilitiy = (u_long)(- MS2BCLK(165)) ;\r\nmib->m[MAC0].fddiMACTVXCapabilitiy = (u_long)(- US2BCLK(52)) ;\r\nif (level == 0) {\r\nmib->m[MAC0].fddiMACTvxValue = (u_long)(- US2BCLK(27)) ;\r\nmib->m[MAC0].fddiMACTvxValueMIB = (u_long)(- US2BCLK(27)) ;\r\nmib->m[MAC0].fddiMACT_Req = (u_long)(- MS2BCLK(165)) ;\r\nmib->m[MAC0].fddiMACT_ReqMIB = (u_long)(- MS2BCLK(165)) ;\r\nmib->m[MAC0].fddiMACT_Max = (u_long)(- MS2BCLK(165)) ;\r\nmib->m[MAC0].fddiMACT_MaxMIB = (u_long)(- MS2BCLK(165)) ;\r\nmib->m[MAC0].fddiMACT_Min = (u_long)(- MS2BCLK(4)) ;\r\n}\r\nmib->m[MAC0].fddiMACHardwarePresent = TRUE ;\r\nmib->m[MAC0].fddiMACMA_UnitdataEnable = TRUE ;\r\nmib->m[MAC0].fddiMACFrameErrorThreshold = 1 ;\r\nmib->m[MAC0].fddiMACNotCopiedThreshold = 1 ;\r\nfor (path = 0 ; path < NUMPATHS ; path++) {\r\nmib->a[path].fddiPATHIndex = INDEX_PATH + path ;\r\nif (level == 0) {\r\nmib->a[path].fddiPATHTVXLowerBound =\r\n(u_long)(- US2BCLK(27)) ;\r\nmib->a[path].fddiPATHT_MaxLowerBound =\r\n(u_long)(- MS2BCLK(165)) ;\r\nmib->a[path].fddiPATHMaxT_Req =\r\n(u_long)(- MS2BCLK(165)) ;\r\n}\r\n}\r\npm = mib->p ;\r\nfor (port = 0 ; port < NUMPHYS ; port++) {\r\nsmc->y[port].mib = NULL;\r\nmib->fddiSMTPORTIndexes[port] = port+INDEX_PORT ;\r\npm->fddiPORTIndex = port+INDEX_PORT ;\r\npm->fddiPORTHardwarePresent = TRUE ;\r\nif (level == 0) {\r\npm->fddiPORTLer_Alarm = DEFAULT_LEM_ALARM ;\r\npm->fddiPORTLer_Cutoff = DEFAULT_LEM_CUTOFF ;\r\n}\r\npm->fddiPORTRequestedPaths[1] = 0 ;\r\npm->fddiPORTRequestedPaths[2] = 0 ;\r\npm->fddiPORTRequestedPaths[3] = 0 ;\r\npm->fddiPORTAvailablePaths = MIB_PATH_P ;\r\npm->fddiPORTPMDClass = MIB_PMDCLASS_MULTI ;\r\npm++ ;\r\n}\r\n(void) smt_set_mac_opvalues(smc) ;\r\n}\r\nint smt_set_mac_opvalues(struct s_smc *smc)\r\n{\r\nint st ;\r\nint st2 ;\r\nst = set_min_max(1,smc->mib.m[MAC0].fddiMACTvxValueMIB,\r\nsmc->mib.a[PATH0].fddiPATHTVXLowerBound,\r\n&smc->mib.m[MAC0].fddiMACTvxValue) ;\r\nst |= set_min_max(0,smc->mib.m[MAC0].fddiMACT_MaxMIB,\r\nsmc->mib.a[PATH0].fddiPATHT_MaxLowerBound,\r\n&smc->mib.m[MAC0].fddiMACT_Max) ;\r\nst |= (st2 = set_min_max(0,smc->mib.m[MAC0].fddiMACT_ReqMIB,\r\nsmc->mib.a[PATH0].fddiPATHMaxT_Req,\r\n&smc->mib.m[MAC0].fddiMACT_Req)) ;\r\nif (st2) {\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\r\nFDDI_SMT_EVENT, (u_long) FDDI_REMOTE_T_REQ,\r\nsmt_get_event_word(smc));\r\n}\r\nreturn st;\r\n}\r\nvoid smt_fixup_mib(struct s_smc *smc)\r\n{\r\n#ifdef CONCENTRATOR\r\nswitch (smc->s.sas) {\r\ncase SMT_SAS :\r\nsmc->mib.fddiSMTNonMaster_Ct = 1 ;\r\nbreak ;\r\ncase SMT_DAS :\r\nsmc->mib.fddiSMTNonMaster_Ct = 2 ;\r\nbreak ;\r\ncase SMT_NAC :\r\nsmc->mib.fddiSMTNonMaster_Ct = 0 ;\r\nbreak ;\r\n}\r\nsmc->mib.fddiSMTMaster_Ct = NUMPHYS - smc->mib.fddiSMTNonMaster_Ct ;\r\n#else\r\nswitch (smc->s.sas) {\r\ncase SMT_SAS :\r\nsmc->mib.fddiSMTNonMaster_Ct = 1 ;\r\nbreak ;\r\ncase SMT_DAS :\r\nsmc->mib.fddiSMTNonMaster_Ct = 2 ;\r\nbreak ;\r\n}\r\nsmc->mib.fddiSMTMaster_Ct = 0 ;\r\n#endif\r\n}\r\nstatic int set_min_max(int maxflag, u_long mib, u_long limit, u_long *oper)\r\n{\r\nu_long old ;\r\nold = *oper ;\r\nif ((limit > mib) ^ maxflag)\r\n*oper = limit ;\r\nelse\r\n*oper = mib ;\r\nreturn old != *oper;\r\n}
