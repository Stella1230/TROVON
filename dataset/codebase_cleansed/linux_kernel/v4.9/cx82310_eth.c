static int cx82310_cmd(struct usbnet *dev, enum cx82310_cmd cmd, bool reply,\r\nu8 *wdata, int wlen, u8 *rdata, int rlen)\r\n{\r\nint actual_len, retries, ret;\r\nstruct usb_device *udev = dev->udev;\r\nu8 *buf = kzalloc(CMD_PACKET_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = cmd;\r\nif (wdata)\r\nmemcpy(buf + 4, wdata, min_t(int, wlen, CMD_PACKET_SIZE - 4));\r\nret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, CMD_EP), buf,\r\nCMD_PACKET_SIZE, &actual_len, CMD_TIMEOUT);\r\nif (ret < 0) {\r\nif (cmd != CMD_GET_LINK_STATUS)\r\ndev_err(&dev->udev->dev, "send command %#x: error %d\n",\r\ncmd, ret);\r\ngoto end;\r\n}\r\nif (reply) {\r\nfor (retries = 0; retries < CMD_REPLY_RETRY; retries++) {\r\nret = usb_bulk_msg(udev, usb_rcvbulkpipe(udev, CMD_EP),\r\nbuf, CMD_PACKET_SIZE, &actual_len,\r\nCMD_TIMEOUT);\r\nif (ret < 0) {\r\nif (cmd != CMD_GET_LINK_STATUS)\r\ndev_err(&dev->udev->dev,\r\n"reply receive error %d\n",\r\nret);\r\ngoto end;\r\n}\r\nif (actual_len > 0)\r\nbreak;\r\n}\r\nif (actual_len == 0) {\r\ndev_err(&dev->udev->dev, "no reply to command %#x\n",\r\ncmd);\r\nret = -EIO;\r\ngoto end;\r\n}\r\nif (buf[0] != cmd) {\r\ndev_err(&dev->udev->dev,\r\n"got reply to command %#x, expected: %#x\n",\r\nbuf[0], cmd);\r\nret = -EIO;\r\ngoto end;\r\n}\r\nif (buf[1] != STATUS_SUCCESS) {\r\ndev_err(&dev->udev->dev, "command %#x failed: %#x\n",\r\ncmd, buf[1]);\r\nret = -EIO;\r\ngoto end;\r\n}\r\nif (rdata)\r\nmemcpy(rdata, buf + 4,\r\nmin_t(int, rlen, CMD_PACKET_SIZE - 4));\r\n}\r\nend:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int cx82310_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret;\r\nchar buf[15];\r\nstruct usb_device *udev = dev->udev;\r\nu8 link[3];\r\nint timeout = 50;\r\nif (usb_string(udev, udev->descriptor.iProduct, buf, sizeof(buf)) > 0\r\n&& strcmp(buf, "USB NET CARD")) {\r\ndev_info(&udev->dev, "ignoring: probably an ADSL modem\n");\r\nreturn -ENODEV;\r\n}\r\nret = usbnet_get_endpoints(dev, intf);\r\nif (ret)\r\nreturn ret;\r\ndev->net->hard_header_len = 0;\r\ndev->hard_mtu = CX82310_MTU + 2;\r\ndev->rx_urb_size = 4096;\r\ndev->partial_data = (unsigned long) kmalloc(dev->hard_mtu, GFP_KERNEL);\r\nif (!dev->partial_data)\r\nreturn -ENOMEM;\r\nwhile (--timeout) {\r\nret = cx82310_cmd(dev, CMD_GET_LINK_STATUS, true, NULL, 0,\r\nlink, sizeof(link));\r\nif (!ret && link[0] == 1 && link[2] == 1)\r\nbreak;\r\nmsleep(500);\r\n}\r\nif (!timeout) {\r\ndev_err(&udev->dev, "firmware not ready in time\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = cx82310_cmd(dev, CMD_ETHERNET_MODE, true, "\x01", 1, NULL, 0);\r\nif (ret) {\r\ndev_err(&udev->dev, "unable to enable ethernet mode: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nret = cx82310_cmd(dev, CMD_GET_MAC_ADDR, true, NULL, 0,\r\ndev->net->dev_addr, ETH_ALEN);\r\nif (ret) {\r\ndev_err(&udev->dev, "unable to read MAC address: %d\n", ret);\r\ngoto err;\r\n}\r\nret = cx82310_cmd(dev, CMD_START, false, NULL, 0, NULL, 0);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree((void *)dev->partial_data);\r\nreturn ret;\r\n}\r\nstatic void cx82310_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nkfree((void *)dev->partial_data);\r\n}\r\nstatic int cx82310_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nint len;\r\nstruct sk_buff *skb2;\r\nif (dev->partial_rem) {\r\nlen = dev->partial_len + dev->partial_rem;\r\nskb2 = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb2)\r\nreturn 0;\r\nskb_put(skb2, len);\r\nmemcpy(skb2->data, (void *)dev->partial_data,\r\ndev->partial_len);\r\nmemcpy(skb2->data + dev->partial_len, skb->data,\r\ndev->partial_rem);\r\nusbnet_skb_return(dev, skb2);\r\nskb_pull(skb, (dev->partial_rem + 1) & ~1);\r\ndev->partial_rem = 0;\r\nif (skb->len < 2)\r\nreturn 1;\r\n}\r\nwhile (skb->len > 1) {\r\nlen = skb->data[0] | (skb->data[1] << 8);\r\nskb_pull(skb, 2);\r\nif (len == skb->len || len + 1 == skb->len) {\r\nskb_trim(skb, len);\r\nbreak;\r\n}\r\nif (len > CX82310_MTU) {\r\ndev_err(&dev->udev->dev, "RX packet too long: %d B\n",\r\nlen);\r\nreturn 0;\r\n}\r\nif (len > skb->len) {\r\ndev->partial_len = skb->len;\r\ndev->partial_rem = len - skb->len;\r\nmemcpy((void *)dev->partial_data, skb->data,\r\ndev->partial_len);\r\nskb_pull(skb, skb->len);\r\nbreak;\r\n}\r\nskb2 = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb2)\r\nreturn 0;\r\nskb_put(skb2, len);\r\nmemcpy(skb2->data, skb->data, len);\r\nusbnet_skb_return(dev, skb2);\r\nskb_pull(skb, (len + 1) & ~1);\r\n}\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *cx82310_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\r\ngfp_t flags)\r\n{\r\nint len = skb->len;\r\nif (skb_headroom(skb) < 2) {\r\nstruct sk_buff *skb2 = skb_copy_expand(skb, 2, 0, flags);\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\nif (!skb)\r\nreturn NULL;\r\n}\r\nskb_push(skb, 2);\r\nskb->data[0] = len;\r\nskb->data[1] = len >> 8;\r\nreturn skb;\r\n}
