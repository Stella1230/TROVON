static irqreturn_t m41t80_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct m41t80_data *m41t80 = i2c_get_clientdata(client);\r\nstruct mutex *lock = &m41t80->rtc->ops_lock;\r\nunsigned long events = 0;\r\nint flags, flags_afe;\r\nmutex_lock(lock);\r\nflags_afe = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\r\nif (flags_afe < 0) {\r\nmutex_unlock(lock);\r\nreturn IRQ_NONE;\r\n}\r\nflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nif (flags <= 0) {\r\nmutex_unlock(lock);\r\nreturn IRQ_NONE;\r\n}\r\nif (flags & M41T80_FLAGS_AF) {\r\nflags &= ~M41T80_FLAGS_AF;\r\nflags_afe &= ~M41T80_ALMON_AFE;\r\nevents |= RTC_AF;\r\n}\r\nif (events) {\r\nrtc_update_irq(m41t80->rtc, 1, events);\r\ni2c_smbus_write_byte_data(client, M41T80_REG_FLAGS, flags);\r\ni2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\r\nflags_afe);\r\n}\r\nmutex_unlock(lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int m41t80_get_datetime(struct i2c_client *client,\r\nstruct rtc_time *tm)\r\n{\r\nunsigned char buf[8];\r\nint err, flags;\r\nflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nif (flags < 0)\r\nreturn flags;\r\nif (flags & M41T80_FLAGS_OF) {\r\ndev_err(&client->dev, "Oscillator failure, data is invalid.\n");\r\nreturn -EINVAL;\r\n}\r\nerr = i2c_smbus_read_i2c_block_data(client, M41T80_REG_SSEC,\r\nsizeof(buf), buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to read date\n");\r\nreturn -EIO;\r\n}\r\ntm->tm_sec = bcd2bin(buf[M41T80_REG_SEC] & 0x7f);\r\ntm->tm_min = bcd2bin(buf[M41T80_REG_MIN] & 0x7f);\r\ntm->tm_hour = bcd2bin(buf[M41T80_REG_HOUR] & 0x3f);\r\ntm->tm_mday = bcd2bin(buf[M41T80_REG_DAY] & 0x3f);\r\ntm->tm_wday = buf[M41T80_REG_WDAY] & 0x07;\r\ntm->tm_mon = bcd2bin(buf[M41T80_REG_MON] & 0x1f) - 1;\r\ntm->tm_year = bcd2bin(buf[M41T80_REG_YEAR]) + 100;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int m41t80_set_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nunsigned char buf[8];\r\nint err, flags;\r\nif (tm->tm_year < 100 || tm->tm_year > 199)\r\nreturn -EINVAL;\r\nbuf[M41T80_REG_SSEC] = 0;\r\nbuf[M41T80_REG_SEC] = bin2bcd(tm->tm_sec);\r\nbuf[M41T80_REG_MIN] = bin2bcd(tm->tm_min);\r\nbuf[M41T80_REG_HOUR] = bin2bcd(tm->tm_hour);\r\nbuf[M41T80_REG_DAY] = bin2bcd(tm->tm_mday);\r\nbuf[M41T80_REG_MON] = bin2bcd(tm->tm_mon + 1);\r\nbuf[M41T80_REG_YEAR] = bin2bcd(tm->tm_year - 100);\r\nbuf[M41T80_REG_WDAY] = tm->tm_wday;\r\nerr = i2c_smbus_write_i2c_block_data(client, M41T80_REG_SSEC,\r\nsizeof(buf), buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write to date registers\n");\r\nreturn err;\r\n}\r\nflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nif (flags < 0)\r\nreturn flags;\r\nif (i2c_smbus_write_byte_data(client, M41T80_REG_FLAGS,\r\nflags & ~M41T80_FLAGS_OF)) {\r\ndev_err(&client->dev, "Unable to write flags register\n");\r\nreturn -EIO;\r\n}\r\nreturn err;\r\n}\r\nstatic int m41t80_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(client);\r\nu8 reg;\r\nif (clientdata->features & M41T80_FEATURE_BL) {\r\nreg = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nseq_printf(seq, "battery\t\t: %s\n",\r\n(reg & M41T80_FLAGS_BATT_LOW) ? "exhausted" : "ok");\r\n}\r\nreturn 0;\r\n}\r\nstatic int m41t80_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn m41t80_get_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int m41t80_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn m41t80_set_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int m41t80_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint flags, retval;\r\nflags = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\r\nif (flags < 0)\r\nreturn flags;\r\nif (enabled)\r\nflags |= M41T80_ALMON_AFE;\r\nelse\r\nflags &= ~M41T80_ALMON_AFE;\r\nretval = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON, flags);\r\nif (retval < 0) {\r\ndev_err(dev, "Unable to enable alarm IRQ %d\n", retval);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int m41t80_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 alarmvals[5];\r\nint ret, err;\r\nalarmvals[0] = bin2bcd(alrm->time.tm_mon + 1);\r\nalarmvals[1] = bin2bcd(alrm->time.tm_mday);\r\nalarmvals[2] = bin2bcd(alrm->time.tm_hour);\r\nalarmvals[3] = bin2bcd(alrm->time.tm_min);\r\nalarmvals[4] = bin2bcd(alrm->time.tm_sec);\r\nret = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\r\nif (ret < 0)\r\nreturn ret;\r\nerr = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\r\nret & ~(M41T80_ALMON_AFE));\r\nif (err < 0) {\r\ndev_err(dev, "Unable to clear AFE bit\n");\r\nreturn err;\r\n}\r\nret = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nif (ret < 0)\r\nreturn ret;\r\nerr = i2c_smbus_write_byte_data(client, M41T80_REG_FLAGS,\r\nret & ~(M41T80_FLAGS_AF));\r\nif (err < 0) {\r\ndev_err(dev, "Unable to clear AF bit\n");\r\nreturn err;\r\n}\r\nerr = i2c_smbus_write_i2c_block_data(client, M41T80_REG_ALARM_MON,\r\n5, alarmvals);\r\nif (err)\r\nreturn err;\r\nif (alrm->enabled) {\r\nalarmvals[0] |= M41T80_ALMON_AFE;\r\nerr = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\r\nalarmvals[0]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int m41t80_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 alarmvals[5];\r\nint flags, ret;\r\nret = i2c_smbus_read_i2c_block_data(client, M41T80_REG_ALARM_MON,\r\n5, alarmvals);\r\nif (ret != 5)\r\nreturn ret < 0 ? ret : -EIO;\r\nflags = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nif (flags < 0)\r\nreturn flags;\r\nalrm->time.tm_sec = bcd2bin(alarmvals[4] & 0x7f);\r\nalrm->time.tm_min = bcd2bin(alarmvals[3] & 0x7f);\r\nalrm->time.tm_hour = bcd2bin(alarmvals[2] & 0x3f);\r\nalrm->time.tm_mday = bcd2bin(alarmvals[1] & 0x3f);\r\nalrm->time.tm_mon = bcd2bin(alarmvals[0] & 0x3f);\r\nalrm->enabled = !!(alarmvals[0] & M41T80_ALMON_AFE);\r\nalrm->pending = (flags & M41T80_FLAGS_AF) && alrm->enabled;\r\nreturn 0;\r\n}\r\nstatic int m41t80_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (client->irq >= 0 && device_may_wakeup(dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int m41t80_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (client->irq >= 0 && device_may_wakeup(dev))\r\ndisable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic ssize_t flags_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint val;\r\nval = i2c_smbus_read_byte_data(client, M41T80_REG_FLAGS);\r\nif (val < 0)\r\nreturn val;\r\nreturn sprintf(buf, "%#x\n", val);\r\n}\r\nstatic ssize_t sqwfreq_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(client);\r\nint val, reg_sqw;\r\nif (!(clientdata->features & M41T80_FEATURE_SQ))\r\nreturn -EINVAL;\r\nreg_sqw = M41T80_REG_SQW;\r\nif (clientdata->features & M41T80_FEATURE_SQ_ALT)\r\nreg_sqw = M41T80_REG_WDAY;\r\nval = i2c_smbus_read_byte_data(client, reg_sqw);\r\nif (val < 0)\r\nreturn val;\r\nval = (val >> 4) & 0xf;\r\nswitch (val) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nval = 32768;\r\nbreak;\r\ndefault:\r\nval = 32768 >> val;\r\n}\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t sqwfreq_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(client);\r\nint almon, sqw, reg_sqw, rc;\r\nunsigned long val;\r\nrc = kstrtoul(buf, 0, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!(clientdata->features & M41T80_FEATURE_SQ))\r\nreturn -EINVAL;\r\nif (val) {\r\nif (!is_power_of_2(val))\r\nreturn -EINVAL;\r\nval = ilog2(val);\r\nif (val == 15)\r\nval = 1;\r\nelse if (val < 14)\r\nval = 15 - val;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nalmon = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);\r\nif (almon < 0)\r\nreturn almon;\r\nreg_sqw = M41T80_REG_SQW;\r\nif (clientdata->features & M41T80_FEATURE_SQ_ALT)\r\nreg_sqw = M41T80_REG_WDAY;\r\nsqw = i2c_smbus_read_byte_data(client, reg_sqw);\r\nif (sqw < 0)\r\nreturn sqw;\r\nsqw = (sqw & 0x0f) | (val << 4);\r\nrc = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\r\nalmon & ~M41T80_ALMON_SQWE);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val) {\r\nrc = i2c_smbus_write_byte_data(client, reg_sqw, sqw);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,\r\nalmon | M41T80_ALMON_SQWE);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn count;\r\n}\r\nstatic void wdt_ping(void)\r\n{\r\nunsigned char i2c_data[2];\r\nstruct i2c_msg msgs1[1] = {\r\n{\r\n.addr = save_client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = i2c_data,\r\n},\r\n};\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(save_client);\r\ni2c_data[0] = 0x09;\r\nif (wdt_margin > 31)\r\ni2c_data[1] = (wdt_margin & 0xFC) | 0x83;\r\nelse\r\ni2c_data[1] = wdt_margin << 2 | 0x82;\r\nif (clientdata->features & M41T80_FEATURE_WD)\r\ni2c_data[1] &= ~M41T80_WATCHDOG_RB2;\r\ni2c_transfer(save_client->adapter, msgs1, 1);\r\n}\r\nstatic void wdt_disable(void)\r\n{\r\nunsigned char i2c_data[2], i2c_buf[0x10];\r\nstruct i2c_msg msgs0[2] = {\r\n{\r\n.addr = save_client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = i2c_data,\r\n},\r\n{\r\n.addr = save_client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = i2c_buf,\r\n},\r\n};\r\nstruct i2c_msg msgs1[1] = {\r\n{\r\n.addr = save_client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = i2c_data,\r\n},\r\n};\r\ni2c_data[0] = 0x09;\r\ni2c_transfer(save_client->adapter, msgs0, 2);\r\ni2c_data[0] = 0x09;\r\ni2c_data[1] = 0x00;\r\ni2c_transfer(save_client->adapter, msgs1, 1);\r\n}\r\nstatic ssize_t wdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nwdt_ping();\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t wdt_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint new_margin, rv;\r\nstatic struct watchdog_info ident = {\r\n.options = WDIOF_POWERUNDER | WDIOF_KEEPALIVEPING |\r\nWDIOF_SETTIMEOUT,\r\n.firmware_version = 1,\r\n.identity = "M41T80 WTD"\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user((struct watchdog_info __user *)arg, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(boot_flag, (int __user *)arg);\r\ncase WDIOC_KEEPALIVE:\r\nwdt_ping();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_margin, (int __user *)arg))\r\nreturn -EFAULT;\r\nif (new_margin < 1 || new_margin > 124)\r\nreturn -EINVAL;\r\nwdt_margin = new_margin;\r\nwdt_ping();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(wdt_margin, (int __user *)arg);\r\ncase WDIOC_SETOPTIONS:\r\nif (copy_from_user(&rv, (int __user *)arg, sizeof(int)))\r\nreturn -EFAULT;\r\nif (rv & WDIOS_DISABLECARD) {\r\npr_info("disable watchdog\n");\r\nwdt_disable();\r\n}\r\nif (rv & WDIOS_ENABLECARD) {\r\npr_info("enable watchdog\n");\r\nwdt_ping();\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic long wdt_unlocked_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&m41t80_rtc_mutex);\r\nret = wdt_ioctl(file, cmd, arg);\r\nmutex_unlock(&m41t80_rtc_mutex);\r\nreturn ret;\r\n}\r\nstatic int wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (MINOR(inode->i_rdev) == WATCHDOG_MINOR) {\r\nmutex_lock(&m41t80_rtc_mutex);\r\nif (test_and_set_bit(0, &wdt_is_open)) {\r\nmutex_unlock(&m41t80_rtc_mutex);\r\nreturn -EBUSY;\r\n}\r\nwdt_is_open = 1;\r\nmutex_unlock(&m41t80_rtc_mutex);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (MINOR(inode->i_rdev) == WATCHDOG_MINOR)\r\nclear_bit(0, &wdt_is_open);\r\nreturn 0;\r\n}\r\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdt_disable();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void m41t80_remove_sysfs_group(void *_dev)\r\n{\r\nstruct device *dev = _dev;\r\nsysfs_remove_group(&dev->kobj, &attr_group);\r\n}\r\nstatic int m41t80_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nint rc = 0;\r\nstruct rtc_device *rtc = NULL;\r\nstruct rtc_time tm;\r\nstruct m41t80_data *m41t80_data = NULL;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK |\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&adapter->dev, "doesn't support I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK\n");\r\nreturn -ENODEV;\r\n}\r\nm41t80_data = devm_kzalloc(&client->dev, sizeof(*m41t80_data),\r\nGFP_KERNEL);\r\nif (!m41t80_data)\r\nreturn -ENOMEM;\r\nm41t80_data->features = id->driver_data;\r\ni2c_set_clientdata(client, m41t80_data);\r\nif (client->irq > 0) {\r\nrc = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, m41t80_handle_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"m41t80", client);\r\nif (rc) {\r\ndev_warn(&client->dev, "unable to request IRQ, alarms disabled\n");\r\nclient->irq = 0;\r\n} else {\r\nm41t80_rtc_ops.read_alarm = m41t80_read_alarm;\r\nm41t80_rtc_ops.set_alarm = m41t80_set_alarm;\r\nm41t80_rtc_ops.alarm_irq_enable = m41t80_alarm_irq_enable;\r\ndevice_init_wakeup(&client->dev, true);\r\n}\r\n}\r\nrtc = devm_rtc_device_register(&client->dev, client->name,\r\n&m41t80_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\nm41t80_data->rtc = rtc;\r\nrc = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_HOUR);\r\nif (rc >= 0 && rc & M41T80_ALHOUR_HT) {\r\nif (m41t80_data->features & M41T80_FEATURE_HT) {\r\nm41t80_get_datetime(client, &tm);\r\ndev_info(&client->dev, "HT bit was set!\n");\r\ndev_info(&client->dev,\r\n"Power Down at %04i-%02i-%02i %02i:%02i:%02i\n",\r\ntm.tm_year + 1900,\r\ntm.tm_mon + 1, tm.tm_mday, tm.tm_hour,\r\ntm.tm_min, tm.tm_sec);\r\n}\r\nrc = i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_HOUR,\r\nrc & ~M41T80_ALHOUR_HT);\r\n}\r\nif (rc < 0) {\r\ndev_err(&client->dev, "Can't clear HT bit\n");\r\nreturn rc;\r\n}\r\nrc = i2c_smbus_read_byte_data(client, M41T80_REG_SEC);\r\nif (rc >= 0 && rc & M41T80_SEC_ST)\r\nrc = i2c_smbus_write_byte_data(client, M41T80_REG_SEC,\r\nrc & ~M41T80_SEC_ST);\r\nif (rc < 0) {\r\ndev_err(&client->dev, "Can't clear ST bit\n");\r\nreturn rc;\r\n}\r\nrc = sysfs_create_group(&(&client->dev)->kobj, &attr_group);\r\nif (rc) {\r\ndev_err(&client->dev, "Failed to create sysfs group: %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = devm_add_action_or_reset(&client->dev, m41t80_remove_sysfs_group,\r\n&client->dev);\r\nif (rc) {\r\ndev_err(&client->dev,\r\n"Failed to add sysfs cleanup action: %d\n", rc);\r\nreturn rc;\r\n}\r\n#ifdef CONFIG_RTC_DRV_M41T80_WDT\r\nif (m41t80_data->features & M41T80_FEATURE_HT) {\r\nsave_client = client;\r\nrc = misc_register(&wdt_dev);\r\nif (rc)\r\nreturn rc;\r\nrc = register_reboot_notifier(&wdt_notifier);\r\nif (rc) {\r\nmisc_deregister(&wdt_dev);\r\nreturn rc;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int m41t80_remove(struct i2c_client *client)\r\n{\r\n#ifdef CONFIG_RTC_DRV_M41T80_WDT\r\nstruct m41t80_data *clientdata = i2c_get_clientdata(client);\r\nif (clientdata->features & M41T80_FEATURE_HT) {\r\nmisc_deregister(&wdt_dev);\r\nunregister_reboot_notifier(&wdt_notifier);\r\n}\r\n#endif\r\nreturn 0;\r\n}
