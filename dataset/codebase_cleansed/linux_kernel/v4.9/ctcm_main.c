void ctcm_unpack_skb(struct channel *ch, struct sk_buff *pskb)\r\n{\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\n__u16 len = *((__u16 *) pskb->data);\r\nskb_put(pskb, 2 + LL_HEADER_LENGTH);\r\nskb_pull(pskb, 2);\r\npskb->dev = dev;\r\npskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nwhile (len > 0) {\r\nstruct sk_buff *skb;\r\nint skblen;\r\nstruct ll_header *header = (struct ll_header *)pskb->data;\r\nskb_pull(pskb, LL_HEADER_LENGTH);\r\nif ((ch->protocol == CTCM_PROTO_S390) &&\r\n(header->type != ETH_P_IP)) {\r\nif (!(ch->logflags & LOG_FLAG_ILLEGALPKT)) {\r\nch->logflags |= LOG_FLAG_ILLEGALPKT;\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): Illegal packet type 0x%04x"\r\n" - dropping",\r\nCTCM_FUNTAIL, dev->name, header->type);\r\n}\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_frame_errors++;\r\nreturn;\r\n}\r\npskb->protocol = ntohs(header->type);\r\nif ((header->length <= LL_HEADER_LENGTH) ||\r\n(len <= LL_HEADER_LENGTH)) {\r\nif (!(ch->logflags & LOG_FLAG_ILLEGALSIZE)) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): Illegal packet size %d(%d,%d)"\r\n"- dropping",\r\nCTCM_FUNTAIL, dev->name,\r\nheader->length, dev->mtu, len);\r\nch->logflags |= LOG_FLAG_ILLEGALSIZE;\r\n}\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_length_errors++;\r\nreturn;\r\n}\r\nheader->length -= LL_HEADER_LENGTH;\r\nlen -= LL_HEADER_LENGTH;\r\nif ((header->length > skb_tailroom(pskb)) ||\r\n(header->length > len)) {\r\nif (!(ch->logflags & LOG_FLAG_OVERRUN)) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): Packet size %d (overrun)"\r\n" - dropping", CTCM_FUNTAIL,\r\ndev->name, header->length);\r\nch->logflags |= LOG_FLAG_OVERRUN;\r\n}\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_length_errors++;\r\nreturn;\r\n}\r\nskb_put(pskb, header->length);\r\nskb_reset_mac_header(pskb);\r\nlen -= header->length;\r\nskb = dev_alloc_skb(pskb->len);\r\nif (!skb) {\r\nif (!(ch->logflags & LOG_FLAG_NOMEM)) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): MEMORY allocation error",\r\nCTCM_FUNTAIL, dev->name);\r\nch->logflags |= LOG_FLAG_NOMEM;\r\n}\r\npriv->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_copy_from_linear_data(pskb, skb_put(skb, pskb->len),\r\npskb->len);\r\nskb_reset_mac_header(skb);\r\nskb->dev = pskb->dev;\r\nskb->protocol = pskb->protocol;\r\npskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskblen = skb->len;\r\nch->logflags = 0;\r\npriv->stats.rx_packets++;\r\npriv->stats.rx_bytes += skblen;\r\nnetif_rx_ni(skb);\r\nif (len > 0) {\r\nskb_pull(pskb, header->length);\r\nif (skb_tailroom(pskb) < LL_HEADER_LENGTH) {\r\nCTCM_DBF_DEV_NAME(TRACE, dev,\r\n"Overrun in ctcm_unpack_skb");\r\nch->logflags |= LOG_FLAG_OVERRUN;\r\nreturn;\r\n}\r\nskb_put(pskb, LL_HEADER_LENGTH);\r\n}\r\n}\r\n}\r\nstatic void channel_free(struct channel *ch)\r\n{\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO, "%s(%s)", CTCM_FUNTAIL, ch->id);\r\nch->flags &= ~CHANNEL_FLAGS_INUSE;\r\nfsm_newstate(ch->fsm, CTC_STATE_IDLE);\r\n}\r\nstatic void channel_remove(struct channel *ch)\r\n{\r\nstruct channel **c = &channels;\r\nchar chid[CTCM_ID_SIZE+1];\r\nint ok = 0;\r\nif (ch == NULL)\r\nreturn;\r\nelse\r\nstrncpy(chid, ch->id, CTCM_ID_SIZE);\r\nchannel_free(ch);\r\nwhile (*c) {\r\nif (*c == ch) {\r\n*c = ch->next;\r\nfsm_deltimer(&ch->timer);\r\nif (IS_MPC(ch))\r\nfsm_deltimer(&ch->sweep_timer);\r\nkfree_fsm(ch->fsm);\r\nclear_normalized_cda(&ch->ccw[4]);\r\nif (ch->trans_skb != NULL) {\r\nclear_normalized_cda(&ch->ccw[1]);\r\ndev_kfree_skb_any(ch->trans_skb);\r\n}\r\nif (IS_MPC(ch)) {\r\ntasklet_kill(&ch->ch_tasklet);\r\ntasklet_kill(&ch->ch_disc_tasklet);\r\nkfree(ch->discontact_th);\r\n}\r\nkfree(ch->ccw);\r\nkfree(ch->irb);\r\nkfree(ch);\r\nok = 1;\r\nbreak;\r\n}\r\nc = &((*c)->next);\r\n}\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO, "%s(%s) %s", CTCM_FUNTAIL,\r\nchid, ok ? "OK" : "failed");\r\n}\r\nstatic struct channel *channel_get(enum ctcm_channel_types type,\r\nchar *id, int direction)\r\n{\r\nstruct channel *ch = channels;\r\nwhile (ch && (strncmp(ch->id, id, CTCM_ID_SIZE) || (ch->type != type)))\r\nch = ch->next;\r\nif (!ch) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%d, %s, %d) not found in channel list\n",\r\nCTCM_FUNTAIL, type, id, direction);\r\n} else {\r\nif (ch->flags & CHANNEL_FLAGS_INUSE)\r\nch = NULL;\r\nelse {\r\nch->flags |= CHANNEL_FLAGS_INUSE;\r\nch->flags &= ~CHANNEL_FLAGS_RWMASK;\r\nch->flags |= (direction == CTCM_WRITE)\r\n? CHANNEL_FLAGS_WRITE : CHANNEL_FLAGS_READ;\r\nfsm_newstate(ch->fsm, CTC_STATE_STOPPED);\r\n}\r\n}\r\nreturn ch;\r\n}\r\nstatic long ctcm_check_irb_error(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nif (!IS_ERR(irb))\r\nreturn 0;\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_WARN,\r\n"irb error %ld on device %s\n",\r\nPTR_ERR(irb), dev_name(&cdev->dev));\r\nswitch (PTR_ERR(irb)) {\r\ncase -EIO:\r\ndev_err(&cdev->dev,\r\n"An I/O-error occurred on the CTCM device\n");\r\nbreak;\r\ncase -ETIMEDOUT:\r\ndev_err(&cdev->dev,\r\n"An adapter hardware operation timed out\n");\r\nbreak;\r\ndefault:\r\ndev_err(&cdev->dev,\r\n"An error occurred on the adapter hardware\n");\r\n}\r\nreturn PTR_ERR(irb);\r\n}\r\nstatic inline void ccw_unit_check(struct channel *ch, __u8 sense)\r\n{\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\r\n"%s(%s): %02x",\r\nCTCM_FUNTAIL, ch->id, sense);\r\nif (sense & SNS0_INTERVENTION_REQ) {\r\nif (sense & 0x01) {\r\nif (ch->sense_rc != 0x01) {\r\npr_notice(\r\n"%s: The communication peer has "\r\n"disconnected\n", ch->id);\r\nch->sense_rc = 0x01;\r\n}\r\nfsm_event(ch->fsm, CTC_EVENT_UC_RCRESET, ch);\r\n} else {\r\nif (ch->sense_rc != SNS0_INTERVENTION_REQ) {\r\npr_notice(\r\n"%s: The remote operating system is "\r\n"not available\n", ch->id);\r\nch->sense_rc = SNS0_INTERVENTION_REQ;\r\n}\r\nfsm_event(ch->fsm, CTC_EVENT_UC_RSRESET, ch);\r\n}\r\n} else if (sense & SNS0_EQUIPMENT_CHECK) {\r\nif (sense & SNS0_BUS_OUT_CHECK) {\r\nif (ch->sense_rc != SNS0_BUS_OUT_CHECK) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\r\n"%s(%s): remote HW error %02x",\r\nCTCM_FUNTAIL, ch->id, sense);\r\nch->sense_rc = SNS0_BUS_OUT_CHECK;\r\n}\r\nfsm_event(ch->fsm, CTC_EVENT_UC_HWFAIL, ch);\r\n} else {\r\nif (ch->sense_rc != SNS0_EQUIPMENT_CHECK) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\r\n"%s(%s): remote read parity error %02x",\r\nCTCM_FUNTAIL, ch->id, sense);\r\nch->sense_rc = SNS0_EQUIPMENT_CHECK;\r\n}\r\nfsm_event(ch->fsm, CTC_EVENT_UC_RXPARITY, ch);\r\n}\r\n} else if (sense & SNS0_BUS_OUT_CHECK) {\r\nif (ch->sense_rc != SNS0_BUS_OUT_CHECK) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\r\n"%s(%s): BUS OUT error %02x",\r\nCTCM_FUNTAIL, ch->id, sense);\r\nch->sense_rc = SNS0_BUS_OUT_CHECK;\r\n}\r\nif (sense & 0x04)\r\nfsm_event(ch->fsm, CTC_EVENT_UC_TXTIMEOUT, ch);\r\nelse\r\nfsm_event(ch->fsm, CTC_EVENT_UC_TXPARITY, ch);\r\n} else if (sense & SNS0_CMD_REJECT) {\r\nif (ch->sense_rc != SNS0_CMD_REJECT) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\r\n"%s(%s): Command rejected",\r\nCTCM_FUNTAIL, ch->id);\r\nch->sense_rc = SNS0_CMD_REJECT;\r\n}\r\n} else if (sense == 0) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\r\n"%s(%s): Unit check ZERO",\r\nCTCM_FUNTAIL, ch->id);\r\nfsm_event(ch->fsm, CTC_EVENT_UC_ZERO, ch);\r\n} else {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\r\n"%s(%s): Unit check code %02x unknown",\r\nCTCM_FUNTAIL, ch->id, sense);\r\nfsm_event(ch->fsm, CTC_EVENT_UC_UNKNOWN, ch);\r\n}\r\n}\r\nint ctcm_ch_alloc_buffer(struct channel *ch)\r\n{\r\nclear_normalized_cda(&ch->ccw[1]);\r\nch->trans_skb = __dev_alloc_skb(ch->max_bufsize, GFP_ATOMIC | GFP_DMA);\r\nif (ch->trans_skb == NULL) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): %s trans_skb allocation error",\r\nCTCM_FUNTAIL, ch->id,\r\n(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ?\r\n"RX" : "TX");\r\nreturn -ENOMEM;\r\n}\r\nch->ccw[1].count = ch->max_bufsize;\r\nif (set_normalized_cda(&ch->ccw[1], ch->trans_skb->data)) {\r\ndev_kfree_skb(ch->trans_skb);\r\nch->trans_skb = NULL;\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): %s set norm_cda failed",\r\nCTCM_FUNTAIL, ch->id,\r\n(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ?\r\n"RX" : "TX");\r\nreturn -ENOMEM;\r\n}\r\nch->ccw[1].count = 0;\r\nch->trans_skb_data = ch->trans_skb->data;\r\nch->flags &= ~CHANNEL_FLAGS_BUFSIZE_CHANGED;\r\nreturn 0;\r\n}\r\nint ctcm_open(struct net_device *dev)\r\n{\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCMY_DBF_DEV_NAME(SETUP, dev, "");\r\nif (!IS_MPC(priv))\r\nfsm_event(priv->fsm, DEV_EVENT_START, dev);\r\nreturn 0;\r\n}\r\nint ctcm_close(struct net_device *dev)\r\n{\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCMY_DBF_DEV_NAME(SETUP, dev, "");\r\nif (!IS_MPC(priv))\r\nfsm_event(priv->fsm, DEV_EVENT_STOP, dev);\r\nreturn 0;\r\n}\r\nstatic int ctcm_transmit_skb(struct channel *ch, struct sk_buff *skb)\r\n{\r\nunsigned long saveflags;\r\nstruct ll_header header;\r\nint rc = 0;\r\n__u16 block_len;\r\nint ccw_idx;\r\nstruct sk_buff *nskb;\r\nunsigned long hi;\r\nspin_lock_irqsave(&ch->collect_lock, saveflags);\r\nif (fsm_getstate(ch->fsm) != CTC_STATE_TXIDLE) {\r\nint l = skb->len + LL_HEADER_LENGTH;\r\nif (ch->collect_len + l > ch->max_bufsize - 2) {\r\nspin_unlock_irqrestore(&ch->collect_lock, saveflags);\r\nreturn -EBUSY;\r\n} else {\r\natomic_inc(&skb->users);\r\nheader.length = l;\r\nheader.type = skb->protocol;\r\nheader.unused = 0;\r\nmemcpy(skb_push(skb, LL_HEADER_LENGTH), &header,\r\nLL_HEADER_LENGTH);\r\nskb_queue_tail(&ch->collect_queue, skb);\r\nch->collect_len += l;\r\n}\r\nspin_unlock_irqrestore(&ch->collect_lock, saveflags);\r\ngoto done;\r\n}\r\nspin_unlock_irqrestore(&ch->collect_lock, saveflags);\r\natomic_inc(&skb->users);\r\nch->prof.txlen += skb->len;\r\nheader.length = skb->len + LL_HEADER_LENGTH;\r\nheader.type = skb->protocol;\r\nheader.unused = 0;\r\nmemcpy(skb_push(skb, LL_HEADER_LENGTH), &header, LL_HEADER_LENGTH);\r\nblock_len = skb->len + 2;\r\n*((__u16 *)skb_push(skb, 2)) = block_len;\r\nhi = ((unsigned long)skb_tail_pointer(skb) + LL_HEADER_LENGTH) >> 31;\r\nif (hi) {\r\nnskb = alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);\r\nif (!nskb) {\r\natomic_dec(&skb->users);\r\nskb_pull(skb, LL_HEADER_LENGTH + 2);\r\nctcm_clear_busy(ch->netdev);\r\nreturn -ENOMEM;\r\n} else {\r\nmemcpy(skb_put(nskb, skb->len), skb->data, skb->len);\r\natomic_inc(&nskb->users);\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_irq(skb);\r\nskb = nskb;\r\n}\r\n}\r\nch->ccw[4].count = block_len;\r\nif (set_normalized_cda(&ch->ccw[4], skb->data)) {\r\nif (ctcm_checkalloc_buffer(ch)) {\r\natomic_dec(&skb->users);\r\nskb_pull(skb, LL_HEADER_LENGTH + 2);\r\nctcm_clear_busy(ch->netdev);\r\nreturn -ENOMEM;\r\n}\r\nskb_reset_tail_pointer(ch->trans_skb);\r\nch->trans_skb->len = 0;\r\nch->ccw[1].count = skb->len;\r\nskb_copy_from_linear_data(skb,\r\nskb_put(ch->trans_skb, skb->len), skb->len);\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_irq(skb);\r\nccw_idx = 0;\r\n} else {\r\nskb_queue_tail(&ch->io_queue, skb);\r\nccw_idx = 3;\r\n}\r\nif (do_debug_ccw)\r\nctcmpc_dumpit((char *)&ch->ccw[ccw_idx],\r\nsizeof(struct ccw1) * 3);\r\nch->retry = 0;\r\nfsm_newstate(ch->fsm, CTC_STATE_TX);\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\nch->prof.send_stamp = jiffies;\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[ccw_idx],\r\n(unsigned long)ch, 0xff, 0);\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (ccw_idx == 3)\r\nch->prof.doios_single++;\r\nif (rc != 0) {\r\nfsm_deltimer(&ch->timer);\r\nctcm_ccw_check_rc(ch, rc, "single skb TX");\r\nif (ccw_idx == 3)\r\nskb_dequeue_tail(&ch->io_queue);\r\nskb_pull(skb, LL_HEADER_LENGTH + 2);\r\n} else if (ccw_idx == 0) {\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\npriv->stats.tx_packets++;\r\npriv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;\r\n}\r\ndone:\r\nctcm_clear_busy(ch->netdev);\r\nreturn rc;\r\n}\r\nstatic void ctcmpc_send_sweep_req(struct channel *rch)\r\n{\r\nstruct net_device *dev = rch->netdev;\r\nstruct ctcm_priv *priv;\r\nstruct mpc_group *grp;\r\nstruct th_sweep *header;\r\nstruct sk_buff *sweep_skb;\r\nstruct channel *ch;\r\npriv = dev->ml_priv;\r\ngrp = priv->mpcg;\r\nch = priv->channel[CTCM_WRITE];\r\nif (grp->in_sweep == 0) {\r\ngrp->in_sweep = 1;\r\ngrp->sweep_rsp_pend_num = grp->active_channels[CTCM_READ];\r\ngrp->sweep_req_pend_num = grp->active_channels[CTCM_READ];\r\n}\r\nsweep_skb = __dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC|GFP_DMA);\r\nif (sweep_skb == NULL) {\r\ngoto nomem;\r\n}\r\nheader = kmalloc(TH_SWEEP_LENGTH, gfp_type());\r\nif (!header) {\r\ndev_kfree_skb_any(sweep_skb);\r\ngoto nomem;\r\n}\r\nheader->th.th_seg = 0x00 ;\r\nheader->th.th_ch_flag = TH_SWEEP_REQ;\r\nheader->th.th_blk_flag = 0x00;\r\nheader->th.th_is_xid = 0x00;\r\nheader->th.th_seq_num = 0x00;\r\nheader->sw.th_last_seq = ch->th_seq_num;\r\nmemcpy(skb_put(sweep_skb, TH_SWEEP_LENGTH), header, TH_SWEEP_LENGTH);\r\nkfree(header);\r\nnetif_trans_update(dev);\r\nskb_queue_tail(&ch->sweep_queue, sweep_skb);\r\nfsm_addtimer(&ch->sweep_timer, 100, CTC_EVENT_RSWEEP_TIMER, ch);\r\nreturn;\r\nnomem:\r\ngrp->in_sweep = 0;\r\nctcm_clear_busy(dev);\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\nreturn;\r\n}\r\nstatic int ctcmpc_transmit_skb(struct channel *ch, struct sk_buff *skb)\r\n{\r\nstruct pdu *p_header;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct th_header *header;\r\nstruct sk_buff *nskb;\r\nint rc = 0;\r\nint ccw_idx;\r\nunsigned long hi;\r\nunsigned long saveflags = 0;\r\nCTCM_PR_DEBUG("Enter %s: %s, cp=%i ch=0x%p id=%s state=%s\n",\r\n__func__, dev->name, smp_processor_id(), ch,\r\nch->id, fsm_getstate_str(ch->fsm));\r\nif ((fsm_getstate(ch->fsm) != CTC_STATE_TXIDLE) || grp->in_sweep) {\r\nspin_lock_irqsave(&ch->collect_lock, saveflags);\r\natomic_inc(&skb->users);\r\np_header = kmalloc(PDU_HEADER_LENGTH, gfp_type());\r\nif (!p_header) {\r\nspin_unlock_irqrestore(&ch->collect_lock, saveflags);\r\ngoto nomem_exit;\r\n}\r\np_header->pdu_offset = skb->len;\r\np_header->pdu_proto = 0x01;\r\np_header->pdu_flag = 0x00;\r\nif (skb->protocol == ntohs(ETH_P_SNAP)) {\r\np_header->pdu_flag |= PDU_FIRST | PDU_CNTL;\r\n} else {\r\np_header->pdu_flag |= PDU_FIRST;\r\n}\r\np_header->pdu_seq = 0;\r\nmemcpy(skb_push(skb, PDU_HEADER_LENGTH), p_header,\r\nPDU_HEADER_LENGTH);\r\nCTCM_PR_DEBUG("%s(%s): Put on collect_q - skb len: %04x \n"\r\n"pdu header and data for up to 32 bytes:\n",\r\n__func__, dev->name, skb->len);\r\nCTCM_D3_DUMP((char *)skb->data, min_t(int, 32, skb->len));\r\nskb_queue_tail(&ch->collect_queue, skb);\r\nch->collect_len += skb->len;\r\nkfree(p_header);\r\nspin_unlock_irqrestore(&ch->collect_lock, saveflags);\r\ngoto done;\r\n}\r\natomic_inc(&skb->users);\r\nhi = ((unsigned long)skb->tail + TH_HEADER_LENGTH) >> 31;\r\nif (hi) {\r\nnskb = __dev_alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);\r\nif (!nskb) {\r\ngoto nomem_exit;\r\n} else {\r\nmemcpy(skb_put(nskb, skb->len), skb->data, skb->len);\r\natomic_inc(&nskb->users);\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_irq(skb);\r\nskb = nskb;\r\n}\r\n}\r\np_header = kmalloc(PDU_HEADER_LENGTH, gfp_type());\r\nif (!p_header)\r\ngoto nomem_exit;\r\np_header->pdu_offset = skb->len;\r\np_header->pdu_proto = 0x01;\r\np_header->pdu_flag = 0x00;\r\np_header->pdu_seq = 0;\r\nif (skb->protocol == ntohs(ETH_P_SNAP)) {\r\np_header->pdu_flag |= PDU_FIRST | PDU_CNTL;\r\n} else {\r\np_header->pdu_flag |= PDU_FIRST;\r\n}\r\nmemcpy(skb_push(skb, PDU_HEADER_LENGTH), p_header, PDU_HEADER_LENGTH);\r\nkfree(p_header);\r\nif (ch->collect_len > 0) {\r\nspin_lock_irqsave(&ch->collect_lock, saveflags);\r\nskb_queue_tail(&ch->collect_queue, skb);\r\nch->collect_len += skb->len;\r\nskb = skb_dequeue(&ch->collect_queue);\r\nch->collect_len -= skb->len;\r\nspin_unlock_irqrestore(&ch->collect_lock, saveflags);\r\n}\r\np_header = (struct pdu *)skb->data;\r\np_header->pdu_flag |= PDU_LAST;\r\nch->prof.txlen += skb->len - PDU_HEADER_LENGTH;\r\nheader = kmalloc(TH_HEADER_LENGTH, gfp_type());\r\nif (!header)\r\ngoto nomem_exit;\r\nheader->th_seg = 0x00;\r\nheader->th_ch_flag = TH_HAS_PDU;\r\nheader->th_blk_flag = 0x00;\r\nheader->th_is_xid = 0x00;\r\nch->th_seq_num++;\r\nheader->th_seq_num = ch->th_seq_num;\r\nCTCM_PR_DBGDATA("%s(%s) ToVTAM_th_seq= %08x\n" ,\r\n__func__, dev->name, ch->th_seq_num);\r\nmemcpy(skb_push(skb, TH_HEADER_LENGTH), header, TH_HEADER_LENGTH);\r\nkfree(header);\r\nCTCM_PR_DBGDATA("%s(%s): skb len: %04x\n - pdu header and data for "\r\n"up to 32 bytes sent to vtam:\n",\r\n__func__, dev->name, skb->len);\r\nCTCM_D3_DUMP((char *)skb->data, min_t(int, 32, skb->len));\r\nch->ccw[4].count = skb->len;\r\nif (set_normalized_cda(&ch->ccw[4], skb->data)) {\r\nif (ctcm_checkalloc_buffer(ch)) {\r\ngoto nomem_exit;\r\n}\r\nskb_reset_tail_pointer(ch->trans_skb);\r\nch->trans_skb->len = 0;\r\nch->ccw[1].count = skb->len;\r\nmemcpy(skb_put(ch->trans_skb, skb->len), skb->data, skb->len);\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_irq(skb);\r\nccw_idx = 0;\r\nCTCM_PR_DBGDATA("%s(%s): trans_skb len: %04x\n"\r\n"up to 32 bytes sent to vtam:\n",\r\n__func__, dev->name, ch->trans_skb->len);\r\nCTCM_D3_DUMP((char *)ch->trans_skb->data,\r\nmin_t(int, 32, ch->trans_skb->len));\r\n} else {\r\nskb_queue_tail(&ch->io_queue, skb);\r\nccw_idx = 3;\r\n}\r\nch->retry = 0;\r\nfsm_newstate(ch->fsm, CTC_STATE_TX);\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\r\nif (do_debug_ccw)\r\nctcmpc_dumpit((char *)&ch->ccw[ccw_idx],\r\nsizeof(struct ccw1) * 3);\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\nch->prof.send_stamp = jiffies;\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[ccw_idx],\r\n(unsigned long)ch, 0xff, 0);\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (ccw_idx == 3)\r\nch->prof.doios_single++;\r\nif (rc != 0) {\r\nfsm_deltimer(&ch->timer);\r\nctcm_ccw_check_rc(ch, rc, "single skb TX");\r\nif (ccw_idx == 3)\r\nskb_dequeue_tail(&ch->io_queue);\r\n} else if (ccw_idx == 0) {\r\npriv->stats.tx_packets++;\r\npriv->stats.tx_bytes += skb->len - TH_HEADER_LENGTH;\r\n}\r\nif (ch->th_seq_num > 0xf0000000)\r\nctcmpc_send_sweep_req(ch);\r\ngoto done;\r\nnomem_exit:\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_CRIT,\r\n"%s(%s): MEMORY allocation ERROR\n",\r\nCTCM_FUNTAIL, ch->id);\r\nrc = -ENOMEM;\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_any(skb);\r\nfsm_event(priv->mpcg->fsm, MPCG_EVENT_INOP, dev);\r\ndone:\r\nCTCM_PR_DEBUG("Exit %s(%s)\n", __func__, dev->name);\r\nreturn rc;\r\n}\r\nstatic int ctcm_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nif (skb == NULL) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): NULL sk_buff passed",\r\nCTCM_FUNTAIL, dev->name);\r\npriv->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb_headroom(skb) < (LL_HEADER_LENGTH + 2)) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): Got sk_buff with head room < %ld bytes",\r\nCTCM_FUNTAIL, dev->name, LL_HEADER_LENGTH + 2);\r\ndev_kfree_skb(skb);\r\npriv->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (fsm_getstate(priv->fsm) != DEV_STATE_RUNNING) {\r\nfsm_event(priv->fsm, DEV_EVENT_START, dev);\r\ndev_kfree_skb(skb);\r\npriv->stats.tx_dropped++;\r\npriv->stats.tx_errors++;\r\npriv->stats.tx_carrier_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (ctcm_test_and_set_busy(dev))\r\nreturn NETDEV_TX_BUSY;\r\nnetif_trans_update(dev);\r\nif (ctcm_transmit_skb(priv->channel[CTCM_WRITE], skb) != 0)\r\nreturn NETDEV_TX_BUSY;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ctcmpc_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint len = 0;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct sk_buff *newskb = NULL;\r\nif (skb == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): NULL sk_buff passed",\r\nCTCM_FUNTAIL, dev->name);\r\npriv->stats.tx_dropped++;\r\ngoto done;\r\n}\r\nif (skb_headroom(skb) < (TH_HEADER_LENGTH + PDU_HEADER_LENGTH)) {\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ERROR,\r\n"%s(%s): Got sk_buff with head room < %ld bytes",\r\nCTCM_FUNTAIL, dev->name,\r\nTH_HEADER_LENGTH + PDU_HEADER_LENGTH);\r\nCTCM_D3_DUMP((char *)skb->data, min_t(int, 32, skb->len));\r\nlen = skb->len + TH_HEADER_LENGTH + PDU_HEADER_LENGTH;\r\nnewskb = __dev_alloc_skb(len, gfp_type() | GFP_DMA);\r\nif (!newskb) {\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ERROR,\r\n"%s: %s: __dev_alloc_skb failed",\r\n__func__, dev->name);\r\ndev_kfree_skb_any(skb);\r\npriv->stats.tx_dropped++;\r\npriv->stats.tx_errors++;\r\npriv->stats.tx_carrier_errors++;\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngoto done;\r\n}\r\nnewskb->protocol = skb->protocol;\r\nskb_reserve(newskb, TH_HEADER_LENGTH + PDU_HEADER_LENGTH);\r\nmemcpy(skb_put(newskb, skb->len), skb->data, skb->len);\r\ndev_kfree_skb_any(skb);\r\nskb = newskb;\r\n}\r\nif ((fsm_getstate(priv->fsm) != DEV_STATE_RUNNING) ||\r\n(fsm_getstate(grp->fsm) < MPCG_STATE_XID2INITW)) {\r\ndev_kfree_skb_any(skb);\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): inactive MPCGROUP - dropped",\r\nCTCM_FUNTAIL, dev->name);\r\npriv->stats.tx_dropped++;\r\npriv->stats.tx_errors++;\r\npriv->stats.tx_carrier_errors++;\r\ngoto done;\r\n}\r\nif (ctcm_test_and_set_busy(dev)) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): device busy - dropped",\r\nCTCM_FUNTAIL, dev->name);\r\ndev_kfree_skb_any(skb);\r\npriv->stats.tx_dropped++;\r\npriv->stats.tx_errors++;\r\npriv->stats.tx_carrier_errors++;\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngoto done;\r\n}\r\nnetif_trans_update(dev);\r\nif (ctcmpc_transmit_skb(priv->channel[CTCM_WRITE], skb) != 0) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): device error - dropped",\r\nCTCM_FUNTAIL, dev->name);\r\ndev_kfree_skb_any(skb);\r\npriv->stats.tx_dropped++;\r\npriv->stats.tx_errors++;\r\npriv->stats.tx_carrier_errors++;\r\nctcm_clear_busy(dev);\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngoto done;\r\n}\r\nctcm_clear_busy(dev);\r\ndone:\r\nif (do_debug)\r\nMPC_DBF_DEV_NAME(TRACE, dev, "exit");\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ctcm_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct ctcm_priv *priv;\r\nint max_bufsize;\r\nif (new_mtu < 576 || new_mtu > 65527)\r\nreturn -EINVAL;\r\npriv = dev->ml_priv;\r\nmax_bufsize = priv->channel[CTCM_READ]->max_bufsize;\r\nif (IS_MPC(priv)) {\r\nif (new_mtu > max_bufsize - TH_HEADER_LENGTH)\r\nreturn -EINVAL;\r\ndev->hard_header_len = TH_HEADER_LENGTH + PDU_HEADER_LENGTH;\r\n} else {\r\nif (new_mtu > max_bufsize - LL_HEADER_LENGTH - 2)\r\nreturn -EINVAL;\r\ndev->hard_header_len = LL_HEADER_LENGTH + 2;\r\n}\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *ctcm_stats(struct net_device *dev)\r\n{\r\nreturn &((struct ctcm_priv *)dev->ml_priv)->stats;\r\n}\r\nstatic void ctcm_free_netdevice(struct net_device *dev)\r\n{\r\nstruct ctcm_priv *priv;\r\nstruct mpc_group *grp;\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\r\n"%s(%s)", CTCM_FUNTAIL, dev->name);\r\npriv = dev->ml_priv;\r\nif (priv) {\r\ngrp = priv->mpcg;\r\nif (grp) {\r\nif (grp->fsm)\r\nkfree_fsm(grp->fsm);\r\nif (grp->xid_skb)\r\ndev_kfree_skb(grp->xid_skb);\r\nif (grp->rcvd_xid_skb)\r\ndev_kfree_skb(grp->rcvd_xid_skb);\r\ntasklet_kill(&grp->mpc_tasklet2);\r\nkfree(grp);\r\npriv->mpcg = NULL;\r\n}\r\nif (priv->fsm) {\r\nkfree_fsm(priv->fsm);\r\npriv->fsm = NULL;\r\n}\r\nkfree(priv->xid);\r\npriv->xid = NULL;\r\n}\r\n#ifdef MODULE\r\nfree_netdev(dev);\r\n#endif\r\n}\r\nvoid static ctcm_dev_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_SLIP;\r\ndev->tx_queue_len = 100;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\n}\r\nstatic struct net_device *ctcm_init_netdevice(struct ctcm_priv *priv)\r\n{\r\nstruct net_device *dev;\r\nstruct mpc_group *grp;\r\nif (!priv)\r\nreturn NULL;\r\nif (IS_MPC(priv))\r\ndev = alloc_netdev(0, MPC_DEVICE_GENE, NET_NAME_UNKNOWN,\r\nctcm_dev_setup);\r\nelse\r\ndev = alloc_netdev(0, CTC_DEVICE_GENE, NET_NAME_UNKNOWN,\r\nctcm_dev_setup);\r\nif (!dev) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_CRIT,\r\n"%s: MEMORY allocation ERROR",\r\nCTCM_FUNTAIL);\r\nreturn NULL;\r\n}\r\ndev->ml_priv = priv;\r\npriv->fsm = init_fsm("ctcmdev", dev_state_names, dev_event_names,\r\nCTCM_NR_DEV_STATES, CTCM_NR_DEV_EVENTS,\r\ndev_fsm, dev_fsm_len, GFP_KERNEL);\r\nif (priv->fsm == NULL) {\r\nCTCMY_DBF_DEV(SETUP, dev, "init_fsm error");\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nfsm_newstate(priv->fsm, DEV_STATE_STOPPED);\r\nfsm_settimer(priv->fsm, &priv->restart_timer);\r\nif (IS_MPC(priv)) {\r\ngrp = ctcmpc_init_mpc_group(priv);\r\nif (grp == NULL) {\r\nMPC_DBF_DEV(SETUP, dev, "init_mpc_group error");\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\ntasklet_init(&grp->mpc_tasklet2,\r\nmpc_group_ready, (unsigned long)dev);\r\ndev->mtu = MPC_BUFSIZE_DEFAULT -\r\nTH_HEADER_LENGTH - PDU_HEADER_LENGTH;\r\ndev->netdev_ops = &ctcm_mpc_netdev_ops;\r\ndev->hard_header_len = TH_HEADER_LENGTH + PDU_HEADER_LENGTH;\r\npriv->buffer_size = MPC_BUFSIZE_DEFAULT;\r\n} else {\r\ndev->mtu = CTCM_BUFSIZE_DEFAULT - LL_HEADER_LENGTH - 2;\r\ndev->netdev_ops = &ctcm_netdev_ops;\r\ndev->hard_header_len = LL_HEADER_LENGTH + 2;\r\n}\r\nCTCMY_DBF_DEV(SETUP, dev, "finished");\r\nreturn dev;\r\n}\r\nstatic void ctcm_irq_handler(struct ccw_device *cdev,\r\nunsigned long intparm, struct irb *irb)\r\n{\r\nstruct channel *ch;\r\nstruct net_device *dev;\r\nstruct ctcm_priv *priv;\r\nstruct ccwgroup_device *cgdev;\r\nint cstat;\r\nint dstat;\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\r\n"Enter %s(%s)", CTCM_FUNTAIL, dev_name(&cdev->dev));\r\nif (ctcm_check_irb_error(cdev, irb))\r\nreturn;\r\ncgdev = dev_get_drvdata(&cdev->dev);\r\ncstat = irb->scsw.cmd.cstat;\r\ndstat = irb->scsw.cmd.dstat;\r\nif (cgdev == NULL) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_ERROR,\r\n"%s(%s) unsolicited irq: c-%02x d-%02x\n",\r\nCTCM_FUNTAIL, dev_name(&cdev->dev), cstat, dstat);\r\ndev_warn(&cdev->dev,\r\n"The adapter received a non-specific IRQ\n");\r\nreturn;\r\n}\r\npriv = dev_get_drvdata(&cgdev->dev);\r\nif (priv->channel[CTCM_READ]->cdev == cdev)\r\nch = priv->channel[CTCM_READ];\r\nelse if (priv->channel[CTCM_WRITE]->cdev == cdev)\r\nch = priv->channel[CTCM_WRITE];\r\nelse {\r\ndev_err(&cdev->dev,\r\n"%s: Internal error: Can't determine channel for "\r\n"interrupt device %s\n",\r\n__func__, dev_name(&cdev->dev));\r\nreturn;\r\n}\r\ndev = ch->netdev;\r\nif (dev == NULL) {\r\ndev_err(&cdev->dev,\r\n"%s Internal error: net_device is NULL, ch = 0x%p\n",\r\n__func__, ch);\r\nreturn;\r\n}\r\nmemcpy(ch->irb, irb, sizeof(struct irb));\r\nif (irb->scsw.cmd.cstat) {\r\nfsm_event(ch->fsm, CTC_EVENT_SC_UNKNOWN, ch);\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\r\n"%s(%s): sub-ch check %s: cs=%02x ds=%02x",\r\nCTCM_FUNTAIL, dev->name, ch->id, cstat, dstat);\r\ndev_warn(&cdev->dev,\r\n"A check occurred on the subchannel\n");\r\nreturn;\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {\r\nif ((irb->ecw[0] & ch->sense_rc) == 0)\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_WARN,\r\n"%s(%s): sense=%02x, ds=%02x",\r\nCTCM_FUNTAIL, ch->id, irb->ecw[0], dstat);\r\nccw_unit_check(ch, irb->ecw[0]);\r\nreturn;\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_BUSY) {\r\nif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION)\r\nfsm_event(ch->fsm, CTC_EVENT_ATTNBUSY, ch);\r\nelse\r\nfsm_event(ch->fsm, CTC_EVENT_BUSY, ch);\r\nreturn;\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\r\nfsm_event(ch->fsm, CTC_EVENT_ATTN, ch);\r\nreturn;\r\n}\r\nif ((irb->scsw.cmd.stctl & SCSW_STCTL_SEC_STATUS) ||\r\n(irb->scsw.cmd.stctl == SCSW_STCTL_STATUS_PEND) ||\r\n(irb->scsw.cmd.stctl ==\r\n(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))\r\nfsm_event(ch->fsm, CTC_EVENT_FINSTAT, ch);\r\nelse\r\nfsm_event(ch->fsm, CTC_EVENT_IRQ, ch);\r\n}\r\nstatic int ctcm_probe_device(struct ccwgroup_device *cgdev)\r\n{\r\nstruct ctcm_priv *priv;\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\r\n"%s %p",\r\n__func__, cgdev);\r\nif (!get_device(&cgdev->dev))\r\nreturn -ENODEV;\r\npriv = kzalloc(sizeof(struct ctcm_priv), GFP_KERNEL);\r\nif (!priv) {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s: memory allocation failure",\r\nCTCM_FUNTAIL);\r\nput_device(&cgdev->dev);\r\nreturn -ENOMEM;\r\n}\r\npriv->buffer_size = CTCM_BUFSIZE_DEFAULT;\r\ncgdev->cdev[0]->handler = ctcm_irq_handler;\r\ncgdev->cdev[1]->handler = ctcm_irq_handler;\r\ndev_set_drvdata(&cgdev->dev, priv);\r\ncgdev->dev.type = &ctcm_devtype;\r\nreturn 0;\r\n}\r\nstatic int add_channel(struct ccw_device *cdev, enum ctcm_channel_types type,\r\nstruct ctcm_priv *priv)\r\n{\r\nstruct channel **c = &channels;\r\nstruct channel *ch;\r\nint ccw_num;\r\nint rc = 0;\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\r\n"%s(%s), type %d, proto %d",\r\n__func__, dev_name(&cdev->dev), type, priv->protocol);\r\nch = kzalloc(sizeof(struct channel), GFP_KERNEL);\r\nif (ch == NULL)\r\nreturn -ENOMEM;\r\nch->protocol = priv->protocol;\r\nif (IS_MPC(priv)) {\r\nch->discontact_th = kzalloc(TH_HEADER_LENGTH, gfp_type());\r\nif (ch->discontact_th == NULL)\r\ngoto nomem_return;\r\nch->discontact_th->th_blk_flag = TH_DISCONTACT;\r\ntasklet_init(&ch->ch_disc_tasklet,\r\nmpc_action_send_discontact, (unsigned long)ch);\r\ntasklet_init(&ch->ch_tasklet, ctcmpc_bh, (unsigned long)ch);\r\nch->max_bufsize = (MPC_BUFSIZE_DEFAULT - 35);\r\nccw_num = 17;\r\n} else\r\nccw_num = 8;\r\nch->ccw = kzalloc(ccw_num * sizeof(struct ccw1), GFP_KERNEL | GFP_DMA);\r\nif (ch->ccw == NULL)\r\ngoto nomem_return;\r\nch->cdev = cdev;\r\nsnprintf(ch->id, CTCM_ID_SIZE, "ch-%s", dev_name(&cdev->dev));\r\nch->type = type;\r\nch->ccw[6].cmd_code = CCW_CMD_SET_EXTENDED;\r\nch->ccw[6].flags = CCW_FLAG_SLI;\r\nch->ccw[7].cmd_code = CCW_CMD_NOOP;\r\nch->ccw[7].flags = CCW_FLAG_SLI;\r\nif (IS_MPC(priv)) {\r\nch->ccw[15].cmd_code = CCW_CMD_WRITE;\r\nch->ccw[15].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[15].count = TH_HEADER_LENGTH;\r\nch->ccw[15].cda = virt_to_phys(ch->discontact_th);\r\nch->ccw[16].cmd_code = CCW_CMD_NOOP;\r\nch->ccw[16].flags = CCW_FLAG_SLI;\r\nch->fsm = init_fsm(ch->id, ctc_ch_state_names,\r\nctc_ch_event_names, CTC_MPC_NR_STATES,\r\nCTC_MPC_NR_EVENTS, ctcmpc_ch_fsm,\r\nmpc_ch_fsm_len, GFP_KERNEL);\r\n} else {\r\nch->fsm = init_fsm(ch->id, ctc_ch_state_names,\r\nctc_ch_event_names, CTC_NR_STATES,\r\nCTC_NR_EVENTS, ch_fsm,\r\nch_fsm_len, GFP_KERNEL);\r\n}\r\nif (ch->fsm == NULL)\r\ngoto nomem_return;\r\nfsm_newstate(ch->fsm, CTC_STATE_IDLE);\r\nch->irb = kzalloc(sizeof(struct irb), GFP_KERNEL);\r\nif (ch->irb == NULL)\r\ngoto nomem_return;\r\nwhile (*c && ctcm_less_than((*c)->id, ch->id))\r\nc = &(*c)->next;\r\nif (*c && (!strncmp((*c)->id, ch->id, CTCM_ID_SIZE))) {\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\r\n"%s (%s) already in list, using old entry",\r\n__func__, (*c)->id);\r\ngoto free_return;\r\n}\r\nspin_lock_init(&ch->collect_lock);\r\nfsm_settimer(ch->fsm, &ch->timer);\r\nskb_queue_head_init(&ch->io_queue);\r\nskb_queue_head_init(&ch->collect_queue);\r\nif (IS_MPC(priv)) {\r\nfsm_settimer(ch->fsm, &ch->sweep_timer);\r\nskb_queue_head_init(&ch->sweep_queue);\r\n}\r\nch->next = *c;\r\n*c = ch;\r\nreturn 0;\r\nnomem_return:\r\nrc = -ENOMEM;\r\nfree_return:\r\nkfree(ch->ccw);\r\nkfree(ch->discontact_th);\r\nkfree_fsm(ch->fsm);\r\nkfree(ch->irb);\r\nkfree(ch);\r\nreturn rc;\r\n}\r\nstatic enum ctcm_channel_types get_channel_type(struct ccw_device_id *id)\r\n{\r\nenum ctcm_channel_types type;\r\ntype = (enum ctcm_channel_types)id->driver_info;\r\nif (type == ctcm_channel_type_ficon)\r\ntype = ctcm_channel_type_escon;\r\nreturn type;\r\n}\r\nstatic int ctcm_new_device(struct ccwgroup_device *cgdev)\r\n{\r\nchar read_id[CTCM_ID_SIZE];\r\nchar write_id[CTCM_ID_SIZE];\r\nint direction;\r\nenum ctcm_channel_types type;\r\nstruct ctcm_priv *priv;\r\nstruct net_device *dev;\r\nstruct ccw_device *cdev0;\r\nstruct ccw_device *cdev1;\r\nstruct channel *readc;\r\nstruct channel *writec;\r\nint ret;\r\nint result;\r\npriv = dev_get_drvdata(&cgdev->dev);\r\nif (!priv) {\r\nresult = -ENODEV;\r\ngoto out_err_result;\r\n}\r\ncdev0 = cgdev->cdev[0];\r\ncdev1 = cgdev->cdev[1];\r\ntype = get_channel_type(&cdev0->id);\r\nsnprintf(read_id, CTCM_ID_SIZE, "ch-%s", dev_name(&cdev0->dev));\r\nsnprintf(write_id, CTCM_ID_SIZE, "ch-%s", dev_name(&cdev1->dev));\r\nret = add_channel(cdev0, type, priv);\r\nif (ret) {\r\nresult = ret;\r\ngoto out_err_result;\r\n}\r\nret = add_channel(cdev1, type, priv);\r\nif (ret) {\r\nresult = ret;\r\ngoto out_remove_channel1;\r\n}\r\nret = ccw_device_set_online(cdev0);\r\nif (ret != 0) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\r\n"%s(%s) set_online rc=%d",\r\nCTCM_FUNTAIL, read_id, ret);\r\nresult = -EIO;\r\ngoto out_remove_channel2;\r\n}\r\nret = ccw_device_set_online(cdev1);\r\nif (ret != 0) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\r\n"%s(%s) set_online rc=%d",\r\nCTCM_FUNTAIL, write_id, ret);\r\nresult = -EIO;\r\ngoto out_ccw1;\r\n}\r\ndev = ctcm_init_netdevice(priv);\r\nif (dev == NULL) {\r\nresult = -ENODEV;\r\ngoto out_ccw2;\r\n}\r\nfor (direction = CTCM_READ; direction <= CTCM_WRITE; direction++) {\r\npriv->channel[direction] =\r\nchannel_get(type, direction == CTCM_READ ?\r\nread_id : write_id, direction);\r\nif (priv->channel[direction] == NULL) {\r\nif (direction == CTCM_WRITE)\r\nchannel_free(priv->channel[CTCM_READ]);\r\ngoto out_dev;\r\n}\r\npriv->channel[direction]->netdev = dev;\r\npriv->channel[direction]->protocol = priv->protocol;\r\npriv->channel[direction]->max_bufsize = priv->buffer_size;\r\n}\r\nSET_NETDEV_DEV(dev, &cgdev->dev);\r\nif (register_netdev(dev)) {\r\nresult = -ENODEV;\r\ngoto out_dev;\r\n}\r\nstrlcpy(priv->fsm->name, dev->name, sizeof(priv->fsm->name));\r\ndev_info(&dev->dev,\r\n"setup OK : r/w = %s/%s, protocol : %d\n",\r\npriv->channel[CTCM_READ]->id,\r\npriv->channel[CTCM_WRITE]->id, priv->protocol);\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\r\n"setup(%s) OK : r/w = %s/%s, protocol : %d", dev->name,\r\npriv->channel[CTCM_READ]->id,\r\npriv->channel[CTCM_WRITE]->id, priv->protocol);\r\nreturn 0;\r\nout_dev:\r\nctcm_free_netdevice(dev);\r\nout_ccw2:\r\nccw_device_set_offline(cgdev->cdev[1]);\r\nout_ccw1:\r\nccw_device_set_offline(cgdev->cdev[0]);\r\nout_remove_channel2:\r\nreadc = channel_get(type, read_id, CTCM_READ);\r\nchannel_remove(readc);\r\nout_remove_channel1:\r\nwritec = channel_get(type, write_id, CTCM_WRITE);\r\nchannel_remove(writec);\r\nout_err_result:\r\nreturn result;\r\n}\r\nstatic int ctcm_shutdown_device(struct ccwgroup_device *cgdev)\r\n{\r\nstruct ctcm_priv *priv;\r\nstruct net_device *dev;\r\npriv = dev_get_drvdata(&cgdev->dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\nif (priv->channel[CTCM_READ]) {\r\ndev = priv->channel[CTCM_READ]->netdev;\r\nCTCM_DBF_DEV(SETUP, dev, "");\r\nctcm_close(dev);\r\ndev->flags &= ~IFF_RUNNING;\r\nchannel_free(priv->channel[CTCM_READ]);\r\n} else\r\ndev = NULL;\r\nif (priv->channel[CTCM_WRITE])\r\nchannel_free(priv->channel[CTCM_WRITE]);\r\nif (dev) {\r\nunregister_netdev(dev);\r\nctcm_free_netdevice(dev);\r\n}\r\nif (priv->fsm)\r\nkfree_fsm(priv->fsm);\r\nccw_device_set_offline(cgdev->cdev[1]);\r\nccw_device_set_offline(cgdev->cdev[0]);\r\nchannel_remove(priv->channel[CTCM_READ]);\r\nchannel_remove(priv->channel[CTCM_WRITE]);\r\npriv->channel[CTCM_READ] = priv->channel[CTCM_WRITE] = NULL;\r\nreturn 0;\r\n}\r\nstatic void ctcm_remove_device(struct ccwgroup_device *cgdev)\r\n{\r\nstruct ctcm_priv *priv = dev_get_drvdata(&cgdev->dev);\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO,\r\n"removing device %p, proto : %d",\r\ncgdev, priv->protocol);\r\nif (cgdev->state == CCWGROUP_ONLINE)\r\nctcm_shutdown_device(cgdev);\r\ndev_set_drvdata(&cgdev->dev, NULL);\r\nkfree(priv);\r\nput_device(&cgdev->dev);\r\n}\r\nstatic int ctcm_pm_suspend(struct ccwgroup_device *gdev)\r\n{\r\nstruct ctcm_priv *priv = dev_get_drvdata(&gdev->dev);\r\nif (gdev->state == CCWGROUP_OFFLINE)\r\nreturn 0;\r\nnetif_device_detach(priv->channel[CTCM_READ]->netdev);\r\nctcm_close(priv->channel[CTCM_READ]->netdev);\r\nif (!wait_event_timeout(priv->fsm->wait_q,\r\nfsm_getstate(priv->fsm) == DEV_STATE_STOPPED, CTCM_TIME_5_SEC)) {\r\nnetif_device_attach(priv->channel[CTCM_READ]->netdev);\r\nreturn -EBUSY;\r\n}\r\nccw_device_set_offline(gdev->cdev[1]);\r\nccw_device_set_offline(gdev->cdev[0]);\r\nreturn 0;\r\n}\r\nstatic int ctcm_pm_resume(struct ccwgroup_device *gdev)\r\n{\r\nstruct ctcm_priv *priv = dev_get_drvdata(&gdev->dev);\r\nint rc;\r\nif (gdev->state == CCWGROUP_OFFLINE)\r\nreturn 0;\r\nrc = ccw_device_set_online(gdev->cdev[1]);\r\nif (rc)\r\ngoto err_out;\r\nrc = ccw_device_set_online(gdev->cdev[0]);\r\nif (rc)\r\ngoto err_out;\r\nctcm_open(priv->channel[CTCM_READ]->netdev);\r\nerr_out:\r\nnetif_device_attach(priv->channel[CTCM_READ]->netdev);\r\nreturn rc;\r\n}\r\nstatic ssize_t ctcm_driver_group_store(struct device_driver *ddrv,\r\nconst char *buf, size_t count)\r\n{\r\nint err;\r\nerr = ccwgroup_create_dev(ctcm_root_dev, &ctcm_group_driver, 2, buf);\r\nreturn err ? err : count;\r\n}\r\nstatic void __exit ctcm_exit(void)\r\n{\r\nccwgroup_driver_unregister(&ctcm_group_driver);\r\nccw_driver_unregister(&ctcm_ccw_driver);\r\nroot_device_unregister(ctcm_root_dev);\r\nctcm_unregister_dbf_views();\r\npr_info("CTCM driver unloaded\n");\r\n}\r\nstatic void print_banner(void)\r\n{\r\npr_info("CTCM driver initialized\n");\r\n}\r\nstatic int __init ctcm_init(void)\r\n{\r\nint ret;\r\nchannels = NULL;\r\nret = ctcm_register_dbf_views();\r\nif (ret)\r\ngoto out_err;\r\nctcm_root_dev = root_device_register("ctcm");\r\nret = PTR_ERR_OR_ZERO(ctcm_root_dev);\r\nif (ret)\r\ngoto register_err;\r\nret = ccw_driver_register(&ctcm_ccw_driver);\r\nif (ret)\r\ngoto ccw_err;\r\nctcm_group_driver.driver.groups = ctcm_drv_attr_groups;\r\nret = ccwgroup_driver_register(&ctcm_group_driver);\r\nif (ret)\r\ngoto ccwgroup_err;\r\nprint_banner();\r\nreturn 0;\r\nccwgroup_err:\r\nccw_driver_unregister(&ctcm_ccw_driver);\r\nccw_err:\r\nroot_device_unregister(ctcm_root_dev);\r\nregister_err:\r\nctcm_unregister_dbf_views();\r\nout_err:\r\npr_err("%s / Initializing the ctcm device driver failed, ret = %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}
