static int sha1_ce_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nif (!may_use_simd() ||\r\n(sctx->count % SHA1_BLOCK_SIZE) + len < SHA1_BLOCK_SIZE)\r\nreturn sha1_update_arm(desc, data, len);\r\nkernel_neon_begin();\r\nsha1_base_do_update(desc, data, len, sha1_ce_transform);\r\nkernel_neon_end();\r\nreturn 0;\r\n}\r\nstatic int sha1_ce_finup(struct shash_desc *desc, const u8 *data,\r\nunsigned int len, u8 *out)\r\n{\r\nif (!may_use_simd())\r\nreturn sha1_finup_arm(desc, data, len, out);\r\nkernel_neon_begin();\r\nif (len)\r\nsha1_base_do_update(desc, data, len, sha1_ce_transform);\r\nsha1_base_do_finalize(desc, sha1_ce_transform);\r\nkernel_neon_end();\r\nreturn sha1_base_finish(desc, out);\r\n}\r\nstatic int sha1_ce_final(struct shash_desc *desc, u8 *out)\r\n{\r\nreturn sha1_ce_finup(desc, NULL, 0, out);\r\n}\r\nstatic int __init sha1_ce_mod_init(void)\r\n{\r\nif (!(elf_hwcap2 & HWCAP2_SHA1))\r\nreturn -ENODEV;\r\nreturn crypto_register_shash(&alg);\r\n}\r\nstatic void __exit sha1_ce_mod_fini(void)\r\n{\r\ncrypto_unregister_shash(&alg);\r\n}
