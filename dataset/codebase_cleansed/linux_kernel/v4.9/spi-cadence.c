static inline u32 cdns_spi_read(struct cdns_spi *xspi, u32 offset)\r\n{\r\nreturn readl_relaxed(xspi->regs + offset);\r\n}\r\nstatic inline void cdns_spi_write(struct cdns_spi *xspi, u32 offset, u32 val)\r\n{\r\nwritel_relaxed(val, xspi->regs + offset);\r\n}\r\nstatic void cdns_spi_init_hw(struct cdns_spi *xspi)\r\n{\r\nu32 ctrl_reg = CDNS_SPI_CR_DEFAULT;\r\nif (xspi->is_decoded_cs)\r\nctrl_reg |= CDNS_SPI_CR_PERI_SEL;\r\ncdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_DISABLE);\r\ncdns_spi_write(xspi, CDNS_SPI_IDR, CDNS_SPI_IXR_ALL);\r\nwhile (cdns_spi_read(xspi, CDNS_SPI_ISR) & CDNS_SPI_IXR_RXNEMTY)\r\ncdns_spi_read(xspi, CDNS_SPI_RXD);\r\ncdns_spi_write(xspi, CDNS_SPI_ISR, CDNS_SPI_IXR_ALL);\r\ncdns_spi_write(xspi, CDNS_SPI_CR, ctrl_reg);\r\ncdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_ENABLE);\r\n}\r\nstatic void cdns_spi_chipselect(struct spi_device *spi, bool is_high)\r\n{\r\nstruct cdns_spi *xspi = spi_master_get_devdata(spi->master);\r\nu32 ctrl_reg;\r\nctrl_reg = cdns_spi_read(xspi, CDNS_SPI_CR);\r\nif (is_high) {\r\nctrl_reg |= CDNS_SPI_CR_SSCTRL;\r\n} else {\r\nctrl_reg &= ~CDNS_SPI_CR_SSCTRL;\r\nif (!(xspi->is_decoded_cs))\r\nctrl_reg |= ((~(CDNS_SPI_SS0 << spi->chip_select)) <<\r\nCDNS_SPI_SS_SHIFT) &\r\nCDNS_SPI_CR_SSCTRL;\r\nelse\r\nctrl_reg |= (spi->chip_select << CDNS_SPI_SS_SHIFT) &\r\nCDNS_SPI_CR_SSCTRL;\r\n}\r\ncdns_spi_write(xspi, CDNS_SPI_CR, ctrl_reg);\r\n}\r\nstatic void cdns_spi_config_clock_mode(struct spi_device *spi)\r\n{\r\nstruct cdns_spi *xspi = spi_master_get_devdata(spi->master);\r\nu32 ctrl_reg, new_ctrl_reg;\r\nnew_ctrl_reg = cdns_spi_read(xspi, CDNS_SPI_CR);\r\nctrl_reg = new_ctrl_reg;\r\nnew_ctrl_reg &= ~(CDNS_SPI_CR_CPHA | CDNS_SPI_CR_CPOL);\r\nif (spi->mode & SPI_CPHA)\r\nnew_ctrl_reg |= CDNS_SPI_CR_CPHA;\r\nif (spi->mode & SPI_CPOL)\r\nnew_ctrl_reg |= CDNS_SPI_CR_CPOL;\r\nif (new_ctrl_reg != ctrl_reg) {\r\ncdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_DISABLE);\r\ncdns_spi_write(xspi, CDNS_SPI_CR, new_ctrl_reg);\r\ncdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_ENABLE);\r\n}\r\n}\r\nstatic void cdns_spi_config_clock_freq(struct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct cdns_spi *xspi = spi_master_get_devdata(spi->master);\r\nu32 ctrl_reg, baud_rate_val;\r\nunsigned long frequency;\r\nfrequency = clk_get_rate(xspi->ref_clk);\r\nctrl_reg = cdns_spi_read(xspi, CDNS_SPI_CR);\r\nif (xspi->speed_hz != transfer->speed_hz) {\r\nbaud_rate_val = CDNS_SPI_BAUD_DIV_MIN;\r\nwhile ((baud_rate_val < CDNS_SPI_BAUD_DIV_MAX) &&\r\n(frequency / (2 << baud_rate_val)) > transfer->speed_hz)\r\nbaud_rate_val++;\r\nctrl_reg &= ~CDNS_SPI_CR_BAUD_DIV;\r\nctrl_reg |= baud_rate_val << CDNS_SPI_BAUD_DIV_SHIFT;\r\nxspi->speed_hz = frequency / (2 << baud_rate_val);\r\n}\r\ncdns_spi_write(xspi, CDNS_SPI_CR, ctrl_reg);\r\n}\r\nstatic int cdns_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct cdns_spi *xspi = spi_master_get_devdata(spi->master);\r\ncdns_spi_config_clock_freq(spi, transfer);\r\ndev_dbg(&spi->dev, "%s, mode %d, %u bits/w, %u clock speed\n",\r\n__func__, spi->mode, spi->bits_per_word,\r\nxspi->speed_hz);\r\nreturn 0;\r\n}\r\nstatic void cdns_spi_fill_tx_fifo(struct cdns_spi *xspi)\r\n{\r\nunsigned long trans_cnt = 0;\r\nwhile ((trans_cnt < CDNS_SPI_FIFO_DEPTH) &&\r\n(xspi->tx_bytes > 0)) {\r\nif (xspi->txbuf)\r\ncdns_spi_write(xspi, CDNS_SPI_TXD, *xspi->txbuf++);\r\nelse\r\ncdns_spi_write(xspi, CDNS_SPI_TXD, 0);\r\nxspi->tx_bytes--;\r\ntrans_cnt++;\r\n}\r\n}\r\nstatic irqreturn_t cdns_spi_irq(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct cdns_spi *xspi = spi_master_get_devdata(master);\r\nu32 intr_status, status;\r\nstatus = IRQ_NONE;\r\nintr_status = cdns_spi_read(xspi, CDNS_SPI_ISR);\r\ncdns_spi_write(xspi, CDNS_SPI_ISR, intr_status);\r\nif (intr_status & CDNS_SPI_IXR_MODF) {\r\ncdns_spi_write(xspi, CDNS_SPI_IDR, CDNS_SPI_IXR_DEFAULT);\r\nspi_finalize_current_transfer(master);\r\nstatus = IRQ_HANDLED;\r\n} else if (intr_status & CDNS_SPI_IXR_TXOW) {\r\nunsigned long trans_cnt;\r\ntrans_cnt = xspi->rx_bytes - xspi->tx_bytes;\r\nwhile (trans_cnt) {\r\nu8 data;\r\ndata = cdns_spi_read(xspi, CDNS_SPI_RXD);\r\nif (xspi->rxbuf)\r\n*xspi->rxbuf++ = data;\r\nxspi->rx_bytes--;\r\ntrans_cnt--;\r\n}\r\nif (xspi->tx_bytes) {\r\ncdns_spi_fill_tx_fifo(xspi);\r\n} else {\r\ncdns_spi_write(xspi, CDNS_SPI_IDR,\r\nCDNS_SPI_IXR_DEFAULT);\r\nspi_finalize_current_transfer(master);\r\n}\r\nstatus = IRQ_HANDLED;\r\n}\r\nreturn status;\r\n}\r\nstatic int cdns_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\ncdns_spi_config_clock_mode(msg->spi);\r\nreturn 0;\r\n}\r\nstatic int cdns_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct cdns_spi *xspi = spi_master_get_devdata(master);\r\nxspi->txbuf = transfer->tx_buf;\r\nxspi->rxbuf = transfer->rx_buf;\r\nxspi->tx_bytes = transfer->len;\r\nxspi->rx_bytes = transfer->len;\r\ncdns_spi_setup_transfer(spi, transfer);\r\ncdns_spi_fill_tx_fifo(xspi);\r\ncdns_spi_write(xspi, CDNS_SPI_IER, CDNS_SPI_IXR_DEFAULT);\r\nreturn transfer->len;\r\n}\r\nstatic int cdns_prepare_transfer_hardware(struct spi_master *master)\r\n{\r\nstruct cdns_spi *xspi = spi_master_get_devdata(master);\r\ncdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int cdns_unprepare_transfer_hardware(struct spi_master *master)\r\n{\r\nstruct cdns_spi *xspi = spi_master_get_devdata(master);\r\ncdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_DISABLE);\r\nreturn 0;\r\n}\r\nstatic int cdns_spi_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0, irq;\r\nstruct spi_master *master;\r\nstruct cdns_spi *xspi;\r\nstruct resource *res;\r\nu32 num_cs;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*xspi));\r\nif (!master)\r\nreturn -ENOMEM;\r\nxspi = spi_master_get_devdata(master);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nplatform_set_drvdata(pdev, master);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nxspi->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(xspi->regs)) {\r\nret = PTR_ERR(xspi->regs);\r\ngoto remove_master;\r\n}\r\nxspi->pclk = devm_clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(xspi->pclk)) {\r\ndev_err(&pdev->dev, "pclk clock not found.\n");\r\nret = PTR_ERR(xspi->pclk);\r\ngoto remove_master;\r\n}\r\nxspi->ref_clk = devm_clk_get(&pdev->dev, "ref_clk");\r\nif (IS_ERR(xspi->ref_clk)) {\r\ndev_err(&pdev->dev, "ref_clk clock not found.\n");\r\nret = PTR_ERR(xspi->ref_clk);\r\ngoto remove_master;\r\n}\r\nret = clk_prepare_enable(xspi->pclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to enable APB clock.\n");\r\ngoto remove_master;\r\n}\r\nret = clk_prepare_enable(xspi->ref_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to enable device clock.\n");\r\ngoto clk_dis_apb;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);\r\npm_runtime_set_active(&pdev->dev);\r\nret = of_property_read_u32(pdev->dev.of_node, "num-cs", &num_cs);\r\nif (ret < 0)\r\nmaster->num_chipselect = CDNS_SPI_DEFAULT_NUM_CS;\r\nelse\r\nmaster->num_chipselect = num_cs;\r\nret = of_property_read_u32(pdev->dev.of_node, "is-decoded-cs",\r\n&xspi->is_decoded_cs);\r\nif (ret < 0)\r\nxspi->is_decoded_cs = 0;\r\ncdns_spi_init_hw(xspi);\r\npm_runtime_mark_last_busy(&pdev->dev);\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "irq number is invalid\n");\r\ngoto clk_dis_all;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, cdns_spi_irq,\r\n0, pdev->name, master);\r\nif (ret != 0) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\ngoto clk_dis_all;\r\n}\r\nmaster->prepare_transfer_hardware = cdns_prepare_transfer_hardware;\r\nmaster->prepare_message = cdns_prepare_message;\r\nmaster->transfer_one = cdns_transfer_one;\r\nmaster->unprepare_transfer_hardware = cdns_unprepare_transfer_hardware;\r\nmaster->set_cs = cdns_spi_chipselect;\r\nmaster->auto_runtime_pm = true;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->max_speed_hz = clk_get_rate(xspi->ref_clk) / 4;\r\nxspi->speed_hz = master->max_speed_hz;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nret = spi_register_master(master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "spi_register_master failed\n");\r\ngoto clk_dis_all;\r\n}\r\nreturn ret;\r\nclk_dis_all:\r\npm_runtime_set_suspended(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(xspi->ref_clk);\r\nclk_dis_apb:\r\nclk_disable_unprepare(xspi->pclk);\r\nremove_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int cdns_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct cdns_spi *xspi = spi_master_get_devdata(master);\r\ncdns_spi_write(xspi, CDNS_SPI_ER, CDNS_SPI_ER_DISABLE);\r\nclk_disable_unprepare(xspi->ref_clk);\r\nclk_disable_unprepare(xspi->pclk);\r\npm_runtime_set_suspended(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nspi_unregister_master(master);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cdns_spi_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nreturn spi_master_suspend(master);\r\n}\r\nstatic int __maybe_unused cdns_spi_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nreturn spi_master_resume(master);\r\n}\r\nstatic int __maybe_unused cnds_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct cdns_spi *xspi = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(xspi->pclk);\r\nif (ret) {\r\ndev_err(dev, "Cannot enable APB clock.\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(xspi->ref_clk);\r\nif (ret) {\r\ndev_err(dev, "Cannot enable device clock.\n");\r\nclk_disable(xspi->pclk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cnds_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct cdns_spi *xspi = spi_master_get_devdata(master);\r\nclk_disable_unprepare(xspi->ref_clk);\r\nclk_disable_unprepare(xspi->pclk);\r\nreturn 0;\r\n}
