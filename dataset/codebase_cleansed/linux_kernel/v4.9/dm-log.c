static struct dm_dirty_log_type *__find_dirty_log_type(const char *name)\r\n{\r\nstruct dm_dirty_log_type *log_type;\r\nlist_for_each_entry(log_type, &_log_types, list)\r\nif (!strcmp(name, log_type->name))\r\nreturn log_type;\r\nreturn NULL;\r\n}\r\nstatic struct dm_dirty_log_type *_get_dirty_log_type(const char *name)\r\n{\r\nstruct dm_dirty_log_type *log_type;\r\nspin_lock(&_lock);\r\nlog_type = __find_dirty_log_type(name);\r\nif (log_type && !try_module_get(log_type->module))\r\nlog_type = NULL;\r\nspin_unlock(&_lock);\r\nreturn log_type;\r\n}\r\nstatic struct dm_dirty_log_type *get_type(const char *type_name)\r\n{\r\nchar *p, *type_name_dup;\r\nstruct dm_dirty_log_type *log_type;\r\nif (!type_name)\r\nreturn NULL;\r\nlog_type = _get_dirty_log_type(type_name);\r\nif (log_type)\r\nreturn log_type;\r\ntype_name_dup = kstrdup(type_name, GFP_KERNEL);\r\nif (!type_name_dup) {\r\nDMWARN("No memory left to attempt log module load for \"%s\"",\r\ntype_name);\r\nreturn NULL;\r\n}\r\nwhile (request_module("dm-log-%s", type_name_dup) ||\r\n!(log_type = _get_dirty_log_type(type_name))) {\r\np = strrchr(type_name_dup, '-');\r\nif (!p)\r\nbreak;\r\np[0] = '\0';\r\n}\r\nif (!log_type)\r\nDMWARN("Module for logging type \"%s\" not found.", type_name);\r\nkfree(type_name_dup);\r\nreturn log_type;\r\n}\r\nstatic void put_type(struct dm_dirty_log_type *type)\r\n{\r\nif (!type)\r\nreturn;\r\nspin_lock(&_lock);\r\nif (!__find_dirty_log_type(type->name))\r\ngoto out;\r\nmodule_put(type->module);\r\nout:\r\nspin_unlock(&_lock);\r\n}\r\nint dm_dirty_log_type_register(struct dm_dirty_log_type *type)\r\n{\r\nint r = 0;\r\nspin_lock(&_lock);\r\nif (!__find_dirty_log_type(type->name))\r\nlist_add(&type->list, &_log_types);\r\nelse\r\nr = -EEXIST;\r\nspin_unlock(&_lock);\r\nreturn r;\r\n}\r\nint dm_dirty_log_type_unregister(struct dm_dirty_log_type *type)\r\n{\r\nspin_lock(&_lock);\r\nif (!__find_dirty_log_type(type->name)) {\r\nspin_unlock(&_lock);\r\nreturn -EINVAL;\r\n}\r\nlist_del(&type->list);\r\nspin_unlock(&_lock);\r\nreturn 0;\r\n}\r\nstruct dm_dirty_log *dm_dirty_log_create(const char *type_name,\r\nstruct dm_target *ti,\r\nint (*flush_callback_fn)(struct dm_target *ti),\r\nunsigned int argc, char **argv)\r\n{\r\nstruct dm_dirty_log_type *type;\r\nstruct dm_dirty_log *log;\r\nlog = kmalloc(sizeof(*log), GFP_KERNEL);\r\nif (!log)\r\nreturn NULL;\r\ntype = get_type(type_name);\r\nif (!type) {\r\nkfree(log);\r\nreturn NULL;\r\n}\r\nlog->flush_callback_fn = flush_callback_fn;\r\nlog->type = type;\r\nif (type->ctr(log, ti, argc, argv)) {\r\nkfree(log);\r\nput_type(type);\r\nreturn NULL;\r\n}\r\nreturn log;\r\n}\r\nvoid dm_dirty_log_destroy(struct dm_dirty_log *log)\r\n{\r\nlog->type->dtr(log);\r\nput_type(log->type);\r\nkfree(log);\r\n}\r\nstatic inline int log_test_bit(uint32_t *bs, unsigned bit)\r\n{\r\nreturn test_bit_le(bit, bs) ? 1 : 0;\r\n}\r\nstatic inline void log_set_bit(struct log_c *l,\r\nuint32_t *bs, unsigned bit)\r\n{\r\n__set_bit_le(bit, bs);\r\nl->touched_cleaned = 1;\r\n}\r\nstatic inline void log_clear_bit(struct log_c *l,\r\nuint32_t *bs, unsigned bit)\r\n{\r\n__clear_bit_le(bit, bs);\r\nl->touched_dirtied = 1;\r\n}\r\nstatic void header_to_disk(struct log_header_core *core, struct log_header_disk *disk)\r\n{\r\ndisk->magic = cpu_to_le32(core->magic);\r\ndisk->version = cpu_to_le32(core->version);\r\ndisk->nr_regions = cpu_to_le64(core->nr_regions);\r\n}\r\nstatic void header_from_disk(struct log_header_core *core, struct log_header_disk *disk)\r\n{\r\ncore->magic = le32_to_cpu(disk->magic);\r\ncore->version = le32_to_cpu(disk->version);\r\ncore->nr_regions = le64_to_cpu(disk->nr_regions);\r\n}\r\nstatic int rw_header(struct log_c *lc, int op)\r\n{\r\nlc->io_req.bi_op = op;\r\nlc->io_req.bi_op_flags = 0;\r\nreturn dm_io(&lc->io_req, 1, &lc->header_location, NULL);\r\n}\r\nstatic int flush_header(struct log_c *lc)\r\n{\r\nstruct dm_io_region null_location = {\r\n.bdev = lc->header_location.bdev,\r\n.sector = 0,\r\n.count = 0,\r\n};\r\nlc->io_req.bi_op = REQ_OP_WRITE;\r\nlc->io_req.bi_op_flags = WRITE_FLUSH;\r\nreturn dm_io(&lc->io_req, 1, &null_location, NULL);\r\n}\r\nstatic int read_header(struct log_c *log)\r\n{\r\nint r;\r\nr = rw_header(log, REQ_OP_READ);\r\nif (r)\r\nreturn r;\r\nheader_from_disk(&log->header, log->disk_header);\r\nif (log->sync != DEFAULTSYNC || log->header.magic != MIRROR_MAGIC) {\r\nlog->header.magic = MIRROR_MAGIC;\r\nlog->header.version = MIRROR_DISK_VERSION;\r\nlog->header.nr_regions = 0;\r\n}\r\n#ifdef __LITTLE_ENDIAN\r\nif (log->header.version == 1)\r\nlog->header.version = 2;\r\n#endif\r\nif (log->header.version != MIRROR_DISK_VERSION) {\r\nDMWARN("incompatible disk log version");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _check_region_size(struct dm_target *ti, uint32_t region_size)\r\n{\r\nif (region_size < 2 || region_size > ti->len)\r\nreturn 0;\r\nif (!is_power_of_2(region_size))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int create_log_context(struct dm_dirty_log *log, struct dm_target *ti,\r\nunsigned int argc, char **argv,\r\nstruct dm_dev *dev)\r\n{\r\nenum sync sync = DEFAULTSYNC;\r\nstruct log_c *lc;\r\nuint32_t region_size;\r\nunsigned int region_count;\r\nsize_t bitset_size, buf_size;\r\nint r;\r\nchar dummy;\r\nif (argc < 1 || argc > 2) {\r\nDMWARN("wrong number of arguments to dirty region log");\r\nreturn -EINVAL;\r\n}\r\nif (argc > 1) {\r\nif (!strcmp(argv[1], "sync"))\r\nsync = FORCESYNC;\r\nelse if (!strcmp(argv[1], "nosync"))\r\nsync = NOSYNC;\r\nelse {\r\nDMWARN("unrecognised sync argument to "\r\n"dirty region log: %s", argv[1]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (sscanf(argv[0], "%u%c", &region_size, &dummy) != 1 ||\r\n!_check_region_size(ti, region_size)) {\r\nDMWARN("invalid region size %s", argv[0]);\r\nreturn -EINVAL;\r\n}\r\nregion_count = dm_sector_div_up(ti->len, region_size);\r\nlc = kmalloc(sizeof(*lc), GFP_KERNEL);\r\nif (!lc) {\r\nDMWARN("couldn't allocate core log");\r\nreturn -ENOMEM;\r\n}\r\nlc->ti = ti;\r\nlc->touched_dirtied = 0;\r\nlc->touched_cleaned = 0;\r\nlc->flush_failed = 0;\r\nlc->region_size = region_size;\r\nlc->region_count = region_count;\r\nlc->sync = sync;\r\nbitset_size = dm_round_up(region_count,\r\nsizeof(*lc->clean_bits) << BYTE_SHIFT);\r\nbitset_size >>= BYTE_SHIFT;\r\nlc->bitset_uint32_count = bitset_size / sizeof(*lc->clean_bits);\r\nif (!dev) {\r\nlc->clean_bits = vmalloc(bitset_size);\r\nif (!lc->clean_bits) {\r\nDMWARN("couldn't allocate clean bitset");\r\nkfree(lc);\r\nreturn -ENOMEM;\r\n}\r\nlc->disk_header = NULL;\r\n} else {\r\nlc->log_dev = dev;\r\nlc->log_dev_failed = 0;\r\nlc->log_dev_flush_failed = 0;\r\nlc->header_location.bdev = lc->log_dev->bdev;\r\nlc->header_location.sector = 0;\r\nbuf_size =\r\ndm_round_up((LOG_OFFSET << SECTOR_SHIFT) + bitset_size,\r\nbdev_logical_block_size(lc->header_location.\r\nbdev));\r\nif (buf_size > i_size_read(dev->bdev->bd_inode)) {\r\nDMWARN("log device %s too small: need %llu bytes",\r\ndev->name, (unsigned long long)buf_size);\r\nkfree(lc);\r\nreturn -EINVAL;\r\n}\r\nlc->header_location.count = buf_size >> SECTOR_SHIFT;\r\nlc->io_req.mem.type = DM_IO_VMA;\r\nlc->io_req.notify.fn = NULL;\r\nlc->io_req.client = dm_io_client_create();\r\nif (IS_ERR(lc->io_req.client)) {\r\nr = PTR_ERR(lc->io_req.client);\r\nDMWARN("couldn't allocate disk io client");\r\nkfree(lc);\r\nreturn r;\r\n}\r\nlc->disk_header = vmalloc(buf_size);\r\nif (!lc->disk_header) {\r\nDMWARN("couldn't allocate disk log buffer");\r\ndm_io_client_destroy(lc->io_req.client);\r\nkfree(lc);\r\nreturn -ENOMEM;\r\n}\r\nlc->io_req.mem.ptr.vma = lc->disk_header;\r\nlc->clean_bits = (void *)lc->disk_header +\r\n(LOG_OFFSET << SECTOR_SHIFT);\r\n}\r\nmemset(lc->clean_bits, -1, bitset_size);\r\nlc->sync_bits = vmalloc(bitset_size);\r\nif (!lc->sync_bits) {\r\nDMWARN("couldn't allocate sync bitset");\r\nif (!dev)\r\nvfree(lc->clean_bits);\r\nelse\r\ndm_io_client_destroy(lc->io_req.client);\r\nvfree(lc->disk_header);\r\nkfree(lc);\r\nreturn -ENOMEM;\r\n}\r\nmemset(lc->sync_bits, (sync == NOSYNC) ? -1 : 0, bitset_size);\r\nlc->sync_count = (sync == NOSYNC) ? region_count : 0;\r\nlc->recovering_bits = vzalloc(bitset_size);\r\nif (!lc->recovering_bits) {\r\nDMWARN("couldn't allocate sync bitset");\r\nvfree(lc->sync_bits);\r\nif (!dev)\r\nvfree(lc->clean_bits);\r\nelse\r\ndm_io_client_destroy(lc->io_req.client);\r\nvfree(lc->disk_header);\r\nkfree(lc);\r\nreturn -ENOMEM;\r\n}\r\nlc->sync_search = 0;\r\nlog->context = lc;\r\nreturn 0;\r\n}\r\nstatic int core_ctr(struct dm_dirty_log *log, struct dm_target *ti,\r\nunsigned int argc, char **argv)\r\n{\r\nreturn create_log_context(log, ti, argc, argv, NULL);\r\n}\r\nstatic void destroy_log_context(struct log_c *lc)\r\n{\r\nvfree(lc->sync_bits);\r\nvfree(lc->recovering_bits);\r\nkfree(lc);\r\n}\r\nstatic void core_dtr(struct dm_dirty_log *log)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nvfree(lc->clean_bits);\r\ndestroy_log_context(lc);\r\n}\r\nstatic int disk_ctr(struct dm_dirty_log *log, struct dm_target *ti,\r\nunsigned int argc, char **argv)\r\n{\r\nint r;\r\nstruct dm_dev *dev;\r\nif (argc < 2 || argc > 3) {\r\nDMWARN("wrong number of arguments to disk dirty region log");\r\nreturn -EINVAL;\r\n}\r\nr = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &dev);\r\nif (r)\r\nreturn r;\r\nr = create_log_context(log, ti, argc - 1, argv + 1, dev);\r\nif (r) {\r\ndm_put_device(ti, dev);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void disk_dtr(struct dm_dirty_log *log)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\ndm_put_device(lc->ti, lc->log_dev);\r\nvfree(lc->disk_header);\r\ndm_io_client_destroy(lc->io_req.client);\r\ndestroy_log_context(lc);\r\n}\r\nstatic void fail_log_device(struct log_c *lc)\r\n{\r\nif (lc->log_dev_failed)\r\nreturn;\r\nlc->log_dev_failed = 1;\r\ndm_table_event(lc->ti->table);\r\n}\r\nstatic int disk_resume(struct dm_dirty_log *log)\r\n{\r\nint r;\r\nunsigned i;\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nsize_t size = lc->bitset_uint32_count * sizeof(uint32_t);\r\nr = read_header(lc);\r\nif (r) {\r\nDMWARN("%s: Failed to read header on dirty region log device",\r\nlc->log_dev->name);\r\nfail_log_device(lc);\r\nlc->header.nr_regions = 0;\r\n}\r\nif (lc->sync == NOSYNC)\r\nfor (i = lc->header.nr_regions; i < lc->region_count; i++)\r\nlog_set_bit(lc, lc->clean_bits, i);\r\nelse\r\nfor (i = lc->header.nr_regions; i < lc->region_count; i++)\r\nlog_clear_bit(lc, lc->clean_bits, i);\r\nfor (i = lc->region_count; i % (sizeof(*lc->clean_bits) << BYTE_SHIFT); i++)\r\nlog_clear_bit(lc, lc->clean_bits, i);\r\nmemcpy(lc->sync_bits, lc->clean_bits, size);\r\nlc->sync_count = memweight(lc->clean_bits,\r\nlc->bitset_uint32_count * sizeof(uint32_t));\r\nlc->sync_search = 0;\r\nlc->header.nr_regions = lc->region_count;\r\nheader_to_disk(&lc->header, lc->disk_header);\r\nr = rw_header(lc, REQ_OP_WRITE);\r\nif (!r) {\r\nr = flush_header(lc);\r\nif (r)\r\nlc->log_dev_flush_failed = 1;\r\n}\r\nif (r) {\r\nDMWARN("%s: Failed to write header on dirty region log device",\r\nlc->log_dev->name);\r\nfail_log_device(lc);\r\n}\r\nreturn r;\r\n}\r\nstatic uint32_t core_get_region_size(struct dm_dirty_log *log)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nreturn lc->region_size;\r\n}\r\nstatic int core_resume(struct dm_dirty_log *log)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nlc->sync_search = 0;\r\nreturn 0;\r\n}\r\nstatic int core_is_clean(struct dm_dirty_log *log, region_t region)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nreturn log_test_bit(lc->clean_bits, region);\r\n}\r\nstatic int core_in_sync(struct dm_dirty_log *log, region_t region, int block)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nreturn log_test_bit(lc->sync_bits, region);\r\n}\r\nstatic int core_flush(struct dm_dirty_log *log)\r\n{\r\nreturn 0;\r\n}\r\nstatic int disk_flush(struct dm_dirty_log *log)\r\n{\r\nint r, i;\r\nstruct log_c *lc = log->context;\r\nif (!lc->touched_cleaned && !lc->touched_dirtied)\r\nreturn 0;\r\nif (lc->touched_cleaned && log->flush_callback_fn &&\r\nlog->flush_callback_fn(lc->ti)) {\r\nlc->flush_failed = 1;\r\nfor (i = 0; i < lc->region_count; i++)\r\nlog_clear_bit(lc, lc->clean_bits, i);\r\n}\r\nr = rw_header(lc, REQ_OP_WRITE);\r\nif (r)\r\nfail_log_device(lc);\r\nelse {\r\nif (lc->touched_dirtied) {\r\nr = flush_header(lc);\r\nif (r) {\r\nlc->log_dev_flush_failed = 1;\r\nfail_log_device(lc);\r\n} else\r\nlc->touched_dirtied = 0;\r\n}\r\nlc->touched_cleaned = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic void core_mark_region(struct dm_dirty_log *log, region_t region)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nlog_clear_bit(lc, lc->clean_bits, region);\r\n}\r\nstatic void core_clear_region(struct dm_dirty_log *log, region_t region)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nif (likely(!lc->flush_failed))\r\nlog_set_bit(lc, lc->clean_bits, region);\r\n}\r\nstatic int core_get_resync_work(struct dm_dirty_log *log, region_t *region)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nif (lc->sync_search >= lc->region_count)\r\nreturn 0;\r\ndo {\r\n*region = find_next_zero_bit_le(lc->sync_bits,\r\nlc->region_count,\r\nlc->sync_search);\r\nlc->sync_search = *region + 1;\r\nif (*region >= lc->region_count)\r\nreturn 0;\r\n} while (log_test_bit(lc->recovering_bits, *region));\r\nlog_set_bit(lc, lc->recovering_bits, *region);\r\nreturn 1;\r\n}\r\nstatic void core_set_region_sync(struct dm_dirty_log *log, region_t region,\r\nint in_sync)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nlog_clear_bit(lc, lc->recovering_bits, region);\r\nif (in_sync) {\r\nlog_set_bit(lc, lc->sync_bits, region);\r\nlc->sync_count++;\r\n} else if (log_test_bit(lc->sync_bits, region)) {\r\nlc->sync_count--;\r\nlog_clear_bit(lc, lc->sync_bits, region);\r\n}\r\n}\r\nstatic region_t core_get_sync_count(struct dm_dirty_log *log)\r\n{\r\nstruct log_c *lc = (struct log_c *) log->context;\r\nreturn lc->sync_count;\r\n}\r\nstatic int core_status(struct dm_dirty_log *log, status_type_t status,\r\nchar *result, unsigned int maxlen)\r\n{\r\nint sz = 0;\r\nstruct log_c *lc = log->context;\r\nswitch(status) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("1 %s", log->type->name);\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%s %u %u ", log->type->name,\r\nlc->sync == DEFAULTSYNC ? 1 : 2, lc->region_size);\r\nDMEMIT_SYNC;\r\n}\r\nreturn sz;\r\n}\r\nstatic int disk_status(struct dm_dirty_log *log, status_type_t status,\r\nchar *result, unsigned int maxlen)\r\n{\r\nint sz = 0;\r\nstruct log_c *lc = log->context;\r\nswitch(status) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("3 %s %s %c", log->type->name, lc->log_dev->name,\r\nlc->log_dev_flush_failed ? 'F' :\r\nlc->log_dev_failed ? 'D' :\r\n'A');\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%s %u %s %u ", log->type->name,\r\nlc->sync == DEFAULTSYNC ? 2 : 3, lc->log_dev->name,\r\nlc->region_size);\r\nDMEMIT_SYNC;\r\n}\r\nreturn sz;\r\n}\r\nstatic int __init dm_dirty_log_init(void)\r\n{\r\nint r;\r\nr = dm_dirty_log_type_register(&_core_type);\r\nif (r)\r\nDMWARN("couldn't register core log");\r\nr = dm_dirty_log_type_register(&_disk_type);\r\nif (r) {\r\nDMWARN("couldn't register disk type");\r\ndm_dirty_log_type_unregister(&_core_type);\r\n}\r\nreturn r;\r\n}\r\nstatic void __exit dm_dirty_log_exit(void)\r\n{\r\ndm_dirty_log_type_unregister(&_disk_type);\r\ndm_dirty_log_type_unregister(&_core_type);\r\n}
