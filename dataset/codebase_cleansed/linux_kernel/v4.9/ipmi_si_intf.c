void debug_timestamp(char *msg)\r\n{\r\nstruct timespec64 t;\r\ngetnstimeofday64(&t);\r\npr_debug("**%s: %lld.%9.9ld\n", msg, (long long) t.tv_sec, t.tv_nsec);\r\n}\r\nstatic int register_xaction_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_register(&xaction_notifier_list, nb);\r\n}\r\nstatic void deliver_recv_msg(struct smi_info *smi_info,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nif (smi_info->intf)\r\nipmi_smi_msg_received(smi_info->intf, msg);\r\nelse\r\nipmi_free_smi_msg(msg);\r\n}\r\nstatic void return_hosed_msg(struct smi_info *smi_info, int cCode)\r\n{\r\nstruct ipmi_smi_msg *msg = smi_info->curr_msg;\r\nif (cCode < 0 || cCode > IPMI_ERR_UNSPECIFIED)\r\ncCode = IPMI_ERR_UNSPECIFIED;\r\nmsg->rsp[0] = msg->data[0] | 4;\r\nmsg->rsp[1] = msg->data[1];\r\nmsg->rsp[2] = cCode;\r\nmsg->rsp_size = 3;\r\nsmi_info->curr_msg = NULL;\r\ndeliver_recv_msg(smi_info, msg);\r\n}\r\nstatic enum si_sm_result start_next_msg(struct smi_info *smi_info)\r\n{\r\nint rv;\r\nif (!smi_info->waiting_msg) {\r\nsmi_info->curr_msg = NULL;\r\nrv = SI_SM_IDLE;\r\n} else {\r\nint err;\r\nsmi_info->curr_msg = smi_info->waiting_msg;\r\nsmi_info->waiting_msg = NULL;\r\ndebug_timestamp("Start2");\r\nerr = atomic_notifier_call_chain(&xaction_notifier_list,\r\n0, smi_info);\r\nif (err & NOTIFY_STOP_MASK) {\r\nrv = SI_SM_CALL_WITHOUT_DELAY;\r\ngoto out;\r\n}\r\nerr = smi_info->handlers->start_transaction(\r\nsmi_info->si_sm,\r\nsmi_info->curr_msg->data,\r\nsmi_info->curr_msg->data_size);\r\nif (err)\r\nreturn_hosed_msg(smi_info, err);\r\nrv = SI_SM_CALL_WITHOUT_DELAY;\r\n}\r\nout:\r\nreturn rv;\r\n}\r\nstatic void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)\r\n{\r\nsmi_info->last_timeout_jiffies = jiffies;\r\nmod_timer(&smi_info->si_timer, new_val);\r\nsmi_info->timer_running = true;\r\n}\r\nstatic void start_new_msg(struct smi_info *smi_info, unsigned char *msg,\r\nunsigned int size)\r\n{\r\nsmi_mod_timer(smi_info, jiffies + SI_TIMEOUT_JIFFIES);\r\nif (smi_info->thread)\r\nwake_up_process(smi_info->thread);\r\nsmi_info->handlers->start_transaction(smi_info->si_sm, msg, size);\r\n}\r\nstatic void start_check_enables(struct smi_info *smi_info, bool start_timer)\r\n{\r\nunsigned char msg[2];\r\nmsg[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmsg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;\r\nif (start_timer)\r\nstart_new_msg(smi_info, msg, 2);\r\nelse\r\nsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);\r\nsmi_info->si_state = SI_CHECKING_ENABLES;\r\n}\r\nstatic void start_clear_flags(struct smi_info *smi_info, bool start_timer)\r\n{\r\nunsigned char msg[3];\r\nmsg[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmsg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;\r\nmsg[2] = WDT_PRE_TIMEOUT_INT;\r\nif (start_timer)\r\nstart_new_msg(smi_info, msg, 3);\r\nelse\r\nsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 3);\r\nsmi_info->si_state = SI_CLEARING_FLAGS;\r\n}\r\nstatic void start_getting_msg_queue(struct smi_info *smi_info)\r\n{\r\nsmi_info->curr_msg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nsmi_info->curr_msg->data[1] = IPMI_GET_MSG_CMD;\r\nsmi_info->curr_msg->data_size = 2;\r\nstart_new_msg(smi_info, smi_info->curr_msg->data,\r\nsmi_info->curr_msg->data_size);\r\nsmi_info->si_state = SI_GETTING_MESSAGES;\r\n}\r\nstatic void start_getting_events(struct smi_info *smi_info)\r\n{\r\nsmi_info->curr_msg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nsmi_info->curr_msg->data[1] = IPMI_READ_EVENT_MSG_BUFFER_CMD;\r\nsmi_info->curr_msg->data_size = 2;\r\nstart_new_msg(smi_info, smi_info->curr_msg->data,\r\nsmi_info->curr_msg->data_size);\r\nsmi_info->si_state = SI_GETTING_EVENTS;\r\n}\r\nstatic inline bool disable_si_irq(struct smi_info *smi_info, bool start_timer)\r\n{\r\nif ((smi_info->irq) && (!smi_info->interrupt_disabled)) {\r\nsmi_info->interrupt_disabled = true;\r\nstart_check_enables(smi_info, start_timer);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline bool enable_si_irq(struct smi_info *smi_info)\r\n{\r\nif ((smi_info->irq) && (smi_info->interrupt_disabled)) {\r\nsmi_info->interrupt_disabled = false;\r\nstart_check_enables(smi_info, true);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct ipmi_smi_msg *alloc_msg_handle_irq(struct smi_info *smi_info)\r\n{\r\nstruct ipmi_smi_msg *msg;\r\nmsg = ipmi_alloc_smi_msg();\r\nif (!msg) {\r\nif (!disable_si_irq(smi_info, true))\r\nsmi_info->si_state = SI_NORMAL;\r\n} else if (enable_si_irq(smi_info)) {\r\nipmi_free_smi_msg(msg);\r\nmsg = NULL;\r\n}\r\nreturn msg;\r\n}\r\nstatic void handle_flags(struct smi_info *smi_info)\r\n{\r\nretry:\r\nif (smi_info->msg_flags & WDT_PRE_TIMEOUT_INT) {\r\nsmi_inc_stat(smi_info, watchdog_pretimeouts);\r\nstart_clear_flags(smi_info, true);\r\nsmi_info->msg_flags &= ~WDT_PRE_TIMEOUT_INT;\r\nif (smi_info->intf)\r\nipmi_smi_watchdog_pretimeout(smi_info->intf);\r\n} else if (smi_info->msg_flags & RECEIVE_MSG_AVAIL) {\r\nsmi_info->curr_msg = alloc_msg_handle_irq(smi_info);\r\nif (!smi_info->curr_msg)\r\nreturn;\r\nstart_getting_msg_queue(smi_info);\r\n} else if (smi_info->msg_flags & EVENT_MSG_BUFFER_FULL) {\r\nsmi_info->curr_msg = alloc_msg_handle_irq(smi_info);\r\nif (!smi_info->curr_msg)\r\nreturn;\r\nstart_getting_events(smi_info);\r\n} else if (smi_info->msg_flags & OEM_DATA_AVAIL &&\r\nsmi_info->oem_data_avail_handler) {\r\nif (smi_info->oem_data_avail_handler(smi_info))\r\ngoto retry;\r\n} else\r\nsmi_info->si_state = SI_NORMAL;\r\n}\r\nstatic u8 current_global_enables(struct smi_info *smi_info, u8 base,\r\nbool *irq_on)\r\n{\r\nu8 enables = 0;\r\nif (smi_info->supports_event_msg_buff)\r\nenables |= IPMI_BMC_EVT_MSG_BUFF;\r\nif (((smi_info->irq && !smi_info->interrupt_disabled) ||\r\nsmi_info->cannot_disable_irq) &&\r\n!smi_info->irq_enable_broken)\r\nenables |= IPMI_BMC_RCV_MSG_INTR;\r\nif (smi_info->supports_event_msg_buff &&\r\nsmi_info->irq && !smi_info->interrupt_disabled &&\r\n!smi_info->irq_enable_broken)\r\nenables |= IPMI_BMC_EVT_MSG_INTR;\r\n*irq_on = enables & (IPMI_BMC_EVT_MSG_INTR | IPMI_BMC_RCV_MSG_INTR);\r\nreturn enables;\r\n}\r\nstatic void check_bt_irq(struct smi_info *smi_info, bool irq_on)\r\n{\r\nu8 irqstate = smi_info->io.inputb(&smi_info->io, IPMI_BT_INTMASK_REG);\r\nirqstate &= IPMI_BT_INTMASK_ENABLE_IRQ_BIT;\r\nif ((bool)irqstate == irq_on)\r\nreturn;\r\nif (irq_on)\r\nsmi_info->io.outputb(&smi_info->io, IPMI_BT_INTMASK_REG,\r\nIPMI_BT_INTMASK_ENABLE_IRQ_BIT);\r\nelse\r\nsmi_info->io.outputb(&smi_info->io, IPMI_BT_INTMASK_REG, 0);\r\n}\r\nstatic void handle_transaction_done(struct smi_info *smi_info)\r\n{\r\nstruct ipmi_smi_msg *msg;\r\ndebug_timestamp("Done");\r\nswitch (smi_info->si_state) {\r\ncase SI_NORMAL:\r\nif (!smi_info->curr_msg)\r\nbreak;\r\nsmi_info->curr_msg->rsp_size\r\n= smi_info->handlers->get_result(\r\nsmi_info->si_sm,\r\nsmi_info->curr_msg->rsp,\r\nIPMI_MAX_MSG_LENGTH);\r\nmsg = smi_info->curr_msg;\r\nsmi_info->curr_msg = NULL;\r\ndeliver_recv_msg(smi_info, msg);\r\nbreak;\r\ncase SI_GETTING_FLAGS:\r\n{\r\nunsigned char msg[4];\r\nunsigned int len;\r\nlen = smi_info->handlers->get_result(smi_info->si_sm, msg, 4);\r\nif (msg[2] != 0) {\r\nsmi_info->si_state = SI_NORMAL;\r\n} else if (len < 4) {\r\nsmi_info->si_state = SI_NORMAL;\r\n} else {\r\nsmi_info->msg_flags = msg[3];\r\nhandle_flags(smi_info);\r\n}\r\nbreak;\r\n}\r\ncase SI_CLEARING_FLAGS:\r\n{\r\nunsigned char msg[3];\r\nsmi_info->handlers->get_result(smi_info->si_sm, msg, 3);\r\nif (msg[2] != 0) {\r\ndev_warn(smi_info->dev,\r\n"Error clearing flags: %2.2x\n", msg[2]);\r\n}\r\nsmi_info->si_state = SI_NORMAL;\r\nbreak;\r\n}\r\ncase SI_GETTING_EVENTS:\r\n{\r\nsmi_info->curr_msg->rsp_size\r\n= smi_info->handlers->get_result(\r\nsmi_info->si_sm,\r\nsmi_info->curr_msg->rsp,\r\nIPMI_MAX_MSG_LENGTH);\r\nmsg = smi_info->curr_msg;\r\nsmi_info->curr_msg = NULL;\r\nif (msg->rsp[2] != 0) {\r\nmsg->done(msg);\r\nsmi_info->msg_flags &= ~EVENT_MSG_BUFFER_FULL;\r\nhandle_flags(smi_info);\r\n} else {\r\nsmi_inc_stat(smi_info, events);\r\nhandle_flags(smi_info);\r\ndeliver_recv_msg(smi_info, msg);\r\n}\r\nbreak;\r\n}\r\ncase SI_GETTING_MESSAGES:\r\n{\r\nsmi_info->curr_msg->rsp_size\r\n= smi_info->handlers->get_result(\r\nsmi_info->si_sm,\r\nsmi_info->curr_msg->rsp,\r\nIPMI_MAX_MSG_LENGTH);\r\nmsg = smi_info->curr_msg;\r\nsmi_info->curr_msg = NULL;\r\nif (msg->rsp[2] != 0) {\r\nmsg->done(msg);\r\nsmi_info->msg_flags &= ~RECEIVE_MSG_AVAIL;\r\nhandle_flags(smi_info);\r\n} else {\r\nsmi_inc_stat(smi_info, incoming_messages);\r\nhandle_flags(smi_info);\r\ndeliver_recv_msg(smi_info, msg);\r\n}\r\nbreak;\r\n}\r\ncase SI_CHECKING_ENABLES:\r\n{\r\nunsigned char msg[4];\r\nu8 enables;\r\nbool irq_on;\r\nsmi_info->handlers->get_result(smi_info->si_sm, msg, 4);\r\nif (msg[2] != 0) {\r\ndev_warn(smi_info->dev,\r\n"Couldn't get irq info: %x.\n", msg[2]);\r\ndev_warn(smi_info->dev,\r\n"Maybe ok, but ipmi might run very slowly.\n");\r\nsmi_info->si_state = SI_NORMAL;\r\nbreak;\r\n}\r\nenables = current_global_enables(smi_info, 0, &irq_on);\r\nif (smi_info->si_type == SI_BT)\r\ncheck_bt_irq(smi_info, irq_on);\r\nif (enables != (msg[3] & GLOBAL_ENABLES_MASK)) {\r\nmsg[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmsg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;\r\nmsg[2] = enables | (msg[3] & ~GLOBAL_ENABLES_MASK);\r\nsmi_info->handlers->start_transaction(\r\nsmi_info->si_sm, msg, 3);\r\nsmi_info->si_state = SI_SETTING_ENABLES;\r\n} else if (smi_info->supports_event_msg_buff) {\r\nsmi_info->curr_msg = ipmi_alloc_smi_msg();\r\nif (!smi_info->curr_msg) {\r\nsmi_info->si_state = SI_NORMAL;\r\nbreak;\r\n}\r\nstart_getting_msg_queue(smi_info);\r\n} else {\r\nsmi_info->si_state = SI_NORMAL;\r\n}\r\nbreak;\r\n}\r\ncase SI_SETTING_ENABLES:\r\n{\r\nunsigned char msg[4];\r\nsmi_info->handlers->get_result(smi_info->si_sm, msg, 4);\r\nif (msg[2] != 0)\r\ndev_warn(smi_info->dev,\r\n"Could not set the global enables: 0x%x.\n",\r\nmsg[2]);\r\nif (smi_info->supports_event_msg_buff) {\r\nsmi_info->curr_msg = ipmi_alloc_smi_msg();\r\nif (!smi_info->curr_msg) {\r\nsmi_info->si_state = SI_NORMAL;\r\nbreak;\r\n}\r\nstart_getting_msg_queue(smi_info);\r\n} else {\r\nsmi_info->si_state = SI_NORMAL;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic enum si_sm_result smi_event_handler(struct smi_info *smi_info,\r\nint time)\r\n{\r\nenum si_sm_result si_sm_result;\r\nrestart:\r\nsi_sm_result = smi_info->handlers->event(smi_info->si_sm, time);\r\ntime = 0;\r\nwhile (si_sm_result == SI_SM_CALL_WITHOUT_DELAY)\r\nsi_sm_result = smi_info->handlers->event(smi_info->si_sm, 0);\r\nif (si_sm_result == SI_SM_TRANSACTION_COMPLETE) {\r\nsmi_inc_stat(smi_info, complete_transactions);\r\nhandle_transaction_done(smi_info);\r\ngoto restart;\r\n} else if (si_sm_result == SI_SM_HOSED) {\r\nsmi_inc_stat(smi_info, hosed_count);\r\nsmi_info->si_state = SI_NORMAL;\r\nif (smi_info->curr_msg != NULL) {\r\nreturn_hosed_msg(smi_info, IPMI_ERR_UNSPECIFIED);\r\n}\r\ngoto restart;\r\n}\r\nif (likely(smi_info->intf) &&\r\n(si_sm_result == SI_SM_ATTN || smi_info->got_attn)) {\r\nunsigned char msg[2];\r\nif (smi_info->si_state != SI_NORMAL) {\r\nsmi_info->got_attn = true;\r\n} else {\r\nsmi_info->got_attn = false;\r\nsmi_inc_stat(smi_info, attentions);\r\nmsg[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmsg[1] = IPMI_GET_MSG_FLAGS_CMD;\r\nstart_new_msg(smi_info, msg, 2);\r\nsmi_info->si_state = SI_GETTING_FLAGS;\r\ngoto restart;\r\n}\r\n}\r\nif (si_sm_result == SI_SM_IDLE) {\r\nsmi_inc_stat(smi_info, idles);\r\nsi_sm_result = start_next_msg(smi_info);\r\nif (si_sm_result != SI_SM_IDLE)\r\ngoto restart;\r\n}\r\nif ((si_sm_result == SI_SM_IDLE)\r\n&& (atomic_read(&smi_info->req_events))) {\r\natomic_set(&smi_info->req_events, 0);\r\nif (smi_info->supports_event_msg_buff || smi_info->irq) {\r\nstart_check_enables(smi_info, true);\r\n} else {\r\nsmi_info->curr_msg = alloc_msg_handle_irq(smi_info);\r\nif (!smi_info->curr_msg)\r\ngoto out;\r\nstart_getting_events(smi_info);\r\n}\r\ngoto restart;\r\n}\r\nif (si_sm_result == SI_SM_IDLE && smi_info->timer_running) {\r\nif (del_timer(&smi_info->si_timer))\r\nsmi_info->timer_running = false;\r\n}\r\nout:\r\nreturn si_sm_result;\r\n}\r\nstatic void check_start_timer_thread(struct smi_info *smi_info)\r\n{\r\nif (smi_info->si_state == SI_NORMAL && smi_info->curr_msg == NULL) {\r\nsmi_mod_timer(smi_info, jiffies + SI_TIMEOUT_JIFFIES);\r\nif (smi_info->thread)\r\nwake_up_process(smi_info->thread);\r\nstart_next_msg(smi_info);\r\nsmi_event_handler(smi_info, 0);\r\n}\r\n}\r\nstatic void flush_messages(void *send_info)\r\n{\r\nstruct smi_info *smi_info = send_info;\r\nenum si_sm_result result;\r\nresult = smi_event_handler(smi_info, 0);\r\nwhile (result != SI_SM_IDLE) {\r\nudelay(SI_SHORT_TIMEOUT_USEC);\r\nresult = smi_event_handler(smi_info, SI_SHORT_TIMEOUT_USEC);\r\n}\r\n}\r\nstatic void sender(void *send_info,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct smi_info *smi_info = send_info;\r\nunsigned long flags;\r\ndebug_timestamp("Enqueue");\r\nif (smi_info->run_to_completion) {\r\nsmi_info->waiting_msg = msg;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&smi_info->si_lock, flags);\r\nBUG_ON(smi_info->waiting_msg);\r\nsmi_info->waiting_msg = msg;\r\ncheck_start_timer_thread(smi_info);\r\nspin_unlock_irqrestore(&smi_info->si_lock, flags);\r\n}\r\nstatic void set_run_to_completion(void *send_info, bool i_run_to_completion)\r\n{\r\nstruct smi_info *smi_info = send_info;\r\nsmi_info->run_to_completion = i_run_to_completion;\r\nif (i_run_to_completion)\r\nflush_messages(smi_info);\r\n}\r\nstatic inline void ipmi_si_set_not_busy(struct timespec64 *ts)\r\n{\r\nts->tv_nsec = -1;\r\n}\r\nstatic inline int ipmi_si_is_busy(struct timespec64 *ts)\r\n{\r\nreturn ts->tv_nsec != -1;\r\n}\r\nstatic inline int ipmi_thread_busy_wait(enum si_sm_result smi_result,\r\nconst struct smi_info *smi_info,\r\nstruct timespec64 *busy_until)\r\n{\r\nunsigned int max_busy_us = 0;\r\nif (smi_info->intf_num < num_max_busy_us)\r\nmax_busy_us = kipmid_max_busy_us[smi_info->intf_num];\r\nif (max_busy_us == 0 || smi_result != SI_SM_CALL_WITH_DELAY)\r\nipmi_si_set_not_busy(busy_until);\r\nelse if (!ipmi_si_is_busy(busy_until)) {\r\ngetnstimeofday64(busy_until);\r\ntimespec64_add_ns(busy_until, max_busy_us*NSEC_PER_USEC);\r\n} else {\r\nstruct timespec64 now;\r\ngetnstimeofday64(&now);\r\nif (unlikely(timespec64_compare(&now, busy_until) > 0)) {\r\nipmi_si_set_not_busy(busy_until);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int ipmi_thread(void *data)\r\n{\r\nstruct smi_info *smi_info = data;\r\nunsigned long flags;\r\nenum si_sm_result smi_result;\r\nstruct timespec64 busy_until;\r\nipmi_si_set_not_busy(&busy_until);\r\nset_user_nice(current, MAX_NICE);\r\nwhile (!kthread_should_stop()) {\r\nint busy_wait;\r\nspin_lock_irqsave(&(smi_info->si_lock), flags);\r\nsmi_result = smi_event_handler(smi_info, 0);\r\nif (smi_result != SI_SM_IDLE && !smi_info->timer_running)\r\nsmi_mod_timer(smi_info, jiffies + SI_TIMEOUT_JIFFIES);\r\nspin_unlock_irqrestore(&(smi_info->si_lock), flags);\r\nbusy_wait = ipmi_thread_busy_wait(smi_result, smi_info,\r\n&busy_until);\r\nif (smi_result == SI_SM_CALL_WITHOUT_DELAY)\r\n;\r\nelse if (smi_result == SI_SM_CALL_WITH_DELAY && busy_wait)\r\nschedule();\r\nelse if (smi_result == SI_SM_IDLE) {\r\nif (atomic_read(&smi_info->need_watch)) {\r\nschedule_timeout_interruptible(100);\r\n} else {\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\n}\r\n} else\r\nschedule_timeout_interruptible(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void poll(void *send_info)\r\n{\r\nstruct smi_info *smi_info = send_info;\r\nunsigned long flags = 0;\r\nbool run_to_completion = smi_info->run_to_completion;\r\nudelay(10);\r\nif (!run_to_completion)\r\nspin_lock_irqsave(&smi_info->si_lock, flags);\r\nsmi_event_handler(smi_info, 10);\r\nif (!run_to_completion)\r\nspin_unlock_irqrestore(&smi_info->si_lock, flags);\r\n}\r\nstatic void request_events(void *send_info)\r\n{\r\nstruct smi_info *smi_info = send_info;\r\nif (!smi_info->has_event_buffer)\r\nreturn;\r\natomic_set(&smi_info->req_events, 1);\r\n}\r\nstatic void set_need_watch(void *send_info, bool enable)\r\n{\r\nstruct smi_info *smi_info = send_info;\r\nunsigned long flags;\r\natomic_set(&smi_info->need_watch, enable);\r\nspin_lock_irqsave(&smi_info->si_lock, flags);\r\ncheck_start_timer_thread(smi_info);\r\nspin_unlock_irqrestore(&smi_info->si_lock, flags);\r\n}\r\nstatic void smi_timeout(unsigned long data)\r\n{\r\nstruct smi_info *smi_info = (struct smi_info *) data;\r\nenum si_sm_result smi_result;\r\nunsigned long flags;\r\nunsigned long jiffies_now;\r\nlong time_diff;\r\nlong timeout;\r\nspin_lock_irqsave(&(smi_info->si_lock), flags);\r\ndebug_timestamp("Timer");\r\njiffies_now = jiffies;\r\ntime_diff = (((long)jiffies_now - (long)smi_info->last_timeout_jiffies)\r\n* SI_USEC_PER_JIFFY);\r\nsmi_result = smi_event_handler(smi_info, time_diff);\r\nif ((smi_info->irq) && (!smi_info->interrupt_disabled)) {\r\ntimeout = jiffies + SI_TIMEOUT_JIFFIES;\r\nsmi_inc_stat(smi_info, long_timeouts);\r\ngoto do_mod_timer;\r\n}\r\nif (smi_result == SI_SM_CALL_WITH_DELAY) {\r\nsmi_inc_stat(smi_info, short_timeouts);\r\ntimeout = jiffies + 1;\r\n} else {\r\nsmi_inc_stat(smi_info, long_timeouts);\r\ntimeout = jiffies + SI_TIMEOUT_JIFFIES;\r\n}\r\ndo_mod_timer:\r\nif (smi_result != SI_SM_IDLE)\r\nsmi_mod_timer(smi_info, timeout);\r\nelse\r\nsmi_info->timer_running = false;\r\nspin_unlock_irqrestore(&(smi_info->si_lock), flags);\r\n}\r\nstatic irqreturn_t si_irq_handler(int irq, void *data)\r\n{\r\nstruct smi_info *smi_info = data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&(smi_info->si_lock), flags);\r\nsmi_inc_stat(smi_info, interrupts);\r\ndebug_timestamp("Interrupt");\r\nsmi_event_handler(smi_info, 0);\r\nspin_unlock_irqrestore(&(smi_info->si_lock), flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t si_bt_irq_handler(int irq, void *data)\r\n{\r\nstruct smi_info *smi_info = data;\r\nsmi_info->io.outputb(&smi_info->io, IPMI_BT_INTMASK_REG,\r\nIPMI_BT_INTMASK_CLEAR_IRQ_BIT\r\n| IPMI_BT_INTMASK_ENABLE_IRQ_BIT);\r\nreturn si_irq_handler(irq, data);\r\n}\r\nstatic int smi_start_processing(void *send_info,\r\nipmi_smi_t intf)\r\n{\r\nstruct smi_info *new_smi = send_info;\r\nint enable = 0;\r\nnew_smi->intf = intf;\r\nsetup_timer(&new_smi->si_timer, smi_timeout, (long)new_smi);\r\nsmi_mod_timer(new_smi, jiffies + SI_TIMEOUT_JIFFIES);\r\nif (new_smi->irq_setup)\r\nnew_smi->irq_setup(new_smi);\r\nif (new_smi->intf_num < num_force_kipmid)\r\nenable = force_kipmid[new_smi->intf_num];\r\nelse if ((new_smi->si_type != SI_BT) && (!new_smi->irq))\r\nenable = 1;\r\nif (enable) {\r\nnew_smi->thread = kthread_run(ipmi_thread, new_smi,\r\n"kipmi%d", new_smi->intf_num);\r\nif (IS_ERR(new_smi->thread)) {\r\ndev_notice(new_smi->dev, "Could not start"\r\n" kernel thread due to error %ld, only using"\r\n" timers to drive the interface\n",\r\nPTR_ERR(new_smi->thread));\r\nnew_smi->thread = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_smi_info(void *send_info, struct ipmi_smi_info *data)\r\n{\r\nstruct smi_info *smi = send_info;\r\ndata->addr_src = smi->addr_source;\r\ndata->dev = smi->dev;\r\ndata->addr_info = smi->addr_info;\r\nget_device(smi->dev);\r\nreturn 0;\r\n}\r\nstatic void set_maintenance_mode(void *send_info, bool enable)\r\n{\r\nstruct smi_info *smi_info = send_info;\r\nif (!enable)\r\natomic_set(&smi_info->req_events, 0);\r\n}\r\nstatic void std_irq_cleanup(struct smi_info *info)\r\n{\r\nif (info->si_type == SI_BT)\r\ninfo->io.outputb(&info->io, IPMI_BT_INTMASK_REG, 0);\r\nfree_irq(info->irq, info);\r\n}\r\nstatic int std_irq_setup(struct smi_info *info)\r\n{\r\nint rv;\r\nif (!info->irq)\r\nreturn 0;\r\nif (info->si_type == SI_BT) {\r\nrv = request_irq(info->irq,\r\nsi_bt_irq_handler,\r\nIRQF_SHARED,\r\nDEVICE_NAME,\r\ninfo);\r\nif (!rv)\r\ninfo->io.outputb(&info->io, IPMI_BT_INTMASK_REG,\r\nIPMI_BT_INTMASK_ENABLE_IRQ_BIT);\r\n} else\r\nrv = request_irq(info->irq,\r\nsi_irq_handler,\r\nIRQF_SHARED,\r\nDEVICE_NAME,\r\ninfo);\r\nif (rv) {\r\ndev_warn(info->dev, "%s unable to claim interrupt %d,"\r\n" running polled\n",\r\nDEVICE_NAME, info->irq);\r\ninfo->irq = 0;\r\n} else {\r\ninfo->irq_cleanup = std_irq_cleanup;\r\ndev_info(info->dev, "Using irq %d\n", info->irq);\r\n}\r\nreturn rv;\r\n}\r\nstatic unsigned char port_inb(const struct si_sm_io *io, unsigned int offset)\r\n{\r\nunsigned int addr = io->addr_data;\r\nreturn inb(addr + (offset * io->regspacing));\r\n}\r\nstatic void port_outb(const struct si_sm_io *io, unsigned int offset,\r\nunsigned char b)\r\n{\r\nunsigned int addr = io->addr_data;\r\noutb(b, addr + (offset * io->regspacing));\r\n}\r\nstatic unsigned char port_inw(const struct si_sm_io *io, unsigned int offset)\r\n{\r\nunsigned int addr = io->addr_data;\r\nreturn (inw(addr + (offset * io->regspacing)) >> io->regshift) & 0xff;\r\n}\r\nstatic void port_outw(const struct si_sm_io *io, unsigned int offset,\r\nunsigned char b)\r\n{\r\nunsigned int addr = io->addr_data;\r\noutw(b << io->regshift, addr + (offset * io->regspacing));\r\n}\r\nstatic unsigned char port_inl(const struct si_sm_io *io, unsigned int offset)\r\n{\r\nunsigned int addr = io->addr_data;\r\nreturn (inl(addr + (offset * io->regspacing)) >> io->regshift) & 0xff;\r\n}\r\nstatic void port_outl(const struct si_sm_io *io, unsigned int offset,\r\nunsigned char b)\r\n{\r\nunsigned int addr = io->addr_data;\r\noutl(b << io->regshift, addr+(offset * io->regspacing));\r\n}\r\nstatic void port_cleanup(struct smi_info *info)\r\n{\r\nunsigned int addr = info->io.addr_data;\r\nint idx;\r\nif (addr) {\r\nfor (idx = 0; idx < info->io_size; idx++)\r\nrelease_region(addr + idx * info->io.regspacing,\r\ninfo->io.regsize);\r\n}\r\n}\r\nstatic int port_setup(struct smi_info *info)\r\n{\r\nunsigned int addr = info->io.addr_data;\r\nint idx;\r\nif (!addr)\r\nreturn -ENODEV;\r\ninfo->io_cleanup = port_cleanup;\r\nswitch (info->io.regsize) {\r\ncase 1:\r\ninfo->io.inputb = port_inb;\r\ninfo->io.outputb = port_outb;\r\nbreak;\r\ncase 2:\r\ninfo->io.inputb = port_inw;\r\ninfo->io.outputb = port_outw;\r\nbreak;\r\ncase 4:\r\ninfo->io.inputb = port_inl;\r\ninfo->io.outputb = port_outl;\r\nbreak;\r\ndefault:\r\ndev_warn(info->dev, "Invalid register size: %d\n",\r\ninfo->io.regsize);\r\nreturn -EINVAL;\r\n}\r\nfor (idx = 0; idx < info->io_size; idx++) {\r\nif (request_region(addr + idx * info->io.regspacing,\r\ninfo->io.regsize, DEVICE_NAME) == NULL) {\r\nwhile (idx--)\r\nrelease_region(addr + idx * info->io.regspacing,\r\ninfo->io.regsize);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char intf_mem_inb(const struct si_sm_io *io,\r\nunsigned int offset)\r\n{\r\nreturn readb((io->addr)+(offset * io->regspacing));\r\n}\r\nstatic void intf_mem_outb(const struct si_sm_io *io, unsigned int offset,\r\nunsigned char b)\r\n{\r\nwriteb(b, (io->addr)+(offset * io->regspacing));\r\n}\r\nstatic unsigned char intf_mem_inw(const struct si_sm_io *io,\r\nunsigned int offset)\r\n{\r\nreturn (readw((io->addr)+(offset * io->regspacing)) >> io->regshift)\r\n& 0xff;\r\n}\r\nstatic void intf_mem_outw(const struct si_sm_io *io, unsigned int offset,\r\nunsigned char b)\r\n{\r\nwriteb(b << io->regshift, (io->addr)+(offset * io->regspacing));\r\n}\r\nstatic unsigned char intf_mem_inl(const struct si_sm_io *io,\r\nunsigned int offset)\r\n{\r\nreturn (readl((io->addr)+(offset * io->regspacing)) >> io->regshift)\r\n& 0xff;\r\n}\r\nstatic void intf_mem_outl(const struct si_sm_io *io, unsigned int offset,\r\nunsigned char b)\r\n{\r\nwritel(b << io->regshift, (io->addr)+(offset * io->regspacing));\r\n}\r\nstatic unsigned char mem_inq(const struct si_sm_io *io, unsigned int offset)\r\n{\r\nreturn (readq((io->addr)+(offset * io->regspacing)) >> io->regshift)\r\n& 0xff;\r\n}\r\nstatic void mem_outq(const struct si_sm_io *io, unsigned int offset,\r\nunsigned char b)\r\n{\r\nwriteq(b << io->regshift, (io->addr)+(offset * io->regspacing));\r\n}\r\nstatic void mem_region_cleanup(struct smi_info *info, int num)\r\n{\r\nunsigned long addr = info->io.addr_data;\r\nint idx;\r\nfor (idx = 0; idx < num; idx++)\r\nrelease_mem_region(addr + idx * info->io.regspacing,\r\ninfo->io.regsize);\r\n}\r\nstatic void mem_cleanup(struct smi_info *info)\r\n{\r\nif (info->io.addr) {\r\niounmap(info->io.addr);\r\nmem_region_cleanup(info, info->io_size);\r\n}\r\n}\r\nstatic int mem_setup(struct smi_info *info)\r\n{\r\nunsigned long addr = info->io.addr_data;\r\nint mapsize, idx;\r\nif (!addr)\r\nreturn -ENODEV;\r\ninfo->io_cleanup = mem_cleanup;\r\nswitch (info->io.regsize) {\r\ncase 1:\r\ninfo->io.inputb = intf_mem_inb;\r\ninfo->io.outputb = intf_mem_outb;\r\nbreak;\r\ncase 2:\r\ninfo->io.inputb = intf_mem_inw;\r\ninfo->io.outputb = intf_mem_outw;\r\nbreak;\r\ncase 4:\r\ninfo->io.inputb = intf_mem_inl;\r\ninfo->io.outputb = intf_mem_outl;\r\nbreak;\r\n#ifdef readq\r\ncase 8:\r\ninfo->io.inputb = mem_inq;\r\ninfo->io.outputb = mem_outq;\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_warn(info->dev, "Invalid register size: %d\n",\r\ninfo->io.regsize);\r\nreturn -EINVAL;\r\n}\r\nfor (idx = 0; idx < info->io_size; idx++) {\r\nif (request_mem_region(addr + idx * info->io.regspacing,\r\ninfo->io.regsize, DEVICE_NAME) == NULL) {\r\nmem_region_cleanup(info, idx);\r\nreturn -EIO;\r\n}\r\n}\r\nmapsize = ((info->io_size * info->io.regspacing)\r\n- (info->io.regspacing - info->io.regsize));\r\ninfo->io.addr = ioremap(addr, mapsize);\r\nif (info->io.addr == NULL) {\r\nmem_region_cleanup(info, info->io_size);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_str(const struct hotmod_vals *v, int *val, char *name,\r\nchar **curr)\r\n{\r\nchar *s;\r\nint i;\r\ns = strchr(*curr, ',');\r\nif (!s) {\r\nprintk(KERN_WARNING PFX "No hotmod %s given.\n", name);\r\nreturn -EINVAL;\r\n}\r\n*s = '\0';\r\ns++;\r\nfor (i = 0; v[i].name; i++) {\r\nif (strcmp(*curr, v[i].name) == 0) {\r\n*val = v[i].val;\r\n*curr = s;\r\nreturn 0;\r\n}\r\n}\r\nprintk(KERN_WARNING PFX "Invalid hotmod %s '%s'\n", name, *curr);\r\nreturn -EINVAL;\r\n}\r\nstatic int check_hotmod_int_op(const char *curr, const char *option,\r\nconst char *name, int *val)\r\n{\r\nchar *n;\r\nif (strcmp(curr, name) == 0) {\r\nif (!option) {\r\nprintk(KERN_WARNING PFX\r\n"No option given for '%s'\n",\r\ncurr);\r\nreturn -EINVAL;\r\n}\r\n*val = simple_strtoul(option, &n, 0);\r\nif ((*n != '\0') || (*option == '\0')) {\r\nprintk(KERN_WARNING PFX\r\n"Bad option given for '%s'\n",\r\ncurr);\r\nreturn -EINVAL;\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct smi_info *smi_info_alloc(void)\r\n{\r\nstruct smi_info *info = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info)\r\nspin_lock_init(&info->si_lock);\r\nreturn info;\r\n}\r\nstatic int hotmod_handler(const char *val, struct kernel_param *kp)\r\n{\r\nchar *str = kstrdup(val, GFP_KERNEL);\r\nint rv;\r\nchar *next, *curr, *s, *n, *o;\r\nenum hotmod_op op;\r\nenum si_type si_type;\r\nint addr_space;\r\nunsigned long addr;\r\nint regspacing;\r\nint regsize;\r\nint regshift;\r\nint irq;\r\nint ipmb;\r\nint ival;\r\nint len;\r\nstruct smi_info *info;\r\nif (!str)\r\nreturn -ENOMEM;\r\nlen = strlen(str);\r\nival = len - 1;\r\nwhile ((ival >= 0) && isspace(str[ival])) {\r\nstr[ival] = '\0';\r\nival--;\r\n}\r\nfor (curr = str; curr; curr = next) {\r\nregspacing = 1;\r\nregsize = 1;\r\nregshift = 0;\r\nirq = 0;\r\nipmb = 0;\r\nnext = strchr(curr, ':');\r\nif (next) {\r\n*next = '\0';\r\nnext++;\r\n}\r\nrv = parse_str(hotmod_ops, &ival, "operation", &curr);\r\nif (rv)\r\nbreak;\r\nop = ival;\r\nrv = parse_str(hotmod_si, &ival, "interface type", &curr);\r\nif (rv)\r\nbreak;\r\nsi_type = ival;\r\nrv = parse_str(hotmod_as, &addr_space, "address space", &curr);\r\nif (rv)\r\nbreak;\r\ns = strchr(curr, ',');\r\nif (s) {\r\n*s = '\0';\r\ns++;\r\n}\r\naddr = simple_strtoul(curr, &n, 0);\r\nif ((*n != '\0') || (*curr == '\0')) {\r\nprintk(KERN_WARNING PFX "Invalid hotmod address"\r\n" '%s'\n", curr);\r\nbreak;\r\n}\r\nwhile (s) {\r\ncurr = s;\r\ns = strchr(curr, ',');\r\nif (s) {\r\n*s = '\0';\r\ns++;\r\n}\r\no = strchr(curr, '=');\r\nif (o) {\r\n*o = '\0';\r\no++;\r\n}\r\nrv = check_hotmod_int_op(curr, o, "rsp", &regspacing);\r\nif (rv < 0)\r\ngoto out;\r\nelse if (rv)\r\ncontinue;\r\nrv = check_hotmod_int_op(curr, o, "rsi", &regsize);\r\nif (rv < 0)\r\ngoto out;\r\nelse if (rv)\r\ncontinue;\r\nrv = check_hotmod_int_op(curr, o, "rsh", &regshift);\r\nif (rv < 0)\r\ngoto out;\r\nelse if (rv)\r\ncontinue;\r\nrv = check_hotmod_int_op(curr, o, "irq", &irq);\r\nif (rv < 0)\r\ngoto out;\r\nelse if (rv)\r\ncontinue;\r\nrv = check_hotmod_int_op(curr, o, "ipmb", &ipmb);\r\nif (rv < 0)\r\ngoto out;\r\nelse if (rv)\r\ncontinue;\r\nrv = -EINVAL;\r\nprintk(KERN_WARNING PFX\r\n"Invalid hotmod option '%s'\n",\r\ncurr);\r\ngoto out;\r\n}\r\nif (op == HM_ADD) {\r\ninfo = smi_info_alloc();\r\nif (!info) {\r\nrv = -ENOMEM;\r\ngoto out;\r\n}\r\ninfo->addr_source = SI_HOTMOD;\r\ninfo->si_type = si_type;\r\ninfo->io.addr_data = addr;\r\ninfo->io.addr_type = addr_space;\r\nif (addr_space == IPMI_MEM_ADDR_SPACE)\r\ninfo->io_setup = mem_setup;\r\nelse\r\ninfo->io_setup = port_setup;\r\ninfo->io.addr = NULL;\r\ninfo->io.regspacing = regspacing;\r\nif (!info->io.regspacing)\r\ninfo->io.regspacing = DEFAULT_REGSPACING;\r\ninfo->io.regsize = regsize;\r\nif (!info->io.regsize)\r\ninfo->io.regsize = DEFAULT_REGSPACING;\r\ninfo->io.regshift = regshift;\r\ninfo->irq = irq;\r\nif (info->irq)\r\ninfo->irq_setup = std_irq_setup;\r\ninfo->slave_addr = ipmb;\r\nrv = add_smi(info);\r\nif (rv) {\r\nkfree(info);\r\ngoto out;\r\n}\r\nrv = try_smi_init(info);\r\nif (rv) {\r\ncleanup_one_si(info);\r\ngoto out;\r\n}\r\n} else {\r\nstruct smi_info *e, *tmp_e;\r\nmutex_lock(&smi_infos_lock);\r\nlist_for_each_entry_safe(e, tmp_e, &smi_infos, link) {\r\nif (e->io.addr_type != addr_space)\r\ncontinue;\r\nif (e->si_type != si_type)\r\ncontinue;\r\nif (e->io.addr_data == addr)\r\ncleanup_one_si(e);\r\n}\r\nmutex_unlock(&smi_infos_lock);\r\n}\r\n}\r\nrv = len;\r\nout:\r\nkfree(str);\r\nreturn rv;\r\n}\r\nstatic int hardcode_find_bmc(void)\r\n{\r\nint ret = -ENODEV;\r\nint i;\r\nstruct smi_info *info;\r\nfor (i = 0; i < SI_MAX_PARMS; i++) {\r\nif (!ports[i] && !addrs[i])\r\ncontinue;\r\ninfo = smi_info_alloc();\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->addr_source = SI_HARDCODED;\r\nprintk(KERN_INFO PFX "probing via hardcoded address\n");\r\nif (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {\r\ninfo->si_type = SI_KCS;\r\n} else if (strcmp(si_type[i], "smic") == 0) {\r\ninfo->si_type = SI_SMIC;\r\n} else if (strcmp(si_type[i], "bt") == 0) {\r\ninfo->si_type = SI_BT;\r\n} else {\r\nprintk(KERN_WARNING PFX "Interface type specified "\r\n"for interface %d, was invalid: %s\n",\r\ni, si_type[i]);\r\nkfree(info);\r\ncontinue;\r\n}\r\nif (ports[i]) {\r\ninfo->io_setup = port_setup;\r\ninfo->io.addr_data = ports[i];\r\ninfo->io.addr_type = IPMI_IO_ADDR_SPACE;\r\n} else if (addrs[i]) {\r\ninfo->io_setup = mem_setup;\r\ninfo->io.addr_data = addrs[i];\r\ninfo->io.addr_type = IPMI_MEM_ADDR_SPACE;\r\n} else {\r\nprintk(KERN_WARNING PFX "Interface type specified "\r\n"for interface %d, but port and address were "\r\n"not set or set to zero.\n", i);\r\nkfree(info);\r\ncontinue;\r\n}\r\ninfo->io.addr = NULL;\r\ninfo->io.regspacing = regspacings[i];\r\nif (!info->io.regspacing)\r\ninfo->io.regspacing = DEFAULT_REGSPACING;\r\ninfo->io.regsize = regsizes[i];\r\nif (!info->io.regsize)\r\ninfo->io.regsize = DEFAULT_REGSPACING;\r\ninfo->io.regshift = regshifts[i];\r\ninfo->irq = irqs[i];\r\nif (info->irq)\r\ninfo->irq_setup = std_irq_setup;\r\ninfo->slave_addr = slave_addrs[i];\r\nif (!add_smi(info)) {\r\nif (try_smi_init(info))\r\ncleanup_one_si(info);\r\nret = 0;\r\n} else {\r\nkfree(info);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 ipmi_acpi_gpe(acpi_handle gpe_device,\r\nu32 gpe_number, void *context)\r\n{\r\nstruct smi_info *smi_info = context;\r\nunsigned long flags;\r\nspin_lock_irqsave(&(smi_info->si_lock), flags);\r\nsmi_inc_stat(smi_info, interrupts);\r\ndebug_timestamp("ACPI_GPE");\r\nsmi_event_handler(smi_info, 0);\r\nspin_unlock_irqrestore(&(smi_info->si_lock), flags);\r\nreturn ACPI_INTERRUPT_HANDLED;\r\n}\r\nstatic void acpi_gpe_irq_cleanup(struct smi_info *info)\r\n{\r\nif (!info->irq)\r\nreturn;\r\nacpi_remove_gpe_handler(NULL, info->irq, &ipmi_acpi_gpe);\r\n}\r\nstatic int acpi_gpe_irq_setup(struct smi_info *info)\r\n{\r\nacpi_status status;\r\nif (!info->irq)\r\nreturn 0;\r\nstatus = acpi_install_gpe_handler(NULL,\r\ninfo->irq,\r\nACPI_GPE_LEVEL_TRIGGERED,\r\n&ipmi_acpi_gpe,\r\ninfo);\r\nif (status != AE_OK) {\r\ndev_warn(info->dev, "%s unable to claim ACPI GPE %d,"\r\n" running polled\n", DEVICE_NAME, info->irq);\r\ninfo->irq = 0;\r\nreturn -EINVAL;\r\n} else {\r\ninfo->irq_cleanup = acpi_gpe_irq_cleanup;\r\ndev_info(info->dev, "Using ACPI GPE %d\n", info->irq);\r\nreturn 0;\r\n}\r\n}\r\nstatic int try_init_spmi(struct SPMITable *spmi)\r\n{\r\nstruct smi_info *info;\r\nint rv;\r\nif (spmi->IPMIlegacy != 1) {\r\nprintk(KERN_INFO PFX "Bad SPMI legacy %d\n", spmi->IPMIlegacy);\r\nreturn -ENODEV;\r\n}\r\ninfo = smi_info_alloc();\r\nif (!info) {\r\nprintk(KERN_ERR PFX "Could not allocate SI data (3)\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->addr_source = SI_SPMI;\r\nprintk(KERN_INFO PFX "probing via SPMI\n");\r\nswitch (spmi->InterfaceType) {\r\ncase 1:\r\ninfo->si_type = SI_KCS;\r\nbreak;\r\ncase 2:\r\ninfo->si_type = SI_SMIC;\r\nbreak;\r\ncase 3:\r\ninfo->si_type = SI_BT;\r\nbreak;\r\ncase 4:\r\nkfree(info);\r\nreturn -EIO;\r\ndefault:\r\nprintk(KERN_INFO PFX "Unknown ACPI/SPMI SI type %d\n",\r\nspmi->InterfaceType);\r\nkfree(info);\r\nreturn -EIO;\r\n}\r\nif (spmi->InterruptType & 1) {\r\ninfo->irq = spmi->GPE;\r\ninfo->irq_setup = acpi_gpe_irq_setup;\r\n} else if (spmi->InterruptType & 2) {\r\ninfo->irq = spmi->GlobalSystemInterrupt;\r\ninfo->irq_setup = std_irq_setup;\r\n} else {\r\ninfo->irq = 0;\r\ninfo->irq_setup = NULL;\r\n}\r\nif (spmi->addr.bit_width) {\r\ninfo->io.regspacing = spmi->addr.bit_width / 8;\r\n} else {\r\ninfo->io.regspacing = DEFAULT_REGSPACING;\r\n}\r\ninfo->io.regsize = info->io.regspacing;\r\ninfo->io.regshift = spmi->addr.bit_offset;\r\nif (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\ninfo->io_setup = mem_setup;\r\ninfo->io.addr_type = IPMI_MEM_ADDR_SPACE;\r\n} else if (spmi->addr.space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\r\ninfo->io_setup = port_setup;\r\ninfo->io.addr_type = IPMI_IO_ADDR_SPACE;\r\n} else {\r\nkfree(info);\r\nprintk(KERN_WARNING PFX "Unknown ACPI I/O Address type\n");\r\nreturn -EIO;\r\n}\r\ninfo->io.addr_data = spmi->addr.address;\r\npr_info("ipmi_si: SPMI: %s %#lx regsize %d spacing %d irq %d\n",\r\n(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",\r\ninfo->io.addr_data, info->io.regsize, info->io.regspacing,\r\ninfo->irq);\r\nrv = add_smi(info);\r\nif (rv)\r\nkfree(info);\r\nreturn rv;\r\n}\r\nstatic void spmi_find_bmc(void)\r\n{\r\nacpi_status status;\r\nstruct SPMITable *spmi;\r\nint i;\r\nif (acpi_disabled)\r\nreturn;\r\nif (acpi_failure)\r\nreturn;\r\nfor (i = 0; ; i++) {\r\nstatus = acpi_get_table(ACPI_SIG_SPMI, i+1,\r\n(struct acpi_table_header **)&spmi);\r\nif (status != AE_OK)\r\nreturn;\r\ntry_init_spmi(spmi);\r\n}\r\n}\r\nstatic int decode_dmi(const struct dmi_header *dm,\r\nstruct dmi_ipmi_data *dmi)\r\n{\r\nconst u8 *data = (const u8 *)dm;\r\nunsigned long base_addr;\r\nu8 reg_spacing;\r\nu8 len = dm->length;\r\ndmi->type = data[4];\r\nmemcpy(&base_addr, data+8, sizeof(unsigned long));\r\nif (len >= 0x11) {\r\nif (base_addr & 1) {\r\nbase_addr &= 0xFFFE;\r\ndmi->addr_space = IPMI_IO_ADDR_SPACE;\r\n} else\r\ndmi->addr_space = IPMI_MEM_ADDR_SPACE;\r\ndmi->base_addr = base_addr | ((data[0x10] & 0x10) >> 4);\r\ndmi->irq = data[0x11];\r\nreg_spacing = (data[0x10] & 0xC0) >> 6;\r\nswitch (reg_spacing) {\r\ncase 0x00:\r\ndmi->offset = 1;\r\nbreak;\r\ncase 0x01:\r\ndmi->offset = 4;\r\nbreak;\r\ncase 0x02:\r\ndmi->offset = 16;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n} else {\r\ndmi->base_addr = base_addr & 0xfffe;\r\ndmi->addr_space = IPMI_IO_ADDR_SPACE;\r\ndmi->offset = 1;\r\n}\r\ndmi->slave_addr = data[6];\r\nreturn 0;\r\n}\r\nstatic void try_init_dmi(struct dmi_ipmi_data *ipmi_data)\r\n{\r\nstruct smi_info *info;\r\ninfo = smi_info_alloc();\r\nif (!info) {\r\nprintk(KERN_ERR PFX "Could not allocate SI data\n");\r\nreturn;\r\n}\r\ninfo->addr_source = SI_SMBIOS;\r\nprintk(KERN_INFO PFX "probing via SMBIOS\n");\r\nswitch (ipmi_data->type) {\r\ncase 0x01:\r\ninfo->si_type = SI_KCS;\r\nbreak;\r\ncase 0x02:\r\ninfo->si_type = SI_SMIC;\r\nbreak;\r\ncase 0x03:\r\ninfo->si_type = SI_BT;\r\nbreak;\r\ndefault:\r\nkfree(info);\r\nreturn;\r\n}\r\nswitch (ipmi_data->addr_space) {\r\ncase IPMI_MEM_ADDR_SPACE:\r\ninfo->io_setup = mem_setup;\r\ninfo->io.addr_type = IPMI_MEM_ADDR_SPACE;\r\nbreak;\r\ncase IPMI_IO_ADDR_SPACE:\r\ninfo->io_setup = port_setup;\r\ninfo->io.addr_type = IPMI_IO_ADDR_SPACE;\r\nbreak;\r\ndefault:\r\nkfree(info);\r\nprintk(KERN_WARNING PFX "Unknown SMBIOS I/O Address type: %d\n",\r\nipmi_data->addr_space);\r\nreturn;\r\n}\r\ninfo->io.addr_data = ipmi_data->base_addr;\r\ninfo->io.regspacing = ipmi_data->offset;\r\nif (!info->io.regspacing)\r\ninfo->io.regspacing = DEFAULT_REGSPACING;\r\ninfo->io.regsize = DEFAULT_REGSPACING;\r\ninfo->io.regshift = 0;\r\ninfo->slave_addr = ipmi_data->slave_addr;\r\ninfo->irq = ipmi_data->irq;\r\nif (info->irq)\r\ninfo->irq_setup = std_irq_setup;\r\npr_info("ipmi_si: SMBIOS: %s %#lx regsize %d spacing %d irq %d\n",\r\n(info->io.addr_type == IPMI_IO_ADDR_SPACE) ? "io" : "mem",\r\ninfo->io.addr_data, info->io.regsize, info->io.regspacing,\r\ninfo->irq);\r\nif (add_smi(info))\r\nkfree(info);\r\n}\r\nstatic void dmi_find_bmc(void)\r\n{\r\nconst struct dmi_device *dev = NULL;\r\nstruct dmi_ipmi_data data;\r\nint rv;\r\nwhile ((dev = dmi_find_device(DMI_DEV_TYPE_IPMI, NULL, dev))) {\r\nmemset(&data, 0, sizeof(data));\r\nrv = decode_dmi((const struct dmi_header *) dev->device_data,\r\n&data);\r\nif (!rv)\r\ntry_init_dmi(&data);\r\n}\r\n}\r\nstatic void ipmi_pci_cleanup(struct smi_info *info)\r\n{\r\nstruct pci_dev *pdev = info->addr_source_data;\r\npci_disable_device(pdev);\r\n}\r\nstatic int ipmi_pci_probe_regspacing(struct smi_info *info)\r\n{\r\nif (info->si_type == SI_KCS) {\r\nunsigned char status;\r\nint regspacing;\r\ninfo->io.regsize = DEFAULT_REGSIZE;\r\ninfo->io.regshift = 0;\r\ninfo->io_size = 2;\r\ninfo->handlers = &kcs_smi_handlers;\r\nfor (regspacing = DEFAULT_REGSPACING; regspacing <= 16;) {\r\ninfo->io.regspacing = regspacing;\r\nif (info->io_setup(info)) {\r\ndev_err(info->dev,\r\n"Could not setup I/O space\n");\r\nreturn DEFAULT_REGSPACING;\r\n}\r\ninfo->io.outputb(&info->io, 1, 0x10);\r\nstatus = info->io.inputb(&info->io, 1);\r\ninfo->io_cleanup(info);\r\nif (status)\r\nreturn regspacing;\r\nregspacing *= 4;\r\n}\r\n}\r\nreturn DEFAULT_REGSPACING;\r\n}\r\nstatic int ipmi_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint rv;\r\nint class_type = pdev->class & PCI_ERMC_CLASSCODE_TYPE_MASK;\r\nstruct smi_info *info;\r\ninfo = smi_info_alloc();\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->addr_source = SI_PCI;\r\ndev_info(&pdev->dev, "probing via PCI");\r\nswitch (class_type) {\r\ncase PCI_ERMC_CLASSCODE_TYPE_SMIC:\r\ninfo->si_type = SI_SMIC;\r\nbreak;\r\ncase PCI_ERMC_CLASSCODE_TYPE_KCS:\r\ninfo->si_type = SI_KCS;\r\nbreak;\r\ncase PCI_ERMC_CLASSCODE_TYPE_BT:\r\ninfo->si_type = SI_BT;\r\nbreak;\r\ndefault:\r\nkfree(info);\r\ndev_info(&pdev->dev, "Unknown IPMI type: %d\n", class_type);\r\nreturn -ENOMEM;\r\n}\r\nrv = pci_enable_device(pdev);\r\nif (rv) {\r\ndev_err(&pdev->dev, "couldn't enable PCI device\n");\r\nkfree(info);\r\nreturn rv;\r\n}\r\ninfo->addr_source_cleanup = ipmi_pci_cleanup;\r\ninfo->addr_source_data = pdev;\r\nif (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {\r\ninfo->io_setup = port_setup;\r\ninfo->io.addr_type = IPMI_IO_ADDR_SPACE;\r\n} else {\r\ninfo->io_setup = mem_setup;\r\ninfo->io.addr_type = IPMI_MEM_ADDR_SPACE;\r\n}\r\ninfo->io.addr_data = pci_resource_start(pdev, 0);\r\ninfo->io.regspacing = ipmi_pci_probe_regspacing(info);\r\ninfo->io.regsize = DEFAULT_REGSIZE;\r\ninfo->io.regshift = 0;\r\ninfo->irq = pdev->irq;\r\nif (info->irq)\r\ninfo->irq_setup = std_irq_setup;\r\ninfo->dev = &pdev->dev;\r\npci_set_drvdata(pdev, info);\r\ndev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",\r\n&pdev->resource[0], info->io.regsize, info->io.regspacing,\r\ninfo->irq);\r\nrv = add_smi(info);\r\nif (rv) {\r\nkfree(info);\r\npci_disable_device(pdev);\r\n}\r\nreturn rv;\r\n}\r\nstatic void ipmi_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct smi_info *info = pci_get_drvdata(pdev);\r\ncleanup_one_si(info);\r\n}\r\nstatic int of_ipmi_probe(struct platform_device *dev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct smi_info *info;\r\nstruct resource resource;\r\nconst __be32 *regsize, *regspacing, *regshift;\r\nstruct device_node *np = dev->dev.of_node;\r\nint ret;\r\nint proplen;\r\ndev_info(&dev->dev, "probing via device tree\n");\r\nmatch = of_match_device(of_ipmi_match, &dev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nif (!of_device_is_available(np))\r\nreturn -EINVAL;\r\nret = of_address_to_resource(np, 0, &resource);\r\nif (ret) {\r\ndev_warn(&dev->dev, PFX "invalid address from OF\n");\r\nreturn ret;\r\n}\r\nregsize = of_get_property(np, "reg-size", &proplen);\r\nif (regsize && proplen != 4) {\r\ndev_warn(&dev->dev, PFX "invalid regsize from OF\n");\r\nreturn -EINVAL;\r\n}\r\nregspacing = of_get_property(np, "reg-spacing", &proplen);\r\nif (regspacing && proplen != 4) {\r\ndev_warn(&dev->dev, PFX "invalid regspacing from OF\n");\r\nreturn -EINVAL;\r\n}\r\nregshift = of_get_property(np, "reg-shift", &proplen);\r\nif (regshift && proplen != 4) {\r\ndev_warn(&dev->dev, PFX "invalid regshift from OF\n");\r\nreturn -EINVAL;\r\n}\r\ninfo = smi_info_alloc();\r\nif (!info) {\r\ndev_err(&dev->dev,\r\n"could not allocate memory for OF probe\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->si_type = (enum si_type) match->data;\r\ninfo->addr_source = SI_DEVICETREE;\r\ninfo->irq_setup = std_irq_setup;\r\nif (resource.flags & IORESOURCE_IO) {\r\ninfo->io_setup = port_setup;\r\ninfo->io.addr_type = IPMI_IO_ADDR_SPACE;\r\n} else {\r\ninfo->io_setup = mem_setup;\r\ninfo->io.addr_type = IPMI_MEM_ADDR_SPACE;\r\n}\r\ninfo->io.addr_data = resource.start;\r\ninfo->io.regsize = regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;\r\ninfo->io.regspacing = regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;\r\ninfo->io.regshift = regshift ? be32_to_cpup(regshift) : 0;\r\ninfo->irq = irq_of_parse_and_map(dev->dev.of_node, 0);\r\ninfo->dev = &dev->dev;\r\ndev_dbg(&dev->dev, "addr 0x%lx regsize %d spacing %d irq %d\n",\r\ninfo->io.addr_data, info->io.regsize, info->io.regspacing,\r\ninfo->irq);\r\ndev_set_drvdata(&dev->dev, info);\r\nret = add_smi(info);\r\nif (ret) {\r\nkfree(info);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int of_ipmi_probe(struct platform_device *dev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int acpi_ipmi_probe(struct platform_device *dev)\r\n{\r\nstruct smi_info *info;\r\nstruct resource *res, *res_second;\r\nacpi_handle handle;\r\nacpi_status status;\r\nunsigned long long tmp;\r\nint rv = -EINVAL;\r\nif (!si_tryacpi)\r\nreturn 0;\r\nhandle = ACPI_HANDLE(&dev->dev);\r\nif (!handle)\r\nreturn -ENODEV;\r\ninfo = smi_info_alloc();\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->addr_source = SI_ACPI;\r\ndev_info(&dev->dev, PFX "probing via ACPI\n");\r\ninfo->addr_info.acpi_info.acpi_handle = handle;\r\nstatus = acpi_evaluate_integer(handle, "_IFT", NULL, &tmp);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(&dev->dev, "Could not find ACPI IPMI interface type\n");\r\ngoto err_free;\r\n}\r\nswitch (tmp) {\r\ncase 1:\r\ninfo->si_type = SI_KCS;\r\nbreak;\r\ncase 2:\r\ninfo->si_type = SI_SMIC;\r\nbreak;\r\ncase 3:\r\ninfo->si_type = SI_BT;\r\nbreak;\r\ncase 4:\r\nrv = -ENODEV;\r\ngoto err_free;\r\ndefault:\r\ndev_info(&dev->dev, "unknown IPMI type %lld\n", tmp);\r\ngoto err_free;\r\n}\r\nres = platform_get_resource(dev, IORESOURCE_IO, 0);\r\nif (res) {\r\ninfo->io_setup = port_setup;\r\ninfo->io.addr_type = IPMI_IO_ADDR_SPACE;\r\n} else {\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (res) {\r\ninfo->io_setup = mem_setup;\r\ninfo->io.addr_type = IPMI_MEM_ADDR_SPACE;\r\n}\r\n}\r\nif (!res) {\r\ndev_err(&dev->dev, "no I/O or memory address\n");\r\ngoto err_free;\r\n}\r\ninfo->io.addr_data = res->start;\r\ninfo->io.regspacing = DEFAULT_REGSPACING;\r\nres_second = platform_get_resource(dev,\r\n(info->io.addr_type == IPMI_IO_ADDR_SPACE) ?\r\nIORESOURCE_IO : IORESOURCE_MEM,\r\n1);\r\nif (res_second) {\r\nif (res_second->start > info->io.addr_data)\r\ninfo->io.regspacing =\r\nres_second->start - info->io.addr_data;\r\n}\r\ninfo->io.regsize = DEFAULT_REGSPACING;\r\ninfo->io.regshift = 0;\r\nstatus = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);\r\nif (ACPI_SUCCESS(status)) {\r\ninfo->irq = tmp;\r\ninfo->irq_setup = acpi_gpe_irq_setup;\r\n} else {\r\nint irq = platform_get_irq(dev, 0);\r\nif (irq > 0) {\r\ninfo->irq = irq;\r\ninfo->irq_setup = std_irq_setup;\r\n}\r\n}\r\ninfo->dev = &dev->dev;\r\nplatform_set_drvdata(dev, info);\r\ndev_info(info->dev, "%pR regsize %d spacing %d irq %d\n",\r\nres, info->io.regsize, info->io.regspacing,\r\ninfo->irq);\r\nrv = add_smi(info);\r\nif (rv)\r\nkfree(info);\r\nreturn rv;\r\nerr_free:\r\nkfree(info);\r\nreturn rv;\r\n}\r\nstatic int acpi_ipmi_probe(struct platform_device *dev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int ipmi_probe(struct platform_device *dev)\r\n{\r\nif (of_ipmi_probe(dev) == 0)\r\nreturn 0;\r\nreturn acpi_ipmi_probe(dev);\r\n}\r\nstatic int ipmi_remove(struct platform_device *dev)\r\n{\r\nstruct smi_info *info = dev_get_drvdata(&dev->dev);\r\ncleanup_one_si(info);\r\nreturn 0;\r\n}\r\nstatic int ipmi_parisc_probe(struct parisc_device *dev)\r\n{\r\nstruct smi_info *info;\r\nint rv;\r\ninfo = smi_info_alloc();\r\nif (!info) {\r\ndev_err(&dev->dev,\r\n"could not allocate memory for PARISC probe\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->si_type = SI_KCS;\r\ninfo->addr_source = SI_DEVICETREE;\r\ninfo->io_setup = mem_setup;\r\ninfo->io.addr_type = IPMI_MEM_ADDR_SPACE;\r\ninfo->io.addr_data = dev->hpa.start;\r\ninfo->io.regsize = 1;\r\ninfo->io.regspacing = 1;\r\ninfo->io.regshift = 0;\r\ninfo->irq = 0;\r\ninfo->irq_setup = NULL;\r\ninfo->dev = &dev->dev;\r\ndev_dbg(&dev->dev, "addr 0x%lx\n", info->io.addr_data);\r\ndev_set_drvdata(&dev->dev, info);\r\nrv = add_smi(info);\r\nif (rv) {\r\nkfree(info);\r\nreturn rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipmi_parisc_remove(struct parisc_device *dev)\r\n{\r\ncleanup_one_si(dev_get_drvdata(&dev->dev));\r\nreturn 0;\r\n}\r\nstatic int wait_for_msg_done(struct smi_info *smi_info)\r\n{\r\nenum si_sm_result smi_result;\r\nsmi_result = smi_info->handlers->event(smi_info->si_sm, 0);\r\nfor (;;) {\r\nif (smi_result == SI_SM_CALL_WITH_DELAY ||\r\nsmi_result == SI_SM_CALL_WITH_TICK_DELAY) {\r\nschedule_timeout_uninterruptible(1);\r\nsmi_result = smi_info->handlers->event(\r\nsmi_info->si_sm, jiffies_to_usecs(1));\r\n} else if (smi_result == SI_SM_CALL_WITHOUT_DELAY) {\r\nsmi_result = smi_info->handlers->event(\r\nsmi_info->si_sm, 0);\r\n} else\r\nbreak;\r\n}\r\nif (smi_result == SI_SM_HOSED)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int try_get_dev_id(struct smi_info *smi_info)\r\n{\r\nunsigned char msg[2];\r\nunsigned char *resp;\r\nunsigned long resp_len;\r\nint rv = 0;\r\nresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\r\nif (!resp)\r\nreturn -ENOMEM;\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_GET_DEVICE_ID_CMD;\r\nsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);\r\nrv = wait_for_msg_done(smi_info);\r\nif (rv)\r\ngoto out;\r\nresp_len = smi_info->handlers->get_result(smi_info->si_sm,\r\nresp, IPMI_MAX_MSG_LENGTH);\r\nrv = ipmi_demangle_device_id(resp, resp_len, &smi_info->device_id);\r\nout:\r\nkfree(resp);\r\nreturn rv;\r\n}\r\nstatic int get_global_enables(struct smi_info *smi_info, u8 *enables)\r\n{\r\nunsigned char msg[3];\r\nunsigned char *resp;\r\nunsigned long resp_len;\r\nint rv;\r\nresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\r\nif (!resp)\r\nreturn -ENOMEM;\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;\r\nsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);\r\nrv = wait_for_msg_done(smi_info);\r\nif (rv) {\r\ndev_warn(smi_info->dev,\r\n"Error getting response from get global enables command: %d\n",\r\nrv);\r\ngoto out;\r\n}\r\nresp_len = smi_info->handlers->get_result(smi_info->si_sm,\r\nresp, IPMI_MAX_MSG_LENGTH);\r\nif (resp_len < 4 ||\r\nresp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||\r\nresp[1] != IPMI_GET_BMC_GLOBAL_ENABLES_CMD ||\r\nresp[2] != 0) {\r\ndev_warn(smi_info->dev,\r\n"Invalid return from get global enables command: %ld %x %x %x\n",\r\nresp_len, resp[0], resp[1], resp[2]);\r\nrv = -EINVAL;\r\ngoto out;\r\n} else {\r\n*enables = resp[3];\r\n}\r\nout:\r\nkfree(resp);\r\nreturn rv;\r\n}\r\nstatic int set_global_enables(struct smi_info *smi_info, u8 enables)\r\n{\r\nunsigned char msg[3];\r\nunsigned char *resp;\r\nunsigned long resp_len;\r\nint rv;\r\nresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\r\nif (!resp)\r\nreturn -ENOMEM;\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;\r\nmsg[2] = enables;\r\nsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 3);\r\nrv = wait_for_msg_done(smi_info);\r\nif (rv) {\r\ndev_warn(smi_info->dev,\r\n"Error getting response from set global enables command: %d\n",\r\nrv);\r\ngoto out;\r\n}\r\nresp_len = smi_info->handlers->get_result(smi_info->si_sm,\r\nresp, IPMI_MAX_MSG_LENGTH);\r\nif (resp_len < 3 ||\r\nresp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||\r\nresp[1] != IPMI_SET_BMC_GLOBAL_ENABLES_CMD) {\r\ndev_warn(smi_info->dev,\r\n"Invalid return from set global enables command: %ld %x %x\n",\r\nresp_len, resp[0], resp[1]);\r\nrv = -EINVAL;\r\ngoto out;\r\n}\r\nif (resp[2] != 0)\r\nrv = 1;\r\nout:\r\nkfree(resp);\r\nreturn rv;\r\n}\r\nstatic void check_clr_rcv_irq(struct smi_info *smi_info)\r\n{\r\nu8 enables = 0;\r\nint rv;\r\nrv = get_global_enables(smi_info, &enables);\r\nif (!rv) {\r\nif ((enables & IPMI_BMC_RCV_MSG_INTR) == 0)\r\nreturn;\r\nenables &= ~IPMI_BMC_RCV_MSG_INTR;\r\nrv = set_global_enables(smi_info, enables);\r\n}\r\nif (rv < 0) {\r\ndev_err(smi_info->dev,\r\n"Cannot check clearing the rcv irq: %d\n", rv);\r\nreturn;\r\n}\r\nif (rv) {\r\ndev_warn(smi_info->dev,\r\n"The BMC does not support clearing the recv irq bit, compensating, but the BMC needs to be fixed.\n");\r\nsmi_info->cannot_disable_irq = true;\r\n}\r\n}\r\nstatic void check_set_rcv_irq(struct smi_info *smi_info)\r\n{\r\nu8 enables = 0;\r\nint rv;\r\nif (!smi_info->irq)\r\nreturn;\r\nrv = get_global_enables(smi_info, &enables);\r\nif (!rv) {\r\nenables |= IPMI_BMC_RCV_MSG_INTR;\r\nrv = set_global_enables(smi_info, enables);\r\n}\r\nif (rv < 0) {\r\ndev_err(smi_info->dev,\r\n"Cannot check setting the rcv irq: %d\n", rv);\r\nreturn;\r\n}\r\nif (rv) {\r\ndev_warn(smi_info->dev,\r\n"The BMC does not support setting the recv irq bit, compensating, but the BMC needs to be fixed.\n");\r\nsmi_info->cannot_disable_irq = true;\r\nsmi_info->irq_enable_broken = true;\r\n}\r\n}\r\nstatic int try_enable_event_buffer(struct smi_info *smi_info)\r\n{\r\nunsigned char msg[3];\r\nunsigned char *resp;\r\nunsigned long resp_len;\r\nint rv = 0;\r\nresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\r\nif (!resp)\r\nreturn -ENOMEM;\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;\r\nsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);\r\nrv = wait_for_msg_done(smi_info);\r\nif (rv) {\r\nprintk(KERN_WARNING PFX "Error getting response from get"\r\n" global enables command, the event buffer is not"\r\n" enabled.\n");\r\ngoto out;\r\n}\r\nresp_len = smi_info->handlers->get_result(smi_info->si_sm,\r\nresp, IPMI_MAX_MSG_LENGTH);\r\nif (resp_len < 4 ||\r\nresp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||\r\nresp[1] != IPMI_GET_BMC_GLOBAL_ENABLES_CMD ||\r\nresp[2] != 0) {\r\nprintk(KERN_WARNING PFX "Invalid return from get global"\r\n" enables command, cannot enable the event buffer.\n");\r\nrv = -EINVAL;\r\ngoto out;\r\n}\r\nif (resp[3] & IPMI_BMC_EVT_MSG_BUFF) {\r\nsmi_info->supports_event_msg_buff = true;\r\ngoto out;\r\n}\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;\r\nmsg[2] = resp[3] | IPMI_BMC_EVT_MSG_BUFF;\r\nsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 3);\r\nrv = wait_for_msg_done(smi_info);\r\nif (rv) {\r\nprintk(KERN_WARNING PFX "Error getting response from set"\r\n" global, enables command, the event buffer is not"\r\n" enabled.\n");\r\ngoto out;\r\n}\r\nresp_len = smi_info->handlers->get_result(smi_info->si_sm,\r\nresp, IPMI_MAX_MSG_LENGTH);\r\nif (resp_len < 3 ||\r\nresp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2 ||\r\nresp[1] != IPMI_SET_BMC_GLOBAL_ENABLES_CMD) {\r\nprintk(KERN_WARNING PFX "Invalid return from get global,"\r\n"enables command, not enable the event buffer.\n");\r\nrv = -EINVAL;\r\ngoto out;\r\n}\r\nif (resp[2] != 0)\r\nrv = -ENOENT;\r\nelse\r\nsmi_info->supports_event_msg_buff = true;\r\nout:\r\nkfree(resp);\r\nreturn rv;\r\n}\r\nstatic int smi_type_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct smi_info *smi = m->private;\r\nseq_printf(m, "%s\n", si_to_str[smi->si_type]);\r\nreturn 0;\r\n}\r\nstatic int smi_type_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, smi_type_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int smi_si_stats_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct smi_info *smi = m->private;\r\nseq_printf(m, "interrupts_enabled: %d\n",\r\nsmi->irq && !smi->interrupt_disabled);\r\nseq_printf(m, "short_timeouts: %u\n",\r\nsmi_get_stat(smi, short_timeouts));\r\nseq_printf(m, "long_timeouts: %u\n",\r\nsmi_get_stat(smi, long_timeouts));\r\nseq_printf(m, "idles: %u\n",\r\nsmi_get_stat(smi, idles));\r\nseq_printf(m, "interrupts: %u\n",\r\nsmi_get_stat(smi, interrupts));\r\nseq_printf(m, "attentions: %u\n",\r\nsmi_get_stat(smi, attentions));\r\nseq_printf(m, "flag_fetches: %u\n",\r\nsmi_get_stat(smi, flag_fetches));\r\nseq_printf(m, "hosed_count: %u\n",\r\nsmi_get_stat(smi, hosed_count));\r\nseq_printf(m, "complete_transactions: %u\n",\r\nsmi_get_stat(smi, complete_transactions));\r\nseq_printf(m, "events: %u\n",\r\nsmi_get_stat(smi, events));\r\nseq_printf(m, "watchdog_pretimeouts: %u\n",\r\nsmi_get_stat(smi, watchdog_pretimeouts));\r\nseq_printf(m, "incoming_messages: %u\n",\r\nsmi_get_stat(smi, incoming_messages));\r\nreturn 0;\r\n}\r\nstatic int smi_si_stats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, smi_si_stats_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int smi_params_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct smi_info *smi = m->private;\r\nseq_printf(m,\r\n"%s,%s,0x%lx,rsp=%d,rsi=%d,rsh=%d,irq=%d,ipmb=%d\n",\r\nsi_to_str[smi->si_type],\r\naddr_space_to_str[smi->io.addr_type],\r\nsmi->io.addr_data,\r\nsmi->io.regspacing,\r\nsmi->io.regsize,\r\nsmi->io.regshift,\r\nsmi->irq,\r\nsmi->slave_addr);\r\nreturn 0;\r\n}\r\nstatic int smi_params_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, smi_params_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int oem_data_avail_to_receive_msg_avail(struct smi_info *smi_info)\r\n{\r\nsmi_info->msg_flags = ((smi_info->msg_flags & ~OEM_DATA_AVAIL) |\r\nRECEIVE_MSG_AVAIL);\r\nreturn 1;\r\n}\r\nstatic void setup_dell_poweredge_oem_data_handler(struct smi_info *smi_info)\r\n{\r\nstruct ipmi_device_id *id = &smi_info->device_id;\r\nif (id->manufacturer_id == DELL_IANA_MFR_ID) {\r\nif (id->device_id == DELL_POWEREDGE_8G_BMC_DEVICE_ID &&\r\nid->device_revision == DELL_POWEREDGE_8G_BMC_DEVICE_REV &&\r\nid->ipmi_version == DELL_POWEREDGE_8G_BMC_IPMI_VERSION) {\r\nsmi_info->oem_data_avail_handler =\r\noem_data_avail_to_receive_msg_avail;\r\n} else if (ipmi_version_major(id) < 1 ||\r\n(ipmi_version_major(id) == 1 &&\r\nipmi_version_minor(id) < 5)) {\r\nsmi_info->oem_data_avail_handler =\r\noem_data_avail_to_receive_msg_avail;\r\n}\r\n}\r\n}\r\nstatic void return_hosed_msg_badsize(struct smi_info *smi_info)\r\n{\r\nstruct ipmi_smi_msg *msg = smi_info->curr_msg;\r\nmsg->rsp[0] = msg->data[0] | 4;\r\nmsg->rsp[1] = msg->data[1];\r\nmsg->rsp[2] = CANNOT_RETURN_REQUESTED_LENGTH;\r\nmsg->rsp_size = 3;\r\nsmi_info->curr_msg = NULL;\r\ndeliver_recv_msg(smi_info, msg);\r\n}\r\nstatic int dell_poweredge_bt_xaction_handler(struct notifier_block *self,\r\nunsigned long unused,\r\nvoid *in)\r\n{\r\nstruct smi_info *smi_info = in;\r\nunsigned char *data = smi_info->curr_msg->data;\r\nunsigned int size = smi_info->curr_msg->data_size;\r\nif (size >= 8 &&\r\n(data[0]>>2) == STORAGE_NETFN &&\r\ndata[1] == STORAGE_CMD_GET_SDR &&\r\ndata[7] == 0x3A) {\r\nreturn_hosed_msg_badsize(smi_info);\r\nreturn NOTIFY_STOP;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void\r\nsetup_dell_poweredge_bt_xaction_handler(struct smi_info *smi_info)\r\n{\r\nstruct ipmi_device_id *id = &smi_info->device_id;\r\nif (id->manufacturer_id == DELL_IANA_MFR_ID &&\r\nsmi_info->si_type == SI_BT)\r\nregister_xaction_notifier(&dell_poweredge_bt_xaction_notifier);\r\n}\r\nstatic void setup_oem_data_handler(struct smi_info *smi_info)\r\n{\r\nsetup_dell_poweredge_oem_data_handler(smi_info);\r\n}\r\nstatic void setup_xaction_handlers(struct smi_info *smi_info)\r\n{\r\nsetup_dell_poweredge_bt_xaction_handler(smi_info);\r\n}\r\nstatic void check_for_broken_irqs(struct smi_info *smi_info)\r\n{\r\ncheck_clr_rcv_irq(smi_info);\r\ncheck_set_rcv_irq(smi_info);\r\n}\r\nstatic inline void wait_for_timer_and_thread(struct smi_info *smi_info)\r\n{\r\nif (smi_info->thread != NULL)\r\nkthread_stop(smi_info->thread);\r\nif (smi_info->timer_running)\r\ndel_timer_sync(&smi_info->si_timer);\r\n}\r\nstatic int is_new_interface(struct smi_info *info)\r\n{\r\nstruct smi_info *e;\r\nlist_for_each_entry(e, &smi_infos, link) {\r\nif (e->io.addr_type != info->io.addr_type)\r\ncontinue;\r\nif (e->io.addr_data == info->io.addr_data)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int add_smi(struct smi_info *new_smi)\r\n{\r\nint rv = 0;\r\nprintk(KERN_INFO PFX "Adding %s-specified %s state machine",\r\nipmi_addr_src_to_str(new_smi->addr_source),\r\nsi_to_str[new_smi->si_type]);\r\nmutex_lock(&smi_infos_lock);\r\nif (!is_new_interface(new_smi)) {\r\nprintk(KERN_CONT " duplicate interface\n");\r\nrv = -EBUSY;\r\ngoto out_err;\r\n}\r\nprintk(KERN_CONT "\n");\r\nnew_smi->intf = NULL;\r\nnew_smi->si_sm = NULL;\r\nnew_smi->handlers = NULL;\r\nlist_add_tail(&new_smi->link, &smi_infos);\r\nout_err:\r\nmutex_unlock(&smi_infos_lock);\r\nreturn rv;\r\n}\r\nstatic int try_smi_init(struct smi_info *new_smi)\r\n{\r\nint rv = 0;\r\nint i;\r\nprintk(KERN_INFO PFX "Trying %s-specified %s state"\r\n" machine at %s address 0x%lx, slave address 0x%x,"\r\n" irq %d\n",\r\nipmi_addr_src_to_str(new_smi->addr_source),\r\nsi_to_str[new_smi->si_type],\r\naddr_space_to_str[new_smi->io.addr_type],\r\nnew_smi->io.addr_data,\r\nnew_smi->slave_addr, new_smi->irq);\r\nswitch (new_smi->si_type) {\r\ncase SI_KCS:\r\nnew_smi->handlers = &kcs_smi_handlers;\r\nbreak;\r\ncase SI_SMIC:\r\nnew_smi->handlers = &smic_smi_handlers;\r\nbreak;\r\ncase SI_BT:\r\nnew_smi->handlers = &bt_smi_handlers;\r\nbreak;\r\ndefault:\r\nrv = -EIO;\r\ngoto out_err;\r\n}\r\nnew_smi->si_sm = kmalloc(new_smi->handlers->size(), GFP_KERNEL);\r\nif (!new_smi->si_sm) {\r\nprintk(KERN_ERR PFX\r\n"Could not allocate state machine memory\n");\r\nrv = -ENOMEM;\r\ngoto out_err;\r\n}\r\nnew_smi->io_size = new_smi->handlers->init_data(new_smi->si_sm,\r\n&new_smi->io);\r\nrv = new_smi->io_setup(new_smi);\r\nif (rv) {\r\nprintk(KERN_ERR PFX "Could not set up I/O space\n");\r\ngoto out_err;\r\n}\r\nif (new_smi->handlers->detect(new_smi->si_sm)) {\r\nif (new_smi->addr_source)\r\nprintk(KERN_INFO PFX "Interface detection failed\n");\r\nrv = -ENODEV;\r\ngoto out_err;\r\n}\r\nrv = try_get_dev_id(new_smi);\r\nif (rv) {\r\nif (new_smi->addr_source)\r\nprintk(KERN_INFO PFX "There appears to be no BMC"\r\n" at this location\n");\r\ngoto out_err;\r\n}\r\nsetup_oem_data_handler(new_smi);\r\nsetup_xaction_handlers(new_smi);\r\ncheck_for_broken_irqs(new_smi);\r\nnew_smi->waiting_msg = NULL;\r\nnew_smi->curr_msg = NULL;\r\natomic_set(&new_smi->req_events, 0);\r\nnew_smi->run_to_completion = false;\r\nfor (i = 0; i < SI_NUM_STATS; i++)\r\natomic_set(&new_smi->stats[i], 0);\r\nnew_smi->interrupt_disabled = true;\r\natomic_set(&new_smi->need_watch, 0);\r\nnew_smi->intf_num = smi_num;\r\nsmi_num++;\r\nrv = try_enable_event_buffer(new_smi);\r\nif (rv == 0)\r\nnew_smi->has_event_buffer = true;\r\nstart_clear_flags(new_smi, false);\r\nif (new_smi->irq) {\r\nnew_smi->interrupt_disabled = false;\r\natomic_set(&new_smi->req_events, 1);\r\n}\r\nif (!new_smi->dev) {\r\nnew_smi->pdev = platform_device_alloc("ipmi_si",\r\nnew_smi->intf_num);\r\nif (!new_smi->pdev) {\r\nprintk(KERN_ERR PFX\r\n"Unable to allocate platform device\n");\r\ngoto out_err;\r\n}\r\nnew_smi->dev = &new_smi->pdev->dev;\r\nnew_smi->dev->driver = &ipmi_driver.driver;\r\nrv = platform_device_add(new_smi->pdev);\r\nif (rv) {\r\nprintk(KERN_ERR PFX\r\n"Unable to register system interface device:"\r\n" %d\n",\r\nrv);\r\ngoto out_err;\r\n}\r\nnew_smi->dev_registered = true;\r\n}\r\nrv = ipmi_register_smi(&handlers,\r\nnew_smi,\r\n&new_smi->device_id,\r\nnew_smi->dev,\r\nnew_smi->slave_addr);\r\nif (rv) {\r\ndev_err(new_smi->dev, "Unable to register device: error %d\n",\r\nrv);\r\ngoto out_err_stop_timer;\r\n}\r\nrv = ipmi_smi_add_proc_entry(new_smi->intf, "type",\r\n&smi_type_proc_ops,\r\nnew_smi);\r\nif (rv) {\r\ndev_err(new_smi->dev, "Unable to create proc entry: %d\n", rv);\r\ngoto out_err_stop_timer;\r\n}\r\nrv = ipmi_smi_add_proc_entry(new_smi->intf, "si_stats",\r\n&smi_si_stats_proc_ops,\r\nnew_smi);\r\nif (rv) {\r\ndev_err(new_smi->dev, "Unable to create proc entry: %d\n", rv);\r\ngoto out_err_stop_timer;\r\n}\r\nrv = ipmi_smi_add_proc_entry(new_smi->intf, "params",\r\n&smi_params_proc_ops,\r\nnew_smi);\r\nif (rv) {\r\ndev_err(new_smi->dev, "Unable to create proc entry: %d\n", rv);\r\ngoto out_err_stop_timer;\r\n}\r\ndev_info(new_smi->dev, "IPMI %s interface initialized\n",\r\nsi_to_str[new_smi->si_type]);\r\nreturn 0;\r\nout_err_stop_timer:\r\nwait_for_timer_and_thread(new_smi);\r\nout_err:\r\nnew_smi->interrupt_disabled = true;\r\nif (new_smi->intf) {\r\nipmi_smi_t intf = new_smi->intf;\r\nnew_smi->intf = NULL;\r\nipmi_unregister_smi(intf);\r\n}\r\nif (new_smi->irq_cleanup) {\r\nnew_smi->irq_cleanup(new_smi);\r\nnew_smi->irq_cleanup = NULL;\r\n}\r\nsynchronize_sched();\r\nif (new_smi->si_sm) {\r\nif (new_smi->handlers)\r\nnew_smi->handlers->cleanup(new_smi->si_sm);\r\nkfree(new_smi->si_sm);\r\nnew_smi->si_sm = NULL;\r\n}\r\nif (new_smi->addr_source_cleanup) {\r\nnew_smi->addr_source_cleanup(new_smi);\r\nnew_smi->addr_source_cleanup = NULL;\r\n}\r\nif (new_smi->io_cleanup) {\r\nnew_smi->io_cleanup(new_smi);\r\nnew_smi->io_cleanup = NULL;\r\n}\r\nif (new_smi->dev_registered) {\r\nplatform_device_unregister(new_smi->pdev);\r\nnew_smi->dev_registered = false;\r\n}\r\nreturn rv;\r\n}\r\nstatic int init_ipmi_si(void)\r\n{\r\nint i;\r\nchar *str;\r\nint rv;\r\nstruct smi_info *e;\r\nenum ipmi_addr_src type = SI_INVALID;\r\nif (initialized)\r\nreturn 0;\r\ninitialized = 1;\r\nif (si_tryplatform) {\r\nrv = platform_driver_register(&ipmi_driver);\r\nif (rv) {\r\nprintk(KERN_ERR PFX "Unable to register "\r\n"driver: %d\n", rv);\r\nreturn rv;\r\n}\r\n}\r\nstr = si_type_str;\r\nif (*str != '\0') {\r\nfor (i = 0; (i < SI_MAX_PARMS) && (*str != '\0'); i++) {\r\nsi_type[i] = str;\r\nstr = strchr(str, ',');\r\nif (str) {\r\n*str = '\0';\r\nstr++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nprintk(KERN_INFO "IPMI System Interface driver.\n");\r\nif (!hardcode_find_bmc())\r\nreturn 0;\r\n#ifdef CONFIG_PCI\r\nif (si_trypci) {\r\nrv = pci_register_driver(&ipmi_pci_driver);\r\nif (rv)\r\nprintk(KERN_ERR PFX "Unable to register "\r\n"PCI driver: %d\n", rv);\r\nelse\r\npci_registered = true;\r\n}\r\n#endif\r\n#ifdef CONFIG_DMI\r\nif (si_trydmi)\r\ndmi_find_bmc();\r\n#endif\r\n#ifdef CONFIG_ACPI\r\nif (si_tryacpi)\r\nspmi_find_bmc();\r\n#endif\r\n#ifdef CONFIG_PARISC\r\nregister_parisc_driver(&ipmi_parisc_driver);\r\nparisc_registered = true;\r\n#endif\r\nmutex_lock(&smi_infos_lock);\r\nlist_for_each_entry(e, &smi_infos, link) {\r\nif (e->irq && (!type || e->addr_source == type)) {\r\nif (!try_smi_init(e)) {\r\ntype = e->addr_source;\r\n}\r\n}\r\n}\r\nif (type) {\r\nmutex_unlock(&smi_infos_lock);\r\nreturn 0;\r\n}\r\nlist_for_each_entry(e, &smi_infos, link) {\r\nif (!e->irq && (!type || e->addr_source == type)) {\r\nif (!try_smi_init(e)) {\r\ntype = e->addr_source;\r\n}\r\n}\r\n}\r\nmutex_unlock(&smi_infos_lock);\r\nif (type)\r\nreturn 0;\r\nmutex_lock(&smi_infos_lock);\r\nif (unload_when_empty && list_empty(&smi_infos)) {\r\nmutex_unlock(&smi_infos_lock);\r\ncleanup_ipmi_si();\r\nprintk(KERN_WARNING PFX\r\n"Unable to find any System Interface(s)\n");\r\nreturn -ENODEV;\r\n} else {\r\nmutex_unlock(&smi_infos_lock);\r\nreturn 0;\r\n}\r\n}\r\nstatic void cleanup_one_si(struct smi_info *to_clean)\r\n{\r\nint rv = 0;\r\nif (!to_clean)\r\nreturn;\r\nif (to_clean->intf) {\r\nipmi_smi_t intf = to_clean->intf;\r\nto_clean->intf = NULL;\r\nrv = ipmi_unregister_smi(intf);\r\nif (rv) {\r\npr_err(PFX "Unable to unregister device: errno=%d\n",\r\nrv);\r\n}\r\n}\r\nif (to_clean->dev)\r\ndev_set_drvdata(to_clean->dev, NULL);\r\nlist_del(&to_clean->link);\r\nif (to_clean->irq_cleanup)\r\nto_clean->irq_cleanup(to_clean);\r\nwait_for_timer_and_thread(to_clean);\r\nwhile (to_clean->curr_msg || (to_clean->si_state != SI_NORMAL)) {\r\npoll(to_clean);\r\nschedule_timeout_uninterruptible(1);\r\n}\r\ndisable_si_irq(to_clean, false);\r\nwhile (to_clean->curr_msg || (to_clean->si_state != SI_NORMAL)) {\r\npoll(to_clean);\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nif (to_clean->handlers)\r\nto_clean->handlers->cleanup(to_clean->si_sm);\r\nkfree(to_clean->si_sm);\r\nif (to_clean->addr_source_cleanup)\r\nto_clean->addr_source_cleanup(to_clean);\r\nif (to_clean->io_cleanup)\r\nto_clean->io_cleanup(to_clean);\r\nif (to_clean->dev_registered)\r\nplatform_device_unregister(to_clean->pdev);\r\nkfree(to_clean);\r\n}\r\nstatic void cleanup_ipmi_si(void)\r\n{\r\nstruct smi_info *e, *tmp_e;\r\nif (!initialized)\r\nreturn;\r\n#ifdef CONFIG_PCI\r\nif (pci_registered)\r\npci_unregister_driver(&ipmi_pci_driver);\r\n#endif\r\n#ifdef CONFIG_PARISC\r\nif (parisc_registered)\r\nunregister_parisc_driver(&ipmi_parisc_driver);\r\n#endif\r\nplatform_driver_unregister(&ipmi_driver);\r\nmutex_lock(&smi_infos_lock);\r\nlist_for_each_entry_safe(e, tmp_e, &smi_infos, link)\r\ncleanup_one_si(e);\r\nmutex_unlock(&smi_infos_lock);\r\n}
