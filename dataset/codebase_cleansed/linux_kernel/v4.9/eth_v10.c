static int __init\r\netrax_ethernet_init(void)\r\n{\r\nstruct net_device *dev;\r\nstruct net_local* np;\r\nint i, err;\r\nprintk(KERN_INFO\r\n"ETRAX 100LX 10/100MBit ethernet v2.0 (c) 1998-2007 Axis Communications AB\n");\r\nif (cris_request_io_interface(if_eth, cardname)) {\r\nprintk(KERN_CRIT "etrax_ethernet_init failed to get IO interface\n");\r\nreturn -EBUSY;\r\n}\r\ndev = alloc_etherdev(sizeof(struct net_local));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nnp = netdev_priv(dev);\r\ndev->features |= NETIF_F_LLTX;\r\ndev->base_addr = (unsigned int)R_NETWORK_SA_0;\r\ndev->irq = NETWORK_DMA_RX_IRQ_NBR;\r\ndev->dma = NETWORK_RX_DMA_NBR;\r\ndev->ethtool_ops = &e100_ethtool_ops;\r\ndev->netdev_ops = &e100_netdev_ops;\r\nspin_lock_init(&np->lock);\r\nspin_lock_init(&np->led_lock);\r\nspin_lock_init(&np->transceiver_lock);\r\nfor (i = 0; i < NBR_OF_RX_DESC; i++) {\r\nRxDescList[i].skb = dev_alloc_skb(MAX_MEDIA_DATA_SIZE + 2 * L1_CACHE_BYTES);\r\nif (!RxDescList[i].skb)\r\nreturn -ENOMEM;\r\nRxDescList[i].descr.ctrl = 0;\r\nRxDescList[i].descr.sw_len = MAX_MEDIA_DATA_SIZE;\r\nRxDescList[i].descr.next = virt_to_phys(&RxDescList[i + 1]);\r\nRxDescList[i].descr.buf = L1_CACHE_ALIGN(virt_to_phys(RxDescList[i].skb->data));\r\nRxDescList[i].descr.status = 0;\r\nRxDescList[i].descr.hw_len = 0;\r\nprepare_rx_descriptor(&RxDescList[i].descr);\r\n}\r\nRxDescList[NBR_OF_RX_DESC - 1].descr.ctrl = d_eol;\r\nRxDescList[NBR_OF_RX_DESC - 1].descr.next = virt_to_phys(&RxDescList[0]);\r\nrx_queue_len = 0;\r\nfor (i = 0; i < NBR_OF_TX_DESC; i++) {\r\nTxDescList[i].descr.ctrl = 0;\r\nTxDescList[i].descr.sw_len = 0;\r\nTxDescList[i].descr.next = virt_to_phys(&TxDescList[i + 1].descr);\r\nTxDescList[i].descr.buf = 0;\r\nTxDescList[i].descr.status = 0;\r\nTxDescList[i].descr.hw_len = 0;\r\nTxDescList[i].skb = 0;\r\n}\r\nTxDescList[NBR_OF_TX_DESC - 1].descr.ctrl = d_eol;\r\nTxDescList[NBR_OF_TX_DESC - 1].descr.next = virt_to_phys(&TxDescList[0].descr);\r\nmyNextRxDesc = &RxDescList[0];\r\nmyLastRxDesc = &RxDescList[NBR_OF_RX_DESC - 1];\r\nmyFirstTxDesc = &TxDescList[0];\r\nmyNextTxDesc = &TxDescList[0];\r\nmyLastTxDesc = &TxDescList[NBR_OF_TX_DESC - 1];\r\nerr = register_netdev(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\ne100_set_mac_address(dev, &default_mac);\r\ncurrent_speed = 10;\r\ncurrent_speed_selection = 0;\r\nspeed_timer.expires = jiffies + NET_LINK_UP_CHECK_INTERVAL;\r\nspeed_timer.data = (unsigned long)dev;\r\nspeed_timer.function = e100_check_speed;\r\nclear_led_timer.function = e100_clear_network_leds;\r\nclear_led_timer.data = (unsigned long)dev;\r\nfull_duplex = 0;\r\ncurrent_duplex = autoneg;\r\nduplex_timer.expires = jiffies + NET_DUPLEX_CHECK_INTERVAL;\r\nduplex_timer.data = (unsigned long)dev;\r\nduplex_timer.function = e100_check_duplex;\r\nnp->mii_if.phy_id_mask = 0x1f;\r\nnp->mii_if.reg_num_mask = 0x1f;\r\nnp->mii_if.dev = dev;\r\nnp->mii_if.mdio_read = e100_get_mdio_reg;\r\nnp->mii_if.mdio_write = e100_set_mdio_reg;\r\n*R_NETWORK_GA_0 = 0x00000000;\r\n*R_NETWORK_GA_1 = 0x00000000;\r\nled_next_time = jiffies;\r\nreturn 0;\r\n}\r\nstatic int\r\ne100_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nspin_lock(&np->lock);\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\n*R_NETWORK_SA_0 = dev->dev_addr[0] | (dev->dev_addr[1] << 8) |\r\n(dev->dev_addr[2] << 16) | (dev->dev_addr[3] << 24);\r\n*R_NETWORK_SA_1 = dev->dev_addr[4] | (dev->dev_addr[5] << 8);\r\n*R_NETWORK_SA_2 = 0;\r\nprintk(KERN_INFO "%s: changed MAC to %pM\n", dev->name, dev->dev_addr);\r\nspin_unlock(&np->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\ne100_open(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\n*R_NETWORK_MGM_CTRL = IO_STATE(R_NETWORK_MGM_CTRL, mdoe, enable);\r\n*R_IRQ_MASK0_CLR =\r\nIO_STATE(R_IRQ_MASK0_CLR, overrun, clr) |\r\nIO_STATE(R_IRQ_MASK0_CLR, underrun, clr) |\r\nIO_STATE(R_IRQ_MASK0_CLR, excessive_col, clr);\r\n*R_IRQ_MASK2_CLR =\r\nIO_STATE(R_IRQ_MASK2_CLR, dma0_descr, clr) |\r\nIO_STATE(R_IRQ_MASK2_CLR, dma0_eop, clr) |\r\nIO_STATE(R_IRQ_MASK2_CLR, dma1_descr, clr) |\r\nIO_STATE(R_IRQ_MASK2_CLR, dma1_eop, clr);\r\nRESET_DMA(NETWORK_TX_DMA_NBR);\r\nRESET_DMA(NETWORK_RX_DMA_NBR);\r\nWAIT_DMA(NETWORK_TX_DMA_NBR);\r\nWAIT_DMA(NETWORK_RX_DMA_NBR);\r\nif (request_irq(NETWORK_DMA_RX_IRQ_NBR, e100rxtx_interrupt, 0, cardname,\r\n(void *)dev)) {\r\ngoto grace_exit0;\r\n}\r\nif (request_irq(NETWORK_DMA_TX_IRQ_NBR, e100rxtx_interrupt, 0,\r\ncardname, (void *)dev)) {\r\ngoto grace_exit1;\r\n}\r\nif (request_irq(NETWORK_STATUS_IRQ_NBR, e100nw_interrupt, 0,\r\ncardname, (void *)dev)) {\r\ngoto grace_exit2;\r\n}\r\nif (cris_request_dma(NETWORK_TX_DMA_NBR,\r\ncardname,\r\nDMA_VERBOSE_ON_ERROR,\r\ndma_eth)) {\r\ngoto grace_exit3;\r\n}\r\nif (cris_request_dma(NETWORK_RX_DMA_NBR,\r\ncardname,\r\nDMA_VERBOSE_ON_ERROR,\r\ndma_eth)) {\r\ngoto grace_exit4;\r\n}\r\n*R_NETWORK_SA_0 = dev->dev_addr[0] | (dev->dev_addr[1] << 8) |\r\n(dev->dev_addr[2] << 16) | (dev->dev_addr[3] << 24);\r\n*R_NETWORK_SA_1 = dev->dev_addr[4] | (dev->dev_addr[5] << 8);\r\n*R_NETWORK_SA_2 = 0;\r\n#if 0\r\n*R_NETWORK_GA_0 = 0xffffffff;\r\n*R_NETWORK_GA_1 = 0xffffffff;\r\n*R_NETWORK_REC_CONFIG = 0xd;\r\n#else\r\nSETS(network_rec_config_shadow, R_NETWORK_REC_CONFIG, max_size, size1522);\r\nSETS(network_rec_config_shadow, R_NETWORK_REC_CONFIG, broadcast, receive);\r\nSETS(network_rec_config_shadow, R_NETWORK_REC_CONFIG, ma0, enable);\r\nSETF(network_rec_config_shadow, R_NETWORK_REC_CONFIG, duplex, full_duplex);\r\n*R_NETWORK_REC_CONFIG = network_rec_config_shadow;\r\n#endif\r\n*R_NETWORK_GEN_CONFIG =\r\nIO_STATE(R_NETWORK_GEN_CONFIG, phy, mii_clk) |\r\nIO_STATE(R_NETWORK_GEN_CONFIG, enable, on);\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, clr_error, clr);\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, delay, none);\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, cancel, dont);\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, cd, enable);\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, retry, enable);\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, pad, enable);\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, crc, enable);\r\n*R_NETWORK_TR_CTRL = network_tr_ctrl_shadow;\r\nlocal_irq_save(flags);\r\n*R_IRQ_MASK2_SET =\r\nIO_STATE(R_IRQ_MASK2_SET, dma0_eop, set) |\r\nIO_STATE(R_IRQ_MASK2_SET, dma1_eop, set);\r\n*R_IRQ_MASK0_SET =\r\nIO_STATE(R_IRQ_MASK0_SET, overrun, set) |\r\nIO_STATE(R_IRQ_MASK0_SET, underrun, set) |\r\nIO_STATE(R_IRQ_MASK0_SET, excessive_col, set);\r\n*R_DMA_CH0_CLR_INTR = IO_STATE(R_DMA_CH0_CLR_INTR, clr_eop, do);\r\n*R_DMA_CH1_CLR_INTR = IO_STATE(R_DMA_CH1_CLR_INTR, clr_eop, do);\r\n(void)*R_REC_COUNTERS;\r\n(void)*R_TR_COUNTERS;\r\n*R_DMA_CH1_FIRST = virt_to_phys(myNextRxDesc);\r\n*R_DMA_CH1_CMD = IO_STATE(R_DMA_CH1_CMD, cmd, start);\r\n*R_DMA_CH0_FIRST = 0;\r\n*R_DMA_CH0_DESCR = virt_to_phys(myLastTxDesc);\r\nnetif_start_queue(dev);\r\nlocal_irq_restore(flags);\r\nif (e100_probe_transceiver(dev))\r\ngoto grace_exit5;\r\nadd_timer(&speed_timer);\r\nadd_timer(&duplex_timer);\r\nnetif_carrier_on(dev);\r\nreturn 0;\r\ngrace_exit5:\r\ncris_free_dma(NETWORK_RX_DMA_NBR, cardname);\r\ngrace_exit4:\r\ncris_free_dma(NETWORK_TX_DMA_NBR, cardname);\r\ngrace_exit3:\r\nfree_irq(NETWORK_STATUS_IRQ_NBR, (void *)dev);\r\ngrace_exit2:\r\nfree_irq(NETWORK_DMA_TX_IRQ_NBR, (void *)dev);\r\ngrace_exit1:\r\nfree_irq(NETWORK_DMA_RX_IRQ_NBR, (void *)dev);\r\ngrace_exit0:\r\nreturn -EAGAIN;\r\n}\r\nstatic void\r\ndummy_check_speed(struct net_device* dev)\r\n{\r\ncurrent_speed = 100;\r\n}\r\nstatic void\r\ngeneric_check_speed(struct net_device* dev)\r\n{\r\nunsigned long data;\r\nstruct net_local *np = netdev_priv(dev);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id, MII_ADVERTISE);\r\nif ((data & ADVERTISE_100FULL) ||\r\n(data & ADVERTISE_100HALF))\r\ncurrent_speed = 100;\r\nelse\r\ncurrent_speed = 10;\r\n}\r\nstatic void\r\ntdk_check_speed(struct net_device* dev)\r\n{\r\nunsigned long data;\r\nstruct net_local *np = netdev_priv(dev);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id,\r\nMDIO_TDK_DIAGNOSTIC_REG);\r\ncurrent_speed = (data & MDIO_TDK_DIAGNOSTIC_RATE ? 100 : 10);\r\n}\r\nstatic void\r\nbroadcom_check_speed(struct net_device* dev)\r\n{\r\nunsigned long data;\r\nstruct net_local *np = netdev_priv(dev);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id,\r\nMDIO_AUX_CTRL_STATUS_REG);\r\ncurrent_speed = (data & MDIO_BC_SPEED ? 100 : 10);\r\n}\r\nstatic void\r\nintel_check_speed(struct net_device* dev)\r\n{\r\nunsigned long data;\r\nstruct net_local *np = netdev_priv(dev);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id,\r\nMDIO_INT_STATUS_REG_2);\r\ncurrent_speed = (data & MDIO_INT_SPEED ? 100 : 10);\r\n}\r\nstatic void\r\ne100_check_speed(unsigned long priv)\r\n{\r\nstruct net_device* dev = (struct net_device*)priv;\r\nstruct net_local *np = netdev_priv(dev);\r\nstatic int led_initiated = 0;\r\nunsigned long data;\r\nint old_speed = current_speed;\r\nspin_lock(&np->transceiver_lock);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id, MII_BMSR);\r\nif (!(data & BMSR_LSTATUS)) {\r\ncurrent_speed = 0;\r\n} else {\r\ntransceiver->check_speed(dev);\r\n}\r\nspin_lock(&np->led_lock);\r\nif ((old_speed != current_speed) || !led_initiated) {\r\nled_initiated = 1;\r\ne100_set_network_leds(NO_NETWORK_ACTIVITY);\r\nif (current_speed)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\n}\r\nspin_unlock(&np->led_lock);\r\nspeed_timer.expires = jiffies + NET_LINK_UP_CHECK_INTERVAL;\r\nadd_timer(&speed_timer);\r\nspin_unlock(&np->transceiver_lock);\r\n}\r\nstatic void\r\ne100_negotiate(struct net_device* dev)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nunsigned short data = e100_get_mdio_reg(dev, np->mii_if.phy_id,\r\nMII_ADVERTISE);\r\ndata &= ~(ADVERTISE_100HALF | ADVERTISE_100FULL |\r\nADVERTISE_10HALF | ADVERTISE_10FULL);\r\nswitch (current_speed_selection) {\r\ncase 10:\r\nif (current_duplex == full)\r\ndata |= ADVERTISE_10FULL;\r\nelse if (current_duplex == half)\r\ndata |= ADVERTISE_10HALF;\r\nelse\r\ndata |= ADVERTISE_10HALF | ADVERTISE_10FULL;\r\nbreak;\r\ncase 100:\r\nif (current_duplex == full)\r\ndata |= ADVERTISE_100FULL;\r\nelse if (current_duplex == half)\r\ndata |= ADVERTISE_100HALF;\r\nelse\r\ndata |= ADVERTISE_100HALF | ADVERTISE_100FULL;\r\nbreak;\r\ncase 0:\r\nif (current_duplex == full)\r\ndata |= ADVERTISE_100FULL | ADVERTISE_10FULL;\r\nelse if (current_duplex == half)\r\ndata |= ADVERTISE_100HALF | ADVERTISE_10HALF;\r\nelse\r\ndata |= ADVERTISE_10HALF | ADVERTISE_10FULL |\r\nADVERTISE_100HALF | ADVERTISE_100FULL;\r\nbreak;\r\ndefault:\r\ndata |= ADVERTISE_10HALF | ADVERTISE_10FULL |\r\nADVERTISE_100HALF | ADVERTISE_100FULL;\r\nbreak;\r\n}\r\ne100_set_mdio_reg(dev, np->mii_if.phy_id, MII_ADVERTISE, data);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id, MII_BMCR);\r\nif (autoneg_normal) {\r\ndata |= BMCR_ANENABLE | BMCR_ANRESTART;\r\n} else {\r\ndata &= ~(BMCR_ANENABLE | BMCR_ANRESTART);\r\nif (current_speed_selection == 10)\r\ndata &= ~BMCR_SPEED100;\r\nelse\r\ndata |= BMCR_SPEED100;\r\nif (current_duplex != full)\r\ndata &= ~BMCR_FULLDPLX;\r\nelse\r\ndata |= BMCR_FULLDPLX;\r\n}\r\ne100_set_mdio_reg(dev, np->mii_if.phy_id, MII_BMCR, data);\r\n}\r\nstatic void\r\ne100_set_speed(struct net_device* dev, unsigned long speed)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nspin_lock(&np->transceiver_lock);\r\nif (speed != current_speed_selection) {\r\ncurrent_speed_selection = speed;\r\ne100_negotiate(dev);\r\n}\r\nspin_unlock(&np->transceiver_lock);\r\n}\r\nstatic void\r\ne100_check_duplex(unsigned long priv)\r\n{\r\nstruct net_device *dev = (struct net_device *)priv;\r\nstruct net_local *np = netdev_priv(dev);\r\nint old_duplex;\r\nspin_lock(&np->transceiver_lock);\r\nold_duplex = full_duplex;\r\ntransceiver->check_duplex(dev);\r\nif (old_duplex != full_duplex) {\r\nSETF(network_rec_config_shadow, R_NETWORK_REC_CONFIG, duplex, full_duplex);\r\n*R_NETWORK_REC_CONFIG = network_rec_config_shadow;\r\n}\r\nduplex_timer.expires = jiffies + NET_DUPLEX_CHECK_INTERVAL;\r\nadd_timer(&duplex_timer);\r\nnp->mii_if.full_duplex = full_duplex;\r\nspin_unlock(&np->transceiver_lock);\r\n}\r\nstatic void\r\ndummy_check_duplex(struct net_device* dev)\r\n{\r\nfull_duplex = 1;\r\n}\r\nstatic void\r\ngeneric_check_duplex(struct net_device* dev)\r\n{\r\nunsigned long data;\r\nstruct net_local *np = netdev_priv(dev);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id, MII_ADVERTISE);\r\nif ((data & ADVERTISE_10FULL) ||\r\n(data & ADVERTISE_100FULL))\r\nfull_duplex = 1;\r\nelse\r\nfull_duplex = 0;\r\n}\r\nstatic void\r\ntdk_check_duplex(struct net_device* dev)\r\n{\r\nunsigned long data;\r\nstruct net_local *np = netdev_priv(dev);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id,\r\nMDIO_TDK_DIAGNOSTIC_REG);\r\nfull_duplex = (data & MDIO_TDK_DIAGNOSTIC_DPLX) ? 1 : 0;\r\n}\r\nstatic void\r\nbroadcom_check_duplex(struct net_device* dev)\r\n{\r\nunsigned long data;\r\nstruct net_local *np = netdev_priv(dev);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id,\r\nMDIO_AUX_CTRL_STATUS_REG);\r\nfull_duplex = (data & MDIO_BC_FULL_DUPLEX_IND) ? 1 : 0;\r\n}\r\nstatic void\r\nintel_check_duplex(struct net_device* dev)\r\n{\r\nunsigned long data;\r\nstruct net_local *np = netdev_priv(dev);\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id,\r\nMDIO_INT_STATUS_REG_2);\r\nfull_duplex = (data & MDIO_INT_FULL_DUPLEX_IND) ? 1 : 0;\r\n}\r\nstatic void\r\ne100_set_duplex(struct net_device* dev, enum duplex new_duplex)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nspin_lock(&np->transceiver_lock);\r\nif (new_duplex != current_duplex) {\r\ncurrent_duplex = new_duplex;\r\ne100_negotiate(dev);\r\n}\r\nspin_unlock(&np->transceiver_lock);\r\n}\r\nstatic int\r\ne100_probe_transceiver(struct net_device* dev)\r\n{\r\nint ret = 0;\r\n#if !defined(CONFIG_ETRAX_NO_PHY)\r\nunsigned int phyid_high;\r\nunsigned int phyid_low;\r\nunsigned int oui;\r\nstruct transceiver_ops* ops = NULL;\r\nstruct net_local *np = netdev_priv(dev);\r\nspin_lock(&np->transceiver_lock);\r\nfor (np->mii_if.phy_id = 0; np->mii_if.phy_id <= 31;\r\nnp->mii_if.phy_id++) {\r\nif (e100_get_mdio_reg(dev,\r\nnp->mii_if.phy_id, MII_BMSR) != 0xffff)\r\nbreak;\r\n}\r\nif (np->mii_if.phy_id == 32) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nphyid_high = e100_get_mdio_reg(dev, np->mii_if.phy_id, MII_PHYSID1);\r\nphyid_low = e100_get_mdio_reg(dev, np->mii_if.phy_id, MII_PHYSID2);\r\noui = (phyid_high << 6) | (phyid_low >> 10);\r\nfor (ops = &transceivers[0]; ops->oui; ops++) {\r\nif (ops->oui == oui)\r\nbreak;\r\n}\r\ntransceiver = ops;\r\nout:\r\nspin_unlock(&np->transceiver_lock);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int\r\ne100_get_mdio_reg(struct net_device *dev, int phy_id, int location)\r\n{\r\nunsigned short cmd;\r\nint data;\r\nint bitCounter;\r\ncmd = (MDIO_START << 14) | (MDIO_READ << 12) | (phy_id << 7) |\r\n(location << 2);\r\ne100_send_mdio_cmd(cmd, 0);\r\ndata = 0;\r\nfor (bitCounter=15; bitCounter>=0 ; bitCounter--) {\r\ndata |= (e100_receive_mdio_bit() << bitCounter);\r\n}\r\nreturn data;\r\n}\r\nstatic void\r\ne100_set_mdio_reg(struct net_device *dev, int phy_id, int location, int value)\r\n{\r\nint bitCounter;\r\nunsigned short cmd;\r\ncmd = (MDIO_START << 14) | (MDIO_WRITE << 12) | (phy_id << 7) |\r\n(location << 2);\r\ne100_send_mdio_cmd(cmd, 1);\r\nfor (bitCounter=15; bitCounter>=0 ; bitCounter--) {\r\ne100_send_mdio_bit(GET_BIT(bitCounter, value));\r\n}\r\n}\r\nstatic void\r\ne100_send_mdio_cmd(unsigned short cmd, int write_cmd)\r\n{\r\nint bitCounter;\r\nunsigned char data = 0x2;\r\nfor (bitCounter = 31; bitCounter>= 0; bitCounter--)\r\ne100_send_mdio_bit(GET_BIT(bitCounter, MDIO_PREAMBLE));\r\nfor (bitCounter = 15; bitCounter >= 2; bitCounter--)\r\ne100_send_mdio_bit(GET_BIT(bitCounter, cmd));\r\nfor (bitCounter = 1; bitCounter >= 0 ; bitCounter--)\r\nif (write_cmd)\r\ne100_send_mdio_bit(GET_BIT(bitCounter, data));\r\nelse\r\ne100_receive_mdio_bit();\r\n}\r\nstatic void\r\ne100_send_mdio_bit(unsigned char bit)\r\n{\r\n*R_NETWORK_MGM_CTRL =\r\nIO_STATE(R_NETWORK_MGM_CTRL, mdoe, enable) |\r\nIO_FIELD(R_NETWORK_MGM_CTRL, mdio, bit);\r\nudelay(1);\r\n*R_NETWORK_MGM_CTRL =\r\nIO_STATE(R_NETWORK_MGM_CTRL, mdoe, enable) |\r\nIO_MASK(R_NETWORK_MGM_CTRL, mdck) |\r\nIO_FIELD(R_NETWORK_MGM_CTRL, mdio, bit);\r\nudelay(1);\r\n}\r\nstatic unsigned char\r\ne100_receive_mdio_bit(void)\r\n{\r\nunsigned char bit;\r\n*R_NETWORK_MGM_CTRL = 0;\r\nbit = IO_EXTRACT(R_NETWORK_STAT, mdio, *R_NETWORK_STAT);\r\nudelay(1);\r\n*R_NETWORK_MGM_CTRL = IO_MASK(R_NETWORK_MGM_CTRL, mdck);\r\nudelay(1);\r\nreturn bit;\r\n}\r\nstatic void\r\ne100_reset_transceiver(struct net_device* dev)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nunsigned short cmd;\r\nunsigned short data;\r\nint bitCounter;\r\ndata = e100_get_mdio_reg(dev, np->mii_if.phy_id, MII_BMCR);\r\ncmd = (MDIO_START << 14) | (MDIO_WRITE << 12) | (np->mii_if.phy_id << 7) | (MII_BMCR << 2);\r\ne100_send_mdio_cmd(cmd, 1);\r\ndata |= 0x8000;\r\nfor (bitCounter = 15; bitCounter >= 0 ; bitCounter--) {\r\ne100_send_mdio_bit(GET_BIT(bitCounter, data));\r\n}\r\n}\r\nstatic void\r\ne100_tx_timeout(struct net_device *dev)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&np->lock, flags);\r\nprintk(KERN_WARNING "%s: transmit timed out, %s?\n", dev->name,\r\ntx_done(dev) ? "IRQ problem" : "network cable problem");\r\ndev->stats.tx_errors++;\r\nRESET_DMA(NETWORK_TX_DMA_NBR);\r\nWAIT_DMA(NETWORK_TX_DMA_NBR);\r\ne100_reset_transceiver(dev);\r\nwhile (myFirstTxDesc != myNextTxDesc) {\r\ndev_kfree_skb(myFirstTxDesc->skb);\r\nmyFirstTxDesc->skb = 0;\r\nmyFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);\r\n}\r\n*R_DMA_CH0_FIRST = 0;\r\n*R_DMA_CH0_DESCR = virt_to_phys(myLastTxDesc);\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&np->lock, flags);\r\n}\r\nstatic int\r\ne100_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nunsigned char *buf = skb->data;\r\nunsigned long flags;\r\n#ifdef ETHDEBUG\r\nprintk("send packet len %d\n", length);\r\n#endif\r\nspin_lock_irqsave(&np->lock, flags);\r\nmyNextTxDesc->skb = skb;\r\nnetif_trans_update(dev);\r\ne100_hardware_send_packet(np, buf, skb->len);\r\nmyNextTxDesc = phys_to_virt(myNextTxDesc->descr.next);\r\nif (myNextTxDesc == myFirstTxDesc) {\r\nnetif_stop_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\ne100rxtx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nunsigned long irqbits;\r\nirqbits = *R_IRQ_MASK2_RD;\r\nif (irqbits & IO_STATE(R_IRQ_MASK2_RD, dma1_eop, active)) {\r\n*R_DMA_CH1_CLR_INTR = IO_STATE(R_DMA_CH1_CLR_INTR, clr_eop, do);\r\nwhile ((*R_DMA_CH1_FIRST != virt_to_phys(myNextRxDesc)) &&\r\n(myNextRxDesc != myLastRxDesc)) {\r\ne100_rx(dev);\r\ndev->stats.rx_packets++;\r\n*R_DMA_CH1_CMD = IO_STATE(R_DMA_CH1_CMD, cmd, restart);\r\n*R_DMA_CH1_CLR_INTR =\r\nIO_STATE(R_DMA_CH1_CLR_INTR, clr_eop, do) |\r\nIO_STATE(R_DMA_CH1_CLR_INTR, clr_descr, do);\r\n}\r\n}\r\nwhile (virt_to_phys(myFirstTxDesc) != *R_DMA_CH0_FIRST &&\r\n(netif_queue_stopped(dev) || myFirstTxDesc != myNextTxDesc)) {\r\ndev->stats.tx_bytes += myFirstTxDesc->skb->len;\r\ndev->stats.tx_packets++;\r\ndev_kfree_skb_irq(myFirstTxDesc->skb);\r\nmyFirstTxDesc->skb = 0;\r\nmyFirstTxDesc = phys_to_virt(myFirstTxDesc->descr.next);\r\nnetif_wake_queue(dev);\r\n}\r\nif (irqbits & IO_STATE(R_IRQ_MASK2_RD, dma0_eop, active)) {\r\n*R_DMA_CH0_CLR_INTR = IO_STATE(R_DMA_CH0_CLR_INTR, clr_eop, do);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\ne100nw_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nunsigned long irqbits = *R_IRQ_MASK0_RD;\r\nif (irqbits & IO_STATE(R_IRQ_MASK0_RD, underrun, active)) {\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, clr_error, clr);\r\n*R_NETWORK_TR_CTRL = network_tr_ctrl_shadow;\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, clr_error, nop);\r\ndev->stats.tx_errors++;\r\nD(printk("ethernet receiver underrun!\n"));\r\n}\r\nif (irqbits & IO_STATE(R_IRQ_MASK0_RD, overrun, active)) {\r\nupdate_rx_stats(&dev->stats);\r\nD(printk("ethernet receiver overrun!\n"));\r\n}\r\nif (irqbits & IO_STATE(R_IRQ_MASK0_RD, excessive_col, active)) {\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, clr_error, clr);\r\n*R_NETWORK_TR_CTRL = network_tr_ctrl_shadow;\r\nSETS(network_tr_ctrl_shadow, R_NETWORK_TR_CTRL, clr_error, nop);\r\ndev->stats.tx_errors++;\r\nD(printk("ethernet excessive collisions!\n"));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\ne100_rx(struct net_device *dev)\r\n{\r\nstruct sk_buff *skb;\r\nint length = 0;\r\nstruct net_local *np = netdev_priv(dev);\r\nunsigned char *skb_data_ptr;\r\n#ifdef ETHDEBUG\r\nint i;\r\n#endif\r\netrax_eth_descr *prevRxDesc;\r\nspin_lock(&np->led_lock);\r\nif (!led_active && time_after(jiffies, led_next_time)) {\r\ne100_set_network_leds(NETWORK_ACTIVITY);\r\nled_next_time = jiffies + NET_FLASH_TIME;\r\nled_active = 1;\r\nmod_timer(&clear_led_timer, jiffies + HZ/10);\r\n}\r\nspin_unlock(&np->led_lock);\r\nlength = myNextRxDesc->descr.hw_len - 4;\r\ndev->stats.rx_bytes += length;\r\n#ifdef ETHDEBUG\r\nprintk("Got a packet of length %d:\n", length);\r\nskb_data_ptr = (unsigned char *)phys_to_virt(myNextRxDesc->descr.buf);\r\nfor (i = 0; i < 8; i++) {\r\nprintk("%d: %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n", i * 8,\r\nskb_data_ptr[0],skb_data_ptr[1],skb_data_ptr[2],skb_data_ptr[3],\r\nskb_data_ptr[4],skb_data_ptr[5],skb_data_ptr[6],skb_data_ptr[7]);\r\nskb_data_ptr += 8;\r\n}\r\n#endif\r\nif (length < RX_COPYBREAK) {\r\nskb = dev_alloc_skb(length - ETHER_HEAD_LEN);\r\nif (!skb) {\r\ndev->stats.rx_errors++;\r\nprintk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n", dev->name);\r\ngoto update_nextrxdesc;\r\n}\r\nskb_put(skb, length - ETHER_HEAD_LEN);\r\nskb_data_ptr = skb_push(skb, ETHER_HEAD_LEN);\r\n#ifdef ETHDEBUG\r\nprintk("head = 0x%x, data = 0x%x, tail = 0x%x, end = 0x%x\n",\r\nskb->head, skb->data, skb_tail_pointer(skb),\r\nskb_end_pointer(skb));\r\nprintk("copying packet to 0x%x.\n", skb_data_ptr);\r\n#endif\r\nmemcpy(skb_data_ptr, phys_to_virt(myNextRxDesc->descr.buf), length);\r\n}\r\nelse {\r\nint align;\r\nstruct sk_buff *new_skb = dev_alloc_skb(MAX_MEDIA_DATA_SIZE + 2 * L1_CACHE_BYTES);\r\nif (!new_skb) {\r\ndev->stats.rx_errors++;\r\nprintk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n", dev->name);\r\ngoto update_nextrxdesc;\r\n}\r\nskb = myNextRxDesc->skb;\r\nalign = (int)phys_to_virt(myNextRxDesc->descr.buf) - (int)skb->data;\r\nskb_put(skb, length + align);\r\nskb_pull(skb, align);\r\nmyNextRxDesc->skb = new_skb;\r\nmyNextRxDesc->descr.buf = L1_CACHE_ALIGN(virt_to_phys(myNextRxDesc->skb->data));\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\nupdate_nextrxdesc:\r\nmyNextRxDesc->descr.status = 0;\r\nprevRxDesc = myNextRxDesc;\r\nmyNextRxDesc = phys_to_virt(myNextRxDesc->descr.next);\r\nrx_queue_len++;\r\nif (rx_queue_len == RX_QUEUE_THRESHOLD) {\r\nflush_etrax_cache();\r\nprevRxDesc->descr.ctrl |= d_eol;\r\nmyLastRxDesc->descr.ctrl &= ~d_eol;\r\nmyLastRxDesc = prevRxDesc;\r\nrx_queue_len = 0;\r\n}\r\n}\r\nstatic int\r\ne100_close(struct net_device *dev)\r\n{\r\nprintk(KERN_INFO "Closing %s.\n", dev->name);\r\nnetif_stop_queue(dev);\r\n*R_IRQ_MASK0_CLR =\r\nIO_STATE(R_IRQ_MASK0_CLR, overrun, clr) |\r\nIO_STATE(R_IRQ_MASK0_CLR, underrun, clr) |\r\nIO_STATE(R_IRQ_MASK0_CLR, excessive_col, clr);\r\n*R_IRQ_MASK2_CLR =\r\nIO_STATE(R_IRQ_MASK2_CLR, dma0_descr, clr) |\r\nIO_STATE(R_IRQ_MASK2_CLR, dma0_eop, clr) |\r\nIO_STATE(R_IRQ_MASK2_CLR, dma1_descr, clr) |\r\nIO_STATE(R_IRQ_MASK2_CLR, dma1_eop, clr);\r\nRESET_DMA(NETWORK_TX_DMA_NBR);\r\nRESET_DMA(NETWORK_RX_DMA_NBR);\r\nfree_irq(NETWORK_DMA_RX_IRQ_NBR, (void *)dev);\r\nfree_irq(NETWORK_DMA_TX_IRQ_NBR, (void *)dev);\r\nfree_irq(NETWORK_STATUS_IRQ_NBR, (void *)dev);\r\ncris_free_dma(NETWORK_TX_DMA_NBR, cardname);\r\ncris_free_dma(NETWORK_RX_DMA_NBR, cardname);\r\nupdate_rx_stats(&dev->stats);\r\nupdate_tx_stats(&dev->stats);\r\ndel_timer(&speed_timer);\r\ndel_timer(&duplex_timer);\r\nreturn 0;\r\n}\r\nstatic int\r\ne100_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nstruct net_local *np = netdev_priv(dev);\r\nint rc = 0;\r\nint old_autoneg;\r\nspin_lock(&np->lock);\r\nswitch (cmd) {\r\ncase SET_ETH_SPEED_10:\r\ne100_set_speed(dev, 10);\r\nbreak;\r\ncase SET_ETH_SPEED_100:\r\ne100_set_speed(dev, 100);\r\nbreak;\r\ncase SET_ETH_SPEED_AUTO:\r\ne100_set_speed(dev, 0);\r\nbreak;\r\ncase SET_ETH_DUPLEX_HALF:\r\ne100_set_duplex(dev, half);\r\nbreak;\r\ncase SET_ETH_DUPLEX_FULL:\r\ne100_set_duplex(dev, full);\r\nbreak;\r\ncase SET_ETH_DUPLEX_AUTO:\r\ne100_set_duplex(dev, autoneg);\r\nbreak;\r\ncase SET_ETH_AUTONEG:\r\nold_autoneg = autoneg_normal;\r\nautoneg_normal = *(int*)data;\r\nif (autoneg_normal != old_autoneg)\r\ne100_negotiate(dev);\r\nbreak;\r\ndefault:\r\nrc = generic_mii_ioctl(&np->mii_if, if_mii(ifr),\r\ncmd, NULL);\r\nbreak;\r\n}\r\nspin_unlock(&np->lock);\r\nreturn rc;\r\n}\r\nstatic int e100_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nint err;\r\nspin_lock_irq(&np->lock);\r\nerr = mii_ethtool_gset(&np->mii_if, cmd);\r\nspin_unlock_irq(&np->lock);\r\ncmd->supported &= ~(SUPPORTED_1000baseT_Half\r\n| SUPPORTED_1000baseT_Full);\r\nreturn err;\r\n}\r\nstatic int e100_set_settings(struct net_device *dev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\ne100_set_duplex(dev, autoneg);\r\ne100_set_speed(dev, 0);\r\n} else {\r\ne100_set_duplex(dev, ecmd->duplex == DUPLEX_HALF ? half : full);\r\ne100_set_speed(dev, ecmd->speed == SPEED_10 ? 10: 100);\r\n}\r\nreturn 0;\r\n}\r\nstatic void e100_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, "ETRAX 100LX", sizeof(info->driver));\r\nstrlcpy(info->version, "$Revision: 1.31 $", sizeof(info->version));\r\nstrlcpy(info->fw_version, "N/A", sizeof(info->fw_version));\r\nstrlcpy(info->bus_info, "N/A", sizeof(info->bus_info));\r\n}\r\nstatic int e100_nway_reset(struct net_device *dev)\r\n{\r\nif (current_duplex == autoneg && current_speed_selection == 0)\r\ne100_negotiate(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\ne100_set_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nstruct net_local *np = netdev_priv(dev);\r\nspin_lock(&np->lock);\r\nswitch(map->port) {\r\ncase IF_PORT_UNKNOWN:\r\ne100_set_speed(dev, 0);\r\ne100_set_duplex(dev, autoneg);\r\nbreak;\r\ncase IF_PORT_10BASET:\r\ne100_set_speed(dev, 10);\r\ne100_set_duplex(dev, autoneg);\r\nbreak;\r\ncase IF_PORT_100BASET:\r\ncase IF_PORT_100BASETX:\r\ne100_set_speed(dev, 100);\r\ne100_set_duplex(dev, autoneg);\r\nbreak;\r\ncase IF_PORT_100BASEFX:\r\ncase IF_PORT_10BASE2:\r\ncase IF_PORT_AUI:\r\nspin_unlock(&np->lock);\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nprintk(KERN_ERR "%s: Invalid media selected", dev->name);\r\nspin_unlock(&np->lock);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&np->lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nupdate_rx_stats(struct net_device_stats *es)\r\n{\r\nunsigned long r = *R_REC_COUNTERS;\r\nes->rx_fifo_errors += IO_EXTRACT(R_REC_COUNTERS, congestion, r);\r\nes->rx_crc_errors += IO_EXTRACT(R_REC_COUNTERS, crc_error, r);\r\nes->rx_frame_errors += IO_EXTRACT(R_REC_COUNTERS, alignment_error, r);\r\nes->rx_length_errors += IO_EXTRACT(R_REC_COUNTERS, oversize, r);\r\n}\r\nstatic void\r\nupdate_tx_stats(struct net_device_stats *es)\r\n{\r\nunsigned long r = *R_TR_COUNTERS;\r\nes->collisions +=\r\nIO_EXTRACT(R_TR_COUNTERS, single_col, r) +\r\nIO_EXTRACT(R_TR_COUNTERS, multiple_col, r);\r\n}\r\nstatic struct net_device_stats *\r\ne100_get_stats(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nupdate_rx_stats(&dev->stats);\r\nupdate_tx_stats(&dev->stats);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void\r\nset_multicast_list(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint num_addr = netdev_mc_count(dev);\r\nunsigned long int lo_bits;\r\nunsigned long int hi_bits;\r\nspin_lock(&lp->lock);\r\nif (dev->flags & IFF_PROMISC) {\r\nlo_bits = 0xfffffffful;\r\nhi_bits = 0xfffffffful;\r\nSETS(network_rec_config_shadow, R_NETWORK_REC_CONFIG, individual, receive);\r\n*R_NETWORK_REC_CONFIG = network_rec_config_shadow;\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\nlo_bits = 0xfffffffful;\r\nhi_bits = 0xfffffffful;\r\nSETS(network_rec_config_shadow, R_NETWORK_REC_CONFIG, individual, discard);\r\n*R_NETWORK_REC_CONFIG = network_rec_config_shadow;\r\n} else if (num_addr == 0) {\r\nlo_bits = 0x00000000ul;\r\nhi_bits = 0x00000000ul;\r\nSETS(network_rec_config_shadow, R_NETWORK_REC_CONFIG, individual, discard);\r\n*R_NETWORK_REC_CONFIG = network_rec_config_shadow;\r\n} else {\r\nchar hash_ix;\r\nstruct netdev_hw_addr *ha;\r\nchar *baddr;\r\nlo_bits = 0x00000000ul;\r\nhi_bits = 0x00000000ul;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nhash_ix = 0;\r\nbaddr = ha->addr;\r\nhash_ix ^= (*baddr) & 0x3f;\r\nhash_ix ^= ((*baddr) >> 6) & 0x03;\r\n++baddr;\r\nhash_ix ^= ((*baddr) << 2) & 0x03c;\r\nhash_ix ^= ((*baddr) >> 4) & 0xf;\r\n++baddr;\r\nhash_ix ^= ((*baddr) << 4) & 0x30;\r\nhash_ix ^= ((*baddr) >> 2) & 0x3f;\r\n++baddr;\r\nhash_ix ^= (*baddr) & 0x3f;\r\nhash_ix ^= ((*baddr) >> 6) & 0x03;\r\n++baddr;\r\nhash_ix ^= ((*baddr) << 2) & 0x03c;\r\nhash_ix ^= ((*baddr) >> 4) & 0xf;\r\n++baddr;\r\nhash_ix ^= ((*baddr) << 4) & 0x30;\r\nhash_ix ^= ((*baddr) >> 2) & 0x3f;\r\nhash_ix &= 0x3f;\r\nif (hash_ix >= 32) {\r\nhi_bits |= (1 << (hash_ix-32));\r\n} else {\r\nlo_bits |= (1 << hash_ix);\r\n}\r\n}\r\nSETS(network_rec_config_shadow, R_NETWORK_REC_CONFIG, individual, discard);\r\n*R_NETWORK_REC_CONFIG = network_rec_config_shadow;\r\n}\r\n*R_NETWORK_GA_0 = lo_bits;\r\n*R_NETWORK_GA_1 = hi_bits;\r\nspin_unlock(&lp->lock);\r\n}\r\nvoid\r\ne100_hardware_send_packet(struct net_local *np, char *buf, int length)\r\n{\r\nD(printk("e100 send pack, buf 0x%x len %d\n", buf, length));\r\nspin_lock(&np->led_lock);\r\nif (!led_active && time_after(jiffies, led_next_time)) {\r\ne100_set_network_leds(NETWORK_ACTIVITY);\r\nled_next_time = jiffies + NET_FLASH_TIME;\r\nled_active = 1;\r\nmod_timer(&clear_led_timer, jiffies + HZ/10);\r\n}\r\nspin_unlock(&np->led_lock);\r\nmyNextTxDesc->descr.sw_len = length;\r\nmyNextTxDesc->descr.ctrl = d_eop | d_eol | d_wait;\r\nmyNextTxDesc->descr.buf = virt_to_phys(buf);\r\nmyLastTxDesc->descr.ctrl &= ~d_eol;\r\nmyLastTxDesc = myNextTxDesc;\r\n*R_DMA_CH0_CMD = IO_STATE(R_DMA_CH0_CMD, cmd, restart);\r\n}\r\nstatic void\r\ne100_clear_network_leds(unsigned long dummy)\r\n{\r\nstruct net_device *dev = (struct net_device *)dummy;\r\nstruct net_local *np = netdev_priv(dev);\r\nspin_lock(&np->led_lock);\r\nif (led_active && time_after(jiffies, led_next_time)) {\r\ne100_set_network_leds(NO_NETWORK_ACTIVITY);\r\nled_next_time = jiffies + NET_FLASH_PAUSE;\r\nled_active = 0;\r\n}\r\nspin_unlock(&np->led_lock);\r\n}\r\nstatic void\r\ne100_set_network_leds(int active)\r\n{\r\n#if defined(CONFIG_ETRAX_NETWORK_LED_ON_WHEN_LINK)\r\nint light_leds = (active == NO_NETWORK_ACTIVITY);\r\n#elif defined(CONFIG_ETRAX_NETWORK_LED_ON_WHEN_ACTIVITY)\r\nint light_leds = (active == NETWORK_ACTIVITY);\r\n#else\r\n#error "Define either CONFIG_ETRAX_NETWORK_LED_ON_WHEN_LINK or CONFIG_ETRAX_NETWORK_LED_ON_WHEN_ACTIVITY"\r\n#endif\r\nif (!current_speed) {\r\nCRIS_LED_NETWORK_SET(CRIS_LED_OFF);\r\n} else if (light_leds) {\r\nif (current_speed == 10) {\r\nCRIS_LED_NETWORK_SET(CRIS_LED_ORANGE);\r\n} else {\r\nCRIS_LED_NETWORK_SET(CRIS_LED_GREEN);\r\n}\r\n} else {\r\nCRIS_LED_NETWORK_SET(CRIS_LED_OFF);\r\n}\r\n}\r\nstatic void\r\ne100_netpoll(struct net_device* netdev)\r\n{\r\ne100rxtx_interrupt(NETWORK_DMA_TX_IRQ_NBR, netdev);\r\n}\r\nstatic int\r\netrax_init_module(void)\r\n{\r\nreturn etrax_ethernet_init();\r\n}\r\nstatic int __init\r\ne100_boot_setup(char* str)\r\n{\r\nstruct sockaddr sa = {0};\r\nint i;\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nunsigned int tmp;\r\nif (sscanf(str + 3*i, "%2x", &tmp) != 1) {\r\nprintk(KERN_WARNING "Malformed station address");\r\nreturn 0;\r\n}\r\nsa.sa_data[i] = (char)tmp;\r\n}\r\ndefault_mac = sa;\r\nreturn 1;\r\n}
