static inline struct iscsi_tpg_np *to_iscsi_tpg_np(struct config_item *item)\r\n{\r\nreturn container_of(to_tpg_np(item), struct iscsi_tpg_np, se_tpg_np);\r\n}\r\nstatic ssize_t lio_target_np_driver_show(struct config_item *item, char *page,\r\nenum iscsit_transport_type type)\r\n{\r\nstruct iscsi_tpg_np *tpg_np = to_iscsi_tpg_np(item);\r\nstruct iscsi_tpg_np *tpg_np_new;\r\nssize_t rb;\r\ntpg_np_new = iscsit_tpg_locate_child_np(tpg_np, type);\r\nif (tpg_np_new)\r\nrb = sprintf(page, "1\n");\r\nelse\r\nrb = sprintf(page, "0\n");\r\nreturn rb;\r\n}\r\nstatic ssize_t lio_target_np_driver_store(struct config_item *item,\r\nconst char *page, size_t count, enum iscsit_transport_type type,\r\nconst char *mod_name)\r\n{\r\nstruct iscsi_tpg_np *tpg_np = to_iscsi_tpg_np(item);\r\nstruct iscsi_np *np;\r\nstruct iscsi_portal_group *tpg;\r\nstruct iscsi_tpg_np *tpg_np_new = NULL;\r\nu32 op;\r\nint rc;\r\nrc = kstrtou32(page, 0, &op);\r\nif (rc)\r\nreturn rc;\r\nif ((op != 1) && (op != 0)) {\r\npr_err("Illegal value for tpg_enable: %u\n", op);\r\nreturn -EINVAL;\r\n}\r\nnp = tpg_np->tpg_np;\r\nif (!np) {\r\npr_err("Unable to locate struct iscsi_np from"\r\n" struct iscsi_tpg_np\n");\r\nreturn -EINVAL;\r\n}\r\ntpg = tpg_np->tpg;\r\nif (iscsit_get_tpg(tpg) < 0)\r\nreturn -EINVAL;\r\nif (op) {\r\nif (strlen(mod_name)) {\r\nrc = request_module(mod_name);\r\nif (rc != 0) {\r\npr_warn("Unable to request_module for %s\n",\r\nmod_name);\r\nrc = 0;\r\n}\r\n}\r\ntpg_np_new = iscsit_tpg_add_network_portal(tpg,\r\n&np->np_sockaddr, tpg_np, type);\r\nif (IS_ERR(tpg_np_new))\r\ngoto out;\r\n} else {\r\ntpg_np_new = iscsit_tpg_locate_child_np(tpg_np, type);\r\nif (tpg_np_new) {\r\nrc = iscsit_tpg_del_network_portal(tpg, tpg_np_new);\r\nif (rc < 0)\r\ngoto out;\r\n}\r\n}\r\niscsit_put_tpg(tpg);\r\nreturn count;\r\nout:\r\niscsit_put_tpg(tpg);\r\nreturn rc;\r\n}\r\nstatic ssize_t lio_target_np_iser_show(struct config_item *item, char *page)\r\n{\r\nreturn lio_target_np_driver_show(item, page, ISCSI_INFINIBAND);\r\n}\r\nstatic ssize_t lio_target_np_iser_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nreturn lio_target_np_driver_store(item, page, count,\r\nISCSI_INFINIBAND, "ib_isert");\r\n}\r\nstatic ssize_t lio_target_np_cxgbit_show(struct config_item *item, char *page)\r\n{\r\nreturn lio_target_np_driver_show(item, page, ISCSI_CXGBIT);\r\n}\r\nstatic ssize_t lio_target_np_cxgbit_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nreturn lio_target_np_driver_store(item, page, count,\r\nISCSI_CXGBIT, "cxgbit");\r\n}\r\nstatic struct se_tpg_np *lio_target_call_addnptotpg(\r\nstruct se_portal_group *se_tpg,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct iscsi_portal_group *tpg;\r\nstruct iscsi_tpg_np *tpg_np;\r\nchar *str, *str2, *ip_str, *port_str;\r\nstruct sockaddr_storage sockaddr;\r\nstruct sockaddr_in *sock_in;\r\nstruct sockaddr_in6 *sock_in6;\r\nunsigned long port;\r\nint ret;\r\nchar buf[MAX_PORTAL_LEN + 1];\r\nif (strlen(name) > MAX_PORTAL_LEN) {\r\npr_err("strlen(name): %d exceeds MAX_PORTAL_LEN: %d\n",\r\n(int)strlen(name), MAX_PORTAL_LEN);\r\nreturn ERR_PTR(-EOVERFLOW);\r\n}\r\nmemset(buf, 0, MAX_PORTAL_LEN + 1);\r\nsnprintf(buf, MAX_PORTAL_LEN + 1, "%s", name);\r\nmemset(&sockaddr, 0, sizeof(struct sockaddr_storage));\r\nstr = strstr(buf, "[");\r\nif (str) {\r\nconst char *end;\r\nstr2 = strstr(str, "]");\r\nif (!str2) {\r\npr_err("Unable to locate trailing \"]\""\r\n" in IPv6 iSCSI network portal address\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstr++;\r\n*str2 = '\0';\r\nstr2++;\r\nport_str = strstr(str2, ":");\r\nif (!port_str) {\r\npr_err("Unable to locate \":port\""\r\n" in IPv6 iSCSI network portal address\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n*port_str = '\0';\r\nport_str++;\r\nret = kstrtoul(port_str, 0, &port);\r\nif (ret < 0) {\r\npr_err("kstrtoul() failed for port_str: %d\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nsock_in6 = (struct sockaddr_in6 *)&sockaddr;\r\nsock_in6->sin6_family = AF_INET6;\r\nsock_in6->sin6_port = htons((unsigned short)port);\r\nret = in6_pton(str, -1,\r\n(void *)&sock_in6->sin6_addr.in6_u, -1, &end);\r\nif (ret <= 0) {\r\npr_err("in6_pton returned: %d\n", ret);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n} else {\r\nstr = ip_str = &buf[0];\r\nport_str = strstr(ip_str, ":");\r\nif (!port_str) {\r\npr_err("Unable to locate \":port\""\r\n" in IPv4 iSCSI network portal address\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n*port_str = '\0';\r\nport_str++;\r\nret = kstrtoul(port_str, 0, &port);\r\nif (ret < 0) {\r\npr_err("kstrtoul() failed for port_str: %d\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nsock_in = (struct sockaddr_in *)&sockaddr;\r\nsock_in->sin_family = AF_INET;\r\nsock_in->sin_port = htons((unsigned short)port);\r\nsock_in->sin_addr.s_addr = in_aton(ip_str);\r\n}\r\ntpg = container_of(se_tpg, struct iscsi_portal_group, tpg_se_tpg);\r\nret = iscsit_get_tpg(tpg);\r\nif (ret < 0)\r\nreturn ERR_PTR(-EINVAL);\r\npr_debug("LIO_Target_ConfigFS: REGISTER -> %s TPGT: %hu"\r\n" PORTAL: %s\n",\r\nconfig_item_name(&se_tpg->se_tpg_wwn->wwn_group.cg_item),\r\ntpg->tpgt, name);\r\ntpg_np = iscsit_tpg_add_network_portal(tpg, &sockaddr, NULL,\r\nISCSI_TCP);\r\nif (IS_ERR(tpg_np)) {\r\niscsit_put_tpg(tpg);\r\nreturn ERR_CAST(tpg_np);\r\n}\r\npr_debug("LIO_Target_ConfigFS: addnptotpg done!\n");\r\niscsit_put_tpg(tpg);\r\nreturn &tpg_np->se_tpg_np;\r\n}\r\nstatic void lio_target_call_delnpfromtpg(\r\nstruct se_tpg_np *se_tpg_np)\r\n{\r\nstruct iscsi_portal_group *tpg;\r\nstruct iscsi_tpg_np *tpg_np;\r\nstruct se_portal_group *se_tpg;\r\nint ret;\r\ntpg_np = container_of(se_tpg_np, struct iscsi_tpg_np, se_tpg_np);\r\ntpg = tpg_np->tpg;\r\nret = iscsit_get_tpg(tpg);\r\nif (ret < 0)\r\nreturn;\r\nse_tpg = &tpg->tpg_se_tpg;\r\npr_debug("LIO_Target_ConfigFS: DEREGISTER -> %s TPGT: %hu"\r\n" PORTAL: %pISpc\n", config_item_name(&se_tpg->se_tpg_wwn->wwn_group.cg_item),\r\ntpg->tpgt, &tpg_np->tpg_np->np_sockaddr);\r\nret = iscsit_tpg_del_network_portal(tpg, tpg_np);\r\nif (ret < 0)\r\ngoto out;\r\npr_debug("LIO_Target_ConfigFS: delnpfromtpg done!\n");\r\nout:\r\niscsit_put_tpg(tpg);\r\n}\r\nstatic ssize_t lio_target_nacl_info_show(struct config_item *item, char *page)\r\n{\r\nstruct se_node_acl *se_nacl = acl_to_nacl(item);\r\nstruct iscsi_session *sess;\r\nstruct iscsi_conn *conn;\r\nstruct se_session *se_sess;\r\nssize_t rb = 0;\r\nu32 max_cmd_sn;\r\nspin_lock_bh(&se_nacl->nacl_sess_lock);\r\nse_sess = se_nacl->nacl_sess;\r\nif (!se_sess) {\r\nrb += sprintf(page+rb, "No active iSCSI Session for Initiator"\r\n" Endpoint: %s\n", se_nacl->initiatorname);\r\n} else {\r\nsess = se_sess->fabric_sess_ptr;\r\nrb += sprintf(page+rb, "InitiatorName: %s\n",\r\nsess->sess_ops->InitiatorName);\r\nrb += sprintf(page+rb, "InitiatorAlias: %s\n",\r\nsess->sess_ops->InitiatorAlias);\r\nrb += sprintf(page+rb,\r\n"LIO Session ID: %u ISID: 0x%6ph TSIH: %hu ",\r\nsess->sid, sess->isid, sess->tsih);\r\nrb += sprintf(page+rb, "SessionType: %s\n",\r\n(sess->sess_ops->SessionType) ?\r\n"Discovery" : "Normal");\r\nrb += sprintf(page+rb, "Session State: ");\r\nswitch (sess->session_state) {\r\ncase TARG_SESS_STATE_FREE:\r\nrb += sprintf(page+rb, "TARG_SESS_FREE\n");\r\nbreak;\r\ncase TARG_SESS_STATE_ACTIVE:\r\nrb += sprintf(page+rb, "TARG_SESS_STATE_ACTIVE\n");\r\nbreak;\r\ncase TARG_SESS_STATE_LOGGED_IN:\r\nrb += sprintf(page+rb, "TARG_SESS_STATE_LOGGED_IN\n");\r\nbreak;\r\ncase TARG_SESS_STATE_FAILED:\r\nrb += sprintf(page+rb, "TARG_SESS_STATE_FAILED\n");\r\nbreak;\r\ncase TARG_SESS_STATE_IN_CONTINUE:\r\nrb += sprintf(page+rb, "TARG_SESS_STATE_IN_CONTINUE\n");\r\nbreak;\r\ndefault:\r\nrb += sprintf(page+rb, "ERROR: Unknown Session"\r\n" State!\n");\r\nbreak;\r\n}\r\nrb += sprintf(page+rb, "---------------------[iSCSI Session"\r\n" Values]-----------------------\n");\r\nrb += sprintf(page+rb, " CmdSN/WR : CmdSN/WC : ExpCmdSN"\r\n" : MaxCmdSN : ITT : TTT\n");\r\nmax_cmd_sn = (u32) atomic_read(&sess->max_cmd_sn);\r\nrb += sprintf(page+rb, " 0x%08x 0x%08x 0x%08x 0x%08x"\r\n" 0x%08x 0x%08x\n",\r\nsess->cmdsn_window,\r\n(max_cmd_sn - sess->exp_cmd_sn) + 1,\r\nsess->exp_cmd_sn, max_cmd_sn,\r\nsess->init_task_tag, sess->targ_xfer_tag);\r\nrb += sprintf(page+rb, "----------------------[iSCSI"\r\n" Connections]-------------------------\n");\r\nspin_lock(&sess->conn_lock);\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\r\nrb += sprintf(page+rb, "CID: %hu Connection"\r\n" State: ", conn->cid);\r\nswitch (conn->conn_state) {\r\ncase TARG_CONN_STATE_FREE:\r\nrb += sprintf(page+rb,\r\n"TARG_CONN_STATE_FREE\n");\r\nbreak;\r\ncase TARG_CONN_STATE_XPT_UP:\r\nrb += sprintf(page+rb,\r\n"TARG_CONN_STATE_XPT_UP\n");\r\nbreak;\r\ncase TARG_CONN_STATE_IN_LOGIN:\r\nrb += sprintf(page+rb,\r\n"TARG_CONN_STATE_IN_LOGIN\n");\r\nbreak;\r\ncase TARG_CONN_STATE_LOGGED_IN:\r\nrb += sprintf(page+rb,\r\n"TARG_CONN_STATE_LOGGED_IN\n");\r\nbreak;\r\ncase TARG_CONN_STATE_IN_LOGOUT:\r\nrb += sprintf(page+rb,\r\n"TARG_CONN_STATE_IN_LOGOUT\n");\r\nbreak;\r\ncase TARG_CONN_STATE_LOGOUT_REQUESTED:\r\nrb += sprintf(page+rb,\r\n"TARG_CONN_STATE_LOGOUT_REQUESTED\n");\r\nbreak;\r\ncase TARG_CONN_STATE_CLEANUP_WAIT:\r\nrb += sprintf(page+rb,\r\n"TARG_CONN_STATE_CLEANUP_WAIT\n");\r\nbreak;\r\ndefault:\r\nrb += sprintf(page+rb,\r\n"ERROR: Unknown Connection State!\n");\r\nbreak;\r\n}\r\nrb += sprintf(page+rb, " Address %pISc %s", &conn->login_sockaddr,\r\n(conn->network_transport == ISCSI_TCP) ?\r\n"TCP" : "SCTP");\r\nrb += sprintf(page+rb, " StatSN: 0x%08x\n",\r\nconn->stat_sn);\r\n}\r\nspin_unlock(&sess->conn_lock);\r\n}\r\nspin_unlock_bh(&se_nacl->nacl_sess_lock);\r\nreturn rb;\r\n}\r\nstatic ssize_t lio_target_nacl_cmdsn_depth_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%u\n", acl_to_nacl(item)->queue_depth);\r\n}\r\nstatic ssize_t lio_target_nacl_cmdsn_depth_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_node_acl *se_nacl = acl_to_nacl(item);\r\nstruct se_portal_group *se_tpg = se_nacl->se_tpg;\r\nstruct iscsi_portal_group *tpg = container_of(se_tpg,\r\nstruct iscsi_portal_group, tpg_se_tpg);\r\nstruct config_item *acl_ci, *tpg_ci, *wwn_ci;\r\nu32 cmdsn_depth = 0;\r\nint ret;\r\nret = kstrtou32(page, 0, &cmdsn_depth);\r\nif (ret)\r\nreturn ret;\r\nif (cmdsn_depth > TA_DEFAULT_CMDSN_DEPTH_MAX) {\r\npr_err("Passed cmdsn_depth: %u exceeds"\r\n" TA_DEFAULT_CMDSN_DEPTH_MAX: %u\n", cmdsn_depth,\r\nTA_DEFAULT_CMDSN_DEPTH_MAX);\r\nreturn -EINVAL;\r\n}\r\nacl_ci = &se_nacl->acl_group.cg_item;\r\nif (!acl_ci) {\r\npr_err("Unable to locatel acl_ci\n");\r\nreturn -EINVAL;\r\n}\r\ntpg_ci = &acl_ci->ci_parent->ci_group->cg_item;\r\nif (!tpg_ci) {\r\npr_err("Unable to locate tpg_ci\n");\r\nreturn -EINVAL;\r\n}\r\nwwn_ci = &tpg_ci->ci_group->cg_item;\r\nif (!wwn_ci) {\r\npr_err("Unable to locate config_item wwn_ci\n");\r\nreturn -EINVAL;\r\n}\r\nif (iscsit_get_tpg(tpg) < 0)\r\nreturn -EINVAL;\r\nret = core_tpg_set_initiator_node_queue_depth(se_nacl, cmdsn_depth);\r\npr_debug("LIO_Target_ConfigFS: %s/%s Set CmdSN Window: %u for"\r\n"InitiatorName: %s\n", config_item_name(wwn_ci),\r\nconfig_item_name(tpg_ci), cmdsn_depth,\r\nconfig_item_name(acl_ci));\r\niscsit_put_tpg(tpg);\r\nreturn (!ret) ? count : (ssize_t)ret;\r\n}\r\nstatic ssize_t lio_target_nacl_tag_show(struct config_item *item, char *page)\r\n{\r\nreturn snprintf(page, PAGE_SIZE, "%s", acl_to_nacl(item)->acl_tag);\r\n}\r\nstatic ssize_t lio_target_nacl_tag_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_node_acl *se_nacl = acl_to_nacl(item);\r\nint ret;\r\nret = core_tpg_set_initiator_node_tag(se_nacl->se_tpg, se_nacl, page);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int lio_target_init_nodeacl(struct se_node_acl *se_nacl,\r\nconst char *name)\r\n{\r\nstruct iscsi_node_acl *acl =\r\ncontainer_of(se_nacl, struct iscsi_node_acl, se_node_acl);\r\nconfig_group_init_type_name(&acl->node_stat_grps.iscsi_sess_stats_group,\r\n"iscsi_sess_stats", &iscsi_stat_sess_cit);\r\nconfigfs_add_default_group(&acl->node_stat_grps.iscsi_sess_stats_group,\r\n&se_nacl->acl_fabric_stat_group);\r\nreturn 0;\r\n}\r\nstatic ssize_t lio_target_tpg_enable_show(struct config_item *item, char *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct iscsi_portal_group *tpg = container_of(se_tpg,\r\nstruct iscsi_portal_group, tpg_se_tpg);\r\nssize_t len;\r\nspin_lock(&tpg->tpg_state_lock);\r\nlen = sprintf(page, "%d\n",\r\n(tpg->tpg_state == TPG_STATE_ACTIVE) ? 1 : 0);\r\nspin_unlock(&tpg->tpg_state_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t lio_target_tpg_enable_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct iscsi_portal_group *tpg = container_of(se_tpg,\r\nstruct iscsi_portal_group, tpg_se_tpg);\r\nu32 op;\r\nint ret;\r\nret = kstrtou32(page, 0, &op);\r\nif (ret)\r\nreturn ret;\r\nif ((op != 1) && (op != 0)) {\r\npr_err("Illegal value for tpg_enable: %u\n", op);\r\nreturn -EINVAL;\r\n}\r\nret = iscsit_get_tpg(tpg);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nif (op) {\r\nret = iscsit_tpg_enable_portal_group(tpg);\r\nif (ret < 0)\r\ngoto out;\r\n} else {\r\nret = iscsit_tpg_disable_portal_group(tpg, 1);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\niscsit_put_tpg(tpg);\r\nreturn count;\r\nout:\r\niscsit_put_tpg(tpg);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t lio_target_tpg_dynamic_sessions_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn target_show_dynamic_sessions(to_tpg(item), page);\r\n}\r\nstatic struct se_portal_group *lio_target_tiqn_addtpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct iscsi_portal_group *tpg;\r\nstruct iscsi_tiqn *tiqn;\r\nchar *tpgt_str;\r\nint ret;\r\nu16 tpgt;\r\ntiqn = container_of(wwn, struct iscsi_tiqn, tiqn_wwn);\r\ntpgt_str = strstr(name, "tpgt_");\r\nif (!tpgt_str) {\r\npr_err("Unable to locate \"tpgt_#\" directory"\r\n" group\n");\r\nreturn NULL;\r\n}\r\ntpgt_str += 5;\r\nret = kstrtou16(tpgt_str, 0, &tpgt);\r\nif (ret)\r\nreturn NULL;\r\ntpg = iscsit_alloc_portal_group(tiqn, tpgt);\r\nif (!tpg)\r\nreturn NULL;\r\nret = core_tpg_register(wwn, &tpg->tpg_se_tpg, SCSI_PROTOCOL_ISCSI);\r\nif (ret < 0)\r\nreturn NULL;\r\nret = iscsit_tpg_add_portal_group(tiqn, tpg);\r\nif (ret != 0)\r\ngoto out;\r\npr_debug("LIO_Target_ConfigFS: REGISTER -> %s\n", tiqn->tiqn);\r\npr_debug("LIO_Target_ConfigFS: REGISTER -> Allocated TPG: %s\n",\r\nname);\r\nreturn &tpg->tpg_se_tpg;\r\nout:\r\ncore_tpg_deregister(&tpg->tpg_se_tpg);\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\nstatic void lio_target_tiqn_deltpg(struct se_portal_group *se_tpg)\r\n{\r\nstruct iscsi_portal_group *tpg;\r\nstruct iscsi_tiqn *tiqn;\r\ntpg = container_of(se_tpg, struct iscsi_portal_group, tpg_se_tpg);\r\ntiqn = tpg->tpg_tiqn;\r\npr_debug("LIO_Target_ConfigFS: DEREGISTER -> Releasing TPG\n");\r\niscsit_tpg_del_portal_group(tiqn, tpg, 1);\r\n}\r\nstatic ssize_t lio_target_wwn_lio_version_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "Datera Inc. iSCSI Target "ISCSIT_VERSION"\n");\r\n}\r\nstatic struct se_wwn *lio_target_call_coreaddtiqn(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct iscsi_tiqn *tiqn;\r\ntiqn = iscsit_add_tiqn((unsigned char *)name);\r\nif (IS_ERR(tiqn))\r\nreturn ERR_CAST(tiqn);\r\npr_debug("LIO_Target_ConfigFS: REGISTER -> %s\n", tiqn->tiqn);\r\npr_debug("LIO_Target_ConfigFS: REGISTER -> Allocated Node:"\r\n" %s\n", name);\r\nreturn &tiqn->tiqn_wwn;\r\n}\r\nstatic void lio_target_add_wwn_groups(struct se_wwn *wwn)\r\n{\r\nstruct iscsi_tiqn *tiqn = container_of(wwn, struct iscsi_tiqn, tiqn_wwn);\r\nconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_instance_group,\r\n"iscsi_instance", &iscsi_stat_instance_cit);\r\nconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_instance_group,\r\n&tiqn->tiqn_wwn.fabric_stat_group);\r\nconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_sess_err_group,\r\n"iscsi_sess_err", &iscsi_stat_sess_err_cit);\r\nconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_sess_err_group,\r\n&tiqn->tiqn_wwn.fabric_stat_group);\r\nconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_tgt_attr_group,\r\n"iscsi_tgt_attr", &iscsi_stat_tgt_attr_cit);\r\nconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_tgt_attr_group,\r\n&tiqn->tiqn_wwn.fabric_stat_group);\r\nconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_login_stats_group,\r\n"iscsi_login_stats", &iscsi_stat_login_cit);\r\nconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_login_stats_group,\r\n&tiqn->tiqn_wwn.fabric_stat_group);\r\nconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_logout_stats_group,\r\n"iscsi_logout_stats", &iscsi_stat_logout_cit);\r\nconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_logout_stats_group,\r\n&tiqn->tiqn_wwn.fabric_stat_group);\r\n}\r\nstatic void lio_target_call_coredeltiqn(\r\nstruct se_wwn *wwn)\r\n{\r\nstruct iscsi_tiqn *tiqn = container_of(wwn, struct iscsi_tiqn, tiqn_wwn);\r\npr_debug("LIO_Target_ConfigFS: DEREGISTER -> %s\n",\r\ntiqn->tiqn);\r\niscsit_del_tiqn(tiqn);\r\n}\r\nstatic ssize_t iscsi_disc_enforce_discovery_auth_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct iscsi_node_auth *discovery_auth = &iscsit_global->discovery_acl.node_auth;\r\nreturn sprintf(page, "%d\n", discovery_auth->enforce_discovery_auth);\r\n}\r\nstatic ssize_t iscsi_disc_enforce_discovery_auth_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct iscsi_param *param;\r\nstruct iscsi_portal_group *discovery_tpg = iscsit_global->discovery_tpg;\r\nu32 op;\r\nint err;\r\nerr = kstrtou32(page, 0, &op);\r\nif (err)\r\nreturn -EINVAL;\r\nif ((op != 1) && (op != 0)) {\r\npr_err("Illegal value for enforce_discovery_auth:"\r\n" %u\n", op);\r\nreturn -EINVAL;\r\n}\r\nif (!discovery_tpg) {\r\npr_err("iscsit_global->discovery_tpg is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nparam = iscsi_find_param_from_key(AUTHMETHOD,\r\ndiscovery_tpg->param_list);\r\nif (!param)\r\nreturn -EINVAL;\r\nif (op) {\r\nif (iscsi_update_param_value(param, CHAP) < 0)\r\nreturn -EINVAL;\r\ndiscovery_tpg->tpg_attrib.authentication = 1;\r\niscsit_global->discovery_acl.node_auth.enforce_discovery_auth = 1;\r\npr_debug("LIO-CORE[0] Successfully enabled"\r\n" authentication enforcement for iSCSI"\r\n" Discovery TPG\n");\r\n} else {\r\nif (iscsi_update_param_value(param, "CHAP,None") < 0)\r\nreturn -EINVAL;\r\ndiscovery_tpg->tpg_attrib.authentication = 0;\r\niscsit_global->discovery_acl.node_auth.enforce_discovery_auth = 0;\r\npr_debug("LIO-CORE[0] Successfully disabled"\r\n" authentication enforcement for iSCSI"\r\n" Discovery TPG\n");\r\n}\r\nreturn count;\r\n}\r\nstatic char *iscsi_get_fabric_name(void)\r\n{\r\nreturn "iSCSI";\r\n}\r\nstatic int iscsi_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nstruct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);\r\nreturn cmd->i_state;\r\n}\r\nstatic u32 lio_sess_get_index(struct se_session *se_sess)\r\n{\r\nstruct iscsi_session *sess = se_sess->fabric_sess_ptr;\r\nreturn sess->session_index;\r\n}\r\nstatic u32 lio_sess_get_initiator_sid(\r\nstruct se_session *se_sess,\r\nunsigned char *buf,\r\nu32 size)\r\n{\r\nstruct iscsi_session *sess = se_sess->fabric_sess_ptr;\r\nreturn snprintf(buf, size, "%6phN", sess->isid);\r\n}\r\nstatic int lio_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nstruct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);\r\ncmd->i_state = ISTATE_SEND_DATAIN;\r\ncmd->conn->conn_transport->iscsit_queue_data_in(cmd->conn, cmd);\r\nreturn 0;\r\n}\r\nstatic int lio_write_pending(struct se_cmd *se_cmd)\r\n{\r\nstruct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);\r\nstruct iscsi_conn *conn = cmd->conn;\r\nif (!cmd->immediate_data && !cmd->unsolicited_data)\r\nreturn conn->conn_transport->iscsit_get_dataout(conn, cmd, false);\r\nreturn 0;\r\n}\r\nstatic int lio_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nstruct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);\r\nint ret;\r\nspin_lock_bh(&cmd->istate_lock);\r\nret = !(cmd->cmd_flags & ICF_GOT_LAST_DATAOUT);\r\nspin_unlock_bh(&cmd->istate_lock);\r\nreturn ret;\r\n}\r\nstatic int lio_queue_status(struct se_cmd *se_cmd)\r\n{\r\nstruct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);\r\ncmd->i_state = ISTATE_SEND_STATUS;\r\nif (cmd->se_cmd.scsi_status || cmd->sense_reason) {\r\niscsit_add_cmd_to_response_queue(cmd, cmd->conn, cmd->i_state);\r\nreturn 0;\r\n}\r\ncmd->conn->conn_transport->iscsit_queue_status(cmd->conn, cmd);\r\nreturn 0;\r\n}\r\nstatic void lio_queue_tm_rsp(struct se_cmd *se_cmd)\r\n{\r\nstruct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);\r\ncmd->i_state = ISTATE_SEND_TASKMGTRSP;\r\niscsit_add_cmd_to_response_queue(cmd, cmd->conn, cmd->i_state);\r\n}\r\nstatic void lio_aborted_task(struct se_cmd *se_cmd)\r\n{\r\nstruct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);\r\ncmd->conn->conn_transport->iscsit_aborted_task(cmd->conn, cmd);\r\n}\r\nstatic inline struct iscsi_portal_group *iscsi_tpg(struct se_portal_group *se_tpg)\r\n{\r\nreturn container_of(se_tpg, struct iscsi_portal_group, tpg_se_tpg);\r\n}\r\nstatic char *lio_tpg_get_endpoint_wwn(struct se_portal_group *se_tpg)\r\n{\r\nreturn iscsi_tpg(se_tpg)->tpg_tiqn->tiqn;\r\n}\r\nstatic u16 lio_tpg_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nreturn iscsi_tpg(se_tpg)->tpgt;\r\n}\r\nstatic u32 lio_tpg_get_default_depth(struct se_portal_group *se_tpg)\r\n{\r\nreturn iscsi_tpg(se_tpg)->tpg_attrib.default_cmdsn_depth;\r\n}\r\nstatic int lio_tpg_check_demo_mode(struct se_portal_group *se_tpg)\r\n{\r\nreturn iscsi_tpg(se_tpg)->tpg_attrib.generate_node_acls;\r\n}\r\nstatic int lio_tpg_check_demo_mode_cache(struct se_portal_group *se_tpg)\r\n{\r\nreturn iscsi_tpg(se_tpg)->tpg_attrib.cache_dynamic_acls;\r\n}\r\nstatic int lio_tpg_check_demo_mode_write_protect(\r\nstruct se_portal_group *se_tpg)\r\n{\r\nreturn iscsi_tpg(se_tpg)->tpg_attrib.demo_mode_write_protect;\r\n}\r\nstatic int lio_tpg_check_prod_mode_write_protect(\r\nstruct se_portal_group *se_tpg)\r\n{\r\nreturn iscsi_tpg(se_tpg)->tpg_attrib.prod_mode_write_protect;\r\n}\r\nstatic int lio_tpg_check_prot_fabric_only(\r\nstruct se_portal_group *se_tpg)\r\n{\r\nif (!iscsi_tpg(se_tpg)->tpg_attrib.t10_pi)\r\nreturn 0;\r\nreturn iscsi_tpg(se_tpg)->tpg_attrib.fabric_prot_type;\r\n}\r\nstatic void lio_tpg_close_session(struct se_session *se_sess)\r\n{\r\nstruct iscsi_session *sess = se_sess->fabric_sess_ptr;\r\nstruct se_portal_group *se_tpg = &sess->tpg->tpg_se_tpg;\r\nspin_lock_bh(&se_tpg->session_lock);\r\nspin_lock(&sess->conn_lock);\r\nif (atomic_read(&sess->session_fall_back_to_erl0) ||\r\natomic_read(&sess->session_logout) ||\r\n(sess->time2retain_timer_flags & ISCSI_TF_EXPIRED)) {\r\nspin_unlock(&sess->conn_lock);\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nreturn;\r\n}\r\natomic_set(&sess->session_reinstatement, 1);\r\nspin_unlock(&sess->conn_lock);\r\niscsit_stop_time2retain_timer(sess);\r\nspin_unlock_bh(&se_tpg->session_lock);\r\niscsit_stop_session(sess, 1, 1);\r\niscsit_close_session(sess);\r\n}\r\nstatic u32 lio_tpg_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nreturn iscsi_tpg(se_tpg)->tpg_tiqn->tiqn_index;\r\n}\r\nstatic void lio_set_default_node_attributes(struct se_node_acl *se_acl)\r\n{\r\nstruct iscsi_node_acl *acl = container_of(se_acl, struct iscsi_node_acl,\r\nse_node_acl);\r\nstruct se_portal_group *se_tpg = se_acl->se_tpg;\r\nstruct iscsi_portal_group *tpg = container_of(se_tpg,\r\nstruct iscsi_portal_group, tpg_se_tpg);\r\nacl->node_attrib.nacl = acl;\r\niscsit_set_default_node_attribues(acl, tpg);\r\n}\r\nstatic int lio_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nreturn target_put_sess_cmd(se_cmd);\r\n}\r\nstatic void lio_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);\r\npr_debug("Entering lio_release_cmd for se_cmd: %p\n", se_cmd);\r\niscsit_release_cmd(cmd);\r\n}
