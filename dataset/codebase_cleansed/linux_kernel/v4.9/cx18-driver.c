static void request_module_async(struct work_struct *work)\r\n{\r\nstruct cx18 *dev = container_of(work, struct cx18, request_module_wk);\r\nrequest_module("cx18-alsa");\r\nif (cx18_ext_init != NULL)\r\ncx18_ext_init(dev);\r\n}\r\nstatic void request_modules(struct cx18 *dev)\r\n{\r\nINIT_WORK(&dev->request_module_wk, request_module_async);\r\nschedule_work(&dev->request_module_wk);\r\n}\r\nstatic void flush_request_modules(struct cx18 *dev)\r\n{\r\nflush_work(&dev->request_module_wk);\r\n}\r\nint cx18_msleep_timeout(unsigned int msecs, int intr)\r\n{\r\nlong int timeout = msecs_to_jiffies(msecs);\r\nint sig;\r\ndo {\r\nset_current_state(intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\r\ntimeout = schedule_timeout(timeout);\r\nsig = intr ? signal_pending(current) : 0;\r\n} while (!sig && timeout);\r\nreturn sig;\r\n}\r\nstatic void cx18_iounmap(struct cx18 *cx)\r\n{\r\nif (cx == NULL)\r\nreturn;\r\nif (cx->enc_mem != NULL) {\r\nCX18_DEBUG_INFO("releasing enc_mem\n");\r\niounmap(cx->enc_mem);\r\ncx->enc_mem = NULL;\r\n}\r\n}\r\nstatic void cx18_eeprom_dump(struct cx18 *cx, unsigned char *eedata, int len)\r\n{\r\nint i;\r\nCX18_INFO("eeprom dump:\n");\r\nfor (i = 0; i < len; i++) {\r\nif (0 == (i % 16))\r\nCX18_INFO("eeprom %02x:", i);\r\nprintk(KERN_CONT " %02x", eedata[i]);\r\nif (15 == (i % 16))\r\nprintk(KERN_CONT "\n");\r\n}\r\n}\r\nvoid cx18_read_eeprom(struct cx18 *cx, struct tveeprom *tv)\r\n{\r\nstruct i2c_client *c;\r\nu8 eedata[256];\r\nmemset(tv, 0, sizeof(*tv));\r\nc = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c)\r\nreturn;\r\nstrlcpy(c->name, "cx18 tveeprom tmp", sizeof(c->name));\r\nc->adapter = &cx->i2c_adap[0];\r\nc->addr = 0xa0 >> 1;\r\nif (tveeprom_read(c, eedata, sizeof(eedata)))\r\ngoto ret;\r\nswitch (cx->card->type) {\r\ncase CX18_CARD_HVR_1600_ESMT:\r\ncase CX18_CARD_HVR_1600_SAMSUNG:\r\ncase CX18_CARD_HVR_1600_S5H1411:\r\ntveeprom_hauppauge_analog(c, tv, eedata);\r\nbreak;\r\ncase CX18_CARD_YUAN_MPC718:\r\ncase CX18_CARD_GOTVIEW_PCI_DVD3:\r\ntv->model = 0x718;\r\ncx18_eeprom_dump(cx, eedata, sizeof(eedata));\r\nCX18_INFO("eeprom PCI ID: %02x%02x:%02x%02x\n",\r\needata[2], eedata[1], eedata[4], eedata[3]);\r\nbreak;\r\ndefault:\r\ntv->model = 0xffffffff;\r\ncx18_eeprom_dump(cx, eedata, sizeof(eedata));\r\nbreak;\r\n}\r\nret:\r\nkfree(c);\r\n}\r\nstatic void cx18_process_eeprom(struct cx18 *cx)\r\n{\r\nstruct tveeprom tv;\r\ncx18_read_eeprom(cx, &tv);\r\nswitch (tv.model) {\r\ncase 74301:\r\ncase 74321:\r\ncase 74351:\r\ncase 74361:\r\ncx->card = cx18_get_card(CX18_CARD_HVR_1600_S5H1411);\r\nbreak;\r\ncase 74021:\r\ncase 74031:\r\ncase 74041:\r\ncase 74141:\r\ncase 74541:\r\ncase 74551:\r\ncase 74591:\r\ncase 74651:\r\ncase 74691:\r\ncase 74751:\r\ncase 74891:\r\ncx->card = cx18_get_card(CX18_CARD_HVR_1600_ESMT);\r\nbreak;\r\ncase 0x718:\r\nreturn;\r\ncase 0xffffffff:\r\nCX18_INFO("Unknown EEPROM encoding\n");\r\nreturn;\r\ncase 0:\r\nCX18_ERR("Invalid EEPROM\n");\r\nreturn;\r\ndefault:\r\nCX18_ERR("Unknown model %d, defaulting to original HVR-1600 "\r\n"(cardtype=1)\n", tv.model);\r\ncx->card = cx18_get_card(CX18_CARD_HVR_1600_ESMT);\r\nbreak;\r\n}\r\ncx->v4l2_cap = cx->card->v4l2_capabilities;\r\ncx->card_name = cx->card->name;\r\ncx->card_i2c = cx->card->i2c;\r\nCX18_INFO("Autodetected %s\n", cx->card_name);\r\nif (tv.tuner_type == TUNER_ABSENT)\r\nCX18_ERR("tveeprom cannot autodetect tuner!\n");\r\nif (cx->options.tuner == -1)\r\ncx->options.tuner = tv.tuner_type;\r\nif (cx->options.radio == -1)\r\ncx->options.radio = (tv.has_radio != 0);\r\nif (cx->std != 0)\r\nreturn;\r\n#define TVEEPROM_TUNER_FORMAT_ALL (V4L2_STD_B | V4L2_STD_GH | \\r\nV4L2_STD_MN | \\r\nV4L2_STD_PAL_I | \\r\nV4L2_STD_SECAM_L | V4L2_STD_SECAM_LC | \\r\nV4L2_STD_DK)\r\nif ((tv.tuner_formats & TVEEPROM_TUNER_FORMAT_ALL)\r\n== TVEEPROM_TUNER_FORMAT_ALL) {\r\nCX18_DEBUG_INFO("Worldwide tuner detected\n");\r\ncx->std = V4L2_STD_ALL;\r\n} else if (tv.tuner_formats & V4L2_STD_PAL) {\r\nCX18_DEBUG_INFO("PAL tuner detected\n");\r\ncx->std |= V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\r\n} else if (tv.tuner_formats & V4L2_STD_NTSC) {\r\nCX18_DEBUG_INFO("NTSC tuner detected\n");\r\ncx->std |= V4L2_STD_NTSC_M;\r\n} else if (tv.tuner_formats & V4L2_STD_SECAM) {\r\nCX18_DEBUG_INFO("SECAM tuner detected\n");\r\ncx->std |= V4L2_STD_SECAM_L;\r\n} else {\r\nCX18_INFO("No tuner detected, default to NTSC-M\n");\r\ncx->std |= V4L2_STD_NTSC_M;\r\n}\r\n}\r\nstatic v4l2_std_id cx18_parse_std(struct cx18 *cx)\r\n{\r\nswitch (pal[0]) {\r\ncase '6':\r\nreturn V4L2_STD_PAL_60;\r\ncase 'b':\r\ncase 'B':\r\ncase 'g':\r\ncase 'G':\r\nreturn V4L2_STD_PAL_BG;\r\ncase 'h':\r\ncase 'H':\r\nreturn V4L2_STD_PAL_H;\r\ncase 'n':\r\ncase 'N':\r\nif (pal[1] == 'c' || pal[1] == 'C')\r\nreturn V4L2_STD_PAL_Nc;\r\nreturn V4L2_STD_PAL_N;\r\ncase 'i':\r\ncase 'I':\r\nreturn V4L2_STD_PAL_I;\r\ncase 'd':\r\ncase 'D':\r\ncase 'k':\r\ncase 'K':\r\nreturn V4L2_STD_PAL_DK;\r\ncase 'M':\r\ncase 'm':\r\nreturn V4L2_STD_PAL_M;\r\ncase '-':\r\nbreak;\r\ndefault:\r\nCX18_WARN("pal= argument not recognised\n");\r\nreturn 0;\r\n}\r\nswitch (secam[0]) {\r\ncase 'b':\r\ncase 'B':\r\ncase 'g':\r\ncase 'G':\r\ncase 'h':\r\ncase 'H':\r\nreturn V4L2_STD_SECAM_B | V4L2_STD_SECAM_G | V4L2_STD_SECAM_H;\r\ncase 'd':\r\ncase 'D':\r\ncase 'k':\r\ncase 'K':\r\nreturn V4L2_STD_SECAM_DK;\r\ncase 'l':\r\ncase 'L':\r\nif (secam[1] == 'C' || secam[1] == 'c')\r\nreturn V4L2_STD_SECAM_LC;\r\nreturn V4L2_STD_SECAM_L;\r\ncase '-':\r\nbreak;\r\ndefault:\r\nCX18_WARN("secam= argument not recognised\n");\r\nreturn 0;\r\n}\r\nswitch (ntsc[0]) {\r\ncase 'm':\r\ncase 'M':\r\nreturn V4L2_STD_NTSC_M;\r\ncase 'j':\r\ncase 'J':\r\nreturn V4L2_STD_NTSC_M_JP;\r\ncase 'k':\r\ncase 'K':\r\nreturn V4L2_STD_NTSC_M_KR;\r\ncase '-':\r\nbreak;\r\ndefault:\r\nCX18_WARN("ntsc= argument not recognised\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cx18_process_options(struct cx18 *cx)\r\n{\r\nint i, j;\r\ncx->options.megabytes[CX18_ENC_STREAM_TYPE_TS] = enc_ts_buffers;\r\ncx->options.megabytes[CX18_ENC_STREAM_TYPE_MPG] = enc_mpg_buffers;\r\ncx->options.megabytes[CX18_ENC_STREAM_TYPE_IDX] = enc_idx_buffers;\r\ncx->options.megabytes[CX18_ENC_STREAM_TYPE_YUV] = enc_yuv_buffers;\r\ncx->options.megabytes[CX18_ENC_STREAM_TYPE_VBI] = enc_vbi_buffers;\r\ncx->options.megabytes[CX18_ENC_STREAM_TYPE_PCM] = enc_pcm_buffers;\r\ncx->options.megabytes[CX18_ENC_STREAM_TYPE_RAD] = 0;\r\ncx->stream_buffers[CX18_ENC_STREAM_TYPE_TS] = enc_ts_bufs;\r\ncx->stream_buffers[CX18_ENC_STREAM_TYPE_MPG] = enc_mpg_bufs;\r\ncx->stream_buffers[CX18_ENC_STREAM_TYPE_IDX] = enc_idx_bufs;\r\ncx->stream_buffers[CX18_ENC_STREAM_TYPE_YUV] = enc_yuv_bufs;\r\ncx->stream_buffers[CX18_ENC_STREAM_TYPE_VBI] = enc_vbi_bufs;\r\ncx->stream_buffers[CX18_ENC_STREAM_TYPE_PCM] = enc_pcm_bufs;\r\ncx->stream_buffers[CX18_ENC_STREAM_TYPE_RAD] = 0;\r\ncx->stream_buf_size[CX18_ENC_STREAM_TYPE_TS] = enc_ts_bufsize;\r\ncx->stream_buf_size[CX18_ENC_STREAM_TYPE_MPG] = enc_mpg_bufsize;\r\ncx->stream_buf_size[CX18_ENC_STREAM_TYPE_IDX] = enc_idx_bufsize;\r\ncx->stream_buf_size[CX18_ENC_STREAM_TYPE_YUV] = enc_yuv_bufsize;\r\ncx->stream_buf_size[CX18_ENC_STREAM_TYPE_VBI] = VBI_ACTIVE_SAMPLES * 36;\r\ncx->stream_buf_size[CX18_ENC_STREAM_TYPE_PCM] = enc_pcm_bufsize;\r\ncx->stream_buf_size[CX18_ENC_STREAM_TYPE_RAD] = 0;\r\nfor (i = 0; i < CX18_MAX_STREAMS; i++) {\r\nif (cx->stream_buffers[i] == 0 ||\r\ncx->options.megabytes[i] <= 0 ||\r\ncx->stream_buf_size[i] <= 0) {\r\ncx->options.megabytes[i] = 0;\r\ncx->stream_buffers[i] = 0;\r\ncx->stream_buf_size[i] = 0;\r\ncontinue;\r\n}\r\nif (i == CX18_ENC_STREAM_TYPE_YUV) {\r\ncx->stream_buf_size[i] *= 1024;\r\ncx->stream_buf_size[i] -=\r\n(cx->stream_buf_size[i] % CX18_UNIT_ENC_YUV_BUFSIZE);\r\nif (cx->stream_buf_size[i] < CX18_UNIT_ENC_YUV_BUFSIZE)\r\ncx->stream_buf_size[i] =\r\nCX18_UNIT_ENC_YUV_BUFSIZE;\r\n} else if (i == CX18_ENC_STREAM_TYPE_IDX) {\r\ncx->stream_buf_size[i] *= 1024;\r\ncx->stream_buf_size[i] -=\r\n(cx->stream_buf_size[i] % CX18_UNIT_ENC_IDX_BUFSIZE);\r\nif (cx->stream_buf_size[i] < CX18_UNIT_ENC_IDX_BUFSIZE)\r\ncx->stream_buf_size[i] =\r\nCX18_UNIT_ENC_IDX_BUFSIZE;\r\n}\r\nif (i == CX18_ENC_STREAM_TYPE_VBI ||\r\ni == CX18_ENC_STREAM_TYPE_YUV ||\r\ni == CX18_ENC_STREAM_TYPE_IDX) {\r\nif (cx->stream_buffers[i] < 0) {\r\ncx->stream_buffers[i] =\r\ncx->options.megabytes[i] * 1024 * 1024\r\n/ cx->stream_buf_size[i];\r\n} else {\r\ncx->options.megabytes[i] =\r\ncx->stream_buffers[i]\r\n* cx->stream_buf_size[i]/(1024 * 1024);\r\n}\r\n} else {\r\nif (cx->stream_buffers[i] < 0) {\r\ncx->stream_buffers[i] =\r\ncx->options.megabytes[i] * 1024\r\n/ cx->stream_buf_size[i];\r\n} else {\r\ncx->options.megabytes[i] =\r\ncx->stream_buffers[i]\r\n* cx->stream_buf_size[i] / 1024;\r\n}\r\ncx->stream_buf_size[i] *= 1024;\r\n}\r\nCX18_DEBUG_INFO("Stream type %d options: %d MB, %d buffers, "\r\n"%d bytes\n", i, cx->options.megabytes[i],\r\ncx->stream_buffers[i], cx->stream_buf_size[i]);\r\n}\r\ncx->options.cardtype = cardtype[cx->instance];\r\ncx->options.tuner = tuner[cx->instance];\r\ncx->options.radio = radio[cx->instance];\r\ncx->std = cx18_parse_std(cx);\r\nif (cx->options.cardtype == -1) {\r\nCX18_INFO("Ignore card\n");\r\nreturn;\r\n}\r\ncx->card = cx18_get_card(cx->options.cardtype - 1);\r\nif (cx->card)\r\nCX18_INFO("User specified %s card\n", cx->card->name);\r\nelse if (cx->options.cardtype != 0)\r\nCX18_ERR("Unknown user specified type, trying to autodetect card\n");\r\nif (cx->card == NULL) {\r\nif (cx->pci_dev->subsystem_vendor == CX18_PCI_ID_HAUPPAUGE) {\r\ncx->card = cx18_get_card(CX18_CARD_HVR_1600_ESMT);\r\nCX18_INFO("Autodetected Hauppauge card\n");\r\n}\r\n}\r\nif (cx->card == NULL) {\r\nfor (i = 0; (cx->card = cx18_get_card(i)); i++) {\r\nif (cx->card->pci_list == NULL)\r\ncontinue;\r\nfor (j = 0; cx->card->pci_list[j].device; j++) {\r\nif (cx->pci_dev->device !=\r\ncx->card->pci_list[j].device)\r\ncontinue;\r\nif (cx->pci_dev->subsystem_vendor !=\r\ncx->card->pci_list[j].subsystem_vendor)\r\ncontinue;\r\nif (cx->pci_dev->subsystem_device !=\r\ncx->card->pci_list[j].subsystem_device)\r\ncontinue;\r\nCX18_INFO("Autodetected %s card\n", cx->card->name);\r\ngoto done;\r\n}\r\n}\r\n}\r\ndone:\r\nif (cx->card == NULL) {\r\ncx->card = cx18_get_card(CX18_CARD_HVR_1600_ESMT);\r\nCX18_ERR("Unknown card: vendor/device: [%04x:%04x]\n",\r\ncx->pci_dev->vendor, cx->pci_dev->device);\r\nCX18_ERR(" subsystem vendor/device: [%04x:%04x]\n",\r\ncx->pci_dev->subsystem_vendor,\r\ncx->pci_dev->subsystem_device);\r\nCX18_ERR("Defaulting to %s card\n", cx->card->name);\r\nCX18_ERR("Please mail the vendor/device and subsystem vendor/device IDs and what kind of\n");\r\nCX18_ERR("card you have to the ivtv-devel mailinglist (www.ivtvdriver.org)\n");\r\nCX18_ERR("Prefix your subject line with [UNKNOWN CX18 CARD].\n");\r\n}\r\ncx->v4l2_cap = cx->card->v4l2_capabilities;\r\ncx->card_name = cx->card->name;\r\ncx->card_i2c = cx->card->i2c;\r\n}\r\nstatic int cx18_create_in_workq(struct cx18 *cx)\r\n{\r\nsnprintf(cx->in_workq_name, sizeof(cx->in_workq_name), "%s-in",\r\ncx->v4l2_dev.name);\r\ncx->in_work_queue = alloc_ordered_workqueue("%s", 0, cx->in_workq_name);\r\nif (cx->in_work_queue == NULL) {\r\nCX18_ERR("Unable to create incoming mailbox handler thread\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cx18_init_in_work_orders(struct cx18 *cx)\r\n{\r\nint i;\r\nfor (i = 0; i < CX18_MAX_IN_WORK_ORDERS; i++) {\r\ncx->in_work_order[i].cx = cx;\r\ncx->in_work_order[i].str = cx->epu_debug_str;\r\nINIT_WORK(&cx->in_work_order[i].work, cx18_in_work_handler);\r\n}\r\n}\r\nstatic int cx18_init_struct1(struct cx18 *cx)\r\n{\r\nint ret;\r\ncx->base_addr = pci_resource_start(cx->pci_dev, 0);\r\nmutex_init(&cx->serialize_lock);\r\nmutex_init(&cx->gpio_lock);\r\nmutex_init(&cx->epu2apu_mb_lock);\r\nmutex_init(&cx->epu2cpu_mb_lock);\r\nret = cx18_create_in_workq(cx);\r\nif (ret)\r\nreturn ret;\r\ncx18_init_in_work_orders(cx);\r\ncx->open_id = 1;\r\ncx->cxhdl.port = CX2341X_PORT_MEMORY;\r\ncx->cxhdl.capabilities = CX2341X_CAP_HAS_TS | CX2341X_CAP_HAS_SLICED_VBI;\r\ncx->cxhdl.ops = &cx18_cxhdl_ops;\r\ncx->cxhdl.func = cx18_api_func;\r\ncx->cxhdl.priv = &cx->streams[CX18_ENC_STREAM_TYPE_MPG];\r\nret = cx2341x_handler_init(&cx->cxhdl, 50);\r\nif (ret)\r\nreturn ret;\r\ncx->v4l2_dev.ctrl_handler = &cx->cxhdl.hdl;\r\ncx->temporal_strength = cx->cxhdl.video_temporal_filter->cur.val;\r\ncx->spatial_strength = cx->cxhdl.video_spatial_filter->cur.val;\r\ncx->filter_mode = cx->cxhdl.video_spatial_filter_mode->cur.val |\r\n(cx->cxhdl.video_temporal_filter_mode->cur.val << 1) |\r\n(cx->cxhdl.video_median_filter_type->cur.val << 2);\r\ninit_waitqueue_head(&cx->cap_w);\r\ninit_waitqueue_head(&cx->mb_apu_waitq);\r\ninit_waitqueue_head(&cx->mb_cpu_waitq);\r\ninit_waitqueue_head(&cx->dma_waitq);\r\ncx->vbi.in.type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\ncx->vbi.sliced_in = &cx->vbi.in.fmt.sliced;\r\nINIT_LIST_HEAD(&cx->vbi.sliced_mpeg_buf.list);\r\nINIT_LIST_HEAD(&cx->vbi.sliced_mpeg_mdl.list);\r\nINIT_LIST_HEAD(&cx->vbi.sliced_mpeg_mdl.buf_list);\r\nlist_add(&cx->vbi.sliced_mpeg_buf.list,\r\n&cx->vbi.sliced_mpeg_mdl.buf_list);\r\nreturn 0;\r\n}\r\nstatic void cx18_init_struct2(struct cx18 *cx)\r\n{\r\nint i;\r\nfor (i = 0; i < CX18_CARD_MAX_VIDEO_INPUTS - 1; i++)\r\nif (cx->card->video_inputs[i].video_type == 0)\r\nbreak;\r\ncx->nof_inputs = i;\r\nfor (i = 0; i < CX18_CARD_MAX_AUDIO_INPUTS - 1; i++)\r\nif (cx->card->audio_inputs[i].audio_type == 0)\r\nbreak;\r\ncx->nof_audio_inputs = i;\r\nfor (i = 0; i < cx->nof_inputs; i++) {\r\nif (cx->card->video_inputs[i].video_type ==\r\nCX18_CARD_INPUT_VID_TUNER)\r\nbreak;\r\n}\r\nif (i == cx->nof_inputs)\r\ni = 0;\r\ncx->active_input = i;\r\ncx->audio_input = cx->card->video_inputs[i].audio_index;\r\n}\r\nstatic int cx18_setup_pci(struct cx18 *cx, struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nu16 cmd;\r\nunsigned char pci_latency;\r\nCX18_DEBUG_INFO("Enabling pci device\n");\r\nif (pci_enable_device(pci_dev)) {\r\nCX18_ERR("Can't enable device %d!\n", cx->instance);\r\nreturn -EIO;\r\n}\r\nif (pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32))) {\r\nCX18_ERR("No suitable DMA available, card %d\n", cx->instance);\r\nreturn -EIO;\r\n}\r\nif (!request_mem_region(cx->base_addr, CX18_MEM_SIZE, "cx18 encoder")) {\r\nCX18_ERR("Cannot request encoder memory region, card %d\n",\r\ncx->instance);\r\nreturn -EIO;\r\n}\r\npci_read_config_word(pci_dev, PCI_COMMAND, &cmd);\r\ncmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\r\npci_write_config_word(pci_dev, PCI_COMMAND, cmd);\r\ncx->card_rev = pci_dev->revision;\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &pci_latency);\r\nif (pci_latency < 64 && cx18_pci_latency) {\r\nCX18_INFO("Unreasonably low latency timer, "\r\n"setting to 64 (was %d)\n", pci_latency);\r\npci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, 64);\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &pci_latency);\r\n}\r\nCX18_DEBUG_INFO("cx%d (rev %d) at %02x:%02x.%x, "\r\n"irq: %d, latency: %d, memory: 0x%llx\n",\r\ncx->pci_dev->device, cx->card_rev, pci_dev->bus->number,\r\nPCI_SLOT(pci_dev->devfn), PCI_FUNC(pci_dev->devfn),\r\ncx->pci_dev->irq, pci_latency, (u64)cx->base_addr);\r\nreturn 0;\r\n}\r\nstatic void cx18_init_subdevs(struct cx18 *cx)\r\n{\r\nu32 hw = cx->card->hw_all;\r\nu32 device;\r\nint i;\r\nfor (i = 0, device = 1; i < 32; i++, device <<= 1) {\r\nif (!(device & hw))\r\ncontinue;\r\nswitch (device) {\r\ncase CX18_HW_DVB:\r\ncase CX18_HW_TVEEPROM:\r\ncx->hw_flags |= device;\r\nbreak;\r\ncase CX18_HW_418_AV:\r\ncx->hw_flags |= device;\r\nbreak;\r\ncase CX18_HW_GPIO_RESET_CTRL:\r\nbreak;\r\ncase CX18_HW_GPIO_MUX:\r\nif (cx18_gpio_register(cx, device) == 0)\r\ncx->hw_flags |= device;\r\nbreak;\r\ndefault:\r\nif (cx18_i2c_register(cx, i) == 0)\r\ncx->hw_flags |= device;\r\nbreak;\r\n}\r\n}\r\nif (cx->hw_flags & CX18_HW_418_AV)\r\ncx->sd_av = cx18_find_hw(cx, CX18_HW_418_AV);\r\nif (cx->card->hw_muxer != 0)\r\ncx->sd_extmux = cx18_find_hw(cx, cx->card->hw_muxer);\r\n}\r\nstatic int cx18_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nint retval = 0;\r\nint i;\r\nu32 devtype;\r\nstruct cx18 *cx;\r\ni = atomic_inc_return(&cx18_instance) - 1;\r\nif (i >= CX18_MAX_CARDS) {\r\nprintk(KERN_ERR "cx18: cannot manage card %d, driver has a "\r\n"limit of 0 - %d\n", i, CX18_MAX_CARDS - 1);\r\nreturn -ENOMEM;\r\n}\r\ncx = kzalloc(sizeof(struct cx18), GFP_ATOMIC);\r\nif (cx == NULL) {\r\nprintk(KERN_ERR "cx18: cannot manage card %d, out of memory\n",\r\ni);\r\nreturn -ENOMEM;\r\n}\r\ncx->pci_dev = pci_dev;\r\ncx->instance = i;\r\nretval = v4l2_device_register(&pci_dev->dev, &cx->v4l2_dev);\r\nif (retval) {\r\nprintk(KERN_ERR "cx18: v4l2_device_register of card %d failed"\r\n"\n", cx->instance);\r\nkfree(cx);\r\nreturn retval;\r\n}\r\nsnprintf(cx->v4l2_dev.name, sizeof(cx->v4l2_dev.name), "cx18-%d",\r\ncx->instance);\r\nCX18_INFO("Initializing card %d\n", cx->instance);\r\ncx18_process_options(cx);\r\nif (cx->options.cardtype == -1) {\r\nretval = -ENODEV;\r\ngoto err;\r\n}\r\nretval = cx18_init_struct1(cx);\r\nif (retval)\r\ngoto err;\r\nCX18_DEBUG_INFO("base addr: 0x%llx\n", (u64)cx->base_addr);\r\nretval = cx18_setup_pci(cx, pci_dev, pci_id);\r\nif (retval != 0)\r\ngoto free_workqueues;\r\nCX18_DEBUG_INFO("attempting ioremap at 0x%llx len 0x%08x\n",\r\n(u64)cx->base_addr + CX18_MEM_OFFSET, CX18_MEM_SIZE);\r\ncx->enc_mem = ioremap_nocache(cx->base_addr + CX18_MEM_OFFSET,\r\nCX18_MEM_SIZE);\r\nif (!cx->enc_mem) {\r\nCX18_ERR("ioremap failed. Can't get a window into CX23418 "\r\n"memory and register space\n");\r\nCX18_ERR("Each capture card with a CX23418 needs 64 MB of "\r\n"vmalloc address space for the window\n");\r\nCX18_ERR("Check the output of 'grep Vmalloc /proc/meminfo'\n");\r\nCX18_ERR("Use the vmalloc= kernel command line option to set "\r\n"VmallocTotal to a larger value\n");\r\nretval = -ENOMEM;\r\ngoto free_mem;\r\n}\r\ncx->reg_mem = cx->enc_mem + CX18_REG_OFFSET;\r\ndevtype = cx18_read_reg(cx, 0xC72028);\r\nswitch (devtype & 0xff000000) {\r\ncase 0xff000000:\r\nCX18_INFO("cx23418 revision %08x (A)\n", devtype);\r\nbreak;\r\ncase 0x01000000:\r\nCX18_INFO("cx23418 revision %08x (B)\n", devtype);\r\nbreak;\r\ndefault:\r\nCX18_INFO("cx23418 revision %08x (Unknown)\n", devtype);\r\nbreak;\r\n}\r\ncx18_init_power(cx, 1);\r\ncx18_init_memory(cx);\r\ncx->scb = (struct cx18_scb __iomem *)(cx->enc_mem + SCB_OFFSET);\r\ncx18_init_scb(cx);\r\ncx18_gpio_init(cx);\r\nretval = cx18_av_probe(cx);\r\nif (retval) {\r\nCX18_ERR("Could not register A/V decoder subdevice\n");\r\ngoto free_map;\r\n}\r\nif (cx->card->hw_all & CX18_HW_GPIO_RESET_CTRL) {\r\nif (cx18_gpio_register(cx, CX18_HW_GPIO_RESET_CTRL) != 0)\r\nCX18_WARN("Could not register GPIO reset controller"\r\n"subdevice; proceeding anyway.\n");\r\nelse\r\ncx->hw_flags |= CX18_HW_GPIO_RESET_CTRL;\r\n}\r\nCX18_DEBUG_INFO("activating i2c...\n");\r\nretval = init_cx18_i2c(cx);\r\nif (retval) {\r\nCX18_ERR("Could not initialize i2c\n");\r\ngoto free_map;\r\n}\r\nif (cx->card->hw_all & CX18_HW_TVEEPROM) {\r\nconst struct cx18_card *orig_card = cx->card;\r\ncx18_process_eeprom(cx);\r\nif (cx->card != orig_card) {\r\ncx18_gpio_init(cx);\r\ncx18_call_hw(cx, CX18_HW_GPIO_RESET_CTRL,\r\ncore, reset, (u32) CX18_GPIO_RESET_I2C);\r\n}\r\n}\r\nif (cx->card->comment)\r\nCX18_INFO("%s", cx->card->comment);\r\nif (cx->card->v4l2_capabilities == 0) {\r\nretval = -ENODEV;\r\ngoto free_i2c;\r\n}\r\ncx18_init_memory(cx);\r\ncx18_init_scb(cx);\r\nretval = request_irq(cx->pci_dev->irq, cx18_irq_handler,\r\nIRQF_SHARED, cx->v4l2_dev.name, (void *)cx);\r\nif (retval) {\r\nCX18_ERR("Failed to register irq %d\n", retval);\r\ngoto free_i2c;\r\n}\r\nif (cx->std == 0)\r\ncx->std = V4L2_STD_NTSC_M;\r\nif (cx->options.tuner == -1) {\r\nfor (i = 0; i < CX18_CARD_MAX_TUNERS; i++) {\r\nif ((cx->std & cx->card->tuners[i].std) == 0)\r\ncontinue;\r\ncx->options.tuner = cx->card->tuners[i].tuner;\r\nbreak;\r\n}\r\n}\r\nif (cx->options.tuner == -1 && cx->card->tuners[0].std) {\r\ncx->std = cx->card->tuners[0].std;\r\nif (cx->std & V4L2_STD_PAL)\r\ncx->std = V4L2_STD_PAL_BG | V4L2_STD_PAL_H;\r\nelse if (cx->std & V4L2_STD_NTSC)\r\ncx->std = V4L2_STD_NTSC_M;\r\nelse if (cx->std & V4L2_STD_SECAM)\r\ncx->std = V4L2_STD_SECAM_L;\r\ncx->options.tuner = cx->card->tuners[0].tuner;\r\n}\r\nif (cx->options.radio == -1)\r\ncx->options.radio = (cx->card->radio_input.audio_type != 0);\r\ncx18_init_struct2(cx);\r\ncx18_init_subdevs(cx);\r\nif (cx->std & V4L2_STD_525_60)\r\ncx->is_60hz = 1;\r\nelse\r\ncx->is_50hz = 1;\r\ncx2341x_handler_set_50hz(&cx->cxhdl, !cx->is_60hz);\r\nif (cx->options.radio > 0)\r\ncx->v4l2_cap |= V4L2_CAP_RADIO;\r\nif (cx->options.tuner > -1) {\r\nstruct tuner_setup setup;\r\nsetup.addr = ADDR_UNSET;\r\nsetup.type = cx->options.tuner;\r\nsetup.mode_mask = T_ANALOG_TV;\r\nsetup.config = NULL;\r\nif (cx->options.radio > 0)\r\nsetup.mode_mask |= T_RADIO;\r\nsetup.tuner_callback = (setup.type == TUNER_XC2028) ?\r\ncx18_reset_tuner_gpio : NULL;\r\ncx18_call_all(cx, tuner, s_type_addr, &setup);\r\nif (setup.type == TUNER_XC2028) {\r\nstatic struct xc2028_ctrl ctrl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64,\r\n};\r\nstruct v4l2_priv_tun_config cfg = {\r\n.tuner = cx->options.tuner,\r\n.priv = &ctrl,\r\n};\r\ncx18_call_all(cx, tuner, s_config, &cfg);\r\n}\r\n}\r\ncx->tuner_std = cx->std;\r\nif (cx->std == V4L2_STD_ALL)\r\ncx->std = V4L2_STD_NTSC_M;\r\nretval = cx18_streams_setup(cx);\r\nif (retval) {\r\nCX18_ERR("Error %d setting up streams\n", retval);\r\ngoto free_irq;\r\n}\r\nretval = cx18_streams_register(cx);\r\nif (retval) {\r\nCX18_ERR("Error %d registering devices\n", retval);\r\ngoto free_streams;\r\n}\r\nCX18_INFO("Initialized card: %s\n", cx->card_name);\r\nrequest_modules(cx);\r\nreturn 0;\r\nfree_streams:\r\ncx18_streams_cleanup(cx, 1);\r\nfree_irq:\r\nfree_irq(cx->pci_dev->irq, (void *)cx);\r\nfree_i2c:\r\nexit_cx18_i2c(cx);\r\nfree_map:\r\ncx18_iounmap(cx);\r\nfree_mem:\r\nrelease_mem_region(cx->base_addr, CX18_MEM_SIZE);\r\nfree_workqueues:\r\ndestroy_workqueue(cx->in_work_queue);\r\nerr:\r\nif (retval == 0)\r\nretval = -ENODEV;\r\nCX18_ERR("Error %d on initialization\n", retval);\r\nv4l2_device_unregister(&cx->v4l2_dev);\r\nkfree(cx);\r\nreturn retval;\r\n}\r\nint cx18_init_on_first_open(struct cx18 *cx)\r\n{\r\nint video_input;\r\nint fw_retry_count = 3;\r\nstruct v4l2_frequency vf;\r\nstruct cx18_open_id fh;\r\nv4l2_std_id std;\r\nfh.cx = cx;\r\nif (test_bit(CX18_F_I_FAILED, &cx->i_flags))\r\nreturn -ENXIO;\r\nif (test_and_set_bit(CX18_F_I_INITED, &cx->i_flags))\r\nreturn 0;\r\nwhile (--fw_retry_count > 0) {\r\nif (cx18_firmware_init(cx) == 0)\r\nbreak;\r\nif (fw_retry_count > 1)\r\nCX18_WARN("Retry loading firmware\n");\r\n}\r\nif (fw_retry_count == 0) {\r\nset_bit(CX18_F_I_FAILED, &cx->i_flags);\r\nreturn -ENXIO;\r\n}\r\nset_bit(CX18_F_I_LOADED_FW, &cx->i_flags);\r\ncx18_vapi(cx, CX18_APU_START, 2, CX18_APU_ENCODING_METHOD_MPEG|0xb9, 0);\r\ncx18_vapi(cx, CX18_APU_RESETAI, 0);\r\ncx18_vapi(cx, CX18_APU_STOP, 1, CX18_APU_ENCODING_METHOD_MPEG);\r\nfw_retry_count = 3;\r\nwhile (--fw_retry_count > 0) {\r\nif (cx18_firmware_init(cx) == 0)\r\nbreak;\r\nif (fw_retry_count > 1)\r\nCX18_WARN("Retry loading firmware\n");\r\n}\r\nif (fw_retry_count == 0) {\r\nset_bit(CX18_F_I_FAILED, &cx->i_flags);\r\nreturn -ENXIO;\r\n}\r\ncx18_vapi(cx, CX18_APU_START, 2, CX18_APU_ENCODING_METHOD_MPEG|0xb9, 0);\r\ncx18_vapi(cx, CX18_APU_RESETAI, 0);\r\ncx18_vapi(cx, CX18_APU_STOP, 1, CX18_APU_ENCODING_METHOD_MPEG);\r\nv4l2_subdev_call(cx->sd_av, core, load_fw);\r\nvf.tuner = 0;\r\nvf.type = V4L2_TUNER_ANALOG_TV;\r\nvf.frequency = 6400;\r\nif (cx->std == V4L2_STD_NTSC_M_JP)\r\nvf.frequency = 1460;\r\nelse if (cx->std & V4L2_STD_NTSC_M)\r\nvf.frequency = 1076;\r\nvideo_input = cx->active_input;\r\ncx->active_input++;\r\ncx18_s_input(NULL, &fh, video_input);\r\ncx->std++;\r\nstd = (cx->tuner_std == V4L2_STD_ALL) ? V4L2_STD_NTSC_M : cx->tuner_std;\r\ncx18_s_std(NULL, &fh, std);\r\ncx18_s_frequency(NULL, &fh, &vf);\r\nreturn 0;\r\n}\r\nstatic void cx18_cancel_in_work_orders(struct cx18 *cx)\r\n{\r\nint i;\r\nfor (i = 0; i < CX18_MAX_IN_WORK_ORDERS; i++)\r\ncancel_work_sync(&cx->in_work_order[i].work);\r\n}\r\nstatic void cx18_cancel_out_work_orders(struct cx18 *cx)\r\n{\r\nint i;\r\nfor (i = 0; i < CX18_MAX_STREAMS; i++)\r\nif (&cx->streams[i].video_dev != NULL)\r\ncancel_work_sync(&cx->streams[i].out_work_order);\r\n}\r\nstatic void cx18_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct cx18 *cx = to_cx18(v4l2_dev);\r\nint i;\r\nCX18_DEBUG_INFO("Removing Card\n");\r\nflush_request_modules(cx);\r\nCX18_DEBUG_INFO("Stopping all streams\n");\r\nif (atomic_read(&cx->tot_capturing) > 0)\r\ncx18_stop_all_captures(cx);\r\ncx18_sw1_irq_disable(cx, IRQ_CPU_TO_EPU | IRQ_APU_TO_EPU);\r\ncx18_cancel_in_work_orders(cx);\r\ncx18_cancel_out_work_orders(cx);\r\ncx18_sw2_irq_disable(cx, IRQ_CPU_TO_EPU_ACK | IRQ_APU_TO_EPU_ACK);\r\ncx18_halt_firmware(cx);\r\ndestroy_workqueue(cx->in_work_queue);\r\ncx18_streams_cleanup(cx, 1);\r\nexit_cx18_i2c(cx);\r\nfree_irq(cx->pci_dev->irq, (void *)cx);\r\ncx18_iounmap(cx);\r\nrelease_mem_region(cx->base_addr, CX18_MEM_SIZE);\r\npci_disable_device(cx->pci_dev);\r\nif (cx->vbi.sliced_mpeg_data[0] != NULL)\r\nfor (i = 0; i < CX18_VBI_FRAMES; i++)\r\nkfree(cx->vbi.sliced_mpeg_data[i]);\r\nv4l2_ctrl_handler_free(&cx->av_state.hdl);\r\nCX18_INFO("Removed %s\n", cx->card_name);\r\nv4l2_device_unregister(v4l2_dev);\r\nkfree(cx);\r\n}\r\nstatic int __init module_start(void)\r\n{\r\nprintk(KERN_INFO "cx18: Start initialization, version %s\n",\r\nCX18_VERSION);\r\nif (cx18_first_minor < 0 || cx18_first_minor >= CX18_MAX_CARDS) {\r\nprintk(KERN_ERR "cx18: Exiting, cx18_first_minor must be between 0 and %d\n",\r\nCX18_MAX_CARDS - 1);\r\nreturn -1;\r\n}\r\nif (cx18_debug < 0 || cx18_debug > 511) {\r\ncx18_debug = 0;\r\nprintk(KERN_INFO "cx18: Debug value must be >= 0 and <= 511!\n");\r\n}\r\nif (pci_register_driver(&cx18_pci_driver)) {\r\nprintk(KERN_ERR "cx18: Error detecting PCI card\n");\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "cx18: End initialization\n");\r\nreturn 0;\r\n}\r\nstatic void __exit module_cleanup(void)\r\n{\r\npci_unregister_driver(&cx18_pci_driver);\r\n}
