static void init_c3(struct cpuinfo_x86 *c)\r\n{\r\nu32 lo, hi;\r\nif (cpuid_eax(0xC0000000) >= 0xC0000001) {\r\nu32 tmp = cpuid_edx(0xC0000001);\r\nif ((tmp & (ACE_PRESENT | ACE_ENABLED)) == ACE_PRESENT) {\r\nrdmsr(MSR_VIA_FCR, lo, hi);\r\nlo |= ACE_FCR;\r\nwrmsr(MSR_VIA_FCR, lo, hi);\r\npr_info("CPU: Enabled ACE h/w crypto\n");\r\n}\r\nif ((tmp & (RNG_PRESENT | RNG_ENABLED)) == RNG_PRESENT) {\r\nrdmsr(MSR_VIA_RNG, lo, hi);\r\nlo |= RNG_ENABLE;\r\nwrmsr(MSR_VIA_RNG, lo, hi);\r\npr_info("CPU: Enabled h/w RNG\n");\r\n}\r\nc->x86_capability[CPUID_C000_0001_EDX] = cpuid_edx(0xC0000001);\r\n}\r\n#ifdef CONFIG_X86_32\r\nif (c->x86_model >= 6 && c->x86_model <= 13) {\r\nrdmsr(MSR_VIA_FCR, lo, hi);\r\nlo |= (1<<1 | 1<<7);\r\nwrmsr(MSR_VIA_FCR, lo, hi);\r\nset_cpu_cap(c, X86_FEATURE_CX8);\r\n}\r\nif (c->x86_model >= 6 && c->x86_model < 9)\r\nset_cpu_cap(c, X86_FEATURE_3DNOW);\r\n#endif\r\nif (c->x86 == 0x6 && c->x86_model >= 0xf) {\r\nc->x86_cache_alignment = c->x86_clflush_size * 2;\r\nset_cpu_cap(c, X86_FEATURE_REP_GOOD);\r\n}\r\ncpu_detect_cache_sizes(c);\r\n}\r\nstatic void early_init_centaur(struct cpuinfo_x86 *c)\r\n{\r\nswitch (c->x86) {\r\n#ifdef CONFIG_X86_32\r\ncase 5:\r\nset_cpu_cap(c, X86_FEATURE_CENTAUR_MCR);\r\nbreak;\r\n#endif\r\ncase 6:\r\nif (c->x86_model >= 0xf)\r\nset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\r\nbreak;\r\n}\r\n#ifdef CONFIG_X86_64\r\nset_cpu_cap(c, X86_FEATURE_SYSENTER32);\r\n#endif\r\n}\r\nstatic void init_centaur(struct cpuinfo_x86 *c)\r\n{\r\n#ifdef CONFIG_X86_32\r\nchar *name;\r\nu32 fcr_set = 0;\r\nu32 fcr_clr = 0;\r\nu32 lo, hi, newlo;\r\nu32 aa, bb, cc, dd;\r\nclear_cpu_cap(c, 0*32+31);\r\n#endif\r\nearly_init_centaur(c);\r\nswitch (c->x86) {\r\n#ifdef CONFIG_X86_32\r\ncase 5:\r\nswitch (c->x86_model) {\r\ncase 4:\r\nname = "C6";\r\nfcr_set = ECX8|DSMC|EDCTLB|EMMX|ERETSTK;\r\nfcr_clr = DPDC;\r\npr_notice("Disabling bugged TSC.\n");\r\nclear_cpu_cap(c, X86_FEATURE_TSC);\r\nbreak;\r\ncase 8:\r\nswitch (c->x86_mask) {\r\ndefault:\r\nname = "2";\r\nbreak;\r\ncase 7 ... 9:\r\nname = "2A";\r\nbreak;\r\ncase 10 ... 15:\r\nname = "2B";\r\nbreak;\r\n}\r\nfcr_set = ECX8|DSMC|DTLOCK|EMMX|EBRPRED|ERETSTK|\r\nE2MMX|EAMD3D;\r\nfcr_clr = DPDC;\r\nbreak;\r\ncase 9:\r\nname = "3";\r\nfcr_set = ECX8|DSMC|DTLOCK|EMMX|EBRPRED|ERETSTK|\r\nE2MMX|EAMD3D;\r\nfcr_clr = DPDC;\r\nbreak;\r\ndefault:\r\nname = "??";\r\n}\r\nrdmsr(MSR_IDT_FCR1, lo, hi);\r\nnewlo = (lo|fcr_set) & (~fcr_clr);\r\nif (newlo != lo) {\r\npr_info("Centaur FCR was 0x%X now 0x%X\n",\r\nlo, newlo);\r\nwrmsr(MSR_IDT_FCR1, newlo, hi);\r\n} else {\r\npr_info("Centaur FCR is 0x%X\n", lo);\r\n}\r\nset_cpu_cap(c, X86_FEATURE_CENTAUR_MCR);\r\nset_cpu_cap(c, X86_FEATURE_CX8);\r\nif (c->x86_model >= 8)\r\nset_cpu_cap(c, X86_FEATURE_3DNOW);\r\nif (cpuid_eax(0x80000000) >= 0x80000005) {\r\ncpuid(0x80000005, &aa, &bb, &cc, &dd);\r\nc->x86_cache_size = (cc>>24)+(dd>>24);\r\n}\r\nsprintf(c->x86_model_id, "WinChip %s", name);\r\nbreak;\r\n#endif\r\ncase 6:\r\ninit_c3(c);\r\nbreak;\r\n}\r\n#ifdef CONFIG_X86_64\r\nset_cpu_cap(c, X86_FEATURE_LFENCE_RDTSC);\r\n#endif\r\n}\r\nstatic unsigned int\r\ncentaur_size_cache(struct cpuinfo_x86 *c, unsigned int size)\r\n{\r\nif ((c->x86 == 6) && ((c->x86_model == 7) || (c->x86_model == 8)))\r\nsize >>= 8;\r\nif ((c->x86 == 6) && (c->x86_model == 9) &&\r\n(c->x86_mask == 1) && (size == 65))\r\nsize -= 1;\r\nreturn size;\r\n}
