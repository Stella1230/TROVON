static int uniphier_pctl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->socdata->groups_count;\r\n}\r\nstatic const char *uniphier_pctl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->socdata->groups[selector].name;\r\n}\r\nstatic int uniphier_pctl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = priv->socdata->groups[selector].pins;\r\n*num_pins = priv->socdata->groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic void uniphier_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\nconst struct pin_desc *desc = pin_desc_get(pctldev, offset);\r\nconst char *pull_dir, *drv_type;\r\nswitch (uniphier_pin_get_pull_dir(desc->drv_data)) {\r\ncase UNIPHIER_PIN_PULL_UP:\r\npull_dir = "UP";\r\nbreak;\r\ncase UNIPHIER_PIN_PULL_DOWN:\r\npull_dir = "DOWN";\r\nbreak;\r\ncase UNIPHIER_PIN_PULL_UP_FIXED:\r\npull_dir = "UP(FIXED)";\r\nbreak;\r\ncase UNIPHIER_PIN_PULL_DOWN_FIXED:\r\npull_dir = "DOWN(FIXED)";\r\nbreak;\r\ncase UNIPHIER_PIN_PULL_NONE:\r\npull_dir = "NONE";\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nswitch (uniphier_pin_get_drv_type(desc->drv_data)) {\r\ncase UNIPHIER_PIN_DRV_1BIT:\r\ndrv_type = "4/8(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_2BIT:\r\ndrv_type = "8/12/16/20(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_3BIT:\r\ndrv_type = "4/5/7/9/11/12/14/16(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_FIXED4:\r\ndrv_type = "4(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_FIXED5:\r\ndrv_type = "5(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_FIXED8:\r\ndrv_type = "8(mA)";\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_NONE:\r\ndrv_type = "NONE";\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nseq_printf(s, " PULL_DIR=%s DRV_TYPE=%s", pull_dir, drv_type);\r\n}\r\nstatic int uniphier_conf_pin_bias_get(struct pinctrl_dev *pctldev,\r\nconst struct pin_desc *desc,\r\nenum pin_config_param param)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nenum uniphier_pin_pull_dir pull_dir =\r\nuniphier_pin_get_pull_dir(desc->drv_data);\r\nunsigned int pupdctrl, reg, shift, val;\r\nunsigned int expected = 1;\r\nint ret;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (pull_dir == UNIPHIER_PIN_PULL_NONE)\r\nreturn 0;\r\nif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED ||\r\npull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED)\r\nreturn -EINVAL;\r\nexpected = 0;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED)\r\nreturn 0;\r\nif (pull_dir != UNIPHIER_PIN_PULL_UP)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (pull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED)\r\nreturn 0;\r\nif (pull_dir != UNIPHIER_PIN_PULL_DOWN)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\npupdctrl = uniphier_pin_get_pupdctrl(desc->drv_data);\r\nreg = UNIPHIER_PINCTRL_PUPDCTRL_BASE + pupdctrl / 32 * 4;\r\nshift = pupdctrl % 32;\r\nret = regmap_read(priv->regmap, priv->regbase + reg, &val);\r\nif (ret)\r\nreturn ret;\r\nval = (val >> shift) & 1;\r\nreturn (val == expected) ? 0 : -EINVAL;\r\n}\r\nstatic int uniphier_conf_pin_drive_get(struct pinctrl_dev *pctldev,\r\nconst struct pin_desc *desc,\r\nu16 *strength)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nenum uniphier_pin_drv_type type =\r\nuniphier_pin_get_drv_type(desc->drv_data);\r\nconst unsigned int strength_1bit[] = {4, 8};\r\nconst unsigned int strength_2bit[] = {8, 12, 16, 20};\r\nconst unsigned int strength_3bit[] = {4, 5, 7, 9, 11, 12, 14, 16};\r\nconst unsigned int *supported_strength;\r\nunsigned int drvctrl, reg, shift, mask, width, val;\r\nint ret;\r\nswitch (type) {\r\ncase UNIPHIER_PIN_DRV_1BIT:\r\nsupported_strength = strength_1bit;\r\nreg = UNIPHIER_PINCTRL_DRVCTRL_BASE;\r\nwidth = 1;\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_2BIT:\r\nsupported_strength = strength_2bit;\r\nreg = UNIPHIER_PINCTRL_DRV2CTRL_BASE;\r\nwidth = 2;\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_3BIT:\r\nsupported_strength = strength_3bit;\r\nreg = UNIPHIER_PINCTRL_DRV3CTRL_BASE;\r\nwidth = 4;\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_FIXED4:\r\n*strength = 4;\r\nreturn 0;\r\ncase UNIPHIER_PIN_DRV_FIXED5:\r\n*strength = 5;\r\nreturn 0;\r\ncase UNIPHIER_PIN_DRV_FIXED8:\r\n*strength = 8;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndrvctrl = uniphier_pin_get_drvctrl(desc->drv_data);\r\ndrvctrl *= width;\r\nreg += drvctrl / 32 * 4;\r\nshift = drvctrl % 32;\r\nmask = (1U << width) - 1;\r\nret = regmap_read(priv->regmap, priv->regbase + reg, &val);\r\nif (ret)\r\nreturn ret;\r\n*strength = supported_strength[(val >> shift) & mask];\r\nreturn 0;\r\n}\r\nstatic int uniphier_conf_pin_input_enable_get(struct pinctrl_dev *pctldev,\r\nconst struct pin_desc *desc)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned int iectrl = uniphier_pin_get_iectrl(desc->drv_data);\r\nunsigned int val;\r\nint ret;\r\nif (iectrl == UNIPHIER_PIN_IECTRL_NONE)\r\nreturn 0;\r\nret = regmap_read(priv->regmap,\r\npriv->regbase + UNIPHIER_PINCTRL_IECTRL, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val & BIT(iectrl) ? 0 : -EINVAL;\r\n}\r\nstatic int uniphier_conf_pin_config_get(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs)\r\n{\r\nconst struct pin_desc *desc = pin_desc_get(pctldev, pin);\r\nenum pin_config_param param = pinconf_to_config_param(*configs);\r\nbool has_arg = false;\r\nu16 arg;\r\nint ret;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = uniphier_conf_pin_bias_get(pctldev, desc, param);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = uniphier_conf_pin_drive_get(pctldev, desc, &arg);\r\nhas_arg = true;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nret = uniphier_conf_pin_input_enable_get(pctldev, desc);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret == 0 && has_arg)\r\n*configs = pinconf_to_config_packed(param, arg);\r\nreturn ret;\r\n}\r\nstatic int uniphier_conf_pin_bias_set(struct pinctrl_dev *pctldev,\r\nconst struct pin_desc *desc,\r\nenum pin_config_param param, u16 arg)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nenum uniphier_pin_pull_dir pull_dir =\r\nuniphier_pin_get_pull_dir(desc->drv_data);\r\nunsigned int pupdctrl, reg, shift;\r\nunsigned int val = 1;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (pull_dir == UNIPHIER_PIN_PULL_NONE)\r\nreturn 0;\r\nif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED ||\r\npull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED) {\r\ndev_err(pctldev->dev,\r\n"can not disable pull register for pin %s\n",\r\ndesc->name);\r\nreturn -EINVAL;\r\n}\r\nval = 0;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED && arg != 0)\r\nreturn 0;\r\nif (pull_dir != UNIPHIER_PIN_PULL_UP) {\r\ndev_err(pctldev->dev,\r\n"pull-up is unsupported for pin %s\n",\r\ndesc->name);\r\nreturn -EINVAL;\r\n}\r\nif (arg == 0) {\r\ndev_err(pctldev->dev, "pull-up can not be total\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (pull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED && arg != 0)\r\nreturn 0;\r\nif (pull_dir != UNIPHIER_PIN_PULL_DOWN) {\r\ndev_err(pctldev->dev,\r\n"pull-down is unsupported for pin %s\n",\r\ndesc->name);\r\nreturn -EINVAL;\r\n}\r\nif (arg == 0) {\r\ndev_err(pctldev->dev, "pull-down can not be total\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\r\nif (pull_dir == UNIPHIER_PIN_PULL_NONE) {\r\ndev_err(pctldev->dev,\r\n"pull-up/down is unsupported for pin %s\n",\r\ndesc->name);\r\nreturn -EINVAL;\r\n}\r\nif (arg == 0)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\npupdctrl = uniphier_pin_get_pupdctrl(desc->drv_data);\r\nreg = UNIPHIER_PINCTRL_PUPDCTRL_BASE + pupdctrl / 32 * 4;\r\nshift = pupdctrl % 32;\r\nreturn regmap_update_bits(priv->regmap, priv->regbase + reg,\r\n1 << shift, val << shift);\r\n}\r\nstatic int uniphier_conf_pin_drive_set(struct pinctrl_dev *pctldev,\r\nconst struct pin_desc *desc,\r\nu16 strength)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nenum uniphier_pin_drv_type type =\r\nuniphier_pin_get_drv_type(desc->drv_data);\r\nconst unsigned int strength_1bit[] = {4, 8, -1};\r\nconst unsigned int strength_2bit[] = {8, 12, 16, 20, -1};\r\nconst unsigned int strength_3bit[] = {4, 5, 7, 9, 11, 12, 14, 16, -1};\r\nconst unsigned int *supported_strength;\r\nunsigned int drvctrl, reg, shift, mask, width, val;\r\nswitch (type) {\r\ncase UNIPHIER_PIN_DRV_1BIT:\r\nsupported_strength = strength_1bit;\r\nreg = UNIPHIER_PINCTRL_DRVCTRL_BASE;\r\nwidth = 1;\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_2BIT:\r\nsupported_strength = strength_2bit;\r\nreg = UNIPHIER_PINCTRL_DRV2CTRL_BASE;\r\nwidth = 2;\r\nbreak;\r\ncase UNIPHIER_PIN_DRV_3BIT:\r\nsupported_strength = strength_3bit;\r\nreg = UNIPHIER_PINCTRL_DRV3CTRL_BASE;\r\nwidth = 4;\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev,\r\n"cannot change drive strength for pin %s\n",\r\ndesc->name);\r\nreturn -EINVAL;\r\n}\r\nfor (val = 0; supported_strength[val] > 0; val++) {\r\nif (supported_strength[val] > strength)\r\nbreak;\r\n}\r\nif (val == 0) {\r\ndev_err(pctldev->dev,\r\n"unsupported drive strength %u mA for pin %s\n",\r\nstrength, desc->name);\r\nreturn -EINVAL;\r\n}\r\nval--;\r\ndrvctrl = uniphier_pin_get_drvctrl(desc->drv_data);\r\ndrvctrl *= width;\r\nreg += drvctrl / 32 * 4;\r\nshift = drvctrl % 32;\r\nmask = (1U << width) - 1;\r\nreturn regmap_update_bits(priv->regmap, priv->regbase + reg,\r\nmask << shift, val << shift);\r\n}\r\nstatic int uniphier_conf_pin_input_enable(struct pinctrl_dev *pctldev,\r\nconst struct pin_desc *desc,\r\nu16 enable)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned int iectrl = uniphier_pin_get_iectrl(desc->drv_data);\r\nunsigned int reg, mask;\r\nif (!(priv->socdata->caps & UNIPHIER_PINCTRL_CAPS_PERPIN_IECTRL) &&\r\n!enable)\r\nreturn -EINVAL;\r\nif (iectrl == UNIPHIER_PIN_IECTRL_NONE)\r\nreturn enable ? 0 : -EINVAL;\r\nreg = priv->regbase + UNIPHIER_PINCTRL_IECTRL + iectrl / 32 * 4;\r\nmask = BIT(iectrl % 32);\r\nreturn regmap_update_bits(priv->regmap, reg, mask, enable ? mask : 0);\r\n}\r\nstatic int uniphier_conf_pin_config_set(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nconst struct pin_desc *desc = pin_desc_get(pctldev, pin);\r\nint i, ret;\r\nfor (i = 0; i < num_configs; i++) {\r\nenum pin_config_param param =\r\npinconf_to_config_param(configs[i]);\r\nu16 arg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\r\nret = uniphier_conf_pin_bias_set(pctldev, desc,\r\nparam, arg);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = uniphier_conf_pin_drive_set(pctldev, desc, arg);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nret = uniphier_conf_pin_input_enable(pctldev, desc,\r\narg);\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev,\r\n"unsupported configuration parameter %u\n",\r\nparam);\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_conf_pin_config_group_set(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nconst unsigned *pins = priv->socdata->groups[selector].pins;\r\nunsigned num_pins = priv->socdata->groups[selector].num_pins;\r\nint i, ret;\r\nfor (i = 0; i < num_pins; i++) {\r\nret = uniphier_conf_pin_config_set(pctldev, pins[i],\r\nconfigs, num_configs);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_pmx_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->socdata->functions_count;\r\n}\r\nstatic const char *uniphier_pmx_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nreturn priv->socdata->functions[selector].name;\r\n}\r\nstatic int uniphier_pmx_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned *num_groups)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = priv->socdata->functions[selector].groups;\r\n*num_groups = priv->socdata->functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int uniphier_pmx_set_one_mux(struct pinctrl_dev *pctldev, unsigned pin,\r\nint muxval)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned int mux_bits, reg_stride, reg, reg_end, shift, mask;\r\nbool load_pinctrl;\r\nint ret;\r\nret = uniphier_conf_pin_input_enable(pctldev,\r\npin_desc_get(pctldev, pin), 1);\r\nif (ret)\r\nreturn ret;\r\nif (muxval < 0)\r\nreturn 0;\r\nif (priv->socdata->caps & UNIPHIER_PINCTRL_CAPS_DBGMUX_SEPARATE) {\r\nmux_bits = 4;\r\nreg_stride = 8;\r\nload_pinctrl = true;\r\n} else {\r\nmux_bits = 8;\r\nreg_stride = 4;\r\nload_pinctrl = false;\r\n}\r\nreg = UNIPHIER_PINCTRL_PINMUX_BASE + pin * mux_bits / 32 * reg_stride;\r\nreg_end = reg + reg_stride;\r\nshift = pin * mux_bits % 32;\r\nmask = (1U << mux_bits) - 1;\r\nfor (; reg < reg_end; reg += 4) {\r\nret = regmap_update_bits(priv->regmap, priv->regbase + reg,\r\nmask << shift, muxval << shift);\r\nif (ret)\r\nreturn ret;\r\nmuxval >>= mux_bits;\r\n}\r\nif (load_pinctrl) {\r\nret = regmap_write(priv->regmap,\r\npriv->regbase + UNIPHIER_PINCTRL_LOAD_PINMUX,\r\n1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_pmx_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned func_selector,\r\nunsigned group_selector)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct uniphier_pinctrl_group *grp =\r\n&priv->socdata->groups[group_selector];\r\nint i;\r\nint ret;\r\nfor (i = 0; i < grp->num_pins; i++) {\r\nret = uniphier_pmx_set_one_mux(pctldev, grp->pins[i],\r\ngrp->muxvals[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_pmx_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct uniphier_pinctrl_group *groups = priv->socdata->groups;\r\nint groups_count = priv->socdata->groups_count;\r\nenum uniphier_pinmux_gpio_range_type range_type;\r\nint i, j;\r\nif (strstr(range->name, "irq"))\r\nrange_type = UNIPHIER_PINMUX_GPIO_RANGE_IRQ;\r\nelse\r\nrange_type = UNIPHIER_PINMUX_GPIO_RANGE_PORT;\r\nfor (i = 0; i < groups_count; i++) {\r\nif (groups[i].range_type != range_type)\r\ncontinue;\r\nfor (j = 0; j < groups[i].num_pins; j++)\r\nif (groups[i].pins[j] == offset)\r\ngoto found;\r\n}\r\ndev_err(pctldev->dev, "pin %u does not support GPIO\n", offset);\r\nreturn -EINVAL;\r\nfound:\r\nreturn uniphier_pmx_set_one_mux(pctldev, offset, groups[i].muxvals[j]);\r\n}\r\nint uniphier_pinctrl_probe(struct platform_device *pdev,\r\nstruct uniphier_pinctrl_socdata *socdata)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct uniphier_pinctrl_priv *priv;\r\nstruct device_node *parent;\r\nif (!socdata ||\r\n!socdata->pins || !socdata->npins ||\r\n!socdata->groups || !socdata->groups_count ||\r\n!socdata->functions || !socdata->functions_count) {\r\ndev_err(dev, "pinctrl socdata lacks necessary members\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (of_device_is_compatible(dev->of_node, "socionext,ph1-ld4-pinctrl") ||\r\nof_device_is_compatible(dev->of_node, "socionext,ph1-pro4-pinctrl") ||\r\nof_device_is_compatible(dev->of_node, "socionext,ph1-sld8-pinctrl") ||\r\nof_device_is_compatible(dev->of_node, "socionext,ph1-pro5-pinctrl") ||\r\nof_device_is_compatible(dev->of_node, "socionext,proxstream2-pinctrl") ||\r\nof_device_is_compatible(dev->of_node, "socionext,ph1-ld6b-pinctrl")) {\r\npriv->regmap = syscon_node_to_regmap(dev->of_node);\r\n} else {\r\npriv->regbase = 0x1000;\r\nparent = of_get_parent(dev->of_node);\r\npriv->regmap = syscon_node_to_regmap(parent);\r\nof_node_put(parent);\r\n}\r\nif (IS_ERR(priv->regmap)) {\r\ndev_err(dev, "failed to get regmap\n");\r\nreturn PTR_ERR(priv->regmap);\r\n}\r\npriv->socdata = socdata;\r\npriv->pctldesc.name = dev->driver->name;\r\npriv->pctldesc.pins = socdata->pins;\r\npriv->pctldesc.npins = socdata->npins;\r\npriv->pctldesc.pctlops = &uniphier_pctlops;\r\npriv->pctldesc.pmxops = &uniphier_pmxops;\r\npriv->pctldesc.confops = &uniphier_confops;\r\npriv->pctldesc.owner = dev->driver->owner;\r\npriv->pctldev = devm_pinctrl_register(dev, &priv->pctldesc, priv);\r\nif (IS_ERR(priv->pctldev)) {\r\ndev_err(dev, "failed to register UniPhier pinctrl driver\n");\r\nreturn PTR_ERR(priv->pctldev);\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}
