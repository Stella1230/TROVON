static void mtk_cec_clear_bits(struct mtk_cec *cec, unsigned int offset,\r\nunsigned int bits)\r\n{\r\nvoid __iomem *reg = cec->regs + offset;\r\nu32 tmp;\r\ntmp = readl(reg);\r\ntmp &= ~bits;\r\nwritel(tmp, reg);\r\n}\r\nstatic void mtk_cec_set_bits(struct mtk_cec *cec, unsigned int offset,\r\nunsigned int bits)\r\n{\r\nvoid __iomem *reg = cec->regs + offset;\r\nu32 tmp;\r\ntmp = readl(reg);\r\ntmp |= bits;\r\nwritel(tmp, reg);\r\n}\r\nstatic void mtk_cec_mask(struct mtk_cec *cec, unsigned int offset,\r\nunsigned int val, unsigned int mask)\r\n{\r\nu32 tmp = readl(cec->regs + offset) & ~mask;\r\ntmp |= val & mask;\r\nwritel(val, cec->regs + offset);\r\n}\r\nvoid mtk_cec_set_hpd_event(struct device *dev,\r\nvoid (*hpd_event)(bool hpd, struct device *dev),\r\nstruct device *hdmi_dev)\r\n{\r\nstruct mtk_cec *cec = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&cec->lock, flags);\r\ncec->hdmi_dev = hdmi_dev;\r\ncec->hpd_event = hpd_event;\r\nspin_unlock_irqrestore(&cec->lock, flags);\r\n}\r\nbool mtk_cec_hpd_high(struct device *dev)\r\n{\r\nstruct mtk_cec *cec = dev_get_drvdata(dev);\r\nunsigned int status;\r\nstatus = readl(cec->regs + RX_EVENT);\r\nreturn (status & (HDMI_PORD | HDMI_HTPLG)) == (HDMI_PORD | HDMI_HTPLG);\r\n}\r\nstatic void mtk_cec_htplg_irq_init(struct mtk_cec *cec)\r\n{\r\nmtk_cec_mask(cec, CEC_CKGEN, 0 | CEC_32K_PDN, PDN | CEC_32K_PDN);\r\nmtk_cec_set_bits(cec, RX_GEN_WD, HDMI_PORD_INT_32K_CLR |\r\nRX_INT_32K_CLR | HDMI_HTPLG_INT_32K_CLR);\r\nmtk_cec_mask(cec, RX_GEN_WD, 0, HDMI_PORD_INT_32K_CLR | RX_INT_32K_CLR |\r\nHDMI_HTPLG_INT_32K_CLR | HDMI_PORD_INT_32K_EN |\r\nRX_INT_32K_EN | HDMI_HTPLG_INT_32K_EN);\r\n}\r\nstatic void mtk_cec_htplg_irq_enable(struct mtk_cec *cec)\r\n{\r\nmtk_cec_set_bits(cec, RX_EVENT, HDMI_PORD_INT_EN | HDMI_HTPLG_INT_EN);\r\n}\r\nstatic void mtk_cec_htplg_irq_disable(struct mtk_cec *cec)\r\n{\r\nmtk_cec_clear_bits(cec, RX_EVENT, HDMI_PORD_INT_EN | HDMI_HTPLG_INT_EN);\r\n}\r\nstatic void mtk_cec_clear_htplg_irq(struct mtk_cec *cec)\r\n{\r\nmtk_cec_set_bits(cec, TR_CONFIG, CLEAR_CEC_IRQ);\r\nmtk_cec_set_bits(cec, NORMAL_INT_CTRL, HDMI_HTPLG_INT_CLR |\r\nHDMI_PORD_INT_CLR | HDMI_FULL_INT_CLR);\r\nmtk_cec_set_bits(cec, RX_GEN_WD, HDMI_PORD_INT_32K_CLR |\r\nRX_INT_32K_CLR | HDMI_HTPLG_INT_32K_CLR);\r\nusleep_range(5, 10);\r\nmtk_cec_clear_bits(cec, NORMAL_INT_CTRL, HDMI_HTPLG_INT_CLR |\r\nHDMI_PORD_INT_CLR | HDMI_FULL_INT_CLR);\r\nmtk_cec_clear_bits(cec, TR_CONFIG, CLEAR_CEC_IRQ);\r\nmtk_cec_clear_bits(cec, RX_GEN_WD, HDMI_PORD_INT_32K_CLR |\r\nRX_INT_32K_CLR | HDMI_HTPLG_INT_32K_CLR);\r\n}\r\nstatic void mtk_cec_hpd_event(struct mtk_cec *cec, bool hpd)\r\n{\r\nvoid (*hpd_event)(bool hpd, struct device *dev);\r\nstruct device *hdmi_dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cec->lock, flags);\r\nhpd_event = cec->hpd_event;\r\nhdmi_dev = cec->hdmi_dev;\r\nspin_unlock_irqrestore(&cec->lock, flags);\r\nif (hpd_event)\r\nhpd_event(hpd, hdmi_dev);\r\n}\r\nstatic irqreturn_t mtk_cec_htplg_isr_thread(int irq, void *arg)\r\n{\r\nstruct device *dev = arg;\r\nstruct mtk_cec *cec = dev_get_drvdata(dev);\r\nbool hpd;\r\nmtk_cec_clear_htplg_irq(cec);\r\nhpd = mtk_cec_hpd_high(dev);\r\nif (cec->hpd != hpd) {\r\ndev_dbg(dev, "hotplug event! cur hpd = %d, hpd = %d\n",\r\ncec->hpd, hpd);\r\ncec->hpd = hpd;\r\nmtk_cec_hpd_event(cec, hpd);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mtk_cec_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_cec *cec;\r\nstruct resource *res;\r\nint ret;\r\ncec = devm_kzalloc(dev, sizeof(*cec), GFP_KERNEL);\r\nif (!cec)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, cec);\r\nspin_lock_init(&cec->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncec->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cec->regs)) {\r\nret = PTR_ERR(cec->regs);\r\ndev_err(dev, "Failed to ioremap cec: %d\n", ret);\r\nreturn ret;\r\n}\r\ncec->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(cec->clk)) {\r\nret = PTR_ERR(cec->clk);\r\ndev_err(dev, "Failed to get cec clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ncec->irq = platform_get_irq(pdev, 0);\r\nif (cec->irq < 0) {\r\ndev_err(dev, "Failed to get cec irq: %d\n", cec->irq);\r\nreturn cec->irq;\r\n}\r\nret = devm_request_threaded_irq(dev, cec->irq, NULL,\r\nmtk_cec_htplg_isr_thread,\r\nIRQF_SHARED | IRQF_TRIGGER_LOW |\r\nIRQF_ONESHOT, "hdmi hpd", dev);\r\nif (ret) {\r\ndev_err(dev, "Failed to register cec irq: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(cec->clk);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable cec clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nmtk_cec_htplg_irq_init(cec);\r\nmtk_cec_htplg_irq_enable(cec);\r\nreturn 0;\r\n}\r\nstatic int mtk_cec_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_cec *cec = platform_get_drvdata(pdev);\r\nmtk_cec_htplg_irq_disable(cec);\r\nclk_disable_unprepare(cec->clk);\r\nreturn 0;\r\n}
