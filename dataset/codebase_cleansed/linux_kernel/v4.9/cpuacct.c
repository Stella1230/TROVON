static inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\r\n{\r\nreturn css ? container_of(css, struct cpuacct, css) : NULL;\r\n}\r\nstatic inline struct cpuacct *task_ca(struct task_struct *tsk)\r\n{\r\nreturn css_ca(task_css(tsk, cpuacct_cgrp_id));\r\n}\r\nstatic inline struct cpuacct *parent_ca(struct cpuacct *ca)\r\n{\r\nreturn css_ca(ca->css.parent);\r\n}\r\nstatic struct cgroup_subsys_state *\r\ncpuacct_css_alloc(struct cgroup_subsys_state *parent_css)\r\n{\r\nstruct cpuacct *ca;\r\nif (!parent_css)\r\nreturn &root_cpuacct.css;\r\nca = kzalloc(sizeof(*ca), GFP_KERNEL);\r\nif (!ca)\r\ngoto out;\r\nca->cpuusage = alloc_percpu(struct cpuacct_usage);\r\nif (!ca->cpuusage)\r\ngoto out_free_ca;\r\nca->cpustat = alloc_percpu(struct kernel_cpustat);\r\nif (!ca->cpustat)\r\ngoto out_free_cpuusage;\r\nreturn &ca->css;\r\nout_free_cpuusage:\r\nfree_percpu(ca->cpuusage);\r\nout_free_ca:\r\nkfree(ca);\r\nout:\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void cpuacct_css_free(struct cgroup_subsys_state *css)\r\n{\r\nstruct cpuacct *ca = css_ca(css);\r\nfree_percpu(ca->cpustat);\r\nfree_percpu(ca->cpuusage);\r\nkfree(ca);\r\n}\r\nstatic u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu,\r\nenum cpuacct_stat_index index)\r\n{\r\nstruct cpuacct_usage *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\r\nu64 data;\r\nBUG_ON(index > CPUACCT_STAT_NSTATS);\r\n#ifndef CONFIG_64BIT\r\nraw_spin_lock_irq(&cpu_rq(cpu)->lock);\r\n#endif\r\nif (index == CPUACCT_STAT_NSTATS) {\r\nint i = 0;\r\ndata = 0;\r\nfor (i = 0; i < CPUACCT_STAT_NSTATS; i++)\r\ndata += cpuusage->usages[i];\r\n} else {\r\ndata = cpuusage->usages[index];\r\n}\r\n#ifndef CONFIG_64BIT\r\nraw_spin_unlock_irq(&cpu_rq(cpu)->lock);\r\n#endif\r\nreturn data;\r\n}\r\nstatic void cpuacct_cpuusage_write(struct cpuacct *ca, int cpu, u64 val)\r\n{\r\nstruct cpuacct_usage *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\r\nint i;\r\n#ifndef CONFIG_64BIT\r\nraw_spin_lock_irq(&cpu_rq(cpu)->lock);\r\n#endif\r\nfor (i = 0; i < CPUACCT_STAT_NSTATS; i++)\r\ncpuusage->usages[i] = val;\r\n#ifndef CONFIG_64BIT\r\nraw_spin_unlock_irq(&cpu_rq(cpu)->lock);\r\n#endif\r\n}\r\nstatic u64 __cpuusage_read(struct cgroup_subsys_state *css,\r\nenum cpuacct_stat_index index)\r\n{\r\nstruct cpuacct *ca = css_ca(css);\r\nu64 totalcpuusage = 0;\r\nint i;\r\nfor_each_possible_cpu(i)\r\ntotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\r\nreturn totalcpuusage;\r\n}\r\nstatic u64 cpuusage_user_read(struct cgroup_subsys_state *css,\r\nstruct cftype *cft)\r\n{\r\nreturn __cpuusage_read(css, CPUACCT_STAT_USER);\r\n}\r\nstatic u64 cpuusage_sys_read(struct cgroup_subsys_state *css,\r\nstruct cftype *cft)\r\n{\r\nreturn __cpuusage_read(css, CPUACCT_STAT_SYSTEM);\r\n}\r\nstatic u64 cpuusage_read(struct cgroup_subsys_state *css, struct cftype *cft)\r\n{\r\nreturn __cpuusage_read(css, CPUACCT_STAT_NSTATS);\r\n}\r\nstatic int cpuusage_write(struct cgroup_subsys_state *css, struct cftype *cft,\r\nu64 val)\r\n{\r\nstruct cpuacct *ca = css_ca(css);\r\nint cpu;\r\nif (val)\r\nreturn -EINVAL;\r\nfor_each_possible_cpu(cpu)\r\ncpuacct_cpuusage_write(ca, cpu, 0);\r\nreturn 0;\r\n}\r\nstatic int __cpuacct_percpu_seq_show(struct seq_file *m,\r\nenum cpuacct_stat_index index)\r\n{\r\nstruct cpuacct *ca = css_ca(seq_css(m));\r\nu64 percpu;\r\nint i;\r\nfor_each_possible_cpu(i) {\r\npercpu = cpuacct_cpuusage_read(ca, i, index);\r\nseq_printf(m, "%llu ", (unsigned long long) percpu);\r\n}\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int cpuacct_percpu_user_seq_show(struct seq_file *m, void *V)\r\n{\r\nreturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_USER);\r\n}\r\nstatic int cpuacct_percpu_sys_seq_show(struct seq_file *m, void *V)\r\n{\r\nreturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_SYSTEM);\r\n}\r\nstatic int cpuacct_percpu_seq_show(struct seq_file *m, void *V)\r\n{\r\nreturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_NSTATS);\r\n}\r\nstatic int cpuacct_all_seq_show(struct seq_file *m, void *V)\r\n{\r\nstruct cpuacct *ca = css_ca(seq_css(m));\r\nint index;\r\nint cpu;\r\nseq_puts(m, "cpu");\r\nfor (index = 0; index < CPUACCT_STAT_NSTATS; index++)\r\nseq_printf(m, " %s", cpuacct_stat_desc[index]);\r\nseq_puts(m, "\n");\r\nfor_each_possible_cpu(cpu) {\r\nstruct cpuacct_usage *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\r\nseq_printf(m, "%d", cpu);\r\nfor (index = 0; index < CPUACCT_STAT_NSTATS; index++) {\r\n#ifndef CONFIG_64BIT\r\nraw_spin_lock_irq(&cpu_rq(cpu)->lock);\r\n#endif\r\nseq_printf(m, " %llu", cpuusage->usages[index]);\r\n#ifndef CONFIG_64BIT\r\nraw_spin_unlock_irq(&cpu_rq(cpu)->lock);\r\n#endif\r\n}\r\nseq_puts(m, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpuacct_stats_show(struct seq_file *sf, void *v)\r\n{\r\nstruct cpuacct *ca = css_ca(seq_css(sf));\r\ns64 val[CPUACCT_STAT_NSTATS];\r\nint cpu;\r\nint stat;\r\nmemset(val, 0, sizeof(val));\r\nfor_each_possible_cpu(cpu) {\r\nu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\r\nval[CPUACCT_STAT_USER] += cpustat[CPUTIME_USER];\r\nval[CPUACCT_STAT_USER] += cpustat[CPUTIME_NICE];\r\nval[CPUACCT_STAT_SYSTEM] += cpustat[CPUTIME_SYSTEM];\r\nval[CPUACCT_STAT_SYSTEM] += cpustat[CPUTIME_IRQ];\r\nval[CPUACCT_STAT_SYSTEM] += cpustat[CPUTIME_SOFTIRQ];\r\n}\r\nfor (stat = 0; stat < CPUACCT_STAT_NSTATS; stat++) {\r\nseq_printf(sf, "%s %lld\n",\r\ncpuacct_stat_desc[stat],\r\ncputime64_to_clock_t(val[stat]));\r\n}\r\nreturn 0;\r\n}\r\nvoid cpuacct_charge(struct task_struct *tsk, u64 cputime)\r\n{\r\nstruct cpuacct *ca;\r\nint index = CPUACCT_STAT_SYSTEM;\r\nstruct pt_regs *regs = task_pt_regs(tsk);\r\nif (regs && user_mode(regs))\r\nindex = CPUACCT_STAT_USER;\r\nrcu_read_lock();\r\nfor (ca = task_ca(tsk); ca; ca = parent_ca(ca))\r\nthis_cpu_ptr(ca->cpuusage)->usages[index] += cputime;\r\nrcu_read_unlock();\r\n}\r\nvoid cpuacct_account_field(struct task_struct *tsk, int index, u64 val)\r\n{\r\nstruct cpuacct *ca;\r\nrcu_read_lock();\r\nfor (ca = task_ca(tsk); ca != &root_cpuacct; ca = parent_ca(ca))\r\nthis_cpu_ptr(ca->cpustat)->cpustat[index] += val;\r\nrcu_read_unlock();\r\n}
