static int s3c2443_clk_suspend(void)\r\n{\r\nsamsung_clk_save(reg_base, s3c2443_save,\r\nARRAY_SIZE(s3c2443_clk_regs));\r\nreturn 0;\r\n}\r\nstatic void s3c2443_clk_resume(void)\r\n{\r\nsamsung_clk_restore(reg_base, s3c2443_save,\r\nARRAY_SIZE(s3c2443_clk_regs));\r\n}\r\nstatic void s3c2443_clk_sleep_init(void)\r\n{\r\ns3c2443_save = samsung_clk_alloc_reg_dump(s3c2443_clk_regs,\r\nARRAY_SIZE(s3c2443_clk_regs));\r\nif (!s3c2443_save) {\r\npr_warn("%s: failed to allocate sleep save data, no sleep support!\n",\r\n__func__);\r\nreturn;\r\n}\r\nregister_syscore_ops(&s3c2443_clk_syscore_ops);\r\nreturn;\r\n}\r\nstatic void s3c2443_clk_sleep_init(void) {}\r\nstatic int s3c2443_restart(struct notifier_block *this,\r\nunsigned long mode, void *cmd)\r\n{\r\n__raw_writel(0x533c2443, reg_base + SWRST);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __init s3c2443_common_clk_register_fixed_ext(\r\nstruct samsung_clk_provider *ctx, unsigned long xti_f)\r\n{\r\ns3c2443_common_frate_clks[0].fixed_rate = xti_f;\r\nsamsung_clk_register_fixed_rate(ctx, s3c2443_common_frate_clks,\r\nARRAY_SIZE(s3c2443_common_frate_clks));\r\n}\r\nvoid __init s3c2443_common_clk_init(struct device_node *np, unsigned long xti_f,\r\nint current_soc,\r\nvoid __iomem *base)\r\n{\r\nstruct samsung_clk_provider *ctx;\r\nint ret;\r\nreg_base = base;\r\nif (np) {\r\nreg_base = of_iomap(np, 0);\r\nif (!reg_base)\r\npanic("%s: failed to map registers\n", __func__);\r\n}\r\nctx = samsung_clk_init(np, reg_base, NR_CLKS);\r\nif (!np)\r\ns3c2443_common_clk_register_fixed_ext(ctx, xti_f);\r\nif (current_soc == S3C2416 || current_soc == S3C2450)\r\nsamsung_clk_register_pll(ctx, s3c2416_pll_clks,\r\nARRAY_SIZE(s3c2416_pll_clks), reg_base);\r\nelse\r\nsamsung_clk_register_pll(ctx, s3c2443_pll_clks,\r\nARRAY_SIZE(s3c2443_pll_clks), reg_base);\r\nsamsung_clk_register_mux(ctx, s3c2443_common_muxes,\r\nARRAY_SIZE(s3c2443_common_muxes));\r\nsamsung_clk_register_div(ctx, s3c2443_common_dividers,\r\nARRAY_SIZE(s3c2443_common_dividers));\r\nsamsung_clk_register_gate(ctx, s3c2443_common_gates,\r\nARRAY_SIZE(s3c2443_common_gates));\r\nsamsung_clk_register_alias(ctx, s3c2443_common_aliases,\r\nARRAY_SIZE(s3c2443_common_aliases));\r\nswitch (current_soc) {\r\ncase S3C2450:\r\nsamsung_clk_register_div(ctx, s3c2450_dividers,\r\nARRAY_SIZE(s3c2450_dividers));\r\nsamsung_clk_register_mux(ctx, s3c2450_muxes,\r\nARRAY_SIZE(s3c2450_muxes));\r\nsamsung_clk_register_gate(ctx, s3c2450_gates,\r\nARRAY_SIZE(s3c2450_gates));\r\nsamsung_clk_register_alias(ctx, s3c2450_aliases,\r\nARRAY_SIZE(s3c2450_aliases));\r\ncase S3C2416:\r\nsamsung_clk_register_div(ctx, s3c2416_dividers,\r\nARRAY_SIZE(s3c2416_dividers));\r\nsamsung_clk_register_mux(ctx, s3c2416_muxes,\r\nARRAY_SIZE(s3c2416_muxes));\r\nsamsung_clk_register_gate(ctx, s3c2416_gates,\r\nARRAY_SIZE(s3c2416_gates));\r\nsamsung_clk_register_alias(ctx, s3c2416_aliases,\r\nARRAY_SIZE(s3c2416_aliases));\r\nbreak;\r\ncase S3C2443:\r\nsamsung_clk_register_div(ctx, s3c2443_dividers,\r\nARRAY_SIZE(s3c2443_dividers));\r\nsamsung_clk_register_gate(ctx, s3c2443_gates,\r\nARRAY_SIZE(s3c2443_gates));\r\nsamsung_clk_register_alias(ctx, s3c2443_aliases,\r\nARRAY_SIZE(s3c2443_aliases));\r\nbreak;\r\n}\r\ns3c2443_clk_sleep_init();\r\nsamsung_clk_of_add_provider(np, ctx);\r\nret = register_restart_handler(&s3c2443_restart_handler);\r\nif (ret)\r\npr_warn("cannot register restart handler, %d\n", ret);\r\n}\r\nstatic void __init s3c2416_clk_init(struct device_node *np)\r\n{\r\ns3c2443_common_clk_init(np, 0, S3C2416, 0);\r\n}\r\nstatic void __init s3c2443_clk_init(struct device_node *np)\r\n{\r\ns3c2443_common_clk_init(np, 0, S3C2443, 0);\r\n}\r\nstatic void __init s3c2450_clk_init(struct device_node *np)\r\n{\r\ns3c2443_common_clk_init(np, 0, S3C2450, 0);\r\n}
