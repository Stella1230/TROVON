static void\r\ncyrix_get_arr(unsigned int reg, unsigned long *base,\r\nunsigned long *size, mtrr_type * type)\r\n{\r\nunsigned char arr, ccr3, rcr, shift;\r\nunsigned long flags;\r\narr = CX86_ARR_BASE + (reg << 1) + reg;\r\nlocal_irq_save(flags);\r\nccr3 = getCx86(CX86_CCR3);\r\nsetCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10);\r\n((unsigned char *)base)[3] = getCx86(arr);\r\n((unsigned char *)base)[2] = getCx86(arr + 1);\r\n((unsigned char *)base)[1] = getCx86(arr + 2);\r\nrcr = getCx86(CX86_RCR_BASE + reg);\r\nsetCx86(CX86_CCR3, ccr3);\r\nlocal_irq_restore(flags);\r\nshift = ((unsigned char *) base)[1] & 0x0f;\r\n*base >>= PAGE_SHIFT;\r\nif (shift)\r\n*size = (reg < 7 ? 0x1UL : 0x40UL) << (shift - 1);\r\nelse\r\n*size = 0;\r\nif (reg < 7) {\r\nswitch (rcr) {\r\ncase 1:\r\n*type = MTRR_TYPE_UNCACHABLE;\r\nbreak;\r\ncase 8:\r\n*type = MTRR_TYPE_WRBACK;\r\nbreak;\r\ncase 9:\r\n*type = MTRR_TYPE_WRCOMB;\r\nbreak;\r\ncase 24:\r\ndefault:\r\n*type = MTRR_TYPE_WRTHROUGH;\r\nbreak;\r\n}\r\n} else {\r\nswitch (rcr) {\r\ncase 0:\r\n*type = MTRR_TYPE_UNCACHABLE;\r\nbreak;\r\ncase 8:\r\n*type = MTRR_TYPE_WRCOMB;\r\nbreak;\r\ncase 9:\r\n*type = MTRR_TYPE_WRBACK;\r\nbreak;\r\ncase 25:\r\ndefault:\r\n*type = MTRR_TYPE_WRTHROUGH;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int\r\ncyrix_get_free_region(unsigned long base, unsigned long size, int replace_reg)\r\n{\r\nunsigned long lbase, lsize;\r\nmtrr_type ltype;\r\nint i;\r\nswitch (replace_reg) {\r\ncase 7:\r\nif (size < 0x40)\r\nbreak;\r\ncase 6:\r\ncase 5:\r\ncase 4:\r\nreturn replace_reg;\r\ncase 3:\r\ncase 2:\r\ncase 1:\r\ncase 0:\r\nreturn replace_reg;\r\n}\r\nif (size > 0x2000) {\r\ncyrix_get_arr(7, &lbase, &lsize, &ltype);\r\nif (lsize == 0)\r\nreturn 7;\r\n} else {\r\nfor (i = 0; i < 7; i++) {\r\ncyrix_get_arr(i, &lbase, &lsize, &ltype);\r\nif (lsize == 0)\r\nreturn i;\r\n}\r\ncyrix_get_arr(i, &lbase, &lsize, &ltype);\r\nif ((lsize == 0) && (size >= 0x40))\r\nreturn i;\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic void prepare_set(void)\r\n{\r\nu32 cr0;\r\nif (boot_cpu_has(X86_FEATURE_PGE)) {\r\ncr4 = __read_cr4();\r\n__write_cr4(cr4 & ~X86_CR4_PGE);\r\n}\r\ncr0 = read_cr0() | X86_CR0_CD;\r\nwbinvd();\r\nwrite_cr0(cr0);\r\nwbinvd();\r\nccr3 = getCx86(CX86_CCR3);\r\nsetCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10);\r\n}\r\nstatic void post_set(void)\r\n{\r\nwbinvd();\r\nsetCx86(CX86_CCR3, ccr3);\r\nwrite_cr0(read_cr0() & ~X86_CR0_CD);\r\nif (boot_cpu_has(X86_FEATURE_PGE))\r\n__write_cr4(cr4);\r\n}\r\nstatic void cyrix_set_arr(unsigned int reg, unsigned long base,\r\nunsigned long size, mtrr_type type)\r\n{\r\nunsigned char arr, arr_type, arr_size;\r\narr = CX86_ARR_BASE + (reg << 1) + reg;\r\nif (reg >= 7)\r\nsize >>= 6;\r\nsize &= 0x7fff;\r\nfor (arr_size = 0; size; arr_size++, size >>= 1)\r\n;\r\nif (reg < 7) {\r\nswitch (type) {\r\ncase MTRR_TYPE_UNCACHABLE:\r\narr_type = 1;\r\nbreak;\r\ncase MTRR_TYPE_WRCOMB:\r\narr_type = 9;\r\nbreak;\r\ncase MTRR_TYPE_WRTHROUGH:\r\narr_type = 24;\r\nbreak;\r\ndefault:\r\narr_type = 8;\r\nbreak;\r\n}\r\n} else {\r\nswitch (type) {\r\ncase MTRR_TYPE_UNCACHABLE:\r\narr_type = 0;\r\nbreak;\r\ncase MTRR_TYPE_WRCOMB:\r\narr_type = 8;\r\nbreak;\r\ncase MTRR_TYPE_WRTHROUGH:\r\narr_type = 25;\r\nbreak;\r\ndefault:\r\narr_type = 9;\r\nbreak;\r\n}\r\n}\r\nprepare_set();\r\nbase <<= PAGE_SHIFT;\r\nsetCx86(arr + 0, ((unsigned char *)&base)[3]);\r\nsetCx86(arr + 1, ((unsigned char *)&base)[2]);\r\nsetCx86(arr + 2, (((unsigned char *)&base)[1]) | arr_size);\r\nsetCx86(CX86_RCR_BASE + reg, arr_type);\r\npost_set();\r\n}\r\nstatic void cyrix_set_all(void)\r\n{\r\nint i;\r\nprepare_set();\r\nfor (i = 0; i < 4; i++)\r\nsetCx86(CX86_CCR0 + i, ccr_state[i]);\r\nfor (; i < 7; i++)\r\nsetCx86(CX86_CCR4 + i, ccr_state[i]);\r\nfor (i = 0; i < 8; i++) {\r\ncyrix_set_arr(i, arr_state[i].base,\r\narr_state[i].size, arr_state[i].type);\r\n}\r\npost_set();\r\n}\r\nint __init cyrix_init_mtrr(void)\r\n{\r\nset_mtrr_ops(&cyrix_mtrr_ops);\r\nreturn 0;\r\n}
