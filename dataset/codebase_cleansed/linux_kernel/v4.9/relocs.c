static int regex_skip_reloc(const char *sym_name)\r\n{\r\nreturn !regexec(&sym_regex_c, sym_name, 0, NULL, 0);\r\n}\r\nstatic void regex_init(void)\r\n{\r\nchar errbuf[128];\r\nint err;\r\nerr = regcomp(&sym_regex_c, regex_sym_kernel,\r\nREG_EXTENDED|REG_NOSUB);\r\nif (err) {\r\nregerror(err, &sym_regex_c, errbuf, sizeof(errbuf));\r\ndie("%s", errbuf);\r\n}\r\n}\r\nstatic const char *rel_type(unsigned type)\r\n{\r\nstatic const char * const type_name[] = {\r\n#define REL_TYPE(X)[X] = #X\r\nREL_TYPE(R_MIPS_NONE),\r\nREL_TYPE(R_MIPS_16),\r\nREL_TYPE(R_MIPS_32),\r\nREL_TYPE(R_MIPS_REL32),\r\nREL_TYPE(R_MIPS_26),\r\nREL_TYPE(R_MIPS_HI16),\r\nREL_TYPE(R_MIPS_LO16),\r\nREL_TYPE(R_MIPS_GPREL16),\r\nREL_TYPE(R_MIPS_LITERAL),\r\nREL_TYPE(R_MIPS_GOT16),\r\nREL_TYPE(R_MIPS_PC16),\r\nREL_TYPE(R_MIPS_CALL16),\r\nREL_TYPE(R_MIPS_GPREL32),\r\nREL_TYPE(R_MIPS_64),\r\nREL_TYPE(R_MIPS_HIGHER),\r\nREL_TYPE(R_MIPS_HIGHEST),\r\nREL_TYPE(R_MIPS_PC21_S2),\r\nREL_TYPE(R_MIPS_PC26_S2),\r\n#undef REL_TYPE\r\n};\r\nconst char *name = "unknown type rel type name";\r\nif (type < ARRAY_SIZE(type_name) && type_name[type])\r\nname = type_name[type];\r\nreturn name;\r\n}\r\nstatic const char *sec_name(unsigned shndx)\r\n{\r\nconst char *sec_strtab;\r\nconst char *name;\r\nsec_strtab = secs[ehdr.e_shstrndx].strtab;\r\nif (shndx < ehdr.e_shnum)\r\nname = sec_strtab + secs[shndx].shdr.sh_name;\r\nelse if (shndx == SHN_ABS)\r\nname = "ABSOLUTE";\r\nelse if (shndx == SHN_COMMON)\r\nname = "COMMON";\r\nelse\r\nname = "<noname>";\r\nreturn name;\r\n}\r\nstatic struct section *sec_lookup(const char *secname)\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++)\r\nif (strcmp(secname, sec_name(i)) == 0)\r\nreturn &secs[i];\r\nreturn NULL;\r\n}\r\nstatic const char *sym_name(const char *sym_strtab, Elf_Sym *sym)\r\n{\r\nconst char *name;\r\nif (sym->st_name)\r\nname = sym_strtab + sym->st_name;\r\nelse\r\nname = sec_name(sym->st_shndx);\r\nreturn name;\r\n}\r\nstatic uint16_t elf16_to_cpu(uint16_t val)\r\n{\r\nif (ehdr.e_ident[EI_DATA] == ELFDATA2LSB)\r\nreturn le16_to_cpu(val);\r\nelse\r\nreturn be16_to_cpu(val);\r\n}\r\nstatic uint32_t elf32_to_cpu(uint32_t val)\r\n{\r\nif (ehdr.e_ident[EI_DATA] == ELFDATA2LSB)\r\nreturn le32_to_cpu(val);\r\nelse\r\nreturn be32_to_cpu(val);\r\n}\r\nstatic uint32_t cpu_to_elf32(uint32_t val)\r\n{\r\nif (ehdr.e_ident[EI_DATA] == ELFDATA2LSB)\r\nreturn cpu_to_le32(val);\r\nelse\r\nreturn cpu_to_be32(val);\r\n}\r\nstatic uint64_t elf64_to_cpu(uint64_t val)\r\n{\r\nif (ehdr.e_ident[EI_DATA] == ELFDATA2LSB)\r\nreturn le64_to_cpu(val);\r\nelse\r\nreturn be64_to_cpu(val);\r\n}\r\nstatic void read_ehdr(FILE *fp)\r\n{\r\nif (fread(&ehdr, sizeof(ehdr), 1, fp) != 1)\r\ndie("Cannot read ELF header: %s\n", strerror(errno));\r\nif (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0)\r\ndie("No ELF magic\n");\r\nif (ehdr.e_ident[EI_CLASS] != ELF_CLASS)\r\ndie("Not a %d bit executable\n", ELF_BITS);\r\nif ((ehdr.e_ident[EI_DATA] != ELFDATA2LSB) &&\r\n(ehdr.e_ident[EI_DATA] != ELFDATA2MSB))\r\ndie("Unknown ELF Endianness\n");\r\nif (ehdr.e_ident[EI_VERSION] != EV_CURRENT)\r\ndie("Unknown ELF version\n");\r\nehdr.e_type = elf_half_to_cpu(ehdr.e_type);\r\nehdr.e_machine = elf_half_to_cpu(ehdr.e_machine);\r\nehdr.e_version = elf_word_to_cpu(ehdr.e_version);\r\nehdr.e_entry = elf_addr_to_cpu(ehdr.e_entry);\r\nehdr.e_phoff = elf_off_to_cpu(ehdr.e_phoff);\r\nehdr.e_shoff = elf_off_to_cpu(ehdr.e_shoff);\r\nehdr.e_flags = elf_word_to_cpu(ehdr.e_flags);\r\nehdr.e_ehsize = elf_half_to_cpu(ehdr.e_ehsize);\r\nehdr.e_phentsize = elf_half_to_cpu(ehdr.e_phentsize);\r\nehdr.e_phnum = elf_half_to_cpu(ehdr.e_phnum);\r\nehdr.e_shentsize = elf_half_to_cpu(ehdr.e_shentsize);\r\nehdr.e_shnum = elf_half_to_cpu(ehdr.e_shnum);\r\nehdr.e_shstrndx = elf_half_to_cpu(ehdr.e_shstrndx);\r\nif ((ehdr.e_type != ET_EXEC) && (ehdr.e_type != ET_DYN))\r\ndie("Unsupported ELF header type\n");\r\nif (ehdr.e_machine != ELF_MACHINE)\r\ndie("Not for %s\n", ELF_MACHINE_NAME);\r\nif (ehdr.e_version != EV_CURRENT)\r\ndie("Unknown ELF version\n");\r\nif (ehdr.e_ehsize != sizeof(Elf_Ehdr))\r\ndie("Bad Elf header size\n");\r\nif (ehdr.e_phentsize != sizeof(Elf_Phdr))\r\ndie("Bad program header entry\n");\r\nif (ehdr.e_shentsize != sizeof(Elf_Shdr))\r\ndie("Bad section header entry\n");\r\nif (ehdr.e_shstrndx >= ehdr.e_shnum)\r\ndie("String table index out of bounds\n");\r\n}\r\nstatic void read_shdrs(FILE *fp)\r\n{\r\nint i;\r\nElf_Shdr shdr;\r\nsecs = calloc(ehdr.e_shnum, sizeof(struct section));\r\nif (!secs)\r\ndie("Unable to allocate %d section headers\n", ehdr.e_shnum);\r\nif (fseek(fp, ehdr.e_shoff, SEEK_SET) < 0)\r\ndie("Seek to %d failed: %s\n", ehdr.e_shoff, strerror(errno));\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nsec->shdr_offset = ftell(fp);\r\nif (fread(&shdr, sizeof(shdr), 1, fp) != 1)\r\ndie("Cannot read ELF section headers %d/%d: %s\n",\r\ni, ehdr.e_shnum, strerror(errno));\r\nsec->shdr.sh_name = elf_word_to_cpu(shdr.sh_name);\r\nsec->shdr.sh_type = elf_word_to_cpu(shdr.sh_type);\r\nsec->shdr.sh_flags = elf_xword_to_cpu(shdr.sh_flags);\r\nsec->shdr.sh_addr = elf_addr_to_cpu(shdr.sh_addr);\r\nsec->shdr.sh_offset = elf_off_to_cpu(shdr.sh_offset);\r\nsec->shdr.sh_size = elf_xword_to_cpu(shdr.sh_size);\r\nsec->shdr.sh_link = elf_word_to_cpu(shdr.sh_link);\r\nsec->shdr.sh_info = elf_word_to_cpu(shdr.sh_info);\r\nsec->shdr.sh_addralign = elf_xword_to_cpu(shdr.sh_addralign);\r\nsec->shdr.sh_entsize = elf_xword_to_cpu(shdr.sh_entsize);\r\nif (sec->shdr.sh_link < ehdr.e_shnum)\r\nsec->link = &secs[sec->shdr.sh_link];\r\n}\r\n}\r\nstatic void read_strtabs(FILE *fp)\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_STRTAB)\r\ncontinue;\r\nsec->strtab = malloc(sec->shdr.sh_size);\r\nif (!sec->strtab)\r\ndie("malloc of %d bytes for strtab failed\n",\r\nsec->shdr.sh_size);\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0)\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\nif (fread(sec->strtab, 1, sec->shdr.sh_size, fp) !=\r\nsec->shdr.sh_size)\r\ndie("Cannot read symbol table: %s\n", strerror(errno));\r\n}\r\n}\r\nstatic void read_symtabs(FILE *fp)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_SYMTAB)\r\ncontinue;\r\nsec->symtab = malloc(sec->shdr.sh_size);\r\nif (!sec->symtab)\r\ndie("malloc of %d bytes for symtab failed\n",\r\nsec->shdr.sh_size);\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0)\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\nif (fread(sec->symtab, 1, sec->shdr.sh_size, fp) !=\r\nsec->shdr.sh_size)\r\ndie("Cannot read symbol table: %s\n", strerror(errno));\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Sym); j++) {\r\nElf_Sym *sym = &sec->symtab[j];\r\nsym->st_name = elf_word_to_cpu(sym->st_name);\r\nsym->st_value = elf_addr_to_cpu(sym->st_value);\r\nsym->st_size = elf_xword_to_cpu(sym->st_size);\r\nsym->st_shndx = elf_half_to_cpu(sym->st_shndx);\r\n}\r\n}\r\n}\r\nstatic void read_relocs(FILE *fp)\r\n{\r\nstatic unsigned long base = 0;\r\nint i, j;\r\nif (!base) {\r\nstruct section *sec = sec_lookup(".text");\r\nif (!sec)\r\ndie("Could not find .text section\n");\r\nbase = sec->shdr.sh_addr;\r\n}\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_REL_TYPE)\r\ncontinue;\r\nsec->reltab = malloc(sec->shdr.sh_size);\r\nif (!sec->reltab)\r\ndie("malloc of %d bytes for relocs failed\n",\r\nsec->shdr.sh_size);\r\nif (fseek(fp, sec->shdr.sh_offset, SEEK_SET) < 0)\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr.sh_offset, strerror(errno));\r\nif (fread(sec->reltab, 1, sec->shdr.sh_size, fp) !=\r\nsec->shdr.sh_size)\r\ndie("Cannot read symbol table: %s\n", strerror(errno));\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {\r\nElf_Rel *rel = &sec->reltab[j];\r\nrel->r_offset = elf_addr_to_cpu(rel->r_offset);\r\nrel->r_offset -= base;\r\n#if (ELF_BITS == 32)\r\nrel->r_info = elf_xword_to_cpu(rel->r_info);\r\n#else\r\nrel->r_info = rel->r_info;\r\nELF_R_SYM(rel->r_info) = elf32_to_cpu(ELF_R_SYM(rel->r_info));\r\n#endif\r\n#if (SHT_REL_TYPE == SHT_RELA)\r\nrel->r_addend = elf_xword_to_cpu(rel->r_addend);\r\n#endif\r\n}\r\n}\r\n}\r\nstatic void remove_relocs(FILE *fp)\r\n{\r\nint i;\r\nElf_Shdr shdr;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_REL_TYPE)\r\ncontinue;\r\nif (fseek(fp, sec->shdr_offset, SEEK_SET) < 0)\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr_offset, strerror(errno));\r\nif (fread(&shdr, sizeof(shdr), 1, fp) != 1)\r\ndie("Cannot read ELF section headers %d/%d: %s\n",\r\ni, ehdr.e_shnum, strerror(errno));\r\nshdr.sh_size = 0;\r\nif (fseek(fp, sec->shdr_offset, SEEK_SET) < 0)\r\ndie("Seek to %d failed: %s\n",\r\nsec->shdr_offset, strerror(errno));\r\nif (fwrite(&shdr, sizeof(shdr), 1, fp) != 1)\r\ndie("Cannot write ELF section headers %d/%d: %s\n",\r\ni, ehdr.e_shnum, strerror(errno));\r\n}\r\n}\r\nstatic void add_reloc(struct relocs *r, uint32_t offset, unsigned type)\r\n{\r\noffset >>= 2;\r\nif (offset > 0x00FFFFFF)\r\ndie("Kernel image exceeds maximum size for relocation!\n");\r\noffset = (offset & 0x00FFFFFF) | ((type & 0xFF) << 24);\r\nif (r->count == r->size) {\r\nunsigned long newsize = r->size + 50000;\r\nvoid *mem = realloc(r->offset, newsize * sizeof(r->offset[0]));\r\nif (!mem)\r\ndie("realloc failed\n");\r\nr->offset = mem;\r\nr->size = newsize;\r\n}\r\nr->offset[r->count++] = offset;\r\n}\r\nstatic void walk_relocs(int (*process)(struct section *sec, Elf_Rel *rel,\r\nElf_Sym *sym, const char *symname))\r\n{\r\nint i;\r\nfor (i = 0; i < ehdr.e_shnum; i++) {\r\nchar *sym_strtab;\r\nElf_Sym *sh_symtab;\r\nstruct section *sec_applies, *sec_symtab;\r\nint j;\r\nstruct section *sec = &secs[i];\r\nif (sec->shdr.sh_type != SHT_REL_TYPE)\r\ncontinue;\r\nsec_symtab = sec->link;\r\nsec_applies = &secs[sec->shdr.sh_info];\r\nif (!(sec_applies->shdr.sh_flags & SHF_ALLOC))\r\ncontinue;\r\nsh_symtab = sec_symtab->symtab;\r\nsym_strtab = sec_symtab->link->strtab;\r\nfor (j = 0; j < sec->shdr.sh_size/sizeof(Elf_Rel); j++) {\r\nElf_Rel *rel = &sec->reltab[j];\r\nElf_Sym *sym = &sh_symtab[ELF_R_SYM(rel->r_info)];\r\nconst char *symname = sym_name(sym_strtab, sym);\r\nprocess(sec, rel, sym, symname);\r\n}\r\n}\r\n}\r\nstatic int do_reloc(struct section *sec, Elf_Rel *rel, Elf_Sym *sym,\r\nconst char *symname)\r\n{\r\nunsigned r_type = ELF_R_TYPE(rel->r_info);\r\nunsigned bind = ELF_ST_BIND(sym->st_info);\r\nif ((bind == STB_WEAK) && (sym->st_value == 0)) {\r\nreturn 0;\r\n}\r\nif (regex_skip_reloc(symname))\r\nreturn 0;\r\nswitch (r_type) {\r\ncase R_MIPS_NONE:\r\ncase R_MIPS_REL32:\r\ncase R_MIPS_PC16:\r\ncase R_MIPS_PC21_S2:\r\ncase R_MIPS_PC26_S2:\r\ncase R_MIPS_HIGHEST:\r\ncase R_MIPS_HIGHER:\r\ncase R_MIPS_LO16:\r\nbreak;\r\ncase R_MIPS_64:\r\ncase R_MIPS_32:\r\ncase R_MIPS_26:\r\ncase R_MIPS_HI16:\r\nadd_reloc(&relocs, rel->r_offset, r_type);\r\nbreak;\r\ndefault:\r\ndie("Unsupported relocation type: %s (%d)\n",\r\nrel_type(r_type), r_type);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_reloc_as_bin(uint32_t v, FILE *f)\r\n{\r\nunsigned char buf[4];\r\nv = cpu_to_elf32(v);\r\nmemcpy(buf, &v, sizeof(uint32_t));\r\nreturn fwrite(buf, 1, 4, f);\r\n}\r\nstatic int write_reloc_as_text(uint32_t v, FILE *f)\r\n{\r\nint res;\r\nres = fprintf(f, "\t.long 0x%08"PRIx32"\n", v);\r\nif (res < 0)\r\nreturn res;\r\nelse\r\nreturn sizeof(uint32_t);\r\n}\r\nstatic void emit_relocs(int as_text, int as_bin, FILE *outf)\r\n{\r\nint i;\r\nint (*write_reloc)(uint32_t, FILE *) = write_reloc_as_bin;\r\nint size = 0;\r\nint size_reserved;\r\nstruct section *sec_reloc;\r\nsec_reloc = sec_lookup(".data.reloc");\r\nif (!sec_reloc)\r\ndie("Could not find relocation section\n");\r\nsize_reserved = sec_reloc->shdr.sh_size;\r\nwalk_relocs(do_reloc);\r\nif (as_text) {\r\nprintf(".section \".data.reloc\",\"a\"\n");\r\nprintf(".balign 4\n");\r\nwrite_reloc = write_reloc_as_text;\r\noutf = stdout;\r\n} else if (as_bin) {\r\noutf = stdout;\r\n} else {\r\nif (fseek(outf, sec_reloc->shdr.sh_offset, SEEK_SET) < 0) {\r\ndie("Seek to %d failed: %s\n",\r\nsec_reloc->shdr.sh_offset, strerror(errno));\r\n}\r\n}\r\nfor (i = 0; i < relocs.count; i++)\r\nsize += write_reloc(relocs.offset[i], outf);\r\nif (size)\r\nsize += write_reloc(0, outf);\r\nif (size > size_reserved)\r\ndie("Relocations overflow available space!\n" \\r\n"Please adjust CONFIG_RELOCATION_TABLE_SIZE " \\r\n"to at least 0x%08x\n", (size + 0x1000) & ~0xFFF);\r\n}\r\nstatic void print_reloc_info(void)\r\n{\r\nprintf("%16s %10s %16s %40s %16s\n",\r\n"reloc section",\r\n"offset",\r\n"reloc type",\r\n"symbol",\r\n"symbol section");\r\nwalk_relocs(do_reloc_info);\r\n}\r\nvoid process(FILE *fp, int as_text, int as_bin,\r\nint show_reloc_info, int keep_relocs)\r\n{\r\nregex_init();\r\nread_ehdr(fp);\r\nread_shdrs(fp);\r\nread_strtabs(fp);\r\nread_symtabs(fp);\r\nread_relocs(fp);\r\nif (show_reloc_info) {\r\nprint_reloc_info();\r\nreturn;\r\n}\r\nemit_relocs(as_text, as_bin, fp);\r\nif (!keep_relocs)\r\nremove_relocs(fp);\r\n}
