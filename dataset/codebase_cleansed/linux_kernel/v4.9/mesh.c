bool mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt)\r\n{\r\nreturn (mgmt->u.action.u.mesh_action.action_code ==\r\nWLAN_MESH_ACTION_HWMP_PATH_SELECTION);\r\n}\r\nvoid ieee80211s_init(void)\r\n{\r\nmesh_allocated = 1;\r\nrm_cache = kmem_cache_create("mesh_rmc", sizeof(struct rmc_entry),\r\n0, 0, NULL);\r\n}\r\nvoid ieee80211s_stop(void)\r\n{\r\nif (!mesh_allocated)\r\nreturn;\r\nkmem_cache_destroy(rm_cache);\r\n}\r\nstatic void ieee80211_mesh_housekeeping_timer(unsigned long data)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = (void *) data;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nset_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nbool mesh_matches_local(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee802_11_elems *ie)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu32 basic_rates = 0;\r\nstruct cfg80211_chan_def sta_chan_def;\r\nif (!(ifmsh->mesh_id_len == ie->mesh_id_len &&\r\nmemcmp(ifmsh->mesh_id, ie->mesh_id, ie->mesh_id_len) == 0 &&\r\n(ifmsh->mesh_pp_id == ie->mesh_config->meshconf_psel) &&\r\n(ifmsh->mesh_pm_id == ie->mesh_config->meshconf_pmetric) &&\r\n(ifmsh->mesh_cc_id == ie->mesh_config->meshconf_congest) &&\r\n(ifmsh->mesh_sp_id == ie->mesh_config->meshconf_synch) &&\r\n(ifmsh->mesh_auth_id == ie->mesh_config->meshconf_auth)))\r\nreturn false;\r\nieee80211_sta_get_rates(sdata, ie, ieee80211_get_sdata_band(sdata),\r\n&basic_rates);\r\nif (sdata->vif.bss_conf.basic_rates != basic_rates)\r\nreturn false;\r\ncfg80211_chandef_create(&sta_chan_def, sdata->vif.bss_conf.chandef.chan,\r\nNL80211_CHAN_NO_HT);\r\nieee80211_chandef_ht_oper(ie->ht_operation, &sta_chan_def);\r\nieee80211_chandef_vht_oper(ie->vht_operation, &sta_chan_def);\r\nif (!cfg80211_chandef_compatible(&sdata->vif.bss_conf.chandef,\r\n&sta_chan_def))\r\nreturn false;\r\nreturn true;\r\n}\r\nbool mesh_peer_accepts_plinks(struct ieee802_11_elems *ie)\r\n{\r\nreturn (ie->mesh_config->meshconf_cap &\r\nIEEE80211_MESHCONF_CAPAB_ACCEPT_PLINKS) != 0;\r\n}\r\nu32 mesh_accept_plinks_update(struct ieee80211_sub_if_data *sdata)\r\n{\r\nbool free_plinks;\r\nu32 changed = 0;\r\nfree_plinks = mesh_plink_availables(sdata);\r\nif (free_plinks != sdata->u.mesh.accepting_plinks) {\r\nsdata->u.mesh.accepting_plinks = free_plinks;\r\nchanged = BSS_CHANGED_BEACON;\r\n}\r\nreturn changed;\r\n}\r\nvoid mesh_sta_cleanup(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nu32 changed = mesh_plink_deactivate(sta);\r\nif (changed)\r\nieee80211_mbss_info_change_notify(sdata, changed);\r\n}\r\nint mesh_rmc_init(struct ieee80211_sub_if_data *sdata)\r\n{\r\nint i;\r\nsdata->u.mesh.rmc = kmalloc(sizeof(struct mesh_rmc), GFP_KERNEL);\r\nif (!sdata->u.mesh.rmc)\r\nreturn -ENOMEM;\r\nsdata->u.mesh.rmc->idx_mask = RMC_BUCKETS - 1;\r\nfor (i = 0; i < RMC_BUCKETS; i++)\r\nINIT_HLIST_HEAD(&sdata->u.mesh.rmc->bucket[i]);\r\nreturn 0;\r\n}\r\nvoid mesh_rmc_free(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct mesh_rmc *rmc = sdata->u.mesh.rmc;\r\nstruct rmc_entry *p;\r\nstruct hlist_node *n;\r\nint i;\r\nif (!sdata->u.mesh.rmc)\r\nreturn;\r\nfor (i = 0; i < RMC_BUCKETS; i++) {\r\nhlist_for_each_entry_safe(p, n, &rmc->bucket[i], list) {\r\nhlist_del(&p->list);\r\nkmem_cache_free(rm_cache, p);\r\n}\r\n}\r\nkfree(rmc);\r\nsdata->u.mesh.rmc = NULL;\r\n}\r\nint mesh_rmc_check(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *sa, struct ieee80211s_hdr *mesh_hdr)\r\n{\r\nstruct mesh_rmc *rmc = sdata->u.mesh.rmc;\r\nu32 seqnum = 0;\r\nint entries = 0;\r\nu8 idx;\r\nstruct rmc_entry *p;\r\nstruct hlist_node *n;\r\nif (!rmc)\r\nreturn -1;\r\nmemcpy(&seqnum, &mesh_hdr->seqnum, sizeof(mesh_hdr->seqnum));\r\nidx = le32_to_cpu(mesh_hdr->seqnum) & rmc->idx_mask;\r\nhlist_for_each_entry_safe(p, n, &rmc->bucket[idx], list) {\r\n++entries;\r\nif (time_after(jiffies, p->exp_time) ||\r\nentries == RMC_QUEUE_MAX_LEN) {\r\nhlist_del(&p->list);\r\nkmem_cache_free(rm_cache, p);\r\n--entries;\r\n} else if ((seqnum == p->seqnum) && ether_addr_equal(sa, p->sa))\r\nreturn -1;\r\n}\r\np = kmem_cache_alloc(rm_cache, GFP_ATOMIC);\r\nif (!p)\r\nreturn 0;\r\np->seqnum = seqnum;\r\np->exp_time = jiffies + RMC_TIMEOUT;\r\nmemcpy(p->sa, sa, ETH_ALEN);\r\nhlist_add_head(&p->list, &rmc->bucket[idx]);\r\nreturn 0;\r\n}\r\nint mesh_add_meshconf_ie(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu8 *pos, neighbors;\r\nu8 meshconf_len = sizeof(struct ieee80211_meshconf_ie);\r\nif (skb_tailroom(skb) < 2 + meshconf_len)\r\nreturn -ENOMEM;\r\npos = skb_put(skb, 2 + meshconf_len);\r\n*pos++ = WLAN_EID_MESH_CONFIG;\r\n*pos++ = meshconf_len;\r\nifmsh->meshconf_offset = pos - skb->data;\r\n*pos++ = ifmsh->mesh_pp_id;\r\n*pos++ = ifmsh->mesh_pm_id;\r\n*pos++ = ifmsh->mesh_cc_id;\r\n*pos++ = ifmsh->mesh_sp_id;\r\n*pos++ = ifmsh->mesh_auth_id;\r\nneighbors = atomic_read(&ifmsh->estab_plinks);\r\nneighbors = min_t(int, neighbors, IEEE80211_MAX_MESH_PEERINGS);\r\n*pos++ = neighbors << 1;\r\n*pos = 0x00;\r\n*pos |= ifmsh->mshcfg.dot11MeshForwarding ?\r\nIEEE80211_MESHCONF_CAPAB_FORWARDING : 0x00;\r\n*pos |= ifmsh->accepting_plinks ?\r\nIEEE80211_MESHCONF_CAPAB_ACCEPT_PLINKS : 0x00;\r\n*pos |= ifmsh->ps_peers_deep_sleep ?\r\nIEEE80211_MESHCONF_CAPAB_POWER_SAVE_LEVEL : 0x00;\r\n*pos++ |= ifmsh->adjusting_tbtt ?\r\nIEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING : 0x00;\r\n*pos++ = 0x00;\r\nreturn 0;\r\n}\r\nint mesh_add_meshid_ie(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu8 *pos;\r\nif (skb_tailroom(skb) < 2 + ifmsh->mesh_id_len)\r\nreturn -ENOMEM;\r\npos = skb_put(skb, 2 + ifmsh->mesh_id_len);\r\n*pos++ = WLAN_EID_MESH_ID;\r\n*pos++ = ifmsh->mesh_id_len;\r\nif (ifmsh->mesh_id_len)\r\nmemcpy(pos, ifmsh->mesh_id, ifmsh->mesh_id_len);\r\nreturn 0;\r\n}\r\nstatic int mesh_add_awake_window_ie(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu8 *pos;\r\nif (ifmsh->ps_peers_light_sleep == 0 &&\r\nifmsh->ps_peers_deep_sleep == 0 &&\r\nifmsh->nonpeer_pm == NL80211_MESH_POWER_ACTIVE)\r\nreturn 0;\r\nif (skb_tailroom(skb) < 4)\r\nreturn -ENOMEM;\r\npos = skb_put(skb, 2 + 2);\r\n*pos++ = WLAN_EID_MESH_AWAKE_WINDOW;\r\n*pos++ = 2;\r\nput_unaligned_le16(ifmsh->mshcfg.dot11MeshAwakeWindowDuration, pos);\r\nreturn 0;\r\n}\r\nint mesh_add_vendor_ies(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu8 offset, len;\r\nconst u8 *data;\r\nif (!ifmsh->ie || !ifmsh->ie_len)\r\nreturn 0;\r\noffset = ieee80211_ie_split_vendor(ifmsh->ie, ifmsh->ie_len, 0);\r\nif (offset) {\r\nlen = ifmsh->ie_len - offset;\r\ndata = ifmsh->ie + offset;\r\nif (skb_tailroom(skb) < len)\r\nreturn -ENOMEM;\r\nmemcpy(skb_put(skb, len), data, len);\r\n}\r\nreturn 0;\r\n}\r\nint mesh_add_rsn_ie(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu8 len = 0;\r\nconst u8 *data;\r\nif (!ifmsh->ie || !ifmsh->ie_len)\r\nreturn 0;\r\ndata = cfg80211_find_ie(WLAN_EID_RSN, ifmsh->ie, ifmsh->ie_len);\r\nif (!data)\r\nreturn 0;\r\nlen = data[1] + 2;\r\nif (skb_tailroom(skb) < len)\r\nreturn -ENOMEM;\r\nmemcpy(skb_put(skb, len), data, len);\r\nreturn 0;\r\n}\r\nstatic int mesh_add_ds_params_ie(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nstruct ieee80211_channel *chan;\r\nu8 *pos;\r\nif (skb_tailroom(skb) < 3)\r\nreturn -ENOMEM;\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\r\nif (WARN_ON(!chanctx_conf)) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nchan = chanctx_conf->def.chan;\r\nrcu_read_unlock();\r\npos = skb_put(skb, 2 + 1);\r\n*pos++ = WLAN_EID_DS_PARAMS;\r\n*pos++ = 1;\r\n*pos++ = ieee80211_frequency_to_channel(chan->center_freq);\r\nreturn 0;\r\n}\r\nint mesh_add_ht_cap_ie(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nenum nl80211_band band = ieee80211_get_sdata_band(sdata);\r\nstruct ieee80211_supported_band *sband;\r\nu8 *pos;\r\nsband = local->hw.wiphy->bands[band];\r\nif (!sband->ht_cap.ht_supported ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\r\nreturn 0;\r\nif (skb_tailroom(skb) < 2 + sizeof(struct ieee80211_ht_cap))\r\nreturn -ENOMEM;\r\npos = skb_put(skb, 2 + sizeof(struct ieee80211_ht_cap));\r\nieee80211_ie_build_ht_cap(pos, &sband->ht_cap, sband->ht_cap.cap);\r\nreturn 0;\r\n}\r\nint mesh_add_ht_oper_ie(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nstruct ieee80211_channel *channel;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_sta_ht_cap *ht_cap;\r\nu8 *pos;\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\r\nif (WARN_ON(!chanctx_conf)) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nchannel = chanctx_conf->def.chan;\r\nrcu_read_unlock();\r\nsband = local->hw.wiphy->bands[channel->band];\r\nht_cap = &sband->ht_cap;\r\nif (!ht_cap->ht_supported ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\r\nreturn 0;\r\nif (skb_tailroom(skb) < 2 + sizeof(struct ieee80211_ht_operation))\r\nreturn -ENOMEM;\r\npos = skb_put(skb, 2 + sizeof(struct ieee80211_ht_operation));\r\nieee80211_ie_build_ht_oper(pos, ht_cap, &sdata->vif.bss_conf.chandef,\r\nsdata->vif.bss_conf.ht_operation_mode,\r\nfalse);\r\nreturn 0;\r\n}\r\nint mesh_add_vht_cap_ie(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nenum nl80211_band band = ieee80211_get_sdata_band(sdata);\r\nstruct ieee80211_supported_band *sband;\r\nu8 *pos;\r\nsband = local->hw.wiphy->bands[band];\r\nif (!sband->vht_cap.vht_supported ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\r\nreturn 0;\r\nif (skb_tailroom(skb) < 2 + sizeof(struct ieee80211_vht_cap))\r\nreturn -ENOMEM;\r\npos = skb_put(skb, 2 + sizeof(struct ieee80211_vht_cap));\r\nieee80211_ie_build_vht_cap(pos, &sband->vht_cap, sband->vht_cap.cap);\r\nreturn 0;\r\n}\r\nint mesh_add_vht_oper_ie(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nstruct ieee80211_channel *channel;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_sta_vht_cap *vht_cap;\r\nu8 *pos;\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\r\nif (WARN_ON(!chanctx_conf)) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nchannel = chanctx_conf->def.chan;\r\nrcu_read_unlock();\r\nsband = local->hw.wiphy->bands[channel->band];\r\nvht_cap = &sband->vht_cap;\r\nif (!vht_cap->vht_supported ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\r\nsdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\r\nreturn 0;\r\nif (skb_tailroom(skb) < 2 + sizeof(struct ieee80211_vht_operation))\r\nreturn -ENOMEM;\r\npos = skb_put(skb, 2 + sizeof(struct ieee80211_vht_operation));\r\nieee80211_ie_build_vht_oper(pos, vht_cap,\r\n&sdata->vif.bss_conf.chandef);\r\nreturn 0;\r\n}\r\nstatic void ieee80211_mesh_path_timer(unsigned long data)\r\n{\r\nstruct ieee80211_sub_if_data *sdata =\r\n(struct ieee80211_sub_if_data *) data;\r\nieee80211_queue_work(&sdata->local->hw, &sdata->work);\r\n}\r\nstatic void ieee80211_mesh_path_root_timer(unsigned long data)\r\n{\r\nstruct ieee80211_sub_if_data *sdata =\r\n(struct ieee80211_sub_if_data *) data;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nset_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\r\nieee80211_queue_work(&sdata->local->hw, &sdata->work);\r\n}\r\nvoid ieee80211_mesh_root_setup(struct ieee80211_if_mesh *ifmsh)\r\n{\r\nif (ifmsh->mshcfg.dot11MeshHWMPRootMode > IEEE80211_ROOTMODE_ROOT)\r\nset_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\r\nelse {\r\nclear_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\r\ndel_timer_sync(&ifmsh->mesh_path_root_timer);\r\n}\r\n}\r\nint ieee80211_fill_mesh_addresses(struct ieee80211_hdr *hdr, __le16 *fc,\r\nconst u8 *meshda, const u8 *meshsa)\r\n{\r\nif (is_multicast_ether_addr(meshda)) {\r\n*fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\r\nmemcpy(hdr->addr1, meshda, ETH_ALEN);\r\nmemcpy(hdr->addr2, meshsa, ETH_ALEN);\r\nmemcpy(hdr->addr3, meshsa, ETH_ALEN);\r\nreturn 24;\r\n} else {\r\n*fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\r\neth_zero_addr(hdr->addr1);\r\nmemcpy(hdr->addr2, meshsa, ETH_ALEN);\r\nmemcpy(hdr->addr3, meshda, ETH_ALEN);\r\nmemcpy(hdr->addr4, meshsa, ETH_ALEN);\r\nreturn 30;\r\n}\r\n}\r\nunsigned int ieee80211_new_mesh_header(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211s_hdr *meshhdr,\r\nconst char *addr4or5, const char *addr6)\r\n{\r\nif (WARN_ON(!addr4or5 && addr6))\r\nreturn 0;\r\nmemset(meshhdr, 0, sizeof(*meshhdr));\r\nmeshhdr->ttl = sdata->u.mesh.mshcfg.dot11MeshTTL;\r\nput_unaligned(cpu_to_le32(sdata->u.mesh.mesh_seqnum), &meshhdr->seqnum);\r\nsdata->u.mesh.mesh_seqnum++;\r\nif (addr4or5 && !addr6) {\r\nmeshhdr->flags |= MESH_FLAGS_AE_A4;\r\nmemcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);\r\nreturn 2 * ETH_ALEN;\r\n} else if (addr4or5 && addr6) {\r\nmeshhdr->flags |= MESH_FLAGS_AE_A5_A6;\r\nmemcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);\r\nmemcpy(meshhdr->eaddr2, addr6, ETH_ALEN);\r\nreturn 3 * ETH_ALEN;\r\n}\r\nreturn ETH_ALEN;\r\n}\r\nstatic void ieee80211_mesh_housekeeping(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu32 changed;\r\nif (ifmsh->mshcfg.plink_timeout > 0)\r\nieee80211_sta_expire(sdata, ifmsh->mshcfg.plink_timeout * HZ);\r\nmesh_path_expire(sdata);\r\nchanged = mesh_accept_plinks_update(sdata);\r\nieee80211_mbss_info_change_notify(sdata, changed);\r\nmod_timer(&ifmsh->housekeeping_timer,\r\nround_jiffies(jiffies +\r\nIEEE80211_MESH_HOUSEKEEPING_INTERVAL));\r\n}\r\nstatic void ieee80211_mesh_rootpath(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu32 interval;\r\nmesh_path_tx_root_frame(sdata);\r\nif (ifmsh->mshcfg.dot11MeshHWMPRootMode == IEEE80211_PROACTIVE_RANN)\r\ninterval = ifmsh->mshcfg.dot11MeshHWMPRannInterval;\r\nelse\r\ninterval = ifmsh->mshcfg.dot11MeshHWMProotInterval;\r\nmod_timer(&ifmsh->mesh_path_root_timer,\r\nround_jiffies(TU_TO_EXP_TIME(interval)));\r\n}\r\nstatic int\r\nieee80211_mesh_build_beacon(struct ieee80211_if_mesh *ifmsh)\r\n{\r\nstruct beacon_data *bcn;\r\nint head_len, tail_len;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nstruct mesh_csa_settings *csa;\r\nenum nl80211_band band;\r\nu8 *pos;\r\nstruct ieee80211_sub_if_data *sdata;\r\nint hdr_len = offsetof(struct ieee80211_mgmt, u.beacon) +\r\nsizeof(mgmt->u.beacon);\r\nsdata = container_of(ifmsh, struct ieee80211_sub_if_data, u.mesh);\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\r\nband = chanctx_conf->def.chan->band;\r\nrcu_read_unlock();\r\nhead_len = hdr_len +\r\n2 +\r\n2 + sizeof(struct ieee80211_channel_sw_ie) +\r\n2 + sizeof(struct ieee80211_mesh_chansw_params_ie) +\r\n2 + 8 +\r\n2 + 3;\r\ntail_len = 2 + (IEEE80211_MAX_SUPP_RATES - 8) +\r\n2 + sizeof(struct ieee80211_ht_cap) +\r\n2 + sizeof(struct ieee80211_ht_operation) +\r\n2 + ifmsh->mesh_id_len +\r\n2 + sizeof(struct ieee80211_meshconf_ie) +\r\n2 + sizeof(__le16) +\r\n2 + sizeof(struct ieee80211_vht_cap) +\r\n2 + sizeof(struct ieee80211_vht_operation) +\r\nifmsh->ie_len;\r\nbcn = kzalloc(sizeof(*bcn) + head_len + tail_len, GFP_KERNEL);\r\nskb = dev_alloc_skb(max(head_len, tail_len));\r\nif (!bcn || !skb)\r\ngoto out_free;\r\nbcn->head = ((u8 *) bcn) + sizeof(*bcn);\r\nmgmt = (struct ieee80211_mgmt *) skb_put(skb, hdr_len);\r\nmemset(mgmt, 0, hdr_len);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_BEACON);\r\neth_broadcast_addr(mgmt->da);\r\nmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\r\nieee80211_mps_set_frame_flags(sdata, NULL, (void *) mgmt);\r\nmgmt->u.beacon.beacon_int =\r\ncpu_to_le16(sdata->vif.bss_conf.beacon_int);\r\nmgmt->u.beacon.capab_info |= cpu_to_le16(\r\nsdata->u.mesh.security ? WLAN_CAPABILITY_PRIVACY : 0);\r\npos = skb_put(skb, 2);\r\n*pos++ = WLAN_EID_SSID;\r\n*pos++ = 0x0;\r\nrcu_read_lock();\r\ncsa = rcu_dereference(ifmsh->csa);\r\nif (csa) {\r\npos = skb_put(skb, 13);\r\nmemset(pos, 0, 13);\r\n*pos++ = WLAN_EID_CHANNEL_SWITCH;\r\n*pos++ = 3;\r\n*pos++ = 0x0;\r\n*pos++ = ieee80211_frequency_to_channel(\r\ncsa->settings.chandef.chan->center_freq);\r\nbcn->csa_current_counter = csa->settings.count;\r\nbcn->csa_counter_offsets[0] = hdr_len + 6;\r\n*pos++ = csa->settings.count;\r\n*pos++ = WLAN_EID_CHAN_SWITCH_PARAM;\r\n*pos++ = 6;\r\nif (ifmsh->csa_role == IEEE80211_MESH_CSA_ROLE_INIT) {\r\n*pos++ = ifmsh->mshcfg.dot11MeshTTL;\r\n*pos |= WLAN_EID_CHAN_SWITCH_PARAM_INITIATOR;\r\n} else {\r\n*pos++ = ifmsh->chsw_ttl;\r\n}\r\n*pos++ |= csa->settings.block_tx ?\r\nWLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT : 0x00;\r\nput_unaligned_le16(WLAN_REASON_MESH_CHAN, pos);\r\npos += 2;\r\nput_unaligned_le16(ifmsh->pre_value, pos);\r\npos += 2;\r\n}\r\nrcu_read_unlock();\r\nif (ieee80211_add_srates_ie(sdata, skb, true, band) ||\r\nmesh_add_ds_params_ie(sdata, skb))\r\ngoto out_free;\r\nbcn->head_len = skb->len;\r\nmemcpy(bcn->head, skb->data, bcn->head_len);\r\nskb_trim(skb, 0);\r\nbcn->tail = bcn->head + bcn->head_len;\r\nif (ieee80211_add_ext_srates_ie(sdata, skb, true, band) ||\r\nmesh_add_rsn_ie(sdata, skb) ||\r\nmesh_add_ht_cap_ie(sdata, skb) ||\r\nmesh_add_ht_oper_ie(sdata, skb) ||\r\nmesh_add_meshid_ie(sdata, skb) ||\r\nmesh_add_meshconf_ie(sdata, skb) ||\r\nmesh_add_awake_window_ie(sdata, skb) ||\r\nmesh_add_vht_cap_ie(sdata, skb) ||\r\nmesh_add_vht_oper_ie(sdata, skb) ||\r\nmesh_add_vendor_ies(sdata, skb))\r\ngoto out_free;\r\nbcn->tail_len = skb->len;\r\nmemcpy(bcn->tail, skb->data, bcn->tail_len);\r\nbcn->meshconf = (struct ieee80211_meshconf_ie *)\r\n(bcn->tail + ifmsh->meshconf_offset);\r\ndev_kfree_skb(skb);\r\nrcu_assign_pointer(ifmsh->beacon, bcn);\r\nreturn 0;\r\nout_free:\r\nkfree(bcn);\r\ndev_kfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\nstatic int\r\nieee80211_mesh_rebuild_beacon(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct beacon_data *old_bcn;\r\nint ret;\r\nold_bcn = rcu_dereference_protected(sdata->u.mesh.beacon,\r\nlockdep_is_held(&sdata->wdev.mtx));\r\nret = ieee80211_mesh_build_beacon(&sdata->u.mesh);\r\nif (ret)\r\nreturn ret;\r\nif (old_bcn)\r\nkfree_rcu(old_bcn, rcu_head);\r\nreturn 0;\r\n}\r\nvoid ieee80211_mbss_info_change_notify(struct ieee80211_sub_if_data *sdata,\r\nu32 changed)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nunsigned long bits = changed;\r\nu32 bit;\r\nif (!bits)\r\nreturn;\r\nfor_each_set_bit(bit, &bits, sizeof(changed) * BITS_PER_BYTE)\r\nset_bit(bit, &ifmsh->mbss_changed);\r\nset_bit(MESH_WORK_MBSS_CHANGED, &ifmsh->wrkq_flags);\r\nieee80211_queue_work(&sdata->local->hw, &sdata->work);\r\n}\r\nint ieee80211_start_mesh(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee80211_local *local = sdata->local;\r\nu32 changed = BSS_CHANGED_BEACON |\r\nBSS_CHANGED_BEACON_ENABLED |\r\nBSS_CHANGED_HT |\r\nBSS_CHANGED_BASIC_RATES |\r\nBSS_CHANGED_BEACON_INT;\r\nlocal->fif_other_bss++;\r\natomic_inc(&local->iff_allmultis);\r\nieee80211_configure_filter(local);\r\nifmsh->mesh_cc_id = 0;\r\nifmsh->sync_ops = ieee80211_mesh_sync_ops_get(ifmsh->mesh_sp_id);\r\nifmsh->adjusting_tbtt = false;\r\nifmsh->sync_offset_clockdrift_max = 0;\r\nset_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);\r\nieee80211_mesh_root_setup(ifmsh);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\nsdata->vif.bss_conf.ht_operation_mode =\r\nifmsh->mshcfg.ht_opmode;\r\nsdata->vif.bss_conf.enable_beacon = true;\r\nchanged |= ieee80211_mps_local_status_update(sdata);\r\nif (ieee80211_mesh_build_beacon(ifmsh)) {\r\nieee80211_stop_mesh(sdata);\r\nreturn -ENOMEM;\r\n}\r\nieee80211_recalc_dtim(local, sdata);\r\nieee80211_bss_info_change_notify(sdata, changed);\r\nnetif_carrier_on(sdata->dev);\r\nreturn 0;\r\n}\r\nvoid ieee80211_stop_mesh(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct beacon_data *bcn;\r\nnetif_carrier_off(sdata->dev);\r\nsta_info_flush(sdata);\r\nmesh_path_flush_by_iface(sdata);\r\nifmsh->mesh_id_len = 0;\r\nsdata->vif.bss_conf.enable_beacon = false;\r\nclear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED);\r\nbcn = rcu_dereference_protected(ifmsh->beacon,\r\nlockdep_is_held(&sdata->wdev.mtx));\r\nRCU_INIT_POINTER(ifmsh->beacon, NULL);\r\nkfree_rcu(bcn, rcu_head);\r\nlocal->total_ps_buffered -= skb_queue_len(&ifmsh->ps.bc_buf);\r\nskb_queue_purge(&ifmsh->ps.bc_buf);\r\ndel_timer_sync(&sdata->u.mesh.housekeeping_timer);\r\ndel_timer_sync(&sdata->u.mesh.mesh_path_root_timer);\r\ndel_timer_sync(&sdata->u.mesh.mesh_path_timer);\r\nifmsh->wrkq_flags = 0;\r\nifmsh->mbss_changed = 0;\r\nlocal->fif_other_bss--;\r\natomic_dec(&local->iff_allmultis);\r\nieee80211_configure_filter(local);\r\n}\r\nstatic bool\r\nieee80211_mesh_process_chnswitch(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee802_11_elems *elems, bool beacon)\r\n{\r\nstruct cfg80211_csa_settings params;\r\nstruct ieee80211_csa_ie csa_ie;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nenum nl80211_band band = ieee80211_get_sdata_band(sdata);\r\nint err;\r\nu32 sta_flags;\r\nsdata_assert_lock(sdata);\r\nsta_flags = IEEE80211_STA_DISABLE_VHT;\r\nswitch (sdata->vif.bss_conf.chandef.width) {\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\nsta_flags |= IEEE80211_STA_DISABLE_HT;\r\ncase NL80211_CHAN_WIDTH_20:\r\nsta_flags |= IEEE80211_STA_DISABLE_40MHZ;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmemset(&params, 0, sizeof(params));\r\nmemset(&csa_ie, 0, sizeof(csa_ie));\r\nerr = ieee80211_parse_ch_switch_ie(sdata, elems, band,\r\nsta_flags, sdata->vif.addr,\r\n&csa_ie);\r\nif (err < 0)\r\nreturn false;\r\nif (err)\r\nreturn false;\r\nparams.chandef = csa_ie.chandef;\r\nparams.count = csa_ie.count;\r\nif (!cfg80211_chandef_usable(sdata->local->hw.wiphy, &params.chandef,\r\nIEEE80211_CHAN_DISABLED)) {\r\nsdata_info(sdata,\r\n"mesh STA %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), aborting\n",\r\nsdata->vif.addr,\r\nparams.chandef.chan->center_freq,\r\nparams.chandef.width,\r\nparams.chandef.center_freq1,\r\nparams.chandef.center_freq2);\r\nreturn false;\r\n}\r\nerr = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,\r\n&params.chandef,\r\nNL80211_IFTYPE_MESH_POINT);\r\nif (err < 0)\r\nreturn false;\r\nif (err > 0)\r\nreturn false;\r\nparams.radar_required = err;\r\nif (cfg80211_chandef_identical(&params.chandef,\r\n&sdata->vif.bss_conf.chandef)) {\r\nmcsa_dbg(sdata,\r\n"received csa with an identical chandef, ignoring\n");\r\nreturn true;\r\n}\r\nmcsa_dbg(sdata,\r\n"received channel switch announcement to go to channel %d MHz\n",\r\nparams.chandef.chan->center_freq);\r\nparams.block_tx = csa_ie.mode & WLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT;\r\nif (beacon) {\r\nifmsh->chsw_ttl = csa_ie.ttl - 1;\r\nif (ifmsh->pre_value >= csa_ie.pre_value)\r\nreturn false;\r\nifmsh->pre_value = csa_ie.pre_value;\r\n}\r\nif (ifmsh->chsw_ttl >= ifmsh->mshcfg.dot11MeshTTL)\r\nreturn false;\r\nifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_REPEATER;\r\nif (ieee80211_channel_switch(sdata->local->hw.wiphy, sdata->dev,\r\n&params) < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void\r\nieee80211_mesh_rx_probe_req(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt, size_t len)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct sk_buff *presp;\r\nstruct beacon_data *bcn;\r\nstruct ieee80211_mgmt *hdr;\r\nstruct ieee802_11_elems elems;\r\nsize_t baselen;\r\nu8 *pos;\r\npos = mgmt->u.probe_req.variable;\r\nbaselen = (u8 *) pos - (u8 *) mgmt;\r\nif (baselen > len)\r\nreturn;\r\nieee802_11_parse_elems(pos, len - baselen, false, &elems);\r\nif (!elems.mesh_id)\r\nreturn;\r\nif ((!ether_addr_equal(mgmt->da, sdata->vif.addr) &&\r\n!is_broadcast_ether_addr(mgmt->da)) ||\r\nelems.ssid_len != 0)\r\nreturn;\r\nif (elems.mesh_id_len != 0 &&\r\n(elems.mesh_id_len != ifmsh->mesh_id_len ||\r\nmemcmp(elems.mesh_id, ifmsh->mesh_id, ifmsh->mesh_id_len)))\r\nreturn;\r\nrcu_read_lock();\r\nbcn = rcu_dereference(ifmsh->beacon);\r\nif (!bcn)\r\ngoto out;\r\npresp = dev_alloc_skb(local->tx_headroom +\r\nbcn->head_len + bcn->tail_len);\r\nif (!presp)\r\ngoto out;\r\nskb_reserve(presp, local->tx_headroom);\r\nmemcpy(skb_put(presp, bcn->head_len), bcn->head, bcn->head_len);\r\nmemcpy(skb_put(presp, bcn->tail_len), bcn->tail, bcn->tail_len);\r\nhdr = (struct ieee80211_mgmt *) presp->data;\r\nhdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_PROBE_RESP);\r\nmemcpy(hdr->da, mgmt->sa, ETH_ALEN);\r\nIEEE80211_SKB_CB(presp)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\r\nieee80211_tx_skb(sdata, presp);\r\nout:\r\nrcu_read_unlock();\r\n}\r\nstatic void ieee80211_mesh_rx_bcn_presp(struct ieee80211_sub_if_data *sdata,\r\nu16 stype,\r\nstruct ieee80211_mgmt *mgmt,\r\nsize_t len,\r\nstruct ieee80211_rx_status *rx_status)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee802_11_elems elems;\r\nstruct ieee80211_channel *channel;\r\nsize_t baselen;\r\nint freq;\r\nenum nl80211_band band = rx_status->band;\r\nif (stype == IEEE80211_STYPE_PROBE_RESP &&\r\n!ether_addr_equal(mgmt->da, sdata->vif.addr))\r\nreturn;\r\nbaselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;\r\nif (baselen > len)\r\nreturn;\r\nieee802_11_parse_elems(mgmt->u.probe_resp.variable, len - baselen,\r\nfalse, &elems);\r\nif ((!elems.mesh_id || !elems.mesh_config) ||\r\n(elems.rsn && sdata->u.mesh.security == IEEE80211_MESH_SEC_NONE) ||\r\n(!elems.rsn && sdata->u.mesh.security != IEEE80211_MESH_SEC_NONE))\r\nreturn;\r\nif (elems.ds_params)\r\nfreq = ieee80211_channel_to_frequency(elems.ds_params[0], band);\r\nelse\r\nfreq = rx_status->freq;\r\nchannel = ieee80211_get_channel(local->hw.wiphy, freq);\r\nif (!channel || channel->flags & IEEE80211_CHAN_DISABLED)\r\nreturn;\r\nif (mesh_matches_local(sdata, &elems))\r\nmesh_neighbour_update(sdata, mgmt->sa, &elems);\r\nif (ifmsh->sync_ops)\r\nifmsh->sync_ops->rx_bcn_presp(sdata,\r\nstype, mgmt, &elems, rx_status);\r\nif (ifmsh->csa_role != IEEE80211_MESH_CSA_ROLE_INIT &&\r\n!sdata->vif.csa_active)\r\nieee80211_mesh_process_chnswitch(sdata, &elems, true);\r\n}\r\nint ieee80211_mesh_finish_csa(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct mesh_csa_settings *tmp_csa_settings;\r\nint ret = 0;\r\nint changed = 0;\r\nifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_NONE;\r\nifmsh->chsw_ttl = 0;\r\ntmp_csa_settings = rcu_dereference(ifmsh->csa);\r\nRCU_INIT_POINTER(ifmsh->csa, NULL);\r\nif (tmp_csa_settings)\r\nkfree_rcu(tmp_csa_settings, rcu_head);\r\nret = ieee80211_mesh_rebuild_beacon(sdata);\r\nif (ret)\r\nreturn -EINVAL;\r\nchanged |= BSS_CHANGED_BEACON;\r\nmcsa_dbg(sdata, "complete switching to center freq %d MHz",\r\nsdata->vif.bss_conf.chandef.chan->center_freq);\r\nreturn changed;\r\n}\r\nint ieee80211_mesh_csa_beacon(struct ieee80211_sub_if_data *sdata,\r\nstruct cfg80211_csa_settings *csa_settings)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct mesh_csa_settings *tmp_csa_settings;\r\nint ret = 0;\r\ntmp_csa_settings = kmalloc(sizeof(*tmp_csa_settings),\r\nGFP_ATOMIC);\r\nif (!tmp_csa_settings)\r\nreturn -ENOMEM;\r\nmemcpy(&tmp_csa_settings->settings, csa_settings,\r\nsizeof(struct cfg80211_csa_settings));\r\nrcu_assign_pointer(ifmsh->csa, tmp_csa_settings);\r\nret = ieee80211_mesh_rebuild_beacon(sdata);\r\nif (ret) {\r\ntmp_csa_settings = rcu_dereference(ifmsh->csa);\r\nRCU_INIT_POINTER(ifmsh->csa, NULL);\r\nkfree_rcu(tmp_csa_settings, rcu_head);\r\nreturn ret;\r\n}\r\nreturn BSS_CHANGED_BEACON;\r\n}\r\nstatic int mesh_fwd_csa_frame(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt, size_t len)\r\n{\r\nstruct ieee80211_mgmt *mgmt_fwd;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_local *local = sdata->local;\r\nu8 *pos = mgmt->u.action.u.chan_switch.variable;\r\nsize_t offset_ttl;\r\nskb = dev_alloc_skb(local->tx_headroom + len);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, local->tx_headroom);\r\nmgmt_fwd = (struct ieee80211_mgmt *) skb_put(skb, len);\r\noffset_ttl = (len < 42) ? 7 : 10;\r\n*(pos + offset_ttl) -= 1;\r\n*(pos + offset_ttl + 1) &= ~WLAN_EID_CHAN_SWITCH_PARAM_INITIATOR;\r\nmemcpy(mgmt_fwd, mgmt, len);\r\neth_broadcast_addr(mgmt_fwd->da);\r\nmemcpy(mgmt_fwd->sa, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(mgmt_fwd->bssid, sdata->vif.addr, ETH_ALEN);\r\nieee80211_tx_skb(sdata, skb);\r\nreturn 0;\r\n}\r\nstatic void mesh_rx_csa_frame(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt, size_t len)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee802_11_elems elems;\r\nu16 pre_value;\r\nbool fwd_csa = true;\r\nsize_t baselen;\r\nu8 *pos;\r\nif (mgmt->u.action.u.measurement.action_code !=\r\nWLAN_ACTION_SPCT_CHL_SWITCH)\r\nreturn;\r\npos = mgmt->u.action.u.chan_switch.variable;\r\nbaselen = offsetof(struct ieee80211_mgmt,\r\nu.action.u.chan_switch.variable);\r\nieee802_11_parse_elems(pos, len - baselen, false, &elems);\r\nifmsh->chsw_ttl = elems.mesh_chansw_params_ie->mesh_ttl;\r\nif (!--ifmsh->chsw_ttl)\r\nfwd_csa = false;\r\npre_value = le16_to_cpu(elems.mesh_chansw_params_ie->mesh_pre_value);\r\nif (ifmsh->pre_value >= pre_value)\r\nreturn;\r\nifmsh->pre_value = pre_value;\r\nif (!sdata->vif.csa_active &&\r\n!ieee80211_mesh_process_chnswitch(sdata, &elems, false)) {\r\nmcsa_dbg(sdata, "Failed to process CSA action frame");\r\nreturn;\r\n}\r\nif (fwd_csa) {\r\nif (mesh_fwd_csa_frame(sdata, mgmt, len) < 0)\r\nmcsa_dbg(sdata, "Failed to forward the CSA frame");\r\n}\r\n}\r\nstatic void ieee80211_mesh_rx_mgmt_action(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_mgmt *mgmt,\r\nsize_t len,\r\nstruct ieee80211_rx_status *rx_status)\r\n{\r\nswitch (mgmt->u.action.category) {\r\ncase WLAN_CATEGORY_SELF_PROTECTED:\r\nswitch (mgmt->u.action.u.self_prot.action_code) {\r\ncase WLAN_SP_MESH_PEERING_OPEN:\r\ncase WLAN_SP_MESH_PEERING_CLOSE:\r\ncase WLAN_SP_MESH_PEERING_CONFIRM:\r\nmesh_rx_plink_frame(sdata, mgmt, len, rx_status);\r\nbreak;\r\n}\r\nbreak;\r\ncase WLAN_CATEGORY_MESH_ACTION:\r\nif (mesh_action_is_path_sel(mgmt))\r\nmesh_rx_path_sel_frame(sdata, mgmt, len);\r\nbreak;\r\ncase WLAN_CATEGORY_SPECTRUM_MGMT:\r\nmesh_rx_csa_frame(sdata, mgmt, len);\r\nbreak;\r\n}\r\n}\r\nvoid ieee80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_rx_status *rx_status;\r\nstruct ieee80211_mgmt *mgmt;\r\nu16 stype;\r\nsdata_lock(sdata);\r\nif (!sdata->u.mesh.mesh_id_len)\r\ngoto out;\r\nrx_status = IEEE80211_SKB_RXCB(skb);\r\nmgmt = (struct ieee80211_mgmt *) skb->data;\r\nstype = le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE;\r\nswitch (stype) {\r\ncase IEEE80211_STYPE_PROBE_RESP:\r\ncase IEEE80211_STYPE_BEACON:\r\nieee80211_mesh_rx_bcn_presp(sdata, stype, mgmt, skb->len,\r\nrx_status);\r\nbreak;\r\ncase IEEE80211_STYPE_PROBE_REQ:\r\nieee80211_mesh_rx_probe_req(sdata, mgmt, skb->len);\r\nbreak;\r\ncase IEEE80211_STYPE_ACTION:\r\nieee80211_mesh_rx_mgmt_action(sdata, mgmt, skb->len, rx_status);\r\nbreak;\r\n}\r\nout:\r\nsdata_unlock(sdata);\r\n}\r\nstatic void mesh_bss_info_changed(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu32 bit, changed = 0;\r\nfor_each_set_bit(bit, &ifmsh->mbss_changed,\r\nsizeof(changed) * BITS_PER_BYTE) {\r\nclear_bit(bit, &ifmsh->mbss_changed);\r\nchanged |= BIT(bit);\r\n}\r\nif (sdata->vif.bss_conf.enable_beacon &&\r\n(changed & (BSS_CHANGED_BEACON |\r\nBSS_CHANGED_HT |\r\nBSS_CHANGED_BASIC_RATES |\r\nBSS_CHANGED_BEACON_INT)))\r\nif (ieee80211_mesh_rebuild_beacon(sdata))\r\nreturn;\r\nieee80211_bss_info_change_notify(sdata, changed);\r\n}\r\nvoid ieee80211_mesh_work(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nsdata_lock(sdata);\r\nif (!sdata->u.mesh.mesh_id_len)\r\ngoto out;\r\nif (ifmsh->preq_queue_len &&\r\ntime_after(jiffies,\r\nifmsh->last_preq + msecs_to_jiffies(ifmsh->mshcfg.dot11MeshHWMPpreqMinInterval)))\r\nmesh_path_start_discovery(sdata);\r\nif (test_and_clear_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags))\r\nieee80211_mesh_housekeeping(sdata);\r\nif (test_and_clear_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags))\r\nieee80211_mesh_rootpath(sdata);\r\nif (test_and_clear_bit(MESH_WORK_DRIFT_ADJUST, &ifmsh->wrkq_flags))\r\nmesh_sync_adjust_tbtt(sdata);\r\nif (test_and_clear_bit(MESH_WORK_MBSS_CHANGED, &ifmsh->wrkq_flags))\r\nmesh_bss_info_changed(sdata);\r\nout:\r\nsdata_unlock(sdata);\r\n}\r\nvoid ieee80211_mesh_init_sdata(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstatic u8 zero_addr[ETH_ALEN] = {};\r\nsetup_timer(&ifmsh->housekeeping_timer,\r\nieee80211_mesh_housekeeping_timer,\r\n(unsigned long) sdata);\r\nifmsh->accepting_plinks = true;\r\natomic_set(&ifmsh->mpaths, 0);\r\nmesh_rmc_init(sdata);\r\nifmsh->last_preq = jiffies;\r\nifmsh->next_perr = jiffies;\r\nifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_NONE;\r\nif (!mesh_allocated)\r\nieee80211s_init();\r\nmesh_pathtbl_init(sdata);\r\nsetup_timer(&ifmsh->mesh_path_timer,\r\nieee80211_mesh_path_timer,\r\n(unsigned long) sdata);\r\nsetup_timer(&ifmsh->mesh_path_root_timer,\r\nieee80211_mesh_path_root_timer,\r\n(unsigned long) sdata);\r\nINIT_LIST_HEAD(&ifmsh->preq_queue.list);\r\nskb_queue_head_init(&ifmsh->ps.bc_buf);\r\nspin_lock_init(&ifmsh->mesh_preq_queue_lock);\r\nspin_lock_init(&ifmsh->sync_offset_lock);\r\nRCU_INIT_POINTER(ifmsh->beacon, NULL);\r\nsdata->vif.bss_conf.bssid = zero_addr;\r\n}\r\nvoid ieee80211_mesh_teardown_sdata(struct ieee80211_sub_if_data *sdata)\r\n{\r\nmesh_rmc_free(sdata);\r\nmesh_pathtbl_unregister(sdata);\r\n}
