static ssize_t\r\nqla2x00_sysfs_read_fw_dump(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = 0;\r\nif (!(ha->fw_dump_reading || ha->mctp_dump_reading))\r\nreturn 0;\r\nif (IS_P3P_TYPE(ha)) {\r\nif (off < ha->md_template_size) {\r\nrval = memory_read_from_buffer(buf, count,\r\n&off, ha->md_tmplt_hdr, ha->md_template_size);\r\nreturn rval;\r\n}\r\noff -= ha->md_template_size;\r\nrval = memory_read_from_buffer(buf, count,\r\n&off, ha->md_dump, ha->md_dump_size);\r\nreturn rval;\r\n} else if (ha->mctp_dumped && ha->mctp_dump_reading)\r\nreturn memory_read_from_buffer(buf, count, &off, ha->mctp_dump,\r\nMCTP_DUMP_SIZE);\r\nelse if (ha->fw_dump_reading)\r\nreturn memory_read_from_buffer(buf, count, &off, ha->fw_dump,\r\nha->fw_dump_len);\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_write_fw_dump(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nint reading;\r\nif (off != 0)\r\nreturn (0);\r\nreading = simple_strtol(buf, NULL, 10);\r\nswitch (reading) {\r\ncase 0:\r\nif (!ha->fw_dump_reading)\r\nbreak;\r\nql_log(ql_log_info, vha, 0x705d,\r\n"Firmware dump cleared on (%ld).\n", vha->host_no);\r\nif (IS_P3P_TYPE(ha)) {\r\nqla82xx_md_free(vha);\r\nqla82xx_md_prep(vha);\r\n}\r\nha->fw_dump_reading = 0;\r\nha->fw_dumped = 0;\r\nbreak;\r\ncase 1:\r\nif (ha->fw_dumped && !ha->fw_dump_reading) {\r\nha->fw_dump_reading = 1;\r\nql_log(ql_log_info, vha, 0x705e,\r\n"Raw firmware dump ready for read on (%ld).\n",\r\nvha->host_no);\r\n}\r\nbreak;\r\ncase 2:\r\nqla2x00_alloc_fw_dump(vha);\r\nbreak;\r\ncase 3:\r\nif (IS_QLA82XX(ha)) {\r\nqla82xx_idc_lock(ha);\r\nqla82xx_set_reset_owner(vha);\r\nqla82xx_idc_unlock(ha);\r\n} else if (IS_QLA8044(ha)) {\r\nqla8044_idc_lock(ha);\r\nqla82xx_set_reset_owner(vha);\r\nqla8044_idc_unlock(ha);\r\n} else\r\nqla2x00_system_error(vha);\r\nbreak;\r\ncase 4:\r\nif (IS_P3P_TYPE(ha)) {\r\nif (ha->md_tmplt_hdr)\r\nql_dbg(ql_dbg_user, vha, 0x705b,\r\n"MiniDump supported with this firmware.\n");\r\nelse\r\nql_dbg(ql_dbg_user, vha, 0x709d,\r\n"MiniDump not supported with this firmware.\n");\r\n}\r\nbreak;\r\ncase 5:\r\nif (IS_P3P_TYPE(ha))\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\ncase 6:\r\nif (!ha->mctp_dump_reading)\r\nbreak;\r\nql_log(ql_log_info, vha, 0x70c1,\r\n"MCTP dump cleared on (%ld).\n", vha->host_no);\r\nha->mctp_dump_reading = 0;\r\nha->mctp_dumped = 0;\r\nbreak;\r\ncase 7:\r\nif (ha->mctp_dumped && !ha->mctp_dump_reading) {\r\nha->mctp_dump_reading = 1;\r\nql_log(ql_log_info, vha, 0x70c2,\r\n"Raw mctp dump ready for read on (%ld).\n",\r\nvha->host_no);\r\n}\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_read_nvram(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn 0;\r\nif (IS_NOCACHE_VPD_TYPE(ha))\r\nha->isp_ops->read_optrom(vha, ha->nvram, ha->flt_region_nvram << 2,\r\nha->nvram_size);\r\nreturn memory_read_from_buffer(buf, count, &off, ha->nvram,\r\nha->nvram_size);\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_write_nvram(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t cnt;\r\nif (!capable(CAP_SYS_ADMIN) || off != 0 || count != ha->nvram_size ||\r\n!ha->isp_ops->write_nvram)\r\nreturn -EINVAL;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nuint32_t *iter;\r\nuint32_t chksum;\r\niter = (uint32_t *)buf;\r\nchksum = 0;\r\nfor (cnt = 0; cnt < ((count >> 2) - 1); cnt++, iter++)\r\nchksum += le32_to_cpu(*iter);\r\nchksum = ~chksum + 1;\r\n*iter = cpu_to_le32(chksum);\r\n} else {\r\nuint8_t *iter;\r\nuint8_t chksum;\r\niter = (uint8_t *)buf;\r\nchksum = 0;\r\nfor (cnt = 0; cnt < count - 1; cnt++)\r\nchksum += *iter++;\r\nchksum = ~chksum + 1;\r\n*iter = chksum;\r\n}\r\nif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x705f,\r\n"HBA not online, failing NVRAM update.\n");\r\nreturn -EAGAIN;\r\n}\r\nha->isp_ops->write_nvram(vha, (uint8_t *)buf, ha->nvram_base, count);\r\nha->isp_ops->read_nvram(vha, (uint8_t *)ha->nvram, ha->nvram_base,\r\ncount);\r\nql_dbg(ql_dbg_user, vha, 0x7060,\r\n"Setting ISP_ABORT_NEEDED\n");\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nqla2x00_wait_for_chip_reset(vha);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_read_optrom(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nssize_t rval = 0;\r\nif (ha->optrom_state != QLA_SREADING)\r\nreturn 0;\r\nmutex_lock(&ha->optrom_mutex);\r\nrval = memory_read_from_buffer(buf, count, &off, ha->optrom_buffer,\r\nha->optrom_region_size);\r\nmutex_unlock(&ha->optrom_mutex);\r\nreturn rval;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_write_optrom(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ha->optrom_state != QLA_SWRITING)\r\nreturn -EINVAL;\r\nif (off > ha->optrom_region_size)\r\nreturn -ERANGE;\r\nif (off + count > ha->optrom_region_size)\r\ncount = ha->optrom_region_size - off;\r\nmutex_lock(&ha->optrom_mutex);\r\nmemcpy(&ha->optrom_buffer[off], buf, count);\r\nmutex_unlock(&ha->optrom_mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t start = 0;\r\nuint32_t size = ha->optrom_size;\r\nint val, valid;\r\nssize_t rval = count;\r\nif (off)\r\nreturn -EINVAL;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn -EAGAIN;\r\nif (sscanf(buf, "%d:%x:%x", &val, &start, &size) < 1)\r\nreturn -EINVAL;\r\nif (start > ha->optrom_size)\r\nreturn -EINVAL;\r\nmutex_lock(&ha->optrom_mutex);\r\nswitch (val) {\r\ncase 0:\r\nif (ha->optrom_state != QLA_SREADING &&\r\nha->optrom_state != QLA_SWRITING) {\r\nrval = -EINVAL;\r\ngoto out;\r\n}\r\nha->optrom_state = QLA_SWAITING;\r\nql_dbg(ql_dbg_user, vha, 0x7061,\r\n"Freeing flash region allocation -- 0x%x bytes.\n",\r\nha->optrom_region_size);\r\nvfree(ha->optrom_buffer);\r\nha->optrom_buffer = NULL;\r\nbreak;\r\ncase 1:\r\nif (ha->optrom_state != QLA_SWAITING) {\r\nrval = -EINVAL;\r\ngoto out;\r\n}\r\nha->optrom_region_start = start;\r\nha->optrom_region_size = start + size > ha->optrom_size ?\r\nha->optrom_size - start : size;\r\nha->optrom_state = QLA_SREADING;\r\nha->optrom_buffer = vmalloc(ha->optrom_region_size);\r\nif (ha->optrom_buffer == NULL) {\r\nql_log(ql_log_warn, vha, 0x7062,\r\n"Unable to allocate memory for optrom retrieval "\r\n"(%x).\n", ha->optrom_region_size);\r\nha->optrom_state = QLA_SWAITING;\r\nrval = -ENOMEM;\r\ngoto out;\r\n}\r\nif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7063,\r\n"HBA not online, failing NVRAM update.\n");\r\nrval = -EAGAIN;\r\ngoto out;\r\n}\r\nql_dbg(ql_dbg_user, vha, 0x7064,\r\n"Reading flash region -- 0x%x/0x%x.\n",\r\nha->optrom_region_start, ha->optrom_region_size);\r\nmemset(ha->optrom_buffer, 0, ha->optrom_region_size);\r\nha->isp_ops->read_optrom(vha, ha->optrom_buffer,\r\nha->optrom_region_start, ha->optrom_region_size);\r\nbreak;\r\ncase 2:\r\nif (ha->optrom_state != QLA_SWAITING) {\r\nrval = -EINVAL;\r\ngoto out;\r\n}\r\nvalid = 0;\r\nif (ha->optrom_size == OPTROM_SIZE_2300 && start == 0)\r\nvalid = 1;\r\nelse if (start == (ha->flt_region_boot * 4) ||\r\nstart == (ha->flt_region_fw * 4))\r\nvalid = 1;\r\nelse if (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha)\r\n|| IS_CNA_CAPABLE(ha) || IS_QLA2031(ha)\r\n|| IS_QLA27XX(ha))\r\nvalid = 1;\r\nif (!valid) {\r\nql_log(ql_log_warn, vha, 0x7065,\r\n"Invalid start region 0x%x/0x%x.\n", start, size);\r\nrval = -EINVAL;\r\ngoto out;\r\n}\r\nha->optrom_region_start = start;\r\nha->optrom_region_size = start + size > ha->optrom_size ?\r\nha->optrom_size - start : size;\r\nha->optrom_state = QLA_SWRITING;\r\nha->optrom_buffer = vmalloc(ha->optrom_region_size);\r\nif (ha->optrom_buffer == NULL) {\r\nql_log(ql_log_warn, vha, 0x7066,\r\n"Unable to allocate memory for optrom update "\r\n"(%x)\n", ha->optrom_region_size);\r\nha->optrom_state = QLA_SWAITING;\r\nrval = -ENOMEM;\r\ngoto out;\r\n}\r\nql_dbg(ql_dbg_user, vha, 0x7067,\r\n"Staging flash region write -- 0x%x/0x%x.\n",\r\nha->optrom_region_start, ha->optrom_region_size);\r\nmemset(ha->optrom_buffer, 0, ha->optrom_region_size);\r\nbreak;\r\ncase 3:\r\nif (ha->optrom_state != QLA_SWRITING) {\r\nrval = -EINVAL;\r\ngoto out;\r\n}\r\nif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7068,\r\n"HBA not online, failing flash update.\n");\r\nrval = -EAGAIN;\r\ngoto out;\r\n}\r\nql_dbg(ql_dbg_user, vha, 0x7069,\r\n"Writing flash region -- 0x%x/0x%x.\n",\r\nha->optrom_region_start, ha->optrom_region_size);\r\nha->isp_ops->write_optrom(vha, ha->optrom_buffer,\r\nha->optrom_region_start, ha->optrom_region_size);\r\nbreak;\r\ndefault:\r\nrval = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&ha->optrom_mutex);\r\nreturn rval;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_read_vpd(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t faddr;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn -EAGAIN;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EINVAL;\r\nif (IS_NOCACHE_VPD_TYPE(ha)) {\r\nfaddr = ha->flt_region_vpd << 2;\r\nif (IS_QLA27XX(ha) &&\r\nqla27xx_find_valid_image(vha) == QLA27XX_SECONDARY_IMAGE)\r\nfaddr = ha->flt_region_vpd_sec << 2;\r\nha->isp_ops->read_optrom(vha, ha->vpd, faddr,\r\nha->vpd_size);\r\n}\r\nreturn memory_read_from_buffer(buf, count, &off, ha->vpd, ha->vpd_size);\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_write_vpd(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint8_t *tmp_data;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn 0;\r\nif (!capable(CAP_SYS_ADMIN) || off != 0 || count != ha->vpd_size ||\r\n!ha->isp_ops->write_nvram)\r\nreturn 0;\r\nif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x706a,\r\n"HBA not online, failing VPD update.\n");\r\nreturn -EAGAIN;\r\n}\r\nha->isp_ops->write_nvram(vha, (uint8_t *)buf, ha->vpd_base, count);\r\nha->isp_ops->read_nvram(vha, (uint8_t *)ha->vpd, ha->vpd_base, count);\r\nif (!IS_FWI2_CAPABLE(ha))\r\nreturn -EINVAL;\r\ntmp_data = vmalloc(256);\r\nif (!tmp_data) {\r\nql_log(ql_log_warn, vha, 0x706b,\r\n"Unable to allocate memory for VPD information update.\n");\r\nreturn -ENOMEM;\r\n}\r\nha->isp_ops->get_flash_version(vha, tmp_data);\r\nvfree(tmp_data);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_read_sfp(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t iter, addr, offset;\r\nint rval;\r\nif (!capable(CAP_SYS_ADMIN) || off != 0 || count != SFP_DEV_SIZE * 2)\r\nreturn 0;\r\nif (ha->sfp_data)\r\ngoto do_read;\r\nha->sfp_data = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,\r\n&ha->sfp_data_dma);\r\nif (!ha->sfp_data) {\r\nql_log(ql_log_warn, vha, 0x706c,\r\n"Unable to allocate memory for SFP read-data.\n");\r\nreturn 0;\r\n}\r\ndo_read:\r\nmemset(ha->sfp_data, 0, SFP_BLOCK_SIZE);\r\naddr = 0xa0;\r\nfor (iter = 0, offset = 0; iter < (SFP_DEV_SIZE * 2) / SFP_BLOCK_SIZE;\r\niter++, offset += SFP_BLOCK_SIZE) {\r\nif (iter == 4) {\r\naddr = 0xa2;\r\noffset = 0;\r\n}\r\nrval = qla2x00_read_sfp(vha, ha->sfp_data_dma, ha->sfp_data,\r\naddr, offset, SFP_BLOCK_SIZE, BIT_1);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x706d,\r\n"Unable to read SFP data (%x/%x/%x).\n", rval,\r\naddr, offset);\r\nreturn -EIO;\r\n}\r\nmemcpy(buf, ha->sfp_data, SFP_BLOCK_SIZE);\r\nbuf += SFP_BLOCK_SIZE;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_write_reset(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nint type;\r\nuint32_t idc_control;\r\nuint8_t *tmp_data = NULL;\r\nif (off != 0)\r\nreturn -EINVAL;\r\ntype = simple_strtol(buf, NULL, 10);\r\nswitch (type) {\r\ncase 0x2025c:\r\nql_log(ql_log_info, vha, 0x706e,\r\n"Issuing ISP reset.\n");\r\nscsi_block_requests(vha->host);\r\nif (IS_QLA82XX(ha)) {\r\nha->flags.isp82xx_no_md_cap = 1;\r\nqla82xx_idc_lock(ha);\r\nqla82xx_set_reset_owner(vha);\r\nqla82xx_idc_unlock(ha);\r\n} else if (IS_QLA8044(ha)) {\r\nqla8044_idc_lock(ha);\r\nidc_control = qla8044_rd_reg(ha,\r\nQLA8044_IDC_DRV_CTRL);\r\nqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL,\r\n(idc_control | GRACEFUL_RESET_BIT1));\r\nqla82xx_set_reset_owner(vha);\r\nqla8044_idc_unlock(ha);\r\n} else {\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n}\r\nqla2x00_wait_for_chip_reset(vha);\r\nscsi_unblock_requests(vha->host);\r\nbreak;\r\ncase 0x2025d:\r\nif (!IS_QLA81XX(ha) && !IS_QLA83XX(ha))\r\nreturn -EPERM;\r\nql_log(ql_log_info, vha, 0x706f,\r\n"Issuing MPI reset.\n");\r\nif (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {\r\nuint32_t idc_control;\r\nqla83xx_idc_lock(vha, 0);\r\n__qla83xx_get_idc_control(vha, &idc_control);\r\nidc_control |= QLA83XX_IDC_GRACEFUL_RESET;\r\n__qla83xx_set_idc_control(vha, idc_control);\r\nqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE,\r\nQLA8XXX_DEV_NEED_RESET);\r\nqla83xx_idc_audit(vha, IDC_AUDIT_TIMESTAMP);\r\nqla83xx_idc_unlock(vha, 0);\r\nbreak;\r\n} else {\r\nqla2x00_wait_for_hba_online(vha);\r\nscsi_block_requests(vha->host);\r\nif (qla81xx_restart_mpi_firmware(vha) != QLA_SUCCESS)\r\nql_log(ql_log_warn, vha, 0x7070,\r\n"MPI reset failed.\n");\r\nscsi_unblock_requests(vha->host);\r\nbreak;\r\n}\r\ncase 0x2025e:\r\nif (!IS_P3P_TYPE(ha) || vha != base_vha) {\r\nql_log(ql_log_info, vha, 0x7071,\r\n"FCoE ctx reset no supported.\n");\r\nreturn -EPERM;\r\n}\r\nql_log(ql_log_info, vha, 0x7072,\r\n"Issuing FCoE ctx reset.\n");\r\nset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nqla2x00_wait_for_fcoe_ctx_reset(vha);\r\nbreak;\r\ncase 0x2025f:\r\nif (!IS_QLA8031(ha))\r\nreturn -EPERM;\r\nql_log(ql_log_info, vha, 0x70bc,\r\n"Disabling Reset by IDC control\n");\r\nqla83xx_idc_lock(vha, 0);\r\n__qla83xx_get_idc_control(vha, &idc_control);\r\nidc_control |= QLA83XX_IDC_RESET_DISABLED;\r\n__qla83xx_set_idc_control(vha, idc_control);\r\nqla83xx_idc_unlock(vha, 0);\r\nbreak;\r\ncase 0x20260:\r\nif (!IS_QLA8031(ha))\r\nreturn -EPERM;\r\nql_log(ql_log_info, vha, 0x70bd,\r\n"Enabling Reset by IDC control\n");\r\nqla83xx_idc_lock(vha, 0);\r\n__qla83xx_get_idc_control(vha, &idc_control);\r\nidc_control &= ~QLA83XX_IDC_RESET_DISABLED;\r\n__qla83xx_set_idc_control(vha, idc_control);\r\nqla83xx_idc_unlock(vha, 0);\r\nbreak;\r\ncase 0x20261:\r\nql_dbg(ql_dbg_user, vha, 0x70e0,\r\n"Updating cache versions without reset ");\r\ntmp_data = vmalloc(256);\r\nif (!tmp_data) {\r\nql_log(ql_log_warn, vha, 0x70e1,\r\n"Unable to allocate memory for VPD information update.\n");\r\nreturn -ENOMEM;\r\n}\r\nha->isp_ops->get_flash_version(vha, tmp_data);\r\nvfree(tmp_data);\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_issue_logo(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nint type;\r\nint rval = 0;\r\nport_id_t did;\r\ntype = simple_strtol(buf, NULL, 10);\r\ndid.b.domain = (type & 0x00ff0000) >> 16;\r\ndid.b.area = (type & 0x0000ff00) >> 8;\r\ndid.b.al_pa = (type & 0x000000ff);\r\nql_log(ql_log_info, vha, 0x70e3, "portid=%02x%02x%02x done\n",\r\ndid.b.domain, did.b.area, did.b.al_pa);\r\nql_log(ql_log_info, vha, 0x70e4, "%s: %d\n", __func__, type);\r\nrval = qla24xx_els_dcmd_iocb(vha, ELS_DCMD_LOGO, did);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_read_xgmac_stats(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval;\r\nuint16_t actual_size;\r\nif (!capable(CAP_SYS_ADMIN) || off != 0 || count > XGMAC_DATA_SIZE)\r\nreturn 0;\r\nif (ha->xgmac_data)\r\ngoto do_read;\r\nha->xgmac_data = dma_alloc_coherent(&ha->pdev->dev, XGMAC_DATA_SIZE,\r\n&ha->xgmac_data_dma, GFP_KERNEL);\r\nif (!ha->xgmac_data) {\r\nql_log(ql_log_warn, vha, 0x7076,\r\n"Unable to allocate memory for XGMAC read-data.\n");\r\nreturn 0;\r\n}\r\ndo_read:\r\nactual_size = 0;\r\nmemset(ha->xgmac_data, 0, XGMAC_DATA_SIZE);\r\nrval = qla2x00_get_xgmac_stats(vha, ha->xgmac_data_dma,\r\nXGMAC_DATA_SIZE, &actual_size);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7077,\r\n"Unable to read XGMAC data (%x).\n", rval);\r\ncount = 0;\r\n}\r\ncount = actual_size > count ? count: actual_size;\r\nmemcpy(buf, ha->xgmac_data, count);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_sysfs_read_dcbx_tlv(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval;\r\nif (!capable(CAP_SYS_ADMIN) || off != 0 || count > DCBX_TLV_DATA_SIZE)\r\nreturn 0;\r\nif (ha->dcbx_tlv)\r\ngoto do_read;\r\nha->dcbx_tlv = dma_alloc_coherent(&ha->pdev->dev, DCBX_TLV_DATA_SIZE,\r\n&ha->dcbx_tlv_dma, GFP_KERNEL);\r\nif (!ha->dcbx_tlv) {\r\nql_log(ql_log_warn, vha, 0x7078,\r\n"Unable to allocate memory for DCBX TLV read-data.\n");\r\nreturn -ENOMEM;\r\n}\r\ndo_read:\r\nmemset(ha->dcbx_tlv, 0, DCBX_TLV_DATA_SIZE);\r\nrval = qla2x00_get_dcbx_params(vha, ha->dcbx_tlv_dma,\r\nDCBX_TLV_DATA_SIZE);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7079,\r\n"Unable to read DCBX TLV (%x).\n", rval);\r\nreturn -EIO;\r\n}\r\nmemcpy(buf, ha->dcbx_tlv, count);\r\nreturn count;\r\n}\r\nvoid\r\nqla2x00_alloc_sysfs_attr(scsi_qla_host_t *vha)\r\n{\r\nstruct Scsi_Host *host = vha->host;\r\nstruct sysfs_entry *iter;\r\nint ret;\r\nfor (iter = bin_file_entries; iter->name; iter++) {\r\nif (iter->is4GBp_only && !IS_FWI2_CAPABLE(vha->hw))\r\ncontinue;\r\nif (iter->is4GBp_only == 2 && !IS_QLA25XX(vha->hw))\r\ncontinue;\r\nif (iter->is4GBp_only == 3 && !(IS_CNA_CAPABLE(vha->hw)))\r\ncontinue;\r\nret = sysfs_create_bin_file(&host->shost_gendev.kobj,\r\niter->attr);\r\nif (ret)\r\nql_log(ql_log_warn, vha, 0x00f3,\r\n"Unable to create sysfs %s binary attribute (%d).\n",\r\niter->name, ret);\r\nelse\r\nql_dbg(ql_dbg_init, vha, 0x00f4,\r\n"Successfully created sysfs %s binary attribure.\n",\r\niter->name);\r\n}\r\n}\r\nvoid\r\nqla2x00_free_sysfs_attr(scsi_qla_host_t *vha, bool stop_beacon)\r\n{\r\nstruct Scsi_Host *host = vha->host;\r\nstruct sysfs_entry *iter;\r\nstruct qla_hw_data *ha = vha->hw;\r\nfor (iter = bin_file_entries; iter->name; iter++) {\r\nif (iter->is4GBp_only && !IS_FWI2_CAPABLE(ha))\r\ncontinue;\r\nif (iter->is4GBp_only == 2 && !IS_QLA25XX(ha))\r\ncontinue;\r\nif (iter->is4GBp_only == 3 && !(IS_CNA_CAPABLE(vha->hw)))\r\ncontinue;\r\nif (iter->is4GBp_only == 0x27 && !IS_QLA27XX(vha->hw))\r\ncontinue;\r\nsysfs_remove_bin_file(&host->shost_gendev.kobj,\r\niter->attr);\r\n}\r\nif (stop_beacon && ha->beacon_blink_led == 1)\r\nha->isp_ops->beacon_off(vha);\r\n}\r\nstatic ssize_t\r\nqla2x00_drvr_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", qla2x00_version_str);\r\n}\r\nstatic ssize_t\r\nqla2x00_fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nchar fw_str[128];\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n",\r\nha->isp_ops->fw_version_str(vha, fw_str, sizeof(fw_str)));\r\n}\r\nstatic ssize_t\r\nqla2x00_serial_num_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t sn;\r\nif (IS_QLAFX00(vha->hw)) {\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n",\r\nvha->hw->mr.serial_num);\r\n} else if (IS_FWI2_CAPABLE(ha)) {\r\nqla2xxx_get_vpd_field(vha, "SN", buf, PAGE_SIZE - 1);\r\nreturn strlen(strcat(buf, "\n"));\r\n}\r\nsn = ((ha->serial0 & 0x1f) << 16) | (ha->serial2 << 8) | ha->serial1;\r\nreturn scnprintf(buf, PAGE_SIZE, "%c%05d\n", 'A' + sn / 100000,\r\nsn % 100000);\r\n}\r\nstatic ssize_t\r\nqla2x00_isp_name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nreturn scnprintf(buf, PAGE_SIZE, "ISP%04X\n", vha->hw->pdev->device);\r\n}\r\nstatic ssize_t\r\nqla2x00_isp_id_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLAFX00(vha->hw))\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n",\r\nvha->hw->mr.hw_version);\r\nreturn scnprintf(buf, PAGE_SIZE, "%04x %04x %04x %04x\n",\r\nha->product_id[0], ha->product_id[1], ha->product_id[2],\r\nha->product_id[3]);\r\n}\r\nstatic ssize_t\r\nqla2x00_model_name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", vha->hw->model_number);\r\n}\r\nstatic ssize_t\r\nqla2x00_model_desc_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", vha->hw->model_desc);\r\n}\r\nstatic ssize_t\r\nqla2x00_pci_info_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nchar pci_info[30];\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n",\r\nvha->hw->isp_ops->pci_info_str(vha, pci_info));\r\n}\r\nstatic ssize_t\r\nqla2x00_link_state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nint len = 0;\r\nif (atomic_read(&vha->loop_state) == LOOP_DOWN ||\r\natomic_read(&vha->loop_state) == LOOP_DEAD ||\r\nvha->device_flags & DFLG_NO_CABLE)\r\nlen = scnprintf(buf, PAGE_SIZE, "Link Down\n");\r\nelse if (atomic_read(&vha->loop_state) != LOOP_READY ||\r\nqla2x00_reset_active(vha))\r\nlen = scnprintf(buf, PAGE_SIZE, "Unknown Link State\n");\r\nelse {\r\nlen = scnprintf(buf, PAGE_SIZE, "Link Up - ");\r\nswitch (ha->current_topology) {\r\ncase ISP_CFG_NL:\r\nlen += scnprintf(buf + len, PAGE_SIZE-len, "Loop\n");\r\nbreak;\r\ncase ISP_CFG_FL:\r\nlen += scnprintf(buf + len, PAGE_SIZE-len, "FL_Port\n");\r\nbreak;\r\ncase ISP_CFG_N:\r\nlen += scnprintf(buf + len, PAGE_SIZE-len,\r\n"N_Port to N_Port\n");\r\nbreak;\r\ncase ISP_CFG_F:\r\nlen += scnprintf(buf + len, PAGE_SIZE-len, "F_Port\n");\r\nbreak;\r\ndefault:\r\nlen += scnprintf(buf + len, PAGE_SIZE-len, "Loop\n");\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nqla2x00_zio_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nint len = 0;\r\nswitch (vha->hw->zio_mode) {\r\ncase QLA_ZIO_MODE_6:\r\nlen += scnprintf(buf + len, PAGE_SIZE-len, "Mode 6\n");\r\nbreak;\r\ncase QLA_ZIO_DISABLED:\r\nlen += scnprintf(buf + len, PAGE_SIZE-len, "Disabled\n");\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nqla2x00_zio_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nint val = 0;\r\nuint16_t zio_mode;\r\nif (!IS_ZIO_SUPPORTED(ha))\r\nreturn -ENOTSUPP;\r\nif (sscanf(buf, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nif (val)\r\nzio_mode = QLA_ZIO_MODE_6;\r\nelse\r\nzio_mode = QLA_ZIO_DISABLED;\r\nif (zio_mode != QLA_ZIO_DISABLED || ha->zio_mode != QLA_ZIO_DISABLED) {\r\nha->zio_mode = zio_mode;\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\n}\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nqla2x00_zio_timer_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nreturn scnprintf(buf, PAGE_SIZE, "%d us\n", vha->hw->zio_timer * 100);\r\n}\r\nstatic ssize_t\r\nqla2x00_zio_timer_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nint val = 0;\r\nuint16_t zio_timer;\r\nif (sscanf(buf, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nif (val > 25500 || val < 100)\r\nreturn -ERANGE;\r\nzio_timer = (uint16_t)(val / 100);\r\nvha->hw->zio_timer = zio_timer;\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nqla2x00_beacon_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nint len = 0;\r\nif (vha->hw->beacon_blink_led)\r\nlen += scnprintf(buf + len, PAGE_SIZE-len, "Enabled\n");\r\nelse\r\nlen += scnprintf(buf + len, PAGE_SIZE-len, "Disabled\n");\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nqla2x00_beacon_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nint val = 0;\r\nint rval;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nreturn -EPERM;\r\nif (test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)) {\r\nql_log(ql_log_warn, vha, 0x707a,\r\n"Abort ISP active -- ignoring beacon request.\n");\r\nreturn -EBUSY;\r\n}\r\nif (sscanf(buf, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nif (val)\r\nrval = ha->isp_ops->beacon_on(vha);\r\nelse\r\nrval = ha->isp_ops->beacon_off(vha);\r\nif (rval != QLA_SUCCESS)\r\ncount = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nqla2x00_optrom_bios_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d.%02d\n", ha->bios_revision[1],\r\nha->bios_revision[0]);\r\n}\r\nstatic ssize_t\r\nqla2x00_optrom_efi_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d.%02d\n", ha->efi_revision[1],\r\nha->efi_revision[0]);\r\n}\r\nstatic ssize_t\r\nqla2x00_optrom_fcode_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d.%02d\n", ha->fcode_revision[1],\r\nha->fcode_revision[0]);\r\n}\r\nstatic ssize_t\r\nqla2x00_optrom_fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d.%02d.%02d %d\n",\r\nha->fw_revision[0], ha->fw_revision[1], ha->fw_revision[2],\r\nha->fw_revision[3]);\r\n}\r\nstatic ssize_t\r\nqla2x00_optrom_gold_fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA81XX(ha) && !IS_QLA83XX(ha) && !IS_QLA27XX(ha))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "%d.%02d.%02d (%d)\n",\r\nha->gold_fw_version[0], ha->gold_fw_version[1],\r\nha->gold_fw_version[2], ha->gold_fw_version[3]);\r\n}\r\nstatic ssize_t\r\nqla2x00_total_isp_aborts_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n",\r\nvha->qla_stats.total_isp_aborts);\r\n}\r\nstatic ssize_t\r\nqla24xx_84xx_fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint rval = QLA_SUCCESS;\r\nuint16_t status[2] = {0, 0};\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA84XX(ha))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nif (ha->cs84xx->op_fw_version == 0)\r\nrval = qla84xx_verify_chip(vha, status);\r\nif ((rval == QLA_SUCCESS) && (status[0] == 0))\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n",\r\n(uint32_t)ha->cs84xx->op_fw_version);\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\n}\r\nstatic ssize_t\r\nqla2x00_mpi_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA81XX(ha) && !IS_QLA8031(ha) && !IS_QLA8044(ha) &&\r\n!IS_QLA27XX(ha))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "%d.%02d.%02d (%x)\n",\r\nha->mpi_version[0], ha->mpi_version[1], ha->mpi_version[2],\r\nha->mpi_capabilities);\r\n}\r\nstatic ssize_t\r\nqla2x00_phy_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA81XX(ha) && !IS_QLA8031(ha))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "%d.%02d.%02d\n",\r\nha->phy_version[0], ha->phy_version[1], ha->phy_version[2]);\r\n}\r\nstatic ssize_t\r\nqla2x00_flash_block_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x\n", ha->fdt_block_size);\r\n}\r\nstatic ssize_t\r\nqla2x00_vlan_id_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nif (!IS_CNA_CAPABLE(vha->hw))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", vha->fcoe_vlan_id);\r\n}\r\nstatic ssize_t\r\nqla2x00_vn_port_mac_address_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nif (!IS_CNA_CAPABLE(vha->hw))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "%pMR\n", vha->fcoe_vn_port_mac);\r\n}\r\nstatic ssize_t\r\nqla2x00_fabric_param_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", vha->hw->switch_cap);\r\n}\r\nstatic ssize_t\r\nqla2x00_thermal_temp_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nuint16_t temp = 0;\r\nif (qla2x00_reset_active(vha)) {\r\nql_log(ql_log_warn, vha, 0x70dc, "ISP reset active.\n");\r\ngoto done;\r\n}\r\nif (vha->hw->flags.eeh_busy) {\r\nql_log(ql_log_warn, vha, 0x70dd, "PCI EEH busy.\n");\r\ngoto done;\r\n}\r\nif (qla2x00_get_thermal_temp(vha, &temp) == QLA_SUCCESS)\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", temp);\r\ndone:\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\n}\r\nstatic ssize_t\r\nqla2x00_fw_state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nint rval = QLA_FUNCTION_FAILED;\r\nuint16_t state[6];\r\nuint32_t pstate;\r\nif (IS_QLAFX00(vha->hw)) {\r\npstate = qlafx00_fw_state_show(dev, attr, buf);\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x\n", pstate);\r\n}\r\nif (qla2x00_reset_active(vha))\r\nql_log(ql_log_warn, vha, 0x707c,\r\n"ISP reset active.\n");\r\nelse if (!vha->hw->flags.eeh_busy)\r\nrval = qla2x00_get_firmware_state(vha, state);\r\nif (rval != QLA_SUCCESS)\r\nmemset(state, -1, sizeof(state));\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",\r\nstate[0], state[1], state[2], state[3], state[4], state[5]);\r\n}\r\nstatic ssize_t\r\nqla2x00_diag_requests_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nif (!IS_BIDI_CAPABLE(vha->hw))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "%llu\n", vha->bidi_stats.io_count);\r\n}\r\nstatic ssize_t\r\nqla2x00_diag_megabytes_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nif (!IS_BIDI_CAPABLE(vha->hw))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "%llu\n",\r\nvha->bidi_stats.transfer_bytes >> 20);\r\n}\r\nstatic ssize_t\r\nqla2x00_fw_dump_size_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t size;\r\nif (!ha->fw_dumped)\r\nsize = 0;\r\nelse if (IS_P3P_TYPE(ha))\r\nsize = ha->md_template_size + ha->md_dump_size;\r\nelse\r\nsize = ha->fw_dump_len;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", size);\r\n}\r\nstatic ssize_t\r\nqla2x00_allow_cna_fw_dump_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nif (!IS_P3P_TYPE(vha->hw))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nelse\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n",\r\nvha->hw->allow_cna_fw_dump ? "true" : "false");\r\n}\r\nstatic ssize_t\r\nqla2x00_allow_cna_fw_dump_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nint val = 0;\r\nif (!IS_P3P_TYPE(vha->hw))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nvha->hw->allow_cna_fw_dump = val != 0;\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nqla2x00_pep_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA27XX(ha))\r\nreturn scnprintf(buf, PAGE_SIZE, "\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "%d.%02d.%02d\n",\r\nha->pep_version[0], ha->pep_version[1], ha->pep_version[2]);\r\n}\r\nstatic void\r\nqla2x00_get_host_port_id(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nfc_host_port_id(shost) = vha->d_id.b.domain << 16 |\r\nvha->d_id.b.area << 8 | vha->d_id.b.al_pa;\r\n}\r\nstatic void\r\nqla2x00_get_host_speed(struct Scsi_Host *shost)\r\n{\r\nstruct qla_hw_data *ha = ((struct scsi_qla_host *)\r\n(shost_priv(shost)))->hw;\r\nu32 speed = FC_PORTSPEED_UNKNOWN;\r\nif (IS_QLAFX00(ha)) {\r\nqlafx00_get_host_speed(shost);\r\nreturn;\r\n}\r\nswitch (ha->link_data_rate) {\r\ncase PORT_SPEED_1GB:\r\nspeed = FC_PORTSPEED_1GBIT;\r\nbreak;\r\ncase PORT_SPEED_2GB:\r\nspeed = FC_PORTSPEED_2GBIT;\r\nbreak;\r\ncase PORT_SPEED_4GB:\r\nspeed = FC_PORTSPEED_4GBIT;\r\nbreak;\r\ncase PORT_SPEED_8GB:\r\nspeed = FC_PORTSPEED_8GBIT;\r\nbreak;\r\ncase PORT_SPEED_10GB:\r\nspeed = FC_PORTSPEED_10GBIT;\r\nbreak;\r\ncase PORT_SPEED_16GB:\r\nspeed = FC_PORTSPEED_16GBIT;\r\nbreak;\r\ncase PORT_SPEED_32GB:\r\nspeed = FC_PORTSPEED_32GBIT;\r\nbreak;\r\n}\r\nfc_host_speed(shost) = speed;\r\n}\r\nstatic void\r\nqla2x00_get_host_port_type(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nuint32_t port_type = FC_PORTTYPE_UNKNOWN;\r\nif (vha->vp_idx) {\r\nfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\r\nreturn;\r\n}\r\nswitch (vha->hw->current_topology) {\r\ncase ISP_CFG_NL:\r\nport_type = FC_PORTTYPE_LPORT;\r\nbreak;\r\ncase ISP_CFG_FL:\r\nport_type = FC_PORTTYPE_NLPORT;\r\nbreak;\r\ncase ISP_CFG_N:\r\nport_type = FC_PORTTYPE_PTP;\r\nbreak;\r\ncase ISP_CFG_F:\r\nport_type = FC_PORTTYPE_NPORT;\r\nbreak;\r\n}\r\nfc_host_port_type(shost) = port_type;\r\n}\r\nstatic void\r\nqla2x00_get_starget_node_name(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *host = dev_to_shost(starget->dev.parent);\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nfc_port_t *fcport;\r\nu64 node_name = 0;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (fcport->rport &&\r\nstarget->id == fcport->rport->scsi_target_id) {\r\nnode_name = wwn_to_u64(fcport->node_name);\r\nbreak;\r\n}\r\n}\r\nfc_starget_node_name(starget) = node_name;\r\n}\r\nstatic void\r\nqla2x00_get_starget_port_name(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *host = dev_to_shost(starget->dev.parent);\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nfc_port_t *fcport;\r\nu64 port_name = 0;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (fcport->rport &&\r\nstarget->id == fcport->rport->scsi_target_id) {\r\nport_name = wwn_to_u64(fcport->port_name);\r\nbreak;\r\n}\r\n}\r\nfc_starget_port_name(starget) = port_name;\r\n}\r\nstatic void\r\nqla2x00_get_starget_port_id(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *host = dev_to_shost(starget->dev.parent);\r\nscsi_qla_host_t *vha = shost_priv(host);\r\nfc_port_t *fcport;\r\nuint32_t port_id = ~0U;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (fcport->rport &&\r\nstarget->id == fcport->rport->scsi_target_id) {\r\nport_id = fcport->d_id.b.domain << 16 |\r\nfcport->d_id.b.area << 8 | fcport->d_id.b.al_pa;\r\nbreak;\r\n}\r\n}\r\nfc_starget_port_id(starget) = port_id;\r\n}\r\nstatic void\r\nqla2x00_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\r\n{\r\nif (timeout)\r\nrport->dev_loss_tmo = timeout;\r\nelse\r\nrport->dev_loss_tmo = 1;\r\n}\r\nstatic void\r\nqla2x00_dev_loss_tmo_callbk(struct fc_rport *rport)\r\n{\r\nstruct Scsi_Host *host = rport_to_shost(rport);\r\nfc_port_t *fcport = *(fc_port_t **)rport->dd_data;\r\nunsigned long flags;\r\nif (!fcport)\r\nreturn;\r\nqla2x00_set_fcport_state(fcport, FCS_DEVICE_DEAD);\r\nspin_lock_irqsave(host->host_lock, flags);\r\nfcport->rport = fcport->drport = NULL;\r\n*((fc_port_t **)rport->dd_data) = NULL;\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nif (test_bit(ABORT_ISP_ACTIVE, &fcport->vha->dpc_flags))\r\nreturn;\r\nif (unlikely(pci_channel_offline(fcport->vha->hw->pdev))) {\r\nqla2x00_abort_all_cmds(fcport->vha, DID_NO_CONNECT << 16);\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nqla2x00_terminate_rport_io(struct fc_rport *rport)\r\n{\r\nfc_port_t *fcport = *(fc_port_t **)rport->dd_data;\r\nif (!fcport)\r\nreturn;\r\nif (test_bit(UNLOADING, &fcport->vha->dpc_flags))\r\nreturn;\r\nif (test_bit(ABORT_ISP_ACTIVE, &fcport->vha->dpc_flags))\r\nreturn;\r\nif (unlikely(pci_channel_offline(fcport->vha->hw->pdev))) {\r\nqla2x00_abort_all_cmds(fcport->vha, DID_NO_CONNECT << 16);\r\nreturn;\r\n}\r\nif (fcport->loop_id != FC_NO_LOOP_ID) {\r\nif (IS_FWI2_CAPABLE(fcport->vha->hw))\r\nfcport->vha->hw->isp_ops->fabric_logout(fcport->vha,\r\nfcport->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nelse\r\nqla2x00_port_logout(fcport->vha, fcport);\r\n}\r\n}\r\nstatic int\r\nqla2x00_issue_lip(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nif (IS_QLAFX00(vha->hw))\r\nreturn 0;\r\nqla2x00_loop_reset(vha);\r\nreturn 0;\r\n}\r\nstatic struct fc_host_statistics *\r\nqla2x00_get_fc_host_stats(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nint rval;\r\nstruct link_statistics *stats;\r\ndma_addr_t stats_dma;\r\nstruct fc_host_statistics *p = &vha->fc_host_stat;\r\nmemset(p, -1, sizeof(*p));\r\nif (IS_QLAFX00(vha->hw))\r\ngoto done;\r\nif (test_bit(UNLOADING, &vha->dpc_flags))\r\ngoto done;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto done;\r\nif (qla2x00_reset_active(vha))\r\ngoto done;\r\nstats = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(*stats), &stats_dma, GFP_KERNEL);\r\nif (!stats) {\r\nql_log(ql_log_warn, vha, 0x707d,\r\n"Failed to allocate memory for stats.\n");\r\ngoto done;\r\n}\r\nmemset(stats, 0, sizeof(*stats));\r\nrval = QLA_FUNCTION_FAILED;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nrval = qla24xx_get_isp_stats(base_vha, stats, stats_dma, 0);\r\n} else if (atomic_read(&base_vha->loop_state) == LOOP_READY &&\r\n!ha->dpc_active) {\r\nrval = qla2x00_get_link_status(base_vha, base_vha->loop_id,\r\nstats, stats_dma);\r\n}\r\nif (rval != QLA_SUCCESS)\r\ngoto done_free;\r\np->link_failure_count = stats->link_fail_cnt;\r\np->loss_of_sync_count = stats->loss_sync_cnt;\r\np->loss_of_signal_count = stats->loss_sig_cnt;\r\np->prim_seq_protocol_err_count = stats->prim_seq_err_cnt;\r\np->invalid_tx_word_count = stats->inval_xmit_word_cnt;\r\np->invalid_crc_count = stats->inval_crc_cnt;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\np->lip_count = stats->lip_cnt;\r\np->tx_frames = stats->tx_frames;\r\np->rx_frames = stats->rx_frames;\r\np->dumped_frames = stats->discarded_frames;\r\np->nos_count = stats->nos_rcvd;\r\np->error_frames =\r\nstats->dropped_frames + stats->discarded_frames;\r\np->rx_words = vha->qla_stats.input_bytes;\r\np->tx_words = vha->qla_stats.output_bytes;\r\n}\r\np->fcp_control_requests = vha->qla_stats.control_requests;\r\np->fcp_input_requests = vha->qla_stats.input_requests;\r\np->fcp_output_requests = vha->qla_stats.output_requests;\r\np->fcp_input_megabytes = vha->qla_stats.input_bytes >> 20;\r\np->fcp_output_megabytes = vha->qla_stats.output_bytes >> 20;\r\np->seconds_since_last_reset =\r\nget_jiffies_64() - vha->qla_stats.jiffies_at_last_reset;\r\ndo_div(p->seconds_since_last_reset, HZ);\r\ndone_free:\r\ndma_free_coherent(&ha->pdev->dev, sizeof(struct link_statistics),\r\nstats, stats_dma);\r\ndone:\r\nreturn p;\r\n}\r\nstatic void\r\nqla2x00_reset_host_stats(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nstruct link_statistics *stats;\r\ndma_addr_t stats_dma;\r\nmemset(&vha->qla_stats, 0, sizeof(vha->qla_stats));\r\nmemset(&vha->fc_host_stat, 0, sizeof(vha->fc_host_stat));\r\nvha->qla_stats.jiffies_at_last_reset = get_jiffies_64();\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nstats = dma_alloc_coherent(&ha->pdev->dev,\r\nsizeof(*stats), &stats_dma, GFP_KERNEL);\r\nif (!stats) {\r\nql_log(ql_log_warn, vha, 0x70d7,\r\n"Failed to allocate memory for stats.\n");\r\nreturn;\r\n}\r\nqla24xx_get_isp_stats(base_vha, stats, stats_dma, BIT_0);\r\ndma_free_coherent(&ha->pdev->dev, sizeof(*stats),\r\nstats, stats_dma);\r\n}\r\n}\r\nstatic void\r\nqla2x00_get_host_symbolic_name(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nqla2x00_get_sym_node_name(vha, fc_host_symbolic_name(shost),\r\nsizeof(fc_host_symbolic_name(shost)));\r\n}\r\nstatic void\r\nqla2x00_set_host_system_hostname(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nset_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);\r\n}\r\nstatic void\r\nqla2x00_get_host_fabric_name(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nuint8_t node_name[WWN_SIZE] = { 0xFF, 0xFF, 0xFF, 0xFF, \\r\n0xFF, 0xFF, 0xFF, 0xFF};\r\nu64 fabric_name = wwn_to_u64(node_name);\r\nif (vha->device_flags & SWITCH_FOUND)\r\nfabric_name = wwn_to_u64(vha->fabric_node_name);\r\nfc_host_fabric_name(shost) = fabric_name;\r\n}\r\nstatic void\r\nqla2x00_get_host_port_state(struct Scsi_Host *shost)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(shost);\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(vha->hw->pdev);\r\nif (!base_vha->flags.online) {\r\nfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\r\nreturn;\r\n}\r\nswitch (atomic_read(&base_vha->loop_state)) {\r\ncase LOOP_UPDATE:\r\nfc_host_port_state(shost) = FC_PORTSTATE_DIAGNOSTICS;\r\nbreak;\r\ncase LOOP_DOWN:\r\nif (test_bit(LOOP_RESYNC_NEEDED, &base_vha->dpc_flags))\r\nfc_host_port_state(shost) = FC_PORTSTATE_DIAGNOSTICS;\r\nelse\r\nfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\r\nbreak;\r\ncase LOOP_DEAD:\r\nfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\r\nbreak;\r\ncase LOOP_READY:\r\nfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\r\nbreak;\r\ndefault:\r\nfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nqla24xx_vport_create(struct fc_vport *fc_vport, bool disable)\r\n{\r\nint ret = 0;\r\nuint8_t qos = 0;\r\nscsi_qla_host_t *base_vha = shost_priv(fc_vport->shost);\r\nscsi_qla_host_t *vha = NULL;\r\nstruct qla_hw_data *ha = base_vha->hw;\r\nuint16_t options = 0;\r\nint cnt;\r\nstruct req_que *req = ha->req_q_map[0];\r\nret = qla24xx_vport_create_req_sanity_check(fc_vport);\r\nif (ret) {\r\nql_log(ql_log_warn, vha, 0x707e,\r\n"Vport sanity check failed, status %x\n", ret);\r\nreturn (ret);\r\n}\r\nvha = qla24xx_create_vhost(fc_vport);\r\nif (vha == NULL) {\r\nql_log(ql_log_warn, vha, 0x707f, "Vport create host failed.\n");\r\nreturn FC_VPORT_FAILED;\r\n}\r\nif (disable) {\r\natomic_set(&vha->vp_state, VP_OFFLINE);\r\nfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\r\n} else\r\natomic_set(&vha->vp_state, VP_FAILED);\r\nql_log(ql_log_info, vha, 0x7080,\r\n"VP entry id %d assigned.\n", vha->vp_idx);\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\nvha->vp_err_state= VP_ERR_PORTDWN;\r\nvha->vp_prev_err_state= VP_ERR_UNKWN;\r\nif (atomic_read(&base_vha->loop_state) == LOOP_DOWN ||\r\natomic_read(&base_vha->loop_state) == LOOP_DEAD) {\r\nql_dbg(ql_dbg_user, vha, 0x7081,\r\n"Vport loop state is not UP.\n");\r\natomic_set(&vha->loop_state, LOOP_DEAD);\r\nif (!disable)\r\nfc_vport_set_state(fc_vport, FC_VPORT_LINKDOWN);\r\n}\r\nif (IS_T10_PI_CAPABLE(ha) && ql2xenabledif) {\r\nif (ha->fw_attributes & BIT_4) {\r\nint prot = 0, guard;\r\nvha->flags.difdix_supported = 1;\r\nql_dbg(ql_dbg_user, vha, 0x7082,\r\n"Registered for DIF/DIX type 1 and 3 protection.\n");\r\nif (ql2xenabledif == 1)\r\nprot = SHOST_DIX_TYPE0_PROTECTION;\r\nscsi_host_set_prot(vha->host,\r\nprot | SHOST_DIF_TYPE1_PROTECTION\r\n| SHOST_DIF_TYPE2_PROTECTION\r\n| SHOST_DIF_TYPE3_PROTECTION\r\n| SHOST_DIX_TYPE1_PROTECTION\r\n| SHOST_DIX_TYPE2_PROTECTION\r\n| SHOST_DIX_TYPE3_PROTECTION);\r\nguard = SHOST_DIX_GUARD_CRC;\r\nif (IS_PI_IPGUARD_CAPABLE(ha) &&\r\n(ql2xenabledif > 1 || IS_PI_DIFB_DIX0_CAPABLE(ha)))\r\nguard |= SHOST_DIX_GUARD_IP;\r\nscsi_host_set_guard(vha->host, guard);\r\n} else\r\nvha->flags.difdix_supported = 0;\r\n}\r\nif (scsi_add_host_with_dma(vha->host, &fc_vport->dev,\r\n&ha->pdev->dev)) {\r\nql_dbg(ql_dbg_user, vha, 0x7083,\r\n"scsi_add_host failure for VP[%d].\n", vha->vp_idx);\r\ngoto vport_create_failed_2;\r\n}\r\nfc_host_dev_loss_tmo(vha->host) = ha->port_down_retry_count;\r\nfc_host_node_name(vha->host) = wwn_to_u64(vha->node_name);\r\nfc_host_port_name(vha->host) = wwn_to_u64(vha->port_name);\r\nfc_host_supported_classes(vha->host) =\r\nfc_host_supported_classes(base_vha->host);\r\nfc_host_supported_speeds(vha->host) =\r\nfc_host_supported_speeds(base_vha->host);\r\nqlt_vport_create(vha, ha);\r\nqla24xx_vport_disable(fc_vport, disable);\r\nif (ha->flags.cpu_affinity_enabled) {\r\nreq = ha->req_q_map[1];\r\nql_dbg(ql_dbg_multiq, vha, 0xc000,\r\n"Request queue %p attached with "\r\n"VP[%d], cpu affinity =%d\n",\r\nreq, vha->vp_idx, ha->flags.cpu_affinity_enabled);\r\ngoto vport_queue;\r\n} else if (ql2xmaxqueues == 1 || !ha->npiv_info)\r\ngoto vport_queue;\r\nfor (cnt = 0; cnt < ha->nvram_npiv_size; cnt++) {\r\nif (memcmp(ha->npiv_info[cnt].port_name, vha->port_name, 8) == 0\r\n&& memcmp(ha->npiv_info[cnt].node_name, vha->node_name,\r\n8) == 0) {\r\nqos = ha->npiv_info[cnt].q_qos;\r\nbreak;\r\n}\r\n}\r\nif (qos) {\r\nret = qla25xx_create_req_que(ha, options, vha->vp_idx, 0, 0,\r\nqos);\r\nif (!ret)\r\nql_log(ql_log_warn, vha, 0x7084,\r\n"Can't create request queue for VP[%d]\n",\r\nvha->vp_idx);\r\nelse {\r\nql_dbg(ql_dbg_multiq, vha, 0xc001,\r\n"Request Que:%d Q0s: %d) created for VP[%d]\n",\r\nret, qos, vha->vp_idx);\r\nql_dbg(ql_dbg_user, vha, 0x7085,\r\n"Request Que:%d Q0s: %d) created for VP[%d]\n",\r\nret, qos, vha->vp_idx);\r\nreq = ha->req_q_map[ret];\r\n}\r\n}\r\nvport_queue:\r\nvha->req = req;\r\nreturn 0;\r\nvport_create_failed_2:\r\nqla24xx_disable_vp(vha);\r\nqla24xx_deallocate_vp_id(vha);\r\nscsi_host_put(vha->host);\r\nreturn FC_VPORT_FAILED;\r\n}\r\nstatic int\r\nqla24xx_vport_delete(struct fc_vport *fc_vport)\r\n{\r\nscsi_qla_host_t *vha = fc_vport->dd_data;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t id = vha->vp_idx;\r\nwhile (test_bit(LOOP_RESYNC_ACTIVE, &vha->dpc_flags) ||\r\ntest_bit(FCPORT_UPDATE_NEEDED, &vha->dpc_flags))\r\nmsleep(1000);\r\nqla24xx_disable_vp(vha);\r\nvha->flags.delete_progress = 1;\r\nqlt_remove_target(ha, vha);\r\nfc_remove_host(vha->host);\r\nscsi_remove_host(vha->host);\r\nqla24xx_deallocate_vp_id(vha);\r\nif (vha->timer_active) {\r\nqla2x00_vp_stop_timer(vha);\r\nql_dbg(ql_dbg_user, vha, 0x7086,\r\n"Timer for the VP[%d] has stopped\n", vha->vp_idx);\r\n}\r\nBUG_ON(atomic_read(&vha->vref_count));\r\nqla2x00_free_fcports(vha);\r\nmutex_lock(&ha->vport_lock);\r\nha->cur_vport_count--;\r\nclear_bit(vha->vp_idx, ha->vp_idx_map);\r\nmutex_unlock(&ha->vport_lock);\r\nif (vha->req->id && !ha->flags.cpu_affinity_enabled) {\r\nif (qla25xx_delete_req_que(vha, vha->req) != QLA_SUCCESS)\r\nql_log(ql_log_warn, vha, 0x7087,\r\n"Queue delete failed.\n");\r\n}\r\nql_log(ql_log_info, vha, 0x7088, "VP[%d] deleted.\n", id);\r\nscsi_host_put(vha->host);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla24xx_vport_disable(struct fc_vport *fc_vport, bool disable)\r\n{\r\nscsi_qla_host_t *vha = fc_vport->dd_data;\r\nif (disable)\r\nqla24xx_disable_vp(vha);\r\nelse\r\nqla24xx_enable_vp(vha);\r\nreturn 0;\r\n}\r\nvoid\r\nqla2x00_init_host_attr(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nu32 speed = FC_PORTSPEED_UNKNOWN;\r\nfc_host_dev_loss_tmo(vha->host) = ha->port_down_retry_count;\r\nfc_host_node_name(vha->host) = wwn_to_u64(vha->node_name);\r\nfc_host_port_name(vha->host) = wwn_to_u64(vha->port_name);\r\nfc_host_supported_classes(vha->host) = ha->tgt.enable_class_2 ?\r\n(FC_COS_CLASS2|FC_COS_CLASS3) : FC_COS_CLASS3;\r\nfc_host_max_npiv_vports(vha->host) = ha->max_npiv_vports;\r\nfc_host_npiv_vports_inuse(vha->host) = ha->cur_vport_count;\r\nif (IS_CNA_CAPABLE(ha))\r\nspeed = FC_PORTSPEED_10GBIT;\r\nelse if (IS_QLA2031(ha))\r\nspeed = FC_PORTSPEED_16GBIT | FC_PORTSPEED_8GBIT |\r\nFC_PORTSPEED_4GBIT;\r\nelse if (IS_QLA25XX(ha))\r\nspeed = FC_PORTSPEED_8GBIT | FC_PORTSPEED_4GBIT |\r\nFC_PORTSPEED_2GBIT | FC_PORTSPEED_1GBIT;\r\nelse if (IS_QLA24XX_TYPE(ha))\r\nspeed = FC_PORTSPEED_4GBIT | FC_PORTSPEED_2GBIT |\r\nFC_PORTSPEED_1GBIT;\r\nelse if (IS_QLA23XX(ha))\r\nspeed = FC_PORTSPEED_2GBIT | FC_PORTSPEED_1GBIT;\r\nelse if (IS_QLAFX00(ha))\r\nspeed = FC_PORTSPEED_8GBIT | FC_PORTSPEED_4GBIT |\r\nFC_PORTSPEED_2GBIT | FC_PORTSPEED_1GBIT;\r\nelse if (IS_QLA27XX(ha))\r\nspeed = FC_PORTSPEED_32GBIT | FC_PORTSPEED_16GBIT |\r\nFC_PORTSPEED_8GBIT;\r\nelse\r\nspeed = FC_PORTSPEED_1GBIT;\r\nfc_host_supported_speeds(vha->host) = speed;\r\n}
