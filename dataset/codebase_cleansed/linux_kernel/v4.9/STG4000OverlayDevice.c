void ResetOverlayRegisters(volatile STG4000REG __iomem *pSTGReg)\r\n{\r\nu32 tmp;\r\ntmp = STG_READ_REG(DACOverlayAddr);\r\nCLEAR_BITS_FRM_TO(0, 20);\r\nCLEAR_BIT(31);\r\nSTG_WRITE_REG(DACOverlayAddr, tmp);\r\ntmp = STG_READ_REG(DACOverlayUAddr);\r\nCLEAR_BITS_FRM_TO(0, 20);\r\nSTG_WRITE_REG(DACOverlayUAddr, tmp);\r\ntmp = STG_READ_REG(DACOverlayVAddr);\r\nCLEAR_BITS_FRM_TO(0, 20);\r\nSTG_WRITE_REG(DACOverlayVAddr, tmp);\r\ntmp = STG_READ_REG(DACOverlaySize);\r\nCLEAR_BITS_FRM_TO(0, 10);\r\nCLEAR_BITS_FRM_TO(12, 31);\r\nSTG_WRITE_REG(DACOverlaySize, tmp);\r\ntmp = STG4000_NO_DECIMATION;\r\nSTG_WRITE_REG(DACOverlayVtDec, tmp);\r\ntmp = STG_READ_REG(DACPixelFormat);\r\nCLEAR_BITS_FRM_TO(4, 7);\r\nCLEAR_BITS_FRM_TO(16, 22);\r\nSTG_WRITE_REG(DACPixelFormat, tmp);\r\ntmp = STG_READ_REG(DACVerticalScal);\r\nCLEAR_BITS_FRM_TO(0, 11);\r\nCLEAR_BITS_FRM_TO(16, 22);\r\ntmp |= STG4000_NO_SCALING;\r\nSTG_WRITE_REG(DACVerticalScal, tmp);\r\ntmp = STG_READ_REG(DACHorizontalScal);\r\nCLEAR_BITS_FRM_TO(0, 11);\r\nCLEAR_BITS_FRM_TO(16, 17);\r\ntmp |= STG4000_NO_SCALING;\r\nSTG_WRITE_REG(DACHorizontalScal, tmp);\r\ntmp = STG_READ_REG(DACBlendCtrl);\r\nCLEAR_BITS_FRM_TO(0, 30);\r\ntmp = (GRAPHICS_MODE << 28);\r\nSTG_WRITE_REG(DACBlendCtrl, tmp);\r\n}\r\nint CreateOverlaySurface(volatile STG4000REG __iomem *pSTGReg,\r\nu32 inWidth,\r\nu32 inHeight,\r\nint bLinear,\r\nu32 ulOverlayOffset,\r\nu32 * retStride, u32 * retUVStride)\r\n{\r\nu32 tmp;\r\nu32 ulStride;\r\nif (inWidth > STG4000_OVRL_MAX_WIDTH ||\r\ninHeight > STG4000_OVRL_MAX_HEIGHT) {\r\nreturn -EINVAL;\r\n}\r\nif (bLinear) {\r\nif ((inWidth & 0x7) == 0) {\r\nulStride = (inWidth / 8);\r\n} else {\r\nulStride = ((inWidth + 8) / 8);\r\n}\r\n} else {\r\nif ((inWidth & 0xf) == 0) {\r\nulStride = (inWidth / 16);\r\n} else {\r\nulStride = ((inWidth + 16) / 16);\r\n}\r\n}\r\ntmp = STG_READ_REG(DACOverlayAddr);\r\nCLEAR_BITS_FRM_TO(0, 20);\r\nif (bLinear) {\r\nCLEAR_BIT(31);\r\n} else {\r\ntmp |= SET_BIT(31);\r\n}\r\ntmp |= (ulOverlayOffset >> 4);\r\nSTG_WRITE_REG(DACOverlayAddr, tmp);\r\nif (!bLinear) {\r\nu32 uvSize =\r\n(inWidth & 0x1) ? (inWidth + 1 / 2) : (inWidth / 2);\r\nu32 uvStride;\r\nu32 ulOffset;\r\nif ((uvSize & 0xf) == 0) {\r\nuvStride = (uvSize / 16);\r\n} else {\r\nuvStride = ((uvSize + 16) / 16);\r\n}\r\nulOffset = ulOverlayOffset + (inHeight * (ulStride * 16));\r\nif ((ulOffset & 0x1f) != 0)\r\nulOffset = (ulOffset + 32L) & 0xffffffE0L;\r\ntmp = STG_READ_REG(DACOverlayUAddr);\r\nCLEAR_BITS_FRM_TO(0, 20);\r\ntmp |= (ulOffset >> 4);\r\nSTG_WRITE_REG(DACOverlayUAddr, tmp);\r\nulOffset += (inHeight / 2) * (uvStride * 16);\r\nif ((ulOffset & 0x1f) != 0)\r\nulOffset = (ulOffset + 32L) & 0xffffffE0L;\r\ntmp = STG_READ_REG(DACOverlayVAddr);\r\nCLEAR_BITS_FRM_TO(0, 20);\r\ntmp |= (ulOffset >> 4);\r\nSTG_WRITE_REG(DACOverlayVAddr, tmp);\r\n*retUVStride = uvStride * 16;\r\n}\r\ntmp = STG_READ_REG(DACPixelFormat);\r\nCLEAR_BITS_FRM_TO(4, 9);\r\nSTG_WRITE_REG(DACPixelFormat, tmp);\r\novlWidth = inWidth;\r\novlHeight = inHeight;\r\novlStride = ulStride;\r\novlLinear = bLinear;\r\n*retStride = ulStride << 4;\r\nreturn 0;\r\n}\r\nint SetOverlayBlendMode(volatile STG4000REG __iomem *pSTGReg,\r\nOVRL_BLEND_MODE mode,\r\nu32 ulAlpha, u32 ulColorKey)\r\n{\r\nu32 tmp;\r\ntmp = STG_READ_REG(DACBlendCtrl);\r\nCLEAR_BITS_FRM_TO(28, 30);\r\ntmp |= (mode << 28);\r\nswitch (mode) {\r\ncase COLOR_KEY:\r\nCLEAR_BITS_FRM_TO(0, 23);\r\ntmp |= (ulColorKey & 0x00FFFFFF);\r\nbreak;\r\ncase GLOBAL_ALPHA:\r\nCLEAR_BITS_FRM_TO(24, 27);\r\ntmp |= ((ulAlpha & 0xF) << 24);\r\nbreak;\r\ncase CK_PIXEL_ALPHA:\r\nCLEAR_BITS_FRM_TO(0, 23);\r\ntmp |= (ulColorKey & 0x00FFFFFF);\r\nbreak;\r\ncase CK_GLOBAL_ALPHA:\r\nCLEAR_BITS_FRM_TO(0, 23);\r\ntmp |= (ulColorKey & 0x00FFFFFF);\r\nCLEAR_BITS_FRM_TO(24, 27);\r\ntmp |= ((ulAlpha & 0xF) << 24);\r\nbreak;\r\ncase GRAPHICS_MODE:\r\ncase PER_PIXEL_ALPHA:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nSTG_WRITE_REG(DACBlendCtrl, tmp);\r\nreturn 0;\r\n}\r\nvoid EnableOverlayPlane(volatile STG4000REG __iomem *pSTGReg)\r\n{\r\nu32 tmp;\r\ntmp = STG_READ_REG(DACPixelFormat);\r\ntmp |= SET_BIT(7);\r\nSTG_WRITE_REG(DACPixelFormat, tmp);\r\ntmp = STG_READ_REG(DACStreamCtrl);\r\ntmp |= SET_BIT(1);\r\nSTG_WRITE_REG(DACStreamCtrl, tmp);\r\n}\r\nstatic u32 Overlap(u32 ulBits, u32 ulPattern)\r\n{\r\nu32 ulCount = 0;\r\nwhile (ulBits) {\r\nif (!(ulPattern & 1))\r\nulCount++;\r\nulBits--;\r\nulPattern = ulPattern >> 1;\r\n}\r\nreturn ulCount;\r\n}\r\nint SetOverlayViewPort(volatile STG4000REG __iomem *pSTGReg,\r\nu32 left, u32 top,\r\nu32 right, u32 bottom)\r\n{\r\nOVRL_SRC_DEST srcDest;\r\nu32 ulSrcTop, ulSrcBottom;\r\nu32 ulSrc, ulDest;\r\nu32 ulFxScale, ulFxOffset;\r\nu32 ulHeight, ulWidth;\r\nu32 ulPattern;\r\nu32 ulDecimate, ulDecimated;\r\nu32 ulApplied;\r\nu32 ulDacXScale, ulDacYScale;\r\nu32 ulScale;\r\nu32 ulLeft, ulRight;\r\nu32 ulSrcLeft, ulSrcRight;\r\nu32 ulScaleLeft, ulScaleRight;\r\nu32 ulhDecim;\r\nu32 ulsVal;\r\nu32 ulVertDecFactor;\r\nint bResult;\r\nu32 ulClipOff = 0;\r\nu32 ulBits = 0;\r\nu32 ulsAdd = 0;\r\nu32 tmp, ulStride;\r\nu32 ulExcessPixels, ulClip, ulExtraLines;\r\nsrcDest.ulSrcX1 = 0;\r\nsrcDest.ulSrcY1 = 0;\r\nsrcDest.ulSrcX2 = ovlWidth - 1;\r\nsrcDest.ulSrcY2 = ovlHeight - 1;\r\nsrcDest.ulDstX1 = left;\r\nsrcDest.ulDstY1 = top;\r\nsrcDest.ulDstX2 = right;\r\nsrcDest.ulDstY2 = bottom;\r\nsrcDest.lDstX1 = srcDest.ulDstX1;\r\nsrcDest.lDstY1 = srcDest.ulDstY1;\r\nsrcDest.lDstX2 = srcDest.ulDstX2;\r\nsrcDest.lDstY2 = srcDest.ulDstY2;\r\nulSrcTop = srcDest.ulSrcY1;\r\nulSrcBottom = srcDest.ulSrcY2;\r\nulSrc = ulSrcBottom - ulSrcTop;\r\nulDest = srcDest.lDstY2 - srcDest.lDstY1;\r\nif (ulSrc <= 1)\r\nreturn -EINVAL;\r\nulFxScale = (ulDest << 11) / ulSrc;\r\nulFxOffset = (srcDest.lDstY2 - srcDest.ulDstY2) << 11;\r\nulSrcBottom = ulSrcBottom - (ulFxOffset / ulFxScale);\r\nulSrc = ulSrcBottom - ulSrcTop;\r\nulHeight = ulSrc;\r\nulDest = srcDest.ulDstY2 - (srcDest.ulDstY1 - 1);\r\nulPattern = adwDecim8[ulBits];\r\nif (ulSrc > ulDest) {\r\nulDecimate = ulSrc - ulDest;\r\nulBits = 0;\r\nulApplied = ulSrc / 32;\r\nwhile (((ulBits * ulApplied) +\r\nOverlap((ulSrc % 32),\r\nadwDecim8[ulBits])) < ulDecimate)\r\nulBits++;\r\nulPattern = adwDecim8[ulBits];\r\nulDecimated =\r\n(ulBits * ulApplied) + Overlap((ulSrc % 32),\r\nulPattern);\r\nulSrc = ulSrc - ulDecimated;\r\n}\r\nif (ulBits && (ulBits != 32)) {\r\nulVertDecFactor = (63 - ulBits) / (32 - ulBits);\r\n} else {\r\nulVertDecFactor = 1;\r\n}\r\nulDacYScale = ((ulSrc - 1) * 2048) / (ulDest + 1);\r\ntmp = STG_READ_REG(DACOverlayVtDec);\r\nCLEAR_BITS_FRM_TO(0, 31);\r\ntmp = ulPattern;\r\nSTG_WRITE_REG(DACOverlayVtDec, tmp);\r\nulSrc = srcDest.ulSrcX2 - srcDest.ulSrcX1;\r\nulDest = srcDest.lDstX2 - srcDest.lDstX1;\r\n#ifdef _OLDCODE\r\nulLeft = srcDest.ulDstX1;\r\nulRight = srcDest.ulDstX2;\r\n#else\r\nif (srcDest.ulDstX1 > 2) {\r\nulLeft = srcDest.ulDstX1 + 2;\r\nulRight = srcDest.ulDstX2 + 1;\r\n} else {\r\nulLeft = srcDest.ulDstX1;\r\nulRight = srcDest.ulDstX2 + 1;\r\n}\r\n#endif\r\nbResult = 1;\r\ndo {\r\nif (ulDest == 0)\r\nreturn -EINVAL;\r\nulFxScale = ((ulSrc - 1) << 11) / (ulDest);\r\nulFxOffset = ulFxScale * ((srcDest.ulDstX1 - srcDest.lDstX1) + ulClipOff);\r\nulFxOffset >>= 11;\r\nulSrcLeft = srcDest.ulSrcX1 + ulFxOffset;\r\nulFxOffset = ulFxScale * (srcDest.lDstX2 - srcDest.ulDstX2);\r\nulFxOffset >>= 11;\r\nulSrcRight = srcDest.ulSrcX2 - ulFxOffset;\r\nulScaleLeft = ulSrcLeft;\r\nulScaleRight = ulSrcRight;\r\nulhDecim = 0;\r\nulScale = (((ulSrcRight - ulSrcLeft) - 1) << (11 - ulhDecim)) / (ulRight - ulLeft + 2);\r\nwhile (ulScale > 0x800) {\r\nulhDecim++;\r\nulScale = (((ulSrcRight - ulSrcLeft) - 1) << (11 - ulhDecim)) / (ulRight - ulLeft + 2);\r\n}\r\nif (!ovlLinear) {\r\nulSrcLeft &= ~0x1f;\r\nulSrcRight = (ulSrcRight + 0x1f) & ~0x1f;\r\n} else {\r\nulSrcLeft &= ~0x7;\r\nulSrcRight = (ulSrcRight + 0x7) & ~0x7;\r\n}\r\nulWidth = ulSrcRight - ulSrcLeft;\r\nulsVal = ((ulWidth / 8) >> ulhDecim);\r\nif ((ulWidth != (ulsVal << ulhDecim) * 8))\r\nulsAdd = 1;\r\nulSrc = ulWidth >> ulhDecim;\r\nif (ulSrc <= 2)\r\nreturn -EINVAL;\r\nulExcessPixels = ((((ulScaleLeft - ulSrcLeft)) << (11 - ulhDecim)) / ulScale);\r\nulClip = (ulSrc << 11) / ulScale;\r\nulClip -= (ulRight - ulLeft);\r\nulClip += ulExcessPixels;\r\nif (ulClip)\r\nulClip--;\r\n} while (!bResult);\r\nulExtraLines = (1 << ulhDecim) * ulVertDecFactor;\r\nulExtraLines += 64;\r\nulHeight += ulExtraLines;\r\nulDacXScale = ulScale;\r\ntmp = STG_READ_REG(DACVerticalScal);\r\nCLEAR_BITS_FRM_TO(0, 11);\r\nCLEAR_BITS_FRM_TO(16, 22);\r\nulStride = (ulWidth >> (ulhDecim + 3)) + ulsAdd;\r\ntmp |= ((ulStride << 16) | (ulDacYScale));\r\nSTG_WRITE_REG(DACVerticalScal, tmp);\r\ntmp = STG_READ_REG(DACOverlaySize);\r\nCLEAR_BITS_FRM_TO(0, 10);\r\nCLEAR_BITS_FRM_TO(12, 31);\r\nif (ovlLinear) {\r\ntmp |=\r\n(ovlStride | ((ulHeight + 1) << 12) |\r\n(((ulWidth / 8) - 1) << 23));\r\n} else {\r\ntmp |=\r\n(ovlStride | ((ulHeight + 1) << 12) |\r\n(((ulWidth / 32) - 1) << 23));\r\n}\r\nSTG_WRITE_REG(DACOverlaySize, tmp);\r\ntmp = ((ulLeft << 16)) | (srcDest.ulDstY1);\r\nSTG_WRITE_REG(DACVidWinStart, tmp);\r\ntmp = ((ulRight) << 16) | (srcDest.ulDstY2);\r\nSTG_WRITE_REG(DACVidWinEnd, tmp);\r\ntmp = STG_READ_REG(DACPixelFormat);\r\ntmp = ((ulExcessPixels << 16) | tmp) & 0x7fffffff;\r\nSTG_WRITE_REG(DACPixelFormat, tmp);\r\ntmp = STG_READ_REG(DACHorizontalScal);\r\nCLEAR_BITS_FRM_TO(0, 11);\r\nCLEAR_BITS_FRM_TO(16, 17);\r\ntmp |= ((ulhDecim << 16) | (ulDacXScale));\r\nSTG_WRITE_REG(DACHorizontalScal, tmp);\r\nreturn 0;\r\n}
