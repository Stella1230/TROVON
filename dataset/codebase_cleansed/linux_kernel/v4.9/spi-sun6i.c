static inline u32 sun6i_spi_read(struct sun6i_spi *sspi, u32 reg)\r\n{\r\nreturn readl(sspi->base_addr + reg);\r\n}\r\nstatic inline void sun6i_spi_write(struct sun6i_spi *sspi, u32 reg, u32 value)\r\n{\r\nwritel(value, sspi->base_addr + reg);\r\n}\r\nstatic inline void sun6i_spi_drain_fifo(struct sun6i_spi *sspi, int len)\r\n{\r\nu32 reg, cnt;\r\nu8 byte;\r\nreg = sun6i_spi_read(sspi, SUN6I_FIFO_STA_REG);\r\nreg &= SUN6I_FIFO_STA_RF_CNT_MASK;\r\ncnt = reg >> SUN6I_FIFO_STA_RF_CNT_BITS;\r\nif (len > cnt)\r\nlen = cnt;\r\nwhile (len--) {\r\nbyte = readb(sspi->base_addr + SUN6I_RXDATA_REG);\r\nif (sspi->rx_buf)\r\n*sspi->rx_buf++ = byte;\r\n}\r\n}\r\nstatic inline void sun6i_spi_fill_fifo(struct sun6i_spi *sspi, int len)\r\n{\r\nu8 byte;\r\nif (len > sspi->len)\r\nlen = sspi->len;\r\nwhile (len--) {\r\nbyte = sspi->tx_buf ? *sspi->tx_buf++ : 0;\r\nwriteb(byte, sspi->base_addr + SUN6I_TXDATA_REG);\r\nsspi->len--;\r\n}\r\n}\r\nstatic void sun6i_spi_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nstruct sun6i_spi *sspi = spi_master_get_devdata(spi->master);\r\nu32 reg;\r\nreg = sun6i_spi_read(sspi, SUN6I_TFR_CTL_REG);\r\nreg &= ~SUN6I_TFR_CTL_CS_MASK;\r\nreg |= SUN6I_TFR_CTL_CS(spi->chip_select);\r\nif (enable)\r\nreg |= SUN6I_TFR_CTL_CS_LEVEL;\r\nelse\r\nreg &= ~SUN6I_TFR_CTL_CS_LEVEL;\r\nsun6i_spi_write(sspi, SUN6I_TFR_CTL_REG, reg);\r\n}\r\nstatic size_t sun6i_spi_max_transfer_size(struct spi_device *spi)\r\n{\r\nreturn SUN6I_FIFO_DEPTH - 1;\r\n}\r\nstatic int sun6i_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nstruct sun6i_spi *sspi = spi_master_get_devdata(master);\r\nunsigned int mclk_rate, div, timeout;\r\nunsigned int start, end, tx_time;\r\nunsigned int tx_len = 0;\r\nint ret = 0;\r\nu32 reg;\r\nif (tfr->len > SUN6I_FIFO_DEPTH)\r\nreturn -EINVAL;\r\nreinit_completion(&sspi->done);\r\nsspi->tx_buf = tfr->tx_buf;\r\nsspi->rx_buf = tfr->rx_buf;\r\nsspi->len = tfr->len;\r\nsun6i_spi_write(sspi, SUN6I_INT_STA_REG, ~0);\r\nsun6i_spi_write(sspi, SUN6I_FIFO_CTL_REG,\r\nSUN6I_FIFO_CTL_RF_RST | SUN6I_FIFO_CTL_TF_RST);\r\nreg = sun6i_spi_read(sspi, SUN6I_TFR_CTL_REG);\r\nif (spi->mode & SPI_CPOL)\r\nreg |= SUN6I_TFR_CTL_CPOL;\r\nelse\r\nreg &= ~SUN6I_TFR_CTL_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\nreg |= SUN6I_TFR_CTL_CPHA;\r\nelse\r\nreg &= ~SUN6I_TFR_CTL_CPHA;\r\nif (spi->mode & SPI_LSB_FIRST)\r\nreg |= SUN6I_TFR_CTL_FBS;\r\nelse\r\nreg &= ~SUN6I_TFR_CTL_FBS;\r\nif (sspi->rx_buf)\r\nreg &= ~SUN6I_TFR_CTL_DHB;\r\nelse\r\nreg |= SUN6I_TFR_CTL_DHB;\r\nreg |= SUN6I_TFR_CTL_CS_MANUAL;\r\nsun6i_spi_write(sspi, SUN6I_TFR_CTL_REG, reg);\r\nmclk_rate = clk_get_rate(sspi->mclk);\r\nif (mclk_rate < (2 * tfr->speed_hz)) {\r\nclk_set_rate(sspi->mclk, 2 * tfr->speed_hz);\r\nmclk_rate = clk_get_rate(sspi->mclk);\r\n}\r\ndiv = mclk_rate / (2 * tfr->speed_hz);\r\nif (div <= (SUN6I_CLK_CTL_CDR2_MASK + 1)) {\r\nif (div > 0)\r\ndiv--;\r\nreg = SUN6I_CLK_CTL_CDR2(div) | SUN6I_CLK_CTL_DRS;\r\n} else {\r\ndiv = ilog2(mclk_rate) - ilog2(tfr->speed_hz);\r\nreg = SUN6I_CLK_CTL_CDR1(div);\r\n}\r\nsun6i_spi_write(sspi, SUN6I_CLK_CTL_REG, reg);\r\nif (sspi->tx_buf)\r\ntx_len = tfr->len;\r\nsun6i_spi_write(sspi, SUN6I_BURST_CNT_REG, SUN6I_BURST_CNT(tfr->len));\r\nsun6i_spi_write(sspi, SUN6I_XMIT_CNT_REG, SUN6I_XMIT_CNT(tx_len));\r\nsun6i_spi_write(sspi, SUN6I_BURST_CTL_CNT_REG,\r\nSUN6I_BURST_CTL_CNT_STC(tx_len));\r\nsun6i_spi_fill_fifo(sspi, SUN6I_FIFO_DEPTH);\r\nsun6i_spi_write(sspi, SUN6I_INT_CTL_REG, SUN6I_INT_CTL_TC);\r\nreg = sun6i_spi_read(sspi, SUN6I_TFR_CTL_REG);\r\nsun6i_spi_write(sspi, SUN6I_TFR_CTL_REG, reg | SUN6I_TFR_CTL_XCH);\r\ntx_time = max(tfr->len * 8 * 2 / (tfr->speed_hz / 1000), 100U);\r\nstart = jiffies;\r\ntimeout = wait_for_completion_timeout(&sspi->done,\r\nmsecs_to_jiffies(tx_time));\r\nend = jiffies;\r\nif (!timeout) {\r\ndev_warn(&master->dev,\r\n"%s: timeout transferring %u bytes@%iHz for %i(%i)ms",\r\ndev_name(&spi->dev), tfr->len, tfr->speed_hz,\r\njiffies_to_msecs(end - start), tx_time);\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nsun6i_spi_drain_fifo(sspi, SUN6I_FIFO_DEPTH);\r\nout:\r\nsun6i_spi_write(sspi, SUN6I_INT_CTL_REG, 0);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t sun6i_spi_handler(int irq, void *dev_id)\r\n{\r\nstruct sun6i_spi *sspi = dev_id;\r\nu32 status = sun6i_spi_read(sspi, SUN6I_INT_STA_REG);\r\nif (status & SUN6I_INT_CTL_TC) {\r\nsun6i_spi_write(sspi, SUN6I_INT_STA_REG, SUN6I_INT_CTL_TC);\r\ncomplete(&sspi->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int sun6i_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct sun6i_spi *sspi = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(sspi->hclk);\r\nif (ret) {\r\ndev_err(dev, "Couldn't enable AHB clock\n");\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(sspi->mclk);\r\nif (ret) {\r\ndev_err(dev, "Couldn't enable module clock\n");\r\ngoto err;\r\n}\r\nret = reset_control_deassert(sspi->rstc);\r\nif (ret) {\r\ndev_err(dev, "Couldn't deassert the device from reset\n");\r\ngoto err2;\r\n}\r\nsun6i_spi_write(sspi, SUN6I_GBL_CTL_REG,\r\nSUN6I_GBL_CTL_BUS_ENABLE | SUN6I_GBL_CTL_MASTER | SUN6I_GBL_CTL_TP);\r\nreturn 0;\r\nerr2:\r\nclk_disable_unprepare(sspi->mclk);\r\nerr:\r\nclk_disable_unprepare(sspi->hclk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sun6i_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct sun6i_spi *sspi = spi_master_get_devdata(master);\r\nreset_control_assert(sspi->rstc);\r\nclk_disable_unprepare(sspi->mclk);\r\nclk_disable_unprepare(sspi->hclk);\r\nreturn 0;\r\n}\r\nstatic int sun6i_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct sun6i_spi *sspi;\r\nstruct resource *res;\r\nint ret = 0, irq;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct sun6i_spi));\r\nif (!master) {\r\ndev_err(&pdev->dev, "Unable to allocate SPI Master\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nsspi = spi_master_get_devdata(master);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsspi->base_addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(sspi->base_addr)) {\r\nret = PTR_ERR(sspi->base_addr);\r\ngoto err_free_master;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "No spi IRQ specified\n");\r\nret = -ENXIO;\r\ngoto err_free_master;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, sun6i_spi_handler,\r\n0, "sun6i-spi", sspi);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot request IRQ\n");\r\ngoto err_free_master;\r\n}\r\nsspi->master = master;\r\nmaster->max_speed_hz = 100 * 1000 * 1000;\r\nmaster->min_speed_hz = 3 * 1000;\r\nmaster->set_cs = sun6i_spi_set_cs;\r\nmaster->transfer_one = sun6i_spi_transfer_one;\r\nmaster->num_chipselect = 4;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->auto_runtime_pm = true;\r\nmaster->max_transfer_size = sun6i_spi_max_transfer_size;\r\nsspi->hclk = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(sspi->hclk)) {\r\ndev_err(&pdev->dev, "Unable to acquire AHB clock\n");\r\nret = PTR_ERR(sspi->hclk);\r\ngoto err_free_master;\r\n}\r\nsspi->mclk = devm_clk_get(&pdev->dev, "mod");\r\nif (IS_ERR(sspi->mclk)) {\r\ndev_err(&pdev->dev, "Unable to acquire module clock\n");\r\nret = PTR_ERR(sspi->mclk);\r\ngoto err_free_master;\r\n}\r\ninit_completion(&sspi->done);\r\nsspi->rstc = devm_reset_control_get(&pdev->dev, NULL);\r\nif (IS_ERR(sspi->rstc)) {\r\ndev_err(&pdev->dev, "Couldn't get reset controller\n");\r\nret = PTR_ERR(sspi->rstc);\r\ngoto err_free_master;\r\n}\r\nret = sun6i_spi_runtime_resume(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't resume the device\n");\r\ngoto err_free_master;\r\n}\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_idle(&pdev->dev);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot register SPI master\n");\r\ngoto err_pm_disable;\r\n}\r\nreturn 0;\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nsun6i_spi_runtime_suspend(&pdev->dev);\r\nerr_free_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int sun6i_spi_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
