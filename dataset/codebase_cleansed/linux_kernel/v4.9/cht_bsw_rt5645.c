static inline struct snd_soc_dai *cht_get_codec_dai(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &card->rtd_list, list) {\r\nif (!strncmp(rtd->codec_dai->name, CHT_CODEC_DAI,\r\nstrlen(CHT_CODEC_DAI)))\r\nreturn rtd->codec_dai;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int platform_clock_control(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct snd_soc_dai *codec_dai;\r\nint ret;\r\ncodec_dai = cht_get_codec_dai(card);\r\nif (!codec_dai) {\r\ndev_err(card->dev, "Codec dai not found; Unable to set platform clock\n");\r\nreturn -EIO;\r\n}\r\nif (!SND_SOC_DAPM_EVENT_OFF(event))\r\nreturn 0;\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_RCCLK,\r\n0, SND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(card->dev, "can't set codec sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_aif1_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret;\r\nret = snd_soc_dai_set_pll(codec_dai, 0, RT5645_PLL1_S_MCLK,\r\nCHT_PLAT_CLK_3_HZ, params_rate(params) * 512);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec pll: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_PLL1,\r\nparams_rate(params) * 512, SND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_codec_init(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nint ret;\r\nint jack_type;\r\nstruct snd_soc_codec *codec = runtime->codec;\r\nstruct snd_soc_dai *codec_dai = runtime->codec_dai;\r\nstruct cht_mc_private *ctx = snd_soc_card_get_drvdata(runtime->card);\r\nrt5645_sel_asrc_clk_src(codec,\r\nRT5645_DA_STEREO_FILTER |\r\nRT5645_DA_MONO_L_FILTER |\r\nRT5645_DA_MONO_R_FILTER |\r\nRT5645_AD_STEREO_FILTER,\r\nRT5645_CLK_SEL_I2S1_ASRC);\r\nret = snd_soc_dai_set_tdm_slot(codec_dai, 0xF, 0xF, 4, 24);\r\nif (ret < 0) {\r\ndev_err(runtime->dev, "can't set codec TDM slot %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ctx->acpi_card->codec_type == CODEC_TYPE_RT5650)\r\njack_type = SND_JACK_HEADPHONE | SND_JACK_MICROPHONE |\r\nSND_JACK_BTN_0 | SND_JACK_BTN_1 |\r\nSND_JACK_BTN_2 | SND_JACK_BTN_3;\r\nelse\r\njack_type = SND_JACK_HEADPHONE | SND_JACK_MICROPHONE;\r\nret = snd_soc_card_jack_new(runtime->card, "Headset",\r\njack_type, &ctx->jack,\r\ncht_bsw_jack_pins, ARRAY_SIZE(cht_bsw_jack_pins));\r\nif (ret) {\r\ndev_err(runtime->dev, "Headset jack creation failed %d\n", ret);\r\nreturn ret;\r\n}\r\nrt5645_set_jack_detect(codec, &ctx->jack, &ctx->jack, &ctx->jack);\r\nreturn ret;\r\n}\r\nstatic int cht_codec_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nrate->min = rate->max = 48000;\r\nchannels->min = channels->max = 2;\r\nparams_set_format(params, SNDRV_PCM_FORMAT_S24_LE);\r\nreturn 0;\r\n}\r\nstatic int cht_aif1_startup(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, 48000);\r\n}\r\nstatic int snd_cht_mc_probe(struct platform_device *pdev)\r\n{\r\nint ret_val = 0;\r\nint i;\r\nstruct cht_mc_private *drv;\r\nstruct snd_soc_card *card = snd_soc_cards[0].soc_card;\r\nchar codec_name[16];\r\nstruct sst_acpi_mach *mach;\r\nconst char *i2c_name = NULL;\r\nint dai_index = 0;\r\ndrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_ATOMIC);\r\nif (!drv)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(snd_soc_cards); i++) {\r\nif (acpi_dev_found(snd_soc_cards[i].codec_id)) {\r\ndev_dbg(&pdev->dev,\r\n"found codec %s\n", snd_soc_cards[i].codec_id);\r\ncard = snd_soc_cards[i].soc_card;\r\ndrv->acpi_card = &snd_soc_cards[i];\r\nbreak;\r\n}\r\n}\r\ncard->dev = &pdev->dev;\r\nmach = card->dev->platform_data;\r\nsprintf(codec_name, "i2c-%s:00", drv->acpi_card->codec_id);\r\nfor (i = 0; i < ARRAY_SIZE(cht_dailink); i++)\r\nif (!strcmp(card->dai_link[i].codec_name, "i2c-10EC5645:00")) {\r\ncard->dai_link[i].codec_name = kstrdup(codec_name, GFP_KERNEL);\r\ndai_index = i;\r\n}\r\ni2c_name = sst_acpi_find_name_from_hid(mach->id);\r\nif (i2c_name != NULL) {\r\nsnprintf(cht_rt5640_codec_name, sizeof(cht_rt5640_codec_name),\r\n"%s%s", "i2c-", i2c_name);\r\ncht_dailink[dai_index].codec_name = cht_rt5640_codec_name;\r\n}\r\nsnd_soc_card_set_drvdata(card, drv);\r\nret_val = devm_snd_soc_register_card(&pdev->dev, card);\r\nif (ret_val) {\r\ndev_err(&pdev->dev,\r\n"snd_soc_register_card failed %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nplatform_set_drvdata(pdev, card);\r\nreturn ret_val;\r\n}
