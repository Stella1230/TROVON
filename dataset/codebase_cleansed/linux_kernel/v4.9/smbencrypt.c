static void\r\nstr_to_key(unsigned char *str, unsigned char *key)\r\n{\r\nint i;\r\nkey[0] = str[0] >> 1;\r\nkey[1] = ((str[0] & 0x01) << 6) | (str[1] >> 2);\r\nkey[2] = ((str[1] & 0x03) << 5) | (str[2] >> 3);\r\nkey[3] = ((str[2] & 0x07) << 4) | (str[3] >> 4);\r\nkey[4] = ((str[3] & 0x0F) << 3) | (str[4] >> 5);\r\nkey[5] = ((str[4] & 0x1F) << 2) | (str[5] >> 6);\r\nkey[6] = ((str[5] & 0x3F) << 1) | (str[6] >> 7);\r\nkey[7] = str[6] & 0x7F;\r\nfor (i = 0; i < 8; i++)\r\nkey[i] = (key[i] << 1);\r\n}\r\nstatic int\r\nsmbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\r\n{\r\nint rc;\r\nunsigned char key2[8];\r\nstruct crypto_skcipher *tfm_des;\r\nstruct scatterlist sgin, sgout;\r\nstruct skcipher_request *req;\r\nstr_to_key(key, key2);\r\ntfm_des = crypto_alloc_skcipher("ecb(des)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm_des)) {\r\nrc = PTR_ERR(tfm_des);\r\ncifs_dbg(VFS, "could not allocate des crypto API\n");\r\ngoto smbhash_err;\r\n}\r\nreq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ncifs_dbg(VFS, "could not allocate des crypto API\n");\r\ngoto smbhash_free_skcipher;\r\n}\r\ncrypto_skcipher_setkey(tfm_des, key2, 8);\r\nsg_init_one(&sgin, in, 8);\r\nsg_init_one(&sgout, out, 8);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\r\nrc = crypto_skcipher_encrypt(req);\r\nif (rc)\r\ncifs_dbg(VFS, "could not encrypt crypt key rc: %d\n", rc);\r\nskcipher_request_free(req);\r\nsmbhash_free_skcipher:\r\ncrypto_free_skcipher(tfm_des);\r\nsmbhash_err:\r\nreturn rc;\r\n}\r\nstatic int\r\nE_P16(unsigned char *p14, unsigned char *p16)\r\n{\r\nint rc;\r\nunsigned char sp8[8] =\r\n{ 0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25 };\r\nrc = smbhash(p16, sp8, p14);\r\nif (rc)\r\nreturn rc;\r\nrc = smbhash(p16 + 8, sp8, p14 + 7);\r\nreturn rc;\r\n}\r\nstatic int\r\nE_P24(unsigned char *p21, const unsigned char *c8, unsigned char *p24)\r\n{\r\nint rc;\r\nrc = smbhash(p24, c8, p21);\r\nif (rc)\r\nreturn rc;\r\nrc = smbhash(p24 + 8, c8, p21 + 7);\r\nif (rc)\r\nreturn rc;\r\nrc = smbhash(p24 + 16, c8, p21 + 14);\r\nreturn rc;\r\n}\r\nint\r\nmdfour(unsigned char *md4_hash, unsigned char *link_str, int link_len)\r\n{\r\nint rc;\r\nunsigned int size;\r\nstruct crypto_shash *md4;\r\nstruct sdesc *sdescmd4;\r\nmd4 = crypto_alloc_shash("md4", 0, 0);\r\nif (IS_ERR(md4)) {\r\nrc = PTR_ERR(md4);\r\ncifs_dbg(VFS, "%s: Crypto md4 allocation error %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nsize = sizeof(struct shash_desc) + crypto_shash_descsize(md4);\r\nsdescmd4 = kmalloc(size, GFP_KERNEL);\r\nif (!sdescmd4) {\r\nrc = -ENOMEM;\r\ngoto mdfour_err;\r\n}\r\nsdescmd4->shash.tfm = md4;\r\nsdescmd4->shash.flags = 0x0;\r\nrc = crypto_shash_init(&sdescmd4->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not init md4 shash\n", __func__);\r\ngoto mdfour_err;\r\n}\r\nrc = crypto_shash_update(&sdescmd4->shash, link_str, link_len);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with link_str\n", __func__);\r\ngoto mdfour_err;\r\n}\r\nrc = crypto_shash_final(&sdescmd4->shash, md4_hash);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Could not generate md4 hash\n", __func__);\r\nmdfour_err:\r\ncrypto_free_shash(md4);\r\nkfree(sdescmd4);\r\nreturn rc;\r\n}\r\nint\r\nSMBencrypt(unsigned char *passwd, const unsigned char *c8, unsigned char *p24)\r\n{\r\nint rc;\r\nunsigned char p14[14], p16[16], p21[21];\r\nmemset(p14, '\0', 14);\r\nmemset(p16, '\0', 16);\r\nmemset(p21, '\0', 21);\r\nmemcpy(p14, passwd, 14);\r\nrc = E_P16(p14, p16);\r\nif (rc)\r\nreturn rc;\r\nmemcpy(p21, p16, 16);\r\nrc = E_P24(p21, c8, p24);\r\nreturn rc;\r\n}\r\nint\r\nE_md4hash(const unsigned char *passwd, unsigned char *p16,\r\nconst struct nls_table *codepage)\r\n{\r\nint rc;\r\nint len;\r\n__le16 wpwd[129];\r\nif (passwd)\r\nlen = cifs_strtoUTF16(wpwd, passwd, 128, codepage);\r\nelse {\r\nlen = 0;\r\n*wpwd = 0;\r\n}\r\nrc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));\r\nmemzero_explicit(wpwd, sizeof(wpwd));\r\nreturn rc;\r\n}\r\nint\r\nSMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,\r\nconst struct nls_table *codepage)\r\n{\r\nint rc;\r\nunsigned char p16[16], p21[21];\r\nmemset(p16, '\0', 16);\r\nmemset(p21, '\0', 21);\r\nrc = E_md4hash(passwd, p16, codepage);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s Can't generate NT hash, error: %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nmemcpy(p21, p16, 16);\r\nrc = E_P24(p21, c8, p24);\r\nreturn rc;\r\n}
