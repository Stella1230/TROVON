static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)\r\n__releases(ohci->lock)\r\n__acquires(ohci->lock)\r\n{\r\nint status = 0;\r\nohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\r\nswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_RESUME:\r\nohci_dbg (ohci, "resume/suspend?\n");\r\nohci->hc_control &= ~OHCI_CTRL_HCFS;\r\nohci->hc_control |= OHCI_USB_RESET;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\ncase OHCI_USB_RESET:\r\nstatus = -EBUSY;\r\nohci_dbg (ohci, "needs reinit!\n");\r\ngoto done;\r\ncase OHCI_USB_SUSPEND:\r\nif (!ohci->autostop) {\r\nohci_dbg (ohci, "already suspended\n");\r\ngoto done;\r\n}\r\n}\r\nohci_dbg (ohci, "%s root hub\n",\r\nautostop ? "auto-stop" : "suspend");\r\nif (!autostop && (ohci->hc_control & OHCI_SCHED_ENABLES)) {\r\nohci->hc_control &= ~OHCI_SCHED_ENABLES;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\nohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\r\nohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrstatus);\r\nohci_dbg (ohci, "stopping schedules ...\n");\r\nohci->autostop = 0;\r\nspin_unlock_irq (&ohci->lock);\r\nmsleep (8);\r\nspin_lock_irq (&ohci->lock);\r\n}\r\nupdate_done_list(ohci);\r\nohci_work(ohci);\r\nif (ohci->flags & OHCI_QUIRK_GLOBAL_SUSPEND) {\r\n__hc32 __iomem *portstat = ohci->regs->roothub.portstatus;\r\nint i;\r\nunsigned temp;\r\nfor (i = 0; i < ohci->num_ports; (++i, ++portstat)) {\r\ntemp = ohci_readl(ohci, portstat);\r\nif ((temp & (RH_PS_PES | RH_PS_PSS)) ==\r\nRH_PS_PES)\r\nohci_writel(ohci, RH_PS_PSS, portstat);\r\n}\r\n}\r\nif (ohci_to_hcd(ohci)->self.root_hub->do_remote_wakeup || autostop) {\r\nohci->hc_control |= OHCI_CTRL_RWE;\r\n} else {\r\nohci_writel(ohci, OHCI_INTR_RHSC | OHCI_INTR_RD,\r\n&ohci->regs->intrdisable);\r\nohci->hc_control &= ~OHCI_CTRL_RWE;\r\n}\r\nohci->hc_control &= ~OHCI_CTRL_HCFS;\r\nohci->hc_control |= OHCI_USB_SUSPEND;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nif (!autostop) {\r\nohci->next_statechange = jiffies + msecs_to_jiffies (5);\r\nohci->autostop = 0;\r\nohci->rh_state = OHCI_RH_SUSPENDED;\r\n}\r\ndone:\r\nreturn status;\r\n}\r\nstatic inline struct ed *find_head (struct ed *ed)\r\n{\r\nwhile (ed->ed_prev)\r\ned = ed->ed_prev;\r\nreturn ed;\r\n}\r\nstatic int ohci_rh_resume (struct ohci_hcd *ohci)\r\n__releases(ohci->lock)\r\n__acquires(ohci->lock)\r\n{\r\nstruct usb_hcd *hcd = ohci_to_hcd (ohci);\r\nu32 temp, enables;\r\nint status = -EINPROGRESS;\r\nint autostopped = ohci->autostop;\r\nohci->autostop = 0;\r\nohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\r\nif (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {\r\nif (ohci->rh_state != OHCI_RH_RUNNING) {\r\nohci_dbg (ohci, "BIOS/SMM active, control %03x\n",\r\nohci->hc_control);\r\nstatus = -EBUSY;\r\n} else {\r\nohci_dbg (ohci, "duplicate resume\n");\r\nstatus = 0;\r\n}\r\n} else switch (ohci->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_SUSPEND:\r\nohci->hc_control &= ~(OHCI_CTRL_HCFS|OHCI_SCHED_ENABLES);\r\nohci->hc_control |= OHCI_USB_RESUME;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nohci_dbg (ohci, "%s root hub\n",\r\nautostopped ? "auto-start" : "resume");\r\nbreak;\r\ncase OHCI_USB_RESUME:\r\nohci_dbg(ohci, "%swakeup root hub\n",\r\nautostopped ? "auto-" : "");\r\nbreak;\r\ncase OHCI_USB_OPER:\r\nohci_dbg (ohci, "snapshot resume? reinit\n");\r\nstatus = -EBUSY;\r\nbreak;\r\ndefault:\r\nohci_dbg (ohci, "lost power\n");\r\nstatus = -EBUSY;\r\n}\r\nif (status == -EBUSY) {\r\nif (!autostopped) {\r\nspin_unlock_irq (&ohci->lock);\r\nstatus = ohci_restart (ohci);\r\nusb_root_hub_lost_power(hcd->self.root_hub);\r\nspin_lock_irq (&ohci->lock);\r\n}\r\nreturn status;\r\n}\r\nif (status != -EINPROGRESS)\r\nreturn status;\r\nif (autostopped)\r\ngoto skip_resume;\r\nspin_unlock_irq (&ohci->lock);\r\nmsleep (20 + 12 + 1);\r\ntemp = ohci_readl (ohci, &ohci->regs->control);\r\ntemp &= OHCI_CTRL_HCFS;\r\nif (temp != OHCI_USB_RESUME) {\r\nohci_err (ohci, "controller won't resume\n");\r\nspin_lock_irq(&ohci->lock);\r\nreturn -EBUSY;\r\n}\r\nohci_writel (ohci, 0, &ohci->regs->ed_controlhead);\r\nohci_writel (ohci, 0, &ohci->regs->ed_controlcurrent);\r\nohci_writel (ohci, 0, &ohci->regs->ed_bulkhead);\r\nohci_writel (ohci, 0, &ohci->regs->ed_bulkcurrent);\r\nohci_writel (ohci, 0, &ohci->regs->ed_periodcurrent);\r\nohci_writel (ohci, (u32) ohci->hcca_dma, &ohci->regs->hcca);\r\nperiodic_reinit (ohci);\r\nskip_resume:\r\nohci_writel (ohci, OHCI_INTR_INIT, &ohci->regs->intrenable);\r\nif (ohci->ed_rm_list)\r\nohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrenable);\r\nohci_writel (ohci, OHCI_USB_OPER, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nif (!autostopped)\r\nmsleep (3);\r\ntemp = ohci->hc_control;\r\ntemp &= OHCI_CTRL_RWC;\r\ntemp |= OHCI_CONTROL_INIT | OHCI_USB_OPER;\r\nohci->hc_control = temp;\r\nohci_writel (ohci, temp, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nif (!autostopped) {\r\nmsleep (10);\r\nspin_lock_irq (&ohci->lock);\r\n}\r\nohci->next_statechange = jiffies + STATECHANGE_DELAY;\r\nenables = 0;\r\ntemp = 0;\r\nif (!ohci->ed_rm_list) {\r\nif (ohci->ed_controltail) {\r\nohci_writel (ohci,\r\nfind_head (ohci->ed_controltail)->dma,\r\n&ohci->regs->ed_controlhead);\r\nenables |= OHCI_CTRL_CLE;\r\ntemp |= OHCI_CLF;\r\n}\r\nif (ohci->ed_bulktail) {\r\nohci_writel (ohci, find_head (ohci->ed_bulktail)->dma,\r\n&ohci->regs->ed_bulkhead);\r\nenables |= OHCI_CTRL_BLE;\r\ntemp |= OHCI_BLF;\r\n}\r\n}\r\nif (hcd->self.bandwidth_isoc_reqs || hcd->self.bandwidth_int_reqs)\r\nenables |= OHCI_CTRL_PLE|OHCI_CTRL_IE;\r\nif (enables) {\r\nohci_dbg (ohci, "restarting schedules ... %08x\n", enables);\r\nohci->hc_control |= enables;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\nif (temp)\r\nohci_writel (ohci, temp, &ohci->regs->cmdstatus);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\n}\r\nohci->rh_state = OHCI_RH_RUNNING;\r\nreturn 0;\r\n}\r\nstatic int ohci_bus_suspend (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint rc;\r\nspin_lock_irq (&ohci->lock);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(hcd)))\r\nrc = -ESHUTDOWN;\r\nelse\r\nrc = ohci_rh_suspend (ohci, 0);\r\nspin_unlock_irq (&ohci->lock);\r\nif (rc == 0)\r\ndel_timer_sync(&ohci->io_watchdog);\r\nreturn rc;\r\n}\r\nstatic int ohci_bus_resume (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint rc;\r\nif (time_before (jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nspin_lock_irq (&ohci->lock);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(hcd)))\r\nrc = -ESHUTDOWN;\r\nelse\r\nrc = ohci_rh_resume (ohci);\r\nspin_unlock_irq (&ohci->lock);\r\nif (rc == 0)\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn rc;\r\n}\r\nstatic int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,\r\nint any_connected, int rhsc_status)\r\n{\r\nint poll_rh = 1;\r\nint rhsc_enable;\r\nrhsc_enable = ohci_readl(ohci, &ohci->regs->intrenable) &\r\nOHCI_INTR_RHSC;\r\nswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_OPER:\r\nif (!rhsc_enable && !rhsc_status && !changed) {\r\nrhsc_enable = OHCI_INTR_RHSC;\r\nohci_writel(ohci, rhsc_enable, &ohci->regs->intrenable);\r\n}\r\nif (!ohci->autostop) {\r\nif (any_connected ||\r\n!device_may_wakeup(&ohci_to_hcd(ohci)\r\n->self.root_hub->dev)) {\r\nif (rhsc_enable)\r\npoll_rh = 0;\r\n} else {\r\nohci->autostop = 1;\r\nohci->next_statechange = jiffies + HZ;\r\n}\r\n} else {\r\nif (changed || any_connected) {\r\nohci->autostop = 0;\r\nohci->next_statechange = jiffies +\r\nSTATECHANGE_DELAY;\r\n} else if (time_after_eq(jiffies,\r\nohci->next_statechange)\r\n&& !ohci->ed_rm_list\r\n&& !(ohci->hc_control &\r\nOHCI_SCHED_ENABLES)) {\r\nohci_rh_suspend(ohci, 1);\r\nif (rhsc_enable)\r\npoll_rh = 0;\r\n}\r\n}\r\nbreak;\r\ncase OHCI_USB_SUSPEND:\r\ncase OHCI_USB_RESUME:\r\nif (changed) {\r\nif (ohci->autostop)\r\nohci_rh_resume(ohci);\r\nelse\r\nusb_hcd_resume_root_hub(ohci_to_hcd(ohci));\r\n} else if (!ohci->autostop &&\r\n!ohci_to_hcd(ohci)->self.root_hub->\r\ndo_remote_wakeup) {\r\npoll_rh = 0;\r\n} else {\r\nif (!rhsc_enable && !rhsc_status) {\r\nrhsc_enable = OHCI_INTR_RHSC;\r\nohci_writel(ohci, rhsc_enable,\r\n&ohci->regs->intrenable);\r\n}\r\nif (rhsc_enable)\r\npoll_rh = 0;\r\n}\r\nbreak;\r\n}\r\nreturn poll_rh;\r\n}\r\nstatic inline int ohci_rh_resume(struct ohci_hcd *ohci)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,\r\nint any_connected, int rhsc_status)\r\n{\r\nif (ohci_readl(ohci, &ohci->regs->intrenable) & OHCI_INTR_RHSC)\r\nreturn 0;\r\nif (changed || rhsc_status)\r\nreturn 1;\r\nohci_writel(ohci, OHCI_INTR_RHSC, &ohci->regs->intrenable);\r\nreturn 0;\r\n}\r\nint ohci_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint i, changed = 0, length = 1;\r\nint any_connected = 0;\r\nint rhsc_status;\r\nunsigned long flags;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\ngoto done;\r\nif ((ohci->flags & OHCI_QUIRK_AMD756)\r\n&& (roothub_a (ohci) & RH_A_NDP) > MAX_ROOT_PORTS) {\r\nohci_warn (ohci, "bogus NDP, rereads as NDP=%d\n",\r\nohci_readl (ohci, &ohci->regs->roothub.a) & RH_A_NDP);\r\ngoto done;\r\n}\r\nif (roothub_status (ohci) & (RH_HS_LPSC | RH_HS_OCIC))\r\nbuf [0] = changed = 1;\r\nelse\r\nbuf [0] = 0;\r\nif (ohci->num_ports > 7) {\r\nbuf [1] = 0;\r\nlength++;\r\n}\r\nohci_writel(ohci, OHCI_INTR_RHSC, &ohci->regs->intrstatus);\r\nrhsc_status = ohci_readl(ohci, &ohci->regs->intrstatus) &\r\nOHCI_INTR_RHSC;\r\nfor (i = 0; i < ohci->num_ports; i++) {\r\nu32 status = roothub_portstatus (ohci, i);\r\nany_connected |= (status & RH_PS_CCS);\r\nif (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC\r\n| RH_PS_OCIC | RH_PS_PRSC)) {\r\nchanged = 1;\r\nif (i < 7)\r\nbuf [0] |= 1 << (i + 1);\r\nelse\r\nbuf [1] |= 1 << (i - 7);\r\n}\r\n}\r\nif (ohci_root_hub_state_changes(ohci, changed,\r\nany_connected, rhsc_status))\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nelse\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\ndone:\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn changed ? length : 0;\r\n}\r\nstatic void\r\nohci_hub_descriptor (\r\nstruct ohci_hcd *ohci,\r\nstruct usb_hub_descriptor *desc\r\n) {\r\nu32 rh = roothub_a (ohci);\r\nu16 temp;\r\ndesc->bDescriptorType = USB_DT_HUB;\r\ndesc->bPwrOn2PwrGood = (rh & RH_A_POTPGT) >> 24;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = ohci->num_ports;\r\ntemp = 1 + (ohci->num_ports / 8);\r\ndesc->bDescLength = 7 + 2 * temp;\r\ntemp = HUB_CHAR_COMMON_LPSM | HUB_CHAR_COMMON_OCPM;\r\nif (rh & RH_A_NPS)\r\ntemp |= HUB_CHAR_NO_LPSM;\r\nif (rh & RH_A_PSM)\r\ntemp |= HUB_CHAR_INDV_PORT_LPSM;\r\nif (rh & RH_A_NOCP)\r\ntemp |= HUB_CHAR_NO_OCPM;\r\nelse if (rh & RH_A_OCPM)\r\ntemp |= HUB_CHAR_INDV_PORT_OCPM;\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\nrh = roothub_b (ohci);\r\nmemset(desc->u.hs.DeviceRemovable, 0xff,\r\nsizeof(desc->u.hs.DeviceRemovable));\r\ndesc->u.hs.DeviceRemovable[0] = rh & RH_B_DR;\r\nif (ohci->num_ports > 7) {\r\ndesc->u.hs.DeviceRemovable[1] = (rh & RH_B_DR) >> 8;\r\ndesc->u.hs.DeviceRemovable[2] = 0xff;\r\n} else\r\ndesc->u.hs.DeviceRemovable[1] = 0xff;\r\n}\r\nstatic int ohci_start_port_reset (struct usb_hcd *hcd, unsigned port)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nu32 status;\r\nif (!port)\r\nreturn -EINVAL;\r\nport--;\r\nstatus = ohci_readl(ohci, &ohci->regs->roothub.portstatus [port]);\r\nif (!(status & RH_PS_CCS))\r\nreturn -ENODEV;\r\nohci_writel(ohci, RH_PS_PRS, &ohci->regs->roothub.portstatus [port]);\r\nreturn 0;\r\n}\r\nstatic inline int root_port_reset (struct ohci_hcd *ohci, unsigned port)\r\n{\r\n__hc32 __iomem *portstat = &ohci->regs->roothub.portstatus [port];\r\nu32 temp = 0;\r\nu16 now = ohci_readl(ohci, &ohci->regs->fmnumber);\r\nu16 reset_done = now + PORT_RESET_MSEC;\r\nint limit_1 = DIV_ROUND_UP(PORT_RESET_MSEC, PORT_RESET_HW_MSEC);\r\ndo {\r\nint limit_2;\r\nlimit_2 = PORT_RESET_HW_MSEC * 2;\r\nwhile (--limit_2 >= 0) {\r\ntemp = ohci_readl (ohci, portstat);\r\nif (temp == ~(u32)0)\r\nreturn -ESHUTDOWN;\r\nif (!(temp & RH_PS_PRS))\r\nbreak;\r\nudelay (500);\r\n}\r\nif (limit_2 < 0) {\r\nohci_dbg(ohci,\r\n"port[%d] reset timeout, stat %08x\n",\r\nport, temp);\r\nbreak;\r\n}\r\nif (!(temp & RH_PS_CCS))\r\nbreak;\r\nif (temp & RH_PS_PRSC)\r\nohci_writel (ohci, RH_PS_PRSC, portstat);\r\nohci_writel (ohci, RH_PS_PRS, portstat);\r\nmsleep(PORT_RESET_HW_MSEC);\r\nnow = ohci_readl(ohci, &ohci->regs->fmnumber);\r\n} while (tick_before(now, reset_done) && --limit_1 >= 0);\r\nreturn 0;\r\n}\r\nint ohci_hub_control(\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength\r\n) {\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint ports = ohci->num_ports;\r\nu32 temp;\r\nint retval = 0;\r\nif (unlikely(!HCD_HW_ACCESSIBLE(hcd)))\r\nreturn -ESHUTDOWN;\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\nohci_writel (ohci, RH_HS_OCIC,\r\n&ohci->regs->roothub.status);\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\ntemp = RH_PS_CCS;\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ntemp = RH_PS_PESC;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\ntemp = RH_PS_POCI;\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ntemp = RH_PS_PSSC;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\ntemp = RH_PS_LSDA;\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ntemp = RH_PS_CSC;\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ntemp = RH_PS_OCIC;\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\ntemp = RH_PS_PRSC;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nohci_writel (ohci, temp,\r\n&ohci->regs->roothub.portstatus [wIndex]);\r\nbreak;\r\ncase GetHubDescriptor:\r\nohci_hub_descriptor (ohci, (struct usb_hub_descriptor *) buf);\r\nbreak;\r\ncase GetHubStatus:\r\ntemp = roothub_status (ohci) & ~(RH_HS_CRWE | RH_HS_DRWE);\r\nput_unaligned_le32(temp, buf);\r\nbreak;\r\ncase GetPortStatus:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = roothub_portstatus (ohci, wIndex);\r\nput_unaligned_le32(temp, buf);\r\nif (*(u16*)(buf+2))\r\ndbg_port(ohci, "GetStatus", wIndex, temp);\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\n#ifdef CONFIG_USB_OTG\r\nif (hcd->self.otg_port == (wIndex + 1)\r\n&& hcd->self.b_hnp_enable)\r\nohci->start_hnp(ohci);\r\nelse\r\n#endif\r\nohci_writel (ohci, RH_PS_PSS,\r\n&ohci->regs->roothub.portstatus [wIndex]);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nohci_writel (ohci, RH_PS_PPS,\r\n&ohci->regs->roothub.portstatus [wIndex]);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nretval = root_port_reset (ohci, wIndex);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nreturn retval;\r\n}
