static int pcpu_populate_chunk(struct pcpu_chunk *chunk,\r\nint page_start, int page_end)\r\n{\r\nreturn 0;\r\n}\r\nstatic void pcpu_depopulate_chunk(struct pcpu_chunk *chunk,\r\nint page_start, int page_end)\r\n{\r\n}\r\nstatic struct pcpu_chunk *pcpu_create_chunk(void)\r\n{\r\nconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\r\nstruct pcpu_chunk *chunk;\r\nstruct page *pages;\r\nint i;\r\nchunk = pcpu_alloc_chunk();\r\nif (!chunk)\r\nreturn NULL;\r\npages = alloc_pages(GFP_KERNEL, order_base_2(nr_pages));\r\nif (!pages) {\r\npcpu_free_chunk(chunk);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < nr_pages; i++)\r\npcpu_set_page_chunk(nth_page(pages, i), chunk);\r\nchunk->data = pages;\r\nchunk->base_addr = page_address(pages) - pcpu_group_offsets[0];\r\nspin_lock_irq(&pcpu_lock);\r\npcpu_chunk_populated(chunk, 0, nr_pages);\r\nspin_unlock_irq(&pcpu_lock);\r\nreturn chunk;\r\n}\r\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk)\r\n{\r\nconst int nr_pages = pcpu_group_sizes[0] >> PAGE_SHIFT;\r\nif (chunk && chunk->data)\r\n__free_pages(chunk->data, order_base_2(nr_pages));\r\npcpu_free_chunk(chunk);\r\n}\r\nstatic struct page *pcpu_addr_to_page(void *addr)\r\n{\r\nreturn virt_to_page(addr);\r\n}\r\nstatic int __init pcpu_verify_alloc_info(const struct pcpu_alloc_info *ai)\r\n{\r\nsize_t nr_pages, alloc_pages;\r\nif (ai->nr_groups != 1) {\r\npr_crit("can't handle more than one group\n");\r\nreturn -EINVAL;\r\n}\r\nnr_pages = (ai->groups[0].nr_units * ai->unit_size) >> PAGE_SHIFT;\r\nalloc_pages = roundup_pow_of_two(nr_pages);\r\nif (alloc_pages > nr_pages)\r\npr_warn("wasting %zu pages per chunk\n",\r\nalloc_pages - nr_pages);\r\nreturn 0;\r\n}
