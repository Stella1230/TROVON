static int mtk_sysirq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nirq_hw_number_t hwirq = data->hwirq;\r\nstruct mtk_sysirq_chip_data *chip_data = data->chip_data;\r\nu32 offset, reg_index, value;\r\nunsigned long flags;\r\nint ret;\r\noffset = hwirq & 0x1f;\r\nreg_index = hwirq >> 5;\r\nspin_lock_irqsave(&chip_data->lock, flags);\r\nvalue = readl_relaxed(chip_data->intpol_base + reg_index * 4);\r\nif (type == IRQ_TYPE_LEVEL_LOW || type == IRQ_TYPE_EDGE_FALLING) {\r\nif (type == IRQ_TYPE_LEVEL_LOW)\r\ntype = IRQ_TYPE_LEVEL_HIGH;\r\nelse\r\ntype = IRQ_TYPE_EDGE_RISING;\r\nvalue |= (1 << offset);\r\n} else {\r\nvalue &= ~(1 << offset);\r\n}\r\nwritel(value, chip_data->intpol_base + reg_index * 4);\r\ndata = data->parent_data;\r\nret = data->chip->irq_set_type(data, type);\r\nspin_unlock_irqrestore(&chip_data->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int mtk_sysirq_domain_translate(struct irq_domain *d,\r\nstruct irq_fwspec *fwspec,\r\nunsigned long *hwirq,\r\nunsigned int *type)\r\n{\r\nif (is_of_node(fwspec->fwnode)) {\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\n*hwirq = fwspec->param[1];\r\n*type = fwspec->param[2] & IRQ_TYPE_SENSE_MASK;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mtk_sysirq_domain_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *arg)\r\n{\r\nint i;\r\nirq_hw_number_t hwirq;\r\nstruct irq_fwspec *fwspec = arg;\r\nstruct irq_fwspec gic_fwspec = *fwspec;\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0])\r\nreturn -EINVAL;\r\nhwirq = fwspec->param[1];\r\nfor (i = 0; i < nr_irqs; i++)\r\nirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\r\n&mtk_sysirq_chip,\r\ndomain->host_data);\r\ngic_fwspec.fwnode = domain->parent->fwnode;\r\nreturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &gic_fwspec);\r\n}\r\nstatic int __init mtk_sysirq_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct irq_domain *domain, *domain_parent;\r\nstruct mtk_sysirq_chip_data *chip_data;\r\nint ret, size, intpol_num;\r\nstruct resource res;\r\ndomain_parent = irq_find_host(parent);\r\nif (!domain_parent) {\r\npr_err("mtk_sysirq: interrupt-parent not found\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret)\r\nreturn ret;\r\nchip_data = kzalloc(sizeof(*chip_data), GFP_KERNEL);\r\nif (!chip_data)\r\nreturn -ENOMEM;\r\nsize = resource_size(&res);\r\nintpol_num = size * 8;\r\nchip_data->intpol_base = ioremap(res.start, size);\r\nif (!chip_data->intpol_base) {\r\npr_err("mtk_sysirq: unable to map sysirq register\n");\r\nret = -ENXIO;\r\ngoto out_free;\r\n}\r\ndomain = irq_domain_add_hierarchy(domain_parent, 0, intpol_num, node,\r\n&sysirq_domain_ops, chip_data);\r\nif (!domain) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nspin_lock_init(&chip_data->lock);\r\nreturn 0;\r\nout_unmap:\r\niounmap(chip_data->intpol_base);\r\nout_free:\r\nkfree(chip_data);\r\nreturn ret;\r\n}
