int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nreturn xfrm6_extract_header(skb);\r\n}\r\nint xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi,\r\nstruct ip6_tnl *t)\r\n{\r\nXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = t;\r\nXFRM_SPI_SKB_CB(skb)->family = AF_INET6;\r\nXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct ipv6hdr, daddr);\r\nreturn xfrm_input(skb, nexthdr, spi, 0);\r\n}\r\nint xfrm6_transport_finish(struct sk_buff *skb, int async)\r\n{\r\nskb_network_header(skb)[IP6CB(skb)->nhoff] =\r\nXFRM_MODE_SKB_CB(skb)->protocol;\r\n#ifndef CONFIG_NETFILTER\r\nif (!async)\r\nreturn 1;\r\n#endif\r\nipv6_hdr(skb)->payload_len = htons(skb->len);\r\n__skb_push(skb, skb->data - skb_network_header(skb));\r\nNF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,\r\ndev_net(skb->dev), NULL, skb, skb->dev, NULL,\r\nip6_rcv_finish);\r\nreturn -1;\r\n}\r\nint xfrm6_rcv_tnl(struct sk_buff *skb, struct ip6_tnl *t)\r\n{\r\nreturn xfrm6_rcv_spi(skb, skb_network_header(skb)[IP6CB(skb)->nhoff],\r\n0, t);\r\n}\r\nint xfrm6_rcv(struct sk_buff *skb)\r\n{\r\nreturn xfrm6_rcv_tnl(skb, NULL);\r\n}\r\nint xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,\r\nxfrm_address_t *saddr, u8 proto)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct xfrm_state *x = NULL;\r\nint i = 0;\r\nif (!skb->sp || atomic_read(&skb->sp->refcnt) != 1) {\r\nstruct sec_path *sp;\r\nsp = secpath_dup(skb->sp);\r\nif (!sp) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINERROR);\r\ngoto drop;\r\n}\r\nif (skb->sp)\r\nsecpath_put(skb->sp);\r\nskb->sp = sp;\r\n}\r\nif (1 + skb->sp->len == XFRM_MAX_DEPTH) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR);\r\ngoto drop;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nxfrm_address_t *dst, *src;\r\nswitch (i) {\r\ncase 0:\r\ndst = daddr;\r\nsrc = saddr;\r\nbreak;\r\ncase 1:\r\ndst = daddr;\r\nsrc = (xfrm_address_t *)&in6addr_any;\r\nbreak;\r\ndefault:\r\ndst = (xfrm_address_t *)&in6addr_any;\r\nsrc = (xfrm_address_t *)&in6addr_any;\r\nbreak;\r\n}\r\nx = xfrm_state_lookup_byaddr(net, skb->mark, dst, src, proto, AF_INET6);\r\nif (!x)\r\ncontinue;\r\nspin_lock(&x->lock);\r\nif ((!i || (x->props.flags & XFRM_STATE_WILDRECV)) &&\r\nlikely(x->km.state == XFRM_STATE_VALID) &&\r\n!xfrm_state_check_expire(x)) {\r\nspin_unlock(&x->lock);\r\nif (x->type->input(x, skb) > 0) {\r\nbreak;\r\n}\r\n} else\r\nspin_unlock(&x->lock);\r\nxfrm_state_put(x);\r\nx = NULL;\r\n}\r\nif (!x) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMINNOSTATES);\r\nxfrm_audit_state_notfound_simple(skb, AF_INET6);\r\ngoto drop;\r\n}\r\nskb->sp->xvec[skb->sp->len++] = x;\r\nspin_lock(&x->lock);\r\nx->curlft.bytes += skb->len;\r\nx->curlft.packets++;\r\nspin_unlock(&x->lock);\r\nreturn 1;\r\ndrop:\r\nreturn -1;\r\n}
