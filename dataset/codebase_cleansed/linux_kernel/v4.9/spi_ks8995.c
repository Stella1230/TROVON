static inline u8 get_chip_id(u8 val)\r\n{\r\nreturn (val >> ID1_CHIPID_S) & ID1_CHIPID_M;\r\n}\r\nstatic inline u8 get_chip_rev(u8 val)\r\n{\r\nreturn (val >> ID1_REVISION_S) & ID1_REVISION_M;\r\n}\r\nstatic inline __be16 create_spi_cmd(struct ks8995_switch *ks, int cmd,\r\nunsigned address)\r\n{\r\nu16 result = cmd;\r\nresult <<= ks->chip->addr_width + ks->chip->addr_shift;\r\nresult |= address << ks->chip->addr_shift;\r\nreturn cpu_to_be16(result);\r\n}\r\nstatic int ks8995_read(struct ks8995_switch *ks, char *buf,\r\nunsigned offset, size_t count)\r\n{\r\n__be16 cmd;\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nint err;\r\ncmd = create_spi_cmd(ks, KS8995_CMD_READ, offset);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt[0].tx_buf = &cmd;\r\nt[0].len = sizeof(cmd);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = count;\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&ks->lock);\r\nerr = spi_sync(ks->spi, &m);\r\nmutex_unlock(&ks->lock);\r\nreturn err ? err : count;\r\n}\r\nstatic int ks8995_write(struct ks8995_switch *ks, char *buf,\r\nunsigned offset, size_t count)\r\n{\r\n__be16 cmd;\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nint err;\r\ncmd = create_spi_cmd(ks, KS8995_CMD_WRITE, offset);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt[0].tx_buf = &cmd;\r\nt[0].len = sizeof(cmd);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = buf;\r\nt[1].len = count;\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&ks->lock);\r\nerr = spi_sync(ks->spi, &m);\r\nmutex_unlock(&ks->lock);\r\nreturn err ? err : count;\r\n}\r\nstatic inline int ks8995_read_reg(struct ks8995_switch *ks, u8 addr, u8 *buf)\r\n{\r\nreturn ks8995_read(ks, buf, addr, 1) != 1;\r\n}\r\nstatic inline int ks8995_write_reg(struct ks8995_switch *ks, u8 addr, u8 val)\r\n{\r\nchar buf = val;\r\nreturn ks8995_write(ks, &buf, addr, 1) != 1;\r\n}\r\nstatic int ks8995_stop(struct ks8995_switch *ks)\r\n{\r\nreturn ks8995_write_reg(ks, KS8995_REG_ID1, 0);\r\n}\r\nstatic int ks8995_start(struct ks8995_switch *ks)\r\n{\r\nreturn ks8995_write_reg(ks, KS8995_REG_ID1, 1);\r\n}\r\nstatic int ks8995_reset(struct ks8995_switch *ks)\r\n{\r\nint err;\r\nerr = ks8995_stop(ks);\r\nif (err)\r\nreturn err;\r\nudelay(KS8995_RESET_DELAY);\r\nreturn ks8995_start(ks);\r\n}\r\nstatic ssize_t ks8995_registers_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev;\r\nstruct ks8995_switch *ks8995;\r\ndev = container_of(kobj, struct device, kobj);\r\nks8995 = dev_get_drvdata(dev);\r\nreturn ks8995_read(ks8995, buf, off, count);\r\n}\r\nstatic ssize_t ks8995_registers_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev;\r\nstruct ks8995_switch *ks8995;\r\ndev = container_of(kobj, struct device, kobj);\r\nks8995 = dev_get_drvdata(dev);\r\nreturn ks8995_write(ks8995, buf, off, count);\r\n}\r\nstatic int ks8995_get_revision(struct ks8995_switch *ks)\r\n{\r\nint err;\r\nu8 id0, id1, ksz8864_id;\r\nerr = ks8995_read_reg(ks, KS8995_REG_ID0, &id0);\r\nif (err) {\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nif (id0 != ks->chip->family_id) {\r\ndev_err(&ks->spi->dev, "chip family id mismatch: expected 0x%02x but 0x%02x read\n",\r\nks->chip->family_id, id0);\r\nerr = -ENODEV;\r\ngoto err_out;\r\n}\r\nswitch (ks->chip->family_id) {\r\ncase FAMILY_KS8995:\r\nerr = ks8995_read_reg(ks, KS8995_REG_ID1, &id1);\r\nif (err) {\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nif ((get_chip_id(id1) == CHIPID_M) &&\r\n(get_chip_id(id1) == ks->chip->chip_id)) {\r\nks->revision_id = get_chip_rev(id1);\r\n} else if (get_chip_id(id1) != CHIPID_M) {\r\nerr = ks8995_read_reg(ks, KS8995_REG_ID1, &ksz8864_id);\r\nif (err) {\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nif ((ksz8864_id & 0x80) &&\r\n(ks->chip->chip_id == KSZ8864_CHIP_ID)) {\r\nks->revision_id = get_chip_rev(id1);\r\n}\r\n} else {\r\ndev_err(&ks->spi->dev, "unsupported chip id for KS8995 family: 0x%02x\n",\r\nid1);\r\nerr = -ENODEV;\r\n}\r\nbreak;\r\ncase FAMILY_KSZ8795:\r\nerr = ks8995_read_reg(ks, KS8995_REG_ID1, &id1);\r\nif (err) {\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nif (get_chip_id(id1) == ks->chip->chip_id) {\r\nks->revision_id = get_chip_rev(id1);\r\n} else {\r\ndev_err(&ks->spi->dev, "unsupported chip id for KSZ8795 family: 0x%02x\n",\r\nid1);\r\nerr = -ENODEV;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&ks->spi->dev, "unsupported family id: 0x%02x\n", id0);\r\nerr = -ENODEV;\r\nbreak;\r\n}\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void ks8995_parse_dt(struct ks8995_switch *ks)\r\n{\r\nstruct device_node *np = ks->spi->dev.of_node;\r\nstruct ks8995_pdata *pdata = ks->pdata;\r\nif (!np)\r\nreturn;\r\npdata->reset_gpio = of_get_named_gpio_flags(np, "reset-gpios", 0,\r\n&pdata->reset_gpio_flags);\r\n}\r\nstatic int ks8995_probe(struct spi_device *spi)\r\n{\r\nstruct ks8995_switch *ks;\r\nint err;\r\nint variant = spi_get_device_id(spi)->driver_data;\r\nif (variant >= max_variant) {\r\ndev_err(&spi->dev, "bad chip variant %d\n", variant);\r\nreturn -ENODEV;\r\n}\r\nks = devm_kzalloc(&spi->dev, sizeof(*ks), GFP_KERNEL);\r\nif (!ks)\r\nreturn -ENOMEM;\r\nmutex_init(&ks->lock);\r\nks->spi = spi;\r\nks->chip = &ks8995_chip[variant];\r\nif (ks->spi->dev.of_node) {\r\nks->pdata = devm_kzalloc(&spi->dev, sizeof(*ks->pdata),\r\nGFP_KERNEL);\r\nif (!ks->pdata)\r\nreturn -ENOMEM;\r\nks->pdata->reset_gpio = -1;\r\nks8995_parse_dt(ks);\r\n}\r\nif (!ks->pdata)\r\nks->pdata = spi->dev.platform_data;\r\nif (ks->pdata && gpio_is_valid(ks->pdata->reset_gpio)) {\r\nunsigned long flags;\r\nflags = (ks->pdata->reset_gpio_flags == OF_GPIO_ACTIVE_LOW ?\r\nGPIOF_ACTIVE_LOW : 0);\r\nerr = devm_gpio_request_one(&spi->dev,\r\nks->pdata->reset_gpio,\r\nflags, "switch-reset");\r\nif (err) {\r\ndev_err(&spi->dev,\r\n"failed to get reset-gpios: %d\n", err);\r\nreturn -EIO;\r\n}\r\ngpiod_set_value(gpio_to_desc(ks->pdata->reset_gpio), 0);\r\n}\r\nspi_set_drvdata(spi, ks);\r\nspi->mode = SPI_MODE_0;\r\nspi->bits_per_word = 8;\r\nerr = spi_setup(spi);\r\nif (err) {\r\ndev_err(&spi->dev, "spi_setup failed, err=%d\n", err);\r\nreturn err;\r\n}\r\nerr = ks8995_get_revision(ks);\r\nif (err)\r\nreturn err;\r\nks->regs_attr.size = ks->chip->regs_size;\r\nmemcpy(&ks->regs_attr, &ks8995_registers_attr, sizeof(ks->regs_attr));\r\nerr = ks8995_reset(ks);\r\nif (err)\r\nreturn err;\r\nerr = sysfs_create_bin_file(&spi->dev.kobj, &ks->regs_attr);\r\nif (err) {\r\ndev_err(&spi->dev, "unable to create sysfs file, err=%d\n",\r\nerr);\r\nreturn err;\r\n}\r\ndev_info(&spi->dev, "%s device found, Chip ID:%x, Revision:%x\n",\r\nks->chip->name, ks->chip->chip_id, ks->revision_id);\r\nreturn 0;\r\n}\r\nstatic int ks8995_remove(struct spi_device *spi)\r\n{\r\nstruct ks8995_switch *ks = spi_get_drvdata(spi);\r\nsysfs_remove_bin_file(&spi->dev.kobj, &ks->regs_attr);\r\nif (ks->pdata && gpio_is_valid(ks->pdata->reset_gpio))\r\ngpiod_set_value(gpio_to_desc(ks->pdata->reset_gpio), 1);\r\nreturn 0;\r\n}
