void sas_init_dev(struct domain_device *dev)\r\n{\r\nswitch (dev->dev_type) {\r\ncase SAS_END_DEVICE:\r\nINIT_LIST_HEAD(&dev->ssp_dev.eh_list_node);\r\nbreak;\r\ncase SAS_EDGE_EXPANDER_DEVICE:\r\ncase SAS_FANOUT_EXPANDER_DEVICE:\r\nINIT_LIST_HEAD(&dev->ex_dev.children);\r\nmutex_init(&dev->ex_dev.cmd_mutex);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int sas_get_port_device(struct asd_sas_port *port)\r\n{\r\nstruct asd_sas_phy *phy;\r\nstruct sas_rphy *rphy;\r\nstruct domain_device *dev;\r\nint rc = -ENODEV;\r\ndev = sas_alloc_device();\r\nif (!dev)\r\nreturn -ENOMEM;\r\nspin_lock_irq(&port->phy_list_lock);\r\nif (list_empty(&port->phy_list)) {\r\nspin_unlock_irq(&port->phy_list_lock);\r\nsas_put_device(dev);\r\nreturn -ENODEV;\r\n}\r\nphy = container_of(port->phy_list.next, struct asd_sas_phy, port_phy_el);\r\nspin_lock(&phy->frame_rcvd_lock);\r\nmemcpy(dev->frame_rcvd, phy->frame_rcvd, min(sizeof(dev->frame_rcvd),\r\n(size_t)phy->frame_rcvd_size));\r\nspin_unlock(&phy->frame_rcvd_lock);\r\nspin_unlock_irq(&port->phy_list_lock);\r\nif (dev->frame_rcvd[0] == 0x34 && port->oob_mode == SATA_OOB_MODE) {\r\nstruct dev_to_host_fis *fis =\r\n(struct dev_to_host_fis *) dev->frame_rcvd;\r\nif (fis->interrupt_reason == 1 && fis->lbal == 1 &&\r\nfis->byte_count_low==0x69 && fis->byte_count_high == 0x96\r\n&& (fis->device & ~0x10) == 0)\r\ndev->dev_type = SAS_SATA_PM;\r\nelse\r\ndev->dev_type = SAS_SATA_DEV;\r\ndev->tproto = SAS_PROTOCOL_SATA;\r\n} else {\r\nstruct sas_identify_frame *id =\r\n(struct sas_identify_frame *) dev->frame_rcvd;\r\ndev->dev_type = id->dev_type;\r\ndev->iproto = id->initiator_bits;\r\ndev->tproto = id->target_bits;\r\n}\r\nsas_init_dev(dev);\r\ndev->port = port;\r\nswitch (dev->dev_type) {\r\ncase SAS_SATA_DEV:\r\nrc = sas_ata_init(dev);\r\nif (rc) {\r\nrphy = NULL;\r\nbreak;\r\n}\r\ncase SAS_END_DEVICE:\r\nrphy = sas_end_device_alloc(port->port);\r\nbreak;\r\ncase SAS_EDGE_EXPANDER_DEVICE:\r\nrphy = sas_expander_alloc(port->port,\r\nSAS_EDGE_EXPANDER_DEVICE);\r\nbreak;\r\ncase SAS_FANOUT_EXPANDER_DEVICE:\r\nrphy = sas_expander_alloc(port->port,\r\nSAS_FANOUT_EXPANDER_DEVICE);\r\nbreak;\r\ndefault:\r\nprintk("ERROR: Unidentified device type %d\n", dev->dev_type);\r\nrphy = NULL;\r\nbreak;\r\n}\r\nif (!rphy) {\r\nsas_put_device(dev);\r\nreturn rc;\r\n}\r\nrphy->identify.phy_identifier = phy->phy->identify.phy_identifier;\r\nmemcpy(dev->sas_addr, port->attached_sas_addr, SAS_ADDR_SIZE);\r\nsas_fill_in_rphy(dev, rphy);\r\nsas_hash_addr(dev->hashed_sas_addr, dev->sas_addr);\r\nport->port_dev = dev;\r\ndev->linkrate = port->linkrate;\r\ndev->min_linkrate = port->linkrate;\r\ndev->max_linkrate = port->linkrate;\r\ndev->pathways = port->num_phys;\r\nmemset(port->disc.fanout_sas_addr, 0, SAS_ADDR_SIZE);\r\nmemset(port->disc.eeds_a, 0, SAS_ADDR_SIZE);\r\nmemset(port->disc.eeds_b, 0, SAS_ADDR_SIZE);\r\nport->disc.max_level = 0;\r\nsas_device_set_phy(dev, port->port);\r\ndev->rphy = rphy;\r\nget_device(&dev->rphy->dev);\r\nif (dev_is_sata(dev) || dev->dev_type == SAS_END_DEVICE)\r\nlist_add_tail(&dev->disco_list_node, &port->disco_list);\r\nelse {\r\nspin_lock_irq(&port->dev_list_lock);\r\nlist_add_tail(&dev->dev_list_node, &port->dev_list);\r\nspin_unlock_irq(&port->dev_list_lock);\r\n}\r\nspin_lock_irq(&port->phy_list_lock);\r\nlist_for_each_entry(phy, &port->phy_list, port_phy_el)\r\nsas_phy_set_target(phy, dev);\r\nspin_unlock_irq(&port->phy_list_lock);\r\nreturn 0;\r\n}\r\nint sas_notify_lldd_dev_found(struct domain_device *dev)\r\n{\r\nint res = 0;\r\nstruct sas_ha_struct *sas_ha = dev->port->ha;\r\nstruct Scsi_Host *shost = sas_ha->core.shost;\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nif (!i->dft->lldd_dev_found)\r\nreturn 0;\r\nres = i->dft->lldd_dev_found(dev);\r\nif (res) {\r\nprintk("sas: driver on pcidev %s cannot handle "\r\n"device %llx, error:%d\n",\r\ndev_name(sas_ha->dev),\r\nSAS_ADDR(dev->sas_addr), res);\r\n}\r\nset_bit(SAS_DEV_FOUND, &dev->state);\r\nkref_get(&dev->kref);\r\nreturn res;\r\n}\r\nvoid sas_notify_lldd_dev_gone(struct domain_device *dev)\r\n{\r\nstruct sas_ha_struct *sas_ha = dev->port->ha;\r\nstruct Scsi_Host *shost = sas_ha->core.shost;\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nif (!i->dft->lldd_dev_gone)\r\nreturn;\r\nif (test_and_clear_bit(SAS_DEV_FOUND, &dev->state)) {\r\ni->dft->lldd_dev_gone(dev);\r\nsas_put_device(dev);\r\n}\r\n}\r\nstatic void sas_probe_devices(struct work_struct *work)\r\n{\r\nstruct domain_device *dev, *n;\r\nstruct sas_discovery_event *ev = to_sas_discovery_event(work);\r\nstruct asd_sas_port *port = ev->port;\r\nclear_bit(DISCE_PROBE, &port->disc.pending);\r\nlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\r\nspin_lock_irq(&port->dev_list_lock);\r\nlist_add_tail(&dev->dev_list_node, &port->dev_list);\r\nspin_unlock_irq(&port->dev_list_lock);\r\n}\r\nsas_probe_sata(port);\r\nlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\r\nint err;\r\nerr = sas_rphy_add(dev->rphy);\r\nif (err)\r\nsas_fail_probe(dev, __func__, err);\r\nelse\r\nlist_del_init(&dev->disco_list_node);\r\n}\r\n}\r\nstatic void sas_suspend_devices(struct work_struct *work)\r\n{\r\nstruct asd_sas_phy *phy;\r\nstruct domain_device *dev;\r\nstruct sas_discovery_event *ev = to_sas_discovery_event(work);\r\nstruct asd_sas_port *port = ev->port;\r\nstruct Scsi_Host *shost = port->ha->core.shost;\r\nstruct sas_internal *si = to_sas_internal(shost->transportt);\r\nclear_bit(DISCE_SUSPEND, &port->disc.pending);\r\nsas_suspend_sata(port);\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node)\r\nsas_notify_lldd_dev_gone(dev);\r\nlist_for_each_entry(phy, &port->phy_list, port_phy_el) {\r\nif (si->dft->lldd_port_formed)\r\nsi->dft->lldd_port_deformed(phy);\r\nphy->suspended = 1;\r\nport->suspended = 1;\r\n}\r\n}\r\nstatic void sas_resume_devices(struct work_struct *work)\r\n{\r\nstruct sas_discovery_event *ev = to_sas_discovery_event(work);\r\nstruct asd_sas_port *port = ev->port;\r\nclear_bit(DISCE_RESUME, &port->disc.pending);\r\nsas_resume_sata(port);\r\n}\r\nint sas_discover_end_dev(struct domain_device *dev)\r\n{\r\nint res;\r\nres = sas_notify_lldd_dev_found(dev);\r\nif (res)\r\nreturn res;\r\nsas_discover_event(dev->port, DISCE_PROBE);\r\nreturn 0;\r\n}\r\nvoid sas_free_device(struct kref *kref)\r\n{\r\nstruct domain_device *dev = container_of(kref, typeof(*dev), kref);\r\nput_device(&dev->rphy->dev);\r\ndev->rphy = NULL;\r\nif (dev->parent)\r\nsas_put_device(dev->parent);\r\nsas_port_put_phy(dev->phy);\r\ndev->phy = NULL;\r\nif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\r\nkfree(dev->ex_dev.ex_phy);\r\nif (dev_is_sata(dev) && dev->sata_dev.ap) {\r\nata_sas_port_destroy(dev->sata_dev.ap);\r\ndev->sata_dev.ap = NULL;\r\n}\r\nkfree(dev);\r\n}\r\nstatic void sas_unregister_common_dev(struct asd_sas_port *port, struct domain_device *dev)\r\n{\r\nstruct sas_ha_struct *ha = port->ha;\r\nsas_notify_lldd_dev_gone(dev);\r\nif (!dev->parent)\r\ndev->port->port_dev = NULL;\r\nelse\r\nlist_del_init(&dev->siblings);\r\nspin_lock_irq(&port->dev_list_lock);\r\nlist_del_init(&dev->dev_list_node);\r\nif (dev_is_sata(dev))\r\nsas_ata_end_eh(dev->sata_dev.ap);\r\nspin_unlock_irq(&port->dev_list_lock);\r\nspin_lock_irq(&ha->lock);\r\nif (dev->dev_type == SAS_END_DEVICE &&\r\n!list_empty(&dev->ssp_dev.eh_list_node)) {\r\nlist_del_init(&dev->ssp_dev.eh_list_node);\r\nha->eh_active--;\r\n}\r\nspin_unlock_irq(&ha->lock);\r\nsas_put_device(dev);\r\n}\r\nstatic void sas_destruct_devices(struct work_struct *work)\r\n{\r\nstruct domain_device *dev, *n;\r\nstruct sas_discovery_event *ev = to_sas_discovery_event(work);\r\nstruct asd_sas_port *port = ev->port;\r\nclear_bit(DISCE_DESTRUCT, &port->disc.pending);\r\nlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\r\nlist_del_init(&dev->disco_list_node);\r\nsas_remove_children(&dev->rphy->dev);\r\nsas_rphy_delete(dev->rphy);\r\nsas_unregister_common_dev(port, dev);\r\n}\r\n}\r\nvoid sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\r\n{\r\nif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\r\n!list_empty(&dev->disco_list_node)) {\r\nlist_del_init(&dev->disco_list_node);\r\nsas_rphy_free(dev->rphy);\r\nsas_unregister_common_dev(port, dev);\r\nreturn;\r\n}\r\nif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\r\nsas_rphy_unlink(dev->rphy);\r\nlist_move_tail(&dev->disco_list_node, &port->destroy_list);\r\nsas_discover_event(dev->port, DISCE_DESTRUCT);\r\n}\r\n}\r\nvoid sas_unregister_domain_devices(struct asd_sas_port *port, int gone)\r\n{\r\nstruct domain_device *dev, *n;\r\nlist_for_each_entry_safe_reverse(dev, n, &port->dev_list, dev_list_node) {\r\nif (gone)\r\nset_bit(SAS_DEV_GONE, &dev->state);\r\nsas_unregister_dev(port, dev);\r\n}\r\nlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node)\r\nsas_unregister_dev(port, dev);\r\nport->port->rphy = NULL;\r\n}\r\nvoid sas_device_set_phy(struct domain_device *dev, struct sas_port *port)\r\n{\r\nstruct sas_ha_struct *ha;\r\nstruct sas_phy *new_phy;\r\nif (!dev)\r\nreturn;\r\nha = dev->port->ha;\r\nnew_phy = sas_port_get_phy(port);\r\nspin_lock_irq(&ha->phy_port_lock);\r\nif (new_phy) {\r\nsas_port_put_phy(dev->phy);\r\ndev->phy = new_phy;\r\n}\r\nspin_unlock_irq(&ha->phy_port_lock);\r\n}\r\nstatic void sas_discover_domain(struct work_struct *work)\r\n{\r\nstruct domain_device *dev;\r\nint error = 0;\r\nstruct sas_discovery_event *ev = to_sas_discovery_event(work);\r\nstruct asd_sas_port *port = ev->port;\r\nclear_bit(DISCE_DISCOVER_DOMAIN, &port->disc.pending);\r\nif (port->port_dev)\r\nreturn;\r\nerror = sas_get_port_device(port);\r\nif (error)\r\nreturn;\r\ndev = port->port_dev;\r\nSAS_DPRINTK("DOING DISCOVERY on port %d, pid:%d\n", port->id,\r\ntask_pid_nr(current));\r\nswitch (dev->dev_type) {\r\ncase SAS_END_DEVICE:\r\nerror = sas_discover_end_dev(dev);\r\nbreak;\r\ncase SAS_EDGE_EXPANDER_DEVICE:\r\ncase SAS_FANOUT_EXPANDER_DEVICE:\r\nerror = sas_discover_root_expander(dev);\r\nbreak;\r\ncase SAS_SATA_DEV:\r\ncase SAS_SATA_PM:\r\n#ifdef CONFIG_SCSI_SAS_ATA\r\nerror = sas_discover_sata(dev);\r\nbreak;\r\n#else\r\nSAS_DPRINTK("ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\n");\r\n#endif\r\ndefault:\r\nerror = -ENXIO;\r\nSAS_DPRINTK("unhandled device %d\n", dev->dev_type);\r\nbreak;\r\n}\r\nif (error) {\r\nsas_rphy_free(dev->rphy);\r\nlist_del_init(&dev->disco_list_node);\r\nspin_lock_irq(&port->dev_list_lock);\r\nlist_del_init(&dev->dev_list_node);\r\nspin_unlock_irq(&port->dev_list_lock);\r\nsas_put_device(dev);\r\nport->port_dev = NULL;\r\n}\r\nSAS_DPRINTK("DONE DISCOVERY on port %d, pid:%d, result:%d\n", port->id,\r\ntask_pid_nr(current), error);\r\n}\r\nstatic void sas_revalidate_domain(struct work_struct *work)\r\n{\r\nint res = 0;\r\nstruct sas_discovery_event *ev = to_sas_discovery_event(work);\r\nstruct asd_sas_port *port = ev->port;\r\nstruct sas_ha_struct *ha = port->ha;\r\nstruct domain_device *ddev = port->port_dev;\r\nmutex_lock(&ha->disco_mutex);\r\nif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\r\nSAS_DPRINTK("REVALIDATION DEFERRED on port %d, pid:%d\n",\r\nport->id, task_pid_nr(current));\r\ngoto out;\r\n}\r\nclear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);\r\nSAS_DPRINTK("REVALIDATING DOMAIN on port %d, pid:%d\n", port->id,\r\ntask_pid_nr(current));\r\nif (ddev && (ddev->dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\r\nddev->dev_type == SAS_EDGE_EXPANDER_DEVICE))\r\nres = sas_ex_revalidate_domain(ddev);\r\nSAS_DPRINTK("done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\n",\r\nport->id, task_pid_nr(current), res);\r\nout:\r\nmutex_unlock(&ha->disco_mutex);\r\n}\r\nstatic void sas_chain_work(struct sas_ha_struct *ha, struct sas_work *sw)\r\n{\r\nscsi_queue_work(ha->core.shost, &sw->work);\r\n}\r\nstatic void sas_chain_event(int event, unsigned long *pending,\r\nstruct sas_work *sw,\r\nstruct sas_ha_struct *ha)\r\n{\r\nif (!test_and_set_bit(event, pending)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->lock, flags);\r\nsas_chain_work(ha, sw);\r\nspin_unlock_irqrestore(&ha->lock, flags);\r\n}\r\n}\r\nint sas_discover_event(struct asd_sas_port *port, enum discover_event ev)\r\n{\r\nstruct sas_discovery *disc;\r\nif (!port)\r\nreturn 0;\r\ndisc = &port->disc;\r\nBUG_ON(ev >= DISC_NUM_EVENTS);\r\nsas_chain_event(ev, &disc->pending, &disc->disc_work[ev].work, port->ha);\r\nreturn 0;\r\n}\r\nvoid sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\r\n{\r\nint i;\r\nstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\r\n[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\r\n[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\r\n[DISCE_PROBE] = sas_probe_devices,\r\n[DISCE_SUSPEND] = sas_suspend_devices,\r\n[DISCE_RESUME] = sas_resume_devices,\r\n[DISCE_DESTRUCT] = sas_destruct_devices,\r\n};\r\ndisc->pending = 0;\r\nfor (i = 0; i < DISC_NUM_EVENTS; i++) {\r\nINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\r\ndisc->disc_work[i].port = port;\r\n}\r\n}
