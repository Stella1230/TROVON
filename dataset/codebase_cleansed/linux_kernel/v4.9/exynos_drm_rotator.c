static void rotator_reg_set_irq(struct rot_context *rot, bool enable)\r\n{\r\nu32 val = rot_read(ROT_CONFIG);\r\nif (enable == true)\r\nval |= ROT_CONFIG_IRQ;\r\nelse\r\nval &= ~ROT_CONFIG_IRQ;\r\nrot_write(val, ROT_CONFIG);\r\n}\r\nstatic u32 rotator_reg_get_fmt(struct rot_context *rot)\r\n{\r\nu32 val = rot_read(ROT_CONTROL);\r\nval &= ROT_CONTROL_FMT_MASK;\r\nreturn val;\r\n}\r\nstatic enum rot_irq_status rotator_reg_get_irq_status(struct rot_context *rot)\r\n{\r\nu32 val = rot_read(ROT_STATUS);\r\nval = ROT_STATUS_IRQ(val);\r\nif (val == ROT_STATUS_IRQ_VAL_COMPLETE)\r\nreturn ROT_IRQ_STATUS_COMPLETE;\r\nreturn ROT_IRQ_STATUS_ILLEGAL;\r\n}\r\nstatic irqreturn_t rotator_irq_handler(int irq, void *arg)\r\n{\r\nstruct rot_context *rot = arg;\r\nstruct exynos_drm_ippdrv *ippdrv = &rot->ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node = ippdrv->c_node;\r\nstruct drm_exynos_ipp_event_work *event_work = c_node->event_work;\r\nenum rot_irq_status irq_status;\r\nu32 val;\r\nirq_status = rotator_reg_get_irq_status(rot);\r\nval = rot_read(ROT_STATUS);\r\nval |= ROT_STATUS_IRQ_PENDING((u32)irq_status);\r\nrot_write(val, ROT_STATUS);\r\nif (irq_status == ROT_IRQ_STATUS_COMPLETE) {\r\nevent_work->ippdrv = ippdrv;\r\nevent_work->buf_id[EXYNOS_DRM_OPS_DST] =\r\nrot->cur_buf_id[EXYNOS_DRM_OPS_DST];\r\nqueue_work(ippdrv->event_workq, &event_work->work);\r\n} else {\r\nDRM_ERROR("the SFR is set illegally\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rotator_align_size(struct rot_context *rot, u32 fmt, u32 *hsize,\r\nu32 *vsize)\r\n{\r\nstruct rot_limit_table *limit_tbl = rot->limit_tbl;\r\nstruct rot_limit *limit;\r\nu32 mask, val;\r\nif (fmt == ROT_CONTROL_FMT_RGB888)\r\nlimit = &limit_tbl->rgb888;\r\nelse\r\nlimit = &limit_tbl->ycbcr420_2p;\r\nmask = ~((1 << limit->align) - 1);\r\nval = ROT_ALIGN(*hsize, limit->align, mask);\r\nif (val < limit->min_w)\r\n*hsize = ROT_MIN(limit->min_w, mask);\r\nelse if (val > limit->max_w)\r\n*hsize = ROT_MAX(limit->max_w, mask);\r\nelse\r\n*hsize = val;\r\nval = ROT_ALIGN(*vsize, limit->align, mask);\r\nif (val < limit->min_h)\r\n*vsize = ROT_MIN(limit->min_h, mask);\r\nelse if (val > limit->max_h)\r\n*vsize = ROT_MAX(limit->max_h, mask);\r\nelse\r\n*vsize = val;\r\n}\r\nstatic int rotator_src_set_fmt(struct device *dev, u32 fmt)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\nu32 val;\r\nval = rot_read(ROT_CONTROL);\r\nval &= ~ROT_CONTROL_FMT_MASK;\r\nswitch (fmt) {\r\ncase DRM_FORMAT_NV12:\r\nval |= ROT_CONTROL_FMT_YCBCR420_2P;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\nval |= ROT_CONTROL_FMT_RGB888;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid image format\n");\r\nreturn -EINVAL;\r\n}\r\nrot_write(val, ROT_CONTROL);\r\nreturn 0;\r\n}\r\nstatic inline bool rotator_check_reg_fmt(u32 fmt)\r\n{\r\nif ((fmt == ROT_CONTROL_FMT_YCBCR420_2P) ||\r\n(fmt == ROT_CONTROL_FMT_RGB888))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int rotator_src_set_size(struct device *dev, int swap,\r\nstruct drm_exynos_pos *pos,\r\nstruct drm_exynos_sz *sz)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\nu32 fmt, hsize, vsize;\r\nu32 val;\r\nfmt = rotator_reg_get_fmt(rot);\r\nif (!rotator_check_reg_fmt(fmt)) {\r\nDRM_ERROR("invalid format.\n");\r\nreturn -EINVAL;\r\n}\r\nhsize = sz->hsize;\r\nvsize = sz->vsize;\r\nrotator_align_size(rot, fmt, &hsize, &vsize);\r\nval = ROT_SET_BUF_SIZE_H(vsize) | ROT_SET_BUF_SIZE_W(hsize);\r\nrot_write(val, ROT_SRC_BUF_SIZE);\r\nval = ROT_CROP_POS_Y(pos->y) | ROT_CROP_POS_X(pos->x);\r\nrot_write(val, ROT_SRC_CROP_POS);\r\nval = ROT_SRC_CROP_SIZE_H(pos->h) | ROT_SRC_CROP_SIZE_W(pos->w);\r\nrot_write(val, ROT_SRC_CROP_SIZE);\r\nreturn 0;\r\n}\r\nstatic int rotator_src_set_addr(struct device *dev,\r\nstruct drm_exynos_ipp_buf_info *buf_info,\r\nu32 buf_id, enum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\ndma_addr_t addr[EXYNOS_DRM_PLANAR_MAX];\r\nu32 val, fmt, hsize, vsize;\r\nint i;\r\nrot->cur_buf_id[EXYNOS_DRM_OPS_SRC] = buf_id;\r\nswitch (buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\nfor_each_ipp_planar(i)\r\naddr[i] = buf_info->base[i];\r\nfmt = rotator_reg_get_fmt(rot);\r\nif (!rotator_check_reg_fmt(fmt)) {\r\nDRM_ERROR("invalid format.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((fmt == ROT_CONTROL_FMT_YCBCR420_2P) &&\r\n!addr[EXYNOS_DRM_PLANAR_CB]) {\r\nval = rot_read(ROT_SRC_BUF_SIZE);\r\nhsize = ROT_GET_BUF_SIZE_W(val);\r\nvsize = ROT_GET_BUF_SIZE_H(val);\r\naddr[EXYNOS_DRM_PLANAR_CB] =\r\naddr[EXYNOS_DRM_PLANAR_Y] + hsize * vsize;\r\n}\r\nfor_each_ipp_planar(i)\r\nrot_write(addr[i], ROT_SRC_BUF_ADDR(i));\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\nfor_each_ipp_planar(i)\r\nrot_write(0x0, ROT_SRC_BUF_ADDR(i));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rotator_dst_set_transf(struct device *dev,\r\nenum drm_exynos_degree degree,\r\nenum drm_exynos_flip flip, bool *swap)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\nu32 val;\r\nval = rot_read(ROT_CONTROL);\r\nval &= ~ROT_CONTROL_FLIP_MASK;\r\nswitch (flip) {\r\ncase EXYNOS_DRM_FLIP_VERTICAL:\r\nval |= ROT_CONTROL_FLIP_VERTICAL;\r\nbreak;\r\ncase EXYNOS_DRM_FLIP_HORIZONTAL:\r\nval |= ROT_CONTROL_FLIP_HORIZONTAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nval &= ~ROT_CONTROL_ROT_MASK;\r\nswitch (degree) {\r\ncase EXYNOS_DRM_DEGREE_90:\r\nval |= ROT_CONTROL_ROT_90;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_180:\r\nval |= ROT_CONTROL_ROT_180;\r\nbreak;\r\ncase EXYNOS_DRM_DEGREE_270:\r\nval |= ROT_CONTROL_ROT_270;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrot_write(val, ROT_CONTROL);\r\nif ((degree == EXYNOS_DRM_DEGREE_90) ||\r\n(degree == EXYNOS_DRM_DEGREE_270))\r\n*swap = true;\r\nelse\r\n*swap = false;\r\nreturn 0;\r\n}\r\nstatic int rotator_dst_set_size(struct device *dev, int swap,\r\nstruct drm_exynos_pos *pos,\r\nstruct drm_exynos_sz *sz)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\nu32 val, fmt, hsize, vsize;\r\nfmt = rotator_reg_get_fmt(rot);\r\nif (!rotator_check_reg_fmt(fmt)) {\r\nDRM_ERROR("invalid format.\n");\r\nreturn -EINVAL;\r\n}\r\nhsize = sz->hsize;\r\nvsize = sz->vsize;\r\nrotator_align_size(rot, fmt, &hsize, &vsize);\r\nval = ROT_SET_BUF_SIZE_H(vsize) | ROT_SET_BUF_SIZE_W(hsize);\r\nrot_write(val, ROT_DST_BUF_SIZE);\r\nval = ROT_CROP_POS_Y(pos->y) | ROT_CROP_POS_X(pos->x);\r\nrot_write(val, ROT_DST_CROP_POS);\r\nreturn 0;\r\n}\r\nstatic int rotator_dst_set_addr(struct device *dev,\r\nstruct drm_exynos_ipp_buf_info *buf_info,\r\nu32 buf_id, enum drm_exynos_ipp_buf_type buf_type)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\ndma_addr_t addr[EXYNOS_DRM_PLANAR_MAX];\r\nu32 val, fmt, hsize, vsize;\r\nint i;\r\nrot->cur_buf_id[EXYNOS_DRM_OPS_DST] = buf_id;\r\nswitch (buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\nfor_each_ipp_planar(i)\r\naddr[i] = buf_info->base[i];\r\nfmt = rotator_reg_get_fmt(rot);\r\nif (!rotator_check_reg_fmt(fmt)) {\r\nDRM_ERROR("invalid format.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((fmt == ROT_CONTROL_FMT_YCBCR420_2P) &&\r\n!addr[EXYNOS_DRM_PLANAR_CB]) {\r\nval = rot_read(ROT_DST_BUF_SIZE);\r\nhsize = ROT_GET_BUF_SIZE_W(val);\r\nvsize = ROT_GET_BUF_SIZE_H(val);\r\naddr[EXYNOS_DRM_PLANAR_CB] =\r\naddr[EXYNOS_DRM_PLANAR_Y] + hsize * vsize;\r\n}\r\nfor_each_ipp_planar(i)\r\nrot_write(addr[i], ROT_DST_BUF_ADDR(i));\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\nfor_each_ipp_planar(i)\r\nrot_write(0x0, ROT_DST_BUF_ADDR(i));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rotator_init_prop_list(struct exynos_drm_ippdrv *ippdrv)\r\n{\r\nstruct drm_exynos_ipp_prop_list *prop_list = &ippdrv->prop_list;\r\nprop_list->version = 1;\r\nprop_list->flip = (1 << EXYNOS_DRM_FLIP_VERTICAL) |\r\n(1 << EXYNOS_DRM_FLIP_HORIZONTAL);\r\nprop_list->degree = (1 << EXYNOS_DRM_DEGREE_0) |\r\n(1 << EXYNOS_DRM_DEGREE_90) |\r\n(1 << EXYNOS_DRM_DEGREE_180) |\r\n(1 << EXYNOS_DRM_DEGREE_270);\r\nprop_list->csc = 0;\r\nprop_list->crop = 0;\r\nprop_list->scale = 0;\r\nreturn 0;\r\n}\r\nstatic inline bool rotator_check_drm_fmt(u32 fmt)\r\n{\r\nswitch (fmt) {\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_NV12:\r\nreturn true;\r\ndefault:\r\nDRM_DEBUG_KMS("not support format\n");\r\nreturn false;\r\n}\r\n}\r\nstatic inline bool rotator_check_drm_flip(enum drm_exynos_flip flip)\r\n{\r\nswitch (flip) {\r\ncase EXYNOS_DRM_FLIP_NONE:\r\ncase EXYNOS_DRM_FLIP_VERTICAL:\r\ncase EXYNOS_DRM_FLIP_HORIZONTAL:\r\ncase EXYNOS_DRM_FLIP_BOTH:\r\nreturn true;\r\ndefault:\r\nDRM_DEBUG_KMS("invalid flip\n");\r\nreturn false;\r\n}\r\n}\r\nstatic int rotator_ippdrv_check_property(struct device *dev,\r\nstruct drm_exynos_ipp_property *property)\r\n{\r\nstruct drm_exynos_ipp_config *src_config =\r\n&property->config[EXYNOS_DRM_OPS_SRC];\r\nstruct drm_exynos_ipp_config *dst_config =\r\n&property->config[EXYNOS_DRM_OPS_DST];\r\nstruct drm_exynos_pos *src_pos = &src_config->pos;\r\nstruct drm_exynos_pos *dst_pos = &dst_config->pos;\r\nstruct drm_exynos_sz *src_sz = &src_config->sz;\r\nstruct drm_exynos_sz *dst_sz = &dst_config->sz;\r\nbool swap = false;\r\nif (src_config->fmt != dst_config->fmt) {\r\nDRM_DEBUG_KMS("not support csc feature\n");\r\nreturn -EINVAL;\r\n}\r\nif (!rotator_check_drm_fmt(dst_config->fmt)) {\r\nDRM_DEBUG_KMS("invalid format\n");\r\nreturn -EINVAL;\r\n}\r\nif (src_config->degree != EXYNOS_DRM_DEGREE_0) {\r\nDRM_DEBUG_KMS("not support source-side rotation\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (dst_config->degree) {\r\ncase EXYNOS_DRM_DEGREE_90:\r\ncase EXYNOS_DRM_DEGREE_270:\r\nswap = true;\r\ncase EXYNOS_DRM_DEGREE_0:\r\ncase EXYNOS_DRM_DEGREE_180:\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("invalid degree\n");\r\nreturn -EINVAL;\r\n}\r\nif (src_config->flip != EXYNOS_DRM_FLIP_NONE) {\r\nDRM_DEBUG_KMS("not support source-side flip\n");\r\nreturn -EINVAL;\r\n}\r\nif (!rotator_check_drm_flip(dst_config->flip)) {\r\nDRM_DEBUG_KMS("invalid flip\n");\r\nreturn -EINVAL;\r\n}\r\nif ((src_pos->x + src_pos->w > src_sz->hsize) ||\r\n(src_pos->y + src_pos->h > src_sz->vsize)) {\r\nDRM_DEBUG_KMS("out of source buffer bound\n");\r\nreturn -EINVAL;\r\n}\r\nif (swap) {\r\nif ((dst_pos->x + dst_pos->h > dst_sz->vsize) ||\r\n(dst_pos->y + dst_pos->w > dst_sz->hsize)) {\r\nDRM_DEBUG_KMS("out of destination buffer bound\n");\r\nreturn -EINVAL;\r\n}\r\nif ((src_pos->w != dst_pos->h) || (src_pos->h != dst_pos->w)) {\r\nDRM_DEBUG_KMS("not support scale feature\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif ((dst_pos->x + dst_pos->w > dst_sz->hsize) ||\r\n(dst_pos->y + dst_pos->h > dst_sz->vsize)) {\r\nDRM_DEBUG_KMS("out of destination buffer bound\n");\r\nreturn -EINVAL;\r\n}\r\nif ((src_pos->w != dst_pos->w) || (src_pos->h != dst_pos->h)) {\r\nDRM_DEBUG_KMS("not support scale feature\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rotator_ippdrv_start(struct device *dev, enum drm_exynos_ipp_cmd cmd)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\nu32 val;\r\nif (rot->suspended) {\r\nDRM_ERROR("suspended state\n");\r\nreturn -EPERM;\r\n}\r\nif (cmd != IPP_CMD_M2M) {\r\nDRM_ERROR("not support cmd: %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nrotator_reg_set_irq(rot, true);\r\nval = rot_read(ROT_CONTROL);\r\nval |= ROT_CONTROL_START;\r\nrot_write(val, ROT_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int rotator_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rot_context *rot;\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nint ret;\r\nif (!dev->of_node) {\r\ndev_err(dev, "cannot find of_node.\n");\r\nreturn -ENODEV;\r\n}\r\nrot = devm_kzalloc(dev, sizeof(*rot), GFP_KERNEL);\r\nif (!rot)\r\nreturn -ENOMEM;\r\nrot->limit_tbl = (struct rot_limit_table *)\r\nof_device_get_match_data(dev);\r\nrot->regs_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrot->regs = devm_ioremap_resource(dev, rot->regs_res);\r\nif (IS_ERR(rot->regs))\r\nreturn PTR_ERR(rot->regs);\r\nrot->irq = platform_get_irq(pdev, 0);\r\nif (rot->irq < 0) {\r\ndev_err(dev, "failed to get irq\n");\r\nreturn rot->irq;\r\n}\r\nret = devm_request_threaded_irq(dev, rot->irq, NULL,\r\nrotator_irq_handler, IRQF_ONESHOT, "drm_rotator", rot);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to request irq\n");\r\nreturn ret;\r\n}\r\nrot->clock = devm_clk_get(dev, "rotator");\r\nif (IS_ERR(rot->clock)) {\r\ndev_err(dev, "failed to get clock\n");\r\nreturn PTR_ERR(rot->clock);\r\n}\r\npm_runtime_enable(dev);\r\nippdrv = &rot->ippdrv;\r\nippdrv->dev = dev;\r\nippdrv->ops[EXYNOS_DRM_OPS_SRC] = &rot_src_ops;\r\nippdrv->ops[EXYNOS_DRM_OPS_DST] = &rot_dst_ops;\r\nippdrv->check_property = rotator_ippdrv_check_property;\r\nippdrv->start = rotator_ippdrv_start;\r\nret = rotator_init_prop_list(ippdrv);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to init property list.\n");\r\ngoto err_ippdrv_register;\r\n}\r\nDRM_DEBUG_KMS("ippdrv[%p]\n", ippdrv);\r\nplatform_set_drvdata(pdev, rot);\r\nret = exynos_drm_ippdrv_register(ippdrv);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register drm rotator device\n");\r\ngoto err_ippdrv_register;\r\n}\r\ndev_info(dev, "The exynos rotator is probed successfully\n");\r\nreturn 0;\r\nerr_ippdrv_register:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int rotator_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\nstruct exynos_drm_ippdrv *ippdrv = &rot->ippdrv;\r\nexynos_drm_ippdrv_unregister(ippdrv);\r\npm_runtime_disable(dev);\r\nreturn 0;\r\n}\r\nstatic int rotator_clk_crtl(struct rot_context *rot, bool enable)\r\n{\r\nif (enable) {\r\nclk_prepare_enable(rot->clock);\r\nrot->suspended = false;\r\n} else {\r\nclk_disable_unprepare(rot->clock);\r\nrot->suspended = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rotator_runtime_suspend(struct device *dev)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\nreturn rotator_clk_crtl(rot, false);\r\n}\r\nstatic int rotator_runtime_resume(struct device *dev)\r\n{\r\nstruct rot_context *rot = dev_get_drvdata(dev);\r\nreturn rotator_clk_crtl(rot, true);\r\n}
