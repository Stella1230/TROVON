static u32 mesh_table_hash(const void *addr, u32 len, u32 seed)\r\n{\r\nreturn jhash_1word(*(u32 *)(addr+2), seed);\r\n}\r\nstatic inline bool mpath_expired(struct mesh_path *mpath)\r\n{\r\nreturn (mpath->flags & MESH_PATH_ACTIVE) &&\r\ntime_after(jiffies, mpath->exp_time) &&\r\n!(mpath->flags & MESH_PATH_FIXED);\r\n}\r\nstatic void mesh_path_rht_free(void *ptr, void *tblptr)\r\n{\r\nstruct mesh_path *mpath = ptr;\r\nstruct mesh_table *tbl = tblptr;\r\nmesh_path_free_rcu(tbl, mpath);\r\n}\r\nstatic struct mesh_table *mesh_table_alloc(void)\r\n{\r\nstruct mesh_table *newtbl;\r\nnewtbl = kmalloc(sizeof(struct mesh_table), GFP_ATOMIC);\r\nif (!newtbl)\r\nreturn NULL;\r\nINIT_HLIST_HEAD(&newtbl->known_gates);\r\natomic_set(&newtbl->entries, 0);\r\nspin_lock_init(&newtbl->gates_lock);\r\nreturn newtbl;\r\n}\r\nstatic void mesh_table_free(struct mesh_table *tbl)\r\n{\r\nrhashtable_free_and_destroy(&tbl->rhead,\r\nmesh_path_rht_free, tbl);\r\nkfree(tbl);\r\n}\r\nvoid mesh_path_assign_nexthop(struct mesh_path *mpath, struct sta_info *sta)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nunsigned long flags;\r\nrcu_assign_pointer(mpath->next_hop, sta);\r\nspin_lock_irqsave(&mpath->frame_queue.lock, flags);\r\nskb_queue_walk(&mpath->frame_queue, skb) {\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nmemcpy(hdr->addr1, sta->sta.addr, ETH_ALEN);\r\nmemcpy(hdr->addr2, mpath->sdata->vif.addr, ETH_ALEN);\r\nieee80211_mps_set_frame_flags(sta->sdata, sta, hdr);\r\n}\r\nspin_unlock_irqrestore(&mpath->frame_queue.lock, flags);\r\n}\r\nstatic void prepare_for_gate(struct sk_buff *skb, char *dst_addr,\r\nstruct mesh_path *gate_mpath)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nstruct ieee80211s_hdr *mshdr;\r\nint mesh_hdrlen, hdrlen;\r\nchar *next_hop;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nmshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);\r\nif (!(mshdr->flags & MESH_FLAGS_AE)) {\r\nmesh_hdrlen = 6;\r\nskb_push(skb, 2 * ETH_ALEN);\r\nmemmove(skb->data, hdr, hdrlen + mesh_hdrlen);\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nmshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);\r\nmshdr->flags = MESH_FLAGS_AE_A5_A6;\r\nmemcpy(mshdr->eaddr1, hdr->addr3, ETH_ALEN);\r\nmemcpy(mshdr->eaddr2, hdr->addr4, ETH_ALEN);\r\n}\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nrcu_read_lock();\r\nnext_hop = rcu_dereference(gate_mpath->next_hop)->sta.addr;\r\nmemcpy(hdr->addr1, next_hop, ETH_ALEN);\r\nrcu_read_unlock();\r\nmemcpy(hdr->addr2, gate_mpath->sdata->vif.addr, ETH_ALEN);\r\nmemcpy(hdr->addr3, dst_addr, ETH_ALEN);\r\n}\r\nstatic void mesh_path_move_to_queue(struct mesh_path *gate_mpath,\r\nstruct mesh_path *from_mpath,\r\nbool copy)\r\n{\r\nstruct sk_buff *skb, *fskb, *tmp;\r\nstruct sk_buff_head failq;\r\nunsigned long flags;\r\nif (WARN_ON(gate_mpath == from_mpath))\r\nreturn;\r\nif (WARN_ON(!gate_mpath->next_hop))\r\nreturn;\r\n__skb_queue_head_init(&failq);\r\nspin_lock_irqsave(&from_mpath->frame_queue.lock, flags);\r\nskb_queue_splice_init(&from_mpath->frame_queue, &failq);\r\nspin_unlock_irqrestore(&from_mpath->frame_queue.lock, flags);\r\nskb_queue_walk_safe(&failq, fskb, tmp) {\r\nif (skb_queue_len(&gate_mpath->frame_queue) >=\r\nMESH_FRAME_QUEUE_LEN) {\r\nmpath_dbg(gate_mpath->sdata, "mpath queue full!\n");\r\nbreak;\r\n}\r\nskb = skb_copy(fskb, GFP_ATOMIC);\r\nif (WARN_ON(!skb))\r\nbreak;\r\nprepare_for_gate(skb, gate_mpath->dst, gate_mpath);\r\nskb_queue_tail(&gate_mpath->frame_queue, skb);\r\nif (copy)\r\ncontinue;\r\n__skb_unlink(fskb, &failq);\r\nkfree_skb(fskb);\r\n}\r\nmpath_dbg(gate_mpath->sdata, "Mpath queue for gate %pM has %d frames\n",\r\ngate_mpath->dst, skb_queue_len(&gate_mpath->frame_queue));\r\nif (!copy)\r\nreturn;\r\nspin_lock_irqsave(&from_mpath->frame_queue.lock, flags);\r\nskb_queue_splice(&failq, &from_mpath->frame_queue);\r\nspin_unlock_irqrestore(&from_mpath->frame_queue.lock, flags);\r\n}\r\nstatic struct mesh_path *mpath_lookup(struct mesh_table *tbl, const u8 *dst,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct mesh_path *mpath;\r\nmpath = rhashtable_lookup_fast(&tbl->rhead, dst, mesh_rht_params);\r\nif (mpath && mpath_expired(mpath)) {\r\nspin_lock_bh(&mpath->state_lock);\r\nmpath->flags &= ~MESH_PATH_ACTIVE;\r\nspin_unlock_bh(&mpath->state_lock);\r\n}\r\nreturn mpath;\r\n}\r\nstruct mesh_path *\r\nmesh_path_lookup(struct ieee80211_sub_if_data *sdata, const u8 *dst)\r\n{\r\nreturn mpath_lookup(sdata->u.mesh.mesh_paths, dst, sdata);\r\n}\r\nstruct mesh_path *\r\nmpp_path_lookup(struct ieee80211_sub_if_data *sdata, const u8 *dst)\r\n{\r\nreturn mpath_lookup(sdata->u.mesh.mpp_paths, dst, sdata);\r\n}\r\nstatic struct mesh_path *\r\n__mesh_path_lookup_by_idx(struct mesh_table *tbl, int idx)\r\n{\r\nint i = 0, ret;\r\nstruct mesh_path *mpath = NULL;\r\nstruct rhashtable_iter iter;\r\nret = rhashtable_walk_init(&tbl->rhead, &iter, GFP_ATOMIC);\r\nif (ret)\r\nreturn NULL;\r\nret = rhashtable_walk_start(&iter);\r\nif (ret && ret != -EAGAIN)\r\ngoto err;\r\nwhile ((mpath = rhashtable_walk_next(&iter))) {\r\nif (IS_ERR(mpath) && PTR_ERR(mpath) == -EAGAIN)\r\ncontinue;\r\nif (IS_ERR(mpath))\r\nbreak;\r\nif (i++ == idx)\r\nbreak;\r\n}\r\nerr:\r\nrhashtable_walk_stop(&iter);\r\nrhashtable_walk_exit(&iter);\r\nif (IS_ERR(mpath) || !mpath)\r\nreturn NULL;\r\nif (mpath_expired(mpath)) {\r\nspin_lock_bh(&mpath->state_lock);\r\nmpath->flags &= ~MESH_PATH_ACTIVE;\r\nspin_unlock_bh(&mpath->state_lock);\r\n}\r\nreturn mpath;\r\n}\r\nstruct mesh_path *\r\nmesh_path_lookup_by_idx(struct ieee80211_sub_if_data *sdata, int idx)\r\n{\r\nreturn __mesh_path_lookup_by_idx(sdata->u.mesh.mesh_paths, idx);\r\n}\r\nstruct mesh_path *\r\nmpp_path_lookup_by_idx(struct ieee80211_sub_if_data *sdata, int idx)\r\n{\r\nreturn __mesh_path_lookup_by_idx(sdata->u.mesh.mpp_paths, idx);\r\n}\r\nint mesh_path_add_gate(struct mesh_path *mpath)\r\n{\r\nstruct mesh_table *tbl;\r\nint err;\r\nrcu_read_lock();\r\ntbl = mpath->sdata->u.mesh.mesh_paths;\r\nspin_lock_bh(&mpath->state_lock);\r\nif (mpath->is_gate) {\r\nerr = -EEXIST;\r\nspin_unlock_bh(&mpath->state_lock);\r\ngoto err_rcu;\r\n}\r\nmpath->is_gate = true;\r\nmpath->sdata->u.mesh.num_gates++;\r\nspin_lock(&tbl->gates_lock);\r\nhlist_add_head_rcu(&mpath->gate_list, &tbl->known_gates);\r\nspin_unlock(&tbl->gates_lock);\r\nspin_unlock_bh(&mpath->state_lock);\r\nmpath_dbg(mpath->sdata,\r\n"Mesh path: Recorded new gate: %pM. %d known gates\n",\r\nmpath->dst, mpath->sdata->u.mesh.num_gates);\r\nerr = 0;\r\nerr_rcu:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic void mesh_gate_del(struct mesh_table *tbl, struct mesh_path *mpath)\r\n{\r\nlockdep_assert_held(&mpath->state_lock);\r\nif (!mpath->is_gate)\r\nreturn;\r\nmpath->is_gate = false;\r\nspin_lock_bh(&tbl->gates_lock);\r\nhlist_del_rcu(&mpath->gate_list);\r\nmpath->sdata->u.mesh.num_gates--;\r\nspin_unlock_bh(&tbl->gates_lock);\r\nmpath_dbg(mpath->sdata,\r\n"Mesh path: Deleted gate: %pM. %d known gates\n",\r\nmpath->dst, mpath->sdata->u.mesh.num_gates);\r\n}\r\nint mesh_gate_num(struct ieee80211_sub_if_data *sdata)\r\n{\r\nreturn sdata->u.mesh.num_gates;\r\n}\r\nstatic\r\nstruct mesh_path *mesh_path_new(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *dst, gfp_t gfp_flags)\r\n{\r\nstruct mesh_path *new_mpath;\r\nnew_mpath = kzalloc(sizeof(struct mesh_path), gfp_flags);\r\nif (!new_mpath)\r\nreturn NULL;\r\nmemcpy(new_mpath->dst, dst, ETH_ALEN);\r\neth_broadcast_addr(new_mpath->rann_snd_addr);\r\nnew_mpath->is_root = false;\r\nnew_mpath->sdata = sdata;\r\nnew_mpath->flags = 0;\r\nskb_queue_head_init(&new_mpath->frame_queue);\r\nnew_mpath->timer.data = (unsigned long) new_mpath;\r\nnew_mpath->timer.function = mesh_path_timer;\r\nnew_mpath->exp_time = jiffies;\r\nspin_lock_init(&new_mpath->state_lock);\r\ninit_timer(&new_mpath->timer);\r\nreturn new_mpath;\r\n}\r\nstruct mesh_path *mesh_path_add(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *dst)\r\n{\r\nstruct mesh_table *tbl;\r\nstruct mesh_path *mpath, *new_mpath;\r\nint ret;\r\nif (ether_addr_equal(dst, sdata->vif.addr))\r\nreturn ERR_PTR(-ENOTSUPP);\r\nif (is_multicast_ether_addr(dst))\r\nreturn ERR_PTR(-ENOTSUPP);\r\nif (atomic_add_unless(&sdata->u.mesh.mpaths, 1, MESH_MAX_MPATHS) == 0)\r\nreturn ERR_PTR(-ENOSPC);\r\nnew_mpath = mesh_path_new(sdata, dst, GFP_ATOMIC);\r\nif (!new_mpath)\r\nreturn ERR_PTR(-ENOMEM);\r\ntbl = sdata->u.mesh.mesh_paths;\r\ndo {\r\nret = rhashtable_lookup_insert_fast(&tbl->rhead,\r\n&new_mpath->rhash,\r\nmesh_rht_params);\r\nif (ret == -EEXIST)\r\nmpath = rhashtable_lookup_fast(&tbl->rhead,\r\ndst,\r\nmesh_rht_params);\r\n} while (unlikely(ret == -EEXIST && !mpath));\r\nif (ret && ret != -EEXIST)\r\nreturn ERR_PTR(ret);\r\nif (ret == -EEXIST) {\r\nkfree(new_mpath);\r\nnew_mpath = mpath;\r\n}\r\nsdata->u.mesh.mesh_paths_generation++;\r\nreturn new_mpath;\r\n}\r\nint mpp_path_add(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *dst, const u8 *mpp)\r\n{\r\nstruct mesh_table *tbl;\r\nstruct mesh_path *new_mpath;\r\nint ret;\r\nif (ether_addr_equal(dst, sdata->vif.addr))\r\nreturn -ENOTSUPP;\r\nif (is_multicast_ether_addr(dst))\r\nreturn -ENOTSUPP;\r\nnew_mpath = mesh_path_new(sdata, dst, GFP_ATOMIC);\r\nif (!new_mpath)\r\nreturn -ENOMEM;\r\nmemcpy(new_mpath->mpp, mpp, ETH_ALEN);\r\ntbl = sdata->u.mesh.mpp_paths;\r\nret = rhashtable_lookup_insert_fast(&tbl->rhead,\r\n&new_mpath->rhash,\r\nmesh_rht_params);\r\nsdata->u.mesh.mpp_paths_generation++;\r\nreturn ret;\r\n}\r\nvoid mesh_plink_broken(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct mesh_table *tbl = sdata->u.mesh.mesh_paths;\r\nstatic const u8 bcast[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct mesh_path *mpath;\r\nstruct rhashtable_iter iter;\r\nint ret;\r\nret = rhashtable_walk_init(&tbl->rhead, &iter, GFP_ATOMIC);\r\nif (ret)\r\nreturn;\r\nret = rhashtable_walk_start(&iter);\r\nif (ret && ret != -EAGAIN)\r\ngoto out;\r\nwhile ((mpath = rhashtable_walk_next(&iter))) {\r\nif (IS_ERR(mpath) && PTR_ERR(mpath) == -EAGAIN)\r\ncontinue;\r\nif (IS_ERR(mpath))\r\nbreak;\r\nif (rcu_access_pointer(mpath->next_hop) == sta &&\r\nmpath->flags & MESH_PATH_ACTIVE &&\r\n!(mpath->flags & MESH_PATH_FIXED)) {\r\nspin_lock_bh(&mpath->state_lock);\r\nmpath->flags &= ~MESH_PATH_ACTIVE;\r\n++mpath->sn;\r\nspin_unlock_bh(&mpath->state_lock);\r\nmesh_path_error_tx(sdata,\r\nsdata->u.mesh.mshcfg.element_ttl,\r\nmpath->dst, mpath->sn,\r\nWLAN_REASON_MESH_PATH_DEST_UNREACHABLE, bcast);\r\n}\r\n}\r\nout:\r\nrhashtable_walk_stop(&iter);\r\nrhashtable_walk_exit(&iter);\r\n}\r\nstatic void mesh_path_free_rcu(struct mesh_table *tbl,\r\nstruct mesh_path *mpath)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = mpath->sdata;\r\nspin_lock_bh(&mpath->state_lock);\r\nmpath->flags |= MESH_PATH_RESOLVING | MESH_PATH_DELETED;\r\nmesh_gate_del(tbl, mpath);\r\nspin_unlock_bh(&mpath->state_lock);\r\ndel_timer_sync(&mpath->timer);\r\natomic_dec(&sdata->u.mesh.mpaths);\r\natomic_dec(&tbl->entries);\r\nkfree_rcu(mpath, rcu);\r\n}\r\nstatic void __mesh_path_del(struct mesh_table *tbl, struct mesh_path *mpath)\r\n{\r\nrhashtable_remove_fast(&tbl->rhead, &mpath->rhash, mesh_rht_params);\r\nmesh_path_free_rcu(tbl, mpath);\r\n}\r\nvoid mesh_path_flush_by_nexthop(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct mesh_table *tbl = sdata->u.mesh.mesh_paths;\r\nstruct mesh_path *mpath;\r\nstruct rhashtable_iter iter;\r\nint ret;\r\nret = rhashtable_walk_init(&tbl->rhead, &iter, GFP_ATOMIC);\r\nif (ret)\r\nreturn;\r\nret = rhashtable_walk_start(&iter);\r\nif (ret && ret != -EAGAIN)\r\ngoto out;\r\nwhile ((mpath = rhashtable_walk_next(&iter))) {\r\nif (IS_ERR(mpath) && PTR_ERR(mpath) == -EAGAIN)\r\ncontinue;\r\nif (IS_ERR(mpath))\r\nbreak;\r\nif (rcu_access_pointer(mpath->next_hop) == sta)\r\n__mesh_path_del(tbl, mpath);\r\n}\r\nout:\r\nrhashtable_walk_stop(&iter);\r\nrhashtable_walk_exit(&iter);\r\n}\r\nstatic void mpp_flush_by_proxy(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *proxy)\r\n{\r\nstruct mesh_table *tbl = sdata->u.mesh.mpp_paths;\r\nstruct mesh_path *mpath;\r\nstruct rhashtable_iter iter;\r\nint ret;\r\nret = rhashtable_walk_init(&tbl->rhead, &iter, GFP_ATOMIC);\r\nif (ret)\r\nreturn;\r\nret = rhashtable_walk_start(&iter);\r\nif (ret && ret != -EAGAIN)\r\ngoto out;\r\nwhile ((mpath = rhashtable_walk_next(&iter))) {\r\nif (IS_ERR(mpath) && PTR_ERR(mpath) == -EAGAIN)\r\ncontinue;\r\nif (IS_ERR(mpath))\r\nbreak;\r\nif (ether_addr_equal(mpath->mpp, proxy))\r\n__mesh_path_del(tbl, mpath);\r\n}\r\nout:\r\nrhashtable_walk_stop(&iter);\r\nrhashtable_walk_exit(&iter);\r\n}\r\nstatic void table_flush_by_iface(struct mesh_table *tbl)\r\n{\r\nstruct mesh_path *mpath;\r\nstruct rhashtable_iter iter;\r\nint ret;\r\nret = rhashtable_walk_init(&tbl->rhead, &iter, GFP_ATOMIC);\r\nif (ret)\r\nreturn;\r\nret = rhashtable_walk_start(&iter);\r\nif (ret && ret != -EAGAIN)\r\ngoto out;\r\nwhile ((mpath = rhashtable_walk_next(&iter))) {\r\nif (IS_ERR(mpath) && PTR_ERR(mpath) == -EAGAIN)\r\ncontinue;\r\nif (IS_ERR(mpath))\r\nbreak;\r\n__mesh_path_del(tbl, mpath);\r\n}\r\nout:\r\nrhashtable_walk_stop(&iter);\r\nrhashtable_walk_exit(&iter);\r\n}\r\nvoid mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata)\r\n{\r\ntable_flush_by_iface(sdata->u.mesh.mesh_paths);\r\ntable_flush_by_iface(sdata->u.mesh.mpp_paths);\r\n}\r\nstatic int table_path_del(struct mesh_table *tbl,\r\nstruct ieee80211_sub_if_data *sdata,\r\nconst u8 *addr)\r\n{\r\nstruct mesh_path *mpath;\r\nrcu_read_lock();\r\nmpath = rhashtable_lookup_fast(&tbl->rhead, addr, mesh_rht_params);\r\nif (!mpath) {\r\nrcu_read_unlock();\r\nreturn -ENXIO;\r\n}\r\n__mesh_path_del(tbl, mpath);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint mesh_path_del(struct ieee80211_sub_if_data *sdata, const u8 *addr)\r\n{\r\nint err;\r\nmpp_flush_by_proxy(sdata, addr);\r\nerr = table_path_del(sdata->u.mesh.mesh_paths, sdata, addr);\r\nsdata->u.mesh.mesh_paths_generation++;\r\nreturn err;\r\n}\r\nvoid mesh_path_tx_pending(struct mesh_path *mpath)\r\n{\r\nif (mpath->flags & MESH_PATH_ACTIVE)\r\nieee80211_add_pending_skbs(mpath->sdata->local,\r\n&mpath->frame_queue);\r\n}\r\nint mesh_path_send_to_gates(struct mesh_path *mpath)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = mpath->sdata;\r\nstruct mesh_table *tbl;\r\nstruct mesh_path *from_mpath = mpath;\r\nstruct mesh_path *gate;\r\nbool copy = false;\r\ntbl = sdata->u.mesh.mesh_paths;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gate, &tbl->known_gates, gate_list) {\r\nif (gate->flags & MESH_PATH_ACTIVE) {\r\nmpath_dbg(sdata, "Forwarding to %pM\n", gate->dst);\r\nmesh_path_move_to_queue(gate, from_mpath, copy);\r\nfrom_mpath = gate;\r\ncopy = true;\r\n} else {\r\nmpath_dbg(sdata,\r\n"Not forwarding to %pM (flags %#x)\n",\r\ngate->dst, gate->flags);\r\n}\r\n}\r\nhlist_for_each_entry_rcu(gate, &tbl->known_gates, gate_list) {\r\nmpath_dbg(sdata, "Sending to %pM\n", gate->dst);\r\nmesh_path_tx_pending(gate);\r\n}\r\nrcu_read_unlock();\r\nreturn (from_mpath == mpath) ? -EHOSTUNREACH : 0;\r\n}\r\nvoid mesh_path_discard_frame(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nkfree_skb(skb);\r\nsdata->u.mesh.mshstats.dropped_frames_no_route++;\r\n}\r\nvoid mesh_path_flush_pending(struct mesh_path *mpath)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&mpath->frame_queue)) != NULL)\r\nmesh_path_discard_frame(mpath->sdata, skb);\r\n}\r\nvoid mesh_path_fix_nexthop(struct mesh_path *mpath, struct sta_info *next_hop)\r\n{\r\nspin_lock_bh(&mpath->state_lock);\r\nmesh_path_assign_nexthop(mpath, next_hop);\r\nmpath->sn = 0xffff;\r\nmpath->metric = 0;\r\nmpath->hop_count = 0;\r\nmpath->exp_time = 0;\r\nmpath->flags = MESH_PATH_FIXED | MESH_PATH_SN_VALID;\r\nmesh_path_activate(mpath);\r\nspin_unlock_bh(&mpath->state_lock);\r\nmesh_path_tx_pending(mpath);\r\n}\r\nint mesh_pathtbl_init(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct mesh_table *tbl_path, *tbl_mpp;\r\nint ret;\r\ntbl_path = mesh_table_alloc();\r\nif (!tbl_path)\r\nreturn -ENOMEM;\r\ntbl_mpp = mesh_table_alloc();\r\nif (!tbl_mpp) {\r\nret = -ENOMEM;\r\ngoto free_path;\r\n}\r\nrhashtable_init(&tbl_path->rhead, &mesh_rht_params);\r\nrhashtable_init(&tbl_mpp->rhead, &mesh_rht_params);\r\nsdata->u.mesh.mesh_paths = tbl_path;\r\nsdata->u.mesh.mpp_paths = tbl_mpp;\r\nreturn 0;\r\nfree_path:\r\nmesh_table_free(tbl_path);\r\nreturn ret;\r\n}\r\nstatic\r\nvoid mesh_path_tbl_expire(struct ieee80211_sub_if_data *sdata,\r\nstruct mesh_table *tbl)\r\n{\r\nstruct mesh_path *mpath;\r\nstruct rhashtable_iter iter;\r\nint ret;\r\nret = rhashtable_walk_init(&tbl->rhead, &iter, GFP_KERNEL);\r\nif (ret)\r\nreturn;\r\nret = rhashtable_walk_start(&iter);\r\nif (ret && ret != -EAGAIN)\r\ngoto out;\r\nwhile ((mpath = rhashtable_walk_next(&iter))) {\r\nif (IS_ERR(mpath) && PTR_ERR(mpath) == -EAGAIN)\r\ncontinue;\r\nif (IS_ERR(mpath))\r\nbreak;\r\nif ((!(mpath->flags & MESH_PATH_RESOLVING)) &&\r\n(!(mpath->flags & MESH_PATH_FIXED)) &&\r\ntime_after(jiffies, mpath->exp_time + MESH_PATH_EXPIRE))\r\n__mesh_path_del(tbl, mpath);\r\n}\r\nout:\r\nrhashtable_walk_stop(&iter);\r\nrhashtable_walk_exit(&iter);\r\n}\r\nvoid mesh_path_expire(struct ieee80211_sub_if_data *sdata)\r\n{\r\nmesh_path_tbl_expire(sdata, sdata->u.mesh.mesh_paths);\r\nmesh_path_tbl_expire(sdata, sdata->u.mesh.mpp_paths);\r\n}\r\nvoid mesh_pathtbl_unregister(struct ieee80211_sub_if_data *sdata)\r\n{\r\nmesh_table_free(sdata->u.mesh.mesh_paths);\r\nmesh_table_free(sdata->u.mesh.mpp_paths);\r\n}
