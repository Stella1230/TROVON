struct ipx_interface *ipx_interfaces_head(void)\r\n{\r\nstruct ipx_interface *rc = NULL;\r\nif (!list_empty(&ipx_interfaces))\r\nrc = list_entry(ipx_interfaces.next,\r\nstruct ipx_interface, node);\r\nreturn rc;\r\n}\r\nstatic void ipxcfg_set_auto_select(char val)\r\n{\r\nipxcfg_auto_select_primary = val;\r\nif (val && !ipx_primary_net)\r\nipx_primary_net = ipx_interfaces_head();\r\n}\r\nstatic int ipxcfg_get_config_data(struct ipx_config_data __user *arg)\r\n{\r\nstruct ipx_config_data vals;\r\nvals.ipxcfg_auto_create_interfaces = ipxcfg_auto_create_interfaces;\r\nvals.ipxcfg_auto_select_primary = ipxcfg_auto_select_primary;\r\nreturn copy_to_user(arg, &vals, sizeof(vals)) ? -EFAULT : 0;\r\n}\r\nstatic void ipx_remove_socket(struct sock *sk)\r\n{\r\nstruct ipx_interface *intrfc = ipx_sk(sk)->intrfc;\r\nif (!intrfc)\r\ngoto out;\r\nipxitf_hold(intrfc);\r\nspin_lock_bh(&intrfc->if_sklist_lock);\r\nsk_del_node_init(sk);\r\nspin_unlock_bh(&intrfc->if_sklist_lock);\r\nipxitf_put(intrfc);\r\nout:\r\nreturn;\r\n}\r\nstatic void ipx_destroy_socket(struct sock *sk)\r\n{\r\nipx_remove_socket(sk);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nsk_refcnt_debug_dec(sk);\r\n}\r\nstatic void ipxitf_clear_primary_net(void)\r\n{\r\nipx_primary_net = NULL;\r\nif (ipxcfg_auto_select_primary)\r\nipx_primary_net = ipx_interfaces_head();\r\n}\r\nstatic struct ipx_interface *__ipxitf_find_using_phys(struct net_device *dev,\r\n__be16 datalink)\r\n{\r\nstruct ipx_interface *i;\r\nlist_for_each_entry(i, &ipx_interfaces, node)\r\nif (i->if_dev == dev && i->if_dlink_type == datalink)\r\ngoto out;\r\ni = NULL;\r\nout:\r\nreturn i;\r\n}\r\nstatic struct ipx_interface *ipxitf_find_using_phys(struct net_device *dev,\r\n__be16 datalink)\r\n{\r\nstruct ipx_interface *i;\r\nspin_lock_bh(&ipx_interfaces_lock);\r\ni = __ipxitf_find_using_phys(dev, datalink);\r\nif (i)\r\nipxitf_hold(i);\r\nspin_unlock_bh(&ipx_interfaces_lock);\r\nreturn i;\r\n}\r\nstruct ipx_interface *ipxitf_find_using_net(__be32 net)\r\n{\r\nstruct ipx_interface *i;\r\nspin_lock_bh(&ipx_interfaces_lock);\r\nif (net) {\r\nlist_for_each_entry(i, &ipx_interfaces, node)\r\nif (i->if_netnum == net)\r\ngoto hold;\r\ni = NULL;\r\ngoto unlock;\r\n}\r\ni = ipx_primary_net;\r\nif (i)\r\nhold:\r\nipxitf_hold(i);\r\nunlock:\r\nspin_unlock_bh(&ipx_interfaces_lock);\r\nreturn i;\r\n}\r\nstatic void ipxitf_insert_socket(struct ipx_interface *intrfc, struct sock *sk)\r\n{\r\nipxitf_hold(intrfc);\r\nspin_lock_bh(&intrfc->if_sklist_lock);\r\nipx_sk(sk)->intrfc = intrfc;\r\nsk_add_node(sk, &intrfc->if_sklist);\r\nspin_unlock_bh(&intrfc->if_sklist_lock);\r\nipxitf_put(intrfc);\r\n}\r\nstatic struct sock *__ipxitf_find_socket(struct ipx_interface *intrfc,\r\n__be16 port)\r\n{\r\nstruct sock *s;\r\nsk_for_each(s, &intrfc->if_sklist)\r\nif (ipx_sk(s)->port == port)\r\ngoto found;\r\ns = NULL;\r\nfound:\r\nreturn s;\r\n}\r\nstatic struct sock *ipxitf_find_socket(struct ipx_interface *intrfc,\r\n__be16 port)\r\n{\r\nstruct sock *s;\r\nspin_lock_bh(&intrfc->if_sklist_lock);\r\ns = __ipxitf_find_socket(intrfc, port);\r\nif (s)\r\nsock_hold(s);\r\nspin_unlock_bh(&intrfc->if_sklist_lock);\r\nreturn s;\r\n}\r\nstatic struct sock *ipxitf_find_internal_socket(struct ipx_interface *intrfc,\r\nunsigned char *ipx_node,\r\n__be16 port)\r\n{\r\nstruct sock *s;\r\nipxitf_hold(intrfc);\r\nspin_lock_bh(&intrfc->if_sklist_lock);\r\nsk_for_each(s, &intrfc->if_sklist) {\r\nstruct ipx_sock *ipxs = ipx_sk(s);\r\nif (ipxs->port == port &&\r\n!memcmp(ipx_node, ipxs->node, IPX_NODE_LEN))\r\ngoto found;\r\n}\r\ns = NULL;\r\nfound:\r\nspin_unlock_bh(&intrfc->if_sklist_lock);\r\nipxitf_put(intrfc);\r\nreturn s;\r\n}\r\nstatic void __ipxitf_down(struct ipx_interface *intrfc)\r\n{\r\nstruct sock *s;\r\nstruct hlist_node *t;\r\nipxrtr_del_routes(intrfc);\r\nspin_lock_bh(&intrfc->if_sklist_lock);\r\nsk_for_each_safe(s, t, &intrfc->if_sklist) {\r\nstruct ipx_sock *ipxs = ipx_sk(s);\r\ns->sk_err = ENOLINK;\r\ns->sk_error_report(s);\r\nipxs->intrfc = NULL;\r\nipxs->port = 0;\r\nsock_set_flag(s, SOCK_ZAPPED);\r\nsk_del_node_init(s);\r\n}\r\nINIT_HLIST_HEAD(&intrfc->if_sklist);\r\nspin_unlock_bh(&intrfc->if_sklist_lock);\r\nlist_del(&intrfc->node);\r\nif (intrfc == ipx_primary_net)\r\nipxitf_clear_primary_net();\r\nif (intrfc == ipx_internal_net)\r\nipx_internal_net = NULL;\r\nif (intrfc->if_dev)\r\ndev_put(intrfc->if_dev);\r\nkfree(intrfc);\r\n}\r\nvoid ipxitf_down(struct ipx_interface *intrfc)\r\n{\r\nspin_lock_bh(&ipx_interfaces_lock);\r\n__ipxitf_down(intrfc);\r\nspin_unlock_bh(&ipx_interfaces_lock);\r\n}\r\nstatic void __ipxitf_put(struct ipx_interface *intrfc)\r\n{\r\nif (atomic_dec_and_test(&intrfc->refcnt))\r\n__ipxitf_down(intrfc);\r\n}\r\nstatic int ipxitf_device_event(struct notifier_block *notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct ipx_interface *i, *tmp;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (event != NETDEV_DOWN && event != NETDEV_UP)\r\ngoto out;\r\nspin_lock_bh(&ipx_interfaces_lock);\r\nlist_for_each_entry_safe(i, tmp, &ipx_interfaces, node)\r\nif (i->if_dev == dev) {\r\nif (event == NETDEV_UP)\r\nipxitf_hold(i);\r\nelse\r\n__ipxitf_put(i);\r\n}\r\nspin_unlock_bh(&ipx_interfaces_lock);\r\nout:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic __exit void ipxitf_cleanup(void)\r\n{\r\nstruct ipx_interface *i, *tmp;\r\nspin_lock_bh(&ipx_interfaces_lock);\r\nlist_for_each_entry_safe(i, tmp, &ipx_interfaces, node)\r\n__ipxitf_put(i);\r\nspin_unlock_bh(&ipx_interfaces_lock);\r\n}\r\nstatic void ipxitf_def_skb_handler(struct sock *sock, struct sk_buff *skb)\r\n{\r\nif (sock_queue_rcv_skb(sock, skb) < 0)\r\nkfree_skb(skb);\r\n}\r\nstatic int ipxitf_demux_socket(struct ipx_interface *intrfc,\r\nstruct sk_buff *skb, int copy)\r\n{\r\nstruct ipxhdr *ipx = ipx_hdr(skb);\r\nint is_broadcast = !memcmp(ipx->ipx_dest.node, ipx_broadcast_node,\r\nIPX_NODE_LEN);\r\nstruct sock *s;\r\nint rc;\r\nspin_lock_bh(&intrfc->if_sklist_lock);\r\nsk_for_each(s, &intrfc->if_sklist) {\r\nstruct ipx_sock *ipxs = ipx_sk(s);\r\nif (ipxs->port == ipx->ipx_dest.sock &&\r\n(is_broadcast || !memcmp(ipx->ipx_dest.node,\r\nipxs->node, IPX_NODE_LEN))) {\r\nstruct sk_buff *skb1;\r\nif (copy) {\r\nskb1 = skb_clone(skb, GFP_ATOMIC);\r\nrc = -ENOMEM;\r\nif (!skb1)\r\ngoto out;\r\n} else {\r\nskb1 = skb;\r\ncopy = 1;\r\n}\r\nipxitf_def_skb_handler(s, skb1);\r\nif (intrfc != ipx_internal_net)\r\nbreak;\r\n}\r\n}\r\nif (!copy)\r\nkfree_skb(skb);\r\nrc = 0;\r\nout:\r\nspin_unlock_bh(&intrfc->if_sklist_lock);\r\nreturn rc;\r\n}\r\nstatic struct sock *ncp_connection_hack(struct ipx_interface *intrfc,\r\nstruct ipxhdr *ipx)\r\n{\r\nstruct sock *sk = NULL;\r\nint connection = 0;\r\nu8 *ncphdr = (u8 *)(ipx + 1);\r\nif (*ncphdr == 0x22 && *(ncphdr + 1) == 0x22)\r\nconnection = (((int) *(ncphdr + 5)) << 8) | (int) *(ncphdr + 3);\r\nelse if (*ncphdr == 0x77 && *(ncphdr + 1) == 0x77)\r\nconnection = (((int) *(ncphdr + 9)) << 8) | (int) *(ncphdr + 8);\r\nif (connection) {\r\nspin_lock_bh(&intrfc->if_sklist_lock);\r\nsk_for_each(sk, &intrfc->if_sklist)\r\nif (ipx_sk(sk)->ipx_ncp_conn == connection) {\r\nsock_hold(sk);\r\ngoto found;\r\n}\r\nsk = NULL;\r\nfound:\r\nspin_unlock_bh(&intrfc->if_sklist_lock);\r\n}\r\nreturn sk;\r\n}\r\nstatic int ipxitf_demux_socket(struct ipx_interface *intrfc,\r\nstruct sk_buff *skb, int copy)\r\n{\r\nstruct ipxhdr *ipx = ipx_hdr(skb);\r\nstruct sock *sock1 = NULL, *sock2 = NULL;\r\nstruct sk_buff *skb1 = NULL, *skb2 = NULL;\r\nint rc;\r\nif (intrfc == ipx_primary_net && ntohs(ipx->ipx_dest.sock) == 0x451)\r\nsock1 = ncp_connection_hack(intrfc, ipx);\r\nif (!sock1)\r\nsock1 = ipxitf_find_socket(intrfc, ipx->ipx_dest.sock);\r\nif (ipx_primary_net && intrfc != ipx_primary_net) {\r\nconst int dsock = ntohs(ipx->ipx_dest.sock);\r\nif (dsock == 0x452 || dsock == 0x453 || dsock == 0x456)\r\nsock2 = ipxitf_find_socket(ipx_primary_net,\r\nipx->ipx_dest.sock);\r\n}\r\nrc = 0;\r\nif (!sock1 && !sock2) {\r\nif (!copy)\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nif (copy)\r\nskb1 = skb_clone(skb, GFP_ATOMIC);\r\nelse\r\nskb1 = skb;\r\nrc = -ENOMEM;\r\nif (!skb1)\r\ngoto out_put;\r\nif (sock1 && sock2)\r\nskb2 = skb_clone(skb1, GFP_ATOMIC);\r\nelse\r\nskb2 = skb1;\r\nif (sock1)\r\nipxitf_def_skb_handler(sock1, skb1);\r\nif (!skb2)\r\ngoto out_put;\r\nif (sock2)\r\nipxitf_def_skb_handler(sock2, skb2);\r\nrc = 0;\r\nout_put:\r\nif (sock1)\r\nsock_put(sock1);\r\nif (sock2)\r\nsock_put(sock2);\r\nout:\r\nreturn rc;\r\n}\r\nstatic struct sk_buff *ipxitf_adjust_skbuff(struct ipx_interface *intrfc,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *skb2;\r\nint in_offset = (unsigned char *)ipx_hdr(skb) - skb->head;\r\nint out_offset = intrfc->if_ipx_offset;\r\nint len;\r\nif (in_offset >= out_offset)\r\nreturn skb;\r\nlen = skb->len + out_offset;\r\nskb2 = alloc_skb(len, GFP_ATOMIC);\r\nif (skb2) {\r\nskb_reserve(skb2, out_offset);\r\nskb_reset_network_header(skb2);\r\nskb_reset_transport_header(skb2);\r\nskb_put(skb2, skb->len);\r\nmemcpy(ipx_hdr(skb2), ipx_hdr(skb), skb->len);\r\nmemcpy(skb2->cb, skb->cb, sizeof(skb->cb));\r\n}\r\nkfree_skb(skb);\r\nreturn skb2;\r\n}\r\nint ipxitf_send(struct ipx_interface *intrfc, struct sk_buff *skb, char *node)\r\n{\r\nstruct ipxhdr *ipx = ipx_hdr(skb);\r\nstruct net_device *dev = intrfc->if_dev;\r\nstruct datalink_proto *dl = intrfc->if_dlink;\r\nchar dest_node[IPX_NODE_LEN];\r\nint send_to_wire = 1;\r\nint addr_len;\r\nipx->ipx_tctrl = IPX_SKB_CB(skb)->ipx_tctrl;\r\nipx->ipx_dest.net = IPX_SKB_CB(skb)->ipx_dest_net;\r\nipx->ipx_source.net = IPX_SKB_CB(skb)->ipx_source_net;\r\nif (IPX_SKB_CB(skb)->last_hop.index >= 0) {\r\n__be32 *last_hop = (__be32 *)(((u8 *) skb->data) +\r\nsizeof(struct ipxhdr) +\r\nIPX_SKB_CB(skb)->last_hop.index *\r\nsizeof(__be32));\r\n*last_hop = IPX_SKB_CB(skb)->last_hop.netnum;\r\nIPX_SKB_CB(skb)->last_hop.index = -1;\r\n}\r\nif (!dl || !dev || dev->flags & IFF_LOOPBACK)\r\nsend_to_wire = 0;\r\nif (ipx->ipx_dest.net == intrfc->if_netnum) {\r\nif (intrfc == ipx_internal_net ||\r\n!memcmp(intrfc->if_node, node, IPX_NODE_LEN)) {\r\nskb_orphan(skb);\r\nreturn ipxitf_demux_socket(intrfc, skb, 0);\r\n}\r\nif (!memcmp(ipx_broadcast_node, node, IPX_NODE_LEN)) {\r\nif (!send_to_wire)\r\nskb_orphan(skb);\r\nipxitf_demux_socket(intrfc, skb, send_to_wire);\r\nif (!send_to_wire)\r\ngoto out;\r\n}\r\n}\r\nif (ipx->ipx_source.net != intrfc->if_netnum) {\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (!skb)\r\ngoto out;\r\nif (++ipx->ipx_tctrl > ipxcfg_max_hops)\r\nsend_to_wire = 0;\r\n}\r\nif (!send_to_wire) {\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\naddr_len = dev->addr_len;\r\nif (!memcmp(ipx_broadcast_node, node, IPX_NODE_LEN))\r\nmemcpy(dest_node, dev->broadcast, addr_len);\r\nelse\r\nmemcpy(dest_node, &(node[IPX_NODE_LEN-addr_len]), addr_len);\r\nskb = ipxitf_adjust_skbuff(intrfc, skb);\r\nif (!skb)\r\ngoto out;\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_IPX);\r\ndl->request(dl, skb, dest_node);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int ipxitf_add_local_route(struct ipx_interface *intrfc)\r\n{\r\nreturn ipxrtr_add_route(intrfc->if_netnum, intrfc, NULL);\r\n}\r\nstatic int ipxitf_rcv(struct ipx_interface *intrfc, struct sk_buff *skb)\r\n{\r\nstruct ipxhdr *ipx = ipx_hdr(skb);\r\nint rc = 0;\r\nipxitf_hold(intrfc);\r\nif (!intrfc->if_netnum)\r\nipxitf_discover_netnum(intrfc, skb);\r\nIPX_SKB_CB(skb)->last_hop.index = -1;\r\nif (ipx->ipx_type == IPX_TYPE_PPROP) {\r\nrc = ipxitf_pprop(intrfc, skb);\r\nif (rc)\r\ngoto out_free_skb;\r\n}\r\nif (!IPX_SKB_CB(skb)->ipx_dest_net)\r\nIPX_SKB_CB(skb)->ipx_dest_net = intrfc->if_netnum;\r\nif (!IPX_SKB_CB(skb)->ipx_source_net)\r\nIPX_SKB_CB(skb)->ipx_source_net = intrfc->if_netnum;\r\nif (ipx->ipx_type != IPX_TYPE_PPROP &&\r\nintrfc->if_netnum != IPX_SKB_CB(skb)->ipx_dest_net) {\r\nif (skb->pkt_type == PACKET_HOST) {\r\nskb = skb_unshare(skb, GFP_ATOMIC);\r\nif (skb)\r\nrc = ipxrtr_route_skb(skb);\r\ngoto out_intrfc;\r\n}\r\ngoto out_free_skb;\r\n}\r\nif (!memcmp(ipx_broadcast_node, ipx->ipx_dest.node, IPX_NODE_LEN) ||\r\n!memcmp(intrfc->if_node, ipx->ipx_dest.node, IPX_NODE_LEN)) {\r\nrc = ipxitf_demux_socket(intrfc, skb, 0);\r\ngoto out_intrfc;\r\n}\r\nout_free_skb:\r\nkfree_skb(skb);\r\nout_intrfc:\r\nipxitf_put(intrfc);\r\nreturn rc;\r\n}\r\nstatic void ipxitf_discover_netnum(struct ipx_interface *intrfc,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct ipx_cb *cb = IPX_SKB_CB(skb);\r\nif (cb->ipx_source_net == cb->ipx_dest_net && cb->ipx_source_net) {\r\nstruct ipx_interface *i =\r\nipxitf_find_using_net(cb->ipx_source_net);\r\nif (!i) {\r\nintrfc->if_netnum = cb->ipx_source_net;\r\nipxitf_add_local_route(intrfc);\r\n} else {\r\nprintk(KERN_WARNING "IPX: Network number collision "\r\n"%lx\n %s %s and %s %s\n",\r\n(unsigned long) ntohl(cb->ipx_source_net),\r\nipx_device_name(i),\r\nipx_frame_name(i->if_dlink_type),\r\nipx_device_name(intrfc),\r\nipx_frame_name(intrfc->if_dlink_type));\r\nipxitf_put(i);\r\n}\r\n}\r\n}\r\nstatic int ipxitf_pprop(struct ipx_interface *intrfc, struct sk_buff *skb)\r\n{\r\nstruct ipxhdr *ipx = ipx_hdr(skb);\r\nint i, rc = -EINVAL;\r\nstruct ipx_interface *ifcs;\r\nchar *c;\r\n__be32 *l;\r\nif (IPX_SKB_CB(skb)->ipx_tctrl > IPX_MAX_PPROP_HOPS ||\r\nntohs(ipx->ipx_pktsize) < sizeof(struct ipxhdr) +\r\nIPX_MAX_PPROP_HOPS * sizeof(u32))\r\ngoto out;\r\nrc = 0;\r\nif (!sysctl_ipx_pprop_broadcasting)\r\ngoto out;\r\nif (IPX_SKB_CB(skb)->ipx_tctrl == IPX_MAX_PPROP_HOPS)\r\ngoto out;\r\nc = ((u8 *) ipx) + sizeof(struct ipxhdr);\r\nl = (__be32 *) c;\r\nfor (i = 0; i < IPX_SKB_CB(skb)->ipx_tctrl; i++)\r\nif (*l++ == intrfc->if_netnum)\r\ngoto out;\r\nIPX_SKB_CB(skb)->last_hop.index = i;\r\nIPX_SKB_CB(skb)->last_hop.netnum = intrfc->if_netnum;\r\nspin_lock_bh(&ipx_interfaces_lock);\r\nlist_for_each_entry(ifcs, &ipx_interfaces, node) {\r\nif (!ifcs->if_netnum)\r\ncontinue;\r\nif (ifcs == intrfc)\r\ncontinue;\r\nl = (__be32 *) c;\r\nfor (i = 0; i < IPX_SKB_CB(skb)->ipx_tctrl; i++)\r\nif (ifcs->if_netnum == *l++)\r\nbreak;\r\nif (i == IPX_SKB_CB(skb)->ipx_tctrl) {\r\nstruct sk_buff *s = skb_copy(skb, GFP_ATOMIC);\r\nif (s) {\r\nIPX_SKB_CB(s)->ipx_dest_net = ifcs->if_netnum;\r\nipxrtr_route_skb(s);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&ipx_interfaces_lock);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void ipxitf_insert(struct ipx_interface *intrfc)\r\n{\r\nspin_lock_bh(&ipx_interfaces_lock);\r\nlist_add_tail(&intrfc->node, &ipx_interfaces);\r\nspin_unlock_bh(&ipx_interfaces_lock);\r\nif (ipxcfg_auto_select_primary && !ipx_primary_net)\r\nipx_primary_net = intrfc;\r\n}\r\nstatic struct ipx_interface *ipxitf_alloc(struct net_device *dev, __be32 netnum,\r\n__be16 dlink_type,\r\nstruct datalink_proto *dlink,\r\nunsigned char internal,\r\nint ipx_offset)\r\n{\r\nstruct ipx_interface *intrfc = kmalloc(sizeof(*intrfc), GFP_ATOMIC);\r\nif (intrfc) {\r\nintrfc->if_dev = dev;\r\nintrfc->if_netnum = netnum;\r\nintrfc->if_dlink_type = dlink_type;\r\nintrfc->if_dlink = dlink;\r\nintrfc->if_internal = internal;\r\nintrfc->if_ipx_offset = ipx_offset;\r\nintrfc->if_sknum = IPX_MIN_EPHEMERAL_SOCKET;\r\nINIT_HLIST_HEAD(&intrfc->if_sklist);\r\natomic_set(&intrfc->refcnt, 1);\r\nspin_lock_init(&intrfc->if_sklist_lock);\r\n}\r\nreturn intrfc;\r\n}\r\nstatic int ipxitf_create_internal(struct ipx_interface_definition *idef)\r\n{\r\nstruct ipx_interface *intrfc;\r\nint rc = -EEXIST;\r\nif (ipx_primary_net)\r\ngoto out;\r\nrc = -EADDRNOTAVAIL;\r\nif (!idef->ipx_network)\r\ngoto out;\r\nintrfc = ipxitf_find_using_net(idef->ipx_network);\r\nrc = -EADDRINUSE;\r\nif (intrfc) {\r\nipxitf_put(intrfc);\r\ngoto out;\r\n}\r\nintrfc = ipxitf_alloc(NULL, idef->ipx_network, 0, NULL, 1, 0);\r\nrc = -EAGAIN;\r\nif (!intrfc)\r\ngoto out;\r\nmemcpy((char *)&(intrfc->if_node), idef->ipx_node, IPX_NODE_LEN);\r\nipx_internal_net = ipx_primary_net = intrfc;\r\nipxitf_hold(intrfc);\r\nipxitf_insert(intrfc);\r\nrc = ipxitf_add_local_route(intrfc);\r\nipxitf_put(intrfc);\r\nout:\r\nreturn rc;\r\n}\r\nstatic __be16 ipx_map_frame_type(unsigned char type)\r\n{\r\n__be16 rc = 0;\r\nswitch (type) {\r\ncase IPX_FRAME_ETHERII: rc = htons(ETH_P_IPX); break;\r\ncase IPX_FRAME_8022: rc = htons(ETH_P_802_2); break;\r\ncase IPX_FRAME_SNAP: rc = htons(ETH_P_SNAP); break;\r\ncase IPX_FRAME_8023: rc = htons(ETH_P_802_3); break;\r\n}\r\nreturn rc;\r\n}\r\nstatic int ipxitf_create(struct ipx_interface_definition *idef)\r\n{\r\nstruct net_device *dev;\r\n__be16 dlink_type = 0;\r\nstruct datalink_proto *datalink = NULL;\r\nstruct ipx_interface *intrfc;\r\nint rc;\r\nif (idef->ipx_special == IPX_INTERNAL) {\r\nrc = ipxitf_create_internal(idef);\r\ngoto out;\r\n}\r\nrc = -EEXIST;\r\nif (idef->ipx_special == IPX_PRIMARY && ipx_primary_net)\r\ngoto out;\r\nintrfc = ipxitf_find_using_net(idef->ipx_network);\r\nrc = -EADDRINUSE;\r\nif (idef->ipx_network && intrfc) {\r\nipxitf_put(intrfc);\r\ngoto out;\r\n}\r\nif (intrfc)\r\nipxitf_put(intrfc);\r\ndev = dev_get_by_name(&init_net, idef->ipx_device);\r\nrc = -ENODEV;\r\nif (!dev)\r\ngoto out;\r\nswitch (idef->ipx_dlink_type) {\r\ncase IPX_FRAME_8022:\r\ndlink_type = htons(ETH_P_802_2);\r\ndatalink = p8022_datalink;\r\nbreak;\r\ncase IPX_FRAME_ETHERII:\r\nif (dev->type != ARPHRD_IEEE802) {\r\ndlink_type = htons(ETH_P_IPX);\r\ndatalink = pEII_datalink;\r\nbreak;\r\n}\r\ncase IPX_FRAME_SNAP:\r\ndlink_type = htons(ETH_P_SNAP);\r\ndatalink = pSNAP_datalink;\r\nbreak;\r\ncase IPX_FRAME_8023:\r\ndlink_type = htons(ETH_P_802_3);\r\ndatalink = p8023_datalink;\r\nbreak;\r\ncase IPX_FRAME_NONE:\r\ndefault:\r\nrc = -EPROTONOSUPPORT;\r\ngoto out_dev;\r\n}\r\nrc = -ENETDOWN;\r\nif (!(dev->flags & IFF_UP))\r\ngoto out_dev;\r\nrc = -EINVAL;\r\nif (dev->addr_len > IPX_NODE_LEN)\r\ngoto out_dev;\r\nintrfc = ipxitf_find_using_phys(dev, dlink_type);\r\nif (!intrfc) {\r\nintrfc = ipxitf_alloc(dev, idef->ipx_network, dlink_type,\r\ndatalink, 0, dev->hard_header_len +\r\ndatalink->header_length);\r\nrc = -EAGAIN;\r\nif (!intrfc)\r\ngoto out_dev;\r\nif (idef->ipx_special == IPX_PRIMARY)\r\nipx_primary_net = intrfc;\r\nif (!memcmp(idef->ipx_node, "\000\000\000\000\000\000",\r\nIPX_NODE_LEN)) {\r\nmemset(intrfc->if_node, 0, IPX_NODE_LEN);\r\nmemcpy(intrfc->if_node + IPX_NODE_LEN - dev->addr_len,\r\ndev->dev_addr, dev->addr_len);\r\n} else\r\nmemcpy(intrfc->if_node, idef->ipx_node, IPX_NODE_LEN);\r\nipxitf_hold(intrfc);\r\nipxitf_insert(intrfc);\r\n}\r\nrc = 0;\r\nif (!intrfc->if_netnum)\r\ngoto out_intrfc;\r\nrc = ipxitf_add_local_route(intrfc);\r\nout_intrfc:\r\nipxitf_put(intrfc);\r\ngoto out;\r\nout_dev:\r\ndev_put(dev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ipxitf_delete(struct ipx_interface_definition *idef)\r\n{\r\nstruct net_device *dev = NULL;\r\n__be16 dlink_type = 0;\r\nstruct ipx_interface *intrfc;\r\nint rc = 0;\r\nspin_lock_bh(&ipx_interfaces_lock);\r\nif (idef->ipx_special == IPX_INTERNAL) {\r\nif (ipx_internal_net) {\r\n__ipxitf_put(ipx_internal_net);\r\ngoto out;\r\n}\r\nrc = -ENOENT;\r\ngoto out;\r\n}\r\ndlink_type = ipx_map_frame_type(idef->ipx_dlink_type);\r\nrc = -EPROTONOSUPPORT;\r\nif (!dlink_type)\r\ngoto out;\r\ndev = __dev_get_by_name(&init_net, idef->ipx_device);\r\nrc = -ENODEV;\r\nif (!dev)\r\ngoto out;\r\nintrfc = __ipxitf_find_using_phys(dev, dlink_type);\r\nrc = -EINVAL;\r\nif (!intrfc)\r\ngoto out;\r\n__ipxitf_put(intrfc);\r\nrc = 0;\r\nout:\r\nspin_unlock_bh(&ipx_interfaces_lock);\r\nreturn rc;\r\n}\r\nstatic struct ipx_interface *ipxitf_auto_create(struct net_device *dev,\r\n__be16 dlink_type)\r\n{\r\nstruct ipx_interface *intrfc = NULL;\r\nstruct datalink_proto *datalink;\r\nif (!dev)\r\ngoto out;\r\nif (dev->addr_len > IPX_NODE_LEN)\r\ngoto out;\r\nswitch (ntohs(dlink_type)) {\r\ncase ETH_P_IPX: datalink = pEII_datalink; break;\r\ncase ETH_P_802_2: datalink = p8022_datalink; break;\r\ncase ETH_P_SNAP: datalink = pSNAP_datalink; break;\r\ncase ETH_P_802_3: datalink = p8023_datalink; break;\r\ndefault: goto out;\r\n}\r\nintrfc = ipxitf_alloc(dev, 0, dlink_type, datalink, 0,\r\ndev->hard_header_len + datalink->header_length);\r\nif (intrfc) {\r\nmemset(intrfc->if_node, 0, IPX_NODE_LEN);\r\nmemcpy((char *)&(intrfc->if_node[IPX_NODE_LEN-dev->addr_len]),\r\ndev->dev_addr, dev->addr_len);\r\nspin_lock_init(&intrfc->if_sklist_lock);\r\natomic_set(&intrfc->refcnt, 1);\r\nipxitf_insert(intrfc);\r\ndev_hold(dev);\r\n}\r\nout:\r\nreturn intrfc;\r\n}\r\nstatic int ipxitf_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nint rc = -EINVAL;\r\nstruct ifreq ifr;\r\nint val;\r\nswitch (cmd) {\r\ncase SIOCSIFADDR: {\r\nstruct sockaddr_ipx *sipx;\r\nstruct ipx_interface_definition f;\r\nrc = -EFAULT;\r\nif (copy_from_user(&ifr, arg, sizeof(ifr)))\r\nbreak;\r\nsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\r\nrc = -EINVAL;\r\nif (sipx->sipx_family != AF_IPX)\r\nbreak;\r\nf.ipx_network = sipx->sipx_network;\r\nmemcpy(f.ipx_device, ifr.ifr_name,\r\nsizeof(f.ipx_device));\r\nmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\r\nf.ipx_dlink_type = sipx->sipx_type;\r\nf.ipx_special = sipx->sipx_special;\r\nif (sipx->sipx_action == IPX_DLTITF)\r\nrc = ipxitf_delete(&f);\r\nelse\r\nrc = ipxitf_create(&f);\r\nbreak;\r\n}\r\ncase SIOCGIFADDR: {\r\nstruct sockaddr_ipx *sipx;\r\nstruct ipx_interface *ipxif;\r\nstruct net_device *dev;\r\nrc = -EFAULT;\r\nif (copy_from_user(&ifr, arg, sizeof(ifr)))\r\nbreak;\r\nsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\r\ndev = __dev_get_by_name(&init_net, ifr.ifr_name);\r\nrc = -ENODEV;\r\nif (!dev)\r\nbreak;\r\nipxif = ipxitf_find_using_phys(dev,\r\nipx_map_frame_type(sipx->sipx_type));\r\nrc = -EADDRNOTAVAIL;\r\nif (!ipxif)\r\nbreak;\r\nsipx->sipx_family = AF_IPX;\r\nsipx->sipx_network = ipxif->if_netnum;\r\nmemcpy(sipx->sipx_node, ipxif->if_node,\r\nsizeof(sipx->sipx_node));\r\nrc = -EFAULT;\r\nif (copy_to_user(arg, &ifr, sizeof(ifr)))\r\nbreak;\r\nipxitf_put(ipxif);\r\nrc = 0;\r\nbreak;\r\n}\r\ncase SIOCAIPXITFCRT:\r\nrc = -EFAULT;\r\nif (get_user(val, (unsigned char __user *) arg))\r\nbreak;\r\nrc = 0;\r\nipxcfg_auto_create_interfaces = val;\r\nbreak;\r\ncase SIOCAIPXPRISLT:\r\nrc = -EFAULT;\r\nif (get_user(val, (unsigned char __user *) arg))\r\nbreak;\r\nrc = 0;\r\nipxcfg_set_auto_select(val);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\n__be16 ipx_cksum(struct ipxhdr *packet, int length)\r\n{\r\n__u16 *p = (__u16 *)packet;\r\n__u32 sum = p[1] + (p[2] & (__force u16)htons(0x00ff));\r\n__u32 i = (length >> 1) - 3;\r\np += 3;\r\nwhile (i--)\r\nsum += *p++;\r\nif (packet->ipx_pktsize & htons(1))\r\nsum += (__force u16)htons(0xff00) & *p;\r\nsum = (sum & 0xffff) + (sum >> 16);\r\nif (sum >= 0x10000)\r\nsum++;\r\nif (sum)\r\nsum = ~sum;\r\nreturn (__force __be16)sum;\r\n}\r\nconst char *ipx_frame_name(__be16 frame)\r\n{\r\nchar* rc = "None";\r\nswitch (ntohs(frame)) {\r\ncase ETH_P_IPX: rc = "EtherII"; break;\r\ncase ETH_P_802_2: rc = "802.2"; break;\r\ncase ETH_P_SNAP: rc = "SNAP"; break;\r\ncase ETH_P_802_3: rc = "802.3"; break;\r\n}\r\nreturn rc;\r\n}\r\nconst char *ipx_device_name(struct ipx_interface *intrfc)\r\n{\r\nreturn intrfc->if_internal ? "Internal" :\r\nintrfc->if_dev ? intrfc->if_dev->name : "Unknown";\r\n}\r\nstatic int ipx_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint opt;\r\nint rc = -EINVAL;\r\nlock_sock(sk);\r\nif (optlen != sizeof(int))\r\ngoto out;\r\nrc = -EFAULT;\r\nif (get_user(opt, (unsigned int __user *)optval))\r\ngoto out;\r\nrc = -ENOPROTOOPT;\r\nif (!(level == SOL_IPX && optname == IPX_TYPE))\r\ngoto out;\r\nipx_sk(sk)->type = opt;\r\nrc = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int ipx_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint val = 0;\r\nint len;\r\nint rc = -ENOPROTOOPT;\r\nlock_sock(sk);\r\nif (!(level == SOL_IPX && optname == IPX_TYPE))\r\ngoto out;\r\nval = ipx_sk(sk)->type;\r\nrc = -EFAULT;\r\nif (get_user(len, optlen))\r\ngoto out;\r\nlen = min_t(unsigned int, len, sizeof(int));\r\nrc = -EINVAL;\r\nif(len < 0)\r\ngoto out;\r\nrc = -EFAULT;\r\nif (put_user(len, optlen) || copy_to_user(optval, &val, len))\r\ngoto out;\r\nrc = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int ipx_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nint rc = -ESOCKTNOSUPPORT;\r\nstruct sock *sk;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nif (sock->type != SOCK_DGRAM)\r\ngoto out;\r\nrc = -ENOMEM;\r\nsk = sk_alloc(net, PF_IPX, GFP_KERNEL, &ipx_proto, kern);\r\nif (!sk)\r\ngoto out;\r\nsk_refcnt_debug_inc(sk);\r\nsock_init_data(sock, sk);\r\nsk->sk_no_check_tx = 1;\r\nsock->ops = &ipx_dgram_ops;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ipx_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (!sk)\r\ngoto out;\r\nlock_sock(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\nsock->sk = NULL;\r\nsk_refcnt_debug_release(sk);\r\nipx_destroy_socket(sk);\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nout:\r\nreturn 0;\r\n}\r\nstatic __be16 ipx_first_free_socketnum(struct ipx_interface *intrfc)\r\n{\r\nunsigned short socketNum = intrfc->if_sknum;\r\nspin_lock_bh(&intrfc->if_sklist_lock);\r\nif (socketNum < IPX_MIN_EPHEMERAL_SOCKET)\r\nsocketNum = IPX_MIN_EPHEMERAL_SOCKET;\r\nwhile (__ipxitf_find_socket(intrfc, htons(socketNum)))\r\nif (socketNum > IPX_MAX_EPHEMERAL_SOCKET)\r\nsocketNum = IPX_MIN_EPHEMERAL_SOCKET;\r\nelse\r\nsocketNum++;\r\nspin_unlock_bh(&intrfc->if_sklist_lock);\r\nintrfc->if_sknum = socketNum;\r\nreturn htons(socketNum);\r\n}\r\nstatic int __ipx_bind(struct socket *sock,\r\nstruct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct ipx_sock *ipxs = ipx_sk(sk);\r\nstruct ipx_interface *intrfc;\r\nstruct sockaddr_ipx *addr = (struct sockaddr_ipx *)uaddr;\r\nint rc = -EINVAL;\r\nif (!sock_flag(sk, SOCK_ZAPPED) || addr_len != sizeof(struct sockaddr_ipx))\r\ngoto out;\r\nintrfc = ipxitf_find_using_net(addr->sipx_network);\r\nrc = -EADDRNOTAVAIL;\r\nif (!intrfc)\r\ngoto out;\r\nif (!addr->sipx_port) {\r\naddr->sipx_port = ipx_first_free_socketnum(intrfc);\r\nrc = -EINVAL;\r\nif (!addr->sipx_port)\r\ngoto out_put;\r\n}\r\nrc = -EACCES;\r\nif (ntohs(addr->sipx_port) < IPX_MIN_EPHEMERAL_SOCKET &&\r\n!capable(CAP_NET_ADMIN))\r\ngoto out_put;\r\nipxs->port = addr->sipx_port;\r\n#ifdef CONFIG_IPX_INTERN\r\nif (intrfc == ipx_internal_net) {\r\nrc = -EINVAL;\r\nif (!memcmp(addr->sipx_node, ipx_broadcast_node, IPX_NODE_LEN))\r\ngoto out_put;\r\nif (!memcmp(addr->sipx_node, ipx_this_node, IPX_NODE_LEN))\r\nmemcpy(ipxs->node, intrfc->if_node, IPX_NODE_LEN);\r\nelse\r\nmemcpy(ipxs->node, addr->sipx_node, IPX_NODE_LEN);\r\nrc = -EADDRINUSE;\r\nif (ipxitf_find_internal_socket(intrfc, ipxs->node,\r\nipxs->port)) {\r\nSOCK_DEBUG(sk,\r\n"IPX: bind failed because port %X in use.\n",\r\nntohs(addr->sipx_port));\r\ngoto out_put;\r\n}\r\n} else {\r\nmemcpy(ipxs->node, intrfc->if_node, IPX_NODE_LEN);\r\nrc = -EADDRINUSE;\r\nif (ipxitf_find_socket(intrfc, addr->sipx_port)) {\r\nSOCK_DEBUG(sk,\r\n"IPX: bind failed because port %X in use.\n",\r\nntohs(addr->sipx_port));\r\ngoto out_put;\r\n}\r\n}\r\n#else\r\nrc = -EADDRINUSE;\r\nif (ipxitf_find_socket(intrfc, addr->sipx_port)) {\r\nSOCK_DEBUG(sk, "IPX: bind failed because port %X in use.\n",\r\nntohs((int)addr->sipx_port));\r\ngoto out_put;\r\n}\r\n#endif\r\nipxitf_insert_socket(intrfc, sk);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nrc = 0;\r\nout_put:\r\nipxitf_put(intrfc);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ipx_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint rc;\r\nlock_sock(sk);\r\nrc = __ipx_bind(sock, uaddr, addr_len);\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int ipx_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct ipx_sock *ipxs = ipx_sk(sk);\r\nstruct sockaddr_ipx *addr;\r\nint rc = -EINVAL;\r\nstruct ipx_route *rt;\r\nsk->sk_state = TCP_CLOSE;\r\nsock->state = SS_UNCONNECTED;\r\nlock_sock(sk);\r\nif (addr_len != sizeof(*addr))\r\ngoto out;\r\naddr = (struct sockaddr_ipx *)uaddr;\r\nif (!ipxs->port) {\r\nstruct sockaddr_ipx uaddr;\r\nuaddr.sipx_port = 0;\r\nuaddr.sipx_network = 0;\r\n#ifdef CONFIG_IPX_INTERN\r\nrc = -ENETDOWN;\r\nif (!ipxs->intrfc)\r\ngoto out;\r\nmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node,\r\nIPX_NODE_LEN);\r\n#endif\r\nrc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\r\nsizeof(struct sockaddr_ipx));\r\nif (rc)\r\ngoto out;\r\n}\r\nrt = ipxrtr_lookup(addr->sipx_network);\r\nrc = -ENETUNREACH;\r\nif (!rt && !(!addr->sipx_network && ipx_primary_net))\r\ngoto out;\r\nipxs->dest_addr.net = addr->sipx_network;\r\nipxs->dest_addr.sock = addr->sipx_port;\r\nmemcpy(ipxs->dest_addr.node, addr->sipx_node, IPX_NODE_LEN);\r\nipxs->type = addr->sipx_type;\r\nif (sock->type == SOCK_DGRAM) {\r\nsock->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\n}\r\nif (rt)\r\nipxrtr_put(rt);\r\nrc = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int ipx_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct ipx_address *addr;\r\nstruct sockaddr_ipx sipx;\r\nstruct sock *sk = sock->sk;\r\nstruct ipx_sock *ipxs = ipx_sk(sk);\r\nint rc;\r\n*uaddr_len = sizeof(struct sockaddr_ipx);\r\nlock_sock(sk);\r\nif (peer) {\r\nrc = -ENOTCONN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\naddr = &ipxs->dest_addr;\r\nsipx.sipx_network = addr->net;\r\nsipx.sipx_port = addr->sock;\r\nmemcpy(sipx.sipx_node, addr->node, IPX_NODE_LEN);\r\n} else {\r\nif (ipxs->intrfc) {\r\nsipx.sipx_network = ipxs->intrfc->if_netnum;\r\n#ifdef CONFIG_IPX_INTERN\r\nmemcpy(sipx.sipx_node, ipxs->node, IPX_NODE_LEN);\r\n#else\r\nmemcpy(sipx.sipx_node, ipxs->intrfc->if_node,\r\nIPX_NODE_LEN);\r\n#endif\r\n} else {\r\nsipx.sipx_network = 0;\r\nmemset(sipx.sipx_node, '\0', IPX_NODE_LEN);\r\n}\r\nsipx.sipx_port = ipxs->port;\r\n}\r\nsipx.sipx_family = AF_IPX;\r\nsipx.sipx_type = ipxs->type;\r\nsipx.sipx_zero = 0;\r\nmemcpy(uaddr, &sipx, sizeof(sipx));\r\nrc = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int ipx_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct ipx_interface *intrfc;\r\nstruct ipxhdr *ipx;\r\nu16 ipx_pktsize;\r\nint rc = 0;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto drop;\r\nif (skb->pkt_type == PACKET_OTHERHOST)\r\ngoto drop;\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\r\ngoto out;\r\nif (!pskb_may_pull(skb, sizeof(struct ipxhdr)))\r\ngoto drop;\r\nipx_pktsize = ntohs(ipx_hdr(skb)->ipx_pktsize);\r\nif (ipx_pktsize < sizeof(struct ipxhdr) ||\r\n!pskb_may_pull(skb, ipx_pktsize))\r\ngoto drop;\r\nipx = ipx_hdr(skb);\r\nif (ipx->ipx_checksum != IPX_NO_CHECKSUM &&\r\nipx->ipx_checksum != ipx_cksum(ipx, ipx_pktsize))\r\ngoto drop;\r\nIPX_SKB_CB(skb)->ipx_tctrl = ipx->ipx_tctrl;\r\nIPX_SKB_CB(skb)->ipx_dest_net = ipx->ipx_dest.net;\r\nIPX_SKB_CB(skb)->ipx_source_net = ipx->ipx_source.net;\r\nintrfc = ipxitf_find_using_phys(dev, pt->type);\r\nif (!intrfc) {\r\nif (ipxcfg_auto_create_interfaces &&\r\nIPX_SKB_CB(skb)->ipx_dest_net) {\r\nintrfc = ipxitf_auto_create(dev, pt->type);\r\nif (intrfc)\r\nipxitf_hold(intrfc);\r\n}\r\nif (!intrfc)\r\ngoto drop;\r\n}\r\nrc = ipxitf_rcv(intrfc, skb);\r\nipxitf_put(intrfc);\r\ngoto out;\r\ndrop:\r\nkfree_skb(skb);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ipx_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct ipx_sock *ipxs = ipx_sk(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_ipx *, usipx, msg->msg_name);\r\nstruct sockaddr_ipx local_sipx;\r\nint rc = -EINVAL;\r\nint flags = msg->msg_flags;\r\nlock_sock(sk);\r\nif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\r\ngoto out;\r\nif (len >= 65535 - sizeof(struct ipxhdr))\r\ngoto out;\r\nif (usipx) {\r\nif (!ipxs->port) {\r\nstruct sockaddr_ipx uaddr;\r\nuaddr.sipx_port = 0;\r\nuaddr.sipx_network = 0;\r\n#ifdef CONFIG_IPX_INTERN\r\nrc = -ENETDOWN;\r\nif (!ipxs->intrfc)\r\ngoto out;\r\nmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node,\r\nIPX_NODE_LEN);\r\n#endif\r\nrc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\r\nsizeof(struct sockaddr_ipx));\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = -EINVAL;\r\nif (msg->msg_namelen < sizeof(*usipx) ||\r\nusipx->sipx_family != AF_IPX)\r\ngoto out;\r\n} else {\r\nrc = -ENOTCONN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\nusipx = &local_sipx;\r\nusipx->sipx_family = AF_IPX;\r\nusipx->sipx_type = ipxs->type;\r\nusipx->sipx_port = ipxs->dest_addr.sock;\r\nusipx->sipx_network = ipxs->dest_addr.net;\r\nmemcpy(usipx->sipx_node, ipxs->dest_addr.node, IPX_NODE_LEN);\r\n}\r\nrc = ipxrtr_route_packet(sk, usipx, msg, len, flags & MSG_DONTWAIT);\r\nif (rc >= 0)\r\nrc = len;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int ipx_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct ipx_sock *ipxs = ipx_sk(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_ipx *, sipx, msg->msg_name);\r\nstruct ipxhdr *ipx = NULL;\r\nstruct sk_buff *skb;\r\nint copied, rc;\r\nbool locked = true;\r\nlock_sock(sk);\r\nif (!ipxs->port) {\r\nstruct sockaddr_ipx uaddr;\r\nuaddr.sipx_port = 0;\r\nuaddr.sipx_network = 0;\r\n#ifdef CONFIG_IPX_INTERN\r\nrc = -ENETDOWN;\r\nif (!ipxs->intrfc)\r\ngoto out;\r\nmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\r\n#endif\r\nrc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\r\nsizeof(struct sockaddr_ipx));\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = -ENOTCONN;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\ngoto out;\r\nrelease_sock(sk);\r\nlocked = false;\r\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\r\nflags & MSG_DONTWAIT, &rc);\r\nif (!skb) {\r\nif (rc == -EAGAIN && (sk->sk_shutdown & RCV_SHUTDOWN))\r\nrc = 0;\r\ngoto out;\r\n}\r\nipx = ipx_hdr(skb);\r\ncopied = ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\r\nif (copied > size) {\r\ncopied = size;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nrc = skb_copy_datagram_msg(skb, sizeof(struct ipxhdr), msg, copied);\r\nif (rc)\r\ngoto out_free;\r\nif (skb->tstamp.tv64)\r\nsk->sk_stamp = skb->tstamp;\r\nif (sipx) {\r\nsipx->sipx_family = AF_IPX;\r\nsipx->sipx_port = ipx->ipx_source.sock;\r\nmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\r\nsipx->sipx_network = IPX_SKB_CB(skb)->ipx_source_net;\r\nsipx->sipx_type = ipx->ipx_type;\r\nsipx->sipx_zero = 0;\r\nmsg->msg_namelen = sizeof(*sipx);\r\n}\r\nrc = copied;\r\nout_free:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nif (locked)\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int ipx_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nint rc = 0;\r\nlong amount = 0;\r\nstruct sock *sk = sock->sk;\r\nvoid __user *argp = (void __user *)arg;\r\nlock_sock(sk);\r\nswitch (cmd) {\r\ncase TIOCOUTQ:\r\namount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nrc = put_user(amount, (int __user *)argp);\r\nbreak;\r\ncase TIOCINQ: {\r\nstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\r\nif (skb)\r\namount = skb->len - sizeof(struct ipxhdr);\r\nrc = put_user(amount, (int __user *)argp);\r\nbreak;\r\n}\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\nrc = -EPERM;\r\nif (capable(CAP_NET_ADMIN))\r\nrc = ipxrtr_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCSIFADDR:\r\ncase SIOCAIPXITFCRT:\r\ncase SIOCAIPXPRISLT:\r\nrc = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nbreak;\r\ncase SIOCGIFADDR:\r\nrc = ipxitf_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCIPXCFGDATA:\r\nrc = ipxcfg_get_config_data(argp);\r\nbreak;\r\ncase SIOCIPXNCPCONN:\r\nrc = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nbreak;\r\nrc = get_user(ipx_sk(sk)->ipx_ncp_conn,\r\n(const unsigned short __user *)argp);\r\nbreak;\r\ncase SIOCGSTAMP:\r\nrc = sock_get_timestamp(sk, argp);\r\nbreak;\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\nrc = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int ipx_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCAIPXITFCRT:\r\ncase SIOCAIPXPRISLT:\r\ncase SIOCIPXCFGDATA:\r\ncase SIOCIPXNCPCONN:\r\nreturn ipx_ioctl(sock, cmd, arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int ipx_shutdown(struct socket *sock, int mode)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (mode < SHUT_RD || mode > SHUT_RDWR)\r\nreturn -EINVAL;\r\n++mode;\r\nlock_sock(sk);\r\nsk->sk_shutdown |= mode;\r\nrelease_sock(sk);\r\nsk->sk_state_change(sk);\r\nreturn 0;\r\n}\r\nstatic int __init ipx_init(void)\r\n{\r\nint rc = proto_register(&ipx_proto, 1);\r\nif (rc != 0)\r\ngoto out;\r\nsock_register(&ipx_family_ops);\r\npEII_datalink = make_EII_client();\r\nif (pEII_datalink)\r\ndev_add_pack(&ipx_dix_packet_type);\r\nelse\r\nprintk(ipx_EII_err_msg);\r\np8023_datalink = make_8023_client();\r\nif (p8023_datalink)\r\ndev_add_pack(&ipx_8023_packet_type);\r\nelse\r\nprintk(ipx_8023_err_msg);\r\np8022_datalink = register_8022_client(ipx_8022_type, ipx_rcv);\r\nif (!p8022_datalink)\r\nprintk(ipx_llc_err_msg);\r\npSNAP_datalink = register_snap_client(ipx_snap_id, ipx_rcv);\r\nif (!pSNAP_datalink)\r\nprintk(ipx_snap_err_msg);\r\nregister_netdevice_notifier(&ipx_dev_notifier);\r\nipx_register_sysctl();\r\nipx_proc_init();\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit ipx_proto_finito(void)\r\n{\r\nipx_proc_exit();\r\nipx_unregister_sysctl();\r\nunregister_netdevice_notifier(&ipx_dev_notifier);\r\nipxitf_cleanup();\r\nif (pSNAP_datalink) {\r\nunregister_snap_client(pSNAP_datalink);\r\npSNAP_datalink = NULL;\r\n}\r\nif (p8022_datalink) {\r\nunregister_8022_client(p8022_datalink);\r\np8022_datalink = NULL;\r\n}\r\ndev_remove_pack(&ipx_8023_packet_type);\r\nif (p8023_datalink) {\r\ndestroy_8023_client(p8023_datalink);\r\np8023_datalink = NULL;\r\n}\r\ndev_remove_pack(&ipx_dix_packet_type);\r\nif (pEII_datalink) {\r\ndestroy_EII_client(pEII_datalink);\r\npEII_datalink = NULL;\r\n}\r\nproto_unregister(&ipx_proto);\r\nsock_unregister(ipx_family_ops.family);\r\n}
