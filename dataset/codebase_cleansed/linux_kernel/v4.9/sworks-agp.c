static int serverworks_create_page_map(struct serverworks_page_map *page_map)\r\n{\r\nint i;\r\npage_map->real = (unsigned long *) __get_free_page(GFP_KERNEL);\r\nif (page_map->real == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nset_memory_uc((unsigned long)page_map->real, 1);\r\npage_map->remapped = page_map->real;\r\nfor (i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++)\r\nwritel(agp_bridge->scratch_page, page_map->remapped+i);\r\nreturn 0;\r\n}\r\nstatic void serverworks_free_page_map(struct serverworks_page_map *page_map)\r\n{\r\nset_memory_wb((unsigned long)page_map->real, 1);\r\nfree_page((unsigned long) page_map->real);\r\n}\r\nstatic void serverworks_free_gatt_pages(void)\r\n{\r\nint i;\r\nstruct serverworks_page_map **tables;\r\nstruct serverworks_page_map *entry;\r\ntables = serverworks_private.gatt_pages;\r\nfor (i = 0; i < serverworks_private.num_tables; i++) {\r\nentry = tables[i];\r\nif (entry != NULL) {\r\nif (entry->real != NULL) {\r\nserverworks_free_page_map(entry);\r\n}\r\nkfree(entry);\r\n}\r\n}\r\nkfree(tables);\r\n}\r\nstatic int serverworks_create_gatt_pages(int nr_tables)\r\n{\r\nstruct serverworks_page_map **tables;\r\nstruct serverworks_page_map *entry;\r\nint retval = 0;\r\nint i;\r\ntables = kzalloc((nr_tables + 1) * sizeof(struct serverworks_page_map *),\r\nGFP_KERNEL);\r\nif (tables == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nr_tables; i++) {\r\nentry = kzalloc(sizeof(struct serverworks_page_map), GFP_KERNEL);\r\nif (entry == NULL) {\r\nretval = -ENOMEM;\r\nbreak;\r\n}\r\ntables[i] = entry;\r\nretval = serverworks_create_page_map(entry);\r\nif (retval != 0) break;\r\n}\r\nserverworks_private.num_tables = nr_tables;\r\nserverworks_private.gatt_pages = tables;\r\nif (retval != 0) serverworks_free_gatt_pages();\r\nreturn retval;\r\n}\r\nstatic int serverworks_create_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct aper_size_info_lvl2 *value;\r\nstruct serverworks_page_map page_dir;\r\nint retval;\r\nu32 temp;\r\nint i;\r\nvalue = A_SIZE_LVL2(agp_bridge->current_size);\r\nretval = serverworks_create_page_map(&page_dir);\r\nif (retval != 0) {\r\nreturn retval;\r\n}\r\nretval = serverworks_create_page_map(&serverworks_private.scratch_dir);\r\nif (retval != 0) {\r\nserverworks_free_page_map(&page_dir);\r\nreturn retval;\r\n}\r\nfor (i = 0; i < 1024; i++) {\r\nwritel(agp_bridge->scratch_page, serverworks_private.scratch_dir.remapped+i);\r\nwritel(virt_to_phys(serverworks_private.scratch_dir.real) | 1, page_dir.remapped+i);\r\n}\r\nretval = serverworks_create_gatt_pages(value->num_entries / 1024);\r\nif (retval != 0) {\r\nserverworks_free_page_map(&page_dir);\r\nserverworks_free_page_map(&serverworks_private.scratch_dir);\r\nreturn retval;\r\n}\r\nagp_bridge->gatt_table_real = (u32 *)page_dir.real;\r\nagp_bridge->gatt_table = (u32 __iomem *)page_dir.remapped;\r\nagp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);\r\npci_read_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,&temp);\r\nagp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\nfor (i = 0; i < value->num_entries / 1024; i++)\r\nwritel(virt_to_phys(serverworks_private.gatt_pages[i]->real)|1, page_dir.remapped+i);\r\nreturn 0;\r\n}\r\nstatic int serverworks_free_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct serverworks_page_map page_dir;\r\npage_dir.real = (unsigned long *)agp_bridge->gatt_table_real;\r\npage_dir.remapped = (unsigned long __iomem *)agp_bridge->gatt_table;\r\nserverworks_free_gatt_pages();\r\nserverworks_free_page_map(&page_dir);\r\nserverworks_free_page_map(&serverworks_private.scratch_dir);\r\nreturn 0;\r\n}\r\nstatic int serverworks_fetch_size(void)\r\n{\r\nint i;\r\nu32 temp;\r\nu32 temp2;\r\nstruct aper_size_info_lvl2 *values;\r\nvalues = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);\r\npci_read_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,&temp);\r\npci_write_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,\r\nSVWRKS_SIZE_MASK);\r\npci_read_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,&temp2);\r\npci_write_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,temp);\r\ntemp2 &= SVWRKS_SIZE_MASK;\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (temp2 == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void serverworks_tlbflush(struct agp_memory *temp)\r\n{\r\nunsigned long timeout;\r\nwriteb(1, serverworks_private.registers+SVWRKS_POSTFLUSH);\r\ntimeout = jiffies + 3*HZ;\r\nwhile (readb(serverworks_private.registers+SVWRKS_POSTFLUSH) == 1) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&serverworks_private.svrwrks_dev->dev,\r\n"TLB post flush took more than 3 seconds\n");\r\nbreak;\r\n}\r\n}\r\nwritel(1, serverworks_private.registers+SVWRKS_DIRFLUSH);\r\ntimeout = jiffies + 3*HZ;\r\nwhile (readl(serverworks_private.registers+SVWRKS_DIRFLUSH) == 1) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&serverworks_private.svrwrks_dev->dev,\r\n"TLB Dir flush took more than 3 seconds\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int serverworks_configure(void)\r\n{\r\nstruct aper_size_info_lvl2 *current_size;\r\nu32 temp;\r\nu8 enable_reg;\r\nu16 cap_reg;\r\ncurrent_size = A_SIZE_LVL2(agp_bridge->current_size);\r\npci_read_config_dword(agp_bridge->dev, serverworks_private.mm_addr_ofs, &temp);\r\ntemp = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\nserverworks_private.registers = (volatile u8 __iomem *) ioremap(temp, 4096);\r\nif (!serverworks_private.registers) {\r\ndev_err(&agp_bridge->dev->dev, "can't ioremap(%#x)\n", temp);\r\nreturn -ENOMEM;\r\n}\r\nwriteb(0xA, serverworks_private.registers+SVWRKS_GART_CACHE);\r\nreadb(serverworks_private.registers+SVWRKS_GART_CACHE);\r\nwritel(agp_bridge->gatt_bus_addr, serverworks_private.registers+SVWRKS_GATTBASE);\r\nreadl(serverworks_private.registers+SVWRKS_GATTBASE);\r\ncap_reg = readw(serverworks_private.registers+SVWRKS_COMMAND);\r\ncap_reg &= ~0x0007;\r\ncap_reg |= 0x4;\r\nwritew(cap_reg, serverworks_private.registers+SVWRKS_COMMAND);\r\nreadw(serverworks_private.registers+SVWRKS_COMMAND);\r\npci_read_config_byte(serverworks_private.svrwrks_dev,SVWRKS_AGP_ENABLE, &enable_reg);\r\nenable_reg |= 0x1;\r\npci_write_config_byte(serverworks_private.svrwrks_dev,SVWRKS_AGP_ENABLE, enable_reg);\r\nserverworks_tlbflush(NULL);\r\nagp_bridge->capndx = pci_find_capability(serverworks_private.svrwrks_dev, PCI_CAP_ID_AGP);\r\npci_read_config_dword(serverworks_private.svrwrks_dev,\r\nagp_bridge->capndx+PCI_AGP_STATUS, &agp_bridge->mode);\r\npci_read_config_byte(agp_bridge->dev, SVWRKS_CACHING, &enable_reg);\r\nenable_reg &= ~0x3;\r\npci_write_config_byte(agp_bridge->dev, SVWRKS_CACHING, enable_reg);\r\npci_read_config_byte(agp_bridge->dev, SVWRKS_FEATURE, &enable_reg);\r\nenable_reg |= (1<<6);\r\npci_write_config_byte(agp_bridge->dev,SVWRKS_FEATURE, enable_reg);\r\nreturn 0;\r\n}\r\nstatic void serverworks_cleanup(void)\r\n{\r\niounmap((void __iomem *) serverworks_private.registers);\r\n}\r\nstatic int serverworks_insert_memory(struct agp_memory *mem,\r\noff_t pg_start, int type)\r\n{\r\nint i, j, num_entries;\r\nunsigned long __iomem *cur_gatt;\r\nunsigned long addr;\r\nnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\r\nif (type != 0 || mem->type != 0) {\r\nreturn -EINVAL;\r\n}\r\nif ((pg_start + mem->page_count) > num_entries) {\r\nreturn -EINVAL;\r\n}\r\nj = pg_start;\r\nwhile (j < (pg_start + mem->page_count)) {\r\naddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = SVRWRKS_GET_GATT(addr);\r\nif (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))\r\nreturn -EBUSY;\r\nj++;\r\n}\r\nif (!mem->is_flushed) {\r\nglobal_cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\r\naddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = SVRWRKS_GET_GATT(addr);\r\nwritel(agp_bridge->driver->mask_memory(agp_bridge,\r\npage_to_phys(mem->pages[i]), mem->type),\r\ncur_gatt+GET_GATT_OFF(addr));\r\n}\r\nserverworks_tlbflush(mem);\r\nreturn 0;\r\n}\r\nstatic int serverworks_remove_memory(struct agp_memory *mem, off_t pg_start,\r\nint type)\r\n{\r\nint i;\r\nunsigned long __iomem *cur_gatt;\r\nunsigned long addr;\r\nif (type != 0 || mem->type != 0) {\r\nreturn -EINVAL;\r\n}\r\nglobal_cache_flush();\r\nserverworks_tlbflush(mem);\r\nfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\r\naddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = SVRWRKS_GET_GATT(addr);\r\nwritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\r\n}\r\nserverworks_tlbflush(mem);\r\nreturn 0;\r\n}\r\nstatic void serverworks_agp_enable(struct agp_bridge_data *bridge, u32 mode)\r\n{\r\nu32 command;\r\npci_read_config_dword(serverworks_private.svrwrks_dev,\r\nbridge->capndx + PCI_AGP_STATUS,\r\n&command);\r\ncommand = agp_collect_device_status(bridge, mode, command);\r\ncommand &= ~0x10;\r\ncommand &= ~0x08;\r\ncommand |= 0x100;\r\npci_write_config_dword(serverworks_private.svrwrks_dev,\r\nbridge->capndx + PCI_AGP_COMMAND,\r\ncommand);\r\nagp_device_command(command, false);\r\n}\r\nstatic int agp_serverworks_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nstruct pci_dev *bridge_dev;\r\nu32 temp, temp2;\r\nu8 cap_ptr = 0;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nswitch (pdev->device) {\r\ncase 0x0006:\r\ndev_err(&pdev->dev, "ServerWorks CNB20HE is unsupported due to lack of documentation\n");\r\nreturn -ENODEV;\r\ncase PCI_DEVICE_ID_SERVERWORKS_HE:\r\ncase PCI_DEVICE_ID_SERVERWORKS_LE:\r\ncase 0x0007:\r\nbreak;\r\ndefault:\r\nif (cap_ptr)\r\ndev_err(&pdev->dev, "unsupported Serverworks chipset "\r\n"[%04x/%04x]\n", pdev->vendor, pdev->device);\r\nreturn -ENODEV;\r\n}\r\nbridge_dev = pci_get_bus_and_slot((unsigned int)pdev->bus->number,\r\nPCI_DEVFN(0, 1));\r\nif (!bridge_dev) {\r\ndev_info(&pdev->dev, "can't find secondary device\n");\r\nreturn -ENODEV;\r\n}\r\nserverworks_private.svrwrks_dev = bridge_dev;\r\nserverworks_private.gart_addr_ofs = 0x10;\r\npci_read_config_dword(pdev, SVWRKS_APSIZE, &temp);\r\nif (temp & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\npci_read_config_dword(pdev, SVWRKS_APSIZE + 4, &temp2);\r\nif (temp2 != 0) {\r\ndev_info(&pdev->dev, "64 bit aperture address, "\r\n"but top bits are not zero; disabling AGP\n");\r\nreturn -ENODEV;\r\n}\r\nserverworks_private.mm_addr_ofs = 0x18;\r\n} else\r\nserverworks_private.mm_addr_ofs = 0x14;\r\npci_read_config_dword(pdev, serverworks_private.mm_addr_ofs, &temp);\r\nif (temp & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\npci_read_config_dword(pdev,\r\nserverworks_private.mm_addr_ofs + 4, &temp2);\r\nif (temp2 != 0) {\r\ndev_info(&pdev->dev, "64 bit MMIO address, but top "\r\n"bits are not zero; disabling AGP\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->driver = &sworks_driver;\r\nbridge->dev_private_data = &serverworks_private,\r\nbridge->dev = pci_dev_get(pdev);\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void agp_serverworks_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\npci_dev_put(bridge->dev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\npci_dev_put(serverworks_private.svrwrks_dev);\r\nserverworks_private.svrwrks_dev = NULL;\r\n}\r\nstatic int __init agp_serverworks_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_serverworks_pci_driver);\r\n}\r\nstatic void __exit agp_serverworks_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_serverworks_pci_driver);\r\n}
