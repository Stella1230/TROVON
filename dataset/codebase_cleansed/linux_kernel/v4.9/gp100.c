static void\r\ngp100_mc_intr_update(struct gp100_mc *mc)\r\n{\r\nstruct nvkm_device *device = mc->base.subdev.device;\r\nu32 mask = mc->intr ? mc->mask : 0, i;\r\nfor (i = 0; i < 2; i++) {\r\nnvkm_wr32(device, 0x000180 + (i * 0x04), ~mask);\r\nnvkm_wr32(device, 0x000160 + (i * 0x04), mask);\r\n}\r\n}\r\nstatic void\r\ngp100_mc_intr_unarm(struct nvkm_mc *base)\r\n{\r\nstruct gp100_mc *mc = gp100_mc(base);\r\nunsigned long flags;\r\nspin_lock_irqsave(&mc->lock, flags);\r\nmc->intr = false;\r\ngp100_mc_intr_update(mc);\r\nspin_unlock_irqrestore(&mc->lock, flags);\r\n}\r\nstatic void\r\ngp100_mc_intr_rearm(struct nvkm_mc *base)\r\n{\r\nstruct gp100_mc *mc = gp100_mc(base);\r\nunsigned long flags;\r\nspin_lock_irqsave(&mc->lock, flags);\r\nmc->intr = true;\r\ngp100_mc_intr_update(mc);\r\nspin_unlock_irqrestore(&mc->lock, flags);\r\n}\r\nstatic void\r\ngp100_mc_intr_mask(struct nvkm_mc *base, u32 mask, u32 intr)\r\n{\r\nstruct gp100_mc *mc = gp100_mc(base);\r\nunsigned long flags;\r\nspin_lock_irqsave(&mc->lock, flags);\r\nmc->mask = (mc->mask & ~mask) | intr;\r\ngp100_mc_intr_update(mc);\r\nspin_unlock_irqrestore(&mc->lock, flags);\r\n}\r\nint\r\ngp100_mc_new(struct nvkm_device *device, int index, struct nvkm_mc **pmc)\r\n{\r\nstruct gp100_mc *mc;\r\nif (!(mc = kzalloc(sizeof(*mc), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nnvkm_mc_ctor(&gp100_mc, device, index, &mc->base);\r\n*pmc = &mc->base;\r\nspin_lock_init(&mc->lock);\r\nmc->intr = false;\r\nmc->mask = 0x7fffffff;\r\nreturn 0;\r\n}
