static inline struct mtk_mipi_tx *mtk_mipi_tx_from_clk_hw(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct mtk_mipi_tx, pll_hw);\r\n}\r\nstatic void mtk_mipi_tx_clear_bits(struct mtk_mipi_tx *mipi_tx, u32 offset,\r\nu32 bits)\r\n{\r\nu32 temp = readl(mipi_tx->regs + offset);\r\nwritel(temp & ~bits, mipi_tx->regs + offset);\r\n}\r\nstatic void mtk_mipi_tx_set_bits(struct mtk_mipi_tx *mipi_tx, u32 offset,\r\nu32 bits)\r\n{\r\nu32 temp = readl(mipi_tx->regs + offset);\r\nwritel(temp | bits, mipi_tx->regs + offset);\r\n}\r\nstatic void mtk_mipi_tx_update_bits(struct mtk_mipi_tx *mipi_tx, u32 offset,\r\nu32 mask, u32 data)\r\n{\r\nu32 temp = readl(mipi_tx->regs + offset);\r\nwritel((temp & ~mask) | (data & mask), mipi_tx->regs + offset);\r\n}\r\nstatic int mtk_mipi_tx_pll_prepare(struct clk_hw *hw)\r\n{\r\nstruct mtk_mipi_tx *mipi_tx = mtk_mipi_tx_from_clk_hw(hw);\r\nunsigned int txdiv, txdiv0, txdiv1;\r\nu64 pcw;\r\ndev_dbg(mipi_tx->dev, "prepare: %u Hz\n", mipi_tx->data_rate);\r\nif (mipi_tx->data_rate >= 500000000) {\r\ntxdiv = 1;\r\ntxdiv0 = 0;\r\ntxdiv1 = 0;\r\n} else if (mipi_tx->data_rate >= 250000000) {\r\ntxdiv = 2;\r\ntxdiv0 = 1;\r\ntxdiv1 = 0;\r\n} else if (mipi_tx->data_rate >= 125000000) {\r\ntxdiv = 4;\r\ntxdiv0 = 2;\r\ntxdiv1 = 0;\r\n} else if (mipi_tx->data_rate > 62000000) {\r\ntxdiv = 8;\r\ntxdiv0 = 2;\r\ntxdiv1 = 1;\r\n} else if (mipi_tx->data_rate >= 50000000) {\r\ntxdiv = 16;\r\ntxdiv0 = 2;\r\ntxdiv1 = 2;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nmtk_mipi_tx_update_bits(mipi_tx, MIPITX_DSI_BG_CON,\r\nRG_DSI_VOUT_MSK |\r\nRG_DSI_BG_CKEN | RG_DSI_BG_CORE_EN,\r\n(4 << 20) | (4 << 17) | (4 << 14) |\r\n(4 << 11) | (4 << 8) | (4 << 5) |\r\nRG_DSI_BG_CKEN | RG_DSI_BG_CORE_EN);\r\nusleep_range(30, 100);\r\nmtk_mipi_tx_update_bits(mipi_tx, MIPITX_DSI_TOP_CON,\r\nRG_DSI_LNT_IMP_CAL_CODE | RG_DSI_LNT_HS_BIAS_EN,\r\n(8 << 4) | RG_DSI_LNT_HS_BIAS_EN);\r\nmtk_mipi_tx_set_bits(mipi_tx, MIPITX_DSI_CON,\r\nRG_DSI_CKG_LDOOUT_EN | RG_DSI_LDOCORE_EN);\r\nmtk_mipi_tx_update_bits(mipi_tx, MIPITX_DSI_PLL_PWR,\r\nRG_DSI_MPPLL_SDM_PWR_ON |\r\nRG_DSI_MPPLL_SDM_ISO_EN,\r\nRG_DSI_MPPLL_SDM_PWR_ON);\r\nmtk_mipi_tx_clear_bits(mipi_tx, MIPITX_DSI_PLL_CON0,\r\nRG_DSI_MPPLL_PLL_EN);\r\nmtk_mipi_tx_update_bits(mipi_tx, MIPITX_DSI_PLL_CON0,\r\nRG_DSI_MPPLL_TXDIV0 | RG_DSI_MPPLL_TXDIV1 |\r\nRG_DSI_MPPLL_PREDIV,\r\n(txdiv0 << 3) | (txdiv1 << 5));\r\npcw = div_u64(((u64)mipi_tx->data_rate * 2 * txdiv) << 24,\r\n26000000);\r\nwritel(pcw, mipi_tx->regs + MIPITX_DSI_PLL_CON2);\r\nmtk_mipi_tx_set_bits(mipi_tx, MIPITX_DSI_PLL_CON1,\r\nRG_DSI_MPPLL_SDM_FRA_EN);\r\nmtk_mipi_tx_set_bits(mipi_tx, MIPITX_DSI_PLL_CON0, RG_DSI_MPPLL_PLL_EN);\r\nusleep_range(20, 100);\r\nmtk_mipi_tx_clear_bits(mipi_tx, MIPITX_DSI_PLL_CON1,\r\nRG_DSI_MPPLL_SDM_SSC_EN);\r\nreturn 0;\r\n}\r\nstatic void mtk_mipi_tx_pll_unprepare(struct clk_hw *hw)\r\n{\r\nstruct mtk_mipi_tx *mipi_tx = mtk_mipi_tx_from_clk_hw(hw);\r\ndev_dbg(mipi_tx->dev, "unprepare\n");\r\nmtk_mipi_tx_clear_bits(mipi_tx, MIPITX_DSI_PLL_CON0,\r\nRG_DSI_MPPLL_PLL_EN);\r\nmtk_mipi_tx_update_bits(mipi_tx, MIPITX_DSI_PLL_PWR,\r\nRG_DSI_MPPLL_SDM_ISO_EN |\r\nRG_DSI_MPPLL_SDM_PWR_ON,\r\nRG_DSI_MPPLL_SDM_ISO_EN);\r\nmtk_mipi_tx_clear_bits(mipi_tx, MIPITX_DSI_TOP_CON,\r\nRG_DSI_LNT_HS_BIAS_EN);\r\nmtk_mipi_tx_clear_bits(mipi_tx, MIPITX_DSI_CON,\r\nRG_DSI_CKG_LDOOUT_EN | RG_DSI_LDOCORE_EN);\r\nmtk_mipi_tx_clear_bits(mipi_tx, MIPITX_DSI_BG_CON,\r\nRG_DSI_BG_CKEN | RG_DSI_BG_CORE_EN);\r\nmtk_mipi_tx_clear_bits(mipi_tx, MIPITX_DSI_PLL_CON0,\r\nRG_DSI_MPPLL_DIV_MSK);\r\n}\r\nstatic long mtk_mipi_tx_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nreturn clamp_val(rate, 50000000, 1250000000);\r\n}\r\nstatic int mtk_mipi_tx_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct mtk_mipi_tx *mipi_tx = mtk_mipi_tx_from_clk_hw(hw);\r\ndev_dbg(mipi_tx->dev, "set rate: %lu Hz\n", rate);\r\nmipi_tx->data_rate = rate;\r\nreturn 0;\r\n}\r\nstatic unsigned long mtk_mipi_tx_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct mtk_mipi_tx *mipi_tx = mtk_mipi_tx_from_clk_hw(hw);\r\nreturn mipi_tx->data_rate;\r\n}\r\nstatic int mtk_mipi_tx_power_on_signal(struct phy *phy)\r\n{\r\nstruct mtk_mipi_tx *mipi_tx = phy_get_drvdata(phy);\r\nunsigned int reg;\r\nfor (reg = MIPITX_DSI_CLOCK_LANE;\r\nreg <= MIPITX_DSI_DATA_LANE3; reg += 4)\r\nmtk_mipi_tx_set_bits(mipi_tx, reg, RG_DSI_LNTx_LDOOUT_EN);\r\nmtk_mipi_tx_clear_bits(mipi_tx, MIPITX_DSI_TOP_CON,\r\nRG_DSI_PAD_TIE_LOW_EN);\r\nreturn 0;\r\n}\r\nstatic int mtk_mipi_tx_power_on(struct phy *phy)\r\n{\r\nstruct mtk_mipi_tx *mipi_tx = phy_get_drvdata(phy);\r\nint ret;\r\nret = clk_prepare_enable(mipi_tx->pll);\r\nif (ret < 0)\r\nreturn ret;\r\nmtk_mipi_tx_power_on_signal(phy);\r\nreturn 0;\r\n}\r\nstatic void mtk_mipi_tx_power_off_signal(struct phy *phy)\r\n{\r\nstruct mtk_mipi_tx *mipi_tx = phy_get_drvdata(phy);\r\nunsigned int reg;\r\nmtk_mipi_tx_set_bits(mipi_tx, MIPITX_DSI_TOP_CON,\r\nRG_DSI_PAD_TIE_LOW_EN);\r\nfor (reg = MIPITX_DSI_CLOCK_LANE;\r\nreg <= MIPITX_DSI_DATA_LANE3; reg += 4)\r\nmtk_mipi_tx_clear_bits(mipi_tx, reg, RG_DSI_LNTx_LDOOUT_EN);\r\n}\r\nstatic int mtk_mipi_tx_power_off(struct phy *phy)\r\n{\r\nstruct mtk_mipi_tx *mipi_tx = phy_get_drvdata(phy);\r\nmtk_mipi_tx_power_off_signal(phy);\r\nclk_disable_unprepare(mipi_tx->pll);\r\nreturn 0;\r\n}\r\nstatic int mtk_mipi_tx_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_mipi_tx *mipi_tx;\r\nstruct resource *mem;\r\nstruct clk *ref_clk;\r\nconst char *ref_clk_name;\r\nstruct clk_init_data clk_init = {\r\n.ops = &mtk_mipi_tx_pll_ops,\r\n.num_parents = 1,\r\n.parent_names = (const char * const *)&ref_clk_name,\r\n.flags = CLK_SET_RATE_GATE,\r\n};\r\nstruct phy *phy;\r\nstruct phy_provider *phy_provider;\r\nint ret;\r\nmipi_tx = devm_kzalloc(dev, sizeof(*mipi_tx), GFP_KERNEL);\r\nif (!mipi_tx)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmipi_tx->regs = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(mipi_tx->regs)) {\r\nret = PTR_ERR(mipi_tx->regs);\r\ndev_err(dev, "Failed to get memory resource: %d\n", ret);\r\nreturn ret;\r\n}\r\nref_clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(ref_clk)) {\r\nret = PTR_ERR(ref_clk);\r\ndev_err(dev, "Failed to get reference clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nref_clk_name = __clk_get_name(ref_clk);\r\nret = of_property_read_string(dev->of_node, "clock-output-names",\r\n&clk_init.name);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read clock-output-names: %d\n", ret);\r\nreturn ret;\r\n}\r\nmipi_tx->pll_hw.init = &clk_init;\r\nmipi_tx->pll = devm_clk_register(dev, &mipi_tx->pll_hw);\r\nif (IS_ERR(mipi_tx->pll)) {\r\nret = PTR_ERR(mipi_tx->pll);\r\ndev_err(dev, "Failed to register PLL: %d\n", ret);\r\nreturn ret;\r\n}\r\nphy = devm_phy_create(dev, NULL, &mtk_mipi_tx_ops);\r\nif (IS_ERR(phy)) {\r\nret = PTR_ERR(phy);\r\ndev_err(dev, "Failed to create MIPI D-PHY: %d\n", ret);\r\nreturn ret;\r\n}\r\nphy_set_drvdata(phy, mipi_tx);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(phy_provider)) {\r\nret = PTR_ERR(phy_provider);\r\nreturn ret;\r\n}\r\nmipi_tx->dev = dev;\r\nreturn of_clk_add_provider(dev->of_node, of_clk_src_simple_get,\r\nmipi_tx->pll);\r\n}\r\nstatic int mtk_mipi_tx_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreturn 0;\r\n}
