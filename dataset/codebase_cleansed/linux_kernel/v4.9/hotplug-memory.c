unsigned long pseries_memory_block_size(void)\r\n{\r\nstruct device_node *np;\r\nunsigned int memblock_size = MIN_MEMORY_BLOCK_SIZE;\r\nstruct resource r;\r\nnp = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");\r\nif (np) {\r\nconst __be64 *size;\r\nsize = of_get_property(np, "ibm,lmb-size", NULL);\r\nif (size)\r\nmemblock_size = be64_to_cpup(size);\r\nof_node_put(np);\r\n} else if (machine_is(pseries)) {\r\nunsigned int memzero_size = 0;\r\nnp = of_find_node_by_path("/memory@0");\r\nif (np) {\r\nif (!of_address_to_resource(np, 0, &r))\r\nmemzero_size = resource_size(&r);\r\nof_node_put(np);\r\n}\r\nif (memzero_size) {\r\nchar buf[64];\r\nsprintf(buf, "/memory@%x", memzero_size);\r\nnp = of_find_node_by_path(buf);\r\nif (np) {\r\nif (!of_address_to_resource(np, 0, &r))\r\nmemblock_size = resource_size(&r);\r\nof_node_put(np);\r\n}\r\n}\r\n}\r\nreturn memblock_size;\r\n}\r\nstatic void dlpar_free_property(struct property *prop)\r\n{\r\nkfree(prop->name);\r\nkfree(prop->value);\r\nkfree(prop);\r\n}\r\nstatic struct property *dlpar_clone_property(struct property *prop,\r\nu32 prop_size)\r\n{\r\nstruct property *new_prop;\r\nnew_prop = kzalloc(sizeof(*new_prop), GFP_KERNEL);\r\nif (!new_prop)\r\nreturn NULL;\r\nnew_prop->name = kstrdup(prop->name, GFP_KERNEL);\r\nnew_prop->value = kzalloc(prop_size, GFP_KERNEL);\r\nif (!new_prop->name || !new_prop->value) {\r\ndlpar_free_property(new_prop);\r\nreturn NULL;\r\n}\r\nmemcpy(new_prop->value, prop->value, prop->length);\r\nnew_prop->length = prop_size;\r\nof_property_set_flag(new_prop, OF_DYNAMIC);\r\nreturn new_prop;\r\n}\r\nstatic struct property *dlpar_clone_drconf_property(struct device_node *dn)\r\n{\r\nstruct property *prop, *new_prop;\r\nstruct of_drconf_cell *lmbs;\r\nu32 num_lmbs, *p;\r\nint i;\r\nprop = of_find_property(dn, "ibm,dynamic-memory", NULL);\r\nif (!prop)\r\nreturn NULL;\r\nnew_prop = dlpar_clone_property(prop, prop->length);\r\nif (!new_prop)\r\nreturn NULL;\r\np = new_prop->value;\r\n*p = be32_to_cpu(*p);\r\nnum_lmbs = *p++;\r\nlmbs = (struct of_drconf_cell *)p;\r\nfor (i = 0; i < num_lmbs; i++) {\r\nlmbs[i].base_addr = be64_to_cpu(lmbs[i].base_addr);\r\nlmbs[i].drc_index = be32_to_cpu(lmbs[i].drc_index);\r\nlmbs[i].flags = be32_to_cpu(lmbs[i].flags);\r\n}\r\nreturn new_prop;\r\n}\r\nstatic void dlpar_update_drconf_property(struct device_node *dn,\r\nstruct property *prop)\r\n{\r\nstruct of_drconf_cell *lmbs;\r\nu32 num_lmbs, *p;\r\nint i;\r\np = prop->value;\r\nnum_lmbs = *p;\r\n*p = cpu_to_be32(*p);\r\np++;\r\nlmbs = (struct of_drconf_cell *)p;\r\nfor (i = 0; i < num_lmbs; i++) {\r\nlmbs[i].base_addr = cpu_to_be64(lmbs[i].base_addr);\r\nlmbs[i].drc_index = cpu_to_be32(lmbs[i].drc_index);\r\nlmbs[i].flags = cpu_to_be32(lmbs[i].flags);\r\n}\r\nrtas_hp_event = true;\r\nof_update_property(dn, prop);\r\nrtas_hp_event = false;\r\n}\r\nstatic int dlpar_update_device_tree_lmb(struct of_drconf_cell *lmb)\r\n{\r\nstruct device_node *dn;\r\nstruct property *prop;\r\nstruct of_drconf_cell *lmbs;\r\nu32 *p, num_lmbs;\r\nint i;\r\ndn = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");\r\nif (!dn)\r\nreturn -ENODEV;\r\nprop = dlpar_clone_drconf_property(dn);\r\nif (!prop) {\r\nof_node_put(dn);\r\nreturn -ENODEV;\r\n}\r\np = prop->value;\r\nnum_lmbs = *p++;\r\nlmbs = (struct of_drconf_cell *)p;\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (lmbs[i].drc_index == lmb->drc_index) {\r\nlmbs[i].flags = lmb->flags;\r\nlmbs[i].aa_index = lmb->aa_index;\r\ndlpar_update_drconf_property(dn, prop);\r\nbreak;\r\n}\r\n}\r\nof_node_put(dn);\r\nreturn 0;\r\n}\r\nstatic u32 find_aa_index(struct device_node *dr_node,\r\nstruct property *ala_prop, const u32 *lmb_assoc)\r\n{\r\nu32 *assoc_arrays;\r\nu32 aa_index;\r\nint aa_arrays, aa_array_entries, aa_array_sz;\r\nint i, index;\r\nassoc_arrays = ala_prop->value;\r\naa_arrays = be32_to_cpu(assoc_arrays[0]);\r\naa_array_entries = be32_to_cpu(assoc_arrays[1]);\r\naa_array_sz = aa_array_entries * sizeof(u32);\r\naa_index = -1;\r\nfor (i = 0; i < aa_arrays; i++) {\r\nindex = (i * aa_array_entries) + 2;\r\nif (memcmp(&assoc_arrays[index], &lmb_assoc[1], aa_array_sz))\r\ncontinue;\r\naa_index = i;\r\nbreak;\r\n}\r\nif (aa_index == -1) {\r\nstruct property *new_prop;\r\nu32 new_prop_size;\r\nnew_prop_size = ala_prop->length + aa_array_sz;\r\nnew_prop = dlpar_clone_property(ala_prop, new_prop_size);\r\nif (!new_prop)\r\nreturn -1;\r\nassoc_arrays = new_prop->value;\r\nassoc_arrays[0] = cpu_to_be32(aa_arrays + 1);\r\nindex = aa_arrays * aa_array_entries + 2;\r\nmemcpy(&assoc_arrays[index], &lmb_assoc[1], aa_array_sz);\r\nof_update_property(dr_node, new_prop);\r\naa_index = be32_to_cpu(assoc_arrays[0]) - 1;\r\n}\r\nreturn aa_index;\r\n}\r\nstatic u32 lookup_lmb_associativity_index(struct of_drconf_cell *lmb)\r\n{\r\nstruct device_node *parent, *lmb_node, *dr_node;\r\nstruct property *ala_prop;\r\nconst u32 *lmb_assoc;\r\nu32 aa_index;\r\nparent = of_find_node_by_path("/");\r\nif (!parent)\r\nreturn -ENODEV;\r\nlmb_node = dlpar_configure_connector(cpu_to_be32(lmb->drc_index),\r\nparent);\r\nof_node_put(parent);\r\nif (!lmb_node)\r\nreturn -EINVAL;\r\nlmb_assoc = of_get_property(lmb_node, "ibm,associativity", NULL);\r\nif (!lmb_assoc) {\r\ndlpar_free_cc_nodes(lmb_node);\r\nreturn -ENODEV;\r\n}\r\ndr_node = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");\r\nif (!dr_node) {\r\ndlpar_free_cc_nodes(lmb_node);\r\nreturn -ENODEV;\r\n}\r\nala_prop = of_find_property(dr_node, "ibm,associativity-lookup-arrays",\r\nNULL);\r\nif (!ala_prop) {\r\nof_node_put(dr_node);\r\ndlpar_free_cc_nodes(lmb_node);\r\nreturn -ENODEV;\r\n}\r\naa_index = find_aa_index(dr_node, ala_prop, lmb_assoc);\r\ndlpar_free_cc_nodes(lmb_node);\r\nreturn aa_index;\r\n}\r\nstatic int dlpar_add_device_tree_lmb(struct of_drconf_cell *lmb)\r\n{\r\nint aa_index;\r\nlmb->flags |= DRCONF_MEM_ASSIGNED;\r\naa_index = lookup_lmb_associativity_index(lmb);\r\nif (aa_index < 0) {\r\npr_err("Couldn't find associativity index for drc index %x\n",\r\nlmb->drc_index);\r\nreturn aa_index;\r\n}\r\nlmb->aa_index = aa_index;\r\nreturn dlpar_update_device_tree_lmb(lmb);\r\n}\r\nstatic int dlpar_remove_device_tree_lmb(struct of_drconf_cell *lmb)\r\n{\r\nlmb->flags &= ~DRCONF_MEM_ASSIGNED;\r\nlmb->aa_index = 0xffffffff;\r\nreturn dlpar_update_device_tree_lmb(lmb);\r\n}\r\nstatic int pseries_remove_memblock(unsigned long base, unsigned int memblock_size)\r\n{\r\nunsigned long block_sz, start_pfn;\r\nint sections_per_block;\r\nint i, nid;\r\nstart_pfn = base >> PAGE_SHIFT;\r\nlock_device_hotplug();\r\nif (!pfn_valid(start_pfn))\r\ngoto out;\r\nblock_sz = pseries_memory_block_size();\r\nsections_per_block = block_sz / MIN_MEMORY_BLOCK_SIZE;\r\nnid = memory_add_physaddr_to_nid(base);\r\nfor (i = 0; i < sections_per_block; i++) {\r\nremove_memory(nid, base, MIN_MEMORY_BLOCK_SIZE);\r\nbase += MIN_MEMORY_BLOCK_SIZE;\r\n}\r\nout:\r\nmemblock_remove(base, memblock_size);\r\nunlock_device_hotplug();\r\nreturn 0;\r\n}\r\nstatic int pseries_remove_mem_node(struct device_node *np)\r\n{\r\nconst char *type;\r\nconst __be32 *regs;\r\nunsigned long base;\r\nunsigned int lmb_size;\r\nint ret = -EINVAL;\r\ntype = of_get_property(np, "device_type", NULL);\r\nif (type == NULL || strcmp(type, "memory") != 0)\r\nreturn 0;\r\nregs = of_get_property(np, "reg", NULL);\r\nif (!regs)\r\nreturn ret;\r\nbase = be64_to_cpu(*(unsigned long *)regs);\r\nlmb_size = be32_to_cpu(regs[3]);\r\npseries_remove_memblock(base, lmb_size);\r\nreturn 0;\r\n}\r\nstatic bool lmb_is_removable(struct of_drconf_cell *lmb)\r\n{\r\nint i, scns_per_block;\r\nint rc = 1;\r\nunsigned long pfn, block_sz;\r\nu64 phys_addr;\r\nif (!(lmb->flags & DRCONF_MEM_ASSIGNED))\r\nreturn false;\r\nblock_sz = memory_block_size_bytes();\r\nscns_per_block = block_sz / MIN_MEMORY_BLOCK_SIZE;\r\nphys_addr = lmb->base_addr;\r\nfor (i = 0; i < scns_per_block; i++) {\r\npfn = PFN_DOWN(phys_addr);\r\nif (!pfn_present(pfn))\r\ncontinue;\r\nrc &= is_mem_section_removable(pfn, PAGES_PER_SECTION);\r\nphys_addr += MIN_MEMORY_BLOCK_SIZE;\r\n}\r\nreturn rc ? true : false;\r\n}\r\nstatic struct memory_block *lmb_to_memblock(struct of_drconf_cell *lmb)\r\n{\r\nunsigned long section_nr;\r\nstruct mem_section *mem_sect;\r\nstruct memory_block *mem_block;\r\nsection_nr = pfn_to_section_nr(PFN_DOWN(lmb->base_addr));\r\nmem_sect = __nr_to_section(section_nr);\r\nmem_block = find_memory_block(mem_sect);\r\nreturn mem_block;\r\n}\r\nstatic int dlpar_remove_lmb(struct of_drconf_cell *lmb)\r\n{\r\nstruct memory_block *mem_block;\r\nunsigned long block_sz;\r\nint nid, rc;\r\nif (!lmb_is_removable(lmb))\r\nreturn -EINVAL;\r\nmem_block = lmb_to_memblock(lmb);\r\nif (!mem_block)\r\nreturn -EINVAL;\r\nrc = device_offline(&mem_block->dev);\r\nput_device(&mem_block->dev);\r\nif (rc)\r\nreturn rc;\r\nblock_sz = pseries_memory_block_size();\r\nnid = memory_add_physaddr_to_nid(lmb->base_addr);\r\nremove_memory(nid, lmb->base_addr, block_sz);\r\nmemblock_remove(lmb->base_addr, block_sz);\r\ndlpar_release_drc(lmb->drc_index);\r\ndlpar_remove_device_tree_lmb(lmb);\r\nreturn 0;\r\n}\r\nstatic int dlpar_memory_remove_by_count(u32 lmbs_to_remove,\r\nstruct property *prop)\r\n{\r\nstruct of_drconf_cell *lmbs;\r\nint lmbs_removed = 0;\r\nint lmbs_available = 0;\r\nu32 num_lmbs, *p;\r\nint i, rc;\r\npr_info("Attempting to hot-remove %d LMB(s)\n", lmbs_to_remove);\r\nif (lmbs_to_remove == 0)\r\nreturn -EINVAL;\r\np = prop->value;\r\nnum_lmbs = *p++;\r\nlmbs = (struct of_drconf_cell *)p;\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (lmbs[i].flags & DRCONF_MEM_ASSIGNED)\r\nlmbs_available++;\r\n}\r\nif (lmbs_available < lmbs_to_remove)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_lmbs && lmbs_removed < lmbs_to_remove; i++) {\r\nrc = dlpar_remove_lmb(&lmbs[i]);\r\nif (rc)\r\ncontinue;\r\nlmbs_removed++;\r\nlmbs[i].reserved = 1;\r\n}\r\nif (lmbs_removed != lmbs_to_remove) {\r\npr_err("Memory hot-remove failed, adding LMB's back\n");\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (!lmbs[i].reserved)\r\ncontinue;\r\nrc = dlpar_add_lmb(&lmbs[i]);\r\nif (rc)\r\npr_err("Failed to add LMB back, drc index %x\n",\r\nlmbs[i].drc_index);\r\nlmbs[i].reserved = 0;\r\n}\r\nrc = -EINVAL;\r\n} else {\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (!lmbs[i].reserved)\r\ncontinue;\r\npr_info("Memory at %llx was hot-removed\n",\r\nlmbs[i].base_addr);\r\nlmbs[i].reserved = 0;\r\n}\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int dlpar_memory_remove_by_index(u32 drc_index, struct property *prop)\r\n{\r\nstruct of_drconf_cell *lmbs;\r\nu32 num_lmbs, *p;\r\nint lmb_found;\r\nint i, rc;\r\npr_info("Attempting to hot-remove LMB, drc index %x\n", drc_index);\r\np = prop->value;\r\nnum_lmbs = *p++;\r\nlmbs = (struct of_drconf_cell *)p;\r\nlmb_found = 0;\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (lmbs[i].drc_index == drc_index) {\r\nlmb_found = 1;\r\nrc = dlpar_remove_lmb(&lmbs[i]);\r\nbreak;\r\n}\r\n}\r\nif (!lmb_found)\r\nrc = -EINVAL;\r\nif (rc)\r\npr_info("Failed to hot-remove memory at %llx\n",\r\nlmbs[i].base_addr);\r\nelse\r\npr_info("Memory at %llx was hot-removed\n", lmbs[i].base_addr);\r\nreturn rc;\r\n}\r\nstatic inline int pseries_remove_memblock(unsigned long base,\r\nunsigned int memblock_size)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic inline int pseries_remove_mem_node(struct device_node *np)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int dlpar_memory_remove(struct pseries_hp_errorlog *hp_elog)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int dlpar_remove_lmb(struct of_drconf_cell *lmb)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int dlpar_memory_remove_by_count(u32 lmbs_to_remove,\r\nstruct property *prop)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int dlpar_memory_remove_by_index(u32 drc_index, struct property *prop)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int dlpar_add_lmb(struct of_drconf_cell *lmb)\r\n{\r\nunsigned long block_sz;\r\nint nid, rc;\r\nif (lmb->flags & DRCONF_MEM_ASSIGNED)\r\nreturn -EINVAL;\r\nrc = dlpar_acquire_drc(lmb->drc_index);\r\nif (rc)\r\nreturn rc;\r\nrc = dlpar_add_device_tree_lmb(lmb);\r\nif (rc) {\r\npr_err("Couldn't update device tree for drc index %x\n",\r\nlmb->drc_index);\r\ndlpar_release_drc(lmb->drc_index);\r\nreturn rc;\r\n}\r\nblock_sz = memory_block_size_bytes();\r\nnid = memory_add_physaddr_to_nid(lmb->base_addr);\r\nrc = add_memory(nid, lmb->base_addr, block_sz);\r\nif (rc) {\r\ndlpar_remove_device_tree_lmb(lmb);\r\ndlpar_release_drc(lmb->drc_index);\r\n} else {\r\nlmb->flags |= DRCONF_MEM_ASSIGNED;\r\n}\r\nreturn rc;\r\n}\r\nstatic int dlpar_memory_add_by_count(u32 lmbs_to_add, struct property *prop)\r\n{\r\nstruct of_drconf_cell *lmbs;\r\nu32 num_lmbs, *p;\r\nint lmbs_available = 0;\r\nint lmbs_added = 0;\r\nint i, rc;\r\npr_info("Attempting to hot-add %d LMB(s)\n", lmbs_to_add);\r\nif (lmbs_to_add == 0)\r\nreturn -EINVAL;\r\np = prop->value;\r\nnum_lmbs = *p++;\r\nlmbs = (struct of_drconf_cell *)p;\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (!(lmbs[i].flags & DRCONF_MEM_ASSIGNED))\r\nlmbs_available++;\r\n}\r\nif (lmbs_available < lmbs_to_add)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_lmbs && lmbs_to_add != lmbs_added; i++) {\r\nrc = dlpar_add_lmb(&lmbs[i]);\r\nif (rc)\r\ncontinue;\r\nlmbs_added++;\r\nlmbs[i].reserved = 1;\r\n}\r\nif (lmbs_added != lmbs_to_add) {\r\npr_err("Memory hot-add failed, removing any added LMBs\n");\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (!lmbs[i].reserved)\r\ncontinue;\r\nrc = dlpar_remove_lmb(&lmbs[i]);\r\nif (rc)\r\npr_err("Failed to remove LMB, drc index %x\n",\r\nbe32_to_cpu(lmbs[i].drc_index));\r\n}\r\nrc = -EINVAL;\r\n} else {\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (!lmbs[i].reserved)\r\ncontinue;\r\npr_info("Memory at %llx (drc index %x) was hot-added\n",\r\nlmbs[i].base_addr, lmbs[i].drc_index);\r\nlmbs[i].reserved = 0;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int dlpar_memory_add_by_index(u32 drc_index, struct property *prop)\r\n{\r\nstruct of_drconf_cell *lmbs;\r\nu32 num_lmbs, *p;\r\nint i, lmb_found;\r\nint rc;\r\npr_info("Attempting to hot-add LMB, drc index %x\n", drc_index);\r\np = prop->value;\r\nnum_lmbs = *p++;\r\nlmbs = (struct of_drconf_cell *)p;\r\nlmb_found = 0;\r\nfor (i = 0; i < num_lmbs; i++) {\r\nif (lmbs[i].drc_index == drc_index) {\r\nlmb_found = 1;\r\nrc = dlpar_add_lmb(&lmbs[i]);\r\nbreak;\r\n}\r\n}\r\nif (!lmb_found)\r\nrc = -EINVAL;\r\nif (rc)\r\npr_info("Failed to hot-add memory, drc index %x\n", drc_index);\r\nelse\r\npr_info("Memory at %llx (drc index %x) was hot-added\n",\r\nlmbs[i].base_addr, drc_index);\r\nreturn rc;\r\n}\r\nint dlpar_memory(struct pseries_hp_errorlog *hp_elog)\r\n{\r\nstruct device_node *dn;\r\nstruct property *prop;\r\nu32 count, drc_index;\r\nint rc;\r\ncount = hp_elog->_drc_u.drc_count;\r\ndrc_index = hp_elog->_drc_u.drc_index;\r\nlock_device_hotplug();\r\ndn = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");\r\nif (!dn) {\r\nrc = -EINVAL;\r\ngoto dlpar_memory_out;\r\n}\r\nprop = dlpar_clone_drconf_property(dn);\r\nif (!prop) {\r\nrc = -EINVAL;\r\ngoto dlpar_memory_out;\r\n}\r\nswitch (hp_elog->action) {\r\ncase PSERIES_HP_ELOG_ACTION_ADD:\r\nif (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_COUNT)\r\nrc = dlpar_memory_add_by_count(count, prop);\r\nelse if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_INDEX)\r\nrc = dlpar_memory_add_by_index(drc_index, prop);\r\nelse\r\nrc = -EINVAL;\r\nbreak;\r\ncase PSERIES_HP_ELOG_ACTION_REMOVE:\r\nif (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_COUNT)\r\nrc = dlpar_memory_remove_by_count(count, prop);\r\nelse if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_INDEX)\r\nrc = dlpar_memory_remove_by_index(drc_index, prop);\r\nelse\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\npr_err("Invalid action (%d) specified\n", hp_elog->action);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\ndlpar_free_property(prop);\r\ndlpar_memory_out:\r\nof_node_put(dn);\r\nunlock_device_hotplug();\r\nreturn rc;\r\n}\r\nstatic int pseries_add_mem_node(struct device_node *np)\r\n{\r\nconst char *type;\r\nconst __be32 *regs;\r\nunsigned long base;\r\nunsigned int lmb_size;\r\nint ret = -EINVAL;\r\ntype = of_get_property(np, "device_type", NULL);\r\nif (type == NULL || strcmp(type, "memory") != 0)\r\nreturn 0;\r\nregs = of_get_property(np, "reg", NULL);\r\nif (!regs)\r\nreturn ret;\r\nbase = be64_to_cpu(*(unsigned long *)regs);\r\nlmb_size = be32_to_cpu(regs[3]);\r\nret = memblock_add(base, lmb_size);\r\nreturn (ret < 0) ? -EINVAL : 0;\r\n}\r\nstatic int pseries_update_drconf_memory(struct of_reconfig_data *pr)\r\n{\r\nstruct of_drconf_cell *new_drmem, *old_drmem;\r\nunsigned long memblock_size;\r\nu32 entries;\r\n__be32 *p;\r\nint i, rc = -EINVAL;\r\nif (rtas_hp_event)\r\nreturn 0;\r\nmemblock_size = pseries_memory_block_size();\r\nif (!memblock_size)\r\nreturn -EINVAL;\r\np = (__be32 *) pr->old_prop->value;\r\nif (!p)\r\nreturn -EINVAL;\r\nentries = be32_to_cpu(*p++);\r\nold_drmem = (struct of_drconf_cell *)p;\r\np = (__be32 *)pr->prop->value;\r\np++;\r\nnew_drmem = (struct of_drconf_cell *)p;\r\nfor (i = 0; i < entries; i++) {\r\nif ((be32_to_cpu(old_drmem[i].flags) & DRCONF_MEM_ASSIGNED) &&\r\n(!(be32_to_cpu(new_drmem[i].flags) & DRCONF_MEM_ASSIGNED))) {\r\nrc = pseries_remove_memblock(\r\nbe64_to_cpu(old_drmem[i].base_addr),\r\nmemblock_size);\r\nbreak;\r\n} else if ((!(be32_to_cpu(old_drmem[i].flags) &\r\nDRCONF_MEM_ASSIGNED)) &&\r\n(be32_to_cpu(new_drmem[i].flags) &\r\nDRCONF_MEM_ASSIGNED)) {\r\nrc = memblock_add(be64_to_cpu(old_drmem[i].base_addr),\r\nmemblock_size);\r\nrc = (rc < 0) ? -EINVAL : 0;\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int pseries_memory_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct of_reconfig_data *rd = data;\r\nint err = 0;\r\nswitch (action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\nerr = pseries_add_mem_node(rd->dn);\r\nbreak;\r\ncase OF_RECONFIG_DETACH_NODE:\r\nerr = pseries_remove_mem_node(rd->dn);\r\nbreak;\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\nif (!strcmp(rd->prop->name, "ibm,dynamic-memory"))\r\nerr = pseries_update_drconf_memory(rd);\r\nbreak;\r\n}\r\nreturn notifier_from_errno(err);\r\n}\r\nstatic int __init pseries_memory_hotplug_init(void)\r\n{\r\nif (firmware_has_feature(FW_FEATURE_LPAR))\r\nof_reconfig_notifier_register(&pseries_mem_nb);\r\nreturn 0;\r\n}
