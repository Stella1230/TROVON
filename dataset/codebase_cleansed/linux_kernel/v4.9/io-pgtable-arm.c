static dma_addr_t __arm_lpae_dma_addr(void *pages)\r\n{\r\nreturn (dma_addr_t)virt_to_phys(pages);\r\n}\r\nstatic void *__arm_lpae_alloc_pages(size_t size, gfp_t gfp,\r\nstruct io_pgtable_cfg *cfg)\r\n{\r\nstruct device *dev = cfg->iommu_dev;\r\ndma_addr_t dma;\r\nvoid *pages = alloc_pages_exact(size, gfp | __GFP_ZERO);\r\nif (!pages)\r\nreturn NULL;\r\nif (!selftest_running) {\r\ndma = dma_map_single(dev, pages, size, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, dma))\r\ngoto out_free;\r\nif (dma != virt_to_phys(pages))\r\ngoto out_unmap;\r\n}\r\nreturn pages;\r\nout_unmap:\r\ndev_err(dev, "Cannot accommodate DMA translation for IOMMU page tables\n");\r\ndma_unmap_single(dev, dma, size, DMA_TO_DEVICE);\r\nout_free:\r\nfree_pages_exact(pages, size);\r\nreturn NULL;\r\n}\r\nstatic void __arm_lpae_free_pages(void *pages, size_t size,\r\nstruct io_pgtable_cfg *cfg)\r\n{\r\nif (!selftest_running)\r\ndma_unmap_single(cfg->iommu_dev, __arm_lpae_dma_addr(pages),\r\nsize, DMA_TO_DEVICE);\r\nfree_pages_exact(pages, size);\r\n}\r\nstatic void __arm_lpae_set_pte(arm_lpae_iopte *ptep, arm_lpae_iopte pte,\r\nstruct io_pgtable_cfg *cfg)\r\n{\r\n*ptep = pte;\r\nif (!selftest_running)\r\ndma_sync_single_for_device(cfg->iommu_dev,\r\n__arm_lpae_dma_addr(ptep),\r\nsizeof(pte), DMA_TO_DEVICE);\r\n}\r\nstatic int arm_lpae_init_pte(struct arm_lpae_io_pgtable *data,\r\nunsigned long iova, phys_addr_t paddr,\r\narm_lpae_iopte prot, int lvl,\r\narm_lpae_iopte *ptep)\r\n{\r\narm_lpae_iopte pte = prot;\r\nstruct io_pgtable_cfg *cfg = &data->iop.cfg;\r\nif (iopte_leaf(*ptep, lvl)) {\r\nWARN_ON(!selftest_running);\r\nreturn -EEXIST;\r\n} else if (iopte_type(*ptep, lvl) == ARM_LPAE_PTE_TYPE_TABLE) {\r\narm_lpae_iopte *tblp;\r\nsize_t sz = ARM_LPAE_BLOCK_SIZE(lvl, data);\r\ntblp = ptep - ARM_LPAE_LVL_IDX(iova, lvl, data);\r\nif (WARN_ON(__arm_lpae_unmap(data, iova, sz, lvl, tblp) != sz))\r\nreturn -EINVAL;\r\n}\r\nif (cfg->quirks & IO_PGTABLE_QUIRK_ARM_NS)\r\npte |= ARM_LPAE_PTE_NS;\r\nif (lvl == ARM_LPAE_MAX_LEVELS - 1)\r\npte |= ARM_LPAE_PTE_TYPE_PAGE;\r\nelse\r\npte |= ARM_LPAE_PTE_TYPE_BLOCK;\r\npte |= ARM_LPAE_PTE_AF | ARM_LPAE_PTE_SH_IS;\r\npte |= pfn_to_iopte(paddr >> data->pg_shift, data);\r\n__arm_lpae_set_pte(ptep, pte, cfg);\r\nreturn 0;\r\n}\r\nstatic int __arm_lpae_map(struct arm_lpae_io_pgtable *data, unsigned long iova,\r\nphys_addr_t paddr, size_t size, arm_lpae_iopte prot,\r\nint lvl, arm_lpae_iopte *ptep)\r\n{\r\narm_lpae_iopte *cptep, pte;\r\nsize_t block_size = ARM_LPAE_BLOCK_SIZE(lvl, data);\r\nstruct io_pgtable_cfg *cfg = &data->iop.cfg;\r\nptep += ARM_LPAE_LVL_IDX(iova, lvl, data);\r\nif (size == block_size && (size & cfg->pgsize_bitmap))\r\nreturn arm_lpae_init_pte(data, iova, paddr, prot, lvl, ptep);\r\nif (WARN_ON(lvl >= ARM_LPAE_MAX_LEVELS - 1))\r\nreturn -EINVAL;\r\npte = *ptep;\r\nif (!pte) {\r\ncptep = __arm_lpae_alloc_pages(ARM_LPAE_GRANULE(data),\r\nGFP_ATOMIC, cfg);\r\nif (!cptep)\r\nreturn -ENOMEM;\r\npte = __pa(cptep) | ARM_LPAE_PTE_TYPE_TABLE;\r\nif (cfg->quirks & IO_PGTABLE_QUIRK_ARM_NS)\r\npte |= ARM_LPAE_PTE_NSTABLE;\r\n__arm_lpae_set_pte(ptep, pte, cfg);\r\n} else {\r\ncptep = iopte_deref(pte, data);\r\n}\r\nreturn __arm_lpae_map(data, iova, paddr, size, prot, lvl + 1, cptep);\r\n}\r\nstatic arm_lpae_iopte arm_lpae_prot_to_pte(struct arm_lpae_io_pgtable *data,\r\nint prot)\r\n{\r\narm_lpae_iopte pte;\r\nif (data->iop.fmt == ARM_64_LPAE_S1 ||\r\ndata->iop.fmt == ARM_32_LPAE_S1) {\r\npte = ARM_LPAE_PTE_AP_UNPRIV | ARM_LPAE_PTE_nG;\r\nif (!(prot & IOMMU_WRITE) && (prot & IOMMU_READ))\r\npte |= ARM_LPAE_PTE_AP_RDONLY;\r\nif (prot & IOMMU_MMIO)\r\npte |= (ARM_LPAE_MAIR_ATTR_IDX_DEV\r\n<< ARM_LPAE_PTE_ATTRINDX_SHIFT);\r\nelse if (prot & IOMMU_CACHE)\r\npte |= (ARM_LPAE_MAIR_ATTR_IDX_CACHE\r\n<< ARM_LPAE_PTE_ATTRINDX_SHIFT);\r\n} else {\r\npte = ARM_LPAE_PTE_HAP_FAULT;\r\nif (prot & IOMMU_READ)\r\npte |= ARM_LPAE_PTE_HAP_READ;\r\nif (prot & IOMMU_WRITE)\r\npte |= ARM_LPAE_PTE_HAP_WRITE;\r\nif (prot & IOMMU_MMIO)\r\npte |= ARM_LPAE_PTE_MEMATTR_DEV;\r\nelse if (prot & IOMMU_CACHE)\r\npte |= ARM_LPAE_PTE_MEMATTR_OIWB;\r\nelse\r\npte |= ARM_LPAE_PTE_MEMATTR_NC;\r\n}\r\nif (prot & IOMMU_NOEXEC)\r\npte |= ARM_LPAE_PTE_XN;\r\nreturn pte;\r\n}\r\nstatic int arm_lpae_map(struct io_pgtable_ops *ops, unsigned long iova,\r\nphys_addr_t paddr, size_t size, int iommu_prot)\r\n{\r\nstruct arm_lpae_io_pgtable *data = io_pgtable_ops_to_data(ops);\r\narm_lpae_iopte *ptep = data->pgd;\r\nint ret, lvl = ARM_LPAE_START_LVL(data);\r\narm_lpae_iopte prot;\r\nif (!(iommu_prot & (IOMMU_READ | IOMMU_WRITE)))\r\nreturn 0;\r\nprot = arm_lpae_prot_to_pte(data, iommu_prot);\r\nret = __arm_lpae_map(data, iova, paddr, size, prot, lvl, ptep);\r\nwmb();\r\nreturn ret;\r\n}\r\nstatic void __arm_lpae_free_pgtable(struct arm_lpae_io_pgtable *data, int lvl,\r\narm_lpae_iopte *ptep)\r\n{\r\narm_lpae_iopte *start, *end;\r\nunsigned long table_size;\r\nif (lvl == ARM_LPAE_START_LVL(data))\r\ntable_size = data->pgd_size;\r\nelse\r\ntable_size = ARM_LPAE_GRANULE(data);\r\nstart = ptep;\r\nif (lvl == ARM_LPAE_MAX_LEVELS - 1)\r\nend = ptep;\r\nelse\r\nend = (void *)ptep + table_size;\r\nwhile (ptep != end) {\r\narm_lpae_iopte pte = *ptep++;\r\nif (!pte || iopte_leaf(pte, lvl))\r\ncontinue;\r\n__arm_lpae_free_pgtable(data, lvl + 1, iopte_deref(pte, data));\r\n}\r\n__arm_lpae_free_pages(start, table_size, &data->iop.cfg);\r\n}\r\nstatic void arm_lpae_free_pgtable(struct io_pgtable *iop)\r\n{\r\nstruct arm_lpae_io_pgtable *data = io_pgtable_to_data(iop);\r\n__arm_lpae_free_pgtable(data, ARM_LPAE_START_LVL(data), data->pgd);\r\nkfree(data);\r\n}\r\nstatic int arm_lpae_split_blk_unmap(struct arm_lpae_io_pgtable *data,\r\nunsigned long iova, size_t size,\r\narm_lpae_iopte prot, int lvl,\r\narm_lpae_iopte *ptep, size_t blk_size)\r\n{\r\nunsigned long blk_start, blk_end;\r\nphys_addr_t blk_paddr;\r\narm_lpae_iopte table = 0;\r\nblk_start = iova & ~(blk_size - 1);\r\nblk_end = blk_start + blk_size;\r\nblk_paddr = iopte_to_pfn(*ptep, data) << data->pg_shift;\r\nfor (; blk_start < blk_end; blk_start += size, blk_paddr += size) {\r\narm_lpae_iopte *tablep;\r\nif (blk_start == iova)\r\ncontinue;\r\ntablep = &table - ARM_LPAE_LVL_IDX(blk_start, lvl, data);\r\nif (__arm_lpae_map(data, blk_start, blk_paddr, size, prot, lvl,\r\ntablep) < 0) {\r\nif (table) {\r\ntablep = iopte_deref(table, data);\r\n__arm_lpae_free_pgtable(data, lvl + 1, tablep);\r\n}\r\nreturn 0;\r\n}\r\n}\r\n__arm_lpae_set_pte(ptep, table, &data->iop.cfg);\r\niova &= ~(blk_size - 1);\r\nio_pgtable_tlb_add_flush(&data->iop, iova, blk_size, blk_size, true);\r\nreturn size;\r\n}\r\nstatic int __arm_lpae_unmap(struct arm_lpae_io_pgtable *data,\r\nunsigned long iova, size_t size, int lvl,\r\narm_lpae_iopte *ptep)\r\n{\r\narm_lpae_iopte pte;\r\nstruct io_pgtable *iop = &data->iop;\r\nsize_t blk_size = ARM_LPAE_BLOCK_SIZE(lvl, data);\r\nif (WARN_ON(lvl == ARM_LPAE_MAX_LEVELS))\r\nreturn 0;\r\nptep += ARM_LPAE_LVL_IDX(iova, lvl, data);\r\npte = *ptep;\r\nif (WARN_ON(!pte))\r\nreturn 0;\r\nif (size == blk_size) {\r\n__arm_lpae_set_pte(ptep, 0, &iop->cfg);\r\nif (!iopte_leaf(pte, lvl)) {\r\nio_pgtable_tlb_add_flush(iop, iova, size,\r\nARM_LPAE_GRANULE(data), false);\r\nio_pgtable_tlb_sync(iop);\r\nptep = iopte_deref(pte, data);\r\n__arm_lpae_free_pgtable(data, lvl + 1, ptep);\r\n} else {\r\nio_pgtable_tlb_add_flush(iop, iova, size, size, true);\r\n}\r\nreturn size;\r\n} else if (iopte_leaf(pte, lvl)) {\r\nreturn arm_lpae_split_blk_unmap(data, iova, size,\r\niopte_prot(pte), lvl, ptep,\r\nblk_size);\r\n}\r\nptep = iopte_deref(pte, data);\r\nreturn __arm_lpae_unmap(data, iova, size, lvl + 1, ptep);\r\n}\r\nstatic int arm_lpae_unmap(struct io_pgtable_ops *ops, unsigned long iova,\r\nsize_t size)\r\n{\r\nsize_t unmapped;\r\nstruct arm_lpae_io_pgtable *data = io_pgtable_ops_to_data(ops);\r\narm_lpae_iopte *ptep = data->pgd;\r\nint lvl = ARM_LPAE_START_LVL(data);\r\nunmapped = __arm_lpae_unmap(data, iova, size, lvl, ptep);\r\nif (unmapped)\r\nio_pgtable_tlb_sync(&data->iop);\r\nreturn unmapped;\r\n}\r\nstatic phys_addr_t arm_lpae_iova_to_phys(struct io_pgtable_ops *ops,\r\nunsigned long iova)\r\n{\r\nstruct arm_lpae_io_pgtable *data = io_pgtable_ops_to_data(ops);\r\narm_lpae_iopte pte, *ptep = data->pgd;\r\nint lvl = ARM_LPAE_START_LVL(data);\r\ndo {\r\nif (!ptep)\r\nreturn 0;\r\npte = *(ptep + ARM_LPAE_LVL_IDX(iova, lvl, data));\r\nif (!pte)\r\nreturn 0;\r\nif (iopte_leaf(pte,lvl))\r\ngoto found_translation;\r\nptep = iopte_deref(pte, data);\r\n} while (++lvl < ARM_LPAE_MAX_LEVELS);\r\nreturn 0;\r\nfound_translation:\r\niova &= (ARM_LPAE_BLOCK_SIZE(lvl, data) - 1);\r\nreturn ((phys_addr_t)iopte_to_pfn(pte,data) << data->pg_shift) | iova;\r\n}\r\nstatic void arm_lpae_restrict_pgsizes(struct io_pgtable_cfg *cfg)\r\n{\r\nunsigned long granule;\r\nif (cfg->pgsize_bitmap & PAGE_SIZE)\r\ngranule = PAGE_SIZE;\r\nelse if (cfg->pgsize_bitmap & ~PAGE_MASK)\r\ngranule = 1UL << __fls(cfg->pgsize_bitmap & ~PAGE_MASK);\r\nelse if (cfg->pgsize_bitmap & PAGE_MASK)\r\ngranule = 1UL << __ffs(cfg->pgsize_bitmap & PAGE_MASK);\r\nelse\r\ngranule = 0;\r\nswitch (granule) {\r\ncase SZ_4K:\r\ncfg->pgsize_bitmap &= (SZ_4K | SZ_2M | SZ_1G);\r\nbreak;\r\ncase SZ_16K:\r\ncfg->pgsize_bitmap &= (SZ_16K | SZ_32M);\r\nbreak;\r\ncase SZ_64K:\r\ncfg->pgsize_bitmap &= (SZ_64K | SZ_512M);\r\nbreak;\r\ndefault:\r\ncfg->pgsize_bitmap = 0;\r\n}\r\n}\r\nstatic struct arm_lpae_io_pgtable *\r\narm_lpae_alloc_pgtable(struct io_pgtable_cfg *cfg)\r\n{\r\nunsigned long va_bits, pgd_bits;\r\nstruct arm_lpae_io_pgtable *data;\r\narm_lpae_restrict_pgsizes(cfg);\r\nif (!(cfg->pgsize_bitmap & (SZ_4K | SZ_16K | SZ_64K)))\r\nreturn NULL;\r\nif (cfg->ias > ARM_LPAE_MAX_ADDR_BITS)\r\nreturn NULL;\r\nif (cfg->oas > ARM_LPAE_MAX_ADDR_BITS)\r\nreturn NULL;\r\nif (!selftest_running && cfg->iommu_dev->dma_pfn_offset) {\r\ndev_err(cfg->iommu_dev, "Cannot accommodate DMA offset for IOMMU page tables\n");\r\nreturn NULL;\r\n}\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\ndata->pg_shift = __ffs(cfg->pgsize_bitmap);\r\ndata->bits_per_level = data->pg_shift - ilog2(sizeof(arm_lpae_iopte));\r\nva_bits = cfg->ias - data->pg_shift;\r\ndata->levels = DIV_ROUND_UP(va_bits, data->bits_per_level);\r\npgd_bits = va_bits - (data->bits_per_level * (data->levels - 1));\r\ndata->pgd_size = 1UL << (pgd_bits + ilog2(sizeof(arm_lpae_iopte)));\r\ndata->iop.ops = (struct io_pgtable_ops) {\r\n.map = arm_lpae_map,\r\n.unmap = arm_lpae_unmap,\r\n.iova_to_phys = arm_lpae_iova_to_phys,\r\n};\r\nreturn data;\r\n}\r\nstatic struct io_pgtable *\r\narm_64_lpae_alloc_pgtable_s1(struct io_pgtable_cfg *cfg, void *cookie)\r\n{\r\nu64 reg;\r\nstruct arm_lpae_io_pgtable *data;\r\nif (cfg->quirks & ~IO_PGTABLE_QUIRK_ARM_NS)\r\nreturn NULL;\r\ndata = arm_lpae_alloc_pgtable(cfg);\r\nif (!data)\r\nreturn NULL;\r\nreg = (ARM_LPAE_TCR_SH_IS << ARM_LPAE_TCR_SH0_SHIFT) |\r\n(ARM_LPAE_TCR_RGN_WBWA << ARM_LPAE_TCR_IRGN0_SHIFT) |\r\n(ARM_LPAE_TCR_RGN_WBWA << ARM_LPAE_TCR_ORGN0_SHIFT);\r\nswitch (ARM_LPAE_GRANULE(data)) {\r\ncase SZ_4K:\r\nreg |= ARM_LPAE_TCR_TG0_4K;\r\nbreak;\r\ncase SZ_16K:\r\nreg |= ARM_LPAE_TCR_TG0_16K;\r\nbreak;\r\ncase SZ_64K:\r\nreg |= ARM_LPAE_TCR_TG0_64K;\r\nbreak;\r\n}\r\nswitch (cfg->oas) {\r\ncase 32:\r\nreg |= (ARM_LPAE_TCR_PS_32_BIT << ARM_LPAE_TCR_IPS_SHIFT);\r\nbreak;\r\ncase 36:\r\nreg |= (ARM_LPAE_TCR_PS_36_BIT << ARM_LPAE_TCR_IPS_SHIFT);\r\nbreak;\r\ncase 40:\r\nreg |= (ARM_LPAE_TCR_PS_40_BIT << ARM_LPAE_TCR_IPS_SHIFT);\r\nbreak;\r\ncase 42:\r\nreg |= (ARM_LPAE_TCR_PS_42_BIT << ARM_LPAE_TCR_IPS_SHIFT);\r\nbreak;\r\ncase 44:\r\nreg |= (ARM_LPAE_TCR_PS_44_BIT << ARM_LPAE_TCR_IPS_SHIFT);\r\nbreak;\r\ncase 48:\r\nreg |= (ARM_LPAE_TCR_PS_48_BIT << ARM_LPAE_TCR_IPS_SHIFT);\r\nbreak;\r\ndefault:\r\ngoto out_free_data;\r\n}\r\nreg |= (64ULL - cfg->ias) << ARM_LPAE_TCR_T0SZ_SHIFT;\r\nreg |= ARM_LPAE_TCR_EPD1;\r\ncfg->arm_lpae_s1_cfg.tcr = reg;\r\nreg = (ARM_LPAE_MAIR_ATTR_NC\r\n<< ARM_LPAE_MAIR_ATTR_SHIFT(ARM_LPAE_MAIR_ATTR_IDX_NC)) |\r\n(ARM_LPAE_MAIR_ATTR_WBRWA\r\n<< ARM_LPAE_MAIR_ATTR_SHIFT(ARM_LPAE_MAIR_ATTR_IDX_CACHE)) |\r\n(ARM_LPAE_MAIR_ATTR_DEVICE\r\n<< ARM_LPAE_MAIR_ATTR_SHIFT(ARM_LPAE_MAIR_ATTR_IDX_DEV));\r\ncfg->arm_lpae_s1_cfg.mair[0] = reg;\r\ncfg->arm_lpae_s1_cfg.mair[1] = 0;\r\ndata->pgd = __arm_lpae_alloc_pages(data->pgd_size, GFP_KERNEL, cfg);\r\nif (!data->pgd)\r\ngoto out_free_data;\r\nwmb();\r\ncfg->arm_lpae_s1_cfg.ttbr[0] = virt_to_phys(data->pgd);\r\ncfg->arm_lpae_s1_cfg.ttbr[1] = 0;\r\nreturn &data->iop;\r\nout_free_data:\r\nkfree(data);\r\nreturn NULL;\r\n}\r\nstatic struct io_pgtable *\r\narm_64_lpae_alloc_pgtable_s2(struct io_pgtable_cfg *cfg, void *cookie)\r\n{\r\nu64 reg, sl;\r\nstruct arm_lpae_io_pgtable *data;\r\nif (cfg->quirks)\r\nreturn NULL;\r\ndata = arm_lpae_alloc_pgtable(cfg);\r\nif (!data)\r\nreturn NULL;\r\nif (data->levels == ARM_LPAE_MAX_LEVELS) {\r\nunsigned long pgd_pages;\r\npgd_pages = data->pgd_size >> ilog2(sizeof(arm_lpae_iopte));\r\nif (pgd_pages <= ARM_LPAE_S2_MAX_CONCAT_PAGES) {\r\ndata->pgd_size = pgd_pages << data->pg_shift;\r\ndata->levels--;\r\n}\r\n}\r\nreg = ARM_64_LPAE_S2_TCR_RES1 |\r\n(ARM_LPAE_TCR_SH_IS << ARM_LPAE_TCR_SH0_SHIFT) |\r\n(ARM_LPAE_TCR_RGN_WBWA << ARM_LPAE_TCR_IRGN0_SHIFT) |\r\n(ARM_LPAE_TCR_RGN_WBWA << ARM_LPAE_TCR_ORGN0_SHIFT);\r\nsl = ARM_LPAE_START_LVL(data);\r\nswitch (ARM_LPAE_GRANULE(data)) {\r\ncase SZ_4K:\r\nreg |= ARM_LPAE_TCR_TG0_4K;\r\nsl++;\r\nbreak;\r\ncase SZ_16K:\r\nreg |= ARM_LPAE_TCR_TG0_16K;\r\nbreak;\r\ncase SZ_64K:\r\nreg |= ARM_LPAE_TCR_TG0_64K;\r\nbreak;\r\n}\r\nswitch (cfg->oas) {\r\ncase 32:\r\nreg |= (ARM_LPAE_TCR_PS_32_BIT << ARM_LPAE_TCR_PS_SHIFT);\r\nbreak;\r\ncase 36:\r\nreg |= (ARM_LPAE_TCR_PS_36_BIT << ARM_LPAE_TCR_PS_SHIFT);\r\nbreak;\r\ncase 40:\r\nreg |= (ARM_LPAE_TCR_PS_40_BIT << ARM_LPAE_TCR_PS_SHIFT);\r\nbreak;\r\ncase 42:\r\nreg |= (ARM_LPAE_TCR_PS_42_BIT << ARM_LPAE_TCR_PS_SHIFT);\r\nbreak;\r\ncase 44:\r\nreg |= (ARM_LPAE_TCR_PS_44_BIT << ARM_LPAE_TCR_PS_SHIFT);\r\nbreak;\r\ncase 48:\r\nreg |= (ARM_LPAE_TCR_PS_48_BIT << ARM_LPAE_TCR_PS_SHIFT);\r\nbreak;\r\ndefault:\r\ngoto out_free_data;\r\n}\r\nreg |= (64ULL - cfg->ias) << ARM_LPAE_TCR_T0SZ_SHIFT;\r\nreg |= (~sl & ARM_LPAE_TCR_SL0_MASK) << ARM_LPAE_TCR_SL0_SHIFT;\r\ncfg->arm_lpae_s2_cfg.vtcr = reg;\r\ndata->pgd = __arm_lpae_alloc_pages(data->pgd_size, GFP_KERNEL, cfg);\r\nif (!data->pgd)\r\ngoto out_free_data;\r\nwmb();\r\ncfg->arm_lpae_s2_cfg.vttbr = virt_to_phys(data->pgd);\r\nreturn &data->iop;\r\nout_free_data:\r\nkfree(data);\r\nreturn NULL;\r\n}\r\nstatic struct io_pgtable *\r\narm_32_lpae_alloc_pgtable_s1(struct io_pgtable_cfg *cfg, void *cookie)\r\n{\r\nstruct io_pgtable *iop;\r\nif (cfg->ias > 32 || cfg->oas > 40)\r\nreturn NULL;\r\ncfg->pgsize_bitmap &= (SZ_4K | SZ_2M | SZ_1G);\r\niop = arm_64_lpae_alloc_pgtable_s1(cfg, cookie);\r\nif (iop) {\r\ncfg->arm_lpae_s1_cfg.tcr |= ARM_32_LPAE_TCR_EAE;\r\ncfg->arm_lpae_s1_cfg.tcr &= 0xffffffff;\r\n}\r\nreturn iop;\r\n}\r\nstatic struct io_pgtable *\r\narm_32_lpae_alloc_pgtable_s2(struct io_pgtable_cfg *cfg, void *cookie)\r\n{\r\nstruct io_pgtable *iop;\r\nif (cfg->ias > 40 || cfg->oas > 40)\r\nreturn NULL;\r\ncfg->pgsize_bitmap &= (SZ_4K | SZ_2M | SZ_1G);\r\niop = arm_64_lpae_alloc_pgtable_s2(cfg, cookie);\r\nif (iop)\r\ncfg->arm_lpae_s2_cfg.vtcr &= 0xffffffff;\r\nreturn iop;\r\n}\r\nstatic void dummy_tlb_flush_all(void *cookie)\r\n{\r\nWARN_ON(cookie != cfg_cookie);\r\n}\r\nstatic void dummy_tlb_add_flush(unsigned long iova, size_t size,\r\nsize_t granule, bool leaf, void *cookie)\r\n{\r\nWARN_ON(cookie != cfg_cookie);\r\nWARN_ON(!(size & cfg_cookie->pgsize_bitmap));\r\n}\r\nstatic void dummy_tlb_sync(void *cookie)\r\n{\r\nWARN_ON(cookie != cfg_cookie);\r\n}\r\nstatic void __init arm_lpae_dump_ops(struct io_pgtable_ops *ops)\r\n{\r\nstruct arm_lpae_io_pgtable *data = io_pgtable_ops_to_data(ops);\r\nstruct io_pgtable_cfg *cfg = &data->iop.cfg;\r\npr_err("cfg: pgsize_bitmap 0x%lx, ias %u-bit\n",\r\ncfg->pgsize_bitmap, cfg->ias);\r\npr_err("data: %d levels, 0x%zx pgd_size, %lu pg_shift, %lu bits_per_level, pgd @ %p\n",\r\ndata->levels, data->pgd_size, data->pg_shift,\r\ndata->bits_per_level, data->pgd);\r\n}\r\nstatic int __init arm_lpae_run_tests(struct io_pgtable_cfg *cfg)\r\n{\r\nstatic const enum io_pgtable_fmt fmts[] = {\r\nARM_64_LPAE_S1,\r\nARM_64_LPAE_S2,\r\n};\r\nint i, j;\r\nunsigned long iova;\r\nsize_t size;\r\nstruct io_pgtable_ops *ops;\r\nselftest_running = true;\r\nfor (i = 0; i < ARRAY_SIZE(fmts); ++i) {\r\ncfg_cookie = cfg;\r\nops = alloc_io_pgtable_ops(fmts[i], cfg, cfg);\r\nif (!ops) {\r\npr_err("selftest: failed to allocate io pgtable ops\n");\r\nreturn -ENOMEM;\r\n}\r\nif (ops->iova_to_phys(ops, 42))\r\nreturn __FAIL(ops, i);\r\nif (ops->iova_to_phys(ops, SZ_1G + 42))\r\nreturn __FAIL(ops, i);\r\nif (ops->iova_to_phys(ops, SZ_2G + 42))\r\nreturn __FAIL(ops, i);\r\niova = 0;\r\nj = find_first_bit(&cfg->pgsize_bitmap, BITS_PER_LONG);\r\nwhile (j != BITS_PER_LONG) {\r\nsize = 1UL << j;\r\nif (ops->map(ops, iova, iova, size, IOMMU_READ |\r\nIOMMU_WRITE |\r\nIOMMU_NOEXEC |\r\nIOMMU_CACHE))\r\nreturn __FAIL(ops, i);\r\nif (!ops->map(ops, iova, iova + size, size,\r\nIOMMU_READ | IOMMU_NOEXEC))\r\nreturn __FAIL(ops, i);\r\nif (ops->iova_to_phys(ops, iova + 42) != (iova + 42))\r\nreturn __FAIL(ops, i);\r\niova += SZ_1G;\r\nj++;\r\nj = find_next_bit(&cfg->pgsize_bitmap, BITS_PER_LONG, j);\r\n}\r\nsize = 1UL << __ffs(cfg->pgsize_bitmap);\r\nif (ops->unmap(ops, SZ_1G + size, size) != size)\r\nreturn __FAIL(ops, i);\r\nif (ops->map(ops, SZ_1G + size, size, size, IOMMU_READ))\r\nreturn __FAIL(ops, i);\r\nif (ops->iova_to_phys(ops, SZ_1G + size + 42) != (size + 42))\r\nreturn __FAIL(ops, i);\r\niova = 0;\r\nj = find_first_bit(&cfg->pgsize_bitmap, BITS_PER_LONG);\r\nwhile (j != BITS_PER_LONG) {\r\nsize = 1UL << j;\r\nif (ops->unmap(ops, iova, size) != size)\r\nreturn __FAIL(ops, i);\r\nif (ops->iova_to_phys(ops, iova + 42))\r\nreturn __FAIL(ops, i);\r\nif (ops->map(ops, iova, iova, size, IOMMU_WRITE))\r\nreturn __FAIL(ops, i);\r\nif (ops->iova_to_phys(ops, iova + 42) != (iova + 42))\r\nreturn __FAIL(ops, i);\r\niova += SZ_1G;\r\nj++;\r\nj = find_next_bit(&cfg->pgsize_bitmap, BITS_PER_LONG, j);\r\n}\r\nfree_io_pgtable_ops(ops);\r\n}\r\nselftest_running = false;\r\nreturn 0;\r\n}\r\nstatic int __init arm_lpae_do_selftests(void)\r\n{\r\nstatic const unsigned long pgsize[] = {\r\nSZ_4K | SZ_2M | SZ_1G,\r\nSZ_16K | SZ_32M,\r\nSZ_64K | SZ_512M,\r\n};\r\nstatic const unsigned int ias[] = {\r\n32, 36, 40, 42, 44, 48,\r\n};\r\nint i, j, pass = 0, fail = 0;\r\nstruct io_pgtable_cfg cfg = {\r\n.tlb = &dummy_tlb_ops,\r\n.oas = 48,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(pgsize); ++i) {\r\nfor (j = 0; j < ARRAY_SIZE(ias); ++j) {\r\ncfg.pgsize_bitmap = pgsize[i];\r\ncfg.ias = ias[j];\r\npr_info("selftest: pgsize_bitmap 0x%08lx, IAS %u\n",\r\npgsize[i], ias[j]);\r\nif (arm_lpae_run_tests(&cfg))\r\nfail++;\r\nelse\r\npass++;\r\n}\r\n}\r\npr_info("selftest: completed with %d PASS %d FAIL\n", pass, fail);\r\nreturn fail ? -EFAULT : 0;\r\n}
