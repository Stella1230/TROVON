static int tzic_set_irq_fiq(unsigned int hwirq, unsigned int type)\r\n{\r\nunsigned int index, mask, value;\r\nindex = hwirq >> 5;\r\nif (unlikely(index >= 4))\r\nreturn -EINVAL;\r\nmask = 1U << (hwirq & 0x1F);\r\nvalue = imx_readl(tzic_base + TZIC_INTSEC0(index)) | mask;\r\nif (type)\r\nvalue &= ~mask;\r\nimx_writel(value, tzic_base + TZIC_INTSEC0(index));\r\nreturn 0;\r\n}\r\nstatic void tzic_irq_suspend(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nint idx = d->hwirq >> 5;\r\nimx_writel(gc->wake_active, tzic_base + TZIC_WAKEUP0(idx));\r\n}\r\nstatic void tzic_irq_resume(struct irq_data *d)\r\n{\r\nint idx = d->hwirq >> 5;\r\nimx_writel(imx_readl(tzic_base + TZIC_ENSET0(idx)),\r\ntzic_base + TZIC_WAKEUP0(idx));\r\n}\r\nstatic __init void tzic_init_gc(int idx, unsigned int irq_start)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("tzic", 1, irq_start, tzic_base,\r\nhandle_level_irq);\r\ngc->private = &tzic_extra_irq;\r\ngc->wake_enabled = IRQ_MSK(32);\r\nct = gc->chip_types;\r\nct->chip.irq_mask = irq_gc_mask_disable_reg;\r\nct->chip.irq_unmask = irq_gc_unmask_enable_reg;\r\nct->chip.irq_set_wake = irq_gc_set_wake;\r\nct->chip.irq_suspend = tzic_irq_suspend;\r\nct->chip.irq_resume = tzic_irq_resume;\r\nct->regs.disable = TZIC_ENCLEAR0(idx);\r\nct->regs.enable = TZIC_ENSET0(idx);\r\nirq_setup_generic_chip(gc, IRQ_MSK(32), 0, IRQ_NOREQUEST, 0);\r\n}\r\nstatic void __exception_irq_entry tzic_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 stat;\r\nint i, irqofs, handled;\r\ndo {\r\nhandled = 0;\r\nfor (i = 0; i < 4; i++) {\r\nstat = imx_readl(tzic_base + TZIC_HIPND(i)) &\r\nimx_readl(tzic_base + TZIC_INTSEC0(i));\r\nwhile (stat) {\r\nhandled = 1;\r\nirqofs = fls(stat) - 1;\r\nhandle_domain_irq(domain, irqofs + i * 32, regs);\r\nstat &= ~(1 << irqofs);\r\n}\r\n}\r\n} while (handled);\r\n}\r\nstatic int __init tzic_init_dt(struct device_node *np, struct device_node *p)\r\n{\r\nint irq_base;\r\nint i;\r\ntzic_base = of_iomap(np, 0);\r\nWARN_ON(!tzic_base);\r\ni = imx_readl(tzic_base + TZIC_INTCNTL);\r\nimx_writel(0x80010001, tzic_base + TZIC_INTCNTL);\r\nimx_writel(0x1f, tzic_base + TZIC_PRIOMASK);\r\nimx_writel(0x02, tzic_base + TZIC_SYNCCTRL);\r\nfor (i = 0; i < 4; i++)\r\nimx_writel(0xFFFFFFFF, tzic_base + TZIC_INTSEC0(i));\r\nfor (i = 0; i < 4; i++)\r\nimx_writel(0xFFFFFFFF, tzic_base + TZIC_ENCLEAR0(i));\r\nirq_base = irq_alloc_descs(-1, 0, TZIC_NUM_IRQS, numa_node_id());\r\nWARN_ON(irq_base < 0);\r\ndomain = irq_domain_add_legacy(np, TZIC_NUM_IRQS, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nWARN_ON(!domain);\r\nfor (i = 0; i < 4; i++, irq_base += 32)\r\ntzic_init_gc(i, irq_base);\r\nset_handle_irq(tzic_handle_irq);\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(FIQ_START);\r\n#endif\r\npr_info("TrustZone Interrupt Controller (TZIC) initialized\n");\r\nreturn 0;\r\n}\r\nint tzic_enable_wake(void)\r\n{\r\nunsigned int i;\r\nimx_writel(1, tzic_base + TZIC_DSMINT);\r\nif (unlikely(imx_readl(tzic_base + TZIC_DSMINT) == 0))\r\nreturn -EAGAIN;\r\nfor (i = 0; i < 4; i++)\r\nimx_writel(imx_readl(tzic_base + TZIC_ENSET0(i)),\r\ntzic_base + TZIC_WAKEUP0(i));\r\nreturn 0;\r\n}
