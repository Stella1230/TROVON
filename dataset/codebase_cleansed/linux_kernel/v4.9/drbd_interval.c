static inline\r\nsector_t interval_end(struct rb_node *node)\r\n{\r\nstruct drbd_interval *this = rb_entry(node, struct drbd_interval, rb);\r\nreturn this->end;\r\n}\r\nstatic inline sector_t\r\ncompute_subtree_last(struct drbd_interval *node)\r\n{\r\nsector_t max = node->sector + (node->size >> 9);\r\nif (node->rb.rb_left) {\r\nsector_t left = interval_end(node->rb.rb_left);\r\nif (left > max)\r\nmax = left;\r\n}\r\nif (node->rb.rb_right) {\r\nsector_t right = interval_end(node->rb.rb_right);\r\nif (right > max)\r\nmax = right;\r\n}\r\nreturn max;\r\n}\r\nbool\r\ndrbd_insert_interval(struct rb_root *root, struct drbd_interval *this)\r\n{\r\nstruct rb_node **new = &root->rb_node, *parent = NULL;\r\nsector_t this_end = this->sector + (this->size >> 9);\r\nBUG_ON(!IS_ALIGNED(this->size, 512));\r\nwhile (*new) {\r\nstruct drbd_interval *here =\r\nrb_entry(*new, struct drbd_interval, rb);\r\nparent = *new;\r\nif (here->end < this_end)\r\nhere->end = this_end;\r\nif (this->sector < here->sector)\r\nnew = &(*new)->rb_left;\r\nelse if (this->sector > here->sector)\r\nnew = &(*new)->rb_right;\r\nelse if (this < here)\r\nnew = &(*new)->rb_left;\r\nelse if (this > here)\r\nnew = &(*new)->rb_right;\r\nelse\r\nreturn false;\r\n}\r\nthis->end = this_end;\r\nrb_link_node(&this->rb, parent, new);\r\nrb_insert_augmented(&this->rb, root, &augment_callbacks);\r\nreturn true;\r\n}\r\nbool\r\ndrbd_contains_interval(struct rb_root *root, sector_t sector,\r\nstruct drbd_interval *interval)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nwhile (node) {\r\nstruct drbd_interval *here =\r\nrb_entry(node, struct drbd_interval, rb);\r\nif (sector < here->sector)\r\nnode = node->rb_left;\r\nelse if (sector > here->sector)\r\nnode = node->rb_right;\r\nelse if (interval < here)\r\nnode = node->rb_left;\r\nelse if (interval > here)\r\nnode = node->rb_right;\r\nelse\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid\r\ndrbd_remove_interval(struct rb_root *root, struct drbd_interval *this)\r\n{\r\nrb_erase_augmented(&this->rb, root, &augment_callbacks);\r\n}\r\nstruct drbd_interval *\r\ndrbd_find_overlap(struct rb_root *root, sector_t sector, unsigned int size)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nstruct drbd_interval *overlap = NULL;\r\nsector_t end = sector + (size >> 9);\r\nBUG_ON(!IS_ALIGNED(size, 512));\r\nwhile (node) {\r\nstruct drbd_interval *here =\r\nrb_entry(node, struct drbd_interval, rb);\r\nif (node->rb_left &&\r\nsector < interval_end(node->rb_left)) {\r\nnode = node->rb_left;\r\n} else if (here->sector < end &&\r\nsector < here->sector + (here->size >> 9)) {\r\noverlap = here;\r\nbreak;\r\n} else if (sector >= here->sector) {\r\nnode = node->rb_right;\r\n} else\r\nbreak;\r\n}\r\nreturn overlap;\r\n}\r\nstruct drbd_interval *\r\ndrbd_next_overlap(struct drbd_interval *i, sector_t sector, unsigned int size)\r\n{\r\nsector_t end = sector + (size >> 9);\r\nstruct rb_node *node;\r\nfor (;;) {\r\nnode = rb_next(&i->rb);\r\nif (!node)\r\nreturn NULL;\r\ni = rb_entry(node, struct drbd_interval, rb);\r\nif (i->sector >= end)\r\nreturn NULL;\r\nif (sector < i->sector + (i->size >> 9))\r\nreturn i;\r\n}\r\n}
