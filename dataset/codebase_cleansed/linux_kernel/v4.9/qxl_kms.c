static void qxl_dump_mode(struct qxl_device *qdev, void *p)\r\n{\r\nstruct qxl_mode *m = p;\r\nDRM_DEBUG_KMS("%d: %dx%d %d bits, stride %d, %dmm x %dmm, orientation %d\n",\r\nm->id, m->x_res, m->y_res, m->bits, m->stride, m->x_mili,\r\nm->y_mili, m->orientation);\r\n}\r\nstatic bool qxl_check_device(struct qxl_device *qdev)\r\n{\r\nstruct qxl_rom *rom = qdev->rom;\r\nint mode_offset;\r\nint i;\r\nif (rom->magic != 0x4f525851) {\r\nDRM_ERROR("bad rom signature %x\n", rom->magic);\r\nreturn false;\r\n}\r\nDRM_INFO("Device Version %d.%d\n", rom->id, rom->update_id);\r\nDRM_INFO("Compression level %d log level %d\n", rom->compression_level,\r\nrom->log_level);\r\nDRM_INFO("Currently using mode #%d, list at 0x%x\n",\r\nrom->mode, rom->modes_offset);\r\nDRM_INFO("%d io pages at offset 0x%x\n",\r\nrom->num_io_pages, rom->pages_offset);\r\nDRM_INFO("%d byte draw area at offset 0x%x\n",\r\nrom->surface0_area_size, rom->draw_area_offset);\r\nqdev->vram_size = rom->surface0_area_size;\r\nDRM_INFO("RAM header offset: 0x%x\n", rom->ram_header_offset);\r\nmode_offset = rom->modes_offset / 4;\r\nqdev->mode_info.num_modes = ((u32 *)rom)[mode_offset];\r\nDRM_INFO("rom modes offset 0x%x for %d modes\n", rom->modes_offset,\r\nqdev->mode_info.num_modes);\r\nqdev->mode_info.modes = (void *)((uint32_t *)rom + mode_offset + 1);\r\nfor (i = 0; i < qdev->mode_info.num_modes; i++)\r\nqxl_dump_mode(qdev, qdev->mode_info.modes + i);\r\nreturn true;\r\n}\r\nstatic void setup_hw_slot(struct qxl_device *qdev, int slot_index,\r\nstruct qxl_memslot *slot)\r\n{\r\nqdev->ram_header->mem_slot.mem_start = slot->start_phys_addr;\r\nqdev->ram_header->mem_slot.mem_end = slot->end_phys_addr;\r\nqxl_io_memslot_add(qdev, slot_index);\r\n}\r\nstatic uint8_t setup_slot(struct qxl_device *qdev, uint8_t slot_index_offset,\r\nunsigned long start_phys_addr, unsigned long end_phys_addr)\r\n{\r\nuint64_t high_bits;\r\nstruct qxl_memslot *slot;\r\nuint8_t slot_index;\r\nslot_index = qdev->rom->slots_start + slot_index_offset;\r\nslot = &qdev->mem_slots[slot_index];\r\nslot->start_phys_addr = start_phys_addr;\r\nslot->end_phys_addr = end_phys_addr;\r\nsetup_hw_slot(qdev, slot_index, slot);\r\nslot->generation = qdev->rom->slot_generation;\r\nhigh_bits = slot_index << qdev->slot_gen_bits;\r\nhigh_bits |= slot->generation;\r\nhigh_bits <<= (64 - (qdev->slot_gen_bits + qdev->slot_id_bits));\r\nslot->high_bits = high_bits;\r\nreturn slot_index;\r\n}\r\nvoid qxl_reinit_memslots(struct qxl_device *qdev)\r\n{\r\nsetup_hw_slot(qdev, qdev->main_mem_slot, &qdev->mem_slots[qdev->main_mem_slot]);\r\nsetup_hw_slot(qdev, qdev->surfaces_mem_slot, &qdev->mem_slots[qdev->surfaces_mem_slot]);\r\n}\r\nstatic void qxl_gc_work(struct work_struct *work)\r\n{\r\nstruct qxl_device *qdev = container_of(work, struct qxl_device, gc_work);\r\nqxl_garbage_collect(qdev);\r\n}\r\nstatic int qxl_device_init(struct qxl_device *qdev,\r\nstruct drm_device *ddev,\r\nstruct pci_dev *pdev,\r\nunsigned long flags)\r\n{\r\nint r, sb;\r\nqdev->dev = &pdev->dev;\r\nqdev->ddev = ddev;\r\nqdev->pdev = pdev;\r\nqdev->flags = flags;\r\nmutex_init(&qdev->gem.mutex);\r\nmutex_init(&qdev->update_area_mutex);\r\nmutex_init(&qdev->release_mutex);\r\nmutex_init(&qdev->surf_evict_mutex);\r\nINIT_LIST_HEAD(&qdev->gem.objects);\r\nqdev->rom_base = pci_resource_start(pdev, 2);\r\nqdev->rom_size = pci_resource_len(pdev, 2);\r\nqdev->vram_base = pci_resource_start(pdev, 0);\r\nqdev->io_base = pci_resource_start(pdev, 3);\r\nqdev->vram_mapping = io_mapping_create_wc(qdev->vram_base, pci_resource_len(pdev, 0));\r\nif (pci_resource_len(pdev, 4) > 0) {\r\nsb = 4;\r\nqdev->surfaceram_base = pci_resource_start(pdev, sb);\r\nqdev->surfaceram_size = pci_resource_len(pdev, sb);\r\nqdev->surface_mapping =\r\nio_mapping_create_wc(qdev->surfaceram_base,\r\nqdev->surfaceram_size);\r\n}\r\nif (qdev->surface_mapping == NULL) {\r\nsb = 1;\r\nqdev->surfaceram_base = pci_resource_start(pdev, sb);\r\nqdev->surfaceram_size = pci_resource_len(pdev, sb);\r\nqdev->surface_mapping =\r\nio_mapping_create_wc(qdev->surfaceram_base,\r\nqdev->surfaceram_size);\r\n}\r\nDRM_DEBUG_KMS("qxl: vram %llx-%llx(%dM %dk), surface %llx-%llx(%dM %dk, %s)\n",\r\n(unsigned long long)qdev->vram_base,\r\n(unsigned long long)pci_resource_end(pdev, 0),\r\n(int)pci_resource_len(pdev, 0) / 1024 / 1024,\r\n(int)pci_resource_len(pdev, 0) / 1024,\r\n(unsigned long long)qdev->surfaceram_base,\r\n(unsigned long long)pci_resource_end(pdev, sb),\r\n(int)qdev->surfaceram_size / 1024 / 1024,\r\n(int)qdev->surfaceram_size / 1024,\r\n(sb == 4) ? "64bit" : "32bit");\r\nqdev->rom = ioremap(qdev->rom_base, qdev->rom_size);\r\nif (!qdev->rom) {\r\npr_err("Unable to ioremap ROM\n");\r\nreturn -ENOMEM;\r\n}\r\nqxl_check_device(qdev);\r\nr = qxl_bo_init(qdev);\r\nif (r) {\r\nDRM_ERROR("bo init failed %d\n", r);\r\nreturn r;\r\n}\r\nqdev->ram_header = ioremap(qdev->vram_base +\r\nqdev->rom->ram_header_offset,\r\nsizeof(*qdev->ram_header));\r\nqdev->command_ring = qxl_ring_create(&(qdev->ram_header->cmd_ring_hdr),\r\nsizeof(struct qxl_command),\r\nQXL_COMMAND_RING_SIZE,\r\nqdev->io_base + QXL_IO_NOTIFY_CMD,\r\nfalse,\r\n&qdev->display_event);\r\nqdev->cursor_ring = qxl_ring_create(\r\n&(qdev->ram_header->cursor_ring_hdr),\r\nsizeof(struct qxl_command),\r\nQXL_CURSOR_RING_SIZE,\r\nqdev->io_base + QXL_IO_NOTIFY_CMD,\r\nfalse,\r\n&qdev->cursor_event);\r\nqdev->release_ring = qxl_ring_create(\r\n&(qdev->ram_header->release_ring_hdr),\r\nsizeof(uint64_t),\r\nQXL_RELEASE_RING_SIZE, 0, true,\r\nNULL);\r\nqdev->n_mem_slots = qdev->rom->slots_end;\r\nqdev->slot_gen_bits = qdev->rom->slot_gen_bits;\r\nqdev->slot_id_bits = qdev->rom->slot_id_bits;\r\nqdev->va_slot_mask =\r\n(~(uint64_t)0) >> (qdev->slot_id_bits + qdev->slot_gen_bits);\r\nqdev->mem_slots =\r\nkmalloc(qdev->n_mem_slots * sizeof(struct qxl_memslot),\r\nGFP_KERNEL);\r\nidr_init(&qdev->release_idr);\r\nspin_lock_init(&qdev->release_idr_lock);\r\nspin_lock_init(&qdev->release_lock);\r\nidr_init(&qdev->surf_id_idr);\r\nspin_lock_init(&qdev->surf_id_idr_lock);\r\nmutex_init(&qdev->async_io_mutex);\r\nqxl_io_reset(qdev);\r\nr = qxl_irq_init(qdev);\r\nif (r)\r\nreturn r;\r\nqdev->main_mem_slot = setup_slot(qdev, 0,\r\n(unsigned long)qdev->vram_base,\r\n(unsigned long)qdev->vram_base + qdev->rom->ram_header_offset);\r\nqdev->surfaces_mem_slot = setup_slot(qdev, 1,\r\n(unsigned long)qdev->surfaceram_base,\r\n(unsigned long)qdev->surfaceram_base + qdev->surfaceram_size);\r\nDRM_INFO("main mem slot %d [%lx,%x]\n",\r\nqdev->main_mem_slot,\r\n(unsigned long)qdev->vram_base, qdev->rom->ram_header_offset);\r\nDRM_INFO("surface mem slot %d [%lx,%lx]\n",\r\nqdev->surfaces_mem_slot,\r\n(unsigned long)qdev->surfaceram_base,\r\n(unsigned long)qdev->surfaceram_size);\r\nINIT_WORK(&qdev->gc_work, qxl_gc_work);\r\nreturn 0;\r\n}\r\nstatic void qxl_device_fini(struct qxl_device *qdev)\r\n{\r\nif (qdev->current_release_bo[0])\r\nqxl_bo_unref(&qdev->current_release_bo[0]);\r\nif (qdev->current_release_bo[1])\r\nqxl_bo_unref(&qdev->current_release_bo[1]);\r\nflush_work(&qdev->gc_work);\r\nqxl_ring_free(qdev->command_ring);\r\nqxl_ring_free(qdev->cursor_ring);\r\nqxl_ring_free(qdev->release_ring);\r\nqxl_bo_fini(qdev);\r\nio_mapping_free(qdev->surface_mapping);\r\nio_mapping_free(qdev->vram_mapping);\r\niounmap(qdev->ram_header);\r\niounmap(qdev->rom);\r\nqdev->rom = NULL;\r\nqdev->mode_info.modes = NULL;\r\nqdev->mode_info.num_modes = 0;\r\nqxl_debugfs_remove_files(qdev);\r\n}\r\nint qxl_driver_unload(struct drm_device *dev)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nif (qdev == NULL)\r\nreturn 0;\r\ndrm_vblank_cleanup(dev);\r\nqxl_modeset_fini(qdev);\r\nqxl_device_fini(qdev);\r\nkfree(qdev);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nint qxl_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct qxl_device *qdev;\r\nint r;\r\nqdev = kzalloc(sizeof(struct qxl_device), GFP_KERNEL);\r\nif (qdev == NULL)\r\nreturn -ENOMEM;\r\ndev->dev_private = qdev;\r\nr = qxl_device_init(qdev, dev, dev->pdev, flags);\r\nif (r)\r\ngoto out;\r\nr = drm_vblank_init(dev, 1);\r\nif (r)\r\ngoto unload;\r\nr = qxl_modeset_init(qdev);\r\nif (r)\r\ngoto unload;\r\ndrm_kms_helper_poll_init(qdev->ddev);\r\nreturn 0;\r\nunload:\r\nqxl_driver_unload(dev);\r\nout:\r\nkfree(qdev);\r\nreturn r;\r\n}
