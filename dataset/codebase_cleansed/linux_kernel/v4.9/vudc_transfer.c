static int get_frame_limit(enum usb_device_speed speed)\r\n{\r\nswitch (speed) {\r\ncase USB_SPEED_LOW:\r\nreturn 8 * 12 ;\r\ncase USB_SPEED_FULL:\r\nreturn 64 * 19 ;\r\ncase USB_SPEED_HIGH:\r\nreturn 512 * 13 * 8 ;\r\ncase USB_SPEED_SUPER:\r\nreturn 490000;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic int handle_control_request(struct vudc *udc, struct urb *urb,\r\nstruct usb_ctrlrequest *setup,\r\nint *status)\r\n{\r\nstruct vep *ep2;\r\nint ret_val = 1;\r\nunsigned w_index;\r\nunsigned w_value;\r\nw_index = le16_to_cpu(setup->wIndex);\r\nw_value = le16_to_cpu(setup->wValue);\r\nswitch (setup->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nif (setup->bRequestType != DEV_REQUEST)\r\nbreak;\r\nudc->address = w_value;\r\nret_val = 0;\r\n*status = 0;\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nif (setup->bRequestType == DEV_REQUEST) {\r\nret_val = 0;\r\nswitch (w_value) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nbreak;\r\ncase USB_DEVICE_B_HNP_ENABLE:\r\nudc->gadget.b_hnp_enable = 1;\r\nbreak;\r\ncase USB_DEVICE_A_HNP_SUPPORT:\r\nudc->gadget.a_hnp_support = 1;\r\nbreak;\r\ncase USB_DEVICE_A_ALT_HNP_SUPPORT:\r\nudc->gadget.a_alt_hnp_support = 1;\r\nbreak;\r\ndefault:\r\nret_val = -EOPNOTSUPP;\r\n}\r\nif (ret_val == 0) {\r\nudc->devstatus |= (1 << w_value);\r\n*status = 0;\r\n}\r\n} else if (setup->bRequestType == EP_REQUEST) {\r\nep2 = vudc_find_endpoint(udc, w_index);\r\nif (!ep2 || ep2->ep.name == udc->ep[0].ep.name) {\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nep2->halted = 1;\r\nret_val = 0;\r\n*status = 0;\r\n}\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nif (setup->bRequestType == DEV_REQUEST) {\r\nret_val = 0;\r\nswitch (w_value) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nw_value = USB_DEVICE_REMOTE_WAKEUP;\r\nbreak;\r\ncase USB_DEVICE_U1_ENABLE:\r\ncase USB_DEVICE_U2_ENABLE:\r\ncase USB_DEVICE_LTM_ENABLE:\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (ret_val == 0) {\r\nudc->devstatus &= ~(1 << w_value);\r\n*status = 0;\r\n}\r\n} else if (setup->bRequestType == EP_REQUEST) {\r\nep2 = vudc_find_endpoint(udc, w_index);\r\nif (!ep2) {\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (!ep2->wedged)\r\nep2->halted = 0;\r\nret_val = 0;\r\n*status = 0;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nif (setup->bRequestType == DEV_INREQUEST\r\n|| setup->bRequestType == INTF_INREQUEST\r\n|| setup->bRequestType == EP_INREQUEST) {\r\nchar *buf;\r\nbuf = (char *)urb->transfer_buffer;\r\nif (urb->transfer_buffer_length > 0) {\r\nif (setup->bRequestType == EP_INREQUEST) {\r\nep2 = vudc_find_endpoint(udc, w_index);\r\nif (!ep2) {\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nbuf[0] = ep2->halted;\r\n} else if (setup->bRequestType ==\r\nDEV_INREQUEST) {\r\nbuf[0] = (u8)udc->devstatus;\r\n} else\r\nbuf[0] = 0;\r\n}\r\nif (urb->transfer_buffer_length > 1)\r\nbuf[1] = 0;\r\nurb->actual_length = min_t(u32, 2,\r\nurb->transfer_buffer_length);\r\nret_val = 0;\r\n*status = 0;\r\n}\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int transfer(struct vudc *udc,\r\nstruct urb *urb, struct vep *ep, int limit)\r\n{\r\nstruct vrequest *req;\r\nint sent = 0;\r\ntop:\r\nlist_for_each_entry(req, &ep->req_queue, req_entry) {\r\nunsigned host_len, dev_len, len;\r\nvoid *ubuf_pos, *rbuf_pos;\r\nint is_short, to_host;\r\nint rescan = 0;\r\nhost_len = urb->transfer_buffer_length - urb->actual_length;\r\ndev_len = req->req.length - req->req.actual;\r\nlen = min(host_len, dev_len);\r\nto_host = usb_pipein(urb->pipe);\r\nif (unlikely(len == 0))\r\nis_short = 1;\r\nelse {\r\nif (len >= ep->ep.maxpacket) {\r\nis_short = 0;\r\nif (len % ep->ep.maxpacket > 0)\r\nrescan = 1;\r\nlen -= len % ep->ep.maxpacket;\r\n} else {\r\nis_short = 1;\r\n}\r\nubuf_pos = urb->transfer_buffer + urb->actual_length;\r\nrbuf_pos = req->req.buf + req->req.actual;\r\nif (urb->pipe & USB_DIR_IN)\r\nmemcpy(ubuf_pos, rbuf_pos, len);\r\nelse\r\nmemcpy(rbuf_pos, ubuf_pos, len);\r\nurb->actual_length += len;\r\nreq->req.actual += len;\r\nsent += len;\r\n}\r\nif (is_short) {\r\nif (host_len == dev_len) {\r\nreq->req.status = 0;\r\nurb->status = 0;\r\n} else if (to_host) {\r\nreq->req.status = 0;\r\nif (dev_len > host_len)\r\nurb->status = -EOVERFLOW;\r\nelse\r\nurb->status = 0;\r\n} else {\r\nurb->status = 0;\r\nif (host_len > dev_len)\r\nreq->req.status = -EOVERFLOW;\r\nelse\r\nreq->req.status = 0;\r\n}\r\n} else {\r\nif (req->req.length == req->req.actual) {\r\nif (req->req.zero && to_host)\r\nrescan = 1;\r\nelse\r\nreq->req.status = 0;\r\n}\r\nif (urb->transfer_buffer_length == urb->actual_length) {\r\nif (urb->transfer_flags & URB_ZERO_PACKET &&\r\n!to_host)\r\nrescan = 1;\r\nelse\r\nurb->status = 0;\r\n}\r\n}\r\nif (req->req.status != -EINPROGRESS) {\r\nlist_del_init(&req->req_entry);\r\nspin_unlock(&udc->lock);\r\nusb_gadget_giveback_request(&ep->ep, &req->req);\r\nspin_lock(&udc->lock);\r\nrescan = 1;\r\n}\r\nif (urb->status != -EINPROGRESS)\r\nbreak;\r\nif (rescan)\r\ngoto top;\r\n}\r\nreturn sent;\r\n}\r\nstatic void v_timer(unsigned long _vudc)\r\n{\r\nstruct vudc *udc = (struct vudc *) _vudc;\r\nstruct transfer_timer *timer = &udc->tr_timer;\r\nstruct urbp *urb_p, *tmp;\r\nunsigned long flags;\r\nstruct usb_ep *_ep;\r\nstruct vep *ep;\r\nint ret = 0;\r\nint total, limit;\r\nspin_lock_irqsave(&udc->lock, flags);\r\ntotal = get_frame_limit(udc->gadget.speed);\r\nif (total < 0) {\r\ntimer->state = VUDC_TR_IDLE;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn;\r\n}\r\nif (time_after(jiffies, timer->frame_start + msecs_to_jiffies(1))) {\r\ntimer->frame_limit = total;\r\ntimer->frame_start = jiffies;\r\n} else {\r\ntotal = timer->frame_limit;\r\n}\r\nlist_for_each_entry(_ep, &udc->gadget.ep_list, ep_list) {\r\nep = to_vep(_ep);\r\nep->already_seen = 0;\r\n}\r\nrestart:\r\nlist_for_each_entry_safe(urb_p, tmp, &udc->urb_queue, urb_entry) {\r\nstruct urb *urb = urb_p->urb;\r\nep = urb_p->ep;\r\nif (urb->unlinked)\r\ngoto return_urb;\r\nif (timer->state != VUDC_TR_RUNNING)\r\ncontinue;\r\nif (!ep) {\r\nurb->status = -EPROTO;\r\ngoto return_urb;\r\n}\r\nif (total <= 0 && ep->type == USB_ENDPOINT_XFER_BULK)\r\ncontinue;\r\nif (ep->already_seen)\r\ncontinue;\r\nep->already_seen = 1;\r\nif (ep == &udc->ep[0] && urb_p->new) {\r\nep->setup_stage = 1;\r\nurb_p->new = 0;\r\n}\r\nif (ep->halted && !ep->setup_stage) {\r\nurb->status = -EPIPE;\r\ngoto return_urb;\r\n}\r\nif (ep == &udc->ep[0] && ep->setup_stage) {\r\nep->setup_stage = 0;\r\nep->halted = 0;\r\nret = handle_control_request(udc, urb,\r\n(struct usb_ctrlrequest *) urb->setup_packet,\r\n(&urb->status));\r\nif (ret > 0) {\r\nspin_unlock(&udc->lock);\r\nret = udc->driver->setup(&udc->gadget,\r\n(struct usb_ctrlrequest *)\r\nurb->setup_packet);\r\nspin_lock(&udc->lock);\r\n}\r\nif (ret >= 0) {\r\nlimit = 64 * 1024;\r\ngoto treat_control_like_bulk;\r\n} else {\r\nurb->status = -EPIPE;\r\nurb->actual_length = 0;\r\ngoto return_urb;\r\n}\r\n}\r\nlimit = total;\r\nswitch (ep->type) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nurb->status = -EXDEV;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nlimit += urb->transfer_buffer_length;\r\ndefault:\r\ntreat_control_like_bulk:\r\ntotal -= transfer(udc, urb, ep, limit);\r\n}\r\nif (urb->status == -EINPROGRESS)\r\ncontinue;\r\nreturn_urb:\r\nif (ep)\r\nep->already_seen = ep->setup_stage = 0;\r\nspin_lock(&udc->lock_tx);\r\nlist_del(&urb_p->urb_entry);\r\nif (!urb->unlinked) {\r\nv_enqueue_ret_submit(udc, urb_p);\r\n} else {\r\nv_enqueue_ret_unlink(udc, urb_p->seqnum,\r\nurb->unlinked);\r\nfree_urbp_and_urb(urb_p);\r\n}\r\nwake_up(&udc->tx_waitq);\r\nspin_unlock(&udc->lock_tx);\r\ngoto restart;\r\n}\r\nif (list_empty(&udc->urb_queue))\r\ntimer->state = VUDC_TR_IDLE;\r\nelse\r\nmod_timer(&timer->timer,\r\ntimer->frame_start + msecs_to_jiffies(1));\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nvoid v_init_timer(struct vudc *udc)\r\n{\r\nstruct transfer_timer *t = &udc->tr_timer;\r\nsetup_timer(&t->timer, v_timer, (unsigned long) udc);\r\nt->state = VUDC_TR_STOPPED;\r\n}\r\nvoid v_start_timer(struct vudc *udc)\r\n{\r\nstruct transfer_timer *t = &udc->tr_timer;\r\ndev_dbg(&udc->pdev->dev, "timer start");\r\nswitch (t->state) {\r\ncase VUDC_TR_RUNNING:\r\nreturn;\r\ncase VUDC_TR_IDLE:\r\nreturn v_kick_timer(udc, jiffies);\r\ncase VUDC_TR_STOPPED:\r\nt->state = VUDC_TR_IDLE;\r\nt->frame_start = jiffies;\r\nt->frame_limit = get_frame_limit(udc->gadget.speed);\r\nreturn v_kick_timer(udc, jiffies);\r\n}\r\n}\r\nvoid v_kick_timer(struct vudc *udc, unsigned long time)\r\n{\r\nstruct transfer_timer *t = &udc->tr_timer;\r\ndev_dbg(&udc->pdev->dev, "timer kick");\r\nswitch (t->state) {\r\ncase VUDC_TR_RUNNING:\r\nreturn;\r\ncase VUDC_TR_IDLE:\r\nt->state = VUDC_TR_RUNNING;\r\ncase VUDC_TR_STOPPED:\r\nmod_timer(&t->timer, time);\r\n}\r\n}\r\nvoid v_stop_timer(struct vudc *udc)\r\n{\r\nstruct transfer_timer *t = &udc->tr_timer;\r\ndev_dbg(&udc->pdev->dev, "timer stop");\r\nt->state = VUDC_TR_STOPPED;\r\n}
