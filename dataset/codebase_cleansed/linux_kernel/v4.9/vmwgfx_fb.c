static int vmw_fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct vmw_fb_par *par = info->par;\r\nu32 *pal = par->pseudo_palette;\r\nif (regno > 15) {\r\nDRM_ERROR("Bad regno %u.\n", regno);\r\nreturn 1;\r\n}\r\nswitch (par->set_fb->depth) {\r\ncase 24:\r\ncase 32:\r\npal[regno] = ((red & 0xff00) << 8) |\r\n(green & 0xff00) |\r\n((blue & 0xff00) >> 8);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad depth %u, bpp %u.\n", par->set_fb->depth,\r\npar->set_fb->bits_per_pixel);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint depth = var->bits_per_pixel;\r\nstruct vmw_fb_par *par = info->par;\r\nstruct vmw_private *vmw_priv = par->vmw_priv;\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\ndepth = (var->transp.length > 0) ? 32 : 24;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad bpp %u.\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nswitch (depth) {\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 8;\r\nvar->transp.offset = 24;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad depth %u.\n", depth);\r\nreturn -EINVAL;\r\n}\r\nif ((var->xoffset + var->xres) > par->max_width ||\r\n(var->yoffset + var->yres) > par->max_height) {\r\nDRM_ERROR("Requested geom can not fit in framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nif (!vmw_kms_validate_mode_vram(vmw_priv,\r\nvar->xres * var->bits_per_pixel/8,\r\nvar->yoffset + var->yres)) {\r\nDRM_ERROR("Requested geom can not fit in framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_blank(int blank, struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vmw_fb_dirty_flush(struct work_struct *work)\r\n{\r\nstruct vmw_fb_par *par = container_of(work, struct vmw_fb_par,\r\nlocal_work.work);\r\nstruct vmw_private *vmw_priv = par->vmw_priv;\r\nstruct fb_info *info = vmw_priv->fb_info;\r\nunsigned long irq_flags;\r\ns32 dst_x1, dst_x2, dst_y1, dst_y2, w, h;\r\nu32 cpp, max_x, max_y;\r\nstruct drm_clip_rect clip;\r\nstruct drm_framebuffer *cur_fb;\r\nu8 *src_ptr, *dst_ptr;\r\nif (vmw_priv->suspended)\r\nreturn;\r\nmutex_lock(&par->bo_mutex);\r\ncur_fb = par->set_fb;\r\nif (!cur_fb)\r\ngoto out_unlock;\r\nspin_lock_irqsave(&par->dirty.lock, irq_flags);\r\nif (!par->dirty.active) {\r\nspin_unlock_irqrestore(&par->dirty.lock, irq_flags);\r\ngoto out_unlock;\r\n}\r\ncpp = (cur_fb->bits_per_pixel + 7) / 8;\r\nmax_x = par->fb_x + cur_fb->width;\r\nmax_y = par->fb_y + cur_fb->height;\r\ndst_x1 = par->dirty.x1 - par->fb_x;\r\ndst_y1 = par->dirty.y1 - par->fb_y;\r\ndst_x1 = max_t(s32, dst_x1, 0);\r\ndst_y1 = max_t(s32, dst_y1, 0);\r\ndst_x2 = par->dirty.x2 - par->fb_x;\r\ndst_y2 = par->dirty.y2 - par->fb_y;\r\ndst_x2 = min_t(s32, dst_x2, max_x);\r\ndst_y2 = min_t(s32, dst_y2, max_y);\r\nw = dst_x2 - dst_x1;\r\nh = dst_y2 - dst_y1;\r\nw = max_t(s32, 0, w);\r\nh = max_t(s32, 0, h);\r\npar->dirty.x1 = par->dirty.x2 = 0;\r\npar->dirty.y1 = par->dirty.y2 = 0;\r\nspin_unlock_irqrestore(&par->dirty.lock, irq_flags);\r\nif (w && h) {\r\ndst_ptr = (u8 *)par->bo_ptr +\r\n(dst_y1 * par->set_fb->pitches[0] + dst_x1 * cpp);\r\nsrc_ptr = (u8 *)par->vmalloc +\r\n((dst_y1 + par->fb_y) * info->fix.line_length +\r\n(dst_x1 + par->fb_x) * cpp);\r\nwhile (h-- > 0) {\r\nmemcpy(dst_ptr, src_ptr, w*cpp);\r\ndst_ptr += par->set_fb->pitches[0];\r\nsrc_ptr += info->fix.line_length;\r\n}\r\nclip.x1 = dst_x1;\r\nclip.x2 = dst_x2;\r\nclip.y1 = dst_y1;\r\nclip.y2 = dst_y2;\r\nWARN_ON_ONCE(par->set_fb->funcs->dirty(cur_fb, NULL, 0, 0,\r\n&clip, 1));\r\nvmw_fifo_flush(vmw_priv, false);\r\n}\r\nout_unlock:\r\nmutex_unlock(&par->bo_mutex);\r\n}\r\nstatic void vmw_fb_dirty_mark(struct vmw_fb_par *par,\r\nunsigned x1, unsigned y1,\r\nunsigned width, unsigned height)\r\n{\r\nunsigned long flags;\r\nunsigned x2 = x1 + width;\r\nunsigned y2 = y1 + height;\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\nif (par->dirty.x1 == par->dirty.x2) {\r\npar->dirty.x1 = x1;\r\npar->dirty.y1 = y1;\r\npar->dirty.x2 = x2;\r\npar->dirty.y2 = y2;\r\nif (par->dirty.active)\r\nschedule_delayed_work(&par->local_work,\r\nVMW_DIRTY_DELAY);\r\n} else {\r\nif (x1 < par->dirty.x1)\r\npar->dirty.x1 = x1;\r\nif (y1 < par->dirty.y1)\r\npar->dirty.y1 = y1;\r\nif (x2 > par->dirty.x2)\r\npar->dirty.x2 = x2;\r\nif (y2 > par->dirty.y2)\r\npar->dirty.y2 = y2;\r\n}\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\n}\r\nstatic int vmw_fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct vmw_fb_par *par = info->par;\r\nif ((var->xoffset + var->xres) > var->xres_virtual ||\r\n(var->yoffset + var->yres) > var->yres_virtual) {\r\nDRM_ERROR("Requested panning can not fit in framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&par->bo_mutex);\r\npar->fb_x = var->xoffset;\r\npar->fb_y = var->yoffset;\r\nif (par->set_fb)\r\nvmw_fb_dirty_mark(par, par->fb_x, par->fb_y, par->set_fb->width,\r\npar->set_fb->height);\r\nmutex_unlock(&par->bo_mutex);\r\nreturn 0;\r\n}\r\nstatic void vmw_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct vmw_fb_par *par = info->par;\r\nunsigned long start, end, min, max;\r\nunsigned long flags;\r\nstruct page *page;\r\nint y1, y2;\r\nmin = ULONG_MAX;\r\nmax = 0;\r\nlist_for_each_entry(page, pagelist, lru) {\r\nstart = page->index << PAGE_SHIFT;\r\nend = start + PAGE_SIZE - 1;\r\nmin = min(min, start);\r\nmax = max(max, end);\r\n}\r\nif (min < max) {\r\ny1 = min / info->fix.line_length;\r\ny2 = (max / info->fix.line_length) + 1;\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\npar->dirty.x1 = 0;\r\npar->dirty.y1 = y1;\r\npar->dirty.x2 = info->var.xres;\r\npar->dirty.y2 = y2;\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\ncancel_delayed_work(&par->local_work);\r\nschedule_delayed_work(&par->local_work, 0);\r\n}\r\n}\r\nstatic void vmw_fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\ncfb_fillrect(info, rect);\r\nvmw_fb_dirty_mark(info->par, rect->dx, rect->dy,\r\nrect->width, rect->height);\r\n}\r\nstatic void vmw_fb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\r\n{\r\ncfb_copyarea(info, region);\r\nvmw_fb_dirty_mark(info->par, region->dx, region->dy,\r\nregion->width, region->height);\r\n}\r\nstatic void vmw_fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\ncfb_imageblit(info, image);\r\nvmw_fb_dirty_mark(info->par, image->dx, image->dy,\r\nimage->width, image->height);\r\n}\r\nstatic int vmw_fb_create_bo(struct vmw_private *vmw_priv,\r\nsize_t size, struct vmw_dma_buffer **out)\r\n{\r\nstruct vmw_dma_buffer *vmw_bo;\r\nint ret;\r\n(void) ttm_write_lock(&vmw_priv->reservation_sem, false);\r\nvmw_bo = kmalloc(sizeof(*vmw_bo), GFP_KERNEL);\r\nif (!vmw_bo) {\r\nret = -ENOMEM;\r\ngoto err_unlock;\r\n}\r\nret = vmw_dmabuf_init(vmw_priv, vmw_bo, size,\r\n&vmw_sys_placement,\r\nfalse,\r\n&vmw_dmabuf_bo_free);\r\nif (unlikely(ret != 0))\r\ngoto err_unlock;\r\n*out = vmw_bo;\r\nttm_write_unlock(&vmw_priv->reservation_sem);\r\nreturn 0;\r\nerr_unlock:\r\nttm_write_unlock(&vmw_priv->reservation_sem);\r\nreturn ret;\r\n}\r\nstatic int vmw_fb_compute_depth(struct fb_var_screeninfo *var,\r\nint *depth)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\n*depth = (var->transp.length > 0) ? 32 : 24;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad bpp %u.\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_kms_detach(struct vmw_fb_par *par,\r\nbool detach_bo,\r\nbool unref_bo)\r\n{\r\nstruct drm_framebuffer *cur_fb = par->set_fb;\r\nint ret;\r\nif (par->set_mode) {\r\nstruct drm_mode_set set;\r\nset.crtc = par->crtc;\r\nset.x = 0;\r\nset.y = 0;\r\nset.mode = NULL;\r\nset.fb = NULL;\r\nset.num_connectors = 1;\r\nset.connectors = &par->con;\r\nret = drm_mode_set_config_internal(&set);\r\nif (ret) {\r\nDRM_ERROR("Could not unset a mode.\n");\r\nreturn ret;\r\n}\r\ndrm_mode_destroy(par->vmw_priv->dev, par->set_mode);\r\npar->set_mode = NULL;\r\n}\r\nif (cur_fb) {\r\ndrm_framebuffer_unreference(cur_fb);\r\npar->set_fb = NULL;\r\n}\r\nif (par->vmw_bo && detach_bo) {\r\nif (par->bo_ptr) {\r\nttm_bo_kunmap(&par->map);\r\npar->bo_ptr = NULL;\r\n}\r\nif (unref_bo)\r\nvmw_dmabuf_unreference(&par->vmw_bo);\r\nelse\r\nvmw_dmabuf_unpin(par->vmw_priv, par->vmw_bo, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_kms_framebuffer(struct fb_info *info)\r\n{\r\nstruct drm_mode_fb_cmd mode_cmd;\r\nstruct vmw_fb_par *par = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct drm_framebuffer *cur_fb;\r\nstruct vmw_framebuffer *vfb;\r\nint ret = 0;\r\nsize_t new_bo_size;\r\nret = vmw_fb_compute_depth(var, &mode_cmd.depth);\r\nif (ret)\r\nreturn ret;\r\nmode_cmd.width = var->xres;\r\nmode_cmd.height = var->yres;\r\nmode_cmd.bpp = var->bits_per_pixel;\r\nmode_cmd.pitch = ((mode_cmd.bpp + 7) / 8) * mode_cmd.width;\r\ncur_fb = par->set_fb;\r\nif (cur_fb && cur_fb->width == mode_cmd.width &&\r\ncur_fb->height == mode_cmd.height &&\r\ncur_fb->bits_per_pixel == mode_cmd.bpp &&\r\ncur_fb->depth == mode_cmd.depth &&\r\ncur_fb->pitches[0] == mode_cmd.pitch)\r\nreturn 0;\r\nnew_bo_size = (size_t) mode_cmd.pitch * (size_t) mode_cmd.height;\r\nret = vmw_fb_kms_detach(par,\r\npar->bo_size < new_bo_size ||\r\npar->bo_size > 2*new_bo_size,\r\ntrue);\r\nif (ret)\r\nreturn ret;\r\nif (!par->vmw_bo) {\r\nret = vmw_fb_create_bo(par->vmw_priv, new_bo_size,\r\n&par->vmw_bo);\r\nif (ret) {\r\nDRM_ERROR("Failed creating a buffer object for "\r\n"fbdev.\n");\r\nreturn ret;\r\n}\r\npar->bo_size = new_bo_size;\r\n}\r\nvfb = vmw_kms_new_framebuffer(par->vmw_priv, par->vmw_bo, NULL,\r\ntrue, &mode_cmd);\r\nif (IS_ERR(vfb))\r\nreturn PTR_ERR(vfb);\r\npar->set_fb = &vfb->base;\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_set_par(struct fb_info *info)\r\n{\r\nstruct vmw_fb_par *par = info->par;\r\nstruct vmw_private *vmw_priv = par->vmw_priv;\r\nstruct drm_mode_set set;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct drm_display_mode new_mode = { DRM_MODE("fb_mode",\r\nDRM_MODE_TYPE_DRIVER,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\nDRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC)\r\n};\r\nstruct drm_display_mode *old_mode;\r\nstruct drm_display_mode *mode;\r\nint ret;\r\nold_mode = par->set_mode;\r\nmode = drm_mode_duplicate(vmw_priv->dev, &new_mode);\r\nif (!mode) {\r\nDRM_ERROR("Could not create new fb mode.\n");\r\nreturn -ENOMEM;\r\n}\r\nmode->hdisplay = var->xres;\r\nmode->vdisplay = var->yres;\r\nvmw_guess_mode_timing(mode);\r\nif (old_mode && drm_mode_equal(old_mode, mode)) {\r\ndrm_mode_destroy(vmw_priv->dev, mode);\r\nmode = old_mode;\r\nold_mode = NULL;\r\n} else if (!vmw_kms_validate_mode_vram(vmw_priv,\r\nmode->hdisplay *\r\nDIV_ROUND_UP(var->bits_per_pixel, 8),\r\nmode->vdisplay)) {\r\ndrm_mode_destroy(vmw_priv->dev, mode);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&par->bo_mutex);\r\ndrm_modeset_lock_all(vmw_priv->dev);\r\nret = vmw_fb_kms_framebuffer(info);\r\nif (ret)\r\ngoto out_unlock;\r\npar->fb_x = var->xoffset;\r\npar->fb_y = var->yoffset;\r\nset.crtc = par->crtc;\r\nset.x = 0;\r\nset.y = 0;\r\nset.mode = mode;\r\nset.fb = par->set_fb;\r\nset.num_connectors = 1;\r\nset.connectors = &par->con;\r\nret = drm_mode_set_config_internal(&set);\r\nif (ret)\r\ngoto out_unlock;\r\nif (!par->bo_ptr) {\r\nstruct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(set.fb);\r\nret = vfb->pin(vfb);\r\nif (ret) {\r\nDRM_ERROR("Could not pin the fbdev framebuffer.\n");\r\ngoto out_unlock;\r\n}\r\nret = ttm_bo_kmap(&par->vmw_bo->base, 0,\r\npar->vmw_bo->base.num_pages, &par->map);\r\nif (ret) {\r\nvfb->unpin(vfb);\r\nDRM_ERROR("Could not map the fbdev framebuffer.\n");\r\ngoto out_unlock;\r\n}\r\npar->bo_ptr = ttm_kmap_obj_virtual(&par->map, &par->bo_iowrite);\r\n}\r\nvmw_fb_dirty_mark(par, par->fb_x, par->fb_y,\r\npar->set_fb->width, par->set_fb->height);\r\nschedule_delayed_work(&par->local_work, 0);\r\nout_unlock:\r\nif (old_mode)\r\ndrm_mode_destroy(vmw_priv->dev, old_mode);\r\npar->set_mode = mode;\r\ndrm_modeset_unlock_all(vmw_priv->dev);\r\nmutex_unlock(&par->bo_mutex);\r\nreturn ret;\r\n}\r\nint vmw_fb_init(struct vmw_private *vmw_priv)\r\n{\r\nstruct device *device = &vmw_priv->dev->pdev->dev;\r\nstruct vmw_fb_par *par;\r\nstruct fb_info *info;\r\nunsigned fb_width, fb_height;\r\nunsigned fb_bpp, fb_depth, fb_offset, fb_pitch, fb_size;\r\nstruct drm_display_mode *init_mode;\r\nint ret;\r\nfb_bpp = 32;\r\nfb_depth = 24;\r\nfb_width = min(vmw_priv->fb_max_width, (unsigned)2048);\r\nfb_height = min(vmw_priv->fb_max_height, (unsigned)2048);\r\nfb_pitch = fb_width * fb_bpp / 8;\r\nfb_size = fb_pitch * fb_height;\r\nfb_offset = vmw_read(vmw_priv, SVGA_REG_FB_OFFSET);\r\ninfo = framebuffer_alloc(sizeof(*par), device);\r\nif (!info)\r\nreturn -ENOMEM;\r\nvmw_priv->fb_info = info;\r\npar = info->par;\r\nmemset(par, 0, sizeof(*par));\r\nINIT_DELAYED_WORK(&par->local_work, &vmw_fb_dirty_flush);\r\npar->vmw_priv = vmw_priv;\r\npar->vmalloc = NULL;\r\npar->max_width = fb_width;\r\npar->max_height = fb_height;\r\ndrm_modeset_lock_all(vmw_priv->dev);\r\nret = vmw_kms_fbdev_init_data(vmw_priv, 0, par->max_width,\r\npar->max_height, &par->con,\r\n&par->crtc, &init_mode);\r\nif (ret) {\r\ndrm_modeset_unlock_all(vmw_priv->dev);\r\ngoto err_kms;\r\n}\r\ninfo->var.xres = init_mode->hdisplay;\r\ninfo->var.yres = init_mode->vdisplay;\r\ndrm_modeset_unlock_all(vmw_priv->dev);\r\npar->vmalloc = vzalloc(fb_size);\r\nif (unlikely(par->vmalloc == NULL)) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nstrcpy(info->fix.id, "svgadrmfb");\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 1;\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->fix.line_length = fb_pitch;\r\ninfo->fix.smem_start = 0;\r\ninfo->fix.smem_len = fb_size;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\ninfo->screen_base = (char __iomem *)par->vmalloc;\r\ninfo->screen_size = fb_size;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->fbops = &vmw_fb_ops;\r\ninfo->var.red.offset = 16;\r\ninfo->var.green.offset = 8;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\ninfo->var.transp.offset = 0;\r\ninfo->var.transp.length = 0;\r\ninfo->var.xres_virtual = fb_width;\r\ninfo->var.yres_virtual = fb_height;\r\ninfo->var.bits_per_pixel = fb_bpp;\r\ninfo->var.xoffset = 0;\r\ninfo->var.yoffset = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto err_aper;\r\n}\r\ninfo->apertures->ranges[0].base = vmw_priv->vram_start;\r\ninfo->apertures->ranges[0].size = vmw_priv->vram_size;\r\npar->dirty.x1 = par->dirty.x2 = 0;\r\npar->dirty.y1 = par->dirty.y2 = 0;\r\npar->dirty.active = true;\r\nspin_lock_init(&par->dirty.lock);\r\nmutex_init(&par->bo_mutex);\r\ninfo->fbdefio = &vmw_defio;\r\nfb_deferred_io_init(info);\r\nret = register_framebuffer(info);\r\nif (unlikely(ret != 0))\r\ngoto err_defio;\r\nvmw_fb_set_par(info);\r\nreturn 0;\r\nerr_defio:\r\nfb_deferred_io_cleanup(info);\r\nerr_aper:\r\nerr_free:\r\nvfree(par->vmalloc);\r\nerr_kms:\r\nframebuffer_release(info);\r\nvmw_priv->fb_info = NULL;\r\nreturn ret;\r\n}\r\nint vmw_fb_close(struct vmw_private *vmw_priv)\r\n{\r\nstruct fb_info *info;\r\nstruct vmw_fb_par *par;\r\nif (!vmw_priv->fb_info)\r\nreturn 0;\r\ninfo = vmw_priv->fb_info;\r\npar = info->par;\r\nfb_deferred_io_cleanup(info);\r\ncancel_delayed_work_sync(&par->local_work);\r\nunregister_framebuffer(info);\r\n(void) vmw_fb_kms_detach(par, true, true);\r\nvfree(par->vmalloc);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nint vmw_fb_off(struct vmw_private *vmw_priv)\r\n{\r\nstruct fb_info *info;\r\nstruct vmw_fb_par *par;\r\nunsigned long flags;\r\nif (!vmw_priv->fb_info)\r\nreturn -EINVAL;\r\ninfo = vmw_priv->fb_info;\r\npar = info->par;\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\npar->dirty.active = false;\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\nflush_delayed_work(&info->deferred_work);\r\nflush_delayed_work(&par->local_work);\r\nmutex_lock(&par->bo_mutex);\r\n(void) vmw_fb_kms_detach(par, true, false);\r\nmutex_unlock(&par->bo_mutex);\r\nreturn 0;\r\n}\r\nint vmw_fb_on(struct vmw_private *vmw_priv)\r\n{\r\nstruct fb_info *info;\r\nstruct vmw_fb_par *par;\r\nunsigned long flags;\r\nif (!vmw_priv->fb_info)\r\nreturn -EINVAL;\r\ninfo = vmw_priv->fb_info;\r\npar = info->par;\r\nvmw_fb_set_par(info);\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\npar->dirty.active = true;\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\nreturn 0;\r\n}
