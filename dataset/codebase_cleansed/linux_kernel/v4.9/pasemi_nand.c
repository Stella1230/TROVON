static void pasemi_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nwhile (len > 0x800) {\r\nmemcpy_fromio(buf, chip->IO_ADDR_R, 0x800);\r\nbuf += 0x800;\r\nlen -= 0x800;\r\n}\r\nmemcpy_fromio(buf, chip->IO_ADDR_R, len);\r\n}\r\nstatic void pasemi_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nwhile (len > 0x800) {\r\nmemcpy_toio(chip->IO_ADDR_R, buf, 0x800);\r\nbuf += 0x800;\r\nlen -= 0x800;\r\n}\r\nmemcpy_toio(chip->IO_ADDR_R, buf, len);\r\n}\r\nstatic void pasemi_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nout_8(chip->IO_ADDR_W + (1 << CLE_PIN_CTL), cmd);\r\nelse\r\nout_8(chip->IO_ADDR_W + (1 << ALE_PIN_CTL), cmd);\r\neieio();\r\ninl(lpcctl);\r\n}\r\nint pasemi_device_ready(struct mtd_info *mtd)\r\n{\r\nreturn !!(inl(lpcctl) & LBICTRL_LPCCTL_NR);\r\n}\r\nstatic int pasemi_nand_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct pci_dev *pdev;\r\nstruct device_node *np = dev->of_node;\r\nstruct resource res;\r\nstruct nand_chip *chip;\r\nint err = 0;\r\nerr = of_address_to_resource(np, 0, &res);\r\nif (err)\r\nreturn -EINVAL;\r\nif (pasemi_nand_mtd)\r\nreturn -ENODEV;\r\ndev_dbg(dev, "pasemi_nand at %pR\n", &res);\r\nchip = kzalloc(sizeof(struct nand_chip), GFP_KERNEL);\r\nif (!chip) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\npasemi_nand_mtd = nand_to_mtd(chip);\r\npasemi_nand_mtd->dev.parent = dev;\r\nchip->IO_ADDR_R = of_iomap(np, 0);\r\nchip->IO_ADDR_W = chip->IO_ADDR_R;\r\nif (!chip->IO_ADDR_R) {\r\nerr = -EIO;\r\ngoto out_mtd;\r\n}\r\npdev = pci_get_device(PCI_VENDOR_ID_PASEMI, 0xa008, NULL);\r\nif (!pdev) {\r\nerr = -ENODEV;\r\ngoto out_ior;\r\n}\r\nlpcctl = pci_resource_start(pdev, 0);\r\npci_dev_put(pdev);\r\nif (!request_region(lpcctl, 4, driver_name)) {\r\nerr = -EBUSY;\r\ngoto out_ior;\r\n}\r\nchip->cmd_ctrl = pasemi_hwcontrol;\r\nchip->dev_ready = pasemi_device_ready;\r\nchip->read_buf = pasemi_read_buf;\r\nchip->write_buf = pasemi_write_buf;\r\nchip->chip_delay = 0;\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nchip->ecc.algo = NAND_ECC_HAMMING;\r\nchip->bbt_options = NAND_BBT_USE_FLASH;\r\nif (nand_scan(pasemi_nand_mtd, 1)) {\r\nerr = -ENXIO;\r\ngoto out_lpc;\r\n}\r\nif (mtd_device_register(pasemi_nand_mtd, NULL, 0)) {\r\ndev_err(dev, "Unable to register MTD device\n");\r\nerr = -ENODEV;\r\ngoto out_lpc;\r\n}\r\ndev_info(dev, "PA Semi NAND flash at %pR, control at I/O %x\n", &res,\r\nlpcctl);\r\nreturn 0;\r\nout_lpc:\r\nrelease_region(lpcctl, 4);\r\nout_ior:\r\niounmap(chip->IO_ADDR_R);\r\nout_mtd:\r\nkfree(chip);\r\nout:\r\nreturn err;\r\n}\r\nstatic int pasemi_nand_remove(struct platform_device *ofdev)\r\n{\r\nstruct nand_chip *chip;\r\nif (!pasemi_nand_mtd)\r\nreturn 0;\r\nchip = mtd_to_nand(pasemi_nand_mtd);\r\nnand_release(pasemi_nand_mtd);\r\nrelease_region(lpcctl, 4);\r\niounmap(chip->IO_ADDR_R);\r\nkfree(chip);\r\npasemi_nand_mtd = NULL;\r\nreturn 0;\r\n}
