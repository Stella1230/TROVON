static bool opal_prd_range_is_valid(uint64_t addr, uint64_t size)\r\n{\r\nstruct device_node *parent, *node;\r\nbool found;\r\nif (addr + size < addr)\r\nreturn false;\r\nparent = of_find_node_by_path("/reserved-memory");\r\nif (!parent)\r\nreturn false;\r\nfound = false;\r\nfor_each_child_of_node(parent, node) {\r\nuint64_t range_addr, range_size, range_end;\r\nconst __be32 *addrp;\r\nconst char *label;\r\naddrp = of_get_address(node, 0, &range_size, NULL);\r\nrange_addr = of_read_number(addrp, 2);\r\nrange_end = range_addr + range_size;\r\nlabel = of_get_property(node, "ibm,prd-label", NULL);\r\nif (!label)\r\ncontinue;\r\nif (range_end <= range_addr)\r\ncontinue;\r\nif (addr >= range_addr && addr + size <= range_end) {\r\nfound = true;\r\nof_node_put(node);\r\nbreak;\r\n}\r\n}\r\nof_node_put(parent);\r\nreturn found;\r\n}\r\nstatic int opal_prd_open(struct inode *inode, struct file *file)\r\n{\r\nif (atomic_xchg(&prd_usage, 1) == 1)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int opal_prd_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nsize_t addr, size;\r\npgprot_t page_prot;\r\nint rc;\r\npr_devel("opal_prd_mmap(0x%016lx, 0x%016lx, 0x%lx, 0x%lx)\n",\r\nvma->vm_start, vma->vm_end, vma->vm_pgoff,\r\nvma->vm_flags);\r\naddr = vma->vm_pgoff << PAGE_SHIFT;\r\nsize = vma->vm_end - vma->vm_start;\r\nif (!opal_prd_range_is_valid(addr, size))\r\nreturn -EINVAL;\r\npage_prot = phys_mem_access_prot(file, vma->vm_pgoff,\r\nsize, vma->vm_page_prot);\r\nrc = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, size,\r\npage_prot);\r\nreturn rc;\r\n}\r\nstatic bool opal_msg_queue_empty(void)\r\n{\r\nunsigned long flags;\r\nbool ret;\r\nspin_lock_irqsave(&opal_prd_msg_queue_lock, flags);\r\nret = list_empty(&opal_prd_msg_queue);\r\nspin_unlock_irqrestore(&opal_prd_msg_queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int opal_prd_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\npoll_wait(file, &opal_prd_msg_wait, wait);\r\nif (!opal_msg_queue_empty())\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic ssize_t opal_prd_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct opal_prd_msg_queue_item *item;\r\nunsigned long flags;\r\nssize_t size, err;\r\nint rc;\r\nif (count < sizeof(item->msg))\r\nreturn -EINVAL;\r\nif (*ppos)\r\nreturn -ESPIPE;\r\nitem = NULL;\r\nfor (;;) {\r\nspin_lock_irqsave(&opal_prd_msg_queue_lock, flags);\r\nif (!list_empty(&opal_prd_msg_queue)) {\r\nitem = list_first_entry(&opal_prd_msg_queue,\r\nstruct opal_prd_msg_queue_item, list);\r\nlist_del(&item->list);\r\n}\r\nspin_unlock_irqrestore(&opal_prd_msg_queue_lock, flags);\r\nif (item)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nrc = wait_event_interruptible(opal_prd_msg_wait,\r\n!opal_msg_queue_empty());\r\nif (rc)\r\nreturn -EINTR;\r\n}\r\nsize = be16_to_cpu(item->msg.size);\r\nif (size > count) {\r\nerr = -EINVAL;\r\ngoto err_requeue;\r\n}\r\nrc = copy_to_user(buf, &item->msg, size);\r\nif (rc) {\r\nerr = -EFAULT;\r\ngoto err_requeue;\r\n}\r\nkfree(item);\r\nreturn size;\r\nerr_requeue:\r\nspin_lock_irqsave(&opal_prd_msg_queue_lock, flags);\r\nlist_add(&item->list, &opal_prd_msg_queue);\r\nspin_unlock_irqrestore(&opal_prd_msg_queue_lock, flags);\r\nreturn err;\r\n}\r\nstatic ssize_t opal_prd_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct opal_prd_msg_header hdr;\r\nssize_t size;\r\nvoid *msg;\r\nint rc;\r\nsize = sizeof(hdr);\r\nif (count < size)\r\nreturn -EINVAL;\r\nrc = copy_from_user(&hdr, buf, sizeof(hdr));\r\nif (rc)\r\nreturn -EFAULT;\r\nsize = be16_to_cpu(hdr.size);\r\nmsg = kmalloc(size, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nrc = copy_from_user(msg, buf, size);\r\nif (rc) {\r\nsize = -EFAULT;\r\ngoto out_free;\r\n}\r\nrc = opal_prd_msg(msg);\r\nif (rc) {\r\npr_warn("write: opal_prd_msg returned %d\n", rc);\r\nsize = -EIO;\r\n}\r\nout_free:\r\nkfree(msg);\r\nreturn size;\r\n}\r\nstatic int opal_prd_release(struct inode *inode, struct file *file)\r\n{\r\nstruct opal_prd_msg_header msg;\r\nmsg.size = cpu_to_be16(sizeof(msg));\r\nmsg.type = OPAL_PRD_MSG_TYPE_FINI;\r\nopal_prd_msg((struct opal_prd_msg *)&msg);\r\natomic_xchg(&prd_usage, 0);\r\nreturn 0;\r\n}\r\nstatic long opal_prd_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long param)\r\n{\r\nstruct opal_prd_info info;\r\nstruct opal_prd_scom scom;\r\nint rc = 0;\r\nswitch (cmd) {\r\ncase OPAL_PRD_GET_INFO:\r\nmemset(&info, 0, sizeof(info));\r\ninfo.version = OPAL_PRD_KERNEL_VERSION;\r\nrc = copy_to_user((void __user *)param, &info, sizeof(info));\r\nif (rc)\r\nreturn -EFAULT;\r\nbreak;\r\ncase OPAL_PRD_SCOM_READ:\r\nrc = copy_from_user(&scom, (void __user *)param, sizeof(scom));\r\nif (rc)\r\nreturn -EFAULT;\r\nscom.rc = opal_xscom_read(scom.chip, scom.addr,\r\n(__be64 *)&scom.data);\r\nscom.data = be64_to_cpu(scom.data);\r\npr_devel("ioctl SCOM_READ: chip %llx addr %016llx data %016llx rc %lld\n",\r\nscom.chip, scom.addr, scom.data, scom.rc);\r\nrc = copy_to_user((void __user *)param, &scom, sizeof(scom));\r\nif (rc)\r\nreturn -EFAULT;\r\nbreak;\r\ncase OPAL_PRD_SCOM_WRITE:\r\nrc = copy_from_user(&scom, (void __user *)param, sizeof(scom));\r\nif (rc)\r\nreturn -EFAULT;\r\nscom.rc = opal_xscom_write(scom.chip, scom.addr, scom.data);\r\npr_devel("ioctl SCOM_WRITE: chip %llx addr %016llx data %016llx rc %lld\n",\r\nscom.chip, scom.addr, scom.data, scom.rc);\r\nrc = copy_to_user((void __user *)param, &scom, sizeof(scom));\r\nif (rc)\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int opal_prd_msg_notifier(struct notifier_block *nb,\r\nunsigned long msg_type, void *_msg)\r\n{\r\nstruct opal_prd_msg_queue_item *item;\r\nstruct opal_prd_msg_header *hdr;\r\nstruct opal_msg *msg = _msg;\r\nint msg_size, item_size;\r\nunsigned long flags;\r\nif (msg_type != OPAL_MSG_PRD)\r\nreturn 0;\r\nhdr = (void *)msg->params;\r\nmsg_size = be16_to_cpu(hdr->size);\r\nitem_size = msg_size + sizeof(*item) - sizeof(item->msg);\r\nitem = kzalloc(item_size, GFP_ATOMIC);\r\nif (!item)\r\nreturn -ENOMEM;\r\nmemcpy(&item->msg, msg->params, msg_size);\r\nspin_lock_irqsave(&opal_prd_msg_queue_lock, flags);\r\nlist_add_tail(&item->list, &opal_prd_msg_queue);\r\nspin_unlock_irqrestore(&opal_prd_msg_queue_lock, flags);\r\nwake_up_interruptible(&opal_prd_msg_wait);\r\nreturn 0;\r\n}\r\nstatic int opal_prd_probe(struct platform_device *pdev)\r\n{\r\nint rc;\r\nif (!pdev || !pdev->dev.of_node)\r\nreturn -ENODEV;\r\nif (prd_node)\r\nreturn -EBUSY;\r\nprd_node = pdev->dev.of_node;\r\nrc = opal_message_notifier_register(OPAL_MSG_PRD, &opal_prd_event_nb);\r\nif (rc) {\r\npr_err("Couldn't register event notifier\n");\r\nreturn rc;\r\n}\r\nrc = misc_register(&opal_prd_dev);\r\nif (rc) {\r\npr_err("failed to register miscdev\n");\r\nopal_message_notifier_unregister(OPAL_MSG_PRD,\r\n&opal_prd_event_nb);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int opal_prd_remove(struct platform_device *pdev)\r\n{\r\nmisc_deregister(&opal_prd_dev);\r\nopal_message_notifier_unregister(OPAL_MSG_PRD, &opal_prd_event_nb);\r\nreturn 0;\r\n}
