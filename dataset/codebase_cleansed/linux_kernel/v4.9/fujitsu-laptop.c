static int call_fext_func(int cmd, int arg0, int arg1, int arg2)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_object params[4] = {\r\n{ .type = ACPI_TYPE_INTEGER },\r\n{ .type = ACPI_TYPE_INTEGER },\r\n{ .type = ACPI_TYPE_INTEGER },\r\n{ .type = ACPI_TYPE_INTEGER }\r\n};\r\nstruct acpi_object_list arg_list = { 4, &params[0] };\r\nunsigned long long value;\r\nacpi_handle handle = NULL;\r\nstatus = acpi_get_handle(fujitsu_hotkey->acpi_handle, "FUNC", &handle);\r\nif (ACPI_FAILURE(status)) {\r\nvdbg_printk(FUJLAPTOP_DBG_ERROR,\r\n"FUNC interface is not present\n");\r\nreturn -ENODEV;\r\n}\r\nparams[0].integer.value = cmd;\r\nparams[1].integer.value = arg0;\r\nparams[2].integer.value = arg1;\r\nparams[3].integer.value = arg2;\r\nstatus = acpi_evaluate_integer(handle, NULL, &arg_list, &value);\r\nif (ACPI_FAILURE(status)) {\r\nvdbg_printk(FUJLAPTOP_DBG_WARN,\r\n"FUNC 0x%x (args 0x%x, 0x%x, 0x%x) call failed\n",\r\ncmd, arg0, arg1, arg2);\r\nreturn -ENODEV;\r\n}\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE,\r\n"FUNC 0x%x (args 0x%x, 0x%x, 0x%x) returned 0x%x\n",\r\ncmd, arg0, arg1, arg2, (int)value);\r\nreturn value;\r\n}\r\nstatic void logolamp_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nif (brightness >= LED_FULL) {\r\ncall_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_POWERON, FUNC_LED_ON);\r\ncall_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_ALWAYS, FUNC_LED_ON);\r\n} else if (brightness >= LED_HALF) {\r\ncall_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_POWERON, FUNC_LED_ON);\r\ncall_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_ALWAYS, FUNC_LED_OFF);\r\n} else {\r\ncall_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_POWERON, FUNC_LED_OFF);\r\n}\r\n}\r\nstatic void kblamps_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nif (brightness >= LED_FULL)\r\ncall_fext_func(FUNC_LEDS, 0x1, KEYBOARD_LAMPS, FUNC_LED_ON);\r\nelse\r\ncall_fext_func(FUNC_LEDS, 0x1, KEYBOARD_LAMPS, FUNC_LED_OFF);\r\n}\r\nstatic void radio_led_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nif (brightness >= LED_FULL)\r\ncall_fext_func(FUNC_RFKILL, 0x5, RADIO_LED_ON, RADIO_LED_ON);\r\nelse\r\ncall_fext_func(FUNC_RFKILL, 0x5, RADIO_LED_ON, 0x0);\r\n}\r\nstatic void eco_led_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nint curr;\r\ncurr = call_fext_func(FUNC_LEDS, 0x2, ECO_LED, 0x0);\r\nif (brightness >= LED_FULL)\r\ncall_fext_func(FUNC_LEDS, 0x1, ECO_LED, curr | ECO_LED_ON);\r\nelse\r\ncall_fext_func(FUNC_LEDS, 0x1, ECO_LED, curr & ~ECO_LED_ON);\r\n}\r\nstatic enum led_brightness logolamp_get(struct led_classdev *cdev)\r\n{\r\nenum led_brightness brightness = LED_OFF;\r\nint poweron, always;\r\npoweron = call_fext_func(FUNC_LEDS, 0x2, LOGOLAMP_POWERON, 0x0);\r\nif (poweron == FUNC_LED_ON) {\r\nbrightness = LED_HALF;\r\nalways = call_fext_func(FUNC_LEDS, 0x2, LOGOLAMP_ALWAYS, 0x0);\r\nif (always == FUNC_LED_ON)\r\nbrightness = LED_FULL;\r\n}\r\nreturn brightness;\r\n}\r\nstatic enum led_brightness kblamps_get(struct led_classdev *cdev)\r\n{\r\nenum led_brightness brightness = LED_OFF;\r\nif (call_fext_func(FUNC_LEDS, 0x2, KEYBOARD_LAMPS, 0x0) == FUNC_LED_ON)\r\nbrightness = LED_FULL;\r\nreturn brightness;\r\n}\r\nstatic enum led_brightness radio_led_get(struct led_classdev *cdev)\r\n{\r\nenum led_brightness brightness = LED_OFF;\r\nif (call_fext_func(FUNC_RFKILL, 0x4, 0x0, 0x0) & RADIO_LED_ON)\r\nbrightness = LED_FULL;\r\nreturn brightness;\r\n}\r\nstatic enum led_brightness eco_led_get(struct led_classdev *cdev)\r\n{\r\nenum led_brightness brightness = LED_OFF;\r\nif (call_fext_func(FUNC_LEDS, 0x2, ECO_LED, 0x0) & ECO_LED_ON)\r\nbrightness = LED_FULL;\r\nreturn brightness;\r\n}\r\nstatic int set_lcd_level(int level)\r\n{\r\nacpi_status status = AE_OK;\r\nacpi_handle handle = NULL;\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE, "set lcd level via SBLL [%d]\n",\r\nlevel);\r\nif (level < 0 || level >= fujitsu->max_brightness)\r\nreturn -EINVAL;\r\nstatus = acpi_get_handle(fujitsu->acpi_handle, "SBLL", &handle);\r\nif (ACPI_FAILURE(status)) {\r\nvdbg_printk(FUJLAPTOP_DBG_ERROR, "SBLL not present\n");\r\nreturn -ENODEV;\r\n}\r\nstatus = acpi_execute_simple_method(handle, NULL, level);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int set_lcd_level_alt(int level)\r\n{\r\nacpi_status status = AE_OK;\r\nacpi_handle handle = NULL;\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE, "set lcd level via SBL2 [%d]\n",\r\nlevel);\r\nif (level < 0 || level >= fujitsu->max_brightness)\r\nreturn -EINVAL;\r\nstatus = acpi_get_handle(fujitsu->acpi_handle, "SBL2", &handle);\r\nif (ACPI_FAILURE(status)) {\r\nvdbg_printk(FUJLAPTOP_DBG_ERROR, "SBL2 not present\n");\r\nreturn -ENODEV;\r\n}\r\nstatus = acpi_execute_simple_method(handle, NULL, level);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int get_lcd_level(void)\r\n{\r\nunsigned long long state = 0;\r\nacpi_status status = AE_OK;\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE, "get lcd level via GBLL\n");\r\nstatus =\r\nacpi_evaluate_integer(fujitsu->acpi_handle, "GBLL", NULL, &state);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nfujitsu->brightness_level = state & 0x0fffffff;\r\nif (state & 0x80000000)\r\nfujitsu->brightness_changed = 1;\r\nelse\r\nfujitsu->brightness_changed = 0;\r\nreturn fujitsu->brightness_level;\r\n}\r\nstatic int get_max_brightness(void)\r\n{\r\nunsigned long long state = 0;\r\nacpi_status status = AE_OK;\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE, "get max lcd level via RBLL\n");\r\nstatus =\r\nacpi_evaluate_integer(fujitsu->acpi_handle, "RBLL", NULL, &state);\r\nif (ACPI_FAILURE(status))\r\nreturn -1;\r\nfujitsu->max_brightness = state;\r\nreturn fujitsu->max_brightness;\r\n}\r\nstatic int bl_get_brightness(struct backlight_device *b)\r\n{\r\nreturn get_lcd_level();\r\n}\r\nstatic int bl_update_status(struct backlight_device *b)\r\n{\r\nint ret;\r\nif (b->props.power == FB_BLANK_POWERDOWN)\r\nret = call_fext_func(FUNC_BACKLIGHT, 0x1, 0x4, 0x3);\r\nelse\r\nret = call_fext_func(FUNC_BACKLIGHT, 0x1, 0x4, 0x0);\r\nif (ret != 0)\r\nvdbg_printk(FUJLAPTOP_DBG_ERROR,\r\n"Unable to adjust backlight power, error code %i\n",\r\nret);\r\nif (use_alt_lcd_levels)\r\nret = set_lcd_level_alt(b->props.brightness);\r\nelse\r\nret = set_lcd_level(b->props.brightness);\r\nif (ret != 0)\r\nvdbg_printk(FUJLAPTOP_DBG_ERROR,\r\n"Unable to adjust LCD brightness, error code %i\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nshow_max_brightness(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nret = get_max_brightness();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t\r\nshow_brightness_changed(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nret = fujitsu->brightness_changed;\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t show_lcd_level(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nret = get_lcd_level();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t store_lcd_level(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nint level, ret;\r\nif (sscanf(buf, "%i", &level) != 1\r\n|| (level < 0 || level >= fujitsu->max_brightness))\r\nreturn -EINVAL;\r\nif (use_alt_lcd_levels)\r\nret = set_lcd_level_alt(level);\r\nelse\r\nret = set_lcd_level(level);\r\nif (ret < 0)\r\nreturn ret;\r\nret = get_lcd_level();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nignore_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_lid_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nif (!(fujitsu_hotkey->rfkill_supported & 0x100))\r\nreturn sprintf(buf, "unknown\n");\r\nif (fujitsu_hotkey->rfkill_state & 0x100)\r\nreturn sprintf(buf, "open\n");\r\nelse\r\nreturn sprintf(buf, "closed\n");\r\n}\r\nstatic ssize_t\r\nshow_dock_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nif (!(fujitsu_hotkey->rfkill_supported & 0x200))\r\nreturn sprintf(buf, "unknown\n");\r\nif (fujitsu_hotkey->rfkill_state & 0x200)\r\nreturn sprintf(buf, "docked\n");\r\nelse\r\nreturn sprintf(buf, "undocked\n");\r\n}\r\nstatic ssize_t\r\nshow_radios_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nif (!(fujitsu_hotkey->rfkill_supported & 0x20))\r\nreturn sprintf(buf, "unknown\n");\r\nif (fujitsu_hotkey->rfkill_state & 0x20)\r\nreturn sprintf(buf, "on\n");\r\nelse\r\nreturn sprintf(buf, "killed\n");\r\n}\r\nstatic void __init dmi_check_cb_common(const struct dmi_system_id *id)\r\n{\r\npr_info("Identified laptop model '%s'\n", id->ident);\r\nif (use_alt_lcd_levels == -1) {\r\nif (acpi_has_method(NULL,\r\n"\\_SB.PCI0.LPCB.FJEX.SBL2"))\r\nuse_alt_lcd_levels = 1;\r\nelse\r\nuse_alt_lcd_levels = 0;\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE, "auto-detected usealt as "\r\n"%i\n", use_alt_lcd_levels);\r\n}\r\n}\r\nstatic int __init dmi_check_cb_s6410(const struct dmi_system_id *id)\r\n{\r\ndmi_check_cb_common(id);\r\nfujitsu->keycode1 = KEY_SCREENLOCK;\r\nfujitsu->keycode2 = KEY_HELP;\r\nreturn 1;\r\n}\r\nstatic int __init dmi_check_cb_s6420(const struct dmi_system_id *id)\r\n{\r\ndmi_check_cb_common(id);\r\nfujitsu->keycode1 = KEY_SCREENLOCK;\r\nfujitsu->keycode2 = KEY_HELP;\r\nreturn 1;\r\n}\r\nstatic int __init dmi_check_cb_p8010(const struct dmi_system_id *id)\r\n{\r\ndmi_check_cb_common(id);\r\nfujitsu->keycode1 = KEY_HELP;\r\nfujitsu->keycode3 = KEY_SWITCHVIDEOMODE;\r\nfujitsu->keycode4 = KEY_WWW;\r\nreturn 1;\r\n}\r\nstatic int acpi_fujitsu_add(struct acpi_device *device)\r\n{\r\nint state = 0;\r\nstruct input_dev *input;\r\nint error;\r\nif (!device)\r\nreturn -EINVAL;\r\nfujitsu->acpi_handle = device->handle;\r\nsprintf(acpi_device_name(device), "%s", ACPI_FUJITSU_DEVICE_NAME);\r\nsprintf(acpi_device_class(device), "%s", ACPI_FUJITSU_CLASS);\r\ndevice->driver_data = fujitsu;\r\nfujitsu->input = input = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto err_stop;\r\n}\r\nsnprintf(fujitsu->phys, sizeof(fujitsu->phys),\r\n"%s/video/input0", acpi_device_hid(device));\r\ninput->name = acpi_device_name(device);\r\ninput->phys = fujitsu->phys;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.product = 0x06;\r\ninput->dev.parent = &device->dev;\r\ninput->evbit[0] = BIT(EV_KEY);\r\nset_bit(KEY_BRIGHTNESSUP, input->keybit);\r\nset_bit(KEY_BRIGHTNESSDOWN, input->keybit);\r\nset_bit(KEY_UNKNOWN, input->keybit);\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_free_input_dev;\r\nerror = acpi_bus_update_power(fujitsu->acpi_handle, &state);\r\nif (error) {\r\npr_err("Error reading power state\n");\r\ngoto err_unregister_input_dev;\r\n}\r\npr_info("ACPI: %s [%s] (%s)\n",\r\nacpi_device_name(device), acpi_device_bid(device),\r\n!device->power.state ? "on" : "off");\r\nfujitsu->dev = device;\r\nif (acpi_has_method(device->handle, METHOD_NAME__INI)) {\r\nvdbg_printk(FUJLAPTOP_DBG_INFO, "Invoking _INI\n");\r\nif (ACPI_FAILURE\r\n(acpi_evaluate_object\r\n(device->handle, METHOD_NAME__INI, NULL, NULL)))\r\npr_err("_INI Method failed\n");\r\n}\r\nuse_alt_lcd_levels = use_alt_lcd_levels == 1 ? 1 : 0;\r\ndisable_brightness_adjust = disable_brightness_adjust == 1 ? 1 : 0;\r\nvdbg_printk(FUJLAPTOP_DBG_INFO,\r\n"config: [alt interface: %d], [adjust disable: %d]\n",\r\nuse_alt_lcd_levels, disable_brightness_adjust);\r\nif (get_max_brightness() <= 0)\r\nfujitsu->max_brightness = FUJITSU_LCD_N_LEVELS;\r\nget_lcd_level();\r\nreturn 0;\r\nerr_unregister_input_dev:\r\ninput_unregister_device(input);\r\ninput = NULL;\r\nerr_free_input_dev:\r\ninput_free_device(input);\r\nerr_stop:\r\nreturn error;\r\n}\r\nstatic int acpi_fujitsu_remove(struct acpi_device *device)\r\n{\r\nstruct fujitsu_t *fujitsu = acpi_driver_data(device);\r\nstruct input_dev *input = fujitsu->input;\r\ninput_unregister_device(input);\r\nfujitsu->acpi_handle = NULL;\r\nreturn 0;\r\n}\r\nstatic void acpi_fujitsu_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct input_dev *input;\r\nint keycode;\r\nint oldb, newb;\r\ninput = fujitsu->input;\r\nswitch (event) {\r\ncase ACPI_FUJITSU_NOTIFY_CODE1:\r\nkeycode = 0;\r\noldb = fujitsu->brightness_level;\r\nget_lcd_level();\r\nnewb = fujitsu->brightness_level;\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE,\r\n"brightness button event [%i -> %i (%i)]\n",\r\noldb, newb, fujitsu->brightness_changed);\r\nif (oldb < newb) {\r\nif (disable_brightness_adjust != 1) {\r\nif (use_alt_lcd_levels)\r\nset_lcd_level_alt(newb);\r\nelse\r\nset_lcd_level(newb);\r\n}\r\nkeycode = KEY_BRIGHTNESSUP;\r\n} else if (oldb > newb) {\r\nif (disable_brightness_adjust != 1) {\r\nif (use_alt_lcd_levels)\r\nset_lcd_level_alt(newb);\r\nelse\r\nset_lcd_level(newb);\r\n}\r\nkeycode = KEY_BRIGHTNESSDOWN;\r\n}\r\nbreak;\r\ndefault:\r\nkeycode = KEY_UNKNOWN;\r\nvdbg_printk(FUJLAPTOP_DBG_WARN,\r\n"unsupported event [0x%x]\n", event);\r\nbreak;\r\n}\r\nif (keycode != 0) {\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\n}\r\n}\r\nstatic int acpi_fujitsu_hotkey_add(struct acpi_device *device)\r\n{\r\nint result = 0;\r\nint state = 0;\r\nstruct input_dev *input;\r\nint error;\r\nint i;\r\nif (!device)\r\nreturn -EINVAL;\r\nfujitsu_hotkey->acpi_handle = device->handle;\r\nsprintf(acpi_device_name(device), "%s",\r\nACPI_FUJITSU_HOTKEY_DEVICE_NAME);\r\nsprintf(acpi_device_class(device), "%s", ACPI_FUJITSU_CLASS);\r\ndevice->driver_data = fujitsu_hotkey;\r\nspin_lock_init(&fujitsu_hotkey->fifo_lock);\r\nerror = kfifo_alloc(&fujitsu_hotkey->fifo, RINGBUFFERSIZE * sizeof(int),\r\nGFP_KERNEL);\r\nif (error) {\r\npr_err("kfifo_alloc failed\n");\r\ngoto err_stop;\r\n}\r\nfujitsu_hotkey->input = input = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto err_free_fifo;\r\n}\r\nsnprintf(fujitsu_hotkey->phys, sizeof(fujitsu_hotkey->phys),\r\n"%s/video/input0", acpi_device_hid(device));\r\ninput->name = acpi_device_name(device);\r\ninput->phys = fujitsu_hotkey->phys;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.product = 0x06;\r\ninput->dev.parent = &device->dev;\r\nset_bit(EV_KEY, input->evbit);\r\nset_bit(fujitsu->keycode1, input->keybit);\r\nset_bit(fujitsu->keycode2, input->keybit);\r\nset_bit(fujitsu->keycode3, input->keybit);\r\nset_bit(fujitsu->keycode4, input->keybit);\r\nset_bit(fujitsu->keycode5, input->keybit);\r\nset_bit(KEY_TOUCHPAD_TOGGLE, input->keybit);\r\nset_bit(KEY_UNKNOWN, input->keybit);\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_free_input_dev;\r\nerror = acpi_bus_update_power(fujitsu_hotkey->acpi_handle, &state);\r\nif (error) {\r\npr_err("Error reading power state\n");\r\ngoto err_unregister_input_dev;\r\n}\r\npr_info("ACPI: %s [%s] (%s)\n",\r\nacpi_device_name(device), acpi_device_bid(device),\r\n!device->power.state ? "on" : "off");\r\nfujitsu_hotkey->dev = device;\r\nif (acpi_has_method(device->handle, METHOD_NAME__INI)) {\r\nvdbg_printk(FUJLAPTOP_DBG_INFO, "Invoking _INI\n");\r\nif (ACPI_FAILURE\r\n(acpi_evaluate_object\r\n(device->handle, METHOD_NAME__INI, NULL, NULL)))\r\npr_err("_INI Method failed\n");\r\n}\r\ni = 0;\r\nwhile (call_fext_func(FUNC_BUTTONS, 0x1, 0x0, 0x0) != 0\r\n&& (i++) < MAX_HOTKEY_RINGBUFFER_SIZE)\r\n;\r\nvdbg_printk(FUJLAPTOP_DBG_INFO, "Discarded %i ringbuffer entries\n", i);\r\nfujitsu_hotkey->rfkill_supported =\r\ncall_fext_func(FUNC_RFKILL, 0x0, 0x0, 0x0);\r\nif (fujitsu_hotkey->rfkill_supported == UNSUPPORTED_CMD)\r\nfujitsu_hotkey->rfkill_supported = 0;\r\nif (fujitsu_hotkey->rfkill_supported)\r\nfujitsu_hotkey->rfkill_state =\r\ncall_fext_func(FUNC_RFKILL, 0x4, 0x0, 0x0);\r\npr_info("BTNI: [0x%x]\n", call_fext_func(FUNC_BUTTONS, 0x0, 0x0, 0x0));\r\n#if IS_ENABLED(CONFIG_LEDS_CLASS)\r\nif (call_fext_func(FUNC_LEDS, 0x0, 0x0, 0x0) & LOGOLAMP_POWERON) {\r\nresult = led_classdev_register(&fujitsu->pf_device->dev,\r\n&logolamp_led);\r\nif (result == 0) {\r\nfujitsu_hotkey->logolamp_registered = 1;\r\n} else {\r\npr_err("Could not register LED handler for logo lamp, error %i\n",\r\nresult);\r\n}\r\n}\r\nif ((call_fext_func(FUNC_LEDS, 0x0, 0x0, 0x0) & KEYBOARD_LAMPS) &&\r\n(call_fext_func(FUNC_BUTTONS, 0x0, 0x0, 0x0) == 0x0)) {\r\nresult = led_classdev_register(&fujitsu->pf_device->dev,\r\n&kblamps_led);\r\nif (result == 0) {\r\nfujitsu_hotkey->kblamps_registered = 1;\r\n} else {\r\npr_err("Could not register LED handler for keyboard lamps, error %i\n",\r\nresult);\r\n}\r\n}\r\nif (call_fext_func(FUNC_BUTTONS, 0x0, 0x0, 0x0) & BIT(24)) {\r\nresult = led_classdev_register(&fujitsu->pf_device->dev,\r\n&radio_led);\r\nif (result == 0) {\r\nfujitsu_hotkey->radio_led_registered = 1;\r\n} else {\r\npr_err("Could not register LED handler for radio LED, error %i\n",\r\nresult);\r\n}\r\n}\r\nif ((call_fext_func(FUNC_LEDS, 0x0, 0x0, 0x0) & BIT(14)) &&\r\n(call_fext_func(FUNC_LEDS, 0x2, ECO_LED, 0x0) != UNSUPPORTED_CMD)) {\r\nresult = led_classdev_register(&fujitsu->pf_device->dev,\r\n&eco_led);\r\nif (result == 0) {\r\nfujitsu_hotkey->eco_led_registered = 1;\r\n} else {\r\npr_err("Could not register LED handler for eco LED, error %i\n",\r\nresult);\r\n}\r\n}\r\n#endif\r\nreturn result;\r\nerr_unregister_input_dev:\r\ninput_unregister_device(input);\r\ninput = NULL;\r\nerr_free_input_dev:\r\ninput_free_device(input);\r\nerr_free_fifo:\r\nkfifo_free(&fujitsu_hotkey->fifo);\r\nerr_stop:\r\nreturn error;\r\n}\r\nstatic int acpi_fujitsu_hotkey_remove(struct acpi_device *device)\r\n{\r\nstruct fujitsu_hotkey_t *fujitsu_hotkey = acpi_driver_data(device);\r\nstruct input_dev *input = fujitsu_hotkey->input;\r\n#if IS_ENABLED(CONFIG_LEDS_CLASS)\r\nif (fujitsu_hotkey->logolamp_registered)\r\nled_classdev_unregister(&logolamp_led);\r\nif (fujitsu_hotkey->kblamps_registered)\r\nled_classdev_unregister(&kblamps_led);\r\nif (fujitsu_hotkey->radio_led_registered)\r\nled_classdev_unregister(&radio_led);\r\nif (fujitsu_hotkey->eco_led_registered)\r\nled_classdev_unregister(&eco_led);\r\n#endif\r\ninput_unregister_device(input);\r\nkfifo_free(&fujitsu_hotkey->fifo);\r\nfujitsu_hotkey->acpi_handle = NULL;\r\nreturn 0;\r\n}\r\nstatic void acpi_fujitsu_hotkey_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct input_dev *input;\r\nint keycode, keycode_r;\r\nunsigned int irb = 1;\r\nint i, status;\r\ninput = fujitsu_hotkey->input;\r\nif (fujitsu_hotkey->rfkill_supported)\r\nfujitsu_hotkey->rfkill_state =\r\ncall_fext_func(FUNC_RFKILL, 0x4, 0x0, 0x0);\r\nswitch (event) {\r\ncase ACPI_FUJITSU_NOTIFY_CODE1:\r\ni = 0;\r\nwhile ((irb =\r\ncall_fext_func(FUNC_BUTTONS, 0x1, 0x0, 0x0)) != 0\r\n&& (i++) < MAX_HOTKEY_RINGBUFFER_SIZE) {\r\nswitch (irb & 0x4ff) {\r\ncase KEY1_CODE:\r\nkeycode = fujitsu->keycode1;\r\nbreak;\r\ncase KEY2_CODE:\r\nkeycode = fujitsu->keycode2;\r\nbreak;\r\ncase KEY3_CODE:\r\nkeycode = fujitsu->keycode3;\r\nbreak;\r\ncase KEY4_CODE:\r\nkeycode = fujitsu->keycode4;\r\nbreak;\r\ncase KEY5_CODE:\r\nkeycode = fujitsu->keycode5;\r\nbreak;\r\ncase 0:\r\nkeycode = 0;\r\nbreak;\r\ndefault:\r\nvdbg_printk(FUJLAPTOP_DBG_WARN,\r\n"Unknown GIRB result [%x]\n", irb);\r\nkeycode = -1;\r\nbreak;\r\n}\r\nif (keycode > 0) {\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE,\r\n"Push keycode into ringbuffer [%d]\n",\r\nkeycode);\r\nstatus = kfifo_in_locked(&fujitsu_hotkey->fifo,\r\n(unsigned char *)&keycode,\r\nsizeof(keycode),\r\n&fujitsu_hotkey->fifo_lock);\r\nif (status != sizeof(keycode)) {\r\nvdbg_printk(FUJLAPTOP_DBG_WARN,\r\n"Could not push keycode [0x%x]\n",\r\nkeycode);\r\n} else {\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\n}\r\n} else if (keycode == 0) {\r\nwhile ((status =\r\nkfifo_out_locked(\r\n&fujitsu_hotkey->fifo,\r\n(unsigned char *) &keycode_r,\r\nsizeof(keycode_r),\r\n&fujitsu_hotkey->fifo_lock))\r\n== sizeof(keycode_r)) {\r\ninput_report_key(input, keycode_r, 0);\r\ninput_sync(input);\r\nvdbg_printk(FUJLAPTOP_DBG_TRACE,\r\n"Pop keycode from ringbuffer [%d]\n",\r\nkeycode_r);\r\n}\r\n}\r\n}\r\nif ((fujitsu_hotkey->rfkill_supported & BIT(26)) &&\r\n(call_fext_func(FUNC_RFKILL, 0x1, 0x0, 0x0) & BIT(26))) {\r\nkeycode = KEY_TOUCHPAD_TOGGLE;\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\n}\r\nbreak;\r\ndefault:\r\nkeycode = KEY_UNKNOWN;\r\nvdbg_printk(FUJLAPTOP_DBG_WARN,\r\n"Unsupported event [0x%x]\n", event);\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\nbreak;\r\n}\r\n}\r\nstatic int __init fujitsu_init(void)\r\n{\r\nint ret, result, max_brightness;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nfujitsu = kzalloc(sizeof(struct fujitsu_t), GFP_KERNEL);\r\nif (!fujitsu)\r\nreturn -ENOMEM;\r\nfujitsu->keycode1 = KEY_PROG1;\r\nfujitsu->keycode2 = KEY_PROG2;\r\nfujitsu->keycode3 = KEY_PROG3;\r\nfujitsu->keycode4 = KEY_PROG4;\r\nfujitsu->keycode5 = KEY_RFKILL;\r\ndmi_check_system(fujitsu_dmi_table);\r\nresult = acpi_bus_register_driver(&acpi_fujitsu_driver);\r\nif (result < 0) {\r\nret = -ENODEV;\r\ngoto fail_acpi;\r\n}\r\nfujitsu->pf_device = platform_device_alloc("fujitsu-laptop", -1);\r\nif (!fujitsu->pf_device) {\r\nret = -ENOMEM;\r\ngoto fail_platform_driver;\r\n}\r\nret = platform_device_add(fujitsu->pf_device);\r\nif (ret)\r\ngoto fail_platform_device1;\r\nret =\r\nsysfs_create_group(&fujitsu->pf_device->dev.kobj,\r\n&fujitsupf_attribute_group);\r\nif (ret)\r\ngoto fail_platform_device2;\r\nif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nmax_brightness = fujitsu->max_brightness;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = max_brightness - 1;\r\nfujitsu->bl_device = backlight_device_register("fujitsu-laptop",\r\nNULL, NULL,\r\n&fujitsubl_ops,\r\n&props);\r\nif (IS_ERR(fujitsu->bl_device)) {\r\nret = PTR_ERR(fujitsu->bl_device);\r\nfujitsu->bl_device = NULL;\r\ngoto fail_sysfs_group;\r\n}\r\nfujitsu->bl_device->props.brightness = fujitsu->brightness_level;\r\n}\r\nret = platform_driver_register(&fujitsupf_driver);\r\nif (ret)\r\ngoto fail_backlight;\r\nfujitsu_hotkey = kzalloc(sizeof(struct fujitsu_hotkey_t), GFP_KERNEL);\r\nif (!fujitsu_hotkey) {\r\nret = -ENOMEM;\r\ngoto fail_hotkey;\r\n}\r\nresult = acpi_bus_register_driver(&acpi_fujitsu_hotkey_driver);\r\nif (result < 0) {\r\nret = -ENODEV;\r\ngoto fail_hotkey1;\r\n}\r\nif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\r\nif (call_fext_func(FUNC_BACKLIGHT, 0x2, 0x4, 0x0) == 3)\r\nfujitsu->bl_device->props.power = FB_BLANK_POWERDOWN;\r\nelse\r\nfujitsu->bl_device->props.power = FB_BLANK_UNBLANK;\r\n}\r\npr_info("driver " FUJITSU_DRIVER_VERSION " successfully loaded\n");\r\nreturn 0;\r\nfail_hotkey1:\r\nkfree(fujitsu_hotkey);\r\nfail_hotkey:\r\nplatform_driver_unregister(&fujitsupf_driver);\r\nfail_backlight:\r\nbacklight_device_unregister(fujitsu->bl_device);\r\nfail_sysfs_group:\r\nsysfs_remove_group(&fujitsu->pf_device->dev.kobj,\r\n&fujitsupf_attribute_group);\r\nfail_platform_device2:\r\nplatform_device_del(fujitsu->pf_device);\r\nfail_platform_device1:\r\nplatform_device_put(fujitsu->pf_device);\r\nfail_platform_driver:\r\nacpi_bus_unregister_driver(&acpi_fujitsu_driver);\r\nfail_acpi:\r\nkfree(fujitsu);\r\nreturn ret;\r\n}\r\nstatic void __exit fujitsu_cleanup(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_fujitsu_hotkey_driver);\r\nkfree(fujitsu_hotkey);\r\nplatform_driver_unregister(&fujitsupf_driver);\r\nbacklight_device_unregister(fujitsu->bl_device);\r\nsysfs_remove_group(&fujitsu->pf_device->dev.kobj,\r\n&fujitsupf_attribute_group);\r\nplatform_device_unregister(fujitsu->pf_device);\r\nacpi_bus_unregister_driver(&acpi_fujitsu_driver);\r\nkfree(fujitsu);\r\npr_info("driver unloaded\n");\r\n}
