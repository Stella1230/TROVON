int solo_p2m_dma(struct solo_dev *solo_dev, int wr,\r\nvoid *sys_addr, u32 ext_addr, u32 size,\r\nint repeat, u32 ext_size)\r\n{\r\ndma_addr_t dma_addr;\r\nint ret;\r\nif (WARN_ON_ONCE((unsigned long)sys_addr & 0x03))\r\nreturn -EINVAL;\r\nif (WARN_ON_ONCE(!size))\r\nreturn -EINVAL;\r\ndma_addr = pci_map_single(solo_dev->pdev, sys_addr, size,\r\nwr ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(solo_dev->pdev, dma_addr))\r\nreturn -ENOMEM;\r\nret = solo_p2m_dma_t(solo_dev, wr, dma_addr, ext_addr, size,\r\nrepeat, ext_size);\r\npci_unmap_single(solo_dev->pdev, dma_addr, size,\r\nwr ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);\r\nreturn ret;\r\n}\r\nint solo_p2m_dma_desc(struct solo_dev *solo_dev,\r\nstruct solo_p2m_desc *desc, dma_addr_t desc_dma,\r\nint desc_cnt)\r\n{\r\nstruct solo_p2m_dev *p2m_dev;\r\nunsigned int timeout;\r\nunsigned int config = 0;\r\nint ret = 0;\r\nint p2m_id = 0;\r\nif (solo_dev->type != SOLO_DEV_6110 && multi_p2m) {\r\np2m_id = atomic_inc_return(&solo_dev->p2m_count) % SOLO_NR_P2M;\r\nif (p2m_id < 0)\r\np2m_id = -p2m_id;\r\n}\r\np2m_dev = &solo_dev->p2m_dev[p2m_id];\r\nif (mutex_lock_interruptible(&p2m_dev->mutex))\r\nreturn -EINTR;\r\nreinit_completion(&p2m_dev->completion);\r\np2m_dev->error = 0;\r\nif (desc_cnt > 1 && solo_dev->type != SOLO_DEV_6110 && desc_mode) {\r\np2m_dev->desc_count = p2m_dev->desc_idx = 0;\r\nconfig = solo_reg_read(solo_dev, SOLO_P2M_CONFIG(p2m_id));\r\nsolo_reg_write(solo_dev, SOLO_P2M_DES_ADR(p2m_id), desc_dma);\r\nsolo_reg_write(solo_dev, SOLO_P2M_DESC_ID(p2m_id), desc_cnt);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(p2m_id), config |\r\nSOLO_P2M_DESC_MODE);\r\n} else {\r\np2m_dev->desc_count = desc_cnt;\r\np2m_dev->desc_idx = 1;\r\np2m_dev->descs = desc;\r\nsolo_reg_write(solo_dev, SOLO_P2M_TAR_ADR(p2m_id),\r\ndesc[1].dma_addr);\r\nsolo_reg_write(solo_dev, SOLO_P2M_EXT_ADR(p2m_id),\r\ndesc[1].ext_addr);\r\nsolo_reg_write(solo_dev, SOLO_P2M_EXT_CFG(p2m_id),\r\ndesc[1].cfg);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(p2m_id),\r\ndesc[1].ctrl);\r\n}\r\ntimeout = wait_for_completion_timeout(&p2m_dev->completion,\r\nsolo_dev->p2m_jiffies);\r\nif (WARN_ON_ONCE(p2m_dev->error))\r\nret = -EIO;\r\nelse if (timeout == 0) {\r\nsolo_dev->p2m_timeouts++;\r\nret = -EAGAIN;\r\n}\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(p2m_id), 0);\r\nif (desc_cnt > 1 && solo_dev->type != SOLO_DEV_6110 && config)\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(p2m_id), config);\r\nmutex_unlock(&p2m_dev->mutex);\r\nreturn ret;\r\n}\r\nvoid solo_p2m_fill_desc(struct solo_p2m_desc *desc, int wr,\r\ndma_addr_t dma_addr, u32 ext_addr, u32 size,\r\nint repeat, u32 ext_size)\r\n{\r\nWARN_ON_ONCE(dma_addr & 0x03);\r\nWARN_ON_ONCE(!size);\r\ndesc->cfg = SOLO_P2M_COPY_SIZE(size >> 2);\r\ndesc->ctrl = SOLO_P2M_BURST_SIZE(SOLO_P2M_BURST_256) |\r\n(wr ? SOLO_P2M_WRITE : 0) | SOLO_P2M_TRANS_ON;\r\nif (repeat) {\r\ndesc->cfg |= SOLO_P2M_EXT_INC(ext_size >> 2);\r\ndesc->ctrl |= SOLO_P2M_PCI_INC(size >> 2) |\r\nSOLO_P2M_REPEAT(repeat);\r\n}\r\ndesc->dma_addr = dma_addr;\r\ndesc->ext_addr = ext_addr;\r\n}\r\nint solo_p2m_dma_t(struct solo_dev *solo_dev, int wr,\r\ndma_addr_t dma_addr, u32 ext_addr, u32 size,\r\nint repeat, u32 ext_size)\r\n{\r\nstruct solo_p2m_desc desc[2];\r\nsolo_p2m_fill_desc(&desc[1], wr, dma_addr, ext_addr, size, repeat,\r\next_size);\r\nreturn solo_p2m_dma_desc(solo_dev, desc, 0, 1);\r\n}\r\nvoid solo_p2m_isr(struct solo_dev *solo_dev, int id)\r\n{\r\nstruct solo_p2m_dev *p2m_dev = &solo_dev->p2m_dev[id];\r\nstruct solo_p2m_desc *desc;\r\nif (p2m_dev->desc_count <= p2m_dev->desc_idx) {\r\ncomplete(&p2m_dev->completion);\r\nreturn;\r\n}\r\np2m_dev->desc_idx++;\r\ndesc = &p2m_dev->descs[p2m_dev->desc_idx];\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(id), 0);\r\nsolo_reg_write(solo_dev, SOLO_P2M_TAR_ADR(id), desc->dma_addr);\r\nsolo_reg_write(solo_dev, SOLO_P2M_EXT_ADR(id), desc->ext_addr);\r\nsolo_reg_write(solo_dev, SOLO_P2M_EXT_CFG(id), desc->cfg);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(id), desc->ctrl);\r\n}\r\nvoid solo_p2m_error_isr(struct solo_dev *solo_dev)\r\n{\r\nunsigned int err = solo_reg_read(solo_dev, SOLO_PCI_ERR);\r\nstruct solo_p2m_dev *p2m_dev;\r\nint i;\r\nif (!(err & (SOLO_PCI_ERR_P2M | SOLO_PCI_ERR_P2M_DESC)))\r\nreturn;\r\nfor (i = 0; i < SOLO_NR_P2M; i++) {\r\np2m_dev = &solo_dev->p2m_dev[i];\r\np2m_dev->error = 1;\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(i), 0);\r\ncomplete(&p2m_dev->completion);\r\n}\r\n}\r\nvoid solo_p2m_exit(struct solo_dev *solo_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < SOLO_NR_P2M; i++)\r\nsolo_irq_off(solo_dev, SOLO_IRQ_P2M(i));\r\n}\r\nstatic int solo_p2m_test(struct solo_dev *solo_dev, int base, int size)\r\n{\r\nu32 *wr_buf;\r\nu32 *rd_buf;\r\nint i;\r\nint ret = -EIO;\r\nint order = get_order(size);\r\nwr_buf = (u32 *)__get_free_pages(GFP_KERNEL, order);\r\nif (wr_buf == NULL)\r\nreturn -1;\r\nrd_buf = (u32 *)__get_free_pages(GFP_KERNEL, order);\r\nif (rd_buf == NULL) {\r\nfree_pages((unsigned long)wr_buf, order);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < (size >> 3); i++)\r\n*(wr_buf + i) = (i << 16) | (i + 1);\r\nfor (i = (size >> 3); i < (size >> 2); i++)\r\n*(wr_buf + i) = ~((i << 16) | (i + 1));\r\nmemset(rd_buf, 0x55, size);\r\nif (solo_p2m_dma(solo_dev, 1, wr_buf, base, size, 0, 0))\r\ngoto test_fail;\r\nif (solo_p2m_dma(solo_dev, 0, rd_buf, base, size, 0, 0))\r\ngoto test_fail;\r\nfor (i = 0; i < (size >> 2); i++) {\r\nif (*(wr_buf + i) != *(rd_buf + i))\r\ngoto test_fail;\r\n}\r\nret = 0;\r\ntest_fail:\r\nfree_pages((unsigned long)wr_buf, order);\r\nfree_pages((unsigned long)rd_buf, order);\r\nreturn ret;\r\n}\r\nint solo_p2m_init(struct solo_dev *solo_dev)\r\n{\r\nstruct solo_p2m_dev *p2m_dev;\r\nint i;\r\nfor (i = 0; i < SOLO_NR_P2M; i++) {\r\np2m_dev = &solo_dev->p2m_dev[i];\r\nmutex_init(&p2m_dev->mutex);\r\ninit_completion(&p2m_dev->completion);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(i), 0);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(i),\r\nSOLO_P2M_CSC_16BIT_565 |\r\nSOLO_P2M_DESC_INTR_OPT |\r\nSOLO_P2M_DMA_INTERVAL(0) |\r\nSOLO_P2M_PCI_MASTER_MODE);\r\nsolo_irq_on(solo_dev, SOLO_IRQ_P2M(i));\r\n}\r\nfor (solo_dev->sdram_size = 0, i = 2; i >= 0; i--) {\r\nsolo_reg_write(solo_dev, SOLO_DMA_CTRL,\r\nSOLO_DMA_CTRL_REFRESH_CYCLE(1) |\r\nSOLO_DMA_CTRL_SDRAM_SIZE(i) |\r\nSOLO_DMA_CTRL_SDRAM_CLK_INVERT |\r\nSOLO_DMA_CTRL_READ_CLK_SELECT |\r\nSOLO_DMA_CTRL_LATENCY(1));\r\nsolo_reg_write(solo_dev, SOLO_SYS_CFG, solo_dev->sys_config |\r\nSOLO_SYS_CFG_RESET);\r\nsolo_reg_write(solo_dev, SOLO_SYS_CFG, solo_dev->sys_config);\r\nswitch (i) {\r\ncase 2:\r\nif (solo_p2m_test(solo_dev, 0x07ff0000, 0x00010000) ||\r\nsolo_p2m_test(solo_dev, 0x05ff0000, 0x00010000))\r\ncontinue;\r\nbreak;\r\ncase 1:\r\nif (solo_p2m_test(solo_dev, 0x03ff0000, 0x00010000))\r\ncontinue;\r\nbreak;\r\ndefault:\r\nif (solo_p2m_test(solo_dev, 0x01ff0000, 0x00010000))\r\ncontinue;\r\n}\r\nsolo_dev->sdram_size = (32 << 20) << i;\r\nbreak;\r\n}\r\nif (!solo_dev->sdram_size) {\r\ndev_err(&solo_dev->pdev->dev, "Error detecting SDRAM size\n");\r\nreturn -EIO;\r\n}\r\nif (SOLO_SDRAM_END(solo_dev) > solo_dev->sdram_size) {\r\ndev_err(&solo_dev->pdev->dev,\r\n"SDRAM is not large enough (%u < %u)\n",\r\nsolo_dev->sdram_size, SOLO_SDRAM_END(solo_dev));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}
