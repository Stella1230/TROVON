static bool addr_check(unsigned int check, unsigned int lo, unsigned int hi)\r\n{\r\nreturn check - (lo + 1) < (hi - 1) - lo;\r\n}\r\nvoid dma_fifo_init(struct dma_fifo *fifo)\r\n{\r\nmemset(fifo, 0, sizeof(*fifo));\r\nINIT_LIST_HEAD(&fifo->pending);\r\n}\r\nint dma_fifo_alloc(struct dma_fifo *fifo, int size, unsigned int align,\r\nint tx_limit, int open_limit, gfp_t gfp_mask)\r\n{\r\nint capacity;\r\nif (!is_power_of_2(align) || size < 0)\r\nreturn -EINVAL;\r\nsize = round_up(size, align);\r\ncapacity = size + align * open_limit + align * DMA_FIFO_GUARD;\r\nfifo->data = kmalloc(capacity, gfp_mask);\r\nif (!fifo->data)\r\nreturn -ENOMEM;\r\nfifo->in = 0;\r\nfifo->out = 0;\r\nfifo->done = 0;\r\nfifo->size = size;\r\nfifo->avail = size;\r\nfifo->align = align;\r\nfifo->tx_limit = max_t(int, round_down(tx_limit, align), align);\r\nfifo->open = 0;\r\nfifo->open_limit = open_limit;\r\nfifo->guard = size + align * open_limit;\r\nfifo->capacity = capacity;\r\nfifo->corrupt = 0;\r\nreturn 0;\r\n}\r\nvoid dma_fifo_free(struct dma_fifo *fifo)\r\n{\r\nstruct dma_pending *pending, *next;\r\nif (!fifo->data)\r\nreturn;\r\nlist_for_each_entry_safe(pending, next, &fifo->pending, link)\r\nlist_del_init(&pending->link);\r\nkfree(fifo->data);\r\nfifo->data = NULL;\r\n}\r\nvoid dma_fifo_reset(struct dma_fifo *fifo)\r\n{\r\nstruct dma_pending *pending, *next;\r\nif (!fifo->data)\r\nreturn;\r\nlist_for_each_entry_safe(pending, next, &fifo->pending, link)\r\nlist_del_init(&pending->link);\r\nfifo->in = 0;\r\nfifo->out = 0;\r\nfifo->done = 0;\r\nfifo->avail = fifo->size;\r\nfifo->open = 0;\r\nfifo->corrupt = 0;\r\n}\r\nint dma_fifo_in(struct dma_fifo *fifo, const void *src, int n)\r\n{\r\nint ofs, l;\r\nif (!fifo->data)\r\nreturn -ENOENT;\r\nif (fifo->corrupt)\r\nreturn -ENXIO;\r\nif (n > fifo->avail)\r\nn = fifo->avail;\r\nif (n <= 0)\r\nreturn 0;\r\nofs = fifo->in % fifo->capacity;\r\nl = min(n, fifo->capacity - ofs);\r\nmemcpy(fifo->data + ofs, src, l);\r\nmemcpy(fifo->data, src + l, n - l);\r\nif (FAIL(fifo, addr_check(fifo->done, fifo->in, fifo->in + n) ||\r\nfifo->avail < n,\r\n"fifo corrupt: in:%u out:%u done:%u n:%d avail:%d",\r\nfifo->in, fifo->out, fifo->done, n, fifo->avail))\r\nreturn -ENXIO;\r\nfifo->in += n;\r\nfifo->avail -= n;\r\ndf_trace("in:%u out:%u done:%u n:%d avail:%d", fifo->in, fifo->out,\r\nfifo->done, n, fifo->avail);\r\nreturn n;\r\n}\r\nint dma_fifo_out_pend(struct dma_fifo *fifo, struct dma_pending *pended)\r\n{\r\nunsigned int len, n, ofs, l, limit;\r\nif (!fifo->data)\r\nreturn -ENOENT;\r\nif (fifo->corrupt)\r\nreturn -ENXIO;\r\npended->len = 0;\r\npended->data = NULL;\r\npended->out = fifo->out;\r\nlen = fifo->in - fifo->out;\r\nif (!len)\r\nreturn -ENODATA;\r\nif (fifo->open == fifo->open_limit)\r\nreturn -EAGAIN;\r\nn = len;\r\nofs = fifo->out % fifo->capacity;\r\nl = fifo->capacity - ofs;\r\nlimit = min_t(unsigned int, l, fifo->tx_limit);\r\nif (n > limit) {\r\nn = limit;\r\nfifo->out += limit;\r\n} else if (ofs + n > fifo->guard) {\r\nfifo->out += l;\r\nfifo->in = fifo->out;\r\n} else {\r\nfifo->out += round_up(n, fifo->align);\r\nfifo->in = fifo->out;\r\n}\r\ndf_trace("in: %u out: %u done: %u n: %d len: %u avail: %d", fifo->in,\r\nfifo->out, fifo->done, n, len, fifo->avail);\r\npended->len = n;\r\npended->data = fifo->data + ofs;\r\npended->next = fifo->out;\r\nlist_add_tail(&pended->link, &fifo->pending);\r\n++fifo->open;\r\nif (FAIL(fifo, fifo->open > fifo->open_limit,\r\n"past open limit:%d (limit:%d)",\r\nfifo->open, fifo->open_limit))\r\nreturn -ENXIO;\r\nif (FAIL(fifo, fifo->out & (fifo->align - 1),\r\n"fifo out unaligned:%u (align:%u)",\r\nfifo->out, fifo->align))\r\nreturn -ENXIO;\r\nreturn len - n;\r\n}\r\nint dma_fifo_out_complete(struct dma_fifo *fifo, struct dma_pending *complete)\r\n{\r\nstruct dma_pending *pending, *next, *tmp;\r\nif (!fifo->data)\r\nreturn -ENOENT;\r\nif (fifo->corrupt)\r\nreturn -ENXIO;\r\nif (list_empty(&fifo->pending) && fifo->open == 0)\r\nreturn -EINVAL;\r\nif (FAIL(fifo, list_empty(&fifo->pending) != (fifo->open == 0),\r\n"pending list disagrees with open count:%d",\r\nfifo->open))\r\nreturn -ENXIO;\r\ntmp = complete->data;\r\n*tmp = *complete;\r\nlist_replace(&complete->link, &tmp->link);\r\ndp_mark_completed(tmp);\r\nlist_for_each_entry_safe(pending, next, &fifo->pending, link) {\r\nif (!dp_is_completed(pending)) {\r\ndf_trace("still pending: saved out: %u len: %d",\r\npending->out, pending->len);\r\nbreak;\r\n}\r\nif (FAIL(fifo, pending->out != fifo->done ||\r\naddr_check(fifo->in, fifo->done, pending->next),\r\n"in:%u out:%u done:%u saved:%u next:%u",\r\nfifo->in, fifo->out, fifo->done, pending->out,\r\npending->next))\r\nreturn -ENXIO;\r\nlist_del_init(&pending->link);\r\nfifo->done = pending->next;\r\nfifo->avail += pending->len;\r\n--fifo->open;\r\ndf_trace("in: %u out: %u done: %u len: %u avail: %d", fifo->in,\r\nfifo->out, fifo->done, pending->len, fifo->avail);\r\n}\r\nif (FAIL(fifo, fifo->open < 0, "open dma:%d < 0", fifo->open))\r\nreturn -ENXIO;\r\nif (FAIL(fifo, fifo->avail > fifo->size, "fifo avail:%d > size:%d",\r\nfifo->avail, fifo->size))\r\nreturn -ENXIO;\r\nreturn 0;\r\n}
