void dw_pcm_push_tx(struct dw_i2s_dev *dev)\r\n{\r\nstruct snd_pcm_substream *tx_substream;\r\nbool tx_active, period_elapsed;\r\nrcu_read_lock();\r\ntx_substream = rcu_dereference(dev->tx_substream);\r\ntx_active = tx_substream && snd_pcm_running(tx_substream);\r\nif (tx_active) {\r\nunsigned int tx_ptr = READ_ONCE(dev->tx_ptr);\r\nunsigned int new_tx_ptr = dev->tx_fn(dev, tx_substream->runtime,\r\ntx_ptr, &period_elapsed);\r\ncmpxchg(&dev->tx_ptr, tx_ptr, new_tx_ptr);\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(tx_substream);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int dw_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nsnd_soc_set_runtime_hwparams(substream, &dw_pcm_hardware);\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nruntime->private_data = dev;\r\nreturn 0;\r\n}\r\nstatic int dw_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nstatic int dw_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dw_i2s_dev *dev = runtime->private_data;\r\nint ret;\r\nswitch (params_channels(hw_params)) {\r\ncase 2:\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "invalid channels number\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (params_format(hw_params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndev->tx_fn = dw_pcm_tx_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndev->tx_fn = dw_pcm_tx_32;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "invalid format\n");\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK) {\r\ndev_err(dev->dev, "only playback is available\n");\r\nreturn -EINVAL;\r\n}\r\nret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int dw_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int dw_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dw_i2s_dev *dev = runtime->private_data;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nWRITE_ONCE(dev->tx_ptr, 0);\r\nrcu_assign_pointer(dev->tx_substream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nrcu_assign_pointer(dev->tx_substream, NULL);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t dw_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dw_i2s_dev *dev = runtime->private_data;\r\nsnd_pcm_uframes_t pos = READ_ONCE(dev->tx_ptr);\r\nreturn pos < runtime->buffer_size ? pos : 0;\r\n}\r\nstatic int dw_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nsize_t size = dw_pcm_hardware.buffer_bytes_max;\r\nreturn snd_pcm_lib_preallocate_pages_for_all(rtd->pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL), size, size);\r\n}\r\nstatic void dw_pcm_free(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nint dw_pcm_register(struct platform_device *pdev)\r\n{\r\nreturn devm_snd_soc_register_platform(&pdev->dev, &dw_pcm_platform);\r\n}
