static void octeon_spi_wait_ready(struct octeon_spi *p)\r\n{\r\nunion cvmx_mpi_sts mpi_sts;\r\nunsigned int loops = 0;\r\ndo {\r\nif (loops++)\r\n__delay(500);\r\nmpi_sts.u64 = readq(p->register_base + OCTEON_SPI_STS(p));\r\n} while (mpi_sts.s.busy);\r\n}\r\nstatic int octeon_spi_do_transfer(struct octeon_spi *p,\r\nstruct spi_message *msg,\r\nstruct spi_transfer *xfer,\r\nbool last_xfer)\r\n{\r\nstruct spi_device *spi = msg->spi;\r\nunion cvmx_mpi_cfg mpi_cfg;\r\nunion cvmx_mpi_tx mpi_tx;\r\nunsigned int clkdiv;\r\nint mode;\r\nbool cpha, cpol;\r\nconst u8 *tx_buf;\r\nu8 *rx_buf;\r\nint len;\r\nint i;\r\nmode = spi->mode;\r\ncpha = mode & SPI_CPHA;\r\ncpol = mode & SPI_CPOL;\r\nclkdiv = p->sys_freq / (2 * xfer->speed_hz);\r\nmpi_cfg.u64 = 0;\r\nmpi_cfg.s.clkdiv = clkdiv;\r\nmpi_cfg.s.cshi = (mode & SPI_CS_HIGH) ? 1 : 0;\r\nmpi_cfg.s.lsbfirst = (mode & SPI_LSB_FIRST) ? 1 : 0;\r\nmpi_cfg.s.wireor = (mode & SPI_3WIRE) ? 1 : 0;\r\nmpi_cfg.s.idlelo = cpha != cpol;\r\nmpi_cfg.s.cslate = cpha ? 1 : 0;\r\nmpi_cfg.s.enable = 1;\r\nif (spi->chip_select < 4)\r\np->cs_enax |= 1ull << (12 + spi->chip_select);\r\nmpi_cfg.u64 |= p->cs_enax;\r\nif (mpi_cfg.u64 != p->last_cfg) {\r\np->last_cfg = mpi_cfg.u64;\r\nwriteq(mpi_cfg.u64, p->register_base + OCTEON_SPI_CFG(p));\r\n}\r\ntx_buf = xfer->tx_buf;\r\nrx_buf = xfer->rx_buf;\r\nlen = xfer->len;\r\nwhile (len > OCTEON_SPI_MAX_BYTES) {\r\nfor (i = 0; i < OCTEON_SPI_MAX_BYTES; i++) {\r\nu8 d;\r\nif (tx_buf)\r\nd = *tx_buf++;\r\nelse\r\nd = 0;\r\nwriteq(d, p->register_base + OCTEON_SPI_DAT0(p) + (8 * i));\r\n}\r\nmpi_tx.u64 = 0;\r\nmpi_tx.s.csid = spi->chip_select;\r\nmpi_tx.s.leavecs = 1;\r\nmpi_tx.s.txnum = tx_buf ? OCTEON_SPI_MAX_BYTES : 0;\r\nmpi_tx.s.totnum = OCTEON_SPI_MAX_BYTES;\r\nwriteq(mpi_tx.u64, p->register_base + OCTEON_SPI_TX(p));\r\nocteon_spi_wait_ready(p);\r\nif (rx_buf)\r\nfor (i = 0; i < OCTEON_SPI_MAX_BYTES; i++) {\r\nu64 v = readq(p->register_base + OCTEON_SPI_DAT0(p) + (8 * i));\r\n*rx_buf++ = (u8)v;\r\n}\r\nlen -= OCTEON_SPI_MAX_BYTES;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nu8 d;\r\nif (tx_buf)\r\nd = *tx_buf++;\r\nelse\r\nd = 0;\r\nwriteq(d, p->register_base + OCTEON_SPI_DAT0(p) + (8 * i));\r\n}\r\nmpi_tx.u64 = 0;\r\nmpi_tx.s.csid = spi->chip_select;\r\nif (last_xfer)\r\nmpi_tx.s.leavecs = xfer->cs_change;\r\nelse\r\nmpi_tx.s.leavecs = !xfer->cs_change;\r\nmpi_tx.s.txnum = tx_buf ? len : 0;\r\nmpi_tx.s.totnum = len;\r\nwriteq(mpi_tx.u64, p->register_base + OCTEON_SPI_TX(p));\r\nocteon_spi_wait_ready(p);\r\nif (rx_buf)\r\nfor (i = 0; i < len; i++) {\r\nu64 v = readq(p->register_base + OCTEON_SPI_DAT0(p) + (8 * i));\r\n*rx_buf++ = (u8)v;\r\n}\r\nif (xfer->delay_usecs)\r\nudelay(xfer->delay_usecs);\r\nreturn xfer->len;\r\n}\r\nint octeon_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct octeon_spi *p = spi_master_get_devdata(master);\r\nunsigned int total_len = 0;\r\nint status = 0;\r\nstruct spi_transfer *xfer;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nbool last_xfer = list_is_last(&xfer->transfer_list,\r\n&msg->transfers);\r\nint r = octeon_spi_do_transfer(p, msg, xfer, last_xfer);\r\nif (r < 0) {\r\nstatus = r;\r\ngoto err;\r\n}\r\ntotal_len += r;\r\n}\r\nerr:\r\nmsg->status = status;\r\nmsg->actual_length = total_len;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}
