static inline int\r\ntwlreg_read(struct twlreg_info *info, unsigned slave_subgp, unsigned offset)\r\n{\r\nu8 value;\r\nint status;\r\nstatus = twl_i2c_read_u8(slave_subgp,\r\n&value, info->base + offset);\r\nreturn (status < 0) ? status : value;\r\n}\r\nstatic inline int\r\ntwlreg_write(struct twlreg_info *info, unsigned slave_subgp, unsigned offset,\r\nu8 value)\r\n{\r\nreturn twl_i2c_write_u8(slave_subgp,\r\nvalue, info->base + offset);\r\n}\r\nstatic int twlreg_grp(struct regulator_dev *rdev)\r\n{\r\nreturn twlreg_read(rdev_get_drvdata(rdev), TWL_MODULE_PM_RECEIVER,\r\nVREG_GRP);\r\n}\r\nstatic int twl4030reg_is_enabled(struct regulator_dev *rdev)\r\n{\r\nint state = twlreg_grp(rdev);\r\nif (state < 0)\r\nreturn state;\r\nreturn state & P1_GRP_4030;\r\n}\r\nstatic int twl6030reg_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp = 0, val;\r\nif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS))) {\r\ngrp = twlreg_grp(rdev);\r\nif (grp < 0)\r\nreturn grp;\r\ngrp &= P1_GRP_6030;\r\n} else {\r\ngrp = 1;\r\n}\r\nval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);\r\nval = TWL6030_CFG_STATE_APP(val);\r\nreturn grp && (val == TWL6030_CFG_STATE_ON);\r\n}\r\nstatic int twl4030_wait_pb_ready(void)\r\n{\r\nint ret;\r\nint timeout = 10;\r\nu8 val;\r\ndo {\r\nret = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &val,\r\nTWL4030_PM_MASTER_PB_CFG);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(val & PB_I2C_BUSY))\r\nreturn 0;\r\nmdelay(1);\r\ntimeout--;\r\n} while (timeout);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int twl4030_send_pb_msg(unsigned msg)\r\n{\r\nu8 val;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &val,\r\nTWL4030_PM_MASTER_PB_CFG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, val | PB_I2C_BWEN,\r\nTWL4030_PM_MASTER_PB_CFG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = twl4030_wait_pb_ready();\r\nif (ret < 0)\r\nreturn ret;\r\nret = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, msg >> 8,\r\nTWL4030_PM_MASTER_PB_WORD_MSB);\r\nif (ret < 0)\r\nreturn ret;\r\nret = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, msg & 0xff,\r\nTWL4030_PM_MASTER_PB_WORD_LSB);\r\nif (ret < 0)\r\nreturn ret;\r\nret = twl4030_wait_pb_ready();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn twl_i2c_write_u8(TWL_MODULE_PM_MASTER, val,\r\nTWL4030_PM_MASTER_PB_CFG);\r\n}\r\nstatic int twl4030reg_enable(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp;\r\nint ret;\r\ngrp = twlreg_grp(rdev);\r\nif (grp < 0)\r\nreturn grp;\r\ngrp |= P1_GRP_4030;\r\nret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_GRP, grp);\r\nreturn ret;\r\n}\r\nstatic int twl6030reg_enable(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp = 0;\r\nint ret;\r\nif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\r\ngrp = twlreg_grp(rdev);\r\nif (grp < 0)\r\nreturn grp;\r\nret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE,\r\ngrp << TWL6030_CFG_STATE_GRP_SHIFT |\r\nTWL6030_CFG_STATE_ON);\r\nreturn ret;\r\n}\r\nstatic int twl4030reg_disable(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp;\r\nint ret;\r\ngrp = twlreg_grp(rdev);\r\nif (grp < 0)\r\nreturn grp;\r\ngrp &= ~(P1_GRP_4030 | P2_GRP_4030 | P3_GRP_4030);\r\nret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_GRP, grp);\r\nreturn ret;\r\n}\r\nstatic int twl6030reg_disable(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp = 0;\r\nint ret;\r\nif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\r\ngrp = P1_GRP_6030 | P2_GRP_6030 | P3_GRP_6030;\r\nret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE,\r\n(grp) << TWL6030_CFG_STATE_GRP_SHIFT |\r\nTWL6030_CFG_STATE_OFF);\r\nreturn ret;\r\n}\r\nstatic int twl4030reg_get_status(struct regulator_dev *rdev)\r\n{\r\nint state = twlreg_grp(rdev);\r\nif (state < 0)\r\nreturn state;\r\nstate &= 0x0f;\r\nif (!state)\r\nreturn REGULATOR_STATUS_OFF;\r\nreturn (state & BIT(3))\r\n? REGULATOR_STATUS_NORMAL\r\n: REGULATOR_STATUS_STANDBY;\r\n}\r\nstatic int twl6030reg_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint val;\r\nval = twlreg_grp(rdev);\r\nif (val < 0)\r\nreturn val;\r\nval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);\r\nswitch (TWL6030_CFG_STATE_APP(val)) {\r\ncase TWL6030_CFG_STATE_ON:\r\nreturn REGULATOR_STATUS_NORMAL;\r\ncase TWL6030_CFG_STATE_SLEEP:\r\nreturn REGULATOR_STATUS_STANDBY;\r\ncase TWL6030_CFG_STATE_OFF:\r\ncase TWL6030_CFG_STATE_OFF2:\r\ndefault:\r\nbreak;\r\n}\r\nreturn REGULATOR_STATUS_OFF;\r\n}\r\nstatic int twl4030reg_set_mode(struct regulator_dev *rdev, unsigned mode)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nunsigned message;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nmessage = MSG_SINGULAR(DEV_GRP_P1, info->id, RES_STATE_ACTIVE);\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nmessage = MSG_SINGULAR(DEV_GRP_P1, info->id, RES_STATE_SLEEP);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn twl4030_send_pb_msg(message);\r\n}\r\nstatic inline unsigned int twl4030reg_map_mode(unsigned int mode)\r\n{\r\nswitch (mode) {\r\ncase RES_STATE_ACTIVE:\r\nreturn REGULATOR_MODE_NORMAL;\r\ncase RES_STATE_SLEEP:\r\nreturn REGULATOR_MODE_STANDBY;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int twl6030reg_set_mode(struct regulator_dev *rdev, unsigned mode)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp = 0;\r\nint val;\r\nif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\r\ngrp = twlreg_grp(rdev);\r\nif (grp < 0)\r\nreturn grp;\r\nval = grp << TWL6030_CFG_STATE_GRP_SHIFT;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nval |= TWL6030_CFG_STATE_ON;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval |= TWL6030_CFG_STATE_SLEEP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE, val);\r\n}\r\nstatic int twl4030ldo_list_voltage(struct regulator_dev *rdev, unsigned index)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint mV = info->table[index];\r\nreturn IS_UNSUP(info, mV) ? 0 : (LDO_MV(mV) * 1000);\r\n}\r\nstatic int\r\ntwl4030ldo_set_voltage_sel(struct regulator_dev *rdev, unsigned selector)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nreturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE,\r\nselector);\r\n}\r\nstatic int twl4030ldo_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint vsel = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE);\r\nif (vsel < 0)\r\nreturn vsel;\r\nvsel &= info->table_len - 1;\r\nreturn vsel;\r\n}\r\nstatic int\r\ntwl4030smps_set_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,\r\nunsigned *selector)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint vsel = DIV_ROUND_UP(min_uV - 600000, 12500);\r\nif (info->set_voltage) {\r\nreturn info->set_voltage(info->data, min_uV);\r\n} else {\r\ntwlreg_write(info, TWL_MODULE_PM_RECEIVER,\r\nVREG_VOLTAGE_SMPS_4030, vsel);\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030smps_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint vsel;\r\nif (info->get_voltage)\r\nreturn info->get_voltage(info->data);\r\nvsel = twlreg_read(info, TWL_MODULE_PM_RECEIVER,\r\nVREG_VOLTAGE_SMPS_4030);\r\nreturn vsel * 12500 + 600000;\r\n}\r\nstatic int twl6030coresmps_set_voltage(struct regulator_dev *rdev, int min_uV,\r\nint max_uV, unsigned *selector)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nif (info->set_voltage)\r\nreturn info->set_voltage(info->data, min_uV);\r\nreturn -ENODEV;\r\n}\r\nstatic int twl6030coresmps_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nif (info->get_voltage)\r\nreturn info->get_voltage(info->data);\r\nreturn -ENODEV;\r\n}\r\nstatic int twl6030ldo_list_voltage(struct regulator_dev *rdev, unsigned sel)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nswitch (sel) {\r\ncase 0:\r\nreturn 0;\r\ncase 1 ... 24:\r\nreturn (info->min_mV + 100 * (sel - 1)) * 1000;\r\ncase 25 ... 30:\r\nreturn -EINVAL;\r\ncase 31:\r\nreturn 2750000;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int\r\ntwl6030ldo_set_voltage_sel(struct regulator_dev *rdev, unsigned selector)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nreturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE,\r\nselector);\r\n}\r\nstatic int twl6030ldo_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint vsel = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE);\r\nreturn vsel;\r\n}\r\nstatic int twl6030smps_list_voltage(struct regulator_dev *rdev, unsigned index)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint voltage = 0;\r\nswitch (info->flags) {\r\ncase SMPS_OFFSET_EN:\r\nvoltage = 100000;\r\ncase 0:\r\nswitch (index) {\r\ncase 0:\r\nvoltage = 0;\r\nbreak;\r\ncase 58:\r\nvoltage = 1350 * 1000;\r\nbreak;\r\ncase 59:\r\nvoltage = 1500 * 1000;\r\nbreak;\r\ncase 60:\r\nvoltage = 1800 * 1000;\r\nbreak;\r\ncase 61:\r\nvoltage = 1900 * 1000;\r\nbreak;\r\ncase 62:\r\nvoltage = 2100 * 1000;\r\nbreak;\r\ndefault:\r\nvoltage += (600000 + (12500 * (index - 1)));\r\n}\r\nbreak;\r\ncase SMPS_EXTENDED_EN:\r\nswitch (index) {\r\ncase 0:\r\nvoltage = 0;\r\nbreak;\r\ncase 58:\r\nvoltage = 2084 * 1000;\r\nbreak;\r\ncase 59:\r\nvoltage = 2315 * 1000;\r\nbreak;\r\ncase 60:\r\nvoltage = 2778 * 1000;\r\nbreak;\r\ncase 61:\r\nvoltage = 2932 * 1000;\r\nbreak;\r\ncase 62:\r\nvoltage = 3241 * 1000;\r\nbreak;\r\ndefault:\r\nvoltage = (1852000 + (38600 * (index - 1)));\r\n}\r\nbreak;\r\ncase SMPS_OFFSET_EN | SMPS_EXTENDED_EN:\r\nswitch (index) {\r\ncase 0:\r\nvoltage = 0;\r\nbreak;\r\ncase 58:\r\nvoltage = 4167 * 1000;\r\nbreak;\r\ncase 59:\r\nvoltage = 2315 * 1000;\r\nbreak;\r\ncase 60:\r\nvoltage = 2778 * 1000;\r\nbreak;\r\ncase 61:\r\nvoltage = 2932 * 1000;\r\nbreak;\r\ncase 62:\r\nvoltage = 3241 * 1000;\r\nbreak;\r\ndefault:\r\nvoltage = (2161000 + (38600 * (index - 1)));\r\n}\r\nbreak;\r\n}\r\nreturn voltage;\r\n}\r\nstatic int twl6030smps_map_voltage(struct regulator_dev *rdev, int min_uV,\r\nint max_uV)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint vsel = 0;\r\nswitch (info->flags) {\r\ncase 0:\r\nif (min_uV == 0)\r\nvsel = 0;\r\nelse if ((min_uV >= 600000) && (min_uV <= 1300000)) {\r\nvsel = DIV_ROUND_UP(min_uV - 600000, 12500);\r\nvsel++;\r\n}\r\nelse if ((min_uV > 1900000) && (min_uV <= 2100000))\r\nvsel = 62;\r\nelse if ((min_uV > 1800000) && (min_uV <= 1900000))\r\nvsel = 61;\r\nelse if ((min_uV > 1500000) && (min_uV <= 1800000))\r\nvsel = 60;\r\nelse if ((min_uV > 1350000) && (min_uV <= 1500000))\r\nvsel = 59;\r\nelse if ((min_uV > 1300000) && (min_uV <= 1350000))\r\nvsel = 58;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase SMPS_OFFSET_EN:\r\nif (min_uV == 0)\r\nvsel = 0;\r\nelse if ((min_uV >= 700000) && (min_uV <= 1420000)) {\r\nvsel = DIV_ROUND_UP(min_uV - 700000, 12500);\r\nvsel++;\r\n}\r\nelse if ((min_uV > 1900000) && (min_uV <= 2100000))\r\nvsel = 62;\r\nelse if ((min_uV > 1800000) && (min_uV <= 1900000))\r\nvsel = 61;\r\nelse if ((min_uV > 1350000) && (min_uV <= 1800000))\r\nvsel = 60;\r\nelse if ((min_uV > 1350000) && (min_uV <= 1500000))\r\nvsel = 59;\r\nelse if ((min_uV > 1300000) && (min_uV <= 1350000))\r\nvsel = 58;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase SMPS_EXTENDED_EN:\r\nif (min_uV == 0) {\r\nvsel = 0;\r\n} else if ((min_uV >= 1852000) && (max_uV <= 4013600)) {\r\nvsel = DIV_ROUND_UP(min_uV - 1852000, 38600);\r\nvsel++;\r\n}\r\nbreak;\r\ncase SMPS_OFFSET_EN|SMPS_EXTENDED_EN:\r\nif (min_uV == 0) {\r\nvsel = 0;\r\n} else if ((min_uV >= 2161000) && (min_uV <= 4321000)) {\r\nvsel = DIV_ROUND_UP(min_uV - 2161000, 38600);\r\nvsel++;\r\n}\r\nbreak;\r\n}\r\nreturn vsel;\r\n}\r\nstatic int twl6030smps_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nreturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE_SMPS,\r\nselector);\r\n}\r\nstatic int twl6030smps_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nreturn twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE_SMPS);\r\n}\r\nstatic u8 twl_get_smps_offset(void)\r\n{\r\nu8 value;\r\ntwl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &value,\r\nTWL6030_SMPS_OFFSET);\r\nreturn value;\r\n}\r\nstatic u8 twl_get_smps_mult(void)\r\n{\r\nu8 value;\r\ntwl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &value,\r\nTWL6030_SMPS_MULT);\r\nreturn value;\r\n}\r\nstatic int twlreg_probe(struct platform_device *pdev)\r\n{\r\nint i, id;\r\nstruct twlreg_info *info;\r\nconst struct twlreg_info *template;\r\nstruct regulator_init_data *initdata;\r\nstruct regulation_constraints *c;\r\nstruct regulator_dev *rdev;\r\nstruct twl_regulator_driver_data *drvdata;\r\nconst struct of_device_id *match;\r\nstruct regulator_config config = { };\r\nmatch = of_match_device(twl_of_match, &pdev->dev);\r\nif (match) {\r\ntemplate = match->data;\r\nid = template->desc.id;\r\ninitdata = of_get_regulator_init_data(&pdev->dev,\r\npdev->dev.of_node,\r\n&template->desc);\r\ndrvdata = NULL;\r\n} else {\r\nid = pdev->id;\r\ninitdata = dev_get_platdata(&pdev->dev);\r\nfor (i = 0, template = NULL; i < ARRAY_SIZE(twl_of_match); i++) {\r\ntemplate = twl_of_match[i].data;\r\nif (template && template->desc.id == id)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(twl_of_match))\r\nreturn -ENODEV;\r\ndrvdata = initdata->driver_data;\r\nif (!drvdata)\r\nreturn -EINVAL;\r\n}\r\nif (!template)\r\nreturn -ENODEV;\r\nif (!initdata)\r\nreturn -EINVAL;\r\ninfo = devm_kmemdup(&pdev->dev, template, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nif (drvdata) {\r\ninfo->features = drvdata->features;\r\ninfo->data = drvdata->data;\r\ninfo->set_voltage = drvdata->set_voltage;\r\ninfo->get_voltage = drvdata->get_voltage;\r\n}\r\nc = &initdata->constraints;\r\nc->valid_modes_mask &= REGULATOR_MODE_NORMAL | REGULATOR_MODE_STANDBY;\r\nc->valid_ops_mask &= REGULATOR_CHANGE_VOLTAGE\r\n| REGULATOR_CHANGE_MODE\r\n| REGULATOR_CHANGE_STATUS;\r\nswitch (id) {\r\ncase TWL4030_REG_VIO:\r\ncase TWL4030_REG_VDD1:\r\ncase TWL4030_REG_VDD2:\r\ncase TWL4030_REG_VPLL1:\r\ncase TWL4030_REG_VINTANA1:\r\ncase TWL4030_REG_VINTANA2:\r\ncase TWL4030_REG_VINTDIG:\r\nc->always_on = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (id) {\r\ncase TWL6032_REG_SMPS3:\r\nif (twl_get_smps_mult() & SMPS_MULTOFFSET_SMPS3)\r\ninfo->flags |= SMPS_EXTENDED_EN;\r\nif (twl_get_smps_offset() & SMPS_MULTOFFSET_SMPS3)\r\ninfo->flags |= SMPS_OFFSET_EN;\r\nbreak;\r\ncase TWL6032_REG_SMPS4:\r\nif (twl_get_smps_mult() & SMPS_MULTOFFSET_SMPS4)\r\ninfo->flags |= SMPS_EXTENDED_EN;\r\nif (twl_get_smps_offset() & SMPS_MULTOFFSET_SMPS4)\r\ninfo->flags |= SMPS_OFFSET_EN;\r\nbreak;\r\ncase TWL6032_REG_VIO:\r\nif (twl_get_smps_mult() & SMPS_MULTOFFSET_VIO)\r\ninfo->flags |= SMPS_EXTENDED_EN;\r\nif (twl_get_smps_offset() & SMPS_MULTOFFSET_VIO)\r\ninfo->flags |= SMPS_OFFSET_EN;\r\nbreak;\r\n}\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = initdata;\r\nconfig.driver_data = info;\r\nconfig.of_node = pdev->dev.of_node;\r\nrdev = devm_regulator_register(&pdev->dev, &info->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "can't register %s, %ld\n",\r\ninfo->desc.name, PTR_ERR(rdev));\r\nreturn PTR_ERR(rdev);\r\n}\r\nplatform_set_drvdata(pdev, rdev);\r\nif (twl_class_is_4030())\r\ntwlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_REMAP,\r\ninfo->remap);\r\nreturn 0;\r\n}\r\nstatic int __init twlreg_init(void)\r\n{\r\nreturn platform_driver_register(&twlreg_driver);\r\n}\r\nstatic void __exit twlreg_exit(void)\r\n{\r\nplatform_driver_unregister(&twlreg_driver);\r\n}
