static struct vpfe_fmt *find_format_by_code(unsigned int code)\r\n{\r\nstruct vpfe_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < ARRAY_SIZE(formats); k++) {\r\nfmt = &formats[k];\r\nif (fmt->code == code)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct vpfe_fmt *find_format_by_pix(unsigned int pixelformat)\r\n{\r\nstruct vpfe_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < ARRAY_SIZE(formats); k++) {\r\nfmt = &formats[k];\r\nif (fmt->fourcc == pixelformat)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nmbus_to_pix(struct vpfe_device *vpfe,\r\nconst struct v4l2_mbus_framefmt *mbus,\r\nstruct v4l2_pix_format *pix, unsigned int *bpp)\r\n{\r\nstruct vpfe_subdev_info *sdinfo = vpfe->current_subdev;\r\nunsigned int bus_width = sdinfo->vpfe_param.bus_width;\r\nstruct vpfe_fmt *fmt;\r\nfmt = find_format_by_code(mbus->code);\r\nif (WARN_ON(fmt == NULL)) {\r\npr_err("Invalid mbus code set\n");\r\n*bpp = 1;\r\nreturn;\r\n}\r\nmemset(pix, 0, sizeof(*pix));\r\nv4l2_fill_pix_format(pix, mbus);\r\npix->pixelformat = fmt->fourcc;\r\n*bpp = (bus_width == 10) ? fmt->l.bpp : fmt->s.bpp;\r\npix->bytesperline = ALIGN(pix->width * *bpp, 32);\r\npix->sizeimage = pix->bytesperline * pix->height;\r\n}\r\nstatic void pix_to_mbus(struct vpfe_device *vpfe,\r\nstruct v4l2_pix_format *pix_fmt,\r\nstruct v4l2_mbus_framefmt *mbus_fmt)\r\n{\r\nstruct vpfe_fmt *fmt;\r\nfmt = find_format_by_pix(pix_fmt->pixelformat);\r\nif (!fmt) {\r\nvpfe_dbg(3, vpfe, "Invalid pixel code: %x, default used instead\n",\r\npix_fmt->pixelformat);\r\nfmt = &formats[0];\r\n}\r\nmemset(mbus_fmt, 0, sizeof(*mbus_fmt));\r\nv4l2_fill_mbus_format(mbus_fmt, pix_fmt, fmt->code);\r\n}\r\nstatic char *print_fourcc(u32 fmt)\r\n{\r\nstatic char code[5];\r\ncode[0] = (unsigned char)(fmt & 0xff);\r\ncode[1] = (unsigned char)((fmt >> 8) & 0xff);\r\ncode[2] = (unsigned char)((fmt >> 16) & 0xff);\r\ncode[3] = (unsigned char)((fmt >> 24) & 0xff);\r\ncode[4] = '\0';\r\nreturn code;\r\n}\r\nstatic int\r\ncmp_v4l2_format(const struct v4l2_format *lhs, const struct v4l2_format *rhs)\r\n{\r\nreturn lhs->type == rhs->type &&\r\nlhs->fmt.pix.width == rhs->fmt.pix.width &&\r\nlhs->fmt.pix.height == rhs->fmt.pix.height &&\r\nlhs->fmt.pix.pixelformat == rhs->fmt.pix.pixelformat &&\r\nlhs->fmt.pix.field == rhs->fmt.pix.field &&\r\nlhs->fmt.pix.colorspace == rhs->fmt.pix.colorspace &&\r\nlhs->fmt.pix.ycbcr_enc == rhs->fmt.pix.ycbcr_enc &&\r\nlhs->fmt.pix.quantization == rhs->fmt.pix.quantization &&\r\nlhs->fmt.pix.xfer_func == rhs->fmt.pix.xfer_func;\r\n}\r\nstatic inline u32 vpfe_reg_read(struct vpfe_ccdc *ccdc, u32 offset)\r\n{\r\nreturn ioread32(ccdc->ccdc_cfg.base_addr + offset);\r\n}\r\nstatic inline void vpfe_reg_write(struct vpfe_ccdc *ccdc, u32 val, u32 offset)\r\n{\r\niowrite32(val, ccdc->ccdc_cfg.base_addr + offset);\r\n}\r\nstatic inline struct vpfe_device *to_vpfe(struct vpfe_ccdc *ccdc)\r\n{\r\nreturn container_of(ccdc, struct vpfe_device, ccdc);\r\n}\r\nstatic inline\r\nstruct vpfe_cap_buffer *to_vpfe_buffer(struct vb2_v4l2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct vpfe_cap_buffer, vb);\r\n}\r\nstatic inline void vpfe_pcr_enable(struct vpfe_ccdc *ccdc, int flag)\r\n{\r\nvpfe_reg_write(ccdc, !!flag, VPFE_PCR);\r\n}\r\nstatic void vpfe_config_enable(struct vpfe_ccdc *ccdc, int flag)\r\n{\r\nunsigned int cfg;\r\nif (!flag) {\r\ncfg = vpfe_reg_read(ccdc, VPFE_CONFIG);\r\ncfg &= ~(VPFE_CONFIG_EN_ENABLE << VPFE_CONFIG_EN_SHIFT);\r\n} else {\r\ncfg = VPFE_CONFIG_EN_ENABLE << VPFE_CONFIG_EN_SHIFT;\r\n}\r\nvpfe_reg_write(ccdc, cfg, VPFE_CONFIG);\r\n}\r\nstatic void vpfe_ccdc_setwin(struct vpfe_ccdc *ccdc,\r\nstruct v4l2_rect *image_win,\r\nenum ccdc_frmfmt frm_fmt,\r\nint bpp)\r\n{\r\nint horz_start, horz_nr_pixels;\r\nint vert_start, vert_nr_lines;\r\nint val, mid_img;\r\nhorz_start = image_win->left * bpp;\r\nhorz_nr_pixels = (image_win->width * bpp) - 1;\r\nvpfe_reg_write(ccdc, (horz_start << VPFE_HORZ_INFO_SPH_SHIFT) |\r\nhorz_nr_pixels, VPFE_HORZ_INFO);\r\nvert_start = image_win->top;\r\nif (frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nvert_nr_lines = (image_win->height >> 1) - 1;\r\nvert_start >>= 1;\r\nvert_start += 1;\r\nval = (vert_start << VPFE_VDINT_VDINT0_SHIFT);\r\n} else {\r\nvert_start += 1;\r\nvert_nr_lines = image_win->height - 1;\r\nmid_img = vert_start + (image_win->height / 2);\r\nval = (vert_start << VPFE_VDINT_VDINT0_SHIFT) |\r\n(mid_img & VPFE_VDINT_VDINT1_MASK);\r\n}\r\nvpfe_reg_write(ccdc, val, VPFE_VDINT);\r\nvpfe_reg_write(ccdc, (vert_start << VPFE_VERT_START_SLV0_SHIFT) |\r\nvert_start, VPFE_VERT_START);\r\nvpfe_reg_write(ccdc, vert_nr_lines, VPFE_VERT_LINES);\r\n}\r\nstatic void vpfe_reg_dump(struct vpfe_ccdc *ccdc)\r\n{\r\nstruct vpfe_device *vpfe = to_vpfe(ccdc);\r\nvpfe_dbg(3, vpfe, "ALAW: 0x%x\n", vpfe_reg_read(ccdc, VPFE_ALAW));\r\nvpfe_dbg(3, vpfe, "CLAMP: 0x%x\n", vpfe_reg_read(ccdc, VPFE_CLAMP));\r\nvpfe_dbg(3, vpfe, "DCSUB: 0x%x\n", vpfe_reg_read(ccdc, VPFE_DCSUB));\r\nvpfe_dbg(3, vpfe, "BLKCMP: 0x%x\n", vpfe_reg_read(ccdc, VPFE_BLKCMP));\r\nvpfe_dbg(3, vpfe, "COLPTN: 0x%x\n", vpfe_reg_read(ccdc, VPFE_COLPTN));\r\nvpfe_dbg(3, vpfe, "SDOFST: 0x%x\n", vpfe_reg_read(ccdc, VPFE_SDOFST));\r\nvpfe_dbg(3, vpfe, "SYN_MODE: 0x%x\n",\r\nvpfe_reg_read(ccdc, VPFE_SYNMODE));\r\nvpfe_dbg(3, vpfe, "HSIZE_OFF: 0x%x\n",\r\nvpfe_reg_read(ccdc, VPFE_HSIZE_OFF));\r\nvpfe_dbg(3, vpfe, "HORZ_INFO: 0x%x\n",\r\nvpfe_reg_read(ccdc, VPFE_HORZ_INFO));\r\nvpfe_dbg(3, vpfe, "VERT_START: 0x%x\n",\r\nvpfe_reg_read(ccdc, VPFE_VERT_START));\r\nvpfe_dbg(3, vpfe, "VERT_LINES: 0x%x\n",\r\nvpfe_reg_read(ccdc, VPFE_VERT_LINES));\r\n}\r\nstatic int\r\nvpfe_ccdc_validate_param(struct vpfe_ccdc *ccdc,\r\nstruct vpfe_ccdc_config_params_raw *ccdcparam)\r\n{\r\nstruct vpfe_device *vpfe = to_vpfe(ccdc);\r\nu8 max_gamma, max_data;\r\nif (!ccdcparam->alaw.enable)\r\nreturn 0;\r\nmax_gamma = ccdc_gamma_width_max_bit(ccdcparam->alaw.gamma_wd);\r\nmax_data = ccdc_data_size_max_bit(ccdcparam->data_sz);\r\nif (ccdcparam->alaw.gamma_wd > VPFE_CCDC_GAMMA_BITS_09_0 ||\r\nccdcparam->alaw.gamma_wd < VPFE_CCDC_GAMMA_BITS_15_6 ||\r\nmax_gamma > max_data) {\r\nvpfe_dbg(1, vpfe, "Invalid data line select\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nvpfe_ccdc_update_raw_params(struct vpfe_ccdc *ccdc,\r\nstruct vpfe_ccdc_config_params_raw *raw_params)\r\n{\r\nstruct vpfe_ccdc_config_params_raw *config_params =\r\n&ccdc->ccdc_cfg.bayer.config_params;\r\n*config_params = *raw_params;\r\n}\r\nstatic void vpfe_ccdc_restore_defaults(struct vpfe_ccdc *ccdc)\r\n{\r\nint i;\r\nvpfe_pcr_enable(ccdc, 0);\r\nfor (i = 4; i <= 0x94; i += 4)\r\nvpfe_reg_write(ccdc, 0, i);\r\nvpfe_reg_write(ccdc, VPFE_NO_CULLING, VPFE_CULLING);\r\nvpfe_reg_write(ccdc, VPFE_CCDC_GAMMA_BITS_11_2, VPFE_ALAW);\r\n}\r\nstatic int vpfe_ccdc_close(struct vpfe_ccdc *ccdc, struct device *dev)\r\n{\r\nint dma_cntl, i, pcr;\r\nfor (i = 0; i < 10; i++) {\r\nusleep_range(5000, 6000);\r\npcr = vpfe_reg_read(ccdc, VPFE_PCR);\r\nif (!pcr)\r\nbreak;\r\nvpfe_pcr_enable(ccdc, 0);\r\n}\r\nvpfe_ccdc_restore_defaults(ccdc);\r\nfor (i = 0; i < 10; i++) {\r\ndma_cntl = vpfe_reg_read(ccdc, VPFE_DMA_CNTL);\r\nif (!(dma_cntl & VPFE_DMA_CNTL_OVERFLOW))\r\nbreak;\r\nvpfe_reg_write(ccdc, dma_cntl, VPFE_DMA_CNTL);\r\nusleep_range(5000, 6000);\r\n}\r\nvpfe_config_enable(ccdc, 0);\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int vpfe_ccdc_set_params(struct vpfe_ccdc *ccdc, void __user *params)\r\n{\r\nstruct vpfe_device *vpfe = container_of(ccdc, struct vpfe_device, ccdc);\r\nstruct vpfe_ccdc_config_params_raw raw_params;\r\nint x;\r\nif (ccdc->ccdc_cfg.if_type != VPFE_RAW_BAYER)\r\nreturn -EINVAL;\r\nx = copy_from_user(&raw_params, params, sizeof(raw_params));\r\nif (x) {\r\nvpfe_dbg(1, vpfe,\r\n"vpfe_ccdc_set_params: error in copying ccdc params, %d\n",\r\nx);\r\nreturn -EFAULT;\r\n}\r\nif (!vpfe_ccdc_validate_param(ccdc, &raw_params)) {\r\nvpfe_ccdc_update_raw_params(ccdc, &raw_params);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void vpfe_ccdc_config_ycbcr(struct vpfe_ccdc *ccdc)\r\n{\r\nstruct vpfe_device *vpfe = container_of(ccdc, struct vpfe_device, ccdc);\r\nstruct ccdc_params_ycbcr *params = &ccdc->ccdc_cfg.ycbcr;\r\nu32 syn_mode;\r\nvpfe_dbg(3, vpfe, "vpfe_ccdc_config_ycbcr:\n");\r\nvpfe_ccdc_restore_defaults(ccdc);\r\nsyn_mode = (((params->pix_fmt & VPFE_SYN_MODE_INPMOD_MASK) <<\r\nVPFE_SYN_MODE_INPMOD_SHIFT) |\r\n((params->frm_fmt & VPFE_SYN_FLDMODE_MASK) <<\r\nVPFE_SYN_FLDMODE_SHIFT) | VPFE_VDHDEN_ENABLE |\r\nVPFE_WEN_ENABLE | VPFE_DATA_PACK_ENABLE);\r\nif (params->bt656_enable) {\r\nvpfe_reg_write(ccdc, VPFE_REC656IF_BT656_EN, VPFE_REC656IF);\r\nsyn_mode |= VPFE_SYN_MODE_VD_POL_NEGATIVE;\r\nif (ccdc->ccdc_cfg.if_type == VPFE_BT656_10BIT)\r\nsyn_mode |= VPFE_SYN_MODE_10BITS;\r\nelse\r\nsyn_mode |= VPFE_SYN_MODE_8BITS;\r\n} else {\r\nsyn_mode |= (((params->fid_pol & VPFE_FID_POL_MASK) <<\r\nVPFE_FID_POL_SHIFT) |\r\n((params->hd_pol & VPFE_HD_POL_MASK) <<\r\nVPFE_HD_POL_SHIFT) |\r\n((params->vd_pol & VPFE_VD_POL_MASK) <<\r\nVPFE_VD_POL_SHIFT));\r\n}\r\nvpfe_reg_write(ccdc, syn_mode, VPFE_SYNMODE);\r\nvpfe_ccdc_setwin(ccdc, &params->win,\r\nparams->frm_fmt, params->bytesperpixel);\r\nif (ccdc->ccdc_cfg.if_type == VPFE_BT656_10BIT)\r\nvpfe_reg_write(ccdc,\r\n(params->pix_order << VPFE_CCDCFG_Y8POS_SHIFT) |\r\nVPFE_LATCH_ON_VSYNC_DISABLE |\r\nVPFE_CCDCFG_BW656_10BIT, VPFE_CCDCFG);\r\nelse\r\nvpfe_reg_write(ccdc,\r\n(params->pix_order << VPFE_CCDCFG_Y8POS_SHIFT) |\r\nVPFE_LATCH_ON_VSYNC_DISABLE, VPFE_CCDCFG);\r\nvpfe_reg_write(ccdc, params->bytesperline, VPFE_HSIZE_OFF);\r\nif (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED)\r\nvpfe_reg_write(ccdc, VPFE_SDOFST_FIELD_INTERLEAVED,\r\nVPFE_SDOFST);\r\n}\r\nstatic void\r\nvpfe_ccdc_config_black_clamp(struct vpfe_ccdc *ccdc,\r\nstruct vpfe_ccdc_black_clamp *bclamp)\r\n{\r\nu32 val;\r\nif (!bclamp->enable) {\r\nval = (bclamp->dc_sub) & VPFE_BLK_DC_SUB_MASK;\r\nvpfe_reg_write(ccdc, val, VPFE_DCSUB);\r\nvpfe_reg_write(ccdc, VPFE_CLAMP_DEFAULT_VAL, VPFE_CLAMP);\r\nreturn;\r\n}\r\nval = ((bclamp->sgain & VPFE_BLK_SGAIN_MASK) |\r\n((bclamp->start_pixel & VPFE_BLK_ST_PXL_MASK) <<\r\nVPFE_BLK_ST_PXL_SHIFT) |\r\n((bclamp->sample_ln & VPFE_BLK_SAMPLE_LINE_MASK) <<\r\nVPFE_BLK_SAMPLE_LINE_SHIFT) |\r\n((bclamp->sample_pixel & VPFE_BLK_SAMPLE_LN_MASK) <<\r\nVPFE_BLK_SAMPLE_LN_SHIFT) | VPFE_BLK_CLAMP_ENABLE);\r\nvpfe_reg_write(ccdc, val, VPFE_CLAMP);\r\nvpfe_reg_write(ccdc, VPFE_DCSUB_DEFAULT_VAL, VPFE_DCSUB);\r\n}\r\nstatic void\r\nvpfe_ccdc_config_black_compense(struct vpfe_ccdc *ccdc,\r\nstruct vpfe_ccdc_black_compensation *bcomp)\r\n{\r\nu32 val;\r\nval = ((bcomp->b & VPFE_BLK_COMP_MASK) |\r\n((bcomp->gb & VPFE_BLK_COMP_MASK) <<\r\nVPFE_BLK_COMP_GB_COMP_SHIFT) |\r\n((bcomp->gr & VPFE_BLK_COMP_MASK) <<\r\nVPFE_BLK_COMP_GR_COMP_SHIFT) |\r\n((bcomp->r & VPFE_BLK_COMP_MASK) <<\r\nVPFE_BLK_COMP_R_COMP_SHIFT));\r\nvpfe_reg_write(ccdc, val, VPFE_BLKCMP);\r\n}\r\nstatic void vpfe_ccdc_config_raw(struct vpfe_ccdc *ccdc)\r\n{\r\nstruct vpfe_device *vpfe = container_of(ccdc, struct vpfe_device, ccdc);\r\nstruct vpfe_ccdc_config_params_raw *config_params =\r\n&ccdc->ccdc_cfg.bayer.config_params;\r\nstruct ccdc_params_raw *params = &ccdc->ccdc_cfg.bayer;\r\nunsigned int syn_mode;\r\nunsigned int val;\r\nvpfe_dbg(3, vpfe, "vpfe_ccdc_config_raw:\n");\r\nvpfe_ccdc_restore_defaults(ccdc);\r\nvpfe_reg_write(ccdc, VPFE_LATCH_ON_VSYNC_DISABLE, VPFE_CCDCFG);\r\nsyn_mode = (((params->vd_pol & VPFE_VD_POL_MASK) << VPFE_VD_POL_SHIFT) |\r\n((params->hd_pol & VPFE_HD_POL_MASK) << VPFE_HD_POL_SHIFT) |\r\n((params->fid_pol & VPFE_FID_POL_MASK) <<\r\nVPFE_FID_POL_SHIFT) | ((params->frm_fmt &\r\nVPFE_FRM_FMT_MASK) << VPFE_FRM_FMT_SHIFT) |\r\n((config_params->data_sz & VPFE_DATA_SZ_MASK) <<\r\nVPFE_DATA_SZ_SHIFT) | ((params->pix_fmt &\r\nVPFE_PIX_FMT_MASK) << VPFE_PIX_FMT_SHIFT) |\r\nVPFE_WEN_ENABLE | VPFE_VDHDEN_ENABLE);\r\nif (config_params->alaw.enable) {\r\nval = ((config_params->alaw.gamma_wd &\r\nVPFE_ALAW_GAMMA_WD_MASK) | VPFE_ALAW_ENABLE);\r\nvpfe_reg_write(ccdc, val, VPFE_ALAW);\r\nvpfe_dbg(3, vpfe, "\nWriting 0x%x to ALAW...\n", val);\r\n}\r\nvpfe_ccdc_setwin(ccdc, &params->win, params->frm_fmt,\r\nparams->bytesperpixel);\r\nvpfe_ccdc_config_black_clamp(ccdc, &config_params->blk_clamp);\r\nvpfe_ccdc_config_black_compense(ccdc, &config_params->blk_comp);\r\nif ((config_params->data_sz == VPFE_CCDC_DATA_8BITS) ||\r\nconfig_params->alaw.enable)\r\nsyn_mode |= VPFE_DATA_PACK_ENABLE;\r\nvpfe_reg_write(ccdc, params->bytesperline, VPFE_HSIZE_OFF);\r\nvpfe_dbg(3, vpfe, "Writing %d (%x) to HSIZE_OFF\n",\r\nparams->bytesperline, params->bytesperline);\r\nif (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nif (params->image_invert_enable) {\r\nvpfe_reg_write(ccdc, VPFE_INTERLACED_IMAGE_INVERT,\r\nVPFE_SDOFST);\r\n} else {\r\nvpfe_reg_write(ccdc, VPFE_INTERLACED_NO_IMAGE_INVERT,\r\nVPFE_SDOFST);\r\n}\r\n} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {\r\nvpfe_reg_write(ccdc, VPFE_PROGRESSIVE_NO_IMAGE_INVERT,\r\nVPFE_SDOFST);\r\n}\r\nvpfe_reg_write(ccdc, syn_mode, VPFE_SYNMODE);\r\nvpfe_reg_dump(ccdc);\r\n}\r\nstatic inline int\r\nvpfe_ccdc_set_buftype(struct vpfe_ccdc *ccdc,\r\nenum ccdc_buftype buf_type)\r\n{\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc->ccdc_cfg.bayer.buf_type = buf_type;\r\nelse\r\nccdc->ccdc_cfg.ycbcr.buf_type = buf_type;\r\nreturn 0;\r\n}\r\nstatic inline enum ccdc_buftype vpfe_ccdc_get_buftype(struct vpfe_ccdc *ccdc)\r\n{\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn ccdc->ccdc_cfg.bayer.buf_type;\r\nreturn ccdc->ccdc_cfg.ycbcr.buf_type;\r\n}\r\nstatic int vpfe_ccdc_set_pixel_format(struct vpfe_ccdc *ccdc, u32 pixfmt)\r\n{\r\nstruct vpfe_device *vpfe = container_of(ccdc, struct vpfe_device, ccdc);\r\nvpfe_dbg(1, vpfe, "vpfe_ccdc_set_pixel_format: if_type: %d, pixfmt:%s\n",\r\nccdc->ccdc_cfg.if_type, print_fourcc(pixfmt));\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\nccdc->ccdc_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;\r\nccdc->ccdc_cfg.bayer.config_params.alaw.enable = 0;\r\nswitch (pixfmt) {\r\ncase V4L2_PIX_FMT_SBGGR8:\r\nccdc->ccdc_cfg.bayer.config_params.alaw.enable = 1;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_YUV420:\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_RGB565X:\r\nbreak;\r\ncase V4L2_PIX_FMT_SBGGR16:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nswitch (pixfmt) {\r\ncase V4L2_PIX_FMT_YUYV:\r\nccdc->ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_YCBYCR;\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\nccdc->ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 vpfe_ccdc_get_pixel_format(struct vpfe_ccdc *ccdc)\r\n{\r\nu32 pixfmt;\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\npixfmt = V4L2_PIX_FMT_YUYV;\r\n} else {\r\nif (ccdc->ccdc_cfg.ycbcr.pix_order == CCDC_PIXORDER_YCBYCR)\r\npixfmt = V4L2_PIX_FMT_YUYV;\r\nelse\r\npixfmt = V4L2_PIX_FMT_UYVY;\r\n}\r\nreturn pixfmt;\r\n}\r\nstatic int\r\nvpfe_ccdc_set_image_window(struct vpfe_ccdc *ccdc,\r\nstruct v4l2_rect *win, unsigned int bpp)\r\n{\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\nccdc->ccdc_cfg.bayer.win = *win;\r\nccdc->ccdc_cfg.bayer.bytesperpixel = bpp;\r\nccdc->ccdc_cfg.bayer.bytesperline = ALIGN(win->width * bpp, 32);\r\n} else {\r\nccdc->ccdc_cfg.ycbcr.win = *win;\r\nccdc->ccdc_cfg.ycbcr.bytesperpixel = bpp;\r\nccdc->ccdc_cfg.ycbcr.bytesperline = ALIGN(win->width * bpp, 32);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nvpfe_ccdc_get_image_window(struct vpfe_ccdc *ccdc,\r\nstruct v4l2_rect *win)\r\n{\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\n*win = ccdc->ccdc_cfg.bayer.win;\r\nelse\r\n*win = ccdc->ccdc_cfg.ycbcr.win;\r\n}\r\nstatic inline unsigned int vpfe_ccdc_get_line_length(struct vpfe_ccdc *ccdc)\r\n{\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn ccdc->ccdc_cfg.bayer.bytesperline;\r\nreturn ccdc->ccdc_cfg.ycbcr.bytesperline;\r\n}\r\nstatic inline int\r\nvpfe_ccdc_set_frame_format(struct vpfe_ccdc *ccdc,\r\nenum ccdc_frmfmt frm_fmt)\r\n{\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc->ccdc_cfg.bayer.frm_fmt = frm_fmt;\r\nelse\r\nccdc->ccdc_cfg.ycbcr.frm_fmt = frm_fmt;\r\nreturn 0;\r\n}\r\nstatic inline enum ccdc_frmfmt\r\nvpfe_ccdc_get_frame_format(struct vpfe_ccdc *ccdc)\r\n{\r\nif (ccdc->ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn ccdc->ccdc_cfg.bayer.frm_fmt;\r\nreturn ccdc->ccdc_cfg.ycbcr.frm_fmt;\r\n}\r\nstatic inline int vpfe_ccdc_getfid(struct vpfe_ccdc *ccdc)\r\n{\r\nreturn (vpfe_reg_read(ccdc, VPFE_SYNMODE) >> 15) & 1;\r\n}\r\nstatic inline void vpfe_set_sdr_addr(struct vpfe_ccdc *ccdc, unsigned long addr)\r\n{\r\nvpfe_reg_write(ccdc, addr & 0xffffffe0, VPFE_SDR_ADDR);\r\n}\r\nstatic int vpfe_ccdc_set_hw_if_params(struct vpfe_ccdc *ccdc,\r\nstruct vpfe_hw_if_param *params)\r\n{\r\nstruct vpfe_device *vpfe = container_of(ccdc, struct vpfe_device, ccdc);\r\nccdc->ccdc_cfg.if_type = params->if_type;\r\nswitch (params->if_type) {\r\ncase VPFE_BT656:\r\ncase VPFE_YCBCR_SYNC_16:\r\ncase VPFE_YCBCR_SYNC_8:\r\ncase VPFE_BT656_10BIT:\r\nccdc->ccdc_cfg.ycbcr.vd_pol = params->vdpol;\r\nccdc->ccdc_cfg.ycbcr.hd_pol = params->hdpol;\r\nbreak;\r\ncase VPFE_RAW_BAYER:\r\nccdc->ccdc_cfg.bayer.vd_pol = params->vdpol;\r\nccdc->ccdc_cfg.bayer.hd_pol = params->hdpol;\r\nif (params->bus_width == 10)\r\nccdc->ccdc_cfg.bayer.config_params.data_sz =\r\nVPFE_CCDC_DATA_10BITS;\r\nelse\r\nccdc->ccdc_cfg.bayer.config_params.data_sz =\r\nVPFE_CCDC_DATA_8BITS;\r\nvpfe_dbg(1, vpfe, "params.bus_width: %d\n",\r\nparams->bus_width);\r\nvpfe_dbg(1, vpfe, "config_params.data_sz: %d\n",\r\nccdc->ccdc_cfg.bayer.config_params.data_sz);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vpfe_clear_intr(struct vpfe_ccdc *ccdc, int vdint)\r\n{\r\nunsigned int vpfe_int_status;\r\nvpfe_int_status = vpfe_reg_read(ccdc, VPFE_IRQ_STS);\r\nswitch (vdint) {\r\ncase VPFE_VDINT0:\r\nvpfe_int_status &= ~VPFE_VDINT0;\r\nvpfe_int_status |= VPFE_VDINT0;\r\nbreak;\r\ncase VPFE_VDINT1:\r\nvpfe_int_status &= ~VPFE_VDINT1;\r\nvpfe_int_status |= VPFE_VDINT1;\r\nbreak;\r\ncase VPFE_VDINT2:\r\nvpfe_int_status &= ~VPFE_VDINT2;\r\nvpfe_int_status |= VPFE_VDINT2;\r\nbreak;\r\ndefault:\r\nvpfe_int_status &= ~(VPFE_VDINT0 |\r\nVPFE_VDINT1 |\r\nVPFE_VDINT2);\r\nvpfe_int_status |= (VPFE_VDINT0 |\r\nVPFE_VDINT1 |\r\nVPFE_VDINT2);\r\nbreak;\r\n}\r\nvpfe_reg_write(ccdc, vpfe_int_status, VPFE_IRQ_STS);\r\nvpfe_int_status = vpfe_reg_read(ccdc, VPFE_IRQ_STS);\r\nvpfe_reg_write(ccdc, 1, VPFE_IRQ_EOI);\r\n}\r\nstatic void vpfe_ccdc_config_defaults(struct vpfe_ccdc *ccdc)\r\n{\r\nccdc->ccdc_cfg.if_type = VPFE_RAW_BAYER;\r\nccdc->ccdc_cfg.ycbcr.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT;\r\nccdc->ccdc_cfg.ycbcr.frm_fmt = CCDC_FRMFMT_INTERLACED;\r\nccdc->ccdc_cfg.ycbcr.fid_pol = VPFE_PINPOL_POSITIVE;\r\nccdc->ccdc_cfg.ycbcr.vd_pol = VPFE_PINPOL_POSITIVE;\r\nccdc->ccdc_cfg.ycbcr.hd_pol = VPFE_PINPOL_POSITIVE;\r\nccdc->ccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\r\nccdc->ccdc_cfg.ycbcr.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED;\r\nccdc->ccdc_cfg.ycbcr.win.left = 0;\r\nccdc->ccdc_cfg.ycbcr.win.top = 0;\r\nccdc->ccdc_cfg.ycbcr.win.width = 720;\r\nccdc->ccdc_cfg.ycbcr.win.height = 576;\r\nccdc->ccdc_cfg.ycbcr.bt656_enable = 1;\r\nccdc->ccdc_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;\r\nccdc->ccdc_cfg.bayer.frm_fmt = CCDC_FRMFMT_PROGRESSIVE;\r\nccdc->ccdc_cfg.bayer.fid_pol = VPFE_PINPOL_POSITIVE;\r\nccdc->ccdc_cfg.bayer.vd_pol = VPFE_PINPOL_POSITIVE;\r\nccdc->ccdc_cfg.bayer.hd_pol = VPFE_PINPOL_POSITIVE;\r\nccdc->ccdc_cfg.bayer.win.left = 0;\r\nccdc->ccdc_cfg.bayer.win.top = 0;\r\nccdc->ccdc_cfg.bayer.win.width = 800;\r\nccdc->ccdc_cfg.bayer.win.height = 600;\r\nccdc->ccdc_cfg.bayer.config_params.data_sz = VPFE_CCDC_DATA_8BITS;\r\nccdc->ccdc_cfg.bayer.config_params.alaw.gamma_wd =\r\nVPFE_CCDC_GAMMA_BITS_09_0;\r\n}\r\nstatic int vpfe_get_ccdc_image_format(struct vpfe_device *vpfe,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_rect image_win;\r\nenum ccdc_buftype buf_type;\r\nenum ccdc_frmfmt frm_fmt;\r\nmemset(f, 0, sizeof(*f));\r\nf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvpfe_ccdc_get_image_window(&vpfe->ccdc, &image_win);\r\nf->fmt.pix.width = image_win.width;\r\nf->fmt.pix.height = image_win.height;\r\nf->fmt.pix.bytesperline = vpfe_ccdc_get_line_length(&vpfe->ccdc);\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline *\r\nf->fmt.pix.height;\r\nbuf_type = vpfe_ccdc_get_buftype(&vpfe->ccdc);\r\nf->fmt.pix.pixelformat = vpfe_ccdc_get_pixel_format(&vpfe->ccdc);\r\nfrm_fmt = vpfe_ccdc_get_frame_format(&vpfe->ccdc);\r\nif (frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\n} else if (frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nif (buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\n} else if (buf_type == CCDC_BUFTYPE_FLD_SEPARATED) {\r\nf->fmt.pix.field = V4L2_FIELD_SEQ_TB;\r\n} else {\r\nvpfe_err(vpfe, "Invalid buf_type\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nvpfe_err(vpfe, "Invalid frm_fmt\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpfe_config_ccdc_image_format(struct vpfe_device *vpfe)\r\n{\r\nenum ccdc_frmfmt frm_fmt = CCDC_FRMFMT_INTERLACED;\r\nint ret = 0;\r\nvpfe_dbg(2, vpfe, "vpfe_config_ccdc_image_format\n");\r\nvpfe_dbg(1, vpfe, "pixelformat: %s\n",\r\nprint_fourcc(vpfe->fmt.fmt.pix.pixelformat));\r\nif (vpfe_ccdc_set_pixel_format(&vpfe->ccdc,\r\nvpfe->fmt.fmt.pix.pixelformat) < 0) {\r\nvpfe_err(vpfe, "couldn't set pix format in ccdc\n");\r\nreturn -EINVAL;\r\n}\r\nvpfe_ccdc_set_image_window(&vpfe->ccdc, &vpfe->crop, vpfe->bpp);\r\nswitch (vpfe->fmt.fmt.pix.field) {\r\ncase V4L2_FIELD_INTERLACED:\r\nret = vpfe_ccdc_set_buftype(\r\n&vpfe->ccdc,\r\nCCDC_BUFTYPE_FLD_INTERLEAVED);\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\nfrm_fmt = CCDC_FRMFMT_PROGRESSIVE;\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\nret = vpfe_ccdc_set_buftype(\r\n&vpfe->ccdc,\r\nCCDC_BUFTYPE_FLD_SEPARATED);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nreturn vpfe_ccdc_set_frame_format(&vpfe->ccdc, frm_fmt);\r\n}\r\nstatic int vpfe_config_image_format(struct vpfe_device *vpfe,\r\nv4l2_std_id std_id)\r\n{\r\nstruct v4l2_pix_format *pix = &vpfe->fmt.fmt.pix;\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(vpfe_standards); i++) {\r\nif (vpfe_standards[i].std_id & std_id) {\r\nvpfe->std_info.active_pixels =\r\nvpfe_standards[i].width;\r\nvpfe->std_info.active_lines =\r\nvpfe_standards[i].height;\r\nvpfe->std_info.frame_format =\r\nvpfe_standards[i].frame_format;\r\nvpfe->std_index = i;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(vpfe_standards)) {\r\nvpfe_err(vpfe, "standard not supported\n");\r\nreturn -EINVAL;\r\n}\r\nvpfe->crop.top = vpfe->crop.left = 0;\r\nvpfe->crop.width = vpfe->std_info.active_pixels;\r\nvpfe->crop.height = vpfe->std_info.active_lines;\r\npix->width = vpfe->crop.width;\r\npix->height = vpfe->crop.height;\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\nif (vpfe->std_info.frame_format)\r\npix->field = V4L2_FIELD_INTERLACED;\r\nelse\r\npix->field = V4L2_FIELD_NONE;\r\nret = __vpfe_get_format(vpfe, &vpfe->fmt, &vpfe->bpp);\r\nif (ret)\r\nreturn ret;\r\nvpfe->crop.width = pix->width;\r\nvpfe->crop.height = pix->height;\r\nreturn vpfe_config_ccdc_image_format(vpfe);\r\n}\r\nstatic int vpfe_initialize_device(struct vpfe_device *vpfe)\r\n{\r\nstruct vpfe_subdev_info *sdinfo;\r\nint ret;\r\nsdinfo = &vpfe->cfg->sub_devs[0];\r\nsdinfo->sd = vpfe->sd[0];\r\nvpfe->current_input = 0;\r\nvpfe->std_index = 0;\r\nret = vpfe_config_image_format(vpfe,\r\nvpfe_standards[vpfe->std_index].std_id);\r\nif (ret)\r\nreturn ret;\r\npm_runtime_get_sync(vpfe->pdev);\r\nvpfe_config_enable(&vpfe->ccdc, 1);\r\nvpfe_ccdc_restore_defaults(&vpfe->ccdc);\r\nvpfe_clear_intr(&vpfe->ccdc, -1);\r\nreturn ret;\r\n}\r\nstatic int vpfe_release(struct file *file)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nbool fh_singular;\r\nint ret;\r\nmutex_lock(&vpfe->lock);\r\nfh_singular = v4l2_fh_is_singular_file(file);\r\nret = _vb2_fop_release(file, NULL);\r\nif (fh_singular)\r\nvpfe_ccdc_close(&vpfe->ccdc, vpfe->pdev);\r\nmutex_unlock(&vpfe->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_open(struct file *file)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nint ret;\r\nmutex_lock(&vpfe->lock);\r\nret = v4l2_fh_open(file);\r\nif (ret) {\r\nvpfe_err(vpfe, "v4l2_fh_open failed\n");\r\ngoto unlock;\r\n}\r\nif (!v4l2_fh_is_singular_file(file))\r\ngoto unlock;\r\nif (vpfe_initialize_device(vpfe)) {\r\nv4l2_fh_release(file);\r\nret = -ENODEV;\r\n}\r\nunlock:\r\nmutex_unlock(&vpfe->lock);\r\nreturn ret;\r\n}\r\nstatic inline void vpfe_schedule_next_buffer(struct vpfe_device *vpfe)\r\n{\r\nvpfe->next_frm = list_entry(vpfe->dma_queue.next,\r\nstruct vpfe_cap_buffer, list);\r\nlist_del(&vpfe->next_frm->list);\r\nvpfe_set_sdr_addr(&vpfe->ccdc,\r\nvb2_dma_contig_plane_dma_addr(&vpfe->next_frm->vb.vb2_buf, 0));\r\n}\r\nstatic inline void vpfe_schedule_bottom_field(struct vpfe_device *vpfe)\r\n{\r\nunsigned long addr;\r\naddr = vb2_dma_contig_plane_dma_addr(&vpfe->next_frm->vb.vb2_buf, 0) +\r\nvpfe->field_off;\r\nvpfe_set_sdr_addr(&vpfe->ccdc, addr);\r\n}\r\nstatic inline void vpfe_process_buffer_complete(struct vpfe_device *vpfe)\r\n{\r\nvpfe->cur_frm->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvpfe->cur_frm->vb.field = vpfe->fmt.fmt.pix.field;\r\nvpfe->cur_frm->vb.sequence = vpfe->sequence++;\r\nvb2_buffer_done(&vpfe->cur_frm->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\nvpfe->cur_frm = vpfe->next_frm;\r\n}\r\nstatic irqreturn_t vpfe_isr(int irq, void *dev)\r\n{\r\nstruct vpfe_device *vpfe = (struct vpfe_device *)dev;\r\nenum v4l2_field field;\r\nint intr_status;\r\nint fid;\r\nintr_status = vpfe_reg_read(&vpfe->ccdc, VPFE_IRQ_STS);\r\nif (intr_status & VPFE_VDINT0) {\r\nfield = vpfe->fmt.fmt.pix.field;\r\nif (field == V4L2_FIELD_NONE) {\r\nif (vpfe->cur_frm != vpfe->next_frm)\r\nvpfe_process_buffer_complete(vpfe);\r\ngoto next_intr;\r\n}\r\nfid = vpfe_ccdc_getfid(&vpfe->ccdc);\r\nvpfe->field ^= 1;\r\nif (fid == vpfe->field) {\r\nif (fid == 0) {\r\nif (vpfe->cur_frm != vpfe->next_frm)\r\nvpfe_process_buffer_complete(vpfe);\r\nif (field == V4L2_FIELD_SEQ_TB)\r\nvpfe_schedule_bottom_field(vpfe);\r\ngoto next_intr;\r\n}\r\nspin_lock(&vpfe->dma_queue_lock);\r\nif (!list_empty(&vpfe->dma_queue) &&\r\nvpfe->cur_frm == vpfe->next_frm)\r\nvpfe_schedule_next_buffer(vpfe);\r\nspin_unlock(&vpfe->dma_queue_lock);\r\n} else if (fid == 0) {\r\nvpfe->field = fid;\r\n}\r\n}\r\nnext_intr:\r\nif (intr_status & VPFE_VDINT1) {\r\nspin_lock(&vpfe->dma_queue_lock);\r\nif (vpfe->fmt.fmt.pix.field == V4L2_FIELD_NONE &&\r\n!list_empty(&vpfe->dma_queue) &&\r\nvpfe->cur_frm == vpfe->next_frm)\r\nvpfe_schedule_next_buffer(vpfe);\r\nspin_unlock(&vpfe->dma_queue_lock);\r\n}\r\nvpfe_clear_intr(&vpfe->ccdc, intr_status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void vpfe_detach_irq(struct vpfe_device *vpfe)\r\n{\r\nunsigned int intr = VPFE_VDINT0;\r\nenum ccdc_frmfmt frame_format;\r\nframe_format = vpfe_ccdc_get_frame_format(&vpfe->ccdc);\r\nif (frame_format == CCDC_FRMFMT_PROGRESSIVE)\r\nintr |= VPFE_VDINT1;\r\nvpfe_reg_write(&vpfe->ccdc, intr, VPFE_IRQ_EN_CLR);\r\n}\r\nstatic inline void vpfe_attach_irq(struct vpfe_device *vpfe)\r\n{\r\nunsigned int intr = VPFE_VDINT0;\r\nenum ccdc_frmfmt frame_format;\r\nframe_format = vpfe_ccdc_get_frame_format(&vpfe->ccdc);\r\nif (frame_format == CCDC_FRMFMT_PROGRESSIVE)\r\nintr |= VPFE_VDINT1;\r\nvpfe_reg_write(&vpfe->ccdc, intr, VPFE_IRQ_EN_SET);\r\n}\r\nstatic int vpfe_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nvpfe_dbg(2, vpfe, "vpfe_querycap\n");\r\nstrlcpy(cap->driver, VPFE_MODULE_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, "TI AM437x VPFE", sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"platform:%s", vpfe->v4l2_dev.name);\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int __vpfe_get_format(struct vpfe_device *vpfe,\r\nstruct v4l2_format *format, unsigned int *bpp)\r\n{\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nstruct vpfe_subdev_info *sdinfo;\r\nstruct v4l2_subdev_format fmt;\r\nint ret;\r\nsdinfo = vpfe->current_subdev;\r\nif (!sdinfo->sd)\r\nreturn -EINVAL;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nfmt.pad = 0;\r\nret = v4l2_subdev_call(sdinfo->sd, pad, get_fmt, NULL, &fmt);\r\nif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nreturn ret;\r\nif (!ret) {\r\nv4l2_fill_pix_format(&format->fmt.pix, &fmt.format);\r\nmbus_to_pix(vpfe, &fmt.format, &format->fmt.pix, bpp);\r\n} else {\r\nret = v4l2_device_call_until_err(&vpfe->v4l2_dev,\r\nsdinfo->grp_id,\r\npad, get_fmt,\r\nNULL, &fmt);\r\nif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nreturn ret;\r\nv4l2_fill_pix_format(&format->fmt.pix, &mbus_fmt);\r\nmbus_to_pix(vpfe, &mbus_fmt, &format->fmt.pix, bpp);\r\n}\r\nformat->type = vpfe->fmt.type;\r\nvpfe_dbg(1, vpfe,\r\n"%s size %dx%d (%s) bytesperline = %d, size = %d, bpp = %d\n",\r\n__func__, format->fmt.pix.width, format->fmt.pix.height,\r\nprint_fourcc(format->fmt.pix.pixelformat),\r\nformat->fmt.pix.bytesperline, format->fmt.pix.sizeimage, *bpp);\r\nreturn 0;\r\n}\r\nstatic int __vpfe_set_format(struct vpfe_device *vpfe,\r\nstruct v4l2_format *format, unsigned int *bpp)\r\n{\r\nstruct vpfe_subdev_info *sdinfo;\r\nstruct v4l2_subdev_format fmt;\r\nint ret;\r\nvpfe_dbg(2, vpfe, "__vpfe_set_format\n");\r\nsdinfo = vpfe->current_subdev;\r\nif (!sdinfo->sd)\r\nreturn -EINVAL;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nfmt.pad = 0;\r\npix_to_mbus(vpfe, &format->fmt.pix, &fmt.format);\r\nret = v4l2_subdev_call(sdinfo->sd, pad, set_fmt, NULL, &fmt);\r\nif (ret)\r\nreturn ret;\r\nv4l2_fill_pix_format(&format->fmt.pix, &fmt.format);\r\nmbus_to_pix(vpfe, &fmt.format, &format->fmt.pix, bpp);\r\nformat->type = vpfe->fmt.type;\r\nvpfe_dbg(1, vpfe,\r\n"%s size %dx%d (%s) bytesperline = %d, size = %d, bpp = %d\n",\r\n__func__, format->fmt.pix.width, format->fmt.pix.height,\r\nprint_fourcc(format->fmt.pix.pixelformat),\r\nformat->fmt.pix.bytesperline, format->fmt.pix.sizeimage, *bpp);\r\nreturn 0;\r\n}\r\nstatic int vpfe_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nvpfe_dbg(2, vpfe, "vpfe_g_fmt\n");\r\n*fmt = vpfe->fmt;\r\nreturn 0;\r\n}\r\nstatic int vpfe_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nstruct vpfe_fmt *fmt = NULL;\r\nunsigned int k;\r\nvpfe_dbg(2, vpfe, "vpfe_enum_format index:%d\n",\r\nf->index);\r\nsdinfo = vpfe->current_subdev;\r\nif (!sdinfo->sd)\r\nreturn -EINVAL;\r\nif (f->index > ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nfor (k = 0; k < ARRAY_SIZE(formats); k++) {\r\nif (formats[k].index == f->index) {\r\nfmt = &formats[k];\r\nbreak;\r\n}\r\n}\r\nif (!fmt)\r\nreturn -EINVAL;\r\nstrncpy(f->description, fmt->name, sizeof(f->description) - 1);\r\nf->pixelformat = fmt->fourcc;\r\nf->type = vpfe->fmt.type;\r\nvpfe_dbg(1, vpfe, "vpfe_enum_format: mbus index: %d code: %x pixelformat: %s [%s]\n",\r\nf->index, fmt->code, print_fourcc(fmt->fourcc), fmt->name);\r\nreturn 0;\r\n}\r\nstatic int vpfe_try_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nunsigned int bpp;\r\nvpfe_dbg(2, vpfe, "vpfe_try_fmt\n");\r\nreturn __vpfe_get_format(vpfe, fmt, &bpp);\r\n}\r\nstatic int vpfe_s_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nstruct v4l2_format format;\r\nunsigned int bpp;\r\nint ret;\r\nvpfe_dbg(2, vpfe, "vpfe_s_fmt\n");\r\nif (vb2_is_busy(&vpfe->buffer_queue)) {\r\nvpfe_err(vpfe, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nret = vpfe_try_fmt(file, priv, &format);\r\nif (ret)\r\nreturn ret;\r\nif (!cmp_v4l2_format(fmt, &format)) {\r\nret = __vpfe_set_format(vpfe, fmt, &bpp);\r\nif (ret)\r\nreturn ret;\r\n} else\r\n*fmt = format;\r\nvpfe_detach_irq(vpfe);\r\nvpfe->fmt = *fmt;\r\nvpfe->bpp = bpp;\r\nvpfe->crop.width = fmt->fmt.pix.width;\r\nvpfe->crop.height = fmt->fmt.pix.height;\r\nreturn vpfe_config_ccdc_image_format(vpfe);\r\n}\r\nstatic int vpfe_enum_size(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nstruct v4l2_subdev_frame_size_enum fse;\r\nstruct vpfe_subdev_info *sdinfo;\r\nstruct v4l2_mbus_framefmt mbus;\r\nstruct v4l2_pix_format pix;\r\nstruct vpfe_fmt *fmt;\r\nint ret;\r\nvpfe_dbg(2, vpfe, "vpfe_enum_size\n");\r\nfmt = find_format_by_pix(fsize->pixel_format);\r\nif (!fmt) {\r\nvpfe_dbg(3, vpfe, "Invalid pixel code: %x, default used instead\n",\r\nfsize->pixel_format);\r\nreturn -EINVAL;\r\n}\r\nmemset(fsize->reserved, 0x0, sizeof(fsize->reserved));\r\nsdinfo = vpfe->current_subdev;\r\nif (!sdinfo->sd)\r\nreturn -EINVAL;\r\nmemset(&pix, 0x0, sizeof(pix));\r\npix.pixelformat = fsize->pixel_format;\r\npix.width = 640;\r\npix.height = 480;\r\npix.colorspace = V4L2_COLORSPACE_SRGB;\r\npix.field = V4L2_FIELD_NONE;\r\npix_to_mbus(vpfe, &pix, &mbus);\r\nmemset(&fse, 0x0, sizeof(fse));\r\nfse.index = fsize->index;\r\nfse.pad = 0;\r\nfse.code = mbus.code;\r\nfse.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(sdinfo->sd, pad, enum_frame_size, NULL, &fse);\r\nif (ret)\r\nreturn -EINVAL;\r\nvpfe_dbg(1, vpfe, "vpfe_enum_size: index: %d code: %x W:[%d,%d] H:[%d,%d]\n",\r\nfse.index, fse.code, fse.min_width, fse.max_width,\r\nfse.min_height, fse.max_height);\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = fse.max_width;\r\nfsize->discrete.height = fse.max_height;\r\nvpfe_dbg(1, vpfe, "vpfe_enum_size: index: %d pixformat: %s size: %dx%d\n",\r\nfsize->index, print_fourcc(fsize->pixel_format),\r\nfsize->discrete.width, fsize->discrete.height);\r\nreturn 0;\r\n}\r\nstatic int\r\nvpfe_get_subdev_input_index(struct vpfe_device *vpfe,\r\nint *subdev_index,\r\nint *subdev_input_index,\r\nint app_input_index)\r\n{\r\nint i, j = 0;\r\nfor (i = 0; i < ARRAY_SIZE(vpfe->cfg->asd); i++) {\r\nif (app_input_index < (j + 1)) {\r\n*subdev_index = i;\r\n*subdev_input_index = app_input_index - j;\r\nreturn 0;\r\n}\r\nj++;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpfe_get_app_input_index(struct vpfe_device *vpfe,\r\nint *app_input_index)\r\n{\r\nstruct vpfe_config *cfg = vpfe->cfg;\r\nstruct vpfe_subdev_info *sdinfo;\r\nstruct i2c_client *client;\r\nstruct i2c_client *curr_client;\r\nint i, j = 0;\r\ncurr_client = v4l2_get_subdevdata(vpfe->current_subdev->sd);\r\nfor (i = 0; i < ARRAY_SIZE(vpfe->cfg->asd); i++) {\r\nsdinfo = &cfg->sub_devs[i];\r\nclient = v4l2_get_subdevdata(sdinfo->sd);\r\nif (client->addr == curr_client->addr &&\r\nclient->adapter->nr == curr_client->adapter->nr) {\r\nif (vpfe->current_input >= 1)\r\nreturn -1;\r\n*app_input_index = j + vpfe->current_input;\r\nreturn 0;\r\n}\r\nj++;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpfe_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nint subdev, index;\r\nvpfe_dbg(2, vpfe, "vpfe_enum_input\n");\r\nif (vpfe_get_subdev_input_index(vpfe, &subdev, &index,\r\ninp->index) < 0) {\r\nvpfe_dbg(1, vpfe,\r\n"input information not found for the subdev\n");\r\nreturn -EINVAL;\r\n}\r\nsdinfo = &vpfe->cfg->sub_devs[subdev];\r\n*inp = sdinfo->inputs[index];\r\nreturn 0;\r\n}\r\nstatic int vpfe_g_input(struct file *file, void *priv, unsigned int *index)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nvpfe_dbg(2, vpfe, "vpfe_g_input\n");\r\nreturn vpfe_get_app_input_index(vpfe, index);\r\n}\r\nstatic int vpfe_set_input(struct vpfe_device *vpfe, unsigned int index)\r\n{\r\nint subdev_index = 0, inp_index = 0;\r\nstruct vpfe_subdev_info *sdinfo;\r\nstruct vpfe_route *route;\r\nu32 input, output;\r\nint ret;\r\nvpfe_dbg(2, vpfe, "vpfe_set_input: index: %d\n", index);\r\nif (vb2_is_busy(&vpfe->buffer_queue)) {\r\nvpfe_err(vpfe, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nret = vpfe_get_subdev_input_index(vpfe,\r\n&subdev_index,\r\n&inp_index,\r\nindex);\r\nif (ret < 0) {\r\nvpfe_err(vpfe, "invalid input index: %d\n", index);\r\ngoto get_out;\r\n}\r\nsdinfo = &vpfe->cfg->sub_devs[subdev_index];\r\nsdinfo->sd = vpfe->sd[subdev_index];\r\nroute = &sdinfo->routes[inp_index];\r\nif (route && sdinfo->can_route) {\r\ninput = route->input;\r\noutput = route->output;\r\nif (sdinfo->sd) {\r\nret = v4l2_subdev_call(sdinfo->sd, video,\r\ns_routing, input, output, 0);\r\nif (ret) {\r\nvpfe_err(vpfe, "s_routing failed\n");\r\nret = -EINVAL;\r\ngoto get_out;\r\n}\r\n}\r\n}\r\nvpfe->current_subdev = sdinfo;\r\nif (sdinfo->sd)\r\nvpfe->v4l2_dev.ctrl_handler = sdinfo->sd->ctrl_handler;\r\nvpfe->current_input = index;\r\nvpfe->std_index = 0;\r\nret = vpfe_ccdc_set_hw_if_params(&vpfe->ccdc, &sdinfo->vpfe_param);\r\nif (ret)\r\nreturn ret;\r\nreturn vpfe_config_image_format(vpfe,\r\nvpfe_standards[vpfe->std_index].std_id);\r\nget_out:\r\nreturn ret;\r\n}\r\nstatic int vpfe_s_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nvpfe_dbg(2, vpfe,\r\n"vpfe_s_input: index: %d\n", index);\r\nreturn vpfe_set_input(vpfe, index);\r\n}\r\nstatic int vpfe_querystd(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nvpfe_dbg(2, vpfe, "vpfe_querystd\n");\r\nsdinfo = vpfe->current_subdev;\r\nif (!(sdinfo->inputs[0].capabilities & V4L2_IN_CAP_STD))\r\nreturn -ENODATA;\r\nreturn v4l2_device_call_until_err(&vpfe->v4l2_dev, sdinfo->grp_id,\r\nvideo, querystd, std_id);\r\n}\r\nstatic int vpfe_s_std(struct file *file, void *priv, v4l2_std_id std_id)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nint ret;\r\nvpfe_dbg(2, vpfe, "vpfe_s_std\n");\r\nsdinfo = vpfe->current_subdev;\r\nif (!(sdinfo->inputs[0].capabilities & V4L2_IN_CAP_STD))\r\nreturn -ENODATA;\r\nif (vb2_is_busy(&vpfe->buffer_queue)) {\r\nvpfe_err(vpfe, "%s device busy\n", __func__);\r\nret = -EBUSY;\r\nreturn ret;\r\n}\r\nret = v4l2_device_call_until_err(&vpfe->v4l2_dev, sdinfo->grp_id,\r\nvideo, s_std, std_id);\r\nif (ret < 0) {\r\nvpfe_err(vpfe, "Failed to set standard\n");\r\nreturn ret;\r\n}\r\nret = vpfe_config_image_format(vpfe, std_id);\r\nreturn ret;\r\n}\r\nstatic int vpfe_g_std(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nstruct vpfe_subdev_info *sdinfo;\r\nvpfe_dbg(2, vpfe, "vpfe_g_std\n");\r\nsdinfo = vpfe->current_subdev;\r\nif (sdinfo->inputs[0].capabilities != V4L2_IN_CAP_STD)\r\nreturn -ENODATA;\r\n*std_id = vpfe_standards[vpfe->std_index].std_id;\r\nreturn 0;\r\n}\r\nstatic void vpfe_calculate_offsets(struct vpfe_device *vpfe)\r\n{\r\nstruct v4l2_rect image_win;\r\nvpfe_dbg(2, vpfe, "vpfe_calculate_offsets\n");\r\nvpfe_ccdc_get_image_window(&vpfe->ccdc, &image_win);\r\nvpfe->field_off = image_win.height * image_win.width;\r\n}\r\nstatic int vpfe_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct vpfe_device *vpfe = vb2_get_drv_priv(vq);\r\nunsigned size = vpfe->fmt.fmt.pix.sizeimage;\r\nif (vq->num_buffers + *nbuffers < 3)\r\n*nbuffers = 3 - vq->num_buffers;\r\nif (*nplanes) {\r\nif (sizes[0] < size)\r\nreturn -EINVAL;\r\nsize = sizes[0];\r\n}\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nvpfe_dbg(1, vpfe,\r\n"nbuffers=%d, size=%u\n", *nbuffers, sizes[0]);\r\nvpfe_calculate_offsets(vpfe);\r\nreturn 0;\r\n}\r\nstatic int vpfe_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vpfe_device *vpfe = vb2_get_drv_priv(vb->vb2_queue);\r\nvb2_set_plane_payload(vb, 0, vpfe->fmt.fmt.pix.sizeimage);\r\nif (vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\r\nreturn -EINVAL;\r\nvbuf->field = vpfe->fmt.fmt.pix.field;\r\nreturn 0;\r\n}\r\nstatic void vpfe_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vpfe_device *vpfe = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vpfe_cap_buffer *buf = to_vpfe_buffer(vbuf);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&vpfe->dma_queue_lock, flags);\r\nlist_add_tail(&buf->list, &vpfe->dma_queue);\r\nspin_unlock_irqrestore(&vpfe->dma_queue_lock, flags);\r\n}\r\nstatic int vpfe_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vpfe_device *vpfe = vb2_get_drv_priv(vq);\r\nstruct vpfe_cap_buffer *buf, *tmp;\r\nstruct vpfe_subdev_info *sdinfo;\r\nunsigned long flags;\r\nunsigned long addr;\r\nint ret;\r\nspin_lock_irqsave(&vpfe->dma_queue_lock, flags);\r\nvpfe->field = 0;\r\nvpfe->sequence = 0;\r\nsdinfo = vpfe->current_subdev;\r\nvpfe_attach_irq(vpfe);\r\nif (vpfe->ccdc.ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nvpfe_ccdc_config_raw(&vpfe->ccdc);\r\nelse\r\nvpfe_ccdc_config_ycbcr(&vpfe->ccdc);\r\nvpfe->next_frm = list_entry(vpfe->dma_queue.next,\r\nstruct vpfe_cap_buffer, list);\r\nvpfe->cur_frm = vpfe->next_frm;\r\nlist_del(&vpfe->cur_frm->list);\r\nspin_unlock_irqrestore(&vpfe->dma_queue_lock, flags);\r\naddr = vb2_dma_contig_plane_dma_addr(&vpfe->cur_frm->vb.vb2_buf, 0);\r\nvpfe_set_sdr_addr(&vpfe->ccdc, (unsigned long)(addr));\r\nvpfe_pcr_enable(&vpfe->ccdc, 1);\r\nret = v4l2_subdev_call(sdinfo->sd, video, s_stream, 1);\r\nif (ret < 0) {\r\nvpfe_err(vpfe, "Error in attaching interrupt handle\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry_safe(buf, tmp, &vpfe->dma_queue, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\r\n}\r\nreturn ret;\r\n}\r\nstatic void vpfe_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vpfe_device *vpfe = vb2_get_drv_priv(vq);\r\nstruct vpfe_subdev_info *sdinfo;\r\nunsigned long flags;\r\nint ret;\r\nvpfe_pcr_enable(&vpfe->ccdc, 0);\r\nvpfe_detach_irq(vpfe);\r\nsdinfo = vpfe->current_subdev;\r\nret = v4l2_subdev_call(sdinfo->sd, video, s_stream, 0);\r\nif (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nvpfe_dbg(1, vpfe, "stream off failed in subdev\n");\r\nspin_lock_irqsave(&vpfe->dma_queue_lock, flags);\r\nif (vpfe->cur_frm == vpfe->next_frm) {\r\nvb2_buffer_done(&vpfe->cur_frm->vb.vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\n} else {\r\nif (vpfe->cur_frm != NULL)\r\nvb2_buffer_done(&vpfe->cur_frm->vb.vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\nif (vpfe->next_frm != NULL)\r\nvb2_buffer_done(&vpfe->next_frm->vb.vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nwhile (!list_empty(&vpfe->dma_queue)) {\r\nvpfe->next_frm = list_entry(vpfe->dma_queue.next,\r\nstruct vpfe_cap_buffer, list);\r\nlist_del(&vpfe->next_frm->list);\r\nvb2_buffer_done(&vpfe->next_frm->vb.vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&vpfe->dma_queue_lock, flags);\r\n}\r\nstatic int vpfe_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *crop)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nvpfe_dbg(2, vpfe, "vpfe_cropcap\n");\r\nif (vpfe->std_index >= ARRAY_SIZE(vpfe_standards))\r\nreturn -EINVAL;\r\nmemset(crop, 0, sizeof(struct v4l2_cropcap));\r\ncrop->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncrop->defrect.width = vpfe_standards[vpfe->std_index].width;\r\ncrop->bounds.width = crop->defrect.width;\r\ncrop->defrect.height = vpfe_standards[vpfe->std_index].height;\r\ncrop->bounds.height = crop->defrect.height;\r\ncrop->pixelaspect = vpfe_standards[vpfe->std_index].pixelaspect;\r\nreturn 0;\r\n}\r\nstatic int\r\nvpfe_g_selection(struct file *file, void *fh, struct v4l2_selection *s)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ns->r.left = s->r.top = 0;\r\ns->r.width = vpfe->crop.width;\r\ns->r.height = vpfe->crop.height;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r = vpfe->crop;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int enclosed_rectangle(struct v4l2_rect *a, struct v4l2_rect *b)\r\n{\r\nif (a->left < b->left || a->top < b->top)\r\nreturn 0;\r\nif (a->left + a->width > b->left + b->width)\r\nreturn 0;\r\nif (a->top + a->height > b->top + b->height)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int\r\nvpfe_s_selection(struct file *file, void *fh, struct v4l2_selection *s)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nstruct v4l2_rect cr = vpfe->crop;\r\nstruct v4l2_rect r = s->r;\r\nif (vb2_is_busy(&vpfe->buffer_queue)) {\r\nvpfe_err(vpfe, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\ns->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nv4l_bound_align_image(&r.width, 0, cr.width, 0,\r\n&r.height, 0, cr.height, 0, 0);\r\nr.left = clamp_t(unsigned int, r.left, 0, cr.width - r.width);\r\nr.top = clamp_t(unsigned int, r.top, 0, cr.height - r.height);\r\nif (s->flags & V4L2_SEL_FLAG_LE && !enclosed_rectangle(&r, &s->r))\r\nreturn -ERANGE;\r\nif (s->flags & V4L2_SEL_FLAG_GE && !enclosed_rectangle(&s->r, &r))\r\nreturn -ERANGE;\r\ns->r = vpfe->crop = r;\r\nvpfe_ccdc_set_image_window(&vpfe->ccdc, &r, vpfe->bpp);\r\nvpfe->fmt.fmt.pix.width = r.width;\r\nvpfe->fmt.fmt.pix.height = r.height;\r\nvpfe->fmt.fmt.pix.bytesperline = vpfe_ccdc_get_line_length(&vpfe->ccdc);\r\nvpfe->fmt.fmt.pix.sizeimage = vpfe->fmt.fmt.pix.bytesperline *\r\nvpfe->fmt.fmt.pix.height;\r\nvpfe_dbg(1, vpfe, "cropped (%d,%d)/%dx%d of %dx%d\n",\r\nr.left, r.top, r.width, r.height, cr.width, cr.height);\r\nreturn 0;\r\n}\r\nstatic long vpfe_ioctl_default(struct file *file, void *priv,\r\nbool valid_prio, unsigned int cmd, void *param)\r\n{\r\nstruct vpfe_device *vpfe = video_drvdata(file);\r\nint ret;\r\nvpfe_dbg(2, vpfe, "vpfe_ioctl_default\n");\r\nif (!valid_prio) {\r\nvpfe_err(vpfe, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (vb2_is_busy(&vpfe->buffer_queue)) {\r\nvpfe_err(vpfe, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nswitch (cmd) {\r\ncase VIDIOC_AM437X_CCDC_CFG:\r\nret = vpfe_ccdc_set_params(&vpfe->ccdc, (void __user *)param);\r\nif (ret) {\r\nvpfe_dbg(2, vpfe,\r\n"Error setting parameters in CCDC\n");\r\nreturn ret;\r\n}\r\nret = vpfe_get_ccdc_image_format(vpfe,\r\n&vpfe->fmt);\r\nif (ret < 0) {\r\nvpfe_dbg(2, vpfe,\r\n"Invalid image format at CCDC\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nvpfe_async_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct vpfe_device *vpfe = container_of(notifier->v4l2_dev,\r\nstruct vpfe_device, v4l2_dev);\r\nstruct v4l2_subdev_mbus_code_enum mbus_code;\r\nstruct vpfe_subdev_info *sdinfo;\r\nbool found = false;\r\nint i, j;\r\nvpfe_dbg(1, vpfe, "vpfe_async_bound\n");\r\nfor (i = 0; i < ARRAY_SIZE(vpfe->cfg->asd); i++) {\r\nif (vpfe->cfg->asd[i]->match.of.node == asd[i].match.of.node) {\r\nsdinfo = &vpfe->cfg->sub_devs[i];\r\nvpfe->sd[i] = subdev;\r\nvpfe->sd[i]->grp_id = sdinfo->grp_id;\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nvpfe_info(vpfe, "sub device (%s) not matched\n", subdev->name);\r\nreturn -EINVAL;\r\n}\r\nvpfe->video_dev.tvnorms |= sdinfo->inputs[0].std;\r\nfor (j = 0, i = 0; ; ++j) {\r\nstruct vpfe_fmt *fmt;\r\nint ret;\r\nmemset(&mbus_code, 0, sizeof(mbus_code));\r\nmbus_code.index = j;\r\nmbus_code.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(subdev, pad, enum_mbus_code,\r\nNULL, &mbus_code);\r\nif (ret)\r\nbreak;\r\nfmt = find_format_by_code(mbus_code.code);\r\nif (!fmt)\r\ncontinue;\r\nfmt->supported = true;\r\nfmt->index = i++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpfe_probe_complete(struct vpfe_device *vpfe)\r\n{\r\nstruct video_device *vdev;\r\nstruct vb2_queue *q;\r\nint err;\r\nspin_lock_init(&vpfe->dma_queue_lock);\r\nmutex_init(&vpfe->lock);\r\nvpfe->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvpfe->current_subdev = &vpfe->cfg->sub_devs[0];\r\nvpfe->v4l2_dev.ctrl_handler = vpfe->sd[0]->ctrl_handler;\r\nerr = vpfe_set_input(vpfe, 0);\r\nif (err)\r\ngoto probe_out;\r\nq = &vpfe->buffer_queue;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\r\nq->drv_priv = vpfe;\r\nq->ops = &vpfe_video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct vpfe_cap_buffer);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &vpfe->lock;\r\nq->min_buffers_needed = 1;\r\nq->dev = vpfe->pdev;\r\nerr = vb2_queue_init(q);\r\nif (err) {\r\nvpfe_err(vpfe, "vb2_queue_init() failed\n");\r\ngoto probe_out;\r\n}\r\nINIT_LIST_HEAD(&vpfe->dma_queue);\r\nvdev = &vpfe->video_dev;\r\nstrlcpy(vdev->name, VPFE_MODULE_NAME, sizeof(vdev->name));\r\nvdev->release = video_device_release_empty;\r\nvdev->fops = &vpfe_fops;\r\nvdev->ioctl_ops = &vpfe_ioctl_ops;\r\nvdev->v4l2_dev = &vpfe->v4l2_dev;\r\nvdev->vfl_dir = VFL_DIR_RX;\r\nvdev->queue = q;\r\nvdev->lock = &vpfe->lock;\r\nvideo_set_drvdata(vdev, vpfe);\r\nerr = video_register_device(&vpfe->video_dev, VFL_TYPE_GRABBER, -1);\r\nif (err) {\r\nvpfe_err(vpfe,\r\n"Unable to register video device.\n");\r\ngoto probe_out;\r\n}\r\nreturn 0;\r\nprobe_out:\r\nv4l2_device_unregister(&vpfe->v4l2_dev);\r\nreturn err;\r\n}\r\nstatic int vpfe_async_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct vpfe_device *vpfe = container_of(notifier->v4l2_dev,\r\nstruct vpfe_device, v4l2_dev);\r\nreturn vpfe_probe_complete(vpfe);\r\n}\r\nstatic struct vpfe_config *\r\nvpfe_get_pdata(struct platform_device *pdev)\r\n{\r\nstruct device_node *endpoint = NULL;\r\nstruct v4l2_of_endpoint bus_cfg;\r\nstruct vpfe_subdev_info *sdinfo;\r\nstruct vpfe_config *pdata;\r\nunsigned int flags;\r\nunsigned int i;\r\nint err;\r\ndev_dbg(&pdev->dev, "vpfe_get_pdata\n");\r\nif (!IS_ENABLED(CONFIG_OF) || !pdev->dev.of_node)\r\nreturn pdev->dev.platform_data;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nfor (i = 0; ; i++) {\r\nstruct device_node *rem;\r\nendpoint = of_graph_get_next_endpoint(pdev->dev.of_node,\r\nendpoint);\r\nif (!endpoint)\r\nbreak;\r\nsdinfo = &pdata->sub_devs[i];\r\nsdinfo->grp_id = 0;\r\nsdinfo->inputs[0].index = i;\r\nstrcpy(sdinfo->inputs[0].name, "Camera");\r\nsdinfo->inputs[0].type = V4L2_INPUT_TYPE_CAMERA;\r\nsdinfo->inputs[0].std = V4L2_STD_ALL;\r\nsdinfo->inputs[0].capabilities = V4L2_IN_CAP_STD;\r\nsdinfo->can_route = 0;\r\nsdinfo->routes = NULL;\r\nof_property_read_u32(endpoint, "ti,am437x-vpfe-interface",\r\n&sdinfo->vpfe_param.if_type);\r\nif (sdinfo->vpfe_param.if_type < 0 ||\r\nsdinfo->vpfe_param.if_type > 4) {\r\nsdinfo->vpfe_param.if_type = VPFE_RAW_BAYER;\r\n}\r\nerr = v4l2_of_parse_endpoint(endpoint, &bus_cfg);\r\nif (err) {\r\ndev_err(&pdev->dev, "Could not parse the endpoint\n");\r\ngoto done;\r\n}\r\nsdinfo->vpfe_param.bus_width = bus_cfg.bus.parallel.bus_width;\r\nif (sdinfo->vpfe_param.bus_width < 8 ||\r\nsdinfo->vpfe_param.bus_width > 16) {\r\ndev_err(&pdev->dev, "Invalid bus width.\n");\r\ngoto done;\r\n}\r\nflags = bus_cfg.bus.parallel.flags;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\r\nsdinfo->vpfe_param.hdpol = 1;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\nsdinfo->vpfe_param.vdpol = 1;\r\nrem = of_graph_get_remote_port_parent(endpoint);\r\nif (!rem) {\r\ndev_err(&pdev->dev, "Remote device at %s not found\n",\r\nendpoint->full_name);\r\ngoto done;\r\n}\r\npdata->asd[i] = devm_kzalloc(&pdev->dev,\r\nsizeof(struct v4l2_async_subdev),\r\nGFP_KERNEL);\r\nif (!pdata->asd[i]) {\r\nof_node_put(rem);\r\npdata = NULL;\r\ngoto done;\r\n}\r\npdata->asd[i]->match_type = V4L2_ASYNC_MATCH_OF;\r\npdata->asd[i]->match.of.node = rem;\r\nof_node_put(rem);\r\n}\r\nof_node_put(endpoint);\r\nreturn pdata;\r\ndone:\r\nof_node_put(endpoint);\r\nreturn NULL;\r\n}\r\nstatic int vpfe_probe(struct platform_device *pdev)\r\n{\r\nstruct vpfe_config *vpfe_cfg = vpfe_get_pdata(pdev);\r\nstruct vpfe_device *vpfe;\r\nstruct vpfe_ccdc *ccdc;\r\nstruct resource *res;\r\nint ret;\r\nif (!vpfe_cfg) {\r\ndev_err(&pdev->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nvpfe = devm_kzalloc(&pdev->dev, sizeof(*vpfe), GFP_KERNEL);\r\nif (!vpfe)\r\nreturn -ENOMEM;\r\nvpfe->pdev = &pdev->dev;\r\nvpfe->cfg = vpfe_cfg;\r\nccdc = &vpfe->ccdc;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nccdc->ccdc_cfg.base_addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ccdc->ccdc_cfg.base_addr))\r\nreturn PTR_ERR(ccdc->ccdc_cfg.base_addr);\r\nret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nreturn -ENODEV;\r\n}\r\nvpfe->irq = ret;\r\nret = devm_request_irq(vpfe->pdev, vpfe->irq, vpfe_isr, 0,\r\n"vpfe_capture0", vpfe);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to request interrupt\n");\r\nreturn -EINVAL;\r\n}\r\nret = v4l2_device_register(&pdev->dev, &vpfe->v4l2_dev);\r\nif (ret) {\r\nvpfe_err(vpfe,\r\n"Unable to register v4l2 device.\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, vpfe);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nvpfe_ccdc_config_defaults(ccdc);\r\npm_runtime_put_sync(&pdev->dev);\r\nvpfe->sd = devm_kzalloc(&pdev->dev, sizeof(struct v4l2_subdev *) *\r\nARRAY_SIZE(vpfe->cfg->asd), GFP_KERNEL);\r\nif (!vpfe->sd) {\r\nret = -ENOMEM;\r\ngoto probe_out_v4l2_unregister;\r\n}\r\nvpfe->notifier.subdevs = vpfe->cfg->asd;\r\nvpfe->notifier.num_subdevs = ARRAY_SIZE(vpfe->cfg->asd);\r\nvpfe->notifier.bound = vpfe_async_bound;\r\nvpfe->notifier.complete = vpfe_async_complete;\r\nret = v4l2_async_notifier_register(&vpfe->v4l2_dev,\r\n&vpfe->notifier);\r\nif (ret) {\r\nvpfe_err(vpfe, "Error registering async notifier\n");\r\nret = -EINVAL;\r\ngoto probe_out_v4l2_unregister;\r\n}\r\nreturn 0;\r\nprobe_out_v4l2_unregister:\r\nv4l2_device_unregister(&vpfe->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int vpfe_remove(struct platform_device *pdev)\r\n{\r\nstruct vpfe_device *vpfe = platform_get_drvdata(pdev);\r\nvpfe_dbg(2, vpfe, "vpfe_remove\n");\r\npm_runtime_disable(&pdev->dev);\r\nv4l2_async_notifier_unregister(&vpfe->notifier);\r\nv4l2_device_unregister(&vpfe->v4l2_dev);\r\nvideo_unregister_device(&vpfe->video_dev);\r\nreturn 0;\r\n}\r\nstatic void vpfe_save_context(struct vpfe_ccdc *ccdc)\r\n{\r\nccdc->ccdc_ctx[VPFE_PCR >> 2] = vpfe_reg_read(ccdc, VPFE_PCR);\r\nccdc->ccdc_ctx[VPFE_SYNMODE >> 2] = vpfe_reg_read(ccdc, VPFE_SYNMODE);\r\nccdc->ccdc_ctx[VPFE_SDOFST >> 2] = vpfe_reg_read(ccdc, VPFE_SDOFST);\r\nccdc->ccdc_ctx[VPFE_SDR_ADDR >> 2] = vpfe_reg_read(ccdc, VPFE_SDR_ADDR);\r\nccdc->ccdc_ctx[VPFE_CLAMP >> 2] = vpfe_reg_read(ccdc, VPFE_CLAMP);\r\nccdc->ccdc_ctx[VPFE_DCSUB >> 2] = vpfe_reg_read(ccdc, VPFE_DCSUB);\r\nccdc->ccdc_ctx[VPFE_COLPTN >> 2] = vpfe_reg_read(ccdc, VPFE_COLPTN);\r\nccdc->ccdc_ctx[VPFE_BLKCMP >> 2] = vpfe_reg_read(ccdc, VPFE_BLKCMP);\r\nccdc->ccdc_ctx[VPFE_VDINT >> 2] = vpfe_reg_read(ccdc, VPFE_VDINT);\r\nccdc->ccdc_ctx[VPFE_ALAW >> 2] = vpfe_reg_read(ccdc, VPFE_ALAW);\r\nccdc->ccdc_ctx[VPFE_REC656IF >> 2] = vpfe_reg_read(ccdc, VPFE_REC656IF);\r\nccdc->ccdc_ctx[VPFE_CCDCFG >> 2] = vpfe_reg_read(ccdc, VPFE_CCDCFG);\r\nccdc->ccdc_ctx[VPFE_CULLING >> 2] = vpfe_reg_read(ccdc, VPFE_CULLING);\r\nccdc->ccdc_ctx[VPFE_HD_VD_WID >> 2] = vpfe_reg_read(ccdc,\r\nVPFE_HD_VD_WID);\r\nccdc->ccdc_ctx[VPFE_PIX_LINES >> 2] = vpfe_reg_read(ccdc,\r\nVPFE_PIX_LINES);\r\nccdc->ccdc_ctx[VPFE_HORZ_INFO >> 2] = vpfe_reg_read(ccdc,\r\nVPFE_HORZ_INFO);\r\nccdc->ccdc_ctx[VPFE_VERT_START >> 2] = vpfe_reg_read(ccdc,\r\nVPFE_VERT_START);\r\nccdc->ccdc_ctx[VPFE_VERT_LINES >> 2] = vpfe_reg_read(ccdc,\r\nVPFE_VERT_LINES);\r\nccdc->ccdc_ctx[VPFE_HSIZE_OFF >> 2] = vpfe_reg_read(ccdc,\r\nVPFE_HSIZE_OFF);\r\n}\r\nstatic int vpfe_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct vpfe_device *vpfe = platform_get_drvdata(pdev);\r\nstruct vpfe_ccdc *ccdc = &vpfe->ccdc;\r\nif (!vb2_start_streaming_called(&vpfe->buffer_queue))\r\nreturn 0;\r\npm_runtime_get_sync(dev);\r\nvpfe_config_enable(ccdc, 1);\r\nvpfe_save_context(ccdc);\r\nvpfe_pcr_enable(ccdc, 0);\r\nvpfe_config_enable(ccdc, 0);\r\npm_runtime_put_sync(dev);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic void vpfe_restore_context(struct vpfe_ccdc *ccdc)\r\n{\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_SYNMODE >> 2], VPFE_SYNMODE);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_CULLING >> 2], VPFE_CULLING);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_SDOFST >> 2], VPFE_SDOFST);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_SDR_ADDR >> 2], VPFE_SDR_ADDR);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_CLAMP >> 2], VPFE_CLAMP);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_DCSUB >> 2], VPFE_DCSUB);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_COLPTN >> 2], VPFE_COLPTN);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_BLKCMP >> 2], VPFE_BLKCMP);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_VDINT >> 2], VPFE_VDINT);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_ALAW >> 2], VPFE_ALAW);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_REC656IF >> 2], VPFE_REC656IF);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_CCDCFG >> 2], VPFE_CCDCFG);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_PCR >> 2], VPFE_PCR);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_HD_VD_WID >> 2],\r\nVPFE_HD_VD_WID);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_PIX_LINES >> 2],\r\nVPFE_PIX_LINES);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_HORZ_INFO >> 2],\r\nVPFE_HORZ_INFO);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_VERT_START >> 2],\r\nVPFE_VERT_START);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_VERT_LINES >> 2],\r\nVPFE_VERT_LINES);\r\nvpfe_reg_write(ccdc, ccdc->ccdc_ctx[VPFE_HSIZE_OFF >> 2],\r\nVPFE_HSIZE_OFF);\r\n}\r\nstatic int vpfe_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct vpfe_device *vpfe = platform_get_drvdata(pdev);\r\nstruct vpfe_ccdc *ccdc = &vpfe->ccdc;\r\nif (!vb2_start_streaming_called(&vpfe->buffer_queue))\r\nreturn 0;\r\npm_runtime_get_sync(dev);\r\nvpfe_config_enable(ccdc, 1);\r\nvpfe_restore_context(ccdc);\r\nvpfe_config_enable(ccdc, 0);\r\npm_runtime_put_sync(dev);\r\npinctrl_pm_select_default_state(dev);\r\nreturn 0;\r\n}
