unsigned long omap2xxx_clk_get_core_rate(void)\r\n{\r\nlong long core_clk;\r\nu32 v;\r\nWARN_ON(!dpll_core_ck);\r\ncore_clk = omap2_get_dpll_rate(dpll_core_ck);\r\nv = omap2xxx_cm_get_core_clk_src();\r\nif (v == CORE_CLK_SRC_32K)\r\ncore_clk = 32768;\r\nelse\r\ncore_clk *= v;\r\nreturn core_clk;\r\n}\r\nstatic long omap2_dpllcore_round_rate(unsigned long target_rate)\r\n{\r\nu32 high, low, core_clk_src;\r\ncore_clk_src = omap2xxx_cm_get_core_clk_src();\r\nif (core_clk_src == CORE_CLK_SRC_DPLL) {\r\nhigh = curr_prcm_set->dpll_speed * 2;\r\nlow = curr_prcm_set->dpll_speed;\r\n} else {\r\nhigh = curr_prcm_set->dpll_speed;\r\nlow = curr_prcm_set->dpll_speed / 2;\r\n}\r\n#ifdef DOWN_VARIABLE_DPLL\r\nif (target_rate > high)\r\nreturn high;\r\nelse\r\nreturn target_rate;\r\n#else\r\nif (target_rate > low)\r\nreturn high;\r\nelse\r\nreturn low;\r\n#endif\r\n}\r\nunsigned long omap2_dpllcore_recalc(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn omap2xxx_clk_get_core_rate();\r\n}\r\nint omap2_reprogram_dpllcore(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nu32 cur_rate, low, mult, div, valid_rate, done_rate;\r\nu32 bypass = 0;\r\nstruct prcm_config tmpset;\r\nconst struct dpll_data *dd;\r\ncur_rate = omap2xxx_clk_get_core_rate();\r\nmult = omap2xxx_cm_get_core_clk_src();\r\nif ((rate == (cur_rate / 2)) && (mult == 2)) {\r\nomap2xxx_sdrc_reprogram(CORE_CLK_SRC_DPLL, 1);\r\n} else if ((rate == (cur_rate * 2)) && (mult == 1)) {\r\nomap2xxx_sdrc_reprogram(CORE_CLK_SRC_DPLL_X2, 1);\r\n} else if (rate != cur_rate) {\r\nvalid_rate = omap2_dpllcore_round_rate(rate);\r\nif (valid_rate != rate)\r\nreturn -EINVAL;\r\nif (mult == 1)\r\nlow = curr_prcm_set->dpll_speed;\r\nelse\r\nlow = curr_prcm_set->dpll_speed / 2;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\ntmpset.cm_clksel1_pll = readl_relaxed(dd->mult_div1_reg);\r\ntmpset.cm_clksel1_pll &= ~(dd->mult_mask |\r\ndd->div1_mask);\r\ndiv = ((curr_prcm_set->xtal_speed / 1000000) - 1);\r\ntmpset.cm_clksel2_pll = omap2xxx_cm_get_core_pll_config();\r\ntmpset.cm_clksel2_pll &= ~OMAP24XX_CORE_CLK_SRC_MASK;\r\nif (rate > low) {\r\ntmpset.cm_clksel2_pll |= CORE_CLK_SRC_DPLL_X2;\r\nmult = ((rate / 2) / 1000000);\r\ndone_rate = CORE_CLK_SRC_DPLL_X2;\r\n} else {\r\ntmpset.cm_clksel2_pll |= CORE_CLK_SRC_DPLL;\r\nmult = (rate / 1000000);\r\ndone_rate = CORE_CLK_SRC_DPLL;\r\n}\r\ntmpset.cm_clksel1_pll |= (div << __ffs(dd->mult_mask));\r\ntmpset.cm_clksel1_pll |= (mult << __ffs(dd->div1_mask));\r\ntmpset.base_sdrc_rfr = SDRC_RFR_CTRL_BYPASS;\r\nif (rate == curr_prcm_set->xtal_speed)\r\nbypass = 1;\r\nomap2xxx_sdrc_reprogram(CORE_CLK_SRC_DPLL_X2, 1);\r\nomap2_set_prcm(tmpset.cm_clksel1_pll, tmpset.base_sdrc_rfr,\r\nbypass);\r\nomap2xxx_sdrc_init_params(omap2xxx_sdrc_dll_is_unlocked());\r\nomap2xxx_sdrc_reprogram(done_rate, 0);\r\n}\r\nreturn 0;\r\n}\r\nvoid omap2xxx_clkt_dpllcore_init(struct clk_hw *hw)\r\n{\r\nWARN(dpll_core_ck, "dpll_core_ck already set - should never happen");\r\ndpll_core_ck = to_clk_hw_omap(hw);\r\n}
