static int m48t35_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct m48t35_priv *priv = dev_get_drvdata(dev);\r\nu8 control;\r\nspin_lock_irq(&priv->lock);\r\ncontrol = readb(&priv->reg->control);\r\nwriteb(control | M48T35_RTC_READ, &priv->reg->control);\r\ntm->tm_sec = readb(&priv->reg->sec);\r\ntm->tm_min = readb(&priv->reg->min);\r\ntm->tm_hour = readb(&priv->reg->hour);\r\ntm->tm_mday = readb(&priv->reg->date);\r\ntm->tm_mon = readb(&priv->reg->month);\r\ntm->tm_year = readb(&priv->reg->year);\r\nwriteb(control, &priv->reg->control);\r\nspin_unlock_irq(&priv->lock);\r\ntm->tm_sec = bcd2bin(tm->tm_sec);\r\ntm->tm_min = bcd2bin(tm->tm_min);\r\ntm->tm_hour = bcd2bin(tm->tm_hour);\r\ntm->tm_mday = bcd2bin(tm->tm_mday);\r\ntm->tm_mon = bcd2bin(tm->tm_mon);\r\ntm->tm_year = bcd2bin(tm->tm_year);\r\ntm->tm_year += 70;\r\nif (tm->tm_year <= 69)\r\ntm->tm_year += 100;\r\ntm->tm_mon--;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int m48t35_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct m48t35_priv *priv = dev_get_drvdata(dev);\r\nunsigned char mon, day, hrs, min, sec;\r\nunsigned int yrs;\r\nu8 control;\r\nyrs = tm->tm_year + 1900;\r\nmon = tm->tm_mon + 1;\r\nday = tm->tm_mday;\r\nhrs = tm->tm_hour;\r\nmin = tm->tm_min;\r\nsec = tm->tm_sec;\r\nif (yrs < 1970)\r\nreturn -EINVAL;\r\nyrs -= 1970;\r\nif (yrs > 255)\r\nreturn -EINVAL;\r\nif (yrs > 169)\r\nreturn -EINVAL;\r\nif (yrs >= 100)\r\nyrs -= 100;\r\nsec = bin2bcd(sec);\r\nmin = bin2bcd(min);\r\nhrs = bin2bcd(hrs);\r\nday = bin2bcd(day);\r\nmon = bin2bcd(mon);\r\nyrs = bin2bcd(yrs);\r\nspin_lock_irq(&priv->lock);\r\ncontrol = readb(&priv->reg->control);\r\nwriteb(control | M48T35_RTC_SET, &priv->reg->control);\r\nwriteb(yrs, &priv->reg->year);\r\nwriteb(mon, &priv->reg->month);\r\nwriteb(day, &priv->reg->date);\r\nwriteb(hrs, &priv->reg->hour);\r\nwriteb(min, &priv->reg->min);\r\nwriteb(sec, &priv->reg->sec);\r\nwriteb(control, &priv->reg->control);\r\nspin_unlock_irq(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int m48t35_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct m48t35_priv *priv;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct m48t35_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->size = resource_size(res);\r\n#ifndef CONFIG_SGI_IP27\r\nif (!devm_request_mem_region(&pdev->dev, res->start, priv->size,\r\npdev->name))\r\nreturn -EBUSY;\r\n#endif\r\npriv->baseaddr = res->start;\r\npriv->reg = devm_ioremap(&pdev->dev, priv->baseaddr, priv->size);\r\nif (!priv->reg)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\nplatform_set_drvdata(pdev, priv);\r\npriv->rtc = devm_rtc_device_register(&pdev->dev, "m48t35",\r\n&m48t35_ops, THIS_MODULE);\r\nreturn PTR_ERR_OR_ZERO(priv->rtc);\r\n}
