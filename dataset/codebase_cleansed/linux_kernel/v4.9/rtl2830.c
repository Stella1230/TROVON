static int rtl2830_bulk_write(struct i2c_client *client, unsigned int reg,\r\nconst void *val, size_t val_count)\r\n{\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\ni2c_lock_adapter(client->adapter);\r\nret = regmap_bulk_write(dev->regmap, reg, val, val_count);\r\ni2c_unlock_adapter(client->adapter);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_update_bits(struct i2c_client *client, unsigned int reg,\r\nunsigned int mask, unsigned int val)\r\n{\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\ni2c_lock_adapter(client->adapter);\r\nret = regmap_update_bits(dev->regmap, reg, mask, val);\r\ni2c_unlock_adapter(client->adapter);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_bulk_read(struct i2c_client *client, unsigned int reg,\r\nvoid *val, size_t val_count)\r\n{\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\ni2c_lock_adapter(client->adapter);\r\nret = regmap_bulk_read(dev->regmap, reg, val, val_count);\r\ni2c_unlock_adapter(client->adapter);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_init(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\r\nint ret, i;\r\nstruct rtl2830_reg_val_mask tab[] = {\r\n{0x00d, 0x01, 0x03},\r\n{0x00d, 0x10, 0x10},\r\n{0x104, 0x00, 0x1e},\r\n{0x105, 0x80, 0x80},\r\n{0x110, 0x02, 0x03},\r\n{0x110, 0x08, 0x0c},\r\n{0x17b, 0x00, 0x40},\r\n{0x17d, 0x05, 0x0f},\r\n{0x17d, 0x50, 0xf0},\r\n{0x18c, 0x08, 0x0f},\r\n{0x18d, 0x00, 0xc0},\r\n{0x188, 0x05, 0x0f},\r\n{0x189, 0x00, 0xfc},\r\n{0x2d5, 0x02, 0x02},\r\n{0x2f1, 0x02, 0x06},\r\n{0x2f1, 0x20, 0xf8},\r\n{0x16d, 0x00, 0x01},\r\n{0x1a6, 0x00, 0x80},\r\n{0x106, dev->pdata->vtop, 0x3f},\r\n{0x107, dev->pdata->krf, 0x3f},\r\n{0x112, 0x28, 0xff},\r\n{0x103, dev->pdata->agc_targ_val, 0xff},\r\n{0x00a, 0x02, 0x07},\r\n{0x140, 0x0c, 0x3c},\r\n{0x140, 0x40, 0xc0},\r\n{0x15b, 0x05, 0x07},\r\n{0x15b, 0x28, 0x38},\r\n{0x15c, 0x05, 0x07},\r\n{0x15c, 0x28, 0x38},\r\n{0x115, dev->pdata->spec_inv, 0x01},\r\n{0x16f, 0x01, 0x07},\r\n{0x170, 0x18, 0x38},\r\n{0x172, 0x0f, 0x0f},\r\n{0x173, 0x08, 0x38},\r\n{0x175, 0x01, 0x07},\r\n{0x176, 0x00, 0xc0},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = rtl2830_update_bits(client, tab[i].reg, tab[i].mask,\r\ntab[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = rtl2830_bulk_write(client, 0x18f, "\x28\x00", 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_bulk_write(client, 0x195,\r\n"\x04\x06\x0a\x12\x0a\x12\x1e\x28", 8);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_update_bits(client, 0x101, 0x04, 0x04);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_update_bits(client, 0x101, 0x04, 0x00);\r\nif (ret)\r\ngoto err;\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\ndev->sleeping = false;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\ndev->sleeping = true;\r\ndev->fe_status = 0;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 500;\r\ns->step_size = fe->ops.info.frequency_stepsize * 2;\r\ns->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu64 num;\r\nu8 buf[3], u8tmp;\r\nu32 if_ctl, if_frequency;\r\nstatic const u8 bw_params1[3][34] = {\r\n{\r\n0x1f, 0xf0, 0x1f, 0xf0, 0x1f, 0xfa, 0x00, 0x17, 0x00, 0x41,\r\n0x00, 0x64, 0x00, 0x67, 0x00, 0x38, 0x1f, 0xde, 0x1f, 0x7a,\r\n0x1f, 0x47, 0x1f, 0x7c, 0x00, 0x30, 0x01, 0x4b, 0x02, 0x82,\r\n0x03, 0x73, 0x03, 0xcf,\r\n}, {\r\n0x1f, 0xfa, 0x1f, 0xda, 0x1f, 0xc1, 0x1f, 0xb3, 0x1f, 0xca,\r\n0x00, 0x07, 0x00, 0x4d, 0x00, 0x6d, 0x00, 0x40, 0x1f, 0xca,\r\n0x1f, 0x4d, 0x1f, 0x2a, 0x1f, 0xb2, 0x00, 0xec, 0x02, 0x7e,\r\n0x03, 0xd0, 0x04, 0x53,\r\n}, {\r\n0x00, 0x10, 0x00, 0x0e, 0x1f, 0xf7, 0x1f, 0xc9, 0x1f, 0xa0,\r\n0x1f, 0xa6, 0x1f, 0xec, 0x00, 0x4e, 0x00, 0x7d, 0x00, 0x3a,\r\n0x1f, 0x98, 0x1f, 0x10, 0x1f, 0x40, 0x00, 0x75, 0x02, 0x5f,\r\n0x04, 0x24, 0x04, 0xdb,\r\n},\r\n};\r\nstatic const u8 bw_params2[3][6] = {\r\n{0xc3, 0x0c, 0x44, 0x33, 0x33, 0x30},\r\n{0xb8, 0xe3, 0x93, 0x99, 0x99, 0x98},\r\n{0xae, 0xba, 0xf3, 0x26, 0x66, 0x64},\r\n};\r\ndev_dbg(&client->dev, "frequency=%u bandwidth_hz=%u inversion=%u\n",\r\nc->frequency, c->bandwidth_hz, c->inversion);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\ni = 0;\r\nbreak;\r\ncase 7000000:\r\ni = 1;\r\nbreak;\r\ncase 8000000:\r\ni = 2;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "invalid bandwidth_hz %u\n",\r\nc->bandwidth_hz);\r\nreturn -EINVAL;\r\n}\r\nret = rtl2830_update_bits(client, 0x008, 0x06, i << 1);\r\nif (ret)\r\ngoto err;\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nelse\r\nret = -EINVAL;\r\nif (ret)\r\ngoto err;\r\nnum = if_frequency % dev->pdata->clk;\r\nnum *= 0x400000;\r\nnum = div_u64(num, dev->pdata->clk);\r\nnum = -num;\r\nif_ctl = num & 0x3fffff;\r\ndev_dbg(&client->dev, "if_frequency=%d if_ctl=%08x\n",\r\nif_frequency, if_ctl);\r\nbuf[0] = (if_ctl >> 16) & 0x3f;\r\nbuf[1] = (if_ctl >> 8) & 0xff;\r\nbuf[2] = (if_ctl >> 0) & 0xff;\r\nret = rtl2830_bulk_read(client, 0x119, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\nbuf[0] |= u8tmp & 0xc0;\r\nret = rtl2830_bulk_write(client, 0x119, buf, 3);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_bulk_write(client, 0x11c, &bw_params1[i][0], 17);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_bulk_write(client, 0x12d, &bw_params1[i][17], 17);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_bulk_write(client, 0x19d, bw_params2[i], 6);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\nu8 buf[3];\r\nif (dev->sleeping)\r\nreturn 0;\r\nret = rtl2830_bulk_read(client, 0x33c, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2830_bulk_read(client, 0x351, &buf[2], 1);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "TPS=%*ph\n", 3, buf);\r\nswitch ((buf[0] >> 2) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 2) & 1) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\n}\r\nswitch ((buf[2] >> 0) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 4) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 3) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\r\nint ret, stmp;\r\nunsigned int utmp;\r\nu8 u8tmp, buf[2];\r\n*status = 0;\r\nif (dev->sleeping)\r\nreturn 0;\r\nret = rtl2830_bulk_read(client, 0x351, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\nu8tmp = (u8tmp >> 3) & 0x0f;\r\nif (u8tmp == 11) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n} else if (u8tmp == 10) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\n}\r\ndev->fe_status = *status;\r\nif (dev->fe_status & FE_HAS_SIGNAL) {\r\nret = rtl2830_bulk_read(client, 0x359, buf, 2);\r\nif (ret)\r\ngoto err;\r\nstmp = buf[0] << 8 | buf[1] << 0;\r\nstmp = sign_extend32(stmp, 13);\r\nutmp = clamp_val(-4 * stmp + 32767, 0x0000, 0xffff);\r\ndev_dbg(&client->dev, "IF AGC=%d\n", stmp);\r\nc->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\nc->strength.stat[0].uvalue = utmp;\r\n} else {\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_VITERBI) {\r\nunsigned int hierarchy, constellation;\r\n#define CONSTELLATION_NUM 3\r\n#define HIERARCHY_NUM 4\r\nstatic const u32 constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {\r\n{70705899, 70705899, 70705899, 70705899},\r\n{82433173, 82433173, 87483115, 94445660},\r\n{92888734, 92888734, 95487525, 99770748},\r\n};\r\nret = rtl2830_bulk_read(client, 0x33c, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\nconstellation = (u8tmp >> 2) & 0x03;\r\nif (constellation > CONSTELLATION_NUM - 1)\r\ngoto err;\r\nhierarchy = (u8tmp >> 4) & 0x07;\r\nif (hierarchy > HIERARCHY_NUM - 1)\r\ngoto err;\r\nret = rtl2830_bulk_read(client, 0x40c, buf, 2);\r\nif (ret)\r\ngoto err;\r\nutmp = buf[0] << 8 | buf[1] << 0;\r\nif (utmp)\r\nstmp = (constant[constellation][hierarchy] -\r\nintlog10(utmp)) / ((1 << 24) / 10000);\r\nelse\r\nstmp = 0;\r\ndev_dbg(&client->dev, "CNR raw=%u\n", utmp);\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = stmp;\r\n} else {\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_LOCK) {\r\nret = rtl2830_bulk_read(client, 0x34e, buf, 2);\r\nif (ret)\r\ngoto err;\r\nutmp = buf[0] << 8 | buf[1] << 0;\r\ndev->post_bit_error += utmp;\r\ndev->post_bit_count += 1000000;\r\ndev_dbg(&client->dev, "BER errors=%u total=1000000\n", utmp);\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\r\n} else {\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\r\n*snr = div_s64(c->cnr.stat[0].svalue, 100);\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\n*ber = (dev->post_bit_error - dev->post_bit_error_prev);\r\ndev->post_bit_error_prev = dev->post_bit_error;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->strength.stat[0].scale == FE_SCALE_RELATIVE)\r\n*strength = c->strength.stat[0].uvalue;\r\nelse\r\n*strength = 0;\r\nreturn 0;\r\n}\r\nstatic int rtl2830_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(&client->dev, "onoff=%d\n", onoff);\r\nif (onoff)\r\nu8tmp = 0x80;\r\nelse\r\nu8tmp = 0x00;\r\nret = rtl2830_update_bits(client, 0x061, 0x80, u8tmp);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid, int onoff)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\nu8 buf[4];\r\ndev_dbg(&client->dev, "index=%d pid=%04x onoff=%d\n",\r\nindex, pid, onoff);\r\nif (pid > 0x1fff || index > 32)\r\nreturn 0;\r\nif (onoff)\r\nset_bit(index, &dev->filters);\r\nelse\r\nclear_bit(index, &dev->filters);\r\nbuf[0] = (dev->filters >> 0) & 0xff;\r\nbuf[1] = (dev->filters >> 8) & 0xff;\r\nbuf[2] = (dev->filters >> 16) & 0xff;\r\nbuf[3] = (dev->filters >> 24) & 0xff;\r\nret = rtl2830_bulk_write(client, 0x062, buf, 4);\r\nif (ret)\r\ngoto err;\r\nbuf[0] = (pid >> 8) & 0xff;\r\nbuf[1] = (pid >> 0) & 0xff;\r\nret = rtl2830_bulk_write(client, 0x066 + 2 * index, buf, 2);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_select(struct i2c_mux_core *muxc, u32 chan_id)\r\n{\r\nstruct i2c_client *client = i2c_mux_priv(muxc);\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic struct dvb_frontend *rtl2830_get_dvb_frontend(struct i2c_client *client)\r\n{\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn &dev->fe;\r\n}\r\nstatic struct i2c_adapter *rtl2830_get_i2c_adapter(struct i2c_client *client)\r\n{\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn dev->muxc->adapter[0];\r\n}\r\nstatic int rtl2830_regmap_read(void *context, const void *reg_buf,\r\nsize_t reg_size, void *val_buf, size_t val_size)\r\n{\r\nstruct i2c_client *client = context;\r\nint ret;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = reg_size,\r\n.buf = (u8 *)reg_buf,\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = val_size,\r\n.buf = val_buf,\r\n}\r\n};\r\nret = __i2c_transfer(client->adapter, msg, 2);\r\nif (ret != 2) {\r\ndev_warn(&client->dev, "i2c reg read failed %d\n", ret);\r\nif (ret >= 0)\r\nret = -EREMOTEIO;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2830_regmap_write(void *context, const void *data, size_t count)\r\n{\r\nstruct i2c_client *client = context;\r\nint ret;\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = count,\r\n.buf = (u8 *)data,\r\n}\r\n};\r\nret = __i2c_transfer(client->adapter, msg, 1);\r\nif (ret != 1) {\r\ndev_warn(&client->dev, "i2c reg write failed %d\n", ret);\r\nif (ret >= 0)\r\nret = -EREMOTEIO;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2830_regmap_gather_write(void *context, const void *reg,\r\nsize_t reg_len, const void *val,\r\nsize_t val_len)\r\n{\r\nstruct i2c_client *client = context;\r\nint ret;\r\nu8 buf[256];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1 + val_len,\r\n.buf = buf,\r\n}\r\n};\r\nbuf[0] = *(u8 const *)reg;\r\nmemcpy(&buf[1], val, val_len);\r\nret = __i2c_transfer(client->adapter, msg, 1);\r\nif (ret != 1) {\r\ndev_warn(&client->dev, "i2c reg write failed %d\n", ret);\r\nif (ret >= 0)\r\nret = -EREMOTEIO;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2830_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rtl2830_platform_data *pdata = client->dev.platform_data;\r\nstruct rtl2830_dev *dev;\r\nint ret;\r\nu8 u8tmp;\r\nstatic const struct regmap_bus regmap_bus = {\r\n.read = rtl2830_regmap_read,\r\n.write = rtl2830_regmap_write,\r\n.gather_write = rtl2830_regmap_gather_write,\r\n.val_format_endian_default = REGMAP_ENDIAN_NATIVE,\r\n};\r\nstatic const struct regmap_range_cfg regmap_range_cfg[] = {\r\n{\r\n.selector_reg = 0x00,\r\n.selector_mask = 0xff,\r\n.selector_shift = 0,\r\n.window_start = 0,\r\n.window_len = 0x100,\r\n.range_min = 0 * 0x100,\r\n.range_max = 5 * 0x100,\r\n},\r\n};\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n.max_register = 5 * 0x100,\r\n.ranges = regmap_range_cfg,\r\n.num_ranges = ARRAY_SIZE(regmap_range_cfg),\r\n};\r\ndev_dbg(&client->dev, "\n");\r\nif (pdata == NULL) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ni2c_set_clientdata(client, dev);\r\ndev->client = client;\r\ndev->pdata = client->dev.platform_data;\r\ndev->sleeping = true;\r\ndev->regmap = regmap_init(&client->dev, &regmap_bus, client,\r\n&regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\nret = rtl2830_bulk_read(client, 0x000, &u8tmp, 1);\r\nif (ret)\r\ngoto err_regmap_exit;\r\ndev->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,\r\nrtl2830_select, NULL);\r\nif (!dev->muxc) {\r\nret = -ENOMEM;\r\ngoto err_regmap_exit;\r\n}\r\ndev->muxc->priv = client;\r\nret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nmemcpy(&dev->fe.ops, &rtl2830_ops, sizeof(dev->fe.ops));\r\ndev->fe.demodulator_priv = client;\r\npdata->get_dvb_frontend = rtl2830_get_dvb_frontend;\r\npdata->get_i2c_adapter = rtl2830_get_i2c_adapter;\r\npdata->pid_filter = rtl2830_pid_filter;\r\npdata->pid_filter_ctrl = rtl2830_pid_filter_ctrl;\r\ndev_info(&client->dev, "Realtek RTL2830 successfully attached\n");\r\nreturn 0;\r\nerr_regmap_exit:\r\nregmap_exit(dev->regmap);\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2830_remove(struct i2c_client *client)\r\n{\r\nstruct rtl2830_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\ni2c_mux_del_adapters(dev->muxc);\r\nregmap_exit(dev->regmap);\r\nkfree(dev);\r\nreturn 0;\r\n}
