static int recursive_loop(int remaining)\r\n{\r\nchar buf[REC_STACK_SIZE];\r\nmemset(buf, (remaining & 0xff) | 0x1, REC_STACK_SIZE);\r\nif (!remaining)\r\nreturn 0;\r\nelse\r\nreturn recursive_loop(remaining - 1);\r\n}\r\nvoid __init lkdtm_bugs_init(int *recur_param)\r\n{\r\nif (*recur_param < 0)\r\n*recur_param = recur_count;\r\nelse\r\nrecur_count = *recur_param;\r\n}\r\nvoid lkdtm_PANIC(void)\r\n{\r\npanic("dumptest");\r\n}\r\nvoid lkdtm_BUG(void)\r\n{\r\nBUG();\r\n}\r\nvoid lkdtm_WARNING(void)\r\n{\r\nWARN_ON(1);\r\n}\r\nvoid lkdtm_EXCEPTION(void)\r\n{\r\n*((int *) 0) = 0;\r\n}\r\nvoid lkdtm_LOOP(void)\r\n{\r\nfor (;;)\r\n;\r\n}\r\nvoid lkdtm_OVERFLOW(void)\r\n{\r\n(void) recursive_loop(recur_count);\r\n}\r\nnoinline void lkdtm_CORRUPT_STACK(void)\r\n{\r\nchar data[8];\r\nmemset((void *)data, 0, 64);\r\n}\r\nvoid lkdtm_UNALIGNED_LOAD_STORE_WRITE(void)\r\n{\r\nstatic u8 data[5] __attribute__((aligned(4))) = {1, 2, 3, 4, 5};\r\nu32 *p;\r\nu32 val = 0x12345678;\r\np = (u32 *)(data + 1);\r\nif (*p == 0)\r\nval = 0x87654321;\r\n*p = val;\r\n}\r\nvoid lkdtm_SOFTLOCKUP(void)\r\n{\r\npreempt_disable();\r\nfor (;;)\r\ncpu_relax();\r\n}\r\nvoid lkdtm_HARDLOCKUP(void)\r\n{\r\nlocal_irq_disable();\r\nfor (;;)\r\ncpu_relax();\r\n}\r\nvoid lkdtm_SPINLOCKUP(void)\r\n{\r\nspin_lock(&lock_me_up);\r\n__release(&lock_me_up);\r\n}\r\nvoid lkdtm_HUNG_TASK(void)\r\n{\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule();\r\n}\r\nvoid lkdtm_ATOMIC_UNDERFLOW(void)\r\n{\r\natomic_t under = ATOMIC_INIT(INT_MIN);\r\npr_info("attempting good atomic increment\n");\r\natomic_inc(&under);\r\natomic_dec(&under);\r\npr_info("attempting bad atomic underflow\n");\r\natomic_dec(&under);\r\n}\r\nvoid lkdtm_ATOMIC_OVERFLOW(void)\r\n{\r\natomic_t over = ATOMIC_INIT(INT_MAX);\r\npr_info("attempting good atomic decrement\n");\r\natomic_dec(&over);\r\natomic_inc(&over);\r\npr_info("attempting bad atomic overflow\n");\r\natomic_inc(&over);\r\n}
