static inline struct dsi_data *dsi_get_dsidrv_data(struct platform_device *dsidev)\r\n{\r\nreturn dev_get_drvdata(&dsidev->dev);\r\n}\r\nstatic inline struct platform_device *dsi_get_dsidev_from_dssdev(struct omap_dss_device *dssdev)\r\n{\r\nreturn to_platform_device(dssdev->dev);\r\n}\r\nstatic struct platform_device *dsi_get_dsidev_from_id(int module)\r\n{\r\nstruct omap_dss_device *out;\r\nenum omap_dss_output_id id;\r\nswitch (module) {\r\ncase 0:\r\nid = OMAP_DSS_OUTPUT_DSI1;\r\nbreak;\r\ncase 1:\r\nid = OMAP_DSS_OUTPUT_DSI2;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nout = omap_dss_get_output(id);\r\nreturn out ? to_platform_device(out->dev) : NULL;\r\n}\r\nstatic inline void dsi_write_reg(struct platform_device *dsidev,\r\nconst struct dsi_reg idx, u32 val)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nvoid __iomem *base;\r\nswitch(idx.module) {\r\ncase DSI_PROTO: base = dsi->proto_base; break;\r\ncase DSI_PHY: base = dsi->phy_base; break;\r\ncase DSI_PLL: base = dsi->pll_base; break;\r\ndefault: return;\r\n}\r\n__raw_writel(val, base + idx.idx);\r\n}\r\nstatic inline u32 dsi_read_reg(struct platform_device *dsidev,\r\nconst struct dsi_reg idx)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nvoid __iomem *base;\r\nswitch(idx.module) {\r\ncase DSI_PROTO: base = dsi->proto_base; break;\r\ncase DSI_PHY: base = dsi->phy_base; break;\r\ncase DSI_PLL: base = dsi->pll_base; break;\r\ndefault: return 0;\r\n}\r\nreturn __raw_readl(base + idx.idx);\r\n}\r\nstatic void dsi_bus_lock(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndown(&dsi->bus_lock);\r\n}\r\nstatic void dsi_bus_unlock(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nup(&dsi->bus_lock);\r\n}\r\nstatic bool dsi_bus_is_locked(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn dsi->bus_lock.count == 0;\r\n}\r\nstatic void dsi_completion_handler(void *data, u32 mask)\r\n{\r\ncomplete((struct completion *)data);\r\n}\r\nstatic inline int wait_for_bit_change(struct platform_device *dsidev,\r\nconst struct dsi_reg idx, int bitnum, int value)\r\n{\r\nunsigned long timeout;\r\nktime_t wait;\r\nint t;\r\nt = 100;\r\nwhile (t-- > 0) {\r\nif (REG_GET(dsidev, idx, bitnum, bitnum) == value)\r\nreturn value;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (time_before(jiffies, timeout)) {\r\nif (REG_GET(dsidev, idx, bitnum, bitnum) == value)\r\nreturn value;\r\nwait = ns_to_ktime(1000 * 1000);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\r\n}\r\nreturn !value;\r\n}\r\nu8 dsi_get_pixel_size(enum omap_dss_dsi_pixel_format fmt)\r\n{\r\nswitch (fmt) {\r\ncase OMAP_DSS_DSI_FMT_RGB888:\r\ncase OMAP_DSS_DSI_FMT_RGB666:\r\nreturn 24;\r\ncase OMAP_DSS_DSI_FMT_RGB666_PACKED:\r\nreturn 18;\r\ncase OMAP_DSS_DSI_FMT_RGB565:\r\nreturn 16;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic void dsi_perf_mark_setup(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi->perf_setup_time = ktime_get();\r\n}\r\nstatic void dsi_perf_mark_start(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi->perf_start_time = ktime_get();\r\n}\r\nstatic void dsi_perf_show(struct platform_device *dsidev, const char *name)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nktime_t t, setup_time, trans_time;\r\nu32 total_bytes;\r\nu32 setup_us, trans_us, total_us;\r\nif (!dsi_perf)\r\nreturn;\r\nt = ktime_get();\r\nsetup_time = ktime_sub(dsi->perf_start_time, dsi->perf_setup_time);\r\nsetup_us = (u32)ktime_to_us(setup_time);\r\nif (setup_us == 0)\r\nsetup_us = 1;\r\ntrans_time = ktime_sub(t, dsi->perf_start_time);\r\ntrans_us = (u32)ktime_to_us(trans_time);\r\nif (trans_us == 0)\r\ntrans_us = 1;\r\ntotal_us = setup_us + trans_us;\r\ntotal_bytes = dsi->update_bytes;\r\nprintk(KERN_INFO "DSI(%s): %u us + %u us = %u us (%uHz), "\r\n"%u bytes, %u kbytes/sec\n",\r\nname,\r\nsetup_us,\r\ntrans_us,\r\ntotal_us,\r\n1000*1000 / total_us,\r\ntotal_bytes,\r\ntotal_bytes * 1000 / total_us);\r\n}\r\nstatic inline void dsi_perf_mark_setup(struct platform_device *dsidev)\r\n{\r\n}\r\nstatic inline void dsi_perf_mark_start(struct platform_device *dsidev)\r\n{\r\n}\r\nstatic inline void dsi_perf_show(struct platform_device *dsidev,\r\nconst char *name)\r\n{\r\n}\r\nstatic void print_irq_status(u32 status)\r\n{\r\nif (status == 0)\r\nreturn;\r\nif (!verbose_irq && (status & ~DSI_IRQ_CHANNEL_MASK) == 0)\r\nreturn;\r\n#define PIS(x) (status & DSI_IRQ_##x) ? (#x " ") : ""\r\npr_debug("DSI IRQ: 0x%x: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",\r\nstatus,\r\nverbose_irq ? PIS(VC0) : "",\r\nverbose_irq ? PIS(VC1) : "",\r\nverbose_irq ? PIS(VC2) : "",\r\nverbose_irq ? PIS(VC3) : "",\r\nPIS(WAKEUP),\r\nPIS(RESYNC),\r\nPIS(PLL_LOCK),\r\nPIS(PLL_UNLOCK),\r\nPIS(PLL_RECALL),\r\nPIS(COMPLEXIO_ERR),\r\nPIS(HS_TX_TIMEOUT),\r\nPIS(LP_RX_TIMEOUT),\r\nPIS(TE_TRIGGER),\r\nPIS(ACK_TRIGGER),\r\nPIS(SYNC_LOST),\r\nPIS(LDO_POWER_GOOD),\r\nPIS(TA_TIMEOUT));\r\n#undef PIS\r\n}\r\nstatic void print_irq_status_vc(int channel, u32 status)\r\n{\r\nif (status == 0)\r\nreturn;\r\nif (!verbose_irq && (status & ~DSI_VC_IRQ_PACKET_SENT) == 0)\r\nreturn;\r\n#define PIS(x) (status & DSI_VC_IRQ_##x) ? (#x " ") : ""\r\npr_debug("DSI VC(%d) IRQ 0x%x: %s%s%s%s%s%s%s%s%s\n",\r\nchannel,\r\nstatus,\r\nPIS(CS),\r\nPIS(ECC_CORR),\r\nPIS(ECC_NO_CORR),\r\nverbose_irq ? PIS(PACKET_SENT) : "",\r\nPIS(BTA),\r\nPIS(FIFO_TX_OVF),\r\nPIS(FIFO_RX_OVF),\r\nPIS(FIFO_TX_UDF),\r\nPIS(PP_BUSY_CHANGE));\r\n#undef PIS\r\n}\r\nstatic void print_irq_status_cio(u32 status)\r\n{\r\nif (status == 0)\r\nreturn;\r\n#define PIS(x) (status & DSI_CIO_IRQ_##x) ? (#x " ") : ""\r\npr_debug("DSI CIO IRQ 0x%x: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",\r\nstatus,\r\nPIS(ERRSYNCESC1),\r\nPIS(ERRSYNCESC2),\r\nPIS(ERRSYNCESC3),\r\nPIS(ERRESC1),\r\nPIS(ERRESC2),\r\nPIS(ERRESC3),\r\nPIS(ERRCONTROL1),\r\nPIS(ERRCONTROL2),\r\nPIS(ERRCONTROL3),\r\nPIS(STATEULPS1),\r\nPIS(STATEULPS2),\r\nPIS(STATEULPS3),\r\nPIS(ERRCONTENTIONLP0_1),\r\nPIS(ERRCONTENTIONLP1_1),\r\nPIS(ERRCONTENTIONLP0_2),\r\nPIS(ERRCONTENTIONLP1_2),\r\nPIS(ERRCONTENTIONLP0_3),\r\nPIS(ERRCONTENTIONLP1_3),\r\nPIS(ULPSACTIVENOT_ALL0),\r\nPIS(ULPSACTIVENOT_ALL1));\r\n#undef PIS\r\n}\r\nstatic void dsi_collect_irq_stats(struct platform_device *dsidev, u32 irqstatus,\r\nu32 *vcstatus, u32 ciostatus)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nspin_lock(&dsi->irq_stats_lock);\r\ndsi->irq_stats.irq_count++;\r\ndss_collect_irq_stats(irqstatus, dsi->irq_stats.dsi_irqs);\r\nfor (i = 0; i < 4; ++i)\r\ndss_collect_irq_stats(vcstatus[i], dsi->irq_stats.vc_irqs[i]);\r\ndss_collect_irq_stats(ciostatus, dsi->irq_stats.cio_irqs);\r\nspin_unlock(&dsi->irq_stats_lock);\r\n}\r\nstatic void dsi_handle_irq_errors(struct platform_device *dsidev, u32 irqstatus,\r\nu32 *vcstatus, u32 ciostatus)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nif (irqstatus & DSI_IRQ_ERROR_MASK) {\r\nDSSERR("DSI error, irqstatus %x\n", irqstatus);\r\nprint_irq_status(irqstatus);\r\nspin_lock(&dsi->errors_lock);\r\ndsi->errors |= irqstatus & DSI_IRQ_ERROR_MASK;\r\nspin_unlock(&dsi->errors_lock);\r\n} else if (debug_irq) {\r\nprint_irq_status(irqstatus);\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nif (vcstatus[i] & DSI_VC_IRQ_ERROR_MASK) {\r\nDSSERR("DSI VC(%d) error, vc irqstatus %x\n",\r\ni, vcstatus[i]);\r\nprint_irq_status_vc(i, vcstatus[i]);\r\n} else if (debug_irq) {\r\nprint_irq_status_vc(i, vcstatus[i]);\r\n}\r\n}\r\nif (ciostatus & DSI_CIO_IRQ_ERROR_MASK) {\r\nDSSERR("DSI CIO error, cio irqstatus %x\n", ciostatus);\r\nprint_irq_status_cio(ciostatus);\r\n} else if (debug_irq) {\r\nprint_irq_status_cio(ciostatus);\r\n}\r\n}\r\nstatic void dsi_call_isrs(struct dsi_isr_data *isr_array,\r\nunsigned isr_array_size, u32 irqstatus)\r\n{\r\nstruct dsi_isr_data *isr_data;\r\nint i;\r\nfor (i = 0; i < isr_array_size; i++) {\r\nisr_data = &isr_array[i];\r\nif (isr_data->isr && isr_data->mask & irqstatus)\r\nisr_data->isr(isr_data->arg, irqstatus);\r\n}\r\n}\r\nstatic void dsi_handle_isrs(struct dsi_isr_tables *isr_tables,\r\nu32 irqstatus, u32 *vcstatus, u32 ciostatus)\r\n{\r\nint i;\r\ndsi_call_isrs(isr_tables->isr_table,\r\nARRAY_SIZE(isr_tables->isr_table),\r\nirqstatus);\r\nfor (i = 0; i < 4; ++i) {\r\nif (vcstatus[i] == 0)\r\ncontinue;\r\ndsi_call_isrs(isr_tables->isr_table_vc[i],\r\nARRAY_SIZE(isr_tables->isr_table_vc[i]),\r\nvcstatus[i]);\r\n}\r\nif (ciostatus != 0)\r\ndsi_call_isrs(isr_tables->isr_table_cio,\r\nARRAY_SIZE(isr_tables->isr_table_cio),\r\nciostatus);\r\n}\r\nstatic irqreturn_t omap_dsi_irq_handler(int irq, void *arg)\r\n{\r\nstruct platform_device *dsidev;\r\nstruct dsi_data *dsi;\r\nu32 irqstatus, vcstatus[4], ciostatus;\r\nint i;\r\ndsidev = (struct platform_device *) arg;\r\ndsi = dsi_get_dsidrv_data(dsidev);\r\nif (!dsi->is_enabled)\r\nreturn IRQ_NONE;\r\nspin_lock(&dsi->irq_lock);\r\nirqstatus = dsi_read_reg(dsidev, DSI_IRQSTATUS);\r\nif (!irqstatus) {\r\nspin_unlock(&dsi->irq_lock);\r\nreturn IRQ_NONE;\r\n}\r\ndsi_write_reg(dsidev, DSI_IRQSTATUS, irqstatus & ~DSI_IRQ_CHANNEL_MASK);\r\ndsi_read_reg(dsidev, DSI_IRQSTATUS);\r\nfor (i = 0; i < 4; ++i) {\r\nif ((irqstatus & (1 << i)) == 0) {\r\nvcstatus[i] = 0;\r\ncontinue;\r\n}\r\nvcstatus[i] = dsi_read_reg(dsidev, DSI_VC_IRQSTATUS(i));\r\ndsi_write_reg(dsidev, DSI_VC_IRQSTATUS(i), vcstatus[i]);\r\ndsi_read_reg(dsidev, DSI_VC_IRQSTATUS(i));\r\n}\r\nif (irqstatus & DSI_IRQ_COMPLEXIO_ERR) {\r\nciostatus = dsi_read_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS);\r\ndsi_write_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS, ciostatus);\r\ndsi_read_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS);\r\n} else {\r\nciostatus = 0;\r\n}\r\n#ifdef DSI_CATCH_MISSING_TE\r\nif (irqstatus & DSI_IRQ_TE_TRIGGER)\r\ndel_timer(&dsi->te_timer);\r\n#endif\r\nmemcpy(&dsi->isr_tables_copy, &dsi->isr_tables,\r\nsizeof(dsi->isr_tables));\r\nspin_unlock(&dsi->irq_lock);\r\ndsi_handle_isrs(&dsi->isr_tables_copy, irqstatus, vcstatus, ciostatus);\r\ndsi_handle_irq_errors(dsidev, irqstatus, vcstatus, ciostatus);\r\ndsi_collect_irq_stats(dsidev, irqstatus, vcstatus, ciostatus);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void _omap_dsi_configure_irqs(struct platform_device *dsidev,\r\nstruct dsi_isr_data *isr_array,\r\nunsigned isr_array_size, u32 default_mask,\r\nconst struct dsi_reg enable_reg,\r\nconst struct dsi_reg status_reg)\r\n{\r\nstruct dsi_isr_data *isr_data;\r\nu32 mask;\r\nu32 old_mask;\r\nint i;\r\nmask = default_mask;\r\nfor (i = 0; i < isr_array_size; i++) {\r\nisr_data = &isr_array[i];\r\nif (isr_data->isr == NULL)\r\ncontinue;\r\nmask |= isr_data->mask;\r\n}\r\nold_mask = dsi_read_reg(dsidev, enable_reg);\r\ndsi_write_reg(dsidev, status_reg, (mask ^ old_mask) & mask);\r\ndsi_write_reg(dsidev, enable_reg, mask);\r\ndsi_read_reg(dsidev, enable_reg);\r\ndsi_read_reg(dsidev, status_reg);\r\n}\r\nstatic void _omap_dsi_set_irqs(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 mask = DSI_IRQ_ERROR_MASK;\r\n#ifdef DSI_CATCH_MISSING_TE\r\nmask |= DSI_IRQ_TE_TRIGGER;\r\n#endif\r\n_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table,\r\nARRAY_SIZE(dsi->isr_tables.isr_table), mask,\r\nDSI_IRQENABLE, DSI_IRQSTATUS);\r\n}\r\nstatic void _omap_dsi_set_irqs_vc(struct platform_device *dsidev, int vc)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\n_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table_vc[vc],\r\nARRAY_SIZE(dsi->isr_tables.isr_table_vc[vc]),\r\nDSI_VC_IRQ_ERROR_MASK,\r\nDSI_VC_IRQENABLE(vc), DSI_VC_IRQSTATUS(vc));\r\n}\r\nstatic void _omap_dsi_set_irqs_cio(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\n_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table_cio,\r\nARRAY_SIZE(dsi->isr_tables.isr_table_cio),\r\nDSI_CIO_IRQ_ERROR_MASK,\r\nDSI_COMPLEXIO_IRQ_ENABLE, DSI_COMPLEXIO_IRQ_STATUS);\r\n}\r\nstatic void _dsi_initialize_irq(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint vc;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nmemset(&dsi->isr_tables, 0, sizeof(dsi->isr_tables));\r\n_omap_dsi_set_irqs(dsidev);\r\nfor (vc = 0; vc < 4; ++vc)\r\n_omap_dsi_set_irqs_vc(dsidev, vc);\r\n_omap_dsi_set_irqs_cio(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\n}\r\nstatic int _dsi_register_isr(omap_dsi_isr_t isr, void *arg, u32 mask,\r\nstruct dsi_isr_data *isr_array, unsigned isr_array_size)\r\n{\r\nstruct dsi_isr_data *isr_data;\r\nint free_idx;\r\nint i;\r\nBUG_ON(isr == NULL);\r\nfree_idx = -1;\r\nfor (i = 0; i < isr_array_size; i++) {\r\nisr_data = &isr_array[i];\r\nif (isr_data->isr == isr && isr_data->arg == arg &&\r\nisr_data->mask == mask) {\r\nreturn -EINVAL;\r\n}\r\nif (isr_data->isr == NULL && free_idx == -1)\r\nfree_idx = i;\r\n}\r\nif (free_idx == -1)\r\nreturn -EBUSY;\r\nisr_data = &isr_array[free_idx];\r\nisr_data->isr = isr;\r\nisr_data->arg = arg;\r\nisr_data->mask = mask;\r\nreturn 0;\r\n}\r\nstatic int _dsi_unregister_isr(omap_dsi_isr_t isr, void *arg, u32 mask,\r\nstruct dsi_isr_data *isr_array, unsigned isr_array_size)\r\n{\r\nstruct dsi_isr_data *isr_data;\r\nint i;\r\nfor (i = 0; i < isr_array_size; i++) {\r\nisr_data = &isr_array[i];\r\nif (isr_data->isr != isr || isr_data->arg != arg ||\r\nisr_data->mask != mask)\r\ncontinue;\r\nisr_data->isr = NULL;\r\nisr_data->arg = NULL;\r\nisr_data->mask = 0;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int dsi_register_isr(struct platform_device *dsidev, omap_dsi_isr_t isr,\r\nvoid *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_register_isr(isr, arg, mask, dsi->isr_tables.isr_table,\r\nARRAY_SIZE(dsi->isr_tables.isr_table));\r\nif (r == 0)\r\n_omap_dsi_set_irqs(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_unregister_isr(struct platform_device *dsidev,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_unregister_isr(isr, arg, mask, dsi->isr_tables.isr_table,\r\nARRAY_SIZE(dsi->isr_tables.isr_table));\r\nif (r == 0)\r\n_omap_dsi_set_irqs(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_register_isr_vc(struct platform_device *dsidev, int channel,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_register_isr(isr, arg, mask,\r\ndsi->isr_tables.isr_table_vc[channel],\r\nARRAY_SIZE(dsi->isr_tables.isr_table_vc[channel]));\r\nif (r == 0)\r\n_omap_dsi_set_irqs_vc(dsidev, channel);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_unregister_isr_vc(struct platform_device *dsidev, int channel,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_unregister_isr(isr, arg, mask,\r\ndsi->isr_tables.isr_table_vc[channel],\r\nARRAY_SIZE(dsi->isr_tables.isr_table_vc[channel]));\r\nif (r == 0)\r\n_omap_dsi_set_irqs_vc(dsidev, channel);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_register_isr_cio(struct platform_device *dsidev,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_register_isr(isr, arg, mask, dsi->isr_tables.isr_table_cio,\r\nARRAY_SIZE(dsi->isr_tables.isr_table_cio));\r\nif (r == 0)\r\n_omap_dsi_set_irqs_cio(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_unregister_isr_cio(struct platform_device *dsidev,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_unregister_isr(isr, arg, mask, dsi->isr_tables.isr_table_cio,\r\nARRAY_SIZE(dsi->isr_tables.isr_table_cio));\r\nif (r == 0)\r\n_omap_dsi_set_irqs_cio(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic u32 dsi_get_errors(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nu32 e;\r\nspin_lock_irqsave(&dsi->errors_lock, flags);\r\ne = dsi->errors;\r\ndsi->errors = 0;\r\nspin_unlock_irqrestore(&dsi->errors_lock, flags);\r\nreturn e;\r\n}\r\nstatic int dsi_runtime_get(struct platform_device *dsidev)\r\n{\r\nint r;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDSSDBG("dsi_runtime_get\n");\r\nr = pm_runtime_get_sync(&dsi->pdev->dev);\r\nWARN_ON(r < 0);\r\nreturn r < 0 ? r : 0;\r\n}\r\nstatic void dsi_runtime_put(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r;\r\nDSSDBG("dsi_runtime_put\n");\r\nr = pm_runtime_put_sync(&dsi->pdev->dev);\r\nWARN_ON(r < 0 && r != -ENOSYS);\r\n}\r\nstatic int dsi_regulator_init(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct regulator *vdds_dsi;\r\nif (dsi->vdds_dsi_reg != NULL)\r\nreturn 0;\r\nvdds_dsi = devm_regulator_get(&dsi->pdev->dev, "vdd");\r\nif (IS_ERR(vdds_dsi)) {\r\nif (PTR_ERR(vdds_dsi) != -EPROBE_DEFER)\r\nDSSERR("can't get DSI VDD regulator\n");\r\nreturn PTR_ERR(vdds_dsi);\r\n}\r\ndsi->vdds_dsi_reg = vdds_dsi;\r\nreturn 0;\r\n}\r\nstatic void _dsi_print_reset_status(struct platform_device *dsidev)\r\n{\r\nu32 l;\r\nint b0, b1, b2;\r\nl = dsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\r\nif (dss_has_feature(FEAT_DSI_REVERSE_TXCLKESC)) {\r\nb0 = 28;\r\nb1 = 27;\r\nb2 = 26;\r\n} else {\r\nb0 = 24;\r\nb1 = 25;\r\nb2 = 26;\r\n}\r\n#define DSI_FLD_GET(fld, start, end)\\r\nFLD_GET(dsi_read_reg(dsidev, DSI_##fld), start, end)\r\npr_debug("DSI resets: PLL (%d) CIO (%d) PHY (%x%x%x, %d, %d, %d)\n",\r\nDSI_FLD_GET(PLL_STATUS, 0, 0),\r\nDSI_FLD_GET(COMPLEXIO_CFG1, 29, 29),\r\nDSI_FLD_GET(DSIPHY_CFG5, b0, b0),\r\nDSI_FLD_GET(DSIPHY_CFG5, b1, b1),\r\nDSI_FLD_GET(DSIPHY_CFG5, b2, b2),\r\nDSI_FLD_GET(DSIPHY_CFG5, 29, 29),\r\nDSI_FLD_GET(DSIPHY_CFG5, 30, 30),\r\nDSI_FLD_GET(DSIPHY_CFG5, 31, 31));\r\n#undef DSI_FLD_GET\r\n}\r\nstatic inline int dsi_if_enable(struct platform_device *dsidev, bool enable)\r\n{\r\nDSSDBG("dsi_if_enable(%d)\n", enable);\r\nenable = enable ? 1 : 0;\r\nREG_FLD_MOD(dsidev, DSI_CTRL, enable, 0, 0);\r\nif (wait_for_bit_change(dsidev, DSI_CTRL, 0, enable) != enable) {\r\nDSSERR("Failed to set dsi_if_enable to %d\n", enable);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long dsi_get_pll_hsdiv_dispc_rate(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn dsi->pll.cinfo.clkout[HSDIV_DISPC];\r\n}\r\nstatic unsigned long dsi_get_pll_hsdiv_dsi_rate(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn dsi->pll.cinfo.clkout[HSDIV_DSI];\r\n}\r\nstatic unsigned long dsi_get_txbyteclkhs(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn dsi->pll.cinfo.clkdco / 16;\r\n}\r\nstatic unsigned long dsi_fclk_rate(struct platform_device *dsidev)\r\n{\r\nunsigned long r;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dss_get_dsi_clk_source(dsi->module_id) == DSS_CLK_SRC_FCK) {\r\nr = clk_get_rate(dsi->dss_clk);\r\n} else {\r\nr = dsi_get_pll_hsdiv_dsi_rate(dsidev);\r\n}\r\nreturn r;\r\n}\r\nstatic int dsi_lp_clock_calc(unsigned long dsi_fclk,\r\nunsigned long lp_clk_min, unsigned long lp_clk_max,\r\nstruct dsi_lp_clock_info *lp_cinfo)\r\n{\r\nunsigned lp_clk_div;\r\nunsigned long lp_clk;\r\nlp_clk_div = DIV_ROUND_UP(dsi_fclk, lp_clk_max * 2);\r\nlp_clk = dsi_fclk / 2 / lp_clk_div;\r\nif (lp_clk < lp_clk_min || lp_clk > lp_clk_max)\r\nreturn -EINVAL;\r\nlp_cinfo->lp_clk_div = lp_clk_div;\r\nlp_cinfo->lp_clk = lp_clk;\r\nreturn 0;\r\n}\r\nstatic int dsi_set_lp_clk_divisor(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long dsi_fclk;\r\nunsigned lp_clk_div;\r\nunsigned long lp_clk;\r\nunsigned lpdiv_max = dss_feat_get_param_max(FEAT_PARAM_DSIPLL_LPDIV);\r\nlp_clk_div = dsi->user_lp_cinfo.lp_clk_div;\r\nif (lp_clk_div == 0 || lp_clk_div > lpdiv_max)\r\nreturn -EINVAL;\r\ndsi_fclk = dsi_fclk_rate(dsidev);\r\nlp_clk = dsi_fclk / 2 / lp_clk_div;\r\nDSSDBG("LP_CLK_DIV %u, LP_CLK %lu\n", lp_clk_div, lp_clk);\r\ndsi->current_lp_cinfo.lp_clk = lp_clk;\r\ndsi->current_lp_cinfo.lp_clk_div = lp_clk_div;\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, lp_clk_div, 12, 0);\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, dsi_fclk > 30000000 ? 1 : 0, 21, 21);\r\nreturn 0;\r\n}\r\nstatic void dsi_enable_scp_clk(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dsi->scp_clk_refcount++ == 0)\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 1, 14, 14);\r\n}\r\nstatic void dsi_disable_scp_clk(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nWARN_ON(dsi->scp_clk_refcount == 0);\r\nif (--dsi->scp_clk_refcount == 0)\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 14, 14);\r\n}\r\nstatic int dsi_pll_power(struct platform_device *dsidev,\r\nenum dsi_pll_power_state state)\r\n{\r\nint t = 0;\r\nif (dss_has_feature(FEAT_DSI_PLL_PWR_BUG) &&\r\nstate == DSI_PLL_POWER_ON_DIV)\r\nstate = DSI_PLL_POWER_ON_ALL;\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, state, 31, 30);\r\nwhile (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {\r\nif (++t > 1000) {\r\nDSSERR("Failed to set DSI PLL power mode to %d\n",\r\nstate);\r\nreturn -ENODEV;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dsi_pll_calc_dsi_fck(struct dss_pll_clock_info *cinfo)\r\n{\r\nunsigned long max_dsi_fck;\r\nmax_dsi_fck = dss_feat_get_param_max(FEAT_PARAM_DSI_FCK);\r\ncinfo->mX[HSDIV_DSI] = DIV_ROUND_UP(cinfo->clkdco, max_dsi_fck);\r\ncinfo->clkout[HSDIV_DSI] = cinfo->clkdco / cinfo->mX[HSDIV_DSI];\r\n}\r\nstatic int dsi_pll_enable(struct dss_pll *pll)\r\n{\r\nstruct dsi_data *dsi = container_of(pll, struct dsi_data, pll);\r\nstruct platform_device *dsidev = dsi->pdev;\r\nint r = 0;\r\nDSSDBG("PLL init\n");\r\nr = dsi_regulator_init(dsidev);\r\nif (r)\r\nreturn r;\r\nr = dsi_runtime_get(dsidev);\r\nif (r)\r\nreturn r;\r\ndsi_enable_scp_clk(dsidev);\r\nif (!dsi->vdds_dsi_enabled) {\r\nr = regulator_enable(dsi->vdds_dsi_reg);\r\nif (r)\r\ngoto err0;\r\ndsi->vdds_dsi_enabled = true;\r\n}\r\ndispc_pck_free_enable(1);\r\nif (wait_for_bit_change(dsidev, DSI_PLL_STATUS, 0, 1) != 1) {\r\nDSSERR("PLL not coming out of reset.\n");\r\nr = -ENODEV;\r\ndispc_pck_free_enable(0);\r\ngoto err1;\r\n}\r\ndispc_pck_free_enable(0);\r\nr = dsi_pll_power(dsidev, DSI_PLL_POWER_ON_ALL);\r\nif (r)\r\ngoto err1;\r\nDSSDBG("PLL init done\n");\r\nreturn 0;\r\nerr1:\r\nif (dsi->vdds_dsi_enabled) {\r\nregulator_disable(dsi->vdds_dsi_reg);\r\ndsi->vdds_dsi_enabled = false;\r\n}\r\nerr0:\r\ndsi_disable_scp_clk(dsidev);\r\ndsi_runtime_put(dsidev);\r\nreturn r;\r\n}\r\nstatic void dsi_pll_uninit(struct platform_device *dsidev, bool disconnect_lanes)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi_pll_power(dsidev, DSI_PLL_POWER_OFF);\r\nif (disconnect_lanes) {\r\nWARN_ON(!dsi->vdds_dsi_enabled);\r\nregulator_disable(dsi->vdds_dsi_reg);\r\ndsi->vdds_dsi_enabled = false;\r\n}\r\ndsi_disable_scp_clk(dsidev);\r\ndsi_runtime_put(dsidev);\r\nDSSDBG("PLL uninit done\n");\r\n}\r\nstatic void dsi_pll_disable(struct dss_pll *pll)\r\n{\r\nstruct dsi_data *dsi = container_of(pll, struct dsi_data, pll);\r\nstruct platform_device *dsidev = dsi->pdev;\r\ndsi_pll_uninit(dsidev, true);\r\n}\r\nstatic void dsi_dump_dsidev_clocks(struct platform_device *dsidev,\r\nstruct seq_file *s)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dss_pll_clock_info *cinfo = &dsi->pll.cinfo;\r\nenum dss_clk_source dispc_clk_src, dsi_clk_src;\r\nint dsi_module = dsi->module_id;\r\nstruct dss_pll *pll = &dsi->pll;\r\ndispc_clk_src = dss_get_dispc_clk_source();\r\ndsi_clk_src = dss_get_dsi_clk_source(dsi_module);\r\nif (dsi_runtime_get(dsidev))\r\nreturn;\r\nseq_printf(s, "- DSI%d PLL -\n", dsi_module + 1);\r\nseq_printf(s, "dsi pll clkin\t%lu\n", clk_get_rate(pll->clkin));\r\nseq_printf(s, "Fint\t\t%-16lun %u\n", cinfo->fint, cinfo->n);\r\nseq_printf(s, "CLKIN4DDR\t%-16lum %u\n",\r\ncinfo->clkdco, cinfo->m);\r\nseq_printf(s, "DSI_PLL_HSDIV_DISPC (%s)\t%-16lum_dispc %u\t(%s)\n",\r\ndss_get_clk_source_name(dsi_module == 0 ?\r\nDSS_CLK_SRC_PLL1_1 :\r\nDSS_CLK_SRC_PLL2_1),\r\ncinfo->clkout[HSDIV_DISPC],\r\ncinfo->mX[HSDIV_DISPC],\r\ndispc_clk_src == DSS_CLK_SRC_FCK ?\r\n"off" : "on");\r\nseq_printf(s, "DSI_PLL_HSDIV_DSI (%s)\t%-16lum_dsi %u\t(%s)\n",\r\ndss_get_clk_source_name(dsi_module == 0 ?\r\nDSS_CLK_SRC_PLL1_2 :\r\nDSS_CLK_SRC_PLL2_2),\r\ncinfo->clkout[HSDIV_DSI],\r\ncinfo->mX[HSDIV_DSI],\r\ndsi_clk_src == DSS_CLK_SRC_FCK ?\r\n"off" : "on");\r\nseq_printf(s, "- DSI%d -\n", dsi_module + 1);\r\nseq_printf(s, "dsi fclk source = %s\n",\r\ndss_get_clk_source_name(dsi_clk_src));\r\nseq_printf(s, "DSI_FCLK\t%lu\n", dsi_fclk_rate(dsidev));\r\nseq_printf(s, "DDR_CLK\t\t%lu\n",\r\ncinfo->clkdco / 4);\r\nseq_printf(s, "TxByteClkHS\t%lu\n", dsi_get_txbyteclkhs(dsidev));\r\nseq_printf(s, "LP_CLK\t\t%lu\n", dsi->current_lp_cinfo.lp_clk);\r\ndsi_runtime_put(dsidev);\r\n}\r\nvoid dsi_dump_clocks(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev;\r\nint i;\r\nfor (i = 0; i < MAX_NUM_DSI; i++) {\r\ndsidev = dsi_get_dsidev_from_id(i);\r\nif (dsidev)\r\ndsi_dump_dsidev_clocks(dsidev, s);\r\n}\r\n}\r\nstatic void dsi_dump_dsidev_irqs(struct platform_device *dsidev,\r\nstruct seq_file *s)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nstruct dsi_irq_stats stats;\r\nspin_lock_irqsave(&dsi->irq_stats_lock, flags);\r\nstats = dsi->irq_stats;\r\nmemset(&dsi->irq_stats, 0, sizeof(dsi->irq_stats));\r\ndsi->irq_stats.last_reset = jiffies;\r\nspin_unlock_irqrestore(&dsi->irq_stats_lock, flags);\r\nseq_printf(s, "period %u ms\n",\r\njiffies_to_msecs(jiffies - stats.last_reset));\r\nseq_printf(s, "irqs %d\n", stats.irq_count);\r\n#define PIS(x) \\r\nseq_printf(s, "%-20s %10d\n", #x, stats.dsi_irqs[ffs(DSI_IRQ_##x)-1]);\r\nseq_printf(s, "-- DSI%d interrupts --\n", dsi->module_id + 1);\r\nPIS(VC0);\r\nPIS(VC1);\r\nPIS(VC2);\r\nPIS(VC3);\r\nPIS(WAKEUP);\r\nPIS(RESYNC);\r\nPIS(PLL_LOCK);\r\nPIS(PLL_UNLOCK);\r\nPIS(PLL_RECALL);\r\nPIS(COMPLEXIO_ERR);\r\nPIS(HS_TX_TIMEOUT);\r\nPIS(LP_RX_TIMEOUT);\r\nPIS(TE_TRIGGER);\r\nPIS(ACK_TRIGGER);\r\nPIS(SYNC_LOST);\r\nPIS(LDO_POWER_GOOD);\r\nPIS(TA_TIMEOUT);\r\n#undef PIS\r\n#define PIS(x) \\r\nseq_printf(s, "%-20s %10d %10d %10d %10d\n", #x, \\r\nstats.vc_irqs[0][ffs(DSI_VC_IRQ_##x)-1], \\r\nstats.vc_irqs[1][ffs(DSI_VC_IRQ_##x)-1], \\r\nstats.vc_irqs[2][ffs(DSI_VC_IRQ_##x)-1], \\r\nstats.vc_irqs[3][ffs(DSI_VC_IRQ_##x)-1]);\r\nseq_printf(s, "-- VC interrupts --\n");\r\nPIS(CS);\r\nPIS(ECC_CORR);\r\nPIS(PACKET_SENT);\r\nPIS(FIFO_TX_OVF);\r\nPIS(FIFO_RX_OVF);\r\nPIS(BTA);\r\nPIS(ECC_NO_CORR);\r\nPIS(FIFO_TX_UDF);\r\nPIS(PP_BUSY_CHANGE);\r\n#undef PIS\r\n#define PIS(x) \\r\nseq_printf(s, "%-20s %10d\n", #x, \\r\nstats.cio_irqs[ffs(DSI_CIO_IRQ_##x)-1]);\r\nseq_printf(s, "-- CIO interrupts --\n");\r\nPIS(ERRSYNCESC1);\r\nPIS(ERRSYNCESC2);\r\nPIS(ERRSYNCESC3);\r\nPIS(ERRESC1);\r\nPIS(ERRESC2);\r\nPIS(ERRESC3);\r\nPIS(ERRCONTROL1);\r\nPIS(ERRCONTROL2);\r\nPIS(ERRCONTROL3);\r\nPIS(STATEULPS1);\r\nPIS(STATEULPS2);\r\nPIS(STATEULPS3);\r\nPIS(ERRCONTENTIONLP0_1);\r\nPIS(ERRCONTENTIONLP1_1);\r\nPIS(ERRCONTENTIONLP0_2);\r\nPIS(ERRCONTENTIONLP1_2);\r\nPIS(ERRCONTENTIONLP0_3);\r\nPIS(ERRCONTENTIONLP1_3);\r\nPIS(ULPSACTIVENOT_ALL0);\r\nPIS(ULPSACTIVENOT_ALL1);\r\n#undef PIS\r\n}\r\nstatic void dsi1_dump_irqs(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_id(0);\r\ndsi_dump_dsidev_irqs(dsidev, s);\r\n}\r\nstatic void dsi2_dump_irqs(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_id(1);\r\ndsi_dump_dsidev_irqs(dsidev, s);\r\n}\r\nstatic void dsi_dump_dsidev_regs(struct platform_device *dsidev,\r\nstruct seq_file *s)\r\n{\r\n#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, dsi_read_reg(dsidev, r))\r\nif (dsi_runtime_get(dsidev))\r\nreturn;\r\ndsi_enable_scp_clk(dsidev);\r\nDUMPREG(DSI_REVISION);\r\nDUMPREG(DSI_SYSCONFIG);\r\nDUMPREG(DSI_SYSSTATUS);\r\nDUMPREG(DSI_IRQSTATUS);\r\nDUMPREG(DSI_IRQENABLE);\r\nDUMPREG(DSI_CTRL);\r\nDUMPREG(DSI_COMPLEXIO_CFG1);\r\nDUMPREG(DSI_COMPLEXIO_IRQ_STATUS);\r\nDUMPREG(DSI_COMPLEXIO_IRQ_ENABLE);\r\nDUMPREG(DSI_CLK_CTRL);\r\nDUMPREG(DSI_TIMING1);\r\nDUMPREG(DSI_TIMING2);\r\nDUMPREG(DSI_VM_TIMING1);\r\nDUMPREG(DSI_VM_TIMING2);\r\nDUMPREG(DSI_VM_TIMING3);\r\nDUMPREG(DSI_CLK_TIMING);\r\nDUMPREG(DSI_TX_FIFO_VC_SIZE);\r\nDUMPREG(DSI_RX_FIFO_VC_SIZE);\r\nDUMPREG(DSI_COMPLEXIO_CFG2);\r\nDUMPREG(DSI_RX_FIFO_VC_FULLNESS);\r\nDUMPREG(DSI_VM_TIMING4);\r\nDUMPREG(DSI_TX_FIFO_VC_EMPTINESS);\r\nDUMPREG(DSI_VM_TIMING5);\r\nDUMPREG(DSI_VM_TIMING6);\r\nDUMPREG(DSI_VM_TIMING7);\r\nDUMPREG(DSI_STOPCLK_TIMING);\r\nDUMPREG(DSI_VC_CTRL(0));\r\nDUMPREG(DSI_VC_TE(0));\r\nDUMPREG(DSI_VC_LONG_PACKET_HEADER(0));\r\nDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(0));\r\nDUMPREG(DSI_VC_SHORT_PACKET_HEADER(0));\r\nDUMPREG(DSI_VC_IRQSTATUS(0));\r\nDUMPREG(DSI_VC_IRQENABLE(0));\r\nDUMPREG(DSI_VC_CTRL(1));\r\nDUMPREG(DSI_VC_TE(1));\r\nDUMPREG(DSI_VC_LONG_PACKET_HEADER(1));\r\nDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(1));\r\nDUMPREG(DSI_VC_SHORT_PACKET_HEADER(1));\r\nDUMPREG(DSI_VC_IRQSTATUS(1));\r\nDUMPREG(DSI_VC_IRQENABLE(1));\r\nDUMPREG(DSI_VC_CTRL(2));\r\nDUMPREG(DSI_VC_TE(2));\r\nDUMPREG(DSI_VC_LONG_PACKET_HEADER(2));\r\nDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(2));\r\nDUMPREG(DSI_VC_SHORT_PACKET_HEADER(2));\r\nDUMPREG(DSI_VC_IRQSTATUS(2));\r\nDUMPREG(DSI_VC_IRQENABLE(2));\r\nDUMPREG(DSI_VC_CTRL(3));\r\nDUMPREG(DSI_VC_TE(3));\r\nDUMPREG(DSI_VC_LONG_PACKET_HEADER(3));\r\nDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(3));\r\nDUMPREG(DSI_VC_SHORT_PACKET_HEADER(3));\r\nDUMPREG(DSI_VC_IRQSTATUS(3));\r\nDUMPREG(DSI_VC_IRQENABLE(3));\r\nDUMPREG(DSI_DSIPHY_CFG0);\r\nDUMPREG(DSI_DSIPHY_CFG1);\r\nDUMPREG(DSI_DSIPHY_CFG2);\r\nDUMPREG(DSI_DSIPHY_CFG5);\r\nDUMPREG(DSI_PLL_CONTROL);\r\nDUMPREG(DSI_PLL_STATUS);\r\nDUMPREG(DSI_PLL_GO);\r\nDUMPREG(DSI_PLL_CONFIGURATION1);\r\nDUMPREG(DSI_PLL_CONFIGURATION2);\r\ndsi_disable_scp_clk(dsidev);\r\ndsi_runtime_put(dsidev);\r\n#undef DUMPREG\r\n}\r\nstatic void dsi1_dump_regs(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_id(0);\r\ndsi_dump_dsidev_regs(dsidev, s);\r\n}\r\nstatic void dsi2_dump_regs(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_id(1);\r\ndsi_dump_dsidev_regs(dsidev, s);\r\n}\r\nstatic int dsi_cio_power(struct platform_device *dsidev,\r\nenum dsi_cio_power_state state)\r\n{\r\nint t = 0;\r\nREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG1, state, 28, 27);\r\nwhile (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),\r\n26, 25) != state) {\r\nif (++t > 1000) {\r\nDSSERR("failed to set complexio power state to "\r\n"%d\n", state);\r\nreturn -ENODEV;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned dsi_get_line_buf_size(struct platform_device *dsidev)\r\n{\r\nint val;\r\nif (!dss_has_feature(FEAT_DSI_GNQ))\r\nreturn 1023 * 3;\r\nval = REG_GET(dsidev, DSI_GNQ, 14, 12);\r\nswitch (val) {\r\ncase 1:\r\nreturn 512 * 3;\r\ncase 2:\r\nreturn 682 * 3;\r\ncase 3:\r\nreturn 853 * 3;\r\ncase 4:\r\nreturn 1024 * 3;\r\ncase 5:\r\nreturn 1194 * 3;\r\ncase 6:\r\nreturn 1365 * 3;\r\ncase 7:\r\nreturn 1920 * 3;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic int dsi_set_lane_config(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstatic const u8 offsets[] = { 0, 4, 8, 12, 16 };\r\nstatic const enum dsi_lane_function functions[] = {\r\nDSI_LANE_CLK,\r\nDSI_LANE_DATA1,\r\nDSI_LANE_DATA2,\r\nDSI_LANE_DATA3,\r\nDSI_LANE_DATA4,\r\n};\r\nu32 r;\r\nint i;\r\nr = dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1);\r\nfor (i = 0; i < dsi->num_lanes_used; ++i) {\r\nunsigned offset = offsets[i];\r\nunsigned polarity, lane_number;\r\nunsigned t;\r\nfor (t = 0; t < dsi->num_lanes_supported; ++t)\r\nif (dsi->lanes[t].function == functions[i])\r\nbreak;\r\nif (t == dsi->num_lanes_supported)\r\nreturn -EINVAL;\r\nlane_number = t;\r\npolarity = dsi->lanes[t].polarity;\r\nr = FLD_MOD(r, lane_number + 1, offset + 2, offset);\r\nr = FLD_MOD(r, polarity, offset + 3, offset + 3);\r\n}\r\nfor (; i < dsi->num_lanes_supported; ++i) {\r\nunsigned offset = offsets[i];\r\nr = FLD_MOD(r, 0, offset + 2, offset);\r\nr = FLD_MOD(r, 0, offset + 3, offset + 3);\r\n}\r\ndsi_write_reg(dsidev, DSI_COMPLEXIO_CFG1, r);\r\nreturn 0;\r\n}\r\nstatic inline unsigned ns2ddr(struct platform_device *dsidev, unsigned ns)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long ddr_clk = dsi->pll.cinfo.clkdco / 4;\r\nreturn (ns * (ddr_clk / 1000 / 1000) + 999) / 1000;\r\n}\r\nstatic inline unsigned ddr2ns(struct platform_device *dsidev, unsigned ddr)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long ddr_clk = dsi->pll.cinfo.clkdco / 4;\r\nreturn ddr * 1000 * 1000 / (ddr_clk / 1000);\r\n}\r\nstatic void dsi_cio_timings(struct platform_device *dsidev)\r\n{\r\nu32 r;\r\nu32 ths_prepare, ths_prepare_ths_zero, ths_trail, ths_exit;\r\nu32 tlpx_half, tclk_trail, tclk_zero;\r\nu32 tclk_prepare;\r\nths_prepare = ns2ddr(dsidev, 70) + 2;\r\nths_prepare_ths_zero = ns2ddr(dsidev, 175) + 2;\r\nths_trail = ns2ddr(dsidev, 60) + 5;\r\nths_exit = ns2ddr(dsidev, 145);\r\ntlpx_half = ns2ddr(dsidev, 25);\r\ntclk_trail = ns2ddr(dsidev, 60) + 2;\r\ntclk_prepare = ns2ddr(dsidev, 65);\r\ntclk_zero = ns2ddr(dsidev, 260);\r\nDSSDBG("ths_prepare %u (%uns), ths_prepare_ths_zero %u (%uns)\n",\r\nths_prepare, ddr2ns(dsidev, ths_prepare),\r\nths_prepare_ths_zero, ddr2ns(dsidev, ths_prepare_ths_zero));\r\nDSSDBG("ths_trail %u (%uns), ths_exit %u (%uns)\n",\r\nths_trail, ddr2ns(dsidev, ths_trail),\r\nths_exit, ddr2ns(dsidev, ths_exit));\r\nDSSDBG("tlpx_half %u (%uns), tclk_trail %u (%uns), "\r\n"tclk_zero %u (%uns)\n",\r\ntlpx_half, ddr2ns(dsidev, tlpx_half),\r\ntclk_trail, ddr2ns(dsidev, tclk_trail),\r\ntclk_zero, ddr2ns(dsidev, tclk_zero));\r\nDSSDBG("tclk_prepare %u (%uns)\n",\r\ntclk_prepare, ddr2ns(dsidev, tclk_prepare));\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\r\nr = FLD_MOD(r, ths_prepare, 31, 24);\r\nr = FLD_MOD(r, ths_prepare_ths_zero, 23, 16);\r\nr = FLD_MOD(r, ths_trail, 15, 8);\r\nr = FLD_MOD(r, ths_exit, 7, 0);\r\ndsi_write_reg(dsidev, DSI_DSIPHY_CFG0, r);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\r\nr = FLD_MOD(r, tlpx_half, 20, 16);\r\nr = FLD_MOD(r, tclk_trail, 15, 8);\r\nr = FLD_MOD(r, tclk_zero, 7, 0);\r\nif (dss_has_feature(FEAT_DSI_PHY_DCC)) {\r\nr = FLD_MOD(r, 0, 21, 21);\r\nr = FLD_MOD(r, 1, 22, 22);\r\nr = FLD_MOD(r, 1, 23, 23);\r\n}\r\ndsi_write_reg(dsidev, DSI_DSIPHY_CFG1, r);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG2);\r\nr = FLD_MOD(r, tclk_prepare, 7, 0);\r\ndsi_write_reg(dsidev, DSI_DSIPHY_CFG2, r);\r\n}\r\nstatic void dsi_cio_enable_lane_override(struct platform_device *dsidev,\r\nunsigned mask_p, unsigned mask_n)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nu32 l;\r\nu8 lptxscp_start = dsi->num_lanes_supported == 3 ? 22 : 26;\r\nl = 0;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nunsigned p = dsi->lanes[i].polarity;\r\nif (mask_p & (1 << i))\r\nl |= 1 << (i * 2 + (p ? 0 : 1));\r\nif (mask_n & (1 << i))\r\nl |= 1 << (i * 2 + (p ? 1 : 0));\r\n}\r\nREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, l, lptxscp_start, 17);\r\nREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 1, 27, 27);\r\n}\r\nstatic void dsi_cio_disable_lane_override(struct platform_device *dsidev)\r\n{\r\nREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 0, 27, 27);\r\nREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 0, 22, 17);\r\n}\r\nstatic int dsi_cio_wait_tx_clk_esc_reset(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint t, i;\r\nbool in_use[DSI_MAX_NR_LANES];\r\nstatic const u8 offsets_old[] = { 28, 27, 26 };\r\nstatic const u8 offsets_new[] = { 24, 25, 26, 27, 28 };\r\nconst u8 *offsets;\r\nif (dss_has_feature(FEAT_DSI_REVERSE_TXCLKESC))\r\noffsets = offsets_old;\r\nelse\r\noffsets = offsets_new;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i)\r\nin_use[i] = dsi->lanes[i].function != DSI_LANE_UNUSED;\r\nt = 100000;\r\nwhile (true) {\r\nu32 l;\r\nint ok;\r\nl = dsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\r\nok = 0;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (!in_use[i] || (l & (1 << offsets[i])))\r\nok++;\r\n}\r\nif (ok == dsi->num_lanes_supported)\r\nbreak;\r\nif (--t == 0) {\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (!in_use[i] || (l & (1 << offsets[i])))\r\ncontinue;\r\nDSSERR("CIO TXCLKESC%d domain not coming " \\r\n"out of reset\n", i);\r\n}\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned dsi_get_lane_mask(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned mask = 0;\r\nint i;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (dsi->lanes[i].function != DSI_LANE_UNUSED)\r\nmask |= 1 << i;\r\n}\r\nreturn mask;\r\n}\r\nstatic int dsi_cio_init(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r;\r\nu32 l;\r\nDSSDBG("DSI CIO init starts");\r\nr = dss_dsi_enable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\r\nif (r)\r\nreturn r;\r\ndsi_enable_scp_clk(dsidev);\r\ndsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\r\nif (wait_for_bit_change(dsidev, DSI_DSIPHY_CFG5, 30, 1) != 1) {\r\nDSSERR("CIO SCP Clock domain not coming out of reset.\n");\r\nr = -EIO;\r\ngoto err_scp_clk_dom;\r\n}\r\nr = dsi_set_lane_config(dsidev);\r\nif (r)\r\ngoto err_scp_clk_dom;\r\nl = dsi_read_reg(dsidev, DSI_TIMING1);\r\nl = FLD_MOD(l, 1, 15, 15);\r\nl = FLD_MOD(l, 1, 14, 14);\r\nl = FLD_MOD(l, 1, 13, 13);\r\nl = FLD_MOD(l, 0x1fff, 12, 0);\r\ndsi_write_reg(dsidev, DSI_TIMING1, l);\r\nif (dsi->ulps_enabled) {\r\nunsigned mask_p;\r\nint i;\r\nDSSDBG("manual ulps exit\n");\r\nmask_p = 0;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (dsi->lanes[i].function == DSI_LANE_UNUSED)\r\ncontinue;\r\nmask_p |= 1 << i;\r\n}\r\ndsi_cio_enable_lane_override(dsidev, mask_p, 0);\r\n}\r\nr = dsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_ON);\r\nif (r)\r\ngoto err_cio_pwr;\r\nif (wait_for_bit_change(dsidev, DSI_COMPLEXIO_CFG1, 29, 1) != 1) {\r\nDSSERR("CIO PWR clock domain not coming out of reset.\n");\r\nr = -ENODEV;\r\ngoto err_cio_pwr_dom;\r\n}\r\ndsi_if_enable(dsidev, true);\r\ndsi_if_enable(dsidev, false);\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 1, 20, 20);\r\nr = dsi_cio_wait_tx_clk_esc_reset(dsidev);\r\nif (r)\r\ngoto err_tx_clk_esc_rst;\r\nif (dsi->ulps_enabled) {\r\nktime_t wait = ns_to_ktime(1000 * 1000);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\r\ndsi_cio_disable_lane_override(dsidev);\r\n}\r\nREG_FLD_MOD(dsidev, DSI_TIMING1, 0, 15, 15);\r\ndsi_cio_timings(dsidev);\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL,\r\ndsi->vm_timings.ddr_clk_always_on, 13, 13);\r\n}\r\ndsi->ulps_enabled = false;\r\nDSSDBG("CIO init done\n");\r\nreturn 0;\r\nerr_tx_clk_esc_rst:\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 20, 20);\r\nerr_cio_pwr_dom:\r\ndsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_OFF);\r\nerr_cio_pwr:\r\nif (dsi->ulps_enabled)\r\ndsi_cio_disable_lane_override(dsidev);\r\nerr_scp_clk_dom:\r\ndsi_disable_scp_clk(dsidev);\r\ndss_dsi_disable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\r\nreturn r;\r\n}\r\nstatic void dsi_cio_uninit(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 13, 13);\r\ndsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_OFF);\r\ndsi_disable_scp_clk(dsidev);\r\ndss_dsi_disable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\r\n}\r\nstatic void dsi_config_tx_fifo(struct platform_device *dsidev,\r\nenum fifo_size size1, enum fifo_size size2,\r\nenum fifo_size size3, enum fifo_size size4)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r = 0;\r\nint add = 0;\r\nint i;\r\ndsi->vc[0].tx_fifo_size = size1;\r\ndsi->vc[1].tx_fifo_size = size2;\r\ndsi->vc[2].tx_fifo_size = size3;\r\ndsi->vc[3].tx_fifo_size = size4;\r\nfor (i = 0; i < 4; i++) {\r\nu8 v;\r\nint size = dsi->vc[i].tx_fifo_size;\r\nif (add + size > 4) {\r\nDSSERR("Illegal FIFO configuration\n");\r\nBUG();\r\nreturn;\r\n}\r\nv = FLD_VAL(add, 2, 0) | FLD_VAL(size, 7, 4);\r\nr |= v << (8 * i);\r\nadd += size;\r\n}\r\ndsi_write_reg(dsidev, DSI_TX_FIFO_VC_SIZE, r);\r\n}\r\nstatic void dsi_config_rx_fifo(struct platform_device *dsidev,\r\nenum fifo_size size1, enum fifo_size size2,\r\nenum fifo_size size3, enum fifo_size size4)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r = 0;\r\nint add = 0;\r\nint i;\r\ndsi->vc[0].rx_fifo_size = size1;\r\ndsi->vc[1].rx_fifo_size = size2;\r\ndsi->vc[2].rx_fifo_size = size3;\r\ndsi->vc[3].rx_fifo_size = size4;\r\nfor (i = 0; i < 4; i++) {\r\nu8 v;\r\nint size = dsi->vc[i].rx_fifo_size;\r\nif (add + size > 4) {\r\nDSSERR("Illegal FIFO configuration\n");\r\nBUG();\r\nreturn;\r\n}\r\nv = FLD_VAL(add, 2, 0) | FLD_VAL(size, 7, 4);\r\nr |= v << (8 * i);\r\nadd += size;\r\n}\r\ndsi_write_reg(dsidev, DSI_RX_FIFO_VC_SIZE, r);\r\n}\r\nstatic int dsi_force_tx_stop_mode_io(struct platform_device *dsidev)\r\n{\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_TIMING1);\r\nr = FLD_MOD(r, 1, 15, 15);\r\ndsi_write_reg(dsidev, DSI_TIMING1, r);\r\nif (wait_for_bit_change(dsidev, DSI_TIMING1, 15, 0) != 0) {\r\nDSSERR("TX_STOP bit not going down\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool dsi_vc_is_enabled(struct platform_device *dsidev, int channel)\r\n{\r\nreturn REG_GET(dsidev, DSI_VC_CTRL(channel), 0, 0);\r\n}\r\nstatic void dsi_packet_sent_handler_vp(void *data, u32 mask)\r\n{\r\nstruct dsi_packet_sent_handler_data *vp_data =\r\n(struct dsi_packet_sent_handler_data *) data;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(vp_data->dsidev);\r\nconst int channel = dsi->update_channel;\r\nu8 bit = dsi->te_enabled ? 30 : 31;\r\nif (REG_GET(vp_data->dsidev, DSI_VC_TE(channel), bit, bit) == 0)\r\ncomplete(vp_data->completion);\r\n}\r\nstatic int dsi_sync_vc_vp(struct platform_device *dsidev, int channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct dsi_packet_sent_handler_data vp_data = {\r\n.dsidev = dsidev,\r\n.completion = &completion\r\n};\r\nint r = 0;\r\nu8 bit;\r\nbit = dsi->te_enabled ? 30 : 31;\r\nr = dsi_register_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\r\n&vp_data, DSI_VC_IRQ_PACKET_SENT);\r\nif (r)\r\ngoto err0;\r\nif (REG_GET(dsidev, DSI_VC_TE(channel), bit, bit)) {\r\nif (wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(10)) == 0) {\r\nDSSERR("Failed to complete previous frame transfer\n");\r\nr = -EIO;\r\ngoto err1;\r\n}\r\n}\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\r\n&vp_data, DSI_VC_IRQ_PACKET_SENT);\r\nreturn 0;\r\nerr1:\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\r\n&vp_data, DSI_VC_IRQ_PACKET_SENT);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic void dsi_packet_sent_handler_l4(void *data, u32 mask)\r\n{\r\nstruct dsi_packet_sent_handler_data *l4_data =\r\n(struct dsi_packet_sent_handler_data *) data;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(l4_data->dsidev);\r\nconst int channel = dsi->update_channel;\r\nif (REG_GET(l4_data->dsidev, DSI_VC_CTRL(channel), 5, 5) == 0)\r\ncomplete(l4_data->completion);\r\n}\r\nstatic int dsi_sync_vc_l4(struct platform_device *dsidev, int channel)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct dsi_packet_sent_handler_data l4_data = {\r\n.dsidev = dsidev,\r\n.completion = &completion\r\n};\r\nint r = 0;\r\nr = dsi_register_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\r\n&l4_data, DSI_VC_IRQ_PACKET_SENT);\r\nif (r)\r\ngoto err0;\r\nif (REG_GET(dsidev, DSI_VC_CTRL(channel), 5, 5)) {\r\nif (wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(10)) == 0) {\r\nDSSERR("Failed to complete previous l4 transfer\n");\r\nr = -EIO;\r\ngoto err1;\r\n}\r\n}\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\r\n&l4_data, DSI_VC_IRQ_PACKET_SENT);\r\nreturn 0;\r\nerr1:\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\r\n&l4_data, DSI_VC_IRQ_PACKET_SENT);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic int dsi_sync_vc(struct platform_device *dsidev, int channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nWARN_ON(in_interrupt());\r\nif (!dsi_vc_is_enabled(dsidev, channel))\r\nreturn 0;\r\nswitch (dsi->vc[channel].source) {\r\ncase DSI_VC_SOURCE_VP:\r\nreturn dsi_sync_vc_vp(dsidev, channel);\r\ncase DSI_VC_SOURCE_L4:\r\nreturn dsi_sync_vc_l4(dsidev, channel);\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int dsi_vc_enable(struct platform_device *dsidev, int channel,\r\nbool enable)\r\n{\r\nDSSDBG("dsi_vc_enable channel %d, enable %d\n",\r\nchannel, enable);\r\nenable = enable ? 1 : 0;\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 0, 0);\r\nif (wait_for_bit_change(dsidev, DSI_VC_CTRL(channel),\r\n0, enable) != enable) {\r\nDSSERR("Failed to set dsi_vc_enable to %d\n", enable);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dsi_vc_initial_config(struct platform_device *dsidev, int channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r;\r\nDSSDBG("Initial config of virtual channel %d", channel);\r\nr = dsi_read_reg(dsidev, DSI_VC_CTRL(channel));\r\nif (FLD_GET(r, 15, 15))\r\nDSSERR("VC(%d) busy when trying to configure it!\n",\r\nchannel);\r\nr = FLD_MOD(r, 0, 1, 1);\r\nr = FLD_MOD(r, 0, 2, 2);\r\nr = FLD_MOD(r, 0, 3, 3);\r\nr = FLD_MOD(r, 0, 4, 4);\r\nr = FLD_MOD(r, 1, 7, 7);\r\nr = FLD_MOD(r, 1, 8, 8);\r\nr = FLD_MOD(r, 0, 9, 9);\r\nif (dss_has_feature(FEAT_DSI_VC_OCP_WIDTH))\r\nr = FLD_MOD(r, 3, 11, 10);\r\nr = FLD_MOD(r, 4, 29, 27);\r\nr = FLD_MOD(r, 4, 23, 21);\r\ndsi_write_reg(dsidev, DSI_VC_CTRL(channel), r);\r\ndsi->vc[channel].source = DSI_VC_SOURCE_L4;\r\n}\r\nstatic int dsi_vc_config_source(struct platform_device *dsidev, int channel,\r\nenum dsi_vc_source source)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dsi->vc[channel].source == source)\r\nreturn 0;\r\nDSSDBG("Source config of virtual channel %d", channel);\r\ndsi_sync_vc(dsidev, channel);\r\ndsi_vc_enable(dsidev, channel, 0);\r\nif (wait_for_bit_change(dsidev, DSI_VC_CTRL(channel), 15, 0) != 0) {\r\nDSSERR("vc(%d) busy when trying to config for VP\n", channel);\r\nreturn -EIO;\r\n}\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), source, 1, 1);\r\nif (dss_has_feature(FEAT_DSI_DCS_CMD_CONFIG_VC)) {\r\nbool enable = source == DSI_VC_SOURCE_VP;\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 30, 30);\r\n}\r\ndsi_vc_enable(dsidev, channel, 1);\r\ndsi->vc[channel].source = source;\r\nreturn 0;\r\n}\r\nstatic void dsi_vc_enable_hs(struct omap_dss_device *dssdev, int channel,\r\nbool enable)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDSSDBG("dsi_vc_enable_hs(%d, %d)\n", channel, enable);\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\ndsi_vc_enable(dsidev, channel, 0);\r\ndsi_if_enable(dsidev, 0);\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 9, 9);\r\ndsi_vc_enable(dsidev, channel, 1);\r\ndsi_if_enable(dsidev, 1);\r\ndsi_force_tx_stop_mode_io(dsidev);\r\nif (dsi->vm_timings.ddr_clk_always_on && enable)\r\ndsi_vc_send_null(dssdev, channel);\r\n}\r\nstatic void dsi_vc_flush_long_data(struct platform_device *dsidev, int channel)\r\n{\r\nwhile (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\r\nu32 val;\r\nval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\r\nDSSDBG("\t\tb1 %#02x b2 %#02x b3 %#02x b4 %#02x\n",\r\n(val >> 0) & 0xff,\r\n(val >> 8) & 0xff,\r\n(val >> 16) & 0xff,\r\n(val >> 24) & 0xff);\r\n}\r\n}\r\nstatic void dsi_show_rx_ack_with_err(u16 err)\r\n{\r\nDSSERR("\tACK with ERROR (%#x):\n", err);\r\nif (err & (1 << 0))\r\nDSSERR("\t\tSoT Error\n");\r\nif (err & (1 << 1))\r\nDSSERR("\t\tSoT Sync Error\n");\r\nif (err & (1 << 2))\r\nDSSERR("\t\tEoT Sync Error\n");\r\nif (err & (1 << 3))\r\nDSSERR("\t\tEscape Mode Entry Command Error\n");\r\nif (err & (1 << 4))\r\nDSSERR("\t\tLP Transmit Sync Error\n");\r\nif (err & (1 << 5))\r\nDSSERR("\t\tHS Receive Timeout Error\n");\r\nif (err & (1 << 6))\r\nDSSERR("\t\tFalse Control Error\n");\r\nif (err & (1 << 7))\r\nDSSERR("\t\t(reserved7)\n");\r\nif (err & (1 << 8))\r\nDSSERR("\t\tECC Error, single-bit (corrected)\n");\r\nif (err & (1 << 9))\r\nDSSERR("\t\tECC Error, multi-bit (not corrected)\n");\r\nif (err & (1 << 10))\r\nDSSERR("\t\tChecksum Error\n");\r\nif (err & (1 << 11))\r\nDSSERR("\t\tData type not recognized\n");\r\nif (err & (1 << 12))\r\nDSSERR("\t\tInvalid VC ID\n");\r\nif (err & (1 << 13))\r\nDSSERR("\t\tInvalid Transmission Length\n");\r\nif (err & (1 << 14))\r\nDSSERR("\t\t(reserved14)\n");\r\nif (err & (1 << 15))\r\nDSSERR("\t\tDSI Protocol Violation\n");\r\n}\r\nstatic u16 dsi_vc_flush_receive_data(struct platform_device *dsidev,\r\nint channel)\r\n{\r\nwhile (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\r\nu32 val;\r\nu8 dt;\r\nval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\r\nDSSERR("\trawval %#08x\n", val);\r\ndt = FLD_GET(val, 5, 0);\r\nif (dt == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT) {\r\nu16 err = FLD_GET(val, 23, 8);\r\ndsi_show_rx_ack_with_err(err);\r\n} else if (dt == MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE) {\r\nDSSERR("\tDCS short response, 1 byte: %#x\n",\r\nFLD_GET(val, 23, 8));\r\n} else if (dt == MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE) {\r\nDSSERR("\tDCS short response, 2 byte: %#x\n",\r\nFLD_GET(val, 23, 8));\r\n} else if (dt == MIPI_DSI_RX_DCS_LONG_READ_RESPONSE) {\r\nDSSERR("\tDCS long response, len %d\n",\r\nFLD_GET(val, 23, 8));\r\ndsi_vc_flush_long_data(dsidev, channel);\r\n} else {\r\nDSSERR("\tunknown datatype 0x%02x\n", dt);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_send_bta(struct platform_device *dsidev, int channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dsi->debug_write || dsi->debug_read)\r\nDSSDBG("dsi_vc_send_bta %d\n", channel);\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\r\nDSSERR("rx fifo not empty when sending BTA, dumping data:\n");\r\ndsi_vc_flush_receive_data(dsidev, channel);\r\n}\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 1, 6, 6);\r\ndsi_read_reg(dsidev, DSI_VC_CTRL(channel));\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_send_bta_sync(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nint r = 0;\r\nu32 err;\r\nr = dsi_register_isr_vc(dsidev, channel, dsi_completion_handler,\r\n&completion, DSI_VC_IRQ_BTA);\r\nif (r)\r\ngoto err0;\r\nr = dsi_register_isr(dsidev, dsi_completion_handler, &completion,\r\nDSI_IRQ_ERROR_MASK);\r\nif (r)\r\ngoto err1;\r\nr = dsi_vc_send_bta(dsidev, channel);\r\nif (r)\r\ngoto err2;\r\nif (wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(500)) == 0) {\r\nDSSERR("Failed to receive BTA\n");\r\nr = -EIO;\r\ngoto err2;\r\n}\r\nerr = dsi_get_errors(dsidev);\r\nif (err) {\r\nDSSERR("Error while sending BTA: %x\n", err);\r\nr = -EIO;\r\ngoto err2;\r\n}\r\nerr2:\r\ndsi_unregister_isr(dsidev, dsi_completion_handler, &completion,\r\nDSI_IRQ_ERROR_MASK);\r\nerr1:\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_completion_handler,\r\n&completion, DSI_VC_IRQ_BTA);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic inline void dsi_vc_write_long_header(struct platform_device *dsidev,\r\nint channel, u8 data_type, u16 len, u8 ecc)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 val;\r\nu8 data_id;\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\ndata_id = data_type | dsi->vc[channel].vc_id << 6;\r\nval = FLD_VAL(data_id, 7, 0) | FLD_VAL(len, 23, 8) |\r\nFLD_VAL(ecc, 31, 24);\r\ndsi_write_reg(dsidev, DSI_VC_LONG_PACKET_HEADER(channel), val);\r\n}\r\nstatic inline void dsi_vc_write_long_payload(struct platform_device *dsidev,\r\nint channel, u8 b1, u8 b2, u8 b3, u8 b4)\r\n{\r\nu32 val;\r\nval = b4 << 24 | b3 << 16 | b2 << 8 | b1 << 0;\r\ndsi_write_reg(dsidev, DSI_VC_LONG_PACKET_PAYLOAD(channel), val);\r\n}\r\nstatic int dsi_vc_send_long(struct platform_device *dsidev, int channel,\r\nu8 data_type, u8 *data, u16 len, u8 ecc)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nu8 *p;\r\nint r = 0;\r\nu8 b1, b2, b3, b4;\r\nif (dsi->debug_write)\r\nDSSDBG("dsi_vc_send_long, %d bytes\n", len);\r\nif (dsi->vc[channel].tx_fifo_size * 32 * 4 < len + 4) {\r\nDSSERR("unable to send long packet: packet too long.\n");\r\nreturn -EINVAL;\r\n}\r\ndsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_L4);\r\ndsi_vc_write_long_header(dsidev, channel, data_type, len, ecc);\r\np = data;\r\nfor (i = 0; i < len >> 2; i++) {\r\nif (dsi->debug_write)\r\nDSSDBG("\tsending full packet %d\n", i);\r\nb1 = *p++;\r\nb2 = *p++;\r\nb3 = *p++;\r\nb4 = *p++;\r\ndsi_vc_write_long_payload(dsidev, channel, b1, b2, b3, b4);\r\n}\r\ni = len % 4;\r\nif (i) {\r\nb1 = 0; b2 = 0; b3 = 0;\r\nif (dsi->debug_write)\r\nDSSDBG("\tsending remainder bytes %d\n", i);\r\nswitch (i) {\r\ncase 3:\r\nb1 = *p++;\r\nb2 = *p++;\r\nb3 = *p++;\r\nbreak;\r\ncase 2:\r\nb1 = *p++;\r\nb2 = *p++;\r\nbreak;\r\ncase 1:\r\nb1 = *p++;\r\nbreak;\r\n}\r\ndsi_vc_write_long_payload(dsidev, channel, b1, b2, b3, 0);\r\n}\r\nreturn r;\r\n}\r\nstatic int dsi_vc_send_short(struct platform_device *dsidev, int channel,\r\nu8 data_type, u16 data, u8 ecc)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r;\r\nu8 data_id;\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nif (dsi->debug_write)\r\nDSSDBG("dsi_vc_send_short(ch%d, dt %#x, b1 %#x, b2 %#x)\n",\r\nchannel,\r\ndata_type, data & 0xff, (data >> 8) & 0xff);\r\ndsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_L4);\r\nif (FLD_GET(dsi_read_reg(dsidev, DSI_VC_CTRL(channel)), 16, 16)) {\r\nDSSERR("ERROR FIFO FULL, aborting transfer\n");\r\nreturn -EINVAL;\r\n}\r\ndata_id = data_type | dsi->vc[channel].vc_id << 6;\r\nr = (data_id << 0) | (data << 8) | (ecc << 24);\r\ndsi_write_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel), r);\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_send_null(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nreturn dsi_vc_send_long(dsidev, channel, MIPI_DSI_NULL_PACKET, NULL,\r\n0, 0);\r\n}\r\nstatic int dsi_vc_write_nosync_common(struct platform_device *dsidev,\r\nint channel, u8 *data, int len, enum dss_dsi_content_type type)\r\n{\r\nint r;\r\nif (len == 0) {\r\nBUG_ON(type == DSS_DSI_CONTENT_DCS);\r\nr = dsi_vc_send_short(dsidev, channel,\r\nMIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM, 0, 0);\r\n} else if (len == 1) {\r\nr = dsi_vc_send_short(dsidev, channel,\r\ntype == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM :\r\nMIPI_DSI_DCS_SHORT_WRITE, data[0], 0);\r\n} else if (len == 2) {\r\nr = dsi_vc_send_short(dsidev, channel,\r\ntype == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM :\r\nMIPI_DSI_DCS_SHORT_WRITE_PARAM,\r\ndata[0] | (data[1] << 8), 0);\r\n} else {\r\nr = dsi_vc_send_long(dsidev, channel,\r\ntype == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_GENERIC_LONG_WRITE :\r\nMIPI_DSI_DCS_LONG_WRITE, data, len, 0);\r\n}\r\nreturn r;\r\n}\r\nstatic int dsi_vc_dcs_write_nosync(struct omap_dss_device *dssdev, int channel,\r\nu8 *data, int len)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nreturn dsi_vc_write_nosync_common(dsidev, channel, data, len,\r\nDSS_DSI_CONTENT_DCS);\r\n}\r\nstatic int dsi_vc_generic_write_nosync(struct omap_dss_device *dssdev, int channel,\r\nu8 *data, int len)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nreturn dsi_vc_write_nosync_common(dsidev, channel, data, len,\r\nDSS_DSI_CONTENT_GENERIC);\r\n}\r\nstatic int dsi_vc_write_common(struct omap_dss_device *dssdev, int channel,\r\nu8 *data, int len, enum dss_dsi_content_type type)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nint r;\r\nr = dsi_vc_write_nosync_common(dsidev, channel, data, len, type);\r\nif (r)\r\ngoto err;\r\nr = dsi_vc_send_bta_sync(dssdev, channel);\r\nif (r)\r\ngoto err;\r\nif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\r\nDSSERR("rx fifo not empty after write, dumping data:\n");\r\ndsi_vc_flush_receive_data(dsidev, channel);\r\nr = -EIO;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nDSSERR("dsi_vc_write_common(ch %d, cmd 0x%02x, len %d) failed\n",\r\nchannel, data[0], len);\r\nreturn r;\r\n}\r\nstatic int dsi_vc_dcs_write(struct omap_dss_device *dssdev, int channel, u8 *data,\r\nint len)\r\n{\r\nreturn dsi_vc_write_common(dssdev, channel, data, len,\r\nDSS_DSI_CONTENT_DCS);\r\n}\r\nstatic int dsi_vc_generic_write(struct omap_dss_device *dssdev, int channel, u8 *data,\r\nint len)\r\n{\r\nreturn dsi_vc_write_common(dssdev, channel, data, len,\r\nDSS_DSI_CONTENT_GENERIC);\r\n}\r\nstatic int dsi_vc_dcs_send_read_request(struct platform_device *dsidev,\r\nint channel, u8 dcs_cmd)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r;\r\nif (dsi->debug_read)\r\nDSSDBG("dsi_vc_dcs_send_read_request(ch%d, dcs_cmd %x)\n",\r\nchannel, dcs_cmd);\r\nr = dsi_vc_send_short(dsidev, channel, MIPI_DSI_DCS_READ, dcs_cmd, 0);\r\nif (r) {\r\nDSSERR("dsi_vc_dcs_send_read_request(ch %d, cmd 0x%02x)"\r\n" failed\n", channel, dcs_cmd);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_generic_send_read_request(struct platform_device *dsidev,\r\nint channel, u8 *reqdata, int reqlen)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu16 data;\r\nu8 data_type;\r\nint r;\r\nif (dsi->debug_read)\r\nDSSDBG("dsi_vc_generic_send_read_request(ch %d, reqlen %d)\n",\r\nchannel, reqlen);\r\nif (reqlen == 0) {\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM;\r\ndata = 0;\r\n} else if (reqlen == 1) {\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM;\r\ndata = reqdata[0];\r\n} else if (reqlen == 2) {\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM;\r\ndata = reqdata[0] | (reqdata[1] << 8);\r\n} else {\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nr = dsi_vc_send_short(dsidev, channel, data_type, data, 0);\r\nif (r) {\r\nDSSERR("dsi_vc_generic_send_read_request(ch %d, reqlen %d)"\r\n" failed\n", channel, reqlen);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_read_rx_fifo(struct platform_device *dsidev, int channel,\r\nu8 *buf, int buflen, enum dss_dsi_content_type type)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 val;\r\nu8 dt;\r\nint r;\r\nif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20) == 0) {\r\nDSSERR("RX fifo empty when trying to read.\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\nval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\r\nif (dsi->debug_read)\r\nDSSDBG("\theader: %08x\n", val);\r\ndt = FLD_GET(val, 5, 0);\r\nif (dt == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT) {\r\nu16 err = FLD_GET(val, 23, 8);\r\ndsi_show_rx_ack_with_err(err);\r\nr = -EIO;\r\ngoto err;\r\n} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE :\r\nMIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE)) {\r\nu8 data = FLD_GET(val, 15, 8);\r\nif (dsi->debug_read)\r\nDSSDBG("\t%s short response, 1 byte: %02x\n",\r\ntype == DSS_DSI_CONTENT_GENERIC ? "GENERIC" :\r\n"DCS", data);\r\nif (buflen < 1) {\r\nr = -EIO;\r\ngoto err;\r\n}\r\nbuf[0] = data;\r\nreturn 1;\r\n} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE :\r\nMIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE)) {\r\nu16 data = FLD_GET(val, 23, 8);\r\nif (dsi->debug_read)\r\nDSSDBG("\t%s short response, 2 byte: %04x\n",\r\ntype == DSS_DSI_CONTENT_GENERIC ? "GENERIC" :\r\n"DCS", data);\r\nif (buflen < 2) {\r\nr = -EIO;\r\ngoto err;\r\n}\r\nbuf[0] = data & 0xff;\r\nbuf[1] = (data >> 8) & 0xff;\r\nreturn 2;\r\n} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE :\r\nMIPI_DSI_RX_DCS_LONG_READ_RESPONSE)) {\r\nint w;\r\nint len = FLD_GET(val, 23, 8);\r\nif (dsi->debug_read)\r\nDSSDBG("\t%s long response, len %d\n",\r\ntype == DSS_DSI_CONTENT_GENERIC ? "GENERIC" :\r\n"DCS", len);\r\nif (len > buflen) {\r\nr = -EIO;\r\ngoto err;\r\n}\r\nfor (w = 0; w < len + 2;) {\r\nint b;\r\nval = dsi_read_reg(dsidev,\r\nDSI_VC_SHORT_PACKET_HEADER(channel));\r\nif (dsi->debug_read)\r\nDSSDBG("\t\t%02x %02x %02x %02x\n",\r\n(val >> 0) & 0xff,\r\n(val >> 8) & 0xff,\r\n(val >> 16) & 0xff,\r\n(val >> 24) & 0xff);\r\nfor (b = 0; b < 4; ++b) {\r\nif (w < len)\r\nbuf[w] = (val >> (b * 8)) & 0xff;\r\n++w;\r\n}\r\n}\r\nreturn len;\r\n} else {\r\nDSSERR("\tunknown datatype 0x%02x\n", dt);\r\nr = -EIO;\r\ngoto err;\r\n}\r\nerr:\r\nDSSERR("dsi_vc_read_rx_fifo(ch %d type %s) failed\n", channel,\r\ntype == DSS_DSI_CONTENT_GENERIC ? "GENERIC" : "DCS");\r\nreturn r;\r\n}\r\nstatic int dsi_vc_dcs_read(struct omap_dss_device *dssdev, int channel, u8 dcs_cmd,\r\nu8 *buf, int buflen)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nint r;\r\nr = dsi_vc_dcs_send_read_request(dsidev, channel, dcs_cmd);\r\nif (r)\r\ngoto err;\r\nr = dsi_vc_send_bta_sync(dssdev, channel);\r\nif (r)\r\ngoto err;\r\nr = dsi_vc_read_rx_fifo(dsidev, channel, buf, buflen,\r\nDSS_DSI_CONTENT_DCS);\r\nif (r < 0)\r\ngoto err;\r\nif (r != buflen) {\r\nr = -EIO;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nDSSERR("dsi_vc_dcs_read(ch %d, cmd 0x%02x) failed\n", channel, dcs_cmd);\r\nreturn r;\r\n}\r\nstatic int dsi_vc_generic_read(struct omap_dss_device *dssdev, int channel,\r\nu8 *reqdata, int reqlen, u8 *buf, int buflen)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nint r;\r\nr = dsi_vc_generic_send_read_request(dsidev, channel, reqdata, reqlen);\r\nif (r)\r\nreturn r;\r\nr = dsi_vc_send_bta_sync(dssdev, channel);\r\nif (r)\r\nreturn r;\r\nr = dsi_vc_read_rx_fifo(dsidev, channel, buf, buflen,\r\nDSS_DSI_CONTENT_GENERIC);\r\nif (r < 0)\r\nreturn r;\r\nif (r != buflen) {\r\nr = -EIO;\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_set_max_rx_packet_size(struct omap_dss_device *dssdev, int channel,\r\nu16 len)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nreturn dsi_vc_send_short(dsidev, channel,\r\nMIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE, len, 0);\r\n}\r\nstatic int dsi_enter_ulps(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nint r, i;\r\nunsigned mask;\r\nDSSDBG("Entering ULPS");\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nWARN_ON(dsi->ulps_enabled);\r\nif (dsi->ulps_enabled)\r\nreturn 0;\r\nif (REG_GET(dsidev, DSI_CLK_CTRL, 13, 13)) {\r\ndsi_if_enable(dsidev, 0);\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 13, 13);\r\ndsi_if_enable(dsidev, 1);\r\n}\r\ndsi_sync_vc(dsidev, 0);\r\ndsi_sync_vc(dsidev, 1);\r\ndsi_sync_vc(dsidev, 2);\r\ndsi_sync_vc(dsidev, 3);\r\ndsi_force_tx_stop_mode_io(dsidev);\r\ndsi_vc_enable(dsidev, 0, false);\r\ndsi_vc_enable(dsidev, 1, false);\r\ndsi_vc_enable(dsidev, 2, false);\r\ndsi_vc_enable(dsidev, 3, false);\r\nif (REG_GET(dsidev, DSI_COMPLEXIO_CFG2, 16, 16)) {\r\nDSSERR("HS busy when enabling ULPS\n");\r\nreturn -EIO;\r\n}\r\nif (REG_GET(dsidev, DSI_COMPLEXIO_CFG2, 17, 17)) {\r\nDSSERR("LP busy when enabling ULPS\n");\r\nreturn -EIO;\r\n}\r\nr = dsi_register_isr_cio(dsidev, dsi_completion_handler, &completion,\r\nDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\r\nif (r)\r\nreturn r;\r\nmask = 0;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (dsi->lanes[i].function == DSI_LANE_UNUSED)\r\ncontinue;\r\nmask |= 1 << i;\r\n}\r\nREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG2, mask, 9, 5);\r\ndsi_read_reg(dsidev, DSI_COMPLEXIO_CFG2);\r\nif (wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(1000)) == 0) {\r\nDSSERR("ULPS enable timeout\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\ndsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,\r\nDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\r\nREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG2, 0, 9, 5);\r\ndsi_read_reg(dsidev, DSI_COMPLEXIO_CFG2);\r\ndsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_ULPS);\r\ndsi_if_enable(dsidev, false);\r\ndsi->ulps_enabled = true;\r\nreturn 0;\r\nerr:\r\ndsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,\r\nDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\r\nreturn r;\r\n}\r\nstatic void dsi_set_lp_rx_timeout(struct platform_device *dsidev,\r\nunsigned ticks, bool x4, bool x16)\r\n{\r\nunsigned long fck;\r\nunsigned long total_ticks;\r\nu32 r;\r\nBUG_ON(ticks > 0x1fff);\r\nfck = dsi_fclk_rate(dsidev);\r\nr = dsi_read_reg(dsidev, DSI_TIMING2);\r\nr = FLD_MOD(r, 1, 15, 15);\r\nr = FLD_MOD(r, x16 ? 1 : 0, 14, 14);\r\nr = FLD_MOD(r, x4 ? 1 : 0, 13, 13);\r\nr = FLD_MOD(r, ticks, 12, 0);\r\ndsi_write_reg(dsidev, DSI_TIMING2, r);\r\ntotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\r\nDSSDBG("LP_RX_TO %lu ticks (%#x%s%s) = %lu ns\n",\r\ntotal_ticks,\r\nticks, x4 ? " x4" : "", x16 ? " x16" : "",\r\n(total_ticks * 1000) / (fck / 1000 / 1000));\r\n}\r\nstatic void dsi_set_ta_timeout(struct platform_device *dsidev, unsigned ticks,\r\nbool x8, bool x16)\r\n{\r\nunsigned long fck;\r\nunsigned long total_ticks;\r\nu32 r;\r\nBUG_ON(ticks > 0x1fff);\r\nfck = dsi_fclk_rate(dsidev);\r\nr = dsi_read_reg(dsidev, DSI_TIMING1);\r\nr = FLD_MOD(r, 1, 31, 31);\r\nr = FLD_MOD(r, x16 ? 1 : 0, 30, 30);\r\nr = FLD_MOD(r, x8 ? 1 : 0, 29, 29);\r\nr = FLD_MOD(r, ticks, 28, 16);\r\ndsi_write_reg(dsidev, DSI_TIMING1, r);\r\ntotal_ticks = ticks * (x16 ? 16 : 1) * (x8 ? 8 : 1);\r\nDSSDBG("TA_TO %lu ticks (%#x%s%s) = %lu ns\n",\r\ntotal_ticks,\r\nticks, x8 ? " x8" : "", x16 ? " x16" : "",\r\n(total_ticks * 1000) / (fck / 1000 / 1000));\r\n}\r\nstatic void dsi_set_stop_state_counter(struct platform_device *dsidev,\r\nunsigned ticks, bool x4, bool x16)\r\n{\r\nunsigned long fck;\r\nunsigned long total_ticks;\r\nu32 r;\r\nBUG_ON(ticks > 0x1fff);\r\nfck = dsi_fclk_rate(dsidev);\r\nr = dsi_read_reg(dsidev, DSI_TIMING1);\r\nr = FLD_MOD(r, 1, 15, 15);\r\nr = FLD_MOD(r, x16 ? 1 : 0, 14, 14);\r\nr = FLD_MOD(r, x4 ? 1 : 0, 13, 13);\r\nr = FLD_MOD(r, ticks, 12, 0);\r\ndsi_write_reg(dsidev, DSI_TIMING1, r);\r\ntotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\r\nDSSDBG("STOP_STATE_COUNTER %lu ticks (%#x%s%s) = %lu ns\n",\r\ntotal_ticks,\r\nticks, x4 ? " x4" : "", x16 ? " x16" : "",\r\n(total_ticks * 1000) / (fck / 1000 / 1000));\r\n}\r\nstatic void dsi_set_hs_tx_timeout(struct platform_device *dsidev,\r\nunsigned ticks, bool x4, bool x16)\r\n{\r\nunsigned long fck;\r\nunsigned long total_ticks;\r\nu32 r;\r\nBUG_ON(ticks > 0x1fff);\r\nfck = dsi_get_txbyteclkhs(dsidev);\r\nr = dsi_read_reg(dsidev, DSI_TIMING2);\r\nr = FLD_MOD(r, 1, 31, 31);\r\nr = FLD_MOD(r, x16 ? 1 : 0, 30, 30);\r\nr = FLD_MOD(r, x4 ? 1 : 0, 29, 29);\r\nr = FLD_MOD(r, ticks, 28, 16);\r\ndsi_write_reg(dsidev, DSI_TIMING2, r);\r\ntotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\r\nDSSDBG("HS_TX_TO %lu ticks (%#x%s%s) = %lu ns\n",\r\ntotal_ticks,\r\nticks, x4 ? " x4" : "", x16 ? " x16" : "",\r\n(total_ticks * 1000) / (fck / 1000 / 1000));\r\n}\r\nstatic void dsi_config_vp_num_line_buffers(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint num_line_buffers;\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\nint bpp = dsi_get_pixel_size(dsi->pix_fmt);\r\nstruct omap_video_timings *timings = &dsi->timings;\r\nif (dsi->line_buffer_size <= timings->x_res * bpp / 8)\r\nnum_line_buffers = 0;\r\nelse\r\nnum_line_buffers = 2;\r\n} else {\r\nnum_line_buffers = 2;\r\n}\r\nREG_FLD_MOD(dsidev, DSI_CTRL, num_line_buffers, 13, 12);\r\n}\r\nstatic void dsi_config_vp_sync_events(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nbool sync_end;\r\nu32 r;\r\nif (dsi->vm_timings.trans_mode == OMAP_DSS_DSI_PULSE_MODE)\r\nsync_end = true;\r\nelse\r\nsync_end = false;\r\nr = dsi_read_reg(dsidev, DSI_CTRL);\r\nr = FLD_MOD(r, 1, 9, 9);\r\nr = FLD_MOD(r, 1, 10, 10);\r\nr = FLD_MOD(r, 1, 11, 11);\r\nr = FLD_MOD(r, 1, 15, 15);\r\nr = FLD_MOD(r, sync_end, 16, 16);\r\nr = FLD_MOD(r, 1, 17, 17);\r\nr = FLD_MOD(r, sync_end, 18, 18);\r\ndsi_write_reg(dsidev, DSI_CTRL, r);\r\n}\r\nstatic void dsi_config_blanking_modes(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint blanking_mode = dsi->vm_timings.blanking_mode;\r\nint hfp_blanking_mode = dsi->vm_timings.hfp_blanking_mode;\r\nint hbp_blanking_mode = dsi->vm_timings.hbp_blanking_mode;\r\nint hsa_blanking_mode = dsi->vm_timings.hsa_blanking_mode;\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_CTRL);\r\nr = FLD_MOD(r, blanking_mode, 20, 20);\r\nr = FLD_MOD(r, hfp_blanking_mode, 21, 21);\r\nr = FLD_MOD(r, hbp_blanking_mode, 22, 22);\r\nr = FLD_MOD(r, hsa_blanking_mode, 23, 23);\r\ndsi_write_reg(dsidev, DSI_CTRL, r);\r\n}\r\nstatic int dsi_compute_interleave_hs(int blank, bool ddr_alwon, int enter_hs,\r\nint exit_hs, int exiths_clk, int ddr_pre, int ddr_post)\r\n{\r\nint transition;\r\nif (ddr_alwon) {\r\ntransition = enter_hs + exit_hs + max(enter_hs, 2) + 1;\r\n} else {\r\nint trans1, trans2;\r\ntrans1 = ddr_pre + enter_hs + exit_hs + max(enter_hs, 2) + 1;\r\ntrans2 = ddr_pre + enter_hs + exiths_clk + ddr_post + ddr_pre +\r\nenter_hs + 1;\r\ntransition = max(trans1, trans2);\r\n}\r\nreturn blank > transition ? blank - transition : 0;\r\n}\r\nstatic int dsi_compute_interleave_lp(int blank, int enter_hs, int exit_hs,\r\nint lp_clk_div, int tdsi_fclk)\r\n{\r\nint trans_lp;\r\nint tlp_avail;\r\nint ttxclkesc;\r\nint thsbyte_clk = 16;\r\nint lp_inter;\r\ntrans_lp = exit_hs + max(enter_hs, 2) + 1;\r\ntlp_avail = thsbyte_clk * (blank - trans_lp);\r\nttxclkesc = tdsi_fclk * lp_clk_div;\r\nlp_inter = ((tlp_avail - 8 * thsbyte_clk - 5 * tdsi_fclk) / ttxclkesc -\r\n26) / 16;\r\nreturn max(lp_inter, 0);\r\n}\r\nstatic void dsi_config_cmd_mode_interleaving(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint blanking_mode;\r\nint hfp_blanking_mode, hbp_blanking_mode, hsa_blanking_mode;\r\nint hsa, hfp, hbp, width_bytes, bllp, lp_clk_div;\r\nint ddr_clk_pre, ddr_clk_post, enter_hs_mode_lat, exit_hs_mode_lat;\r\nint tclk_trail, ths_exit, exiths_clk;\r\nbool ddr_alwon;\r\nstruct omap_video_timings *timings = &dsi->timings;\r\nint bpp = dsi_get_pixel_size(dsi->pix_fmt);\r\nint ndl = dsi->num_lanes_used - 1;\r\nint dsi_fclk_hsdiv = dsi->user_dsi_cinfo.mX[HSDIV_DSI] + 1;\r\nint hsa_interleave_hs = 0, hsa_interleave_lp = 0;\r\nint hfp_interleave_hs = 0, hfp_interleave_lp = 0;\r\nint hbp_interleave_hs = 0, hbp_interleave_lp = 0;\r\nint bl_interleave_hs = 0, bl_interleave_lp = 0;\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_CTRL);\r\nblanking_mode = FLD_GET(r, 20, 20);\r\nhfp_blanking_mode = FLD_GET(r, 21, 21);\r\nhbp_blanking_mode = FLD_GET(r, 22, 22);\r\nhsa_blanking_mode = FLD_GET(r, 23, 23);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING1);\r\nhbp = FLD_GET(r, 11, 0);\r\nhfp = FLD_GET(r, 23, 12);\r\nhsa = FLD_GET(r, 31, 24);\r\nr = dsi_read_reg(dsidev, DSI_CLK_TIMING);\r\nddr_clk_post = FLD_GET(r, 7, 0);\r\nddr_clk_pre = FLD_GET(r, 15, 8);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING7);\r\nexit_hs_mode_lat = FLD_GET(r, 15, 0);\r\nenter_hs_mode_lat = FLD_GET(r, 31, 16);\r\nr = dsi_read_reg(dsidev, DSI_CLK_CTRL);\r\nlp_clk_div = FLD_GET(r, 12, 0);\r\nddr_alwon = FLD_GET(r, 13, 13);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\r\nths_exit = FLD_GET(r, 7, 0);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\r\ntclk_trail = FLD_GET(r, 15, 8);\r\nexiths_clk = ths_exit + tclk_trail;\r\nwidth_bytes = DIV_ROUND_UP(timings->x_res * bpp, 8);\r\nbllp = hbp + hfp + hsa + DIV_ROUND_UP(width_bytes + 6, ndl);\r\nif (!hsa_blanking_mode) {\r\nhsa_interleave_hs = dsi_compute_interleave_hs(hsa, ddr_alwon,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nexiths_clk, ddr_clk_pre, ddr_clk_post);\r\nhsa_interleave_lp = dsi_compute_interleave_lp(hsa,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nlp_clk_div, dsi_fclk_hsdiv);\r\n}\r\nif (!hfp_blanking_mode) {\r\nhfp_interleave_hs = dsi_compute_interleave_hs(hfp, ddr_alwon,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nexiths_clk, ddr_clk_pre, ddr_clk_post);\r\nhfp_interleave_lp = dsi_compute_interleave_lp(hfp,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nlp_clk_div, dsi_fclk_hsdiv);\r\n}\r\nif (!hbp_blanking_mode) {\r\nhbp_interleave_hs = dsi_compute_interleave_hs(hbp, ddr_alwon,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nexiths_clk, ddr_clk_pre, ddr_clk_post);\r\nhbp_interleave_lp = dsi_compute_interleave_lp(hbp,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nlp_clk_div, dsi_fclk_hsdiv);\r\n}\r\nif (!blanking_mode) {\r\nbl_interleave_hs = dsi_compute_interleave_hs(bllp, ddr_alwon,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nexiths_clk, ddr_clk_pre, ddr_clk_post);\r\nbl_interleave_lp = dsi_compute_interleave_lp(bllp,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nlp_clk_div, dsi_fclk_hsdiv);\r\n}\r\nDSSDBG("DSI HS interleaving(TXBYTECLKHS) HSA %d, HFP %d, HBP %d, BLLP %d\n",\r\nhsa_interleave_hs, hfp_interleave_hs, hbp_interleave_hs,\r\nbl_interleave_hs);\r\nDSSDBG("DSI LP interleaving(bytes) HSA %d, HFP %d, HBP %d, BLLP %d\n",\r\nhsa_interleave_lp, hfp_interleave_lp, hbp_interleave_lp,\r\nbl_interleave_lp);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING4);\r\nr = FLD_MOD(r, hsa_interleave_hs, 23, 16);\r\nr = FLD_MOD(r, hfp_interleave_hs, 15, 8);\r\nr = FLD_MOD(r, hbp_interleave_hs, 7, 0);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING4, r);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING5);\r\nr = FLD_MOD(r, hsa_interleave_lp, 23, 16);\r\nr = FLD_MOD(r, hfp_interleave_lp, 15, 8);\r\nr = FLD_MOD(r, hbp_interleave_lp, 7, 0);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING5, r);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING6);\r\nr = FLD_MOD(r, bl_interleave_hs, 31, 15);\r\nr = FLD_MOD(r, bl_interleave_lp, 16, 0);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING6, r);\r\n}\r\nstatic int dsi_proto_config(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r;\r\nint buswidth = 0;\r\ndsi_config_tx_fifo(dsidev, DSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32);\r\ndsi_config_rx_fifo(dsidev, DSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32);\r\ndsi_set_stop_state_counter(dsidev, 0x1000, false, false);\r\ndsi_set_ta_timeout(dsidev, 0x1fff, true, true);\r\ndsi_set_lp_rx_timeout(dsidev, 0x1fff, true, true);\r\ndsi_set_hs_tx_timeout(dsidev, 0x1fff, true, true);\r\nswitch (dsi_get_pixel_size(dsi->pix_fmt)) {\r\ncase 16:\r\nbuswidth = 0;\r\nbreak;\r\ncase 18:\r\nbuswidth = 1;\r\nbreak;\r\ncase 24:\r\nbuswidth = 2;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nr = dsi_read_reg(dsidev, DSI_CTRL);\r\nr = FLD_MOD(r, 1, 1, 1);\r\nr = FLD_MOD(r, 1, 2, 2);\r\nr = FLD_MOD(r, 1, 3, 3);\r\nr = FLD_MOD(r, 1, 4, 4);\r\nr = FLD_MOD(r, buswidth, 7, 6);\r\nr = FLD_MOD(r, 0, 8, 8);\r\nr = FLD_MOD(r, 1, 14, 14);\r\nr = FLD_MOD(r, 1, 19, 19);\r\nif (!dss_has_feature(FEAT_DSI_DCS_CMD_CONFIG_VC)) {\r\nr = FLD_MOD(r, 1, 24, 24);\r\nr = FLD_MOD(r, 0, 25, 25);\r\n}\r\ndsi_write_reg(dsidev, DSI_CTRL, r);\r\ndsi_config_vp_num_line_buffers(dsidev);\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\ndsi_config_vp_sync_events(dsidev);\r\ndsi_config_blanking_modes(dsidev);\r\ndsi_config_cmd_mode_interleaving(dsidev);\r\n}\r\ndsi_vc_initial_config(dsidev, 0);\r\ndsi_vc_initial_config(dsidev, 1);\r\ndsi_vc_initial_config(dsidev, 2);\r\ndsi_vc_initial_config(dsidev, 3);\r\nreturn 0;\r\n}\r\nstatic void dsi_proto_timings(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned tlpx, tclk_zero, tclk_prepare, tclk_trail;\r\nunsigned tclk_pre, tclk_post;\r\nunsigned ths_prepare, ths_prepare_ths_zero, ths_zero;\r\nunsigned ths_trail, ths_exit;\r\nunsigned ddr_clk_pre, ddr_clk_post;\r\nunsigned enter_hs_mode_lat, exit_hs_mode_lat;\r\nunsigned ths_eot;\r\nint ndl = dsi->num_lanes_used - 1;\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\r\nths_prepare = FLD_GET(r, 31, 24);\r\nths_prepare_ths_zero = FLD_GET(r, 23, 16);\r\nths_zero = ths_prepare_ths_zero - ths_prepare;\r\nths_trail = FLD_GET(r, 15, 8);\r\nths_exit = FLD_GET(r, 7, 0);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\r\ntlpx = FLD_GET(r, 20, 16) * 2;\r\ntclk_trail = FLD_GET(r, 15, 8);\r\ntclk_zero = FLD_GET(r, 7, 0);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG2);\r\ntclk_prepare = FLD_GET(r, 7, 0);\r\ntclk_pre = 20;\r\ntclk_post = ns2ddr(dsidev, 60) + 26;\r\nths_eot = DIV_ROUND_UP(4, ndl);\r\nddr_clk_pre = DIV_ROUND_UP(tclk_pre + tlpx + tclk_zero + tclk_prepare,\r\n4);\r\nddr_clk_post = DIV_ROUND_UP(tclk_post + ths_trail, 4) + ths_eot;\r\nBUG_ON(ddr_clk_pre == 0 || ddr_clk_pre > 255);\r\nBUG_ON(ddr_clk_post == 0 || ddr_clk_post > 255);\r\nr = dsi_read_reg(dsidev, DSI_CLK_TIMING);\r\nr = FLD_MOD(r, ddr_clk_pre, 15, 8);\r\nr = FLD_MOD(r, ddr_clk_post, 7, 0);\r\ndsi_write_reg(dsidev, DSI_CLK_TIMING, r);\r\nDSSDBG("ddr_clk_pre %u, ddr_clk_post %u\n",\r\nddr_clk_pre,\r\nddr_clk_post);\r\nenter_hs_mode_lat = 1 + DIV_ROUND_UP(tlpx, 4) +\r\nDIV_ROUND_UP(ths_prepare, 4) +\r\nDIV_ROUND_UP(ths_zero + 3, 4);\r\nexit_hs_mode_lat = DIV_ROUND_UP(ths_trail + ths_exit, 4) + 1 + ths_eot;\r\nr = FLD_VAL(enter_hs_mode_lat, 31, 16) |\r\nFLD_VAL(exit_hs_mode_lat, 15, 0);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING7, r);\r\nDSSDBG("enter_hs_mode_lat %u, exit_hs_mode_lat %u\n",\r\nenter_hs_mode_lat, exit_hs_mode_lat);\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\nint hsa = dsi->vm_timings.hsa;\r\nint hfp = dsi->vm_timings.hfp;\r\nint hbp = dsi->vm_timings.hbp;\r\nint vsa = dsi->vm_timings.vsa;\r\nint vfp = dsi->vm_timings.vfp;\r\nint vbp = dsi->vm_timings.vbp;\r\nint window_sync = dsi->vm_timings.window_sync;\r\nbool hsync_end;\r\nstruct omap_video_timings *timings = &dsi->timings;\r\nint bpp = dsi_get_pixel_size(dsi->pix_fmt);\r\nint tl, t_he, width_bytes;\r\nhsync_end = dsi->vm_timings.trans_mode == OMAP_DSS_DSI_PULSE_MODE;\r\nt_he = hsync_end ?\r\n((hsa == 0 && ndl == 3) ? 1 : DIV_ROUND_UP(4, ndl)) : 0;\r\nwidth_bytes = DIV_ROUND_UP(timings->x_res * bpp, 8);\r\ntl = DIV_ROUND_UP(4, ndl) + (hsync_end ? hsa : 0) + t_he + hfp +\r\nDIV_ROUND_UP(width_bytes + 6, ndl) + hbp;\r\nDSSDBG("HBP: %d, HFP: %d, HSA: %d, TL: %d TXBYTECLKHS\n", hbp,\r\nhfp, hsync_end ? hsa : 0, tl);\r\nDSSDBG("VBP: %d, VFP: %d, VSA: %d, VACT: %d lines\n", vbp, vfp,\r\nvsa, timings->y_res);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING1);\r\nr = FLD_MOD(r, hbp, 11, 0);\r\nr = FLD_MOD(r, hfp, 23, 12);\r\nr = FLD_MOD(r, hsync_end ? hsa : 0, 31, 24);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING1, r);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING2);\r\nr = FLD_MOD(r, vbp, 7, 0);\r\nr = FLD_MOD(r, vfp, 15, 8);\r\nr = FLD_MOD(r, vsa, 23, 16);\r\nr = FLD_MOD(r, window_sync, 27, 24);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING2, r);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING3);\r\nr = FLD_MOD(r, timings->y_res, 14, 0);\r\nr = FLD_MOD(r, tl, 31, 16);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING3, r);\r\n}\r\n}\r\nstatic int dsi_configure_pins(struct omap_dss_device *dssdev,\r\nconst struct omap_dsi_pin_config *pin_cfg)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint num_pins;\r\nconst int *pins;\r\nstruct dsi_lane_config lanes[DSI_MAX_NR_LANES];\r\nint num_lanes;\r\nint i;\r\nstatic const enum dsi_lane_function functions[] = {\r\nDSI_LANE_CLK,\r\nDSI_LANE_DATA1,\r\nDSI_LANE_DATA2,\r\nDSI_LANE_DATA3,\r\nDSI_LANE_DATA4,\r\n};\r\nnum_pins = pin_cfg->num_pins;\r\npins = pin_cfg->pins;\r\nif (num_pins < 4 || num_pins > dsi->num_lanes_supported * 2\r\n|| num_pins % 2 != 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < DSI_MAX_NR_LANES; ++i)\r\nlanes[i].function = DSI_LANE_UNUSED;\r\nnum_lanes = 0;\r\nfor (i = 0; i < num_pins; i += 2) {\r\nu8 lane, pol;\r\nint dx, dy;\r\ndx = pins[i];\r\ndy = pins[i + 1];\r\nif (dx < 0 || dx >= dsi->num_lanes_supported * 2)\r\nreturn -EINVAL;\r\nif (dy < 0 || dy >= dsi->num_lanes_supported * 2)\r\nreturn -EINVAL;\r\nif (dx & 1) {\r\nif (dy != dx - 1)\r\nreturn -EINVAL;\r\npol = 1;\r\n} else {\r\nif (dy != dx + 1)\r\nreturn -EINVAL;\r\npol = 0;\r\n}\r\nlane = dx / 2;\r\nlanes[lane].function = functions[i / 2];\r\nlanes[lane].polarity = pol;\r\nnum_lanes++;\r\n}\r\nmemcpy(dsi->lanes, lanes, sizeof(dsi->lanes));\r\ndsi->num_lanes_used = num_lanes;\r\nreturn 0;\r\n}\r\nstatic int dsi_enable_video_output(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nenum omap_channel dispc_channel = dssdev->dispc_channel;\r\nint bpp = dsi_get_pixel_size(dsi->pix_fmt);\r\nstruct omap_dss_device *out = &dsi->output;\r\nu8 data_type;\r\nu16 word_count;\r\nint r;\r\nif (!out->dispc_channel_connected) {\r\nDSSERR("failed to enable display: no output/manager\n");\r\nreturn -ENODEV;\r\n}\r\nr = dsi_display_init_dispc(dsidev, dispc_channel);\r\nif (r)\r\ngoto err_init_dispc;\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\nswitch (dsi->pix_fmt) {\r\ncase OMAP_DSS_DSI_FMT_RGB888:\r\ndata_type = MIPI_DSI_PACKED_PIXEL_STREAM_24;\r\nbreak;\r\ncase OMAP_DSS_DSI_FMT_RGB666:\r\ndata_type = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\r\nbreak;\r\ncase OMAP_DSS_DSI_FMT_RGB666_PACKED:\r\ndata_type = MIPI_DSI_PACKED_PIXEL_STREAM_18;\r\nbreak;\r\ncase OMAP_DSS_DSI_FMT_RGB565:\r\ndata_type = MIPI_DSI_PACKED_PIXEL_STREAM_16;\r\nbreak;\r\ndefault:\r\nr = -EINVAL;\r\ngoto err_pix_fmt;\r\n}\r\ndsi_if_enable(dsidev, false);\r\ndsi_vc_enable(dsidev, channel, false);\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 1, 4, 4);\r\nword_count = DIV_ROUND_UP(dsi->timings.x_res * bpp, 8);\r\ndsi_vc_write_long_header(dsidev, channel, data_type,\r\nword_count, 0);\r\ndsi_vc_enable(dsidev, channel, true);\r\ndsi_if_enable(dsidev, true);\r\n}\r\nr = dss_mgr_enable(dispc_channel);\r\nif (r)\r\ngoto err_mgr_enable;\r\nreturn 0;\r\nerr_mgr_enable:\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\ndsi_if_enable(dsidev, false);\r\ndsi_vc_enable(dsidev, channel, false);\r\n}\r\nerr_pix_fmt:\r\ndsi_display_uninit_dispc(dsidev, dispc_channel);\r\nerr_init_dispc:\r\nreturn r;\r\n}\r\nstatic void dsi_disable_video_output(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nenum omap_channel dispc_channel = dssdev->dispc_channel;\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\ndsi_if_enable(dsidev, false);\r\ndsi_vc_enable(dsidev, channel, false);\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 0, 4, 4);\r\ndsi_vc_enable(dsidev, channel, true);\r\ndsi_if_enable(dsidev, true);\r\n}\r\ndss_mgr_disable(dispc_channel);\r\ndsi_display_uninit_dispc(dsidev, dispc_channel);\r\n}\r\nstatic void dsi_update_screen_dispc(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nenum omap_channel dispc_channel = dsi->output.dispc_channel;\r\nunsigned bytespp;\r\nunsigned bytespl;\r\nunsigned bytespf;\r\nunsigned total_len;\r\nunsigned packet_payload;\r\nunsigned packet_len;\r\nu32 l;\r\nint r;\r\nconst unsigned channel = dsi->update_channel;\r\nconst unsigned line_buf_size = dsi->line_buffer_size;\r\nu16 w = dsi->timings.x_res;\r\nu16 h = dsi->timings.y_res;\r\nDSSDBG("dsi_update_screen_dispc(%dx%d)\n", w, h);\r\ndsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_VP);\r\nbytespp = dsi_get_pixel_size(dsi->pix_fmt) / 8;\r\nbytespl = w * bytespp;\r\nbytespf = bytespl * h;\r\nif (bytespf < line_buf_size)\r\npacket_payload = bytespf;\r\nelse\r\npacket_payload = (line_buf_size) / bytespl * bytespl;\r\npacket_len = packet_payload + 1;\r\ntotal_len = (bytespf / packet_payload) * packet_len;\r\nif (bytespf % packet_payload)\r\ntotal_len += (bytespf % packet_payload) + 1;\r\nl = FLD_VAL(total_len, 23, 0);\r\ndsi_write_reg(dsidev, DSI_VC_TE(channel), l);\r\ndsi_vc_write_long_header(dsidev, channel, MIPI_DSI_DCS_LONG_WRITE,\r\npacket_len, 0);\r\nif (dsi->te_enabled)\r\nl = FLD_MOD(l, 1, 30, 30);\r\nelse\r\nl = FLD_MOD(l, 1, 31, 31);\r\ndsi_write_reg(dsidev, DSI_VC_TE(channel), l);\r\ndispc_disable_sidle();\r\ndsi_perf_mark_start(dsidev);\r\nr = schedule_delayed_work(&dsi->framedone_timeout_work,\r\nmsecs_to_jiffies(250));\r\nBUG_ON(r == 0);\r\ndss_mgr_set_timings(dispc_channel, &dsi->timings);\r\ndss_mgr_start_update(dispc_channel);\r\nif (dsi->te_enabled) {\r\nREG_FLD_MOD(dsidev, DSI_TIMING2, 0, 15, 15);\r\ndsi_vc_send_bta(dsidev, channel);\r\n#ifdef DSI_CATCH_MISSING_TE\r\nmod_timer(&dsi->te_timer, jiffies + msecs_to_jiffies(250));\r\n#endif\r\n}\r\n}\r\nstatic void dsi_te_timeout(unsigned long arg)\r\n{\r\nDSSERR("TE not received for 250ms!\n");\r\n}\r\nstatic void dsi_handle_framedone(struct platform_device *dsidev, int error)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndispc_enable_sidle();\r\nif (dsi->te_enabled) {\r\nREG_FLD_MOD(dsidev, DSI_TIMING2, 1, 15, 15);\r\n}\r\ndsi->framedone_callback(error, dsi->framedone_data);\r\nif (!error)\r\ndsi_perf_show(dsidev, "DISPC");\r\n}\r\nstatic void dsi_framedone_timeout_work_callback(struct work_struct *work)\r\n{\r\nstruct dsi_data *dsi = container_of(work, struct dsi_data,\r\nframedone_timeout_work.work);\r\nDSSERR("Framedone not received for 250ms!\n");\r\ndsi_handle_framedone(dsi->pdev, -ETIMEDOUT);\r\n}\r\nstatic void dsi_framedone_irq_callback(void *data)\r\n{\r\nstruct platform_device *dsidev = (struct platform_device *) data;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ncancel_delayed_work(&dsi->framedone_timeout_work);\r\ndsi_handle_framedone(dsidev, 0);\r\n}\r\nstatic int dsi_update(struct omap_dss_device *dssdev, int channel,\r\nvoid (*callback)(int, void *), void *data)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu16 dw, dh;\r\ndsi_perf_mark_setup(dsidev);\r\ndsi->update_channel = channel;\r\ndsi->framedone_callback = callback;\r\ndsi->framedone_data = data;\r\ndw = dsi->timings.x_res;\r\ndh = dsi->timings.y_res;\r\n#ifdef DSI_PERF_MEASURE\r\ndsi->update_bytes = dw * dh *\r\ndsi_get_pixel_size(dsi->pix_fmt) / 8;\r\n#endif\r\ndsi_update_screen_dispc(dsidev);\r\nreturn 0;\r\n}\r\nstatic int dsi_configure_dispc_clocks(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dispc_clock_info dispc_cinfo;\r\nint r;\r\nunsigned long fck;\r\nfck = dsi_get_pll_hsdiv_dispc_rate(dsidev);\r\ndispc_cinfo.lck_div = dsi->user_dispc_cinfo.lck_div;\r\ndispc_cinfo.pck_div = dsi->user_dispc_cinfo.pck_div;\r\nr = dispc_calc_clock_rates(fck, &dispc_cinfo);\r\nif (r) {\r\nDSSERR("Failed to calc dispc clocks\n");\r\nreturn r;\r\n}\r\ndsi->mgr_config.clock_info = dispc_cinfo;\r\nreturn 0;\r\n}\r\nstatic int dsi_display_init_dispc(struct platform_device *dsidev,\r\nenum omap_channel channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r;\r\ndss_select_lcd_clk_source(channel, dsi->module_id == 0 ?\r\nDSS_CLK_SRC_PLL1_1 :\r\nDSS_CLK_SRC_PLL2_1);\r\nif (dsi->mode == OMAP_DSS_DSI_CMD_MODE) {\r\nr = dss_mgr_register_framedone_handler(channel,\r\ndsi_framedone_irq_callback, dsidev);\r\nif (r) {\r\nDSSERR("can't register FRAMEDONE handler\n");\r\ngoto err;\r\n}\r\ndsi->mgr_config.stallmode = true;\r\ndsi->mgr_config.fifohandcheck = true;\r\n} else {\r\ndsi->mgr_config.stallmode = false;\r\ndsi->mgr_config.fifohandcheck = false;\r\n}\r\ndsi->timings.interlace = false;\r\ndsi->timings.hsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\ndsi->timings.vsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\ndsi->timings.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\r\ndsi->timings.de_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\ndsi->timings.sync_pclk_edge = OMAPDSS_DRIVE_SIG_FALLING_EDGE;\r\ndss_mgr_set_timings(channel, &dsi->timings);\r\nr = dsi_configure_dispc_clocks(dsidev);\r\nif (r)\r\ngoto err1;\r\ndsi->mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\r\ndsi->mgr_config.video_port_width =\r\ndsi_get_pixel_size(dsi->pix_fmt);\r\ndsi->mgr_config.lcden_sig_polarity = 0;\r\ndss_mgr_set_lcd_config(channel, &dsi->mgr_config);\r\nreturn 0;\r\nerr1:\r\nif (dsi->mode == OMAP_DSS_DSI_CMD_MODE)\r\ndss_mgr_unregister_framedone_handler(channel,\r\ndsi_framedone_irq_callback, dsidev);\r\nerr:\r\ndss_select_lcd_clk_source(channel, DSS_CLK_SRC_FCK);\r\nreturn r;\r\n}\r\nstatic void dsi_display_uninit_dispc(struct platform_device *dsidev,\r\nenum omap_channel channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dsi->mode == OMAP_DSS_DSI_CMD_MODE)\r\ndss_mgr_unregister_framedone_handler(channel,\r\ndsi_framedone_irq_callback, dsidev);\r\ndss_select_lcd_clk_source(channel, DSS_CLK_SRC_FCK);\r\n}\r\nstatic int dsi_configure_dsi_clocks(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dss_pll_clock_info cinfo;\r\nint r;\r\ncinfo = dsi->user_dsi_cinfo;\r\nr = dss_pll_set_config(&dsi->pll, &cinfo);\r\nif (r) {\r\nDSSERR("Failed to set dsi clocks\n");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_display_init_dsi(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r;\r\nr = dss_pll_enable(&dsi->pll);\r\nif (r)\r\ngoto err0;\r\nr = dsi_configure_dsi_clocks(dsidev);\r\nif (r)\r\ngoto err1;\r\ndss_select_dsi_clk_source(dsi->module_id, dsi->module_id == 0 ?\r\nDSS_CLK_SRC_PLL1_2 :\r\nDSS_CLK_SRC_PLL2_2);\r\nDSSDBG("PLL OK\n");\r\nr = dsi_cio_init(dsidev);\r\nif (r)\r\ngoto err2;\r\n_dsi_print_reset_status(dsidev);\r\ndsi_proto_timings(dsidev);\r\ndsi_set_lp_clk_divisor(dsidev);\r\nif (1)\r\n_dsi_print_reset_status(dsidev);\r\nr = dsi_proto_config(dsidev);\r\nif (r)\r\ngoto err3;\r\ndsi_vc_enable(dsidev, 0, 1);\r\ndsi_vc_enable(dsidev, 1, 1);\r\ndsi_vc_enable(dsidev, 2, 1);\r\ndsi_vc_enable(dsidev, 3, 1);\r\ndsi_if_enable(dsidev, 1);\r\ndsi_force_tx_stop_mode_io(dsidev);\r\nreturn 0;\r\nerr3:\r\ndsi_cio_uninit(dsidev);\r\nerr2:\r\ndss_select_dsi_clk_source(dsi->module_id, DSS_CLK_SRC_FCK);\r\nerr1:\r\ndss_pll_disable(&dsi->pll);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic void dsi_display_uninit_dsi(struct platform_device *dsidev,\r\nbool disconnect_lanes, bool enter_ulps)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (enter_ulps && !dsi->ulps_enabled)\r\ndsi_enter_ulps(dsidev);\r\ndsi_if_enable(dsidev, 0);\r\ndsi_vc_enable(dsidev, 0, 0);\r\ndsi_vc_enable(dsidev, 1, 0);\r\ndsi_vc_enable(dsidev, 2, 0);\r\ndsi_vc_enable(dsidev, 3, 0);\r\ndss_select_dsi_clk_source(dsi->module_id, DSS_CLK_SRC_FCK);\r\ndsi_cio_uninit(dsidev);\r\ndsi_pll_uninit(dsidev, disconnect_lanes);\r\n}\r\nstatic int dsi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r = 0;\r\nDSSDBG("dsi_display_enable\n");\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nmutex_lock(&dsi->lock);\r\nr = dsi_runtime_get(dsidev);\r\nif (r)\r\ngoto err_get_dsi;\r\n_dsi_initialize_irq(dsidev);\r\nr = dsi_display_init_dsi(dsidev);\r\nif (r)\r\ngoto err_init_dsi;\r\nmutex_unlock(&dsi->lock);\r\nreturn 0;\r\nerr_init_dsi:\r\ndsi_runtime_put(dsidev);\r\nerr_get_dsi:\r\nmutex_unlock(&dsi->lock);\r\nDSSDBG("dsi_display_enable FAILED\n");\r\nreturn r;\r\n}\r\nstatic void dsi_display_disable(struct omap_dss_device *dssdev,\r\nbool disconnect_lanes, bool enter_ulps)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDSSDBG("dsi_display_disable\n");\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nmutex_lock(&dsi->lock);\r\ndsi_sync_vc(dsidev, 0);\r\ndsi_sync_vc(dsidev, 1);\r\ndsi_sync_vc(dsidev, 2);\r\ndsi_sync_vc(dsidev, 3);\r\ndsi_display_uninit_dsi(dsidev, disconnect_lanes, enter_ulps);\r\ndsi_runtime_put(dsidev);\r\nmutex_unlock(&dsi->lock);\r\n}\r\nstatic int dsi_enable_te(struct omap_dss_device *dssdev, bool enable)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi->te_enabled = enable;\r\nreturn 0;\r\n}\r\nstatic void print_dsi_vm(const char *str,\r\nconst struct omap_dss_dsi_videomode_timings *t)\r\n{\r\nunsigned long byteclk = t->hsclk / 4;\r\nint bl, wc, pps, tot;\r\nwc = DIV_ROUND_UP(t->hact * t->bitspp, 8);\r\npps = DIV_ROUND_UP(wc + 6, t->ndl);\r\nbl = t->hss + t->hsa + t->hse + t->hbp + t->hfp;\r\ntot = bl + pps;\r\n#define TO_DSI_T(x) ((u32)div64_u64((u64)x * 1000000000llu, byteclk))\r\npr_debug("%s bck %lu, %u/%u/%u/%u/%u/%u = %u+%u = %u, "\r\n"%u/%u/%u/%u/%u/%u = %u + %u = %u\n",\r\nstr,\r\nbyteclk,\r\nt->hss, t->hsa, t->hse, t->hbp, pps, t->hfp,\r\nbl, pps, tot,\r\nTO_DSI_T(t->hss),\r\nTO_DSI_T(t->hsa),\r\nTO_DSI_T(t->hse),\r\nTO_DSI_T(t->hbp),\r\nTO_DSI_T(pps),\r\nTO_DSI_T(t->hfp),\r\nTO_DSI_T(bl),\r\nTO_DSI_T(pps),\r\nTO_DSI_T(tot));\r\n#undef TO_DSI_T\r\n}\r\nstatic void print_dispc_vm(const char *str, const struct omap_video_timings *t)\r\n{\r\nunsigned long pck = t->pixelclock;\r\nint hact, bl, tot;\r\nhact = t->x_res;\r\nbl = t->hsw + t->hbp + t->hfp;\r\ntot = hact + bl;\r\n#define TO_DISPC_T(x) ((u32)div64_u64((u64)x * 1000000000llu, pck))\r\npr_debug("%s pck %lu, %u/%u/%u/%u = %u+%u = %u, "\r\n"%u/%u/%u/%u = %u + %u = %u\n",\r\nstr,\r\npck,\r\nt->hsw, t->hbp, hact, t->hfp,\r\nbl, hact, tot,\r\nTO_DISPC_T(t->hsw),\r\nTO_DISPC_T(t->hbp),\r\nTO_DISPC_T(hact),\r\nTO_DISPC_T(t->hfp),\r\nTO_DISPC_T(bl),\r\nTO_DISPC_T(hact),\r\nTO_DISPC_T(tot));\r\n#undef TO_DISPC_T\r\n}\r\nstatic void print_dsi_dispc_vm(const char *str,\r\nconst struct omap_dss_dsi_videomode_timings *t)\r\n{\r\nstruct omap_video_timings vm = { 0 };\r\nunsigned long byteclk = t->hsclk / 4;\r\nunsigned long pck;\r\nu64 dsi_tput;\r\nint dsi_hact, dsi_htot;\r\ndsi_tput = (u64)byteclk * t->ndl * 8;\r\npck = (u32)div64_u64(dsi_tput, t->bitspp);\r\ndsi_hact = DIV_ROUND_UP(DIV_ROUND_UP(t->hact * t->bitspp, 8) + 6, t->ndl);\r\ndsi_htot = t->hss + t->hsa + t->hse + t->hbp + dsi_hact + t->hfp;\r\nvm.pixelclock = pck;\r\nvm.hsw = div64_u64((u64)(t->hsa + t->hse) * pck, byteclk);\r\nvm.hbp = div64_u64((u64)t->hbp * pck, byteclk);\r\nvm.hfp = div64_u64((u64)t->hfp * pck, byteclk);\r\nvm.x_res = t->hact;\r\nprint_dispc_vm(str, &vm);\r\n}\r\nstatic bool dsi_cm_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\r\nunsigned long pck, void *data)\r\n{\r\nstruct dsi_clk_calc_ctx *ctx = data;\r\nstruct omap_video_timings *t = &ctx->dispc_vm;\r\nctx->dispc_cinfo.lck_div = lckd;\r\nctx->dispc_cinfo.pck_div = pckd;\r\nctx->dispc_cinfo.lck = lck;\r\nctx->dispc_cinfo.pck = pck;\r\n*t = *ctx->config->timings;\r\nt->pixelclock = pck;\r\nt->x_res = ctx->config->timings->x_res;\r\nt->y_res = ctx->config->timings->y_res;\r\nt->hsw = t->hfp = t->hbp = t->vsw = 1;\r\nt->vfp = t->vbp = 0;\r\nreturn true;\r\n}\r\nstatic bool dsi_cm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\r\nvoid *data)\r\n{\r\nstruct dsi_clk_calc_ctx *ctx = data;\r\nctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\r\nctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\r\nreturn dispc_div_calc(dispc, ctx->req_pck_min, ctx->req_pck_max,\r\ndsi_cm_calc_dispc_cb, ctx);\r\n}\r\nstatic bool dsi_cm_calc_pll_cb(int n, int m, unsigned long fint,\r\nunsigned long clkdco, void *data)\r\n{\r\nstruct dsi_clk_calc_ctx *ctx = data;\r\nctx->dsi_cinfo.n = n;\r\nctx->dsi_cinfo.m = m;\r\nctx->dsi_cinfo.fint = fint;\r\nctx->dsi_cinfo.clkdco = clkdco;\r\nreturn dss_pll_hsdiv_calc_a(ctx->pll, clkdco, ctx->req_pck_min,\r\ndss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\r\ndsi_cm_calc_hsdiv_cb, ctx);\r\n}\r\nstatic bool dsi_cm_calc(struct dsi_data *dsi,\r\nconst struct omap_dss_dsi_config *cfg,\r\nstruct dsi_clk_calc_ctx *ctx)\r\n{\r\nunsigned long clkin;\r\nint bitspp, ndl;\r\nunsigned long pll_min, pll_max;\r\nunsigned long pck, txbyteclk;\r\nclkin = clk_get_rate(dsi->pll.clkin);\r\nbitspp = dsi_get_pixel_size(cfg->pixel_format);\r\nndl = dsi->num_lanes_used - 1;\r\npck = cfg->timings->pixelclock;\r\npck = pck * 3 / 2;\r\ntxbyteclk = pck * bitspp / 8 / ndl;\r\nmemset(ctx, 0, sizeof(*ctx));\r\nctx->dsidev = dsi->pdev;\r\nctx->pll = &dsi->pll;\r\nctx->config = cfg;\r\nctx->req_pck_min = pck;\r\nctx->req_pck_nom = pck;\r\nctx->req_pck_max = pck * 3 / 2;\r\npll_min = max(cfg->hs_clk_min * 4, txbyteclk * 4 * 4);\r\npll_max = cfg->hs_clk_max * 4;\r\nreturn dss_pll_calc_a(ctx->pll, clkin,\r\npll_min, pll_max,\r\ndsi_cm_calc_pll_cb, ctx);\r\n}\r\nstatic bool dsi_vm_calc_blanking(struct dsi_clk_calc_ctx *ctx)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(ctx->dsidev);\r\nconst struct omap_dss_dsi_config *cfg = ctx->config;\r\nint bitspp = dsi_get_pixel_size(cfg->pixel_format);\r\nint ndl = dsi->num_lanes_used - 1;\r\nunsigned long hsclk = ctx->dsi_cinfo.clkdco / 4;\r\nunsigned long byteclk = hsclk / 4;\r\nunsigned long dispc_pck, req_pck_min, req_pck_nom, req_pck_max;\r\nint xres;\r\nint panel_htot, panel_hbl;\r\nint dispc_htot, dispc_hbl;\r\nint dsi_htot, dsi_hact, dsi_hbl, hss, hse;\r\nint hfp, hsa, hbp;\r\nconst struct omap_video_timings *req_vm;\r\nstruct omap_video_timings *dispc_vm;\r\nstruct omap_dss_dsi_videomode_timings *dsi_vm;\r\nu64 dsi_tput, dispc_tput;\r\ndsi_tput = (u64)byteclk * ndl * 8;\r\nreq_vm = cfg->timings;\r\nreq_pck_min = ctx->req_pck_min;\r\nreq_pck_max = ctx->req_pck_max;\r\nreq_pck_nom = ctx->req_pck_nom;\r\ndispc_pck = ctx->dispc_cinfo.pck;\r\ndispc_tput = (u64)dispc_pck * bitspp;\r\nxres = req_vm->x_res;\r\npanel_hbl = req_vm->hfp + req_vm->hbp + req_vm->hsw;\r\npanel_htot = xres + panel_hbl;\r\ndsi_hact = DIV_ROUND_UP(DIV_ROUND_UP(xres * bitspp, 8) + 6, ndl);\r\nif (dsi->line_buffer_size < xres * bitspp / 8) {\r\nif (dispc_tput != dsi_tput)\r\nreturn false;\r\n} else {\r\nif (dispc_tput < dsi_tput)\r\nreturn false;\r\n}\r\nif (dsi_tput < (u64)bitspp * req_pck_min)\r\nreturn false;\r\nif (cfg->trans_mode != OMAP_DSS_DSI_BURST_MODE) {\r\nif (dsi_tput > (u64)bitspp * req_pck_max)\r\nreturn false;\r\n}\r\nhss = DIV_ROUND_UP(4, ndl);\r\nif (cfg->trans_mode == OMAP_DSS_DSI_PULSE_MODE) {\r\nif (ndl == 3 && req_vm->hsw == 0)\r\nhse = 1;\r\nelse\r\nhse = DIV_ROUND_UP(4, ndl);\r\n} else {\r\nhse = 0;\r\n}\r\ndsi_htot = div64_u64((u64)panel_htot * byteclk, req_pck_nom);\r\nif (dsi_htot < hss + hse + dsi_hact)\r\nreturn false;\r\ndsi_hbl = dsi_htot - dsi_hact;\r\ndispc_htot = div64_u64((u64)dsi_htot * dispc_pck, byteclk);\r\nif ((u64)dsi_htot * dispc_pck != (u64)dispc_htot * byteclk)\r\nreturn false;\r\ndispc_hbl = dispc_htot - xres;\r\ndsi_vm = &ctx->dsi_vm;\r\nmemset(dsi_vm, 0, sizeof(*dsi_vm));\r\ndsi_vm->hsclk = hsclk;\r\ndsi_vm->ndl = ndl;\r\ndsi_vm->bitspp = bitspp;\r\nif (cfg->trans_mode != OMAP_DSS_DSI_PULSE_MODE) {\r\nhsa = 0;\r\n} else if (ndl == 3 && req_vm->hsw == 0) {\r\nhsa = 0;\r\n} else {\r\nhsa = div64_u64((u64)req_vm->hsw * byteclk, req_pck_nom);\r\nhsa = max(hsa - hse, 1);\r\n}\r\nhbp = div64_u64((u64)req_vm->hbp * byteclk, req_pck_nom);\r\nhbp = max(hbp, 1);\r\nhfp = dsi_hbl - (hss + hsa + hse + hbp);\r\nif (hfp < 1) {\r\nint t;\r\nt = 1 - hfp;\r\nhbp = max(hbp - t, 1);\r\nhfp = dsi_hbl - (hss + hsa + hse + hbp);\r\nif (hfp < 1 && hsa > 0) {\r\nt = 1 - hfp;\r\nhsa = max(hsa - t, 1);\r\nhfp = dsi_hbl - (hss + hsa + hse + hbp);\r\n}\r\n}\r\nif (hfp < 1)\r\nreturn false;\r\ndsi_vm->hss = hss;\r\ndsi_vm->hsa = hsa;\r\ndsi_vm->hse = hse;\r\ndsi_vm->hbp = hbp;\r\ndsi_vm->hact = xres;\r\ndsi_vm->hfp = hfp;\r\ndsi_vm->vsa = req_vm->vsw;\r\ndsi_vm->vbp = req_vm->vbp;\r\ndsi_vm->vact = req_vm->y_res;\r\ndsi_vm->vfp = req_vm->vfp;\r\ndsi_vm->trans_mode = cfg->trans_mode;\r\ndsi_vm->blanking_mode = 0;\r\ndsi_vm->hsa_blanking_mode = 1;\r\ndsi_vm->hfp_blanking_mode = 1;\r\ndsi_vm->hbp_blanking_mode = 1;\r\ndsi_vm->ddr_clk_always_on = cfg->ddr_clk_always_on;\r\ndsi_vm->window_sync = 4;\r\ndispc_vm = &ctx->dispc_vm;\r\n*dispc_vm = *req_vm;\r\ndispc_vm->pixelclock = dispc_pck;\r\nif (cfg->trans_mode == OMAP_DSS_DSI_PULSE_MODE) {\r\nhsa = div64_u64((u64)req_vm->hsw * dispc_pck,\r\nreq_pck_nom);\r\nhsa = max(hsa, 1);\r\n} else {\r\nhsa = 1;\r\n}\r\nhbp = div64_u64((u64)req_vm->hbp * dispc_pck, req_pck_nom);\r\nhbp = max(hbp, 1);\r\nhfp = dispc_hbl - hsa - hbp;\r\nif (hfp < 1) {\r\nint t;\r\nt = 1 - hfp;\r\nhbp = max(hbp - t, 1);\r\nhfp = dispc_hbl - hsa - hbp;\r\nif (hfp < 1) {\r\nt = 1 - hfp;\r\nhsa = max(hsa - t, 1);\r\nhfp = dispc_hbl - hsa - hbp;\r\n}\r\n}\r\nif (hfp < 1)\r\nreturn false;\r\ndispc_vm->hfp = hfp;\r\ndispc_vm->hsw = hsa;\r\ndispc_vm->hbp = hbp;\r\nreturn true;\r\n}\r\nstatic bool dsi_vm_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\r\nunsigned long pck, void *data)\r\n{\r\nstruct dsi_clk_calc_ctx *ctx = data;\r\nctx->dispc_cinfo.lck_div = lckd;\r\nctx->dispc_cinfo.pck_div = pckd;\r\nctx->dispc_cinfo.lck = lck;\r\nctx->dispc_cinfo.pck = pck;\r\nif (dsi_vm_calc_blanking(ctx) == false)\r\nreturn false;\r\n#ifdef PRINT_VERBOSE_VM_TIMINGS\r\nprint_dispc_vm("dispc", &ctx->dispc_vm);\r\nprint_dsi_vm("dsi ", &ctx->dsi_vm);\r\nprint_dispc_vm("req ", ctx->config->timings);\r\nprint_dsi_dispc_vm("act ", &ctx->dsi_vm);\r\n#endif\r\nreturn true;\r\n}\r\nstatic bool dsi_vm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\r\nvoid *data)\r\n{\r\nstruct dsi_clk_calc_ctx *ctx = data;\r\nunsigned long pck_max;\r\nctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\r\nctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\r\nif (ctx->config->trans_mode == OMAP_DSS_DSI_BURST_MODE)\r\npck_max = ctx->req_pck_max + 10000000;\r\nelse\r\npck_max = ctx->req_pck_max;\r\nreturn dispc_div_calc(dispc, ctx->req_pck_min, pck_max,\r\ndsi_vm_calc_dispc_cb, ctx);\r\n}\r\nstatic bool dsi_vm_calc_pll_cb(int n, int m, unsigned long fint,\r\nunsigned long clkdco, void *data)\r\n{\r\nstruct dsi_clk_calc_ctx *ctx = data;\r\nctx->dsi_cinfo.n = n;\r\nctx->dsi_cinfo.m = m;\r\nctx->dsi_cinfo.fint = fint;\r\nctx->dsi_cinfo.clkdco = clkdco;\r\nreturn dss_pll_hsdiv_calc_a(ctx->pll, clkdco, ctx->req_pck_min,\r\ndss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\r\ndsi_vm_calc_hsdiv_cb, ctx);\r\n}\r\nstatic bool dsi_vm_calc(struct dsi_data *dsi,\r\nconst struct omap_dss_dsi_config *cfg,\r\nstruct dsi_clk_calc_ctx *ctx)\r\n{\r\nconst struct omap_video_timings *t = cfg->timings;\r\nunsigned long clkin;\r\nunsigned long pll_min;\r\nunsigned long pll_max;\r\nint ndl = dsi->num_lanes_used - 1;\r\nint bitspp = dsi_get_pixel_size(cfg->pixel_format);\r\nunsigned long byteclk_min;\r\nclkin = clk_get_rate(dsi->pll.clkin);\r\nmemset(ctx, 0, sizeof(*ctx));\r\nctx->dsidev = dsi->pdev;\r\nctx->pll = &dsi->pll;\r\nctx->config = cfg;\r\nctx->req_pck_min = t->pixelclock - 1000;\r\nctx->req_pck_nom = t->pixelclock;\r\nctx->req_pck_max = t->pixelclock + 1000;\r\nbyteclk_min = div64_u64((u64)ctx->req_pck_min * bitspp, ndl * 8);\r\npll_min = max(cfg->hs_clk_min * 4, byteclk_min * 4 * 4);\r\nif (cfg->trans_mode == OMAP_DSS_DSI_BURST_MODE) {\r\npll_max = cfg->hs_clk_max * 4;\r\n} else {\r\nunsigned long byteclk_max;\r\nbyteclk_max = div64_u64((u64)ctx->req_pck_max * bitspp,\r\nndl * 8);\r\npll_max = byteclk_max * 4 * 4;\r\n}\r\nreturn dss_pll_calc_a(ctx->pll, clkin,\r\npll_min, pll_max,\r\ndsi_vm_calc_pll_cb, ctx);\r\n}\r\nstatic int dsi_set_config(struct omap_dss_device *dssdev,\r\nconst struct omap_dss_dsi_config *config)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dsi_clk_calc_ctx ctx;\r\nbool ok;\r\nint r;\r\nmutex_lock(&dsi->lock);\r\ndsi->pix_fmt = config->pixel_format;\r\ndsi->mode = config->mode;\r\nif (config->mode == OMAP_DSS_DSI_VIDEO_MODE)\r\nok = dsi_vm_calc(dsi, config, &ctx);\r\nelse\r\nok = dsi_cm_calc(dsi, config, &ctx);\r\nif (!ok) {\r\nDSSERR("failed to find suitable DSI clock settings\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\ndsi_pll_calc_dsi_fck(&ctx.dsi_cinfo);\r\nr = dsi_lp_clock_calc(ctx.dsi_cinfo.clkout[HSDIV_DSI],\r\nconfig->lp_clk_min, config->lp_clk_max, &dsi->user_lp_cinfo);\r\nif (r) {\r\nDSSERR("failed to find suitable DSI LP clock settings\n");\r\ngoto err;\r\n}\r\ndsi->user_dsi_cinfo = ctx.dsi_cinfo;\r\ndsi->user_dispc_cinfo = ctx.dispc_cinfo;\r\ndsi->timings = ctx.dispc_vm;\r\ndsi->vm_timings = ctx.dsi_vm;\r\nmutex_unlock(&dsi->lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&dsi->lock);\r\nreturn r;\r\n}\r\nstatic enum omap_channel dsi_get_channel(int module_id)\r\n{\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\ncase OMAPDSS_VER_AM43xx:\r\nDSSWARN("DSI not supported\n");\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_OMAP3630:\r\ncase OMAPDSS_VER_AM35xx:\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nswitch (module_id) {\r\ncase 0:\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\ncase 1:\r\nreturn OMAP_DSS_CHANNEL_LCD2;\r\ndefault:\r\nDSSWARN("unsupported module id\n");\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\n}\r\ncase OMAPDSS_VER_OMAP5:\r\nswitch (module_id) {\r\ncase 0:\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\ncase 1:\r\nreturn OMAP_DSS_CHANNEL_LCD3;\r\ndefault:\r\nDSSWARN("unsupported module id\n");\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\n}\r\ndefault:\r\nDSSWARN("unsupported DSS version\n");\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\n}\r\n}\r\nstatic int dsi_request_vc(struct omap_dss_device *dssdev, int *channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dsi->vc); i++) {\r\nif (!dsi->vc[i].dssdev) {\r\ndsi->vc[i].dssdev = dssdev;\r\n*channel = i;\r\nreturn 0;\r\n}\r\n}\r\nDSSERR("cannot get VC for display %s", dssdev->name);\r\nreturn -ENOSPC;\r\n}\r\nstatic int dsi_set_vc_id(struct omap_dss_device *dssdev, int channel, int vc_id)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (vc_id < 0 || vc_id > 3) {\r\nDSSERR("VC ID out of range\n");\r\nreturn -EINVAL;\r\n}\r\nif (channel < 0 || channel > 3) {\r\nDSSERR("Virtual Channel out of range\n");\r\nreturn -EINVAL;\r\n}\r\nif (dsi->vc[channel].dssdev != dssdev) {\r\nDSSERR("Virtual Channel not allocated to display %s\n",\r\ndssdev->name);\r\nreturn -EINVAL;\r\n}\r\ndsi->vc[channel].vc_id = vc_id;\r\nreturn 0;\r\n}\r\nstatic void dsi_release_vc(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif ((channel >= 0 && channel <= 3) &&\r\ndsi->vc[channel].dssdev == dssdev) {\r\ndsi->vc[channel].dssdev = NULL;\r\ndsi->vc[channel].vc_id = 0;\r\n}\r\n}\r\nstatic int dsi_get_clocks(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct clk *clk;\r\nclk = devm_clk_get(&dsidev->dev, "fck");\r\nif (IS_ERR(clk)) {\r\nDSSERR("can't get fck\n");\r\nreturn PTR_ERR(clk);\r\n}\r\ndsi->dss_clk = clk;\r\nreturn 0;\r\n}\r\nstatic int dsi_connect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nenum omap_channel dispc_channel = dssdev->dispc_channel;\r\nint r;\r\nr = dsi_regulator_init(dsidev);\r\nif (r)\r\nreturn r;\r\nr = dss_mgr_connect(dispc_channel, dssdev);\r\nif (r)\r\nreturn r;\r\nr = omapdss_output_set_device(dssdev, dst);\r\nif (r) {\r\nDSSERR("failed to connect output to new device: %s\n",\r\ndssdev->name);\r\ndss_mgr_disconnect(dispc_channel, dssdev);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dsi_disconnect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nenum omap_channel dispc_channel = dssdev->dispc_channel;\r\nWARN_ON(dst != dssdev->dst);\r\nif (dst != dssdev->dst)\r\nreturn;\r\nomapdss_output_unset_device(dssdev);\r\ndss_mgr_disconnect(dispc_channel, dssdev);\r\n}\r\nstatic void dsi_init_output(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_dss_device *out = &dsi->output;\r\nout->dev = &dsidev->dev;\r\nout->id = dsi->module_id == 0 ?\r\nOMAP_DSS_OUTPUT_DSI1 : OMAP_DSS_OUTPUT_DSI2;\r\nout->output_type = OMAP_DISPLAY_TYPE_DSI;\r\nout->name = dsi->module_id == 0 ? "dsi.0" : "dsi.1";\r\nout->dispc_channel = dsi_get_channel(dsi->module_id);\r\nout->ops.dsi = &dsi_ops;\r\nout->owner = THIS_MODULE;\r\nomapdss_register_output(out);\r\n}\r\nstatic void dsi_uninit_output(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_dss_device *out = &dsi->output;\r\nomapdss_unregister_output(out);\r\n}\r\nstatic int dsi_probe_of(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(pdev);\r\nstruct property *prop;\r\nu32 lane_arr[10];\r\nint len, num_pins;\r\nint r, i;\r\nstruct device_node *ep;\r\nstruct omap_dsi_pin_config pin_cfg;\r\nep = omapdss_of_get_first_endpoint(node);\r\nif (!ep)\r\nreturn 0;\r\nprop = of_find_property(ep, "lanes", &len);\r\nif (prop == NULL) {\r\ndev_err(&pdev->dev, "failed to find lane data\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nnum_pins = len / sizeof(u32);\r\nif (num_pins < 4 || num_pins % 2 != 0 ||\r\nnum_pins > dsi->num_lanes_supported * 2) {\r\ndev_err(&pdev->dev, "bad number of lanes\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nr = of_property_read_u32_array(ep, "lanes", lane_arr, num_pins);\r\nif (r) {\r\ndev_err(&pdev->dev, "failed to read lane data\n");\r\ngoto err;\r\n}\r\npin_cfg.num_pins = num_pins;\r\nfor (i = 0; i < num_pins; ++i)\r\npin_cfg.pins[i] = (int)lane_arr[i];\r\nr = dsi_configure_pins(&dsi->output, &pin_cfg);\r\nif (r) {\r\ndev_err(&pdev->dev, "failed to configure pins");\r\ngoto err;\r\n}\r\nof_node_put(ep);\r\nreturn 0;\r\nerr:\r\nof_node_put(ep);\r\nreturn r;\r\n}\r\nstatic int dsi_init_pll_data(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dss_pll *pll = &dsi->pll;\r\nstruct clk *clk;\r\nint r;\r\nclk = devm_clk_get(&dsidev->dev, "sys_clk");\r\nif (IS_ERR(clk)) {\r\nDSSERR("can't get sys_clk\n");\r\nreturn PTR_ERR(clk);\r\n}\r\npll->name = dsi->module_id == 0 ? "dsi0" : "dsi1";\r\npll->id = dsi->module_id == 0 ? DSS_PLL_DSI1 : DSS_PLL_DSI2;\r\npll->clkin = clk;\r\npll->base = dsi->pll_base;\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_OMAP3630:\r\ncase OMAPDSS_VER_AM35xx:\r\npll->hw = &dss_omap3_dsi_pll_hw;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\npll->hw = &dss_omap4_dsi_pll_hw;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP5:\r\npll->hw = &dss_omap5_dsi_pll_hw;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\npll->ops = &dsi_pll_ops;\r\nr = dss_pll_register(pll);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int dsi_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *dsidev = to_platform_device(dev);\r\nu32 rev;\r\nint r, i;\r\nstruct dsi_data *dsi;\r\nstruct resource *dsi_mem;\r\nstruct resource *res;\r\nstruct resource temp_res;\r\ndsi = devm_kzalloc(&dsidev->dev, sizeof(*dsi), GFP_KERNEL);\r\nif (!dsi)\r\nreturn -ENOMEM;\r\ndsi->pdev = dsidev;\r\ndev_set_drvdata(&dsidev->dev, dsi);\r\nspin_lock_init(&dsi->irq_lock);\r\nspin_lock_init(&dsi->errors_lock);\r\ndsi->errors = 0;\r\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\r\nspin_lock_init(&dsi->irq_stats_lock);\r\ndsi->irq_stats.last_reset = jiffies;\r\n#endif\r\nmutex_init(&dsi->lock);\r\nsema_init(&dsi->bus_lock, 1);\r\nINIT_DEFERRABLE_WORK(&dsi->framedone_timeout_work,\r\ndsi_framedone_timeout_work_callback);\r\n#ifdef DSI_CATCH_MISSING_TE\r\ninit_timer(&dsi->te_timer);\r\ndsi->te_timer.function = dsi_te_timeout;\r\ndsi->te_timer.data = 0;\r\n#endif\r\nres = platform_get_resource_byname(dsidev, IORESOURCE_MEM, "proto");\r\nif (!res) {\r\nres = platform_get_resource(dsidev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nDSSERR("can't get IORESOURCE_MEM DSI\n");\r\nreturn -EINVAL;\r\n}\r\ntemp_res.start = res->start;\r\ntemp_res.end = temp_res.start + DSI_PROTO_SZ - 1;\r\nres = &temp_res;\r\n}\r\ndsi_mem = res;\r\ndsi->proto_base = devm_ioremap(&dsidev->dev, res->start,\r\nresource_size(res));\r\nif (!dsi->proto_base) {\r\nDSSERR("can't ioremap DSI protocol engine\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource_byname(dsidev, IORESOURCE_MEM, "phy");\r\nif (!res) {\r\nres = platform_get_resource(dsidev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nDSSERR("can't get IORESOURCE_MEM DSI\n");\r\nreturn -EINVAL;\r\n}\r\ntemp_res.start = res->start + DSI_PHY_OFFSET;\r\ntemp_res.end = temp_res.start + DSI_PHY_SZ - 1;\r\nres = &temp_res;\r\n}\r\ndsi->phy_base = devm_ioremap(&dsidev->dev, res->start,\r\nresource_size(res));\r\nif (!dsi->proto_base) {\r\nDSSERR("can't ioremap DSI PHY\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource_byname(dsidev, IORESOURCE_MEM, "pll");\r\nif (!res) {\r\nres = platform_get_resource(dsidev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nDSSERR("can't get IORESOURCE_MEM DSI\n");\r\nreturn -EINVAL;\r\n}\r\ntemp_res.start = res->start + DSI_PLL_OFFSET;\r\ntemp_res.end = temp_res.start + DSI_PLL_SZ - 1;\r\nres = &temp_res;\r\n}\r\ndsi->pll_base = devm_ioremap(&dsidev->dev, res->start,\r\nresource_size(res));\r\nif (!dsi->proto_base) {\r\nDSSERR("can't ioremap DSI PLL\n");\r\nreturn -ENOMEM;\r\n}\r\ndsi->irq = platform_get_irq(dsi->pdev, 0);\r\nif (dsi->irq < 0) {\r\nDSSERR("platform_get_irq failed\n");\r\nreturn -ENODEV;\r\n}\r\nr = devm_request_irq(&dsidev->dev, dsi->irq, omap_dsi_irq_handler,\r\nIRQF_SHARED, dev_name(&dsidev->dev), dsi->pdev);\r\nif (r < 0) {\r\nDSSERR("request_irq failed\n");\r\nreturn r;\r\n}\r\nif (dsidev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nconst struct dsi_module_id_data *d;\r\nmatch = of_match_node(dsi_of_match, dsidev->dev.of_node);\r\nif (!match) {\r\nDSSERR("unsupported DSI module\n");\r\nreturn -ENODEV;\r\n}\r\nd = match->data;\r\nwhile (d->address != 0 && d->address != dsi_mem->start)\r\nd++;\r\nif (d->address == 0) {\r\nDSSERR("unsupported DSI module\n");\r\nreturn -ENODEV;\r\n}\r\ndsi->module_id = d->id;\r\n} else {\r\ndsi->module_id = dsidev->id;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(dsi->vc); i++) {\r\ndsi->vc[i].source = DSI_VC_SOURCE_L4;\r\ndsi->vc[i].dssdev = NULL;\r\ndsi->vc[i].vc_id = 0;\r\n}\r\nr = dsi_get_clocks(dsidev);\r\nif (r)\r\nreturn r;\r\ndsi_init_pll_data(dsidev);\r\npm_runtime_enable(&dsidev->dev);\r\nr = dsi_runtime_get(dsidev);\r\nif (r)\r\ngoto err_runtime_get;\r\nrev = dsi_read_reg(dsidev, DSI_REVISION);\r\ndev_dbg(&dsidev->dev, "OMAP DSI rev %d.%d\n",\r\nFLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\r\nif (dss_has_feature(FEAT_DSI_GNQ))\r\ndsi->num_lanes_supported = 1 + REG_GET(dsidev, DSI_GNQ, 11, 9);\r\nelse\r\ndsi->num_lanes_supported = 3;\r\ndsi->line_buffer_size = dsi_get_line_buf_size(dsidev);\r\ndsi_init_output(dsidev);\r\nif (dsidev->dev.of_node) {\r\nr = dsi_probe_of(dsidev);\r\nif (r) {\r\nDSSERR("Invalid DSI DT data\n");\r\ngoto err_probe_of;\r\n}\r\nr = of_platform_populate(dsidev->dev.of_node, NULL, NULL,\r\n&dsidev->dev);\r\nif (r)\r\nDSSERR("Failed to populate DSI child devices: %d\n", r);\r\n}\r\ndsi_runtime_put(dsidev);\r\nif (dsi->module_id == 0)\r\ndss_debugfs_create_file("dsi1_regs", dsi1_dump_regs);\r\nelse if (dsi->module_id == 1)\r\ndss_debugfs_create_file("dsi2_regs", dsi2_dump_regs);\r\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\r\nif (dsi->module_id == 0)\r\ndss_debugfs_create_file("dsi1_irqs", dsi1_dump_irqs);\r\nelse if (dsi->module_id == 1)\r\ndss_debugfs_create_file("dsi2_irqs", dsi2_dump_irqs);\r\n#endif\r\nreturn 0;\r\nerr_probe_of:\r\ndsi_uninit_output(dsidev);\r\ndsi_runtime_put(dsidev);\r\nerr_runtime_get:\r\npm_runtime_disable(&dsidev->dev);\r\nreturn r;\r\n}\r\nstatic void dsi_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *dsidev = to_platform_device(dev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nof_platform_depopulate(&dsidev->dev);\r\nWARN_ON(dsi->scp_clk_refcount > 0);\r\ndss_pll_unregister(&dsi->pll);\r\ndsi_uninit_output(dsidev);\r\npm_runtime_disable(&dsidev->dev);\r\nif (dsi->vdds_dsi_reg != NULL && dsi->vdds_dsi_enabled) {\r\nregulator_disable(dsi->vdds_dsi_reg);\r\ndsi->vdds_dsi_enabled = false;\r\n}\r\n}\r\nstatic int dsi_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &dsi_component_ops);\r\n}\r\nstatic int dsi_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &dsi_component_ops);\r\nreturn 0;\r\n}\r\nstatic int dsi_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(pdev);\r\ndsi->is_enabled = false;\r\nsmp_wmb();\r\nsynchronize_irq(dsi->irq);\r\ndispc_runtime_put();\r\nreturn 0;\r\n}\r\nstatic int dsi_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(pdev);\r\nint r;\r\nr = dispc_runtime_get();\r\nif (r)\r\nreturn r;\r\ndsi->is_enabled = true;\r\nsmp_wmb();\r\nreturn 0;\r\n}\r\nint __init dsi_init_platform_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_dsihw_driver);\r\n}\r\nvoid dsi_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_dsihw_driver);\r\n}
