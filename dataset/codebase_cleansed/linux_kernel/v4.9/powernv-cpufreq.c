static inline int idx_to_pstate(unsigned int i)\r\n{\r\nif (unlikely(i >= powernv_pstate_info.nr_pstates)) {\r\npr_warn_once("index %u is out of bound\n", i);\r\nreturn powernv_freqs[powernv_pstate_info.nominal].driver_data;\r\n}\r\nreturn powernv_freqs[i].driver_data;\r\n}\r\nstatic inline unsigned int pstate_to_idx(int pstate)\r\n{\r\nint min = powernv_freqs[powernv_pstate_info.min].driver_data;\r\nint max = powernv_freqs[powernv_pstate_info.max].driver_data;\r\nif (min > 0) {\r\nif (unlikely((pstate < max) || (pstate > min))) {\r\npr_warn_once("pstate %d is out of bound\n", pstate);\r\nreturn powernv_pstate_info.nominal;\r\n}\r\n} else {\r\nif (unlikely((pstate > max) || (pstate < min))) {\r\npr_warn_once("pstate %d is out of bound\n", pstate);\r\nreturn powernv_pstate_info.nominal;\r\n}\r\n}\r\nreturn abs(pstate - idx_to_pstate(powernv_pstate_info.max));\r\n}\r\nstatic inline void reset_gpstates(struct cpufreq_policy *policy)\r\n{\r\nstruct global_pstate_info *gpstates = policy->driver_data;\r\ngpstates->highest_lpstate_idx = 0;\r\ngpstates->elapsed_time = 0;\r\ngpstates->last_sampled_time = 0;\r\ngpstates->last_lpstate_idx = 0;\r\ngpstates->last_gpstate_idx = 0;\r\n}\r\nstatic int init_powernv_pstates(void)\r\n{\r\nstruct device_node *power_mgt;\r\nint i, nr_pstates = 0;\r\nconst __be32 *pstate_ids, *pstate_freqs;\r\nu32 len_ids, len_freqs;\r\nu32 pstate_min, pstate_max, pstate_nominal;\r\npower_mgt = of_find_node_by_path("/ibm,opal/power-mgt");\r\nif (!power_mgt) {\r\npr_warn("power-mgt node not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(power_mgt, "ibm,pstate-min", &pstate_min)) {\r\npr_warn("ibm,pstate-min node not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(power_mgt, "ibm,pstate-max", &pstate_max)) {\r\npr_warn("ibm,pstate-max node not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(power_mgt, "ibm,pstate-nominal",\r\n&pstate_nominal)) {\r\npr_warn("ibm,pstate-nominal not found\n");\r\nreturn -ENODEV;\r\n}\r\npr_info("cpufreq pstate min %d nominal %d max %d\n", pstate_min,\r\npstate_nominal, pstate_max);\r\npstate_ids = of_get_property(power_mgt, "ibm,pstate-ids", &len_ids);\r\nif (!pstate_ids) {\r\npr_warn("ibm,pstate-ids not found\n");\r\nreturn -ENODEV;\r\n}\r\npstate_freqs = of_get_property(power_mgt, "ibm,pstate-frequencies-mhz",\r\n&len_freqs);\r\nif (!pstate_freqs) {\r\npr_warn("ibm,pstate-frequencies-mhz not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (len_ids != len_freqs) {\r\npr_warn("Entries in ibm,pstate-ids and "\r\n"ibm,pstate-frequencies-mhz does not match\n");\r\n}\r\nnr_pstates = min(len_ids, len_freqs) / sizeof(u32);\r\nif (!nr_pstates) {\r\npr_warn("No PStates found\n");\r\nreturn -ENODEV;\r\n}\r\npowernv_pstate_info.nr_pstates = nr_pstates;\r\npr_debug("NR PStates %d\n", nr_pstates);\r\nfor (i = 0; i < nr_pstates; i++) {\r\nu32 id = be32_to_cpu(pstate_ids[i]);\r\nu32 freq = be32_to_cpu(pstate_freqs[i]);\r\npr_debug("PState id %d freq %d MHz\n", id, freq);\r\npowernv_freqs[i].frequency = freq * 1000;\r\npowernv_freqs[i].driver_data = id;\r\nif (id == pstate_max)\r\npowernv_pstate_info.max = i;\r\nelse if (id == pstate_nominal)\r\npowernv_pstate_info.nominal = i;\r\nelse if (id == pstate_min)\r\npowernv_pstate_info.min = i;\r\n}\r\npowernv_freqs[i].frequency = CPUFREQ_TABLE_END;\r\nreturn 0;\r\n}\r\nstatic unsigned int pstate_id_to_freq(int pstate_id)\r\n{\r\nint i;\r\ni = pstate_to_idx(pstate_id);\r\nif (i >= powernv_pstate_info.nr_pstates || i < 0) {\r\npr_warn("PState id %d outside of PState table, "\r\n"reporting nominal id %d instead\n",\r\npstate_id, idx_to_pstate(powernv_pstate_info.nominal));\r\ni = powernv_pstate_info.nominal;\r\n}\r\nreturn powernv_freqs[i].frequency;\r\n}\r\nstatic ssize_t cpuinfo_nominal_freq_show(struct cpufreq_policy *policy,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%u\n",\r\npowernv_freqs[powernv_pstate_info.nominal].frequency);\r\n}\r\nstatic inline unsigned long get_pmspr(unsigned long sprn)\r\n{\r\nswitch (sprn) {\r\ncase SPRN_PMCR:\r\nreturn mfspr(SPRN_PMCR);\r\ncase SPRN_PMICR:\r\nreturn mfspr(SPRN_PMICR);\r\ncase SPRN_PMSR:\r\nreturn mfspr(SPRN_PMSR);\r\n}\r\nBUG();\r\n}\r\nstatic inline void set_pmspr(unsigned long sprn, unsigned long val)\r\n{\r\nswitch (sprn) {\r\ncase SPRN_PMCR:\r\nmtspr(SPRN_PMCR, val);\r\nreturn;\r\ncase SPRN_PMICR:\r\nmtspr(SPRN_PMICR, val);\r\nreturn;\r\n}\r\nBUG();\r\n}\r\nstatic void powernv_read_cpu_freq(void *arg)\r\n{\r\nunsigned long pmspr_val;\r\ns8 local_pstate_id;\r\nstruct powernv_smp_call_data *freq_data = arg;\r\npmspr_val = get_pmspr(SPRN_PMSR);\r\nlocal_pstate_id = (pmspr_val >> 48) & 0xFF;\r\nfreq_data->pstate_id = local_pstate_id;\r\nfreq_data->freq = pstate_id_to_freq(freq_data->pstate_id);\r\npr_debug("cpu %d pmsr %016lX pstate_id %d frequency %d kHz\n",\r\nraw_smp_processor_id(), pmspr_val, freq_data->pstate_id,\r\nfreq_data->freq);\r\n}\r\nstatic unsigned int powernv_cpufreq_get(unsigned int cpu)\r\n{\r\nstruct powernv_smp_call_data freq_data;\r\nsmp_call_function_any(cpu_sibling_mask(cpu), powernv_read_cpu_freq,\r\n&freq_data, 1);\r\nreturn freq_data.freq;\r\n}\r\nstatic void set_pstate(void *data)\r\n{\r\nunsigned long val;\r\nstruct powernv_smp_call_data *freq_data = data;\r\nunsigned long pstate_ul = freq_data->pstate_id;\r\nunsigned long gpstate_ul = freq_data->gpstate_id;\r\nval = get_pmspr(SPRN_PMCR);\r\nval = val & 0x0000FFFFFFFFFFFFULL;\r\npstate_ul = pstate_ul & 0xFF;\r\ngpstate_ul = gpstate_ul & 0xFF;\r\nval = val | (gpstate_ul << 56) | (pstate_ul << 48);\r\npr_debug("Setting cpu %d pmcr to %016lX\n",\r\nraw_smp_processor_id(), val);\r\nset_pmspr(SPRN_PMCR, val);\r\n}\r\nstatic inline unsigned int get_nominal_index(void)\r\n{\r\nreturn powernv_pstate_info.nominal;\r\n}\r\nstatic void powernv_cpufreq_throttle_check(void *data)\r\n{\r\nstruct chip *chip;\r\nunsigned int cpu = smp_processor_id();\r\nunsigned long pmsr;\r\nint pmsr_pmax;\r\nunsigned int pmsr_pmax_idx;\r\npmsr = get_pmspr(SPRN_PMSR);\r\nchip = this_cpu_read(chip_info);\r\npmsr_pmax = (s8)PMSR_MAX(pmsr);\r\npmsr_pmax_idx = pstate_to_idx(pmsr_pmax);\r\nif (pmsr_pmax_idx != powernv_pstate_info.max) {\r\nif (chip->throttled)\r\ngoto next;\r\nchip->throttled = true;\r\nif (pmsr_pmax_idx > powernv_pstate_info.nominal) {\r\npr_warn_once("CPU %d on Chip %u has Pmax(%d) reduced below nominal frequency(%d)\n",\r\ncpu, chip->id, pmsr_pmax,\r\nidx_to_pstate(powernv_pstate_info.nominal));\r\nchip->throttle_sub_turbo++;\r\n} else {\r\nchip->throttle_turbo++;\r\n}\r\ntrace_powernv_throttle(chip->id,\r\nthrottle_reason[chip->throttle_reason],\r\npmsr_pmax);\r\n} else if (chip->throttled) {\r\nchip->throttled = false;\r\ntrace_powernv_throttle(chip->id,\r\nthrottle_reason[chip->throttle_reason],\r\npmsr_pmax);\r\n}\r\nnext:\r\nif (pmsr & PMSR_PSAFE_ENABLE) {\r\nthrottled = true;\r\npr_info("Pstate set to safe frequency\n");\r\n}\r\nif (pmsr & PMSR_SPR_EM_DISABLE) {\r\nthrottled = true;\r\npr_info("Frequency Control disabled from OS\n");\r\n}\r\nif (throttled) {\r\npr_info("PMSR = %16lx\n", pmsr);\r\npr_warn("CPU Frequency could be throttled\n");\r\n}\r\n}\r\nstatic inline int calc_global_pstate(unsigned int elapsed_time,\r\nint highest_lpstate_idx,\r\nint local_pstate_idx)\r\n{\r\nint index_diff;\r\nindex_diff = ((int)ramp_down_percent(elapsed_time) *\r\n(powernv_pstate_info.min - highest_lpstate_idx)) / 100;\r\nif (highest_lpstate_idx + index_diff >= local_pstate_idx)\r\nreturn local_pstate_idx;\r\nelse\r\nreturn highest_lpstate_idx + index_diff;\r\n}\r\nstatic inline void queue_gpstate_timer(struct global_pstate_info *gpstates)\r\n{\r\nunsigned int timer_interval;\r\nif ((gpstates->elapsed_time + GPSTATE_TIMER_INTERVAL)\r\n> MAX_RAMP_DOWN_TIME)\r\ntimer_interval = MAX_RAMP_DOWN_TIME - gpstates->elapsed_time;\r\nelse\r\ntimer_interval = GPSTATE_TIMER_INTERVAL;\r\nmod_timer(&gpstates->timer, jiffies + msecs_to_jiffies(timer_interval));\r\n}\r\nvoid gpstate_timer_handler(unsigned long data)\r\n{\r\nstruct cpufreq_policy *policy = (struct cpufreq_policy *)data;\r\nstruct global_pstate_info *gpstates = policy->driver_data;\r\nint gpstate_idx;\r\nunsigned int time_diff = jiffies_to_msecs(jiffies)\r\n- gpstates->last_sampled_time;\r\nstruct powernv_smp_call_data freq_data;\r\nif (!spin_trylock(&gpstates->gpstate_lock))\r\nreturn;\r\ngpstates->last_sampled_time += time_diff;\r\ngpstates->elapsed_time += time_diff;\r\nfreq_data.pstate_id = idx_to_pstate(gpstates->last_lpstate_idx);\r\nif ((gpstates->last_gpstate_idx == gpstates->last_lpstate_idx) ||\r\n(gpstates->elapsed_time > MAX_RAMP_DOWN_TIME)) {\r\ngpstate_idx = pstate_to_idx(freq_data.pstate_id);\r\nreset_gpstates(policy);\r\ngpstates->highest_lpstate_idx = gpstate_idx;\r\n} else {\r\ngpstate_idx = calc_global_pstate(gpstates->elapsed_time,\r\ngpstates->highest_lpstate_idx,\r\ngpstates->last_lpstate_idx);\r\n}\r\nif (gpstate_idx != gpstates->last_lpstate_idx)\r\nqueue_gpstate_timer(gpstates);\r\nfreq_data.gpstate_id = idx_to_pstate(gpstate_idx);\r\ngpstates->last_gpstate_idx = pstate_to_idx(freq_data.gpstate_id);\r\ngpstates->last_lpstate_idx = pstate_to_idx(freq_data.pstate_id);\r\nspin_unlock(&gpstates->gpstate_lock);\r\nsmp_call_function_any(policy->cpus, set_pstate, &freq_data, 1);\r\n}\r\nstatic int powernv_cpufreq_target_index(struct cpufreq_policy *policy,\r\nunsigned int new_index)\r\n{\r\nstruct powernv_smp_call_data freq_data;\r\nunsigned int cur_msec, gpstate_idx;\r\nstruct global_pstate_info *gpstates = policy->driver_data;\r\nif (unlikely(rebooting) && new_index != get_nominal_index())\r\nreturn 0;\r\nif (!throttled)\r\npowernv_cpufreq_throttle_check(NULL);\r\ncur_msec = jiffies_to_msecs(get_jiffies_64());\r\nspin_lock(&gpstates->gpstate_lock);\r\nfreq_data.pstate_id = idx_to_pstate(new_index);\r\nif (!gpstates->last_sampled_time) {\r\ngpstate_idx = new_index;\r\ngpstates->highest_lpstate_idx = new_index;\r\ngoto gpstates_done;\r\n}\r\nif (gpstates->last_gpstate_idx < new_index) {\r\ngpstates->elapsed_time += cur_msec -\r\ngpstates->last_sampled_time;\r\nif (gpstates->elapsed_time > MAX_RAMP_DOWN_TIME) {\r\nreset_gpstates(policy);\r\ngpstates->highest_lpstate_idx = new_index;\r\ngpstate_idx = new_index;\r\n} else {\r\ngpstate_idx = calc_global_pstate(gpstates->elapsed_time,\r\ngpstates->highest_lpstate_idx,\r\nnew_index);\r\n}\r\n} else {\r\nreset_gpstates(policy);\r\ngpstates->highest_lpstate_idx = new_index;\r\ngpstate_idx = new_index;\r\n}\r\nif (gpstate_idx != new_index)\r\nqueue_gpstate_timer(gpstates);\r\nelse\r\ndel_timer_sync(&gpstates->timer);\r\ngpstates_done:\r\nfreq_data.gpstate_id = idx_to_pstate(gpstate_idx);\r\ngpstates->last_sampled_time = cur_msec;\r\ngpstates->last_gpstate_idx = gpstate_idx;\r\ngpstates->last_lpstate_idx = new_index;\r\nspin_unlock(&gpstates->gpstate_lock);\r\nsmp_call_function_any(policy->cpus, set_pstate, &freq_data, 1);\r\nreturn 0;\r\n}\r\nstatic int powernv_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint base, i, ret;\r\nstruct kernfs_node *kn;\r\nstruct global_pstate_info *gpstates;\r\nbase = cpu_first_thread_sibling(policy->cpu);\r\nfor (i = 0; i < threads_per_core; i++)\r\ncpumask_set_cpu(base + i, policy->cpus);\r\nkn = kernfs_find_and_get(policy->kobj.sd, throttle_attr_grp.name);\r\nif (!kn) {\r\nint ret;\r\nret = sysfs_create_group(&policy->kobj, &throttle_attr_grp);\r\nif (ret) {\r\npr_info("Failed to create throttle stats directory for cpu %d\n",\r\npolicy->cpu);\r\nreturn ret;\r\n}\r\n} else {\r\nkernfs_put(kn);\r\n}\r\ngpstates = kzalloc(sizeof(*gpstates), GFP_KERNEL);\r\nif (!gpstates)\r\nreturn -ENOMEM;\r\npolicy->driver_data = gpstates;\r\ninit_timer_pinned_deferrable(&gpstates->timer);\r\ngpstates->timer.data = (unsigned long)policy;\r\ngpstates->timer.function = gpstate_timer_handler;\r\ngpstates->timer.expires = jiffies +\r\nmsecs_to_jiffies(GPSTATE_TIMER_INTERVAL);\r\nspin_lock_init(&gpstates->gpstate_lock);\r\nret = cpufreq_table_validate_and_show(policy, powernv_freqs);\r\nif (ret < 0)\r\nkfree(policy->driver_data);\r\nreturn ret;\r\n}\r\nstatic int powernv_cpufreq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nkfree(policy->driver_data);\r\nreturn 0;\r\n}\r\nstatic int powernv_cpufreq_reboot_notifier(struct notifier_block *nb,\r\nunsigned long action, void *unused)\r\n{\r\nint cpu;\r\nstruct cpufreq_policy cpu_policy;\r\nrebooting = true;\r\nfor_each_online_cpu(cpu) {\r\ncpufreq_get_policy(&cpu_policy, cpu);\r\npowernv_cpufreq_target_index(&cpu_policy, get_nominal_index());\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid powernv_cpufreq_work_fn(struct work_struct *work)\r\n{\r\nstruct chip *chip = container_of(work, struct chip, throttle);\r\nunsigned int cpu;\r\ncpumask_t mask;\r\nget_online_cpus();\r\ncpumask_and(&mask, &chip->mask, cpu_online_mask);\r\nsmp_call_function_any(&mask,\r\npowernv_cpufreq_throttle_check, NULL, 0);\r\nif (!chip->restore)\r\ngoto out;\r\nchip->restore = false;\r\nfor_each_cpu(cpu, &mask) {\r\nint index;\r\nstruct cpufreq_policy policy;\r\ncpufreq_get_policy(&policy, cpu);\r\nindex = cpufreq_table_find_index_c(&policy, policy.cur);\r\npowernv_cpufreq_target_index(&policy, index);\r\ncpumask_andnot(&mask, &mask, policy.cpus);\r\n}\r\nout:\r\nput_online_cpus();\r\n}\r\nstatic int powernv_cpufreq_occ_msg(struct notifier_block *nb,\r\nunsigned long msg_type, void *_msg)\r\n{\r\nstruct opal_msg *msg = _msg;\r\nstruct opal_occ_msg omsg;\r\nint i;\r\nif (msg_type != OPAL_MSG_OCC)\r\nreturn 0;\r\nomsg.type = be64_to_cpu(msg->params[0]);\r\nswitch (omsg.type) {\r\ncase OCC_RESET:\r\nocc_reset = true;\r\npr_info("OCC (On Chip Controller - enforces hard thermal/power limits) Resetting\n");\r\nif (!throttled) {\r\nthrottled = true;\r\npr_warn("CPU frequency is throttled for duration\n");\r\n}\r\nbreak;\r\ncase OCC_LOAD:\r\npr_info("OCC Loading, CPU frequency is throttled until OCC is started\n");\r\nbreak;\r\ncase OCC_THROTTLE:\r\nomsg.chip = be64_to_cpu(msg->params[1]);\r\nomsg.throttle_status = be64_to_cpu(msg->params[2]);\r\nif (occ_reset) {\r\nocc_reset = false;\r\nthrottled = false;\r\npr_info("OCC Active, CPU frequency is no longer throttled\n");\r\nfor (i = 0; i < nr_chips; i++) {\r\nchips[i].restore = true;\r\nschedule_work(&chips[i].throttle);\r\n}\r\nreturn 0;\r\n}\r\nfor (i = 0; i < nr_chips; i++)\r\nif (chips[i].id == omsg.chip)\r\nbreak;\r\nif (omsg.throttle_status >= 0 &&\r\nomsg.throttle_status <= OCC_MAX_THROTTLE_STATUS) {\r\nchips[i].throttle_reason = omsg.throttle_status;\r\nchips[i].reason[omsg.throttle_status]++;\r\n}\r\nif (!omsg.throttle_status)\r\nchips[i].restore = true;\r\nschedule_work(&chips[i].throttle);\r\n}\r\nreturn 0;\r\n}\r\nstatic void powernv_cpufreq_stop_cpu(struct cpufreq_policy *policy)\r\n{\r\nstruct powernv_smp_call_data freq_data;\r\nstruct global_pstate_info *gpstates = policy->driver_data;\r\nfreq_data.pstate_id = idx_to_pstate(powernv_pstate_info.min);\r\nfreq_data.gpstate_id = idx_to_pstate(powernv_pstate_info.min);\r\nsmp_call_function_single(policy->cpu, set_pstate, &freq_data, 1);\r\ndel_timer_sync(&gpstates->timer);\r\n}\r\nstatic int init_chip_info(void)\r\n{\r\nunsigned int chip[256];\r\nunsigned int cpu, i;\r\nunsigned int prev_chip_id = UINT_MAX;\r\nfor_each_possible_cpu(cpu) {\r\nunsigned int id = cpu_to_chip_id(cpu);\r\nif (prev_chip_id != id) {\r\nprev_chip_id = id;\r\nchip[nr_chips++] = id;\r\n}\r\n}\r\nchips = kcalloc(nr_chips, sizeof(struct chip), GFP_KERNEL);\r\nif (!chips)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nr_chips; i++) {\r\nchips[i].id = chip[i];\r\ncpumask_copy(&chips[i].mask, cpumask_of_node(chip[i]));\r\nINIT_WORK(&chips[i].throttle, powernv_cpufreq_work_fn);\r\nfor_each_cpu(cpu, &chips[i].mask)\r\nper_cpu(chip_info, cpu) = &chips[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void clean_chip_info(void)\r\n{\r\nkfree(chips);\r\n}\r\nstatic inline void unregister_all_notifiers(void)\r\n{\r\nopal_message_notifier_unregister(OPAL_MSG_OCC,\r\n&powernv_cpufreq_opal_nb);\r\nunregister_reboot_notifier(&powernv_cpufreq_reboot_nb);\r\n}\r\nstatic int __init powernv_cpufreq_init(void)\r\n{\r\nint rc = 0;\r\nif (!firmware_has_feature(FW_FEATURE_OPAL))\r\nreturn -ENODEV;\r\nrc = init_powernv_pstates();\r\nif (rc)\r\ngoto out;\r\nrc = init_chip_info();\r\nif (rc)\r\ngoto out;\r\nregister_reboot_notifier(&powernv_cpufreq_reboot_nb);\r\nopal_message_notifier_register(OPAL_MSG_OCC, &powernv_cpufreq_opal_nb);\r\nrc = cpufreq_register_driver(&powernv_cpufreq_driver);\r\nif (!rc)\r\nreturn 0;\r\npr_info("Failed to register the cpufreq driver (%d)\n", rc);\r\nunregister_all_notifiers();\r\nclean_chip_info();\r\nout:\r\npr_info("Platform driver disabled. System does not support PState control\n");\r\nreturn rc;\r\n}\r\nstatic void __exit powernv_cpufreq_exit(void)\r\n{\r\ncpufreq_unregister_driver(&powernv_cpufreq_driver);\r\nunregister_all_notifiers();\r\nclean_chip_info();\r\n}
