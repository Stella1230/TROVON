static int efi_get_secureboot(efi_system_table_t *sys_table_arg)\r\n{\r\nstatic efi_char16_t const sb_var_name[] = {\r\n'S', 'e', 'c', 'u', 'r', 'e', 'B', 'o', 'o', 't', 0 };\r\nstatic efi_char16_t const sm_var_name[] = {\r\n'S', 'e', 't', 'u', 'p', 'M', 'o', 'd', 'e', 0 };\r\nefi_guid_t var_guid = EFI_GLOBAL_VARIABLE_GUID;\r\nefi_get_variable_t *f_getvar = sys_table_arg->runtime->get_variable;\r\nu8 val;\r\nunsigned long size = sizeof(val);\r\nefi_status_t status;\r\nstatus = f_getvar((efi_char16_t *)sb_var_name, (efi_guid_t *)&var_guid,\r\nNULL, &size, &val);\r\nif (status != EFI_SUCCESS)\r\ngoto out_efi_err;\r\nif (val == 0)\r\nreturn 0;\r\nstatus = f_getvar((efi_char16_t *)sm_var_name, (efi_guid_t *)&var_guid,\r\nNULL, &size, &val);\r\nif (status != EFI_SUCCESS)\r\ngoto out_efi_err;\r\nif (val == 1)\r\nreturn 0;\r\nreturn 1;\r\nout_efi_err:\r\nswitch (status) {\r\ncase EFI_NOT_FOUND:\r\nreturn 0;\r\ncase EFI_DEVICE_ERROR:\r\nreturn -EIO;\r\ncase EFI_SECURITY_VIOLATION:\r\nreturn -EACCES;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nefi_status_t efi_open_volume(efi_system_table_t *sys_table_arg,\r\nvoid *__image, void **__fh)\r\n{\r\nefi_file_io_interface_t *io;\r\nefi_loaded_image_t *image = __image;\r\nefi_file_handle_t *fh;\r\nefi_guid_t fs_proto = EFI_FILE_SYSTEM_GUID;\r\nefi_status_t status;\r\nvoid *handle = (void *)(unsigned long)image->device_handle;\r\nstatus = sys_table_arg->boottime->handle_protocol(handle,\r\n&fs_proto, (void **)&io);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to handle fs_proto\n");\r\nreturn status;\r\n}\r\nstatus = io->open_volume(io, &fh);\r\nif (status != EFI_SUCCESS)\r\nefi_printk(sys_table_arg, "Failed to open volume\n");\r\n*__fh = fh;\r\nreturn status;\r\n}\r\nefi_status_t efi_file_close(void *handle)\r\n{\r\nefi_file_handle_t *fh = handle;\r\nreturn fh->close(handle);\r\n}\r\nefi_status_t\r\nefi_file_read(void *handle, unsigned long *size, void *addr)\r\n{\r\nefi_file_handle_t *fh = handle;\r\nreturn fh->read(handle, size, addr);\r\n}\r\nefi_status_t\r\nefi_file_size(efi_system_table_t *sys_table_arg, void *__fh,\r\nefi_char16_t *filename_16, void **handle, u64 *file_sz)\r\n{\r\nefi_file_handle_t *h, *fh = __fh;\r\nefi_file_info_t *info;\r\nefi_status_t status;\r\nefi_guid_t info_guid = EFI_FILE_INFO_ID;\r\nunsigned long info_sz;\r\nstatus = fh->open(fh, &h, filename_16, EFI_FILE_MODE_READ, (u64)0);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to open file: ");\r\nefi_char16_printk(sys_table_arg, filename_16);\r\nefi_printk(sys_table_arg, "\n");\r\nreturn status;\r\n}\r\n*handle = h;\r\ninfo_sz = 0;\r\nstatus = h->get_info(h, &info_guid, &info_sz, NULL);\r\nif (status != EFI_BUFFER_TOO_SMALL) {\r\nefi_printk(sys_table_arg, "Failed to get file info size\n");\r\nreturn status;\r\n}\r\ngrow:\r\nstatus = sys_table_arg->boottime->allocate_pool(EFI_LOADER_DATA,\r\ninfo_sz, (void **)&info);\r\nif (status != EFI_SUCCESS) {\r\nefi_printk(sys_table_arg, "Failed to alloc mem for file info\n");\r\nreturn status;\r\n}\r\nstatus = h->get_info(h, &info_guid, &info_sz,\r\ninfo);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nsys_table_arg->boottime->free_pool(info);\r\ngoto grow;\r\n}\r\n*file_sz = info->file_size;\r\nsys_table_arg->boottime->free_pool(info);\r\nif (status != EFI_SUCCESS)\r\nefi_printk(sys_table_arg, "Failed to get initrd info\n");\r\nreturn status;\r\n}\r\nvoid efi_char16_printk(efi_system_table_t *sys_table_arg,\r\nefi_char16_t *str)\r\n{\r\nstruct efi_simple_text_output_protocol *out;\r\nout = (struct efi_simple_text_output_protocol *)sys_table_arg->con_out;\r\nout->output_string(out, str);\r\n}\r\nstatic struct screen_info *setup_graphics(efi_system_table_t *sys_table_arg)\r\n{\r\nefi_guid_t gop_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;\r\nefi_status_t status;\r\nunsigned long size;\r\nvoid **gop_handle = NULL;\r\nstruct screen_info *si = NULL;\r\nsize = 0;\r\nstatus = efi_call_early(locate_handle, EFI_LOCATE_BY_PROTOCOL,\r\n&gop_proto, NULL, &size, gop_handle);\r\nif (status == EFI_BUFFER_TOO_SMALL) {\r\nsi = alloc_screen_info(sys_table_arg);\r\nif (!si)\r\nreturn NULL;\r\nefi_setup_gop(sys_table_arg, si, &gop_proto, size);\r\n}\r\nreturn si;\r\n}\r\nunsigned long efi_entry(void *handle, efi_system_table_t *sys_table,\r\nunsigned long *image_addr)\r\n{\r\nefi_loaded_image_t *image;\r\nefi_status_t status;\r\nunsigned long image_size = 0;\r\nunsigned long dram_base;\r\nunsigned long initrd_addr;\r\nu64 initrd_size = 0;\r\nunsigned long fdt_addr = 0;\r\nunsigned long fdt_size = 0;\r\nchar *cmdline_ptr = NULL;\r\nint cmdline_size = 0;\r\nunsigned long new_fdt_addr;\r\nefi_guid_t loaded_image_proto = LOADED_IMAGE_PROTOCOL_GUID;\r\nunsigned long reserve_addr = 0;\r\nunsigned long reserve_size = 0;\r\nint secure_boot = 0;\r\nstruct screen_info *si;\r\nif (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)\r\ngoto fail;\r\npr_efi(sys_table, "Booting Linux Kernel...\n");\r\nstatus = check_platform_features(sys_table);\r\nif (status != EFI_SUCCESS)\r\ngoto fail;\r\nstatus = sys_table->boottime->handle_protocol(handle,\r\n&loaded_image_proto, (void *)&image);\r\nif (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table, "Failed to get loaded image protocol\n");\r\ngoto fail;\r\n}\r\ndram_base = get_dram_base(sys_table);\r\nif (dram_base == EFI_ERROR) {\r\npr_efi_err(sys_table, "Failed to find DRAM base\n");\r\ngoto fail;\r\n}\r\ncmdline_ptr = efi_convert_cmdline(sys_table, image, &cmdline_size);\r\nif (!cmdline_ptr) {\r\npr_efi_err(sys_table, "getting command line via LOADED_IMAGE_PROTOCOL\n");\r\ngoto fail;\r\n}\r\nif (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) {\r\nstatic const u8 default_cmdline[] = CONFIG_CMDLINE;\r\nconst u8 *str, *cmdline = cmdline_ptr;\r\nif (IS_ENABLED(CONFIG_CMDLINE_FORCE))\r\ncmdline = default_cmdline;\r\nstr = strstr(cmdline, "nokaslr");\r\nif (str == cmdline || (str > cmdline && *(str - 1) == ' '))\r\n__nokaslr = true;\r\n}\r\nsi = setup_graphics(sys_table);\r\nstatus = handle_kernel_image(sys_table, image_addr, &image_size,\r\n&reserve_addr,\r\n&reserve_size,\r\ndram_base, image);\r\nif (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table, "Failed to relocate kernel\n");\r\ngoto fail_free_cmdline;\r\n}\r\nstatus = efi_parse_options(cmdline_ptr);\r\nif (status != EFI_SUCCESS)\r\npr_efi_err(sys_table, "Failed to parse EFI cmdline options\n");\r\nsecure_boot = efi_get_secureboot(sys_table);\r\nif (secure_boot > 0)\r\npr_efi(sys_table, "UEFI Secure Boot is enabled.\n");\r\nif (secure_boot < 0) {\r\npr_efi_err(sys_table,\r\n"could not determine UEFI Secure Boot status.\n");\r\n}\r\nif (secure_boot != 0 && strstr(cmdline_ptr, "dtb=")) {\r\npr_efi(sys_table, "Ignoring DTB from command line.\n");\r\n} else {\r\nstatus = handle_cmdline_files(sys_table, image, cmdline_ptr,\r\n"dtb=",\r\n~0UL, &fdt_addr, &fdt_size);\r\nif (status != EFI_SUCCESS) {\r\npr_efi_err(sys_table, "Failed to load device tree!\n");\r\ngoto fail_free_image;\r\n}\r\n}\r\nif (fdt_addr) {\r\npr_efi(sys_table, "Using DTB from command line\n");\r\n} else {\r\nfdt_addr = (uintptr_t)get_fdt(sys_table, &fdt_size);\r\nif (fdt_addr)\r\npr_efi(sys_table, "Using DTB from configuration table\n");\r\n}\r\nif (!fdt_addr)\r\npr_efi(sys_table, "Generating empty DTB\n");\r\nstatus = handle_cmdline_files(sys_table, image, cmdline_ptr,\r\n"initrd=", dram_base + SZ_512M,\r\n(unsigned long *)&initrd_addr,\r\n(unsigned long *)&initrd_size);\r\nif (status != EFI_SUCCESS)\r\npr_efi_err(sys_table, "Failed initrd from command line!\n");\r\nnew_fdt_addr = fdt_addr;\r\nstatus = allocate_new_fdt_and_exit_boot(sys_table, handle,\r\n&new_fdt_addr, dram_base + MAX_FDT_OFFSET,\r\ninitrd_addr, initrd_size, cmdline_ptr,\r\nfdt_addr, fdt_size);\r\nif (status == EFI_SUCCESS)\r\nreturn new_fdt_addr;\r\npr_efi_err(sys_table, "Failed to update FDT and exit boot services\n");\r\nefi_free(sys_table, initrd_size, initrd_addr);\r\nefi_free(sys_table, fdt_size, fdt_addr);\r\nfail_free_image:\r\nefi_free(sys_table, image_size, *image_addr);\r\nefi_free(sys_table, reserve_size, reserve_addr);\r\nfail_free_cmdline:\r\nfree_screen_info(sys_table, si);\r\nefi_free(sys_table, cmdline_size, (unsigned long)cmdline_ptr);\r\nfail:\r\nreturn EFI_ERROR;\r\n}\r\nstatic int cmp_mem_desc(const void *l, const void *r)\r\n{\r\nconst efi_memory_desc_t *left = l, *right = r;\r\nreturn (left->phys_addr > right->phys_addr) ? 1 : -1;\r\n}\r\nstatic bool regions_are_adjacent(efi_memory_desc_t *left,\r\nefi_memory_desc_t *right)\r\n{\r\nu64 left_end;\r\nif (left == NULL || right == NULL)\r\nreturn false;\r\nleft_end = left->phys_addr + left->num_pages * EFI_PAGE_SIZE;\r\nreturn left_end == right->phys_addr;\r\n}\r\nstatic bool regions_have_compatible_memory_type_attrs(efi_memory_desc_t *left,\r\nefi_memory_desc_t *right)\r\n{\r\nstatic const u64 mem_type_mask = EFI_MEMORY_WB | EFI_MEMORY_WT |\r\nEFI_MEMORY_WC | EFI_MEMORY_UC |\r\nEFI_MEMORY_RUNTIME;\r\nreturn ((left->attribute ^ right->attribute) & mem_type_mask) == 0;\r\n}\r\nvoid efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,\r\nunsigned long desc_size, efi_memory_desc_t *runtime_map,\r\nint *count)\r\n{\r\nu64 efi_virt_base = EFI_RT_VIRTUAL_BASE;\r\nefi_memory_desc_t *in, *prev = NULL, *out = runtime_map;\r\nint l;\r\nsort(memory_map, map_size / desc_size, desc_size, cmp_mem_desc, NULL);\r\nfor (l = 0; l < map_size; l += desc_size, prev = in) {\r\nu64 paddr, size;\r\nin = (void *)memory_map + l;\r\nif (!(in->attribute & EFI_MEMORY_RUNTIME))\r\ncontinue;\r\npaddr = in->phys_addr;\r\nsize = in->num_pages * EFI_PAGE_SIZE;\r\nif (!regions_are_adjacent(prev, in) ||\r\n!regions_have_compatible_memory_type_attrs(prev, in)) {\r\npaddr = round_down(in->phys_addr, SZ_64K);\r\nsize += in->phys_addr - paddr;\r\nif (IS_ALIGNED(in->phys_addr, SZ_2M) && size >= SZ_2M)\r\nefi_virt_base = round_up(efi_virt_base, SZ_2M);\r\nelse\r\nefi_virt_base = round_up(efi_virt_base, SZ_64K);\r\n}\r\nin->virt_addr = efi_virt_base + in->phys_addr - paddr;\r\nefi_virt_base += size;\r\nmemcpy(out, in, desc_size);\r\nout = (void *)out + desc_size;\r\n++*count;\r\n}\r\n}
