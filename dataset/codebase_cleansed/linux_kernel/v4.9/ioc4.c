int\r\nioc4_register_submodule(struct ioc4_submodule *is)\r\n{\r\nstruct ioc4_driver_data *idd;\r\nmutex_lock(&ioc4_mutex);\r\nlist_add(&is->is_list, &ioc4_submodules);\r\nif (!is->is_probe)\r\ngoto out;\r\nlist_for_each_entry(idd, &ioc4_devices, idd_list) {\r\nif (is->is_probe(idd)) {\r\nprintk(KERN_WARNING\r\n"%s: IOC4 submodule %s probe failed "\r\n"for pci_dev %s",\r\n__func__, module_name(is->is_owner),\r\npci_name(idd->idd_pdev));\r\n}\r\n}\r\nout:\r\nmutex_unlock(&ioc4_mutex);\r\nreturn 0;\r\n}\r\nvoid\r\nioc4_unregister_submodule(struct ioc4_submodule *is)\r\n{\r\nstruct ioc4_driver_data *idd;\r\nmutex_lock(&ioc4_mutex);\r\nlist_del(&is->is_list);\r\nif (!is->is_remove)\r\ngoto out;\r\nlist_for_each_entry(idd, &ioc4_devices, idd_list) {\r\nif (is->is_remove(idd)) {\r\nprintk(KERN_WARNING\r\n"%s: IOC4 submodule %s remove failed "\r\n"for pci_dev %s.\n",\r\n__func__, module_name(is->is_owner),\r\npci_name(idd->idd_pdev));\r\n}\r\n}\r\nout:\r\nmutex_unlock(&ioc4_mutex);\r\n}\r\nstatic void\r\nioc4_clock_calibrate(struct ioc4_driver_data *idd)\r\n{\r\nunion ioc4_int_out int_out;\r\nunion ioc4_gpcr gpcr;\r\nunsigned int state, last_state;\r\nuint64_t start, end, period;\r\nunsigned int count;\r\ngpcr.raw = 0;\r\ngpcr.fields.dir = IOC4_GPCR_DIR_0;\r\ngpcr.fields.int_out_en = 1;\r\nwritel(gpcr.raw, &idd->idd_misc_regs->gpcr_s.raw);\r\nwritel(0, &idd->idd_misc_regs->int_out.raw);\r\nmmiowb();\r\nint_out.raw = 0;\r\nint_out.fields.count = IOC4_CALIBRATE_COUNT;\r\nint_out.fields.mode = IOC4_INT_OUT_MODE_TOGGLE;\r\nint_out.fields.diag = 0;\r\nwritel(int_out.raw, &idd->idd_misc_regs->int_out.raw);\r\nmmiowb();\r\nstart = ktime_get_ns();\r\nstate = 1;\r\nfor (count = 0; count <= IOC4_CALIBRATE_END; count++) {\r\ndo {\r\nlast_state = state;\r\nint_out.raw = readl(&idd->idd_misc_regs->int_out.raw);\r\nstate = int_out.fields.int_out;\r\n} while (last_state || !state);\r\nif (count == IOC4_CALIBRATE_DISCARD)\r\nstart = ktime_get_ns();\r\n}\r\nend = ktime_get_ns();\r\nperiod = (end - start) /\r\n(IOC4_CALIBRATE_CYCLES * 2 * (IOC4_CALIBRATE_COUNT + 1));\r\nif (period > IOC4_CALIBRATE_LOW_LIMIT ||\r\nperiod < IOC4_CALIBRATE_HIGH_LIMIT) {\r\nprintk(KERN_INFO\r\n"IOC4 %s: Clock calibration failed. Assuming"\r\n"PCI clock is %d ns.\n",\r\npci_name(idd->idd_pdev),\r\nIOC4_CALIBRATE_DEFAULT / IOC4_EXTINT_COUNT_DIVISOR);\r\nperiod = IOC4_CALIBRATE_DEFAULT;\r\n} else {\r\nu64 ns = period;\r\ndo_div(ns, IOC4_EXTINT_COUNT_DIVISOR);\r\nprintk(KERN_DEBUG\r\n"IOC4 %s: PCI clock is %llu ns.\n",\r\npci_name(idd->idd_pdev), (unsigned long long)ns);\r\n}\r\nidd->count_period = period;\r\n}\r\nstatic unsigned int\r\nioc4_variant(struct ioc4_driver_data *idd)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nint found = 0;\r\ndo {\r\npdev = pci_get_device(PCI_VENDOR_ID_QLOGIC,\r\nPCI_DEVICE_ID_QLOGIC_ISP12160, pdev);\r\nif (pdev &&\r\nidd->idd_pdev->bus->number == pdev->bus->number &&\r\n3 == PCI_SLOT(pdev->devfn))\r\nfound = 1;\r\n} while (pdev && !found);\r\nif (NULL != pdev) {\r\npci_dev_put(pdev);\r\nreturn IOC4_VARIANT_IO9;\r\n}\r\npdev = NULL;\r\ndo {\r\npdev = pci_get_device(PCI_VENDOR_ID_VITESSE,\r\nPCI_DEVICE_ID_VITESSE_VSC7174, pdev);\r\nif (pdev &&\r\nidd->idd_pdev->bus->number == pdev->bus->number &&\r\n3 == PCI_SLOT(pdev->devfn))\r\nfound = 1;\r\n} while (pdev && !found);\r\nif (NULL != pdev) {\r\npci_dev_put(pdev);\r\nreturn IOC4_VARIANT_IO10;\r\n}\r\nreturn IOC4_VARIANT_PCI_RT;\r\n}\r\nstatic void\r\nioc4_load_modules(struct work_struct *work)\r\n{\r\nrequest_module("sgiioc4");\r\n}\r\nstatic int\r\nioc4_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)\r\n{\r\nstruct ioc4_driver_data *idd;\r\nstruct ioc4_submodule *is;\r\nuint32_t pcmd;\r\nint ret;\r\nif ((ret = pci_enable_device(pdev))) {\r\nprintk(KERN_WARNING\r\n"%s: Failed to enable IOC4 device for pci_dev %s.\n",\r\n__func__, pci_name(pdev));\r\ngoto out;\r\n}\r\npci_set_master(pdev);\r\nidd = kmalloc(sizeof(struct ioc4_driver_data), GFP_KERNEL);\r\nif (!idd) {\r\nprintk(KERN_WARNING\r\n"%s: Failed to allocate IOC4 data for pci_dev %s.\n",\r\n__func__, pci_name(pdev));\r\nret = -ENODEV;\r\ngoto out_idd;\r\n}\r\nidd->idd_pdev = pdev;\r\nidd->idd_pci_id = pci_id;\r\nidd->idd_bar0 = pci_resource_start(idd->idd_pdev, 0);\r\nif (!idd->idd_bar0) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to find IOC4 misc resource "\r\n"for pci_dev %s.\n",\r\n__func__, pci_name(idd->idd_pdev));\r\nret = -ENODEV;\r\ngoto out_pci;\r\n}\r\nif (!request_mem_region(idd->idd_bar0, sizeof(struct ioc4_misc_regs),\r\n"ioc4_misc")) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to request IOC4 misc region "\r\n"for pci_dev %s.\n",\r\n__func__, pci_name(idd->idd_pdev));\r\nret = -ENODEV;\r\ngoto out_pci;\r\n}\r\nidd->idd_misc_regs = ioremap(idd->idd_bar0,\r\nsizeof(struct ioc4_misc_regs));\r\nif (!idd->idd_misc_regs) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to remap IOC4 misc region "\r\n"for pci_dev %s.\n",\r\n__func__, pci_name(idd->idd_pdev));\r\nret = -ENODEV;\r\ngoto out_misc_region;\r\n}\r\nidd->idd_variant = ioc4_variant(idd);\r\nprintk(KERN_INFO "IOC4 %s: %s card detected.\n", pci_name(pdev),\r\nidd->idd_variant == IOC4_VARIANT_IO9 ? "IO9" :\r\nidd->idd_variant == IOC4_VARIANT_PCI_RT ? "PCI-RT" :\r\nidd->idd_variant == IOC4_VARIANT_IO10 ? "IO10" : "unknown");\r\npci_read_config_dword(idd->idd_pdev, PCI_COMMAND, &pcmd);\r\npci_write_config_dword(idd->idd_pdev, PCI_COMMAND,\r\npcmd | PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\r\nioc4_clock_calibrate(idd);\r\nwritel(~0, &idd->idd_misc_regs->other_iec.raw);\r\nwritel(~0, &idd->idd_misc_regs->sio_iec);\r\nwritel(~0, &idd->idd_misc_regs->other_ir.raw);\r\nwritel(~0, &idd->idd_misc_regs->sio_ir);\r\nidd->idd_serial_data = NULL;\r\npci_set_drvdata(idd->idd_pdev, idd);\r\nmutex_lock(&ioc4_mutex);\r\nlist_add_tail(&idd->idd_list, &ioc4_devices);\r\nlist_for_each_entry(is, &ioc4_submodules, is_list) {\r\nif (is->is_probe && is->is_probe(idd)) {\r\nprintk(KERN_WARNING\r\n"%s: IOC4 submodule 0x%s probe failed "\r\n"for pci_dev %s.\n",\r\n__func__, module_name(is->is_owner),\r\npci_name(idd->idd_pdev));\r\n}\r\n}\r\nmutex_unlock(&ioc4_mutex);\r\nif (idd->idd_variant != IOC4_VARIANT_PCI_RT) {\r\nprintk(KERN_INFO "IOC4 loading sgiioc4 submodule\n");\r\nschedule_work(&ioc4_load_modules_work);\r\n}\r\nreturn 0;\r\nout_misc_region:\r\nrelease_mem_region(idd->idd_bar0, sizeof(struct ioc4_misc_regs));\r\nout_pci:\r\nkfree(idd);\r\nout_idd:\r\npci_disable_device(pdev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void\r\nioc4_remove(struct pci_dev *pdev)\r\n{\r\nstruct ioc4_submodule *is;\r\nstruct ioc4_driver_data *idd;\r\nidd = pci_get_drvdata(pdev);\r\nmutex_lock(&ioc4_mutex);\r\nlist_for_each_entry(is, &ioc4_submodules, is_list) {\r\nif (is->is_remove && is->is_remove(idd)) {\r\nprintk(KERN_WARNING\r\n"%s: IOC4 submodule 0x%s remove failed "\r\n"for pci_dev %s.\n",\r\n__func__, module_name(is->is_owner),\r\npci_name(idd->idd_pdev));\r\n}\r\n}\r\nmutex_unlock(&ioc4_mutex);\r\niounmap(idd->idd_misc_regs);\r\nif (!idd->idd_bar0) {\r\nprintk(KERN_WARNING\r\n"%s: Unable to get IOC4 misc mapping for pci_dev %s. "\r\n"Device removal may be incomplete.\n",\r\n__func__, pci_name(idd->idd_pdev));\r\n}\r\nrelease_mem_region(idd->idd_bar0, sizeof(struct ioc4_misc_regs));\r\npci_disable_device(pdev);\r\nmutex_lock(&ioc4_mutex);\r\nlist_del(&idd->idd_list);\r\nmutex_unlock(&ioc4_mutex);\r\nkfree(idd);\r\n}\r\nstatic int __init\r\nioc4_init(void)\r\n{\r\nreturn pci_register_driver(&ioc4_driver);\r\n}\r\nstatic void __exit\r\nioc4_exit(void)\r\n{\r\nflush_work(&ioc4_load_modules_work);\r\npci_unregister_driver(&ioc4_driver);\r\n}
