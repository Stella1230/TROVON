static int cx231xx_enable_analog_tuner(struct cx231xx *dev)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nstruct media_device *mdev = dev->media_dev;\r\nstruct media_entity *entity, *decoder = NULL, *source;\r\nstruct media_link *link, *found_link = NULL;\r\nint ret, active_links = 0;\r\nif (!mdev)\r\nreturn 0;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nif (entity->function == MEDIA_ENT_F_ATV_DECODER) {\r\ndecoder = entity;\r\nbreak;\r\n}\r\n}\r\nif (!decoder)\r\nreturn 0;\r\nlist_for_each_entry(link, &decoder->links, list) {\r\nif (link->sink->entity == decoder) {\r\nfound_link = link;\r\nif (link->flags & MEDIA_LNK_FL_ENABLED)\r\nactive_links++;\r\nbreak;\r\n}\r\n}\r\nif (active_links == 1 || !found_link)\r\nreturn 0;\r\nsource = found_link->source->entity;\r\nlist_for_each_entry(link, &source->links, list) {\r\nstruct media_entity *sink;\r\nint flags = 0;\r\nsink = link->sink->entity;\r\nif (sink == entity)\r\nflags = MEDIA_LNK_FL_ENABLED;\r\nret = media_entity_setup_link(link, flags);\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"Couldn't change link %s->%s to %s. Error %d\n",\r\nsource->name, sink->name,\r\nflags ? "enabled" : "disabled",\r\nret);\r\nreturn ret;\r\n} else\r\ndev_dbg(dev->dev,\r\n"link %s->%s was %s\n",\r\nsource->name, sink->name,\r\nflags ? "ENABLED" : "disabled");\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline void buffer_filled(struct cx231xx *dev,\r\nstruct cx231xx_dmaqueue *dma_q,\r\nstruct cx231xx_buffer *buf)\r\n{\r\ncx231xx_isocdbg("[%p/%d] wakeup\n", buf, buf->vb.i);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\nv4l2_get_timestamp(&buf->vb.ts);\r\nif (dev->USE_ISO)\r\ndev->video_mode.isoc_ctl.buf = NULL;\r\nelse\r\ndev->video_mode.bulk_ctl.buf = NULL;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nstatic inline void print_err_status(struct cx231xx *dev, int packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\ncx231xx_isocdbg("URB status %d [%s].\n", status, errmsg);\r\n} else {\r\ncx231xx_isocdbg("URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic inline void get_next_buf(struct cx231xx_dmaqueue *dma_q,\r\nstruct cx231xx_buffer **buf)\r\n{\r\nstruct cx231xx_video_mode *vmode =\r\ncontainer_of(dma_q, struct cx231xx_video_mode, vidq);\r\nstruct cx231xx *dev = container_of(vmode, struct cx231xx, video_mode);\r\nchar *outp;\r\nif (list_empty(&dma_q->active)) {\r\ncx231xx_isocdbg("No active queue to serve\n");\r\nif (dev->USE_ISO)\r\ndev->video_mode.isoc_ctl.buf = NULL;\r\nelse\r\ndev->video_mode.bulk_ctl.buf = NULL;\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next, struct cx231xx_buffer, vb.queue);\r\noutp = videobuf_to_vmalloc(&(*buf)->vb);\r\nmemset(outp, 0, (*buf)->vb.size);\r\nif (dev->USE_ISO)\r\ndev->video_mode.isoc_ctl.buf = *buf;\r\nelse\r\ndev->video_mode.bulk_ctl.buf = *buf;\r\nreturn;\r\n}\r\nstatic inline int cx231xx_isoc_copy(struct cx231xx *dev, struct urb *urb)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = urb->context;\r\nint i;\r\nunsigned char *p_buffer;\r\nu32 bytes_parsed = 0, buffer_size = 0;\r\nu8 sav_eav = 0;\r\nif (!dev)\r\nreturn 0;\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nint status = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\nif (urb->iso_frame_desc[i].actual_length <= 0) {\r\ncontinue;\r\n}\r\nif (urb->iso_frame_desc[i].actual_length >\r\ndev->video_mode.max_pkt_size) {\r\ncx231xx_isocdbg("packet bigger than packet size");\r\ncontinue;\r\n}\r\np_buffer = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nbuffer_size = urb->iso_frame_desc[i].actual_length;\r\nbytes_parsed = 0;\r\nif (dma_q->is_partial_line) {\r\nsav_eav = dma_q->last_sav;\r\n} else {\r\nsav_eav =\r\ncx231xx_find_boundary_SAV_EAV(p_buffer,\r\ndma_q->partial_buf,\r\n&bytes_parsed);\r\n}\r\nsav_eav &= 0xF0;\r\nif (sav_eav) {\r\nbytes_parsed += cx231xx_get_video_line(dev, dma_q,\r\nsav_eav,\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed);\r\n}\r\nwhile (bytes_parsed < buffer_size) {\r\nu32 bytes_used = 0;\r\nsav_eav = cx231xx_find_next_SAV_EAV(\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed,\r\n&bytes_used);\r\nbytes_parsed += bytes_used;\r\nsav_eav &= 0xF0;\r\nif (sav_eav && (bytes_parsed < buffer_size)) {\r\nbytes_parsed += cx231xx_get_video_line(dev,\r\ndma_q, sav_eav,\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed);\r\n}\r\n}\r\nmemcpy(dma_q->partial_buf, p_buffer + buffer_size - 4, 4);\r\nbytes_parsed = 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline int cx231xx_bulk_copy(struct cx231xx *dev, struct urb *urb)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = urb->context;\r\nunsigned char *p_buffer;\r\nu32 bytes_parsed = 0, buffer_size = 0;\r\nu8 sav_eav = 0;\r\nif (!dev)\r\nreturn 0;\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nif (1) {\r\np_buffer = urb->transfer_buffer;\r\nbuffer_size = urb->actual_length;\r\nbytes_parsed = 0;\r\nif (dma_q->is_partial_line) {\r\nsav_eav = dma_q->last_sav;\r\n} else {\r\nsav_eav =\r\ncx231xx_find_boundary_SAV_EAV(p_buffer,\r\ndma_q->partial_buf,\r\n&bytes_parsed);\r\n}\r\nsav_eav &= 0xF0;\r\nif (sav_eav) {\r\nbytes_parsed += cx231xx_get_video_line(dev, dma_q,\r\nsav_eav,\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed);\r\n}\r\nwhile (bytes_parsed < buffer_size) {\r\nu32 bytes_used = 0;\r\nsav_eav = cx231xx_find_next_SAV_EAV(\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed,\r\n&bytes_used);\r\nbytes_parsed += bytes_used;\r\nsav_eav &= 0xF0;\r\nif (sav_eav && (bytes_parsed < buffer_size)) {\r\nbytes_parsed += cx231xx_get_video_line(dev,\r\ndma_q, sav_eav,\r\np_buffer + bytes_parsed,\r\nbuffer_size - bytes_parsed);\r\n}\r\n}\r\nmemcpy(dma_q->partial_buf, p_buffer + buffer_size - 4, 4);\r\nbytes_parsed = 0;\r\n}\r\nreturn 1;\r\n}\r\nu8 cx231xx_find_boundary_SAV_EAV(u8 *p_buffer, u8 *partial_buf,\r\nu32 *p_bytes_used)\r\n{\r\nu32 bytes_used;\r\nu8 boundary_bytes[8];\r\nu8 sav_eav = 0;\r\n*p_bytes_used = 0;\r\nmemcpy(boundary_bytes, partial_buf, 4);\r\nmemcpy(boundary_bytes + 4, p_buffer, 4);\r\nsav_eav = cx231xx_find_next_SAV_EAV((u8 *)&boundary_bytes, 8,\r\n&bytes_used);\r\nif (sav_eav) {\r\n*p_bytes_used = bytes_used - 4;\r\n}\r\nreturn sav_eav;\r\n}\r\nu8 cx231xx_find_next_SAV_EAV(u8 *p_buffer, u32 buffer_size, u32 *p_bytes_used)\r\n{\r\nu32 i;\r\nu8 sav_eav = 0;\r\nif (buffer_size < 4) {\r\n*p_bytes_used = buffer_size;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < (buffer_size - 3); i++) {\r\nif ((p_buffer[i] == 0xFF) &&\r\n(p_buffer[i + 1] == 0x00) && (p_buffer[i + 2] == 0x00)) {\r\n*p_bytes_used = i + 4;\r\nsav_eav = p_buffer[i + 3];\r\nreturn sav_eav;\r\n}\r\n}\r\n*p_bytes_used = buffer_size;\r\nreturn 0;\r\n}\r\nu32 cx231xx_get_video_line(struct cx231xx *dev,\r\nstruct cx231xx_dmaqueue *dma_q, u8 sav_eav,\r\nu8 *p_buffer, u32 buffer_size)\r\n{\r\nu32 bytes_copied = 0;\r\nint current_field = -1;\r\nswitch (sav_eav) {\r\ncase SAV_ACTIVE_VIDEO_FIELD1:\r\nif ((buffer_size > 3) && (p_buffer[0] == 0xFF) &&\r\n(p_buffer[1] == 0x00) && (p_buffer[2] == 0x00) &&\r\n((p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD1) ||\r\n(p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD2) ||\r\n(p_buffer[3] == EAV_VBLANK_FIELD1) ||\r\n(p_buffer[3] == EAV_VBLANK_FIELD2)))\r\nreturn bytes_copied;\r\ncurrent_field = 1;\r\nbreak;\r\ncase SAV_ACTIVE_VIDEO_FIELD2:\r\nif ((buffer_size > 3) && (p_buffer[0] == 0xFF) &&\r\n(p_buffer[1] == 0x00) && (p_buffer[2] == 0x00) &&\r\n((p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD1) ||\r\n(p_buffer[3] == EAV_ACTIVE_VIDEO_FIELD2) ||\r\n(p_buffer[3] == EAV_VBLANK_FIELD1) ||\r\n(p_buffer[3] == EAV_VBLANK_FIELD2)))\r\nreturn bytes_copied;\r\ncurrent_field = 2;\r\nbreak;\r\n}\r\ndma_q->last_sav = sav_eav;\r\nbytes_copied = cx231xx_copy_video_line(dev, dma_q, p_buffer,\r\nbuffer_size, current_field);\r\nreturn bytes_copied;\r\n}\r\nu32 cx231xx_copy_video_line(struct cx231xx *dev,\r\nstruct cx231xx_dmaqueue *dma_q, u8 *p_line,\r\nu32 length, int field_number)\r\n{\r\nu32 bytes_to_copy;\r\nstruct cx231xx_buffer *buf;\r\nu32 _line_size = dev->width * 2;\r\nif (dma_q->current_field != field_number)\r\ncx231xx_reset_video_buffer(dev, dma_q);\r\nif (dev->USE_ISO)\r\nbuf = dev->video_mode.isoc_ctl.buf;\r\nelse\r\nbuf = dev->video_mode.bulk_ctl.buf;\r\ndma_q->current_field = field_number;\r\nbytes_to_copy = dma_q->bytes_left_in_line;\r\nif (bytes_to_copy > length)\r\nbytes_to_copy = length;\r\nif (dma_q->lines_completed >= dma_q->lines_per_field) {\r\ndma_q->bytes_left_in_line -= bytes_to_copy;\r\ndma_q->is_partial_line = (dma_q->bytes_left_in_line == 0) ?\r\n0 : 1;\r\nreturn 0;\r\n}\r\ndma_q->is_partial_line = 1;\r\nif (!buf) {\r\ndma_q->bytes_left_in_line -= bytes_to_copy;\r\ndma_q->is_partial_line = (dma_q->bytes_left_in_line == 0)\r\n? 0 : 1;\r\nreturn bytes_to_copy;\r\n}\r\ncx231xx_do_copy(dev, dma_q, p_line, bytes_to_copy);\r\ndma_q->pos += bytes_to_copy;\r\ndma_q->bytes_left_in_line -= bytes_to_copy;\r\nif (dma_q->bytes_left_in_line == 0) {\r\ndma_q->bytes_left_in_line = _line_size;\r\ndma_q->lines_completed++;\r\ndma_q->is_partial_line = 0;\r\nif (cx231xx_is_buffer_done(dev, dma_q) && buf) {\r\nbuffer_filled(dev, dma_q, buf);\r\ndma_q->pos = 0;\r\nbuf = NULL;\r\ndma_q->lines_completed = 0;\r\n}\r\n}\r\nreturn bytes_to_copy;\r\n}\r\nvoid cx231xx_reset_video_buffer(struct cx231xx *dev,\r\nstruct cx231xx_dmaqueue *dma_q)\r\n{\r\nstruct cx231xx_buffer *buf;\r\nif (dma_q->current_field == 1) {\r\nif (dma_q->lines_completed >= dma_q->lines_per_field)\r\ndma_q->field1_done = 1;\r\nelse\r\ndma_q->field1_done = 0;\r\n}\r\nif (dev->USE_ISO)\r\nbuf = dev->video_mode.isoc_ctl.buf;\r\nelse\r\nbuf = dev->video_mode.bulk_ctl.buf;\r\nif (buf == NULL) {\r\nget_next_buf(dma_q, &buf);\r\ndma_q->pos = 0;\r\ndma_q->field1_done = 0;\r\ndma_q->current_field = -1;\r\n}\r\ndma_q->bytes_left_in_line = dev->width << 1;\r\ndma_q->lines_completed = 0;\r\n}\r\nint cx231xx_do_copy(struct cx231xx *dev, struct cx231xx_dmaqueue *dma_q,\r\nu8 *p_buffer, u32 bytes_to_copy)\r\n{\r\nu8 *p_out_buffer = NULL;\r\nu32 current_line_bytes_copied = 0;\r\nstruct cx231xx_buffer *buf;\r\nu32 _line_size = dev->width << 1;\r\nvoid *startwrite;\r\nint offset, lencopy;\r\nif (dev->USE_ISO)\r\nbuf = dev->video_mode.isoc_ctl.buf;\r\nelse\r\nbuf = dev->video_mode.bulk_ctl.buf;\r\nif (buf == NULL)\r\nreturn -1;\r\np_out_buffer = videobuf_to_vmalloc(&buf->vb);\r\ncurrent_line_bytes_copied = _line_size - dma_q->bytes_left_in_line;\r\noffset = (dma_q->current_field == 1) ? 0 : _line_size;\r\nstartwrite = p_out_buffer + offset;\r\nstartwrite += (dma_q->lines_completed * _line_size * 2);\r\nstartwrite += current_line_bytes_copied;\r\nlencopy = dma_q->bytes_left_in_line > bytes_to_copy ?\r\nbytes_to_copy : dma_q->bytes_left_in_line;\r\nif ((u8 *)(startwrite + lencopy) > (u8 *)(p_out_buffer + buf->vb.size))\r\nreturn 0;\r\ncx231xx_swab((u16 *) p_buffer, (u16 *) startwrite, (u16) lencopy);\r\nreturn 0;\r\n}\r\nvoid cx231xx_swab(u16 *from, u16 *to, u16 len)\r\n{\r\nu16 i;\r\nif (len <= 0)\r\nreturn;\r\nfor (i = 0; i < len / 2; i++)\r\nto[i] = (from[i] << 8) | (from[i] >> 8);\r\n}\r\nu8 cx231xx_is_buffer_done(struct cx231xx *dev, struct cx231xx_dmaqueue *dma_q)\r\n{\r\nu8 buffer_complete = 0;\r\nbuffer_complete = ((dma_q->current_field == 2) &&\r\n(dma_q->lines_completed >= dma_q->lines_per_field) &&\r\ndma_q->field1_done);\r\nreturn buffer_complete;\r\n}\r\nstatic int\r\nbuffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)\r\n{\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = fh->dev;\r\n*size = (fh->dev->width * fh->dev->height * dev->format->depth + 7)>>3;\r\nif (0 == *count)\r\n*count = CX231XX_DEF_BUF;\r\nif (*count < CX231XX_MIN_BUF)\r\n*count = CX231XX_MIN_BUF;\r\ncx231xx_enable_analog_tuner(dev);\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct cx231xx_buffer *buf)\r\n{\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = fh->dev;\r\nunsigned long flags = 0;\r\nBUG_ON(in_interrupt());\r\nspin_lock_irqsave(&dev->video_mode.slock, flags);\r\nif (dev->USE_ISO) {\r\nif (dev->video_mode.isoc_ctl.buf == buf)\r\ndev->video_mode.isoc_ctl.buf = NULL;\r\n} else {\r\nif (dev->video_mode.bulk_ctl.buf == buf)\r\ndev->video_mode.bulk_ctl.buf = NULL;\r\n}\r\nspin_unlock_irqrestore(&dev->video_mode.slock, flags);\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int\r\nbuffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nstruct cx231xx *dev = fh->dev;\r\nint rc = 0, urb_init = 0;\r\nbuf->vb.size = (fh->dev->width * fh->dev->height * dev->format->depth\r\n+ 7) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nbuf->vb.width = dev->width;\r\nbuf->vb.height = dev->height;\r\nbuf->vb.field = field;\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nif (dev->USE_ISO) {\r\nif (!dev->video_mode.isoc_ctl.num_bufs)\r\nurb_init = 1;\r\n} else {\r\nif (!dev->video_mode.bulk_ctl.num_bufs)\r\nurb_init = 1;\r\n}\r\ndev_dbg(dev->dev,\r\n"urb_init=%d dev->video_mode.max_pkt_size=%d\n",\r\nurb_init, dev->video_mode.max_pkt_size);\r\nif (urb_init) {\r\ndev->mode_tv = 0;\r\nif (dev->USE_ISO)\r\nrc = cx231xx_init_isoc(dev, CX231XX_NUM_PACKETS,\r\nCX231XX_NUM_BUFS,\r\ndev->video_mode.max_pkt_size,\r\ncx231xx_isoc_copy);\r\nelse\r\nrc = cx231xx_init_bulk(dev, CX231XX_NUM_PACKETS,\r\nCX231XX_NUM_BUFS,\r\ndev->video_mode.max_pkt_size,\r\ncx231xx_bulk_copy);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = fh->dev;\r\nstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = (struct cx231xx *)fh->dev;\r\ncx231xx_isocdbg("cx231xx: called buffer_release\n");\r\nfree_buffer(vq, buf);\r\n}\r\nvoid video_mux(struct cx231xx *dev, int index)\r\n{\r\ndev->video_input = index;\r\ndev->ctl_ainput = INPUT(index)->amux;\r\ncx231xx_set_video_input_mux(dev, index);\r\ncx25840_call(dev, video, s_routing, INPUT(index)->vmux, 0, 0);\r\ncx231xx_set_audio_input(dev, dev->ctl_ainput);\r\ndev_dbg(dev->dev, "video_mux : %d\n", index);\r\ncx231xx_do_mode_ctrl_overrides(dev);\r\n}\r\nstatic int res_get(struct cx231xx_fh *fh)\r\n{\r\nstruct cx231xx *dev = fh->dev;\r\nint rc = 0;\r\nif (fh->stream_on)\r\nreturn rc;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (dev->stream_on)\r\nreturn -EBUSY;\r\ndev->stream_on = 1;\r\n} else if (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nif (dev->vbi_stream_on)\r\nreturn -EBUSY;\r\ndev->vbi_stream_on = 1;\r\n} else\r\nreturn -EINVAL;\r\nfh->stream_on = 1;\r\nreturn rc;\r\n}\r\nstatic int res_check(struct cx231xx_fh *fh)\r\n{\r\nreturn fh->stream_on;\r\n}\r\nstatic void res_free(struct cx231xx_fh *fh)\r\n{\r\nstruct cx231xx *dev = fh->dev;\r\nfh->stream_on = 0;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ndev->stream_on = 0;\r\nif (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)\r\ndev->vbi_stream_on = 0;\r\n}\r\nstatic int check_dev(struct cx231xx *dev)\r\n{\r\nif (dev->state & DEV_DISCONNECTED) {\r\ndev_err(dev->dev, "v4l2 ioctl: device not present\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.pixelformat = dev->format->fourcc;\r\nf->fmt.pix.bytesperline = (dev->width * dev->format->depth + 7) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * dev->height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nreturn 0;\r\n}\r\nstatic struct cx231xx_fmt *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(format); i++)\r\nif (format[i].fourcc == fourcc)\r\nreturn &format[i];\r\nreturn NULL;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nunsigned int width = f->fmt.pix.width;\r\nunsigned int height = f->fmt.pix.height;\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\nstruct cx231xx_fmt *fmt;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (!fmt) {\r\ncx231xx_videodbg("Fourcc format (%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nv4l_bound_align_image(&width, 48, maxw, 1, &height, 32, maxh, 1, 0);\r\nf->fmt.pix.width = width;\r\nf->fmt.pix.height = height;\r\nf->fmt.pix.pixelformat = fmt->fourcc;\r\nf->fmt.pix.bytesperline = (width * fmt->depth + 7) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nstruct cx231xx_fmt *fmt;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nvidioc_try_fmt_vid_cap(file, priv, f);\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nif (videobuf_queue_is_busy(&fh->vb_vidq)) {\r\ndev_err(dev->dev, "%s: queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (dev->stream_on && !fh->stream_on) {\r\ndev_err(dev->dev,\r\n"%s: device in use by another fh\n", __func__);\r\nreturn -EBUSY;\r\n}\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\ndev->format = fmt;\r\nv4l2_fill_mbus_format(&format.format, &f->fmt.pix, MEDIA_BUS_FMT_FIXED);\r\ncall_all(dev, pad, set_fmt, NULL, &format);\r\nv4l2_fill_pix_format(&f->fmt.pix, &format.format);\r\nreturn rc;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\n*id = dev->norm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id norm)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (dev->norm == norm)\r\nreturn 0;\r\nif (videobuf_queue_is_busy(&fh->vb_vidq))\r\nreturn -EBUSY;\r\ndev->norm = norm;\r\ndev->width = 720;\r\ndev->height = (dev->norm & V4L2_STD_625_50) ? 576 : 480;\r\ncall_all(dev, video, s_std, dev->norm);\r\nformat.format.code = MEDIA_BUS_FMT_FIXED;\r\nformat.format.width = dev->width;\r\nformat.format.height = dev->height;\r\ncall_all(dev, pad, set_fmt, NULL, &format);\r\ncx231xx_do_mode_ctrl_overrides(dev);\r\nreturn 0;\r\n}\r\nvoid cx231xx_v4l2_create_entities(struct cx231xx *dev)\r\n{\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nint ret, i;\r\nfor (i = 0; i < MAX_CX231XX_INPUT; i++) {\r\nstruct media_entity *ent = &dev->input_ent[i];\r\nif (!INPUT(i)->type)\r\nbreak;\r\nent->name = iname[INPUT(i)->type];\r\nent->flags = MEDIA_ENT_FL_CONNECTOR;\r\ndev->input_pad[i].flags = MEDIA_PAD_FL_SOURCE;\r\nswitch (INPUT(i)->type) {\r\ncase CX231XX_VMUX_COMPOSITE1:\r\nent->function = MEDIA_ENT_F_CONN_COMPOSITE;\r\nbreak;\r\ncase CX231XX_VMUX_SVIDEO:\r\nent->function = MEDIA_ENT_F_CONN_SVIDEO;\r\nbreak;\r\ncase CX231XX_VMUX_TELEVISION:\r\ncase CX231XX_VMUX_CABLE:\r\ncase CX231XX_VMUX_DVB:\r\nif (dev->tuner_type == TUNER_ABSENT)\r\ncontinue;\r\ndefault:\r\nent->function = MEDIA_ENT_F_CONN_RF;\r\nbreak;\r\n}\r\nret = media_entity_pads_init(ent, 1, &dev->input_pad[i]);\r\nif (ret < 0)\r\npr_err("failed to initialize input pad[%d]!\n", i);\r\nret = media_device_register_entity(dev->media_dev, ent);\r\nif (ret < 0)\r\npr_err("failed to register input entity %d!\n", i);\r\n}\r\n#endif\r\n}\r\nint cx231xx_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nu32 gen_stat;\r\nunsigned int n;\r\nint ret;\r\nn = i->index;\r\nif (n >= MAX_CX231XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n)->type)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, iname[INPUT(n)->type]);\r\nif ((CX231XX_VMUX_TELEVISION == INPUT(n)->type) ||\r\n(CX231XX_VMUX_CABLE == INPUT(n)->type))\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\ni->std = dev->vdev.tvnorms;\r\nif (n == dev->video_input) {\r\nret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\r\nGEN_STAT, 2, &gen_stat, 4);\r\nif (ret > 0) {\r\nif ((gen_stat & FLD_VPRES) == 0x00)\r\ni->status |= V4L2_IN_ST_NO_SIGNAL;\r\nif ((gen_stat & FLD_HLOCK) == 0x00)\r\ni->status |= V4L2_IN_ST_NO_H_LOCK;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cx231xx_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\n*i = dev->video_input;\r\nreturn 0;\r\n}\r\nint cx231xx_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\ndev->mode_tv = 0;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (i >= MAX_CX231XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(i)->type)\r\nreturn -EINVAL;\r\nvideo_mux(dev, i);\r\nif (INPUT(i)->type == CX231XX_VMUX_TELEVISION ||\r\nINPUT(i)->type == CX231XX_VMUX_CABLE) {\r\ncall_all(dev, video, s_std, dev->norm);\r\n}\r\nreturn 0;\r\n}\r\nint cx231xx_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Tuner");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nt->rangehigh = 0xffffffffUL;\r\nt->signal = 0xffff;\r\ncall_all(dev, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nint cx231xx_s_tuner(struct file *file, void *priv, const struct v4l2_tuner *t)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\n#if 0\r\ncall_all(dev, tuner, s_tuner, t);\r\n#endif\r\nreturn 0;\r\n}\r\nint cx231xx_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nf->frequency = dev->ctl_freq;\r\nreturn 0;\r\n}\r\nint cx231xx_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nstruct v4l2_frequency new_freq = *f;\r\nint rc;\r\nu32 if_frequency = 5400000;\r\ndev_dbg(dev->dev,\r\n"Enter vidioc_s_frequency()f->frequency=%d;f->type=%d\n",\r\nf->frequency, f->type);\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nrc = cx231xx_tuner_pre_channel_change(dev);\r\ncall_all(dev, tuner, s_frequency, f);\r\ncall_all(dev, tuner, g_frequency, &new_freq);\r\ndev->ctl_freq = new_freq.frequency;\r\nrc = cx231xx_tuner_post_channel_change(dev);\r\nif (dev->tuner_type == TUNER_NXP_TDA18271) {\r\nif (dev->norm & (V4L2_STD_MN | V4L2_STD_NTSC_443))\r\nif_frequency = 5400000;\r\nelse if (dev->norm & V4L2_STD_B)\r\nif_frequency = 6000000;\r\nelse if (dev->norm & (V4L2_STD_PAL_DK | V4L2_STD_SECAM_DK))\r\nif_frequency = 6900000;\r\nelse if (dev->norm & V4L2_STD_GH)\r\nif_frequency = 7100000;\r\nelse if (dev->norm & V4L2_STD_PAL_I)\r\nif_frequency = 7250000;\r\nelse if (dev->norm & V4L2_STD_SECAM_L)\r\nif_frequency = 6900000;\r\nelse if (dev->norm & V4L2_STD_SECAM_LC)\r\nif_frequency = 1250000;\r\ndev_dbg(dev->dev,\r\n"if_frequency is set to %d\n", if_frequency);\r\ncx231xx_set_Colibri_For_LowIF(dev, if_frequency, 1, 1);\r\nupdate_HH_register_after_set_DIF(dev);\r\n}\r\ndev_dbg(dev->dev, "Set New FREQUENCY to %d\n", f->frequency);\r\nreturn rc;\r\n}\r\nint cx231xx_g_chip_info(struct file *file, void *fh,\r\nstruct v4l2_dbg_chip_info *chip)\r\n{\r\nswitch (chip->match.addr) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nstrlcpy(chip->name, "AFE (byte)", sizeof(chip->name));\r\nreturn 0;\r\ncase 2:\r\nstrlcpy(chip->name, "Video (byte)", sizeof(chip->name));\r\nreturn 0;\r\ncase 3:\r\nstrlcpy(chip->name, "I2S (byte)", sizeof(chip->name));\r\nreturn 0;\r\ncase 4:\r\nstrlcpy(chip->name, "AFE (dword)", sizeof(chip->name));\r\nreturn 0;\r\ncase 5:\r\nstrlcpy(chip->name, "Video (dword)", sizeof(chip->name));\r\nreturn 0;\r\ncase 6:\r\nstrlcpy(chip->name, "I2S (dword)", sizeof(chip->name));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint cx231xx_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint ret;\r\nu8 value[4] = { 0, 0, 0, 0 };\r\nu32 data = 0;\r\nswitch (reg->match.addr) {\r\ncase 0:\r\nret = cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER,\r\n(u16)reg->reg, value, 4);\r\nreg->val = value[0] | value[1] << 8 |\r\nvalue[2] << 16 | value[3] << 24;\r\nreg->size = 4;\r\nbreak;\r\ncase 1:\r\nret = cx231xx_read_i2c_data(dev, AFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2, &data, 1);\r\nreg->val = data;\r\nreg->size = 1;\r\nbreak;\r\ncase 2:\r\nret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2, &data, 1);\r\nreg->val = data;\r\nreg->size = 1;\r\nbreak;\r\ncase 3:\r\nret = cx231xx_read_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1, &data, 1);\r\nreg->val = data;\r\nreg->size = 1;\r\nbreak;\r\ncase 4:\r\nret = cx231xx_read_i2c_data(dev, AFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2, &data, 4);\r\nreg->val = data;\r\nreg->size = 4;\r\nbreak;\r\ncase 5:\r\nret = cx231xx_read_i2c_data(dev, VID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2, &data, 4);\r\nreg->val = data;\r\nreg->size = 4;\r\nbreak;\r\ncase 6:\r\nret = cx231xx_read_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1, &data, 4);\r\nreg->val = data;\r\nreg->size = 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nint cx231xx_s_register(struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint ret;\r\nu8 data[4] = { 0, 0, 0, 0 };\r\nswitch (reg->match.addr) {\r\ncase 0:\r\ndata[0] = (u8) reg->val;\r\ndata[1] = (u8) (reg->val >> 8);\r\ndata[2] = (u8) (reg->val >> 16);\r\ndata[3] = (u8) (reg->val >> 24);\r\nret = cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\r\n(u16)reg->reg, data, 4);\r\nbreak;\r\ncase 1:\r\nret = cx231xx_write_i2c_data(dev, AFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2, reg->val, 1);\r\nbreak;\r\ncase 2:\r\nret = cx231xx_write_i2c_data(dev, VID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2, reg->val, 1);\r\nbreak;\r\ncase 3:\r\nret = cx231xx_write_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1, reg->val, 1);\r\nbreak;\r\ncase 4:\r\nret = cx231xx_write_i2c_data(dev, AFE_DEVICE_ADDRESS,\r\n(u16)reg->reg, 2, reg->val, 4);\r\nbreak;\r\ncase 5:\r\nret = cx231xx_write_i2c_data(dev, VID_BLK_I2C_ADDRESS,\r\n(u16)reg->reg, 2, reg->val, 4);\r\nbreak;\r\ncase 6:\r\nret = cx231xx_write_i2c_data(dev, I2S_BLK_DEVICE_ADDRESS,\r\n(u16)reg->reg, 1, reg->val, 4);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cc)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nbool is_50hz = dev->norm & V4L2_STD_625_50;\r\nif (cc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncc->bounds.left = 0;\r\ncc->bounds.top = 0;\r\ncc->bounds.width = dev->width;\r\ncc->bounds.height = dev->height;\r\ncc->defrect = cc->bounds;\r\ncc->pixelaspect.numerator = is_50hz ? 54 : 11;\r\ncc->pixelaspect.denominator = is_50hz ? 59 : 10;\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = res_get(fh);\r\nif (likely(rc >= 0))\r\nrc = videobuf_streamon(&fh->vb_vidq);\r\ncall_all(dev, video, s_stream, 1);\r\nreturn rc;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (type != fh->type)\r\nreturn -EINVAL;\r\ncx25840_call(dev, video, s_stream, 0);\r\nvideobuf_streamoff(&fh->vb_vidq);\r\nres_free(fh);\r\nreturn 0;\r\n}\r\nint cx231xx_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nstrlcpy(cap->driver, "cx231xx", sizeof(cap->driver));\r\nstrlcpy(cap->card, cx231xx_boards[dev->model].name, sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\ncap->device_caps = V4L2_CAP_RADIO;\r\nelse {\r\ncap->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nif (vdev->vfl_type == VFL_TYPE_VBI)\r\ncap->device_caps |= V4L2_CAP_VBI_CAPTURE;\r\nelse\r\ncap->device_caps |= V4L2_CAP_VIDEO_CAPTURE;\r\n}\r\nif (dev->tuner_type != TUNER_ABSENT)\r\ncap->device_caps |= V4L2_CAP_TUNER;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_READWRITE |\r\nV4L2_CAP_VBI_CAPTURE | V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS;\r\nif (video_is_registered(&dev->radio_dev))\r\ncap->capabilities |= V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(format)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, format[f->index].name, sizeof(f->description));\r\nf->pixelformat = format[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nf->fmt.vbi.sampling_rate = 6750000 * 4;\r\nf->fmt.vbi.samples_per_line = VBI_LINE_LENGTH;\r\nf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nf->fmt.vbi.offset = 0;\r\nf->fmt.vbi.start[0] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_START_LINE : NTSC_VBI_START_LINE;\r\nf->fmt.vbi.count[0] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_LINES : NTSC_VBI_LINES;\r\nf->fmt.vbi.start[1] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_START_LINE + 312 : NTSC_VBI_START_LINE + 263;\r\nf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\r\nmemset(f->fmt.vbi.reserved, 0, sizeof(f->fmt.vbi.reserved));\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nf->fmt.vbi.sampling_rate = 6750000 * 4;\r\nf->fmt.vbi.samples_per_line = VBI_LINE_LENGTH;\r\nf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nf->fmt.vbi.offset = 0;\r\nf->fmt.vbi.flags = 0;\r\nf->fmt.vbi.start[0] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_START_LINE : NTSC_VBI_START_LINE;\r\nf->fmt.vbi.count[0] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_LINES : NTSC_VBI_LINES;\r\nf->fmt.vbi.start[1] = (dev->norm & V4L2_STD_625_50) ?\r\nPAL_VBI_START_LINE + 312 : NTSC_VBI_START_LINE + 263;\r\nf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\r\nmemset(f->fmt.vbi.reserved, 0, sizeof(f->fmt.vbi.reserved));\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nif (dev->vbi_stream_on && !fh->stream_on) {\r\ndev_err(dev->dev,\r\n"%s device in use by another fh\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nreturn vidioc_try_fmt_vbi_cap(file, priv, f);\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn videobuf_reqbufs(&fh->vb_vidq, rb);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn videobuf_querybuf(&fh->vb_vidq, b);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn videobuf_qbuf(&fh->vb_vidq, b);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn videobuf_dqbuf(&fh->vb_vidq, b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int radio_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct cx231xx *dev = ((struct cx231xx_fh *)priv)->dev;\r\nif (t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\ncall_all(dev, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner(struct file *file, void *priv, const struct v4l2_tuner *t)\r\n{\r\nstruct cx231xx *dev = ((struct cx231xx_fh *)priv)->dev;\r\nif (t->index)\r\nreturn -EINVAL;\r\ncall_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int cx231xx_v4l2_open(struct file *filp)\r\n{\r\nint radio = 0;\r\nstruct video_device *vdev = video_devdata(filp);\r\nstruct cx231xx *dev = video_drvdata(filp);\r\nstruct cx231xx_fh *fh;\r\nenum v4l2_buf_type fh_type = 0;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nfh_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nfh_type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nradio = 1;\r\nbreak;\r\n}\r\ncx231xx_videodbg("open dev=%s type=%s users=%d\n",\r\nvideo_device_node_name(vdev), v4l2_type_names[fh_type],\r\ndev->users);\r\n#if 0\r\nerrCode = cx231xx_set_mode(dev, CX231XX_ANALOG_MODE);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"Device locked on digital mode. Can't open analog\n");\r\nreturn -EBUSY;\r\n}\r\n#endif\r\nfh = kzalloc(sizeof(struct cx231xx_fh), GFP_KERNEL);\r\nif (!fh)\r\nreturn -ENOMEM;\r\nif (mutex_lock_interruptible(&dev->lock)) {\r\nkfree(fh);\r\nreturn -ERESTARTSYS;\r\n}\r\nfh->dev = dev;\r\nfh->type = fh_type;\r\nfilp->private_data = fh;\r\nv4l2_fh_init(&fh->fh, vdev);\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE && dev->users == 0) {\r\nif (dev->board.external_av)\r\ncx231xx_set_power_mode(dev,\r\nPOLARIS_AVMODE_ENXTERNAL_AV);\r\nelse\r\ncx231xx_set_power_mode(dev, POLARIS_AVMODE_ANALOGT_TV);\r\n#if 0\r\ncx231xx_set_mode(dev, CX231XX_ANALOG_MODE);\r\n#endif\r\ncx231xx_set_video_alternate(dev);\r\ncx231xx_config_i2c(dev);\r\ndev->video_input = dev->video_input > 2 ? 2 : dev->video_input;\r\n}\r\nif (radio) {\r\ncx231xx_videodbg("video_open: setting radio device\n");\r\ncall_all(dev, tuner, s_radio);\r\n}\r\ndev->users++;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nvideobuf_queue_vmalloc_init(&fh->vb_vidq, &cx231xx_video_qops,\r\nNULL, &dev->video_mode.slock,\r\nfh->type, V4L2_FIELD_INTERLACED,\r\nsizeof(struct cx231xx_buffer),\r\nfh, &dev->lock);\r\nif (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\ncx231xx_set_alt_setting(dev, INDEX_VANC, 0);\r\nvideobuf_queue_vmalloc_init(&fh->vb_vidq, &cx231xx_vbi_qops,\r\nNULL, &dev->vbi_mode.slock,\r\nfh->type, V4L2_FIELD_SEQ_TB,\r\nsizeof(struct cx231xx_buffer),\r\nfh, &dev->lock);\r\n}\r\nmutex_unlock(&dev->lock);\r\nv4l2_fh_add(&fh->fh);\r\nreturn 0;\r\n}\r\nvoid cx231xx_release_analog_resources(struct cx231xx *dev)\r\n{\r\nif (video_is_registered(&dev->radio_dev))\r\nvideo_unregister_device(&dev->radio_dev);\r\nif (video_is_registered(&dev->vbi_dev)) {\r\ndev_info(dev->dev, "V4L2 device %s deregistered\n",\r\nvideo_device_node_name(&dev->vbi_dev));\r\nvideo_unregister_device(&dev->vbi_dev);\r\n}\r\nif (video_is_registered(&dev->vdev)) {\r\ndev_info(dev->dev, "V4L2 device %s deregistered\n",\r\nvideo_device_node_name(&dev->vdev));\r\nif (dev->board.has_417)\r\ncx231xx_417_unregister(dev);\r\nvideo_unregister_device(&dev->vdev);\r\n}\r\nv4l2_ctrl_handler_free(&dev->ctrl_handler);\r\nv4l2_ctrl_handler_free(&dev->radio_ctrl_handler);\r\n}\r\nstatic int cx231xx_close(struct file *filp)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\ncx231xx_videodbg("users=%d\n", dev->users);\r\ncx231xx_videodbg("users=%d\n", dev->users);\r\nif (res_check(fh))\r\nres_free(fh);\r\nif (!dev->board.no_alt_vanc)\r\nif (fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\nvideobuf_stop(&fh->vb_vidq);\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\nif (dev->state & DEV_DISCONNECTED) {\r\nif (atomic_read(&dev->devlist_count) > 0) {\r\ncx231xx_release_resources(dev);\r\nfh->dev = NULL;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\ncx231xx_uninit_vbi_isoc(dev);\r\nif (!dev->vbi_or_sliced_cc_mode)\r\ncx231xx_set_alt_setting(dev, INDEX_VANC, 0);\r\nelse\r\ncx231xx_set_alt_setting(dev, INDEX_HANC, 0);\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nkfree(fh);\r\ndev->users--;\r\nwake_up_interruptible(&dev->open);\r\nreturn 0;\r\n}\r\nv4l2_fh_del(&fh->fh);\r\ndev->users--;\r\nif (!dev->users) {\r\nvideobuf_stop(&fh->vb_vidq);\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\nif (dev->state & DEV_DISCONNECTED) {\r\ncx231xx_release_resources(dev);\r\nfh->dev = NULL;\r\nreturn 0;\r\n}\r\ncall_all(dev, core, s_power, 0);\r\nif (dev->USE_ISO)\r\ncx231xx_uninit_isoc(dev);\r\nelse\r\ncx231xx_uninit_bulk(dev);\r\ncx231xx_set_mode(dev, CX231XX_SUSPEND);\r\ncx231xx_set_alt_setting(dev, INDEX_VIDEO, 0);\r\n}\r\nv4l2_fh_exit(&fh->fh);\r\nkfree(fh);\r\nwake_up_interruptible(&dev->open);\r\nreturn 0;\r\n}\r\nstatic int cx231xx_v4l2_close(struct file *filp)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nmutex_lock(&dev->lock);\r\nrc = cx231xx_close(filp);\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\ncx231xx_v4l2_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *pos)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif ((fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ||\r\n(fh->type == V4L2_BUF_TYPE_VBI_CAPTURE)) {\r\nrc = res_get(fh);\r\nif (unlikely(rc < 0))\r\nreturn rc;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nrc = videobuf_read_stream(&fh->vb_vidq, buf, count, pos, 0,\r\nfilp->f_flags & O_NONBLOCK);\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int cx231xx_v4l2_poll(struct file *filp, poll_table *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nunsigned res = 0;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn POLLERR;\r\nrc = res_get(fh);\r\nif (unlikely(rc < 0))\r\nreturn POLLERR;\r\nif (v4l2_event_pending(&fh->fh))\r\nres |= POLLPRI;\r\nelse\r\npoll_wait(filp, &fh->fh.wait, wait);\r\nif (!(req_events & (POLLIN | POLLRDNORM)))\r\nreturn res;\r\nif ((V4L2_BUF_TYPE_VIDEO_CAPTURE == fh->type) ||\r\n(V4L2_BUF_TYPE_VBI_CAPTURE == fh->type)) {\r\nmutex_lock(&dev->lock);\r\nres |= videobuf_poll_stream(filp, &fh->vb_vidq, wait);\r\nmutex_unlock(&dev->lock);\r\nreturn res;\r\n}\r\nreturn res | POLLERR;\r\n}\r\nstatic int cx231xx_v4l2_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct cx231xx_fh *fh = filp->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nint rc;\r\nrc = check_dev(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = res_get(fh);\r\nif (unlikely(rc < 0))\r\nreturn rc;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nrc = videobuf_mmap_mapper(&fh->vb_vidq, vma);\r\nmutex_unlock(&dev->lock);\r\ncx231xx_videodbg("vma start=0x%08lx, size=%ld, ret=%d\n",\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end -\r\n(unsigned long)vma->vm_start, rc);\r\nreturn rc;\r\n}\r\nstatic void cx231xx_vdev_init(struct cx231xx *dev,\r\nstruct video_device *vfd,\r\nconst struct video_device *template,\r\nconst char *type_name)\r\n{\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release_empty;\r\nvfd->lock = &dev->lock;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s", dev->name, type_name);\r\nvideo_set_drvdata(vfd, dev);\r\nif (dev->tuner_type == TUNER_ABSENT) {\r\nv4l2_disable_ioctl(vfd, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(vfd, VIDIOC_S_FREQUENCY);\r\nv4l2_disable_ioctl(vfd, VIDIOC_G_TUNER);\r\nv4l2_disable_ioctl(vfd, VIDIOC_S_TUNER);\r\n}\r\n}\r\nint cx231xx_register_analog_devices(struct cx231xx *dev)\r\n{\r\nint ret;\r\ndev_info(dev->dev, "v4l2 driver version %s\n", CX231XX_VERSION);\r\ndev->norm = V4L2_STD_PAL;\r\ndev->width = norm_maxw(dev);\r\ndev->height = norm_maxh(dev);\r\ndev->interlaced = 0;\r\ndev->format = &format[0];\r\nvideo_mux(dev, dev->video_input);\r\ncall_all(dev, video, s_std, dev->norm);\r\nv4l2_ctrl_handler_init(&dev->ctrl_handler, 10);\r\nv4l2_ctrl_handler_init(&dev->radio_ctrl_handler, 5);\r\nif (dev->sd_cx25840) {\r\nv4l2_ctrl_add_handler(&dev->ctrl_handler,\r\ndev->sd_cx25840->ctrl_handler, NULL);\r\nv4l2_ctrl_add_handler(&dev->radio_ctrl_handler,\r\ndev->sd_cx25840->ctrl_handler,\r\nv4l2_ctrl_radio_filter);\r\n}\r\nif (dev->ctrl_handler.error)\r\nreturn dev->ctrl_handler.error;\r\nif (dev->radio_ctrl_handler.error)\r\nreturn dev->radio_ctrl_handler.error;\r\ncx231xx_vdev_init(dev, &dev->vdev, &cx231xx_video_template, "video");\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\ndev->video_pad.flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_pads_init(&dev->vdev.entity, 1, &dev->video_pad);\r\nif (ret < 0)\r\ndev_err(dev->dev, "failed to initialize video media entity!\n");\r\n#endif\r\ndev->vdev.ctrl_handler = &dev->ctrl_handler;\r\nret = video_register_device(&dev->vdev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev->devno]);\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"unable to register video device (error=%i).\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev_info(dev->dev, "Registered video device %s [v4l2]\n",\r\nvideo_device_node_name(&dev->vdev));\r\ncx231xx_vbi_template = cx231xx_video_template;\r\nstrcpy(cx231xx_vbi_template.name, "cx231xx-vbi");\r\ncx231xx_vdev_init(dev, &dev->vbi_dev, &cx231xx_vbi_template, "vbi");\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\ndev->vbi_pad.flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_pads_init(&dev->vbi_dev.entity, 1, &dev->vbi_pad);\r\nif (ret < 0)\r\ndev_err(dev->dev, "failed to initialize vbi media entity!\n");\r\n#endif\r\ndev->vbi_dev.ctrl_handler = &dev->ctrl_handler;\r\nret = video_register_device(&dev->vbi_dev, VFL_TYPE_VBI,\r\nvbi_nr[dev->devno]);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "unable to register vbi device\n");\r\nreturn ret;\r\n}\r\ndev_info(dev->dev, "Registered VBI device %s\n",\r\nvideo_device_node_name(&dev->vbi_dev));\r\nif (cx231xx_boards[dev->model].radio.type == CX231XX_RADIO) {\r\ncx231xx_vdev_init(dev, &dev->radio_dev,\r\n&cx231xx_radio_template, "radio");\r\ndev->radio_dev.ctrl_handler = &dev->radio_ctrl_handler;\r\nret = video_register_device(&dev->radio_dev, VFL_TYPE_RADIO,\r\nradio_nr[dev->devno]);\r\nif (ret < 0) {\r\ndev_err(dev->dev,\r\n"can't register radio device\n");\r\nreturn ret;\r\n}\r\ndev_info(dev->dev, "Registered radio device as %s\n",\r\nvideo_device_node_name(&dev->radio_dev));\r\n}\r\nreturn 0;\r\n}
