static struct scsi_dev_info_list_table *scsi_devinfo_lookup_by_key(int key)\r\n{\r\nstruct scsi_dev_info_list_table *devinfo_table;\r\nint found = 0;\r\nlist_for_each_entry(devinfo_table, &scsi_dev_info_list, node)\r\nif (devinfo_table->key == key) {\r\nfound = 1;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn devinfo_table;\r\n}\r\nstatic void scsi_strcpy_devinfo(char *name, char *to, size_t to_length,\r\nchar *from, int compatible)\r\n{\r\nsize_t from_length;\r\nfrom_length = strlen(from);\r\nstrncpy(to, from, min(to_length, from_length));\r\nif (from_length < to_length) {\r\nif (compatible) {\r\nto[from_length] = '\0';\r\n} else {\r\nstrncpy(&to[from_length], spaces,\r\nto_length - from_length);\r\n}\r\n}\r\nif (from_length > to_length)\r\nprintk(KERN_WARNING "%s: %s string '%s' is too long\n",\r\n__func__, name, from);\r\n}\r\nstatic int scsi_dev_info_list_add(int compatible, char *vendor, char *model,\r\nchar *strflags, int flags)\r\n{\r\nreturn scsi_dev_info_list_add_keyed(compatible, vendor, model,\r\nstrflags, flags,\r\nSCSI_DEVINFO_GLOBAL);\r\n}\r\nint scsi_dev_info_list_add_keyed(int compatible, char *vendor, char *model,\r\nchar *strflags, int flags, int key)\r\n{\r\nstruct scsi_dev_info_list *devinfo;\r\nstruct scsi_dev_info_list_table *devinfo_table =\r\nscsi_devinfo_lookup_by_key(key);\r\nif (IS_ERR(devinfo_table))\r\nreturn PTR_ERR(devinfo_table);\r\ndevinfo = kmalloc(sizeof(*devinfo), GFP_KERNEL);\r\nif (!devinfo) {\r\nprintk(KERN_ERR "%s: no memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nscsi_strcpy_devinfo("vendor", devinfo->vendor, sizeof(devinfo->vendor),\r\nvendor, compatible);\r\nscsi_strcpy_devinfo("model", devinfo->model, sizeof(devinfo->model),\r\nmodel, compatible);\r\nif (strflags)\r\ndevinfo->flags = simple_strtoul(strflags, NULL, 0);\r\nelse\r\ndevinfo->flags = flags;\r\ndevinfo->compatible = compatible;\r\nif (compatible)\r\nlist_add_tail(&devinfo->dev_info_list,\r\n&devinfo_table->scsi_dev_info_list);\r\nelse\r\nlist_add(&devinfo->dev_info_list,\r\n&devinfo_table->scsi_dev_info_list);\r\nreturn 0;\r\n}\r\nstatic struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,\r\nconst char *model, int key)\r\n{\r\nstruct scsi_dev_info_list *devinfo;\r\nstruct scsi_dev_info_list_table *devinfo_table =\r\nscsi_devinfo_lookup_by_key(key);\r\nsize_t vmax, mmax;\r\nconst char *vskip, *mskip;\r\nif (IS_ERR(devinfo_table))\r\nreturn (struct scsi_dev_info_list *) devinfo_table;\r\nvmax = sizeof(devinfo->vendor);\r\nvskip = vendor;\r\nwhile (vmax > 0 && *vskip == ' ') {\r\nvmax--;\r\nvskip++;\r\n}\r\nwhile (vmax > 0 && vskip[vmax - 1] == ' ')\r\n--vmax;\r\nmmax = sizeof(devinfo->model);\r\nmskip = model;\r\nwhile (mmax > 0 && *mskip == ' ') {\r\nmmax--;\r\nmskip++;\r\n}\r\nwhile (mmax > 0 && mskip[mmax - 1] == ' ')\r\n--mmax;\r\nlist_for_each_entry(devinfo, &devinfo_table->scsi_dev_info_list,\r\ndev_info_list) {\r\nif (devinfo->compatible) {\r\nif (memcmp(devinfo->vendor, vskip, vmax) ||\r\n(vmax < sizeof(devinfo->vendor) &&\r\ndevinfo->vendor[vmax]))\r\ncontinue;\r\nif (memcmp(devinfo->model, mskip, mmax) ||\r\n(mmax < sizeof(devinfo->model) &&\r\ndevinfo->model[mmax]))\r\ncontinue;\r\nreturn devinfo;\r\n} else {\r\nif (!memcmp(devinfo->vendor, vendor,\r\nsizeof(devinfo->vendor)) &&\r\n!memcmp(devinfo->model, model,\r\nsizeof(devinfo->model)))\r\nreturn devinfo;\r\n}\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nint scsi_dev_info_list_del_keyed(char *vendor, char *model, int key)\r\n{\r\nstruct scsi_dev_info_list *found;\r\nfound = scsi_dev_info_list_find(vendor, model, key);\r\nif (IS_ERR(found))\r\nreturn PTR_ERR(found);\r\nlist_del(&found->dev_info_list);\r\nkfree(found);\r\nreturn 0;\r\n}\r\nstatic int scsi_dev_info_list_add_str(char *dev_list)\r\n{\r\nchar *vendor, *model, *strflags, *next;\r\nchar *next_check;\r\nint res = 0;\r\nnext = dev_list;\r\nif (next && next[0] == '"') {\r\nnext++;\r\nnext_check = ",\"";\r\n} else {\r\nnext_check = ",";\r\n}\r\nfor (vendor = strsep(&next, ":"); vendor && (vendor[0] != '\0')\r\n&& (res == 0); vendor = strsep(&next, ":")) {\r\nstrflags = NULL;\r\nmodel = strsep(&next, ":");\r\nif (model)\r\nstrflags = strsep(&next, next_check);\r\nif (!model || !strflags) {\r\nprintk(KERN_ERR "%s: bad dev info string '%s' '%s'"\r\n" '%s'\n", __func__, vendor, model,\r\nstrflags);\r\nres = -EINVAL;\r\n} else\r\nres = scsi_dev_info_list_add(0 , vendor,\r\nmodel, strflags, 0);\r\n}\r\nreturn res;\r\n}\r\nint scsi_get_device_flags(struct scsi_device *sdev,\r\nconst unsigned char *vendor,\r\nconst unsigned char *model)\r\n{\r\nreturn scsi_get_device_flags_keyed(sdev, vendor, model,\r\nSCSI_DEVINFO_GLOBAL);\r\n}\r\nint scsi_get_device_flags_keyed(struct scsi_device *sdev,\r\nconst unsigned char *vendor,\r\nconst unsigned char *model,\r\nint key)\r\n{\r\nstruct scsi_dev_info_list *devinfo;\r\nint err;\r\ndevinfo = scsi_dev_info_list_find(vendor, model, key);\r\nif (!IS_ERR(devinfo))\r\nreturn devinfo->flags;\r\nerr = PTR_ERR(devinfo);\r\nif (err != -ENOENT)\r\nreturn err;\r\nif (key != SCSI_DEVINFO_GLOBAL)\r\nreturn 0;\r\nif (sdev->sdev_bflags)\r\nreturn sdev->sdev_bflags;\r\nreturn scsi_default_dev_flags;\r\n}\r\nstatic int devinfo_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct double_list *dl = v;\r\nstruct scsi_dev_info_list_table *devinfo_table =\r\nlist_entry(dl->top, struct scsi_dev_info_list_table, node);\r\nstruct scsi_dev_info_list *devinfo =\r\nlist_entry(dl->bottom, struct scsi_dev_info_list,\r\ndev_info_list);\r\nif (devinfo_table->scsi_dev_info_list.next == dl->bottom &&\r\ndevinfo_table->name)\r\nseq_printf(m, "[%s]:\n", devinfo_table->name);\r\nseq_printf(m, "'%.8s' '%.16s' 0x%x\n",\r\ndevinfo->vendor, devinfo->model, devinfo->flags);\r\nreturn 0;\r\n}\r\nstatic void *devinfo_seq_start(struct seq_file *m, loff_t *ppos)\r\n{\r\nstruct double_list *dl = kmalloc(sizeof(*dl), GFP_KERNEL);\r\nloff_t pos = *ppos;\r\nif (!dl)\r\nreturn NULL;\r\nlist_for_each(dl->top, &scsi_dev_info_list) {\r\nstruct scsi_dev_info_list_table *devinfo_table =\r\nlist_entry(dl->top, struct scsi_dev_info_list_table,\r\nnode);\r\nlist_for_each(dl->bottom, &devinfo_table->scsi_dev_info_list)\r\nif (pos-- == 0)\r\nreturn dl;\r\n}\r\nkfree(dl);\r\nreturn NULL;\r\n}\r\nstatic void *devinfo_seq_next(struct seq_file *m, void *v, loff_t *ppos)\r\n{\r\nstruct double_list *dl = v;\r\nstruct scsi_dev_info_list_table *devinfo_table =\r\nlist_entry(dl->top, struct scsi_dev_info_list_table, node);\r\n++*ppos;\r\ndl->bottom = dl->bottom->next;\r\nwhile (&devinfo_table->scsi_dev_info_list == dl->bottom) {\r\ndl->top = dl->top->next;\r\nif (dl->top == &scsi_dev_info_list) {\r\nkfree(dl);\r\nreturn NULL;\r\n}\r\ndevinfo_table = list_entry(dl->top,\r\nstruct scsi_dev_info_list_table,\r\nnode);\r\ndl->bottom = devinfo_table->scsi_dev_info_list.next;\r\n}\r\nreturn dl;\r\n}\r\nstatic void devinfo_seq_stop(struct seq_file *m, void *v)\r\n{\r\nkfree(v);\r\n}\r\nstatic int proc_scsi_devinfo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &scsi_devinfo_seq_ops);\r\n}\r\nstatic ssize_t proc_scsi_devinfo_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t length, loff_t *ppos)\r\n{\r\nchar *buffer;\r\nssize_t err = length;\r\nif (!buf || length>PAGE_SIZE)\r\nreturn -EINVAL;\r\nif (!(buffer = (char *) __get_free_page(GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nif (copy_from_user(buffer, buf, length)) {\r\nerr =-EFAULT;\r\ngoto out;\r\n}\r\nif (length < PAGE_SIZE)\r\nbuffer[length] = '\0';\r\nelse if (buffer[PAGE_SIZE-1]) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nscsi_dev_info_list_add_str(buffer);\r\nout:\r\nfree_page((unsigned long)buffer);\r\nreturn err;\r\n}\r\nvoid scsi_exit_devinfo(void)\r\n{\r\n#ifdef CONFIG_SCSI_PROC_FS\r\nremove_proc_entry("scsi/device_info", NULL);\r\n#endif\r\nscsi_dev_info_remove_list(SCSI_DEVINFO_GLOBAL);\r\n}\r\nint scsi_dev_info_add_list(int key, const char *name)\r\n{\r\nstruct scsi_dev_info_list_table *devinfo_table =\r\nscsi_devinfo_lookup_by_key(key);\r\nif (!IS_ERR(devinfo_table))\r\nreturn -EEXIST;\r\ndevinfo_table = kmalloc(sizeof(*devinfo_table), GFP_KERNEL);\r\nif (!devinfo_table)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&devinfo_table->node);\r\nINIT_LIST_HEAD(&devinfo_table->scsi_dev_info_list);\r\ndevinfo_table->name = name;\r\ndevinfo_table->key = key;\r\nlist_add_tail(&devinfo_table->node, &scsi_dev_info_list);\r\nreturn 0;\r\n}\r\nint scsi_dev_info_remove_list(int key)\r\n{\r\nstruct list_head *lh, *lh_next;\r\nstruct scsi_dev_info_list_table *devinfo_table =\r\nscsi_devinfo_lookup_by_key(key);\r\nif (IS_ERR(devinfo_table))\r\nreturn -EINVAL;\r\nlist_del(&devinfo_table->node);\r\nlist_for_each_safe(lh, lh_next, &devinfo_table->scsi_dev_info_list) {\r\nstruct scsi_dev_info_list *devinfo;\r\ndevinfo = list_entry(lh, struct scsi_dev_info_list,\r\ndev_info_list);\r\nkfree(devinfo);\r\n}\r\nkfree(devinfo_table);\r\nreturn 0;\r\n}\r\nint __init scsi_init_devinfo(void)\r\n{\r\n#ifdef CONFIG_SCSI_PROC_FS\r\nstruct proc_dir_entry *p;\r\n#endif\r\nint error, i;\r\nerror = scsi_dev_info_add_list(SCSI_DEVINFO_GLOBAL, NULL);\r\nif (error)\r\nreturn error;\r\nerror = scsi_dev_info_list_add_str(scsi_dev_flags);\r\nif (error)\r\ngoto out;\r\nfor (i = 0; scsi_static_device_list[i].vendor; i++) {\r\nerror = scsi_dev_info_list_add(1 ,\r\nscsi_static_device_list[i].vendor,\r\nscsi_static_device_list[i].model,\r\nNULL,\r\nscsi_static_device_list[i].flags);\r\nif (error)\r\ngoto out;\r\n}\r\n#ifdef CONFIG_SCSI_PROC_FS\r\np = proc_create("scsi/device_info", 0, NULL, &scsi_devinfo_proc_fops);\r\nif (!p) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\n#endif\r\nout:\r\nif (error)\r\nscsi_exit_devinfo();\r\nreturn error;\r\n}
