static u64\r\nget_imm64 (u64 insn_addr)\r\n{\r\nu64 *p = (u64 *) (insn_addr & -16);\r\nreturn ( (p[1] & 0x0800000000000000UL) << 4) |\r\n((p[1] & 0x00000000007fffffUL) << 40) |\r\n((p[0] & 0xffffc00000000000UL) >> 24) |\r\n((p[1] & 0x0000100000000000UL) >> 23) |\r\n((p[1] & 0x0003e00000000000UL) >> 29) |\r\n((p[1] & 0x07fc000000000000UL) >> 43) |\r\n((p[1] & 0x000007f000000000UL) >> 36);\r\n}\r\nvoid\r\nia64_patch (u64 insn_addr, u64 mask, u64 val)\r\n{\r\nu64 m0, m1, v0, v1, b0, b1, *b = (u64 *) (insn_addr & -16);\r\n# define insn_mask ((1UL << 41) - 1)\r\nunsigned long shift;\r\nb0 = b[0]; b1 = b[1];\r\nshift = 5 + 41 * (insn_addr % 16);\r\nif (shift >= 64) {\r\nm1 = mask << (shift - 64);\r\nv1 = val << (shift - 64);\r\n} else {\r\nm0 = mask << shift; m1 = mask >> (64 - shift);\r\nv0 = val << shift; v1 = val >> (64 - shift);\r\nb[0] = (b0 & ~m0) | (v0 & m0);\r\n}\r\nb[1] = (b1 & ~m1) | (v1 & m1);\r\n}\r\nvoid\r\nia64_patch_imm64 (u64 insn_addr, u64 val)\r\n{\r\ninsn_addr &= -16UL;\r\nia64_patch(insn_addr + 2,\r\n0x01fffefe000UL, ( ((val & 0x8000000000000000UL) >> 27)\r\n| ((val & 0x0000000000200000UL) << 0)\r\n| ((val & 0x00000000001f0000UL) << 6)\r\n| ((val & 0x000000000000ff80UL) << 20)\r\n| ((val & 0x000000000000007fUL) << 13) ));\r\nia64_patch(insn_addr + 1, 0x1ffffffffffUL, val >> 22);\r\n}\r\nvoid\r\nia64_patch_imm60 (u64 insn_addr, u64 val)\r\n{\r\ninsn_addr &= -16UL;\r\nia64_patch(insn_addr + 2,\r\n0x011ffffe000UL, ( ((val & 0x0800000000000000UL) >> 23)\r\n| ((val & 0x00000000000fffffUL) << 13) ));\r\nia64_patch(insn_addr + 1, 0x1fffffffffcUL, val >> 18);\r\n}\r\nvoid __init\r\nia64_patch_vtop (unsigned long start, unsigned long end)\r\n{\r\ns32 *offp = (s32 *) start;\r\nu64 ip;\r\nwhile (offp < (s32 *) end) {\r\nip = (u64) offp + *offp;\r\nia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));\r\nia64_fc((void *) ip);\r\n++offp;\r\n}\r\nia64_sync_i();\r\nia64_srlz_i();\r\n}\r\nvoid __init\r\nia64_patch_rse (unsigned long start, unsigned long end)\r\n{\r\ns32 *offp = (s32 *) start;\r\nu64 ip, *b;\r\nwhile (offp < (s32 *) end) {\r\nip = (u64) offp + *offp;\r\nb = (u64 *)(ip & -16);\r\nb[1] &= ~0xf800000L;\r\nia64_fc((void *) ip);\r\n++offp;\r\n}\r\nia64_sync_i();\r\nia64_srlz_i();\r\n}\r\nvoid __init\r\nia64_patch_mckinley_e9 (unsigned long start, unsigned long end)\r\n{\r\nstatic int first_time = 1;\r\nint need_workaround;\r\ns32 *offp = (s32 *) start;\r\nu64 *wp;\r\nneed_workaround = (local_cpu_data->family == 0x1f && local_cpu_data->model == 0);\r\nif (first_time) {\r\nfirst_time = 0;\r\nif (need_workaround)\r\nprintk(KERN_INFO "Leaving McKinley Errata 9 workaround enabled\n");\r\n}\r\nif (need_workaround)\r\nreturn;\r\nwhile (offp < (s32 *) end) {\r\nwp = (u64 *) ia64_imva((char *) offp + *offp);\r\nwp[0] = 0x0000000100000011UL;\r\nwp[1] = 0x0084006880000200UL;\r\nwp[2] = 0x0000000100000000UL;\r\nwp[3] = 0x0004000000000200UL;\r\nia64_fc(wp); ia64_fc(wp + 2);\r\n++offp;\r\n}\r\nia64_sync_i();\r\nia64_srlz_i();\r\n}\r\nstatic void __init\r\npatch_fsyscall_table (unsigned long start, unsigned long end)\r\n{\r\nextern unsigned long fsyscall_table[NR_syscalls];\r\ns32 *offp = (s32 *) start;\r\nu64 ip;\r\nwhile (offp < (s32 *) end) {\r\nip = (u64) ia64_imva((char *) offp + *offp);\r\nia64_patch_imm64(ip, (u64) fsyscall_table);\r\nia64_fc((void *) ip);\r\n++offp;\r\n}\r\nia64_sync_i();\r\nia64_srlz_i();\r\n}\r\nstatic void __init\r\npatch_brl_fsys_bubble_down (unsigned long start, unsigned long end)\r\n{\r\nextern char fsys_bubble_down[];\r\ns32 *offp = (s32 *) start;\r\nu64 ip;\r\nwhile (offp < (s32 *) end) {\r\nip = (u64) offp + *offp;\r\nia64_patch_imm60((u64) ia64_imva((void *) ip),\r\n(u64) (fsys_bubble_down - (ip & -16)) / 16);\r\nia64_fc((void *) ip);\r\n++offp;\r\n}\r\nia64_sync_i();\r\nia64_srlz_i();\r\n}\r\nvoid __init\r\nia64_patch_gate (void)\r\n{\r\n# define START(name) ((unsigned long) __start_gate_##name##_patchlist)\r\n# define END(name) ((unsigned long)__end_gate_##name##_patchlist)\r\npatch_fsyscall_table(START(fsyscall), END(fsyscall));\r\npatch_brl_fsys_bubble_down(START(brl_fsys_bubble_down), END(brl_fsys_bubble_down));\r\nia64_patch_vtop(START(vtop), END(vtop));\r\nia64_patch_mckinley_e9(START(mckinley_e9), END(mckinley_e9));\r\n}\r\nvoid ia64_patch_phys_stack_reg(unsigned long val)\r\n{\r\ns32 * offp = (s32 *) __start___phys_stack_reg_patchlist;\r\ns32 * end = (s32 *) __end___phys_stack_reg_patchlist;\r\nu64 ip, mask, imm;\r\nmask = (0x3fUL << 27) | (0x7f << 13);\r\nimm = (((val >> 7) & 0x3f) << 27) | (val & 0x7f) << 13;\r\nwhile (offp < end) {\r\nip = (u64) offp + *offp;\r\nia64_patch(ip, mask, imm);\r\nia64_fc((void *)ip);\r\n++offp;\r\n}\r\nia64_sync_i();\r\nia64_srlz_i();\r\n}
