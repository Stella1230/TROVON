static bool vga_switcheroo_ready(void)\r\n{\r\nreturn !vgasr_priv.active &&\r\nvgasr_priv.registered_clients == 2 && vgasr_priv.handler;\r\n}\r\nstatic void vga_switcheroo_enable(void)\r\n{\r\nint ret;\r\nstruct vga_switcheroo_client *client;\r\nif (vgasr_priv.handler->init)\r\nvgasr_priv.handler->init();\r\nlist_for_each_entry(client, &vgasr_priv.clients, list) {\r\nif (client->id != VGA_SWITCHEROO_UNKNOWN_ID)\r\ncontinue;\r\nret = vgasr_priv.handler->get_client_id(client->pdev);\r\nif (ret < 0)\r\nreturn;\r\nclient->id = ret;\r\n}\r\nvga_switcheroo_debugfs_init(&vgasr_priv);\r\nvgasr_priv.active = true;\r\n}\r\nint vga_switcheroo_register_handler(const struct vga_switcheroo_handler *handler,\r\nenum vga_switcheroo_handler_flags_t handler_flags)\r\n{\r\nmutex_lock(&vgasr_mutex);\r\nif (vgasr_priv.handler) {\r\nmutex_unlock(&vgasr_mutex);\r\nreturn -EINVAL;\r\n}\r\nvgasr_priv.handler = handler;\r\nvgasr_priv.handler_flags = handler_flags;\r\nif (vga_switcheroo_ready()) {\r\npr_info("enabled\n");\r\nvga_switcheroo_enable();\r\n}\r\nmutex_unlock(&vgasr_mutex);\r\nreturn 0;\r\n}\r\nvoid vga_switcheroo_unregister_handler(void)\r\n{\r\nmutex_lock(&vgasr_mutex);\r\nmutex_lock(&vgasr_priv.mux_hw_lock);\r\nvgasr_priv.handler_flags = 0;\r\nvgasr_priv.handler = NULL;\r\nif (vgasr_priv.active) {\r\npr_info("disabled\n");\r\nvga_switcheroo_debugfs_fini(&vgasr_priv);\r\nvgasr_priv.active = false;\r\n}\r\nmutex_unlock(&vgasr_priv.mux_hw_lock);\r\nmutex_unlock(&vgasr_mutex);\r\n}\r\nenum vga_switcheroo_handler_flags_t vga_switcheroo_handler_flags(void)\r\n{\r\nreturn vgasr_priv.handler_flags;\r\n}\r\nstatic int register_client(struct pci_dev *pdev,\r\nconst struct vga_switcheroo_client_ops *ops,\r\nenum vga_switcheroo_client_id id, bool active,\r\nbool driver_power_control)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nclient = kzalloc(sizeof(*client), GFP_KERNEL);\r\nif (!client)\r\nreturn -ENOMEM;\r\nclient->pwr_state = VGA_SWITCHEROO_ON;\r\nclient->pdev = pdev;\r\nclient->ops = ops;\r\nclient->id = id;\r\nclient->active = active;\r\nclient->driver_power_control = driver_power_control;\r\nmutex_lock(&vgasr_mutex);\r\nlist_add_tail(&client->list, &vgasr_priv.clients);\r\nif (client_is_vga(client))\r\nvgasr_priv.registered_clients++;\r\nif (vga_switcheroo_ready()) {\r\npr_info("enabled\n");\r\nvga_switcheroo_enable();\r\n}\r\nmutex_unlock(&vgasr_mutex);\r\nreturn 0;\r\n}\r\nint vga_switcheroo_register_client(struct pci_dev *pdev,\r\nconst struct vga_switcheroo_client_ops *ops,\r\nbool driver_power_control)\r\n{\r\nreturn register_client(pdev, ops, VGA_SWITCHEROO_UNKNOWN_ID,\r\npdev == vga_default_device(),\r\ndriver_power_control);\r\n}\r\nint vga_switcheroo_register_audio_client(struct pci_dev *pdev,\r\nconst struct vga_switcheroo_client_ops *ops,\r\nenum vga_switcheroo_client_id id)\r\n{\r\nreturn register_client(pdev, ops, id | ID_BIT_AUDIO, false, false);\r\n}\r\nstatic struct vga_switcheroo_client *\r\nfind_client_from_pci(struct list_head *head, struct pci_dev *pdev)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nlist_for_each_entry(client, head, list)\r\nif (client->pdev == pdev)\r\nreturn client;\r\nreturn NULL;\r\n}\r\nstatic struct vga_switcheroo_client *\r\nfind_client_from_id(struct list_head *head,\r\nenum vga_switcheroo_client_id client_id)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nlist_for_each_entry(client, head, list)\r\nif (client->id == client_id)\r\nreturn client;\r\nreturn NULL;\r\n}\r\nstatic struct vga_switcheroo_client *\r\nfind_active_client(struct list_head *head)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nlist_for_each_entry(client, head, list)\r\nif (client->active)\r\nreturn client;\r\nreturn NULL;\r\n}\r\nbool vga_switcheroo_client_probe_defer(struct pci_dev *pdev)\r\n{\r\nif ((pdev->class >> 16) == PCI_BASE_CLASS_DISPLAY) {\r\nif (apple_gmux_present() && pdev != vga_default_device() &&\r\n!vgasr_priv.handler_flags)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nenum vga_switcheroo_state vga_switcheroo_get_client_state(struct pci_dev *pdev)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nenum vga_switcheroo_state ret;\r\nmutex_lock(&vgasr_mutex);\r\nclient = find_client_from_pci(&vgasr_priv.clients, pdev);\r\nif (!client)\r\nret = VGA_SWITCHEROO_NOT_FOUND;\r\nelse\r\nret = client->pwr_state;\r\nmutex_unlock(&vgasr_mutex);\r\nreturn ret;\r\n}\r\nvoid vga_switcheroo_unregister_client(struct pci_dev *pdev)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nmutex_lock(&vgasr_mutex);\r\nclient = find_client_from_pci(&vgasr_priv.clients, pdev);\r\nif (client) {\r\nif (client_is_vga(client))\r\nvgasr_priv.registered_clients--;\r\nlist_del(&client->list);\r\nkfree(client);\r\n}\r\nif (vgasr_priv.active && vgasr_priv.registered_clients < 2) {\r\npr_info("disabled\n");\r\nvga_switcheroo_debugfs_fini(&vgasr_priv);\r\nvgasr_priv.active = false;\r\n}\r\nmutex_unlock(&vgasr_mutex);\r\n}\r\nvoid vga_switcheroo_client_fb_set(struct pci_dev *pdev,\r\nstruct fb_info *info)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nmutex_lock(&vgasr_mutex);\r\nclient = find_client_from_pci(&vgasr_priv.clients, pdev);\r\nif (client)\r\nclient->fb_info = info;\r\nmutex_unlock(&vgasr_mutex);\r\n}\r\nint vga_switcheroo_lock_ddc(struct pci_dev *pdev)\r\n{\r\nenum vga_switcheroo_client_id id;\r\nmutex_lock(&vgasr_priv.mux_hw_lock);\r\nif (!vgasr_priv.handler || !vgasr_priv.handler->switch_ddc) {\r\nvgasr_priv.old_ddc_owner = -ENODEV;\r\nreturn -ENODEV;\r\n}\r\nid = vgasr_priv.handler->get_client_id(pdev);\r\nvgasr_priv.old_ddc_owner = vgasr_priv.handler->switch_ddc(id);\r\nreturn vgasr_priv.old_ddc_owner;\r\n}\r\nint vga_switcheroo_unlock_ddc(struct pci_dev *pdev)\r\n{\r\nenum vga_switcheroo_client_id id;\r\nint ret = vgasr_priv.old_ddc_owner;\r\nif (WARN_ON_ONCE(!mutex_is_locked(&vgasr_priv.mux_hw_lock)))\r\nreturn -EINVAL;\r\nif (vgasr_priv.old_ddc_owner >= 0) {\r\nid = vgasr_priv.handler->get_client_id(pdev);\r\nif (vgasr_priv.old_ddc_owner != id)\r\nret = vgasr_priv.handler->switch_ddc(\r\nvgasr_priv.old_ddc_owner);\r\n}\r\nmutex_unlock(&vgasr_priv.mux_hw_lock);\r\nreturn ret;\r\n}\r\nstatic int vga_switcheroo_show(struct seq_file *m, void *v)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nint i = 0;\r\nmutex_lock(&vgasr_mutex);\r\nlist_for_each_entry(client, &vgasr_priv.clients, list) {\r\nseq_printf(m, "%d:%s%s:%c:%s%s:%s\n", i,\r\nclient_id(client) == VGA_SWITCHEROO_DIS ? "DIS" :\r\n"IGD",\r\nclient_is_vga(client) ? "" : "-Audio",\r\nclient->active ? '+' : ' ',\r\nclient->driver_power_control ? "Dyn" : "",\r\nclient->pwr_state ? "Pwr" : "Off",\r\npci_name(client->pdev));\r\ni++;\r\n}\r\nmutex_unlock(&vgasr_mutex);\r\nreturn 0;\r\n}\r\nstatic int vga_switcheroo_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, vga_switcheroo_show, NULL);\r\n}\r\nstatic int vga_switchon(struct vga_switcheroo_client *client)\r\n{\r\nif (client->driver_power_control)\r\nreturn 0;\r\nif (vgasr_priv.handler->power_state)\r\nvgasr_priv.handler->power_state(client->id, VGA_SWITCHEROO_ON);\r\nclient->ops->set_gpu_state(client->pdev, VGA_SWITCHEROO_ON);\r\nclient->pwr_state = VGA_SWITCHEROO_ON;\r\nreturn 0;\r\n}\r\nstatic int vga_switchoff(struct vga_switcheroo_client *client)\r\n{\r\nif (client->driver_power_control)\r\nreturn 0;\r\nclient->ops->set_gpu_state(client->pdev, VGA_SWITCHEROO_OFF);\r\nif (vgasr_priv.handler->power_state)\r\nvgasr_priv.handler->power_state(client->id, VGA_SWITCHEROO_OFF);\r\nclient->pwr_state = VGA_SWITCHEROO_OFF;\r\nreturn 0;\r\n}\r\nstatic void set_audio_state(enum vga_switcheroo_client_id id,\r\nenum vga_switcheroo_state state)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nclient = find_client_from_id(&vgasr_priv.clients, id | ID_BIT_AUDIO);\r\nif (client && client->pwr_state != state) {\r\nclient->ops->set_gpu_state(client->pdev, state);\r\nclient->pwr_state = state;\r\n}\r\n}\r\nstatic int vga_switchto_stage1(struct vga_switcheroo_client *new_client)\r\n{\r\nstruct vga_switcheroo_client *active;\r\nactive = find_active_client(&vgasr_priv.clients);\r\nif (!active)\r\nreturn 0;\r\nif (new_client->pwr_state == VGA_SWITCHEROO_OFF)\r\nvga_switchon(new_client);\r\nvga_set_default_device(new_client->pdev);\r\nreturn 0;\r\n}\r\nstatic int vga_switchto_stage2(struct vga_switcheroo_client *new_client)\r\n{\r\nint ret;\r\nstruct vga_switcheroo_client *active;\r\nactive = find_active_client(&vgasr_priv.clients);\r\nif (!active)\r\nreturn 0;\r\nactive->active = false;\r\nset_audio_state(active->id, VGA_SWITCHEROO_OFF);\r\nif (new_client->fb_info) {\r\nstruct fb_event event;\r\nconsole_lock();\r\nevent.info = new_client->fb_info;\r\nfb_notifier_call_chain(FB_EVENT_REMAP_ALL_CONSOLE, &event);\r\nconsole_unlock();\r\n}\r\nmutex_lock(&vgasr_priv.mux_hw_lock);\r\nret = vgasr_priv.handler->switchto(new_client->id);\r\nmutex_unlock(&vgasr_priv.mux_hw_lock);\r\nif (ret)\r\nreturn ret;\r\nif (new_client->ops->reprobe)\r\nnew_client->ops->reprobe(new_client->pdev);\r\nif (active->pwr_state == VGA_SWITCHEROO_ON)\r\nvga_switchoff(active);\r\nset_audio_state(new_client->id, VGA_SWITCHEROO_ON);\r\nnew_client->active = true;\r\nreturn 0;\r\n}\r\nstatic bool check_can_switch(void)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nlist_for_each_entry(client, &vgasr_priv.clients, list) {\r\nif (!client->ops->can_switch(client->pdev)) {\r\npr_err("client %x refused switch\n", client->id);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic ssize_t\r\nvga_switcheroo_debugfs_write(struct file *filp, const char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nchar usercmd[64];\r\nint ret;\r\nbool delay = false, can_switch;\r\nbool just_mux = false;\r\nenum vga_switcheroo_client_id client_id = VGA_SWITCHEROO_UNKNOWN_ID;\r\nstruct vga_switcheroo_client *client = NULL;\r\nif (cnt > 63)\r\ncnt = 63;\r\nif (copy_from_user(usercmd, ubuf, cnt))\r\nreturn -EFAULT;\r\nmutex_lock(&vgasr_mutex);\r\nif (!vgasr_priv.active) {\r\ncnt = -EINVAL;\r\ngoto out;\r\n}\r\nif (strncmp(usercmd, "OFF", 3) == 0) {\r\nlist_for_each_entry(client, &vgasr_priv.clients, list) {\r\nif (client->active || client_is_audio(client))\r\ncontinue;\r\nif (client->driver_power_control)\r\ncontinue;\r\nset_audio_state(client->id, VGA_SWITCHEROO_OFF);\r\nif (client->pwr_state == VGA_SWITCHEROO_ON)\r\nvga_switchoff(client);\r\n}\r\ngoto out;\r\n}\r\nif (strncmp(usercmd, "ON", 2) == 0) {\r\nlist_for_each_entry(client, &vgasr_priv.clients, list) {\r\nif (client->active || client_is_audio(client))\r\ncontinue;\r\nif (client->driver_power_control)\r\ncontinue;\r\nif (client->pwr_state == VGA_SWITCHEROO_OFF)\r\nvga_switchon(client);\r\nset_audio_state(client->id, VGA_SWITCHEROO_ON);\r\n}\r\ngoto out;\r\n}\r\nif (strncmp(usercmd, "DIGD", 4) == 0) {\r\nclient_id = VGA_SWITCHEROO_IGD;\r\ndelay = true;\r\n}\r\nif (strncmp(usercmd, "DDIS", 4) == 0) {\r\nclient_id = VGA_SWITCHEROO_DIS;\r\ndelay = true;\r\n}\r\nif (strncmp(usercmd, "IGD", 3) == 0)\r\nclient_id = VGA_SWITCHEROO_IGD;\r\nif (strncmp(usercmd, "DIS", 3) == 0)\r\nclient_id = VGA_SWITCHEROO_DIS;\r\nif (strncmp(usercmd, "MIGD", 4) == 0) {\r\njust_mux = true;\r\nclient_id = VGA_SWITCHEROO_IGD;\r\n}\r\nif (strncmp(usercmd, "MDIS", 4) == 0) {\r\njust_mux = true;\r\nclient_id = VGA_SWITCHEROO_DIS;\r\n}\r\nif (client_id == VGA_SWITCHEROO_UNKNOWN_ID)\r\ngoto out;\r\nclient = find_client_from_id(&vgasr_priv.clients, client_id);\r\nif (!client)\r\ngoto out;\r\nvgasr_priv.delayed_switch_active = false;\r\nif (just_mux) {\r\nmutex_lock(&vgasr_priv.mux_hw_lock);\r\nret = vgasr_priv.handler->switchto(client_id);\r\nmutex_unlock(&vgasr_priv.mux_hw_lock);\r\ngoto out;\r\n}\r\nif (client->active)\r\ngoto out;\r\ncan_switch = check_can_switch();\r\nif (can_switch == false && delay == false)\r\ngoto out;\r\nif (can_switch) {\r\nret = vga_switchto_stage1(client);\r\nif (ret)\r\npr_err("switching failed stage 1 %d\n", ret);\r\nret = vga_switchto_stage2(client);\r\nif (ret)\r\npr_err("switching failed stage 2 %d\n", ret);\r\n} else {\r\npr_info("setting delayed switch to client %d\n", client->id);\r\nvgasr_priv.delayed_switch_active = true;\r\nvgasr_priv.delayed_client_id = client_id;\r\nret = vga_switchto_stage1(client);\r\nif (ret)\r\npr_err("delayed switching stage 1 failed %d\n", ret);\r\n}\r\nout:\r\nmutex_unlock(&vgasr_mutex);\r\nreturn cnt;\r\n}\r\nstatic void vga_switcheroo_debugfs_fini(struct vgasr_priv *priv)\r\n{\r\ndebugfs_remove(priv->switch_file);\r\npriv->switch_file = NULL;\r\ndebugfs_remove(priv->debugfs_root);\r\npriv->debugfs_root = NULL;\r\n}\r\nstatic int vga_switcheroo_debugfs_init(struct vgasr_priv *priv)\r\n{\r\nstatic const char mp[] = "/sys/kernel/debug";\r\nif (priv->debugfs_root)\r\nreturn 0;\r\npriv->debugfs_root = debugfs_create_dir("vgaswitcheroo", NULL);\r\nif (!priv->debugfs_root) {\r\npr_err("Cannot create %s/vgaswitcheroo\n", mp);\r\ngoto fail;\r\n}\r\npriv->switch_file = debugfs_create_file("switch", 0644,\r\npriv->debugfs_root, NULL,\r\n&vga_switcheroo_debugfs_fops);\r\nif (!priv->switch_file) {\r\npr_err("cannot create %s/vgaswitcheroo/switch\n", mp);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nvga_switcheroo_debugfs_fini(priv);\r\nreturn -1;\r\n}\r\nint vga_switcheroo_process_delayed_switch(void)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nint ret;\r\nint err = -EINVAL;\r\nmutex_lock(&vgasr_mutex);\r\nif (!vgasr_priv.delayed_switch_active)\r\ngoto err;\r\npr_info("processing delayed switch to %d\n",\r\nvgasr_priv.delayed_client_id);\r\nclient = find_client_from_id(&vgasr_priv.clients,\r\nvgasr_priv.delayed_client_id);\r\nif (!client || !check_can_switch())\r\ngoto err;\r\nret = vga_switchto_stage2(client);\r\nif (ret)\r\npr_err("delayed switching failed stage 2 %d\n", ret);\r\nvgasr_priv.delayed_switch_active = false;\r\nerr = 0;\r\nerr:\r\nmutex_unlock(&vgasr_mutex);\r\nreturn err;\r\n}\r\nstatic void vga_switcheroo_power_switch(struct pci_dev *pdev,\r\nenum vga_switcheroo_state state)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nif (!vgasr_priv.handler->power_state)\r\nreturn;\r\nclient = find_client_from_pci(&vgasr_priv.clients, pdev);\r\nif (!client)\r\nreturn;\r\nif (!client->driver_power_control)\r\nreturn;\r\nvgasr_priv.handler->power_state(client->id, state);\r\n}\r\nvoid vga_switcheroo_set_dynamic_switch(struct pci_dev *pdev,\r\nenum vga_switcheroo_state dynamic)\r\n{\r\nstruct vga_switcheroo_client *client;\r\nmutex_lock(&vgasr_mutex);\r\nclient = find_client_from_pci(&vgasr_priv.clients, pdev);\r\nif (!client || !client->driver_power_control) {\r\nmutex_unlock(&vgasr_mutex);\r\nreturn;\r\n}\r\nclient->pwr_state = dynamic;\r\nset_audio_state(client->id, dynamic);\r\nmutex_unlock(&vgasr_mutex);\r\n}\r\nstatic int vga_switcheroo_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nint ret;\r\nret = dev->bus->pm->runtime_suspend(dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&vgasr_mutex);\r\nif (vgasr_priv.handler->switchto) {\r\nmutex_lock(&vgasr_priv.mux_hw_lock);\r\nvgasr_priv.handler->switchto(VGA_SWITCHEROO_IGD);\r\nmutex_unlock(&vgasr_priv.mux_hw_lock);\r\n}\r\nvga_switcheroo_power_switch(pdev, VGA_SWITCHEROO_OFF);\r\nmutex_unlock(&vgasr_mutex);\r\nreturn 0;\r\n}\r\nstatic int vga_switcheroo_runtime_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nint ret;\r\nmutex_lock(&vgasr_mutex);\r\nvga_switcheroo_power_switch(pdev, VGA_SWITCHEROO_ON);\r\nmutex_unlock(&vgasr_mutex);\r\nret = dev->bus->pm->runtime_resume(dev);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint vga_switcheroo_init_domain_pm_ops(struct device *dev,\r\nstruct dev_pm_domain *domain)\r\n{\r\nif (dev->bus && dev->bus->pm) {\r\ndomain->ops = *dev->bus->pm;\r\ndomain->ops.runtime_suspend = vga_switcheroo_runtime_suspend;\r\ndomain->ops.runtime_resume = vga_switcheroo_runtime_resume;\r\ndev_pm_domain_set(dev, domain);\r\nreturn 0;\r\n}\r\ndev_pm_domain_set(dev, NULL);\r\nreturn -EINVAL;\r\n}\r\nvoid vga_switcheroo_fini_domain_pm_ops(struct device *dev)\r\n{\r\ndev_pm_domain_set(dev, NULL);\r\n}\r\nstatic int vga_switcheroo_runtime_resume_hdmi_audio(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct vga_switcheroo_client *client;\r\nstruct device *video_dev = NULL;\r\nint ret;\r\nmutex_lock(&vgasr_mutex);\r\nlist_for_each_entry(client, &vgasr_priv.clients, list) {\r\nif (PCI_SLOT(client->pdev->devfn) == PCI_SLOT(pdev->devfn) &&\r\nclient_is_vga(client)) {\r\nvideo_dev = &client->pdev->dev;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vgasr_mutex);\r\nif (video_dev) {\r\nret = pm_runtime_get_sync(video_dev);\r\nif (ret && ret != 1)\r\nreturn ret;\r\n}\r\nret = dev->bus->pm->runtime_resume(dev);\r\nif (video_dev) {\r\npm_runtime_mark_last_busy(video_dev);\r\npm_runtime_put_autosuspend(video_dev);\r\n}\r\nreturn ret;\r\n}\r\nint\r\nvga_switcheroo_init_domain_pm_optimus_hdmi_audio(struct device *dev,\r\nstruct dev_pm_domain *domain)\r\n{\r\nif (dev->bus && dev->bus->pm) {\r\ndomain->ops = *dev->bus->pm;\r\ndomain->ops.runtime_resume =\r\nvga_switcheroo_runtime_resume_hdmi_audio;\r\ndev_pm_domain_set(dev, domain);\r\nreturn 0;\r\n}\r\ndev_pm_domain_set(dev, NULL);\r\nreturn -EINVAL;\r\n}
