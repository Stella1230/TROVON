static bool wait_for_reg(void __iomem *reg, u32 mask, unsigned long timeout)\r\n{\r\ntimeout += jiffies;\r\nwhile (time_is_after_eq_jiffies(timeout)) {\r\nif ((readl(reg) & mask) == mask)\r\nreturn true;\r\nmsleep(1);\r\n}\r\nreturn false;\r\n}\r\nstatic int mv_hsic_phy_init(struct phy *phy)\r\n{\r\nstruct mv_hsic_phy *mv_phy = phy_get_drvdata(phy);\r\nstruct platform_device *pdev = mv_phy->pdev;\r\nvoid __iomem *base = mv_phy->base;\r\nclk_prepare_enable(mv_phy->clk);\r\nwritel(0x1 << PHY_28NM_HSIC_PLL_SELLPFR_SHIFT |\r\n0xf0 << PHY_28NM_HSIC_PLL_FBDIV_SHIFT |\r\n0xd << PHY_28NM_HSIC_PLL_REFDIV_SHIFT,\r\nbase + PHY_28NM_HSIC_PLL_CTRL01);\r\nwritel(readl(base + PHY_28NM_HSIC_PLL_CTRL2) |\r\nPHY_28NM_HSIC_S2H_PU_PLL,\r\nbase + PHY_28NM_HSIC_PLL_CTRL2);\r\nif (!wait_for_reg(base + PHY_28NM_HSIC_PLL_CTRL2,\r\nPHY_28NM_HSIC_H2S_PLL_LOCK, HZ / 10)) {\r\ndev_err(&pdev->dev, "HSIC PHY PLL not locked after 100mS.");\r\nclk_disable_unprepare(mv_phy->clk);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv_hsic_phy_power_on(struct phy *phy)\r\n{\r\nstruct mv_hsic_phy *mv_phy = phy_get_drvdata(phy);\r\nstruct platform_device *pdev = mv_phy->pdev;\r\nvoid __iomem *base = mv_phy->base;\r\nu32 reg;\r\nreg = readl(base + PHY_28NM_HSIC_CTRL);\r\nreg &= ~S2H_DRV_SE0_4RESUME;\r\nreg |= PHY_28NM_HSIC_S2H_HSIC_EN;\r\nwritel(reg, base + PHY_28NM_HSIC_CTRL);\r\nif (!wait_for_reg(base + PHY_28NM_HSIC_IMPCAL_CAL,\r\nPHY_28NM_HSIC_H2S_IMPCAL_DONE, HZ / 10)) {\r\ndev_warn(&pdev->dev, "HSIC PHY READY not set after 100mS.");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wait_for_reg(base + PHY_28NM_HSIC_INT,\r\nPHY_28NM_HSIC_CONNECT_INT, HZ / 5)) {\r\ndev_warn(&pdev->dev, "HSIC wait for connect interrupt timeout.");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv_hsic_phy_power_off(struct phy *phy)\r\n{\r\nstruct mv_hsic_phy *mv_phy = phy_get_drvdata(phy);\r\nvoid __iomem *base = mv_phy->base;\r\nwritel(readl(base + PHY_28NM_HSIC_CTRL) & ~PHY_28NM_HSIC_S2H_HSIC_EN,\r\nbase + PHY_28NM_HSIC_CTRL);\r\nreturn 0;\r\n}\r\nstatic int mv_hsic_phy_exit(struct phy *phy)\r\n{\r\nstruct mv_hsic_phy *mv_phy = phy_get_drvdata(phy);\r\nvoid __iomem *base = mv_phy->base;\r\nwritel(readl(base + PHY_28NM_HSIC_PLL_CTRL2) &\r\n~PHY_28NM_HSIC_S2H_PU_PLL,\r\nbase + PHY_28NM_HSIC_PLL_CTRL2);\r\nclk_disable_unprepare(mv_phy->clk);\r\nreturn 0;\r\n}\r\nstatic int mv_hsic_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct phy_provider *phy_provider;\r\nstruct mv_hsic_phy *mv_phy;\r\nstruct resource *r;\r\nmv_phy = devm_kzalloc(&pdev->dev, sizeof(*mv_phy), GFP_KERNEL);\r\nif (!mv_phy)\r\nreturn -ENOMEM;\r\nmv_phy->pdev = pdev;\r\nmv_phy->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mv_phy->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock.\n");\r\nreturn PTR_ERR(mv_phy->clk);\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmv_phy->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(mv_phy->base))\r\nreturn PTR_ERR(mv_phy->base);\r\nmv_phy->phy = devm_phy_create(&pdev->dev, pdev->dev.of_node, &hsic_ops);\r\nif (IS_ERR(mv_phy->phy))\r\nreturn PTR_ERR(mv_phy->phy);\r\nphy_set_drvdata(mv_phy->phy, mv_phy);\r\nphy_provider = devm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
