static void *alloc_pgt_page(void *context)\r\n{\r\nstruct alloc_pgt_data *pages = (struct alloc_pgt_data *)context;\r\nunsigned char *entry;\r\nif (pages->pgt_buf_offset >= pages->pgt_buf_size) {\r\ndebug_putstr("out of pgt_buf in " __FILE__ "!?\n");\r\ndebug_putaddr(pages->pgt_buf_offset);\r\ndebug_putaddr(pages->pgt_buf_size);\r\nreturn NULL;\r\n}\r\nentry = pages->pgt_buf + pages->pgt_buf_offset;\r\npages->pgt_buf_offset += PAGE_SIZE;\r\nreturn entry;\r\n}\r\nvoid initialize_identity_maps(void)\r\n{\r\nmapping_info.alloc_pgt_page = alloc_pgt_page;\r\nmapping_info.context = &pgt_data;\r\npgt_data.pgt_buf_offset = 0;\r\nlevel4p = read_cr3();\r\nif (level4p == (unsigned long)_pgtable) {\r\ndebug_putstr("booted via startup_32()\n");\r\npgt_data.pgt_buf = _pgtable + BOOT_INIT_PGT_SIZE;\r\npgt_data.pgt_buf_size = BOOT_PGT_SIZE - BOOT_INIT_PGT_SIZE;\r\nmemset(pgt_data.pgt_buf, 0, pgt_data.pgt_buf_size);\r\n} else {\r\ndebug_putstr("booted via startup_64()\n");\r\npgt_data.pgt_buf = _pgtable;\r\npgt_data.pgt_buf_size = BOOT_PGT_SIZE;\r\nmemset(pgt_data.pgt_buf, 0, pgt_data.pgt_buf_size);\r\nlevel4p = (unsigned long)alloc_pgt_page(&pgt_data);\r\n}\r\n}\r\nvoid add_identity_map(unsigned long start, unsigned long size)\r\n{\r\nunsigned long end = start + size;\r\nstart = round_down(start, PMD_SIZE);\r\nend = round_up(end, PMD_SIZE);\r\nif (start >= end)\r\nreturn;\r\nkernel_ident_mapping_init(&mapping_info, (pgd_t *)level4p,\r\nstart, end);\r\n}\r\nvoid finalize_identity_maps(void)\r\n{\r\nwrite_cr3(level4p);\r\n}
