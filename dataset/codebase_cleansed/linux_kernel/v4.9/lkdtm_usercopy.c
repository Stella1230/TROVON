static noinline unsigned char *trick_compiler(unsigned char *stack)\r\n{\r\nreturn stack + 0;\r\n}\r\nstatic noinline unsigned char *do_usercopy_stack_callee(int value)\r\n{\r\nunsigned char buf[32];\r\nint i;\r\nfor (i = 0; i < sizeof(buf); i++) {\r\nbuf[i] = value & 0xff;\r\n}\r\nreturn trick_compiler(buf);\r\n}\r\nstatic noinline void do_usercopy_stack(bool to_user, bool bad_frame)\r\n{\r\nunsigned long user_addr;\r\nunsigned char good_stack[32];\r\nunsigned char *bad_stack;\r\nint i;\r\nfor (i = 0; i < sizeof(good_stack); i++)\r\ngood_stack[i] = test_text[i % sizeof(test_text)];\r\nif (bad_frame) {\r\nbad_stack = do_usercopy_stack_callee((uintptr_t)&bad_stack);\r\n} else {\r\nbad_stack = task_stack_page(current) + THREAD_SIZE;\r\nbad_stack -= sizeof(unsigned long);\r\n}\r\nuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_ANONYMOUS | MAP_PRIVATE, 0);\r\nif (user_addr >= TASK_SIZE) {\r\npr_warn("Failed to allocate user memory\n");\r\nreturn;\r\n}\r\nif (to_user) {\r\npr_info("attempting good copy_to_user of local stack\n");\r\nif (copy_to_user((void __user *)user_addr, good_stack,\r\nunconst + sizeof(good_stack))) {\r\npr_warn("copy_to_user failed unexpectedly?!\n");\r\ngoto free_user;\r\n}\r\npr_info("attempting bad copy_to_user of distant stack\n");\r\nif (copy_to_user((void __user *)user_addr, bad_stack,\r\nunconst + sizeof(good_stack))) {\r\npr_warn("copy_to_user failed, but lacked Oops\n");\r\ngoto free_user;\r\n}\r\n} else {\r\nif (!bad_frame)\r\ngoto free_user;\r\npr_info("attempting good copy_from_user of local stack\n");\r\nif (copy_from_user(good_stack, (void __user *)user_addr,\r\nunconst + sizeof(good_stack))) {\r\npr_warn("copy_from_user failed unexpectedly?!\n");\r\ngoto free_user;\r\n}\r\npr_info("attempting bad copy_from_user of distant stack\n");\r\nif (copy_from_user(bad_stack, (void __user *)user_addr,\r\nunconst + sizeof(good_stack))) {\r\npr_warn("copy_from_user failed, but lacked Oops\n");\r\ngoto free_user;\r\n}\r\n}\r\nfree_user:\r\nvm_munmap(user_addr, PAGE_SIZE);\r\n}\r\nstatic void do_usercopy_heap_size(bool to_user)\r\n{\r\nunsigned long user_addr;\r\nunsigned char *one, *two;\r\nsize_t size = unconst + 1024;\r\none = kmalloc(size, GFP_KERNEL);\r\ntwo = kmalloc(size, GFP_KERNEL);\r\nif (!one || !two) {\r\npr_warn("Failed to allocate kernel memory\n");\r\ngoto free_kernel;\r\n}\r\nuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_ANONYMOUS | MAP_PRIVATE, 0);\r\nif (user_addr >= TASK_SIZE) {\r\npr_warn("Failed to allocate user memory\n");\r\ngoto free_kernel;\r\n}\r\nmemset(one, 'A', size);\r\nmemset(two, 'B', size);\r\nif (to_user) {\r\npr_info("attempting good copy_to_user of correct size\n");\r\nif (copy_to_user((void __user *)user_addr, one, size)) {\r\npr_warn("copy_to_user failed unexpectedly?!\n");\r\ngoto free_user;\r\n}\r\npr_info("attempting bad copy_to_user of too large size\n");\r\nif (copy_to_user((void __user *)user_addr, one, 2 * size)) {\r\npr_warn("copy_to_user failed, but lacked Oops\n");\r\ngoto free_user;\r\n}\r\n} else {\r\npr_info("attempting good copy_from_user of correct size\n");\r\nif (copy_from_user(one, (void __user *)user_addr, size)) {\r\npr_warn("copy_from_user failed unexpectedly?!\n");\r\ngoto free_user;\r\n}\r\npr_info("attempting bad copy_from_user of too large size\n");\r\nif (copy_from_user(one, (void __user *)user_addr, 2 * size)) {\r\npr_warn("copy_from_user failed, but lacked Oops\n");\r\ngoto free_user;\r\n}\r\n}\r\nfree_user:\r\nvm_munmap(user_addr, PAGE_SIZE);\r\nfree_kernel:\r\nkfree(one);\r\nkfree(two);\r\n}\r\nstatic void do_usercopy_heap_flag(bool to_user)\r\n{\r\nunsigned long user_addr;\r\nunsigned char *good_buf = NULL;\r\nunsigned char *bad_buf = NULL;\r\nif (!bad_cache) {\r\npr_warn("Failed to allocate kernel cache\n");\r\nreturn;\r\n}\r\ngood_buf = kmalloc(cache_size, GFP_KERNEL);\r\nbad_buf = kmem_cache_alloc(bad_cache, GFP_KERNEL);\r\nif (!good_buf || !bad_buf) {\r\npr_warn("Failed to allocate buffers from caches\n");\r\ngoto free_alloc;\r\n}\r\nuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_ANONYMOUS | MAP_PRIVATE, 0);\r\nif (user_addr >= TASK_SIZE) {\r\npr_warn("Failed to allocate user memory\n");\r\ngoto free_alloc;\r\n}\r\nmemset(good_buf, 'A', cache_size);\r\nmemset(bad_buf, 'B', cache_size);\r\nif (to_user) {\r\npr_info("attempting good copy_to_user with SLAB_USERCOPY\n");\r\nif (copy_to_user((void __user *)user_addr, good_buf,\r\ncache_size)) {\r\npr_warn("copy_to_user failed unexpectedly?!\n");\r\ngoto free_user;\r\n}\r\npr_info("attempting bad copy_to_user w/o SLAB_USERCOPY\n");\r\nif (copy_to_user((void __user *)user_addr, bad_buf,\r\ncache_size)) {\r\npr_warn("copy_to_user failed, but lacked Oops\n");\r\ngoto free_user;\r\n}\r\n} else {\r\npr_info("attempting good copy_from_user with SLAB_USERCOPY\n");\r\nif (copy_from_user(good_buf, (void __user *)user_addr,\r\ncache_size)) {\r\npr_warn("copy_from_user failed unexpectedly?!\n");\r\ngoto free_user;\r\n}\r\npr_info("attempting bad copy_from_user w/o SLAB_USERCOPY\n");\r\nif (copy_from_user(bad_buf, (void __user *)user_addr,\r\ncache_size)) {\r\npr_warn("copy_from_user failed, but lacked Oops\n");\r\ngoto free_user;\r\n}\r\n}\r\nfree_user:\r\nvm_munmap(user_addr, PAGE_SIZE);\r\nfree_alloc:\r\nif (bad_buf)\r\nkmem_cache_free(bad_cache, bad_buf);\r\nkfree(good_buf);\r\n}\r\nvoid lkdtm_USERCOPY_HEAP_SIZE_TO(void)\r\n{\r\ndo_usercopy_heap_size(true);\r\n}\r\nvoid lkdtm_USERCOPY_HEAP_SIZE_FROM(void)\r\n{\r\ndo_usercopy_heap_size(false);\r\n}\r\nvoid lkdtm_USERCOPY_HEAP_FLAG_TO(void)\r\n{\r\ndo_usercopy_heap_flag(true);\r\n}\r\nvoid lkdtm_USERCOPY_HEAP_FLAG_FROM(void)\r\n{\r\ndo_usercopy_heap_flag(false);\r\n}\r\nvoid lkdtm_USERCOPY_STACK_FRAME_TO(void)\r\n{\r\ndo_usercopy_stack(true, true);\r\n}\r\nvoid lkdtm_USERCOPY_STACK_FRAME_FROM(void)\r\n{\r\ndo_usercopy_stack(false, true);\r\n}\r\nvoid lkdtm_USERCOPY_STACK_BEYOND(void)\r\n{\r\ndo_usercopy_stack(true, false);\r\n}\r\nvoid lkdtm_USERCOPY_KERNEL(void)\r\n{\r\nunsigned long user_addr;\r\nuser_addr = vm_mmap(NULL, 0, PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC,\r\nMAP_ANONYMOUS | MAP_PRIVATE, 0);\r\nif (user_addr >= TASK_SIZE) {\r\npr_warn("Failed to allocate user memory\n");\r\nreturn;\r\n}\r\npr_info("attempting good copy_to_user from kernel rodata\n");\r\nif (copy_to_user((void __user *)user_addr, test_text,\r\nunconst + sizeof(test_text))) {\r\npr_warn("copy_to_user failed unexpectedly?!\n");\r\ngoto free_user;\r\n}\r\npr_info("attempting bad copy_to_user from kernel text\n");\r\nif (copy_to_user((void __user *)user_addr, vm_mmap,\r\nunconst + PAGE_SIZE)) {\r\npr_warn("copy_to_user failed, but lacked Oops\n");\r\ngoto free_user;\r\n}\r\nfree_user:\r\nvm_munmap(user_addr, PAGE_SIZE);\r\n}\r\nvoid __init lkdtm_usercopy_init(void)\r\n{\r\nbad_cache = kmem_cache_create("lkdtm-no-usercopy", cache_size, 0,\r\n0, NULL);\r\n}\r\nvoid __exit lkdtm_usercopy_exit(void)\r\n{\r\nkmem_cache_destroy(bad_cache);\r\n}
