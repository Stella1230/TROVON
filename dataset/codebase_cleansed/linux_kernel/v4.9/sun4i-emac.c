static void emac_update_speed(struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nunsigned int reg_val;\r\nreg_val = readl(db->membase + EMAC_MAC_SUPP_REG);\r\nreg_val &= ~(0x1 << 8);\r\nif (db->speed == SPEED_100)\r\nreg_val |= 1 << 8;\r\nwritel(reg_val, db->membase + EMAC_MAC_SUPP_REG);\r\n}\r\nstatic void emac_update_duplex(struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nunsigned int reg_val;\r\nreg_val = readl(db->membase + EMAC_MAC_CTL1_REG);\r\nreg_val &= ~EMAC_MAC_CTL1_DUPLEX_EN;\r\nif (db->duplex)\r\nreg_val |= EMAC_MAC_CTL1_DUPLEX_EN;\r\nwritel(reg_val, db->membase + EMAC_MAC_CTL1_REG);\r\n}\r\nstatic void emac_handle_link_change(struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nstruct phy_device *phydev = dev->phydev;\r\nunsigned long flags;\r\nint status_change = 0;\r\nif (phydev->link) {\r\nif (db->speed != phydev->speed) {\r\nspin_lock_irqsave(&db->lock, flags);\r\ndb->speed = phydev->speed;\r\nemac_update_speed(dev);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nstatus_change = 1;\r\n}\r\nif (db->duplex != phydev->duplex) {\r\nspin_lock_irqsave(&db->lock, flags);\r\ndb->duplex = phydev->duplex;\r\nemac_update_duplex(dev);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nstatus_change = 1;\r\n}\r\n}\r\nif (phydev->link != db->link) {\r\nif (!phydev->link) {\r\ndb->speed = 0;\r\ndb->duplex = -1;\r\n}\r\ndb->link = phydev->link;\r\nstatus_change = 1;\r\n}\r\nif (status_change)\r\nphy_print_status(phydev);\r\n}\r\nstatic int emac_mdio_probe(struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nstruct phy_device *phydev;\r\nphydev = of_phy_connect(db->ndev, db->phy_node,\r\n&emac_handle_link_change, 0,\r\ndb->phy_interface);\r\nif (!phydev) {\r\nnetdev_err(db->ndev, "could not find the PHY\n");\r\nreturn -ENODEV;\r\n}\r\nphydev->supported &= PHY_BASIC_FEATURES;\r\nphydev->advertising = phydev->supported;\r\ndb->link = 0;\r\ndb->speed = 0;\r\ndb->duplex = -1;\r\nreturn 0;\r\n}\r\nstatic void emac_mdio_remove(struct net_device *dev)\r\n{\r\nphy_disconnect(dev->phydev);\r\n}\r\nstatic void emac_reset(struct emac_board_info *db)\r\n{\r\ndev_dbg(db->dev, "resetting device\n");\r\nwritel(0, db->membase + EMAC_CTL_REG);\r\nudelay(200);\r\nwritel(EMAC_CTL_RESET, db->membase + EMAC_CTL_REG);\r\nudelay(200);\r\n}\r\nstatic void emac_outblk_32bit(void __iomem *reg, void *data, int count)\r\n{\r\nwritesl(reg, data, round_up(count, 4) / 4);\r\n}\r\nstatic void emac_inblk_32bit(void __iomem *reg, void *data, int count)\r\n{\r\nreadsl(reg, data, round_up(count, 4) / 4);\r\n}\r\nstatic int emac_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct phy_device *phydev = dev->phydev;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(phydev, rq, cmd);\r\n}\r\nstatic void emac_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(DRV_NAME));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(DRV_VERSION));\r\nstrlcpy(info->bus_info, dev_name(&dev->dev), sizeof(info->bus_info));\r\n}\r\nstatic unsigned int emac_setup(struct net_device *ndev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(ndev);\r\nunsigned int reg_val;\r\nreg_val = readl(db->membase + EMAC_TX_MODE_REG);\r\nwritel(reg_val | EMAC_TX_MODE_ABORTED_FRAME_EN,\r\ndb->membase + EMAC_TX_MODE_REG);\r\nreg_val = readl(db->membase + EMAC_MAC_CTL0_REG);\r\nwritel(reg_val | EMAC_MAC_CTL0_RX_FLOW_CTL_EN |\r\nEMAC_MAC_CTL0_TX_FLOW_CTL_EN,\r\ndb->membase + EMAC_MAC_CTL0_REG);\r\nreg_val = readl(db->membase + EMAC_MAC_CTL1_REG);\r\nreg_val |= EMAC_MAC_CTL1_LEN_CHECK_EN;\r\nreg_val |= EMAC_MAC_CTL1_CRC_EN;\r\nreg_val |= EMAC_MAC_CTL1_PAD_EN;\r\nwritel(reg_val, db->membase + EMAC_MAC_CTL1_REG);\r\nwritel(EMAC_MAC_IPGT_FULL_DUPLEX, db->membase + EMAC_MAC_IPGT_REG);\r\nwritel((EMAC_MAC_IPGR_IPG1 << 8) | EMAC_MAC_IPGR_IPG2,\r\ndb->membase + EMAC_MAC_IPGR_REG);\r\nwritel((EMAC_MAC_CLRT_COLLISION_WINDOW << 8) | EMAC_MAC_CLRT_RM,\r\ndb->membase + EMAC_MAC_CLRT_REG);\r\nwritel(EMAC_MAX_FRAME_LEN,\r\ndb->membase + EMAC_MAC_MAXF_REG);\r\nreturn 0;\r\n}\r\nstatic void emac_set_rx_mode(struct net_device *ndev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(ndev);\r\nunsigned int reg_val;\r\nreg_val = readl(db->membase + EMAC_RX_CTL_REG);\r\nif (ndev->flags & IFF_PROMISC)\r\nreg_val |= EMAC_RX_CTL_PASS_ALL_EN;\r\nelse\r\nreg_val &= ~EMAC_RX_CTL_PASS_ALL_EN;\r\nwritel(reg_val | EMAC_RX_CTL_PASS_LEN_OOR_EN |\r\nEMAC_RX_CTL_ACCEPT_UNICAST_EN | EMAC_RX_CTL_DA_FILTER_EN |\r\nEMAC_RX_CTL_ACCEPT_MULTICAST_EN |\r\nEMAC_RX_CTL_ACCEPT_BROADCAST_EN,\r\ndb->membase + EMAC_RX_CTL_REG);\r\n}\r\nstatic unsigned int emac_powerup(struct net_device *ndev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(ndev);\r\nunsigned int reg_val;\r\nreg_val = readl(db->membase + EMAC_RX_CTL_REG);\r\nreg_val |= 0x8;\r\nwritel(reg_val, db->membase + EMAC_RX_CTL_REG);\r\nudelay(1);\r\nreg_val = readl(db->membase + EMAC_MAC_CTL0_REG);\r\nreg_val &= ~EMAC_MAC_CTL0_SOFT_RESET;\r\nwritel(reg_val, db->membase + EMAC_MAC_CTL0_REG);\r\nreg_val = readl(db->membase + EMAC_MAC_MCFG_REG);\r\nreg_val &= (~(0xf << 2));\r\nreg_val |= (0xD << 2);\r\nwritel(reg_val, db->membase + EMAC_MAC_MCFG_REG);\r\nwritel(0x0, db->membase + EMAC_RX_FBC_REG);\r\nwritel(0, db->membase + EMAC_INT_CTL_REG);\r\nreg_val = readl(db->membase + EMAC_INT_STA_REG);\r\nwritel(reg_val, db->membase + EMAC_INT_STA_REG);\r\nudelay(1);\r\nemac_setup(ndev);\r\nwritel(ndev->dev_addr[0] << 16 | ndev->dev_addr[1] << 8 | ndev->\r\ndev_addr[2], db->membase + EMAC_MAC_A1_REG);\r\nwritel(ndev->dev_addr[3] << 16 | ndev->dev_addr[4] << 8 | ndev->\r\ndev_addr[5], db->membase + EMAC_MAC_A0_REG);\r\nmdelay(1);\r\nreturn 0;\r\n}\r\nstatic int emac_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nwritel(dev->dev_addr[0] << 16 | dev->dev_addr[1] << 8 | dev->\r\ndev_addr[2], db->membase + EMAC_MAC_A1_REG);\r\nwritel(dev->dev_addr[3] << 16 | dev->dev_addr[4] << 8 | dev->\r\ndev_addr[5], db->membase + EMAC_MAC_A0_REG);\r\nreturn 0;\r\n}\r\nstatic void emac_init_device(struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nunsigned long flags;\r\nunsigned int reg_val;\r\nspin_lock_irqsave(&db->lock, flags);\r\nemac_update_speed(dev);\r\nemac_update_duplex(dev);\r\nreg_val = readl(db->membase + EMAC_CTL_REG);\r\nwritel(reg_val | EMAC_CTL_RESET | EMAC_CTL_TX_EN | EMAC_CTL_RX_EN,\r\ndb->membase + EMAC_CTL_REG);\r\nreg_val = readl(db->membase + EMAC_INT_CTL_REG);\r\nreg_val |= (0xf << 0) | (0x01 << 8);\r\nwritel(reg_val, db->membase + EMAC_INT_CTL_REG);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic void emac_timeout(struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nunsigned long flags;\r\nif (netif_msg_timer(db))\r\ndev_err(db->dev, "tx time out.\n");\r\nspin_lock_irqsave(&db->lock, flags);\r\nnetif_stop_queue(dev);\r\nemac_reset(db);\r\nemac_init_device(dev);\r\nnetif_trans_update(dev);\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic int emac_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nunsigned long channel;\r\nunsigned long flags;\r\nchannel = db->tx_fifo_stat & 3;\r\nif (channel == 3)\r\nreturn 1;\r\nchannel = (channel == 1 ? 1 : 0);\r\nspin_lock_irqsave(&db->lock, flags);\r\nwritel(channel, db->membase + EMAC_TX_INS_REG);\r\nemac_outblk_32bit(db->membase + EMAC_TX_IO_DATA_REG,\r\nskb->data, skb->len);\r\ndev->stats.tx_bytes += skb->len;\r\ndb->tx_fifo_stat |= 1 << channel;\r\nif (channel == 0) {\r\nwritel(skb->len, db->membase + EMAC_TX_PL0_REG);\r\nwritel(readl(db->membase + EMAC_TX_CTL0_REG) | 1,\r\ndb->membase + EMAC_TX_CTL0_REG);\r\nnetif_trans_update(dev);\r\n} else if (channel == 1) {\r\nwritel(skb->len, db->membase + EMAC_TX_PL1_REG);\r\nwritel(readl(db->membase + EMAC_TX_CTL1_REG) | 1,\r\ndb->membase + EMAC_TX_CTL1_REG);\r\nnetif_trans_update(dev);\r\n}\r\nif ((db->tx_fifo_stat & 3) == 3) {\r\nnetif_stop_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&db->lock, flags);\r\ndev_consume_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void emac_tx_done(struct net_device *dev, struct emac_board_info *db,\r\nunsigned int tx_status)\r\n{\r\ndb->tx_fifo_stat &= ~(tx_status & 3);\r\nif (3 == (tx_status & 3))\r\ndev->stats.tx_packets += 2;\r\nelse\r\ndev->stats.tx_packets++;\r\nif (netif_msg_tx_done(db))\r\ndev_dbg(db->dev, "tx done, NSR %02x\n", tx_status);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void emac_rx(struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nu8 *rdptr;\r\nbool good_packet;\r\nstatic int rxlen_last;\r\nunsigned int reg_val;\r\nu32 rxhdr, rxstatus, rxcount, rxlen;\r\nwhile (1) {\r\nrxcount = readl(db->membase + EMAC_RX_FBC_REG);\r\nif (netif_msg_rx_status(db))\r\ndev_dbg(db->dev, "RXCount: %x\n", rxcount);\r\nif ((db->skb_last != NULL) && (rxlen_last > 0)) {\r\ndev->stats.rx_bytes += rxlen_last;\r\ndb->skb_last->protocol = eth_type_trans(db->skb_last,\r\ndev);\r\nnetif_rx(db->skb_last);\r\ndev->stats.rx_packets++;\r\ndb->skb_last = NULL;\r\nrxlen_last = 0;\r\nreg_val = readl(db->membase + EMAC_RX_CTL_REG);\r\nreg_val &= ~EMAC_RX_CTL_DMA_EN;\r\nwritel(reg_val, db->membase + EMAC_RX_CTL_REG);\r\n}\r\nif (!rxcount) {\r\ndb->emacrx_completed_flag = 1;\r\nreg_val = readl(db->membase + EMAC_INT_CTL_REG);\r\nreg_val |= (0xf << 0) | (0x01 << 8);\r\nwritel(reg_val, db->membase + EMAC_INT_CTL_REG);\r\nrxcount = readl(db->membase + EMAC_RX_FBC_REG);\r\nif (!rxcount)\r\nreturn;\r\n}\r\nreg_val = readl(db->membase + EMAC_RX_IO_DATA_REG);\r\nif (netif_msg_rx_status(db))\r\ndev_dbg(db->dev, "receive header: %x\n", reg_val);\r\nif (reg_val != EMAC_UNDOCUMENTED_MAGIC) {\r\nreg_val = readl(db->membase + EMAC_CTL_REG);\r\nwritel(reg_val & ~EMAC_CTL_RX_EN,\r\ndb->membase + EMAC_CTL_REG);\r\nreg_val = readl(db->membase + EMAC_RX_CTL_REG);\r\nwritel(reg_val | (1 << 3),\r\ndb->membase + EMAC_RX_CTL_REG);\r\ndo {\r\nreg_val = readl(db->membase + EMAC_RX_CTL_REG);\r\n} while (reg_val & (1 << 3));\r\nreg_val = readl(db->membase + EMAC_CTL_REG);\r\nwritel(reg_val | EMAC_CTL_RX_EN,\r\ndb->membase + EMAC_CTL_REG);\r\nreg_val = readl(db->membase + EMAC_INT_CTL_REG);\r\nreg_val |= (0xf << 0) | (0x01 << 8);\r\nwritel(reg_val, db->membase + EMAC_INT_CTL_REG);\r\ndb->emacrx_completed_flag = 1;\r\nreturn;\r\n}\r\ngood_packet = true;\r\nemac_inblk_32bit(db->membase + EMAC_RX_IO_DATA_REG,\r\n&rxhdr, sizeof(rxhdr));\r\nif (netif_msg_rx_status(db))\r\ndev_dbg(db->dev, "rxhdr: %x\n", *((int *)(&rxhdr)));\r\nrxlen = EMAC_RX_IO_DATA_LEN(rxhdr);\r\nrxstatus = EMAC_RX_IO_DATA_STATUS(rxhdr);\r\nif (netif_msg_rx_status(db))\r\ndev_dbg(db->dev, "RX: status %02x, length %04x\n",\r\nrxstatus, rxlen);\r\nif (rxlen < 0x40) {\r\ngood_packet = false;\r\nif (netif_msg_rx_err(db))\r\ndev_dbg(db->dev, "RX: Bad Packet (runt)\n");\r\n}\r\nif (unlikely(!(rxstatus & EMAC_RX_IO_DATA_STATUS_OK))) {\r\ngood_packet = false;\r\nif (rxstatus & EMAC_RX_IO_DATA_STATUS_CRC_ERR) {\r\nif (netif_msg_rx_err(db))\r\ndev_dbg(db->dev, "crc error\n");\r\ndev->stats.rx_crc_errors++;\r\n}\r\nif (rxstatus & EMAC_RX_IO_DATA_STATUS_LEN_ERR) {\r\nif (netif_msg_rx_err(db))\r\ndev_dbg(db->dev, "length error\n");\r\ndev->stats.rx_length_errors++;\r\n}\r\n}\r\nif (good_packet) {\r\nskb = netdev_alloc_skb(dev, rxlen + 4);\r\nif (!skb)\r\ncontinue;\r\nskb_reserve(skb, 2);\r\nrdptr = (u8 *) skb_put(skb, rxlen - 4);\r\nif (netif_msg_rx_status(db))\r\ndev_dbg(db->dev, "RxLen %x\n", rxlen);\r\nemac_inblk_32bit(db->membase + EMAC_RX_IO_DATA_REG,\r\nrdptr, rxlen);\r\ndev->stats.rx_bytes += rxlen;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t emac_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nint int_status;\r\nunsigned long flags;\r\nunsigned int reg_val;\r\nspin_lock_irqsave(&db->lock, flags);\r\nwritel(0, db->membase + EMAC_INT_CTL_REG);\r\nint_status = readl(db->membase + EMAC_INT_STA_REG);\r\nwritel(int_status, db->membase + EMAC_INT_STA_REG);\r\nif (netif_msg_intr(db))\r\ndev_dbg(db->dev, "emac interrupt %02x\n", int_status);\r\nif ((int_status & 0x100) && (db->emacrx_completed_flag == 1)) {\r\ndb->emacrx_completed_flag = 0;\r\nemac_rx(dev);\r\n}\r\nif (int_status & (0x01 | 0x02))\r\nemac_tx_done(dev, db, int_status);\r\nif (int_status & (0x04 | 0x08))\r\nnetdev_info(dev, " ab : %x\n", int_status);\r\nif (db->emacrx_completed_flag == 1) {\r\nreg_val = readl(db->membase + EMAC_INT_CTL_REG);\r\nreg_val |= (0xf << 0) | (0x01 << 8);\r\nwritel(reg_val, db->membase + EMAC_INT_CTL_REG);\r\n}\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void emac_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nemac_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int emac_open(struct net_device *dev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nint ret;\r\nif (netif_msg_ifup(db))\r\ndev_dbg(db->dev, "enabling %s\n", dev->name);\r\nif (request_irq(dev->irq, &emac_interrupt, 0, dev->name, dev))\r\nreturn -EAGAIN;\r\nemac_reset(db);\r\nemac_init_device(dev);\r\nret = emac_mdio_probe(dev);\r\nif (ret < 0) {\r\nfree_irq(dev->irq, dev);\r\nnetdev_err(dev, "cannot probe MDIO bus\n");\r\nreturn ret;\r\n}\r\nphy_start(dev->phydev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void emac_shutdown(struct net_device *dev)\r\n{\r\nunsigned int reg_val;\r\nstruct emac_board_info *db = netdev_priv(dev);\r\nwritel(0, db->membase + EMAC_INT_CTL_REG);\r\nreg_val = readl(db->membase + EMAC_INT_STA_REG);\r\nwritel(reg_val, db->membase + EMAC_INT_STA_REG);\r\nreg_val = readl(db->membase + EMAC_CTL_REG);\r\nreg_val &= ~(EMAC_CTL_TX_EN | EMAC_CTL_RX_EN | EMAC_CTL_RESET);\r\nwritel(reg_val, db->membase + EMAC_CTL_REG);\r\n}\r\nstatic int emac_stop(struct net_device *ndev)\r\n{\r\nstruct emac_board_info *db = netdev_priv(ndev);\r\nif (netif_msg_ifdown(db))\r\ndev_dbg(db->dev, "shutting down %s\n", ndev->name);\r\nnetif_stop_queue(ndev);\r\nnetif_carrier_off(ndev);\r\nphy_stop(ndev->phydev);\r\nemac_mdio_remove(ndev);\r\nemac_shutdown(ndev);\r\nfree_irq(ndev->irq, ndev);\r\nreturn 0;\r\n}\r\nstatic int emac_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct emac_board_info *db;\r\nstruct net_device *ndev;\r\nint ret = 0;\r\nconst char *mac_addr;\r\nndev = alloc_etherdev(sizeof(struct emac_board_info));\r\nif (!ndev) {\r\ndev_err(&pdev->dev, "could not allocate device.\n");\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\ndb = netdev_priv(ndev);\r\nmemset(db, 0, sizeof(*db));\r\ndb->dev = &pdev->dev;\r\ndb->ndev = ndev;\r\ndb->pdev = pdev;\r\nspin_lock_init(&db->lock);\r\ndb->membase = of_iomap(np, 0);\r\nif (!db->membase) {\r\ndev_err(&pdev->dev, "failed to remap registers\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nndev->base_addr = (unsigned long)db->membase;\r\nndev->irq = irq_of_parse_and_map(np, 0);\r\nif (ndev->irq == -ENXIO) {\r\nnetdev_err(ndev, "No irq resource\n");\r\nret = ndev->irq;\r\ngoto out_iounmap;\r\n}\r\ndb->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(db->clk)) {\r\nret = PTR_ERR(db->clk);\r\ngoto out_iounmap;\r\n}\r\nret = clk_prepare_enable(db->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Error couldn't enable clock (%d)\n", ret);\r\ngoto out_iounmap;\r\n}\r\nret = sunxi_sram_claim(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Error couldn't map SRAM to device\n");\r\ngoto out_clk_disable_unprepare;\r\n}\r\ndb->phy_node = of_parse_phandle(np, "phy", 0);\r\nif (!db->phy_node) {\r\ndev_err(&pdev->dev, "no associated PHY\n");\r\nret = -ENODEV;\r\ngoto out_release_sram;\r\n}\r\nmac_addr = of_get_mac_address(np);\r\nif (mac_addr)\r\nmemcpy(ndev->dev_addr, mac_addr, ETH_ALEN);\r\nif (!is_valid_ether_addr(ndev->dev_addr)) {\r\neth_hw_addr_random(ndev);\r\ndev_warn(&pdev->dev, "using random MAC address %pM\n",\r\nndev->dev_addr);\r\n}\r\ndb->emacrx_completed_flag = 1;\r\nemac_powerup(ndev);\r\nemac_reset(db);\r\nndev->netdev_ops = &emac_netdev_ops;\r\nndev->watchdog_timeo = msecs_to_jiffies(watchdog);\r\nndev->ethtool_ops = &emac_ethtool_ops;\r\nplatform_set_drvdata(pdev, ndev);\r\nnetif_carrier_off(ndev);\r\nret = register_netdev(ndev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Registering netdev failed!\n");\r\nret = -ENODEV;\r\ngoto out_release_sram;\r\n}\r\ndev_info(&pdev->dev, "%s: at %p, IRQ %d MAC: %pM\n",\r\nndev->name, db->membase, ndev->irq, ndev->dev_addr);\r\nreturn 0;\r\nout_release_sram:\r\nsunxi_sram_release(&pdev->dev);\r\nout_clk_disable_unprepare:\r\nclk_disable_unprepare(db->clk);\r\nout_iounmap:\r\niounmap(db->membase);\r\nout:\r\ndev_err(db->dev, "not found (%d).\n", ret);\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int emac_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct emac_board_info *db = netdev_priv(ndev);\r\nunregister_netdev(ndev);\r\nsunxi_sram_release(&pdev->dev);\r\nclk_disable_unprepare(db->clk);\r\niounmap(db->membase);\r\nfree_netdev(ndev);\r\ndev_dbg(&pdev->dev, "released and freed device\n");\r\nreturn 0;\r\n}\r\nstatic int emac_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(dev);\r\nnetif_carrier_off(ndev);\r\nnetif_device_detach(ndev);\r\nemac_shutdown(ndev);\r\nreturn 0;\r\n}\r\nstatic int emac_resume(struct platform_device *dev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(dev);\r\nstruct emac_board_info *db = netdev_priv(ndev);\r\nemac_reset(db);\r\nemac_init_device(ndev);\r\nnetif_device_attach(ndev);\r\nreturn 0;\r\n}
