static long do_sys_name_to_handle(struct path *path,\r\nstruct file_handle __user *ufh,\r\nint __user *mnt_id)\r\n{\r\nlong retval;\r\nstruct file_handle f_handle;\r\nint handle_dwords, handle_bytes;\r\nstruct file_handle *handle = NULL;\r\nif (!path->dentry->d_sb->s_export_op ||\r\n!path->dentry->d_sb->s_export_op->fh_to_dentry)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle)))\r\nreturn -EFAULT;\r\nif (f_handle.handle_bytes > MAX_HANDLE_SZ)\r\nreturn -EINVAL;\r\nhandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\r\nGFP_KERNEL);\r\nif (!handle)\r\nreturn -ENOMEM;\r\nhandle_dwords = f_handle.handle_bytes >> 2;\r\nretval = exportfs_encode_fh(path->dentry,\r\n(struct fid *)handle->f_handle,\r\n&handle_dwords, 0);\r\nhandle->handle_type = retval;\r\nhandle_bytes = handle_dwords * sizeof(u32);\r\nhandle->handle_bytes = handle_bytes;\r\nif ((handle->handle_bytes > f_handle.handle_bytes) ||\r\n(retval == FILEID_INVALID) || (retval == -ENOSPC)) {\r\nhandle_bytes = 0;\r\nretval = -EOVERFLOW;\r\n} else\r\nretval = 0;\r\nif (copy_to_user(mnt_id, &real_mount(path->mnt)->mnt_id,\r\nsizeof(*mnt_id)) ||\r\ncopy_to_user(ufh, handle,\r\nsizeof(struct file_handle) + handle_bytes))\r\nretval = -EFAULT;\r\nkfree(handle);\r\nreturn retval;\r\n}\r\nstatic struct vfsmount *get_vfsmount_from_fd(int fd)\r\n{\r\nstruct vfsmount *mnt;\r\nif (fd == AT_FDCWD) {\r\nstruct fs_struct *fs = current->fs;\r\nspin_lock(&fs->lock);\r\nmnt = mntget(fs->pwd.mnt);\r\nspin_unlock(&fs->lock);\r\n} else {\r\nstruct fd f = fdget(fd);\r\nif (!f.file)\r\nreturn ERR_PTR(-EBADF);\r\nmnt = mntget(f.file->f_path.mnt);\r\nfdput(f);\r\n}\r\nreturn mnt;\r\n}\r\nstatic int vfs_dentry_acceptable(void *context, struct dentry *dentry)\r\n{\r\nreturn 1;\r\n}\r\nstatic int do_handle_to_path(int mountdirfd, struct file_handle *handle,\r\nstruct path *path)\r\n{\r\nint retval = 0;\r\nint handle_dwords;\r\npath->mnt = get_vfsmount_from_fd(mountdirfd);\r\nif (IS_ERR(path->mnt)) {\r\nretval = PTR_ERR(path->mnt);\r\ngoto out_err;\r\n}\r\nhandle_dwords = handle->handle_bytes >> 2;\r\npath->dentry = exportfs_decode_fh(path->mnt,\r\n(struct fid *)handle->f_handle,\r\nhandle_dwords, handle->handle_type,\r\nvfs_dentry_acceptable, NULL);\r\nif (IS_ERR(path->dentry)) {\r\nretval = PTR_ERR(path->dentry);\r\ngoto out_mnt;\r\n}\r\nreturn 0;\r\nout_mnt:\r\nmntput(path->mnt);\r\nout_err:\r\nreturn retval;\r\n}\r\nstatic int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\r\nstruct path *path)\r\n{\r\nint retval = 0;\r\nstruct file_handle f_handle;\r\nstruct file_handle *handle = NULL;\r\nif (!capable(CAP_DAC_READ_SEARCH)) {\r\nretval = -EPERM;\r\ngoto out_err;\r\n}\r\nif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\r\nretval = -EFAULT;\r\ngoto out_err;\r\n}\r\nif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\r\n(f_handle.handle_bytes == 0)) {\r\nretval = -EINVAL;\r\ngoto out_err;\r\n}\r\nhandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\r\nGFP_KERNEL);\r\nif (!handle) {\r\nretval = -ENOMEM;\r\ngoto out_err;\r\n}\r\n*handle = f_handle;\r\nif (copy_from_user(&handle->f_handle,\r\n&ufh->f_handle,\r\nf_handle.handle_bytes)) {\r\nretval = -EFAULT;\r\ngoto out_handle;\r\n}\r\nretval = do_handle_to_path(mountdirfd, handle, path);\r\nout_handle:\r\nkfree(handle);\r\nout_err:\r\nreturn retval;\r\n}\r\nlong do_handle_open(int mountdirfd,\r\nstruct file_handle __user *ufh, int open_flag)\r\n{\r\nlong retval = 0;\r\nstruct path path;\r\nstruct file *file;\r\nint fd;\r\nretval = handle_to_path(mountdirfd, ufh, &path);\r\nif (retval)\r\nreturn retval;\r\nfd = get_unused_fd_flags(open_flag);\r\nif (fd < 0) {\r\npath_put(&path);\r\nreturn fd;\r\n}\r\nfile = file_open_root(path.dentry, path.mnt, "", open_flag, 0);\r\nif (IS_ERR(file)) {\r\nput_unused_fd(fd);\r\nretval = PTR_ERR(file);\r\n} else {\r\nretval = fd;\r\nfsnotify_open(file);\r\nfd_install(fd, file);\r\n}\r\npath_put(&path);\r\nreturn retval;\r\n}
