static inline void zynqmp_dma_writeq(struct zynqmp_dma_chan *chan, u32 reg,\r\nu64 value)\r\n{\r\nlo_hi_writeq(value, chan->regs + reg);\r\n}\r\nstatic void zynqmp_dma_update_desc_to_ctrlr(struct zynqmp_dma_chan *chan,\r\nstruct zynqmp_dma_desc_sw *desc)\r\n{\r\ndma_addr_t addr;\r\naddr = desc->src_p;\r\nzynqmp_dma_writeq(chan, ZYNQMP_DMA_SRC_START_LSB, addr);\r\naddr = desc->dst_p;\r\nzynqmp_dma_writeq(chan, ZYNQMP_DMA_DST_START_LSB, addr);\r\n}\r\nstatic void zynqmp_dma_desc_config_eod(struct zynqmp_dma_chan *chan,\r\nvoid *desc)\r\n{\r\nstruct zynqmp_dma_desc_ll *hw = (struct zynqmp_dma_desc_ll *)desc;\r\nhw->ctrl |= ZYNQMP_DMA_DESC_CTRL_STOP;\r\nhw++;\r\nhw->ctrl |= ZYNQMP_DMA_DESC_CTRL_COMP_INT | ZYNQMP_DMA_DESC_CTRL_STOP;\r\n}\r\nstatic void zynqmp_dma_config_sg_ll_desc(struct zynqmp_dma_chan *chan,\r\nstruct zynqmp_dma_desc_ll *sdesc,\r\ndma_addr_t src, dma_addr_t dst, size_t len,\r\nstruct zynqmp_dma_desc_ll *prev)\r\n{\r\nstruct zynqmp_dma_desc_ll *ddesc = sdesc + 1;\r\nsdesc->size = ddesc->size = len;\r\nsdesc->addr = src;\r\nddesc->addr = dst;\r\nsdesc->ctrl = ddesc->ctrl = ZYNQMP_DMA_DESC_CTRL_SIZE_256;\r\nif (chan->is_dmacoherent) {\r\nsdesc->ctrl |= ZYNQMP_DMA_DESC_CTRL_COHRNT;\r\nddesc->ctrl |= ZYNQMP_DMA_DESC_CTRL_COHRNT;\r\n}\r\nif (prev) {\r\ndma_addr_t addr = chan->desc_pool_p +\r\n((uintptr_t)sdesc - (uintptr_t)chan->desc_pool_v);\r\nddesc = prev + 1;\r\nprev->nxtdscraddr = addr;\r\nddesc->nxtdscraddr = addr + ZYNQMP_DMA_DESC_SIZE(chan);\r\n}\r\n}\r\nstatic void zynqmp_dma_init(struct zynqmp_dma_chan *chan)\r\n{\r\nu32 val;\r\nwritel(ZYNQMP_DMA_IDS_DEFAULT_MASK, chan->regs + ZYNQMP_DMA_IDS);\r\nval = readl(chan->regs + ZYNQMP_DMA_ISR);\r\nwritel(val, chan->regs + ZYNQMP_DMA_ISR);\r\nif (chan->is_dmacoherent) {\r\nval = ZYNQMP_DMA_AXCOHRNT;\r\nval = (val & ~ZYNQMP_DMA_AXCACHE) |\r\n(ZYNQMP_DMA_AXCACHE_VAL << ZYNQMP_DMA_AXCACHE_OFST);\r\nwritel(val, chan->regs + ZYNQMP_DMA_DSCR_ATTR);\r\n}\r\nval = readl(chan->regs + ZYNQMP_DMA_DATA_ATTR);\r\nif (chan->is_dmacoherent) {\r\nval = (val & ~ZYNQMP_DMA_ARCACHE) |\r\n(ZYNQMP_DMA_AXCACHE_VAL << ZYNQMP_DMA_ARCACHE_OFST);\r\nval = (val & ~ZYNQMP_DMA_AWCACHE) |\r\n(ZYNQMP_DMA_AXCACHE_VAL << ZYNQMP_DMA_AWCACHE_OFST);\r\n}\r\nwritel(val, chan->regs + ZYNQMP_DMA_DATA_ATTR);\r\nval = readl(chan->regs + ZYNQMP_DMA_IRQ_SRC_ACCT);\r\nval = readl(chan->regs + ZYNQMP_DMA_IRQ_DST_ACCT);\r\nchan->idle = true;\r\n}\r\nstatic dma_cookie_t zynqmp_dma_tx_submit(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct zynqmp_dma_chan *chan = to_chan(tx->chan);\r\nstruct zynqmp_dma_desc_sw *desc, *new;\r\ndma_cookie_t cookie;\r\nnew = tx_to_desc(tx);\r\nspin_lock_bh(&chan->lock);\r\ncookie = dma_cookie_assign(tx);\r\nif (!list_empty(&chan->pending_list)) {\r\ndesc = list_last_entry(&chan->pending_list,\r\nstruct zynqmp_dma_desc_sw, node);\r\nif (!list_empty(&desc->tx_list))\r\ndesc = list_last_entry(&desc->tx_list,\r\nstruct zynqmp_dma_desc_sw, node);\r\ndesc->src_v->nxtdscraddr = new->src_p;\r\ndesc->src_v->ctrl &= ~ZYNQMP_DMA_DESC_CTRL_STOP;\r\ndesc->dst_v->nxtdscraddr = new->dst_p;\r\ndesc->dst_v->ctrl &= ~ZYNQMP_DMA_DESC_CTRL_STOP;\r\n}\r\nlist_add_tail(&new->node, &chan->pending_list);\r\nspin_unlock_bh(&chan->lock);\r\nreturn cookie;\r\n}\r\nstatic struct zynqmp_dma_desc_sw *\r\nzynqmp_dma_get_descriptor(struct zynqmp_dma_chan *chan)\r\n{\r\nstruct zynqmp_dma_desc_sw *desc;\r\nspin_lock_bh(&chan->lock);\r\ndesc = list_first_entry(&chan->free_list,\r\nstruct zynqmp_dma_desc_sw, node);\r\nlist_del(&desc->node);\r\nspin_unlock_bh(&chan->lock);\r\nINIT_LIST_HEAD(&desc->tx_list);\r\nmemset((void *)desc->src_v, 0, ZYNQMP_DMA_DESC_SIZE(chan));\r\nmemset((void *)desc->dst_v, 0, ZYNQMP_DMA_DESC_SIZE(chan));\r\nreturn desc;\r\n}\r\nstatic void zynqmp_dma_free_descriptor(struct zynqmp_dma_chan *chan,\r\nstruct zynqmp_dma_desc_sw *sdesc)\r\n{\r\nstruct zynqmp_dma_desc_sw *child, *next;\r\nchan->desc_free_cnt++;\r\nlist_add_tail(&sdesc->node, &chan->free_list);\r\nlist_for_each_entry_safe(child, next, &sdesc->tx_list, node) {\r\nchan->desc_free_cnt++;\r\nlist_move_tail(&child->node, &chan->free_list);\r\n}\r\n}\r\nstatic void zynqmp_dma_free_desc_list(struct zynqmp_dma_chan *chan,\r\nstruct list_head *list)\r\n{\r\nstruct zynqmp_dma_desc_sw *desc, *next;\r\nlist_for_each_entry_safe(desc, next, list, node)\r\nzynqmp_dma_free_descriptor(chan, desc);\r\n}\r\nstatic int zynqmp_dma_alloc_chan_resources(struct dma_chan *dchan)\r\n{\r\nstruct zynqmp_dma_chan *chan = to_chan(dchan);\r\nstruct zynqmp_dma_desc_sw *desc;\r\nint i;\r\nchan->sw_desc_pool = kzalloc(sizeof(*desc) * ZYNQMP_DMA_NUM_DESCS,\r\nGFP_KERNEL);\r\nif (!chan->sw_desc_pool)\r\nreturn -ENOMEM;\r\nchan->idle = true;\r\nchan->desc_free_cnt = ZYNQMP_DMA_NUM_DESCS;\r\nINIT_LIST_HEAD(&chan->free_list);\r\nfor (i = 0; i < ZYNQMP_DMA_NUM_DESCS; i++) {\r\ndesc = chan->sw_desc_pool + i;\r\ndma_async_tx_descriptor_init(&desc->async_tx, &chan->common);\r\ndesc->async_tx.tx_submit = zynqmp_dma_tx_submit;\r\nlist_add_tail(&desc->node, &chan->free_list);\r\n}\r\nchan->desc_pool_v = dma_zalloc_coherent(chan->dev,\r\n(2 * chan->desc_size * ZYNQMP_DMA_NUM_DESCS),\r\n&chan->desc_pool_p, GFP_KERNEL);\r\nif (!chan->desc_pool_v)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ZYNQMP_DMA_NUM_DESCS; i++) {\r\ndesc = chan->sw_desc_pool + i;\r\ndesc->src_v = (struct zynqmp_dma_desc_ll *) (chan->desc_pool_v +\r\n(i * ZYNQMP_DMA_DESC_SIZE(chan) * 2));\r\ndesc->dst_v = (struct zynqmp_dma_desc_ll *) (desc->src_v + 1);\r\ndesc->src_p = chan->desc_pool_p +\r\n(i * ZYNQMP_DMA_DESC_SIZE(chan) * 2);\r\ndesc->dst_p = desc->src_p + ZYNQMP_DMA_DESC_SIZE(chan);\r\n}\r\nreturn ZYNQMP_DMA_NUM_DESCS;\r\n}\r\nstatic void zynqmp_dma_start(struct zynqmp_dma_chan *chan)\r\n{\r\nwritel(ZYNQMP_DMA_INT_EN_DEFAULT_MASK, chan->regs + ZYNQMP_DMA_IER);\r\nchan->idle = false;\r\nwritel(ZYNQMP_DMA_ENABLE, chan->regs + ZYNQMP_DMA_CTRL2);\r\n}\r\nstatic void zynqmp_dma_handle_ovfl_int(struct zynqmp_dma_chan *chan, u32 status)\r\n{\r\nu32 val;\r\nif (status & ZYNQMP_DMA_IRQ_DST_ACCT_ERR)\r\nval = readl(chan->regs + ZYNQMP_DMA_IRQ_DST_ACCT);\r\nif (status & ZYNQMP_DMA_IRQ_SRC_ACCT_ERR)\r\nval = readl(chan->regs + ZYNQMP_DMA_IRQ_SRC_ACCT);\r\n}\r\nstatic void zynqmp_dma_config(struct zynqmp_dma_chan *chan)\r\n{\r\nu32 val;\r\nval = readl(chan->regs + ZYNQMP_DMA_CTRL0);\r\nval |= ZYNQMP_DMA_POINT_TYPE_SG;\r\nwritel(val, chan->regs + ZYNQMP_DMA_CTRL0);\r\nval = readl(chan->regs + ZYNQMP_DMA_DATA_ATTR);\r\nval = (val & ~ZYNQMP_DMA_ARLEN) |\r\n(chan->src_burst_len << ZYNQMP_DMA_ARLEN_OFST);\r\nval = (val & ~ZYNQMP_DMA_AWLEN) |\r\n(chan->dst_burst_len << ZYNQMP_DMA_AWLEN_OFST);\r\nwritel(val, chan->regs + ZYNQMP_DMA_DATA_ATTR);\r\n}\r\nstatic int zynqmp_dma_device_config(struct dma_chan *dchan,\r\nstruct dma_slave_config *config)\r\n{\r\nstruct zynqmp_dma_chan *chan = to_chan(dchan);\r\nchan->src_burst_len = config->src_maxburst;\r\nchan->dst_burst_len = config->dst_maxburst;\r\nreturn 0;\r\n}\r\nstatic void zynqmp_dma_start_transfer(struct zynqmp_dma_chan *chan)\r\n{\r\nstruct zynqmp_dma_desc_sw *desc;\r\nif (!chan->idle)\r\nreturn;\r\nzynqmp_dma_config(chan);\r\ndesc = list_first_entry_or_null(&chan->pending_list,\r\nstruct zynqmp_dma_desc_sw, node);\r\nif (!desc)\r\nreturn;\r\nlist_splice_tail_init(&chan->pending_list, &chan->active_list);\r\nzynqmp_dma_update_desc_to_ctrlr(chan, desc);\r\nzynqmp_dma_start(chan);\r\n}\r\nstatic void zynqmp_dma_chan_desc_cleanup(struct zynqmp_dma_chan *chan)\r\n{\r\nstruct zynqmp_dma_desc_sw *desc, *next;\r\nlist_for_each_entry_safe(desc, next, &chan->done_list, node) {\r\ndma_async_tx_callback callback;\r\nvoid *callback_param;\r\nlist_del(&desc->node);\r\ncallback = desc->async_tx.callback;\r\ncallback_param = desc->async_tx.callback_param;\r\nif (callback) {\r\nspin_unlock(&chan->lock);\r\ncallback(callback_param);\r\nspin_lock(&chan->lock);\r\n}\r\nzynqmp_dma_free_descriptor(chan, desc);\r\n}\r\n}\r\nstatic void zynqmp_dma_complete_descriptor(struct zynqmp_dma_chan *chan)\r\n{\r\nstruct zynqmp_dma_desc_sw *desc;\r\ndesc = list_first_entry_or_null(&chan->active_list,\r\nstruct zynqmp_dma_desc_sw, node);\r\nif (!desc)\r\nreturn;\r\nlist_del(&desc->node);\r\ndma_cookie_complete(&desc->async_tx);\r\nlist_add_tail(&desc->node, &chan->done_list);\r\n}\r\nstatic void zynqmp_dma_issue_pending(struct dma_chan *dchan)\r\n{\r\nstruct zynqmp_dma_chan *chan = to_chan(dchan);\r\nspin_lock_bh(&chan->lock);\r\nzynqmp_dma_start_transfer(chan);\r\nspin_unlock_bh(&chan->lock);\r\n}\r\nstatic void zynqmp_dma_free_descriptors(struct zynqmp_dma_chan *chan)\r\n{\r\nzynqmp_dma_free_desc_list(chan, &chan->active_list);\r\nzynqmp_dma_free_desc_list(chan, &chan->pending_list);\r\nzynqmp_dma_free_desc_list(chan, &chan->done_list);\r\n}\r\nstatic void zynqmp_dma_free_chan_resources(struct dma_chan *dchan)\r\n{\r\nstruct zynqmp_dma_chan *chan = to_chan(dchan);\r\nspin_lock_bh(&chan->lock);\r\nzynqmp_dma_free_descriptors(chan);\r\nspin_unlock_bh(&chan->lock);\r\ndma_free_coherent(chan->dev,\r\n(2 * ZYNQMP_DMA_DESC_SIZE(chan) * ZYNQMP_DMA_NUM_DESCS),\r\nchan->desc_pool_v, chan->desc_pool_p);\r\nkfree(chan->sw_desc_pool);\r\n}\r\nstatic void zynqmp_dma_reset(struct zynqmp_dma_chan *chan)\r\n{\r\nwritel(ZYNQMP_DMA_IDS_DEFAULT_MASK, chan->regs + ZYNQMP_DMA_IDS);\r\nzynqmp_dma_complete_descriptor(chan);\r\nzynqmp_dma_chan_desc_cleanup(chan);\r\nzynqmp_dma_free_descriptors(chan);\r\nzynqmp_dma_init(chan);\r\n}\r\nstatic irqreturn_t zynqmp_dma_irq_handler(int irq, void *data)\r\n{\r\nstruct zynqmp_dma_chan *chan = (struct zynqmp_dma_chan *)data;\r\nu32 isr, imr, status;\r\nirqreturn_t ret = IRQ_NONE;\r\nisr = readl(chan->regs + ZYNQMP_DMA_ISR);\r\nimr = readl(chan->regs + ZYNQMP_DMA_IMR);\r\nstatus = isr & ~imr;\r\nwritel(isr, chan->regs + ZYNQMP_DMA_ISR);\r\nif (status & ZYNQMP_DMA_INT_DONE) {\r\ntasklet_schedule(&chan->tasklet);\r\nret = IRQ_HANDLED;\r\n}\r\nif (status & ZYNQMP_DMA_DONE)\r\nchan->idle = true;\r\nif (status & ZYNQMP_DMA_INT_ERR) {\r\nchan->err = true;\r\ntasklet_schedule(&chan->tasklet);\r\ndev_err(chan->dev, "Channel %p has errors\n", chan);\r\nret = IRQ_HANDLED;\r\n}\r\nif (status & ZYNQMP_DMA_INT_OVRFL) {\r\nzynqmp_dma_handle_ovfl_int(chan, status);\r\ndev_info(chan->dev, "Channel %p overflow interrupt\n", chan);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic void zynqmp_dma_do_tasklet(unsigned long data)\r\n{\r\nstruct zynqmp_dma_chan *chan = (struct zynqmp_dma_chan *)data;\r\nu32 count;\r\nspin_lock(&chan->lock);\r\nif (chan->err) {\r\nzynqmp_dma_reset(chan);\r\nchan->err = false;\r\ngoto unlock;\r\n}\r\ncount = readl(chan->regs + ZYNQMP_DMA_IRQ_DST_ACCT);\r\nwhile (count) {\r\nzynqmp_dma_complete_descriptor(chan);\r\nzynqmp_dma_chan_desc_cleanup(chan);\r\ncount--;\r\n}\r\nif (chan->idle)\r\nzynqmp_dma_start_transfer(chan);\r\nunlock:\r\nspin_unlock(&chan->lock);\r\n}\r\nstatic int zynqmp_dma_device_terminate_all(struct dma_chan *dchan)\r\n{\r\nstruct zynqmp_dma_chan *chan = to_chan(dchan);\r\nspin_lock_bh(&chan->lock);\r\nwritel(ZYNQMP_DMA_IDS_DEFAULT_MASK, chan->regs + ZYNQMP_DMA_IDS);\r\nzynqmp_dma_free_descriptors(chan);\r\nspin_unlock_bh(&chan->lock);\r\nreturn 0;\r\n}\r\nstatic struct dma_async_tx_descriptor *zynqmp_dma_prep_memcpy(\r\nstruct dma_chan *dchan, dma_addr_t dma_dst,\r\ndma_addr_t dma_src, size_t len, ulong flags)\r\n{\r\nstruct zynqmp_dma_chan *chan;\r\nstruct zynqmp_dma_desc_sw *new, *first = NULL;\r\nvoid *desc = NULL, *prev = NULL;\r\nsize_t copy;\r\nu32 desc_cnt;\r\nchan = to_chan(dchan);\r\nif (len > ZYNQMP_DMA_MAX_TRANS_LEN)\r\nreturn NULL;\r\ndesc_cnt = DIV_ROUND_UP(len, ZYNQMP_DMA_MAX_TRANS_LEN);\r\nspin_lock_bh(&chan->lock);\r\nif (desc_cnt > chan->desc_free_cnt) {\r\nspin_unlock_bh(&chan->lock);\r\ndev_dbg(chan->dev, "chan %p descs are not available\n", chan);\r\nreturn NULL;\r\n}\r\nchan->desc_free_cnt = chan->desc_free_cnt - desc_cnt;\r\nspin_unlock_bh(&chan->lock);\r\ndo {\r\nnew = zynqmp_dma_get_descriptor(chan);\r\ncopy = min_t(size_t, len, ZYNQMP_DMA_MAX_TRANS_LEN);\r\ndesc = (struct zynqmp_dma_desc_ll *)new->src_v;\r\nzynqmp_dma_config_sg_ll_desc(chan, desc, dma_src,\r\ndma_dst, copy, prev);\r\nprev = desc;\r\nlen -= copy;\r\ndma_src += copy;\r\ndma_dst += copy;\r\nif (!first)\r\nfirst = new;\r\nelse\r\nlist_add_tail(&new->node, &first->tx_list);\r\n} while (len);\r\nzynqmp_dma_desc_config_eod(chan, desc);\r\nasync_tx_ack(&first->async_tx);\r\nfirst->async_tx.flags = flags;\r\nreturn &first->async_tx;\r\n}\r\nstatic struct dma_async_tx_descriptor *zynqmp_dma_prep_sg(\r\nstruct dma_chan *dchan, struct scatterlist *dst_sg,\r\nunsigned int dst_sg_len, struct scatterlist *src_sg,\r\nunsigned int src_sg_len, unsigned long flags)\r\n{\r\nstruct zynqmp_dma_desc_sw *new, *first = NULL;\r\nstruct zynqmp_dma_chan *chan = to_chan(dchan);\r\nvoid *desc = NULL, *prev = NULL;\r\nsize_t len, dst_avail, src_avail;\r\ndma_addr_t dma_dst, dma_src;\r\nu32 desc_cnt = 0, i;\r\nstruct scatterlist *sg;\r\nfor_each_sg(src_sg, sg, src_sg_len, i)\r\ndesc_cnt += DIV_ROUND_UP(sg_dma_len(sg),\r\nZYNQMP_DMA_MAX_TRANS_LEN);\r\nspin_lock_bh(&chan->lock);\r\nif (desc_cnt > chan->desc_free_cnt) {\r\nspin_unlock_bh(&chan->lock);\r\ndev_dbg(chan->dev, "chan %p descs are not available\n", chan);\r\nreturn NULL;\r\n}\r\nchan->desc_free_cnt = chan->desc_free_cnt - desc_cnt;\r\nspin_unlock_bh(&chan->lock);\r\ndst_avail = sg_dma_len(dst_sg);\r\nsrc_avail = sg_dma_len(src_sg);\r\nwhile (true) {\r\nnew = zynqmp_dma_get_descriptor(chan);\r\ndesc = (struct zynqmp_dma_desc_ll *)new->src_v;\r\nlen = min_t(size_t, src_avail, dst_avail);\r\nlen = min_t(size_t, len, ZYNQMP_DMA_MAX_TRANS_LEN);\r\nif (len == 0)\r\ngoto fetch;\r\ndma_dst = sg_dma_address(dst_sg) + sg_dma_len(dst_sg) -\r\ndst_avail;\r\ndma_src = sg_dma_address(src_sg) + sg_dma_len(src_sg) -\r\nsrc_avail;\r\nzynqmp_dma_config_sg_ll_desc(chan, desc, dma_src, dma_dst,\r\nlen, prev);\r\nprev = desc;\r\ndst_avail -= len;\r\nsrc_avail -= len;\r\nif (!first)\r\nfirst = new;\r\nelse\r\nlist_add_tail(&new->node, &first->tx_list);\r\nfetch:\r\nif (dst_avail == 0) {\r\nif (dst_sg_len == 0)\r\nbreak;\r\ndst_sg = sg_next(dst_sg);\r\nif (dst_sg == NULL)\r\nbreak;\r\ndst_sg_len--;\r\ndst_avail = sg_dma_len(dst_sg);\r\n}\r\nif (src_avail == 0) {\r\nif (src_sg_len == 0)\r\nbreak;\r\nsrc_sg = sg_next(src_sg);\r\nif (src_sg == NULL)\r\nbreak;\r\nsrc_sg_len--;\r\nsrc_avail = sg_dma_len(src_sg);\r\n}\r\n}\r\nzynqmp_dma_desc_config_eod(chan, desc);\r\nfirst->async_tx.flags = flags;\r\nreturn &first->async_tx;\r\n}\r\nstatic void zynqmp_dma_chan_remove(struct zynqmp_dma_chan *chan)\r\n{\r\nif (!chan)\r\nreturn;\r\ndevm_free_irq(chan->zdev->dev, chan->irq, chan);\r\ntasklet_kill(&chan->tasklet);\r\nlist_del(&chan->common.device_node);\r\nclk_disable_unprepare(chan->clk_apb);\r\nclk_disable_unprepare(chan->clk_main);\r\n}\r\nstatic int zynqmp_dma_chan_probe(struct zynqmp_dma_device *zdev,\r\nstruct platform_device *pdev)\r\n{\r\nstruct zynqmp_dma_chan *chan;\r\nstruct resource *res;\r\nstruct device_node *node = pdev->dev.of_node;\r\nint err;\r\nchan = devm_kzalloc(zdev->dev, sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn -ENOMEM;\r\nchan->dev = zdev->dev;\r\nchan->zdev = zdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchan->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(chan->regs))\r\nreturn PTR_ERR(chan->regs);\r\nchan->bus_width = ZYNQMP_DMA_BUS_WIDTH_64;\r\nchan->dst_burst_len = ZYNQMP_DMA_AWLEN_RST_VAL;\r\nchan->src_burst_len = ZYNQMP_DMA_ARLEN_RST_VAL;\r\nerr = of_property_read_u32(node, "xlnx,bus-width", &chan->bus_width);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "missing xlnx,bus-width property\n");\r\nreturn err;\r\n}\r\nif (chan->bus_width != ZYNQMP_DMA_BUS_WIDTH_64 &&\r\nchan->bus_width != ZYNQMP_DMA_BUS_WIDTH_128) {\r\ndev_err(zdev->dev, "invalid bus-width value");\r\nreturn -EINVAL;\r\n}\r\nchan->is_dmacoherent = of_property_read_bool(node, "dma-coherent");\r\nzdev->chan = chan;\r\ntasklet_init(&chan->tasklet, zynqmp_dma_do_tasklet, (ulong)chan);\r\nspin_lock_init(&chan->lock);\r\nINIT_LIST_HEAD(&chan->active_list);\r\nINIT_LIST_HEAD(&chan->pending_list);\r\nINIT_LIST_HEAD(&chan->done_list);\r\nINIT_LIST_HEAD(&chan->free_list);\r\ndma_cookie_init(&chan->common);\r\nchan->common.device = &zdev->common;\r\nlist_add_tail(&chan->common.device_node, &zdev->common.channels);\r\nzynqmp_dma_init(chan);\r\nchan->irq = platform_get_irq(pdev, 0);\r\nif (chan->irq < 0)\r\nreturn -ENXIO;\r\nerr = devm_request_irq(&pdev->dev, chan->irq, zynqmp_dma_irq_handler, 0,\r\n"zynqmp-dma", chan);\r\nif (err)\r\nreturn err;\r\nchan->clk_main = devm_clk_get(&pdev->dev, "clk_main");\r\nif (IS_ERR(chan->clk_main)) {\r\ndev_err(&pdev->dev, "main clock not found.\n");\r\nreturn PTR_ERR(chan->clk_main);\r\n}\r\nchan->clk_apb = devm_clk_get(&pdev->dev, "clk_apb");\r\nif (IS_ERR(chan->clk_apb)) {\r\ndev_err(&pdev->dev, "apb clock not found.\n");\r\nreturn PTR_ERR(chan->clk_apb);\r\n}\r\nerr = clk_prepare_enable(chan->clk_main);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to enable main clock.\n");\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(chan->clk_apb);\r\nif (err) {\r\nclk_disable_unprepare(chan->clk_main);\r\ndev_err(&pdev->dev, "Unable to enable apb clock.\n");\r\nreturn err;\r\n}\r\nchan->desc_size = sizeof(struct zynqmp_dma_desc_ll);\r\nchan->idle = true;\r\nreturn 0;\r\n}\r\nstatic struct dma_chan *of_zynqmp_dma_xlate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct zynqmp_dma_device *zdev = ofdma->of_dma_data;\r\nreturn dma_get_slave_channel(&zdev->chan->common);\r\n}\r\nstatic int zynqmp_dma_probe(struct platform_device *pdev)\r\n{\r\nstruct zynqmp_dma_device *zdev;\r\nstruct dma_device *p;\r\nint ret;\r\nzdev = devm_kzalloc(&pdev->dev, sizeof(*zdev), GFP_KERNEL);\r\nif (!zdev)\r\nreturn -ENOMEM;\r\nzdev->dev = &pdev->dev;\r\nINIT_LIST_HEAD(&zdev->common.channels);\r\ndma_set_mask(&pdev->dev, DMA_BIT_MASK(44));\r\ndma_cap_set(DMA_SG, zdev->common.cap_mask);\r\ndma_cap_set(DMA_MEMCPY, zdev->common.cap_mask);\r\np = &zdev->common;\r\np->device_prep_dma_sg = zynqmp_dma_prep_sg;\r\np->device_prep_dma_memcpy = zynqmp_dma_prep_memcpy;\r\np->device_terminate_all = zynqmp_dma_device_terminate_all;\r\np->device_issue_pending = zynqmp_dma_issue_pending;\r\np->device_alloc_chan_resources = zynqmp_dma_alloc_chan_resources;\r\np->device_free_chan_resources = zynqmp_dma_free_chan_resources;\r\np->device_tx_status = dma_cookie_status;\r\np->device_config = zynqmp_dma_device_config;\r\np->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, zdev);\r\nret = zynqmp_dma_chan_probe(zdev, pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Probing channel failed\n");\r\ngoto free_chan_resources;\r\n}\r\np->dst_addr_widths = BIT(zdev->chan->bus_width / 8);\r\np->src_addr_widths = BIT(zdev->chan->bus_width / 8);\r\ndma_async_device_register(&zdev->common);\r\nret = of_dma_controller_register(pdev->dev.of_node,\r\nof_zynqmp_dma_xlate, zdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to register DMA to DT\n");\r\ndma_async_device_unregister(&zdev->common);\r\ngoto free_chan_resources;\r\n}\r\ndev_info(&pdev->dev, "ZynqMP DMA driver Probe success\n");\r\nreturn 0;\r\nfree_chan_resources:\r\nzynqmp_dma_chan_remove(zdev->chan);\r\nreturn ret;\r\n}\r\nstatic int zynqmp_dma_remove(struct platform_device *pdev)\r\n{\r\nstruct zynqmp_dma_device *zdev = platform_get_drvdata(pdev);\r\nof_dma_controller_free(pdev->dev.of_node);\r\ndma_async_device_unregister(&zdev->common);\r\nzynqmp_dma_chan_remove(zdev->chan);\r\nreturn 0;\r\n}
