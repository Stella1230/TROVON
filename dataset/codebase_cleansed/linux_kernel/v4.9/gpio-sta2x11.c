static inline struct gsta_regs __iomem *__regs(struct gsta_gpio *chip, int nr)\r\n{\r\nreturn chip->regs[nr / GSTA_GPIO_PER_BLOCK];\r\n}\r\nstatic inline u32 __bit(int nr)\r\n{\r\nreturn 1U << (nr % GSTA_GPIO_PER_BLOCK);\r\n}\r\nstatic void gsta_gpio_set(struct gpio_chip *gpio, unsigned nr, int val)\r\n{\r\nstruct gsta_gpio *chip = gpiochip_get_data(gpio);\r\nstruct gsta_regs __iomem *regs = __regs(chip, nr);\r\nu32 bit = __bit(nr);\r\nif (val)\r\nwritel(bit, &regs->dats);\r\nelse\r\nwritel(bit, &regs->datc);\r\n}\r\nstatic int gsta_gpio_get(struct gpio_chip *gpio, unsigned nr)\r\n{\r\nstruct gsta_gpio *chip = gpiochip_get_data(gpio);\r\nstruct gsta_regs __iomem *regs = __regs(chip, nr);\r\nu32 bit = __bit(nr);\r\nreturn !!(readl(&regs->dat) & bit);\r\n}\r\nstatic int gsta_gpio_direction_output(struct gpio_chip *gpio, unsigned nr,\r\nint val)\r\n{\r\nstruct gsta_gpio *chip = gpiochip_get_data(gpio);\r\nstruct gsta_regs __iomem *regs = __regs(chip, nr);\r\nu32 bit = __bit(nr);\r\nwritel(bit, &regs->dirs);\r\nif (val)\r\nwritel(bit, &regs->dats);\r\nelse\r\nwritel(bit, &regs->datc);\r\nreturn 0;\r\n}\r\nstatic int gsta_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)\r\n{\r\nstruct gsta_gpio *chip = gpiochip_get_data(gpio);\r\nstruct gsta_regs __iomem *regs = __regs(chip, nr);\r\nu32 bit = __bit(nr);\r\nwritel(bit, &regs->dirc);\r\nreturn 0;\r\n}\r\nstatic int gsta_gpio_to_irq(struct gpio_chip *gpio, unsigned offset)\r\n{\r\nstruct gsta_gpio *chip = gpiochip_get_data(gpio);\r\nreturn chip->irq_base + offset;\r\n}\r\nstatic void gsta_gpio_setup(struct gsta_gpio *chip)\r\n{\r\nstruct gpio_chip *gpio = &chip->gpio;\r\nstatic int gpio_base;\r\ngpio->label = dev_name(chip->dev);\r\ngpio->owner = THIS_MODULE;\r\ngpio->direction_input = gsta_gpio_direction_input;\r\ngpio->get = gsta_gpio_get;\r\ngpio->direction_output = gsta_gpio_direction_output;\r\ngpio->set = gsta_gpio_set;\r\ngpio->dbg_show = NULL;\r\ngpio->base = gpio_base;\r\ngpio->ngpio = GSTA_NR_GPIO;\r\ngpio->can_sleep = false;\r\ngpio->to_irq = gsta_gpio_to_irq;\r\nif (!gpio_base)\r\ngpio_base = -1;\r\n}\r\nstatic void gsta_set_config(struct gsta_gpio *chip, int nr, unsigned cfg)\r\n{\r\nstruct gsta_regs __iomem *regs = __regs(chip, nr);\r\nunsigned long flags;\r\nu32 bit = __bit(nr);\r\nu32 val;\r\nint err = 0;\r\npr_info("%s: %p %i %i\n", __func__, chip, nr, cfg);\r\nif (cfg == PINMUX_TYPE_NONE)\r\nreturn;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nval = readl(&regs->afsela);\r\nif (cfg == PINMUX_TYPE_FUNCTION)\r\nval |= bit;\r\nelse\r\nval &= ~bit;\r\nwritel(val | bit, &regs->afsela);\r\nif (cfg == PINMUX_TYPE_FUNCTION) {\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn;\r\n}\r\nswitch (cfg) {\r\ncase PINMUX_TYPE_OUTPUT_LOW:\r\nwritel(bit, &regs->dirs);\r\nwritel(bit, &regs->datc);\r\nbreak;\r\ncase PINMUX_TYPE_OUTPUT_HIGH:\r\nwritel(bit, &regs->dirs);\r\nwritel(bit, &regs->dats);\r\nbreak;\r\ncase PINMUX_TYPE_INPUT:\r\nwritel(bit, &regs->dirc);\r\nval = readl(&regs->pdis) | bit;\r\nwritel(val, &regs->pdis);\r\nbreak;\r\ncase PINMUX_TYPE_INPUT_PULLUP:\r\nwritel(bit, &regs->dirc);\r\nval = readl(&regs->pdis) & ~bit;\r\nwritel(val, &regs->pdis);\r\nwritel(bit, &regs->dats);\r\nbreak;\r\ncase PINMUX_TYPE_INPUT_PULLDOWN:\r\nwritel(bit, &regs->dirc);\r\nval = readl(&regs->pdis) & ~bit;\r\nwritel(val, &regs->pdis);\r\nwritel(bit, &regs->datc);\r\nbreak;\r\ndefault:\r\nerr = 1;\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nif (err)\r\npr_err("%s: chip %p, pin %i, cfg %i is invalid\n",\r\n__func__, chip, nr, cfg);\r\n}\r\nstatic void gsta_irq_disable(struct irq_data *data)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\r\nstruct gsta_gpio *chip = gc->private;\r\nint nr = data->irq - chip->irq_base;\r\nstruct gsta_regs __iomem *regs = __regs(chip, nr);\r\nu32 bit = __bit(nr);\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nif (chip->irq_type[nr] & IRQ_TYPE_EDGE_RISING) {\r\nval = readl(&regs->rimsc) & ~bit;\r\nwritel(val, &regs->rimsc);\r\n}\r\nif (chip->irq_type[nr] & IRQ_TYPE_EDGE_FALLING) {\r\nval = readl(&regs->fimsc) & ~bit;\r\nwritel(val, &regs->fimsc);\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn;\r\n}\r\nstatic void gsta_irq_enable(struct irq_data *data)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\r\nstruct gsta_gpio *chip = gc->private;\r\nint nr = data->irq - chip->irq_base;\r\nstruct gsta_regs __iomem *regs = __regs(chip, nr);\r\nu32 bit = __bit(nr);\r\nu32 val;\r\nint type;\r\nunsigned long flags;\r\ntype = chip->irq_type[nr];\r\nspin_lock_irqsave(&chip->lock, flags);\r\nval = readl(&regs->rimsc);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nwritel(val | bit, &regs->rimsc);\r\nelse\r\nwritel(val & ~bit, &regs->rimsc);\r\nval = readl(&regs->rimsc);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nwritel(val | bit, &regs->fimsc);\r\nelse\r\nwritel(val & ~bit, &regs->fimsc);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn;\r\n}\r\nstatic int gsta_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct gsta_gpio *chip = gc->private;\r\nint nr = d->irq - chip->irq_base;\r\nif (!(type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))) {\r\npr_debug("%s: unsupported type 0x%x\n", __func__, type);\r\nreturn -EINVAL;\r\n}\r\nchip->irq_type[nr] = type;\r\ngsta_irq_enable(d);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t gsta_gpio_handler(int irq, void *dev_id)\r\n{\r\nstruct gsta_gpio *chip = dev_id;\r\nstruct gsta_regs __iomem *regs;\r\nu32 is;\r\nint i, nr, base;\r\nirqreturn_t ret = IRQ_NONE;\r\nfor (i = 0; i < GSTA_NR_BLOCKS; i++) {\r\nregs = chip->regs[i];\r\nbase = chip->irq_base + i * GSTA_GPIO_PER_BLOCK;\r\nwhile ((is = readl(&regs->is))) {\r\nnr = __ffs(is);\r\nirq = base + nr;\r\ngeneric_handle_irq(irq);\r\nwritel(1 << nr, &regs->ic);\r\nret = IRQ_HANDLED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void gsta_alloc_irq_chip(struct gsta_gpio *chip)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip(KBUILD_MODNAME, 1, chip->irq_base,\r\nchip->reg_base, handle_simple_irq);\r\ngc->private = chip;\r\nct = gc->chip_types;\r\nct->chip.irq_set_type = gsta_irq_type;\r\nct->chip.irq_disable = gsta_irq_disable;\r\nct->chip.irq_enable = gsta_irq_enable;\r\nirq_setup_generic_chip(gc, 0 , 0,\r\nIRQ_NOREQUEST | IRQ_NOPROBE, 0);\r\n{\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nint i, j;\r\nfor (j = 0; j < GSTA_NR_GPIO; j++) {\r\ni = chip->irq_base + j;\r\nirq_set_chip_and_handler(i, &ct->chip, ct->handler);\r\nirq_set_chip_data(i, gc);\r\nirq_clear_status_flags(i, IRQ_NOREQUEST | IRQ_NOPROBE);\r\n}\r\ngc->irq_cnt = i - gc->irq_base;\r\n}\r\n}\r\nstatic int gsta_probe(struct platform_device *dev)\r\n{\r\nint i, err;\r\nstruct pci_dev *pdev;\r\nstruct sta2x11_gpio_pdata *gpio_pdata;\r\nstruct gsta_gpio *chip;\r\nstruct resource *res;\r\npdev = *(struct pci_dev **)dev_get_platdata(&dev->dev);\r\ngpio_pdata = dev_get_platdata(&pdev->dev);\r\nif (gpio_pdata == NULL)\r\ndev_err(&dev->dev, "no gpio config\n");\r\npr_debug("gpio config: %p\n", gpio_pdata);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nchip = devm_kzalloc(&dev->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->dev = &dev->dev;\r\nchip->reg_base = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(chip->reg_base))\r\nreturn PTR_ERR(chip->reg_base);\r\nfor (i = 0; i < GSTA_NR_BLOCKS; i++) {\r\nchip->regs[i] = chip->reg_base + i * 4096;\r\nwritel(0, &chip->regs[i]->rimsc);\r\nwritel(0, &chip->regs[i]->fimsc);\r\nwritel(~0, &chip->regs[i]->ic);\r\n}\r\nspin_lock_init(&chip->lock);\r\ngsta_gpio_setup(chip);\r\nif (gpio_pdata)\r\nfor (i = 0; i < GSTA_NR_GPIO; i++)\r\ngsta_set_config(chip, i, gpio_pdata->pinconfig[i]);\r\nerr = irq_alloc_descs(-1, 384, GSTA_NR_GPIO, NUMA_NO_NODE);\r\nif (err < 0) {\r\ndev_warn(&dev->dev, "sta2x11 gpio: Can't get irq base (%i)\n",\r\n-err);\r\nreturn err;\r\n}\r\nchip->irq_base = err;\r\ngsta_alloc_irq_chip(chip);\r\nerr = request_irq(pdev->irq, gsta_gpio_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, chip);\r\nif (err < 0) {\r\ndev_err(&dev->dev, "sta2x11 gpio: Can't request irq (%i)\n",\r\n-err);\r\ngoto err_free_descs;\r\n}\r\nerr = devm_gpiochip_add_data(&dev->dev, &chip->gpio, chip);\r\nif (err < 0) {\r\ndev_err(&dev->dev, "sta2x11 gpio: Can't register (%i)\n",\r\n-err);\r\ngoto err_free_irq;\r\n}\r\nplatform_set_drvdata(dev, chip);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(pdev->irq, chip);\r\nerr_free_descs:\r\nirq_free_descs(chip->irq_base, GSTA_NR_GPIO);\r\nreturn err;\r\n}
