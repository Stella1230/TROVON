static inline u16 get_usb_speed(struct r8a66597 *r8a66597)\r\n{\r\nreturn r8a66597_read(r8a66597, DVSTCTR0) & RHST;\r\n}\r\nstatic void enable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,\r\nunsigned long reg)\r\n{\r\nu16 tmp;\r\ntmp = r8a66597_read(r8a66597, INTENB0);\r\nr8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE,\r\nINTENB0);\r\nr8a66597_bset(r8a66597, (1 << pipenum), reg);\r\nr8a66597_write(r8a66597, tmp, INTENB0);\r\n}\r\nstatic void disable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,\r\nunsigned long reg)\r\n{\r\nu16 tmp;\r\ntmp = r8a66597_read(r8a66597, INTENB0);\r\nr8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE,\r\nINTENB0);\r\nr8a66597_bclr(r8a66597, (1 << pipenum), reg);\r\nr8a66597_write(r8a66597, tmp, INTENB0);\r\n}\r\nstatic void r8a66597_usb_connect(struct r8a66597 *r8a66597)\r\n{\r\nr8a66597_bset(r8a66597, CTRE, INTENB0);\r\nr8a66597_bset(r8a66597, BEMPE | BRDYE, INTENB0);\r\nr8a66597_bset(r8a66597, DPRPU, SYSCFG0);\r\n}\r\nstatic void r8a66597_usb_disconnect(struct r8a66597 *r8a66597)\r\n__releases(r8a66597->lock)\r\n__acquires(r8a66597->lock)\r\n{\r\nr8a66597_bclr(r8a66597, CTRE, INTENB0);\r\nr8a66597_bclr(r8a66597, BEMPE | BRDYE, INTENB0);\r\nr8a66597_bclr(r8a66597, DPRPU, SYSCFG0);\r\nr8a66597->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock(&r8a66597->lock);\r\nr8a66597->driver->disconnect(&r8a66597->gadget);\r\nspin_lock(&r8a66597->lock);\r\ndisable_controller(r8a66597);\r\ninit_controller(r8a66597);\r\nr8a66597_bset(r8a66597, VBSE, INTENB0);\r\nINIT_LIST_HEAD(&r8a66597->ep[0].queue);\r\n}\r\nstatic inline u16 control_reg_get_pid(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nu16 pid = 0;\r\nunsigned long offset;\r\nif (pipenum == 0) {\r\npid = r8a66597_read(r8a66597, DCPCTR) & PID;\r\n} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\npid = r8a66597_read(r8a66597, offset) & PID;\r\n} else {\r\ndev_err(r8a66597_to_dev(r8a66597), "unexpect pipe num (%d)\n",\r\npipenum);\r\n}\r\nreturn pid;\r\n}\r\nstatic inline void control_reg_set_pid(struct r8a66597 *r8a66597, u16 pipenum,\r\nu16 pid)\r\n{\r\nunsigned long offset;\r\nif (pipenum == 0) {\r\nr8a66597_mdfy(r8a66597, pid, PID, DCPCTR);\r\n} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\nr8a66597_mdfy(r8a66597, pid, PID, offset);\r\n} else {\r\ndev_err(r8a66597_to_dev(r8a66597), "unexpect pipe num (%d)\n",\r\npipenum);\r\n}\r\n}\r\nstatic inline void pipe_start(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\ncontrol_reg_set_pid(r8a66597, pipenum, PID_BUF);\r\n}\r\nstatic inline void pipe_stop(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\ncontrol_reg_set_pid(r8a66597, pipenum, PID_NAK);\r\n}\r\nstatic inline void pipe_stall(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\ncontrol_reg_set_pid(r8a66597, pipenum, PID_STALL);\r\n}\r\nstatic inline u16 control_reg_get(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nu16 ret = 0;\r\nunsigned long offset;\r\nif (pipenum == 0) {\r\nret = r8a66597_read(r8a66597, DCPCTR);\r\n} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\nret = r8a66597_read(r8a66597, offset);\r\n} else {\r\ndev_err(r8a66597_to_dev(r8a66597), "unexpect pipe num (%d)\n",\r\npipenum);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void control_reg_sqclr(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nunsigned long offset;\r\npipe_stop(r8a66597, pipenum);\r\nif (pipenum == 0) {\r\nr8a66597_bset(r8a66597, SQCLR, DCPCTR);\r\n} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\nr8a66597_bset(r8a66597, SQCLR, offset);\r\n} else {\r\ndev_err(r8a66597_to_dev(r8a66597), "unexpect pipe num (%d)\n",\r\npipenum);\r\n}\r\n}\r\nstatic void control_reg_sqset(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nunsigned long offset;\r\npipe_stop(r8a66597, pipenum);\r\nif (pipenum == 0) {\r\nr8a66597_bset(r8a66597, SQSET, DCPCTR);\r\n} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\nr8a66597_bset(r8a66597, SQSET, offset);\r\n} else {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"unexpect pipe num(%d)\n", pipenum);\r\n}\r\n}\r\nstatic u16 control_reg_sqmon(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nunsigned long offset;\r\nif (pipenum == 0) {\r\nreturn r8a66597_read(r8a66597, DCPCTR) & SQMON;\r\n} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\r\noffset = get_pipectr_addr(pipenum);\r\nreturn r8a66597_read(r8a66597, offset) & SQMON;\r\n} else {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"unexpect pipe num(%d)\n", pipenum);\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 save_usb_toggle(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nreturn control_reg_sqmon(r8a66597, pipenum);\r\n}\r\nstatic void restore_usb_toggle(struct r8a66597 *r8a66597, u16 pipenum,\r\nu16 toggle)\r\n{\r\nif (toggle)\r\ncontrol_reg_sqset(r8a66597, pipenum);\r\nelse\r\ncontrol_reg_sqclr(r8a66597, pipenum);\r\n}\r\nstatic inline int get_buffer_size(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nu16 tmp;\r\nint size;\r\nif (pipenum == 0) {\r\ntmp = r8a66597_read(r8a66597, DCPCFG);\r\nif ((tmp & R8A66597_CNTMD) != 0)\r\nsize = 256;\r\nelse {\r\ntmp = r8a66597_read(r8a66597, DCPMAXP);\r\nsize = tmp & MAXP;\r\n}\r\n} else {\r\nr8a66597_write(r8a66597, pipenum, PIPESEL);\r\ntmp = r8a66597_read(r8a66597, PIPECFG);\r\nif ((tmp & R8A66597_CNTMD) != 0) {\r\ntmp = r8a66597_read(r8a66597, PIPEBUF);\r\nsize = ((tmp >> 10) + 1) * 64;\r\n} else {\r\ntmp = r8a66597_read(r8a66597, PIPEMAXP);\r\nsize = tmp & MXPS;\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic inline unsigned short mbw_value(struct r8a66597 *r8a66597)\r\n{\r\nif (r8a66597->pdata->on_chip)\r\nreturn MBW_32;\r\nelse\r\nreturn MBW_16;\r\n}\r\nstatic void r8a66597_change_curpipe(struct r8a66597 *r8a66597, u16 pipenum,\r\nu16 isel, u16 fifosel)\r\n{\r\nu16 tmp, mask, loop;\r\nint i = 0;\r\nif (!pipenum) {\r\nmask = ISEL | CURPIPE;\r\nloop = isel;\r\n} else {\r\nmask = CURPIPE;\r\nloop = pipenum;\r\n}\r\nr8a66597_mdfy(r8a66597, loop, mask, fifosel);\r\ndo {\r\ntmp = r8a66597_read(r8a66597, fifosel);\r\nif (i++ > 1000000) {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"r8a66597: register%x, loop %x "\r\n"is timeout\n", fifosel, loop);\r\nbreak;\r\n}\r\nndelay(1);\r\n} while ((tmp & mask) != loop);\r\n}\r\nstatic void pipe_change(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nstruct r8a66597_ep *ep = r8a66597->pipenum2ep[pipenum];\r\nif (ep->use_dma)\r\nr8a66597_bclr(r8a66597, DREQE, ep->fifosel);\r\nr8a66597_mdfy(r8a66597, pipenum, CURPIPE, ep->fifosel);\r\nndelay(450);\r\nif (r8a66597_is_sudmac(r8a66597) && ep->use_dma)\r\nr8a66597_bclr(r8a66597, mbw_value(r8a66597), ep->fifosel);\r\nelse\r\nr8a66597_bset(r8a66597, mbw_value(r8a66597), ep->fifosel);\r\nif (ep->use_dma)\r\nr8a66597_bset(r8a66597, DREQE, ep->fifosel);\r\n}\r\nstatic int pipe_buffer_setting(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe_info *info)\r\n{\r\nu16 bufnum = 0, buf_bsize = 0;\r\nu16 pipecfg = 0;\r\nif (info->pipe == 0)\r\nreturn -EINVAL;\r\nr8a66597_write(r8a66597, info->pipe, PIPESEL);\r\nif (info->dir_in)\r\npipecfg |= R8A66597_DIR;\r\npipecfg |= info->type;\r\npipecfg |= info->epnum;\r\nswitch (info->type) {\r\ncase R8A66597_INT:\r\nbufnum = 4 + (info->pipe - R8A66597_BASE_PIPENUM_INT);\r\nbuf_bsize = 0;\r\nbreak;\r\ncase R8A66597_BULK:\r\nif (info->pipe >= R8A66597_BASE_PIPENUM_BULK)\r\nbufnum = info->pipe - R8A66597_BASE_PIPENUM_BULK;\r\nelse\r\nbufnum = info->pipe - R8A66597_BASE_PIPENUM_ISOC;\r\nbufnum = R8A66597_BASE_BUFNUM + (bufnum * 16);\r\nbuf_bsize = 7;\r\npipecfg |= R8A66597_DBLB;\r\nif (!info->dir_in)\r\npipecfg |= R8A66597_SHTNAK;\r\nbreak;\r\ncase R8A66597_ISO:\r\nbufnum = R8A66597_BASE_BUFNUM +\r\n(info->pipe - R8A66597_BASE_PIPENUM_ISOC) * 16;\r\nbuf_bsize = 7;\r\nbreak;\r\n}\r\nif (buf_bsize && ((bufnum + 16) >= R8A66597_MAX_BUFNUM)) {\r\npr_err("r8a66597 pipe memory is insufficient\n");\r\nreturn -ENOMEM;\r\n}\r\nr8a66597_write(r8a66597, pipecfg, PIPECFG);\r\nr8a66597_write(r8a66597, (buf_bsize << 10) | (bufnum), PIPEBUF);\r\nr8a66597_write(r8a66597, info->maxpacket, PIPEMAXP);\r\nif (info->interval)\r\ninfo->interval--;\r\nr8a66597_write(r8a66597, info->interval, PIPEPERI);\r\nreturn 0;\r\n}\r\nstatic void pipe_buffer_release(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe_info *info)\r\n{\r\nif (info->pipe == 0)\r\nreturn;\r\nif (is_bulk_pipe(info->pipe)) {\r\nr8a66597->bulk--;\r\n} else if (is_interrupt_pipe(info->pipe)) {\r\nr8a66597->interrupt--;\r\n} else if (is_isoc_pipe(info->pipe)) {\r\nr8a66597->isochronous--;\r\nif (info->type == R8A66597_BULK)\r\nr8a66597->bulk--;\r\n} else {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"ep_release: unexpect pipenum (%d)\n", info->pipe);\r\n}\r\n}\r\nstatic void pipe_initialize(struct r8a66597_ep *ep)\r\n{\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\nr8a66597_mdfy(r8a66597, 0, CURPIPE, ep->fifosel);\r\nr8a66597_write(r8a66597, ACLRM, ep->pipectr);\r\nr8a66597_write(r8a66597, 0, ep->pipectr);\r\nr8a66597_write(r8a66597, SQCLR, ep->pipectr);\r\nif (ep->use_dma) {\r\nr8a66597_mdfy(r8a66597, ep->pipenum, CURPIPE, ep->fifosel);\r\nndelay(450);\r\nr8a66597_bset(r8a66597, mbw_value(r8a66597), ep->fifosel);\r\n}\r\n}\r\nstatic void r8a66597_ep_setting(struct r8a66597 *r8a66597,\r\nstruct r8a66597_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc,\r\nu16 pipenum, int dma)\r\n{\r\nep->use_dma = 0;\r\nep->fifoaddr = CFIFO;\r\nep->fifosel = CFIFOSEL;\r\nep->fifoctr = CFIFOCTR;\r\nep->pipectr = get_pipectr_addr(pipenum);\r\nif (is_bulk_pipe(pipenum) || is_isoc_pipe(pipenum)) {\r\nep->pipetre = get_pipetre_addr(pipenum);\r\nep->pipetrn = get_pipetrn_addr(pipenum);\r\n} else {\r\nep->pipetre = 0;\r\nep->pipetrn = 0;\r\n}\r\nep->pipenum = pipenum;\r\nep->ep.maxpacket = usb_endpoint_maxp(desc);\r\nr8a66597->pipenum2ep[pipenum] = ep;\r\nr8a66597->epaddr2ep[usb_endpoint_num(desc)]\r\n= ep;\r\nINIT_LIST_HEAD(&ep->queue);\r\n}\r\nstatic void r8a66597_ep_release(struct r8a66597_ep *ep)\r\n{\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\nu16 pipenum = ep->pipenum;\r\nif (pipenum == 0)\r\nreturn;\r\nif (ep->use_dma)\r\nr8a66597->num_dma--;\r\nep->pipenum = 0;\r\nep->busy = 0;\r\nep->use_dma = 0;\r\n}\r\nstatic int alloc_pipe_config(struct r8a66597_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\nstruct r8a66597_pipe_info info;\r\nint dma = 0;\r\nunsigned char *counter;\r\nint ret;\r\nep->ep.desc = desc;\r\nif (ep->pipenum)\r\nreturn 0;\r\nswitch (usb_endpoint_type(desc)) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (r8a66597->bulk >= R8A66597_MAX_NUM_BULK) {\r\nif (r8a66597->isochronous >= R8A66597_MAX_NUM_ISOC) {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"bulk pipe is insufficient\n");\r\nreturn -ENODEV;\r\n} else {\r\ninfo.pipe = R8A66597_BASE_PIPENUM_ISOC\r\n+ r8a66597->isochronous;\r\ncounter = &r8a66597->isochronous;\r\n}\r\n} else {\r\ninfo.pipe = R8A66597_BASE_PIPENUM_BULK + r8a66597->bulk;\r\ncounter = &r8a66597->bulk;\r\n}\r\ninfo.type = R8A66597_BULK;\r\ndma = 1;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (r8a66597->interrupt >= R8A66597_MAX_NUM_INT) {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"interrupt pipe is insufficient\n");\r\nreturn -ENODEV;\r\n}\r\ninfo.pipe = R8A66597_BASE_PIPENUM_INT + r8a66597->interrupt;\r\ninfo.type = R8A66597_INT;\r\ncounter = &r8a66597->interrupt;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (r8a66597->isochronous >= R8A66597_MAX_NUM_ISOC) {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"isochronous pipe is insufficient\n");\r\nreturn -ENODEV;\r\n}\r\ninfo.pipe = R8A66597_BASE_PIPENUM_ISOC + r8a66597->isochronous;\r\ninfo.type = R8A66597_ISO;\r\ncounter = &r8a66597->isochronous;\r\nbreak;\r\ndefault:\r\ndev_err(r8a66597_to_dev(r8a66597), "unexpect xfer type\n");\r\nreturn -EINVAL;\r\n}\r\nep->type = info.type;\r\ninfo.epnum = usb_endpoint_num(desc);\r\ninfo.maxpacket = usb_endpoint_maxp(desc);\r\ninfo.interval = desc->bInterval;\r\nif (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)\r\ninfo.dir_in = 1;\r\nelse\r\ninfo.dir_in = 0;\r\nret = pipe_buffer_setting(r8a66597, &info);\r\nif (ret < 0) {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"pipe_buffer_setting fail\n");\r\nreturn ret;\r\n}\r\n(*counter)++;\r\nif ((counter == &r8a66597->isochronous) && info.type == R8A66597_BULK)\r\nr8a66597->bulk++;\r\nr8a66597_ep_setting(r8a66597, ep, desc, info.pipe, dma);\r\npipe_initialize(ep);\r\nreturn 0;\r\n}\r\nstatic int free_pipe_config(struct r8a66597_ep *ep)\r\n{\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\nstruct r8a66597_pipe_info info;\r\ninfo.pipe = ep->pipenum;\r\ninfo.type = ep->type;\r\npipe_buffer_release(r8a66597, &info);\r\nr8a66597_ep_release(ep);\r\nreturn 0;\r\n}\r\nstatic void pipe_irq_enable(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nenable_irq_ready(r8a66597, pipenum);\r\nenable_irq_nrdy(r8a66597, pipenum);\r\n}\r\nstatic void pipe_irq_disable(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\ndisable_irq_ready(r8a66597, pipenum);\r\ndisable_irq_nrdy(r8a66597, pipenum);\r\n}\r\nstatic void control_end(struct r8a66597 *r8a66597, unsigned ccpl)\r\n{\r\nr8a66597->ep[0].internal_ccpl = ccpl;\r\npipe_start(r8a66597, 0);\r\nr8a66597_bset(r8a66597, CCPL, DCPCTR);\r\n}\r\nstatic void start_ep0_write(struct r8a66597_ep *ep,\r\nstruct r8a66597_request *req)\r\n{\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\npipe_change(r8a66597, ep->pipenum);\r\nr8a66597_mdfy(r8a66597, ISEL, (ISEL | CURPIPE), CFIFOSEL);\r\nr8a66597_write(r8a66597, BCLR, ep->fifoctr);\r\nif (req->req.length == 0) {\r\nr8a66597_bset(r8a66597, BVAL, ep->fifoctr);\r\npipe_start(r8a66597, 0);\r\ntransfer_complete(ep, req, 0);\r\n} else {\r\nr8a66597_write(r8a66597, ~BEMP0, BEMPSTS);\r\nirq_ep0_write(ep, req);\r\n}\r\n}\r\nstatic void disable_fifosel(struct r8a66597 *r8a66597, u16 pipenum,\r\nu16 fifosel)\r\n{\r\nu16 tmp;\r\ntmp = r8a66597_read(r8a66597, fifosel) & CURPIPE;\r\nif (tmp == pipenum)\r\nr8a66597_change_curpipe(r8a66597, 0, 0, fifosel);\r\n}\r\nstatic void change_bfre_mode(struct r8a66597 *r8a66597, u16 pipenum,\r\nint enable)\r\n{\r\nstruct r8a66597_ep *ep = r8a66597->pipenum2ep[pipenum];\r\nu16 tmp, toggle;\r\nr8a66597_write(r8a66597, pipenum, PIPESEL);\r\ntmp = r8a66597_read(r8a66597, PIPECFG) & R8A66597_BFRE;\r\nif ((enable && tmp) || (!enable && !tmp))\r\nreturn;\r\npipe_stop(r8a66597, pipenum);\r\ndisable_fifosel(r8a66597, pipenum, CFIFOSEL);\r\ndisable_fifosel(r8a66597, pipenum, D0FIFOSEL);\r\ndisable_fifosel(r8a66597, pipenum, D1FIFOSEL);\r\ntoggle = save_usb_toggle(r8a66597, pipenum);\r\nr8a66597_write(r8a66597, pipenum, PIPESEL);\r\nif (enable)\r\nr8a66597_bset(r8a66597, R8A66597_BFRE, PIPECFG);\r\nelse\r\nr8a66597_bclr(r8a66597, R8A66597_BFRE, PIPECFG);\r\nr8a66597_bset(r8a66597, ACLRM, ep->pipectr);\r\nr8a66597_bclr(r8a66597, ACLRM, ep->pipectr);\r\nrestore_usb_toggle(r8a66597, pipenum, toggle);\r\n}\r\nstatic int sudmac_alloc_channel(struct r8a66597 *r8a66597,\r\nstruct r8a66597_ep *ep,\r\nstruct r8a66597_request *req)\r\n{\r\nstruct r8a66597_dma *dma;\r\nif (!r8a66597_is_sudmac(r8a66597))\r\nreturn -ENODEV;\r\nif (!is_bulk_pipe(ep->pipenum))\r\nreturn -EIO;\r\nif (r8a66597->dma.used)\r\nreturn -EBUSY;\r\ndma = &r8a66597->dma;\r\ndma->used = 1;\r\nif (ep->ep.desc->bEndpointAddress & USB_DIR_IN) {\r\ndma->dir = 1;\r\n} else {\r\ndma->dir = 0;\r\nchange_bfre_mode(r8a66597, ep->pipenum, 1);\r\n}\r\nep->use_dma = 1;\r\nep->dma = dma;\r\nep->fifoaddr = D0FIFO;\r\nep->fifosel = D0FIFOSEL;\r\nep->fifoctr = D0FIFOCTR;\r\nreturn usb_gadget_map_request(&r8a66597->gadget, &req->req, dma->dir);\r\n}\r\nstatic void sudmac_free_channel(struct r8a66597 *r8a66597,\r\nstruct r8a66597_ep *ep,\r\nstruct r8a66597_request *req)\r\n{\r\nif (!r8a66597_is_sudmac(r8a66597))\r\nreturn;\r\nusb_gadget_unmap_request(&r8a66597->gadget, &req->req, ep->dma->dir);\r\nr8a66597_bclr(r8a66597, DREQE, ep->fifosel);\r\nr8a66597_change_curpipe(r8a66597, 0, 0, ep->fifosel);\r\nep->dma->used = 0;\r\nep->use_dma = 0;\r\nep->fifoaddr = CFIFO;\r\nep->fifosel = CFIFOSEL;\r\nep->fifoctr = CFIFOCTR;\r\n}\r\nstatic void sudmac_start(struct r8a66597 *r8a66597, struct r8a66597_ep *ep,\r\nstruct r8a66597_request *req)\r\n{\r\nBUG_ON(req->req.length == 0);\r\nr8a66597_sudmac_write(r8a66597, LBA_WAIT, CH0CFG);\r\nr8a66597_sudmac_write(r8a66597, req->req.dma, CH0BA);\r\nr8a66597_sudmac_write(r8a66597, req->req.length, CH0BBC);\r\nr8a66597_sudmac_write(r8a66597, CH0ENDE, DINTCTRL);\r\nr8a66597_sudmac_write(r8a66597, DEN, CH0DEN);\r\n}\r\nstatic void start_packet_write(struct r8a66597_ep *ep,\r\nstruct r8a66597_request *req)\r\n{\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\nu16 tmp;\r\npipe_change(r8a66597, ep->pipenum);\r\ndisable_irq_empty(r8a66597, ep->pipenum);\r\npipe_start(r8a66597, ep->pipenum);\r\nif (req->req.length == 0) {\r\ntransfer_complete(ep, req, 0);\r\n} else {\r\nr8a66597_write(r8a66597, ~(1 << ep->pipenum), BRDYSTS);\r\nif (sudmac_alloc_channel(r8a66597, ep, req) < 0) {\r\npipe_change(r8a66597, ep->pipenum);\r\ndisable_irq_empty(r8a66597, ep->pipenum);\r\npipe_start(r8a66597, ep->pipenum);\r\ntmp = r8a66597_read(r8a66597, ep->fifoctr);\r\nif (unlikely((tmp & FRDY) == 0))\r\npipe_irq_enable(r8a66597, ep->pipenum);\r\nelse\r\nirq_packet_write(ep, req);\r\n} else {\r\npipe_change(r8a66597, ep->pipenum);\r\ndisable_irq_nrdy(r8a66597, ep->pipenum);\r\npipe_start(r8a66597, ep->pipenum);\r\nenable_irq_nrdy(r8a66597, ep->pipenum);\r\nsudmac_start(r8a66597, ep, req);\r\n}\r\n}\r\n}\r\nstatic void start_packet_read(struct r8a66597_ep *ep,\r\nstruct r8a66597_request *req)\r\n{\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\nu16 pipenum = ep->pipenum;\r\nif (ep->pipenum == 0) {\r\nr8a66597_mdfy(r8a66597, 0, (ISEL | CURPIPE), CFIFOSEL);\r\nr8a66597_write(r8a66597, BCLR, ep->fifoctr);\r\npipe_start(r8a66597, pipenum);\r\npipe_irq_enable(r8a66597, pipenum);\r\n} else {\r\npipe_stop(r8a66597, pipenum);\r\nif (ep->pipetre) {\r\nenable_irq_nrdy(r8a66597, pipenum);\r\nr8a66597_write(r8a66597, TRCLR, ep->pipetre);\r\nr8a66597_write(r8a66597,\r\nDIV_ROUND_UP(req->req.length, ep->ep.maxpacket),\r\nep->pipetrn);\r\nr8a66597_bset(r8a66597, TRENB, ep->pipetre);\r\n}\r\nif (sudmac_alloc_channel(r8a66597, ep, req) < 0) {\r\nchange_bfre_mode(r8a66597, ep->pipenum, 0);\r\npipe_start(r8a66597, pipenum);\r\npipe_irq_enable(r8a66597, pipenum);\r\n} else {\r\npipe_change(r8a66597, pipenum);\r\nsudmac_start(r8a66597, ep, req);\r\npipe_start(r8a66597, pipenum);\r\n}\r\n}\r\n}\r\nstatic void start_packet(struct r8a66597_ep *ep, struct r8a66597_request *req)\r\n{\r\nif (ep->ep.desc->bEndpointAddress & USB_DIR_IN)\r\nstart_packet_write(ep, req);\r\nelse\r\nstart_packet_read(ep, req);\r\n}\r\nstatic void start_ep0(struct r8a66597_ep *ep, struct r8a66597_request *req)\r\n{\r\nu16 ctsq;\r\nctsq = r8a66597_read(ep->r8a66597, INTSTS0) & CTSQ;\r\nswitch (ctsq) {\r\ncase CS_RDDS:\r\nstart_ep0_write(ep, req);\r\nbreak;\r\ncase CS_WRDS:\r\nstart_packet_read(ep, req);\r\nbreak;\r\ncase CS_WRND:\r\ncontrol_end(ep->r8a66597, 0);\r\nbreak;\r\ndefault:\r\ndev_err(r8a66597_to_dev(ep->r8a66597),\r\n"start_ep0: unexpect ctsq(%x)\n", ctsq);\r\nbreak;\r\n}\r\n}\r\nstatic void init_controller(struct r8a66597 *r8a66597)\r\n{\r\nu16 vif = r8a66597->pdata->vif ? LDRV : 0;\r\nu16 irq_sense = r8a66597->irq_sense_low ? INTL : 0;\r\nu16 endian = r8a66597->pdata->endian ? BIGEND : 0;\r\nif (r8a66597->pdata->on_chip) {\r\nif (r8a66597->pdata->buswait)\r\nr8a66597_write(r8a66597, r8a66597->pdata->buswait,\r\nSYSCFG1);\r\nelse\r\nr8a66597_write(r8a66597, 0x0f, SYSCFG1);\r\nr8a66597_bset(r8a66597, HSE, SYSCFG0);\r\nr8a66597_bclr(r8a66597, USBE, SYSCFG0);\r\nr8a66597_bclr(r8a66597, DPRPU, SYSCFG0);\r\nr8a66597_bset(r8a66597, USBE, SYSCFG0);\r\nr8a66597_bset(r8a66597, SCKE, SYSCFG0);\r\nr8a66597_bset(r8a66597, irq_sense, INTENB1);\r\nr8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR,\r\nDMA0CFG);\r\n} else {\r\nr8a66597_bset(r8a66597, vif | endian, PINCFG);\r\nr8a66597_bset(r8a66597, HSE, SYSCFG0);\r\nr8a66597_mdfy(r8a66597, get_xtal_from_pdata(r8a66597->pdata),\r\nXTAL, SYSCFG0);\r\nr8a66597_bclr(r8a66597, USBE, SYSCFG0);\r\nr8a66597_bclr(r8a66597, DPRPU, SYSCFG0);\r\nr8a66597_bset(r8a66597, USBE, SYSCFG0);\r\nr8a66597_bset(r8a66597, XCKE, SYSCFG0);\r\nmsleep(3);\r\nr8a66597_bset(r8a66597, PLLC, SYSCFG0);\r\nmsleep(1);\r\nr8a66597_bset(r8a66597, SCKE, SYSCFG0);\r\nr8a66597_bset(r8a66597, irq_sense, INTENB1);\r\nr8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR,\r\nDMA0CFG);\r\n}\r\n}\r\nstatic void disable_controller(struct r8a66597 *r8a66597)\r\n{\r\nif (r8a66597->pdata->on_chip) {\r\nr8a66597_bset(r8a66597, SCKE, SYSCFG0);\r\nr8a66597_bclr(r8a66597, UTST, TESTMODE);\r\nr8a66597_write(r8a66597, 0, INTENB0);\r\nr8a66597_write(r8a66597, 0, INTENB1);\r\nr8a66597_write(r8a66597, 0, BRDYENB);\r\nr8a66597_write(r8a66597, 0, BEMPENB);\r\nr8a66597_write(r8a66597, 0, NRDYENB);\r\nr8a66597_write(r8a66597, 0, BRDYSTS);\r\nr8a66597_write(r8a66597, 0, NRDYSTS);\r\nr8a66597_write(r8a66597, 0, BEMPSTS);\r\nr8a66597_bclr(r8a66597, USBE, SYSCFG0);\r\nr8a66597_bclr(r8a66597, SCKE, SYSCFG0);\r\n} else {\r\nr8a66597_bclr(r8a66597, UTST, TESTMODE);\r\nr8a66597_bclr(r8a66597, SCKE, SYSCFG0);\r\nudelay(1);\r\nr8a66597_bclr(r8a66597, PLLC, SYSCFG0);\r\nudelay(1);\r\nudelay(1);\r\nr8a66597_bclr(r8a66597, XCKE, SYSCFG0);\r\n}\r\n}\r\nstatic void r8a66597_start_xclock(struct r8a66597 *r8a66597)\r\n{\r\nu16 tmp;\r\nif (!r8a66597->pdata->on_chip) {\r\ntmp = r8a66597_read(r8a66597, SYSCFG0);\r\nif (!(tmp & XCKE))\r\nr8a66597_bset(r8a66597, XCKE, SYSCFG0);\r\n}\r\n}\r\nstatic struct r8a66597_request *get_request_from_ep(struct r8a66597_ep *ep)\r\n{\r\nreturn list_entry(ep->queue.next, struct r8a66597_request, queue);\r\n}\r\nstatic void transfer_complete(struct r8a66597_ep *ep,\r\nstruct r8a66597_request *req, int status)\r\n__releases(r8a66597->lock)\r\n__acquires(r8a66597->lock)\r\n{\r\nint restart = 0;\r\nif (unlikely(ep->pipenum == 0)) {\r\nif (ep->internal_ccpl) {\r\nep->internal_ccpl = 0;\r\nreturn;\r\n}\r\n}\r\nlist_del_init(&req->queue);\r\nif (ep->r8a66597->gadget.speed == USB_SPEED_UNKNOWN)\r\nreq->req.status = -ESHUTDOWN;\r\nelse\r\nreq->req.status = status;\r\nif (!list_empty(&ep->queue))\r\nrestart = 1;\r\nif (ep->use_dma)\r\nsudmac_free_channel(ep->r8a66597, ep, req);\r\nspin_unlock(&ep->r8a66597->lock);\r\nusb_gadget_giveback_request(&ep->ep, &req->req);\r\nspin_lock(&ep->r8a66597->lock);\r\nif (restart) {\r\nreq = get_request_from_ep(ep);\r\nif (ep->ep.desc)\r\nstart_packet(ep, req);\r\n}\r\n}\r\nstatic void irq_ep0_write(struct r8a66597_ep *ep, struct r8a66597_request *req)\r\n{\r\nint i;\r\nu16 tmp;\r\nunsigned bufsize;\r\nsize_t size;\r\nvoid *buf;\r\nu16 pipenum = ep->pipenum;\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\npipe_change(r8a66597, pipenum);\r\nr8a66597_bset(r8a66597, ISEL, ep->fifosel);\r\ni = 0;\r\ndo {\r\ntmp = r8a66597_read(r8a66597, ep->fifoctr);\r\nif (i++ > 100000) {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"pipe0 is busy. maybe cpu i/o bus "\r\n"conflict. please power off this controller.");\r\nreturn;\r\n}\r\nndelay(1);\r\n} while ((tmp & FRDY) == 0);\r\nbufsize = get_buffer_size(r8a66597, pipenum);\r\nbuf = req->req.buf + req->req.actual;\r\nsize = min(bufsize, req->req.length - req->req.actual);\r\nif (req->req.buf) {\r\nif (size > 0)\r\nr8a66597_write_fifo(r8a66597, ep, buf, size);\r\nif ((size == 0) || ((size % ep->ep.maxpacket) != 0))\r\nr8a66597_bset(r8a66597, BVAL, ep->fifoctr);\r\n}\r\nreq->req.actual += size;\r\nif ((!req->req.zero && (req->req.actual == req->req.length))\r\n|| (size % ep->ep.maxpacket)\r\n|| (size == 0)) {\r\ndisable_irq_ready(r8a66597, pipenum);\r\ndisable_irq_empty(r8a66597, pipenum);\r\n} else {\r\ndisable_irq_ready(r8a66597, pipenum);\r\nenable_irq_empty(r8a66597, pipenum);\r\n}\r\npipe_start(r8a66597, pipenum);\r\n}\r\nstatic void irq_packet_write(struct r8a66597_ep *ep,\r\nstruct r8a66597_request *req)\r\n{\r\nu16 tmp;\r\nunsigned bufsize;\r\nsize_t size;\r\nvoid *buf;\r\nu16 pipenum = ep->pipenum;\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\npipe_change(r8a66597, pipenum);\r\ntmp = r8a66597_read(r8a66597, ep->fifoctr);\r\nif (unlikely((tmp & FRDY) == 0)) {\r\npipe_stop(r8a66597, pipenum);\r\npipe_irq_disable(r8a66597, pipenum);\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"write fifo not ready. pipnum=%d\n", pipenum);\r\nreturn;\r\n}\r\nbufsize = get_buffer_size(r8a66597, pipenum);\r\nbuf = req->req.buf + req->req.actual;\r\nsize = min(bufsize, req->req.length - req->req.actual);\r\nif (req->req.buf) {\r\nr8a66597_write_fifo(r8a66597, ep, buf, size);\r\nif ((size == 0)\r\n|| ((size % ep->ep.maxpacket) != 0)\r\n|| ((bufsize != ep->ep.maxpacket)\r\n&& (bufsize > size)))\r\nr8a66597_bset(r8a66597, BVAL, ep->fifoctr);\r\n}\r\nreq->req.actual += size;\r\nif ((!req->req.zero && (req->req.actual == req->req.length))\r\n|| (size % ep->ep.maxpacket)\r\n|| (size == 0)) {\r\ndisable_irq_ready(r8a66597, pipenum);\r\nenable_irq_empty(r8a66597, pipenum);\r\n} else {\r\ndisable_irq_empty(r8a66597, pipenum);\r\npipe_irq_enable(r8a66597, pipenum);\r\n}\r\n}\r\nstatic void irq_packet_read(struct r8a66597_ep *ep,\r\nstruct r8a66597_request *req)\r\n{\r\nu16 tmp;\r\nint rcv_len, bufsize, req_len;\r\nint size;\r\nvoid *buf;\r\nu16 pipenum = ep->pipenum;\r\nstruct r8a66597 *r8a66597 = ep->r8a66597;\r\nint finish = 0;\r\npipe_change(r8a66597, pipenum);\r\ntmp = r8a66597_read(r8a66597, ep->fifoctr);\r\nif (unlikely((tmp & FRDY) == 0)) {\r\nreq->req.status = -EPIPE;\r\npipe_stop(r8a66597, pipenum);\r\npipe_irq_disable(r8a66597, pipenum);\r\ndev_err(r8a66597_to_dev(r8a66597), "read fifo not ready");\r\nreturn;\r\n}\r\nrcv_len = tmp & DTLN;\r\nbufsize = get_buffer_size(r8a66597, pipenum);\r\nbuf = req->req.buf + req->req.actual;\r\nreq_len = req->req.length - req->req.actual;\r\nif (rcv_len < bufsize)\r\nsize = min(rcv_len, req_len);\r\nelse\r\nsize = min(bufsize, req_len);\r\nreq->req.actual += size;\r\nif ((!req->req.zero && (req->req.actual == req->req.length))\r\n|| (size % ep->ep.maxpacket)\r\n|| (size == 0)) {\r\npipe_stop(r8a66597, pipenum);\r\npipe_irq_disable(r8a66597, pipenum);\r\nfinish = 1;\r\n}\r\nif (req->req.buf) {\r\nif (size == 0)\r\nr8a66597_write(r8a66597, BCLR, ep->fifoctr);\r\nelse\r\nr8a66597_read_fifo(r8a66597, ep->fifoaddr, buf, size);\r\n}\r\nif ((ep->pipenum != 0) && finish)\r\ntransfer_complete(ep, req, 0);\r\n}\r\nstatic void irq_pipe_ready(struct r8a66597 *r8a66597, u16 status, u16 enb)\r\n{\r\nu16 check;\r\nu16 pipenum;\r\nstruct r8a66597_ep *ep;\r\nstruct r8a66597_request *req;\r\nif ((status & BRDY0) && (enb & BRDY0)) {\r\nr8a66597_write(r8a66597, ~BRDY0, BRDYSTS);\r\nr8a66597_mdfy(r8a66597, 0, CURPIPE, CFIFOSEL);\r\nep = &r8a66597->ep[0];\r\nreq = get_request_from_ep(ep);\r\nirq_packet_read(ep, req);\r\n} else {\r\nfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\r\ncheck = 1 << pipenum;\r\nif ((status & check) && (enb & check)) {\r\nr8a66597_write(r8a66597, ~check, BRDYSTS);\r\nep = r8a66597->pipenum2ep[pipenum];\r\nreq = get_request_from_ep(ep);\r\nif (ep->ep.desc->bEndpointAddress & USB_DIR_IN)\r\nirq_packet_write(ep, req);\r\nelse\r\nirq_packet_read(ep, req);\r\n}\r\n}\r\n}\r\n}\r\nstatic void irq_pipe_empty(struct r8a66597 *r8a66597, u16 status, u16 enb)\r\n{\r\nu16 tmp;\r\nu16 check;\r\nu16 pipenum;\r\nstruct r8a66597_ep *ep;\r\nstruct r8a66597_request *req;\r\nif ((status & BEMP0) && (enb & BEMP0)) {\r\nr8a66597_write(r8a66597, ~BEMP0, BEMPSTS);\r\nep = &r8a66597->ep[0];\r\nreq = get_request_from_ep(ep);\r\nirq_ep0_write(ep, req);\r\n} else {\r\nfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\r\ncheck = 1 << pipenum;\r\nif ((status & check) && (enb & check)) {\r\nr8a66597_write(r8a66597, ~check, BEMPSTS);\r\ntmp = control_reg_get(r8a66597, pipenum);\r\nif ((tmp & INBUFM) == 0) {\r\ndisable_irq_empty(r8a66597, pipenum);\r\npipe_irq_disable(r8a66597, pipenum);\r\npipe_stop(r8a66597, pipenum);\r\nep = r8a66597->pipenum2ep[pipenum];\r\nreq = get_request_from_ep(ep);\r\nif (!list_empty(&ep->queue))\r\ntransfer_complete(ep, req, 0);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void get_status(struct r8a66597 *r8a66597, struct usb_ctrlrequest *ctrl)\r\n__releases(r8a66597->lock)\r\n__acquires(r8a66597->lock)\r\n{\r\nstruct r8a66597_ep *ep;\r\nu16 pid;\r\nu16 status = 0;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nstatus = r8a66597->device_status;\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nstatus = 0;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nep = r8a66597->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\r\npid = control_reg_get_pid(r8a66597, ep->pipenum);\r\nif (pid == PID_STALL)\r\nstatus = 1 << USB_ENDPOINT_HALT;\r\nelse\r\nstatus = 0;\r\nbreak;\r\ndefault:\r\npipe_stall(r8a66597, 0);\r\nreturn;\r\n}\r\nr8a66597->ep0_data = cpu_to_le16(status);\r\nr8a66597->ep0_req->buf = &r8a66597->ep0_data;\r\nr8a66597->ep0_req->length = 2;\r\nspin_unlock(&r8a66597->lock);\r\nr8a66597_queue(r8a66597->gadget.ep0, r8a66597->ep0_req, GFP_KERNEL);\r\nspin_lock(&r8a66597->lock);\r\n}\r\nstatic void clear_feature(struct r8a66597 *r8a66597,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\ncontrol_end(r8a66597, 1);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\ncontrol_end(r8a66597, 1);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT: {\r\nstruct r8a66597_ep *ep;\r\nstruct r8a66597_request *req;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nep = r8a66597->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\r\nif (!ep->wedge) {\r\npipe_stop(r8a66597, ep->pipenum);\r\ncontrol_reg_sqclr(r8a66597, ep->pipenum);\r\nspin_unlock(&r8a66597->lock);\r\nusb_ep_clear_halt(&ep->ep);\r\nspin_lock(&r8a66597->lock);\r\n}\r\ncontrol_end(r8a66597, 1);\r\nreq = get_request_from_ep(ep);\r\nif (ep->busy) {\r\nep->busy = 0;\r\nif (list_empty(&ep->queue))\r\nbreak;\r\nstart_packet(ep, req);\r\n} else if (!list_empty(&ep->queue))\r\npipe_start(r8a66597, ep->pipenum);\r\n}\r\nbreak;\r\ndefault:\r\npipe_stall(r8a66597, 0);\r\nbreak;\r\n}\r\n}\r\nstatic void set_feature(struct r8a66597 *r8a66597, struct usb_ctrlrequest *ctrl)\r\n{\r\nu16 tmp;\r\nint timeout = 3000;\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nswitch (le16_to_cpu(ctrl->wValue)) {\r\ncase USB_DEVICE_TEST_MODE:\r\ncontrol_end(r8a66597, 1);\r\ndo {\r\ntmp = r8a66597_read(r8a66597, INTSTS0) & CTSQ;\r\nudelay(1);\r\n} while (tmp != CS_IDST || timeout-- > 0);\r\nif (tmp == CS_IDST)\r\nr8a66597_bset(r8a66597,\r\nle16_to_cpu(ctrl->wIndex >> 8),\r\nTESTMODE);\r\nbreak;\r\ndefault:\r\npipe_stall(r8a66597, 0);\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\ncontrol_end(r8a66597, 1);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT: {\r\nstruct r8a66597_ep *ep;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nep = r8a66597->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\r\npipe_stall(r8a66597, ep->pipenum);\r\ncontrol_end(r8a66597, 1);\r\n}\r\nbreak;\r\ndefault:\r\npipe_stall(r8a66597, 0);\r\nbreak;\r\n}\r\n}\r\nstatic int setup_packet(struct r8a66597 *r8a66597, struct usb_ctrlrequest *ctrl)\r\n{\r\nu16 *p = (u16 *)ctrl;\r\nunsigned long offset = USBREQ;\r\nint i, ret = 0;\r\nr8a66597_write(r8a66597, ~VALID, INTSTS0);\r\nfor (i = 0; i < 4; i++)\r\np[i] = r8a66597_read(r8a66597, offset + i*2);\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nget_status(r8a66597, ctrl);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nclear_feature(r8a66597, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nset_feature(r8a66597, ctrl);\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\n} else\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic void r8a66597_update_usb_speed(struct r8a66597 *r8a66597)\r\n{\r\nu16 speed = get_usb_speed(r8a66597);\r\nswitch (speed) {\r\ncase HSMODE:\r\nr8a66597->gadget.speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase FSMODE:\r\nr8a66597->gadget.speed = USB_SPEED_FULL;\r\nbreak;\r\ndefault:\r\nr8a66597->gadget.speed = USB_SPEED_UNKNOWN;\r\ndev_err(r8a66597_to_dev(r8a66597), "USB speed unknown\n");\r\n}\r\n}\r\nstatic void irq_device_state(struct r8a66597 *r8a66597)\r\n{\r\nu16 dvsq;\r\ndvsq = r8a66597_read(r8a66597, INTSTS0) & DVSQ;\r\nr8a66597_write(r8a66597, ~DVST, INTSTS0);\r\nif (dvsq == DS_DFLT) {\r\nspin_unlock(&r8a66597->lock);\r\nusb_gadget_udc_reset(&r8a66597->gadget, r8a66597->driver);\r\nspin_lock(&r8a66597->lock);\r\nr8a66597_update_usb_speed(r8a66597);\r\n}\r\nif (r8a66597->old_dvsq == DS_CNFG && dvsq != DS_CNFG)\r\nr8a66597_update_usb_speed(r8a66597);\r\nif ((dvsq == DS_CNFG || dvsq == DS_ADDS)\r\n&& r8a66597->gadget.speed == USB_SPEED_UNKNOWN)\r\nr8a66597_update_usb_speed(r8a66597);\r\nr8a66597->old_dvsq = dvsq;\r\n}\r\nstatic void irq_control_stage(struct r8a66597 *r8a66597)\r\n__releases(r8a66597->lock)\r\n__acquires(r8a66597->lock)\r\n{\r\nstruct usb_ctrlrequest ctrl;\r\nu16 ctsq;\r\nctsq = r8a66597_read(r8a66597, INTSTS0) & CTSQ;\r\nr8a66597_write(r8a66597, ~CTRT, INTSTS0);\r\nswitch (ctsq) {\r\ncase CS_IDST: {\r\nstruct r8a66597_ep *ep;\r\nstruct r8a66597_request *req;\r\nep = &r8a66597->ep[0];\r\nreq = get_request_from_ep(ep);\r\ntransfer_complete(ep, req, 0);\r\n}\r\nbreak;\r\ncase CS_RDDS:\r\ncase CS_WRDS:\r\ncase CS_WRND:\r\nif (setup_packet(r8a66597, &ctrl)) {\r\nspin_unlock(&r8a66597->lock);\r\nif (r8a66597->driver->setup(&r8a66597->gadget, &ctrl)\r\n< 0)\r\npipe_stall(r8a66597, 0);\r\nspin_lock(&r8a66597->lock);\r\n}\r\nbreak;\r\ncase CS_RDSS:\r\ncase CS_WRSS:\r\ncontrol_end(r8a66597, 0);\r\nbreak;\r\ndefault:\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"ctrl_stage: unexpect ctsq(%x)\n", ctsq);\r\nbreak;\r\n}\r\n}\r\nstatic void sudmac_finish(struct r8a66597 *r8a66597, struct r8a66597_ep *ep)\r\n{\r\nu16 pipenum;\r\nstruct r8a66597_request *req;\r\nu32 len;\r\nint i = 0;\r\npipenum = ep->pipenum;\r\npipe_change(r8a66597, pipenum);\r\nwhile (!(r8a66597_read(r8a66597, ep->fifoctr) & FRDY)) {\r\nudelay(1);\r\nif (unlikely(i++ >= 10000)) {\r\ndev_err(r8a66597_to_dev(r8a66597),\r\n"%s: FRDY was not set (%d)\n",\r\n__func__, pipenum);\r\nreturn;\r\n}\r\n}\r\nr8a66597_bset(r8a66597, BCLR, ep->fifoctr);\r\nreq = get_request_from_ep(ep);\r\nlen = r8a66597_sudmac_read(r8a66597, CH0CBC);\r\nreq->req.actual += len;\r\nr8a66597_sudmac_write(r8a66597, CH0STCLR, DSTSCLR);\r\nif ((!req->req.zero && (req->req.actual == req->req.length))\r\n|| (len % ep->ep.maxpacket)) {\r\nif (ep->dma->dir) {\r\ndisable_irq_ready(r8a66597, pipenum);\r\nenable_irq_empty(r8a66597, pipenum);\r\n} else {\r\nr8a66597_write(r8a66597, ~(1 << pipenum), BRDYSTS);\r\ntransfer_complete(ep, req, 0);\r\n}\r\n}\r\n}\r\nstatic void r8a66597_sudmac_irq(struct r8a66597 *r8a66597)\r\n{\r\nu32 irqsts;\r\nstruct r8a66597_ep *ep;\r\nu16 pipenum;\r\nirqsts = r8a66597_sudmac_read(r8a66597, DINTSTS);\r\nif (irqsts & CH0ENDS) {\r\nr8a66597_sudmac_write(r8a66597, CH0ENDC, DINTSTSCLR);\r\npipenum = (r8a66597_read(r8a66597, D0FIFOSEL) & CURPIPE);\r\nep = r8a66597->pipenum2ep[pipenum];\r\nsudmac_finish(r8a66597, ep);\r\n}\r\n}\r\nstatic irqreturn_t r8a66597_irq(int irq, void *_r8a66597)\r\n{\r\nstruct r8a66597 *r8a66597 = _r8a66597;\r\nu16 intsts0;\r\nu16 intenb0;\r\nu16 savepipe;\r\nu16 mask0;\r\nspin_lock(&r8a66597->lock);\r\nif (r8a66597_is_sudmac(r8a66597))\r\nr8a66597_sudmac_irq(r8a66597);\r\nintsts0 = r8a66597_read(r8a66597, INTSTS0);\r\nintenb0 = r8a66597_read(r8a66597, INTENB0);\r\nsavepipe = r8a66597_read(r8a66597, CFIFOSEL);\r\nmask0 = intsts0 & intenb0;\r\nif (mask0) {\r\nu16 brdysts = r8a66597_read(r8a66597, BRDYSTS);\r\nu16 bempsts = r8a66597_read(r8a66597, BEMPSTS);\r\nu16 brdyenb = r8a66597_read(r8a66597, BRDYENB);\r\nu16 bempenb = r8a66597_read(r8a66597, BEMPENB);\r\nif (mask0 & VBINT) {\r\nr8a66597_write(r8a66597, 0xffff & ~VBINT,\r\nINTSTS0);\r\nr8a66597_start_xclock(r8a66597);\r\nr8a66597->old_vbus = r8a66597_read(r8a66597, INTSTS0)\r\n& VBSTS;\r\nr8a66597->scount = R8A66597_MAX_SAMPLING;\r\nmod_timer(&r8a66597->timer,\r\njiffies + msecs_to_jiffies(50));\r\n}\r\nif (intsts0 & DVSQ)\r\nirq_device_state(r8a66597);\r\nif ((intsts0 & BRDY) && (intenb0 & BRDYE)\r\n&& (brdysts & brdyenb))\r\nirq_pipe_ready(r8a66597, brdysts, brdyenb);\r\nif ((intsts0 & BEMP) && (intenb0 & BEMPE)\r\n&& (bempsts & bempenb))\r\nirq_pipe_empty(r8a66597, bempsts, bempenb);\r\nif (intsts0 & CTRT)\r\nirq_control_stage(r8a66597);\r\n}\r\nr8a66597_write(r8a66597, savepipe, CFIFOSEL);\r\nspin_unlock(&r8a66597->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void r8a66597_timer(unsigned long _r8a66597)\r\n{\r\nstruct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;\r\nunsigned long flags;\r\nu16 tmp;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\ntmp = r8a66597_read(r8a66597, SYSCFG0);\r\nif (r8a66597->scount > 0) {\r\ntmp = r8a66597_read(r8a66597, INTSTS0) & VBSTS;\r\nif (tmp == r8a66597->old_vbus) {\r\nr8a66597->scount--;\r\nif (r8a66597->scount == 0) {\r\nif (tmp == VBSTS)\r\nr8a66597_usb_connect(r8a66597);\r\nelse\r\nr8a66597_usb_disconnect(r8a66597);\r\n} else {\r\nmod_timer(&r8a66597->timer,\r\njiffies + msecs_to_jiffies(50));\r\n}\r\n} else {\r\nr8a66597->scount = R8A66597_MAX_SAMPLING;\r\nr8a66597->old_vbus = tmp;\r\nmod_timer(&r8a66597->timer,\r\njiffies + msecs_to_jiffies(50));\r\n}\r\n}\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\n}\r\nstatic int r8a66597_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct r8a66597_ep *ep;\r\nep = container_of(_ep, struct r8a66597_ep, ep);\r\nreturn alloc_pipe_config(ep, desc);\r\n}\r\nstatic int r8a66597_disable(struct usb_ep *_ep)\r\n{\r\nstruct r8a66597_ep *ep;\r\nstruct r8a66597_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct r8a66597_ep, ep);\r\nBUG_ON(!ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = get_request_from_ep(ep);\r\nspin_lock_irqsave(&ep->r8a66597->lock, flags);\r\ntransfer_complete(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\r\n}\r\npipe_irq_disable(ep->r8a66597, ep->pipenum);\r\nreturn free_pipe_config(ep);\r\n}\r\nstatic struct usb_request *r8a66597_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct r8a66597_request *req;\r\nreq = kzalloc(sizeof(struct r8a66597_request), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void r8a66597_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct r8a66597_request *req;\r\nreq = container_of(_req, struct r8a66597_request, req);\r\nkfree(req);\r\n}\r\nstatic int r8a66597_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct r8a66597_ep *ep;\r\nstruct r8a66597_request *req;\r\nunsigned long flags;\r\nint request = 0;\r\nep = container_of(_ep, struct r8a66597_ep, ep);\r\nreq = container_of(_req, struct r8a66597_request, req);\r\nif (ep->r8a66597->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&ep->r8a66597->lock, flags);\r\nif (list_empty(&ep->queue))\r\nrequest = 1;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nreq->req.actual = 0;\r\nreq->req.status = -EINPROGRESS;\r\nif (ep->ep.desc == NULL)\r\nstart_ep0(ep, req);\r\nelse {\r\nif (request && !ep->busy)\r\nstart_packet(ep, req);\r\n}\r\nspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int r8a66597_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct r8a66597_ep *ep;\r\nstruct r8a66597_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct r8a66597_ep, ep);\r\nreq = container_of(_req, struct r8a66597_request, req);\r\nspin_lock_irqsave(&ep->r8a66597->lock, flags);\r\nif (!list_empty(&ep->queue))\r\ntransfer_complete(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int r8a66597_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct r8a66597_ep *ep = container_of(_ep, struct r8a66597_ep, ep);\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&ep->r8a66597->lock, flags);\r\nif (!list_empty(&ep->queue)) {\r\nret = -EAGAIN;\r\n} else if (value) {\r\nep->busy = 1;\r\npipe_stall(ep->r8a66597, ep->pipenum);\r\n} else {\r\nep->busy = 0;\r\nep->wedge = 0;\r\npipe_stop(ep->r8a66597, ep->pipenum);\r\n}\r\nspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int r8a66597_set_wedge(struct usb_ep *_ep)\r\n{\r\nstruct r8a66597_ep *ep;\r\nunsigned long flags;\r\nep = container_of(_ep, struct r8a66597_ep, ep);\r\nif (!ep || !ep->ep.desc)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->r8a66597->lock, flags);\r\nep->wedge = 1;\r\nspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\r\nreturn usb_ep_set_halt(_ep);\r\n}\r\nstatic void r8a66597_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct r8a66597_ep *ep;\r\nunsigned long flags;\r\nep = container_of(_ep, struct r8a66597_ep, ep);\r\nspin_lock_irqsave(&ep->r8a66597->lock, flags);\r\nif (list_empty(&ep->queue) && !ep->busy) {\r\npipe_stop(ep->r8a66597, ep->pipenum);\r\nr8a66597_bclr(ep->r8a66597, BCLR, ep->fifoctr);\r\nr8a66597_write(ep->r8a66597, ACLRM, ep->pipectr);\r\nr8a66597_write(ep->r8a66597, 0, ep->pipectr);\r\n}\r\nspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\r\n}\r\nstatic int r8a66597_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct r8a66597 *r8a66597 = gadget_to_r8a66597(gadget);\r\nif (!driver\r\n|| driver->max_speed < USB_SPEED_HIGH\r\n|| !driver->setup)\r\nreturn -EINVAL;\r\nif (!r8a66597)\r\nreturn -ENODEV;\r\nr8a66597->driver = driver;\r\ninit_controller(r8a66597);\r\nr8a66597_bset(r8a66597, VBSE, INTENB0);\r\nif (r8a66597_read(r8a66597, INTSTS0) & VBSTS) {\r\nr8a66597_start_xclock(r8a66597);\r\nr8a66597->old_vbus = r8a66597_read(r8a66597,\r\nINTSTS0) & VBSTS;\r\nr8a66597->scount = R8A66597_MAX_SAMPLING;\r\nmod_timer(&r8a66597->timer, jiffies + msecs_to_jiffies(50));\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8a66597_stop(struct usb_gadget *gadget)\r\n{\r\nstruct r8a66597 *r8a66597 = gadget_to_r8a66597(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\nr8a66597_bclr(r8a66597, VBSE, INTENB0);\r\ndisable_controller(r8a66597);\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\nr8a66597->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic int r8a66597_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct r8a66597 *r8a66597 = gadget_to_r8a66597(_gadget);\r\nreturn r8a66597_read(r8a66597, FRMNUM) & 0x03FF;\r\n}\r\nstatic int r8a66597_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct r8a66597 *r8a66597 = gadget_to_r8a66597(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\nif (is_on)\r\nr8a66597_bset(r8a66597, DPRPU, SYSCFG0);\r\nelse\r\nr8a66597_bclr(r8a66597, DPRPU, SYSCFG0);\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int r8a66597_set_selfpowered(struct usb_gadget *gadget, int is_self)\r\n{\r\nstruct r8a66597 *r8a66597 = gadget_to_r8a66597(gadget);\r\ngadget->is_selfpowered = (is_self != 0);\r\nif (is_self)\r\nr8a66597->device_status |= 1 << USB_DEVICE_SELF_POWERED;\r\nelse\r\nr8a66597->device_status &= ~(1 << USB_DEVICE_SELF_POWERED);\r\nreturn 0;\r\n}\r\nstatic int r8a66597_remove(struct platform_device *pdev)\r\n{\r\nstruct r8a66597 *r8a66597 = platform_get_drvdata(pdev);\r\nusb_del_gadget_udc(&r8a66597->gadget);\r\ndel_timer_sync(&r8a66597->timer);\r\nr8a66597_free_request(&r8a66597->ep[0].ep, r8a66597->ep0_req);\r\nif (r8a66597->pdata->on_chip) {\r\nclk_disable_unprepare(r8a66597->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic void nop_completion(struct usb_ep *ep, struct usb_request *r)\r\n{\r\n}\r\nstatic int r8a66597_sudmac_ioremap(struct r8a66597 *r8a66597,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "sudmac");\r\nr8a66597->sudmac_reg = devm_ioremap_resource(&pdev->dev, res);\r\nreturn PTR_ERR_OR_ZERO(r8a66597->sudmac_reg);\r\n}\r\nstatic int r8a66597_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nchar clk_name[8];\r\nstruct resource *res, *ires;\r\nint irq;\r\nvoid __iomem *reg = NULL;\r\nstruct r8a66597 *r8a66597 = NULL;\r\nint ret = 0;\r\nint i;\r\nunsigned long irq_trigger;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nirq = ires->start;\r\nirq_trigger = ires->flags & IRQF_TRIGGER_MASK;\r\nif (irq < 0) {\r\ndev_err(dev, "platform_get_irq error.\n");\r\nreturn -ENODEV;\r\n}\r\nr8a66597 = devm_kzalloc(dev, sizeof(struct r8a66597), GFP_KERNEL);\r\nif (r8a66597 == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&r8a66597->lock);\r\nplatform_set_drvdata(pdev, r8a66597);\r\nr8a66597->pdata = dev_get_platdata(dev);\r\nr8a66597->irq_sense_low = irq_trigger == IRQF_TRIGGER_LOW;\r\nr8a66597->gadget.ops = &r8a66597_gadget_ops;\r\nr8a66597->gadget.max_speed = USB_SPEED_HIGH;\r\nr8a66597->gadget.name = udc_name;\r\ninit_timer(&r8a66597->timer);\r\nr8a66597->timer.function = r8a66597_timer;\r\nr8a66597->timer.data = (unsigned long)r8a66597;\r\nr8a66597->reg = reg;\r\nif (r8a66597->pdata->on_chip) {\r\nsnprintf(clk_name, sizeof(clk_name), "usb%d", pdev->id);\r\nr8a66597->clk = devm_clk_get(dev, clk_name);\r\nif (IS_ERR(r8a66597->clk)) {\r\ndev_err(dev, "cannot get clock \"%s\"\n", clk_name);\r\nreturn PTR_ERR(r8a66597->clk);\r\n}\r\nclk_prepare_enable(r8a66597->clk);\r\n}\r\nif (r8a66597->pdata->sudmac) {\r\nret = r8a66597_sudmac_ioremap(r8a66597, pdev);\r\nif (ret < 0)\r\ngoto clean_up2;\r\n}\r\ndisable_controller(r8a66597);\r\nret = devm_request_irq(dev, irq, r8a66597_irq, IRQF_SHARED,\r\nudc_name, r8a66597);\r\nif (ret < 0) {\r\ndev_err(dev, "request_irq error (%d)\n", ret);\r\ngoto clean_up2;\r\n}\r\nINIT_LIST_HEAD(&r8a66597->gadget.ep_list);\r\nr8a66597->gadget.ep0 = &r8a66597->ep[0].ep;\r\nINIT_LIST_HEAD(&r8a66597->gadget.ep0->ep_list);\r\nfor (i = 0; i < R8A66597_MAX_NUM_PIPE; i++) {\r\nstruct r8a66597_ep *ep = &r8a66597->ep[i];\r\nif (i != 0) {\r\nINIT_LIST_HEAD(&r8a66597->ep[i].ep.ep_list);\r\nlist_add_tail(&r8a66597->ep[i].ep.ep_list,\r\n&r8a66597->gadget.ep_list);\r\n}\r\nep->r8a66597 = r8a66597;\r\nINIT_LIST_HEAD(&ep->queue);\r\nep->ep.name = r8a66597_ep_name[i];\r\nep->ep.ops = &r8a66597_ep_ops;\r\nusb_ep_set_maxpacket_limit(&ep->ep, 512);\r\nif (i == 0) {\r\nep->ep.caps.type_control = true;\r\n} else {\r\nep->ep.caps.type_iso = true;\r\nep->ep.caps.type_bulk = true;\r\nep->ep.caps.type_int = true;\r\n}\r\nep->ep.caps.dir_in = true;\r\nep->ep.caps.dir_out = true;\r\n}\r\nusb_ep_set_maxpacket_limit(&r8a66597->ep[0].ep, 64);\r\nr8a66597->ep[0].pipenum = 0;\r\nr8a66597->ep[0].fifoaddr = CFIFO;\r\nr8a66597->ep[0].fifosel = CFIFOSEL;\r\nr8a66597->ep[0].fifoctr = CFIFOCTR;\r\nr8a66597->ep[0].pipectr = get_pipectr_addr(0);\r\nr8a66597->pipenum2ep[0] = &r8a66597->ep[0];\r\nr8a66597->epaddr2ep[0] = &r8a66597->ep[0];\r\nr8a66597->ep0_req = r8a66597_alloc_request(&r8a66597->ep[0].ep,\r\nGFP_KERNEL);\r\nif (r8a66597->ep0_req == NULL) {\r\nret = -ENOMEM;\r\ngoto clean_up2;\r\n}\r\nr8a66597->ep0_req->complete = nop_completion;\r\nret = usb_add_gadget_udc(dev, &r8a66597->gadget);\r\nif (ret)\r\ngoto err_add_udc;\r\ndev_info(dev, "version %s\n", DRIVER_VERSION);\r\nreturn 0;\r\nerr_add_udc:\r\nr8a66597_free_request(&r8a66597->ep[0].ep, r8a66597->ep0_req);\r\nclean_up2:\r\nif (r8a66597->pdata->on_chip)\r\nclk_disable_unprepare(r8a66597->clk);\r\nif (r8a66597->ep0_req)\r\nr8a66597_free_request(&r8a66597->ep[0].ep, r8a66597->ep0_req);\r\nreturn ret;\r\n}
