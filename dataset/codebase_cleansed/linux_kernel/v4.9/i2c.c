static int st_nci_i2c_enable(void *phy_id)\r\n{\r\nstruct st_nci_i2c_phy *phy = phy_id;\r\ngpio_set_value(phy->gpio_reset, 0);\r\nusleep_range(10000, 15000);\r\ngpio_set_value(phy->gpio_reset, 1);\r\nusleep_range(80000, 85000);\r\nif (phy->ndlc->powered == 0 && phy->irq_active == 0) {\r\nenable_irq(phy->i2c_dev->irq);\r\nphy->irq_active = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic void st_nci_i2c_disable(void *phy_id)\r\n{\r\nstruct st_nci_i2c_phy *phy = phy_id;\r\ndisable_irq_nosync(phy->i2c_dev->irq);\r\nphy->irq_active = false;\r\n}\r\nstatic int st_nci_i2c_write(void *phy_id, struct sk_buff *skb)\r\n{\r\nint r = -1;\r\nstruct st_nci_i2c_phy *phy = phy_id;\r\nstruct i2c_client *client = phy->i2c_dev;\r\nif (phy->ndlc->hard_fault != 0)\r\nreturn phy->ndlc->hard_fault;\r\nr = i2c_master_send(client, skb->data, skb->len);\r\nif (r < 0) {\r\nusleep_range(1000, 4000);\r\nr = i2c_master_send(client, skb->data, skb->len);\r\n}\r\nif (r >= 0) {\r\nif (r != skb->len)\r\nr = -EREMOTEIO;\r\nelse\r\nr = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic int st_nci_i2c_read(struct st_nci_i2c_phy *phy,\r\nstruct sk_buff **skb)\r\n{\r\nint r;\r\nu8 len;\r\nu8 buf[ST_NCI_I2C_MAX_SIZE];\r\nstruct i2c_client *client = phy->i2c_dev;\r\nr = i2c_master_recv(client, buf, ST_NCI_I2C_MIN_SIZE);\r\nif (r < 0) {\r\nusleep_range(1000, 4000);\r\nr = i2c_master_recv(client, buf, ST_NCI_I2C_MIN_SIZE);\r\n}\r\nif (r != ST_NCI_I2C_MIN_SIZE)\r\nreturn -EREMOTEIO;\r\nlen = be16_to_cpu(*(__be16 *) (buf + 2));\r\nif (len > ST_NCI_I2C_MAX_SIZE) {\r\nnfc_err(&client->dev, "invalid frame len\n");\r\nreturn -EBADMSG;\r\n}\r\n*skb = alloc_skb(ST_NCI_I2C_MIN_SIZE + len, GFP_KERNEL);\r\nif (*skb == NULL)\r\nreturn -ENOMEM;\r\nskb_reserve(*skb, ST_NCI_I2C_MIN_SIZE);\r\nskb_put(*skb, ST_NCI_I2C_MIN_SIZE);\r\nmemcpy((*skb)->data, buf, ST_NCI_I2C_MIN_SIZE);\r\nif (!len)\r\nreturn 0;\r\nr = i2c_master_recv(client, buf, len);\r\nif (r != len) {\r\nkfree_skb(*skb);\r\nreturn -EREMOTEIO;\r\n}\r\nskb_put(*skb, len);\r\nmemcpy((*skb)->data + ST_NCI_I2C_MIN_SIZE, buf, len);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t st_nci_irq_thread_fn(int irq, void *phy_id)\r\n{\r\nstruct st_nci_i2c_phy *phy = phy_id;\r\nstruct i2c_client *client;\r\nstruct sk_buff *skb = NULL;\r\nint r;\r\nif (!phy || !phy->ndlc || irq != phy->i2c_dev->irq) {\r\nWARN_ON_ONCE(1);\r\nreturn IRQ_NONE;\r\n}\r\nclient = phy->i2c_dev;\r\ndev_dbg(&client->dev, "IRQ\n");\r\nif (phy->ndlc->hard_fault)\r\nreturn IRQ_HANDLED;\r\nif (!phy->ndlc->powered) {\r\nst_nci_i2c_disable(phy);\r\nreturn IRQ_HANDLED;\r\n}\r\nr = st_nci_i2c_read(phy, &skb);\r\nif (r == -EREMOTEIO || r == -ENOMEM || r == -EBADMSG)\r\nreturn IRQ_HANDLED;\r\nndlc_recv(phy->ndlc, skb);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int st_nci_i2c_acpi_request_resources(struct i2c_client *client)\r\n{\r\nstruct st_nci_i2c_phy *phy = i2c_get_clientdata(client);\r\nstruct gpio_desc *gpiod_reset;\r\nstruct device *dev = &client->dev;\r\nu8 tmp;\r\ngpiod_reset = devm_gpiod_get_index(dev, ST_NCI_GPIO_NAME_RESET, 1,\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(gpiod_reset)) {\r\nnfc_err(dev, "Unable to get RESET GPIO\n");\r\nreturn -ENODEV;\r\n}\r\nphy->gpio_reset = desc_to_gpio(gpiod_reset);\r\nphy->irq_polarity = irq_get_trigger_type(client->irq);\r\nphy->se_status.is_ese_present = false;\r\nphy->se_status.is_uicc_present = false;\r\nif (device_property_present(dev, "ese-present")) {\r\ndevice_property_read_u8(dev, "ese-present", &tmp);\r\nphy->se_status.is_ese_present = tmp;\r\n}\r\nif (device_property_present(dev, "uicc-present")) {\r\ndevice_property_read_u8(dev, "uicc-present", &tmp);\r\nphy->se_status.is_uicc_present = tmp;\r\n}\r\nreturn 0;\r\n}\r\nstatic int st_nci_i2c_of_request_resources(struct i2c_client *client)\r\n{\r\nstruct st_nci_i2c_phy *phy = i2c_get_clientdata(client);\r\nstruct device_node *pp;\r\nint gpio;\r\nint r;\r\npp = client->dev.of_node;\r\nif (!pp)\r\nreturn -ENODEV;\r\ngpio = of_get_named_gpio(pp, "reset-gpios", 0);\r\nif (gpio < 0) {\r\nnfc_err(&client->dev,\r\n"Failed to retrieve reset-gpios from device tree\n");\r\nreturn gpio;\r\n}\r\nr = devm_gpio_request_one(&client->dev, gpio,\r\nGPIOF_OUT_INIT_HIGH, ST_NCI_GPIO_NAME_RESET);\r\nif (r) {\r\nnfc_err(&client->dev, "Failed to request reset pin\n");\r\nreturn r;\r\n}\r\nphy->gpio_reset = gpio;\r\nphy->irq_polarity = irq_get_trigger_type(client->irq);\r\nphy->se_status.is_ese_present =\r\nof_property_read_bool(pp, "ese-present");\r\nphy->se_status.is_uicc_present =\r\nof_property_read_bool(pp, "uicc-present");\r\nreturn 0;\r\n}\r\nstatic int st_nci_i2c_request_resources(struct i2c_client *client)\r\n{\r\nstruct st_nci_nfc_platform_data *pdata;\r\nstruct st_nci_i2c_phy *phy = i2c_get_clientdata(client);\r\nint r;\r\npdata = client->dev.platform_data;\r\nif (pdata == NULL) {\r\nnfc_err(&client->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nphy->gpio_reset = pdata->gpio_reset;\r\nphy->irq_polarity = pdata->irq_polarity;\r\nr = devm_gpio_request_one(&client->dev,\r\nphy->gpio_reset, GPIOF_OUT_INIT_HIGH,\r\nST_NCI_GPIO_NAME_RESET);\r\nif (r) {\r\npr_err("%s : reset gpio_request failed\n", __FILE__);\r\nreturn r;\r\n}\r\nphy->se_status.is_ese_present = pdata->is_ese_present;\r\nphy->se_status.is_uicc_present = pdata->is_uicc_present;\r\nreturn 0;\r\n}\r\nstatic int st_nci_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct st_nci_i2c_phy *phy;\r\nstruct st_nci_nfc_platform_data *pdata;\r\nint r;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\ndev_dbg(&client->dev, "IRQ: %d\n", client->irq);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nnfc_err(&client->dev, "Need I2C_FUNC_I2C\n");\r\nreturn -ENODEV;\r\n}\r\nphy = devm_kzalloc(&client->dev, sizeof(struct st_nci_i2c_phy),\r\nGFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\nphy->i2c_dev = client;\r\ni2c_set_clientdata(client, phy);\r\npdata = client->dev.platform_data;\r\nif (!pdata && client->dev.of_node) {\r\nr = st_nci_i2c_of_request_resources(client);\r\nif (r) {\r\nnfc_err(&client->dev, "No platform data\n");\r\nreturn r;\r\n}\r\n} else if (pdata) {\r\nr = st_nci_i2c_request_resources(client);\r\nif (r) {\r\nnfc_err(&client->dev,\r\n"Cannot get platform resources\n");\r\nreturn r;\r\n}\r\n} else if (ACPI_HANDLE(&client->dev)) {\r\nr = st_nci_i2c_acpi_request_resources(client);\r\nif (r) {\r\nnfc_err(&client->dev, "Cannot get ACPI data\n");\r\nreturn r;\r\n}\r\n} else {\r\nnfc_err(&client->dev,\r\n"st_nci platform resources not available\n");\r\nreturn -ENODEV;\r\n}\r\nr = ndlc_probe(phy, &i2c_phy_ops, &client->dev,\r\nST_NCI_FRAME_HEADROOM, ST_NCI_FRAME_TAILROOM,\r\n&phy->ndlc, &phy->se_status);\r\nif (r < 0) {\r\nnfc_err(&client->dev, "Unable to register ndlc layer\n");\r\nreturn r;\r\n}\r\nphy->irq_active = true;\r\nr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\r\nst_nci_irq_thread_fn,\r\nphy->irq_polarity | IRQF_ONESHOT,\r\nST_NCI_DRIVER_NAME, phy);\r\nif (r < 0)\r\nnfc_err(&client->dev, "Unable to register IRQ handler\n");\r\nreturn r;\r\n}\r\nstatic int st_nci_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct st_nci_i2c_phy *phy = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nndlc_remove(phy->ndlc);\r\nreturn 0;\r\n}
