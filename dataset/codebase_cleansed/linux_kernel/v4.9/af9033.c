static int af9033_wr_regs(struct af9033_dev *dev, u32 reg, const u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = dev->client->addr,\r\n.flags = 0,\r\n.len = 3 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (3 + len > sizeof(buf)) {\r\ndev_warn(&dev->client->dev,\r\n"i2c wr reg=%04x: len=%d is too big!\n",\r\nreg, len);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = (reg >> 16) & 0xff;\r\nbuf[1] = (reg >> 8) & 0xff;\r\nbuf[2] = (reg >> 0) & 0xff;\r\nmemcpy(&buf[3], val, len);\r\nret = i2c_transfer(dev->client->adapter, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&dev->client->dev, "i2c wr failed=%d reg=%06x len=%d\n",\r\nret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9033_rd_regs(struct af9033_dev *dev, u32 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[3] = { (reg >> 16) & 0xff, (reg >> 8) & 0xff,\r\n(reg >> 0) & 0xff };\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = dev->client->addr,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf\r\n}, {\r\n.addr = dev->client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val\r\n}\r\n};\r\nret = i2c_transfer(dev->client->adapter, msg, 2);\r\nif (ret == 2) {\r\nret = 0;\r\n} else {\r\ndev_warn(&dev->client->dev, "i2c rd failed=%d reg=%06x len=%d\n",\r\nret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int af9033_wr_reg(struct af9033_dev *dev, u32 reg, u8 val)\r\n{\r\nreturn af9033_wr_regs(dev, reg, &val, 1);\r\n}\r\nstatic int af9033_rd_reg(struct af9033_dev *dev, u32 reg, u8 *val)\r\n{\r\nreturn af9033_rd_regs(dev, reg, val, 1);\r\n}\r\nstatic int af9033_wr_reg_mask(struct af9033_dev *dev, u32 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = af9033_rd_regs(dev, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn af9033_wr_regs(dev, reg, &val, 1);\r\n}\r\nstatic int af9033_rd_reg_mask(struct af9033_dev *dev, u32 reg, u8 *val,\r\nu8 mask)\r\n{\r\nint ret, i;\r\nu8 tmp;\r\nret = af9033_rd_regs(dev, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\ntmp &= mask;\r\nfor (i = 0; i < 8; i++) {\r\nif ((mask >> i) & 0x01)\r\nbreak;\r\n}\r\n*val = tmp >> i;\r\nreturn 0;\r\n}\r\nstatic int af9033_wr_reg_val_tab(struct af9033_dev *dev,\r\nconst struct reg_val *tab, int tab_len)\r\n{\r\n#define MAX_TAB_LEN 212\r\nint ret, i, j;\r\nu8 buf[1 + MAX_TAB_LEN];\r\ndev_dbg(&dev->client->dev, "tab_len=%d\n", tab_len);\r\nif (tab_len > sizeof(buf)) {\r\ndev_warn(&dev->client->dev, "tab len %d is too big\n", tab_len);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0, j = 0; i < tab_len; i++) {\r\nbuf[j] = tab[i].val;\r\nif (i == tab_len - 1 || tab[i].reg != tab[i + 1].reg - 1) {\r\nret = af9033_wr_regs(dev, tab[i].reg - j, buf, j + 1);\r\nif (ret < 0)\r\ngoto err;\r\nj = 0;\r\n} else {\r\nj++;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic u32 af9033_div(struct af9033_dev *dev, u32 a, u32 b, u32 x)\r\n{\r\nu32 r = 0, c = 0, i;\r\ndev_dbg(&dev->client->dev, "a=%d b=%d x=%d\n", a, b, x);\r\nif (a > b) {\r\nc = a / b;\r\na = a - c * b;\r\n}\r\nfor (i = 0; i < x; i++) {\r\nif (a >= b) {\r\nr += 1;\r\na -= b;\r\n}\r\na <<= 1;\r\nr <<= 1;\r\n}\r\nr = (c << (u32)x) + r;\r\ndev_dbg(&dev->client->dev, "a=%d b=%d x=%d r=%d r=%x\n", a, b, x, r, r);\r\nreturn r;\r\n}\r\nstatic int af9033_init(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, len;\r\nconst struct reg_val *init;\r\nu8 buf[4];\r\nu32 adc_cw, clock_cw;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x80fb24, 0x00, 0x08 },\r\n{ 0x80004c, 0x00, 0xff },\r\n{ 0x00f641, dev->cfg.tuner, 0xff },\r\n{ 0x80f5ca, 0x01, 0x01 },\r\n{ 0x80f715, 0x01, 0x01 },\r\n{ 0x00f41f, 0x04, 0x04 },\r\n{ 0x00f41a, 0x01, 0x01 },\r\n{ 0x80f731, 0x00, 0x01 },\r\n{ 0x00d91e, 0x00, 0x01 },\r\n{ 0x00d919, 0x00, 0x01 },\r\n{ 0x80f732, 0x00, 0x01 },\r\n{ 0x00d91f, 0x00, 0x01 },\r\n{ 0x00d91a, 0x00, 0x01 },\r\n{ 0x80f730, 0x00, 0x01 },\r\n{ 0x80f778, 0x00, 0xff },\r\n{ 0x80f73c, 0x01, 0x01 },\r\n{ 0x80f776, 0x00, 0x01 },\r\n{ 0x00d8fd, 0x01, 0xff },\r\n{ 0x00d830, 0x01, 0xff },\r\n{ 0x00d831, 0x00, 0xff },\r\n{ 0x00d832, 0x00, 0xff },\r\n{ 0x80f985, dev->ts_mode_serial, 0x01 },\r\n{ 0x80f986, dev->ts_mode_parallel, 0x01 },\r\n{ 0x00d827, 0x00, 0xff },\r\n{ 0x00d829, 0x00, 0xff },\r\n{ 0x800045, dev->cfg.adc_multiplier, 0xff },\r\n};\r\nclock_cw = af9033_div(dev, dev->cfg.clock, 1000000ul, 19ul);\r\nbuf[0] = (clock_cw >> 0) & 0xff;\r\nbuf[1] = (clock_cw >> 8) & 0xff;\r\nbuf[2] = (clock_cw >> 16) & 0xff;\r\nbuf[3] = (clock_cw >> 24) & 0xff;\r\ndev_dbg(&dev->client->dev, "clock=%d clock_cw=%08x\n",\r\ndev->cfg.clock, clock_cw);\r\nret = af9033_wr_regs(dev, 0x800025, buf, 4);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(clock_adc_lut); i++) {\r\nif (clock_adc_lut[i].clock == dev->cfg.clock)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(clock_adc_lut)) {\r\ndev_err(&dev->client->dev,\r\n"Couldn't find ADC config for clock=%d\n",\r\ndev->cfg.clock);\r\ngoto err;\r\n}\r\nadc_cw = af9033_div(dev, clock_adc_lut[i].adc, 1000000ul, 19ul);\r\nbuf[0] = (adc_cw >> 0) & 0xff;\r\nbuf[1] = (adc_cw >> 8) & 0xff;\r\nbuf[2] = (adc_cw >> 16) & 0xff;\r\ndev_dbg(&dev->client->dev, "adc=%d adc_cw=%06x\n",\r\nclock_adc_lut[i].adc, adc_cw);\r\nret = af9033_wr_regs(dev, 0x80f1cd, buf, 3);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = af9033_wr_reg_mask(dev, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (dev->cfg.dyn0_clk) {\r\nret = af9033_wr_reg(dev, 0x80fba8, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (dev->cfg.ts_mode == AF9033_TS_MODE_USB) {\r\nret = af9033_wr_reg_mask(dev, 0x80f9a5, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(dev, 0x80f9b5, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n} else {\r\nret = af9033_wr_reg_mask(dev, 0x80f990, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(dev, 0x80f9b5, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\ndev_dbg(&dev->client->dev, "load ofsm settings\n");\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\nlen = ARRAY_SIZE(ofsm_init_it9135_v1);\r\ninit = ofsm_init_it9135_v1;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nlen = ARRAY_SIZE(ofsm_init_it9135_v2);\r\ninit = ofsm_init_it9135_v2;\r\nbreak;\r\ndefault:\r\nlen = ARRAY_SIZE(ofsm_init);\r\ninit = ofsm_init;\r\nbreak;\r\n}\r\nret = af9033_wr_reg_val_tab(dev, init, len);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&dev->client->dev, "load tuner specific settings\n");\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_TUA9001:\r\nlen = ARRAY_SIZE(tuner_init_tua9001);\r\ninit = tuner_init_tua9001;\r\nbreak;\r\ncase AF9033_TUNER_FC0011:\r\nlen = ARRAY_SIZE(tuner_init_fc0011);\r\ninit = tuner_init_fc0011;\r\nbreak;\r\ncase AF9033_TUNER_MXL5007T:\r\nlen = ARRAY_SIZE(tuner_init_mxl5007t);\r\ninit = tuner_init_mxl5007t;\r\nbreak;\r\ncase AF9033_TUNER_TDA18218:\r\nlen = ARRAY_SIZE(tuner_init_tda18218);\r\ninit = tuner_init_tda18218;\r\nbreak;\r\ncase AF9033_TUNER_FC2580:\r\nlen = ARRAY_SIZE(tuner_init_fc2580);\r\ninit = tuner_init_fc2580;\r\nbreak;\r\ncase AF9033_TUNER_FC0012:\r\nlen = ARRAY_SIZE(tuner_init_fc0012);\r\ninit = tuner_init_fc0012;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_38:\r\nlen = ARRAY_SIZE(tuner_init_it9135_38);\r\ninit = tuner_init_it9135_38;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_51:\r\nlen = ARRAY_SIZE(tuner_init_it9135_51);\r\ninit = tuner_init_it9135_51;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_52:\r\nlen = ARRAY_SIZE(tuner_init_it9135_52);\r\ninit = tuner_init_it9135_52;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_60:\r\nlen = ARRAY_SIZE(tuner_init_it9135_60);\r\ninit = tuner_init_it9135_60;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_61:\r\nlen = ARRAY_SIZE(tuner_init_it9135_61);\r\ninit = tuner_init_it9135_61;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_62:\r\nlen = ARRAY_SIZE(tuner_init_it9135_62);\r\ninit = tuner_init_it9135_62;\r\nbreak;\r\ndefault:\r\ndev_dbg(&dev->client->dev, "unsupported tuner ID=%d\n",\r\ndev->cfg.tuner);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = af9033_wr_reg_val_tab(dev, init, len);\r\nif (ret < 0)\r\ngoto err;\r\nif (dev->cfg.ts_mode == AF9033_TS_MODE_SERIAL) {\r\nret = af9033_wr_reg_mask(dev, 0x00d91c, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(dev, 0x00d917, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(dev, 0x00d916, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nret = af9033_wr_reg(dev, 0x800000, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\ndev->bandwidth_hz = 0;\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.len = 1;\r\nc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.len = 1;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nint ret, i;\r\nu8 tmp;\r\nret = af9033_wr_reg(dev, 0x80004c, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(dev, 0x800000, 0);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 100, tmp = 1; i && tmp; i--) {\r\nret = af9033_rd_reg(dev, 0x80004c, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(200, 10000);\r\n}\r\ndev_dbg(&dev->client->dev, "loop=%d\n", i);\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nret = af9033_wr_reg_mask(dev, 0x80fb24, 0x08, 0x08);\r\nif (ret < 0)\r\ngoto err;\r\nif (dev->cfg.ts_mode == AF9033_TS_MODE_SERIAL) {\r\nret = af9033_wr_reg_mask(dev, 0x00d917, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(dev, 0x00d916, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 2000;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int af9033_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, spec_inv, sampling_freq;\r\nu8 tmp, buf[3], bandwidth_reg_val;\r\nu32 if_frequency, freq_cw, adc_freq;\r\ndev_dbg(&dev->client->dev, "frequency=%d bandwidth_hz=%d\n",\r\nc->frequency, c->bandwidth_hz);\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nbandwidth_reg_val = 0x00;\r\nbreak;\r\ncase 7000000:\r\nbandwidth_reg_val = 0x01;\r\nbreak;\r\ncase 8000000:\r\nbandwidth_reg_val = 0x02;\r\nbreak;\r\ndefault:\r\ndev_dbg(&dev->client->dev, "invalid bandwidth_hz\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (c->bandwidth_hz != dev->bandwidth_hz) {\r\nfor (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {\r\nif (coeff_lut[i].clock == dev->cfg.clock &&\r\ncoeff_lut[i].bandwidth_hz == c->bandwidth_hz) {\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(coeff_lut)) {\r\ndev_err(&dev->client->dev,\r\n"Couldn't find LUT config for clock=%d\n",\r\ndev->cfg.clock);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = af9033_wr_regs(dev, 0x800001,\r\ncoeff_lut[i].val, sizeof(coeff_lut[i].val));\r\n}\r\nif (c->bandwidth_hz != dev->bandwidth_hz) {\r\nspec_inv = dev->cfg.spec_inv ? -1 : 1;\r\nfor (i = 0; i < ARRAY_SIZE(clock_adc_lut); i++) {\r\nif (clock_adc_lut[i].clock == dev->cfg.clock)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(clock_adc_lut)) {\r\ndev_err(&dev->client->dev,\r\n"Couldn't find ADC clock for clock=%d\n",\r\ndev->cfg.clock);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nadc_freq = clock_adc_lut[i].adc;\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nfe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nelse\r\nif_frequency = 0;\r\nsampling_freq = if_frequency;\r\nwhile (sampling_freq > (adc_freq / 2))\r\nsampling_freq -= adc_freq;\r\nif (sampling_freq >= 0)\r\nspec_inv *= -1;\r\nelse\r\nsampling_freq *= -1;\r\nfreq_cw = af9033_div(dev, sampling_freq, adc_freq, 23ul);\r\nif (spec_inv == -1)\r\nfreq_cw = 0x800000 - freq_cw;\r\nif (dev->cfg.adc_multiplier == AF9033_ADC_MULTIPLIER_2X)\r\nfreq_cw /= 2;\r\nbuf[0] = (freq_cw >> 0) & 0xff;\r\nbuf[1] = (freq_cw >> 8) & 0xff;\r\nbuf[2] = (freq_cw >> 16) & 0x7f;\r\nif (if_frequency == 0)\r\nbuf[2] = 0;\r\nret = af9033_wr_regs(dev, 0x800029, buf, 3);\r\nif (ret < 0)\r\ngoto err;\r\ndev->bandwidth_hz = c->bandwidth_hz;\r\n}\r\nret = af9033_wr_reg_mask(dev, 0x80f904, bandwidth_reg_val, 0x03);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(dev, 0x800040, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(dev, 0x800047, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg_mask(dev, 0x80f999, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nif (c->frequency <= 230000000)\r\ntmp = 0x00;\r\nelse\r\ntmp = 0x01;\r\nret = af9033_wr_reg(dev, 0x80004b, tmp);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(dev, 0x800000, 0x00);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[8];\r\ndev_dbg(&dev->client->dev, "\n");\r\nret = af9033_rd_regs(dev, 0x80f900, buf, sizeof(buf));\r\nif (ret < 0)\r\ngoto err;\r\nswitch ((buf[0] >> 0) & 3) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 0) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 0) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[3] >> 0) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[4] >> 0) & 3) {\r\ncase 0:\r\nc->bandwidth_hz = 6000000;\r\nbreak;\r\ncase 1:\r\nc->bandwidth_hz = 7000000;\r\nbreak;\r\ncase 2:\r\nc->bandwidth_hz = 8000000;\r\nbreak;\r\n}\r\nswitch ((buf[6] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\ncase 5:\r\nc->code_rate_HP = FEC_NONE;\r\nbreak;\r\n}\r\nswitch ((buf[7] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\ncase 5:\r\nc->code_rate_LP = FEC_NONE;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, tmp = 0;\r\nu8 u8tmp, buf[7];\r\ndev_dbg(&dev->client->dev, "\n");\r\n*status = 0;\r\nret = af9033_rd_reg(dev, 0x800047, &u8tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (u8tmp == 0x01)\r\n*status |= FE_HAS_SIGNAL;\r\nif (u8tmp != 0x02) {\r\nret = af9033_rd_reg_mask(dev, 0x80f5a9, &u8tmp, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nif (u8tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\nret = af9033_rd_reg_mask(dev, 0x80f999, &u8tmp, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nif (u8tmp)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\n}\r\ndev->fe_status = *status;\r\nif (dev->fe_status & FE_HAS_SIGNAL) {\r\nif (dev->is_af9035) {\r\nret = af9033_rd_reg(dev, 0x80004a, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ntmp = -u8tmp * 1000;\r\n} else {\r\nret = af9033_rd_reg(dev, 0x8000f7, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ntmp = (u8tmp - 100) * 1000;\r\n}\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->strength.stat[0].svalue = tmp;\r\n} else {\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_VITERBI) {\r\nu32 snr_val, snr_lut_size;\r\nconst struct val_snr *snr_lut = NULL;\r\nret = af9033_rd_regs(dev, 0x80002c, buf, 3);\r\nif (ret)\r\ngoto err;\r\nsnr_val = (buf[2] << 16) | (buf[1] << 8) | (buf[0] << 0);\r\nret = af9033_rd_reg(dev, 0x80f78b, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (u8tmp)\r\nsnr_val /= u8tmp;\r\nret = af9033_rd_reg(dev, 0x80f900, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nswitch ((u8tmp >> 0) & 3) {\r\ncase 0:\r\nsnr_val *= 4;\r\nbreak;\r\ncase 1:\r\nsnr_val *= 1;\r\nbreak;\r\ncase 2:\r\nsnr_val *= 2;\r\nbreak;\r\ndefault:\r\nsnr_val *= 0;\r\nbreak;\r\n}\r\nret = af9033_rd_reg(dev, 0x80f903, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nswitch ((u8tmp >> 0) & 3) {\r\ncase 0:\r\nsnr_lut_size = ARRAY_SIZE(qpsk_snr_lut);\r\nsnr_lut = qpsk_snr_lut;\r\nbreak;\r\ncase 1:\r\nsnr_lut_size = ARRAY_SIZE(qam16_snr_lut);\r\nsnr_lut = qam16_snr_lut;\r\nbreak;\r\ncase 2:\r\nsnr_lut_size = ARRAY_SIZE(qam64_snr_lut);\r\nsnr_lut = qam64_snr_lut;\r\nbreak;\r\ndefault:\r\nsnr_lut_size = 0;\r\ntmp = 0;\r\nbreak;\r\n}\r\nfor (i = 0; i < snr_lut_size; i++) {\r\ntmp = snr_lut[i].snr * 1000;\r\nif (snr_val < snr_lut[i].val)\r\nbreak;\r\n}\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = tmp;\r\n} else {\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_LOCK) {\r\nu16 abort_packet_count, rsd_packet_count;\r\nu32 rsd_bit_err_count;\r\nret = af9033_rd_regs(dev, 0x800032, buf, 7);\r\nif (ret)\r\ngoto err;\r\nabort_packet_count = (buf[1] << 8) | (buf[0] << 0);\r\nrsd_bit_err_count = (buf[4] << 16) | (buf[3] << 8) | buf[2];\r\nrsd_packet_count = (buf[6] << 8) | (buf[5] << 0);\r\ndev->error_block_count += abort_packet_count;\r\ndev->total_block_count += rsd_packet_count;\r\ndev->post_bit_error += rsd_bit_err_count;\r\ndev->post_bit_count += rsd_packet_count * 204 * 8;\r\nc->block_count.len = 1;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].uvalue = dev->total_block_count;\r\nc->block_error.len = 1;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue = dev->error_block_count;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\r\nint ret;\r\nu8 u8tmp;\r\nif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL) {\r\nif (dev->is_af9035) {\r\n*snr = div_s64(c->cnr.stat[0].svalue, 100);\r\n} else {\r\n*snr = div_s64(c->cnr.stat[0].svalue, 1000);\r\nret = af9033_rd_reg(dev, 0x80f903, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nswitch ((u8tmp >> 0) & 3) {\r\ncase 0:\r\n*snr = *snr * 0xffff / 23;\r\nbreak;\r\ncase 1:\r\n*snr = *snr * 0xffff / 26;\r\nbreak;\r\ncase 2:\r\n*snr = *snr * 0xffff / 32;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\n}\r\n} else {\r\n*snr = 0;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\r\nint ret, tmp, power_real;\r\nu8 u8tmp, gain_offset, buf[7];\r\nif (dev->is_af9035) {\r\nret = af9033_rd_reg(dev, 0x800048, &u8tmp);\r\nif (ret < 0)\r\ngoto err;\r\n*strength = u8tmp * 0xffff / 100;\r\n} else {\r\nret = af9033_rd_reg(dev, 0x8000f7, &u8tmp);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_rd_regs(dev, 0x80f900, buf, 7);\r\nif (ret < 0)\r\ngoto err;\r\nif (c->frequency <= 300000000)\r\ngain_offset = 7;\r\nelse\r\ngain_offset = 4;\r\npower_real = (u8tmp - 100 - gain_offset) -\r\npower_reference[((buf[3] >> 0) & 3)][((buf[6] >> 0) & 7)];\r\nif (power_real < -15)\r\ntmp = 0;\r\nelse if ((power_real >= -15) && (power_real < 0))\r\ntmp = (2 * (power_real + 15)) / 3;\r\nelse if ((power_real >= 0) && (power_real < 20))\r\ntmp = 4 * power_real + 10;\r\nelse if ((power_real >= 20) && (power_real < 35))\r\ntmp = (2 * (power_real - 20)) / 3 + 90;\r\nelse\r\ntmp = 100;\r\n*strength = tmp * 0xffff / 100;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\n*ber = (dev->post_bit_error - dev->post_bit_error_prev);\r\ndev->post_bit_error_prev = dev->post_bit_error;\r\nreturn 0;\r\n}\r\nstatic int af9033_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\n*ucblocks = dev->error_block_count;\r\nreturn 0;\r\n}\r\nstatic int af9033_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&dev->client->dev, "enable=%d\n", enable);\r\nret = af9033_wr_reg_mask(dev, 0x00fa04, enable, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nint ret;\r\ndev_dbg(&dev->client->dev, "onoff=%d\n", onoff);\r\nret = af9033_wr_reg_mask(dev, 0x80f993, onoff, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_pid_filter(struct dvb_frontend *fe, int index, u16 pid,\r\nint onoff)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nint ret;\r\nu8 wbuf[2] = {(pid >> 0) & 0xff, (pid >> 8) & 0xff};\r\ndev_dbg(&dev->client->dev, "index=%d pid=%04x onoff=%d\n",\r\nindex, pid, onoff);\r\nif (pid > 0x1fff)\r\nreturn 0;\r\nret = af9033_wr_regs(dev, 0x80f996, wbuf, 2);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(dev, 0x80f994, onoff);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9033_wr_reg(dev, 0x80f995, index);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct af9033_config *cfg = client->dev.platform_data;\r\nstruct af9033_dev *dev;\r\nint ret;\r\nu8 buf[8];\r\nu32 reg;\r\ndev = kzalloc(sizeof(struct af9033_dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nret = -ENOMEM;\r\ndev_err(&client->dev, "Could not allocate memory for state\n");\r\ngoto err;\r\n}\r\ndev->client = client;\r\nmemcpy(&dev->cfg, cfg, sizeof(struct af9033_config));\r\nif (dev->cfg.clock != 12000000) {\r\nret = -ENODEV;\r\ndev_err(&dev->client->dev,\r\n"unsupported clock %d Hz, only 12000000 Hz is supported currently\n",\r\ndev->cfg.clock);\r\ngoto err_kfree;\r\n}\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\ndev->is_it9135 = true;\r\nreg = 0x004bfc;\r\nbreak;\r\ndefault:\r\ndev->is_af9035 = true;\r\nreg = 0x0083e9;\r\nbreak;\r\n}\r\nret = af9033_rd_regs(dev, reg, &buf[0], 4);\r\nif (ret < 0)\r\ngoto err_kfree;\r\nret = af9033_rd_regs(dev, 0x804191, &buf[4], 4);\r\nif (ret < 0)\r\ngoto err_kfree;\r\ndev_info(&dev->client->dev,\r\n"firmware version: LINK %d.%d.%d.%d - OFDM %d.%d.%d.%d\n",\r\nbuf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6],\r\nbuf[7]);\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nbreak;\r\ndefault:\r\nret = af9033_wr_reg(dev, 0x80004c, 1);\r\nif (ret < 0)\r\ngoto err_kfree;\r\nret = af9033_wr_reg(dev, 0x800000, 0);\r\nif (ret < 0)\r\ngoto err_kfree;\r\n}\r\nswitch (dev->cfg.ts_mode) {\r\ncase AF9033_TS_MODE_PARALLEL:\r\ndev->ts_mode_parallel = true;\r\nbreak;\r\ncase AF9033_TS_MODE_SERIAL:\r\ndev->ts_mode_serial = true;\r\nbreak;\r\ncase AF9033_TS_MODE_USB:\r\ndefault:\r\nbreak;\r\n}\r\nmemcpy(&dev->fe.ops, &af9033_ops, sizeof(struct dvb_frontend_ops));\r\ndev->fe.demodulator_priv = dev;\r\n*cfg->fe = &dev->fe;\r\nif (cfg->ops) {\r\ncfg->ops->pid_filter = af9033_pid_filter;\r\ncfg->ops->pid_filter_ctrl = af9033_pid_filter_ctrl;\r\n}\r\ni2c_set_clientdata(client, dev);\r\ndev_info(&dev->client->dev, "Afatech AF9033 successfully attached\n");\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_remove(struct i2c_client *client)\r\n{\r\nstruct af9033_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&dev->client->dev, "\n");\r\ndev->fe.ops.release = NULL;\r\ndev->fe.demodulator_priv = NULL;\r\nkfree(dev);\r\nreturn 0;\r\n}
