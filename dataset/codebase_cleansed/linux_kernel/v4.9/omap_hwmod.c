static struct omap_hwmod_ocp_if *_fetch_next_ocp_if(struct list_head **p,\r\nint *i)\r\n{\r\nstruct omap_hwmod_ocp_if *oi;\r\noi = list_entry(*p, struct omap_hwmod_link, node)->ocp_if;\r\n*p = (*p)->next;\r\n*i = *i + 1;\r\nreturn oi;\r\n}\r\nstatic int _update_sysc_cache(struct omap_hwmod *oh)\r\n{\r\nif (!oh->class->sysc) {\r\nWARN(1, "omap_hwmod: %s: cannot read OCP_SYSCONFIG: not defined on hwmod's class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\noh->_sysc_cache = omap_hwmod_read(oh, oh->class->sysc->sysc_offs);\r\nif (!(oh->class->sysc->sysc_flags & SYSC_NO_CACHE))\r\noh->_int_flags |= _HWMOD_SYSCONFIG_LOADED;\r\nreturn 0;\r\n}\r\nstatic void _write_sysconfig(u32 v, struct omap_hwmod *oh)\r\n{\r\nif (!oh->class->sysc) {\r\nWARN(1, "omap_hwmod: %s: cannot write OCP_SYSCONFIG: not defined on hwmod's class\n", oh->name);\r\nreturn;\r\n}\r\noh->_sysc_cache = v;\r\nif (oh->class->unlock)\r\noh->class->unlock(oh);\r\nomap_hwmod_write(v, oh, oh->class->sysc->sysc_offs);\r\nif (oh->class->lock)\r\noh->class->lock(oh);\r\n}\r\nstatic int _set_master_standbymode(struct omap_hwmod *oh, u8 standbymode,\r\nu32 *v)\r\n{\r\nu32 mstandby_mask;\r\nu8 mstandby_shift;\r\nif (!oh->class->sysc ||\r\n!(oh->class->sysc->sysc_flags & SYSC_HAS_MIDLEMODE))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nmstandby_shift = oh->class->sysc->sysc_fields->midle_shift;\r\nmstandby_mask = (0x3 << mstandby_shift);\r\n*v &= ~mstandby_mask;\r\n*v |= __ffs(standbymode) << mstandby_shift;\r\nreturn 0;\r\n}\r\nstatic int _set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode, u32 *v)\r\n{\r\nu32 sidle_mask;\r\nu8 sidle_shift;\r\nif (!oh->class->sysc ||\r\n!(oh->class->sysc->sysc_flags & SYSC_HAS_SIDLEMODE))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nsidle_shift = oh->class->sysc->sysc_fields->sidle_shift;\r\nsidle_mask = (0x3 << sidle_shift);\r\n*v &= ~sidle_mask;\r\n*v |= __ffs(idlemode) << sidle_shift;\r\nreturn 0;\r\n}\r\nstatic int _set_clockactivity(struct omap_hwmod *oh, u8 clockact, u32 *v)\r\n{\r\nu32 clkact_mask;\r\nu8 clkact_shift;\r\nif (!oh->class->sysc ||\r\n!(oh->class->sysc->sysc_flags & SYSC_HAS_CLOCKACTIVITY))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nclkact_shift = oh->class->sysc->sysc_fields->clkact_shift;\r\nclkact_mask = (0x3 << clkact_shift);\r\n*v &= ~clkact_mask;\r\n*v |= clockact << clkact_shift;\r\nreturn 0;\r\n}\r\nstatic int _set_softreset(struct omap_hwmod *oh, u32 *v)\r\n{\r\nu32 softrst_mask;\r\nif (!oh->class->sysc ||\r\n!(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nsoftrst_mask = (0x1 << oh->class->sysc->sysc_fields->srst_shift);\r\n*v |= softrst_mask;\r\nreturn 0;\r\n}\r\nstatic int _clear_softreset(struct omap_hwmod *oh, u32 *v)\r\n{\r\nu32 softrst_mask;\r\nif (!oh->class->sysc ||\r\n!(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1,\r\n"omap_hwmod: %s: sysc_fields absent for sysconfig class\n",\r\noh->name);\r\nreturn -EINVAL;\r\n}\r\nsoftrst_mask = (0x1 << oh->class->sysc->sysc_fields->srst_shift);\r\n*v &= ~softrst_mask;\r\nreturn 0;\r\n}\r\nstatic int _wait_softreset_complete(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_class_sysconfig *sysc;\r\nu32 softrst_mask;\r\nint c = 0;\r\nsysc = oh->class->sysc;\r\nif (sysc->sysc_flags & SYSS_HAS_RESET_STATUS)\r\nomap_test_timeout((omap_hwmod_read(oh, sysc->syss_offs)\r\n& SYSS_RESETDONE_MASK),\r\nMAX_MODULE_SOFTRESET_WAIT, c);\r\nelse if (sysc->sysc_flags & SYSC_HAS_RESET_STATUS) {\r\nsoftrst_mask = (0x1 << sysc->sysc_fields->srst_shift);\r\nomap_test_timeout(!(omap_hwmod_read(oh, sysc->sysc_offs)\r\n& softrst_mask),\r\nMAX_MODULE_SOFTRESET_WAIT, c);\r\n}\r\nreturn c;\r\n}\r\nstatic int _set_dmadisable(struct omap_hwmod *oh)\r\n{\r\nu32 v;\r\nu32 dmadisable_mask;\r\nif (!oh->class->sysc ||\r\n!(oh->class->sysc->sysc_flags & SYSC_HAS_DMADISABLE))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nif (oh->_state != _HWMOD_STATE_ENABLED) {\r\npr_warn("omap_hwmod: %s: dma can be disabled only from enabled state\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\npr_debug("omap_hwmod: %s: setting DMADISABLE\n", oh->name);\r\nv = oh->_sysc_cache;\r\ndmadisable_mask =\r\n(0x1 << oh->class->sysc->sysc_fields->dmadisable_shift);\r\nv |= dmadisable_mask;\r\n_write_sysconfig(v, oh);\r\nreturn 0;\r\n}\r\nstatic int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,\r\nu32 *v)\r\n{\r\nu32 autoidle_mask;\r\nu8 autoidle_shift;\r\nif (!oh->class->sysc ||\r\n!(oh->class->sysc->sysc_flags & SYSC_HAS_AUTOIDLE))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nautoidle_shift = oh->class->sysc->sysc_fields->autoidle_shift;\r\nautoidle_mask = (0x1 << autoidle_shift);\r\n*v &= ~autoidle_mask;\r\n*v |= autoidle << autoidle_shift;\r\nreturn 0;\r\n}\r\nstatic void _set_idle_ioring_wakeup(struct omap_hwmod *oh, bool set_wake)\r\n{\r\nstruct omap_device_pad *pad;\r\nbool change = false;\r\nu16 prev_idle;\r\nint j;\r\nif (!oh->mux || !oh->mux->enabled)\r\nreturn;\r\nfor (j = 0; j < oh->mux->nr_pads_dynamic; j++) {\r\npad = oh->mux->pads_dynamic[j];\r\nif (!(pad->flags & OMAP_DEVICE_PAD_WAKEUP))\r\ncontinue;\r\nprev_idle = pad->idle;\r\nif (set_wake)\r\npad->idle |= OMAP_WAKEUP_EN;\r\nelse\r\npad->idle &= ~OMAP_WAKEUP_EN;\r\nif (prev_idle != pad->idle)\r\nchange = true;\r\n}\r\nif (change && oh->_state == _HWMOD_STATE_IDLE)\r\nomap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);\r\n}\r\nstatic int _enable_wakeup(struct omap_hwmod *oh, u32 *v)\r\n{\r\nif (!oh->class->sysc ||\r\n!((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||\r\n(oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||\r\n(oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nif (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)\r\n*v |= 0x1 << oh->class->sysc->sysc_fields->enwkup_shift;\r\nif (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)\r\n_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART_WKUP, v);\r\nif (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)\r\n_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART_WKUP, v);\r\nreturn 0;\r\n}\r\nstatic int _disable_wakeup(struct omap_hwmod *oh, u32 *v)\r\n{\r\nif (!oh->class->sysc ||\r\n!((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||\r\n(oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||\r\n(oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)))\r\nreturn -EINVAL;\r\nif (!oh->class->sysc->sysc_fields) {\r\nWARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nif (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)\r\n*v &= ~(0x1 << oh->class->sysc->sysc_fields->enwkup_shift);\r\nif (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)\r\n_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART, v);\r\nif (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)\r\n_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART, v);\r\nreturn 0;\r\n}\r\nstatic struct clockdomain *_get_clkdm(struct omap_hwmod *oh)\r\n{\r\nstruct clk_hw_omap *clk;\r\nif (oh->clkdm) {\r\nreturn oh->clkdm;\r\n} else if (oh->_clk) {\r\nif (__clk_get_flags(oh->_clk) & CLK_IS_BASIC)\r\nreturn NULL;\r\nclk = to_clk_hw_omap(__clk_get_hw(oh->_clk));\r\nreturn clk->clkdm;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)\r\n{\r\nstruct clockdomain *clkdm, *init_clkdm;\r\nclkdm = _get_clkdm(oh);\r\ninit_clkdm = _get_clkdm(init_oh);\r\nif (!clkdm || !init_clkdm)\r\nreturn -EINVAL;\r\nif (clkdm && clkdm->flags & CLKDM_NO_AUTODEPS)\r\nreturn 0;\r\nreturn clkdm_add_sleepdep(clkdm, init_clkdm);\r\n}\r\nstatic int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)\r\n{\r\nstruct clockdomain *clkdm, *init_clkdm;\r\nclkdm = _get_clkdm(oh);\r\ninit_clkdm = _get_clkdm(init_oh);\r\nif (!clkdm || !init_clkdm)\r\nreturn -EINVAL;\r\nif (clkdm && clkdm->flags & CLKDM_NO_AUTODEPS)\r\nreturn 0;\r\nreturn clkdm_del_sleepdep(clkdm, init_clkdm);\r\n}\r\nstatic int _init_main_clk(struct omap_hwmod *oh)\r\n{\r\nint ret = 0;\r\nchar name[MOD_CLK_MAX_NAME_LEN];\r\nstruct clk *clk;\r\nif (strlen(oh->name) + 7 > MOD_CLK_MAX_NAME_LEN)\r\npr_warn("%s: warning: cropping name for %s\n", __func__,\r\noh->name);\r\nstrncpy(name, oh->name, MOD_CLK_MAX_NAME_LEN - 7);\r\nstrcat(name, "_mod_ck");\r\nclk = clk_get(NULL, name);\r\nif (!IS_ERR(clk)) {\r\noh->_clk = clk;\r\nsoc_ops.disable_direct_prcm(oh);\r\noh->main_clk = kstrdup(name, GFP_KERNEL);\r\n} else {\r\nif (!oh->main_clk)\r\nreturn 0;\r\noh->_clk = clk_get(NULL, oh->main_clk);\r\n}\r\nif (IS_ERR(oh->_clk)) {\r\npr_warn("omap_hwmod: %s: cannot clk_get main_clk %s\n",\r\noh->name, oh->main_clk);\r\nreturn -EINVAL;\r\n}\r\nclk_prepare(oh->_clk);\r\nif (!_get_clkdm(oh))\r\npr_debug("omap_hwmod: %s: missing clockdomain for %s.\n",\r\noh->name, oh->main_clk);\r\nreturn ret;\r\n}\r\nstatic int _init_interface_clks(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_ocp_if *os;\r\nstruct list_head *p;\r\nstruct clk *c;\r\nint i = 0;\r\nint ret = 0;\r\np = oh->slave_ports.next;\r\nwhile (i < oh->slaves_cnt) {\r\nos = _fetch_next_ocp_if(&p, &i);\r\nif (!os->clk)\r\ncontinue;\r\nc = clk_get(NULL, os->clk);\r\nif (IS_ERR(c)) {\r\npr_warn("omap_hwmod: %s: cannot clk_get interface_clk %s\n",\r\noh->name, os->clk);\r\nret = -EINVAL;\r\ncontinue;\r\n}\r\nos->_clk = c;\r\nclk_prepare(os->_clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int _init_opt_clks(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_opt_clk *oc;\r\nstruct clk *c;\r\nint i;\r\nint ret = 0;\r\nfor (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {\r\nc = clk_get(NULL, oc->clk);\r\nif (IS_ERR(c)) {\r\npr_warn("omap_hwmod: %s: cannot clk_get opt_clk %s\n",\r\noh->name, oc->clk);\r\nret = -EINVAL;\r\ncontinue;\r\n}\r\noc->_clk = c;\r\nclk_prepare(oc->_clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic void _enable_optional_clocks(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_opt_clk *oc;\r\nint i;\r\npr_debug("omap_hwmod: %s: enabling optional clocks\n", oh->name);\r\nfor (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)\r\nif (oc->_clk) {\r\npr_debug("omap_hwmod: enable %s:%s\n", oc->role,\r\n__clk_get_name(oc->_clk));\r\nclk_enable(oc->_clk);\r\n}\r\n}\r\nstatic void _disable_optional_clocks(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_opt_clk *oc;\r\nint i;\r\npr_debug("omap_hwmod: %s: disabling optional clocks\n", oh->name);\r\nfor (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)\r\nif (oc->_clk) {\r\npr_debug("omap_hwmod: disable %s:%s\n", oc->role,\r\n__clk_get_name(oc->_clk));\r\nclk_disable(oc->_clk);\r\n}\r\n}\r\nstatic int _enable_clocks(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_ocp_if *os;\r\nstruct list_head *p;\r\nint i = 0;\r\npr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);\r\nif (oh->_clk)\r\nclk_enable(oh->_clk);\r\np = oh->slave_ports.next;\r\nwhile (i < oh->slaves_cnt) {\r\nos = _fetch_next_ocp_if(&p, &i);\r\nif (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))\r\nclk_enable(os->_clk);\r\n}\r\nif (oh->flags & HWMOD_OPT_CLKS_NEEDED)\r\n_enable_optional_clocks(oh);\r\nreturn 0;\r\n}\r\nstatic int _disable_clocks(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_ocp_if *os;\r\nstruct list_head *p;\r\nint i = 0;\r\npr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);\r\nif (oh->_clk)\r\nclk_disable(oh->_clk);\r\np = oh->slave_ports.next;\r\nwhile (i < oh->slaves_cnt) {\r\nos = _fetch_next_ocp_if(&p, &i);\r\nif (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))\r\nclk_disable(os->_clk);\r\n}\r\nif (oh->flags & HWMOD_OPT_CLKS_NEEDED)\r\n_disable_optional_clocks(oh);\r\nreturn 0;\r\n}\r\nstatic void _omap4_enable_module(struct omap_hwmod *oh)\r\n{\r\nif (!oh->clkdm || !oh->prcm.omap4.modulemode)\r\nreturn;\r\npr_debug("omap_hwmod: %s: %s: %d\n",\r\noh->name, __func__, oh->prcm.omap4.modulemode);\r\nomap_cm_module_enable(oh->prcm.omap4.modulemode,\r\noh->clkdm->prcm_partition,\r\noh->clkdm->cm_inst, oh->prcm.omap4.clkctrl_offs);\r\n}\r\nstatic int _omap4_wait_target_disable(struct omap_hwmod *oh)\r\n{\r\nif (!oh)\r\nreturn -EINVAL;\r\nif (oh->_int_flags & _HWMOD_NO_MPU_PORT || !oh->clkdm)\r\nreturn 0;\r\nif (oh->flags & HWMOD_NO_IDLEST)\r\nreturn 0;\r\nif (!oh->prcm.omap4.clkctrl_offs &&\r\n!(oh->prcm.omap4.flags & HWMOD_OMAP4_ZERO_CLKCTRL_OFFSET))\r\nreturn 0;\r\nreturn omap_cm_wait_module_idle(oh->clkdm->prcm_partition,\r\noh->clkdm->cm_inst,\r\noh->prcm.omap4.clkctrl_offs, 0);\r\n}\r\nstatic int _count_mpu_irqs(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_irq_info *ohii;\r\nint i = 0;\r\nif (!oh || !oh->mpu_irqs)\r\nreturn 0;\r\ndo {\r\nohii = &oh->mpu_irqs[i++];\r\n} while (ohii->irq != -1);\r\nreturn i-1;\r\n}\r\nstatic int _count_sdma_reqs(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_dma_info *ohdi;\r\nint i = 0;\r\nif (!oh || !oh->sdma_reqs)\r\nreturn 0;\r\ndo {\r\nohdi = &oh->sdma_reqs[i++];\r\n} while (ohdi->dma_req != -1);\r\nreturn i-1;\r\n}\r\nstatic int _count_ocp_if_addr_spaces(struct omap_hwmod_ocp_if *os)\r\n{\r\nstruct omap_hwmod_addr_space *mem;\r\nint i = 0;\r\nif (!os || !os->addr)\r\nreturn 0;\r\ndo {\r\nmem = &os->addr[i++];\r\n} while (mem->pa_start != mem->pa_end);\r\nreturn i-1;\r\n}\r\nstatic int _get_mpu_irq_by_name(struct omap_hwmod *oh, const char *name,\r\nunsigned int *irq)\r\n{\r\nint i;\r\nbool found = false;\r\nif (!oh->mpu_irqs)\r\nreturn -ENOENT;\r\ni = 0;\r\nwhile (oh->mpu_irqs[i].irq != -1) {\r\nif (name == oh->mpu_irqs[i].name ||\r\n!strcmp(name, oh->mpu_irqs[i].name)) {\r\nfound = true;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (!found)\r\nreturn -ENOENT;\r\n*irq = oh->mpu_irqs[i].irq;\r\nreturn 0;\r\n}\r\nstatic int _get_sdma_req_by_name(struct omap_hwmod *oh, const char *name,\r\nunsigned int *dma)\r\n{\r\nint i;\r\nbool found = false;\r\nif (!oh->sdma_reqs)\r\nreturn -ENOENT;\r\ni = 0;\r\nwhile (oh->sdma_reqs[i].dma_req != -1) {\r\nif (name == oh->sdma_reqs[i].name ||\r\n!strcmp(name, oh->sdma_reqs[i].name)) {\r\nfound = true;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (!found)\r\nreturn -ENOENT;\r\n*dma = oh->sdma_reqs[i].dma_req;\r\nreturn 0;\r\n}\r\nstatic int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,\r\nu32 *pa_start, u32 *pa_end)\r\n{\r\nint i, j;\r\nstruct omap_hwmod_ocp_if *os;\r\nstruct list_head *p = NULL;\r\nbool found = false;\r\np = oh->slave_ports.next;\r\ni = 0;\r\nwhile (i < oh->slaves_cnt) {\r\nos = _fetch_next_ocp_if(&p, &i);\r\nif (!os->addr)\r\nreturn -ENOENT;\r\nj = 0;\r\nwhile (os->addr[j].pa_start != os->addr[j].pa_end) {\r\nif (name == os->addr[j].name ||\r\n!strcmp(name, os->addr[j].name)) {\r\nfound = true;\r\nbreak;\r\n}\r\nj++;\r\n}\r\nif (found)\r\nbreak;\r\n}\r\nif (!found)\r\nreturn -ENOENT;\r\n*pa_start = os->addr[j].pa_start;\r\n*pa_end = os->addr[j].pa_end;\r\nreturn 0;\r\n}\r\nstatic void __init _save_mpu_port_index(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_ocp_if *os = NULL;\r\nstruct list_head *p;\r\nint i = 0;\r\nif (!oh)\r\nreturn;\r\noh->_int_flags |= _HWMOD_NO_MPU_PORT;\r\np = oh->slave_ports.next;\r\nwhile (i < oh->slaves_cnt) {\r\nos = _fetch_next_ocp_if(&p, &i);\r\nif (os->user & OCP_USER_MPU) {\r\noh->_mpu_port = os;\r\noh->_int_flags &= ~_HWMOD_NO_MPU_PORT;\r\nbreak;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic struct omap_hwmod_ocp_if *_find_mpu_rt_port(struct omap_hwmod *oh)\r\n{\r\nif (!oh || oh->_int_flags & _HWMOD_NO_MPU_PORT || oh->slaves_cnt == 0)\r\nreturn NULL;\r\nreturn oh->_mpu_port;\r\n}\r\nstatic struct omap_hwmod_addr_space * __init _find_mpu_rt_addr_space(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_ocp_if *os;\r\nstruct omap_hwmod_addr_space *mem;\r\nint found = 0, i = 0;\r\nos = _find_mpu_rt_port(oh);\r\nif (!os || !os->addr)\r\nreturn NULL;\r\ndo {\r\nmem = &os->addr[i++];\r\nif (mem->flags & ADDR_TYPE_RT)\r\nfound = 1;\r\n} while (!found && mem->pa_start != mem->pa_end);\r\nreturn (found) ? mem : NULL;\r\n}\r\nstatic void _enable_sysc(struct omap_hwmod *oh)\r\n{\r\nu8 idlemode, sf;\r\nu32 v;\r\nbool clkdm_act;\r\nstruct clockdomain *clkdm;\r\nif (!oh->class->sysc)\r\nreturn;\r\nif (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)\r\n_enable_optional_clocks(oh);\r\n_wait_softreset_complete(oh);\r\nif (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)\r\n_disable_optional_clocks(oh);\r\nv = oh->_sysc_cache;\r\nsf = oh->class->sysc->sysc_flags;\r\nclkdm = _get_clkdm(oh);\r\nif (sf & SYSC_HAS_SIDLEMODE) {\r\nif (oh->flags & HWMOD_SWSUP_SIDLE ||\r\noh->flags & HWMOD_SWSUP_SIDLE_ACT) {\r\nidlemode = HWMOD_IDLEMODE_NO;\r\n} else {\r\nif (sf & SYSC_HAS_ENAWAKEUP)\r\n_enable_wakeup(oh, &v);\r\nif (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)\r\nidlemode = HWMOD_IDLEMODE_SMART_WKUP;\r\nelse\r\nidlemode = HWMOD_IDLEMODE_SMART;\r\n}\r\nclkdm_act = (clkdm && clkdm->flags & CLKDM_ACTIVE_WITH_MPU);\r\nif (clkdm_act && !(oh->class->sysc->idlemodes &\r\n(SIDLE_SMART | SIDLE_SMART_WKUP)))\r\nidlemode = HWMOD_IDLEMODE_FORCE;\r\n_set_slave_idlemode(oh, idlemode, &v);\r\n}\r\nif (sf & SYSC_HAS_MIDLEMODE) {\r\nif (oh->flags & HWMOD_FORCE_MSTANDBY) {\r\nidlemode = HWMOD_IDLEMODE_FORCE;\r\n} else if (oh->flags & HWMOD_SWSUP_MSTANDBY) {\r\nidlemode = HWMOD_IDLEMODE_NO;\r\n} else {\r\nif (sf & SYSC_HAS_ENAWAKEUP)\r\n_enable_wakeup(oh, &v);\r\nif (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)\r\nidlemode = HWMOD_IDLEMODE_SMART_WKUP;\r\nelse\r\nidlemode = HWMOD_IDLEMODE_SMART;\r\n}\r\n_set_master_standbymode(oh, idlemode, &v);\r\n}\r\nif ((oh->flags & HWMOD_SET_DEFAULT_CLOCKACT) &&\r\n(sf & SYSC_HAS_CLOCKACTIVITY))\r\n_set_clockactivity(oh, oh->class->sysc->clockact, &v);\r\n_write_sysconfig(v, oh);\r\nif (sf & SYSC_HAS_AUTOIDLE) {\r\nidlemode = (oh->flags & HWMOD_NO_OCP_AUTOIDLE) ?\r\n0 : 1;\r\n_set_module_autoidle(oh, idlemode, &v);\r\n_write_sysconfig(v, oh);\r\n}\r\n}\r\nstatic void _idle_sysc(struct omap_hwmod *oh)\r\n{\r\nu8 idlemode, sf;\r\nu32 v;\r\nif (!oh->class->sysc)\r\nreturn;\r\nv = oh->_sysc_cache;\r\nsf = oh->class->sysc->sysc_flags;\r\nif (sf & SYSC_HAS_SIDLEMODE) {\r\nif (oh->flags & HWMOD_SWSUP_SIDLE) {\r\nidlemode = HWMOD_IDLEMODE_FORCE;\r\n} else {\r\nif (sf & SYSC_HAS_ENAWAKEUP)\r\n_enable_wakeup(oh, &v);\r\nif (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)\r\nidlemode = HWMOD_IDLEMODE_SMART_WKUP;\r\nelse\r\nidlemode = HWMOD_IDLEMODE_SMART;\r\n}\r\n_set_slave_idlemode(oh, idlemode, &v);\r\n}\r\nif (sf & SYSC_HAS_MIDLEMODE) {\r\nif ((oh->flags & HWMOD_SWSUP_MSTANDBY) ||\r\n(oh->flags & HWMOD_FORCE_MSTANDBY)) {\r\nidlemode = HWMOD_IDLEMODE_FORCE;\r\n} else {\r\nif (sf & SYSC_HAS_ENAWAKEUP)\r\n_enable_wakeup(oh, &v);\r\nif (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)\r\nidlemode = HWMOD_IDLEMODE_SMART_WKUP;\r\nelse\r\nidlemode = HWMOD_IDLEMODE_SMART;\r\n}\r\n_set_master_standbymode(oh, idlemode, &v);\r\n}\r\nif (oh->_sysc_cache != v)\r\n_write_sysconfig(v, oh);\r\n}\r\nstatic void _shutdown_sysc(struct omap_hwmod *oh)\r\n{\r\nu32 v;\r\nu8 sf;\r\nif (!oh->class->sysc)\r\nreturn;\r\nv = oh->_sysc_cache;\r\nsf = oh->class->sysc->sysc_flags;\r\nif (sf & SYSC_HAS_SIDLEMODE)\r\n_set_slave_idlemode(oh, HWMOD_IDLEMODE_FORCE, &v);\r\nif (sf & SYSC_HAS_MIDLEMODE)\r\n_set_master_standbymode(oh, HWMOD_IDLEMODE_FORCE, &v);\r\nif (sf & SYSC_HAS_AUTOIDLE)\r\n_set_module_autoidle(oh, 1, &v);\r\n_write_sysconfig(v, oh);\r\n}\r\nstatic struct omap_hwmod *_lookup(const char *name)\r\n{\r\nstruct omap_hwmod *oh, *temp_oh;\r\noh = NULL;\r\nlist_for_each_entry(temp_oh, &omap_hwmod_list, node) {\r\nif (!strcmp(name, temp_oh->name)) {\r\noh = temp_oh;\r\nbreak;\r\n}\r\n}\r\nreturn oh;\r\n}\r\nstatic int _init_clkdm(struct omap_hwmod *oh)\r\n{\r\nif (!oh->clkdm_name) {\r\npr_debug("omap_hwmod: %s: missing clockdomain\n", oh->name);\r\nreturn 0;\r\n}\r\noh->clkdm = clkdm_lookup(oh->clkdm_name);\r\nif (!oh->clkdm) {\r\npr_warn("omap_hwmod: %s: could not associate to clkdm %s\n",\r\noh->name, oh->clkdm_name);\r\nreturn 0;\r\n}\r\npr_debug("omap_hwmod: %s: associated to clkdm %s\n",\r\noh->name, oh->clkdm_name);\r\nreturn 0;\r\n}\r\nstatic int _init_clocks(struct omap_hwmod *oh, void *data)\r\n{\r\nint ret = 0;\r\nif (oh->_state != _HWMOD_STATE_REGISTERED)\r\nreturn 0;\r\npr_debug("omap_hwmod: %s: looking up clocks\n", oh->name);\r\nif (soc_ops.init_clkdm)\r\nret |= soc_ops.init_clkdm(oh);\r\nret |= _init_main_clk(oh);\r\nret |= _init_interface_clks(oh);\r\nret |= _init_opt_clks(oh);\r\nif (!ret)\r\noh->_state = _HWMOD_STATE_CLKS_INITED;\r\nelse\r\npr_warn("omap_hwmod: %s: cannot _init_clocks\n", oh->name);\r\nreturn ret;\r\n}\r\nstatic int _lookup_hardreset(struct omap_hwmod *oh, const char *name,\r\nstruct omap_hwmod_rst_info *ohri)\r\n{\r\nint i;\r\nfor (i = 0; i < oh->rst_lines_cnt; i++) {\r\nconst char *rst_line = oh->rst_lines[i].name;\r\nif (!strcmp(rst_line, name)) {\r\nohri->rst_shift = oh->rst_lines[i].rst_shift;\r\nohri->st_shift = oh->rst_lines[i].st_shift;\r\npr_debug("omap_hwmod: %s: %s: %s: rst %d st %d\n",\r\noh->name, __func__, rst_line, ohri->rst_shift,\r\nohri->st_shift);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int _assert_hardreset(struct omap_hwmod *oh, const char *name)\r\n{\r\nstruct omap_hwmod_rst_info ohri;\r\nint ret = -EINVAL;\r\nif (!oh)\r\nreturn -EINVAL;\r\nif (!soc_ops.assert_hardreset)\r\nreturn -ENOSYS;\r\nret = _lookup_hardreset(oh, name, &ohri);\r\nif (ret < 0)\r\nreturn ret;\r\nret = soc_ops.assert_hardreset(oh, &ohri);\r\nreturn ret;\r\n}\r\nstatic int _deassert_hardreset(struct omap_hwmod *oh, const char *name)\r\n{\r\nstruct omap_hwmod_rst_info ohri;\r\nint ret = -EINVAL;\r\nif (!oh)\r\nreturn -EINVAL;\r\nif (!soc_ops.deassert_hardreset)\r\nreturn -ENOSYS;\r\nret = _lookup_hardreset(oh, name, &ohri);\r\nif (ret < 0)\r\nreturn ret;\r\nif (oh->clkdm) {\r\nclkdm_deny_idle(oh->clkdm);\r\nret = clkdm_hwmod_enable(oh->clkdm, oh);\r\nif (ret) {\r\nWARN(1, "omap_hwmod: %s: could not enable clockdomain %s: %d\n",\r\noh->name, oh->clkdm->name, ret);\r\nreturn ret;\r\n}\r\n}\r\n_enable_clocks(oh);\r\nif (soc_ops.enable_module)\r\nsoc_ops.enable_module(oh);\r\nret = soc_ops.deassert_hardreset(oh, &ohri);\r\nif (soc_ops.disable_module)\r\nsoc_ops.disable_module(oh);\r\n_disable_clocks(oh);\r\nif (ret == -EBUSY)\r\npr_warn("omap_hwmod: %s: failed to hardreset\n", oh->name);\r\nif (oh->clkdm) {\r\nclkdm_allow_idle(oh->clkdm);\r\nclkdm_hwmod_disable(oh->clkdm, oh);\r\n}\r\nreturn ret;\r\n}\r\nstatic int _read_hardreset(struct omap_hwmod *oh, const char *name)\r\n{\r\nstruct omap_hwmod_rst_info ohri;\r\nint ret = -EINVAL;\r\nif (!oh)\r\nreturn -EINVAL;\r\nif (!soc_ops.is_hardreset_asserted)\r\nreturn -ENOSYS;\r\nret = _lookup_hardreset(oh, name, &ohri);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn soc_ops.is_hardreset_asserted(oh, &ohri);\r\n}\r\nstatic bool _are_all_hardreset_lines_asserted(struct omap_hwmod *oh)\r\n{\r\nint i, rst_cnt = 0;\r\nif (oh->rst_lines_cnt == 0)\r\nreturn false;\r\nfor (i = 0; i < oh->rst_lines_cnt; i++)\r\nif (_read_hardreset(oh, oh->rst_lines[i].name) > 0)\r\nrst_cnt++;\r\nif (oh->rst_lines_cnt == rst_cnt)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool _are_any_hardreset_lines_asserted(struct omap_hwmod *oh)\r\n{\r\nint rst_cnt = 0;\r\nint i;\r\nfor (i = 0; i < oh->rst_lines_cnt && rst_cnt == 0; i++)\r\nif (_read_hardreset(oh, oh->rst_lines[i].name) > 0)\r\nrst_cnt++;\r\nreturn (rst_cnt) ? true : false;\r\n}\r\nstatic int _omap4_disable_module(struct omap_hwmod *oh)\r\n{\r\nint v;\r\nif (!oh->clkdm || !oh->prcm.omap4.modulemode)\r\nreturn -EINVAL;\r\nif (_are_any_hardreset_lines_asserted(oh))\r\nreturn 0;\r\npr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);\r\nomap_cm_module_disable(oh->clkdm->prcm_partition, oh->clkdm->cm_inst,\r\noh->prcm.omap4.clkctrl_offs);\r\nv = _omap4_wait_target_disable(oh);\r\nif (v)\r\npr_warn("omap_hwmod: %s: _wait_target_disable failed\n",\r\noh->name);\r\nreturn 0;\r\n}\r\nstatic int _ocp_softreset(struct omap_hwmod *oh)\r\n{\r\nu32 v;\r\nint c = 0;\r\nint ret = 0;\r\nif (!oh->class->sysc ||\r\n!(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))\r\nreturn -ENOENT;\r\nif (oh->_state != _HWMOD_STATE_ENABLED) {\r\npr_warn("omap_hwmod: %s: reset can only be entered from enabled state\n",\r\noh->name);\r\nreturn -EINVAL;\r\n}\r\nif (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)\r\n_enable_optional_clocks(oh);\r\npr_debug("omap_hwmod: %s: resetting via OCP SOFTRESET\n", oh->name);\r\nv = oh->_sysc_cache;\r\nret = _set_softreset(oh, &v);\r\nif (ret)\r\ngoto dis_opt_clks;\r\n_write_sysconfig(v, oh);\r\nif (oh->class->sysc->srst_udelay)\r\nudelay(oh->class->sysc->srst_udelay);\r\nc = _wait_softreset_complete(oh);\r\nif (c == MAX_MODULE_SOFTRESET_WAIT) {\r\npr_warn("omap_hwmod: %s: softreset failed (waited %d usec)\n",\r\noh->name, MAX_MODULE_SOFTRESET_WAIT);\r\nret = -ETIMEDOUT;\r\ngoto dis_opt_clks;\r\n} else {\r\npr_debug("omap_hwmod: %s: softreset in %d usec\n", oh->name, c);\r\n}\r\nret = _clear_softreset(oh, &v);\r\nif (ret)\r\ngoto dis_opt_clks;\r\n_write_sysconfig(v, oh);\r\ndis_opt_clks:\r\nif (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)\r\n_disable_optional_clocks(oh);\r\nreturn ret;\r\n}\r\nstatic int _reset(struct omap_hwmod *oh)\r\n{\r\nint i, r;\r\npr_debug("omap_hwmod: %s: resetting\n", oh->name);\r\nif (oh->class->reset) {\r\nr = oh->class->reset(oh);\r\n} else {\r\nif (oh->rst_lines_cnt > 0) {\r\nfor (i = 0; i < oh->rst_lines_cnt; i++)\r\n_assert_hardreset(oh, oh->rst_lines[i].name);\r\nreturn 0;\r\n} else {\r\nr = _ocp_softreset(oh);\r\nif (r == -ENOENT)\r\nr = 0;\r\n}\r\n}\r\n_set_dmadisable(oh);\r\nif (oh->class->sysc) {\r\n_update_sysc_cache(oh);\r\n_enable_sysc(oh);\r\n}\r\nreturn r;\r\n}\r\nstatic void _reconfigure_io_chain(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&io_chain_lock, flags);\r\nomap_prm_reconfigure_io_chain();\r\nspin_unlock_irqrestore(&io_chain_lock, flags);\r\n}\r\nstatic void _omap4_update_context_lost(struct omap_hwmod *oh)\r\n{\r\nif (oh->prcm.omap4.flags & HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT)\r\nreturn;\r\nif (!prm_was_any_context_lost_old(oh->clkdm->pwrdm.ptr->prcm_partition,\r\noh->clkdm->pwrdm.ptr->prcm_offs,\r\noh->prcm.omap4.context_offs))\r\nreturn;\r\noh->prcm.omap4.context_lost_counter++;\r\nprm_clear_context_loss_flags_old(oh->clkdm->pwrdm.ptr->prcm_partition,\r\noh->clkdm->pwrdm.ptr->prcm_offs,\r\noh->prcm.omap4.context_offs);\r\n}\r\nstatic int _omap4_get_context_lost(struct omap_hwmod *oh)\r\n{\r\nreturn oh->prcm.omap4.context_lost_counter;\r\n}\r\nstatic int _enable_preprogram(struct omap_hwmod *oh)\r\n{\r\nif (!oh->class->enable_preprogram)\r\nreturn 0;\r\nreturn oh->class->enable_preprogram(oh);\r\n}\r\nstatic int _enable(struct omap_hwmod *oh)\r\n{\r\nint r;\r\npr_debug("omap_hwmod: %s: enabling\n", oh->name);\r\nif (oh->_int_flags & _HWMOD_SKIP_ENABLE) {\r\nif (oh->mux)\r\nomap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);\r\noh->_int_flags &= ~_HWMOD_SKIP_ENABLE;\r\nreturn 0;\r\n}\r\nif (oh->_state != _HWMOD_STATE_INITIALIZED &&\r\noh->_state != _HWMOD_STATE_IDLE &&\r\noh->_state != _HWMOD_STATE_DISABLED) {\r\nWARN(1, "omap_hwmod: %s: enabled state can only be entered from initialized, idle, or disabled state\n",\r\noh->name);\r\nreturn -EINVAL;\r\n}\r\nif (_are_all_hardreset_lines_asserted(oh))\r\nreturn 0;\r\nif (oh->mux && (!oh->mux->enabled ||\r\n((oh->_state == _HWMOD_STATE_IDLE) &&\r\noh->mux->pads_dynamic))) {\r\nomap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);\r\n_reconfigure_io_chain();\r\n} else if (oh->flags & HWMOD_RECONFIG_IO_CHAIN) {\r\n_reconfigure_io_chain();\r\n}\r\n_add_initiator_dep(oh, mpu_oh);\r\nif (oh->clkdm) {\r\nclkdm_deny_idle(oh->clkdm);\r\nr = clkdm_hwmod_enable(oh->clkdm, oh);\r\nif (r) {\r\nWARN(1, "omap_hwmod: %s: could not enable clockdomain %s: %d\n",\r\noh->name, oh->clkdm->name, r);\r\nreturn r;\r\n}\r\n}\r\n_enable_clocks(oh);\r\nif (soc_ops.enable_module)\r\nsoc_ops.enable_module(oh);\r\nif (oh->flags & HWMOD_BLOCK_WFI)\r\ncpu_idle_poll_ctrl(true);\r\nif (soc_ops.update_context_lost)\r\nsoc_ops.update_context_lost(oh);\r\nr = (soc_ops.wait_target_ready) ? soc_ops.wait_target_ready(oh) :\r\n-EINVAL;\r\nif (oh->clkdm)\r\nclkdm_allow_idle(oh->clkdm);\r\nif (!r) {\r\noh->_state = _HWMOD_STATE_ENABLED;\r\nif (oh->class->sysc) {\r\nif (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))\r\n_update_sysc_cache(oh);\r\n_enable_sysc(oh);\r\n}\r\nr = _enable_preprogram(oh);\r\n} else {\r\nif (soc_ops.disable_module)\r\nsoc_ops.disable_module(oh);\r\n_disable_clocks(oh);\r\npr_err("omap_hwmod: %s: _wait_target_ready failed: %d\n",\r\noh->name, r);\r\nif (oh->clkdm)\r\nclkdm_hwmod_disable(oh->clkdm, oh);\r\n}\r\nreturn r;\r\n}\r\nstatic int _idle(struct omap_hwmod *oh)\r\n{\r\nif (oh->flags & HWMOD_NO_IDLE) {\r\noh->_int_flags |= _HWMOD_SKIP_ENABLE;\r\nreturn 0;\r\n}\r\npr_debug("omap_hwmod: %s: idling\n", oh->name);\r\nif (_are_all_hardreset_lines_asserted(oh))\r\nreturn 0;\r\nif (oh->_state != _HWMOD_STATE_ENABLED) {\r\nWARN(1, "omap_hwmod: %s: idle state can only be entered from enabled state\n",\r\noh->name);\r\nreturn -EINVAL;\r\n}\r\nif (oh->class->sysc)\r\n_idle_sysc(oh);\r\n_del_initiator_dep(oh, mpu_oh);\r\nif (oh->clkdm)\r\nclkdm_deny_idle(oh->clkdm);\r\nif (oh->flags & HWMOD_BLOCK_WFI)\r\ncpu_idle_poll_ctrl(false);\r\nif (soc_ops.disable_module)\r\nsoc_ops.disable_module(oh);\r\n_disable_clocks(oh);\r\nif (oh->clkdm) {\r\nclkdm_allow_idle(oh->clkdm);\r\nclkdm_hwmod_disable(oh->clkdm, oh);\r\n}\r\nif (oh->mux && oh->mux->pads_dynamic) {\r\nomap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);\r\n_reconfigure_io_chain();\r\n} else if (oh->flags & HWMOD_RECONFIG_IO_CHAIN) {\r\n_reconfigure_io_chain();\r\n}\r\noh->_state = _HWMOD_STATE_IDLE;\r\nreturn 0;\r\n}\r\nstatic int _shutdown(struct omap_hwmod *oh)\r\n{\r\nint ret, i;\r\nu8 prev_state;\r\nif (_are_all_hardreset_lines_asserted(oh))\r\nreturn 0;\r\nif (oh->_state != _HWMOD_STATE_IDLE &&\r\noh->_state != _HWMOD_STATE_ENABLED) {\r\nWARN(1, "omap_hwmod: %s: disabled state can only be entered from idle, or enabled state\n",\r\noh->name);\r\nreturn -EINVAL;\r\n}\r\npr_debug("omap_hwmod: %s: disabling\n", oh->name);\r\nif (oh->class->pre_shutdown) {\r\nprev_state = oh->_state;\r\nif (oh->_state == _HWMOD_STATE_IDLE)\r\n_enable(oh);\r\nret = oh->class->pre_shutdown(oh);\r\nif (ret) {\r\nif (prev_state == _HWMOD_STATE_IDLE)\r\n_idle(oh);\r\nreturn ret;\r\n}\r\n}\r\nif (oh->class->sysc) {\r\nif (oh->_state == _HWMOD_STATE_IDLE)\r\n_enable(oh);\r\n_shutdown_sysc(oh);\r\n}\r\nif (oh->_state == _HWMOD_STATE_ENABLED) {\r\n_del_initiator_dep(oh, mpu_oh);\r\nif (oh->flags & HWMOD_BLOCK_WFI)\r\ncpu_idle_poll_ctrl(false);\r\nif (soc_ops.disable_module)\r\nsoc_ops.disable_module(oh);\r\n_disable_clocks(oh);\r\nif (oh->clkdm)\r\nclkdm_hwmod_disable(oh->clkdm, oh);\r\n}\r\nfor (i = 0; i < oh->rst_lines_cnt; i++)\r\n_assert_hardreset(oh, oh->rst_lines[i].name);\r\nif (oh->mux)\r\nomap_hwmod_mux(oh->mux, _HWMOD_STATE_DISABLED);\r\noh->_state = _HWMOD_STATE_DISABLED;\r\nreturn 0;\r\n}\r\nstatic int of_dev_find_hwmod(struct device_node *np,\r\nstruct omap_hwmod *oh)\r\n{\r\nint count, i, res;\r\nconst char *p;\r\ncount = of_property_count_strings(np, "ti,hwmods");\r\nif (count < 1)\r\nreturn -ENODEV;\r\nfor (i = 0; i < count; i++) {\r\nres = of_property_read_string_index(np, "ti,hwmods",\r\ni, &p);\r\nif (res)\r\ncontinue;\r\nif (!strcmp(p, oh->name)) {\r\npr_debug("omap_hwmod: dt %s[%i] uses hwmod %s\n",\r\nnp->name, i, oh->name);\r\nreturn i;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int of_dev_hwmod_lookup(struct device_node *np,\r\nstruct omap_hwmod *oh,\r\nint *index,\r\nstruct device_node **found)\r\n{\r\nstruct device_node *np0 = NULL;\r\nint res;\r\nres = of_dev_find_hwmod(np, oh);\r\nif (res >= 0) {\r\n*found = np;\r\n*index = res;\r\nreturn 0;\r\n}\r\nfor_each_child_of_node(np, np0) {\r\nstruct device_node *fc;\r\nint i;\r\nres = of_dev_hwmod_lookup(np0, oh, &i, &fc);\r\nif (res == 0) {\r\n*found = fc;\r\n*index = i;\r\nreturn 0;\r\n}\r\n}\r\n*found = NULL;\r\n*index = 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,\r\nint index, struct device_node *np)\r\n{\r\nstruct omap_hwmod_addr_space *mem;\r\nvoid __iomem *va_start = NULL;\r\nif (!oh)\r\nreturn -EINVAL;\r\n_save_mpu_port_index(oh);\r\nif (!oh->class->sysc)\r\nreturn 0;\r\nif (oh->_int_flags & _HWMOD_NO_MPU_PORT)\r\nreturn -ENXIO;\r\nmem = _find_mpu_rt_addr_space(oh);\r\nif (!mem) {\r\npr_debug("omap_hwmod: %s: no MPU register target found\n",\r\noh->name);\r\nif (!np) {\r\npr_err("omap_hwmod: %s: no dt node\n", oh->name);\r\nreturn -ENXIO;\r\n}\r\nva_start = of_iomap(np, index + oh->mpu_rt_idx);\r\n} else {\r\nva_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);\r\n}\r\nif (!va_start) {\r\nif (mem)\r\npr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);\r\nelse\r\npr_err("omap_hwmod: %s: Missing dt reg%i for %s\n",\r\noh->name, index, np->full_name);\r\nreturn -ENXIO;\r\n}\r\npr_debug("omap_hwmod: %s: MPU register target at va %p\n",\r\noh->name, va_start);\r\noh->_mpu_rt_va = va_start;\r\nreturn 0;\r\n}\r\nstatic int __init _init(struct omap_hwmod *oh, void *data)\r\n{\r\nint r, index;\r\nstruct device_node *np = NULL;\r\nif (oh->_state != _HWMOD_STATE_REGISTERED)\r\nreturn 0;\r\nif (of_have_populated_dt()) {\r\nstruct device_node *bus;\r\nbus = of_find_node_by_name(NULL, "ocp");\r\nif (!bus)\r\nreturn -ENODEV;\r\nr = of_dev_hwmod_lookup(bus, oh, &index, &np);\r\nif (r)\r\npr_debug("omap_hwmod: %s missing dt data\n", oh->name);\r\nelse if (np && index)\r\npr_warn("omap_hwmod: %s using broken dt data from %s\n",\r\noh->name, np->name);\r\n}\r\nr = _init_mpu_rt_base(oh, NULL, index, np);\r\nif (r < 0) {\r\nWARN(1, "omap_hwmod: %s: doesn't have mpu register target base\n",\r\noh->name);\r\nreturn 0;\r\n}\r\nr = _init_clocks(oh, NULL);\r\nif (r < 0) {\r\nWARN(1, "omap_hwmod: %s: couldn't init clocks\n", oh->name);\r\nreturn -EINVAL;\r\n}\r\nif (np) {\r\nif (of_find_property(np, "ti,no-reset-on-init", NULL))\r\noh->flags |= HWMOD_INIT_NO_RESET;\r\nif (of_find_property(np, "ti,no-idle-on-init", NULL))\r\noh->flags |= HWMOD_INIT_NO_IDLE;\r\nif (of_find_property(np, "ti,no-idle", NULL))\r\noh->flags |= HWMOD_NO_IDLE;\r\n}\r\noh->_state = _HWMOD_STATE_INITIALIZED;\r\nreturn 0;\r\n}\r\nstatic void __init _setup_iclk_autoidle(struct omap_hwmod *oh)\r\n{\r\nstruct omap_hwmod_ocp_if *os;\r\nstruct list_head *p;\r\nint i = 0;\r\nif (oh->_state != _HWMOD_STATE_INITIALIZED)\r\nreturn;\r\np = oh->slave_ports.next;\r\nwhile (i < oh->slaves_cnt) {\r\nos = _fetch_next_ocp_if(&p, &i);\r\nif (!os->_clk)\r\ncontinue;\r\nif (os->flags & OCPIF_SWSUP_IDLE) {\r\n} else {\r\nclk_enable(os->_clk);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int __init _setup_reset(struct omap_hwmod *oh)\r\n{\r\nint r;\r\nif (oh->_state != _HWMOD_STATE_INITIALIZED)\r\nreturn -EINVAL;\r\nif (oh->flags & HWMOD_EXT_OPT_MAIN_CLK)\r\nreturn -EPERM;\r\nif (oh->rst_lines_cnt == 0) {\r\nr = _enable(oh);\r\nif (r) {\r\npr_warn("omap_hwmod: %s: cannot be enabled for reset (%d)\n",\r\noh->name, oh->_state);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!(oh->flags & HWMOD_INIT_NO_RESET))\r\nr = _reset(oh);\r\nreturn r;\r\n}\r\nstatic void __init _setup_postsetup(struct omap_hwmod *oh)\r\n{\r\nu8 postsetup_state;\r\nif (oh->rst_lines_cnt > 0)\r\nreturn;\r\npostsetup_state = oh->_postsetup_state;\r\nif (postsetup_state == _HWMOD_STATE_UNKNOWN)\r\npostsetup_state = _HWMOD_STATE_ENABLED;\r\nif ((oh->flags & (HWMOD_INIT_NO_IDLE | HWMOD_NO_IDLE)) &&\r\n(postsetup_state == _HWMOD_STATE_IDLE)) {\r\noh->_int_flags |= _HWMOD_SKIP_ENABLE;\r\npostsetup_state = _HWMOD_STATE_ENABLED;\r\n}\r\nif (postsetup_state == _HWMOD_STATE_IDLE)\r\n_idle(oh);\r\nelse if (postsetup_state == _HWMOD_STATE_DISABLED)\r\n_shutdown(oh);\r\nelse if (postsetup_state != _HWMOD_STATE_ENABLED)\r\nWARN(1, "hwmod: %s: unknown postsetup state %d! defaulting to enabled\n",\r\noh->name, postsetup_state);\r\nreturn;\r\n}\r\nstatic int __init _setup(struct omap_hwmod *oh, void *data)\r\n{\r\nif (oh->_state != _HWMOD_STATE_INITIALIZED)\r\nreturn 0;\r\nif (oh->parent_hwmod) {\r\nint r;\r\nr = _enable(oh->parent_hwmod);\r\nWARN(r, "hwmod: %s: setup: failed to enable parent hwmod %s\n",\r\noh->name, oh->parent_hwmod->name);\r\n}\r\n_setup_iclk_autoidle(oh);\r\nif (!_setup_reset(oh))\r\n_setup_postsetup(oh);\r\nif (oh->parent_hwmod) {\r\nu8 postsetup_state;\r\npostsetup_state = oh->parent_hwmod->_postsetup_state;\r\nif (postsetup_state == _HWMOD_STATE_IDLE)\r\n_idle(oh->parent_hwmod);\r\nelse if (postsetup_state == _HWMOD_STATE_DISABLED)\r\n_shutdown(oh->parent_hwmod);\r\nelse if (postsetup_state != _HWMOD_STATE_ENABLED)\r\nWARN(1, "hwmod: %s: unknown postsetup state %d! defaulting to enabled\n",\r\noh->parent_hwmod->name, postsetup_state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init _register(struct omap_hwmod *oh)\r\n{\r\nif (!oh || !oh->name || !oh->class || !oh->class->name ||\r\n(oh->_state != _HWMOD_STATE_UNKNOWN))\r\nreturn -EINVAL;\r\npr_debug("omap_hwmod: %s: registering\n", oh->name);\r\nif (_lookup(oh->name))\r\nreturn -EEXIST;\r\nlist_add_tail(&oh->node, &omap_hwmod_list);\r\nINIT_LIST_HEAD(&oh->master_ports);\r\nINIT_LIST_HEAD(&oh->slave_ports);\r\nspin_lock_init(&oh->_lock);\r\nlockdep_set_class(&oh->_lock, &oh->hwmod_key);\r\noh->_state = _HWMOD_STATE_REGISTERED;\r\nif (!strcmp(oh->name, MPU_INITIATOR_NAME))\r\nmpu_oh = oh;\r\nreturn 0;\r\n}\r\nstatic int __init _alloc_links(struct omap_hwmod_link **ml,\r\nstruct omap_hwmod_link **sl)\r\n{\r\nunsigned int sz;\r\nif ((free_ls + LINKS_PER_OCP_IF) <= max_ls) {\r\n*ml = &linkspace[free_ls++];\r\n*sl = &linkspace[free_ls++];\r\nreturn 0;\r\n}\r\nsz = sizeof(struct omap_hwmod_link) * LINKS_PER_OCP_IF;\r\n*sl = NULL;\r\n*ml = memblock_virt_alloc(sz, 0);\r\n*sl = (void *)(*ml) + sizeof(struct omap_hwmod_link);\r\nls_supp++;\r\npr_debug("omap_hwmod: supplemental link allocations needed: %d\n",\r\nls_supp * LINKS_PER_OCP_IF);\r\nreturn 0;\r\n}\r\nstatic int __init _add_link(struct omap_hwmod_ocp_if *oi)\r\n{\r\nstruct omap_hwmod_link *ml, *sl;\r\npr_debug("omap_hwmod: %s -> %s: adding link\n", oi->master->name,\r\noi->slave->name);\r\n_alloc_links(&ml, &sl);\r\nml->ocp_if = oi;\r\nlist_add(&ml->node, &oi->master->master_ports);\r\noi->master->masters_cnt++;\r\nsl->ocp_if = oi;\r\nlist_add(&sl->node, &oi->slave->slave_ports);\r\noi->slave->slaves_cnt++;\r\nreturn 0;\r\n}\r\nstatic int __init _register_link(struct omap_hwmod_ocp_if *oi)\r\n{\r\nif (!oi || !oi->master || !oi->slave || !oi->user)\r\nreturn -EINVAL;\r\nif (oi->_int_flags & _OCPIF_INT_FLAGS_REGISTERED)\r\nreturn -EEXIST;\r\npr_debug("omap_hwmod: registering link from %s to %s\n",\r\noi->master->name, oi->slave->name);\r\nif (oi->master->_state != _HWMOD_STATE_REGISTERED)\r\n_register(oi->master);\r\nif (oi->slave->_state != _HWMOD_STATE_REGISTERED)\r\n_register(oi->slave);\r\n_add_link(oi);\r\noi->_int_flags |= _OCPIF_INT_FLAGS_REGISTERED;\r\nreturn 0;\r\n}\r\nstatic int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)\r\n{\r\nunsigned int i = 0;\r\nunsigned int sz;\r\nif (linkspace) {\r\nWARN(1, "linkspace already allocated\n");\r\nreturn -EEXIST;\r\n}\r\nif (max_ls == 0)\r\nwhile (ois[i++])\r\nmax_ls += LINKS_PER_OCP_IF;\r\nsz = sizeof(struct omap_hwmod_link) * max_ls;\r\npr_debug("omap_hwmod: %s: allocating %d byte linkspace (%d links)\n",\r\n__func__, sz, max_ls);\r\nlinkspace = memblock_virt_alloc(sz, 0);\r\nreturn 0;\r\n}\r\nstatic int _omap2xxx_3xxx_wait_target_ready(struct omap_hwmod *oh)\r\n{\r\nif (!oh)\r\nreturn -EINVAL;\r\nif (oh->flags & HWMOD_NO_IDLEST)\r\nreturn 0;\r\nif (!_find_mpu_rt_port(oh))\r\nreturn 0;\r\nreturn omap_cm_wait_module_ready(0, oh->prcm.omap2.module_offs,\r\noh->prcm.omap2.idlest_reg_id,\r\noh->prcm.omap2.idlest_idle_bit);\r\n}\r\nstatic int _omap4_wait_target_ready(struct omap_hwmod *oh)\r\n{\r\nif (!oh)\r\nreturn -EINVAL;\r\nif (oh->flags & HWMOD_NO_IDLEST || !oh->clkdm)\r\nreturn 0;\r\nif (!_find_mpu_rt_port(oh))\r\nreturn 0;\r\nif (!oh->prcm.omap4.clkctrl_offs &&\r\n!(oh->prcm.omap4.flags & HWMOD_OMAP4_ZERO_CLKCTRL_OFFSET))\r\nreturn 0;\r\nreturn omap_cm_wait_module_ready(oh->clkdm->prcm_partition,\r\noh->clkdm->cm_inst,\r\noh->prcm.omap4.clkctrl_offs, 0);\r\n}\r\nstatic int _omap2_assert_hardreset(struct omap_hwmod *oh,\r\nstruct omap_hwmod_rst_info *ohri)\r\n{\r\nreturn omap_prm_assert_hardreset(ohri->rst_shift, 0,\r\noh->prcm.omap2.module_offs, 0);\r\n}\r\nstatic int _omap2_deassert_hardreset(struct omap_hwmod *oh,\r\nstruct omap_hwmod_rst_info *ohri)\r\n{\r\nreturn omap_prm_deassert_hardreset(ohri->rst_shift, ohri->st_shift, 0,\r\noh->prcm.omap2.module_offs, 0, 0);\r\n}\r\nstatic int _omap2_is_hardreset_asserted(struct omap_hwmod *oh,\r\nstruct omap_hwmod_rst_info *ohri)\r\n{\r\nreturn omap_prm_is_hardreset_asserted(ohri->st_shift, 0,\r\noh->prcm.omap2.module_offs, 0);\r\n}\r\nstatic int _omap4_assert_hardreset(struct omap_hwmod *oh,\r\nstruct omap_hwmod_rst_info *ohri)\r\n{\r\nif (!oh->clkdm)\r\nreturn -EINVAL;\r\nreturn omap_prm_assert_hardreset(ohri->rst_shift,\r\noh->clkdm->pwrdm.ptr->prcm_partition,\r\noh->clkdm->pwrdm.ptr->prcm_offs,\r\noh->prcm.omap4.rstctrl_offs);\r\n}\r\nstatic int _omap4_deassert_hardreset(struct omap_hwmod *oh,\r\nstruct omap_hwmod_rst_info *ohri)\r\n{\r\nif (!oh->clkdm)\r\nreturn -EINVAL;\r\nif (ohri->st_shift)\r\npr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",\r\noh->name, ohri->name);\r\nreturn omap_prm_deassert_hardreset(ohri->rst_shift, ohri->rst_shift,\r\noh->clkdm->pwrdm.ptr->prcm_partition,\r\noh->clkdm->pwrdm.ptr->prcm_offs,\r\noh->prcm.omap4.rstctrl_offs,\r\noh->prcm.omap4.rstctrl_offs +\r\nOMAP4_RST_CTRL_ST_OFFSET);\r\n}\r\nstatic int _omap4_is_hardreset_asserted(struct omap_hwmod *oh,\r\nstruct omap_hwmod_rst_info *ohri)\r\n{\r\nif (!oh->clkdm)\r\nreturn -EINVAL;\r\nreturn omap_prm_is_hardreset_asserted(ohri->rst_shift,\r\noh->clkdm->pwrdm.ptr->\r\nprcm_partition,\r\noh->clkdm->pwrdm.ptr->prcm_offs,\r\noh->prcm.omap4.rstctrl_offs);\r\n}\r\nstatic int _omap4_disable_direct_prcm(struct omap_hwmod *oh)\r\n{\r\nif (!oh)\r\nreturn -EINVAL;\r\noh->prcm.omap4.clkctrl_offs = 0;\r\noh->prcm.omap4.modulemode = 0;\r\nreturn 0;\r\n}\r\nstatic int _am33xx_deassert_hardreset(struct omap_hwmod *oh,\r\nstruct omap_hwmod_rst_info *ohri)\r\n{\r\nreturn omap_prm_deassert_hardreset(ohri->rst_shift, ohri->st_shift,\r\noh->clkdm->pwrdm.ptr->prcm_partition,\r\noh->clkdm->pwrdm.ptr->prcm_offs,\r\noh->prcm.omap4.rstctrl_offs,\r\noh->prcm.omap4.rstst_offs);\r\n}\r\nu32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)\r\n{\r\nif (oh->flags & HWMOD_16BIT_REG)\r\nreturn readw_relaxed(oh->_mpu_rt_va + reg_offs);\r\nelse\r\nreturn readl_relaxed(oh->_mpu_rt_va + reg_offs);\r\n}\r\nvoid omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)\r\n{\r\nif (oh->flags & HWMOD_16BIT_REG)\r\nwritew_relaxed(v, oh->_mpu_rt_va + reg_offs);\r\nelse\r\nwritel_relaxed(v, oh->_mpu_rt_va + reg_offs);\r\n}\r\nint omap_hwmod_softreset(struct omap_hwmod *oh)\r\n{\r\nu32 v;\r\nint ret;\r\nif (!oh || !(oh->_sysc_cache))\r\nreturn -EINVAL;\r\nv = oh->_sysc_cache;\r\nret = _set_softreset(oh, &v);\r\nif (ret)\r\ngoto error;\r\n_write_sysconfig(v, oh);\r\nret = _clear_softreset(oh, &v);\r\nif (ret)\r\ngoto error;\r\n_write_sysconfig(v, oh);\r\nerror:\r\nreturn ret;\r\n}\r\nstruct omap_hwmod *omap_hwmod_lookup(const char *name)\r\n{\r\nstruct omap_hwmod *oh;\r\nif (!name)\r\nreturn NULL;\r\noh = _lookup(name);\r\nreturn oh;\r\n}\r\nint omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),\r\nvoid *data)\r\n{\r\nstruct omap_hwmod *temp_oh;\r\nint ret = 0;\r\nif (!fn)\r\nreturn -EINVAL;\r\nlist_for_each_entry(temp_oh, &omap_hwmod_list, node) {\r\nret = (*fn)(temp_oh, data);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint __init omap_hwmod_register_links(struct omap_hwmod_ocp_if **ois)\r\n{\r\nint r, i;\r\nif (!inited)\r\nreturn -EINVAL;\r\nif (!ois)\r\nreturn 0;\r\nif (ois[0] == NULL)\r\nreturn 0;\r\nif (!linkspace) {\r\nif (_alloc_linkspace(ois)) {\r\npr_err("omap_hwmod: could not allocate link space\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ni = 0;\r\ndo {\r\nr = _register_link(ois[i]);\r\nWARN(r && r != -EEXIST,\r\n"omap_hwmod: _register_link(%s -> %s) returned %d\n",\r\nois[i]->master->name, ois[i]->slave->name, r);\r\n} while (ois[++i]);\r\nreturn 0;\r\n}\r\nstatic void __init _ensure_mpu_hwmod_is_setup(struct omap_hwmod *oh)\r\n{\r\nif (!mpu_oh || mpu_oh->_state == _HWMOD_STATE_UNKNOWN)\r\npr_err("omap_hwmod: %s: MPU initiator hwmod %s not yet registered\n",\r\n__func__, MPU_INITIATOR_NAME);\r\nelse if (mpu_oh->_state == _HWMOD_STATE_REGISTERED && oh != mpu_oh)\r\nomap_hwmod_setup_one(MPU_INITIATOR_NAME);\r\n}\r\nint __init omap_hwmod_setup_one(const char *oh_name)\r\n{\r\nstruct omap_hwmod *oh;\r\npr_debug("omap_hwmod: %s: %s\n", oh_name, __func__);\r\noh = _lookup(oh_name);\r\nif (!oh) {\r\nWARN(1, "omap_hwmod: %s: hwmod not yet registered\n", oh_name);\r\nreturn -EINVAL;\r\n}\r\n_ensure_mpu_hwmod_is_setup(oh);\r\n_init(oh, NULL);\r\n_setup(oh, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init omap_hwmod_setup_all(void)\r\n{\r\n_ensure_mpu_hwmod_is_setup(NULL);\r\nomap_hwmod_for_each(_init, NULL);\r\nomap_hwmod_for_each(_setup, NULL);\r\nreturn 0;\r\n}\r\nint omap_hwmod_enable(struct omap_hwmod *oh)\r\n{\r\nint r;\r\nunsigned long flags;\r\nif (!oh)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&oh->_lock, flags);\r\nr = _enable(oh);\r\nspin_unlock_irqrestore(&oh->_lock, flags);\r\nreturn r;\r\n}\r\nint omap_hwmod_idle(struct omap_hwmod *oh)\r\n{\r\nint r;\r\nunsigned long flags;\r\nif (!oh)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&oh->_lock, flags);\r\nr = _idle(oh);\r\nspin_unlock_irqrestore(&oh->_lock, flags);\r\nreturn r;\r\n}\r\nint omap_hwmod_shutdown(struct omap_hwmod *oh)\r\n{\r\nint r;\r\nunsigned long flags;\r\nif (!oh)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&oh->_lock, flags);\r\nr = _shutdown(oh);\r\nspin_unlock_irqrestore(&oh->_lock, flags);\r\nreturn r;\r\n}\r\nint omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)\r\n{\r\nint ret = 0;\r\nif (flags & IORESOURCE_IRQ)\r\nret += _count_mpu_irqs(oh);\r\nif (flags & IORESOURCE_DMA)\r\nret += _count_sdma_reqs(oh);\r\nif (flags & IORESOURCE_MEM) {\r\nint i = 0;\r\nstruct omap_hwmod_ocp_if *os;\r\nstruct list_head *p = oh->slave_ports.next;\r\nwhile (i < oh->slaves_cnt) {\r\nos = _fetch_next_ocp_if(&p, &i);\r\nret += _count_ocp_if_addr_spaces(os);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)\r\n{\r\nstruct omap_hwmod_ocp_if *os;\r\nstruct list_head *p;\r\nint i, j, mpu_irqs_cnt, sdma_reqs_cnt, addr_cnt;\r\nint r = 0;\r\nmpu_irqs_cnt = _count_mpu_irqs(oh);\r\nfor (i = 0; i < mpu_irqs_cnt; i++) {\r\nunsigned int irq;\r\nif (oh->xlate_irq)\r\nirq = oh->xlate_irq((oh->mpu_irqs + i)->irq);\r\nelse\r\nirq = (oh->mpu_irqs + i)->irq;\r\n(res + r)->name = (oh->mpu_irqs + i)->name;\r\n(res + r)->start = irq;\r\n(res + r)->end = irq;\r\n(res + r)->flags = IORESOURCE_IRQ;\r\nr++;\r\n}\r\nsdma_reqs_cnt = _count_sdma_reqs(oh);\r\nfor (i = 0; i < sdma_reqs_cnt; i++) {\r\n(res + r)->name = (oh->sdma_reqs + i)->name;\r\n(res + r)->start = (oh->sdma_reqs + i)->dma_req;\r\n(res + r)->end = (oh->sdma_reqs + i)->dma_req;\r\n(res + r)->flags = IORESOURCE_DMA;\r\nr++;\r\n}\r\np = oh->slave_ports.next;\r\ni = 0;\r\nwhile (i < oh->slaves_cnt) {\r\nos = _fetch_next_ocp_if(&p, &i);\r\naddr_cnt = _count_ocp_if_addr_spaces(os);\r\nfor (j = 0; j < addr_cnt; j++) {\r\n(res + r)->name = (os->addr + j)->name;\r\n(res + r)->start = (os->addr + j)->pa_start;\r\n(res + r)->end = (os->addr + j)->pa_end;\r\n(res + r)->flags = IORESOURCE_MEM;\r\nr++;\r\n}\r\n}\r\nreturn r;\r\n}\r\nint omap_hwmod_fill_dma_resources(struct omap_hwmod *oh, struct resource *res)\r\n{\r\nint i, sdma_reqs_cnt;\r\nint r = 0;\r\nsdma_reqs_cnt = _count_sdma_reqs(oh);\r\nfor (i = 0; i < sdma_reqs_cnt; i++) {\r\n(res + r)->name = (oh->sdma_reqs + i)->name;\r\n(res + r)->start = (oh->sdma_reqs + i)->dma_req;\r\n(res + r)->end = (oh->sdma_reqs + i)->dma_req;\r\n(res + r)->flags = IORESOURCE_DMA;\r\nr++;\r\n}\r\nreturn r;\r\n}\r\nint omap_hwmod_get_resource_byname(struct omap_hwmod *oh, unsigned int type,\r\nconst char *name, struct resource *rsrc)\r\n{\r\nint r;\r\nunsigned int irq, dma;\r\nu32 pa_start, pa_end;\r\nif (!oh || !rsrc)\r\nreturn -EINVAL;\r\nif (type == IORESOURCE_IRQ) {\r\nr = _get_mpu_irq_by_name(oh, name, &irq);\r\nif (r)\r\nreturn r;\r\nrsrc->start = irq;\r\nrsrc->end = irq;\r\n} else if (type == IORESOURCE_DMA) {\r\nr = _get_sdma_req_by_name(oh, name, &dma);\r\nif (r)\r\nreturn r;\r\nrsrc->start = dma;\r\nrsrc->end = dma;\r\n} else if (type == IORESOURCE_MEM) {\r\nr = _get_addr_space_by_name(oh, name, &pa_start, &pa_end);\r\nif (r)\r\nreturn r;\r\nrsrc->start = pa_start;\r\nrsrc->end = pa_end;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nrsrc->flags = type;\r\nrsrc->name = name;\r\nreturn 0;\r\n}\r\nstruct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)\r\n{\r\nstruct clk *c;\r\nstruct omap_hwmod_ocp_if *oi;\r\nstruct clockdomain *clkdm;\r\nstruct clk_hw_omap *clk;\r\nif (!oh)\r\nreturn NULL;\r\nif (oh->clkdm)\r\nreturn oh->clkdm->pwrdm.ptr;\r\nif (oh->_clk) {\r\nc = oh->_clk;\r\n} else {\r\noi = _find_mpu_rt_port(oh);\r\nif (!oi)\r\nreturn NULL;\r\nc = oi->_clk;\r\n}\r\nclk = to_clk_hw_omap(__clk_get_hw(c));\r\nclkdm = clk->clkdm;\r\nif (!clkdm)\r\nreturn NULL;\r\nreturn clkdm->pwrdm.ptr;\r\n}\r\nvoid __iomem *omap_hwmod_get_mpu_rt_va(struct omap_hwmod *oh)\r\n{\r\nif (!oh)\r\nreturn NULL;\r\nif (oh->_int_flags & _HWMOD_NO_MPU_PORT)\r\nreturn NULL;\r\nif (oh->_state == _HWMOD_STATE_UNKNOWN)\r\nreturn NULL;\r\nreturn oh->_mpu_rt_va;\r\n}\r\nint omap_hwmod_enable_wakeup(struct omap_hwmod *oh)\r\n{\r\nunsigned long flags;\r\nu32 v;\r\nspin_lock_irqsave(&oh->_lock, flags);\r\nif (oh->class->sysc &&\r\n(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)) {\r\nv = oh->_sysc_cache;\r\n_enable_wakeup(oh, &v);\r\n_write_sysconfig(v, oh);\r\n}\r\n_set_idle_ioring_wakeup(oh, true);\r\nspin_unlock_irqrestore(&oh->_lock, flags);\r\nreturn 0;\r\n}\r\nint omap_hwmod_disable_wakeup(struct omap_hwmod *oh)\r\n{\r\nunsigned long flags;\r\nu32 v;\r\nspin_lock_irqsave(&oh->_lock, flags);\r\nif (oh->class->sysc &&\r\n(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)) {\r\nv = oh->_sysc_cache;\r\n_disable_wakeup(oh, &v);\r\n_write_sysconfig(v, oh);\r\n}\r\n_set_idle_ioring_wakeup(oh, false);\r\nspin_unlock_irqrestore(&oh->_lock, flags);\r\nreturn 0;\r\n}\r\nint omap_hwmod_assert_hardreset(struct omap_hwmod *oh, const char *name)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nif (!oh)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&oh->_lock, flags);\r\nret = _assert_hardreset(oh, name);\r\nspin_unlock_irqrestore(&oh->_lock, flags);\r\nreturn ret;\r\n}\r\nint omap_hwmod_deassert_hardreset(struct omap_hwmod *oh, const char *name)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nif (!oh)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&oh->_lock, flags);\r\nret = _deassert_hardreset(oh, name);\r\nspin_unlock_irqrestore(&oh->_lock, flags);\r\nreturn ret;\r\n}\r\nint omap_hwmod_for_each_by_class(const char *classname,\r\nint (*fn)(struct omap_hwmod *oh,\r\nvoid *user),\r\nvoid *user)\r\n{\r\nstruct omap_hwmod *temp_oh;\r\nint ret = 0;\r\nif (!classname || !fn)\r\nreturn -EINVAL;\r\npr_debug("omap_hwmod: %s: looking for modules of class %s\n",\r\n__func__, classname);\r\nlist_for_each_entry(temp_oh, &omap_hwmod_list, node) {\r\nif (!strcmp(temp_oh->class->name, classname)) {\r\npr_debug("omap_hwmod: %s: %s: calling callback fn\n",\r\n__func__, temp_oh->name);\r\nret = (*fn)(temp_oh, user);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\npr_debug("omap_hwmod: %s: iterator terminated early: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nint omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nif (!oh)\r\nreturn -EINVAL;\r\nif (state != _HWMOD_STATE_DISABLED &&\r\nstate != _HWMOD_STATE_ENABLED &&\r\nstate != _HWMOD_STATE_IDLE)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&oh->_lock, flags);\r\nif (oh->_state != _HWMOD_STATE_REGISTERED) {\r\nret = -EINVAL;\r\ngoto ohsps_unlock;\r\n}\r\noh->_postsetup_state = state;\r\nret = 0;\r\nohsps_unlock:\r\nspin_unlock_irqrestore(&oh->_lock, flags);\r\nreturn ret;\r\n}\r\nint omap_hwmod_get_context_loss_count(struct omap_hwmod *oh)\r\n{\r\nstruct powerdomain *pwrdm;\r\nint ret = 0;\r\nif (soc_ops.get_context_lost)\r\nreturn soc_ops.get_context_lost(oh);\r\npwrdm = omap_hwmod_get_pwrdm(oh);\r\nif (pwrdm)\r\nret = pwrdm_get_context_loss_count(pwrdm);\r\nreturn ret;\r\n}\r\nvoid __init omap_hwmod_init(void)\r\n{\r\nif (cpu_is_omap24xx()) {\r\nsoc_ops.wait_target_ready = _omap2xxx_3xxx_wait_target_ready;\r\nsoc_ops.assert_hardreset = _omap2_assert_hardreset;\r\nsoc_ops.deassert_hardreset = _omap2_deassert_hardreset;\r\nsoc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;\r\n} else if (cpu_is_omap34xx()) {\r\nsoc_ops.wait_target_ready = _omap2xxx_3xxx_wait_target_ready;\r\nsoc_ops.assert_hardreset = _omap2_assert_hardreset;\r\nsoc_ops.deassert_hardreset = _omap2_deassert_hardreset;\r\nsoc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;\r\nsoc_ops.init_clkdm = _init_clkdm;\r\n} else if (cpu_is_omap44xx() || soc_is_omap54xx() || soc_is_dra7xx()) {\r\nsoc_ops.enable_module = _omap4_enable_module;\r\nsoc_ops.disable_module = _omap4_disable_module;\r\nsoc_ops.wait_target_ready = _omap4_wait_target_ready;\r\nsoc_ops.assert_hardreset = _omap4_assert_hardreset;\r\nsoc_ops.deassert_hardreset = _omap4_deassert_hardreset;\r\nsoc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;\r\nsoc_ops.init_clkdm = _init_clkdm;\r\nsoc_ops.update_context_lost = _omap4_update_context_lost;\r\nsoc_ops.get_context_lost = _omap4_get_context_lost;\r\nsoc_ops.disable_direct_prcm = _omap4_disable_direct_prcm;\r\n} else if (cpu_is_ti814x() || cpu_is_ti816x() || soc_is_am33xx() ||\r\nsoc_is_am43xx()) {\r\nsoc_ops.enable_module = _omap4_enable_module;\r\nsoc_ops.disable_module = _omap4_disable_module;\r\nsoc_ops.wait_target_ready = _omap4_wait_target_ready;\r\nsoc_ops.assert_hardreset = _omap4_assert_hardreset;\r\nsoc_ops.deassert_hardreset = _am33xx_deassert_hardreset;\r\nsoc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;\r\nsoc_ops.init_clkdm = _init_clkdm;\r\nsoc_ops.disable_direct_prcm = _omap4_disable_direct_prcm;\r\n} else {\r\nWARN(1, "omap_hwmod: unknown SoC type\n");\r\n}\r\ninited = true;\r\n}\r\nconst char *omap_hwmod_get_main_clk(struct omap_hwmod *oh)\r\n{\r\nif (!oh)\r\nreturn NULL;\r\nreturn oh->main_clk;\r\n}
