static int qcom_hwspinlock_trylock(struct hwspinlock *lock)\r\n{\r\nstruct regmap_field *field = lock->priv;\r\nu32 lock_owner;\r\nint ret;\r\nret = regmap_field_write(field, QCOM_MUTEX_APPS_PROC_ID);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_field_read(field, &lock_owner);\r\nif (ret)\r\nreturn ret;\r\nreturn lock_owner == QCOM_MUTEX_APPS_PROC_ID;\r\n}\r\nstatic void qcom_hwspinlock_unlock(struct hwspinlock *lock)\r\n{\r\nstruct regmap_field *field = lock->priv;\r\nu32 lock_owner;\r\nint ret;\r\nret = regmap_field_read(field, &lock_owner);\r\nif (ret) {\r\npr_err("%s: unable to query spinlock owner\n", __func__);\r\nreturn;\r\n}\r\nif (lock_owner != QCOM_MUTEX_APPS_PROC_ID) {\r\npr_err("%s: spinlock not owned by us (actual owner is %d)\n",\r\n__func__, lock_owner);\r\n}\r\nret = regmap_field_write(field, 0);\r\nif (ret)\r\npr_err("%s: failed to unlock spinlock\n", __func__);\r\n}\r\nstatic int qcom_hwspinlock_probe(struct platform_device *pdev)\r\n{\r\nstruct hwspinlock_device *bank;\r\nstruct device_node *syscon;\r\nstruct reg_field field;\r\nstruct regmap *regmap;\r\nsize_t array_size;\r\nu32 stride;\r\nu32 base;\r\nint ret;\r\nint i;\r\nsyscon = of_parse_phandle(pdev->dev.of_node, "syscon", 0);\r\nif (!syscon) {\r\ndev_err(&pdev->dev, "no syscon property\n");\r\nreturn -ENODEV;\r\n}\r\nregmap = syscon_node_to_regmap(syscon);\r\nof_node_put(syscon);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nret = of_property_read_u32_index(pdev->dev.of_node, "syscon", 1, &base);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "no offset in syscon\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_index(pdev->dev.of_node, "syscon", 2, &stride);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "no stride syscon\n");\r\nreturn -EINVAL;\r\n}\r\narray_size = QCOM_MUTEX_NUM_LOCKS * sizeof(struct hwspinlock);\r\nbank = devm_kzalloc(&pdev->dev, sizeof(*bank) + array_size, GFP_KERNEL);\r\nif (!bank)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, bank);\r\nfor (i = 0; i < QCOM_MUTEX_NUM_LOCKS; i++) {\r\nfield.reg = base + i * stride;\r\nfield.lsb = 0;\r\nfield.msb = 31;\r\nbank->lock[i].priv = devm_regmap_field_alloc(&pdev->dev,\r\nregmap, field);\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nret = hwspin_lock_register(bank, &pdev->dev, &qcom_hwspinlock_ops,\r\n0, QCOM_MUTEX_NUM_LOCKS);\r\nif (ret)\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int qcom_hwspinlock_remove(struct platform_device *pdev)\r\n{\r\nstruct hwspinlock_device *bank = platform_get_drvdata(pdev);\r\nint ret;\r\nret = hwspin_lock_unregister(bank);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s failed: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init qcom_hwspinlock_init(void)\r\n{\r\nreturn platform_driver_register(&qcom_hwspinlock_driver);\r\n}\r\nstatic void __exit qcom_hwspinlock_exit(void)\r\n{\r\nplatform_driver_unregister(&qcom_hwspinlock_driver);\r\n}
