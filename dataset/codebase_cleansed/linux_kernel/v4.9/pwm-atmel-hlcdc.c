static inline struct atmel_hlcdc_pwm *to_atmel_hlcdc_pwm(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct atmel_hlcdc_pwm, chip);\r\n}\r\nstatic int atmel_hlcdc_pwm_config(struct pwm_chip *c,\r\nstruct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = to_atmel_hlcdc_pwm(c);\r\nstruct atmel_hlcdc *hlcdc = chip->hlcdc;\r\nstruct clk *new_clk = hlcdc->slow_clk;\r\nu64 pwmcval = duty_ns * 256;\r\nunsigned long clk_freq;\r\nu64 clk_period_ns;\r\nu32 pwmcfg;\r\nint pres;\r\nif (!chip->errata || !chip->errata->slow_clk_erratum) {\r\nclk_freq = clk_get_rate(new_clk);\r\nif (!clk_freq)\r\nreturn -EINVAL;\r\nclk_period_ns = (u64)NSEC_PER_SEC * 256;\r\ndo_div(clk_period_ns, clk_freq);\r\n}\r\nif ((chip->errata && chip->errata->slow_clk_erratum) ||\r\nclk_period_ns > period_ns) {\r\nnew_clk = hlcdc->sys_clk;\r\nclk_freq = clk_get_rate(new_clk);\r\nif (!clk_freq)\r\nreturn -EINVAL;\r\nclk_period_ns = (u64)NSEC_PER_SEC * 256;\r\ndo_div(clk_period_ns, clk_freq);\r\n}\r\nfor (pres = 0; pres <= ATMEL_HLCDC_PWMPS_MAX; pres++) {\r\nif (!pres && chip->errata && chip->errata->div1_clk_erratum)\r\ncontinue;\r\nif ((clk_period_ns << pres) >= period_ns)\r\nbreak;\r\n}\r\nif (pres > ATMEL_HLCDC_PWMPS_MAX)\r\nreturn -EINVAL;\r\npwmcfg = ATMEL_HLCDC_PWMPS(pres);\r\nif (new_clk != chip->cur_clk) {\r\nu32 gencfg = 0;\r\nint ret;\r\nret = clk_prepare_enable(new_clk);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(chip->cur_clk);\r\nchip->cur_clk = new_clk;\r\nif (new_clk == hlcdc->sys_clk)\r\ngencfg = ATMEL_HLCDC_CLKPWMSEL;\r\nret = regmap_update_bits(hlcdc->regmap, ATMEL_HLCDC_CFG(0),\r\nATMEL_HLCDC_CLKPWMSEL, gencfg);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndo_div(pwmcval, period_ns);\r\nif (pwmcval > 255)\r\npwmcval = 255;\r\npwmcfg |= ATMEL_HLCDC_PWMCVAL(pwmcval);\r\nreturn regmap_update_bits(hlcdc->regmap, ATMEL_HLCDC_CFG(6),\r\nATMEL_HLCDC_PWMCVAL_MASK |\r\nATMEL_HLCDC_PWMPS_MASK,\r\npwmcfg);\r\n}\r\nstatic int atmel_hlcdc_pwm_set_polarity(struct pwm_chip *c,\r\nstruct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = to_atmel_hlcdc_pwm(c);\r\nstruct atmel_hlcdc *hlcdc = chip->hlcdc;\r\nu32 cfg = 0;\r\nif (polarity == PWM_POLARITY_NORMAL)\r\ncfg = ATMEL_HLCDC_PWMPOL;\r\nreturn regmap_update_bits(hlcdc->regmap, ATMEL_HLCDC_CFG(6),\r\nATMEL_HLCDC_PWMPOL, cfg);\r\n}\r\nstatic int atmel_hlcdc_pwm_enable(struct pwm_chip *c, struct pwm_device *pwm)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = to_atmel_hlcdc_pwm(c);\r\nstruct atmel_hlcdc *hlcdc = chip->hlcdc;\r\nu32 status;\r\nint ret;\r\nret = regmap_write(hlcdc->regmap, ATMEL_HLCDC_EN, ATMEL_HLCDC_PWM);\r\nif (ret)\r\nreturn ret;\r\nwhile (true) {\r\nret = regmap_read(hlcdc->regmap, ATMEL_HLCDC_SR, &status);\r\nif (ret)\r\nreturn ret;\r\nif ((status & ATMEL_HLCDC_PWM) != 0)\r\nbreak;\r\nusleep_range(1, 10);\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_hlcdc_pwm_disable(struct pwm_chip *c,\r\nstruct pwm_device *pwm)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = to_atmel_hlcdc_pwm(c);\r\nstruct atmel_hlcdc *hlcdc = chip->hlcdc;\r\nu32 status;\r\nint ret;\r\nret = regmap_write(hlcdc->regmap, ATMEL_HLCDC_DIS, ATMEL_HLCDC_PWM);\r\nif (ret)\r\nreturn;\r\nwhile (true) {\r\nret = regmap_read(hlcdc->regmap, ATMEL_HLCDC_SR, &status);\r\nif (ret)\r\nreturn;\r\nif ((status & ATMEL_HLCDC_PWM) == 0)\r\nbreak;\r\nusleep_range(1, 10);\r\n}\r\n}\r\nstatic int atmel_hlcdc_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device *dev = &pdev->dev;\r\nstruct atmel_hlcdc_pwm *chip;\r\nstruct atmel_hlcdc *hlcdc;\r\nint ret;\r\nhlcdc = dev_get_drvdata(dev->parent);\r\nchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nret = clk_prepare_enable(hlcdc->periph_clk);\r\nif (ret)\r\nreturn ret;\r\nmatch = of_match_node(atmel_hlcdc_dt_ids, dev->parent->of_node);\r\nif (match)\r\nchip->errata = match->data;\r\nchip->hlcdc = hlcdc;\r\nchip->chip.ops = &atmel_hlcdc_pwm_ops;\r\nchip->chip.dev = dev;\r\nchip->chip.base = -1;\r\nchip->chip.npwm = 1;\r\nchip->chip.of_xlate = of_pwm_xlate_with_flags;\r\nchip->chip.of_pwm_n_cells = 3;\r\nchip->chip.can_sleep = 1;\r\nret = pwmchip_add_with_polarity(&chip->chip, PWM_POLARITY_INVERSED);\r\nif (ret) {\r\nclk_disable_unprepare(hlcdc->periph_clk);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, chip);\r\nreturn 0;\r\n}\r\nstatic int atmel_hlcdc_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_hlcdc_pwm *chip = platform_get_drvdata(pdev);\r\nint ret;\r\nret = pwmchip_remove(&chip->chip);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(chip->hlcdc->periph_clk);\r\nreturn 0;\r\n}
