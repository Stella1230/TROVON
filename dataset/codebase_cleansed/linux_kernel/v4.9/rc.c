static u8 _rtl_rc_get_highest_rix(struct rtl_priv *rtlpriv,\r\nstruct ieee80211_sta *sta,\r\nstruct sk_buff *skb, bool not_data)\r\n{\r\nstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_sta_info *sta_entry = NULL;\r\nu16 wireless_mode = 0;\r\nif (sta) {\r\nsta_entry = (struct rtl_sta_info *)sta->drv_priv;\r\nwireless_mode = sta_entry->wireless_mode;\r\n}\r\nif (rtl_is_special_data(rtlpriv->mac80211.hw, skb, true, false) ||\r\nnot_data) {\r\nreturn 0;\r\n} else {\r\nif (rtlhal->current_bandtype == BAND_ON_2_4G) {\r\nif (wireless_mode == WIRELESS_MODE_B) {\r\nreturn B_MODE_MAX_RIX;\r\n} else if (wireless_mode == WIRELESS_MODE_G) {\r\nreturn G_MODE_MAX_RIX;\r\n} else if (wireless_mode == WIRELESS_MODE_N_24G) {\r\nif (get_rf_type(rtlphy) != RF_2T2R)\r\nreturn N_MODE_MCS7_RIX;\r\nelse\r\nreturn N_MODE_MCS15_RIX;\r\n} else if (wireless_mode == WIRELESS_MODE_AC_24G) {\r\nreturn AC_MODE_MCS9_RIX;\r\n}\r\nreturn 0;\r\n} else {\r\nif (wireless_mode == WIRELESS_MODE_A) {\r\nreturn A_MODE_MAX_RIX;\r\n} else if (wireless_mode == WIRELESS_MODE_N_5G) {\r\nif (get_rf_type(rtlphy) != RF_2T2R)\r\nreturn N_MODE_MCS7_RIX;\r\nelse\r\nreturn N_MODE_MCS15_RIX;\r\n} else if (wireless_mode == WIRELESS_MODE_AC_5G) {\r\nreturn AC_MODE_MCS9_RIX;\r\n}\r\nreturn 0;\r\n}\r\n}\r\n}\r\nstatic void _rtl_rc_rate_set_series(struct rtl_priv *rtlpriv,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_tx_rate *rate,\r\nstruct ieee80211_tx_rate_control *txrc,\r\nu8 tries, s8 rix, int rtsctsenable,\r\nbool not_data)\r\n{\r\nstruct rtl_mac *mac = rtl_mac(rtlpriv);\r\nstruct rtl_sta_info *sta_entry = NULL;\r\nu16 wireless_mode = 0;\r\nu8 sgi_20 = 0, sgi_40 = 0, sgi_80 = 0;\r\nif (sta) {\r\nsgi_20 = sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20;\r\nsgi_40 = sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40;\r\nsgi_80 = sta->vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80;\r\nsta_entry = (struct rtl_sta_info *)sta->drv_priv;\r\nwireless_mode = sta_entry->wireless_mode;\r\n}\r\nrate->count = tries;\r\nrate->idx = rix >= 0x00 ? rix : 0x00;\r\nif (rtlpriv->rtlhal.hw_type == HARDWARE_TYPE_RTL8812AE &&\r\nwireless_mode == WIRELESS_MODE_AC_5G)\r\nrate->idx += 0x10;\r\nif (!not_data) {\r\nif (txrc->short_preamble)\r\nrate->flags |= IEEE80211_TX_RC_USE_SHORT_PREAMBLE;\r\nif (mac->opmode == NL80211_IFTYPE_AP ||\r\nmac->opmode == NL80211_IFTYPE_ADHOC) {\r\nif (sta && (sta->ht_cap.cap &\r\nIEEE80211_HT_CAP_SUP_WIDTH_20_40))\r\nrate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (sta && (sta->vht_cap.vht_supported))\r\nrate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;\r\n} else {\r\nif (mac->bw_40)\r\nrate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (mac->bw_80)\r\nrate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;\r\n}\r\nif (sgi_20 || sgi_40 || sgi_80)\r\nrate->flags |= IEEE80211_TX_RC_SHORT_GI;\r\nif (sta && sta->ht_cap.ht_supported &&\r\n((wireless_mode == WIRELESS_MODE_N_5G) ||\r\n(wireless_mode == WIRELESS_MODE_N_24G)))\r\nrate->flags |= IEEE80211_TX_RC_MCS;\r\nif (sta && sta->vht_cap.vht_supported &&\r\n(wireless_mode == WIRELESS_MODE_AC_5G ||\r\nwireless_mode == WIRELESS_MODE_AC_24G ||\r\nwireless_mode == WIRELESS_MODE_AC_ONLY))\r\nrate->flags |= IEEE80211_TX_RC_VHT_MCS;\r\n}\r\n}\r\nstatic void rtl_get_rate(void *ppriv, struct ieee80211_sta *sta,\r\nvoid *priv_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct rtl_priv *rtlpriv = ppriv;\r\nstruct sk_buff *skb = txrc->skb;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_tx_rate *rates = tx_info->control.rates;\r\n__le16 fc = rtl_get_fc(skb);\r\nu8 try_per_rate, i, rix;\r\nbool not_data = !ieee80211_is_data(fc);\r\nif (rate_control_send_low(sta, priv_sta, txrc))\r\nreturn;\r\nrix = _rtl_rc_get_highest_rix(rtlpriv, sta, skb, not_data);\r\ntry_per_rate = 1;\r\n_rtl_rc_rate_set_series(rtlpriv, sta, &rates[0], txrc,\r\ntry_per_rate, rix, 1, not_data);\r\nif (!not_data) {\r\nfor (i = 1; i < 4; i++)\r\n_rtl_rc_rate_set_series(rtlpriv, sta, &rates[i],\r\ntxrc, i, (rix - i), 1,\r\nnot_data);\r\n}\r\n}\r\nstatic bool _rtl_tx_aggr_check(struct rtl_priv *rtlpriv,\r\nstruct rtl_sta_info *sta_entry, u16 tid)\r\n{\r\nstruct rtl_mac *mac = rtl_mac(rtlpriv);\r\nif (mac->act_scanning)\r\nreturn false;\r\nif (mac->opmode == NL80211_IFTYPE_STATION &&\r\nmac->cnt_after_linked < 3)\r\nreturn false;\r\nif (sta_entry->tids[tid].agg.agg_state == RTL_AGG_STOP)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void rtl_tx_status(void *ppriv,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rtl_priv *rtlpriv = ppriv;\r\nstruct rtl_mac *mac = rtl_mac(rtlpriv);\r\nstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\r\n__le16 fc = rtl_get_fc(skb);\r\nstruct rtl_sta_info *sta_entry;\r\nif (!priv_sta || !ieee80211_is_data(fc))\r\nreturn;\r\nif (rtl_is_special_data(mac->hw, skb, true, true))\r\nreturn;\r\nif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\r\nis_broadcast_ether_addr(ieee80211_get_DA(hdr)))\r\nreturn;\r\nif (sta) {\r\nsta_entry = (struct rtl_sta_info *) sta->drv_priv;\r\nif ((sta->ht_cap.ht_supported) &&\r\n!(skb->protocol == cpu_to_be16(ETH_P_PAE))) {\r\nif (ieee80211_is_data_qos(fc)) {\r\nu8 tid = rtl_get_tid(skb);\r\nif (_rtl_tx_aggr_check(rtlpriv, sta_entry,\r\ntid)) {\r\nsta_entry->tids[tid].agg.agg_state =\r\nRTL_AGG_PROGRESS;\r\nieee80211_start_tx_ba_session(sta, tid,\r\n5000);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void rtl_rate_init(void *ppriv,\r\nstruct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\n}\r\nstatic void rtl_rate_update(void *ppriv,\r\nstruct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nu32 changed)\r\n{\r\n}\r\nstatic void *rtl_rate_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nreturn rtlpriv;\r\n}\r\nstatic void rtl_rate_free(void *rtlpriv)\r\n{\r\nreturn;\r\n}\r\nstatic void *rtl_rate_alloc_sta(void *ppriv,\r\nstruct ieee80211_sta *sta, gfp_t gfp)\r\n{\r\nstruct rtl_priv *rtlpriv = ppriv;\r\nstruct rtl_rate_priv *rate_priv;\r\nrate_priv = kzalloc(sizeof(struct rtl_rate_priv), gfp);\r\nif (!rate_priv) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Unable to allocate private rc structure\n");\r\nreturn NULL;\r\n}\r\nrtlpriv->rate_priv = rate_priv;\r\nreturn rate_priv;\r\n}\r\nstatic void rtl_rate_free_sta(void *rtlpriv,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct rtl_rate_priv *rate_priv = priv_sta;\r\nkfree(rate_priv);\r\n}\r\nint rtl_rate_control_register(void)\r\n{\r\nreturn ieee80211_rate_control_register(&rtl_rate_ops);\r\n}\r\nvoid rtl_rate_control_unregister(void)\r\n{\r\nieee80211_rate_control_unregister(&rtl_rate_ops);\r\n}
