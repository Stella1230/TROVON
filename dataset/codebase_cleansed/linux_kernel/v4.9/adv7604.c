static bool adv76xx_has_afe(struct adv76xx_state *state)\r\n{\r\nreturn state->info->has_afe;\r\n}\r\nstatic bool adv76xx_check_dv_timings(const struct v4l2_dv_timings *t, void *hdl)\r\n{\r\nint i;\r\nfor (i = 0; adv76xx_timings_exceptions[i].bt.width; i++)\r\nif (v4l2_match_dv_timings(t, adv76xx_timings_exceptions + i, 0, false))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline struct adv76xx_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv76xx_state, sd);\r\n}\r\nstatic inline unsigned htotal(const struct v4l2_bt_timings *t)\r\n{\r\nreturn V4L2_DV_BT_FRAME_WIDTH(t);\r\n}\r\nstatic inline unsigned vtotal(const struct v4l2_bt_timings *t)\r\n{\r\nreturn V4L2_DV_BT_FRAME_HEIGHT(t);\r\n}\r\nstatic int adv76xx_read_check(struct adv76xx_state *state,\r\nint client_page, u8 reg)\r\n{\r\nstruct i2c_client *client = state->i2c_clients[client_page];\r\nint err;\r\nunsigned int val;\r\nerr = regmap_read(state->regmap[client_page], reg, &val);\r\nif (err) {\r\nv4l_err(client, "error reading %02x, %02x\n",\r\nclient->addr, reg);\r\nreturn err;\r\n}\r\nreturn val;\r\n}\r\nstatic int adv76xx_write_block(struct adv76xx_state *state, int client_page,\r\nunsigned int init_reg, const void *val,\r\nsize_t val_len)\r\n{\r\nstruct regmap *regmap = state->regmap[client_page];\r\nif (val_len > I2C_SMBUS_BLOCK_MAX)\r\nval_len = I2C_SMBUS_BLOCK_MAX;\r\nreturn regmap_raw_write(regmap, init_reg, val, val_len);\r\n}\r\nstatic inline int io_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV76XX_PAGE_IO, reg);\r\n}\r\nstatic inline int io_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_IO], reg, val);\r\n}\r\nstatic inline int io_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask,\r\nu8 val)\r\n{\r\nreturn io_write(sd, reg, (io_read(sd, reg) & ~mask) | val);\r\n}\r\nstatic inline int avlink_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV7604_PAGE_AVLINK, reg);\r\n}\r\nstatic inline int avlink_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV7604_PAGE_AVLINK], reg, val);\r\n}\r\nstatic inline int cec_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV76XX_PAGE_CEC, reg);\r\n}\r\nstatic inline int cec_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_CEC], reg, val);\r\n}\r\nstatic inline int cec_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask,\r\nu8 val)\r\n{\r\nreturn cec_write(sd, reg, (cec_read(sd, reg) & ~mask) | val);\r\n}\r\nstatic inline int infoframe_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV76XX_PAGE_INFOFRAME, reg);\r\n}\r\nstatic inline int infoframe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_INFOFRAME], reg, val);\r\n}\r\nstatic inline int afe_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV76XX_PAGE_AFE, reg);\r\n}\r\nstatic inline int afe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_AFE], reg, val);\r\n}\r\nstatic inline int rep_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV76XX_PAGE_REP, reg);\r\n}\r\nstatic inline int rep_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_REP], reg, val);\r\n}\r\nstatic inline int rep_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn rep_write(sd, reg, (rep_read(sd, reg) & ~mask) | val);\r\n}\r\nstatic inline int edid_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV76XX_PAGE_EDID, reg);\r\n}\r\nstatic inline int edid_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_EDID], reg, val);\r\n}\r\nstatic inline int edid_write_block(struct v4l2_subdev *sd,\r\nunsigned int total_len, const u8 *val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nint err = 0;\r\nint i = 0;\r\nint len = 0;\r\nv4l2_dbg(2, debug, sd, "%s: write EDID block (%d byte)\n",\r\n__func__, total_len);\r\nwhile (!err && i < total_len) {\r\nlen = (total_len - i) > I2C_SMBUS_BLOCK_MAX ?\r\nI2C_SMBUS_BLOCK_MAX :\r\n(total_len - i);\r\nerr = adv76xx_write_block(state, ADV76XX_PAGE_EDID,\r\ni, val + i, len);\r\ni += len;\r\n}\r\nreturn err;\r\n}\r\nstatic void adv76xx_set_hpd(struct adv76xx_state *state, unsigned int hpd)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < state->info->num_dv_ports; ++i)\r\ngpiod_set_value_cansleep(state->hpd_gpio[i], hpd & BIT(i));\r\nv4l2_subdev_notify(&state->sd, ADV76XX_HOTPLUG, &hpd);\r\n}\r\nstatic void adv76xx_delayed_work_enable_hotplug(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct adv76xx_state *state = container_of(dwork, struct adv76xx_state,\r\ndelayed_work_enable_hotplug);\r\nstruct v4l2_subdev *sd = &state->sd;\r\nv4l2_dbg(2, debug, sd, "%s: enable hotplug\n", __func__);\r\nadv76xx_set_hpd(state, state->edid.present);\r\n}\r\nstatic inline int hdmi_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV76XX_PAGE_HDMI, reg);\r\n}\r\nstatic u16 hdmi_read16(struct v4l2_subdev *sd, u8 reg, u16 mask)\r\n{\r\nreturn ((hdmi_read(sd, reg) << 8) | hdmi_read(sd, reg + 1)) & mask;\r\n}\r\nstatic inline int hdmi_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_HDMI], reg, val);\r\n}\r\nstatic inline int hdmi_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn hdmi_write(sd, reg, (hdmi_read(sd, reg) & ~mask) | val);\r\n}\r\nstatic inline int test_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_TEST], reg, val);\r\n}\r\nstatic inline int cp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV76XX_PAGE_CP, reg);\r\n}\r\nstatic u16 cp_read16(struct v4l2_subdev *sd, u8 reg, u16 mask)\r\n{\r\nreturn ((cp_read(sd, reg) << 8) | cp_read(sd, reg + 1)) & mask;\r\n}\r\nstatic inline int cp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV76XX_PAGE_CP], reg, val);\r\n}\r\nstatic inline int cp_write_clr_set(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn cp_write(sd, reg, (cp_read(sd, reg) & ~mask) | val);\r\n}\r\nstatic inline int vdp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn adv76xx_read_check(state, ADV7604_PAGE_VDP, reg);\r\n}\r\nstatic inline int vdp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn regmap_write(state->regmap[ADV7604_PAGE_VDP], reg, val);\r\n}\r\nstatic int adv76xx_read_reg(struct v4l2_subdev *sd, unsigned int reg)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nunsigned int page = reg >> 8;\r\nunsigned int val;\r\nint err;\r\nif (!(BIT(page) & state->info->page_mask))\r\nreturn -EINVAL;\r\nreg &= 0xff;\r\nerr = regmap_read(state->regmap[page], reg, &val);\r\nreturn err ? err : val;\r\n}\r\nstatic int adv76xx_write_reg(struct v4l2_subdev *sd, unsigned int reg, u8 val)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nunsigned int page = reg >> 8;\r\nif (!(BIT(page) & state->info->page_mask))\r\nreturn -EINVAL;\r\nreg &= 0xff;\r\nreturn regmap_write(state->regmap[page], reg, val);\r\n}\r\nstatic void adv76xx_write_reg_seq(struct v4l2_subdev *sd,\r\nconst struct adv76xx_reg_seq *reg_seq)\r\n{\r\nunsigned int i;\r\nfor (i = 0; reg_seq[i].reg != ADV76XX_REG_SEQ_TERM; i++)\r\nadv76xx_write_reg(sd, reg_seq[i].reg, reg_seq[i].val);\r\n}\r\nstatic const struct adv76xx_format_info *\r\nadv76xx_format_info(struct adv76xx_state *state, u32 code)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < state->info->nformats; ++i) {\r\nif (state->info->formats[i].code == code)\r\nreturn &state->info->formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline bool is_analog_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn state->selected_input == ADV7604_PAD_VGA_RGB ||\r\nstate->selected_input == ADV7604_PAD_VGA_COMP;\r\n}\r\nstatic inline bool is_digital_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn state->selected_input == ADV76XX_PAD_HDMI_PORT_A ||\r\nstate->selected_input == ADV7604_PAD_HDMI_PORT_B ||\r\nstate->selected_input == ADV7604_PAD_HDMI_PORT_C ||\r\nstate->selected_input == ADV7604_PAD_HDMI_PORT_D;\r\n}\r\nstatic const struct v4l2_dv_timings_cap *\r\nadv76xx_get_dv_timings_cap(struct v4l2_subdev *sd, int pad)\r\n{\r\nif (pad == -1) {\r\nstruct adv76xx_state *state = to_state(sd);\r\npad = state->selected_input;\r\n}\r\nswitch (pad) {\r\ncase ADV76XX_PAD_HDMI_PORT_A:\r\ncase ADV7604_PAD_HDMI_PORT_B:\r\ncase ADV7604_PAD_HDMI_PORT_C:\r\ncase ADV7604_PAD_HDMI_PORT_D:\r\nreturn &adv76xx_timings_cap_digital;\r\ncase ADV7604_PAD_VGA_RGB:\r\ncase ADV7604_PAD_VGA_COMP:\r\ndefault:\r\nreturn &adv7604_timings_cap_analog;\r\n}\r\n}\r\nstatic void adv76xx_inv_register(struct v4l2_subdev *sd)\r\n{\r\nv4l2_info(sd, "0x000-0x0ff: IO Map\n");\r\nv4l2_info(sd, "0x100-0x1ff: AVLink Map\n");\r\nv4l2_info(sd, "0x200-0x2ff: CEC Map\n");\r\nv4l2_info(sd, "0x300-0x3ff: InfoFrame Map\n");\r\nv4l2_info(sd, "0x400-0x4ff: ESDP Map\n");\r\nv4l2_info(sd, "0x500-0x5ff: DPP Map\n");\r\nv4l2_info(sd, "0x600-0x6ff: AFE Map\n");\r\nv4l2_info(sd, "0x700-0x7ff: Repeater Map\n");\r\nv4l2_info(sd, "0x800-0x8ff: EDID Map\n");\r\nv4l2_info(sd, "0x900-0x9ff: HDMI Map\n");\r\nv4l2_info(sd, "0xa00-0xaff: Test Map\n");\r\nv4l2_info(sd, "0xb00-0xbff: CP Map\n");\r\nv4l2_info(sd, "0xc00-0xcff: VDP Map\n");\r\n}\r\nstatic int adv76xx_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nint ret;\r\nret = adv76xx_read_reg(sd, reg->reg);\r\nif (ret < 0) {\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv76xx_inv_register(sd);\r\nreturn ret;\r\n}\r\nreg->size = 1;\r\nreg->val = ret;\r\nreturn 0;\r\n}\r\nstatic int adv76xx_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nint ret;\r\nret = adv76xx_write_reg(sd, reg->reg, reg->val);\r\nif (ret < 0) {\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv76xx_inv_register(sd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int adv7604_read_cable_det(struct v4l2_subdev *sd)\r\n{\r\nu8 value = io_read(sd, 0x6f);\r\nreturn ((value & 0x10) >> 4)\r\n| ((value & 0x08) >> 2)\r\n| ((value & 0x04) << 0)\r\n| ((value & 0x02) << 2);\r\n}\r\nstatic unsigned int adv7611_read_cable_det(struct v4l2_subdev *sd)\r\n{\r\nu8 value = io_read(sd, 0x6f);\r\nreturn value & 1;\r\n}\r\nstatic unsigned int adv7612_read_cable_det(struct v4l2_subdev *sd)\r\n{\r\nu8 value = io_read(sd, 0x6f);\r\nreturn value & 1;\r\n}\r\nstatic int adv76xx_s_detect_tx_5v_ctrl(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nu16 cable_det = info->read_cable_det(sd);\r\nreturn v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl, cable_det);\r\n}\r\nstatic int find_and_set_predefined_video_timings(struct v4l2_subdev *sd,\r\nu8 prim_mode,\r\nconst struct adv76xx_video_standards *predef_vid_timings,\r\nconst struct v4l2_dv_timings *timings)\r\n{\r\nint i;\r\nfor (i = 0; predef_vid_timings[i].timings.bt.width; i++) {\r\nif (!v4l2_match_dv_timings(timings, &predef_vid_timings[i].timings,\r\nis_digital_input(sd) ? 250000 : 1000000, false))\r\ncontinue;\r\nio_write(sd, 0x00, predef_vid_timings[i].vid_std);\r\nio_write(sd, 0x01, (predef_vid_timings[i].v_freq << 4) +\r\nprim_mode);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int configure_predefined_video_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nint err;\r\nv4l2_dbg(1, debug, sd, "%s", __func__);\r\nif (adv76xx_has_afe(state)) {\r\nio_write(sd, 0x16, 0x43);\r\nio_write(sd, 0x17, 0x5a);\r\n}\r\ncp_write_clr_set(sd, 0x81, 0x10, 0x00);\r\ncp_write(sd, 0x8f, 0x00);\r\ncp_write(sd, 0x90, 0x00);\r\ncp_write(sd, 0xa2, 0x00);\r\ncp_write(sd, 0xa3, 0x00);\r\ncp_write(sd, 0xa4, 0x00);\r\ncp_write(sd, 0xa5, 0x00);\r\ncp_write(sd, 0xa6, 0x00);\r\ncp_write(sd, 0xa7, 0x00);\r\ncp_write(sd, 0xab, 0x00);\r\ncp_write(sd, 0xac, 0x00);\r\nif (is_analog_input(sd)) {\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x01, adv7604_prim_mode_comp, timings);\r\nif (err)\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x02, adv7604_prim_mode_gr, timings);\r\n} else if (is_digital_input(sd)) {\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x05, adv76xx_prim_mode_hdmi_comp, timings);\r\nif (err)\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x06, adv76xx_prim_mode_hdmi_gr, timings);\r\n} else {\r\nv4l2_dbg(2, debug, sd, "%s: Unknown port %d selected\n",\r\n__func__, state->selected_input);\r\nerr = -1;\r\n}\r\nreturn err;\r\n}\r\nstatic void configure_custom_video_timings(struct v4l2_subdev *sd,\r\nconst struct v4l2_bt_timings *bt)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nu32 width = htotal(bt);\r\nu32 height = vtotal(bt);\r\nu16 cp_start_sav = bt->hsync + bt->hbackporch - 4;\r\nu16 cp_start_eav = width - bt->hfrontporch;\r\nu16 cp_start_vbi = height - bt->vfrontporch;\r\nu16 cp_end_vbi = bt->vsync + bt->vbackporch;\r\nu16 ch1_fr_ll = (((u32)bt->pixelclock / 100) > 0) ?\r\n((width * (ADV76XX_FSC / 100)) / ((u32)bt->pixelclock / 100)) : 0;\r\nconst u8 pll[2] = {\r\n0xc0 | ((width >> 8) & 0x1f),\r\nwidth & 0xff\r\n};\r\nv4l2_dbg(2, debug, sd, "%s\n", __func__);\r\nif (is_analog_input(sd)) {\r\nio_write(sd, 0x00, 0x07);\r\nio_write(sd, 0x01, 0x02);\r\ncp_write_clr_set(sd, 0x81, 0x10, 0x10);\r\nif (regmap_raw_write(state->regmap[ADV76XX_PAGE_IO],\r\n0x16, pll, 2))\r\nv4l2_err(sd, "writing to reg 0x16 and 0x17 failed\n");\r\ncp_write(sd, 0xa2, (cp_start_sav >> 4) & 0xff);\r\ncp_write(sd, 0xa3, ((cp_start_sav & 0x0f) << 4) |\r\n((cp_start_eav >> 8) & 0x0f));\r\ncp_write(sd, 0xa4, cp_start_eav & 0xff);\r\ncp_write(sd, 0xa5, (cp_start_vbi >> 4) & 0xff);\r\ncp_write(sd, 0xa6, ((cp_start_vbi & 0xf) << 4) |\r\n((cp_end_vbi >> 8) & 0xf));\r\ncp_write(sd, 0xa7, cp_end_vbi & 0xff);\r\n} else if (is_digital_input(sd)) {\r\nio_write(sd, 0x00, 0x02);\r\nio_write(sd, 0x01, 0x06);\r\n} else {\r\nv4l2_dbg(2, debug, sd, "%s: Unknown port %d selected\n",\r\n__func__, state->selected_input);\r\n}\r\ncp_write(sd, 0x8f, (ch1_fr_ll >> 8) & 0x7);\r\ncp_write(sd, 0x90, ch1_fr_ll & 0xff);\r\ncp_write(sd, 0xab, (height >> 4) & 0xff);\r\ncp_write(sd, 0xac, (height & 0x0f) << 4);\r\n}\r\nstatic void adv76xx_set_offset(struct v4l2_subdev *sd, bool auto_offset, u16 offset_a, u16 offset_b, u16 offset_c)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nu8 offset_buf[4];\r\nif (auto_offset) {\r\noffset_a = 0x3ff;\r\noffset_b = 0x3ff;\r\noffset_c = 0x3ff;\r\n}\r\nv4l2_dbg(2, debug, sd, "%s: %s offset: a = 0x%x, b = 0x%x, c = 0x%x\n",\r\n__func__, auto_offset ? "Auto" : "Manual",\r\noffset_a, offset_b, offset_c);\r\noffset_buf[0] = (cp_read(sd, 0x77) & 0xc0) | ((offset_a & 0x3f0) >> 4);\r\noffset_buf[1] = ((offset_a & 0x00f) << 4) | ((offset_b & 0x3c0) >> 6);\r\noffset_buf[2] = ((offset_b & 0x03f) << 2) | ((offset_c & 0x300) >> 8);\r\noffset_buf[3] = offset_c & 0x0ff;\r\nif (regmap_raw_write(state->regmap[ADV76XX_PAGE_CP],\r\n0x77, offset_buf, 4))\r\nv4l2_err(sd, "%s: i2c error writing to CP reg 0x77, 0x78, 0x79, 0x7a\n", __func__);\r\n}\r\nstatic void adv76xx_set_gain(struct v4l2_subdev *sd, bool auto_gain, u16 gain_a, u16 gain_b, u16 gain_c)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nu8 gain_buf[4];\r\nu8 gain_man = 1;\r\nu8 agc_mode_man = 1;\r\nif (auto_gain) {\r\ngain_man = 0;\r\nagc_mode_man = 0;\r\ngain_a = 0x100;\r\ngain_b = 0x100;\r\ngain_c = 0x100;\r\n}\r\nv4l2_dbg(2, debug, sd, "%s: %s gain: a = 0x%x, b = 0x%x, c = 0x%x\n",\r\n__func__, auto_gain ? "Auto" : "Manual",\r\ngain_a, gain_b, gain_c);\r\ngain_buf[0] = ((gain_man << 7) | (agc_mode_man << 6) | ((gain_a & 0x3f0) >> 4));\r\ngain_buf[1] = (((gain_a & 0x00f) << 4) | ((gain_b & 0x3c0) >> 6));\r\ngain_buf[2] = (((gain_b & 0x03f) << 2) | ((gain_c & 0x300) >> 8));\r\ngain_buf[3] = ((gain_c & 0x0ff));\r\nif (regmap_raw_write(state->regmap[ADV76XX_PAGE_CP],\r\n0x73, gain_buf, 4))\r\nv4l2_err(sd, "%s: i2c error writing to CP reg 0x73, 0x74, 0x75, 0x76\n", __func__);\r\n}\r\nstatic void set_rgb_quantization_range(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nbool rgb_output = io_read(sd, 0x02) & 0x02;\r\nbool hdmi_signal = hdmi_read(sd, 0x05) & 0x80;\r\nu8 y = HDMI_COLORSPACE_RGB;\r\nif (hdmi_signal && (io_read(sd, 0x60) & 1))\r\ny = infoframe_read(sd, 0x01) >> 5;\r\nv4l2_dbg(2, debug, sd, "%s: RGB quantization range: %d, RGB out: %d, HDMI: %d\n",\r\n__func__, state->rgb_quantization_range,\r\nrgb_output, hdmi_signal);\r\nadv76xx_set_gain(sd, true, 0x0, 0x0, 0x0);\r\nadv76xx_set_offset(sd, true, 0x0, 0x0, 0x0);\r\nio_write_clr_set(sd, 0x02, 0x04, rgb_output ? 0 : 4);\r\nswitch (state->rgb_quantization_range) {\r\ncase V4L2_DV_RGB_RANGE_AUTO:\r\nif (state->selected_input == ADV7604_PAD_VGA_RGB) {\r\nio_write_clr_set(sd, 0x02, 0xf0, 0x10);\r\nbreak;\r\n}\r\nif (state->selected_input == ADV7604_PAD_VGA_COMP) {\r\nio_write_clr_set(sd, 0x02, 0xf0, 0xf0);\r\nbreak;\r\n}\r\nif (hdmi_signal) {\r\nio_write_clr_set(sd, 0x02, 0xf0, 0xf0);\r\nbreak;\r\n}\r\nif (state->timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO) {\r\nio_write_clr_set(sd, 0x02, 0xf0, 0x00);\r\n} else {\r\nio_write_clr_set(sd, 0x02, 0xf0, 0x10);\r\nif (is_digital_input(sd) && rgb_output) {\r\nadv76xx_set_offset(sd, false, 0x40, 0x40, 0x40);\r\n} else {\r\nadv76xx_set_gain(sd, false, 0xe0, 0xe0, 0xe0);\r\nadv76xx_set_offset(sd, false, 0x70, 0x70, 0x70);\r\n}\r\n}\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_LIMITED:\r\nif (state->selected_input == ADV7604_PAD_VGA_COMP) {\r\nio_write_clr_set(sd, 0x02, 0xf0, 0x20);\r\nbreak;\r\n}\r\nif (y != HDMI_COLORSPACE_RGB)\r\nbreak;\r\nio_write_clr_set(sd, 0x02, 0xf0, 0x00);\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_FULL:\r\nif (state->selected_input == ADV7604_PAD_VGA_COMP) {\r\nio_write_clr_set(sd, 0x02, 0xf0, 0x60);\r\nbreak;\r\n}\r\nif (y != HDMI_COLORSPACE_RGB)\r\nbreak;\r\nio_write_clr_set(sd, 0x02, 0xf0, 0x10);\r\nif (is_analog_input(sd) || hdmi_signal)\r\nbreak;\r\nif (rgb_output) {\r\nadv76xx_set_offset(sd, false, 0x40, 0x40, 0x40);\r\n} else {\r\nadv76xx_set_gain(sd, false, 0xe0, 0xe0, 0xe0);\r\nadv76xx_set_offset(sd, false, 0x70, 0x70, 0x70);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int adv76xx_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd =\r\n&container_of(ctrl->handler, struct adv76xx_state, hdl)->sd;\r\nstruct adv76xx_state *state = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncp_write(sd, 0x3c, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_CONTRAST:\r\ncp_write(sd, 0x3a, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\ncp_write(sd, 0x3b, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\ncp_write(sd, 0x3d, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_DV_RX_RGB_RANGE:\r\nstate->rgb_quantization_range = ctrl->val;\r\nset_rgb_quantization_range(sd);\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_ANALOG_SAMPLING_PHASE:\r\nif (!adv76xx_has_afe(state))\r\nreturn -EINVAL;\r\nafe_write(sd, 0xc8, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_FREE_RUN_COLOR_MANUAL:\r\ncp_write_clr_set(sd, 0xbf, 0x04, ctrl->val << 2);\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_FREE_RUN_COLOR:\r\ncp_write(sd, 0xc0, (ctrl->val & 0xff0000) >> 16);\r\ncp_write(sd, 0xc1, (ctrl->val & 0x00ff00) >> 8);\r\ncp_write(sd, 0xc2, (u8)(ctrl->val & 0x0000ff));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int adv76xx_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd =\r\n&container_of(ctrl->handler, struct adv76xx_state, hdl)->sd;\r\nif (ctrl->id == V4L2_CID_DV_RX_IT_CONTENT_TYPE) {\r\nctrl->val = V4L2_DV_IT_CONTENT_TYPE_NO_ITC;\r\nif ((io_read(sd, 0x60) & 1) && (infoframe_read(sd, 0x03) & 0x80))\r\nctrl->val = (infoframe_read(sd, 0x05) >> 4) & 3;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline bool no_power(struct v4l2_subdev *sd)\r\n{\r\nreturn io_read(sd, 0x0c) & 0x24;\r\n}\r\nstatic inline bool no_signal_tmds(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nreturn !(io_read(sd, 0x6a) & (0x10 >> state->selected_input));\r\n}\r\nstatic inline bool no_lock_tmds(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nreturn (io_read(sd, 0x6a) & info->tdms_lock_mask) != info->tdms_lock_mask;\r\n}\r\nstatic inline bool is_hdmi(struct v4l2_subdev *sd)\r\n{\r\nreturn hdmi_read(sd, 0x05) & 0x80;\r\n}\r\nstatic inline bool no_lock_sspd(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nif (adv76xx_has_afe(state))\r\nreturn false;\r\nreturn ((cp_read(sd, 0xb5) & 0xd0) != 0xd0);\r\n}\r\nstatic inline bool no_lock_stdi(struct v4l2_subdev *sd)\r\n{\r\nreturn !(cp_read(sd, 0xb1) & 0x80);\r\n}\r\nstatic inline bool no_signal(struct v4l2_subdev *sd)\r\n{\r\nbool ret;\r\nret = no_power(sd);\r\nret |= no_lock_stdi(sd);\r\nret |= no_lock_sspd(sd);\r\nif (is_digital_input(sd)) {\r\nret |= no_lock_tmds(sd);\r\nret |= no_signal_tmds(sd);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline bool no_lock_cp(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nif (!adv76xx_has_afe(state))\r\nreturn false;\r\nreturn io_read(sd, 0x12) & 0x01;\r\n}\r\nstatic inline bool in_free_run(struct v4l2_subdev *sd)\r\n{\r\nreturn cp_read(sd, 0xff) & 0x10;\r\n}\r\nstatic int adv76xx_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\n*status = 0;\r\n*status |= no_power(sd) ? V4L2_IN_ST_NO_POWER : 0;\r\n*status |= no_signal(sd) ? V4L2_IN_ST_NO_SIGNAL : 0;\r\nif (!in_free_run(sd) && no_lock_cp(sd))\r\n*status |= is_digital_input(sd) ?\r\nV4L2_IN_ST_NO_SYNC : V4L2_IN_ST_NO_H_LOCK;\r\nv4l2_dbg(1, debug, sd, "%s: status = 0x%x\n", __func__, *status);\r\nreturn 0;\r\n}\r\nstatic int stdi2dv_timings(struct v4l2_subdev *sd,\r\nstruct stdi_readback *stdi,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nu32 hfreq = (ADV76XX_FSC * 8) / stdi->bl;\r\nu32 pix_clk;\r\nint i;\r\nfor (i = 0; v4l2_dv_timings_presets[i].bt.width; i++) {\r\nconst struct v4l2_bt_timings *bt = &v4l2_dv_timings_presets[i].bt;\r\nif (!v4l2_valid_dv_timings(&v4l2_dv_timings_presets[i],\r\nadv76xx_get_dv_timings_cap(sd, -1),\r\nadv76xx_check_dv_timings, NULL))\r\ncontinue;\r\nif (vtotal(bt) != stdi->lcf + 1)\r\ncontinue;\r\nif (bt->vsync != stdi->lcvs)\r\ncontinue;\r\npix_clk = hfreq * htotal(bt);\r\nif ((pix_clk < bt->pixelclock + 1000000) &&\r\n(pix_clk > bt->pixelclock - 1000000)) {\r\n*timings = v4l2_dv_timings_presets[i];\r\nreturn 0;\r\n}\r\n}\r\nif (v4l2_detect_cvt(stdi->lcf + 1, hfreq, stdi->lcvs, 0,\r\n(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\r\n(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\r\nfalse, timings))\r\nreturn 0;\r\nif (v4l2_detect_gtf(stdi->lcf + 1, hfreq, stdi->lcvs,\r\n(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\r\n(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\r\nfalse, state->aspect_ratio, timings))\r\nreturn 0;\r\nv4l2_dbg(2, debug, sd,\r\n"%s: No format candidate found for lcvs = %d, lcf=%d, bl = %d, %chsync, %cvsync\n",\r\n__func__, stdi->lcvs, stdi->lcf, stdi->bl,\r\nstdi->hs_pol, stdi->vs_pol);\r\nreturn -1;\r\n}\r\nstatic int read_stdi(struct v4l2_subdev *sd, struct stdi_readback *stdi)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nu8 polarity;\r\nif (no_lock_stdi(sd) || no_lock_sspd(sd)) {\r\nv4l2_dbg(2, debug, sd, "%s: STDI and/or SSPD not locked\n", __func__);\r\nreturn -1;\r\n}\r\nstdi->bl = cp_read16(sd, 0xb1, 0x3fff);\r\nstdi->lcf = cp_read16(sd, info->lcf_reg, 0x7ff);\r\nstdi->lcvs = cp_read(sd, 0xb3) >> 3;\r\nstdi->interlaced = io_read(sd, 0x12) & 0x10;\r\nif (adv76xx_has_afe(state)) {\r\npolarity = cp_read(sd, 0xb5);\r\nif ((polarity & 0x03) == 0x01) {\r\nstdi->hs_pol = polarity & 0x10\r\n? (polarity & 0x08 ? '+' : '-') : 'x';\r\nstdi->vs_pol = polarity & 0x40\r\n? (polarity & 0x20 ? '+' : '-') : 'x';\r\n} else {\r\nstdi->hs_pol = 'x';\r\nstdi->vs_pol = 'x';\r\n}\r\n} else {\r\npolarity = hdmi_read(sd, 0x05);\r\nstdi->hs_pol = polarity & 0x20 ? '+' : '-';\r\nstdi->vs_pol = polarity & 0x10 ? '+' : '-';\r\n}\r\nif (no_lock_stdi(sd) || no_lock_sspd(sd)) {\r\nv4l2_dbg(2, debug, sd,\r\n"%s: signal lost during readout of STDI/SSPD\n", __func__);\r\nreturn -1;\r\n}\r\nif (stdi->lcf < 239 || stdi->bl < 8 || stdi->bl == 0x3fff) {\r\nv4l2_dbg(2, debug, sd, "%s: invalid signal\n", __func__);\r\nmemset(stdi, 0, sizeof(struct stdi_readback));\r\nreturn -1;\r\n}\r\nv4l2_dbg(2, debug, sd,\r\n"%s: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, %chsync, %cvsync, %s\n",\r\n__func__, stdi->lcf, stdi->bl, stdi->lcvs,\r\nstdi->hs_pol, stdi->vs_pol,\r\nstdi->interlaced ? "interlaced" : "progressive");\r\nreturn 0;\r\n}\r\nstatic int adv76xx_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nif (timings->pad >= state->source_pad)\r\nreturn -EINVAL;\r\nreturn v4l2_enum_dv_timings_cap(timings,\r\nadv76xx_get_dv_timings_cap(sd, timings->pad),\r\nadv76xx_check_dv_timings, NULL);\r\n}\r\nstatic int adv76xx_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nunsigned int pad = cap->pad;\r\nif (cap->pad >= state->source_pad)\r\nreturn -EINVAL;\r\n*cap = *adv76xx_get_dv_timings_cap(sd, pad);\r\ncap->pad = pad;\r\nreturn 0;\r\n}\r\nstatic void adv76xx_fill_optional_dv_timings_fields(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nv4l2_find_dv_timings_cap(timings, adv76xx_get_dv_timings_cap(sd, -1),\r\nis_digital_input(sd) ? 250000 : 1000000,\r\nadv76xx_check_dv_timings, NULL);\r\n}\r\nstatic unsigned int adv7604_read_hdmi_pixelclock(struct v4l2_subdev *sd)\r\n{\r\nunsigned int freq;\r\nint a, b;\r\na = hdmi_read(sd, 0x06);\r\nb = hdmi_read(sd, 0x3b);\r\nif (a < 0 || b < 0)\r\nreturn 0;\r\nfreq = a * 1000000 + ((b & 0x30) >> 4) * 250000;\r\nif (is_hdmi(sd)) {\r\nunsigned bits_per_channel = ((hdmi_read(sd, 0x0b) & 0x60) >> 4) + 8;\r\nfreq = freq * 8 / bits_per_channel;\r\n}\r\nreturn freq;\r\n}\r\nstatic unsigned int adv7611_read_hdmi_pixelclock(struct v4l2_subdev *sd)\r\n{\r\nint a, b;\r\na = hdmi_read(sd, 0x51);\r\nb = hdmi_read(sd, 0x52);\r\nif (a < 0 || b < 0)\r\nreturn 0;\r\nreturn ((a << 1) | (b >> 7)) * 1000000 + (b & 0x7f) * 1000000 / 128;\r\n}\r\nstatic int adv76xx_query_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nstruct v4l2_bt_timings *bt = &timings->bt;\r\nstruct stdi_readback stdi;\r\nif (!timings)\r\nreturn -EINVAL;\r\nmemset(timings, 0, sizeof(struct v4l2_dv_timings));\r\nif (no_signal(sd)) {\r\nstate->restart_stdi_once = true;\r\nv4l2_dbg(1, debug, sd, "%s: no valid signal\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nif (read_stdi(sd, &stdi)) {\r\nv4l2_dbg(1, debug, sd, "%s: STDI/SSPD not locked\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nbt->interlaced = stdi.interlaced ?\r\nV4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\r\nif (is_digital_input(sd)) {\r\ntimings->type = V4L2_DV_BT_656_1120;\r\nbt->width = hdmi_read16(sd, 0x07, info->linewidth_mask);\r\nbt->height = hdmi_read16(sd, 0x09, info->field0_height_mask);\r\nbt->pixelclock = info->read_hdmi_pixelclock(sd);\r\nbt->hfrontporch = hdmi_read16(sd, 0x20, info->hfrontporch_mask);\r\nbt->hsync = hdmi_read16(sd, 0x22, info->hsync_mask);\r\nbt->hbackporch = hdmi_read16(sd, 0x24, info->hbackporch_mask);\r\nbt->vfrontporch = hdmi_read16(sd, 0x2a,\r\ninfo->field0_vfrontporch_mask) / 2;\r\nbt->vsync = hdmi_read16(sd, 0x2e, info->field0_vsync_mask) / 2;\r\nbt->vbackporch = hdmi_read16(sd, 0x32,\r\ninfo->field0_vbackporch_mask) / 2;\r\nbt->polarities = ((hdmi_read(sd, 0x05) & 0x10) ? V4L2_DV_VSYNC_POS_POL : 0) |\r\n((hdmi_read(sd, 0x05) & 0x20) ? V4L2_DV_HSYNC_POS_POL : 0);\r\nif (bt->interlaced == V4L2_DV_INTERLACED) {\r\nbt->height += hdmi_read16(sd, 0x0b,\r\ninfo->field1_height_mask);\r\nbt->il_vfrontporch = hdmi_read16(sd, 0x2c,\r\ninfo->field1_vfrontporch_mask) / 2;\r\nbt->il_vsync = hdmi_read16(sd, 0x30,\r\ninfo->field1_vsync_mask) / 2;\r\nbt->il_vbackporch = hdmi_read16(sd, 0x34,\r\ninfo->field1_vbackporch_mask) / 2;\r\n}\r\nadv76xx_fill_optional_dv_timings_fields(sd, timings);\r\n} else {\r\nif (!stdi2dv_timings(sd, &stdi, timings))\r\ngoto found;\r\nstdi.lcvs += 1;\r\nv4l2_dbg(1, debug, sd, "%s: lcvs + 1 = %d\n", __func__, stdi.lcvs);\r\nif (!stdi2dv_timings(sd, &stdi, timings))\r\ngoto found;\r\nstdi.lcvs -= 2;\r\nv4l2_dbg(1, debug, sd, "%s: lcvs - 1 = %d\n", __func__, stdi.lcvs);\r\nif (stdi2dv_timings(sd, &stdi, timings)) {\r\nif (state->restart_stdi_once) {\r\nv4l2_dbg(1, debug, sd, "%s: restart STDI\n", __func__);\r\ncp_write_clr_set(sd, 0x86, 0x06, 0x00);\r\ncp_write_clr_set(sd, 0x86, 0x06, 0x04);\r\ncp_write_clr_set(sd, 0x86, 0x06, 0x02);\r\nstate->restart_stdi_once = false;\r\nreturn -ENOLINK;\r\n}\r\nv4l2_dbg(1, debug, sd, "%s: format not supported\n", __func__);\r\nreturn -ERANGE;\r\n}\r\nstate->restart_stdi_once = true;\r\n}\r\nfound:\r\nif (no_signal(sd)) {\r\nv4l2_dbg(1, debug, sd, "%s: signal lost during readout\n", __func__);\r\nmemset(timings, 0, sizeof(struct v4l2_dv_timings));\r\nreturn -ENOLINK;\r\n}\r\nif ((is_analog_input(sd) && bt->pixelclock > 170000000) ||\r\n(is_digital_input(sd) && bt->pixelclock > 225000000)) {\r\nv4l2_dbg(1, debug, sd, "%s: pixelclock out of range %d\n",\r\n__func__, (u32)bt->pixelclock);\r\nreturn -ERANGE;\r\n}\r\nif (debug > 1)\r\nv4l2_print_dv_timings(sd->name, "adv76xx_query_dv_timings: ",\r\ntimings, true);\r\nreturn 0;\r\n}\r\nstatic int adv76xx_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nstruct v4l2_bt_timings *bt;\r\nint err;\r\nif (!timings)\r\nreturn -EINVAL;\r\nif (v4l2_match_dv_timings(&state->timings, timings, 0, false)) {\r\nv4l2_dbg(1, debug, sd, "%s: no change\n", __func__);\r\nreturn 0;\r\n}\r\nbt = &timings->bt;\r\nif (!v4l2_valid_dv_timings(timings, adv76xx_get_dv_timings_cap(sd, -1),\r\nadv76xx_check_dv_timings, NULL))\r\nreturn -ERANGE;\r\nadv76xx_fill_optional_dv_timings_fields(sd, timings);\r\nstate->timings = *timings;\r\ncp_write_clr_set(sd, 0x91, 0x40, bt->interlaced ? 0x40 : 0x00);\r\nerr = configure_predefined_video_timings(sd, timings);\r\nif (err) {\r\nconfigure_custom_video_timings(sd, bt);\r\n}\r\nset_rgb_quantization_range(sd);\r\nif (debug > 1)\r\nv4l2_print_dv_timings(sd->name, "adv76xx_s_dv_timings: ",\r\ntimings, true);\r\nreturn 0;\r\n}\r\nstatic int adv76xx_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\n*timings = state->timings;\r\nreturn 0;\r\n}\r\nstatic void adv7604_set_termination(struct v4l2_subdev *sd, bool enable)\r\n{\r\nhdmi_write(sd, 0x01, enable ? 0x00 : 0x78);\r\n}\r\nstatic void adv7611_set_termination(struct v4l2_subdev *sd, bool enable)\r\n{\r\nhdmi_write(sd, 0x83, enable ? 0xfe : 0xff);\r\n}\r\nstatic void enable_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nif (is_analog_input(sd)) {\r\nio_write(sd, 0x15, 0xb0);\r\n} else if (is_digital_input(sd)) {\r\nhdmi_write_clr_set(sd, 0x00, 0x03, state->selected_input);\r\nstate->info->set_termination(sd, true);\r\nio_write(sd, 0x15, 0xa0);\r\nhdmi_write_clr_set(sd, 0x1a, 0x10, 0x00);\r\n} else {\r\nv4l2_dbg(2, debug, sd, "%s: Unknown port %d selected\n",\r\n__func__, state->selected_input);\r\n}\r\n}\r\nstatic void disable_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nhdmi_write_clr_set(sd, 0x1a, 0x10, 0x10);\r\nmsleep(16);\r\nio_write(sd, 0x15, 0xbe);\r\nstate->info->set_termination(sd, false);\r\n}\r\nstatic void select_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nif (is_analog_input(sd)) {\r\nadv76xx_write_reg_seq(sd, info->recommended_settings[0]);\r\nafe_write(sd, 0x00, 0x08);\r\nafe_write(sd, 0x01, 0x06);\r\nafe_write(sd, 0xc8, 0x00);\r\n} else if (is_digital_input(sd)) {\r\nhdmi_write(sd, 0x00, state->selected_input & 0x03);\r\nadv76xx_write_reg_seq(sd, info->recommended_settings[1]);\r\nif (adv76xx_has_afe(state)) {\r\nafe_write(sd, 0x00, 0xff);\r\nafe_write(sd, 0x01, 0xfe);\r\nafe_write(sd, 0xc8, 0x40);\r\n}\r\ncp_write(sd, 0x3e, 0x00);\r\ncp_write(sd, 0xc3, 0x39);\r\ncp_write(sd, 0x40, 0x80);\r\n} else {\r\nv4l2_dbg(2, debug, sd, "%s: Unknown port %d selected\n",\r\n__func__, state->selected_input);\r\n}\r\n}\r\nstatic int adv76xx_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nv4l2_dbg(2, debug, sd, "%s: input %d, selected input %d",\r\n__func__, input, state->selected_input);\r\nif (input == state->selected_input)\r\nreturn 0;\r\nif (input > state->info->max_port)\r\nreturn -EINVAL;\r\nstate->selected_input = input;\r\ndisable_input(sd);\r\nselect_input(sd);\r\nenable_input(sd);\r\nv4l2_subdev_notify_event(sd, &adv76xx_ev_fmt);\r\nreturn 0;\r\n}\r\nstatic int adv76xx_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nif (code->index >= state->info->nformats)\r\nreturn -EINVAL;\r\ncode->code = state->info->formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic void adv76xx_fill_format(struct adv76xx_state *state,\r\nstruct v4l2_mbus_framefmt *format)\r\n{\r\nmemset(format, 0, sizeof(*format));\r\nformat->width = state->timings.bt.width;\r\nformat->height = state->timings.bt.height;\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nif (state->timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO)\r\nformat->colorspace = (state->timings.bt.height <= 576) ?\r\nV4L2_COLORSPACE_SMPTE170M : V4L2_COLORSPACE_REC709;\r\n}\r\nstatic unsigned int adv76xx_op_ch_sel(struct adv76xx_state *state)\r\n{\r\n#define _SEL(a,b,c,d,e,f) { \\r\nADV76XX_OP_CH_SEL_##a, ADV76XX_OP_CH_SEL_##b, ADV76XX_OP_CH_SEL_##c, \\r\nADV76XX_OP_CH_SEL_##d, ADV76XX_OP_CH_SEL_##e, ADV76XX_OP_CH_SEL_##f }\r\n#define _BUS(x) [ADV7604_BUS_ORDER_##x]\r\nstatic const unsigned int op_ch_sel[6][6] = {\r\n_BUS(RGB) = _SEL(GBR, GRB, BGR, RGB, BRG, RBG),\r\n_BUS(GRB) = _SEL(BGR, RGB, GBR, GRB, RBG, BRG),\r\n_BUS(RBG) = _SEL(GRB, GBR, BRG, RBG, BGR, RGB),\r\n_BUS(BGR) = _SEL(RBG, BRG, RGB, BGR, GRB, GBR),\r\n_BUS(BRG) = _SEL(BRG, RBG, GRB, GBR, RGB, BGR),\r\n_BUS(GBR) = _SEL(RGB, BGR, RBG, BRG, GBR, GRB),\r\n};\r\nreturn op_ch_sel[state->pdata.bus_order][state->format->op_ch_sel >> 5];\r\n}\r\nstatic void adv76xx_setup_format(struct adv76xx_state *state)\r\n{\r\nstruct v4l2_subdev *sd = &state->sd;\r\nio_write_clr_set(sd, 0x02, 0x02,\r\nstate->format->rgb_out ? ADV76XX_RGB_OUT : 0);\r\nio_write(sd, 0x03, state->format->op_format_sel |\r\nstate->pdata.op_format_mode_sel);\r\nio_write_clr_set(sd, 0x04, 0xe0, adv76xx_op_ch_sel(state));\r\nio_write_clr_set(sd, 0x05, 0x01,\r\nstate->format->swap_cb_cr ? ADV76XX_OP_SWAP_CB_CR : 0);\r\nset_rgb_quantization_range(sd);\r\n}\r\nstatic int adv76xx_get_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nif (format->pad != state->source_pad)\r\nreturn -EINVAL;\r\nadv76xx_fill_format(state, &format->format);\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_mbus_framefmt *fmt;\r\nfmt = v4l2_subdev_get_try_format(sd, cfg, format->pad);\r\nformat->format.code = fmt->code;\r\n} else {\r\nformat->format.code = state->format->code;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv76xx_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nif (sel->target > V4L2_SEL_TGT_CROP_BOUNDS)\r\nreturn -EINVAL;\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = state->timings.bt.width;\r\nsel->r.height = state->timings.bt.height;\r\nreturn 0;\r\n}\r\nstatic int adv76xx_set_format(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_format_info *info;\r\nif (format->pad != state->source_pad)\r\nreturn -EINVAL;\r\ninfo = adv76xx_format_info(state, format->format.code);\r\nif (info == NULL)\r\ninfo = adv76xx_format_info(state, MEDIA_BUS_FMT_YUYV8_2X8);\r\nadv76xx_fill_format(state, &format->format);\r\nformat->format.code = info->code;\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_mbus_framefmt *fmt;\r\nfmt = v4l2_subdev_get_try_format(sd, cfg, format->pad);\r\nfmt->code = format->format.code;\r\n} else {\r\nstate->format = info;\r\nadv76xx_setup_format(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adv76xx_cec_tx_raw_status(struct v4l2_subdev *sd, u8 tx_raw_status)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nif ((cec_read(sd, 0x11) & 0x01) == 0) {\r\nv4l2_dbg(1, debug, sd, "%s: tx raw: tx disabled\n", __func__);\r\nreturn;\r\n}\r\nif (tx_raw_status & 0x02) {\r\nv4l2_dbg(1, debug, sd, "%s: tx raw: arbitration lost\n",\r\n__func__);\r\ncec_transmit_done(state->cec_adap, CEC_TX_STATUS_ARB_LOST,\r\n1, 0, 0, 0);\r\n}\r\nif (tx_raw_status & 0x04) {\r\nu8 status;\r\nu8 nack_cnt;\r\nu8 low_drive_cnt;\r\nv4l2_dbg(1, debug, sd, "%s: tx raw: retry failed\n", __func__);\r\nstatus = CEC_TX_STATUS_MAX_RETRIES;\r\nnack_cnt = cec_read(sd, 0x14) & 0xf;\r\nif (nack_cnt)\r\nstatus |= CEC_TX_STATUS_NACK;\r\nlow_drive_cnt = cec_read(sd, 0x14) >> 4;\r\nif (low_drive_cnt)\r\nstatus |= CEC_TX_STATUS_LOW_DRIVE;\r\ncec_transmit_done(state->cec_adap, status,\r\n0, nack_cnt, low_drive_cnt, 0);\r\nreturn;\r\n}\r\nif (tx_raw_status & 0x01) {\r\nv4l2_dbg(1, debug, sd, "%s: tx raw: ready ok\n", __func__);\r\ncec_transmit_done(state->cec_adap, CEC_TX_STATUS_OK, 0, 0, 0, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void adv76xx_cec_isr(struct v4l2_subdev *sd, bool *handled)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nu8 cec_irq;\r\ncec_irq = io_read(sd, 0x4d) & 0x0f;\r\nif (!cec_irq)\r\nreturn;\r\nv4l2_dbg(1, debug, sd, "%s: cec: irq 0x%x\n", __func__, cec_irq);\r\nadv76xx_cec_tx_raw_status(sd, cec_irq);\r\nif (cec_irq & 0x08) {\r\nstruct cec_msg msg;\r\nmsg.len = cec_read(sd, 0x25) & 0x1f;\r\nif (msg.len > 16)\r\nmsg.len = 16;\r\nif (msg.len) {\r\nu8 i;\r\nfor (i = 0; i < msg.len; i++)\r\nmsg.msg[i] = cec_read(sd, i + 0x15);\r\ncec_write(sd, 0x26, 0x01);\r\ncec_received_msg(state->cec_adap, &msg);\r\n}\r\n}\r\ncec_irq = ((cec_irq & 0x08) >> 3) | ((cec_irq & 0x04) >> 1) |\r\n((cec_irq & 0x02) << 1) | ((cec_irq & 0x01) << 3);\r\nio_write(sd, 0x4e, cec_irq);\r\nif (handled)\r\n*handled = true;\r\n}\r\nstatic int adv76xx_cec_adap_enable(struct cec_adapter *adap, bool enable)\r\n{\r\nstruct adv76xx_state *state = adap->priv;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nif (!state->cec_enabled_adap && enable) {\r\ncec_write_clr_set(sd, 0x2a, 0x01, 0x01);\r\ncec_write(sd, 0x2c, 0x01);\r\ncec_write_clr_set(sd, 0x11, 0x01, 0);\r\nio_write_clr_set(sd, 0x50, 0x0f, 0x0f);\r\ncec_write(sd, 0x26, 0x01);\r\n} else if (state->cec_enabled_adap && !enable) {\r\nio_write_clr_set(sd, 0x50, 0x0f, 0x00);\r\ncec_write_clr_set(sd, 0x27, 0x70, 0x00);\r\ncec_write_clr_set(sd, 0x2a, 0x01, 0x00);\r\nstate->cec_valid_addrs = 0;\r\n}\r\nstate->cec_enabled_adap = enable;\r\nadv76xx_s_detect_tx_5v_ctrl(sd);\r\nreturn 0;\r\n}\r\nstatic int adv76xx_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\r\n{\r\nstruct adv76xx_state *state = adap->priv;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nunsigned int i, free_idx = ADV76XX_MAX_ADDRS;\r\nif (!state->cec_enabled_adap)\r\nreturn addr == CEC_LOG_ADDR_INVALID ? 0 : -EIO;\r\nif (addr == CEC_LOG_ADDR_INVALID) {\r\ncec_write_clr_set(sd, 0x27, 0x70, 0);\r\nstate->cec_valid_addrs = 0;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ADV76XX_MAX_ADDRS; i++) {\r\nbool is_valid = state->cec_valid_addrs & (1 << i);\r\nif (free_idx == ADV76XX_MAX_ADDRS && !is_valid)\r\nfree_idx = i;\r\nif (is_valid && state->cec_addr[i] == addr)\r\nreturn 0;\r\n}\r\nif (i == ADV76XX_MAX_ADDRS) {\r\ni = free_idx;\r\nif (i == ADV76XX_MAX_ADDRS)\r\nreturn -ENXIO;\r\n}\r\nstate->cec_addr[i] = addr;\r\nstate->cec_valid_addrs |= 1 << i;\r\nswitch (i) {\r\ncase 0:\r\ncec_write_clr_set(sd, 0x27, 0x10, 0x10);\r\ncec_write_clr_set(sd, 0x28, 0x0f, addr);\r\nbreak;\r\ncase 1:\r\ncec_write_clr_set(sd, 0x27, 0x20, 0x20);\r\ncec_write_clr_set(sd, 0x28, 0xf0, addr << 4);\r\nbreak;\r\ncase 2:\r\ncec_write_clr_set(sd, 0x27, 0x40, 0x40);\r\ncec_write_clr_set(sd, 0x29, 0x0f, addr);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv76xx_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\r\nu32 signal_free_time, struct cec_msg *msg)\r\n{\r\nstruct adv76xx_state *state = adap->priv;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nu8 len = msg->len;\r\nunsigned int i;\r\ncec_write_clr_set(sd, 0x12, 0x70, max(1, attempts - 1) << 4);\r\nif (len > 16) {\r\nv4l2_err(sd, "%s: len exceeded 16 (%d)\n", __func__, len);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < len; i++)\r\ncec_write(sd, i, msg->msg[i]);\r\ncec_write(sd, 0x10, len);\r\ncec_write(sd, 0x11, 0x01);\r\nreturn 0;\r\n}\r\nstatic int adv76xx_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nconst u8 irq_reg_0x43 = io_read(sd, 0x43);\r\nconst u8 irq_reg_0x6b = io_read(sd, 0x6b);\r\nconst u8 irq_reg_0x70 = io_read(sd, 0x70);\r\nu8 fmt_change_digital;\r\nu8 fmt_change;\r\nu8 tx_5v;\r\nif (irq_reg_0x43)\r\nio_write(sd, 0x44, irq_reg_0x43);\r\nif (irq_reg_0x70)\r\nio_write(sd, 0x71, irq_reg_0x70);\r\nif (irq_reg_0x6b)\r\nio_write(sd, 0x6c, irq_reg_0x6b);\r\nv4l2_dbg(2, debug, sd, "%s: ", __func__);\r\nfmt_change = irq_reg_0x43 & 0x98;\r\nfmt_change_digital = is_digital_input(sd)\r\n? irq_reg_0x6b & info->fmt_change_digital_mask\r\n: 0;\r\nif (fmt_change || fmt_change_digital) {\r\nv4l2_dbg(1, debug, sd,\r\n"%s: fmt_change = 0x%x, fmt_change_digital = 0x%x\n",\r\n__func__, fmt_change, fmt_change_digital);\r\nv4l2_subdev_notify_event(sd, &adv76xx_ev_fmt);\r\nif (handled)\r\n*handled = true;\r\n}\r\nif (irq_reg_0x6b & 0x01) {\r\nv4l2_dbg(1, debug, sd, "%s: irq %s mode\n", __func__,\r\n(io_read(sd, 0x6a) & 0x01) ? "HDMI" : "DVI");\r\nset_rgb_quantization_range(sd);\r\nif (handled)\r\n*handled = true;\r\n}\r\n#if IS_ENABLED(CONFIG_VIDEO_ADV7604_CEC)\r\nadv76xx_cec_isr(sd, handled);\r\n#endif\r\ntx_5v = irq_reg_0x70 & info->cable_det_mask;\r\nif (tx_5v) {\r\nv4l2_dbg(1, debug, sd, "%s: tx_5v: 0x%x\n", __func__, tx_5v);\r\nadv76xx_s_detect_tx_5v_ctrl(sd);\r\nif (handled)\r\n*handled = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv76xx_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nu8 *data = NULL;\r\nmemset(edid->reserved, 0, sizeof(edid->reserved));\r\nswitch (edid->pad) {\r\ncase ADV76XX_PAD_HDMI_PORT_A:\r\ncase ADV7604_PAD_HDMI_PORT_B:\r\ncase ADV7604_PAD_HDMI_PORT_C:\r\ncase ADV7604_PAD_HDMI_PORT_D:\r\nif (state->edid.present & (1 << edid->pad))\r\ndata = state->edid.edid;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (edid->start_block == 0 && edid->blocks == 0) {\r\nedid->blocks = data ? state->edid.blocks : 0;\r\nreturn 0;\r\n}\r\nif (data == NULL)\r\nreturn -ENODATA;\r\nif (edid->start_block >= state->edid.blocks)\r\nreturn -EINVAL;\r\nif (edid->start_block + edid->blocks > state->edid.blocks)\r\nedid->blocks = state->edid.blocks - edid->start_block;\r\nmemcpy(edid->edid, data + edid->start_block * 128, edid->blocks * 128);\r\nreturn 0;\r\n}\r\nstatic int adv76xx_set_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nunsigned int spa_loc;\r\nu16 pa;\r\nint err;\r\nint i;\r\nmemset(edid->reserved, 0, sizeof(edid->reserved));\r\nif (edid->pad > ADV7604_PAD_HDMI_PORT_D)\r\nreturn -EINVAL;\r\nif (edid->start_block != 0)\r\nreturn -EINVAL;\r\nif (edid->blocks == 0) {\r\nstate->edid.present &= ~(1 << edid->pad);\r\nadv76xx_set_hpd(state, state->edid.present);\r\nrep_write_clr_set(sd, info->edid_enable_reg, 0x0f, state->edid.present);\r\nstate->aspect_ratio.numerator = 16;\r\nstate->aspect_ratio.denominator = 9;\r\nif (!state->edid.present)\r\nstate->edid.blocks = 0;\r\nv4l2_dbg(2, debug, sd, "%s: clear EDID pad %d, edid.present = 0x%x\n",\r\n__func__, edid->pad, state->edid.present);\r\nreturn 0;\r\n}\r\nif (edid->blocks > 2) {\r\nedid->blocks = 2;\r\nreturn -E2BIG;\r\n}\r\npa = cec_get_edid_phys_addr(edid->edid, edid->blocks * 128, &spa_loc);\r\nerr = cec_phys_addr_validate(pa, &pa, NULL);\r\nif (err)\r\nreturn err;\r\nv4l2_dbg(2, debug, sd, "%s: write EDID pad %d, edid.present = 0x%x\n",\r\n__func__, edid->pad, state->edid.present);\r\ncancel_delayed_work_sync(&state->delayed_work_enable_hotplug);\r\nadv76xx_set_hpd(state, 0);\r\nrep_write_clr_set(sd, info->edid_enable_reg, 0x0f, 0x00);\r\nif (spa_loc == 0)\r\nreturn -EINVAL;\r\nswitch (edid->pad) {\r\ncase ADV76XX_PAD_HDMI_PORT_A:\r\nstate->spa_port_a[0] = edid->edid[spa_loc];\r\nstate->spa_port_a[1] = edid->edid[spa_loc + 1];\r\nbreak;\r\ncase ADV7604_PAD_HDMI_PORT_B:\r\nrep_write(sd, 0x70, edid->edid[spa_loc]);\r\nrep_write(sd, 0x71, edid->edid[spa_loc + 1]);\r\nbreak;\r\ncase ADV7604_PAD_HDMI_PORT_C:\r\nrep_write(sd, 0x72, edid->edid[spa_loc]);\r\nrep_write(sd, 0x73, edid->edid[spa_loc + 1]);\r\nbreak;\r\ncase ADV7604_PAD_HDMI_PORT_D:\r\nrep_write(sd, 0x74, edid->edid[spa_loc]);\r\nrep_write(sd, 0x75, edid->edid[spa_loc + 1]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (info->type == ADV7604) {\r\nrep_write(sd, 0x76, spa_loc & 0xff);\r\nrep_write_clr_set(sd, 0x77, 0x40, (spa_loc & 0x100) >> 2);\r\n} else {\r\nrep_write(sd, 0x70, spa_loc & 0xff);\r\nrep_write_clr_set(sd, 0x71, 0x01, (spa_loc & 0x100) >> 8);\r\n}\r\nedid->edid[spa_loc] = state->spa_port_a[0];\r\nedid->edid[spa_loc + 1] = state->spa_port_a[1];\r\nmemcpy(state->edid.edid, edid->edid, 128 * edid->blocks);\r\nstate->edid.blocks = edid->blocks;\r\nstate->aspect_ratio = v4l2_calc_aspect_ratio(edid->edid[0x15],\r\nedid->edid[0x16]);\r\nstate->edid.present |= 1 << edid->pad;\r\nerr = edid_write_block(sd, 128 * edid->blocks, state->edid.edid);\r\nif (err < 0) {\r\nv4l2_err(sd, "error %d writing edid pad %d\n", err, edid->pad);\r\nreturn err;\r\n}\r\nrep_write_clr_set(sd, info->edid_enable_reg, 0x0f, state->edid.present);\r\nfor (i = 0; i < 1000; i++) {\r\nif (rep_read(sd, info->edid_status_reg) & state->edid.present)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == 1000) {\r\nv4l2_err(sd, "error enabling edid (0x%x)\n", state->edid.present);\r\nreturn -EIO;\r\n}\r\ncec_s_phys_addr(state->cec_adap, pa, false);\r\nschedule_delayed_work(&state->delayed_work_enable_hotplug, HZ / 10);\r\nreturn 0;\r\n}\r\nstatic int adv76xx_read_infoframe(struct v4l2_subdev *sd, int index,\r\nunion hdmi_infoframe *frame)\r\n{\r\nuint8_t buffer[32];\r\nu8 len;\r\nint i;\r\nif (!(io_read(sd, 0x60) & adv76xx_cri[index].present_mask)) {\r\nv4l2_info(sd, "%s infoframe not received\n",\r\nadv76xx_cri[index].desc);\r\nreturn -ENOENT;\r\n}\r\nfor (i = 0; i < 3; i++)\r\nbuffer[i] = infoframe_read(sd,\r\nadv76xx_cri[index].head_addr + i);\r\nlen = buffer[2] + 1;\r\nif (len + 3 > sizeof(buffer)) {\r\nv4l2_err(sd, "%s: invalid %s infoframe length %d\n", __func__,\r\nadv76xx_cri[index].desc, len);\r\nreturn -ENOENT;\r\n}\r\nfor (i = 0; i < len; i++)\r\nbuffer[i + 3] = infoframe_read(sd,\r\nadv76xx_cri[index].payload_addr + i);\r\nif (hdmi_infoframe_unpack(frame, buffer) < 0) {\r\nv4l2_err(sd, "%s: unpack of %s infoframe failed\n", __func__,\r\nadv76xx_cri[index].desc);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void adv76xx_log_infoframes(struct v4l2_subdev *sd)\r\n{\r\nint i;\r\nif (!is_hdmi(sd)) {\r\nv4l2_info(sd, "receive DVI-D signal, no infoframes\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(adv76xx_cri); i++) {\r\nunion hdmi_infoframe frame;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (adv76xx_read_infoframe(sd, i, &frame))\r\nreturn;\r\nhdmi_infoframe_log(KERN_INFO, &client->dev, &frame);\r\n}\r\n}\r\nstatic int adv76xx_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nstruct v4l2_dv_timings timings;\r\nstruct stdi_readback stdi;\r\nu8 reg_io_0x02 = io_read(sd, 0x02);\r\nu8 edid_enabled;\r\nu8 cable_det;\r\nstatic const char * const csc_coeff_sel_rb[16] = {\r\n"bypassed", "YPbPr601 -> RGB", "reserved", "YPbPr709 -> RGB",\r\n"reserved", "RGB -> YPbPr601", "reserved", "RGB -> YPbPr709",\r\n"reserved", "YPbPr709 -> YPbPr601", "YPbPr601 -> YPbPr709",\r\n"reserved", "reserved", "reserved", "reserved", "manual"\r\n};\r\nstatic const char * const input_color_space_txt[16] = {\r\n"RGB limited range (16-235)", "RGB full range (0-255)",\r\n"YCbCr Bt.601 (16-235)", "YCbCr Bt.709 (16-235)",\r\n"xvYCC Bt.601", "xvYCC Bt.709",\r\n"YCbCr Bt.601 (0-255)", "YCbCr Bt.709 (0-255)",\r\n"invalid", "invalid", "invalid", "invalid", "invalid",\r\n"invalid", "invalid", "automatic"\r\n};\r\nstatic const char * const hdmi_color_space_txt[16] = {\r\n"RGB limited range (16-235)", "RGB full range (0-255)",\r\n"YCbCr Bt.601 (16-235)", "YCbCr Bt.709 (16-235)",\r\n"xvYCC Bt.601", "xvYCC Bt.709",\r\n"YCbCr Bt.601 (0-255)", "YCbCr Bt.709 (0-255)",\r\n"sYCC", "Adobe YCC 601", "AdobeRGB", "invalid", "invalid",\r\n"invalid", "invalid", "invalid"\r\n};\r\nstatic const char * const rgb_quantization_range_txt[] = {\r\n"Automatic",\r\n"RGB limited range (16-235)",\r\n"RGB full range (0-255)",\r\n};\r\nstatic const char * const deep_color_mode_txt[4] = {\r\n"8-bits per channel",\r\n"10-bits per channel",\r\n"12-bits per channel",\r\n"16-bits per channel (not supported)"\r\n};\r\nv4l2_info(sd, "-----Chip status-----\n");\r\nv4l2_info(sd, "Chip power: %s\n", no_power(sd) ? "off" : "on");\r\nedid_enabled = rep_read(sd, info->edid_status_reg);\r\nv4l2_info(sd, "EDID enabled port A: %s, B: %s, C: %s, D: %s\n",\r\n((edid_enabled & 0x01) ? "Yes" : "No"),\r\n((edid_enabled & 0x02) ? "Yes" : "No"),\r\n((edid_enabled & 0x04) ? "Yes" : "No"),\r\n((edid_enabled & 0x08) ? "Yes" : "No"));\r\nv4l2_info(sd, "CEC: %s\n", state->cec_enabled_adap ?\r\n"enabled" : "disabled");\r\nif (state->cec_enabled_adap) {\r\nint i;\r\nfor (i = 0; i < ADV76XX_MAX_ADDRS; i++) {\r\nbool is_valid = state->cec_valid_addrs & (1 << i);\r\nif (is_valid)\r\nv4l2_info(sd, "CEC Logical Address: 0x%x\n",\r\nstate->cec_addr[i]);\r\n}\r\n}\r\nv4l2_info(sd, "-----Signal status-----\n");\r\ncable_det = info->read_cable_det(sd);\r\nv4l2_info(sd, "Cable detected (+5V power) port A: %s, B: %s, C: %s, D: %s\n",\r\n((cable_det & 0x01) ? "Yes" : "No"),\r\n((cable_det & 0x02) ? "Yes" : "No"),\r\n((cable_det & 0x04) ? "Yes" : "No"),\r\n((cable_det & 0x08) ? "Yes" : "No"));\r\nv4l2_info(sd, "TMDS signal detected: %s\n",\r\nno_signal_tmds(sd) ? "false" : "true");\r\nv4l2_info(sd, "TMDS signal locked: %s\n",\r\nno_lock_tmds(sd) ? "false" : "true");\r\nv4l2_info(sd, "SSPD locked: %s\n", no_lock_sspd(sd) ? "false" : "true");\r\nv4l2_info(sd, "STDI locked: %s\n", no_lock_stdi(sd) ? "false" : "true");\r\nv4l2_info(sd, "CP locked: %s\n", no_lock_cp(sd) ? "false" : "true");\r\nv4l2_info(sd, "CP free run: %s\n",\r\n(in_free_run(sd)) ? "on" : "off");\r\nv4l2_info(sd, "Prim-mode = 0x%x, video std = 0x%x, v_freq = 0x%x\n",\r\nio_read(sd, 0x01) & 0x0f, io_read(sd, 0x00) & 0x3f,\r\n(io_read(sd, 0x01) & 0x70) >> 4);\r\nv4l2_info(sd, "-----Video Timings-----\n");\r\nif (read_stdi(sd, &stdi))\r\nv4l2_info(sd, "STDI: not locked\n");\r\nelse\r\nv4l2_info(sd, "STDI: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, %s, %chsync, %cvsync\n",\r\nstdi.lcf, stdi.bl, stdi.lcvs,\r\nstdi.interlaced ? "interlaced" : "progressive",\r\nstdi.hs_pol, stdi.vs_pol);\r\nif (adv76xx_query_dv_timings(sd, &timings))\r\nv4l2_info(sd, "No video detected\n");\r\nelse\r\nv4l2_print_dv_timings(sd->name, "Detected format: ",\r\n&timings, true);\r\nv4l2_print_dv_timings(sd->name, "Configured format: ",\r\n&state->timings, true);\r\nif (no_signal(sd))\r\nreturn 0;\r\nv4l2_info(sd, "-----Color space-----\n");\r\nv4l2_info(sd, "RGB quantization range ctrl: %s\n",\r\nrgb_quantization_range_txt[state->rgb_quantization_range]);\r\nv4l2_info(sd, "Input color space: %s\n",\r\ninput_color_space_txt[reg_io_0x02 >> 4]);\r\nv4l2_info(sd, "Output color space: %s %s, alt-gamma %s\n",\r\n(reg_io_0x02 & 0x02) ? "RGB" : "YCbCr",\r\n(((reg_io_0x02 >> 2) & 0x01) ^ (reg_io_0x02 & 0x01)) ?\r\n"(16-235)" : "(0-255)",\r\n(reg_io_0x02 & 0x08) ? "enabled" : "disabled");\r\nv4l2_info(sd, "Color space conversion: %s\n",\r\ncsc_coeff_sel_rb[cp_read(sd, info->cp_csc) >> 4]);\r\nif (!is_digital_input(sd))\r\nreturn 0;\r\nv4l2_info(sd, "-----%s status-----\n", is_hdmi(sd) ? "HDMI" : "DVI-D");\r\nv4l2_info(sd, "Digital video port selected: %c\n",\r\n(hdmi_read(sd, 0x00) & 0x03) + 'A');\r\nv4l2_info(sd, "HDCP encrypted content: %s\n",\r\n(hdmi_read(sd, 0x05) & 0x40) ? "true" : "false");\r\nv4l2_info(sd, "HDCP keys read: %s%s\n",\r\n(hdmi_read(sd, 0x04) & 0x20) ? "yes" : "no",\r\n(hdmi_read(sd, 0x04) & 0x10) ? "ERROR" : "");\r\nif (is_hdmi(sd)) {\r\nbool audio_pll_locked = hdmi_read(sd, 0x04) & 0x01;\r\nbool audio_sample_packet_detect = hdmi_read(sd, 0x18) & 0x01;\r\nbool audio_mute = io_read(sd, 0x65) & 0x40;\r\nv4l2_info(sd, "Audio: pll %s, samples %s, %s\n",\r\naudio_pll_locked ? "locked" : "not locked",\r\naudio_sample_packet_detect ? "detected" : "not detected",\r\naudio_mute ? "muted" : "enabled");\r\nif (audio_pll_locked && audio_sample_packet_detect) {\r\nv4l2_info(sd, "Audio format: %s\n",\r\n(hdmi_read(sd, 0x07) & 0x20) ? "multi-channel" : "stereo");\r\n}\r\nv4l2_info(sd, "Audio CTS: %u\n", (hdmi_read(sd, 0x5b) << 12) +\r\n(hdmi_read(sd, 0x5c) << 8) +\r\n(hdmi_read(sd, 0x5d) & 0xf0));\r\nv4l2_info(sd, "Audio N: %u\n", ((hdmi_read(sd, 0x5d) & 0x0f) << 16) +\r\n(hdmi_read(sd, 0x5e) << 8) +\r\nhdmi_read(sd, 0x5f));\r\nv4l2_info(sd, "AV Mute: %s\n", (hdmi_read(sd, 0x04) & 0x40) ? "on" : "off");\r\nv4l2_info(sd, "Deep color mode: %s\n", deep_color_mode_txt[(hdmi_read(sd, 0x0b) & 0x60) >> 5]);\r\nv4l2_info(sd, "HDMI colorspace: %s\n", hdmi_color_space_txt[hdmi_read(sd, 0x53) & 0xf]);\r\nadv76xx_log_infoframes(sd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv76xx_subscribe_event(struct v4l2_subdev *sd,\r\nstruct v4l2_fh *fh,\r\nstruct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_SOURCE_CHANGE:\r\nreturn v4l2_src_change_event_subdev_subscribe(sd, fh, sub);\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int adv76xx_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nint err;\r\nerr = cec_register_adapter(state->cec_adap);\r\nif (err)\r\ncec_delete_adapter(state->cec_adap);\r\nreturn err;\r\n}\r\nstatic void adv76xx_unregistered(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\ncec_unregister_adapter(state->cec_adap);\r\n}\r\nstatic int adv76xx_core_init(struct v4l2_subdev *sd)\r\n{\r\nstruct adv76xx_state *state = to_state(sd);\r\nconst struct adv76xx_chip_info *info = state->info;\r\nstruct adv76xx_platform_data *pdata = &state->pdata;\r\nhdmi_write(sd, 0x48,\r\n(pdata->disable_pwrdnb ? 0x80 : 0) |\r\n(pdata->disable_cable_det_rst ? 0x40 : 0));\r\ndisable_input(sd);\r\nif (pdata->default_input >= 0 &&\r\npdata->default_input < state->source_pad) {\r\nstate->selected_input = pdata->default_input;\r\nselect_input(sd);\r\nenable_input(sd);\r\n}\r\nio_write(sd, 0x0c, 0x42);\r\nio_write(sd, 0x0b, 0x44);\r\ncp_write(sd, 0xcf, 0x01);\r\nio_write_clr_set(sd, 0x02, 0x0f, pdata->alt_gamma << 3);\r\nio_write_clr_set(sd, 0x05, 0x0e, pdata->blank_data << 3 |\r\npdata->insert_av_codes << 2 |\r\npdata->replicate_av_codes << 1);\r\nadv76xx_setup_format(state);\r\ncp_write(sd, 0x69, 0x30);\r\nio_write(sd, 0x06, 0xa0 | pdata->inv_vs_pol << 2 |\r\npdata->inv_hs_pol << 1 | pdata->inv_llc_pol);\r\nio_write(sd, 0x14, 0x40 | pdata->dr_str_data << 4 |\r\npdata->dr_str_clk << 2 |\r\npdata->dr_str_sync);\r\ncp_write(sd, 0xba, (pdata->hdmi_free_run_mode << 1) | 0x01);\r\ncp_write(sd, 0xf3, 0xdc);\r\ncp_write(sd, 0xf9, 0x23);\r\ncp_write(sd, 0x45, 0x23);\r\ncp_write(sd, 0xc9, 0x2d);\r\nhdmi_write_clr_set(sd, 0x15, 0x03, 0x03);\r\nhdmi_write_clr_set(sd, 0x1a, 0x0e, 0x08);\r\nhdmi_write_clr_set(sd, 0x68, 0x06, 0x06);\r\nafe_write(sd, 0xb5, 0x01);\r\nif (adv76xx_has_afe(state)) {\r\nafe_write(sd, 0x02, pdata->ain_sel);\r\nio_write_clr_set(sd, 0x30, 1 << 4, pdata->output_bus_lsb_to_msb << 4);\r\n}\r\nio_write(sd, 0x40, 0xc0 | pdata->int1_config);\r\nio_write(sd, 0x46, 0x98);\r\nio_write(sd, 0x6e, info->fmt_change_digital_mask);\r\nio_write(sd, 0x73, info->cable_det_mask);\r\ninfo->setup_irqs(sd);\r\nreturn v4l2_ctrl_handler_setup(sd->ctrl_handler);\r\n}\r\nstatic void adv7604_setup_irqs(struct v4l2_subdev *sd)\r\n{\r\nio_write(sd, 0x41, 0xd7);\r\n}\r\nstatic void adv7611_setup_irqs(struct v4l2_subdev *sd)\r\n{\r\nio_write(sd, 0x41, 0xd0);\r\n}\r\nstatic void adv7612_setup_irqs(struct v4l2_subdev *sd)\r\n{\r\nio_write(sd, 0x41, 0xd0);\r\n}\r\nstatic void adv76xx_unregister_clients(struct adv76xx_state *state)\r\n{\r\nunsigned int i;\r\nfor (i = 1; i < ARRAY_SIZE(state->i2c_clients); ++i) {\r\nif (state->i2c_clients[i])\r\ni2c_unregister_device(state->i2c_clients[i]);\r\n}\r\n}\r\nstatic struct i2c_client *adv76xx_dummy_client(struct v4l2_subdev *sd,\r\nu8 addr, u8 io_reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (addr)\r\nio_write(sd, io_reg, addr << 1);\r\nreturn i2c_new_dummy(client->adapter, io_read(sd, io_reg) >> 1);\r\n}\r\nstatic int adv76xx_parse_dt(struct adv76xx_state *state)\r\n{\r\nstruct v4l2_of_endpoint bus_cfg;\r\nstruct device_node *endpoint;\r\nstruct device_node *np;\r\nunsigned int flags;\r\nint ret;\r\nu32 v;\r\nnp = state->i2c_clients[ADV76XX_PAGE_IO]->dev.of_node;\r\nendpoint = of_graph_get_next_endpoint(np, NULL);\r\nif (!endpoint)\r\nreturn -EINVAL;\r\nret = v4l2_of_parse_endpoint(endpoint, &bus_cfg);\r\nif (ret) {\r\nof_node_put(endpoint);\r\nreturn ret;\r\n}\r\nif (!of_property_read_u32(endpoint, "default-input", &v))\r\nstate->pdata.default_input = v;\r\nelse\r\nstate->pdata.default_input = -1;\r\nof_node_put(endpoint);\r\nflags = bus_cfg.bus.parallel.flags;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\r\nstate->pdata.inv_hs_pol = 1;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\nstate->pdata.inv_vs_pol = 1;\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\nstate->pdata.inv_llc_pol = 1;\r\nif (bus_cfg.bus_type == V4L2_MBUS_BT656)\r\nstate->pdata.insert_av_codes = 1;\r\nstate->pdata.int1_config = ADV76XX_INT1_CONFIG_DISABLED;\r\nstate->pdata.i2c_addresses[ADV7604_PAGE_AVLINK] = 0x42;\r\nstate->pdata.i2c_addresses[ADV76XX_PAGE_CEC] = 0x40;\r\nstate->pdata.i2c_addresses[ADV76XX_PAGE_INFOFRAME] = 0x3e;\r\nstate->pdata.i2c_addresses[ADV7604_PAGE_ESDP] = 0x38;\r\nstate->pdata.i2c_addresses[ADV7604_PAGE_DPP] = 0x3c;\r\nstate->pdata.i2c_addresses[ADV76XX_PAGE_AFE] = 0x26;\r\nstate->pdata.i2c_addresses[ADV76XX_PAGE_REP] = 0x32;\r\nstate->pdata.i2c_addresses[ADV76XX_PAGE_EDID] = 0x36;\r\nstate->pdata.i2c_addresses[ADV76XX_PAGE_HDMI] = 0x34;\r\nstate->pdata.i2c_addresses[ADV76XX_PAGE_TEST] = 0x30;\r\nstate->pdata.i2c_addresses[ADV76XX_PAGE_CP] = 0x22;\r\nstate->pdata.i2c_addresses[ADV7604_PAGE_VDP] = 0x24;\r\nstate->pdata.disable_pwrdnb = 0;\r\nstate->pdata.disable_cable_det_rst = 0;\r\nstate->pdata.blank_data = 1;\r\nstate->pdata.op_format_mode_sel = ADV7604_OP_FORMAT_MODE0;\r\nstate->pdata.bus_order = ADV7604_BUS_ORDER_RGB;\r\nreturn 0;\r\n}\r\nstatic int configure_regmap(struct adv76xx_state *state, int region)\r\n{\r\nint err;\r\nif (!state->i2c_clients[region])\r\nreturn -ENODEV;\r\nstate->regmap[region] =\r\ndevm_regmap_init_i2c(state->i2c_clients[region],\r\n&adv76xx_regmap_cnf[region]);\r\nif (IS_ERR(state->regmap[region])) {\r\nerr = PTR_ERR(state->regmap[region]);\r\nv4l_err(state->i2c_clients[region],\r\n"Error initializing regmap %d with error %d\n",\r\nregion, err);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int configure_regmaps(struct adv76xx_state *state)\r\n{\r\nint i, err;\r\nfor (i = ADV7604_PAGE_AVLINK ; i < ADV76XX_PAGE_MAX; i++) {\r\nerr = configure_regmap(state, i);\r\nif (err && (err != -ENODEV))\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void adv76xx_reset(struct adv76xx_state *state)\r\n{\r\nif (state->reset_gpio) {\r\ngpiod_set_value_cansleep(state->reset_gpio, 0);\r\nusleep_range(5000, 10000);\r\ngpiod_set_value_cansleep(state->reset_gpio, 1);\r\nusleep_range(5000, 10000);\r\n}\r\n}\r\nstatic int adv76xx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstatic const struct v4l2_dv_timings cea640x480 =\r\nV4L2_DV_BT_CEA_640X480P59_94;\r\nstruct adv76xx_state *state;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct v4l2_ctrl *ctrl;\r\nstruct v4l2_subdev *sd;\r\nunsigned int i;\r\nunsigned int val, val2;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_dbg(1, debug, client, "detecting adv76xx client on address 0x%x\n",\r\nclient->addr << 1);\r\nstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\r\nif (!state) {\r\nv4l_err(client, "Could not allocate adv76xx_state memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nstate->i2c_clients[ADV76XX_PAGE_IO] = client;\r\nstate->restart_stdi_once = true;\r\nstate->selected_input = ~0;\r\nif (IS_ENABLED(CONFIG_OF) && client->dev.of_node) {\r\nconst struct of_device_id *oid;\r\noid = of_match_node(adv76xx_of_id, client->dev.of_node);\r\nstate->info = oid->data;\r\nerr = adv76xx_parse_dt(state);\r\nif (err < 0) {\r\nv4l_err(client, "DT parsing error\n");\r\nreturn err;\r\n}\r\n} else if (client->dev.platform_data) {\r\nstruct adv76xx_platform_data *pdata = client->dev.platform_data;\r\nstate->info = (const struct adv76xx_chip_info *)id->driver_data;\r\nstate->pdata = *pdata;\r\n} else {\r\nv4l_err(client, "No platform data!\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < state->info->num_dv_ports; ++i) {\r\nstate->hpd_gpio[i] =\r\ndevm_gpiod_get_index_optional(&client->dev, "hpd", i,\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(state->hpd_gpio[i]))\r\nreturn PTR_ERR(state->hpd_gpio[i]);\r\nif (state->hpd_gpio[i])\r\nv4l_info(client, "Handling HPD %u GPIO\n", i);\r\n}\r\nstate->reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(state->reset_gpio))\r\nreturn PTR_ERR(state->reset_gpio);\r\nadv76xx_reset(state);\r\nstate->timings = cea640x480;\r\nstate->format = adv76xx_format_info(state, MEDIA_BUS_FMT_YUYV8_2X8);\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &adv76xx_ops);\r\nsnprintf(sd->name, sizeof(sd->name), "%s %d-%04x",\r\nid->name, i2c_adapter_id(client->adapter),\r\nclient->addr);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;\r\nsd->internal_ops = &adv76xx_int_ops;\r\nerr = configure_regmap(state, ADV76XX_PAGE_IO);\r\nif (err) {\r\nv4l2_err(sd, "Error configuring IO regmap region\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (state->info->type) {\r\ncase ADV7604:\r\nerr = regmap_read(state->regmap[ADV76XX_PAGE_IO], 0xfb, &val);\r\nif (err) {\r\nv4l2_err(sd, "Error %d reading IO Regmap\n", err);\r\nreturn -ENODEV;\r\n}\r\nif (val != 0x68) {\r\nv4l2_err(sd, "not an adv7604 on address 0x%x\n",\r\nclient->addr << 1);\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\ncase ADV7611:\r\ncase ADV7612:\r\nerr = regmap_read(state->regmap[ADV76XX_PAGE_IO],\r\n0xea,\r\n&val);\r\nif (err) {\r\nv4l2_err(sd, "Error %d reading IO Regmap\n", err);\r\nreturn -ENODEV;\r\n}\r\nval2 = val << 8;\r\nerr = regmap_read(state->regmap[ADV76XX_PAGE_IO],\r\n0xeb,\r\n&val);\r\nif (err) {\r\nv4l2_err(sd, "Error %d reading IO Regmap\n", err);\r\nreturn -ENODEV;\r\n}\r\nval |= val2;\r\nif ((state->info->type == ADV7611 && val != 0x2051) ||\r\n(state->info->type == ADV7612 && val != 0x2041)) {\r\nv4l2_err(sd, "not an adv761x on address 0x%x\n",\r\nclient->addr << 1);\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\n}\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, adv76xx_has_afe(state) ? 9 : 8);\r\nv4l2_ctrl_new_std(hdl, &adv76xx_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &adv76xx_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &adv76xx_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &adv76xx_ctrl_ops,\r\nV4L2_CID_HUE, 0, 128, 1, 0);\r\nctrl = v4l2_ctrl_new_std_menu(hdl, &adv76xx_ctrl_ops,\r\nV4L2_CID_DV_RX_IT_CONTENT_TYPE, V4L2_DV_IT_CONTENT_TYPE_NO_ITC,\r\n0, V4L2_DV_IT_CONTENT_TYPE_NO_ITC);\r\nif (ctrl)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nstate->detect_tx_5v_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_RX_POWER_PRESENT, 0,\r\n(1 << state->info->num_dv_ports) - 1, 0, 0);\r\nstate->rgb_quantization_range_ctrl =\r\nv4l2_ctrl_new_std_menu(hdl, &adv76xx_ctrl_ops,\r\nV4L2_CID_DV_RX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\r\n0, V4L2_DV_RGB_RANGE_AUTO);\r\nif (adv76xx_has_afe(state))\r\nstate->analog_sampling_phase_ctrl =\r\nv4l2_ctrl_new_custom(hdl, &adv7604_ctrl_analog_sampling_phase, NULL);\r\nstate->free_run_color_manual_ctrl =\r\nv4l2_ctrl_new_custom(hdl, &adv76xx_ctrl_free_run_color_manual, NULL);\r\nstate->free_run_color_ctrl =\r\nv4l2_ctrl_new_custom(hdl, &adv76xx_ctrl_free_run_color, NULL);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ngoto err_hdl;\r\n}\r\nif (adv76xx_s_detect_tx_5v_ctrl(sd)) {\r\nerr = -ENODEV;\r\ngoto err_hdl;\r\n}\r\nfor (i = 1; i < ADV76XX_PAGE_MAX; ++i) {\r\nif (!(BIT(i) & state->info->page_mask))\r\ncontinue;\r\nstate->i2c_clients[i] =\r\nadv76xx_dummy_client(sd, state->pdata.i2c_addresses[i],\r\n0xf2 + i);\r\nif (state->i2c_clients[i] == NULL) {\r\nerr = -ENOMEM;\r\nv4l2_err(sd, "failed to create i2c client %u\n", i);\r\ngoto err_i2c;\r\n}\r\n}\r\nINIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,\r\nadv76xx_delayed_work_enable_hotplug);\r\nstate->source_pad = state->info->num_dv_ports\r\n+ (state->info->has_afe ? 2 : 0);\r\nfor (i = 0; i < state->source_pad; ++i)\r\nstate->pads[i].flags = MEDIA_PAD_FL_SINK;\r\nstate->pads[state->source_pad].flags = MEDIA_PAD_FL_SOURCE;\r\nerr = media_entity_pads_init(&sd->entity, state->source_pad + 1,\r\nstate->pads);\r\nif (err)\r\ngoto err_work_queues;\r\nerr = configure_regmaps(state);\r\nif (err)\r\ngoto err_entity;\r\nerr = adv76xx_core_init(sd);\r\nif (err)\r\ngoto err_entity;\r\n#if IS_ENABLED(CONFIG_VIDEO_ADV7604_CEC)\r\nstate->cec_adap = cec_allocate_adapter(&adv76xx_cec_adap_ops,\r\nstate, dev_name(&client->dev),\r\nCEC_CAP_TRANSMIT | CEC_CAP_LOG_ADDRS |\r\nCEC_CAP_PASSTHROUGH | CEC_CAP_RC, ADV76XX_MAX_ADDRS,\r\n&client->dev);\r\nerr = PTR_ERR_OR_ZERO(state->cec_adap);\r\nif (err)\r\ngoto err_entity;\r\n#endif\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nerr = v4l2_async_register_subdev(sd);\r\nif (err)\r\ngoto err_entity;\r\nreturn 0;\r\nerr_entity:\r\nmedia_entity_cleanup(&sd->entity);\r\nerr_work_queues:\r\ncancel_delayed_work(&state->delayed_work_enable_hotplug);\r\nerr_i2c:\r\nadv76xx_unregister_clients(state);\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn err;\r\n}\r\nstatic int adv76xx_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv76xx_state *state = to_state(sd);\r\nio_write(sd, 0x40, 0);\r\nio_write(sd, 0x41, 0);\r\nio_write(sd, 0x46, 0);\r\nio_write(sd, 0x6e, 0);\r\nio_write(sd, 0x73, 0);\r\ncancel_delayed_work(&state->delayed_work_enable_hotplug);\r\nv4l2_async_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nadv76xx_unregister_clients(to_state(sd));\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nreturn 0;\r\n}
