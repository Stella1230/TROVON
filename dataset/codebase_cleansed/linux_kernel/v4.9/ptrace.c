void ptrace_disable(struct task_struct *task)\r\n{\r\nclear_tsk_thread_flag(task, TIF_SINGLESTEP);\r\nclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\r\npa_psw(task)->r = 0;\r\npa_psw(task)->t = 0;\r\npa_psw(task)->h = 0;\r\npa_psw(task)->l = 0;\r\n}\r\nvoid user_disable_single_step(struct task_struct *task)\r\n{\r\nptrace_disable(task);\r\n}\r\nvoid user_enable_single_step(struct task_struct *task)\r\n{\r\nclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\r\nset_tsk_thread_flag(task, TIF_SINGLESTEP);\r\nif (pa_psw(task)->n) {\r\nstruct siginfo si;\r\ntask_regs(task)->iaoq[0] = task_regs(task)->iaoq[1];\r\ntask_regs(task)->iasq[0] = task_regs(task)->iasq[1];\r\ntask_regs(task)->iaoq[1] = task_regs(task)->iaoq[0] + 4;\r\npa_psw(task)->n = 0;\r\npa_psw(task)->x = 0;\r\npa_psw(task)->y = 0;\r\npa_psw(task)->z = 0;\r\npa_psw(task)->b = 0;\r\nptrace_disable(task);\r\nsi.si_code = TRAP_TRACE;\r\nsi.si_addr = (void __user *) (task_regs(task)->iaoq[0] & ~3);\r\nsi.si_signo = SIGTRAP;\r\nsi.si_errno = 0;\r\nforce_sig_info(SIGTRAP, &si, task);\r\nreturn;\r\n}\r\npa_psw(task)->r = 1;\r\npa_psw(task)->t = 0;\r\npa_psw(task)->h = 0;\r\npa_psw(task)->l = 0;\r\n}\r\nvoid user_enable_block_step(struct task_struct *task)\r\n{\r\nclear_tsk_thread_flag(task, TIF_SINGLESTEP);\r\nset_tsk_thread_flag(task, TIF_BLOCKSTEP);\r\npa_psw(task)->r = 0;\r\npa_psw(task)->t = 1;\r\npa_psw(task)->h = 0;\r\npa_psw(task)->l = 0;\r\n}\r\nlong arch_ptrace(struct task_struct *child, long request,\r\nunsigned long addr, unsigned long data)\r\n{\r\nunsigned long __user *datap = (unsigned long __user *)data;\r\nunsigned long tmp;\r\nlong ret = -EIO;\r\nswitch (request) {\r\ncase PTRACE_PEEKUSR:\r\nif ((addr & (sizeof(unsigned long)-1)) ||\r\naddr >= sizeof(struct pt_regs))\r\nbreak;\r\ntmp = *(unsigned long *) ((char *) task_regs(child) + addr);\r\nret = put_user(tmp, datap);\r\nbreak;\r\ncase PTRACE_POKEUSR:\r\nif (addr == PT_PSW) {\r\ndata &= USER_PSW_BITS;\r\ntask_regs(child)->gr[0] &= ~USER_PSW_BITS;\r\ntask_regs(child)->gr[0] |= data;\r\nret = 0;\r\nbreak;\r\n}\r\nif ((addr & (sizeof(unsigned long)-1)) ||\r\naddr >= sizeof(struct pt_regs))\r\nbreak;\r\nif ((addr >= PT_GR1 && addr <= PT_GR31) ||\r\naddr == PT_IAOQ0 || addr == PT_IAOQ1 ||\r\n(addr >= PT_FR0 && addr <= PT_FR31 + 4) ||\r\naddr == PT_SAR) {\r\n*(unsigned long *) ((char *) task_regs(child) + addr) = data;\r\nret = 0;\r\n}\r\nbreak;\r\ncase PTRACE_GETREGS:\r\nreturn copy_regset_to_user(child,\r\ntask_user_regset_view(current),\r\nREGSET_GENERAL,\r\n0, sizeof(struct user_regs_struct),\r\ndatap);\r\ncase PTRACE_SETREGS:\r\nreturn copy_regset_from_user(child,\r\ntask_user_regset_view(current),\r\nREGSET_GENERAL,\r\n0, sizeof(struct user_regs_struct),\r\ndatap);\r\ncase PTRACE_GETFPREGS:\r\nreturn copy_regset_to_user(child,\r\ntask_user_regset_view(current),\r\nREGSET_FP,\r\n0, sizeof(struct user_fp_struct),\r\ndatap);\r\ncase PTRACE_SETFPREGS:\r\nreturn copy_regset_from_user(child,\r\ntask_user_regset_view(current),\r\nREGSET_FP,\r\n0, sizeof(struct user_fp_struct),\r\ndatap);\r\ndefault:\r\nret = ptrace_request(child, request, addr, data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic compat_ulong_t translate_usr_offset(compat_ulong_t offset)\r\n{\r\nif (offset < 0)\r\nreturn sizeof(struct pt_regs);\r\nelse if (offset <= 32*4)\r\nreturn offset * 2 + 4;\r\nelse if (offset <= 32*4+32*8)\r\nreturn offset + 32*4;\r\nelse if (offset < sizeof(struct pt_regs)/2 + 32*4)\r\nreturn offset * 2 + 4 - 32*8;\r\nelse\r\nreturn sizeof(struct pt_regs);\r\n}\r\nlong compat_arch_ptrace(struct task_struct *child, compat_long_t request,\r\ncompat_ulong_t addr, compat_ulong_t data)\r\n{\r\ncompat_uint_t tmp;\r\nlong ret = -EIO;\r\nswitch (request) {\r\ncase PTRACE_PEEKUSR:\r\nif (addr & (sizeof(compat_uint_t)-1))\r\nbreak;\r\naddr = translate_usr_offset(addr);\r\nif (addr >= sizeof(struct pt_regs))\r\nbreak;\r\ntmp = *(compat_uint_t *) ((char *) task_regs(child) + addr);\r\nret = put_user(tmp, (compat_uint_t *) (unsigned long) data);\r\nbreak;\r\ncase PTRACE_POKEUSR:\r\nif (addr == PT_PSW) {\r\nret = arch_ptrace(child, request, addr, data);\r\n} else {\r\nif (addr & (sizeof(compat_uint_t)-1))\r\nbreak;\r\naddr = translate_usr_offset(addr);\r\nif (addr >= sizeof(struct pt_regs))\r\nbreak;\r\nif (addr >= PT_FR0 && addr <= PT_FR31 + 4) {\r\n*(__u64 *) ((char *) task_regs(child) + addr) = data;\r\nret = 0;\r\n}\r\nelse if ((addr >= PT_GR1+4 && addr <= PT_GR31+4) ||\r\naddr == PT_IAOQ0+4 || addr == PT_IAOQ1+4 ||\r\naddr == PT_SAR+4) {\r\n*(__u32 *) ((char *) task_regs(child) + addr - 4) = 0;\r\n*(__u32 *) ((char *) task_regs(child) + addr) = data;\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nret = compat_ptrace_request(child, request, addr, data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nlong do_syscall_trace_enter(struct pt_regs *regs)\r\n{\r\nif (test_thread_flag(TIF_SYSCALL_TRACE) &&\r\ntracehook_report_syscall_entry(regs)) {\r\nregs->gr[20] = -1UL;\r\ngoto out;\r\n}\r\nif (secure_computing(NULL) == -1)\r\nreturn -1;\r\n#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS\r\nif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\r\ntrace_sys_enter(regs, regs->gr[20]);\r\n#endif\r\n#ifdef CONFIG_64BIT\r\nif (!is_compat_task())\r\naudit_syscall_entry(regs->gr[20], regs->gr[26], regs->gr[25],\r\nregs->gr[24], regs->gr[23]);\r\nelse\r\n#endif\r\naudit_syscall_entry(regs->gr[20] & 0xffffffff,\r\nregs->gr[26] & 0xffffffff,\r\nregs->gr[25] & 0xffffffff,\r\nregs->gr[24] & 0xffffffff,\r\nregs->gr[23] & 0xffffffff);\r\nout:\r\nreturn (int) ((u32) regs->gr[20]);\r\n}\r\nvoid do_syscall_trace_exit(struct pt_regs *regs)\r\n{\r\nint stepping = test_thread_flag(TIF_SINGLESTEP) ||\r\ntest_thread_flag(TIF_BLOCKSTEP);\r\naudit_syscall_exit(regs);\r\n#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS\r\nif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\r\ntrace_sys_exit(regs, regs->gr[20]);\r\n#endif\r\nif (stepping || test_thread_flag(TIF_SYSCALL_TRACE))\r\ntracehook_report_syscall_exit(regs, stepping);\r\n}\r\nstatic int fpr_get(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nstruct pt_regs *regs = task_regs(target);\r\n__u64 *k = kbuf;\r\n__u64 __user *u = ubuf;\r\n__u64 reg;\r\npos /= sizeof(reg);\r\ncount /= sizeof(reg);\r\nif (kbuf)\r\nfor (; count > 0 && pos < ELF_NFPREG; --count)\r\n*k++ = regs->fr[pos++];\r\nelse\r\nfor (; count > 0 && pos < ELF_NFPREG; --count)\r\nif (__put_user(regs->fr[pos++], u++))\r\nreturn -EFAULT;\r\nkbuf = k;\r\nubuf = u;\r\npos *= sizeof(reg);\r\ncount *= sizeof(reg);\r\nreturn user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\r\nELF_NFPREG * sizeof(reg), -1);\r\n}\r\nstatic int fpr_set(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct pt_regs *regs = task_regs(target);\r\nconst __u64 *k = kbuf;\r\nconst __u64 __user *u = ubuf;\r\n__u64 reg;\r\npos /= sizeof(reg);\r\ncount /= sizeof(reg);\r\nif (kbuf)\r\nfor (; count > 0 && pos < ELF_NFPREG; --count)\r\nregs->fr[pos++] = *k++;\r\nelse\r\nfor (; count > 0 && pos < ELF_NFPREG; --count) {\r\nif (__get_user(reg, u++))\r\nreturn -EFAULT;\r\nregs->fr[pos++] = reg;\r\n}\r\nkbuf = k;\r\nubuf = u;\r\npos *= sizeof(reg);\r\ncount *= sizeof(reg);\r\nreturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\r\nELF_NFPREG * sizeof(reg), -1);\r\n}\r\nstatic unsigned long get_reg(struct pt_regs *regs, int num)\r\n{\r\nswitch (num) {\r\ncase RI(gr[0]) ... RI(gr[31]): return regs->gr[num - RI(gr[0])];\r\ncase RI(sr[0]) ... RI(sr[7]): return regs->sr[num - RI(sr[0])];\r\ncase RI(iasq[0]): return regs->iasq[0];\r\ncase RI(iasq[1]): return regs->iasq[1];\r\ncase RI(iaoq[0]): return regs->iaoq[0];\r\ncase RI(iaoq[1]): return regs->iaoq[1];\r\ncase RI(sar): return regs->sar;\r\ncase RI(iir): return regs->iir;\r\ncase RI(isr): return regs->isr;\r\ncase RI(ior): return regs->ior;\r\ncase RI(ipsw): return regs->ipsw;\r\ncase RI(cr27): return regs->cr27;\r\ncase RI(cr0): return mfctl(0);\r\ncase RI(cr24): return mfctl(24);\r\ncase RI(cr25): return mfctl(25);\r\ncase RI(cr26): return mfctl(26);\r\ncase RI(cr28): return mfctl(28);\r\ncase RI(cr29): return mfctl(29);\r\ncase RI(cr30): return mfctl(30);\r\ncase RI(cr31): return mfctl(31);\r\ncase RI(cr8): return mfctl(8);\r\ncase RI(cr9): return mfctl(9);\r\ncase RI(cr12): return mfctl(12);\r\ncase RI(cr13): return mfctl(13);\r\ncase RI(cr10): return mfctl(10);\r\ncase RI(cr15): return mfctl(15);\r\ndefault: return 0;\r\n}\r\n}\r\nstatic void set_reg(struct pt_regs *regs, int num, unsigned long val)\r\n{\r\nswitch (num) {\r\ncase RI(gr[0]):\r\nval &= USER_PSW_BITS;\r\nregs->gr[0] &= ~USER_PSW_BITS;\r\nregs->gr[0] |= val;\r\nreturn;\r\ncase RI(gr[1]) ... RI(gr[31]):\r\nregs->gr[num - RI(gr[0])] = val;\r\nreturn;\r\ncase RI(iaoq[0]):\r\ncase RI(iaoq[1]):\r\nregs->iaoq[num - RI(iaoq[0])] = val;\r\nreturn;\r\ncase RI(sar): regs->sar = val;\r\nreturn;\r\ndefault: return;\r\n#if 0\r\ncase RI(sr[0]) ... RI(sr[7]): return regs->sr[num - RI(sr[0])];\r\ncase RI(iasq[0]): return regs->iasq[0];\r\ncase RI(iasq[1]): return regs->iasq[1];\r\ncase RI(iir): return regs->iir;\r\ncase RI(isr): return regs->isr;\r\ncase RI(ior): return regs->ior;\r\ncase RI(ipsw): return regs->ipsw;\r\ncase RI(cr27): return regs->cr27;\r\ncase cr0, cr24, cr25, cr26, cr27, cr28, cr29, cr30, cr31;\r\ncase cr8, cr9, cr12, cr13, cr10, cr15;\r\n#endif\r\n}\r\n}\r\nstatic int gpr_get(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nstruct pt_regs *regs = task_regs(target);\r\nunsigned long *k = kbuf;\r\nunsigned long __user *u = ubuf;\r\nunsigned long reg;\r\npos /= sizeof(reg);\r\ncount /= sizeof(reg);\r\nif (kbuf)\r\nfor (; count > 0 && pos < ELF_NGREG; --count)\r\n*k++ = get_reg(regs, pos++);\r\nelse\r\nfor (; count > 0 && pos < ELF_NGREG; --count)\r\nif (__put_user(get_reg(regs, pos++), u++))\r\nreturn -EFAULT;\r\nkbuf = k;\r\nubuf = u;\r\npos *= sizeof(reg);\r\ncount *= sizeof(reg);\r\nreturn user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\r\nELF_NGREG * sizeof(reg), -1);\r\n}\r\nstatic int gpr_set(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct pt_regs *regs = task_regs(target);\r\nconst unsigned long *k = kbuf;\r\nconst unsigned long __user *u = ubuf;\r\nunsigned long reg;\r\npos /= sizeof(reg);\r\ncount /= sizeof(reg);\r\nif (kbuf)\r\nfor (; count > 0 && pos < ELF_NGREG; --count)\r\nset_reg(regs, pos++, *k++);\r\nelse\r\nfor (; count > 0 && pos < ELF_NGREG; --count) {\r\nif (__get_user(reg, u++))\r\nreturn -EFAULT;\r\nset_reg(regs, pos++, reg);\r\n}\r\nkbuf = k;\r\nubuf = u;\r\npos *= sizeof(reg);\r\ncount *= sizeof(reg);\r\nreturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\r\nELF_NGREG * sizeof(reg), -1);\r\n}\r\nstatic int gpr32_get(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nstruct pt_regs *regs = task_regs(target);\r\ncompat_ulong_t *k = kbuf;\r\ncompat_ulong_t __user *u = ubuf;\r\ncompat_ulong_t reg;\r\npos /= sizeof(reg);\r\ncount /= sizeof(reg);\r\nif (kbuf)\r\nfor (; count > 0 && pos < ELF_NGREG; --count)\r\n*k++ = get_reg(regs, pos++);\r\nelse\r\nfor (; count > 0 && pos < ELF_NGREG; --count)\r\nif (__put_user((compat_ulong_t) get_reg(regs, pos++), u++))\r\nreturn -EFAULT;\r\nkbuf = k;\r\nubuf = u;\r\npos *= sizeof(reg);\r\ncount *= sizeof(reg);\r\nreturn user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\r\nELF_NGREG * sizeof(reg), -1);\r\n}\r\nstatic int gpr32_set(struct task_struct *target,\r\nconst struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct pt_regs *regs = task_regs(target);\r\nconst compat_ulong_t *k = kbuf;\r\nconst compat_ulong_t __user *u = ubuf;\r\ncompat_ulong_t reg;\r\npos /= sizeof(reg);\r\ncount /= sizeof(reg);\r\nif (kbuf)\r\nfor (; count > 0 && pos < ELF_NGREG; --count)\r\nset_reg(regs, pos++, *k++);\r\nelse\r\nfor (; count > 0 && pos < ELF_NGREG; --count) {\r\nif (__get_user(reg, u++))\r\nreturn -EFAULT;\r\nset_reg(regs, pos++, reg);\r\n}\r\nkbuf = k;\r\nubuf = u;\r\npos *= sizeof(reg);\r\ncount *= sizeof(reg);\r\nreturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\r\nELF_NGREG * sizeof(reg), -1);\r\n}\r\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\r\n{\r\nBUILD_BUG_ON(sizeof(struct user_regs_struct)/sizeof(long) != ELF_NGREG);\r\nBUILD_BUG_ON(sizeof(struct user_fp_struct)/sizeof(__u64) != ELF_NFPREG);\r\n#ifdef CONFIG_64BIT\r\nif (is_compat_task())\r\nreturn &user_parisc_compat_view;\r\n#endif\r\nreturn &user_parisc_native_view;\r\n}
