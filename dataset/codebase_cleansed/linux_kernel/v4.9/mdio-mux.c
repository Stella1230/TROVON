static int mdio_mux_read(struct mii_bus *bus, int phy_id, int regnum)\r\n{\r\nstruct mdio_mux_child_bus *cb = bus->priv;\r\nstruct mdio_mux_parent_bus *pb = cb->parent;\r\nint r;\r\nmutex_lock_nested(&pb->mii_bus->mdio_lock, MDIO_MUTEX_MUX);\r\nr = pb->switch_fn(pb->current_child, cb->bus_number, pb->switch_data);\r\nif (r)\r\ngoto out;\r\npb->current_child = cb->bus_number;\r\nr = pb->mii_bus->read(pb->mii_bus, phy_id, regnum);\r\nout:\r\nmutex_unlock(&pb->mii_bus->mdio_lock);\r\nreturn r;\r\n}\r\nstatic int mdio_mux_write(struct mii_bus *bus, int phy_id,\r\nint regnum, u16 val)\r\n{\r\nstruct mdio_mux_child_bus *cb = bus->priv;\r\nstruct mdio_mux_parent_bus *pb = cb->parent;\r\nint r;\r\nmutex_lock_nested(&pb->mii_bus->mdio_lock, MDIO_MUTEX_MUX);\r\nr = pb->switch_fn(pb->current_child, cb->bus_number, pb->switch_data);\r\nif (r)\r\ngoto out;\r\npb->current_child = cb->bus_number;\r\nr = pb->mii_bus->write(pb->mii_bus, phy_id, regnum, val);\r\nout:\r\nmutex_unlock(&pb->mii_bus->mdio_lock);\r\nreturn r;\r\n}\r\nint mdio_mux_init(struct device *dev,\r\nint (*switch_fn)(int cur, int desired, void *data),\r\nvoid **mux_handle,\r\nvoid *data,\r\nstruct mii_bus *mux_bus)\r\n{\r\nstruct device_node *parent_bus_node;\r\nstruct device_node *child_bus_node;\r\nint r, ret_val;\r\nstruct mii_bus *parent_bus;\r\nstruct mdio_mux_parent_bus *pb;\r\nstruct mdio_mux_child_bus *cb;\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nif (!mux_bus) {\r\nparent_bus_node = of_parse_phandle(dev->of_node,\r\n"mdio-parent-bus", 0);\r\nif (!parent_bus_node)\r\nreturn -ENODEV;\r\nparent_bus = of_mdio_find_bus(parent_bus_node);\r\nif (!parent_bus) {\r\nret_val = -EPROBE_DEFER;\r\ngoto err_parent_bus;\r\n}\r\n} else {\r\nparent_bus_node = NULL;\r\nparent_bus = mux_bus;\r\n}\r\npb = devm_kzalloc(dev, sizeof(*pb), GFP_KERNEL);\r\nif (pb == NULL) {\r\nret_val = -ENOMEM;\r\ngoto err_parent_bus;\r\n}\r\npb->switch_data = data;\r\npb->switch_fn = switch_fn;\r\npb->current_child = -1;\r\npb->parent_id = parent_count++;\r\npb->mii_bus = parent_bus;\r\nret_val = -ENODEV;\r\nfor_each_available_child_of_node(dev->of_node, child_bus_node) {\r\nu32 v;\r\nr = of_property_read_u32(child_bus_node, "reg", &v);\r\nif (r)\r\ncontinue;\r\ncb = devm_kzalloc(dev, sizeof(*cb), GFP_KERNEL);\r\nif (cb == NULL) {\r\ndev_err(dev,\r\n"Error: Failed to allocate memory for child\n");\r\nret_val = -ENOMEM;\r\nof_node_put(child_bus_node);\r\nbreak;\r\n}\r\ncb->bus_number = v;\r\ncb->parent = pb;\r\ncb->mii_bus = mdiobus_alloc();\r\nif (!cb->mii_bus) {\r\nret_val = -ENOMEM;\r\nof_node_put(child_bus_node);\r\nbreak;\r\n}\r\ncb->mii_bus->priv = cb;\r\ncb->mii_bus->name = "mdio_mux";\r\nsnprintf(cb->mii_bus->id, MII_BUS_ID_SIZE, "%x.%x",\r\npb->parent_id, v);\r\ncb->mii_bus->parent = dev;\r\ncb->mii_bus->read = mdio_mux_read;\r\ncb->mii_bus->write = mdio_mux_write;\r\nr = of_mdiobus_register(cb->mii_bus, child_bus_node);\r\nif (r) {\r\nmdiobus_free(cb->mii_bus);\r\ndevm_kfree(dev, cb);\r\n} else {\r\nof_node_get(child_bus_node);\r\ncb->next = pb->children;\r\npb->children = cb;\r\n}\r\n}\r\nif (pb->children) {\r\n*mux_handle = pb;\r\ndev_info(dev, "Version " DRV_VERSION "\n");\r\nreturn 0;\r\n}\r\nput_device(&pb->mii_bus->dev);\r\nerr_parent_bus:\r\nof_node_put(parent_bus_node);\r\nreturn ret_val;\r\n}\r\nvoid mdio_mux_uninit(void *mux_handle)\r\n{\r\nstruct mdio_mux_parent_bus *pb = mux_handle;\r\nstruct mdio_mux_child_bus *cb = pb->children;\r\nwhile (cb) {\r\nmdiobus_unregister(cb->mii_bus);\r\nmdiobus_free(cb->mii_bus);\r\ncb = cb->next;\r\n}\r\nput_device(&pb->mii_bus->dev);\r\n}
