static int pxa_cpufreq_change_voltage(const struct pxa_freqs *pxa_freq)\r\n{\r\nint ret = 0;\r\nint vmin, vmax;\r\nif (!cpu_is_pxa27x())\r\nreturn 0;\r\nvmin = pxa_freq->vmin;\r\nvmax = pxa_freq->vmax;\r\nif ((vmin == -1) || (vmax == -1))\r\nreturn 0;\r\nret = regulator_set_voltage(vcc_core, vmin, vmax);\r\nif (ret)\r\npr_err("Failed to set vcc_core in [%dmV..%dmV]\n", vmin, vmax);\r\nreturn ret;\r\n}\r\nstatic void __init pxa_cpufreq_init_voltages(void)\r\n{\r\nvcc_core = regulator_get(NULL, "vcc_core");\r\nif (IS_ERR(vcc_core)) {\r\npr_info("Didn't find vcc_core regulator\n");\r\nvcc_core = NULL;\r\n} else {\r\npr_info("Found vcc_core regulator\n");\r\n}\r\n}\r\nstatic int pxa_cpufreq_change_voltage(const struct pxa_freqs *pxa_freq)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init pxa_cpufreq_init_voltages(void) { }\r\nstatic void find_freq_tables(struct cpufreq_frequency_table **freq_table,\r\nconst struct pxa_freqs **pxa_freqs)\r\n{\r\nif (cpu_is_pxa25x()) {\r\nif (!pxa255_turbo_table) {\r\n*pxa_freqs = pxa255_run_freqs;\r\n*freq_table = pxa255_run_freq_table;\r\n} else {\r\n*pxa_freqs = pxa255_turbo_freqs;\r\n*freq_table = pxa255_turbo_freq_table;\r\n}\r\n} else if (cpu_is_pxa27x()) {\r\n*pxa_freqs = pxa27x_freqs;\r\n*freq_table = pxa27x_freq_table;\r\n} else {\r\nBUG();\r\n}\r\n}\r\nstatic void pxa27x_guess_max_freq(void)\r\n{\r\nif (!pxa27x_maxfreq) {\r\npxa27x_maxfreq = 416000;\r\npr_info("PXA CPU 27x max frequency not defined (pxa27x_maxfreq), assuming pxa271 with %dkHz maxfreq\n",\r\npxa27x_maxfreq);\r\n} else {\r\npxa27x_maxfreq *= 1000;\r\n}\r\n}\r\nstatic void init_sdram_rows(void)\r\n{\r\nuint32_t mdcnfg = __raw_readl(MDCNFG);\r\nunsigned int drac2 = 0, drac0 = 0;\r\nif (mdcnfg & (MDCNFG_DE2 | MDCNFG_DE3))\r\ndrac2 = MDCNFG_DRAC2(mdcnfg);\r\nif (mdcnfg & (MDCNFG_DE0 | MDCNFG_DE1))\r\ndrac0 = MDCNFG_DRAC0(mdcnfg);\r\nsdram_rows = 1 << (11 + max(drac0, drac2));\r\n}\r\nstatic u32 mdrefr_dri(unsigned int freq)\r\n{\r\nu32 interval = freq * SDRAM_TREF / sdram_rows;\r\nreturn (interval - (cpu_is_pxa27x() ? 31 : 0)) / 32;\r\n}\r\nstatic unsigned int pxa_cpufreq_get(unsigned int cpu)\r\n{\r\nreturn get_clk_frequency_khz(0);\r\n}\r\nstatic int pxa_set_target(struct cpufreq_policy *policy, unsigned int idx)\r\n{\r\nstruct cpufreq_frequency_table *pxa_freqs_table;\r\nconst struct pxa_freqs *pxa_freq_settings;\r\nunsigned long flags;\r\nunsigned int new_freq_cpu, new_freq_mem;\r\nunsigned int unused, preset_mdrefr, postset_mdrefr, cclkcfg;\r\nint ret = 0;\r\nfind_freq_tables(&pxa_freqs_table, &pxa_freq_settings);\r\nnew_freq_cpu = pxa_freq_settings[idx].khz;\r\nnew_freq_mem = pxa_freq_settings[idx].membus;\r\nif (freq_debug)\r\npr_debug("Changing CPU frequency to %d Mhz, (SDRAM %d Mhz)\n",\r\nnew_freq_cpu / 1000, (pxa_freq_settings[idx].div2) ?\r\n(new_freq_mem / 2000) : (new_freq_mem / 1000));\r\nif (vcc_core && new_freq_cpu > policy->cur) {\r\nret = pxa_cpufreq_change_voltage(&pxa_freq_settings[idx]);\r\nif (ret)\r\nreturn ret;\r\n}\r\npreset_mdrefr = postset_mdrefr = __raw_readl(MDREFR);\r\nif ((preset_mdrefr & MDREFR_DRI_MASK) > mdrefr_dri(new_freq_mem)) {\r\npreset_mdrefr = (preset_mdrefr & ~MDREFR_DRI_MASK);\r\npreset_mdrefr |= mdrefr_dri(new_freq_mem);\r\n}\r\npostset_mdrefr =\r\n(postset_mdrefr & ~MDREFR_DRI_MASK) | mdrefr_dri(new_freq_mem);\r\nif (pxa_freq_settings[idx].div2) {\r\npreset_mdrefr |= MDREFR_DB2_MASK;\r\npostset_mdrefr |= MDREFR_DB2_MASK;\r\n} else {\r\npostset_mdrefr &= ~MDREFR_DB2_MASK;\r\n}\r\nlocal_irq_save(flags);\r\nwritel(pxa_freq_settings[idx].cccr, CCCR);\r\ncclkcfg = pxa_freq_settings[idx].cclkcfg;\r\nasm volatile(" \n\\r\nldr r4, [%1] /* load MDREFR */ \n\\r\nb 2f \n\\r\n.align 5 \n\\r\n1: \n\\r\nstr %3, [%1] /* preset the MDREFR */ \n\\r\nmcr p14, 0, %2, c6, c0, 0 /* set CCLKCFG[FCS] */ \n\\r\nstr %4, [%1] /* postset the MDREFR */ \n\\r\n\n\\r\nb 3f \n\\r\n2: b 1b \n\\r\n3: nop \n\\r\n"\r\n: "=&r" (unused)\r\n: "r" (MDREFR), "r" (cclkcfg),\r\n"r" (preset_mdrefr), "r" (postset_mdrefr)\r\n: "r4", "r5");\r\nlocal_irq_restore(flags);\r\nif (vcc_core && new_freq_cpu < policy->cur)\r\nret = pxa_cpufreq_change_voltage(&pxa_freq_settings[idx]);\r\nreturn 0;\r\n}\r\nstatic int pxa_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nint i;\r\nunsigned int freq;\r\nstruct cpufreq_frequency_table *pxa255_freq_table;\r\nconst struct pxa_freqs *pxa255_freqs;\r\nif (cpu_is_pxa27x())\r\npxa27x_guess_max_freq();\r\npxa_cpufreq_init_voltages();\r\ninit_sdram_rows();\r\npolicy->cpuinfo.transition_latency = 1000;\r\nfor (i = 0; i < NUM_PXA25x_RUN_FREQS; i++) {\r\npxa255_run_freq_table[i].frequency = pxa255_run_freqs[i].khz;\r\npxa255_run_freq_table[i].driver_data = i;\r\n}\r\npxa255_run_freq_table[i].frequency = CPUFREQ_TABLE_END;\r\nfor (i = 0; i < NUM_PXA25x_TURBO_FREQS; i++) {\r\npxa255_turbo_freq_table[i].frequency =\r\npxa255_turbo_freqs[i].khz;\r\npxa255_turbo_freq_table[i].driver_data = i;\r\n}\r\npxa255_turbo_freq_table[i].frequency = CPUFREQ_TABLE_END;\r\npxa255_turbo_table = !!pxa255_turbo_table;\r\nfor (i = 0; i < NUM_PXA27x_FREQS; i++) {\r\nfreq = pxa27x_freqs[i].khz;\r\nif (freq > pxa27x_maxfreq)\r\nbreak;\r\npxa27x_freq_table[i].frequency = freq;\r\npxa27x_freq_table[i].driver_data = i;\r\n}\r\npxa27x_freq_table[i].driver_data = i;\r\npxa27x_freq_table[i].frequency = CPUFREQ_TABLE_END;\r\nif (cpu_is_pxa25x()) {\r\nfind_freq_tables(&pxa255_freq_table, &pxa255_freqs);\r\npr_info("using %s frequency table\n",\r\npxa255_turbo_table ? "turbo" : "run");\r\ncpufreq_table_validate_and_show(policy, pxa255_freq_table);\r\n}\r\nelse if (cpu_is_pxa27x()) {\r\ncpufreq_table_validate_and_show(policy, pxa27x_freq_table);\r\n}\r\npr_info("frequency change support initialized\n");\r\nreturn 0;\r\n}\r\nstatic int __init pxa_cpu_init(void)\r\n{\r\nint ret = -ENODEV;\r\nif (cpu_is_pxa25x() || cpu_is_pxa27x())\r\nret = cpufreq_register_driver(&pxa_cpufreq_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit pxa_cpu_exit(void)\r\n{\r\ncpufreq_unregister_driver(&pxa_cpufreq_driver);\r\n}
