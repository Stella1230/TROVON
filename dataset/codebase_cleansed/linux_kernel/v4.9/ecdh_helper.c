static inline u8 *ecdh_pack_data(void *dst, const void *src, size_t sz)\r\n{\r\nmemcpy(dst, src, sz);\r\nreturn dst + sz;\r\n}\r\nstatic inline const u8 *ecdh_unpack_data(void *dst, const void *src, size_t sz)\r\n{\r\nmemcpy(dst, src, sz);\r\nreturn src + sz;\r\n}\r\nint crypto_ecdh_key_len(const struct ecdh *params)\r\n{\r\nreturn ECDH_KPP_SECRET_MIN_SIZE + params->key_size;\r\n}\r\nint crypto_ecdh_encode_key(char *buf, unsigned int len,\r\nconst struct ecdh *params)\r\n{\r\nu8 *ptr = buf;\r\nstruct kpp_secret secret = {\r\n.type = CRYPTO_KPP_SECRET_TYPE_ECDH,\r\n.len = len\r\n};\r\nif (unlikely(!buf))\r\nreturn -EINVAL;\r\nif (len != crypto_ecdh_key_len(params))\r\nreturn -EINVAL;\r\nptr = ecdh_pack_data(ptr, &secret, sizeof(secret));\r\nptr = ecdh_pack_data(ptr, &params->curve_id, sizeof(params->curve_id));\r\nptr = ecdh_pack_data(ptr, &params->key_size, sizeof(params->key_size));\r\necdh_pack_data(ptr, params->key, params->key_size);\r\nreturn 0;\r\n}\r\nint crypto_ecdh_decode_key(const char *buf, unsigned int len,\r\nstruct ecdh *params)\r\n{\r\nconst u8 *ptr = buf;\r\nstruct kpp_secret secret;\r\nif (unlikely(!buf || len < ECDH_KPP_SECRET_MIN_SIZE))\r\nreturn -EINVAL;\r\nptr = ecdh_unpack_data(&secret, ptr, sizeof(secret));\r\nif (secret.type != CRYPTO_KPP_SECRET_TYPE_ECDH)\r\nreturn -EINVAL;\r\nptr = ecdh_unpack_data(&params->curve_id, ptr, sizeof(params->curve_id));\r\nptr = ecdh_unpack_data(&params->key_size, ptr, sizeof(params->key_size));\r\nif (secret.len != crypto_ecdh_key_len(params))\r\nreturn -EINVAL;\r\nparams->key = (void *)ptr;\r\nreturn 0;\r\n}
