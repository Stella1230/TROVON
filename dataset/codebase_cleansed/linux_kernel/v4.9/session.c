static int perf_session__open(struct perf_session *session)\r\n{\r\nstruct perf_data_file *file = session->file;\r\nif (perf_session__read_header(session) < 0) {\r\npr_err("incompatible file format (rerun with -v to learn more)\n");\r\nreturn -1;\r\n}\r\nif (perf_data_file__is_pipe(file))\r\nreturn 0;\r\nif (perf_header__has_feat(&session->header, HEADER_STAT))\r\nreturn 0;\r\nif (!perf_evlist__valid_sample_type(session->evlist)) {\r\npr_err("non matching sample_type\n");\r\nreturn -1;\r\n}\r\nif (!perf_evlist__valid_sample_id_all(session->evlist)) {\r\npr_err("non matching sample_id_all\n");\r\nreturn -1;\r\n}\r\nif (!perf_evlist__valid_read_format(session->evlist)) {\r\npr_err("non matching read_format\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid perf_session__set_id_hdr_size(struct perf_session *session)\r\n{\r\nu16 id_hdr_size = perf_evlist__id_hdr_size(session->evlist);\r\nmachines__set_id_hdr_size(&session->machines, id_hdr_size);\r\n}\r\nint perf_session__create_kernel_maps(struct perf_session *session)\r\n{\r\nint ret = machine__create_kernel_maps(&session->machines.host);\r\nif (ret >= 0)\r\nret = machines__create_guest_kernel_maps(&session->machines);\r\nreturn ret;\r\n}\r\nstatic void perf_session__destroy_kernel_maps(struct perf_session *session)\r\n{\r\nmachines__destroy_kernel_maps(&session->machines);\r\n}\r\nstatic bool perf_session__has_comm_exec(struct perf_session *session)\r\n{\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(session->evlist, evsel) {\r\nif (evsel->attr.comm_exec)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void perf_session__set_comm_exec(struct perf_session *session)\r\n{\r\nbool comm_exec = perf_session__has_comm_exec(session);\r\nmachines__set_comm_exec(&session->machines, comm_exec);\r\n}\r\nstatic int ordered_events__deliver_event(struct ordered_events *oe,\r\nstruct ordered_event *event)\r\n{\r\nstruct perf_sample sample;\r\nstruct perf_session *session = container_of(oe, struct perf_session,\r\nordered_events);\r\nint ret = perf_evlist__parse_sample(session->evlist, event->event, &sample);\r\nif (ret) {\r\npr_err("Can't parse sample, err = %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn perf_session__deliver_event(session, event->event, &sample,\r\nsession->tool, event->file_offset);\r\n}\r\nstruct perf_session *perf_session__new(struct perf_data_file *file,\r\nbool repipe, struct perf_tool *tool)\r\n{\r\nstruct perf_session *session = zalloc(sizeof(*session));\r\nif (!session)\r\ngoto out;\r\nsession->repipe = repipe;\r\nsession->tool = tool;\r\nINIT_LIST_HEAD(&session->auxtrace_index);\r\nmachines__init(&session->machines);\r\nordered_events__init(&session->ordered_events, ordered_events__deliver_event);\r\nif (file) {\r\nif (perf_data_file__open(file))\r\ngoto out_delete;\r\nsession->file = file;\r\nif (perf_data_file__is_read(file)) {\r\nif (perf_session__open(session) < 0)\r\ngoto out_close;\r\nperf_session__set_id_hdr_size(session);\r\nperf_session__set_comm_exec(session);\r\n}\r\n} else {\r\nsession->machines.host.env = &perf_env;\r\n}\r\nif (!file || perf_data_file__is_write(file)) {\r\nif (perf_session__create_kernel_maps(session) < 0)\r\npr_warning("Cannot read kernel map\n");\r\n}\r\nif (tool && tool->ordering_requires_timestamps &&\r\ntool->ordered_events && !perf_evlist__sample_id_all(session->evlist)) {\r\ndump_printf("WARNING: No sample_id_all support, falling back to unordered processing\n");\r\ntool->ordered_events = false;\r\n}\r\nreturn session;\r\nout_close:\r\nperf_data_file__close(file);\r\nout_delete:\r\nperf_session__delete(session);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic void perf_session__delete_threads(struct perf_session *session)\r\n{\r\nmachine__delete_threads(&session->machines.host);\r\n}\r\nvoid perf_session__delete(struct perf_session *session)\r\n{\r\nif (session == NULL)\r\nreturn;\r\nauxtrace__free(session);\r\nauxtrace_index__free(&session->auxtrace_index);\r\nperf_session__destroy_kernel_maps(session);\r\nperf_session__delete_threads(session);\r\nperf_env__exit(&session->header.env);\r\nmachines__exit(&session->machines);\r\nif (session->file)\r\nperf_data_file__close(session->file);\r\nfree(session);\r\n}\r\nstatic int process_event_synth_tracing_data_stub(struct perf_tool *tool\r\n__maybe_unused,\r\nunion perf_event *event\r\n__maybe_unused,\r\nstruct perf_session *session\r\n__maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_event_synth_attr_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_evlist **pevlist\r\n__maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_event_synth_event_update_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_evlist **pevlist\r\n__maybe_unused)\r\n{\r\nif (dump_trace)\r\nperf_event__fprintf_event_update(event, stdout);\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_event_sample_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_event_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_finished_round_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct ordered_events *oe __maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int skipn(int fd, off_t n)\r\n{\r\nchar buf[4096];\r\nssize_t ret;\r\nwhile (n > 0) {\r\nret = read(fd, buf, min(n, (off_t)sizeof(buf)));\r\nif (ret <= 0)\r\nreturn ret;\r\nn -= ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic s64 process_event_auxtrace_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_session *session\r\n__maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nif (perf_data_file__is_pipe(session->file))\r\nskipn(perf_data_file__fd(session->file), event->auxtrace.size);\r\nreturn event->auxtrace.size;\r\n}\r\nstatic int process_event_op2_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *session __maybe_unused)\r\n{\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic\r\nint process_event_thread_map_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *session __maybe_unused)\r\n{\r\nif (dump_trace)\r\nperf_event__fprintf_thread_map(event, stdout);\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic\r\nint process_event_cpu_map_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *session __maybe_unused)\r\n{\r\nif (dump_trace)\r\nperf_event__fprintf_cpu_map(event, stdout);\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic\r\nint process_event_stat_config_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *session __maybe_unused)\r\n{\r\nif (dump_trace)\r\nperf_event__fprintf_stat_config(event, stdout);\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_stat_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *perf_session\r\n__maybe_unused)\r\n{\r\nif (dump_trace)\r\nperf_event__fprintf_stat(event, stdout);\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nstatic int process_stat_round_stub(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *perf_session\r\n__maybe_unused)\r\n{\r\nif (dump_trace)\r\nperf_event__fprintf_stat_round(event, stdout);\r\ndump_printf(": unhandled!\n");\r\nreturn 0;\r\n}\r\nvoid perf_tool__fill_defaults(struct perf_tool *tool)\r\n{\r\nif (tool->sample == NULL)\r\ntool->sample = process_event_sample_stub;\r\nif (tool->mmap == NULL)\r\ntool->mmap = process_event_stub;\r\nif (tool->mmap2 == NULL)\r\ntool->mmap2 = process_event_stub;\r\nif (tool->comm == NULL)\r\ntool->comm = process_event_stub;\r\nif (tool->fork == NULL)\r\ntool->fork = process_event_stub;\r\nif (tool->exit == NULL)\r\ntool->exit = process_event_stub;\r\nif (tool->lost == NULL)\r\ntool->lost = perf_event__process_lost;\r\nif (tool->lost_samples == NULL)\r\ntool->lost_samples = perf_event__process_lost_samples;\r\nif (tool->aux == NULL)\r\ntool->aux = perf_event__process_aux;\r\nif (tool->itrace_start == NULL)\r\ntool->itrace_start = perf_event__process_itrace_start;\r\nif (tool->context_switch == NULL)\r\ntool->context_switch = perf_event__process_switch;\r\nif (tool->read == NULL)\r\ntool->read = process_event_sample_stub;\r\nif (tool->throttle == NULL)\r\ntool->throttle = process_event_stub;\r\nif (tool->unthrottle == NULL)\r\ntool->unthrottle = process_event_stub;\r\nif (tool->attr == NULL)\r\ntool->attr = process_event_synth_attr_stub;\r\nif (tool->event_update == NULL)\r\ntool->event_update = process_event_synth_event_update_stub;\r\nif (tool->tracing_data == NULL)\r\ntool->tracing_data = process_event_synth_tracing_data_stub;\r\nif (tool->build_id == NULL)\r\ntool->build_id = process_event_op2_stub;\r\nif (tool->finished_round == NULL) {\r\nif (tool->ordered_events)\r\ntool->finished_round = process_finished_round;\r\nelse\r\ntool->finished_round = process_finished_round_stub;\r\n}\r\nif (tool->id_index == NULL)\r\ntool->id_index = process_event_op2_stub;\r\nif (tool->auxtrace_info == NULL)\r\ntool->auxtrace_info = process_event_op2_stub;\r\nif (tool->auxtrace == NULL)\r\ntool->auxtrace = process_event_auxtrace_stub;\r\nif (tool->auxtrace_error == NULL)\r\ntool->auxtrace_error = process_event_op2_stub;\r\nif (tool->thread_map == NULL)\r\ntool->thread_map = process_event_thread_map_stub;\r\nif (tool->cpu_map == NULL)\r\ntool->cpu_map = process_event_cpu_map_stub;\r\nif (tool->stat_config == NULL)\r\ntool->stat_config = process_event_stat_config_stub;\r\nif (tool->stat == NULL)\r\ntool->stat = process_stat_stub;\r\nif (tool->stat_round == NULL)\r\ntool->stat_round = process_stat_round_stub;\r\nif (tool->time_conv == NULL)\r\ntool->time_conv = process_event_op2_stub;\r\n}\r\nstatic void swap_sample_id_all(union perf_event *event, void *data)\r\n{\r\nvoid *end = (void *) event + event->header.size;\r\nint size = end - data;\r\nBUG_ON(size % sizeof(u64));\r\nmem_bswap_64(data, size);\r\n}\r\nstatic void perf_event__all64_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nstruct perf_event_header *hdr = &event->header;\r\nmem_bswap_64(hdr + 1, event->header.size - sizeof(*hdr));\r\n}\r\nstatic void perf_event__comm_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nevent->comm.pid = bswap_32(event->comm.pid);\r\nevent->comm.tid = bswap_32(event->comm.tid);\r\nif (sample_id_all) {\r\nvoid *data = &event->comm.comm;\r\ndata += PERF_ALIGN(strlen(data) + 1, sizeof(u64));\r\nswap_sample_id_all(event, data);\r\n}\r\n}\r\nstatic void perf_event__mmap_swap(union perf_event *event,\r\nbool sample_id_all)\r\n{\r\nevent->mmap.pid = bswap_32(event->mmap.pid);\r\nevent->mmap.tid = bswap_32(event->mmap.tid);\r\nevent->mmap.start = bswap_64(event->mmap.start);\r\nevent->mmap.len = bswap_64(event->mmap.len);\r\nevent->mmap.pgoff = bswap_64(event->mmap.pgoff);\r\nif (sample_id_all) {\r\nvoid *data = &event->mmap.filename;\r\ndata += PERF_ALIGN(strlen(data) + 1, sizeof(u64));\r\nswap_sample_id_all(event, data);\r\n}\r\n}\r\nstatic void perf_event__mmap2_swap(union perf_event *event,\r\nbool sample_id_all)\r\n{\r\nevent->mmap2.pid = bswap_32(event->mmap2.pid);\r\nevent->mmap2.tid = bswap_32(event->mmap2.tid);\r\nevent->mmap2.start = bswap_64(event->mmap2.start);\r\nevent->mmap2.len = bswap_64(event->mmap2.len);\r\nevent->mmap2.pgoff = bswap_64(event->mmap2.pgoff);\r\nevent->mmap2.maj = bswap_32(event->mmap2.maj);\r\nevent->mmap2.min = bswap_32(event->mmap2.min);\r\nevent->mmap2.ino = bswap_64(event->mmap2.ino);\r\nif (sample_id_all) {\r\nvoid *data = &event->mmap2.filename;\r\ndata += PERF_ALIGN(strlen(data) + 1, sizeof(u64));\r\nswap_sample_id_all(event, data);\r\n}\r\n}\r\nstatic void perf_event__task_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nevent->fork.pid = bswap_32(event->fork.pid);\r\nevent->fork.tid = bswap_32(event->fork.tid);\r\nevent->fork.ppid = bswap_32(event->fork.ppid);\r\nevent->fork.ptid = bswap_32(event->fork.ptid);\r\nevent->fork.time = bswap_64(event->fork.time);\r\nif (sample_id_all)\r\nswap_sample_id_all(event, &event->fork + 1);\r\n}\r\nstatic void perf_event__read_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nevent->read.pid = bswap_32(event->read.pid);\r\nevent->read.tid = bswap_32(event->read.tid);\r\nevent->read.value = bswap_64(event->read.value);\r\nevent->read.time_enabled = bswap_64(event->read.time_enabled);\r\nevent->read.time_running = bswap_64(event->read.time_running);\r\nevent->read.id = bswap_64(event->read.id);\r\nif (sample_id_all)\r\nswap_sample_id_all(event, &event->read + 1);\r\n}\r\nstatic void perf_event__aux_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nevent->aux.aux_offset = bswap_64(event->aux.aux_offset);\r\nevent->aux.aux_size = bswap_64(event->aux.aux_size);\r\nevent->aux.flags = bswap_64(event->aux.flags);\r\nif (sample_id_all)\r\nswap_sample_id_all(event, &event->aux + 1);\r\n}\r\nstatic void perf_event__itrace_start_swap(union perf_event *event,\r\nbool sample_id_all)\r\n{\r\nevent->itrace_start.pid = bswap_32(event->itrace_start.pid);\r\nevent->itrace_start.tid = bswap_32(event->itrace_start.tid);\r\nif (sample_id_all)\r\nswap_sample_id_all(event, &event->itrace_start + 1);\r\n}\r\nstatic void perf_event__switch_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nif (event->header.type == PERF_RECORD_SWITCH_CPU_WIDE) {\r\nevent->context_switch.next_prev_pid =\r\nbswap_32(event->context_switch.next_prev_pid);\r\nevent->context_switch.next_prev_tid =\r\nbswap_32(event->context_switch.next_prev_tid);\r\n}\r\nif (sample_id_all)\r\nswap_sample_id_all(event, &event->context_switch + 1);\r\n}\r\nstatic void perf_event__throttle_swap(union perf_event *event,\r\nbool sample_id_all)\r\n{\r\nevent->throttle.time = bswap_64(event->throttle.time);\r\nevent->throttle.id = bswap_64(event->throttle.id);\r\nevent->throttle.stream_id = bswap_64(event->throttle.stream_id);\r\nif (sample_id_all)\r\nswap_sample_id_all(event, &event->throttle + 1);\r\n}\r\nstatic u8 revbyte(u8 b)\r\n{\r\nint rev = (b >> 4) | ((b & 0xf) << 4);\r\nrev = ((rev & 0xcc) >> 2) | ((rev & 0x33) << 2);\r\nrev = ((rev & 0xaa) >> 1) | ((rev & 0x55) << 1);\r\nreturn (u8) rev;\r\n}\r\nstatic void swap_bitfield(u8 *p, unsigned len)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < len; i++) {\r\n*p = revbyte(*p);\r\np++;\r\n}\r\n}\r\nvoid perf_event__attr_swap(struct perf_event_attr *attr)\r\n{\r\nattr->type = bswap_32(attr->type);\r\nattr->size = bswap_32(attr->size);\r\n#define bswap_safe(f, n) \\r\n(attr->size > (offsetof(struct perf_event_attr, f) + \\r\nsizeof(attr->f) * (n)))\r\n#define bswap_field(f, sz) \\r\ndo { \\r\nif (bswap_safe(f, 0)) \\r\nattr->f = bswap_##sz(attr->f); \\r\n} while(0)\r\n#define bswap_field_16(f) bswap_field(f, 16)\r\n#define bswap_field_32(f) bswap_field(f, 32)\r\n#define bswap_field_64(f) bswap_field(f, 64)\r\nbswap_field_64(config);\r\nbswap_field_64(sample_period);\r\nbswap_field_64(sample_type);\r\nbswap_field_64(read_format);\r\nbswap_field_32(wakeup_events);\r\nbswap_field_32(bp_type);\r\nbswap_field_64(bp_addr);\r\nbswap_field_64(bp_len);\r\nbswap_field_64(branch_sample_type);\r\nbswap_field_64(sample_regs_user);\r\nbswap_field_32(sample_stack_user);\r\nbswap_field_32(aux_watermark);\r\nbswap_field_16(sample_max_stack);\r\nif (bswap_safe(read_format, 1))\r\nswap_bitfield((u8 *) (&attr->read_format + 1),\r\nsizeof(u64));\r\n#undef bswap_field_64\r\n#undef bswap_field_32\r\n#undef bswap_field\r\n#undef bswap_safe\r\n}\r\nstatic void perf_event__hdr_attr_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nsize_t size;\r\nperf_event__attr_swap(&event->attr.attr);\r\nsize = event->header.size;\r\nsize -= (void *)&event->attr.id - (void *)event;\r\nmem_bswap_64(event->attr.id, size);\r\n}\r\nstatic void perf_event__event_update_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->event_update.type = bswap_64(event->event_update.type);\r\nevent->event_update.id = bswap_64(event->event_update.id);\r\n}\r\nstatic void perf_event__event_type_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->event_type.event_type.event_id =\r\nbswap_64(event->event_type.event_type.event_id);\r\n}\r\nstatic void perf_event__tracing_data_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->tracing_data.size = bswap_32(event->tracing_data.size);\r\n}\r\nstatic void perf_event__auxtrace_info_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nsize_t size;\r\nevent->auxtrace_info.type = bswap_32(event->auxtrace_info.type);\r\nsize = event->header.size;\r\nsize -= (void *)&event->auxtrace_info.priv - (void *)event;\r\nmem_bswap_64(event->auxtrace_info.priv, size);\r\n}\r\nstatic void perf_event__auxtrace_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->auxtrace.size = bswap_64(event->auxtrace.size);\r\nevent->auxtrace.offset = bswap_64(event->auxtrace.offset);\r\nevent->auxtrace.reference = bswap_64(event->auxtrace.reference);\r\nevent->auxtrace.idx = bswap_32(event->auxtrace.idx);\r\nevent->auxtrace.tid = bswap_32(event->auxtrace.tid);\r\nevent->auxtrace.cpu = bswap_32(event->auxtrace.cpu);\r\n}\r\nstatic void perf_event__auxtrace_error_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->auxtrace_error.type = bswap_32(event->auxtrace_error.type);\r\nevent->auxtrace_error.code = bswap_32(event->auxtrace_error.code);\r\nevent->auxtrace_error.cpu = bswap_32(event->auxtrace_error.cpu);\r\nevent->auxtrace_error.pid = bswap_32(event->auxtrace_error.pid);\r\nevent->auxtrace_error.tid = bswap_32(event->auxtrace_error.tid);\r\nevent->auxtrace_error.ip = bswap_64(event->auxtrace_error.ip);\r\n}\r\nstatic void perf_event__thread_map_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nunsigned i;\r\nevent->thread_map.nr = bswap_64(event->thread_map.nr);\r\nfor (i = 0; i < event->thread_map.nr; i++)\r\nevent->thread_map.entries[i].pid = bswap_64(event->thread_map.entries[i].pid);\r\n}\r\nstatic void perf_event__cpu_map_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nstruct cpu_map_data *data = &event->cpu_map.data;\r\nstruct cpu_map_entries *cpus;\r\nstruct cpu_map_mask *mask;\r\nunsigned i;\r\ndata->type = bswap_64(data->type);\r\nswitch (data->type) {\r\ncase PERF_CPU_MAP__CPUS:\r\ncpus = (struct cpu_map_entries *)data->data;\r\ncpus->nr = bswap_16(cpus->nr);\r\nfor (i = 0; i < cpus->nr; i++)\r\ncpus->cpu[i] = bswap_16(cpus->cpu[i]);\r\nbreak;\r\ncase PERF_CPU_MAP__MASK:\r\nmask = (struct cpu_map_mask *) data->data;\r\nmask->nr = bswap_16(mask->nr);\r\nmask->long_size = bswap_16(mask->long_size);\r\nswitch (mask->long_size) {\r\ncase 4: mem_bswap_32(&mask->mask, mask->nr); break;\r\ncase 8: mem_bswap_64(&mask->mask, mask->nr); break;\r\ndefault:\r\npr_err("cpu_map swap: unsupported long size\n");\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void perf_event__stat_config_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nu64 size;\r\nsize = event->stat_config.nr * sizeof(event->stat_config.data[0]);\r\nsize += 1;\r\nmem_bswap_64(&event->stat_config.nr, size);\r\n}\r\nstatic void perf_event__stat_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->stat.id = bswap_64(event->stat.id);\r\nevent->stat.thread = bswap_32(event->stat.thread);\r\nevent->stat.cpu = bswap_32(event->stat.cpu);\r\nevent->stat.val = bswap_64(event->stat.val);\r\nevent->stat.ena = bswap_64(event->stat.ena);\r\nevent->stat.run = bswap_64(event->stat.run);\r\n}\r\nstatic void perf_event__stat_round_swap(union perf_event *event,\r\nbool sample_id_all __maybe_unused)\r\n{\r\nevent->stat_round.type = bswap_64(event->stat_round.type);\r\nevent->stat_round.time = bswap_64(event->stat_round.time);\r\n}\r\nstatic int process_finished_round(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct ordered_events *oe)\r\n{\r\nif (dump_trace)\r\nfprintf(stdout, "\n");\r\nreturn ordered_events__flush(oe, OE_FLUSH__ROUND);\r\n}\r\nint perf_session__queue_event(struct perf_session *s, union perf_event *event,\r\nstruct perf_sample *sample, u64 file_offset)\r\n{\r\nreturn ordered_events__queue(&s->ordered_events, event, sample, file_offset);\r\n}\r\nstatic void callchain__lbr_callstack_printf(struct perf_sample *sample)\r\n{\r\nstruct ip_callchain *callchain = sample->callchain;\r\nstruct branch_stack *lbr_stack = sample->branch_stack;\r\nu64 kernel_callchain_nr = callchain->nr;\r\nunsigned int i;\r\nfor (i = 0; i < kernel_callchain_nr; i++) {\r\nif (callchain->ips[i] == PERF_CONTEXT_USER)\r\nbreak;\r\n}\r\nif ((i != kernel_callchain_nr) && lbr_stack->nr) {\r\nu64 total_nr;\r\ntotal_nr = i + 1 + lbr_stack->nr + 1;\r\nkernel_callchain_nr = i + 1;\r\nprintf("... LBR call chain: nr:%" PRIu64 "\n", total_nr);\r\nfor (i = 0; i < kernel_callchain_nr; i++)\r\nprintf("..... %2d: %016" PRIx64 "\n",\r\ni, callchain->ips[i]);\r\nprintf("..... %2d: %016" PRIx64 "\n",\r\n(int)(kernel_callchain_nr), lbr_stack->entries[0].to);\r\nfor (i = 0; i < lbr_stack->nr; i++)\r\nprintf("..... %2d: %016" PRIx64 "\n",\r\n(int)(i + kernel_callchain_nr + 1), lbr_stack->entries[i].from);\r\n}\r\n}\r\nstatic void callchain__printf(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nunsigned int i;\r\nstruct ip_callchain *callchain = sample->callchain;\r\nif (perf_evsel__has_branch_callstack(evsel))\r\ncallchain__lbr_callstack_printf(sample);\r\nprintf("... FP chain: nr:%" PRIu64 "\n", callchain->nr);\r\nfor (i = 0; i < callchain->nr; i++)\r\nprintf("..... %2d: %016" PRIx64 "\n",\r\ni, callchain->ips[i]);\r\n}\r\nstatic void branch_stack__printf(struct perf_sample *sample)\r\n{\r\nuint64_t i;\r\nprintf("... branch stack: nr:%" PRIu64 "\n", sample->branch_stack->nr);\r\nfor (i = 0; i < sample->branch_stack->nr; i++) {\r\nstruct branch_entry *e = &sample->branch_stack->entries[i];\r\nprintf("..... %2"PRIu64": %016" PRIx64 " -> %016" PRIx64 " %hu cycles %s%s%s%s %x\n",\r\ni, e->from, e->to,\r\ne->flags.cycles,\r\ne->flags.mispred ? "M" : " ",\r\ne->flags.predicted ? "P" : " ",\r\ne->flags.abort ? "A" : " ",\r\ne->flags.in_tx ? "T" : " ",\r\n(unsigned)e->flags.reserved);\r\n}\r\n}\r\nstatic void regs_dump__printf(u64 mask, u64 *regs)\r\n{\r\nunsigned rid, i = 0;\r\nfor_each_set_bit(rid, (unsigned long *) &mask, sizeof(mask) * 8) {\r\nu64 val = regs[i++];\r\nprintf(".... %-5s 0x%" PRIx64 "\n",\r\nperf_reg_name(rid), val);\r\n}\r\n}\r\nstatic inline const char *regs_dump_abi(struct regs_dump *d)\r\n{\r\nif (d->abi > PERF_SAMPLE_REGS_ABI_64)\r\nreturn "unknown";\r\nreturn regs_abi[d->abi];\r\n}\r\nstatic void regs__printf(const char *type, struct regs_dump *regs)\r\n{\r\nu64 mask = regs->mask;\r\nprintf("... %s regs: mask 0x%" PRIx64 " ABI %s\n",\r\ntype,\r\nmask,\r\nregs_dump_abi(regs));\r\nregs_dump__printf(mask, regs->regs);\r\n}\r\nstatic void regs_user__printf(struct perf_sample *sample)\r\n{\r\nstruct regs_dump *user_regs = &sample->user_regs;\r\nif (user_regs->regs)\r\nregs__printf("user", user_regs);\r\n}\r\nstatic void regs_intr__printf(struct perf_sample *sample)\r\n{\r\nstruct regs_dump *intr_regs = &sample->intr_regs;\r\nif (intr_regs->regs)\r\nregs__printf("intr", intr_regs);\r\n}\r\nstatic void stack_user__printf(struct stack_dump *dump)\r\n{\r\nprintf("... ustack: size %" PRIu64 ", offset 0x%x\n",\r\ndump->size, dump->offset);\r\n}\r\nstatic void perf_evlist__print_tstamp(struct perf_evlist *evlist,\r\nunion perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nu64 sample_type = __perf_evlist__combined_sample_type(evlist);\r\nif (event->header.type != PERF_RECORD_SAMPLE &&\r\n!perf_evlist__sample_id_all(evlist)) {\r\nfputs("-1 -1 ", stdout);\r\nreturn;\r\n}\r\nif ((sample_type & PERF_SAMPLE_CPU))\r\nprintf("%u ", sample->cpu);\r\nif (sample_type & PERF_SAMPLE_TIME)\r\nprintf("%" PRIu64 " ", sample->time);\r\n}\r\nstatic void sample_read__printf(struct perf_sample *sample, u64 read_format)\r\n{\r\nprintf("... sample_read:\n");\r\nif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\r\nprintf("...... time enabled %016" PRIx64 "\n",\r\nsample->read.time_enabled);\r\nif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\r\nprintf("...... time running %016" PRIx64 "\n",\r\nsample->read.time_running);\r\nif (read_format & PERF_FORMAT_GROUP) {\r\nu64 i;\r\nprintf(".... group nr %" PRIu64 "\n", sample->read.group.nr);\r\nfor (i = 0; i < sample->read.group.nr; i++) {\r\nstruct sample_read_value *value;\r\nvalue = &sample->read.group.values[i];\r\nprintf("..... id %016" PRIx64\r\n", value %016" PRIx64 "\n",\r\nvalue->id, value->value);\r\n}\r\n} else\r\nprintf("..... id %016" PRIx64 ", value %016" PRIx64 "\n",\r\nsample->read.one.id, sample->read.one.value);\r\n}\r\nstatic void dump_event(struct perf_evlist *evlist, union perf_event *event,\r\nu64 file_offset, struct perf_sample *sample)\r\n{\r\nif (!dump_trace)\r\nreturn;\r\nprintf("\n%#" PRIx64 " [%#x]: event: %d\n",\r\nfile_offset, event->header.size, event->header.type);\r\ntrace_event(event);\r\nif (sample)\r\nperf_evlist__print_tstamp(evlist, event, sample);\r\nprintf("%#" PRIx64 " [%#x]: PERF_RECORD_%s", file_offset,\r\nevent->header.size, perf_event__name(event->header.type));\r\n}\r\nstatic void dump_sample(struct perf_evsel *evsel, union perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nu64 sample_type;\r\nif (!dump_trace)\r\nreturn;\r\nprintf("(IP, 0x%x): %d/%d: %#" PRIx64 " period: %" PRIu64 " addr: %#" PRIx64 "\n",\r\nevent->header.misc, sample->pid, sample->tid, sample->ip,\r\nsample->period, sample->addr);\r\nsample_type = evsel->attr.sample_type;\r\nif (sample_type & PERF_SAMPLE_CALLCHAIN)\r\ncallchain__printf(evsel, sample);\r\nif ((sample_type & PERF_SAMPLE_BRANCH_STACK) && !perf_evsel__has_branch_callstack(evsel))\r\nbranch_stack__printf(sample);\r\nif (sample_type & PERF_SAMPLE_REGS_USER)\r\nregs_user__printf(sample);\r\nif (sample_type & PERF_SAMPLE_REGS_INTR)\r\nregs_intr__printf(sample);\r\nif (sample_type & PERF_SAMPLE_STACK_USER)\r\nstack_user__printf(&sample->user_stack);\r\nif (sample_type & PERF_SAMPLE_WEIGHT)\r\nprintf("... weight: %" PRIu64 "\n", sample->weight);\r\nif (sample_type & PERF_SAMPLE_DATA_SRC)\r\nprintf(" . data_src: 0x%"PRIx64"\n", sample->data_src);\r\nif (sample_type & PERF_SAMPLE_TRANSACTION)\r\nprintf("... transaction: %" PRIx64 "\n", sample->transaction);\r\nif (sample_type & PERF_SAMPLE_READ)\r\nsample_read__printf(sample, evsel->attr.read_format);\r\n}\r\nstatic struct machine *machines__find_for_cpumode(struct machines *machines,\r\nunion perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nstruct machine *machine;\r\nif (perf_guest &&\r\n((sample->cpumode == PERF_RECORD_MISC_GUEST_KERNEL) ||\r\n(sample->cpumode == PERF_RECORD_MISC_GUEST_USER))) {\r\nu32 pid;\r\nif (event->header.type == PERF_RECORD_MMAP\r\n|| event->header.type == PERF_RECORD_MMAP2)\r\npid = event->mmap.pid;\r\nelse\r\npid = sample->pid;\r\nmachine = machines__find(machines, pid);\r\nif (!machine)\r\nmachine = machines__findnew(machines, DEFAULT_GUEST_KERNEL_ID);\r\nreturn machine;\r\n}\r\nreturn &machines->host;\r\n}\r\nstatic int deliver_sample_value(struct perf_evlist *evlist,\r\nstruct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct sample_read_value *v,\r\nstruct machine *machine)\r\n{\r\nstruct perf_sample_id *sid = perf_evlist__id2sid(evlist, v->id);\r\nif (sid) {\r\nsample->id = v->id;\r\nsample->period = v->value - sid->period;\r\nsid->period = v->value;\r\n}\r\nif (!sid || sid->evsel == NULL) {\r\n++evlist->stats.nr_unknown_id;\r\nreturn 0;\r\n}\r\nreturn tool->sample(tool, event, sample, sid->evsel, machine);\r\n}\r\nstatic int deliver_sample_group(struct perf_evlist *evlist,\r\nstruct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint ret = -EINVAL;\r\nu64 i;\r\nfor (i = 0; i < sample->read.group.nr; i++) {\r\nret = deliver_sample_value(evlist, tool, event, sample,\r\n&sample->read.group.values[i],\r\nmachine);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nperf_evlist__deliver_sample(struct perf_evlist *evlist,\r\nstruct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nu64 sample_type = evsel->attr.sample_type;\r\nu64 read_format = evsel->attr.read_format;\r\nif (!(sample_type & PERF_SAMPLE_READ))\r\nreturn tool->sample(tool, event, sample, evsel, machine);\r\nif (read_format & PERF_FORMAT_GROUP)\r\nreturn deliver_sample_group(evlist, tool, event, sample,\r\nmachine);\r\nelse\r\nreturn deliver_sample_value(evlist, tool, event, sample,\r\n&sample->read.one, machine);\r\n}\r\nstatic int machines__deliver_event(struct machines *machines,\r\nstruct perf_evlist *evlist,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_tool *tool, u64 file_offset)\r\n{\r\nstruct perf_evsel *evsel;\r\nstruct machine *machine;\r\ndump_event(evlist, event, file_offset, sample);\r\nevsel = perf_evlist__id2evsel(evlist, sample->id);\r\nmachine = machines__find_for_cpumode(machines, event, sample);\r\nswitch (event->header.type) {\r\ncase PERF_RECORD_SAMPLE:\r\nif (evsel == NULL) {\r\n++evlist->stats.nr_unknown_id;\r\nreturn 0;\r\n}\r\ndump_sample(evsel, event, sample);\r\nif (machine == NULL) {\r\n++evlist->stats.nr_unprocessable_samples;\r\nreturn 0;\r\n}\r\nreturn perf_evlist__deliver_sample(evlist, tool, event, sample, evsel, machine);\r\ncase PERF_RECORD_MMAP:\r\nreturn tool->mmap(tool, event, sample, machine);\r\ncase PERF_RECORD_MMAP2:\r\nif (event->header.misc & PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT)\r\n++evlist->stats.nr_proc_map_timeout;\r\nreturn tool->mmap2(tool, event, sample, machine);\r\ncase PERF_RECORD_COMM:\r\nreturn tool->comm(tool, event, sample, machine);\r\ncase PERF_RECORD_FORK:\r\nreturn tool->fork(tool, event, sample, machine);\r\ncase PERF_RECORD_EXIT:\r\nreturn tool->exit(tool, event, sample, machine);\r\ncase PERF_RECORD_LOST:\r\nif (tool->lost == perf_event__process_lost)\r\nevlist->stats.total_lost += event->lost.lost;\r\nreturn tool->lost(tool, event, sample, machine);\r\ncase PERF_RECORD_LOST_SAMPLES:\r\nif (tool->lost_samples == perf_event__process_lost_samples)\r\nevlist->stats.total_lost_samples += event->lost_samples.lost;\r\nreturn tool->lost_samples(tool, event, sample, machine);\r\ncase PERF_RECORD_READ:\r\nreturn tool->read(tool, event, sample, evsel, machine);\r\ncase PERF_RECORD_THROTTLE:\r\nreturn tool->throttle(tool, event, sample, machine);\r\ncase PERF_RECORD_UNTHROTTLE:\r\nreturn tool->unthrottle(tool, event, sample, machine);\r\ncase PERF_RECORD_AUX:\r\nif (tool->aux == perf_event__process_aux &&\r\n(event->aux.flags & PERF_AUX_FLAG_TRUNCATED))\r\nevlist->stats.total_aux_lost += 1;\r\nreturn tool->aux(tool, event, sample, machine);\r\ncase PERF_RECORD_ITRACE_START:\r\nreturn tool->itrace_start(tool, event, sample, machine);\r\ncase PERF_RECORD_SWITCH:\r\ncase PERF_RECORD_SWITCH_CPU_WIDE:\r\nreturn tool->context_switch(tool, event, sample, machine);\r\ndefault:\r\n++evlist->stats.nr_unknown_events;\r\nreturn -1;\r\n}\r\n}\r\nstatic int perf_session__deliver_event(struct perf_session *session,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_tool *tool,\r\nu64 file_offset)\r\n{\r\nint ret;\r\nret = auxtrace__process_event(session, event, sample, tool);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret > 0)\r\nreturn 0;\r\nreturn machines__deliver_event(&session->machines, session->evlist,\r\nevent, sample, tool, file_offset);\r\n}\r\nstatic s64 perf_session__process_user_event(struct perf_session *session,\r\nunion perf_event *event,\r\nu64 file_offset)\r\n{\r\nstruct ordered_events *oe = &session->ordered_events;\r\nstruct perf_tool *tool = session->tool;\r\nint fd = perf_data_file__fd(session->file);\r\nint err;\r\ndump_event(session->evlist, event, file_offset, NULL);\r\nswitch (event->header.type) {\r\ncase PERF_RECORD_HEADER_ATTR:\r\nerr = tool->attr(tool, event, &session->evlist);\r\nif (err == 0) {\r\nperf_session__set_id_hdr_size(session);\r\nperf_session__set_comm_exec(session);\r\n}\r\nreturn err;\r\ncase PERF_RECORD_EVENT_UPDATE:\r\nreturn tool->event_update(tool, event, &session->evlist);\r\ncase PERF_RECORD_HEADER_EVENT_TYPE:\r\nreturn 0;\r\ncase PERF_RECORD_HEADER_TRACING_DATA:\r\nlseek(fd, file_offset, SEEK_SET);\r\nreturn tool->tracing_data(tool, event, session);\r\ncase PERF_RECORD_HEADER_BUILD_ID:\r\nreturn tool->build_id(tool, event, session);\r\ncase PERF_RECORD_FINISHED_ROUND:\r\nreturn tool->finished_round(tool, event, oe);\r\ncase PERF_RECORD_ID_INDEX:\r\nreturn tool->id_index(tool, event, session);\r\ncase PERF_RECORD_AUXTRACE_INFO:\r\nreturn tool->auxtrace_info(tool, event, session);\r\ncase PERF_RECORD_AUXTRACE:\r\nlseek(fd, file_offset + event->header.size, SEEK_SET);\r\nreturn tool->auxtrace(tool, event, session);\r\ncase PERF_RECORD_AUXTRACE_ERROR:\r\nperf_session__auxtrace_error_inc(session, event);\r\nreturn tool->auxtrace_error(tool, event, session);\r\ncase PERF_RECORD_THREAD_MAP:\r\nreturn tool->thread_map(tool, event, session);\r\ncase PERF_RECORD_CPU_MAP:\r\nreturn tool->cpu_map(tool, event, session);\r\ncase PERF_RECORD_STAT_CONFIG:\r\nreturn tool->stat_config(tool, event, session);\r\ncase PERF_RECORD_STAT:\r\nreturn tool->stat(tool, event, session);\r\ncase PERF_RECORD_STAT_ROUND:\r\nreturn tool->stat_round(tool, event, session);\r\ncase PERF_RECORD_TIME_CONV:\r\nsession->time_conv = event->time_conv;\r\nreturn tool->time_conv(tool, event, session);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint perf_session__deliver_synth_event(struct perf_session *session,\r\nunion perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nstruct perf_evlist *evlist = session->evlist;\r\nstruct perf_tool *tool = session->tool;\r\nevents_stats__inc(&evlist->stats, event->header.type);\r\nif (event->header.type >= PERF_RECORD_USER_TYPE_START)\r\nreturn perf_session__process_user_event(session, event, 0);\r\nreturn machines__deliver_event(&session->machines, evlist, event, sample, tool, 0);\r\n}\r\nstatic void event_swap(union perf_event *event, bool sample_id_all)\r\n{\r\nperf_event__swap_op swap;\r\nswap = perf_event__swap_ops[event->header.type];\r\nif (swap)\r\nswap(event, sample_id_all);\r\n}\r\nint perf_session__peek_event(struct perf_session *session, off_t file_offset,\r\nvoid *buf, size_t buf_sz,\r\nunion perf_event **event_ptr,\r\nstruct perf_sample *sample)\r\n{\r\nunion perf_event *event;\r\nsize_t hdr_sz, rest;\r\nint fd;\r\nif (session->one_mmap && !session->header.needs_swap) {\r\nevent = file_offset - session->one_mmap_offset +\r\nsession->one_mmap_addr;\r\ngoto out_parse_sample;\r\n}\r\nif (perf_data_file__is_pipe(session->file))\r\nreturn -1;\r\nfd = perf_data_file__fd(session->file);\r\nhdr_sz = sizeof(struct perf_event_header);\r\nif (buf_sz < hdr_sz)\r\nreturn -1;\r\nif (lseek(fd, file_offset, SEEK_SET) == (off_t)-1 ||\r\nreadn(fd, buf, hdr_sz) != (ssize_t)hdr_sz)\r\nreturn -1;\r\nevent = (union perf_event *)buf;\r\nif (session->header.needs_swap)\r\nperf_event_header__bswap(&event->header);\r\nif (event->header.size < hdr_sz || event->header.size > buf_sz)\r\nreturn -1;\r\nrest = event->header.size - hdr_sz;\r\nif (readn(fd, buf, rest) != (ssize_t)rest)\r\nreturn -1;\r\nif (session->header.needs_swap)\r\nevent_swap(event, perf_evlist__sample_id_all(session->evlist));\r\nout_parse_sample:\r\nif (sample && event->header.type < PERF_RECORD_USER_TYPE_START &&\r\nperf_evlist__parse_sample(session->evlist, event, sample))\r\nreturn -1;\r\n*event_ptr = event;\r\nreturn 0;\r\n}\r\nstatic s64 perf_session__process_event(struct perf_session *session,\r\nunion perf_event *event, u64 file_offset)\r\n{\r\nstruct perf_evlist *evlist = session->evlist;\r\nstruct perf_tool *tool = session->tool;\r\nstruct perf_sample sample;\r\nint ret;\r\nif (session->header.needs_swap)\r\nevent_swap(event, perf_evlist__sample_id_all(evlist));\r\nif (event->header.type >= PERF_RECORD_HEADER_MAX)\r\nreturn -EINVAL;\r\nevents_stats__inc(&evlist->stats, event->header.type);\r\nif (event->header.type >= PERF_RECORD_USER_TYPE_START)\r\nreturn perf_session__process_user_event(session, event, file_offset);\r\nret = perf_evlist__parse_sample(evlist, event, &sample);\r\nif (ret)\r\nreturn ret;\r\nif (tool->ordered_events) {\r\nret = perf_session__queue_event(session, event, &sample, file_offset);\r\nif (ret != -ETIME)\r\nreturn ret;\r\n}\r\nreturn perf_session__deliver_event(session, event, &sample, tool,\r\nfile_offset);\r\n}\r\nvoid perf_event_header__bswap(struct perf_event_header *hdr)\r\n{\r\nhdr->type = bswap_32(hdr->type);\r\nhdr->misc = bswap_16(hdr->misc);\r\nhdr->size = bswap_16(hdr->size);\r\n}\r\nstruct thread *perf_session__findnew(struct perf_session *session, pid_t pid)\r\n{\r\nreturn machine__findnew_thread(&session->machines.host, -1, pid);\r\n}\r\nint perf_session__register_idle_thread(struct perf_session *session)\r\n{\r\nstruct thread *thread;\r\nint err = 0;\r\nthread = machine__findnew_thread(&session->machines.host, 0, 0);\r\nif (thread == NULL || thread__set_comm(thread, "swapper", 0)) {\r\npr_err("problem inserting idle task.\n");\r\nerr = -1;\r\n}\r\nthread__put(thread);\r\nreturn err;\r\n}\r\nstatic void\r\nperf_session__warn_order(const struct perf_session *session)\r\n{\r\nconst struct ordered_events *oe = &session->ordered_events;\r\nstruct perf_evsel *evsel;\r\nbool should_warn = true;\r\nevlist__for_each_entry(session->evlist, evsel) {\r\nif (evsel->attr.write_backward)\r\nshould_warn = false;\r\n}\r\nif (!should_warn)\r\nreturn;\r\nif (oe->nr_unordered_events != 0)\r\nui__warning("%u out of order events recorded.\n", oe->nr_unordered_events);\r\n}\r\nstatic void perf_session__warn_about_errors(const struct perf_session *session)\r\n{\r\nconst struct events_stats *stats = &session->evlist->stats;\r\nif (session->tool->lost == perf_event__process_lost &&\r\nstats->nr_events[PERF_RECORD_LOST] != 0) {\r\nui__warning("Processed %d events and lost %d chunks!\n\n"\r\n"Check IO/CPU overload!\n\n",\r\nstats->nr_events[0],\r\nstats->nr_events[PERF_RECORD_LOST]);\r\n}\r\nif (session->tool->lost_samples == perf_event__process_lost_samples) {\r\ndouble drop_rate;\r\ndrop_rate = (double)stats->total_lost_samples /\r\n(double) (stats->nr_events[PERF_RECORD_SAMPLE] + stats->total_lost_samples);\r\nif (drop_rate > 0.05) {\r\nui__warning("Processed %" PRIu64 " samples and lost %3.2f%% samples!\n\n",\r\nstats->nr_events[PERF_RECORD_SAMPLE] + stats->total_lost_samples,\r\ndrop_rate * 100.0);\r\n}\r\n}\r\nif (session->tool->aux == perf_event__process_aux &&\r\nstats->total_aux_lost != 0) {\r\nui__warning("AUX data lost %" PRIu64 " times out of %u!\n\n",\r\nstats->total_aux_lost,\r\nstats->nr_events[PERF_RECORD_AUX]);\r\n}\r\nif (stats->nr_unknown_events != 0) {\r\nui__warning("Found %u unknown events!\n\n"\r\n"Is this an older tool processing a perf.data "\r\n"file generated by a more recent tool?\n\n"\r\n"If that is not the case, consider "\r\n"reporting to linux-kernel@vger.kernel.org.\n\n",\r\nstats->nr_unknown_events);\r\n}\r\nif (stats->nr_unknown_id != 0) {\r\nui__warning("%u samples with id not present in the header\n",\r\nstats->nr_unknown_id);\r\n}\r\nif (stats->nr_invalid_chains != 0) {\r\nui__warning("Found invalid callchains!\n\n"\r\n"%u out of %u events were discarded for this reason.\n\n"\r\n"Consider reporting to linux-kernel@vger.kernel.org.\n\n",\r\nstats->nr_invalid_chains,\r\nstats->nr_events[PERF_RECORD_SAMPLE]);\r\n}\r\nif (stats->nr_unprocessable_samples != 0) {\r\nui__warning("%u unprocessable samples recorded.\n"\r\n"Do you have a KVM guest running and not using 'perf kvm'?\n",\r\nstats->nr_unprocessable_samples);\r\n}\r\nperf_session__warn_order(session);\r\nevents_stats__auxtrace_error_warn(stats);\r\nif (stats->nr_proc_map_timeout != 0) {\r\nui__warning("%d map information files for pre-existing threads were\n"\r\n"not processed, if there are samples for addresses they\n"\r\n"will not be resolved, you may find out which are these\n"\r\n"threads by running with -v and redirecting the output\n"\r\n"to a file.\n"\r\n"The time limit to process proc map is too short?\n"\r\n"Increase it by --proc-map-timeout\n",\r\nstats->nr_proc_map_timeout);\r\n}\r\n}\r\nstatic int perf_session__flush_thread_stack(struct thread *thread,\r\nvoid *p __maybe_unused)\r\n{\r\nreturn thread_stack__flush(thread);\r\n}\r\nstatic int perf_session__flush_thread_stacks(struct perf_session *session)\r\n{\r\nreturn machines__for_each_thread(&session->machines,\r\nperf_session__flush_thread_stack,\r\nNULL);\r\n}\r\nstatic int __perf_session__process_pipe_events(struct perf_session *session)\r\n{\r\nstruct ordered_events *oe = &session->ordered_events;\r\nstruct perf_tool *tool = session->tool;\r\nint fd = perf_data_file__fd(session->file);\r\nunion perf_event *event;\r\nuint32_t size, cur_size = 0;\r\nvoid *buf = NULL;\r\ns64 skip = 0;\r\nu64 head;\r\nssize_t err;\r\nvoid *p;\r\nperf_tool__fill_defaults(tool);\r\nhead = 0;\r\ncur_size = sizeof(union perf_event);\r\nbuf = malloc(cur_size);\r\nif (!buf)\r\nreturn -errno;\r\nmore:\r\nevent = buf;\r\nerr = readn(fd, event, sizeof(struct perf_event_header));\r\nif (err <= 0) {\r\nif (err == 0)\r\ngoto done;\r\npr_err("failed to read event header\n");\r\ngoto out_err;\r\n}\r\nif (session->header.needs_swap)\r\nperf_event_header__bswap(&event->header);\r\nsize = event->header.size;\r\nif (size < sizeof(struct perf_event_header)) {\r\npr_err("bad event header size\n");\r\ngoto out_err;\r\n}\r\nif (size > cur_size) {\r\nvoid *new = realloc(buf, size);\r\nif (!new) {\r\npr_err("failed to allocate memory to read event\n");\r\ngoto out_err;\r\n}\r\nbuf = new;\r\ncur_size = size;\r\nevent = buf;\r\n}\r\np = event;\r\np += sizeof(struct perf_event_header);\r\nif (size - sizeof(struct perf_event_header)) {\r\nerr = readn(fd, p, size - sizeof(struct perf_event_header));\r\nif (err <= 0) {\r\nif (err == 0) {\r\npr_err("unexpected end of event stream\n");\r\ngoto done;\r\n}\r\npr_err("failed to read event data\n");\r\ngoto out_err;\r\n}\r\n}\r\nif ((skip = perf_session__process_event(session, event, head)) < 0) {\r\npr_err("%#" PRIx64 " [%#x]: failed to process type: %d\n",\r\nhead, event->header.size, event->header.type);\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nhead += size;\r\nif (skip > 0)\r\nhead += skip;\r\nif (!session_done())\r\ngoto more;\r\ndone:\r\nerr = ordered_events__flush(oe, OE_FLUSH__FINAL);\r\nif (err)\r\ngoto out_err;\r\nerr = auxtrace__flush_events(session, tool);\r\nif (err)\r\ngoto out_err;\r\nerr = perf_session__flush_thread_stacks(session);\r\nout_err:\r\nfree(buf);\r\nperf_session__warn_about_errors(session);\r\nordered_events__free(&session->ordered_events);\r\nauxtrace__free_events(session);\r\nreturn err;\r\n}\r\nstatic union perf_event *\r\nfetch_mmaped_event(struct perf_session *session,\r\nu64 head, size_t mmap_size, char *buf)\r\n{\r\nunion perf_event *event;\r\nif (head + sizeof(event->header) > mmap_size)\r\nreturn NULL;\r\nevent = (union perf_event *)(buf + head);\r\nif (session->header.needs_swap)\r\nperf_event_header__bswap(&event->header);\r\nif (head + event->header.size > mmap_size) {\r\nif (session->header.needs_swap)\r\nperf_event_header__bswap(&event->header);\r\nreturn NULL;\r\n}\r\nreturn event;\r\n}\r\nstatic int __perf_session__process_events(struct perf_session *session,\r\nu64 data_offset, u64 data_size,\r\nu64 file_size)\r\n{\r\nstruct ordered_events *oe = &session->ordered_events;\r\nstruct perf_tool *tool = session->tool;\r\nint fd = perf_data_file__fd(session->file);\r\nu64 head, page_offset, file_offset, file_pos, size;\r\nint err, mmap_prot, mmap_flags, map_idx = 0;\r\nsize_t mmap_size;\r\nchar *buf, *mmaps[NUM_MMAPS];\r\nunion perf_event *event;\r\nstruct ui_progress prog;\r\ns64 skip;\r\nperf_tool__fill_defaults(tool);\r\npage_offset = page_size * (data_offset / page_size);\r\nfile_offset = page_offset;\r\nhead = data_offset - page_offset;\r\nif (data_size == 0)\r\ngoto out;\r\nif (data_offset + data_size < file_size)\r\nfile_size = data_offset + data_size;\r\nui_progress__init(&prog, file_size, "Processing events...");\r\nmmap_size = MMAP_SIZE;\r\nif (mmap_size > file_size) {\r\nmmap_size = file_size;\r\nsession->one_mmap = true;\r\n}\r\nmemset(mmaps, 0, sizeof(mmaps));\r\nmmap_prot = PROT_READ;\r\nmmap_flags = MAP_SHARED;\r\nif (session->header.needs_swap) {\r\nmmap_prot |= PROT_WRITE;\r\nmmap_flags = MAP_PRIVATE;\r\n}\r\nremap:\r\nbuf = mmap(NULL, mmap_size, mmap_prot, mmap_flags, fd,\r\nfile_offset);\r\nif (buf == MAP_FAILED) {\r\npr_err("failed to mmap file\n");\r\nerr = -errno;\r\ngoto out_err;\r\n}\r\nmmaps[map_idx] = buf;\r\nmap_idx = (map_idx + 1) & (ARRAY_SIZE(mmaps) - 1);\r\nfile_pos = file_offset + head;\r\nif (session->one_mmap) {\r\nsession->one_mmap_addr = buf;\r\nsession->one_mmap_offset = file_offset;\r\n}\r\nmore:\r\nevent = fetch_mmaped_event(session, head, mmap_size, buf);\r\nif (!event) {\r\nif (mmaps[map_idx]) {\r\nmunmap(mmaps[map_idx], mmap_size);\r\nmmaps[map_idx] = NULL;\r\n}\r\npage_offset = page_size * (head / page_size);\r\nfile_offset += page_offset;\r\nhead -= page_offset;\r\ngoto remap;\r\n}\r\nsize = event->header.size;\r\nif (size < sizeof(struct perf_event_header) ||\r\n(skip = perf_session__process_event(session, event, file_pos)) < 0) {\r\npr_err("%#" PRIx64 " [%#x]: failed to process type: %d\n",\r\nfile_offset + head, event->header.size,\r\nevent->header.type);\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nif (skip)\r\nsize += skip;\r\nhead += size;\r\nfile_pos += size;\r\nui_progress__update(&prog, size);\r\nif (session_done())\r\ngoto out;\r\nif (file_pos < file_size)\r\ngoto more;\r\nout:\r\nerr = ordered_events__flush(oe, OE_FLUSH__FINAL);\r\nif (err)\r\ngoto out_err;\r\nerr = auxtrace__flush_events(session, tool);\r\nif (err)\r\ngoto out_err;\r\nerr = perf_session__flush_thread_stacks(session);\r\nout_err:\r\nui_progress__finish();\r\nperf_session__warn_about_errors(session);\r\nordered_events__reinit(&session->ordered_events);\r\nauxtrace__free_events(session);\r\nsession->one_mmap = false;\r\nreturn err;\r\n}\r\nint perf_session__process_events(struct perf_session *session)\r\n{\r\nu64 size = perf_data_file__size(session->file);\r\nint err;\r\nif (perf_session__register_idle_thread(session) < 0)\r\nreturn -ENOMEM;\r\nif (!perf_data_file__is_pipe(session->file))\r\nerr = __perf_session__process_events(session,\r\nsession->header.data_offset,\r\nsession->header.data_size, size);\r\nelse\r\nerr = __perf_session__process_pipe_events(session);\r\nreturn err;\r\n}\r\nbool perf_session__has_traces(struct perf_session *session, const char *msg)\r\n{\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(session->evlist, evsel) {\r\nif (evsel->attr.type == PERF_TYPE_TRACEPOINT)\r\nreturn true;\r\n}\r\npr_err("No trace sample to read. Did you call 'perf %s'?\n", msg);\r\nreturn false;\r\n}\r\nint maps__set_kallsyms_ref_reloc_sym(struct map **maps,\r\nconst char *symbol_name, u64 addr)\r\n{\r\nchar *bracket;\r\nenum map_type i;\r\nstruct ref_reloc_sym *ref;\r\nref = zalloc(sizeof(struct ref_reloc_sym));\r\nif (ref == NULL)\r\nreturn -ENOMEM;\r\nref->name = strdup(symbol_name);\r\nif (ref->name == NULL) {\r\nfree(ref);\r\nreturn -ENOMEM;\r\n}\r\nbracket = strchr(ref->name, ']');\r\nif (bracket)\r\n*bracket = '\0';\r\nref->addr = addr;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i) {\r\nstruct kmap *kmap = map__kmap(maps[i]);\r\nif (!kmap)\r\ncontinue;\r\nkmap->ref_reloc_sym = ref;\r\n}\r\nreturn 0;\r\n}\r\nsize_t perf_session__fprintf_dsos(struct perf_session *session, FILE *fp)\r\n{\r\nreturn machines__fprintf_dsos(&session->machines, fp);\r\n}\r\nsize_t perf_session__fprintf_dsos_buildid(struct perf_session *session, FILE *fp,\r\nbool (skip)(struct dso *dso, int parm), int parm)\r\n{\r\nreturn machines__fprintf_dsos_buildid(&session->machines, fp, skip, parm);\r\n}\r\nsize_t perf_session__fprintf_nr_events(struct perf_session *session, FILE *fp)\r\n{\r\nsize_t ret;\r\nconst char *msg = "";\r\nif (perf_header__has_feat(&session->header, HEADER_AUXTRACE))\r\nmsg = " (excludes AUX area (e.g. instruction trace) decoded / synthesized events)";\r\nret = fprintf(fp, "\nAggregated stats:%s\n", msg);\r\nret += events_stats__fprintf(&session->evlist->stats, fp);\r\nreturn ret;\r\n}\r\nsize_t perf_session__fprintf(struct perf_session *session, FILE *fp)\r\n{\r\nreturn machine__fprintf(&session->machines.host, fp);\r\n}\r\nstruct perf_evsel *perf_session__find_first_evtype(struct perf_session *session,\r\nunsigned int type)\r\n{\r\nstruct perf_evsel *pos;\r\nevlist__for_each_entry(session->evlist, pos) {\r\nif (pos->attr.type == type)\r\nreturn pos;\r\n}\r\nreturn NULL;\r\n}\r\nint perf_session__cpu_bitmap(struct perf_session *session,\r\nconst char *cpu_list, unsigned long *cpu_bitmap)\r\n{\r\nint i, err = -1;\r\nstruct cpu_map *map;\r\nfor (i = 0; i < PERF_TYPE_MAX; ++i) {\r\nstruct perf_evsel *evsel;\r\nevsel = perf_session__find_first_evtype(session, i);\r\nif (!evsel)\r\ncontinue;\r\nif (!(evsel->attr.sample_type & PERF_SAMPLE_CPU)) {\r\npr_err("File does not contain CPU events. "\r\n"Remove -c option to proceed.\n");\r\nreturn -1;\r\n}\r\n}\r\nmap = cpu_map__new(cpu_list);\r\nif (map == NULL) {\r\npr_err("Invalid cpu_list\n");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < map->nr; i++) {\r\nint cpu = map->map[i];\r\nif (cpu >= MAX_NR_CPUS) {\r\npr_err("Requested CPU %d too large. "\r\n"Consider raising MAX_NR_CPUS\n", cpu);\r\ngoto out_delete_map;\r\n}\r\nset_bit(cpu, cpu_bitmap);\r\n}\r\nerr = 0;\r\nout_delete_map:\r\ncpu_map__put(map);\r\nreturn err;\r\n}\r\nvoid perf_session__fprintf_info(struct perf_session *session, FILE *fp,\r\nbool full)\r\n{\r\nstruct stat st;\r\nint fd, ret;\r\nif (session == NULL || fp == NULL)\r\nreturn;\r\nfd = perf_data_file__fd(session->file);\r\nret = fstat(fd, &st);\r\nif (ret == -1)\r\nreturn;\r\nfprintf(fp, "# ========\n");\r\nfprintf(fp, "# captured on: %s", ctime(&st.st_ctime));\r\nperf_header__fprintf_info(session, fp, full);\r\nfprintf(fp, "# ========\n#\n");\r\n}\r\nint __perf_session__set_tracepoints_handlers(struct perf_session *session,\r\nconst struct perf_evsel_str_handler *assocs,\r\nsize_t nr_assocs)\r\n{\r\nstruct perf_evsel *evsel;\r\nsize_t i;\r\nint err;\r\nfor (i = 0; i < nr_assocs; i++) {\r\nevsel = perf_evlist__find_tracepoint_by_name(session->evlist, assocs[i].name);\r\nif (evsel == NULL)\r\ncontinue;\r\nerr = -EEXIST;\r\nif (evsel->handler != NULL)\r\ngoto out;\r\nevsel->handler = assocs[i].handler;\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nint perf_event__process_id_index(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nstruct perf_evlist *evlist = session->evlist;\r\nstruct id_index_event *ie = &event->id_index;\r\nsize_t i, nr, max_nr;\r\nmax_nr = (ie->header.size - sizeof(struct id_index_event)) /\r\nsizeof(struct id_index_entry);\r\nnr = ie->nr;\r\nif (nr > max_nr)\r\nreturn -EINVAL;\r\nif (dump_trace)\r\nfprintf(stdout, " nr: %zu\n", nr);\r\nfor (i = 0; i < nr; i++) {\r\nstruct id_index_entry *e = &ie->entries[i];\r\nstruct perf_sample_id *sid;\r\nif (dump_trace) {\r\nfprintf(stdout, " ... id: %"PRIu64, e->id);\r\nfprintf(stdout, " idx: %"PRIu64, e->idx);\r\nfprintf(stdout, " cpu: %"PRId64, e->cpu);\r\nfprintf(stdout, " tid: %"PRId64"\n", e->tid);\r\n}\r\nsid = perf_evlist__id2sid(evlist, e->id);\r\nif (!sid)\r\nreturn -ENOENT;\r\nsid->idx = e->idx;\r\nsid->cpu = e->cpu;\r\nsid->tid = e->tid;\r\n}\r\nreturn 0;\r\n}\r\nint perf_event__synthesize_id_index(struct perf_tool *tool,\r\nperf_event__handler_t process,\r\nstruct perf_evlist *evlist,\r\nstruct machine *machine)\r\n{\r\nunion perf_event *ev;\r\nstruct perf_evsel *evsel;\r\nsize_t nr = 0, i = 0, sz, max_nr, n;\r\nint err;\r\npr_debug2("Synthesizing id index\n");\r\nmax_nr = (UINT16_MAX - sizeof(struct id_index_event)) /\r\nsizeof(struct id_index_entry);\r\nevlist__for_each_entry(evlist, evsel)\r\nnr += evsel->ids;\r\nn = nr > max_nr ? max_nr : nr;\r\nsz = sizeof(struct id_index_event) + n * sizeof(struct id_index_entry);\r\nev = zalloc(sz);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->id_index.header.type = PERF_RECORD_ID_INDEX;\r\nev->id_index.header.size = sz;\r\nev->id_index.nr = n;\r\nevlist__for_each_entry(evlist, evsel) {\r\nu32 j;\r\nfor (j = 0; j < evsel->ids; j++) {\r\nstruct id_index_entry *e;\r\nstruct perf_sample_id *sid;\r\nif (i >= n) {\r\nerr = process(tool, ev, NULL, machine);\r\nif (err)\r\ngoto out_err;\r\nnr -= n;\r\ni = 0;\r\n}\r\ne = &ev->id_index.entries[i++];\r\ne->id = evsel->id[j];\r\nsid = perf_evlist__id2sid(evlist, e->id);\r\nif (!sid) {\r\nfree(ev);\r\nreturn -ENOENT;\r\n}\r\ne->idx = sid->idx;\r\ne->cpu = sid->cpu;\r\ne->tid = sid->tid;\r\n}\r\n}\r\nsz = sizeof(struct id_index_event) + nr * sizeof(struct id_index_entry);\r\nev->id_index.header.size = sz;\r\nev->id_index.nr = nr;\r\nerr = process(tool, ev, NULL, machine);\r\nout_err:\r\nfree(ev);\r\nreturn err;\r\n}
