static inline void\r\nahc_freeze_untagged_queues(struct ahc_softc *ahc)\r\n{\r\nif ((ahc->flags & AHC_SCB_BTT) == 0)\r\nahc->untagged_queue_lock++;\r\n}\r\nstatic inline void\r\nahc_release_untagged_queues(struct ahc_softc *ahc)\r\n{\r\nif ((ahc->flags & AHC_SCB_BTT) == 0) {\r\nahc->untagged_queue_lock--;\r\nif (ahc->untagged_queue_lock == 0)\r\nahc_run_untagged_queues(ahc);\r\n}\r\n}\r\nstatic void\r\nahc_pause_bug_fix(struct ahc_softc *ahc)\r\n{\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\n(void)ahc_inb(ahc, CCSCBCTL);\r\n}\r\nint\r\nahc_is_paused(struct ahc_softc *ahc)\r\n{\r\nreturn ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);\r\n}\r\nvoid\r\nahc_pause(struct ahc_softc *ahc)\r\n{\r\nahc_outb(ahc, HCNTRL, ahc->pause);\r\nwhile (ahc_is_paused(ahc) == 0)\r\n;\r\nahc_pause_bug_fix(ahc);\r\n}\r\nvoid\r\nahc_unpause(struct ahc_softc *ahc)\r\n{\r\nif ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)\r\nahc_outb(ahc, HCNTRL, ahc->unpause);\r\n}\r\nstatic struct ahc_dma_seg *\r\nahc_sg_bus_to_virt(struct scb *scb, uint32_t sg_busaddr)\r\n{\r\nint sg_index;\r\nsg_index = (sg_busaddr - scb->sg_list_phys)/sizeof(struct ahc_dma_seg);\r\nsg_index++;\r\nreturn (&scb->sg_list[sg_index]);\r\n}\r\nstatic uint32_t\r\nahc_sg_virt_to_bus(struct scb *scb, struct ahc_dma_seg *sg)\r\n{\r\nint sg_index;\r\nsg_index = sg - &scb->sg_list[1];\r\nreturn (scb->sg_list_phys + (sg_index * sizeof(*scb->sg_list)));\r\n}\r\nstatic uint32_t\r\nahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)\r\n{\r\nreturn (ahc->scb_data->hscb_busaddr\r\n+ (sizeof(struct hardware_scb) * index));\r\n}\r\nstatic void\r\nahc_sync_scb(struct ahc_softc *ahc, struct scb *scb, int op)\r\n{\r\nahc_dmamap_sync(ahc, ahc->scb_data->hscb_dmat,\r\nahc->scb_data->hscb_dmamap,\r\n(scb->hscb - ahc->hscbs) * sizeof(*scb->hscb),\r\nsizeof(*scb->hscb), op);\r\n}\r\nvoid\r\nahc_sync_sglist(struct ahc_softc *ahc, struct scb *scb, int op)\r\n{\r\nif (scb->sg_count == 0)\r\nreturn;\r\nahc_dmamap_sync(ahc, ahc->scb_data->sg_dmat, scb->sg_map->sg_dmamap,\r\n(scb->sg_list - scb->sg_map->sg_vaddr)\r\n* sizeof(struct ahc_dma_seg),\r\nsizeof(struct ahc_dma_seg) * scb->sg_count, op);\r\n}\r\nstatic uint32_t\r\nahc_targetcmd_offset(struct ahc_softc *ahc, u_int index)\r\n{\r\nreturn (((uint8_t *)&ahc->targetcmds[index]) - ahc->qoutfifo);\r\n}\r\nstatic void\r\nahc_update_residual(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nuint32_t sgptr;\r\nsgptr = ahc_le32toh(scb->hscb->sgptr);\r\nif ((sgptr & SG_RESID_VALID) != 0)\r\nahc_calc_residual(ahc, scb);\r\n}\r\nstruct ahc_initiator_tinfo *\r\nahc_fetch_transinfo(struct ahc_softc *ahc, char channel, u_int our_id,\r\nu_int remote_id, struct ahc_tmode_tstate **tstate)\r\n{\r\nif (channel == 'B')\r\nour_id += 8;\r\n*tstate = ahc->enabled_targets[our_id];\r\nreturn (&(*tstate)->transinfo[remote_id]);\r\n}\r\nuint16_t\r\nahc_inw(struct ahc_softc *ahc, u_int port)\r\n{\r\nuint16_t r = ahc_inb(ahc, port+1) << 8;\r\nreturn r | ahc_inb(ahc, port);\r\n}\r\nvoid\r\nahc_outw(struct ahc_softc *ahc, u_int port, u_int value)\r\n{\r\nahc_outb(ahc, port, value & 0xFF);\r\nahc_outb(ahc, port+1, (value >> 8) & 0xFF);\r\n}\r\nuint32_t\r\nahc_inl(struct ahc_softc *ahc, u_int port)\r\n{\r\nreturn ((ahc_inb(ahc, port))\r\n| (ahc_inb(ahc, port+1) << 8)\r\n| (ahc_inb(ahc, port+2) << 16)\r\n| (ahc_inb(ahc, port+3) << 24));\r\n}\r\nvoid\r\nahc_outl(struct ahc_softc *ahc, u_int port, uint32_t value)\r\n{\r\nahc_outb(ahc, port, (value) & 0xFF);\r\nahc_outb(ahc, port+1, ((value) >> 8) & 0xFF);\r\nahc_outb(ahc, port+2, ((value) >> 16) & 0xFF);\r\nahc_outb(ahc, port+3, ((value) >> 24) & 0xFF);\r\n}\r\nuint64_t\r\nahc_inq(struct ahc_softc *ahc, u_int port)\r\n{\r\nreturn ((ahc_inb(ahc, port))\r\n| (ahc_inb(ahc, port+1) << 8)\r\n| (ahc_inb(ahc, port+2) << 16)\r\n| (ahc_inb(ahc, port+3) << 24)\r\n| (((uint64_t)ahc_inb(ahc, port+4)) << 32)\r\n| (((uint64_t)ahc_inb(ahc, port+5)) << 40)\r\n| (((uint64_t)ahc_inb(ahc, port+6)) << 48)\r\n| (((uint64_t)ahc_inb(ahc, port+7)) << 56));\r\n}\r\nvoid\r\nahc_outq(struct ahc_softc *ahc, u_int port, uint64_t value)\r\n{\r\nahc_outb(ahc, port, value & 0xFF);\r\nahc_outb(ahc, port+1, (value >> 8) & 0xFF);\r\nahc_outb(ahc, port+2, (value >> 16) & 0xFF);\r\nahc_outb(ahc, port+3, (value >> 24) & 0xFF);\r\nahc_outb(ahc, port+4, (value >> 32) & 0xFF);\r\nahc_outb(ahc, port+5, (value >> 40) & 0xFF);\r\nahc_outb(ahc, port+6, (value >> 48) & 0xFF);\r\nahc_outb(ahc, port+7, (value >> 56) & 0xFF);\r\n}\r\nstruct scb *\r\nahc_get_scb(struct ahc_softc *ahc)\r\n{\r\nstruct scb *scb;\r\nif ((scb = SLIST_FIRST(&ahc->scb_data->free_scbs)) == NULL) {\r\nahc_alloc_scbs(ahc);\r\nscb = SLIST_FIRST(&ahc->scb_data->free_scbs);\r\nif (scb == NULL)\r\nreturn (NULL);\r\n}\r\nSLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links.sle);\r\nreturn (scb);\r\n}\r\nvoid\r\nahc_free_scb(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nstruct hardware_scb *hscb;\r\nhscb = scb->hscb;\r\nahc->scb_data->scbindex[hscb->tag] = NULL;\r\nscb->flags = SCB_FREE;\r\nhscb->control = 0;\r\nSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links.sle);\r\nahc_platform_scb_free(ahc, scb);\r\n}\r\nstruct scb *\r\nahc_lookup_scb(struct ahc_softc *ahc, u_int tag)\r\n{\r\nstruct scb* scb;\r\nscb = ahc->scb_data->scbindex[tag];\r\nif (scb != NULL)\r\nahc_sync_scb(ahc, scb,\r\nBUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);\r\nreturn (scb);\r\n}\r\nstatic void\r\nahc_swap_with_next_hscb(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nstruct hardware_scb *q_hscb;\r\nu_int saved_tag;\r\nq_hscb = ahc->next_queued_scb->hscb;\r\nsaved_tag = q_hscb->tag;\r\nmemcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));\r\nif ((scb->flags & SCB_CDB32_PTR) != 0) {\r\nq_hscb->shared_data.cdb_ptr =\r\nahc_htole32(ahc_hscb_busaddr(ahc, q_hscb->tag)\r\n+ offsetof(struct hardware_scb, cdb32));\r\n}\r\nq_hscb->tag = saved_tag;\r\nq_hscb->next = scb->hscb->tag;\r\nahc->next_queued_scb->hscb = scb->hscb;\r\nscb->hscb = q_hscb;\r\nahc->scb_data->scbindex[scb->hscb->tag] = scb;\r\n}\r\nvoid\r\nahc_queue_scb(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nahc_swap_with_next_hscb(ahc, scb);\r\nif (scb->hscb->tag == SCB_LIST_NULL\r\n|| scb->hscb->next == SCB_LIST_NULL)\r\npanic("Attempt to queue invalid SCB tag %x:%x\n",\r\nscb->hscb->tag, scb->hscb->next);\r\nscb->hscb->lun &= LID;\r\nif (ahc_get_transfer_length(scb) & 0x1)\r\nscb->hscb->lun |= SCB_XFERLEN_ODD;\r\nahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\r\nahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\r\nif ((ahc->features & AHC_QUEUE_REGS) != 0) {\r\nahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\r\n} else {\r\nif ((ahc->features & AHC_AUTOPAUSE) == 0)\r\nahc_pause(ahc);\r\nahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\r\nif ((ahc->features & AHC_AUTOPAUSE) == 0)\r\nahc_unpause(ahc);\r\n}\r\n}\r\nstruct scsi_sense_data *\r\nahc_get_sense_buf(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nint offset;\r\noffset = scb - ahc->scb_data->scbarray;\r\nreturn (&ahc->scb_data->sense[offset]);\r\n}\r\nstatic uint32_t\r\nahc_get_sense_bufaddr(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nint offset;\r\noffset = scb - ahc->scb_data->scbarray;\r\nreturn (ahc->scb_data->sense_busaddr\r\n+ (offset * sizeof(struct scsi_sense_data)));\r\n}\r\nstatic void\r\nahc_sync_qoutfifo(struct ahc_softc *ahc, int op)\r\n{\r\nahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,\r\n0, 256, op);\r\n}\r\nstatic void\r\nahc_sync_tqinfifo(struct ahc_softc *ahc, int op)\r\n{\r\n#ifdef AHC_TARGET_MODE\r\nif ((ahc->flags & AHC_TARGETROLE) != 0) {\r\nahc_dmamap_sync(ahc, ahc->shared_data_dmat,\r\nahc->shared_data_dmamap,\r\nahc_targetcmd_offset(ahc, 0),\r\nsizeof(struct target_cmd) * AHC_TMODE_CMDS,\r\nop);\r\n}\r\n#endif\r\n}\r\nstatic u_int\r\nahc_check_cmdcmpltqueues(struct ahc_softc *ahc)\r\n{\r\nu_int retval;\r\nretval = 0;\r\nahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,\r\nahc->qoutfifonext, 1,\r\nBUS_DMASYNC_POSTREAD);\r\nif (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL)\r\nretval |= AHC_RUN_QOUTFIFO;\r\n#ifdef AHC_TARGET_MODE\r\nif ((ahc->flags & AHC_TARGETROLE) != 0\r\n&& (ahc->flags & AHC_TQINFIFO_BLOCKED) == 0) {\r\nahc_dmamap_sync(ahc, ahc->shared_data_dmat,\r\nahc->shared_data_dmamap,\r\nahc_targetcmd_offset(ahc, ahc->tqinfifofnext),\r\nsizeof(struct target_cmd),\r\nBUS_DMASYNC_POSTREAD);\r\nif (ahc->targetcmds[ahc->tqinfifonext].cmd_valid != 0)\r\nretval |= AHC_RUN_TQINFIFO;\r\n}\r\n#endif\r\nreturn (retval);\r\n}\r\nint\r\nahc_intr(struct ahc_softc *ahc)\r\n{\r\nu_int intstat;\r\nif ((ahc->pause & INTEN) == 0) {\r\nreturn (0);\r\n}\r\nif ((ahc->flags & (AHC_ALL_INTERRUPTS|AHC_EDGE_INTERRUPT)) == 0\r\n&& (ahc_check_cmdcmpltqueues(ahc) != 0))\r\nintstat = CMDCMPLT;\r\nelse {\r\nintstat = ahc_inb(ahc, INTSTAT);\r\n}\r\nif ((intstat & INT_PEND) == 0) {\r\n#if AHC_PCI_CONFIG > 0\r\nif (ahc->unsolicited_ints > 500) {\r\nahc->unsolicited_ints = 0;\r\nif ((ahc->chip & AHC_PCI) != 0\r\n&& (ahc_inb(ahc, ERROR) & PCIERRSTAT) != 0)\r\nahc->bus_intr(ahc);\r\n}\r\n#endif\r\nahc->unsolicited_ints++;\r\nreturn (0);\r\n}\r\nahc->unsolicited_ints = 0;\r\nif (intstat & CMDCMPLT) {\r\nahc_outb(ahc, CLRINT, CLRCMDINT);\r\nahc_flush_device_writes(ahc);\r\nahc_run_qoutfifo(ahc);\r\n#ifdef AHC_TARGET_MODE\r\nif ((ahc->flags & AHC_TARGETROLE) != 0)\r\nahc_run_tqinfifo(ahc, FALSE);\r\n#endif\r\n}\r\nif (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0) {\r\n} else if (intstat & BRKADRINT) {\r\nahc_handle_brkadrint(ahc);\r\n} else if ((intstat & (SEQINT|SCSIINT)) != 0) {\r\nahc_pause_bug_fix(ahc);\r\nif ((intstat & SEQINT) != 0)\r\nahc_handle_seqint(ahc, intstat);\r\nif ((intstat & SCSIINT) != 0)\r\nahc_handle_scsiint(ahc, intstat);\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nahc_restart(struct ahc_softc *ahc)\r\n{\r\nuint8_t sblkctl;\r\nahc_pause(ahc);\r\nahc_clear_msg_state(ahc);\r\nahc_outb(ahc, SCSISIGO, 0);\r\nahc_outb(ahc, MSG_OUT, MSG_NOOP);\r\nahc_outb(ahc, SXFRCTL1, ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);\r\nahc_outb(ahc, LASTPHASE, P_BUSFREE);\r\nahc_outb(ahc, SAVED_SCSIID, 0xFF);\r\nahc_outb(ahc, SAVED_LUN, 0xFF);\r\nahc_outb(ahc, TQINPOS, ahc->tqinfifonext);\r\nahc_outb(ahc, SCSISEQ,\r\nahc_inb(ahc, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));\r\nif ((ahc->features & AHC_CMD_CHAN) != 0) {\r\nahc_outb(ahc, CCSCBCNT, 0);\r\nahc_outb(ahc, CCSGCTL, 0);\r\nahc_outb(ahc, CCSCBCTL, 0);\r\n}\r\nif ((ahc_inb(ahc, SEQ_FLAGS2) & SCB_DMA) != 0) {\r\nahc_add_curscb_to_free_list(ahc);\r\nahc_outb(ahc, SEQ_FLAGS2,\r\nahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);\r\n}\r\nahc_outb(ahc, CLRINT, CLRSEQINT);\r\nahc_outb(ahc, MWI_RESIDUAL, 0);\r\nahc_outb(ahc, SEQCTL, ahc->seqctl);\r\nahc_outb(ahc, SEQADDR0, 0);\r\nahc_outb(ahc, SEQADDR1, 0);\r\nsblkctl = ahc_inb(ahc, SBLKCTL);\r\nahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));\r\nahc_unpause(ahc);\r\n}\r\nstatic void\r\nahc_run_qoutfifo(struct ahc_softc *ahc)\r\n{\r\nstruct scb *scb;\r\nu_int scb_index;\r\nahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);\r\nwhile (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {\r\nscb_index = ahc->qoutfifo[ahc->qoutfifonext];\r\nif ((ahc->qoutfifonext & 0x03) == 0x03) {\r\nu_int modnext;\r\nmodnext = ahc->qoutfifonext & ~0x3;\r\n*((uint32_t *)(&ahc->qoutfifo[modnext])) = 0xFFFFFFFFUL;\r\nahc_dmamap_sync(ahc, ahc->shared_data_dmat,\r\nahc->shared_data_dmamap,\r\nmodnext, 4,\r\nBUS_DMASYNC_PREREAD);\r\n}\r\nahc->qoutfifonext++;\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nif (scb == NULL) {\r\nprintk("%s: WARNING no command for scb %d "\r\n"(cmdcmplt)\nQOUTPOS = %d\n",\r\nahc_name(ahc), scb_index,\r\n(ahc->qoutfifonext - 1) & 0xFF);\r\ncontinue;\r\n}\r\nahc_update_residual(ahc, scb);\r\nahc_done(ahc, scb);\r\n}\r\n}\r\nstatic void\r\nahc_run_untagged_queues(struct ahc_softc *ahc)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nahc_run_untagged_queue(ahc, &ahc->untagged_queues[i]);\r\n}\r\nstatic void\r\nahc_run_untagged_queue(struct ahc_softc *ahc, struct scb_tailq *queue)\r\n{\r\nstruct scb *scb;\r\nif (ahc->untagged_queue_lock != 0)\r\nreturn;\r\nif ((scb = TAILQ_FIRST(queue)) != NULL\r\n&& (scb->flags & SCB_ACTIVE) == 0) {\r\nscb->flags |= SCB_ACTIVE;\r\nahc_queue_scb(ahc, scb);\r\n}\r\n}\r\nstatic void\r\nahc_handle_brkadrint(struct ahc_softc *ahc)\r\n{\r\nint i;\r\nint error;\r\nerror = ahc_inb(ahc, ERROR);\r\nfor (i = 0; error != 1 && i < num_errors; i++)\r\nerror >>= 1;\r\nprintk("%s: brkadrint, %s at seqaddr = 0x%x\n",\r\nahc_name(ahc), ahc_hard_errors[i].errmesg,\r\nahc_inb(ahc, SEQADDR0) |\r\n(ahc_inb(ahc, SEQADDR1) << 8));\r\nahc_dump_card_state(ahc);\r\nahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,\r\nCAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,\r\nCAM_NO_HBA);\r\nahc_shutdown(ahc);\r\n}\r\nstatic void\r\nahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)\r\n{\r\nstruct scb *scb;\r\nstruct ahc_devinfo devinfo;\r\nahc_fetch_devinfo(ahc, &devinfo);\r\nahc_outb(ahc, CLRINT, CLRSEQINT);\r\nswitch (intstat & SEQINT_MASK) {\r\ncase BAD_STATUS:\r\n{\r\nu_int scb_index;\r\nstruct hardware_scb *hscb;\r\nahc_outb(ahc, RETURN_1, 0);\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nif (scb == NULL) {\r\nahc_print_devinfo(ahc, &devinfo);\r\nprintk("ahc_intr - referenced scb "\r\n"not valid during seqint 0x%x scb(%d)\n",\r\nintstat, scb_index);\r\nahc_dump_card_state(ahc);\r\npanic("for safety");\r\ngoto unpause;\r\n}\r\nhscb = scb->hscb;\r\nif ((scb->flags & SCB_SENSE) != 0) {\r\nscb->flags &= ~SCB_SENSE;\r\nahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);\r\nbreak;\r\n}\r\nahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);\r\nahc_freeze_devq(ahc, scb);\r\nahc_freeze_scb(scb);\r\nahc_set_scsi_status(scb, hscb->shared_data.status.scsi_status);\r\nswitch (hscb->shared_data.status.scsi_status) {\r\ncase SCSI_STATUS_OK:\r\nprintk("%s: Interrupted for status of 0???\n",\r\nahc_name(ahc));\r\nbreak;\r\ncase SCSI_STATUS_CMD_TERMINATED:\r\ncase SCSI_STATUS_CHECK_COND:\r\n{\r\nstruct ahc_dma_seg *sg;\r\nstruct scsi_sense *sc;\r\nstruct ahc_initiator_tinfo *targ_info;\r\nstruct ahc_tmode_tstate *tstate;\r\nstruct ahc_transinfo *tinfo;\r\n#ifdef AHC_DEBUG\r\nif (ahc_debug & AHC_SHOW_SENSE) {\r\nahc_print_path(ahc, scb);\r\nprintk("SCB %d: requests Check Status\n",\r\nscb->hscb->tag);\r\n}\r\n#endif\r\nif (ahc_perform_autosense(scb) == 0)\r\nbreak;\r\ntarg_info = ahc_fetch_transinfo(ahc,\r\ndevinfo.channel,\r\ndevinfo.our_scsiid,\r\ndevinfo.target,\r\n&tstate);\r\ntinfo = &targ_info->curr;\r\nsg = scb->sg_list;\r\nsc = (struct scsi_sense *)(&hscb->shared_data.cdb);\r\nahc_update_residual(ahc, scb);\r\n#ifdef AHC_DEBUG\r\nif (ahc_debug & AHC_SHOW_SENSE) {\r\nahc_print_path(ahc, scb);\r\nprintk("Sending Sense\n");\r\n}\r\n#endif\r\nsg->addr = ahc_get_sense_bufaddr(ahc, scb);\r\nsg->len = ahc_get_sense_bufsize(ahc, scb);\r\nsg->len |= AHC_DMA_LAST_SEG;\r\nsg->addr = ahc_htole32(sg->addr);\r\nsg->len = ahc_htole32(sg->len);\r\nsc->opcode = REQUEST_SENSE;\r\nsc->byte2 = 0;\r\nif (tinfo->protocol_version <= SCSI_REV_2\r\n&& SCB_GET_LUN(scb) < 8)\r\nsc->byte2 = SCB_GET_LUN(scb) << 5;\r\nsc->unused[0] = 0;\r\nsc->unused[1] = 0;\r\nsc->length = sg->len;\r\nsc->control = 0;\r\nhscb->control = 0;\r\nif (ahc_get_residual(scb)\r\n== ahc_get_transfer_length(scb)) {\r\nahc_update_neg_request(ahc, &devinfo,\r\ntstate, targ_info,\r\nAHC_NEG_IF_NON_ASYNC);\r\n}\r\nif (tstate->auto_negotiate & devinfo.target_mask) {\r\nhscb->control |= MK_MESSAGE;\r\nscb->flags &= ~SCB_NEGOTIATE;\r\nscb->flags |= SCB_AUTO_NEGOTIATE;\r\n}\r\nhscb->cdb_len = sizeof(*sc);\r\nhscb->dataptr = sg->addr;\r\nhscb->datacnt = sg->len;\r\nhscb->sgptr = scb->sg_list_phys | SG_FULL_RESID;\r\nhscb->sgptr = ahc_htole32(hscb->sgptr);\r\nscb->sg_count = 1;\r\nscb->flags |= SCB_SENSE;\r\nahc_qinfifo_requeue_tail(ahc, scb);\r\nahc_outb(ahc, RETURN_1, SEND_SENSE);\r\nahc_scb_timer_reset(scb, 5 * 1000000);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase NO_MATCH:\r\n{\r\nahc_outb(ahc, SCSISEQ,\r\nahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\r\nprintk("%s:%c:%d: no active SCB for reconnecting "\r\n"target - issuing BUS DEVICE RESET\n",\r\nahc_name(ahc), devinfo.channel, devinfo.target);\r\nprintk("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "\r\n"ARG_1 == 0x%x ACCUM = 0x%x\n",\r\nahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),\r\nahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));\r\nprintk("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "\r\n"SINDEX == 0x%x\n",\r\nahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),\r\nahc_index_busy_tcl(ahc,\r\nBUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),\r\nahc_inb(ahc, SAVED_LUN))),\r\nahc_inb(ahc, SINDEX));\r\nprintk("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "\r\n"SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",\r\nahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),\r\nahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),\r\nahc_inb(ahc, SCB_CONTROL));\r\nprintk("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",\r\nahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));\r\nprintk("SXFRCTL0 == 0x%x\n", ahc_inb(ahc, SXFRCTL0));\r\nprintk("SEQCTL == 0x%x\n", ahc_inb(ahc, SEQCTL));\r\nahc_dump_card_state(ahc);\r\nahc->msgout_buf[0] = MSG_BUS_DEV_RESET;\r\nahc->msgout_len = 1;\r\nahc->msgout_index = 0;\r\nahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\nahc_outb(ahc, MSG_OUT, HOST_MSG);\r\nahc_assert_atn(ahc);\r\nbreak;\r\n}\r\ncase SEND_REJECT:\r\n{\r\nu_int rejbyte = ahc_inb(ahc, ACCUM);\r\nprintk("%s:%c:%d: Warning - unknown message received from "\r\n"target (0x%x). Rejecting\n",\r\nahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);\r\nbreak;\r\n}\r\ncase PROTO_VIOLATION:\r\n{\r\nahc_handle_proto_violation(ahc);\r\nbreak;\r\n}\r\ncase IGN_WIDE_RES:\r\nahc_handle_ign_wide_residue(ahc, &devinfo);\r\nbreak;\r\ncase PDATA_REINIT:\r\nahc_reinitialize_dataptrs(ahc);\r\nbreak;\r\ncase BAD_PHASE:\r\n{\r\nu_int lastphase;\r\nlastphase = ahc_inb(ahc, LASTPHASE);\r\nprintk("%s:%c:%d: unknown scsi bus phase %x, "\r\n"lastphase = 0x%x. Attempting to continue\n",\r\nahc_name(ahc), devinfo.channel, devinfo.target,\r\nlastphase, ahc_inb(ahc, SCSISIGI));\r\nbreak;\r\n}\r\ncase MISSED_BUSFREE:\r\n{\r\nu_int lastphase;\r\nlastphase = ahc_inb(ahc, LASTPHASE);\r\nprintk("%s:%c:%d: Missed busfree. "\r\n"Lastphase = 0x%x, Curphase = 0x%x\n",\r\nahc_name(ahc), devinfo.channel, devinfo.target,\r\nlastphase, ahc_inb(ahc, SCSISIGI));\r\nahc_restart(ahc);\r\nreturn;\r\n}\r\ncase HOST_MSG_LOOP:\r\n{\r\nif (ahc->msg_type == MSG_TYPE_NONE) {\r\nstruct scb *scb;\r\nu_int scb_index;\r\nu_int bus_phase;\r\nbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\r\nif (bus_phase != P_MESGIN\r\n&& bus_phase != P_MESGOUT) {\r\nprintk("ahc_intr: HOST_MSG_LOOP bad "\r\n"phase 0x%x\n",\r\nbus_phase);\r\nahc_clear_intstat(ahc);\r\nahc_restart(ahc);\r\nreturn;\r\n}\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nif (devinfo.role == ROLE_INITIATOR) {\r\nif (bus_phase == P_MESGOUT) {\r\nif (scb == NULL)\r\npanic("HOST_MSG_LOOP with "\r\n"invalid SCB %x\n",\r\nscb_index);\r\nahc_setup_initiator_msgout(ahc,\r\n&devinfo,\r\nscb);\r\n} else {\r\nahc->msg_type =\r\nMSG_TYPE_INITIATOR_MSGIN;\r\nahc->msgin_index = 0;\r\n}\r\n}\r\n#ifdef AHC_TARGET_MODE\r\nelse {\r\nif (bus_phase == P_MESGOUT) {\r\nahc->msg_type =\r\nMSG_TYPE_TARGET_MSGOUT;\r\nahc->msgin_index = 0;\r\n}\r\nelse\r\nahc_setup_target_msgin(ahc,\r\n&devinfo,\r\nscb);\r\n}\r\n#endif\r\n}\r\nahc_handle_message_phase(ahc);\r\nbreak;\r\n}\r\ncase PERR_DETECTED:\r\n{\r\nif ((intstat & SCSIINT) == 0\r\n&& (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {\r\nif ((ahc->features & AHC_DT) == 0) {\r\nu_int curphase;\r\ncurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\r\nahc_outb(ahc, LASTPHASE, curphase);\r\nahc_outb(ahc, SCSISIGO, curphase);\r\n}\r\nif ((ahc_inb(ahc, SCSISIGI) & (CDI|MSGI)) == 0) {\r\nint wait;\r\nahc_outb(ahc, SXFRCTL1,\r\nahc_inb(ahc, SXFRCTL1) | BITBUCKET);\r\nwait = 5000;\r\nwhile (--wait != 0) {\r\nif ((ahc_inb(ahc, SCSISIGI)\r\n& (CDI|MSGI)) != 0)\r\nbreak;\r\nahc_delay(100);\r\n}\r\nahc_outb(ahc, SXFRCTL1,\r\nahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);\r\nif (wait == 0) {\r\nstruct scb *scb;\r\nu_int scb_index;\r\nahc_print_devinfo(ahc, &devinfo);\r\nprintk("Unable to clear parity error. "\r\n"Resetting bus.\n");\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nif (scb != NULL)\r\nahc_set_transaction_status(scb,\r\nCAM_UNCOR_PARITY);\r\nahc_reset_channel(ahc, devinfo.channel,\r\nTRUE);\r\n}\r\n} else {\r\nahc_inb(ahc, SCSIDATL);\r\n}\r\n}\r\nbreak;\r\n}\r\ncase DATA_OVERRUN:\r\n{\r\nu_int scbindex = ahc_inb(ahc, SCB_TAG);\r\nu_int lastphase = ahc_inb(ahc, LASTPHASE);\r\nu_int i;\r\nscb = ahc_lookup_scb(ahc, scbindex);\r\nfor (i = 0; i < num_phases; i++) {\r\nif (lastphase == ahc_phase_table[i].phase)\r\nbreak;\r\n}\r\nahc_print_path(ahc, scb);\r\nprintk("data overrun detected %s."\r\n" Tag == 0x%x.\n",\r\nahc_phase_table[i].phasemsg,\r\nscb->hscb->tag);\r\nahc_print_path(ahc, scb);\r\nprintk("%s seen Data Phase. Length = %ld. NumSGs = %d.\n",\r\nahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",\r\nahc_get_transfer_length(scb), scb->sg_count);\r\nif (scb->sg_count > 0) {\r\nfor (i = 0; i < scb->sg_count; i++) {\r\nprintk("sg[%d] - Addr 0x%x%x : Length %d\n",\r\ni,\r\n(ahc_le32toh(scb->sg_list[i].len) >> 24\r\n& SG_HIGH_ADDR_BITS),\r\nahc_le32toh(scb->sg_list[i].addr),\r\nahc_le32toh(scb->sg_list[i].len)\r\n& AHC_SG_LEN_MASK);\r\n}\r\n}\r\nahc_freeze_devq(ahc, scb);\r\nif ((scb->flags & SCB_SENSE) == 0) {\r\nahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);\r\n} else {\r\nscb->flags &= ~SCB_SENSE;\r\nahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);\r\n}\r\nahc_freeze_scb(scb);\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nahc_outb(ahc, SXFRCTL0,\r\nahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);\r\nahc_outb(ahc, SXFRCTL0,\r\nahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);\r\n}\r\nif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\r\nu_int dscommand1;\r\ndscommand1 = ahc_inb(ahc, DSCOMMAND1);\r\nahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);\r\nahc_outb(ahc, HADDR, 0);\r\nahc_outb(ahc, DSCOMMAND1, dscommand1);\r\n}\r\nbreak;\r\n}\r\ncase MKMSG_FAILED:\r\n{\r\nu_int scbindex;\r\nprintk("%s:%c:%d:%d: Attempt to issue message failed\n",\r\nahc_name(ahc), devinfo.channel, devinfo.target,\r\ndevinfo.lun);\r\nscbindex = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scbindex);\r\nif (scb != NULL\r\n&& (scb->flags & SCB_RECOVERY_SCB) != 0)\r\nahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),\r\nSCB_GET_CHANNEL(ahc, scb),\r\nSCB_GET_LUN(scb), scb->hscb->tag,\r\nROLE_INITIATOR, 0,\r\nSEARCH_REMOVE);\r\nbreak;\r\n}\r\ncase NO_FREE_SCB:\r\n{\r\nprintk("%s: No free or disconnected SCBs\n", ahc_name(ahc));\r\nahc_dump_card_state(ahc);\r\npanic("for safety");\r\nbreak;\r\n}\r\ncase SCB_MISMATCH:\r\n{\r\nu_int scbptr;\r\nscbptr = ahc_inb(ahc, SCBPTR);\r\nprintk("Bogus TAG after DMA. SCBPTR %d, tag %d, our tag %d\n",\r\nscbptr, ahc_inb(ahc, ARG_1),\r\nahc->scb_data->hscbs[scbptr].tag);\r\nahc_dump_card_state(ahc);\r\npanic("for safety");\r\nbreak;\r\n}\r\ncase OUT_OF_RANGE:\r\n{\r\nprintk("%s: BTT calculation out of range\n", ahc_name(ahc));\r\nprintk("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "\r\n"ARG_1 == 0x%x ACCUM = 0x%x\n",\r\nahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),\r\nahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));\r\nprintk("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "\r\n"SINDEX == 0x%x\n, A == 0x%x\n",\r\nahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),\r\nahc_index_busy_tcl(ahc,\r\nBUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),\r\nahc_inb(ahc, SAVED_LUN))),\r\nahc_inb(ahc, SINDEX),\r\nahc_inb(ahc, ACCUM));\r\nprintk("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "\r\n"SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",\r\nahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),\r\nahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),\r\nahc_inb(ahc, SCB_CONTROL));\r\nprintk("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",\r\nahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));\r\nahc_dump_card_state(ahc);\r\npanic("for safety");\r\nbreak;\r\n}\r\ndefault:\r\nprintk("ahc_intr: seqint, "\r\n"intstat == 0x%x, scsisigi = 0x%x\n",\r\nintstat, ahc_inb(ahc, SCSISIGI));\r\nbreak;\r\n}\r\nunpause:\r\nahc_unpause(ahc);\r\n}\r\nstatic void\r\nahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)\r\n{\r\nu_int scb_index;\r\nu_int status0;\r\nu_int status;\r\nstruct scb *scb;\r\nchar cur_channel;\r\nchar intr_channel;\r\nif ((ahc->features & AHC_TWIN) != 0\r\n&& ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))\r\ncur_channel = 'B';\r\nelse\r\ncur_channel = 'A';\r\nintr_channel = cur_channel;\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nstatus0 = ahc_inb(ahc, SSTAT0) & IOERR;\r\nelse\r\nstatus0 = 0;\r\nstatus = ahc_inb(ahc, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);\r\nif (status == 0 && status0 == 0) {\r\nif ((ahc->features & AHC_TWIN) != 0) {\r\nahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\r\nstatus = ahc_inb(ahc, SSTAT1)\r\n& (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);\r\nintr_channel = (cur_channel == 'A') ? 'B' : 'A';\r\n}\r\nif (status == 0) {\r\nprintk("%s: Spurious SCSI interrupt\n", ahc_name(ahc));\r\nahc_outb(ahc, CLRINT, CLRSCSIINT);\r\nahc_unpause(ahc);\r\nreturn;\r\n}\r\n}\r\nahc_clear_critical_section(ahc);\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nif (scb != NULL\r\n&& (ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)\r\nscb = NULL;\r\nif ((ahc->features & AHC_ULTRA2) != 0\r\n&& (status0 & IOERR) != 0) {\r\nint now_lvd;\r\nnow_lvd = ahc_inb(ahc, SBLKCTL) & ENAB40;\r\nprintk("%s: Transceiver State Has Changed to %s mode\n",\r\nahc_name(ahc), now_lvd ? "LVD" : "SE");\r\nahc_outb(ahc, CLRSINT0, CLRIOERR);\r\nahc_reset_channel(ahc, intr_channel,\r\nnow_lvd == 0);\r\n} else if ((status & SCSIRSTI) != 0) {\r\nprintk("%s: Someone reset channel %c\n",\r\nahc_name(ahc), intr_channel);\r\nif (intr_channel != cur_channel)\r\nahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);\r\nahc_reset_channel(ahc, intr_channel, FALSE);\r\n} else if ((status & SCSIPERR) != 0) {\r\nstruct ahc_devinfo devinfo;\r\nu_int mesg_out;\r\nu_int curphase;\r\nu_int errorphase;\r\nu_int lastphase;\r\nu_int scsirate;\r\nu_int i;\r\nu_int sstat2;\r\nint silent;\r\nlastphase = ahc_inb(ahc, LASTPHASE);\r\ncurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\r\nsstat2 = ahc_inb(ahc, SSTAT2);\r\nahc_outb(ahc, CLRSINT1, CLRSCSIPERR);\r\nif ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0\r\n|| curphase == P_DATAIN || curphase == P_DATAIN_DT)\r\nerrorphase = curphase;\r\nelse\r\nerrorphase = lastphase;\r\nfor (i = 0; i < num_phases; i++) {\r\nif (errorphase == ahc_phase_table[i].phase)\r\nbreak;\r\n}\r\nmesg_out = ahc_phase_table[i].mesg_out;\r\nsilent = FALSE;\r\nif (scb != NULL) {\r\nif (SCB_IS_SILENT(scb))\r\nsilent = TRUE;\r\nelse\r\nahc_print_path(ahc, scb);\r\nscb->flags |= SCB_TRANSMISSION_ERROR;\r\n} else\r\nprintk("%s:%c:%d: ", ahc_name(ahc), intr_channel,\r\nSCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)));\r\nscsirate = ahc_inb(ahc, SCSIRATE);\r\nif (silent == FALSE) {\r\nprintk("parity error detected %s. "\r\n"SEQADDR(0x%x) SCSIRATE(0x%x)\n",\r\nahc_phase_table[i].phasemsg,\r\nahc_inw(ahc, SEQADDR0),\r\nscsirate);\r\nif ((ahc->features & AHC_DT) != 0) {\r\nif ((sstat2 & CRCVALERR) != 0)\r\nprintk("\tCRC Value Mismatch\n");\r\nif ((sstat2 & CRCENDERR) != 0)\r\nprintk("\tNo terminal CRC packet "\r\n"recevied\n");\r\nif ((sstat2 & CRCREQERR) != 0)\r\nprintk("\tIllegal CRC packet "\r\n"request\n");\r\nif ((sstat2 & DUAL_EDGE_ERR) != 0)\r\nprintk("\tUnexpected %sDT Data Phase\n",\r\n(scsirate & SINGLE_EDGE)\r\n? "" : "non-");\r\n}\r\n}\r\nif ((ahc->features & AHC_DT) != 0\r\n&& (sstat2 & DUAL_EDGE_ERR) != 0) {\r\nmesg_out = MSG_INITIATOR_DET_ERR;\r\n}\r\nif (mesg_out != MSG_NOOP) {\r\nif (ahc->msg_type != MSG_TYPE_NONE)\r\nahc->send_msg_perror = TRUE;\r\nelse\r\nahc_outb(ahc, MSG_OUT, mesg_out);\r\n}\r\nahc_fetch_devinfo(ahc, &devinfo);\r\nahc_force_renegotiation(ahc, &devinfo);\r\nahc_outb(ahc, CLRINT, CLRSCSIINT);\r\nahc_unpause(ahc);\r\n} else if ((status & SELTO) != 0) {\r\nu_int scbptr;\r\nahc_outb(ahc, SCSISEQ, 0);\r\nahc_clear_msg_state(ahc);\r\nahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\r\nahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);\r\nahc_outb(ahc, CLRSINT0, CLRSELINGO);\r\nscbptr = ahc_inb(ahc, WAITING_SCBH);\r\nahc_outb(ahc, SCBPTR, scbptr);\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nif (scb == NULL) {\r\nprintk("%s: ahc_intr - referenced scb not "\r\n"valid during SELTO scb(%d, %d)\n",\r\nahc_name(ahc), scbptr, scb_index);\r\nahc_dump_card_state(ahc);\r\n} else {\r\nstruct ahc_devinfo devinfo;\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_SELTO) != 0) {\r\nahc_print_path(ahc, scb);\r\nprintk("Saw Selection Timeout for SCB 0x%x\n",\r\nscb_index);\r\n}\r\n#endif\r\nahc_scb_devinfo(ahc, &devinfo, scb);\r\nahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);\r\nahc_freeze_devq(ahc, scb);\r\nahc_handle_devreset(ahc, &devinfo,\r\nCAM_SEL_TIMEOUT,\r\n"Selection Timeout",\r\n1);\r\n}\r\nahc_outb(ahc, CLRINT, CLRSCSIINT);\r\nahc_restart(ahc);\r\n} else if ((status & BUSFREE) != 0\r\n&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {\r\nstruct ahc_devinfo devinfo;\r\nu_int lastphase;\r\nu_int saved_scsiid;\r\nu_int saved_lun;\r\nu_int target;\r\nu_int initiator_role_id;\r\nchar channel;\r\nint printerror;\r\nahc_outb(ahc, SCSISEQ,\r\nahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));\r\nahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);\r\nahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);\r\nlastphase = ahc_inb(ahc, LASTPHASE);\r\nsaved_scsiid = ahc_inb(ahc, SAVED_SCSIID);\r\nsaved_lun = ahc_inb(ahc, SAVED_LUN);\r\ntarget = SCSIID_TARGET(ahc, saved_scsiid);\r\ninitiator_role_id = SCSIID_OUR_ID(saved_scsiid);\r\nchannel = SCSIID_CHANNEL(ahc, saved_scsiid);\r\nahc_compile_devinfo(&devinfo, initiator_role_id,\r\ntarget, saved_lun, channel, ROLE_INITIATOR);\r\nprinterror = 1;\r\nif (lastphase == P_MESGOUT) {\r\nu_int tag;\r\ntag = SCB_LIST_NULL;\r\nif (ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT_TAG, TRUE)\r\n|| ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {\r\nif (ahc->msgout_buf[ahc->msgout_index - 1]\r\n== MSG_ABORT_TAG)\r\ntag = scb->hscb->tag;\r\nahc_print_path(ahc, scb);\r\nprintk("SCB %d - Abort%s Completed.\n",\r\nscb->hscb->tag, tag == SCB_LIST_NULL ?\r\n"" : " Tag");\r\nahc_abort_scbs(ahc, target, channel,\r\nsaved_lun, tag,\r\nROLE_INITIATOR,\r\nCAM_REQ_ABORTED);\r\nprinterror = 0;\r\n} else if (ahc_sent_msg(ahc, AHCMSG_1B,\r\nMSG_BUS_DEV_RESET, TRUE)) {\r\n#ifdef __FreeBSD__\r\nif (scb != NULL\r\n&& scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV\r\n&& ahc_match_scb(ahc, scb, target, channel,\r\nCAM_LUN_WILDCARD,\r\nSCB_LIST_NULL,\r\nROLE_INITIATOR)) {\r\nahc_set_transaction_status(scb, CAM_REQ_CMP);\r\n}\r\n#endif\r\nahc_compile_devinfo(&devinfo,\r\ninitiator_role_id,\r\ntarget,\r\nCAM_LUN_WILDCARD,\r\nchannel,\r\nROLE_INITIATOR);\r\nahc_handle_devreset(ahc, &devinfo,\r\nCAM_BDR_SENT,\r\n"Bus Device Reset",\r\n0);\r\nprinterror = 0;\r\n} else if (ahc_sent_msg(ahc, AHCMSG_EXT,\r\nMSG_EXT_PPR, FALSE)) {\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\ntinfo = ahc_fetch_transinfo(ahc,\r\ndevinfo.channel,\r\ndevinfo.our_scsiid,\r\ndevinfo.target,\r\n&tstate);\r\ntinfo->curr.transport_version = 2;\r\ntinfo->goal.transport_version = 2;\r\ntinfo->goal.ppr_options = 0;\r\nahc_qinfifo_requeue_tail(ahc, scb);\r\nprinterror = 0;\r\n} else if (ahc_sent_msg(ahc, AHCMSG_EXT,\r\nMSG_EXT_WDTR, FALSE)) {\r\nahc_set_width(ahc, &devinfo,\r\nMSG_EXT_WDTR_BUS_8_BIT,\r\nAHC_TRANS_CUR|AHC_TRANS_GOAL,\r\nTRUE);\r\nahc_qinfifo_requeue_tail(ahc, scb);\r\nprinterror = 0;\r\n} else if (ahc_sent_msg(ahc, AHCMSG_EXT,\r\nMSG_EXT_SDTR, FALSE)) {\r\nahc_set_syncrate(ahc, &devinfo,\r\nNULL,\r\n0, 0,\r\n0,\r\nAHC_TRANS_CUR|AHC_TRANS_GOAL,\r\nTRUE);\r\nahc_qinfifo_requeue_tail(ahc, scb);\r\nprinterror = 0;\r\n}\r\n}\r\nif (printerror != 0) {\r\nu_int i;\r\nif (scb != NULL) {\r\nu_int tag;\r\nif ((scb->hscb->control & TAG_ENB) != 0)\r\ntag = scb->hscb->tag;\r\nelse\r\ntag = SCB_LIST_NULL;\r\nahc_print_path(ahc, scb);\r\nahc_abort_scbs(ahc, target, channel,\r\nSCB_GET_LUN(scb), tag,\r\nROLE_INITIATOR,\r\nCAM_UNEXP_BUSFREE);\r\n} else {\r\nprintk("%s: ", ahc_name(ahc));\r\n}\r\nfor (i = 0; i < num_phases; i++) {\r\nif (lastphase == ahc_phase_table[i].phase)\r\nbreak;\r\n}\r\nif (lastphase != P_BUSFREE) {\r\nahc_force_renegotiation(ahc, &devinfo);\r\n}\r\nprintk("Unexpected busfree %s\n"\r\n"SEQADDR == 0x%x\n",\r\nahc_phase_table[i].phasemsg,\r\nahc_inb(ahc, SEQADDR0)\r\n| (ahc_inb(ahc, SEQADDR1) << 8));\r\n}\r\nahc_outb(ahc, CLRINT, CLRSCSIINT);\r\nahc_restart(ahc);\r\n} else {\r\nprintk("%s: Missing case in ahc_handle_scsiint. status = %x\n",\r\nahc_name(ahc), status);\r\nahc_outb(ahc, CLRINT, CLRSCSIINT);\r\n}\r\n}\r\nstatic void\r\nahc_force_renegotiation(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\r\n{\r\nstruct ahc_initiator_tinfo *targ_info;\r\nstruct ahc_tmode_tstate *tstate;\r\ntarg_info = ahc_fetch_transinfo(ahc,\r\ndevinfo->channel,\r\ndevinfo->our_scsiid,\r\ndevinfo->target,\r\n&tstate);\r\nahc_update_neg_request(ahc, devinfo, tstate,\r\ntarg_info, AHC_NEG_IF_NON_ASYNC);\r\n}\r\nstatic void\r\nahc_clear_critical_section(struct ahc_softc *ahc)\r\n{\r\nint stepping;\r\nint steps;\r\nu_int simode0;\r\nu_int simode1;\r\nif (ahc->num_critical_sections == 0)\r\nreturn;\r\nstepping = FALSE;\r\nsteps = 0;\r\nsimode0 = 0;\r\nsimode1 = 0;\r\nfor (;;) {\r\nstruct cs *cs;\r\nu_int seqaddr;\r\nu_int i;\r\nseqaddr = ahc_inb(ahc, SEQADDR0)\r\n| (ahc_inb(ahc, SEQADDR1) << 8);\r\nif (seqaddr != 0)\r\nseqaddr -= 1;\r\ncs = ahc->critical_sections;\r\nfor (i = 0; i < ahc->num_critical_sections; i++, cs++) {\r\nif (cs->begin < seqaddr && cs->end >= seqaddr)\r\nbreak;\r\n}\r\nif (i == ahc->num_critical_sections)\r\nbreak;\r\nif (steps > AHC_MAX_STEPS) {\r\nprintk("%s: Infinite loop in critical section\n",\r\nahc_name(ahc));\r\nahc_dump_card_state(ahc);\r\npanic("critical section loop");\r\n}\r\nsteps++;\r\nif (stepping == FALSE) {\r\nsimode0 = ahc_inb(ahc, SIMODE0);\r\nahc_outb(ahc, SIMODE0, 0);\r\nsimode1 = ahc_inb(ahc, SIMODE1);\r\nif ((ahc->features & AHC_DT) != 0)\r\nahc_outb(ahc, SIMODE1, simode1 & ENBUSFREE);\r\nelse\r\nahc_outb(ahc, SIMODE1, 0);\r\nahc_outb(ahc, CLRINT, CLRSCSIINT);\r\nahc_outb(ahc, SEQCTL, ahc->seqctl | STEP);\r\nstepping = TRUE;\r\n}\r\nif ((ahc->features & AHC_DT) != 0) {\r\nahc_outb(ahc, CLRSINT1, CLRBUSFREE);\r\nahc_outb(ahc, CLRINT, CLRSCSIINT);\r\n}\r\nahc_outb(ahc, HCNTRL, ahc->unpause);\r\nwhile (!ahc_is_paused(ahc))\r\nahc_delay(200);\r\n}\r\nif (stepping) {\r\nahc_outb(ahc, SIMODE0, simode0);\r\nahc_outb(ahc, SIMODE1, simode1);\r\nahc_outb(ahc, SEQCTL, ahc->seqctl);\r\n}\r\n}\r\nstatic void\r\nahc_clear_intstat(struct ahc_softc *ahc)\r\n{\r\nahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI\r\n|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|\r\nCLRREQINIT);\r\nahc_flush_device_writes(ahc);\r\nahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);\r\nahc_flush_device_writes(ahc);\r\nahc_outb(ahc, CLRINT, CLRSCSIINT);\r\nahc_flush_device_writes(ahc);\r\n}\r\nstatic struct ahc_tmode_tstate *\r\nahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel)\r\n{\r\nstruct ahc_tmode_tstate *master_tstate;\r\nstruct ahc_tmode_tstate *tstate;\r\nint i;\r\nmaster_tstate = ahc->enabled_targets[ahc->our_id];\r\nif (channel == 'B') {\r\nscsi_id += 8;\r\nmaster_tstate = ahc->enabled_targets[ahc->our_id_b + 8];\r\n}\r\nif (ahc->enabled_targets[scsi_id] != NULL\r\n&& ahc->enabled_targets[scsi_id] != master_tstate)\r\npanic("%s: ahc_alloc_tstate - Target already allocated",\r\nahc_name(ahc));\r\ntstate = kmalloc(sizeof(*tstate), GFP_ATOMIC);\r\nif (tstate == NULL)\r\nreturn (NULL);\r\nif (master_tstate != NULL) {\r\nmemcpy(tstate, master_tstate, sizeof(*tstate));\r\nmemset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));\r\ntstate->ultraenb = 0;\r\nfor (i = 0; i < AHC_NUM_TARGETS; i++) {\r\nmemset(&tstate->transinfo[i].curr, 0,\r\nsizeof(tstate->transinfo[i].curr));\r\nmemset(&tstate->transinfo[i].goal, 0,\r\nsizeof(tstate->transinfo[i].goal));\r\n}\r\n} else\r\nmemset(tstate, 0, sizeof(*tstate));\r\nahc->enabled_targets[scsi_id] = tstate;\r\nreturn (tstate);\r\n}\r\nstatic void\r\nahc_free_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel, int force)\r\n{\r\nstruct ahc_tmode_tstate *tstate;\r\nif (((channel == 'B' && scsi_id == ahc->our_id_b)\r\n|| (channel == 'A' && scsi_id == ahc->our_id))\r\n&& force == FALSE)\r\nreturn;\r\nif (channel == 'B')\r\nscsi_id += 8;\r\ntstate = ahc->enabled_targets[scsi_id];\r\nif (tstate != NULL)\r\nkfree(tstate);\r\nahc->enabled_targets[scsi_id] = NULL;\r\n}\r\nconst struct ahc_syncrate *\r\nahc_devlimited_syncrate(struct ahc_softc *ahc,\r\nstruct ahc_initiator_tinfo *tinfo,\r\nu_int *period, u_int *ppr_options, role_t role)\r\n{\r\nstruct ahc_transinfo *transinfo;\r\nu_int maxsync;\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nif ((ahc_inb(ahc, SBLKCTL) & ENAB40) != 0\r\n&& (ahc_inb(ahc, SSTAT2) & EXP_ACTIVE) == 0) {\r\nmaxsync = AHC_SYNCRATE_DT;\r\n} else {\r\nmaxsync = AHC_SYNCRATE_ULTRA;\r\n*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\r\n}\r\n} else if ((ahc->features & AHC_ULTRA) != 0) {\r\nmaxsync = AHC_SYNCRATE_ULTRA;\r\n} else {\r\nmaxsync = AHC_SYNCRATE_FAST;\r\n}\r\nif (role == ROLE_TARGET)\r\ntransinfo = &tinfo->user;\r\nelse\r\ntransinfo = &tinfo->goal;\r\n*ppr_options &= transinfo->ppr_options;\r\nif (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {\r\nmaxsync = max(maxsync, (u_int)AHC_SYNCRATE_ULTRA2);\r\n*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\r\n}\r\nif (transinfo->period == 0) {\r\n*period = 0;\r\n*ppr_options = 0;\r\nreturn (NULL);\r\n}\r\n*period = max(*period, (u_int)transinfo->period);\r\nreturn (ahc_find_syncrate(ahc, period, ppr_options, maxsync));\r\n}\r\nconst struct ahc_syncrate *\r\nahc_find_syncrate(struct ahc_softc *ahc, u_int *period,\r\nu_int *ppr_options, u_int maxsync)\r\n{\r\nconst struct ahc_syncrate *syncrate;\r\nif ((ahc->features & AHC_DT) == 0)\r\n*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\r\nif ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0\r\n&& maxsync < AHC_SYNCRATE_ULTRA2)\r\nmaxsync = AHC_SYNCRATE_ULTRA2;\r\nif ((ahc->features & (AHC_DT | AHC_ULTRA2)) == 0\r\n&& maxsync < AHC_SYNCRATE_ULTRA)\r\nmaxsync = AHC_SYNCRATE_ULTRA;\r\nif ((ahc->features & (AHC_DT | AHC_ULTRA2 | AHC_ULTRA)) == 0\r\n&& maxsync < AHC_SYNCRATE_FAST)\r\nmaxsync = AHC_SYNCRATE_FAST;\r\nfor (syncrate = &ahc_syncrates[maxsync];\r\nsyncrate->rate != NULL;\r\nsyncrate++) {\r\nif ((ahc->features & AHC_ULTRA2) != 0\r\n&& (syncrate->sxfr_u2 == 0))\r\nbreak;\r\nif (*period <= syncrate->period) {\r\nif (syncrate == &ahc_syncrates[maxsync])\r\n*period = syncrate->period;\r\nif ((syncrate->sxfr_u2 & ST_SXFR) != 0)\r\n*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\r\nbreak;\r\n}\r\n}\r\nif ((*period == 0)\r\n|| (syncrate->rate == NULL)\r\n|| ((ahc->features & AHC_ULTRA2) != 0\r\n&& (syncrate->sxfr_u2 == 0))) {\r\n*period = 0;\r\nsyncrate = NULL;\r\n*ppr_options &= ~MSG_EXT_PPR_DT_REQ;\r\n}\r\nreturn (syncrate);\r\n}\r\nu_int\r\nahc_find_period(struct ahc_softc *ahc, u_int scsirate, u_int maxsync)\r\n{\r\nconst struct ahc_syncrate *syncrate;\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nscsirate &= SXFR_ULTRA2;\r\nelse\r\nscsirate &= SXFR;\r\nif ((ahc->features & AHC_DT) == 0 && maxsync < AHC_SYNCRATE_ULTRA2)\r\nmaxsync = AHC_SYNCRATE_ULTRA2;\r\nif ((ahc->features & (AHC_DT | AHC_ULTRA2)) == 0\r\n&& maxsync < AHC_SYNCRATE_ULTRA)\r\nmaxsync = AHC_SYNCRATE_ULTRA;\r\nif ((ahc->features & (AHC_DT | AHC_ULTRA2 | AHC_ULTRA)) == 0\r\n&& maxsync < AHC_SYNCRATE_FAST)\r\nmaxsync = AHC_SYNCRATE_FAST;\r\nsyncrate = &ahc_syncrates[maxsync];\r\nwhile (syncrate->rate != NULL) {\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nif (syncrate->sxfr_u2 == 0)\r\nbreak;\r\nelse if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))\r\nreturn (syncrate->period);\r\n} else if (scsirate == (syncrate->sxfr & SXFR)) {\r\nreturn (syncrate->period);\r\n}\r\nsyncrate++;\r\n}\r\nreturn (0);\r\n}\r\nstatic void\r\nahc_validate_offset(struct ahc_softc *ahc,\r\nstruct ahc_initiator_tinfo *tinfo,\r\nconst struct ahc_syncrate *syncrate,\r\nu_int *offset, int wide, role_t role)\r\n{\r\nu_int maxoffset;\r\nif (syncrate == NULL) {\r\nmaxoffset = 0;\r\n} else if ((ahc->features & AHC_ULTRA2) != 0) {\r\nmaxoffset = MAX_OFFSET_ULTRA2;\r\n} else {\r\nif (wide)\r\nmaxoffset = MAX_OFFSET_16BIT;\r\nelse\r\nmaxoffset = MAX_OFFSET_8BIT;\r\n}\r\n*offset = min(*offset, maxoffset);\r\nif (tinfo != NULL) {\r\nif (role == ROLE_TARGET)\r\n*offset = min(*offset, (u_int)tinfo->user.offset);\r\nelse\r\n*offset = min(*offset, (u_int)tinfo->goal.offset);\r\n}\r\n}\r\nstatic void\r\nahc_validate_width(struct ahc_softc *ahc, struct ahc_initiator_tinfo *tinfo,\r\nu_int *bus_width, role_t role)\r\n{\r\nswitch (*bus_width) {\r\ndefault:\r\nif (ahc->features & AHC_WIDE) {\r\n*bus_width = MSG_EXT_WDTR_BUS_16_BIT;\r\nbreak;\r\n}\r\ncase MSG_EXT_WDTR_BUS_8_BIT:\r\n*bus_width = MSG_EXT_WDTR_BUS_8_BIT;\r\nbreak;\r\n}\r\nif (tinfo != NULL) {\r\nif (role == ROLE_TARGET)\r\n*bus_width = min((u_int)tinfo->user.width, *bus_width);\r\nelse\r\n*bus_width = min((u_int)tinfo->goal.width, *bus_width);\r\n}\r\n}\r\nint\r\nahc_update_neg_request(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nstruct ahc_tmode_tstate *tstate,\r\nstruct ahc_initiator_tinfo *tinfo, ahc_neg_type neg_type)\r\n{\r\nu_int auto_negotiate_orig;\r\nauto_negotiate_orig = tstate->auto_negotiate;\r\nif (neg_type == AHC_NEG_ALWAYS) {\r\nif ((ahc->features & AHC_WIDE) != 0)\r\ntinfo->curr.width = AHC_WIDTH_UNKNOWN;\r\ntinfo->curr.period = AHC_PERIOD_UNKNOWN;\r\ntinfo->curr.offset = AHC_OFFSET_UNKNOWN;\r\n}\r\nif (tinfo->curr.period != tinfo->goal.period\r\n|| tinfo->curr.width != tinfo->goal.width\r\n|| tinfo->curr.offset != tinfo->goal.offset\r\n|| tinfo->curr.ppr_options != tinfo->goal.ppr_options\r\n|| (neg_type == AHC_NEG_IF_NON_ASYNC\r\n&& (tinfo->goal.offset != 0\r\n|| tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT\r\n|| tinfo->goal.ppr_options != 0)))\r\ntstate->auto_negotiate |= devinfo->target_mask;\r\nelse\r\ntstate->auto_negotiate &= ~devinfo->target_mask;\r\nreturn (auto_negotiate_orig != tstate->auto_negotiate);\r\n}\r\nvoid\r\nahc_set_syncrate(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nconst struct ahc_syncrate *syncrate, u_int period,\r\nu_int offset, u_int ppr_options, u_int type, int paused)\r\n{\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nu_int old_period;\r\nu_int old_offset;\r\nu_int old_ppr;\r\nint active;\r\nint update_needed;\r\nactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\r\nupdate_needed = 0;\r\nif (syncrate == NULL) {\r\nperiod = 0;\r\noffset = 0;\r\n}\r\ntinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nif ((type & AHC_TRANS_USER) != 0) {\r\ntinfo->user.period = period;\r\ntinfo->user.offset = offset;\r\ntinfo->user.ppr_options = ppr_options;\r\n}\r\nif ((type & AHC_TRANS_GOAL) != 0) {\r\ntinfo->goal.period = period;\r\ntinfo->goal.offset = offset;\r\ntinfo->goal.ppr_options = ppr_options;\r\n}\r\nold_period = tinfo->curr.period;\r\nold_offset = tinfo->curr.offset;\r\nold_ppr = tinfo->curr.ppr_options;\r\nif ((type & AHC_TRANS_CUR) != 0\r\n&& (old_period != period\r\n|| old_offset != offset\r\n|| old_ppr != ppr_options)) {\r\nu_int scsirate;\r\nupdate_needed++;\r\nscsirate = tinfo->scsirate;\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nscsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);\r\nif (syncrate != NULL) {\r\nscsirate |= syncrate->sxfr_u2;\r\nif ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0)\r\nscsirate |= ENABLE_CRC;\r\nelse\r\nscsirate |= SINGLE_EDGE;\r\n}\r\n} else {\r\nscsirate &= ~(SXFR|SOFS);\r\ntstate->ultraenb &= ~devinfo->target_mask;\r\nif (syncrate != NULL) {\r\nif (syncrate->sxfr & ULTRA_SXFR) {\r\ntstate->ultraenb |=\r\ndevinfo->target_mask;\r\n}\r\nscsirate |= syncrate->sxfr & SXFR;\r\nscsirate |= offset & SOFS;\r\n}\r\nif (active) {\r\nu_int sxfrctl0;\r\nsxfrctl0 = ahc_inb(ahc, SXFRCTL0);\r\nsxfrctl0 &= ~FAST20;\r\nif (tstate->ultraenb & devinfo->target_mask)\r\nsxfrctl0 |= FAST20;\r\nahc_outb(ahc, SXFRCTL0, sxfrctl0);\r\n}\r\n}\r\nif (active) {\r\nahc_outb(ahc, SCSIRATE, scsirate);\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nahc_outb(ahc, SCSIOFFSET, offset);\r\n}\r\ntinfo->scsirate = scsirate;\r\ntinfo->curr.period = period;\r\ntinfo->curr.offset = offset;\r\ntinfo->curr.ppr_options = ppr_options;\r\nahc_send_async(ahc, devinfo->channel, devinfo->target,\r\nCAM_LUN_WILDCARD, AC_TRANSFER_NEG);\r\nif (bootverbose) {\r\nif (offset != 0) {\r\nprintk("%s: target %d synchronous at %sMHz%s, "\r\n"offset = 0x%x\n", ahc_name(ahc),\r\ndevinfo->target, syncrate->rate,\r\n(ppr_options & MSG_EXT_PPR_DT_REQ)\r\n? " DT" : "", offset);\r\n} else {\r\nprintk("%s: target %d using "\r\n"asynchronous transfers\n",\r\nahc_name(ahc), devinfo->target);\r\n}\r\n}\r\n}\r\nupdate_needed += ahc_update_neg_request(ahc, devinfo, tstate,\r\ntinfo, AHC_NEG_TO_GOAL);\r\nif (update_needed)\r\nahc_update_pending_scbs(ahc);\r\n}\r\nvoid\r\nahc_set_width(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nu_int width, u_int type, int paused)\r\n{\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nu_int oldwidth;\r\nint active;\r\nint update_needed;\r\nactive = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;\r\nupdate_needed = 0;\r\ntinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nif ((type & AHC_TRANS_USER) != 0)\r\ntinfo->user.width = width;\r\nif ((type & AHC_TRANS_GOAL) != 0)\r\ntinfo->goal.width = width;\r\noldwidth = tinfo->curr.width;\r\nif ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {\r\nu_int scsirate;\r\nupdate_needed++;\r\nscsirate = tinfo->scsirate;\r\nscsirate &= ~WIDEXFER;\r\nif (width == MSG_EXT_WDTR_BUS_16_BIT)\r\nscsirate |= WIDEXFER;\r\ntinfo->scsirate = scsirate;\r\nif (active)\r\nahc_outb(ahc, SCSIRATE, scsirate);\r\ntinfo->curr.width = width;\r\nahc_send_async(ahc, devinfo->channel, devinfo->target,\r\nCAM_LUN_WILDCARD, AC_TRANSFER_NEG);\r\nif (bootverbose) {\r\nprintk("%s: target %d using %dbit transfers\n",\r\nahc_name(ahc), devinfo->target,\r\n8 * (0x01 << width));\r\n}\r\n}\r\nupdate_needed += ahc_update_neg_request(ahc, devinfo, tstate,\r\ntinfo, AHC_NEG_TO_GOAL);\r\nif (update_needed)\r\nahc_update_pending_scbs(ahc);\r\n}\r\nstatic void\r\nahc_set_tags(struct ahc_softc *ahc, struct scsi_cmnd *cmd,\r\nstruct ahc_devinfo *devinfo, ahc_queue_alg alg)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nahc_platform_set_tags(ahc, sdev, devinfo, alg);\r\nahc_send_async(ahc, devinfo->channel, devinfo->target,\r\ndevinfo->lun, AC_TRANSFER_NEG);\r\n}\r\nstatic void\r\nahc_update_pending_scbs(struct ahc_softc *ahc)\r\n{\r\nstruct scb *pending_scb;\r\nint pending_scb_count;\r\nint i;\r\nint paused;\r\nu_int saved_scbptr;\r\npending_scb_count = 0;\r\nLIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {\r\nstruct ahc_devinfo devinfo;\r\nstruct hardware_scb *pending_hscb;\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nahc_scb_devinfo(ahc, &devinfo, pending_scb);\r\ntinfo = ahc_fetch_transinfo(ahc, devinfo.channel,\r\ndevinfo.our_scsiid,\r\ndevinfo.target, &tstate);\r\npending_hscb = pending_scb->hscb;\r\npending_hscb->control &= ~ULTRAENB;\r\nif ((tstate->ultraenb & devinfo.target_mask) != 0)\r\npending_hscb->control |= ULTRAENB;\r\npending_hscb->scsirate = tinfo->scsirate;\r\npending_hscb->scsioffset = tinfo->curr.offset;\r\nif ((tstate->auto_negotiate & devinfo.target_mask) == 0\r\n&& (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {\r\npending_scb->flags &= ~SCB_AUTO_NEGOTIATE;\r\npending_hscb->control &= ~MK_MESSAGE;\r\n}\r\nahc_sync_scb(ahc, pending_scb,\r\nBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\r\npending_scb_count++;\r\n}\r\nif (pending_scb_count == 0)\r\nreturn;\r\nif (ahc_is_paused(ahc)) {\r\npaused = 1;\r\n} else {\r\npaused = 0;\r\nahc_pause(ahc);\r\n}\r\nsaved_scbptr = ahc_inb(ahc, SCBPTR);\r\nfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\r\nstruct hardware_scb *pending_hscb;\r\nu_int control;\r\nu_int scb_tag;\r\nahc_outb(ahc, SCBPTR, i);\r\nscb_tag = ahc_inb(ahc, SCB_TAG);\r\npending_scb = ahc_lookup_scb(ahc, scb_tag);\r\nif (pending_scb == NULL)\r\ncontinue;\r\npending_hscb = pending_scb->hscb;\r\ncontrol = ahc_inb(ahc, SCB_CONTROL);\r\ncontrol &= ~(ULTRAENB|MK_MESSAGE);\r\ncontrol |= pending_hscb->control & (ULTRAENB|MK_MESSAGE);\r\nahc_outb(ahc, SCB_CONTROL, control);\r\nahc_outb(ahc, SCB_SCSIRATE, pending_hscb->scsirate);\r\nahc_outb(ahc, SCB_SCSIOFFSET, pending_hscb->scsioffset);\r\n}\r\nahc_outb(ahc, SCBPTR, saved_scbptr);\r\nif (paused == 0)\r\nahc_unpause(ahc);\r\n}\r\nstatic void\r\nahc_fetch_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\r\n{\r\nu_int saved_scsiid;\r\nrole_t role;\r\nint our_id;\r\nif (ahc_inb(ahc, SSTAT0) & TARGET)\r\nrole = ROLE_TARGET;\r\nelse\r\nrole = ROLE_INITIATOR;\r\nif (role == ROLE_TARGET\r\n&& (ahc->features & AHC_MULTI_TID) != 0\r\n&& (ahc_inb(ahc, SEQ_FLAGS)\r\n& (CMDPHASE_PENDING|TARG_CMD_PENDING|NO_DISCONNECT)) != 0) {\r\nour_id = ahc_inb(ahc, TARGIDIN) & OID;\r\n} else if ((ahc->features & AHC_ULTRA2) != 0)\r\nour_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;\r\nelse\r\nour_id = ahc_inb(ahc, SCSIID) & OID;\r\nsaved_scsiid = ahc_inb(ahc, SAVED_SCSIID);\r\nahc_compile_devinfo(devinfo,\r\nour_id,\r\nSCSIID_TARGET(ahc, saved_scsiid),\r\nahc_inb(ahc, SAVED_LUN),\r\nSCSIID_CHANNEL(ahc, saved_scsiid),\r\nrole);\r\n}\r\nstatic const struct ahc_phase_table_entry*\r\nahc_lookup_phase_entry(int phase)\r\n{\r\nconst struct ahc_phase_table_entry *entry;\r\nconst struct ahc_phase_table_entry *last_entry;\r\nlast_entry = &ahc_phase_table[num_phases];\r\nfor (entry = ahc_phase_table; entry < last_entry; entry++) {\r\nif (phase == entry->phase)\r\nbreak;\r\n}\r\nreturn (entry);\r\n}\r\nvoid\r\nahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id, u_int target,\r\nu_int lun, char channel, role_t role)\r\n{\r\ndevinfo->our_scsiid = our_id;\r\ndevinfo->target = target;\r\ndevinfo->lun = lun;\r\ndevinfo->target_offset = target;\r\ndevinfo->channel = channel;\r\ndevinfo->role = role;\r\nif (channel == 'B')\r\ndevinfo->target_offset += 8;\r\ndevinfo->target_mask = (0x01 << devinfo->target_offset);\r\n}\r\nvoid\r\nahc_print_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\r\n{\r\nprintk("%s:%c:%d:%d: ", ahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n}\r\nstatic void\r\nahc_scb_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nstruct scb *scb)\r\n{\r\nrole_t role;\r\nint our_id;\r\nour_id = SCSIID_OUR_ID(scb->hscb->scsiid);\r\nrole = ROLE_INITIATOR;\r\nif ((scb->flags & SCB_TARGET_SCB) != 0)\r\nrole = ROLE_TARGET;\r\nahc_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahc, scb),\r\nSCB_GET_LUN(scb), SCB_GET_CHANNEL(ahc, scb), role);\r\n}\r\nstatic void\r\nahc_assert_atn(struct ahc_softc *ahc)\r\n{\r\nu_int scsisigo;\r\nscsisigo = ATNO;\r\nif ((ahc->features & AHC_DT) == 0)\r\nscsisigo |= ahc_inb(ahc, SCSISIGI);\r\nahc_outb(ahc, SCSISIGO, scsisigo);\r\n}\r\nstatic void\r\nahc_setup_initiator_msgout(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nstruct scb *scb)\r\n{\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 0;\r\nif ((scb->flags & SCB_DEVICE_RESET) == 0\r\n&& ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {\r\nu_int identify_msg;\r\nidentify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);\r\nif ((scb->hscb->control & DISCENB) != 0)\r\nidentify_msg |= MSG_IDENTIFY_DISCFLAG;\r\nahc->msgout_buf[ahc->msgout_index++] = identify_msg;\r\nahc->msgout_len++;\r\nif ((scb->hscb->control & TAG_ENB) != 0) {\r\nahc->msgout_buf[ahc->msgout_index++] =\r\nscb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);\r\nahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;\r\nahc->msgout_len += 2;\r\n}\r\n}\r\nif (scb->flags & SCB_DEVICE_RESET) {\r\nahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;\r\nahc->msgout_len++;\r\nahc_print_path(ahc, scb);\r\nprintk("Bus Device Reset Message Sent\n");\r\nahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\r\n} else if ((scb->flags & SCB_ABORT) != 0) {\r\nif ((scb->hscb->control & TAG_ENB) != 0)\r\nahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;\r\nelse\r\nahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;\r\nahc->msgout_len++;\r\nahc_print_path(ahc, scb);\r\nprintk("Abort%s Message Sent\n",\r\n(scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");\r\nahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\r\n} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {\r\nahc_build_transfer_msg(ahc, devinfo);\r\n} else {\r\nprintk("ahc_intr: AWAITING_MSG for an SCB that "\r\n"does not have a waiting message\n");\r\nprintk("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,\r\ndevinfo->target_mask);\r\npanic("SCB = %d, SCB Control = %x, MSG_OUT = %x "\r\n"SCB flags = %x", scb->hscb->tag, scb->hscb->control,\r\nahc_inb(ahc, MSG_OUT), scb->flags);\r\n}\r\nahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);\r\nscb->hscb->control &= ~MK_MESSAGE;\r\nahc->msgout_index = 0;\r\nahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\n}\r\nstatic void\r\nahc_build_transfer_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\r\n{\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nconst struct ahc_syncrate *rate;\r\nint dowide;\r\nint dosync;\r\nint doppr;\r\nu_int period;\r\nu_int ppr_options;\r\nu_int offset;\r\ntinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nperiod = tinfo->goal.period;\r\noffset = tinfo->goal.offset;\r\nppr_options = tinfo->goal.ppr_options;\r\nif (devinfo->role == ROLE_TARGET)\r\nppr_options = 0;\r\nrate = ahc_devlimited_syncrate(ahc, tinfo, &period,\r\n&ppr_options, devinfo->role);\r\ndowide = tinfo->curr.width != tinfo->goal.width;\r\ndosync = tinfo->curr.offset != offset || tinfo->curr.period != period;\r\ndoppr = ppr_options != 0;\r\nif (!dowide && !dosync && !doppr) {\r\ndowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;\r\ndosync = tinfo->goal.offset != 0;\r\n}\r\nif (!dowide && !dosync && !doppr) {\r\nif ((ahc->features & AHC_WIDE) != 0)\r\ndowide = 1;\r\nelse\r\ndosync = 1;\r\nif (bootverbose) {\r\nahc_print_devinfo(ahc, devinfo);\r\nprintk("Ensuring async\n");\r\n}\r\n}\r\nif (devinfo->role == ROLE_TARGET)\r\ndoppr = 0;\r\nif (doppr || (dosync && !dowide)) {\r\noffset = tinfo->goal.offset;\r\nahc_validate_offset(ahc, tinfo, rate, &offset,\r\ndoppr ? tinfo->goal.width\r\n: tinfo->curr.width,\r\ndevinfo->role);\r\nif (doppr) {\r\nahc_construct_ppr(ahc, devinfo, period, offset,\r\ntinfo->goal.width, ppr_options);\r\n} else {\r\nahc_construct_sdtr(ahc, devinfo, period, offset);\r\n}\r\n} else {\r\nahc_construct_wdtr(ahc, devinfo, tinfo->goal.width);\r\n}\r\n}\r\nstatic void\r\nahc_construct_sdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nu_int period, u_int offset)\r\n{\r\nif (offset == 0)\r\nperiod = AHC_ASYNC_XFER_PERIOD;\r\nahc->msgout_index += spi_populate_sync_msg(\r\nahc->msgout_buf + ahc->msgout_index, period, offset);\r\nahc->msgout_len += 5;\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",\r\nahc_name(ahc), devinfo->channel, devinfo->target,\r\ndevinfo->lun, period, offset);\r\n}\r\n}\r\nstatic void\r\nahc_construct_wdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nu_int bus_width)\r\n{\r\nahc->msgout_index += spi_populate_width_msg(\r\nahc->msgout_buf + ahc->msgout_index, bus_width);\r\nahc->msgout_len += 4;\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Sending WDTR %x\n",\r\nahc_name(ahc), devinfo->channel, devinfo->target,\r\ndevinfo->lun, bus_width);\r\n}\r\n}\r\nstatic void\r\nahc_construct_ppr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nu_int period, u_int offset, u_int bus_width,\r\nu_int ppr_options)\r\n{\r\nif (offset == 0)\r\nperiod = AHC_ASYNC_XFER_PERIOD;\r\nahc->msgout_index += spi_populate_ppr_msg(\r\nahc->msgout_buf + ahc->msgout_index, period, offset,\r\nbus_width, ppr_options);\r\nahc->msgout_len += 8;\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "\r\n"offset %x, ppr_options %x\n", ahc_name(ahc),\r\ndevinfo->channel, devinfo->target, devinfo->lun,\r\nbus_width, period, offset, ppr_options);\r\n}\r\n}\r\nstatic void\r\nahc_clear_msg_state(struct ahc_softc *ahc)\r\n{\r\nahc->msgout_len = 0;\r\nahc->msgin_index = 0;\r\nahc->msg_type = MSG_TYPE_NONE;\r\nif ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0) {\r\nahc_outb(ahc, CLRSINT1, CLRATNO);\r\n}\r\nahc_outb(ahc, MSG_OUT, MSG_NOOP);\r\nahc_outb(ahc, SEQ_FLAGS2,\r\nahc_inb(ahc, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);\r\n}\r\nstatic void\r\nahc_handle_proto_violation(struct ahc_softc *ahc)\r\n{\r\nstruct ahc_devinfo devinfo;\r\nstruct scb *scb;\r\nu_int scbid;\r\nu_int seq_flags;\r\nu_int curphase;\r\nu_int lastphase;\r\nint found;\r\nahc_fetch_devinfo(ahc, &devinfo);\r\nscbid = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scbid);\r\nseq_flags = ahc_inb(ahc, SEQ_FLAGS);\r\ncurphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\r\nlastphase = ahc_inb(ahc, LASTPHASE);\r\nif ((seq_flags & NOT_IDENTIFIED) != 0) {\r\nahc_print_devinfo(ahc, &devinfo);\r\nprintk("Target did not send an IDENTIFY message. "\r\n"LASTPHASE = 0x%x.\n", lastphase);\r\nscb = NULL;\r\n} else if (scb == NULL) {\r\nahc_print_devinfo(ahc, &devinfo);\r\nprintk("No SCB found during protocol violation\n");\r\ngoto proto_violation_reset;\r\n} else {\r\nahc_set_transaction_status(scb, CAM_SEQUENCE_FAIL);\r\nif ((seq_flags & NO_CDB_SENT) != 0) {\r\nahc_print_path(ahc, scb);\r\nprintk("No or incomplete CDB sent to device.\n");\r\n} else if ((ahc_inb(ahc, SCB_CONTROL) & STATUS_RCVD) == 0) {\r\nahc_print_path(ahc, scb);\r\nprintk("Completed command without status.\n");\r\n} else {\r\nahc_print_path(ahc, scb);\r\nprintk("Unknown protocol violation.\n");\r\nahc_dump_card_state(ahc);\r\n}\r\n}\r\nif ((lastphase & ~P_DATAIN_DT) == 0\r\n|| lastphase == P_COMMAND) {\r\nproto_violation_reset:\r\nfound = ahc_reset_channel(ahc, 'A', TRUE);\r\nprintk("%s: Issued Channel %c Bus Reset. "\r\n"%d SCBs aborted\n", ahc_name(ahc), 'A', found);\r\n} else {\r\nahc_outb(ahc, SCSISEQ,\r\nahc_inb(ahc, SCSISEQ) & ~ENSELO);\r\nahc_assert_atn(ahc);\r\nahc_outb(ahc, MSG_OUT, HOST_MSG);\r\nif (scb == NULL) {\r\nahc_print_devinfo(ahc, &devinfo);\r\nahc->msgout_buf[0] = MSG_ABORT_TASK;\r\nahc->msgout_len = 1;\r\nahc->msgout_index = 0;\r\nahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\n} else {\r\nahc_print_path(ahc, scb);\r\nscb->flags |= SCB_ABORT;\r\n}\r\nprintk("Protocol violation %s. Attempting to abort.\n",\r\nahc_lookup_phase_entry(curphase)->phasemsg);\r\n}\r\n}\r\nstatic void\r\nahc_handle_message_phase(struct ahc_softc *ahc)\r\n{\r\nstruct ahc_devinfo devinfo;\r\nu_int bus_phase;\r\nint end_session;\r\nahc_fetch_devinfo(ahc, &devinfo);\r\nend_session = FALSE;\r\nbus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;\r\nreswitch:\r\nswitch (ahc->msg_type) {\r\ncase MSG_TYPE_INITIATOR_MSGOUT:\r\n{\r\nint lastbyte;\r\nint phasemis;\r\nint msgdone;\r\nif (ahc->msgout_len == 0)\r\npanic("HOST_MSG_LOOP interrupt with no active message");\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\r\nahc_print_devinfo(ahc, &devinfo);\r\nprintk("INITIATOR_MSG_OUT");\r\n}\r\n#endif\r\nphasemis = bus_phase != P_MESGOUT;\r\nif (phasemis) {\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\r\nprintk(" PHASEMIS %s\n",\r\nahc_lookup_phase_entry(bus_phase)\r\n->phasemsg);\r\n}\r\n#endif\r\nif (bus_phase == P_MESGIN) {\r\nahc_outb(ahc, CLRSINT1, CLRATNO);\r\nahc->send_msg_perror = FALSE;\r\nahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;\r\nahc->msgin_index = 0;\r\ngoto reswitch;\r\n}\r\nend_session = TRUE;\r\nbreak;\r\n}\r\nif (ahc->send_msg_perror) {\r\nahc_outb(ahc, CLRSINT1, CLRATNO);\r\nahc_outb(ahc, CLRSINT1, CLRREQINIT);\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MESSAGES) != 0)\r\nprintk(" byte 0x%x\n", ahc->send_msg_perror);\r\n#endif\r\nahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);\r\nbreak;\r\n}\r\nmsgdone = ahc->msgout_index == ahc->msgout_len;\r\nif (msgdone) {\r\nahc->msgout_index = 0;\r\nahc_assert_atn(ahc);\r\n}\r\nlastbyte = ahc->msgout_index == (ahc->msgout_len - 1);\r\nif (lastbyte) {\r\nahc_outb(ahc, CLRSINT1, CLRATNO);\r\n}\r\nahc_outb(ahc, CLRSINT1, CLRREQINIT);\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MESSAGES) != 0)\r\nprintk(" byte 0x%x\n",\r\nahc->msgout_buf[ahc->msgout_index]);\r\n#endif\r\nahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\r\nbreak;\r\n}\r\ncase MSG_TYPE_INITIATOR_MSGIN:\r\n{\r\nint phasemis;\r\nint message_done;\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\r\nahc_print_devinfo(ahc, &devinfo);\r\nprintk("INITIATOR_MSG_IN");\r\n}\r\n#endif\r\nphasemis = bus_phase != P_MESGIN;\r\nif (phasemis) {\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\r\nprintk(" PHASEMIS %s\n",\r\nahc_lookup_phase_entry(bus_phase)\r\n->phasemsg);\r\n}\r\n#endif\r\nahc->msgin_index = 0;\r\nif (bus_phase == P_MESGOUT\r\n&& (ahc->send_msg_perror == TRUE\r\n|| (ahc->msgout_len != 0\r\n&& ahc->msgout_index == 0))) {\r\nahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\ngoto reswitch;\r\n}\r\nend_session = TRUE;\r\nbreak;\r\n}\r\nahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MESSAGES) != 0)\r\nprintk(" byte 0x%x\n",\r\nahc->msgin_buf[ahc->msgin_index]);\r\n#endif\r\nmessage_done = ahc_parse_msg(ahc, &devinfo);\r\nif (message_done) {\r\nahc->msgin_index = 0;\r\nif (ahc->msgout_len != 0) {\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {\r\nahc_print_devinfo(ahc, &devinfo);\r\nprintk("Asserting ATN for response\n");\r\n}\r\n#endif\r\nahc_assert_atn(ahc);\r\n}\r\n} else\r\nahc->msgin_index++;\r\nif (message_done == MSGLOOP_TERMINATED) {\r\nend_session = TRUE;\r\n} else {\r\nahc_outb(ahc, CLRSINT1, CLRREQINIT);\r\nahc_inb(ahc, SCSIDATL);\r\n}\r\nbreak;\r\n}\r\ncase MSG_TYPE_TARGET_MSGIN:\r\n{\r\nint msgdone;\r\nint msgout_request;\r\nif (ahc->msgout_len == 0)\r\npanic("Target MSGIN with no active message");\r\nif ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0\r\n&& ahc->msgout_index > 0)\r\nmsgout_request = TRUE;\r\nelse\r\nmsgout_request = FALSE;\r\nif (msgout_request) {\r\nahc->msg_type = MSG_TYPE_TARGET_MSGOUT;\r\nahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);\r\nahc->msgin_index = 0;\r\nahc_inb(ahc, SCSIDATL);\r\nahc_outb(ahc, SXFRCTL0,\r\nahc_inb(ahc, SXFRCTL0) | SPIOEN);\r\nbreak;\r\n}\r\nmsgdone = ahc->msgout_index == ahc->msgout_len;\r\nif (msgdone) {\r\nahc_outb(ahc, SXFRCTL0,\r\nahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\r\nend_session = TRUE;\r\nbreak;\r\n}\r\nahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);\r\nahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);\r\nbreak;\r\n}\r\ncase MSG_TYPE_TARGET_MSGOUT:\r\n{\r\nint lastbyte;\r\nint msgdone;\r\nlastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;\r\nahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);\r\nahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);\r\nmsgdone = ahc_parse_msg(ahc, &devinfo);\r\nif (msgdone == MSGLOOP_TERMINATED) {\r\nreturn;\r\n}\r\nahc->msgin_index++;\r\nif (msgdone == MSGLOOP_MSGCOMPLETE) {\r\nahc->msgin_index = 0;\r\nif (ahc->msgout_len != 0) {\r\nahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);\r\nahc_outb(ahc, SXFRCTL0,\r\nahc_inb(ahc, SXFRCTL0) | SPIOEN);\r\nahc->msg_type = MSG_TYPE_TARGET_MSGIN;\r\nahc->msgin_index = 0;\r\nbreak;\r\n}\r\n}\r\nif (lastbyte)\r\nend_session = TRUE;\r\nelse {\r\nahc_outb(ahc, SXFRCTL0,\r\nahc_inb(ahc, SXFRCTL0) | SPIOEN);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\npanic("Unknown REQINIT message type");\r\n}\r\nif (end_session) {\r\nahc_clear_msg_state(ahc);\r\nahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);\r\n} else\r\nahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);\r\n}\r\nstatic int\r\nahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type, u_int msgval, int full)\r\n{\r\nint found;\r\nu_int index;\r\nfound = FALSE;\r\nindex = 0;\r\nwhile (index < ahc->msgout_len) {\r\nif (ahc->msgout_buf[index] == MSG_EXTENDED) {\r\nu_int end_index;\r\nend_index = index + 1 + ahc->msgout_buf[index + 1];\r\nif (ahc->msgout_buf[index+2] == msgval\r\n&& type == AHCMSG_EXT) {\r\nif (full) {\r\nif (ahc->msgout_index > end_index)\r\nfound = TRUE;\r\n} else if (ahc->msgout_index > index)\r\nfound = TRUE;\r\n}\r\nindex = end_index;\r\n} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_TASK\r\n&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {\r\nindex += 2;\r\n} else {\r\nif (type == AHCMSG_1B\r\n&& ahc->msgout_buf[index] == msgval\r\n&& ahc->msgout_index > index)\r\nfound = TRUE;\r\nindex++;\r\n}\r\nif (found)\r\nbreak;\r\n}\r\nreturn (found);\r\n}\r\nstatic int\r\nahc_parse_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\r\n{\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nint reject;\r\nint done;\r\nint response;\r\nu_int targ_scsirate;\r\ndone = MSGLOOP_IN_PROG;\r\nresponse = FALSE;\r\nreject = FALSE;\r\ntinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\ntarg_scsirate = tinfo->scsirate;\r\nswitch (ahc->msgin_buf[0]) {\r\ncase MSG_DISCONNECT:\r\ncase MSG_SAVEDATAPOINTER:\r\ncase MSG_CMDCOMPLETE:\r\ncase MSG_RESTOREPOINTERS:\r\ncase MSG_IGN_WIDE_RESIDUE:\r\ndone = MSGLOOP_TERMINATED;\r\nbreak;\r\ncase MSG_MESSAGE_REJECT:\r\nresponse = ahc_handle_msg_reject(ahc, devinfo);\r\ncase MSG_NOOP:\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nbreak;\r\ncase MSG_EXTENDED:\r\n{\r\nif (ahc->msgin_index < 2)\r\nbreak;\r\nswitch (ahc->msgin_buf[2]) {\r\ncase MSG_EXT_SDTR:\r\n{\r\nconst struct ahc_syncrate *syncrate;\r\nu_int period;\r\nu_int ppr_options;\r\nu_int offset;\r\nu_int saved_offset;\r\nif (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))\r\nbreak;\r\nperiod = ahc->msgin_buf[3];\r\nppr_options = 0;\r\nsaved_offset = offset = ahc->msgin_buf[4];\r\nsyncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,\r\n&ppr_options,\r\ndevinfo->role);\r\nahc_validate_offset(ahc, tinfo, syncrate, &offset,\r\ntarg_scsirate & WIDEXFER,\r\ndevinfo->role);\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Received "\r\n"SDTR period %x, offset %x\n\t"\r\n"Filtered to period %x, offset %x\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun,\r\nahc->msgin_buf[3], saved_offset,\r\nperiod, offset);\r\n}\r\nahc_set_syncrate(ahc, devinfo,\r\nsyncrate, period,\r\noffset, ppr_options,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\r\nTRUE);\r\nif (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, TRUE)) {\r\nif (saved_offset != offset) {\r\nreject = TRUE;\r\n}\r\n} else {\r\nif (bootverbose\r\n&& devinfo->role == ROLE_INITIATOR) {\r\nprintk("(%s:%c:%d:%d): Target "\r\n"Initiated SDTR\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n}\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 0;\r\nahc_construct_sdtr(ahc, devinfo,\r\nperiod, offset);\r\nahc->msgout_index = 0;\r\nresponse = TRUE;\r\n}\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nbreak;\r\n}\r\ncase MSG_EXT_WDTR:\r\n{\r\nu_int bus_width;\r\nu_int saved_width;\r\nu_int sending_reply;\r\nsending_reply = FALSE;\r\nif (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))\r\nbreak;\r\nbus_width = ahc->msgin_buf[3];\r\nsaved_width = bus_width;\r\nahc_validate_width(ahc, tinfo, &bus_width,\r\ndevinfo->role);\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Received WDTR "\r\n"%x filtered to %x\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun,\r\nsaved_width, bus_width);\r\n}\r\nif (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, TRUE)) {\r\nif (saved_width > bus_width) {\r\nreject = TRUE;\r\nprintk("(%s:%c:%d:%d): requested %dBit "\r\n"transfers. Rejecting...\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun,\r\n8 * (0x01 << bus_width));\r\nbus_width = 0;\r\n}\r\n} else {\r\nif (bootverbose\r\n&& devinfo->role == ROLE_INITIATOR) {\r\nprintk("(%s:%c:%d:%d): Target "\r\n"Initiated WDTR\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n}\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 0;\r\nahc_construct_wdtr(ahc, devinfo, bus_width);\r\nahc->msgout_index = 0;\r\nresponse = TRUE;\r\nsending_reply = TRUE;\r\n}\r\nahc_update_neg_request(ahc, devinfo, tstate,\r\ntinfo, AHC_NEG_ALWAYS);\r\nahc_set_width(ahc, devinfo, bus_width,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\r\nTRUE);\r\nif (sending_reply == FALSE && reject == FALSE) {\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 0;\r\nahc_build_transfer_msg(ahc, devinfo);\r\nahc->msgout_index = 0;\r\nresponse = TRUE;\r\n}\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nbreak;\r\n}\r\ncase MSG_EXT_PPR:\r\n{\r\nconst struct ahc_syncrate *syncrate;\r\nu_int period;\r\nu_int offset;\r\nu_int bus_width;\r\nu_int ppr_options;\r\nu_int saved_width;\r\nu_int saved_offset;\r\nu_int saved_ppr_options;\r\nif (ahc->msgin_buf[1] != MSG_EXT_PPR_LEN) {\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (ahc->msgin_index < (MSG_EXT_PPR_LEN + 1))\r\nbreak;\r\nperiod = ahc->msgin_buf[3];\r\noffset = ahc->msgin_buf[5];\r\nbus_width = ahc->msgin_buf[6];\r\nsaved_width = bus_width;\r\nppr_options = ahc->msgin_buf[7];\r\nif ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0\r\n&& period == 9)\r\noffset = 0;\r\nsaved_ppr_options = ppr_options;\r\nsaved_offset = offset;\r\nppr_options &= MSG_EXT_PPR_DT_REQ;\r\nif (bus_width == 0)\r\nppr_options = 0;\r\nahc_validate_width(ahc, tinfo, &bus_width,\r\ndevinfo->role);\r\nsyncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,\r\n&ppr_options,\r\ndevinfo->role);\r\nahc_validate_offset(ahc, tinfo, syncrate,\r\n&offset, bus_width,\r\ndevinfo->role);\r\nif (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, TRUE)) {\r\nif (saved_width > bus_width\r\n|| saved_offset != offset\r\n|| saved_ppr_options != ppr_options) {\r\nreject = TRUE;\r\nperiod = 0;\r\noffset = 0;\r\nbus_width = 0;\r\nppr_options = 0;\r\nsyncrate = NULL;\r\n}\r\n} else {\r\nif (devinfo->role != ROLE_TARGET)\r\nprintk("(%s:%c:%d:%d): Target "\r\n"Initiated PPR\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\nelse\r\nprintk("(%s:%c:%d:%d): Initiator "\r\n"Initiated PPR\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 0;\r\nahc_construct_ppr(ahc, devinfo, period, offset,\r\nbus_width, ppr_options);\r\nahc->msgout_index = 0;\r\nresponse = TRUE;\r\n}\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): Received PPR width %x, "\r\n"period %x, offset %x,options %x\n"\r\n"\tFiltered to width %x, period %x, "\r\n"offset %x, options %x\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun,\r\nsaved_width, ahc->msgin_buf[3],\r\nsaved_offset, saved_ppr_options,\r\nbus_width, period, offset, ppr_options);\r\n}\r\nahc_set_width(ahc, devinfo, bus_width,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\r\nTRUE);\r\nahc_set_syncrate(ahc, devinfo,\r\nsyncrate, period,\r\noffset, ppr_options,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\r\nTRUE);\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nbreak;\r\n}\r\ndefault:\r\nreject = TRUE;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n#ifdef AHC_TARGET_MODE\r\ncase MSG_BUS_DEV_RESET:\r\nahc_handle_devreset(ahc, devinfo,\r\nCAM_BDR_SENT,\r\n"Bus Device Reset Received",\r\n0);\r\nahc_restart(ahc);\r\ndone = MSGLOOP_TERMINATED;\r\nbreak;\r\ncase MSG_ABORT_TAG:\r\ncase MSG_ABORT:\r\ncase MSG_CLEAR_QUEUE:\r\n{\r\nint tag;\r\nif (devinfo->role != ROLE_TARGET) {\r\nreject = TRUE;\r\nbreak;\r\n}\r\ntag = SCB_LIST_NULL;\r\nif (ahc->msgin_buf[0] == MSG_ABORT_TAG)\r\ntag = ahc_inb(ahc, INITIATOR_TAG);\r\nahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\r\ndevinfo->lun, tag, ROLE_TARGET,\r\nCAM_REQ_ABORTED);\r\ntstate = ahc->enabled_targets[devinfo->our_scsiid];\r\nif (tstate != NULL) {\r\nstruct ahc_tmode_lstate* lstate;\r\nlstate = tstate->enabled_luns[devinfo->lun];\r\nif (lstate != NULL) {\r\nahc_queue_lstate_event(ahc, lstate,\r\ndevinfo->our_scsiid,\r\nahc->msgin_buf[0],\r\ntag);\r\nahc_send_lstate_events(ahc, lstate);\r\n}\r\n}\r\nahc_restart(ahc);\r\ndone = MSGLOOP_TERMINATED;\r\nbreak;\r\n}\r\n#endif\r\ncase MSG_TERM_IO_PROC:\r\ndefault:\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (reject) {\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 1;\r\nahc->msgout_buf[0] = MSG_MESSAGE_REJECT;\r\ndone = MSGLOOP_MSGCOMPLETE;\r\nresponse = TRUE;\r\n}\r\nif (done != MSGLOOP_IN_PROG && !response)\r\nahc->msgout_len = 0;\r\nreturn (done);\r\n}\r\nstatic int\r\nahc_handle_msg_reject(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\r\n{\r\nstruct scb *scb;\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nu_int scb_index;\r\nu_int last_msg;\r\nint response = 0;\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\ntinfo = ahc_fetch_transinfo(ahc, devinfo->channel,\r\ndevinfo->our_scsiid,\r\ndevinfo->target, &tstate);\r\nlast_msg = ahc_inb(ahc, LAST_MSG);\r\nif (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, FALSE)) {\r\nif (bootverbose) {\r\nprintk("(%s:%c:%d:%d): PPR Rejected. "\r\n"Trying WDTR/SDTR\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n}\r\ntinfo->goal.ppr_options = 0;\r\ntinfo->curr.transport_version = 2;\r\ntinfo->goal.transport_version = 2;\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 0;\r\nahc_build_transfer_msg(ahc, devinfo);\r\nahc->msgout_index = 0;\r\nresponse = 1;\r\n} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, FALSE)) {\r\nprintk("(%s:%c:%d:%d): refuses WIDE negotiation. Using "\r\n"8bit transfers\n", ahc_name(ahc),\r\ndevinfo->channel, devinfo->target, devinfo->lun);\r\nahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\r\nTRUE);\r\nif (tinfo->goal.offset != tinfo->curr.offset) {\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 0;\r\nahc_build_transfer_msg(ahc, devinfo);\r\nahc->msgout_index = 0;\r\nresponse = 1;\r\n}\r\n} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, FALSE)) {\r\nahc_set_syncrate(ahc, devinfo, NULL, 0,\r\n0, 0,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_GOAL,\r\nTRUE);\r\nprintk("(%s:%c:%d:%d): refuses synchronous negotiation. "\r\n"Using asynchronous transfers\n",\r\nahc_name(ahc), devinfo->channel,\r\ndevinfo->target, devinfo->lun);\r\n} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {\r\nint tag_type;\r\nint mask;\r\ntag_type = (scb->hscb->control & MSG_SIMPLE_TASK);\r\nif (tag_type == MSG_SIMPLE_TASK) {\r\nprintk("(%s:%c:%d:%d): refuses tagged commands. "\r\n"Performing non-tagged I/O\n", ahc_name(ahc),\r\ndevinfo->channel, devinfo->target, devinfo->lun);\r\nahc_set_tags(ahc, scb->io_ctx, devinfo, AHC_QUEUE_NONE);\r\nmask = ~0x23;\r\n} else {\r\nprintk("(%s:%c:%d:%d): refuses %s tagged commands. "\r\n"Performing simple queue tagged I/O only\n",\r\nahc_name(ahc), devinfo->channel, devinfo->target,\r\ndevinfo->lun, tag_type == MSG_ORDERED_TASK\r\n? "ordered" : "head of queue");\r\nahc_set_tags(ahc, scb->io_ctx, devinfo, AHC_QUEUE_BASIC);\r\nmask = ~0x03;\r\n}\r\nahc_outb(ahc, SCB_CONTROL,\r\nahc_inb(ahc, SCB_CONTROL) & mask);\r\nscb->hscb->control &= mask;\r\nahc_set_transaction_tag(scb, FALSE,\r\nMSG_SIMPLE_TASK);\r\nahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);\r\nahc_assert_atn(ahc);\r\nif ((ahc->flags & AHC_SCB_BTT) == 0) {\r\nstruct scb_tailq *untagged_q;\r\nuntagged_q =\r\n&(ahc->untagged_queues[devinfo->target_offset]);\r\nTAILQ_INSERT_HEAD(untagged_q, scb, links.tqe);\r\nscb->flags |= SCB_UNTAGGEDQ;\r\n}\r\nahc_busy_tcl(ahc, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),\r\nscb->hscb->tag);\r\nahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),\r\nSCB_GET_CHANNEL(ahc, scb),\r\nSCB_GET_LUN(scb), SCB_LIST_NULL,\r\nROLE_INITIATOR, CAM_REQUEUE_REQ,\r\nSEARCH_COMPLETE);\r\n} else {\r\nprintk("%s:%c:%d: Message reject for %x -- ignored\n",\r\nahc_name(ahc), devinfo->channel, devinfo->target,\r\nlast_msg);\r\n}\r\nreturn (response);\r\n}\r\nstatic void\r\nahc_handle_ign_wide_residue(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)\r\n{\r\nu_int scb_index;\r\nstruct scb *scb;\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nif ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0\r\n|| ahc_get_transfer_dir(scb) != CAM_DIR_IN) {\r\n} else {\r\nuint32_t sgptr;\r\nsgptr = ahc_inb(ahc, SCB_RESIDUAL_SGPTR);\r\nif ((sgptr & SG_LIST_NULL) != 0\r\n&& (ahc_inb(ahc, SCB_LUN) & SCB_XFERLEN_ODD) != 0) {\r\n} else {\r\nstruct ahc_dma_seg *sg;\r\nuint32_t data_cnt;\r\nuint32_t data_addr;\r\nuint32_t sglen;\r\nsgptr = ahc_inl(ahc, SCB_RESIDUAL_SGPTR);\r\ndata_cnt = ahc_inl(ahc, SCB_RESIDUAL_DATACNT);\r\nif ((sgptr & SG_LIST_NULL) != 0) {\r\ndata_cnt &= ~AHC_SG_LEN_MASK;\r\n}\r\ndata_addr = ahc_inl(ahc, SHADDR);\r\ndata_cnt += 1;\r\ndata_addr -= 1;\r\nsgptr &= SG_PTR_MASK;\r\nsg = ahc_sg_bus_to_virt(scb, sgptr);\r\nsg--;\r\nsglen = ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;\r\nif (sg != scb->sg_list\r\n&& sglen < (data_cnt & AHC_SG_LEN_MASK)) {\r\nsg--;\r\nsglen = ahc_le32toh(sg->len);\r\ndata_cnt = 1 | (sglen & (~AHC_SG_LEN_MASK));\r\ndata_addr = ahc_le32toh(sg->addr)\r\n+ (sglen & AHC_SG_LEN_MASK) - 1;\r\nsg++;\r\nsgptr = ahc_sg_virt_to_bus(scb, sg);\r\n}\r\nahc_outl(ahc, SCB_RESIDUAL_SGPTR, sgptr);\r\nahc_outl(ahc, SCB_RESIDUAL_DATACNT, data_cnt);\r\nahc_outb(ahc, SCB_LUN,\r\nahc_inb(ahc, SCB_LUN) ^ SCB_XFERLEN_ODD);\r\n}\r\n}\r\n}\r\nstatic void\r\nahc_reinitialize_dataptrs(struct ahc_softc *ahc)\r\n{\r\nstruct scb *scb;\r\nstruct ahc_dma_seg *sg;\r\nu_int scb_index;\r\nuint32_t sgptr;\r\nuint32_t resid;\r\nuint32_t dataptr;\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nsgptr = (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)\r\n| (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)\r\n| (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8)\r\n| ahc_inb(ahc, SCB_RESIDUAL_SGPTR);\r\nsgptr &= SG_PTR_MASK;\r\nsg = ahc_sg_bus_to_virt(scb, sgptr);\r\nsg--;\r\nresid = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 2) << 16)\r\n| (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 1) << 8)\r\n| ahc_inb(ahc, SCB_RESIDUAL_DATACNT);\r\ndataptr = ahc_le32toh(sg->addr)\r\n+ (ahc_le32toh(sg->len) & AHC_SG_LEN_MASK)\r\n- resid;\r\nif ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {\r\nu_int dscommand1;\r\ndscommand1 = ahc_inb(ahc, DSCOMMAND1);\r\nahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);\r\nahc_outb(ahc, HADDR,\r\n(ahc_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);\r\nahc_outb(ahc, DSCOMMAND1, dscommand1);\r\n}\r\nahc_outb(ahc, HADDR + 3, dataptr >> 24);\r\nahc_outb(ahc, HADDR + 2, dataptr >> 16);\r\nahc_outb(ahc, HADDR + 1, dataptr >> 8);\r\nahc_outb(ahc, HADDR, dataptr);\r\nahc_outb(ahc, HCNT + 2, resid >> 16);\r\nahc_outb(ahc, HCNT + 1, resid >> 8);\r\nahc_outb(ahc, HCNT, resid);\r\nif ((ahc->features & AHC_ULTRA2) == 0) {\r\nahc_outb(ahc, STCNT + 2, resid >> 16);\r\nahc_outb(ahc, STCNT + 1, resid >> 8);\r\nahc_outb(ahc, STCNT, resid);\r\n}\r\n}\r\nstatic void\r\nahc_handle_devreset(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\ncam_status status, char *message, int verbose_level)\r\n{\r\n#ifdef AHC_TARGET_MODE\r\nstruct ahc_tmode_tstate* tstate;\r\nu_int lun;\r\n#endif\r\nint found;\r\nfound = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,\r\nCAM_LUN_WILDCARD, SCB_LIST_NULL, devinfo->role,\r\nstatus);\r\n#ifdef AHC_TARGET_MODE\r\ntstate = ahc->enabled_targets[devinfo->our_scsiid];\r\nif (tstate != NULL) {\r\nfor (lun = 0; lun < AHC_NUM_LUNS; lun++) {\r\nstruct ahc_tmode_lstate* lstate;\r\nlstate = tstate->enabled_luns[lun];\r\nif (lstate == NULL)\r\ncontinue;\r\nahc_queue_lstate_event(ahc, lstate, devinfo->our_scsiid,\r\nMSG_BUS_DEV_RESET, 0);\r\nahc_send_lstate_events(ahc, lstate);\r\n}\r\n}\r\n#endif\r\nahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHC_TRANS_CUR, TRUE);\r\nahc_set_syncrate(ahc, devinfo, NULL,\r\n0, 0, 0,\r\nAHC_TRANS_CUR, TRUE);\r\nif (status != CAM_SEL_TIMEOUT)\r\nahc_send_async(ahc, devinfo->channel, devinfo->target,\r\nCAM_LUN_WILDCARD, AC_SENT_BDR);\r\nif (message != NULL\r\n&& (verbose_level <= bootverbose))\r\nprintk("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),\r\nmessage, devinfo->channel, devinfo->target, found);\r\n}\r\nstatic void\r\nahc_setup_target_msgin(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,\r\nstruct scb *scb)\r\n{\r\nahc->msgout_index = 0;\r\nahc->msgout_len = 0;\r\nif (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)\r\nahc_build_transfer_msg(ahc, devinfo);\r\nelse\r\npanic("ahc_intr: AWAITING target message with no message");\r\nahc->msgout_index = 0;\r\nahc->msg_type = MSG_TYPE_TARGET_MSGIN;\r\n}\r\nstruct ahc_softc *\r\nahc_alloc(void *platform_arg, char *name)\r\n{\r\nstruct ahc_softc *ahc;\r\nint i;\r\n#ifndef __FreeBSD__\r\nahc = kmalloc(sizeof(*ahc), GFP_ATOMIC);\r\nif (!ahc) {\r\nprintk("aic7xxx: cannot malloc softc!\n");\r\nkfree(name);\r\nreturn NULL;\r\n}\r\n#else\r\nahc = device_get_softc((device_t)platform_arg);\r\n#endif\r\nmemset(ahc, 0, sizeof(*ahc));\r\nahc->seep_config = kmalloc(sizeof(*ahc->seep_config), GFP_ATOMIC);\r\nif (ahc->seep_config == NULL) {\r\n#ifndef __FreeBSD__\r\nkfree(ahc);\r\n#endif\r\nkfree(name);\r\nreturn (NULL);\r\n}\r\nLIST_INIT(&ahc->pending_scbs);\r\nahc->name = name;\r\nahc->unit = -1;\r\nahc->description = NULL;\r\nahc->channel = 'A';\r\nahc->channel_b = 'B';\r\nahc->chip = AHC_NONE;\r\nahc->features = AHC_FENONE;\r\nahc->bugs = AHC_BUGNONE;\r\nahc->flags = AHC_FNONE;\r\nahc->seqctl = FASTMODE;\r\nfor (i = 0; i < AHC_NUM_TARGETS; i++)\r\nTAILQ_INIT(&ahc->untagged_queues[i]);\r\nif (ahc_platform_alloc(ahc, platform_arg) != 0) {\r\nahc_free(ahc);\r\nahc = NULL;\r\n}\r\nreturn (ahc);\r\n}\r\nint\r\nahc_softc_init(struct ahc_softc *ahc)\r\n{\r\nif ((ahc->chip & AHC_PCI) == 0)\r\nahc->unpause = ahc_inb(ahc, HCNTRL) & IRQMS;\r\nelse\r\nahc->unpause = 0;\r\nahc->pause = ahc->unpause | PAUSE;\r\nif (ahc->scb_data == NULL) {\r\nahc->scb_data = kzalloc(sizeof(*ahc->scb_data), GFP_ATOMIC);\r\nif (ahc->scb_data == NULL)\r\nreturn (ENOMEM);\r\n}\r\nreturn (0);\r\n}\r\nvoid\r\nahc_set_unit(struct ahc_softc *ahc, int unit)\r\n{\r\nahc->unit = unit;\r\n}\r\nvoid\r\nahc_set_name(struct ahc_softc *ahc, char *name)\r\n{\r\nif (ahc->name != NULL)\r\nkfree(ahc->name);\r\nahc->name = name;\r\n}\r\nvoid\r\nahc_free(struct ahc_softc *ahc)\r\n{\r\nint i;\r\nswitch (ahc->init_level) {\r\ndefault:\r\ncase 5:\r\nahc_shutdown(ahc);\r\ncase 4:\r\nahc_dmamap_unload(ahc, ahc->shared_data_dmat,\r\nahc->shared_data_dmamap);\r\ncase 3:\r\nahc_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,\r\nahc->shared_data_dmamap);\r\nahc_dmamap_destroy(ahc, ahc->shared_data_dmat,\r\nahc->shared_data_dmamap);\r\ncase 2:\r\nahc_dma_tag_destroy(ahc, ahc->shared_data_dmat);\r\ncase 1:\r\n#ifndef __linux__\r\nahc_dma_tag_destroy(ahc, ahc->buffer_dmat);\r\n#endif\r\nbreak;\r\ncase 0:\r\nbreak;\r\n}\r\n#ifndef __linux__\r\nahc_dma_tag_destroy(ahc, ahc->parent_dmat);\r\n#endif\r\nahc_platform_free(ahc);\r\nahc_fini_scbdata(ahc);\r\nfor (i = 0; i < AHC_NUM_TARGETS; i++) {\r\nstruct ahc_tmode_tstate *tstate;\r\ntstate = ahc->enabled_targets[i];\r\nif (tstate != NULL) {\r\n#ifdef AHC_TARGET_MODE\r\nint j;\r\nfor (j = 0; j < AHC_NUM_LUNS; j++) {\r\nstruct ahc_tmode_lstate *lstate;\r\nlstate = tstate->enabled_luns[j];\r\nif (lstate != NULL) {\r\nxpt_free_path(lstate->path);\r\nkfree(lstate);\r\n}\r\n}\r\n#endif\r\nkfree(tstate);\r\n}\r\n}\r\n#ifdef AHC_TARGET_MODE\r\nif (ahc->black_hole != NULL) {\r\nxpt_free_path(ahc->black_hole->path);\r\nkfree(ahc->black_hole);\r\n}\r\n#endif\r\nif (ahc->name != NULL)\r\nkfree(ahc->name);\r\nif (ahc->seep_config != NULL)\r\nkfree(ahc->seep_config);\r\n#ifndef __FreeBSD__\r\nkfree(ahc);\r\n#endif\r\nreturn;\r\n}\r\nstatic void\r\nahc_shutdown(void *arg)\r\n{\r\nstruct ahc_softc *ahc;\r\nint i;\r\nahc = (struct ahc_softc *)arg;\r\nahc_reset(ahc, FALSE);\r\nahc_outb(ahc, SCSISEQ, 0);\r\nahc_outb(ahc, SXFRCTL0, 0);\r\nahc_outb(ahc, DSPCISTATUS, 0);\r\nfor (i = TARG_SCSIRATE; i < SCSICONF; i++)\r\nahc_outb(ahc, i, 0);\r\n}\r\nint\r\nahc_reset(struct ahc_softc *ahc, int reinit)\r\n{\r\nu_int sblkctl;\r\nu_int sxfrctl1_a, sxfrctl1_b;\r\nint error;\r\nint wait;\r\nahc_pause(ahc);\r\nsxfrctl1_b = 0;\r\nif ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {\r\nu_int sblkctl;\r\nsblkctl = ahc_inb(ahc, SBLKCTL);\r\nahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);\r\nsxfrctl1_b = ahc_inb(ahc, SXFRCTL1);\r\nahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);\r\n}\r\nsxfrctl1_a = ahc_inb(ahc, SXFRCTL1);\r\nahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);\r\nwait = 1000;\r\ndo {\r\nahc_delay(1000);\r\n} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));\r\nif (wait == 0) {\r\nprintk("%s: WARNING - Failed chip reset! "\r\n"Trying to initialize anyway.\n", ahc_name(ahc));\r\n}\r\nahc_outb(ahc, HCNTRL, ahc->pause);\r\nsblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);\r\nif ((ahc->chip & AHC_PCI) != 0)\r\nsblkctl &= ~SELBUSB;\r\nswitch (sblkctl) {\r\ncase 0:\r\nbreak;\r\ncase 2:\r\nahc->features |= AHC_WIDE;\r\nbreak;\r\ncase 8:\r\nahc->features |= AHC_TWIN;\r\nbreak;\r\ndefault:\r\nprintk(" Unsupported adapter type. Ignoring\n");\r\nreturn(-1);\r\n}\r\nif ((ahc->features & AHC_TWIN) != 0) {\r\nu_int sblkctl;\r\nsblkctl = ahc_inb(ahc, SBLKCTL);\r\nahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);\r\nahc_outb(ahc, SXFRCTL1, sxfrctl1_b);\r\nahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);\r\n}\r\nahc_outb(ahc, SXFRCTL1, sxfrctl1_a);\r\nerror = 0;\r\nif (reinit != 0)\r\nerror = ahc->bus_chip_init(ahc);\r\n#ifdef AHC_DUMP_SEQ\r\nelse\r\nahc_dumpseq(ahc);\r\n#endif\r\nreturn (error);\r\n}\r\nint\r\nahc_probe_scbs(struct ahc_softc *ahc) {\r\nint i;\r\nfor (i = 0; i < AHC_SCB_MAX; i++) {\r\nahc_outb(ahc, SCBPTR, i);\r\nahc_outb(ahc, SCB_BASE, i);\r\nif (ahc_inb(ahc, SCB_BASE) != i)\r\nbreak;\r\nahc_outb(ahc, SCBPTR, 0);\r\nif (ahc_inb(ahc, SCB_BASE) != 0)\r\nbreak;\r\n}\r\nreturn (i);\r\n}\r\nstatic void\r\nahc_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error)\r\n{\r\ndma_addr_t *baddr;\r\nbaddr = (dma_addr_t *)arg;\r\n*baddr = segs->ds_addr;\r\n}\r\nstatic void\r\nahc_build_free_scb_list(struct ahc_softc *ahc)\r\n{\r\nint scbsize;\r\nint i;\r\nscbsize = 32;\r\nif ((ahc->flags & AHC_LSCBS_ENABLED) != 0)\r\nscbsize = 64;\r\nfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\r\nint j;\r\nahc_outb(ahc, SCBPTR, i);\r\nfor (j = 0; j < scbsize; j++)\r\nahc_outb(ahc, SCB_BASE+j, 0xFF);\r\nahc_outb(ahc, SCB_CONTROL, 0);\r\nif ((ahc->flags & AHC_PAGESCBS) != 0)\r\nahc_outb(ahc, SCB_NEXT, i+1);\r\nelse\r\nahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);\r\nahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\r\nahc_outb(ahc, SCB_SCSIID, 0xFF);\r\nahc_outb(ahc, SCB_LUN, 0xFF);\r\n}\r\nif ((ahc->flags & AHC_PAGESCBS) != 0) {\r\nahc_outb(ahc, FREE_SCBH, 0);\r\n} else {\r\nahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);\r\n}\r\nahc_outb(ahc, SCBPTR, i-1);\r\nahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);\r\n}\r\nstatic int\r\nahc_init_scbdata(struct ahc_softc *ahc)\r\n{\r\nstruct scb_data *scb_data;\r\nscb_data = ahc->scb_data;\r\nSLIST_INIT(&scb_data->free_scbs);\r\nSLIST_INIT(&scb_data->sg_maps);\r\nscb_data->scbarray = kzalloc(sizeof(struct scb) * AHC_SCB_MAX_ALLOC,\r\nGFP_ATOMIC);\r\nif (scb_data->scbarray == NULL)\r\nreturn (ENOMEM);\r\nscb_data->maxhscbs = ahc_probe_scbs(ahc);\r\nif (ahc->scb_data->maxhscbs == 0) {\r\nprintk("%s: No SCB space found\n", ahc_name(ahc));\r\nreturn (ENXIO);\r\n}\r\nif (ahc_dma_tag_create(ahc, ahc->parent_dmat, 1,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nBUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\nAHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb),\r\n1,\r\nBUS_SPACE_MAXSIZE_32BIT,\r\n0, &scb_data->hscb_dmat) != 0) {\r\ngoto error_exit;\r\n}\r\nscb_data->init_level++;\r\nif (ahc_dmamem_alloc(ahc, scb_data->hscb_dmat,\r\n(void **)&scb_data->hscbs,\r\nBUS_DMA_NOWAIT, &scb_data->hscb_dmamap) != 0) {\r\ngoto error_exit;\r\n}\r\nscb_data->init_level++;\r\nahc_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,\r\nscb_data->hscbs,\r\nAHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb),\r\nahc_dmamap_cb, &scb_data->hscb_busaddr, 0);\r\nscb_data->init_level++;\r\nif (ahc_dma_tag_create(ahc, ahc->parent_dmat, 1,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nBUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\nAHC_SCB_MAX_ALLOC * sizeof(struct scsi_sense_data),\r\n1,\r\nBUS_SPACE_MAXSIZE_32BIT,\r\n0, &scb_data->sense_dmat) != 0) {\r\ngoto error_exit;\r\n}\r\nscb_data->init_level++;\r\nif (ahc_dmamem_alloc(ahc, scb_data->sense_dmat,\r\n(void **)&scb_data->sense,\r\nBUS_DMA_NOWAIT, &scb_data->sense_dmamap) != 0) {\r\ngoto error_exit;\r\n}\r\nscb_data->init_level++;\r\nahc_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,\r\nscb_data->sense,\r\nAHC_SCB_MAX_ALLOC * sizeof(struct scsi_sense_data),\r\nahc_dmamap_cb, &scb_data->sense_busaddr, 0);\r\nscb_data->init_level++;\r\nif (ahc_dma_tag_create(ahc, ahc->parent_dmat, 8,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nBUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\nPAGE_SIZE, 1,\r\nBUS_SPACE_MAXSIZE_32BIT,\r\n0, &scb_data->sg_dmat) != 0) {\r\ngoto error_exit;\r\n}\r\nscb_data->init_level++;\r\nmemset(scb_data->hscbs, 0,\r\nAHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb));\r\nahc_alloc_scbs(ahc);\r\nif (scb_data->numscbs == 0) {\r\nprintk("%s: ahc_init_scbdata - "\r\n"Unable to allocate initial scbs\n",\r\nahc_name(ahc));\r\ngoto error_exit;\r\n}\r\nahc->next_queued_scb = ahc_get_scb(ahc);\r\nreturn (0);\r\nerror_exit:\r\nreturn (ENOMEM);\r\n}\r\nstatic void\r\nahc_fini_scbdata(struct ahc_softc *ahc)\r\n{\r\nstruct scb_data *scb_data;\r\nscb_data = ahc->scb_data;\r\nif (scb_data == NULL)\r\nreturn;\r\nswitch (scb_data->init_level) {\r\ndefault:\r\ncase 7:\r\n{\r\nstruct sg_map_node *sg_map;\r\nwhile ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {\r\nSLIST_REMOVE_HEAD(&scb_data->sg_maps, links);\r\nahc_dmamap_unload(ahc, scb_data->sg_dmat,\r\nsg_map->sg_dmamap);\r\nahc_dmamem_free(ahc, scb_data->sg_dmat,\r\nsg_map->sg_vaddr,\r\nsg_map->sg_dmamap);\r\nkfree(sg_map);\r\n}\r\nahc_dma_tag_destroy(ahc, scb_data->sg_dmat);\r\n}\r\ncase 6:\r\nahc_dmamap_unload(ahc, scb_data->sense_dmat,\r\nscb_data->sense_dmamap);\r\ncase 5:\r\nahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,\r\nscb_data->sense_dmamap);\r\nahc_dmamap_destroy(ahc, scb_data->sense_dmat,\r\nscb_data->sense_dmamap);\r\ncase 4:\r\nahc_dma_tag_destroy(ahc, scb_data->sense_dmat);\r\ncase 3:\r\nahc_dmamap_unload(ahc, scb_data->hscb_dmat,\r\nscb_data->hscb_dmamap);\r\ncase 2:\r\nahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,\r\nscb_data->hscb_dmamap);\r\nahc_dmamap_destroy(ahc, scb_data->hscb_dmat,\r\nscb_data->hscb_dmamap);\r\ncase 1:\r\nahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);\r\nbreak;\r\ncase 0:\r\nbreak;\r\n}\r\nif (scb_data->scbarray != NULL)\r\nkfree(scb_data->scbarray);\r\n}\r\nstatic void\r\nahc_alloc_scbs(struct ahc_softc *ahc)\r\n{\r\nstruct scb_data *scb_data;\r\nstruct scb *next_scb;\r\nstruct sg_map_node *sg_map;\r\ndma_addr_t physaddr;\r\nstruct ahc_dma_seg *segs;\r\nint newcount;\r\nint i;\r\nscb_data = ahc->scb_data;\r\nif (scb_data->numscbs >= AHC_SCB_MAX_ALLOC)\r\nreturn;\r\nnext_scb = &scb_data->scbarray[scb_data->numscbs];\r\nsg_map = kmalloc(sizeof(*sg_map), GFP_ATOMIC);\r\nif (sg_map == NULL)\r\nreturn;\r\nif (ahc_dmamem_alloc(ahc, scb_data->sg_dmat,\r\n(void **)&sg_map->sg_vaddr,\r\nBUS_DMA_NOWAIT, &sg_map->sg_dmamap) != 0) {\r\nkfree(sg_map);\r\nreturn;\r\n}\r\nSLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);\r\nahc_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,\r\nsg_map->sg_vaddr, PAGE_SIZE, ahc_dmamap_cb,\r\n&sg_map->sg_physaddr, 0);\r\nsegs = sg_map->sg_vaddr;\r\nphysaddr = sg_map->sg_physaddr;\r\nnewcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));\r\nnewcount = min(newcount, (AHC_SCB_MAX_ALLOC - scb_data->numscbs));\r\nfor (i = 0; i < newcount; i++) {\r\nstruct scb_platform_data *pdata;\r\n#ifndef __linux__\r\nint error;\r\n#endif\r\npdata = kmalloc(sizeof(*pdata), GFP_ATOMIC);\r\nif (pdata == NULL)\r\nbreak;\r\nnext_scb->platform_data = pdata;\r\nnext_scb->sg_map = sg_map;\r\nnext_scb->sg_list = segs;\r\nnext_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);\r\nnext_scb->ahc_softc = ahc;\r\nnext_scb->flags = SCB_FREE;\r\n#ifndef __linux__\r\nerror = ahc_dmamap_create(ahc, ahc->buffer_dmat, 0,\r\n&next_scb->dmamap);\r\nif (error != 0)\r\nbreak;\r\n#endif\r\nnext_scb->hscb = &scb_data->hscbs[scb_data->numscbs];\r\nnext_scb->hscb->tag = ahc->scb_data->numscbs;\r\nSLIST_INSERT_HEAD(&ahc->scb_data->free_scbs,\r\nnext_scb, links.sle);\r\nsegs += AHC_NSEG;\r\nphysaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));\r\nnext_scb++;\r\nahc->scb_data->numscbs++;\r\n}\r\n}\r\nvoid\r\nahc_controller_info(struct ahc_softc *ahc, char *buf)\r\n{\r\nint len;\r\nlen = sprintf(buf, "%s: ", ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);\r\nbuf += len;\r\nif ((ahc->features & AHC_TWIN) != 0)\r\nlen = sprintf(buf, "Twin Channel, A SCSI Id=%d, "\r\n"B SCSI Id=%d, primary %c, ",\r\nahc->our_id, ahc->our_id_b,\r\n(ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');\r\nelse {\r\nconst char *speed;\r\nconst char *type;\r\nspeed = "";\r\nif ((ahc->features & AHC_ULTRA) != 0) {\r\nspeed = "Ultra ";\r\n} else if ((ahc->features & AHC_DT) != 0) {\r\nspeed = "Ultra160 ";\r\n} else if ((ahc->features & AHC_ULTRA2) != 0) {\r\nspeed = "Ultra2 ";\r\n}\r\nif ((ahc->features & AHC_WIDE) != 0) {\r\ntype = "Wide";\r\n} else {\r\ntype = "Single";\r\n}\r\nlen = sprintf(buf, "%s%s Channel %c, SCSI Id=%d, ",\r\nspeed, type, ahc->channel, ahc->our_id);\r\n}\r\nbuf += len;\r\nif ((ahc->flags & AHC_PAGESCBS) != 0)\r\nsprintf(buf, "%d/%d SCBs",\r\nahc->scb_data->maxhscbs, AHC_MAX_QUEUE);\r\nelse\r\nsprintf(buf, "%d SCBs", ahc->scb_data->maxhscbs);\r\n}\r\nint\r\nahc_chip_init(struct ahc_softc *ahc)\r\n{\r\nint term;\r\nint error;\r\nu_int i;\r\nu_int scsi_conf;\r\nu_int scsiseq_template;\r\nuint32_t physaddr;\r\nahc_outb(ahc, SEQ_FLAGS, 0);\r\nahc_outb(ahc, SEQ_FLAGS2, 0);\r\nif (ahc->features & AHC_TWIN) {\r\nahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);\r\nterm = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;\r\nahc_outb(ahc, SCSIID, ahc->our_id_b);\r\nscsi_conf = ahc_inb(ahc, SCSICONF + 1);\r\nahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\r\n|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);\r\nahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\r\nahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\r\nahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);\r\n}\r\nterm = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);\r\nelse\r\nahc_outb(ahc, SCSIID, ahc->our_id);\r\nscsi_conf = ahc_inb(ahc, SCSICONF);\r\nahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))\r\n|term|ahc->seltime\r\n|ENSTIMER|ACTNEGEN);\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);\r\nahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);\r\nahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);\r\nfor (i = 0; i < 16; i++) {\r\nahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));\r\nif ((ahc->flags & AHC_SCB_BTT) != 0) {\r\nint lun;\r\nfor (lun = 1; lun < AHC_NUM_LUNS; lun++)\r\nahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));\r\n}\r\n}\r\nfor (i = 0; i < 256; i++)\r\nahc->qoutfifo[i] = SCB_LIST_NULL;\r\nahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);\r\nfor (i = 0; i < 256; i++)\r\nahc->qinfifo[i] = SCB_LIST_NULL;\r\nif ((ahc->features & AHC_MULTI_TID) != 0) {\r\nahc_outb(ahc, TARGID, 0);\r\nahc_outb(ahc, TARGID + 1, 0);\r\n}\r\nphysaddr = ahc->scb_data->hscb_busaddr;\r\nahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);\r\nahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);\r\nahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);\r\nahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);\r\nphysaddr = ahc->shared_data_busaddr;\r\nahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);\r\nahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);\r\nahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);\r\nahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);\r\nahc_outb(ahc, CMDSIZE_TABLE, 5);\r\nahc_outb(ahc, CMDSIZE_TABLE + 1, 9);\r\nahc_outb(ahc, CMDSIZE_TABLE + 2, 9);\r\nahc_outb(ahc, CMDSIZE_TABLE + 3, 0);\r\nahc_outb(ahc, CMDSIZE_TABLE + 4, 15);\r\nahc_outb(ahc, CMDSIZE_TABLE + 5, 11);\r\nahc_outb(ahc, CMDSIZE_TABLE + 6, 0);\r\nahc_outb(ahc, CMDSIZE_TABLE + 7, 0);\r\nif ((ahc->features & AHC_HS_MAILBOX) != 0)\r\nahc_outb(ahc, HS_MAILBOX, 0);\r\nif ((ahc->features & AHC_TARGETMODE) != 0) {\r\nahc->tqinfifonext = 1;\r\nahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);\r\nahc_outb(ahc, TQINPOS, ahc->tqinfifonext);\r\n}\r\nahc->qinfifonext = 0;\r\nahc->qoutfifonext = 0;\r\nif ((ahc->features & AHC_QUEUE_REGS) != 0) {\r\nahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);\r\nahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\r\nahc_outb(ahc, SNSCB_QOFF, ahc->qinfifonext);\r\nahc_outb(ahc, SDSCB_QOFF, 0);\r\n} else {\r\nahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\r\nahc_outb(ahc, QINPOS, ahc->qinfifonext);\r\nahc_outb(ahc, QOUTPOS, ahc->qoutfifonext);\r\n}\r\nahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);\r\nahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);\r\nahc_outb(ahc, MSG_OUT, MSG_NOOP);\r\nscsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;\r\nif ((ahc->flags & AHC_INITIATORROLE) != 0)\r\nscsiseq_template |= ENRSELI;\r\nahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);\r\nahc_build_free_scb_list(ahc);\r\nahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);\r\nif (bootverbose)\r\nprintk("%s: Downloading Sequencer Program...",\r\nahc_name(ahc));\r\nerror = ahc_loadseq(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nint wait;\r\nfor (wait = 5000;\r\n(ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;\r\nwait--)\r\nahc_delay(100);\r\n}\r\nahc_restart(ahc);\r\nreturn (0);\r\n}\r\nint\r\nahc_init(struct ahc_softc *ahc)\r\n{\r\nint max_targ;\r\nu_int i;\r\nu_int scsi_conf;\r\nu_int ultraenb;\r\nu_int discenable;\r\nu_int tagenable;\r\nsize_t driver_data_size;\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_DEBUG_SEQUENCER) != 0)\r\nahc->flags |= AHC_SEQUENCER_DEBUG;\r\n#endif\r\n#ifdef AHC_PRINT_SRAM\r\nprintk("Scratch Ram:");\r\nfor (i = 0x20; i < 0x5f; i++) {\r\nif (((i % 8) == 0) && (i != 0)) {\r\nprintk ("\n ");\r\n}\r\nprintk (" 0x%x", ahc_inb(ahc, i));\r\n}\r\nif ((ahc->features & AHC_MORE_SRAM) != 0) {\r\nfor (i = 0x70; i < 0x7f; i++) {\r\nif (((i % 8) == 0) && (i != 0)) {\r\nprintk ("\n ");\r\n}\r\nprintk (" 0x%x", ahc_inb(ahc, i));\r\n}\r\n}\r\nprintk ("\n");\r\nahc_outb(ahc, CLRINT, CLRPARERR);\r\nahc_outb(ahc, CLRINT, CLRBRKADRINT);\r\n#endif\r\nmax_targ = 15;\r\nif ((ahc->flags & AHC_USEDEFAULTS) != 0)\r\nahc->our_id = ahc->our_id_b = 7;\r\nahc->flags |= AHC_INITIATORROLE;\r\nif ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)\r\nahc->features &= ~AHC_TARGETMODE;\r\n#ifndef __linux__\r\nif (ahc_dma_tag_create(ahc, ahc->parent_dmat, 1,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nahc->flags & AHC_39BIT_ADDRESSING\r\n? (dma_addr_t)0x7FFFFFFFFFULL\r\n: BUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\n(AHC_NSEG - 1) * PAGE_SIZE,\r\nAHC_NSEG,\r\nAHC_MAXTRANSFER_SIZE,\r\nBUS_DMA_ALLOCNOW,\r\n&ahc->buffer_dmat) != 0) {\r\nreturn (ENOMEM);\r\n}\r\n#endif\r\nahc->init_level++;\r\ndriver_data_size = 2 * 256 * sizeof(uint8_t);\r\nif ((ahc->features & AHC_TARGETMODE) != 0)\r\ndriver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)\r\n+ 1;\r\nif (ahc_dma_tag_create(ahc, ahc->parent_dmat, 1,\r\nBUS_SPACE_MAXADDR_32BIT + 1,\r\nBUS_SPACE_MAXADDR_32BIT,\r\nBUS_SPACE_MAXADDR,\r\nNULL, NULL,\r\ndriver_data_size,\r\n1,\r\nBUS_SPACE_MAXSIZE_32BIT,\r\n0, &ahc->shared_data_dmat) != 0) {\r\nreturn (ENOMEM);\r\n}\r\nahc->init_level++;\r\nif (ahc_dmamem_alloc(ahc, ahc->shared_data_dmat,\r\n(void **)&ahc->qoutfifo,\r\nBUS_DMA_NOWAIT, &ahc->shared_data_dmamap) != 0) {\r\nreturn (ENOMEM);\r\n}\r\nahc->init_level++;\r\nahc_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,\r\nahc->qoutfifo, driver_data_size, ahc_dmamap_cb,\r\n&ahc->shared_data_busaddr, 0);\r\nif ((ahc->features & AHC_TARGETMODE) != 0) {\r\nahc->targetcmds = (struct target_cmd *)ahc->qoutfifo;\r\nahc->qoutfifo = (uint8_t *)&ahc->targetcmds[AHC_TMODE_CMDS];\r\nahc->dma_bug_buf = ahc->shared_data_busaddr\r\n+ driver_data_size - 1;\r\nfor (i = 0; i < AHC_TMODE_CMDS; i++)\r\nahc->targetcmds[i].cmd_valid = 0;\r\nahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);\r\nahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];\r\n}\r\nahc->qinfifo = &ahc->qoutfifo[256];\r\nahc->init_level++;\r\nif (ahc->scb_data->maxhscbs == 0)\r\nif (ahc_init_scbdata(ahc) != 0)\r\nreturn (ENOMEM);\r\nif (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {\r\nprintk("%s: unable to allocate ahc_tmode_tstate. "\r\n"Failing attach\n", ahc_name(ahc));\r\nreturn (ENOMEM);\r\n}\r\nif ((ahc->features & AHC_TWIN) != 0) {\r\nif (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {\r\nprintk("%s: unable to allocate ahc_tmode_tstate. "\r\n"Failing attach\n", ahc_name(ahc));\r\nreturn (ENOMEM);\r\n}\r\n}\r\nif (ahc->scb_data->maxhscbs < AHC_SCB_MAX_ALLOC) {\r\nahc->flags |= AHC_PAGESCBS;\r\n} else {\r\nahc->flags &= ~AHC_PAGESCBS;\r\n}\r\n#ifdef AHC_DEBUG\r\nif (ahc_debug & AHC_SHOW_MISC) {\r\nprintk("%s: hardware scb %u bytes; kernel scb %u bytes; "\r\n"ahc_dma %u bytes\n",\r\nahc_name(ahc),\r\n(u_int)sizeof(struct hardware_scb),\r\n(u_int)sizeof(struct scb),\r\n(u_int)sizeof(struct ahc_dma_seg));\r\n}\r\n#endif\r\nif (ahc->features & AHC_TWIN) {\r\nscsi_conf = ahc_inb(ahc, SCSICONF + 1);\r\nif ((scsi_conf & RESET_SCSI) != 0\r\n&& (ahc->flags & AHC_INITIATORROLE) != 0)\r\nahc->flags |= AHC_RESET_BUS_B;\r\n}\r\nscsi_conf = ahc_inb(ahc, SCSICONF);\r\nif ((scsi_conf & RESET_SCSI) != 0\r\n&& (ahc->flags & AHC_INITIATORROLE) != 0)\r\nahc->flags |= AHC_RESET_BUS_A;\r\nultraenb = 0;\r\ntagenable = ALL_TARGETS_MASK;\r\nif ((ahc->flags & AHC_USEDEFAULTS) != 0) {\r\nprintk("%s: Host Adapter Bios disabled. Using default SCSI "\r\n"device parameters\n", ahc_name(ahc));\r\nahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|\r\nAHC_TERM_ENB_A|AHC_TERM_ENB_B;\r\ndiscenable = ALL_TARGETS_MASK;\r\nif ((ahc->features & AHC_ULTRA) != 0)\r\nultraenb = ALL_TARGETS_MASK;\r\n} else {\r\ndiscenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)\r\n| ahc_inb(ahc, DISC_DSB));\r\nif ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)\r\nultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)\r\n| ahc_inb(ahc, ULTRA_ENB);\r\n}\r\nif ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)\r\nmax_targ = 7;\r\nfor (i = 0; i <= max_targ; i++) {\r\nstruct ahc_initiator_tinfo *tinfo;\r\nstruct ahc_tmode_tstate *tstate;\r\nu_int our_id;\r\nu_int target_id;\r\nchar channel;\r\nchannel = 'A';\r\nour_id = ahc->our_id;\r\ntarget_id = i;\r\nif (i > 7 && (ahc->features & AHC_TWIN) != 0) {\r\nchannel = 'B';\r\nour_id = ahc->our_id_b;\r\ntarget_id = i % 8;\r\n}\r\ntinfo = ahc_fetch_transinfo(ahc, channel, our_id,\r\ntarget_id, &tstate);\r\nmemset(tinfo, 0, sizeof(*tinfo));\r\nif (ahc->flags & AHC_USEDEFAULTS) {\r\nif ((ahc->features & AHC_WIDE) != 0)\r\ntinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\r\ntinfo->user.period = ahc_syncrates->period;\r\ntinfo->user.offset = MAX_OFFSET;\r\n} else {\r\nu_int scsirate;\r\nuint16_t mask;\r\nscsirate = ahc_inb(ahc, TARG_SCSIRATE + i);\r\nmask = (0x01 << i);\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nu_int offset;\r\nu_int maxsync;\r\nif ((scsirate & SOFS) == 0x0F) {\r\nscsirate = (scsirate & SXFR) >> 4\r\n| (ultraenb & mask)\r\n? 0x08 : 0x0\r\n| (scsirate & WIDEXFER);\r\noffset = MAX_OFFSET_ULTRA2;\r\n} else\r\noffset = ahc_inb(ahc, TARG_OFFSET + i);\r\nif ((scsirate & ~WIDEXFER) == 0 && offset != 0)\r\nscsirate |= 0x1c;\r\nmaxsync = AHC_SYNCRATE_ULTRA2;\r\nif ((ahc->features & AHC_DT) != 0)\r\nmaxsync = AHC_SYNCRATE_DT;\r\ntinfo->user.period =\r\nahc_find_period(ahc, scsirate, maxsync);\r\nif (offset == 0)\r\ntinfo->user.period = 0;\r\nelse\r\ntinfo->user.offset = MAX_OFFSET;\r\nif ((scsirate & SXFR_ULTRA2) <= 8\r\n&& (ahc->features & AHC_DT) != 0)\r\ntinfo->user.ppr_options =\r\nMSG_EXT_PPR_DT_REQ;\r\n} else if ((scsirate & SOFS) != 0) {\r\nif ((scsirate & SXFR) == 0x40\r\n&& (ultraenb & mask) != 0) {\r\nscsirate &= ~SXFR;\r\nultraenb &= ~mask;\r\n}\r\ntinfo->user.period =\r\nahc_find_period(ahc, scsirate,\r\n(ultraenb & mask)\r\n? AHC_SYNCRATE_ULTRA\r\n: AHC_SYNCRATE_FAST);\r\nif (tinfo->user.period != 0)\r\ntinfo->user.offset = MAX_OFFSET;\r\n}\r\nif (tinfo->user.period == 0)\r\ntinfo->user.offset = 0;\r\nif ((scsirate & WIDEXFER) != 0\r\n&& (ahc->features & AHC_WIDE) != 0)\r\ntinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;\r\ntinfo->user.protocol_version = 4;\r\nif ((ahc->features & AHC_DT) != 0)\r\ntinfo->user.transport_version = 3;\r\nelse\r\ntinfo->user.transport_version = 2;\r\ntinfo->goal.protocol_version = 2;\r\ntinfo->goal.transport_version = 2;\r\ntinfo->curr.protocol_version = 2;\r\ntinfo->curr.transport_version = 2;\r\n}\r\ntstate->ultraenb = 0;\r\n}\r\nahc->user_discenable = discenable;\r\nahc->user_tagenable = tagenable;\r\nreturn (ahc->bus_chip_init(ahc));\r\n}\r\nvoid\r\nahc_intr_enable(struct ahc_softc *ahc, int enable)\r\n{\r\nu_int hcntrl;\r\nhcntrl = ahc_inb(ahc, HCNTRL);\r\nhcntrl &= ~INTEN;\r\nahc->pause &= ~INTEN;\r\nahc->unpause &= ~INTEN;\r\nif (enable) {\r\nhcntrl |= INTEN;\r\nahc->pause |= INTEN;\r\nahc->unpause |= INTEN;\r\n}\r\nahc_outb(ahc, HCNTRL, hcntrl);\r\n}\r\nvoid\r\nahc_pause_and_flushwork(struct ahc_softc *ahc)\r\n{\r\nint intstat;\r\nint maxloops;\r\nint paused;\r\nmaxloops = 1000;\r\nahc->flags |= AHC_ALL_INTERRUPTS;\r\npaused = FALSE;\r\ndo {\r\nif (paused) {\r\nahc_unpause(ahc);\r\nahc_delay(500);\r\n}\r\nahc_intr(ahc);\r\nahc_pause(ahc);\r\npaused = TRUE;\r\nahc_outb(ahc, SCSISEQ, ahc_inb(ahc, SCSISEQ) & ~ENSELO);\r\nintstat = ahc_inb(ahc, INTSTAT);\r\nif ((intstat & INT_PEND) == 0) {\r\nahc_clear_critical_section(ahc);\r\nintstat = ahc_inb(ahc, INTSTAT);\r\n}\r\n} while (--maxloops\r\n&& (intstat != 0xFF || (ahc->features & AHC_REMOVABLE) == 0)\r\n&& ((intstat & INT_PEND) != 0\r\n|| (ahc_inb(ahc, SSTAT0) & (SELDO|SELINGO)) != 0));\r\nif (maxloops == 0) {\r\nprintk("Infinite interrupt loop, INTSTAT = %x",\r\nahc_inb(ahc, INTSTAT));\r\n}\r\nahc_platform_flushwork(ahc);\r\nahc->flags &= ~AHC_ALL_INTERRUPTS;\r\n}\r\nint\r\nahc_suspend(struct ahc_softc *ahc)\r\n{\r\nahc_pause_and_flushwork(ahc);\r\nif (LIST_FIRST(&ahc->pending_scbs) != NULL) {\r\nahc_unpause(ahc);\r\nreturn (EBUSY);\r\n}\r\n#ifdef AHC_TARGET_MODE\r\nif (ahc->pending_device != NULL) {\r\nahc_unpause(ahc);\r\nreturn (EBUSY);\r\n}\r\n#endif\r\nahc_shutdown(ahc);\r\nreturn (0);\r\n}\r\nint\r\nahc_resume(struct ahc_softc *ahc)\r\n{\r\nahc_reset(ahc, TRUE);\r\nahc_intr_enable(ahc, TRUE);\r\nahc_restart(ahc);\r\nreturn (0);\r\n}\r\nstatic u_int\r\nahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl)\r\n{\r\nu_int scbid;\r\nu_int target_offset;\r\nif ((ahc->flags & AHC_SCB_BTT) != 0) {\r\nu_int saved_scbptr;\r\nsaved_scbptr = ahc_inb(ahc, SCBPTR);\r\nahc_outb(ahc, SCBPTR, TCL_LUN(tcl));\r\nscbid = ahc_inb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl));\r\nahc_outb(ahc, SCBPTR, saved_scbptr);\r\n} else {\r\ntarget_offset = TCL_TARGET_OFFSET(tcl);\r\nscbid = ahc_inb(ahc, BUSY_TARGETS + target_offset);\r\n}\r\nreturn (scbid);\r\n}\r\nstatic void\r\nahc_unbusy_tcl(struct ahc_softc *ahc, u_int tcl)\r\n{\r\nu_int target_offset;\r\nif ((ahc->flags & AHC_SCB_BTT) != 0) {\r\nu_int saved_scbptr;\r\nsaved_scbptr = ahc_inb(ahc, SCBPTR);\r\nahc_outb(ahc, SCBPTR, TCL_LUN(tcl));\r\nahc_outb(ahc, SCB_64_BTT+TCL_TARGET_OFFSET(tcl), SCB_LIST_NULL);\r\nahc_outb(ahc, SCBPTR, saved_scbptr);\r\n} else {\r\ntarget_offset = TCL_TARGET_OFFSET(tcl);\r\nahc_outb(ahc, BUSY_TARGETS + target_offset, SCB_LIST_NULL);\r\n}\r\n}\r\nstatic void\r\nahc_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int scbid)\r\n{\r\nu_int target_offset;\r\nif ((ahc->flags & AHC_SCB_BTT) != 0) {\r\nu_int saved_scbptr;\r\nsaved_scbptr = ahc_inb(ahc, SCBPTR);\r\nahc_outb(ahc, SCBPTR, TCL_LUN(tcl));\r\nahc_outb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl), scbid);\r\nahc_outb(ahc, SCBPTR, saved_scbptr);\r\n} else {\r\ntarget_offset = TCL_TARGET_OFFSET(tcl);\r\nahc_outb(ahc, BUSY_TARGETS + target_offset, scbid);\r\n}\r\n}\r\nint\r\nahc_match_scb(struct ahc_softc *ahc, struct scb *scb, int target,\r\nchar channel, int lun, u_int tag, role_t role)\r\n{\r\nint targ = SCB_GET_TARGET(ahc, scb);\r\nchar chan = SCB_GET_CHANNEL(ahc, scb);\r\nint slun = SCB_GET_LUN(scb);\r\nint match;\r\nmatch = ((chan == channel) || (channel == ALL_CHANNELS));\r\nif (match != 0)\r\nmatch = ((targ == target) || (target == CAM_TARGET_WILDCARD));\r\nif (match != 0)\r\nmatch = ((lun == slun) || (lun == CAM_LUN_WILDCARD));\r\nif (match != 0) {\r\n#ifdef AHC_TARGET_MODE\r\nint group;\r\ngroup = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);\r\nif (role == ROLE_INITIATOR) {\r\nmatch = (group != XPT_FC_GROUP_TMODE)\r\n&& ((tag == scb->hscb->tag)\r\n|| (tag == SCB_LIST_NULL));\r\n} else if (role == ROLE_TARGET) {\r\nmatch = (group == XPT_FC_GROUP_TMODE)\r\n&& ((tag == scb->io_ctx->csio.tag_id)\r\n|| (tag == SCB_LIST_NULL));\r\n}\r\n#else\r\nmatch = ((tag == scb->hscb->tag) || (tag == SCB_LIST_NULL));\r\n#endif\r\n}\r\nreturn match;\r\n}\r\nstatic void\r\nahc_freeze_devq(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nint target;\r\nchar channel;\r\nint lun;\r\ntarget = SCB_GET_TARGET(ahc, scb);\r\nlun = SCB_GET_LUN(scb);\r\nchannel = SCB_GET_CHANNEL(ahc, scb);\r\nahc_search_qinfifo(ahc, target, channel, lun,\r\nSCB_LIST_NULL, ROLE_UNKNOWN,\r\nCAM_REQUEUE_REQ, SEARCH_COMPLETE);\r\nahc_platform_freeze_devq(ahc, scb);\r\n}\r\nvoid\r\nahc_qinfifo_requeue_tail(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nstruct scb *prev_scb;\r\nprev_scb = NULL;\r\nif (ahc_qinfifo_count(ahc) != 0) {\r\nu_int prev_tag;\r\nuint8_t prev_pos;\r\nprev_pos = ahc->qinfifonext - 1;\r\nprev_tag = ahc->qinfifo[prev_pos];\r\nprev_scb = ahc_lookup_scb(ahc, prev_tag);\r\n}\r\nahc_qinfifo_requeue(ahc, prev_scb, scb);\r\nif ((ahc->features & AHC_QUEUE_REGS) != 0) {\r\nahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\r\n} else {\r\nahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\r\n}\r\n}\r\nstatic void\r\nahc_qinfifo_requeue(struct ahc_softc *ahc, struct scb *prev_scb,\r\nstruct scb *scb)\r\n{\r\nif (prev_scb == NULL) {\r\nahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);\r\n} else {\r\nprev_scb->hscb->next = scb->hscb->tag;\r\nahc_sync_scb(ahc, prev_scb,\r\nBUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\r\n}\r\nahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;\r\nscb->hscb->next = ahc->next_queued_scb->hscb->tag;\r\nahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);\r\n}\r\nstatic int\r\nahc_qinfifo_count(struct ahc_softc *ahc)\r\n{\r\nuint8_t qinpos;\r\nuint8_t diff;\r\nif ((ahc->features & AHC_QUEUE_REGS) != 0) {\r\nqinpos = ahc_inb(ahc, SNSCB_QOFF);\r\nahc_outb(ahc, SNSCB_QOFF, qinpos);\r\n} else\r\nqinpos = ahc_inb(ahc, QINPOS);\r\ndiff = ahc->qinfifonext - qinpos;\r\nreturn (diff);\r\n}\r\nint\r\nahc_search_qinfifo(struct ahc_softc *ahc, int target, char channel,\r\nint lun, u_int tag, role_t role, uint32_t status,\r\nahc_search_action action)\r\n{\r\nstruct scb *scb;\r\nstruct scb *prev_scb;\r\nuint8_t qinstart;\r\nuint8_t qinpos;\r\nuint8_t qintail;\r\nuint8_t next;\r\nuint8_t prev;\r\nuint8_t curscbptr;\r\nint found;\r\nint have_qregs;\r\nqintail = ahc->qinfifonext;\r\nhave_qregs = (ahc->features & AHC_QUEUE_REGS) != 0;\r\nif (have_qregs) {\r\nqinstart = ahc_inb(ahc, SNSCB_QOFF);\r\nahc_outb(ahc, SNSCB_QOFF, qinstart);\r\n} else\r\nqinstart = ahc_inb(ahc, QINPOS);\r\nqinpos = qinstart;\r\nfound = 0;\r\nprev_scb = NULL;\r\nif (action == SEARCH_COMPLETE) {\r\nahc_freeze_untagged_queues(ahc);\r\n}\r\nahc->qinfifonext = qinpos;\r\nahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);\r\nwhile (qinpos != qintail) {\r\nscb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);\r\nif (scb == NULL) {\r\nprintk("qinpos = %d, SCB index = %d\n",\r\nqinpos, ahc->qinfifo[qinpos]);\r\npanic("Loop 1\n");\r\n}\r\nif (ahc_match_scb(ahc, scb, target, channel, lun, tag, role)) {\r\nfound++;\r\nswitch (action) {\r\ncase SEARCH_COMPLETE:\r\n{\r\ncam_status ostat;\r\ncam_status cstat;\r\nostat = ahc_get_transaction_status(scb);\r\nif (ostat == CAM_REQ_INPROG)\r\nahc_set_transaction_status(scb, status);\r\ncstat = ahc_get_transaction_status(scb);\r\nif (cstat != CAM_REQ_CMP)\r\nahc_freeze_scb(scb);\r\nif ((scb->flags & SCB_ACTIVE) == 0)\r\nprintk("Inactive SCB in qinfifo\n");\r\nahc_done(ahc, scb);\r\n}\r\ncase SEARCH_REMOVE:\r\nbreak;\r\ncase SEARCH_COUNT:\r\nahc_qinfifo_requeue(ahc, prev_scb, scb);\r\nprev_scb = scb;\r\nbreak;\r\n}\r\n} else {\r\nahc_qinfifo_requeue(ahc, prev_scb, scb);\r\nprev_scb = scb;\r\n}\r\nqinpos++;\r\n}\r\nif ((ahc->features & AHC_QUEUE_REGS) != 0) {\r\nahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);\r\n} else {\r\nahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);\r\n}\r\nif (action != SEARCH_COUNT\r\n&& (found != 0)\r\n&& (qinstart != ahc->qinfifonext)) {\r\nscb = ahc_lookup_scb(ahc, ahc->qinfifo[qinstart]);\r\nif (scb == NULL) {\r\nprintk("found = %d, qinstart = %d, qinfifionext = %d\n",\r\nfound, qinstart, ahc->qinfifonext);\r\npanic("First/Second Qinfifo fixup\n");\r\n}\r\nnext = scb->hscb->next;\r\nahc->scb_data->scbindex[scb->hscb->tag] = NULL;\r\nahc_swap_with_next_hscb(ahc, scb);\r\nscb->hscb->next = next;\r\nahc->qinfifo[qinstart] = scb->hscb->tag;\r\nahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);\r\nqintail = ahc->qinfifonext - 1;\r\nscb = ahc_lookup_scb(ahc, ahc->qinfifo[qintail]);\r\nscb->hscb->next = ahc->next_queued_scb->hscb->tag;\r\n}\r\ncurscbptr = ahc_inb(ahc, SCBPTR);\r\nnext = ahc_inb(ahc, WAITING_SCBH);\r\nprev = SCB_LIST_NULL;\r\nwhile (next != SCB_LIST_NULL) {\r\nuint8_t scb_index;\r\nahc_outb(ahc, SCBPTR, next);\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nif (scb_index >= ahc->scb_data->numscbs) {\r\nprintk("Waiting List inconsistency. "\r\n"SCB index == %d, yet numscbs == %d.",\r\nscb_index, ahc->scb_data->numscbs);\r\nahc_dump_card_state(ahc);\r\npanic("for safety");\r\n}\r\nscb = ahc_lookup_scb(ahc, scb_index);\r\nif (scb == NULL) {\r\nprintk("scb_index = %d, next = %d\n",\r\nscb_index, next);\r\npanic("Waiting List traversal\n");\r\n}\r\nif (ahc_match_scb(ahc, scb, target, channel,\r\nlun, SCB_LIST_NULL, role)) {\r\nfound++;\r\nswitch (action) {\r\ncase SEARCH_COMPLETE:\r\n{\r\ncam_status ostat;\r\ncam_status cstat;\r\nostat = ahc_get_transaction_status(scb);\r\nif (ostat == CAM_REQ_INPROG)\r\nahc_set_transaction_status(scb,\r\nstatus);\r\ncstat = ahc_get_transaction_status(scb);\r\nif (cstat != CAM_REQ_CMP)\r\nahc_freeze_scb(scb);\r\nif ((scb->flags & SCB_ACTIVE) == 0)\r\nprintk("Inactive SCB in Waiting List\n");\r\nahc_done(ahc, scb);\r\n}\r\ncase SEARCH_REMOVE:\r\nnext = ahc_rem_wscb(ahc, next, prev);\r\nbreak;\r\ncase SEARCH_COUNT:\r\nprev = next;\r\nnext = ahc_inb(ahc, SCB_NEXT);\r\nbreak;\r\n}\r\n} else {\r\nprev = next;\r\nnext = ahc_inb(ahc, SCB_NEXT);\r\n}\r\n}\r\nahc_outb(ahc, SCBPTR, curscbptr);\r\nfound += ahc_search_untagged_queues(ahc, NULL, target,\r\nchannel, lun, status, action);\r\nif (action == SEARCH_COMPLETE)\r\nahc_release_untagged_queues(ahc);\r\nreturn (found);\r\n}\r\nint\r\nahc_search_untagged_queues(struct ahc_softc *ahc, ahc_io_ctx_t ctx,\r\nint target, char channel, int lun, uint32_t status,\r\nahc_search_action action)\r\n{\r\nstruct scb *scb;\r\nint maxtarget;\r\nint found;\r\nint i;\r\nif (action == SEARCH_COMPLETE) {\r\nahc_freeze_untagged_queues(ahc);\r\n}\r\nfound = 0;\r\ni = 0;\r\nif ((ahc->flags & AHC_SCB_BTT) == 0) {\r\nmaxtarget = 16;\r\nif (target != CAM_TARGET_WILDCARD) {\r\ni = target;\r\nif (channel == 'B')\r\ni += 8;\r\nmaxtarget = i + 1;\r\n}\r\n} else {\r\nmaxtarget = 0;\r\n}\r\nfor (; i < maxtarget; i++) {\r\nstruct scb_tailq *untagged_q;\r\nstruct scb *next_scb;\r\nuntagged_q = &(ahc->untagged_queues[i]);\r\nnext_scb = TAILQ_FIRST(untagged_q);\r\nwhile (next_scb != NULL) {\r\nscb = next_scb;\r\nnext_scb = TAILQ_NEXT(scb, links.tqe);\r\nif ((scb->flags & SCB_ACTIVE) != 0)\r\ncontinue;\r\nif (ahc_match_scb(ahc, scb, target, channel, lun,\r\nSCB_LIST_NULL, ROLE_INITIATOR) == 0\r\n|| (ctx != NULL && ctx != scb->io_ctx))\r\ncontinue;\r\nfound++;\r\nswitch (action) {\r\ncase SEARCH_COMPLETE:\r\n{\r\ncam_status ostat;\r\ncam_status cstat;\r\nostat = ahc_get_transaction_status(scb);\r\nif (ostat == CAM_REQ_INPROG)\r\nahc_set_transaction_status(scb, status);\r\ncstat = ahc_get_transaction_status(scb);\r\nif (cstat != CAM_REQ_CMP)\r\nahc_freeze_scb(scb);\r\nif ((scb->flags & SCB_ACTIVE) == 0)\r\nprintk("Inactive SCB in untaggedQ\n");\r\nahc_done(ahc, scb);\r\nbreak;\r\n}\r\ncase SEARCH_REMOVE:\r\nscb->flags &= ~SCB_UNTAGGEDQ;\r\nTAILQ_REMOVE(untagged_q, scb, links.tqe);\r\nbreak;\r\ncase SEARCH_COUNT:\r\nbreak;\r\n}\r\n}\r\n}\r\nif (action == SEARCH_COMPLETE)\r\nahc_release_untagged_queues(ahc);\r\nreturn (found);\r\n}\r\nint\r\nahc_search_disc_list(struct ahc_softc *ahc, int target, char channel,\r\nint lun, u_int tag, int stop_on_first, int remove,\r\nint save_state)\r\n{\r\nstruct scb *scbp;\r\nu_int next;\r\nu_int prev;\r\nu_int count;\r\nu_int active_scb;\r\ncount = 0;\r\nnext = ahc_inb(ahc, DISCONNECTED_SCBH);\r\nprev = SCB_LIST_NULL;\r\nif (save_state) {\r\nactive_scb = ahc_inb(ahc, SCBPTR);\r\n} else\r\nactive_scb = SCB_LIST_NULL;\r\nwhile (next != SCB_LIST_NULL) {\r\nu_int scb_index;\r\nahc_outb(ahc, SCBPTR, next);\r\nscb_index = ahc_inb(ahc, SCB_TAG);\r\nif (scb_index >= ahc->scb_data->numscbs) {\r\nprintk("Disconnected List inconsistency. "\r\n"SCB index == %d, yet numscbs == %d.",\r\nscb_index, ahc->scb_data->numscbs);\r\nahc_dump_card_state(ahc);\r\npanic("for safety");\r\n}\r\nif (next == prev) {\r\npanic("Disconnected List Loop. "\r\n"cur SCBPTR == %x, prev SCBPTR == %x.",\r\nnext, prev);\r\n}\r\nscbp = ahc_lookup_scb(ahc, scb_index);\r\nif (ahc_match_scb(ahc, scbp, target, channel, lun,\r\ntag, ROLE_INITIATOR)) {\r\ncount++;\r\nif (remove) {\r\nnext =\r\nahc_rem_scb_from_disc_list(ahc, prev, next);\r\n} else {\r\nprev = next;\r\nnext = ahc_inb(ahc, SCB_NEXT);\r\n}\r\nif (stop_on_first)\r\nbreak;\r\n} else {\r\nprev = next;\r\nnext = ahc_inb(ahc, SCB_NEXT);\r\n}\r\n}\r\nif (save_state)\r\nahc_outb(ahc, SCBPTR, active_scb);\r\nreturn (count);\r\n}\r\nstatic u_int\r\nahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev, u_int scbptr)\r\n{\r\nu_int next;\r\nahc_outb(ahc, SCBPTR, scbptr);\r\nnext = ahc_inb(ahc, SCB_NEXT);\r\nahc_outb(ahc, SCB_CONTROL, 0);\r\nahc_add_curscb_to_free_list(ahc);\r\nif (prev != SCB_LIST_NULL) {\r\nahc_outb(ahc, SCBPTR, prev);\r\nahc_outb(ahc, SCB_NEXT, next);\r\n} else\r\nahc_outb(ahc, DISCONNECTED_SCBH, next);\r\nreturn (next);\r\n}\r\nstatic void\r\nahc_add_curscb_to_free_list(struct ahc_softc *ahc)\r\n{\r\nahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);\r\nif ((ahc->flags & AHC_PAGESCBS) != 0) {\r\nahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));\r\nahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));\r\n}\r\n}\r\nstatic u_int\r\nahc_rem_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev)\r\n{\r\nu_int curscb, next;\r\ncurscb = ahc_inb(ahc, SCBPTR);\r\nahc_outb(ahc, SCBPTR, scbpos);\r\nnext = ahc_inb(ahc, SCB_NEXT);\r\nahc_outb(ahc, SCB_CONTROL, 0);\r\nahc_add_curscb_to_free_list(ahc);\r\nif (prev == SCB_LIST_NULL) {\r\nahc_outb(ahc, WAITING_SCBH, next);\r\nahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));\r\n} else {\r\nahc_outb(ahc, SCBPTR, prev);\r\nahc_outb(ahc, SCB_NEXT, next);\r\n}\r\nahc_outb(ahc, SCBPTR, curscb);\r\nreturn next;\r\n}\r\nstatic int\r\nahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,\r\nint lun, u_int tag, role_t role, uint32_t status)\r\n{\r\nstruct scb *scbp;\r\nstruct scb *scbp_next;\r\nu_int active_scb;\r\nint i, j;\r\nint maxtarget;\r\nint minlun;\r\nint maxlun;\r\nint found;\r\nahc_freeze_untagged_queues(ahc);\r\nactive_scb = ahc_inb(ahc, SCBPTR);\r\nfound = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,\r\nrole, CAM_REQUEUE_REQ, SEARCH_COMPLETE);\r\ni = 0;\r\nmaxtarget = 16;\r\nif (target != CAM_TARGET_WILDCARD) {\r\ni = target;\r\nif (channel == 'B')\r\ni += 8;\r\nmaxtarget = i + 1;\r\n}\r\nif (lun == CAM_LUN_WILDCARD) {\r\nminlun = 0;\r\nmaxlun = 1;\r\nif ((ahc->flags & AHC_SCB_BTT) != 0)\r\nmaxlun = AHC_NUM_LUNS;\r\n} else {\r\nminlun = lun;\r\nmaxlun = lun + 1;\r\n}\r\nif (role != ROLE_TARGET) {\r\nfor (;i < maxtarget; i++) {\r\nfor (j = minlun;j < maxlun; j++) {\r\nu_int scbid;\r\nu_int tcl;\r\ntcl = BUILD_TCL(i << 4, j);\r\nscbid = ahc_index_busy_tcl(ahc, tcl);\r\nscbp = ahc_lookup_scb(ahc, scbid);\r\nif (scbp == NULL\r\n|| ahc_match_scb(ahc, scbp, target, channel,\r\nlun, tag, role) == 0)\r\ncontinue;\r\nahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));\r\n}\r\n}\r\nahc_search_disc_list(ahc, target, channel, lun, tag,\r\nFALSE, TRUE,\r\nFALSE);\r\n}\r\nfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\r\nu_int scbid;\r\nahc_outb(ahc, SCBPTR, i);\r\nscbid = ahc_inb(ahc, SCB_TAG);\r\nscbp = ahc_lookup_scb(ahc, scbid);\r\nif ((scbp == NULL && scbid != SCB_LIST_NULL)\r\n|| (scbp != NULL\r\n&& ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)))\r\nahc_add_curscb_to_free_list(ahc);\r\n}\r\nscbp_next = LIST_FIRST(&ahc->pending_scbs);\r\nwhile (scbp_next != NULL) {\r\nscbp = scbp_next;\r\nscbp_next = LIST_NEXT(scbp, pending_links);\r\nif (ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)) {\r\ncam_status ostat;\r\nostat = ahc_get_transaction_status(scbp);\r\nif (ostat == CAM_REQ_INPROG)\r\nahc_set_transaction_status(scbp, status);\r\nif (ahc_get_transaction_status(scbp) != CAM_REQ_CMP)\r\nahc_freeze_scb(scbp);\r\nif ((scbp->flags & SCB_ACTIVE) == 0)\r\nprintk("Inactive SCB on pending list\n");\r\nahc_done(ahc, scbp);\r\nfound++;\r\n}\r\n}\r\nahc_outb(ahc, SCBPTR, active_scb);\r\nahc_platform_abort_scbs(ahc, target, channel, lun, tag, role, status);\r\nahc_release_untagged_queues(ahc);\r\nreturn found;\r\n}\r\nstatic void\r\nahc_reset_current_bus(struct ahc_softc *ahc)\r\n{\r\nuint8_t scsiseq;\r\nahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);\r\nscsiseq = ahc_inb(ahc, SCSISEQ);\r\nahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);\r\nahc_flush_device_writes(ahc);\r\nahc_delay(AHC_BUSRESET_DELAY);\r\nahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);\r\nahc_clear_intstat(ahc);\r\nahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);\r\n}\r\nint\r\nahc_reset_channel(struct ahc_softc *ahc, char channel, int initiate_reset)\r\n{\r\nstruct ahc_devinfo devinfo;\r\nu_int initiator, target, max_scsiid;\r\nu_int sblkctl;\r\nu_int scsiseq;\r\nu_int simode1;\r\nint found;\r\nint restart_needed;\r\nchar cur_channel;\r\nahc->pending_device = NULL;\r\nahc_compile_devinfo(&devinfo,\r\nCAM_TARGET_WILDCARD,\r\nCAM_TARGET_WILDCARD,\r\nCAM_LUN_WILDCARD,\r\nchannel, ROLE_UNKNOWN);\r\nahc_pause(ahc);\r\nahc_clear_critical_section(ahc);\r\nahc_run_qoutfifo(ahc);\r\n#ifdef AHC_TARGET_MODE\r\nif ((ahc->flags & AHC_TARGETROLE) != 0) {\r\nahc_run_tqinfifo(ahc, TRUE);\r\n}\r\n#endif\r\nsblkctl = ahc_inb(ahc, SBLKCTL);\r\ncur_channel = 'A';\r\nif ((ahc->features & AHC_TWIN) != 0\r\n&& ((sblkctl & SELBUSB) != 0))\r\ncur_channel = 'B';\r\nscsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);\r\nif (cur_channel != channel) {\r\nahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);\r\nsimode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);\r\n#ifdef AHC_TARGET_MODE\r\nif ((ahc->flags & AHC_TARGETROLE) != 0)\r\nsimode1 |= ENSCSIRST;\r\n#endif\r\nahc_outb(ahc, SIMODE1, simode1);\r\nif (initiate_reset)\r\nahc_reset_current_bus(ahc);\r\nahc_clear_intstat(ahc);\r\nahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));\r\nahc_outb(ahc, SBLKCTL, sblkctl);\r\nrestart_needed = FALSE;\r\n} else {\r\nsimode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);\r\n#ifdef AHC_TARGET_MODE\r\nif ((ahc->flags & AHC_TARGETROLE) != 0)\r\nsimode1 |= ENSCSIRST;\r\n#endif\r\nahc_outb(ahc, SIMODE1, simode1);\r\nif (initiate_reset)\r\nahc_reset_current_bus(ahc);\r\nahc_clear_intstat(ahc);\r\nahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));\r\nrestart_needed = TRUE;\r\n}\r\nfound = ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, channel,\r\nCAM_LUN_WILDCARD, SCB_LIST_NULL,\r\nROLE_UNKNOWN, CAM_SCSI_BUS_RESET);\r\nmax_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;\r\n#ifdef AHC_TARGET_MODE\r\nfor (target = 0; target <= max_scsiid; target++) {\r\nstruct ahc_tmode_tstate* tstate;\r\nu_int lun;\r\ntstate = ahc->enabled_targets[target];\r\nif (tstate == NULL)\r\ncontinue;\r\nfor (lun = 0; lun < AHC_NUM_LUNS; lun++) {\r\nstruct ahc_tmode_lstate* lstate;\r\nlstate = tstate->enabled_luns[lun];\r\nif (lstate == NULL)\r\ncontinue;\r\nahc_queue_lstate_event(ahc, lstate, CAM_TARGET_WILDCARD,\r\nEVENT_TYPE_BUS_RESET, 0);\r\nahc_send_lstate_events(ahc, lstate);\r\n}\r\n}\r\n#endif\r\nahc_send_async(ahc, devinfo.channel, CAM_TARGET_WILDCARD,\r\nCAM_LUN_WILDCARD, AC_BUS_RESET);\r\nfor (target = 0; target <= max_scsiid; target++) {\r\nif (ahc->enabled_targets[target] == NULL)\r\ncontinue;\r\nfor (initiator = 0; initiator <= max_scsiid; initiator++) {\r\nstruct ahc_devinfo devinfo;\r\nahc_compile_devinfo(&devinfo, target, initiator,\r\nCAM_LUN_WILDCARD,\r\nchannel, ROLE_UNKNOWN);\r\nahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHC_TRANS_CUR, TRUE);\r\nahc_set_syncrate(ahc, &devinfo, NULL,\r\n0, 0,\r\n0, AHC_TRANS_CUR,\r\nTRUE);\r\n}\r\n}\r\nif (restart_needed)\r\nahc_restart(ahc);\r\nelse\r\nahc_unpause(ahc);\r\nreturn found;\r\n}\r\nstatic void\r\nahc_calc_residual(struct ahc_softc *ahc, struct scb *scb)\r\n{\r\nstruct hardware_scb *hscb;\r\nstruct status_pkt *spkt;\r\nuint32_t sgptr;\r\nuint32_t resid_sgptr;\r\nuint32_t resid;\r\nhscb = scb->hscb;\r\nsgptr = ahc_le32toh(hscb->sgptr);\r\nif ((sgptr & SG_RESID_VALID) == 0)\r\nreturn;\r\nsgptr &= ~SG_RESID_VALID;\r\nif ((sgptr & SG_LIST_NULL) != 0)\r\nreturn;\r\nspkt = &hscb->shared_data.status;\r\nresid_sgptr = ahc_le32toh(spkt->residual_sg_ptr);\r\nif ((sgptr & SG_FULL_RESID) != 0) {\r\nresid = ahc_get_transfer_length(scb);\r\n} else if ((resid_sgptr & SG_LIST_NULL) != 0) {\r\nreturn;\r\n} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {\r\npanic("Bogus resid sgptr value 0x%x\n", resid_sgptr);\r\n} else {\r\nstruct ahc_dma_seg *sg;\r\nresid = ahc_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;\r\nsg = ahc_sg_bus_to_virt(scb, resid_sgptr & SG_PTR_MASK);\r\nsg--;\r\nwhile ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {\r\nsg++;\r\nresid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;\r\n}\r\n}\r\nif ((scb->flags & SCB_SENSE) == 0)\r\nahc_set_residual(scb, resid);\r\nelse\r\nahc_set_sense_residual(scb, resid);\r\n#ifdef AHC_DEBUG\r\nif ((ahc_debug & AHC_SHOW_MISC) != 0) {\r\nahc_print_path(ahc, scb);\r\nprintk("Handled %sResidual of %d bytes\n",\r\n(scb->flags & SCB_SENSE) ? "Sense " : "", resid);\r\n}\r\n#endif\r\n}\r\nstatic void\r\nahc_queue_lstate_event(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate,\r\nu_int initiator_id, u_int event_type, u_int event_arg)\r\n{\r\nstruct ahc_tmode_event *event;\r\nint pending;\r\nxpt_freeze_devq(lstate->path, 1);\r\nif (lstate->event_w_idx >= lstate->event_r_idx)\r\npending = lstate->event_w_idx - lstate->event_r_idx;\r\nelse\r\npending = AHC_TMODE_EVENT_BUFFER_SIZE + 1\r\n- (lstate->event_r_idx - lstate->event_w_idx);\r\nif (event_type == EVENT_TYPE_BUS_RESET\r\n|| event_type == MSG_BUS_DEV_RESET) {\r\nlstate->event_r_idx = 0;\r\nlstate->event_w_idx = 0;\r\nxpt_release_devq(lstate->path, pending, FALSE);\r\n}\r\nif (pending == AHC_TMODE_EVENT_BUFFER_SIZE) {\r\nxpt_print_path(lstate->path);\r\nprintk("immediate event %x:%x lost\n",\r\nlstate->event_buffer[lstate->event_r_idx].event_type,\r\nlstate->event_buffer[lstate->event_r_idx].event_arg);\r\nlstate->event_r_idx++;\r\nif (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)\r\nlstate->event_r_idx = 0;\r\nxpt_release_devq(lstate->path, 1, FALSE);\r\n}\r\nevent = &lstate->event_buffer[lstate->event_w_idx];\r\nevent->initiator_id = initiator_id;\r\nevent->event_type = event_type;\r\nevent->event_arg = event_arg;\r\nlstate->event_w_idx++;\r\nif (lstate->event_w_idx == AHC_TMODE_EVENT_BUFFER_SIZE)\r\nlstate->event_w_idx = 0;\r\n}\r\nvoid\r\nahc_send_lstate_events(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate)\r\n{\r\nstruct ccb_hdr *ccbh;\r\nstruct ccb_immed_notify *inot;\r\nwhile (lstate->event_r_idx != lstate->event_w_idx\r\n&& (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {\r\nstruct ahc_tmode_event *event;\r\nevent = &lstate->event_buffer[lstate->event_r_idx];\r\nSLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);\r\ninot = (struct ccb_immed_notify *)ccbh;\r\nswitch (event->event_type) {\r\ncase EVENT_TYPE_BUS_RESET:\r\nccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;\r\nbreak;\r\ndefault:\r\nccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;\r\ninot->message_args[0] = event->event_type;\r\ninot->message_args[1] = event->event_arg;\r\nbreak;\r\n}\r\ninot->initiator_id = event->initiator_id;\r\ninot->sense_len = 0;\r\nxpt_done((union ccb *)inot);\r\nlstate->event_r_idx++;\r\nif (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)\r\nlstate->event_r_idx = 0;\r\n}\r\n}\r\nvoid\r\nahc_dumpseq(struct ahc_softc* ahc)\r\n{\r\nint i;\r\nahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\r\nahc_outb(ahc, SEQADDR0, 0);\r\nahc_outb(ahc, SEQADDR1, 0);\r\nfor (i = 0; i < ahc->instruction_ram_size; i++) {\r\nuint8_t ins_bytes[4];\r\nahc_insb(ahc, SEQRAM, ins_bytes, 4);\r\nprintk("0x%08x\n", ins_bytes[0] << 24\r\n| ins_bytes[1] << 16\r\n| ins_bytes[2] << 8\r\n| ins_bytes[3]);\r\n}\r\n}\r\nstatic int\r\nahc_loadseq(struct ahc_softc *ahc)\r\n{\r\nstruct cs cs_table[num_critical_sections];\r\nu_int begin_set[num_critical_sections];\r\nu_int end_set[num_critical_sections];\r\nconst struct patch *cur_patch;\r\nu_int cs_count;\r\nu_int cur_cs;\r\nu_int i;\r\nu_int skip_addr;\r\nu_int sg_prefetch_cnt;\r\nint downloaded;\r\nuint8_t download_consts[7];\r\ncs_count = 0;\r\ncur_cs = 0;\r\nmemset(begin_set, 0, sizeof(begin_set));\r\nmemset(end_set, 0, sizeof(end_set));\r\ndownload_consts[QOUTFIFO_OFFSET] = 0;\r\nif (ahc->targetcmds != NULL)\r\ndownload_consts[QOUTFIFO_OFFSET] += 32;\r\ndownload_consts[QINFIFO_OFFSET] = download_consts[QOUTFIFO_OFFSET] + 1;\r\ndownload_consts[CACHESIZE_MASK] = ahc->pci_cachesize - 1;\r\ndownload_consts[INVERTED_CACHESIZE_MASK] = ~(ahc->pci_cachesize - 1);\r\nsg_prefetch_cnt = ahc->pci_cachesize;\r\nif (sg_prefetch_cnt < (2 * sizeof(struct ahc_dma_seg)))\r\nsg_prefetch_cnt = 2 * sizeof(struct ahc_dma_seg);\r\ndownload_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;\r\ndownload_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_cnt - 1);\r\ndownload_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_cnt - 1);\r\ncur_patch = patches;\r\ndownloaded = 0;\r\nskip_addr = 0;\r\nahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);\r\nahc_outb(ahc, SEQADDR0, 0);\r\nahc_outb(ahc, SEQADDR1, 0);\r\nfor (i = 0; i < sizeof(seqprog)/4; i++) {\r\nif (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {\r\ncontinue;\r\n}\r\nif (downloaded == ahc->instruction_ram_size) {\r\nprintk("\n%s: Program too large for instruction memory "\r\n"size of %d!\n", ahc_name(ahc),\r\nahc->instruction_ram_size);\r\nreturn (ENOMEM);\r\n}\r\nfor (; cur_cs < num_critical_sections; cur_cs++) {\r\nif (critical_sections[cur_cs].end <= i) {\r\nif (begin_set[cs_count] == TRUE\r\n&& end_set[cs_count] == FALSE) {\r\ncs_table[cs_count].end = downloaded;\r\nend_set[cs_count] = TRUE;\r\ncs_count++;\r\n}\r\ncontinue;\r\n}\r\nif (critical_sections[cur_cs].begin <= i\r\n&& begin_set[cs_count] == FALSE) {\r\ncs_table[cs_count].begin = downloaded;\r\nbegin_set[cs_count] = TRUE;\r\n}\r\nbreak;\r\n}\r\nahc_download_instr(ahc, i, download_consts);\r\ndownloaded++;\r\n}\r\nahc->num_critical_sections = cs_count;\r\nif (cs_count != 0) {\r\ncs_count *= sizeof(struct cs);\r\nahc->critical_sections = kmalloc(cs_count, GFP_ATOMIC);\r\nif (ahc->critical_sections == NULL)\r\npanic("ahc_loadseq: Could not malloc");\r\nmemcpy(ahc->critical_sections, cs_table, cs_count);\r\n}\r\nahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);\r\nif (bootverbose) {\r\nprintk(" %d instructions downloaded\n", downloaded);\r\nprintk("%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n",\r\nahc_name(ahc), ahc->features, ahc->bugs, ahc->flags);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_check_patch(struct ahc_softc *ahc, const struct patch **start_patch,\r\nu_int start_instr, u_int *skip_addr)\r\n{\r\nconst struct patch *cur_patch;\r\nconst struct patch *last_patch;\r\nu_int num_patches;\r\nnum_patches = ARRAY_SIZE(patches);\r\nlast_patch = &patches[num_patches];\r\ncur_patch = *start_patch;\r\nwhile (cur_patch < last_patch && start_instr == cur_patch->begin) {\r\nif (cur_patch->patch_func(ahc) == 0) {\r\n*skip_addr = start_instr + cur_patch->skip_instr;\r\ncur_patch += cur_patch->skip_patch;\r\n} else {\r\ncur_patch++;\r\n}\r\n}\r\n*start_patch = cur_patch;\r\nif (start_instr < *skip_addr)\r\nreturn (0);\r\nreturn (1);\r\n}\r\nstatic void\r\nahc_download_instr(struct ahc_softc *ahc, u_int instrptr, uint8_t *dconsts)\r\n{\r\nunion ins_formats instr;\r\nstruct ins_format1 *fmt1_ins;\r\nstruct ins_format3 *fmt3_ins;\r\nu_int opcode;\r\ninstr.integer = ahc_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);\r\nfmt1_ins = &instr.format1;\r\nfmt3_ins = NULL;\r\nopcode = instr.format1.opcode;\r\nswitch (opcode) {\r\ncase AIC_OP_JMP:\r\ncase AIC_OP_JC:\r\ncase AIC_OP_JNC:\r\ncase AIC_OP_CALL:\r\ncase AIC_OP_JNE:\r\ncase AIC_OP_JNZ:\r\ncase AIC_OP_JE:\r\ncase AIC_OP_JZ:\r\n{\r\nconst struct patch *cur_patch;\r\nint address_offset;\r\nu_int address;\r\nu_int skip_addr;\r\nu_int i;\r\nfmt3_ins = &instr.format3;\r\naddress_offset = 0;\r\naddress = fmt3_ins->address;\r\ncur_patch = patches;\r\nskip_addr = 0;\r\nfor (i = 0; i < address;) {\r\nahc_check_patch(ahc, &cur_patch, i, &skip_addr);\r\nif (skip_addr > i) {\r\nint end_addr;\r\nend_addr = min(address, skip_addr);\r\naddress_offset += end_addr - i;\r\ni = skip_addr;\r\n} else {\r\ni++;\r\n}\r\n}\r\naddress -= address_offset;\r\nfmt3_ins->address = address;\r\n}\r\ncase AIC_OP_OR:\r\ncase AIC_OP_AND:\r\ncase AIC_OP_XOR:\r\ncase AIC_OP_ADD:\r\ncase AIC_OP_ADC:\r\ncase AIC_OP_BMOV:\r\nif (fmt1_ins->parity != 0) {\r\nfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\r\n}\r\nfmt1_ins->parity = 0;\r\nif ((ahc->features & AHC_CMD_CHAN) == 0\r\n&& opcode == AIC_OP_BMOV) {\r\nif (fmt1_ins->immediate != 1)\r\npanic("%s: BMOV not supported\n",\r\nahc_name(ahc));\r\nfmt1_ins->opcode = AIC_OP_AND;\r\nfmt1_ins->immediate = 0xff;\r\n}\r\ncase AIC_OP_ROL:\r\nif ((ahc->features & AHC_ULTRA2) != 0) {\r\nint i, count;\r\nfor (i = 0, count = 0; i < 31; i++) {\r\nuint32_t mask;\r\nmask = 0x01 << i;\r\nif ((instr.integer & mask) != 0)\r\ncount++;\r\n}\r\nif ((count & 0x01) == 0)\r\ninstr.format1.parity = 1;\r\n} else {\r\nif (fmt3_ins != NULL) {\r\ninstr.integer =\r\nfmt3_ins->immediate\r\n| (fmt3_ins->source << 8)\r\n| (fmt3_ins->address << 16)\r\n| (fmt3_ins->opcode << 25);\r\n} else {\r\ninstr.integer =\r\nfmt1_ins->immediate\r\n| (fmt1_ins->source << 8)\r\n| (fmt1_ins->destination << 16)\r\n| (fmt1_ins->ret << 24)\r\n| (fmt1_ins->opcode << 25);\r\n}\r\n}\r\ninstr.integer = ahc_htole32(instr.integer);\r\nahc_outsb(ahc, SEQRAM, instr.bytes, 4);\r\nbreak;\r\ndefault:\r\npanic("Unknown opcode encountered in seq program");\r\nbreak;\r\n}\r\n}\r\nint\r\nahc_print_register(const ahc_reg_parse_entry_t *table, u_int num_entries,\r\nconst char *name, u_int address, u_int value,\r\nu_int *cur_column, u_int wrap_point)\r\n{\r\nint printed;\r\nu_int printed_mask;\r\nif (cur_column != NULL && *cur_column >= wrap_point) {\r\nprintk("\n");\r\n*cur_column = 0;\r\n}\r\nprinted = printk("%s[0x%x]", name, value);\r\nif (table == NULL) {\r\nprinted += printk(" ");\r\n*cur_column += printed;\r\nreturn (printed);\r\n}\r\nprinted_mask = 0;\r\nwhile (printed_mask != 0xFF) {\r\nint entry;\r\nfor (entry = 0; entry < num_entries; entry++) {\r\nif (((value & table[entry].mask)\r\n!= table[entry].value)\r\n|| ((printed_mask & table[entry].mask)\r\n== table[entry].mask))\r\ncontinue;\r\nprinted += printk("%s%s",\r\nprinted_mask == 0 ? ":(" : "|",\r\ntable[entry].name);\r\nprinted_mask |= table[entry].mask;\r\nbreak;\r\n}\r\nif (entry >= num_entries)\r\nbreak;\r\n}\r\nif (printed_mask != 0)\r\nprinted += printk(") ");\r\nelse\r\nprinted += printk(" ");\r\nif (cur_column != NULL)\r\n*cur_column += printed;\r\nreturn (printed);\r\n}\r\nvoid\r\nahc_dump_card_state(struct ahc_softc *ahc)\r\n{\r\nstruct scb *scb;\r\nstruct scb_tailq *untagged_q;\r\nu_int cur_col;\r\nint paused;\r\nint target;\r\nint maxtarget;\r\nint i;\r\nuint8_t last_phase;\r\nuint8_t qinpos;\r\nuint8_t qintail;\r\nuint8_t qoutpos;\r\nuint8_t scb_index;\r\nuint8_t saved_scbptr;\r\nif (ahc_is_paused(ahc)) {\r\npaused = 1;\r\n} else {\r\npaused = 0;\r\nahc_pause(ahc);\r\n}\r\nsaved_scbptr = ahc_inb(ahc, SCBPTR);\r\nlast_phase = ahc_inb(ahc, LASTPHASE);\r\nprintk(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"\r\n"%s: Dumping Card State %s, at SEQADDR 0x%x\n",\r\nahc_name(ahc), ahc_lookup_phase_entry(last_phase)->phasemsg,\r\nahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));\r\nif (paused)\r\nprintk("Card was paused\n");\r\nprintk("ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\n",\r\nahc_inb(ahc, ACCUM), ahc_inb(ahc, SINDEX), ahc_inb(ahc, DINDEX),\r\nahc_inb(ahc, ARG_2));\r\nprintk("HCNT = 0x%x SCBPTR = 0x%x\n", ahc_inb(ahc, HCNT),\r\nahc_inb(ahc, SCBPTR));\r\ncur_col = 0;\r\nif ((ahc->features & AHC_DT) != 0)\r\nahc_scsiphase_print(ahc_inb(ahc, SCSIPHASE), &cur_col, 50);\r\nahc_scsisigi_print(ahc_inb(ahc, SCSISIGI), &cur_col, 50);\r\nahc_error_print(ahc_inb(ahc, ERROR), &cur_col, 50);\r\nahc_scsibusl_print(ahc_inb(ahc, SCSIBUSL), &cur_col, 50);\r\nahc_lastphase_print(ahc_inb(ahc, LASTPHASE), &cur_col, 50);\r\nahc_scsiseq_print(ahc_inb(ahc, SCSISEQ), &cur_col, 50);\r\nahc_sblkctl_print(ahc_inb(ahc, SBLKCTL), &cur_col, 50);\r\nahc_scsirate_print(ahc_inb(ahc, SCSIRATE), &cur_col, 50);\r\nahc_seqctl_print(ahc_inb(ahc, SEQCTL), &cur_col, 50);\r\nahc_seq_flags_print(ahc_inb(ahc, SEQ_FLAGS), &cur_col, 50);\r\nahc_sstat0_print(ahc_inb(ahc, SSTAT0), &cur_col, 50);\r\nahc_sstat1_print(ahc_inb(ahc, SSTAT1), &cur_col, 50);\r\nahc_sstat2_print(ahc_inb(ahc, SSTAT2), &cur_col, 50);\r\nahc_sstat3_print(ahc_inb(ahc, SSTAT3), &cur_col, 50);\r\nahc_simode0_print(ahc_inb(ahc, SIMODE0), &cur_col, 50);\r\nahc_simode1_print(ahc_inb(ahc, SIMODE1), &cur_col, 50);\r\nahc_sxfrctl0_print(ahc_inb(ahc, SXFRCTL0), &cur_col, 50);\r\nahc_dfcntrl_print(ahc_inb(ahc, DFCNTRL), &cur_col, 50);\r\nahc_dfstatus_print(ahc_inb(ahc, DFSTATUS), &cur_col, 50);\r\nif (cur_col != 0)\r\nprintk("\n");\r\nprintk("STACK:");\r\nfor (i = 0; i < STACK_SIZE; i++)\r\nprintk(" 0x%x", ahc_inb(ahc, STACK)|(ahc_inb(ahc, STACK) << 8));\r\nprintk("\nSCB count = %d\n", ahc->scb_data->numscbs);\r\nprintk("Kernel NEXTQSCB = %d\n", ahc->next_queued_scb->hscb->tag);\r\nprintk("Card NEXTQSCB = %d\n", ahc_inb(ahc, NEXT_QUEUED_SCB));\r\nprintk("QINFIFO entries: ");\r\nif ((ahc->features & AHC_QUEUE_REGS) != 0) {\r\nqinpos = ahc_inb(ahc, SNSCB_QOFF);\r\nahc_outb(ahc, SNSCB_QOFF, qinpos);\r\n} else\r\nqinpos = ahc_inb(ahc, QINPOS);\r\nqintail = ahc->qinfifonext;\r\nwhile (qinpos != qintail) {\r\nprintk("%d ", ahc->qinfifo[qinpos]);\r\nqinpos++;\r\n}\r\nprintk("\n");\r\nprintk("Waiting Queue entries: ");\r\nscb_index = ahc_inb(ahc, WAITING_SCBH);\r\ni = 0;\r\nwhile (scb_index != SCB_LIST_NULL && i++ < 256) {\r\nahc_outb(ahc, SCBPTR, scb_index);\r\nprintk("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));\r\nscb_index = ahc_inb(ahc, SCB_NEXT);\r\n}\r\nprintk("\n");\r\nprintk("Disconnected Queue entries: ");\r\nscb_index = ahc_inb(ahc, DISCONNECTED_SCBH);\r\ni = 0;\r\nwhile (scb_index != SCB_LIST_NULL && i++ < 256) {\r\nahc_outb(ahc, SCBPTR, scb_index);\r\nprintk("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));\r\nscb_index = ahc_inb(ahc, SCB_NEXT);\r\n}\r\nprintk("\n");\r\nahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);\r\nprintk("QOUTFIFO entries: ");\r\nqoutpos = ahc->qoutfifonext;\r\ni = 0;\r\nwhile (ahc->qoutfifo[qoutpos] != SCB_LIST_NULL && i++ < 256) {\r\nprintk("%d ", ahc->qoutfifo[qoutpos]);\r\nqoutpos++;\r\n}\r\nprintk("\n");\r\nprintk("Sequencer Free SCB List: ");\r\nscb_index = ahc_inb(ahc, FREE_SCBH);\r\ni = 0;\r\nwhile (scb_index != SCB_LIST_NULL && i++ < 256) {\r\nahc_outb(ahc, SCBPTR, scb_index);\r\nprintk("%d ", scb_index);\r\nscb_index = ahc_inb(ahc, SCB_NEXT);\r\n}\r\nprintk("\n");\r\nprintk("Sequencer SCB Info: ");\r\nfor (i = 0; i < ahc->scb_data->maxhscbs; i++) {\r\nahc_outb(ahc, SCBPTR, i);\r\ncur_col = printk("\n%3d ", i);\r\nahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL), &cur_col, 60);\r\nahc_scb_scsiid_print(ahc_inb(ahc, SCB_SCSIID), &cur_col, 60);\r\nahc_scb_lun_print(ahc_inb(ahc, SCB_LUN), &cur_col, 60);\r\nahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);\r\n}\r\nprintk("\n");\r\nprintk("Pending list: ");\r\ni = 0;\r\nLIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {\r\nif (i++ > 256)\r\nbreak;\r\ncur_col = printk("\n%3d ", scb->hscb->tag);\r\nahc_scb_control_print(scb->hscb->control, &cur_col, 60);\r\nahc_scb_scsiid_print(scb->hscb->scsiid, &cur_col, 60);\r\nahc_scb_lun_print(scb->hscb->lun, &cur_col, 60);\r\nif ((ahc->flags & AHC_PAGESCBS) == 0) {\r\nahc_outb(ahc, SCBPTR, scb->hscb->tag);\r\nprintk("(");\r\nahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL),\r\n&cur_col, 60);\r\nahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);\r\nprintk(")");\r\n}\r\n}\r\nprintk("\n");\r\nprintk("Kernel Free SCB list: ");\r\ni = 0;\r\nSLIST_FOREACH(scb, &ahc->scb_data->free_scbs, links.sle) {\r\nif (i++ > 256)\r\nbreak;\r\nprintk("%d ", scb->hscb->tag);\r\n}\r\nprintk("\n");\r\nmaxtarget = (ahc->features & (AHC_WIDE|AHC_TWIN)) ? 15 : 7;\r\nfor (target = 0; target <= maxtarget; target++) {\r\nuntagged_q = &ahc->untagged_queues[target];\r\nif (TAILQ_FIRST(untagged_q) == NULL)\r\ncontinue;\r\nprintk("Untagged Q(%d): ", target);\r\ni = 0;\r\nTAILQ_FOREACH(scb, untagged_q, links.tqe) {\r\nif (i++ > 256)\r\nbreak;\r\nprintk("%d ", scb->hscb->tag);\r\n}\r\nprintk("\n");\r\n}\r\nahc_platform_dump_card_state(ahc);\r\nprintk("\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\n");\r\nahc_outb(ahc, SCBPTR, saved_scbptr);\r\nif (paused == 0)\r\nahc_unpause(ahc);\r\n}\r\ncam_status\r\nahc_find_tmode_devs(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb,\r\nstruct ahc_tmode_tstate **tstate,\r\nstruct ahc_tmode_lstate **lstate,\r\nint notfound_failure)\r\n{\r\nif ((ahc->features & AHC_TARGETMODE) == 0)\r\nreturn (CAM_REQ_INVALID);\r\nif (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD\r\n&& ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {\r\n*tstate = NULL;\r\n*lstate = ahc->black_hole;\r\n} else {\r\nu_int max_id;\r\nmax_id = (ahc->features & AHC_WIDE) ? 16 : 8;\r\nif (ccb->ccb_h.target_id >= max_id)\r\nreturn (CAM_TID_INVALID);\r\nif (ccb->ccb_h.target_lun >= AHC_NUM_LUNS)\r\nreturn (CAM_LUN_INVALID);\r\n*tstate = ahc->enabled_targets[ccb->ccb_h.target_id];\r\n*lstate = NULL;\r\nif (*tstate != NULL)\r\n*lstate =\r\n(*tstate)->enabled_luns[ccb->ccb_h.target_lun];\r\n}\r\nif (notfound_failure != 0 && *lstate == NULL)\r\nreturn (CAM_PATH_INVALID);\r\nreturn (CAM_REQ_CMP);\r\n}\r\nvoid\r\nahc_handle_en_lun(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb)\r\n{\r\nstruct ahc_tmode_tstate *tstate;\r\nstruct ahc_tmode_lstate *lstate;\r\nstruct ccb_en_lun *cel;\r\ncam_status status;\r\nu_long s;\r\nu_int target;\r\nu_int lun;\r\nu_int target_mask;\r\nu_int our_id;\r\nint error;\r\nchar channel;\r\nstatus = ahc_find_tmode_devs(ahc, sim, ccb, &tstate, &lstate,\r\nFALSE);\r\nif (status != CAM_REQ_CMP) {\r\nccb->ccb_h.status = status;\r\nreturn;\r\n}\r\nif (cam_sim_bus(sim) == 0)\r\nour_id = ahc->our_id;\r\nelse\r\nour_id = ahc->our_id_b;\r\nif (ccb->ccb_h.target_id != our_id) {\r\nif ((ahc->features & AHC_MULTIROLE) != 0) {\r\nif ((ahc->features & AHC_MULTI_TID) != 0\r\n&& (ahc->flags & AHC_INITIATORROLE) != 0) {\r\nstatus = CAM_TID_INVALID;\r\n} else if ((ahc->flags & AHC_INITIATORROLE) != 0\r\n|| ahc->enabled_luns > 0) {\r\nstatus = CAM_TID_INVALID;\r\n}\r\n} else if ((ahc->features & AHC_MULTI_TID) == 0\r\n&& ahc->enabled_luns > 0) {\r\nstatus = CAM_TID_INVALID;\r\n}\r\n}\r\nif (status != CAM_REQ_CMP) {\r\nccb->ccb_h.status = status;\r\nreturn;\r\n}\r\nif ((ahc->flags & AHC_TARGETROLE) == 0\r\n&& ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {\r\nu_long s;\r\nahc_flag saved_flags;\r\nprintk("Configuring Target Mode\n");\r\nahc_lock(ahc, &s);\r\nif (LIST_FIRST(&ahc->pending_scbs) != NULL) {\r\nccb->ccb_h.status = CAM_BUSY;\r\nahc_unlock(ahc, &s);\r\nreturn;\r\n}\r\nsaved_flags = ahc->flags;\r\nahc->flags |= AHC_TARGETROLE;\r\nif ((ahc->features & AHC_MULTIROLE) == 0)\r\nahc->flags &= ~AHC_INITIATORROLE;\r\nahc_pause(ahc);\r\nerror = ahc_loadseq(ahc);\r\nif (error != 0) {\r\nahc->flags = saved_flags;\r\n(void)ahc_loadseq(ahc);\r\nahc_restart(ahc);\r\nahc_unlock(ahc, &s);\r\nccb->ccb_h.status = CAM_FUNC_NOTAVAIL;\r\nreturn;\r\n}\r\nahc_restart(ahc);\r\nahc_unlock(ahc, &s);\r\n}\r\ncel = &ccb->cel;\r\ntarget = ccb->ccb_h.target_id;\r\nlun = ccb->ccb_h.target_lun;\r\nchannel = SIM_CHANNEL(ahc, sim);\r\ntarget_mask = 0x01 << target;\r\nif (channel == 'B')\r\ntarget_mask <<= 8;\r\nif (cel->enable != 0) {\r\nu_int scsiseq;\r\nif (lstate != NULL) {\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Lun already enabled\n");\r\nccb->ccb_h.status = CAM_LUN_ALRDY_ENA;\r\nreturn;\r\n}\r\nif (cel->grp6_len != 0\r\n|| cel->grp7_len != 0) {\r\nccb->ccb_h.status = CAM_REQ_INVALID;\r\nprintk("Non-zero Group Codes\n");\r\nreturn;\r\n}\r\nif (target != CAM_TARGET_WILDCARD && tstate == NULL) {\r\ntstate = ahc_alloc_tstate(ahc, target, channel);\r\nif (tstate == NULL) {\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Couldn't allocate tstate\n");\r\nccb->ccb_h.status = CAM_RESRC_UNAVAIL;\r\nreturn;\r\n}\r\n}\r\nlstate = kzalloc(sizeof(*lstate), GFP_ATOMIC);\r\nif (lstate == NULL) {\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Couldn't allocate lstate\n");\r\nccb->ccb_h.status = CAM_RESRC_UNAVAIL;\r\nreturn;\r\n}\r\nstatus = xpt_create_path(&lstate->path, NULL,\r\nxpt_path_path_id(ccb->ccb_h.path),\r\nxpt_path_target_id(ccb->ccb_h.path),\r\nxpt_path_lun_id(ccb->ccb_h.path));\r\nif (status != CAM_REQ_CMP) {\r\nkfree(lstate);\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Couldn't allocate path\n");\r\nccb->ccb_h.status = CAM_RESRC_UNAVAIL;\r\nreturn;\r\n}\r\nSLIST_INIT(&lstate->accept_tios);\r\nSLIST_INIT(&lstate->immed_notifies);\r\nahc_lock(ahc, &s);\r\nahc_pause(ahc);\r\nif (target != CAM_TARGET_WILDCARD) {\r\ntstate->enabled_luns[lun] = lstate;\r\nahc->enabled_luns++;\r\nif ((ahc->features & AHC_MULTI_TID) != 0) {\r\nu_int targid_mask;\r\ntargid_mask = ahc_inb(ahc, TARGID)\r\n| (ahc_inb(ahc, TARGID + 1) << 8);\r\ntargid_mask |= target_mask;\r\nahc_outb(ahc, TARGID, targid_mask);\r\nahc_outb(ahc, TARGID+1, (targid_mask >> 8));\r\nahc_update_scsiid(ahc, targid_mask);\r\n} else {\r\nu_int our_id;\r\nchar channel;\r\nchannel = SIM_CHANNEL(ahc, sim);\r\nour_id = SIM_SCSI_ID(ahc, sim);\r\nif (target != our_id) {\r\nu_int sblkctl;\r\nchar cur_channel;\r\nint swap;\r\nsblkctl = ahc_inb(ahc, SBLKCTL);\r\ncur_channel = (sblkctl & SELBUSB)\r\n? 'B' : 'A';\r\nif ((ahc->features & AHC_TWIN) == 0)\r\ncur_channel = 'A';\r\nswap = cur_channel != channel;\r\nif (channel == 'A')\r\nahc->our_id = target;\r\nelse\r\nahc->our_id_b = target;\r\nif (swap)\r\nahc_outb(ahc, SBLKCTL,\r\nsblkctl ^ SELBUSB);\r\nahc_outb(ahc, SCSIID, target);\r\nif (swap)\r\nahc_outb(ahc, SBLKCTL, sblkctl);\r\n}\r\n}\r\n} else\r\nahc->black_hole = lstate;\r\nif (ahc->black_hole != NULL && ahc->enabled_luns > 0) {\r\nscsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);\r\nscsiseq |= ENSELI;\r\nahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);\r\nscsiseq = ahc_inb(ahc, SCSISEQ);\r\nscsiseq |= ENSELI;\r\nahc_outb(ahc, SCSISEQ, scsiseq);\r\n}\r\nahc_unpause(ahc);\r\nahc_unlock(ahc, &s);\r\nccb->ccb_h.status = CAM_REQ_CMP;\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Lun now enabled for target mode\n");\r\n} else {\r\nstruct scb *scb;\r\nint i, empty;\r\nif (lstate == NULL) {\r\nccb->ccb_h.status = CAM_LUN_INVALID;\r\nreturn;\r\n}\r\nahc_lock(ahc, &s);\r\nccb->ccb_h.status = CAM_REQ_CMP;\r\nLIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {\r\nstruct ccb_hdr *ccbh;\r\nccbh = &scb->io_ctx->ccb_h;\r\nif (ccbh->func_code == XPT_CONT_TARGET_IO\r\n&& !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){\r\nprintk("CTIO pending\n");\r\nccb->ccb_h.status = CAM_REQ_INVALID;\r\nahc_unlock(ahc, &s);\r\nreturn;\r\n}\r\n}\r\nif (SLIST_FIRST(&lstate->accept_tios) != NULL) {\r\nprintk("ATIOs pending\n");\r\nccb->ccb_h.status = CAM_REQ_INVALID;\r\n}\r\nif (SLIST_FIRST(&lstate->immed_notifies) != NULL) {\r\nprintk("INOTs pending\n");\r\nccb->ccb_h.status = CAM_REQ_INVALID;\r\n}\r\nif (ccb->ccb_h.status != CAM_REQ_CMP) {\r\nahc_unlock(ahc, &s);\r\nreturn;\r\n}\r\nxpt_print_path(ccb->ccb_h.path);\r\nprintk("Target mode disabled\n");\r\nxpt_free_path(lstate->path);\r\nkfree(lstate);\r\nahc_pause(ahc);\r\nif (target != CAM_TARGET_WILDCARD) {\r\ntstate->enabled_luns[lun] = NULL;\r\nahc->enabled_luns--;\r\nfor (empty = 1, i = 0; i < 8; i++)\r\nif (tstate->enabled_luns[i] != NULL) {\r\nempty = 0;\r\nbreak;\r\n}\r\nif (empty) {\r\nahc_free_tstate(ahc, target, channel,\r\nFALSE);\r\nif (ahc->features & AHC_MULTI_TID) {\r\nu_int targid_mask;\r\ntargid_mask = ahc_inb(ahc, TARGID)\r\n| (ahc_inb(ahc, TARGID + 1)\r\n<< 8);\r\ntargid_mask &= ~target_mask;\r\nahc_outb(ahc, TARGID, targid_mask);\r\nahc_outb(ahc, TARGID+1,\r\n(targid_mask >> 8));\r\nahc_update_scsiid(ahc, targid_mask);\r\n}\r\n}\r\n} else {\r\nahc->black_hole = NULL;\r\nempty = TRUE;\r\n}\r\nif (ahc->enabled_luns == 0) {\r\nu_int scsiseq;\r\nscsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);\r\nscsiseq &= ~ENSELI;\r\nahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);\r\nscsiseq = ahc_inb(ahc, SCSISEQ);\r\nscsiseq &= ~ENSELI;\r\nahc_outb(ahc, SCSISEQ, scsiseq);\r\nif ((ahc->features & AHC_MULTIROLE) == 0) {\r\nprintk("Configuring Initiator Mode\n");\r\nahc->flags &= ~AHC_TARGETROLE;\r\nahc->flags |= AHC_INITIATORROLE;\r\n(void)ahc_loadseq(ahc);\r\nahc_restart(ahc);\r\n}\r\n}\r\nahc_unpause(ahc);\r\nahc_unlock(ahc, &s);\r\n}\r\n}\r\nstatic void\r\nahc_update_scsiid(struct ahc_softc *ahc, u_int targid_mask)\r\n{\r\nu_int scsiid_mask;\r\nu_int scsiid;\r\nif ((ahc->features & AHC_MULTI_TID) == 0)\r\npanic("ahc_update_scsiid called on non-multitid unit\n");\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nscsiid = ahc_inb(ahc, SCSIID_ULTRA2);\r\nelse\r\nscsiid = ahc_inb(ahc, SCSIID);\r\nscsiid_mask = 0x1 << (scsiid & OID);\r\nif ((targid_mask & scsiid_mask) == 0) {\r\nu_int our_id;\r\nour_id = ffs(targid_mask);\r\nif (our_id == 0)\r\nour_id = ahc->our_id;\r\nelse\r\nour_id--;\r\nscsiid &= TID;\r\nscsiid |= our_id;\r\n}\r\nif ((ahc->features & AHC_ULTRA2) != 0)\r\nahc_outb(ahc, SCSIID_ULTRA2, scsiid);\r\nelse\r\nahc_outb(ahc, SCSIID, scsiid);\r\n}\r\nstatic void\r\nahc_run_tqinfifo(struct ahc_softc *ahc, int paused)\r\n{\r\nstruct target_cmd *cmd;\r\nif ((ahc->features & AHC_AUTOPAUSE) != 0)\r\npaused = TRUE;\r\nahc_sync_tqinfifo(ahc, BUS_DMASYNC_POSTREAD);\r\nwhile ((cmd = &ahc->targetcmds[ahc->tqinfifonext])->cmd_valid != 0) {\r\nif (ahc_handle_target_cmd(ahc, cmd) != 0)\r\nbreak;\r\ncmd->cmd_valid = 0;\r\nahc_dmamap_sync(ahc, ahc->shared_data_dmat,\r\nahc->shared_data_dmamap,\r\nahc_targetcmd_offset(ahc, ahc->tqinfifonext),\r\nsizeof(struct target_cmd),\r\nBUS_DMASYNC_PREREAD);\r\nahc->tqinfifonext++;\r\nif ((ahc->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {\r\nif ((ahc->features & AHC_HS_MAILBOX) != 0) {\r\nu_int hs_mailbox;\r\nhs_mailbox = ahc_inb(ahc, HS_MAILBOX);\r\nhs_mailbox &= ~HOST_TQINPOS;\r\nhs_mailbox |= ahc->tqinfifonext & HOST_TQINPOS;\r\nahc_outb(ahc, HS_MAILBOX, hs_mailbox);\r\n} else {\r\nif (!paused)\r\nahc_pause(ahc);\r\nahc_outb(ahc, KERNEL_TQINPOS,\r\nahc->tqinfifonext & HOST_TQINPOS);\r\nif (!paused)\r\nahc_unpause(ahc);\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\nahc_handle_target_cmd(struct ahc_softc *ahc, struct target_cmd *cmd)\r\n{\r\nstruct ahc_tmode_tstate *tstate;\r\nstruct ahc_tmode_lstate *lstate;\r\nstruct ccb_accept_tio *atio;\r\nuint8_t *byte;\r\nint initiator;\r\nint target;\r\nint lun;\r\ninitiator = SCSIID_TARGET(ahc, cmd->scsiid);\r\ntarget = SCSIID_OUR_ID(cmd->scsiid);\r\nlun = (cmd->identify & MSG_IDENTIFY_LUNMASK);\r\nbyte = cmd->bytes;\r\ntstate = ahc->enabled_targets[target];\r\nlstate = NULL;\r\nif (tstate != NULL)\r\nlstate = tstate->enabled_luns[lun];\r\nif (lstate == NULL)\r\nlstate = ahc->black_hole;\r\natio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);\r\nif (atio == NULL) {\r\nahc->flags |= AHC_TQINFIFO_BLOCKED;\r\nif (bootverbose)\r\nprintk("%s: ATIOs exhausted\n", ahc_name(ahc));\r\nreturn (1);\r\n} else\r\nahc->flags &= ~AHC_TQINFIFO_BLOCKED;\r\n#if 0\r\nprintk("Incoming command from %d for %d:%d%s\n",\r\ninitiator, target, lun,\r\nlstate == ahc->black_hole ? "(Black Holed)" : "");\r\n#endif\r\nSLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);\r\nif (lstate == ahc->black_hole) {\r\natio->ccb_h.target_id = target;\r\natio->ccb_h.target_lun = lun;\r\n}\r\natio->sense_len = 0;\r\natio->init_id = initiator;\r\nif (byte[0] != 0xFF) {\r\natio->tag_action = *byte++;\r\natio->tag_id = *byte++;\r\natio->ccb_h.flags = CAM_TAG_ACTION_VALID;\r\n} else {\r\natio->ccb_h.flags = 0;\r\n}\r\nbyte++;\r\nswitch (*byte >> CMD_GROUP_CODE_SHIFT) {\r\ncase 0:\r\natio->cdb_len = 6;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\natio->cdb_len = 10;\r\nbreak;\r\ncase 4:\r\natio->cdb_len = 16;\r\nbreak;\r\ncase 5:\r\natio->cdb_len = 12;\r\nbreak;\r\ncase 3:\r\ndefault:\r\natio->cdb_len = 1;\r\nprintk("Reserved or VU command code type encountered\n");\r\nbreak;\r\n}\r\nmemcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);\r\natio->ccb_h.status |= CAM_CDB_RECVD;\r\nif ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {\r\n#if 0\r\nprintk("Received Immediate Command %d:%d:%d - %p\n",\r\ninitiator, target, lun, ahc->pending_device);\r\n#endif\r\nahc->pending_device = lstate;\r\nahc_freeze_ccb((union ccb *)atio);\r\natio->ccb_h.flags |= CAM_DIS_DISCONNECT;\r\n}\r\nxpt_done((union ccb*)atio);\r\nreturn (0);\r\n}
