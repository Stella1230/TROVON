static bool fsl_asoc_card_is_ac97(struct fsl_asoc_card_priv *priv)\r\n{\r\nreturn priv->dai_fmt == SND_SOC_DAIFMT_AC97;\r\n}\r\nstatic int fsl_asoc_card_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct cpu_priv *cpu_priv = &priv->cpu_priv;\r\nstruct device *dev = rtd->card->dev;\r\nint ret;\r\npriv->sample_rate = params_rate(params);\r\npriv->sample_format = params_format(params);\r\nif ((priv->card.set_bias_level &&\r\npriv->dai_fmt & SND_SOC_DAIFMT_CBM_CFM) ||\r\nfsl_asoc_card_is_ac97(priv))\r\nreturn 0;\r\nret = snd_soc_dai_set_sysclk(rtd->cpu_dai, cpu_priv->sysclk_id[tx],\r\ncpu_priv->sysclk_freq[tx],\r\ncpu_priv->sysclk_dir[tx]);\r\nif (ret) {\r\ndev_err(dev, "failed to set sysclk for cpu dai\n");\r\nreturn ret;\r\n}\r\nif (cpu_priv->slot_width) {\r\nret = snd_soc_dai_set_tdm_slot(rtd->cpu_dai, 0x3, 0x3, 2,\r\ncpu_priv->slot_width);\r\nif (ret) {\r\ndev_err(dev, "failed to set TDM slot for cpu dai\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\r\nstruct snd_interval *rate;\r\nstruct snd_mask *mask;\r\nrate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nrate->max = rate->min = priv->asrc_rate;\r\nmask = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nsnd_mask_none(mask);\r\nsnd_mask_set(mask, priv->asrc_format);\r\nreturn 0;\r\n}\r\nstatic int fsl_asoc_card_set_bias_level(struct snd_soc_card *card,\r\nstruct snd_soc_dapm_context *dapm,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(card);\r\nstruct snd_soc_pcm_runtime *rtd;\r\nstruct snd_soc_dai *codec_dai;\r\nstruct codec_priv *codec_priv = &priv->codec_priv;\r\nstruct device *dev = card->dev;\r\nunsigned int pll_out;\r\nint ret;\r\nrtd = snd_soc_get_pcm_runtime(card, card->dai_link[0].name);\r\ncodec_dai = rtd->codec_dai;\r\nif (dapm->dev != codec_dai->dev)\r\nreturn 0;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (dapm->bias_level != SND_SOC_BIAS_STANDBY)\r\nbreak;\r\nif (priv->sample_format == SNDRV_PCM_FORMAT_S24_LE)\r\npll_out = priv->sample_rate * 384;\r\nelse\r\npll_out = priv->sample_rate * 256;\r\nret = snd_soc_dai_set_pll(codec_dai, codec_priv->pll_id,\r\ncodec_priv->mclk_id,\r\ncodec_priv->mclk_freq, pll_out);\r\nif (ret) {\r\ndev_err(dev, "failed to start FLL: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_sysclk(codec_dai, codec_priv->fll_id,\r\npll_out, SND_SOC_CLOCK_IN);\r\nif (ret) {\r\ndev_err(dev, "failed to set SYSCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (dapm->bias_level != SND_SOC_BIAS_PREPARE)\r\nbreak;\r\nret = snd_soc_dai_set_sysclk(codec_dai, codec_priv->mclk_id,\r\ncodec_priv->mclk_freq,\r\nSND_SOC_CLOCK_IN);\r\nif (ret) {\r\ndev_err(dev, "failed to switch away from FLL: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_pll(codec_dai, codec_priv->pll_id, 0, 0, 0);\r\nif (ret) {\r\ndev_err(dev, "failed to stop FLL: %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_asoc_card_audmux_init(struct device_node *np,\r\nstruct fsl_asoc_card_priv *priv)\r\n{\r\nstruct device *dev = &priv->pdev->dev;\r\nu32 int_ptcr = 0, ext_ptcr = 0;\r\nint int_port, ext_port;\r\nint ret;\r\nret = of_property_read_u32(np, "mux-int-port", &int_port);\r\nif (ret) {\r\ndev_err(dev, "mux-int-port missing or invalid\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "mux-ext-port", &ext_port);\r\nif (ret) {\r\ndev_err(dev, "mux-ext-port missing or invalid\n");\r\nreturn ret;\r\n}\r\nint_port--;\r\next_port--;\r\nswitch (priv->dai_fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nint_ptcr = IMX_AUDMUX_V2_PTCR_RFSEL(8 | ext_port) |\r\nIMX_AUDMUX_V2_PTCR_RCSEL(8 | ext_port) |\r\nIMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\r\nIMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\r\nIMX_AUDMUX_V2_PTCR_RFSDIR |\r\nIMX_AUDMUX_V2_PTCR_RCLKDIR |\r\nIMX_AUDMUX_V2_PTCR_TFSDIR |\r\nIMX_AUDMUX_V2_PTCR_TCLKDIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nint_ptcr = IMX_AUDMUX_V2_PTCR_RCSEL(8 | ext_port) |\r\nIMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\r\nIMX_AUDMUX_V2_PTCR_RCLKDIR |\r\nIMX_AUDMUX_V2_PTCR_TCLKDIR;\r\next_ptcr = IMX_AUDMUX_V2_PTCR_RFSEL(8 | int_port) |\r\nIMX_AUDMUX_V2_PTCR_TFSEL(int_port) |\r\nIMX_AUDMUX_V2_PTCR_RFSDIR |\r\nIMX_AUDMUX_V2_PTCR_TFSDIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nint_ptcr = IMX_AUDMUX_V2_PTCR_RFSEL(8 | ext_port) |\r\nIMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\r\nIMX_AUDMUX_V2_PTCR_RFSDIR |\r\nIMX_AUDMUX_V2_PTCR_TFSDIR;\r\next_ptcr = IMX_AUDMUX_V2_PTCR_RCSEL(8 | int_port) |\r\nIMX_AUDMUX_V2_PTCR_TCSEL(int_port) |\r\nIMX_AUDMUX_V2_PTCR_RCLKDIR |\r\nIMX_AUDMUX_V2_PTCR_TCLKDIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\next_ptcr = IMX_AUDMUX_V2_PTCR_RFSEL(8 | int_port) |\r\nIMX_AUDMUX_V2_PTCR_RCSEL(8 | int_port) |\r\nIMX_AUDMUX_V2_PTCR_TFSEL(int_port) |\r\nIMX_AUDMUX_V2_PTCR_TCSEL(int_port) |\r\nIMX_AUDMUX_V2_PTCR_RFSDIR |\r\nIMX_AUDMUX_V2_PTCR_RCLKDIR |\r\nIMX_AUDMUX_V2_PTCR_TFSDIR |\r\nIMX_AUDMUX_V2_PTCR_TCLKDIR;\r\nbreak;\r\ndefault:\r\nif (!fsl_asoc_card_is_ac97(priv))\r\nreturn -EINVAL;\r\n}\r\nif (fsl_asoc_card_is_ac97(priv)) {\r\nint_ptcr = IMX_AUDMUX_V2_PTCR_SYN |\r\nIMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\r\nIMX_AUDMUX_V2_PTCR_TCLKDIR;\r\next_ptcr = IMX_AUDMUX_V2_PTCR_SYN |\r\nIMX_AUDMUX_V2_PTCR_TFSEL(int_port) |\r\nIMX_AUDMUX_V2_PTCR_TFSDIR;\r\n}\r\nif (!fsl_asoc_card_is_ac97(priv)) {\r\nunsigned int pdcr =\r\nIMX_AUDMUX_V2_PDCR_RXDSEL(ext_port);\r\nret = imx_audmux_v2_configure_port(int_port, 0,\r\npdcr);\r\nif (ret) {\r\ndev_err(dev, "audmux internal port setup failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = imx_audmux_v2_configure_port(int_port, int_ptcr,\r\nIMX_AUDMUX_V2_PDCR_RXDSEL(ext_port));\r\nif (ret) {\r\ndev_err(dev, "audmux internal port setup failed\n");\r\nreturn ret;\r\n}\r\nif (!fsl_asoc_card_is_ac97(priv)) {\r\nunsigned int pdcr =\r\nIMX_AUDMUX_V2_PDCR_RXDSEL(int_port);\r\nret = imx_audmux_v2_configure_port(ext_port, 0,\r\npdcr);\r\nif (ret) {\r\ndev_err(dev, "audmux external port setup failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = imx_audmux_v2_configure_port(ext_port, ext_ptcr,\r\nIMX_AUDMUX_V2_PDCR_RXDSEL(int_port));\r\nif (ret) {\r\ndev_err(dev, "audmux external port setup failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_asoc_card_late_probe(struct snd_soc_card *card)\r\n{\r\nstruct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(card);\r\nstruct snd_soc_pcm_runtime *rtd = list_first_entry(\r\n&card->rtd_list, struct snd_soc_pcm_runtime, list);\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct codec_priv *codec_priv = &priv->codec_priv;\r\nstruct device *dev = card->dev;\r\nint ret;\r\nif (fsl_asoc_card_is_ac97(priv)) {\r\n#if IS_ENABLED(CONFIG_SND_AC97_CODEC)\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nstruct snd_ac97 *ac97 = snd_soc_codec_get_drvdata(codec);\r\nsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\r\nAC97_EA_SPSA_SLOT_MASK, AC97_EA_SPSA_3_4);\r\n#endif\r\nreturn 0;\r\n}\r\nret = snd_soc_dai_set_sysclk(codec_dai, codec_priv->mclk_id,\r\ncodec_priv->mclk_freq, SND_SOC_CLOCK_IN);\r\nif (ret) {\r\ndev_err(dev, "failed to set sysclk in %s\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_asoc_card_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *cpu_np, *codec_np, *asrc_np;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct platform_device *asrc_pdev = NULL;\r\nstruct platform_device *cpu_pdev;\r\nstruct fsl_asoc_card_priv *priv;\r\nstruct i2c_client *codec_dev;\r\nconst char *codec_dai_name;\r\nu32 width;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ncpu_np = of_parse_phandle(np, "audio-cpu", 0);\r\nif (!cpu_np)\r\ncpu_np = of_parse_phandle(np, "ssi-controller", 0);\r\nif (!cpu_np) {\r\ndev_err(&pdev->dev, "CPU phandle missing or invalid\n");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\ncpu_pdev = of_find_device_by_node(cpu_np);\r\nif (!cpu_pdev) {\r\ndev_err(&pdev->dev, "failed to find CPU DAI device\n");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\ncodec_np = of_parse_phandle(np, "audio-codec", 0);\r\nif (codec_np)\r\ncodec_dev = of_find_i2c_device_by_node(codec_np);\r\nelse\r\ncodec_dev = NULL;\r\nasrc_np = of_parse_phandle(np, "audio-asrc", 0);\r\nif (asrc_np)\r\nasrc_pdev = of_find_device_by_node(asrc_np);\r\nif (codec_dev) {\r\nstruct clk *codec_clk = clk_get(&codec_dev->dev, NULL);\r\nif (!IS_ERR(codec_clk)) {\r\npriv->codec_priv.mclk_freq = clk_get_rate(codec_clk);\r\nclk_put(codec_clk);\r\n}\r\n}\r\npriv->sample_rate = 44100;\r\npriv->sample_format = SNDRV_PCM_FORMAT_S16_LE;\r\npriv->dai_fmt = DAI_FMT_BASE;\r\nif (of_device_is_compatible(np, "fsl,imx-audio-cs42888")) {\r\ncodec_dai_name = "cs42888";\r\npriv->card.set_bias_level = NULL;\r\npriv->cpu_priv.sysclk_freq[TX] = priv->codec_priv.mclk_freq;\r\npriv->cpu_priv.sysclk_freq[RX] = priv->codec_priv.mclk_freq;\r\npriv->cpu_priv.sysclk_dir[TX] = SND_SOC_CLOCK_OUT;\r\npriv->cpu_priv.sysclk_dir[RX] = SND_SOC_CLOCK_OUT;\r\npriv->cpu_priv.slot_width = 32;\r\npriv->dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;\r\n} else if (of_device_is_compatible(np, "fsl,imx-audio-cs427x")) {\r\ncodec_dai_name = "cs4271-hifi";\r\npriv->codec_priv.mclk_id = CS427x_SYSCLK_MCLK;\r\npriv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;\r\n} else if (of_device_is_compatible(np, "fsl,imx-audio-sgtl5000")) {\r\ncodec_dai_name = "sgtl5000";\r\npriv->codec_priv.mclk_id = SGTL5000_SYSCLK;\r\npriv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;\r\n} else if (of_device_is_compatible(np, "fsl,imx-audio-wm8962")) {\r\ncodec_dai_name = "wm8962";\r\npriv->card.set_bias_level = fsl_asoc_card_set_bias_level;\r\npriv->codec_priv.mclk_id = WM8962_SYSCLK_MCLK;\r\npriv->codec_priv.fll_id = WM8962_SYSCLK_FLL;\r\npriv->codec_priv.pll_id = WM8962_FLL;\r\npriv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;\r\n} else if (of_device_is_compatible(np, "fsl,imx-audio-wm8960")) {\r\ncodec_dai_name = "wm8960-hifi";\r\npriv->card.set_bias_level = fsl_asoc_card_set_bias_level;\r\npriv->codec_priv.fll_id = WM8960_SYSCLK_AUTO;\r\npriv->codec_priv.pll_id = WM8960_SYSCLK_AUTO;\r\npriv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;\r\n} else if (of_device_is_compatible(np, "fsl,imx-audio-ac97")) {\r\ncodec_dai_name = "ac97-hifi";\r\npriv->card.set_bias_level = NULL;\r\npriv->dai_fmt = SND_SOC_DAIFMT_AC97;\r\n} else {\r\ndev_err(&pdev->dev, "unknown Device Tree compatible\n");\r\nret = -EINVAL;\r\ngoto asrc_fail;\r\n}\r\nif (!fsl_asoc_card_is_ac97(priv) && !codec_dev) {\r\ndev_err(&pdev->dev, "failed to find codec device\n");\r\nret = -EINVAL;\r\ngoto asrc_fail;\r\n}\r\nif (strstr(cpu_np->name, "ssi")) {\r\nret = fsl_asoc_card_audmux_init(np, priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to init audmux\n");\r\ngoto asrc_fail;\r\n}\r\n} else if (strstr(cpu_np->name, "esai")) {\r\npriv->cpu_priv.sysclk_id[1] = ESAI_HCKT_EXTAL;\r\npriv->cpu_priv.sysclk_id[0] = ESAI_HCKR_EXTAL;\r\n} else if (strstr(cpu_np->name, "sai")) {\r\npriv->cpu_priv.sysclk_id[1] = FSL_SAI_CLK_MAST1;\r\npriv->cpu_priv.sysclk_id[0] = FSL_SAI_CLK_MAST1;\r\n}\r\nsnprintf(priv->name, sizeof(priv->name), "%s-audio",\r\nfsl_asoc_card_is_ac97(priv) ? "ac97" :\r\ncodec_dev->name);\r\npriv->pdev = pdev;\r\npriv->card.dev = &pdev->dev;\r\npriv->card.name = priv->name;\r\npriv->card.dai_link = priv->dai_link;\r\npriv->card.dapm_routes = fsl_asoc_card_is_ac97(priv) ?\r\naudio_map_ac97 : audio_map;\r\npriv->card.late_probe = fsl_asoc_card_late_probe;\r\npriv->card.num_dapm_routes = ARRAY_SIZE(audio_map);\r\npriv->card.dapm_widgets = fsl_asoc_card_dapm_widgets;\r\npriv->card.num_dapm_widgets = ARRAY_SIZE(fsl_asoc_card_dapm_widgets);\r\nif (!asrc_pdev)\r\npriv->card.num_dapm_routes /= 2;\r\nmemcpy(priv->dai_link, fsl_asoc_card_dai,\r\nsizeof(struct snd_soc_dai_link) * ARRAY_SIZE(priv->dai_link));\r\nret = snd_soc_of_parse_audio_routing(&priv->card, "audio-routing");\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to parse audio-routing: %d\n", ret);\r\ngoto asrc_fail;\r\n}\r\npriv->dai_link[0].cpu_of_node = cpu_np;\r\npriv->dai_link[0].codec_dai_name = codec_dai_name;\r\nif (!fsl_asoc_card_is_ac97(priv))\r\npriv->dai_link[0].codec_of_node = codec_np;\r\nelse {\r\nu32 idx;\r\nret = of_property_read_u32(cpu_np, "cell-index", &idx);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"cannot get CPU index property\n");\r\ngoto asrc_fail;\r\n}\r\npriv->dai_link[0].codec_name =\r\ndevm_kasprintf(&pdev->dev, GFP_KERNEL,\r\n"ac97-codec.%u",\r\n(unsigned int)idx);\r\n}\r\npriv->dai_link[0].platform_of_node = cpu_np;\r\npriv->dai_link[0].dai_fmt = priv->dai_fmt;\r\npriv->card.num_links = 1;\r\nif (asrc_pdev) {\r\npriv->dai_link[1].cpu_of_node = asrc_np;\r\npriv->dai_link[1].platform_of_node = asrc_np;\r\npriv->dai_link[2].codec_dai_name = codec_dai_name;\r\npriv->dai_link[2].codec_of_node = codec_np;\r\npriv->dai_link[2].codec_name =\r\npriv->dai_link[0].codec_name;\r\npriv->dai_link[2].cpu_of_node = cpu_np;\r\npriv->dai_link[2].dai_fmt = priv->dai_fmt;\r\npriv->card.num_links = 3;\r\nret = of_property_read_u32(asrc_np, "fsl,asrc-rate",\r\n&priv->asrc_rate);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get output rate\n");\r\nret = -EINVAL;\r\ngoto asrc_fail;\r\n}\r\nret = of_property_read_u32(asrc_np, "fsl,asrc-width", &width);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get output rate\n");\r\nret = -EINVAL;\r\ngoto asrc_fail;\r\n}\r\nif (width == 24)\r\npriv->asrc_format = SNDRV_PCM_FORMAT_S24_LE;\r\nelse\r\npriv->asrc_format = SNDRV_PCM_FORMAT_S16_LE;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nsnd_soc_card_set_drvdata(&priv->card, priv);\r\nret = devm_snd_soc_register_card(&pdev->dev, &priv->card);\r\nif (ret)\r\ndev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);\r\nasrc_fail:\r\nof_node_put(asrc_np);\r\nof_node_put(codec_np);\r\nfail:\r\nof_node_put(cpu_np);\r\nreturn ret;\r\n}
