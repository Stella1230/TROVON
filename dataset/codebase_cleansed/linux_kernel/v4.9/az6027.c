static int az6027_usb_in_op(struct dvb_usb_device *d, u8 req,\r\nu16 value, u16 index, u8 *b, int blen)\r\n{\r\nint ret = -1;\r\nif (mutex_lock_interruptible(&d->usb_mutex))\r\nreturn -EAGAIN;\r\nret = usb_control_msg(d->udev,\r\nusb_rcvctrlpipe(d->udev, 0),\r\nreq,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\nvalue,\r\nindex,\r\nb,\r\nblen,\r\n2000);\r\nif (ret < 0) {\r\nwarn("usb in operation failed. (%d)", ret);\r\nret = -EIO;\r\n} else\r\nret = 0;\r\ndeb_xfer("in: req. %02x, val: %04x, ind: %04x, buffer: ", req, value, index);\r\ndebug_dump(b, blen, deb_xfer);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int az6027_usb_out_op(struct dvb_usb_device *d,\r\nu8 req,\r\nu16 value,\r\nu16 index,\r\nu8 *b,\r\nint blen)\r\n{\r\nint ret;\r\ndeb_xfer("out: req. %02x, val: %04x, ind: %04x, buffer: ", req, value, index);\r\ndebug_dump(b, blen, deb_xfer);\r\nif (mutex_lock_interruptible(&d->usb_mutex))\r\nreturn -EAGAIN;\r\nret = usb_control_msg(d->udev,\r\nusb_sndctrlpipe(d->udev, 0),\r\nreq,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\nvalue,\r\nindex,\r\nb,\r\nblen,\r\n2000);\r\nif (ret != blen) {\r\nwarn("usb out operation failed. (%d)", ret);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn -EIO;\r\n} else{\r\nmutex_unlock(&d->usb_mutex);\r\nreturn 0;\r\n}\r\n}\r\nstatic int az6027_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\ndeb_info("%s %d", __func__, onoff);\r\nreq = 0xBC;\r\nvalue = onoff;\r\nindex = 0;\r\nblen = 0;\r\nret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\r\nif (ret != 0)\r\nwarn("usb out operation failed. (%d)", ret);\r\nreturn ret;\r\n}\r\nstatic int az6027_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int az6027_ci_read_attribute_mem(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nint address)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nu8 *b;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nb = kmalloc(12, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC1;\r\nvalue = address;\r\nindex = 0;\r\nblen = 1;\r\nret = az6027_usb_in_op(d, req, value, index, b, blen);\r\nif (ret < 0) {\r\nwarn("usb in operation failed. (%d)", ret);\r\nret = -EINVAL;\r\n} else {\r\nret = b[0];\r\n}\r\nmutex_unlock(&state->ca_mutex);\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic int az6027_ci_write_attribute_mem(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nint address,\r\nu8 value)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\r\nint ret;\r\nu8 req;\r\nu16 value1;\r\nu16 index;\r\nint blen;\r\ndeb_info("%s %d", __func__, slot);\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC2;\r\nvalue1 = address;\r\nindex = value;\r\nblen = 0;\r\nret = az6027_usb_out_op(d, req, value1, index, NULL, blen);\r\nif (ret != 0)\r\nwarn("usb out operation failed. (%d)", ret);\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int az6027_ci_read_cam_control(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nu8 address)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nu8 *b;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nb = kmalloc(12, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC3;\r\nvalue = address;\r\nindex = 0;\r\nblen = 2;\r\nret = az6027_usb_in_op(d, req, value, index, b, blen);\r\nif (ret < 0) {\r\nwarn("usb in operation failed. (%d)", ret);\r\nret = -EINVAL;\r\n} else {\r\nif (b[0] == 0)\r\nwarn("Read CI IO error");\r\nret = b[1];\r\ndeb_info("read cam data = %x from 0x%x", b[1], value);\r\n}\r\nmutex_unlock(&state->ca_mutex);\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic int az6027_ci_write_cam_control(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nu8 address,\r\nu8 value)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\r\nint ret;\r\nu8 req;\r\nu16 value1;\r\nu16 index;\r\nint blen;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC4;\r\nvalue1 = address;\r\nindex = value;\r\nblen = 0;\r\nret = az6027_usb_out_op(d, req, value1, index, NULL, blen);\r\nif (ret != 0) {\r\nwarn("usb out operation failed. (%d)", ret);\r\ngoto failed;\r\n}\r\nfailed:\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int CI_CamReady(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nu8 *b;\r\nb = kmalloc(12, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nreq = 0xC8;\r\nvalue = 0;\r\nindex = 0;\r\nblen = 1;\r\nret = az6027_usb_in_op(d, req, value, index, b, blen);\r\nif (ret < 0) {\r\nwarn("usb in operation failed. (%d)", ret);\r\nret = -EIO;\r\n} else{\r\nret = b[0];\r\n}\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic int az6027_ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\r\nint ret, i;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC6;\r\nvalue = 1;\r\nindex = 0;\r\nblen = 0;\r\nret = az6027_usb_out_op(d, req, value, index, NULL, blen);\r\nif (ret != 0) {\r\nwarn("usb out operation failed. (%d)", ret);\r\ngoto failed;\r\n}\r\nmsleep(500);\r\nreq = 0xC6;\r\nvalue = 0;\r\nindex = 0;\r\nblen = 0;\r\nret = az6027_usb_out_op(d, req, value, index, NULL, blen);\r\nif (ret != 0) {\r\nwarn("usb out operation failed. (%d)", ret);\r\ngoto failed;\r\n}\r\nfor (i = 0; i < 15; i++) {\r\nmsleep(100);\r\nif (CI_CamReady(ca, slot)) {\r\ndeb_info("CAM Ready");\r\nbreak;\r\n}\r\n}\r\nmsleep(5000);\r\nfailed:\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int az6027_ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nreturn 0;\r\n}\r\nstatic int az6027_ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\ndeb_info("%s", __func__);\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC7;\r\nvalue = 1;\r\nindex = 0;\r\nblen = 0;\r\nret = az6027_usb_out_op(d, req, value, index, NULL, blen);\r\nif (ret != 0) {\r\nwarn("usb out operation failed. (%d)", ret);\r\ngoto failed;\r\n}\r\nfailed:\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int az6027_ci_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nu8 *b;\r\nb = kmalloc(12, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC5;\r\nvalue = 0;\r\nindex = 0;\r\nblen = 1;\r\nret = az6027_usb_in_op(d, req, value, index, b, blen);\r\nif (ret < 0) {\r\nwarn("usb in operation failed. (%d)", ret);\r\nret = -EIO;\r\n} else\r\nret = 0;\r\nif (!ret && b[0] == 1) {\r\nret = DVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY;\r\n}\r\nmutex_unlock(&state->ca_mutex);\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic void az6027_ci_uninit(struct dvb_usb_device *d)\r\n{\r\nstruct az6027_device_state *state;\r\ndeb_info("%s", __func__);\r\nif (NULL == d)\r\nreturn;\r\nstate = (struct az6027_device_state *)d->priv;\r\nif (NULL == state)\r\nreturn;\r\nif (NULL == state->ca.data)\r\nreturn;\r\ndvb_ca_en50221_release(&state->ca);\r\nmemset(&state->ca, 0, sizeof(state->ca));\r\n}\r\nstatic int az6027_ci_init(struct dvb_usb_adapter *a)\r\n{\r\nstruct dvb_usb_device *d = a->dev;\r\nstruct az6027_device_state *state = (struct az6027_device_state *)d->priv;\r\nint ret;\r\ndeb_info("%s", __func__);\r\nmutex_init(&state->ca_mutex);\r\nstate->ca.owner = THIS_MODULE;\r\nstate->ca.read_attribute_mem = az6027_ci_read_attribute_mem;\r\nstate->ca.write_attribute_mem = az6027_ci_write_attribute_mem;\r\nstate->ca.read_cam_control = az6027_ci_read_cam_control;\r\nstate->ca.write_cam_control = az6027_ci_write_cam_control;\r\nstate->ca.slot_reset = az6027_ci_slot_reset;\r\nstate->ca.slot_shutdown = az6027_ci_slot_shutdown;\r\nstate->ca.slot_ts_enable = az6027_ci_slot_ts_enable;\r\nstate->ca.poll_slot_status = az6027_ci_poll_slot_status;\r\nstate->ca.data = d;\r\nret = dvb_ca_en50221_init(&a->dvb_adap,\r\n&state->ca,\r\n0,\r\n1);\r\nif (ret != 0) {\r\nerr("Cannot initialize CI: Error %d.", ret);\r\nmemset(&state->ca, 0, sizeof(state->ca));\r\nreturn ret;\r\n}\r\ndeb_info("CI initialized.");\r\nreturn 0;\r\n}\r\nstatic int az6027_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nu8 buf;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct i2c_msg i2c_msg = {\r\n.addr = 0x99,\r\n.flags = 0,\r\n.buf = &buf,\r\n.len = 1\r\n};\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\nbuf = 1;\r\ni2c_transfer(&adap->dev->i2c_adap, &i2c_msg, 1);\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\nbuf = 2;\r\ni2c_transfer(&adap->dev->i2c_adap, &i2c_msg, 1);\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nbuf = 0;\r\ni2c_transfer(&adap->dev->i2c_adap, &i2c_msg, 1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int az6027_frontend_poweron(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nreq = 0xBC;\r\nvalue = 1;\r\nindex = 3;\r\nblen = 0;\r\nret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\r\nif (ret != 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int az6027_frontend_reset(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nreq = 0xC0;\r\nvalue = 1;\r\nindex = 3;\r\nblen = 0;\r\nret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\r\nif (ret != 0)\r\nreturn -EIO;\r\nreq = 0xC0;\r\nvalue = 0;\r\nindex = 3;\r\nblen = 0;\r\nmsleep_interruptible(200);\r\nret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\r\nif (ret != 0)\r\nreturn -EIO;\r\nmsleep_interruptible(200);\r\nreq = 0xC0;\r\nvalue = 1;\r\nindex = 3;\r\nblen = 0;\r\nret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\r\nif (ret != 0)\r\nreturn -EIO;\r\nmsleep_interruptible(200);\r\nreturn 0;\r\n}\r\nstatic int az6027_frontend_tsbypass(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nreq = 0xC7;\r\nvalue = onoff;\r\nindex = 0;\r\nblen = 0;\r\nret = az6027_usb_out_op(adap->dev, req, value, index, NULL, blen);\r\nif (ret != 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int az6027_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\naz6027_frontend_poweron(adap);\r\naz6027_frontend_reset(adap);\r\ndeb_info("adap = %p, dev = %p\n", adap, adap->dev);\r\nadap->fe_adap[0].fe = stb0899_attach(&az6027_stb0899_config, &adap->dev->i2c_adap);\r\nif (adap->fe_adap[0].fe) {\r\ndeb_info("found STB0899 DVB-S/DVB-S2 frontend @0x%02x", az6027_stb0899_config.demod_address);\r\nif (stb6100_attach(adap->fe_adap[0].fe, &az6027_stb6100_config, &adap->dev->i2c_adap)) {\r\ndeb_info("found STB6100 DVB-S/DVB-S2 frontend @0x%02x", az6027_stb6100_config.tuner_address);\r\nadap->fe_adap[0].fe->ops.set_voltage = az6027_set_voltage;\r\naz6027_ci_init(adap);\r\n} else {\r\nadap->fe_adap[0].fe = NULL;\r\n}\r\n} else\r\nwarn("no front-end attached\n");\r\naz6027_frontend_tsbypass(adap, 0);\r\nreturn 0;\r\n}\r\nstatic void az6027_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\naz6027_ci_uninit(d);\r\ndvb_usb_device_exit(intf);\r\n}\r\nstatic int az6027_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn dvb_usb_device_init(intf,\r\n&az6027_properties,\r\nTHIS_MODULE,\r\nNULL,\r\nadapter_nr);\r\n}\r\nstatic int az6027_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i = 0, j = 0, len = 0;\r\nu16 index;\r\nu16 value;\r\nint length;\r\nu8 req;\r\nu8 *data;\r\ndata = kmalloc(256, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0) {\r\nkfree(data);\r\nreturn -EAGAIN;\r\n}\r\nif (num > 2)\r\nwarn("more than 2 i2c messages at a time is not handled yet. TODO.");\r\nfor (i = 0; i < num; i++) {\r\nif (msg[i].addr == 0x99) {\r\nreq = 0xBE;\r\nindex = 0;\r\nvalue = msg[i].buf[0] & 0x00ff;\r\nlength = 1;\r\naz6027_usb_out_op(d, req, value, index, data, length);\r\n}\r\nif (msg[i].addr == 0xd0) {\r\nif (i + 1 < num && (msg[i + 1].flags & I2C_M_RD)) {\r\nreq = 0xB9;\r\nindex = (((msg[i].buf[0] << 8) & 0xff00) | (msg[i].buf[1] & 0x00ff));\r\nvalue = msg[i].addr + (msg[i].len << 8);\r\nlength = msg[i + 1].len + 6;\r\naz6027_usb_in_op(d, req, value, index, data, length);\r\nlen = msg[i + 1].len;\r\nfor (j = 0; j < len; j++)\r\nmsg[i + 1].buf[j] = data[j + 5];\r\ni++;\r\n} else {\r\nreq = 0xBD;\r\nindex = (((msg[i].buf[0] << 8) & 0xff00) | (msg[i].buf[1] & 0x00ff));\r\nvalue = msg[i].addr + (2 << 8);\r\nlength = msg[i].len - 2;\r\nlen = msg[i].len - 2;\r\nfor (j = 0; j < len; j++)\r\ndata[j] = msg[i].buf[j + 2];\r\naz6027_usb_out_op(d, req, value, index, data, length);\r\n}\r\n}\r\nif (msg[i].addr == 0xc0) {\r\nif (msg[i].flags & I2C_M_RD) {\r\nreq = 0xB9;\r\nindex = 0x0;\r\nvalue = msg[i].addr;\r\nlength = msg[i].len + 6;\r\naz6027_usb_in_op(d, req, value, index, data, length);\r\nlen = msg[i].len;\r\nfor (j = 0; j < len; j++)\r\nmsg[i].buf[j] = data[j + 5];\r\n} else {\r\nreq = 0xBD;\r\nindex = msg[i].buf[0] & 0x00FF;\r\nvalue = msg[i].addr + (1 << 8);\r\nlength = msg[i].len - 1;\r\nlen = msg[i].len - 1;\r\nfor (j = 0; j < len; j++)\r\ndata[j] = msg[i].buf[j + 1];\r\naz6027_usb_out_op(d, req, value, index, data, length);\r\n}\r\n}\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nkfree(data);\r\nreturn i;\r\n}\r\nstatic u32 az6027_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int az6027_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\nu8 *b;\r\ns16 ret;\r\nb = kmalloc(16, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, 0),\r\n0xb7,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\n6,\r\n0,\r\nb,\r\n6,\r\nUSB_CTRL_GET_TIMEOUT);\r\n*cold = ret <= 0;\r\nkfree(b);\r\ndeb_info("cold: %d\n", *cold);\r\nreturn 0;\r\n}
