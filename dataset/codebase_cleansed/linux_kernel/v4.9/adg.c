static u32 rsnd_adg_calculate_rbgx(unsigned long div)\r\n{\r\nint i, ratio;\r\nif (!div)\r\nreturn 0;\r\nfor (i = 3; i >= 0; i--) {\r\nratio = 2 << (i * 2);\r\nif (0 == (div % ratio))\r\nreturn (u32)((i << 8) | ((div / ratio) - 1));\r\n}\r\nreturn ~0;\r\n}\r\nstatic u32 rsnd_adg_ssi_ws_timing_gen2(struct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);\r\nint id = rsnd_mod_id(ssi_mod);\r\nint ws = id;\r\nif (rsnd_ssi_is_pin_sharing(io)) {\r\nswitch (id) {\r\ncase 1:\r\ncase 2:\r\nws = 0;\r\nbreak;\r\ncase 4:\r\nws = 3;\r\nbreak;\r\ncase 8:\r\nws = 7;\r\nbreak;\r\n}\r\n}\r\nreturn (0x6 + ws) << 8;\r\n}\r\nstatic void __rsnd_adg_get_timesel_ratio(struct rsnd_priv *priv,\r\nstruct rsnd_dai_stream *io,\r\nunsigned int target_rate,\r\nunsigned int *target_val,\r\nunsigned int *target_en)\r\n{\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nint idx, sel, div, step;\r\nunsigned int val, en;\r\nunsigned int min, diff;\r\nunsigned int sel_rate[] = {\r\nclk_get_rate(adg->clk[CLKA]),\r\nclk_get_rate(adg->clk[CLKB]),\r\nclk_get_rate(adg->clk[CLKC]),\r\nadg->rbga_rate_for_441khz,\r\nadg->rbgb_rate_for_48khz,\r\n};\r\nmin = ~0;\r\nval = 0;\r\nen = 0;\r\nfor (sel = 0; sel < ARRAY_SIZE(sel_rate); sel++) {\r\nidx = 0;\r\nstep = 2;\r\nif (!sel_rate[sel])\r\ncontinue;\r\nfor (div = 2; div <= 98304; div += step) {\r\ndiff = abs(target_rate - sel_rate[sel] / div);\r\nif (min > diff) {\r\nval = (sel << 8) | idx;\r\nmin = diff;\r\nen = 1 << (sel + 1);\r\n}\r\nif ((idx > 2) && (idx % 2))\r\nstep *= 2;\r\nif (idx == 0x1c) {\r\ndiv += step;\r\nstep *= 2;\r\n}\r\nidx++;\r\n}\r\n}\r\nif (min == ~0) {\r\ndev_err(dev, "no Input clock\n");\r\nreturn;\r\n}\r\n*target_val = val;\r\nif (target_en)\r\n*target_en = en;\r\n}\r\nstatic void rsnd_adg_get_timesel_ratio(struct rsnd_priv *priv,\r\nstruct rsnd_dai_stream *io,\r\nunsigned int in_rate,\r\nunsigned int out_rate,\r\nu32 *in, u32 *out, u32 *en)\r\n{\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nunsigned int target_rate;\r\nu32 *target_val;\r\nu32 _in;\r\nu32 _out;\r\nu32 _en;\r\n_in =\r\n_out = rsnd_adg_ssi_ws_timing_gen2(io);\r\ntarget_rate = 0;\r\ntarget_val = NULL;\r\n_en = 0;\r\nif (runtime->rate != in_rate) {\r\ntarget_rate = out_rate;\r\ntarget_val = &_out;\r\n} else if (runtime->rate != out_rate) {\r\ntarget_rate = in_rate;\r\ntarget_val = &_in;\r\n}\r\nif (target_rate)\r\n__rsnd_adg_get_timesel_ratio(priv, io,\r\ntarget_rate,\r\ntarget_val, &_en);\r\nif (in)\r\n*in = _in;\r\nif (out)\r\n*out = _out;\r\nif (en)\r\n*en = _en;\r\n}\r\nint rsnd_adg_set_cmd_timsel_gen2(struct rsnd_mod *cmd_mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(cmd_mod);\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\r\nint id = rsnd_mod_id(cmd_mod);\r\nint shift = (id % 2) ? 16 : 0;\r\nu32 mask, val;\r\nrsnd_adg_get_timesel_ratio(priv, io,\r\nrsnd_src_get_in_rate(priv, io),\r\nrsnd_src_get_out_rate(priv, io),\r\nNULL, &val, NULL);\r\nval = val << shift;\r\nmask = 0xffff << shift;\r\nrsnd_mod_bset(adg_mod, CMDOUT_TIMSEL, mask, val);\r\nreturn 0;\r\n}\r\nint rsnd_adg_set_src_timesel_gen2(struct rsnd_mod *src_mod,\r\nstruct rsnd_dai_stream *io,\r\nunsigned int in_rate,\r\nunsigned int out_rate)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(src_mod);\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\r\nu32 in, out;\r\nu32 mask, en;\r\nint id = rsnd_mod_id(src_mod);\r\nint shift = (id % 2) ? 16 : 0;\r\nrsnd_mod_confirm_src(src_mod);\r\nrsnd_adg_get_timesel_ratio(priv, io,\r\nin_rate, out_rate,\r\n&in, &out, &en);\r\nin = in << shift;\r\nout = out << shift;\r\nmask = 0xffff << shift;\r\nswitch (id / 2) {\r\ncase 0:\r\nrsnd_mod_bset(adg_mod, SRCIN_TIMSEL0, mask, in);\r\nrsnd_mod_bset(adg_mod, SRCOUT_TIMSEL0, mask, out);\r\nbreak;\r\ncase 1:\r\nrsnd_mod_bset(adg_mod, SRCIN_TIMSEL1, mask, in);\r\nrsnd_mod_bset(adg_mod, SRCOUT_TIMSEL1, mask, out);\r\nbreak;\r\ncase 2:\r\nrsnd_mod_bset(adg_mod, SRCIN_TIMSEL2, mask, in);\r\nrsnd_mod_bset(adg_mod, SRCOUT_TIMSEL2, mask, out);\r\nbreak;\r\ncase 3:\r\nrsnd_mod_bset(adg_mod, SRCIN_TIMSEL3, mask, in);\r\nrsnd_mod_bset(adg_mod, SRCOUT_TIMSEL3, mask, out);\r\nbreak;\r\ncase 4:\r\nrsnd_mod_bset(adg_mod, SRCIN_TIMSEL4, mask, in);\r\nrsnd_mod_bset(adg_mod, SRCOUT_TIMSEL4, mask, out);\r\nbreak;\r\n}\r\nif (en)\r\nrsnd_mod_bset(adg_mod, DIV_EN, en, en);\r\nreturn 0;\r\n}\r\nstatic void rsnd_adg_set_ssi_clk(struct rsnd_mod *ssi_mod, u32 val)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(ssi_mod);\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\r\nint id = rsnd_mod_id(ssi_mod);\r\nint shift = (id % 4) * 8;\r\nu32 mask = 0xFF << shift;\r\nrsnd_mod_confirm_ssi(ssi_mod);\r\nval = val << shift;\r\nif (id == 8)\r\nreturn;\r\nswitch (id / 4) {\r\ncase 0:\r\nrsnd_mod_bset(adg_mod, AUDIO_CLK_SEL0, mask, val);\r\nbreak;\r\ncase 1:\r\nrsnd_mod_bset(adg_mod, AUDIO_CLK_SEL1, mask, val);\r\nbreak;\r\ncase 2:\r\nrsnd_mod_bset(adg_mod, AUDIO_CLK_SEL2, mask, val);\r\nbreak;\r\n}\r\n}\r\nint rsnd_adg_ssi_clk_stop(struct rsnd_mod *ssi_mod)\r\n{\r\nrsnd_adg_set_ssi_clk(ssi_mod, 0);\r\nreturn 0;\r\n}\r\nint rsnd_adg_ssi_clk_try_start(struct rsnd_mod *ssi_mod, unsigned int rate)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(ssi_mod);\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct clk *clk;\r\nint i;\r\nu32 data;\r\nint sel_table[] = {\r\n[CLKA] = 0x1,\r\n[CLKB] = 0x2,\r\n[CLKC] = 0x3,\r\n[CLKI] = 0x0,\r\n};\r\ndev_dbg(dev, "request clock = %d\n", rate);\r\ndata = 0;\r\nfor_each_rsnd_clk(clk, adg, i) {\r\nif (rate == clk_get_rate(clk)) {\r\ndata = sel_table[i];\r\ngoto found_clock;\r\n}\r\n}\r\nif (rate == adg->rbga_rate_for_441khz) {\r\ndata = 0x10;\r\ngoto found_clock;\r\n}\r\nif (rate == adg->rbgb_rate_for_48khz) {\r\ndata = 0x20;\r\ngoto found_clock;\r\n}\r\nreturn -EIO;\r\nfound_clock:\r\nrsnd_adg_set_ssi_clk(ssi_mod, data);\r\nif (!(adg_mode_flags(adg) & LRCLK_ASYNC)) {\r\nstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\r\nu32 ckr = 0;\r\nif (0 == (rate % 8000))\r\nckr = 0x80000000;\r\nrsnd_mod_bset(adg_mod, SSICKR, 0x80000000, ckr);\r\n}\r\ndev_dbg(dev, "ADG: %s[%d] selects 0x%x for %d\n",\r\nrsnd_mod_name(ssi_mod), rsnd_mod_id(ssi_mod),\r\ndata, rate);\r\nreturn 0;\r\n}\r\nstatic void rsnd_adg_get_clkin(struct rsnd_priv *priv,\r\nstruct rsnd_adg *adg)\r\n{\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct clk *clk;\r\nstatic const char * const clk_name[] = {\r\n[CLKA] = "clk_a",\r\n[CLKB] = "clk_b",\r\n[CLKC] = "clk_c",\r\n[CLKI] = "clk_i",\r\n};\r\nint i, ret;\r\nfor (i = 0; i < CLKMAX; i++) {\r\nclk = devm_clk_get(dev, clk_name[i]);\r\nadg->clk[i] = IS_ERR(clk) ? NULL : clk;\r\n}\r\nfor_each_rsnd_clk(clk, adg, i) {\r\nret = clk_prepare_enable(clk);\r\nif (ret < 0)\r\ndev_warn(dev, "can't use clk %d\n", i);\r\ndev_dbg(dev, "clk %d : %p : %ld\n", i, clk, clk_get_rate(clk));\r\n}\r\n}\r\nstatic void rsnd_adg_get_clkout(struct rsnd_priv *priv,\r\nstruct rsnd_adg *adg)\r\n{\r\nstruct clk *clk;\r\nstruct rsnd_mod *adg_mod = rsnd_mod_get(adg);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct device_node *np = dev->of_node;\r\nu32 ckr, rbgx, rbga, rbgb;\r\nu32 rate, req_rate = 0, div;\r\nuint32_t count = 0;\r\nunsigned long req_48kHz_rate, req_441kHz_rate;\r\nint i;\r\nconst char *parent_clk_name = NULL;\r\nstatic const char * const clkout_name[] = {\r\n[CLKOUT] = "audio_clkout",\r\n[CLKOUT1] = "audio_clkout1",\r\n[CLKOUT2] = "audio_clkout2",\r\n[CLKOUT3] = "audio_clkout3",\r\n};\r\nint brg_table[] = {\r\n[CLKA] = 0x0,\r\n[CLKB] = 0x1,\r\n[CLKC] = 0x4,\r\n[CLKI] = 0x2,\r\n};\r\nof_property_read_u32(np, "#clock-cells", &count);\r\nof_property_read_u32(np, "clock-frequency", &req_rate);\r\nreq_48kHz_rate = 0;\r\nreq_441kHz_rate = 0;\r\nif (0 == (req_rate % 44100))\r\nreq_441kHz_rate = req_rate;\r\nif (0 == (req_rate % 48000))\r\nreq_48kHz_rate = req_rate;\r\nckr = 0;\r\nrbga = 2;\r\nrbgb = 2;\r\nadg->rbga_rate_for_441khz = 0;\r\nadg->rbgb_rate_for_48khz = 0;\r\nfor_each_rsnd_clk(clk, adg, i) {\r\nrate = clk_get_rate(clk);\r\nif (0 == rate)\r\ncontinue;\r\nif (!adg->rbga_rate_for_441khz && (0 == rate % 44100)) {\r\ndiv = 6;\r\nif (req_441kHz_rate)\r\ndiv = rate / req_441kHz_rate;\r\nrbgx = rsnd_adg_calculate_rbgx(div);\r\nif (BRRx_MASK(rbgx) == rbgx) {\r\nrbga = rbgx;\r\nadg->rbga_rate_for_441khz = rate / div;\r\nckr |= brg_table[i] << 20;\r\nif (req_441kHz_rate)\r\nparent_clk_name = __clk_get_name(clk);\r\n}\r\n}\r\nif (!adg->rbgb_rate_for_48khz && (0 == rate % 48000)) {\r\ndiv = 6;\r\nif (req_48kHz_rate)\r\ndiv = rate / req_48kHz_rate;\r\nrbgx = rsnd_adg_calculate_rbgx(div);\r\nif (BRRx_MASK(rbgx) == rbgx) {\r\nrbgb = rbgx;\r\nadg->rbgb_rate_for_48khz = rate / div;\r\nckr |= brg_table[i] << 16;\r\nif (req_48kHz_rate) {\r\nparent_clk_name = __clk_get_name(clk);\r\nckr |= 0x80000000;\r\n}\r\n}\r\n}\r\n}\r\nif (!count) {\r\nclk = clk_register_fixed_rate(dev, clkout_name[CLKOUT],\r\nparent_clk_name, 0, req_rate);\r\nif (!IS_ERR(clk)) {\r\nadg->clkout[CLKOUT] = clk;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\n}\r\nelse {\r\nfor (i = 0; i < CLKOUTMAX; i++) {\r\nclk = clk_register_fixed_rate(dev, clkout_name[i],\r\nparent_clk_name, 0,\r\nreq_rate);\r\nif (!IS_ERR(clk)) {\r\nadg->onecell.clks = adg->clkout;\r\nadg->onecell.clk_num = CLKOUTMAX;\r\nadg->clkout[i] = clk;\r\nof_clk_add_provider(np, of_clk_src_onecell_get,\r\n&adg->onecell);\r\n}\r\n}\r\n}\r\nrsnd_mod_bset(adg_mod, SSICKR, 0x80FF0000, ckr);\r\nrsnd_mod_write(adg_mod, BRRA, rbga);\r\nrsnd_mod_write(adg_mod, BRRB, rbgb);\r\nfor_each_rsnd_clkout(clk, adg, i)\r\ndev_dbg(dev, "clkout %d : %p : %ld\n", i, clk, clk_get_rate(clk));\r\ndev_dbg(dev, "SSICKR = 0x%08x, BRRA/BRRB = 0x%x/0x%x\n",\r\nckr, rbga, rbgb);\r\n}\r\nint rsnd_adg_probe(struct rsnd_priv *priv)\r\n{\r\nstruct rsnd_adg *adg;\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct device_node *np = dev->of_node;\r\nadg = devm_kzalloc(dev, sizeof(*adg), GFP_KERNEL);\r\nif (!adg) {\r\ndev_err(dev, "ADG allocate failed\n");\r\nreturn -ENOMEM;\r\n}\r\nrsnd_mod_init(priv, &adg->mod, &adg_ops,\r\nNULL, NULL, 0, 0);\r\nrsnd_adg_get_clkin(priv, adg);\r\nrsnd_adg_get_clkout(priv, adg);\r\nif (of_get_property(np, "clkout-lr-asynchronous", NULL))\r\nadg->flags = LRCLK_ASYNC;\r\npriv->adg = adg;\r\nreturn 0;\r\n}\r\nvoid rsnd_adg_remove(struct rsnd_priv *priv)\r\n{\r\nstruct rsnd_adg *adg = rsnd_priv_to_adg(priv);\r\nstruct clk *clk;\r\nint i;\r\nfor_each_rsnd_clk(clk, adg, i) {\r\nclk_disable_unprepare(clk);\r\n}\r\n}
