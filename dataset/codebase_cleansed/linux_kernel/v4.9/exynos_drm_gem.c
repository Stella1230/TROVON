static int exynos_drm_alloc_buf(struct exynos_drm_gem *exynos_gem)\r\n{\r\nstruct drm_device *dev = exynos_gem->base.dev;\r\nunsigned long attr;\r\nunsigned int nr_pages;\r\nstruct sg_table sgt;\r\nint ret = -ENOMEM;\r\nif (exynos_gem->dma_addr) {\r\nDRM_DEBUG_KMS("already allocated.\n");\r\nreturn 0;\r\n}\r\nexynos_gem->dma_attrs = 0;\r\nif (!(exynos_gem->flags & EXYNOS_BO_NONCONTIG))\r\nexynos_gem->dma_attrs |= DMA_ATTR_FORCE_CONTIGUOUS;\r\nif (exynos_gem->flags & EXYNOS_BO_WC ||\r\n!(exynos_gem->flags & EXYNOS_BO_CACHABLE))\r\nattr = DMA_ATTR_WRITE_COMBINE;\r\nelse\r\nattr = DMA_ATTR_NON_CONSISTENT;\r\nexynos_gem->dma_attrs |= attr;\r\nexynos_gem->dma_attrs |= DMA_ATTR_NO_KERNEL_MAPPING;\r\nnr_pages = exynos_gem->size >> PAGE_SHIFT;\r\nexynos_gem->pages = drm_calloc_large(nr_pages, sizeof(struct page *));\r\nif (!exynos_gem->pages) {\r\nDRM_ERROR("failed to allocate pages.\n");\r\nreturn -ENOMEM;\r\n}\r\nexynos_gem->cookie = dma_alloc_attrs(to_dma_dev(dev), exynos_gem->size,\r\n&exynos_gem->dma_addr, GFP_KERNEL,\r\nexynos_gem->dma_attrs);\r\nif (!exynos_gem->cookie) {\r\nDRM_ERROR("failed to allocate buffer.\n");\r\ngoto err_free;\r\n}\r\nret = dma_get_sgtable_attrs(to_dma_dev(dev), &sgt, exynos_gem->cookie,\r\nexynos_gem->dma_addr, exynos_gem->size,\r\nexynos_gem->dma_attrs);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to get sgtable.\n");\r\ngoto err_dma_free;\r\n}\r\nif (drm_prime_sg_to_page_addr_arrays(&sgt, exynos_gem->pages, NULL,\r\nnr_pages)) {\r\nDRM_ERROR("invalid sgtable.\n");\r\nret = -EINVAL;\r\ngoto err_sgt_free;\r\n}\r\nsg_free_table(&sgt);\r\nDRM_DEBUG_KMS("dma_addr(0x%lx), size(0x%lx)\n",\r\n(unsigned long)exynos_gem->dma_addr, exynos_gem->size);\r\nreturn 0;\r\nerr_sgt_free:\r\nsg_free_table(&sgt);\r\nerr_dma_free:\r\ndma_free_attrs(to_dma_dev(dev), exynos_gem->size, exynos_gem->cookie,\r\nexynos_gem->dma_addr, exynos_gem->dma_attrs);\r\nerr_free:\r\ndrm_free_large(exynos_gem->pages);\r\nreturn ret;\r\n}\r\nstatic void exynos_drm_free_buf(struct exynos_drm_gem *exynos_gem)\r\n{\r\nstruct drm_device *dev = exynos_gem->base.dev;\r\nif (!exynos_gem->dma_addr) {\r\nDRM_DEBUG_KMS("dma_addr is invalid.\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("dma_addr(0x%lx), size(0x%lx)\n",\r\n(unsigned long)exynos_gem->dma_addr, exynos_gem->size);\r\ndma_free_attrs(to_dma_dev(dev), exynos_gem->size, exynos_gem->cookie,\r\n(dma_addr_t)exynos_gem->dma_addr,\r\nexynos_gem->dma_attrs);\r\ndrm_free_large(exynos_gem->pages);\r\n}\r\nstatic int exynos_drm_gem_handle_create(struct drm_gem_object *obj,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nint ret;\r\nret = drm_gem_handle_create(file_priv, obj, handle);\r\nif (ret)\r\nreturn ret;\r\nDRM_DEBUG_KMS("gem handle = 0x%x\n", *handle);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn 0;\r\n}\r\nvoid exynos_drm_gem_destroy(struct exynos_drm_gem *exynos_gem)\r\n{\r\nstruct drm_gem_object *obj = &exynos_gem->base;\r\nDRM_DEBUG_KMS("handle count = %d\n", obj->handle_count);\r\nif (obj->import_attach)\r\ndrm_prime_gem_destroy(obj, exynos_gem->sgt);\r\nelse\r\nexynos_drm_free_buf(exynos_gem);\r\ndrm_gem_object_release(obj);\r\nkfree(exynos_gem);\r\n}\r\nunsigned long exynos_drm_gem_get_size(struct drm_device *dev,\r\nunsigned int gem_handle,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct exynos_drm_gem *exynos_gem;\r\nstruct drm_gem_object *obj;\r\nobj = drm_gem_object_lookup(file_priv, gem_handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn 0;\r\n}\r\nexynos_gem = to_exynos_gem(obj);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn exynos_gem->size;\r\n}\r\nstatic struct exynos_drm_gem *exynos_drm_gem_init(struct drm_device *dev,\r\nunsigned long size)\r\n{\r\nstruct exynos_drm_gem *exynos_gem;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nexynos_gem = kzalloc(sizeof(*exynos_gem), GFP_KERNEL);\r\nif (!exynos_gem)\r\nreturn ERR_PTR(-ENOMEM);\r\nexynos_gem->size = size;\r\nobj = &exynos_gem->base;\r\nret = drm_gem_object_init(dev, obj, size);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to initialize gem object\n");\r\nkfree(exynos_gem);\r\nreturn ERR_PTR(ret);\r\n}\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret < 0) {\r\ndrm_gem_object_release(obj);\r\nkfree(exynos_gem);\r\nreturn ERR_PTR(ret);\r\n}\r\nDRM_DEBUG_KMS("created file object = %p\n", obj->filp);\r\nreturn exynos_gem;\r\n}\r\nstruct exynos_drm_gem *exynos_drm_gem_create(struct drm_device *dev,\r\nunsigned int flags,\r\nunsigned long size)\r\n{\r\nstruct exynos_drm_gem *exynos_gem;\r\nint ret;\r\nif (flags & ~(EXYNOS_BO_MASK)) {\r\nDRM_ERROR("invalid flags.\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!size) {\r\nDRM_ERROR("invalid size.\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nsize = roundup(size, PAGE_SIZE);\r\nexynos_gem = exynos_drm_gem_init(dev, size);\r\nif (IS_ERR(exynos_gem))\r\nreturn exynos_gem;\r\nexynos_gem->flags = flags;\r\nret = exynos_drm_alloc_buf(exynos_gem);\r\nif (ret < 0) {\r\ndrm_gem_object_release(&exynos_gem->base);\r\nkfree(exynos_gem);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn exynos_gem;\r\n}\r\nint exynos_drm_gem_create_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_exynos_gem_create *args = data;\r\nstruct exynos_drm_gem *exynos_gem;\r\nint ret;\r\nexynos_gem = exynos_drm_gem_create(dev, args->flags, args->size);\r\nif (IS_ERR(exynos_gem))\r\nreturn PTR_ERR(exynos_gem);\r\nret = exynos_drm_gem_handle_create(&exynos_gem->base, file_priv,\r\n&args->handle);\r\nif (ret) {\r\nexynos_drm_gem_destroy(exynos_gem);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint exynos_drm_gem_map_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_exynos_gem_map *args = data;\r\nreturn exynos_drm_gem_dumb_map_offset(file_priv, dev, args->handle,\r\n&args->offset);\r\n}\r\ndma_addr_t *exynos_drm_gem_get_dma_addr(struct drm_device *dev,\r\nunsigned int gem_handle,\r\nstruct drm_file *filp)\r\n{\r\nstruct exynos_drm_gem *exynos_gem;\r\nstruct drm_gem_object *obj;\r\nobj = drm_gem_object_lookup(filp, gem_handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nexynos_gem = to_exynos_gem(obj);\r\nreturn &exynos_gem->dma_addr;\r\n}\r\nvoid exynos_drm_gem_put_dma_addr(struct drm_device *dev,\r\nunsigned int gem_handle,\r\nstruct drm_file *filp)\r\n{\r\nstruct drm_gem_object *obj;\r\nobj = drm_gem_object_lookup(filp, gem_handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn;\r\n}\r\ndrm_gem_object_unreference_unlocked(obj);\r\ndrm_gem_object_unreference_unlocked(obj);\r\n}\r\nstatic int exynos_drm_gem_mmap_buffer(struct exynos_drm_gem *exynos_gem,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct drm_device *drm_dev = exynos_gem->base.dev;\r\nunsigned long vm_size;\r\nint ret;\r\nvma->vm_flags &= ~VM_PFNMAP;\r\nvma->vm_pgoff = 0;\r\nvm_size = vma->vm_end - vma->vm_start;\r\nif (vm_size > exynos_gem->size)\r\nreturn -EINVAL;\r\nret = dma_mmap_attrs(to_dma_dev(drm_dev), vma, exynos_gem->cookie,\r\nexynos_gem->dma_addr, exynos_gem->size,\r\nexynos_gem->dma_attrs);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to mmap.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint exynos_drm_gem_get_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct exynos_drm_gem *exynos_gem;\r\nstruct drm_exynos_gem_info *args = data;\r\nstruct drm_gem_object *obj;\r\nobj = drm_gem_object_lookup(file_priv, args->handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn -EINVAL;\r\n}\r\nexynos_gem = to_exynos_gem(obj);\r\nargs->flags = exynos_gem->flags;\r\nargs->size = exynos_gem->size;\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn 0;\r\n}\r\nvoid exynos_drm_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nexynos_drm_gem_destroy(to_exynos_gem(obj));\r\n}\r\nint exynos_drm_gem_dumb_create(struct drm_file *file_priv,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct exynos_drm_gem *exynos_gem;\r\nunsigned int flags;\r\nint ret;\r\nargs->pitch = args->width * ((args->bpp + 7) / 8);\r\nargs->size = args->pitch * args->height;\r\nif (is_drm_iommu_supported(dev))\r\nflags = EXYNOS_BO_NONCONTIG | EXYNOS_BO_WC;\r\nelse\r\nflags = EXYNOS_BO_CONTIG | EXYNOS_BO_WC;\r\nexynos_gem = exynos_drm_gem_create(dev, flags, args->size);\r\nif (IS_ERR(exynos_gem)) {\r\ndev_warn(dev->dev, "FB allocation failed.\n");\r\nreturn PTR_ERR(exynos_gem);\r\n}\r\nret = exynos_drm_gem_handle_create(&exynos_gem->base, file_priv,\r\n&args->handle);\r\nif (ret) {\r\nexynos_drm_gem_destroy(exynos_gem);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint exynos_drm_gem_dumb_map_offset(struct drm_file *file_priv,\r\nstruct drm_device *dev, uint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret = 0;\r\nobj = drm_gem_object_lookup(file_priv, handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn -EINVAL;\r\n}\r\n*offset = drm_vma_node_offset_addr(&obj->vma_node);\r\nDRM_DEBUG_KMS("offset = 0x%lx\n", (unsigned long)*offset);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nint exynos_drm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_gem_object *obj = vma->vm_private_data;\r\nstruct exynos_drm_gem *exynos_gem = to_exynos_gem(obj);\r\nunsigned long pfn;\r\npgoff_t page_offset;\r\nint ret;\r\npage_offset = ((unsigned long)vmf->virtual_address -\r\nvma->vm_start) >> PAGE_SHIFT;\r\nif (page_offset >= (exynos_gem->size >> PAGE_SHIFT)) {\r\nDRM_ERROR("invalid page offset\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npfn = page_to_pfn(exynos_gem->pages[page_offset]);\r\nret = vm_insert_mixed(vma, (unsigned long)vmf->virtual_address,\r\n__pfn_to_pfn_t(pfn, PFN_DEV));\r\nout:\r\nswitch (ret) {\r\ncase 0:\r\ncase -ERESTARTSYS:\r\ncase -EINTR:\r\nreturn VM_FAULT_NOPAGE;\r\ncase -ENOMEM:\r\nreturn VM_FAULT_OOM;\r\ndefault:\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\n}\r\nstatic int exynos_drm_gem_mmap_obj(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct exynos_drm_gem *exynos_gem = to_exynos_gem(obj);\r\nint ret;\r\nDRM_DEBUG_KMS("flags = 0x%x\n", exynos_gem->flags);\r\nif (exynos_gem->flags & EXYNOS_BO_CACHABLE)\r\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\r\nelse if (exynos_gem->flags & EXYNOS_BO_WC)\r\nvma->vm_page_prot =\r\npgprot_writecombine(vm_get_page_prot(vma->vm_flags));\r\nelse\r\nvma->vm_page_prot =\r\npgprot_noncached(vm_get_page_prot(vma->vm_flags));\r\nret = exynos_drm_gem_mmap_buffer(exynos_gem, vma);\r\nif (ret)\r\ngoto err_close_vm;\r\nreturn ret;\r\nerr_close_vm:\r\ndrm_gem_vm_close(vma);\r\nreturn ret;\r\n}\r\nint exynos_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to mmap.\n");\r\nreturn ret;\r\n}\r\nobj = vma->vm_private_data;\r\nif (obj->import_attach)\r\nreturn dma_buf_mmap(obj->dma_buf, vma, 0);\r\nreturn exynos_drm_gem_mmap_obj(obj, vma);\r\n}\r\nstruct sg_table *exynos_drm_gem_prime_get_sg_table(struct drm_gem_object *obj)\r\n{\r\nstruct exynos_drm_gem *exynos_gem = to_exynos_gem(obj);\r\nint npages;\r\nnpages = exynos_gem->size >> PAGE_SHIFT;\r\nreturn drm_prime_pages_to_sg(exynos_gem->pages, npages);\r\n}\r\nstruct drm_gem_object *\r\nexynos_drm_gem_prime_import_sg_table(struct drm_device *dev,\r\nstruct dma_buf_attachment *attach,\r\nstruct sg_table *sgt)\r\n{\r\nstruct exynos_drm_gem *exynos_gem;\r\nint npages;\r\nint ret;\r\nexynos_gem = exynos_drm_gem_init(dev, attach->dmabuf->size);\r\nif (IS_ERR(exynos_gem)) {\r\nret = PTR_ERR(exynos_gem);\r\nreturn ERR_PTR(ret);\r\n}\r\nexynos_gem->dma_addr = sg_dma_address(sgt->sgl);\r\nnpages = exynos_gem->size >> PAGE_SHIFT;\r\nexynos_gem->pages = drm_malloc_ab(npages, sizeof(struct page *));\r\nif (!exynos_gem->pages) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = drm_prime_sg_to_page_addr_arrays(sgt, exynos_gem->pages, NULL,\r\nnpages);\r\nif (ret < 0)\r\ngoto err_free_large;\r\nexynos_gem->sgt = sgt;\r\nif (sgt->nents == 1) {\r\nexynos_gem->flags |= EXYNOS_BO_CONTIG;\r\n} else {\r\nexynos_gem->flags |= EXYNOS_BO_NONCONTIG;\r\n}\r\nreturn &exynos_gem->base;\r\nerr_free_large:\r\ndrm_free_large(exynos_gem->pages);\r\nerr:\r\ndrm_gem_object_release(&exynos_gem->base);\r\nkfree(exynos_gem);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid *exynos_drm_gem_prime_vmap(struct drm_gem_object *obj)\r\n{\r\nreturn NULL;\r\n}\r\nvoid exynos_drm_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr)\r\n{\r\n}\r\nint exynos_drm_gem_prime_mmap(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nint ret;\r\nret = drm_gem_mmap_obj(obj, obj->size, vma);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn exynos_drm_gem_mmap_obj(obj, vma);\r\n}
