static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\r\n{\r\nreturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\r\nRTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\r\nindx, 0, data, size, 500);\r\n}\r\nstatic int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\r\n{\r\nreturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\nRTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\r\nindx, 0, data, size, 500);\r\n}\r\nstatic void async_set_reg_cb(struct urb *urb)\r\n{\r\nstruct async_req *req = (struct async_req *)urb->context;\r\nint status = urb->status;\r\nif (status < 0)\r\ndev_dbg(&urb->dev->dev, "%s failed with %d", __func__, status);\r\nkfree(req);\r\nusb_free_urb(urb);\r\n}\r\nstatic int async_set_registers(rtl8150_t *dev, u16 indx, u16 size, u16 reg)\r\n{\r\nint res = -ENOMEM;\r\nstruct urb *async_urb;\r\nstruct async_req *req;\r\nreq = kmalloc(sizeof(struct async_req), GFP_ATOMIC);\r\nif (req == NULL)\r\nreturn res;\r\nasync_urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (async_urb == NULL) {\r\nkfree(req);\r\nreturn res;\r\n}\r\nreq->rx_creg = cpu_to_le16(reg);\r\nreq->dr.bRequestType = RTL8150_REQT_WRITE;\r\nreq->dr.bRequest = RTL8150_REQ_SET_REGS;\r\nreq->dr.wIndex = 0;\r\nreq->dr.wValue = cpu_to_le16(indx);\r\nreq->dr.wLength = cpu_to_le16(size);\r\nusb_fill_control_urb(async_urb, dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0), (void *)&req->dr,\r\n&req->rx_creg, size, async_set_reg_cb, req);\r\nres = usb_submit_urb(async_urb, GFP_ATOMIC);\r\nif (res) {\r\nif (res == -ENODEV)\r\nnetif_device_detach(dev->netdev);\r\ndev_err(&dev->udev->dev, "%s failed with %d\n", __func__, res);\r\n}\r\nreturn res;\r\n}\r\nstatic int read_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 * reg)\r\n{\r\nint i;\r\nu8 data[3], tmp;\r\ndata[0] = phy;\r\ndata[1] = data[2] = 0;\r\ntmp = indx | PHY_READ | PHY_GO;\r\ni = 0;\r\nset_registers(dev, PHYADD, sizeof(data), data);\r\nset_registers(dev, PHYCNT, 1, &tmp);\r\ndo {\r\nget_registers(dev, PHYCNT, 1, data);\r\n} while ((data[0] & PHY_GO) && (i++ < MII_TIMEOUT));\r\nif (i <= MII_TIMEOUT) {\r\nget_registers(dev, PHYDAT, 2, data);\r\n*reg = data[0] | (data[1] << 8);\r\nreturn 0;\r\n} else\r\nreturn 1;\r\n}\r\nstatic int write_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 reg)\r\n{\r\nint i;\r\nu8 data[3], tmp;\r\ndata[0] = phy;\r\ndata[1] = reg & 0xff;\r\ndata[2] = (reg >> 8) & 0xff;\r\ntmp = indx | PHY_WRITE | PHY_GO;\r\ni = 0;\r\nset_registers(dev, PHYADD, sizeof(data), data);\r\nset_registers(dev, PHYCNT, 1, &tmp);\r\ndo {\r\nget_registers(dev, PHYCNT, 1, data);\r\n} while ((data[0] & PHY_GO) && (i++ < MII_TIMEOUT));\r\nif (i <= MII_TIMEOUT)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic inline void set_ethernet_addr(rtl8150_t * dev)\r\n{\r\nu8 node_id[6];\r\nget_registers(dev, IDR, sizeof(node_id), node_id);\r\nmemcpy(dev->netdev->dev_addr, node_id, sizeof(node_id));\r\n}\r\nstatic int rtl8150_set_mac_address(struct net_device *netdev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nif (netif_running(netdev))\r\nreturn -EBUSY;\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nnetdev_dbg(netdev, "Setting MAC address to %pM\n", netdev->dev_addr);\r\nset_registers(dev, IDR, netdev->addr_len, netdev->dev_addr);\r\n#ifdef EEPROM_WRITE\r\n{\r\nint i;\r\nu8 cr;\r\nget_registers(dev, CR, 1, &cr);\r\ncr |= 0x20;\r\nset_registers(dev, CR, 1, &cr);\r\nfor (i = 0; i * 2 < netdev->addr_len; i++) {\r\nset_registers(dev, IDR_EEPROM + (i * 2), 2,\r\nnetdev->dev_addr + (i * 2));\r\n}\r\ncr &= 0xdf;\r\nset_registers(dev, CR, 1, &cr);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int rtl8150_reset(rtl8150_t * dev)\r\n{\r\nu8 data = 0x10;\r\nint i = HZ;\r\nset_registers(dev, CR, 1, &data);\r\ndo {\r\nget_registers(dev, CR, 1, &data);\r\n} while ((data & 0x10) && --i);\r\nreturn (i > 0) ? 1 : 0;\r\n}\r\nstatic int alloc_all_urbs(rtl8150_t * dev)\r\n{\r\ndev->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->rx_urb)\r\nreturn 0;\r\ndev->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->tx_urb) {\r\nusb_free_urb(dev->rx_urb);\r\nreturn 0;\r\n}\r\ndev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->intr_urb) {\r\nusb_free_urb(dev->rx_urb);\r\nusb_free_urb(dev->tx_urb);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void free_all_urbs(rtl8150_t * dev)\r\n{\r\nusb_free_urb(dev->rx_urb);\r\nusb_free_urb(dev->tx_urb);\r\nusb_free_urb(dev->intr_urb);\r\n}\r\nstatic void unlink_all_urbs(rtl8150_t * dev)\r\n{\r\nusb_kill_urb(dev->rx_urb);\r\nusb_kill_urb(dev->tx_urb);\r\nusb_kill_urb(dev->intr_urb);\r\n}\r\nstatic inline struct sk_buff *pull_skb(rtl8150_t *dev)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = 0; i < RX_SKB_POOL_SIZE; i++) {\r\nif (dev->rx_skb_pool[i]) {\r\nskb = dev->rx_skb_pool[i];\r\ndev->rx_skb_pool[i] = NULL;\r\nreturn skb;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void read_bulk_callback(struct urb *urb)\r\n{\r\nrtl8150_t *dev;\r\nunsigned pkt_len, res;\r\nstruct sk_buff *skb;\r\nstruct net_device *netdev;\r\nu16 rx_stat;\r\nint status = urb->status;\r\nint result;\r\ndev = urb->context;\r\nif (!dev)\r\nreturn;\r\nif (test_bit(RTL8150_UNPLUG, &dev->flags))\r\nreturn;\r\nnetdev = dev->netdev;\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\nreturn;\r\ncase -ETIME:\r\nif (printk_ratelimit())\r\ndev_warn(&urb->dev->dev, "may be reset is needed?..\n");\r\ngoto goon;\r\ndefault:\r\nif (printk_ratelimit())\r\ndev_warn(&urb->dev->dev, "Rx status %d\n", status);\r\ngoto goon;\r\n}\r\nif (!dev->rx_skb)\r\ngoto resched;\r\nif (urb->actual_length < 4)\r\ngoto goon;\r\nres = urb->actual_length;\r\nrx_stat = le16_to_cpu(*(__le16 *)(urb->transfer_buffer + res - 4));\r\npkt_len = res - 4;\r\nskb_put(dev->rx_skb, pkt_len);\r\ndev->rx_skb->protocol = eth_type_trans(dev->rx_skb, netdev);\r\nnetif_rx(dev->rx_skb);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += pkt_len;\r\nspin_lock(&dev->rx_pool_lock);\r\nskb = pull_skb(dev);\r\nspin_unlock(&dev->rx_pool_lock);\r\nif (!skb)\r\ngoto resched;\r\ndev->rx_skb = skb;\r\ngoon:\r\nusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\r\ndev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\r\nresult = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\r\nif (result == -ENODEV)\r\nnetif_device_detach(dev->netdev);\r\nelse if (result) {\r\nset_bit(RX_URB_FAIL, &dev->flags);\r\ngoto resched;\r\n} else {\r\nclear_bit(RX_URB_FAIL, &dev->flags);\r\n}\r\nreturn;\r\nresched:\r\ntasklet_schedule(&dev->tl);\r\n}\r\nstatic void write_bulk_callback(struct urb *urb)\r\n{\r\nrtl8150_t *dev;\r\nint status = urb->status;\r\ndev = urb->context;\r\nif (!dev)\r\nreturn;\r\ndev_kfree_skb_irq(dev->tx_skb);\r\nif (!netif_device_present(dev->netdev))\r\nreturn;\r\nif (status)\r\ndev_info(&urb->dev->dev, "%s: Tx status %d\n",\r\ndev->netdev->name, status);\r\nnetif_trans_update(dev->netdev);\r\nnetif_wake_queue(dev->netdev);\r\n}\r\nstatic void intr_callback(struct urb *urb)\r\n{\r\nrtl8150_t *dev;\r\n__u8 *d;\r\nint status = urb->status;\r\nint res;\r\ndev = urb->context;\r\nif (!dev)\r\nreturn;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_info(&urb->dev->dev, "%s: intr status %d\n",\r\ndev->netdev->name, status);\r\ngoto resubmit;\r\n}\r\nd = urb->transfer_buffer;\r\nif (d[0] & TSR_ERRORS) {\r\ndev->netdev->stats.tx_errors++;\r\nif (d[INT_TSR] & (TSR_ECOL | TSR_JBR))\r\ndev->netdev->stats.tx_aborted_errors++;\r\nif (d[INT_TSR] & TSR_LCOL)\r\ndev->netdev->stats.tx_window_errors++;\r\nif (d[INT_TSR] & TSR_LOSS_CRS)\r\ndev->netdev->stats.tx_carrier_errors++;\r\n}\r\nif ((d[INT_MSR] & MSR_LINK) == 0) {\r\nif (netif_carrier_ok(dev->netdev)) {\r\nnetif_carrier_off(dev->netdev);\r\nnetdev_dbg(dev->netdev, "%s: LINK LOST\n", __func__);\r\n}\r\n} else {\r\nif (!netif_carrier_ok(dev->netdev)) {\r\nnetif_carrier_on(dev->netdev);\r\nnetdev_dbg(dev->netdev, "%s: LINK CAME BACK\n", __func__);\r\n}\r\n}\r\nresubmit:\r\nres = usb_submit_urb (urb, GFP_ATOMIC);\r\nif (res == -ENODEV)\r\nnetif_device_detach(dev->netdev);\r\nelse if (res)\r\ndev_err(&dev->udev->dev,\r\n"can't resubmit intr, %s-%s/input0, status %d\n",\r\ndev->udev->bus->bus_name, dev->udev->devpath, res);\r\n}\r\nstatic int rtl8150_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nrtl8150_t *dev = usb_get_intfdata(intf);\r\nnetif_device_detach(dev->netdev);\r\nif (netif_running(dev->netdev)) {\r\nusb_kill_urb(dev->rx_urb);\r\nusb_kill_urb(dev->intr_urb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8150_resume(struct usb_interface *intf)\r\n{\r\nrtl8150_t *dev = usb_get_intfdata(intf);\r\nnetif_device_attach(dev->netdev);\r\nif (netif_running(dev->netdev)) {\r\ndev->rx_urb->status = 0;\r\ndev->rx_urb->actual_length = 0;\r\nread_bulk_callback(dev->rx_urb);\r\ndev->intr_urb->status = 0;\r\ndev->intr_urb->actual_length = 0;\r\nintr_callback(dev->intr_urb);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fill_skb_pool(rtl8150_t *dev)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = 0; i < RX_SKB_POOL_SIZE; i++) {\r\nif (dev->rx_skb_pool[i])\r\ncontinue;\r\nskb = dev_alloc_skb(RTL8150_MTU + 2);\r\nif (!skb) {\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\ndev->rx_skb_pool[i] = skb;\r\n}\r\n}\r\nstatic void free_skb_pool(rtl8150_t *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_SKB_POOL_SIZE; i++)\r\nif (dev->rx_skb_pool[i])\r\ndev_kfree_skb(dev->rx_skb_pool[i]);\r\n}\r\nstatic void rx_fixup(unsigned long data)\r\n{\r\nstruct rtl8150 *dev = (struct rtl8150 *)data;\r\nstruct sk_buff *skb;\r\nint status;\r\nspin_lock_irq(&dev->rx_pool_lock);\r\nfill_skb_pool(dev);\r\nspin_unlock_irq(&dev->rx_pool_lock);\r\nif (test_bit(RX_URB_FAIL, &dev->flags))\r\nif (dev->rx_skb)\r\ngoto try_again;\r\nspin_lock_irq(&dev->rx_pool_lock);\r\nskb = pull_skb(dev);\r\nspin_unlock_irq(&dev->rx_pool_lock);\r\nif (skb == NULL)\r\ngoto tlsched;\r\ndev->rx_skb = skb;\r\nusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\r\ndev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\r\ntry_again:\r\nstatus = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\r\nif (status == -ENODEV) {\r\nnetif_device_detach(dev->netdev);\r\n} else if (status) {\r\nset_bit(RX_URB_FAIL, &dev->flags);\r\ngoto tlsched;\r\n} else {\r\nclear_bit(RX_URB_FAIL, &dev->flags);\r\n}\r\nreturn;\r\ntlsched:\r\ntasklet_schedule(&dev->tl);\r\n}\r\nstatic int enable_net_traffic(rtl8150_t * dev)\r\n{\r\nu8 cr, tcr, rcr, msr;\r\nif (!rtl8150_reset(dev)) {\r\ndev_warn(&dev->udev->dev, "device reset failed\n");\r\n}\r\nrcr = 0x9e;\r\ntcr = 0xd8;\r\ncr = 0x0c;\r\nif (!(rcr & 0x80))\r\nset_bit(RTL8150_HW_CRC, &dev->flags);\r\nset_registers(dev, RCR, 1, &rcr);\r\nset_registers(dev, TCR, 1, &tcr);\r\nset_registers(dev, CR, 1, &cr);\r\nget_registers(dev, MSR, 1, &msr);\r\nreturn 0;\r\n}\r\nstatic void disable_net_traffic(rtl8150_t * dev)\r\n{\r\nu8 cr;\r\nget_registers(dev, CR, 1, &cr);\r\ncr &= 0xf3;\r\nset_registers(dev, CR, 1, &cr);\r\n}\r\nstatic void rtl8150_tx_timeout(struct net_device *netdev)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\ndev_warn(&netdev->dev, "Tx timeout.\n");\r\nusb_unlink_urb(dev->tx_urb);\r\nnetdev->stats.tx_errors++;\r\n}\r\nstatic void rtl8150_set_multicast(struct net_device *netdev)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nu16 rx_creg = 0x9e;\r\nnetif_stop_queue(netdev);\r\nif (netdev->flags & IFF_PROMISC) {\r\nrx_creg |= 0x0001;\r\ndev_info(&netdev->dev, "%s: promiscuous mode\n", netdev->name);\r\n} else if (!netdev_mc_empty(netdev) ||\r\n(netdev->flags & IFF_ALLMULTI)) {\r\nrx_creg &= 0xfffe;\r\nrx_creg |= 0x0002;\r\ndev_info(&netdev->dev, "%s: allmulti set\n", netdev->name);\r\n} else {\r\nrx_creg &= 0x00fc;\r\n}\r\nasync_set_registers(dev, RCR, sizeof(rx_creg), rx_creg);\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic netdev_tx_t rtl8150_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nint count, res;\r\nnetif_stop_queue(netdev);\r\ncount = (skb->len < 60) ? 60 : skb->len;\r\ncount = (count & 0x3f) ? count : count + 1;\r\ndev->tx_skb = skb;\r\nusb_fill_bulk_urb(dev->tx_urb, dev->udev, usb_sndbulkpipe(dev->udev, 2),\r\nskb->data, count, write_bulk_callback, dev);\r\nif ((res = usb_submit_urb(dev->tx_urb, GFP_ATOMIC))) {\r\nif (res == -ENODEV)\r\nnetif_device_detach(dev->netdev);\r\nelse {\r\ndev_warn(&netdev->dev, "failed tx_urb %d\n", res);\r\nnetdev->stats.tx_errors++;\r\nnetif_start_queue(netdev);\r\n}\r\n} else {\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += skb->len;\r\nnetif_trans_update(netdev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void set_carrier(struct net_device *netdev)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nshort tmp;\r\nget_registers(dev, CSCR, 2, &tmp);\r\nif (tmp & CSCR_LINK_STATUS)\r\nnetif_carrier_on(netdev);\r\nelse\r\nnetif_carrier_off(netdev);\r\n}\r\nstatic int rtl8150_open(struct net_device *netdev)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nint res;\r\nif (dev->rx_skb == NULL)\r\ndev->rx_skb = pull_skb(dev);\r\nif (!dev->rx_skb)\r\nreturn -ENOMEM;\r\nset_registers(dev, IDR, 6, netdev->dev_addr);\r\nusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\r\ndev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\r\nif ((res = usb_submit_urb(dev->rx_urb, GFP_KERNEL))) {\r\nif (res == -ENODEV)\r\nnetif_device_detach(dev->netdev);\r\ndev_warn(&netdev->dev, "rx_urb submit failed: %d\n", res);\r\nreturn res;\r\n}\r\nusb_fill_int_urb(dev->intr_urb, dev->udev, usb_rcvintpipe(dev->udev, 3),\r\ndev->intr_buff, INTBUFSIZE, intr_callback,\r\ndev, dev->intr_interval);\r\nif ((res = usb_submit_urb(dev->intr_urb, GFP_KERNEL))) {\r\nif (res == -ENODEV)\r\nnetif_device_detach(dev->netdev);\r\ndev_warn(&netdev->dev, "intr_urb submit failed: %d\n", res);\r\nusb_kill_urb(dev->rx_urb);\r\nreturn res;\r\n}\r\nenable_net_traffic(dev);\r\nset_carrier(netdev);\r\nnetif_start_queue(netdev);\r\nreturn res;\r\n}\r\nstatic int rtl8150_close(struct net_device *netdev)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nnetif_stop_queue(netdev);\r\nif (!test_bit(RTL8150_UNPLUG, &dev->flags))\r\ndisable_net_traffic(dev);\r\nunlink_all_urbs(dev);\r\nreturn 0;\r\n}\r\nstatic void rtl8150_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *info)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nstrlcpy(info->driver, driver_name, sizeof(info->driver));\r\nstrlcpy(info->version, DRIVER_VERSION, sizeof(info->version));\r\nusb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));\r\n}\r\nstatic int rtl8150_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nshort lpa, bmcr;\r\necmd->supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_TP | SUPPORTED_MII);\r\necmd->port = PORT_TP;\r\necmd->transceiver = XCVR_INTERNAL;\r\necmd->phy_address = dev->phy;\r\nget_registers(dev, BMCR, 2, &bmcr);\r\nget_registers(dev, ANLP, 2, &lpa);\r\nif (bmcr & BMCR_ANENABLE) {\r\nu32 speed = ((lpa & (LPA_100HALF | LPA_100FULL)) ?\r\nSPEED_100 : SPEED_10);\r\nethtool_cmd_speed_set(ecmd, speed);\r\necmd->autoneg = AUTONEG_ENABLE;\r\nif (speed == SPEED_100)\r\necmd->duplex = (lpa & LPA_100FULL) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\nelse\r\necmd->duplex = (lpa & LPA_10FULL) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\n} else {\r\necmd->autoneg = AUTONEG_DISABLE;\r\nethtool_cmd_speed_set(ecmd, ((bmcr & BMCR_SPEED100) ?\r\nSPEED_100 : SPEED_10));\r\necmd->duplex = (bmcr & BMCR_FULLDPLX) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8150_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\r\n{\r\nrtl8150_t *dev = netdev_priv(netdev);\r\nu16 *data = (u16 *) & rq->ifr_ifru;\r\nint res = 0;\r\nswitch (cmd) {\r\ncase SIOCDEVPRIVATE:\r\ndata[0] = dev->phy;\r\ncase SIOCDEVPRIVATE + 1:\r\nread_mii_word(dev, dev->phy, (data[1] & 0x1f), &data[3]);\r\nbreak;\r\ncase SIOCDEVPRIVATE + 2:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nwrite_mii_word(dev, dev->phy, (data[1] & 0x1f), data[2]);\r\nbreak;\r\ndefault:\r\nres = -EOPNOTSUPP;\r\n}\r\nreturn res;\r\n}\r\nstatic int rtl8150_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nrtl8150_t *dev;\r\nstruct net_device *netdev;\r\nnetdev = alloc_etherdev(sizeof(rtl8150_t));\r\nif (!netdev)\r\nreturn -ENOMEM;\r\ndev = netdev_priv(netdev);\r\ndev->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);\r\nif (!dev->intr_buff) {\r\nfree_netdev(netdev);\r\nreturn -ENOMEM;\r\n}\r\ntasklet_init(&dev->tl, rx_fixup, (unsigned long)dev);\r\nspin_lock_init(&dev->rx_pool_lock);\r\ndev->udev = udev;\r\ndev->netdev = netdev;\r\nnetdev->netdev_ops = &rtl8150_netdev_ops;\r\nnetdev->watchdog_timeo = RTL8150_TX_TIMEOUT;\r\nnetdev->ethtool_ops = &ops;\r\ndev->intr_interval = 100;\r\nif (!alloc_all_urbs(dev)) {\r\ndev_err(&intf->dev, "out of memory\n");\r\ngoto out;\r\n}\r\nif (!rtl8150_reset(dev)) {\r\ndev_err(&intf->dev, "couldn't reset the device\n");\r\ngoto out1;\r\n}\r\nfill_skb_pool(dev);\r\nset_ethernet_addr(dev);\r\nusb_set_intfdata(intf, dev);\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nif (register_netdev(netdev) != 0) {\r\ndev_err(&intf->dev, "couldn't register the device\n");\r\ngoto out2;\r\n}\r\ndev_info(&intf->dev, "%s: rtl8150 is detected\n", netdev->name);\r\nreturn 0;\r\nout2:\r\nusb_set_intfdata(intf, NULL);\r\nfree_skb_pool(dev);\r\nout1:\r\nfree_all_urbs(dev);\r\nout:\r\nkfree(dev->intr_buff);\r\nfree_netdev(netdev);\r\nreturn -EIO;\r\n}\r\nstatic void rtl8150_disconnect(struct usb_interface *intf)\r\n{\r\nrtl8150_t *dev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (dev) {\r\nset_bit(RTL8150_UNPLUG, &dev->flags);\r\ntasklet_kill(&dev->tl);\r\nunregister_netdev(dev->netdev);\r\nunlink_all_urbs(dev);\r\nfree_all_urbs(dev);\r\nfree_skb_pool(dev);\r\nif (dev->rx_skb)\r\ndev_kfree_skb(dev->rx_skb);\r\nkfree(dev->intr_buff);\r\nfree_netdev(dev->netdev);\r\n}\r\n}
