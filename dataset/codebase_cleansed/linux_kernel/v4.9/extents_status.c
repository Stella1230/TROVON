int __init ext4_init_es(void)\r\n{\r\next4_es_cachep = kmem_cache_create("ext4_extent_status",\r\nsizeof(struct extent_status),\r\n0, (SLAB_RECLAIM_ACCOUNT), NULL);\r\nif (ext4_es_cachep == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ext4_exit_es(void)\r\n{\r\nif (ext4_es_cachep)\r\nkmem_cache_destroy(ext4_es_cachep);\r\n}\r\nvoid ext4_es_init_tree(struct ext4_es_tree *tree)\r\n{\r\ntree->root = RB_ROOT;\r\ntree->cache_es = NULL;\r\n}\r\nstatic void ext4_es_print_tree(struct inode *inode)\r\n{\r\nstruct ext4_es_tree *tree;\r\nstruct rb_node *node;\r\nprintk(KERN_DEBUG "status extents for inode %lu:", inode->i_ino);\r\ntree = &EXT4_I(inode)->i_es_tree;\r\nnode = rb_first(&tree->root);\r\nwhile (node) {\r\nstruct extent_status *es;\r\nes = rb_entry(node, struct extent_status, rb_node);\r\nprintk(KERN_DEBUG " [%u/%u) %llu %x",\r\nes->es_lblk, es->es_len,\r\next4_es_pblock(es), ext4_es_status(es));\r\nnode = rb_next(node);\r\n}\r\nprintk(KERN_DEBUG "\n");\r\n}\r\nstatic inline ext4_lblk_t ext4_es_end(struct extent_status *es)\r\n{\r\nBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\r\nreturn es->es_lblk + es->es_len - 1;\r\n}\r\nstatic struct extent_status *__es_tree_search(struct rb_root *root,\r\next4_lblk_t lblk)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nstruct extent_status *es = NULL;\r\nwhile (node) {\r\nes = rb_entry(node, struct extent_status, rb_node);\r\nif (lblk < es->es_lblk)\r\nnode = node->rb_left;\r\nelse if (lblk > ext4_es_end(es))\r\nnode = node->rb_right;\r\nelse\r\nreturn es;\r\n}\r\nif (es && lblk < es->es_lblk)\r\nreturn es;\r\nif (es && lblk > ext4_es_end(es)) {\r\nnode = rb_next(&es->rb_node);\r\nreturn node ? rb_entry(node, struct extent_status, rb_node) :\r\nNULL;\r\n}\r\nreturn NULL;\r\n}\r\nvoid ext4_es_find_delayed_extent_range(struct inode *inode,\r\next4_lblk_t lblk, ext4_lblk_t end,\r\nstruct extent_status *es)\r\n{\r\nstruct ext4_es_tree *tree = NULL;\r\nstruct extent_status *es1 = NULL;\r\nstruct rb_node *node;\r\nBUG_ON(es == NULL);\r\nBUG_ON(end < lblk);\r\ntrace_ext4_es_find_delayed_extent_range_enter(inode, lblk);\r\nread_lock(&EXT4_I(inode)->i_es_lock);\r\ntree = &EXT4_I(inode)->i_es_tree;\r\nes->es_lblk = es->es_len = es->es_pblk = 0;\r\nif (tree->cache_es) {\r\nes1 = tree->cache_es;\r\nif (in_range(lblk, es1->es_lblk, es1->es_len)) {\r\nes_debug("%u cached by [%u/%u) %llu %x\n",\r\nlblk, es1->es_lblk, es1->es_len,\r\next4_es_pblock(es1), ext4_es_status(es1));\r\ngoto out;\r\n}\r\n}\r\nes1 = __es_tree_search(&tree->root, lblk);\r\nout:\r\nif (es1 && !ext4_es_is_delayed(es1)) {\r\nwhile ((node = rb_next(&es1->rb_node)) != NULL) {\r\nes1 = rb_entry(node, struct extent_status, rb_node);\r\nif (es1->es_lblk > end) {\r\nes1 = NULL;\r\nbreak;\r\n}\r\nif (ext4_es_is_delayed(es1))\r\nbreak;\r\n}\r\n}\r\nif (es1 && ext4_es_is_delayed(es1)) {\r\ntree->cache_es = es1;\r\nes->es_lblk = es1->es_lblk;\r\nes->es_len = es1->es_len;\r\nes->es_pblk = es1->es_pblk;\r\n}\r\nread_unlock(&EXT4_I(inode)->i_es_lock);\r\ntrace_ext4_es_find_delayed_extent_range_exit(inode, es);\r\n}\r\nstatic void ext4_es_list_add(struct inode *inode)\r\n{\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\r\nif (!list_empty(&ei->i_es_list))\r\nreturn;\r\nspin_lock(&sbi->s_es_lock);\r\nif (list_empty(&ei->i_es_list)) {\r\nlist_add_tail(&ei->i_es_list, &sbi->s_es_list);\r\nsbi->s_es_nr_inode++;\r\n}\r\nspin_unlock(&sbi->s_es_lock);\r\n}\r\nstatic void ext4_es_list_del(struct inode *inode)\r\n{\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\r\nspin_lock(&sbi->s_es_lock);\r\nif (!list_empty(&ei->i_es_list)) {\r\nlist_del_init(&ei->i_es_list);\r\nsbi->s_es_nr_inode--;\r\nWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\r\n}\r\nspin_unlock(&sbi->s_es_lock);\r\n}\r\nstatic struct extent_status *\r\next4_es_alloc_extent(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len,\r\next4_fsblk_t pblk)\r\n{\r\nstruct extent_status *es;\r\nes = kmem_cache_alloc(ext4_es_cachep, GFP_ATOMIC);\r\nif (es == NULL)\r\nreturn NULL;\r\nes->es_lblk = lblk;\r\nes->es_len = len;\r\nes->es_pblk = pblk;\r\nif (!ext4_es_is_delayed(es)) {\r\nif (!EXT4_I(inode)->i_es_shk_nr++)\r\next4_es_list_add(inode);\r\npercpu_counter_inc(&EXT4_SB(inode->i_sb)->\r\ns_es_stats.es_stats_shk_cnt);\r\n}\r\nEXT4_I(inode)->i_es_all_nr++;\r\npercpu_counter_inc(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\r\nreturn es;\r\n}\r\nstatic void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\r\n{\r\nEXT4_I(inode)->i_es_all_nr--;\r\npercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\r\nif (!ext4_es_is_delayed(es)) {\r\nBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\r\nif (!--EXT4_I(inode)->i_es_shk_nr)\r\next4_es_list_del(inode);\r\npercpu_counter_dec(&EXT4_SB(inode->i_sb)->\r\ns_es_stats.es_stats_shk_cnt);\r\n}\r\nkmem_cache_free(ext4_es_cachep, es);\r\n}\r\nstatic int ext4_es_can_be_merged(struct extent_status *es1,\r\nstruct extent_status *es2)\r\n{\r\nif (ext4_es_type(es1) != ext4_es_type(es2))\r\nreturn 0;\r\nif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\r\npr_warn("ES assertion failed when merging extents. "\r\n"The sum of lengths of es1 (%d) and es2 (%d) "\r\n"is bigger than allowed file size (%d)\n",\r\nes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\r\nreturn 0;\r\nif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\r\n(ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\r\nreturn 1;\r\nif (ext4_es_is_hole(es1))\r\nreturn 1;\r\nif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct extent_status *\r\next4_es_try_to_merge_left(struct inode *inode, struct extent_status *es)\r\n{\r\nstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\r\nstruct extent_status *es1;\r\nstruct rb_node *node;\r\nnode = rb_prev(&es->rb_node);\r\nif (!node)\r\nreturn es;\r\nes1 = rb_entry(node, struct extent_status, rb_node);\r\nif (ext4_es_can_be_merged(es1, es)) {\r\nes1->es_len += es->es_len;\r\nif (ext4_es_is_referenced(es))\r\next4_es_set_referenced(es1);\r\nrb_erase(&es->rb_node, &tree->root);\r\next4_es_free_extent(inode, es);\r\nes = es1;\r\n}\r\nreturn es;\r\n}\r\nstatic struct extent_status *\r\next4_es_try_to_merge_right(struct inode *inode, struct extent_status *es)\r\n{\r\nstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\r\nstruct extent_status *es1;\r\nstruct rb_node *node;\r\nnode = rb_next(&es->rb_node);\r\nif (!node)\r\nreturn es;\r\nes1 = rb_entry(node, struct extent_status, rb_node);\r\nif (ext4_es_can_be_merged(es, es1)) {\r\nes->es_len += es1->es_len;\r\nif (ext4_es_is_referenced(es1))\r\next4_es_set_referenced(es);\r\nrb_erase(node, &tree->root);\r\next4_es_free_extent(inode, es1);\r\n}\r\nreturn es;\r\n}\r\nstatic void ext4_es_insert_extent_ext_check(struct inode *inode,\r\nstruct extent_status *es)\r\n{\r\nstruct ext4_ext_path *path = NULL;\r\nstruct ext4_extent *ex;\r\next4_lblk_t ee_block;\r\next4_fsblk_t ee_start;\r\nunsigned short ee_len;\r\nint depth, ee_status, es_status;\r\npath = ext4_find_extent(inode, es->es_lblk, NULL, EXT4_EX_NOCACHE);\r\nif (IS_ERR(path))\r\nreturn;\r\ndepth = ext_depth(inode);\r\nex = path[depth].p_ext;\r\nif (ex) {\r\nee_block = le32_to_cpu(ex->ee_block);\r\nee_start = ext4_ext_pblock(ex);\r\nee_len = ext4_ext_get_actual_len(ex);\r\nee_status = ext4_ext_is_unwritten(ex) ? 1 : 0;\r\nes_status = ext4_es_is_unwritten(es) ? 1 : 0;\r\nif (!ext4_es_is_written(es) && !ext4_es_is_unwritten(es)) {\r\nif (in_range(es->es_lblk, ee_block, ee_len)) {\r\npr_warn("ES insert assertion failed for "\r\n"inode: %lu we can find an extent "\r\n"at block [%d/%d/%llu/%c], but we "\r\n"want to add a delayed/hole extent "\r\n"[%d/%d/%llu/%x]\n",\r\ninode->i_ino, ee_block, ee_len,\r\nee_start, ee_status ? 'u' : 'w',\r\nes->es_lblk, es->es_len,\r\next4_es_pblock(es), ext4_es_status(es));\r\n}\r\ngoto out;\r\n}\r\nif (es->es_lblk < ee_block ||\r\next4_es_pblock(es) != ee_start + es->es_lblk - ee_block) {\r\npr_warn("ES insert assertion failed for inode: %lu "\r\n"ex_status [%d/%d/%llu/%c] != "\r\n"es_status [%d/%d/%llu/%c]\n", inode->i_ino,\r\nee_block, ee_len, ee_start,\r\nee_status ? 'u' : 'w', es->es_lblk, es->es_len,\r\next4_es_pblock(es), es_status ? 'u' : 'w');\r\ngoto out;\r\n}\r\nif (ee_status ^ es_status) {\r\npr_warn("ES insert assertion failed for inode: %lu "\r\n"ex_status [%d/%d/%llu/%c] != "\r\n"es_status [%d/%d/%llu/%c]\n", inode->i_ino,\r\nee_block, ee_len, ee_start,\r\nee_status ? 'u' : 'w', es->es_lblk, es->es_len,\r\next4_es_pblock(es), es_status ? 'u' : 'w');\r\n}\r\n} else {\r\nif (!ext4_es_is_delayed(es) && !ext4_es_is_hole(es)) {\r\npr_warn("ES insert assertion failed for inode: %lu "\r\n"can't find an extent at block %d but we want "\r\n"to add a written/unwritten extent "\r\n"[%d/%d/%llu/%x]\n", inode->i_ino,\r\nes->es_lblk, es->es_lblk, es->es_len,\r\next4_es_pblock(es), ext4_es_status(es));\r\n}\r\n}\r\nout:\r\next4_ext_drop_refs(path);\r\nkfree(path);\r\n}\r\nstatic void ext4_es_insert_extent_ind_check(struct inode *inode,\r\nstruct extent_status *es)\r\n{\r\nstruct ext4_map_blocks map;\r\nint retval;\r\nmap.m_lblk = es->es_lblk;\r\nmap.m_len = es->es_len;\r\nretval = ext4_ind_map_blocks(NULL, inode, &map, 0);\r\nif (retval > 0) {\r\nif (ext4_es_is_delayed(es) || ext4_es_is_hole(es)) {\r\npr_warn("ES insert assertion failed for inode: %lu "\r\n"We can find blocks but we want to add a "\r\n"delayed/hole extent [%d/%d/%llu/%x]\n",\r\ninode->i_ino, es->es_lblk, es->es_len,\r\next4_es_pblock(es), ext4_es_status(es));\r\nreturn;\r\n} else if (ext4_es_is_written(es)) {\r\nif (retval != es->es_len) {\r\npr_warn("ES insert assertion failed for "\r\n"inode: %lu retval %d != es_len %d\n",\r\ninode->i_ino, retval, es->es_len);\r\nreturn;\r\n}\r\nif (map.m_pblk != ext4_es_pblock(es)) {\r\npr_warn("ES insert assertion failed for "\r\n"inode: %lu m_pblk %llu != "\r\n"es_pblk %llu\n",\r\ninode->i_ino, map.m_pblk,\r\next4_es_pblock(es));\r\nreturn;\r\n}\r\n} else {\r\nBUG_ON(1);\r\n}\r\n} else if (retval == 0) {\r\nif (ext4_es_is_written(es)) {\r\npr_warn("ES insert assertion failed for inode: %lu "\r\n"We can't find the block but we want to add "\r\n"a written extent [%d/%d/%llu/%x]\n",\r\ninode->i_ino, es->es_lblk, es->es_len,\r\next4_es_pblock(es), ext4_es_status(es));\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic inline void ext4_es_insert_extent_check(struct inode *inode,\r\nstruct extent_status *es)\r\n{\r\nBUG_ON(!rwsem_is_locked(&EXT4_I(inode)->i_data_sem));\r\nif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\r\next4_es_insert_extent_ext_check(inode, es);\r\nelse\r\next4_es_insert_extent_ind_check(inode, es);\r\n}\r\nstatic inline void ext4_es_insert_extent_check(struct inode *inode,\r\nstruct extent_status *es)\r\n{\r\n}\r\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes)\r\n{\r\nstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\r\nstruct rb_node **p = &tree->root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct extent_status *es;\r\nwhile (*p) {\r\nparent = *p;\r\nes = rb_entry(parent, struct extent_status, rb_node);\r\nif (newes->es_lblk < es->es_lblk) {\r\nif (ext4_es_can_be_merged(newes, es)) {\r\nes->es_lblk = newes->es_lblk;\r\nes->es_len += newes->es_len;\r\nif (ext4_es_is_written(es) ||\r\next4_es_is_unwritten(es))\r\next4_es_store_pblock(es,\r\nnewes->es_pblk);\r\nes = ext4_es_try_to_merge_left(inode, es);\r\ngoto out;\r\n}\r\np = &(*p)->rb_left;\r\n} else if (newes->es_lblk > ext4_es_end(es)) {\r\nif (ext4_es_can_be_merged(es, newes)) {\r\nes->es_len += newes->es_len;\r\nes = ext4_es_try_to_merge_right(inode, es);\r\ngoto out;\r\n}\r\np = &(*p)->rb_right;\r\n} else {\r\nBUG_ON(1);\r\nreturn -EINVAL;\r\n}\r\n}\r\nes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\r\nnewes->es_pblk);\r\nif (!es)\r\nreturn -ENOMEM;\r\nrb_link_node(&es->rb_node, parent, p);\r\nrb_insert_color(&es->rb_node, &tree->root);\r\nout:\r\ntree->cache_es = es;\r\nreturn 0;\r\n}\r\nint ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\r\next4_lblk_t len, ext4_fsblk_t pblk,\r\nunsigned int status)\r\n{\r\nstruct extent_status newes;\r\next4_lblk_t end = lblk + len - 1;\r\nint err = 0;\r\nes_debug("add [%u/%u) %llu %x to extent status tree of inode %lu\n",\r\nlblk, len, pblk, status, inode->i_ino);\r\nif (!len)\r\nreturn 0;\r\nBUG_ON(end < lblk);\r\nif ((status & EXTENT_STATUS_DELAYED) &&\r\n(status & EXTENT_STATUS_WRITTEN)) {\r\next4_warning(inode->i_sb, "Inserting extent [%u/%u] as "\r\n" delayed and written which can potentially "\r\n" cause data loss.", lblk, len);\r\nWARN_ON(1);\r\n}\r\nnewes.es_lblk = lblk;\r\nnewes.es_len = len;\r\next4_es_store_pblock_status(&newes, pblk, status);\r\ntrace_ext4_es_insert_extent(inode, &newes);\r\next4_es_insert_extent_check(inode, &newes);\r\nwrite_lock(&EXT4_I(inode)->i_es_lock);\r\nerr = __es_remove_extent(inode, lblk, end);\r\nif (err != 0)\r\ngoto error;\r\nretry:\r\nerr = __es_insert_extent(inode, &newes);\r\nif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\r\n128, EXT4_I(inode)))\r\ngoto retry;\r\nif (err == -ENOMEM && !ext4_es_is_delayed(&newes))\r\nerr = 0;\r\nerror:\r\nwrite_unlock(&EXT4_I(inode)->i_es_lock);\r\next4_es_print_tree(inode);\r\nreturn err;\r\n}\r\nvoid ext4_es_cache_extent(struct inode *inode, ext4_lblk_t lblk,\r\next4_lblk_t len, ext4_fsblk_t pblk,\r\nunsigned int status)\r\n{\r\nstruct extent_status *es;\r\nstruct extent_status newes;\r\next4_lblk_t end = lblk + len - 1;\r\nnewes.es_lblk = lblk;\r\nnewes.es_len = len;\r\next4_es_store_pblock_status(&newes, pblk, status);\r\ntrace_ext4_es_cache_extent(inode, &newes);\r\nif (!len)\r\nreturn;\r\nBUG_ON(end < lblk);\r\nwrite_lock(&EXT4_I(inode)->i_es_lock);\r\nes = __es_tree_search(&EXT4_I(inode)->i_es_tree.root, lblk);\r\nif (!es || es->es_lblk > end)\r\n__es_insert_extent(inode, &newes);\r\nwrite_unlock(&EXT4_I(inode)->i_es_lock);\r\n}\r\nint ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\r\nstruct extent_status *es)\r\n{\r\nstruct ext4_es_tree *tree;\r\nstruct ext4_es_stats *stats;\r\nstruct extent_status *es1 = NULL;\r\nstruct rb_node *node;\r\nint found = 0;\r\ntrace_ext4_es_lookup_extent_enter(inode, lblk);\r\nes_debug("lookup extent in block %u\n", lblk);\r\ntree = &EXT4_I(inode)->i_es_tree;\r\nread_lock(&EXT4_I(inode)->i_es_lock);\r\nes->es_lblk = es->es_len = es->es_pblk = 0;\r\nif (tree->cache_es) {\r\nes1 = tree->cache_es;\r\nif (in_range(lblk, es1->es_lblk, es1->es_len)) {\r\nes_debug("%u cached by [%u/%u)\n",\r\nlblk, es1->es_lblk, es1->es_len);\r\nfound = 1;\r\ngoto out;\r\n}\r\n}\r\nnode = tree->root.rb_node;\r\nwhile (node) {\r\nes1 = rb_entry(node, struct extent_status, rb_node);\r\nif (lblk < es1->es_lblk)\r\nnode = node->rb_left;\r\nelse if (lblk > ext4_es_end(es1))\r\nnode = node->rb_right;\r\nelse {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nout:\r\nstats = &EXT4_SB(inode->i_sb)->s_es_stats;\r\nif (found) {\r\nBUG_ON(!es1);\r\nes->es_lblk = es1->es_lblk;\r\nes->es_len = es1->es_len;\r\nes->es_pblk = es1->es_pblk;\r\nif (!ext4_es_is_referenced(es1))\r\next4_es_set_referenced(es1);\r\nstats->es_stats_cache_hits++;\r\n} else {\r\nstats->es_stats_cache_misses++;\r\n}\r\nread_unlock(&EXT4_I(inode)->i_es_lock);\r\ntrace_ext4_es_lookup_extent_exit(inode, es, found);\r\nreturn found;\r\n}\r\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\r\next4_lblk_t end)\r\n{\r\nstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\r\nstruct rb_node *node;\r\nstruct extent_status *es;\r\nstruct extent_status orig_es;\r\next4_lblk_t len1, len2;\r\next4_fsblk_t block;\r\nint err;\r\nretry:\r\nerr = 0;\r\nes = __es_tree_search(&tree->root, lblk);\r\nif (!es)\r\ngoto out;\r\nif (es->es_lblk > end)\r\ngoto out;\r\ntree->cache_es = NULL;\r\norig_es.es_lblk = es->es_lblk;\r\norig_es.es_len = es->es_len;\r\norig_es.es_pblk = es->es_pblk;\r\nlen1 = lblk > es->es_lblk ? lblk - es->es_lblk : 0;\r\nlen2 = ext4_es_end(es) > end ? ext4_es_end(es) - end : 0;\r\nif (len1 > 0)\r\nes->es_len = len1;\r\nif (len2 > 0) {\r\nif (len1 > 0) {\r\nstruct extent_status newes;\r\nnewes.es_lblk = end + 1;\r\nnewes.es_len = len2;\r\nblock = 0x7FDEADBEEFULL;\r\nif (ext4_es_is_written(&orig_es) ||\r\next4_es_is_unwritten(&orig_es))\r\nblock = ext4_es_pblock(&orig_es) +\r\norig_es.es_len - len2;\r\next4_es_store_pblock_status(&newes, block,\r\next4_es_status(&orig_es));\r\nerr = __es_insert_extent(inode, &newes);\r\nif (err) {\r\nes->es_lblk = orig_es.es_lblk;\r\nes->es_len = orig_es.es_len;\r\nif ((err == -ENOMEM) &&\r\n__es_shrink(EXT4_SB(inode->i_sb),\r\n128, EXT4_I(inode)))\r\ngoto retry;\r\ngoto out;\r\n}\r\n} else {\r\nes->es_lblk = end + 1;\r\nes->es_len = len2;\r\nif (ext4_es_is_written(es) ||\r\next4_es_is_unwritten(es)) {\r\nblock = orig_es.es_pblk + orig_es.es_len - len2;\r\next4_es_store_pblock(es, block);\r\n}\r\n}\r\ngoto out;\r\n}\r\nif (len1 > 0) {\r\nnode = rb_next(&es->rb_node);\r\nif (node)\r\nes = rb_entry(node, struct extent_status, rb_node);\r\nelse\r\nes = NULL;\r\n}\r\nwhile (es && ext4_es_end(es) <= end) {\r\nnode = rb_next(&es->rb_node);\r\nrb_erase(&es->rb_node, &tree->root);\r\next4_es_free_extent(inode, es);\r\nif (!node) {\r\nes = NULL;\r\nbreak;\r\n}\r\nes = rb_entry(node, struct extent_status, rb_node);\r\n}\r\nif (es && es->es_lblk < end + 1) {\r\next4_lblk_t orig_len = es->es_len;\r\nlen1 = ext4_es_end(es) - end;\r\nes->es_lblk = end + 1;\r\nes->es_len = len1;\r\nif (ext4_es_is_written(es) || ext4_es_is_unwritten(es)) {\r\nblock = es->es_pblk + orig_len - len1;\r\next4_es_store_pblock(es, block);\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\r\next4_lblk_t len)\r\n{\r\next4_lblk_t end;\r\nint err = 0;\r\ntrace_ext4_es_remove_extent(inode, lblk, len);\r\nes_debug("remove [%u/%u) from extent status tree of inode %lu\n",\r\nlblk, len, inode->i_ino);\r\nif (!len)\r\nreturn err;\r\nend = lblk + len - 1;\r\nBUG_ON(end < lblk);\r\nwrite_lock(&EXT4_I(inode)->i_es_lock);\r\nerr = __es_remove_extent(inode, lblk, end);\r\nwrite_unlock(&EXT4_I(inode)->i_es_lock);\r\next4_es_print_tree(inode);\r\nreturn err;\r\n}\r\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\r\nstruct ext4_inode_info *locked_ei)\r\n{\r\nstruct ext4_inode_info *ei;\r\nstruct ext4_es_stats *es_stats;\r\nktime_t start_time;\r\nu64 scan_time;\r\nint nr_to_walk;\r\nint nr_shrunk = 0;\r\nint retried = 0, nr_skipped = 0;\r\nes_stats = &sbi->s_es_stats;\r\nstart_time = ktime_get();\r\nretry:\r\nspin_lock(&sbi->s_es_lock);\r\nnr_to_walk = sbi->s_es_nr_inode;\r\nwhile (nr_to_walk-- > 0) {\r\nif (list_empty(&sbi->s_es_list)) {\r\nspin_unlock(&sbi->s_es_lock);\r\ngoto out;\r\n}\r\nei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\r\ni_es_list);\r\nlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\r\nif (!retried && ext4_test_inode_state(&ei->vfs_inode,\r\nEXT4_STATE_EXT_PRECACHED)) {\r\nnr_skipped++;\r\ncontinue;\r\n}\r\nif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\r\nnr_skipped++;\r\ncontinue;\r\n}\r\nspin_unlock(&sbi->s_es_lock);\r\nnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\r\nwrite_unlock(&ei->i_es_lock);\r\nif (nr_to_scan <= 0)\r\ngoto out;\r\nspin_lock(&sbi->s_es_lock);\r\n}\r\nspin_unlock(&sbi->s_es_lock);\r\nif ((nr_shrunk == 0) && nr_skipped && !retried) {\r\nretried++;\r\ngoto retry;\r\n}\r\nif (locked_ei && nr_shrunk == 0)\r\nnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\r\nout:\r\nscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\r\nif (likely(es_stats->es_stats_scan_time))\r\nes_stats->es_stats_scan_time = (scan_time +\r\nes_stats->es_stats_scan_time*3) / 4;\r\nelse\r\nes_stats->es_stats_scan_time = scan_time;\r\nif (scan_time > es_stats->es_stats_max_scan_time)\r\nes_stats->es_stats_max_scan_time = scan_time;\r\nif (likely(es_stats->es_stats_shrunk))\r\nes_stats->es_stats_shrunk = (nr_shrunk +\r\nes_stats->es_stats_shrunk*3) / 4;\r\nelse\r\nes_stats->es_stats_shrunk = nr_shrunk;\r\ntrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\r\nnr_skipped, retried);\r\nreturn nr_shrunk;\r\n}\r\nstatic unsigned long ext4_es_count(struct shrinker *shrink,\r\nstruct shrink_control *sc)\r\n{\r\nunsigned long nr;\r\nstruct ext4_sb_info *sbi;\r\nsbi = container_of(shrink, struct ext4_sb_info, s_es_shrinker);\r\nnr = percpu_counter_read_positive(&sbi->s_es_stats.es_stats_shk_cnt);\r\ntrace_ext4_es_shrink_count(sbi->s_sb, sc->nr_to_scan, nr);\r\nreturn nr;\r\n}\r\nstatic unsigned long ext4_es_scan(struct shrinker *shrink,\r\nstruct shrink_control *sc)\r\n{\r\nstruct ext4_sb_info *sbi = container_of(shrink,\r\nstruct ext4_sb_info, s_es_shrinker);\r\nint nr_to_scan = sc->nr_to_scan;\r\nint ret, nr_shrunk;\r\nret = percpu_counter_read_positive(&sbi->s_es_stats.es_stats_shk_cnt);\r\ntrace_ext4_es_shrink_scan_enter(sbi->s_sb, nr_to_scan, ret);\r\nif (!nr_to_scan)\r\nreturn ret;\r\nnr_shrunk = __es_shrink(sbi, nr_to_scan, NULL);\r\ntrace_ext4_es_shrink_scan_exit(sbi->s_sb, nr_shrunk, ret);\r\nreturn nr_shrunk;\r\n}\r\nint ext4_seq_es_shrinker_info_show(struct seq_file *seq, void *v)\r\n{\r\nstruct ext4_sb_info *sbi = EXT4_SB((struct super_block *) seq->private);\r\nstruct ext4_es_stats *es_stats = &sbi->s_es_stats;\r\nstruct ext4_inode_info *ei, *max = NULL;\r\nunsigned int inode_cnt = 0;\r\nif (v != SEQ_START_TOKEN)\r\nreturn 0;\r\nspin_lock(&sbi->s_es_lock);\r\nlist_for_each_entry(ei, &sbi->s_es_list, i_es_list) {\r\ninode_cnt++;\r\nif (max && max->i_es_all_nr < ei->i_es_all_nr)\r\nmax = ei;\r\nelse if (!max)\r\nmax = ei;\r\n}\r\nspin_unlock(&sbi->s_es_lock);\r\nseq_printf(seq, "stats:\n %lld objects\n %lld reclaimable objects\n",\r\npercpu_counter_sum_positive(&es_stats->es_stats_all_cnt),\r\npercpu_counter_sum_positive(&es_stats->es_stats_shk_cnt));\r\nseq_printf(seq, " %lu/%lu cache hits/misses\n",\r\nes_stats->es_stats_cache_hits,\r\nes_stats->es_stats_cache_misses);\r\nif (inode_cnt)\r\nseq_printf(seq, " %d inodes on list\n", inode_cnt);\r\nseq_printf(seq, "average:\n %llu us scan time\n",\r\ndiv_u64(es_stats->es_stats_scan_time, 1000));\r\nseq_printf(seq, " %lu shrunk objects\n", es_stats->es_stats_shrunk);\r\nif (inode_cnt)\r\nseq_printf(seq,\r\n"maximum:\n %lu inode (%u objects, %u reclaimable)\n"\r\n" %llu us max scan time\n",\r\nmax->vfs_inode.i_ino, max->i_es_all_nr, max->i_es_shk_nr,\r\ndiv_u64(es_stats->es_stats_max_scan_time, 1000));\r\nreturn 0;\r\n}\r\nint ext4_es_register_shrinker(struct ext4_sb_info *sbi)\r\n{\r\nint err;\r\nBUILD_BUG_ON(ES_SHIFT < 48);\r\nINIT_LIST_HEAD(&sbi->s_es_list);\r\nsbi->s_es_nr_inode = 0;\r\nspin_lock_init(&sbi->s_es_lock);\r\nsbi->s_es_stats.es_stats_shrunk = 0;\r\nsbi->s_es_stats.es_stats_cache_hits = 0;\r\nsbi->s_es_stats.es_stats_cache_misses = 0;\r\nsbi->s_es_stats.es_stats_scan_time = 0;\r\nsbi->s_es_stats.es_stats_max_scan_time = 0;\r\nerr = percpu_counter_init(&sbi->s_es_stats.es_stats_all_cnt, 0, GFP_KERNEL);\r\nif (err)\r\nreturn err;\r\nerr = percpu_counter_init(&sbi->s_es_stats.es_stats_shk_cnt, 0, GFP_KERNEL);\r\nif (err)\r\ngoto err1;\r\nsbi->s_es_shrinker.scan_objects = ext4_es_scan;\r\nsbi->s_es_shrinker.count_objects = ext4_es_count;\r\nsbi->s_es_shrinker.seeks = DEFAULT_SEEKS;\r\nerr = register_shrinker(&sbi->s_es_shrinker);\r\nif (err)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\npercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\r\nerr1:\r\npercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\r\nreturn err;\r\n}\r\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\r\n{\r\npercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\r\npercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\r\nunregister_shrinker(&sbi->s_es_shrinker);\r\n}\r\nstatic int es_do_reclaim_extents(struct ext4_inode_info *ei, ext4_lblk_t end,\r\nint *nr_to_scan, int *nr_shrunk)\r\n{\r\nstruct inode *inode = &ei->vfs_inode;\r\nstruct ext4_es_tree *tree = &ei->i_es_tree;\r\nstruct extent_status *es;\r\nstruct rb_node *node;\r\nes = __es_tree_search(&tree->root, ei->i_es_shrink_lblk);\r\nif (!es)\r\ngoto out_wrap;\r\nnode = &es->rb_node;\r\nwhile (*nr_to_scan > 0) {\r\nif (es->es_lblk > end) {\r\nei->i_es_shrink_lblk = end + 1;\r\nreturn 0;\r\n}\r\n(*nr_to_scan)--;\r\nnode = rb_next(&es->rb_node);\r\nif (ext4_es_is_delayed(es))\r\ngoto next;\r\nif (ext4_es_is_referenced(es)) {\r\next4_es_clear_referenced(es);\r\ngoto next;\r\n}\r\nrb_erase(&es->rb_node, &tree->root);\r\next4_es_free_extent(inode, es);\r\n(*nr_shrunk)++;\r\nnext:\r\nif (!node)\r\ngoto out_wrap;\r\nes = rb_entry(node, struct extent_status, rb_node);\r\n}\r\nei->i_es_shrink_lblk = es->es_lblk;\r\nreturn 1;\r\nout_wrap:\r\nei->i_es_shrink_lblk = 0;\r\nreturn 0;\r\n}\r\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan)\r\n{\r\nstruct inode *inode = &ei->vfs_inode;\r\nint nr_shrunk = 0;\r\next4_lblk_t start = ei->i_es_shrink_lblk;\r\nstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\r\nDEFAULT_RATELIMIT_BURST);\r\nif (ei->i_es_shk_nr == 0)\r\nreturn 0;\r\nif (ext4_test_inode_state(inode, EXT4_STATE_EXT_PRECACHED) &&\r\n__ratelimit(&_rs))\r\next4_warning(inode->i_sb, "forced shrink of precached extents");\r\nif (!es_do_reclaim_extents(ei, EXT_MAX_BLOCKS, nr_to_scan, &nr_shrunk) &&\r\nstart != 0)\r\nes_do_reclaim_extents(ei, start - 1, nr_to_scan, &nr_shrunk);\r\nei->i_es_tree.cache_es = NULL;\r\nreturn nr_shrunk;\r\n}
