static inline struct pca9685 *to_pca(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct pca9685, chip);\r\n}\r\nstatic int pca9685_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct pca9685 *pca = to_pca(chip);\r\nunsigned long long duty;\r\nunsigned int reg;\r\nint prescale;\r\nif (period_ns != pca->period_ns) {\r\nprescale = DIV_ROUND_CLOSEST(PCA9685_OSC_CLOCK_MHZ * period_ns,\r\nPCA9685_COUNTER_RANGE * 1000) - 1;\r\nif (prescale >= PCA9685_PRESCALE_MIN &&\r\nprescale <= PCA9685_PRESCALE_MAX) {\r\nregmap_update_bits(pca->regmap, PCA9685_MODE1,\r\nMODE1_SLEEP, MODE1_SLEEP);\r\nregmap_write(pca->regmap, PCA9685_PRESCALE, prescale);\r\nregmap_update_bits(pca->regmap, PCA9685_MODE1,\r\nMODE1_SLEEP, 0x0);\r\nudelay(500);\r\npca->period_ns = period_ns;\r\nif (duty_ns == pca->duty_ns) {\r\nregmap_update_bits(pca->regmap, PCA9685_MODE1,\r\nMODE1_RESTART, 0x1);\r\nreturn 0;\r\n}\r\n} else {\r\ndev_err(chip->dev,\r\n"prescaler not set: period out of bounds!\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\npca->duty_ns = duty_ns;\r\nif (duty_ns < 1) {\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_OFF_H;\r\nelse\r\nreg = LED_N_OFF_H(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, LED_FULL);\r\nreturn 0;\r\n}\r\nif (duty_ns == period_ns) {\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_OFF_L;\r\nelse\r\nreg = LED_N_OFF_L(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, 0x0);\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_OFF_H;\r\nelse\r\nreg = LED_N_OFF_H(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, 0x0);\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_ON_H;\r\nelse\r\nreg = LED_N_ON_H(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, LED_FULL);\r\nreturn 0;\r\n}\r\nduty = PCA9685_COUNTER_RANGE * (unsigned long long)duty_ns;\r\nduty = DIV_ROUND_UP_ULL(duty, period_ns);\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_OFF_L;\r\nelse\r\nreg = LED_N_OFF_L(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, (int)duty & 0xff);\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_OFF_H;\r\nelse\r\nreg = LED_N_OFF_H(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, ((int)duty >> 8) & 0xf);\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_ON_H;\r\nelse\r\nreg = LED_N_ON_H(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, 0);\r\nreturn 0;\r\n}\r\nstatic int pca9685_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct pca9685 *pca = to_pca(chip);\r\nunsigned int reg;\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_ON_L;\r\nelse\r\nreg = LED_N_ON_L(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, 0);\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_ON_H;\r\nelse\r\nreg = LED_N_ON_H(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, 0);\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_OFF_H;\r\nelse\r\nreg = LED_N_OFF_H(pwm->hwpwm);\r\nregmap_update_bits(pca->regmap, reg, LED_FULL, 0x0);\r\nreturn 0;\r\n}\r\nstatic void pca9685_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct pca9685 *pca = to_pca(chip);\r\nunsigned int reg;\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_OFF_H;\r\nelse\r\nreg = LED_N_OFF_H(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, LED_FULL);\r\nif (pwm->hwpwm >= PCA9685_MAXCHAN)\r\nreg = PCA9685_ALL_LED_OFF_L;\r\nelse\r\nreg = LED_N_OFF_L(pwm->hwpwm);\r\nregmap_write(pca->regmap, reg, 0x0);\r\n}\r\nstatic int pca9685_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct pca9685 *pca = to_pca(chip);\r\nif (pca->active_cnt++ == 0)\r\nreturn regmap_update_bits(pca->regmap, PCA9685_MODE1,\r\nMODE1_SLEEP, 0x0);\r\nreturn 0;\r\n}\r\nstatic void pca9685_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct pca9685 *pca = to_pca(chip);\r\nif (--pca->active_cnt == 0)\r\nregmap_update_bits(pca->regmap, PCA9685_MODE1, MODE1_SLEEP,\r\nMODE1_SLEEP);\r\n}\r\nstatic int pca9685_pwm_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pca9685 *pca;\r\nint ret;\r\nint mode2;\r\npca = devm_kzalloc(&client->dev, sizeof(*pca), GFP_KERNEL);\r\nif (!pca)\r\nreturn -ENOMEM;\r\npca->regmap = devm_regmap_init_i2c(client, &pca9685_regmap_i2c_config);\r\nif (IS_ERR(pca->regmap)) {\r\nret = PTR_ERR(pca->regmap);\r\ndev_err(&client->dev, "Failed to initialize register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\npca->duty_ns = 0;\r\npca->period_ns = PCA9685_DEFAULT_PERIOD;\r\ni2c_set_clientdata(client, pca);\r\nregmap_read(pca->regmap, PCA9685_MODE2, &mode2);\r\nif (device_property_read_bool(&client->dev, "invert"))\r\nmode2 |= MODE2_INVRT;\r\nelse\r\nmode2 &= ~MODE2_INVRT;\r\nif (device_property_read_bool(&client->dev, "open-drain"))\r\nmode2 &= ~MODE2_OUTDRV;\r\nelse\r\nmode2 |= MODE2_OUTDRV;\r\nregmap_write(pca->regmap, PCA9685_MODE2, mode2);\r\nregmap_write(pca->regmap, PCA9685_ALL_LED_OFF_L, 0);\r\nregmap_write(pca->regmap, PCA9685_ALL_LED_OFF_H, 0);\r\npca->chip.ops = &pca9685_pwm_ops;\r\npca->chip.npwm = PCA9685_MAXCHAN + 1;\r\npca->chip.dev = &client->dev;\r\npca->chip.base = -1;\r\npca->chip.can_sleep = true;\r\nreturn pwmchip_add(&pca->chip);\r\n}\r\nstatic int pca9685_pwm_remove(struct i2c_client *client)\r\n{\r\nstruct pca9685 *pca = i2c_get_clientdata(client);\r\nregmap_update_bits(pca->regmap, PCA9685_MODE1, MODE1_SLEEP,\r\nMODE1_SLEEP);\r\nreturn pwmchip_remove(&pca->chip);\r\n}
