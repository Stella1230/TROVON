static int should_io_be_busy(void)\r\n{\r\n#if defined(CONFIG_X86)\r\nif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\r\nboot_cpu_data.x86 == 6 &&\r\nboot_cpu_data.x86_model >= 15)\r\nreturn 1;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic unsigned int generic_powersave_bias_target(struct cpufreq_policy *policy,\r\nunsigned int freq_next, unsigned int relation)\r\n{\r\nunsigned int freq_req, freq_reduc, freq_avg;\r\nunsigned int freq_hi, freq_lo;\r\nunsigned int index;\r\nunsigned int delay_hi_us;\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\nstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy_dbs);\r\nstruct dbs_data *dbs_data = policy_dbs->dbs_data;\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nstruct cpufreq_frequency_table *freq_table = policy->freq_table;\r\nif (!freq_table) {\r\ndbs_info->freq_lo = 0;\r\ndbs_info->freq_lo_delay_us = 0;\r\nreturn freq_next;\r\n}\r\nindex = cpufreq_frequency_table_target(policy, freq_next, relation);\r\nfreq_req = freq_table[index].frequency;\r\nfreq_reduc = freq_req * od_tuners->powersave_bias / 1000;\r\nfreq_avg = freq_req - freq_reduc;\r\nindex = cpufreq_table_find_index_h(policy, freq_avg);\r\nfreq_lo = freq_table[index].frequency;\r\nindex = cpufreq_table_find_index_l(policy, freq_avg);\r\nfreq_hi = freq_table[index].frequency;\r\nif (freq_hi == freq_lo) {\r\ndbs_info->freq_lo = 0;\r\ndbs_info->freq_lo_delay_us = 0;\r\nreturn freq_lo;\r\n}\r\ndelay_hi_us = (freq_avg - freq_lo) * dbs_data->sampling_rate;\r\ndelay_hi_us += (freq_hi - freq_lo) / 2;\r\ndelay_hi_us /= freq_hi - freq_lo;\r\ndbs_info->freq_hi_delay_us = delay_hi_us;\r\ndbs_info->freq_lo = freq_lo;\r\ndbs_info->freq_lo_delay_us = dbs_data->sampling_rate - delay_hi_us;\r\nreturn freq_hi;\r\n}\r\nstatic void ondemand_powersave_bias_init(struct cpufreq_policy *policy)\r\n{\r\nstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy->governor_data);\r\ndbs_info->freq_lo = 0;\r\n}\r\nstatic void dbs_freq_increase(struct cpufreq_policy *policy, unsigned int freq)\r\n{\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\nstruct dbs_data *dbs_data = policy_dbs->dbs_data;\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nif (od_tuners->powersave_bias)\r\nfreq = od_ops.powersave_bias_target(policy, freq,\r\nCPUFREQ_RELATION_H);\r\nelse if (policy->cur == policy->max)\r\nreturn;\r\n__cpufreq_driver_target(policy, freq, od_tuners->powersave_bias ?\r\nCPUFREQ_RELATION_L : CPUFREQ_RELATION_H);\r\n}\r\nstatic void od_update(struct cpufreq_policy *policy)\r\n{\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\nstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy_dbs);\r\nstruct dbs_data *dbs_data = policy_dbs->dbs_data;\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nunsigned int load = dbs_update(policy);\r\ndbs_info->freq_lo = 0;\r\nif (load > dbs_data->up_threshold) {\r\nif (policy->cur < policy->max)\r\npolicy_dbs->rate_mult = dbs_data->sampling_down_factor;\r\ndbs_freq_increase(policy, policy->max);\r\n} else {\r\nunsigned int freq_next, min_f, max_f;\r\nmin_f = policy->cpuinfo.min_freq;\r\nmax_f = policy->cpuinfo.max_freq;\r\nfreq_next = min_f + load * (max_f - min_f) / 100;\r\npolicy_dbs->rate_mult = 1;\r\nif (od_tuners->powersave_bias)\r\nfreq_next = od_ops.powersave_bias_target(policy,\r\nfreq_next,\r\nCPUFREQ_RELATION_L);\r\n__cpufreq_driver_target(policy, freq_next, CPUFREQ_RELATION_C);\r\n}\r\n}\r\nstatic unsigned int od_dbs_timer(struct cpufreq_policy *policy)\r\n{\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\nstruct dbs_data *dbs_data = policy_dbs->dbs_data;\r\nstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy_dbs);\r\nint sample_type = dbs_info->sample_type;\r\ndbs_info->sample_type = OD_NORMAL_SAMPLE;\r\nif (sample_type == OD_SUB_SAMPLE && policy_dbs->sample_delay_ns > 0) {\r\n__cpufreq_driver_target(policy, dbs_info->freq_lo,\r\nCPUFREQ_RELATION_H);\r\nreturn dbs_info->freq_lo_delay_us;\r\n}\r\nod_update(policy);\r\nif (dbs_info->freq_lo) {\r\ndbs_info->sample_type = OD_SUB_SAMPLE;\r\nreturn dbs_info->freq_hi_delay_us;\r\n}\r\nreturn dbs_data->sampling_rate * policy_dbs->rate_mult;\r\n}\r\nstatic ssize_t store_io_is_busy(struct gov_attr_set *attr_set, const char *buf,\r\nsize_t count)\r\n{\r\nstruct dbs_data *dbs_data = to_dbs_data(attr_set);\r\nunsigned int input;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\ndbs_data->io_is_busy = !!input;\r\ngov_update_cpu_data(dbs_data);\r\nreturn count;\r\n}\r\nstatic ssize_t store_up_threshold(struct gov_attr_set *attr_set,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dbs_data *dbs_data = to_dbs_data(attr_set);\r\nunsigned int input;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1 || input > MAX_FREQUENCY_UP_THRESHOLD ||\r\ninput < MIN_FREQUENCY_UP_THRESHOLD) {\r\nreturn -EINVAL;\r\n}\r\ndbs_data->up_threshold = input;\r\nreturn count;\r\n}\r\nstatic ssize_t store_sampling_down_factor(struct gov_attr_set *attr_set,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dbs_data *dbs_data = to_dbs_data(attr_set);\r\nstruct policy_dbs_info *policy_dbs;\r\nunsigned int input;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR || input < 1)\r\nreturn -EINVAL;\r\ndbs_data->sampling_down_factor = input;\r\nlist_for_each_entry(policy_dbs, &attr_set->policy_list, list) {\r\nmutex_lock(&policy_dbs->timer_mutex);\r\npolicy_dbs->rate_mult = 1;\r\nmutex_unlock(&policy_dbs->timer_mutex);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t store_ignore_nice_load(struct gov_attr_set *attr_set,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dbs_data *dbs_data = to_dbs_data(attr_set);\r\nunsigned int input;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nif (input > 1)\r\ninput = 1;\r\nif (input == dbs_data->ignore_nice_load) {\r\nreturn count;\r\n}\r\ndbs_data->ignore_nice_load = input;\r\ngov_update_cpu_data(dbs_data);\r\nreturn count;\r\n}\r\nstatic ssize_t store_powersave_bias(struct gov_attr_set *attr_set,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dbs_data *dbs_data = to_dbs_data(attr_set);\r\nstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\r\nstruct policy_dbs_info *policy_dbs;\r\nunsigned int input;\r\nint ret;\r\nret = sscanf(buf, "%u", &input);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nif (input > 1000)\r\ninput = 1000;\r\nod_tuners->powersave_bias = input;\r\nlist_for_each_entry(policy_dbs, &attr_set->policy_list, list)\r\nondemand_powersave_bias_init(policy_dbs->policy);\r\nreturn count;\r\n}\r\nstatic struct policy_dbs_info *od_alloc(void)\r\n{\r\nstruct od_policy_dbs_info *dbs_info;\r\ndbs_info = kzalloc(sizeof(*dbs_info), GFP_KERNEL);\r\nreturn dbs_info ? &dbs_info->policy_dbs : NULL;\r\n}\r\nstatic void od_free(struct policy_dbs_info *policy_dbs)\r\n{\r\nkfree(to_dbs_info(policy_dbs));\r\n}\r\nstatic int od_init(struct dbs_data *dbs_data)\r\n{\r\nstruct od_dbs_tuners *tuners;\r\nu64 idle_time;\r\nint cpu;\r\ntuners = kzalloc(sizeof(*tuners), GFP_KERNEL);\r\nif (!tuners)\r\nreturn -ENOMEM;\r\ncpu = get_cpu();\r\nidle_time = get_cpu_idle_time_us(cpu, NULL);\r\nput_cpu();\r\nif (idle_time != -1ULL) {\r\ndbs_data->up_threshold = MICRO_FREQUENCY_UP_THRESHOLD;\r\ndbs_data->min_sampling_rate = MICRO_FREQUENCY_MIN_SAMPLE_RATE;\r\n} else {\r\ndbs_data->up_threshold = DEF_FREQUENCY_UP_THRESHOLD;\r\ndbs_data->min_sampling_rate = MIN_SAMPLING_RATE_RATIO *\r\njiffies_to_usecs(10);\r\n}\r\ndbs_data->sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR;\r\ndbs_data->ignore_nice_load = 0;\r\ntuners->powersave_bias = default_powersave_bias;\r\ndbs_data->io_is_busy = should_io_be_busy();\r\ndbs_data->tuners = tuners;\r\nreturn 0;\r\n}\r\nstatic void od_exit(struct dbs_data *dbs_data)\r\n{\r\nkfree(dbs_data->tuners);\r\n}\r\nstatic void od_start(struct cpufreq_policy *policy)\r\n{\r\nstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy->governor_data);\r\ndbs_info->sample_type = OD_NORMAL_SAMPLE;\r\nondemand_powersave_bias_init(policy);\r\n}\r\nstatic void od_set_powersave_bias(unsigned int powersave_bias)\r\n{\r\nunsigned int cpu;\r\ncpumask_t done;\r\ndefault_powersave_bias = powersave_bias;\r\ncpumask_clear(&done);\r\nget_online_cpus();\r\nfor_each_online_cpu(cpu) {\r\nstruct cpufreq_policy *policy;\r\nstruct policy_dbs_info *policy_dbs;\r\nstruct dbs_data *dbs_data;\r\nstruct od_dbs_tuners *od_tuners;\r\nif (cpumask_test_cpu(cpu, &done))\r\ncontinue;\r\npolicy = cpufreq_cpu_get_raw(cpu);\r\nif (!policy || policy->governor != CPU_FREQ_GOV_ONDEMAND)\r\ncontinue;\r\npolicy_dbs = policy->governor_data;\r\nif (!policy_dbs)\r\ncontinue;\r\ncpumask_or(&done, &done, policy->cpus);\r\ndbs_data = policy_dbs->dbs_data;\r\nod_tuners = dbs_data->tuners;\r\nod_tuners->powersave_bias = default_powersave_bias;\r\n}\r\nput_online_cpus();\r\n}\r\nvoid od_unregister_powersave_bias_handler(void)\r\n{\r\nod_ops.powersave_bias_target = generic_powersave_bias_target;\r\nod_set_powersave_bias(0);\r\n}\r\nstatic int __init cpufreq_gov_dbs_init(void)\r\n{\r\nreturn cpufreq_register_governor(CPU_FREQ_GOV_ONDEMAND);\r\n}\r\nstatic void __exit cpufreq_gov_dbs_exit(void)\r\n{\r\ncpufreq_unregister_governor(CPU_FREQ_GOV_ONDEMAND);\r\n}\r\nstruct cpufreq_governor *cpufreq_default_governor(void)\r\n{\r\nreturn CPU_FREQ_GOV_ONDEMAND;\r\n}
