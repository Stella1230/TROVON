static void moxa_wait_finish(void __iomem *ofsAddr)\r\n{\r\nunsigned long end = jiffies + moxaFuncTout;\r\nwhile (readw(ofsAddr + FuncCode) != 0)\r\nif (time_after(jiffies, end))\r\nreturn;\r\nif (readw(ofsAddr + FuncCode) != 0)\r\nprintk_ratelimited(KERN_WARNING "moxa function expired\n");\r\n}\r\nstatic void moxafunc(void __iomem *ofsAddr, u16 cmd, u16 arg)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&moxafunc_lock, flags);\r\nwritew(arg, ofsAddr + FuncArg);\r\nwritew(cmd, ofsAddr + FuncCode);\r\nmoxa_wait_finish(ofsAddr);\r\nspin_unlock_irqrestore(&moxafunc_lock, flags);\r\n}\r\nstatic int moxafuncret(void __iomem *ofsAddr, u16 cmd, u16 arg)\r\n{\r\nunsigned long flags;\r\nu16 ret;\r\nspin_lock_irqsave(&moxafunc_lock, flags);\r\nwritew(arg, ofsAddr + FuncArg);\r\nwritew(cmd, ofsAddr + FuncCode);\r\nmoxa_wait_finish(ofsAddr);\r\nret = readw(ofsAddr + FuncArg);\r\nspin_unlock_irqrestore(&moxafunc_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void moxa_low_water_check(void __iomem *ofsAddr)\r\n{\r\nu16 rptr, wptr, mask, len;\r\nif (readb(ofsAddr + FlagStat) & Xoff_state) {\r\nrptr = readw(ofsAddr + RXrptr);\r\nwptr = readw(ofsAddr + RXwptr);\r\nmask = readw(ofsAddr + RX_mask);\r\nlen = (wptr - rptr) & mask;\r\nif (len <= Low_water)\r\nmoxafunc(ofsAddr, FC_SendXon, 0);\r\n}\r\n}\r\nstatic int moxa_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint status, ret = 0;\r\nif (tty->index == MAX_PORTS) {\r\nif (cmd != MOXA_GETDATACOUNT && cmd != MOXA_GET_IOQUEUE &&\r\ncmd != MOXA_GETMSTATUS)\r\nreturn -EINVAL;\r\n} else if (!ch)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase MOXA_GETDATACOUNT:\r\nmoxaLog.tick = jiffies;\r\nif (copy_to_user(argp, &moxaLog, sizeof(moxaLog)))\r\nret = -EFAULT;\r\nbreak;\r\ncase MOXA_FLUSH_QUEUE:\r\nMoxaPortFlushData(ch, arg);\r\nbreak;\r\ncase MOXA_GET_IOQUEUE: {\r\nstruct moxaq_str __user *argm = argp;\r\nstruct moxaq_str tmp;\r\nstruct moxa_port *p;\r\nunsigned int i, j;\r\nfor (i = 0; i < MAX_BOARDS; i++) {\r\np = moxa_boards[i].ports;\r\nfor (j = 0; j < MAX_PORTS_PER_BOARD; j++, p++, argm++) {\r\nmemset(&tmp, 0, sizeof(tmp));\r\nspin_lock_bh(&moxa_lock);\r\nif (moxa_boards[i].ready) {\r\ntmp.inq = MoxaPortRxQueue(p);\r\ntmp.outq = MoxaPortTxQueue(p);\r\n}\r\nspin_unlock_bh(&moxa_lock);\r\nif (copy_to_user(argm, &tmp, sizeof(tmp)))\r\nreturn -EFAULT;\r\n}\r\n}\r\nbreak;\r\n} case MOXA_GET_OQUEUE:\r\nstatus = MoxaPortTxQueue(ch);\r\nret = put_user(status, (unsigned long __user *)argp);\r\nbreak;\r\ncase MOXA_GET_IQUEUE:\r\nstatus = MoxaPortRxQueue(ch);\r\nret = put_user(status, (unsigned long __user *)argp);\r\nbreak;\r\ncase MOXA_GETMSTATUS: {\r\nstruct mxser_mstatus __user *argm = argp;\r\nstruct mxser_mstatus tmp;\r\nstruct moxa_port *p;\r\nunsigned int i, j;\r\nfor (i = 0; i < MAX_BOARDS; i++) {\r\np = moxa_boards[i].ports;\r\nfor (j = 0; j < MAX_PORTS_PER_BOARD; j++, p++, argm++) {\r\nstruct tty_struct *ttyp;\r\nmemset(&tmp, 0, sizeof(tmp));\r\nspin_lock_bh(&moxa_lock);\r\nif (!moxa_boards[i].ready) {\r\nspin_unlock_bh(&moxa_lock);\r\ngoto copy;\r\n}\r\nstatus = MoxaPortLineStatus(p);\r\nspin_unlock_bh(&moxa_lock);\r\nif (status & 1)\r\ntmp.cts = 1;\r\nif (status & 2)\r\ntmp.dsr = 1;\r\nif (status & 4)\r\ntmp.dcd = 1;\r\nttyp = tty_port_tty_get(&p->port);\r\nif (!ttyp)\r\ntmp.cflag = p->cflag;\r\nelse\r\ntmp.cflag = ttyp->termios.c_cflag;\r\ntty_kref_put(ttyp);\r\ncopy:\r\nif (copy_to_user(argm, &tmp, sizeof(tmp)))\r\nreturn -EFAULT;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase TIOCGSERIAL:\r\nmutex_lock(&ch->port.mutex);\r\nret = moxa_get_serial_info(ch, argp);\r\nmutex_unlock(&ch->port.mutex);\r\nbreak;\r\ncase TIOCSSERIAL:\r\nmutex_lock(&ch->port.mutex);\r\nret = moxa_set_serial_info(ch, argp);\r\nmutex_unlock(&ch->port.mutex);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}\r\nstatic int moxa_break_ctl(struct tty_struct *tty, int state)\r\n{\r\nstruct moxa_port *port = tty->driver_data;\r\nmoxafunc(port->tableAddr, state ? FC_SendBreak : FC_StopBreak,\r\nMagic_code);\r\nreturn 0;\r\n}\r\nstatic int moxa_check_fw_model(struct moxa_board_conf *brd, u8 model)\r\n{\r\nswitch (brd->boardType) {\r\ncase MOXA_BOARD_C218_ISA:\r\ncase MOXA_BOARD_C218_PCI:\r\nif (model != 1)\r\ngoto err;\r\nbreak;\r\ncase MOXA_BOARD_CP204J:\r\nif (model != 3)\r\ngoto err;\r\nbreak;\r\ndefault:\r\nif (model != 2)\r\ngoto err;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn -EINVAL;\r\n}\r\nstatic int moxa_check_fw(const void *ptr)\r\n{\r\nconst __le16 *lptr = ptr;\r\nif (*lptr != cpu_to_le16(0x7980))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int moxa_load_bios(struct moxa_board_conf *brd, const u8 *buf,\r\nsize_t len)\r\n{\r\nvoid __iomem *baseAddr = brd->basemem;\r\nu16 tmp;\r\nwriteb(HW_reset, baseAddr + Control_reg);\r\nmsleep(10);\r\nmemset_io(baseAddr, 0, 4096);\r\nmemcpy_toio(baseAddr, buf, len);\r\nwriteb(0, baseAddr + Control_reg);\r\nmsleep(2000);\r\nswitch (brd->boardType) {\r\ncase MOXA_BOARD_C218_ISA:\r\ncase MOXA_BOARD_C218_PCI:\r\ntmp = readw(baseAddr + C218_key);\r\nif (tmp != C218_KeyCode)\r\ngoto err;\r\nbreak;\r\ncase MOXA_BOARD_CP204J:\r\ntmp = readw(baseAddr + C218_key);\r\nif (tmp != CP204J_KeyCode)\r\ngoto err;\r\nbreak;\r\ndefault:\r\ntmp = readw(baseAddr + C320_key);\r\nif (tmp != C320_KeyCode)\r\ngoto err;\r\ntmp = readw(baseAddr + C320_status);\r\nif (tmp != STS_init) {\r\nprintk(KERN_ERR "MOXA: bios upload failed -- CPU/Basic "\r\n"module not found\n");\r\nreturn -EIO;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\nprintk(KERN_ERR "MOXA: bios upload failed -- board not found\n");\r\nreturn -EIO;\r\n}\r\nstatic int moxa_load_320b(struct moxa_board_conf *brd, const u8 *ptr,\r\nsize_t len)\r\n{\r\nvoid __iomem *baseAddr = brd->basemem;\r\nif (len < 7168) {\r\nprintk(KERN_ERR "MOXA: invalid 320 bios -- too short\n");\r\nreturn -EINVAL;\r\n}\r\nwritew(len - 7168 - 2, baseAddr + C320bapi_len);\r\nwriteb(1, baseAddr + Control_reg);\r\nmemcpy_toio(baseAddr + DynPage_addr, ptr, 7168);\r\nwriteb(2, baseAddr + Control_reg);\r\nmemcpy_toio(baseAddr + DynPage_addr, ptr + 7168, len - 7168);\r\nreturn 0;\r\n}\r\nstatic int moxa_real_load_code(struct moxa_board_conf *brd, const void *ptr,\r\nsize_t len)\r\n{\r\nvoid __iomem *baseAddr = brd->basemem;\r\nconst __le16 *uptr = ptr;\r\nsize_t wlen, len2, j;\r\nunsigned long key, loadbuf, loadlen, checksum, checksum_ok;\r\nunsigned int i, retry;\r\nu16 usum, keycode;\r\nkeycode = (brd->boardType == MOXA_BOARD_CP204J) ? CP204J_KeyCode :\r\nC218_KeyCode;\r\nswitch (brd->boardType) {\r\ncase MOXA_BOARD_CP204J:\r\ncase MOXA_BOARD_C218_ISA:\r\ncase MOXA_BOARD_C218_PCI:\r\nkey = C218_key;\r\nloadbuf = C218_LoadBuf;\r\nloadlen = C218DLoad_len;\r\nchecksum = C218check_sum;\r\nchecksum_ok = C218chksum_ok;\r\nbreak;\r\ndefault:\r\nkey = C320_key;\r\nkeycode = C320_KeyCode;\r\nloadbuf = C320_LoadBuf;\r\nloadlen = C320DLoad_len;\r\nchecksum = C320check_sum;\r\nchecksum_ok = C320chksum_ok;\r\nbreak;\r\n}\r\nusum = 0;\r\nwlen = len >> 1;\r\nfor (i = 0; i < wlen; i++)\r\nusum += le16_to_cpu(uptr[i]);\r\nretry = 0;\r\ndo {\r\nwlen = len >> 1;\r\nj = 0;\r\nwhile (wlen) {\r\nlen2 = (wlen > 2048) ? 2048 : wlen;\r\nwlen -= len2;\r\nmemcpy_toio(baseAddr + loadbuf, ptr + j, len2 << 1);\r\nj += len2 << 1;\r\nwritew(len2, baseAddr + loadlen);\r\nwritew(0, baseAddr + key);\r\nfor (i = 0; i < 100; i++) {\r\nif (readw(baseAddr + key) == keycode)\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (readw(baseAddr + key) != keycode)\r\nreturn -EIO;\r\n}\r\nwritew(0, baseAddr + loadlen);\r\nwritew(usum, baseAddr + checksum);\r\nwritew(0, baseAddr + key);\r\nfor (i = 0; i < 100; i++) {\r\nif (readw(baseAddr + key) == keycode)\r\nbreak;\r\nmsleep(10);\r\n}\r\nretry++;\r\n} while ((readb(baseAddr + checksum_ok) != 1) && (retry < 3));\r\nif (readb(baseAddr + checksum_ok) != 1)\r\nreturn -EIO;\r\nwritew(0, baseAddr + key);\r\nfor (i = 0; i < 600; i++) {\r\nif (readw(baseAddr + Magic_no) == Magic_code)\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (readw(baseAddr + Magic_no) != Magic_code)\r\nreturn -EIO;\r\nif (MOXA_IS_320(brd)) {\r\nif (brd->busType == MOXA_BUS_TYPE_PCI) {\r\nwritew(0x3800, baseAddr + TMS320_PORT1);\r\nwritew(0x3900, baseAddr + TMS320_PORT2);\r\nwritew(28499, baseAddr + TMS320_CLOCK);\r\n} else {\r\nwritew(0x3200, baseAddr + TMS320_PORT1);\r\nwritew(0x3400, baseAddr + TMS320_PORT2);\r\nwritew(19999, baseAddr + TMS320_CLOCK);\r\n}\r\n}\r\nwritew(1, baseAddr + Disable_IRQ);\r\nwritew(0, baseAddr + Magic_no);\r\nfor (i = 0; i < 500; i++) {\r\nif (readw(baseAddr + Magic_no) == Magic_code)\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (readw(baseAddr + Magic_no) != Magic_code)\r\nreturn -EIO;\r\nif (MOXA_IS_320(brd)) {\r\nj = readw(baseAddr + Module_cnt);\r\nif (j <= 0)\r\nreturn -EIO;\r\nbrd->numPorts = j * 8;\r\nwritew(j, baseAddr + Module_no);\r\nwritew(0, baseAddr + Magic_no);\r\nfor (i = 0; i < 600; i++) {\r\nif (readw(baseAddr + Magic_no) == Magic_code)\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (readw(baseAddr + Magic_no) != Magic_code)\r\nreturn -EIO;\r\n}\r\nbrd->intNdx = baseAddr + IRQindex;\r\nbrd->intPend = baseAddr + IRQpending;\r\nbrd->intTable = baseAddr + IRQtable;\r\nreturn 0;\r\n}\r\nstatic int moxa_load_code(struct moxa_board_conf *brd, const void *ptr,\r\nsize_t len)\r\n{\r\nvoid __iomem *ofsAddr, *baseAddr = brd->basemem;\r\nstruct moxa_port *port;\r\nint retval, i;\r\nif (len % 2) {\r\nprintk(KERN_ERR "MOXA: bios length is not even\n");\r\nreturn -EINVAL;\r\n}\r\nretval = moxa_real_load_code(brd, ptr, len);\r\nif (retval)\r\nreturn retval;\r\nswitch (brd->boardType) {\r\ncase MOXA_BOARD_C218_ISA:\r\ncase MOXA_BOARD_C218_PCI:\r\ncase MOXA_BOARD_CP204J:\r\nport = brd->ports;\r\nfor (i = 0; i < brd->numPorts; i++, port++) {\r\nport->board = brd;\r\nport->DCDState = 0;\r\nport->tableAddr = baseAddr + Extern_table +\r\nExtern_size * i;\r\nofsAddr = port->tableAddr;\r\nwritew(C218rx_mask, ofsAddr + RX_mask);\r\nwritew(C218tx_mask, ofsAddr + TX_mask);\r\nwritew(C218rx_spage + i * C218buf_pageno, ofsAddr + Page_rxb);\r\nwritew(readw(ofsAddr + Page_rxb) + C218rx_pageno, ofsAddr + EndPage_rxb);\r\nwritew(C218tx_spage + i * C218buf_pageno, ofsAddr + Page_txb);\r\nwritew(readw(ofsAddr + Page_txb) + C218tx_pageno, ofsAddr + EndPage_txb);\r\n}\r\nbreak;\r\ndefault:\r\nport = brd->ports;\r\nfor (i = 0; i < brd->numPorts; i++, port++) {\r\nport->board = brd;\r\nport->DCDState = 0;\r\nport->tableAddr = baseAddr + Extern_table +\r\nExtern_size * i;\r\nofsAddr = port->tableAddr;\r\nswitch (brd->numPorts) {\r\ncase 8:\r\nwritew(C320p8rx_mask, ofsAddr + RX_mask);\r\nwritew(C320p8tx_mask, ofsAddr + TX_mask);\r\nwritew(C320p8rx_spage + i * C320p8buf_pgno, ofsAddr + Page_rxb);\r\nwritew(readw(ofsAddr + Page_rxb) + C320p8rx_pgno, ofsAddr + EndPage_rxb);\r\nwritew(C320p8tx_spage + i * C320p8buf_pgno, ofsAddr + Page_txb);\r\nwritew(readw(ofsAddr + Page_txb) + C320p8tx_pgno, ofsAddr + EndPage_txb);\r\nbreak;\r\ncase 16:\r\nwritew(C320p16rx_mask, ofsAddr + RX_mask);\r\nwritew(C320p16tx_mask, ofsAddr + TX_mask);\r\nwritew(C320p16rx_spage + i * C320p16buf_pgno, ofsAddr + Page_rxb);\r\nwritew(readw(ofsAddr + Page_rxb) + C320p16rx_pgno, ofsAddr + EndPage_rxb);\r\nwritew(C320p16tx_spage + i * C320p16buf_pgno, ofsAddr + Page_txb);\r\nwritew(readw(ofsAddr + Page_txb) + C320p16tx_pgno, ofsAddr + EndPage_txb);\r\nbreak;\r\ncase 24:\r\nwritew(C320p24rx_mask, ofsAddr + RX_mask);\r\nwritew(C320p24tx_mask, ofsAddr + TX_mask);\r\nwritew(C320p24rx_spage + i * C320p24buf_pgno, ofsAddr + Page_rxb);\r\nwritew(readw(ofsAddr + Page_rxb) + C320p24rx_pgno, ofsAddr + EndPage_rxb);\r\nwritew(C320p24tx_spage + i * C320p24buf_pgno, ofsAddr + Page_txb);\r\nwritew(readw(ofsAddr + Page_txb), ofsAddr + EndPage_txb);\r\nbreak;\r\ncase 32:\r\nwritew(C320p32rx_mask, ofsAddr + RX_mask);\r\nwritew(C320p32tx_mask, ofsAddr + TX_mask);\r\nwritew(C320p32tx_ofs, ofsAddr + Ofs_txb);\r\nwritew(C320p32rx_spage + i * C320p32buf_pgno, ofsAddr + Page_rxb);\r\nwritew(readb(ofsAddr + Page_rxb), ofsAddr + EndPage_rxb);\r\nwritew(C320p32tx_spage + i * C320p32buf_pgno, ofsAddr + Page_txb);\r\nwritew(readw(ofsAddr + Page_txb), ofsAddr + EndPage_txb);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int moxa_load_fw(struct moxa_board_conf *brd, const struct firmware *fw)\r\n{\r\nconst void *ptr = fw->data;\r\nchar rsn[64];\r\nu16 lens[5];\r\nsize_t len;\r\nunsigned int a, lenp, lencnt;\r\nint ret = -EINVAL;\r\nstruct {\r\n__le32 magic;\r\nu8 reserved1[2];\r\nu8 type;\r\nu8 model;\r\nu8 reserved2[8];\r\n__le16 len[5];\r\n} const *hdr = ptr;\r\nBUILD_BUG_ON(ARRAY_SIZE(hdr->len) != ARRAY_SIZE(lens));\r\nif (fw->size < MOXA_FW_HDRLEN) {\r\nstrcpy(rsn, "too short (even header won't fit)");\r\ngoto err;\r\n}\r\nif (hdr->magic != cpu_to_le32(0x30343034)) {\r\nsprintf(rsn, "bad magic: %.8x", le32_to_cpu(hdr->magic));\r\ngoto err;\r\n}\r\nif (hdr->type != 3) {\r\nsprintf(rsn, "not for linux, type is %u", hdr->type);\r\ngoto err;\r\n}\r\nif (moxa_check_fw_model(brd, hdr->model)) {\r\nsprintf(rsn, "not for this card, model is %u", hdr->model);\r\ngoto err;\r\n}\r\nlen = MOXA_FW_HDRLEN;\r\nlencnt = hdr->model == 2 ? 5 : 3;\r\nfor (a = 0; a < ARRAY_SIZE(lens); a++) {\r\nlens[a] = le16_to_cpu(hdr->len[a]);\r\nif (lens[a] && len + lens[a] <= fw->size &&\r\nmoxa_check_fw(&fw->data[len]))\r\nprintk(KERN_WARNING "MOXA firmware: unexpected input "\r\n"at offset %u, but going on\n", (u32)len);\r\nif (!lens[a] && a < lencnt) {\r\nsprintf(rsn, "too few entries in fw file");\r\ngoto err;\r\n}\r\nlen += lens[a];\r\n}\r\nif (len != fw->size) {\r\nsprintf(rsn, "bad length: %u (should be %u)", (u32)fw->size,\r\n(u32)len);\r\ngoto err;\r\n}\r\nptr += MOXA_FW_HDRLEN;\r\nlenp = 0;\r\nstrcpy(rsn, "read above");\r\nret = moxa_load_bios(brd, ptr, lens[lenp]);\r\nif (ret)\r\ngoto err;\r\nptr += lens[lenp] + lens[lenp + 1];\r\nlenp += 2;\r\nif (hdr->model == 2) {\r\nret = moxa_load_320b(brd, ptr, lens[lenp]);\r\nif (ret)\r\ngoto err;\r\nptr += lens[lenp] + lens[lenp + 1];\r\nlenp += 2;\r\n}\r\nret = moxa_load_code(brd, ptr, lens[lenp]);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nprintk(KERN_ERR "firmware failed to load, reason: %s\n", rsn);\r\nreturn ret;\r\n}\r\nstatic int moxa_init_board(struct moxa_board_conf *brd, struct device *dev)\r\n{\r\nconst struct firmware *fw;\r\nconst char *file;\r\nstruct moxa_port *p;\r\nunsigned int i, first_idx;\r\nint ret;\r\nbrd->ports = kcalloc(MAX_PORTS_PER_BOARD, sizeof(*brd->ports),\r\nGFP_KERNEL);\r\nif (brd->ports == NULL) {\r\nprintk(KERN_ERR "cannot allocate memory for ports\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (i = 0, p = brd->ports; i < MAX_PORTS_PER_BOARD; i++, p++) {\r\ntty_port_init(&p->port);\r\np->port.ops = &moxa_port_ops;\r\np->type = PORT_16550A;\r\np->cflag = B9600 | CS8 | CREAD | CLOCAL | HUPCL;\r\n}\r\nswitch (brd->boardType) {\r\ncase MOXA_BOARD_C218_ISA:\r\ncase MOXA_BOARD_C218_PCI:\r\nfile = "c218tunx.cod";\r\nbreak;\r\ncase MOXA_BOARD_CP204J:\r\nfile = "cp204unx.cod";\r\nbreak;\r\ndefault:\r\nfile = "c320tunx.cod";\r\nbreak;\r\n}\r\nret = request_firmware(&fw, file, dev);\r\nif (ret) {\r\nprintk(KERN_ERR "MOXA: request_firmware failed. Make sure "\r\n"you've placed '%s' file into your firmware "\r\n"loader directory (e.g. /lib/firmware)\n",\r\nfile);\r\ngoto err_free;\r\n}\r\nret = moxa_load_fw(brd, fw);\r\nrelease_firmware(fw);\r\nif (ret)\r\ngoto err_free;\r\nspin_lock_bh(&moxa_lock);\r\nbrd->ready = 1;\r\nif (!timer_pending(&moxaTimer))\r\nmod_timer(&moxaTimer, jiffies + HZ / 50);\r\nspin_unlock_bh(&moxa_lock);\r\nfirst_idx = (brd - moxa_boards) * MAX_PORTS_PER_BOARD;\r\nfor (i = 0; i < brd->numPorts; i++)\r\ntty_port_register_device(&brd->ports[i].port, moxaDriver,\r\nfirst_idx + i, dev);\r\nreturn 0;\r\nerr_free:\r\nfor (i = 0; i < MAX_PORTS_PER_BOARD; i++)\r\ntty_port_destroy(&brd->ports[i].port);\r\nkfree(brd->ports);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void moxa_board_deinit(struct moxa_board_conf *brd)\r\n{\r\nunsigned int a, opened, first_idx;\r\nmutex_lock(&moxa_openlock);\r\nspin_lock_bh(&moxa_lock);\r\nbrd->ready = 0;\r\nspin_unlock_bh(&moxa_lock);\r\nfor (a = 0; a < brd->numPorts; a++)\r\nif (tty_port_initialized(&brd->ports[a].port))\r\ntty_port_tty_hangup(&brd->ports[a].port, false);\r\nfor (a = 0; a < MAX_PORTS_PER_BOARD; a++)\r\ntty_port_destroy(&brd->ports[a].port);\r\nwhile (1) {\r\nopened = 0;\r\nfor (a = 0; a < brd->numPorts; a++)\r\nif (tty_port_initialized(&brd->ports[a].port))\r\nopened++;\r\nmutex_unlock(&moxa_openlock);\r\nif (!opened)\r\nbreak;\r\nmsleep(50);\r\nmutex_lock(&moxa_openlock);\r\n}\r\nfirst_idx = (brd - moxa_boards) * MAX_PORTS_PER_BOARD;\r\nfor (a = 0; a < brd->numPorts; a++)\r\ntty_unregister_device(moxaDriver, first_idx + a);\r\niounmap(brd->basemem);\r\nbrd->basemem = NULL;\r\nkfree(brd->ports);\r\n}\r\nstatic int moxa_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct moxa_board_conf *board;\r\nunsigned int i;\r\nint board_type = ent->driver_data;\r\nint retval;\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "can't enable pci device\n");\r\ngoto err;\r\n}\r\nfor (i = 0; i < MAX_BOARDS; i++)\r\nif (moxa_boards[i].basemem == NULL)\r\nbreak;\r\nretval = -ENODEV;\r\nif (i >= MAX_BOARDS) {\r\ndev_warn(&pdev->dev, "more than %u MOXA Intellio family boards "\r\n"found. Board is ignored.\n", MAX_BOARDS);\r\ngoto err;\r\n}\r\nboard = &moxa_boards[i];\r\nretval = pci_request_region(pdev, 2, "moxa-base");\r\nif (retval) {\r\ndev_err(&pdev->dev, "can't request pci region 2\n");\r\ngoto err;\r\n}\r\nboard->basemem = ioremap_nocache(pci_resource_start(pdev, 2), 0x4000);\r\nif (board->basemem == NULL) {\r\ndev_err(&pdev->dev, "can't remap io space 2\n");\r\nretval = -ENOMEM;\r\ngoto err_reg;\r\n}\r\nboard->boardType = board_type;\r\nswitch (board_type) {\r\ncase MOXA_BOARD_C218_ISA:\r\ncase MOXA_BOARD_C218_PCI:\r\nboard->numPorts = 8;\r\nbreak;\r\ncase MOXA_BOARD_CP204J:\r\nboard->numPorts = 4;\r\nbreak;\r\ndefault:\r\nboard->numPorts = 0;\r\nbreak;\r\n}\r\nboard->busType = MOXA_BUS_TYPE_PCI;\r\nretval = moxa_init_board(board, &pdev->dev);\r\nif (retval)\r\ngoto err_base;\r\npci_set_drvdata(pdev, board);\r\ndev_info(&pdev->dev, "board '%s' ready (%u ports, firmware loaded)\n",\r\nmoxa_brdname[board_type - 1], board->numPorts);\r\nreturn 0;\r\nerr_base:\r\niounmap(board->basemem);\r\nboard->basemem = NULL;\r\nerr_reg:\r\npci_release_region(pdev, 2);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic void moxa_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct moxa_board_conf *brd = pci_get_drvdata(pdev);\r\nmoxa_board_deinit(brd);\r\npci_release_region(pdev, 2);\r\n}\r\nstatic int __init moxa_init(void)\r\n{\r\nunsigned int isabrds = 0;\r\nint retval = 0;\r\nstruct moxa_board_conf *brd = moxa_boards;\r\nunsigned int i;\r\nprintk(KERN_INFO "MOXA Intellio family driver version %s\n",\r\nMOXA_VERSION);\r\ntty_port_init(&moxa_service_port);\r\nmoxaDriver = tty_alloc_driver(MAX_PORTS + 1,\r\nTTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV);\r\nif (IS_ERR(moxaDriver))\r\nreturn PTR_ERR(moxaDriver);\r\nmoxaDriver->name = "ttyMX";\r\nmoxaDriver->major = ttymajor;\r\nmoxaDriver->minor_start = 0;\r\nmoxaDriver->type = TTY_DRIVER_TYPE_SERIAL;\r\nmoxaDriver->subtype = SERIAL_TYPE_NORMAL;\r\nmoxaDriver->init_termios = tty_std_termios;\r\nmoxaDriver->init_termios.c_cflag = B9600 | CS8 | CREAD | CLOCAL | HUPCL;\r\nmoxaDriver->init_termios.c_ispeed = 9600;\r\nmoxaDriver->init_termios.c_ospeed = 9600;\r\ntty_set_operations(moxaDriver, &moxa_ops);\r\ntty_port_link_device(&moxa_service_port, moxaDriver, MAX_PORTS);\r\nif (tty_register_driver(moxaDriver)) {\r\nprintk(KERN_ERR "can't register MOXA Smartio tty driver!\n");\r\nput_tty_driver(moxaDriver);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < MAX_BOARDS; i++) {\r\nif (!baseaddr[i])\r\nbreak;\r\nif (type[i] == MOXA_BOARD_C218_ISA ||\r\ntype[i] == MOXA_BOARD_C320_ISA) {\r\npr_debug("Moxa board %2d: %s board(baseAddr=%lx)\n",\r\nisabrds + 1, moxa_brdname[type[i] - 1],\r\nbaseaddr[i]);\r\nbrd->boardType = type[i];\r\nbrd->numPorts = type[i] == MOXA_BOARD_C218_ISA ? 8 :\r\nnumports[i];\r\nbrd->busType = MOXA_BUS_TYPE_ISA;\r\nbrd->basemem = ioremap_nocache(baseaddr[i], 0x4000);\r\nif (!brd->basemem) {\r\nprintk(KERN_ERR "MOXA: can't remap %lx\n",\r\nbaseaddr[i]);\r\ncontinue;\r\n}\r\nif (moxa_init_board(brd, NULL)) {\r\niounmap(brd->basemem);\r\nbrd->basemem = NULL;\r\ncontinue;\r\n}\r\nprintk(KERN_INFO "MOXA isa board found at 0x%.8lx and "\r\n"ready (%u ports, firmware loaded)\n",\r\nbaseaddr[i], brd->numPorts);\r\nbrd++;\r\nisabrds++;\r\n}\r\n}\r\n#ifdef CONFIG_PCI\r\nretval = pci_register_driver(&moxa_pci_driver);\r\nif (retval) {\r\nprintk(KERN_ERR "Can't register MOXA pci driver!\n");\r\nif (isabrds)\r\nretval = 0;\r\n}\r\n#endif\r\nreturn retval;\r\n}\r\nstatic void __exit moxa_exit(void)\r\n{\r\nunsigned int i;\r\n#ifdef CONFIG_PCI\r\npci_unregister_driver(&moxa_pci_driver);\r\n#endif\r\nfor (i = 0; i < MAX_BOARDS; i++)\r\nif (moxa_boards[i].ready)\r\nmoxa_board_deinit(&moxa_boards[i]);\r\ndel_timer_sync(&moxaTimer);\r\nif (tty_unregister_driver(moxaDriver))\r\nprintk(KERN_ERR "Couldn't unregister MOXA Intellio family "\r\n"serial driver\n");\r\nput_tty_driver(moxaDriver);\r\n}\r\nstatic void moxa_shutdown(struct tty_port *port)\r\n{\r\nstruct moxa_port *ch = container_of(port, struct moxa_port, port);\r\nMoxaPortDisable(ch);\r\nMoxaPortFlushData(ch, 2);\r\n}\r\nstatic int moxa_carrier_raised(struct tty_port *port)\r\n{\r\nstruct moxa_port *ch = container_of(port, struct moxa_port, port);\r\nint dcd;\r\nspin_lock_irq(&port->lock);\r\ndcd = ch->DCDState;\r\nspin_unlock_irq(&port->lock);\r\nreturn dcd;\r\n}\r\nstatic void moxa_dtr_rts(struct tty_port *port, int onoff)\r\n{\r\nstruct moxa_port *ch = container_of(port, struct moxa_port, port);\r\nMoxaPortLineCtrl(ch, onoff, onoff);\r\n}\r\nstatic int moxa_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct moxa_board_conf *brd;\r\nstruct moxa_port *ch;\r\nint port;\r\nport = tty->index;\r\nif (port == MAX_PORTS) {\r\nreturn capable(CAP_SYS_ADMIN) ? 0 : -EPERM;\r\n}\r\nif (mutex_lock_interruptible(&moxa_openlock))\r\nreturn -ERESTARTSYS;\r\nbrd = &moxa_boards[port / MAX_PORTS_PER_BOARD];\r\nif (!brd->ready) {\r\nmutex_unlock(&moxa_openlock);\r\nreturn -ENODEV;\r\n}\r\nif (port % MAX_PORTS_PER_BOARD >= brd->numPorts) {\r\nmutex_unlock(&moxa_openlock);\r\nreturn -ENODEV;\r\n}\r\nch = &brd->ports[port % MAX_PORTS_PER_BOARD];\r\nch->port.count++;\r\ntty->driver_data = ch;\r\ntty_port_tty_set(&ch->port, tty);\r\nmutex_lock(&ch->port.mutex);\r\nif (!tty_port_initialized(&ch->port)) {\r\nch->statusflags = 0;\r\nmoxa_set_tty_param(tty, &tty->termios);\r\nMoxaPortLineCtrl(ch, 1, 1);\r\nMoxaPortEnable(ch);\r\nMoxaSetFifo(ch, ch->type == PORT_16550A);\r\ntty_port_set_initialized(&ch->port, 1);\r\n}\r\nmutex_unlock(&ch->port.mutex);\r\nmutex_unlock(&moxa_openlock);\r\nreturn tty_port_block_til_ready(&ch->port, tty, filp);\r\n}\r\nstatic void moxa_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nch->cflag = tty->termios.c_cflag;\r\ntty_port_close(&ch->port, tty, filp);\r\n}\r\nstatic int moxa_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nunsigned long flags;\r\nint len;\r\nif (ch == NULL)\r\nreturn 0;\r\nspin_lock_irqsave(&moxa_lock, flags);\r\nlen = MoxaPortWriteData(tty, buf, count);\r\nspin_unlock_irqrestore(&moxa_lock, flags);\r\nset_bit(LOWWAIT, &ch->statusflags);\r\nreturn len;\r\n}\r\nstatic int moxa_write_room(struct tty_struct *tty)\r\n{\r\nstruct moxa_port *ch;\r\nif (tty->stopped)\r\nreturn 0;\r\nch = tty->driver_data;\r\nif (ch == NULL)\r\nreturn 0;\r\nreturn MoxaPortTxFree(ch);\r\n}\r\nstatic void moxa_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nif (ch == NULL)\r\nreturn;\r\nMoxaPortFlushData(ch, 1);\r\ntty_wakeup(tty);\r\n}\r\nstatic int moxa_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nint chars;\r\nchars = MoxaPortTxQueue(ch);\r\nif (chars)\r\nset_bit(EMPTYWAIT, &ch->statusflags);\r\nreturn chars;\r\n}\r\nstatic int moxa_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nint flag = 0, dtr, rts;\r\nMoxaPortGetLineOut(ch, &dtr, &rts);\r\nif (dtr)\r\nflag |= TIOCM_DTR;\r\nif (rts)\r\nflag |= TIOCM_RTS;\r\ndtr = MoxaPortLineStatus(ch);\r\nif (dtr & 1)\r\nflag |= TIOCM_CTS;\r\nif (dtr & 2)\r\nflag |= TIOCM_DSR;\r\nif (dtr & 4)\r\nflag |= TIOCM_CD;\r\nreturn flag;\r\n}\r\nstatic int moxa_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct moxa_port *ch;\r\nint dtr, rts;\r\nmutex_lock(&moxa_openlock);\r\nch = tty->driver_data;\r\nif (!ch) {\r\nmutex_unlock(&moxa_openlock);\r\nreturn -EINVAL;\r\n}\r\nMoxaPortGetLineOut(ch, &dtr, &rts);\r\nif (set & TIOCM_RTS)\r\nrts = 1;\r\nif (set & TIOCM_DTR)\r\ndtr = 1;\r\nif (clear & TIOCM_RTS)\r\nrts = 0;\r\nif (clear & TIOCM_DTR)\r\ndtr = 0;\r\nMoxaPortLineCtrl(ch, dtr, rts);\r\nmutex_unlock(&moxa_openlock);\r\nreturn 0;\r\n}\r\nstatic void moxa_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nif (ch == NULL)\r\nreturn;\r\nmoxa_set_tty_param(tty, old_termios);\r\nif (!(old_termios->c_cflag & CLOCAL) && C_CLOCAL(tty))\r\nwake_up_interruptible(&ch->port.open_wait);\r\n}\r\nstatic void moxa_stop(struct tty_struct *tty)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nif (ch == NULL)\r\nreturn;\r\nMoxaPortTxDisable(ch);\r\nset_bit(TXSTOPPED, &ch->statusflags);\r\n}\r\nstatic void moxa_start(struct tty_struct *tty)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\nif (ch == NULL)\r\nreturn;\r\nif (!test_bit(TXSTOPPED, &ch->statusflags))\r\nreturn;\r\nMoxaPortTxEnable(ch);\r\nclear_bit(TXSTOPPED, &ch->statusflags);\r\n}\r\nstatic void moxa_hangup(struct tty_struct *tty)\r\n{\r\nstruct moxa_port *ch = tty->driver_data;\r\ntty_port_hangup(&ch->port);\r\n}\r\nstatic void moxa_new_dcdstate(struct moxa_port *p, u8 dcd)\r\n{\r\nunsigned long flags;\r\ndcd = !!dcd;\r\nspin_lock_irqsave(&p->port.lock, flags);\r\nif (dcd != p->DCDState) {\r\np->DCDState = dcd;\r\nspin_unlock_irqrestore(&p->port.lock, flags);\r\nif (!dcd)\r\ntty_port_tty_hangup(&p->port, true);\r\n}\r\nelse\r\nspin_unlock_irqrestore(&p->port.lock, flags);\r\n}\r\nstatic int moxa_poll_port(struct moxa_port *p, unsigned int handle,\r\nu16 __iomem *ip)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&p->port);\r\nvoid __iomem *ofsAddr;\r\nunsigned int inited = tty_port_initialized(&p->port);\r\nu16 intr;\r\nif (tty) {\r\nif (test_bit(EMPTYWAIT, &p->statusflags) &&\r\nMoxaPortTxQueue(p) == 0) {\r\nclear_bit(EMPTYWAIT, &p->statusflags);\r\ntty_wakeup(tty);\r\n}\r\nif (test_bit(LOWWAIT, &p->statusflags) && !tty->stopped &&\r\nMoxaPortTxQueue(p) <= WAKEUP_CHARS) {\r\nclear_bit(LOWWAIT, &p->statusflags);\r\ntty_wakeup(tty);\r\n}\r\nif (inited && !tty_throttled(tty) &&\r\nMoxaPortRxQueue(p) > 0) {\r\nMoxaPortReadData(p);\r\ntty_schedule_flip(&p->port);\r\n}\r\n} else {\r\nclear_bit(EMPTYWAIT, &p->statusflags);\r\nMoxaPortFlushData(p, 0);\r\n}\r\nif (!handle)\r\ngoto put;\r\nintr = readw(ip);\r\nif (intr == 0)\r\ngoto put;\r\nwritew(0, ip);\r\nofsAddr = p->tableAddr;\r\nif (intr & IntrTx)\r\nwritew(readw(ofsAddr + HostStat) & ~WakeupTx,\r\nofsAddr + HostStat);\r\nif (!inited)\r\ngoto put;\r\nif (tty && (intr & IntrBreak) && !I_IGNBRK(tty)) {\r\ntty_insert_flip_char(&p->port, 0, TTY_BREAK);\r\ntty_schedule_flip(&p->port);\r\n}\r\nif (intr & IntrLine)\r\nmoxa_new_dcdstate(p, readb(ofsAddr + FlagStat) & DCD_state);\r\nput:\r\ntty_kref_put(tty);\r\nreturn 0;\r\n}\r\nstatic void moxa_poll(unsigned long ignored)\r\n{\r\nstruct moxa_board_conf *brd;\r\nu16 __iomem *ip;\r\nunsigned int card, port, served = 0;\r\nspin_lock(&moxa_lock);\r\nfor (card = 0; card < MAX_BOARDS; card++) {\r\nbrd = &moxa_boards[card];\r\nif (!brd->ready)\r\ncontinue;\r\nserved++;\r\nip = NULL;\r\nif (readb(brd->intPend) == 0xff)\r\nip = brd->intTable + readb(brd->intNdx);\r\nfor (port = 0; port < brd->numPorts; port++)\r\nmoxa_poll_port(&brd->ports[port], !!ip, ip + port);\r\nif (ip)\r\nwriteb(0, brd->intPend);\r\nif (moxaLowWaterChk) {\r\nstruct moxa_port *p = brd->ports;\r\nfor (port = 0; port < brd->numPorts; port++, p++)\r\nif (p->lowChkFlag) {\r\np->lowChkFlag = 0;\r\nmoxa_low_water_check(p->tableAddr);\r\n}\r\n}\r\n}\r\nmoxaLowWaterChk = 0;\r\nif (served)\r\nmod_timer(&moxaTimer, jiffies + HZ / 50);\r\nspin_unlock(&moxa_lock);\r\n}\r\nstatic void moxa_set_tty_param(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nregister struct ktermios *ts = &tty->termios;\r\nstruct moxa_port *ch = tty->driver_data;\r\nint rts, cts, txflow, rxflow, xany, baud;\r\nrts = cts = txflow = rxflow = xany = 0;\r\nif (ts->c_cflag & CRTSCTS)\r\nrts = cts = 1;\r\nif (ts->c_iflag & IXON)\r\ntxflow = 1;\r\nif (ts->c_iflag & IXOFF)\r\nrxflow = 1;\r\nif (ts->c_iflag & IXANY)\r\nxany = 1;\r\nts->c_cflag &= ~CMSPAR;\r\nMoxaPortFlowCtrl(ch, rts, cts, txflow, rxflow, xany);\r\nbaud = MoxaPortSetTermio(ch, ts, tty_get_baud_rate(tty));\r\nif (baud == -1)\r\nbaud = tty_termios_baud_rate(old_termios);\r\ntty_encode_baud_rate(tty, baud, baud);\r\n}\r\nstatic void MoxaPortFlushData(struct moxa_port *port, int mode)\r\n{\r\nvoid __iomem *ofsAddr;\r\nif (mode < 0 || mode > 2)\r\nreturn;\r\nofsAddr = port->tableAddr;\r\nmoxafunc(ofsAddr, FC_FlushQueue, mode);\r\nif (mode != 1) {\r\nport->lowChkFlag = 0;\r\nmoxa_low_water_check(ofsAddr);\r\n}\r\n}\r\nstatic void MoxaPortEnable(struct moxa_port *port)\r\n{\r\nvoid __iomem *ofsAddr;\r\nu16 lowwater = 512;\r\nofsAddr = port->tableAddr;\r\nwritew(lowwater, ofsAddr + Low_water);\r\nif (MOXA_IS_320(port->board))\r\nmoxafunc(ofsAddr, FC_SetBreakIrq, 0);\r\nelse\r\nwritew(readw(ofsAddr + HostStat) | WakeupBreak,\r\nofsAddr + HostStat);\r\nmoxafunc(ofsAddr, FC_SetLineIrq, Magic_code);\r\nmoxafunc(ofsAddr, FC_FlushQueue, 2);\r\nmoxafunc(ofsAddr, FC_EnableCH, Magic_code);\r\nMoxaPortLineStatus(port);\r\n}\r\nstatic void MoxaPortDisable(struct moxa_port *port)\r\n{\r\nvoid __iomem *ofsAddr = port->tableAddr;\r\nmoxafunc(ofsAddr, FC_SetFlowCtl, 0);\r\nmoxafunc(ofsAddr, FC_ClrLineIrq, Magic_code);\r\nwritew(0, ofsAddr + HostStat);\r\nmoxafunc(ofsAddr, FC_DisableCH, Magic_code);\r\n}\r\nstatic speed_t MoxaPortSetBaud(struct moxa_port *port, speed_t baud)\r\n{\r\nvoid __iomem *ofsAddr = port->tableAddr;\r\nunsigned int clock, val;\r\nspeed_t max;\r\nmax = MOXA_IS_320(port->board) ? 460800 : 921600;\r\nif (baud < 50)\r\nreturn 0;\r\nif (baud > max)\r\nbaud = max;\r\nclock = 921600;\r\nval = clock / baud;\r\nmoxafunc(ofsAddr, FC_SetBaud, val);\r\nbaud = clock / val;\r\nreturn baud;\r\n}\r\nstatic int MoxaPortSetTermio(struct moxa_port *port, struct ktermios *termio,\r\nspeed_t baud)\r\n{\r\nvoid __iomem *ofsAddr;\r\ntcflag_t mode = 0;\r\nofsAddr = port->tableAddr;\r\nmode = termio->c_cflag & CSIZE;\r\nif (mode == CS5)\r\nmode = MX_CS5;\r\nelse if (mode == CS6)\r\nmode = MX_CS6;\r\nelse if (mode == CS7)\r\nmode = MX_CS7;\r\nelse if (mode == CS8)\r\nmode = MX_CS8;\r\nif (termio->c_cflag & CSTOPB) {\r\nif (mode == MX_CS5)\r\nmode |= MX_STOP15;\r\nelse\r\nmode |= MX_STOP2;\r\n} else\r\nmode |= MX_STOP1;\r\nif (termio->c_cflag & PARENB) {\r\nif (termio->c_cflag & PARODD)\r\nmode |= MX_PARODD;\r\nelse\r\nmode |= MX_PAREVEN;\r\n} else\r\nmode |= MX_PARNONE;\r\nmoxafunc(ofsAddr, FC_SetDataMode, (u16)mode);\r\nif (MOXA_IS_320(port->board) && baud >= 921600)\r\nreturn -1;\r\nbaud = MoxaPortSetBaud(port, baud);\r\nif (termio->c_iflag & (IXON | IXOFF | IXANY)) {\r\nspin_lock_irq(&moxafunc_lock);\r\nwriteb(termio->c_cc[VSTART], ofsAddr + FuncArg);\r\nwriteb(termio->c_cc[VSTOP], ofsAddr + FuncArg1);\r\nwriteb(FC_SetXonXoff, ofsAddr + FuncCode);\r\nmoxa_wait_finish(ofsAddr);\r\nspin_unlock_irq(&moxafunc_lock);\r\n}\r\nreturn baud;\r\n}\r\nstatic int MoxaPortGetLineOut(struct moxa_port *port, int *dtrState,\r\nint *rtsState)\r\n{\r\nif (dtrState)\r\n*dtrState = !!(port->lineCtrl & DTR_ON);\r\nif (rtsState)\r\n*rtsState = !!(port->lineCtrl & RTS_ON);\r\nreturn 0;\r\n}\r\nstatic void MoxaPortLineCtrl(struct moxa_port *port, int dtr, int rts)\r\n{\r\nu8 mode = 0;\r\nif (dtr)\r\nmode |= DTR_ON;\r\nif (rts)\r\nmode |= RTS_ON;\r\nport->lineCtrl = mode;\r\nmoxafunc(port->tableAddr, FC_LineControl, mode);\r\n}\r\nstatic void MoxaPortFlowCtrl(struct moxa_port *port, int rts, int cts,\r\nint txflow, int rxflow, int txany)\r\n{\r\nint mode = 0;\r\nif (rts)\r\nmode |= RTS_FlowCtl;\r\nif (cts)\r\nmode |= CTS_FlowCtl;\r\nif (txflow)\r\nmode |= Tx_FlowCtl;\r\nif (rxflow)\r\nmode |= Rx_FlowCtl;\r\nif (txany)\r\nmode |= IXM_IXANY;\r\nmoxafunc(port->tableAddr, FC_SetFlowCtl, mode);\r\n}\r\nstatic int MoxaPortLineStatus(struct moxa_port *port)\r\n{\r\nvoid __iomem *ofsAddr;\r\nint val;\r\nofsAddr = port->tableAddr;\r\nif (MOXA_IS_320(port->board))\r\nval = moxafuncret(ofsAddr, FC_LineStatus, 0);\r\nelse\r\nval = readw(ofsAddr + FlagStat) >> 4;\r\nval &= 0x0B;\r\nif (val & 8)\r\nval |= 4;\r\nmoxa_new_dcdstate(port, val & 8);\r\nval &= 7;\r\nreturn val;\r\n}\r\nstatic int MoxaPortWriteData(struct tty_struct *tty,\r\nconst unsigned char *buffer, int len)\r\n{\r\nstruct moxa_port *port = tty->driver_data;\r\nvoid __iomem *baseAddr, *ofsAddr, *ofs;\r\nunsigned int c, total;\r\nu16 head, tail, tx_mask, spage, epage;\r\nu16 pageno, pageofs, bufhead;\r\nofsAddr = port->tableAddr;\r\nbaseAddr = port->board->basemem;\r\ntx_mask = readw(ofsAddr + TX_mask);\r\nspage = readw(ofsAddr + Page_txb);\r\nepage = readw(ofsAddr + EndPage_txb);\r\ntail = readw(ofsAddr + TXwptr);\r\nhead = readw(ofsAddr + TXrptr);\r\nc = (head > tail) ? (head - tail - 1) : (head - tail + tx_mask);\r\nif (c > len)\r\nc = len;\r\nmoxaLog.txcnt[port->port.tty->index] += c;\r\ntotal = c;\r\nif (spage == epage) {\r\nbufhead = readw(ofsAddr + Ofs_txb);\r\nwritew(spage, baseAddr + Control_reg);\r\nwhile (c > 0) {\r\nif (head > tail)\r\nlen = head - tail - 1;\r\nelse\r\nlen = tx_mask + 1 - tail;\r\nlen = (c > len) ? len : c;\r\nofs = baseAddr + DynPage_addr + bufhead + tail;\r\nmemcpy_toio(ofs, buffer, len);\r\nbuffer += len;\r\ntail = (tail + len) & tx_mask;\r\nc -= len;\r\n}\r\n} else {\r\npageno = spage + (tail >> 13);\r\npageofs = tail & Page_mask;\r\nwhile (c > 0) {\r\nlen = Page_size - pageofs;\r\nif (len > c)\r\nlen = c;\r\nwriteb(pageno, baseAddr + Control_reg);\r\nofs = baseAddr + DynPage_addr + pageofs;\r\nmemcpy_toio(ofs, buffer, len);\r\nbuffer += len;\r\nif (++pageno == epage)\r\npageno = spage;\r\npageofs = 0;\r\nc -= len;\r\n}\r\ntail = (tail + total) & tx_mask;\r\n}\r\nwritew(tail, ofsAddr + TXwptr);\r\nwriteb(1, ofsAddr + CD180TXirq);\r\nreturn total;\r\n}\r\nstatic int MoxaPortReadData(struct moxa_port *port)\r\n{\r\nstruct tty_struct *tty = port->port.tty;\r\nunsigned char *dst;\r\nvoid __iomem *baseAddr, *ofsAddr, *ofs;\r\nunsigned int count, len, total;\r\nu16 tail, rx_mask, spage, epage;\r\nu16 pageno, pageofs, bufhead, head;\r\nofsAddr = port->tableAddr;\r\nbaseAddr = port->board->basemem;\r\nhead = readw(ofsAddr + RXrptr);\r\ntail = readw(ofsAddr + RXwptr);\r\nrx_mask = readw(ofsAddr + RX_mask);\r\nspage = readw(ofsAddr + Page_rxb);\r\nepage = readw(ofsAddr + EndPage_rxb);\r\ncount = (tail >= head) ? (tail - head) : (tail - head + rx_mask + 1);\r\nif (count == 0)\r\nreturn 0;\r\ntotal = count;\r\nmoxaLog.rxcnt[tty->index] += total;\r\nif (spage == epage) {\r\nbufhead = readw(ofsAddr + Ofs_rxb);\r\nwritew(spage, baseAddr + Control_reg);\r\nwhile (count > 0) {\r\nofs = baseAddr + DynPage_addr + bufhead + head;\r\nlen = (tail >= head) ? (tail - head) :\r\n(rx_mask + 1 - head);\r\nlen = tty_prepare_flip_string(&port->port, &dst,\r\nmin(len, count));\r\nmemcpy_fromio(dst, ofs, len);\r\nhead = (head + len) & rx_mask;\r\ncount -= len;\r\n}\r\n} else {\r\npageno = spage + (head >> 13);\r\npageofs = head & Page_mask;\r\nwhile (count > 0) {\r\nwritew(pageno, baseAddr + Control_reg);\r\nofs = baseAddr + DynPage_addr + pageofs;\r\nlen = tty_prepare_flip_string(&port->port, &dst,\r\nmin(Page_size - pageofs, count));\r\nmemcpy_fromio(dst, ofs, len);\r\ncount -= len;\r\npageofs = (pageofs + len) & Page_mask;\r\nif (pageofs == 0 && ++pageno == epage)\r\npageno = spage;\r\n}\r\nhead = (head + total) & rx_mask;\r\n}\r\nwritew(head, ofsAddr + RXrptr);\r\nif (readb(ofsAddr + FlagStat) & Xoff_state) {\r\nmoxaLowWaterChk = 1;\r\nport->lowChkFlag = 1;\r\n}\r\nreturn total;\r\n}\r\nstatic int MoxaPortTxQueue(struct moxa_port *port)\r\n{\r\nvoid __iomem *ofsAddr = port->tableAddr;\r\nu16 rptr, wptr, mask;\r\nrptr = readw(ofsAddr + TXrptr);\r\nwptr = readw(ofsAddr + TXwptr);\r\nmask = readw(ofsAddr + TX_mask);\r\nreturn (wptr - rptr) & mask;\r\n}\r\nstatic int MoxaPortTxFree(struct moxa_port *port)\r\n{\r\nvoid __iomem *ofsAddr = port->tableAddr;\r\nu16 rptr, wptr, mask;\r\nrptr = readw(ofsAddr + TXrptr);\r\nwptr = readw(ofsAddr + TXwptr);\r\nmask = readw(ofsAddr + TX_mask);\r\nreturn mask - ((wptr - rptr) & mask);\r\n}\r\nstatic int MoxaPortRxQueue(struct moxa_port *port)\r\n{\r\nvoid __iomem *ofsAddr = port->tableAddr;\r\nu16 rptr, wptr, mask;\r\nrptr = readw(ofsAddr + RXrptr);\r\nwptr = readw(ofsAddr + RXwptr);\r\nmask = readw(ofsAddr + RX_mask);\r\nreturn (wptr - rptr) & mask;\r\n}\r\nstatic void MoxaPortTxDisable(struct moxa_port *port)\r\n{\r\nmoxafunc(port->tableAddr, FC_SetXoffState, Magic_code);\r\n}\r\nstatic void MoxaPortTxEnable(struct moxa_port *port)\r\n{\r\nmoxafunc(port->tableAddr, FC_SetXonState, Magic_code);\r\n}\r\nstatic int moxa_get_serial_info(struct moxa_port *info,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp = {\r\n.type = info->type,\r\n.line = info->port.tty->index,\r\n.flags = info->port.flags,\r\n.baud_base = 921600,\r\n.close_delay = info->port.close_delay\r\n};\r\nreturn copy_to_user(retinfo, &tmp, sizeof(*retinfo)) ? -EFAULT : 0;\r\n}\r\nstatic int moxa_set_serial_info(struct moxa_port *info,\r\nstruct serial_struct __user *new_info)\r\n{\r\nstruct serial_struct new_serial;\r\nif (copy_from_user(&new_serial, new_info, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nif (new_serial.irq != 0 || new_serial.port != 0 ||\r\nnew_serial.custom_divisor != 0 ||\r\nnew_serial.baud_base != 921600)\r\nreturn -EPERM;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif (((new_serial.flags & ~ASYNC_USR_MASK) !=\r\n(info->port.flags & ~ASYNC_USR_MASK)))\r\nreturn -EPERM;\r\n} else\r\ninfo->port.close_delay = new_serial.close_delay * HZ / 100;\r\nnew_serial.flags = (new_serial.flags & ~ASYNC_FLAGS);\r\nnew_serial.flags |= (info->port.flags & ASYNC_FLAGS);\r\nMoxaSetFifo(info, new_serial.type == PORT_16550A);\r\ninfo->type = new_serial.type;\r\nreturn 0;\r\n}\r\nstatic void MoxaSetFifo(struct moxa_port *port, int enable)\r\n{\r\nvoid __iomem *ofsAddr = port->tableAddr;\r\nif (!enable) {\r\nmoxafunc(ofsAddr, FC_SetRxFIFOTrig, 0);\r\nmoxafunc(ofsAddr, FC_SetTxFIFOCnt, 1);\r\n} else {\r\nmoxafunc(ofsAddr, FC_SetRxFIFOTrig, 3);\r\nmoxafunc(ofsAddr, FC_SetTxFIFOCnt, 16);\r\n}\r\n}
