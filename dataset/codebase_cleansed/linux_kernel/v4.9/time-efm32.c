static int efm32_clock_event_shutdown(struct clock_event_device *evtdev)\r\n{\r\nstruct efm32_clock_event_ddata *ddata =\r\ncontainer_of(evtdev, struct efm32_clock_event_ddata, evtdev);\r\nwritel_relaxed(TIMERn_CMD_STOP, ddata->base + TIMERn_CMD);\r\nreturn 0;\r\n}\r\nstatic int efm32_clock_event_set_oneshot(struct clock_event_device *evtdev)\r\n{\r\nstruct efm32_clock_event_ddata *ddata =\r\ncontainer_of(evtdev, struct efm32_clock_event_ddata, evtdev);\r\nwritel_relaxed(TIMERn_CMD_STOP, ddata->base + TIMERn_CMD);\r\nwritel_relaxed(TIMERn_CTRL_PRESC_1024 |\r\nTIMERn_CTRL_CLKSEL_PRESCHFPERCLK |\r\nTIMERn_CTRL_OSMEN |\r\nTIMERn_CTRL_MODE_DOWN,\r\nddata->base + TIMERn_CTRL);\r\nreturn 0;\r\n}\r\nstatic int efm32_clock_event_set_periodic(struct clock_event_device *evtdev)\r\n{\r\nstruct efm32_clock_event_ddata *ddata =\r\ncontainer_of(evtdev, struct efm32_clock_event_ddata, evtdev);\r\nwritel_relaxed(TIMERn_CMD_STOP, ddata->base + TIMERn_CMD);\r\nwritel_relaxed(ddata->periodic_top, ddata->base + TIMERn_TOP);\r\nwritel_relaxed(TIMERn_CTRL_PRESC_1024 |\r\nTIMERn_CTRL_CLKSEL_PRESCHFPERCLK |\r\nTIMERn_CTRL_MODE_DOWN,\r\nddata->base + TIMERn_CTRL);\r\nwritel_relaxed(TIMERn_CMD_START, ddata->base + TIMERn_CMD);\r\nreturn 0;\r\n}\r\nstatic int efm32_clock_event_set_next_event(unsigned long evt,\r\nstruct clock_event_device *evtdev)\r\n{\r\nstruct efm32_clock_event_ddata *ddata =\r\ncontainer_of(evtdev, struct efm32_clock_event_ddata, evtdev);\r\nwritel_relaxed(TIMERn_CMD_STOP, ddata->base + TIMERn_CMD);\r\nwritel_relaxed(evt, ddata->base + TIMERn_CNT);\r\nwritel_relaxed(TIMERn_CMD_START, ddata->base + TIMERn_CMD);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t efm32_clock_event_handler(int irq, void *dev_id)\r\n{\r\nstruct efm32_clock_event_ddata *ddata = dev_id;\r\nwritel_relaxed(TIMERn_IRQ_UF, ddata->base + TIMERn_IFC);\r\nddata->evtdev.event_handler(&ddata->evtdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init efm32_clocksource_init(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nunsigned long rate;\r\nint ret;\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\npr_err("failed to get clock for clocksource (%d)\n", ret);\r\ngoto err_clk_get;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("failed to enable timer clock for clocksource (%d)\n",\r\nret);\r\ngoto err_clk_enable;\r\n}\r\nrate = clk_get_rate(clk);\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\nret = -EADDRNOTAVAIL;\r\npr_err("failed to map registers for clocksource\n");\r\ngoto err_iomap;\r\n}\r\nwritel_relaxed(TIMERn_CTRL_PRESC_1024 |\r\nTIMERn_CTRL_CLKSEL_PRESCHFPERCLK |\r\nTIMERn_CTRL_MODE_UP, base + TIMERn_CTRL);\r\nwritel_relaxed(TIMERn_CMD_START, base + TIMERn_CMD);\r\nret = clocksource_mmio_init(base + TIMERn_CNT, "efm32 timer",\r\nDIV_ROUND_CLOSEST(rate, 1024), 200, 16,\r\nclocksource_mmio_readl_up);\r\nif (ret) {\r\npr_err("failed to init clocksource (%d)\n", ret);\r\ngoto err_clocksource_init;\r\n}\r\nreturn 0;\r\nerr_clocksource_init:\r\niounmap(base);\r\nerr_iomap:\r\nclk_disable_unprepare(clk);\r\nerr_clk_enable:\r\nclk_put(clk);\r\nerr_clk_get:\r\nreturn ret;\r\n}\r\nstatic int __init efm32_clockevent_init(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nunsigned long rate;\r\nint irq;\r\nint ret;\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\npr_err("failed to get clock for clockevent (%d)\n", ret);\r\ngoto err_clk_get;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("failed to enable timer clock for clockevent (%d)\n",\r\nret);\r\ngoto err_clk_enable;\r\n}\r\nrate = clk_get_rate(clk);\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\nret = -EADDRNOTAVAIL;\r\npr_err("failed to map registers for clockevent\n");\r\ngoto err_iomap;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\nret = -ENOENT;\r\npr_err("failed to get irq for clockevent\n");\r\ngoto err_get_irq;\r\n}\r\nwritel_relaxed(TIMERn_IRQ_UF, base + TIMERn_IEN);\r\nclock_event_ddata.base = base;\r\nclock_event_ddata.periodic_top = DIV_ROUND_CLOSEST(rate, 1024 * HZ);\r\nclockevents_config_and_register(&clock_event_ddata.evtdev,\r\nDIV_ROUND_CLOSEST(rate, 1024),\r\n0xf, 0xffff);\r\nret = setup_irq(irq, &efm32_clock_event_irq);\r\nif (ret) {\r\npr_err("Failed setup irq");\r\ngoto err_setup_irq;\r\n}\r\nreturn 0;\r\nerr_setup_irq:\r\nerr_get_irq:\r\niounmap(base);\r\nerr_iomap:\r\nclk_disable_unprepare(clk);\r\nerr_clk_enable:\r\nclk_put(clk);\r\nerr_clk_get:\r\nreturn ret;\r\n}\r\nstatic int __init efm32_timer_init(struct device_node *np)\r\n{\r\nstatic int has_clocksource, has_clockevent;\r\nint ret = 0;\r\nif (!has_clocksource) {\r\nret = efm32_clocksource_init(np);\r\nif (!ret) {\r\nhas_clocksource = 1;\r\nreturn 0;\r\n}\r\n}\r\nif (!has_clockevent) {\r\nret = efm32_clockevent_init(np);\r\nif (!ret) {\r\nhas_clockevent = 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn ret;\r\n}
