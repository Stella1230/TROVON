static int cx24116_writereg(struct cx24116_state *state, int reg, int data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address,\r\n.flags = 0, .buf = buf, .len = 2 };\r\nint err;\r\nif (debug > 1)\r\nprintk("cx24116: %s: write reg 0x%02x, value 0x%02x\n",\r\n__func__, reg, data);\r\nerr = i2c_transfer(state->i2c, &msg, 1);\r\nif (err != 1) {\r\nprintk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x,"\r\n" value == 0x%02x)\n", __func__, err, reg, data);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24116_writeregN(struct cx24116_state *state, int reg,\r\nconst u8 *data, u16 len)\r\n{\r\nint ret = -EREMOTEIO;\r\nstruct i2c_msg msg;\r\nu8 *buf;\r\nbuf = kmalloc(len + 1, GFP_KERNEL);\r\nif (buf == NULL) {\r\nprintk("Unable to kmalloc\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\n*(buf) = reg;\r\nmemcpy(buf + 1, data, len);\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.buf = buf;\r\nmsg.len = len + 1;\r\nif (debug > 1)\r\nprintk(KERN_INFO "cx24116: %s: write regN 0x%02x, len = %d\n",\r\n__func__, reg, len);\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1) {\r\nprintk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x\n",\r\n__func__, ret, reg);\r\nret = -EREMOTEIO;\r\n}\r\nerror:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int cx24116_readreg(struct cx24116_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config->demod_address, .flags = 0,\r\n.buf = b0, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD,\r\n.buf = b1, .len = 1 }\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\nprintk(KERN_ERR "%s: reg=0x%x (error=%d)\n",\r\n__func__, reg, ret);\r\nreturn ret;\r\n}\r\nif (debug > 1)\r\nprintk(KERN_INFO "cx24116: read reg 0x%02x, value 0x%02x\n",\r\nreg, b1[0]);\r\nreturn b1[0];\r\n}\r\nstatic int cx24116_set_inversion(struct cx24116_state *state,\r\nenum fe_spectral_inversion inversion)\r\n{\r\ndprintk("%s(%d)\n", __func__, inversion);\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\nstate->dnxt.inversion_val = 0x00;\r\nbreak;\r\ncase INVERSION_ON:\r\nstate->dnxt.inversion_val = 0x04;\r\nbreak;\r\ncase INVERSION_AUTO:\r\nstate->dnxt.inversion_val = 0x0C;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->dnxt.inversion = inversion;\r\nreturn 0;\r\n}\r\nstatic int cx24116_lookup_fecmod(struct cx24116_state *state,\r\nenum fe_delivery_system d, enum fe_modulation m, enum fe_code_rate f)\r\n{\r\nint i, ret = -EOPNOTSUPP;\r\ndprintk("%s(0x%02x,0x%02x)\n", __func__, m, f);\r\nfor (i = 0; i < ARRAY_SIZE(CX24116_MODFEC_MODES); i++) {\r\nif ((d == CX24116_MODFEC_MODES[i].delivery_system) &&\r\n(m == CX24116_MODFEC_MODES[i].modulation) &&\r\n(f == CX24116_MODFEC_MODES[i].fec)) {\r\nret = i;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int cx24116_set_fec(struct cx24116_state *state,\r\nenum fe_delivery_system delsys,\r\nenum fe_modulation mod,\r\nenum fe_code_rate fec)\r\n{\r\nint ret = 0;\r\ndprintk("%s(0x%02x,0x%02x)\n", __func__, mod, fec);\r\nret = cx24116_lookup_fecmod(state, delsys, mod, fec);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->dnxt.fec = fec;\r\nstate->dnxt.fec_val = CX24116_MODFEC_MODES[ret].val;\r\nstate->dnxt.fec_mask = CX24116_MODFEC_MODES[ret].mask;\r\ndprintk("%s() mask/val = 0x%02x/0x%02x\n", __func__,\r\nstate->dnxt.fec_mask, state->dnxt.fec_val);\r\nreturn 0;\r\n}\r\nstatic int cx24116_set_symbolrate(struct cx24116_state *state, u32 rate)\r\n{\r\ndprintk("%s(%d)\n", __func__, rate);\r\nif ((rate > state->frontend.ops.info.symbol_rate_max) ||\r\n(rate < state->frontend.ops.info.symbol_rate_min)) {\r\ndprintk("%s() unsupported symbol_rate = %d\n", __func__, rate);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstate->dnxt.symbol_rate = rate;\r\ndprintk("%s() symbol_rate = %d\n", __func__, rate);\r\nreturn 0;\r\n}\r\nstatic int cx24116_firmware_ondemand(struct dvb_frontend *fe)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nconst struct firmware *fw;\r\nint ret = 0;\r\ndprintk("%s()\n", __func__);\r\nif (cx24116_readreg(state, 0x20) > 0) {\r\nif (state->skip_fw_load)\r\nreturn 0;\r\nprintk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n",\r\n__func__, CX24116_DEFAULT_FIRMWARE);\r\nret = request_firmware(&fw, CX24116_DEFAULT_FIRMWARE,\r\nstate->i2c->dev.parent);\r\nprintk(KERN_INFO "%s: Waiting for firmware upload(2)...\n",\r\n__func__);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: No firmware uploaded "\r\n"(timeout or file not found?)\n", __func__);\r\nreturn ret;\r\n}\r\nstate->skip_fw_load = 1;\r\nret = cx24116_load_firmware(fe, fw);\r\nif (ret)\r\nprintk(KERN_ERR "%s: Writing firmware to device failed\n",\r\n__func__);\r\nrelease_firmware(fw);\r\nprintk(KERN_INFO "%s: Firmware upload %s\n", __func__,\r\nret == 0 ? "complete" : "failed");\r\nstate->skip_fw_load = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cx24116_cmd_execute(struct dvb_frontend *fe, struct cx24116_cmd *cmd)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nint i, ret;\r\ndprintk("%s()\n", __func__);\r\nret = cx24116_firmware_ondemand(fe);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "%s(): Unable initialise the firmware\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < cmd->len ; i++) {\r\ndprintk("%s: 0x%02x == 0x%02x\n", __func__, i, cmd->args[i]);\r\ncx24116_writereg(state, i, cmd->args[i]);\r\n}\r\ncx24116_writereg(state, CX24116_REG_EXECUTE, 0x01);\r\nwhile (cx24116_readreg(state, CX24116_REG_EXECUTE)) {\r\nmsleep(10);\r\nif (i++ > 64) {\r\nprintk(KERN_WARNING "%s() Firmware not responding\n",\r\n__func__);\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24116_load_firmware(struct dvb_frontend *fe,\r\nconst struct firmware *fw)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nstruct cx24116_cmd cmd;\r\nint i, ret, len, max, remaining;\r\nunsigned char vers[4];\r\ndprintk("%s\n", __func__);\r\ndprintk("Firmware is %zu bytes (%02x %02x .. %02x %02x)\n",\r\nfw->size,\r\nfw->data[0],\r\nfw->data[1],\r\nfw->data[fw->size-2],\r\nfw->data[fw->size-1]);\r\nif (state->config->reset_device)\r\nstate->config->reset_device(fe);\r\ncx24116_writereg(state, 0xE5, 0x00);\r\ncx24116_writereg(state, 0xF1, 0x08);\r\ncx24116_writereg(state, 0xF2, 0x13);\r\ncx24116_writereg(state, 0xe0, 0x03);\r\ncx24116_writereg(state, 0xe0, 0x00);\r\ncx24116_writereg(state, CX24116_REG_CLKDIV, 0x46);\r\ncx24116_writereg(state, CX24116_REG_RATEDIV, 0x00);\r\ncx24116_writereg(state, 0xF0, 0x03);\r\ncx24116_writereg(state, 0xF4, 0x81);\r\ncx24116_writereg(state, 0xF5, 0x00);\r\ncx24116_writereg(state, 0xF6, 0x00);\r\nif (state->config->i2c_wr_max)\r\nmax = state->config->i2c_wr_max;\r\nelse\r\nmax = INT_MAX;\r\nfor (remaining = fw->size; remaining > 0; remaining -= max - 1) {\r\nlen = remaining;\r\nif (len > max - 1)\r\nlen = max - 1;\r\ncx24116_writeregN(state, 0xF7, &fw->data[fw->size - remaining],\r\nlen);\r\n}\r\ncx24116_writereg(state, 0xF4, 0x10);\r\ncx24116_writereg(state, 0xF0, 0x00);\r\ncx24116_writereg(state, 0xF8, 0x06);\r\ncmd.args[0x00] = CMD_SET_VCO;\r\ncmd.args[0x01] = 0x05;\r\ncmd.args[0x02] = 0xdc;\r\ncmd.args[0x03] = 0xda;\r\ncmd.args[0x04] = 0xae;\r\ncmd.args[0x05] = 0xaa;\r\ncmd.args[0x06] = 0x04;\r\ncmd.args[0x07] = 0x9d;\r\ncmd.args[0x08] = 0xfc;\r\ncmd.args[0x09] = 0x06;\r\ncmd.len = 0x0a;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\ncx24116_writereg(state, CX24116_REG_SSTATUS, 0x00);\r\ncmd.args[0x00] = CMD_TUNERINIT;\r\ncmd.args[0x01] = 0x00;\r\ncmd.args[0x02] = 0x00;\r\ncmd.len = 0x03;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\ncx24116_writereg(state, 0xe5, 0x00);\r\ncmd.args[0x00] = CMD_MPEGCONFIG;\r\ncmd.args[0x01] = 0x01;\r\ncmd.args[0x02] = 0x75;\r\ncmd.args[0x03] = 0x00;\r\nif (state->config->mpg_clk_pos_pol)\r\ncmd.args[0x04] = state->config->mpg_clk_pos_pol;\r\nelse\r\ncmd.args[0x04] = 0x02;\r\ncmd.args[0x05] = 0x00;\r\ncmd.len = 0x06;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\ncmd.args[0x00] = CMD_UPDFWVERS;\r\ncmd.len = 0x02;\r\nfor (i = 0; i < 4; i++) {\r\ncmd.args[0x01] = i;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nvers[i] = cx24116_readreg(state, CX24116_REG_MAILBOX);\r\n}\r\nprintk(KERN_INFO "%s: FW version %i.%i.%i.%i\n", __func__,\r\nvers[0], vers[1], vers[2], vers[3]);\r\nreturn 0;\r\n}\r\nstatic int cx24116_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nint lock = cx24116_readreg(state, CX24116_REG_SSTATUS) &\r\nCX24116_STATUS_MASK;\r\ndprintk("%s: status = 0x%02x\n", __func__, lock);\r\n*status = 0;\r\nif (lock & CX24116_HAS_SIGNAL)\r\n*status |= FE_HAS_SIGNAL;\r\nif (lock & CX24116_HAS_CARRIER)\r\n*status |= FE_HAS_CARRIER;\r\nif (lock & CX24116_HAS_VITERBI)\r\n*status |= FE_HAS_VITERBI;\r\nif (lock & CX24116_HAS_SYNCLOCK)\r\n*status |= FE_HAS_SYNC | FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int cx24116_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\n*ber = (cx24116_readreg(state, CX24116_REG_BER24) << 24) |\r\n(cx24116_readreg(state, CX24116_REG_BER16) << 16) |\r\n(cx24116_readreg(state, CX24116_REG_BER8) << 8) |\r\ncx24116_readreg(state, CX24116_REG_BER0);\r\nreturn 0;\r\n}\r\nstatic int cx24116_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nstruct cx24116_cmd cmd;\r\nint ret;\r\nu16 sig_reading;\r\ndprintk("%s()\n", __func__);\r\ncmd.args[0x00] = CMD_GETAGC;\r\ncmd.len = 0x01;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nsig_reading =\r\n(cx24116_readreg(state,\r\nCX24116_REG_SSTATUS) & CX24116_SIGNAL_MASK) |\r\n(cx24116_readreg(state, CX24116_REG_SIGNAL) << 6);\r\n*signal_strength = 0 - sig_reading;\r\ndprintk("%s: raw / cooked = 0x%04x / 0x%04x\n",\r\n__func__, sig_reading, *signal_strength);\r\nreturn 0;\r\n}\r\nstatic int cx24116_read_snr_pct(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nu8 snr_reading;\r\nstatic const u32 snr_tab[] = {\r\n0x00000, 0x0199A, 0x03333, 0x04ccD, 0x06667,\r\n0x08000, 0x0999A, 0x0b333, 0x0cccD, 0x0e667,\r\n0x10000, 0x1199A, 0x13333, 0x14ccD, 0x16667,\r\n0x18000 };\r\ndprintk("%s()\n", __func__);\r\nsnr_reading = cx24116_readreg(state, CX24116_REG_QUALITY0);\r\nif (snr_reading >= 0xa0 )\r\n*snr = 0xffff;\r\nelse\r\n*snr = snr_tab[(snr_reading & 0xf0) >> 4] +\r\n(snr_tab[(snr_reading & 0x0f)] >> 4);\r\ndprintk("%s: raw / cooked = 0x%02x / 0x%04x\n", __func__,\r\nsnr_reading, *snr);\r\nreturn 0;\r\n}\r\nstatic int cx24116_read_snr_esno(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\n*snr = cx24116_readreg(state, CX24116_REG_QUALITY8) << 8 |\r\ncx24116_readreg(state, CX24116_REG_QUALITY0);\r\ndprintk("%s: raw 0x%04x\n", __func__, *snr);\r\nreturn 0;\r\n}\r\nstatic int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nif (esno_snr == 1)\r\nreturn cx24116_read_snr_esno(fe, snr);\r\nelse\r\nreturn cx24116_read_snr_pct(fe, snr);\r\n}\r\nstatic int cx24116_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\ndprintk("%s()\n", __func__);\r\n*ucblocks = (cx24116_readreg(state, CX24116_REG_UCB8) << 8) |\r\ncx24116_readreg(state, CX24116_REG_UCB0);\r\nreturn 0;\r\n}\r\nstatic void cx24116_clone_params(struct dvb_frontend *fe)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nstate->dcur = state->dnxt;\r\n}\r\nstatic int cx24116_wait_for_lnb(struct dvb_frontend *fe)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nint i;\r\ndprintk("%s() qstatus = 0x%02x\n", __func__,\r\ncx24116_readreg(state, CX24116_REG_QSTATUS));\r\nfor (i = 0; i < 30 ; i++) {\r\nif (cx24116_readreg(state, CX24116_REG_QSTATUS) & 0x20)\r\nreturn 0;\r\nmsleep(10);\r\n}\r\ndprintk("%s(): LNB not ready\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int cx24116_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct cx24116_cmd cmd;\r\nint ret;\r\ndprintk("%s: %s\n", __func__,\r\nvoltage == SEC_VOLTAGE_13 ? "SEC_VOLTAGE_13" :\r\nvoltage == SEC_VOLTAGE_18 ? "SEC_VOLTAGE_18" : "??");\r\nret = cx24116_wait_for_lnb(fe);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep(100);\r\ncmd.args[0x00] = CMD_LNBDCLEVEL;\r\ncmd.args[0x01] = (voltage == SEC_VOLTAGE_18 ? 0x01 : 0x00);\r\ncmd.len = 0x02;\r\nmsleep(15);\r\nreturn cx24116_cmd_execute(fe, &cmd);\r\n}\r\nstatic int cx24116_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode tone)\r\n{\r\nstruct cx24116_cmd cmd;\r\nint ret;\r\ndprintk("%s(%d)\n", __func__, tone);\r\nif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\r\nprintk(KERN_ERR "%s: Invalid, tone=%d\n", __func__, tone);\r\nreturn -EINVAL;\r\n}\r\nret = cx24116_wait_for_lnb(fe);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep(15);\r\ncmd.args[0x00] = CMD_SET_TONE;\r\ncmd.args[0x01] = 0x00;\r\ncmd.args[0x02] = 0x00;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\ndprintk("%s: setting tone on\n", __func__);\r\ncmd.args[0x03] = 0x01;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\ndprintk("%s: setting tone off\n", __func__);\r\ncmd.args[0x03] = 0x00;\r\nbreak;\r\n}\r\ncmd.len = 0x04;\r\nmsleep(15);\r\nreturn cx24116_cmd_execute(fe, &cmd);\r\n}\r\nstatic int cx24116_diseqc_init(struct dvb_frontend *fe)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nstruct cx24116_cmd cmd;\r\nint ret;\r\ncmd.args[0x00] = CMD_LNBCONFIG;\r\ncmd.args[0x01] = 0x00;\r\ncmd.args[0x02] = 0x10;\r\ncmd.args[0x03] = 0x00;\r\ncmd.args[0x04] = 0x8f;\r\ncmd.args[0x05] = 0x28;\r\ncmd.args[0x06] = (toneburst == CX24116_DISEQC_TONEOFF) ? 0x00 : 0x01;\r\ncmd.args[0x07] = 0x01;\r\ncmd.len = 0x08;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nstate->dsec_cmd.args[0x00] = CMD_LNBSEND;\r\nstate->dsec_cmd.args[CX24116_DISEQC_BURST] = CX24116_DISEQC_MINI_A;\r\nstate->dsec_cmd.args[CX24116_DISEQC_ARG2_2] = 0x02;\r\nstate->dsec_cmd.args[CX24116_DISEQC_ARG3_0] = 0x00;\r\nstate->dsec_cmd.args[CX24116_DISEQC_ARG4_0] = 0x00;\r\nstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = 0x00;\r\nstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS;\r\nreturn 0;\r\n}\r\nstatic int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *d)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nint i, ret;\r\nif (d->msg_len > sizeof(d->msg))\r\nreturn -EINVAL;\r\nif (debug) {\r\nprintk(KERN_INFO "cx24116: %s(", __func__);\r\nfor (i = 0 ; i < d->msg_len ;) {\r\nprintk(KERN_INFO "0x%02x", d->msg[i]);\r\nif (++i < d->msg_len)\r\nprintk(KERN_INFO ", ");\r\n}\r\nprintk(") toneburst=%d\n", toneburst);\r\n}\r\nfor (i = 0; i < d->msg_len; i++)\r\nstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\r\nstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\r\nstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\r\nstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\r\nif (toneburst == CX24116_DISEQC_MESGCACHE)\r\nreturn 0;\r\nelse if (toneburst == CX24116_DISEQC_TONEOFF)\r\nstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\r\nelse if (toneburst == CX24116_DISEQC_TONECACHE) {\r\nif (d->msg_len >= 4 && d->msg[2] == 0x38)\r\nstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\r\n((d->msg[3] & 4) >> 2);\r\nif (debug)\r\ndprintk("%s burst=%d\n", __func__,\r\nstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\r\n}\r\nret = cx24116_wait_for_lnb(fe);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep(100);\r\nret = cx24116_cmd_execute(fe, &state->dsec_cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\r\n((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\r\nreturn 0;\r\n}\r\nstatic int cx24116_diseqc_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd burst)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nint ret;\r\ndprintk("%s(%d) toneburst=%d\n", __func__, burst, toneburst);\r\nif (burst == SEC_MINI_A)\r\nstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\r\nCX24116_DISEQC_MINI_A;\r\nelse if (burst == SEC_MINI_B)\r\nstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\r\nCX24116_DISEQC_MINI_B;\r\nelse\r\nreturn -EINVAL;\r\nif (toneburst != CX24116_DISEQC_MESGCACHE)\r\nreturn 0;\r\nret = cx24116_wait_for_lnb(fe);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep(100);\r\nret = cx24116_cmd_execute(fe, &state->dsec_cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) + 60);\r\nreturn 0;\r\n}\r\nstatic void cx24116_release(struct dvb_frontend *fe)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *cx24116_attach(const struct cx24116_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct cx24116_state *state = NULL;\r\nint ret;\r\ndprintk("%s\n", __func__);\r\nstate = kzalloc(sizeof(struct cx24116_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error1;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nret = (cx24116_readreg(state, 0xFF) << 8) |\r\ncx24116_readreg(state, 0xFE);\r\nif (ret != 0x0501) {\r\nprintk(KERN_INFO "Invalid probe, probably not a CX24116 device\n");\r\ngoto error2;\r\n}\r\nmemcpy(&state->frontend.ops, &cx24116_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror2: kfree(state);\r\nerror1: return NULL;\r\n}\r\nstatic int cx24116_initfe(struct dvb_frontend *fe)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nstruct cx24116_cmd cmd;\r\nint ret;\r\ndprintk("%s()\n", __func__);\r\ncx24116_writereg(state, 0xe0, 0);\r\ncx24116_writereg(state, 0xe1, 0);\r\ncx24116_writereg(state, 0xea, 0);\r\ncmd.args[0x00] = CMD_TUNERSLEEP;\r\ncmd.args[0x01] = 0;\r\ncmd.len = 0x02;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24116_diseqc_init(fe);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn cx24116_set_voltage(fe, SEC_VOLTAGE_13);\r\n}\r\nstatic int cx24116_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nstruct cx24116_cmd cmd;\r\nint ret;\r\ndprintk("%s()\n", __func__);\r\ncmd.args[0x00] = CMD_TUNERSLEEP;\r\ncmd.args[0x01] = 1;\r\ncmd.len = 0x02;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\ncx24116_writereg(state, 0xea, 0xff);\r\ncx24116_writereg(state, 0xe1, 1);\r\ncx24116_writereg(state, 0xe0, 1);\r\nreturn 0;\r\n}\r\nstatic int cx24116_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct cx24116_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx24116_cmd cmd;\r\nenum fe_status tunerstat;\r\nint i, status, ret, retune = 1;\r\ndprintk("%s()\n", __func__);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\ndprintk("%s: DVB-S delivery system selected\n", __func__);\r\nif (c->modulation != QPSK) {\r\ndprintk("%s: unsupported modulation selected (%d)\n",\r\n__func__, c->modulation);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstate->dnxt.pilot_val = CX24116_PILOT_OFF;\r\nif (c->rolloff != ROLLOFF_35) {\r\ndprintk("%s: unsupported rolloff selected (%d)\n",\r\n__func__, c->rolloff);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstate->dnxt.rolloff_val = CX24116_ROLLOFF_035;\r\nbreak;\r\ncase SYS_DVBS2:\r\ndprintk("%s: DVB-S2 delivery system selected\n", __func__);\r\nif (c->modulation != PSK_8 && c->modulation != QPSK) {\r\ndprintk("%s: unsupported modulation selected (%d)\n",\r\n__func__, c->modulation);\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (c->pilot) {\r\ncase PILOT_AUTO:\r\nstate->dnxt.pilot_val = (c->modulation == QPSK)\r\n? CX24116_PILOT_OFF : CX24116_PILOT_ON;\r\nretune++;\r\nbreak;\r\ncase PILOT_OFF:\r\nstate->dnxt.pilot_val = CX24116_PILOT_OFF;\r\nbreak;\r\ncase PILOT_ON:\r\nstate->dnxt.pilot_val = CX24116_PILOT_ON;\r\nbreak;\r\ndefault:\r\ndprintk("%s: unsupported pilot mode selected (%d)\n",\r\n__func__, c->pilot);\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (c->rolloff) {\r\ncase ROLLOFF_20:\r\nstate->dnxt.rolloff_val = CX24116_ROLLOFF_020;\r\nbreak;\r\ncase ROLLOFF_25:\r\nstate->dnxt.rolloff_val = CX24116_ROLLOFF_025;\r\nbreak;\r\ncase ROLLOFF_35:\r\nstate->dnxt.rolloff_val = CX24116_ROLLOFF_035;\r\nbreak;\r\ncase ROLLOFF_AUTO:\r\ndefault:\r\ndprintk("%s: unsupported rolloff selected (%d)\n",\r\n__func__, c->rolloff);\r\nreturn -EOPNOTSUPP;\r\n}\r\nbreak;\r\ndefault:\r\ndprintk("%s: unsupported delivery system selected (%d)\n",\r\n__func__, c->delivery_system);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstate->dnxt.delsys = c->delivery_system;\r\nstate->dnxt.modulation = c->modulation;\r\nstate->dnxt.frequency = c->frequency;\r\nstate->dnxt.pilot = c->pilot;\r\nstate->dnxt.rolloff = c->rolloff;\r\nret = cx24116_set_inversion(state, c->inversion);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24116_set_fec(state, c->delivery_system, c->modulation, c->fec_inner);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24116_set_symbolrate(state, c->symbol_rate);\r\nif (ret != 0)\r\nreturn ret;\r\ncx24116_clone_params(fe);\r\ndprintk("%s: delsys = %d\n", __func__, state->dcur.delsys);\r\ndprintk("%s: modulation = %d\n", __func__, state->dcur.modulation);\r\ndprintk("%s: frequency = %d\n", __func__, state->dcur.frequency);\r\ndprintk("%s: pilot = %d (val = 0x%02x)\n", __func__,\r\nstate->dcur.pilot, state->dcur.pilot_val);\r\ndprintk("%s: retune = %d\n", __func__, retune);\r\ndprintk("%s: rolloff = %d (val = 0x%02x)\n", __func__,\r\nstate->dcur.rolloff, state->dcur.rolloff_val);\r\ndprintk("%s: symbol_rate = %d\n", __func__, state->dcur.symbol_rate);\r\ndprintk("%s: FEC = %d (mask/val = 0x%02x/0x%02x)\n", __func__,\r\nstate->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);\r\ndprintk("%s: Inversion = %d (val = 0x%02x)\n", __func__,\r\nstate->dcur.inversion, state->dcur.inversion_val);\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, 0);\r\ncmd.args[0x00] = CMD_BANDWIDTH;\r\ncmd.args[0x01] = 0x01;\r\ncmd.len = 0x02;\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\ncmd.args[0x00] = CMD_TUNEREQUEST;\r\ncmd.args[0x01] = (state->dcur.frequency & 0xff0000) >> 16;\r\ncmd.args[0x02] = (state->dcur.frequency & 0x00ff00) >> 8;\r\ncmd.args[0x03] = (state->dcur.frequency & 0x0000ff);\r\ncmd.args[0x04] = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;\r\ncmd.args[0x05] = ((state->dcur.symbol_rate / 1000) & 0x00ff);\r\ncmd.args[0x06] = state->dcur.inversion_val;\r\ncmd.args[0x07] = state->dcur.fec_val | state->dcur.pilot_val;\r\ncmd.args[0x08] = CX24116_SEARCH_RANGE_KHZ >> 8;\r\ncmd.args[0x09] = CX24116_SEARCH_RANGE_KHZ & 0xff;\r\ncmd.args[0x0a] = 0x00;\r\ncmd.args[0x0b] = 0x00;\r\ncmd.args[0x0c] = state->dcur.rolloff_val;\r\ncmd.args[0x0d] = state->dcur.fec_mask;\r\nif (state->dcur.symbol_rate > 30000000) {\r\ncmd.args[0x0e] = 0x04;\r\ncmd.args[0x0f] = 0x00;\r\ncmd.args[0x10] = 0x01;\r\ncmd.args[0x11] = 0x77;\r\ncmd.args[0x12] = 0x36;\r\ncx24116_writereg(state, CX24116_REG_CLKDIV, 0x44);\r\ncx24116_writereg(state, CX24116_REG_RATEDIV, 0x01);\r\n} else {\r\ncmd.args[0x0e] = 0x06;\r\ncmd.args[0x0f] = 0x00;\r\ncmd.args[0x10] = 0x00;\r\ncmd.args[0x11] = 0xFA;\r\ncmd.args[0x12] = 0x24;\r\ncx24116_writereg(state, CX24116_REG_CLKDIV, 0x46);\r\ncx24116_writereg(state, CX24116_REG_RATEDIV, 0x00);\r\n}\r\ncmd.len = 0x13;\r\ndo {\r\nstatus = cx24116_readreg(state, CX24116_REG_SSTATUS)\r\n& CX24116_SIGNAL_MASK;\r\ncx24116_writereg(state, CX24116_REG_SSTATUS, status);\r\nret = cx24116_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nbreak;\r\nfor (i = 0; i < 50 ; i++) {\r\ncx24116_read_status(fe, &tunerstat);\r\nstatus = tunerstat & (FE_HAS_SIGNAL | FE_HAS_SYNC);\r\nif (status == (FE_HAS_SIGNAL | FE_HAS_SYNC)) {\r\ndprintk("%s: Tuned\n", __func__);\r\ngoto tuned;\r\n}\r\nmsleep(10);\r\n}\r\ndprintk("%s: Not tuned\n", __func__);\r\nif (state->dcur.pilot == PILOT_AUTO)\r\ncmd.args[0x07] ^= CX24116_PILOT_ON;\r\n} while (--retune);\r\ntuned:\r\ncmd.args[0x00] = CMD_BANDWIDTH;\r\ncmd.args[0x01] = 0x00;\r\ncmd.len = 0x02;\r\nreturn cx24116_cmd_execute(fe, &cmd);\r\n}\r\nstatic int cx24116_tune(struct dvb_frontend *fe, bool re_tune,\r\nunsigned int mode_flags, unsigned int *delay, enum fe_status *status)\r\n{\r\n*delay = HZ / 5;\r\nif (re_tune) {\r\nint ret = cx24116_set_frontend(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn cx24116_read_status(fe, status);\r\n}\r\nstatic int cx24116_get_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_HW;\r\n}
