static ssize_t device_show(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scif_hw_dev *dev = dev_to_scif(d);\r\nreturn sprintf(buf, "0x%04x\n", dev->id.device);\r\n}\r\nstatic ssize_t vendor_show(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scif_hw_dev *dev = dev_to_scif(d);\r\nreturn sprintf(buf, "0x%04x\n", dev->id.vendor);\r\n}\r\nstatic ssize_t modalias_show(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scif_hw_dev *dev = dev_to_scif(d);\r\nreturn sprintf(buf, "scif:d%08Xv%08X\n",\r\ndev->id.device, dev->id.vendor);\r\n}\r\nstatic inline int scif_id_match(const struct scif_hw_dev *dev,\r\nconst struct scif_hw_dev_id *id)\r\n{\r\nif (id->device != dev->id.device && id->device != SCIF_DEV_ANY_ID)\r\nreturn 0;\r\nreturn id->vendor == SCIF_DEV_ANY_ID || id->vendor == dev->id.vendor;\r\n}\r\nstatic int scif_dev_match(struct device *dv, struct device_driver *dr)\r\n{\r\nunsigned int i;\r\nstruct scif_hw_dev *dev = dev_to_scif(dv);\r\nconst struct scif_hw_dev_id *ids;\r\nids = drv_to_scif(dr)->id_table;\r\nfor (i = 0; ids[i].device; i++)\r\nif (scif_id_match(dev, &ids[i]))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int scif_uevent(struct device *dv, struct kobj_uevent_env *env)\r\n{\r\nstruct scif_hw_dev *dev = dev_to_scif(dv);\r\nreturn add_uevent_var(env, "MODALIAS=scif:d%08Xv%08X",\r\ndev->id.device, dev->id.vendor);\r\n}\r\nstatic int scif_dev_probe(struct device *d)\r\n{\r\nstruct scif_hw_dev *dev = dev_to_scif(d);\r\nstruct scif_driver *drv = drv_to_scif(dev->dev.driver);\r\nreturn drv->probe(dev);\r\n}\r\nstatic int scif_dev_remove(struct device *d)\r\n{\r\nstruct scif_hw_dev *dev = dev_to_scif(d);\r\nstruct scif_driver *drv = drv_to_scif(dev->dev.driver);\r\ndrv->remove(dev);\r\nreturn 0;\r\n}\r\nint scif_register_driver(struct scif_driver *driver)\r\n{\r\ndriver->driver.bus = &scif_bus;\r\nreturn driver_register(&driver->driver);\r\n}\r\nvoid scif_unregister_driver(struct scif_driver *driver)\r\n{\r\ndriver_unregister(&driver->driver);\r\n}\r\nstatic void scif_release_dev(struct device *d)\r\n{\r\nstruct scif_hw_dev *sdev = dev_to_scif(d);\r\nkfree(sdev);\r\n}\r\nstruct scif_hw_dev *\r\nscif_register_device(struct device *pdev, int id, struct dma_map_ops *dma_ops,\r\nstruct scif_hw_ops *hw_ops, u8 dnode, u8 snode,\r\nstruct mic_mw *mmio, struct mic_mw *aper, void *dp,\r\nvoid __iomem *rdp, struct dma_chan **chan, int num_chan,\r\nbool card_rel_da)\r\n{\r\nint ret;\r\nstruct scif_hw_dev *sdev;\r\nsdev = kzalloc(sizeof(*sdev), GFP_KERNEL);\r\nif (!sdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsdev->dev.parent = pdev;\r\nsdev->id.device = id;\r\nsdev->id.vendor = SCIF_DEV_ANY_ID;\r\nsdev->dev.archdata.dma_ops = dma_ops;\r\nsdev->dev.release = scif_release_dev;\r\nsdev->hw_ops = hw_ops;\r\nsdev->dnode = dnode;\r\nsdev->snode = snode;\r\ndev_set_drvdata(&sdev->dev, sdev);\r\nsdev->dev.bus = &scif_bus;\r\nsdev->mmio = mmio;\r\nsdev->aper = aper;\r\nsdev->dp = dp;\r\nsdev->rdp = rdp;\r\nsdev->dev.dma_mask = &sdev->dev.coherent_dma_mask;\r\ndma_set_mask(&sdev->dev, DMA_BIT_MASK(64));\r\nsdev->dma_ch = chan;\r\nsdev->num_dma_ch = num_chan;\r\nsdev->card_rel_da = card_rel_da;\r\ndev_set_name(&sdev->dev, "scif-dev%u", sdev->dnode);\r\nret = device_register(&sdev->dev);\r\nif (ret)\r\ngoto free_sdev;\r\nreturn sdev;\r\nfree_sdev:\r\nput_device(&sdev->dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid scif_unregister_device(struct scif_hw_dev *sdev)\r\n{\r\ndevice_unregister(&sdev->dev);\r\n}\r\nstatic int __init scif_init(void)\r\n{\r\nreturn bus_register(&scif_bus);\r\n}\r\nstatic void __exit scif_exit(void)\r\n{\r\nbus_unregister(&scif_bus);\r\n}
