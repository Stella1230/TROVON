static void pm8001_phy_init(struct pm8001_hba_info *pm8001_ha, int phy_id)\r\n{\r\nstruct pm8001_phy *phy = &pm8001_ha->phy[phy_id];\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nphy->phy_state = 0;\r\nphy->pm8001_ha = pm8001_ha;\r\nsas_phy->enabled = (phy_id < pm8001_ha->chip->n_phy) ? 1 : 0;\r\nsas_phy->class = SAS;\r\nsas_phy->iproto = SAS_PROTOCOL_ALL;\r\nsas_phy->tproto = 0;\r\nsas_phy->type = PHY_TYPE_PHYSICAL;\r\nsas_phy->role = PHY_ROLE_INITIATOR;\r\nsas_phy->oob_mode = OOB_NOT_CONNECTED;\r\nsas_phy->linkrate = SAS_LINK_RATE_UNKNOWN;\r\nsas_phy->id = phy_id;\r\nsas_phy->sas_addr = &pm8001_ha->sas_addr[0];\r\nsas_phy->frame_rcvd = &phy->frame_rcvd[0];\r\nsas_phy->ha = (struct sas_ha_struct *)pm8001_ha->shost->hostdata;\r\nsas_phy->lldd_phy = phy;\r\n}\r\nstatic void pm8001_free(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nint i;\r\nif (!pm8001_ha)\r\nreturn;\r\nfor (i = 0; i < USI_MAX_MEMCNT; i++) {\r\nif (pm8001_ha->memoryMap.region[i].virt_ptr != NULL) {\r\npci_free_consistent(pm8001_ha->pdev,\r\n(pm8001_ha->memoryMap.region[i].total_len +\r\npm8001_ha->memoryMap.region[i].alignment),\r\npm8001_ha->memoryMap.region[i].virt_ptr,\r\npm8001_ha->memoryMap.region[i].phys_addr);\r\n}\r\n}\r\nPM8001_CHIP_DISP->chip_iounmap(pm8001_ha);\r\nif (pm8001_ha->shost)\r\nscsi_host_put(pm8001_ha->shost);\r\nflush_workqueue(pm8001_wq);\r\nkfree(pm8001_ha->tags);\r\nkfree(pm8001_ha);\r\n}\r\nstatic void pm8001_tasklet(unsigned long opaque)\r\n{\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct isr_param *irq_vector;\r\nirq_vector = (struct isr_param *)opaque;\r\npm8001_ha = irq_vector->drv_inst;\r\nif (unlikely(!pm8001_ha))\r\nBUG_ON(1);\r\nPM8001_CHIP_DISP->isr(pm8001_ha, irq_vector->irq_id);\r\n}\r\nstatic irqreturn_t pm8001_interrupt_handler_msix(int irq, void *opaque)\r\n{\r\nstruct isr_param *irq_vector;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nirq_vector = (struct isr_param *)opaque;\r\npm8001_ha = irq_vector->drv_inst;\r\nif (unlikely(!pm8001_ha))\r\nreturn IRQ_NONE;\r\nif (!PM8001_CHIP_DISP->is_our_interupt(pm8001_ha))\r\nreturn IRQ_NONE;\r\n#ifdef PM8001_USE_TASKLET\r\ntasklet_schedule(&pm8001_ha->tasklet[irq_vector->irq_id]);\r\n#else\r\nret = PM8001_CHIP_DISP->isr(pm8001_ha, irq_vector->irq_id);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic irqreturn_t pm8001_interrupt_handler_intx(int irq, void *dev_id)\r\n{\r\nstruct pm8001_hba_info *pm8001_ha;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nstruct sas_ha_struct *sha = dev_id;\r\npm8001_ha = sha->lldd_ha;\r\nif (unlikely(!pm8001_ha))\r\nreturn IRQ_NONE;\r\nif (!PM8001_CHIP_DISP->is_our_interupt(pm8001_ha))\r\nreturn IRQ_NONE;\r\n#ifdef PM8001_USE_TASKLET\r\ntasklet_schedule(&pm8001_ha->tasklet[0]);\r\n#else\r\nret = PM8001_CHIP_DISP->isr(pm8001_ha, 0);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int pm8001_alloc(struct pm8001_hba_info *pm8001_ha,\r\nconst struct pci_device_id *ent)\r\n{\r\nint i;\r\nspin_lock_init(&pm8001_ha->lock);\r\nspin_lock_init(&pm8001_ha->bitmap_lock);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("pm8001_alloc: PHY:%x\n",\r\npm8001_ha->chip->n_phy));\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\r\npm8001_phy_init(pm8001_ha, i);\r\npm8001_ha->port[i].wide_port_phymap = 0;\r\npm8001_ha->port[i].port_attached = 0;\r\npm8001_ha->port[i].port_state = 0;\r\nINIT_LIST_HEAD(&pm8001_ha->port[i].list);\r\n}\r\npm8001_ha->tags = kzalloc(PM8001_MAX_CCB, GFP_KERNEL);\r\nif (!pm8001_ha->tags)\r\ngoto err_out;\r\npm8001_ha->memoryMap.region[AAP1].num_elements = 1;\r\npm8001_ha->memoryMap.region[AAP1].element_size = PM8001_EVENT_LOG_SIZE;\r\npm8001_ha->memoryMap.region[AAP1].total_len = PM8001_EVENT_LOG_SIZE;\r\npm8001_ha->memoryMap.region[AAP1].alignment = 32;\r\npm8001_ha->memoryMap.region[IOP].num_elements = 1;\r\npm8001_ha->memoryMap.region[IOP].element_size = PM8001_EVENT_LOG_SIZE;\r\npm8001_ha->memoryMap.region[IOP].total_len = PM8001_EVENT_LOG_SIZE;\r\npm8001_ha->memoryMap.region[IOP].alignment = 32;\r\nfor (i = 0; i < PM8001_MAX_SPCV_INB_NUM; i++) {\r\npm8001_ha->memoryMap.region[CI+i].num_elements = 1;\r\npm8001_ha->memoryMap.region[CI+i].element_size = 4;\r\npm8001_ha->memoryMap.region[CI+i].total_len = 4;\r\npm8001_ha->memoryMap.region[CI+i].alignment = 4;\r\nif ((ent->driver_data) != chip_8001) {\r\npm8001_ha->memoryMap.region[IB+i].num_elements =\r\nPM8001_MPI_QUEUE;\r\npm8001_ha->memoryMap.region[IB+i].element_size = 128;\r\npm8001_ha->memoryMap.region[IB+i].total_len =\r\nPM8001_MPI_QUEUE * 128;\r\npm8001_ha->memoryMap.region[IB+i].alignment = 128;\r\n} else {\r\npm8001_ha->memoryMap.region[IB+i].num_elements =\r\nPM8001_MPI_QUEUE;\r\npm8001_ha->memoryMap.region[IB+i].element_size = 64;\r\npm8001_ha->memoryMap.region[IB+i].total_len =\r\nPM8001_MPI_QUEUE * 64;\r\npm8001_ha->memoryMap.region[IB+i].alignment = 64;\r\n}\r\n}\r\nfor (i = 0; i < PM8001_MAX_SPCV_OUTB_NUM; i++) {\r\npm8001_ha->memoryMap.region[PI+i].num_elements = 1;\r\npm8001_ha->memoryMap.region[PI+i].element_size = 4;\r\npm8001_ha->memoryMap.region[PI+i].total_len = 4;\r\npm8001_ha->memoryMap.region[PI+i].alignment = 4;\r\nif (ent->driver_data != chip_8001) {\r\npm8001_ha->memoryMap.region[OB+i].num_elements =\r\nPM8001_MPI_QUEUE;\r\npm8001_ha->memoryMap.region[OB+i].element_size = 128;\r\npm8001_ha->memoryMap.region[OB+i].total_len =\r\nPM8001_MPI_QUEUE * 128;\r\npm8001_ha->memoryMap.region[OB+i].alignment = 128;\r\n} else {\r\npm8001_ha->memoryMap.region[OB+i].num_elements =\r\nPM8001_MPI_QUEUE;\r\npm8001_ha->memoryMap.region[OB+i].element_size = 64;\r\npm8001_ha->memoryMap.region[OB+i].total_len =\r\nPM8001_MPI_QUEUE * 64;\r\npm8001_ha->memoryMap.region[OB+i].alignment = 64;\r\n}\r\n}\r\npm8001_ha->memoryMap.region[NVMD].num_elements = 1;\r\npm8001_ha->memoryMap.region[NVMD].element_size = 4096;\r\npm8001_ha->memoryMap.region[NVMD].total_len = 4096;\r\npm8001_ha->memoryMap.region[DEV_MEM].num_elements = 1;\r\npm8001_ha->memoryMap.region[DEV_MEM].element_size = PM8001_MAX_DEVICES *\r\nsizeof(struct pm8001_device);\r\npm8001_ha->memoryMap.region[DEV_MEM].total_len = PM8001_MAX_DEVICES *\r\nsizeof(struct pm8001_device);\r\npm8001_ha->memoryMap.region[CCB_MEM].num_elements = 1;\r\npm8001_ha->memoryMap.region[CCB_MEM].element_size = PM8001_MAX_CCB *\r\nsizeof(struct pm8001_ccb_info);\r\npm8001_ha->memoryMap.region[CCB_MEM].total_len = PM8001_MAX_CCB *\r\nsizeof(struct pm8001_ccb_info);\r\npm8001_ha->memoryMap.region[FW_FLASH].total_len = 4096;\r\npm8001_ha->memoryMap.region[FORENSIC_MEM].num_elements = 1;\r\npm8001_ha->memoryMap.region[FORENSIC_MEM].total_len = 0x10000;\r\npm8001_ha->memoryMap.region[FORENSIC_MEM].element_size = 0x10000;\r\npm8001_ha->memoryMap.region[FORENSIC_MEM].alignment = 0x10000;\r\nfor (i = 0; i < USI_MAX_MEMCNT; i++) {\r\nif (pm8001_mem_alloc(pm8001_ha->pdev,\r\n&pm8001_ha->memoryMap.region[i].virt_ptr,\r\n&pm8001_ha->memoryMap.region[i].phys_addr,\r\n&pm8001_ha->memoryMap.region[i].phys_addr_hi,\r\n&pm8001_ha->memoryMap.region[i].phys_addr_lo,\r\npm8001_ha->memoryMap.region[i].total_len,\r\npm8001_ha->memoryMap.region[i].alignment) != 0) {\r\nPM8001_FAIL_DBG(pm8001_ha,\r\npm8001_printk("Mem%d alloc failed\n",\r\ni));\r\ngoto err_out;\r\n}\r\n}\r\npm8001_ha->devices = pm8001_ha->memoryMap.region[DEV_MEM].virt_ptr;\r\nfor (i = 0; i < PM8001_MAX_DEVICES; i++) {\r\npm8001_ha->devices[i].dev_type = SAS_PHY_UNUSED;\r\npm8001_ha->devices[i].id = i;\r\npm8001_ha->devices[i].device_id = PM8001_MAX_DEVICES;\r\npm8001_ha->devices[i].running_req = 0;\r\n}\r\npm8001_ha->ccb_info = pm8001_ha->memoryMap.region[CCB_MEM].virt_ptr;\r\nfor (i = 0; i < PM8001_MAX_CCB; i++) {\r\npm8001_ha->ccb_info[i].ccb_dma_handle =\r\npm8001_ha->memoryMap.region[CCB_MEM].phys_addr +\r\ni * sizeof(struct pm8001_ccb_info);\r\npm8001_ha->ccb_info[i].task = NULL;\r\npm8001_ha->ccb_info[i].ccb_tag = 0xffffffff;\r\npm8001_ha->ccb_info[i].device = NULL;\r\n++pm8001_ha->tags_num;\r\n}\r\npm8001_ha->flags = PM8001F_INIT_TIME;\r\npm8001_tag_init(pm8001_ha);\r\nreturn 0;\r\nerr_out:\r\nreturn 1;\r\n}\r\nstatic int pm8001_ioremap(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 bar;\r\nu32 logicalBar = 0;\r\nstruct pci_dev *pdev;\r\npdev = pm8001_ha->pdev;\r\nfor (bar = 0; bar < 6; bar++) {\r\nif ((bar == 1) || (bar == 3))\r\ncontinue;\r\nif (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {\r\npm8001_ha->io_mem[logicalBar].membase =\r\npci_resource_start(pdev, bar);\r\npm8001_ha->io_mem[logicalBar].memsize =\r\npci_resource_len(pdev, bar);\r\npm8001_ha->io_mem[logicalBar].memvirtaddr =\r\nioremap(pm8001_ha->io_mem[logicalBar].membase,\r\npm8001_ha->io_mem[logicalBar].memsize);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("PCI: bar %d, logicalBar %d ",\r\nbar, logicalBar));\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk(\r\n"base addr %llx virt_addr=%llx len=%d\n",\r\n(u64)pm8001_ha->io_mem[logicalBar].membase,\r\n(u64)(unsigned long)\r\npm8001_ha->io_mem[logicalBar].memvirtaddr,\r\npm8001_ha->io_mem[logicalBar].memsize));\r\n} else {\r\npm8001_ha->io_mem[logicalBar].membase = 0;\r\npm8001_ha->io_mem[logicalBar].memsize = 0;\r\npm8001_ha->io_mem[logicalBar].memvirtaddr = 0;\r\n}\r\nlogicalBar++;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pm8001_hba_info *pm8001_pci_alloc(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent,\r\nstruct Scsi_Host *shost)\r\n{\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nint j;\r\npm8001_ha = sha->lldd_ha;\r\nif (!pm8001_ha)\r\nreturn NULL;\r\npm8001_ha->pdev = pdev;\r\npm8001_ha->dev = &pdev->dev;\r\npm8001_ha->chip_id = ent->driver_data;\r\npm8001_ha->chip = &pm8001_chips[pm8001_ha->chip_id];\r\npm8001_ha->irq = pdev->irq;\r\npm8001_ha->sas = sha;\r\npm8001_ha->shost = shost;\r\npm8001_ha->id = pm8001_id++;\r\npm8001_ha->logging_level = 0x01;\r\nsprintf(pm8001_ha->name, "%s%d", DRV_NAME, pm8001_ha->id);\r\nif (pm8001_ha->chip_id != chip_8001)\r\npm8001_ha->iomb_size = IOMB_SIZE_SPCV;\r\nelse\r\npm8001_ha->iomb_size = IOMB_SIZE_SPC;\r\n#ifdef PM8001_USE_TASKLET\r\nif ((!pdev->msix_cap || !pci_msi_enabled())\r\n|| (pm8001_ha->chip_id == chip_8001))\r\ntasklet_init(&pm8001_ha->tasklet[0], pm8001_tasklet,\r\n(unsigned long)&(pm8001_ha->irq_vector[0]));\r\nelse\r\nfor (j = 0; j < PM8001_MAX_MSIX_VEC; j++)\r\ntasklet_init(&pm8001_ha->tasklet[j], pm8001_tasklet,\r\n(unsigned long)&(pm8001_ha->irq_vector[j]));\r\n#endif\r\npm8001_ioremap(pm8001_ha);\r\nif (!pm8001_alloc(pm8001_ha, ent))\r\nreturn pm8001_ha;\r\npm8001_free(pm8001_ha);\r\nreturn NULL;\r\n}\r\nstatic int pci_go_44(struct pci_dev *pdev)\r\n{\r\nint rc;\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(44))) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(44));\r\nif (rc) {\r\nrc = pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"44-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\n} else {\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"32-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"32-bit consistent DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int pm8001_prep_sas_ha_init(struct Scsi_Host *shost,\r\nconst struct pm8001_chip_info *chip_info)\r\n{\r\nint phy_nr, port_nr;\r\nstruct asd_sas_phy **arr_phy;\r\nstruct asd_sas_port **arr_port;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\nphy_nr = chip_info->n_phy;\r\nport_nr = phy_nr;\r\nmemset(sha, 0x00, sizeof(*sha));\r\narr_phy = kcalloc(phy_nr, sizeof(void *), GFP_KERNEL);\r\nif (!arr_phy)\r\ngoto exit;\r\narr_port = kcalloc(port_nr, sizeof(void *), GFP_KERNEL);\r\nif (!arr_port)\r\ngoto exit_free2;\r\nsha->sas_phy = arr_phy;\r\nsha->sas_port = arr_port;\r\nsha->lldd_ha = kzalloc(sizeof(struct pm8001_hba_info), GFP_KERNEL);\r\nif (!sha->lldd_ha)\r\ngoto exit_free1;\r\nshost->transportt = pm8001_stt;\r\nshost->max_id = PM8001_MAX_DEVICES;\r\nshost->max_lun = 8;\r\nshost->max_channel = 0;\r\nshost->unique_id = pm8001_id;\r\nshost->max_cmd_len = 16;\r\nshost->can_queue = PM8001_CAN_QUEUE;\r\nshost->cmd_per_lun = 32;\r\nreturn 0;\r\nexit_free1:\r\nkfree(arr_port);\r\nexit_free2:\r\nkfree(arr_phy);\r\nexit:\r\nreturn -1;\r\n}\r\nstatic void pm8001_post_sas_ha_init(struct Scsi_Host *shost,\r\nconst struct pm8001_chip_info *chip_info)\r\n{\r\nint i = 0;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\r\npm8001_ha = sha->lldd_ha;\r\nfor (i = 0; i < chip_info->n_phy; i++) {\r\nsha->sas_phy[i] = &pm8001_ha->phy[i].sas_phy;\r\nsha->sas_port[i] = &pm8001_ha->port[i].sas_port;\r\n}\r\nsha->sas_ha_name = DRV_NAME;\r\nsha->dev = pm8001_ha->dev;\r\nsha->lldd_module = THIS_MODULE;\r\nsha->sas_addr = &pm8001_ha->sas_addr[0];\r\nsha->num_phys = chip_info->n_phy;\r\nsha->core.shost = shost;\r\n}\r\nstatic void pm8001_init_sas_add(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu8 i, j;\r\n#ifdef PM8001_READ_VPD\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct pm8001_ioctl_payload payload;\r\nu16 deviceid;\r\nint rc;\r\npci_read_config_word(pm8001_ha->pdev, PCI_DEVICE_ID, &deviceid);\r\npm8001_ha->nvmd_completion = &completion;\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nif (deviceid == 0x8081 || deviceid == 0x0042) {\r\npayload.minor_function = 4;\r\npayload.length = 4096;\r\n} else {\r\npayload.minor_function = 0;\r\npayload.length = 128;\r\n}\r\n} else if ((pm8001_ha->chip_id == chip_8070 ||\r\npm8001_ha->chip_id == chip_8072) &&\r\npm8001_ha->pdev->subsystem_vendor == PCI_VENDOR_ID_ATTO) {\r\npayload.minor_function = 4;\r\npayload.length = 4096;\r\n} else {\r\npayload.minor_function = 1;\r\npayload.length = 4096;\r\n}\r\npayload.offset = 0;\r\npayload.func_specific = kzalloc(payload.length, GFP_KERNEL);\r\nif (!payload.func_specific) {\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk("mem alloc fail\n"));\r\nreturn;\r\n}\r\nrc = PM8001_CHIP_DISP->get_nvmd_req(pm8001_ha, &payload);\r\nif (rc) {\r\nkfree(payload.func_specific);\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk("nvmd failed\n"));\r\nreturn;\r\n}\r\nwait_for_completion(&completion);\r\nfor (i = 0, j = 0; i <= 7; i++, j++) {\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nif (deviceid == 0x8081)\r\npm8001_ha->sas_addr[j] =\r\npayload.func_specific[0x704 + i];\r\nelse if (deviceid == 0x0042)\r\npm8001_ha->sas_addr[j] =\r\npayload.func_specific[0x010 + i];\r\n} else if ((pm8001_ha->chip_id == chip_8070 ||\r\npm8001_ha->chip_id == chip_8072) &&\r\npm8001_ha->pdev->subsystem_vendor == PCI_VENDOR_ID_ATTO) {\r\npm8001_ha->sas_addr[j] =\r\npayload.func_specific[0x010 + i];\r\n} else\r\npm8001_ha->sas_addr[j] =\r\npayload.func_specific[0x804 + i];\r\n}\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\r\nmemcpy(&pm8001_ha->phy[i].dev_sas_addr,\r\npm8001_ha->sas_addr, SAS_ADDR_SIZE);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("phy %d sas_addr = %016llx\n", i,\r\npm8001_ha->phy[i].dev_sas_addr));\r\n}\r\nkfree(payload.func_specific);\r\n#else\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\r\npm8001_ha->phy[i].dev_sas_addr = 0x50010c600047f9d0ULL;\r\npm8001_ha->phy[i].dev_sas_addr =\r\ncpu_to_be64((u64)\r\n(*(u64 *)&pm8001_ha->phy[i].dev_sas_addr));\r\n}\r\nmemcpy(pm8001_ha->sas_addr, &pm8001_ha->phy[0].dev_sas_addr,\r\nSAS_ADDR_SIZE);\r\n#endif\r\n}\r\nstatic int pm8001_get_phy_settings_info(struct pm8001_hba_info *pm8001_ha)\r\n{\r\n#ifdef PM8001_READ_VPD\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct pm8001_ioctl_payload payload;\r\nint rc;\r\npm8001_ha->nvmd_completion = &completion;\r\npayload.minor_function = 6;\r\npayload.offset = 0;\r\npayload.length = 4096;\r\npayload.func_specific = kzalloc(4096, GFP_KERNEL);\r\nif (!payload.func_specific)\r\nreturn -ENOMEM;\r\nrc = PM8001_CHIP_DISP->get_nvmd_req(pm8001_ha, &payload);\r\nif (rc) {\r\nkfree(payload.func_specific);\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk("nvmd failed\n"));\r\nreturn -ENOMEM;\r\n}\r\nwait_for_completion(&completion);\r\npm8001_set_phy_profile(pm8001_ha, sizeof(u8), payload.func_specific);\r\nkfree(payload.func_specific);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic\r\nvoid pm8001_get_internal_phy_settings(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_mpi3_phy_pg_trx_config *phycfg)\r\n{\r\nphycfg->LaneLosCfg = 0x00000132;\r\nphycfg->LanePgaCfg1 = 0x00203949;\r\nphycfg->LanePisoCfg1 = 0x000000FF;\r\nphycfg->LanePisoCfg2 = 0xFF000001;\r\nphycfg->LanePisoCfg3 = 0xE7011300;\r\nphycfg->LanePisoCfg4 = 0x631C40C0;\r\nphycfg->LanePisoCfg5 = 0xF8102036;\r\nphycfg->LanePisoCfg6 = 0xF74A1000;\r\nphycfg->LaneBctCtrl = 0x00FB33F8;\r\n}\r\nstatic\r\nvoid pm8001_get_external_phy_settings(struct pm8001_hba_info *pm8001_ha,\r\nstruct pm8001_mpi3_phy_pg_trx_config *phycfg)\r\n{\r\nphycfg->LaneLosCfg = 0x00000132;\r\nphycfg->LanePgaCfg1 = 0x00203949;\r\nphycfg->LanePisoCfg1 = 0x000000FF;\r\nphycfg->LanePisoCfg2 = 0xFF000001;\r\nphycfg->LanePisoCfg3 = 0xE7011300;\r\nphycfg->LanePisoCfg4 = 0x63349140;\r\nphycfg->LanePisoCfg5 = 0xF8102036;\r\nphycfg->LanePisoCfg6 = 0xF80D9300;\r\nphycfg->LaneBctCtrl = 0x00FB33F8;\r\n}\r\nstatic\r\nvoid pm8001_get_phy_mask(struct pm8001_hba_info *pm8001_ha, int *phymask)\r\n{\r\nswitch (pm8001_ha->pdev->subsystem_device) {\r\ncase 0x0070:\r\ncase 0x0072:\r\n*phymask = 0x0000;\r\nbreak;\r\ncase 0x0071:\r\ncase 0x0073:\r\n*phymask = 0xFFFF;\r\nbreak;\r\ncase 0x0080:\r\n*phymask = 0x00F0;\r\nbreak;\r\ncase 0x0081:\r\n*phymask = 0x0FF0;\r\nbreak;\r\ncase 0x0082:\r\n*phymask = 0xFF00;\r\nbreak;\r\ndefault:\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("Unknown subsystem device=0x%.04x",\r\npm8001_ha->pdev->subsystem_device));\r\n}\r\n}\r\nstatic\r\nint pm8001_set_phy_settings_ven_117c_12G(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct pm8001_mpi3_phy_pg_trx_config phycfg_int;\r\nstruct pm8001_mpi3_phy_pg_trx_config phycfg_ext;\r\nint phymask = 0;\r\nint i = 0;\r\nmemset(&phycfg_int, 0, sizeof(phycfg_int));\r\nmemset(&phycfg_ext, 0, sizeof(phycfg_ext));\r\npm8001_get_internal_phy_settings(pm8001_ha, &phycfg_int);\r\npm8001_get_external_phy_settings(pm8001_ha, &phycfg_ext);\r\npm8001_get_phy_mask(pm8001_ha, &phymask);\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\r\nif (phymask & (1 << i)) {\r\npm8001_set_phy_profile_single(pm8001_ha, i,\r\nsizeof(phycfg_int) / sizeof(u32),\r\n(u32 *)&phycfg_int);\r\n} else {\r\npm8001_set_phy_profile_single(pm8001_ha, i,\r\nsizeof(phycfg_ext) / sizeof(u32),\r\n(u32 *)&phycfg_ext);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8001_configure_phy_settings(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nswitch (pm8001_ha->pdev->subsystem_vendor) {\r\ncase PCI_VENDOR_ID_ATTO:\r\nif (pm8001_ha->pdev->device == 0x0042)\r\nreturn 0;\r\nelse\r\nreturn pm8001_set_phy_settings_ven_117c_12G(pm8001_ha);\r\ncase PCI_VENDOR_ID_ADAPTEC2:\r\ncase 0:\r\nreturn 0;\r\ndefault:\r\nreturn pm8001_get_phy_settings_info(pm8001_ha);\r\n}\r\n}\r\nstatic u32 pm8001_setup_msix(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nu32 i = 0, j = 0;\r\nu32 number_of_intr;\r\nint flag = 0;\r\nu32 max_entry;\r\nint rc;\r\nstatic char intr_drvname[PM8001_MAX_MSIX_VEC][sizeof(DRV_NAME)+3];\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nnumber_of_intr = 1;\r\n} else {\r\nnumber_of_intr = PM8001_MAX_MSIX_VEC;\r\nflag &= ~IRQF_SHARED;\r\n}\r\nmax_entry = sizeof(pm8001_ha->msix_entries) /\r\nsizeof(pm8001_ha->msix_entries[0]);\r\nfor (i = 0; i < max_entry ; i++)\r\npm8001_ha->msix_entries[i].entry = i;\r\nrc = pci_enable_msix_exact(pm8001_ha->pdev, pm8001_ha->msix_entries,\r\nnumber_of_intr);\r\npm8001_ha->number_of_intr = number_of_intr;\r\nif (rc)\r\nreturn rc;\r\nPM8001_INIT_DBG(pm8001_ha, pm8001_printk(\r\n"pci_enable_msix_exact request ret:%d no of intr %d\n",\r\nrc, pm8001_ha->number_of_intr));\r\nfor (i = 0; i < number_of_intr; i++) {\r\nsnprintf(intr_drvname[i], sizeof(intr_drvname[0]),\r\nDRV_NAME"%d", i);\r\npm8001_ha->irq_vector[i].irq_id = i;\r\npm8001_ha->irq_vector[i].drv_inst = pm8001_ha;\r\nrc = request_irq(pm8001_ha->msix_entries[i].vector,\r\npm8001_interrupt_handler_msix, flag,\r\nintr_drvname[i], &(pm8001_ha->irq_vector[i]));\r\nif (rc) {\r\nfor (j = 0; j < i; j++) {\r\nfree_irq(pm8001_ha->msix_entries[j].vector,\r\n&(pm8001_ha->irq_vector[i]));\r\n}\r\npci_disable_msix(pm8001_ha->pdev);\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic u32 pm8001_request_irq(struct pm8001_hba_info *pm8001_ha)\r\n{\r\nstruct pci_dev *pdev;\r\nint rc;\r\npdev = pm8001_ha->pdev;\r\n#ifdef PM8001_USE_MSIX\r\nif (pdev->msix_cap && pci_msi_enabled())\r\nreturn pm8001_setup_msix(pm8001_ha);\r\nelse {\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("MSIX not supported!!!\n"));\r\ngoto intx;\r\n}\r\n#endif\r\nintx:\r\npm8001_ha->irq_vector[0].irq_id = 0;\r\npm8001_ha->irq_vector[0].drv_inst = pm8001_ha;\r\nrc = request_irq(pdev->irq, pm8001_interrupt_handler_intx, IRQF_SHARED,\r\nDRV_NAME, SHOST_TO_SAS_HA(pm8001_ha->shost));\r\nreturn rc;\r\n}\r\nstatic int pm8001_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nunsigned int rc;\r\nu32 pci_reg;\r\nu8 i = 0;\r\nstruct pm8001_hba_info *pm8001_ha;\r\nstruct Scsi_Host *shost = NULL;\r\nconst struct pm8001_chip_info *chip;\r\ndev_printk(KERN_INFO, &pdev->dev,\r\n"pm80xx: driver version %s\n", DRV_VERSION);\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err_out_enable;\r\npci_set_master(pdev);\r\npci_read_config_dword(pdev, PCI_COMMAND, &pci_reg);\r\npci_reg |= 0x157;\r\npci_write_config_dword(pdev, PCI_COMMAND, pci_reg);\r\nrc = pci_request_regions(pdev, DRV_NAME);\r\nif (rc)\r\ngoto err_out_disable;\r\nrc = pci_go_44(pdev);\r\nif (rc)\r\ngoto err_out_regions;\r\nshost = scsi_host_alloc(&pm8001_sht, sizeof(void *));\r\nif (!shost) {\r\nrc = -ENOMEM;\r\ngoto err_out_regions;\r\n}\r\nchip = &pm8001_chips[ent->driver_data];\r\nSHOST_TO_SAS_HA(shost) =\r\nkzalloc(sizeof(struct sas_ha_struct), GFP_KERNEL);\r\nif (!SHOST_TO_SAS_HA(shost)) {\r\nrc = -ENOMEM;\r\ngoto err_out_free_host;\r\n}\r\nrc = pm8001_prep_sas_ha_init(shost, chip);\r\nif (rc) {\r\nrc = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\npci_set_drvdata(pdev, SHOST_TO_SAS_HA(shost));\r\npm8001_ha = pm8001_pci_alloc(pdev, ent, shost);\r\nif (!pm8001_ha) {\r\nrc = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nlist_add_tail(&pm8001_ha->list, &hba_list);\r\nPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha);\r\nrc = PM8001_CHIP_DISP->chip_init(pm8001_ha);\r\nif (rc) {\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk(\r\n"chip_init failed [ret: %d]\n", rc));\r\ngoto err_out_ha_free;\r\n}\r\nrc = scsi_add_host(shost, &pdev->dev);\r\nif (rc)\r\ngoto err_out_ha_free;\r\nrc = pm8001_request_irq(pm8001_ha);\r\nif (rc) {\r\nPM8001_FAIL_DBG(pm8001_ha, pm8001_printk(\r\n"pm8001_request_irq failed [ret: %d]\n", rc));\r\ngoto err_out_shost;\r\n}\r\nPM8001_CHIP_DISP->interrupt_enable(pm8001_ha, 0);\r\nif (pm8001_ha->chip_id != chip_8001) {\r\nfor (i = 1; i < pm8001_ha->number_of_intr; i++)\r\nPM8001_CHIP_DISP->interrupt_enable(pm8001_ha, i);\r\npm80xx_set_thermal_config(pm8001_ha);\r\n}\r\npm8001_init_sas_add(pm8001_ha);\r\nif (pm8001_configure_phy_settings(pm8001_ha))\r\ngoto err_out_shost;\r\npm8001_post_sas_ha_init(shost, chip);\r\nrc = sas_register_ha(SHOST_TO_SAS_HA(shost));\r\nif (rc)\r\ngoto err_out_shost;\r\nscsi_scan_host(pm8001_ha->shost);\r\nreturn 0;\r\nerr_out_shost:\r\nscsi_remove_host(pm8001_ha->shost);\r\nerr_out_ha_free:\r\npm8001_free(pm8001_ha);\r\nerr_out_free:\r\nkfree(SHOST_TO_SAS_HA(shost));\r\nerr_out_free_host:\r\nkfree(shost);\r\nerr_out_regions:\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out_enable:\r\nreturn rc;\r\n}\r\nstatic void pm8001_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\r\nstruct pm8001_hba_info *pm8001_ha;\r\nint i, j;\r\npm8001_ha = sha->lldd_ha;\r\nscsi_remove_host(pm8001_ha->shost);\r\nsas_unregister_ha(sha);\r\nsas_remove_host(pm8001_ha->shost);\r\nlist_del(&pm8001_ha->list);\r\nPM8001_CHIP_DISP->interrupt_disable(pm8001_ha, 0xFF);\r\nPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha);\r\n#ifdef PM8001_USE_MSIX\r\nfor (i = 0; i < pm8001_ha->number_of_intr; i++)\r\nsynchronize_irq(pm8001_ha->msix_entries[i].vector);\r\nfor (i = 0; i < pm8001_ha->number_of_intr; i++)\r\nfree_irq(pm8001_ha->msix_entries[i].vector,\r\n&(pm8001_ha->irq_vector[i]));\r\npci_disable_msix(pdev);\r\n#else\r\nfree_irq(pm8001_ha->irq, sha);\r\n#endif\r\n#ifdef PM8001_USE_TASKLET\r\nif ((!pdev->msix_cap || !pci_msi_enabled()) ||\r\n(pm8001_ha->chip_id == chip_8001))\r\ntasklet_kill(&pm8001_ha->tasklet[0]);\r\nelse\r\nfor (j = 0; j < PM8001_MAX_MSIX_VEC; j++)\r\ntasklet_kill(&pm8001_ha->tasklet[j]);\r\n#endif\r\npm8001_free(pm8001_ha);\r\nkfree(sha->sas_phy);\r\nkfree(sha->sas_port);\r\nkfree(sha);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int pm8001_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\r\nstruct pm8001_hba_info *pm8001_ha;\r\nint i, j;\r\nu32 device_state;\r\npm8001_ha = sha->lldd_ha;\r\nsas_suspend_ha(sha);\r\nflush_workqueue(pm8001_wq);\r\nscsi_block_requests(pm8001_ha->shost);\r\nif (!pdev->pm_cap) {\r\ndev_err(&pdev->dev, " PCI PM not supported\n");\r\nreturn -ENODEV;\r\n}\r\nPM8001_CHIP_DISP->interrupt_disable(pm8001_ha, 0xFF);\r\nPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha);\r\n#ifdef PM8001_USE_MSIX\r\nfor (i = 0; i < pm8001_ha->number_of_intr; i++)\r\nsynchronize_irq(pm8001_ha->msix_entries[i].vector);\r\nfor (i = 0; i < pm8001_ha->number_of_intr; i++)\r\nfree_irq(pm8001_ha->msix_entries[i].vector,\r\n&(pm8001_ha->irq_vector[i]));\r\npci_disable_msix(pdev);\r\n#else\r\nfree_irq(pm8001_ha->irq, sha);\r\n#endif\r\n#ifdef PM8001_USE_TASKLET\r\nif ((!pdev->msix_cap || !pci_msi_enabled()) ||\r\n(pm8001_ha->chip_id == chip_8001))\r\ntasklet_kill(&pm8001_ha->tasklet[0]);\r\nelse\r\nfor (j = 0; j < PM8001_MAX_MSIX_VEC; j++)\r\ntasklet_kill(&pm8001_ha->tasklet[j]);\r\n#endif\r\ndevice_state = pci_choose_state(pdev, state);\r\npm8001_printk("pdev=0x%p, slot=%s, entering "\r\n"operating state [D%d]\n", pdev,\r\npm8001_ha->name, device_state);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, device_state);\r\nreturn 0;\r\n}\r\nstatic int pm8001_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\r\nstruct pm8001_hba_info *pm8001_ha;\r\nint rc;\r\nu8 i = 0, j;\r\nu32 device_state;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\npm8001_ha = sha->lldd_ha;\r\ndevice_state = pdev->current_state;\r\npm8001_printk("pdev=0x%p, slot=%s, resuming from previous "\r\n"operating state [D%d]\n", pdev, pm8001_ha->name, device_state);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\npm8001_printk("slot=%s Enable device failed during resume\n",\r\npm8001_ha->name);\r\ngoto err_out_enable;\r\n}\r\npci_set_master(pdev);\r\nrc = pci_go_44(pdev);\r\nif (rc)\r\ngoto err_out_disable;\r\nsas_prep_resume_ha(sha);\r\nif (pm8001_ha->chip_id == chip_8001) {\r\nPM8001_CHIP_DISP->chip_soft_rst(pm8001_ha);\r\nPM8001_INIT_DBG(pm8001_ha,\r\npm8001_printk("chip soft reset successful\n"));\r\n}\r\nrc = PM8001_CHIP_DISP->chip_init(pm8001_ha);\r\nif (rc)\r\ngoto err_out_disable;\r\nPM8001_CHIP_DISP->interrupt_disable(pm8001_ha, 0xFF);\r\nrc = pm8001_request_irq(pm8001_ha);\r\nif (rc)\r\ngoto err_out_disable;\r\n#ifdef PM8001_USE_TASKLET\r\nif ((!pdev->msix_cap || !pci_msi_enabled()) ||\r\n(pm8001_ha->chip_id == chip_8001))\r\ntasklet_init(&pm8001_ha->tasklet[0], pm8001_tasklet,\r\n(unsigned long)&(pm8001_ha->irq_vector[0]));\r\nelse\r\nfor (j = 0; j < PM8001_MAX_MSIX_VEC; j++)\r\ntasklet_init(&pm8001_ha->tasklet[j], pm8001_tasklet,\r\n(unsigned long)&(pm8001_ha->irq_vector[j]));\r\n#endif\r\nPM8001_CHIP_DISP->interrupt_enable(pm8001_ha, 0);\r\nif (pm8001_ha->chip_id != chip_8001) {\r\nfor (i = 1; i < pm8001_ha->number_of_intr; i++)\r\nPM8001_CHIP_DISP->interrupt_enable(pm8001_ha, i);\r\n}\r\nif (pm8001_ha->chip_id == chip_8070 ||\r\npm8001_ha->chip_id == chip_8072) {\r\nmdelay(500);\r\n}\r\npm8001_ha->flags = PM8001F_RUN_TIME;\r\nfor (i = 0; i < pm8001_ha->chip->n_phy; i++) {\r\npm8001_ha->phy[i].enable_completion = &completion;\r\nPM8001_CHIP_DISP->phy_start_req(pm8001_ha, i);\r\nwait_for_completion(&completion);\r\n}\r\nsas_resume_ha(sha);\r\nreturn 0;\r\nerr_out_disable:\r\nscsi_remove_host(pm8001_ha->shost);\r\npci_disable_device(pdev);\r\nerr_out_enable:\r\nreturn rc;\r\n}\r\nstatic int __init pm8001_init(void)\r\n{\r\nint rc = -ENOMEM;\r\npm8001_wq = alloc_workqueue("pm80xx", 0, 0);\r\nif (!pm8001_wq)\r\ngoto err;\r\npm8001_id = 0;\r\npm8001_stt = sas_domain_attach_transport(&pm8001_transport_ops);\r\nif (!pm8001_stt)\r\ngoto err_wq;\r\nrc = pci_register_driver(&pm8001_pci_driver);\r\nif (rc)\r\ngoto err_tp;\r\nreturn 0;\r\nerr_tp:\r\nsas_release_transport(pm8001_stt);\r\nerr_wq:\r\ndestroy_workqueue(pm8001_wq);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic void __exit pm8001_exit(void)\r\n{\r\npci_unregister_driver(&pm8001_pci_driver);\r\nsas_release_transport(pm8001_stt);\r\ndestroy_workqueue(pm8001_wq);\r\n}
