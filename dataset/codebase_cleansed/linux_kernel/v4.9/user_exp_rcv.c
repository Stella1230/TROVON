static inline u32 rcventry2tidinfo(u32 rcventry)\r\n{\r\nu32 pair = rcventry & ~0x1;\r\nreturn EXP_TID_SET(IDX, pair >> 1) |\r\nEXP_TID_SET(CTRL, 1 << (rcventry - pair));\r\n}\r\nstatic inline void exp_tid_group_init(struct exp_tid_set *set)\r\n{\r\nINIT_LIST_HEAD(&set->list);\r\nset->count = 0;\r\n}\r\nstatic inline void tid_group_remove(struct tid_group *grp,\r\nstruct exp_tid_set *set)\r\n{\r\nlist_del_init(&grp->list);\r\nset->count--;\r\n}\r\nstatic inline void tid_group_add_tail(struct tid_group *grp,\r\nstruct exp_tid_set *set)\r\n{\r\nlist_add_tail(&grp->list, &set->list);\r\nset->count++;\r\n}\r\nstatic inline struct tid_group *tid_group_pop(struct exp_tid_set *set)\r\n{\r\nstruct tid_group *grp =\r\nlist_first_entry(&set->list, struct tid_group, list);\r\nlist_del_init(&grp->list);\r\nset->count--;\r\nreturn grp;\r\n}\r\nstatic inline void tid_group_move(struct tid_group *group,\r\nstruct exp_tid_set *s1,\r\nstruct exp_tid_set *s2)\r\n{\r\ntid_group_remove(group, s1);\r\ntid_group_add_tail(group, s2);\r\n}\r\nint hfi1_user_exp_rcv_init(struct file *fp)\r\n{\r\nstruct hfi1_filedata *fd = fp->private_data;\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nstruct hfi1_devdata *dd = uctxt->dd;\r\nunsigned tidbase;\r\nint i, ret = 0;\r\nspin_lock_init(&fd->tid_lock);\r\nspin_lock_init(&fd->invalid_lock);\r\nif (!uctxt->subctxt_cnt || !fd->subctxt) {\r\nexp_tid_group_init(&uctxt->tid_group_list);\r\nexp_tid_group_init(&uctxt->tid_used_list);\r\nexp_tid_group_init(&uctxt->tid_full_list);\r\ntidbase = uctxt->expected_base;\r\nfor (i = 0; i < uctxt->expected_count /\r\ndd->rcv_entries.group_size; i++) {\r\nstruct tid_group *grp;\r\ngrp = kzalloc(sizeof(*grp), GFP_KERNEL);\r\nif (!grp) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\ngrp->size = dd->rcv_entries.group_size;\r\ngrp->base = tidbase;\r\ntid_group_add_tail(grp, &uctxt->tid_group_list);\r\ntidbase += dd->rcv_entries.group_size;\r\n}\r\n}\r\nfd->entry_to_rb = kcalloc(uctxt->expected_count,\r\nsizeof(struct rb_node *),\r\nGFP_KERNEL);\r\nif (!fd->entry_to_rb)\r\nreturn -ENOMEM;\r\nif (!HFI1_CAP_UGET_MASK(uctxt->flags, TID_UNMAP)) {\r\nfd->invalid_tid_idx = 0;\r\nfd->invalid_tids = kzalloc(uctxt->expected_count *\r\nsizeof(u32), GFP_KERNEL);\r\nif (!fd->invalid_tids) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nret = hfi1_mmu_rb_register(fd, fd->mm, &tid_rb_ops,\r\ndd->pport->hfi1_wq,\r\n&fd->handler);\r\nif (ret) {\r\ndd_dev_info(dd,\r\n"Failed MMU notifier registration %d\n",\r\nret);\r\nret = 0;\r\n}\r\n}\r\nspin_lock(&fd->tid_lock);\r\nif (uctxt->subctxt_cnt && fd->handler) {\r\nu16 remainder;\r\nfd->tid_limit = uctxt->expected_count / uctxt->subctxt_cnt;\r\nremainder = uctxt->expected_count % uctxt->subctxt_cnt;\r\nif (remainder && fd->subctxt < remainder)\r\nfd->tid_limit++;\r\n} else {\r\nfd->tid_limit = uctxt->expected_count;\r\n}\r\nspin_unlock(&fd->tid_lock);\r\ndone:\r\nreturn ret;\r\n}\r\nint hfi1_user_exp_rcv_free(struct hfi1_filedata *fd)\r\n{\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nstruct tid_group *grp, *gptr;\r\nif (!test_bit(HFI1_CTXT_SETUP_DONE, &uctxt->event_flags))\r\nreturn 0;\r\nif (fd->handler)\r\nhfi1_mmu_rb_unregister(fd->handler);\r\nkfree(fd->invalid_tids);\r\nif (!uctxt->cnt) {\r\nif (!EXP_TID_SET_EMPTY(uctxt->tid_full_list))\r\nunlock_exp_tids(uctxt, &uctxt->tid_full_list, fd);\r\nif (!EXP_TID_SET_EMPTY(uctxt->tid_used_list))\r\nunlock_exp_tids(uctxt, &uctxt->tid_used_list, fd);\r\nlist_for_each_entry_safe(grp, gptr, &uctxt->tid_group_list.list,\r\nlist) {\r\nlist_del_init(&grp->list);\r\nkfree(grp);\r\n}\r\nhfi1_clear_tids(uctxt);\r\n}\r\nkfree(fd->entry_to_rb);\r\nreturn 0;\r\n}\r\nstatic inline void rcv_array_wc_fill(struct hfi1_devdata *dd, u32 index)\r\n{\r\nif ((dd->flags & HFI1_PRESENT) && dd->rcvarray_wc)\r\nwriteq(0, dd->rcvarray_wc + (index * 8));\r\n}\r\nint hfi1_user_exp_rcv_setup(struct file *fp, struct hfi1_tid_info *tinfo)\r\n{\r\nint ret = 0, need_group = 0, pinned;\r\nstruct hfi1_filedata *fd = fp->private_data;\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nstruct hfi1_devdata *dd = uctxt->dd;\r\nunsigned npages, ngroups, pageidx = 0, pageset_count, npagesets,\r\ntididx = 0, mapped, mapped_pages = 0;\r\nunsigned long vaddr = tinfo->vaddr;\r\nstruct page **pages = NULL;\r\nu32 *tidlist = NULL;\r\nstruct tid_pageset *pagesets = NULL;\r\nnpages = num_user_pages(vaddr, tinfo->length);\r\nif (!npages)\r\nreturn -EINVAL;\r\nif (npages > uctxt->expected_count) {\r\ndd_dev_err(dd, "Expected buffer too big\n");\r\nreturn -EINVAL;\r\n}\r\nif (!access_ok(VERIFY_WRITE, (void __user *)vaddr,\r\nnpages * PAGE_SIZE)) {\r\ndd_dev_err(dd, "Fail vaddr %p, %u pages, !access_ok\n",\r\n(void *)vaddr, npages);\r\nreturn -EFAULT;\r\n}\r\npagesets = kcalloc(uctxt->expected_count, sizeof(*pagesets),\r\nGFP_KERNEL);\r\nif (!pagesets)\r\nreturn -ENOMEM;\r\npages = kcalloc(npages, sizeof(*pages), GFP_KERNEL);\r\nif (!pages) {\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\nif (!hfi1_can_pin_pages(dd, fd->mm, fd->tid_n_pinned, npages)) {\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\npinned = hfi1_acquire_user_pages(fd->mm, vaddr, npages, true, pages);\r\nif (pinned <= 0) {\r\nret = pinned;\r\ngoto bail;\r\n}\r\nfd->tid_n_pinned += npages;\r\nnpagesets = find_phys_blocks(pages, pinned, pagesets);\r\nspin_lock(&fd->tid_lock);\r\nif (fd->tid_used + npagesets > fd->tid_limit)\r\npageset_count = fd->tid_limit - fd->tid_used;\r\nelse\r\npageset_count = npagesets;\r\nspin_unlock(&fd->tid_lock);\r\nif (!pageset_count)\r\ngoto bail;\r\nngroups = pageset_count / dd->rcv_entries.group_size;\r\ntidlist = kcalloc(pageset_count, sizeof(*tidlist), GFP_KERNEL);\r\nif (!tidlist) {\r\nret = -ENOMEM;\r\ngoto nomem;\r\n}\r\ntididx = 0;\r\nmutex_lock(&uctxt->exp_lock);\r\nwhile (ngroups && uctxt->tid_group_list.count) {\r\nstruct tid_group *grp =\r\ntid_group_pop(&uctxt->tid_group_list);\r\nret = program_rcvarray(fp, vaddr, grp, pagesets,\r\npageidx, dd->rcv_entries.group_size,\r\npages, tidlist, &tididx, &mapped);\r\nif (ret <= 0) {\r\ntid_group_add_tail(grp, &uctxt->tid_group_list);\r\nhfi1_cdbg(TID,\r\n"Failed to program RcvArray group %d", ret);\r\ngoto unlock;\r\n}\r\ntid_group_add_tail(grp, &uctxt->tid_full_list);\r\nngroups--;\r\npageidx += ret;\r\nmapped_pages += mapped;\r\n}\r\nwhile (pageidx < pageset_count) {\r\nstruct tid_group *grp, *ptr;\r\nif (!uctxt->tid_used_list.count || need_group) {\r\nif (!uctxt->tid_group_list.count)\r\ngoto unlock;\r\ngrp = tid_group_pop(&uctxt->tid_group_list);\r\ntid_group_add_tail(grp, &uctxt->tid_used_list);\r\nneed_group = 0;\r\n}\r\nlist_for_each_entry_safe(grp, ptr, &uctxt->tid_used_list.list,\r\nlist) {\r\nunsigned use = min_t(unsigned, pageset_count - pageidx,\r\ngrp->size - grp->used);\r\nret = program_rcvarray(fp, vaddr, grp, pagesets,\r\npageidx, use, pages, tidlist,\r\n&tididx, &mapped);\r\nif (ret < 0) {\r\nhfi1_cdbg(TID,\r\n"Failed to program RcvArray entries %d",\r\nret);\r\nret = -EFAULT;\r\ngoto unlock;\r\n} else if (ret > 0) {\r\nif (grp->used == grp->size)\r\ntid_group_move(grp,\r\n&uctxt->tid_used_list,\r\n&uctxt->tid_full_list);\r\npageidx += ret;\r\nmapped_pages += mapped;\r\nneed_group = 0;\r\nif (pageidx >= pageset_count)\r\nbreak;\r\n} else if (WARN_ON(ret == 0)) {\r\nneed_group = 1;\r\n}\r\n}\r\n}\r\nunlock:\r\nmutex_unlock(&uctxt->exp_lock);\r\nnomem:\r\nhfi1_cdbg(TID, "total mapped: tidpairs:%u pages:%u (%d)", tididx,\r\nmapped_pages, ret);\r\nif (tididx) {\r\nspin_lock(&fd->tid_lock);\r\nfd->tid_used += tididx;\r\nspin_unlock(&fd->tid_lock);\r\ntinfo->tidcnt = tididx;\r\ntinfo->length = mapped_pages * PAGE_SIZE;\r\nif (copy_to_user((void __user *)(unsigned long)tinfo->tidlist,\r\ntidlist, sizeof(tidlist[0]) * tididx)) {\r\ntinfo->tidlist = (unsigned long)&tidlist;\r\nhfi1_user_exp_rcv_clear(fp, tinfo);\r\ntinfo->tidlist = 0;\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\n}\r\nif (mapped_pages != pinned) {\r\nhfi1_release_user_pages(fd->mm, &pages[mapped_pages],\r\npinned - mapped_pages,\r\nfalse);\r\nfd->tid_n_pinned -= pinned - mapped_pages;\r\n}\r\nbail:\r\nkfree(pagesets);\r\nkfree(pages);\r\nkfree(tidlist);\r\nreturn ret > 0 ? 0 : ret;\r\n}\r\nint hfi1_user_exp_rcv_clear(struct file *fp, struct hfi1_tid_info *tinfo)\r\n{\r\nint ret = 0;\r\nstruct hfi1_filedata *fd = fp->private_data;\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nu32 *tidinfo;\r\nunsigned tididx;\r\ntidinfo = kcalloc(tinfo->tidcnt, sizeof(*tidinfo), GFP_KERNEL);\r\nif (!tidinfo)\r\nreturn -ENOMEM;\r\nif (copy_from_user(tidinfo, (void __user *)(unsigned long)\r\ntinfo->tidlist, sizeof(tidinfo[0]) *\r\ntinfo->tidcnt)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nmutex_lock(&uctxt->exp_lock);\r\nfor (tididx = 0; tididx < tinfo->tidcnt; tididx++) {\r\nret = unprogram_rcvarray(fp, tidinfo[tididx], NULL);\r\nif (ret) {\r\nhfi1_cdbg(TID, "Failed to unprogram rcv array %d",\r\nret);\r\nbreak;\r\n}\r\n}\r\nspin_lock(&fd->tid_lock);\r\nfd->tid_used -= tididx;\r\nspin_unlock(&fd->tid_lock);\r\ntinfo->tidcnt = tididx;\r\nmutex_unlock(&uctxt->exp_lock);\r\ndone:\r\nkfree(tidinfo);\r\nreturn ret;\r\n}\r\nint hfi1_user_exp_rcv_invalid(struct file *fp, struct hfi1_tid_info *tinfo)\r\n{\r\nstruct hfi1_filedata *fd = fp->private_data;\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nunsigned long *ev = uctxt->dd->events +\r\n(((uctxt->ctxt - uctxt->dd->first_user_ctxt) *\r\nHFI1_MAX_SHARED_CTXTS) + fd->subctxt);\r\nu32 *array;\r\nint ret = 0;\r\nif (!fd->invalid_tids)\r\nreturn -EINVAL;\r\narray = kcalloc(uctxt->expected_count, sizeof(*array), GFP_KERNEL);\r\nif (!array)\r\nreturn -EFAULT;\r\nspin_lock(&fd->invalid_lock);\r\nif (fd->invalid_tid_idx) {\r\nmemcpy(array, fd->invalid_tids, sizeof(*array) *\r\nfd->invalid_tid_idx);\r\nmemset(fd->invalid_tids, 0, sizeof(*fd->invalid_tids) *\r\nfd->invalid_tid_idx);\r\ntinfo->tidcnt = fd->invalid_tid_idx;\r\nfd->invalid_tid_idx = 0;\r\nclear_bit(_HFI1_EVENT_TID_MMU_NOTIFY_BIT, ev);\r\n} else {\r\ntinfo->tidcnt = 0;\r\n}\r\nspin_unlock(&fd->invalid_lock);\r\nif (tinfo->tidcnt) {\r\nif (copy_to_user((void __user *)tinfo->tidlist,\r\narray, sizeof(*array) * tinfo->tidcnt))\r\nret = -EFAULT;\r\n}\r\nkfree(array);\r\nreturn ret;\r\n}\r\nstatic u32 find_phys_blocks(struct page **pages, unsigned npages,\r\nstruct tid_pageset *list)\r\n{\r\nunsigned pagecount, pageidx, setcount = 0, i;\r\nunsigned long pfn, this_pfn;\r\nif (!npages)\r\nreturn 0;\r\npfn = page_to_pfn(pages[0]);\r\nfor (pageidx = 0, pagecount = 1, i = 1; i <= npages; i++) {\r\nthis_pfn = i < npages ? page_to_pfn(pages[i]) : 0;\r\nif (this_pfn != ++pfn) {\r\nwhile (pagecount) {\r\nint maxpages = pagecount;\r\nu32 bufsize = pagecount * PAGE_SIZE;\r\nif (bufsize > MAX_EXPECTED_BUFFER)\r\nmaxpages =\r\nMAX_EXPECTED_BUFFER >>\r\nPAGE_SHIFT;\r\nelse if (!is_power_of_2(bufsize))\r\nmaxpages =\r\nrounddown_pow_of_two(bufsize) >>\r\nPAGE_SHIFT;\r\nlist[setcount].idx = pageidx;\r\nlist[setcount].count = maxpages;\r\npagecount -= maxpages;\r\npageidx += maxpages;\r\nsetcount++;\r\n}\r\npageidx = i;\r\npagecount = 1;\r\npfn = this_pfn;\r\n} else {\r\npagecount++;\r\n}\r\n}\r\nreturn setcount;\r\n}\r\nstatic int program_rcvarray(struct file *fp, unsigned long vaddr,\r\nstruct tid_group *grp,\r\nstruct tid_pageset *sets,\r\nunsigned start, u16 count, struct page **pages,\r\nu32 *tidlist, unsigned *tididx, unsigned *pmapped)\r\n{\r\nstruct hfi1_filedata *fd = fp->private_data;\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nstruct hfi1_devdata *dd = uctxt->dd;\r\nu16 idx;\r\nu32 tidinfo = 0, rcventry, useidx = 0;\r\nint mapped = 0;\r\nif (count > grp->size)\r\nreturn -EINVAL;\r\nfor (idx = 0; idx < grp->size; idx++) {\r\nif (!(grp->map & (1 << idx))) {\r\nuseidx = idx;\r\nbreak;\r\n}\r\nrcv_array_wc_fill(dd, grp->base + idx);\r\n}\r\nidx = 0;\r\nwhile (idx < count) {\r\nu16 npages, pageidx, setidx = start + idx;\r\nint ret = 0;\r\nif (useidx >= grp->size) {\r\nbreak;\r\n} else if (grp->map & (1 << useidx)) {\r\nrcv_array_wc_fill(dd, grp->base + useidx);\r\nuseidx++;\r\ncontinue;\r\n}\r\nrcventry = grp->base + useidx;\r\nnpages = sets[setidx].count;\r\npageidx = sets[setidx].idx;\r\nret = set_rcvarray_entry(fp, vaddr + (pageidx * PAGE_SIZE),\r\nrcventry, grp, pages + pageidx,\r\nnpages);\r\nif (ret)\r\nreturn ret;\r\nmapped += npages;\r\ntidinfo = rcventry2tidinfo(rcventry - uctxt->expected_base) |\r\nEXP_TID_SET(LEN, npages);\r\ntidlist[(*tididx)++] = tidinfo;\r\ngrp->used++;\r\ngrp->map |= 1 << useidx++;\r\nidx++;\r\n}\r\nfor (; useidx < grp->size; useidx++)\r\nrcv_array_wc_fill(dd, grp->base + useidx);\r\n*pmapped = mapped;\r\nreturn idx;\r\n}\r\nstatic int set_rcvarray_entry(struct file *fp, unsigned long vaddr,\r\nu32 rcventry, struct tid_group *grp,\r\nstruct page **pages, unsigned npages)\r\n{\r\nint ret;\r\nstruct hfi1_filedata *fd = fp->private_data;\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nstruct tid_rb_node *node;\r\nstruct hfi1_devdata *dd = uctxt->dd;\r\ndma_addr_t phys;\r\nnode = kzalloc(sizeof(*node) + (sizeof(struct page *) * npages),\r\nGFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nphys = pci_map_single(dd->pcidev,\r\n__va(page_to_phys(pages[0])),\r\nnpages * PAGE_SIZE, PCI_DMA_FROMDEVICE);\r\nif (dma_mapping_error(&dd->pcidev->dev, phys)) {\r\ndd_dev_err(dd, "Failed to DMA map Exp Rcv pages 0x%llx\n",\r\nphys);\r\nkfree(node);\r\nreturn -EFAULT;\r\n}\r\nnode->mmu.addr = vaddr;\r\nnode->mmu.len = npages * PAGE_SIZE;\r\nnode->phys = page_to_phys(pages[0]);\r\nnode->npages = npages;\r\nnode->rcventry = rcventry;\r\nnode->dma_addr = phys;\r\nnode->grp = grp;\r\nnode->freed = false;\r\nmemcpy(node->pages, pages, sizeof(struct page *) * npages);\r\nif (!fd->handler)\r\nret = tid_rb_insert(fd, &node->mmu);\r\nelse\r\nret = hfi1_mmu_rb_insert(fd->handler, &node->mmu);\r\nif (ret) {\r\nhfi1_cdbg(TID, "Failed to insert RB node %u 0x%lx, 0x%lx %d",\r\nnode->rcventry, node->mmu.addr, node->phys, ret);\r\npci_unmap_single(dd->pcidev, phys, npages * PAGE_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nkfree(node);\r\nreturn -EFAULT;\r\n}\r\nhfi1_put_tid(dd, rcventry, PT_EXPECTED, phys, ilog2(npages) + 1);\r\ntrace_hfi1_exp_tid_reg(uctxt->ctxt, fd->subctxt, rcventry, npages,\r\nnode->mmu.addr, node->phys, phys);\r\nreturn 0;\r\n}\r\nstatic int unprogram_rcvarray(struct file *fp, u32 tidinfo,\r\nstruct tid_group **grp)\r\n{\r\nstruct hfi1_filedata *fd = fp->private_data;\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nstruct hfi1_devdata *dd = uctxt->dd;\r\nstruct tid_rb_node *node;\r\nu8 tidctrl = EXP_TID_GET(tidinfo, CTRL);\r\nu32 tididx = EXP_TID_GET(tidinfo, IDX) << 1, rcventry;\r\nif (tididx >= uctxt->expected_count) {\r\ndd_dev_err(dd, "Invalid RcvArray entry (%u) index for ctxt %u\n",\r\ntididx, uctxt->ctxt);\r\nreturn -EINVAL;\r\n}\r\nif (tidctrl == 0x3)\r\nreturn -EINVAL;\r\nrcventry = tididx + (tidctrl - 1);\r\nnode = fd->entry_to_rb[rcventry];\r\nif (!node || node->rcventry != (uctxt->expected_base + rcventry))\r\nreturn -EBADF;\r\nif (grp)\r\n*grp = node->grp;\r\nif (!fd->handler)\r\ncacheless_tid_rb_remove(fd, node);\r\nelse\r\nhfi1_mmu_rb_remove(fd->handler, &node->mmu);\r\nreturn 0;\r\n}\r\nstatic void clear_tid_node(struct hfi1_filedata *fd, struct tid_rb_node *node)\r\n{\r\nstruct hfi1_ctxtdata *uctxt = fd->uctxt;\r\nstruct hfi1_devdata *dd = uctxt->dd;\r\ntrace_hfi1_exp_tid_unreg(uctxt->ctxt, fd->subctxt, node->rcventry,\r\nnode->npages, node->mmu.addr, node->phys,\r\nnode->dma_addr);\r\nhfi1_put_tid(dd, node->rcventry, PT_INVALID, 0, 0);\r\nflush_wc();\r\npci_unmap_single(dd->pcidev, node->dma_addr, node->mmu.len,\r\nPCI_DMA_FROMDEVICE);\r\nhfi1_release_user_pages(fd->mm, node->pages, node->npages, true);\r\nfd->tid_n_pinned -= node->npages;\r\nnode->grp->used--;\r\nnode->grp->map &= ~(1 << (node->rcventry - node->grp->base));\r\nif (node->grp->used == node->grp->size - 1)\r\ntid_group_move(node->grp, &uctxt->tid_full_list,\r\n&uctxt->tid_used_list);\r\nelse if (!node->grp->used)\r\ntid_group_move(node->grp, &uctxt->tid_used_list,\r\n&uctxt->tid_group_list);\r\nkfree(node);\r\n}\r\nstatic void unlock_exp_tids(struct hfi1_ctxtdata *uctxt,\r\nstruct exp_tid_set *set,\r\nstruct hfi1_filedata *fd)\r\n{\r\nstruct tid_group *grp, *ptr;\r\nint i;\r\nlist_for_each_entry_safe(grp, ptr, &set->list, list) {\r\nlist_del_init(&grp->list);\r\nfor (i = 0; i < grp->size; i++) {\r\nif (grp->map & (1 << i)) {\r\nu16 rcventry = grp->base + i;\r\nstruct tid_rb_node *node;\r\nnode = fd->entry_to_rb[rcventry -\r\nuctxt->expected_base];\r\nif (!node || node->rcventry != rcventry)\r\ncontinue;\r\ncacheless_tid_rb_remove(fd, node);\r\n}\r\n}\r\n}\r\n}\r\nstatic int tid_rb_invalidate(void *arg, struct mmu_rb_node *mnode)\r\n{\r\nstruct hfi1_filedata *fdata = arg;\r\nstruct hfi1_ctxtdata *uctxt = fdata->uctxt;\r\nstruct tid_rb_node *node =\r\ncontainer_of(mnode, struct tid_rb_node, mmu);\r\nif (node->freed)\r\nreturn 0;\r\ntrace_hfi1_exp_tid_inval(uctxt->ctxt, fdata->subctxt, node->mmu.addr,\r\nnode->rcventry, node->npages, node->dma_addr);\r\nnode->freed = true;\r\nspin_lock(&fdata->invalid_lock);\r\nif (fdata->invalid_tid_idx < uctxt->expected_count) {\r\nfdata->invalid_tids[fdata->invalid_tid_idx] =\r\nrcventry2tidinfo(node->rcventry - uctxt->expected_base);\r\nfdata->invalid_tids[fdata->invalid_tid_idx] |=\r\nEXP_TID_SET(LEN, node->npages);\r\nif (!fdata->invalid_tid_idx) {\r\nunsigned long *ev;\r\nev = uctxt->dd->events +\r\n(((uctxt->ctxt - uctxt->dd->first_user_ctxt) *\r\nHFI1_MAX_SHARED_CTXTS) + fdata->subctxt);\r\nset_bit(_HFI1_EVENT_TID_MMU_NOTIFY_BIT, ev);\r\n}\r\nfdata->invalid_tid_idx++;\r\n}\r\nspin_unlock(&fdata->invalid_lock);\r\nreturn 0;\r\n}\r\nstatic int tid_rb_insert(void *arg, struct mmu_rb_node *node)\r\n{\r\nstruct hfi1_filedata *fdata = arg;\r\nstruct tid_rb_node *tnode =\r\ncontainer_of(node, struct tid_rb_node, mmu);\r\nu32 base = fdata->uctxt->expected_base;\r\nfdata->entry_to_rb[tnode->rcventry - base] = tnode;\r\nreturn 0;\r\n}\r\nstatic void cacheless_tid_rb_remove(struct hfi1_filedata *fdata,\r\nstruct tid_rb_node *tnode)\r\n{\r\nu32 base = fdata->uctxt->expected_base;\r\nfdata->entry_to_rb[tnode->rcventry - base] = NULL;\r\nclear_tid_node(fdata, tnode);\r\n}\r\nstatic void tid_rb_remove(void *arg, struct mmu_rb_node *node)\r\n{\r\nstruct hfi1_filedata *fdata = arg;\r\nstruct tid_rb_node *tnode =\r\ncontainer_of(node, struct tid_rb_node, mmu);\r\ncacheless_tid_rb_remove(fdata, tnode);\r\n}
