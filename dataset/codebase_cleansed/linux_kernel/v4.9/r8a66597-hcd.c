static void enable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,\r\nunsigned long reg)\r\n{\r\nu16 tmp;\r\ntmp = r8a66597_read(r8a66597, INTENB0);\r\nr8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);\r\nr8a66597_bset(r8a66597, 1 << pipenum, reg);\r\nr8a66597_write(r8a66597, tmp, INTENB0);\r\n}\r\nstatic void disable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,\r\nunsigned long reg)\r\n{\r\nu16 tmp;\r\ntmp = r8a66597_read(r8a66597, INTENB0);\r\nr8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);\r\nr8a66597_bclr(r8a66597, 1 << pipenum, reg);\r\nr8a66597_write(r8a66597, tmp, INTENB0);\r\n}\r\nstatic void set_devadd_reg(struct r8a66597 *r8a66597, u8 r8a66597_address,\r\nu16 usbspd, u8 upphub, u8 hubport, int port)\r\n{\r\nu16 val;\r\nunsigned long devadd_reg = get_devadd_addr(r8a66597_address);\r\nval = (upphub << 11) | (hubport << 8) | (usbspd << 6) | (port & 0x0001);\r\nr8a66597_write(r8a66597, val, devadd_reg);\r\n}\r\nstatic int r8a66597_clock_enable(struct r8a66597 *r8a66597)\r\n{\r\nu16 tmp;\r\nint i = 0;\r\nif (r8a66597->pdata->on_chip) {\r\nclk_prepare_enable(r8a66597->clk);\r\ndo {\r\nr8a66597_write(r8a66597, SCKE, SYSCFG0);\r\ntmp = r8a66597_read(r8a66597, SYSCFG0);\r\nif (i++ > 1000) {\r\nprintk(KERN_ERR "r8a66597: reg access fail.\n");\r\nreturn -ENXIO;\r\n}\r\n} while ((tmp & SCKE) != SCKE);\r\nr8a66597_write(r8a66597, 0x04, 0x02);\r\n} else {\r\ndo {\r\nr8a66597_write(r8a66597, USBE, SYSCFG0);\r\ntmp = r8a66597_read(r8a66597, SYSCFG0);\r\nif (i++ > 1000) {\r\nprintk(KERN_ERR "r8a66597: reg access fail.\n");\r\nreturn -ENXIO;\r\n}\r\n} while ((tmp & USBE) != USBE);\r\nr8a66597_bclr(r8a66597, USBE, SYSCFG0);\r\nr8a66597_mdfy(r8a66597, get_xtal_from_pdata(r8a66597->pdata),\r\nXTAL, SYSCFG0);\r\ni = 0;\r\nr8a66597_bset(r8a66597, XCKE, SYSCFG0);\r\ndo {\r\nmsleep(1);\r\ntmp = r8a66597_read(r8a66597, SYSCFG0);\r\nif (i++ > 500) {\r\nprintk(KERN_ERR "r8a66597: reg access fail.\n");\r\nreturn -ENXIO;\r\n}\r\n} while ((tmp & SCKE) != SCKE);\r\n}\r\nreturn 0;\r\n}\r\nstatic void r8a66597_clock_disable(struct r8a66597 *r8a66597)\r\n{\r\nr8a66597_bclr(r8a66597, SCKE, SYSCFG0);\r\nudelay(1);\r\nif (r8a66597->pdata->on_chip) {\r\nclk_disable_unprepare(r8a66597->clk);\r\n} else {\r\nr8a66597_bclr(r8a66597, PLLC, SYSCFG0);\r\nr8a66597_bclr(r8a66597, XCKE, SYSCFG0);\r\nr8a66597_bclr(r8a66597, USBE, SYSCFG0);\r\n}\r\n}\r\nstatic void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)\r\n{\r\nu16 val;\r\nval = port ? DRPD : DCFM | DRPD;\r\nr8a66597_bset(r8a66597, val, get_syscfg_reg(port));\r\nr8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));\r\nr8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, get_dmacfg_reg(port));\r\nr8a66597_bclr(r8a66597, DTCHE, get_intenb_reg(port));\r\nr8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));\r\n}\r\nstatic void r8a66597_disable_port(struct r8a66597 *r8a66597, int port)\r\n{\r\nu16 val, tmp;\r\nr8a66597_write(r8a66597, 0, get_intenb_reg(port));\r\nr8a66597_write(r8a66597, 0, get_intsts_reg(port));\r\nr8a66597_port_power(r8a66597, port, 0);\r\ndo {\r\ntmp = r8a66597_read(r8a66597, SOFCFG) & EDGESTS;\r\nudelay(640);\r\n} while (tmp == EDGESTS);\r\nval = port ? DRPD : DCFM | DRPD;\r\nr8a66597_bclr(r8a66597, val, get_syscfg_reg(port));\r\nr8a66597_bclr(r8a66597, HSE, get_syscfg_reg(port));\r\n}\r\nstatic int enable_controller(struct r8a66597 *r8a66597)\r\n{\r\nint ret, port;\r\nu16 vif = r8a66597->pdata->vif ? LDRV : 0;\r\nu16 irq_sense = r8a66597->irq_sense_low ? INTL : 0;\r\nu16 endian = r8a66597->pdata->endian ? BIGEND : 0;\r\nret = r8a66597_clock_enable(r8a66597);\r\nif (ret < 0)\r\nreturn ret;\r\nr8a66597_bset(r8a66597, vif & LDRV, PINCFG);\r\nr8a66597_bset(r8a66597, USBE, SYSCFG0);\r\nr8a66597_bset(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);\r\nr8a66597_bset(r8a66597, irq_sense & INTL, SOFCFG);\r\nr8a66597_bset(r8a66597, BRDY0, BRDYENB);\r\nr8a66597_bset(r8a66597, BEMP0, BEMPENB);\r\nr8a66597_bset(r8a66597, endian & BIGEND, CFIFOSEL);\r\nr8a66597_bset(r8a66597, endian & BIGEND, D0FIFOSEL);\r\nr8a66597_bset(r8a66597, endian & BIGEND, D1FIFOSEL);\r\nr8a66597_bset(r8a66597, TRNENSEL, SOFCFG);\r\nr8a66597_bset(r8a66597, SIGNE | SACKE, INTENB1);\r\nfor (port = 0; port < r8a66597->max_root_hub; port++)\r\nr8a66597_enable_port(r8a66597, port);\r\nreturn 0;\r\n}\r\nstatic void disable_controller(struct r8a66597 *r8a66597)\r\n{\r\nint port;\r\nr8a66597_write(r8a66597, 0, INTENB0);\r\nr8a66597_write(r8a66597, 0, INTENB1);\r\nr8a66597_write(r8a66597, 0, BRDYENB);\r\nr8a66597_write(r8a66597, 0, BEMPENB);\r\nr8a66597_write(r8a66597, 0, NRDYENB);\r\nr8a66597_write(r8a66597, 0, BRDYSTS);\r\nr8a66597_write(r8a66597, 0, NRDYSTS);\r\nr8a66597_write(r8a66597, 0, BEMPSTS);\r\nfor (port = 0; port < r8a66597->max_root_hub; port++)\r\nr8a66597_disable_port(r8a66597, port);\r\nr8a66597_clock_disable(r8a66597);\r\n}\r\nstatic int get_parent_r8a66597_address(struct r8a66597 *r8a66597,\r\nstruct usb_device *udev)\r\n{\r\nstruct r8a66597_device *dev;\r\nif (udev->parent && udev->parent->devnum != 1)\r\nudev = udev->parent;\r\ndev = dev_get_drvdata(&udev->dev);\r\nif (dev)\r\nreturn dev->address;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int is_child_device(char *devpath)\r\n{\r\nreturn (devpath[2] ? 1 : 0);\r\n}\r\nstatic int is_hub_limit(char *devpath)\r\n{\r\nreturn ((strlen(devpath) >= 4) ? 1 : 0);\r\n}\r\nstatic void get_port_number(struct r8a66597 *r8a66597,\r\nchar *devpath, u16 *root_port, u16 *hub_port)\r\n{\r\nif (root_port) {\r\n*root_port = (devpath[0] & 0x0F) - 1;\r\nif (*root_port >= r8a66597->max_root_hub)\r\nprintk(KERN_ERR "r8a66597: Illegal root port number.\n");\r\n}\r\nif (hub_port)\r\n*hub_port = devpath[2] & 0x0F;\r\n}\r\nstatic u16 get_r8a66597_usb_speed(enum usb_device_speed speed)\r\n{\r\nu16 usbspd = 0;\r\nswitch (speed) {\r\ncase USB_SPEED_LOW:\r\nusbspd = LSMODE;\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nusbspd = FSMODE;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nusbspd = HSMODE;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "r8a66597: unknown speed\n");\r\nbreak;\r\n}\r\nreturn usbspd;\r\n}\r\nstatic void set_child_connect_map(struct r8a66597 *r8a66597, int address)\r\n{\r\nint idx;\r\nidx = address / 32;\r\nr8a66597->child_connect_map[idx] |= 1 << (address % 32);\r\n}\r\nstatic void put_child_connect_map(struct r8a66597 *r8a66597, int address)\r\n{\r\nint idx;\r\nidx = address / 32;\r\nr8a66597->child_connect_map[idx] &= ~(1 << (address % 32));\r\n}\r\nstatic void set_pipe_reg_addr(struct r8a66597_pipe *pipe, u8 dma_ch)\r\n{\r\nu16 pipenum = pipe->info.pipenum;\r\nconst unsigned long fifoaddr[] = {D0FIFO, D1FIFO, CFIFO};\r\nconst unsigned long fifosel[] = {D0FIFOSEL, D1FIFOSEL, CFIFOSEL};\r\nconst unsigned long fifoctr[] = {D0FIFOCTR, D1FIFOCTR, CFIFOCTR};\r\nif (dma_ch > R8A66597_PIPE_NO_DMA)\r\ndma_ch = R8A66597_PIPE_NO_DMA;\r\npipe->fifoaddr = fifoaddr[dma_ch];\r\npipe->fifosel = fifosel[dma_ch];\r\npipe->fifoctr = fifoctr[dma_ch];\r\nif (pipenum == 0)\r\npipe->pipectr = DCPCTR;\r\nelse\r\npipe->pipectr = get_pipectr_addr(pipenum);\r\nif (check_bulk_or_isoc(pipenum)) {\r\npipe->pipetre = get_pipetre_addr(pipenum);\r\npipe->pipetrn = get_pipetrn_addr(pipenum);\r\n} else {\r\npipe->pipetre = 0;\r\npipe->pipetrn = 0;\r\n}\r\n}\r\nstatic struct r8a66597_device *\r\nget_urb_to_r8a66597_dev(struct r8a66597 *r8a66597, struct urb *urb)\r\n{\r\nif (usb_pipedevice(urb->pipe) == 0)\r\nreturn &r8a66597->device0;\r\nreturn dev_get_drvdata(&urb->dev->dev);\r\n}\r\nstatic int make_r8a66597_device(struct r8a66597 *r8a66597,\r\nstruct urb *urb, u8 addr)\r\n{\r\nstruct r8a66597_device *dev;\r\nint usb_address = urb->setup_packet[2];\r\ndev = kzalloc(sizeof(struct r8a66597_device), GFP_ATOMIC);\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&urb->dev->dev, dev);\r\ndev->udev = urb->dev;\r\ndev->address = addr;\r\ndev->usb_address = usb_address;\r\ndev->state = USB_STATE_ADDRESS;\r\ndev->ep_in_toggle = 0;\r\ndev->ep_out_toggle = 0;\r\nINIT_LIST_HEAD(&dev->device_list);\r\nlist_add_tail(&dev->device_list, &r8a66597->child_device);\r\nget_port_number(r8a66597, urb->dev->devpath,\r\n&dev->root_port, &dev->hub_port);\r\nif (!is_child_device(urb->dev->devpath))\r\nr8a66597->root_hub[dev->root_port].dev = dev;\r\nset_devadd_reg(r8a66597, dev->address,\r\nget_r8a66597_usb_speed(urb->dev->speed),\r\nget_parent_r8a66597_address(r8a66597, urb->dev),\r\ndev->hub_port, dev->root_port);\r\nreturn 0;\r\n}\r\nstatic u8 alloc_usb_address(struct r8a66597 *r8a66597, struct urb *urb)\r\n{\r\nu8 addr;\r\nstruct r8a66597_device *dev;\r\nif (is_hub_limit(urb->dev->devpath)) {\r\ndev_err(&urb->dev->dev, "External hub limit reached.\n");\r\nreturn 0;\r\n}\r\ndev = get_urb_to_r8a66597_dev(r8a66597, urb);\r\nif (dev && dev->state >= USB_STATE_ADDRESS)\r\nreturn dev->address;\r\nfor (addr = 1; addr <= R8A66597_MAX_DEVICE; addr++) {\r\nif (r8a66597->address_map & (1 << addr))\r\ncontinue;\r\ndev_dbg(&urb->dev->dev, "alloc_address: r8a66597_addr=%d\n", addr);\r\nr8a66597->address_map |= 1 << addr;\r\nif (make_r8a66597_device(r8a66597, urb, addr) < 0)\r\nreturn 0;\r\nreturn addr;\r\n}\r\ndev_err(&urb->dev->dev,\r\n"cannot communicate with a USB device more than 10.(%x)\n",\r\nr8a66597->address_map);\r\nreturn 0;\r\n}\r\nstatic void free_usb_address(struct r8a66597 *r8a66597,\r\nstruct r8a66597_device *dev, int reset)\r\n{\r\nint port;\r\nif (!dev)\r\nreturn;\r\ndev_dbg(&dev->udev->dev, "free_addr: addr=%d\n", dev->address);\r\ndev->state = USB_STATE_DEFAULT;\r\nr8a66597->address_map &= ~(1 << dev->address);\r\ndev->address = 0;\r\nif (reset)\r\ndev_set_drvdata(&dev->udev->dev, NULL);\r\nlist_del(&dev->device_list);\r\nkfree(dev);\r\nfor (port = 0; port < r8a66597->max_root_hub; port++) {\r\nif (r8a66597->root_hub[port].dev == dev) {\r\nr8a66597->root_hub[port].dev = NULL;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void r8a66597_reg_wait(struct r8a66597 *r8a66597, unsigned long reg,\r\nu16 mask, u16 loop)\r\n{\r\nu16 tmp;\r\nint i = 0;\r\ndo {\r\ntmp = r8a66597_read(r8a66597, reg);\r\nif (i++ > 1000000) {\r\nprintk(KERN_ERR "r8a66597: register%lx, loop %x "\r\n"is timeout\n", reg, loop);\r\nbreak;\r\n}\r\nndelay(1);\r\n} while ((tmp & mask) != loop);\r\n}\r\nstatic void pipe_start(struct r8a66597 *r8a66597, struct r8a66597_pipe *pipe)\r\n{\r\nu16 tmp;\r\ntmp = r8a66597_read(r8a66597, pipe->pipectr) & PID;\r\nif ((pipe->info.pipenum != 0) & ((tmp & PID_STALL) != 0))\r\nr8a66597_mdfy(r8a66597, PID_NAK, PID, pipe->pipectr);\r\nr8a66597_mdfy(r8a66597, PID_BUF, PID, pipe->pipectr);\r\n}\r\nstatic void pipe_stop(struct r8a66597 *r8a66597, struct r8a66597_pipe *pipe)\r\n{\r\nu16 tmp;\r\ntmp = r8a66597_read(r8a66597, pipe->pipectr) & PID;\r\nif ((tmp & PID_STALL11) != PID_STALL11)\r\nr8a66597_mdfy(r8a66597, PID_STALL, PID, pipe->pipectr);\r\nr8a66597_mdfy(r8a66597, PID_NAK, PID, pipe->pipectr);\r\nr8a66597_reg_wait(r8a66597, pipe->pipectr, PBUSY, 0);\r\n}\r\nstatic void clear_all_buffer(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe *pipe)\r\n{\r\nu16 tmp;\r\nif (!pipe || pipe->info.pipenum == 0)\r\nreturn;\r\npipe_stop(r8a66597, pipe);\r\nr8a66597_bset(r8a66597, ACLRM, pipe->pipectr);\r\ntmp = r8a66597_read(r8a66597, pipe->pipectr);\r\ntmp = r8a66597_read(r8a66597, pipe->pipectr);\r\ntmp = r8a66597_read(r8a66597, pipe->pipectr);\r\nr8a66597_bclr(r8a66597, ACLRM, pipe->pipectr);\r\n}\r\nstatic void r8a66597_pipe_toggle(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe *pipe, int toggle)\r\n{\r\nif (toggle)\r\nr8a66597_bset(r8a66597, SQSET, pipe->pipectr);\r\nelse\r\nr8a66597_bset(r8a66597, SQCLR, pipe->pipectr);\r\n}\r\nstatic inline unsigned short mbw_value(struct r8a66597 *r8a66597)\r\n{\r\nif (r8a66597->pdata->on_chip)\r\nreturn MBW_32;\r\nelse\r\nreturn MBW_16;\r\n}\r\nstatic inline void cfifo_change(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nunsigned short mbw = mbw_value(r8a66597);\r\nr8a66597_mdfy(r8a66597, mbw | pipenum, mbw | CURPIPE, CFIFOSEL);\r\nr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, pipenum);\r\n}\r\nstatic inline void fifo_change_from_pipe(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe *pipe)\r\n{\r\nunsigned short mbw = mbw_value(r8a66597);\r\ncfifo_change(r8a66597, 0);\r\nr8a66597_mdfy(r8a66597, mbw | 0, mbw | CURPIPE, D0FIFOSEL);\r\nr8a66597_mdfy(r8a66597, mbw | 0, mbw | CURPIPE, D1FIFOSEL);\r\nr8a66597_mdfy(r8a66597, mbw | pipe->info.pipenum, mbw | CURPIPE,\r\npipe->fifosel);\r\nr8a66597_reg_wait(r8a66597, pipe->fifosel, CURPIPE, pipe->info.pipenum);\r\n}\r\nstatic u16 r8a66597_get_pipenum(struct urb *urb, struct usb_host_endpoint *hep)\r\n{\r\nstruct r8a66597_pipe *pipe = hep->hcpriv;\r\nif (usb_pipeendpoint(urb->pipe) == 0)\r\nreturn 0;\r\nelse\r\nreturn pipe->info.pipenum;\r\n}\r\nstatic u16 get_urb_to_r8a66597_addr(struct r8a66597 *r8a66597, struct urb *urb)\r\n{\r\nstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\r\nreturn (usb_pipedevice(urb->pipe) == 0) ? 0 : dev->address;\r\n}\r\nstatic unsigned short *get_toggle_pointer(struct r8a66597_device *dev,\r\nint urb_pipe)\r\n{\r\nif (!dev)\r\nreturn NULL;\r\nreturn usb_pipein(urb_pipe) ? &dev->ep_in_toggle : &dev->ep_out_toggle;\r\n}\r\nstatic void pipe_toggle_set(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe *pipe,\r\nstruct urb *urb, int set)\r\n{\r\nstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\r\nunsigned char endpoint = usb_pipeendpoint(urb->pipe);\r\nunsigned short *toggle = get_toggle_pointer(dev, urb->pipe);\r\nif (!toggle)\r\nreturn;\r\nif (set)\r\n*toggle |= 1 << endpoint;\r\nelse\r\n*toggle &= ~(1 << endpoint);\r\n}\r\nstatic void pipe_toggle_save(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe *pipe,\r\nstruct urb *urb)\r\n{\r\nif (r8a66597_read(r8a66597, pipe->pipectr) & SQMON)\r\npipe_toggle_set(r8a66597, pipe, urb, 1);\r\nelse\r\npipe_toggle_set(r8a66597, pipe, urb, 0);\r\n}\r\nstatic void pipe_toggle_restore(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe *pipe,\r\nstruct urb *urb)\r\n{\r\nstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\r\nunsigned char endpoint = usb_pipeendpoint(urb->pipe);\r\nunsigned short *toggle = get_toggle_pointer(dev, urb->pipe);\r\nif (!toggle)\r\nreturn;\r\nr8a66597_pipe_toggle(r8a66597, pipe, *toggle & (1 << endpoint));\r\n}\r\nstatic void pipe_buffer_setting(struct r8a66597 *r8a66597,\r\nstruct r8a66597_pipe_info *info)\r\n{\r\nu16 val = 0;\r\nif (info->pipenum == 0)\r\nreturn;\r\nr8a66597_bset(r8a66597, ACLRM, get_pipectr_addr(info->pipenum));\r\nr8a66597_bclr(r8a66597, ACLRM, get_pipectr_addr(info->pipenum));\r\nr8a66597_write(r8a66597, info->pipenum, PIPESEL);\r\nif (!info->dir_in)\r\nval |= R8A66597_DIR;\r\nif (info->type == R8A66597_BULK && info->dir_in)\r\nval |= R8A66597_DBLB | R8A66597_SHTNAK;\r\nval |= info->type | info->epnum;\r\nr8a66597_write(r8a66597, val, PIPECFG);\r\nr8a66597_write(r8a66597, (info->buf_bsize << 10) | (info->bufnum),\r\nPIPEBUF);\r\nr8a66597_write(r8a66597, make_devsel(info->address) | info->maxpacket,\r\nPIPEMAXP);\r\nr8a66597_write(r8a66597, info->interval, PIPEPERI);\r\n}\r\nstatic void pipe_setting(struct r8a66597 *r8a66597, struct r8a66597_td *td)\r\n{\r\nstruct r8a66597_pipe_info *info;\r\nstruct urb *urb = td->urb;\r\nif (td->pipenum > 0) {\r\ninfo = &td->pipe->info;\r\ncfifo_change(r8a66597, 0);\r\npipe_buffer_setting(r8a66597, info);\r\nif (!usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe)) &&\r\n!usb_pipecontrol(urb->pipe)) {\r\nr8a66597_pipe_toggle(r8a66597, td->pipe, 0);\r\npipe_toggle_set(r8a66597, td->pipe, urb, 0);\r\nclear_all_buffer(r8a66597, td->pipe);\r\nusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe), 1);\r\n}\r\npipe_toggle_restore(r8a66597, td->pipe, urb);\r\n}\r\n}\r\nstatic u16 get_empty_pipenum(struct r8a66597 *r8a66597,\r\nstruct usb_endpoint_descriptor *ep)\r\n{\r\nu16 array[R8A66597_MAX_NUM_PIPE], i = 0, min;\r\nmemset(array, 0, sizeof(array));\r\nswitch (usb_endpoint_type(ep)) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (usb_endpoint_dir_in(ep))\r\narray[i++] = 4;\r\nelse {\r\narray[i++] = 3;\r\narray[i++] = 5;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (usb_endpoint_dir_in(ep)) {\r\narray[i++] = 6;\r\narray[i++] = 7;\r\narray[i++] = 8;\r\n} else\r\narray[i++] = 9;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (usb_endpoint_dir_in(ep))\r\narray[i++] = 2;\r\nelse\r\narray[i++] = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "r8a66597: Illegal type\n");\r\nreturn 0;\r\n}\r\ni = 1;\r\nmin = array[0];\r\nwhile (array[i] != 0) {\r\nif (r8a66597->pipe_cnt[min] > r8a66597->pipe_cnt[array[i]])\r\nmin = array[i];\r\ni++;\r\n}\r\nreturn min;\r\n}\r\nstatic u16 get_r8a66597_type(__u8 type)\r\n{\r\nu16 r8a66597_type;\r\nswitch (type) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nr8a66597_type = R8A66597_BULK;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nr8a66597_type = R8A66597_INT;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nr8a66597_type = R8A66597_ISO;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "r8a66597: Illegal type\n");\r\nr8a66597_type = 0x0000;\r\nbreak;\r\n}\r\nreturn r8a66597_type;\r\n}\r\nstatic u16 get_bufnum(u16 pipenum)\r\n{\r\nu16 bufnum = 0;\r\nif (pipenum == 0)\r\nbufnum = 0;\r\nelse if (check_bulk_or_isoc(pipenum))\r\nbufnum = 8 + (pipenum - 1) * R8A66597_BUF_BSIZE*2;\r\nelse if (check_interrupt(pipenum))\r\nbufnum = 4 + (pipenum - 6);\r\nelse\r\nprintk(KERN_ERR "r8a66597: Illegal pipenum (%d)\n", pipenum);\r\nreturn bufnum;\r\n}\r\nstatic u16 get_buf_bsize(u16 pipenum)\r\n{\r\nu16 buf_bsize = 0;\r\nif (pipenum == 0)\r\nbuf_bsize = 3;\r\nelse if (check_bulk_or_isoc(pipenum))\r\nbuf_bsize = R8A66597_BUF_BSIZE - 1;\r\nelse if (check_interrupt(pipenum))\r\nbuf_bsize = 0;\r\nelse\r\nprintk(KERN_ERR "r8a66597: Illegal pipenum (%d)\n", pipenum);\r\nreturn buf_bsize;\r\n}\r\nstatic void enable_r8a66597_pipe_dma(struct r8a66597 *r8a66597,\r\nstruct r8a66597_device *dev,\r\nstruct r8a66597_pipe *pipe,\r\nstruct urb *urb)\r\n{\r\nint i;\r\nstruct r8a66597_pipe_info *info = &pipe->info;\r\nunsigned short mbw = mbw_value(r8a66597);\r\nif (r8a66597->pdata->on_chip)\r\nreturn;\r\nif ((pipe->info.pipenum != 0) && (info->type != R8A66597_INT)) {\r\nfor (i = 0; i < R8A66597_MAX_DMA_CHANNEL; i++) {\r\nif ((r8a66597->dma_map & (1 << i)) != 0)\r\ncontinue;\r\ndev_info(&dev->udev->dev,\r\n"address %d, EndpointAddress 0x%02x use "\r\n"DMA FIFO\n", usb_pipedevice(urb->pipe),\r\ninfo->dir_in ?\r\nUSB_ENDPOINT_DIR_MASK + info->epnum\r\n: info->epnum);\r\nr8a66597->dma_map |= 1 << i;\r\ndev->dma_map |= 1 << i;\r\nset_pipe_reg_addr(pipe, i);\r\ncfifo_change(r8a66597, 0);\r\nr8a66597_mdfy(r8a66597, mbw | pipe->info.pipenum,\r\nmbw | CURPIPE, pipe->fifosel);\r\nr8a66597_reg_wait(r8a66597, pipe->fifosel, CURPIPE,\r\npipe->info.pipenum);\r\nr8a66597_bset(r8a66597, BCLR, pipe->fifoctr);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void enable_r8a66597_pipe(struct r8a66597 *r8a66597, struct urb *urb,\r\nstruct usb_host_endpoint *hep,\r\nstruct r8a66597_pipe_info *info)\r\n{\r\nstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\r\nstruct r8a66597_pipe *pipe = hep->hcpriv;\r\ndev_dbg(&dev->udev->dev, "enable_pipe:\n");\r\npipe->info = *info;\r\nset_pipe_reg_addr(pipe, R8A66597_PIPE_NO_DMA);\r\nr8a66597->pipe_cnt[pipe->info.pipenum]++;\r\ndev->pipe_cnt[pipe->info.pipenum]++;\r\nenable_r8a66597_pipe_dma(r8a66597, dev, pipe, urb);\r\n}\r\nstatic void r8a66597_urb_done(struct r8a66597 *r8a66597, struct urb *urb,\r\nint status)\r\n__releases(r8a66597->lock)\r\n__acquires(r8a66597->lock)\r\n{\r\nif (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {\r\nvoid *ptr;\r\nfor (ptr = urb->transfer_buffer;\r\nptr < urb->transfer_buffer + urb->transfer_buffer_length;\r\nptr += PAGE_SIZE)\r\nflush_dcache_page(virt_to_page(ptr));\r\n}\r\nusb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);\r\nspin_unlock(&r8a66597->lock);\r\nusb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb, status);\r\nspin_lock(&r8a66597->lock);\r\n}\r\nstatic void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)\r\n{\r\nstruct r8a66597_td *td, *next;\r\nstruct urb *urb;\r\nstruct list_head *list = &r8a66597->pipe_queue[pipenum];\r\nif (list_empty(list))\r\nreturn;\r\nlist_for_each_entry_safe(td, next, list, queue) {\r\nif (td->address != address)\r\ncontinue;\r\nurb = td->urb;\r\nlist_del(&td->queue);\r\nkfree(td);\r\nif (urb)\r\nr8a66597_urb_done(r8a66597, urb, -ENODEV);\r\nbreak;\r\n}\r\n}\r\nstatic void disable_r8a66597_pipe_all(struct r8a66597 *r8a66597,\r\nstruct r8a66597_device *dev)\r\n{\r\nint check_ep0 = 0;\r\nu16 pipenum;\r\nif (!dev)\r\nreturn;\r\nfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\r\nif (!dev->pipe_cnt[pipenum])\r\ncontinue;\r\nif (!check_ep0) {\r\ncheck_ep0 = 1;\r\nforce_dequeue(r8a66597, 0, dev->address);\r\n}\r\nr8a66597->pipe_cnt[pipenum] -= dev->pipe_cnt[pipenum];\r\ndev->pipe_cnt[pipenum] = 0;\r\nforce_dequeue(r8a66597, pipenum, dev->address);\r\n}\r\ndev_dbg(&dev->udev->dev, "disable_pipe\n");\r\nr8a66597->dma_map &= ~(dev->dma_map);\r\ndev->dma_map = 0;\r\n}\r\nstatic u16 get_interval(struct urb *urb, __u8 interval)\r\n{\r\nu16 time = 1;\r\nint i;\r\nif (urb->dev->speed == USB_SPEED_HIGH) {\r\nif (interval > IITV)\r\ntime = IITV;\r\nelse\r\ntime = interval ? interval - 1 : 0;\r\n} else {\r\nif (interval > 128) {\r\ntime = IITV;\r\n} else {\r\nfor (i = 0; i < 7; i++) {\r\nif ((1 << i) < interval &&\r\n(1 << (i + 1) > interval))\r\ntime = 1 << i;\r\n}\r\n}\r\n}\r\nreturn time;\r\n}\r\nstatic unsigned long get_timer_interval(struct urb *urb, __u8 interval)\r\n{\r\n__u8 i;\r\nunsigned long time = 1;\r\nif (usb_pipeisoc(urb->pipe))\r\nreturn 0;\r\nif (get_r8a66597_usb_speed(urb->dev->speed) == HSMODE) {\r\nfor (i = 0; i < (interval - 1); i++)\r\ntime *= 2;\r\ntime = time * 125 / 1000;\r\n} else {\r\ntime = interval;\r\n}\r\nreturn time;\r\n}\r\nstatic void init_pipe_info(struct r8a66597 *r8a66597, struct urb *urb,\r\nstruct usb_host_endpoint *hep,\r\nstruct usb_endpoint_descriptor *ep)\r\n{\r\nstruct r8a66597_pipe_info info;\r\ninfo.pipenum = get_empty_pipenum(r8a66597, ep);\r\ninfo.address = get_urb_to_r8a66597_addr(r8a66597, urb);\r\ninfo.epnum = usb_endpoint_num(ep);\r\ninfo.maxpacket = usb_endpoint_maxp(ep);\r\ninfo.type = get_r8a66597_type(usb_endpoint_type(ep));\r\ninfo.bufnum = get_bufnum(info.pipenum);\r\ninfo.buf_bsize = get_buf_bsize(info.pipenum);\r\nif (info.type == R8A66597_BULK) {\r\ninfo.interval = 0;\r\ninfo.timer_interval = 0;\r\n} else {\r\ninfo.interval = get_interval(urb, ep->bInterval);\r\ninfo.timer_interval = get_timer_interval(urb, ep->bInterval);\r\n}\r\nif (usb_endpoint_dir_in(ep))\r\ninfo.dir_in = 1;\r\nelse\r\ninfo.dir_in = 0;\r\nenable_r8a66597_pipe(r8a66597, urb, hep, &info);\r\n}\r\nstatic void init_pipe_config(struct r8a66597 *r8a66597, struct urb *urb)\r\n{\r\nstruct r8a66597_device *dev;\r\ndev = get_urb_to_r8a66597_dev(r8a66597, urb);\r\ndev->state = USB_STATE_CONFIGURED;\r\n}\r\nstatic void pipe_irq_enable(struct r8a66597 *r8a66597, struct urb *urb,\r\nu16 pipenum)\r\n{\r\nif (pipenum == 0 && usb_pipeout(urb->pipe))\r\nenable_irq_empty(r8a66597, pipenum);\r\nelse\r\nenable_irq_ready(r8a66597, pipenum);\r\nif (!usb_pipeisoc(urb->pipe))\r\nenable_irq_nrdy(r8a66597, pipenum);\r\n}\r\nstatic void pipe_irq_disable(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\ndisable_irq_ready(r8a66597, pipenum);\r\ndisable_irq_nrdy(r8a66597, pipenum);\r\n}\r\nstatic void r8a66597_root_hub_start_polling(struct r8a66597 *r8a66597)\r\n{\r\nmod_timer(&r8a66597->rh_timer,\r\njiffies + msecs_to_jiffies(R8A66597_RH_POLL_TIME));\r\n}\r\nstatic void start_root_hub_sampling(struct r8a66597 *r8a66597, int port,\r\nint connect)\r\n{\r\nstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\r\nrh->old_syssts = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;\r\nrh->scount = R8A66597_MAX_SAMPLING;\r\nif (connect)\r\nrh->port |= USB_PORT_STAT_CONNECTION;\r\nelse\r\nrh->port &= ~USB_PORT_STAT_CONNECTION;\r\nrh->port |= USB_PORT_STAT_C_CONNECTION << 16;\r\nr8a66597_root_hub_start_polling(r8a66597);\r\n}\r\nstatic void r8a66597_check_syssts(struct r8a66597 *r8a66597, int port,\r\nu16 syssts)\r\n__releases(r8a66597->lock)\r\n__acquires(r8a66597->lock)\r\n{\r\nif (syssts == SE0) {\r\nr8a66597_write(r8a66597, ~ATTCH, get_intsts_reg(port));\r\nr8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));\r\n} else {\r\nif (syssts == FS_JSTS)\r\nr8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));\r\nelse if (syssts == LS_JSTS)\r\nr8a66597_bclr(r8a66597, HSE, get_syscfg_reg(port));\r\nr8a66597_write(r8a66597, ~DTCH, get_intsts_reg(port));\r\nr8a66597_bset(r8a66597, DTCHE, get_intenb_reg(port));\r\nif (r8a66597->bus_suspended)\r\nusb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));\r\n}\r\nspin_unlock(&r8a66597->lock);\r\nusb_hcd_poll_rh_status(r8a66597_to_hcd(r8a66597));\r\nspin_lock(&r8a66597->lock);\r\n}\r\nstatic void r8a66597_usb_connect(struct r8a66597 *r8a66597, int port)\r\n{\r\nu16 speed = get_rh_usb_speed(r8a66597, port);\r\nstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\r\nrh->port &= ~(USB_PORT_STAT_HIGH_SPEED | USB_PORT_STAT_LOW_SPEED);\r\nif (speed == HSMODE)\r\nrh->port |= USB_PORT_STAT_HIGH_SPEED;\r\nelse if (speed == LSMODE)\r\nrh->port |= USB_PORT_STAT_LOW_SPEED;\r\nrh->port &= ~USB_PORT_STAT_RESET;\r\nrh->port |= USB_PORT_STAT_ENABLE;\r\n}\r\nstatic void r8a66597_usb_disconnect(struct r8a66597 *r8a66597, int port)\r\n{\r\nstruct r8a66597_device *dev = r8a66597->root_hub[port].dev;\r\ndisable_r8a66597_pipe_all(r8a66597, dev);\r\nfree_usb_address(r8a66597, dev, 0);\r\nstart_root_hub_sampling(r8a66597, port, 0);\r\n}\r\nstatic void prepare_setup_packet(struct r8a66597 *r8a66597,\r\nstruct r8a66597_td *td)\r\n{\r\nint i;\r\n__le16 *p = (__le16 *)td->urb->setup_packet;\r\nunsigned long setup_addr = USBREQ;\r\nr8a66597_write(r8a66597, make_devsel(td->address) | td->maxpacket,\r\nDCPMAXP);\r\nr8a66597_write(r8a66597, ~(SIGN | SACK), INTSTS1);\r\nfor (i = 0; i < 4; i++) {\r\nr8a66597_write(r8a66597, le16_to_cpu(p[i]), setup_addr);\r\nsetup_addr += 2;\r\n}\r\nr8a66597_write(r8a66597, SUREQ, DCPCTR);\r\n}\r\nstatic void prepare_packet_read(struct r8a66597 *r8a66597,\r\nstruct r8a66597_td *td)\r\n{\r\nstruct urb *urb = td->urb;\r\nif (usb_pipecontrol(urb->pipe)) {\r\nr8a66597_bclr(r8a66597, R8A66597_DIR, DCPCFG);\r\nr8a66597_mdfy(r8a66597, 0, ISEL | CURPIPE, CFIFOSEL);\r\nr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);\r\nif (urb->actual_length == 0) {\r\nr8a66597_pipe_toggle(r8a66597, td->pipe, 1);\r\nr8a66597_write(r8a66597, BCLR, CFIFOCTR);\r\n}\r\npipe_irq_disable(r8a66597, td->pipenum);\r\npipe_start(r8a66597, td->pipe);\r\npipe_irq_enable(r8a66597, urb, td->pipenum);\r\n} else {\r\nif (urb->actual_length == 0) {\r\npipe_irq_disable(r8a66597, td->pipenum);\r\npipe_setting(r8a66597, td);\r\npipe_stop(r8a66597, td->pipe);\r\nr8a66597_write(r8a66597, ~(1 << td->pipenum), BRDYSTS);\r\nif (td->pipe->pipetre) {\r\nr8a66597_write(r8a66597, TRCLR,\r\ntd->pipe->pipetre);\r\nr8a66597_write(r8a66597,\r\nDIV_ROUND_UP\r\n(urb->transfer_buffer_length,\r\ntd->maxpacket),\r\ntd->pipe->pipetrn);\r\nr8a66597_bset(r8a66597, TRENB,\r\ntd->pipe->pipetre);\r\n}\r\npipe_start(r8a66597, td->pipe);\r\npipe_irq_enable(r8a66597, urb, td->pipenum);\r\n}\r\n}\r\n}\r\nstatic void prepare_packet_write(struct r8a66597 *r8a66597,\r\nstruct r8a66597_td *td)\r\n{\r\nu16 tmp;\r\nstruct urb *urb = td->urb;\r\nif (usb_pipecontrol(urb->pipe)) {\r\npipe_stop(r8a66597, td->pipe);\r\nr8a66597_bset(r8a66597, R8A66597_DIR, DCPCFG);\r\nr8a66597_mdfy(r8a66597, ISEL, ISEL | CURPIPE, CFIFOSEL);\r\nr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);\r\nif (urb->actual_length == 0) {\r\nr8a66597_pipe_toggle(r8a66597, td->pipe, 1);\r\nr8a66597_write(r8a66597, BCLR, CFIFOCTR);\r\n}\r\n} else {\r\nif (urb->actual_length == 0)\r\npipe_setting(r8a66597, td);\r\nif (td->pipe->pipetre)\r\nr8a66597_bclr(r8a66597, TRENB, td->pipe->pipetre);\r\n}\r\nr8a66597_write(r8a66597, ~(1 << td->pipenum), BRDYSTS);\r\nfifo_change_from_pipe(r8a66597, td->pipe);\r\ntmp = r8a66597_read(r8a66597, td->pipe->fifoctr);\r\nif (unlikely((tmp & FRDY) == 0))\r\npipe_irq_enable(r8a66597, urb, td->pipenum);\r\nelse\r\npacket_write(r8a66597, td->pipenum);\r\npipe_start(r8a66597, td->pipe);\r\n}\r\nstatic void prepare_status_packet(struct r8a66597 *r8a66597,\r\nstruct r8a66597_td *td)\r\n{\r\nstruct urb *urb = td->urb;\r\nr8a66597_pipe_toggle(r8a66597, td->pipe, 1);\r\npipe_stop(r8a66597, td->pipe);\r\nif (urb->setup_packet[0] & USB_ENDPOINT_DIR_MASK) {\r\nr8a66597_bset(r8a66597, R8A66597_DIR, DCPCFG);\r\nr8a66597_mdfy(r8a66597, ISEL, ISEL | CURPIPE, CFIFOSEL);\r\nr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);\r\nr8a66597_write(r8a66597, ~BEMP0, BEMPSTS);\r\nr8a66597_write(r8a66597, BCLR | BVAL, CFIFOCTR);\r\nenable_irq_empty(r8a66597, 0);\r\n} else {\r\nr8a66597_bclr(r8a66597, R8A66597_DIR, DCPCFG);\r\nr8a66597_mdfy(r8a66597, 0, ISEL | CURPIPE, CFIFOSEL);\r\nr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);\r\nr8a66597_write(r8a66597, BCLR, CFIFOCTR);\r\nenable_irq_ready(r8a66597, 0);\r\n}\r\nenable_irq_nrdy(r8a66597, 0);\r\npipe_start(r8a66597, td->pipe);\r\n}\r\nstatic int is_set_address(unsigned char *setup_packet)\r\n{\r\nif (((setup_packet[0] & USB_TYPE_MASK) == USB_TYPE_STANDARD) &&\r\nsetup_packet[1] == USB_REQ_SET_ADDRESS)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int start_transfer(struct r8a66597 *r8a66597, struct r8a66597_td *td)\r\n{\r\nBUG_ON(!td);\r\nswitch (td->type) {\r\ncase USB_PID_SETUP:\r\nif (is_set_address(td->urb->setup_packet)) {\r\ntd->set_address = 1;\r\ntd->urb->setup_packet[2] = alloc_usb_address(r8a66597,\r\ntd->urb);\r\nif (td->urb->setup_packet[2] == 0)\r\nreturn -EPIPE;\r\n}\r\nprepare_setup_packet(r8a66597, td);\r\nbreak;\r\ncase USB_PID_IN:\r\nprepare_packet_read(r8a66597, td);\r\nbreak;\r\ncase USB_PID_OUT:\r\nprepare_packet_write(r8a66597, td);\r\nbreak;\r\ncase USB_PID_ACK:\r\nprepare_status_packet(r8a66597, td);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "r8a66597: invalid type.\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_transfer_finish(struct r8a66597_td *td, struct urb *urb)\r\n{\r\nif (usb_pipeisoc(urb->pipe)) {\r\nif (urb->number_of_packets == td->iso_cnt)\r\nreturn 1;\r\n}\r\nif ((urb->transfer_buffer_length <= urb->actual_length) ||\r\n(td->short_packet) || (td->zero_packet))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)\r\n{\r\nunsigned long time;\r\nBUG_ON(!td);\r\nif (!list_empty(&r8a66597->pipe_queue[td->pipenum]) &&\r\n!usb_pipecontrol(td->urb->pipe) && usb_pipein(td->urb->pipe)) {\r\nr8a66597->timeout_map |= 1 << td->pipenum;\r\nswitch (usb_pipetype(td->urb->pipe)) {\r\ncase PIPE_INTERRUPT:\r\ncase PIPE_ISOCHRONOUS:\r\ntime = 30;\r\nbreak;\r\ndefault:\r\ntime = 300;\r\nbreak;\r\n}\r\nmod_timer(&r8a66597->td_timer[td->pipenum],\r\njiffies + msecs_to_jiffies(time));\r\n}\r\n}\r\nstatic void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,\r\nu16 pipenum, struct urb *urb, int status)\r\n__releases(r8a66597->lock) __acquires(r8a66597->lock)\r\n{\r\nint restart = 0;\r\nstruct usb_hcd *hcd = r8a66597_to_hcd(r8a66597);\r\nr8a66597->timeout_map &= ~(1 << pipenum);\r\nif (likely(td)) {\r\nif (td->set_address && (status != 0 || urb->unlinked))\r\nr8a66597->address_map &= ~(1 << urb->setup_packet[2]);\r\npipe_toggle_save(r8a66597, td->pipe, urb);\r\nlist_del(&td->queue);\r\nkfree(td);\r\n}\r\nif (!list_empty(&r8a66597->pipe_queue[pipenum]))\r\nrestart = 1;\r\nif (likely(urb)) {\r\nif (usb_pipeisoc(urb->pipe))\r\nurb->start_frame = r8a66597_get_frame(hcd);\r\nr8a66597_urb_done(r8a66597, urb, status);\r\n}\r\nif (restart) {\r\ntd = r8a66597_get_td(r8a66597, pipenum);\r\nif (unlikely(!td))\r\nreturn;\r\nstart_transfer(r8a66597, td);\r\nset_td_timer(r8a66597, td);\r\n}\r\n}\r\nstatic void packet_read(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nu16 tmp;\r\nint rcv_len, bufsize, urb_len, size;\r\nu16 *buf;\r\nstruct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);\r\nstruct urb *urb;\r\nint finish = 0;\r\nint status = 0;\r\nif (unlikely(!td))\r\nreturn;\r\nurb = td->urb;\r\nfifo_change_from_pipe(r8a66597, td->pipe);\r\ntmp = r8a66597_read(r8a66597, td->pipe->fifoctr);\r\nif (unlikely((tmp & FRDY) == 0)) {\r\npipe_stop(r8a66597, td->pipe);\r\npipe_irq_disable(r8a66597, pipenum);\r\nprintk(KERN_ERR "r8a66597: in fifo not ready (%d)\n", pipenum);\r\nfinish_request(r8a66597, td, pipenum, td->urb, -EPIPE);\r\nreturn;\r\n}\r\nrcv_len = tmp & DTLN;\r\nif (usb_pipeisoc(urb->pipe)) {\r\nbuf = (u16 *)(urb->transfer_buffer +\r\nurb->iso_frame_desc[td->iso_cnt].offset);\r\nurb_len = urb->iso_frame_desc[td->iso_cnt].length;\r\n} else {\r\nbuf = (void *)urb->transfer_buffer + urb->actual_length;\r\nurb_len = urb->transfer_buffer_length - urb->actual_length;\r\n}\r\nbufsize = min(urb_len, (int) td->maxpacket);\r\nif (rcv_len <= bufsize) {\r\nsize = rcv_len;\r\n} else {\r\nsize = bufsize;\r\nstatus = -EOVERFLOW;\r\nfinish = 1;\r\n}\r\nurb->actual_length += size;\r\nif (rcv_len == 0)\r\ntd->zero_packet = 1;\r\nif (rcv_len < bufsize) {\r\ntd->short_packet = 1;\r\n}\r\nif (usb_pipeisoc(urb->pipe)) {\r\nurb->iso_frame_desc[td->iso_cnt].actual_length = size;\r\nurb->iso_frame_desc[td->iso_cnt].status = status;\r\ntd->iso_cnt++;\r\nfinish = 0;\r\n}\r\nif (finish || check_transfer_finish(td, urb)) {\r\npipe_stop(r8a66597, td->pipe);\r\npipe_irq_disable(r8a66597, pipenum);\r\nfinish = 1;\r\n}\r\nif (urb->transfer_buffer) {\r\nif (size == 0)\r\nr8a66597_write(r8a66597, BCLR, td->pipe->fifoctr);\r\nelse\r\nr8a66597_read_fifo(r8a66597, td->pipe->fifoaddr,\r\nbuf, size);\r\n}\r\nif (finish && pipenum != 0)\r\nfinish_request(r8a66597, td, pipenum, urb, status);\r\n}\r\nstatic void packet_write(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nu16 tmp;\r\nint bufsize, size;\r\nu16 *buf;\r\nstruct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);\r\nstruct urb *urb;\r\nif (unlikely(!td))\r\nreturn;\r\nurb = td->urb;\r\nfifo_change_from_pipe(r8a66597, td->pipe);\r\ntmp = r8a66597_read(r8a66597, td->pipe->fifoctr);\r\nif (unlikely((tmp & FRDY) == 0)) {\r\npipe_stop(r8a66597, td->pipe);\r\npipe_irq_disable(r8a66597, pipenum);\r\nprintk(KERN_ERR "r8a66597: out fifo not ready (%d)\n", pipenum);\r\nfinish_request(r8a66597, td, pipenum, urb, -EPIPE);\r\nreturn;\r\n}\r\nbufsize = td->maxpacket;\r\nif (usb_pipeisoc(urb->pipe)) {\r\nbuf = (u16 *)(urb->transfer_buffer +\r\nurb->iso_frame_desc[td->iso_cnt].offset);\r\nsize = min(bufsize,\r\n(int)urb->iso_frame_desc[td->iso_cnt].length);\r\n} else {\r\nbuf = (u16 *)(urb->transfer_buffer + urb->actual_length);\r\nsize = min_t(u32, bufsize,\r\nurb->transfer_buffer_length - urb->actual_length);\r\n}\r\nif (pipenum > 0)\r\nr8a66597_write(r8a66597, ~(1 << pipenum), BEMPSTS);\r\nif (urb->transfer_buffer) {\r\nr8a66597_write_fifo(r8a66597, td->pipe, buf, size);\r\nif (!usb_pipebulk(urb->pipe) || td->maxpacket != size)\r\nr8a66597_write(r8a66597, BVAL, td->pipe->fifoctr);\r\n}\r\nurb->actual_length += size;\r\nif (usb_pipeisoc(urb->pipe)) {\r\nurb->iso_frame_desc[td->iso_cnt].actual_length = size;\r\nurb->iso_frame_desc[td->iso_cnt].status = 0;\r\ntd->iso_cnt++;\r\n}\r\nif (check_transfer_finish(td, urb)) {\r\ndisable_irq_ready(r8a66597, pipenum);\r\nenable_irq_empty(r8a66597, pipenum);\r\nif (!usb_pipeisoc(urb->pipe))\r\nenable_irq_nrdy(r8a66597, pipenum);\r\n} else\r\npipe_irq_enable(r8a66597, urb, pipenum);\r\n}\r\nstatic void check_next_phase(struct r8a66597 *r8a66597, int status)\r\n{\r\nstruct r8a66597_td *td = r8a66597_get_td(r8a66597, 0);\r\nstruct urb *urb;\r\nu8 finish = 0;\r\nif (unlikely(!td))\r\nreturn;\r\nurb = td->urb;\r\nswitch (td->type) {\r\ncase USB_PID_IN:\r\ncase USB_PID_OUT:\r\nif (check_transfer_finish(td, urb))\r\ntd->type = USB_PID_ACK;\r\nbreak;\r\ncase USB_PID_SETUP:\r\nif (urb->transfer_buffer_length == urb->actual_length)\r\ntd->type = USB_PID_ACK;\r\nelse if (usb_pipeout(urb->pipe))\r\ntd->type = USB_PID_OUT;\r\nelse\r\ntd->type = USB_PID_IN;\r\nbreak;\r\ncase USB_PID_ACK:\r\nfinish = 1;\r\nbreak;\r\n}\r\nif (finish || status != 0 || urb->unlinked)\r\nfinish_request(r8a66597, td, 0, urb, status);\r\nelse\r\nstart_transfer(r8a66597, td);\r\n}\r\nstatic int get_urb_error(struct r8a66597 *r8a66597, u16 pipenum)\r\n{\r\nstruct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);\r\nif (td) {\r\nu16 pid = r8a66597_read(r8a66597, td->pipe->pipectr) & PID;\r\nif (pid == PID_NAK)\r\nreturn -ECONNRESET;\r\nelse\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void irq_pipe_ready(struct r8a66597 *r8a66597)\r\n{\r\nu16 check;\r\nu16 pipenum;\r\nu16 mask;\r\nstruct r8a66597_td *td;\r\nmask = r8a66597_read(r8a66597, BRDYSTS)\r\n& r8a66597_read(r8a66597, BRDYENB);\r\nr8a66597_write(r8a66597, ~mask, BRDYSTS);\r\nif (mask & BRDY0) {\r\ntd = r8a66597_get_td(r8a66597, 0);\r\nif (td && td->type == USB_PID_IN)\r\npacket_read(r8a66597, 0);\r\nelse\r\npipe_irq_disable(r8a66597, 0);\r\ncheck_next_phase(r8a66597, 0);\r\n}\r\nfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\r\ncheck = 1 << pipenum;\r\nif (mask & check) {\r\ntd = r8a66597_get_td(r8a66597, pipenum);\r\nif (unlikely(!td))\r\ncontinue;\r\nif (td->type == USB_PID_IN)\r\npacket_read(r8a66597, pipenum);\r\nelse if (td->type == USB_PID_OUT)\r\npacket_write(r8a66597, pipenum);\r\n}\r\n}\r\n}\r\nstatic void irq_pipe_empty(struct r8a66597 *r8a66597)\r\n{\r\nu16 tmp;\r\nu16 check;\r\nu16 pipenum;\r\nu16 mask;\r\nstruct r8a66597_td *td;\r\nmask = r8a66597_read(r8a66597, BEMPSTS)\r\n& r8a66597_read(r8a66597, BEMPENB);\r\nr8a66597_write(r8a66597, ~mask, BEMPSTS);\r\nif (mask & BEMP0) {\r\ncfifo_change(r8a66597, 0);\r\ntd = r8a66597_get_td(r8a66597, 0);\r\nif (td && td->type != USB_PID_OUT)\r\ndisable_irq_empty(r8a66597, 0);\r\ncheck_next_phase(r8a66597, 0);\r\n}\r\nfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\r\ncheck = 1 << pipenum;\r\nif (mask & check) {\r\nstruct r8a66597_td *td;\r\ntd = r8a66597_get_td(r8a66597, pipenum);\r\nif (unlikely(!td))\r\ncontinue;\r\ntmp = r8a66597_read(r8a66597, td->pipe->pipectr);\r\nif ((tmp & INBUFM) == 0) {\r\ndisable_irq_empty(r8a66597, pipenum);\r\npipe_irq_disable(r8a66597, pipenum);\r\nfinish_request(r8a66597, td, pipenum, td->urb,\r\n0);\r\n}\r\n}\r\n}\r\n}\r\nstatic void irq_pipe_nrdy(struct r8a66597 *r8a66597)\r\n{\r\nu16 check;\r\nu16 pipenum;\r\nu16 mask;\r\nint status;\r\nmask = r8a66597_read(r8a66597, NRDYSTS)\r\n& r8a66597_read(r8a66597, NRDYENB);\r\nr8a66597_write(r8a66597, ~mask, NRDYSTS);\r\nif (mask & NRDY0) {\r\ncfifo_change(r8a66597, 0);\r\nstatus = get_urb_error(r8a66597, 0);\r\npipe_irq_disable(r8a66597, 0);\r\ncheck_next_phase(r8a66597, status);\r\n}\r\nfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\r\ncheck = 1 << pipenum;\r\nif (mask & check) {\r\nstruct r8a66597_td *td;\r\ntd = r8a66597_get_td(r8a66597, pipenum);\r\nif (unlikely(!td))\r\ncontinue;\r\nstatus = get_urb_error(r8a66597, pipenum);\r\npipe_irq_disable(r8a66597, pipenum);\r\npipe_stop(r8a66597, td->pipe);\r\nfinish_request(r8a66597, td, pipenum, td->urb, status);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t r8a66597_irq(struct usb_hcd *hcd)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nu16 intsts0, intsts1, intsts2;\r\nu16 intenb0, intenb1, intenb2;\r\nu16 mask0, mask1, mask2;\r\nint status;\r\nspin_lock(&r8a66597->lock);\r\nintsts0 = r8a66597_read(r8a66597, INTSTS0);\r\nintsts1 = r8a66597_read(r8a66597, INTSTS1);\r\nintsts2 = r8a66597_read(r8a66597, INTSTS2);\r\nintenb0 = r8a66597_read(r8a66597, INTENB0);\r\nintenb1 = r8a66597_read(r8a66597, INTENB1);\r\nintenb2 = r8a66597_read(r8a66597, INTENB2);\r\nmask2 = intsts2 & intenb2;\r\nmask1 = intsts1 & intenb1;\r\nmask0 = intsts0 & intenb0 & (BEMP | NRDY | BRDY);\r\nif (mask2) {\r\nif (mask2 & ATTCH) {\r\nr8a66597_write(r8a66597, ~ATTCH, INTSTS2);\r\nr8a66597_bclr(r8a66597, ATTCHE, INTENB2);\r\nstart_root_hub_sampling(r8a66597, 1, 1);\r\n}\r\nif (mask2 & DTCH) {\r\nr8a66597_write(r8a66597, ~DTCH, INTSTS2);\r\nr8a66597_bclr(r8a66597, DTCHE, INTENB2);\r\nr8a66597_usb_disconnect(r8a66597, 1);\r\n}\r\nif (mask2 & BCHG) {\r\nr8a66597_write(r8a66597, ~BCHG, INTSTS2);\r\nr8a66597_bclr(r8a66597, BCHGE, INTENB2);\r\nusb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));\r\n}\r\n}\r\nif (mask1) {\r\nif (mask1 & ATTCH) {\r\nr8a66597_write(r8a66597, ~ATTCH, INTSTS1);\r\nr8a66597_bclr(r8a66597, ATTCHE, INTENB1);\r\nstart_root_hub_sampling(r8a66597, 0, 1);\r\n}\r\nif (mask1 & DTCH) {\r\nr8a66597_write(r8a66597, ~DTCH, INTSTS1);\r\nr8a66597_bclr(r8a66597, DTCHE, INTENB1);\r\nr8a66597_usb_disconnect(r8a66597, 0);\r\n}\r\nif (mask1 & BCHG) {\r\nr8a66597_write(r8a66597, ~BCHG, INTSTS1);\r\nr8a66597_bclr(r8a66597, BCHGE, INTENB1);\r\nusb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));\r\n}\r\nif (mask1 & SIGN) {\r\nr8a66597_write(r8a66597, ~SIGN, INTSTS1);\r\nstatus = get_urb_error(r8a66597, 0);\r\ncheck_next_phase(r8a66597, status);\r\n}\r\nif (mask1 & SACK) {\r\nr8a66597_write(r8a66597, ~SACK, INTSTS1);\r\ncheck_next_phase(r8a66597, 0);\r\n}\r\n}\r\nif (mask0) {\r\nif (mask0 & BRDY)\r\nirq_pipe_ready(r8a66597);\r\nif (mask0 & BEMP)\r\nirq_pipe_empty(r8a66597);\r\nif (mask0 & NRDY)\r\nirq_pipe_nrdy(r8a66597);\r\n}\r\nspin_unlock(&r8a66597->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void r8a66597_root_hub_control(struct r8a66597 *r8a66597, int port)\r\n{\r\nu16 tmp;\r\nstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\r\nif (rh->port & USB_PORT_STAT_RESET) {\r\nunsigned long dvstctr_reg = get_dvstctr_reg(port);\r\ntmp = r8a66597_read(r8a66597, dvstctr_reg);\r\nif ((tmp & USBRST) == USBRST) {\r\nr8a66597_mdfy(r8a66597, UACT, USBRST | UACT,\r\ndvstctr_reg);\r\nr8a66597_root_hub_start_polling(r8a66597);\r\n} else\r\nr8a66597_usb_connect(r8a66597, port);\r\n}\r\nif (!(rh->port & USB_PORT_STAT_CONNECTION)) {\r\nr8a66597_write(r8a66597, ~ATTCH, get_intsts_reg(port));\r\nr8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));\r\n}\r\nif (rh->scount > 0) {\r\ntmp = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;\r\nif (tmp == rh->old_syssts) {\r\nrh->scount--;\r\nif (rh->scount == 0)\r\nr8a66597_check_syssts(r8a66597, port, tmp);\r\nelse\r\nr8a66597_root_hub_start_polling(r8a66597);\r\n} else {\r\nrh->scount = R8A66597_MAX_SAMPLING;\r\nrh->old_syssts = tmp;\r\nr8a66597_root_hub_start_polling(r8a66597);\r\n}\r\n}\r\n}\r\nstatic void r8a66597_interval_timer(unsigned long _r8a66597)\r\n{\r\nstruct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;\r\nunsigned long flags;\r\nu16 pipenum;\r\nstruct r8a66597_td *td;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\nfor (pipenum = 0; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\r\nif (!(r8a66597->interval_map & (1 << pipenum)))\r\ncontinue;\r\nif (timer_pending(&r8a66597->interval_timer[pipenum]))\r\ncontinue;\r\ntd = r8a66597_get_td(r8a66597, pipenum);\r\nif (td)\r\nstart_transfer(r8a66597, td);\r\n}\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\n}\r\nstatic void r8a66597_td_timer(unsigned long _r8a66597)\r\n{\r\nstruct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;\r\nunsigned long flags;\r\nu16 pipenum;\r\nstruct r8a66597_td *td, *new_td = NULL;\r\nstruct r8a66597_pipe *pipe;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\nfor (pipenum = 0; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\r\nif (!(r8a66597->timeout_map & (1 << pipenum)))\r\ncontinue;\r\nif (timer_pending(&r8a66597->td_timer[pipenum]))\r\ncontinue;\r\ntd = r8a66597_get_td(r8a66597, pipenum);\r\nif (!td) {\r\nr8a66597->timeout_map &= ~(1 << pipenum);\r\ncontinue;\r\n}\r\nif (td->urb->actual_length) {\r\nset_td_timer(r8a66597, td);\r\nbreak;\r\n}\r\npipe = td->pipe;\r\npipe_stop(r8a66597, pipe);\r\nnew_td = td;\r\ndo {\r\nlist_move_tail(&new_td->queue,\r\n&r8a66597->pipe_queue[pipenum]);\r\nnew_td = r8a66597_get_td(r8a66597, pipenum);\r\nif (!new_td) {\r\nnew_td = td;\r\nbreak;\r\n}\r\n} while (td != new_td && td->address == new_td->address);\r\nstart_transfer(r8a66597, new_td);\r\nif (td == new_td)\r\nr8a66597->timeout_map &= ~(1 << pipenum);\r\nelse\r\nset_td_timer(r8a66597, new_td);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\n}\r\nstatic void r8a66597_timer(unsigned long _r8a66597)\r\n{\r\nstruct r8a66597 *r8a66597 = (struct r8a66597 *)_r8a66597;\r\nunsigned long flags;\r\nint port;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\nfor (port = 0; port < r8a66597->max_root_hub; port++)\r\nr8a66597_root_hub_control(r8a66597, port);\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\n}\r\nstatic int check_pipe_config(struct r8a66597 *r8a66597, struct urb *urb)\r\n{\r\nstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\r\nif (dev && dev->address && dev->state != USB_STATE_CONFIGURED &&\r\n(urb->dev->state == USB_STATE_CONFIGURED))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int r8a66597_start(struct usb_hcd *hcd)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nhcd->state = HC_STATE_RUNNING;\r\nreturn enable_controller(r8a66597);\r\n}\r\nstatic void r8a66597_stop(struct usb_hcd *hcd)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\ndisable_controller(r8a66597);\r\n}\r\nstatic void set_address_zero(struct r8a66597 *r8a66597, struct urb *urb)\r\n{\r\nunsigned int usb_address = usb_pipedevice(urb->pipe);\r\nu16 root_port, hub_port;\r\nif (usb_address == 0) {\r\nget_port_number(r8a66597, urb->dev->devpath,\r\n&root_port, &hub_port);\r\nset_devadd_reg(r8a66597, 0,\r\nget_r8a66597_usb_speed(urb->dev->speed),\r\nget_parent_r8a66597_address(r8a66597, urb->dev),\r\nhub_port, root_port);\r\n}\r\n}\r\nstatic struct r8a66597_td *r8a66597_make_td(struct r8a66597 *r8a66597,\r\nstruct urb *urb,\r\nstruct usb_host_endpoint *hep)\r\n{\r\nstruct r8a66597_td *td;\r\nu16 pipenum;\r\ntd = kzalloc(sizeof(struct r8a66597_td), GFP_ATOMIC);\r\nif (td == NULL)\r\nreturn NULL;\r\npipenum = r8a66597_get_pipenum(urb, hep);\r\ntd->pipenum = pipenum;\r\ntd->pipe = hep->hcpriv;\r\ntd->urb = urb;\r\ntd->address = get_urb_to_r8a66597_addr(r8a66597, urb);\r\ntd->maxpacket = usb_maxpacket(urb->dev, urb->pipe,\r\n!usb_pipein(urb->pipe));\r\nif (usb_pipecontrol(urb->pipe))\r\ntd->type = USB_PID_SETUP;\r\nelse if (usb_pipein(urb->pipe))\r\ntd->type = USB_PID_IN;\r\nelse\r\ntd->type = USB_PID_OUT;\r\nINIT_LIST_HEAD(&td->queue);\r\nreturn td;\r\n}\r\nstatic int r8a66597_urb_enqueue(struct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct usb_host_endpoint *hep = urb->ep;\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nstruct r8a66597_td *td = NULL;\r\nint ret, request = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\nif (!get_urb_to_r8a66597_dev(r8a66597, urb)) {\r\nret = -ENODEV;\r\ngoto error_not_linked;\r\n}\r\nret = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (ret)\r\ngoto error_not_linked;\r\nif (!hep->hcpriv) {\r\nhep->hcpriv = kzalloc(sizeof(struct r8a66597_pipe),\r\nGFP_ATOMIC);\r\nif (!hep->hcpriv) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nset_pipe_reg_addr(hep->hcpriv, R8A66597_PIPE_NO_DMA);\r\nif (usb_pipeendpoint(urb->pipe))\r\ninit_pipe_info(r8a66597, urb, hep, &hep->desc);\r\n}\r\nif (unlikely(check_pipe_config(r8a66597, urb)))\r\ninit_pipe_config(r8a66597, urb);\r\nset_address_zero(r8a66597, urb);\r\ntd = r8a66597_make_td(r8a66597, urb, hep);\r\nif (td == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (list_empty(&r8a66597->pipe_queue[td->pipenum]))\r\nrequest = 1;\r\nlist_add_tail(&td->queue, &r8a66597->pipe_queue[td->pipenum]);\r\nurb->hcpriv = td;\r\nif (request) {\r\nif (td->pipe->info.timer_interval) {\r\nr8a66597->interval_map |= 1 << td->pipenum;\r\nmod_timer(&r8a66597->interval_timer[td->pipenum],\r\njiffies + msecs_to_jiffies(\r\ntd->pipe->info.timer_interval));\r\n} else {\r\nret = start_transfer(r8a66597, td);\r\nif (ret < 0) {\r\nlist_del(&td->queue);\r\nkfree(td);\r\n}\r\n}\r\n} else\r\nset_td_timer(r8a66597, td);\r\nerror:\r\nif (ret)\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nerror_not_linked:\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,\r\nint status)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nstruct r8a66597_td *td;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto done;\r\nif (urb->hcpriv) {\r\ntd = urb->hcpriv;\r\npipe_stop(r8a66597, td->pipe);\r\npipe_irq_disable(r8a66597, td->pipenum);\r\ndisable_irq_empty(r8a66597, td->pipenum);\r\nfinish_request(r8a66597, td, td->pipenum, urb, status);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void r8a66597_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *hep)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nstruct r8a66597_pipe *pipe = (struct r8a66597_pipe *)hep->hcpriv;\r\nstruct r8a66597_td *td;\r\nstruct urb *urb = NULL;\r\nu16 pipenum;\r\nunsigned long flags;\r\nif (pipe == NULL)\r\nreturn;\r\npipenum = pipe->info.pipenum;\r\nif (pipenum == 0) {\r\nkfree(hep->hcpriv);\r\nhep->hcpriv = NULL;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\npipe_stop(r8a66597, pipe);\r\npipe_irq_disable(r8a66597, pipenum);\r\ndisable_irq_empty(r8a66597, pipenum);\r\ntd = r8a66597_get_td(r8a66597, pipenum);\r\nif (td)\r\nurb = td->urb;\r\nfinish_request(r8a66597, td, pipenum, urb, -ESHUTDOWN);\r\nkfree(hep->hcpriv);\r\nhep->hcpriv = NULL;\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\n}\r\nstatic int r8a66597_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nreturn r8a66597_read(r8a66597, FRMNUM) & 0x03FF;\r\n}\r\nstatic void collect_usb_address_map(struct usb_device *udev, unsigned long *map)\r\n{\r\nint chix;\r\nstruct usb_device *childdev;\r\nif (udev->state == USB_STATE_CONFIGURED &&\r\nudev->parent && udev->parent->devnum > 1 &&\r\nudev->parent->descriptor.bDeviceClass == USB_CLASS_HUB)\r\nmap[udev->devnum/32] |= (1 << (udev->devnum % 32));\r\nusb_hub_for_each_child(udev, chix, childdev)\r\ncollect_usb_address_map(childdev, map);\r\n}\r\nstatic struct r8a66597_device *get_r8a66597_device(struct r8a66597 *r8a66597,\r\nint addr)\r\n{\r\nstruct r8a66597_device *dev;\r\nstruct list_head *list = &r8a66597->child_device;\r\nlist_for_each_entry(dev, list, device_list) {\r\nif (dev->usb_address != addr)\r\ncontinue;\r\nreturn dev;\r\n}\r\nprintk(KERN_ERR "r8a66597: get_r8a66597_device fail.(%d)\n", addr);\r\nreturn NULL;\r\n}\r\nstatic void update_usb_address_map(struct r8a66597 *r8a66597,\r\nstruct usb_device *root_hub,\r\nunsigned long *map)\r\n{\r\nint i, j, addr;\r\nunsigned long diff;\r\nunsigned long flags;\r\nfor (i = 0; i < 4; i++) {\r\ndiff = r8a66597->child_connect_map[i] ^ map[i];\r\nif (!diff)\r\ncontinue;\r\nfor (j = 0; j < 32; j++) {\r\nif (!(diff & (1 << j)))\r\ncontinue;\r\naddr = i * 32 + j;\r\nif (map[i] & (1 << j))\r\nset_child_connect_map(r8a66597, addr);\r\nelse {\r\nstruct r8a66597_device *dev;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\ndev = get_r8a66597_device(r8a66597, addr);\r\ndisable_r8a66597_pipe_all(r8a66597, dev);\r\nfree_usb_address(r8a66597, dev, 0);\r\nput_child_connect_map(r8a66597, addr);\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\n}\r\n}\r\n}\r\n}\r\nstatic void r8a66597_check_detect_child(struct r8a66597 *r8a66597,\r\nstruct usb_hcd *hcd)\r\n{\r\nstruct usb_bus *bus;\r\nunsigned long now_map[4];\r\nmemset(now_map, 0, sizeof(now_map));\r\nmutex_lock(&usb_bus_idr_lock);\r\nbus = idr_find(&usb_bus_idr, hcd->self.busnum);\r\nif (bus && bus->root_hub) {\r\ncollect_usb_address_map(bus->root_hub, now_map);\r\nupdate_usb_address_map(r8a66597, bus->root_hub, now_map);\r\n}\r\nmutex_unlock(&usb_bus_idr_lock);\r\n}\r\nstatic int r8a66597_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nunsigned long flags;\r\nint i;\r\nr8a66597_check_detect_child(r8a66597, hcd);\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\n*buf = 0;\r\nfor (i = 0; i < r8a66597->max_root_hub; i++) {\r\nif (r8a66597->root_hub[i].port & 0xffff0000)\r\n*buf |= 1 << (i + 1);\r\n}\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\nreturn (*buf != 0);\r\n}\r\nstatic void r8a66597_hub_descriptor(struct r8a66597 *r8a66597,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\ndesc->bDescriptorType = USB_DT_HUB;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = r8a66597->max_root_hub;\r\ndesc->bDescLength = 9;\r\ndesc->bPwrOn2PwrGood = 0;\r\ndesc->wHubCharacteristics =\r\ncpu_to_le16(HUB_CHAR_INDV_PORT_LPSM | HUB_CHAR_NO_OCPM);\r\ndesc->u.hs.DeviceRemovable[0] =\r\n((1 << r8a66597->max_root_hub) - 1) << 1;\r\ndesc->u.hs.DeviceRemovable[1] = ~0;\r\n}\r\nstatic int r8a66597_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nint ret;\r\nint port = (wIndex & 0x00FF) - 1;\r\nstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\r\nunsigned long flags;\r\nret = 0;\r\nspin_lock_irqsave(&r8a66597->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (wIndex > r8a66597->max_root_hub)\r\ngoto error;\r\nif (wLength != 0)\r\ngoto error;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nrh->port &= ~USB_PORT_STAT_POWER;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nr8a66597_port_power(r8a66597, port, 0);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ncase USB_PORT_FEAT_C_RESET:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nrh->port &= ~(1 << wValue);\r\nbreak;\r\ncase GetHubDescriptor:\r\nr8a66597_hub_descriptor(r8a66597,\r\n(struct usb_hub_descriptor *)buf);\r\nbreak;\r\ncase GetHubStatus:\r\n*buf = 0x00;\r\nbreak;\r\ncase GetPortStatus:\r\nif (wIndex > r8a66597->max_root_hub)\r\ngoto error;\r\n*(__le32 *)buf = cpu_to_le32(rh->port);\r\nbreak;\r\ncase SetPortFeature:\r\nif (wIndex > r8a66597->max_root_hub)\r\ngoto error;\r\nif (wLength != 0)\r\ngoto error;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nr8a66597_port_power(r8a66597, port, 1);\r\nrh->port |= USB_PORT_STAT_POWER;\r\nbreak;\r\ncase USB_PORT_FEAT_RESET: {\r\nstruct r8a66597_device *dev = rh->dev;\r\nrh->port |= USB_PORT_STAT_RESET;\r\ndisable_r8a66597_pipe_all(r8a66597, dev);\r\nfree_usb_address(r8a66597, dev, 1);\r\nr8a66597_mdfy(r8a66597, USBRST, USBRST | UACT,\r\nget_dvstctr_reg(port));\r\nmod_timer(&r8a66597->rh_timer,\r\njiffies + msecs_to_jiffies(50));\r\n}\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nrh->port |= 1 << wValue;\r\nbreak;\r\ndefault:\r\nerror:\r\nret = -EPIPE;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&r8a66597->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int r8a66597_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nint port;\r\ndev_dbg(&r8a66597->device0.udev->dev, "%s\n", __func__);\r\nfor (port = 0; port < r8a66597->max_root_hub; port++) {\r\nstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\r\nunsigned long dvstctr_reg = get_dvstctr_reg(port);\r\nif (!(rh->port & USB_PORT_STAT_ENABLE))\r\ncontinue;\r\ndev_dbg(&rh->dev->udev->dev, "suspend port = %d\n", port);\r\nr8a66597_bclr(r8a66597, UACT, dvstctr_reg);\r\nrh->port |= USB_PORT_STAT_SUSPEND;\r\nif (rh->dev->udev->do_remote_wakeup) {\r\nmsleep(3);\r\nr8a66597_bset(r8a66597, RWUPE, dvstctr_reg);\r\nr8a66597_write(r8a66597, ~BCHG, get_intsts_reg(port));\r\nr8a66597_bset(r8a66597, BCHGE, get_intenb_reg(port));\r\n}\r\n}\r\nr8a66597->bus_suspended = 1;\r\nreturn 0;\r\n}\r\nstatic int r8a66597_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\r\nint port;\r\ndev_dbg(&r8a66597->device0.udev->dev, "%s\n", __func__);\r\nfor (port = 0; port < r8a66597->max_root_hub; port++) {\r\nstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\r\nunsigned long dvstctr_reg = get_dvstctr_reg(port);\r\nif (!(rh->port & USB_PORT_STAT_SUSPEND))\r\ncontinue;\r\ndev_dbg(&rh->dev->udev->dev, "resume port = %d\n", port);\r\nrh->port &= ~USB_PORT_STAT_SUSPEND;\r\nrh->port |= USB_PORT_STAT_C_SUSPEND << 16;\r\nr8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);\r\nmsleep(USB_RESUME_TIMEOUT);\r\nr8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8a66597_suspend(struct device *dev)\r\n{\r\nstruct r8a66597 *r8a66597 = dev_get_drvdata(dev);\r\nint port;\r\ndev_dbg(dev, "%s\n", __func__);\r\ndisable_controller(r8a66597);\r\nfor (port = 0; port < r8a66597->max_root_hub; port++) {\r\nstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\r\nrh->port = 0x00000000;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8a66597_resume(struct device *dev)\r\n{\r\nstruct r8a66597 *r8a66597 = dev_get_drvdata(dev);\r\nstruct usb_hcd *hcd = r8a66597_to_hcd(r8a66597);\r\ndev_dbg(dev, "%s\n", __func__);\r\nenable_controller(r8a66597);\r\nusb_root_hub_lost_power(hcd->self.root_hub);\r\nreturn 0;\r\n}\r\nstatic int r8a66597_remove(struct platform_device *pdev)\r\n{\r\nstruct r8a66597 *r8a66597 = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = r8a66597_to_hcd(r8a66597);\r\ndel_timer_sync(&r8a66597->rh_timer);\r\nusb_remove_hcd(hcd);\r\niounmap(r8a66597->reg);\r\nif (r8a66597->pdata->on_chip)\r\nclk_put(r8a66597->clk);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int r8a66597_probe(struct platform_device *pdev)\r\n{\r\nchar clk_name[8];\r\nstruct resource *res = NULL, *ires;\r\nint irq = -1;\r\nvoid __iomem *reg = NULL;\r\nstruct usb_hcd *hcd = NULL;\r\nstruct r8a66597 *r8a66597;\r\nint ret = 0;\r\nint i;\r\nunsigned long irq_trigger;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (pdev->dev.dma_mask) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "dma not supported\n");\r\ngoto clean_up;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "platform_get_resource error.\n");\r\ngoto clean_up;\r\n}\r\nires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!ires) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev,\r\n"platform_get_resource IORESOURCE_IRQ error.\n");\r\ngoto clean_up;\r\n}\r\nirq = ires->start;\r\nirq_trigger = ires->flags & IRQF_TRIGGER_MASK;\r\nreg = ioremap(res->start, resource_size(res));\r\nif (reg == NULL) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "ioremap error.\n");\r\ngoto clean_up;\r\n}\r\nif (pdev->dev.platform_data == NULL) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nret = -ENODEV;\r\ngoto clean_up;\r\n}\r\nhcd = usb_create_hcd(&r8a66597_hc_driver, &pdev->dev, (char *)hcd_name);\r\nif (!hcd) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "Failed to create hcd\n");\r\ngoto clean_up;\r\n}\r\nr8a66597 = hcd_to_r8a66597(hcd);\r\nmemset(r8a66597, 0, sizeof(struct r8a66597));\r\nplatform_set_drvdata(pdev, r8a66597);\r\nr8a66597->pdata = dev_get_platdata(&pdev->dev);\r\nr8a66597->irq_sense_low = irq_trigger == IRQF_TRIGGER_LOW;\r\nif (r8a66597->pdata->on_chip) {\r\nsnprintf(clk_name, sizeof(clk_name), "usb%d", pdev->id);\r\nr8a66597->clk = clk_get(&pdev->dev, clk_name);\r\nif (IS_ERR(r8a66597->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock \"%s\"\n",\r\nclk_name);\r\nret = PTR_ERR(r8a66597->clk);\r\ngoto clean_up2;\r\n}\r\nr8a66597->max_root_hub = 1;\r\n} else\r\nr8a66597->max_root_hub = 2;\r\nspin_lock_init(&r8a66597->lock);\r\nsetup_timer(&r8a66597->rh_timer, r8a66597_timer,\r\n(unsigned long)r8a66597);\r\nr8a66597->reg = reg;\r\nret = r8a66597_clock_enable(r8a66597);\r\nif (ret < 0)\r\ngoto clean_up3;\r\ndisable_controller(r8a66597);\r\nfor (i = 0; i < R8A66597_MAX_NUM_PIPE; i++) {\r\nINIT_LIST_HEAD(&r8a66597->pipe_queue[i]);\r\nsetup_timer(&r8a66597->td_timer[i], r8a66597_td_timer,\r\n(unsigned long)r8a66597);\r\nsetup_timer(&r8a66597->interval_timer[i],\r\nr8a66597_interval_timer,\r\n(unsigned long)r8a66597);\r\n}\r\nINIT_LIST_HEAD(&r8a66597->child_device);\r\nhcd->rsrc_start = res->start;\r\nhcd->has_tt = 1;\r\nret = usb_add_hcd(hcd, irq, irq_trigger);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to add hcd\n");\r\ngoto clean_up3;\r\n}\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn 0;\r\nclean_up3:\r\nif (r8a66597->pdata->on_chip)\r\nclk_put(r8a66597->clk);\r\nclean_up2:\r\nusb_put_hcd(hcd);\r\nclean_up:\r\nif (reg)\r\niounmap(reg);\r\nreturn ret;\r\n}
