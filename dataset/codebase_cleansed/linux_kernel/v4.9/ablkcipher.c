static inline void ablkcipher_buffer_write(struct ablkcipher_buffer *p)\r\n{\r\nscatterwalk_copychunks(p->data, &p->dst, p->len, 1);\r\n}\r\nvoid __ablkcipher_walk_complete(struct ablkcipher_walk *walk)\r\n{\r\nstruct ablkcipher_buffer *p, *tmp;\r\nlist_for_each_entry_safe(p, tmp, &walk->buffers, entry) {\r\nablkcipher_buffer_write(p);\r\nlist_del(&p->entry);\r\nkfree(p);\r\n}\r\n}\r\nstatic inline void ablkcipher_queue_write(struct ablkcipher_walk *walk,\r\nstruct ablkcipher_buffer *p)\r\n{\r\np->dst = walk->out;\r\nlist_add_tail(&p->entry, &walk->buffers);\r\n}\r\nstatic inline u8 *ablkcipher_get_spot(u8 *start, unsigned int len)\r\n{\r\nu8 *end_page = (u8 *)(((unsigned long)(start + len - 1)) & PAGE_MASK);\r\nreturn max(start, end_page);\r\n}\r\nstatic inline unsigned int ablkcipher_done_slow(struct ablkcipher_walk *walk,\r\nunsigned int bsize)\r\n{\r\nunsigned int n = bsize;\r\nfor (;;) {\r\nunsigned int len_this_page = scatterwalk_pagelen(&walk->out);\r\nif (len_this_page > n)\r\nlen_this_page = n;\r\nscatterwalk_advance(&walk->out, n);\r\nif (n == len_this_page)\r\nbreak;\r\nn -= len_this_page;\r\nscatterwalk_start(&walk->out, sg_next(walk->out.sg));\r\n}\r\nreturn bsize;\r\n}\r\nstatic inline unsigned int ablkcipher_done_fast(struct ablkcipher_walk *walk,\r\nunsigned int n)\r\n{\r\nscatterwalk_advance(&walk->in, n);\r\nscatterwalk_advance(&walk->out, n);\r\nreturn n;\r\n}\r\nint ablkcipher_walk_done(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk, int err)\r\n{\r\nstruct crypto_tfm *tfm = req->base.tfm;\r\nunsigned int nbytes = 0;\r\nif (likely(err >= 0)) {\r\nunsigned int n = walk->nbytes - err;\r\nif (likely(!(walk->flags & ABLKCIPHER_WALK_SLOW)))\r\nn = ablkcipher_done_fast(walk, n);\r\nelse if (WARN_ON(err)) {\r\nerr = -EINVAL;\r\ngoto err;\r\n} else\r\nn = ablkcipher_done_slow(walk, n);\r\nnbytes = walk->total - n;\r\nerr = 0;\r\n}\r\nscatterwalk_done(&walk->in, 0, nbytes);\r\nscatterwalk_done(&walk->out, 1, nbytes);\r\nerr:\r\nwalk->total = nbytes;\r\nwalk->nbytes = nbytes;\r\nif (nbytes) {\r\ncrypto_yield(req->base.flags);\r\nreturn ablkcipher_walk_next(req, walk);\r\n}\r\nif (walk->iv != req->info)\r\nmemcpy(req->info, walk->iv, tfm->crt_ablkcipher.ivsize);\r\nkfree(walk->iv_buffer);\r\nreturn err;\r\n}\r\nstatic inline int ablkcipher_next_slow(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk,\r\nunsigned int bsize,\r\nunsigned int alignmask,\r\nvoid **src_p, void **dst_p)\r\n{\r\nunsigned aligned_bsize = ALIGN(bsize, alignmask + 1);\r\nstruct ablkcipher_buffer *p;\r\nvoid *src, *dst, *base;\r\nunsigned int n;\r\nn = ALIGN(sizeof(struct ablkcipher_buffer), alignmask + 1);\r\nn += (aligned_bsize * 3 - (alignmask + 1) +\r\n(alignmask & ~(crypto_tfm_ctx_alignment() - 1)));\r\np = kmalloc(n, GFP_ATOMIC);\r\nif (!p)\r\nreturn ablkcipher_walk_done(req, walk, -ENOMEM);\r\nbase = p + 1;\r\ndst = (u8 *)ALIGN((unsigned long)base, alignmask + 1);\r\nsrc = dst = ablkcipher_get_spot(dst, bsize);\r\np->len = bsize;\r\np->data = dst;\r\nscatterwalk_copychunks(src, &walk->in, bsize, 0);\r\nablkcipher_queue_write(walk, p);\r\nwalk->nbytes = bsize;\r\nwalk->flags |= ABLKCIPHER_WALK_SLOW;\r\n*src_p = src;\r\n*dst_p = dst;\r\nreturn 0;\r\n}\r\nstatic inline int ablkcipher_copy_iv(struct ablkcipher_walk *walk,\r\nstruct crypto_tfm *tfm,\r\nunsigned int alignmask)\r\n{\r\nunsigned bs = walk->blocksize;\r\nunsigned int ivsize = tfm->crt_ablkcipher.ivsize;\r\nunsigned aligned_bs = ALIGN(bs, alignmask + 1);\r\nunsigned int size = aligned_bs * 2 + ivsize + max(aligned_bs, ivsize) -\r\n(alignmask + 1);\r\nu8 *iv;\r\nsize += alignmask & ~(crypto_tfm_ctx_alignment() - 1);\r\nwalk->iv_buffer = kmalloc(size, GFP_ATOMIC);\r\nif (!walk->iv_buffer)\r\nreturn -ENOMEM;\r\niv = (u8 *)ALIGN((unsigned long)walk->iv_buffer, alignmask + 1);\r\niv = ablkcipher_get_spot(iv, bs) + aligned_bs;\r\niv = ablkcipher_get_spot(iv, bs) + aligned_bs;\r\niv = ablkcipher_get_spot(iv, ivsize);\r\nwalk->iv = memcpy(iv, walk->iv, ivsize);\r\nreturn 0;\r\n}\r\nstatic inline int ablkcipher_next_fast(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk)\r\n{\r\nwalk->src.page = scatterwalk_page(&walk->in);\r\nwalk->src.offset = offset_in_page(walk->in.offset);\r\nwalk->dst.page = scatterwalk_page(&walk->out);\r\nwalk->dst.offset = offset_in_page(walk->out.offset);\r\nreturn 0;\r\n}\r\nstatic int ablkcipher_walk_next(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk)\r\n{\r\nstruct crypto_tfm *tfm = req->base.tfm;\r\nunsigned int alignmask, bsize, n;\r\nvoid *src, *dst;\r\nint err;\r\nalignmask = crypto_tfm_alg_alignmask(tfm);\r\nn = walk->total;\r\nif (unlikely(n < crypto_tfm_alg_blocksize(tfm))) {\r\nreq->base.flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;\r\nreturn ablkcipher_walk_done(req, walk, -EINVAL);\r\n}\r\nwalk->flags &= ~ABLKCIPHER_WALK_SLOW;\r\nsrc = dst = NULL;\r\nbsize = min(walk->blocksize, n);\r\nn = scatterwalk_clamp(&walk->in, n);\r\nn = scatterwalk_clamp(&walk->out, n);\r\nif (n < bsize ||\r\n!scatterwalk_aligned(&walk->in, alignmask) ||\r\n!scatterwalk_aligned(&walk->out, alignmask)) {\r\nerr = ablkcipher_next_slow(req, walk, bsize, alignmask,\r\n&src, &dst);\r\ngoto set_phys_lowmem;\r\n}\r\nwalk->nbytes = n;\r\nreturn ablkcipher_next_fast(req, walk);\r\nset_phys_lowmem:\r\nif (err >= 0) {\r\nwalk->src.page = virt_to_page(src);\r\nwalk->dst.page = virt_to_page(dst);\r\nwalk->src.offset = ((unsigned long)src & (PAGE_SIZE - 1));\r\nwalk->dst.offset = ((unsigned long)dst & (PAGE_SIZE - 1));\r\n}\r\nreturn err;\r\n}\r\nstatic int ablkcipher_walk_first(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk)\r\n{\r\nstruct crypto_tfm *tfm = req->base.tfm;\r\nunsigned int alignmask;\r\nalignmask = crypto_tfm_alg_alignmask(tfm);\r\nif (WARN_ON_ONCE(in_irq()))\r\nreturn -EDEADLK;\r\nwalk->iv = req->info;\r\nwalk->nbytes = walk->total;\r\nif (unlikely(!walk->total))\r\nreturn 0;\r\nwalk->iv_buffer = NULL;\r\nif (unlikely(((unsigned long)walk->iv & alignmask))) {\r\nint err = ablkcipher_copy_iv(walk, tfm, alignmask);\r\nif (err)\r\nreturn err;\r\n}\r\nscatterwalk_start(&walk->in, walk->in.sg);\r\nscatterwalk_start(&walk->out, walk->out.sg);\r\nreturn ablkcipher_walk_next(req, walk);\r\n}\r\nint ablkcipher_walk_phys(struct ablkcipher_request *req,\r\nstruct ablkcipher_walk *walk)\r\n{\r\nwalk->blocksize = crypto_tfm_alg_blocksize(req->base.tfm);\r\nreturn ablkcipher_walk_first(req, walk);\r\n}\r\nstatic int setkey_unaligned(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);\r\nunsigned long alignmask = crypto_ablkcipher_alignmask(tfm);\r\nint ret;\r\nu8 *buffer, *alignbuffer;\r\nunsigned long absize;\r\nabsize = keylen + alignmask;\r\nbuffer = kmalloc(absize, GFP_ATOMIC);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nalignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\r\nmemcpy(alignbuffer, key, keylen);\r\nret = cipher->setkey(tfm, alignbuffer, keylen);\r\nmemset(alignbuffer, 0, keylen);\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic int setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);\r\nunsigned long alignmask = crypto_ablkcipher_alignmask(tfm);\r\nif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nif ((unsigned long)key & alignmask)\r\nreturn setkey_unaligned(tfm, key, keylen);\r\nreturn cipher->setkey(tfm, key, keylen);\r\n}\r\nstatic unsigned int crypto_ablkcipher_ctxsize(struct crypto_alg *alg, u32 type,\r\nu32 mask)\r\n{\r\nreturn alg->cra_ctxsize;\r\n}\r\nstatic int crypto_init_ablkcipher_ops(struct crypto_tfm *tfm, u32 type,\r\nu32 mask)\r\n{\r\nstruct ablkcipher_alg *alg = &tfm->__crt_alg->cra_ablkcipher;\r\nstruct ablkcipher_tfm *crt = &tfm->crt_ablkcipher;\r\nif (alg->ivsize > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\ncrt->setkey = setkey;\r\ncrt->encrypt = alg->encrypt;\r\ncrt->decrypt = alg->decrypt;\r\ncrt->base = __crypto_ablkcipher_cast(tfm);\r\ncrt->ivsize = alg->ivsize;\r\nreturn 0;\r\n}\r\nstatic int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_blkcipher rblkcipher;\r\nstrncpy(rblkcipher.type, "ablkcipher", sizeof(rblkcipher.type));\r\nstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: "<default>",\r\nsizeof(rblkcipher.geniv));\r\nrblkcipher.blocksize = alg->cra_blocksize;\r\nrblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\r\nrblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\r\nrblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\r\nsizeof(struct crypto_report_blkcipher), &rblkcipher))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void crypto_ablkcipher_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct ablkcipher_alg *ablkcipher = &alg->cra_ablkcipher;\r\nseq_printf(m, "type : ablkcipher\n");\r\nseq_printf(m, "async : %s\n", alg->cra_flags & CRYPTO_ALG_ASYNC ?\r\n"yes" : "no");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "min keysize : %u\n", ablkcipher->min_keysize);\r\nseq_printf(m, "max keysize : %u\n", ablkcipher->max_keysize);\r\nseq_printf(m, "ivsize : %u\n", ablkcipher->ivsize);\r\nseq_printf(m, "geniv : %s\n", ablkcipher->geniv ?: "<default>");\r\n}\r\nstatic int crypto_init_givcipher_ops(struct crypto_tfm *tfm, u32 type,\r\nu32 mask)\r\n{\r\nstruct ablkcipher_alg *alg = &tfm->__crt_alg->cra_ablkcipher;\r\nstruct ablkcipher_tfm *crt = &tfm->crt_ablkcipher;\r\nif (alg->ivsize > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\ncrt->setkey = tfm->__crt_alg->cra_flags & CRYPTO_ALG_GENIV ?\r\nalg->setkey : setkey;\r\ncrt->encrypt = alg->encrypt;\r\ncrt->decrypt = alg->decrypt;\r\ncrt->base = __crypto_ablkcipher_cast(tfm);\r\ncrt->ivsize = alg->ivsize;\r\nreturn 0;\r\n}\r\nstatic int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_blkcipher rblkcipher;\r\nstrncpy(rblkcipher.type, "givcipher", sizeof(rblkcipher.type));\r\nstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: "<built-in>",\r\nsizeof(rblkcipher.geniv));\r\nrblkcipher.blocksize = alg->cra_blocksize;\r\nrblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\r\nrblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\r\nrblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\r\nsizeof(struct crypto_report_blkcipher), &rblkcipher))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void crypto_givcipher_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct ablkcipher_alg *ablkcipher = &alg->cra_ablkcipher;\r\nseq_printf(m, "type : givcipher\n");\r\nseq_printf(m, "async : %s\n", alg->cra_flags & CRYPTO_ALG_ASYNC ?\r\n"yes" : "no");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "min keysize : %u\n", ablkcipher->min_keysize);\r\nseq_printf(m, "max keysize : %u\n", ablkcipher->max_keysize);\r\nseq_printf(m, "ivsize : %u\n", ablkcipher->ivsize);\r\nseq_printf(m, "geniv : %s\n", ablkcipher->geniv ?: "<built-in>");\r\n}
