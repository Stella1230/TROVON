static int mac53c94_queue_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct fsc_state *state;\r\n#if 0\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE) {\r\nint i;\r\nprintk(KERN_DEBUG "mac53c94_queue %p: command is", cmd);\r\nfor (i = 0; i < cmd->cmd_len; ++i)\r\nprintk(KERN_CONT " %.2x", cmd->cmnd[i]);\r\nprintk(KERN_CONT "\n");\r\nprintk(KERN_DEBUG "use_sg=%d request_bufflen=%d request_buffer=%p\n",\r\nscsi_sg_count(cmd), scsi_bufflen(cmd), scsi_sglist(cmd));\r\n}\r\n#endif\r\ncmd->scsi_done = done;\r\ncmd->host_scribble = NULL;\r\nstate = (struct fsc_state *) cmd->device->host->hostdata;\r\nif (state->request_q == NULL)\r\nstate->request_q = cmd;\r\nelse\r\nstate->request_qtail->host_scribble = (void *) cmd;\r\nstate->request_qtail = cmd;\r\nif (state->phase == idle)\r\nmac53c94_start(state);\r\nreturn 0;\r\n}\r\nstatic void mac53c94_init(struct fsc_state *state)\r\n{\r\nstruct mac53c94_regs __iomem *regs = state->regs;\r\nstruct dbdma_regs __iomem *dma = state->dma;\r\nint x;\r\nwriteb(state->host->this_id | CF1_PAR_ENABLE, &regs->config1);\r\nwriteb(TIMO_VAL(250), &regs->sel_timeout);\r\nwriteb(CLKF_VAL(state->clk_freq), &regs->clk_factor);\r\nwriteb(CF2_FEATURE_EN, &regs->config2);\r\nwriteb(0, &regs->config3);\r\nwriteb(0, &regs->sync_period);\r\nwriteb(0, &regs->sync_offset);\r\nx = readb(&regs->interrupt);\r\nwritel((RUN|PAUSE|FLUSH|WAKE) << 16, &dma->control);\r\n}\r\nstatic void mac53c94_start(struct fsc_state *state)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nstruct mac53c94_regs __iomem *regs = state->regs;\r\nint i;\r\nif (state->phase != idle || state->current_req != NULL)\r\npanic("inappropriate mac53c94_start (state=%p)", state);\r\nif (state->request_q == NULL)\r\nreturn;\r\nstate->current_req = cmd = state->request_q;\r\nstate->request_q = (struct scsi_cmnd *) cmd->host_scribble;\r\nwriteb(0, &regs->count_lo);\r\nwriteb(0, &regs->count_mid);\r\nwriteb(0, &regs->count_hi);\r\nwriteb(CMD_NOP + CMD_DMA_MODE, &regs->command);\r\nudelay(1);\r\nwriteb(CMD_FLUSH, &regs->command);\r\nudelay(1);\r\nwriteb(cmd->device->id, &regs->dest_id);\r\nwriteb(0, &regs->sync_period);\r\nwriteb(0, &regs->sync_offset);\r\nfor (i = 0; i < cmd->cmd_len; ++i)\r\nwriteb(cmd->cmnd[i], &regs->fifo);\r\nwriteb(CMD_SELECT, &regs->command);\r\nstate->phase = selecting;\r\nset_dma_cmds(state, cmd);\r\n}\r\nstatic irqreturn_t do_mac53c94_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host *dev = ((struct fsc_state *) dev_id)->current_req->device->host;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\nmac53c94_interrupt(irq, dev_id);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mac53c94_interrupt(int irq, void *dev_id)\r\n{\r\nstruct fsc_state *state = (struct fsc_state *) dev_id;\r\nstruct mac53c94_regs __iomem *regs = state->regs;\r\nstruct dbdma_regs __iomem *dma = state->dma;\r\nstruct scsi_cmnd *cmd = state->current_req;\r\nint nb, stat, seq, intr;\r\nstatic int mac53c94_errors;\r\nseq = readb(&regs->seqstep);\r\nstat = readb(&regs->status);\r\nintr = readb(&regs->interrupt);\r\n#if 0\r\nprintk(KERN_DEBUG "mac53c94_intr, intr=%x stat=%x seq=%x phase=%d\n",\r\nintr, stat, seq, state->phase);\r\n#endif\r\nif (intr & INTR_RESET) {\r\nprintk(KERN_INFO "external SCSI bus reset detected\n");\r\nwriteb(CMD_NOP, &regs->command);\r\nwritel(RUN << 16, &dma->control);\r\ncmd_done(state, DID_RESET << 16);\r\nreturn;\r\n}\r\nif (intr & INTR_ILL_CMD) {\r\nprintk(KERN_ERR "53c94: invalid cmd, intr=%x stat=%x seq=%x phase=%d\n",\r\nintr, stat, seq, state->phase);\r\ncmd_done(state, DID_ERROR << 16);\r\nreturn;\r\n}\r\nif (stat & STAT_ERROR) {\r\n#if 0\r\nprintk("53c94: bad error, intr=%x stat=%x seq=%x phase=%d\n",\r\nintr, stat, seq, state->phase);\r\n#endif\r\n++mac53c94_errors;\r\nwriteb(CMD_NOP + CMD_DMA_MODE, &regs->command);\r\n}\r\nif (cmd == 0) {\r\nprintk(KERN_DEBUG "53c94: interrupt with no command active?\n");\r\nreturn;\r\n}\r\nif (stat & STAT_PARITY) {\r\nprintk(KERN_ERR "mac53c94: parity error\n");\r\ncmd_done(state, DID_PARITY << 16);\r\nreturn;\r\n}\r\nswitch (state->phase) {\r\ncase selecting:\r\nif (intr & INTR_DISCONNECT) {\r\ncmd_done(state, DID_BAD_TARGET << 16);\r\nreturn;\r\n}\r\nif (intr != INTR_BUS_SERV + INTR_DONE) {\r\nprintk(KERN_DEBUG "got intr %x during selection\n", intr);\r\ncmd_done(state, DID_ERROR << 16);\r\nreturn;\r\n}\r\nif ((seq & SS_MASK) != SS_DONE) {\r\nprintk(KERN_DEBUG "seq step %x after command\n", seq);\r\ncmd_done(state, DID_ERROR << 16);\r\nreturn;\r\n}\r\nwriteb(CMD_NOP, &regs->command);\r\nif ((stat & (STAT_MSG|STAT_CD)) == 0\r\n&& (scsi_sg_count(cmd) > 0 || scsi_bufflen(cmd))) {\r\nnb = cmd->SCp.this_residual;\r\nif (nb > 0xfff0)\r\nnb = 0xfff0;\r\ncmd->SCp.this_residual -= nb;\r\nwriteb(nb, &regs->count_lo);\r\nwriteb(nb >> 8, &regs->count_mid);\r\nwriteb(CMD_DMA_MODE + CMD_NOP, &regs->command);\r\nwritel(virt_to_phys(state->dma_cmds), &dma->cmdptr);\r\nwritel((RUN << 16) | RUN, &dma->control);\r\nwriteb(CMD_DMA_MODE + CMD_XFER_DATA, &regs->command);\r\nstate->phase = dataing;\r\nbreak;\r\n} else if ((stat & STAT_PHASE) == STAT_CD + STAT_IO) {\r\nwriteb(CMD_I_COMPLETE, &regs->command);\r\nstate->phase = completing;\r\n} else {\r\nprintk(KERN_DEBUG "in unexpected phase %x after cmd\n",\r\nstat & STAT_PHASE);\r\ncmd_done(state, DID_ERROR << 16);\r\nreturn;\r\n}\r\nbreak;\r\ncase dataing:\r\nif (intr != INTR_BUS_SERV) {\r\nprintk(KERN_DEBUG "got intr %x before status\n", intr);\r\ncmd_done(state, DID_ERROR << 16);\r\nreturn;\r\n}\r\nif (cmd->SCp.this_residual != 0\r\n&& (stat & (STAT_MSG|STAT_CD)) == 0) {\r\nnb = cmd->SCp.this_residual;\r\nif (nb > 0xfff0)\r\nnb = 0xfff0;\r\ncmd->SCp.this_residual -= nb;\r\nwriteb(nb, &regs->count_lo);\r\nwriteb(nb >> 8, &regs->count_mid);\r\nwriteb(CMD_DMA_MODE + CMD_NOP, &regs->command);\r\nwriteb(CMD_DMA_MODE + CMD_XFER_DATA, &regs->command);\r\nbreak;\r\n}\r\nif ((stat & STAT_PHASE) != STAT_CD + STAT_IO) {\r\nprintk(KERN_DEBUG "intr %x before data xfer complete\n", intr);\r\n}\r\nwritel(RUN << 16, &dma->control);\r\nscsi_dma_unmap(cmd);\r\nwriteb(CMD_I_COMPLETE, &regs->command);\r\nstate->phase = completing;\r\nbreak;\r\ncase completing:\r\nif (intr != INTR_DONE) {\r\nprintk(KERN_DEBUG "got intr %x on completion\n", intr);\r\ncmd_done(state, DID_ERROR << 16);\r\nreturn;\r\n}\r\ncmd->SCp.Status = readb(&regs->fifo);\r\ncmd->SCp.Message = readb(&regs->fifo);\r\ncmd->result = CMD_ACCEPT_MSG;\r\nwriteb(CMD_ACCEPT_MSG, &regs->command);\r\nstate->phase = busfreeing;\r\nbreak;\r\ncase busfreeing:\r\nif (intr != INTR_DISCONNECT) {\r\nprintk(KERN_DEBUG "got intr %x when expected disconnect\n", intr);\r\n}\r\ncmd_done(state, (DID_OK << 16) + (cmd->SCp.Message << 8)\r\n+ cmd->SCp.Status);\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "don't know about phase %d\n", state->phase);\r\n}\r\n}\r\nstatic void cmd_done(struct fsc_state *state, int result)\r\n{\r\nstruct scsi_cmnd *cmd;\r\ncmd = state->current_req;\r\nif (cmd != 0) {\r\ncmd->result = result;\r\n(*cmd->scsi_done)(cmd);\r\nstate->current_req = NULL;\r\n}\r\nstate->phase = idle;\r\nmac53c94_start(state);\r\n}\r\nstatic void set_dma_cmds(struct fsc_state *state, struct scsi_cmnd *cmd)\r\n{\r\nint i, dma_cmd, total, nseg;\r\nstruct scatterlist *scl;\r\nstruct dbdma_cmd *dcmds;\r\ndma_addr_t dma_addr;\r\nu32 dma_len;\r\nnseg = scsi_dma_map(cmd);\r\nBUG_ON(nseg < 0);\r\nif (!nseg)\r\nreturn;\r\ndma_cmd = cmd->sc_data_direction == DMA_TO_DEVICE ?\r\nOUTPUT_MORE : INPUT_MORE;\r\ndcmds = state->dma_cmds;\r\ntotal = 0;\r\nscsi_for_each_sg(cmd, scl, nseg, i) {\r\ndma_addr = sg_dma_address(scl);\r\ndma_len = sg_dma_len(scl);\r\nif (dma_len > 0xffff)\r\npanic("mac53c94: scatterlist element >= 64k");\r\ntotal += dma_len;\r\ndcmds->req_count = cpu_to_le16(dma_len);\r\ndcmds->command = cpu_to_le16(dma_cmd);\r\ndcmds->phy_addr = cpu_to_le32(dma_addr);\r\ndcmds->xfer_status = 0;\r\n++dcmds;\r\n}\r\ndma_cmd += OUTPUT_LAST - OUTPUT_MORE;\r\ndcmds[-1].command = cpu_to_le16(dma_cmd);\r\ndcmds->command = cpu_to_le16(DBDMA_STOP);\r\ncmd->SCp.this_residual = total;\r\n}\r\nstatic int mac53c94_probe(struct macio_dev *mdev, const struct of_device_id *match)\r\n{\r\nstruct device_node *node = macio_get_of_node(mdev);\r\nstruct pci_dev *pdev = macio_get_pci_dev(mdev);\r\nstruct fsc_state *state;\r\nstruct Scsi_Host *host;\r\nvoid *dma_cmd_space;\r\nconst unsigned char *clkprop;\r\nint proplen, rc = -ENODEV;\r\nif (macio_resource_count(mdev) != 2 || macio_irq_count(mdev) != 2) {\r\nprintk(KERN_ERR "mac53c94: expected 2 addrs and intrs"\r\n" (got %d/%d)\n",\r\nmacio_resource_count(mdev), macio_irq_count(mdev));\r\nreturn -ENODEV;\r\n}\r\nif (macio_request_resources(mdev, "mac53c94") != 0) {\r\nprintk(KERN_ERR "mac53c94: unable to request memory resources");\r\nreturn -EBUSY;\r\n}\r\nhost = scsi_host_alloc(&mac53c94_template, sizeof(struct fsc_state));\r\nif (host == NULL) {\r\nprintk(KERN_ERR "mac53c94: couldn't register host");\r\nrc = -ENOMEM;\r\ngoto out_release;\r\n}\r\nstate = (struct fsc_state *) host->hostdata;\r\nmacio_set_drvdata(mdev, state);\r\nstate->host = host;\r\nstate->pdev = pdev;\r\nstate->mdev = mdev;\r\nstate->regs = (struct mac53c94_regs __iomem *)\r\nioremap(macio_resource_start(mdev, 0), 0x1000);\r\nstate->intr = macio_irq(mdev, 0);\r\nstate->dma = (struct dbdma_regs __iomem *)\r\nioremap(macio_resource_start(mdev, 1), 0x1000);\r\nstate->dmaintr = macio_irq(mdev, 1);\r\nif (state->regs == NULL || state->dma == NULL) {\r\nprintk(KERN_ERR "mac53c94: ioremap failed for %s\n",\r\nnode->full_name);\r\ngoto out_free;\r\n}\r\nclkprop = of_get_property(node, "clock-frequency", &proplen);\r\nif (clkprop == NULL || proplen != sizeof(int)) {\r\nprintk(KERN_ERR "%s: can't get clock frequency, "\r\n"assuming 25MHz\n", node->full_name);\r\nstate->clk_freq = 25000000;\r\n} else\r\nstate->clk_freq = *(int *)clkprop;\r\ndma_cmd_space = kmalloc((host->sg_tablesize + 2) *\r\nsizeof(struct dbdma_cmd), GFP_KERNEL);\r\nif (dma_cmd_space == 0) {\r\nprintk(KERN_ERR "mac53c94: couldn't allocate dma "\r\n"command space for %s\n", node->full_name);\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\nstate->dma_cmds = (struct dbdma_cmd *)DBDMA_ALIGN(dma_cmd_space);\r\nmemset(state->dma_cmds, 0, (host->sg_tablesize + 1)\r\n* sizeof(struct dbdma_cmd));\r\nstate->dma_cmd_space = dma_cmd_space;\r\nmac53c94_init(state);\r\nif (request_irq(state->intr, do_mac53c94_interrupt, 0, "53C94",state)) {\r\nprintk(KERN_ERR "mac53C94: can't get irq %d for %s\n",\r\nstate->intr, node->full_name);\r\ngoto out_free_dma;\r\n}\r\nrc = scsi_add_host(host, &mdev->ofdev.dev);\r\nif (rc != 0)\r\ngoto out_release_irq;\r\nscsi_scan_host(host);\r\nreturn 0;\r\nout_release_irq:\r\nfree_irq(state->intr, state);\r\nout_free_dma:\r\nkfree(state->dma_cmd_space);\r\nout_free:\r\nif (state->dma != NULL)\r\niounmap(state->dma);\r\nif (state->regs != NULL)\r\niounmap(state->regs);\r\nscsi_host_put(host);\r\nout_release:\r\nmacio_release_resources(mdev);\r\nreturn rc;\r\n}\r\nstatic int mac53c94_remove(struct macio_dev *mdev)\r\n{\r\nstruct fsc_state *fp = (struct fsc_state *)macio_get_drvdata(mdev);\r\nstruct Scsi_Host *host = fp->host;\r\nscsi_remove_host(host);\r\nfree_irq(fp->intr, fp);\r\nif (fp->regs)\r\niounmap(fp->regs);\r\nif (fp->dma)\r\niounmap(fp->dma);\r\nkfree(fp->dma_cmd_space);\r\nscsi_host_put(host);\r\nmacio_release_resources(mdev);\r\nreturn 0;\r\n}\r\nstatic int __init init_mac53c94(void)\r\n{\r\nreturn macio_register_driver(&mac53c94_driver);\r\n}\r\nstatic void __exit exit_mac53c94(void)\r\n{\r\nreturn macio_unregister_driver(&mac53c94_driver);\r\n}
