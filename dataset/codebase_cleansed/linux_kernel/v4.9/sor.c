static inline struct tegra_sor_state *\r\nto_sor_state(struct drm_connector_state *state)\r\n{\r\nreturn container_of(state, struct tegra_sor_state, base);\r\n}\r\nstatic inline struct tegra_sor *\r\nhost1x_client_to_sor(struct host1x_client *client)\r\n{\r\nreturn container_of(client, struct tegra_sor, client);\r\n}\r\nstatic inline struct tegra_sor *to_sor(struct tegra_output *output)\r\n{\r\nreturn container_of(output, struct tegra_sor, output);\r\n}\r\nstatic inline u32 tegra_sor_readl(struct tegra_sor *sor, unsigned long offset)\r\n{\r\nreturn readl(sor->regs + (offset << 2));\r\n}\r\nstatic inline void tegra_sor_writel(struct tegra_sor *sor, u32 value,\r\nunsigned long offset)\r\n{\r\nwritel(value, sor->regs + (offset << 2));\r\n}\r\nstatic int tegra_sor_set_parent_clock(struct tegra_sor *sor, struct clk *parent)\r\n{\r\nint err;\r\nclk_disable_unprepare(sor->clk);\r\nerr = clk_set_parent(sor->clk, parent);\r\nif (err < 0)\r\nreturn err;\r\nerr = clk_prepare_enable(sor->clk);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic inline struct tegra_clk_sor_brick *to_brick(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct tegra_clk_sor_brick, hw);\r\n}\r\nstatic int tegra_clk_sor_brick_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct tegra_clk_sor_brick *brick = to_brick(hw);\r\nstruct tegra_sor *sor = brick->sor;\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_CLK_SEL_MASK;\r\nswitch (index) {\r\ncase 0:\r\nvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_PCLK;\r\nbreak;\r\ncase 1:\r\nvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_DPCLK;\r\nbreak;\r\n}\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nreturn 0;\r\n}\r\nstatic u8 tegra_clk_sor_brick_get_parent(struct clk_hw *hw)\r\n{\r\nstruct tegra_clk_sor_brick *brick = to_brick(hw);\r\nstruct tegra_sor *sor = brick->sor;\r\nu8 parent = U8_MAX;\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nswitch (value & SOR_CLK_CNTRL_DP_CLK_SEL_MASK) {\r\ncase SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_PCLK:\r\ncase SOR_CLK_CNTRL_DP_CLK_SEL_DIFF_PCLK:\r\nparent = 0;\r\nbreak;\r\ncase SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_DPCLK:\r\ncase SOR_CLK_CNTRL_DP_CLK_SEL_DIFF_DPCLK:\r\nparent = 1;\r\nbreak;\r\n}\r\nreturn parent;\r\n}\r\nstatic struct clk *tegra_clk_sor_brick_register(struct tegra_sor *sor,\r\nconst char *name)\r\n{\r\nstruct tegra_clk_sor_brick *brick;\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nbrick = devm_kzalloc(sor->dev, sizeof(*brick), GFP_KERNEL);\r\nif (!brick)\r\nreturn ERR_PTR(-ENOMEM);\r\nbrick->sor = sor;\r\ninit.name = name;\r\ninit.flags = 0;\r\ninit.parent_names = tegra_clk_sor_brick_parents;\r\ninit.num_parents = ARRAY_SIZE(tegra_clk_sor_brick_parents);\r\ninit.ops = &tegra_clk_sor_brick_ops;\r\nbrick->hw.init = &init;\r\nclk = devm_clk_register(sor->dev, &brick->hw);\r\nif (IS_ERR(clk))\r\nkfree(brick);\r\nreturn clk;\r\n}\r\nstatic int tegra_sor_dp_train_fast(struct tegra_sor *sor,\r\nstruct drm_dp_link *link)\r\n{\r\nunsigned int i;\r\nu8 pattern;\r\nu32 value;\r\nint err;\r\nvalue = SOR_LANE_DRIVE_CURRENT_LANE3(0x40) |\r\nSOR_LANE_DRIVE_CURRENT_LANE2(0x40) |\r\nSOR_LANE_DRIVE_CURRENT_LANE1(0x40) |\r\nSOR_LANE_DRIVE_CURRENT_LANE0(0x40);\r\ntegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT0);\r\nvalue = SOR_LANE_PREEMPHASIS_LANE3(0x0f) |\r\nSOR_LANE_PREEMPHASIS_LANE2(0x0f) |\r\nSOR_LANE_PREEMPHASIS_LANE1(0x0f) |\r\nSOR_LANE_PREEMPHASIS_LANE0(0x0f);\r\ntegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS0);\r\nvalue = SOR_LANE_POSTCURSOR_LANE3(0x00) |\r\nSOR_LANE_POSTCURSOR_LANE2(0x00) |\r\nSOR_LANE_POSTCURSOR_LANE1(0x00) |\r\nSOR_LANE_POSTCURSOR_LANE0(0x00);\r\ntegra_sor_writel(sor, value, SOR_LANE_POSTCURSOR0);\r\ntegra_sor_writel(sor, 0, SOR_LVDS);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\r\nvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\r\nvalue |= SOR_DP_PADCTL_TX_PU(2);\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue |= SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\r\nSOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nusleep_range(10, 100);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\r\nSOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nerr = drm_dp_aux_prepare(sor->aux, DP_SET_ANSI_8B10B);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0, value = 0; i < link->num_lanes; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_NONE |\r\nSOR_DP_TPG_PATTERN_TRAIN1;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\npattern = DP_TRAINING_PATTERN_1;\r\nerr = drm_dp_aux_train(sor->aux, link, pattern);\r\nif (err < 0)\r\nreturn err;\r\nvalue = tegra_sor_readl(sor, SOR_DP_SPARE0);\r\nvalue |= SOR_DP_SPARE_SEQ_ENABLE;\r\nvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\r\nvalue |= SOR_DP_SPARE_MACRO_SOR_CLK;\r\ntegra_sor_writel(sor, value, SOR_DP_SPARE0);\r\nfor (i = 0, value = 0; i < link->num_lanes; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_NONE |\r\nSOR_DP_TPG_PATTERN_TRAIN2;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\npattern = DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_2;\r\nerr = drm_dp_aux_train(sor->aux, link, pattern);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0, value = 0; i < link->num_lanes; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_GALIOS |\r\nSOR_DP_TPG_PATTERN_NONE;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\npattern = DP_TRAINING_PATTERN_DISABLE;\r\nerr = drm_dp_aux_train(sor->aux, link, pattern);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void tegra_sor_dp_term_calibrate(struct tegra_sor *sor)\r\n{\r\nu32 mask = 0x08, adj = 0, value;\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue &= ~SOR_DP_PADCTL_PAD_CAL_PD;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nvalue = tegra_sor_readl(sor, SOR_PLL1);\r\nvalue |= SOR_PLL1_TMDS_TERM;\r\ntegra_sor_writel(sor, value, SOR_PLL1);\r\nwhile (mask) {\r\nadj |= mask;\r\nvalue = tegra_sor_readl(sor, SOR_PLL1);\r\nvalue &= ~SOR_PLL1_TMDS_TERMADJ_MASK;\r\nvalue |= SOR_PLL1_TMDS_TERMADJ(adj);\r\ntegra_sor_writel(sor, value, SOR_PLL1);\r\nusleep_range(100, 200);\r\nvalue = tegra_sor_readl(sor, SOR_PLL1);\r\nif (value & SOR_PLL1_TERM_COMPOUT)\r\nadj &= ~mask;\r\nmask >>= 1;\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_PLL1);\r\nvalue &= ~SOR_PLL1_TMDS_TERMADJ_MASK;\r\nvalue |= SOR_PLL1_TMDS_TERMADJ(adj);\r\ntegra_sor_writel(sor, value, SOR_PLL1);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue |= SOR_DP_PADCTL_PAD_CAL_PD;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\n}\r\nstatic void tegra_sor_super_update(struct tegra_sor *sor)\r\n{\r\ntegra_sor_writel(sor, 0, SOR_SUPER_STATE0);\r\ntegra_sor_writel(sor, 1, SOR_SUPER_STATE0);\r\ntegra_sor_writel(sor, 0, SOR_SUPER_STATE0);\r\n}\r\nstatic void tegra_sor_update(struct tegra_sor *sor)\r\n{\r\ntegra_sor_writel(sor, 0, SOR_STATE0);\r\ntegra_sor_writel(sor, 1, SOR_STATE0);\r\ntegra_sor_writel(sor, 0, SOR_STATE0);\r\n}\r\nstatic int tegra_sor_setup_pwm(struct tegra_sor *sor, unsigned long timeout)\r\n{\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_PWM_DIV);\r\nvalue &= ~SOR_PWM_DIV_MASK;\r\nvalue |= 0x400;\r\ntegra_sor_writel(sor, value, SOR_PWM_DIV);\r\nvalue = tegra_sor_readl(sor, SOR_PWM_CTL);\r\nvalue &= ~SOR_PWM_CTL_DUTY_CYCLE_MASK;\r\nvalue |= 0x400;\r\nvalue &= ~SOR_PWM_CTL_CLK_SEL;\r\nvalue |= SOR_PWM_CTL_TRIGGER;\r\ntegra_sor_writel(sor, value, SOR_PWM_CTL);\r\ntimeout = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_PWM_CTL);\r\nif ((value & SOR_PWM_CTL_TRIGGER) == 0)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_attach(struct tegra_sor *sor)\r\n{\r\nunsigned long value, timeout;\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\r\nvalue |= SOR_SUPER_STATE_HEAD_MODE_AWAKE;\r\nvalue |= SOR_SUPER_STATE_MODE_NORMAL;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE1);\r\ntegra_sor_super_update(sor);\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\r\nvalue |= SOR_SUPER_STATE_ATTACHED;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE1);\r\ntegra_sor_super_update(sor);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_TEST);\r\nif ((value & SOR_TEST_ATTACHED) != 0)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_wakeup(struct tegra_sor *sor)\r\n{\r\nunsigned long value, timeout;\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_TEST);\r\nvalue &= SOR_TEST_HEAD_MODE_MASK;\r\nif (value == SOR_TEST_HEAD_MODE_AWAKE)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_power_up(struct tegra_sor *sor, unsigned long timeout)\r\n{\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nvalue |= SOR_PWR_TRIGGER | SOR_PWR_NORMAL_STATE_PU;\r\ntegra_sor_writel(sor, value, SOR_PWR);\r\ntimeout = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nif ((value & SOR_PWR_TRIGGER) == 0)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_compute_params(struct tegra_sor *sor,\r\nstruct tegra_sor_params *params,\r\nunsigned int tu_size)\r\n{\r\nu64 active_sym, active_count, frac, approx;\r\nu32 active_polarity, active_frac = 0;\r\nconst u64 f = params->precision;\r\ns64 error;\r\nactive_sym = params->ratio * tu_size;\r\nactive_count = div_u64(active_sym, f) * f;\r\nfrac = active_sym - active_count;\r\nif (frac >= (f / 2)) {\r\nactive_polarity = 1;\r\nfrac = f - frac;\r\n} else {\r\nactive_polarity = 0;\r\n}\r\nif (frac != 0) {\r\nfrac = div_u64(f * f, frac);\r\nif (frac <= (15 * f)) {\r\nactive_frac = div_u64(frac, f);\r\nif (active_polarity)\r\nactive_frac++;\r\n} else {\r\nactive_frac = active_polarity ? 1 : 15;\r\n}\r\n}\r\nif (active_frac == 1)\r\nactive_polarity = 0;\r\nif (active_polarity == 1) {\r\nif (active_frac) {\r\napprox = active_count + (active_frac * (f - 1)) * f;\r\napprox = div_u64(approx, active_frac * f);\r\n} else {\r\napprox = active_count + f;\r\n}\r\n} else {\r\nif (active_frac)\r\napprox = active_count + div_u64(f, active_frac);\r\nelse\r\napprox = active_count;\r\n}\r\nerror = div_s64(active_sym - approx, tu_size);\r\nerror *= params->num_clocks;\r\nif (error <= 0 && abs(error) < params->error) {\r\nparams->active_count = div_u64(active_count, f);\r\nparams->active_polarity = active_polarity;\r\nparams->active_frac = active_frac;\r\nparams->error = abs(error);\r\nparams->tu_size = tu_size;\r\nif (error == 0)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int tegra_sor_compute_config(struct tegra_sor *sor,\r\nconst struct drm_display_mode *mode,\r\nstruct tegra_sor_config *config,\r\nstruct drm_dp_link *link)\r\n{\r\nconst u64 f = 100000, link_rate = link->rate * 1000;\r\nconst u64 pclk = mode->clock * 1000;\r\nu64 input, output, watermark, num;\r\nstruct tegra_sor_params params;\r\nu32 num_syms_per_line;\r\nunsigned int i;\r\nif (!link_rate || !link->num_lanes || !pclk || !config->bits_per_pixel)\r\nreturn -EINVAL;\r\noutput = link_rate * 8 * link->num_lanes;\r\ninput = pclk * config->bits_per_pixel;\r\nif (input >= output)\r\nreturn -ERANGE;\r\nmemset(&params, 0, sizeof(params));\r\nparams.ratio = div64_u64(input * f, output);\r\nparams.num_clocks = div_u64(link_rate * mode->hdisplay, pclk);\r\nparams.precision = f;\r\nparams.error = 64 * f;\r\nparams.tu_size = 64;\r\nfor (i = params.tu_size; i >= 32; i--)\r\nif (tegra_sor_compute_params(sor, &params, i))\r\nbreak;\r\nif (params.active_frac == 0) {\r\nconfig->active_polarity = 0;\r\nconfig->active_count = params.active_count;\r\nif (!params.active_polarity)\r\nconfig->active_count--;\r\nconfig->tu_size = params.tu_size;\r\nconfig->active_frac = 1;\r\n} else {\r\nconfig->active_polarity = params.active_polarity;\r\nconfig->active_count = params.active_count;\r\nconfig->active_frac = params.active_frac;\r\nconfig->tu_size = params.tu_size;\r\n}\r\ndev_dbg(sor->dev,\r\n"polarity: %d active count: %d tu size: %d active frac: %d\n",\r\nconfig->active_polarity, config->active_count,\r\nconfig->tu_size, config->active_frac);\r\nwatermark = params.ratio * config->tu_size * (f - params.ratio);\r\nwatermark = div_u64(watermark, f);\r\nwatermark = div_u64(watermark + params.error, f);\r\nconfig->watermark = watermark + (config->bits_per_pixel / 8) + 2;\r\nnum_syms_per_line = (mode->hdisplay * config->bits_per_pixel) *\r\n(link->num_lanes * 8);\r\nif (config->watermark > 30) {\r\nconfig->watermark = 30;\r\ndev_err(sor->dev,\r\n"unable to compute TU size, forcing watermark to %u\n",\r\nconfig->watermark);\r\n} else if (config->watermark > num_syms_per_line) {\r\nconfig->watermark = num_syms_per_line;\r\ndev_err(sor->dev, "watermark too high, forcing to %u\n",\r\nconfig->watermark);\r\n}\r\nnum = ((mode->htotal - mode->hdisplay) - 7) * link_rate;\r\nconfig->hblank_symbols = div_u64(num, pclk);\r\nif (link->capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\r\nconfig->hblank_symbols -= 3;\r\nconfig->hblank_symbols -= 12 / link->num_lanes;\r\nnum = (mode->hdisplay - 25) * link_rate;\r\nconfig->vblank_symbols = div_u64(num, pclk);\r\nconfig->vblank_symbols -= 36 / link->num_lanes + 4;\r\ndev_dbg(sor->dev, "blank symbols: H:%u V:%u\n", config->hblank_symbols,\r\nconfig->vblank_symbols);\r\nreturn 0;\r\n}\r\nstatic void tegra_sor_apply_config(struct tegra_sor *sor,\r\nconst struct tegra_sor_config *config)\r\n{\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL0);\r\nvalue &= ~SOR_DP_LINKCTL_TU_SIZE_MASK;\r\nvalue |= SOR_DP_LINKCTL_TU_SIZE(config->tu_size);\r\ntegra_sor_writel(sor, value, SOR_DP_LINKCTL0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_CONFIG0);\r\nvalue &= ~SOR_DP_CONFIG_WATERMARK_MASK;\r\nvalue |= SOR_DP_CONFIG_WATERMARK(config->watermark);\r\nvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_COUNT_MASK;\r\nvalue |= SOR_DP_CONFIG_ACTIVE_SYM_COUNT(config->active_count);\r\nvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_FRAC_MASK;\r\nvalue |= SOR_DP_CONFIG_ACTIVE_SYM_FRAC(config->active_frac);\r\nif (config->active_polarity)\r\nvalue |= SOR_DP_CONFIG_ACTIVE_SYM_POLARITY;\r\nelse\r\nvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_POLARITY;\r\nvalue |= SOR_DP_CONFIG_ACTIVE_SYM_ENABLE;\r\nvalue |= SOR_DP_CONFIG_DISPARITY_NEGATIVE;\r\ntegra_sor_writel(sor, value, SOR_DP_CONFIG0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_AUDIO_HBLANK_SYMBOLS);\r\nvalue &= ~SOR_DP_AUDIO_HBLANK_SYMBOLS_MASK;\r\nvalue |= config->hblank_symbols & 0xffff;\r\ntegra_sor_writel(sor, value, SOR_DP_AUDIO_HBLANK_SYMBOLS);\r\nvalue = tegra_sor_readl(sor, SOR_DP_AUDIO_VBLANK_SYMBOLS);\r\nvalue &= ~SOR_DP_AUDIO_VBLANK_SYMBOLS_MASK;\r\nvalue |= config->vblank_symbols & 0xffff;\r\ntegra_sor_writel(sor, value, SOR_DP_AUDIO_VBLANK_SYMBOLS);\r\n}\r\nstatic void tegra_sor_mode_set(struct tegra_sor *sor,\r\nconst struct drm_display_mode *mode,\r\nstruct tegra_sor_state *state)\r\n{\r\nstruct tegra_dc *dc = to_tegra_dc(sor->output.encoder.crtc);\r\nunsigned int vbe, vse, hbe, hse, vbs, hbs;\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_STATE1);\r\nvalue &= ~SOR_STATE_ASY_PIXELDEPTH_MASK;\r\nvalue &= ~SOR_STATE_ASY_CRC_MODE_MASK;\r\nvalue &= ~SOR_STATE_ASY_OWNER_MASK;\r\nvalue |= SOR_STATE_ASY_CRC_MODE_COMPLETE |\r\nSOR_STATE_ASY_OWNER(dc->pipe + 1);\r\nif (mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nvalue &= ~SOR_STATE_ASY_HSYNCPOL;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nvalue |= SOR_STATE_ASY_HSYNCPOL;\r\nif (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nvalue &= ~SOR_STATE_ASY_VSYNCPOL;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nvalue |= SOR_STATE_ASY_VSYNCPOL;\r\nswitch (state->bpc) {\r\ncase 16:\r\nvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_48_444;\r\nbreak;\r\ncase 12:\r\nvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_36_444;\r\nbreak;\r\ncase 10:\r\nvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_30_444;\r\nbreak;\r\ncase 8:\r\nvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_24_444;\r\nbreak;\r\ncase 6:\r\nvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_18_444;\r\nbreak;\r\ndefault:\r\nvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_24_444;\r\nbreak;\r\n}\r\ntegra_sor_writel(sor, value, SOR_STATE1);\r\nvalue = ((mode->vtotal & 0x7fff) << 16) | (mode->htotal & 0x7fff);\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE1(dc->pipe));\r\nvse = mode->vsync_end - mode->vsync_start - 1;\r\nhse = mode->hsync_end - mode->hsync_start - 1;\r\nvalue = ((vse & 0x7fff) << 16) | (hse & 0x7fff);\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE2(dc->pipe));\r\nvbe = vse + (mode->vtotal - mode->vsync_end);\r\nhbe = hse + (mode->htotal - mode->hsync_end);\r\nvalue = ((vbe & 0x7fff) << 16) | (hbe & 0x7fff);\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE3(dc->pipe));\r\nvbs = vbe + mode->vdisplay;\r\nhbs = hbe + mode->hdisplay;\r\nvalue = ((vbs & 0x7fff) << 16) | (hbs & 0x7fff);\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE4(dc->pipe));\r\ntegra_sor_writel(sor, 0x001, SOR_HEAD_STATE5(dc->pipe));\r\n}\r\nstatic int tegra_sor_detach(struct tegra_sor *sor)\r\n{\r\nunsigned long value, timeout;\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\r\nvalue &= ~SOR_SUPER_STATE_MODE_NORMAL;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE1);\r\ntegra_sor_super_update(sor);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nif (value & SOR_PWR_MODE_SAFE)\r\nbreak;\r\n}\r\nif ((value & SOR_PWR_MODE_SAFE) == 0)\r\nreturn -ETIMEDOUT;\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\r\nvalue &= ~SOR_SUPER_STATE_HEAD_MODE_MASK;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE1);\r\ntegra_sor_super_update(sor);\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE1);\r\nvalue &= ~SOR_SUPER_STATE_ATTACHED;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE1);\r\ntegra_sor_super_update(sor);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_TEST);\r\nif ((value & SOR_TEST_ATTACHED) == 0)\r\nbreak;\r\nusleep_range(25, 100);\r\n}\r\nif ((value & SOR_TEST_ATTACHED) != 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_power_down(struct tegra_sor *sor)\r\n{\r\nunsigned long value, timeout;\r\nint err;\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nvalue &= ~SOR_PWR_NORMAL_STATE_PU;\r\nvalue |= SOR_PWR_TRIGGER;\r\ntegra_sor_writel(sor, value, SOR_PWR);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nif ((value & SOR_PWR_TRIGGER) == 0)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nif ((value & SOR_PWR_TRIGGER) != 0)\r\nreturn -ETIMEDOUT;\r\nerr = tegra_sor_set_parent_clock(sor, sor->clk_safe);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set safe parent clock: %d\n", err);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue &= ~(SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_0 |\r\nSOR_DP_PADCTL_PD_TXD_1 | SOR_DP_PADCTL_PD_TXD_2);\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nvalue = SOR_LANE_SEQ_CTL_TRIGGER | SOR_LANE_SEQ_CTL_SEQUENCE_UP |\r\nSOR_LANE_SEQ_CTL_POWER_STATE_DOWN;\r\ntegra_sor_writel(sor, value, SOR_LANE_SEQ_CTL);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\r\nif ((value & SOR_LANE_SEQ_CTL_TRIGGER) == 0)\r\nbreak;\r\nusleep_range(25, 100);\r\n}\r\nif ((value & SOR_LANE_SEQ_CTL_TRIGGER) != 0)\r\nreturn -ETIMEDOUT;\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue |= SOR_PLL2_PORT_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL0);\r\nvalue |= SOR_PLL0_VCOPD | SOR_PLL0_PWR;\r\ntegra_sor_writel(sor, value, SOR_PLL0);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue |= SOR_PLL2_SEQ_PLLCAPPD;\r\nvalue |= SOR_PLL2_SEQ_PLLCAPPD_ENFORCE;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nusleep_range(20, 100);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_crc_wait(struct tegra_sor *sor, unsigned long timeout)\r\n{\r\nu32 value;\r\ntimeout = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_CRCA);\r\nif (value & SOR_CRCA_VALID)\r\nreturn 0;\r\nusleep_range(100, 200);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_show_crc(struct seq_file *s, void *data)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct tegra_sor *sor = node->info_ent->data;\r\nstruct drm_crtc *crtc = sor->output.encoder.crtc;\r\nstruct drm_device *drm = node->minor->dev;\r\nint err = 0;\r\nu32 value;\r\ndrm_modeset_lock_all(drm);\r\nif (!crtc || !crtc->state->active) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_STATE1);\r\nvalue &= ~SOR_STATE_ASY_CRC_MODE_MASK;\r\ntegra_sor_writel(sor, value, SOR_STATE1);\r\nvalue = tegra_sor_readl(sor, SOR_CRC_CNTRL);\r\nvalue |= SOR_CRC_CNTRL_ENABLE;\r\ntegra_sor_writel(sor, value, SOR_CRC_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_TEST);\r\nvalue &= ~SOR_TEST_CRC_POST_SERIALIZE;\r\ntegra_sor_writel(sor, value, SOR_TEST);\r\nerr = tegra_sor_crc_wait(sor, 100);\r\nif (err < 0)\r\ngoto unlock;\r\ntegra_sor_writel(sor, SOR_CRCA_RESET, SOR_CRCA);\r\nvalue = tegra_sor_readl(sor, SOR_CRCB);\r\nseq_printf(s, "%08x\n", value);\r\nunlock:\r\ndrm_modeset_unlock_all(drm);\r\nreturn err;\r\n}\r\nstatic int tegra_sor_show_regs(struct seq_file *s, void *data)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct tegra_sor *sor = node->info_ent->data;\r\nstruct drm_crtc *crtc = sor->output.encoder.crtc;\r\nstruct drm_device *drm = node->minor->dev;\r\nint err = 0;\r\ndrm_modeset_lock_all(drm);\r\nif (!crtc || !crtc->state->active) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\n#define DUMP_REG(name) \\r\nseq_printf(s, "%-38s %#05x %08x\n", #name, name, \\r\ntegra_sor_readl(sor, name))\r\nDUMP_REG(SOR_CTXSW);\r\nDUMP_REG(SOR_SUPER_STATE0);\r\nDUMP_REG(SOR_SUPER_STATE1);\r\nDUMP_REG(SOR_STATE0);\r\nDUMP_REG(SOR_STATE1);\r\nDUMP_REG(SOR_HEAD_STATE0(0));\r\nDUMP_REG(SOR_HEAD_STATE0(1));\r\nDUMP_REG(SOR_HEAD_STATE1(0));\r\nDUMP_REG(SOR_HEAD_STATE1(1));\r\nDUMP_REG(SOR_HEAD_STATE2(0));\r\nDUMP_REG(SOR_HEAD_STATE2(1));\r\nDUMP_REG(SOR_HEAD_STATE3(0));\r\nDUMP_REG(SOR_HEAD_STATE3(1));\r\nDUMP_REG(SOR_HEAD_STATE4(0));\r\nDUMP_REG(SOR_HEAD_STATE4(1));\r\nDUMP_REG(SOR_HEAD_STATE5(0));\r\nDUMP_REG(SOR_HEAD_STATE5(1));\r\nDUMP_REG(SOR_CRC_CNTRL);\r\nDUMP_REG(SOR_DP_DEBUG_MVID);\r\nDUMP_REG(SOR_CLK_CNTRL);\r\nDUMP_REG(SOR_CAP);\r\nDUMP_REG(SOR_PWR);\r\nDUMP_REG(SOR_TEST);\r\nDUMP_REG(SOR_PLL0);\r\nDUMP_REG(SOR_PLL1);\r\nDUMP_REG(SOR_PLL2);\r\nDUMP_REG(SOR_PLL3);\r\nDUMP_REG(SOR_CSTM);\r\nDUMP_REG(SOR_LVDS);\r\nDUMP_REG(SOR_CRCA);\r\nDUMP_REG(SOR_CRCB);\r\nDUMP_REG(SOR_BLANK);\r\nDUMP_REG(SOR_SEQ_CTL);\r\nDUMP_REG(SOR_LANE_SEQ_CTL);\r\nDUMP_REG(SOR_SEQ_INST(0));\r\nDUMP_REG(SOR_SEQ_INST(1));\r\nDUMP_REG(SOR_SEQ_INST(2));\r\nDUMP_REG(SOR_SEQ_INST(3));\r\nDUMP_REG(SOR_SEQ_INST(4));\r\nDUMP_REG(SOR_SEQ_INST(5));\r\nDUMP_REG(SOR_SEQ_INST(6));\r\nDUMP_REG(SOR_SEQ_INST(7));\r\nDUMP_REG(SOR_SEQ_INST(8));\r\nDUMP_REG(SOR_SEQ_INST(9));\r\nDUMP_REG(SOR_SEQ_INST(10));\r\nDUMP_REG(SOR_SEQ_INST(11));\r\nDUMP_REG(SOR_SEQ_INST(12));\r\nDUMP_REG(SOR_SEQ_INST(13));\r\nDUMP_REG(SOR_SEQ_INST(14));\r\nDUMP_REG(SOR_SEQ_INST(15));\r\nDUMP_REG(SOR_PWM_DIV);\r\nDUMP_REG(SOR_PWM_CTL);\r\nDUMP_REG(SOR_VCRC_A0);\r\nDUMP_REG(SOR_VCRC_A1);\r\nDUMP_REG(SOR_VCRC_B0);\r\nDUMP_REG(SOR_VCRC_B1);\r\nDUMP_REG(SOR_CCRC_A0);\r\nDUMP_REG(SOR_CCRC_A1);\r\nDUMP_REG(SOR_CCRC_B0);\r\nDUMP_REG(SOR_CCRC_B1);\r\nDUMP_REG(SOR_EDATA_A0);\r\nDUMP_REG(SOR_EDATA_A1);\r\nDUMP_REG(SOR_EDATA_B0);\r\nDUMP_REG(SOR_EDATA_B1);\r\nDUMP_REG(SOR_COUNT_A0);\r\nDUMP_REG(SOR_COUNT_A1);\r\nDUMP_REG(SOR_COUNT_B0);\r\nDUMP_REG(SOR_COUNT_B1);\r\nDUMP_REG(SOR_DEBUG_A0);\r\nDUMP_REG(SOR_DEBUG_A1);\r\nDUMP_REG(SOR_DEBUG_B0);\r\nDUMP_REG(SOR_DEBUG_B1);\r\nDUMP_REG(SOR_TRIG);\r\nDUMP_REG(SOR_MSCHECK);\r\nDUMP_REG(SOR_XBAR_CTRL);\r\nDUMP_REG(SOR_XBAR_POL);\r\nDUMP_REG(SOR_DP_LINKCTL0);\r\nDUMP_REG(SOR_DP_LINKCTL1);\r\nDUMP_REG(SOR_LANE_DRIVE_CURRENT0);\r\nDUMP_REG(SOR_LANE_DRIVE_CURRENT1);\r\nDUMP_REG(SOR_LANE4_DRIVE_CURRENT0);\r\nDUMP_REG(SOR_LANE4_DRIVE_CURRENT1);\r\nDUMP_REG(SOR_LANE_PREEMPHASIS0);\r\nDUMP_REG(SOR_LANE_PREEMPHASIS1);\r\nDUMP_REG(SOR_LANE4_PREEMPHASIS0);\r\nDUMP_REG(SOR_LANE4_PREEMPHASIS1);\r\nDUMP_REG(SOR_LANE_POSTCURSOR0);\r\nDUMP_REG(SOR_LANE_POSTCURSOR1);\r\nDUMP_REG(SOR_DP_CONFIG0);\r\nDUMP_REG(SOR_DP_CONFIG1);\r\nDUMP_REG(SOR_DP_MN0);\r\nDUMP_REG(SOR_DP_MN1);\r\nDUMP_REG(SOR_DP_PADCTL0);\r\nDUMP_REG(SOR_DP_PADCTL1);\r\nDUMP_REG(SOR_DP_DEBUG0);\r\nDUMP_REG(SOR_DP_DEBUG1);\r\nDUMP_REG(SOR_DP_SPARE0);\r\nDUMP_REG(SOR_DP_SPARE1);\r\nDUMP_REG(SOR_DP_AUDIO_CTRL);\r\nDUMP_REG(SOR_DP_AUDIO_HBLANK_SYMBOLS);\r\nDUMP_REG(SOR_DP_AUDIO_VBLANK_SYMBOLS);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_HEADER);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK0);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK1);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK2);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK3);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK4);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK5);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK6);\r\nDUMP_REG(SOR_DP_TPG);\r\nDUMP_REG(SOR_DP_TPG_CONFIG);\r\nDUMP_REG(SOR_DP_LQ_CSTM0);\r\nDUMP_REG(SOR_DP_LQ_CSTM1);\r\nDUMP_REG(SOR_DP_LQ_CSTM2);\r\n#undef DUMP_REG\r\nunlock:\r\ndrm_modeset_unlock_all(drm);\r\nreturn err;\r\n}\r\nstatic int tegra_sor_debugfs_init(struct tegra_sor *sor,\r\nstruct drm_minor *minor)\r\n{\r\nconst char *name = sor->soc->supports_dp ? "sor1" : "sor";\r\nunsigned int i;\r\nint err;\r\nsor->debugfs = debugfs_create_dir(name, minor->debugfs_root);\r\nif (!sor->debugfs)\r\nreturn -ENOMEM;\r\nsor->debugfs_files = kmemdup(debugfs_files, sizeof(debugfs_files),\r\nGFP_KERNEL);\r\nif (!sor->debugfs_files) {\r\nerr = -ENOMEM;\r\ngoto remove;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(debugfs_files); i++)\r\nsor->debugfs_files[i].data = sor;\r\nerr = drm_debugfs_create_files(sor->debugfs_files,\r\nARRAY_SIZE(debugfs_files),\r\nsor->debugfs, minor);\r\nif (err < 0)\r\ngoto free;\r\nsor->minor = minor;\r\nreturn 0;\r\nfree:\r\nkfree(sor->debugfs_files);\r\nsor->debugfs_files = NULL;\r\nremove:\r\ndebugfs_remove_recursive(sor->debugfs);\r\nsor->debugfs = NULL;\r\nreturn err;\r\n}\r\nstatic void tegra_sor_debugfs_exit(struct tegra_sor *sor)\r\n{\r\ndrm_debugfs_remove_files(sor->debugfs_files, ARRAY_SIZE(debugfs_files),\r\nsor->minor);\r\nsor->minor = NULL;\r\nkfree(sor->debugfs_files);\r\nsor->debugfs_files = NULL;\r\ndebugfs_remove_recursive(sor->debugfs);\r\nsor->debugfs = NULL;\r\n}\r\nstatic void tegra_sor_connector_reset(struct drm_connector *connector)\r\n{\r\nstruct tegra_sor_state *state;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn;\r\nif (connector->state) {\r\n__drm_atomic_helper_connector_destroy_state(connector->state);\r\nkfree(connector->state);\r\n}\r\n__drm_atomic_helper_connector_reset(connector, &state->base);\r\n}\r\nstatic enum drm_connector_status\r\ntegra_sor_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct tegra_output *output = connector_to_output(connector);\r\nstruct tegra_sor *sor = to_sor(output);\r\nif (sor->aux)\r\nreturn drm_dp_aux_detect(sor->aux);\r\nreturn tegra_output_connector_detect(connector, force);\r\n}\r\nstatic struct drm_connector_state *\r\ntegra_sor_connector_duplicate_state(struct drm_connector *connector)\r\n{\r\nstruct tegra_sor_state *state = to_sor_state(connector->state);\r\nstruct tegra_sor_state *copy;\r\ncopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\r\nif (!copy)\r\nreturn NULL;\r\n__drm_atomic_helper_connector_duplicate_state(connector, &copy->base);\r\nreturn &copy->base;\r\n}\r\nstatic int tegra_sor_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct tegra_output *output = connector_to_output(connector);\r\nstruct tegra_sor *sor = to_sor(output);\r\nint err;\r\nif (sor->aux)\r\ndrm_dp_aux_enable(sor->aux);\r\nerr = tegra_output_connector_get_modes(connector);\r\nif (sor->aux)\r\ndrm_dp_aux_disable(sor->aux);\r\nreturn err;\r\n}\r\nstatic enum drm_mode_status\r\ntegra_sor_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock > 340000)\r\nreturn MODE_NOCLOCK;\r\nreturn MODE_OK;\r\n}\r\nstatic void tegra_sor_edp_disable(struct drm_encoder *encoder)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\r\nstruct tegra_sor *sor = to_sor(output);\r\nu32 value;\r\nint err;\r\nif (output->panel)\r\ndrm_panel_disable(output->panel);\r\nerr = tegra_sor_detach(sor);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to detach SOR: %d\n", err);\r\ntegra_sor_writel(sor, 0, SOR_STATE1);\r\ntegra_sor_update(sor);\r\nif (dc) {\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue &= ~SOR_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\r\ntegra_dc_commit(dc);\r\n}\r\nerr = tegra_sor_power_down(sor);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power down SOR: %d\n", err);\r\nif (sor->aux) {\r\nerr = drm_dp_aux_disable(sor->aux);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to disable DP: %d\n", err);\r\n}\r\nerr = tegra_io_rail_power_off(TEGRA_IO_RAIL_LVDS);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power off I/O rail: %d\n", err);\r\nif (output->panel)\r\ndrm_panel_unprepare(output->panel);\r\npm_runtime_put(sor->dev);\r\n}\r\nstatic void tegra_sor_edp_enable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_display_mode *mode = &encoder->crtc->state->adjusted_mode;\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\r\nstruct tegra_sor *sor = to_sor(output);\r\nstruct tegra_sor_config config;\r\nstruct tegra_sor_state *state;\r\nstruct drm_dp_link link;\r\nu8 rate, lanes;\r\nunsigned int i;\r\nint err = 0;\r\nu32 value;\r\nstate = to_sor_state(output->connector.state);\r\npm_runtime_get_sync(sor->dev);\r\nif (output->panel)\r\ndrm_panel_prepare(output->panel);\r\nerr = drm_dp_aux_enable(sor->aux);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to enable DP: %d\n", err);\r\nerr = drm_dp_link_probe(sor->aux, &link);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to probe eDP link: %d\n", err);\r\nreturn;\r\n}\r\nerr = tegra_sor_set_parent_clock(sor, sor->clk_safe);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set safe parent clock: %d\n", err);\r\nmemset(&config, 0, sizeof(config));\r\nconfig.bits_per_pixel = state->bpc * 3;\r\nerr = tegra_sor_compute_config(sor, mode, &config, &link);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to compute configuration: %d\n", err);\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_CLK_SEL_MASK;\r\nvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_DPCLK;\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue &= ~SOR_PLL2_BANDGAP_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL3);\r\nvalue |= SOR_PLL3_PLL_VDD_MODE_3V3;\r\ntegra_sor_writel(sor, value, SOR_PLL3);\r\nvalue = SOR_PLL0_ICHPMP(0xf) | SOR_PLL0_VCOCAP_RST |\r\nSOR_PLL0_PLLREG_LEVEL_V45 | SOR_PLL0_RESISTOR_EXT;\r\ntegra_sor_writel(sor, value, SOR_PLL0);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue |= SOR_PLL2_SEQ_PLLCAPPD;\r\nvalue &= ~SOR_PLL2_SEQ_PLLCAPPD_ENFORCE;\r\nvalue |= SOR_PLL2_LVDS_ENABLE;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nvalue = SOR_PLL1_TERM_COMPOUT | SOR_PLL1_TMDS_TERM;\r\ntegra_sor_writel(sor, value, SOR_PLL1);\r\nwhile (true) {\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nif ((value & SOR_PLL2_SEQ_PLLCAPPD_ENFORCE) == 0)\r\nbreak;\r\nusleep_range(250, 1000);\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue &= ~SOR_PLL2_POWERDOWN_OVERRIDE;\r\nvalue &= ~SOR_PLL2_PORT_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\r\nvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED_G1_62;\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue |= SOR_PLL2_SEQ_PLLCAPPD_ENFORCE | SOR_PLL2_PORT_POWERDOWN |\r\nSOR_PLL2_BANDGAP_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nvalue = tegra_sor_readl(sor, SOR_PLL0);\r\nvalue |= SOR_PLL0_VCOPD | SOR_PLL0_PWR;\r\ntegra_sor_writel(sor, value, SOR_PLL0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue &= ~SOR_DP_PADCTL_PAD_CAL_PD;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nerr = tegra_io_rail_power_on(TEGRA_IO_RAIL_LVDS);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power on I/O rail: %d\n", err);\r\nusleep_range(5, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue &= ~SOR_PLL2_BANDGAP_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL0);\r\nvalue &= ~SOR_PLL0_VCOPD;\r\nvalue &= ~SOR_PLL0_PWR;\r\ntegra_sor_writel(sor, value, SOR_PLL0);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue &= ~SOR_PLL2_SEQ_PLLCAPPD_ENFORCE;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nusleep_range(200, 1000);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue &= ~SOR_PLL2_PORT_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nfor (value = 0, i = 0; i < 5; i++)\r\nvalue |= SOR_XBAR_CTRL_LINK0_XSEL(i, sor->soc->xbar_cfg[i]) |\r\nSOR_XBAR_CTRL_LINK1_XSEL(i, i);\r\ntegra_sor_writel(sor, 0x00000000, SOR_XBAR_POL);\r\ntegra_sor_writel(sor, value, SOR_XBAR_CTRL);\r\nerr = tegra_sor_set_parent_clock(sor, sor->clk_dp);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set parent clock: %d\n", err);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nif (link.num_lanes <= 2)\r\nvalue &= ~(SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_2);\r\nelse\r\nvalue |= SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_2;\r\nif (link.num_lanes <= 1)\r\nvalue &= ~SOR_DP_PADCTL_PD_TXD_1;\r\nelse\r\nvalue |= SOR_DP_PADCTL_PD_TXD_1;\r\nif (link.num_lanes == 0)\r\nvalue &= ~SOR_DP_PADCTL_PD_TXD_0;\r\nelse\r\nvalue |= SOR_DP_PADCTL_PD_TXD_0;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL0);\r\nvalue &= ~SOR_DP_LINKCTL_LANE_COUNT_MASK;\r\nvalue |= SOR_DP_LINKCTL_LANE_COUNT(link.num_lanes);\r\ntegra_sor_writel(sor, value, SOR_DP_LINKCTL0);\r\nvalue = SOR_LANE_SEQ_CTL_TRIGGER | SOR_LANE_SEQ_CTL_SEQUENCE_DOWN |\r\nSOR_LANE_SEQ_CTL_POWER_STATE_UP;\r\ntegra_sor_writel(sor, value, SOR_LANE_SEQ_CTL);\r\nwhile (true) {\r\nvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\r\nif ((value & SOR_LANE_SEQ_CTL_TRIGGER) == 0)\r\nbreak;\r\nusleep_range(250, 1000);\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\r\nvalue |= drm_dp_link_rate_to_bw_code(link.rate) << 2;\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\ntegra_sor_apply_config(sor, &config);\r\nvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL0);\r\nvalue |= SOR_DP_LINKCTL_ENABLE;\r\nvalue |= SOR_DP_LINKCTL_ENHANCED_FRAME;\r\ntegra_sor_writel(sor, value, SOR_DP_LINKCTL0);\r\nfor (i = 0, value = 0; i < 4; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_GALIOS |\r\nSOR_DP_TPG_PATTERN_NONE;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue |= SOR_DP_PADCTL_PAD_CAL_PD;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nerr = drm_dp_link_probe(sor->aux, &link);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to probe eDP link: %d\n", err);\r\nerr = drm_dp_link_power_up(sor->aux, &link);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power up eDP link: %d\n", err);\r\nerr = drm_dp_link_configure(sor->aux, &link);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to configure eDP link: %d\n", err);\r\nrate = drm_dp_link_rate_to_bw_code(link.rate);\r\nlanes = link.num_lanes;\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\r\nvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED(rate);\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL0);\r\nvalue &= ~SOR_DP_LINKCTL_LANE_COUNT_MASK;\r\nvalue |= SOR_DP_LINKCTL_LANE_COUNT(lanes);\r\nif (link.capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\r\nvalue |= SOR_DP_LINKCTL_ENHANCED_FRAME;\r\ntegra_sor_writel(sor, value, SOR_DP_LINKCTL0);\r\nfor (i = 0; i < link.num_lanes; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_GALIOS |\r\nSOR_DP_TPG_PATTERN_NONE;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\nerr = tegra_sor_dp_train_fast(sor, &link);\r\nif (err < 0)\r\ndev_err(sor->dev, "DP fast link training failed: %d\n", err);\r\ndev_dbg(sor->dev, "fast link training succeeded\n");\r\nerr = tegra_sor_power_up(sor, 250);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power up SOR: %d\n", err);\r\nvalue = SOR_CSTM_LVDS | SOR_CSTM_LINK_ACT_A | SOR_CSTM_LINK_ACT_B |\r\nSOR_CSTM_UPPER;\r\ntegra_sor_writel(sor, value, SOR_CSTM);\r\nvalue = tegra_sor_readl(sor, SOR_STATE1);\r\nvalue &= ~SOR_STATE_ASY_PROTOCOL_MASK;\r\nvalue |= SOR_STATE_ASY_PROTOCOL_DP_A;\r\ntegra_sor_writel(sor, value, SOR_STATE1);\r\ntegra_sor_mode_set(sor, mode, state);\r\nerr = tegra_sor_setup_pwm(sor, 250);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to setup PWM: %d\n", err);\r\ntegra_sor_update(sor);\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue |= SOR_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\r\ntegra_dc_commit(dc);\r\nerr = tegra_sor_attach(sor);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to attach SOR: %d\n", err);\r\nerr = tegra_sor_wakeup(sor);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to enable DC: %d\n", err);\r\nif (output->panel)\r\ndrm_panel_enable(output->panel);\r\n}\r\nstatic int\r\ntegra_sor_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_sor_state *state = to_sor_state(conn_state);\r\nstruct tegra_dc *dc = to_tegra_dc(conn_state->crtc);\r\nunsigned long pclk = crtc_state->mode.clock * 1000;\r\nstruct tegra_sor *sor = to_sor(output);\r\nstruct drm_display_info *info;\r\nint err;\r\ninfo = &output->connector.display_info;\r\nerr = tegra_dc_state_setup_clock(dc, crtc_state, sor->clk_parent,\r\npclk, 0);\r\nif (err < 0) {\r\ndev_err(output->dev, "failed to setup CRTC state: %d\n", err);\r\nreturn err;\r\n}\r\nswitch (info->bpc) {\r\ncase 8:\r\ncase 6:\r\nstate->bpc = info->bpc;\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("%u bits-per-color not supported\n", info->bpc);\r\nstate->bpc = 8;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 tegra_sor_hdmi_subpack(const u8 *ptr, size_t size)\r\n{\r\nu32 value = 0;\r\nsize_t i;\r\nfor (i = size; i > 0; i--)\r\nvalue = (value << 8) | ptr[i - 1];\r\nreturn value;\r\n}\r\nstatic void tegra_sor_hdmi_write_infopack(struct tegra_sor *sor,\r\nconst void *data, size_t size)\r\n{\r\nconst u8 *ptr = data;\r\nunsigned long offset;\r\nsize_t i, j;\r\nu32 value;\r\nswitch (ptr[0]) {\r\ncase HDMI_INFOFRAME_TYPE_AVI:\r\noffset = SOR_HDMI_AVI_INFOFRAME_HEADER;\r\nbreak;\r\ncase HDMI_INFOFRAME_TYPE_AUDIO:\r\noffset = SOR_HDMI_AUDIO_INFOFRAME_HEADER;\r\nbreak;\r\ncase HDMI_INFOFRAME_TYPE_VENDOR:\r\noffset = SOR_HDMI_VSI_INFOFRAME_HEADER;\r\nbreak;\r\ndefault:\r\ndev_err(sor->dev, "unsupported infoframe type: %02x\n",\r\nptr[0]);\r\nreturn;\r\n}\r\nvalue = INFOFRAME_HEADER_TYPE(ptr[0]) |\r\nINFOFRAME_HEADER_VERSION(ptr[1]) |\r\nINFOFRAME_HEADER_LEN(ptr[2]);\r\ntegra_sor_writel(sor, value, offset);\r\noffset++;\r\nfor (i = 3, j = 0; i < size; i += 7, j += 8) {\r\nsize_t rem = size - i, num = min_t(size_t, rem, 4);\r\nvalue = tegra_sor_hdmi_subpack(&ptr[i], num);\r\ntegra_sor_writel(sor, value, offset++);\r\nnum = min_t(size_t, rem - num, 3);\r\nvalue = tegra_sor_hdmi_subpack(&ptr[i + 4], num);\r\ntegra_sor_writel(sor, value, offset++);\r\n}\r\n}\r\nstatic int\r\ntegra_sor_hdmi_setup_avi_infoframe(struct tegra_sor *sor,\r\nconst struct drm_display_mode *mode)\r\n{\r\nu8 buffer[HDMI_INFOFRAME_SIZE(AVI)];\r\nstruct hdmi_avi_infoframe frame;\r\nu32 value;\r\nint err;\r\nvalue = tegra_sor_readl(sor, SOR_HDMI_AVI_INFOFRAME_CTRL);\r\nvalue &= ~INFOFRAME_CTRL_SINGLE;\r\nvalue &= ~INFOFRAME_CTRL_OTHER;\r\nvalue &= ~INFOFRAME_CTRL_ENABLE;\r\ntegra_sor_writel(sor, value, SOR_HDMI_AVI_INFOFRAME_CTRL);\r\nerr = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to setup AVI infoframe: %d\n", err);\r\nreturn err;\r\n}\r\nerr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to pack AVI infoframe: %d\n", err);\r\nreturn err;\r\n}\r\ntegra_sor_hdmi_write_infopack(sor, buffer, err);\r\nvalue = tegra_sor_readl(sor, SOR_HDMI_AVI_INFOFRAME_CTRL);\r\nvalue |= INFOFRAME_CTRL_CHECKSUM_ENABLE;\r\nvalue |= INFOFRAME_CTRL_ENABLE;\r\ntegra_sor_writel(sor, value, SOR_HDMI_AVI_INFOFRAME_CTRL);\r\nreturn 0;\r\n}\r\nstatic void tegra_sor_hdmi_disable_audio_infoframe(struct tegra_sor *sor)\r\n{\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_HDMI_AUDIO_INFOFRAME_CTRL);\r\nvalue &= ~INFOFRAME_CTRL_ENABLE;\r\ntegra_sor_writel(sor, value, SOR_HDMI_AUDIO_INFOFRAME_CTRL);\r\n}\r\nstatic struct tegra_sor_hdmi_settings *\r\ntegra_sor_hdmi_find_settings(struct tegra_sor *sor, unsigned long frequency)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < sor->num_settings; i++)\r\nif (frequency <= sor->settings[i].frequency)\r\nreturn &sor->settings[i];\r\nreturn NULL;\r\n}\r\nstatic void tegra_sor_hdmi_disable(struct drm_encoder *encoder)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\r\nstruct tegra_sor *sor = to_sor(output);\r\nu32 value;\r\nint err;\r\nerr = tegra_sor_detach(sor);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to detach SOR: %d\n", err);\r\ntegra_sor_writel(sor, 0, SOR_STATE1);\r\ntegra_sor_update(sor);\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue &= ~SOR1_TIMING_CYA;\r\nvalue &= ~SOR1_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\r\ntegra_dc_commit(dc);\r\nerr = tegra_sor_power_down(sor);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power down SOR: %d\n", err);\r\nerr = tegra_io_rail_power_off(TEGRA_IO_RAIL_HDMI);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power off HDMI rail: %d\n", err);\r\npm_runtime_put(sor->dev);\r\n}\r\nstatic void tegra_sor_hdmi_enable(struct drm_encoder *encoder)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nunsigned int h_ref_to_sync = 1, pulse_start, max_ac;\r\nstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\r\nstruct tegra_sor_hdmi_settings *settings;\r\nstruct tegra_sor *sor = to_sor(output);\r\nstruct tegra_sor_state *state;\r\nstruct drm_display_mode *mode;\r\nunsigned int div, i;\r\nu32 value;\r\nint err;\r\nstate = to_sor_state(output->connector.state);\r\nmode = &encoder->crtc->state->adjusted_mode;\r\npm_runtime_get_sync(sor->dev);\r\nerr = tegra_sor_set_parent_clock(sor, sor->clk_safe);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set safe parent clock: %d\n", err);\r\ndiv = clk_get_rate(sor->clk) / 1000000 * 4;\r\nerr = tegra_io_rail_power_on(TEGRA_IO_RAIL_HDMI);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power on HDMI rail: %d\n", err);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue &= ~SOR_PLL2_BANDGAP_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL3);\r\nvalue &= ~SOR_PLL3_PLL_VDD_MODE_3V3;\r\ntegra_sor_writel(sor, value, SOR_PLL3);\r\nvalue = tegra_sor_readl(sor, SOR_PLL0);\r\nvalue &= ~SOR_PLL0_VCOPD;\r\nvalue &= ~SOR_PLL0_PWR;\r\ntegra_sor_writel(sor, value, SOR_PLL0);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue &= ~SOR_PLL2_SEQ_PLLCAPPD_ENFORCE;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nusleep_range(200, 400);\r\nvalue = tegra_sor_readl(sor, SOR_PLL2);\r\nvalue &= ~SOR_PLL2_POWERDOWN_OVERRIDE;\r\nvalue &= ~SOR_PLL2_PORT_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL2);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue |= SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_0 |\r\nSOR_DP_PADCTL_PD_TXD_1 | SOR_DP_PADCTL_PD_TXD_2;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nwhile (true) {\r\nvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\r\nif ((value & SOR_LANE_SEQ_CTL_STATE_BUSY) == 0)\r\nbreak;\r\nusleep_range(250, 1000);\r\n}\r\nvalue = SOR_LANE_SEQ_CTL_TRIGGER | SOR_LANE_SEQ_CTL_SEQUENCE_DOWN |\r\nSOR_LANE_SEQ_CTL_POWER_STATE_UP | SOR_LANE_SEQ_CTL_DELAY(5);\r\ntegra_sor_writel(sor, value, SOR_LANE_SEQ_CTL);\r\nwhile (true) {\r\nvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\r\nif ((value & SOR_LANE_SEQ_CTL_TRIGGER) == 0)\r\nbreak;\r\nusleep_range(250, 1000);\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\r\nvalue &= ~SOR_CLK_CNTRL_DP_CLK_SEL_MASK;\r\nif (mode->clock < 340000)\r\nvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED_G2_70;\r\nelse\r\nvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED_G5_40;\r\nvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_PCLK;\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_DP_SPARE0);\r\nvalue |= SOR_DP_SPARE_DISP_VIDEO_PREAMBLE;\r\nvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\r\nvalue |= SOR_DP_SPARE_SEQ_ENABLE;\r\ntegra_sor_writel(sor, value, SOR_DP_SPARE0);\r\nvalue = SOR_SEQ_CTL_PU_PC(0) | SOR_SEQ_CTL_PU_PC_ALT(0) |\r\nSOR_SEQ_CTL_PD_PC(8) | SOR_SEQ_CTL_PD_PC_ALT(8);\r\ntegra_sor_writel(sor, value, SOR_SEQ_CTL);\r\nvalue = SOR_SEQ_INST_DRIVE_PWM_OUT_LO | SOR_SEQ_INST_HALT |\r\nSOR_SEQ_INST_WAIT_VSYNC | SOR_SEQ_INST_WAIT(1);\r\ntegra_sor_writel(sor, value, SOR_SEQ_INST(0));\r\ntegra_sor_writel(sor, value, SOR_SEQ_INST(8));\r\nvalue = SOR_REFCLK_DIV_INT(div) | SOR_REFCLK_DIV_FRAC(div);\r\ntegra_sor_writel(sor, value, SOR_REFCLK);\r\nfor (value = 0, i = 0; i < 5; i++)\r\nvalue |= SOR_XBAR_CTRL_LINK0_XSEL(i, sor->soc->xbar_cfg[i]) |\r\nSOR_XBAR_CTRL_LINK1_XSEL(i, i);\r\ntegra_sor_writel(sor, 0x00000000, SOR_XBAR_POL);\r\ntegra_sor_writel(sor, value, SOR_XBAR_CTRL);\r\nerr = clk_set_parent(sor->clk_src, sor->clk_parent);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set source clock: %d\n", err);\r\nerr = tegra_sor_set_parent_clock(sor, sor->clk_src);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set parent clock: %d\n", err);\r\nvalue = SOR_INPUT_CONTROL_HDMI_SRC_SELECT(dc->pipe);\r\nif (mode->clock < 75000)\r\nvalue |= SOR_INPUT_CONTROL_ARM_VIDEO_RANGE_LIMITED;\r\ntegra_sor_writel(sor, value, SOR_INPUT_CONTROL);\r\nmax_ac = ((mode->htotal - mode->hdisplay) - SOR_REKEY - 18) / 32;\r\nvalue = SOR_HDMI_CTRL_ENABLE | SOR_HDMI_CTRL_MAX_AC_PACKET(max_ac) |\r\nSOR_HDMI_CTRL_AUDIO_LAYOUT | SOR_HDMI_CTRL_REKEY(SOR_REKEY);\r\ntegra_sor_writel(sor, value, SOR_HDMI_CTRL);\r\npulse_start = h_ref_to_sync + (mode->hsync_end - mode->hsync_start) +\r\n(mode->htotal - mode->hsync_end) - 10;\r\nvalue = PULSE_LAST_END_A | PULSE_QUAL_VACTIVE |\r\nPULSE_POLARITY_HIGH | PULSE_MODE_NORMAL;\r\ntegra_dc_writel(dc, value, DC_DISP_H_PULSE2_CONTROL);\r\nvalue = PULSE_END(pulse_start + 8) | PULSE_START(pulse_start);\r\ntegra_dc_writel(dc, value, DC_DISP_H_PULSE2_POSITION_A);\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_SIGNAL_OPTIONS0);\r\nvalue |= H_PULSE2_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_SIGNAL_OPTIONS0);\r\nerr = tegra_sor_hdmi_setup_avi_infoframe(sor, mode);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to setup AVI infoframe: %d\n", err);\r\ntegra_sor_hdmi_disable_audio_infoframe(sor);\r\nvalue = tegra_sor_readl(sor, SOR_STATE1);\r\nvalue &= ~SOR_STATE_ASY_PROTOCOL_MASK;\r\nvalue |= SOR_STATE_ASY_PROTOCOL_SINGLE_TMDS_A;\r\ntegra_sor_writel(sor, value, SOR_STATE1);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue &= ~SOR_DP_PADCTL_PAD_CAL_PD;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nsettings = tegra_sor_hdmi_find_settings(sor, mode->clock * 1000);\r\nif (!settings) {\r\ndev_err(sor->dev, "no settings for pixel clock %d Hz\n",\r\nmode->clock * 1000);\r\nreturn;\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_PLL0);\r\nvalue &= ~SOR_PLL0_ICHPMP_MASK;\r\nvalue &= ~SOR_PLL0_VCOCAP_MASK;\r\nvalue |= SOR_PLL0_ICHPMP(settings->ichpmp);\r\nvalue |= SOR_PLL0_VCOCAP(settings->vcocap);\r\ntegra_sor_writel(sor, value, SOR_PLL0);\r\ntegra_sor_dp_term_calibrate(sor);\r\nvalue = tegra_sor_readl(sor, SOR_PLL1);\r\nvalue &= ~SOR_PLL1_LOADADJ_MASK;\r\nvalue |= SOR_PLL1_LOADADJ(settings->loadadj);\r\ntegra_sor_writel(sor, value, SOR_PLL1);\r\nvalue = tegra_sor_readl(sor, SOR_PLL3);\r\nvalue &= ~SOR_PLL3_BG_VREF_LEVEL_MASK;\r\nvalue |= SOR_PLL3_BG_VREF_LEVEL(settings->bg_vref);\r\ntegra_sor_writel(sor, value, SOR_PLL3);\r\nvalue = settings->drive_current[0] << 24 |\r\nsettings->drive_current[1] << 16 |\r\nsettings->drive_current[2] << 8 |\r\nsettings->drive_current[3] << 0;\r\ntegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT0);\r\nvalue = settings->preemphasis[0] << 24 |\r\nsettings->preemphasis[1] << 16 |\r\nsettings->preemphasis[2] << 8 |\r\nsettings->preemphasis[3] << 0;\r\ntegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\r\nvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\r\nvalue |= SOR_DP_PADCTL_TX_PU(settings->tx_pu);\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL0);\r\nvalue |= SOR_DP_PADCTL_PAD_CAL_PD;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL0);\r\nvalue = VSYNC_H_POSITION(1);\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_TIMING_OPTIONS);\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_COLOR_CONTROL);\r\nvalue &= ~DITHER_CONTROL_MASK;\r\nvalue &= ~BASE_COLOR_SIZE_MASK;\r\nswitch (state->bpc) {\r\ncase 6:\r\nvalue |= BASE_COLOR_SIZE_666;\r\nbreak;\r\ncase 8:\r\nvalue |= BASE_COLOR_SIZE_888;\r\nbreak;\r\ndefault:\r\nWARN(1, "%u bits-per-color not supported\n", state->bpc);\r\nvalue |= BASE_COLOR_SIZE_888;\r\nbreak;\r\n}\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_COLOR_CONTROL);\r\nerr = tegra_sor_power_up(sor, 250);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to power up SOR: %d\n", err);\r\nvalue = tegra_sor_readl(sor, SOR_HEAD_STATE0(dc->pipe));\r\nvalue &= ~SOR_HEAD_STATE_RANGECOMPRESS_MASK;\r\nvalue &= ~SOR_HEAD_STATE_DYNRANGE_MASK;\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE0(dc->pipe));\r\nvalue = tegra_sor_readl(sor, SOR_HEAD_STATE0(dc->pipe));\r\nvalue &= ~SOR_HEAD_STATE_COLORSPACE_MASK;\r\nvalue |= SOR_HEAD_STATE_COLORSPACE_RGB;\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE0(dc->pipe));\r\ntegra_sor_mode_set(sor, mode, state);\r\ntegra_sor_update(sor);\r\nerr = tegra_sor_attach(sor);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to attach SOR: %d\n", err);\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue |= SOR1_ENABLE | SOR1_TIMING_CYA;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\r\ntegra_dc_commit(dc);\r\nerr = tegra_sor_wakeup(sor);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to wakeup SOR: %d\n", err);\r\n}\r\nstatic int tegra_sor_init(struct host1x_client *client)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(client->parent);\r\nconst struct drm_encoder_helper_funcs *helpers = NULL;\r\nstruct tegra_sor *sor = host1x_client_to_sor(client);\r\nint connector = DRM_MODE_CONNECTOR_Unknown;\r\nint encoder = DRM_MODE_ENCODER_NONE;\r\nint err;\r\nif (!sor->aux) {\r\nif (sor->soc->supports_hdmi) {\r\nconnector = DRM_MODE_CONNECTOR_HDMIA;\r\nencoder = DRM_MODE_ENCODER_TMDS;\r\nhelpers = &tegra_sor_hdmi_helpers;\r\n} else if (sor->soc->supports_lvds) {\r\nconnector = DRM_MODE_CONNECTOR_LVDS;\r\nencoder = DRM_MODE_ENCODER_LVDS;\r\n}\r\n} else {\r\nif (sor->soc->supports_edp) {\r\nconnector = DRM_MODE_CONNECTOR_eDP;\r\nencoder = DRM_MODE_ENCODER_TMDS;\r\nhelpers = &tegra_sor_edp_helpers;\r\n} else if (sor->soc->supports_dp) {\r\nconnector = DRM_MODE_CONNECTOR_DisplayPort;\r\nencoder = DRM_MODE_ENCODER_TMDS;\r\n}\r\n}\r\nsor->output.dev = sor->dev;\r\ndrm_connector_init(drm, &sor->output.connector,\r\n&tegra_sor_connector_funcs,\r\nconnector);\r\ndrm_connector_helper_add(&sor->output.connector,\r\n&tegra_sor_connector_helper_funcs);\r\nsor->output.connector.dpms = DRM_MODE_DPMS_OFF;\r\ndrm_encoder_init(drm, &sor->output.encoder, &tegra_sor_encoder_funcs,\r\nencoder, NULL);\r\ndrm_encoder_helper_add(&sor->output.encoder, helpers);\r\ndrm_mode_connector_attach_encoder(&sor->output.connector,\r\n&sor->output.encoder);\r\ndrm_connector_register(&sor->output.connector);\r\nerr = tegra_output_init(drm, &sor->output);\r\nif (err < 0) {\r\ndev_err(client->dev, "failed to initialize output: %d\n", err);\r\nreturn err;\r\n}\r\nsor->output.encoder.possible_crtcs = 0x3;\r\nif (IS_ENABLED(CONFIG_DEBUG_FS)) {\r\nerr = tegra_sor_debugfs_init(sor, drm->primary);\r\nif (err < 0)\r\ndev_err(sor->dev, "debugfs setup failed: %d\n", err);\r\n}\r\nif (sor->aux) {\r\nerr = drm_dp_aux_attach(sor->aux, &sor->output);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to attach DP: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nif (sor->rst) {\r\nerr = reset_control_assert(sor->rst);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to assert SOR reset: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\nerr = clk_prepare_enable(sor->clk);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to enable clock: %d\n", err);\r\nreturn err;\r\n}\r\nusleep_range(1000, 3000);\r\nif (sor->rst) {\r\nerr = reset_control_deassert(sor->rst);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to deassert SOR reset: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\nerr = clk_prepare_enable(sor->clk_safe);\r\nif (err < 0)\r\nreturn err;\r\nerr = clk_prepare_enable(sor->clk_dp);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_exit(struct host1x_client *client)\r\n{\r\nstruct tegra_sor *sor = host1x_client_to_sor(client);\r\nint err;\r\ntegra_output_exit(&sor->output);\r\nif (sor->aux) {\r\nerr = drm_dp_aux_detach(sor->aux);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to detach DP: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nclk_disable_unprepare(sor->clk_safe);\r\nclk_disable_unprepare(sor->clk_dp);\r\nclk_disable_unprepare(sor->clk);\r\nif (IS_ENABLED(CONFIG_DEBUG_FS))\r\ntegra_sor_debugfs_exit(sor);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_hdmi_probe(struct tegra_sor *sor)\r\n{\r\nint err;\r\nsor->avdd_io_supply = devm_regulator_get(sor->dev, "avdd-io");\r\nif (IS_ERR(sor->avdd_io_supply)) {\r\ndev_err(sor->dev, "cannot get AVDD I/O supply: %ld\n",\r\nPTR_ERR(sor->avdd_io_supply));\r\nreturn PTR_ERR(sor->avdd_io_supply);\r\n}\r\nerr = regulator_enable(sor->avdd_io_supply);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to enable AVDD I/O supply: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nsor->vdd_pll_supply = devm_regulator_get(sor->dev, "vdd-pll");\r\nif (IS_ERR(sor->vdd_pll_supply)) {\r\ndev_err(sor->dev, "cannot get VDD PLL supply: %ld\n",\r\nPTR_ERR(sor->vdd_pll_supply));\r\nreturn PTR_ERR(sor->vdd_pll_supply);\r\n}\r\nerr = regulator_enable(sor->vdd_pll_supply);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to enable VDD PLL supply: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nsor->hdmi_supply = devm_regulator_get(sor->dev, "hdmi");\r\nif (IS_ERR(sor->hdmi_supply)) {\r\ndev_err(sor->dev, "cannot get HDMI supply: %ld\n",\r\nPTR_ERR(sor->hdmi_supply));\r\nreturn PTR_ERR(sor->hdmi_supply);\r\n}\r\nerr = regulator_enable(sor->hdmi_supply);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to enable HDMI supply: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_hdmi_remove(struct tegra_sor *sor)\r\n{\r\nregulator_disable(sor->hdmi_supply);\r\nregulator_disable(sor->vdd_pll_supply);\r\nregulator_disable(sor->avdd_io_supply);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device_node *np;\r\nstruct tegra_sor *sor;\r\nstruct resource *regs;\r\nint err;\r\nmatch = of_match_device(tegra_sor_of_match, &pdev->dev);\r\nsor = devm_kzalloc(&pdev->dev, sizeof(*sor), GFP_KERNEL);\r\nif (!sor)\r\nreturn -ENOMEM;\r\nsor->output.dev = sor->dev = &pdev->dev;\r\nsor->soc = match->data;\r\nsor->settings = devm_kmemdup(&pdev->dev, sor->soc->settings,\r\nsor->soc->num_settings *\r\nsizeof(*sor->settings),\r\nGFP_KERNEL);\r\nif (!sor->settings)\r\nreturn -ENOMEM;\r\nsor->num_settings = sor->soc->num_settings;\r\nnp = of_parse_phandle(pdev->dev.of_node, "nvidia,dpaux", 0);\r\nif (np) {\r\nsor->aux = drm_dp_aux_find_by_of_node(np);\r\nof_node_put(np);\r\nif (!sor->aux)\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (!sor->aux) {\r\nif (sor->soc->supports_hdmi) {\r\nsor->ops = &tegra_sor_hdmi_ops;\r\n} else if (sor->soc->supports_lvds) {\r\ndev_err(&pdev->dev, "LVDS not supported yet\n");\r\nreturn -ENODEV;\r\n} else {\r\ndev_err(&pdev->dev, "unknown (non-DP) support\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nif (sor->soc->supports_edp) {\r\nsor->ops = &tegra_sor_edp_ops;\r\n} else if (sor->soc->supports_dp) {\r\ndev_err(&pdev->dev, "DisplayPort not supported yet\n");\r\nreturn -ENODEV;\r\n} else {\r\ndev_err(&pdev->dev, "unknown (DP) support\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nerr = tegra_output_probe(&sor->output);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to probe output: %d\n", err);\r\nreturn err;\r\n}\r\nif (sor->ops && sor->ops->probe) {\r\nerr = sor->ops->probe(sor);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to probe %s: %d\n",\r\nsor->ops->name, err);\r\ngoto output;\r\n}\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsor->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(sor->regs)) {\r\nerr = PTR_ERR(sor->regs);\r\ngoto remove;\r\n}\r\nif (!pdev->dev.pm_domain) {\r\nsor->rst = devm_reset_control_get(&pdev->dev, "sor");\r\nif (IS_ERR(sor->rst)) {\r\nerr = PTR_ERR(sor->rst);\r\ndev_err(&pdev->dev, "failed to get reset control: %d\n",\r\nerr);\r\ngoto remove;\r\n}\r\n}\r\nsor->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(sor->clk)) {\r\nerr = PTR_ERR(sor->clk);\r\ndev_err(&pdev->dev, "failed to get module clock: %d\n", err);\r\ngoto remove;\r\n}\r\nif (sor->soc->supports_hdmi || sor->soc->supports_dp) {\r\nsor->clk_src = devm_clk_get(&pdev->dev, "source");\r\nif (IS_ERR(sor->clk_src)) {\r\nerr = PTR_ERR(sor->clk_src);\r\ndev_err(sor->dev, "failed to get source clock: %d\n",\r\nerr);\r\ngoto remove;\r\n}\r\n}\r\nsor->clk_parent = devm_clk_get(&pdev->dev, "parent");\r\nif (IS_ERR(sor->clk_parent)) {\r\nerr = PTR_ERR(sor->clk_parent);\r\ndev_err(&pdev->dev, "failed to get parent clock: %d\n", err);\r\ngoto remove;\r\n}\r\nsor->clk_safe = devm_clk_get(&pdev->dev, "safe");\r\nif (IS_ERR(sor->clk_safe)) {\r\nerr = PTR_ERR(sor->clk_safe);\r\ndev_err(&pdev->dev, "failed to get safe clock: %d\n", err);\r\ngoto remove;\r\n}\r\nsor->clk_dp = devm_clk_get(&pdev->dev, "dp");\r\nif (IS_ERR(sor->clk_dp)) {\r\nerr = PTR_ERR(sor->clk_dp);\r\ndev_err(&pdev->dev, "failed to get DP clock: %d\n", err);\r\ngoto remove;\r\n}\r\nplatform_set_drvdata(pdev, sor);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nsor->clk_brick = tegra_clk_sor_brick_register(sor, "sor1_brick");\r\npm_runtime_put(&pdev->dev);\r\nif (IS_ERR(sor->clk_brick)) {\r\nerr = PTR_ERR(sor->clk_brick);\r\ndev_err(&pdev->dev, "failed to register SOR clock: %d\n", err);\r\ngoto remove;\r\n}\r\nINIT_LIST_HEAD(&sor->client.list);\r\nsor->client.ops = &sor_client_ops;\r\nsor->client.dev = &pdev->dev;\r\nerr = host1x_client_register(&sor->client);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to register host1x client: %d\n",\r\nerr);\r\ngoto remove;\r\n}\r\nreturn 0;\r\nremove:\r\nif (sor->ops && sor->ops->remove)\r\nsor->ops->remove(sor);\r\noutput:\r\ntegra_output_remove(&sor->output);\r\nreturn err;\r\n}\r\nstatic int tegra_sor_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_sor *sor = platform_get_drvdata(pdev);\r\nint err;\r\npm_runtime_disable(&pdev->dev);\r\nerr = host1x_client_unregister(&sor->client);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to unregister host1x client: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (sor->ops && sor->ops->remove) {\r\nerr = sor->ops->remove(sor);\r\nif (err < 0)\r\ndev_err(&pdev->dev, "failed to remove SOR: %d\n", err);\r\n}\r\ntegra_output_remove(&sor->output);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_suspend(struct device *dev)\r\n{\r\nstruct tegra_sor *sor = dev_get_drvdata(dev);\r\nint err;\r\nif (sor->rst) {\r\nerr = reset_control_assert(sor->rst);\r\nif (err < 0) {\r\ndev_err(dev, "failed to assert reset: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nusleep_range(1000, 2000);\r\nclk_disable_unprepare(sor->clk);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_resume(struct device *dev)\r\n{\r\nstruct tegra_sor *sor = dev_get_drvdata(dev);\r\nint err;\r\nerr = clk_prepare_enable(sor->clk);\r\nif (err < 0) {\r\ndev_err(dev, "failed to enable clock: %d\n", err);\r\nreturn err;\r\n}\r\nusleep_range(1000, 2000);\r\nif (sor->rst) {\r\nerr = reset_control_deassert(sor->rst);\r\nif (err < 0) {\r\ndev_err(dev, "failed to deassert reset: %d\n", err);\r\nclk_disable_unprepare(sor->clk);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}
