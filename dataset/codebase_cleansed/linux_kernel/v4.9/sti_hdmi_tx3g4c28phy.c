static bool sti_hdmi_tx3g4c28phy_start(struct sti_hdmi *hdmi)\r\n{\r\nu32 ckpxpll = hdmi->mode.clock * 1000;\r\nu32 val, tmdsck, idf, odf, pllctrl = 0;\r\nbool foundplldivides = false;\r\nint i;\r\nDRM_DEBUG_DRIVER("ckpxpll = %dHz\n", ckpxpll);\r\nfor (i = 0; i < NB_PLL_MODE; i++) {\r\nif (ckpxpll >= plldividers[i].min &&\r\nckpxpll < plldividers[i].max) {\r\nidf = plldividers[i].idf;\r\nodf = plldividers[i].odf;\r\nfoundplldivides = true;\r\nbreak;\r\n}\r\n}\r\nif (!foundplldivides) {\r\nDRM_ERROR("input TMDS clock speed (%d) not supported\n",\r\nckpxpll);\r\ngoto err;\r\n}\r\ntmdsck = ckpxpll;\r\npllctrl |= 40 << PLL_CFG_NDIV_SHIFT;\r\nif (tmdsck > 340000000) {\r\nDRM_ERROR("output TMDS clock (%d) out of range\n", tmdsck);\r\ngoto err;\r\n}\r\npllctrl |= idf << PLL_CFG_IDF_SHIFT;\r\npllctrl |= odf << PLL_CFG_ODF_SHIFT;\r\nhdmi->event_received = false;\r\nDRM_DEBUG_DRIVER("pllctrl = 0x%x\n", pllctrl);\r\nhdmi_write(hdmi, (pllctrl | PLL_CFG_EN), HDMI_SRZ_PLL_CFG);\r\nwait_event_interruptible_timeout(hdmi->wait_event,\r\nhdmi->event_received == true,\r\nmsecs_to_jiffies\r\n(HDMI_TIMEOUT_PLL_LOCK));\r\nif ((hdmi_read(hdmi, HDMI_STA) & HDMI_STA_DLL_LCK) == 0) {\r\nDRM_ERROR("hdmi phy pll not locked\n");\r\ngoto err;\r\n}\r\nDRM_DEBUG_DRIVER("got PHY PLL Lock\n");\r\nval = (HDMI_SRZ_CFG_EN |\r\nHDMI_SRZ_CFG_EXTERNAL_DATA |\r\nHDMI_SRZ_CFG_EN_BIASRES_DETECTION |\r\nHDMI_SRZ_CFG_EN_SINK_TERM_DETECTION);\r\nif (tmdsck > 165000000)\r\nval |= HDMI_SRZ_CFG_EN_SRC_TERMINATION;\r\nfor (i = 0; i < NB_HDMI_PHY_CONFIG; i++) {\r\nif ((hdmiphy_config[i].min_tmds_freq <= tmdsck) &&\r\n(hdmiphy_config[i].max_tmds_freq >= tmdsck)) {\r\nval |= (hdmiphy_config[i].config[0]\r\n& ~HDMI_SRZ_CFG_INTERNAL_MASK);\r\nhdmi_write(hdmi, val, HDMI_SRZ_CFG);\r\nval = hdmiphy_config[i].config[1];\r\nhdmi_write(hdmi, val, HDMI_SRZ_ICNTL);\r\nval = hdmiphy_config[i].config[2];\r\nhdmi_write(hdmi, val, HDMI_SRZ_CALCODE_EXT);\r\nDRM_DEBUG_DRIVER("serializer cfg 0x%x 0x%x 0x%x\n",\r\nhdmiphy_config[i].config[0],\r\nhdmiphy_config[i].config[1],\r\nhdmiphy_config[i].config[2]);\r\nreturn true;\r\n}\r\n}\r\nhdmi_write(hdmi, val, HDMI_SRZ_CFG);\r\nhdmi_write(hdmi, 0x0, HDMI_SRZ_ICNTL);\r\nhdmi_write(hdmi, 0x0, HDMI_SRZ_CALCODE_EXT);\r\nreturn true;\r\nerr:\r\nreturn false;\r\n}\r\nstatic void sti_hdmi_tx3g4c28phy_stop(struct sti_hdmi *hdmi)\r\n{\r\nint val = 0;\r\nDRM_DEBUG_DRIVER("\n");\r\nhdmi->event_received = false;\r\nval = HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION;\r\nval |= HDMI_SRZ_CFG_EN_BIASRES_DETECTION;\r\nhdmi_write(hdmi, val, HDMI_SRZ_CFG);\r\nhdmi_write(hdmi, 0, HDMI_SRZ_PLL_CFG);\r\nwait_event_interruptible_timeout(hdmi->wait_event,\r\nhdmi->event_received == true,\r\nmsecs_to_jiffies\r\n(HDMI_TIMEOUT_PLL_LOCK));\r\nif (hdmi_read(hdmi, HDMI_STA) & HDMI_STA_DLL_LCK)\r\nDRM_ERROR("hdmi phy pll not well disabled\n");\r\n}
