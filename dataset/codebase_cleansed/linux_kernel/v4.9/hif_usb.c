static void hif_usb_regout_cb(struct urb *urb)\r\n{\r\nstruct cmd_buf *cmd = (struct cmd_buf *)urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ngoto free;\r\ndefault:\r\nbreak;\r\n}\r\nif (cmd) {\r\nath9k_htc_txcompletion_cb(cmd->hif_dev->htc_handle,\r\ncmd->skb, true);\r\nkfree(cmd);\r\n}\r\nreturn;\r\nfree:\r\nkfree_skb(cmd->skb);\r\nkfree(cmd);\r\n}\r\nstatic int hif_usb_send_regout(struct hif_device_usb *hif_dev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct urb *urb;\r\nstruct cmd_buf *cmd;\r\nint ret = 0;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (urb == NULL)\r\nreturn -ENOMEM;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (cmd == NULL) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\ncmd->skb = skb;\r\ncmd->hif_dev = hif_dev;\r\nusb_fill_int_urb(urb, hif_dev->udev,\r\nusb_sndintpipe(hif_dev->udev, USB_REG_OUT_PIPE),\r\nskb->data, skb->len,\r\nhif_usb_regout_cb, cmd, 1);\r\nusb_anchor_urb(urb, &hif_dev->regout_submitted);\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\nusb_unanchor_urb(urb);\r\nkfree(cmd);\r\n}\r\nusb_free_urb(urb);\r\nreturn ret;\r\n}\r\nstatic void hif_usb_mgmt_cb(struct urb *urb)\r\n{\r\nstruct cmd_buf *cmd = (struct cmd_buf *)urb->context;\r\nstruct hif_device_usb *hif_dev;\r\nbool txok = true;\r\nif (!cmd || !cmd->skb || !cmd->hif_dev)\r\nreturn;\r\nhif_dev = cmd->hif_dev;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ntxok = false;\r\nspin_lock(&hif_dev->tx.tx_lock);\r\nif (hif_dev->tx.flags & HIF_USB_TX_FLUSH) {\r\nspin_unlock(&hif_dev->tx.tx_lock);\r\ndev_kfree_skb_any(cmd->skb);\r\nkfree(cmd);\r\nreturn;\r\n}\r\nspin_unlock(&hif_dev->tx.tx_lock);\r\nbreak;\r\ndefault:\r\ntxok = false;\r\nbreak;\r\n}\r\nskb_pull(cmd->skb, 4);\r\nath9k_htc_txcompletion_cb(cmd->hif_dev->htc_handle,\r\ncmd->skb, txok);\r\nkfree(cmd);\r\n}\r\nstatic int hif_usb_send_mgmt(struct hif_device_usb *hif_dev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct urb *urb;\r\nstruct cmd_buf *cmd;\r\nint ret = 0;\r\n__le16 *hdr;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (urb == NULL)\r\nreturn -ENOMEM;\r\ncmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\r\nif (cmd == NULL) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\ncmd->skb = skb;\r\ncmd->hif_dev = hif_dev;\r\nhdr = (__le16 *) skb_push(skb, 4);\r\n*hdr++ = cpu_to_le16(skb->len - 4);\r\n*hdr++ = cpu_to_le16(ATH_USB_TX_STREAM_MODE_TAG);\r\nusb_fill_bulk_urb(urb, hif_dev->udev,\r\nusb_sndbulkpipe(hif_dev->udev, USB_WLAN_TX_PIPE),\r\nskb->data, skb->len,\r\nhif_usb_mgmt_cb, cmd);\r\nusb_anchor_urb(urb, &hif_dev->mgmt_submitted);\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret) {\r\nusb_unanchor_urb(urb);\r\nkfree(cmd);\r\n}\r\nusb_free_urb(urb);\r\nreturn ret;\r\n}\r\nstatic inline void ath9k_skb_queue_purge(struct hif_device_usb *hif_dev,\r\nstruct sk_buff_head *list)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = __skb_dequeue(list)) != NULL) {\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nstatic inline void ath9k_skb_queue_complete(struct hif_device_usb *hif_dev,\r\nstruct sk_buff_head *queue,\r\nbool txok)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = __skb_dequeue(queue)) != NULL) {\r\n#ifdef CONFIG_ATH9K_HTC_DEBUGFS\r\nint ln = skb->len;\r\n#endif\r\nath9k_htc_txcompletion_cb(hif_dev->htc_handle,\r\nskb, txok);\r\nif (txok) {\r\nTX_STAT_INC(skb_success);\r\nTX_STAT_ADD(skb_success_bytes, ln);\r\n}\r\nelse\r\nTX_STAT_INC(skb_failed);\r\n}\r\n}\r\nstatic void hif_usb_tx_cb(struct urb *urb)\r\n{\r\nstruct tx_buf *tx_buf = (struct tx_buf *) urb->context;\r\nstruct hif_device_usb *hif_dev;\r\nbool txok = true;\r\nif (!tx_buf || !tx_buf->hif_dev)\r\nreturn;\r\nhif_dev = tx_buf->hif_dev;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ntxok = false;\r\nspin_lock(&hif_dev->tx.tx_lock);\r\nif (hif_dev->tx.flags & HIF_USB_TX_FLUSH) {\r\nspin_unlock(&hif_dev->tx.tx_lock);\r\nath9k_skb_queue_purge(hif_dev, &tx_buf->skb_queue);\r\nreturn;\r\n}\r\nspin_unlock(&hif_dev->tx.tx_lock);\r\nbreak;\r\ndefault:\r\ntxok = false;\r\nbreak;\r\n}\r\nath9k_skb_queue_complete(hif_dev, &tx_buf->skb_queue, txok);\r\ntx_buf->len = tx_buf->offset = 0;\r\n__skb_queue_head_init(&tx_buf->skb_queue);\r\nspin_lock(&hif_dev->tx.tx_lock);\r\nlist_move_tail(&tx_buf->list, &hif_dev->tx.tx_buf);\r\nhif_dev->tx.tx_buf_cnt++;\r\nif (!(hif_dev->tx.flags & HIF_USB_TX_STOP))\r\n__hif_usb_tx(hif_dev);\r\nTX_STAT_INC(buf_completed);\r\nspin_unlock(&hif_dev->tx.tx_lock);\r\n}\r\nstatic int __hif_usb_tx(struct hif_device_usb *hif_dev)\r\n{\r\nstruct tx_buf *tx_buf = NULL;\r\nstruct sk_buff *nskb = NULL;\r\nint ret = 0, i;\r\nu16 tx_skb_cnt = 0;\r\nu8 *buf;\r\n__le16 *hdr;\r\nif (hif_dev->tx.tx_skb_cnt == 0)\r\nreturn 0;\r\nif (list_empty(&hif_dev->tx.tx_buf))\r\nreturn 0;\r\ntx_buf = list_first_entry(&hif_dev->tx.tx_buf, struct tx_buf, list);\r\nlist_move_tail(&tx_buf->list, &hif_dev->tx.tx_pending);\r\nhif_dev->tx.tx_buf_cnt--;\r\ntx_skb_cnt = min_t(u16, hif_dev->tx.tx_skb_cnt, MAX_TX_AGGR_NUM);\r\nfor (i = 0; i < tx_skb_cnt; i++) {\r\nnskb = __skb_dequeue(&hif_dev->tx.tx_skb_queue);\r\nBUG_ON(!nskb);\r\nhif_dev->tx.tx_skb_cnt--;\r\nbuf = tx_buf->buf;\r\nbuf += tx_buf->offset;\r\nhdr = (__le16 *)buf;\r\n*hdr++ = cpu_to_le16(nskb->len);\r\n*hdr++ = cpu_to_le16(ATH_USB_TX_STREAM_MODE_TAG);\r\nbuf += 4;\r\nmemcpy(buf, nskb->data, nskb->len);\r\ntx_buf->len = nskb->len + 4;\r\nif (i < (tx_skb_cnt - 1))\r\ntx_buf->offset += (((tx_buf->len - 1) / 4) + 1) * 4;\r\nif (i == (tx_skb_cnt - 1))\r\ntx_buf->len += tx_buf->offset;\r\n__skb_queue_tail(&tx_buf->skb_queue, nskb);\r\nTX_STAT_INC(skb_queued);\r\n}\r\nusb_fill_bulk_urb(tx_buf->urb, hif_dev->udev,\r\nusb_sndbulkpipe(hif_dev->udev, USB_WLAN_TX_PIPE),\r\ntx_buf->buf, tx_buf->len,\r\nhif_usb_tx_cb, tx_buf);\r\nret = usb_submit_urb(tx_buf->urb, GFP_ATOMIC);\r\nif (ret) {\r\ntx_buf->len = tx_buf->offset = 0;\r\nath9k_skb_queue_complete(hif_dev, &tx_buf->skb_queue, false);\r\n__skb_queue_head_init(&tx_buf->skb_queue);\r\nlist_move_tail(&tx_buf->list, &hif_dev->tx.tx_buf);\r\nhif_dev->tx.tx_buf_cnt++;\r\n}\r\nif (!ret)\r\nTX_STAT_INC(buf_queued);\r\nreturn ret;\r\n}\r\nstatic int hif_usb_send_tx(struct hif_device_usb *hif_dev, struct sk_buff *skb)\r\n{\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\r\nif (hif_dev->tx.flags & HIF_USB_TX_STOP) {\r\nspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\r\nreturn -ENODEV;\r\n}\r\nif (hif_dev->tx.tx_skb_cnt > MAX_TX_BUF_NUM) {\r\nspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\r\ntx_ctl = HTC_SKB_CB(skb);\r\nif ((tx_ctl->type == ATH9K_HTC_MGMT) ||\r\n(tx_ctl->type == ATH9K_HTC_BEACON)) {\r\nret = hif_usb_send_mgmt(hif_dev, skb);\r\n}\r\nspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\r\nif ((tx_ctl->type == ATH9K_HTC_NORMAL) ||\r\n(tx_ctl->type == ATH9K_HTC_AMPDU)) {\r\n__skb_queue_tail(&hif_dev->tx.tx_skb_queue, skb);\r\nhif_dev->tx.tx_skb_cnt++;\r\n}\r\nif ((hif_dev->tx.tx_buf_cnt == MAX_TX_URB_NUM) &&\r\n(hif_dev->tx.tx_skb_cnt < 2)) {\r\n__hif_usb_tx(hif_dev);\r\n}\r\nspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void hif_usb_start(void *hif_handle)\r\n{\r\nstruct hif_device_usb *hif_dev = (struct hif_device_usb *)hif_handle;\r\nunsigned long flags;\r\nhif_dev->flags |= HIF_USB_START;\r\nspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\r\nhif_dev->tx.flags &= ~HIF_USB_TX_STOP;\r\nspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\r\n}\r\nstatic void hif_usb_stop(void *hif_handle)\r\n{\r\nstruct hif_device_usb *hif_dev = (struct hif_device_usb *)hif_handle;\r\nstruct tx_buf *tx_buf = NULL, *tx_buf_tmp = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\r\nath9k_skb_queue_complete(hif_dev, &hif_dev->tx.tx_skb_queue, false);\r\nhif_dev->tx.tx_skb_cnt = 0;\r\nhif_dev->tx.flags |= HIF_USB_TX_STOP;\r\nspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\r\nlist_for_each_entry_safe(tx_buf, tx_buf_tmp,\r\n&hif_dev->tx.tx_pending, list) {\r\nusb_kill_urb(tx_buf->urb);\r\n}\r\nusb_kill_anchored_urbs(&hif_dev->mgmt_submitted);\r\n}\r\nstatic int hif_usb_send(void *hif_handle, u8 pipe_id, struct sk_buff *skb)\r\n{\r\nstruct hif_device_usb *hif_dev = (struct hif_device_usb *)hif_handle;\r\nint ret = 0;\r\nswitch (pipe_id) {\r\ncase USB_WLAN_TX_PIPE:\r\nret = hif_usb_send_tx(hif_dev, skb);\r\nbreak;\r\ncase USB_REG_OUT_PIPE:\r\nret = hif_usb_send_regout(hif_dev, skb);\r\nbreak;\r\ndefault:\r\ndev_err(&hif_dev->udev->dev,\r\n"ath9k_htc: Invalid TX pipe: %d\n", pipe_id);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline bool check_index(struct sk_buff *skb, u8 idx)\r\n{\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\ntx_ctl = HTC_SKB_CB(skb);\r\nif ((tx_ctl->type == ATH9K_HTC_AMPDU) &&\r\n(tx_ctl->sta_idx == idx))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void hif_usb_sta_drain(void *hif_handle, u8 idx)\r\n{\r\nstruct hif_device_usb *hif_dev = (struct hif_device_usb *)hif_handle;\r\nstruct sk_buff *skb, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\r\nskb_queue_walk_safe(&hif_dev->tx.tx_skb_queue, skb, tmp) {\r\nif (check_index(skb, idx)) {\r\n__skb_unlink(skb, &hif_dev->tx.tx_skb_queue);\r\nath9k_htc_txcompletion_cb(hif_dev->htc_handle,\r\nskb, false);\r\nhif_dev->tx.tx_skb_cnt--;\r\nTX_STAT_INC(skb_failed);\r\n}\r\n}\r\nspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\r\n}\r\nstatic void ath9k_hif_usb_rx_stream(struct hif_device_usb *hif_dev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *nskb, *skb_pool[MAX_PKT_NUM_IN_TRANSFER];\r\nint index = 0, i, len = skb->len;\r\nint rx_remain_len, rx_pkt_len;\r\nu16 pool_index = 0;\r\nu8 *ptr;\r\nspin_lock(&hif_dev->rx_lock);\r\nrx_remain_len = hif_dev->rx_remain_len;\r\nrx_pkt_len = hif_dev->rx_transfer_len;\r\nif (rx_remain_len != 0) {\r\nstruct sk_buff *remain_skb = hif_dev->remain_skb;\r\nif (remain_skb) {\r\nptr = (u8 *) remain_skb->data;\r\nindex = rx_remain_len;\r\nrx_remain_len -= hif_dev->rx_pad_len;\r\nptr += rx_pkt_len;\r\nmemcpy(ptr, skb->data, rx_remain_len);\r\nrx_pkt_len += rx_remain_len;\r\nhif_dev->rx_remain_len = 0;\r\nskb_put(remain_skb, rx_pkt_len);\r\nskb_pool[pool_index++] = remain_skb;\r\n} else {\r\nindex = rx_remain_len;\r\n}\r\n}\r\nspin_unlock(&hif_dev->rx_lock);\r\nwhile (index < len) {\r\nu16 pkt_len;\r\nu16 pkt_tag;\r\nu16 pad_len;\r\nint chk_idx;\r\nptr = (u8 *) skb->data;\r\npkt_len = get_unaligned_le16(ptr + index);\r\npkt_tag = get_unaligned_le16(ptr + index + 2);\r\nif (pkt_tag != ATH_USB_RX_STREAM_MODE_TAG) {\r\nRX_STAT_INC(skb_dropped);\r\nreturn;\r\n}\r\npad_len = 4 - (pkt_len & 0x3);\r\nif (pad_len == 4)\r\npad_len = 0;\r\nchk_idx = index;\r\nindex = index + 4 + pkt_len + pad_len;\r\nif (index > MAX_RX_BUF_SIZE) {\r\nspin_lock(&hif_dev->rx_lock);\r\nhif_dev->rx_remain_len = index - MAX_RX_BUF_SIZE;\r\nhif_dev->rx_transfer_len =\r\nMAX_RX_BUF_SIZE - chk_idx - 4;\r\nhif_dev->rx_pad_len = pad_len;\r\nnskb = __dev_alloc_skb(pkt_len + 32, GFP_ATOMIC);\r\nif (!nskb) {\r\ndev_err(&hif_dev->udev->dev,\r\n"ath9k_htc: RX memory allocation error\n");\r\nspin_unlock(&hif_dev->rx_lock);\r\ngoto err;\r\n}\r\nskb_reserve(nskb, 32);\r\nRX_STAT_INC(skb_allocated);\r\nmemcpy(nskb->data, &(skb->data[chk_idx+4]),\r\nhif_dev->rx_transfer_len);\r\nhif_dev->remain_skb = nskb;\r\nspin_unlock(&hif_dev->rx_lock);\r\n} else {\r\nnskb = __dev_alloc_skb(pkt_len + 32, GFP_ATOMIC);\r\nif (!nskb) {\r\ndev_err(&hif_dev->udev->dev,\r\n"ath9k_htc: RX memory allocation error\n");\r\ngoto err;\r\n}\r\nskb_reserve(nskb, 32);\r\nRX_STAT_INC(skb_allocated);\r\nmemcpy(nskb->data, &(skb->data[chk_idx+4]), pkt_len);\r\nskb_put(nskb, pkt_len);\r\nskb_pool[pool_index++] = nskb;\r\n}\r\n}\r\nerr:\r\nfor (i = 0; i < pool_index; i++) {\r\nRX_STAT_ADD(skb_completed_bytes, skb_pool[i]->len);\r\nath9k_htc_rx_msg(hif_dev->htc_handle, skb_pool[i],\r\nskb_pool[i]->len, USB_WLAN_RX_PIPE);\r\nRX_STAT_INC(skb_completed);\r\n}\r\n}\r\nstatic void ath9k_hif_usb_rx_cb(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct hif_device_usb *hif_dev =\r\nusb_get_intfdata(usb_ifnum_to_if(urb->dev, 0));\r\nint ret;\r\nif (!skb)\r\nreturn;\r\nif (!hif_dev)\r\ngoto free;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ngoto free;\r\ndefault:\r\ngoto resubmit;\r\n}\r\nif (likely(urb->actual_length != 0)) {\r\nskb_put(skb, urb->actual_length);\r\nath9k_hif_usb_rx_stream(hif_dev, skb);\r\n}\r\nresubmit:\r\nskb_reset_tail_pointer(skb);\r\nskb_trim(skb, 0);\r\nusb_anchor_urb(urb, &hif_dev->rx_submitted);\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret) {\r\nusb_unanchor_urb(urb);\r\ngoto free;\r\n}\r\nreturn;\r\nfree:\r\nkfree_skb(skb);\r\n}\r\nstatic void ath9k_hif_usb_reg_in_cb(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct sk_buff *nskb;\r\nstruct hif_device_usb *hif_dev =\r\nusb_get_intfdata(usb_ifnum_to_if(urb->dev, 0));\r\nint ret;\r\nif (!skb)\r\nreturn;\r\nif (!hif_dev)\r\ngoto free;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\ngoto free;\r\ndefault:\r\nskb_reset_tail_pointer(skb);\r\nskb_trim(skb, 0);\r\ngoto resubmit;\r\n}\r\nif (likely(urb->actual_length != 0)) {\r\nskb_put(skb, urb->actual_length);\r\nath9k_htc_rx_msg(hif_dev->htc_handle, skb,\r\nskb->len, USB_REG_IN_PIPE);\r\nnskb = alloc_skb(MAX_REG_IN_BUF_SIZE, GFP_ATOMIC);\r\nif (!nskb) {\r\ndev_err(&hif_dev->udev->dev,\r\n"ath9k_htc: REG_IN memory allocation failure\n");\r\nurb->context = NULL;\r\nreturn;\r\n}\r\nusb_fill_int_urb(urb, hif_dev->udev,\r\nusb_rcvintpipe(hif_dev->udev,\r\nUSB_REG_IN_PIPE),\r\nnskb->data, MAX_REG_IN_BUF_SIZE,\r\nath9k_hif_usb_reg_in_cb, nskb, 1);\r\n}\r\nresubmit:\r\nusb_anchor_urb(urb, &hif_dev->reg_in_submitted);\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret) {\r\nusb_unanchor_urb(urb);\r\ngoto free;\r\n}\r\nreturn;\r\nfree:\r\nkfree_skb(skb);\r\nurb->context = NULL;\r\n}\r\nstatic void ath9k_hif_usb_dealloc_tx_urbs(struct hif_device_usb *hif_dev)\r\n{\r\nstruct tx_buf *tx_buf = NULL, *tx_buf_tmp = NULL;\r\nunsigned long flags;\r\nlist_for_each_entry_safe(tx_buf, tx_buf_tmp,\r\n&hif_dev->tx.tx_buf, list) {\r\nusb_kill_urb(tx_buf->urb);\r\nlist_del(&tx_buf->list);\r\nusb_free_urb(tx_buf->urb);\r\nkfree(tx_buf->buf);\r\nkfree(tx_buf);\r\n}\r\nspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\r\nhif_dev->tx.flags |= HIF_USB_TX_FLUSH;\r\nspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\r\nlist_for_each_entry_safe(tx_buf, tx_buf_tmp,\r\n&hif_dev->tx.tx_pending, list) {\r\nusb_kill_urb(tx_buf->urb);\r\nlist_del(&tx_buf->list);\r\nusb_free_urb(tx_buf->urb);\r\nkfree(tx_buf->buf);\r\nkfree(tx_buf);\r\n}\r\nusb_kill_anchored_urbs(&hif_dev->mgmt_submitted);\r\n}\r\nstatic int ath9k_hif_usb_alloc_tx_urbs(struct hif_device_usb *hif_dev)\r\n{\r\nstruct tx_buf *tx_buf;\r\nint i;\r\nINIT_LIST_HEAD(&hif_dev->tx.tx_buf);\r\nINIT_LIST_HEAD(&hif_dev->tx.tx_pending);\r\nspin_lock_init(&hif_dev->tx.tx_lock);\r\n__skb_queue_head_init(&hif_dev->tx.tx_skb_queue);\r\ninit_usb_anchor(&hif_dev->mgmt_submitted);\r\nfor (i = 0; i < MAX_TX_URB_NUM; i++) {\r\ntx_buf = kzalloc(sizeof(struct tx_buf), GFP_KERNEL);\r\nif (!tx_buf)\r\ngoto err;\r\ntx_buf->buf = kzalloc(MAX_TX_BUF_SIZE, GFP_KERNEL);\r\nif (!tx_buf->buf)\r\ngoto err;\r\ntx_buf->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!tx_buf->urb)\r\ngoto err;\r\ntx_buf->hif_dev = hif_dev;\r\n__skb_queue_head_init(&tx_buf->skb_queue);\r\nlist_add_tail(&tx_buf->list, &hif_dev->tx.tx_buf);\r\n}\r\nhif_dev->tx.tx_buf_cnt = MAX_TX_URB_NUM;\r\nreturn 0;\r\nerr:\r\nif (tx_buf) {\r\nkfree(tx_buf->buf);\r\nkfree(tx_buf);\r\n}\r\nath9k_hif_usb_dealloc_tx_urbs(hif_dev);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ath9k_hif_usb_dealloc_rx_urbs(struct hif_device_usb *hif_dev)\r\n{\r\nusb_kill_anchored_urbs(&hif_dev->rx_submitted);\r\n}\r\nstatic int ath9k_hif_usb_alloc_rx_urbs(struct hif_device_usb *hif_dev)\r\n{\r\nstruct urb *urb = NULL;\r\nstruct sk_buff *skb = NULL;\r\nint i, ret;\r\ninit_usb_anchor(&hif_dev->rx_submitted);\r\nspin_lock_init(&hif_dev->rx_lock);\r\nfor (i = 0; i < MAX_RX_URB_NUM; i++) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (urb == NULL) {\r\nret = -ENOMEM;\r\ngoto err_urb;\r\n}\r\nskb = alloc_skb(MAX_RX_BUF_SIZE, GFP_KERNEL);\r\nif (!skb) {\r\nret = -ENOMEM;\r\ngoto err_skb;\r\n}\r\nusb_fill_bulk_urb(urb, hif_dev->udev,\r\nusb_rcvbulkpipe(hif_dev->udev,\r\nUSB_WLAN_RX_PIPE),\r\nskb->data, MAX_RX_BUF_SIZE,\r\nath9k_hif_usb_rx_cb, skb);\r\nusb_anchor_urb(urb, &hif_dev->rx_submitted);\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\nusb_unanchor_urb(urb);\r\ngoto err_submit;\r\n}\r\nusb_free_urb(urb);\r\n}\r\nreturn 0;\r\nerr_submit:\r\nkfree_skb(skb);\r\nerr_skb:\r\nusb_free_urb(urb);\r\nerr_urb:\r\nath9k_hif_usb_dealloc_rx_urbs(hif_dev);\r\nreturn ret;\r\n}\r\nstatic void ath9k_hif_usb_dealloc_reg_in_urbs(struct hif_device_usb *hif_dev)\r\n{\r\nusb_kill_anchored_urbs(&hif_dev->reg_in_submitted);\r\n}\r\nstatic int ath9k_hif_usb_alloc_reg_in_urbs(struct hif_device_usb *hif_dev)\r\n{\r\nstruct urb *urb = NULL;\r\nstruct sk_buff *skb = NULL;\r\nint i, ret;\r\ninit_usb_anchor(&hif_dev->reg_in_submitted);\r\nfor (i = 0; i < MAX_REG_IN_URB_NUM; i++) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (urb == NULL) {\r\nret = -ENOMEM;\r\ngoto err_urb;\r\n}\r\nskb = alloc_skb(MAX_REG_IN_BUF_SIZE, GFP_KERNEL);\r\nif (!skb) {\r\nret = -ENOMEM;\r\ngoto err_skb;\r\n}\r\nusb_fill_int_urb(urb, hif_dev->udev,\r\nusb_rcvintpipe(hif_dev->udev,\r\nUSB_REG_IN_PIPE),\r\nskb->data, MAX_REG_IN_BUF_SIZE,\r\nath9k_hif_usb_reg_in_cb, skb, 1);\r\nusb_anchor_urb(urb, &hif_dev->reg_in_submitted);\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\nusb_unanchor_urb(urb);\r\ngoto err_submit;\r\n}\r\nusb_free_urb(urb);\r\n}\r\nreturn 0;\r\nerr_submit:\r\nkfree_skb(skb);\r\nerr_skb:\r\nusb_free_urb(urb);\r\nerr_urb:\r\nath9k_hif_usb_dealloc_reg_in_urbs(hif_dev);\r\nreturn ret;\r\n}\r\nstatic int ath9k_hif_usb_alloc_urbs(struct hif_device_usb *hif_dev)\r\n{\r\ninit_usb_anchor(&hif_dev->regout_submitted);\r\nif (ath9k_hif_usb_alloc_tx_urbs(hif_dev) < 0)\r\ngoto err;\r\nif (ath9k_hif_usb_alloc_rx_urbs(hif_dev) < 0)\r\ngoto err_rx;\r\nif (ath9k_hif_usb_alloc_reg_in_urbs(hif_dev) < 0)\r\ngoto err_reg;\r\nreturn 0;\r\nerr_reg:\r\nath9k_hif_usb_dealloc_rx_urbs(hif_dev);\r\nerr_rx:\r\nath9k_hif_usb_dealloc_tx_urbs(hif_dev);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void ath9k_hif_usb_dealloc_urbs(struct hif_device_usb *hif_dev)\r\n{\r\nusb_kill_anchored_urbs(&hif_dev->regout_submitted);\r\nath9k_hif_usb_dealloc_reg_in_urbs(hif_dev);\r\nath9k_hif_usb_dealloc_tx_urbs(hif_dev);\r\nath9k_hif_usb_dealloc_rx_urbs(hif_dev);\r\n}\r\nstatic int ath9k_hif_usb_download_fw(struct hif_device_usb *hif_dev)\r\n{\r\nint transfer, err;\r\nconst void *data = hif_dev->fw_data;\r\nsize_t len = hif_dev->fw_size;\r\nu32 addr = AR9271_FIRMWARE;\r\nu8 *buf = kzalloc(4096, GFP_KERNEL);\r\nu32 firm_offset;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nwhile (len) {\r\ntransfer = min_t(size_t, len, 4096);\r\nmemcpy(buf, data, transfer);\r\nerr = usb_control_msg(hif_dev->udev,\r\nusb_sndctrlpipe(hif_dev->udev, 0),\r\nFIRMWARE_DOWNLOAD, 0x40 | USB_DIR_OUT,\r\naddr >> 8, 0, buf, transfer, HZ);\r\nif (err < 0) {\r\nkfree(buf);\r\nreturn err;\r\n}\r\nlen -= transfer;\r\ndata += transfer;\r\naddr += transfer;\r\n}\r\nkfree(buf);\r\nif (IS_AR7010_DEVICE(hif_dev->usb_device_id->driver_info))\r\nfirm_offset = AR7010_FIRMWARE_TEXT;\r\nelse\r\nfirm_offset = AR9271_FIRMWARE_TEXT;\r\nerr = usb_control_msg(hif_dev->udev, usb_sndctrlpipe(hif_dev->udev, 0),\r\nFIRMWARE_DOWNLOAD_COMP,\r\n0x40 | USB_DIR_OUT,\r\nfirm_offset >> 8, 0, NULL, 0, HZ);\r\nif (err)\r\nreturn -EIO;\r\ndev_info(&hif_dev->udev->dev, "ath9k_htc: Transferred FW: %s, size: %ld\n",\r\nhif_dev->fw_name, (unsigned long) hif_dev->fw_size);\r\nreturn 0;\r\n}\r\nstatic int ath9k_hif_usb_dev_init(struct hif_device_usb *hif_dev)\r\n{\r\nint ret;\r\nret = ath9k_hif_usb_download_fw(hif_dev);\r\nif (ret) {\r\ndev_err(&hif_dev->udev->dev,\r\n"ath9k_htc: Firmware - %s download failed\n",\r\nhif_dev->fw_name);\r\nreturn ret;\r\n}\r\nret = ath9k_hif_usb_alloc_urbs(hif_dev);\r\nif (ret) {\r\ndev_err(&hif_dev->udev->dev,\r\n"ath9k_htc: Unable to allocate URBs\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath9k_hif_usb_dev_deinit(struct hif_device_usb *hif_dev)\r\n{\r\nath9k_hif_usb_dealloc_urbs(hif_dev);\r\n}\r\nstatic void ath9k_hif_usb_firmware_fail(struct hif_device_usb *hif_dev)\r\n{\r\nstruct device *dev = &hif_dev->udev->dev;\r\nstruct device *parent = dev->parent;\r\ncomplete_all(&hif_dev->fw_done);\r\nif (parent)\r\ndevice_lock(parent);\r\ndevice_release_driver(dev);\r\nif (parent)\r\ndevice_unlock(parent);\r\n}\r\nstatic int ath9k_hif_request_firmware(struct hif_device_usb *hif_dev,\r\nbool first)\r\n{\r\nchar index[8], *chip;\r\nint ret;\r\nif (first) {\r\nif (htc_use_dev_fw) {\r\nhif_dev->fw_minor_index = FIRMWARE_MINOR_IDX_MAX + 1;\r\nsprintf(index, "%s", "dev");\r\n} else {\r\nhif_dev->fw_minor_index = FIRMWARE_MINOR_IDX_MAX;\r\nsprintf(index, "%d", hif_dev->fw_minor_index);\r\n}\r\n} else {\r\nhif_dev->fw_minor_index--;\r\nsprintf(index, "%d", hif_dev->fw_minor_index);\r\n}\r\nif (MAJOR_VERSION_REQ == 1 && hif_dev->fw_minor_index == 3) {\r\nconst char *filename;\r\nif (IS_AR7010_DEVICE(hif_dev->usb_device_id->driver_info))\r\nfilename = FIRMWARE_AR7010_1_1;\r\nelse\r\nfilename = FIRMWARE_AR9271;\r\nsnprintf(hif_dev->fw_name, sizeof(hif_dev->fw_name),\r\n"%s", filename);\r\n} else if (hif_dev->fw_minor_index < FIRMWARE_MINOR_IDX_MIN) {\r\ndev_err(&hif_dev->udev->dev, "no suitable firmware found!\n");\r\nreturn -ENOENT;\r\n} else {\r\nif (IS_AR7010_DEVICE(hif_dev->usb_device_id->driver_info))\r\nchip = "7010";\r\nelse\r\nchip = "9271";\r\nsnprintf(hif_dev->fw_name, sizeof(hif_dev->fw_name),\r\n"%s/htc_%s-%d.%s.0.fw", HTC_FW_PATH,\r\nchip, MAJOR_VERSION_REQ, index);\r\n}\r\nret = request_firmware_nowait(THIS_MODULE, true, hif_dev->fw_name,\r\n&hif_dev->udev->dev, GFP_KERNEL,\r\nhif_dev, ath9k_hif_usb_firmware_cb);\r\nif (ret) {\r\ndev_err(&hif_dev->udev->dev,\r\n"ath9k_htc: Async request for firmware %s failed\n",\r\nhif_dev->fw_name);\r\nreturn ret;\r\n}\r\ndev_info(&hif_dev->udev->dev, "ath9k_htc: Firmware %s requested\n",\r\nhif_dev->fw_name);\r\nreturn ret;\r\n}\r\nstatic void ath9k_hif_usb_firmware_cb(const struct firmware *fw, void *context)\r\n{\r\nstruct hif_device_usb *hif_dev = context;\r\nint ret;\r\nif (!fw) {\r\nret = ath9k_hif_request_firmware(hif_dev, false);\r\nif (!ret)\r\nreturn;\r\ndev_err(&hif_dev->udev->dev,\r\n"ath9k_htc: Failed to get firmware %s\n",\r\nhif_dev->fw_name);\r\ngoto err_fw;\r\n}\r\nhif_dev->htc_handle = ath9k_htc_hw_alloc(hif_dev, &hif_usb,\r\n&hif_dev->udev->dev);\r\nif (hif_dev->htc_handle == NULL)\r\ngoto err_dev_alloc;\r\nhif_dev->fw_data = fw->data;\r\nhif_dev->fw_size = fw->size;\r\nret = ath9k_hif_usb_dev_init(hif_dev);\r\nif (ret)\r\ngoto err_dev_init;\r\nret = ath9k_htc_hw_init(hif_dev->htc_handle,\r\n&hif_dev->interface->dev,\r\nhif_dev->usb_device_id->idProduct,\r\nhif_dev->udev->product,\r\nhif_dev->usb_device_id->driver_info);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto err_htc_hw_init;\r\n}\r\nrelease_firmware(fw);\r\nhif_dev->flags |= HIF_USB_READY;\r\ncomplete_all(&hif_dev->fw_done);\r\nreturn;\r\nerr_htc_hw_init:\r\nath9k_hif_usb_dev_deinit(hif_dev);\r\nerr_dev_init:\r\nath9k_htc_hw_free(hif_dev->htc_handle);\r\nerr_dev_alloc:\r\nrelease_firmware(fw);\r\nerr_fw:\r\nath9k_hif_usb_firmware_fail(hif_dev);\r\n}\r\nstatic int send_eject_command(struct usb_interface *interface)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_host_interface *iface_desc = &interface->altsetting[0];\r\nstruct usb_endpoint_descriptor *endpoint;\r\nunsigned char *cmd;\r\nu8 bulk_out_ep;\r\nint r;\r\nfor (r = 1; r >= 0; r--) {\r\nendpoint = &iface_desc->endpoint[r].desc;\r\nif (usb_endpoint_dir_out(endpoint) &&\r\nusb_endpoint_xfer_bulk(endpoint)) {\r\nbulk_out_ep = endpoint->bEndpointAddress;\r\nbreak;\r\n}\r\n}\r\nif (r == -1) {\r\ndev_err(&udev->dev,\r\n"ath9k_htc: Could not find bulk out endpoint\n");\r\nreturn -ENODEV;\r\n}\r\ncmd = kzalloc(31, GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENODEV;\r\ncmd[0] = 0x55;\r\ncmd[1] = 0x53;\r\ncmd[2] = 0x42;\r\ncmd[3] = 0x43;\r\ncmd[14] = 6;\r\ncmd[15] = 0x1b;\r\ncmd[19] = 0x2;\r\ndev_info(&udev->dev, "Ejecting storage device...\n");\r\nr = usb_bulk_msg(udev, usb_sndbulkpipe(udev, bulk_out_ep),\r\ncmd, 31, NULL, 2000);\r\nkfree(cmd);\r\nif (r)\r\nreturn r;\r\nusb_set_intfdata(interface, NULL);\r\nreturn 0;\r\n}\r\nstatic int ath9k_hif_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct hif_device_usb *hif_dev;\r\nint ret = 0;\r\nif (id->driver_info == STORAGE_DEVICE)\r\nreturn send_eject_command(interface);\r\nhif_dev = kzalloc(sizeof(struct hif_device_usb), GFP_KERNEL);\r\nif (!hif_dev) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nusb_get_dev(udev);\r\nhif_dev->udev = udev;\r\nhif_dev->interface = interface;\r\nhif_dev->usb_device_id = id;\r\n#ifdef CONFIG_PM\r\nudev->reset_resume = 1;\r\n#endif\r\nusb_set_intfdata(interface, hif_dev);\r\ninit_completion(&hif_dev->fw_done);\r\nret = ath9k_hif_request_firmware(hif_dev, true);\r\nif (ret)\r\ngoto err_fw_req;\r\nreturn ret;\r\nerr_fw_req:\r\nusb_set_intfdata(interface, NULL);\r\nkfree(hif_dev);\r\nusb_put_dev(udev);\r\nerr_alloc:\r\nreturn ret;\r\n}\r\nstatic void ath9k_hif_usb_reboot(struct usb_device *udev)\r\n{\r\nu32 reboot_cmd = 0xffffffff;\r\nvoid *buf;\r\nint ret;\r\nbuf = kmemdup(&reboot_cmd, 4, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nret = usb_interrupt_msg(udev, usb_sndintpipe(udev, USB_REG_OUT_PIPE),\r\nbuf, 4, NULL, HZ);\r\nif (ret)\r\ndev_err(&udev->dev, "ath9k_htc: USB reboot failed\n");\r\nkfree(buf);\r\n}\r\nstatic void ath9k_hif_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct hif_device_usb *hif_dev = usb_get_intfdata(interface);\r\nbool unplugged = (udev->state == USB_STATE_NOTATTACHED) ? true : false;\r\nif (!hif_dev)\r\nreturn;\r\nwait_for_completion(&hif_dev->fw_done);\r\nif (hif_dev->flags & HIF_USB_READY) {\r\nath9k_htc_hw_deinit(hif_dev->htc_handle, unplugged);\r\nath9k_htc_hw_free(hif_dev->htc_handle);\r\nath9k_hif_usb_dev_deinit(hif_dev);\r\n}\r\nusb_set_intfdata(interface, NULL);\r\nif (!unplugged && (hif_dev->flags & HIF_USB_READY))\r\nath9k_hif_usb_reboot(udev);\r\nkfree(hif_dev);\r\ndev_info(&udev->dev, "ath9k_htc: USB layer deinitialized\n");\r\nusb_put_dev(udev);\r\n}\r\nstatic int ath9k_hif_usb_suspend(struct usb_interface *interface,\r\npm_message_t message)\r\n{\r\nstruct hif_device_usb *hif_dev = usb_get_intfdata(interface);\r\nif (!(hif_dev->flags & HIF_USB_START))\r\nath9k_htc_suspend(hif_dev->htc_handle);\r\nwait_for_completion(&hif_dev->fw_done);\r\nif (hif_dev->flags & HIF_USB_READY)\r\nath9k_hif_usb_dealloc_urbs(hif_dev);\r\nreturn 0;\r\n}\r\nstatic int ath9k_hif_usb_resume(struct usb_interface *interface)\r\n{\r\nstruct hif_device_usb *hif_dev = usb_get_intfdata(interface);\r\nstruct htc_target *htc_handle = hif_dev->htc_handle;\r\nint ret;\r\nconst struct firmware *fw;\r\nret = ath9k_hif_usb_alloc_urbs(hif_dev);\r\nif (ret)\r\nreturn ret;\r\nif (hif_dev->flags & HIF_USB_READY) {\r\nret = request_firmware(&fw, hif_dev->fw_name,\r\n&hif_dev->udev->dev);\r\nif (ret)\r\ngoto fail_resume;\r\nhif_dev->fw_data = fw->data;\r\nhif_dev->fw_size = fw->size;\r\nret = ath9k_hif_usb_download_fw(hif_dev);\r\nrelease_firmware(fw);\r\nif (ret)\r\ngoto fail_resume;\r\n} else {\r\nath9k_hif_usb_dealloc_urbs(hif_dev);\r\nreturn -EIO;\r\n}\r\nmdelay(100);\r\nret = ath9k_htc_resume(htc_handle);\r\nif (ret)\r\ngoto fail_resume;\r\nreturn 0;\r\nfail_resume:\r\nath9k_hif_usb_dealloc_urbs(hif_dev);\r\nreturn ret;\r\n}\r\nint ath9k_hif_usb_init(void)\r\n{\r\nreturn usb_register(&ath9k_hif_usb_driver);\r\n}\r\nvoid ath9k_hif_usb_exit(void)\r\n{\r\nusb_deregister(&ath9k_hif_usb_driver);\r\n}
