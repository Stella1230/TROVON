int amon_cpu_avail(int cpu)\r\n{\r\nstruct cpulaunch *launch = (struct cpulaunch *)CKSEG0ADDR(CPULAUNCH);\r\nif (cpu < 0 || cpu >= NCPULAUNCH) {\r\npr_debug("avail: cpu%d is out of range\n", cpu);\r\nreturn 0;\r\n}\r\nlaunch += cpu;\r\nif (!(launch->flags & LAUNCH_FREADY)) {\r\npr_debug("avail: cpu%d is not ready\n", cpu);\r\nreturn 0;\r\n}\r\nif (launch->flags & (LAUNCH_FGO|LAUNCH_FGONE)) {\r\npr_debug("avail: too late.. cpu%d is already gone\n", cpu);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint amon_cpu_start(int cpu,\r\nunsigned long pc, unsigned long sp,\r\nunsigned long gp, unsigned long a0)\r\n{\r\nvolatile struct cpulaunch *launch =\r\n(struct cpulaunch *)CKSEG0ADDR(CPULAUNCH);\r\nif (!amon_cpu_avail(cpu))\r\nreturn -1;\r\nif (cpu == smp_processor_id()) {\r\npr_debug("launch: I am cpu%d!\n", cpu);\r\nreturn -1;\r\n}\r\nlaunch += cpu;\r\npr_debug("launch: starting cpu%d\n", cpu);\r\nlaunch->pc = pc;\r\nlaunch->gp = gp;\r\nlaunch->sp = sp;\r\nlaunch->a0 = a0;\r\nsmp_wmb();\r\nlaunch->flags |= LAUNCH_FGO;\r\nsmp_wmb();\r\nwhile ((launch->flags & LAUNCH_FGONE) == 0)\r\n;\r\nsmp_rmb();\r\npr_debug("launch: cpu%d gone!\n", cpu);\r\nreturn 0;\r\n}\r\nint vpe_run(struct vpe *v)\r\n{\r\nstruct vpe_notifications *n;\r\nif (amon_cpu_start(aprp_cpu_index(), v->__start, 0, 0, 0) < 0)\r\nreturn -1;\r\nlist_for_each_entry(n, &v->notify, list)\r\nn->start(VPE_MODULE_MINOR);\r\nreturn 0;\r\n}
