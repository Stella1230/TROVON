static int wait_for_reg_status(void __iomem *base, u32 reg, u32 checkbit,\r\nu32 status)\r\n{\r\nunsigned long timeout = jiffies + PHY_PLL_TIMEOUT;\r\nwhile (time_before(jiffies, timeout)) {\r\nif ((readl(base + reg) & checkbit) == status)\r\nreturn 0;\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic int exynos_sata_phy_power_on(struct phy *phy)\r\n{\r\nstruct exynos_sata_phy *sata_phy = phy_get_drvdata(phy);\r\nreturn regmap_update_bits(sata_phy->pmureg, SATAPHY_CONTROL_OFFSET,\r\nEXYNOS5_SATAPHY_PMU_ENABLE, true);\r\n}\r\nstatic int exynos_sata_phy_power_off(struct phy *phy)\r\n{\r\nstruct exynos_sata_phy *sata_phy = phy_get_drvdata(phy);\r\nreturn regmap_update_bits(sata_phy->pmureg, SATAPHY_CONTROL_OFFSET,\r\nEXYNOS5_SATAPHY_PMU_ENABLE, false);\r\n}\r\nstatic int exynos_sata_phy_init(struct phy *phy)\r\n{\r\nu32 val = 0;\r\nint ret = 0;\r\nu8 buf[] = { 0x3a, 0x0b };\r\nstruct exynos_sata_phy *sata_phy = phy_get_drvdata(phy);\r\nret = regmap_update_bits(sata_phy->pmureg, SATAPHY_CONTROL_OFFSET,\r\nEXYNOS5_SATAPHY_PMU_ENABLE, true);\r\nif (ret != 0)\r\ndev_err(&sata_phy->phy->dev, "phy init failed\n");\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval |= RESET_GLOBAL_RST_N | RESET_CMN_RST_N | RESET_CMN_BLOCK_RST_N\r\n| RESET_CMN_I2C_RST_N | RESET_TX_RX_PIPE_RST_N\r\n| RESET_TX_RX_BLOCK_RST_N | RESET_TX_RX_I2C_RST_N;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval |= LINK_RESET;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval |= RESET_CMN_RST_N;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_PHSATA_CTRLM);\r\nval &= ~PHCTRLM_REF_RATE;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_PHSATA_CTRLM);\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_PHSATA_CTRLM);\r\nval |= PHCTRLM_HIGH_SPEED;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_PHSATA_CTRLM);\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_CTRL0);\r\nval |= CTRL0_P0_PHY_CALIBRATED_SEL | CTRL0_P0_PHY_CALIBRATED;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_CTRL0);\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_MODE0);\r\nval |= SATA_SPD_GEN3;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_MODE0);\r\nret = i2c_master_send(sata_phy->client, buf, sizeof(buf));\r\nif (ret < 0)\r\nreturn ret;\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval &= ~RESET_CMN_RST_N;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval = readl(sata_phy->regs + EXYNOS5_SATA_RESET);\r\nval |= RESET_CMN_RST_N;\r\nwritel(val, sata_phy->regs + EXYNOS5_SATA_RESET);\r\nret = wait_for_reg_status(sata_phy->regs,\r\nEXYNOS5_SATA_PHSATA_STATM,\r\nPHSTATM_PLL_LOCKED, 1);\r\nif (ret < 0)\r\ndev_err(&sata_phy->phy->dev,\r\n"PHY PLL locking failed\n");\r\nreturn ret;\r\n}\r\nstatic int exynos_sata_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos_sata_phy *sata_phy;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct phy_provider *phy_provider;\r\nstruct device_node *node;\r\nint ret = 0;\r\nsata_phy = devm_kzalloc(dev, sizeof(*sata_phy), GFP_KERNEL);\r\nif (!sata_phy)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsata_phy->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(sata_phy->regs))\r\nreturn PTR_ERR(sata_phy->regs);\r\nsata_phy->pmureg = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"samsung,syscon-phandle");\r\nif (IS_ERR(sata_phy->pmureg)) {\r\ndev_err(dev, "syscon regmap lookup failed.\n");\r\nreturn PTR_ERR(sata_phy->pmureg);\r\n}\r\nnode = of_parse_phandle(dev->of_node,\r\n"samsung,exynos-sataphy-i2c-phandle", 0);\r\nif (!node)\r\nreturn -EINVAL;\r\nsata_phy->client = of_find_i2c_device_by_node(node);\r\nif (!sata_phy->client)\r\nreturn -EPROBE_DEFER;\r\ndev_set_drvdata(dev, sata_phy);\r\nsata_phy->phyclk = devm_clk_get(dev, "sata_phyctrl");\r\nif (IS_ERR(sata_phy->phyclk)) {\r\ndev_err(dev, "failed to get clk for PHY\n");\r\nreturn PTR_ERR(sata_phy->phyclk);\r\n}\r\nret = clk_prepare_enable(sata_phy->phyclk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable source clk\n");\r\nreturn ret;\r\n}\r\nsata_phy->phy = devm_phy_create(dev, NULL, &exynos_sata_phy_ops);\r\nif (IS_ERR(sata_phy->phy)) {\r\nclk_disable_unprepare(sata_phy->phyclk);\r\ndev_err(dev, "failed to create PHY\n");\r\nreturn PTR_ERR(sata_phy->phy);\r\n}\r\nphy_set_drvdata(sata_phy->phy, sata_phy);\r\nphy_provider = devm_of_phy_provider_register(dev,\r\nof_phy_simple_xlate);\r\nif (IS_ERR(phy_provider)) {\r\nclk_disable_unprepare(sata_phy->phyclk);\r\nreturn PTR_ERR(phy_provider);\r\n}\r\nreturn 0;\r\n}
