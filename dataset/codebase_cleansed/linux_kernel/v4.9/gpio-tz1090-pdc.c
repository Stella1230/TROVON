static inline void pdc_write(struct tz1090_pdc_gpio *priv, unsigned int reg_offs,\r\nunsigned int data)\r\n{\r\nwritel(data, priv->reg + reg_offs);\r\n}\r\nstatic inline unsigned int pdc_read(struct tz1090_pdc_gpio *priv,\r\nunsigned int reg_offs)\r\n{\r\nreturn readl(priv->reg + reg_offs);\r\n}\r\nstatic int tz1090_pdc_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct tz1090_pdc_gpio *priv = gpiochip_get_data(chip);\r\nu32 value;\r\nint lstat;\r\n__global_lock2(lstat);\r\nvalue = pdc_read(priv, REG_SOC_GPIO_CONTROL1);\r\nvalue |= BIT(offset);\r\npdc_write(priv, REG_SOC_GPIO_CONTROL1, value);\r\n__global_unlock2(lstat);\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset,\r\nint output_value)\r\n{\r\nstruct tz1090_pdc_gpio *priv = gpiochip_get_data(chip);\r\nu32 value;\r\nint lstat;\r\n__global_lock2(lstat);\r\nif (offset < 6) {\r\nvalue = pdc_read(priv, REG_SOC_GPIO_CONTROL0);\r\nif (output_value)\r\nvalue |= BIT(offset);\r\nelse\r\nvalue &= ~BIT(offset);\r\npdc_write(priv, REG_SOC_GPIO_CONTROL0, value);\r\n}\r\nvalue = pdc_read(priv, REG_SOC_GPIO_CONTROL1);\r\nvalue &= ~BIT(offset);\r\npdc_write(priv, REG_SOC_GPIO_CONTROL1, value);\r\n__global_unlock2(lstat);\r\nreturn 0;\r\n}\r\nstatic int tz1090_pdc_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct tz1090_pdc_gpio *priv = gpiochip_get_data(chip);\r\nreturn !!(pdc_read(priv, REG_SOC_GPIO_STATUS) & BIT(offset));\r\n}\r\nstatic void tz1090_pdc_gpio_set(struct gpio_chip *chip, unsigned int offset,\r\nint output_value)\r\n{\r\nstruct tz1090_pdc_gpio *priv = gpiochip_get_data(chip);\r\nu32 value;\r\nint lstat;\r\nif (offset >= 6)\r\nreturn;\r\n__global_lock2(lstat);\r\nvalue = pdc_read(priv, REG_SOC_GPIO_CONTROL0);\r\nif (output_value)\r\nvalue |= BIT(offset);\r\nelse\r\nvalue &= ~BIT(offset);\r\npdc_write(priv, REG_SOC_GPIO_CONTROL0, value);\r\n__global_unlock2(lstat);\r\n}\r\nstatic int tz1090_pdc_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct tz1090_pdc_gpio *priv = gpiochip_get_data(chip);\r\nunsigned int syswake = offset - GPIO_PDC_IRQ_FIRST;\r\nint irq;\r\nif (syswake >= GPIO_PDC_NIRQ)\r\nreturn -EINVAL;\r\nirq = priv->irq[syswake];\r\nif (!irq)\r\nreturn -EINVAL;\r\nreturn irq;\r\n}\r\nstatic int tz1090_pdc_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res_regs;\r\nstruct tz1090_pdc_gpio *priv;\r\nunsigned int i;\r\nif (!np) {\r\ndev_err(&pdev->dev, "must be instantiated via devicetree\n");\r\nreturn -ENOENT;\r\n}\r\nres_regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_regs) {\r\ndev_err(&pdev->dev, "cannot find registers resource\n");\r\nreturn -ENOENT;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "unable to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->reg = devm_ioremap(&pdev->dev, res_regs->start,\r\nresource_size(res_regs));\r\nif (!priv->reg) {\r\ndev_err(&pdev->dev, "unable to ioremap registers\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->chip.label = "tz1090-pdc-gpio";\r\npriv->chip.parent = &pdev->dev;\r\npriv->chip.direction_input = tz1090_pdc_gpio_direction_input;\r\npriv->chip.direction_output = tz1090_pdc_gpio_direction_output;\r\npriv->chip.get = tz1090_pdc_gpio_get;\r\npriv->chip.set = tz1090_pdc_gpio_set;\r\npriv->chip.free = gpiochip_generic_free;\r\npriv->chip.request = gpiochip_generic_request;\r\npriv->chip.to_irq = tz1090_pdc_gpio_to_irq;\r\npriv->chip.of_node = np;\r\npriv->chip.base = GPIO_PDC_BASE;\r\npriv->chip.ngpio = GPIO_PDC_NGPIO;\r\nfor (i = 0; i < GPIO_PDC_NIRQ; ++i)\r\npriv->irq[i] = irq_of_parse_and_map(np, i);\r\ngpiochip_add_data(&priv->chip, priv);\r\nreturn 0;\r\n}\r\nstatic int __init tz1090_pdc_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&tz1090_pdc_gpio_driver);\r\n}
