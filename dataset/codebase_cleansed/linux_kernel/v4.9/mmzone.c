struct pglist_data *first_online_pgdat(void)\r\n{\r\nreturn NODE_DATA(first_online_node);\r\n}\r\nstruct pglist_data *next_online_pgdat(struct pglist_data *pgdat)\r\n{\r\nint nid = next_online_node(pgdat->node_id);\r\nif (nid == MAX_NUMNODES)\r\nreturn NULL;\r\nreturn NODE_DATA(nid);\r\n}\r\nstruct zone *next_zone(struct zone *zone)\r\n{\r\npg_data_t *pgdat = zone->zone_pgdat;\r\nif (zone < pgdat->node_zones + MAX_NR_ZONES - 1)\r\nzone++;\r\nelse {\r\npgdat = next_online_pgdat(pgdat);\r\nif (pgdat)\r\nzone = pgdat->node_zones;\r\nelse\r\nzone = NULL;\r\n}\r\nreturn zone;\r\n}\r\nstatic inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)\r\n{\r\n#ifdef CONFIG_NUMA\r\nreturn node_isset(zonelist_node_idx(zref), *nodes);\r\n#else\r\nreturn 1;\r\n#endif\r\n}\r\nstruct zoneref *__next_zones_zonelist(struct zoneref *z,\r\nenum zone_type highest_zoneidx,\r\nnodemask_t *nodes)\r\n{\r\nif (likely(nodes == NULL))\r\nwhile (zonelist_zone_idx(z) > highest_zoneidx)\r\nz++;\r\nelse\r\nwhile (zonelist_zone_idx(z) > highest_zoneidx ||\r\n(z->zone && !zref_in_nodemask(z, nodes)))\r\nz++;\r\nreturn z;\r\n}\r\nbool memmap_valid_within(unsigned long pfn,\r\nstruct page *page, struct zone *zone)\r\n{\r\nif (page_to_pfn(page) != pfn)\r\nreturn false;\r\nif (page_zone(page) != zone)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid lruvec_init(struct lruvec *lruvec)\r\n{\r\nenum lru_list lru;\r\nmemset(lruvec, 0, sizeof(struct lruvec));\r\nfor_each_lru(lru)\r\nINIT_LIST_HEAD(&lruvec->lists[lru]);\r\n}\r\nint page_cpupid_xchg_last(struct page *page, int cpupid)\r\n{\r\nunsigned long old_flags, flags;\r\nint last_cpupid;\r\ndo {\r\nold_flags = flags = page->flags;\r\nlast_cpupid = page_cpupid_last(page);\r\nflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\r\nflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\r\n} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\r\nreturn last_cpupid;\r\n}
