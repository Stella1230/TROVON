static int dwc2_periodic_channel_available(struct dwc2_hsotg *hsotg)\r\n{\r\nint status;\r\nint num_channels;\r\nnum_channels = hsotg->core_params->host_channels;\r\nif (hsotg->periodic_channels + hsotg->non_periodic_channels <\r\nnum_channels\r\n&& hsotg->periodic_channels < num_channels - 1) {\r\nstatus = 0;\r\n} else {\r\ndev_dbg(hsotg->dev,\r\n"%s: Total channels: %d, Periodic: %d, "\r\n"Non-periodic: %d\n", __func__, num_channels,\r\nhsotg->periodic_channels, hsotg->non_periodic_channels);\r\nstatus = -ENOSPC;\r\n}\r\nreturn status;\r\n}\r\nstatic int dwc2_check_periodic_bandwidth(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nint status;\r\ns16 max_claimed_usecs;\r\nstatus = 0;\r\nif (qh->dev_speed == USB_SPEED_HIGH || qh->do_split) {\r\nmax_claimed_usecs = 100 - qh->host_us;\r\n} else {\r\nmax_claimed_usecs = 900 - qh->host_us;\r\n}\r\nif (hsotg->periodic_usecs > max_claimed_usecs) {\r\ndev_err(hsotg->dev,\r\n"%s: already claimed usecs %d, required usecs %d\n",\r\n__func__, hsotg->periodic_usecs, qh->host_us);\r\nstatus = -ENOSPC;\r\n}\r\nreturn status;\r\n}\r\nstatic int pmap_schedule(unsigned long *map, int bits_per_period,\r\nint periods_in_map, int num_bits,\r\nint interval, int start, bool only_one_period)\r\n{\r\nint interval_bits;\r\nint to_reserve;\r\nint first_end;\r\nint i;\r\nif (num_bits > bits_per_period)\r\nreturn -ENOSPC;\r\ninterval = gcd(interval, periods_in_map);\r\ninterval_bits = bits_per_period * interval;\r\nto_reserve = periods_in_map / interval;\r\nif (start >= interval_bits)\r\nreturn -ENOSPC;\r\nif (only_one_period)\r\nfirst_end = (start / bits_per_period + 1) * bits_per_period;\r\nelse\r\nfirst_end = interval_bits;\r\nwhile (start + num_bits <= first_end) {\r\nint end;\r\nend = (start / bits_per_period + 1) * bits_per_period;\r\nstart = bitmap_find_next_zero_area(map, end, start, num_bits,\r\n0);\r\nif (start >= end) {\r\nstart = end;\r\ncontinue;\r\n}\r\nfor (i = 1; i < to_reserve; i++) {\r\nint ith_start = start + interval_bits * i;\r\nint ith_end = end + interval_bits * i;\r\nint ret;\r\nret = bitmap_find_next_zero_area(\r\nmap, ith_start + num_bits, ith_start, num_bits,\r\n0);\r\nif (ret == ith_start)\r\ncontinue;\r\nith_start = bitmap_find_next_zero_area(\r\nmap, ith_end, ith_start, num_bits, 0);\r\nif (ith_start >= ith_end)\r\nstart = end;\r\nelse\r\nstart = ith_start - interval_bits * i;\r\nbreak;\r\n}\r\nif (i == to_reserve)\r\nbreak;\r\n}\r\nif (start + num_bits > first_end)\r\nreturn -ENOSPC;\r\nfor (i = 0; i < to_reserve; i++) {\r\nint ith_start = start + interval_bits * i;\r\nbitmap_set(map, ith_start, num_bits);\r\n}\r\nreturn start;\r\n}\r\nstatic void pmap_unschedule(unsigned long *map, int bits_per_period,\r\nint periods_in_map, int num_bits,\r\nint interval, int start)\r\n{\r\nint interval_bits;\r\nint to_release;\r\nint i;\r\ninterval = gcd(interval, periods_in_map);\r\ninterval_bits = bits_per_period * interval;\r\nto_release = periods_in_map / interval;\r\nfor (i = 0; i < to_release; i++) {\r\nint ith_start = start + interval_bits * i;\r\nbitmap_clear(map, ith_start, num_bits);\r\n}\r\n}\r\nvoid pmap_print(unsigned long *map, int bits_per_period,\r\nint periods_in_map, const char *period_name,\r\nconst char *units,\r\nvoid (*print_fn)(const char *str, void *data),\r\nvoid *print_data)\r\n{\r\nint period;\r\nfor (period = 0; period < periods_in_map; period++) {\r\nchar tmp[64];\r\nchar *buf = tmp;\r\nsize_t buf_size = sizeof(tmp);\r\nint period_start = period * bits_per_period;\r\nint period_end = period_start + bits_per_period;\r\nint start = 0;\r\nint count = 0;\r\nbool printed = false;\r\nint i;\r\nfor (i = period_start; i < period_end + 1; i++) {\r\nif (i < period_end &&\r\nbitmap_find_next_zero_area(map, i + 1,\r\ni, 1, 0) != i) {\r\nif (count == 0)\r\nstart = i - period_start;\r\ncount++;\r\ncontinue;\r\n}\r\nif (count == 0)\r\ncontinue;\r\nif (!printed)\r\ncat_printf(&buf, &buf_size, "%s %d: ",\r\nperiod_name, period);\r\nelse\r\ncat_printf(&buf, &buf_size, ", ");\r\nprinted = true;\r\ncat_printf(&buf, &buf_size, "%d %s -%3d %s", start,\r\nunits, start + count - 1, units);\r\ncount = 0;\r\n}\r\nif (printed)\r\nprint_fn(tmp, print_data);\r\n}\r\n}\r\nstatic unsigned long *dwc2_get_ls_map(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nunsigned long *map;\r\nif (WARN_ON(!qh->dwc_tt))\r\nreturn NULL;\r\nmap = qh->dwc_tt->periodic_bitmaps;\r\nif (qh->dwc_tt->usb_tt->multi)\r\nmap += DWC2_ELEMENTS_PER_LS_BITMAP * qh->ttport;\r\nreturn map;\r\n}\r\nstatic void dwc2_qh_print(const char *str, void *data)\r\n{\r\nstruct dwc2_qh_print_data *print_data = data;\r\ndwc2_sch_dbg(print_data->hsotg, "QH=%p ...%s\n", print_data->qh, str);\r\n}\r\nstatic void dwc2_qh_schedule_print(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nstruct dwc2_qh_print_data print_data = { hsotg, qh };\r\nint i;\r\n#ifndef DWC2_PRINT_SCHEDULE\r\nreturn;\r\n#endif\r\nif (qh->schedule_low_speed) {\r\nunsigned long *map = dwc2_get_ls_map(hsotg, qh);\r\ndwc2_sch_dbg(hsotg, "QH=%p LS/FS trans: %d=>%d us @ %d us",\r\nqh, qh->device_us,\r\nDWC2_ROUND_US_TO_SLICE(qh->device_us),\r\nDWC2_US_PER_SLICE * qh->ls_start_schedule_slice);\r\nif (map) {\r\ndwc2_sch_dbg(hsotg,\r\n"QH=%p Whole low/full speed map %p now:\n",\r\nqh, map);\r\npmap_print(map, DWC2_LS_PERIODIC_SLICES_PER_FRAME,\r\nDWC2_LS_SCHEDULE_FRAMES, "Frame ", "slices",\r\ndwc2_qh_print, &print_data);\r\n}\r\n}\r\nfor (i = 0; i < qh->num_hs_transfers; i++) {\r\nstruct dwc2_hs_transfer_time *trans_time = qh->hs_transfers + i;\r\nint uframe = trans_time->start_schedule_us /\r\nDWC2_HS_PERIODIC_US_PER_UFRAME;\r\nint rel_us = trans_time->start_schedule_us %\r\nDWC2_HS_PERIODIC_US_PER_UFRAME;\r\ndwc2_sch_dbg(hsotg,\r\n"QH=%p HS trans #%d: %d us @ uFrame %d + %d us\n",\r\nqh, i, trans_time->duration_us, uframe, rel_us);\r\n}\r\nif (qh->num_hs_transfers) {\r\ndwc2_sch_dbg(hsotg, "QH=%p Whole high speed map now:\n", qh);\r\npmap_print(hsotg->hs_periodic_bitmap,\r\nDWC2_HS_PERIODIC_US_PER_UFRAME,\r\nDWC2_HS_SCHEDULE_UFRAMES, "uFrame", "us",\r\ndwc2_qh_print, &print_data);\r\n}\r\n}\r\nstatic int dwc2_ls_pmap_schedule(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\r\nint search_slice)\r\n{\r\nint slices = DIV_ROUND_UP(qh->device_us, DWC2_US_PER_SLICE);\r\nunsigned long *map = dwc2_get_ls_map(hsotg, qh);\r\nint slice;\r\nif (map == NULL)\r\nreturn -EINVAL;\r\nslice = pmap_schedule(map, DWC2_LS_PERIODIC_SLICES_PER_FRAME,\r\nDWC2_LS_SCHEDULE_FRAMES, slices,\r\nqh->device_interval, search_slice, false);\r\nif (slice < 0)\r\nreturn slice;\r\nqh->ls_start_schedule_slice = slice;\r\nreturn 0;\r\n}\r\nstatic void dwc2_ls_pmap_unschedule(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nint slices = DIV_ROUND_UP(qh->device_us, DWC2_US_PER_SLICE);\r\nunsigned long *map = dwc2_get_ls_map(hsotg, qh);\r\nif (map == NULL)\r\nreturn;\r\npmap_unschedule(map, DWC2_LS_PERIODIC_SLICES_PER_FRAME,\r\nDWC2_LS_SCHEDULE_FRAMES, slices, qh->device_interval,\r\nqh->ls_start_schedule_slice);\r\n}\r\nstatic int dwc2_hs_pmap_schedule(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\r\nbool only_one_period, int index)\r\n{\r\nstruct dwc2_hs_transfer_time *trans_time = qh->hs_transfers + index;\r\nint us;\r\nus = pmap_schedule(hsotg->hs_periodic_bitmap,\r\nDWC2_HS_PERIODIC_US_PER_UFRAME,\r\nDWC2_HS_SCHEDULE_UFRAMES, trans_time->duration_us,\r\nqh->host_interval, trans_time->start_schedule_us,\r\nonly_one_period);\r\nif (us < 0)\r\nreturn us;\r\ntrans_time->start_schedule_us = us;\r\nreturn 0;\r\n}\r\nstatic void dwc2_hs_pmap_unschedule(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh, int index)\r\n{\r\nstruct dwc2_hs_transfer_time *trans_time = qh->hs_transfers + index;\r\npmap_unschedule(hsotg->hs_periodic_bitmap,\r\nDWC2_HS_PERIODIC_US_PER_UFRAME,\r\nDWC2_HS_SCHEDULE_UFRAMES, trans_time->duration_us,\r\nqh->host_interval, trans_time->start_schedule_us);\r\n}\r\nstatic int dwc2_uframe_schedule_split(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nint bytecount = dwc2_hb_mult(qh->maxp) * dwc2_max_packet(qh->maxp);\r\nint ls_search_slice;\r\nint err = 0;\r\nint host_interval_in_sched;\r\nhost_interval_in_sched = gcd(qh->host_interval,\r\nDWC2_HS_SCHEDULE_UFRAMES);\r\nls_search_slice = 0;\r\nwhile (ls_search_slice < DWC2_LS_SCHEDULE_SLICES) {\r\nint start_s_uframe;\r\nint ssplit_s_uframe;\r\nint second_s_uframe;\r\nint rel_uframe;\r\nint first_count;\r\nint middle_count;\r\nint end_count;\r\nint first_data_bytes;\r\nint other_data_bytes;\r\nint i;\r\nif (qh->schedule_low_speed) {\r\nerr = dwc2_ls_pmap_schedule(hsotg, qh, ls_search_slice);\r\nif (err)\r\nreturn err;\r\n} else {\r\nWARN_ON_ONCE(1);\r\n}\r\nstart_s_uframe = qh->ls_start_schedule_slice /\r\nDWC2_SLICES_PER_UFRAME;\r\nrel_uframe = (start_s_uframe % 8);\r\nif (rel_uframe == 7) {\r\nif (qh->schedule_low_speed)\r\ndwc2_ls_pmap_unschedule(hsotg, qh);\r\nls_search_slice =\r\n(qh->ls_start_schedule_slice /\r\nDWC2_LS_PERIODIC_SLICES_PER_FRAME + 1) *\r\nDWC2_LS_PERIODIC_SLICES_PER_FRAME;\r\ncontinue;\r\n}\r\nssplit_s_uframe = (start_s_uframe +\r\nhost_interval_in_sched - 1) %\r\nhost_interval_in_sched;\r\nif (qh->ep_type == USB_ENDPOINT_XFER_ISOC && !qh->ep_is_in)\r\nsecond_s_uframe = start_s_uframe;\r\nelse\r\nsecond_s_uframe = start_s_uframe + 1;\r\nfirst_data_bytes = 188 -\r\nDIV_ROUND_UP(188 * (qh->ls_start_schedule_slice %\r\nDWC2_SLICES_PER_UFRAME),\r\nDWC2_SLICES_PER_UFRAME);\r\nif (first_data_bytes > bytecount)\r\nfirst_data_bytes = bytecount;\r\nother_data_bytes = bytecount - first_data_bytes;\r\nif (!qh->ep_is_in &&\r\n(first_data_bytes != min_t(int, 188, bytecount))) {\r\ndwc2_sch_dbg(hsotg,\r\n"QH=%p avoiding broken 1st xfer (%d, %d)\n",\r\nqh, first_data_bytes, bytecount);\r\nif (qh->schedule_low_speed)\r\ndwc2_ls_pmap_unschedule(hsotg, qh);\r\nls_search_slice = (start_s_uframe + 1) *\r\nDWC2_SLICES_PER_UFRAME;\r\ncontinue;\r\n}\r\nqh->num_hs_transfers = 1 + DIV_ROUND_UP(other_data_bytes, 188);\r\nif (qh->ep_type == USB_ENDPOINT_XFER_INT) {\r\nif (rel_uframe == 6)\r\nqh->num_hs_transfers += 2;\r\nelse\r\nqh->num_hs_transfers += 3;\r\nif (qh->ep_is_in) {\r\nfirst_count = 4;\r\nmiddle_count = bytecount;\r\nend_count = bytecount;\r\n} else {\r\nfirst_count = first_data_bytes;\r\nmiddle_count = max_t(int, 4, other_data_bytes);\r\nend_count = 4;\r\n}\r\n} else {\r\nif (qh->ep_is_in) {\r\nint last;\r\nqh->num_hs_transfers++;\r\nlast = rel_uframe + qh->num_hs_transfers + 1;\r\nif (last <= 6)\r\nqh->num_hs_transfers += 2;\r\nelse\r\nqh->num_hs_transfers += 1;\r\nif (last >= 6 && rel_uframe == 0)\r\nqh->num_hs_transfers--;\r\nfirst_count = 4;\r\nmiddle_count = min_t(int, 188, bytecount);\r\nend_count = middle_count;\r\n} else {\r\nfirst_count = first_data_bytes;\r\nmiddle_count = min_t(int, 188,\r\nother_data_bytes);\r\nend_count = other_data_bytes % 188;\r\n}\r\n}\r\nqh->hs_transfers[0].duration_us = HS_USECS_ISO(first_count);\r\nfor (i = 1; i < qh->num_hs_transfers - 1; i++)\r\nqh->hs_transfers[i].duration_us =\r\nHS_USECS_ISO(middle_count);\r\nif (qh->num_hs_transfers > 1)\r\nqh->hs_transfers[qh->num_hs_transfers - 1].duration_us =\r\nHS_USECS_ISO(end_count);\r\nqh->hs_transfers[0].start_schedule_us =\r\nssplit_s_uframe * DWC2_HS_PERIODIC_US_PER_UFRAME;\r\nfor (i = 1; i < qh->num_hs_transfers; i++)\r\nqh->hs_transfers[i].start_schedule_us =\r\n((second_s_uframe + i - 1) %\r\nDWC2_HS_SCHEDULE_UFRAMES) *\r\nDWC2_HS_PERIODIC_US_PER_UFRAME;\r\nfor (i = 0; i < qh->num_hs_transfers; i++) {\r\nerr = dwc2_hs_pmap_schedule(hsotg, qh, true, i);\r\nif (err)\r\nbreak;\r\n}\r\nif (i == qh->num_hs_transfers)\r\nbreak;\r\nfor (; i >= 0; i--)\r\ndwc2_hs_pmap_unschedule(hsotg, qh, i);\r\nif (qh->schedule_low_speed)\r\ndwc2_ls_pmap_unschedule(hsotg, qh);\r\nls_search_slice = (start_s_uframe + 1) * DWC2_SLICES_PER_UFRAME;\r\n}\r\nif (ls_search_slice >= DWC2_LS_SCHEDULE_SLICES)\r\nreturn -ENOSPC;\r\nreturn 0;\r\n}\r\nstatic int dwc2_uframe_schedule_hs(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nWARN_ON(qh->host_us != qh->device_us);\r\nWARN_ON(qh->host_interval != qh->device_interval);\r\nWARN_ON(qh->num_hs_transfers != 1);\r\nqh->hs_transfers[0].start_schedule_us = 0;\r\nqh->hs_transfers[0].duration_us = qh->host_us;\r\nreturn dwc2_hs_pmap_schedule(hsotg, qh, false, 0);\r\n}\r\nstatic int dwc2_uframe_schedule_ls(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nWARN_ON(qh->host_us != qh->device_us);\r\nWARN_ON(qh->host_interval != qh->device_interval);\r\nWARN_ON(!qh->schedule_low_speed);\r\nreturn dwc2_ls_pmap_schedule(hsotg, qh, 0);\r\n}\r\nstatic int dwc2_uframe_schedule(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nint ret;\r\nif (qh->dev_speed == USB_SPEED_HIGH)\r\nret = dwc2_uframe_schedule_hs(hsotg, qh);\r\nelse if (!qh->do_split)\r\nret = dwc2_uframe_schedule_ls(hsotg, qh);\r\nelse\r\nret = dwc2_uframe_schedule_split(hsotg, qh);\r\nif (ret)\r\ndwc2_sch_dbg(hsotg, "QH=%p Failed to schedule %d\n", qh, ret);\r\nelse\r\ndwc2_qh_schedule_print(hsotg, qh);\r\nreturn ret;\r\n}\r\nstatic void dwc2_uframe_unschedule(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nint i;\r\nfor (i = 0; i < qh->num_hs_transfers; i++)\r\ndwc2_hs_pmap_unschedule(hsotg, qh, i);\r\nif (qh->schedule_low_speed)\r\ndwc2_ls_pmap_unschedule(hsotg, qh);\r\ndwc2_sch_dbg(hsotg, "QH=%p Unscheduled\n", qh);\r\n}\r\nstatic void dwc2_pick_first_frame(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nu16 frame_number;\r\nu16 earliest_frame;\r\nu16 next_active_frame;\r\nu16 relative_frame;\r\nu16 interval;\r\nframe_number = dwc2_hcd_get_frame_number(hsotg);\r\nearliest_frame = dwc2_frame_num_inc(frame_number, 1);\r\nnext_active_frame = earliest_frame;\r\nif (hsotg->core_params->uframe_sched <= 0) {\r\nif (qh->do_split)\r\nnext_active_frame |= 0x7;\r\ngoto exit;\r\n}\r\nif (qh->dev_speed == USB_SPEED_HIGH || qh->do_split) {\r\nWARN_ON(qh->num_hs_transfers < 1);\r\nrelative_frame = qh->hs_transfers[0].start_schedule_us /\r\nDWC2_HS_PERIODIC_US_PER_UFRAME;\r\ninterval = gcd(qh->host_interval, DWC2_HS_SCHEDULE_UFRAMES);\r\n} else {\r\nrelative_frame = qh->ls_start_schedule_slice /\r\nDWC2_LS_PERIODIC_SLICES_PER_FRAME;\r\ninterval = gcd(qh->host_interval, DWC2_LS_SCHEDULE_FRAMES);\r\n}\r\nWARN_ON(relative_frame >= interval);\r\nnext_active_frame = (next_active_frame / interval) * interval;\r\nnext_active_frame = dwc2_frame_num_inc(next_active_frame,\r\nrelative_frame);\r\nnext_active_frame = dwc2_frame_num_dec(next_active_frame, 1);\r\nwhile (dwc2_frame_num_gt(earliest_frame, next_active_frame))\r\nnext_active_frame = dwc2_frame_num_inc(next_active_frame,\r\ninterval);\r\nexit:\r\nqh->next_active_frame = next_active_frame;\r\nqh->start_active_frame = next_active_frame;\r\ndwc2_sch_vdbg(hsotg, "QH=%p First fn=%04x nxt=%04x\n",\r\nqh, frame_number, qh->next_active_frame);\r\n}\r\nstatic int dwc2_do_reserve(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nint status;\r\nif (hsotg->core_params->uframe_sched > 0) {\r\nstatus = dwc2_uframe_schedule(hsotg, qh);\r\n} else {\r\nstatus = dwc2_periodic_channel_available(hsotg);\r\nif (status) {\r\ndev_info(hsotg->dev,\r\n"%s: No host channel available for periodic transfer\n",\r\n__func__);\r\nreturn status;\r\n}\r\nstatus = dwc2_check_periodic_bandwidth(hsotg, qh);\r\n}\r\nif (status) {\r\ndev_dbg(hsotg->dev,\r\n"%s: Insufficient periodic bandwidth for periodic transfer\n",\r\n__func__);\r\nreturn status;\r\n}\r\nif (hsotg->core_params->uframe_sched <= 0)\r\nhsotg->periodic_channels++;\r\nhsotg->periodic_usecs += qh->host_us;\r\ndwc2_pick_first_frame(hsotg, qh);\r\nreturn 0;\r\n}\r\nstatic void dwc2_do_unreserve(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nassert_spin_locked(&hsotg->lock);\r\nWARN_ON(!qh->unreserve_pending);\r\nqh->unreserve_pending = false;\r\nif (WARN_ON(!list_empty(&qh->qh_list_entry)))\r\nlist_del_init(&qh->qh_list_entry);\r\nhsotg->periodic_usecs -= qh->host_us;\r\nif (hsotg->core_params->uframe_sched > 0) {\r\ndwc2_uframe_unschedule(hsotg, qh);\r\n} else {\r\nhsotg->periodic_channels--;\r\n}\r\n}\r\nstatic void dwc2_unreserve_timer_fn(unsigned long data)\r\n{\r\nstruct dwc2_qh *qh = (struct dwc2_qh *)data;\r\nstruct dwc2_hsotg *hsotg = qh->hsotg;\r\nunsigned long flags;\r\nwhile (!spin_trylock_irqsave(&hsotg->lock, flags)) {\r\nif (timer_pending(&qh->unreserve_timer))\r\nreturn;\r\n}\r\nif (qh->unreserve_pending)\r\ndwc2_do_unreserve(hsotg, qh);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\n}\r\nstatic int dwc2_check_max_xfer_size(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nu32 max_xfer_size;\r\nu32 max_channel_xfer_size;\r\nint status = 0;\r\nmax_xfer_size = dwc2_max_packet(qh->maxp) * dwc2_hb_mult(qh->maxp);\r\nmax_channel_xfer_size = hsotg->core_params->max_transfer_size;\r\nif (max_xfer_size > max_channel_xfer_size) {\r\ndev_err(hsotg->dev,\r\n"%s: Periodic xfer length %d > max xfer length for channel %d\n",\r\n__func__, max_xfer_size, max_channel_xfer_size);\r\nstatus = -ENOSPC;\r\n}\r\nreturn status;\r\n}\r\nstatic int dwc2_schedule_periodic(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nint status;\r\nstatus = dwc2_check_max_xfer_size(hsotg, qh);\r\nif (status) {\r\ndev_dbg(hsotg->dev,\r\n"%s: Channel max transfer size too small for periodic transfer\n",\r\n__func__);\r\nreturn status;\r\n}\r\nif (del_timer(&qh->unreserve_timer))\r\nWARN_ON(!qh->unreserve_pending);\r\nif (!qh->unreserve_pending) {\r\nstatus = dwc2_do_reserve(hsotg, qh);\r\nif (status)\r\nreturn status;\r\n} else {\r\nif (dwc2_frame_num_le(qh->next_active_frame,\r\nhsotg->frame_number))\r\ndwc2_pick_first_frame(hsotg, qh);\r\n}\r\nqh->unreserve_pending = 0;\r\nif (hsotg->core_params->dma_desc_enable > 0)\r\nlist_add_tail(&qh->qh_list_entry, &hsotg->periodic_sched_ready);\r\nelse\r\nlist_add_tail(&qh->qh_list_entry,\r\n&hsotg->periodic_sched_inactive);\r\nreturn 0;\r\n}\r\nstatic void dwc2_deschedule_periodic(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh)\r\n{\r\nbool did_modify;\r\nassert_spin_locked(&hsotg->lock);\r\ndid_modify = mod_timer(&qh->unreserve_timer,\r\njiffies + DWC2_UNRESERVE_DELAY + 1);\r\nWARN_ON(did_modify);\r\nqh->unreserve_pending = 1;\r\nlist_del_init(&qh->qh_list_entry);\r\n}\r\nstatic void dwc2_qh_init(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\r\nstruct dwc2_hcd_urb *urb, gfp_t mem_flags)\r\n{\r\nint dev_speed = dwc2_host_get_speed(hsotg, urb->priv);\r\nu8 ep_type = dwc2_hcd_get_pipe_type(&urb->pipe_info);\r\nbool ep_is_in = !!dwc2_hcd_is_pipe_in(&urb->pipe_info);\r\nbool ep_is_isoc = (ep_type == USB_ENDPOINT_XFER_ISOC);\r\nbool ep_is_int = (ep_type == USB_ENDPOINT_XFER_INT);\r\nu32 hprt = dwc2_readl(hsotg->regs + HPRT0);\r\nu32 prtspd = (hprt & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;\r\nbool do_split = (prtspd == HPRT0_SPD_HIGH_SPEED &&\r\ndev_speed != USB_SPEED_HIGH);\r\nint maxp = dwc2_hcd_get_mps(&urb->pipe_info);\r\nint bytecount = dwc2_hb_mult(maxp) * dwc2_max_packet(maxp);\r\nchar *speed, *type;\r\nqh->hsotg = hsotg;\r\nsetup_timer(&qh->unreserve_timer, dwc2_unreserve_timer_fn,\r\n(unsigned long)qh);\r\nqh->ep_type = ep_type;\r\nqh->ep_is_in = ep_is_in;\r\nqh->data_toggle = DWC2_HC_PID_DATA0;\r\nqh->maxp = maxp;\r\nINIT_LIST_HEAD(&qh->qtd_list);\r\nINIT_LIST_HEAD(&qh->qh_list_entry);\r\nqh->do_split = do_split;\r\nqh->dev_speed = dev_speed;\r\nif (ep_is_int || ep_is_isoc) {\r\nint host_speed = do_split ? USB_SPEED_HIGH : dev_speed;\r\nstruct dwc2_tt *dwc_tt = dwc2_host_get_tt_info(hsotg, urb->priv,\r\nmem_flags,\r\n&qh->ttport);\r\nint device_ns;\r\nqh->dwc_tt = dwc_tt;\r\nqh->host_us = NS_TO_US(usb_calc_bus_time(host_speed, ep_is_in,\r\nep_is_isoc, bytecount));\r\ndevice_ns = usb_calc_bus_time(dev_speed, ep_is_in,\r\nep_is_isoc, bytecount);\r\nif (do_split && dwc_tt)\r\ndevice_ns += dwc_tt->usb_tt->think_time;\r\nqh->device_us = NS_TO_US(device_ns);\r\nqh->device_interval = urb->interval;\r\nqh->host_interval = urb->interval * (do_split ? 8 : 1);\r\nqh->schedule_low_speed = prtspd != HPRT0_SPD_HIGH_SPEED ||\r\ndwc_tt;\r\nif (do_split) {\r\nqh->num_hs_transfers = -1;\r\n} else if (dev_speed == USB_SPEED_HIGH) {\r\nqh->num_hs_transfers = 1;\r\n} else {\r\nqh->num_hs_transfers = 0;\r\n}\r\n}\r\nswitch (dev_speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = "low";\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nspeed = "full";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nspeed = "high";\r\nbreak;\r\ndefault:\r\nspeed = "?";\r\nbreak;\r\n}\r\nswitch (qh->ep_type) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ntype = "isochronous";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\ntype = "interrupt";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ntype = "control";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ntype = "bulk";\r\nbreak;\r\ndefault:\r\ntype = "?";\r\nbreak;\r\n}\r\ndwc2_sch_dbg(hsotg, "QH=%p Init %s, %s speed, %d bytes:\n", qh, type,\r\nspeed, bytecount);\r\ndwc2_sch_dbg(hsotg, "QH=%p ...addr=%d, ep=%d, %s\n", qh,\r\ndwc2_hcd_get_dev_addr(&urb->pipe_info),\r\ndwc2_hcd_get_ep_num(&urb->pipe_info),\r\nep_is_in ? "IN" : "OUT");\r\nif (ep_is_int || ep_is_isoc) {\r\ndwc2_sch_dbg(hsotg,\r\n"QH=%p ...duration: host=%d us, device=%d us\n",\r\nqh, qh->host_us, qh->device_us);\r\ndwc2_sch_dbg(hsotg, "QH=%p ...interval: host=%d, device=%d\n",\r\nqh, qh->host_interval, qh->device_interval);\r\nif (qh->schedule_low_speed)\r\ndwc2_sch_dbg(hsotg, "QH=%p ...low speed schedule=%p\n",\r\nqh, dwc2_get_ls_map(hsotg, qh));\r\n}\r\n}\r\nstruct dwc2_qh *dwc2_hcd_qh_create(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hcd_urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct dwc2_qh *qh;\r\nif (!urb->priv)\r\nreturn NULL;\r\nqh = kzalloc(sizeof(*qh), mem_flags);\r\nif (!qh)\r\nreturn NULL;\r\ndwc2_qh_init(hsotg, qh, urb, mem_flags);\r\nif (hsotg->core_params->dma_desc_enable > 0 &&\r\ndwc2_hcd_qh_init_ddma(hsotg, qh, mem_flags) < 0) {\r\ndwc2_hcd_qh_free(hsotg, qh);\r\nreturn NULL;\r\n}\r\nreturn qh;\r\n}\r\nvoid dwc2_hcd_qh_free(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nif (del_timer_sync(&qh->unreserve_timer)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\ndwc2_do_unreserve(hsotg, qh);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\n}\r\ndwc2_host_put_tt_info(hsotg, qh->dwc_tt);\r\nif (qh->desc_list)\r\ndwc2_hcd_qh_free_ddma(hsotg, qh);\r\nkfree(qh);\r\n}\r\nint dwc2_hcd_qh_add(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nint status;\r\nu32 intr_mask;\r\nif (dbg_qh(qh))\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nif (!list_empty(&qh->qh_list_entry))\r\nreturn 0;\r\nif (dwc2_qh_is_non_per(qh)) {\r\nqh->start_active_frame = hsotg->frame_number;\r\nqh->next_active_frame = qh->start_active_frame;\r\nlist_add_tail(&qh->qh_list_entry,\r\n&hsotg->non_periodic_sched_inactive);\r\nreturn 0;\r\n}\r\nstatus = dwc2_schedule_periodic(hsotg, qh);\r\nif (status)\r\nreturn status;\r\nif (!hsotg->periodic_qh_count) {\r\nintr_mask = dwc2_readl(hsotg->regs + GINTMSK);\r\nintr_mask |= GINTSTS_SOF;\r\ndwc2_writel(intr_mask, hsotg->regs + GINTMSK);\r\n}\r\nhsotg->periodic_qh_count++;\r\nreturn 0;\r\n}\r\nvoid dwc2_hcd_qh_unlink(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\r\n{\r\nu32 intr_mask;\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nif (list_empty(&qh->qh_list_entry))\r\nreturn;\r\nif (dwc2_qh_is_non_per(qh)) {\r\nif (hsotg->non_periodic_qh_ptr == &qh->qh_list_entry)\r\nhsotg->non_periodic_qh_ptr =\r\nhsotg->non_periodic_qh_ptr->next;\r\nlist_del_init(&qh->qh_list_entry);\r\nreturn;\r\n}\r\ndwc2_deschedule_periodic(hsotg, qh);\r\nhsotg->periodic_qh_count--;\r\nif (!hsotg->periodic_qh_count &&\r\nhsotg->core_params->dma_desc_enable <= 0) {\r\nintr_mask = dwc2_readl(hsotg->regs + GINTMSK);\r\nintr_mask &= ~GINTSTS_SOF;\r\ndwc2_writel(intr_mask, hsotg->regs + GINTMSK);\r\n}\r\n}\r\nstatic int dwc2_next_for_periodic_split(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh, u16 frame_number)\r\n{\r\nu16 old_frame = qh->next_active_frame;\r\nu16 prev_frame_number = dwc2_frame_num_dec(frame_number, 1);\r\nint missed = 0;\r\nu16 incr;\r\nif (old_frame == qh->start_active_frame &&\r\n!(qh->ep_type == USB_ENDPOINT_XFER_ISOC && !qh->ep_is_in))\r\nincr = 2;\r\nelse\r\nincr = 1;\r\nqh->next_active_frame = dwc2_frame_num_inc(old_frame, incr);\r\nif (dwc2_frame_num_gt(prev_frame_number, qh->next_active_frame)) {\r\nmissed = dwc2_frame_num_dec(prev_frame_number,\r\nqh->next_active_frame);\r\nqh->next_active_frame = frame_number;\r\n}\r\nreturn missed;\r\n}\r\nstatic int dwc2_next_periodic_start(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_qh *qh, u16 frame_number)\r\n{\r\nint missed = 0;\r\nu16 interval = qh->host_interval;\r\nu16 prev_frame_number = dwc2_frame_num_dec(frame_number, 1);\r\nqh->start_active_frame = dwc2_frame_num_inc(qh->start_active_frame,\r\ninterval);\r\nif (interval >= 0x1000)\r\ngoto exit;\r\nif (qh->start_active_frame == qh->next_active_frame ||\r\ndwc2_frame_num_gt(prev_frame_number, qh->start_active_frame)) {\r\nu16 ideal_start = qh->start_active_frame;\r\nint periods_in_map;\r\nif (qh->do_split || qh->dev_speed == USB_SPEED_HIGH)\r\nperiods_in_map = DWC2_HS_SCHEDULE_UFRAMES;\r\nelse\r\nperiods_in_map = DWC2_LS_SCHEDULE_FRAMES;\r\ninterval = gcd(interval, periods_in_map);\r\ndo {\r\nqh->start_active_frame = dwc2_frame_num_inc(\r\nqh->start_active_frame, interval);\r\n} while (dwc2_frame_num_gt(prev_frame_number,\r\nqh->start_active_frame));\r\nmissed = dwc2_frame_num_dec(qh->start_active_frame,\r\nideal_start);\r\n}\r\nexit:\r\nqh->next_active_frame = qh->start_active_frame;\r\nreturn missed;\r\n}\r\nvoid dwc2_hcd_qh_deactivate(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\r\nint sched_next_periodic_split)\r\n{\r\nu16 old_frame = qh->next_active_frame;\r\nu16 frame_number;\r\nint missed;\r\nif (dbg_qh(qh))\r\ndev_vdbg(hsotg->dev, "%s()\n", __func__);\r\nif (dwc2_qh_is_non_per(qh)) {\r\ndwc2_hcd_qh_unlink(hsotg, qh);\r\nif (!list_empty(&qh->qtd_list))\r\ndwc2_hcd_qh_add(hsotg, qh);\r\nreturn;\r\n}\r\nframe_number = dwc2_hcd_get_frame_number(hsotg);\r\nif (sched_next_periodic_split)\r\nmissed = dwc2_next_for_periodic_split(hsotg, qh, frame_number);\r\nelse\r\nmissed = dwc2_next_periodic_start(hsotg, qh, frame_number);\r\ndwc2_sch_vdbg(hsotg,\r\n"QH=%p next(%d) fn=%04x, sch=%04x=>%04x (%+d) miss=%d %s\n",\r\nqh, sched_next_periodic_split, frame_number, old_frame,\r\nqh->next_active_frame,\r\ndwc2_frame_num_dec(qh->next_active_frame, old_frame),\r\nmissed, missed ? "MISS" : "");\r\nif (list_empty(&qh->qtd_list)) {\r\ndwc2_hcd_qh_unlink(hsotg, qh);\r\nreturn;\r\n}\r\nif (dwc2_frame_num_le(qh->next_active_frame, hsotg->frame_number))\r\nlist_move_tail(&qh->qh_list_entry,\r\n&hsotg->periodic_sched_ready);\r\nelse\r\nlist_move_tail(&qh->qh_list_entry,\r\n&hsotg->periodic_sched_inactive);\r\n}\r\nvoid dwc2_hcd_qtd_init(struct dwc2_qtd *qtd, struct dwc2_hcd_urb *urb)\r\n{\r\nqtd->urb = urb;\r\nif (dwc2_hcd_get_pipe_type(&urb->pipe_info) ==\r\nUSB_ENDPOINT_XFER_CONTROL) {\r\nqtd->data_toggle = DWC2_HC_PID_DATA1;\r\nqtd->control_phase = DWC2_CONTROL_SETUP;\r\n}\r\nqtd->complete_split = 0;\r\nqtd->isoc_split_pos = DWC2_HCSPLT_XACTPOS_ALL;\r\nqtd->isoc_split_offset = 0;\r\nqtd->in_process = 0;\r\nurb->qtd = qtd;\r\n}\r\nint dwc2_hcd_qtd_add(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,\r\nstruct dwc2_qh *qh)\r\n{\r\nint retval;\r\nif (unlikely(!qh)) {\r\ndev_err(hsotg->dev, "%s: Invalid QH\n", __func__);\r\nretval = -EINVAL;\r\ngoto fail;\r\n}\r\nretval = dwc2_hcd_qh_add(hsotg, qh);\r\nif (retval)\r\ngoto fail;\r\nqtd->qh = qh;\r\nlist_add_tail(&qtd->qtd_list_entry, &qh->qtd_list);\r\nreturn 0;\r\nfail:\r\nreturn retval;\r\n}
