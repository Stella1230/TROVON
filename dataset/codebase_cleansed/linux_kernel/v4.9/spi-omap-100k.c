static void spi100k_enable_clock(struct spi_master *master)\r\n{\r\nunsigned int val;\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nval = readw(spi100k->base + SPI_SETUP1);\r\nval |= SPI_SETUP1_CLOCK_ENABLE;\r\nwritew(val, spi100k->base + SPI_SETUP1);\r\n}\r\nstatic void spi100k_disable_clock(struct spi_master *master)\r\n{\r\nunsigned int val;\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nval = readw(spi100k->base + SPI_SETUP1);\r\nval &= ~SPI_SETUP1_CLOCK_ENABLE;\r\nwritew(val, spi100k->base + SPI_SETUP1);\r\n}\r\nstatic void spi100k_write_data(struct spi_master *master, int len, int data)\r\n{\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nif (len <= 8) {\r\ndata <<= 8;\r\nlen = 16;\r\n}\r\nspi100k_enable_clock(master);\r\nwritew(data , spi100k->base + SPI_TX_MSB);\r\nwritew(SPI_CTRL_SEN(0) |\r\nSPI_CTRL_WORD_SIZE(len) |\r\nSPI_CTRL_WR,\r\nspi100k->base + SPI_CTRL);\r\nwhile ((readw(spi100k->base + SPI_STATUS) & SPI_STATUS_WE) != SPI_STATUS_WE)\r\n;\r\nudelay(1000);\r\nspi100k_disable_clock(master);\r\n}\r\nstatic int spi100k_read_data(struct spi_master *master, int len)\r\n{\r\nint dataH, dataL;\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nif (len <= 8)\r\nlen = 16;\r\nspi100k_enable_clock(master);\r\nwritew(SPI_CTRL_SEN(0) |\r\nSPI_CTRL_WORD_SIZE(len) |\r\nSPI_CTRL_RD,\r\nspi100k->base + SPI_CTRL);\r\nwhile ((readw(spi100k->base + SPI_STATUS) & SPI_STATUS_RD) != SPI_STATUS_RD)\r\n;\r\nudelay(1000);\r\ndataL = readw(spi100k->base + SPI_RX_LSB);\r\ndataH = readw(spi100k->base + SPI_RX_MSB);\r\nspi100k_disable_clock(master);\r\nreturn dataL;\r\n}\r\nstatic void spi100k_open(struct spi_master *master)\r\n{\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nwritew(SPI_SETUP1_INT_READ_ENABLE |\r\nSPI_SETUP1_INT_WRITE_ENABLE |\r\nSPI_SETUP1_CLOCK_DIVISOR(0), spi100k->base + SPI_SETUP1);\r\nwritew(SPI_SETUP2_ACTIVE_EDGE_FALLING |\r\nSPI_SETUP2_NEGATIVE_LEVEL |\r\nSPI_SETUP2_LEVEL_TRIGGER, spi100k->base + SPI_SETUP2);\r\n}\r\nstatic void omap1_spi100k_force_cs(struct omap1_spi100k *spi100k, int enable)\r\n{\r\nif (enable)\r\nwritew(0x05fc, spi100k->base + SPI_CTRL);\r\nelse\r\nwritew(0x05fd, spi100k->base + SPI_CTRL);\r\n}\r\nstatic unsigned\r\nomap1_spi100k_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nstruct omap1_spi100k_cs *cs = spi->controller_state;\r\nunsigned int count, c;\r\nint word_len;\r\ncount = xfer->len;\r\nc = count;\r\nword_len = cs->word_len;\r\nif (word_len <= 8) {\r\nu8 *rx;\r\nconst u8 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc -= 1;\r\nif (xfer->tx_buf != NULL)\r\nspi100k_write_data(spi->master, word_len, *tx++);\r\nif (xfer->rx_buf != NULL)\r\n*rx++ = spi100k_read_data(spi->master, word_len);\r\n} while (c);\r\n} else if (word_len <= 16) {\r\nu16 *rx;\r\nconst u16 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc -= 2;\r\nif (xfer->tx_buf != NULL)\r\nspi100k_write_data(spi->master, word_len, *tx++);\r\nif (xfer->rx_buf != NULL)\r\n*rx++ = spi100k_read_data(spi->master, word_len);\r\n} while (c);\r\n} else if (word_len <= 32) {\r\nu32 *rx;\r\nconst u32 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc -= 4;\r\nif (xfer->tx_buf != NULL)\r\nspi100k_write_data(spi->master, word_len, *tx);\r\nif (xfer->rx_buf != NULL)\r\n*rx = spi100k_read_data(spi->master, word_len);\r\n} while (c);\r\n}\r\nreturn count - c;\r\n}\r\nstatic int omap1_spi100k_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(spi->master);\r\nstruct omap1_spi100k_cs *cs = spi->controller_state;\r\nu8 word_len;\r\nif (t != NULL)\r\nword_len = t->bits_per_word;\r\nelse\r\nword_len = spi->bits_per_word;\r\nif (spi->bits_per_word > 32)\r\nreturn -EINVAL;\r\ncs->word_len = word_len;\r\nwritew(0x3e , spi100k->base + SPI_SETUP1);\r\nwritew(0x00 , spi100k->base + SPI_STATUS);\r\nwritew(0x3e , spi100k->base + SPI_CTRL);\r\nreturn 0;\r\n}\r\nstatic int omap1_spi100k_setup(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct omap1_spi100k *spi100k;\r\nstruct omap1_spi100k_cs *cs = spi->controller_state;\r\nspi100k = spi_master_get_devdata(spi->master);\r\nif (!cs) {\r\ncs = devm_kzalloc(&spi->dev, sizeof(*cs), GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\ncs->base = spi100k->base + spi->chip_select * 0x14;\r\nspi->controller_state = cs;\r\n}\r\nspi100k_open(spi->master);\r\nclk_prepare_enable(spi100k->ick);\r\nclk_prepare_enable(spi100k->fck);\r\nret = omap1_spi100k_setup_transfer(spi, NULL);\r\nclk_disable_unprepare(spi100k->ick);\r\nclk_disable_unprepare(spi100k->fck);\r\nreturn ret;\r\n}\r\nstatic int omap1_spi100k_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nstruct spi_device *spi = m->spi;\r\nstruct spi_transfer *t = NULL;\r\nint cs_active = 0;\r\nint status = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->tx_buf == NULL && t->rx_buf == NULL && t->len) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nstatus = omap1_spi100k_setup_transfer(spi, t);\r\nif (status < 0)\r\nbreak;\r\nif (!cs_active) {\r\nomap1_spi100k_force_cs(spi100k, 1);\r\ncs_active = 1;\r\n}\r\nif (t->len) {\r\nunsigned count;\r\ncount = omap1_spi100k_txrx_pio(spi, t);\r\nm->actual_length += count;\r\nif (count != t->len) {\r\nstatus = -EIO;\r\nbreak;\r\n}\r\n}\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (t->cs_change) {\r\nomap1_spi100k_force_cs(spi100k, 0);\r\ncs_active = 0;\r\n}\r\n}\r\nstatus = omap1_spi100k_setup_transfer(spi, NULL);\r\nif (cs_active)\r\nomap1_spi100k_force_cs(spi100k, 0);\r\nm->status = status;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int omap1_spi100k_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct omap1_spi100k *spi100k;\r\nint status = 0;\r\nif (!pdev->id)\r\nreturn -EINVAL;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*spi100k));\r\nif (master == NULL) {\r\ndev_dbg(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (pdev->id != -1)\r\nmaster->bus_num = pdev->id;\r\nmaster->setup = omap1_spi100k_setup;\r\nmaster->transfer_one_message = omap1_spi100k_transfer_one_message;\r\nmaster->num_chipselect = 2;\r\nmaster->mode_bits = MODEBITS;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\r\nmaster->min_speed_hz = OMAP1_SPI100K_MAX_FREQ/(1<<16);\r\nmaster->max_speed_hz = OMAP1_SPI100K_MAX_FREQ;\r\nmaster->auto_runtime_pm = true;\r\nspi100k = spi_master_get_devdata(master);\r\nspi100k->base = (void __iomem *)dev_get_platdata(&pdev->dev);\r\nspi100k->ick = devm_clk_get(&pdev->dev, "ick");\r\nif (IS_ERR(spi100k->ick)) {\r\ndev_dbg(&pdev->dev, "can't get spi100k_ick\n");\r\nstatus = PTR_ERR(spi100k->ick);\r\ngoto err;\r\n}\r\nspi100k->fck = devm_clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(spi100k->fck)) {\r\ndev_dbg(&pdev->dev, "can't get spi100k_fck\n");\r\nstatus = PTR_ERR(spi100k->fck);\r\ngoto err;\r\n}\r\nstatus = clk_prepare_enable(spi100k->ick);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "failed to enable ick: %d\n", status);\r\ngoto err;\r\n}\r\nstatus = clk_prepare_enable(spi100k->fck);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "failed to enable fck: %d\n", status);\r\ngoto err_ick;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\nstatus = devm_spi_register_master(&pdev->dev, master);\r\nif (status < 0)\r\ngoto err_fck;\r\nreturn status;\r\nerr_fck:\r\nclk_disable_unprepare(spi100k->fck);\r\nerr_ick:\r\nclk_disable_unprepare(spi100k->ick);\r\nerr:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int omap1_spi100k_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = spi_master_get(platform_get_drvdata(pdev));\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(spi100k->fck);\r\nclk_disable_unprepare(spi100k->ick);\r\nreturn 0;\r\n}\r\nstatic int omap1_spi100k_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = spi_master_get(dev_get_drvdata(dev));\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nclk_disable_unprepare(spi100k->ick);\r\nclk_disable_unprepare(spi100k->fck);\r\nreturn 0;\r\n}\r\nstatic int omap1_spi100k_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = spi_master_get(dev_get_drvdata(dev));\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(spi100k->ick);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable ick: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(spi100k->fck);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable fck: %d\n", ret);\r\nclk_disable_unprepare(spi100k->ick);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
