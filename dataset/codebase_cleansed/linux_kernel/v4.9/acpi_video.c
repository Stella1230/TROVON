static int acpi_video_get_brightness(struct backlight_device *bd)\r\n{\r\nunsigned long long cur_level;\r\nint i;\r\nstruct acpi_video_device *vd = bl_get_data(bd);\r\nif (acpi_video_device_lcd_get_level_current(vd, &cur_level, false))\r\nreturn -EINVAL;\r\nfor (i = 2; i < vd->brightness->count; i++) {\r\nif (vd->brightness->levels[i] == cur_level)\r\nreturn i - 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_video_set_brightness(struct backlight_device *bd)\r\n{\r\nint request_level = bd->props.brightness + 2;\r\nstruct acpi_video_device *vd = bl_get_data(bd);\r\ncancel_delayed_work(&vd->switch_brightness_work);\r\nreturn acpi_video_device_lcd_set_level(vd,\r\nvd->brightness->levels[request_level]);\r\n}\r\nstatic int video_get_max_state(struct thermal_cooling_device *cooling_dev, unsigned\r\nlong *state)\r\n{\r\nstruct acpi_device *device = cooling_dev->devdata;\r\nstruct acpi_video_device *video = acpi_driver_data(device);\r\n*state = video->brightness->count - 3;\r\nreturn 0;\r\n}\r\nstatic int video_get_cur_state(struct thermal_cooling_device *cooling_dev, unsigned\r\nlong *state)\r\n{\r\nstruct acpi_device *device = cooling_dev->devdata;\r\nstruct acpi_video_device *video = acpi_driver_data(device);\r\nunsigned long long level;\r\nint offset;\r\nif (acpi_video_device_lcd_get_level_current(video, &level, false))\r\nreturn -EINVAL;\r\nfor (offset = 2; offset < video->brightness->count; offset++)\r\nif (level == video->brightness->levels[offset]) {\r\n*state = video->brightness->count - offset - 1;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nvideo_set_cur_state(struct thermal_cooling_device *cooling_dev, unsigned long state)\r\n{\r\nstruct acpi_device *device = cooling_dev->devdata;\r\nstruct acpi_video_device *video = acpi_driver_data(device);\r\nint level;\r\nif (state >= video->brightness->count - 2)\r\nreturn -EINVAL;\r\nstate = video->brightness->count - state;\r\nlevel = video->brightness->levels[state - 1];\r\nreturn acpi_video_device_lcd_set_level(video, level);\r\n}\r\nstatic int\r\nacpi_video_device_lcd_query_levels(acpi_handle handle,\r\nunion acpi_object **levels)\r\n{\r\nint status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\n*levels = NULL;\r\nstatus = acpi_evaluate_object(handle, "_BCL", NULL, &buffer);\r\nif (!ACPI_SUCCESS(status))\r\nreturn status;\r\nobj = (union acpi_object *)buffer.pointer;\r\nif (!obj || (obj->type != ACPI_TYPE_PACKAGE)) {\r\nprintk(KERN_ERR PREFIX "Invalid _BCL data\n");\r\nstatus = -EFAULT;\r\ngoto err;\r\n}\r\n*levels = obj;\r\nreturn 0;\r\nerr:\r\nkfree(buffer.pointer);\r\nreturn status;\r\n}\r\nstatic int\r\nacpi_video_device_lcd_set_level(struct acpi_video_device *device, int level)\r\n{\r\nint status;\r\nint state;\r\nstatus = acpi_execute_simple_method(device->dev->handle,\r\n"_BCM", level);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Evaluating _BCM failed"));\r\nreturn -EIO;\r\n}\r\ndevice->brightness->curr = level;\r\nfor (state = 2; state < device->brightness->count; state++)\r\nif (level == device->brightness->levels[state]) {\r\nif (device->backlight)\r\ndevice->backlight->props.brightness = state - 2;\r\nreturn 0;\r\n}\r\nACPI_ERROR((AE_INFO, "Current brightness invalid"));\r\nreturn -EINVAL;\r\n}\r\nstatic int video_set_bqc_offset(const struct dmi_system_id *d)\r\n{\r\nbqc_offset_aml_bug_workaround = 9;\r\nreturn 0;\r\n}\r\nstatic int video_disable_backlight_sysfs_if(\r\nconst struct dmi_system_id *d)\r\n{\r\nif (disable_backlight_sysfs_if == -1)\r\ndisable_backlight_sysfs_if = 1;\r\nreturn 0;\r\n}\r\nstatic int video_set_device_id_scheme(const struct dmi_system_id *d)\r\n{\r\ndevice_id_scheme = true;\r\nreturn 0;\r\n}\r\nstatic int video_enable_only_lcd(const struct dmi_system_id *d)\r\n{\r\nonly_lcd = true;\r\nreturn 0;\r\n}\r\nstatic int video_set_report_key_events(const struct dmi_system_id *id)\r\n{\r\nif (report_key_events == -1)\r\nreport_key_events = (uintptr_t)id->driver_data;\r\nreturn 0;\r\n}\r\nstatic unsigned long long\r\nacpi_video_bqc_value_to_level(struct acpi_video_device *device,\r\nunsigned long long bqc_value)\r\n{\r\nunsigned long long level;\r\nif (device->brightness->flags._BQC_use_index) {\r\nif (device->brightness->flags._BCL_reversed)\r\nbqc_value = device->brightness->count - 3 - bqc_value;\r\nlevel = device->brightness->levels[bqc_value + 2];\r\n} else {\r\nlevel = bqc_value;\r\n}\r\nlevel += bqc_offset_aml_bug_workaround;\r\nreturn level;\r\n}\r\nstatic int\r\nacpi_video_device_lcd_get_level_current(struct acpi_video_device *device,\r\nunsigned long long *level, bool raw)\r\n{\r\nacpi_status status = AE_OK;\r\nint i;\r\nif (device->cap._BQC || device->cap._BCQ) {\r\nchar *buf = device->cap._BQC ? "_BQC" : "_BCQ";\r\nstatus = acpi_evaluate_integer(device->dev->handle, buf,\r\nNULL, level);\r\nif (ACPI_SUCCESS(status)) {\r\nif (raw) {\r\nreturn 0;\r\n}\r\n*level = acpi_video_bqc_value_to_level(device, *level);\r\nfor (i = 2; i < device->brightness->count; i++)\r\nif (device->brightness->levels[i] == *level) {\r\ndevice->brightness->curr = *level;\r\nreturn 0;\r\n}\r\nACPI_WARNING((AE_INFO,\r\n"%s returned an invalid level",\r\nbuf));\r\ndevice->cap._BQC = device->cap._BCQ = 0;\r\n} else {\r\nACPI_WARNING((AE_INFO, "Evaluating %s failed", buf));\r\ndevice->cap._BQC = device->cap._BCQ = 0;\r\n}\r\n}\r\n*level = device->brightness->curr;\r\nreturn 0;\r\n}\r\nstatic int\r\nacpi_video_device_EDID(struct acpi_video_device *device,\r\nunion acpi_object **edid, ssize_t length)\r\n{\r\nint status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\r\nstruct acpi_object_list args = { 1, &arg0 };\r\n*edid = NULL;\r\nif (!device)\r\nreturn -ENODEV;\r\nif (length == 128)\r\narg0.integer.value = 1;\r\nelse if (length == 256)\r\narg0.integer.value = 2;\r\nelse\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_object(device->dev->handle, "_DDC", &args, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nobj = buffer.pointer;\r\nif (obj && obj->type == ACPI_TYPE_BUFFER)\r\n*edid = obj;\r\nelse {\r\nprintk(KERN_ERR PREFIX "Invalid _DDC data\n");\r\nstatus = -EFAULT;\r\nkfree(obj);\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nacpi_video_bus_DOS(struct acpi_video_bus *video, int bios_flag, int lcd_flag)\r\n{\r\nacpi_status status;\r\nif (!video->cap._DOS)\r\nreturn 0;\r\nif (bios_flag < 0 || bios_flag > 3 || lcd_flag < 0 || lcd_flag > 1)\r\nreturn -EINVAL;\r\nvideo->dos_setting = (lcd_flag << 2) | bios_flag;\r\nstatus = acpi_execute_simple_method(video->device->handle, "_DOS",\r\n(lcd_flag << 2) | bios_flag);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nacpi_video_cmp_level(const void *a, const void *b)\r\n{\r\nreturn *(int *)a - *(int *)b;\r\n}\r\nstatic int acpi_video_bqc_quirk(struct acpi_video_device *device,\r\nint max_level, int current_level)\r\n{\r\nstruct acpi_video_device_brightness *br = device->brightness;\r\nint result;\r\nunsigned long long level;\r\nint test_level;\r\nif (bqc_offset_aml_bug_workaround)\r\nreturn 0;\r\ntest_level = current_level == max_level ? br->levels[3] : max_level;\r\nresult = acpi_video_device_lcd_set_level(device, test_level);\r\nif (result)\r\nreturn result;\r\nresult = acpi_video_device_lcd_get_level_current(device, &level, true);\r\nif (result)\r\nreturn result;\r\nif (level != test_level) {\r\nif (level < br->count) {\r\nif (br->flags._BCL_reversed)\r\nlevel = br->count - 3 - level;\r\nif (br->levels[level + 2] == test_level)\r\nbr->flags._BQC_use_index = 1;\r\n}\r\nif (!br->flags._BQC_use_index)\r\ndevice->cap._BQC = device->cap._BCQ = 0;\r\n}\r\nreturn 0;\r\n}\r\nint acpi_video_get_levels(struct acpi_device *device,\r\nstruct acpi_video_device_brightness **dev_br,\r\nint *pmax_level)\r\n{\r\nunion acpi_object *obj = NULL;\r\nint i, max_level = 0, count = 0, level_ac_battery = 0;\r\nunion acpi_object *o;\r\nstruct acpi_video_device_brightness *br = NULL;\r\nint result = 0;\r\nu32 value;\r\nif (!ACPI_SUCCESS(acpi_video_device_lcd_query_levels(device->handle,\r\n&obj))) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Could not query available "\r\n"LCD brightness level\n"));\r\nresult = -ENODEV;\r\ngoto out;\r\n}\r\nif (obj->package.count < 2) {\r\nresult = -EINVAL;\r\ngoto out;\r\n}\r\nbr = kzalloc(sizeof(*br), GFP_KERNEL);\r\nif (!br) {\r\nprintk(KERN_ERR "can't allocate memory\n");\r\nresult = -ENOMEM;\r\ngoto out;\r\n}\r\nbr->levels = kmalloc((obj->package.count + 2) * sizeof *(br->levels),\r\nGFP_KERNEL);\r\nif (!br->levels) {\r\nresult = -ENOMEM;\r\ngoto out_free;\r\n}\r\nfor (i = 0; i < obj->package.count; i++) {\r\no = (union acpi_object *)&obj->package.elements[i];\r\nif (o->type != ACPI_TYPE_INTEGER) {\r\nprintk(KERN_ERR PREFIX "Invalid data\n");\r\ncontinue;\r\n}\r\nvalue = (u32) o->integer.value;\r\nif (count > 2 && br->levels[count - 1] == value)\r\ncontinue;\r\nbr->levels[count] = value;\r\nif (br->levels[count] > max_level)\r\nmax_level = br->levels[count];\r\ncount++;\r\n}\r\nfor (i = 2; i < count; i++) {\r\nif (br->levels[i] == br->levels[0])\r\nlevel_ac_battery++;\r\nif (br->levels[i] == br->levels[1])\r\nlevel_ac_battery++;\r\n}\r\nif (level_ac_battery < 2) {\r\nlevel_ac_battery = 2 - level_ac_battery;\r\nbr->flags._BCL_no_ac_battery_levels = 1;\r\nfor (i = (count - 1 + level_ac_battery); i >= 2; i--)\r\nbr->levels[i] = br->levels[i - level_ac_battery];\r\ncount += level_ac_battery;\r\n} else if (level_ac_battery > 2)\r\nACPI_ERROR((AE_INFO, "Too many duplicates in _BCL package"));\r\nif (max_level == br->levels[2]) {\r\nbr->flags._BCL_reversed = 1;\r\nsort(&br->levels[2], count - 2, sizeof(br->levels[2]),\r\nacpi_video_cmp_level, NULL);\r\n} else if (max_level != br->levels[count - 1])\r\nACPI_ERROR((AE_INFO,\r\n"Found unordered _BCL package"));\r\nbr->count = count;\r\n*dev_br = br;\r\nif (pmax_level)\r\n*pmax_level = max_level;\r\nout:\r\nkfree(obj);\r\nreturn result;\r\nout_free:\r\nkfree(br);\r\ngoto out;\r\n}\r\nstatic int\r\nacpi_video_init_brightness(struct acpi_video_device *device)\r\n{\r\nint i, max_level = 0;\r\nunsigned long long level, level_old;\r\nstruct acpi_video_device_brightness *br = NULL;\r\nint result = -EINVAL;\r\nresult = acpi_video_get_levels(device->dev, &br, &max_level);\r\nif (result)\r\nreturn result;\r\ndevice->brightness = br;\r\nbr->curr = level = max_level;\r\nif (!device->cap._BQC)\r\ngoto set_level;\r\nresult = acpi_video_device_lcd_get_level_current(device,\r\n&level_old, true);\r\nif (result)\r\ngoto out_free_levels;\r\nresult = acpi_video_bqc_quirk(device, max_level, level_old);\r\nif (result)\r\ngoto out_free_levels;\r\nif (!device->cap._BQC)\r\ngoto set_level;\r\nlevel = acpi_video_bqc_value_to_level(device, level_old);\r\nfor (i = 2; i < br->count; i++)\r\nif (level == br->levels[i])\r\nbreak;\r\nif (i == br->count || !level)\r\nlevel = max_level;\r\nset_level:\r\nresult = acpi_video_device_lcd_set_level(device, level);\r\nif (result)\r\ngoto out_free_levels;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"found %d brightness levels\n", br->count - 2));\r\nreturn 0;\r\nout_free_levels:\r\nkfree(br->levels);\r\nkfree(br);\r\ndevice->brightness = NULL;\r\nreturn result;\r\n}\r\nstatic void acpi_video_device_find_cap(struct acpi_video_device *device)\r\n{\r\nif (acpi_has_method(device->dev->handle, "_ADR"))\r\ndevice->cap._ADR = 1;\r\nif (acpi_has_method(device->dev->handle, "_BCL"))\r\ndevice->cap._BCL = 1;\r\nif (acpi_has_method(device->dev->handle, "_BCM"))\r\ndevice->cap._BCM = 1;\r\nif (acpi_has_method(device->dev->handle, "_BQC")) {\r\ndevice->cap._BQC = 1;\r\n} else if (acpi_has_method(device->dev->handle, "_BCQ")) {\r\nprintk(KERN_WARNING FW_BUG "_BCQ is used instead of _BQC\n");\r\ndevice->cap._BCQ = 1;\r\n}\r\nif (acpi_has_method(device->dev->handle, "_DDC"))\r\ndevice->cap._DDC = 1;\r\n}\r\nstatic void acpi_video_bus_find_cap(struct acpi_video_bus *video)\r\n{\r\nif (acpi_has_method(video->device->handle, "_DOS"))\r\nvideo->cap._DOS = 1;\r\nif (acpi_has_method(video->device->handle, "_DOD"))\r\nvideo->cap._DOD = 1;\r\nif (acpi_has_method(video->device->handle, "_ROM"))\r\nvideo->cap._ROM = 1;\r\nif (acpi_has_method(video->device->handle, "_GPD"))\r\nvideo->cap._GPD = 1;\r\nif (acpi_has_method(video->device->handle, "_SPD"))\r\nvideo->cap._SPD = 1;\r\nif (acpi_has_method(video->device->handle, "_VPO"))\r\nvideo->cap._VPO = 1;\r\n}\r\nstatic int acpi_video_bus_check(struct acpi_video_bus *video)\r\n{\r\nacpi_status status = -ENOENT;\r\nstruct pci_dev *dev;\r\nif (!video)\r\nreturn -EINVAL;\r\ndev = acpi_get_pci_dev(video->device->handle);\r\nif (!dev)\r\nreturn -ENODEV;\r\npci_dev_put(dev);\r\nif (video->cap._DOS || video->cap._DOD) {\r\nif (!video->cap._DOS) {\r\nprintk(KERN_WARNING FW_BUG\r\n"ACPI(%s) defines _DOD but not _DOS\n",\r\nacpi_device_bid(video->device));\r\n}\r\nvideo->flags.multihead = 1;\r\nstatus = 0;\r\n}\r\nif (video->cap._ROM) {\r\nvideo->flags.rom = 1;\r\nstatus = 0;\r\n}\r\nif (video->cap._GPD && video->cap._SPD && video->cap._VPO) {\r\nvideo->flags.post = 1;\r\nstatus = 0;\r\n}\r\nreturn status;\r\n}\r\nstatic struct acpi_video_device_attrib *\r\nacpi_video_get_device_attr(struct acpi_video_bus *video, unsigned long device_id)\r\n{\r\nstruct acpi_video_enumerated_device *ids;\r\nint i;\r\nfor (i = 0; i < video->attached_count; i++) {\r\nids = &video->attached_array[i];\r\nif ((ids->value.int_val & 0xffff) == device_id)\r\nreturn &ids->value.attrib;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nacpi_video_get_device_type(struct acpi_video_bus *video,\r\nunsigned long device_id)\r\n{\r\nstruct acpi_video_enumerated_device *ids;\r\nint i;\r\nfor (i = 0; i < video->attached_count; i++) {\r\nids = &video->attached_array[i];\r\nif ((ids->value.int_val & 0xffff) == device_id)\r\nreturn ids->value.int_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nacpi_video_bus_get_one_device(struct acpi_device *device,\r\nstruct acpi_video_bus *video)\r\n{\r\nunsigned long long device_id;\r\nint status, device_type;\r\nstruct acpi_video_device *data;\r\nstruct acpi_video_device_attrib *attribute;\r\nstatus =\r\nacpi_evaluate_integer(device->handle, "_ADR", NULL, &device_id);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\ndata = kzalloc(sizeof(struct acpi_video_device), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nstrcpy(acpi_device_name(device), ACPI_VIDEO_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_VIDEO_CLASS);\r\ndevice->driver_data = data;\r\ndata->device_id = device_id;\r\ndata->video = video;\r\ndata->dev = device;\r\nINIT_DELAYED_WORK(&data->switch_brightness_work,\r\nacpi_video_switch_brightness);\r\nattribute = acpi_video_get_device_attr(video, device_id);\r\nif (attribute && (attribute->device_id_scheme || device_id_scheme)) {\r\nswitch (attribute->display_type) {\r\ncase ACPI_VIDEO_DISPLAY_CRT:\r\ndata->flags.crt = 1;\r\nbreak;\r\ncase ACPI_VIDEO_DISPLAY_TV:\r\ndata->flags.tvout = 1;\r\nbreak;\r\ncase ACPI_VIDEO_DISPLAY_DVI:\r\ndata->flags.dvi = 1;\r\nbreak;\r\ncase ACPI_VIDEO_DISPLAY_LCD:\r\ndata->flags.lcd = 1;\r\nbreak;\r\ndefault:\r\ndata->flags.unknown = 1;\r\nbreak;\r\n}\r\nif (attribute->bios_can_detect)\r\ndata->flags.bios = 1;\r\n} else {\r\ndevice_type = acpi_video_get_device_type(video, device_id);\r\nswitch (device_type & 0xffe2ffff) {\r\ncase ACPI_VIDEO_DISPLAY_LEGACY_MONITOR:\r\ndata->flags.crt = 1;\r\nbreak;\r\ncase ACPI_VIDEO_DISPLAY_LEGACY_PANEL:\r\ndata->flags.lcd = 1;\r\nbreak;\r\ncase ACPI_VIDEO_DISPLAY_LEGACY_TV:\r\ndata->flags.tvout = 1;\r\nbreak;\r\ndefault:\r\ndata->flags.unknown = 1;\r\n}\r\n}\r\nacpi_video_device_bind(video, data);\r\nacpi_video_device_find_cap(data);\r\nmutex_lock(&video->device_list_lock);\r\nlist_add_tail(&data->entry, &video->video_device_list);\r\nmutex_unlock(&video->device_list_lock);\r\nreturn status;\r\n}\r\nstatic void acpi_video_device_rebind(struct acpi_video_bus *video)\r\n{\r\nstruct acpi_video_device *dev;\r\nmutex_lock(&video->device_list_lock);\r\nlist_for_each_entry(dev, &video->video_device_list, entry)\r\nacpi_video_device_bind(video, dev);\r\nmutex_unlock(&video->device_list_lock);\r\n}\r\nstatic void\r\nacpi_video_device_bind(struct acpi_video_bus *video,\r\nstruct acpi_video_device *device)\r\n{\r\nstruct acpi_video_enumerated_device *ids;\r\nint i;\r\nfor (i = 0; i < video->attached_count; i++) {\r\nids = &video->attached_array[i];\r\nif (device->device_id == (ids->value.int_val & 0xffff)) {\r\nids->bind_info = device;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "device_bind %d\n", i));\r\n}\r\n}\r\n}\r\nstatic bool acpi_video_device_in_dod(struct acpi_video_device *device)\r\n{\r\nstruct acpi_video_bus *video = device->video;\r\nint i;\r\nif (!video->attached_count || video->child_count > 8)\r\nreturn true;\r\nfor (i = 0; i < video->attached_count; i++) {\r\nif ((video->attached_array[i].value.int_val & 0xfff) ==\r\n(device->device_id & 0xfff))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int acpi_video_device_enumerate(struct acpi_video_bus *video)\r\n{\r\nint status;\r\nint count;\r\nint i;\r\nstruct acpi_video_enumerated_device *active_list;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *dod = NULL;\r\nunion acpi_object *obj;\r\nif (!video->cap._DOD)\r\nreturn AE_NOT_EXIST;\r\nstatus = acpi_evaluate_object(video->device->handle, "_DOD", NULL, &buffer);\r\nif (!ACPI_SUCCESS(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _DOD"));\r\nreturn status;\r\n}\r\ndod = buffer.pointer;\r\nif (!dod || (dod->type != ACPI_TYPE_PACKAGE)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Invalid _DOD data"));\r\nstatus = -EFAULT;\r\ngoto out;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d video heads in _DOD\n",\r\ndod->package.count));\r\nactive_list = kcalloc(1 + dod->package.count,\r\nsizeof(struct acpi_video_enumerated_device),\r\nGFP_KERNEL);\r\nif (!active_list) {\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\ncount = 0;\r\nfor (i = 0; i < dod->package.count; i++) {\r\nobj = &dod->package.elements[i];\r\nif (obj->type != ACPI_TYPE_INTEGER) {\r\nprintk(KERN_ERR PREFIX\r\n"Invalid _DOD data in element %d\n", i);\r\ncontinue;\r\n}\r\nactive_list[count].value.int_val = obj->integer.value;\r\nactive_list[count].bind_info = NULL;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "dod element[%d] = %d\n", i,\r\n(int)obj->integer.value));\r\ncount++;\r\n}\r\nkfree(video->attached_array);\r\nvideo->attached_array = active_list;\r\nvideo->attached_count = count;\r\nout:\r\nkfree(buffer.pointer);\r\nreturn status;\r\n}\r\nstatic int\r\nacpi_video_get_next_level(struct acpi_video_device *device,\r\nu32 level_current, u32 event)\r\n{\r\nint min, max, min_above, max_below, i, l, delta = 255;\r\nmax = max_below = 0;\r\nmin = min_above = 255;\r\nfor (i = 2; i < device->brightness->count; i++) {\r\nl = device->brightness->levels[i];\r\nif (abs(l - level_current) < abs(delta)) {\r\ndelta = l - level_current;\r\nif (!delta)\r\nbreak;\r\n}\r\n}\r\nlevel_current += delta;\r\nfor (i = 2; i < device->brightness->count; i++) {\r\nl = device->brightness->levels[i];\r\nif (l < min)\r\nmin = l;\r\nif (l > max)\r\nmax = l;\r\nif (l < min_above && l > level_current)\r\nmin_above = l;\r\nif (l > max_below && l < level_current)\r\nmax_below = l;\r\n}\r\nswitch (event) {\r\ncase ACPI_VIDEO_NOTIFY_CYCLE_BRIGHTNESS:\r\nreturn (level_current < max) ? min_above : min;\r\ncase ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS:\r\nreturn (level_current < max) ? min_above : max;\r\ncase ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS:\r\nreturn (level_current > min) ? max_below : min;\r\ncase ACPI_VIDEO_NOTIFY_ZERO_BRIGHTNESS:\r\ncase ACPI_VIDEO_NOTIFY_DISPLAY_OFF:\r\nreturn 0;\r\ndefault:\r\nreturn level_current;\r\n}\r\n}\r\nstatic void\r\nacpi_video_switch_brightness(struct work_struct *work)\r\n{\r\nstruct acpi_video_device *device = container_of(to_delayed_work(work),\r\nstruct acpi_video_device, switch_brightness_work);\r\nunsigned long long level_current, level_next;\r\nint event = device->switch_brightness_event;\r\nint result = -EINVAL;\r\nif (!device->backlight)\r\nreturn;\r\nif (!device->brightness)\r\ngoto out;\r\nresult = acpi_video_device_lcd_get_level_current(device,\r\n&level_current,\r\nfalse);\r\nif (result)\r\ngoto out;\r\nlevel_next = acpi_video_get_next_level(device, level_current, event);\r\nresult = acpi_video_device_lcd_set_level(device, level_next);\r\nif (!result)\r\nbacklight_force_update(device->backlight,\r\nBACKLIGHT_UPDATE_HOTKEY);\r\nout:\r\nif (result)\r\nprintk(KERN_ERR PREFIX "Failed to switch the brightness\n");\r\n}\r\nint acpi_video_get_edid(struct acpi_device *device, int type, int device_id,\r\nvoid **edid)\r\n{\r\nstruct acpi_video_bus *video;\r\nstruct acpi_video_device *video_device;\r\nunion acpi_object *buffer = NULL;\r\nacpi_status status;\r\nint i, length;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nvideo = acpi_driver_data(device);\r\nfor (i = 0; i < video->attached_count; i++) {\r\nvideo_device = video->attached_array[i].bind_info;\r\nlength = 256;\r\nif (!video_device)\r\ncontinue;\r\nif (!video_device->cap._DDC)\r\ncontinue;\r\nif (type) {\r\nswitch (type) {\r\ncase ACPI_VIDEO_DISPLAY_CRT:\r\nif (!video_device->flags.crt)\r\ncontinue;\r\nbreak;\r\ncase ACPI_VIDEO_DISPLAY_TV:\r\nif (!video_device->flags.tvout)\r\ncontinue;\r\nbreak;\r\ncase ACPI_VIDEO_DISPLAY_DVI:\r\nif (!video_device->flags.dvi)\r\ncontinue;\r\nbreak;\r\ncase ACPI_VIDEO_DISPLAY_LCD:\r\nif (!video_device->flags.lcd)\r\ncontinue;\r\nbreak;\r\n}\r\n} else if (video_device->device_id != device_id) {\r\ncontinue;\r\n}\r\nstatus = acpi_video_device_EDID(video_device, &buffer, length);\r\nif (ACPI_FAILURE(status) || !buffer ||\r\nbuffer->type != ACPI_TYPE_BUFFER) {\r\nlength = 128;\r\nstatus = acpi_video_device_EDID(video_device, &buffer,\r\nlength);\r\nif (ACPI_FAILURE(status) || !buffer ||\r\nbuffer->type != ACPI_TYPE_BUFFER) {\r\ncontinue;\r\n}\r\n}\r\n*edid = buffer->buffer.pointer;\r\nreturn length;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nacpi_video_bus_get_devices(struct acpi_video_bus *video,\r\nstruct acpi_device *device)\r\n{\r\nint status = 0;\r\nstruct acpi_device *dev;\r\nacpi_video_device_enumerate(video);\r\nlist_for_each_entry(dev, &device->children, node) {\r\nstatus = acpi_video_bus_get_one_device(dev, video);\r\nif (status) {\r\ndev_err(&dev->dev, "Can't attach device\n");\r\nbreak;\r\n}\r\nvideo->child_count++;\r\n}\r\nreturn status;\r\n}\r\nstatic int acpi_video_bus_start_devices(struct acpi_video_bus *video)\r\n{\r\nreturn acpi_video_bus_DOS(video, 0,\r\nacpi_osi_is_win8() ? 1 : 0);\r\n}\r\nstatic int acpi_video_bus_stop_devices(struct acpi_video_bus *video)\r\n{\r\nreturn acpi_video_bus_DOS(video, 0,\r\nacpi_osi_is_win8() ? 0 : 1);\r\n}\r\nstatic void acpi_video_bus_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_video_bus *video = acpi_driver_data(device);\r\nstruct input_dev *input;\r\nint keycode = 0;\r\nif (!video || !video->input)\r\nreturn;\r\ninput = video->input;\r\nswitch (event) {\r\ncase ACPI_VIDEO_NOTIFY_SWITCH:\r\nkeycode = KEY_SWITCHVIDEOMODE;\r\nbreak;\r\ncase ACPI_VIDEO_NOTIFY_PROBE:\r\nacpi_video_device_enumerate(video);\r\nacpi_video_device_rebind(video);\r\nkeycode = KEY_SWITCHVIDEOMODE;\r\nbreak;\r\ncase ACPI_VIDEO_NOTIFY_CYCLE:\r\nkeycode = KEY_SWITCHVIDEOMODE;\r\nbreak;\r\ncase ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:\r\nkeycode = KEY_VIDEO_NEXT;\r\nbreak;\r\ncase ACPI_VIDEO_NOTIFY_PREV_OUTPUT:\r\nkeycode = KEY_VIDEO_PREV;\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\nif (acpi_notifier_call_chain(device, event, 0))\r\nkeycode = 0;\r\nif (keycode && (report_key_events & REPORT_OUTPUT_KEY_EVENTS)) {\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\n}\r\nreturn;\r\n}\r\nstatic void brightness_switch_event(struct acpi_video_device *video_device,\r\nu32 event)\r\n{\r\nif (!brightness_switch_enabled)\r\nreturn;\r\nvideo_device->switch_brightness_event = event;\r\nschedule_delayed_work(&video_device->switch_brightness_work, HZ / 10);\r\n}\r\nstatic void acpi_video_device_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct acpi_video_device *video_device = data;\r\nstruct acpi_device *device = NULL;\r\nstruct acpi_video_bus *bus;\r\nstruct input_dev *input;\r\nint keycode = 0;\r\nif (!video_device)\r\nreturn;\r\ndevice = video_device->dev;\r\nbus = video_device->video;\r\ninput = bus->input;\r\nswitch (event) {\r\ncase ACPI_VIDEO_NOTIFY_CYCLE_BRIGHTNESS:\r\nbrightness_switch_event(video_device, event);\r\nkeycode = KEY_BRIGHTNESS_CYCLE;\r\nbreak;\r\ncase ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS:\r\nbrightness_switch_event(video_device, event);\r\nkeycode = KEY_BRIGHTNESSUP;\r\nbreak;\r\ncase ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS:\r\nbrightness_switch_event(video_device, event);\r\nkeycode = KEY_BRIGHTNESSDOWN;\r\nbreak;\r\ncase ACPI_VIDEO_NOTIFY_ZERO_BRIGHTNESS:\r\nbrightness_switch_event(video_device, event);\r\nkeycode = KEY_BRIGHTNESS_ZERO;\r\nbreak;\r\ncase ACPI_VIDEO_NOTIFY_DISPLAY_OFF:\r\nbrightness_switch_event(video_device, event);\r\nkeycode = KEY_DISPLAY_OFF;\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\nacpi_notifier_call_chain(device, event, 0);\r\nif (keycode && (report_key_events & REPORT_BRIGHTNESS_KEY_EVENTS)) {\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\n}\r\nreturn;\r\n}\r\nstatic int acpi_video_resume(struct notifier_block *nb,\r\nunsigned long val, void *ign)\r\n{\r\nstruct acpi_video_bus *video;\r\nstruct acpi_video_device *video_device;\r\nint i;\r\nswitch (val) {\r\ncase PM_HIBERNATION_PREPARE:\r\ncase PM_SUSPEND_PREPARE:\r\ncase PM_RESTORE_PREPARE:\r\nreturn NOTIFY_DONE;\r\n}\r\nvideo = container_of(nb, struct acpi_video_bus, pm_nb);\r\ndev_info(&video->device->dev, "Restoring backlight state\n");\r\nfor (i = 0; i < video->attached_count; i++) {\r\nvideo_device = video->attached_array[i].bind_info;\r\nif (video_device && video_device->brightness)\r\nacpi_video_device_lcd_set_level(video_device,\r\nvideo_device->brightness->curr);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic acpi_status\r\nacpi_video_bus_match(acpi_handle handle, u32 level, void *context,\r\nvoid **return_value)\r\n{\r\nstruct acpi_device *device = context;\r\nstruct acpi_device *sibling;\r\nint result;\r\nif (handle == device->handle)\r\nreturn AE_CTRL_TERMINATE;\r\nresult = acpi_bus_get_device(handle, &sibling);\r\nif (result)\r\nreturn AE_OK;\r\nif (!strcmp(acpi_device_name(sibling), ACPI_VIDEO_BUS_NAME))\r\nreturn AE_ALREADY_EXISTS;\r\nreturn AE_OK;\r\n}\r\nstatic void acpi_video_dev_register_backlight(struct acpi_video_device *device)\r\n{\r\nstruct backlight_properties props;\r\nstruct pci_dev *pdev;\r\nacpi_handle acpi_parent;\r\nstruct device *parent = NULL;\r\nint result;\r\nstatic int count;\r\nchar *name;\r\nresult = acpi_video_init_brightness(device);\r\nif (result)\r\nreturn;\r\nif (disable_backlight_sysfs_if > 0)\r\nreturn;\r\nname = kasprintf(GFP_KERNEL, "acpi_video%d", count);\r\nif (!name)\r\nreturn;\r\ncount++;\r\nacpi_get_parent(device->dev->handle, &acpi_parent);\r\npdev = acpi_get_pci_dev(acpi_parent);\r\nif (pdev) {\r\nparent = &pdev->dev;\r\npci_dev_put(pdev);\r\n}\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_FIRMWARE;\r\nprops.max_brightness = device->brightness->count - 3;\r\ndevice->backlight = backlight_device_register(name,\r\nparent,\r\ndevice,\r\n&acpi_backlight_ops,\r\n&props);\r\nkfree(name);\r\nif (IS_ERR(device->backlight)) {\r\ndevice->backlight = NULL;\r\nreturn;\r\n}\r\ndevice->backlight->props.brightness =\r\nacpi_video_get_brightness(device->backlight);\r\ndevice->cooling_dev = thermal_cooling_device_register("LCD",\r\ndevice->dev, &video_cooling_ops);\r\nif (IS_ERR(device->cooling_dev)) {\r\ndevice->cooling_dev = NULL;\r\nreturn;\r\n}\r\ndev_info(&device->dev->dev, "registered as cooling_device%d\n",\r\ndevice->cooling_dev->id);\r\nresult = sysfs_create_link(&device->dev->dev.kobj,\r\n&device->cooling_dev->device.kobj,\r\n"thermal_cooling");\r\nif (result)\r\nprintk(KERN_ERR PREFIX "Create sysfs link\n");\r\nresult = sysfs_create_link(&device->cooling_dev->device.kobj,\r\n&device->dev->dev.kobj, "device");\r\nif (result)\r\nprintk(KERN_ERR PREFIX "Create sysfs link\n");\r\n}\r\nstatic void acpi_video_run_bcl_for_osi(struct acpi_video_bus *video)\r\n{\r\nstruct acpi_video_device *dev;\r\nunion acpi_object *levels;\r\nmutex_lock(&video->device_list_lock);\r\nlist_for_each_entry(dev, &video->video_device_list, entry) {\r\nif (!acpi_video_device_lcd_query_levels(dev->dev->handle, &levels))\r\nkfree(levels);\r\n}\r\nmutex_unlock(&video->device_list_lock);\r\n}\r\nstatic bool acpi_video_should_register_backlight(struct acpi_video_device *dev)\r\n{\r\nif (!acpi_video_device_in_dod(dev)) {\r\ndev_dbg(&dev->dev->dev, "not in _DOD list, ignore\n");\r\nreturn false;\r\n}\r\nif (only_lcd)\r\nreturn dev->flags.lcd;\r\nreturn true;\r\n}\r\nstatic int acpi_video_bus_register_backlight(struct acpi_video_bus *video)\r\n{\r\nstruct acpi_video_device *dev;\r\nif (video->backlight_registered)\r\nreturn 0;\r\nacpi_video_run_bcl_for_osi(video);\r\nif (acpi_video_get_backlight_type() != acpi_backlight_video)\r\nreturn 0;\r\nmutex_lock(&video->device_list_lock);\r\nlist_for_each_entry(dev, &video->video_device_list, entry) {\r\nif (acpi_video_should_register_backlight(dev))\r\nacpi_video_dev_register_backlight(dev);\r\n}\r\nmutex_unlock(&video->device_list_lock);\r\nvideo->backlight_registered = true;\r\nvideo->pm_nb.notifier_call = acpi_video_resume;\r\nvideo->pm_nb.priority = 0;\r\nreturn register_pm_notifier(&video->pm_nb);\r\n}\r\nstatic void acpi_video_dev_unregister_backlight(struct acpi_video_device *device)\r\n{\r\nif (device->backlight) {\r\nbacklight_device_unregister(device->backlight);\r\ndevice->backlight = NULL;\r\n}\r\nif (device->brightness) {\r\nkfree(device->brightness->levels);\r\nkfree(device->brightness);\r\ndevice->brightness = NULL;\r\n}\r\nif (device->cooling_dev) {\r\nsysfs_remove_link(&device->dev->dev.kobj, "thermal_cooling");\r\nsysfs_remove_link(&device->cooling_dev->device.kobj, "device");\r\nthermal_cooling_device_unregister(device->cooling_dev);\r\ndevice->cooling_dev = NULL;\r\n}\r\n}\r\nstatic int acpi_video_bus_unregister_backlight(struct acpi_video_bus *video)\r\n{\r\nstruct acpi_video_device *dev;\r\nint error;\r\nif (!video->backlight_registered)\r\nreturn 0;\r\nerror = unregister_pm_notifier(&video->pm_nb);\r\nmutex_lock(&video->device_list_lock);\r\nlist_for_each_entry(dev, &video->video_device_list, entry)\r\nacpi_video_dev_unregister_backlight(dev);\r\nmutex_unlock(&video->device_list_lock);\r\nvideo->backlight_registered = false;\r\nreturn error;\r\n}\r\nstatic void acpi_video_dev_add_notify_handler(struct acpi_video_device *device)\r\n{\r\nacpi_status status;\r\nstruct acpi_device *adev = device->dev;\r\nstatus = acpi_install_notify_handler(adev->handle, ACPI_DEVICE_NOTIFY,\r\nacpi_video_device_notify, device);\r\nif (ACPI_FAILURE(status))\r\ndev_err(&adev->dev, "Error installing notify handler\n");\r\nelse\r\ndevice->flags.notify = 1;\r\n}\r\nstatic int acpi_video_bus_add_notify_handler(struct acpi_video_bus *video)\r\n{\r\nstruct input_dev *input;\r\nstruct acpi_video_device *dev;\r\nint error;\r\nvideo->input = input = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nerror = acpi_video_bus_start_devices(video);\r\nif (error)\r\ngoto err_free_input;\r\nsnprintf(video->phys, sizeof(video->phys),\r\n"%s/video/input0", acpi_device_hid(video->device));\r\ninput->name = acpi_device_name(video->device);\r\ninput->phys = video->phys;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.product = 0x06;\r\ninput->dev.parent = &video->device->dev;\r\ninput->evbit[0] = BIT(EV_KEY);\r\nset_bit(KEY_SWITCHVIDEOMODE, input->keybit);\r\nset_bit(KEY_VIDEO_NEXT, input->keybit);\r\nset_bit(KEY_VIDEO_PREV, input->keybit);\r\nset_bit(KEY_BRIGHTNESS_CYCLE, input->keybit);\r\nset_bit(KEY_BRIGHTNESSUP, input->keybit);\r\nset_bit(KEY_BRIGHTNESSDOWN, input->keybit);\r\nset_bit(KEY_BRIGHTNESS_ZERO, input->keybit);\r\nset_bit(KEY_DISPLAY_OFF, input->keybit);\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_stop_dev;\r\nmutex_lock(&video->device_list_lock);\r\nlist_for_each_entry(dev, &video->video_device_list, entry)\r\nacpi_video_dev_add_notify_handler(dev);\r\nmutex_unlock(&video->device_list_lock);\r\nreturn 0;\r\nerr_stop_dev:\r\nacpi_video_bus_stop_devices(video);\r\nerr_free_input:\r\ninput_free_device(input);\r\nvideo->input = NULL;\r\nout:\r\nreturn error;\r\n}\r\nstatic void acpi_video_dev_remove_notify_handler(struct acpi_video_device *dev)\r\n{\r\nif (dev->flags.notify) {\r\nacpi_remove_notify_handler(dev->dev->handle, ACPI_DEVICE_NOTIFY,\r\nacpi_video_device_notify);\r\ndev->flags.notify = 0;\r\n}\r\n}\r\nstatic void acpi_video_bus_remove_notify_handler(struct acpi_video_bus *video)\r\n{\r\nstruct acpi_video_device *dev;\r\nmutex_lock(&video->device_list_lock);\r\nlist_for_each_entry(dev, &video->video_device_list, entry)\r\nacpi_video_dev_remove_notify_handler(dev);\r\nmutex_unlock(&video->device_list_lock);\r\nacpi_video_bus_stop_devices(video);\r\ninput_unregister_device(video->input);\r\nvideo->input = NULL;\r\n}\r\nstatic int acpi_video_bus_put_devices(struct acpi_video_bus *video)\r\n{\r\nstruct acpi_video_device *dev, *next;\r\nmutex_lock(&video->device_list_lock);\r\nlist_for_each_entry_safe(dev, next, &video->video_device_list, entry) {\r\nlist_del(&dev->entry);\r\nkfree(dev);\r\n}\r\nmutex_unlock(&video->device_list_lock);\r\nreturn 0;\r\n}\r\nstatic int acpi_video_bus_add(struct acpi_device *device)\r\n{\r\nstruct acpi_video_bus *video;\r\nint error;\r\nacpi_status status;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE,\r\ndevice->parent->handle, 1,\r\nacpi_video_bus_match, NULL,\r\ndevice, NULL);\r\nif (status == AE_ALREADY_EXISTS) {\r\nprintk(KERN_WARNING FW_BUG\r\n"Duplicate ACPI video bus devices for the"\r\n" same VGA controller, please try module "\r\n"parameter \"video.allow_duplicates=1\""\r\n"if the current driver doesn't work.\n");\r\nif (!allow_duplicates)\r\nreturn -ENODEV;\r\n}\r\nvideo = kzalloc(sizeof(struct acpi_video_bus), GFP_KERNEL);\r\nif (!video)\r\nreturn -ENOMEM;\r\nif (!strcmp(device->pnp.bus_id, "VID")) {\r\nif (instance)\r\ndevice->pnp.bus_id[3] = '0' + instance;\r\ninstance++;\r\n}\r\nif (!strcmp(device->pnp.bus_id, "VGA")) {\r\nif (instance)\r\ndevice->pnp.bus_id[3] = '0' + instance;\r\ninstance++;\r\n}\r\nvideo->device = device;\r\nstrcpy(acpi_device_name(device), ACPI_VIDEO_BUS_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_VIDEO_CLASS);\r\ndevice->driver_data = video;\r\nacpi_video_bus_find_cap(video);\r\nerror = acpi_video_bus_check(video);\r\nif (error)\r\ngoto err_free_video;\r\nmutex_init(&video->device_list_lock);\r\nINIT_LIST_HEAD(&video->video_device_list);\r\nerror = acpi_video_bus_get_devices(video, device);\r\nif (error)\r\ngoto err_put_video;\r\nprintk(KERN_INFO PREFIX "%s [%s] (multi-head: %s rom: %s post: %s)\n",\r\nACPI_VIDEO_DEVICE_NAME, acpi_device_bid(device),\r\nvideo->flags.multihead ? "yes" : "no",\r\nvideo->flags.rom ? "yes" : "no",\r\nvideo->flags.post ? "yes" : "no");\r\nmutex_lock(&video_list_lock);\r\nlist_add_tail(&video->entry, &video_bus_head);\r\nmutex_unlock(&video_list_lock);\r\nacpi_video_bus_register_backlight(video);\r\nacpi_video_bus_add_notify_handler(video);\r\nreturn 0;\r\nerr_put_video:\r\nacpi_video_bus_put_devices(video);\r\nkfree(video->attached_array);\r\nerr_free_video:\r\nkfree(video);\r\ndevice->driver_data = NULL;\r\nreturn error;\r\n}\r\nstatic int acpi_video_bus_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_video_bus *video = NULL;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nvideo = acpi_driver_data(device);\r\nacpi_video_bus_remove_notify_handler(video);\r\nacpi_video_bus_unregister_backlight(video);\r\nacpi_video_bus_put_devices(video);\r\nmutex_lock(&video_list_lock);\r\nlist_del(&video->entry);\r\nmutex_unlock(&video_list_lock);\r\nkfree(video->attached_array);\r\nkfree(video);\r\nreturn 0;\r\n}\r\nstatic int __init is_i740(struct pci_dev *dev)\r\n{\r\nif (dev->device == 0x00D1)\r\nreturn 1;\r\nif (dev->device == 0x7000)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init intel_opregion_present(void)\r\n{\r\nint opregion = 0;\r\nstruct pci_dev *dev = NULL;\r\nu32 address;\r\nfor_each_pci_dev(dev) {\r\nif ((dev->class >> 8) != PCI_CLASS_DISPLAY_VGA)\r\ncontinue;\r\nif (dev->vendor != PCI_VENDOR_ID_INTEL)\r\ncontinue;\r\nif (is_i740(dev))\r\ncontinue;\r\npci_read_config_dword(dev, 0xfc, &address);\r\nif (!address)\r\ncontinue;\r\nopregion = 1;\r\n}\r\nreturn opregion;\r\n}\r\nint acpi_video_register(void)\r\n{\r\nint ret = 0;\r\nmutex_lock(&register_count_mutex);\r\nif (register_count) {\r\ngoto leave;\r\n}\r\ndmi_check_system(video_dmi_table);\r\nret = acpi_bus_register_driver(&acpi_video_bus);\r\nif (ret)\r\ngoto leave;\r\nregister_count = 1;\r\nleave:\r\nmutex_unlock(&register_count_mutex);\r\nreturn ret;\r\n}\r\nvoid acpi_video_unregister(void)\r\n{\r\nmutex_lock(&register_count_mutex);\r\nif (register_count) {\r\nacpi_bus_unregister_driver(&acpi_video_bus);\r\nregister_count = 0;\r\n}\r\nmutex_unlock(&register_count_mutex);\r\n}\r\nvoid acpi_video_unregister_backlight(void)\r\n{\r\nstruct acpi_video_bus *video;\r\nmutex_lock(&register_count_mutex);\r\nif (register_count) {\r\nmutex_lock(&video_list_lock);\r\nlist_for_each_entry(video, &video_bus_head, entry)\r\nacpi_video_bus_unregister_backlight(video);\r\nmutex_unlock(&video_list_lock);\r\n}\r\nmutex_unlock(&register_count_mutex);\r\n}\r\nbool acpi_video_handles_brightness_key_presses(void)\r\n{\r\nbool have_video_busses;\r\nmutex_lock(&video_list_lock);\r\nhave_video_busses = !list_empty(&video_bus_head);\r\nmutex_unlock(&video_list_lock);\r\nreturn have_video_busses &&\r\n(report_key_events & REPORT_BRIGHTNESS_KEY_EVENTS);\r\n}\r\nstatic int __init acpi_video_init(void)\r\n{\r\nif (acpi_disabled)\r\nreturn 0;\r\nif (intel_opregion_present())\r\nreturn 0;\r\nreturn acpi_video_register();\r\n}\r\nstatic void __exit acpi_video_exit(void)\r\n{\r\nacpi_video_detect_exit();\r\nacpi_video_unregister();\r\nreturn;\r\n}
