uint32_t pipe2vbl(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nreturn dispc_mgr_get_vsync_irq(omap_crtc->channel);\r\n}\r\nstruct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nreturn &omap_crtc->timings;\r\n}\r\nenum omap_channel omap_crtc_channel(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nreturn omap_crtc->channel;\r\n}\r\nint omap_crtc_wait_pending(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nreturn wait_event_timeout(omap_crtc->pending_wait,\r\n!omap_crtc->pending,\r\nmsecs_to_jiffies(250));\r\n}\r\nstatic int omap_crtc_dss_connect(enum omap_channel channel,\r\nstruct omap_dss_device *dst)\r\n{\r\nif (omap_crtc_output[channel])\r\nreturn -EINVAL;\r\nif ((dispc_mgr_get_supported_outputs(channel) & dst->id) == 0)\r\nreturn -EINVAL;\r\nomap_crtc_output[channel] = dst;\r\ndst->dispc_channel_connected = true;\r\nreturn 0;\r\n}\r\nstatic void omap_crtc_dss_disconnect(enum omap_channel channel,\r\nstruct omap_dss_device *dst)\r\n{\r\nomap_crtc_output[channel] = NULL;\r\ndst->dispc_channel_connected = false;\r\n}\r\nstatic void omap_crtc_dss_start_update(enum omap_channel channel)\r\n{\r\n}\r\nstatic void omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nenum omap_channel channel = omap_crtc->channel;\r\nstruct omap_irq_wait *wait;\r\nu32 framedone_irq, vsync_irq;\r\nint ret;\r\nif (omap_crtc_output[channel]->output_type == OMAP_DISPLAY_TYPE_HDMI) {\r\ndispc_mgr_enable(channel, enable);\r\nreturn;\r\n}\r\nif (dispc_mgr_is_enabled(channel) == enable)\r\nreturn;\r\nif (omap_crtc->channel == OMAP_DSS_CHANNEL_DIGIT) {\r\nomap_crtc->ignore_digit_sync_lost = true;\r\n}\r\nframedone_irq = dispc_mgr_get_framedone_irq(channel);\r\nvsync_irq = dispc_mgr_get_vsync_irq(channel);\r\nif (enable) {\r\nwait = omap_irq_wait_init(dev, vsync_irq, 1);\r\n} else {\r\nif (framedone_irq)\r\nwait = omap_irq_wait_init(dev, framedone_irq, 1);\r\nelse\r\nwait = omap_irq_wait_init(dev, vsync_irq, 2);\r\n}\r\ndispc_mgr_enable(channel, enable);\r\nret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));\r\nif (ret) {\r\ndev_err(dev->dev, "%s: timeout waiting for %s\n",\r\nomap_crtc->name, enable ? "enable" : "disable");\r\n}\r\nif (omap_crtc->channel == OMAP_DSS_CHANNEL_DIGIT) {\r\nomap_crtc->ignore_digit_sync_lost = false;\r\nmb();\r\n}\r\n}\r\nstatic int omap_crtc_dss_enable(enum omap_channel channel)\r\n{\r\nstruct omap_crtc *omap_crtc = omap_crtcs[channel];\r\nstruct omap_overlay_manager_info info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.default_color = 0x00000000;\r\ninfo.trans_key = 0x00000000;\r\ninfo.trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;\r\ninfo.trans_enabled = false;\r\ndispc_mgr_setup(omap_crtc->channel, &info);\r\ndispc_mgr_set_timings(omap_crtc->channel,\r\n&omap_crtc->timings);\r\nomap_crtc_set_enabled(&omap_crtc->base, true);\r\nreturn 0;\r\n}\r\nstatic void omap_crtc_dss_disable(enum omap_channel channel)\r\n{\r\nstruct omap_crtc *omap_crtc = omap_crtcs[channel];\r\nomap_crtc_set_enabled(&omap_crtc->base, false);\r\n}\r\nstatic void omap_crtc_dss_set_timings(enum omap_channel channel,\r\nconst struct omap_video_timings *timings)\r\n{\r\nstruct omap_crtc *omap_crtc = omap_crtcs[channel];\r\nDBG("%s", omap_crtc->name);\r\nomap_crtc->timings = *timings;\r\n}\r\nstatic void omap_crtc_dss_set_lcd_config(enum omap_channel channel,\r\nconst struct dss_lcd_mgr_config *config)\r\n{\r\nstruct omap_crtc *omap_crtc = omap_crtcs[channel];\r\nDBG("%s", omap_crtc->name);\r\ndispc_mgr_set_lcd_config(omap_crtc->channel, config);\r\n}\r\nstatic int omap_crtc_dss_register_framedone(\r\nenum omap_channel channel,\r\nvoid (*handler)(void *), void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic void omap_crtc_dss_unregister_framedone(\r\nenum omap_channel channel,\r\nvoid (*handler)(void *), void *data)\r\n{\r\n}\r\nstatic void omap_crtc_complete_page_flip(struct drm_crtc *crtc)\r\n{\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_device *dev = crtc->dev;\r\nunsigned long flags;\r\nevent = crtc->state->event;\r\nif (!event)\r\nreturn;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\ndrm_crtc_send_vblank_event(crtc, event);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct omap_crtc *omap_crtc =\r\ncontainer_of(irq, struct omap_crtc, error_irq);\r\nif (omap_crtc->ignore_digit_sync_lost) {\r\nirqstatus &= ~DISPC_IRQ_SYNC_LOST_DIGIT;\r\nif (!irqstatus)\r\nreturn;\r\n}\r\nDRM_ERROR_RATELIMITED("%s: errors: %08x\n", omap_crtc->name, irqstatus);\r\n}\r\nstatic void omap_crtc_vblank_irq(struct omap_drm_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct omap_crtc *omap_crtc =\r\ncontainer_of(irq, struct omap_crtc, vblank_irq);\r\nstruct drm_device *dev = omap_crtc->base.dev;\r\nif (dispc_mgr_go_busy(omap_crtc->channel))\r\nreturn;\r\nDBG("%s: apply done", omap_crtc->name);\r\n__omap_irq_unregister(dev, &omap_crtc->vblank_irq);\r\nrmb();\r\nWARN_ON(!omap_crtc->pending);\r\nomap_crtc->pending = false;\r\nwmb();\r\nomap_crtc_complete_page_flip(&omap_crtc->base);\r\nwake_up(&omap_crtc->pending_wait);\r\n}\r\nstatic void omap_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nDBG("%s", omap_crtc->name);\r\nWARN_ON(omap_crtc->vblank_irq.registered);\r\nomap_irq_unregister(crtc->dev, &omap_crtc->error_irq);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(omap_crtc);\r\n}\r\nstatic void omap_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nDBG("%s", omap_crtc->name);\r\nrmb();\r\nWARN_ON(omap_crtc->pending);\r\nomap_crtc->pending = true;\r\nwmb();\r\nomap_irq_register(crtc->dev, &omap_crtc->vblank_irq);\r\ndrm_crtc_vblank_on(crtc);\r\n}\r\nstatic void omap_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nDBG("%s", omap_crtc->name);\r\ndrm_crtc_vblank_off(crtc);\r\n}\r\nstatic void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\r\nDBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\nomap_crtc->name, mode->base.id, mode->name,\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start, mode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start, mode->vsync_end, mode->vtotal,\r\nmode->type, mode->flags);\r\ncopy_timings_drm_to_omap(&omap_crtc->timings, mode);\r\n}\r\nstatic int omap_crtc_atomic_check(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nif (state->color_mgmt_changed && state->gamma_lut) {\r\nuint length = state->gamma_lut->length /\r\nsizeof(struct drm_color_lut);\r\nif (length < 2)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_crtc_atomic_begin(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\n}\r\nstatic void omap_crtc_atomic_flush(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nWARN_ON(omap_crtc->vblank_irq.registered);\r\nif (crtc->state->color_mgmt_changed) {\r\nstruct drm_color_lut *lut = NULL;\r\nuint length = 0;\r\nif (crtc->state->gamma_lut) {\r\nlut = (struct drm_color_lut *)\r\ncrtc->state->gamma_lut->data;\r\nlength = crtc->state->gamma_lut->length /\r\nsizeof(*lut);\r\n}\r\ndispc_mgr_set_gamma(omap_crtc->channel, lut, length);\r\n}\r\nif (crtc->state->color_mgmt_changed) {\r\nstruct drm_color_lut *lut = NULL;\r\nuint length = 0;\r\nif (crtc->state->gamma_lut) {\r\nlut = (struct drm_color_lut *)\r\ncrtc->state->gamma_lut->data;\r\nlength = crtc->state->gamma_lut->length /\r\nsizeof(*lut);\r\n}\r\ndispc_mgr_set_gamma(omap_crtc->channel, lut, length);\r\n}\r\nif (dispc_mgr_is_enabled(omap_crtc->channel)) {\r\nDBG("%s: GO", omap_crtc->name);\r\nrmb();\r\nWARN_ON(omap_crtc->pending);\r\nomap_crtc->pending = true;\r\nwmb();\r\ndispc_mgr_go(omap_crtc->channel);\r\nomap_irq_register(crtc->dev, &omap_crtc->vblank_irq);\r\n}\r\n}\r\nstatic bool omap_crtc_is_plane_prop(struct drm_device *dev,\r\nstruct drm_property *property)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nreturn property == priv->zorder_prop ||\r\nproperty == dev->mode_config.rotation_property;\r\n}\r\nstatic int omap_crtc_atomic_set_property(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nif (omap_crtc_is_plane_prop(dev, property)) {\r\nstruct drm_plane_state *plane_state;\r\nstruct drm_plane *plane = crtc->primary;\r\nplane_state = drm_atomic_get_plane_state(state->state, plane);\r\nif (IS_ERR(plane_state))\r\nreturn PTR_ERR(plane_state);\r\nreturn drm_atomic_plane_set_property(plane, plane_state,\r\nproperty, val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int omap_crtc_atomic_get_property(struct drm_crtc *crtc,\r\nconst struct drm_crtc_state *state,\r\nstruct drm_property *property,\r\nuint64_t *val)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nif (omap_crtc_is_plane_prop(dev, property)) {\r\nreturn drm_object_property_get_value(&crtc->primary->base,\r\nproperty, val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid omap_crtc_pre_init(void)\r\n{\r\ndss_install_mgr_ops(&mgr_ops);\r\n}\r\nvoid omap_crtc_pre_uninit(void)\r\n{\r\ndss_uninstall_mgr_ops();\r\n}\r\nstruct drm_crtc *omap_crtc_init(struct drm_device *dev,\r\nstruct drm_plane *plane, enum omap_channel channel, int id)\r\n{\r\nstruct drm_crtc *crtc = NULL;\r\nstruct omap_crtc *omap_crtc;\r\nint ret;\r\nDBG("%s", channel_names[channel]);\r\nomap_crtc = kzalloc(sizeof(*omap_crtc), GFP_KERNEL);\r\nif (!omap_crtc)\r\nreturn NULL;\r\ncrtc = &omap_crtc->base;\r\ninit_waitqueue_head(&omap_crtc->pending_wait);\r\nomap_crtc->channel = channel;\r\nomap_crtc->name = channel_names[channel];\r\nomap_crtc->vblank_irq.irqmask = pipe2vbl(crtc);\r\nomap_crtc->vblank_irq.irq = omap_crtc_vblank_irq;\r\nomap_crtc->error_irq.irqmask =\r\ndispc_mgr_get_sync_lost_irq(channel);\r\nomap_crtc->error_irq.irq = omap_crtc_error_irq;\r\nomap_irq_register(dev, &omap_crtc->error_irq);\r\nret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,\r\n&omap_crtc_funcs, NULL);\r\nif (ret < 0) {\r\nkfree(omap_crtc);\r\nreturn NULL;\r\n}\r\ndrm_crtc_helper_add(crtc, &omap_crtc_helper_funcs);\r\nif (dispc_mgr_gamma_size(channel)) {\r\nuint gamma_lut_size = 256;\r\ndrm_crtc_enable_color_mgmt(crtc, 0, false, gamma_lut_size);\r\ndrm_mode_crtc_set_gamma_size(crtc, gamma_lut_size);\r\n}\r\nomap_plane_install_properties(crtc->primary, &crtc->base);\r\nomap_crtcs[channel] = omap_crtc;\r\nreturn crtc;\r\n}
