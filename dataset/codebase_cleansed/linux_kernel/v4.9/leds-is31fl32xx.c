static int is31fl32xx_write(struct is31fl32xx_priv *priv, u8 reg, u8 val)\r\n{\r\nint ret;\r\ndev_dbg(&priv->client->dev, "writing register 0x%02X=0x%02X", reg, val);\r\nret = i2c_smbus_write_byte_data(priv->client, reg, val);\r\nif (ret) {\r\ndev_err(&priv->client->dev,\r\n"register write to 0x%02X failed (error %d)",\r\nreg, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int is31fl3216_reset(struct is31fl32xx_priv *priv)\r\n{\r\nunsigned int i;\r\nint ret;\r\nret = is31fl32xx_write(priv, IS31FL3216_CONFIG_REG,\r\nIS31FL3216_CONFIG_SSD_ENABLE);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < priv->cdef->channels; i++) {\r\nret = is31fl32xx_write(priv, priv->cdef->pwm_register_base+i,\r\n0x00);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = is31fl32xx_write(priv, priv->cdef->pwm_update_reg, 0);\r\nif (ret)\r\nreturn ret;\r\nret = is31fl32xx_write(priv, IS31FL3216_LIGHTING_EFFECT_REG, 0x00);\r\nif (ret)\r\nreturn ret;\r\nret = is31fl32xx_write(priv, IS31FL3216_CHANNEL_CONFIG_REG, 0x00);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int is31fl3216_software_shutdown(struct is31fl32xx_priv *priv,\r\nbool enable)\r\n{\r\nu8 value = enable ? IS31FL3216_CONFIG_SSD_ENABLE :\r\nIS31FL3216_CONFIG_SSD_DISABLE;\r\nreturn is31fl32xx_write(priv, IS31FL3216_CONFIG_REG, value);\r\n}\r\nstatic int is31fl32xx_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nconst struct is31fl32xx_led_data *led_data =\r\ncontainer_of(led_cdev, struct is31fl32xx_led_data, cdev);\r\nconst struct is31fl32xx_chipdef *cdef = led_data->priv->cdef;\r\nu8 pwm_register_offset;\r\nint ret;\r\ndev_dbg(led_cdev->dev, "%s: %d\n", __func__, brightness);\r\nif (cdef->pwm_registers_reversed)\r\npwm_register_offset = cdef->channels - led_data->channel;\r\nelse\r\npwm_register_offset = led_data->channel - 1;\r\nret = is31fl32xx_write(led_data->priv,\r\ncdef->pwm_register_base + pwm_register_offset,\r\nbrightness);\r\nif (ret)\r\nreturn ret;\r\nreturn is31fl32xx_write(led_data->priv, cdef->pwm_update_reg, 0);\r\n}\r\nstatic int is31fl32xx_reset_regs(struct is31fl32xx_priv *priv)\r\n{\r\nconst struct is31fl32xx_chipdef *cdef = priv->cdef;\r\nint ret;\r\nif (cdef->reset_reg != IS31FL32XX_REG_NONE) {\r\nret = is31fl32xx_write(priv, cdef->reset_reg, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (cdef->reset_func)\r\nreturn cdef->reset_func(priv);\r\nreturn 0;\r\n}\r\nstatic int is31fl32xx_software_shutdown(struct is31fl32xx_priv *priv,\r\nbool enable)\r\n{\r\nconst struct is31fl32xx_chipdef *cdef = priv->cdef;\r\nint ret;\r\nif (cdef->shutdown_reg != IS31FL32XX_REG_NONE) {\r\nu8 value = enable ? IS31FL32XX_SHUTDOWN_SSD_ENABLE :\r\nIS31FL32XX_SHUTDOWN_SSD_DISABLE;\r\nret = is31fl32xx_write(priv, cdef->shutdown_reg, value);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (cdef->sw_shutdown_func)\r\nreturn cdef->sw_shutdown_func(priv, enable);\r\nreturn 0;\r\n}\r\nstatic int is31fl32xx_init_regs(struct is31fl32xx_priv *priv)\r\n{\r\nconst struct is31fl32xx_chipdef *cdef = priv->cdef;\r\nint ret;\r\nret = is31fl32xx_reset_regs(priv);\r\nif (ret)\r\nreturn ret;\r\nif (cdef->led_control_register_base != IS31FL32XX_REG_NONE) {\r\nu8 value =\r\nGENMASK(cdef->enable_bits_per_led_control_register-1, 0);\r\nu8 num_regs = cdef->channels /\r\ncdef->enable_bits_per_led_control_register;\r\nint i;\r\nfor (i = 0; i < num_regs; i++) {\r\nret = is31fl32xx_write(priv,\r\ncdef->led_control_register_base+i,\r\nvalue);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nret = is31fl32xx_software_shutdown(priv, false);\r\nif (ret)\r\nreturn ret;\r\nif (cdef->global_control_reg != IS31FL32XX_REG_NONE) {\r\nret = is31fl32xx_write(priv, cdef->global_control_reg, 0x00);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline size_t sizeof_is31fl32xx_priv(int num_leds)\r\n{\r\nreturn sizeof(struct is31fl32xx_priv) +\r\n(sizeof(struct is31fl32xx_led_data) * num_leds);\r\n}\r\nstatic int is31fl32xx_parse_child_dt(const struct device *dev,\r\nconst struct device_node *child,\r\nstruct is31fl32xx_led_data *led_data)\r\n{\r\nstruct led_classdev *cdev = &led_data->cdev;\r\nint ret = 0;\r\nu32 reg;\r\nif (of_property_read_string(child, "label", &cdev->name))\r\ncdev->name = child->name;\r\nret = of_property_read_u32(child, "reg", &reg);\r\nif (ret || reg < 1 || reg > led_data->priv->cdef->channels) {\r\ndev_err(dev,\r\n"Child node %s does not have a valid reg property\n",\r\nchild->full_name);\r\nreturn -EINVAL;\r\n}\r\nled_data->channel = reg;\r\nof_property_read_string(child, "linux,default-trigger",\r\n&cdev->default_trigger);\r\ncdev->brightness_set_blocking = is31fl32xx_brightness_set;\r\nreturn 0;\r\n}\r\nstatic struct is31fl32xx_led_data *is31fl32xx_find_led_data(\r\nstruct is31fl32xx_priv *priv,\r\nu8 channel)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < priv->num_leds; i++) {\r\nif (priv->leds[i].channel == channel)\r\nreturn &priv->leds[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int is31fl32xx_parse_dt(struct device *dev,\r\nstruct is31fl32xx_priv *priv)\r\n{\r\nstruct device_node *child;\r\nint ret = 0;\r\nfor_each_child_of_node(dev->of_node, child) {\r\nstruct is31fl32xx_led_data *led_data =\r\n&priv->leds[priv->num_leds];\r\nconst struct is31fl32xx_led_data *other_led_data;\r\nled_data->priv = priv;\r\nret = is31fl32xx_parse_child_dt(dev, child, led_data);\r\nif (ret)\r\ngoto err;\r\nother_led_data = is31fl32xx_find_led_data(priv,\r\nled_data->channel);\r\nif (other_led_data) {\r\ndev_err(dev,\r\n"%s and %s both attempting to use channel %d\n",\r\nled_data->cdev.name,\r\nother_led_data->cdev.name,\r\nled_data->channel);\r\ngoto err;\r\n}\r\nret = devm_led_classdev_register(dev, &led_data->cdev);\r\nif (ret) {\r\ndev_err(dev, "failed to register PWM led for %s: %d\n",\r\nled_data->cdev.name, ret);\r\ngoto err;\r\n}\r\npriv->num_leds++;\r\n}\r\nreturn 0;\r\nerr:\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\nstatic int is31fl32xx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct is31fl32xx_chipdef *cdef;\r\nconst struct of_device_id *of_dev_id;\r\nstruct device *dev = &client->dev;\r\nstruct is31fl32xx_priv *priv;\r\nint count;\r\nint ret = 0;\r\nof_dev_id = of_match_device(of_is31fl32xx_match, dev);\r\nif (!of_dev_id)\r\nreturn -EINVAL;\r\ncdef = of_dev_id->data;\r\ncount = of_get_child_count(dev->of_node);\r\nif (!count)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(dev, sizeof_is31fl32xx_priv(count),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->client = client;\r\npriv->cdef = cdef;\r\ni2c_set_clientdata(client, priv);\r\nret = is31fl32xx_init_regs(priv);\r\nif (ret)\r\nreturn ret;\r\nret = is31fl32xx_parse_dt(dev, priv);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int is31fl32xx_remove(struct i2c_client *client)\r\n{\r\nstruct is31fl32xx_priv *priv = i2c_get_clientdata(client);\r\nreturn is31fl32xx_reset_regs(priv);\r\n}
