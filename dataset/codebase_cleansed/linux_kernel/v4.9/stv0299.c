static int stv0299_writeregI (struct stv0299_state* state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf [] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\r\nret = i2c_transfer (state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: writereg error (reg == 0x%02x, val == 0x%02x, "\r\n"ret == %i)\n", __func__, reg, data, ret);\r\nreturn (ret != 1) ? -EREMOTEIO : 0;\r\n}\r\nstatic int stv0299_write(struct dvb_frontend* fe, const u8 buf[], int len)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nif (len != 2)\r\nreturn -EINVAL;\r\nreturn stv0299_writeregI(state, buf[0], buf[1]);\r\n}\r\nstatic u8 stv0299_readreg (struct stv0299_state* state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0 [] = { reg };\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\nret = i2c_transfer (state->i2c, msg, 2);\r\nif (ret != 2)\r\ndprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n",\r\n__func__, reg, ret);\r\nreturn b1[0];\r\n}\r\nstatic int stv0299_readregs (struct stv0299_state* state, u8 reg1, u8 *b, u8 len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = &reg1, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b, .len = len } };\r\nret = i2c_transfer (state->i2c, msg, 2);\r\nif (ret != 2)\r\ndprintk("%s: readreg error (ret == %i)\n", __func__, ret);\r\nreturn ret == 2 ? 0 : ret;\r\n}\r\nstatic int stv0299_set_FEC(struct stv0299_state *state, enum fe_code_rate fec)\r\n{\r\ndprintk ("%s\n", __func__);\r\nswitch (fec) {\r\ncase FEC_AUTO:\r\n{\r\nreturn stv0299_writeregI (state, 0x31, 0x1f);\r\n}\r\ncase FEC_1_2:\r\n{\r\nreturn stv0299_writeregI (state, 0x31, 0x01);\r\n}\r\ncase FEC_2_3:\r\n{\r\nreturn stv0299_writeregI (state, 0x31, 0x02);\r\n}\r\ncase FEC_3_4:\r\n{\r\nreturn stv0299_writeregI (state, 0x31, 0x04);\r\n}\r\ncase FEC_5_6:\r\n{\r\nreturn stv0299_writeregI (state, 0x31, 0x08);\r\n}\r\ncase FEC_7_8:\r\n{\r\nreturn stv0299_writeregI (state, 0x31, 0x10);\r\n}\r\ndefault:\r\n{\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nstatic enum fe_code_rate stv0299_get_fec(struct stv0299_state *state)\r\n{\r\nstatic enum fe_code_rate fec_tab[] = { FEC_2_3, FEC_3_4, FEC_5_6,\r\nFEC_7_8, FEC_1_2 };\r\nu8 index;\r\ndprintk ("%s\n", __func__);\r\nindex = stv0299_readreg (state, 0x1b);\r\nindex &= 0x7;\r\nif (index > 4)\r\nreturn FEC_AUTO;\r\nreturn fec_tab [index];\r\n}\r\nstatic int stv0299_wait_diseqc_fifo (struct stv0299_state* state, int timeout)\r\n{\r\nunsigned long start = jiffies;\r\ndprintk ("%s\n", __func__);\r\nwhile (stv0299_readreg(state, 0x0a) & 1) {\r\nif (jiffies - start > timeout) {\r\ndprintk ("%s: timeout!!\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0299_wait_diseqc_idle (struct stv0299_state* state, int timeout)\r\n{\r\nunsigned long start = jiffies;\r\ndprintk ("%s\n", __func__);\r\nwhile ((stv0299_readreg(state, 0x0a) & 3) != 2 ) {\r\nif (jiffies - start > timeout) {\r\ndprintk ("%s: timeout!!\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0299_set_symbolrate (struct dvb_frontend* fe, u32 srate)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nu64 big = srate;\r\nu32 ratio;\r\nif ((srate < 1000000) || (srate > 45000000)) return -EINVAL;\r\nbig = big << 20;\r\nbig += (state->config->mclk-1);\r\ndo_div(big, state->config->mclk);\r\nratio = big << 4;\r\nreturn state->config->set_symbol_rate(fe, srate, ratio);\r\n}\r\nstatic int stv0299_get_symbolrate (struct stv0299_state* state)\r\n{\r\nu32 Mclk = state->config->mclk / 4096L;\r\nu32 srate;\r\ns32 offset;\r\nu8 sfr[3];\r\ns8 rtf;\r\ndprintk ("%s\n", __func__);\r\nstv0299_readregs (state, 0x1f, sfr, 3);\r\nstv0299_readregs (state, 0x1a, (u8 *)&rtf, 1);\r\nsrate = (sfr[0] << 8) | sfr[1];\r\nsrate *= Mclk;\r\nsrate /= 16;\r\nsrate += (sfr[2] >> 4) * Mclk / 256;\r\noffset = (s32) rtf * (srate / 4096L);\r\noffset /= 128;\r\ndprintk ("%s : srate = %i\n", __func__, srate);\r\ndprintk ("%s : ofset = %i\n", __func__, offset);\r\nsrate += offset;\r\nsrate += 1000;\r\nsrate /= 2000;\r\nsrate *= 2000;\r\nreturn srate;\r\n}\r\nstatic int stv0299_send_diseqc_msg (struct dvb_frontend* fe,\r\nstruct dvb_diseqc_master_cmd *m)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nu8 val;\r\nint i;\r\ndprintk ("%s\n", __func__);\r\nif (stv0299_wait_diseqc_idle (state, 100) < 0)\r\nreturn -ETIMEDOUT;\r\nval = stv0299_readreg (state, 0x08);\r\nif (stv0299_writeregI (state, 0x08, (val & ~0x7) | 0x6))\r\nreturn -EREMOTEIO;\r\nfor (i=0; i<m->msg_len; i++) {\r\nif (stv0299_wait_diseqc_fifo (state, 100) < 0)\r\nreturn -ETIMEDOUT;\r\nif (stv0299_writeregI (state, 0x09, m->msg[i]))\r\nreturn -EREMOTEIO;\r\n}\r\nif (stv0299_wait_diseqc_idle (state, 100) < 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int stv0299_send_diseqc_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd burst)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nu8 val;\r\ndprintk ("%s\n", __func__);\r\nif (stv0299_wait_diseqc_idle (state, 100) < 0)\r\nreturn -ETIMEDOUT;\r\nval = stv0299_readreg (state, 0x08);\r\nif (stv0299_writeregI (state, 0x08, (val & ~0x7) | 0x2))\r\nreturn -EREMOTEIO;\r\nif (stv0299_writeregI (state, 0x09, burst == SEC_MINI_A ? 0x00 : 0xff))\r\nreturn -EREMOTEIO;\r\nif (stv0299_wait_diseqc_idle (state, 100) < 0)\r\nreturn -ETIMEDOUT;\r\nif (stv0299_writeregI (state, 0x08, val))\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int stv0299_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode tone)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nu8 val;\r\nif (stv0299_wait_diseqc_idle (state, 100) < 0)\r\nreturn -ETIMEDOUT;\r\nval = stv0299_readreg (state, 0x08);\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\nreturn stv0299_writeregI (state, 0x08, val | 0x3);\r\ncase SEC_TONE_OFF:\r\nreturn stv0299_writeregI (state, 0x08, (val & ~0x3) | 0x02);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int stv0299_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nu8 reg0x08;\r\nu8 reg0x0c;\r\ndprintk("%s: %s\n", __func__,\r\nvoltage == SEC_VOLTAGE_13 ? "SEC_VOLTAGE_13" :\r\nvoltage == SEC_VOLTAGE_18 ? "SEC_VOLTAGE_18" : "??");\r\nreg0x08 = stv0299_readreg (state, 0x08);\r\nreg0x0c = stv0299_readreg (state, 0x0c);\r\nreg0x0c &= 0x0f;\r\nreg0x08 = (reg0x08 & 0x3f) | (state->config->lock_output << 6);\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\nif (state->config->volt13_op0_op1 == STV0299_VOLT13_OP0)\r\nreg0x0c |= 0x10;\r\nelse\r\nreg0x0c |= 0x40;\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\nreg0x0c |= 0x50;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nreg0x08 = 0x00;\r\nreg0x0c = 0x00;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (state->config->op0_off)\r\nreg0x0c &= ~0x10;\r\nstv0299_writeregI(state, 0x08, reg0x08);\r\nreturn stv0299_writeregI(state, 0x0c, reg0x0c);\r\n}\r\nstatic int stv0299_send_legacy_dish_cmd (struct dvb_frontend* fe, unsigned long cmd)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nu8 reg0x08;\r\nu8 reg0x0c;\r\nu8 lv_mask = 0x40;\r\nu8 last = 1;\r\nint i;\r\nktime_t nexttime;\r\nktime_t tv[10];\r\nreg0x08 = stv0299_readreg (state, 0x08);\r\nreg0x0c = stv0299_readreg (state, 0x0c);\r\nreg0x0c &= 0x0f;\r\nstv0299_writeregI (state, 0x08, (reg0x08 & 0x3f) | (state->config->lock_output << 6));\r\nif (state->config->volt13_op0_op1 == STV0299_VOLT13_OP0)\r\nlv_mask = 0x10;\r\ncmd = cmd << 1;\r\nif (debug_legacy_dish_switch)\r\nprintk ("%s switch command: 0x%04lx\n",__func__, cmd);\r\nnexttime = ktime_get_boottime();\r\nif (debug_legacy_dish_switch)\r\ntv[0] = nexttime;\r\nstv0299_writeregI (state, 0x0c, reg0x0c | 0x50);\r\ndvb_frontend_sleep_until(&nexttime, 32000);\r\nfor (i=0; i<9; i++) {\r\nif (debug_legacy_dish_switch)\r\ntv[i+1] = ktime_get_boottime();\r\nif((cmd & 0x01) != last) {\r\nstv0299_writeregI (state, 0x0c, reg0x0c | (last ? lv_mask : 0x50));\r\nlast = (last) ? 0 : 1;\r\n}\r\ncmd = cmd >> 1;\r\nif (i != 8)\r\ndvb_frontend_sleep_until(&nexttime, 8000);\r\n}\r\nif (debug_legacy_dish_switch) {\r\nprintk ("%s(%d): switch delay (should be 32k followed by all 8k\n",\r\n__func__, fe->dvb->num);\r\nfor (i = 1; i < 10; i++)\r\nprintk("%d: %d\n", i,\r\n(int) ktime_us_delta(tv[i], tv[i-1]));\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0299_init (struct dvb_frontend* fe)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nint i;\r\nu8 reg;\r\nu8 val;\r\ndprintk("stv0299: init chip\n");\r\nstv0299_writeregI(state, 0x02, 0x30 | state->mcr_reg);\r\nmsleep(50);\r\nfor (i = 0; ; i += 2) {\r\nreg = state->config->inittab[i];\r\nval = state->config->inittab[i+1];\r\nif (reg == 0xff && val == 0xff)\r\nbreak;\r\nif (reg == 0x0c && state->config->op0_off)\r\nval &= ~0x10;\r\nif (reg == 0x2)\r\nstate->mcr_reg = val & 0xf;\r\nstv0299_writeregI(state, reg, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0299_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nu8 signal = 0xff - stv0299_readreg (state, 0x18);\r\nu8 sync = stv0299_readreg (state, 0x1b);\r\ndprintk ("%s : FE_READ_STATUS : VSTATUS: 0x%02x\n", __func__, sync);\r\n*status = 0;\r\nif (signal > 10)\r\n*status |= FE_HAS_SIGNAL;\r\nif (sync & 0x80)\r\n*status |= FE_HAS_CARRIER;\r\nif (sync & 0x10)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 0x08)\r\n*status |= FE_HAS_SYNC;\r\nif ((sync & 0x98) == 0x98)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int stv0299_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nif (state->errmode != STATUS_BER)\r\nreturn -ENOSYS;\r\n*ber = stv0299_readreg(state, 0x1e) | (stv0299_readreg(state, 0x1d) << 8);\r\nreturn 0;\r\n}\r\nstatic int stv0299_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\ns32 signal = 0xffff - ((stv0299_readreg (state, 0x18) << 8)\r\n| stv0299_readreg (state, 0x19));\r\ndprintk ("%s : FE_READ_SIGNAL_STRENGTH : AGC2I: 0x%02x%02x, signal=0x%04x\n", __func__,\r\nstv0299_readreg (state, 0x18),\r\nstv0299_readreg (state, 0x19), (int) signal);\r\nsignal = signal * 5 / 4;\r\n*strength = (signal > 0xffff) ? 0xffff : (signal < 0) ? 0 : signal;\r\nreturn 0;\r\n}\r\nstatic int stv0299_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\ns32 xsnr = 0xffff - ((stv0299_readreg (state, 0x24) << 8)\r\n| stv0299_readreg (state, 0x25));\r\nxsnr = 3 * (xsnr - 0xa100);\r\n*snr = (xsnr > 0xffff) ? 0xffff : (xsnr < 0) ? 0 : xsnr;\r\nreturn 0;\r\n}\r\nstatic int stv0299_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nif (state->errmode != STATUS_UCBLOCKS)\r\nreturn -ENOSYS;\r\nstate->ucblocks += stv0299_readreg(state, 0x1e);\r\nstate->ucblocks += (stv0299_readreg(state, 0x1d) << 8);\r\n*ucblocks = state->ucblocks;\r\nreturn 0;\r\n}\r\nstatic int stv0299_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nint invval = 0;\r\ndprintk ("%s : FE_SET_FRONTEND\n", __func__);\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, 0);\r\nif (p->inversion == INVERSION_OFF) invval = 0;\r\nelse if (p->inversion == INVERSION_ON) invval = 1;\r\nelse {\r\nprintk("stv0299 does not support auto-inversion\n");\r\nreturn -EINVAL;\r\n}\r\nif (state->config->invert) invval = (~invval) & 1;\r\nstv0299_writeregI(state, 0x0c, (stv0299_readreg(state, 0x0c) & 0xfe) | invval);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nstv0299_set_FEC(state, p->fec_inner);\r\nstv0299_set_symbolrate(fe, p->symbol_rate);\r\nstv0299_writeregI(state, 0x22, 0x00);\r\nstv0299_writeregI(state, 0x23, 0x00);\r\nstate->tuner_frequency = p->frequency;\r\nstate->fec_inner = p->fec_inner;\r\nstate->symbol_rate = p->symbol_rate;\r\nreturn 0;\r\n}\r\nstatic int stv0299_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\ns32 derot_freq;\r\nint invval;\r\nderot_freq = (s32)(s16) ((stv0299_readreg (state, 0x22) << 8)\r\n| stv0299_readreg (state, 0x23));\r\nderot_freq *= (state->config->mclk >> 16);\r\nderot_freq += 500;\r\nderot_freq /= 1000;\r\np->frequency += derot_freq;\r\ninvval = stv0299_readreg (state, 0x0c) & 1;\r\nif (state->config->invert) invval = (~invval) & 1;\r\np->inversion = invval ? INVERSION_ON : INVERSION_OFF;\r\np->fec_inner = stv0299_get_fec(state);\r\np->symbol_rate = stv0299_get_symbolrate(state);\r\nreturn 0;\r\n}\r\nstatic int stv0299_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nstv0299_writeregI(state, 0x02, 0xb0 | state->mcr_reg);\r\nstate->initialised = 0;\r\nreturn 0;\r\n}\r\nstatic int stv0299_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nstv0299_writeregI(state, 0x05, 0xb5);\r\n} else {\r\nstv0299_writeregI(state, 0x05, 0x35);\r\n}\r\nudelay(1);\r\nreturn 0;\r\n}\r\nstatic int stv0299_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nfesettings->min_delay_ms = state->config->min_delay_ms;\r\nif (p->symbol_rate < 10000000) {\r\nfesettings->step_size = p->symbol_rate / 32000;\r\nfesettings->max_drift = 5000;\r\n} else {\r\nfesettings->step_size = p->symbol_rate / 16000;\r\nfesettings->max_drift = p->symbol_rate / 2000;\r\n}\r\nreturn 0;\r\n}\r\nstatic void stv0299_release(struct dvb_frontend* fe)\r\n{\r\nstruct stv0299_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* stv0299_attach(const struct stv0299_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct stv0299_state* state = NULL;\r\nint id;\r\nstate = kzalloc(sizeof(struct stv0299_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->initialised = 0;\r\nstate->tuner_frequency = 0;\r\nstate->symbol_rate = 0;\r\nstate->fec_inner = 0;\r\nstate->errmode = STATUS_BER;\r\nstv0299_writeregI(state, 0x02, 0x30);\r\nmsleep(200);\r\nid = stv0299_readreg(state, 0x00);\r\nif (id != 0xa1 && id != 0x80) goto error;\r\nmemcpy(&state->frontend.ops, &stv0299_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
