static int ff_reprogram(struct fmc_device *fmc, struct fmc_driver *drv,\r\nchar *gw)\r\n{\r\nconst struct firmware *fw;\r\nint ret;\r\nif (!gw) {\r\nfmc->flags &= ~FMC_DEVICE_HAS_CUSTOM;\r\nfmc->flags |= FMC_DEVICE_HAS_GOLDEN;\r\nreturn 0;\r\n}\r\ndev_info(&fmc->dev, "reprogramming with %s\n", gw);\r\nret = request_firmware(&fw, gw, &fmc->dev);\r\nif (ret < 0) {\r\ndev_warn(&fmc->dev, "request firmware \"%s\": error %i\n",\r\ngw, ret);\r\ngoto out;\r\n}\r\nfmc->flags &= ~FMC_DEVICE_HAS_GOLDEN;\r\nfmc->flags |= FMC_DEVICE_HAS_CUSTOM;\r\nout:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int ff_irq_request(struct fmc_device *fmc, irq_handler_t handler,\r\nchar *name, int flags)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void ff_work_fn(struct work_struct *work)\r\n{\r\nstruct ff_dev *ff = ff_current_dev;\r\nint ret;\r\nfmc_device_unregister_n(ff->fmc, ff_nr_dev);\r\ndevice_unregister(&ff->dev);\r\nff_current_dev = NULL;\r\nff = ff_dev_create();\r\nif (IS_ERR(ff)) {\r\npr_warning("%s: can't re-create FMC devices\n", __func__);\r\nreturn;\r\n}\r\nret = fmc_device_register_n(ff->fmc, ff_nr_dev);\r\nif (ret < 0) {\r\ndev_warn(&ff->dev, "can't re-register FMC devices\n");\r\ndevice_unregister(&ff->dev);\r\nreturn;\r\n}\r\nff_current_dev = ff;\r\n}\r\nstatic int ff_eeprom_read(struct fmc_device *fmc, uint32_t offset,\r\nvoid *buf, size_t size)\r\n{\r\nif (offset > FF_EEPROM_SIZE)\r\nreturn -EINVAL;\r\nif (offset + size > FF_EEPROM_SIZE)\r\nsize = FF_EEPROM_SIZE - offset;\r\nmemcpy(buf, fmc->eeprom + offset, size);\r\nreturn size;\r\n}\r\nstatic int ff_eeprom_write(struct fmc_device *fmc, uint32_t offset,\r\nconst void *buf, size_t size)\r\n{\r\nif (offset > FF_EEPROM_SIZE)\r\nreturn -EINVAL;\r\nif (offset + size > FF_EEPROM_SIZE)\r\nsize = FF_EEPROM_SIZE - offset;\r\ndev_info(&fmc->dev, "write_eeprom: offset %i, size %zi\n",\r\n(int)offset, size);\r\nmemcpy(fmc->eeprom + offset, buf, size);\r\nschedule_delayed_work(&ff_work, HZ * 2);\r\nreturn size;\r\n}\r\nstatic int ff_read_ee(struct fmc_device *fmc, int pos, void *data, int len)\r\n{\r\nif (!(fmc->flags & FMC_DEVICE_HAS_GOLDEN))\r\nreturn -EOPNOTSUPP;\r\nreturn ff_eeprom_read(fmc, pos, data, len);\r\n}\r\nstatic int ff_write_ee(struct fmc_device *fmc, int pos,\r\nconst void *data, int len)\r\n{\r\nif (!(fmc->flags & FMC_DEVICE_HAS_GOLDEN))\r\nreturn -EOPNOTSUPP;\r\nreturn ff_eeprom_write(fmc, pos, data, len);\r\n}\r\nstatic uint32_t ff_readl(struct fmc_device *fmc, int offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ff_writel(struct fmc_device *fmc, uint32_t value, int offset)\r\n{\r\nreturn;\r\n}\r\nstatic int ff_validate(struct fmc_device *fmc, struct fmc_driver *drv)\r\n{\r\nint i;\r\nif (!drv->busid_n)\r\nreturn 0;\r\nfor (i = 0; i < drv->busid_n; i++)\r\nif (drv->busid_val[i] == fmc->device_id)\r\nreturn i;\r\nreturn -ENOENT;\r\n}\r\nstatic void ff_dev_release(struct device *dev)\r\n{\r\nstruct ff_dev *ff = container_of(dev, struct ff_dev, dev);\r\nkfree(ff);\r\n}\r\nstatic struct ff_dev *ff_dev_create(void)\r\n{\r\nstruct ff_dev *ff;\r\nstruct fmc_device *fmc;\r\nint i, ret;\r\nff = kzalloc(sizeof(*ff), GFP_KERNEL);\r\nif (!ff)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev_set_name(&ff->dev, "fake-fmc-carrier");\r\nff->dev.release = ff_dev_release;\r\nret = device_register(&ff->dev);\r\nif (ret < 0) {\r\nput_device(&ff->dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nfor (i = 0; i < ff_nr_dev; i++) {\r\nfmc = kmemdup(&ff_template_fmc, sizeof(ff_template_fmc),\r\nGFP_KERNEL);\r\nfmc->hwdev = &ff->dev;\r\nfmc->carrier_data = ff;\r\nfmc->nr_slots = ff_nr_dev;\r\nfmc->eeprom = ff_eeimg[i];\r\nfmc->eeprom_addr = 0x50 + 2 * i;\r\nfmc->slot_id = i;\r\nff->fmc[i] = fmc;\r\nff_template_fmc.device_id++;\r\n}\r\nreturn ff;\r\n}\r\nstatic int ff_init(void)\r\n{\r\nstruct ff_dev *ff;\r\nconst struct firmware *fw;\r\nint i, len, ret = 0;\r\nfor (i = 1; i < FF_MAX_MEZZANINES; i++)\r\nmemcpy(ff_eeimg[i], ff_eeimg[0], sizeof(ff_eeimg[0]));\r\nif (ff_nr_eeprom > ff_nr_dev)\r\nff_nr_dev = ff_nr_eeprom;\r\nff = ff_dev_create();\r\nif (IS_ERR(ff))\r\nreturn PTR_ERR(ff);\r\nfor (i = 0; i < ff_nr_eeprom; i++) {\r\nif (!strlen(ff_eeprom[i]))\r\ncontinue;\r\nret = request_firmware(&fw, ff_eeprom[i], &ff->dev);\r\nif (ret < 0) {\r\ndev_err(&ff->dev, "Mezzanine %i: can't load \"%s\" "\r\n"(error %i)\n", i, ff_eeprom[i], -ret);\r\n} else {\r\nlen = min_t(size_t, fw->size, (size_t)FF_EEPROM_SIZE);\r\nmemcpy(ff_eeimg[i], fw->data, len);\r\nrelease_firmware(fw);\r\ndev_info(&ff->dev, "Mezzanine %i: eeprom \"%s\"\n", i,\r\nff_eeprom[i]);\r\n}\r\n}\r\nret = fmc_device_register_n(ff->fmc, ff_nr_dev);\r\nif (ret) {\r\ndevice_unregister(&ff->dev);\r\nreturn ret;\r\n}\r\nff_current_dev = ff;\r\nreturn ret;\r\n}\r\nstatic void ff_exit(void)\r\n{\r\nif (ff_current_dev) {\r\nfmc_device_unregister_n(ff_current_dev->fmc, ff_nr_dev);\r\ndevice_unregister(&ff_current_dev->dev);\r\n}\r\ncancel_delayed_work_sync(&ff_work);\r\n}
