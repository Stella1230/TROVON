void\r\nnv04_fifo_dma_object_dtor(struct nvkm_fifo_chan *base, int cookie)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nstruct nvkm_instmem *imem = chan->fifo->base.engine.subdev.device->imem;\r\nmutex_lock(&chan->fifo->base.engine.subdev.mutex);\r\nnvkm_ramht_remove(imem->ramht, cookie);\r\nmutex_unlock(&chan->fifo->base.engine.subdev.mutex);\r\n}\r\nstatic int\r\nnv04_fifo_dma_object_ctor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_object *object)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nstruct nvkm_instmem *imem = chan->fifo->base.engine.subdev.device->imem;\r\nu32 context = 0x80000000 | chan->base.chid << 24;\r\nu32 handle = object->handle;\r\nint hash;\r\nswitch (object->engine->subdev.index) {\r\ncase NVKM_ENGINE_DMAOBJ:\r\ncase NVKM_ENGINE_SW : context |= 0x00000000; break;\r\ncase NVKM_ENGINE_GR : context |= 0x00010000; break;\r\ncase NVKM_ENGINE_MPEG : context |= 0x00020000; break;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&chan->fifo->base.engine.subdev.mutex);\r\nhash = nvkm_ramht_insert(imem->ramht, object, chan->base.chid, 4,\r\nhandle, context);\r\nmutex_unlock(&chan->fifo->base.engine.subdev.mutex);\r\nreturn hash;\r\n}\r\nvoid\r\nnv04_fifo_dma_fini(struct nvkm_fifo_chan *base)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nstruct nv04_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nstruct nvkm_memory *fctx = device->imem->ramfc;\r\nconst struct nv04_fifo_ramfc *c;\r\nunsigned long flags;\r\nu32 mask = fifo->base.nr - 1;\r\nu32 data = chan->ramfc;\r\nu32 chid;\r\nspin_lock_irqsave(&fifo->base.lock, flags);\r\nnvkm_wr32(device, NV03_PFIFO_CACHES, 0);\r\nchid = nvkm_rd32(device, NV03_PFIFO_CACHE1_PUSH1) & mask;\r\nif (chid == chan->base.chid) {\r\nnvkm_mask(device, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);\r\nnvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0, 0);\r\nnvkm_mask(device, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);\r\nc = fifo->ramfc;\r\ndo {\r\nu32 rm = ((1ULL << c->bits) - 1) << c->regs;\r\nu32 cm = ((1ULL << c->bits) - 1) << c->ctxs;\r\nu32 rv = (nvkm_rd32(device, c->regp) & rm) >> c->regs;\r\nu32 cv = (nvkm_ro32(fctx, c->ctxp + data) & ~cm);\r\nnvkm_wo32(fctx, c->ctxp + data, cv | (rv << c->ctxs));\r\n} while ((++c)->bits);\r\nc = fifo->ramfc;\r\ndo {\r\nnvkm_wr32(device, c->regp, 0x00000000);\r\n} while ((++c)->bits);\r\nnvkm_wr32(device, NV03_PFIFO_CACHE1_GET, 0);\r\nnvkm_wr32(device, NV03_PFIFO_CACHE1_PUT, 0);\r\nnvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH1, mask);\r\nnvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0, 1);\r\nnvkm_wr32(device, NV04_PFIFO_CACHE1_PULL0, 1);\r\n}\r\nnvkm_mask(device, NV04_PFIFO_MODE, 1 << chan->base.chid, 0);\r\nnvkm_wr32(device, NV03_PFIFO_CACHES, 1);\r\nspin_unlock_irqrestore(&fifo->base.lock, flags);\r\n}\r\nvoid\r\nnv04_fifo_dma_init(struct nvkm_fifo_chan *base)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nstruct nv04_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nu32 mask = 1 << chan->base.chid;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fifo->base.lock, flags);\r\nnvkm_mask(device, NV04_PFIFO_MODE, mask, mask);\r\nspin_unlock_irqrestore(&fifo->base.lock, flags);\r\n}\r\nvoid *\r\nnv04_fifo_dma_dtor(struct nvkm_fifo_chan *base)\r\n{\r\nstruct nv04_fifo_chan *chan = nv04_fifo_chan(base);\r\nstruct nv04_fifo *fifo = chan->fifo;\r\nstruct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;\r\nconst struct nv04_fifo_ramfc *c = fifo->ramfc;\r\nnvkm_kmap(imem->ramfc);\r\ndo {\r\nnvkm_wo32(imem->ramfc, chan->ramfc + c->ctxp, 0x00000000);\r\n} while ((++c)->bits);\r\nnvkm_done(imem->ramfc);\r\nreturn chan;\r\n}\r\nstatic int\r\nnv04_fifo_dma_new(struct nvkm_fifo *base, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nstruct nvkm_object *parent = oclass->parent;\r\nunion {\r\nstruct nv03_channel_dma_v0 v0;\r\n} *args = data;\r\nstruct nv04_fifo *fifo = nv04_fifo(base);\r\nstruct nv04_fifo_chan *chan = NULL;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nstruct nvkm_instmem *imem = device->imem;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(parent, "create channel dma size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(parent, "create channel dma vers %d pushbuf %llx "\r\n"offset %08x\n", args->v0.version,\r\nargs->v0.pushbuf, args->v0.offset);\r\nif (!args->v0.pushbuf)\r\nreturn -EINVAL;\r\n} else\r\nreturn ret;\r\nif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &chan->base.object;\r\nret = nvkm_fifo_chan_ctor(&nv04_fifo_dma_func, &fifo->base,\r\n0x1000, 0x1000, false, 0, args->v0.pushbuf,\r\n(1ULL << NVKM_ENGINE_DMAOBJ) |\r\n(1ULL << NVKM_ENGINE_GR) |\r\n(1ULL << NVKM_ENGINE_SW),\r\n0, 0x800000, 0x10000, oclass, &chan->base);\r\nchan->fifo = fifo;\r\nif (ret)\r\nreturn ret;\r\nargs->v0.chid = chan->base.chid;\r\nchan->ramfc = chan->base.chid * 32;\r\nnvkm_kmap(imem->ramfc);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x00, args->v0.offset);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x04, args->v0.offset);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x08, chan->base.push->addr >> 4);\r\nnvkm_wo32(imem->ramfc, chan->ramfc + 0x10,\r\nNV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |\r\nNV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |\r\n#ifdef __BIG_ENDIAN\r\nNV_PFIFO_CACHE1_BIG_ENDIAN |\r\n#endif\r\nNV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);\r\nnvkm_done(imem->ramfc);\r\nreturn 0;\r\n}
