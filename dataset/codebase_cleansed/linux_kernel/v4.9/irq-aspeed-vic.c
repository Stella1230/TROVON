static void vic_init_hw(struct aspeed_vic *vic)\r\n{\r\nu32 sense;\r\nwritel(0xffffffff, vic->base + AVIC_INT_ENABLE_CLR);\r\nwritel(0xffffffff, vic->base + AVIC_INT_ENABLE_CLR + 4);\r\nwritel(0xffffffff, vic->base + AVIC_INT_TRIGGER_CLR);\r\nwritel(0xffffffff, vic->base + AVIC_INT_TRIGGER_CLR + 4);\r\nwritel(0, vic->base + AVIC_INT_SELECT);\r\nwritel(0, vic->base + AVIC_INT_SELECT + 4);\r\nsense = readl(vic->base + AVIC_INT_SENSE);\r\nvic->edge_sources[0] = ~sense;\r\nsense = readl(vic->base + AVIC_INT_SENSE + 4);\r\nvic->edge_sources[1] = ~sense;\r\nwritel(0xffffffff, vic->base + AVIC_EDGE_CLR);\r\nwritel(0xffffffff, vic->base + AVIC_EDGE_CLR + 4);\r\n}\r\nstatic void __exception_irq_entry avic_handle_irq(struct pt_regs *regs)\r\n{\r\nstruct aspeed_vic *vic = system_avic;\r\nu32 stat, irq;\r\nfor (;;) {\r\nirq = 0;\r\nstat = readl_relaxed(vic->base + AVIC_IRQ_STATUS);\r\nif (!stat) {\r\nstat = readl_relaxed(vic->base + AVIC_IRQ_STATUS + 4);\r\nirq = 32;\r\n}\r\nif (stat == 0)\r\nbreak;\r\nirq += ffs(stat) - 1;\r\nhandle_domain_irq(vic->dom, irq, regs);\r\n}\r\n}\r\nstatic void avic_ack_irq(struct irq_data *d)\r\n{\r\nstruct aspeed_vic *vic = irq_data_get_irq_chip_data(d);\r\nunsigned int sidx = d->hwirq >> 5;\r\nunsigned int sbit = 1u << (d->hwirq & 0x1f);\r\nif (vic->edge_sources[sidx] & sbit)\r\nwritel(sbit, vic->base + AVIC_EDGE_CLR + sidx * 4);\r\n}\r\nstatic void avic_mask_irq(struct irq_data *d)\r\n{\r\nstruct aspeed_vic *vic = irq_data_get_irq_chip_data(d);\r\nunsigned int sidx = d->hwirq >> 5;\r\nunsigned int sbit = 1u << (d->hwirq & 0x1f);\r\nwritel(sbit, vic->base + AVIC_INT_ENABLE_CLR + sidx * 4);\r\n}\r\nstatic void avic_unmask_irq(struct irq_data *d)\r\n{\r\nstruct aspeed_vic *vic = irq_data_get_irq_chip_data(d);\r\nunsigned int sidx = d->hwirq >> 5;\r\nunsigned int sbit = 1u << (d->hwirq & 0x1f);\r\nwritel(sbit, vic->base + AVIC_INT_ENABLE + sidx * 4);\r\n}\r\nstatic void avic_mask_ack_irq(struct irq_data *d)\r\n{\r\nstruct aspeed_vic *vic = irq_data_get_irq_chip_data(d);\r\nunsigned int sidx = d->hwirq >> 5;\r\nunsigned int sbit = 1u << (d->hwirq & 0x1f);\r\nwritel(sbit, vic->base + AVIC_INT_ENABLE_CLR + sidx * 4);\r\nif (vic->edge_sources[sidx] & sbit)\r\nwritel(sbit, vic->base + AVIC_EDGE_CLR + sidx * 4);\r\n}\r\nstatic int avic_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct aspeed_vic *vic = d->host_data;\r\nunsigned int sidx = hwirq >> 5;\r\nunsigned int sbit = 1u << (hwirq & 0x1f);\r\nif (sidx > 1)\r\nreturn -EPERM;\r\nif (vic->edge_sources[sidx] & sbit)\r\nirq_set_chip_and_handler(irq, &avic_chip, handle_edge_irq);\r\nelse\r\nirq_set_chip_and_handler(irq, &avic_chip, handle_level_irq);\r\nirq_set_chip_data(irq, vic);\r\nirq_set_probe(irq);\r\nreturn 0;\r\n}\r\nstatic int __init avic_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nvoid __iomem *regs;\r\nstruct aspeed_vic *vic;\r\nif (WARN(parent, "non-root Aspeed VIC not supported"))\r\nreturn -EINVAL;\r\nif (WARN(system_avic, "duplicate Aspeed VIC not supported"))\r\nreturn -EINVAL;\r\nregs = of_iomap(node, 0);\r\nif (WARN_ON(!regs))\r\nreturn -EIO;\r\nvic = kzalloc(sizeof(struct aspeed_vic), GFP_KERNEL);\r\nif (WARN_ON(!vic)) {\r\niounmap(regs);\r\nreturn -ENOMEM;\r\n}\r\nvic->base = regs;\r\nvic_init_hw(vic);\r\nsystem_avic = vic;\r\nset_handle_irq(avic_handle_irq);\r\nvic->dom = irq_domain_add_simple(node, NUM_IRQS, 0,\r\n&avic_dom_ops, vic);\r\nreturn 0;\r\n}
