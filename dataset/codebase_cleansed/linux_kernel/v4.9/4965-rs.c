static int\r\nil4965_hwrate_to_plcp_idx(u32 rate_n_flags)\r\n{\r\nint idx = 0;\r\nif (rate_n_flags & RATE_MCS_HT_MSK) {\r\nidx = (rate_n_flags & 0xff);\r\nif (idx >= RATE_MIMO2_6M_PLCP)\r\nidx = idx - RATE_MIMO2_6M_PLCP;\r\nidx += IL_FIRST_OFDM_RATE;\r\nif (idx >= RATE_9M_IDX)\r\nidx += 1;\r\nif (idx >= IL_FIRST_OFDM_RATE && idx <= IL_LAST_OFDM_RATE)\r\nreturn idx;\r\n} else {\r\nfor (idx = 0; idx < ARRAY_SIZE(il_rates); idx++)\r\nif (il_rates[idx].plcp == (rate_n_flags & 0xFF))\r\nreturn idx;\r\n}\r\nreturn -1;\r\n}\r\nstatic void\r\nil4965_rs_dbgfs_set_mcs(struct il_lq_sta *lq_sta, u32 * rate_n_flags, int idx)\r\n{\r\n}\r\nstatic inline u8\r\nil4965_rs_extract_rate(u32 rate_n_flags)\r\n{\r\nreturn (u8) (rate_n_flags & 0xFF);\r\n}\r\nstatic void\r\nil4965_rs_rate_scale_clear_win(struct il_rate_scale_data *win)\r\n{\r\nwin->data = 0;\r\nwin->success_counter = 0;\r\nwin->success_ratio = IL_INVALID_VALUE;\r\nwin->counter = 0;\r\nwin->average_tpt = IL_INVALID_VALUE;\r\nwin->stamp = 0;\r\n}\r\nstatic inline u8\r\nil4965_rs_is_valid_ant(u8 valid_antenna, u8 ant_type)\r\n{\r\nreturn (ant_type & valid_antenna) == ant_type;\r\n}\r\nstatic void\r\nil4965_rs_tl_rm_old_stats(struct il_traffic_load *tl, u32 curr_time)\r\n{\r\nu32 oldest_time = curr_time - TID_MAX_TIME_DIFF;\r\nwhile (tl->queue_count && tl->time_stamp < oldest_time) {\r\ntl->total -= tl->packet_count[tl->head];\r\ntl->packet_count[tl->head] = 0;\r\ntl->time_stamp += TID_QUEUE_CELL_SPACING;\r\ntl->queue_count--;\r\ntl->head++;\r\nif (tl->head >= TID_QUEUE_MAX_SIZE)\r\ntl->head = 0;\r\n}\r\n}\r\nstatic u8\r\nil4965_rs_tl_add_packet(struct il_lq_sta *lq_data, struct ieee80211_hdr *hdr)\r\n{\r\nu32 curr_time = jiffies_to_msecs(jiffies);\r\nu32 time_diff;\r\ns32 idx;\r\nstruct il_traffic_load *tl = NULL;\r\nu8 tid;\r\nif (ieee80211_is_data_qos(hdr->frame_control)) {\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & 0xf;\r\n} else\r\nreturn MAX_TID_COUNT;\r\nif (unlikely(tid >= TID_MAX_LOAD_COUNT))\r\nreturn MAX_TID_COUNT;\r\ntl = &lq_data->load[tid];\r\ncurr_time -= curr_time % TID_ROUND_VALUE;\r\nif (!(tl->queue_count)) {\r\ntl->total = 1;\r\ntl->time_stamp = curr_time;\r\ntl->queue_count = 1;\r\ntl->head = 0;\r\ntl->packet_count[0] = 1;\r\nreturn MAX_TID_COUNT;\r\n}\r\ntime_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);\r\nidx = time_diff / TID_QUEUE_CELL_SPACING;\r\nif (idx >= TID_QUEUE_MAX_SIZE)\r\nil4965_rs_tl_rm_old_stats(tl, curr_time);\r\nidx = (tl->head + idx) % TID_QUEUE_MAX_SIZE;\r\ntl->packet_count[idx] = tl->packet_count[idx] + 1;\r\ntl->total = tl->total + 1;\r\nif ((idx + 1) > tl->queue_count)\r\ntl->queue_count = idx + 1;\r\nreturn tid;\r\n}\r\nstatic u32\r\nil4965_rs_tl_get_load(struct il_lq_sta *lq_data, u8 tid)\r\n{\r\nu32 curr_time = jiffies_to_msecs(jiffies);\r\nu32 time_diff;\r\ns32 idx;\r\nstruct il_traffic_load *tl = NULL;\r\nif (tid >= TID_MAX_LOAD_COUNT)\r\nreturn 0;\r\ntl = &(lq_data->load[tid]);\r\ncurr_time -= curr_time % TID_ROUND_VALUE;\r\nif (!(tl->queue_count))\r\nreturn 0;\r\ntime_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);\r\nidx = time_diff / TID_QUEUE_CELL_SPACING;\r\nif (idx >= TID_QUEUE_MAX_SIZE)\r\nil4965_rs_tl_rm_old_stats(tl, curr_time);\r\nreturn tl->total;\r\n}\r\nstatic int\r\nil4965_rs_tl_turn_on_agg_for_tid(struct il_priv *il, struct il_lq_sta *lq_data,\r\nu8 tid, struct ieee80211_sta *sta)\r\n{\r\nint ret = -EAGAIN;\r\nu32 load;\r\nload = il4965_rs_tl_get_load(lq_data, tid);\r\nif (load > IL_AGG_LOAD_THRESHOLD) {\r\nD_HT("Starting Tx agg: STA: %pM tid: %d\n", sta->addr, tid);\r\nret = ieee80211_start_tx_ba_session(sta, tid, 5000);\r\nif (ret == -EAGAIN) {\r\nIL_ERR("Fail start Tx agg on tid: %d\n", tid);\r\nieee80211_stop_tx_ba_session(sta, tid);\r\n}\r\n} else\r\nD_HT("Aggregation not enabled for tid %d because load = %u\n",\r\ntid, load);\r\nreturn ret;\r\n}\r\nstatic void\r\nil4965_rs_tl_turn_on_agg(struct il_priv *il, u8 tid, struct il_lq_sta *lq_data,\r\nstruct ieee80211_sta *sta)\r\n{\r\nif (tid < TID_MAX_LOAD_COUNT)\r\nil4965_rs_tl_turn_on_agg_for_tid(il, lq_data, tid, sta);\r\nelse\r\nIL_ERR("tid exceeds max load count: %d/%d\n", tid,\r\nTID_MAX_LOAD_COUNT);\r\n}\r\nstatic inline int\r\nil4965_get_il4965_num_of_ant_from_rate(u32 rate_n_flags)\r\n{\r\nreturn !!(rate_n_flags & RATE_MCS_ANT_A_MSK) +\r\n!!(rate_n_flags & RATE_MCS_ANT_B_MSK) +\r\n!!(rate_n_flags & RATE_MCS_ANT_C_MSK);\r\n}\r\nstatic s32\r\nil4965_get_expected_tpt(struct il_scale_tbl_info *tbl, int rs_idx)\r\n{\r\nif (tbl->expected_tpt)\r\nreturn tbl->expected_tpt[rs_idx];\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_rs_collect_tx_data(struct il_scale_tbl_info *tbl, int scale_idx,\r\nint attempts, int successes)\r\n{\r\nstruct il_rate_scale_data *win = NULL;\r\nstatic const u64 mask = (((u64) 1) << (RATE_MAX_WINDOW - 1));\r\ns32 fail_count, tpt;\r\nif (scale_idx < 0 || scale_idx >= RATE_COUNT)\r\nreturn -EINVAL;\r\nwin = &(tbl->win[scale_idx]);\r\ntpt = il4965_get_expected_tpt(tbl, scale_idx);\r\nwhile (attempts > 0) {\r\nif (win->counter >= RATE_MAX_WINDOW) {\r\nwin->counter = RATE_MAX_WINDOW - 1;\r\nif (win->data & mask) {\r\nwin->data &= ~mask;\r\nwin->success_counter--;\r\n}\r\n}\r\nwin->counter++;\r\nwin->data <<= 1;\r\nif (successes > 0) {\r\nwin->success_counter++;\r\nwin->data |= 0x1;\r\nsuccesses--;\r\n}\r\nattempts--;\r\n}\r\nif (win->counter > 0)\r\nwin->success_ratio =\r\n128 * (100 * win->success_counter) / win->counter;\r\nelse\r\nwin->success_ratio = IL_INVALID_VALUE;\r\nfail_count = win->counter - win->success_counter;\r\nif (fail_count >= RATE_MIN_FAILURE_TH ||\r\nwin->success_counter >= RATE_MIN_SUCCESS_TH)\r\nwin->average_tpt = (win->success_ratio * tpt + 64) / 128;\r\nelse\r\nwin->average_tpt = IL_INVALID_VALUE;\r\nwin->stamp = jiffies;\r\nreturn 0;\r\n}\r\nstatic u32\r\nil4965_rate_n_flags_from_tbl(struct il_priv *il, struct il_scale_tbl_info *tbl,\r\nint idx, u8 use_green)\r\n{\r\nu32 rate_n_flags = 0;\r\nif (is_legacy(tbl->lq_type)) {\r\nrate_n_flags = il_rates[idx].plcp;\r\nif (idx >= IL_FIRST_CCK_RATE && idx <= IL_LAST_CCK_RATE)\r\nrate_n_flags |= RATE_MCS_CCK_MSK;\r\n} else if (is_Ht(tbl->lq_type)) {\r\nif (idx > IL_LAST_OFDM_RATE) {\r\nIL_ERR("Invalid HT rate idx %d\n", idx);\r\nidx = IL_LAST_OFDM_RATE;\r\n}\r\nrate_n_flags = RATE_MCS_HT_MSK;\r\nif (is_siso(tbl->lq_type))\r\nrate_n_flags |= il_rates[idx].plcp_siso;\r\nelse\r\nrate_n_flags |= il_rates[idx].plcp_mimo2;\r\n} else {\r\nIL_ERR("Invalid tbl->lq_type %d\n", tbl->lq_type);\r\n}\r\nrate_n_flags |=\r\n((tbl->ant_type << RATE_MCS_ANT_POS) & RATE_MCS_ANT_ABC_MSK);\r\nif (is_Ht(tbl->lq_type)) {\r\nif (tbl->is_ht40) {\r\nif (tbl->is_dup)\r\nrate_n_flags |= RATE_MCS_DUP_MSK;\r\nelse\r\nrate_n_flags |= RATE_MCS_HT40_MSK;\r\n}\r\nif (tbl->is_SGI)\r\nrate_n_flags |= RATE_MCS_SGI_MSK;\r\nif (use_green) {\r\nrate_n_flags |= RATE_MCS_GF_MSK;\r\nif (is_siso(tbl->lq_type) && tbl->is_SGI) {\r\nrate_n_flags &= ~RATE_MCS_SGI_MSK;\r\nIL_ERR("GF was set with SGI:SISO\n");\r\n}\r\n}\r\n}\r\nreturn rate_n_flags;\r\n}\r\nstatic int\r\nil4965_rs_get_tbl_info_from_mcs(const u32 rate_n_flags,\r\nenum nl80211_band band,\r\nstruct il_scale_tbl_info *tbl, int *rate_idx)\r\n{\r\nu32 ant_msk = (rate_n_flags & RATE_MCS_ANT_ABC_MSK);\r\nu8 il4965_num_of_ant =\r\nil4965_get_il4965_num_of_ant_from_rate(rate_n_flags);\r\nu8 mcs;\r\nmemset(tbl, 0, sizeof(struct il_scale_tbl_info));\r\n*rate_idx = il4965_hwrate_to_plcp_idx(rate_n_flags);\r\nif (*rate_idx == RATE_INVALID) {\r\n*rate_idx = -1;\r\nreturn -EINVAL;\r\n}\r\ntbl->is_SGI = 0;\r\ntbl->is_ht40 = 0;\r\ntbl->is_dup = 0;\r\ntbl->ant_type = (ant_msk >> RATE_MCS_ANT_POS);\r\ntbl->lq_type = LQ_NONE;\r\ntbl->max_search = IL_MAX_SEARCH;\r\nif (!(rate_n_flags & RATE_MCS_HT_MSK)) {\r\nif (il4965_num_of_ant == 1) {\r\nif (band == NL80211_BAND_5GHZ)\r\ntbl->lq_type = LQ_A;\r\nelse\r\ntbl->lq_type = LQ_G;\r\n}\r\n} else {\r\nif (rate_n_flags & RATE_MCS_SGI_MSK)\r\ntbl->is_SGI = 1;\r\nif ((rate_n_flags & RATE_MCS_HT40_MSK) ||\r\n(rate_n_flags & RATE_MCS_DUP_MSK))\r\ntbl->is_ht40 = 1;\r\nif (rate_n_flags & RATE_MCS_DUP_MSK)\r\ntbl->is_dup = 1;\r\nmcs = il4965_rs_extract_rate(rate_n_flags);\r\nif (mcs <= RATE_SISO_60M_PLCP) {\r\nif (il4965_num_of_ant == 1)\r\ntbl->lq_type = LQ_SISO;\r\n} else {\r\nif (il4965_num_of_ant == 2)\r\ntbl->lq_type = LQ_MIMO2;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_rs_toggle_antenna(u32 valid_ant, u32 *rate_n_flags,\r\nstruct il_scale_tbl_info *tbl)\r\n{\r\nu8 new_ant_type;\r\nif (!tbl->ant_type || tbl->ant_type > ANT_ABC)\r\nreturn 0;\r\nif (!il4965_rs_is_valid_ant(valid_ant, tbl->ant_type))\r\nreturn 0;\r\nnew_ant_type = ant_toggle_lookup[tbl->ant_type];\r\nwhile (new_ant_type != tbl->ant_type &&\r\n!il4965_rs_is_valid_ant(valid_ant, new_ant_type))\r\nnew_ant_type = ant_toggle_lookup[new_ant_type];\r\nif (new_ant_type == tbl->ant_type)\r\nreturn 0;\r\ntbl->ant_type = new_ant_type;\r\n*rate_n_flags &= ~RATE_MCS_ANT_ABC_MSK;\r\n*rate_n_flags |= new_ant_type << RATE_MCS_ANT_POS;\r\nreturn 1;\r\n}\r\nstatic bool\r\nil4965_rs_use_green(struct il_priv *il, struct ieee80211_sta *sta)\r\n{\r\nreturn (sta->ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD) &&\r\n!il->ht.non_gf_sta_present;\r\n}\r\nstatic u16\r\nil4965_rs_get_supported_rates(struct il_lq_sta *lq_sta,\r\nstruct ieee80211_hdr *hdr,\r\nenum il_table_type rate_type)\r\n{\r\nif (is_legacy(rate_type)) {\r\nreturn lq_sta->active_legacy_rate;\r\n} else {\r\nif (is_siso(rate_type))\r\nreturn lq_sta->active_siso_rate;\r\nelse\r\nreturn lq_sta->active_mimo2_rate;\r\n}\r\n}\r\nstatic u16\r\nil4965_rs_get_adjacent_rate(struct il_priv *il, u8 idx, u16 rate_mask,\r\nint rate_type)\r\n{\r\nu8 high = RATE_INVALID;\r\nu8 low = RATE_INVALID;\r\nif (is_a_band(rate_type) || !is_legacy(rate_type)) {\r\nint i;\r\nu32 mask;\r\ni = idx - 1;\r\nfor (mask = (1 << i); i >= 0; i--, mask >>= 1) {\r\nif (rate_mask & mask) {\r\nlow = i;\r\nbreak;\r\n}\r\n}\r\ni = idx + 1;\r\nfor (mask = (1 << i); i < RATE_COUNT; i++, mask <<= 1) {\r\nif (rate_mask & mask) {\r\nhigh = i;\r\nbreak;\r\n}\r\n}\r\nreturn (high << 8) | low;\r\n}\r\nlow = idx;\r\nwhile (low != RATE_INVALID) {\r\nlow = il_rates[low].prev_rs;\r\nif (low == RATE_INVALID)\r\nbreak;\r\nif (rate_mask & (1 << low))\r\nbreak;\r\nD_RATE("Skipping masked lower rate: %d\n", low);\r\n}\r\nhigh = idx;\r\nwhile (high != RATE_INVALID) {\r\nhigh = il_rates[high].next_rs;\r\nif (high == RATE_INVALID)\r\nbreak;\r\nif (rate_mask & (1 << high))\r\nbreak;\r\nD_RATE("Skipping masked higher rate: %d\n", high);\r\n}\r\nreturn (high << 8) | low;\r\n}\r\nstatic u32\r\nil4965_rs_get_lower_rate(struct il_lq_sta *lq_sta,\r\nstruct il_scale_tbl_info *tbl, u8 scale_idx,\r\nu8 ht_possible)\r\n{\r\ns32 low;\r\nu16 rate_mask;\r\nu16 high_low;\r\nu8 switch_to_legacy = 0;\r\nu8 is_green = lq_sta->is_green;\r\nstruct il_priv *il = lq_sta->drv;\r\nif (!is_legacy(tbl->lq_type) && (!ht_possible || !scale_idx)) {\r\nswitch_to_legacy = 1;\r\nscale_idx = rs_ht_to_legacy[scale_idx];\r\nif (lq_sta->band == NL80211_BAND_5GHZ)\r\ntbl->lq_type = LQ_A;\r\nelse\r\ntbl->lq_type = LQ_G;\r\nif (il4965_num_of_ant(tbl->ant_type) > 1)\r\ntbl->ant_type =\r\nil4965_first_antenna(il->hw_params.valid_tx_ant);\r\ntbl->is_ht40 = 0;\r\ntbl->is_SGI = 0;\r\ntbl->max_search = IL_MAX_SEARCH;\r\n}\r\nrate_mask = il4965_rs_get_supported_rates(lq_sta, NULL, tbl->lq_type);\r\nif (is_legacy(tbl->lq_type)) {\r\nif (lq_sta->band == NL80211_BAND_5GHZ)\r\nrate_mask =\r\n(u16) (rate_mask &\r\n(lq_sta->supp_rates << IL_FIRST_OFDM_RATE));\r\nelse\r\nrate_mask = (u16) (rate_mask & lq_sta->supp_rates);\r\n}\r\nif (switch_to_legacy && (rate_mask & (1 << scale_idx))) {\r\nlow = scale_idx;\r\ngoto out;\r\n}\r\nhigh_low =\r\nil4965_rs_get_adjacent_rate(lq_sta->drv, scale_idx, rate_mask,\r\ntbl->lq_type);\r\nlow = high_low & 0xff;\r\nif (low == RATE_INVALID)\r\nlow = scale_idx;\r\nout:\r\nreturn il4965_rate_n_flags_from_tbl(lq_sta->drv, tbl, low, is_green);\r\n}\r\nstatic bool\r\nil4965_table_type_matches(struct il_scale_tbl_info *a,\r\nstruct il_scale_tbl_info *b)\r\n{\r\nreturn (a->lq_type == b->lq_type && a->ant_type == b->ant_type &&\r\na->is_SGI == b->is_SGI);\r\n}\r\nstatic void\r\nil4965_rs_tx_status(void *il_r, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *il_sta,\r\nstruct sk_buff *skb)\r\n{\r\nint legacy_success;\r\nint retries;\r\nint rs_idx, mac_idx, i;\r\nstruct il_lq_sta *lq_sta = il_sta;\r\nstruct il_link_quality_cmd *table;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct il_priv *il = (struct il_priv *)il_r;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nenum mac80211_rate_control_flags mac_flags;\r\nu32 tx_rate;\r\nstruct il_scale_tbl_info tbl_type;\r\nstruct il_scale_tbl_info *curr_tbl, *other_tbl, *tmp_tbl;\r\nD_RATE("get frame ack response, update rate scale win\n");\r\nif (!lq_sta) {\r\nD_RATE("Station rate scaling not created yet.\n");\r\nreturn;\r\n} else if (!lq_sta->drv) {\r\nD_RATE("Rate scaling not initialized yet.\n");\r\nreturn;\r\n}\r\nif (!ieee80211_is_data(hdr->frame_control) ||\r\n(info->flags & IEEE80211_TX_CTL_NO_ACK))\r\nreturn;\r\nif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n!(info->flags & IEEE80211_TX_STAT_AMPDU))\r\nreturn;\r\ntable = &lq_sta->lq;\r\ntx_rate = le32_to_cpu(table->rs_table[0].rate_n_flags);\r\nil4965_rs_get_tbl_info_from_mcs(tx_rate, il->band, &tbl_type, &rs_idx);\r\nif (il->band == NL80211_BAND_5GHZ)\r\nrs_idx -= IL_FIRST_OFDM_RATE;\r\nmac_flags = info->status.rates[0].flags;\r\nmac_idx = info->status.rates[0].idx;\r\nif (mac_flags & IEEE80211_TX_RC_MCS) {\r\nmac_idx &= RATE_MCS_CODE_MSK;\r\nif (mac_idx >= (RATE_9M_IDX - IL_FIRST_OFDM_RATE))\r\nmac_idx++;\r\nif (il->band == NL80211_BAND_2GHZ)\r\nmac_idx += IL_FIRST_OFDM_RATE;\r\n}\r\nif (mac_idx < 0 ||\r\ntbl_type.is_SGI != !!(mac_flags & IEEE80211_TX_RC_SHORT_GI) ||\r\ntbl_type.is_ht40 != !!(mac_flags & IEEE80211_TX_RC_40_MHZ_WIDTH) ||\r\ntbl_type.is_dup != !!(mac_flags & IEEE80211_TX_RC_DUP_DATA) ||\r\ntbl_type.ant_type != info->status.antenna ||\r\n!!(tx_rate & RATE_MCS_HT_MSK) != !!(mac_flags & IEEE80211_TX_RC_MCS)\r\n|| !!(tx_rate & RATE_MCS_GF_MSK) !=\r\n!!(mac_flags & IEEE80211_TX_RC_GREEN_FIELD) || rs_idx != mac_idx) {\r\nD_RATE("initial rate %d does not match %d (0x%x)\n", mac_idx,\r\nrs_idx, tx_rate);\r\nlq_sta->missed_rate_counter++;\r\nif (lq_sta->missed_rate_counter > IL_MISSED_RATE_MAX) {\r\nlq_sta->missed_rate_counter = 0;\r\nil_send_lq_cmd(il, &lq_sta->lq, CMD_ASYNC, false);\r\n}\r\nreturn;\r\n} else\r\nlq_sta->missed_rate_counter = 0;\r\nif (il4965_table_type_matches\r\n(&tbl_type, &(lq_sta->lq_info[lq_sta->active_tbl]))) {\r\ncurr_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nother_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\r\n} else\r\nif (il4965_table_type_matches\r\n(&tbl_type, &lq_sta->lq_info[1 - lq_sta->active_tbl])) {\r\ncurr_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\r\nother_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\n} else {\r\nD_RATE("Neither active nor search matches tx rate\n");\r\ntmp_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nD_RATE("active- lq:%x, ant:%x, SGI:%d\n", tmp_tbl->lq_type,\r\ntmp_tbl->ant_type, tmp_tbl->is_SGI);\r\ntmp_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\r\nD_RATE("search- lq:%x, ant:%x, SGI:%d\n", tmp_tbl->lq_type,\r\ntmp_tbl->ant_type, tmp_tbl->is_SGI);\r\nD_RATE("actual- lq:%x, ant:%x, SGI:%d\n", tbl_type.lq_type,\r\ntbl_type.ant_type, tbl_type.is_SGI);\r\nil4965_rs_stay_in_table(lq_sta, true);\r\ngoto done;\r\n}\r\nif (info->flags & IEEE80211_TX_STAT_AMPDU) {\r\ntx_rate = le32_to_cpu(table->rs_table[0].rate_n_flags);\r\nil4965_rs_get_tbl_info_from_mcs(tx_rate, il->band, &tbl_type,\r\n&rs_idx);\r\nil4965_rs_collect_tx_data(curr_tbl, rs_idx,\r\ninfo->status.ampdu_len,\r\ninfo->status.ampdu_ack_len);\r\nif (lq_sta->stay_in_tbl) {\r\nlq_sta->total_success += info->status.ampdu_ack_len;\r\nlq_sta->total_failed +=\r\n(info->status.ampdu_len -\r\ninfo->status.ampdu_ack_len);\r\n}\r\n} else {\r\nretries = info->status.rates[0].count - 1;\r\nretries = min(retries, 15);\r\nlegacy_success = !!(info->flags & IEEE80211_TX_STAT_ACK);\r\nfor (i = 0; i <= retries; ++i) {\r\ntx_rate = le32_to_cpu(table->rs_table[i].rate_n_flags);\r\nil4965_rs_get_tbl_info_from_mcs(tx_rate, il->band,\r\n&tbl_type, &rs_idx);\r\nif (il4965_table_type_matches(&tbl_type, curr_tbl))\r\ntmp_tbl = curr_tbl;\r\nelse if (il4965_table_type_matches\r\n(&tbl_type, other_tbl))\r\ntmp_tbl = other_tbl;\r\nelse\r\ncontinue;\r\nil4965_rs_collect_tx_data(tmp_tbl, rs_idx, 1,\r\ni <\r\nretries ? 0 : legacy_success);\r\n}\r\nif (lq_sta->stay_in_tbl) {\r\nlq_sta->total_success += legacy_success;\r\nlq_sta->total_failed += retries + (1 - legacy_success);\r\n}\r\n}\r\nlq_sta->last_rate_n_flags = tx_rate;\r\ndone:\r\nif (sta->supp_rates[sband->band])\r\nil4965_rs_rate_scale_perform(il, skb, sta, lq_sta);\r\n}\r\nstatic void\r\nil4965_rs_set_stay_in_table(struct il_priv *il, u8 is_legacy,\r\nstruct il_lq_sta *lq_sta)\r\n{\r\nD_RATE("we are staying in the same table\n");\r\nlq_sta->stay_in_tbl = 1;\r\nif (is_legacy) {\r\nlq_sta->table_count_limit = IL_LEGACY_TBL_COUNT;\r\nlq_sta->max_failure_limit = IL_LEGACY_FAILURE_LIMIT;\r\nlq_sta->max_success_limit = IL_LEGACY_SUCCESS_LIMIT;\r\n} else {\r\nlq_sta->table_count_limit = IL_NONE_LEGACY_TBL_COUNT;\r\nlq_sta->max_failure_limit = IL_NONE_LEGACY_FAILURE_LIMIT;\r\nlq_sta->max_success_limit = IL_NONE_LEGACY_SUCCESS_LIMIT;\r\n}\r\nlq_sta->table_count = 0;\r\nlq_sta->total_failed = 0;\r\nlq_sta->total_success = 0;\r\nlq_sta->flush_timer = jiffies;\r\nlq_sta->action_counter = 0;\r\n}\r\nstatic void\r\nil4965_rs_set_expected_tpt_table(struct il_lq_sta *lq_sta,\r\nstruct il_scale_tbl_info *tbl)\r\n{\r\ns32(*ht_tbl_pointer)[RATE_COUNT];\r\nif (WARN_ON_ONCE(!is_legacy(tbl->lq_type) && !is_Ht(tbl->lq_type))) {\r\ntbl->expected_tpt = expected_tpt_legacy;\r\nreturn;\r\n}\r\nif (is_legacy(tbl->lq_type)) {\r\ntbl->expected_tpt = expected_tpt_legacy;\r\nreturn;\r\n}\r\nif (is_siso(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\r\nht_tbl_pointer = expected_tpt_siso20MHz;\r\nelse if (is_siso(tbl->lq_type))\r\nht_tbl_pointer = expected_tpt_siso40MHz;\r\nelse if (is_mimo2(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\r\nht_tbl_pointer = expected_tpt_mimo2_20MHz;\r\nelse\r\nht_tbl_pointer = expected_tpt_mimo2_40MHz;\r\nif (!tbl->is_SGI && !lq_sta->is_agg)\r\ntbl->expected_tpt = ht_tbl_pointer[0];\r\nelse if (tbl->is_SGI && !lq_sta->is_agg)\r\ntbl->expected_tpt = ht_tbl_pointer[1];\r\nelse if (!tbl->is_SGI && lq_sta->is_agg)\r\ntbl->expected_tpt = ht_tbl_pointer[2];\r\nelse\r\ntbl->expected_tpt = ht_tbl_pointer[3];\r\n}\r\nstatic s32\r\nil4965_rs_get_best_rate(struct il_priv *il, struct il_lq_sta *lq_sta,\r\nstruct il_scale_tbl_info *tbl,\r\nu16 rate_mask, s8 idx)\r\n{\r\nstruct il_scale_tbl_info *active_tbl =\r\n&(lq_sta->lq_info[lq_sta->active_tbl]);\r\ns32 active_sr = active_tbl->win[idx].success_ratio;\r\ns32 active_tpt = active_tbl->expected_tpt[idx];\r\ns32 *tpt_tbl = tbl->expected_tpt;\r\ns32 new_rate, high, low, start_hi;\r\nu16 high_low;\r\ns8 rate = idx;\r\nnew_rate = high = low = start_hi = RATE_INVALID;\r\nfor (;;) {\r\nhigh_low =\r\nil4965_rs_get_adjacent_rate(il, rate, rate_mask,\r\ntbl->lq_type);\r\nlow = high_low & 0xff;\r\nhigh = (high_low >> 8) & 0xff;\r\nif ((100 * tpt_tbl[rate] > lq_sta->last_tpt &&\r\n(active_sr > RATE_DECREASE_TH && active_sr <= RATE_HIGH_TH\r\n&& tpt_tbl[rate] <= active_tpt)) ||\r\n(active_sr >= RATE_SCALE_SWITCH &&\r\ntpt_tbl[rate] > active_tpt)) {\r\nif (start_hi != RATE_INVALID) {\r\nnew_rate = start_hi;\r\nbreak;\r\n}\r\nnew_rate = rate;\r\nif (low != RATE_INVALID)\r\nrate = low;\r\nelse\r\nbreak;\r\n} else {\r\nif (new_rate != RATE_INVALID)\r\nbreak;\r\nelse if (high != RATE_INVALID) {\r\nstart_hi = high;\r\nrate = high;\r\n} else {\r\nnew_rate = rate;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn new_rate;\r\n}\r\nstatic int\r\nil4965_rs_switch_to_mimo2(struct il_priv *il, struct il_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta,\r\nstruct il_scale_tbl_info *tbl, int idx)\r\n{\r\nu16 rate_mask;\r\ns32 rate;\r\ns8 is_green = lq_sta->is_green;\r\nif (!conf_is_ht(conf) || !sta->ht_cap.ht_supported)\r\nreturn -1;\r\nif (sta->smps_mode == IEEE80211_SMPS_STATIC)\r\nreturn -1;\r\nif (il->hw_params.tx_chains_num < 2)\r\nreturn -1;\r\nD_RATE("LQ: try to switch to MIMO2\n");\r\ntbl->lq_type = LQ_MIMO2;\r\ntbl->is_dup = lq_sta->is_dup;\r\ntbl->action = 0;\r\ntbl->max_search = IL_MAX_SEARCH;\r\nrate_mask = lq_sta->active_mimo2_rate;\r\nif (il_is_ht40_tx_allowed(il, &sta->ht_cap))\r\ntbl->is_ht40 = 1;\r\nelse\r\ntbl->is_ht40 = 0;\r\nil4965_rs_set_expected_tpt_table(lq_sta, tbl);\r\nrate = il4965_rs_get_best_rate(il, lq_sta, tbl, rate_mask, idx);\r\nD_RATE("LQ: MIMO2 best rate %d mask %X\n", rate, rate_mask);\r\nif (rate == RATE_INVALID || !((1 << rate) & rate_mask)) {\r\nD_RATE("Can't switch with idx %d rate mask %x\n", rate,\r\nrate_mask);\r\nreturn -1;\r\n}\r\ntbl->current_rate =\r\nil4965_rate_n_flags_from_tbl(il, tbl, rate, is_green);\r\nD_RATE("LQ: Switch to new mcs %X idx is green %X\n", tbl->current_rate,\r\nis_green);\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_rs_switch_to_siso(struct il_priv *il, struct il_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf, struct ieee80211_sta *sta,\r\nstruct il_scale_tbl_info *tbl, int idx)\r\n{\r\nu16 rate_mask;\r\nu8 is_green = lq_sta->is_green;\r\ns32 rate;\r\nif (!conf_is_ht(conf) || !sta->ht_cap.ht_supported)\r\nreturn -1;\r\nD_RATE("LQ: try to switch to SISO\n");\r\ntbl->is_dup = lq_sta->is_dup;\r\ntbl->lq_type = LQ_SISO;\r\ntbl->action = 0;\r\ntbl->max_search = IL_MAX_SEARCH;\r\nrate_mask = lq_sta->active_siso_rate;\r\nif (il_is_ht40_tx_allowed(il, &sta->ht_cap))\r\ntbl->is_ht40 = 1;\r\nelse\r\ntbl->is_ht40 = 0;\r\nif (is_green)\r\ntbl->is_SGI = 0;\r\nil4965_rs_set_expected_tpt_table(lq_sta, tbl);\r\nrate = il4965_rs_get_best_rate(il, lq_sta, tbl, rate_mask, idx);\r\nD_RATE("LQ: get best rate %d mask %X\n", rate, rate_mask);\r\nif (rate == RATE_INVALID || !((1 << rate) & rate_mask)) {\r\nD_RATE("can not switch with idx %d rate mask %x\n", rate,\r\nrate_mask);\r\nreturn -1;\r\n}\r\ntbl->current_rate =\r\nil4965_rate_n_flags_from_tbl(il, tbl, rate, is_green);\r\nD_RATE("LQ: Switch to new mcs %X idx is green %X\n", tbl->current_rate,\r\nis_green);\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_rs_move_legacy_other(struct il_priv *il, struct il_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta, int idx)\r\n{\r\nstruct il_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nstruct il_scale_tbl_info *search_tbl =\r\n&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nstruct il_rate_scale_data *win = &(tbl->win[idx]);\r\nu32 sz =\r\n(sizeof(struct il_scale_tbl_info) -\r\n(sizeof(struct il_rate_scale_data) * RATE_COUNT));\r\nu8 start_action;\r\nu8 valid_tx_ant = il->hw_params.valid_tx_ant;\r\nu8 tx_chains_num = il->hw_params.tx_chains_num;\r\nint ret = 0;\r\nu8 update_search_tbl_counter = 0;\r\ntbl->action = IL_LEGACY_SWITCH_SISO;\r\nstart_action = tbl->action;\r\nfor (;;) {\r\nlq_sta->action_counter++;\r\nswitch (tbl->action) {\r\ncase IL_LEGACY_SWITCH_ANTENNA1:\r\ncase IL_LEGACY_SWITCH_ANTENNA2:\r\nD_RATE("LQ: Legacy toggle Antenna\n");\r\nif ((tbl->action == IL_LEGACY_SWITCH_ANTENNA1 &&\r\ntx_chains_num <= 1) ||\r\n(tbl->action == IL_LEGACY_SWITCH_ANTENNA2 &&\r\ntx_chains_num <= 2))\r\nbreak;\r\nif (win->success_ratio >= IL_RS_GOOD_RATIO)\r\nbreak;\r\nmemcpy(search_tbl, tbl, sz);\r\nif (il4965_rs_toggle_antenna\r\n(valid_tx_ant, &search_tbl->current_rate,\r\nsearch_tbl)) {\r\nupdate_search_tbl_counter = 1;\r\nil4965_rs_set_expected_tpt_table(lq_sta,\r\nsearch_tbl);\r\ngoto out;\r\n}\r\nbreak;\r\ncase IL_LEGACY_SWITCH_SISO:\r\nD_RATE("LQ: Legacy switch to SISO\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nret =\r\nil4965_rs_switch_to_siso(il, lq_sta, conf, sta,\r\nsearch_tbl, idx);\r\nif (!ret) {\r\nlq_sta->action_counter = 0;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IL_LEGACY_SWITCH_MIMO2_AB:\r\ncase IL_LEGACY_SWITCH_MIMO2_AC:\r\ncase IL_LEGACY_SWITCH_MIMO2_BC:\r\nD_RATE("LQ: Legacy switch to MIMO2\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nif (tbl->action == IL_LEGACY_SWITCH_MIMO2_AB)\r\nsearch_tbl->ant_type = ANT_AB;\r\nelse if (tbl->action == IL_LEGACY_SWITCH_MIMO2_AC)\r\nsearch_tbl->ant_type = ANT_AC;\r\nelse\r\nsearch_tbl->ant_type = ANT_BC;\r\nif (!il4965_rs_is_valid_ant\r\n(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret =\r\nil4965_rs_switch_to_mimo2(il, lq_sta, conf, sta,\r\nsearch_tbl, idx);\r\nif (!ret) {\r\nlq_sta->action_counter = 0;\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\ntbl->action++;\r\nif (tbl->action > IL_LEGACY_SWITCH_MIMO2_BC)\r\ntbl->action = IL_LEGACY_SWITCH_ANTENNA1;\r\nif (tbl->action == start_action)\r\nbreak;\r\n}\r\nsearch_tbl->lq_type = LQ_NONE;\r\nreturn 0;\r\nout:\r\nlq_sta->search_better_tbl = 1;\r\ntbl->action++;\r\nif (tbl->action > IL_LEGACY_SWITCH_MIMO2_BC)\r\ntbl->action = IL_LEGACY_SWITCH_ANTENNA1;\r\nif (update_search_tbl_counter)\r\nsearch_tbl->action = tbl->action;\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_rs_move_siso_to_other(struct il_priv *il, struct il_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta, int idx)\r\n{\r\nu8 is_green = lq_sta->is_green;\r\nstruct il_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nstruct il_scale_tbl_info *search_tbl =\r\n&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nstruct il_rate_scale_data *win = &(tbl->win[idx]);\r\nstruct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;\r\nu32 sz =\r\n(sizeof(struct il_scale_tbl_info) -\r\n(sizeof(struct il_rate_scale_data) * RATE_COUNT));\r\nu8 start_action;\r\nu8 valid_tx_ant = il->hw_params.valid_tx_ant;\r\nu8 tx_chains_num = il->hw_params.tx_chains_num;\r\nu8 update_search_tbl_counter = 0;\r\nint ret;\r\nstart_action = tbl->action;\r\nfor (;;) {\r\nlq_sta->action_counter++;\r\nswitch (tbl->action) {\r\ncase IL_SISO_SWITCH_ANTENNA1:\r\ncase IL_SISO_SWITCH_ANTENNA2:\r\nD_RATE("LQ: SISO toggle Antenna\n");\r\nif ((tbl->action == IL_SISO_SWITCH_ANTENNA1 &&\r\ntx_chains_num <= 1) ||\r\n(tbl->action == IL_SISO_SWITCH_ANTENNA2 &&\r\ntx_chains_num <= 2))\r\nbreak;\r\nif (win->success_ratio >= IL_RS_GOOD_RATIO)\r\nbreak;\r\nmemcpy(search_tbl, tbl, sz);\r\nif (il4965_rs_toggle_antenna\r\n(valid_tx_ant, &search_tbl->current_rate,\r\nsearch_tbl)) {\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IL_SISO_SWITCH_MIMO2_AB:\r\ncase IL_SISO_SWITCH_MIMO2_AC:\r\ncase IL_SISO_SWITCH_MIMO2_BC:\r\nD_RATE("LQ: SISO switch to MIMO2\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = 0;\r\nif (tbl->action == IL_SISO_SWITCH_MIMO2_AB)\r\nsearch_tbl->ant_type = ANT_AB;\r\nelse if (tbl->action == IL_SISO_SWITCH_MIMO2_AC)\r\nsearch_tbl->ant_type = ANT_AC;\r\nelse\r\nsearch_tbl->ant_type = ANT_BC;\r\nif (!il4965_rs_is_valid_ant\r\n(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret =\r\nil4965_rs_switch_to_mimo2(il, lq_sta, conf, sta,\r\nsearch_tbl, idx);\r\nif (!ret)\r\ngoto out;\r\nbreak;\r\ncase IL_SISO_SWITCH_GI:\r\nif (!tbl->is_ht40 &&\r\n!(ht_cap->cap & IEEE80211_HT_CAP_SGI_20))\r\nbreak;\r\nif (tbl->is_ht40 &&\r\n!(ht_cap->cap & IEEE80211_HT_CAP_SGI_40))\r\nbreak;\r\nD_RATE("LQ: SISO toggle SGI/NGI\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nif (is_green) {\r\nif (!tbl->is_SGI)\r\nbreak;\r\nelse\r\nIL_ERR("SGI was set in GF+SISO\n");\r\n}\r\nsearch_tbl->is_SGI = !tbl->is_SGI;\r\nil4965_rs_set_expected_tpt_table(lq_sta, search_tbl);\r\nif (tbl->is_SGI) {\r\ns32 tpt = lq_sta->last_tpt / 100;\r\nif (tpt >= search_tbl->expected_tpt[idx])\r\nbreak;\r\n}\r\nsearch_tbl->current_rate =\r\nil4965_rate_n_flags_from_tbl(il, search_tbl, idx,\r\nis_green);\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\n}\r\ntbl->action++;\r\nif (tbl->action > IL_SISO_SWITCH_GI)\r\ntbl->action = IL_SISO_SWITCH_ANTENNA1;\r\nif (tbl->action == start_action)\r\nbreak;\r\n}\r\nsearch_tbl->lq_type = LQ_NONE;\r\nreturn 0;\r\nout:\r\nlq_sta->search_better_tbl = 1;\r\ntbl->action++;\r\nif (tbl->action > IL_SISO_SWITCH_GI)\r\ntbl->action = IL_SISO_SWITCH_ANTENNA1;\r\nif (update_search_tbl_counter)\r\nsearch_tbl->action = tbl->action;\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_rs_move_mimo2_to_other(struct il_priv *il, struct il_lq_sta *lq_sta,\r\nstruct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta, int idx)\r\n{\r\ns8 is_green = lq_sta->is_green;\r\nstruct il_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nstruct il_scale_tbl_info *search_tbl =\r\n&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nstruct il_rate_scale_data *win = &(tbl->win[idx]);\r\nstruct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;\r\nu32 sz =\r\n(sizeof(struct il_scale_tbl_info) -\r\n(sizeof(struct il_rate_scale_data) * RATE_COUNT));\r\nu8 start_action;\r\nu8 valid_tx_ant = il->hw_params.valid_tx_ant;\r\nu8 tx_chains_num = il->hw_params.tx_chains_num;\r\nu8 update_search_tbl_counter = 0;\r\nint ret;\r\nstart_action = tbl->action;\r\nfor (;;) {\r\nlq_sta->action_counter++;\r\nswitch (tbl->action) {\r\ncase IL_MIMO2_SWITCH_ANTENNA1:\r\ncase IL_MIMO2_SWITCH_ANTENNA2:\r\nD_RATE("LQ: MIMO2 toggle Antennas\n");\r\nif (tx_chains_num <= 2)\r\nbreak;\r\nif (win->success_ratio >= IL_RS_GOOD_RATIO)\r\nbreak;\r\nmemcpy(search_tbl, tbl, sz);\r\nif (il4965_rs_toggle_antenna\r\n(valid_tx_ant, &search_tbl->current_rate,\r\nsearch_tbl)) {\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IL_MIMO2_SWITCH_SISO_A:\r\ncase IL_MIMO2_SWITCH_SISO_B:\r\ncase IL_MIMO2_SWITCH_SISO_C:\r\nD_RATE("LQ: MIMO2 switch to SISO\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nif (tbl->action == IL_MIMO2_SWITCH_SISO_A)\r\nsearch_tbl->ant_type = ANT_A;\r\nelse if (tbl->action == IL_MIMO2_SWITCH_SISO_B)\r\nsearch_tbl->ant_type = ANT_B;\r\nelse\r\nsearch_tbl->ant_type = ANT_C;\r\nif (!il4965_rs_is_valid_ant\r\n(valid_tx_ant, search_tbl->ant_type))\r\nbreak;\r\nret =\r\nil4965_rs_switch_to_siso(il, lq_sta, conf, sta,\r\nsearch_tbl, idx);\r\nif (!ret)\r\ngoto out;\r\nbreak;\r\ncase IL_MIMO2_SWITCH_GI:\r\nif (!tbl->is_ht40 &&\r\n!(ht_cap->cap & IEEE80211_HT_CAP_SGI_20))\r\nbreak;\r\nif (tbl->is_ht40 &&\r\n!(ht_cap->cap & IEEE80211_HT_CAP_SGI_40))\r\nbreak;\r\nD_RATE("LQ: MIMO2 toggle SGI/NGI\n");\r\nmemcpy(search_tbl, tbl, sz);\r\nsearch_tbl->is_SGI = !tbl->is_SGI;\r\nil4965_rs_set_expected_tpt_table(lq_sta, search_tbl);\r\nif (tbl->is_SGI) {\r\ns32 tpt = lq_sta->last_tpt / 100;\r\nif (tpt >= search_tbl->expected_tpt[idx])\r\nbreak;\r\n}\r\nsearch_tbl->current_rate =\r\nil4965_rate_n_flags_from_tbl(il, search_tbl, idx,\r\nis_green);\r\nupdate_search_tbl_counter = 1;\r\ngoto out;\r\n}\r\ntbl->action++;\r\nif (tbl->action > IL_MIMO2_SWITCH_GI)\r\ntbl->action = IL_MIMO2_SWITCH_ANTENNA1;\r\nif (tbl->action == start_action)\r\nbreak;\r\n}\r\nsearch_tbl->lq_type = LQ_NONE;\r\nreturn 0;\r\nout:\r\nlq_sta->search_better_tbl = 1;\r\ntbl->action++;\r\nif (tbl->action > IL_MIMO2_SWITCH_GI)\r\ntbl->action = IL_MIMO2_SWITCH_ANTENNA1;\r\nif (update_search_tbl_counter)\r\nsearch_tbl->action = tbl->action;\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_rs_stay_in_table(struct il_lq_sta *lq_sta, bool force_search)\r\n{\r\nstruct il_scale_tbl_info *tbl;\r\nint i;\r\nint active_tbl;\r\nint flush_interval_passed = 0;\r\nstruct il_priv *il;\r\nil = lq_sta->drv;\r\nactive_tbl = lq_sta->active_tbl;\r\ntbl = &(lq_sta->lq_info[active_tbl]);\r\nif (lq_sta->stay_in_tbl) {\r\nif (lq_sta->flush_timer)\r\nflush_interval_passed =\r\ntime_after(jiffies,\r\n(unsigned long)(lq_sta->flush_timer +\r\nRATE_SCALE_FLUSH_INTVL));\r\nif (force_search ||\r\nlq_sta->total_failed > lq_sta->max_failure_limit ||\r\nlq_sta->total_success > lq_sta->max_success_limit ||\r\n(!lq_sta->search_better_tbl && lq_sta->flush_timer &&\r\nflush_interval_passed)) {\r\nD_RATE("LQ: stay is expired %d %d %d\n",\r\nlq_sta->total_failed, lq_sta->total_success,\r\nflush_interval_passed);\r\nlq_sta->stay_in_tbl = 0;\r\nlq_sta->total_failed = 0;\r\nlq_sta->total_success = 0;\r\nlq_sta->flush_timer = 0;\r\n} else {\r\nlq_sta->table_count++;\r\nif (lq_sta->table_count >= lq_sta->table_count_limit) {\r\nlq_sta->table_count = 0;\r\nD_RATE("LQ: stay in table clear win\n");\r\nfor (i = 0; i < RATE_COUNT; i++)\r\nil4965_rs_rate_scale_clear_win(&\r\n(tbl->\r\nwin\r\n[i]));\r\n}\r\n}\r\nif (!lq_sta->stay_in_tbl) {\r\nfor (i = 0; i < RATE_COUNT; i++)\r\nil4965_rs_rate_scale_clear_win(&(tbl->win[i]));\r\n}\r\n}\r\n}\r\nstatic void\r\nil4965_rs_update_rate_tbl(struct il_priv *il, struct il_lq_sta *lq_sta,\r\nstruct il_scale_tbl_info *tbl, int idx, u8 is_green)\r\n{\r\nu32 rate;\r\nrate = il4965_rate_n_flags_from_tbl(il, tbl, idx, is_green);\r\nil4965_rs_fill_link_cmd(il, lq_sta, rate);\r\nil_send_lq_cmd(il, &lq_sta->lq, CMD_ASYNC, false);\r\n}\r\nstatic void\r\nil4965_rs_rate_scale_perform(struct il_priv *il, struct sk_buff *skb,\r\nstruct ieee80211_sta *sta,\r\nstruct il_lq_sta *lq_sta)\r\n{\r\nstruct ieee80211_hw *hw = il->hw;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nint low = RATE_INVALID;\r\nint high = RATE_INVALID;\r\nint idx;\r\nint i;\r\nstruct il_rate_scale_data *win = NULL;\r\nint current_tpt = IL_INVALID_VALUE;\r\nint low_tpt = IL_INVALID_VALUE;\r\nint high_tpt = IL_INVALID_VALUE;\r\nu32 fail_count;\r\ns8 scale_action = 0;\r\nu16 rate_mask;\r\nu8 update_lq = 0;\r\nstruct il_scale_tbl_info *tbl, *tbl1;\r\nu16 rate_scale_idx_msk = 0;\r\nu8 is_green = 0;\r\nu8 active_tbl = 0;\r\nu8 done_search = 0;\r\nu16 high_low;\r\ns32 sr;\r\nu8 tid = MAX_TID_COUNT;\r\nstruct il_tid_data *tid_data;\r\nD_RATE("rate scale calculate new rate for skb\n");\r\nif (!ieee80211_is_data(hdr->frame_control) ||\r\n(info->flags & IEEE80211_TX_CTL_NO_ACK))\r\nreturn;\r\nlq_sta->supp_rates = sta->supp_rates[lq_sta->band];\r\ntid = il4965_rs_tl_add_packet(lq_sta, hdr);\r\nif (tid != MAX_TID_COUNT && (lq_sta->tx_agg_tid_en & (1 << tid))) {\r\ntid_data = &il->stations[lq_sta->lq.sta_id].tid[tid];\r\nif (tid_data->agg.state == IL_AGG_OFF)\r\nlq_sta->is_agg = 0;\r\nelse\r\nlq_sta->is_agg = 1;\r\n} else\r\nlq_sta->is_agg = 0;\r\nif (!lq_sta->search_better_tbl)\r\nactive_tbl = lq_sta->active_tbl;\r\nelse\r\nactive_tbl = 1 - lq_sta->active_tbl;\r\ntbl = &(lq_sta->lq_info[active_tbl]);\r\nif (is_legacy(tbl->lq_type))\r\nlq_sta->is_green = 0;\r\nelse\r\nlq_sta->is_green = il4965_rs_use_green(il, sta);\r\nis_green = lq_sta->is_green;\r\nidx = lq_sta->last_txrate_idx;\r\nD_RATE("Rate scale idx %d for type %d\n", idx, tbl->lq_type);\r\nrate_mask = il4965_rs_get_supported_rates(lq_sta, hdr, tbl->lq_type);\r\nD_RATE("mask 0x%04X\n", rate_mask);\r\nif (is_legacy(tbl->lq_type)) {\r\nif (lq_sta->band == NL80211_BAND_5GHZ)\r\nrate_scale_idx_msk =\r\n(u16) (rate_mask &\r\n(lq_sta->supp_rates << IL_FIRST_OFDM_RATE));\r\nelse\r\nrate_scale_idx_msk =\r\n(u16) (rate_mask & lq_sta->supp_rates);\r\n} else\r\nrate_scale_idx_msk = rate_mask;\r\nif (!rate_scale_idx_msk)\r\nrate_scale_idx_msk = rate_mask;\r\nif (!((1 << idx) & rate_scale_idx_msk)) {\r\nIL_ERR("Current Rate is not valid\n");\r\nif (lq_sta->search_better_tbl) {\r\ntbl->lq_type = LQ_NONE;\r\nlq_sta->search_better_tbl = 0;\r\ntbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nidx = il4965_hwrate_to_plcp_idx(tbl->current_rate);\r\nil4965_rs_update_rate_tbl(il, lq_sta, tbl, idx,\r\nis_green);\r\n}\r\nreturn;\r\n}\r\nif (!tbl->expected_tpt) {\r\nIL_ERR("tbl->expected_tpt is NULL\n");\r\nreturn;\r\n}\r\nif (lq_sta->max_rate_idx != -1 && lq_sta->max_rate_idx < idx) {\r\nidx = lq_sta->max_rate_idx;\r\nupdate_lq = 1;\r\nwin = &(tbl->win[idx]);\r\ngoto lq_update;\r\n}\r\nwin = &(tbl->win[idx]);\r\nfail_count = win->counter - win->success_counter;\r\nif (fail_count < RATE_MIN_FAILURE_TH &&\r\nwin->success_counter < RATE_MIN_SUCCESS_TH) {\r\nD_RATE("LQ: still below TH. succ=%d total=%d " "for idx %d\n",\r\nwin->success_counter, win->counter, idx);\r\nwin->average_tpt = IL_INVALID_VALUE;\r\nil4965_rs_stay_in_table(lq_sta, false);\r\ngoto out;\r\n}\r\nif (win->average_tpt !=\r\n((win->success_ratio * tbl->expected_tpt[idx] + 64) / 128)) {\r\nIL_ERR("expected_tpt should have been calculated by now\n");\r\nwin->average_tpt =\r\n((win->success_ratio * tbl->expected_tpt[idx] + 64) / 128);\r\n}\r\nif (lq_sta->search_better_tbl) {\r\nif (win->average_tpt > lq_sta->last_tpt) {\r\nD_RATE("LQ: SWITCHING TO NEW TBL "\r\n"suc=%d cur-tpt=%d old-tpt=%d\n",\r\nwin->success_ratio, win->average_tpt,\r\nlq_sta->last_tpt);\r\nif (!is_legacy(tbl->lq_type))\r\nlq_sta->enable_counter = 1;\r\nlq_sta->active_tbl = active_tbl;\r\ncurrent_tpt = win->average_tpt;\r\n} else {\r\nD_RATE("LQ: GOING BACK TO THE OLD TBL "\r\n"suc=%d cur-tpt=%d old-tpt=%d\n",\r\nwin->success_ratio, win->average_tpt,\r\nlq_sta->last_tpt);\r\ntbl->lq_type = LQ_NONE;\r\nactive_tbl = lq_sta->active_tbl;\r\ntbl = &(lq_sta->lq_info[active_tbl]);\r\nidx = il4965_hwrate_to_plcp_idx(tbl->current_rate);\r\ncurrent_tpt = lq_sta->last_tpt;\r\nupdate_lq = 1;\r\n}\r\nlq_sta->search_better_tbl = 0;\r\ndone_search = 1;\r\ngoto lq_update;\r\n}\r\nhigh_low =\r\nil4965_rs_get_adjacent_rate(il, idx, rate_scale_idx_msk,\r\ntbl->lq_type);\r\nlow = high_low & 0xff;\r\nhigh = (high_low >> 8) & 0xff;\r\nif (lq_sta->max_rate_idx != -1 && lq_sta->max_rate_idx < high)\r\nhigh = RATE_INVALID;\r\nsr = win->success_ratio;\r\ncurrent_tpt = win->average_tpt;\r\nif (low != RATE_INVALID)\r\nlow_tpt = tbl->win[low].average_tpt;\r\nif (high != RATE_INVALID)\r\nhigh_tpt = tbl->win[high].average_tpt;\r\nscale_action = 0;\r\nif (sr <= RATE_DECREASE_TH || current_tpt == 0) {\r\nD_RATE("decrease rate because of low success_ratio\n");\r\nscale_action = -1;\r\n} else if (low_tpt == IL_INVALID_VALUE && high_tpt == IL_INVALID_VALUE) {\r\nif (high != RATE_INVALID && sr >= RATE_INCREASE_TH)\r\nscale_action = 1;\r\nelse if (low != RATE_INVALID)\r\nscale_action = 0;\r\n}\r\nelse if (low_tpt != IL_INVALID_VALUE && high_tpt != IL_INVALID_VALUE &&\r\nlow_tpt < current_tpt && high_tpt < current_tpt)\r\nscale_action = 0;\r\nelse {\r\nif (high_tpt != IL_INVALID_VALUE) {\r\nif (high_tpt > current_tpt && sr >= RATE_INCREASE_TH)\r\nscale_action = 1;\r\nelse\r\nscale_action = 0;\r\n} else if (low_tpt != IL_INVALID_VALUE) {\r\nif (low_tpt > current_tpt) {\r\nD_RATE("decrease rate because of low tpt\n");\r\nscale_action = -1;\r\n} else if (sr >= RATE_INCREASE_TH) {\r\nscale_action = 1;\r\n}\r\n}\r\n}\r\nif (scale_action == -1 && low != RATE_INVALID &&\r\n(sr > RATE_HIGH_TH || current_tpt > 100 * tbl->expected_tpt[low]))\r\nscale_action = 0;\r\nswitch (scale_action) {\r\ncase -1:\r\nif (low != RATE_INVALID) {\r\nupdate_lq = 1;\r\nidx = low;\r\n}\r\nbreak;\r\ncase 1:\r\nif (high != RATE_INVALID) {\r\nupdate_lq = 1;\r\nidx = high;\r\n}\r\nbreak;\r\ncase 0:\r\ndefault:\r\nbreak;\r\n}\r\nD_RATE("choose rate scale idx %d action %d low %d " "high %d type %d\n",\r\nidx, scale_action, low, high, tbl->lq_type);\r\nlq_update:\r\nif (update_lq)\r\nil4965_rs_update_rate_tbl(il, lq_sta, tbl, idx, is_green);\r\nil4965_rs_stay_in_table(lq_sta, false);\r\nif (!update_lq && !done_search && !lq_sta->stay_in_tbl && win->counter) {\r\nlq_sta->last_tpt = current_tpt;\r\nif (is_legacy(tbl->lq_type))\r\nil4965_rs_move_legacy_other(il, lq_sta, conf, sta, idx);\r\nelse if (is_siso(tbl->lq_type))\r\nil4965_rs_move_siso_to_other(il, lq_sta, conf, sta,\r\nidx);\r\nelse\r\nil4965_rs_move_mimo2_to_other(il, lq_sta, conf, sta,\r\nidx);\r\nif (lq_sta->search_better_tbl) {\r\ntbl = &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\r\nfor (i = 0; i < RATE_COUNT; i++)\r\nil4965_rs_rate_scale_clear_win(&(tbl->win[i]));\r\nidx = il4965_hwrate_to_plcp_idx(tbl->current_rate);\r\nD_RATE("Switch current mcs: %X idx: %d\n",\r\ntbl->current_rate, idx);\r\nil4965_rs_fill_link_cmd(il, lq_sta, tbl->current_rate);\r\nil_send_lq_cmd(il, &lq_sta->lq, CMD_ASYNC, false);\r\n} else\r\ndone_search = 1;\r\n}\r\nif (done_search && !lq_sta->stay_in_tbl) {\r\ntbl1 = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nif (is_legacy(tbl1->lq_type) && !conf_is_ht(conf) &&\r\nlq_sta->action_counter > tbl1->max_search) {\r\nD_RATE("LQ: STAY in legacy table\n");\r\nil4965_rs_set_stay_in_table(il, 1, lq_sta);\r\n}\r\nif (lq_sta->enable_counter &&\r\nlq_sta->action_counter >= tbl1->max_search) {\r\nif (lq_sta->last_tpt > IL_AGG_TPT_THREHOLD &&\r\n(lq_sta->tx_agg_tid_en & (1 << tid)) &&\r\ntid != MAX_TID_COUNT) {\r\ntid_data =\r\n&il->stations[lq_sta->lq.sta_id].tid[tid];\r\nif (tid_data->agg.state == IL_AGG_OFF) {\r\nD_RATE("try to aggregate tid %d\n",\r\ntid);\r\nil4965_rs_tl_turn_on_agg(il, tid,\r\nlq_sta, sta);\r\n}\r\n}\r\nil4965_rs_set_stay_in_table(il, 0, lq_sta);\r\n}\r\n}\r\nout:\r\ntbl->current_rate =\r\nil4965_rate_n_flags_from_tbl(il, tbl, idx, is_green);\r\ni = idx;\r\nlq_sta->last_txrate_idx = i;\r\n}\r\nstatic void\r\nil4965_rs_initialize_lq(struct il_priv *il, struct ieee80211_conf *conf,\r\nstruct ieee80211_sta *sta, struct il_lq_sta *lq_sta)\r\n{\r\nstruct il_scale_tbl_info *tbl;\r\nint rate_idx;\r\nint i;\r\nu32 rate;\r\nu8 use_green;\r\nu8 active_tbl = 0;\r\nu8 valid_tx_ant;\r\nstruct il_station_priv *sta_priv;\r\nif (!sta || !lq_sta)\r\nreturn;\r\nuse_green = il4965_rs_use_green(il, sta);\r\nsta_priv = (void *)sta->drv_priv;\r\ni = lq_sta->last_txrate_idx;\r\nvalid_tx_ant = il->hw_params.valid_tx_ant;\r\nif (!lq_sta->search_better_tbl)\r\nactive_tbl = lq_sta->active_tbl;\r\nelse\r\nactive_tbl = 1 - lq_sta->active_tbl;\r\ntbl = &(lq_sta->lq_info[active_tbl]);\r\nif (i < 0 || i >= RATE_COUNT)\r\ni = 0;\r\nrate = il_rates[i].plcp;\r\ntbl->ant_type = il4965_first_antenna(valid_tx_ant);\r\nrate |= tbl->ant_type << RATE_MCS_ANT_POS;\r\nif (i >= IL_FIRST_CCK_RATE && i <= IL_LAST_CCK_RATE)\r\nrate |= RATE_MCS_CCK_MSK;\r\nil4965_rs_get_tbl_info_from_mcs(rate, il->band, tbl, &rate_idx);\r\nif (!il4965_rs_is_valid_ant(valid_tx_ant, tbl->ant_type))\r\nil4965_rs_toggle_antenna(valid_tx_ant, &rate, tbl);\r\nrate = il4965_rate_n_flags_from_tbl(il, tbl, rate_idx, use_green);\r\ntbl->current_rate = rate;\r\nil4965_rs_set_expected_tpt_table(lq_sta, tbl);\r\nil4965_rs_fill_link_cmd(NULL, lq_sta, rate);\r\nil->stations[lq_sta->lq.sta_id].lq = &lq_sta->lq;\r\nil_send_lq_cmd(il, &lq_sta->lq, CMD_SYNC, true);\r\n}\r\nstatic void\r\nil4965_rs_get_rate(void *il_r, struct ieee80211_sta *sta, void *il_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct sk_buff *skb = txrc->skb;\r\nstruct ieee80211_supported_band *sband = txrc->sband;\r\nstruct il_priv *il __maybe_unused = (struct il_priv *)il_r;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct il_lq_sta *lq_sta = il_sta;\r\nint rate_idx;\r\nD_RATE("rate scale calculate new rate for skb\n");\r\nif (lq_sta) {\r\nlq_sta->max_rate_idx = txrc->max_rate_idx;\r\nif (sband->band == NL80211_BAND_5GHZ &&\r\nlq_sta->max_rate_idx != -1)\r\nlq_sta->max_rate_idx += IL_FIRST_OFDM_RATE;\r\nif (lq_sta->max_rate_idx < 0 ||\r\nlq_sta->max_rate_idx >= RATE_COUNT)\r\nlq_sta->max_rate_idx = -1;\r\n}\r\nif (lq_sta && !lq_sta->drv) {\r\nD_RATE("Rate scaling not initialized yet.\n");\r\nil_sta = NULL;\r\n}\r\nif (rate_control_send_low(sta, il_sta, txrc))\r\nreturn;\r\nif (!lq_sta)\r\nreturn;\r\nrate_idx = lq_sta->last_txrate_idx;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_HT_MSK) {\r\nrate_idx -= IL_FIRST_OFDM_RATE;\r\nrate_idx = (rate_idx > 0) ? (rate_idx - 1) : 0;\r\nif (il4965_rs_extract_rate(lq_sta->last_rate_n_flags) >=\r\nRATE_MIMO2_6M_PLCP)\r\nrate_idx = rate_idx + MCS_IDX_PER_STREAM;\r\ninfo->control.rates[0].flags = IEEE80211_TX_RC_MCS;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_SGI_MSK)\r\ninfo->control.rates[0].flags |=\r\nIEEE80211_TX_RC_SHORT_GI;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_DUP_MSK)\r\ninfo->control.rates[0].flags |=\r\nIEEE80211_TX_RC_DUP_DATA;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_HT40_MSK)\r\ninfo->control.rates[0].flags |=\r\nIEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (lq_sta->last_rate_n_flags & RATE_MCS_GF_MSK)\r\ninfo->control.rates[0].flags |=\r\nIEEE80211_TX_RC_GREEN_FIELD;\r\n} else {\r\nif (rate_idx < 0 || rate_idx >= RATE_COUNT_LEGACY ||\r\n(sband->band == NL80211_BAND_5GHZ &&\r\nrate_idx < IL_FIRST_OFDM_RATE))\r\nrate_idx = rate_lowest_index(sband, sta);\r\nelse if (sband->band == NL80211_BAND_5GHZ)\r\nrate_idx -= IL_FIRST_OFDM_RATE;\r\ninfo->control.rates[0].flags = 0;\r\n}\r\ninfo->control.rates[0].idx = rate_idx;\r\ninfo->control.rates[0].count = 1;\r\n}\r\nstatic void *\r\nil4965_rs_alloc_sta(void *il_rate, struct ieee80211_sta *sta, gfp_t gfp)\r\n{\r\nstruct il_station_priv *sta_priv =\r\n(struct il_station_priv *)sta->drv_priv;\r\nstruct il_priv *il;\r\nil = (struct il_priv *)il_rate;\r\nD_RATE("create station rate scale win\n");\r\nreturn &sta_priv->lq_sta;\r\n}\r\nvoid\r\nil4965_rs_rate_init(struct il_priv *il, struct ieee80211_sta *sta, u8 sta_id)\r\n{\r\nint i, j;\r\nstruct ieee80211_hw *hw = il->hw;\r\nstruct ieee80211_conf *conf = &il->hw->conf;\r\nstruct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;\r\nstruct il_station_priv *sta_priv;\r\nstruct il_lq_sta *lq_sta;\r\nstruct ieee80211_supported_band *sband;\r\nsta_priv = (struct il_station_priv *)sta->drv_priv;\r\nlq_sta = &sta_priv->lq_sta;\r\nsband = hw->wiphy->bands[conf->chandef.chan->band];\r\nlq_sta->lq.sta_id = sta_id;\r\nfor (j = 0; j < LQ_SIZE; j++)\r\nfor (i = 0; i < RATE_COUNT; i++)\r\nil4965_rs_rate_scale_clear_win(&lq_sta->lq_info[j].\r\nwin[i]);\r\nlq_sta->flush_timer = 0;\r\nlq_sta->supp_rates = sta->supp_rates[sband->band];\r\nfor (j = 0; j < LQ_SIZE; j++)\r\nfor (i = 0; i < RATE_COUNT; i++)\r\nil4965_rs_rate_scale_clear_win(&lq_sta->lq_info[j].\r\nwin[i]);\r\nD_RATE("LQ:" "*** rate scale station global init for station %d ***\n",\r\nsta_id);\r\nlq_sta->is_dup = 0;\r\nlq_sta->max_rate_idx = -1;\r\nlq_sta->missed_rate_counter = IL_MISSED_RATE_MAX;\r\nlq_sta->is_green = il4965_rs_use_green(il, sta);\r\nlq_sta->active_legacy_rate = il->active_rate & ~(0x1000);\r\nlq_sta->band = il->band;\r\nlq_sta->active_siso_rate = ht_cap->mcs.rx_mask[0] << 1;\r\nlq_sta->active_siso_rate |= ht_cap->mcs.rx_mask[0] & 0x1;\r\nlq_sta->active_siso_rate &= ~((u16) 0x2);\r\nlq_sta->active_siso_rate <<= IL_FIRST_OFDM_RATE;\r\nlq_sta->active_mimo2_rate = ht_cap->mcs.rx_mask[1] << 1;\r\nlq_sta->active_mimo2_rate |= ht_cap->mcs.rx_mask[1] & 0x1;\r\nlq_sta->active_mimo2_rate &= ~((u16) 0x2);\r\nlq_sta->active_mimo2_rate <<= IL_FIRST_OFDM_RATE;\r\nlq_sta->lq.general_params.single_stream_ant_msk =\r\nil4965_first_antenna(il->hw_params.valid_tx_ant);\r\nlq_sta->lq.general_params.dual_stream_ant_msk =\r\nil->hw_params.valid_tx_ant & ~il4965_first_antenna(il->hw_params.\r\nvalid_tx_ant);\r\nif (!lq_sta->lq.general_params.dual_stream_ant_msk) {\r\nlq_sta->lq.general_params.dual_stream_ant_msk = ANT_AB;\r\n} else if (il4965_num_of_ant(il->hw_params.valid_tx_ant) == 2) {\r\nlq_sta->lq.general_params.dual_stream_ant_msk =\r\nil->hw_params.valid_tx_ant;\r\n}\r\nlq_sta->tx_agg_tid_en = IL_AGG_ALL_TID;\r\nlq_sta->drv = il;\r\nlq_sta->last_txrate_idx = rate_lowest_index(sband, sta);\r\nif (sband->band == NL80211_BAND_5GHZ)\r\nlq_sta->last_txrate_idx += IL_FIRST_OFDM_RATE;\r\nlq_sta->is_agg = 0;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nlq_sta->dbg_fixed_rate = 0;\r\n#endif\r\nil4965_rs_initialize_lq(il, conf, sta, lq_sta);\r\n}\r\nstatic void\r\nil4965_rs_fill_link_cmd(struct il_priv *il, struct il_lq_sta *lq_sta,\r\nu32 new_rate)\r\n{\r\nstruct il_scale_tbl_info tbl_type;\r\nint idx = 0;\r\nint rate_idx;\r\nint repeat_rate = 0;\r\nu8 ant_toggle_cnt = 0;\r\nu8 use_ht_possible = 1;\r\nu8 valid_tx_ant = 0;\r\nstruct il_link_quality_cmd *lq_cmd = &lq_sta->lq;\r\nil4965_rs_dbgfs_set_mcs(lq_sta, &new_rate, idx);\r\nil4965_rs_get_tbl_info_from_mcs(new_rate, lq_sta->band, &tbl_type,\r\n&rate_idx);\r\nif (is_legacy(tbl_type.lq_type)) {\r\nant_toggle_cnt = 1;\r\nrepeat_rate = IL_NUMBER_TRY;\r\n} else {\r\nrepeat_rate = IL_HT_NUMBER_TRY;\r\n}\r\nlq_cmd->general_params.mimo_delimiter =\r\nis_mimo(tbl_type.lq_type) ? 1 : 0;\r\nlq_cmd->rs_table[idx].rate_n_flags = cpu_to_le32(new_rate);\r\nif (il4965_num_of_ant(tbl_type.ant_type) == 1) {\r\nlq_cmd->general_params.single_stream_ant_msk =\r\ntbl_type.ant_type;\r\n} else if (il4965_num_of_ant(tbl_type.ant_type) == 2) {\r\nlq_cmd->general_params.dual_stream_ant_msk = tbl_type.ant_type;\r\n}\r\nidx++;\r\nrepeat_rate--;\r\nif (il)\r\nvalid_tx_ant = il->hw_params.valid_tx_ant;\r\nwhile (idx < LINK_QUAL_MAX_RETRY_NUM) {\r\nwhile (repeat_rate > 0 && idx < LINK_QUAL_MAX_RETRY_NUM) {\r\nif (is_legacy(tbl_type.lq_type)) {\r\nif (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)\r\nant_toggle_cnt++;\r\nelse if (il &&\r\nil4965_rs_toggle_antenna(valid_tx_ant,\r\n&new_rate,\r\n&tbl_type))\r\nant_toggle_cnt = 1;\r\n}\r\nil4965_rs_dbgfs_set_mcs(lq_sta, &new_rate, idx);\r\nlq_cmd->rs_table[idx].rate_n_flags =\r\ncpu_to_le32(new_rate);\r\nrepeat_rate--;\r\nidx++;\r\n}\r\nil4965_rs_get_tbl_info_from_mcs(new_rate, lq_sta->band,\r\n&tbl_type, &rate_idx);\r\nif (is_mimo(tbl_type.lq_type))\r\nlq_cmd->general_params.mimo_delimiter = idx;\r\nnew_rate =\r\nil4965_rs_get_lower_rate(lq_sta, &tbl_type, rate_idx,\r\nuse_ht_possible);\r\nif (is_legacy(tbl_type.lq_type)) {\r\nif (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)\r\nant_toggle_cnt++;\r\nelse if (il &&\r\nil4965_rs_toggle_antenna(valid_tx_ant,\r\n&new_rate, &tbl_type))\r\nant_toggle_cnt = 1;\r\nrepeat_rate = IL_NUMBER_TRY;\r\n} else {\r\nrepeat_rate = IL_HT_NUMBER_TRY;\r\n}\r\nuse_ht_possible = 0;\r\nil4965_rs_dbgfs_set_mcs(lq_sta, &new_rate, idx);\r\nlq_cmd->rs_table[idx].rate_n_flags = cpu_to_le32(new_rate);\r\nidx++;\r\nrepeat_rate--;\r\n}\r\nlq_cmd->agg_params.agg_frame_cnt_limit = LINK_QUAL_AGG_FRAME_LIMIT_DEF;\r\nlq_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;\r\nlq_cmd->agg_params.agg_time_limit =\r\ncpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\r\n}\r\nstatic void *\r\nil4965_rs_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nreturn hw->priv;\r\n}\r\nstatic void\r\nil4965_rs_free(void *il_rate)\r\n{\r\nreturn;\r\n}\r\nstatic void\r\nil4965_rs_free_sta(void *il_r, struct ieee80211_sta *sta, void *il_sta)\r\n{\r\nstruct il_priv *il __maybe_unused = il_r;\r\nD_RATE("enter\n");\r\nD_RATE("leave\n");\r\n}\r\nstatic void\r\nil4965_rs_dbgfs_set_mcs(struct il_lq_sta *lq_sta, u32 * rate_n_flags, int idx)\r\n{\r\nstruct il_priv *il;\r\nu8 valid_tx_ant;\r\nu8 ant_sel_tx;\r\nil = lq_sta->drv;\r\nvalid_tx_ant = il->hw_params.valid_tx_ant;\r\nif (lq_sta->dbg_fixed_rate) {\r\nant_sel_tx =\r\n((lq_sta->\r\ndbg_fixed_rate & RATE_MCS_ANT_ABC_MSK) >>\r\nRATE_MCS_ANT_POS);\r\nif ((valid_tx_ant & ant_sel_tx) == ant_sel_tx) {\r\n*rate_n_flags = lq_sta->dbg_fixed_rate;\r\nD_RATE("Fixed rate ON\n");\r\n} else {\r\nlq_sta->dbg_fixed_rate = 0;\r\nIL_ERR\r\n("Invalid antenna selection 0x%X, Valid is 0x%X\n",\r\nant_sel_tx, valid_tx_ant);\r\nD_RATE("Fixed rate OFF\n");\r\n}\r\n} else {\r\nD_RATE("Fixed rate OFF\n");\r\n}\r\n}\r\nstatic ssize_t\r\nil4965_rs_sta_dbgfs_scale_table_write(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct il_lq_sta *lq_sta = file->private_data;\r\nstruct il_priv *il;\r\nchar buf[64];\r\nsize_t buf_size;\r\nu32 parsed_rate;\r\nil = lq_sta->drv;\r\nmemset(buf, 0, sizeof(buf));\r\nbuf_size = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, buf_size))\r\nreturn -EFAULT;\r\nif (sscanf(buf, "%x", &parsed_rate) == 1)\r\nlq_sta->dbg_fixed_rate = parsed_rate;\r\nelse\r\nlq_sta->dbg_fixed_rate = 0;\r\nlq_sta->active_legacy_rate = 0x0FFF;\r\nlq_sta->active_siso_rate = 0x1FD0;\r\nlq_sta->active_mimo2_rate = 0x1FD0;\r\nD_RATE("sta_id %d rate 0x%X\n", lq_sta->lq.sta_id,\r\nlq_sta->dbg_fixed_rate);\r\nif (lq_sta->dbg_fixed_rate) {\r\nil4965_rs_fill_link_cmd(NULL, lq_sta, lq_sta->dbg_fixed_rate);\r\nil_send_lq_cmd(lq_sta->drv, &lq_sta->lq, CMD_ASYNC, false);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nil4965_rs_sta_dbgfs_scale_table_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *buff;\r\nint desc = 0;\r\nint i = 0;\r\nint idx = 0;\r\nssize_t ret;\r\nstruct il_lq_sta *lq_sta = file->private_data;\r\nstruct il_priv *il;\r\nstruct il_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\r\nil = lq_sta->drv;\r\nbuff = kmalloc(1024, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\ndesc += sprintf(buff + desc, "sta_id %d\n", lq_sta->lq.sta_id);\r\ndesc +=\r\nsprintf(buff + desc, "failed=%d success=%d rate=0%X\n",\r\nlq_sta->total_failed, lq_sta->total_success,\r\nlq_sta->active_legacy_rate);\r\ndesc +=\r\nsprintf(buff + desc, "fixed rate 0x%X\n", lq_sta->dbg_fixed_rate);\r\ndesc +=\r\nsprintf(buff + desc, "valid_tx_ant %s%s%s\n",\r\n(il->hw_params.valid_tx_ant & ANT_A) ? "ANT_A," : "",\r\n(il->hw_params.valid_tx_ant & ANT_B) ? "ANT_B," : "",\r\n(il->hw_params.valid_tx_ant & ANT_C) ? "ANT_C" : "");\r\ndesc +=\r\nsprintf(buff + desc, "lq type %s\n",\r\n(is_legacy(tbl->lq_type)) ? "legacy" : "HT");\r\nif (is_Ht(tbl->lq_type)) {\r\ndesc +=\r\nsprintf(buff + desc, " %s",\r\n(is_siso(tbl->lq_type)) ? "SISO" : "MIMO2");\r\ndesc +=\r\nsprintf(buff + desc, " %s",\r\n(tbl->is_ht40) ? "40MHz" : "20MHz");\r\ndesc +=\r\nsprintf(buff + desc, " %s %s %s\n",\r\n(tbl->is_SGI) ? "SGI" : "",\r\n(lq_sta->is_green) ? "GF enabled" : "",\r\n(lq_sta->is_agg) ? "AGG on" : "");\r\n}\r\ndesc +=\r\nsprintf(buff + desc, "last tx rate=0x%X\n",\r\nlq_sta->last_rate_n_flags);\r\ndesc +=\r\nsprintf(buff + desc,\r\n"general:" "flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\n",\r\nlq_sta->lq.general_params.flags,\r\nlq_sta->lq.general_params.mimo_delimiter,\r\nlq_sta->lq.general_params.single_stream_ant_msk,\r\nlq_sta->lq.general_params.dual_stream_ant_msk);\r\ndesc +=\r\nsprintf(buff + desc,\r\n"agg:"\r\n"time_limit=%d dist_start_th=%d frame_cnt_limit=%d\n",\r\nle16_to_cpu(lq_sta->lq.agg_params.agg_time_limit),\r\nlq_sta->lq.agg_params.agg_dis_start_th,\r\nlq_sta->lq.agg_params.agg_frame_cnt_limit);\r\ndesc +=\r\nsprintf(buff + desc,\r\n"Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\n",\r\nlq_sta->lq.general_params.start_rate_idx[0],\r\nlq_sta->lq.general_params.start_rate_idx[1],\r\nlq_sta->lq.general_params.start_rate_idx[2],\r\nlq_sta->lq.general_params.start_rate_idx[3]);\r\nfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {\r\nidx =\r\nil4965_hwrate_to_plcp_idx(le32_to_cpu\r\n(lq_sta->lq.rs_table[i].\r\nrate_n_flags));\r\nif (is_legacy(tbl->lq_type)) {\r\ndesc +=\r\nsprintf(buff + desc, " rate[%d] 0x%X %smbps\n", i,\r\nle32_to_cpu(lq_sta->lq.rs_table[i].\r\nrate_n_flags),\r\nil_rate_mcs[idx].mbps);\r\n} else {\r\ndesc +=\r\nsprintf(buff + desc, " rate[%d] 0x%X %smbps (%s)\n",\r\ni,\r\nle32_to_cpu(lq_sta->lq.rs_table[i].\r\nrate_n_flags),\r\nil_rate_mcs[idx].mbps,\r\nil_rate_mcs[idx].mcs);\r\n}\r\n}\r\nret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\r\nkfree(buff);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nil4965_rs_sta_dbgfs_stats_table_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *buff;\r\nint desc = 0;\r\nint i, j;\r\nssize_t ret;\r\nstruct il_lq_sta *lq_sta = file->private_data;\r\nbuff = kmalloc(1024, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < LQ_SIZE; i++) {\r\ndesc +=\r\nsprintf(buff + desc,\r\n"%s type=%d SGI=%d HT40=%d DUP=%d GF=%d\n"\r\n"rate=0x%X\n", lq_sta->active_tbl == i ? "*" : "x",\r\nlq_sta->lq_info[i].lq_type,\r\nlq_sta->lq_info[i].is_SGI,\r\nlq_sta->lq_info[i].is_ht40,\r\nlq_sta->lq_info[i].is_dup, lq_sta->is_green,\r\nlq_sta->lq_info[i].current_rate);\r\nfor (j = 0; j < RATE_COUNT; j++) {\r\ndesc +=\r\nsprintf(buff + desc,\r\n"counter=%d success=%d %%=%d\n",\r\nlq_sta->lq_info[i].win[j].counter,\r\nlq_sta->lq_info[i].win[j].success_counter,\r\nlq_sta->lq_info[i].win[j].success_ratio);\r\n}\r\n}\r\nret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\r\nkfree(buff);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nil4965_rs_sta_dbgfs_rate_scale_data_read(struct file *file,\r\nchar __user *user_buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nchar buff[120];\r\nint desc = 0;\r\nstruct il_lq_sta *lq_sta = file->private_data;\r\nstruct il_scale_tbl_info *tbl = &lq_sta->lq_info[lq_sta->active_tbl];\r\nif (is_Ht(tbl->lq_type))\r\ndesc +=\r\nsprintf(buff + desc, "Bit Rate= %d Mb/s\n",\r\ntbl->expected_tpt[lq_sta->last_txrate_idx]);\r\nelse\r\ndesc +=\r\nsprintf(buff + desc, "Bit Rate= %d Mb/s\n",\r\nil_rates[lq_sta->last_txrate_idx].ieee >> 1);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buff, desc);\r\n}\r\nstatic void\r\nil4965_rs_add_debugfs(void *il, void *il_sta, struct dentry *dir)\r\n{\r\nstruct il_lq_sta *lq_sta = il_sta;\r\nlq_sta->rs_sta_dbgfs_scale_table_file =\r\ndebugfs_create_file("rate_scale_table", S_IRUSR | S_IWUSR, dir,\r\nlq_sta, &rs_sta_dbgfs_scale_table_ops);\r\nlq_sta->rs_sta_dbgfs_stats_table_file =\r\ndebugfs_create_file("rate_stats_table", S_IRUSR, dir, lq_sta,\r\n&rs_sta_dbgfs_stats_table_ops);\r\nlq_sta->rs_sta_dbgfs_rate_scale_data_file =\r\ndebugfs_create_file("rate_scale_data", S_IRUSR, dir, lq_sta,\r\n&rs_sta_dbgfs_rate_scale_data_ops);\r\nlq_sta->rs_sta_dbgfs_tx_agg_tid_en_file =\r\ndebugfs_create_u8("tx_agg_tid_enable", S_IRUSR | S_IWUSR, dir,\r\n&lq_sta->tx_agg_tid_en);\r\n}\r\nstatic void\r\nil4965_rs_remove_debugfs(void *il, void *il_sta)\r\n{\r\nstruct il_lq_sta *lq_sta = il_sta;\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_scale_table_file);\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_stats_table_file);\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_rate_scale_data_file);\r\ndebugfs_remove(lq_sta->rs_sta_dbgfs_tx_agg_tid_en_file);\r\n}\r\nstatic void\r\nil4965_rs_rate_init_stub(void *il_r, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *il_sta)\r\n{\r\n}\r\nint\r\nil4965_rate_control_register(void)\r\n{\r\nreturn ieee80211_rate_control_register(&rs_4965_ops);\r\n}\r\nvoid\r\nil4965_rate_control_unregister(void)\r\n{\r\nieee80211_rate_control_unregister(&rs_4965_ops);\r\n}
