static void dp83640_gpio_defaults(struct ptp_pin_desc *pd)\r\n{\r\nint i, index;\r\nfor (i = 0; i < DP83640_N_PINS; i++) {\r\nsnprintf(pd[i].name, sizeof(pd[i].name), "GPIO%d", 1 + i);\r\npd[i].index = i;\r\n}\r\nfor (i = 0; i < GPIO_TABLE_SIZE; i++) {\r\nif (gpio_tab[i] < 1 || gpio_tab[i] > DP83640_N_PINS) {\r\npr_err("gpio_tab[%d]=%hu out of range", i, gpio_tab[i]);\r\nreturn;\r\n}\r\n}\r\nindex = gpio_tab[CALIBRATE_GPIO] - 1;\r\npd[index].func = PTP_PF_PHYSYNC;\r\npd[index].chan = 0;\r\nindex = gpio_tab[PEROUT_GPIO] - 1;\r\npd[index].func = PTP_PF_PEROUT;\r\npd[index].chan = 0;\r\nfor (i = EXTTS0_GPIO; i < GPIO_TABLE_SIZE; i++) {\r\nindex = gpio_tab[i] - 1;\r\npd[index].func = PTP_PF_EXTTS;\r\npd[index].chan = i - EXTTS0_GPIO;\r\n}\r\n}\r\nstatic inline int broadcast_write(struct phy_device *phydev, u32 regnum,\r\nu16 val)\r\n{\r\nreturn mdiobus_write(phydev->mdio.bus, BROADCAST_ADDR, regnum, val);\r\n}\r\nstatic int ext_read(struct phy_device *phydev, int page, u32 regnum)\r\n{\r\nstruct dp83640_private *dp83640 = phydev->priv;\r\nint val;\r\nif (dp83640->clock->page != page) {\r\nbroadcast_write(phydev, PAGESEL, page);\r\ndp83640->clock->page = page;\r\n}\r\nval = phy_read(phydev, regnum);\r\nreturn val;\r\n}\r\nstatic void ext_write(int broadcast, struct phy_device *phydev,\r\nint page, u32 regnum, u16 val)\r\n{\r\nstruct dp83640_private *dp83640 = phydev->priv;\r\nif (dp83640->clock->page != page) {\r\nbroadcast_write(phydev, PAGESEL, page);\r\ndp83640->clock->page = page;\r\n}\r\nif (broadcast)\r\nbroadcast_write(phydev, regnum, val);\r\nelse\r\nphy_write(phydev, regnum, val);\r\n}\r\nstatic int tdr_write(int bc, struct phy_device *dev,\r\nconst struct timespec64 *ts, u16 cmd)\r\n{\r\next_write(bc, dev, PAGE4, PTP_TDR, ts->tv_nsec & 0xffff);\r\next_write(bc, dev, PAGE4, PTP_TDR, ts->tv_nsec >> 16);\r\next_write(bc, dev, PAGE4, PTP_TDR, ts->tv_sec & 0xffff);\r\next_write(bc, dev, PAGE4, PTP_TDR, ts->tv_sec >> 16);\r\next_write(bc, dev, PAGE4, PTP_CTL, cmd);\r\nreturn 0;\r\n}\r\nstatic void phy2rxts(struct phy_rxts *p, struct rxts *rxts)\r\n{\r\nu32 sec;\r\nsec = p->sec_lo;\r\nsec |= p->sec_hi << 16;\r\nrxts->ns = p->ns_lo;\r\nrxts->ns |= (p->ns_hi & 0x3fff) << 16;\r\nrxts->ns += ((u64)sec) * 1000000000ULL;\r\nrxts->seqid = p->seqid;\r\nrxts->msgtype = (p->msgtype >> 12) & 0xf;\r\nrxts->hash = p->msgtype & 0x0fff;\r\nrxts->tmo = jiffies + SKB_TIMESTAMP_TIMEOUT;\r\n}\r\nstatic u64 phy2txts(struct phy_txts *p)\r\n{\r\nu64 ns;\r\nu32 sec;\r\nsec = p->sec_lo;\r\nsec |= p->sec_hi << 16;\r\nns = p->ns_lo;\r\nns |= (p->ns_hi & 0x3fff) << 16;\r\nns += ((u64)sec) * 1000000000ULL;\r\nreturn ns;\r\n}\r\nstatic int periodic_output(struct dp83640_clock *clock,\r\nstruct ptp_clock_request *clkreq, bool on,\r\nint trigger)\r\n{\r\nstruct dp83640_private *dp83640 = clock->chosen;\r\nstruct phy_device *phydev = dp83640->phydev;\r\nu32 sec, nsec, pwidth;\r\nu16 gpio, ptp_trig, val;\r\nif (on) {\r\ngpio = 1 + ptp_find_pin(clock->ptp_clock, PTP_PF_PEROUT,\r\ntrigger);\r\nif (gpio < 1)\r\nreturn -EINVAL;\r\n} else {\r\ngpio = 0;\r\n}\r\nptp_trig = TRIG_WR |\r\n(trigger & TRIG_CSEL_MASK) << TRIG_CSEL_SHIFT |\r\n(gpio & TRIG_GPIO_MASK) << TRIG_GPIO_SHIFT |\r\nTRIG_PER |\r\nTRIG_PULSE;\r\nval = (trigger & TRIG_SEL_MASK) << TRIG_SEL_SHIFT;\r\nif (!on) {\r\nval |= TRIG_DIS;\r\nmutex_lock(&clock->extreg_lock);\r\next_write(0, phydev, PAGE5, PTP_TRIG, ptp_trig);\r\next_write(0, phydev, PAGE4, PTP_CTL, val);\r\nmutex_unlock(&clock->extreg_lock);\r\nreturn 0;\r\n}\r\nsec = clkreq->perout.start.sec;\r\nnsec = clkreq->perout.start.nsec;\r\npwidth = clkreq->perout.period.sec * 1000000000UL;\r\npwidth += clkreq->perout.period.nsec;\r\npwidth /= 2;\r\nmutex_lock(&clock->extreg_lock);\r\next_write(0, phydev, PAGE5, PTP_TRIG, ptp_trig);\r\nval |= TRIG_LOAD;\r\next_write(0, phydev, PAGE4, PTP_CTL, val);\r\next_write(0, phydev, PAGE4, PTP_TDR, nsec & 0xffff);\r\next_write(0, phydev, PAGE4, PTP_TDR, nsec >> 16);\r\next_write(0, phydev, PAGE4, PTP_TDR, sec & 0xffff);\r\next_write(0, phydev, PAGE4, PTP_TDR, sec >> 16);\r\next_write(0, phydev, PAGE4, PTP_TDR, pwidth & 0xffff);\r\next_write(0, phydev, PAGE4, PTP_TDR, pwidth >> 16);\r\nif (trigger < 2) {\r\next_write(0, phydev, PAGE4, PTP_TDR, pwidth & 0xffff);\r\next_write(0, phydev, PAGE4, PTP_TDR, pwidth >> 16);\r\n}\r\nval &= ~TRIG_LOAD;\r\nval |= TRIG_EN;\r\next_write(0, phydev, PAGE4, PTP_CTL, val);\r\nmutex_unlock(&clock->extreg_lock);\r\nreturn 0;\r\n}\r\nstatic int ptp_dp83640_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct dp83640_clock *clock =\r\ncontainer_of(ptp, struct dp83640_clock, caps);\r\nstruct phy_device *phydev = clock->chosen->phydev;\r\nu64 rate;\r\nint neg_adj = 0;\r\nu16 hi, lo;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nrate = ppb;\r\nrate <<= 26;\r\nrate = div_u64(rate, 1953125);\r\nhi = (rate >> 16) & PTP_RATE_HI_MASK;\r\nif (neg_adj)\r\nhi |= PTP_RATE_DIR;\r\nlo = rate & 0xffff;\r\nmutex_lock(&clock->extreg_lock);\r\next_write(1, phydev, PAGE4, PTP_RATEH, hi);\r\next_write(1, phydev, PAGE4, PTP_RATEL, lo);\r\nmutex_unlock(&clock->extreg_lock);\r\nreturn 0;\r\n}\r\nstatic int ptp_dp83640_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct dp83640_clock *clock =\r\ncontainer_of(ptp, struct dp83640_clock, caps);\r\nstruct phy_device *phydev = clock->chosen->phydev;\r\nstruct timespec64 ts;\r\nint err;\r\ndelta += ADJTIME_FIX;\r\nts = ns_to_timespec64(delta);\r\nmutex_lock(&clock->extreg_lock);\r\nerr = tdr_write(1, phydev, &ts, PTP_STEP_CLK);\r\nmutex_unlock(&clock->extreg_lock);\r\nreturn err;\r\n}\r\nstatic int ptp_dp83640_gettime(struct ptp_clock_info *ptp,\r\nstruct timespec64 *ts)\r\n{\r\nstruct dp83640_clock *clock =\r\ncontainer_of(ptp, struct dp83640_clock, caps);\r\nstruct phy_device *phydev = clock->chosen->phydev;\r\nunsigned int val[4];\r\nmutex_lock(&clock->extreg_lock);\r\next_write(0, phydev, PAGE4, PTP_CTL, PTP_RD_CLK);\r\nval[0] = ext_read(phydev, PAGE4, PTP_TDR);\r\nval[1] = ext_read(phydev, PAGE4, PTP_TDR);\r\nval[2] = ext_read(phydev, PAGE4, PTP_TDR);\r\nval[3] = ext_read(phydev, PAGE4, PTP_TDR);\r\nmutex_unlock(&clock->extreg_lock);\r\nts->tv_nsec = val[0] | (val[1] << 16);\r\nts->tv_sec = val[2] | (val[3] << 16);\r\nreturn 0;\r\n}\r\nstatic int ptp_dp83640_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct dp83640_clock *clock =\r\ncontainer_of(ptp, struct dp83640_clock, caps);\r\nstruct phy_device *phydev = clock->chosen->phydev;\r\nint err;\r\nmutex_lock(&clock->extreg_lock);\r\nerr = tdr_write(1, phydev, ts, PTP_LOAD_CLK);\r\nmutex_unlock(&clock->extreg_lock);\r\nreturn err;\r\n}\r\nstatic int ptp_dp83640_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct dp83640_clock *clock =\r\ncontainer_of(ptp, struct dp83640_clock, caps);\r\nstruct phy_device *phydev = clock->chosen->phydev;\r\nunsigned int index;\r\nu16 evnt, event_num, gpio_num;\r\nswitch (rq->type) {\r\ncase PTP_CLK_REQ_EXTTS:\r\nindex = rq->extts.index;\r\nif (index >= N_EXT_TS)\r\nreturn -EINVAL;\r\nevent_num = EXT_EVENT + index;\r\nevnt = EVNT_WR | (event_num & EVNT_SEL_MASK) << EVNT_SEL_SHIFT;\r\nif (on) {\r\ngpio_num = 1 + ptp_find_pin(clock->ptp_clock,\r\nPTP_PF_EXTTS, index);\r\nif (gpio_num < 1)\r\nreturn -EINVAL;\r\nevnt |= (gpio_num & EVNT_GPIO_MASK) << EVNT_GPIO_SHIFT;\r\nif (rq->extts.flags & PTP_FALLING_EDGE)\r\nevnt |= EVNT_FALL;\r\nelse\r\nevnt |= EVNT_RISE;\r\n}\r\nmutex_lock(&clock->extreg_lock);\r\next_write(0, phydev, PAGE5, PTP_EVNT, evnt);\r\nmutex_unlock(&clock->extreg_lock);\r\nreturn 0;\r\ncase PTP_CLK_REQ_PEROUT:\r\nif (rq->perout.index >= N_PER_OUT)\r\nreturn -EINVAL;\r\nreturn periodic_output(clock, rq, on, rq->perout.index);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ptp_dp83640_verify(struct ptp_clock_info *ptp, unsigned int pin,\r\nenum ptp_pin_function func, unsigned int chan)\r\n{\r\nstruct dp83640_clock *clock =\r\ncontainer_of(ptp, struct dp83640_clock, caps);\r\nif (clock->caps.pin_config[pin].func == PTP_PF_PHYSYNC &&\r\n!list_empty(&clock->phylist))\r\nreturn 1;\r\nif (func == PTP_PF_PHYSYNC)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void enable_status_frames(struct phy_device *phydev, bool on)\r\n{\r\nstruct dp83640_private *dp83640 = phydev->priv;\r\nstruct dp83640_clock *clock = dp83640->clock;\r\nu16 cfg0 = 0, ver;\r\nif (on)\r\ncfg0 = PSF_EVNT_EN | PSF_RXTS_EN | PSF_TXTS_EN | ENDIAN_FLAG;\r\nver = (PSF_PTPVER & VERSIONPTP_MASK) << VERSIONPTP_SHIFT;\r\nmutex_lock(&clock->extreg_lock);\r\next_write(0, phydev, PAGE5, PSF_CFG0, cfg0);\r\next_write(0, phydev, PAGE6, PSF_CFG1, ver);\r\nmutex_unlock(&clock->extreg_lock);\r\nif (!phydev->attached_dev) {\r\npr_warn("expected to find an attached netdevice\n");\r\nreturn;\r\n}\r\nif (on) {\r\nif (dev_mc_add(phydev->attached_dev, status_frame_dst))\r\npr_warn("failed to add mc address\n");\r\n} else {\r\nif (dev_mc_del(phydev->attached_dev, status_frame_dst))\r\npr_warn("failed to delete mc address\n");\r\n}\r\n}\r\nstatic bool is_status_frame(struct sk_buff *skb, int type)\r\n{\r\nstruct ethhdr *h = eth_hdr(skb);\r\nif (PTP_CLASS_V2_L2 == type &&\r\n!memcmp(h->h_source, status_frame_src, sizeof(status_frame_src)))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int expired(struct rxts *rxts)\r\n{\r\nreturn time_after(jiffies, rxts->tmo);\r\n}\r\nstatic void prune_rx_ts(struct dp83640_private *dp83640)\r\n{\r\nstruct list_head *this, *next;\r\nstruct rxts *rxts;\r\nlist_for_each_safe(this, next, &dp83640->rxts) {\r\nrxts = list_entry(this, struct rxts, list);\r\nif (expired(rxts)) {\r\nlist_del_init(&rxts->list);\r\nlist_add(&rxts->list, &dp83640->rxpool);\r\n}\r\n}\r\n}\r\nstatic void enable_broadcast(struct phy_device *phydev, int init_page, int on)\r\n{\r\nint val;\r\nphy_write(phydev, PAGESEL, 0);\r\nval = phy_read(phydev, PHYCR2);\r\nif (on)\r\nval |= BC_WRITE;\r\nelse\r\nval &= ~BC_WRITE;\r\nphy_write(phydev, PHYCR2, val);\r\nphy_write(phydev, PAGESEL, init_page);\r\n}\r\nstatic void recalibrate(struct dp83640_clock *clock)\r\n{\r\ns64 now, diff;\r\nstruct phy_txts event_ts;\r\nstruct timespec64 ts;\r\nstruct list_head *this;\r\nstruct dp83640_private *tmp;\r\nstruct phy_device *master = clock->chosen->phydev;\r\nu16 cal_gpio, cfg0, evnt, ptp_trig, trigger, val;\r\ntrigger = CAL_TRIGGER;\r\ncal_gpio = 1 + ptp_find_pin(clock->ptp_clock, PTP_PF_PHYSYNC, 0);\r\nif (cal_gpio < 1) {\r\npr_err("PHY calibration pin not available - PHY is not calibrated.");\r\nreturn;\r\n}\r\nmutex_lock(&clock->extreg_lock);\r\nlist_for_each(this, &clock->phylist) {\r\ntmp = list_entry(this, struct dp83640_private, list);\r\nenable_broadcast(tmp->phydev, clock->page, 1);\r\ntmp->cfg0 = ext_read(tmp->phydev, PAGE5, PSF_CFG0);\r\next_write(0, tmp->phydev, PAGE5, PSF_CFG0, 0);\r\next_write(0, tmp->phydev, PAGE4, PTP_CTL, PTP_ENABLE);\r\n}\r\nenable_broadcast(master, clock->page, 1);\r\ncfg0 = ext_read(master, PAGE5, PSF_CFG0);\r\next_write(0, master, PAGE5, PSF_CFG0, 0);\r\next_write(0, master, PAGE4, PTP_CTL, PTP_ENABLE);\r\nevnt = EVNT_WR | EVNT_RISE | EVNT_SINGLE;\r\nevnt |= (CAL_EVENT & EVNT_SEL_MASK) << EVNT_SEL_SHIFT;\r\nevnt |= (cal_gpio & EVNT_GPIO_MASK) << EVNT_GPIO_SHIFT;\r\nlist_for_each(this, &clock->phylist) {\r\ntmp = list_entry(this, struct dp83640_private, list);\r\next_write(0, tmp->phydev, PAGE5, PTP_EVNT, evnt);\r\n}\r\next_write(0, master, PAGE5, PTP_EVNT, evnt);\r\nptp_trig = TRIG_WR | TRIG_IF_LATE | TRIG_PULSE;\r\nptp_trig |= (trigger & TRIG_CSEL_MASK) << TRIG_CSEL_SHIFT;\r\nptp_trig |= (cal_gpio & TRIG_GPIO_MASK) << TRIG_GPIO_SHIFT;\r\next_write(0, master, PAGE5, PTP_TRIG, ptp_trig);\r\nval = (trigger & TRIG_SEL_MASK) << TRIG_SEL_SHIFT;\r\nval |= TRIG_LOAD;\r\next_write(0, master, PAGE4, PTP_CTL, val);\r\nval &= ~TRIG_LOAD;\r\nval |= TRIG_EN;\r\next_write(0, master, PAGE4, PTP_CTL, val);\r\nval = (trigger & TRIG_SEL_MASK) << TRIG_SEL_SHIFT;\r\nval |= TRIG_DIS;\r\next_write(0, master, PAGE4, PTP_CTL, val);\r\nval = ext_read(master, PAGE4, PTP_STS);\r\npr_info("master PTP_STS 0x%04hx\n", val);\r\nval = ext_read(master, PAGE4, PTP_ESTS);\r\npr_info("master PTP_ESTS 0x%04hx\n", val);\r\nevent_ts.ns_lo = ext_read(master, PAGE4, PTP_EDATA);\r\nevent_ts.ns_hi = ext_read(master, PAGE4, PTP_EDATA);\r\nevent_ts.sec_lo = ext_read(master, PAGE4, PTP_EDATA);\r\nevent_ts.sec_hi = ext_read(master, PAGE4, PTP_EDATA);\r\nnow = phy2txts(&event_ts);\r\nlist_for_each(this, &clock->phylist) {\r\ntmp = list_entry(this, struct dp83640_private, list);\r\nval = ext_read(tmp->phydev, PAGE4, PTP_STS);\r\npr_info("slave PTP_STS 0x%04hx\n", val);\r\nval = ext_read(tmp->phydev, PAGE4, PTP_ESTS);\r\npr_info("slave PTP_ESTS 0x%04hx\n", val);\r\nevent_ts.ns_lo = ext_read(tmp->phydev, PAGE4, PTP_EDATA);\r\nevent_ts.ns_hi = ext_read(tmp->phydev, PAGE4, PTP_EDATA);\r\nevent_ts.sec_lo = ext_read(tmp->phydev, PAGE4, PTP_EDATA);\r\nevent_ts.sec_hi = ext_read(tmp->phydev, PAGE4, PTP_EDATA);\r\ndiff = now - (s64) phy2txts(&event_ts);\r\npr_info("slave offset %lld nanoseconds\n", diff);\r\ndiff += ADJTIME_FIX;\r\nts = ns_to_timespec64(diff);\r\ntdr_write(0, tmp->phydev, &ts, PTP_STEP_CLK);\r\n}\r\nlist_for_each(this, &clock->phylist) {\r\ntmp = list_entry(this, struct dp83640_private, list);\r\next_write(0, tmp->phydev, PAGE5, PSF_CFG0, tmp->cfg0);\r\n}\r\next_write(0, master, PAGE5, PSF_CFG0, cfg0);\r\nmutex_unlock(&clock->extreg_lock);\r\n}\r\nstatic inline u16 exts_chan_to_edata(int ch)\r\n{\r\nreturn 1 << ((ch + EXT_EVENT) * 2);\r\n}\r\nstatic int decode_evnt(struct dp83640_private *dp83640,\r\nvoid *data, int len, u16 ests)\r\n{\r\nstruct phy_txts *phy_txts;\r\nstruct ptp_clock_event event;\r\nint i, parsed;\r\nint words = (ests >> EVNT_TS_LEN_SHIFT) & EVNT_TS_LEN_MASK;\r\nu16 ext_status = 0;\r\nif (ests & MULT_EVNT)\r\nparsed = (words + 2) * sizeof(u16);\r\nelse\r\nparsed = (words + 1) * sizeof(u16);\r\nif (len < parsed)\r\nreturn len;\r\nif (ests & MULT_EVNT) {\r\next_status = *(u16 *) data;\r\ndata += sizeof(ext_status);\r\n}\r\nphy_txts = data;\r\nswitch (words) {\r\ncase 3:\r\ndp83640->edata.sec_hi = phy_txts->sec_hi;\r\ncase 2:\r\ndp83640->edata.sec_lo = phy_txts->sec_lo;\r\ncase 1:\r\ndp83640->edata.ns_hi = phy_txts->ns_hi;\r\ncase 0:\r\ndp83640->edata.ns_lo = phy_txts->ns_lo;\r\n}\r\nif (!ext_status) {\r\ni = ((ests >> EVNT_NUM_SHIFT) & EVNT_NUM_MASK) - EXT_EVENT;\r\next_status = exts_chan_to_edata(i);\r\n}\r\nevent.type = PTP_CLOCK_EXTTS;\r\nevent.timestamp = phy2txts(&dp83640->edata);\r\nevent.timestamp -= 35;\r\nfor (i = 0; i < N_EXT_TS; i++) {\r\nif (ext_status & exts_chan_to_edata(i)) {\r\nevent.index = i;\r\nptp_clock_event(dp83640->clock->ptp_clock, &event);\r\n}\r\n}\r\nreturn parsed;\r\n}\r\nstatic int match(struct sk_buff *skb, unsigned int type, struct rxts *rxts)\r\n{\r\nu16 *seqid, hash;\r\nunsigned int offset = 0;\r\nu8 *msgtype, *data = skb_mac_header(skb);\r\nif (type & PTP_CLASS_VLAN)\r\noffset += VLAN_HLEN;\r\nswitch (type & PTP_CLASS_PMASK) {\r\ncase PTP_CLASS_IPV4:\r\noffset += ETH_HLEN + IPV4_HLEN(data + offset) + UDP_HLEN;\r\nbreak;\r\ncase PTP_CLASS_IPV6:\r\noffset += ETH_HLEN + IP6_HLEN + UDP_HLEN;\r\nbreak;\r\ncase PTP_CLASS_L2:\r\noffset += ETH_HLEN;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (skb->len + ETH_HLEN < offset + OFF_PTP_SEQUENCE_ID + sizeof(*seqid))\r\nreturn 0;\r\nif (unlikely(type & PTP_CLASS_V1))\r\nmsgtype = data + offset + OFF_PTP_CONTROL;\r\nelse\r\nmsgtype = data + offset;\r\nif (rxts->msgtype != (*msgtype & 0xf))\r\nreturn 0;\r\nseqid = (u16 *)(data + offset + OFF_PTP_SEQUENCE_ID);\r\nif (rxts->seqid != ntohs(*seqid))\r\nreturn 0;\r\nhash = ether_crc(DP83640_PACKET_HASH_LEN,\r\ndata + offset + DP83640_PACKET_HASH_OFFSET) >> 20;\r\nif (rxts->hash != hash)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void decode_rxts(struct dp83640_private *dp83640,\r\nstruct phy_rxts *phy_rxts)\r\n{\r\nstruct rxts *rxts;\r\nstruct skb_shared_hwtstamps *shhwtstamps = NULL;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nu8 overflow;\r\noverflow = (phy_rxts->ns_hi >> 14) & 0x3;\r\nif (overflow)\r\npr_debug("rx timestamp queue overflow, count %d\n", overflow);\r\nspin_lock_irqsave(&dp83640->rx_lock, flags);\r\nprune_rx_ts(dp83640);\r\nif (list_empty(&dp83640->rxpool)) {\r\npr_debug("rx timestamp pool is empty\n");\r\ngoto out;\r\n}\r\nrxts = list_first_entry(&dp83640->rxpool, struct rxts, list);\r\nlist_del_init(&rxts->list);\r\nphy2rxts(phy_rxts, rxts);\r\nspin_lock(&dp83640->rx_queue.lock);\r\nskb_queue_walk(&dp83640->rx_queue, skb) {\r\nstruct dp83640_skb_info *skb_info;\r\nskb_info = (struct dp83640_skb_info *)skb->cb;\r\nif (match(skb, skb_info->ptp_type, rxts)) {\r\n__skb_unlink(skb, &dp83640->rx_queue);\r\nshhwtstamps = skb_hwtstamps(skb);\r\nmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\r\nshhwtstamps->hwtstamp = ns_to_ktime(rxts->ns);\r\nnetif_rx_ni(skb);\r\nlist_add(&rxts->list, &dp83640->rxpool);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dp83640->rx_queue.lock);\r\nif (!shhwtstamps)\r\nlist_add_tail(&rxts->list, &dp83640->rxts);\r\nout:\r\nspin_unlock_irqrestore(&dp83640->rx_lock, flags);\r\n}\r\nstatic void decode_txts(struct dp83640_private *dp83640,\r\nstruct phy_txts *phy_txts)\r\n{\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nstruct sk_buff *skb;\r\nu64 ns;\r\nu8 overflow;\r\nskb = skb_dequeue(&dp83640->tx_queue);\r\nif (!skb) {\r\npr_debug("have timestamp but tx_queue empty\n");\r\nreturn;\r\n}\r\noverflow = (phy_txts->ns_hi >> 14) & 0x3;\r\nif (overflow) {\r\npr_debug("tx timestamp queue overflow, count %d\n", overflow);\r\nwhile (skb) {\r\nskb_complete_tx_timestamp(skb, NULL);\r\nskb = skb_dequeue(&dp83640->tx_queue);\r\n}\r\nreturn;\r\n}\r\nns = phy2txts(phy_txts);\r\nmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\r\nshhwtstamps.hwtstamp = ns_to_ktime(ns);\r\nskb_complete_tx_timestamp(skb, &shhwtstamps);\r\n}\r\nstatic void decode_status_frame(struct dp83640_private *dp83640,\r\nstruct sk_buff *skb)\r\n{\r\nstruct phy_rxts *phy_rxts;\r\nstruct phy_txts *phy_txts;\r\nu8 *ptr;\r\nint len, size;\r\nu16 ests, type;\r\nptr = skb->data + 2;\r\nfor (len = skb_headlen(skb) - 2; len > sizeof(type); len -= size) {\r\ntype = *(u16 *)ptr;\r\nests = type & 0x0fff;\r\ntype = type & 0xf000;\r\nlen -= sizeof(type);\r\nptr += sizeof(type);\r\nif (PSF_RX == type && len >= sizeof(*phy_rxts)) {\r\nphy_rxts = (struct phy_rxts *) ptr;\r\ndecode_rxts(dp83640, phy_rxts);\r\nsize = sizeof(*phy_rxts);\r\n} else if (PSF_TX == type && len >= sizeof(*phy_txts)) {\r\nphy_txts = (struct phy_txts *) ptr;\r\ndecode_txts(dp83640, phy_txts);\r\nsize = sizeof(*phy_txts);\r\n} else if (PSF_EVNT == type) {\r\nsize = decode_evnt(dp83640, ptr, len, ests);\r\n} else {\r\nsize = 0;\r\nbreak;\r\n}\r\nptr += size;\r\n}\r\n}\r\nstatic int is_sync(struct sk_buff *skb, int type)\r\n{\r\nu8 *data = skb->data, *msgtype;\r\nunsigned int offset = 0;\r\nif (type & PTP_CLASS_VLAN)\r\noffset += VLAN_HLEN;\r\nswitch (type & PTP_CLASS_PMASK) {\r\ncase PTP_CLASS_IPV4:\r\noffset += ETH_HLEN + IPV4_HLEN(data + offset) + UDP_HLEN;\r\nbreak;\r\ncase PTP_CLASS_IPV6:\r\noffset += ETH_HLEN + IP6_HLEN + UDP_HLEN;\r\nbreak;\r\ncase PTP_CLASS_L2:\r\noffset += ETH_HLEN;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (type & PTP_CLASS_V1)\r\noffset += OFF_PTP_CONTROL;\r\nif (skb->len < offset + 1)\r\nreturn 0;\r\nmsgtype = data + offset;\r\nreturn (*msgtype & 0xf) == 0;\r\n}\r\nstatic void dp83640_free_clocks(void)\r\n{\r\nstruct dp83640_clock *clock;\r\nstruct list_head *this, *next;\r\nmutex_lock(&phyter_clocks_lock);\r\nlist_for_each_safe(this, next, &phyter_clocks) {\r\nclock = list_entry(this, struct dp83640_clock, list);\r\nif (!list_empty(&clock->phylist)) {\r\npr_warn("phy list non-empty while unloading\n");\r\nBUG();\r\n}\r\nlist_del(&clock->list);\r\nmutex_destroy(&clock->extreg_lock);\r\nmutex_destroy(&clock->clock_lock);\r\nput_device(&clock->bus->dev);\r\nkfree(clock->caps.pin_config);\r\nkfree(clock);\r\n}\r\nmutex_unlock(&phyter_clocks_lock);\r\n}\r\nstatic void dp83640_clock_init(struct dp83640_clock *clock, struct mii_bus *bus)\r\n{\r\nINIT_LIST_HEAD(&clock->list);\r\nclock->bus = bus;\r\nmutex_init(&clock->extreg_lock);\r\nmutex_init(&clock->clock_lock);\r\nINIT_LIST_HEAD(&clock->phylist);\r\nclock->caps.owner = THIS_MODULE;\r\nsprintf(clock->caps.name, "dp83640 timer");\r\nclock->caps.max_adj = 1953124;\r\nclock->caps.n_alarm = 0;\r\nclock->caps.n_ext_ts = N_EXT_TS;\r\nclock->caps.n_per_out = N_PER_OUT;\r\nclock->caps.n_pins = DP83640_N_PINS;\r\nclock->caps.pps = 0;\r\nclock->caps.adjfreq = ptp_dp83640_adjfreq;\r\nclock->caps.adjtime = ptp_dp83640_adjtime;\r\nclock->caps.gettime64 = ptp_dp83640_gettime;\r\nclock->caps.settime64 = ptp_dp83640_settime;\r\nclock->caps.enable = ptp_dp83640_enable;\r\nclock->caps.verify = ptp_dp83640_verify;\r\ndp83640_gpio_defaults(clock->caps.pin_config);\r\nget_device(&bus->dev);\r\n}\r\nstatic int choose_this_phy(struct dp83640_clock *clock,\r\nstruct phy_device *phydev)\r\n{\r\nif (chosen_phy == -1 && !clock->chosen)\r\nreturn 1;\r\nif (chosen_phy == phydev->mdio.addr)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct dp83640_clock *dp83640_clock_get(struct dp83640_clock *clock)\r\n{\r\nif (clock)\r\nmutex_lock(&clock->clock_lock);\r\nreturn clock;\r\n}\r\nstatic struct dp83640_clock *dp83640_clock_get_bus(struct mii_bus *bus)\r\n{\r\nstruct dp83640_clock *clock = NULL, *tmp;\r\nstruct list_head *this;\r\nmutex_lock(&phyter_clocks_lock);\r\nlist_for_each(this, &phyter_clocks) {\r\ntmp = list_entry(this, struct dp83640_clock, list);\r\nif (tmp->bus == bus) {\r\nclock = tmp;\r\nbreak;\r\n}\r\n}\r\nif (clock)\r\ngoto out;\r\nclock = kzalloc(sizeof(struct dp83640_clock), GFP_KERNEL);\r\nif (!clock)\r\ngoto out;\r\nclock->caps.pin_config = kzalloc(sizeof(struct ptp_pin_desc) *\r\nDP83640_N_PINS, GFP_KERNEL);\r\nif (!clock->caps.pin_config) {\r\nkfree(clock);\r\nclock = NULL;\r\ngoto out;\r\n}\r\ndp83640_clock_init(clock, bus);\r\nlist_add_tail(&phyter_clocks, &clock->list);\r\nout:\r\nmutex_unlock(&phyter_clocks_lock);\r\nreturn dp83640_clock_get(clock);\r\n}\r\nstatic void dp83640_clock_put(struct dp83640_clock *clock)\r\n{\r\nmutex_unlock(&clock->clock_lock);\r\n}\r\nstatic int dp83640_probe(struct phy_device *phydev)\r\n{\r\nstruct dp83640_clock *clock;\r\nstruct dp83640_private *dp83640;\r\nint err = -ENOMEM, i;\r\nif (phydev->mdio.addr == BROADCAST_ADDR)\r\nreturn 0;\r\nclock = dp83640_clock_get_bus(phydev->mdio.bus);\r\nif (!clock)\r\ngoto no_clock;\r\ndp83640 = kzalloc(sizeof(struct dp83640_private), GFP_KERNEL);\r\nif (!dp83640)\r\ngoto no_memory;\r\ndp83640->phydev = phydev;\r\nINIT_DELAYED_WORK(&dp83640->ts_work, rx_timestamp_work);\r\nINIT_LIST_HEAD(&dp83640->rxts);\r\nINIT_LIST_HEAD(&dp83640->rxpool);\r\nfor (i = 0; i < MAX_RXTS; i++)\r\nlist_add(&dp83640->rx_pool_data[i].list, &dp83640->rxpool);\r\nphydev->priv = dp83640;\r\nspin_lock_init(&dp83640->rx_lock);\r\nskb_queue_head_init(&dp83640->rx_queue);\r\nskb_queue_head_init(&dp83640->tx_queue);\r\ndp83640->clock = clock;\r\nif (choose_this_phy(clock, phydev)) {\r\nclock->chosen = dp83640;\r\nclock->ptp_clock = ptp_clock_register(&clock->caps,\r\n&phydev->mdio.dev);\r\nif (IS_ERR(clock->ptp_clock)) {\r\nerr = PTR_ERR(clock->ptp_clock);\r\ngoto no_register;\r\n}\r\n} else\r\nlist_add_tail(&dp83640->list, &clock->phylist);\r\ndp83640_clock_put(clock);\r\nreturn 0;\r\nno_register:\r\nclock->chosen = NULL;\r\nkfree(dp83640);\r\nno_memory:\r\ndp83640_clock_put(clock);\r\nno_clock:\r\nreturn err;\r\n}\r\nstatic void dp83640_remove(struct phy_device *phydev)\r\n{\r\nstruct dp83640_clock *clock;\r\nstruct list_head *this, *next;\r\nstruct dp83640_private *tmp, *dp83640 = phydev->priv;\r\nif (phydev->mdio.addr == BROADCAST_ADDR)\r\nreturn;\r\nenable_status_frames(phydev, false);\r\ncancel_delayed_work_sync(&dp83640->ts_work);\r\nskb_queue_purge(&dp83640->rx_queue);\r\nskb_queue_purge(&dp83640->tx_queue);\r\nclock = dp83640_clock_get(dp83640->clock);\r\nif (dp83640 == clock->chosen) {\r\nptp_clock_unregister(clock->ptp_clock);\r\nclock->chosen = NULL;\r\n} else {\r\nlist_for_each_safe(this, next, &clock->phylist) {\r\ntmp = list_entry(this, struct dp83640_private, list);\r\nif (tmp == dp83640) {\r\nlist_del_init(&tmp->list);\r\nbreak;\r\n}\r\n}\r\n}\r\ndp83640_clock_put(clock);\r\nkfree(dp83640);\r\n}\r\nstatic int dp83640_config_init(struct phy_device *phydev)\r\n{\r\nstruct dp83640_private *dp83640 = phydev->priv;\r\nstruct dp83640_clock *clock = dp83640->clock;\r\nif (clock->chosen && !list_empty(&clock->phylist))\r\nrecalibrate(clock);\r\nelse {\r\nmutex_lock(&clock->extreg_lock);\r\nenable_broadcast(phydev, clock->page, 1);\r\nmutex_unlock(&clock->extreg_lock);\r\n}\r\nenable_status_frames(phydev, true);\r\nmutex_lock(&clock->extreg_lock);\r\next_write(0, phydev, PAGE4, PTP_CTL, PTP_ENABLE);\r\nmutex_unlock(&clock->extreg_lock);\r\nreturn 0;\r\n}\r\nstatic int dp83640_ack_interrupt(struct phy_device *phydev)\r\n{\r\nint err = phy_read(phydev, MII_DP83640_MISR);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int dp83640_config_intr(struct phy_device *phydev)\r\n{\r\nint micr;\r\nint misr;\r\nint err;\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\r\nmisr = phy_read(phydev, MII_DP83640_MISR);\r\nif (misr < 0)\r\nreturn misr;\r\nmisr |=\r\n(MII_DP83640_MISR_ANC_INT_EN |\r\nMII_DP83640_MISR_DUP_INT_EN |\r\nMII_DP83640_MISR_SPD_INT_EN |\r\nMII_DP83640_MISR_LINK_INT_EN);\r\nerr = phy_write(phydev, MII_DP83640_MISR, misr);\r\nif (err < 0)\r\nreturn err;\r\nmicr = phy_read(phydev, MII_DP83640_MICR);\r\nif (micr < 0)\r\nreturn micr;\r\nmicr |=\r\n(MII_DP83640_MICR_OE |\r\nMII_DP83640_MICR_IE);\r\nreturn phy_write(phydev, MII_DP83640_MICR, micr);\r\n} else {\r\nmicr = phy_read(phydev, MII_DP83640_MICR);\r\nif (micr < 0)\r\nreturn micr;\r\nmicr &=\r\n~(MII_DP83640_MICR_OE |\r\nMII_DP83640_MICR_IE);\r\nerr = phy_write(phydev, MII_DP83640_MICR, micr);\r\nif (err < 0)\r\nreturn err;\r\nmisr = phy_read(phydev, MII_DP83640_MISR);\r\nif (misr < 0)\r\nreturn misr;\r\nmisr &=\r\n~(MII_DP83640_MISR_ANC_INT_EN |\r\nMII_DP83640_MISR_DUP_INT_EN |\r\nMII_DP83640_MISR_SPD_INT_EN |\r\nMII_DP83640_MISR_LINK_INT_EN);\r\nreturn phy_write(phydev, MII_DP83640_MISR, misr);\r\n}\r\n}\r\nstatic int dp83640_hwtstamp(struct phy_device *phydev, struct ifreq *ifr)\r\n{\r\nstruct dp83640_private *dp83640 = phydev->priv;\r\nstruct hwtstamp_config cfg;\r\nu16 txcfg0, rxcfg0;\r\nif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\r\nreturn -EFAULT;\r\nif (cfg.flags)\r\nreturn -EINVAL;\r\nif (cfg.tx_type < 0 || cfg.tx_type > HWTSTAMP_TX_ONESTEP_SYNC)\r\nreturn -ERANGE;\r\ndp83640->hwts_tx_en = cfg.tx_type;\r\nswitch (cfg.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ndp83640->hwts_rx_en = 0;\r\ndp83640->layer = 0;\r\ndp83640->version = 0;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ndp83640->hwts_rx_en = 1;\r\ndp83640->layer = PTP_CLASS_L4;\r\ndp83640->version = PTP_CLASS_V1;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ndp83640->hwts_rx_en = 1;\r\ndp83640->layer = PTP_CLASS_L4;\r\ndp83640->version = PTP_CLASS_V2;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ndp83640->hwts_rx_en = 1;\r\ndp83640->layer = PTP_CLASS_L2;\r\ndp83640->version = PTP_CLASS_V2;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ndp83640->hwts_rx_en = 1;\r\ndp83640->layer = PTP_CLASS_L4 | PTP_CLASS_L2;\r\ndp83640->version = PTP_CLASS_V2;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\ntxcfg0 = (dp83640->version & TX_PTP_VER_MASK) << TX_PTP_VER_SHIFT;\r\nrxcfg0 = (dp83640->version & TX_PTP_VER_MASK) << TX_PTP_VER_SHIFT;\r\nif (dp83640->layer & PTP_CLASS_L2) {\r\ntxcfg0 |= TX_L2_EN;\r\nrxcfg0 |= RX_L2_EN;\r\n}\r\nif (dp83640->layer & PTP_CLASS_L4) {\r\ntxcfg0 |= TX_IPV6_EN | TX_IPV4_EN;\r\nrxcfg0 |= RX_IPV6_EN | RX_IPV4_EN;\r\n}\r\nif (dp83640->hwts_tx_en)\r\ntxcfg0 |= TX_TS_EN;\r\nif (dp83640->hwts_tx_en == HWTSTAMP_TX_ONESTEP_SYNC)\r\ntxcfg0 |= SYNC_1STEP | CHK_1STEP;\r\nif (dp83640->hwts_rx_en)\r\nrxcfg0 |= RX_TS_EN;\r\nmutex_lock(&dp83640->clock->extreg_lock);\r\next_write(0, phydev, PAGE5, PTP_TXCFG0, txcfg0);\r\next_write(0, phydev, PAGE5, PTP_RXCFG0, rxcfg0);\r\nmutex_unlock(&dp83640->clock->extreg_lock);\r\nreturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\r\n}\r\nstatic void rx_timestamp_work(struct work_struct *work)\r\n{\r\nstruct dp83640_private *dp83640 =\r\ncontainer_of(work, struct dp83640_private, ts_work.work);\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&dp83640->rx_queue))) {\r\nstruct dp83640_skb_info *skb_info;\r\nskb_info = (struct dp83640_skb_info *)skb->cb;\r\nif (!time_after(jiffies, skb_info->tmo)) {\r\nskb_queue_head(&dp83640->rx_queue, skb);\r\nbreak;\r\n}\r\nnetif_rx_ni(skb);\r\n}\r\nif (!skb_queue_empty(&dp83640->rx_queue))\r\nschedule_delayed_work(&dp83640->ts_work, SKB_TIMESTAMP_TIMEOUT);\r\n}\r\nstatic bool dp83640_rxtstamp(struct phy_device *phydev,\r\nstruct sk_buff *skb, int type)\r\n{\r\nstruct dp83640_private *dp83640 = phydev->priv;\r\nstruct dp83640_skb_info *skb_info = (struct dp83640_skb_info *)skb->cb;\r\nstruct list_head *this, *next;\r\nstruct rxts *rxts;\r\nstruct skb_shared_hwtstamps *shhwtstamps = NULL;\r\nunsigned long flags;\r\nif (is_status_frame(skb, type)) {\r\ndecode_status_frame(dp83640, skb);\r\nkfree_skb(skb);\r\nreturn true;\r\n}\r\nif (!dp83640->hwts_rx_en)\r\nreturn false;\r\nif ((type & dp83640->version) == 0 || (type & dp83640->layer) == 0)\r\nreturn false;\r\nspin_lock_irqsave(&dp83640->rx_lock, flags);\r\nprune_rx_ts(dp83640);\r\nlist_for_each_safe(this, next, &dp83640->rxts) {\r\nrxts = list_entry(this, struct rxts, list);\r\nif (match(skb, type, rxts)) {\r\nshhwtstamps = skb_hwtstamps(skb);\r\nmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\r\nshhwtstamps->hwtstamp = ns_to_ktime(rxts->ns);\r\nnetif_rx_ni(skb);\r\nlist_del_init(&rxts->list);\r\nlist_add(&rxts->list, &dp83640->rxpool);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dp83640->rx_lock, flags);\r\nif (!shhwtstamps) {\r\nskb_info->ptp_type = type;\r\nskb_info->tmo = jiffies + SKB_TIMESTAMP_TIMEOUT;\r\nskb_queue_tail(&dp83640->rx_queue, skb);\r\nschedule_delayed_work(&dp83640->ts_work, SKB_TIMESTAMP_TIMEOUT);\r\n} else {\r\nnetif_rx_ni(skb);\r\n}\r\nreturn true;\r\n}\r\nstatic void dp83640_txtstamp(struct phy_device *phydev,\r\nstruct sk_buff *skb, int type)\r\n{\r\nstruct dp83640_private *dp83640 = phydev->priv;\r\nswitch (dp83640->hwts_tx_en) {\r\ncase HWTSTAMP_TX_ONESTEP_SYNC:\r\nif (is_sync(skb, type)) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\ncase HWTSTAMP_TX_ON:\r\nskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\r\nskb_queue_tail(&dp83640->tx_queue, skb);\r\nbreak;\r\ncase HWTSTAMP_TX_OFF:\r\ndefault:\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\n}\r\nstatic int dp83640_ts_info(struct phy_device *dev, struct ethtool_ts_info *info)\r\n{\r\nstruct dp83640_private *dp83640 = dev->priv;\r\ninfo->so_timestamping =\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\ninfo->phc_index = ptp_clock_index(dp83640->clock->ptp_clock);\r\ninfo->tx_types =\r\n(1 << HWTSTAMP_TX_OFF) |\r\n(1 << HWTSTAMP_TX_ON) |\r\n(1 << HWTSTAMP_TX_ONESTEP_SYNC);\r\ninfo->rx_filters =\r\n(1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\r\nreturn 0;\r\n}\r\nstatic int __init dp83640_init(void)\r\n{\r\nreturn phy_driver_register(&dp83640_driver, THIS_MODULE);\r\n}\r\nstatic void __exit dp83640_exit(void)\r\n{\r\ndp83640_free_clocks();\r\nphy_driver_unregister(&dp83640_driver);\r\n}
