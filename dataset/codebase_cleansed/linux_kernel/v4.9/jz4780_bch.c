static void jz4780_bch_init(struct jz4780_bch *bch,\r\nstruct jz4780_bch_params *params, bool encode)\r\n{\r\nu32 reg;\r\nwritel(readl(bch->base + BCH_BHINT), bch->base + BCH_BHINT);\r\nreg = params->size << BCH_BHCNT_BLOCKSIZE_SHIFT;\r\nreg |= params->bytes << BCH_BHCNT_PARITYSIZE_SHIFT;\r\nwritel(reg, bch->base + BCH_BHCNT);\r\nreg = BCH_BHCR_BCHE | BCH_BHCR_INIT;\r\nreg |= params->strength << BCH_BHCR_BSEL_SHIFT;\r\nif (encode)\r\nreg |= BCH_BHCR_ENCE;\r\nwritel(reg, bch->base + BCH_BHCR);\r\n}\r\nstatic void jz4780_bch_disable(struct jz4780_bch *bch)\r\n{\r\nwritel(readl(bch->base + BCH_BHINT), bch->base + BCH_BHINT);\r\nwritel(BCH_BHCR_BCHE, bch->base + BCH_BHCCR);\r\n}\r\nstatic void jz4780_bch_write_data(struct jz4780_bch *bch, const void *buf,\r\nsize_t size)\r\n{\r\nsize_t size32 = size / sizeof(u32);\r\nsize_t size8 = size % sizeof(u32);\r\nconst u32 *src32;\r\nconst u8 *src8;\r\nsrc32 = (const u32 *)buf;\r\nwhile (size32--)\r\nwritel(*src32++, bch->base + BCH_BHDR);\r\nsrc8 = (const u8 *)src32;\r\nwhile (size8--)\r\nwriteb(*src8++, bch->base + BCH_BHDR);\r\n}\r\nstatic void jz4780_bch_read_parity(struct jz4780_bch *bch, void *buf,\r\nsize_t size)\r\n{\r\nsize_t size32 = size / sizeof(u32);\r\nsize_t size8 = size % sizeof(u32);\r\nu32 *dest32;\r\nu8 *dest8;\r\nu32 val, offset = 0;\r\ndest32 = (u32 *)buf;\r\nwhile (size32--) {\r\n*dest32++ = readl(bch->base + BCH_BHPAR0 + offset);\r\noffset += sizeof(u32);\r\n}\r\ndest8 = (u8 *)dest32;\r\nval = readl(bch->base + BCH_BHPAR0 + offset);\r\nswitch (size8) {\r\ncase 3:\r\ndest8[2] = (val >> 16) & 0xff;\r\ncase 2:\r\ndest8[1] = (val >> 8) & 0xff;\r\ncase 1:\r\ndest8[0] = val & 0xff;\r\nbreak;\r\n}\r\n}\r\nstatic bool jz4780_bch_wait_complete(struct jz4780_bch *bch, unsigned int irq,\r\nu32 *status)\r\n{\r\nu32 reg;\r\nint ret;\r\nret = readl_poll_timeout(bch->base + BCH_BHINT, reg,\r\n(reg & irq) == irq, 0, BCH_TIMEOUT_US);\r\nif (ret)\r\nreturn false;\r\nif (status)\r\n*status = reg;\r\nwritel(reg, bch->base + BCH_BHINT);\r\nreturn true;\r\n}\r\nint jz4780_bch_calculate(struct jz4780_bch *bch, struct jz4780_bch_params *params,\r\nconst u8 *buf, u8 *ecc_code)\r\n{\r\nint ret = 0;\r\nmutex_lock(&bch->lock);\r\njz4780_bch_init(bch, params, true);\r\njz4780_bch_write_data(bch, buf, params->size);\r\nif (jz4780_bch_wait_complete(bch, BCH_BHINT_ENCF, NULL)) {\r\njz4780_bch_read_parity(bch, ecc_code, params->bytes);\r\n} else {\r\ndev_err(bch->dev, "timed out while calculating ECC\n");\r\nret = -ETIMEDOUT;\r\n}\r\njz4780_bch_disable(bch);\r\nmutex_unlock(&bch->lock);\r\nreturn ret;\r\n}\r\nint jz4780_bch_correct(struct jz4780_bch *bch, struct jz4780_bch_params *params,\r\nu8 *buf, u8 *ecc_code)\r\n{\r\nu32 reg, mask, index;\r\nint i, ret, count;\r\nmutex_lock(&bch->lock);\r\njz4780_bch_init(bch, params, false);\r\njz4780_bch_write_data(bch, buf, params->size);\r\njz4780_bch_write_data(bch, ecc_code, params->bytes);\r\nif (!jz4780_bch_wait_complete(bch, BCH_BHINT_DECF, &reg)) {\r\ndev_err(bch->dev, "timed out while correcting data\n");\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nif (reg & BCH_BHINT_UNCOR) {\r\ndev_warn(bch->dev, "uncorrectable ECC error\n");\r\nret = -EBADMSG;\r\ngoto out;\r\n}\r\nif (reg & BCH_BHINT_ERR) {\r\ncount = (reg & BCH_BHINT_ERRC_MASK) >> BCH_BHINT_ERRC_SHIFT;\r\nret = (reg & BCH_BHINT_TERRC_MASK) >> BCH_BHINT_TERRC_SHIFT;\r\nfor (i = 0; i < count; i++) {\r\nreg = readl(bch->base + BCH_BHERR0 + (i * 4));\r\nmask = (reg & BCH_BHERR_MASK_MASK) >>\r\nBCH_BHERR_MASK_SHIFT;\r\nindex = (reg & BCH_BHERR_INDEX_MASK) >>\r\nBCH_BHERR_INDEX_SHIFT;\r\nbuf[(index * 2) + 0] ^= mask;\r\nbuf[(index * 2) + 1] ^= mask >> 8;\r\n}\r\n} else {\r\nret = 0;\r\n}\r\nout:\r\njz4780_bch_disable(bch);\r\nmutex_unlock(&bch->lock);\r\nreturn ret;\r\n}\r\nstatic struct jz4780_bch *jz4780_bch_get(struct device_node *np)\r\n{\r\nstruct platform_device *pdev;\r\nstruct jz4780_bch *bch;\r\npdev = of_find_device_by_node(np);\r\nif (!pdev || !platform_get_drvdata(pdev))\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\nget_device(&pdev->dev);\r\nbch = platform_get_drvdata(pdev);\r\nclk_prepare_enable(bch->clk);\r\nreturn bch;\r\n}\r\nstruct jz4780_bch *of_jz4780_bch_get(struct device_node *of_node)\r\n{\r\nstruct jz4780_bch *bch = NULL;\r\nstruct device_node *np;\r\nnp = of_parse_phandle(of_node, "ingenic,bch-controller", 0);\r\nif (np) {\r\nbch = jz4780_bch_get(np);\r\nof_node_put(np);\r\n}\r\nreturn bch;\r\n}\r\nvoid jz4780_bch_release(struct jz4780_bch *bch)\r\n{\r\nclk_disable_unprepare(bch->clk);\r\nput_device(bch->dev);\r\n}\r\nstatic int jz4780_bch_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct jz4780_bch *bch;\r\nstruct resource *res;\r\nbch = devm_kzalloc(dev, sizeof(*bch), GFP_KERNEL);\r\nif (!bch)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbch->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(bch->base))\r\nreturn PTR_ERR(bch->base);\r\njz4780_bch_disable(bch);\r\nbch->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(bch->clk)) {\r\ndev_err(dev, "failed to get clock: %ld\n", PTR_ERR(bch->clk));\r\nreturn PTR_ERR(bch->clk);\r\n}\r\nclk_set_rate(bch->clk, BCH_CLK_RATE);\r\nmutex_init(&bch->lock);\r\nbch->dev = dev;\r\nplatform_set_drvdata(pdev, bch);\r\nreturn 0;\r\n}
