static inline bool codec_has_acomp(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nreturn spec->use_acomp_notifier;\r\n}\r\nstatic int pin_nid_to_pin_index(struct hda_codec *codec, hda_nid_t pin_nid)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx;\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++)\r\nif (get_pin(spec, pin_idx)->pin_nid == pin_nid)\r\nreturn pin_idx;\r\ncodec_warn(codec, "HDMI: pin nid %d not registered\n", pin_nid);\r\nreturn -EINVAL;\r\n}\r\nstatic int hinfo_to_pcm_index(struct hda_codec *codec,\r\nstruct hda_pcm_stream *hinfo)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pcm_idx;\r\nfor (pcm_idx = 0; pcm_idx < spec->pcm_used; pcm_idx++)\r\nif (get_pcm_rec(spec, pcm_idx)->stream == hinfo)\r\nreturn pcm_idx;\r\ncodec_warn(codec, "HDMI: hinfo %p not registered\n", hinfo);\r\nreturn -EINVAL;\r\n}\r\nstatic int hinfo_to_pin_index(struct hda_codec *codec,\r\nstruct hda_pcm_stream *hinfo)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nint pin_idx;\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\r\nper_pin = get_pin(spec, pin_idx);\r\nif (per_pin->pcm &&\r\nper_pin->pcm->pcm->stream == hinfo)\r\nreturn pin_idx;\r\n}\r\ncodec_dbg(codec, "HDMI: hinfo %p not registered\n", hinfo);\r\nreturn -EINVAL;\r\n}\r\nstatic struct hdmi_spec_per_pin *pcm_idx_to_pin(struct hdmi_spec *spec,\r\nint pcm_idx)\r\n{\r\nint i;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nfor (i = 0; i < spec->num_pins; i++) {\r\nper_pin = get_pin(spec, i);\r\nif (per_pin->pcm_idx == pcm_idx)\r\nreturn per_pin;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int cvt_nid_to_cvt_index(struct hda_codec *codec, hda_nid_t cvt_nid)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint cvt_idx;\r\nfor (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++)\r\nif (get_cvt(spec, cvt_idx)->cvt_nid == cvt_nid)\r\nreturn cvt_idx;\r\ncodec_warn(codec, "HDMI: cvt nid %d not registered\n", cvt_nid);\r\nreturn -EINVAL;\r\n}\r\nstatic int hdmi_eld_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nstruct hdmi_eld *eld;\r\nint pcm_idx;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\npcm_idx = kcontrol->private_value;\r\nmutex_lock(&spec->pcm_lock);\r\nper_pin = pcm_idx_to_pin(spec, pcm_idx);\r\nif (!per_pin) {\r\nuinfo->count = 0;\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn 0;\r\n}\r\neld = &per_pin->sink_eld;\r\nuinfo->count = eld->eld_valid ? eld->eld_size : 0;\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn 0;\r\n}\r\nstatic int hdmi_eld_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nstruct hdmi_eld *eld;\r\nint pcm_idx;\r\npcm_idx = kcontrol->private_value;\r\nmutex_lock(&spec->pcm_lock);\r\nper_pin = pcm_idx_to_pin(spec, pcm_idx);\r\nif (!per_pin) {\r\nmemset(ucontrol->value.bytes.data, 0,\r\nARRAY_SIZE(ucontrol->value.bytes.data));\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn 0;\r\n}\r\neld = &per_pin->sink_eld;\r\nif (eld->eld_size > ARRAY_SIZE(ucontrol->value.bytes.data) ||\r\neld->eld_size > ELD_MAX_SIZE) {\r\nmutex_unlock(&spec->pcm_lock);\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nmemset(ucontrol->value.bytes.data, 0,\r\nARRAY_SIZE(ucontrol->value.bytes.data));\r\nif (eld->eld_valid)\r\nmemcpy(ucontrol->value.bytes.data, eld->eld_buffer,\r\neld->eld_size);\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn 0;\r\n}\r\nstatic int hdmi_create_eld_ctl(struct hda_codec *codec, int pcm_idx,\r\nint device)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nstruct hdmi_spec *spec = codec->spec;\r\nint err;\r\nkctl = snd_ctl_new1(&eld_bytes_ctl, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->private_value = pcm_idx;\r\nkctl->id.device = device;\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (err < 0)\r\nreturn err;\r\nget_hdmi_pcm(spec, pcm_idx)->eld_ctl = kctl;\r\nreturn 0;\r\n}\r\nstatic void hdmi_get_dip_index(struct hda_codec *codec, hda_nid_t pin_nid,\r\nint *packet_index, int *byte_index)\r\n{\r\nint val;\r\nval = snd_hda_codec_read(codec, pin_nid, 0,\r\nAC_VERB_GET_HDMI_DIP_INDEX, 0);\r\n*packet_index = val >> 5;\r\n*byte_index = val & 0x1f;\r\n}\r\nstatic void hdmi_set_dip_index(struct hda_codec *codec, hda_nid_t pin_nid,\r\nint packet_index, int byte_index)\r\n{\r\nint val;\r\nval = (packet_index << 5) | (byte_index & 0x1f);\r\nsnd_hda_codec_write(codec, pin_nid, 0, AC_VERB_SET_HDMI_DIP_INDEX, val);\r\n}\r\nstatic void hdmi_write_dip_byte(struct hda_codec *codec, hda_nid_t pin_nid,\r\nunsigned char val)\r\n{\r\nsnd_hda_codec_write(codec, pin_nid, 0, AC_VERB_SET_HDMI_DIP_DATA, val);\r\n}\r\nstatic void hdmi_init_pin(struct hda_codec *codec, hda_nid_t pin_nid)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_out;\r\nif (get_wcaps(codec, pin_nid) & AC_WCAP_OUT_AMP)\r\nsnd_hda_codec_write(codec, pin_nid, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_UNMUTE);\r\nif (spec->dyn_pin_out)\r\npin_out = 0;\r\nelse\r\npin_out = PIN_OUT;\r\nsnd_hda_codec_write(codec, pin_nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, pin_out);\r\n}\r\nstatic void print_eld_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdmi_spec_per_pin *per_pin = entry->private_data;\r\nmutex_lock(&per_pin->lock);\r\nsnd_hdmi_print_eld_info(&per_pin->sink_eld, buffer);\r\nmutex_unlock(&per_pin->lock);\r\n}\r\nstatic void write_eld_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdmi_spec_per_pin *per_pin = entry->private_data;\r\nmutex_lock(&per_pin->lock);\r\nsnd_hdmi_write_eld_info(&per_pin->sink_eld, buffer);\r\nmutex_unlock(&per_pin->lock);\r\n}\r\nstatic int eld_proc_new(struct hdmi_spec_per_pin *per_pin, int index)\r\n{\r\nchar name[32];\r\nstruct hda_codec *codec = per_pin->codec;\r\nstruct snd_info_entry *entry;\r\nint err;\r\nsnprintf(name, sizeof(name), "eld#%d.%d", codec->addr, index);\r\nerr = snd_card_proc_new(codec->card, name, &entry);\r\nif (err < 0)\r\nreturn err;\r\nsnd_info_set_text_ops(entry, per_pin, print_eld_info);\r\nentry->c.text.write = write_eld_info;\r\nentry->mode |= S_IWUSR;\r\nper_pin->proc_entry = entry;\r\nreturn 0;\r\n}\r\nstatic void eld_proc_free(struct hdmi_spec_per_pin *per_pin)\r\n{\r\nif (!per_pin->codec->bus->shutdown) {\r\nsnd_info_free_entry(per_pin->proc_entry);\r\nper_pin->proc_entry = NULL;\r\n}\r\n}\r\nstatic inline int eld_proc_new(struct hdmi_spec_per_pin *per_pin,\r\nint index)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void eld_proc_free(struct hdmi_spec_per_pin *per_pin)\r\n{\r\n}\r\nstatic void hdmi_start_infoframe_trans(struct hda_codec *codec,\r\nhda_nid_t pin_nid)\r\n{\r\nhdmi_set_dip_index(codec, pin_nid, 0x0, 0x0);\r\nsnd_hda_codec_write(codec, pin_nid, 0, AC_VERB_SET_HDMI_DIP_XMIT,\r\nAC_DIPXMIT_BEST);\r\n}\r\nstatic void hdmi_stop_infoframe_trans(struct hda_codec *codec,\r\nhda_nid_t pin_nid)\r\n{\r\nhdmi_set_dip_index(codec, pin_nid, 0x0, 0x0);\r\nsnd_hda_codec_write(codec, pin_nid, 0, AC_VERB_SET_HDMI_DIP_XMIT,\r\nAC_DIPXMIT_DISABLE);\r\n}\r\nstatic void hdmi_debug_dip_size(struct hda_codec *codec, hda_nid_t pin_nid)\r\n{\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nint i;\r\nint size;\r\nsize = snd_hdmi_get_eld_size(codec, pin_nid);\r\ncodec_dbg(codec, "HDMI: ELD buf size is %d\n", size);\r\nfor (i = 0; i < 8; i++) {\r\nsize = snd_hda_codec_read(codec, pin_nid, 0,\r\nAC_VERB_GET_HDMI_DIP_SIZE, i);\r\ncodec_dbg(codec, "HDMI: DIP GP[%d] buf size is %d\n", i, size);\r\n}\r\n#endif\r\n}\r\nstatic void hdmi_clear_dip_buffers(struct hda_codec *codec, hda_nid_t pin_nid)\r\n{\r\n#ifdef BE_PARANOID\r\nint i, j;\r\nint size;\r\nint pi, bi;\r\nfor (i = 0; i < 8; i++) {\r\nsize = snd_hda_codec_read(codec, pin_nid, 0,\r\nAC_VERB_GET_HDMI_DIP_SIZE, i);\r\nif (size == 0)\r\ncontinue;\r\nhdmi_set_dip_index(codec, pin_nid, i, 0x0);\r\nfor (j = 1; j < 1000; j++) {\r\nhdmi_write_dip_byte(codec, pin_nid, 0x0);\r\nhdmi_get_dip_index(codec, pin_nid, &pi, &bi);\r\nif (pi != i)\r\ncodec_dbg(codec, "dip index %d: %d != %d\n",\r\nbi, pi, i);\r\nif (bi == 0)\r\nbreak;\r\n}\r\ncodec_dbg(codec,\r\n"HDMI: DIP GP[%d] buf reported size=%d, written=%d\n",\r\ni, size, j);\r\n}\r\n#endif\r\n}\r\nstatic void hdmi_checksum_audio_infoframe(struct hdmi_audio_infoframe *hdmi_ai)\r\n{\r\nu8 *bytes = (u8 *)hdmi_ai;\r\nu8 sum = 0;\r\nint i;\r\nhdmi_ai->checksum = 0;\r\nfor (i = 0; i < sizeof(*hdmi_ai); i++)\r\nsum += bytes[i];\r\nhdmi_ai->checksum = -sum;\r\n}\r\nstatic void hdmi_fill_audio_infoframe(struct hda_codec *codec,\r\nhda_nid_t pin_nid,\r\nu8 *dip, int size)\r\n{\r\nint i;\r\nhdmi_debug_dip_size(codec, pin_nid);\r\nhdmi_clear_dip_buffers(codec, pin_nid);\r\nhdmi_set_dip_index(codec, pin_nid, 0x0, 0x0);\r\nfor (i = 0; i < size; i++)\r\nhdmi_write_dip_byte(codec, pin_nid, dip[i]);\r\n}\r\nstatic bool hdmi_infoframe_uptodate(struct hda_codec *codec, hda_nid_t pin_nid,\r\nu8 *dip, int size)\r\n{\r\nu8 val;\r\nint i;\r\nif (snd_hda_codec_read(codec, pin_nid, 0, AC_VERB_GET_HDMI_DIP_XMIT, 0)\r\n!= AC_DIPXMIT_BEST)\r\nreturn false;\r\nhdmi_set_dip_index(codec, pin_nid, 0x0, 0x0);\r\nfor (i = 0; i < size; i++) {\r\nval = snd_hda_codec_read(codec, pin_nid, 0,\r\nAC_VERB_GET_HDMI_DIP_DATA, 0);\r\nif (val != dip[i])\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void hdmi_pin_setup_infoframe(struct hda_codec *codec,\r\nhda_nid_t pin_nid,\r\nint ca, int active_channels,\r\nint conn_type)\r\n{\r\nunion audio_infoframe ai;\r\nmemset(&ai, 0, sizeof(ai));\r\nif (conn_type == 0) {\r\nstruct hdmi_audio_infoframe *hdmi_ai = &ai.hdmi;\r\nhdmi_ai->type = 0x84;\r\nhdmi_ai->ver = 0x01;\r\nhdmi_ai->len = 0x0a;\r\nhdmi_ai->CC02_CT47 = active_channels - 1;\r\nhdmi_ai->CA = ca;\r\nhdmi_checksum_audio_infoframe(hdmi_ai);\r\n} else if (conn_type == 1) {\r\nstruct dp_audio_infoframe *dp_ai = &ai.dp;\r\ndp_ai->type = 0x84;\r\ndp_ai->len = 0x1b;\r\ndp_ai->ver = 0x11 << 2;\r\ndp_ai->CC02_CT47 = active_channels - 1;\r\ndp_ai->CA = ca;\r\n} else {\r\ncodec_dbg(codec, "HDMI: unknown connection type at pin %d\n",\r\npin_nid);\r\nreturn;\r\n}\r\nif (!hdmi_infoframe_uptodate(codec, pin_nid, ai.bytes,\r\nsizeof(ai))) {\r\ncodec_dbg(codec,\r\n"hdmi_pin_setup_infoframe: pin=%d channels=%d ca=0x%02x\n",\r\npin_nid,\r\nactive_channels, ca);\r\nhdmi_stop_infoframe_trans(codec, pin_nid);\r\nhdmi_fill_audio_infoframe(codec, pin_nid,\r\nai.bytes, sizeof(ai));\r\nhdmi_start_infoframe_trans(codec, pin_nid);\r\n}\r\n}\r\nstatic void hdmi_setup_audio_infoframe(struct hda_codec *codec,\r\nstruct hdmi_spec_per_pin *per_pin,\r\nbool non_pcm)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdac_chmap *chmap = &spec->chmap;\r\nhda_nid_t pin_nid = per_pin->pin_nid;\r\nint channels = per_pin->channels;\r\nint active_channels;\r\nstruct hdmi_eld *eld;\r\nint ca;\r\nif (!channels)\r\nreturn;\r\nif (get_wcaps(codec, pin_nid) & AC_WCAP_OUT_AMP)\r\nsnd_hda_codec_write(codec, pin_nid, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_OUT_UNMUTE);\r\neld = &per_pin->sink_eld;\r\nca = snd_hdac_channel_allocation(&codec->core,\r\neld->info.spk_alloc, channels,\r\nper_pin->chmap_set, non_pcm, per_pin->chmap);\r\nactive_channels = snd_hdac_get_active_channels(ca);\r\nchmap->ops.set_channel_count(&codec->core, per_pin->cvt_nid,\r\nactive_channels);\r\nsnd_hdac_setup_channel_mapping(&spec->chmap,\r\npin_nid, non_pcm, ca, channels,\r\nper_pin->chmap, per_pin->chmap_set);\r\nspec->ops.pin_setup_infoframe(codec, pin_nid, ca, active_channels,\r\neld->info.conn_type);\r\nper_pin->non_pcm = non_pcm;\r\n}\r\nstatic void check_presence_and_report(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx = pin_nid_to_pin_index(codec, nid);\r\nif (pin_idx < 0)\r\nreturn;\r\nif (hdmi_present_sense(get_pin(spec, pin_idx), 1))\r\nsnd_hda_jack_report_sync(codec);\r\n}\r\nstatic void jack_callback(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\ncheck_presence_and_report(codec, jack->nid);\r\n}\r\nstatic void hdmi_intrinsic_event(struct hda_codec *codec, unsigned int res)\r\n{\r\nint tag = res >> AC_UNSOL_RES_TAG_SHIFT;\r\nstruct hda_jack_tbl *jack;\r\nint dev_entry = (res & AC_UNSOL_RES_DE) >> AC_UNSOL_RES_DE_SHIFT;\r\njack = snd_hda_jack_tbl_get_from_tag(codec, tag);\r\nif (!jack)\r\nreturn;\r\njack->jack_dirty = 1;\r\ncodec_dbg(codec,\r\n"HDMI hot plug event: Codec=%d Pin=%d Device=%d Inactive=%d Presence_Detect=%d ELD_Valid=%d\n",\r\ncodec->addr, jack->nid, dev_entry, !!(res & AC_UNSOL_RES_IA),\r\n!!(res & AC_UNSOL_RES_PD), !!(res & AC_UNSOL_RES_ELDV));\r\ncheck_presence_and_report(codec, jack->nid);\r\n}\r\nstatic void hdmi_non_intrinsic_event(struct hda_codec *codec, unsigned int res)\r\n{\r\nint tag = res >> AC_UNSOL_RES_TAG_SHIFT;\r\nint subtag = (res & AC_UNSOL_RES_SUBTAG) >> AC_UNSOL_RES_SUBTAG_SHIFT;\r\nint cp_state = !!(res & AC_UNSOL_RES_CP_STATE);\r\nint cp_ready = !!(res & AC_UNSOL_RES_CP_READY);\r\ncodec_info(codec,\r\n"HDMI CP event: CODEC=%d TAG=%d SUBTAG=0x%x CP_STATE=%d CP_READY=%d\n",\r\ncodec->addr,\r\ntag,\r\nsubtag,\r\ncp_state,\r\ncp_ready);\r\nif (cp_state)\r\n;\r\nif (cp_ready)\r\n;\r\n}\r\nstatic void hdmi_unsol_event(struct hda_codec *codec, unsigned int res)\r\n{\r\nint tag = res >> AC_UNSOL_RES_TAG_SHIFT;\r\nint subtag = (res & AC_UNSOL_RES_SUBTAG) >> AC_UNSOL_RES_SUBTAG_SHIFT;\r\nif (!snd_hda_jack_tbl_get_from_tag(codec, tag)) {\r\ncodec_dbg(codec, "Unexpected HDMI event tag 0x%x\n", tag);\r\nreturn;\r\n}\r\nif (subtag == 0)\r\nhdmi_intrinsic_event(codec, res);\r\nelse\r\nhdmi_non_intrinsic_event(codec, res);\r\n}\r\nstatic void haswell_verify_D0(struct hda_codec *codec,\r\nhda_nid_t cvt_nid, hda_nid_t nid)\r\n{\r\nint pwr;\r\nif (!snd_hda_check_power_state(codec, cvt_nid, AC_PWRST_D0))\r\nsnd_hda_codec_write(codec, cvt_nid, 0, AC_VERB_SET_POWER_STATE, AC_PWRST_D0);\r\nif (!snd_hda_check_power_state(codec, nid, AC_PWRST_D0)) {\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE,\r\nAC_PWRST_D0);\r\nmsleep(40);\r\npwr = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_POWER_STATE, 0);\r\npwr = (pwr & AC_PWRST_ACTUAL) >> AC_PWRST_ACTUAL_SHIFT;\r\ncodec_dbg(codec, "Haswell HDMI audio: Power for pin 0x%x is now D%d\n", nid, pwr);\r\n}\r\n}\r\nstatic int hdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,\r\nbool hbr)\r\n{\r\nint pinctl, new_pinctl;\r\nif (snd_hda_query_pin_caps(codec, pin_nid) & AC_PINCAP_HBR) {\r\npinctl = snd_hda_codec_read(codec, pin_nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nif (pinctl < 0)\r\nreturn hbr ? -EINVAL : 0;\r\nnew_pinctl = pinctl & ~AC_PINCTL_EPT;\r\nif (hbr)\r\nnew_pinctl |= AC_PINCTL_EPT_HBR;\r\nelse\r\nnew_pinctl |= AC_PINCTL_EPT_NATIVE;\r\ncodec_dbg(codec,\r\n"hdmi_pin_hbr_setup: NID=0x%x, %spinctl=0x%x\n",\r\npin_nid,\r\npinctl == new_pinctl ? "" : "new-",\r\nnew_pinctl);\r\nif (pinctl != new_pinctl)\r\nsnd_hda_codec_write(codec, pin_nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\nnew_pinctl);\r\n} else if (hbr)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int hdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,\r\nhda_nid_t pin_nid, u32 stream_tag, int format)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint err;\r\nerr = spec->ops.pin_hbr_setup(codec, pin_nid, is_hbr_format(format));\r\nif (err) {\r\ncodec_dbg(codec, "hdmi_setup_stream: HBR is not supported\n");\r\nreturn err;\r\n}\r\nsnd_hda_codec_setup_stream(codec, cvt_nid, stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int hdmi_choose_cvt(struct hda_codec *codec,\r\nint pin_idx, int *cvt_id)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nstruct hdmi_spec_per_cvt *per_cvt = NULL;\r\nint cvt_idx, mux_idx = 0;\r\nif (pin_idx < 0)\r\nper_pin = NULL;\r\nelse\r\nper_pin = get_pin(spec, pin_idx);\r\nfor (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {\r\nper_cvt = get_cvt(spec, cvt_idx);\r\nif (per_cvt->assigned)\r\ncontinue;\r\nif (per_pin == NULL)\r\nbreak;\r\nfor (mux_idx = 0; mux_idx < per_pin->num_mux_nids; mux_idx++)\r\nif (per_pin->mux_nids[mux_idx] == per_cvt->cvt_nid)\r\nbreak;\r\nif (mux_idx == per_pin->num_mux_nids)\r\ncontinue;\r\nbreak;\r\n}\r\nif (cvt_idx == spec->num_cvts)\r\nreturn -EBUSY;\r\nif (per_pin != NULL)\r\nper_pin->mux_idx = mux_idx;\r\nif (cvt_id)\r\n*cvt_id = cvt_idx;\r\nreturn 0;\r\n}\r\nstatic void intel_verify_pin_cvt_connect(struct hda_codec *codec,\r\nstruct hdmi_spec_per_pin *per_pin)\r\n{\r\nhda_nid_t pin_nid = per_pin->pin_nid;\r\nint mux_idx, curr;\r\nmux_idx = per_pin->mux_idx;\r\ncurr = snd_hda_codec_read(codec, pin_nid, 0,\r\nAC_VERB_GET_CONNECT_SEL, 0);\r\nif (curr != mux_idx)\r\nsnd_hda_codec_write_cache(codec, pin_nid, 0,\r\nAC_VERB_SET_CONNECT_SEL,\r\nmux_idx);\r\n}\r\nstatic int intel_cvt_id_to_mux_idx(struct hdmi_spec *spec,\r\nhda_nid_t cvt_nid)\r\n{\r\nint i;\r\nfor (i = 0; i < spec->num_cvts; i++)\r\nif (spec->cvt_nids[i] == cvt_nid)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic void intel_not_share_assigned_cvt(struct hda_codec *codec,\r\nhda_nid_t pin_nid, int mux_idx)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nint cvt_idx, curr;\r\nstruct hdmi_spec_per_cvt *per_cvt;\r\nfor_each_hda_codec_node(nid, codec) {\r\nunsigned int wid_caps = get_wcaps(codec, nid);\r\nunsigned int wid_type = get_wcaps_type(wid_caps);\r\nif (wid_type != AC_WID_PIN)\r\ncontinue;\r\nif (nid == pin_nid)\r\ncontinue;\r\ncurr = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_CONNECT_SEL, 0);\r\nif (curr != mux_idx)\r\ncontinue;\r\nfor (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {\r\nper_cvt = get_cvt(spec, cvt_idx);\r\nif (!per_cvt->assigned) {\r\ncodec_dbg(codec,\r\n"choose cvt %d for pin nid %d\n",\r\ncvt_idx, nid);\r\nsnd_hda_codec_write_cache(codec, nid, 0,\r\nAC_VERB_SET_CONNECT_SEL,\r\ncvt_idx);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void intel_not_share_assigned_cvt_nid(struct hda_codec *codec,\r\nhda_nid_t pin_nid, hda_nid_t cvt_nid)\r\n{\r\nint mux_idx;\r\nstruct hdmi_spec *spec = codec->spec;\r\nmux_idx = intel_cvt_id_to_mux_idx(spec, cvt_nid);\r\nif (mux_idx >= 0)\r\nintel_not_share_assigned_cvt(codec, pin_nid, mux_idx);\r\n}\r\nstatic void pin_cvt_fixup(struct hda_codec *codec,\r\nstruct hdmi_spec_per_pin *per_pin,\r\nhda_nid_t cvt_nid)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nif (spec->ops.pin_cvt_fixup)\r\nspec->ops.pin_cvt_fixup(codec, per_pin, cvt_nid);\r\n}\r\nstatic int hdmi_pcm_open_no_pin(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint cvt_idx, pcm_idx;\r\nstruct hdmi_spec_per_cvt *per_cvt = NULL;\r\nint err;\r\npcm_idx = hinfo_to_pcm_index(codec, hinfo);\r\nif (pcm_idx < 0)\r\nreturn -EINVAL;\r\nerr = hdmi_choose_cvt(codec, -1, &cvt_idx);\r\nif (err)\r\nreturn err;\r\nper_cvt = get_cvt(spec, cvt_idx);\r\nper_cvt->assigned = 1;\r\nhinfo->nid = per_cvt->cvt_nid;\r\npin_cvt_fixup(codec, NULL, per_cvt->cvt_nid);\r\nset_bit(pcm_idx, &spec->pcm_in_use);\r\nhinfo->channels_min = per_cvt->channels_min;\r\nhinfo->channels_max = per_cvt->channels_max;\r\nhinfo->rates = per_cvt->rates;\r\nhinfo->formats = per_cvt->formats;\r\nhinfo->maxbps = per_cvt->maxbps;\r\nruntime->hw.channels_min = hinfo->channels_min;\r\nruntime->hw.channels_max = hinfo->channels_max;\r\nruntime->hw.formats = hinfo->formats;\r\nruntime->hw.rates = hinfo->rates;\r\nsnd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, 2);\r\nreturn 0;\r\n}\r\nstatic int hdmi_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint pin_idx, cvt_idx, pcm_idx;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nstruct hdmi_eld *eld;\r\nstruct hdmi_spec_per_cvt *per_cvt = NULL;\r\nint err;\r\npcm_idx = hinfo_to_pcm_index(codec, hinfo);\r\nif (pcm_idx < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&spec->pcm_lock);\r\npin_idx = hinfo_to_pin_index(codec, hinfo);\r\nif (!spec->dyn_pcm_assign) {\r\nif (snd_BUG_ON(pin_idx < 0)) {\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (pin_idx < 0) {\r\nerr = hdmi_pcm_open_no_pin(hinfo, codec, substream);\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn err;\r\n}\r\n}\r\nerr = hdmi_choose_cvt(codec, pin_idx, &cvt_idx);\r\nif (err < 0) {\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn err;\r\n}\r\nper_cvt = get_cvt(spec, cvt_idx);\r\nper_cvt->assigned = 1;\r\nset_bit(pcm_idx, &spec->pcm_in_use);\r\nper_pin = get_pin(spec, pin_idx);\r\nper_pin->cvt_nid = per_cvt->cvt_nid;\r\nhinfo->nid = per_cvt->cvt_nid;\r\nsnd_hda_codec_write_cache(codec, per_pin->pin_nid, 0,\r\nAC_VERB_SET_CONNECT_SEL,\r\nper_pin->mux_idx);\r\npin_cvt_fixup(codec, per_pin, 0);\r\nsnd_hda_spdif_ctls_assign(codec, pcm_idx, per_cvt->cvt_nid);\r\nhinfo->channels_min = per_cvt->channels_min;\r\nhinfo->channels_max = per_cvt->channels_max;\r\nhinfo->rates = per_cvt->rates;\r\nhinfo->formats = per_cvt->formats;\r\nhinfo->maxbps = per_cvt->maxbps;\r\neld = &per_pin->sink_eld;\r\nif (!static_hdmi_pcm && eld->eld_valid) {\r\nsnd_hdmi_eld_update_pcm_info(&eld->info, hinfo);\r\nif (hinfo->channels_min > hinfo->channels_max ||\r\n!hinfo->rates || !hinfo->formats) {\r\nper_cvt->assigned = 0;\r\nhinfo->nid = 0;\r\nsnd_hda_spdif_ctls_unassign(codec, pcm_idx);\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn -ENODEV;\r\n}\r\n}\r\nmutex_unlock(&spec->pcm_lock);\r\nruntime->hw.channels_min = hinfo->channels_min;\r\nruntime->hw.channels_max = hinfo->channels_max;\r\nruntime->hw.formats = hinfo->formats;\r\nruntime->hw.rates = hinfo->rates;\r\nsnd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, 2);\r\nreturn 0;\r\n}\r\nstatic int hdmi_read_pin_conn(struct hda_codec *codec, int pin_idx)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\r\nhda_nid_t pin_nid = per_pin->pin_nid;\r\nif (!(get_wcaps(codec, pin_nid) & AC_WCAP_CONN_LIST)) {\r\ncodec_warn(codec,\r\n"HDMI: pin %d wcaps %#x does not support connection list\n",\r\npin_nid, get_wcaps(codec, pin_nid));\r\nreturn -EINVAL;\r\n}\r\nper_pin->num_mux_nids = snd_hda_get_connections(codec, pin_nid,\r\nper_pin->mux_nids,\r\nHDA_MAX_CONNECTIONS);\r\nreturn 0;\r\n}\r\nstatic int hdmi_find_pcm_slot(struct hdmi_spec *spec,\r\nstruct hdmi_spec_per_pin *per_pin)\r\n{\r\nint i;\r\nif (!test_bit(per_pin->pin_nid_idx, &spec->pcm_bitmap))\r\nreturn per_pin->pin_nid_idx;\r\nfor (i = spec->num_pins; i < spec->pcm_used; i++) {\r\nif (!test_bit(i, &spec->pcm_bitmap))\r\nreturn i;\r\n}\r\nfor (i = 0; i < spec->num_pins; i++) {\r\nif (!test_bit(i, &spec->pcm_bitmap))\r\nreturn i;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic void hdmi_attach_hda_pcm(struct hdmi_spec *spec,\r\nstruct hdmi_spec_per_pin *per_pin)\r\n{\r\nint idx;\r\nif (per_pin->pcm)\r\nreturn;\r\nidx = hdmi_find_pcm_slot(spec, per_pin);\r\nif (idx == -EBUSY)\r\nreturn;\r\nper_pin->pcm_idx = idx;\r\nper_pin->pcm = get_hdmi_pcm(spec, idx);\r\nset_bit(idx, &spec->pcm_bitmap);\r\n}\r\nstatic void hdmi_detach_hda_pcm(struct hdmi_spec *spec,\r\nstruct hdmi_spec_per_pin *per_pin)\r\n{\r\nint idx;\r\nif (!per_pin->pcm)\r\nreturn;\r\nidx = per_pin->pcm_idx;\r\nper_pin->pcm_idx = -1;\r\nper_pin->pcm = NULL;\r\nif (idx >= 0 && idx < spec->pcm_used)\r\nclear_bit(idx, &spec->pcm_bitmap);\r\n}\r\nstatic int hdmi_get_pin_cvt_mux(struct hdmi_spec *spec,\r\nstruct hdmi_spec_per_pin *per_pin, hda_nid_t cvt_nid)\r\n{\r\nint mux_idx;\r\nfor (mux_idx = 0; mux_idx < per_pin->num_mux_nids; mux_idx++)\r\nif (per_pin->mux_nids[mux_idx] == cvt_nid)\r\nbreak;\r\nreturn mux_idx;\r\n}\r\nstatic void hdmi_pcm_setup_pin(struct hdmi_spec *spec,\r\nstruct hdmi_spec_per_pin *per_pin)\r\n{\r\nstruct hda_codec *codec = per_pin->codec;\r\nstruct hda_pcm *pcm;\r\nstruct hda_pcm_stream *hinfo;\r\nstruct snd_pcm_substream *substream;\r\nint mux_idx;\r\nbool non_pcm;\r\nif (per_pin->pcm_idx >= 0 && per_pin->pcm_idx < spec->pcm_used)\r\npcm = get_pcm_rec(spec, per_pin->pcm_idx);\r\nelse\r\nreturn;\r\nif (!test_bit(per_pin->pcm_idx, &spec->pcm_in_use))\r\nreturn;\r\nhinfo = pcm->stream;\r\nsubstream = pcm->pcm->streams[0].substream;\r\nper_pin->cvt_nid = hinfo->nid;\r\nmux_idx = hdmi_get_pin_cvt_mux(spec, per_pin, hinfo->nid);\r\nif (mux_idx < per_pin->num_mux_nids)\r\nsnd_hda_codec_write_cache(codec, per_pin->pin_nid, 0,\r\nAC_VERB_SET_CONNECT_SEL,\r\nmux_idx);\r\nsnd_hda_spdif_ctls_assign(codec, per_pin->pcm_idx, hinfo->nid);\r\nnon_pcm = check_non_pcm_per_cvt(codec, hinfo->nid);\r\nif (substream->runtime)\r\nper_pin->channels = substream->runtime->channels;\r\nper_pin->setup = true;\r\nper_pin->mux_idx = mux_idx;\r\nhdmi_setup_audio_infoframe(codec, per_pin, non_pcm);\r\n}\r\nstatic void hdmi_pcm_reset_pin(struct hdmi_spec *spec,\r\nstruct hdmi_spec_per_pin *per_pin)\r\n{\r\nif (per_pin->pcm_idx >= 0 && per_pin->pcm_idx < spec->pcm_used)\r\nsnd_hda_spdif_ctls_unassign(per_pin->codec, per_pin->pcm_idx);\r\nper_pin->chmap_set = false;\r\nmemset(per_pin->chmap, 0, sizeof(per_pin->chmap));\r\nper_pin->setup = false;\r\nper_pin->channels = 0;\r\n}\r\nstatic void update_eld(struct hda_codec *codec,\r\nstruct hdmi_spec_per_pin *per_pin,\r\nstruct hdmi_eld *eld)\r\n{\r\nstruct hdmi_eld *pin_eld = &per_pin->sink_eld;\r\nstruct hdmi_spec *spec = codec->spec;\r\nbool old_eld_valid = pin_eld->eld_valid;\r\nbool eld_changed;\r\nint pcm_idx = -1;\r\npcm_idx = per_pin->pcm_idx;\r\nif (spec->dyn_pcm_assign) {\r\nif (eld->eld_valid) {\r\nhdmi_attach_hda_pcm(spec, per_pin);\r\nhdmi_pcm_setup_pin(spec, per_pin);\r\n} else {\r\nhdmi_pcm_reset_pin(spec, per_pin);\r\nhdmi_detach_hda_pcm(spec, per_pin);\r\n}\r\n}\r\nif (pcm_idx == -1)\r\npcm_idx = per_pin->pcm_idx;\r\nif (eld->eld_valid)\r\nsnd_hdmi_show_eld(codec, &eld->info);\r\neld_changed = (pin_eld->eld_valid != eld->eld_valid);\r\nif (eld->eld_valid && pin_eld->eld_valid)\r\nif (pin_eld->eld_size != eld->eld_size ||\r\nmemcmp(pin_eld->eld_buffer, eld->eld_buffer,\r\neld->eld_size) != 0)\r\neld_changed = true;\r\npin_eld->monitor_present = eld->monitor_present;\r\npin_eld->eld_valid = eld->eld_valid;\r\npin_eld->eld_size = eld->eld_size;\r\nif (eld->eld_valid)\r\nmemcpy(pin_eld->eld_buffer, eld->eld_buffer, eld->eld_size);\r\npin_eld->info = eld->info;\r\nif (eld->eld_valid && !old_eld_valid && per_pin->setup) {\r\npin_cvt_fixup(codec, per_pin, 0);\r\nhdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);\r\n}\r\nif (eld_changed && pcm_idx >= 0)\r\nsnd_ctl_notify(codec->card,\r\nSNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\n&get_hdmi_pcm(spec, pcm_idx)->eld_ctl->id);\r\n}\r\nstatic bool hdmi_present_sense_via_verbs(struct hdmi_spec_per_pin *per_pin,\r\nint repoll)\r\n{\r\nstruct hda_jack_tbl *jack;\r\nstruct hda_codec *codec = per_pin->codec;\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_eld *eld = &spec->temp_eld;\r\nhda_nid_t pin_nid = per_pin->pin_nid;\r\nint present;\r\nbool ret;\r\nbool do_repoll = false;\r\npresent = snd_hda_pin_sense(codec, pin_nid);\r\nmutex_lock(&per_pin->lock);\r\neld->monitor_present = !!(present & AC_PINSENSE_PRESENCE);\r\nif (eld->monitor_present)\r\neld->eld_valid = !!(present & AC_PINSENSE_ELDV);\r\nelse\r\neld->eld_valid = false;\r\ncodec_dbg(codec,\r\n"HDMI status: Codec=%d Pin=%d Presence_Detect=%d ELD_Valid=%d\n",\r\ncodec->addr, pin_nid, eld->monitor_present, eld->eld_valid);\r\nif (eld->eld_valid) {\r\nif (spec->ops.pin_get_eld(codec, pin_nid, eld->eld_buffer,\r\n&eld->eld_size) < 0)\r\neld->eld_valid = false;\r\nelse {\r\nif (snd_hdmi_parse_eld(codec, &eld->info, eld->eld_buffer,\r\neld->eld_size) < 0)\r\neld->eld_valid = false;\r\n}\r\nif (!eld->eld_valid && repoll)\r\ndo_repoll = true;\r\n}\r\nif (do_repoll)\r\nschedule_delayed_work(&per_pin->work, msecs_to_jiffies(300));\r\nelse\r\nupdate_eld(codec, per_pin, eld);\r\nret = !repoll || !eld->monitor_present || eld->eld_valid;\r\njack = snd_hda_jack_tbl_get(codec, pin_nid);\r\nif (jack)\r\njack->block_report = !ret;\r\nmutex_unlock(&per_pin->lock);\r\nreturn ret;\r\n}\r\nstatic struct snd_jack *pin_idx_to_jack(struct hda_codec *codec,\r\nstruct hdmi_spec_per_pin *per_pin)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct snd_jack *jack = NULL;\r\nstruct hda_jack_tbl *jack_tbl;\r\nif (per_pin->pcm_idx >= 0 && spec->dyn_pcm_assign)\r\njack = spec->pcm_rec[per_pin->pcm_idx].jack;\r\nelse if (!spec->dyn_pcm_assign) {\r\njack_tbl = snd_hda_jack_tbl_get(codec, per_pin->pin_nid);\r\nif (jack_tbl)\r\njack = jack_tbl->jack;\r\n}\r\nreturn jack;\r\n}\r\nstatic void sync_eld_via_acomp(struct hda_codec *codec,\r\nstruct hdmi_spec_per_pin *per_pin)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_eld *eld = &spec->temp_eld;\r\nstruct snd_jack *jack = NULL;\r\nint size;\r\nmutex_lock(&per_pin->lock);\r\neld->monitor_present = false;\r\nsize = snd_hdac_acomp_get_eld(&codec->core, per_pin->pin_nid,\r\n&eld->monitor_present, eld->eld_buffer,\r\nELD_MAX_SIZE);\r\nif (size > 0) {\r\nsize = min(size, ELD_MAX_SIZE);\r\nif (snd_hdmi_parse_eld(codec, &eld->info,\r\neld->eld_buffer, size) < 0)\r\nsize = -EINVAL;\r\n}\r\nif (size > 0) {\r\neld->eld_valid = true;\r\neld->eld_size = size;\r\n} else {\r\neld->eld_valid = false;\r\neld->eld_size = 0;\r\n}\r\njack = pin_idx_to_jack(codec, per_pin);\r\nupdate_eld(codec, per_pin, eld);\r\nif (jack == NULL)\r\njack = pin_idx_to_jack(codec, per_pin);\r\nif (jack == NULL)\r\ngoto unlock;\r\nsnd_jack_report(jack,\r\neld->monitor_present ? SND_JACK_AVOUT : 0);\r\nunlock:\r\nmutex_unlock(&per_pin->lock);\r\n}\r\nstatic bool hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll)\r\n{\r\nstruct hda_codec *codec = per_pin->codec;\r\nstruct hdmi_spec *spec = codec->spec;\r\nint ret;\r\nif (!codec_has_acomp(codec))\r\nsnd_hda_power_up_pm(codec);\r\nmutex_lock(&spec->pcm_lock);\r\nif (codec_has_acomp(codec)) {\r\nsync_eld_via_acomp(codec, per_pin);\r\nret = false;\r\n} else {\r\nret = hdmi_present_sense_via_verbs(per_pin, repoll);\r\n}\r\nmutex_unlock(&spec->pcm_lock);\r\nif (!codec_has_acomp(codec))\r\nsnd_hda_power_down_pm(codec);\r\nreturn ret;\r\n}\r\nstatic void hdmi_repoll_eld(struct work_struct *work)\r\n{\r\nstruct hdmi_spec_per_pin *per_pin =\r\ncontainer_of(to_delayed_work(work), struct hdmi_spec_per_pin, work);\r\nif (per_pin->repoll_count++ > 6)\r\nper_pin->repoll_count = 0;\r\nif (hdmi_present_sense(per_pin, per_pin->repoll_count))\r\nsnd_hda_jack_report_sync(per_pin->codec);\r\n}\r\nstatic int hdmi_add_pin(struct hda_codec *codec, hda_nid_t pin_nid)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nunsigned int caps, config;\r\nint pin_idx;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nint err;\r\ncaps = snd_hda_query_pin_caps(codec, pin_nid);\r\nif (!(caps & (AC_PINCAP_HDMI | AC_PINCAP_DP)))\r\nreturn 0;\r\nconfig = snd_hda_codec_get_pincfg(codec, pin_nid);\r\nif (get_defcfg_connect(config) == AC_JACK_PORT_NONE)\r\nreturn 0;\r\nif (is_haswell_plus(codec))\r\nintel_haswell_fixup_connect_list(codec, pin_nid);\r\npin_idx = spec->num_pins;\r\nper_pin = snd_array_new(&spec->pins);\r\nif (!per_pin)\r\nreturn -ENOMEM;\r\nper_pin->pin_nid = pin_nid;\r\nper_pin->non_pcm = false;\r\nif (spec->dyn_pcm_assign)\r\nper_pin->pcm_idx = -1;\r\nelse {\r\nper_pin->pcm = get_hdmi_pcm(spec, pin_idx);\r\nper_pin->pcm_idx = pin_idx;\r\n}\r\nper_pin->pin_nid_idx = pin_idx;\r\nerr = hdmi_read_pin_conn(codec, pin_idx);\r\nif (err < 0)\r\nreturn err;\r\nspec->num_pins++;\r\nreturn 0;\r\n}\r\nstatic int hdmi_add_cvt(struct hda_codec *codec, hda_nid_t cvt_nid)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_cvt *per_cvt;\r\nunsigned int chans;\r\nint err;\r\nchans = get_wcaps(codec, cvt_nid);\r\nchans = get_wcaps_channels(chans);\r\nper_cvt = snd_array_new(&spec->cvts);\r\nif (!per_cvt)\r\nreturn -ENOMEM;\r\nper_cvt->cvt_nid = cvt_nid;\r\nper_cvt->channels_min = 2;\r\nif (chans <= 16) {\r\nper_cvt->channels_max = chans;\r\nif (chans > spec->chmap.channels_max)\r\nspec->chmap.channels_max = chans;\r\n}\r\nerr = snd_hda_query_supported_pcm(codec, cvt_nid,\r\n&per_cvt->rates,\r\n&per_cvt->formats,\r\n&per_cvt->maxbps);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->num_cvts < ARRAY_SIZE(spec->cvt_nids))\r\nspec->cvt_nids[spec->num_cvts] = cvt_nid;\r\nspec->num_cvts++;\r\nreturn 0;\r\n}\r\nstatic int hdmi_parse_codec(struct hda_codec *codec)\r\n{\r\nhda_nid_t nid;\r\nint i, nodes;\r\nnodes = snd_hda_get_sub_nodes(codec, codec->core.afg, &nid);\r\nif (!nid || nodes < 0) {\r\ncodec_warn(codec, "HDMI: failed to get afg sub nodes\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < nodes; i++, nid++) {\r\nunsigned int caps;\r\nunsigned int type;\r\ncaps = get_wcaps(codec, nid);\r\ntype = get_wcaps_type(caps);\r\nif (!(caps & AC_WCAP_DIGITAL))\r\ncontinue;\r\nswitch (type) {\r\ncase AC_WID_AUD_OUT:\r\nhdmi_add_cvt(codec, nid);\r\nbreak;\r\ncase AC_WID_PIN:\r\nhdmi_add_pin(codec, nid);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic bool check_non_pcm_per_cvt(struct hda_codec *codec, hda_nid_t cvt_nid)\r\n{\r\nstruct hda_spdif_out *spdif;\r\nbool non_pcm;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_hda_spdif_out_of_nid(codec, cvt_nid);\r\nif (WARN_ON(spdif == NULL))\r\nreturn true;\r\nnon_pcm = !!(spdif->status & IEC958_AES0_NONAUDIO);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn non_pcm;\r\n}\r\nstatic int generic_hdmi_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nhda_nid_t cvt_nid = hinfo->nid;\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nhda_nid_t pin_nid;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nbool non_pcm;\r\nint pinctl;\r\nint err;\r\nmutex_lock(&spec->pcm_lock);\r\npin_idx = hinfo_to_pin_index(codec, hinfo);\r\nif (spec->dyn_pcm_assign && pin_idx < 0) {\r\npin_cvt_fixup(codec, NULL, cvt_nid);\r\nsnd_hda_codec_setup_stream(codec, cvt_nid,\r\nstream_tag, 0, format);\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn 0;\r\n}\r\nif (snd_BUG_ON(pin_idx < 0)) {\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn -EINVAL;\r\n}\r\nper_pin = get_pin(spec, pin_idx);\r\npin_nid = per_pin->pin_nid;\r\npin_cvt_fixup(codec, per_pin, 0);\r\nif (codec_has_acomp(codec))\r\nsnd_hdac_sync_audio_rate(&codec->core, pin_nid, runtime->rate);\r\nnon_pcm = check_non_pcm_per_cvt(codec, cvt_nid);\r\nmutex_lock(&per_pin->lock);\r\nper_pin->channels = substream->runtime->channels;\r\nper_pin->setup = true;\r\nhdmi_setup_audio_infoframe(codec, per_pin, non_pcm);\r\nmutex_unlock(&per_pin->lock);\r\nif (spec->dyn_pin_out) {\r\npinctl = snd_hda_codec_read(codec, pin_nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nsnd_hda_codec_write(codec, pin_nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\npinctl | PIN_OUT);\r\n}\r\nerr = spec->ops.setup_stream(codec, cvt_nid, pin_nid,\r\nstream_tag, format);\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn err;\r\n}\r\nstatic int generic_hdmi_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\r\nreturn 0;\r\n}\r\nstatic int hdmi_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint cvt_idx, pin_idx, pcm_idx;\r\nstruct hdmi_spec_per_cvt *per_cvt;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nint pinctl;\r\nif (hinfo->nid) {\r\npcm_idx = hinfo_to_pcm_index(codec, hinfo);\r\nif (snd_BUG_ON(pcm_idx < 0))\r\nreturn -EINVAL;\r\ncvt_idx = cvt_nid_to_cvt_index(codec, hinfo->nid);\r\nif (snd_BUG_ON(cvt_idx < 0))\r\nreturn -EINVAL;\r\nper_cvt = get_cvt(spec, cvt_idx);\r\nsnd_BUG_ON(!per_cvt->assigned);\r\nper_cvt->assigned = 0;\r\nhinfo->nid = 0;\r\nmutex_lock(&spec->pcm_lock);\r\nsnd_hda_spdif_ctls_unassign(codec, pcm_idx);\r\nclear_bit(pcm_idx, &spec->pcm_in_use);\r\npin_idx = hinfo_to_pin_index(codec, hinfo);\r\nif (spec->dyn_pcm_assign && pin_idx < 0) {\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn 0;\r\n}\r\nif (snd_BUG_ON(pin_idx < 0)) {\r\nmutex_unlock(&spec->pcm_lock);\r\nreturn -EINVAL;\r\n}\r\nper_pin = get_pin(spec, pin_idx);\r\nif (spec->dyn_pin_out) {\r\npinctl = snd_hda_codec_read(codec, per_pin->pin_nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nsnd_hda_codec_write(codec, per_pin->pin_nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\npinctl & ~PIN_OUT);\r\n}\r\nmutex_lock(&per_pin->lock);\r\nper_pin->chmap_set = false;\r\nmemset(per_pin->chmap, 0, sizeof(per_pin->chmap));\r\nper_pin->setup = false;\r\nper_pin->channels = 0;\r\nmutex_unlock(&per_pin->lock);\r\nmutex_unlock(&spec->pcm_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdmi_get_spk_alloc(struct hdac_device *hdac, int pcm_idx)\r\n{\r\nstruct hda_codec *codec = container_of(hdac, struct hda_codec, core);\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin = pcm_idx_to_pin(spec, pcm_idx);\r\nif (!per_pin)\r\nreturn 0;\r\nreturn per_pin->sink_eld.info.spk_alloc;\r\n}\r\nstatic void hdmi_get_chmap(struct hdac_device *hdac, int pcm_idx,\r\nunsigned char *chmap)\r\n{\r\nstruct hda_codec *codec = container_of(hdac, struct hda_codec, core);\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin = pcm_idx_to_pin(spec, pcm_idx);\r\nif (!per_pin)\r\nreturn;\r\nmemcpy(chmap, per_pin->chmap, ARRAY_SIZE(per_pin->chmap));\r\n}\r\nstatic void hdmi_set_chmap(struct hdac_device *hdac, int pcm_idx,\r\nunsigned char *chmap, int prepared)\r\n{\r\nstruct hda_codec *codec = container_of(hdac, struct hda_codec, core);\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin = pcm_idx_to_pin(spec, pcm_idx);\r\nif (!per_pin)\r\nreturn;\r\nmutex_lock(&per_pin->lock);\r\nper_pin->chmap_set = true;\r\nmemcpy(per_pin->chmap, chmap, ARRAY_SIZE(per_pin->chmap));\r\nif (prepared)\r\nhdmi_setup_audio_infoframe(codec, per_pin, per_pin->non_pcm);\r\nmutex_unlock(&per_pin->lock);\r\n}\r\nstatic bool is_hdmi_pcm_attached(struct hdac_device *hdac, int pcm_idx)\r\n{\r\nstruct hda_codec *codec = container_of(hdac, struct hda_codec, core);\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin = pcm_idx_to_pin(spec, pcm_idx);\r\nreturn per_pin ? true:false;\r\n}\r\nstatic int generic_hdmi_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx;\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\r\nstruct hda_pcm *info;\r\nstruct hda_pcm_stream *pstr;\r\ninfo = snd_hda_codec_pcm_new(codec, "HDMI %d", pin_idx);\r\nif (!info)\r\nreturn -ENOMEM;\r\nspec->pcm_rec[pin_idx].pcm = info;\r\nspec->pcm_used++;\r\ninfo->pcm_type = HDA_PCM_TYPE_HDMI;\r\ninfo->own_chmap = true;\r\npstr = &info->stream[SNDRV_PCM_STREAM_PLAYBACK];\r\npstr->substreams = 1;\r\npstr->ops = generic_ops;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_hdmi_jack_priv(struct snd_jack *jack)\r\n{\r\nstruct hdmi_pcm *pcm = jack->private_data;\r\npcm->jack = NULL;\r\n}\r\nstatic int add_hdmi_jack_kctl(struct hda_codec *codec,\r\nstruct hdmi_spec *spec,\r\nint pcm_idx,\r\nconst char *name)\r\n{\r\nstruct snd_jack *jack;\r\nint err;\r\nerr = snd_jack_new(codec->card, name, SND_JACK_AVOUT, &jack,\r\ntrue, false);\r\nif (err < 0)\r\nreturn err;\r\nspec->pcm_rec[pcm_idx].jack = jack;\r\njack->private_data = &spec->pcm_rec[pcm_idx];\r\njack->private_free = free_hdmi_jack_priv;\r\nreturn 0;\r\n}\r\nstatic int generic_hdmi_build_jack(struct hda_codec *codec, int pcm_idx)\r\n{\r\nchar hdmi_str[32] = "HDMI/DP";\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nstruct hda_jack_tbl *jack;\r\nint pcmdev = get_pcm_rec(spec, pcm_idx)->device;\r\nbool phantom_jack;\r\nint ret;\r\nif (pcmdev > 0)\r\nsprintf(hdmi_str + strlen(hdmi_str), ",pcm=%d", pcmdev);\r\nif (spec->dyn_pcm_assign)\r\nreturn add_hdmi_jack_kctl(codec, spec, pcm_idx, hdmi_str);\r\nper_pin = get_pin(spec, pcm_idx);\r\nphantom_jack = !is_jack_detectable(codec, per_pin->pin_nid);\r\nif (phantom_jack)\r\nstrncat(hdmi_str, " Phantom",\r\nsizeof(hdmi_str) - strlen(hdmi_str) - 1);\r\nret = snd_hda_jack_add_kctl(codec, per_pin->pin_nid, hdmi_str,\r\nphantom_jack);\r\nif (ret < 0)\r\nreturn ret;\r\njack = snd_hda_jack_tbl_get(codec, per_pin->pin_nid);\r\nif (jack == NULL)\r\nreturn 0;\r\nspec->pcm_rec[pcm_idx].jack = jack->jack;\r\nreturn 0;\r\n}\r\nstatic int generic_hdmi_build_controls(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint err;\r\nint pin_idx, pcm_idx;\r\nfor (pcm_idx = 0; pcm_idx < spec->pcm_used; pcm_idx++) {\r\nerr = generic_hdmi_build_jack(codec, pcm_idx);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->dyn_pcm_assign)\r\nerr = snd_hda_create_dig_out_ctls(codec,\r\n0, spec->cvt_nids[0],\r\nHDA_PCM_TYPE_HDMI);\r\nelse {\r\nstruct hdmi_spec_per_pin *per_pin =\r\nget_pin(spec, pcm_idx);\r\nerr = snd_hda_create_dig_out_ctls(codec,\r\nper_pin->pin_nid,\r\nper_pin->mux_nids[0],\r\nHDA_PCM_TYPE_HDMI);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nsnd_hda_spdif_ctls_unassign(codec, pcm_idx);\r\nerr = hdmi_create_eld_ctl(codec, pcm_idx,\r\nget_pcm_rec(spec, pcm_idx)->device);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\r\nstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\r\nhdmi_present_sense(per_pin, 0);\r\n}\r\nfor (pcm_idx = 0; pcm_idx < spec->pcm_used; pcm_idx++) {\r\nstruct hda_pcm *pcm;\r\npcm = get_pcm_rec(spec, pcm_idx);\r\nif (!pcm || !pcm->pcm)\r\nbreak;\r\nerr = snd_hdac_add_chmap_ctls(pcm->pcm, pcm_idx, &spec->chmap);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int generic_hdmi_init_per_pins(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx;\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\r\nstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\r\nper_pin->codec = codec;\r\nmutex_init(&per_pin->lock);\r\nINIT_DELAYED_WORK(&per_pin->work, hdmi_repoll_eld);\r\neld_proc_new(per_pin, pin_idx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int generic_hdmi_init(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx;\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\r\nstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\r\nhda_nid_t pin_nid = per_pin->pin_nid;\r\nhdmi_init_pin(codec, pin_nid);\r\nif (!codec_has_acomp(codec))\r\nsnd_hda_jack_detect_enable_callback(codec, pin_nid,\r\ncodec->jackpoll_interval > 0 ?\r\njack_callback : NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hdmi_array_init(struct hdmi_spec *spec, int nums)\r\n{\r\nsnd_array_init(&spec->pins, sizeof(struct hdmi_spec_per_pin), nums);\r\nsnd_array_init(&spec->cvts, sizeof(struct hdmi_spec_per_cvt), nums);\r\n}\r\nstatic void hdmi_array_free(struct hdmi_spec *spec)\r\n{\r\nsnd_array_free(&spec->pins);\r\nsnd_array_free(&spec->cvts);\r\n}\r\nstatic void generic_spec_free(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nif (spec) {\r\nif (spec->i915_bound)\r\nsnd_hdac_i915_exit(&codec->bus->core);\r\nhdmi_array_free(spec);\r\nkfree(spec);\r\ncodec->spec = NULL;\r\n}\r\ncodec->dp_mst = false;\r\n}\r\nstatic void generic_hdmi_free(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx, pcm_idx;\r\nif (codec_has_acomp(codec))\r\nsnd_hdac_i915_register_notifier(NULL);\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\r\nstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\r\ncancel_delayed_work_sync(&per_pin->work);\r\neld_proc_free(per_pin);\r\n}\r\nfor (pcm_idx = 0; pcm_idx < spec->pcm_used; pcm_idx++) {\r\nif (spec->pcm_rec[pcm_idx].jack == NULL)\r\ncontinue;\r\nif (spec->dyn_pcm_assign)\r\nsnd_device_free(codec->card,\r\nspec->pcm_rec[pcm_idx].jack);\r\nelse\r\nspec->pcm_rec[pcm_idx].jack = NULL;\r\n}\r\ngeneric_spec_free(codec);\r\n}\r\nstatic int generic_hdmi_resume(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx;\r\ncodec->patch_ops.init(codec);\r\nregcache_sync(codec->core.regmap);\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\r\nstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\r\nhdmi_present_sense(per_pin, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int alloc_generic_hdmi(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nspec->ops = generic_standard_hdmi_ops;\r\nmutex_init(&spec->pcm_lock);\r\nsnd_hdac_register_chmap_ops(&codec->core, &spec->chmap);\r\nspec->chmap.ops.get_chmap = hdmi_get_chmap;\r\nspec->chmap.ops.set_chmap = hdmi_set_chmap;\r\nspec->chmap.ops.is_pcm_attached = is_hdmi_pcm_attached;\r\nspec->chmap.ops.get_spk_alloc = hdmi_get_spk_alloc,\r\ncodec->spec = spec;\r\nhdmi_array_init(spec, 4);\r\ncodec->patch_ops = generic_hdmi_patch_ops;\r\nreturn 0;\r\n}\r\nstatic int patch_generic_hdmi(struct hda_codec *codec)\r\n{\r\nint err;\r\nerr = alloc_generic_hdmi(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = hdmi_parse_codec(codec);\r\nif (err < 0) {\r\ngeneric_spec_free(codec);\r\nreturn err;\r\n}\r\ngeneric_hdmi_init_per_pins(codec);\r\nreturn 0;\r\n}\r\nstatic void intel_haswell_fixup_connect_list(struct hda_codec *codec,\r\nhda_nid_t nid)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nhda_nid_t conns[4];\r\nint nconns;\r\nnconns = snd_hda_get_connections(codec, nid, conns, ARRAY_SIZE(conns));\r\nif (nconns == spec->num_cvts &&\r\n!memcmp(conns, spec->cvt_nids, spec->num_cvts * sizeof(hda_nid_t)))\r\nreturn;\r\ncodec_dbg(codec, "hdmi: haswell: override pin connection 0x%x\n", nid);\r\nsnd_hda_override_conn_list(codec, nid, spec->num_cvts, spec->cvt_nids);\r\n}\r\nstatic void intel_haswell_enable_all_pins(struct hda_codec *codec,\r\nbool update_tree)\r\n{\r\nunsigned int vendor_param;\r\nvendor_param = snd_hda_codec_read(codec, INTEL_VENDOR_NID, 0,\r\nINTEL_GET_VENDOR_VERB, 0);\r\nif (vendor_param == -1 || vendor_param & INTEL_EN_ALL_PIN_CVTS)\r\nreturn;\r\nvendor_param |= INTEL_EN_ALL_PIN_CVTS;\r\nvendor_param = snd_hda_codec_read(codec, INTEL_VENDOR_NID, 0,\r\nINTEL_SET_VENDOR_VERB, vendor_param);\r\nif (vendor_param == -1)\r\nreturn;\r\nif (update_tree)\r\nsnd_hda_codec_update_widgets(codec);\r\n}\r\nstatic void intel_haswell_fixup_enable_dp12(struct hda_codec *codec)\r\n{\r\nunsigned int vendor_param;\r\nvendor_param = snd_hda_codec_read(codec, INTEL_VENDOR_NID, 0,\r\nINTEL_GET_VENDOR_VERB, 0);\r\nif (vendor_param == -1 || vendor_param & INTEL_EN_DP12)\r\nreturn;\r\nvendor_param |= INTEL_EN_DP12;\r\nsnd_hdac_regmap_add_vendor_verb(&codec->core, INTEL_SET_VENDOR_VERB);\r\nsnd_hda_codec_write_cache(codec, INTEL_VENDOR_NID, 0,\r\nINTEL_SET_VENDOR_VERB, vendor_param);\r\n}\r\nstatic void haswell_set_power_state(struct hda_codec *codec, hda_nid_t fg,\r\nunsigned int power_state)\r\n{\r\nif (power_state == AC_PWRST_D0) {\r\nintel_haswell_enable_all_pins(codec, false);\r\nintel_haswell_fixup_enable_dp12(codec);\r\n}\r\nsnd_hda_codec_read(codec, fg, 0, AC_VERB_SET_POWER_STATE, power_state);\r\nsnd_hda_codec_set_power_to_all(codec, fg, power_state);\r\n}\r\nstatic void intel_pin_eld_notify(void *audio_ptr, int port)\r\n{\r\nstruct hda_codec *codec = audio_ptr;\r\nint pin_nid;\r\nif (port < 1 || port > 3)\r\nreturn;\r\nswitch (codec->core.vendor_id) {\r\ncase 0x80860054:\r\ncase 0x80862804:\r\ncase 0x80862882:\r\npin_nid = port + 0x03;\r\nbreak;\r\ndefault:\r\npin_nid = port + 0x04;\r\nbreak;\r\n}\r\nif (snd_power_get_state(codec->card) != SNDRV_CTL_POWER_D0)\r\nreturn;\r\nif (atomic_read(&(codec)->core.in_pm))\r\nreturn;\r\nsnd_hdac_i915_set_bclk(&codec->bus->core);\r\ncheck_presence_and_report(codec, pin_nid);\r\n}\r\nstatic void register_i915_notifier(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nspec->use_acomp_notifier = true;\r\nspec->i915_audio_ops.audio_ptr = codec;\r\nwmb();\r\nspec->i915_audio_ops.pin_eld_notify = intel_pin_eld_notify;\r\nsnd_hdac_i915_register_notifier(&spec->i915_audio_ops);\r\n}\r\nstatic int i915_hsw_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,\r\nhda_nid_t pin_nid, u32 stream_tag, int format)\r\n{\r\nhaswell_verify_D0(codec, cvt_nid, pin_nid);\r\nreturn hdmi_setup_stream(codec, cvt_nid, pin_nid, stream_tag, format);\r\n}\r\nstatic void i915_pin_cvt_fixup(struct hda_codec *codec,\r\nstruct hdmi_spec_per_pin *per_pin,\r\nhda_nid_t cvt_nid)\r\n{\r\nif (per_pin) {\r\nintel_verify_pin_cvt_connect(codec, per_pin);\r\nintel_not_share_assigned_cvt(codec, per_pin->pin_nid,\r\nper_pin->mux_idx);\r\n} else {\r\nintel_not_share_assigned_cvt_nid(codec, 0, cvt_nid);\r\n}\r\n}\r\nstatic int patch_i915_hsw_hdmi(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec;\r\nint err;\r\nif (!codec->bus->core.audio_component) {\r\ncodec_info(codec, "No i915 binding for Intel HDMI/DP codec\n");\r\nreturn -ENODEV;\r\n}\r\nerr = alloc_generic_hdmi(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nintel_haswell_enable_all_pins(codec, true);\r\nintel_haswell_fixup_enable_dp12(codec);\r\nif (!is_haswell(codec) && !is_broadwell(codec))\r\ncodec->core.link_power_control = 1;\r\ncodec->patch_ops.set_power_state = haswell_set_power_state;\r\ncodec->dp_mst = true;\r\ncodec->depop_delay = 0;\r\ncodec->auto_runtime_pm = 1;\r\nspec->ops.setup_stream = i915_hsw_setup_stream;\r\nspec->ops.pin_cvt_fixup = i915_pin_cvt_fixup;\r\nerr = hdmi_parse_codec(codec);\r\nif (err < 0) {\r\ngeneric_spec_free(codec);\r\nreturn err;\r\n}\r\ngeneric_hdmi_init_per_pins(codec);\r\nregister_i915_notifier(codec);\r\nreturn 0;\r\n}\r\nstatic int patch_i915_byt_hdmi(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec;\r\nint err;\r\nif (!codec->bus->core.audio_component) {\r\ncodec_info(codec, "No i915 binding for Intel HDMI/DP codec\n");\r\nreturn -ENODEV;\r\n}\r\nerr = alloc_generic_hdmi(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\ncodec->core.link_power_control = 1;\r\ncodec->depop_delay = 0;\r\ncodec->auto_runtime_pm = 1;\r\nspec->ops.pin_cvt_fixup = i915_pin_cvt_fixup;\r\nerr = hdmi_parse_codec(codec);\r\nif (err < 0) {\r\ngeneric_spec_free(codec);\r\nreturn err;\r\n}\r\ngeneric_hdmi_init_per_pins(codec);\r\nregister_i915_notifier(codec);\r\nreturn 0;\r\n}\r\nstatic int patch_i915_cpt_hdmi(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec;\r\nint err;\r\nif (WARN_ON(codec->bus->core.audio_component))\r\nreturn -EBUSY;\r\nerr = alloc_generic_hdmi(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nerr = snd_hdac_i915_init(&codec->bus->core);\r\nif (err < 0)\r\ngoto error;\r\nspec->i915_bound = true;\r\nerr = hdmi_parse_codec(codec);\r\nif (err < 0)\r\ngoto error;\r\ngeneric_hdmi_init_per_pins(codec);\r\nregister_i915_notifier(codec);\r\nreturn 0;\r\nerror:\r\ngeneric_spec_free(codec);\r\nreturn err;\r\n}\r\nstatic int simple_playback_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hda_pcm *info;\r\nunsigned int chans;\r\nstruct hda_pcm_stream *pstr;\r\nstruct hdmi_spec_per_cvt *per_cvt;\r\nper_cvt = get_cvt(spec, 0);\r\nchans = get_wcaps(codec, per_cvt->cvt_nid);\r\nchans = get_wcaps_channels(chans);\r\ninfo = snd_hda_codec_pcm_new(codec, "HDMI 0");\r\nif (!info)\r\nreturn -ENOMEM;\r\nspec->pcm_rec[0].pcm = info;\r\ninfo->pcm_type = HDA_PCM_TYPE_HDMI;\r\npstr = &info->stream[SNDRV_PCM_STREAM_PLAYBACK];\r\n*pstr = spec->pcm_playback;\r\npstr->nid = per_cvt->cvt_nid;\r\nif (pstr->channels_max <= 2 && chans && chans <= 16)\r\npstr->channels_max = chans;\r\nreturn 0;\r\n}\r\nstatic void simple_hdmi_unsol_event(struct hda_codec *codec,\r\nunsigned int res)\r\n{\r\nsnd_hda_jack_set_dirty_all(codec);\r\nsnd_hda_jack_report_sync(codec);\r\n}\r\nstatic int simple_playback_build_controls(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_cvt *per_cvt;\r\nint err;\r\nper_cvt = get_cvt(spec, 0);\r\nerr = snd_hda_create_dig_out_ctls(codec, per_cvt->cvt_nid,\r\nper_cvt->cvt_nid,\r\nHDA_PCM_TYPE_HDMI);\r\nif (err < 0)\r\nreturn err;\r\nreturn simple_hdmi_build_jack(codec, 0);\r\n}\r\nstatic int simple_playback_init(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hdmi_spec_per_pin *per_pin = get_pin(spec, 0);\r\nhda_nid_t pin = per_pin->pin_nid;\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT);\r\nif (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)\r\nsnd_hda_codec_write(codec, pin, 0, AC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_OUT_UNMUTE);\r\nsnd_hda_jack_detect_enable(codec, pin);\r\nreturn 0;\r\n}\r\nstatic void simple_playback_free(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nhdmi_array_free(spec);\r\nkfree(spec);\r\n}\r\nstatic int nvhdmi_7x_init_2ch(struct hda_codec *codec)\r\n{\r\nsnd_hda_sequence_write(codec, nvhdmi_basic_init_7x_2ch);\r\nreturn 0;\r\n}\r\nstatic int nvhdmi_7x_init_8ch(struct hda_codec *codec)\r\n{\r\nsnd_hda_sequence_write(codec, nvhdmi_basic_init_7x_8ch);\r\nreturn 0;\r\n}\r\nstatic int simple_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct snd_pcm_hw_constraint_list *hw_constraints_channels = NULL;\r\nswitch (codec->preset->vendor_id) {\r\ncase 0x10de0002:\r\ncase 0x10de0003:\r\ncase 0x10de0005:\r\ncase 0x10de0006:\r\nhw_constraints_channels = &hw_constraints_2_8_channels;\r\nbreak;\r\ncase 0x10de0007:\r\nhw_constraints_channels = &hw_constraints_2_6_8_channels;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hw_constraints_channels != NULL) {\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_constraints_channels);\r\n} else {\r\nsnd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, 2);\r\n}\r\nreturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\r\n}\r\nstatic int simple_playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\r\n}\r\nstatic int simple_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout,\r\nstream_tag, format, substream);\r\n}\r\nstatic int patch_simple_hdmi(struct hda_codec *codec,\r\nhda_nid_t cvt_nid, hda_nid_t pin_nid)\r\n{\r\nstruct hdmi_spec *spec;\r\nstruct hdmi_spec_per_cvt *per_cvt;\r\nstruct hdmi_spec_per_pin *per_pin;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\nhdmi_array_init(spec, 1);\r\nspec->multiout.num_dacs = 0;\r\nspec->multiout.max_channels = 2;\r\nspec->multiout.dig_out_nid = cvt_nid;\r\nspec->num_cvts = 1;\r\nspec->num_pins = 1;\r\nper_pin = snd_array_new(&spec->pins);\r\nper_cvt = snd_array_new(&spec->cvts);\r\nif (!per_pin || !per_cvt) {\r\nsimple_playback_free(codec);\r\nreturn -ENOMEM;\r\n}\r\nper_cvt->cvt_nid = cvt_nid;\r\nper_pin->pin_nid = pin_nid;\r\nspec->pcm_playback = simple_pcm_playback;\r\ncodec->patch_ops = simple_hdmi_patch_ops;\r\nreturn 0;\r\n}\r\nstatic void nvhdmi_8ch_7x_set_info_frame_parameters(struct hda_codec *codec,\r\nint channels)\r\n{\r\nunsigned int chanmask;\r\nint chan = channels ? (channels - 1) : 1;\r\nswitch (channels) {\r\ndefault:\r\ncase 0:\r\ncase 2:\r\nchanmask = 0x00;\r\nbreak;\r\ncase 4:\r\nchanmask = 0x08;\r\nbreak;\r\ncase 6:\r\nchanmask = 0x0b;\r\nbreak;\r\ncase 8:\r\nchanmask = 0x13;\r\nbreak;\r\n}\r\nsnd_hda_codec_write(codec, 0x1, 0,\r\nNv_VERB_SET_Channel_Allocation, chanmask);\r\nsnd_hda_codec_write(codec, 0x1, 0,\r\nNv_VERB_SET_Info_Frame_Checksum,\r\n(0x71 - chan - chanmask));\r\n}\r\nstatic int nvhdmi_8ch_7x_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint i;\r\nsnd_hda_codec_write(codec, nvhdmi_master_con_nid_7x,\r\n0, AC_VERB_SET_CHANNEL_STREAMID, 0);\r\nfor (i = 0; i < 4; i++) {\r\nsnd_hda_codec_write(codec, nvhdmi_con_nids_7x[i], 0,\r\nAC_VERB_SET_CHANNEL_STREAMID, 0);\r\nsnd_hda_codec_write(codec, nvhdmi_con_nids_7x[i], 0,\r\nAC_VERB_SET_STREAM_FORMAT, 0);\r\n}\r\nnvhdmi_8ch_7x_set_info_frame_parameters(codec, 8);\r\nreturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\r\n}\r\nstatic int nvhdmi_8ch_7x_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint chs;\r\nunsigned int dataDCC2, channel_id;\r\nint i;\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hda_spdif_out *spdif;\r\nstruct hdmi_spec_per_cvt *per_cvt;\r\nmutex_lock(&codec->spdif_mutex);\r\nper_cvt = get_cvt(spec, 0);\r\nspdif = snd_hda_spdif_out_of_nid(codec, per_cvt->cvt_nid);\r\nchs = substream->runtime->channels;\r\ndataDCC2 = 0x2;\r\nif (codec->spdif_status_reset && (spdif->ctls & AC_DIG1_ENABLE))\r\nsnd_hda_codec_write(codec,\r\nnvhdmi_master_con_nid_7x,\r\n0,\r\nAC_VERB_SET_DIGI_CONVERT_1,\r\nspdif->ctls & ~AC_DIG1_ENABLE & 0xff);\r\nsnd_hda_codec_write(codec, nvhdmi_master_con_nid_7x, 0,\r\nAC_VERB_SET_CHANNEL_STREAMID, (stream_tag << 4) | 0x0);\r\nsnd_hda_codec_write(codec, nvhdmi_master_con_nid_7x, 0,\r\nAC_VERB_SET_STREAM_FORMAT, format);\r\nif (codec->spdif_status_reset && (spdif->ctls & AC_DIG1_ENABLE)) {\r\nsnd_hda_codec_write(codec,\r\nnvhdmi_master_con_nid_7x,\r\n0,\r\nAC_VERB_SET_DIGI_CONVERT_1,\r\nspdif->ctls & 0xff);\r\nsnd_hda_codec_write(codec,\r\nnvhdmi_master_con_nid_7x,\r\n0,\r\nAC_VERB_SET_DIGI_CONVERT_2, dataDCC2);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif (chs == 2)\r\nchannel_id = 0;\r\nelse\r\nchannel_id = i * 2;\r\nif (codec->spdif_status_reset &&\r\n(spdif->ctls & AC_DIG1_ENABLE))\r\nsnd_hda_codec_write(codec,\r\nnvhdmi_con_nids_7x[i],\r\n0,\r\nAC_VERB_SET_DIGI_CONVERT_1,\r\nspdif->ctls & ~AC_DIG1_ENABLE & 0xff);\r\nsnd_hda_codec_write(codec,\r\nnvhdmi_con_nids_7x[i],\r\n0,\r\nAC_VERB_SET_CHANNEL_STREAMID,\r\n(stream_tag << 4) | channel_id);\r\nsnd_hda_codec_write(codec,\r\nnvhdmi_con_nids_7x[i],\r\n0,\r\nAC_VERB_SET_STREAM_FORMAT,\r\nformat);\r\nif (codec->spdif_status_reset &&\r\n(spdif->ctls & AC_DIG1_ENABLE)) {\r\nsnd_hda_codec_write(codec,\r\nnvhdmi_con_nids_7x[i],\r\n0,\r\nAC_VERB_SET_DIGI_CONVERT_1,\r\nspdif->ctls & 0xff);\r\nsnd_hda_codec_write(codec,\r\nnvhdmi_con_nids_7x[i],\r\n0,\r\nAC_VERB_SET_DIGI_CONVERT_2, dataDCC2);\r\n}\r\n}\r\nnvhdmi_8ch_7x_set_info_frame_parameters(codec, chs);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nstatic int patch_nvhdmi_2ch(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec;\r\nint err = patch_simple_hdmi(codec, nvhdmi_master_con_nid_7x,\r\nnvhdmi_master_pin_nid_7x);\r\nif (err < 0)\r\nreturn err;\r\ncodec->patch_ops.init = nvhdmi_7x_init_2ch;\r\nspec = codec->spec;\r\nspec->pcm_playback.rates = SUPPORTED_RATES;\r\nspec->pcm_playback.maxbps = SUPPORTED_MAXBPS;\r\nspec->pcm_playback.formats = SUPPORTED_FORMATS;\r\nreturn 0;\r\n}\r\nstatic int nvhdmi_7x_8ch_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint err = simple_playback_build_pcms(codec);\r\nif (!err) {\r\nstruct hda_pcm *info = get_pcm_rec(spec, 0);\r\ninfo->own_chmap = true;\r\n}\r\nreturn err;\r\n}\r\nstatic int nvhdmi_7x_8ch_build_controls(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nstruct hda_pcm *info;\r\nstruct snd_pcm_chmap *chmap;\r\nint err;\r\nerr = simple_playback_build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\ninfo = get_pcm_rec(spec, 0);\r\nerr = snd_pcm_add_chmap_ctls(info->pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_alt_chmaps, 8, 0, &chmap);\r\nif (err < 0)\r\nreturn err;\r\nswitch (codec->preset->vendor_id) {\r\ncase 0x10de0002:\r\ncase 0x10de0003:\r\ncase 0x10de0005:\r\ncase 0x10de0006:\r\nchmap->channel_mask = (1U << 2) | (1U << 8);\r\nbreak;\r\ncase 0x10de0007:\r\nchmap->channel_mask = (1U << 2) | (1U << 6) | (1U << 8);\r\n}\r\nreturn 0;\r\n}\r\nstatic int patch_nvhdmi_8ch_7x(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec;\r\nint err = patch_nvhdmi_2ch(codec);\r\nif (err < 0)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->multiout.max_channels = 8;\r\nspec->pcm_playback = nvhdmi_pcm_playback_8ch_7x;\r\ncodec->patch_ops.init = nvhdmi_7x_init_8ch;\r\ncodec->patch_ops.build_pcms = nvhdmi_7x_8ch_build_pcms;\r\ncodec->patch_ops.build_controls = nvhdmi_7x_8ch_build_controls;\r\nnvhdmi_8ch_7x_set_info_frame_parameters(codec, 8);\r\nreturn 0;\r\n}\r\nstatic int nvhdmi_chmap_cea_alloc_validate_get_type(struct hdac_chmap *chmap,\r\nstruct hdac_cea_channel_speaker_allocation *cap, int channels)\r\n{\r\nif (cap->ca_index == 0x00 && channels == 2)\r\nreturn SNDRV_CTL_TLVT_CHMAP_FIXED;\r\nif (cap->channels != channels)\r\nreturn -1;\r\nreturn SNDRV_CTL_TLVT_CHMAP_VAR;\r\n}\r\nstatic int nvhdmi_chmap_validate(struct hdac_chmap *chmap,\r\nint ca, int chs, unsigned char *map)\r\n{\r\nif (ca == 0x00 && (map[0] != SNDRV_CHMAP_FL || map[1] != SNDRV_CHMAP_FR))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int patch_nvhdmi(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec;\r\nint err;\r\nerr = patch_generic_hdmi(codec);\r\nif (err)\r\nreturn err;\r\nspec = codec->spec;\r\nspec->dyn_pin_out = true;\r\nspec->chmap.ops.chmap_cea_alloc_validate_get_type =\r\nnvhdmi_chmap_cea_alloc_validate_get_type;\r\nspec->chmap.ops.chmap_validate = nvhdmi_chmap_validate;\r\nreturn 0;\r\n}\r\nstatic void tegra_hdmi_set_format(struct hda_codec *codec, unsigned int format)\r\n{\r\nunsigned int value;\r\nvalue = snd_hda_codec_read(codec, NVIDIA_AFG_NID, 0,\r\nNVIDIA_GET_SCRATCH0, 0);\r\nvalue = (value >> 24) & 0xff;\r\nsnd_hda_codec_write(codec, NVIDIA_AFG_NID, 0,\r\nNVIDIA_SET_SCRATCH0_BYTE0,\r\n(format >> 0) & 0xff);\r\nsnd_hda_codec_write(codec, NVIDIA_AFG_NID, 0,\r\nNVIDIA_SET_SCRATCH0_BYTE1,\r\n(format >> 8) & 0xff);\r\nsnd_hda_codec_write(codec, NVIDIA_AFG_NID, 0,\r\nNVIDIA_SET_SCRATCH0_BYTE2, 0);\r\nif (format == 0)\r\nvalue &= ~NVIDIA_SCRATCH_VALID;\r\nelse\r\nvalue |= NVIDIA_SCRATCH_VALID;\r\nvalue ^= NVIDIA_SCRATCH_TRIGGER;\r\nsnd_hda_codec_write(codec, NVIDIA_AFG_NID, 0,\r\nNVIDIA_SET_SCRATCH0_BYTE3, value);\r\n}\r\nstatic int tegra_hdmi_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nerr = generic_hdmi_playback_pcm_prepare(hinfo, codec, stream_tag,\r\nformat, substream);\r\nif (err < 0)\r\nreturn err;\r\ntegra_hdmi_set_format(codec, format);\r\nreturn 0;\r\n}\r\nstatic int tegra_hdmi_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\ntegra_hdmi_set_format(codec, 0);\r\nreturn generic_hdmi_playback_pcm_cleanup(hinfo, codec, substream);\r\n}\r\nstatic struct hda_pcm *hda_find_pcm_by_type(struct hda_codec *codec, int type)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nunsigned int i;\r\nfor (i = 0; i < spec->num_pins; i++) {\r\nstruct hda_pcm *pcm = get_pcm_rec(spec, i);\r\nif (pcm->pcm_type == type)\r\nreturn pcm;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int tegra_hdmi_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct hda_pcm_stream *stream;\r\nstruct hda_pcm *pcm;\r\nint err;\r\nerr = generic_hdmi_build_pcms(codec);\r\nif (err < 0)\r\nreturn err;\r\npcm = hda_find_pcm_by_type(codec, HDA_PCM_TYPE_HDMI);\r\nif (!pcm)\r\nreturn -ENODEV;\r\nstream = &pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];\r\nstream->ops.prepare = tegra_hdmi_pcm_prepare;\r\nstream->ops.cleanup = tegra_hdmi_pcm_cleanup;\r\nreturn 0;\r\n}\r\nstatic int patch_tegra_hdmi(struct hda_codec *codec)\r\n{\r\nint err;\r\nerr = patch_generic_hdmi(codec);\r\nif (err)\r\nreturn err;\r\ncodec->patch_ops.build_pcms = tegra_hdmi_build_pcms;\r\nreturn 0;\r\n}\r\nstatic int atihdmi_pin_get_eld(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned char *buf, int *eld_size)\r\n{\r\nreturn snd_hdmi_get_eld_ati(codec, nid, buf, eld_size,\r\nis_amdhdmi_rev3_or_later(codec));\r\n}\r\nstatic void atihdmi_pin_setup_infoframe(struct hda_codec *codec, hda_nid_t pin_nid, int ca,\r\nint active_channels, int conn_type)\r\n{\r\nsnd_hda_codec_write(codec, pin_nid, 0, ATI_VERB_SET_CHANNEL_ALLOCATION, ca);\r\n}\r\nstatic int atihdmi_paired_swap_fc_lfe(int pos)\r\n{\r\nswitch (pos) {\r\ncase 2: return 3;\r\ncase 3: return 2;\r\ndefault: break;\r\n}\r\nreturn pos;\r\n}\r\nstatic int atihdmi_paired_chmap_validate(struct hdac_chmap *chmap,\r\nint ca, int chs, unsigned char *map)\r\n{\r\nstruct hdac_cea_channel_speaker_allocation *cap;\r\nint i, j;\r\ncap = snd_hdac_get_ch_alloc_from_ca(ca);\r\nfor (i = 0; i < chs; ++i) {\r\nint mask = snd_hdac_chmap_to_spk_mask(map[i]);\r\nbool ok = false;\r\nbool companion_ok = false;\r\nif (!mask)\r\ncontinue;\r\nfor (j = 0 + i % 2; j < 8; j += 2) {\r\nint chan_idx = 7 - atihdmi_paired_swap_fc_lfe(j);\r\nif (cap->speakers[chan_idx] == mask) {\r\nok = true;\r\nif (i % 2 == 0 && i + 1 < chs) {\r\nint comp_chan_idx = 7 - atihdmi_paired_swap_fc_lfe(j + 1);\r\nint comp_mask_req = snd_hdac_chmap_to_spk_mask(map[i+1]);\r\nint comp_mask_act = cap->speakers[comp_chan_idx];\r\nif (comp_mask_req == comp_mask_act)\r\ncompanion_ok = true;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (!ok)\r\nreturn -EINVAL;\r\nif (companion_ok)\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atihdmi_pin_set_slot_channel(struct hdac_device *hdac,\r\nhda_nid_t pin_nid, int hdmi_slot, int stream_channel)\r\n{\r\nstruct hda_codec *codec = container_of(hdac, struct hda_codec, core);\r\nint verb;\r\nint ati_channel_setup = 0;\r\nif (hdmi_slot > 7)\r\nreturn -EINVAL;\r\nif (!has_amd_full_remap_support(codec)) {\r\nhdmi_slot = atihdmi_paired_swap_fc_lfe(hdmi_slot);\r\nif (hdmi_slot % 2 != 0 && stream_channel == 0xf)\r\nreturn 0;\r\nhdmi_slot -= hdmi_slot % 2;\r\nif (stream_channel != 0xf)\r\nstream_channel -= stream_channel % 2;\r\n}\r\nverb = ATI_VERB_SET_MULTICHANNEL_01 + hdmi_slot/2 + (hdmi_slot % 2) * 0x00e;\r\nif (stream_channel != 0xf)\r\nati_channel_setup = (stream_channel << 4) | ATI_OUT_ENABLE;\r\nreturn snd_hda_codec_write(codec, pin_nid, 0, verb, ati_channel_setup);\r\n}\r\nstatic int atihdmi_pin_get_slot_channel(struct hdac_device *hdac,\r\nhda_nid_t pin_nid, int asp_slot)\r\n{\r\nstruct hda_codec *codec = container_of(hdac, struct hda_codec, core);\r\nbool was_odd = false;\r\nint ati_asp_slot = asp_slot;\r\nint verb;\r\nint ati_channel_setup;\r\nif (asp_slot > 7)\r\nreturn -EINVAL;\r\nif (!has_amd_full_remap_support(codec)) {\r\nati_asp_slot = atihdmi_paired_swap_fc_lfe(asp_slot);\r\nif (ati_asp_slot % 2 != 0) {\r\nati_asp_slot -= 1;\r\nwas_odd = true;\r\n}\r\n}\r\nverb = ATI_VERB_GET_MULTICHANNEL_01 + ati_asp_slot/2 + (ati_asp_slot % 2) * 0x00e;\r\nati_channel_setup = snd_hda_codec_read(codec, pin_nid, 0, verb, 0);\r\nif (!(ati_channel_setup & ATI_OUT_ENABLE))\r\nreturn 0xf;\r\nreturn ((ati_channel_setup & 0xf0) >> 4) + !!was_odd;\r\n}\r\nstatic int atihdmi_paired_chmap_cea_alloc_validate_get_type(\r\nstruct hdac_chmap *chmap,\r\nstruct hdac_cea_channel_speaker_allocation *cap,\r\nint channels)\r\n{\r\nint c;\r\nint chanpairs = 0;\r\nif ((channels % 2) != 0)\r\nreturn -1;\r\nfor (c = 0; c < 7; c += 2) {\r\nif (cap->speakers[c] || cap->speakers[c+1])\r\nchanpairs++;\r\n}\r\nif (chanpairs * 2 != channels)\r\nreturn -1;\r\nreturn SNDRV_CTL_TLVT_CHMAP_PAIRED;\r\n}\r\nstatic void atihdmi_paired_cea_alloc_to_tlv_chmap(struct hdac_chmap *hchmap,\r\nstruct hdac_cea_channel_speaker_allocation *cap,\r\nunsigned int *chmap, int channels)\r\n{\r\nint count = 0;\r\nint c;\r\nfor (c = 7; c >= 0; c--) {\r\nint chan = 7 - atihdmi_paired_swap_fc_lfe(7 - c);\r\nint spk = cap->speakers[chan];\r\nif (!spk) {\r\nif (cap->speakers[chan + (chan % 2 ? -1 : 1)])\r\nchmap[count++] = SNDRV_CHMAP_NA;\r\ncontinue;\r\n}\r\nchmap[count++] = snd_hdac_spk_to_chmap(spk);\r\n}\r\nWARN_ON(count != channels);\r\n}\r\nstatic int atihdmi_pin_hbr_setup(struct hda_codec *codec, hda_nid_t pin_nid,\r\nbool hbr)\r\n{\r\nint hbr_ctl, hbr_ctl_new;\r\nhbr_ctl = snd_hda_codec_read(codec, pin_nid, 0, ATI_VERB_GET_HBR_CONTROL, 0);\r\nif (hbr_ctl >= 0 && (hbr_ctl & ATI_HBR_CAPABLE)) {\r\nif (hbr)\r\nhbr_ctl_new = hbr_ctl | ATI_HBR_ENABLE;\r\nelse\r\nhbr_ctl_new = hbr_ctl & ~ATI_HBR_ENABLE;\r\ncodec_dbg(codec,\r\n"atihdmi_pin_hbr_setup: NID=0x%x, %shbr-ctl=0x%x\n",\r\npin_nid,\r\nhbr_ctl == hbr_ctl_new ? "" : "new-",\r\nhbr_ctl_new);\r\nif (hbr_ctl != hbr_ctl_new)\r\nsnd_hda_codec_write(codec, pin_nid, 0,\r\nATI_VERB_SET_HBR_CONTROL,\r\nhbr_ctl_new);\r\n} else if (hbr)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int atihdmi_setup_stream(struct hda_codec *codec, hda_nid_t cvt_nid,\r\nhda_nid_t pin_nid, u32 stream_tag, int format)\r\n{\r\nif (is_amdhdmi_rev3_or_later(codec)) {\r\nint ramp_rate = 180;\r\nif (format & AC_FMT_TYPE_NON_PCM)\r\nramp_rate = 0;\r\nsnd_hda_codec_write(codec, cvt_nid, 0, ATI_VERB_SET_RAMP_RATE, ramp_rate);\r\n}\r\nreturn hdmi_setup_stream(codec, cvt_nid, pin_nid, stream_tag, format);\r\n}\r\nstatic int atihdmi_init(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec = codec->spec;\r\nint pin_idx, err;\r\nerr = generic_hdmi_init(codec);\r\nif (err)\r\nreturn err;\r\nfor (pin_idx = 0; pin_idx < spec->num_pins; pin_idx++) {\r\nstruct hdmi_spec_per_pin *per_pin = get_pin(spec, pin_idx);\r\nsnd_hda_codec_write(codec, per_pin->pin_nid, 0, ATI_VERB_SET_DOWNMIX_INFO, 0);\r\nif (has_amd_full_remap_support(codec))\r\nsnd_hda_codec_write(codec, per_pin->pin_nid, 0,\r\nATI_VERB_SET_MULTICHANNEL_MODE,\r\nATI_MULTICHANNEL_MODE_SINGLE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int patch_atihdmi(struct hda_codec *codec)\r\n{\r\nstruct hdmi_spec *spec;\r\nstruct hdmi_spec_per_cvt *per_cvt;\r\nint err, cvt_idx;\r\nerr = patch_generic_hdmi(codec);\r\nif (err)\r\nreturn err;\r\ncodec->patch_ops.init = atihdmi_init;\r\nspec = codec->spec;\r\nspec->ops.pin_get_eld = atihdmi_pin_get_eld;\r\nspec->ops.pin_setup_infoframe = atihdmi_pin_setup_infoframe;\r\nspec->ops.pin_hbr_setup = atihdmi_pin_hbr_setup;\r\nspec->ops.setup_stream = atihdmi_setup_stream;\r\nspec->chmap.ops.pin_get_slot_channel = atihdmi_pin_get_slot_channel;\r\nspec->chmap.ops.pin_set_slot_channel = atihdmi_pin_set_slot_channel;\r\nif (!has_amd_full_remap_support(codec)) {\r\nspec->chmap.ops.chmap_cea_alloc_validate_get_type =\r\natihdmi_paired_chmap_cea_alloc_validate_get_type;\r\nspec->chmap.ops.cea_alloc_to_tlv_chmap =\r\natihdmi_paired_cea_alloc_to_tlv_chmap;\r\nspec->chmap.ops.chmap_validate = atihdmi_paired_chmap_validate;\r\n}\r\nfor (cvt_idx = 0; cvt_idx < spec->num_cvts; cvt_idx++) {\r\nper_cvt = get_cvt(spec, cvt_idx);\r\nper_cvt->channels_max = max(per_cvt->channels_max, 8u);\r\nper_cvt->rates |= SUPPORTED_RATES;\r\nper_cvt->formats |= SUPPORTED_FORMATS;\r\nper_cvt->maxbps = max(per_cvt->maxbps, 24u);\r\n}\r\nspec->chmap.channels_max = max(spec->chmap.channels_max, 8u);\r\nreturn 0;\r\n}\r\nstatic int patch_via_hdmi(struct hda_codec *codec)\r\n{\r\nreturn patch_simple_hdmi(codec, VIAHDMI_CVT_NID, VIAHDMI_PIN_NID);\r\n}
