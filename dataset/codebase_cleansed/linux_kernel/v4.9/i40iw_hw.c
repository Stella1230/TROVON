u32 i40iw_initialize_hw_resources(struct i40iw_device *iwdev)\r\n{\r\nunsigned long num_pds;\r\nu32 resources_size;\r\nu32 max_mr;\r\nu32 max_qp;\r\nu32 max_cq;\r\nu32 arp_table_size;\r\nu32 mrdrvbits;\r\nvoid *resource_ptr;\r\nmax_qp = iwdev->sc_dev.hmc_info->hmc_obj[I40IW_HMC_IW_QP].cnt;\r\nmax_cq = iwdev->sc_dev.hmc_info->hmc_obj[I40IW_HMC_IW_CQ].cnt;\r\nmax_mr = iwdev->sc_dev.hmc_info->hmc_obj[I40IW_HMC_IW_MR].cnt;\r\narp_table_size = iwdev->sc_dev.hmc_info->hmc_obj[I40IW_HMC_IW_ARP].cnt;\r\niwdev->max_cqe = 0xFFFFF;\r\nnum_pds = max_qp * 4;\r\nresources_size = sizeof(struct i40iw_arp_entry) * arp_table_size;\r\nresources_size += sizeof(unsigned long) * BITS_TO_LONGS(max_qp);\r\nresources_size += sizeof(unsigned long) * BITS_TO_LONGS(max_mr);\r\nresources_size += sizeof(unsigned long) * BITS_TO_LONGS(max_cq);\r\nresources_size += sizeof(unsigned long) * BITS_TO_LONGS(num_pds);\r\nresources_size += sizeof(unsigned long) * BITS_TO_LONGS(arp_table_size);\r\nresources_size += sizeof(struct i40iw_qp **) * max_qp;\r\niwdev->mem_resources = kzalloc(resources_size, GFP_KERNEL);\r\nif (!iwdev->mem_resources)\r\nreturn -ENOMEM;\r\niwdev->max_qp = max_qp;\r\niwdev->max_mr = max_mr;\r\niwdev->max_cq = max_cq;\r\niwdev->max_pd = num_pds;\r\niwdev->arp_table_size = arp_table_size;\r\niwdev->arp_table = (struct i40iw_arp_entry *)iwdev->mem_resources;\r\nresource_ptr = iwdev->mem_resources + (sizeof(struct i40iw_arp_entry) * arp_table_size);\r\niwdev->device_cap_flags = IB_DEVICE_LOCAL_DMA_LKEY |\r\nIB_DEVICE_MEM_WINDOW | IB_DEVICE_MEM_MGT_EXTENSIONS;\r\niwdev->allocated_qps = resource_ptr;\r\niwdev->allocated_cqs = &iwdev->allocated_qps[BITS_TO_LONGS(max_qp)];\r\niwdev->allocated_mrs = &iwdev->allocated_cqs[BITS_TO_LONGS(max_cq)];\r\niwdev->allocated_pds = &iwdev->allocated_mrs[BITS_TO_LONGS(max_mr)];\r\niwdev->allocated_arps = &iwdev->allocated_pds[BITS_TO_LONGS(num_pds)];\r\niwdev->qp_table = (struct i40iw_qp **)(&iwdev->allocated_arps[BITS_TO_LONGS(arp_table_size)]);\r\nset_bit(0, iwdev->allocated_mrs);\r\nset_bit(0, iwdev->allocated_qps);\r\nset_bit(0, iwdev->allocated_cqs);\r\nset_bit(0, iwdev->allocated_pds);\r\nset_bit(0, iwdev->allocated_arps);\r\nset_bit(1, iwdev->allocated_qps);\r\nset_bit(1, iwdev->allocated_cqs);\r\nset_bit(1, iwdev->allocated_pds);\r\nset_bit(2, iwdev->allocated_cqs);\r\nset_bit(2, iwdev->allocated_pds);\r\nspin_lock_init(&iwdev->resource_lock);\r\nspin_lock_init(&iwdev->qptable_lock);\r\nmrdrvbits = 24 - max(get_count_order(iwdev->max_mr), 14);\r\niwdev->mr_stagmask = ~(((1 << mrdrvbits) - 1) << (32 - mrdrvbits));\r\nreturn 0;\r\n}\r\nstatic void i40iw_cqp_ce_handler(struct i40iw_device *iwdev, struct i40iw_sc_cq *cq, bool arm)\r\n{\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nu32 cqe_count = 0;\r\nstruct i40iw_ccq_cqe_info info;\r\nint ret;\r\ndo {\r\nmemset(&info, 0, sizeof(info));\r\nret = dev->ccq_ops->ccq_get_cqe_info(cq, &info);\r\nif (ret)\r\nbreak;\r\ncqp_request = (struct i40iw_cqp_request *)(unsigned long)info.scratch;\r\nif (info.error)\r\ni40iw_pr_err("opcode = 0x%x maj_err_code = 0x%x min_err_code = 0x%x\n",\r\ninfo.op_code, info.maj_err_code, info.min_err_code);\r\nif (cqp_request) {\r\ncqp_request->compl_info.maj_err_code = info.maj_err_code;\r\ncqp_request->compl_info.min_err_code = info.min_err_code;\r\ncqp_request->compl_info.op_ret_val = info.op_ret_val;\r\ncqp_request->compl_info.error = info.error;\r\nif (cqp_request->waiting) {\r\ncqp_request->request_done = true;\r\nwake_up(&cqp_request->waitq);\r\ni40iw_put_cqp_request(&iwdev->cqp, cqp_request);\r\n} else {\r\nif (cqp_request->callback_fcn)\r\ncqp_request->callback_fcn(cqp_request, 1);\r\ni40iw_put_cqp_request(&iwdev->cqp, cqp_request);\r\n}\r\n}\r\ncqe_count++;\r\n} while (1);\r\nif (arm && cqe_count) {\r\ni40iw_process_bh(dev);\r\ndev->ccq_ops->ccq_arm(cq);\r\n}\r\n}\r\nstatic void i40iw_iwarp_ce_handler(struct i40iw_device *iwdev,\r\nstruct i40iw_sc_cq *iwcq)\r\n{\r\nstruct i40iw_cq *i40iwcq = iwcq->back_cq;\r\nif (i40iwcq->ibcq.comp_handler)\r\ni40iwcq->ibcq.comp_handler(&i40iwcq->ibcq,\r\ni40iwcq->ibcq.cq_context);\r\n}\r\nstatic void i40iw_puda_ce_handler(struct i40iw_device *iwdev,\r\nstruct i40iw_sc_cq *cq)\r\n{\r\nstruct i40iw_sc_dev *dev = (struct i40iw_sc_dev *)&iwdev->sc_dev;\r\nenum i40iw_status_code status;\r\nu32 compl_error;\r\ndo {\r\nstatus = i40iw_puda_poll_completion(dev, cq, &compl_error);\r\nif (status == I40IW_ERR_QUEUE_EMPTY)\r\nbreak;\r\nif (status) {\r\ni40iw_pr_err("puda status = %d\n", status);\r\nbreak;\r\n}\r\nif (compl_error) {\r\ni40iw_pr_err("puda compl_err =0x%x\n", compl_error);\r\nbreak;\r\n}\r\n} while (1);\r\ndev->ccq_ops->ccq_arm(cq);\r\n}\r\nvoid i40iw_process_ceq(struct i40iw_device *iwdev, struct i40iw_ceq *ceq)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_sc_ceq *sc_ceq;\r\nstruct i40iw_sc_cq *cq;\r\nbool arm = true;\r\nsc_ceq = &ceq->sc_ceq;\r\ndo {\r\ncq = dev->ceq_ops->process_ceq(dev, sc_ceq);\r\nif (!cq)\r\nbreak;\r\nif (cq->cq_type == I40IW_CQ_TYPE_CQP)\r\ni40iw_cqp_ce_handler(iwdev, cq, arm);\r\nelse if (cq->cq_type == I40IW_CQ_TYPE_IWARP)\r\ni40iw_iwarp_ce_handler(iwdev, cq);\r\nelse if ((cq->cq_type == I40IW_CQ_TYPE_ILQ) ||\r\n(cq->cq_type == I40IW_CQ_TYPE_IEQ))\r\ni40iw_puda_ce_handler(iwdev, cq);\r\n} while (1);\r\n}\r\nvoid i40iw_next_iw_state(struct i40iw_qp *iwqp,\r\nu8 state,\r\nu8 del_hash,\r\nu8 term,\r\nu8 termlen)\r\n{\r\nstruct i40iw_modify_qp_info info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.next_iwarp_state = state;\r\ninfo.remove_hash_idx = del_hash;\r\ninfo.cq_num_valid = true;\r\ninfo.arp_cache_idx_valid = true;\r\ninfo.dont_send_term = true;\r\ninfo.dont_send_fin = true;\r\ninfo.termlen = termlen;\r\nif (term & I40IWQP_TERM_SEND_TERM_ONLY)\r\ninfo.dont_send_term = false;\r\nif (term & I40IWQP_TERM_SEND_FIN_ONLY)\r\ninfo.dont_send_fin = false;\r\nif (iwqp->sc_qp.term_flags && (state == I40IW_QP_STATE_ERROR))\r\ninfo.reset_tcp_conn = true;\r\niwqp->hw_iwarp_state = state;\r\ni40iw_hw_modify_qp(iwqp->iwdev, iwqp, &info, 0);\r\n}\r\nvoid i40iw_process_aeq(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_aeq *aeq = &iwdev->aeq;\r\nstruct i40iw_sc_aeq *sc_aeq = &aeq->sc_aeq;\r\nstruct i40iw_aeqe_info aeinfo;\r\nstruct i40iw_aeqe_info *info = &aeinfo;\r\nint ret;\r\nstruct i40iw_qp *iwqp = NULL;\r\nstruct i40iw_sc_cq *cq = NULL;\r\nstruct i40iw_cq *iwcq = NULL;\r\nstruct i40iw_sc_qp *qp = NULL;\r\nstruct i40iw_qp_host_ctx_info *ctx_info = NULL;\r\nunsigned long flags;\r\nu32 aeqcnt = 0;\r\nif (!sc_aeq->size)\r\nreturn;\r\ndo {\r\nmemset(info, 0, sizeof(*info));\r\nret = dev->aeq_ops->get_next_aeqe(sc_aeq, info);\r\nif (ret)\r\nbreak;\r\naeqcnt++;\r\ni40iw_debug(dev, I40IW_DEBUG_AEQ,\r\n"%s ae_id = 0x%x bool qp=%d qp_id = %d\n",\r\n__func__, info->ae_id, info->qp, info->qp_cq_id);\r\nif (info->qp) {\r\nspin_lock_irqsave(&iwdev->qptable_lock, flags);\r\niwqp = iwdev->qp_table[info->qp_cq_id];\r\nif (!iwqp) {\r\nspin_unlock_irqrestore(&iwdev->qptable_lock, flags);\r\ni40iw_pr_err("qp_id %d is already freed\n", info->qp_cq_id);\r\ncontinue;\r\n}\r\ni40iw_add_ref(&iwqp->ibqp);\r\nspin_unlock_irqrestore(&iwdev->qptable_lock, flags);\r\nqp = &iwqp->sc_qp;\r\nspin_lock_irqsave(&iwqp->lock, flags);\r\niwqp->hw_tcp_state = info->tcp_state;\r\niwqp->hw_iwarp_state = info->iwarp_state;\r\niwqp->last_aeq = info->ae_id;\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\nctx_info = &iwqp->ctx_info;\r\nctx_info->err_rq_idx_valid = true;\r\n} else {\r\nif (info->ae_id != I40IW_AE_CQ_OPERATION_ERROR)\r\ncontinue;\r\n}\r\nswitch (info->ae_id) {\r\ncase I40IW_AE_LLP_FIN_RECEIVED:\r\nif (qp->term_flags)\r\ncontinue;\r\nif (atomic_inc_return(&iwqp->close_timer_started) == 1) {\r\niwqp->hw_tcp_state = I40IW_TCP_STATE_CLOSE_WAIT;\r\nif ((iwqp->hw_tcp_state == I40IW_TCP_STATE_CLOSE_WAIT) &&\r\n(iwqp->ibqp_state == IB_QPS_RTS)) {\r\ni40iw_next_iw_state(iwqp,\r\nI40IW_QP_STATE_CLOSING, 0, 0, 0);\r\ni40iw_cm_disconn(iwqp);\r\n}\r\niwqp->cm_id->add_ref(iwqp->cm_id);\r\ni40iw_schedule_cm_timer(iwqp->cm_node,\r\n(struct i40iw_puda_buf *)iwqp,\r\nI40IW_TIMER_TYPE_CLOSE, 1, 0);\r\n}\r\nbreak;\r\ncase I40IW_AE_LLP_CLOSE_COMPLETE:\r\nif (qp->term_flags)\r\ni40iw_terminate_done(qp, 0);\r\nelse\r\ni40iw_cm_disconn(iwqp);\r\nbreak;\r\ncase I40IW_AE_RESET_SENT:\r\ni40iw_next_iw_state(iwqp, I40IW_QP_STATE_ERROR, 1, 0, 0);\r\ni40iw_cm_disconn(iwqp);\r\nbreak;\r\ncase I40IW_AE_LLP_CONNECTION_RESET:\r\nif (atomic_read(&iwqp->close_timer_started))\r\ncontinue;\r\ni40iw_cm_disconn(iwqp);\r\nbreak;\r\ncase I40IW_AE_TERMINATE_SENT:\r\ni40iw_terminate_send_fin(qp);\r\nbreak;\r\ncase I40IW_AE_LLP_TERMINATE_RECEIVED:\r\ni40iw_terminate_received(qp, info);\r\nbreak;\r\ncase I40IW_AE_CQ_OPERATION_ERROR:\r\ni40iw_pr_err("Processing an iWARP related AE for CQ misc = 0x%04X\n",\r\ninfo->ae_id);\r\ncq = (struct i40iw_sc_cq *)(unsigned long)info->compl_ctx;\r\niwcq = (struct i40iw_cq *)cq->back_cq;\r\nif (iwcq->ibcq.event_handler) {\r\nstruct ib_event ibevent;\r\nibevent.device = iwcq->ibcq.device;\r\nibevent.event = IB_EVENT_CQ_ERR;\r\nibevent.element.cq = &iwcq->ibcq;\r\niwcq->ibcq.event_handler(&ibevent, iwcq->ibcq.cq_context);\r\n}\r\nbreak;\r\ncase I40IW_AE_PRIV_OPERATION_DENIED:\r\ncase I40IW_AE_STAG_ZERO_INVALID:\r\ncase I40IW_AE_IB_RREQ_AND_Q1_FULL:\r\ncase I40IW_AE_DDP_UBE_INVALID_DDP_VERSION:\r\ncase I40IW_AE_DDP_UBE_INVALID_MO:\r\ncase I40IW_AE_DDP_UBE_INVALID_QN:\r\ncase I40IW_AE_DDP_NO_L_BIT:\r\ncase I40IW_AE_RDMAP_ROE_INVALID_RDMAP_VERSION:\r\ncase I40IW_AE_RDMAP_ROE_UNEXPECTED_OPCODE:\r\ncase I40IW_AE_ROE_INVALID_RDMA_READ_REQUEST:\r\ncase I40IW_AE_ROE_INVALID_RDMA_WRITE_OR_READ_RESP:\r\ncase I40IW_AE_INVALID_ARP_ENTRY:\r\ncase I40IW_AE_INVALID_TCP_OPTION_RCVD:\r\ncase I40IW_AE_STALE_ARP_ENTRY:\r\ncase I40IW_AE_LLP_RECEIVED_MPA_CRC_ERROR:\r\ncase I40IW_AE_LLP_SEGMENT_TOO_SMALL:\r\ncase I40IW_AE_LLP_SYN_RECEIVED:\r\ncase I40IW_AE_LLP_TOO_MANY_RETRIES:\r\ncase I40IW_AE_LLP_DOUBT_REACHABILITY:\r\ncase I40IW_AE_LCE_QP_CATASTROPHIC:\r\ncase I40IW_AE_LCE_FUNCTION_CATASTROPHIC:\r\ncase I40IW_AE_LCE_CQ_CATASTROPHIC:\r\ncase I40IW_AE_UDA_XMIT_DGRAM_TOO_LONG:\r\ncase I40IW_AE_UDA_XMIT_IPADDR_MISMATCH:\r\ncase I40IW_AE_QP_SUSPEND_COMPLETE:\r\nctx_info->err_rq_idx_valid = false;\r\ndefault:\r\nif (!info->sq && ctx_info->err_rq_idx_valid) {\r\nctx_info->err_rq_idx = info->wqe_idx;\r\nctx_info->tcp_info_valid = false;\r\nctx_info->iwarp_info_valid = false;\r\nret = dev->iw_priv_qp_ops->qp_setctx(&iwqp->sc_qp,\r\niwqp->host_ctx.va,\r\nctx_info);\r\n}\r\ni40iw_terminate_connection(qp, info);\r\nbreak;\r\n}\r\nif (info->qp)\r\ni40iw_rem_ref(&iwqp->ibqp);\r\n} while (1);\r\nif (aeqcnt)\r\ndev->aeq_ops->repost_aeq_entries(dev, aeqcnt);\r\n}\r\nint i40iw_manage_apbvt(struct i40iw_device *iwdev, u16 accel_local_port, bool add_port)\r\n{\r\nstruct i40iw_apbvt_info *info;\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, add_port);\r\nif (!cqp_request)\r\nreturn -ENOMEM;\r\ncqp_info = &cqp_request->info;\r\ninfo = &cqp_info->in.u.manage_apbvt_entry.info;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->add = add_port;\r\ninfo->port = cpu_to_le16(accel_local_port);\r\ncqp_info->cqp_cmd = OP_MANAGE_APBVT_ENTRY;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.manage_apbvt_entry.cqp = &iwdev->cqp.sc_cqp;\r\ncqp_info->in.u.manage_apbvt_entry.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Manage APBVT entry fail");\r\nreturn status;\r\n}\r\nvoid i40iw_manage_arp_cache(struct i40iw_device *iwdev,\r\nunsigned char *mac_addr,\r\nu32 *ip_addr,\r\nbool ipv4,\r\nu32 action)\r\n{\r\nstruct i40iw_add_arp_cache_entry_info *info;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nint arp_index;\r\narp_index = i40iw_arp_table(iwdev, ip_addr, ipv4, mac_addr, action);\r\nif (arp_index == -1)\r\nreturn;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, false);\r\nif (!cqp_request)\r\nreturn;\r\ncqp_info = &cqp_request->info;\r\nif (action == I40IW_ARP_ADD) {\r\ncqp_info->cqp_cmd = OP_ADD_ARP_CACHE_ENTRY;\r\ninfo = &cqp_info->in.u.add_arp_cache_entry.info;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->arp_index = cpu_to_le16((u16)arp_index);\r\ninfo->permanent = true;\r\nether_addr_copy(info->mac_addr, mac_addr);\r\ncqp_info->in.u.add_arp_cache_entry.scratch = (uintptr_t)cqp_request;\r\ncqp_info->in.u.add_arp_cache_entry.cqp = &iwdev->cqp.sc_cqp;\r\n} else {\r\ncqp_info->cqp_cmd = OP_DELETE_ARP_CACHE_ENTRY;\r\ncqp_info->in.u.del_arp_cache_entry.scratch = (uintptr_t)cqp_request;\r\ncqp_info->in.u.del_arp_cache_entry.cqp = &iwdev->cqp.sc_cqp;\r\ncqp_info->in.u.del_arp_cache_entry.arp_index = arp_index;\r\n}\r\ncqp_info->in.u.add_arp_cache_entry.cqp = &iwdev->cqp.sc_cqp;\r\ncqp_info->in.u.add_arp_cache_entry.scratch = (uintptr_t)cqp_request;\r\ncqp_info->post_sq = 1;\r\nif (i40iw_handle_cqp_op(iwdev, cqp_request))\r\ni40iw_pr_err("CQP-OP Add/Del Arp Cache entry fail");\r\n}\r\nstatic void i40iw_send_syn_cqp_callback(struct i40iw_cqp_request *cqp_request, u32 send_ack)\r\n{\r\ni40iw_send_syn(cqp_request->param, send_ack);\r\n}\r\nenum i40iw_status_code i40iw_manage_qhash(struct i40iw_device *iwdev,\r\nstruct i40iw_cm_info *cminfo,\r\nenum i40iw_quad_entry_type etype,\r\nenum i40iw_quad_hash_manage_type mtype,\r\nvoid *cmnode,\r\nbool wait)\r\n{\r\nstruct i40iw_qhash_table_info *info;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nenum i40iw_status_code status;\r\nstruct i40iw_cqp *iwcqp = &iwdev->cqp;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\ncqp_request = i40iw_get_cqp_request(iwcqp, wait);\r\nif (!cqp_request)\r\nreturn I40IW_ERR_NO_MEMORY;\r\ncqp_info = &cqp_request->info;\r\ninfo = &cqp_info->in.u.manage_qhash_table_entry.info;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->manage = mtype;\r\ninfo->entry_type = etype;\r\nif (cminfo->vlan_id != 0xFFFF) {\r\ninfo->vlan_valid = true;\r\ninfo->vlan_id = cpu_to_le16(cminfo->vlan_id);\r\n} else {\r\ninfo->vlan_valid = false;\r\n}\r\ninfo->ipv4_valid = cminfo->ipv4;\r\nether_addr_copy(info->mac_addr, iwdev->netdev->dev_addr);\r\ninfo->qp_num = cpu_to_le32(dev->ilq->qp_id);\r\ninfo->dest_port = cpu_to_le16(cminfo->loc_port);\r\ninfo->dest_ip[0] = cpu_to_le32(cminfo->loc_addr[0]);\r\ninfo->dest_ip[1] = cpu_to_le32(cminfo->loc_addr[1]);\r\ninfo->dest_ip[2] = cpu_to_le32(cminfo->loc_addr[2]);\r\ninfo->dest_ip[3] = cpu_to_le32(cminfo->loc_addr[3]);\r\nif (etype == I40IW_QHASH_TYPE_TCP_ESTABLISHED) {\r\ninfo->src_port = cpu_to_le16(cminfo->rem_port);\r\ninfo->src_ip[0] = cpu_to_le32(cminfo->rem_addr[0]);\r\ninfo->src_ip[1] = cpu_to_le32(cminfo->rem_addr[1]);\r\ninfo->src_ip[2] = cpu_to_le32(cminfo->rem_addr[2]);\r\ninfo->src_ip[3] = cpu_to_le32(cminfo->rem_addr[3]);\r\n}\r\nif (cmnode) {\r\ncqp_request->callback_fcn = i40iw_send_syn_cqp_callback;\r\ncqp_request->param = (void *)cmnode;\r\n}\r\nif (info->ipv4_valid)\r\ni40iw_debug(dev, I40IW_DEBUG_CM,\r\n"%s:%s IP=%pI4, port=%d, mac=%pM, vlan_id=%d\n",\r\n__func__, (!mtype) ? "DELETE" : "ADD",\r\ninfo->dest_ip,\r\ninfo->dest_port, info->mac_addr, cminfo->vlan_id);\r\nelse\r\ni40iw_debug(dev, I40IW_DEBUG_CM,\r\n"%s:%s IP=%pI6, port=%d, mac=%pM, vlan_id=%d\n",\r\n__func__, (!mtype) ? "DELETE" : "ADD",\r\ninfo->dest_ip,\r\ninfo->dest_port, info->mac_addr, cminfo->vlan_id);\r\ncqp_info->in.u.manage_qhash_table_entry.cqp = &iwdev->cqp.sc_cqp;\r\ncqp_info->in.u.manage_qhash_table_entry.scratch = (uintptr_t)cqp_request;\r\ncqp_info->cqp_cmd = OP_MANAGE_QHASH_TABLE_ENTRY;\r\ncqp_info->post_sq = 1;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Manage Qhash Entry fail");\r\nreturn status;\r\n}\r\nenum i40iw_status_code i40iw_hw_flush_wqes(struct i40iw_device *iwdev,\r\nstruct i40iw_sc_qp *qp,\r\nstruct i40iw_qp_flush_info *info,\r\nbool wait)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_qp_flush_info *hw_info;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, wait);\r\nif (!cqp_request)\r\nreturn I40IW_ERR_NO_MEMORY;\r\ncqp_info = &cqp_request->info;\r\nhw_info = &cqp_request->info.in.u.qp_flush_wqes.info;\r\nmemcpy(hw_info, info, sizeof(*hw_info));\r\ncqp_info->cqp_cmd = OP_QP_FLUSH_WQES;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.qp_flush_wqes.qp = qp;\r\ncqp_info->in.u.qp_flush_wqes.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Flush WQE's fail");\r\nreturn status;\r\n}\r\nenum i40iw_status_code i40iw_hw_manage_vf_pble_bp(struct i40iw_device *iwdev,\r\nstruct i40iw_manage_vf_pble_info *info,\r\nbool wait)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_manage_vf_pble_info *hw_info;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nif ((iwdev->init_state < CCQ_CREATED) && wait)\r\nwait = false;\r\ncqp_request = i40iw_get_cqp_request(&iwdev->cqp, wait);\r\nif (!cqp_request)\r\nreturn I40IW_ERR_NO_MEMORY;\r\ncqp_info = &cqp_request->info;\r\nhw_info = &cqp_request->info.in.u.manage_vf_pble_bp.info;\r\nmemcpy(hw_info, info, sizeof(*hw_info));\r\ncqp_info->cqp_cmd = OP_MANAGE_VF_PBLE_BP;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.manage_vf_pble_bp.cqp = &iwdev->cqp.sc_cqp;\r\ncqp_info->in.u.manage_vf_pble_bp.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Manage VF pble_bp fail");\r\nreturn status;\r\n}\r\nstatic enum ib_wc_status i40iw_get_ib_wc(enum i40iw_flush_opcode opcode)\r\n{\r\nswitch (opcode) {\r\ncase FLUSH_PROT_ERR:\r\nreturn IB_WC_LOC_PROT_ERR;\r\ncase FLUSH_REM_ACCESS_ERR:\r\nreturn IB_WC_REM_ACCESS_ERR;\r\ncase FLUSH_LOC_QP_OP_ERR:\r\nreturn IB_WC_LOC_QP_OP_ERR;\r\ncase FLUSH_REM_OP_ERR:\r\nreturn IB_WC_REM_OP_ERR;\r\ncase FLUSH_LOC_LEN_ERR:\r\nreturn IB_WC_LOC_LEN_ERR;\r\ncase FLUSH_GENERAL_ERR:\r\nreturn IB_WC_GENERAL_ERR;\r\ncase FLUSH_FATAL_ERR:\r\ndefault:\r\nreturn IB_WC_FATAL_ERR;\r\n}\r\n}\r\nstatic void i40iw_set_flush_info(struct i40iw_qp_flush_info *pinfo,\r\nu16 *min,\r\nu16 *maj,\r\nenum i40iw_flush_opcode opcode)\r\n{\r\n*min = (u16)i40iw_get_ib_wc(opcode);\r\n*maj = CQE_MAJOR_DRV;\r\npinfo->userflushcode = true;\r\n}\r\nvoid i40iw_flush_wqes(struct i40iw_device *iwdev, struct i40iw_qp *iwqp)\r\n{\r\nstruct i40iw_qp_flush_info info;\r\nstruct i40iw_qp_flush_info *pinfo = &info;\r\nstruct i40iw_sc_qp *qp = &iwqp->sc_qp;\r\nmemset(pinfo, 0, sizeof(*pinfo));\r\ninfo.sq = true;\r\ninfo.rq = true;\r\nif (qp->term_flags) {\r\ni40iw_set_flush_info(pinfo, &pinfo->sq_minor_code,\r\n&pinfo->sq_major_code, qp->flush_code);\r\ni40iw_set_flush_info(pinfo, &pinfo->rq_minor_code,\r\n&pinfo->rq_major_code, qp->flush_code);\r\n}\r\n(void)i40iw_hw_flush_wqes(iwdev, &iwqp->sc_qp, &info, true);\r\n}
