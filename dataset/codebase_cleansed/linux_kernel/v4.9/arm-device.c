static int xen_unmap_device_mmio(const struct resource *resources,\r\nunsigned int count)\r\n{\r\nunsigned int i, j, nr;\r\nint rc = 0;\r\nconst struct resource *r;\r\nstruct xen_remove_from_physmap xrp;\r\nfor (i = 0; i < count; i++) {\r\nr = &resources[i];\r\nnr = DIV_ROUND_UP(resource_size(r), XEN_PAGE_SIZE);\r\nif ((resource_type(r) != IORESOURCE_MEM) || (nr == 0))\r\ncontinue;\r\nfor (j = 0; j < nr; j++) {\r\nxrp.domid = DOMID_SELF;\r\nxrp.gpfn = XEN_PFN_DOWN(r->start) + j;\r\nrc = HYPERVISOR_memory_op(XENMEM_remove_from_physmap,\r\n&xrp);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int xen_map_device_mmio(const struct resource *resources,\r\nunsigned int count)\r\n{\r\nunsigned int i, j, nr;\r\nint rc = 0;\r\nconst struct resource *r;\r\nxen_pfn_t *gpfns;\r\nxen_ulong_t *idxs;\r\nint *errs;\r\nstruct xen_add_to_physmap_range xatp;\r\nfor (i = 0; i < count; i++) {\r\nr = &resources[i];\r\nnr = DIV_ROUND_UP(resource_size(r), XEN_PAGE_SIZE);\r\nif ((resource_type(r) != IORESOURCE_MEM) || (nr == 0))\r\ncontinue;\r\ngpfns = kzalloc(sizeof(xen_pfn_t) * nr, GFP_KERNEL);\r\nidxs = kzalloc(sizeof(xen_ulong_t) * nr, GFP_KERNEL);\r\nerrs = kzalloc(sizeof(int) * nr, GFP_KERNEL);\r\nif (!gpfns || !idxs || !errs) {\r\nkfree(gpfns);\r\nkfree(idxs);\r\nkfree(errs);\r\nrc = -ENOMEM;\r\ngoto unmap;\r\n}\r\nfor (j = 0; j < nr; j++) {\r\ngpfns[j] = XEN_PFN_DOWN(r->start) + j;\r\nidxs[j] = XEN_PFN_DOWN(r->start) + j;\r\n}\r\nxatp.domid = DOMID_SELF;\r\nxatp.size = nr;\r\nxatp.space = XENMAPSPACE_dev_mmio;\r\nset_xen_guest_handle(xatp.gpfns, gpfns);\r\nset_xen_guest_handle(xatp.idxs, idxs);\r\nset_xen_guest_handle(xatp.errs, errs);\r\nrc = HYPERVISOR_memory_op(XENMEM_add_to_physmap_range, &xatp);\r\nkfree(gpfns);\r\nkfree(idxs);\r\nkfree(errs);\r\nif (rc)\r\ngoto unmap;\r\n}\r\nreturn rc;\r\nunmap:\r\nxen_unmap_device_mmio(resources, i);\r\nreturn rc;\r\n}\r\nstatic int xen_platform_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(data);\r\nint r = 0;\r\nif (pdev->num_resources == 0 || pdev->resource == NULL)\r\nreturn NOTIFY_OK;\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nr = xen_map_device_mmio(pdev->resource, pdev->num_resources);\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nr = xen_unmap_device_mmio(pdev->resource, pdev->num_resources);\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\nif (r)\r\ndev_err(&pdev->dev, "Platform: Failed to %s device %s MMIO!\n",\r\naction == BUS_NOTIFY_ADD_DEVICE ? "map" :\r\n(action == BUS_NOTIFY_DEL_DEVICE ? "unmap" : "?"),\r\npdev->name);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init register_xen_platform_notifier(void)\r\n{\r\nif (!xen_initial_domain() || acpi_disabled)\r\nreturn 0;\r\nreturn bus_register_notifier(&platform_bus_type, &platform_device_nb);\r\n}\r\nstatic int xen_amba_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct amba_device *adev = to_amba_device(data);\r\nint r = 0;\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nr = xen_map_device_mmio(&adev->res, 1);\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nr = xen_unmap_device_mmio(&adev->res, 1);\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\nif (r)\r\ndev_err(&adev->dev, "AMBA: Failed to %s device %s MMIO!\n",\r\naction == BUS_NOTIFY_ADD_DEVICE ? "map" :\r\n(action == BUS_NOTIFY_DEL_DEVICE ? "unmap" : "?"),\r\nadev->dev.init_name);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init register_xen_amba_notifier(void)\r\n{\r\nif (!xen_initial_domain() || acpi_disabled)\r\nreturn 0;\r\nreturn bus_register_notifier(&amba_bustype, &amba_device_nb);\r\n}
