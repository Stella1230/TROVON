static inline struct arp_pkt *arp_pkt(const struct sk_buff *skb)\r\n{\r\nreturn (struct arp_pkt *)skb_network_header(skb);\r\n}\r\nstatic inline u8 _simple_hash(const u8 *hash_start, int hash_size)\r\n{\r\nint i;\r\nu8 hash = 0;\r\nfor (i = 0; i < hash_size; i++)\r\nhash ^= hash_start[i];\r\nreturn hash;\r\n}\r\nstatic inline void tlb_init_table_entry(struct tlb_client_info *entry, int save_load)\r\n{\r\nif (save_load) {\r\nentry->load_history = 1 + entry->tx_bytes /\r\nBOND_TLB_REBALANCE_INTERVAL;\r\nentry->tx_bytes = 0;\r\n}\r\nentry->tx_slave = NULL;\r\nentry->next = TLB_NULL_INDEX;\r\nentry->prev = TLB_NULL_INDEX;\r\n}\r\nstatic inline void tlb_init_slave(struct slave *slave)\r\n{\r\nSLAVE_TLB_INFO(slave).load = 0;\r\nSLAVE_TLB_INFO(slave).head = TLB_NULL_INDEX;\r\n}\r\nstatic void __tlb_clear_slave(struct bonding *bond, struct slave *slave,\r\nint save_load)\r\n{\r\nstruct tlb_client_info *tx_hash_table;\r\nu32 index;\r\ntx_hash_table = BOND_ALB_INFO(bond).tx_hashtbl;\r\nif (tx_hash_table) {\r\nindex = SLAVE_TLB_INFO(slave).head;\r\nwhile (index != TLB_NULL_INDEX) {\r\nu32 next_index = tx_hash_table[index].next;\r\ntlb_init_table_entry(&tx_hash_table[index], save_load);\r\nindex = next_index;\r\n}\r\n}\r\ntlb_init_slave(slave);\r\n}\r\nstatic void tlb_clear_slave(struct bonding *bond, struct slave *slave,\r\nint save_load)\r\n{\r\nspin_lock_bh(&bond->mode_lock);\r\n__tlb_clear_slave(bond, slave, save_load);\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic int tlb_initialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nint size = TLB_HASH_TABLE_SIZE * sizeof(struct tlb_client_info);\r\nstruct tlb_client_info *new_hashtbl;\r\nint i;\r\nnew_hashtbl = kzalloc(size, GFP_KERNEL);\r\nif (!new_hashtbl)\r\nreturn -ENOMEM;\r\nspin_lock_bh(&bond->mode_lock);\r\nbond_info->tx_hashtbl = new_hashtbl;\r\nfor (i = 0; i < TLB_HASH_TABLE_SIZE; i++)\r\ntlb_init_table_entry(&bond_info->tx_hashtbl[i], 0);\r\nspin_unlock_bh(&bond->mode_lock);\r\nreturn 0;\r\n}\r\nstatic void tlb_deinitialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nspin_lock_bh(&bond->mode_lock);\r\nkfree(bond_info->tx_hashtbl);\r\nbond_info->tx_hashtbl = NULL;\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic long long compute_gap(struct slave *slave)\r\n{\r\nreturn (s64) (slave->speed << 20) -\r\n(s64) (SLAVE_TLB_INFO(slave).load << 3);\r\n}\r\nstatic struct slave *tlb_get_least_loaded_slave(struct bonding *bond)\r\n{\r\nstruct slave *slave, *least_loaded;\r\nstruct list_head *iter;\r\nlong long max_gap;\r\nleast_loaded = NULL;\r\nmax_gap = LLONG_MIN;\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nif (bond_slave_can_tx(slave)) {\r\nlong long gap = compute_gap(slave);\r\nif (max_gap < gap) {\r\nleast_loaded = slave;\r\nmax_gap = gap;\r\n}\r\n}\r\n}\r\nreturn least_loaded;\r\n}\r\nstatic struct slave *__tlb_choose_channel(struct bonding *bond, u32 hash_index,\r\nu32 skb_len)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct tlb_client_info *hash_table;\r\nstruct slave *assigned_slave;\r\nhash_table = bond_info->tx_hashtbl;\r\nassigned_slave = hash_table[hash_index].tx_slave;\r\nif (!assigned_slave) {\r\nassigned_slave = tlb_get_least_loaded_slave(bond);\r\nif (assigned_slave) {\r\nstruct tlb_slave_info *slave_info =\r\n&(SLAVE_TLB_INFO(assigned_slave));\r\nu32 next_index = slave_info->head;\r\nhash_table[hash_index].tx_slave = assigned_slave;\r\nhash_table[hash_index].next = next_index;\r\nhash_table[hash_index].prev = TLB_NULL_INDEX;\r\nif (next_index != TLB_NULL_INDEX)\r\nhash_table[next_index].prev = hash_index;\r\nslave_info->head = hash_index;\r\nslave_info->load +=\r\nhash_table[hash_index].load_history;\r\n}\r\n}\r\nif (assigned_slave)\r\nhash_table[hash_index].tx_bytes += skb_len;\r\nreturn assigned_slave;\r\n}\r\nstatic struct slave *tlb_choose_channel(struct bonding *bond, u32 hash_index,\r\nu32 skb_len)\r\n{\r\nstruct slave *tx_slave;\r\nspin_lock(&bond->mode_lock);\r\ntx_slave = __tlb_choose_channel(bond, hash_index, skb_len);\r\nspin_unlock(&bond->mode_lock);\r\nreturn tx_slave;\r\n}\r\nstatic void rlb_update_entry_from_arp(struct bonding *bond, struct arp_pkt *arp)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *client_info;\r\nu32 hash_index;\r\nspin_lock_bh(&bond->mode_lock);\r\nhash_index = _simple_hash((u8 *)&(arp->ip_src), sizeof(arp->ip_src));\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif ((client_info->assigned) &&\r\n(client_info->ip_src == arp->ip_dst) &&\r\n(client_info->ip_dst == arp->ip_src) &&\r\n(!ether_addr_equal_64bits(client_info->mac_dst, arp->mac_src))) {\r\nether_addr_copy(client_info->mac_dst, arp->mac_src);\r\nclient_info->ntt = 1;\r\nbond_info->rx_ntt = 1;\r\n}\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic int rlb_arp_recv(const struct sk_buff *skb, struct bonding *bond,\r\nstruct slave *slave)\r\n{\r\nstruct arp_pkt *arp, _arp;\r\nif (skb->protocol != cpu_to_be16(ETH_P_ARP))\r\ngoto out;\r\narp = skb_header_pointer(skb, 0, sizeof(_arp), &_arp);\r\nif (!arp)\r\ngoto out;\r\nrlb_purge_src_ip(bond, arp);\r\nif (arp->op_code == htons(ARPOP_REPLY)) {\r\nrlb_update_entry_from_arp(bond, arp);\r\nnetdev_dbg(bond->dev, "Server received an ARP Reply from client\n");\r\n}\r\nout:\r\nreturn RX_HANDLER_ANOTHER;\r\n}\r\nstatic struct slave *__rlb_next_rx_slave(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct slave *before = NULL, *rx_slave = NULL, *slave;\r\nstruct list_head *iter;\r\nbool found = false;\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nif (!bond_slave_can_tx(slave))\r\ncontinue;\r\nif (!found) {\r\nif (!before || before->speed < slave->speed)\r\nbefore = slave;\r\n} else {\r\nif (!rx_slave || rx_slave->speed < slave->speed)\r\nrx_slave = slave;\r\n}\r\nif (slave == bond_info->rx_slave)\r\nfound = true;\r\n}\r\nif (!rx_slave || (before && rx_slave->speed < before->speed))\r\nrx_slave = before;\r\nif (rx_slave)\r\nbond_info->rx_slave = rx_slave;\r\nreturn rx_slave;\r\n}\r\nstatic struct slave *rlb_next_rx_slave(struct bonding *bond)\r\n{\r\nstruct slave *rx_slave;\r\nASSERT_RTNL();\r\nrcu_read_lock();\r\nrx_slave = __rlb_next_rx_slave(bond);\r\nrcu_read_unlock();\r\nreturn rx_slave;\r\n}\r\nstatic void rlb_teach_disabled_mac_on_primary(struct bonding *bond, u8 addr[])\r\n{\r\nstruct slave *curr_active = rtnl_dereference(bond->curr_active_slave);\r\nif (!curr_active)\r\nreturn;\r\nif (!bond->alb_info.primary_is_promisc) {\r\nif (!dev_set_promiscuity(curr_active->dev, 1))\r\nbond->alb_info.primary_is_promisc = 1;\r\nelse\r\nbond->alb_info.primary_is_promisc = 0;\r\n}\r\nbond->alb_info.rlb_promisc_timeout_counter = 0;\r\nalb_send_learning_packets(curr_active, addr, true);\r\n}\r\nstatic void rlb_clear_slave(struct bonding *bond, struct slave *slave)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *rx_hash_table;\r\nu32 index, next_index;\r\nspin_lock_bh(&bond->mode_lock);\r\nrx_hash_table = bond_info->rx_hashtbl;\r\nindex = bond_info->rx_hashtbl_used_head;\r\nfor (; index != RLB_NULL_INDEX; index = next_index) {\r\nnext_index = rx_hash_table[index].used_next;\r\nif (rx_hash_table[index].slave == slave) {\r\nstruct slave *assigned_slave = rlb_next_rx_slave(bond);\r\nif (assigned_slave) {\r\nrx_hash_table[index].slave = assigned_slave;\r\nif (!ether_addr_equal_64bits(rx_hash_table[index].mac_dst,\r\nmac_bcast)) {\r\nbond_info->rx_hashtbl[index].ntt = 1;\r\nbond_info->rx_ntt = 1;\r\nbond_info->rlb_update_retry_counter =\r\nRLB_UPDATE_RETRY;\r\n}\r\n} else {\r\nrx_hash_table[index].slave = NULL;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&bond->mode_lock);\r\nif (slave != rtnl_dereference(bond->curr_active_slave))\r\nrlb_teach_disabled_mac_on_primary(bond, slave->dev->dev_addr);\r\n}\r\nstatic void rlb_update_client(struct rlb_client_info *client_info)\r\n{\r\nint i;\r\nif (!client_info->slave)\r\nreturn;\r\nfor (i = 0; i < RLB_ARP_BURST_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nskb = arp_create(ARPOP_REPLY, ETH_P_ARP,\r\nclient_info->ip_dst,\r\nclient_info->slave->dev,\r\nclient_info->ip_src,\r\nclient_info->mac_dst,\r\nclient_info->slave->dev->dev_addr,\r\nclient_info->mac_dst);\r\nif (!skb) {\r\nnetdev_err(client_info->slave->bond->dev,\r\n"failed to create an ARP packet\n");\r\ncontinue;\r\n}\r\nskb->dev = client_info->slave->dev;\r\nif (client_info->vlan_id) {\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\r\nclient_info->vlan_id);\r\n}\r\narp_xmit(skb);\r\n}\r\n}\r\nstatic void rlb_update_rx_clients(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *client_info;\r\nu32 hash_index;\r\nspin_lock_bh(&bond->mode_lock);\r\nhash_index = bond_info->rx_hashtbl_used_head;\r\nfor (; hash_index != RLB_NULL_INDEX;\r\nhash_index = client_info->used_next) {\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif (client_info->ntt) {\r\nrlb_update_client(client_info);\r\nif (bond_info->rlb_update_retry_counter == 0)\r\nclient_info->ntt = 0;\r\n}\r\n}\r\nbond_info->rlb_update_delay_counter = RLB_UPDATE_DELAY;\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic void rlb_req_update_slave_clients(struct bonding *bond, struct slave *slave)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *client_info;\r\nint ntt = 0;\r\nu32 hash_index;\r\nspin_lock_bh(&bond->mode_lock);\r\nhash_index = bond_info->rx_hashtbl_used_head;\r\nfor (; hash_index != RLB_NULL_INDEX;\r\nhash_index = client_info->used_next) {\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif ((client_info->slave == slave) &&\r\n!ether_addr_equal_64bits(client_info->mac_dst, mac_bcast)) {\r\nclient_info->ntt = 1;\r\nntt = 1;\r\n}\r\n}\r\nif (ntt) {\r\nbond_info->rx_ntt = 1;\r\nbond_info->rlb_update_retry_counter = RLB_UPDATE_RETRY;\r\n}\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic void rlb_req_update_subnet_clients(struct bonding *bond, __be32 src_ip)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *client_info;\r\nu32 hash_index;\r\nspin_lock(&bond->mode_lock);\r\nhash_index = bond_info->rx_hashtbl_used_head;\r\nfor (; hash_index != RLB_NULL_INDEX;\r\nhash_index = client_info->used_next) {\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif (!client_info->slave) {\r\nnetdev_err(bond->dev, "found a client with no channel in the client's hash table\n");\r\ncontinue;\r\n}\r\nif ((client_info->ip_src == src_ip) &&\r\n!ether_addr_equal_64bits(client_info->slave->dev->dev_addr,\r\nbond->dev->dev_addr) &&\r\n!ether_addr_equal_64bits(client_info->mac_dst, mac_bcast)) {\r\nclient_info->ntt = 1;\r\nbond_info->rx_ntt = 1;\r\n}\r\n}\r\nspin_unlock(&bond->mode_lock);\r\n}\r\nstatic struct slave *rlb_choose_channel(struct sk_buff *skb, struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct arp_pkt *arp = arp_pkt(skb);\r\nstruct slave *assigned_slave, *curr_active_slave;\r\nstruct rlb_client_info *client_info;\r\nu32 hash_index = 0;\r\nspin_lock(&bond->mode_lock);\r\ncurr_active_slave = rcu_dereference(bond->curr_active_slave);\r\nhash_index = _simple_hash((u8 *)&arp->ip_dst, sizeof(arp->ip_dst));\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif (client_info->assigned) {\r\nif ((client_info->ip_src == arp->ip_src) &&\r\n(client_info->ip_dst == arp->ip_dst)) {\r\nif (!ether_addr_equal_64bits(arp->mac_dst, mac_bcast)) {\r\nether_addr_copy(client_info->mac_dst, arp->mac_dst);\r\n}\r\nether_addr_copy(client_info->mac_src, arp->mac_src);\r\nassigned_slave = client_info->slave;\r\nif (assigned_slave) {\r\nspin_unlock(&bond->mode_lock);\r\nreturn assigned_slave;\r\n}\r\n} else {\r\nif (curr_active_slave &&\r\nclient_info->slave != curr_active_slave) {\r\nclient_info->slave = curr_active_slave;\r\nrlb_update_client(client_info);\r\n}\r\n}\r\n}\r\nassigned_slave = __rlb_next_rx_slave(bond);\r\nif (assigned_slave) {\r\nif (!(client_info->assigned &&\r\nclient_info->ip_src == arp->ip_src)) {\r\nu32 hash_src = _simple_hash((u8 *)&arp->ip_src,\r\nsizeof(arp->ip_src));\r\nrlb_src_unlink(bond, hash_index);\r\nrlb_src_link(bond, hash_src, hash_index);\r\n}\r\nclient_info->ip_src = arp->ip_src;\r\nclient_info->ip_dst = arp->ip_dst;\r\nether_addr_copy(client_info->mac_dst, arp->mac_dst);\r\nether_addr_copy(client_info->mac_src, arp->mac_src);\r\nclient_info->slave = assigned_slave;\r\nif (!ether_addr_equal_64bits(client_info->mac_dst, mac_bcast)) {\r\nclient_info->ntt = 1;\r\nbond->alb_info.rx_ntt = 1;\r\n} else {\r\nclient_info->ntt = 0;\r\n}\r\nif (vlan_get_tag(skb, &client_info->vlan_id))\r\nclient_info->vlan_id = 0;\r\nif (!client_info->assigned) {\r\nu32 prev_tbl_head = bond_info->rx_hashtbl_used_head;\r\nbond_info->rx_hashtbl_used_head = hash_index;\r\nclient_info->used_next = prev_tbl_head;\r\nif (prev_tbl_head != RLB_NULL_INDEX) {\r\nbond_info->rx_hashtbl[prev_tbl_head].used_prev =\r\nhash_index;\r\n}\r\nclient_info->assigned = 1;\r\n}\r\n}\r\nspin_unlock(&bond->mode_lock);\r\nreturn assigned_slave;\r\n}\r\nstatic struct slave *rlb_arp_xmit(struct sk_buff *skb, struct bonding *bond)\r\n{\r\nstruct arp_pkt *arp = arp_pkt(skb);\r\nstruct slave *tx_slave = NULL;\r\nif (!bond_slave_has_mac_rx(bond, arp->mac_src))\r\nreturn NULL;\r\nif (arp->op_code == htons(ARPOP_REPLY)) {\r\ntx_slave = rlb_choose_channel(skb, bond);\r\nif (tx_slave)\r\nether_addr_copy(arp->mac_src, tx_slave->dev->dev_addr);\r\nnetdev_dbg(bond->dev, "Server sent ARP Reply packet\n");\r\n} else if (arp->op_code == htons(ARPOP_REQUEST)) {\r\nrlb_choose_channel(skb, bond);\r\nbond->alb_info.rlb_update_delay_counter = RLB_UPDATE_DELAY;\r\nrlb_req_update_subnet_clients(bond, arp->ip_src);\r\nnetdev_dbg(bond->dev, "Server sent ARP Request packet\n");\r\n}\r\nreturn tx_slave;\r\n}\r\nstatic void rlb_rebalance(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct slave *assigned_slave;\r\nstruct rlb_client_info *client_info;\r\nint ntt;\r\nu32 hash_index;\r\nspin_lock_bh(&bond->mode_lock);\r\nntt = 0;\r\nhash_index = bond_info->rx_hashtbl_used_head;\r\nfor (; hash_index != RLB_NULL_INDEX;\r\nhash_index = client_info->used_next) {\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nassigned_slave = __rlb_next_rx_slave(bond);\r\nif (assigned_slave && (client_info->slave != assigned_slave)) {\r\nclient_info->slave = assigned_slave;\r\nclient_info->ntt = 1;\r\nntt = 1;\r\n}\r\n}\r\nif (ntt)\r\nbond_info->rx_ntt = 1;\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic void rlb_init_table_entry_dst(struct rlb_client_info *entry)\r\n{\r\nentry->used_next = RLB_NULL_INDEX;\r\nentry->used_prev = RLB_NULL_INDEX;\r\nentry->assigned = 0;\r\nentry->slave = NULL;\r\nentry->vlan_id = 0;\r\n}\r\nstatic void rlb_init_table_entry_src(struct rlb_client_info *entry)\r\n{\r\nentry->src_first = RLB_NULL_INDEX;\r\nentry->src_prev = RLB_NULL_INDEX;\r\nentry->src_next = RLB_NULL_INDEX;\r\n}\r\nstatic void rlb_init_table_entry(struct rlb_client_info *entry)\r\n{\r\nmemset(entry, 0, sizeof(struct rlb_client_info));\r\nrlb_init_table_entry_dst(entry);\r\nrlb_init_table_entry_src(entry);\r\n}\r\nstatic void rlb_delete_table_entry_dst(struct bonding *bond, u32 index)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nu32 next_index = bond_info->rx_hashtbl[index].used_next;\r\nu32 prev_index = bond_info->rx_hashtbl[index].used_prev;\r\nif (index == bond_info->rx_hashtbl_used_head)\r\nbond_info->rx_hashtbl_used_head = next_index;\r\nif (prev_index != RLB_NULL_INDEX)\r\nbond_info->rx_hashtbl[prev_index].used_next = next_index;\r\nif (next_index != RLB_NULL_INDEX)\r\nbond_info->rx_hashtbl[next_index].used_prev = prev_index;\r\n}\r\nstatic void rlb_src_unlink(struct bonding *bond, u32 index)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nu32 next_index = bond_info->rx_hashtbl[index].src_next;\r\nu32 prev_index = bond_info->rx_hashtbl[index].src_prev;\r\nbond_info->rx_hashtbl[index].src_next = RLB_NULL_INDEX;\r\nbond_info->rx_hashtbl[index].src_prev = RLB_NULL_INDEX;\r\nif (next_index != RLB_NULL_INDEX)\r\nbond_info->rx_hashtbl[next_index].src_prev = prev_index;\r\nif (prev_index == RLB_NULL_INDEX)\r\nreturn;\r\nif (bond_info->rx_hashtbl[prev_index].src_first == index)\r\nbond_info->rx_hashtbl[prev_index].src_first = next_index;\r\nelse\r\nbond_info->rx_hashtbl[prev_index].src_next = next_index;\r\n}\r\nstatic void rlb_delete_table_entry(struct bonding *bond, u32 index)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *entry = &(bond_info->rx_hashtbl[index]);\r\nrlb_delete_table_entry_dst(bond, index);\r\nrlb_init_table_entry_dst(entry);\r\nrlb_src_unlink(bond, index);\r\n}\r\nstatic void rlb_src_link(struct bonding *bond, u32 ip_src_hash, u32 ip_dst_hash)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nu32 next;\r\nbond_info->rx_hashtbl[ip_dst_hash].src_prev = ip_src_hash;\r\nnext = bond_info->rx_hashtbl[ip_src_hash].src_first;\r\nbond_info->rx_hashtbl[ip_dst_hash].src_next = next;\r\nif (next != RLB_NULL_INDEX)\r\nbond_info->rx_hashtbl[next].src_prev = ip_dst_hash;\r\nbond_info->rx_hashtbl[ip_src_hash].src_first = ip_dst_hash;\r\n}\r\nstatic void rlb_purge_src_ip(struct bonding *bond, struct arp_pkt *arp)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nu32 ip_src_hash = _simple_hash((u8 *)&(arp->ip_src), sizeof(arp->ip_src));\r\nu32 index;\r\nspin_lock_bh(&bond->mode_lock);\r\nindex = bond_info->rx_hashtbl[ip_src_hash].src_first;\r\nwhile (index != RLB_NULL_INDEX) {\r\nstruct rlb_client_info *entry = &(bond_info->rx_hashtbl[index]);\r\nu32 next_index = entry->src_next;\r\nif (entry->ip_src == arp->ip_src &&\r\n!ether_addr_equal_64bits(arp->mac_src, entry->mac_src))\r\nrlb_delete_table_entry(bond, index);\r\nindex = next_index;\r\n}\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic int rlb_initialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *new_hashtbl;\r\nint size = RLB_HASH_TABLE_SIZE * sizeof(struct rlb_client_info);\r\nint i;\r\nnew_hashtbl = kmalloc(size, GFP_KERNEL);\r\nif (!new_hashtbl)\r\nreturn -1;\r\nspin_lock_bh(&bond->mode_lock);\r\nbond_info->rx_hashtbl = new_hashtbl;\r\nbond_info->rx_hashtbl_used_head = RLB_NULL_INDEX;\r\nfor (i = 0; i < RLB_HASH_TABLE_SIZE; i++)\r\nrlb_init_table_entry(bond_info->rx_hashtbl + i);\r\nspin_unlock_bh(&bond->mode_lock);\r\nbond->recv_probe = rlb_arp_recv;\r\nreturn 0;\r\n}\r\nstatic void rlb_deinitialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nspin_lock_bh(&bond->mode_lock);\r\nkfree(bond_info->rx_hashtbl);\r\nbond_info->rx_hashtbl = NULL;\r\nbond_info->rx_hashtbl_used_head = RLB_NULL_INDEX;\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic void rlb_clear_vlan(struct bonding *bond, unsigned short vlan_id)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nu32 curr_index;\r\nspin_lock_bh(&bond->mode_lock);\r\ncurr_index = bond_info->rx_hashtbl_used_head;\r\nwhile (curr_index != RLB_NULL_INDEX) {\r\nstruct rlb_client_info *curr = &(bond_info->rx_hashtbl[curr_index]);\r\nu32 next_index = bond_info->rx_hashtbl[curr_index].used_next;\r\nif (curr->vlan_id == vlan_id)\r\nrlb_delete_table_entry(bond, curr_index);\r\ncurr_index = next_index;\r\n}\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nstatic void alb_send_lp_vid(struct slave *slave, u8 mac_addr[],\r\n__be16 vlan_proto, u16 vid)\r\n{\r\nstruct learning_pkt pkt;\r\nstruct sk_buff *skb;\r\nint size = sizeof(struct learning_pkt);\r\nchar *data;\r\nmemset(&pkt, 0, size);\r\nether_addr_copy(pkt.mac_dst, mac_addr);\r\nether_addr_copy(pkt.mac_src, mac_addr);\r\npkt.type = cpu_to_be16(ETH_P_LOOPBACK);\r\nskb = dev_alloc_skb(size);\r\nif (!skb)\r\nreturn;\r\ndata = skb_put(skb, size);\r\nmemcpy(data, &pkt, size);\r\nskb_reset_mac_header(skb);\r\nskb->network_header = skb->mac_header + ETH_HLEN;\r\nskb->protocol = pkt.type;\r\nskb->priority = TC_PRIO_CONTROL;\r\nskb->dev = slave->dev;\r\nif (vid)\r\n__vlan_hwaccel_put_tag(skb, vlan_proto, vid);\r\ndev_queue_xmit(skb);\r\n}\r\nstatic void alb_send_learning_packets(struct slave *slave, u8 mac_addr[],\r\nbool strict_match)\r\n{\r\nstruct bonding *bond = bond_get_bond_by_slave(slave);\r\nstruct net_device *upper;\r\nstruct list_head *iter;\r\nstruct bond_vlan_tag *tags;\r\nalb_send_lp_vid(slave, mac_addr, 0, 0);\r\nrcu_read_lock();\r\nnetdev_for_each_all_upper_dev_rcu(bond->dev, upper, iter) {\r\nif (is_vlan_dev(upper) && vlan_get_encap_level(upper) == 0) {\r\nif (strict_match &&\r\nether_addr_equal_64bits(mac_addr,\r\nupper->dev_addr)) {\r\nalb_send_lp_vid(slave, mac_addr,\r\nvlan_dev_vlan_proto(upper),\r\nvlan_dev_vlan_id(upper));\r\n} else if (!strict_match) {\r\nalb_send_lp_vid(slave, upper->dev_addr,\r\nvlan_dev_vlan_proto(upper),\r\nvlan_dev_vlan_id(upper));\r\n}\r\n}\r\nif (netif_is_macvlan(upper) && !strict_match) {\r\ntags = bond_verify_device_path(bond->dev, upper, 0);\r\nif (IS_ERR_OR_NULL(tags))\r\nBUG();\r\nalb_send_lp_vid(slave, upper->dev_addr,\r\ntags[0].vlan_proto, tags[0].vlan_id);\r\nkfree(tags);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int alb_set_slave_mac_addr(struct slave *slave, u8 addr[])\r\n{\r\nstruct net_device *dev = slave->dev;\r\nstruct sockaddr s_addr;\r\nif (BOND_MODE(slave->bond) == BOND_MODE_TLB) {\r\nmemcpy(dev->dev_addr, addr, dev->addr_len);\r\nreturn 0;\r\n}\r\nmemcpy(s_addr.sa_data, addr, dev->addr_len);\r\ns_addr.sa_family = dev->type;\r\nif (dev_set_mac_address(dev, &s_addr)) {\r\nnetdev_err(slave->bond->dev, "dev_set_mac_address of dev %s failed! ALB mode requires that the base driver support setting the hw address also when the network device's interface is open\n",\r\ndev->name);\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void alb_swap_mac_addr(struct slave *slave1, struct slave *slave2)\r\n{\r\nu8 tmp_mac_addr[ETH_ALEN];\r\nether_addr_copy(tmp_mac_addr, slave1->dev->dev_addr);\r\nalb_set_slave_mac_addr(slave1, slave2->dev->dev_addr);\r\nalb_set_slave_mac_addr(slave2, tmp_mac_addr);\r\n}\r\nstatic void alb_fasten_mac_swap(struct bonding *bond, struct slave *slave1,\r\nstruct slave *slave2)\r\n{\r\nint slaves_state_differ = (bond_slave_can_tx(slave1) != bond_slave_can_tx(slave2));\r\nstruct slave *disabled_slave = NULL;\r\nASSERT_RTNL();\r\nif (bond_slave_can_tx(slave1)) {\r\nalb_send_learning_packets(slave1, slave1->dev->dev_addr, false);\r\nif (bond->alb_info.rlb_enabled) {\r\nrlb_req_update_slave_clients(bond, slave1);\r\n}\r\n} else {\r\ndisabled_slave = slave1;\r\n}\r\nif (bond_slave_can_tx(slave2)) {\r\nalb_send_learning_packets(slave2, slave2->dev->dev_addr, false);\r\nif (bond->alb_info.rlb_enabled) {\r\nrlb_req_update_slave_clients(bond, slave2);\r\n}\r\n} else {\r\ndisabled_slave = slave2;\r\n}\r\nif (bond->alb_info.rlb_enabled && slaves_state_differ) {\r\nrlb_teach_disabled_mac_on_primary(bond,\r\ndisabled_slave->dev->dev_addr);\r\n}\r\n}\r\nstatic void alb_change_hw_addr_on_detach(struct bonding *bond, struct slave *slave)\r\n{\r\nint perm_curr_diff;\r\nint perm_bond_diff;\r\nstruct slave *found_slave;\r\nperm_curr_diff = !ether_addr_equal_64bits(slave->perm_hwaddr,\r\nslave->dev->dev_addr);\r\nperm_bond_diff = !ether_addr_equal_64bits(slave->perm_hwaddr,\r\nbond->dev->dev_addr);\r\nif (perm_curr_diff && perm_bond_diff) {\r\nfound_slave = bond_slave_has_mac(bond, slave->perm_hwaddr);\r\nif (found_slave) {\r\nalb_swap_mac_addr(slave, found_slave);\r\nalb_fasten_mac_swap(bond, slave, found_slave);\r\n}\r\n}\r\n}\r\nstatic int alb_handle_addr_collision_on_attach(struct bonding *bond, struct slave *slave)\r\n{\r\nstruct slave *has_bond_addr = rcu_access_pointer(bond->curr_active_slave);\r\nstruct slave *tmp_slave1, *free_mac_slave = NULL;\r\nstruct list_head *iter;\r\nif (!bond_has_slaves(bond)) {\r\nreturn 0;\r\n}\r\nif (!ether_addr_equal_64bits(slave->perm_hwaddr, bond->dev->dev_addr)) {\r\nif (!bond_slave_has_mac(bond, slave->dev->dev_addr))\r\nreturn 0;\r\nalb_set_slave_mac_addr(slave, bond->dev->dev_addr);\r\n}\r\nbond_for_each_slave(bond, tmp_slave1, iter) {\r\nif (!bond_slave_has_mac(bond, tmp_slave1->perm_hwaddr)) {\r\nfree_mac_slave = tmp_slave1;\r\nbreak;\r\n}\r\nif (!has_bond_addr) {\r\nif (ether_addr_equal_64bits(tmp_slave1->dev->dev_addr,\r\nbond->dev->dev_addr)) {\r\nhas_bond_addr = tmp_slave1;\r\n}\r\n}\r\n}\r\nif (free_mac_slave) {\r\nalb_set_slave_mac_addr(slave, free_mac_slave->perm_hwaddr);\r\nnetdev_warn(bond->dev, "the hw address of slave %s is in use by the bond; giving it the hw address of %s\n",\r\nslave->dev->name, free_mac_slave->dev->name);\r\n} else if (has_bond_addr) {\r\nnetdev_err(bond->dev, "the hw address of slave %s is in use by the bond; couldn't find a slave with a free hw address to give it (this should not have happened)\n",\r\nslave->dev->name);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alb_set_mac_address(struct bonding *bond, void *addr)\r\n{\r\nstruct slave *slave, *rollback_slave;\r\nstruct list_head *iter;\r\nstruct sockaddr sa;\r\nchar tmp_addr[ETH_ALEN];\r\nint res;\r\nif (bond->alb_info.rlb_enabled)\r\nreturn 0;\r\nbond_for_each_slave(bond, slave, iter) {\r\nether_addr_copy(tmp_addr, slave->dev->dev_addr);\r\nres = dev_set_mac_address(slave->dev, addr);\r\nether_addr_copy(slave->dev->dev_addr, tmp_addr);\r\nif (res)\r\ngoto unwind;\r\n}\r\nreturn 0;\r\nunwind:\r\nmemcpy(sa.sa_data, bond->dev->dev_addr, bond->dev->addr_len);\r\nsa.sa_family = bond->dev->type;\r\nbond_for_each_slave(bond, rollback_slave, iter) {\r\nif (rollback_slave == slave)\r\nbreak;\r\nether_addr_copy(tmp_addr, rollback_slave->dev->dev_addr);\r\ndev_set_mac_address(rollback_slave->dev, &sa);\r\nether_addr_copy(rollback_slave->dev->dev_addr, tmp_addr);\r\n}\r\nreturn res;\r\n}\r\nint bond_alb_initialize(struct bonding *bond, int rlb_enabled)\r\n{\r\nint res;\r\nres = tlb_initialize(bond);\r\nif (res)\r\nreturn res;\r\nif (rlb_enabled) {\r\nbond->alb_info.rlb_enabled = 1;\r\nres = rlb_initialize(bond);\r\nif (res) {\r\ntlb_deinitialize(bond);\r\nreturn res;\r\n}\r\n} else {\r\nbond->alb_info.rlb_enabled = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid bond_alb_deinitialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\ntlb_deinitialize(bond);\r\nif (bond_info->rlb_enabled)\r\nrlb_deinitialize(bond);\r\n}\r\nstatic int bond_do_alb_xmit(struct sk_buff *skb, struct bonding *bond,\r\nstruct slave *tx_slave)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct ethhdr *eth_data = eth_hdr(skb);\r\nif (!tx_slave) {\r\ntx_slave = rcu_dereference(bond->curr_active_slave);\r\nif (bond->params.tlb_dynamic_lb)\r\nbond_info->unbalanced_load += skb->len;\r\n}\r\nif (tx_slave && bond_slave_can_tx(tx_slave)) {\r\nif (tx_slave != rcu_access_pointer(bond->curr_active_slave)) {\r\nether_addr_copy(eth_data->h_source,\r\ntx_slave->dev->dev_addr);\r\n}\r\nbond_dev_queue_xmit(bond, skb, tx_slave->dev);\r\ngoto out;\r\n}\r\nif (tx_slave && bond->params.tlb_dynamic_lb) {\r\nspin_lock(&bond->mode_lock);\r\n__tlb_clear_slave(bond, tx_slave, 0);\r\nspin_unlock(&bond->mode_lock);\r\n}\r\nbond_tx_drop(bond->dev, skb);\r\nout:\r\nreturn NETDEV_TX_OK;\r\n}\r\nint bond_tlb_xmit(struct sk_buff *skb, struct net_device *bond_dev)\r\n{\r\nstruct bonding *bond = netdev_priv(bond_dev);\r\nstruct ethhdr *eth_data;\r\nstruct slave *tx_slave = NULL;\r\nu32 hash_index;\r\nskb_reset_mac_header(skb);\r\neth_data = eth_hdr(skb);\r\nif (!is_multicast_ether_addr(eth_data->h_dest)) {\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\ncase htons(ETH_P_IPX):\r\ncase htons(ETH_P_IPV6):\r\nhash_index = bond_xmit_hash(bond, skb);\r\nif (bond->params.tlb_dynamic_lb) {\r\ntx_slave = tlb_choose_channel(bond,\r\nhash_index & 0xFF,\r\nskb->len);\r\n} else {\r\nstruct bond_up_slave *slaves;\r\nunsigned int count;\r\nslaves = rcu_dereference(bond->slave_arr);\r\ncount = slaves ? ACCESS_ONCE(slaves->count) : 0;\r\nif (likely(count))\r\ntx_slave = slaves->arr[hash_index %\r\ncount];\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn bond_do_alb_xmit(skb, bond, tx_slave);\r\n}\r\nint bond_alb_xmit(struct sk_buff *skb, struct net_device *bond_dev)\r\n{\r\nstruct bonding *bond = netdev_priv(bond_dev);\r\nstruct ethhdr *eth_data;\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct slave *tx_slave = NULL;\r\nstatic const __be32 ip_bcast = htonl(0xffffffff);\r\nint hash_size = 0;\r\nbool do_tx_balance = true;\r\nu32 hash_index = 0;\r\nconst u8 *hash_start = NULL;\r\nstruct ipv6hdr *ip6hdr;\r\nskb_reset_mac_header(skb);\r\neth_data = eth_hdr(skb);\r\nswitch (ntohs(skb->protocol)) {\r\ncase ETH_P_IP: {\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nif (ether_addr_equal_64bits(eth_data->h_dest, mac_bcast) ||\r\n(iph->daddr == ip_bcast) ||\r\n(iph->protocol == IPPROTO_IGMP)) {\r\ndo_tx_balance = false;\r\nbreak;\r\n}\r\nhash_start = (char *)&(iph->daddr);\r\nhash_size = sizeof(iph->daddr);\r\n}\r\nbreak;\r\ncase ETH_P_IPV6:\r\nif (ether_addr_equal_64bits(eth_data->h_dest, mac_bcast)) {\r\ndo_tx_balance = false;\r\nbreak;\r\n}\r\nif (ether_addr_equal_64bits(eth_data->h_dest, mac_v6_allmcast)) {\r\ndo_tx_balance = false;\r\nbreak;\r\n}\r\nip6hdr = ipv6_hdr(skb);\r\nif (ipv6_addr_any(&ip6hdr->saddr)) {\r\ndo_tx_balance = false;\r\nbreak;\r\n}\r\nhash_start = (char *)&(ipv6_hdr(skb)->daddr);\r\nhash_size = sizeof(ipv6_hdr(skb)->daddr);\r\nbreak;\r\ncase ETH_P_IPX:\r\nif (ipx_hdr(skb)->ipx_checksum != IPX_NO_CHECKSUM) {\r\ndo_tx_balance = false;\r\nbreak;\r\n}\r\nif (ipx_hdr(skb)->ipx_type != IPX_TYPE_NCP) {\r\ndo_tx_balance = false;\r\nbreak;\r\n}\r\nhash_start = (char *)eth_data->h_dest;\r\nhash_size = ETH_ALEN;\r\nbreak;\r\ncase ETH_P_ARP:\r\ndo_tx_balance = false;\r\nif (bond_info->rlb_enabled)\r\ntx_slave = rlb_arp_xmit(skb, bond);\r\nbreak;\r\ndefault:\r\ndo_tx_balance = false;\r\nbreak;\r\n}\r\nif (do_tx_balance) {\r\nhash_index = _simple_hash(hash_start, hash_size);\r\ntx_slave = tlb_choose_channel(bond, hash_index, skb->len);\r\n}\r\nreturn bond_do_alb_xmit(skb, bond, tx_slave);\r\n}\r\nvoid bond_alb_monitor(struct work_struct *work)\r\n{\r\nstruct bonding *bond = container_of(work, struct bonding,\r\nalb_work.work);\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nif (!bond_has_slaves(bond)) {\r\nbond_info->tx_rebalance_counter = 0;\r\nbond_info->lp_counter = 0;\r\ngoto re_arm;\r\n}\r\nrcu_read_lock();\r\nbond_info->tx_rebalance_counter++;\r\nbond_info->lp_counter++;\r\nif (bond_info->lp_counter >= BOND_ALB_LP_TICKS(bond)) {\r\nbool strict_match;\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nstrict_match = (slave != rcu_access_pointer(bond->curr_active_slave) ||\r\nbond_info->rlb_enabled);\r\nalb_send_learning_packets(slave, slave->dev->dev_addr,\r\nstrict_match);\r\n}\r\nbond_info->lp_counter = 0;\r\n}\r\nif (bond_info->tx_rebalance_counter >= BOND_TLB_REBALANCE_TICKS) {\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\ntlb_clear_slave(bond, slave, 1);\r\nif (slave == rcu_access_pointer(bond->curr_active_slave)) {\r\nSLAVE_TLB_INFO(slave).load =\r\nbond_info->unbalanced_load /\r\nBOND_TLB_REBALANCE_INTERVAL;\r\nbond_info->unbalanced_load = 0;\r\n}\r\n}\r\nbond_info->tx_rebalance_counter = 0;\r\n}\r\nif (bond_info->rlb_enabled) {\r\nif (bond_info->primary_is_promisc &&\r\n(++bond_info->rlb_promisc_timeout_counter >= RLB_PROMISC_TIMEOUT)) {\r\nrcu_read_unlock();\r\nif (!rtnl_trylock())\r\ngoto re_arm;\r\nbond_info->rlb_promisc_timeout_counter = 0;\r\ndev_set_promiscuity(rtnl_dereference(bond->curr_active_slave)->dev,\r\n-1);\r\nbond_info->primary_is_promisc = 0;\r\nrtnl_unlock();\r\nrcu_read_lock();\r\n}\r\nif (bond_info->rlb_rebalance) {\r\nbond_info->rlb_rebalance = 0;\r\nrlb_rebalance(bond);\r\n}\r\nif (bond_info->rx_ntt) {\r\nif (bond_info->rlb_update_delay_counter) {\r\n--bond_info->rlb_update_delay_counter;\r\n} else {\r\nrlb_update_rx_clients(bond);\r\nif (bond_info->rlb_update_retry_counter)\r\n--bond_info->rlb_update_retry_counter;\r\nelse\r\nbond_info->rx_ntt = 0;\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\nre_arm:\r\nqueue_delayed_work(bond->wq, &bond->alb_work, alb_delta_in_ticks);\r\n}\r\nint bond_alb_init_slave(struct bonding *bond, struct slave *slave)\r\n{\r\nint res;\r\nres = alb_set_slave_mac_addr(slave, slave->perm_hwaddr);\r\nif (res)\r\nreturn res;\r\nres = alb_handle_addr_collision_on_attach(bond, slave);\r\nif (res)\r\nreturn res;\r\ntlb_init_slave(slave);\r\nbond->alb_info.tx_rebalance_counter = BOND_TLB_REBALANCE_TICKS;\r\nif (bond->alb_info.rlb_enabled)\r\nbond->alb_info.rlb_rebalance = 1;\r\nreturn 0;\r\n}\r\nvoid bond_alb_deinit_slave(struct bonding *bond, struct slave *slave)\r\n{\r\nif (bond_has_slaves(bond))\r\nalb_change_hw_addr_on_detach(bond, slave);\r\ntlb_clear_slave(bond, slave, 0);\r\nif (bond->alb_info.rlb_enabled) {\r\nbond->alb_info.rx_slave = NULL;\r\nrlb_clear_slave(bond, slave);\r\n}\r\n}\r\nvoid bond_alb_handle_link_change(struct bonding *bond, struct slave *slave, char link)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nif (link == BOND_LINK_DOWN) {\r\ntlb_clear_slave(bond, slave, 0);\r\nif (bond->alb_info.rlb_enabled)\r\nrlb_clear_slave(bond, slave);\r\n} else if (link == BOND_LINK_UP) {\r\nbond_info->tx_rebalance_counter = BOND_TLB_REBALANCE_TICKS;\r\nif (bond->alb_info.rlb_enabled) {\r\nbond->alb_info.rlb_rebalance = 1;\r\n}\r\n}\r\nif (bond_is_nondyn_tlb(bond)) {\r\nif (bond_update_slave_arr(bond, NULL))\r\npr_err("Failed to build slave-array for TLB mode.\n");\r\n}\r\n}\r\nvoid bond_alb_handle_active_change(struct bonding *bond, struct slave *new_slave)\r\n{\r\nstruct slave *swap_slave;\r\nstruct slave *curr_active;\r\ncurr_active = rtnl_dereference(bond->curr_active_slave);\r\nif (curr_active == new_slave)\r\nreturn;\r\nif (curr_active && bond->alb_info.primary_is_promisc) {\r\ndev_set_promiscuity(curr_active->dev, -1);\r\nbond->alb_info.primary_is_promisc = 0;\r\nbond->alb_info.rlb_promisc_timeout_counter = 0;\r\n}\r\nswap_slave = curr_active;\r\nrcu_assign_pointer(bond->curr_active_slave, new_slave);\r\nif (!new_slave || !bond_has_slaves(bond))\r\nreturn;\r\nif (!swap_slave)\r\nswap_slave = bond_slave_has_mac(bond, bond->dev->dev_addr);\r\nif (swap_slave)\r\ntlb_clear_slave(bond, swap_slave, 1);\r\ntlb_clear_slave(bond, new_slave, 1);\r\nif (BOND_MODE(bond) == BOND_MODE_TLB) {\r\nstruct sockaddr sa;\r\nu8 tmp_addr[ETH_ALEN];\r\nether_addr_copy(tmp_addr, new_slave->dev->dev_addr);\r\nmemcpy(sa.sa_data, bond->dev->dev_addr, bond->dev->addr_len);\r\nsa.sa_family = bond->dev->type;\r\ndev_set_mac_address(new_slave->dev, &sa);\r\nether_addr_copy(new_slave->dev->dev_addr, tmp_addr);\r\n}\r\nif (swap_slave) {\r\nalb_swap_mac_addr(swap_slave, new_slave);\r\nalb_fasten_mac_swap(bond, swap_slave, new_slave);\r\n} else {\r\nalb_set_slave_mac_addr(new_slave, bond->dev->dev_addr);\r\nalb_send_learning_packets(new_slave, bond->dev->dev_addr,\r\nfalse);\r\n}\r\n}\r\nint bond_alb_set_mac_address(struct net_device *bond_dev, void *addr)\r\n{\r\nstruct bonding *bond = netdev_priv(bond_dev);\r\nstruct sockaddr *sa = addr;\r\nstruct slave *curr_active;\r\nstruct slave *swap_slave;\r\nint res;\r\nif (!is_valid_ether_addr(sa->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nres = alb_set_mac_address(bond, addr);\r\nif (res)\r\nreturn res;\r\nmemcpy(bond_dev->dev_addr, sa->sa_data, bond_dev->addr_len);\r\ncurr_active = rtnl_dereference(bond->curr_active_slave);\r\nif (!curr_active)\r\nreturn 0;\r\nswap_slave = bond_slave_has_mac(bond, bond_dev->dev_addr);\r\nif (swap_slave) {\r\nalb_swap_mac_addr(swap_slave, curr_active);\r\nalb_fasten_mac_swap(bond, swap_slave, curr_active);\r\n} else {\r\nalb_set_slave_mac_addr(curr_active, bond_dev->dev_addr);\r\nalb_send_learning_packets(curr_active,\r\nbond_dev->dev_addr, false);\r\nif (bond->alb_info.rlb_enabled) {\r\nrlb_req_update_slave_clients(bond, curr_active);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid bond_alb_clear_vlan(struct bonding *bond, unsigned short vlan_id)\r\n{\r\nif (bond->alb_info.rlb_enabled)\r\nrlb_clear_vlan(bond, vlan_id);\r\n}
