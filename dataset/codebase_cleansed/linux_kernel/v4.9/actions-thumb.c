static void __kprobes\r\nt32_simulate_table_branch(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc;\r\nint rn = (insn >> 16) & 0xf;\r\nint rm = insn & 0xf;\r\nunsigned long rnv = (rn == 15) ? pc : regs->uregs[rn];\r\nunsigned long rmv = regs->uregs[rm];\r\nunsigned int halfwords;\r\nif (insn & 0x10)\r\nhalfwords = ((u16 *)rnv)[rmv];\r\nelse\r\nhalfwords = ((u8 *)rnv)[rmv];\r\nregs->ARM_pc = pc + 2 * halfwords;\r\n}\r\nstatic void __kprobes\r\nt32_simulate_mrs(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nint rd = (insn >> 8) & 0xf;\r\nunsigned long mask = 0xf8ff03df;\r\nregs->uregs[rd] = regs->ARM_cpsr & mask;\r\n}\r\nstatic void __kprobes\r\nt32_simulate_cond_branch(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc;\r\nlong offset = insn & 0x7ff;\r\noffset += (insn & 0x003f0000) >> 5;\r\noffset += (insn & 0x00002000) << 4;\r\noffset += (insn & 0x00000800) << 7;\r\noffset -= (insn & 0x04000000) >> 7;\r\nregs->ARM_pc = pc + (offset * 2);\r\n}\r\nstatic enum probes_insn __kprobes\r\nt32_decode_cond_branch(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\nint cc = (insn >> 22) & 0xf;\r\nasi->insn_check_cc = probes_condition_checks[cc];\r\nasi->insn_handler = t32_simulate_cond_branch;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nstatic void __kprobes\r\nt32_simulate_branch(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc;\r\nlong offset = insn & 0x7ff;\r\noffset += (insn & 0x03ff0000) >> 5;\r\noffset += (insn & 0x00002000) << 9;\r\noffset += (insn & 0x00000800) << 10;\r\nif (insn & 0x04000000)\r\noffset -= 0x00800000;\r\nelse\r\noffset ^= 0x00600000;\r\nif (insn & (1 << 14)) {\r\nregs->ARM_lr = regs->ARM_pc | 1;\r\nif (!(insn & (1 << 12))) {\r\nregs->ARM_cpsr &= ~PSR_T_BIT;\r\npc &= ~3;\r\n}\r\n}\r\nregs->ARM_pc = pc + (offset * 2);\r\n}\r\nstatic void __kprobes\r\nt32_simulate_ldr_literal(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long addr = regs->ARM_pc & ~3;\r\nint rt = (insn >> 12) & 0xf;\r\nunsigned long rtv;\r\nlong offset = insn & 0xfff;\r\nif (insn & 0x00800000)\r\naddr += offset;\r\nelse\r\naddr -= offset;\r\nif (insn & 0x00400000) {\r\nrtv = *(unsigned long *)addr;\r\nif (rt == 15) {\r\nbx_write_pc(rtv, regs);\r\nreturn;\r\n}\r\n} else if (insn & 0x00200000) {\r\nif (insn & 0x01000000)\r\nrtv = *(s16 *)addr;\r\nelse\r\nrtv = *(u16 *)addr;\r\n} else {\r\nif (insn & 0x01000000)\r\nrtv = *(s8 *)addr;\r\nelse\r\nrtv = *(u8 *)addr;\r\n}\r\nregs->uregs[rt] = rtv;\r\n}\r\nstatic enum probes_insn __kprobes\r\nt32_decode_ldmstm(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\nenum probes_insn ret = kprobe_decode_ldmstm(insn, asi, d);\r\ninsn = __mem_to_opcode_arm(asi->insn[0]);\r\n((u16 *)asi->insn)[0] = __opcode_to_mem_thumb16(insn >> 16);\r\n((u16 *)asi->insn)[1] = __opcode_to_mem_thumb16(insn & 0xffff);\r\nreturn ret;\r\n}\r\nstatic void __kprobes\r\nt32_emulate_ldrdstrd(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc & ~3;\r\nint rt1 = (insn >> 12) & 0xf;\r\nint rt2 = (insn >> 8) & 0xf;\r\nint rn = (insn >> 16) & 0xf;\r\nregister unsigned long rt1v asm("r0") = regs->uregs[rt1];\r\nregister unsigned long rt2v asm("r1") = regs->uregs[rt2];\r\nregister unsigned long rnv asm("r2") = (rn == 15) ? pc\r\n: regs->uregs[rn];\r\n__asm__ __volatile__ (\r\n"blx %[fn]"\r\n: "=r" (rt1v), "=r" (rt2v), "=r" (rnv)\r\n: "0" (rt1v), "1" (rt2v), "2" (rnv), [fn] "r" (asi->insn_fn)\r\n: "lr", "memory", "cc"\r\n);\r\nif (rn != 15)\r\nregs->uregs[rn] = rnv;\r\nregs->uregs[rt1] = rt1v;\r\nregs->uregs[rt2] = rt2v;\r\n}\r\nstatic void __kprobes\r\nt32_emulate_ldrstr(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nint rt = (insn >> 12) & 0xf;\r\nint rn = (insn >> 16) & 0xf;\r\nint rm = insn & 0xf;\r\nregister unsigned long rtv asm("r0") = regs->uregs[rt];\r\nregister unsigned long rnv asm("r2") = regs->uregs[rn];\r\nregister unsigned long rmv asm("r3") = regs->uregs[rm];\r\n__asm__ __volatile__ (\r\n"blx %[fn]"\r\n: "=r" (rtv), "=r" (rnv)\r\n: "0" (rtv), "1" (rnv), "r" (rmv), [fn] "r" (asi->insn_fn)\r\n: "lr", "memory", "cc"\r\n);\r\nregs->uregs[rn] = rnv;\r\nif (rt == 15)\r\nbx_write_pc(rtv, regs);\r\nelse\r\nregs->uregs[rt] = rtv;\r\n}\r\nstatic void __kprobes\r\nt32_emulate_rd8rn16rm0_rwflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nint rd = (insn >> 8) & 0xf;\r\nint rn = (insn >> 16) & 0xf;\r\nint rm = insn & 0xf;\r\nregister unsigned long rdv asm("r1") = regs->uregs[rd];\r\nregister unsigned long rnv asm("r2") = regs->uregs[rn];\r\nregister unsigned long rmv asm("r3") = regs->uregs[rm];\r\nunsigned long cpsr = regs->ARM_cpsr;\r\n__asm__ __volatile__ (\r\n"msr cpsr_fs, %[cpsr] \n\t"\r\n"blx %[fn] \n\t"\r\n"mrs %[cpsr], cpsr \n\t"\r\n: "=r" (rdv), [cpsr] "=r" (cpsr)\r\n: "0" (rdv), "r" (rnv), "r" (rmv),\r\n"1" (cpsr), [fn] "r" (asi->insn_fn)\r\n: "lr", "memory", "cc"\r\n);\r\nregs->uregs[rd] = rdv;\r\nregs->ARM_cpsr = (regs->ARM_cpsr & ~APSR_MASK) | (cpsr & APSR_MASK);\r\n}\r\nstatic void __kprobes\r\nt32_emulate_rd8pc16_noflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc;\r\nint rd = (insn >> 8) & 0xf;\r\nregister unsigned long rdv asm("r1") = regs->uregs[rd];\r\nregister unsigned long rnv asm("r2") = pc & ~3;\r\n__asm__ __volatile__ (\r\n"blx %[fn]"\r\n: "=r" (rdv)\r\n: "0" (rdv), "r" (rnv), [fn] "r" (asi->insn_fn)\r\n: "lr", "memory", "cc"\r\n);\r\nregs->uregs[rd] = rdv;\r\n}\r\nstatic void __kprobes\r\nt32_emulate_rd8rn16_noflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nint rd = (insn >> 8) & 0xf;\r\nint rn = (insn >> 16) & 0xf;\r\nregister unsigned long rdv asm("r1") = regs->uregs[rd];\r\nregister unsigned long rnv asm("r2") = regs->uregs[rn];\r\n__asm__ __volatile__ (\r\n"blx %[fn]"\r\n: "=r" (rdv)\r\n: "0" (rdv), "r" (rnv), [fn] "r" (asi->insn_fn)\r\n: "lr", "memory", "cc"\r\n);\r\nregs->uregs[rd] = rdv;\r\n}\r\nstatic void __kprobes\r\nt32_emulate_rdlo12rdhi8rn16rm0_noflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nstruct pt_regs *regs)\r\n{\r\nint rdlo = (insn >> 12) & 0xf;\r\nint rdhi = (insn >> 8) & 0xf;\r\nint rn = (insn >> 16) & 0xf;\r\nint rm = insn & 0xf;\r\nregister unsigned long rdlov asm("r0") = regs->uregs[rdlo];\r\nregister unsigned long rdhiv asm("r1") = regs->uregs[rdhi];\r\nregister unsigned long rnv asm("r2") = regs->uregs[rn];\r\nregister unsigned long rmv asm("r3") = regs->uregs[rm];\r\n__asm__ __volatile__ (\r\n"blx %[fn]"\r\n: "=r" (rdlov), "=r" (rdhiv)\r\n: "0" (rdlov), "1" (rdhiv), "r" (rnv), "r" (rmv),\r\n[fn] "r" (asi->insn_fn)\r\n: "lr", "memory", "cc"\r\n);\r\nregs->uregs[rdlo] = rdlov;\r\nregs->uregs[rdhi] = rdhiv;\r\n}\r\nstatic void __kprobes\r\nt16_simulate_bxblx(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc + 2;\r\nint rm = (insn >> 3) & 0xf;\r\nunsigned long rmv = (rm == 15) ? pc : regs->uregs[rm];\r\nif (insn & (1 << 7))\r\nregs->ARM_lr = regs->ARM_pc | 1;\r\nbx_write_pc(rmv, regs);\r\n}\r\nstatic void __kprobes\r\nt16_simulate_ldr_literal(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long *base = (unsigned long *)((regs->ARM_pc + 2) & ~3);\r\nlong index = insn & 0xff;\r\nint rt = (insn >> 8) & 0x7;\r\nregs->uregs[rt] = base[index];\r\n}\r\nstatic void __kprobes\r\nt16_simulate_ldrstr_sp_relative(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long* base = (unsigned long *)regs->ARM_sp;\r\nlong index = insn & 0xff;\r\nint rt = (insn >> 8) & 0x7;\r\nif (insn & 0x800)\r\nregs->uregs[rt] = base[index];\r\nelse\r\nbase[index] = regs->uregs[rt];\r\n}\r\nstatic void __kprobes\r\nt16_simulate_reladr(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long base = (insn & 0x800) ? regs->ARM_sp\r\n: ((regs->ARM_pc + 2) & ~3);\r\nlong offset = insn & 0xff;\r\nint rt = (insn >> 8) & 0x7;\r\nregs->uregs[rt] = base + offset * 4;\r\n}\r\nstatic void __kprobes\r\nt16_simulate_add_sp_imm(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nlong imm = insn & 0x7f;\r\nif (insn & 0x80)\r\nregs->ARM_sp -= imm * 4;\r\nelse\r\nregs->ARM_sp += imm * 4;\r\n}\r\nstatic void __kprobes\r\nt16_simulate_cbz(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nint rn = insn & 0x7;\r\nprobes_opcode_t nonzero = regs->uregs[rn] ? insn : ~insn;\r\nif (nonzero & 0x800) {\r\nlong i = insn & 0x200;\r\nlong imm5 = insn & 0xf8;\r\nunsigned long pc = regs->ARM_pc + 2;\r\nregs->ARM_pc = pc + (i >> 3) + (imm5 >> 2);\r\n}\r\n}\r\nstatic void __kprobes\r\nt16_simulate_it(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long cpsr = regs->ARM_cpsr;\r\ncpsr &= ~PSR_IT_MASK;\r\ncpsr |= (insn & 0xfc) << 8;\r\ncpsr |= (insn & 0x03) << 25;\r\nregs->ARM_cpsr = cpsr;\r\n}\r\nstatic void __kprobes\r\nt16_singlestep_it(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nregs->ARM_pc += 2;\r\nt16_simulate_it(insn, asi, regs);\r\n}\r\nstatic enum probes_insn __kprobes\r\nt16_decode_it(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\nasi->insn_singlestep = t16_singlestep_it;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nstatic void __kprobes\r\nt16_simulate_cond_branch(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc + 2;\r\nlong offset = insn & 0x7f;\r\noffset -= insn & 0x80;\r\nregs->ARM_pc = pc + (offset * 2);\r\n}\r\nstatic enum probes_insn __kprobes\r\nt16_decode_cond_branch(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\nint cc = (insn >> 8) & 0xf;\r\nasi->insn_check_cc = probes_condition_checks[cc];\r\nasi->insn_handler = t16_simulate_cond_branch;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nstatic void __kprobes\r\nt16_simulate_branch(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc + 2;\r\nlong offset = insn & 0x3ff;\r\noffset -= insn & 0x400;\r\nregs->ARM_pc = pc + (offset * 2);\r\n}\r\nstatic unsigned long __kprobes\r\nt16_emulate_loregs(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long oldcpsr = regs->ARM_cpsr;\r\nunsigned long newcpsr;\r\n__asm__ __volatile__ (\r\n"msr cpsr_fs, %[oldcpsr] \n\t"\r\n"ldmia %[regs], {r0-r7} \n\t"\r\n"blx %[fn] \n\t"\r\n"stmia %[regs], {r0-r7} \n\t"\r\n"mrs %[newcpsr], cpsr \n\t"\r\n: [newcpsr] "=r" (newcpsr)\r\n: [oldcpsr] "r" (oldcpsr), [regs] "r" (regs),\r\n[fn] "r" (asi->insn_fn)\r\n: "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",\r\n"lr", "memory", "cc"\r\n);\r\nreturn (oldcpsr & ~APSR_MASK) | (newcpsr & APSR_MASK);\r\n}\r\nstatic void __kprobes\r\nt16_emulate_loregs_rwflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nregs->ARM_cpsr = t16_emulate_loregs(insn, asi, regs);\r\n}\r\nstatic void __kprobes\r\nt16_emulate_loregs_noitrwflags(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long cpsr = t16_emulate_loregs(insn, asi, regs);\r\nif (!in_it_block(cpsr))\r\nregs->ARM_cpsr = cpsr;\r\n}\r\nstatic void __kprobes\r\nt16_emulate_hiregs(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nunsigned long pc = regs->ARM_pc + 2;\r\nint rdn = (insn & 0x7) | ((insn & 0x80) >> 4);\r\nint rm = (insn >> 3) & 0xf;\r\nregister unsigned long rdnv asm("r1");\r\nregister unsigned long rmv asm("r0");\r\nunsigned long cpsr = regs->ARM_cpsr;\r\nrdnv = (rdn == 15) ? pc : regs->uregs[rdn];\r\nrmv = (rm == 15) ? pc : regs->uregs[rm];\r\n__asm__ __volatile__ (\r\n"msr cpsr_fs, %[cpsr] \n\t"\r\n"blx %[fn] \n\t"\r\n"mrs %[cpsr], cpsr \n\t"\r\n: "=r" (rdnv), [cpsr] "=r" (cpsr)\r\n: "0" (rdnv), "r" (rmv), "1" (cpsr), [fn] "r" (asi->insn_fn)\r\n: "lr", "memory", "cc"\r\n);\r\nif (rdn == 15)\r\nrdnv &= ~1;\r\nregs->uregs[rdn] = rdnv;\r\nregs->ARM_cpsr = (regs->ARM_cpsr & ~APSR_MASK) | (cpsr & APSR_MASK);\r\n}\r\nstatic enum probes_insn __kprobes\r\nt16_decode_hiregs(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\ninsn &= ~0x00ff;\r\ninsn |= 0x001;\r\n((u16 *)asi->insn)[0] = __opcode_to_mem_thumb16(insn);\r\nasi->insn_handler = t16_emulate_hiregs;\r\nreturn INSN_GOOD;\r\n}\r\nstatic void __kprobes\r\nt16_emulate_push(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\n__asm__ __volatile__ (\r\n"ldr r9, [%[regs], #13*4] \n\t"\r\n"ldr r8, [%[regs], #14*4] \n\t"\r\n"ldmia %[regs], {r0-r7} \n\t"\r\n"blx %[fn] \n\t"\r\n"str r9, [%[regs], #13*4] \n\t"\r\n:\r\n: [regs] "r" (regs), [fn] "r" (asi->insn_fn)\r\n: "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9",\r\n"lr", "memory", "cc"\r\n);\r\n}\r\nstatic enum probes_insn __kprobes\r\nt16_decode_push(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\n((u16 *)asi->insn)[0] = __opcode_to_mem_thumb16(0xe929);\r\n((u16 *)asi->insn)[1] = __opcode_to_mem_thumb16(insn & 0x1ff);\r\nasi->insn_handler = t16_emulate_push;\r\nreturn INSN_GOOD;\r\n}\r\nstatic void __kprobes\r\nt16_emulate_pop_nopc(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\n__asm__ __volatile__ (\r\n"ldr r9, [%[regs], #13*4] \n\t"\r\n"ldmia %[regs], {r0-r7} \n\t"\r\n"blx %[fn] \n\t"\r\n"stmia %[regs], {r0-r7} \n\t"\r\n"str r9, [%[regs], #13*4] \n\t"\r\n:\r\n: [regs] "r" (regs), [fn] "r" (asi->insn_fn)\r\n: "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r9",\r\n"lr", "memory", "cc"\r\n);\r\n}\r\nstatic void __kprobes\r\nt16_emulate_pop_pc(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi, struct pt_regs *regs)\r\n{\r\nregister unsigned long pc asm("r8");\r\n__asm__ __volatile__ (\r\n"ldr r9, [%[regs], #13*4] \n\t"\r\n"ldmia %[regs], {r0-r7} \n\t"\r\n"blx %[fn] \n\t"\r\n"stmia %[regs], {r0-r7} \n\t"\r\n"str r9, [%[regs], #13*4] \n\t"\r\n: "=r" (pc)\r\n: [regs] "r" (regs), [fn] "r" (asi->insn_fn)\r\n: "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r9",\r\n"lr", "memory", "cc"\r\n);\r\nbx_write_pc(pc, regs);\r\n}\r\nstatic enum probes_insn __kprobes\r\nt16_decode_pop(probes_opcode_t insn, struct arch_probes_insn *asi,\r\nconst struct decode_header *d)\r\n{\r\n((u16 *)asi->insn)[0] = __opcode_to_mem_thumb16(0xe8b9);\r\n((u16 *)asi->insn)[1] = __opcode_to_mem_thumb16(insn & 0x1ff);\r\nasi->insn_handler = insn & 0x100 ? t16_emulate_pop_pc\r\n: t16_emulate_pop_nopc;\r\nreturn INSN_GOOD;\r\n}
