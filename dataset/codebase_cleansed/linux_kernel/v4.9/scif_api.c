scif_epd_t scif_open(void)\r\n{\r\nstruct scif_endpt *ep;\r\nint err;\r\nmight_sleep();\r\nep = kzalloc(sizeof(*ep), GFP_KERNEL);\r\nif (!ep)\r\ngoto err_ep_alloc;\r\nep->qp_info.qp = kzalloc(sizeof(*ep->qp_info.qp), GFP_KERNEL);\r\nif (!ep->qp_info.qp)\r\ngoto err_qp_alloc;\r\nerr = scif_anon_inode_getfile(ep);\r\nif (err)\r\ngoto err_anon_inode;\r\nspin_lock_init(&ep->lock);\r\nmutex_init(&ep->sendlock);\r\nmutex_init(&ep->recvlock);\r\nscif_rma_ep_init(ep);\r\nep->state = SCIFEP_UNBOUND;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI open: ep %p success\n", ep);\r\nreturn ep;\r\nerr_anon_inode:\r\nkfree(ep->qp_info.qp);\r\nerr_qp_alloc:\r\nkfree(ep);\r\nerr_ep_alloc:\r\nreturn NULL;\r\n}\r\nstatic struct scif_endpt *scif_disconnect_ep(struct scif_endpt *ep)\r\n{\r\nstruct scifmsg msg;\r\nstruct scif_endpt *fep = NULL;\r\nstruct scif_endpt *tmpep;\r\nstruct list_head *pos, *tmpq;\r\nint err;\r\nwake_up_interruptible(&ep->sendwq);\r\nwake_up_interruptible(&ep->recvwq);\r\nmutex_lock(&ep->sendlock);\r\nmutex_unlock(&ep->sendlock);\r\nmutex_lock(&ep->recvlock);\r\nmutex_unlock(&ep->recvlock);\r\nmutex_lock(&scif_info.connlock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.connected) {\r\ntmpep = list_entry(pos, struct scif_endpt, list);\r\nif (tmpep == ep) {\r\nlist_del(pos);\r\nfep = tmpep;\r\nspin_lock(&ep->lock);\r\nbreak;\r\n}\r\n}\r\nif (!fep) {\r\nlist_for_each_safe(pos, tmpq, &scif_info.disconnected) {\r\ntmpep = list_entry(pos, struct scif_endpt, list);\r\nif (tmpep == ep) {\r\nlist_del(pos);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&scif_info.connlock);\r\nreturn NULL;\r\n}\r\ninit_completion(&ep->discon);\r\nmsg.uop = SCIF_DISCNCT;\r\nmsg.src = ep->port;\r\nmsg.dst = ep->peer;\r\nmsg.payload[0] = (u64)ep;\r\nmsg.payload[1] = ep->remote_ep;\r\nerr = scif_nodeqp_send(ep->remote_dev, &msg);\r\nspin_unlock(&ep->lock);\r\nmutex_unlock(&scif_info.connlock);\r\nif (!err)\r\nwait_for_completion_timeout(&ep->discon,\r\nSCIF_NODE_ALIVE_TIMEOUT);\r\nreturn ep;\r\n}\r\nint scif_close(scif_epd_t epd)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct scif_endpt *tmpep;\r\nstruct list_head *pos, *tmpq;\r\nenum scif_epd_state oldstate;\r\nbool flush_conn;\r\ndev_dbg(scif_info.mdev.this_device, "SCIFAPI close: ep %p %s\n",\r\nep, scif_ep_states[ep->state]);\r\nmight_sleep();\r\nspin_lock(&ep->lock);\r\nflush_conn = (ep->conn_async_state == ASYNC_CONN_INPROGRESS);\r\nspin_unlock(&ep->lock);\r\nif (flush_conn)\r\nflush_work(&scif_info.conn_work);\r\nspin_lock(&ep->lock);\r\noldstate = ep->state;\r\nep->state = SCIFEP_CLOSING;\r\nswitch (oldstate) {\r\ncase SCIFEP_ZOMBIE:\r\ndev_err(scif_info.mdev.this_device,\r\n"SCIFAPI close: zombie state unexpected\n");\r\ncase SCIFEP_DISCONNECTED:\r\nspin_unlock(&ep->lock);\r\nscif_unregister_all_windows(epd);\r\nmutex_lock(&scif_info.connlock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.disconnected) {\r\ntmpep = list_entry(pos, struct scif_endpt, list);\r\nif (tmpep == ep) {\r\nlist_del(pos);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&scif_info.connlock);\r\nbreak;\r\ncase SCIFEP_UNBOUND:\r\ncase SCIFEP_BOUND:\r\ncase SCIFEP_CONNECTING:\r\nspin_unlock(&ep->lock);\r\nbreak;\r\ncase SCIFEP_MAPPING:\r\ncase SCIFEP_CONNECTED:\r\ncase SCIFEP_CLOSING:\r\n{\r\nspin_unlock(&ep->lock);\r\nscif_unregister_all_windows(epd);\r\nscif_disconnect_ep(ep);\r\nbreak;\r\n}\r\ncase SCIFEP_LISTENING:\r\ncase SCIFEP_CLLISTEN:\r\n{\r\nstruct scif_conreq *conreq;\r\nstruct scifmsg msg;\r\nstruct scif_endpt *aep;\r\nspin_unlock(&ep->lock);\r\nmutex_lock(&scif_info.eplock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.listen) {\r\ntmpep = list_entry(pos, struct scif_endpt, list);\r\nif (tmpep == ep)\r\nlist_del(pos);\r\n}\r\nwhile (ep->acceptcnt) {\r\naep = list_first_entry(&ep->li_accept,\r\nstruct scif_endpt, liacceptlist);\r\nlist_del(&aep->liacceptlist);\r\nscif_put_port(aep->port.port);\r\nlist_for_each_safe(pos, tmpq, &scif_info.uaccept) {\r\ntmpep = list_entry(pos, struct scif_endpt,\r\nmiacceptlist);\r\nif (tmpep == aep) {\r\nlist_del(pos);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&scif_info.eplock);\r\nmutex_lock(&scif_info.connlock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.connected) {\r\ntmpep = list_entry(pos,\r\nstruct scif_endpt, list);\r\nif (tmpep == aep) {\r\nlist_del(pos);\r\nbreak;\r\n}\r\n}\r\nlist_for_each_safe(pos, tmpq, &scif_info.disconnected) {\r\ntmpep = list_entry(pos,\r\nstruct scif_endpt, list);\r\nif (tmpep == aep) {\r\nlist_del(pos);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&scif_info.connlock);\r\nscif_teardown_ep(aep);\r\nmutex_lock(&scif_info.eplock);\r\nscif_add_epd_to_zombie_list(aep, SCIF_EPLOCK_HELD);\r\nep->acceptcnt--;\r\n}\r\nspin_lock(&ep->lock);\r\nmutex_unlock(&scif_info.eplock);\r\nwhile (ep->conreqcnt) {\r\nconreq = list_first_entry(&ep->conlist,\r\nstruct scif_conreq, list);\r\nlist_del(&conreq->list);\r\nmsg.uop = SCIF_CNCT_REJ;\r\nmsg.dst.node = conreq->msg.src.node;\r\nmsg.dst.port = conreq->msg.src.port;\r\nmsg.payload[0] = conreq->msg.payload[0];\r\nmsg.payload[1] = conreq->msg.payload[1];\r\nscif_nodeqp_send(&scif_dev[conreq->msg.src.node],\r\n&msg);\r\nep->conreqcnt--;\r\nkfree(conreq);\r\n}\r\nspin_unlock(&ep->lock);\r\nwake_up_interruptible(&ep->conwq);\r\nbreak;\r\n}\r\n}\r\nscif_put_port(ep->port.port);\r\nscif_anon_inode_fput(ep);\r\nscif_teardown_ep(ep);\r\nscif_add_epd_to_zombie_list(ep, !SCIF_EPLOCK_HELD);\r\nreturn 0;\r\n}\r\nint __scif_flush(scif_epd_t epd)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nswitch (ep->state) {\r\ncase SCIFEP_LISTENING:\r\n{\r\nep->state = SCIFEP_CLLISTEN;\r\nwake_up_interruptible(&ep->conwq);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint scif_bind(scif_epd_t epd, u16 pn)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint ret = 0;\r\nint tmp;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI bind: ep %p %s requested port number %d\n",\r\nep, scif_ep_states[ep->state], pn);\r\nif (pn) {\r\nif (pn < SCIF_ADMIN_PORT_END && !capable(CAP_SYS_ADMIN)) {\r\nret = -EACCES;\r\ngoto scif_bind_admin_exit;\r\n}\r\n}\r\nspin_lock(&ep->lock);\r\nif (ep->state == SCIFEP_BOUND) {\r\nret = -EINVAL;\r\ngoto scif_bind_exit;\r\n} else if (ep->state != SCIFEP_UNBOUND) {\r\nret = -EISCONN;\r\ngoto scif_bind_exit;\r\n}\r\nif (pn) {\r\ntmp = scif_rsrv_port(pn);\r\nif (tmp != pn) {\r\nret = -EINVAL;\r\ngoto scif_bind_exit;\r\n}\r\n} else {\r\npn = scif_get_new_port();\r\nif (!pn) {\r\nret = -ENOSPC;\r\ngoto scif_bind_exit;\r\n}\r\n}\r\nep->state = SCIFEP_BOUND;\r\nep->port.node = scif_info.nodeid;\r\nep->port.port = pn;\r\nep->conn_async_state = ASYNC_CONN_IDLE;\r\nret = pn;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI bind: bound to port number %d\n", pn);\r\nscif_bind_exit:\r\nspin_unlock(&ep->lock);\r\nscif_bind_admin_exit:\r\nreturn ret;\r\n}\r\nint scif_listen(scif_epd_t epd, int backlog)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI listen: ep %p %s\n", ep, scif_ep_states[ep->state]);\r\nspin_lock(&ep->lock);\r\nswitch (ep->state) {\r\ncase SCIFEP_ZOMBIE:\r\ncase SCIFEP_CLOSING:\r\ncase SCIFEP_CLLISTEN:\r\ncase SCIFEP_UNBOUND:\r\ncase SCIFEP_DISCONNECTED:\r\nspin_unlock(&ep->lock);\r\nreturn -EINVAL;\r\ncase SCIFEP_LISTENING:\r\ncase SCIFEP_CONNECTED:\r\ncase SCIFEP_CONNECTING:\r\ncase SCIFEP_MAPPING:\r\nspin_unlock(&ep->lock);\r\nreturn -EISCONN;\r\ncase SCIFEP_BOUND:\r\nbreak;\r\n}\r\nep->state = SCIFEP_LISTENING;\r\nep->backlog = backlog;\r\nep->conreqcnt = 0;\r\nep->acceptcnt = 0;\r\nINIT_LIST_HEAD(&ep->conlist);\r\ninit_waitqueue_head(&ep->conwq);\r\nINIT_LIST_HEAD(&ep->li_accept);\r\nspin_unlock(&ep->lock);\r\nscif_teardown_ep(ep);\r\nep->qp_info.qp = NULL;\r\nmutex_lock(&scif_info.eplock);\r\nlist_add_tail(&ep->list, &scif_info.listen);\r\nmutex_unlock(&scif_info.eplock);\r\nreturn 0;\r\n}\r\nstatic int scif_conn_func(struct scif_endpt *ep)\r\n{\r\nint err = 0;\r\nstruct scifmsg msg;\r\nstruct device *spdev;\r\nerr = scif_reserve_dma_chan(ep);\r\nif (err) {\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\nep->state = SCIFEP_BOUND;\r\ngoto connect_error_simple;\r\n}\r\nerr = scif_setup_qp_connect(ep->qp_info.qp, &ep->qp_info.qp_offset,\r\nSCIF_ENDPT_QP_SIZE, ep->remote_dev);\r\nif (err) {\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s err %d qp_offset 0x%llx\n",\r\n__func__, err, ep->qp_info.qp_offset);\r\nep->state = SCIFEP_BOUND;\r\ngoto connect_error_simple;\r\n}\r\nspdev = scif_get_peer_dev(ep->remote_dev);\r\nif (IS_ERR(spdev)) {\r\nerr = PTR_ERR(spdev);\r\ngoto cleanup_qp;\r\n}\r\nmsg.src = ep->port;\r\nmsg.dst = ep->conn_port;\r\nmsg.uop = SCIF_CNCT_REQ;\r\nmsg.payload[0] = (u64)ep;\r\nmsg.payload[1] = ep->qp_info.qp_offset;\r\nerr = _scif_nodeqp_send(ep->remote_dev, &msg);\r\nif (err)\r\ngoto connect_error_dec;\r\nscif_put_peer_dev(spdev);\r\nerr = wait_event_timeout(ep->conwq, ep->state != SCIFEP_CONNECTING,\r\nSCIF_NODE_ALIVE_TIMEOUT);\r\nif (!err) {\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s %d timeout\n", __func__, __LINE__);\r\nep->state = SCIFEP_BOUND;\r\n}\r\nspdev = scif_get_peer_dev(ep->remote_dev);\r\nif (IS_ERR(spdev)) {\r\nerr = PTR_ERR(spdev);\r\ngoto cleanup_qp;\r\n}\r\nif (ep->state == SCIFEP_MAPPING) {\r\nerr = scif_setup_qp_connect_response(ep->remote_dev,\r\nep->qp_info.qp,\r\nep->qp_info.gnt_pld);\r\nif (err) {\r\ndev_err(&ep->remote_dev->sdev->dev,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\nmsg.uop = SCIF_CNCT_GNTNACK;\r\nmsg.payload[0] = ep->remote_ep;\r\n_scif_nodeqp_send(ep->remote_dev, &msg);\r\nep->state = SCIFEP_BOUND;\r\ngoto connect_error_dec;\r\n}\r\nmsg.uop = SCIF_CNCT_GNTACK;\r\nmsg.payload[0] = ep->remote_ep;\r\nerr = _scif_nodeqp_send(ep->remote_dev, &msg);\r\nif (err) {\r\nep->state = SCIFEP_BOUND;\r\ngoto connect_error_dec;\r\n}\r\nep->state = SCIFEP_CONNECTED;\r\nmutex_lock(&scif_info.connlock);\r\nlist_add_tail(&ep->list, &scif_info.connected);\r\nmutex_unlock(&scif_info.connlock);\r\ndev_dbg(&ep->remote_dev->sdev->dev,\r\n"SCIFAPI connect: ep %p connected\n", ep);\r\n} else if (ep->state == SCIFEP_BOUND) {\r\ndev_dbg(&ep->remote_dev->sdev->dev,\r\n"SCIFAPI connect: ep %p connection refused\n", ep);\r\nerr = -ECONNREFUSED;\r\ngoto connect_error_dec;\r\n}\r\nscif_put_peer_dev(spdev);\r\nreturn err;\r\nconnect_error_dec:\r\nscif_put_peer_dev(spdev);\r\ncleanup_qp:\r\nscif_cleanup_ep_qp(ep);\r\nconnect_error_simple:\r\nreturn err;\r\n}\r\nvoid scif_conn_handler(struct work_struct *work)\r\n{\r\nstruct scif_endpt *ep;\r\ndo {\r\nep = NULL;\r\nspin_lock(&scif_info.nb_connect_lock);\r\nif (!list_empty(&scif_info.nb_connect_list)) {\r\nep = list_first_entry(&scif_info.nb_connect_list,\r\nstruct scif_endpt, conn_list);\r\nlist_del(&ep->conn_list);\r\n}\r\nspin_unlock(&scif_info.nb_connect_lock);\r\nif (ep) {\r\nep->conn_err = scif_conn_func(ep);\r\nwake_up_interruptible(&ep->conn_pend_wq);\r\n}\r\n} while (ep);\r\n}\r\nint __scif_connect(scif_epd_t epd, struct scif_port_id *dst, bool non_block)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint err = 0;\r\nstruct scif_dev *remote_dev;\r\nstruct device *spdev;\r\ndev_dbg(scif_info.mdev.this_device, "SCIFAPI connect: ep %p %s\n", ep,\r\nscif_ep_states[ep->state]);\r\nif (!scif_dev || dst->node > scif_info.maxid)\r\nreturn -ENODEV;\r\nmight_sleep();\r\nremote_dev = &scif_dev[dst->node];\r\nspdev = scif_get_peer_dev(remote_dev);\r\nif (IS_ERR(spdev)) {\r\nerr = PTR_ERR(spdev);\r\nreturn err;\r\n}\r\nspin_lock(&ep->lock);\r\nswitch (ep->state) {\r\ncase SCIFEP_ZOMBIE:\r\ncase SCIFEP_CLOSING:\r\nerr = -EINVAL;\r\nbreak;\r\ncase SCIFEP_DISCONNECTED:\r\nif (ep->conn_async_state == ASYNC_CONN_INPROGRESS)\r\nep->conn_async_state = ASYNC_CONN_FLUSH_WORK;\r\nelse\r\nerr = -EINVAL;\r\nbreak;\r\ncase SCIFEP_LISTENING:\r\ncase SCIFEP_CLLISTEN:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\ncase SCIFEP_CONNECTING:\r\ncase SCIFEP_MAPPING:\r\nif (ep->conn_async_state == ASYNC_CONN_INPROGRESS)\r\nerr = -EINPROGRESS;\r\nelse\r\nerr = -EISCONN;\r\nbreak;\r\ncase SCIFEP_CONNECTED:\r\nif (ep->conn_async_state == ASYNC_CONN_INPROGRESS)\r\nep->conn_async_state = ASYNC_CONN_FLUSH_WORK;\r\nelse\r\nerr = -EISCONN;\r\nbreak;\r\ncase SCIFEP_UNBOUND:\r\nep->port.port = scif_get_new_port();\r\nif (!ep->port.port) {\r\nerr = -ENOSPC;\r\n} else {\r\nep->port.node = scif_info.nodeid;\r\nep->conn_async_state = ASYNC_CONN_IDLE;\r\n}\r\ncase SCIFEP_BOUND:\r\nif (ep->conn_async_state == ASYNC_CONN_INPROGRESS) {\r\nep->conn_async_state = ASYNC_CONN_FLUSH_WORK;\r\n} else if (ep->conn_async_state == ASYNC_CONN_FLUSH_WORK) {\r\nerr = -EINPROGRESS;\r\n} else {\r\nep->conn_port = *dst;\r\ninit_waitqueue_head(&ep->sendwq);\r\ninit_waitqueue_head(&ep->recvwq);\r\ninit_waitqueue_head(&ep->conwq);\r\nep->conn_async_state = 0;\r\nif (unlikely(non_block))\r\nep->conn_async_state = ASYNC_CONN_INPROGRESS;\r\n}\r\nbreak;\r\n}\r\nif (err || ep->conn_async_state == ASYNC_CONN_FLUSH_WORK)\r\ngoto connect_simple_unlock1;\r\nep->state = SCIFEP_CONNECTING;\r\nep->remote_dev = &scif_dev[dst->node];\r\nep->qp_info.qp->magic = SCIFEP_MAGIC;\r\nif (ep->conn_async_state == ASYNC_CONN_INPROGRESS) {\r\ninit_waitqueue_head(&ep->conn_pend_wq);\r\nspin_lock(&scif_info.nb_connect_lock);\r\nlist_add_tail(&ep->conn_list, &scif_info.nb_connect_list);\r\nspin_unlock(&scif_info.nb_connect_lock);\r\nerr = -EINPROGRESS;\r\nschedule_work(&scif_info.conn_work);\r\n}\r\nconnect_simple_unlock1:\r\nspin_unlock(&ep->lock);\r\nscif_put_peer_dev(spdev);\r\nif (err) {\r\nreturn err;\r\n} else if (ep->conn_async_state == ASYNC_CONN_FLUSH_WORK) {\r\nflush_work(&scif_info.conn_work);\r\nerr = ep->conn_err;\r\nspin_lock(&ep->lock);\r\nep->conn_async_state = ASYNC_CONN_IDLE;\r\nspin_unlock(&ep->lock);\r\n} else {\r\nerr = scif_conn_func(ep);\r\n}\r\nreturn err;\r\n}\r\nint scif_connect(scif_epd_t epd, struct scif_port_id *dst)\r\n{\r\nreturn __scif_connect(epd, dst, false);\r\n}\r\nint scif_accept(scif_epd_t epd, struct scif_port_id *peer,\r\nscif_epd_t *newepd, int flags)\r\n{\r\nstruct scif_endpt *lep = (struct scif_endpt *)epd;\r\nstruct scif_endpt *cep;\r\nstruct scif_conreq *conreq;\r\nstruct scifmsg msg;\r\nint err;\r\nstruct device *spdev;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI accept: ep %p %s\n", lep, scif_ep_states[lep->state]);\r\nif (flags & ~SCIF_ACCEPT_SYNC)\r\nreturn -EINVAL;\r\nif (!peer || !newepd)\r\nreturn -EINVAL;\r\nmight_sleep();\r\nspin_lock(&lep->lock);\r\nif (lep->state != SCIFEP_LISTENING) {\r\nspin_unlock(&lep->lock);\r\nreturn -EINVAL;\r\n}\r\nif (!lep->conreqcnt && !(flags & SCIF_ACCEPT_SYNC)) {\r\nspin_unlock(&lep->lock);\r\nreturn -EAGAIN;\r\n}\r\nlep->files = current->files;\r\nretry_connection:\r\nspin_unlock(&lep->lock);\r\nerr = wait_event_interruptible(lep->conwq,\r\n(lep->conreqcnt ||\r\n(lep->state != SCIFEP_LISTENING)));\r\nif (err)\r\nreturn err;\r\nif (lep->state != SCIFEP_LISTENING)\r\nreturn -EINTR;\r\nspin_lock(&lep->lock);\r\nif (!lep->conreqcnt)\r\ngoto retry_connection;\r\nconreq = list_first_entry(&lep->conlist, struct scif_conreq, list);\r\nlist_del(&conreq->list);\r\nlep->conreqcnt--;\r\nspin_unlock(&lep->lock);\r\npeer->node = conreq->msg.src.node;\r\npeer->port = conreq->msg.src.port;\r\ncep = kzalloc(sizeof(*cep), GFP_KERNEL);\r\nif (!cep) {\r\nerr = -ENOMEM;\r\ngoto scif_accept_error_epalloc;\r\n}\r\nspin_lock_init(&cep->lock);\r\nmutex_init(&cep->sendlock);\r\nmutex_init(&cep->recvlock);\r\ncep->state = SCIFEP_CONNECTING;\r\ncep->remote_dev = &scif_dev[peer->node];\r\ncep->remote_ep = conreq->msg.payload[0];\r\nscif_rma_ep_init(cep);\r\nerr = scif_reserve_dma_chan(cep);\r\nif (err) {\r\ndev_err(scif_info.mdev.this_device,\r\n"%s %d err %d\n", __func__, __LINE__, err);\r\ngoto scif_accept_error_qpalloc;\r\n}\r\ncep->qp_info.qp = kzalloc(sizeof(*cep->qp_info.qp), GFP_KERNEL);\r\nif (!cep->qp_info.qp) {\r\nerr = -ENOMEM;\r\ngoto scif_accept_error_qpalloc;\r\n}\r\nerr = scif_anon_inode_getfile(cep);\r\nif (err)\r\ngoto scif_accept_error_anon_inode;\r\ncep->qp_info.qp->magic = SCIFEP_MAGIC;\r\nspdev = scif_get_peer_dev(cep->remote_dev);\r\nif (IS_ERR(spdev)) {\r\nerr = PTR_ERR(spdev);\r\ngoto scif_accept_error_map;\r\n}\r\nerr = scif_setup_qp_accept(cep->qp_info.qp, &cep->qp_info.qp_offset,\r\nconreq->msg.payload[1], SCIF_ENDPT_QP_SIZE,\r\ncep->remote_dev);\r\nif (err) {\r\ndev_dbg(&cep->remote_dev->sdev->dev,\r\n"SCIFAPI accept: ep %p new %p scif_setup_qp_accept %d qp_offset 0x%llx\n",\r\nlep, cep, err, cep->qp_info.qp_offset);\r\nscif_put_peer_dev(spdev);\r\ngoto scif_accept_error_map;\r\n}\r\ncep->port.node = lep->port.node;\r\ncep->port.port = lep->port.port;\r\ncep->peer.node = peer->node;\r\ncep->peer.port = peer->port;\r\ninit_waitqueue_head(&cep->sendwq);\r\ninit_waitqueue_head(&cep->recvwq);\r\ninit_waitqueue_head(&cep->conwq);\r\nmsg.uop = SCIF_CNCT_GNT;\r\nmsg.src = cep->port;\r\nmsg.payload[0] = cep->remote_ep;\r\nmsg.payload[1] = cep->qp_info.qp_offset;\r\nmsg.payload[2] = (u64)cep;\r\nerr = _scif_nodeqp_send(cep->remote_dev, &msg);\r\nscif_put_peer_dev(spdev);\r\nif (err)\r\ngoto scif_accept_error_map;\r\nretry:\r\nerr = wait_event_timeout(cep->conwq, cep->state != SCIFEP_CONNECTING,\r\nSCIF_NODE_ACCEPT_TIMEOUT);\r\nif (!err && scifdev_alive(cep))\r\ngoto retry;\r\nerr = !err ? -ENODEV : 0;\r\nif (err)\r\ngoto scif_accept_error_map;\r\nkfree(conreq);\r\nspin_lock(&cep->lock);\r\nif (cep->state == SCIFEP_CLOSING) {\r\nspin_unlock(&cep->lock);\r\nscif_teardown_ep(cep);\r\nkfree(cep);\r\nif (flags & SCIF_ACCEPT_SYNC) {\r\nspin_lock(&lep->lock);\r\ngoto retry_connection;\r\n}\r\nreturn -EAGAIN;\r\n}\r\nscif_get_port(cep->port.port);\r\n*newepd = (scif_epd_t)cep;\r\nspin_unlock(&cep->lock);\r\nreturn 0;\r\nscif_accept_error_map:\r\nscif_anon_inode_fput(cep);\r\nscif_accept_error_anon_inode:\r\nscif_teardown_ep(cep);\r\nscif_accept_error_qpalloc:\r\nkfree(cep);\r\nscif_accept_error_epalloc:\r\nmsg.uop = SCIF_CNCT_REJ;\r\nmsg.dst.node = conreq->msg.src.node;\r\nmsg.dst.port = conreq->msg.src.port;\r\nmsg.payload[0] = conreq->msg.payload[0];\r\nmsg.payload[1] = conreq->msg.payload[1];\r\nscif_nodeqp_send(&scif_dev[conreq->msg.src.node], &msg);\r\nkfree(conreq);\r\nreturn err;\r\n}\r\nstatic inline int scif_msg_param_check(scif_epd_t epd, int len, int flags)\r\n{\r\nint ret = -EINVAL;\r\nif (len < 0)\r\ngoto err_ret;\r\nif (flags && (!(flags & SCIF_RECV_BLOCK)))\r\ngoto err_ret;\r\nret = 0;\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic int _scif_send(scif_epd_t epd, void *msg, int len, int flags)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct scifmsg notif_msg;\r\nint curr_xfer_len = 0, sent_len = 0, write_count;\r\nint ret = 0;\r\nstruct scif_qp *qp = ep->qp_info.qp;\r\nif (flags & SCIF_SEND_BLOCK)\r\nmight_sleep();\r\nspin_lock(&ep->lock);\r\nwhile (sent_len != len && SCIFEP_CONNECTED == ep->state) {\r\nwrite_count = scif_rb_space(&qp->outbound_q);\r\nif (write_count) {\r\ncurr_xfer_len = min(len - sent_len, write_count);\r\nret = scif_rb_write(&qp->outbound_q, msg,\r\ncurr_xfer_len);\r\nif (ret < 0)\r\nbreak;\r\nscif_rb_commit(&qp->outbound_q);\r\nnotif_msg.src = ep->port;\r\nnotif_msg.uop = SCIF_CLIENT_SENT;\r\nnotif_msg.payload[0] = ep->remote_ep;\r\nret = _scif_nodeqp_send(ep->remote_dev, &notif_msg);\r\nif (ret)\r\nbreak;\r\nsent_len += curr_xfer_len;\r\nmsg = msg + curr_xfer_len;\r\ncontinue;\r\n}\r\ncurr_xfer_len = min(len - sent_len, SCIF_ENDPT_QP_SIZE - 1);\r\nif (!(flags & SCIF_SEND_BLOCK))\r\nbreak;\r\nspin_unlock(&ep->lock);\r\nret =\r\nwait_event_interruptible(ep->sendwq,\r\n(SCIFEP_CONNECTED != ep->state) ||\r\n(scif_rb_space(&qp->outbound_q) >=\r\ncurr_xfer_len));\r\nspin_lock(&ep->lock);\r\nif (ret)\r\nbreak;\r\n}\r\nif (sent_len)\r\nret = sent_len;\r\nelse if (!ret && SCIFEP_CONNECTED != ep->state)\r\nret = SCIFEP_DISCONNECTED == ep->state ?\r\n-ECONNRESET : -ENOTCONN;\r\nspin_unlock(&ep->lock);\r\nreturn ret;\r\n}\r\nstatic int _scif_recv(scif_epd_t epd, void *msg, int len, int flags)\r\n{\r\nint read_size;\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nstruct scifmsg notif_msg;\r\nint curr_recv_len = 0, remaining_len = len, read_count;\r\nint ret = 0;\r\nstruct scif_qp *qp = ep->qp_info.qp;\r\nif (flags & SCIF_RECV_BLOCK)\r\nmight_sleep();\r\nspin_lock(&ep->lock);\r\nwhile (remaining_len && (SCIFEP_CONNECTED == ep->state ||\r\nSCIFEP_DISCONNECTED == ep->state)) {\r\nread_count = scif_rb_count(&qp->inbound_q, remaining_len);\r\nif (read_count) {\r\ncurr_recv_len = min(remaining_len, read_count);\r\nread_size = scif_rb_get_next(&qp->inbound_q,\r\nmsg, curr_recv_len);\r\nif (ep->state == SCIFEP_CONNECTED) {\r\nscif_rb_update_read_ptr(&qp->inbound_q);\r\nnotif_msg.src = ep->port;\r\nnotif_msg.uop = SCIF_CLIENT_RCVD;\r\nnotif_msg.payload[0] = ep->remote_ep;\r\nret = _scif_nodeqp_send(ep->remote_dev,\r\n&notif_msg);\r\nif (ret)\r\nbreak;\r\n}\r\nremaining_len -= curr_recv_len;\r\nmsg = msg + curr_recv_len;\r\ncontinue;\r\n}\r\nif (ep->state == SCIFEP_DISCONNECTED)\r\nbreak;\r\nif (!(flags & SCIF_RECV_BLOCK))\r\nbreak;\r\ncurr_recv_len = min(remaining_len, SCIF_ENDPT_QP_SIZE - 1);\r\nspin_unlock(&ep->lock);\r\nret =\r\nwait_event_interruptible(ep->recvwq,\r\nSCIFEP_CONNECTED != ep->state ||\r\nscif_rb_count(&qp->inbound_q,\r\ncurr_recv_len)\r\n>= curr_recv_len);\r\nspin_lock(&ep->lock);\r\nif (ret)\r\nbreak;\r\n}\r\nif (len - remaining_len)\r\nret = len - remaining_len;\r\nelse if (!ret && ep->state != SCIFEP_CONNECTED)\r\nret = ep->state == SCIFEP_DISCONNECTED ?\r\n-ECONNRESET : -ENOTCONN;\r\nspin_unlock(&ep->lock);\r\nreturn ret;\r\n}\r\nint scif_user_send(scif_epd_t epd, void __user *msg, int len, int flags)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint err = 0;\r\nint sent_len = 0;\r\nchar *tmp;\r\nint loop_len;\r\nint chunk_len = min(len, (1 << (MAX_ORDER + PAGE_SHIFT - 1)));\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI send (U): ep %p %s\n", ep, scif_ep_states[ep->state]);\r\nif (!len)\r\nreturn 0;\r\nerr = scif_msg_param_check(epd, len, flags);\r\nif (err)\r\ngoto send_err;\r\ntmp = kmalloc(chunk_len, GFP_KERNEL);\r\nif (!tmp) {\r\nerr = -ENOMEM;\r\ngoto send_err;\r\n}\r\nmutex_lock(&ep->sendlock);\r\nwhile (sent_len != len) {\r\nloop_len = len - sent_len;\r\nloop_len = min(chunk_len, loop_len);\r\nif (copy_from_user(tmp, msg, loop_len)) {\r\nerr = -EFAULT;\r\ngoto send_free_err;\r\n}\r\nerr = _scif_send(epd, tmp, loop_len, flags);\r\nif (err < 0)\r\ngoto send_free_err;\r\nsent_len += err;\r\nmsg += err;\r\nif (err != loop_len)\r\ngoto send_free_err;\r\n}\r\nsend_free_err:\r\nmutex_unlock(&ep->sendlock);\r\nkfree(tmp);\r\nsend_err:\r\nreturn err < 0 ? err : sent_len;\r\n}\r\nint scif_user_recv(scif_epd_t epd, void __user *msg, int len, int flags)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint err = 0;\r\nint recv_len = 0;\r\nchar *tmp;\r\nint loop_len;\r\nint chunk_len = min(len, (1 << (MAX_ORDER + PAGE_SHIFT - 1)));\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI recv (U): ep %p %s\n", ep, scif_ep_states[ep->state]);\r\nif (!len)\r\nreturn 0;\r\nerr = scif_msg_param_check(epd, len, flags);\r\nif (err)\r\ngoto recv_err;\r\ntmp = kmalloc(chunk_len, GFP_KERNEL);\r\nif (!tmp) {\r\nerr = -ENOMEM;\r\ngoto recv_err;\r\n}\r\nmutex_lock(&ep->recvlock);\r\nwhile (recv_len != len) {\r\nloop_len = len - recv_len;\r\nloop_len = min(chunk_len, loop_len);\r\nerr = _scif_recv(epd, tmp, loop_len, flags);\r\nif (err < 0)\r\ngoto recv_free_err;\r\nif (copy_to_user(msg, tmp, err)) {\r\nerr = -EFAULT;\r\ngoto recv_free_err;\r\n}\r\nrecv_len += err;\r\nmsg += err;\r\nif (err != loop_len)\r\ngoto recv_free_err;\r\n}\r\nrecv_free_err:\r\nmutex_unlock(&ep->recvlock);\r\nkfree(tmp);\r\nrecv_err:\r\nreturn err < 0 ? err : recv_len;\r\n}\r\nint scif_send(scif_epd_t epd, void *msg, int len, int flags)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint ret;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI send (K): ep %p %s\n", ep, scif_ep_states[ep->state]);\r\nif (!len)\r\nreturn 0;\r\nret = scif_msg_param_check(epd, len, flags);\r\nif (ret)\r\nreturn ret;\r\nif (!ep->remote_dev)\r\nreturn -ENOTCONN;\r\nif (flags & SCIF_SEND_BLOCK)\r\nmutex_lock(&ep->sendlock);\r\nret = _scif_send(epd, msg, len, flags);\r\nif (flags & SCIF_SEND_BLOCK)\r\nmutex_unlock(&ep->sendlock);\r\nreturn ret;\r\n}\r\nint scif_recv(scif_epd_t epd, void *msg, int len, int flags)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)epd;\r\nint ret;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI recv (K): ep %p %s\n", ep, scif_ep_states[ep->state]);\r\nif (!len)\r\nreturn 0;\r\nret = scif_msg_param_check(epd, len, flags);\r\nif (ret)\r\nreturn ret;\r\nif (flags & SCIF_RECV_BLOCK)\r\nmutex_lock(&ep->recvlock);\r\nret = _scif_recv(epd, msg, len, flags);\r\nif (flags & SCIF_RECV_BLOCK)\r\nmutex_unlock(&ep->recvlock);\r\nreturn ret;\r\n}\r\nstatic inline void _scif_poll_wait(struct file *f, wait_queue_head_t *wq,\r\npoll_table *p, struct scif_endpt *ep)\r\n{\r\nspin_unlock(&ep->lock);\r\npoll_wait(f, wq, p);\r\nspin_lock(&ep->lock);\r\n}\r\nunsigned int\r\n__scif_pollfd(struct file *f, poll_table *wait, struct scif_endpt *ep)\r\n{\r\nunsigned int mask = 0;\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI pollfd: ep %p %s\n", ep, scif_ep_states[ep->state]);\r\nspin_lock(&ep->lock);\r\nif (ep->conn_async_state == ASYNC_CONN_INPROGRESS) {\r\n_scif_poll_wait(f, &ep->conn_pend_wq, wait, ep);\r\nif (ep->conn_async_state == ASYNC_CONN_INPROGRESS) {\r\nif (ep->state == SCIFEP_CONNECTED ||\r\nep->state == SCIFEP_DISCONNECTED ||\r\nep->conn_err)\r\nmask |= POLLOUT;\r\ngoto exit;\r\n}\r\n}\r\nif (ep->state == SCIFEP_LISTENING) {\r\n_scif_poll_wait(f, &ep->conwq, wait, ep);\r\nif (ep->state == SCIFEP_LISTENING) {\r\nif (ep->conreqcnt)\r\nmask |= POLLIN;\r\ngoto exit;\r\n}\r\n}\r\nif (ep->state == SCIFEP_CONNECTED || ep->state == SCIFEP_DISCONNECTED) {\r\nif (poll_requested_events(wait) & POLLIN)\r\n_scif_poll_wait(f, &ep->recvwq, wait, ep);\r\nif (poll_requested_events(wait) & POLLOUT)\r\n_scif_poll_wait(f, &ep->sendwq, wait, ep);\r\nif (ep->state == SCIFEP_CONNECTED ||\r\nep->state == SCIFEP_DISCONNECTED) {\r\nif (scif_rb_count(&ep->qp_info.qp->inbound_q, 1))\r\nmask |= POLLIN;\r\nif (scif_rb_space(&ep->qp_info.qp->outbound_q))\r\nmask |= POLLOUT;\r\nif (ep->state == SCIFEP_DISCONNECTED)\r\nmask |= POLLHUP;\r\ngoto exit;\r\n}\r\n}\r\nmask |= POLLERR;\r\nexit:\r\nspin_unlock(&ep->lock);\r\nreturn mask;\r\n}\r\nint\r\nscif_poll(struct scif_pollepd *ufds, unsigned int nfds, long timeout_msecs)\r\n{\r\nstruct poll_wqueues table;\r\npoll_table *pt;\r\nint i, mask, count = 0, timed_out = timeout_msecs == 0;\r\nu64 timeout = timeout_msecs < 0 ? MAX_SCHEDULE_TIMEOUT\r\n: msecs_to_jiffies(timeout_msecs);\r\npoll_initwait(&table);\r\npt = &table.pt;\r\nwhile (1) {\r\nfor (i = 0; i < nfds; i++) {\r\npt->_key = ufds[i].events | POLLERR | POLLHUP;\r\nmask = __scif_pollfd(ufds[i].epd->anon,\r\npt, ufds[i].epd);\r\nmask &= ufds[i].events | POLLERR | POLLHUP;\r\nif (mask) {\r\ncount++;\r\npt->_qproc = NULL;\r\n}\r\nufds[i].revents = mask;\r\n}\r\npt->_qproc = NULL;\r\nif (!count) {\r\ncount = table.error;\r\nif (signal_pending(current))\r\ncount = -EINTR;\r\n}\r\nif (count || timed_out)\r\nbreak;\r\nif (!schedule_timeout_interruptible(timeout))\r\ntimed_out = 1;\r\n}\r\npoll_freewait(&table);\r\nreturn count;\r\n}\r\nint scif_get_node_ids(u16 *nodes, int len, u16 *self)\r\n{\r\nint online = 0;\r\nint offset = 0;\r\nint node;\r\nif (!scif_is_mgmt_node())\r\nscif_get_node_info();\r\n*self = scif_info.nodeid;\r\nmutex_lock(&scif_info.conflock);\r\nlen = min_t(int, len, scif_info.total);\r\nfor (node = 0; node <= scif_info.maxid; node++) {\r\nif (_scifdev_alive(&scif_dev[node])) {\r\nonline++;\r\nif (offset < len)\r\nnodes[offset++] = node;\r\n}\r\n}\r\ndev_dbg(scif_info.mdev.this_device,\r\n"SCIFAPI get_node_ids total %d online %d filled in %d nodes\n",\r\nscif_info.total, online, offset);\r\nmutex_unlock(&scif_info.conflock);\r\nreturn online;\r\n}\r\nstatic int scif_add_client_dev(struct device *dev, struct subsys_interface *si)\r\n{\r\nstruct scif_client *client =\r\ncontainer_of(si, struct scif_client, si);\r\nstruct scif_peer_dev *spdev =\r\ncontainer_of(dev, struct scif_peer_dev, dev);\r\nif (client->probe)\r\nclient->probe(spdev);\r\nreturn 0;\r\n}\r\nstatic void scif_remove_client_dev(struct device *dev,\r\nstruct subsys_interface *si)\r\n{\r\nstruct scif_client *client =\r\ncontainer_of(si, struct scif_client, si);\r\nstruct scif_peer_dev *spdev =\r\ncontainer_of(dev, struct scif_peer_dev, dev);\r\nif (client->remove)\r\nclient->remove(spdev);\r\n}\r\nvoid scif_client_unregister(struct scif_client *client)\r\n{\r\nsubsys_interface_unregister(&client->si);\r\n}\r\nint scif_client_register(struct scif_client *client)\r\n{\r\nstruct subsys_interface *si = &client->si;\r\nsi->name = client->name;\r\nsi->subsys = &scif_peer_bus;\r\nsi->add_dev = scif_add_client_dev;\r\nsi->remove_dev = scif_remove_client_dev;\r\nreturn subsys_interface_register(&client->si);\r\n}
