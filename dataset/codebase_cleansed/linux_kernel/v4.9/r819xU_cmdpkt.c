rt_status SendTxCommandPacket(struct net_device *dev, void *pData, u32 DataLen)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct sk_buff *skb;\r\ncb_desc *tcb_desc;\r\nunsigned char *ptr_buf;\r\nskb = dev_alloc_skb(USB_HWDESC_HEADER_LEN + DataLen + 4);\r\nif (!skb)\r\nreturn RT_STATUS_FAILURE;\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\ntcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;\r\ntcb_desc->bLastIniPkt = 0;\r\nskb_reserve(skb, USB_HWDESC_HEADER_LEN);\r\nptr_buf = skb_put(skb, DataLen);\r\nmemcpy(ptr_buf, pData, DataLen);\r\ntcb_desc->txbuf_size = (u16)DataLen;\r\nif (!priv->ieee80211->check_nic_enough_desc(dev, tcb_desc->queue_index) ||\r\n(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index])) ||\r\n(priv->ieee80211->queue_stop)) {\r\nRT_TRACE(COMP_FIRMWARE, "=== NULL packet ======> tx full!\n");\r\nskb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);\r\n} else {\r\npriv->ieee80211->softmac_hard_start_xmit(skb, dev);\r\n}\r\nreturn RT_STATUS_SUCCESS;\r\n}\r\nstatic void cmpk_count_txstatistic(struct net_device *dev, cmpk_txfb_t *pstx_fb)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\n#ifdef ENABLE_PS\r\nRT_RF_POWER_STATE rtState;\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\r\n(pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\nreturn;\r\n#endif\r\n#ifdef TODO\r\nif (pAdapter->bInHctTest)\r\nreturn;\r\n#endif\r\nif (pstx_fb->tok) {\r\npriv->stats.txfeedbackok++;\r\npriv->stats.txoktotal++;\r\npriv->stats.txokbytestotal += pstx_fb->pkt_length;\r\npriv->stats.txokinperiod++;\r\nif (pstx_fb->pkt_type == PACKET_MULTICAST) {\r\npriv->stats.txmulticast++;\r\npriv->stats.txbytesmulticast += pstx_fb->pkt_length;\r\n} else if (pstx_fb->pkt_type == PACKET_BROADCAST) {\r\npriv->stats.txbroadcast++;\r\npriv->stats.txbytesbroadcast += pstx_fb->pkt_length;\r\n} else {\r\npriv->stats.txunicast++;\r\npriv->stats.txbytesunicast += pstx_fb->pkt_length;\r\n}\r\n} else {\r\npriv->stats.txfeedbackfail++;\r\npriv->stats.txerrtotal++;\r\npriv->stats.txerrbytestotal += pstx_fb->pkt_length;\r\nif (pstx_fb->pkt_type == PACKET_MULTICAST)\r\npriv->stats.txerrmulticast++;\r\nelse if (pstx_fb->pkt_type == PACKET_BROADCAST)\r\npriv->stats.txerrbroadcast++;\r\nelse\r\npriv->stats.txerrunicast++;\r\n}\r\npriv->stats.txretrycount += pstx_fb->retry_cnt;\r\npriv->stats.txfeedbackretry += pstx_fb->retry_cnt;\r\n}\r\nstatic void cmpk_handle_tx_feedback(struct net_device *dev, u8 *pmsg)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\ncmpk_txfb_t rx_tx_fb;\r\npriv->stats.txfeedback++;\r\nmemcpy((u8 *)&rx_tx_fb, pmsg, sizeof(cmpk_txfb_t));\r\ncmpk_count_txstatistic(dev, &rx_tx_fb);\r\n}\r\nstatic void cmdpkt_beacontimerinterrupt_819xusb(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu16 tx_rate;\r\nif (priv->ieee80211->current_network.mode == IEEE_A ||\r\npriv->ieee80211->current_network.mode == IEEE_N_5G ||\r\n(priv->ieee80211->current_network.mode == IEEE_N_24G &&\r\n(!priv->ieee80211->pHTInfo->bCurSuppCCK))) {\r\ntx_rate = 60;\r\nDMESG("send beacon frame tx rate is 6Mbpm\n");\r\n} else {\r\ntx_rate = 10;\r\nDMESG("send beacon frame tx rate is 1Mbpm\n");\r\n}\r\nrtl819xusb_beacon_tx(dev, tx_rate);\r\n}\r\nstatic void cmpk_handle_interrupt_status(struct net_device *dev, u8 *pmsg)\r\n{\r\ncmpk_intr_sta_t rx_intr_status;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nDMESG("---> cmpk_Handle_Interrupt_Status()\n");\r\nrx_intr_status.length = pmsg[1];\r\nif (rx_intr_status.length != (sizeof(cmpk_intr_sta_t) - 2)) {\r\nDMESG("cmpk_Handle_Interrupt_Status: wrong length!\n");\r\nreturn;\r\n}\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC) {\r\nrx_intr_status.interrupt_status = *((u32 *)(pmsg + 4));\r\nDMESG("interrupt status = 0x%x\n",\r\nrx_intr_status.interrupt_status);\r\nif (rx_intr_status.interrupt_status & ISR_TxBcnOk) {\r\npriv->ieee80211->bibsscoordinator = true;\r\npriv->stats.txbeaconokint++;\r\n} else if (rx_intr_status.interrupt_status & ISR_TxBcnErr) {\r\npriv->ieee80211->bibsscoordinator = false;\r\npriv->stats.txbeaconerr++;\r\n}\r\nif (rx_intr_status.interrupt_status & ISR_BcnTimerIntr)\r\ncmdpkt_beacontimerinterrupt_819xusb(dev);\r\n}\r\nDMESG("<---- cmpk_handle_interrupt_status()\n");\r\n}\r\nstatic void cmpk_handle_query_config_rx(struct net_device *dev, u8 *pmsg)\r\n{\r\ncmpk_query_cfg_t rx_query_cfg;\r\nrx_query_cfg.cfg_action = (pmsg[4] & 0x80000000) >> 31;\r\nrx_query_cfg.cfg_type = (pmsg[4] & 0x60) >> 5;\r\nrx_query_cfg.cfg_size = (pmsg[4] & 0x18) >> 3;\r\nrx_query_cfg.cfg_page = (pmsg[6] & 0x0F) >> 0;\r\nrx_query_cfg.cfg_offset = pmsg[7];\r\nrx_query_cfg.value = (pmsg[8] << 24) | (pmsg[9] << 16) |\r\n(pmsg[10] << 8) | (pmsg[11] << 0);\r\nrx_query_cfg.mask = (pmsg[12] << 24) | (pmsg[13] << 16) |\r\n(pmsg[14] << 8) | (pmsg[15] << 0);\r\n}\r\nstatic void cmpk_count_tx_status(struct net_device *dev,\r\ncmpk_tx_status_t *pstx_status)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\n#ifdef ENABLE_PS\r\nRT_RF_POWER_STATE rtstate;\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\r\n(pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\nreturn;\r\n#endif\r\npriv->stats.txfeedbackok += pstx_status->txok;\r\npriv->stats.txoktotal += pstx_status->txok;\r\npriv->stats.txfeedbackfail += pstx_status->txfail;\r\npriv->stats.txerrtotal += pstx_status->txfail;\r\npriv->stats.txretrycount += pstx_status->txretry;\r\npriv->stats.txfeedbackretry += pstx_status->txretry;\r\npriv->stats.txmulticast += pstx_status->txmcok;\r\npriv->stats.txbroadcast += pstx_status->txbcok;\r\npriv->stats.txunicast += pstx_status->txucok;\r\npriv->stats.txerrmulticast += pstx_status->txmcfail;\r\npriv->stats.txerrbroadcast += pstx_status->txbcfail;\r\npriv->stats.txerrunicast += pstx_status->txucfail;\r\npriv->stats.txbytesmulticast += pstx_status->txmclength;\r\npriv->stats.txbytesbroadcast += pstx_status->txbclength;\r\npriv->stats.txbytesunicast += pstx_status->txuclength;\r\npriv->stats.last_packet_rate = pstx_status->rate;\r\n}\r\nstatic void cmpk_handle_tx_status(struct net_device *dev, u8 *pmsg)\r\n{\r\ncmpk_tx_status_t rx_tx_sts;\r\nmemcpy((void *)&rx_tx_sts, (void *)pmsg, sizeof(cmpk_tx_status_t));\r\ncmpk_count_tx_status(dev, &rx_tx_sts);\r\n}\r\nstatic void cmpk_handle_tx_rate_history(struct net_device *dev, u8 *pmsg)\r\n{\r\ncmpk_tx_rahis_t *ptxrate;\r\nu8 i, j;\r\nu16 length = sizeof(cmpk_tx_rahis_t);\r\nu32 *ptemp;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\n#ifdef ENABLE_PS\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\r\n(pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\nreturn;\r\n#endif\r\nptemp = (u32 *)pmsg;\r\nfor (i = 0; i < (length/4); i++) {\r\nu16 temp1, temp2;\r\ntemp1 = ptemp[i] & 0x0000FFFF;\r\ntemp2 = ptemp[i] >> 16;\r\nptemp[i] = (temp1 << 16) | temp2;\r\n}\r\nptxrate = (cmpk_tx_rahis_t *)pmsg;\r\nif (ptxrate == NULL)\r\nreturn;\r\nfor (i = 0; i < 16; i++) {\r\nif (i < 4)\r\npriv->stats.txrate.cck[i] += ptxrate->cck[i];\r\nif (i < 8)\r\npriv->stats.txrate.ofdm[i] += ptxrate->ofdm[i];\r\nfor (j = 0; j < 4; j++)\r\npriv->stats.txrate.ht_mcs[j][i] += ptxrate->ht_mcs[j][i];\r\n}\r\n}\r\nu32 cmpk_message_handle_rx(struct net_device *dev,\r\nstruct ieee80211_rx_stats *pstats)\r\n{\r\nint total_length;\r\nu8 cmd_length, exe_cnt = 0;\r\nu8 element_id;\r\nu8 *pcmd_buff;\r\nif (pstats == NULL)\r\nreturn 0;\r\ntotal_length = pstats->Length;\r\npcmd_buff = pstats->virtual_address;\r\nelement_id = pcmd_buff[0];\r\nwhile (total_length > 0 && exe_cnt++ < 100) {\r\nelement_id = pcmd_buff[0];\r\nswitch (element_id) {\r\ncase RX_TX_FEEDBACK:\r\ncmpk_handle_tx_feedback(dev, pcmd_buff);\r\ncmd_length = CMPK_RX_TX_FB_SIZE;\r\nbreak;\r\ncase RX_INTERRUPT_STATUS:\r\ncmpk_handle_interrupt_status(dev, pcmd_buff);\r\ncmd_length = sizeof(cmpk_intr_sta_t);\r\nbreak;\r\ncase BOTH_QUERY_CONFIG:\r\ncmpk_handle_query_config_rx(dev, pcmd_buff);\r\ncmd_length = CMPK_BOTH_QUERY_CONFIG_SIZE;\r\nbreak;\r\ncase RX_TX_STATUS:\r\ncmpk_handle_tx_status(dev, pcmd_buff);\r\ncmd_length = CMPK_RX_TX_STS_SIZE;\r\nbreak;\r\ncase RX_TX_PER_PKT_FEEDBACK:\r\ncmd_length = CMPK_RX_TX_FB_SIZE;\r\nbreak;\r\ncase RX_TX_RATE_HISTORY:\r\ncmpk_handle_tx_rate_history(dev, pcmd_buff);\r\ncmd_length = CMPK_TX_RAHIS_SIZE;\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "---->%s():unknown CMD Element\n",\r\n__func__);\r\nreturn 1;\r\n}\r\ntotal_length -= cmd_length;\r\npcmd_buff += cmd_length;\r\n}\r\nreturn 1;\r\n}
