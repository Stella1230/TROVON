static s32 e1000_init_phy_params_82571(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nif (hw->phy.media_type != e1000_media_type_copper) {\r\nphy->type = e1000_phy_none;\r\nreturn 0;\r\n}\r\nphy->addr = 1;\r\nphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\r\nphy->reset_delay_us = 100;\r\nphy->ops.power_up = e1000_power_up_phy_copper;\r\nphy->ops.power_down = e1000_power_down_phy_copper_82571;\r\nswitch (hw->mac.type) {\r\ncase e1000_82571:\r\ncase e1000_82572:\r\nphy->type = e1000_phy_igp_2;\r\nbreak;\r\ncase e1000_82573:\r\nphy->type = e1000_phy_m88;\r\nbreak;\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nphy->type = e1000_phy_bm;\r\nphy->ops.acquire = e1000_get_hw_semaphore_82574;\r\nphy->ops.release = e1000_put_hw_semaphore_82574;\r\nphy->ops.set_d0_lplu_state = e1000_set_d0_lplu_state_82574;\r\nphy->ops.set_d3_lplu_state = e1000_set_d3_lplu_state_82574;\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_PHY;\r\n}\r\nret_val = e1000_get_phy_id_82571(hw);\r\nif (ret_val) {\r\ne_dbg("Error getting PHY ID\n");\r\nreturn ret_val;\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_82571:\r\ncase e1000_82572:\r\nif (phy->id != IGP01E1000_I_PHY_ID)\r\nret_val = -E1000_ERR_PHY;\r\nbreak;\r\ncase e1000_82573:\r\nif (phy->id != M88E1111_I_PHY_ID)\r\nret_val = -E1000_ERR_PHY;\r\nbreak;\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nif (phy->id != BME1000_E_PHY_ID_R2)\r\nret_val = -E1000_ERR_PHY;\r\nbreak;\r\ndefault:\r\nret_val = -E1000_ERR_PHY;\r\nbreak;\r\n}\r\nif (ret_val)\r\ne_dbg("PHY ID unknown: type = 0x%08x\n", phy->id);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_init_nvm_params_82571(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = er32(EECD);\r\nu16 size;\r\nnvm->opcode_bits = 8;\r\nnvm->delay_usec = 1;\r\nswitch (nvm->override) {\r\ncase e1000_nvm_override_spi_large:\r\nnvm->page_size = 32;\r\nnvm->address_bits = 16;\r\nbreak;\r\ncase e1000_nvm_override_spi_small:\r\nnvm->page_size = 8;\r\nnvm->address_bits = 8;\r\nbreak;\r\ndefault:\r\nnvm->page_size = eecd & E1000_EECD_ADDR_BITS ? 32 : 8;\r\nnvm->address_bits = eecd & E1000_EECD_ADDR_BITS ? 16 : 8;\r\nbreak;\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nif (((eecd >> 15) & 0x3) == 0x3) {\r\nnvm->type = e1000_nvm_flash_hw;\r\nnvm->word_size = 2048;\r\neecd &= ~E1000_EECD_AUPDEN;\r\new32(EECD, eecd);\r\nbreak;\r\n}\r\ndefault:\r\nnvm->type = e1000_nvm_eeprom_spi;\r\nsize = (u16)((eecd & E1000_EECD_SIZE_EX_MASK) >>\r\nE1000_EECD_SIZE_EX_SHIFT);\r\nsize += NVM_WORD_SIZE_BASE_SHIFT;\r\nif (size > 14)\r\nsize = 14;\r\nnvm->word_size = BIT(size);\r\nbreak;\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nnvm->ops.acquire = e1000_get_hw_semaphore_82574;\r\nnvm->ops.release = e1000_put_hw_semaphore_82574;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_init_mac_params_82571(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nu32 swsm = 0;\r\nu32 swsm2 = 0;\r\nbool force_clear_smbi = false;\r\nswitch (hw->adapter->pdev->device) {\r\ncase E1000_DEV_ID_82571EB_FIBER:\r\ncase E1000_DEV_ID_82572EI_FIBER:\r\ncase E1000_DEV_ID_82571EB_QUAD_FIBER:\r\nhw->phy.media_type = e1000_media_type_fiber;\r\nmac->ops.setup_physical_interface =\r\ne1000_setup_fiber_serdes_link_82571;\r\nmac->ops.check_for_link = e1000e_check_for_fiber_link;\r\nmac->ops.get_link_up_info =\r\ne1000e_get_speed_and_duplex_fiber_serdes;\r\nbreak;\r\ncase E1000_DEV_ID_82571EB_SERDES:\r\ncase E1000_DEV_ID_82571EB_SERDES_DUAL:\r\ncase E1000_DEV_ID_82571EB_SERDES_QUAD:\r\ncase E1000_DEV_ID_82572EI_SERDES:\r\nhw->phy.media_type = e1000_media_type_internal_serdes;\r\nmac->ops.setup_physical_interface =\r\ne1000_setup_fiber_serdes_link_82571;\r\nmac->ops.check_for_link = e1000_check_for_serdes_link_82571;\r\nmac->ops.get_link_up_info =\r\ne1000e_get_speed_and_duplex_fiber_serdes;\r\nbreak;\r\ndefault:\r\nhw->phy.media_type = e1000_media_type_copper;\r\nmac->ops.setup_physical_interface =\r\ne1000_setup_copper_link_82571;\r\nmac->ops.check_for_link = e1000e_check_for_copper_link;\r\nmac->ops.get_link_up_info = e1000e_get_speed_and_duplex_copper;\r\nbreak;\r\n}\r\nmac->mta_reg_count = 128;\r\nmac->rar_entry_count = E1000_RAR_ENTRIES;\r\nmac->adaptive_ifs = true;\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\nmac->ops.set_lan_id = e1000_set_lan_id_single_port;\r\nmac->ops.check_mng_mode = e1000e_check_mng_mode_generic;\r\nmac->ops.led_on = e1000e_led_on_generic;\r\nmac->ops.blink_led = e1000e_blink_led_generic;\r\nmac->has_fwsm = true;\r\nmac->arc_subsystem_valid = !!(er32(FWSM) &\r\nE1000_FWSM_MODE_MASK);\r\nbreak;\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nmac->ops.set_lan_id = e1000_set_lan_id_single_port;\r\nmac->ops.check_mng_mode = e1000_check_mng_mode_82574;\r\nmac->ops.led_on = e1000_led_on_82574;\r\nbreak;\r\ndefault:\r\nmac->ops.check_mng_mode = e1000e_check_mng_mode_generic;\r\nmac->ops.led_on = e1000e_led_on_generic;\r\nmac->ops.blink_led = e1000e_blink_led_generic;\r\nmac->has_fwsm = true;\r\nbreak;\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_82571:\r\ncase e1000_82572:\r\nswsm2 = er32(SWSM2);\r\nif (!(swsm2 & E1000_SWSM2_LOCK)) {\r\new32(SWSM2, swsm2 | E1000_SWSM2_LOCK);\r\nforce_clear_smbi = true;\r\n} else {\r\nforce_clear_smbi = false;\r\n}\r\nbreak;\r\ndefault:\r\nforce_clear_smbi = true;\r\nbreak;\r\n}\r\nif (force_clear_smbi) {\r\nswsm = er32(SWSM);\r\nif (swsm & E1000_SWSM_SMBI) {\r\ne_dbg("Please update your 82571 Bootagent\n");\r\n}\r\new32(SWSM, swsm & ~E1000_SWSM_SMBI);\r\n}\r\nhw->dev_spec.e82571.smb_counter = 0;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_get_variants_82571(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstatic int global_quad_port_a;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint is_port_b = er32(STATUS) & E1000_STATUS_FUNC_1;\r\ns32 rc;\r\nrc = e1000_init_mac_params_82571(hw);\r\nif (rc)\r\nreturn rc;\r\nrc = e1000_init_nvm_params_82571(hw);\r\nif (rc)\r\nreturn rc;\r\nrc = e1000_init_phy_params_82571(hw);\r\nif (rc)\r\nreturn rc;\r\nswitch (pdev->device) {\r\ncase E1000_DEV_ID_82571EB_QUAD_COPPER:\r\ncase E1000_DEV_ID_82571EB_QUAD_FIBER:\r\ncase E1000_DEV_ID_82571EB_QUAD_COPPER_LP:\r\ncase E1000_DEV_ID_82571PT_QUAD_COPPER:\r\nadapter->flags |= FLAG_IS_QUAD_PORT;\r\nif (global_quad_port_a == 0)\r\nadapter->flags |= FLAG_IS_QUAD_PORT_A;\r\nglobal_quad_port_a++;\r\nif (global_quad_port_a == 4)\r\nglobal_quad_port_a = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (adapter->hw.mac.type) {\r\ncase e1000_82571:\r\nif (((pdev->device == E1000_DEV_ID_82571EB_FIBER) ||\r\n(pdev->device == E1000_DEV_ID_82571EB_SERDES) ||\r\n(pdev->device == E1000_DEV_ID_82571EB_COPPER)) &&\r\n(is_port_b))\r\nadapter->flags &= ~FLAG_HAS_WOL;\r\nif (adapter->flags & FLAG_IS_QUAD_PORT &&\r\n(!(adapter->flags & FLAG_IS_QUAD_PORT_A)))\r\nadapter->flags &= ~FLAG_HAS_WOL;\r\nif (pdev->device == E1000_DEV_ID_82571EB_SERDES_QUAD)\r\nadapter->flags &= ~FLAG_HAS_WOL;\r\nbreak;\r\ncase e1000_82573:\r\nif (pdev->device == E1000_DEV_ID_82573L) {\r\nadapter->flags |= FLAG_HAS_JUMBO_FRAMES;\r\nadapter->max_hw_frame_size = DEFAULT_JUMBO;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_get_phy_id_82571(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nu16 phy_id = 0;\r\nswitch (hw->mac.type) {\r\ncase e1000_82571:\r\ncase e1000_82572:\r\nphy->id = IGP01E1000_I_PHY_ID;\r\nbreak;\r\ncase e1000_82573:\r\nreturn e1000e_get_phy_id(hw);\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nret_val = e1e_rphy(hw, MII_PHYSID1, &phy_id);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy->id = (u32)(phy_id << 16);\r\nusleep_range(20, 40);\r\nret_val = e1e_rphy(hw, MII_PHYSID2, &phy_id);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy->id |= (u32)(phy_id);\r\nphy->revision = (u32)(phy_id & ~PHY_REVISION_MASK);\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_PHY;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_get_hw_semaphore_82571(struct e1000_hw *hw)\r\n{\r\nu32 swsm;\r\ns32 sw_timeout = hw->nvm.word_size + 1;\r\ns32 fw_timeout = hw->nvm.word_size + 1;\r\ns32 i = 0;\r\nif (hw->dev_spec.e82571.smb_counter > 2)\r\nsw_timeout = 1;\r\nwhile (i < sw_timeout) {\r\nswsm = er32(SWSM);\r\nif (!(swsm & E1000_SWSM_SMBI))\r\nbreak;\r\nusleep_range(50, 100);\r\ni++;\r\n}\r\nif (i == sw_timeout) {\r\ne_dbg("Driver can't access device - SMBI bit is set.\n");\r\nhw->dev_spec.e82571.smb_counter++;\r\n}\r\nfor (i = 0; i < fw_timeout; i++) {\r\nswsm = er32(SWSM);\r\new32(SWSM, swsm | E1000_SWSM_SWESMBI);\r\nif (er32(SWSM) & E1000_SWSM_SWESMBI)\r\nbreak;\r\nusleep_range(50, 100);\r\n}\r\nif (i == fw_timeout) {\r\ne1000_put_hw_semaphore_82571(hw);\r\ne_dbg("Driver can't access the NVM\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void e1000_put_hw_semaphore_82571(struct e1000_hw *hw)\r\n{\r\nu32 swsm;\r\nswsm = er32(SWSM);\r\nswsm &= ~(E1000_SWSM_SMBI | E1000_SWSM_SWESMBI);\r\new32(SWSM, swsm);\r\n}\r\nstatic s32 e1000_get_hw_semaphore_82573(struct e1000_hw *hw)\r\n{\r\nu32 extcnf_ctrl;\r\ns32 i = 0;\r\nextcnf_ctrl = er32(EXTCNF_CTRL);\r\ndo {\r\nextcnf_ctrl |= E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP;\r\new32(EXTCNF_CTRL, extcnf_ctrl);\r\nextcnf_ctrl = er32(EXTCNF_CTRL);\r\nif (extcnf_ctrl & E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP)\r\nbreak;\r\nusleep_range(2000, 4000);\r\ni++;\r\n} while (i < MDIO_OWNERSHIP_TIMEOUT);\r\nif (i == MDIO_OWNERSHIP_TIMEOUT) {\r\ne1000_put_hw_semaphore_82573(hw);\r\ne_dbg("Driver can't access the PHY\n");\r\nreturn -E1000_ERR_PHY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void e1000_put_hw_semaphore_82573(struct e1000_hw *hw)\r\n{\r\nu32 extcnf_ctrl;\r\nextcnf_ctrl = er32(EXTCNF_CTRL);\r\nextcnf_ctrl &= ~E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP;\r\new32(EXTCNF_CTRL, extcnf_ctrl);\r\n}\r\nstatic s32 e1000_get_hw_semaphore_82574(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nmutex_lock(&swflag_mutex);\r\nret_val = e1000_get_hw_semaphore_82573(hw);\r\nif (ret_val)\r\nmutex_unlock(&swflag_mutex);\r\nreturn ret_val;\r\n}\r\nstatic void e1000_put_hw_semaphore_82574(struct e1000_hw *hw)\r\n{\r\ne1000_put_hw_semaphore_82573(hw);\r\nmutex_unlock(&swflag_mutex);\r\n}\r\nstatic s32 e1000_set_d0_lplu_state_82574(struct e1000_hw *hw, bool active)\r\n{\r\nu32 data = er32(POEMB);\r\nif (active)\r\ndata |= E1000_PHY_CTRL_D0A_LPLU;\r\nelse\r\ndata &= ~E1000_PHY_CTRL_D0A_LPLU;\r\new32(POEMB, data);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_set_d3_lplu_state_82574(struct e1000_hw *hw, bool active)\r\n{\r\nu32 data = er32(POEMB);\r\nif (!active) {\r\ndata &= ~E1000_PHY_CTRL_NOND0A_LPLU;\r\n} else if ((hw->phy.autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||\r\n(hw->phy.autoneg_advertised == E1000_ALL_NOT_GIG) ||\r\n(hw->phy.autoneg_advertised == E1000_ALL_10_SPEED)) {\r\ndata |= E1000_PHY_CTRL_NOND0A_LPLU;\r\n}\r\new32(POEMB, data);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_acquire_nvm_82571(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nret_val = e1000_get_hw_semaphore_82571(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\nbreak;\r\ndefault:\r\nret_val = e1000e_acquire_nvm(hw);\r\nbreak;\r\n}\r\nif (ret_val)\r\ne1000_put_hw_semaphore_82571(hw);\r\nreturn ret_val;\r\n}\r\nstatic void e1000_release_nvm_82571(struct e1000_hw *hw)\r\n{\r\ne1000e_release_nvm(hw);\r\ne1000_put_hw_semaphore_82571(hw);\r\n}\r\nstatic s32 e1000_write_nvm_82571(struct e1000_hw *hw, u16 offset, u16 words,\r\nu16 *data)\r\n{\r\ns32 ret_val;\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nret_val = e1000_write_nvm_eewr_82571(hw, offset, words, data);\r\nbreak;\r\ncase e1000_82571:\r\ncase e1000_82572:\r\nret_val = e1000e_write_nvm_spi(hw, offset, words, data);\r\nbreak;\r\ndefault:\r\nret_val = -E1000_ERR_NVM;\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_update_nvm_checksum_82571(struct e1000_hw *hw)\r\n{\r\nu32 eecd;\r\ns32 ret_val;\r\nu16 i;\r\nret_val = e1000e_update_nvm_checksum_generic(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (hw->nvm.type != e1000_nvm_flash_hw)\r\nreturn 0;\r\nfor (i = 0; i < E1000_FLASH_UPDATES; i++) {\r\nusleep_range(1000, 2000);\r\nif (!(er32(EECD) & E1000_EECD_FLUPD))\r\nbreak;\r\n}\r\nif (i == E1000_FLASH_UPDATES)\r\nreturn -E1000_ERR_NVM;\r\nif ((er32(FLOP) & 0xFF00) == E1000_STM_OPCODE) {\r\new32(HICR, E1000_HICR_FW_RESET_ENABLE);\r\ne1e_flush();\r\new32(HICR, E1000_HICR_FW_RESET);\r\n}\r\neecd = er32(EECD) | E1000_EECD_FLUPD;\r\new32(EECD, eecd);\r\nfor (i = 0; i < E1000_FLASH_UPDATES; i++) {\r\nusleep_range(1000, 2000);\r\nif (!(er32(EECD) & E1000_EECD_FLUPD))\r\nbreak;\r\n}\r\nif (i == E1000_FLASH_UPDATES)\r\nreturn -E1000_ERR_NVM;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_validate_nvm_checksum_82571(struct e1000_hw *hw)\r\n{\r\nif (hw->nvm.type == e1000_nvm_flash_hw)\r\ne1000_fix_nvm_checksum_82571(hw);\r\nreturn e1000e_validate_nvm_checksum_generic(hw);\r\n}\r\nstatic s32 e1000_write_nvm_eewr_82571(struct e1000_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 i, eewr = 0;\r\ns32 ret_val = 0;\r\nif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\r\n(words == 0)) {\r\ne_dbg("nvm parameter(s) out of bounds\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nfor (i = 0; i < words; i++) {\r\neewr = ((data[i] << E1000_NVM_RW_REG_DATA) |\r\n((offset + i) << E1000_NVM_RW_ADDR_SHIFT) |\r\nE1000_NVM_RW_REG_START);\r\nret_val = e1000e_poll_eerd_eewr_done(hw, E1000_NVM_POLL_WRITE);\r\nif (ret_val)\r\nbreak;\r\new32(EEWR, eewr);\r\nret_val = e1000e_poll_eerd_eewr_done(hw, E1000_NVM_POLL_WRITE);\r\nif (ret_val)\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_get_cfg_done_82571(struct e1000_hw *hw)\r\n{\r\ns32 timeout = PHY_CFG_TIMEOUT;\r\nwhile (timeout) {\r\nif (er32(EEMNGCTL) & E1000_NVM_CFG_DONE_PORT_0)\r\nbreak;\r\nusleep_range(1000, 2000);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\ne_dbg("MNG configuration cycle has not completed.\n");\r\nreturn -E1000_ERR_RESET;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_set_d0_lplu_state_82571(struct e1000_hw *hw, bool active)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nu16 data;\r\nret_val = e1e_rphy(hw, IGP02E1000_PHY_POWER_MGMT, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (active) {\r\ndata |= IGP02E1000_PM_D0_LPLU;\r\nret_val = e1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG, data);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else {\r\ndata &= ~IGP02E1000_PM_D0_LPLU;\r\nret_val = e1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, data);\r\nif (phy->smart_speed == e1000_smart_speed_on) {\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata |= IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\ndata);\r\nif (ret_val)\r\nreturn ret_val;\r\n} else if (phy->smart_speed == e1000_smart_speed_off) {\r\nret_val = e1e_rphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = e1e_wphy(hw, IGP01E1000_PHY_PORT_CONFIG,\r\ndata);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_reset_hw_82571(struct e1000_hw *hw)\r\n{\r\nu32 ctrl, ctrl_ext, eecd, tctl;\r\ns32 ret_val;\r\nret_val = e1000e_disable_pcie_master(hw);\r\nif (ret_val)\r\ne_dbg("PCI-E Master disable polling has failed.\n");\r\ne_dbg("Masking off all interrupts\n");\r\new32(IMC, 0xffffffff);\r\new32(RCTL, 0);\r\ntctl = er32(TCTL);\r\ntctl &= ~E1000_TCTL_EN;\r\new32(TCTL, tctl);\r\ne1e_flush();\r\nusleep_range(10000, 20000);\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\nret_val = e1000_get_hw_semaphore_82573(hw);\r\nbreak;\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nret_val = e1000_get_hw_semaphore_82574(hw);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nctrl = er32(CTRL);\r\ne_dbg("Issuing a global reset to MAC\n");\r\new32(CTRL, ctrl | E1000_CTRL_RST);\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\nif (!ret_val)\r\ne1000_put_hw_semaphore_82573(hw);\r\nbreak;\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nif (!ret_val)\r\ne1000_put_hw_semaphore_82574(hw);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hw->nvm.type == e1000_nvm_flash_hw) {\r\nusleep_range(10, 20);\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_EE_RST;\r\new32(CTRL_EXT, ctrl_ext);\r\ne1e_flush();\r\n}\r\nret_val = e1000e_get_auto_rd_done(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nswitch (hw->mac.type) {\r\ncase e1000_82571:\r\ncase e1000_82572:\r\neecd = er32(EECD);\r\neecd &= ~(E1000_EECD_REQ | E1000_EECD_GNT);\r\new32(EECD, eecd);\r\nbreak;\r\ncase e1000_82573:\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nmsleep(25);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\new32(IMC, 0xffffffff);\r\ner32(ICR);\r\nif (hw->mac.type == e1000_82571) {\r\nret_val = e1000_check_alt_mac_addr_generic(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\ne1000e_set_laa_state_82571(hw, true);\r\n}\r\nif (hw->phy.media_type == e1000_media_type_internal_serdes)\r\nhw->mac.serdes_link_state = e1000_serdes_link_down;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_init_hw_82571(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nu32 reg_data;\r\ns32 ret_val;\r\nu16 i, rar_count = mac->rar_entry_count;\r\ne1000_initialize_hw_bits_82571(hw);\r\nret_val = mac->ops.id_led_init(hw);\r\nif (ret_val)\r\ne_dbg("Error initializing identification LED\n");\r\ne_dbg("Initializing the IEEE VLAN\n");\r\nmac->ops.clear_vfta(hw);\r\nif (e1000e_get_laa_state_82571(hw))\r\nrar_count--;\r\ne1000e_init_rx_addrs(hw, rar_count);\r\ne_dbg("Zeroing the MTA\n");\r\nfor (i = 0; i < mac->mta_reg_count; i++)\r\nE1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);\r\nret_val = mac->ops.setup_link(hw);\r\nreg_data = er32(TXDCTL(0));\r\nreg_data = ((reg_data & ~E1000_TXDCTL_WTHRESH) |\r\nE1000_TXDCTL_FULL_TX_DESC_WB | E1000_TXDCTL_COUNT_DESC);\r\new32(TXDCTL(0), reg_data);\r\nswitch (mac->type) {\r\ncase e1000_82573:\r\ne1000e_enable_tx_pkt_filtering(hw);\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nreg_data = er32(GCR);\r\nreg_data |= E1000_GCR_L1_ACT_WITHOUT_L0S_RX;\r\new32(GCR, reg_data);\r\nbreak;\r\ndefault:\r\nreg_data = er32(TXDCTL(1));\r\nreg_data = ((reg_data & ~E1000_TXDCTL_WTHRESH) |\r\nE1000_TXDCTL_FULL_TX_DESC_WB |\r\nE1000_TXDCTL_COUNT_DESC);\r\new32(TXDCTL(1), reg_data);\r\nbreak;\r\n}\r\ne1000_clear_hw_cntrs_82571(hw);\r\nreturn ret_val;\r\n}\r\nstatic void e1000_initialize_hw_bits_82571(struct e1000_hw *hw)\r\n{\r\nu32 reg;\r\nreg = er32(TXDCTL(0));\r\nreg |= BIT(22);\r\new32(TXDCTL(0), reg);\r\nreg = er32(TXDCTL(1));\r\nreg |= BIT(22);\r\new32(TXDCTL(1), reg);\r\nreg = er32(TARC(0));\r\nreg &= ~(0xF << 27);\r\nswitch (hw->mac.type) {\r\ncase e1000_82571:\r\ncase e1000_82572:\r\nreg |= BIT(23) | BIT(24) | BIT(25) | BIT(26);\r\nbreak;\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nreg |= BIT(26);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\new32(TARC(0), reg);\r\nreg = er32(TARC(1));\r\nswitch (hw->mac.type) {\r\ncase e1000_82571:\r\ncase e1000_82572:\r\nreg &= ~(BIT(29) | BIT(30));\r\nreg |= BIT(22) | BIT(24) | BIT(25) | BIT(26);\r\nif (er32(TCTL) & E1000_TCTL_MULR)\r\nreg &= ~BIT(28);\r\nelse\r\nreg |= BIT(28);\r\new32(TARC(1), reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nreg = er32(CTRL);\r\nreg &= ~BIT(29);\r\new32(CTRL, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nreg = er32(CTRL_EXT);\r\nreg &= ~BIT(23);\r\nreg |= BIT(22);\r\new32(CTRL_EXT, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hw->mac.type == e1000_82571) {\r\nreg = er32(PBA_ECC);\r\nreg |= E1000_PBA_ECC_CORR_EN;\r\new32(PBA_ECC, reg);\r\n}\r\nif ((hw->mac.type == e1000_82571) || (hw->mac.type == e1000_82572)) {\r\nreg = er32(CTRL_EXT);\r\nreg &= ~E1000_CTRL_EXT_DMA_DYN_CLK_EN;\r\new32(CTRL_EXT, reg);\r\n}\r\nif (hw->mac.type <= e1000_82573) {\r\nreg = er32(RFCTL);\r\nreg |= (E1000_RFCTL_IPV6_EX_DIS | E1000_RFCTL_NEW_IPV6_EXT_DIS);\r\new32(RFCTL, reg);\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nreg = er32(GCR);\r\nreg |= BIT(22);\r\new32(GCR, reg);\r\nreg = er32(GCR2);\r\nreg |= 1;\r\new32(GCR2, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void e1000_clear_vfta_82571(struct e1000_hw *hw)\r\n{\r\nu32 offset;\r\nu32 vfta_value = 0;\r\nu32 vfta_offset = 0;\r\nu32 vfta_bit_in_reg = 0;\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nif (hw->mng_cookie.vlan_id != 0) {\r\nvfta_offset = (hw->mng_cookie.vlan_id >>\r\nE1000_VFTA_ENTRY_SHIFT) &\r\nE1000_VFTA_ENTRY_MASK;\r\nvfta_bit_in_reg =\r\nBIT(hw->mng_cookie.vlan_id &\r\nE1000_VFTA_ENTRY_BIT_SHIFT_MASK);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {\r\nvfta_value = (offset == vfta_offset) ? vfta_bit_in_reg : 0;\r\nE1000_WRITE_REG_ARRAY(hw, E1000_VFTA, offset, vfta_value);\r\ne1e_flush();\r\n}\r\n}\r\nstatic bool e1000_check_mng_mode_82574(struct e1000_hw *hw)\r\n{\r\nu16 data;\r\ne1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &data);\r\nreturn (data & E1000_NVM_INIT_CTRL2_MNGM) != 0;\r\n}\r\nstatic s32 e1000_led_on_82574(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\nu32 i;\r\nctrl = hw->mac.ledctl_mode2;\r\nif (!(E1000_STATUS_LU & er32(STATUS))) {\r\nfor (i = 0; i < 4; i++)\r\nif (((hw->mac.ledctl_mode2 >> (i * 8)) & 0xFF) ==\r\nE1000_LEDCTL_MODE_LED_ON)\r\nctrl |= (E1000_LEDCTL_LED0_IVRT << (i * 8));\r\n}\r\new32(LEDCTL, ctrl);\r\nreturn 0;\r\n}\r\nbool e1000_check_phy_82574(struct e1000_hw *hw)\r\n{\r\nu16 status_1kbt = 0;\r\nu16 receive_errors = 0;\r\ns32 ret_val;\r\nret_val = e1e_rphy(hw, E1000_RECEIVE_ERROR_COUNTER, &receive_errors);\r\nif (ret_val)\r\nreturn false;\r\nif (receive_errors == E1000_RECEIVE_ERROR_MAX) {\r\nret_val = e1e_rphy(hw, E1000_BASE1000T_STATUS, &status_1kbt);\r\nif (ret_val)\r\nreturn false;\r\nif ((status_1kbt & E1000_IDLE_ERROR_COUNT_MASK) ==\r\nE1000_IDLE_ERROR_COUNT_MASK)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic s32 e1000_setup_link_82571(struct e1000_hw *hw)\r\n{\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nif (hw->fc.requested_mode == e1000_fc_default)\r\nhw->fc.requested_mode = e1000_fc_full;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn e1000e_setup_link_generic(hw);\r\n}\r\nstatic s32 e1000_setup_copper_link_82571(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nctrl = er32(CTRL);\r\nctrl |= E1000_CTRL_SLU;\r\nctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\r\new32(CTRL, ctrl);\r\nswitch (hw->phy.type) {\r\ncase e1000_phy_m88:\r\ncase e1000_phy_bm:\r\nret_val = e1000e_copper_link_setup_m88(hw);\r\nbreak;\r\ncase e1000_phy_igp_2:\r\nret_val = e1000e_copper_link_setup_igp(hw);\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_PHY;\r\n}\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn e1000e_setup_copper_link(hw);\r\n}\r\nstatic s32 e1000_setup_fiber_serdes_link_82571(struct e1000_hw *hw)\r\n{\r\nswitch (hw->mac.type) {\r\ncase e1000_82571:\r\ncase e1000_82572:\r\new32(SCTL, E1000_SCTL_DISABLE_SERDES_LOOPBACK);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn e1000e_setup_fiber_serdes_link(hw);\r\n}\r\nstatic s32 e1000_check_for_serdes_link_82571(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nu32 rxcw;\r\nu32 ctrl;\r\nu32 status;\r\nu32 txcw;\r\nu32 i;\r\ns32 ret_val = 0;\r\nctrl = er32(CTRL);\r\nstatus = er32(STATUS);\r\ner32(RXCW);\r\nusleep_range(10, 20);\r\nrxcw = er32(RXCW);\r\nif ((rxcw & E1000_RXCW_SYNCH) && !(rxcw & E1000_RXCW_IV)) {\r\nswitch (mac->serdes_link_state) {\r\ncase e1000_serdes_link_autoneg_complete:\r\nif (!(status & E1000_STATUS_LU)) {\r\nmac->serdes_link_state =\r\ne1000_serdes_link_autoneg_progress;\r\nmac->serdes_has_link = false;\r\ne_dbg("AN_UP -> AN_PROG\n");\r\n} else {\r\nmac->serdes_has_link = true;\r\n}\r\nbreak;\r\ncase e1000_serdes_link_forced_up:\r\nif (rxcw & E1000_RXCW_C) {\r\new32(TXCW, mac->txcw);\r\new32(CTRL, (ctrl & ~E1000_CTRL_SLU));\r\nmac->serdes_link_state =\r\ne1000_serdes_link_autoneg_progress;\r\nmac->serdes_has_link = false;\r\ne_dbg("FORCED_UP -> AN_PROG\n");\r\n} else {\r\nmac->serdes_has_link = true;\r\n}\r\nbreak;\r\ncase e1000_serdes_link_autoneg_progress:\r\nif (rxcw & E1000_RXCW_C) {\r\nif (status & E1000_STATUS_LU) {\r\nmac->serdes_link_state =\r\ne1000_serdes_link_autoneg_complete;\r\ne_dbg("AN_PROG -> AN_UP\n");\r\nmac->serdes_has_link = true;\r\n} else {\r\nmac->serdes_link_state =\r\ne1000_serdes_link_down;\r\ne_dbg("AN_PROG -> DOWN\n");\r\n}\r\n} else {\r\new32(TXCW, (mac->txcw & ~E1000_TXCW_ANE));\r\nctrl |= (E1000_CTRL_SLU | E1000_CTRL_FD);\r\new32(CTRL, ctrl);\r\nret_val = e1000e_config_fc_after_link_up(hw);\r\nif (ret_val) {\r\ne_dbg("Error config flow control\n");\r\nbreak;\r\n}\r\nmac->serdes_link_state =\r\ne1000_serdes_link_forced_up;\r\nmac->serdes_has_link = true;\r\ne_dbg("AN_PROG -> FORCED_UP\n");\r\n}\r\nbreak;\r\ncase e1000_serdes_link_down:\r\ndefault:\r\new32(TXCW, mac->txcw);\r\new32(CTRL, (ctrl & ~E1000_CTRL_SLU));\r\nmac->serdes_link_state =\r\ne1000_serdes_link_autoneg_progress;\r\nmac->serdes_has_link = false;\r\ne_dbg("DOWN -> AN_PROG\n");\r\nbreak;\r\n}\r\n} else {\r\nif (!(rxcw & E1000_RXCW_SYNCH)) {\r\nmac->serdes_has_link = false;\r\nmac->serdes_link_state = e1000_serdes_link_down;\r\ne_dbg("ANYSTATE -> DOWN\n");\r\n} else {\r\nfor (i = 0; i < AN_RETRY_COUNT; i++) {\r\nusleep_range(10, 20);\r\nrxcw = er32(RXCW);\r\nif ((rxcw & E1000_RXCW_SYNCH) &&\r\n(rxcw & E1000_RXCW_C))\r\ncontinue;\r\nif (rxcw & E1000_RXCW_IV) {\r\nmac->serdes_has_link = false;\r\nmac->serdes_link_state =\r\ne1000_serdes_link_down;\r\ne_dbg("ANYSTATE -> DOWN\n");\r\nbreak;\r\n}\r\n}\r\nif (i == AN_RETRY_COUNT) {\r\ntxcw = er32(TXCW);\r\ntxcw |= E1000_TXCW_ANE;\r\new32(TXCW, txcw);\r\nmac->serdes_link_state =\r\ne1000_serdes_link_autoneg_progress;\r\nmac->serdes_has_link = false;\r\ne_dbg("ANYSTATE -> AN_PROG\n");\r\n}\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_valid_led_default_82571(struct e1000_hw *hw, u16 *data)\r\n{\r\ns32 ret_val;\r\nret_val = e1000_read_nvm(hw, NVM_ID_LED_SETTINGS, 1, data);\r\nif (ret_val) {\r\ne_dbg("NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_82573:\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nif (*data == ID_LED_RESERVED_F746)\r\n*data = ID_LED_DEFAULT_82573;\r\nbreak;\r\ndefault:\r\nif (*data == ID_LED_RESERVED_0000 ||\r\n*data == ID_LED_RESERVED_FFFF)\r\n*data = ID_LED_DEFAULT;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nbool e1000e_get_laa_state_82571(struct e1000_hw *hw)\r\n{\r\nif (hw->mac.type != e1000_82571)\r\nreturn false;\r\nreturn hw->dev_spec.e82571.laa_is_present;\r\n}\r\nvoid e1000e_set_laa_state_82571(struct e1000_hw *hw, bool state)\r\n{\r\nif (hw->mac.type != e1000_82571)\r\nreturn;\r\nhw->dev_spec.e82571.laa_is_present = state;\r\nif (state)\r\nhw->mac.ops.rar_set(hw, hw->mac.addr,\r\nhw->mac.rar_entry_count - 1);\r\n}\r\nstatic s32 e1000_fix_nvm_checksum_82571(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\ns32 ret_val;\r\nu16 data;\r\nif (nvm->type != e1000_nvm_flash_hw)\r\nreturn 0;\r\nret_val = e1000_read_nvm(hw, 0x10, 1, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (!(data & 0x10)) {\r\nret_val = e1000_read_nvm(hw, 0x23, 1, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (!(data & 0x8000)) {\r\ndata |= 0x8000;\r\nret_val = e1000_write_nvm(hw, 0x23, 1, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000e_update_nvm_checksum(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_read_mac_addr_82571(struct e1000_hw *hw)\r\n{\r\nif (hw->mac.type == e1000_82571) {\r\ns32 ret_val;\r\nret_val = e1000_check_alt_mac_addr_generic(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn e1000_read_mac_addr_generic(hw);\r\n}\r\nstatic void e1000_power_down_phy_copper_82571(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nif (!phy->ops.check_reset_block)\r\nreturn;\r\nif (!(mac->ops.check_mng_mode(hw) || phy->ops.check_reset_block(hw)))\r\ne1000_power_down_phy_copper(hw);\r\n}\r\nstatic void e1000_clear_hw_cntrs_82571(struct e1000_hw *hw)\r\n{\r\ne1000e_clear_hw_cntrs_base(hw);\r\ner32(PRC64);\r\ner32(PRC127);\r\ner32(PRC255);\r\ner32(PRC511);\r\ner32(PRC1023);\r\ner32(PRC1522);\r\ner32(PTC64);\r\ner32(PTC127);\r\ner32(PTC255);\r\ner32(PTC511);\r\ner32(PTC1023);\r\ner32(PTC1522);\r\ner32(ALGNERRC);\r\ner32(RXERRC);\r\ner32(TNCRS);\r\ner32(CEXTERR);\r\ner32(TSCTC);\r\ner32(TSCTFC);\r\ner32(MGTPRC);\r\ner32(MGTPDC);\r\ner32(MGTPTC);\r\ner32(IAC);\r\ner32(ICRXOC);\r\ner32(ICRXPTC);\r\ner32(ICRXATC);\r\ner32(ICTXPTC);\r\ner32(ICTXATC);\r\ner32(ICTXQEC);\r\ner32(ICTXQMTC);\r\ner32(ICRXDMTC);\r\n}
