static int max77693_chg_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nconst struct chg_reg_data *reg_data = rdev_get_drvdata(rdev);\r\nunsigned int chg_min_uA = rdev->constraints->min_uA;\r\nunsigned int chg_max_uA = rdev->constraints->max_uA;\r\nunsigned int reg, sel;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(rdev->regmap, reg_data->linear_reg, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nsel = reg & reg_data->linear_mask;\r\nif (sel <= reg_data->min_sel)\r\nsel = 0;\r\nelse\r\nsel -= reg_data->min_sel;\r\nval = chg_min_uA + reg_data->uA_step * sel;\r\nif (val > chg_max_uA)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nstatic int max77693_chg_set_current_limit(struct regulator_dev *rdev,\r\nint min_uA, int max_uA)\r\n{\r\nconst struct chg_reg_data *reg_data = rdev_get_drvdata(rdev);\r\nunsigned int chg_min_uA = rdev->constraints->min_uA;\r\nint sel = 0;\r\nwhile (chg_min_uA + reg_data->uA_step * sel < min_uA)\r\nsel++;\r\nif (chg_min_uA + reg_data->uA_step * sel > max_uA)\r\nreturn -EINVAL;\r\nsel += reg_data->min_sel;\r\nreturn regmap_write(rdev->regmap, reg_data->linear_reg, sel);\r\n}\r\nstatic struct regmap *max77693_get_regmap(enum max77693_types type,\r\nstruct max77693_dev *max77693,\r\nint reg_id)\r\n{\r\nif (type == TYPE_MAX77693)\r\nreturn max77693->regmap;\r\nswitch (reg_id) {\r\ncase MAX77843_SAFEOUT1:\r\ncase MAX77843_SAFEOUT2:\r\nreturn max77693->regmap;\r\ncase MAX77843_CHARGER:\r\nreturn max77693->regmap_chg;\r\ndefault:\r\nreturn max77693->regmap;\r\n}\r\n}\r\nstatic int max77693_pmic_probe(struct platform_device *pdev)\r\n{\r\nenum max77693_types type = platform_get_device_id(pdev)->driver_data;\r\nstruct max77693_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nconst struct regulator_desc *regulators;\r\nunsigned int regulators_size;\r\nint i;\r\nstruct regulator_config config = { };\r\nconfig.dev = iodev->dev;\r\nswitch (type) {\r\ncase TYPE_MAX77693:\r\nregulators = max77693_supported_regulators;\r\nregulators_size = ARRAY_SIZE(max77693_supported_regulators);\r\nconfig.driver_data = (void *)&max77693_chg_reg_data;\r\nbreak;\r\ncase TYPE_MAX77843:\r\nregulators = max77843_supported_regulators;\r\nregulators_size = ARRAY_SIZE(max77843_supported_regulators);\r\nconfig.driver_data = (void *)&max77843_chg_reg_data;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported device type: %u\n", type);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < regulators_size; i++) {\r\nstruct regulator_dev *rdev;\r\nconfig.regmap = max77693_get_regmap(type, iodev,\r\nregulators[i].id);\r\nrdev = devm_regulator_register(&pdev->dev,\r\n&regulators[i], &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev,\r\n"Failed to initialize regulator-%d\n", i);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init max77693_pmic_init(void)\r\n{\r\nreturn platform_driver_register(&max77693_pmic_driver);\r\n}\r\nstatic void __exit max77693_pmic_cleanup(void)\r\n{\r\nplatform_driver_unregister(&max77693_pmic_driver);\r\n}
