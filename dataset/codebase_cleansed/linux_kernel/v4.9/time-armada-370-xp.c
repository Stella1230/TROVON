static void local_timer_ctrl_clrset(u32 clr, u32 set)\r\n{\r\nwritel((readl(local_base + TIMER_CTRL_OFF) & ~clr) | set,\r\nlocal_base + TIMER_CTRL_OFF);\r\n}\r\nstatic u64 notrace armada_370_xp_read_sched_clock(void)\r\n{\r\nreturn ~readl(timer_base + TIMER0_VAL_OFF);\r\n}\r\nstatic int\r\narmada_370_xp_clkevt_next_event(unsigned long delta,\r\nstruct clock_event_device *dev)\r\n{\r\nwritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\r\nwritel(delta, local_base + TIMER0_VAL_OFF);\r\nlocal_timer_ctrl_clrset(TIMER0_RELOAD_EN, enable_mask);\r\nreturn 0;\r\n}\r\nstatic int armada_370_xp_clkevt_shutdown(struct clock_event_device *evt)\r\n{\r\nlocal_timer_ctrl_clrset(TIMER0_EN, 0);\r\nwritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\r\nreturn 0;\r\n}\r\nstatic int armada_370_xp_clkevt_set_periodic(struct clock_event_device *evt)\r\n{\r\nwritel(ticks_per_jiffy - 1, local_base + TIMER0_RELOAD_OFF);\r\nwritel(ticks_per_jiffy - 1, local_base + TIMER0_VAL_OFF);\r\nlocal_timer_ctrl_clrset(0, TIMER0_RELOAD_EN | enable_mask);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t armada_370_xp_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nwritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int armada_370_xp_timer_starting_cpu(unsigned int cpu)\r\n{\r\nstruct clock_event_device *evt = per_cpu_ptr(armada_370_xp_evt, cpu);\r\nu32 clr = 0, set = 0;\r\nif (timer25Mhz)\r\nset = TIMER0_25MHZ;\r\nelse\r\nclr = TIMER0_25MHZ;\r\nlocal_timer_ctrl_clrset(clr, set);\r\nevt->name = "armada_370_xp_per_cpu_tick",\r\nevt->features = CLOCK_EVT_FEAT_ONESHOT |\r\nCLOCK_EVT_FEAT_PERIODIC;\r\nevt->shift = 32,\r\nevt->rating = 300,\r\nevt->set_next_event = armada_370_xp_clkevt_next_event,\r\nevt->set_state_shutdown = armada_370_xp_clkevt_shutdown;\r\nevt->set_state_periodic = armada_370_xp_clkevt_set_periodic;\r\nevt->set_state_oneshot = armada_370_xp_clkevt_shutdown;\r\nevt->tick_resume = armada_370_xp_clkevt_shutdown;\r\nevt->irq = armada_370_xp_clkevt_irq;\r\nevt->cpumask = cpumask_of(cpu);\r\nclockevents_config_and_register(evt, timer_clk, 1, 0xfffffffe);\r\nenable_percpu_irq(evt->irq, 0);\r\nreturn 0;\r\n}\r\nstatic int armada_370_xp_timer_dying_cpu(unsigned int cpu)\r\n{\r\nstruct clock_event_device *evt = per_cpu_ptr(armada_370_xp_evt, cpu);\r\nevt->set_state_shutdown(evt);\r\ndisable_percpu_irq(evt->irq);\r\nreturn 0;\r\n}\r\nstatic int armada_370_xp_timer_suspend(void)\r\n{\r\ntimer0_ctrl_reg = readl(timer_base + TIMER_CTRL_OFF);\r\ntimer0_local_ctrl_reg = readl(local_base + TIMER_CTRL_OFF);\r\nreturn 0;\r\n}\r\nstatic void armada_370_xp_timer_resume(void)\r\n{\r\nwritel(0xffffffff, timer_base + TIMER0_VAL_OFF);\r\nwritel(0xffffffff, timer_base + TIMER0_RELOAD_OFF);\r\nwritel(timer0_ctrl_reg, timer_base + TIMER_CTRL_OFF);\r\nwritel(timer0_local_ctrl_reg, local_base + TIMER_CTRL_OFF);\r\n}\r\nstatic unsigned long armada_370_delay_timer_read(void)\r\n{\r\nreturn ~readl(timer_base + TIMER0_VAL_OFF);\r\n}\r\nstatic int __init armada_370_xp_timer_common_init(struct device_node *np)\r\n{\r\nu32 clr = 0, set = 0;\r\nint res;\r\ntimer_base = of_iomap(np, 0);\r\nif (!timer_base) {\r\npr_err("Failed to iomap");\r\nreturn -ENXIO;\r\n}\r\nlocal_base = of_iomap(np, 1);\r\nif (!local_base) {\r\npr_err("Failed to iomap");\r\nreturn -ENXIO;\r\n}\r\nif (timer25Mhz) {\r\nset = TIMER0_25MHZ;\r\nenable_mask = TIMER0_EN;\r\n} else {\r\nclr = TIMER0_25MHZ;\r\nenable_mask = TIMER0_EN | TIMER0_DIV(TIMER_DIVIDER_SHIFT);\r\n}\r\natomic_io_modify(timer_base + TIMER_CTRL_OFF, clr | set, set);\r\nlocal_timer_ctrl_clrset(clr, set);\r\narmada_370_xp_clkevt_irq = irq_of_parse_and_map(np, 4);\r\nticks_per_jiffy = (timer_clk + HZ / 2) / HZ;\r\nwritel(0xffffffff, timer_base + TIMER0_VAL_OFF);\r\nwritel(0xffffffff, timer_base + TIMER0_RELOAD_OFF);\r\natomic_io_modify(timer_base + TIMER_CTRL_OFF,\r\nTIMER0_RELOAD_EN | enable_mask,\r\nTIMER0_RELOAD_EN | enable_mask);\r\narmada_370_delay_timer.freq = timer_clk;\r\nregister_current_timer_delay(&armada_370_delay_timer);\r\nsched_clock_register(armada_370_xp_read_sched_clock, 32, timer_clk);\r\nres = clocksource_mmio_init(timer_base + TIMER0_VAL_OFF,\r\n"armada_370_xp_clocksource",\r\ntimer_clk, 300, 32, clocksource_mmio_readl_down);\r\nif (res) {\r\npr_err("Failed to initialize clocksource mmio");\r\nreturn res;\r\n}\r\narmada_370_xp_evt = alloc_percpu(struct clock_event_device);\r\nif (!armada_370_xp_evt)\r\nreturn -ENOMEM;\r\nres = request_percpu_irq(armada_370_xp_clkevt_irq,\r\narmada_370_xp_timer_interrupt,\r\n"armada_370_xp_per_cpu_tick",\r\narmada_370_xp_evt);\r\nif (res) {\r\npr_err("Failed to request percpu irq");\r\nreturn res;\r\n}\r\nres = cpuhp_setup_state(CPUHP_AP_ARMADA_TIMER_STARTING,\r\n"AP_ARMADA_TIMER_STARTING",\r\narmada_370_xp_timer_starting_cpu,\r\narmada_370_xp_timer_dying_cpu);\r\nif (res) {\r\npr_err("Failed to setup hotplug state and timer");\r\nreturn res;\r\n}\r\nregister_syscore_ops(&armada_370_xp_timer_syscore_ops);\r\nreturn 0;\r\n}\r\nstatic int __init armada_xp_timer_init(struct device_node *np)\r\n{\r\nstruct clk *clk = of_clk_get_by_name(np, "fixed");\r\nint ret;\r\nif (IS_ERR(clk)) {\r\npr_err("Failed to get clock");\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\nreturn ret;\r\ntimer_clk = clk_get_rate(clk);\r\nreturn armada_370_xp_timer_common_init(np);\r\n}\r\nstatic int __init armada_375_timer_init(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nint ret;\r\nclk = of_clk_get_by_name(np, "fixed");\r\nif (!IS_ERR(clk)) {\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\nreturn ret;\r\ntimer_clk = clk_get_rate(clk);\r\n} else {\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("Failed to get clock");\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\nreturn ret;\r\ntimer_clk = clk_get_rate(clk) / TIMER_DIVIDER;\r\ntimer25Mhz = false;\r\n}\r\nreturn armada_370_xp_timer_common_init(np);\r\n}\r\nstatic int __init armada_370_timer_init(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nint ret;\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("Failed to get clock");\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\nreturn ret;\r\ntimer_clk = clk_get_rate(clk) / TIMER_DIVIDER;\r\ntimer25Mhz = false;\r\nreturn armada_370_xp_timer_common_init(np);\r\n}
