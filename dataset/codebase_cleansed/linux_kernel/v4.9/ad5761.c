static int _ad5761_spi_write(struct ad5761_state *st, u8 addr, u16 val)\r\n{\r\nst->data[0].d32 = cpu_to_be32(AD5761_ADDR(addr) | val);\r\nreturn spi_write(st->spi, &st->data[0].d8[1], 3);\r\n}\r\nstatic int ad5761_spi_write(struct iio_dev *indio_dev, u8 addr, u16 val)\r\n{\r\nstruct ad5761_state *st = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = _ad5761_spi_write(st, addr, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int _ad5761_spi_read(struct ad5761_state *st, u8 addr, u16 *val)\r\n{\r\nint ret;\r\nstruct spi_transfer xfers[] = {\r\n{\r\n.tx_buf = &st->data[0].d8[1],\r\n.bits_per_word = 8,\r\n.len = 3,\r\n.cs_change = true,\r\n}, {\r\n.tx_buf = &st->data[1].d8[1],\r\n.rx_buf = &st->data[2].d8[1],\r\n.bits_per_word = 8,\r\n.len = 3,\r\n},\r\n};\r\nst->data[0].d32 = cpu_to_be32(AD5761_ADDR(addr));\r\nst->data[1].d32 = cpu_to_be32(AD5761_ADDR(AD5761_ADDR_NOOP));\r\nret = spi_sync_transfer(st->spi, xfers, ARRAY_SIZE(xfers));\r\n*val = be32_to_cpu(st->data[2].d32);\r\nreturn ret;\r\n}\r\nstatic int ad5761_spi_read(struct iio_dev *indio_dev, u8 addr, u16 *val)\r\n{\r\nstruct ad5761_state *st = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = _ad5761_spi_read(st, addr, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5761_spi_set_range(struct ad5761_state *st,\r\nenum ad5761_voltage_range range)\r\n{\r\nu16 aux;\r\nint ret;\r\naux = (range & 0x7) | AD5761_CTRL_ETS;\r\nif (st->use_intref)\r\naux |= AD5761_CTRL_USE_INTVREF;\r\nret = _ad5761_spi_write(st, AD5761_ADDR_SW_FULL_RESET, 0);\r\nif (ret)\r\nreturn ret;\r\nret = _ad5761_spi_write(st, AD5761_ADDR_CTRL_WRITE_REG, aux);\r\nif (ret)\r\nreturn ret;\r\nst->range = range;\r\nreturn 0;\r\n}\r\nstatic int ad5761_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nstruct ad5761_state *st;\r\nint ret;\r\nu16 aux;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = ad5761_spi_read(indio_dev, AD5761_ADDR_DAC_READ, &aux);\r\nif (ret)\r\nreturn ret;\r\n*val = aux >> chan->scan_type.shift;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nst = iio_priv(indio_dev);\r\n*val = st->vref * ad5761_range_params[st->range].m;\r\n*val /= 10;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nst = iio_priv(indio_dev);\r\n*val = -(1 << chan->scan_type.realbits);\r\n*val *= ad5761_range_params[st->range].c;\r\n*val /= ad5761_range_params[st->range].m;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ad5761_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nu16 aux;\r\nif (mask != IIO_CHAN_INFO_RAW)\r\nreturn -EINVAL;\r\nif (val2 || (val << chan->scan_type.shift) > 0xffff || val < 0)\r\nreturn -EINVAL;\r\naux = val << chan->scan_type.shift;\r\nreturn ad5761_spi_write(indio_dev, AD5761_ADDR_DAC_WRITE, aux);\r\n}\r\nstatic int ad5761_get_vref(struct ad5761_state *st,\r\nconst struct ad5761_chip_info *chip_info)\r\n{\r\nint ret;\r\nst->vref_reg = devm_regulator_get_optional(&st->spi->dev, "vref");\r\nif (PTR_ERR(st->vref_reg) == -ENODEV) {\r\nif (!chip_info->int_vref) {\r\ndev_err(&st->spi->dev,\r\n"Voltage reference not found\n");\r\nreturn -EIO;\r\n}\r\nst->use_intref = true;\r\nst->vref = chip_info->int_vref;\r\nreturn 0;\r\n}\r\nif (IS_ERR(st->vref_reg)) {\r\ndev_err(&st->spi->dev,\r\n"Error getting voltage reference regulator\n");\r\nreturn PTR_ERR(st->vref_reg);\r\n}\r\nret = regulator_enable(st->vref_reg);\r\nif (ret) {\r\ndev_err(&st->spi->dev,\r\n"Failed to enable voltage reference\n");\r\nreturn ret;\r\n}\r\nret = regulator_get_voltage(st->vref_reg);\r\nif (ret < 0) {\r\ndev_err(&st->spi->dev,\r\n"Failed to get voltage reference value\n");\r\ngoto disable_regulator_vref;\r\n}\r\nif (ret < 2000000 || ret > 3000000) {\r\ndev_warn(&st->spi->dev,\r\n"Invalid external voltage ref. value %d uV\n", ret);\r\nret = -EIO;\r\ngoto disable_regulator_vref;\r\n}\r\nst->vref = ret / 1000;\r\nst->use_intref = false;\r\nreturn 0;\r\ndisable_regulator_vref:\r\nregulator_disable(st->vref_reg);\r\nst->vref_reg = NULL;\r\nreturn ret;\r\n}\r\nstatic int ad5761_probe(struct spi_device *spi)\r\n{\r\nstruct iio_dev *iio_dev;\r\nstruct ad5761_state *st;\r\nint ret;\r\nconst struct ad5761_chip_info *chip_info =\r\n&ad5761_chip_infos[spi_get_device_id(spi)->driver_data];\r\nenum ad5761_voltage_range voltage_range = AD5761_VOLTAGE_RANGE_0V_5V;\r\nstruct ad5761_platform_data *pdata = dev_get_platdata(&spi->dev);\r\niio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (!iio_dev)\r\nreturn -ENOMEM;\r\nst = iio_priv(iio_dev);\r\nst->spi = spi;\r\nspi_set_drvdata(spi, iio_dev);\r\nret = ad5761_get_vref(st, chip_info);\r\nif (ret)\r\nreturn ret;\r\nif (pdata)\r\nvoltage_range = pdata->voltage_range;\r\nret = ad5761_spi_set_range(st, voltage_range);\r\nif (ret)\r\ngoto disable_regulator_err;\r\niio_dev->dev.parent = &spi->dev;\r\niio_dev->info = &ad5761_info;\r\niio_dev->modes = INDIO_DIRECT_MODE;\r\niio_dev->channels = &chip_info->channel;\r\niio_dev->num_channels = 1;\r\niio_dev->name = spi_get_device_id(st->spi)->name;\r\nret = iio_device_register(iio_dev);\r\nif (ret)\r\ngoto disable_regulator_err;\r\nreturn 0;\r\ndisable_regulator_err:\r\nif (!IS_ERR_OR_NULL(st->vref_reg))\r\nregulator_disable(st->vref_reg);\r\nreturn ret;\r\n}\r\nstatic int ad5761_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *iio_dev = spi_get_drvdata(spi);\r\nstruct ad5761_state *st = iio_priv(iio_dev);\r\niio_device_unregister(iio_dev);\r\nif (!IS_ERR_OR_NULL(st->vref_reg))\r\nregulator_disable(st->vref_reg);\r\nreturn 0;\r\n}
