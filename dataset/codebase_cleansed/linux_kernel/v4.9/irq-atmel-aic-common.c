static void aic_common_shutdown(struct irq_data *d)\r\n{\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nct->chip.irq_mask(d);\r\n}\r\nint aic_common_set_type(struct irq_data *d, unsigned type, unsigned *val)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct aic_chip_data *aic = gc->private;\r\nunsigned aic_type;\r\nswitch (type) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\naic_type = AT91_AIC_SRCTYPE_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\naic_type = AT91_AIC_SRCTYPE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nif (!(d->mask & aic->ext_irqs))\r\nreturn -EINVAL;\r\naic_type = AT91_AIC_SRCTYPE_LOW;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nif (!(d->mask & aic->ext_irqs))\r\nreturn -EINVAL;\r\naic_type = AT91_AIC_SRCTYPE_FALLING;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*val &= ~AT91_AIC_SRCTYPE;\r\n*val |= aic_type;\r\nreturn 0;\r\n}\r\nvoid aic_common_set_priority(int priority, unsigned *val)\r\n{\r\n*val &= ~AT91_AIC_PRIOR;\r\n*val |= priority;\r\n}\r\nint aic_common_irq_domain_xlate(struct irq_domain *d,\r\nstruct device_node *ctrlr,\r\nconst u32 *intspec,\r\nunsigned int intsize,\r\nirq_hw_number_t *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nif (WARN_ON(intsize < 3))\r\nreturn -EINVAL;\r\nif (WARN_ON((intspec[2] < AT91_AIC_IRQ_MIN_PRIORITY) ||\r\n(intspec[2] > AT91_AIC_IRQ_MAX_PRIORITY)))\r\nreturn -EINVAL;\r\n*out_hwirq = intspec[0];\r\n*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\r\nreturn 0;\r\n}\r\nstatic void __init aic_common_ext_irq_of_init(struct irq_domain *domain)\r\n{\r\nstruct device_node *node = irq_domain_get_of_node(domain);\r\nstruct irq_chip_generic *gc;\r\nstruct aic_chip_data *aic;\r\nstruct property *prop;\r\nconst __be32 *p;\r\nu32 hwirq;\r\ngc = irq_get_domain_generic_chip(domain, 0);\r\naic = gc->private;\r\naic->ext_irqs |= 1;\r\nof_property_for_each_u32(node, "atmel,external-irqs", prop, p, hwirq) {\r\ngc = irq_get_domain_generic_chip(domain, hwirq);\r\nif (!gc) {\r\npr_warn("AIC: external irq %d >= %d skip it\n",\r\nhwirq, domain->revmap_size);\r\ncontinue;\r\n}\r\naic = gc->private;\r\naic->ext_irqs |= (1 << (hwirq % 32));\r\n}\r\n}\r\nvoid __init aic_common_rtc_irq_fixup(struct device_node *root)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *regs;\r\nnp = of_find_compatible_node(root, NULL, "atmel,at91rm9200-rtc");\r\nif (!np)\r\nnp = of_find_compatible_node(root, NULL,\r\n"atmel,at91sam9x5-rtc");\r\nif (!np)\r\nreturn;\r\nregs = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!regs)\r\nreturn;\r\nwritel(AT91_RTC_IRQ_MASK, regs + AT91_RTC_IDR);\r\niounmap(regs);\r\n}\r\nvoid __init aic_common_rtt_irq_fixup(struct device_node *root)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *regs;\r\nfor_each_compatible_node(np, NULL, "atmel,at91sam9260-rtt") {\r\nregs = of_iomap(np, 0);\r\nif (!regs)\r\ncontinue;\r\nwritel(readl(regs + AT91_RTT_MR) &\r\n~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN),\r\nregs + AT91_RTT_MR);\r\niounmap(regs);\r\n}\r\n}\r\nstatic void __init aic_common_irq_fixup(const struct of_device_id *matches)\r\n{\r\nstruct device_node *root = of_find_node_by_path("/");\r\nconst struct of_device_id *match;\r\nif (!root)\r\nreturn;\r\nmatch = of_match_node(matches, root);\r\nof_node_put(root);\r\nif (match) {\r\nvoid (*fixup)(struct device_node *) = match->data;\r\nfixup(root);\r\n}\r\nof_node_put(root);\r\n}\r\nstruct irq_domain *__init aic_common_of_init(struct device_node *node,\r\nconst struct irq_domain_ops *ops,\r\nconst char *name, int nirqs,\r\nconst struct of_device_id *matches)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_domain *domain;\r\nstruct aic_chip_data *aic;\r\nvoid __iomem *reg_base;\r\nint nchips;\r\nint ret;\r\nint i;\r\nnchips = DIV_ROUND_UP(nirqs, 32);\r\nreg_base = of_iomap(node, 0);\r\nif (!reg_base)\r\nreturn ERR_PTR(-ENOMEM);\r\naic = kcalloc(nchips, sizeof(*aic), GFP_KERNEL);\r\nif (!aic) {\r\nret = -ENOMEM;\r\ngoto err_iounmap;\r\n}\r\ndomain = irq_domain_add_linear(node, nchips * 32, ops, aic);\r\nif (!domain) {\r\nret = -ENOMEM;\r\ngoto err_free_aic;\r\n}\r\nret = irq_alloc_domain_generic_chips(domain, 32, 1, name,\r\nhandle_fasteoi_irq,\r\nIRQ_NOREQUEST | IRQ_NOPROBE |\r\nIRQ_NOAUTOEN, 0, 0);\r\nif (ret)\r\ngoto err_domain_remove;\r\nfor (i = 0; i < nchips; i++) {\r\ngc = irq_get_domain_generic_chip(domain, i * 32);\r\ngc->reg_base = reg_base;\r\ngc->unused = 0;\r\ngc->wake_enabled = ~0;\r\ngc->chip_types[0].type = IRQ_TYPE_SENSE_MASK;\r\ngc->chip_types[0].chip.irq_eoi = irq_gc_eoi;\r\ngc->chip_types[0].chip.irq_set_wake = irq_gc_set_wake;\r\ngc->chip_types[0].chip.irq_shutdown = aic_common_shutdown;\r\ngc->private = &aic[i];\r\n}\r\naic_common_ext_irq_of_init(domain);\r\naic_common_irq_fixup(matches);\r\nreturn domain;\r\nerr_domain_remove:\r\nirq_domain_remove(domain);\r\nerr_free_aic:\r\nkfree(aic);\r\nerr_iounmap:\r\niounmap(reg_base);\r\nreturn ERR_PTR(ret);\r\n}
