static struct aspeed_wdt *to_aspeed_wdt(struct watchdog_device *wdd)\r\n{\r\nreturn container_of(wdd, struct aspeed_wdt, wdd);\r\n}\r\nstatic void aspeed_wdt_enable(struct aspeed_wdt *wdt, int count)\r\n{\r\nwdt->ctrl |= WDT_CTRL_ENABLE;\r\nwritel(0, wdt->base + WDT_CTRL);\r\nwritel(count, wdt->base + WDT_RELOAD_VALUE);\r\nwritel(WDT_RESTART_MAGIC, wdt->base + WDT_RESTART);\r\nwritel(wdt->ctrl, wdt->base + WDT_CTRL);\r\n}\r\nstatic int aspeed_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\r\naspeed_wdt_enable(wdt, wdd->timeout * WDT_RATE_1MHZ);\r\nreturn 0;\r\n}\r\nstatic int aspeed_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\r\nwdt->ctrl &= ~WDT_CTRL_ENABLE;\r\nwritel(wdt->ctrl, wdt->base + WDT_CTRL);\r\nreturn 0;\r\n}\r\nstatic int aspeed_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\r\nwritel(WDT_RESTART_MAGIC, wdt->base + WDT_RESTART);\r\nreturn 0;\r\n}\r\nstatic int aspeed_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\r\nu32 actual;\r\nwdd->timeout = timeout;\r\nactual = min(timeout, wdd->max_hw_heartbeat_ms * 1000);\r\nwritel(actual * WDT_RATE_1MHZ, wdt->base + WDT_RELOAD_VALUE);\r\nwritel(WDT_RESTART_MAGIC, wdt->base + WDT_RESTART);\r\nreturn 0;\r\n}\r\nstatic int aspeed_wdt_restart(struct watchdog_device *wdd,\r\nunsigned long action, void *data)\r\n{\r\nstruct aspeed_wdt *wdt = to_aspeed_wdt(wdd);\r\naspeed_wdt_enable(wdt, 128 * WDT_RATE_1MHZ / 1000);\r\nmdelay(1000);\r\nreturn 0;\r\n}\r\nstatic int aspeed_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct aspeed_wdt *wdt = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&wdt->wdd);\r\nreturn 0;\r\n}\r\nstatic int aspeed_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct aspeed_wdt *wdt;\r\nstruct resource *res;\r\nint ret;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(wdt->base))\r\nreturn PTR_ERR(wdt->base);\r\nwdt->wdd.info = &aspeed_wdt_info;\r\nwdt->wdd.ops = &aspeed_wdt_ops;\r\nwdt->wdd.max_hw_heartbeat_ms = WDT_MAX_TIMEOUT_MS;\r\nwdt->wdd.parent = &pdev->dev;\r\nwdt->wdd.timeout = WDT_DEFAULT_TIMEOUT;\r\nwatchdog_init_timeout(&wdt->wdd, 0, &pdev->dev);\r\nwdt->ctrl = WDT_CTRL_RESET_MODE_SOC |\r\nWDT_CTRL_1MHZ_CLK |\r\nWDT_CTRL_RESET_SYSTEM;\r\nif (readl(wdt->base + WDT_CTRL) & WDT_CTRL_ENABLE) {\r\naspeed_wdt_start(&wdt->wdd);\r\nset_bit(WDOG_HW_RUNNING, &wdt->wdd.status);\r\n}\r\nret = watchdog_register_device(&wdt->wdd);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, wdt);\r\nreturn 0;\r\n}
