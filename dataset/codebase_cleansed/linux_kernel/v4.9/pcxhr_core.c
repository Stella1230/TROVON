static int pcxhr_check_reg_bit(struct pcxhr_mgr *mgr, unsigned int reg,\r\nunsigned char mask, unsigned char bit, int time,\r\nunsigned char* read)\r\n{\r\nint i = 0;\r\nunsigned long end_time = jiffies + (time * HZ + 999) / 1000;\r\ndo {\r\n*read = PCXHR_INPB(mgr, reg);\r\nif ((*read & mask) == bit) {\r\nif (i > 100)\r\ndev_dbg(&mgr->pci->dev,\r\n"ATTENTION! check_reg(%x) loopcount=%d\n",\r\nreg, i);\r\nreturn 0;\r\n}\r\ni++;\r\n} while (time_after_eq(end_time, jiffies));\r\ndev_err(&mgr->pci->dev,\r\n"pcxhr_check_reg_bit: timeout, reg=%x, mask=0x%x, val=%x\n",\r\nreg, mask, *read);\r\nreturn -EIO;\r\n}\r\nstatic int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr,\r\nunsigned int itdsp, int atomic)\r\n{\r\nint err;\r\nunsigned char reg;\r\nif (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0,\r\nPCXHR_INPL(mgr, PCXHR_PLX_MBOX0) &\r\n~PCXHR_MBOX0_HF5);\r\n}\r\nif ((itdsp & PCXHR_MASK_IT_NO_HF0_HF1) == 0) {\r\nreg = (PCXHR_ICR_HI08_RREQ |\r\nPCXHR_ICR_HI08_TREQ |\r\nPCXHR_ICR_HI08_HDRQ);\r\nif (itdsp & PCXHR_MASK_IT_HF0)\r\nreg |= PCXHR_ICR_HI08_HF0;\r\nif (itdsp & PCXHR_MASK_IT_HF1)\r\nreg |= PCXHR_ICR_HI08_HF1;\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);\r\n}\r\nreg = (unsigned char)(((itdsp & PCXHR_MASK_EXTRA_INFO) >> 1) |\r\nPCXHR_CVR_HI08_HC);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_CVR, reg);\r\nif (itdsp & PCXHR_MASK_IT_WAIT) {\r\nif (atomic)\r\nmdelay(PCXHR_WAIT_IT);\r\nelse\r\nmsleep(PCXHR_WAIT_IT);\r\n}\r\nif (itdsp & PCXHR_MASK_IT_WAIT_EXTRA) {\r\nif (atomic)\r\nmdelay(PCXHR_WAIT_IT_EXTRA);\r\nelse\r\nmsleep(PCXHR_WAIT_IT);\r\n}\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_CVR, PCXHR_CVR_HI08_HC, 0,\r\nPCXHR_TIMEOUT_DSP, &reg);\r\nif (err) {\r\ndev_err(&mgr->pci->dev, "pcxhr_send_it_dsp : TIMEOUT CVR\n");\r\nreturn err;\r\n}\r\nif (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_PLX_MBOX0,\r\nPCXHR_MBOX0_HF5,\r\nPCXHR_MBOX0_HF5,\r\nPCXHR_TIMEOUT_DSP,\r\n&reg);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"pcxhr_send_it_dsp : TIMEOUT HF5\n");\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid pcxhr_reset_xilinx_com(struct pcxhr_mgr *mgr)\r\n{\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC,\r\nPCXHR_CHIPSC_INIT_VALUE & ~PCXHR_CHIPSC_RESET_XILINX);\r\n}\r\nstatic void pcxhr_enable_irq(struct pcxhr_mgr *mgr, int enable)\r\n{\r\nunsigned int reg = PCXHR_INPL(mgr, PCXHR_PLX_IRQCS);\r\nif (enable)\r\nreg |= (PCXHR_IRQCS_ENABLE_PCIIRQ | PCXHR_IRQCS_ENABLE_PCIDB);\r\nelse\r\nreg &= ~(PCXHR_IRQCS_ENABLE_PCIIRQ | PCXHR_IRQCS_ENABLE_PCIDB);\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_IRQCS, reg);\r\n}\r\nvoid pcxhr_reset_dsp(struct pcxhr_mgr *mgr)\r\n{\r\npcxhr_enable_irq(mgr, 0);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, 0);\r\nmsleep( PCXHR_WAIT_DEFAULT );\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, 3);\r\nmsleep( PCXHR_WAIT_DEFAULT );\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0, 0);\r\n}\r\nvoid pcxhr_enable_dsp(struct pcxhr_mgr *mgr)\r\n{\r\npcxhr_enable_irq(mgr, 1);\r\n}\r\nint pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr,\r\nconst struct firmware *xilinx, int second)\r\n{\r\nunsigned int i;\r\nunsigned int chipsc;\r\nunsigned char data;\r\nunsigned char mask;\r\nconst unsigned char *image;\r\nchipsc = PCXHR_INPL(mgr, PCXHR_PLX_CHIPSC);\r\nif(second) {\r\nif ((chipsc & PCXHR_CHIPSC_GPI_USERI) == 0) {\r\ndev_err(&mgr->pci->dev, "error loading first xilinx\n");\r\nreturn -EINVAL;\r\n}\r\nchipsc |= PCXHR_CHIPSC_RESET_XILINX;\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);\r\nmsleep( PCXHR_WAIT_DEFAULT );\r\n}\r\nimage = xilinx->data;\r\nfor (i = 0; i < xilinx->size; i++, image++) {\r\ndata = *image;\r\nmask = 0x80;\r\nwhile (mask) {\r\nchipsc &= ~(PCXHR_CHIPSC_DATA_CLK |\r\nPCXHR_CHIPSC_DATA_IN);\r\nif (data & mask)\r\nchipsc |= PCXHR_CHIPSC_DATA_IN;\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);\r\nchipsc |= PCXHR_CHIPSC_DATA_CLK;\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);\r\nmask >>= 1;\r\n}\r\ncond_resched();\r\n}\r\nchipsc &= ~(PCXHR_CHIPSC_DATA_CLK | PCXHR_CHIPSC_DATA_IN);\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);\r\nmsleep( PCXHR_WAIT_DEFAULT );\r\nreturn 0;\r\n}\r\nstatic int pcxhr_download_dsp(struct pcxhr_mgr *mgr, const struct firmware *dsp)\r\n{\r\nint err;\r\nunsigned int i;\r\nunsigned int len;\r\nconst unsigned char *data;\r\nunsigned char dummy;\r\nif (dsp->size <= 0)\r\nreturn -EINVAL;\r\nif (dsp->size % 3)\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!dsp->data))\r\nreturn -EINVAL;\r\nfor (i = 0; i < dsp->size; i += 3) {\r\ndata = dsp->data + i;\r\nif (i == 0) {\r\nlen = (unsigned int)((data[0]<<16) +\r\n(data[1]<<8) +\r\ndata[2]);\r\nif (len && (dsp->size != (len + 2) * 3))\r\nreturn -EINVAL;\r\n}\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\r\nPCXHR_ISR_HI08_TRDY,\r\nPCXHR_ISR_HI08_TRDY,\r\nPCXHR_TIMEOUT_DSP, &dummy);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"dsp loading error at position %d\n", i);\r\nreturn err;\r\n}\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXH, data[0]);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXM, data[1]);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXL, data[2]);\r\ncond_resched();\r\n}\r\nmsleep(PCXHR_WAIT_DEFAULT);\r\nreturn 0;\r\n}\r\nint pcxhr_load_eeprom_binary(struct pcxhr_mgr *mgr,\r\nconst struct firmware *eeprom)\r\n{\r\nint err;\r\nunsigned char reg;\r\nreg = PCXHR_ICR_HI08_RREQ | PCXHR_ICR_HI08_TREQ | PCXHR_ICR_HI08_HDRQ;\r\nif (PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & PCXHR_MBOX0_BOOT_HERE) {\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg | PCXHR_ICR_HI08_INIT);\r\nmsleep(PCXHR_WAIT_DEFAULT);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);\r\nmsleep(PCXHR_WAIT_DEFAULT);\r\ndev_dbg(&mgr->pci->dev, "no need to load eeprom boot\n");\r\nreturn 0;\r\n}\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);\r\nerr = pcxhr_download_dsp(mgr, eeprom);\r\nif (err)\r\nreturn err;\r\nreturn pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,\r\nPCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);\r\n}\r\nint pcxhr_load_boot_binary(struct pcxhr_mgr *mgr, const struct firmware *boot)\r\n{\r\nint err;\r\nunsigned int physaddr = mgr->hostport.addr;\r\nunsigned char dummy;\r\nif (snd_BUG_ON(physaddr & 0xff))\r\nreturn -EINVAL;\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_MBOX1, (physaddr >> 8));\r\nerr = pcxhr_send_it_dsp(mgr, PCXHR_IT_DOWNLOAD_BOOT, 0);\r\nif (err)\r\nreturn err;\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0,\r\nPCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & ~PCXHR_MBOX0_HF5);\r\nerr = pcxhr_download_dsp(mgr, boot);\r\nif (err)\r\nreturn err;\r\nreturn pcxhr_check_reg_bit(mgr, PCXHR_PLX_MBOX0, PCXHR_MBOX0_HF5,\r\nPCXHR_MBOX0_HF5, PCXHR_TIMEOUT_DSP, &dummy);\r\n}\r\nint pcxhr_load_dsp_binary(struct pcxhr_mgr *mgr, const struct firmware *dsp)\r\n{\r\nint err;\r\nunsigned char dummy;\r\nerr = pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_BOARD_FUNC, 0);\r\nif (err)\r\nreturn err;\r\nerr = pcxhr_send_it_dsp(mgr, PCXHR_IT_DOWNLOAD_DSP, 0);\r\nif (err)\r\nreturn err;\r\nerr = pcxhr_download_dsp(mgr, dsp);\r\nif (err)\r\nreturn err;\r\nreturn pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\r\nPCXHR_ISR_HI08_CHK,\r\nPCXHR_ISR_HI08_CHK,\r\nPCXHR_TIMEOUT_DSP, &dummy);\r\n}\r\nstatic int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)\r\n{\r\nint err;\r\nint i;\r\nu32 data;\r\nu32 size_mask;\r\nunsigned char reg;\r\nint max_stat_len;\r\nif (rmh->stat_len < PCXHR_SIZE_MAX_STATUS)\r\nmax_stat_len = PCXHR_SIZE_MAX_STATUS;\r\nelse max_stat_len = rmh->stat_len;\r\nfor (i = 0; i < rmh->stat_len; i++) {\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\r\nPCXHR_ISR_HI08_RXDF,\r\nPCXHR_ISR_HI08_RXDF,\r\nPCXHR_TIMEOUT_DSP, &reg);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"ERROR RMH stat: ISR:RXDF=1 (ISR = %x; i=%d )\n",\r\nreg, i);\r\nreturn err;\r\n}\r\ndata = PCXHR_INPB(mgr, PCXHR_DSP_TXH) << 16;\r\ndata |= PCXHR_INPB(mgr, PCXHR_DSP_TXM) << 8;\r\ndata |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);\r\nif (!i) {\r\nif (rmh->dsp_stat != RMH_SSIZE_FIXED) {\r\nif (rmh->dsp_stat == RMH_SSIZE_ARG) {\r\nrmh->stat_len = (data & 0x0000ff) + 1;\r\ndata &= 0xffff00;\r\n} else {\r\nrmh->stat_len = 1;\r\nsize_mask = data;\r\nwhile (size_mask) {\r\nif (size_mask & 1)\r\nrmh->stat_len++;\r\nsize_mask >>= 1;\r\n}\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nif (rmh->cmd_idx < CMD_LAST_INDEX)\r\ndev_dbg(&mgr->pci->dev, " stat[%d]=%x\n", i, data);\r\n#endif\r\nif (i < max_stat_len)\r\nrmh->stat[i] = data;\r\n}\r\nif (rmh->stat_len > max_stat_len) {\r\ndev_dbg(&mgr->pci->dev, "PCXHR : rmh->stat_len=%x too big\n",\r\nrmh->stat_len);\r\nrmh->stat_len = max_stat_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)\r\n{\r\nint err;\r\nint i;\r\nu32 data;\r\nunsigned char reg;\r\nif (snd_BUG_ON(rmh->cmd_len >= PCXHR_SIZE_MAX_CMD))\r\nreturn -EINVAL;\r\nerr = pcxhr_send_it_dsp(mgr, PCXHR_IT_MESSAGE, 1);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"pcxhr_send_message : ED_DSP_CRASHED\n");\r\nreturn err;\r\n}\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,\r\nPCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);\r\nif (err)\r\nreturn err;\r\nerr = pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_CHK, 1);\r\nif (err)\r\nreturn err;\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK, 0,\r\nPCXHR_TIMEOUT_DSP, &reg);\r\nif (err)\r\nreturn err;\r\ndata = rmh->cmd[0];\r\nif (rmh->cmd_len > 1)\r\ndata |= 0x008000;\r\nelse\r\ndata &= 0xff7fff;\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nif (rmh->cmd_idx < CMD_LAST_INDEX)\r\ndev_dbg(&mgr->pci->dev, "MSG cmd[0]=%x (%s)\n",\r\ndata, cmd_names[rmh->cmd_idx]);\r\n#endif\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,\r\nPCXHR_ISR_HI08_TRDY, PCXHR_TIMEOUT_DSP, &reg);\r\nif (err)\r\nreturn err;\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));\r\nif (rmh->cmd_len > 1) {\r\ndata = rmh->cmd_len - 1;\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\r\nPCXHR_ISR_HI08_TRDY,\r\nPCXHR_ISR_HI08_TRDY,\r\nPCXHR_TIMEOUT_DSP, &reg);\r\nif (err)\r\nreturn err;\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));\r\nfor (i=1; i < rmh->cmd_len; i++) {\r\ndata = rmh->cmd[i];\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nif (rmh->cmd_idx < CMD_LAST_INDEX)\r\ndev_dbg(&mgr->pci->dev,\r\n" cmd[%d]=%x\n", i, data);\r\n#endif\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\r\nPCXHR_ISR_HI08_TRDY,\r\nPCXHR_ISR_HI08_TRDY,\r\nPCXHR_TIMEOUT_DSP, &reg);\r\nif (err)\r\nreturn err;\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));\r\n}\r\n}\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,\r\nPCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);\r\nif (err)\r\nreturn err;\r\nif (reg & PCXHR_ISR_HI08_ERR) {\r\nerr = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,\r\nPCXHR_ISR_HI08_RXDF,\r\nPCXHR_ISR_HI08_RXDF,\r\nPCXHR_TIMEOUT_DSP, &reg);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"ERROR RMH: ISR:RXDF=1 (ISR = %x)\n", reg);\r\nreturn err;\r\n}\r\ndata = PCXHR_INPB(mgr, PCXHR_DSP_TXH) << 16;\r\ndata |= PCXHR_INPB(mgr, PCXHR_DSP_TXM) << 8;\r\ndata |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);\r\ndev_err(&mgr->pci->dev, "ERROR RMH(%d): 0x%x\n",\r\nrmh->cmd_idx, data);\r\nerr = -EINVAL;\r\n} else {\r\nerr = pcxhr_read_rmh_status(mgr, rmh);\r\n}\r\nif (pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_SEMAPHORE, 1) < 0)\r\nreturn -EIO;\r\nreturn err;\r\n}\r\nvoid pcxhr_init_rmh(struct pcxhr_rmh *rmh, int cmd)\r\n{\r\nif (snd_BUG_ON(cmd >= CMD_LAST_INDEX))\r\nreturn;\r\nrmh->cmd[0] = pcxhr_dsp_cmds[cmd].opcode;\r\nrmh->cmd_len = 1;\r\nrmh->stat_len = pcxhr_dsp_cmds[cmd].st_length;\r\nrmh->dsp_stat = pcxhr_dsp_cmds[cmd].st_type;\r\nrmh->cmd_idx = cmd;\r\n}\r\nvoid pcxhr_set_pipe_cmd_params(struct pcxhr_rmh *rmh, int capture,\r\nunsigned int param1, unsigned int param2,\r\nunsigned int param3)\r\n{\r\nsnd_BUG_ON(param1 > MASK_FIRST_FIELD);\r\nif (capture)\r\nrmh->cmd[0] |= 0x800;\r\nif (param1)\r\nrmh->cmd[0] |= (param1 << FIELD_SIZE);\r\nif (param2) {\r\nsnd_BUG_ON(param2 > MASK_FIRST_FIELD);\r\nrmh->cmd[0] |= param2;\r\n}\r\nif(param3) {\r\nsnd_BUG_ON(param3 > MASK_DSP_WORD);\r\nrmh->cmd[1] = param3;\r\nrmh->cmd_len = 2;\r\n}\r\n}\r\nint pcxhr_send_msg(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)\r\n{\r\nint err;\r\nmutex_lock(&mgr->msg_lock);\r\nerr = pcxhr_send_msg_nolock(mgr, rmh);\r\nmutex_unlock(&mgr->msg_lock);\r\nreturn err;\r\n}\r\nstatic inline int pcxhr_pipes_running(struct pcxhr_mgr *mgr)\r\n{\r\nint start_mask = PCXHR_INPL(mgr, PCXHR_PLX_MBOX2);\r\nstart_mask &= 0xffffff;\r\ndev_dbg(&mgr->pci->dev, "CMD_PIPE_STATE MBOX2=0x%06x\n", start_mask);\r\nreturn start_mask;\r\n}\r\nstatic int pcxhr_prepair_pipe_start(struct pcxhr_mgr *mgr,\r\nint audio_mask, int *retry)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nint err;\r\nint audio = 0;\r\n*retry = 0;\r\nwhile (audio_mask) {\r\nif (audio_mask & 1) {\r\npcxhr_init_rmh(&rmh, CMD_CAN_START_PIPE);\r\nif (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET) {\r\npcxhr_set_pipe_cmd_params(&rmh, 0, audio, 0, 0);\r\n} else {\r\npcxhr_set_pipe_cmd_params(&rmh, 1, audio -\r\nPCXHR_PIPE_STATE_CAPTURE_OFFSET,\r\n0, 0);\r\n}\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"error pipe start "\r\n"(CMD_CAN_START_PIPE) err=%x!\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (rmh.stat[0] == 0)\r\n*retry |= (1<<audio);\r\n}\r\naudio_mask>>=1;\r\naudio++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_stop_pipes(struct pcxhr_mgr *mgr, int audio_mask)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nint err;\r\nint audio = 0;\r\nwhile (audio_mask) {\r\nif (audio_mask & 1) {\r\npcxhr_init_rmh(&rmh, CMD_STOP_PIPE);\r\nif (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET) {\r\npcxhr_set_pipe_cmd_params(&rmh, 0, audio, 0, 0);\r\n} else {\r\npcxhr_set_pipe_cmd_params(&rmh, 1, audio -\r\nPCXHR_PIPE_STATE_CAPTURE_OFFSET,\r\n0, 0);\r\n}\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"error pipe stop "\r\n"(CMD_STOP_PIPE) err=%x!\n", err);\r\nreturn err;\r\n}\r\n}\r\naudio_mask>>=1;\r\naudio++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_toggle_pipes(struct pcxhr_mgr *mgr, int audio_mask)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nint err;\r\nint audio = 0;\r\nwhile (audio_mask) {\r\nif (audio_mask & 1) {\r\npcxhr_init_rmh(&rmh, CMD_CONF_PIPE);\r\nif (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET)\r\npcxhr_set_pipe_cmd_params(&rmh, 0, 0, 0,\r\n1 << audio);\r\nelse\r\npcxhr_set_pipe_cmd_params(&rmh, 1, 0, 0,\r\n1 << (audio - PCXHR_PIPE_STATE_CAPTURE_OFFSET));\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"error pipe start "\r\n"(CMD_CONF_PIPE) err=%x!\n", err);\r\nreturn err;\r\n}\r\n}\r\naudio_mask>>=1;\r\naudio++;\r\n}\r\npcxhr_init_rmh(&rmh, CMD_SEND_IRQA);\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err) {\r\ndev_err(&mgr->pci->dev,\r\n"error pipe start (CMD_SEND_IRQA) err=%x!\n",\r\nerr);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask,\r\nint capture_mask, int start)\r\n{\r\nint state, i, err;\r\nint audio_mask;\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nktime_t start_time, stop_time, diff_time;\r\nstart_time = ktime_get();\r\n#endif\r\naudio_mask = (playback_mask |\r\n(capture_mask << PCXHR_PIPE_STATE_CAPTURE_OFFSET));\r\nstate = pcxhr_pipes_running(mgr);\r\ndev_dbg(&mgr->pci->dev,\r\n"pcxhr_set_pipe_state %s (mask %x current %x)\n",\r\nstart ? "START" : "STOP", audio_mask, state);\r\nif (start) {\r\naudio_mask &= ~state;\r\nstate = audio_mask;\r\nfor (i = 0; i < MAX_WAIT_FOR_DSP; i++) {\r\nerr = pcxhr_prepair_pipe_start(mgr, state, &state);\r\nif (err)\r\nreturn err;\r\nif (state == 0)\r\nbreak;\r\nmdelay(1);\r\n}\r\n} else {\r\naudio_mask &= state;\r\n}\r\nif (audio_mask == 0)\r\nreturn 0;\r\nerr = pcxhr_toggle_pipes(mgr, audio_mask);\r\nif (err)\r\nreturn err;\r\ni = 0;\r\nwhile (1) {\r\nstate = pcxhr_pipes_running(mgr);\r\nif ((state & audio_mask) == (start ? audio_mask : 0))\r\nbreak;\r\nif (++i >= MAX_WAIT_FOR_DSP * 100) {\r\ndev_err(&mgr->pci->dev, "error pipe start/stop\n");\r\nreturn -EBUSY;\r\n}\r\nudelay(10);\r\n}\r\nif (!start) {\r\nerr = pcxhr_stop_pipes(mgr, audio_mask);\r\nif (err)\r\nreturn err;\r\n}\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nstop_time = ktime_get();\r\ndiff_time = ktime_sub(stop_time, start_time);\r\ndev_dbg(&mgr->pci->dev, "***SET PIPE STATE*** TIME = %ld (err = %x)\n",\r\n(long)(ktime_to_ns(diff_time)), err);\r\n#endif\r\nreturn 0;\r\n}\r\nint pcxhr_write_io_num_reg_cont(struct pcxhr_mgr *mgr, unsigned int mask,\r\nunsigned int value, int *changed)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nint err;\r\nmutex_lock(&mgr->msg_lock);\r\nif ((mgr->io_num_reg_cont & mask) == value) {\r\ndev_dbg(&mgr->pci->dev,\r\n"IO_NUM_REG_CONT mask %x already is set to %x\n",\r\nmask, value);\r\nif (changed)\r\n*changed = 0;\r\nmutex_unlock(&mgr->msg_lock);\r\nreturn 0;\r\n}\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nrmh.cmd[0] |= IO_NUM_REG_CONT;\r\nrmh.cmd[1] = mask;\r\nrmh.cmd[2] = value;\r\nrmh.cmd_len = 3;\r\nerr = pcxhr_send_msg_nolock(mgr, &rmh);\r\nif (err == 0) {\r\nmgr->io_num_reg_cont &= ~mask;\r\nmgr->io_num_reg_cont |= value;\r\nif (changed)\r\n*changed = 1;\r\n}\r\nmutex_unlock(&mgr->msg_lock);\r\nreturn err;\r\n}\r\nstatic int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,\r\nenum pcxhr_async_err_src err_src, int pipe,\r\nint is_capture)\r\n{\r\nstatic char* err_src_name[] = {\r\n[PCXHR_ERR_PIPE] = "Pipe",\r\n[PCXHR_ERR_STREAM] = "Stream",\r\n[PCXHR_ERR_AUDIO] = "Audio"\r\n};\r\nif (err & 0xfff)\r\nerr &= 0xfff;\r\nelse\r\nerr = ((err >> 12) & 0xfff);\r\nif (!err)\r\nreturn 0;\r\ndev_dbg(&mgr->pci->dev, "CMD_ASYNC : Error %s %s Pipe %d err=%x\n",\r\nerr_src_name[err_src],\r\nis_capture ? "Record" : "Play", pipe, err);\r\nif (err == 0xe01)\r\nmgr->async_err_stream_xrun++;\r\nelse if (err == 0xe10)\r\nmgr->async_err_pipe_xrun++;\r\nelse\r\nmgr->async_err_other_last = (int)err;\r\nreturn 1;\r\n}\r\nstatic void pcxhr_msg_thread(struct pcxhr_mgr *mgr)\r\n{\r\nstruct pcxhr_rmh *prmh = mgr->prmh;\r\nint err;\r\nint i, j;\r\nif (mgr->src_it_dsp & PCXHR_IRQ_FREQ_CHANGE)\r\ndev_dbg(&mgr->pci->dev,\r\n"PCXHR_IRQ_FREQ_CHANGE event occurred\n");\r\nif (mgr->src_it_dsp & PCXHR_IRQ_TIME_CODE)\r\ndev_dbg(&mgr->pci->dev,\r\n"PCXHR_IRQ_TIME_CODE event occurred\n");\r\nif (mgr->src_it_dsp & PCXHR_IRQ_NOTIFY)\r\ndev_dbg(&mgr->pci->dev,\r\n"PCXHR_IRQ_NOTIFY event occurred\n");\r\nif (mgr->src_it_dsp & (PCXHR_IRQ_FREQ_CHANGE | PCXHR_IRQ_TIME_CODE)) {\r\npcxhr_init_rmh(prmh, CMD_TEST_IT);\r\nerr = pcxhr_send_msg(mgr, prmh);\r\ndev_dbg(&mgr->pci->dev, "CMD_TEST_IT : err=%x, stat=%x\n",\r\nerr, prmh->stat[0]);\r\n}\r\nif (mgr->src_it_dsp & PCXHR_IRQ_ASYNC) {\r\ndev_dbg(&mgr->pci->dev,\r\n"PCXHR_IRQ_ASYNC event occurred\n");\r\npcxhr_init_rmh(prmh, CMD_ASYNC);\r\nprmh->cmd[0] |= 1;\r\nprmh->stat_len = PCXHR_SIZE_MAX_LONG_STATUS;\r\nerr = pcxhr_send_msg(mgr, prmh);\r\nif (err)\r\ndev_err(&mgr->pci->dev, "ERROR pcxhr_msg_thread=%x;\n",\r\nerr);\r\ni = 1;\r\nwhile (i < prmh->stat_len) {\r\nint nb_audio = ((prmh->stat[i] >> FIELD_SIZE) &\r\nMASK_FIRST_FIELD);\r\nint nb_stream = ((prmh->stat[i] >> (2*FIELD_SIZE)) &\r\nMASK_FIRST_FIELD);\r\nint pipe = prmh->stat[i] & MASK_FIRST_FIELD;\r\nint is_capture = prmh->stat[i] & 0x400000;\r\nu32 err2;\r\nif (prmh->stat[i] & 0x800000) {\r\ndev_dbg(&mgr->pci->dev,\r\n"TASKLET : End%sPipe %d\n",\r\nis_capture ? "Record" : "Play",\r\npipe);\r\n}\r\ni++;\r\nerr2 = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];\r\nif (err2)\r\npcxhr_handle_async_err(mgr, err2,\r\nPCXHR_ERR_PIPE,\r\npipe, is_capture);\r\ni += 2;\r\nfor (j = 0; j < nb_stream; j++) {\r\nerr2 = prmh->stat[i] ?\r\nprmh->stat[i] : prmh->stat[i+1];\r\nif (err2)\r\npcxhr_handle_async_err(mgr, err2,\r\nPCXHR_ERR_STREAM,\r\npipe,\r\nis_capture);\r\ni += 2;\r\n}\r\nfor (j = 0; j < nb_audio; j++) {\r\nerr2 = prmh->stat[i] ?\r\nprmh->stat[i] : prmh->stat[i+1];\r\nif (err2)\r\npcxhr_handle_async_err(mgr, err2,\r\nPCXHR_ERR_AUDIO,\r\npipe,\r\nis_capture);\r\ni += 2;\r\n}\r\n}\r\n}\r\n}\r\nstatic u_int64_t pcxhr_stream_read_position(struct pcxhr_mgr *mgr,\r\nstruct pcxhr_stream *stream)\r\n{\r\nu_int64_t hw_sample_count;\r\nstruct pcxhr_rmh rmh;\r\nint err, stream_mask;\r\nstream_mask = stream->pipe->is_capture ? 1 : 1<<stream->substream->number;\r\npcxhr_init_rmh(&rmh, CMD_STREAM_SAMPLE_COUNT);\r\npcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture,\r\nstream->pipe->first_audio, 0, stream_mask);\r\nerr = pcxhr_send_msg(mgr, &rmh);\r\nif (err)\r\nreturn 0;\r\nhw_sample_count = ((u_int64_t)rmh.stat[0]) << 24;\r\nhw_sample_count += (u_int64_t)rmh.stat[1];\r\ndev_dbg(&mgr->pci->dev,\r\n"stream %c%d : abs samples real(%llu) timer(%llu)\n",\r\nstream->pipe->is_capture ? 'C' : 'P',\r\nstream->substream->number,\r\nhw_sample_count,\r\nstream->timer_abs_periods + stream->timer_period_frag +\r\nmgr->granularity);\r\nreturn hw_sample_count;\r\n}\r\nstatic void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,\r\nstruct pcxhr_stream *stream,\r\nint samples_to_add)\r\n{\r\nif (stream->substream &&\r\n(stream->status == PCXHR_STREAM_STATUS_RUNNING)) {\r\nu_int64_t new_sample_count;\r\nint elapsed = 0;\r\nint hardware_read = 0;\r\nstruct snd_pcm_runtime *runtime = stream->substream->runtime;\r\nif (samples_to_add < 0) {\r\nstream->timer_is_synced = 0;\r\nsamples_to_add = mgr->granularity;\r\n}\r\nif (!stream->timer_is_synced) {\r\nif ((stream->timer_abs_periods != 0) ||\r\n((stream->timer_period_frag + samples_to_add) >=\r\nruntime->period_size)) {\r\nnew_sample_count =\r\npcxhr_stream_read_position(mgr, stream);\r\nhardware_read = 1;\r\nif (new_sample_count >= mgr->granularity) {\r\nnew_sample_count -= mgr->granularity;\r\nstream->timer_is_synced = 1;\r\n}\r\n}\r\n}\r\nif (!hardware_read) {\r\nnew_sample_count = stream->timer_abs_periods +\r\nstream->timer_period_frag + samples_to_add;\r\n}\r\nwhile (1) {\r\nu_int64_t new_elapse_pos = stream->timer_abs_periods +\r\nruntime->period_size;\r\nif (new_elapse_pos > new_sample_count)\r\nbreak;\r\nelapsed = 1;\r\nstream->timer_buf_periods++;\r\nif (stream->timer_buf_periods >= runtime->periods)\r\nstream->timer_buf_periods = 0;\r\nstream->timer_abs_periods = new_elapse_pos;\r\n}\r\nif (new_sample_count >= stream->timer_abs_periods) {\r\nstream->timer_period_frag =\r\n(u_int32_t)(new_sample_count -\r\nstream->timer_abs_periods);\r\n} else {\r\ndev_err(&mgr->pci->dev,\r\n"ERROR new_sample_count too small ??? %ld\n",\r\n(long unsigned int)new_sample_count);\r\n}\r\nif (elapsed) {\r\nmutex_unlock(&mgr->lock);\r\nsnd_pcm_period_elapsed(stream->substream);\r\nmutex_lock(&mgr->lock);\r\n}\r\n}\r\n}\r\nirqreturn_t pcxhr_interrupt(int irq, void *dev_id)\r\n{\r\nstruct pcxhr_mgr *mgr = dev_id;\r\nunsigned int reg;\r\nbool wake_thread = false;\r\nreg = PCXHR_INPL(mgr, PCXHR_PLX_IRQCS);\r\nif (! (reg & PCXHR_IRQCS_ACTIVE_PCIDB)) {\r\nreturn IRQ_NONE;\r\n}\r\nreg = PCXHR_INPL(mgr, PCXHR_PLX_L2PCIDB);\r\nPCXHR_OUTPL(mgr, PCXHR_PLX_L2PCIDB, reg);\r\nif (reg & PCXHR_IRQ_TIMER) {\r\nint timer_toggle = reg & PCXHR_IRQ_TIMER;\r\nif (timer_toggle == mgr->timer_toggle) {\r\ndev_dbg(&mgr->pci->dev, "ERROR TIMER TOGGLE\n");\r\nmgr->dsp_time_err++;\r\n}\r\nmgr->timer_toggle = timer_toggle;\r\nmgr->src_it_dsp = reg;\r\nwake_thread = true;\r\n}\r\nif (reg & PCXHR_IRQ_MASK) {\r\nif (reg & PCXHR_IRQ_ASYNC) {\r\nmgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;\r\n}\r\nmgr->src_it_dsp = reg;\r\nwake_thread = true;\r\n}\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nif (reg & PCXHR_FATAL_DSP_ERR)\r\ndev_dbg(&mgr->pci->dev, "FATAL DSP ERROR : %x\n", reg);\r\n#endif\r\nreturn wake_thread ? IRQ_WAKE_THREAD : IRQ_HANDLED;\r\n}\r\nirqreturn_t pcxhr_threaded_irq(int irq, void *dev_id)\r\n{\r\nstruct pcxhr_mgr *mgr = dev_id;\r\nint i, j;\r\nstruct snd_pcxhr *chip;\r\nmutex_lock(&mgr->lock);\r\nif (mgr->src_it_dsp & PCXHR_IRQ_TIMER) {\r\nint dsp_time_new =\r\nPCXHR_INPL(mgr, PCXHR_PLX_MBOX4) & PCXHR_DSP_TIME_MASK;\r\nint dsp_time_diff = dsp_time_new - mgr->dsp_time_last;\r\nif ((dsp_time_diff < 0) &&\r\n(mgr->dsp_time_last != PCXHR_DSP_TIME_INVALID)) {\r\nint tmp_diff = dsp_time_diff + PCXHR_DSP_TIME_MASK + 1;\r\ndev_dbg(&mgr->pci->dev,\r\n"WARNING DSP timestamp old(%d) new(%d)",\r\nmgr->dsp_time_last, dsp_time_new);\r\nif (tmp_diff > 0 && tmp_diff <= (2*mgr->granularity)) {\r\ndev_dbg(&mgr->pci->dev,\r\n"-> timestamp wraparound OK: "\r\n"diff=%d\n", tmp_diff);\r\ndsp_time_diff = tmp_diff;\r\n} else {\r\ndev_dbg(&mgr->pci->dev,\r\n"-> resynchronize all streams\n");\r\nmgr->dsp_time_err++;\r\n}\r\n}\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nif (dsp_time_diff == 0)\r\ndev_dbg(&mgr->pci->dev,\r\n"ERROR DSP TIME NO DIFF time(%d)\n",\r\ndsp_time_new);\r\nelse if (dsp_time_diff >= (2*mgr->granularity))\r\ndev_dbg(&mgr->pci->dev,\r\n"ERROR DSP TIME TOO BIG old(%d) add(%d)\n",\r\nmgr->dsp_time_last,\r\ndsp_time_new - mgr->dsp_time_last);\r\nelse if (dsp_time_diff % mgr->granularity)\r\ndev_dbg(&mgr->pci->dev,\r\n"ERROR DSP TIME increased by %d\n",\r\ndsp_time_diff);\r\n#endif\r\nmgr->dsp_time_last = dsp_time_new;\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nchip = mgr->chip[i];\r\nfor (j = 0; j < chip->nb_streams_capt; j++)\r\npcxhr_update_timer_pos(mgr,\r\n&chip->capture_stream[j],\r\ndsp_time_diff);\r\n}\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nchip = mgr->chip[i];\r\nfor (j = 0; j < chip->nb_streams_play; j++)\r\npcxhr_update_timer_pos(mgr,\r\n&chip->playback_stream[j],\r\ndsp_time_diff);\r\n}\r\n}\r\npcxhr_msg_thread(mgr);\r\nmutex_unlock(&mgr->lock);\r\nreturn IRQ_HANDLED;\r\n}
