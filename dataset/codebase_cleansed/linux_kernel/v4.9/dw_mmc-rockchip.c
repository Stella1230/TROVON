static void dw_mci_rk3288_set_ios(struct dw_mci *host, struct mmc_ios *ios)\r\n{\r\nstruct dw_mci_rockchip_priv_data *priv = host->priv;\r\nint ret;\r\nunsigned int cclkin;\r\nu32 bus_hz;\r\nif (ios->clock == 0)\r\nreturn;\r\nif (ios->bus_width == MMC_BUS_WIDTH_8 &&\r\nios->timing == MMC_TIMING_MMC_DDR52)\r\ncclkin = 2 * ios->clock * RK3288_CLKGEN_DIV;\r\nelse\r\ncclkin = ios->clock * RK3288_CLKGEN_DIV;\r\nret = clk_set_rate(host->ciu_clk, cclkin);\r\nif (ret)\r\ndev_warn(host->dev, "failed to set rate %uHz\n", ios->clock);\r\nbus_hz = clk_get_rate(host->ciu_clk) / RK3288_CLKGEN_DIV;\r\nif (bus_hz != host->bus_hz) {\r\nhost->bus_hz = bus_hz;\r\nhost->current_speed = 0;\r\n}\r\nif (!IS_ERR(priv->sample_clk))\r\nclk_set_phase(priv->sample_clk, priv->default_sample_phase);\r\nif (!IS_ERR(priv->drv_clk)) {\r\nint phase;\r\nphase = 90;\r\nswitch (ios->timing) {\r\ncase MMC_TIMING_MMC_DDR52:\r\nif (ios->bus_width == MMC_BUS_WIDTH_8)\r\nphase = 180;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR104:\r\ncase MMC_TIMING_MMC_HS200:\r\nphase = 180;\r\nbreak;\r\n}\r\nclk_set_phase(priv->drv_clk, phase);\r\n}\r\n}\r\nstatic int dw_mci_rk3288_execute_tuning(struct dw_mci_slot *slot, u32 opcode)\r\n{\r\nstruct dw_mci *host = slot->host;\r\nstruct dw_mci_rockchip_priv_data *priv = host->priv;\r\nstruct mmc_host *mmc = slot->mmc;\r\nint ret = 0;\r\nint i;\r\nbool v, prev_v = 0, first_v;\r\nstruct range_t {\r\nint start;\r\nint end;\r\n};\r\nstruct range_t *ranges;\r\nunsigned int range_count = 0;\r\nint longest_range_len = -1;\r\nint longest_range = -1;\r\nint middle_phase;\r\nif (IS_ERR(priv->sample_clk)) {\r\ndev_err(host->dev, "Tuning clock (sample_clk) not defined.\n");\r\nreturn -EIO;\r\n}\r\nranges = kmalloc_array(NUM_PHASES / 2 + 1, sizeof(*ranges), GFP_KERNEL);\r\nif (!ranges)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < NUM_PHASES; ) {\r\nclk_set_phase(priv->sample_clk, TUNING_ITERATION_TO_PHASE(i));\r\nv = !mmc_send_tuning(mmc, opcode, NULL);\r\nif (i == 0)\r\nfirst_v = v;\r\nif ((!prev_v) && v) {\r\nrange_count++;\r\nranges[range_count-1].start = i;\r\n}\r\nif (v) {\r\nranges[range_count-1].end = i;\r\ni++;\r\n} else if (i == NUM_PHASES - 1) {\r\ni++;\r\n} else {\r\ni += DIV_ROUND_UP(20 * NUM_PHASES, 360);\r\nif (i >= NUM_PHASES)\r\ni = NUM_PHASES - 1;\r\n}\r\nprev_v = v;\r\n}\r\nif (range_count == 0) {\r\ndev_warn(host->dev, "All phases bad!");\r\nret = -EIO;\r\ngoto free;\r\n}\r\nif ((range_count > 1) && first_v && v) {\r\nranges[0].start = ranges[range_count-1].start;\r\nrange_count--;\r\n}\r\nif (ranges[0].start == 0 && ranges[0].end == NUM_PHASES - 1) {\r\nclk_set_phase(priv->sample_clk, priv->default_sample_phase);\r\ndev_info(host->dev, "All phases work, using default phase %d.",\r\npriv->default_sample_phase);\r\ngoto free;\r\n}\r\nfor (i = 0; i < range_count; i++) {\r\nint len = (ranges[i].end - ranges[i].start + 1);\r\nif (len < 0)\r\nlen += NUM_PHASES;\r\nif (longest_range_len < len) {\r\nlongest_range_len = len;\r\nlongest_range = i;\r\n}\r\ndev_dbg(host->dev, "Good phase range %d-%d (%d len)\n",\r\nTUNING_ITERATION_TO_PHASE(ranges[i].start),\r\nTUNING_ITERATION_TO_PHASE(ranges[i].end),\r\nlen\r\n);\r\n}\r\ndev_dbg(host->dev, "Best phase range %d-%d (%d len)\n",\r\nTUNING_ITERATION_TO_PHASE(ranges[longest_range].start),\r\nTUNING_ITERATION_TO_PHASE(ranges[longest_range].end),\r\nlongest_range_len\r\n);\r\nmiddle_phase = ranges[longest_range].start + longest_range_len / 2;\r\nmiddle_phase %= NUM_PHASES;\r\ndev_info(host->dev, "Successfully tuned phase to %d\n",\r\nTUNING_ITERATION_TO_PHASE(middle_phase));\r\nclk_set_phase(priv->sample_clk,\r\nTUNING_ITERATION_TO_PHASE(middle_phase));\r\nfree:\r\nkfree(ranges);\r\nreturn ret;\r\n}\r\nstatic int dw_mci_rk3288_parse_dt(struct dw_mci *host)\r\n{\r\nstruct device_node *np = host->dev->of_node;\r\nstruct dw_mci_rockchip_priv_data *priv;\r\npriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(np, "rockchip,default-sample-phase",\r\n&priv->default_sample_phase))\r\npriv->default_sample_phase = 0;\r\npriv->drv_clk = devm_clk_get(host->dev, "ciu-drive");\r\nif (IS_ERR(priv->drv_clk))\r\ndev_dbg(host->dev, "ciu_drv not available\n");\r\npriv->sample_clk = devm_clk_get(host->dev, "ciu-sample");\r\nif (IS_ERR(priv->sample_clk))\r\ndev_dbg(host->dev, "ciu_sample not available\n");\r\nhost->priv = priv;\r\nreturn 0;\r\n}\r\nstatic int dw_mci_rockchip_init(struct dw_mci *host)\r\n{\r\nhost->sdio_id0 = 8;\r\nif (of_device_is_compatible(host->dev->of_node,\r\n"rockchip,rk3288-dw-mshc"))\r\nhost->bus_hz /= RK3288_CLKGEN_DIV;\r\nreturn 0;\r\n}\r\nstatic int dw_mci_rockchip_probe(struct platform_device *pdev)\r\n{\r\nconst struct dw_mci_drv_data *drv_data;\r\nconst struct of_device_id *match;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nmatch = of_match_node(dw_mci_rockchip_match, pdev->dev.of_node);\r\ndrv_data = match->data;\r\nreturn dw_mci_pltfm_register(pdev, drv_data);\r\n}
