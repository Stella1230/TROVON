static void dc_link_event(struct ipu_dc *dc, int event, int addr, int priority)\r\n{\r\nu32 reg;\r\nreg = readl(dc->base + DC_RL_CH(event));\r\nreg &= ~(0xffff << (16 * (event & 0x1)));\r\nreg |= ((addr << 8) | priority) << (16 * (event & 0x1));\r\nwritel(reg, dc->base + DC_RL_CH(event));\r\n}\r\nstatic void dc_write_tmpl(struct ipu_dc *dc, int word, u32 opcode, u32 operand,\r\nint map, int wave, int glue, int sync, int stop)\r\n{\r\nstruct ipu_dc_priv *priv = dc->priv;\r\nu32 reg1, reg2;\r\nif (opcode == WCLK) {\r\nreg1 = (operand << 20) & 0xfff00000;\r\nreg2 = operand >> 12 | opcode << 1 | stop << 9;\r\n} else if (opcode == WRG) {\r\nreg1 = sync | glue << 4 | ++wave << 11 | ((operand << 15) & 0xffff8000);\r\nreg2 = operand >> 17 | opcode << 7 | stop << 9;\r\n} else {\r\nreg1 = sync | glue << 4 | ++wave << 11 | ++map << 15 | ((operand << 20) & 0xfff00000);\r\nreg2 = operand >> 12 | opcode << 4 | stop << 9;\r\n}\r\nwritel(reg1, priv->dc_tmpl_reg + word * 8);\r\nwritel(reg2, priv->dc_tmpl_reg + word * 8 + 4);\r\n}\r\nstatic int ipu_bus_format_to_map(u32 fmt)\r\n{\r\nswitch (fmt) {\r\ndefault:\r\nWARN_ON(1);\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\nreturn IPU_DC_MAP_RGB24;\r\ncase MEDIA_BUS_FMT_RGB565_1X16:\r\nreturn IPU_DC_MAP_RGB565;\r\ncase MEDIA_BUS_FMT_GBR888_1X24:\r\nreturn IPU_DC_MAP_GBR24;\r\ncase MEDIA_BUS_FMT_RGB666_1X18:\r\nreturn IPU_DC_MAP_BGR666;\r\ncase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\r\nreturn IPU_DC_MAP_LVDS666;\r\ncase MEDIA_BUS_FMT_BGR888_1X24:\r\nreturn IPU_DC_MAP_BGR24;\r\n}\r\n}\r\nint ipu_dc_init_sync(struct ipu_dc *dc, struct ipu_di *di, bool interlaced,\r\nu32 bus_format, u32 width)\r\n{\r\nstruct ipu_dc_priv *priv = dc->priv;\r\nint addr, sync;\r\nu32 reg = 0;\r\nint map;\r\ndc->di = ipu_di_get_num(di);\r\nmap = ipu_bus_format_to_map(bus_format);\r\nsync = interlaced ? 6 : 5;\r\nif (dc->di)\r\naddr = 5;\r\nelse\r\naddr = 0;\r\nif (interlaced) {\r\ndc_link_event(dc, DC_EVT_NL, addr, 3);\r\ndc_link_event(dc, DC_EVT_EOL, addr, 2);\r\ndc_link_event(dc, DC_EVT_NEW_DATA, addr, 1);\r\ndc_write_tmpl(dc, addr, WROD(0), 0, map, SYNC_WAVE, 0, sync, 1);\r\n} else {\r\ndc_link_event(dc, DC_EVT_NL, addr + 2, 3);\r\ndc_link_event(dc, DC_EVT_EOL, addr + 3, 2);\r\ndc_link_event(dc, DC_EVT_NEW_DATA, addr + 1, 1);\r\ndc_write_tmpl(dc, addr + 2, WROD(0), 0, map, SYNC_WAVE, 8, sync, 1);\r\ndc_write_tmpl(dc, addr + 3, WROD(0), 0, map, SYNC_WAVE, 4, sync, 0);\r\ndc_write_tmpl(dc, addr + 4, WRG, 0, map, NULL_WAVE, 0, 0, 1);\r\ndc_write_tmpl(dc, addr + 1, WROD(0), 0, map, SYNC_WAVE, 0, sync, 1);\r\n}\r\ndc_link_event(dc, DC_EVT_NF, 0, 0);\r\ndc_link_event(dc, DC_EVT_NFIELD, 0, 0);\r\ndc_link_event(dc, DC_EVT_EOF, 0, 0);\r\ndc_link_event(dc, DC_EVT_EOFIELD, 0, 0);\r\ndc_link_event(dc, DC_EVT_NEW_CHAN, 0, 0);\r\ndc_link_event(dc, DC_EVT_NEW_ADDR, 0, 0);\r\nreg = readl(dc->base + DC_WR_CH_CONF);\r\nif (interlaced)\r\nreg |= DC_WR_CH_CONF_FIELD_MODE;\r\nelse\r\nreg &= ~DC_WR_CH_CONF_FIELD_MODE;\r\nwritel(reg, dc->base + DC_WR_CH_CONF);\r\nwritel(0x0, dc->base + DC_WR_CH_ADDR);\r\nwritel(width, priv->dc_reg + DC_DISP_CONF2(dc->di));\r\nreturn 0;\r\n}\r\nvoid ipu_dc_enable(struct ipu_soc *ipu)\r\n{\r\nstruct ipu_dc_priv *priv = ipu->dc_priv;\r\nmutex_lock(&priv->mutex);\r\nif (!priv->use_count)\r\nipu_module_enable(priv->ipu, IPU_CONF_DC_EN);\r\npriv->use_count++;\r\nmutex_unlock(&priv->mutex);\r\n}\r\nvoid ipu_dc_enable_channel(struct ipu_dc *dc)\r\n{\r\nint di;\r\nu32 reg;\r\ndi = dc->di;\r\nreg = readl(dc->base + DC_WR_CH_CONF);\r\nreg |= DC_WR_CH_CONF_PROG_TYPE_NORMAL;\r\nwritel(reg, dc->base + DC_WR_CH_CONF);\r\n}\r\nstatic irqreturn_t dc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct ipu_dc *dc = dev_id;\r\nu32 reg;\r\nreg = readl(dc->base + DC_WR_CH_CONF);\r\nreg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;\r\nwritel(reg, dc->base + DC_WR_CH_CONF);\r\ncomplete(&dc->priv->comp);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid ipu_dc_disable_channel(struct ipu_dc *dc)\r\n{\r\nstruct ipu_dc_priv *priv = dc->priv;\r\nint irq;\r\nunsigned long ret;\r\nu32 val;\r\nif (dc->chno == 1)\r\nirq = priv->dc_irq;\r\nelse if (dc->chno == 5)\r\nirq = priv->dp_irq;\r\nelse\r\nreturn;\r\ninit_completion(&priv->comp);\r\nenable_irq(irq);\r\nret = wait_for_completion_timeout(&priv->comp, msecs_to_jiffies(50));\r\ndisable_irq(irq);\r\nif (ret == 0) {\r\ndev_warn(priv->dev, "DC stop timeout after 50 ms\n");\r\nval = readl(dc->base + DC_WR_CH_CONF);\r\nval &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;\r\nwritel(val, dc->base + DC_WR_CH_CONF);\r\n}\r\n}\r\nvoid ipu_dc_disable(struct ipu_soc *ipu)\r\n{\r\nstruct ipu_dc_priv *priv = ipu->dc_priv;\r\nmutex_lock(&priv->mutex);\r\npriv->use_count--;\r\nif (!priv->use_count)\r\nipu_module_disable(priv->ipu, IPU_CONF_DC_EN);\r\nif (priv->use_count < 0)\r\npriv->use_count = 0;\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipu_dc_map_config(struct ipu_dc_priv *priv, enum ipu_dc_map map,\r\nint byte_num, int offset, int mask)\r\n{\r\nint ptr = map * 3 + byte_num;\r\nu32 reg;\r\nreg = readl(priv->dc_reg + DC_MAP_CONF_VAL(ptr));\r\nreg &= ~(0xffff << (16 * (ptr & 0x1)));\r\nreg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));\r\nwritel(reg, priv->dc_reg + DC_MAP_CONF_VAL(ptr));\r\nreg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));\r\nreg &= ~(0x1f << ((16 * (map & 0x1)) + (5 * byte_num)));\r\nreg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));\r\nwritel(reg, priv->dc_reg + DC_MAP_CONF_PTR(map));\r\n}\r\nstatic void ipu_dc_map_clear(struct ipu_dc_priv *priv, int map)\r\n{\r\nu32 reg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));\r\nwritel(reg & ~(0xffff << (16 * (map & 0x1))),\r\npriv->dc_reg + DC_MAP_CONF_PTR(map));\r\n}\r\nstruct ipu_dc *ipu_dc_get(struct ipu_soc *ipu, int channel)\r\n{\r\nstruct ipu_dc_priv *priv = ipu->dc_priv;\r\nstruct ipu_dc *dc;\r\nif (channel >= IPU_DC_NUM_CHANNELS)\r\nreturn ERR_PTR(-ENODEV);\r\ndc = &priv->channels[channel];\r\nmutex_lock(&priv->mutex);\r\nif (dc->in_use) {\r\nmutex_unlock(&priv->mutex);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\ndc->in_use = true;\r\nmutex_unlock(&priv->mutex);\r\nreturn dc;\r\n}\r\nvoid ipu_dc_put(struct ipu_dc *dc)\r\n{\r\nstruct ipu_dc_priv *priv = dc->priv;\r\nmutex_lock(&priv->mutex);\r\ndc->in_use = false;\r\nmutex_unlock(&priv->mutex);\r\n}\r\nint ipu_dc_init(struct ipu_soc *ipu, struct device *dev,\r\nunsigned long base, unsigned long template_base)\r\n{\r\nstruct ipu_dc_priv *priv;\r\nstatic int channel_offsets[] = { 0, 0x1c, 0x38, 0x54, 0x58, 0x5c,\r\n0x78, 0, 0x94, 0xb4};\r\nint i, ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->mutex);\r\npriv->dev = dev;\r\npriv->ipu = ipu;\r\npriv->dc_reg = devm_ioremap(dev, base, PAGE_SIZE);\r\npriv->dc_tmpl_reg = devm_ioremap(dev, template_base, PAGE_SIZE);\r\nif (!priv->dc_reg || !priv->dc_tmpl_reg)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < IPU_DC_NUM_CHANNELS; i++) {\r\npriv->channels[i].chno = i;\r\npriv->channels[i].priv = priv;\r\npriv->channels[i].base = priv->dc_reg + channel_offsets[i];\r\n}\r\npriv->dc_irq = ipu_map_irq(ipu, IPU_IRQ_DC_FC_1);\r\nif (!priv->dc_irq)\r\nreturn -EINVAL;\r\nret = devm_request_irq(dev, priv->dc_irq, dc_irq_handler, 0, NULL,\r\n&priv->channels[1]);\r\nif (ret < 0)\r\nreturn ret;\r\ndisable_irq(priv->dc_irq);\r\npriv->dp_irq = ipu_map_irq(ipu, IPU_IRQ_DP_SF_END);\r\nif (!priv->dp_irq)\r\nreturn -EINVAL;\r\nret = devm_request_irq(dev, priv->dp_irq, dc_irq_handler, 0, NULL,\r\n&priv->channels[5]);\r\nif (ret < 0)\r\nreturn ret;\r\ndisable_irq(priv->dp_irq);\r\nwritel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(1) |\r\nDC_WR_CH_CONF_PROG_DI_ID,\r\npriv->channels[1].base + DC_WR_CH_CONF);\r\nwritel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(0),\r\npriv->channels[5].base + DC_WR_CH_CONF);\r\nwritel(DC_GEN_SYNC_1_6_SYNC | DC_GEN_SYNC_PRIORITY_1,\r\npriv->dc_reg + DC_GEN);\r\nipu->dc_priv = priv;\r\ndev_dbg(dev, "DC base: 0x%08lx template base: 0x%08lx\n",\r\nbase, template_base);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_RGB24);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 0, 7, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 1, 15, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 2, 23, 0xff);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_RGB565);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 0, 4, 0xf8);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 1, 10, 0xfc);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 2, 15, 0xf8);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_GBR24);\r\nipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 2, 15, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 1, 7, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 0, 23, 0xff);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_BGR666);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 0, 5, 0xfc);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 1, 11, 0xfc);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 2, 17, 0xfc);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_LVDS666);\r\nipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 0, 5, 0xfc);\r\nipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 1, 13, 0xfc);\r\nipu_dc_map_config(priv, IPU_DC_MAP_LVDS666, 2, 21, 0xfc);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_BGR24);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 2, 7, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 1, 15, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR24, 0, 23, 0xff);\r\nreturn 0;\r\n}\r\nvoid ipu_dc_exit(struct ipu_soc *ipu)\r\n{\r\n}
