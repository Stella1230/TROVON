void vivid_cec_bus_free_work(struct vivid_dev *dev)\r\n{\r\nspin_lock(&dev->cec_slock);\r\nwhile (!list_empty(&dev->cec_work_list)) {\r\nstruct vivid_cec_work *cw =\r\nlist_first_entry(&dev->cec_work_list,\r\nstruct vivid_cec_work, list);\r\nspin_unlock(&dev->cec_slock);\r\ncancel_delayed_work_sync(&cw->work);\r\nspin_lock(&dev->cec_slock);\r\nlist_del(&cw->list);\r\ncec_transmit_done(cw->adap, CEC_TX_STATUS_LOW_DRIVE, 0, 0, 1, 0);\r\nkfree(cw);\r\n}\r\nspin_unlock(&dev->cec_slock);\r\n}\r\nstatic bool vivid_cec_find_dest_adap(struct vivid_dev *dev,\r\nstruct cec_adapter *adap, u8 dest)\r\n{\r\nunsigned int i;\r\nif (dest >= 0xf)\r\nreturn false;\r\nif (adap != dev->cec_rx_adap && dev->cec_rx_adap &&\r\ndev->cec_rx_adap->is_configured &&\r\ncec_has_log_addr(dev->cec_rx_adap, dest))\r\nreturn true;\r\nfor (i = 0; i < MAX_OUTPUTS && dev->cec_tx_adap[i]; i++) {\r\nif (adap == dev->cec_tx_adap[i])\r\ncontinue;\r\nif (!dev->cec_tx_adap[i]->is_configured)\r\ncontinue;\r\nif (cec_has_log_addr(dev->cec_tx_adap[i], dest))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void vivid_cec_xfer_done_worker(struct work_struct *work)\r\n{\r\nstruct vivid_cec_work *cw =\r\ncontainer_of(work, struct vivid_cec_work, work.work);\r\nstruct vivid_dev *dev = cw->dev;\r\nstruct cec_adapter *adap = cw->adap;\r\nu8 dest = cec_msg_destination(&cw->msg);\r\nbool valid_dest;\r\nunsigned int i;\r\nvalid_dest = cec_msg_is_broadcast(&cw->msg);\r\nif (!valid_dest)\r\nvalid_dest = vivid_cec_find_dest_adap(dev, adap, dest);\r\ncw->tx_status = valid_dest ? CEC_TX_STATUS_OK : CEC_TX_STATUS_NACK;\r\nspin_lock(&dev->cec_slock);\r\ndev->cec_xfer_time_jiffies = 0;\r\ndev->cec_xfer_start_jiffies = 0;\r\nlist_del(&cw->list);\r\nspin_unlock(&dev->cec_slock);\r\ncec_transmit_done(cw->adap, cw->tx_status, 0, valid_dest ? 0 : 1, 0, 0);\r\nif (adap != dev->cec_rx_adap)\r\ncec_received_msg(dev->cec_rx_adap, &cw->msg);\r\nfor (i = 0; i < MAX_OUTPUTS && dev->cec_tx_adap[i]; i++)\r\nif (adap != dev->cec_tx_adap[i])\r\ncec_received_msg(dev->cec_tx_adap[i], &cw->msg);\r\nkfree(cw);\r\n}\r\nstatic void vivid_cec_xfer_try_worker(struct work_struct *work)\r\n{\r\nstruct vivid_cec_work *cw =\r\ncontainer_of(work, struct vivid_cec_work, work.work);\r\nstruct vivid_dev *dev = cw->dev;\r\nspin_lock(&dev->cec_slock);\r\nif (dev->cec_xfer_time_jiffies) {\r\nlist_del(&cw->list);\r\nspin_unlock(&dev->cec_slock);\r\ncec_transmit_done(cw->adap, CEC_TX_STATUS_ARB_LOST, 1, 0, 0, 0);\r\nkfree(cw);\r\n} else {\r\nINIT_DELAYED_WORK(&cw->work, vivid_cec_xfer_done_worker);\r\ndev->cec_xfer_start_jiffies = jiffies;\r\ndev->cec_xfer_time_jiffies = usecs_to_jiffies(cw->usecs);\r\nspin_unlock(&dev->cec_slock);\r\nschedule_delayed_work(&cw->work, dev->cec_xfer_time_jiffies);\r\n}\r\n}\r\nstatic int vivid_cec_adap_enable(struct cec_adapter *adap, bool enable)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vivid_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vivid_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\r\nu32 signal_free_time, struct cec_msg *msg)\r\n{\r\nstruct vivid_dev *dev = adap->priv;\r\nstruct vivid_cec_work *cw = kzalloc(sizeof(*cw), GFP_KERNEL);\r\nlong delta_jiffies = 0;\r\nif (cw == NULL)\r\nreturn -ENOMEM;\r\ncw->dev = dev;\r\ncw->adap = adap;\r\ncw->usecs = CEC_FREE_TIME_TO_USEC(signal_free_time) +\r\nmsg->len * USECS_PER_BYTE;\r\ncw->msg = *msg;\r\nspin_lock(&dev->cec_slock);\r\nlist_add(&cw->list, &dev->cec_work_list);\r\nif (dev->cec_xfer_time_jiffies == 0) {\r\nINIT_DELAYED_WORK(&cw->work, vivid_cec_xfer_done_worker);\r\ndev->cec_xfer_start_jiffies = jiffies;\r\ndev->cec_xfer_time_jiffies = usecs_to_jiffies(cw->usecs);\r\ndelta_jiffies = dev->cec_xfer_time_jiffies;\r\n} else {\r\nINIT_DELAYED_WORK(&cw->work, vivid_cec_xfer_try_worker);\r\ndelta_jiffies = dev->cec_xfer_start_jiffies +\r\ndev->cec_xfer_time_jiffies - jiffies;\r\n}\r\nspin_unlock(&dev->cec_slock);\r\nschedule_delayed_work(&cw->work, delta_jiffies < 0 ? 0 : delta_jiffies);\r\nreturn 0;\r\n}\r\nstatic int vivid_received(struct cec_adapter *adap, struct cec_msg *msg)\r\n{\r\nstruct vivid_dev *dev = adap->priv;\r\nstruct cec_msg reply;\r\nu8 dest = cec_msg_destination(msg);\r\nu8 disp_ctl;\r\nchar osd[14];\r\nif (cec_msg_is_broadcast(msg))\r\ndest = adap->log_addrs.log_addr[0];\r\ncec_msg_init(&reply, dest, cec_msg_initiator(msg));\r\nswitch (cec_msg_opcode(msg)) {\r\ncase CEC_MSG_SET_OSD_STRING:\r\nif (!cec_is_sink(adap))\r\nreturn -ENOMSG;\r\ncec_ops_set_osd_string(msg, &disp_ctl, osd);\r\nswitch (disp_ctl) {\r\ncase CEC_OP_DISP_CTL_DEFAULT:\r\nstrcpy(dev->osd, osd);\r\ndev->osd_jiffies = jiffies;\r\nbreak;\r\ncase CEC_OP_DISP_CTL_UNTIL_CLEARED:\r\nstrcpy(dev->osd, osd);\r\ndev->osd_jiffies = 0;\r\nbreak;\r\ncase CEC_OP_DISP_CTL_CLEAR:\r\ndev->osd[0] = 0;\r\ndev->osd_jiffies = 0;\r\nbreak;\r\ndefault:\r\ncec_msg_feature_abort(&reply, cec_msg_opcode(msg),\r\nCEC_OP_ABORT_INVALID_OP);\r\ncec_transmit_msg(adap, &reply, false);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOMSG;\r\n}\r\nreturn 0;\r\n}\r\nstruct cec_adapter *vivid_cec_alloc_adap(struct vivid_dev *dev,\r\nunsigned int idx,\r\nstruct device *parent,\r\nbool is_source)\r\n{\r\nchar name[sizeof(dev->vid_out_dev.name) + 2];\r\nu32 caps = CEC_CAP_TRANSMIT | CEC_CAP_LOG_ADDRS |\r\nCEC_CAP_PASSTHROUGH | CEC_CAP_RC | CEC_CAP_MONITOR_ALL;\r\nsnprintf(name, sizeof(name), "%s%d",\r\nis_source ? dev->vid_out_dev.name : dev->vid_cap_dev.name,\r\nidx);\r\nreturn cec_allocate_adapter(&vivid_cec_adap_ops, dev,\r\nname, caps, 1, parent);\r\n}
