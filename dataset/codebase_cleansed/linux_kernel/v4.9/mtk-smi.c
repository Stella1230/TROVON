static int mtk_smi_enable(const struct mtk_smi *smi)\r\n{\r\nint ret;\r\nret = pm_runtime_get_sync(smi->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(smi->clk_apb);\r\nif (ret)\r\ngoto err_put_pm;\r\nret = clk_prepare_enable(smi->clk_smi);\r\nif (ret)\r\ngoto err_disable_apb;\r\nreturn 0;\r\nerr_disable_apb:\r\nclk_disable_unprepare(smi->clk_apb);\r\nerr_put_pm:\r\npm_runtime_put_sync(smi->dev);\r\nreturn ret;\r\n}\r\nstatic void mtk_smi_disable(const struct mtk_smi *smi)\r\n{\r\nclk_disable_unprepare(smi->clk_smi);\r\nclk_disable_unprepare(smi->clk_apb);\r\npm_runtime_put_sync(smi->dev);\r\n}\r\nint mtk_smi_larb_get(struct device *larbdev)\r\n{\r\nstruct mtk_smi_larb *larb = dev_get_drvdata(larbdev);\r\nconst struct mtk_smi_larb_gen *larb_gen = larb->larb_gen;\r\nstruct mtk_smi *common = dev_get_drvdata(larb->smi_common_dev);\r\nint ret;\r\nret = mtk_smi_enable(common);\r\nif (ret)\r\nreturn ret;\r\nret = mtk_smi_enable(&larb->smi);\r\nif (ret) {\r\nmtk_smi_disable(common);\r\nreturn ret;\r\n}\r\nlarb_gen->config_port(larbdev);\r\nreturn 0;\r\n}\r\nvoid mtk_smi_larb_put(struct device *larbdev)\r\n{\r\nstruct mtk_smi_larb *larb = dev_get_drvdata(larbdev);\r\nstruct mtk_smi *common = dev_get_drvdata(larb->smi_common_dev);\r\nmtk_smi_disable(&larb->smi);\r\nmtk_smi_disable(common);\r\n}\r\nstatic int\r\nmtk_smi_larb_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\r\nstruct mtk_smi_iommu *smi_iommu = data;\r\nunsigned int i;\r\nfor (i = 0; i < smi_iommu->larb_nr; i++) {\r\nif (dev == smi_iommu->larb_imu[i].dev) {\r\nlarb->mmu = &smi_iommu->larb_imu[i].mmu;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void mtk_smi_larb_config_port(struct device *dev)\r\n{\r\nstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\r\nwritel(*larb->mmu, larb->base + SMI_LARB_MMU_EN);\r\n}\r\nstatic void mtk_smi_larb_config_port_gen1(struct device *dev)\r\n{\r\nstruct mtk_smi_larb *larb = dev_get_drvdata(dev);\r\nconst struct mtk_smi_larb_gen *larb_gen = larb->larb_gen;\r\nstruct mtk_smi *common = dev_get_drvdata(larb->smi_common_dev);\r\nint i, m4u_port_id, larb_port_num;\r\nu32 sec_con_val, reg_val;\r\nm4u_port_id = larb_gen->port_in_larb[larb->larbid];\r\nlarb_port_num = larb_gen->port_in_larb[larb->larbid + 1]\r\n- larb_gen->port_in_larb[larb->larbid];\r\nfor (i = 0; i < larb_port_num; i++, m4u_port_id++) {\r\nif (*larb->mmu & BIT(i)) {\r\nsec_con_val = SMI_SECUR_CON_VAL_VIRT(m4u_port_id);\r\n} else {\r\ncontinue;\r\n}\r\nreg_val = readl(common->smi_ao_base\r\n+ REG_SMI_SECUR_CON_ADDR(m4u_port_id));\r\nreg_val &= SMI_SECUR_CON_VAL_MSK(m4u_port_id);\r\nreg_val |= sec_con_val;\r\nreg_val |= SMI_SECUR_CON_VAL_DOMAIN(m4u_port_id);\r\nwritel(reg_val,\r\ncommon->smi_ao_base\r\n+ REG_SMI_SECUR_CON_ADDR(m4u_port_id));\r\n}\r\n}\r\nstatic void\r\nmtk_smi_larb_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\n}\r\nstatic int mtk_smi_larb_probe(struct platform_device *pdev)\r\n{\r\nstruct mtk_smi_larb *larb;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *smi_node;\r\nstruct platform_device *smi_pdev;\r\nconst struct of_device_id *of_id;\r\nif (!dev->pm_domain)\r\nreturn -EPROBE_DEFER;\r\nof_id = of_match_node(mtk_smi_larb_of_ids, pdev->dev.of_node);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nlarb = devm_kzalloc(dev, sizeof(*larb), GFP_KERNEL);\r\nif (!larb)\r\nreturn -ENOMEM;\r\nlarb->larb_gen = of_id->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nlarb->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(larb->base))\r\nreturn PTR_ERR(larb->base);\r\nlarb->smi.clk_apb = devm_clk_get(dev, "apb");\r\nif (IS_ERR(larb->smi.clk_apb))\r\nreturn PTR_ERR(larb->smi.clk_apb);\r\nlarb->smi.clk_smi = devm_clk_get(dev, "smi");\r\nif (IS_ERR(larb->smi.clk_smi))\r\nreturn PTR_ERR(larb->smi.clk_smi);\r\nlarb->smi.dev = dev;\r\nsmi_node = of_parse_phandle(dev->of_node, "mediatek,smi", 0);\r\nif (!smi_node)\r\nreturn -EINVAL;\r\nsmi_pdev = of_find_device_by_node(smi_node);\r\nof_node_put(smi_node);\r\nif (smi_pdev) {\r\nlarb->smi_common_dev = &smi_pdev->dev;\r\n} else {\r\ndev_err(dev, "Failed to get the smi_common device\n");\r\nreturn -EINVAL;\r\n}\r\npm_runtime_enable(dev);\r\nplatform_set_drvdata(pdev, larb);\r\nreturn component_add(dev, &mtk_smi_larb_component_ops);\r\n}\r\nstatic int mtk_smi_larb_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\ncomponent_del(&pdev->dev, &mtk_smi_larb_component_ops);\r\nreturn 0;\r\n}\r\nstatic int mtk_smi_common_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_smi *common;\r\nstruct resource *res;\r\nconst struct of_device_id *of_id;\r\nenum mtk_smi_gen smi_gen;\r\nif (!dev->pm_domain)\r\nreturn -EPROBE_DEFER;\r\ncommon = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);\r\nif (!common)\r\nreturn -ENOMEM;\r\ncommon->dev = dev;\r\ncommon->clk_apb = devm_clk_get(dev, "apb");\r\nif (IS_ERR(common->clk_apb))\r\nreturn PTR_ERR(common->clk_apb);\r\ncommon->clk_smi = devm_clk_get(dev, "smi");\r\nif (IS_ERR(common->clk_smi))\r\nreturn PTR_ERR(common->clk_smi);\r\nof_id = of_match_node(mtk_smi_common_of_ids, pdev->dev.of_node);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nsmi_gen = (enum mtk_smi_gen)of_id->data;\r\nif (smi_gen == MTK_SMI_GEN1) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncommon->smi_ao_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(common->smi_ao_base))\r\nreturn PTR_ERR(common->smi_ao_base);\r\ncommon->clk_async = devm_clk_get(dev, "async");\r\nif (IS_ERR(common->clk_async))\r\nreturn PTR_ERR(common->clk_async);\r\nclk_prepare_enable(common->clk_async);\r\n}\r\npm_runtime_enable(dev);\r\nplatform_set_drvdata(pdev, common);\r\nreturn 0;\r\n}\r\nstatic int mtk_smi_common_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init mtk_smi_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&mtk_smi_common_driver);\r\nif (ret != 0) {\r\npr_err("Failed to register SMI driver\n");\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&mtk_smi_larb_driver);\r\nif (ret != 0) {\r\npr_err("Failed to register SMI-LARB driver\n");\r\ngoto err_unreg_smi;\r\n}\r\nreturn ret;\r\nerr_unreg_smi:\r\nplatform_driver_unregister(&mtk_smi_common_driver);\r\nreturn ret;\r\n}
