static int __split_next_bits(struct sw842_param *p, u64 *d, u8 n, u8 s)\r\n{\r\nu64 tmp = 0;\r\nint ret;\r\nif (n <= s) {\r\npr_debug("split_next_bits invalid n %u s %u\n", n, s);\r\nreturn -EINVAL;\r\n}\r\nret = next_bits(p, &tmp, n - s);\r\nif (ret)\r\nreturn ret;\r\nret = next_bits(p, d, s);\r\nif (ret)\r\nreturn ret;\r\n*d |= tmp << s;\r\nreturn 0;\r\n}\r\nstatic int next_bits(struct sw842_param *p, u64 *d, u8 n)\r\n{\r\nu8 *in = p->in, b = p->bit, bits = b + n;\r\nif (n > 64) {\r\npr_debug("next_bits invalid n %u\n", n);\r\nreturn -EINVAL;\r\n}\r\nif (bits > 64)\r\nreturn __split_next_bits(p, d, n, 32);\r\nelse if (p->ilen < 8 && bits > 32 && bits <= 56)\r\nreturn __split_next_bits(p, d, n, 16);\r\nelse if (p->ilen < 4 && bits > 16 && bits <= 24)\r\nreturn __split_next_bits(p, d, n, 8);\r\nif (DIV_ROUND_UP(bits, 8) > p->ilen)\r\nreturn -EOVERFLOW;\r\nif (bits <= 8)\r\n*d = *in >> (8 - bits);\r\nelse if (bits <= 16)\r\n*d = be16_to_cpu(get_unaligned((__be16 *)in)) >> (16 - bits);\r\nelse if (bits <= 32)\r\n*d = be32_to_cpu(get_unaligned((__be32 *)in)) >> (32 - bits);\r\nelse\r\n*d = be64_to_cpu(get_unaligned((__be64 *)in)) >> (64 - bits);\r\n*d &= GENMASK_ULL(n - 1, 0);\r\np->bit += n;\r\nif (p->bit > 7) {\r\np->in += p->bit / 8;\r\np->ilen -= p->bit / 8;\r\np->bit %= 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_data(struct sw842_param *p, u8 n)\r\n{\r\nu64 v;\r\nint ret;\r\nif (n > p->olen)\r\nreturn -ENOSPC;\r\nret = next_bits(p, &v, n * 8);\r\nif (ret)\r\nreturn ret;\r\nswitch (n) {\r\ncase 2:\r\nput_unaligned(cpu_to_be16((u16)v), (__be16 *)p->out);\r\nbreak;\r\ncase 4:\r\nput_unaligned(cpu_to_be32((u32)v), (__be32 *)p->out);\r\nbreak;\r\ncase 8:\r\nput_unaligned(cpu_to_be64((u64)v), (__be64 *)p->out);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\np->out += n;\r\np->olen -= n;\r\nreturn 0;\r\n}\r\nstatic int __do_index(struct sw842_param *p, u8 size, u8 bits, u64 fsize)\r\n{\r\nu64 index, offset, total = round_down(p->out - p->ostart, 8);\r\nint ret;\r\nret = next_bits(p, &index, bits);\r\nif (ret)\r\nreturn ret;\r\noffset = index * size;\r\nif (total > fsize) {\r\nu64 section = round_down(total, fsize);\r\nu64 pos = total - section;\r\nif (offset >= pos)\r\nsection -= fsize;\r\noffset += section;\r\n}\r\nif (offset + size > total) {\r\npr_debug("index%x %lx points past end %lx\n", size,\r\n(unsigned long)offset, (unsigned long)total);\r\nreturn -EINVAL;\r\n}\r\nif (size != 2 && size != 4 && size != 8)\r\nWARN(1, "__do_index invalid size %x\n", size);\r\nelse\r\npr_debug("index%x to %lx off %lx adjoff %lx tot %lx data %lx\n",\r\nsize, (unsigned long)index,\r\n(unsigned long)(index * size), (unsigned long)offset,\r\n(unsigned long)total,\r\n(unsigned long)beN_to_cpu(&p->ostart[offset], size));\r\nmemcpy(p->out, &p->ostart[offset], size);\r\np->out += size;\r\np->olen -= size;\r\nreturn 0;\r\n}\r\nstatic int do_index(struct sw842_param *p, u8 n)\r\n{\r\nswitch (n) {\r\ncase 2:\r\nreturn __do_index(p, 2, I2_BITS, I2_FIFO_SIZE);\r\ncase 4:\r\nreturn __do_index(p, 4, I4_BITS, I4_FIFO_SIZE);\r\ncase 8:\r\nreturn __do_index(p, 8, I8_BITS, I8_FIFO_SIZE);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int do_op(struct sw842_param *p, u8 o)\r\n{\r\nint i, ret = 0;\r\nif (o >= OPS_MAX)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 4; i++) {\r\nu8 op = decomp_ops[o][i];\r\npr_debug("op is %x\n", op);\r\nswitch (op & OP_ACTION) {\r\ncase OP_ACTION_DATA:\r\nret = do_data(p, op & OP_AMOUNT);\r\nbreak;\r\ncase OP_ACTION_INDEX:\r\nret = do_index(p, op & OP_AMOUNT);\r\nbreak;\r\ncase OP_ACTION_NOOP:\r\nbreak;\r\ndefault:\r\npr_err("Internal error, invalid op %x\n", op);\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (sw842_template_counts)\r\natomic_inc(&template_count[o]);\r\nreturn 0;\r\n}\r\nint sw842_decompress(const u8 *in, unsigned int ilen,\r\nu8 *out, unsigned int *olen)\r\n{\r\nstruct sw842_param p;\r\nint ret;\r\nu64 op, rep, tmp, bytes, total;\r\nu64 crc;\r\np.in = (u8 *)in;\r\np.bit = 0;\r\np.ilen = ilen;\r\np.out = out;\r\np.ostart = out;\r\np.olen = *olen;\r\ntotal = p.olen;\r\n*olen = 0;\r\ndo {\r\nret = next_bits(&p, &op, OP_BITS);\r\nif (ret)\r\nreturn ret;\r\npr_debug("template is %lx\n", (unsigned long)op);\r\nswitch (op) {\r\ncase OP_REPEAT:\r\nret = next_bits(&p, &rep, REPEAT_BITS);\r\nif (ret)\r\nreturn ret;\r\nif (p.out == out)\r\nreturn -EINVAL;\r\nrep++;\r\nif (rep * 8 > p.olen)\r\nreturn -ENOSPC;\r\nwhile (rep-- > 0) {\r\nmemcpy(p.out, p.out - 8, 8);\r\np.out += 8;\r\np.olen -= 8;\r\n}\r\nif (sw842_template_counts)\r\natomic_inc(&template_repeat_count);\r\nbreak;\r\ncase OP_ZEROS:\r\nif (8 > p.olen)\r\nreturn -ENOSPC;\r\nmemset(p.out, 0, 8);\r\np.out += 8;\r\np.olen -= 8;\r\nif (sw842_template_counts)\r\natomic_inc(&template_zeros_count);\r\nbreak;\r\ncase OP_SHORT_DATA:\r\nret = next_bits(&p, &bytes, SHORT_DATA_BITS);\r\nif (ret)\r\nreturn ret;\r\nif (!bytes || bytes > SHORT_DATA_BITS_MAX)\r\nreturn -EINVAL;\r\nwhile (bytes-- > 0) {\r\nret = next_bits(&p, &tmp, 8);\r\nif (ret)\r\nreturn ret;\r\n*p.out = (u8)tmp;\r\np.out++;\r\np.olen--;\r\n}\r\nif (sw842_template_counts)\r\natomic_inc(&template_short_data_count);\r\nbreak;\r\ncase OP_END:\r\nif (sw842_template_counts)\r\natomic_inc(&template_end_count);\r\nbreak;\r\ndefault:\r\nret = do_op(&p, op);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\n} while (op != OP_END);\r\nret = next_bits(&p, &crc, CRC_BITS);\r\nif (ret)\r\nreturn ret;\r\nif (crc != (u64)crc32_be(0, out, total - p.olen)) {\r\npr_debug("CRC mismatch for decompression\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely((total - p.olen) > UINT_MAX))\r\nreturn -ENOSPC;\r\n*olen = total - p.olen;\r\nreturn 0;\r\n}\r\nstatic int __init sw842_init(void)\r\n{\r\nif (sw842_template_counts)\r\nsw842_debugfs_create();\r\nreturn 0;\r\n}\r\nstatic void __exit sw842_exit(void)\r\n{\r\nif (sw842_template_counts)\r\nsw842_debugfs_remove();\r\n}
