static bool __power_supply_is_supplied_by(struct power_supply *supplier,\r\nstruct power_supply *supply)\r\n{\r\nint i;\r\nif (!supply->supplied_from && !supplier->supplied_to)\r\nreturn false;\r\nif (supply->supplied_from) {\r\nif (!supplier->desc->name)\r\nreturn false;\r\nfor (i = 0; i < supply->num_supplies; i++)\r\nif (!strcmp(supplier->desc->name, supply->supplied_from[i]))\r\nreturn true;\r\n} else {\r\nif (!supply->desc->name)\r\nreturn false;\r\nfor (i = 0; i < supplier->num_supplicants; i++)\r\nif (!strcmp(supplier->supplied_to[i], supply->desc->name))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int __power_supply_changed_work(struct device *dev, void *data)\r\n{\r\nstruct power_supply *psy = data;\r\nstruct power_supply *pst = dev_get_drvdata(dev);\r\nif (__power_supply_is_supplied_by(psy, pst)) {\r\nif (pst->desc->external_power_changed)\r\npst->desc->external_power_changed(pst);\r\n}\r\nreturn 0;\r\n}\r\nstatic void power_supply_changed_work(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct power_supply *psy = container_of(work, struct power_supply,\r\nchanged_work);\r\ndev_dbg(&psy->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&psy->changed_lock, flags);\r\nif (likely(psy->changed)) {\r\npsy->changed = false;\r\nspin_unlock_irqrestore(&psy->changed_lock, flags);\r\nclass_for_each_device(power_supply_class, NULL, psy,\r\n__power_supply_changed_work);\r\npower_supply_update_leds(psy);\r\natomic_notifier_call_chain(&power_supply_notifier,\r\nPSY_EVENT_PROP_CHANGED, psy);\r\nkobject_uevent(&psy->dev.kobj, KOBJ_CHANGE);\r\nspin_lock_irqsave(&psy->changed_lock, flags);\r\n}\r\nif (likely(!psy->changed))\r\npm_relax(&psy->dev);\r\nspin_unlock_irqrestore(&psy->changed_lock, flags);\r\n}\r\nvoid power_supply_changed(struct power_supply *psy)\r\n{\r\nunsigned long flags;\r\ndev_dbg(&psy->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&psy->changed_lock, flags);\r\npsy->changed = true;\r\npm_stay_awake(&psy->dev);\r\nspin_unlock_irqrestore(&psy->changed_lock, flags);\r\nschedule_work(&psy->changed_work);\r\n}\r\nstatic void power_supply_deferred_register_work(struct work_struct *work)\r\n{\r\nstruct power_supply *psy = container_of(work, struct power_supply,\r\ndeferred_register_work.work);\r\nif (psy->dev.parent)\r\nmutex_lock(&psy->dev.parent->mutex);\r\npower_supply_changed(psy);\r\nif (psy->dev.parent)\r\nmutex_unlock(&psy->dev.parent->mutex);\r\n}\r\nstatic int __power_supply_populate_supplied_from(struct device *dev,\r\nvoid *data)\r\n{\r\nstruct power_supply *psy = data;\r\nstruct power_supply *epsy = dev_get_drvdata(dev);\r\nstruct device_node *np;\r\nint i = 0;\r\ndo {\r\nnp = of_parse_phandle(psy->of_node, "power-supplies", i++);\r\nif (!np)\r\nbreak;\r\nif (np == epsy->of_node) {\r\ndev_info(&psy->dev, "%s: Found supply : %s\n",\r\npsy->desc->name, epsy->desc->name);\r\npsy->supplied_from[i-1] = (char *)epsy->desc->name;\r\npsy->num_supplies++;\r\nof_node_put(np);\r\nbreak;\r\n}\r\nof_node_put(np);\r\n} while (np);\r\nreturn 0;\r\n}\r\nstatic int power_supply_populate_supplied_from(struct power_supply *psy)\r\n{\r\nint error;\r\nerror = class_for_each_device(power_supply_class, NULL, psy,\r\n__power_supply_populate_supplied_from);\r\ndev_dbg(&psy->dev, "%s %d\n", __func__, error);\r\nreturn error;\r\n}\r\nstatic int __power_supply_find_supply_from_node(struct device *dev,\r\nvoid *data)\r\n{\r\nstruct device_node *np = data;\r\nstruct power_supply *epsy = dev_get_drvdata(dev);\r\nif (epsy->of_node == np)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int power_supply_find_supply_from_node(struct device_node *supply_node)\r\n{\r\nint error;\r\nerror = class_for_each_device(power_supply_class, NULL, supply_node,\r\n__power_supply_find_supply_from_node);\r\nreturn error ? (error == 1 ? 0 : error) : -EPROBE_DEFER;\r\n}\r\nstatic int power_supply_check_supplies(struct power_supply *psy)\r\n{\r\nstruct device_node *np;\r\nint cnt = 0;\r\nif (psy->supplied_from && psy->num_supplies > 0)\r\nreturn 0;\r\nif (!psy->of_node)\r\nreturn 0;\r\ndo {\r\nint ret;\r\nnp = of_parse_phandle(psy->of_node, "power-supplies", cnt++);\r\nif (!np)\r\nbreak;\r\nret = power_supply_find_supply_from_node(np);\r\nof_node_put(np);\r\nif (ret) {\r\ndev_dbg(&psy->dev, "Failed to find supply!\n");\r\nreturn ret;\r\n}\r\n} while (np);\r\nif (cnt == 1)\r\nreturn 0;\r\npsy->supplied_from = devm_kzalloc(&psy->dev, sizeof(psy->supplied_from),\r\nGFP_KERNEL);\r\nif (!psy->supplied_from) {\r\ndev_err(&psy->dev, "Couldn't allocate memory for supply list\n");\r\nreturn -ENOMEM;\r\n}\r\n*psy->supplied_from = devm_kzalloc(&psy->dev,\r\nsizeof(char *) * (cnt - 1),\r\nGFP_KERNEL);\r\nif (!*psy->supplied_from) {\r\ndev_err(&psy->dev, "Couldn't allocate memory for supply list\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn power_supply_populate_supplied_from(psy);\r\n}\r\nstatic inline int power_supply_check_supplies(struct power_supply *psy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __power_supply_am_i_supplied(struct device *dev, void *data)\r\n{\r\nunion power_supply_propval ret = {0,};\r\nstruct power_supply *psy = data;\r\nstruct power_supply *epsy = dev_get_drvdata(dev);\r\nif (__power_supply_is_supplied_by(epsy, psy))\r\nif (!epsy->desc->get_property(epsy, POWER_SUPPLY_PROP_ONLINE,\r\n&ret))\r\nreturn ret.intval;\r\nreturn 0;\r\n}\r\nint power_supply_am_i_supplied(struct power_supply *psy)\r\n{\r\nint error;\r\nerror = class_for_each_device(power_supply_class, NULL, psy,\r\n__power_supply_am_i_supplied);\r\ndev_dbg(&psy->dev, "%s %d\n", __func__, error);\r\nreturn error;\r\n}\r\nstatic int __power_supply_is_system_supplied(struct device *dev, void *data)\r\n{\r\nunion power_supply_propval ret = {0,};\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nunsigned int *count = data;\r\n(*count)++;\r\nif (psy->desc->type != POWER_SUPPLY_TYPE_BATTERY)\r\nif (!psy->desc->get_property(psy, POWER_SUPPLY_PROP_ONLINE,\r\n&ret))\r\nreturn ret.intval;\r\nreturn 0;\r\n}\r\nint power_supply_is_system_supplied(void)\r\n{\r\nint error;\r\nunsigned int count = 0;\r\nerror = class_for_each_device(power_supply_class, NULL, &count,\r\n__power_supply_is_system_supplied);\r\nif (count == 0)\r\nreturn 1;\r\nreturn error;\r\n}\r\nint power_supply_set_battery_charged(struct power_supply *psy)\r\n{\r\nif (atomic_read(&psy->use_cnt) >= 0 &&\r\npsy->desc->type == POWER_SUPPLY_TYPE_BATTERY &&\r\npsy->desc->set_charged) {\r\npsy->desc->set_charged(psy);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int power_supply_match_device_by_name(struct device *dev, const void *data)\r\n{\r\nconst char *name = data;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nreturn strcmp(psy->desc->name, name) == 0;\r\n}\r\nstruct power_supply *power_supply_get_by_name(const char *name)\r\n{\r\nstruct power_supply *psy = NULL;\r\nstruct device *dev = class_find_device(power_supply_class, NULL, name,\r\npower_supply_match_device_by_name);\r\nif (dev) {\r\npsy = dev_get_drvdata(dev);\r\natomic_inc(&psy->use_cnt);\r\n}\r\nreturn psy;\r\n}\r\nvoid power_supply_put(struct power_supply *psy)\r\n{\r\nmight_sleep();\r\natomic_dec(&psy->use_cnt);\r\nput_device(&psy->dev);\r\n}\r\nstatic int power_supply_match_device_node(struct device *dev, const void *data)\r\n{\r\nreturn dev->parent && dev->parent->of_node == data;\r\n}\r\nstruct power_supply *power_supply_get_by_phandle(struct device_node *np,\r\nconst char *property)\r\n{\r\nstruct device_node *power_supply_np;\r\nstruct power_supply *psy = NULL;\r\nstruct device *dev;\r\npower_supply_np = of_parse_phandle(np, property, 0);\r\nif (!power_supply_np)\r\nreturn ERR_PTR(-ENODEV);\r\ndev = class_find_device(power_supply_class, NULL, power_supply_np,\r\npower_supply_match_device_node);\r\nof_node_put(power_supply_np);\r\nif (dev) {\r\npsy = dev_get_drvdata(dev);\r\natomic_inc(&psy->use_cnt);\r\n}\r\nreturn psy;\r\n}\r\nstatic void devm_power_supply_put(struct device *dev, void *res)\r\n{\r\nstruct power_supply **psy = res;\r\npower_supply_put(*psy);\r\n}\r\nstruct power_supply *devm_power_supply_get_by_phandle(struct device *dev,\r\nconst char *property)\r\n{\r\nstruct power_supply **ptr, *psy;\r\nif (!dev->of_node)\r\nreturn ERR_PTR(-ENODEV);\r\nptr = devres_alloc(devm_power_supply_put, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\npsy = power_supply_get_by_phandle(dev->of_node, property);\r\nif (IS_ERR_OR_NULL(psy)) {\r\ndevres_free(ptr);\r\n} else {\r\n*ptr = psy;\r\ndevres_add(dev, ptr);\r\n}\r\nreturn psy;\r\n}\r\nint power_supply_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nif (atomic_read(&psy->use_cnt) <= 0) {\r\nif (!psy->initialized)\r\nreturn -EAGAIN;\r\nreturn -ENODEV;\r\n}\r\nreturn psy->desc->get_property(psy, psp, val);\r\n}\r\nint power_supply_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nif (atomic_read(&psy->use_cnt) <= 0 || !psy->desc->set_property)\r\nreturn -ENODEV;\r\nreturn psy->desc->set_property(psy, psp, val);\r\n}\r\nint power_supply_property_is_writeable(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nif (atomic_read(&psy->use_cnt) <= 0 ||\r\n!psy->desc->property_is_writeable)\r\nreturn -ENODEV;\r\nreturn psy->desc->property_is_writeable(psy, psp);\r\n}\r\nvoid power_supply_external_power_changed(struct power_supply *psy)\r\n{\r\nif (atomic_read(&psy->use_cnt) <= 0 ||\r\n!psy->desc->external_power_changed)\r\nreturn;\r\npsy->desc->external_power_changed(psy);\r\n}\r\nint power_supply_powers(struct power_supply *psy, struct device *dev)\r\n{\r\nreturn sysfs_create_link(&psy->dev.kobj, &dev->kobj, "powers");\r\n}\r\nstatic void power_supply_dev_release(struct device *dev)\r\n{\r\nstruct power_supply *psy = container_of(dev, struct power_supply, dev);\r\npr_debug("device: '%s': %s\n", dev_name(dev), __func__);\r\nkfree(psy);\r\n}\r\nint power_supply_reg_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_register(&power_supply_notifier, nb);\r\n}\r\nvoid power_supply_unreg_notifier(struct notifier_block *nb)\r\n{\r\natomic_notifier_chain_unregister(&power_supply_notifier, nb);\r\n}\r\nstatic int power_supply_read_temp(struct thermal_zone_device *tzd,\r\nint *temp)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\nWARN_ON(tzd == NULL);\r\npsy = tzd->devdata;\r\nret = power_supply_get_property(psy, POWER_SUPPLY_PROP_TEMP, &val);\r\nif (ret)\r\nreturn ret;\r\n*temp = val.intval * 100;\r\nreturn ret;\r\n}\r\nstatic int psy_register_thermal(struct power_supply *psy)\r\n{\r\nint i;\r\nif (psy->desc->no_thermal)\r\nreturn 0;\r\nfor (i = 0; i < psy->desc->num_properties; i++) {\r\nif (psy->desc->properties[i] == POWER_SUPPLY_PROP_TEMP) {\r\npsy->tzd = thermal_zone_device_register(psy->desc->name,\r\n0, 0, psy, &psy_tzd_ops, NULL, 0, 0);\r\nreturn PTR_ERR_OR_ZERO(psy->tzd);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void psy_unregister_thermal(struct power_supply *psy)\r\n{\r\nif (IS_ERR_OR_NULL(psy->tzd))\r\nreturn;\r\nthermal_zone_device_unregister(psy->tzd);\r\n}\r\nstatic int ps_get_max_charge_cntl_limit(struct thermal_cooling_device *tcd,\r\nunsigned long *state)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\npsy = tcd->devdata;\r\nret = power_supply_get_property(psy,\r\nPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX, &val);\r\nif (ret)\r\nreturn ret;\r\n*state = val.intval;\r\nreturn ret;\r\n}\r\nstatic int ps_get_cur_chrage_cntl_limit(struct thermal_cooling_device *tcd,\r\nunsigned long *state)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\npsy = tcd->devdata;\r\nret = power_supply_get_property(psy,\r\nPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, &val);\r\nif (ret)\r\nreturn ret;\r\n*state = val.intval;\r\nreturn ret;\r\n}\r\nstatic int ps_set_cur_charge_cntl_limit(struct thermal_cooling_device *tcd,\r\nunsigned long state)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\npsy = tcd->devdata;\r\nval.intval = state;\r\nret = psy->desc->set_property(psy,\r\nPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, &val);\r\nreturn ret;\r\n}\r\nstatic int psy_register_cooler(struct power_supply *psy)\r\n{\r\nint i;\r\nfor (i = 0; i < psy->desc->num_properties; i++) {\r\nif (psy->desc->properties[i] ==\r\nPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT) {\r\npsy->tcd = thermal_cooling_device_register(\r\n(char *)psy->desc->name,\r\npsy, &psy_tcd_ops);\r\nreturn PTR_ERR_OR_ZERO(psy->tcd);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void psy_unregister_cooler(struct power_supply *psy)\r\n{\r\nif (IS_ERR_OR_NULL(psy->tcd))\r\nreturn;\r\nthermal_cooling_device_unregister(psy->tcd);\r\n}\r\nstatic int psy_register_thermal(struct power_supply *psy)\r\n{\r\nreturn 0;\r\n}\r\nstatic void psy_unregister_thermal(struct power_supply *psy)\r\n{\r\n}\r\nstatic int psy_register_cooler(struct power_supply *psy)\r\n{\r\nreturn 0;\r\n}\r\nstatic void psy_unregister_cooler(struct power_supply *psy)\r\n{\r\n}\r\nstatic struct power_supply *__must_check\r\n__power_supply_register(struct device *parent,\r\nconst struct power_supply_desc *desc,\r\nconst struct power_supply_config *cfg,\r\nbool ws)\r\n{\r\nstruct device *dev;\r\nstruct power_supply *psy;\r\nint rc;\r\nif (!parent)\r\npr_warn("%s: Expected proper parent device for '%s'\n",\r\n__func__, desc->name);\r\npsy = kzalloc(sizeof(*psy), GFP_KERNEL);\r\nif (!psy)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev = &psy->dev;\r\ndevice_initialize(dev);\r\ndev->class = power_supply_class;\r\ndev->type = &power_supply_dev_type;\r\ndev->parent = parent;\r\ndev->release = power_supply_dev_release;\r\ndev_set_drvdata(dev, psy);\r\npsy->desc = desc;\r\nif (cfg) {\r\npsy->drv_data = cfg->drv_data;\r\npsy->of_node = cfg->of_node;\r\npsy->supplied_to = cfg->supplied_to;\r\npsy->num_supplicants = cfg->num_supplicants;\r\n}\r\nrc = dev_set_name(dev, "%s", desc->name);\r\nif (rc)\r\ngoto dev_set_name_failed;\r\nINIT_WORK(&psy->changed_work, power_supply_changed_work);\r\nINIT_DELAYED_WORK(&psy->deferred_register_work,\r\npower_supply_deferred_register_work);\r\nrc = power_supply_check_supplies(psy);\r\nif (rc) {\r\ndev_info(dev, "Not all required supplies found, defer probe\n");\r\ngoto check_supplies_failed;\r\n}\r\nspin_lock_init(&psy->changed_lock);\r\nrc = device_init_wakeup(dev, ws);\r\nif (rc)\r\ngoto wakeup_init_failed;\r\nrc = device_add(dev);\r\nif (rc)\r\ngoto device_add_failed;\r\nrc = psy_register_thermal(psy);\r\nif (rc)\r\ngoto register_thermal_failed;\r\nrc = psy_register_cooler(psy);\r\nif (rc)\r\ngoto register_cooler_failed;\r\nrc = power_supply_create_triggers(psy);\r\nif (rc)\r\ngoto create_triggers_failed;\r\natomic_inc(&psy->use_cnt);\r\npsy->initialized = true;\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&psy->deferred_register_work,\r\nPOWER_SUPPLY_DEFERRED_REGISTER_TIME);\r\nreturn psy;\r\ncreate_triggers_failed:\r\npsy_unregister_cooler(psy);\r\nregister_cooler_failed:\r\npsy_unregister_thermal(psy);\r\nregister_thermal_failed:\r\ndevice_del(dev);\r\ndevice_add_failed:\r\nwakeup_init_failed:\r\ncheck_supplies_failed:\r\ndev_set_name_failed:\r\nput_device(dev);\r\nreturn ERR_PTR(rc);\r\n}\r\nstruct power_supply *__must_check power_supply_register(struct device *parent,\r\nconst struct power_supply_desc *desc,\r\nconst struct power_supply_config *cfg)\r\n{\r\nreturn __power_supply_register(parent, desc, cfg, true);\r\n}\r\nstruct power_supply *__must_check\r\npower_supply_register_no_ws(struct device *parent,\r\nconst struct power_supply_desc *desc,\r\nconst struct power_supply_config *cfg)\r\n{\r\nreturn __power_supply_register(parent, desc, cfg, false);\r\n}\r\nstatic void devm_power_supply_release(struct device *dev, void *res)\r\n{\r\nstruct power_supply **psy = res;\r\npower_supply_unregister(*psy);\r\n}\r\nstruct power_supply *__must_check\r\ndevm_power_supply_register(struct device *parent,\r\nconst struct power_supply_desc *desc,\r\nconst struct power_supply_config *cfg)\r\n{\r\nstruct power_supply **ptr, *psy;\r\nptr = devres_alloc(devm_power_supply_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\npsy = __power_supply_register(parent, desc, cfg, true);\r\nif (IS_ERR(psy)) {\r\ndevres_free(ptr);\r\n} else {\r\n*ptr = psy;\r\ndevres_add(parent, ptr);\r\n}\r\nreturn psy;\r\n}\r\nstruct power_supply *__must_check\r\ndevm_power_supply_register_no_ws(struct device *parent,\r\nconst struct power_supply_desc *desc,\r\nconst struct power_supply_config *cfg)\r\n{\r\nstruct power_supply **ptr, *psy;\r\nptr = devres_alloc(devm_power_supply_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\npsy = __power_supply_register(parent, desc, cfg, false);\r\nif (IS_ERR(psy)) {\r\ndevres_free(ptr);\r\n} else {\r\n*ptr = psy;\r\ndevres_add(parent, ptr);\r\n}\r\nreturn psy;\r\n}\r\nvoid power_supply_unregister(struct power_supply *psy)\r\n{\r\nWARN_ON(atomic_dec_return(&psy->use_cnt));\r\ncancel_work_sync(&psy->changed_work);\r\ncancel_delayed_work_sync(&psy->deferred_register_work);\r\nsysfs_remove_link(&psy->dev.kobj, "powers");\r\npower_supply_remove_triggers(psy);\r\npsy_unregister_cooler(psy);\r\npsy_unregister_thermal(psy);\r\ndevice_init_wakeup(&psy->dev, false);\r\ndevice_unregister(&psy->dev);\r\n}\r\nvoid *power_supply_get_drvdata(struct power_supply *psy)\r\n{\r\nreturn psy->drv_data;\r\n}\r\nstatic int __init power_supply_class_init(void)\r\n{\r\npower_supply_class = class_create(THIS_MODULE, "power_supply");\r\nif (IS_ERR(power_supply_class))\r\nreturn PTR_ERR(power_supply_class);\r\npower_supply_class->dev_uevent = power_supply_uevent;\r\npower_supply_init_attrs(&power_supply_dev_type);\r\nreturn 0;\r\n}\r\nstatic void __exit power_supply_class_exit(void)\r\n{\r\nclass_destroy(power_supply_class);\r\n}
