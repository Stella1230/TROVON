static inline struct pxa_gpio_chip *chip_to_pxachip(struct gpio_chip *c)\r\n{\r\nstruct pxa_gpio_chip *pxa_chip = gpiochip_get_data(c);\r\nreturn pxa_chip;\r\n}\r\nstatic inline void __iomem *gpio_bank_base(struct gpio_chip *c, int gpio)\r\n{\r\nstruct pxa_gpio_chip *p = gpiochip_get_data(c);\r\nstruct pxa_gpio_bank *bank = p->banks + (gpio / 32);\r\nreturn bank->regbase;\r\n}\r\nstatic inline struct pxa_gpio_bank *gpio_to_pxabank(struct gpio_chip *c,\r\nunsigned gpio)\r\n{\r\nreturn chip_to_pxachip(c)->banks + gpio / 32;\r\n}\r\nstatic inline int gpio_is_pxa_type(int type)\r\n{\r\nreturn (type & MMP_GPIO) == 0;\r\n}\r\nstatic inline int gpio_is_mmp_type(int type)\r\n{\r\nreturn (type & MMP_GPIO) != 0;\r\n}\r\nstatic inline int __gpio_is_inverted(int gpio)\r\n{\r\nif ((gpio_type == PXA26X_GPIO) && (gpio > 85))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int __gpio_is_occupied(struct pxa_gpio_chip *pchip, unsigned gpio)\r\n{\r\nvoid __iomem *base;\r\nunsigned long gafr = 0, gpdr = 0;\r\nint ret, af = 0, dir = 0;\r\nbase = gpio_bank_base(&pchip->chip, gpio);\r\ngpdr = readl_relaxed(base + GPDR_OFFSET);\r\nswitch (gpio_type) {\r\ncase PXA25X_GPIO:\r\ncase PXA26X_GPIO:\r\ncase PXA27X_GPIO:\r\ngafr = readl_relaxed(base + GAFR_OFFSET);\r\naf = (gafr >> ((gpio & 0xf) * 2)) & 0x3;\r\ndir = gpdr & GPIO_bit(gpio);\r\nif (__gpio_is_inverted(gpio))\r\nret = (af != 1) || (dir == 0);\r\nelse\r\nret = (af != 0) || (dir != 0);\r\nbreak;\r\ndefault:\r\nret = gpdr & GPIO_bit(gpio);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint pxa_irq_to_gpio(int irq)\r\n{\r\nstruct pxa_gpio_chip *pchip = pxa_gpio_chip;\r\nint irq_gpio0;\r\nirq_gpio0 = irq_find_mapping(pchip->irqdomain, 0);\r\nif (irq_gpio0 > 0)\r\nreturn irq - irq_gpio0;\r\nreturn irq_gpio0;\r\n}\r\nstatic int pxa_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pxa_gpio_chip *pchip = chip_to_pxachip(chip);\r\nreturn irq_find_mapping(pchip->irqdomain, offset);\r\n}\r\nstatic int pxa_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *base = gpio_bank_base(chip, offset);\r\nuint32_t value, mask = GPIO_bit(offset);\r\nunsigned long flags;\r\nint ret;\r\nret = pinctrl_gpio_direction_input(chip->base + offset);\r\nif (!ret)\r\nreturn 0;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nvalue = readl_relaxed(base + GPDR_OFFSET);\r\nif (__gpio_is_inverted(chip->base + offset))\r\nvalue |= mask;\r\nelse\r\nvalue &= ~mask;\r\nwritel_relaxed(value, base + GPDR_OFFSET);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pxa_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nvoid __iomem *base = gpio_bank_base(chip, offset);\r\nuint32_t tmp, mask = GPIO_bit(offset);\r\nunsigned long flags;\r\nint ret;\r\nwritel_relaxed(mask, base + (value ? GPSR_OFFSET : GPCR_OFFSET));\r\nret = pinctrl_gpio_direction_output(chip->base + offset);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\ntmp = readl_relaxed(base + GPDR_OFFSET);\r\nif (__gpio_is_inverted(chip->base + offset))\r\ntmp &= ~mask;\r\nelse\r\ntmp |= mask;\r\nwritel_relaxed(tmp, base + GPDR_OFFSET);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pxa_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *base = gpio_bank_base(chip, offset);\r\nu32 gplr = readl_relaxed(base + GPLR_OFFSET);\r\nreturn !!(gplr & GPIO_bit(offset));\r\n}\r\nstatic void pxa_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nvoid __iomem *base = gpio_bank_base(chip, offset);\r\nwritel_relaxed(GPIO_bit(offset),\r\nbase + (value ? GPSR_OFFSET : GPCR_OFFSET));\r\n}\r\nstatic int pxa_gpio_of_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec,\r\nu32 *flags)\r\n{\r\nif (gpiospec->args[0] > pxa_last_gpio)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[1];\r\nreturn gpiospec->args[0];\r\n}\r\nstatic int pxa_gpio_request(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nreturn pinctrl_request_gpio(chip->base + offset);\r\n}\r\nstatic void pxa_gpio_free(struct gpio_chip *chip, unsigned int offset)\r\n{\r\npinctrl_free_gpio(chip->base + offset);\r\n}\r\nstatic int pxa_init_gpio_chip(struct pxa_gpio_chip *pchip, int ngpio,\r\nstruct device_node *np, void __iomem *regbase)\r\n{\r\nint i, gpio, nbanks = DIV_ROUND_UP(ngpio, 32);\r\nstruct pxa_gpio_bank *bank;\r\npchip->banks = devm_kcalloc(pchip->dev, nbanks, sizeof(*pchip->banks),\r\nGFP_KERNEL);\r\nif (!pchip->banks)\r\nreturn -ENOMEM;\r\npchip->chip.label = "gpio-pxa";\r\npchip->chip.direction_input = pxa_gpio_direction_input;\r\npchip->chip.direction_output = pxa_gpio_direction_output;\r\npchip->chip.get = pxa_gpio_get;\r\npchip->chip.set = pxa_gpio_set;\r\npchip->chip.to_irq = pxa_gpio_to_irq;\r\npchip->chip.ngpio = ngpio;\r\npchip->chip.request = pxa_gpio_request;\r\npchip->chip.free = pxa_gpio_free;\r\n#ifdef CONFIG_OF_GPIO\r\npchip->chip.of_node = np;\r\npchip->chip.of_xlate = pxa_gpio_of_xlate;\r\npchip->chip.of_gpio_n_cells = 2;\r\n#endif\r\nfor (i = 0, gpio = 0; i < nbanks; i++, gpio += 32) {\r\nbank = pchip->banks + i;\r\nbank->regbase = regbase + BANK_OFF(i);\r\n}\r\nreturn gpiochip_add_data(&pchip->chip, pchip);\r\n}\r\nstatic inline void update_edge_detect(struct pxa_gpio_bank *c)\r\n{\r\nuint32_t grer, gfer;\r\ngrer = readl_relaxed(c->regbase + GRER_OFFSET) & ~c->irq_mask;\r\ngfer = readl_relaxed(c->regbase + GFER_OFFSET) & ~c->irq_mask;\r\ngrer |= c->irq_edge_rise & c->irq_mask;\r\ngfer |= c->irq_edge_fall & c->irq_mask;\r\nwritel_relaxed(grer, c->regbase + GRER_OFFSET);\r\nwritel_relaxed(gfer, c->regbase + GFER_OFFSET);\r\n}\r\nstatic int pxa_gpio_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\r\nunsigned int gpio = irqd_to_hwirq(d);\r\nstruct pxa_gpio_bank *c = gpio_to_pxabank(&pchip->chip, gpio);\r\nunsigned long gpdr, mask = GPIO_bit(gpio);\r\nif (type == IRQ_TYPE_PROBE) {\r\nif ((c->irq_edge_rise | c->irq_edge_fall) & GPIO_bit(gpio))\r\nreturn 0;\r\nif (__gpio_is_occupied(pchip, gpio))\r\nreturn 0;\r\ntype = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\r\n}\r\ngpdr = readl_relaxed(c->regbase + GPDR_OFFSET);\r\nif (__gpio_is_inverted(gpio))\r\nwritel_relaxed(gpdr | mask, c->regbase + GPDR_OFFSET);\r\nelse\r\nwritel_relaxed(gpdr & ~mask, c->regbase + GPDR_OFFSET);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nc->irq_edge_rise |= mask;\r\nelse\r\nc->irq_edge_rise &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nc->irq_edge_fall |= mask;\r\nelse\r\nc->irq_edge_fall &= ~mask;\r\nupdate_edge_detect(c);\r\npr_debug("%s: IRQ%d (GPIO%d) - edge%s%s\n", __func__, d->irq, gpio,\r\n((type & IRQ_TYPE_EDGE_RISING) ? " rising" : ""),\r\n((type & IRQ_TYPE_EDGE_FALLING) ? " falling" : ""));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pxa_gpio_demux_handler(int in_irq, void *d)\r\n{\r\nint loop, gpio, n, handled = 0;\r\nunsigned long gedr;\r\nstruct pxa_gpio_chip *pchip = d;\r\nstruct pxa_gpio_bank *c;\r\ndo {\r\nloop = 0;\r\nfor_each_gpio_bank(gpio, c, pchip) {\r\ngedr = readl_relaxed(c->regbase + GEDR_OFFSET);\r\ngedr = gedr & c->irq_mask;\r\nwritel_relaxed(gedr, c->regbase + GEDR_OFFSET);\r\nfor_each_set_bit(n, &gedr, BITS_PER_LONG) {\r\nloop = 1;\r\ngeneric_handle_irq(gpio_to_irq(gpio + n));\r\n}\r\n}\r\nhandled += loop;\r\n} while (loop);\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic irqreturn_t pxa_gpio_direct_handler(int in_irq, void *d)\r\n{\r\nstruct pxa_gpio_chip *pchip = d;\r\nif (in_irq == pchip->irq0) {\r\ngeneric_handle_irq(gpio_to_irq(0));\r\n} else if (in_irq == pchip->irq1) {\r\ngeneric_handle_irq(gpio_to_irq(1));\r\n} else {\r\npr_err("%s() unknown irq %d\n", __func__, in_irq);\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pxa_ack_muxed_gpio(struct irq_data *d)\r\n{\r\nstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\r\nunsigned int gpio = irqd_to_hwirq(d);\r\nvoid __iomem *base = gpio_bank_base(&pchip->chip, gpio);\r\nwritel_relaxed(GPIO_bit(gpio), base + GEDR_OFFSET);\r\n}\r\nstatic void pxa_mask_muxed_gpio(struct irq_data *d)\r\n{\r\nstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\r\nunsigned int gpio = irqd_to_hwirq(d);\r\nstruct pxa_gpio_bank *b = gpio_to_pxabank(&pchip->chip, gpio);\r\nvoid __iomem *base = gpio_bank_base(&pchip->chip, gpio);\r\nuint32_t grer, gfer;\r\nb->irq_mask &= ~GPIO_bit(gpio);\r\ngrer = readl_relaxed(base + GRER_OFFSET) & ~GPIO_bit(gpio);\r\ngfer = readl_relaxed(base + GFER_OFFSET) & ~GPIO_bit(gpio);\r\nwritel_relaxed(grer, base + GRER_OFFSET);\r\nwritel_relaxed(gfer, base + GFER_OFFSET);\r\n}\r\nstatic int pxa_gpio_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\r\nunsigned int gpio = irqd_to_hwirq(d);\r\nif (pchip->set_wake)\r\nreturn pchip->set_wake(gpio, on);\r\nelse\r\nreturn 0;\r\n}\r\nstatic void pxa_unmask_muxed_gpio(struct irq_data *d)\r\n{\r\nstruct pxa_gpio_chip *pchip = irq_data_get_irq_chip_data(d);\r\nunsigned int gpio = irqd_to_hwirq(d);\r\nstruct pxa_gpio_bank *c = gpio_to_pxabank(&pchip->chip, gpio);\r\nc->irq_mask |= GPIO_bit(gpio);\r\nupdate_edge_detect(c);\r\n}\r\nstatic int pxa_gpio_nums(struct platform_device *pdev)\r\n{\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\nstruct pxa_gpio_id *pxa_id = (struct pxa_gpio_id *)id->driver_data;\r\nint count = 0;\r\nswitch (pxa_id->type) {\r\ncase PXA25X_GPIO:\r\ncase PXA26X_GPIO:\r\ncase PXA27X_GPIO:\r\ncase PXA3XX_GPIO:\r\ncase PXA93X_GPIO:\r\ncase MMP_GPIO:\r\ncase MMP2_GPIO:\r\ncase PXA1928_GPIO:\r\ngpio_type = pxa_id->type;\r\ncount = pxa_id->gpio_nums - 1;\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic int pxa_irq_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,\r\nhandle_edge_irq);\r\nirq_set_chip_data(irq, d->host_data);\r\nirq_set_noprobe(irq);\r\nreturn 0;\r\n}\r\nstatic int pxa_gpio_probe_dt(struct platform_device *pdev,\r\nstruct pxa_gpio_chip *pchip)\r\n{\r\nint nr_gpios;\r\nconst struct of_device_id *of_id =\r\nof_match_device(pxa_gpio_dt_ids, &pdev->dev);\r\nconst struct pxa_gpio_id *gpio_id;\r\nif (!of_id || !of_id->data) {\r\ndev_err(&pdev->dev, "Failed to find gpio controller\n");\r\nreturn -EFAULT;\r\n}\r\ngpio_id = of_id->data;\r\ngpio_type = gpio_id->type;\r\nnr_gpios = gpio_id->gpio_nums;\r\npxa_last_gpio = nr_gpios - 1;\r\nirq_base = irq_alloc_descs(-1, 0, nr_gpios, 0);\r\nif (irq_base < 0) {\r\ndev_err(&pdev->dev, "Failed to allocate IRQ numbers\n");\r\nreturn irq_base;\r\n}\r\nreturn irq_base;\r\n}\r\nstatic int pxa_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa_gpio_chip *pchip;\r\nstruct pxa_gpio_bank *c;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nstruct pxa_gpio_platform_data *info;\r\nvoid __iomem *gpio_reg_base;\r\nint gpio, ret;\r\nint irq0 = 0, irq1 = 0, irq_mux, gpio_offset = 0;\r\npchip = devm_kzalloc(&pdev->dev, sizeof(*pchip), GFP_KERNEL);\r\nif (!pchip)\r\nreturn -ENOMEM;\r\npchip->dev = &pdev->dev;\r\ninfo = dev_get_platdata(&pdev->dev);\r\nif (info) {\r\nirq_base = info->irq_base;\r\nif (irq_base <= 0)\r\nreturn -EINVAL;\r\npxa_last_gpio = pxa_gpio_nums(pdev);\r\npchip->set_wake = info->gpio_set_wake;\r\n} else {\r\nirq_base = pxa_gpio_probe_dt(pdev, pchip);\r\nif (irq_base < 0)\r\nreturn -EINVAL;\r\n}\r\nif (!pxa_last_gpio)\r\nreturn -EINVAL;\r\npchip->irqdomain = irq_domain_add_legacy(pdev->dev.of_node,\r\npxa_last_gpio + 1, irq_base,\r\n0, &pxa_irq_domain_ops, pchip);\r\nif (!pchip->irqdomain)\r\nreturn -ENOMEM;\r\nirq0 = platform_get_irq_byname(pdev, "gpio0");\r\nirq1 = platform_get_irq_byname(pdev, "gpio1");\r\nirq_mux = platform_get_irq_byname(pdev, "gpio_mux");\r\nif ((irq0 > 0 && irq1 <= 0) || (irq0 <= 0 && irq1 > 0)\r\n|| (irq_mux <= 0))\r\nreturn -EINVAL;\r\npchip->irq0 = irq0;\r\npchip->irq1 = irq1;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngpio_reg_base = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!gpio_reg_base)\r\nreturn -EINVAL;\r\nif (irq0 > 0)\r\ngpio_offset = 2;\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "Error %ld to get gpio clock\n",\r\nPTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\nclk_put(clk);\r\nreturn ret;\r\n}\r\nret = pxa_init_gpio_chip(pchip, pxa_last_gpio + 1, pdev->dev.of_node,\r\ngpio_reg_base);\r\nif (ret) {\r\nclk_put(clk);\r\nreturn ret;\r\n}\r\nfor_each_gpio_bank(gpio, c, pchip) {\r\nwritel_relaxed(0, c->regbase + GFER_OFFSET);\r\nwritel_relaxed(0, c->regbase + GRER_OFFSET);\r\nwritel_relaxed(~0, c->regbase + GEDR_OFFSET);\r\nif (gpio_is_mmp_type(gpio_type))\r\nwritel_relaxed(~0, c->regbase + ED_MASK_OFFSET);\r\n}\r\nif (irq0 > 0) {\r\nret = devm_request_irq(&pdev->dev,\r\nirq0, pxa_gpio_direct_handler, 0,\r\n"gpio-0", pchip);\r\nif (ret)\r\ndev_err(&pdev->dev, "request of gpio0 irq failed: %d\n",\r\nret);\r\n}\r\nif (irq1 > 0) {\r\nret = devm_request_irq(&pdev->dev,\r\nirq1, pxa_gpio_direct_handler, 0,\r\n"gpio-1", pchip);\r\nif (ret)\r\ndev_err(&pdev->dev, "request of gpio1 irq failed: %d\n",\r\nret);\r\n}\r\nret = devm_request_irq(&pdev->dev,\r\nirq_mux, pxa_gpio_demux_handler, 0,\r\n"gpio-mux", pchip);\r\nif (ret)\r\ndev_err(&pdev->dev, "request of gpio-mux irq failed: %d\n",\r\nret);\r\npxa_gpio_chip = pchip;\r\nreturn 0;\r\n}\r\nstatic int __init pxa_gpio_legacy_init(void)\r\n{\r\nif (of_have_populated_dt())\r\nreturn 0;\r\nreturn platform_driver_register(&pxa_gpio_driver);\r\n}\r\nstatic int __init pxa_gpio_dt_init(void)\r\n{\r\nif (of_have_populated_dt())\r\nreturn platform_driver_register(&pxa_gpio_driver);\r\nreturn 0;\r\n}\r\nstatic int pxa_gpio_suspend(void)\r\n{\r\nstruct pxa_gpio_chip *pchip = pxa_gpio_chip;\r\nstruct pxa_gpio_bank *c;\r\nint gpio;\r\nfor_each_gpio_bank(gpio, c, pchip) {\r\nc->saved_gplr = readl_relaxed(c->regbase + GPLR_OFFSET);\r\nc->saved_gpdr = readl_relaxed(c->regbase + GPDR_OFFSET);\r\nc->saved_grer = readl_relaxed(c->regbase + GRER_OFFSET);\r\nc->saved_gfer = readl_relaxed(c->regbase + GFER_OFFSET);\r\nwritel_relaxed(0xffffffff, c->regbase + GEDR_OFFSET);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pxa_gpio_resume(void)\r\n{\r\nstruct pxa_gpio_chip *pchip = pxa_gpio_chip;\r\nstruct pxa_gpio_bank *c;\r\nint gpio;\r\nfor_each_gpio_bank(gpio, c, pchip) {\r\nwritel_relaxed(c->saved_gplr, c->regbase + GPSR_OFFSET);\r\nwritel_relaxed(~c->saved_gplr, c->regbase + GPCR_OFFSET);\r\nwritel_relaxed(c->saved_grer, c->regbase + GRER_OFFSET);\r\nwritel_relaxed(c->saved_gfer, c->regbase + GFER_OFFSET);\r\nwritel_relaxed(c->saved_gpdr, c->regbase + GPDR_OFFSET);\r\n}\r\n}\r\nstatic int __init pxa_gpio_sysinit(void)\r\n{\r\nregister_syscore_ops(&pxa_gpio_syscore_ops);\r\nreturn 0;\r\n}
