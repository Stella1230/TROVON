static int ec168_ctrl_msg(struct dvb_usb_device *d, struct ec168_req *req)\r\n{\r\nint ret;\r\nunsigned int pipe;\r\nu8 request, requesttype;\r\nu8 *buf;\r\nswitch (req->cmd) {\r\ncase DOWNLOAD_FIRMWARE:\r\ncase GPIO:\r\ncase WRITE_I2C:\r\ncase STREAMING_CTRL:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nrequest = req->cmd;\r\nbreak;\r\ncase READ_I2C:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nrequest = req->cmd;\r\nbreak;\r\ncase GET_CONFIG:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nrequest = CONFIG;\r\nbreak;\r\ncase SET_CONFIG:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nrequest = CONFIG;\r\nbreak;\r\ncase WRITE_DEMOD:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nrequest = DEMOD_RW;\r\nbreak;\r\ncase READ_DEMOD:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nrequest = DEMOD_RW;\r\nbreak;\r\ndefault:\r\ndev_err(&d->udev->dev, "%s: unknown command=%02x\n",\r\nKBUILD_MODNAME, req->cmd);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbuf = kmalloc(req->size, GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (requesttype == (USB_TYPE_VENDOR | USB_DIR_OUT)) {\r\nmemcpy(buf, req->data, req->size);\r\npipe = usb_sndctrlpipe(d->udev, 0);\r\n} else {\r\npipe = usb_rcvctrlpipe(d->udev, 0);\r\n}\r\nmsleep(1);\r\nret = usb_control_msg(d->udev, pipe, request, requesttype, req->value,\r\nreq->index, buf, req->size, EC168_USB_TIMEOUT);\r\ndvb_usb_dbg_usb_control_msg(d->udev, request, requesttype, req->value,\r\nreq->index, buf, req->size);\r\nif (ret < 0)\r\ngoto err_dealloc;\r\nelse\r\nret = 0;\r\nif (!ret && requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))\r\nmemcpy(req->data, buf, req->size);\r\nkfree(buf);\r\nreturn ret;\r\nerr_dealloc:\r\nkfree(buf);\r\nerror:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec168_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct ec168_req req;\r\nint i = 0;\r\nint ret;\r\nif (num > 2)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nwhile (i < num) {\r\nif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\r\nif (msg[i].addr == ec168_ec100_config.demod_address) {\r\nreq.cmd = READ_DEMOD;\r\nreq.value = 0;\r\nreq.index = 0xff00 + msg[i].buf[0];\r\nreq.size = msg[i+1].len;\r\nreq.data = &msg[i+1].buf[0];\r\nret = ec168_ctrl_msg(d, &req);\r\ni += 2;\r\n} else {\r\ndev_err(&d->udev->dev, "%s: I2C read not " \\r\n"implemented\n",\r\nKBUILD_MODNAME);\r\nret = -EOPNOTSUPP;\r\ni += 2;\r\n}\r\n} else {\r\nif (msg[i].addr == ec168_ec100_config.demod_address) {\r\nreq.cmd = WRITE_DEMOD;\r\nreq.value = msg[i].buf[1];\r\nreq.index = 0xff00 + msg[i].buf[0];\r\nreq.size = 0;\r\nreq.data = NULL;\r\nret = ec168_ctrl_msg(d, &req);\r\ni += 1;\r\n} else {\r\nreq.cmd = WRITE_I2C;\r\nreq.value = msg[i].buf[0];\r\nreq.index = 0x0100 + msg[i].addr;\r\nreq.size = msg[i].len-1;\r\nreq.data = &msg[i].buf[1];\r\nret = ec168_ctrl_msg(d, &req);\r\ni += 1;\r\n}\r\n}\r\nif (ret)\r\ngoto error;\r\n}\r\nret = i;\r\nerror:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 ec168_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int ec168_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\nint ret;\r\nu8 reply;\r\nstruct ec168_req req = {GET_CONFIG, 0, 1, sizeof(reply), &reply};\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nret = ec168_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\ndev_dbg(&d->udev->dev, "%s: reply=%02x\n", __func__, reply);\r\nif (reply == 0x01)\r\nret = WARM;\r\nelse\r\nret = COLD;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec168_download_firmware(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nint ret, len, remaining;\r\nstruct ec168_req req = {DOWNLOAD_FIRMWARE, 0, 0, 0, NULL};\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\n#define LEN_MAX 2048\r\nfor (remaining = fw->size; remaining > 0; remaining -= LEN_MAX) {\r\nlen = remaining;\r\nif (len > LEN_MAX)\r\nlen = LEN_MAX;\r\nreq.size = len;\r\nreq.data = (u8 *) &fw->data[fw->size - remaining];\r\nreq.index = fw->size - remaining;\r\nret = ec168_ctrl_msg(d, &req);\r\nif (ret) {\r\ndev_err(&d->udev->dev,\r\n"%s: firmware download failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto error;\r\n}\r\n}\r\nreq.size = 0;\r\nreq.cmd = SET_CONFIG;\r\nreq.value = 0;\r\nreq.index = 0x0001;\r\nret = ec168_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nreq.cmd = GPIO;\r\nreq.value = 0;\r\nreq.index = 0x0206;\r\nret = ec168_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nreq.cmd = WRITE_I2C;\r\nreq.value = 0;\r\nreq.index = 0x00c6;\r\nret = ec168_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int ec168_ec100_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nadap->fe[0] = dvb_attach(ec100_attach, &ec168_ec100_config,\r\n&d->i2c_adap);\r\nif (adap->fe[0] == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ec168_mxl5003s_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nreturn dvb_attach(mxl5005s_attach, adap->fe[0], &d->i2c_adap,\r\n&ec168_mxl5003s_config) == NULL ? -ENODEV : 0;\r\n}\r\nstatic int ec168_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct ec168_req req = {STREAMING_CTRL, 0x7f01, 0x0202, 0, NULL};\r\ndev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);\r\nif (onoff)\r\nreq.index = 0x0102;\r\nreturn ec168_ctrl_msg(d, &req);\r\n}
