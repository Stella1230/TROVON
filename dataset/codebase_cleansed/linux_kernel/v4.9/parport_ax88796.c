static inline struct ax_drvdata *pp_to_drv(struct parport *p)\r\n{\r\nreturn p->private_data;\r\n}\r\nstatic unsigned char\r\nparport_ax88796_read_data(struct parport *p)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nreturn readb(dd->spp_data);\r\n}\r\nstatic void\r\nparport_ax88796_write_data(struct parport *p, unsigned char data)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nwriteb(data, dd->spp_data);\r\n}\r\nstatic unsigned char\r\nparport_ax88796_read_control(struct parport *p)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nunsigned int cpr = readb(dd->spp_cpr);\r\nunsigned int ret = 0;\r\nif (!(cpr & AX_CPR_STRB))\r\nret |= PARPORT_CONTROL_STROBE;\r\nif (!(cpr & AX_CPR_ATFD))\r\nret |= PARPORT_CONTROL_AUTOFD;\r\nif (cpr & AX_CPR_nINIT)\r\nret |= PARPORT_CONTROL_INIT;\r\nif (!(cpr & AX_CPR_SLCTIN))\r\nret |= PARPORT_CONTROL_SELECT;\r\nreturn ret;\r\n}\r\nstatic void\r\nparport_ax88796_write_control(struct parport *p, unsigned char control)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nunsigned int cpr = readb(dd->spp_cpr);\r\ncpr &= AX_CPR_nDOE;\r\nif (!(control & PARPORT_CONTROL_STROBE))\r\ncpr |= AX_CPR_STRB;\r\nif (!(control & PARPORT_CONTROL_AUTOFD))\r\ncpr |= AX_CPR_ATFD;\r\nif (control & PARPORT_CONTROL_INIT)\r\ncpr |= AX_CPR_nINIT;\r\nif (!(control & PARPORT_CONTROL_SELECT))\r\ncpr |= AX_CPR_SLCTIN;\r\ndev_dbg(dd->dev, "write_control: ctrl=%02x, cpr=%02x\n", control, cpr);\r\nwriteb(cpr, dd->spp_cpr);\r\nif (parport_ax88796_read_control(p) != control) {\r\ndev_err(dd->dev, "write_control: read != set (%02x, %02x)\n",\r\nparport_ax88796_read_control(p), control);\r\n}\r\n}\r\nstatic unsigned char\r\nparport_ax88796_read_status(struct parport *p)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nunsigned int status = readb(dd->spp_spr);\r\nunsigned int ret = 0;\r\nif (status & AX_SPR_BUSY)\r\nret |= PARPORT_STATUS_BUSY;\r\nif (status & AX_SPR_ACK)\r\nret |= PARPORT_STATUS_ACK;\r\nif (status & AX_SPR_ERR)\r\nret |= PARPORT_STATUS_ERROR;\r\nif (status & AX_SPR_SLCT)\r\nret |= PARPORT_STATUS_SELECT;\r\nif (status & AX_SPR_PE)\r\nret |= PARPORT_STATUS_PAPEROUT;\r\nreturn ret;\r\n}\r\nstatic unsigned char\r\nparport_ax88796_frob_control(struct parport *p, unsigned char mask,\r\nunsigned char val)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nunsigned char old = parport_ax88796_read_control(p);\r\ndev_dbg(dd->dev, "frob: mask=%02x, val=%02x, old=%02x\n",\r\nmask, val, old);\r\nparport_ax88796_write_control(p, (old & ~mask) | val);\r\nreturn old;\r\n}\r\nstatic void\r\nparport_ax88796_enable_irq(struct parport *p)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (!dd->irq_enabled) {\r\nenable_irq(p->irq);\r\ndd->irq_enabled = 1;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nparport_ax88796_disable_irq(struct parport *p)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (dd->irq_enabled) {\r\ndisable_irq(p->irq);\r\ndd->irq_enabled = 0;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nparport_ax88796_data_forward(struct parport *p)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nvoid __iomem *cpr = dd->spp_cpr;\r\nwriteb((readb(cpr) & ~AX_CPR_nDOE), cpr);\r\n}\r\nstatic void\r\nparport_ax88796_data_reverse(struct parport *p)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nvoid __iomem *cpr = dd->spp_cpr;\r\nwriteb(readb(cpr) | AX_CPR_nDOE, cpr);\r\n}\r\nstatic void\r\nparport_ax88796_init_state(struct pardevice *d, struct parport_state *s)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(d->port);\r\nmemset(s, 0, sizeof(struct parport_state));\r\ndev_dbg(dd->dev, "init_state: %p: state=%p\n", d, s);\r\ns->u.ax88796.cpr = readb(dd->spp_cpr);\r\n}\r\nstatic void\r\nparport_ax88796_save_state(struct parport *p, struct parport_state *s)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\ndev_dbg(dd->dev, "save_state: %p: state=%p\n", p, s);\r\ns->u.ax88796.cpr = readb(dd->spp_cpr);\r\n}\r\nstatic void\r\nparport_ax88796_restore_state(struct parport *p, struct parport_state *s)\r\n{\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\ndev_dbg(dd->dev, "restore_state: %p: state=%p\n", p, s);\r\nwriteb(s->u.ax88796.cpr, dd->spp_cpr);\r\n}\r\nstatic int parport_ax88796_probe(struct platform_device *pdev)\r\n{\r\nstruct device *_dev = &pdev->dev;\r\nstruct ax_drvdata *dd;\r\nstruct parport *pp = NULL;\r\nstruct resource *res;\r\nunsigned long size;\r\nint spacing;\r\nint irq;\r\nint ret;\r\ndd = kzalloc(sizeof(struct ax_drvdata), GFP_KERNEL);\r\nif (dd == NULL) {\r\ndev_err(_dev, "no memory for private data\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(_dev, "no MEM specified\n");\r\nret = -ENXIO;\r\ngoto exit_mem;\r\n}\r\nsize = resource_size(res);\r\nspacing = size / 3;\r\ndd->io = request_mem_region(res->start, size, pdev->name);\r\nif (dd->io == NULL) {\r\ndev_err(_dev, "cannot reserve memory\n");\r\nret = -ENXIO;\r\ngoto exit_mem;\r\n}\r\ndd->base = ioremap(res->start, size);\r\nif (dd->base == NULL) {\r\ndev_err(_dev, "cannot ioremap region\n");\r\nret = -ENXIO;\r\ngoto exit_res;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nirq = PARPORT_IRQ_NONE;\r\npp = parport_register_port((unsigned long)dd->base, irq,\r\nPARPORT_DMA_NONE,\r\n&parport_ax88796_ops);\r\nif (pp == NULL) {\r\ndev_err(_dev, "failed to register parallel port\n");\r\nret = -ENOMEM;\r\ngoto exit_unmap;\r\n}\r\npp->private_data = dd;\r\ndd->parport = pp;\r\ndd->dev = _dev;\r\ndd->spp_data = dd->base;\r\ndd->spp_spr = dd->base + (spacing * 1);\r\ndd->spp_cpr = dd->base + (spacing * 2);\r\nwriteb(AX_CPR_STRB, dd->spp_cpr);\r\nif (irq >= 0) {\r\nret = request_irq(irq, parport_irq_handler,\r\nIRQF_TRIGGER_FALLING, pdev->name, pp);\r\nif (ret < 0)\r\ngoto exit_port;\r\ndd->irq_enabled = 1;\r\n}\r\nplatform_set_drvdata(pdev, pp);\r\ndev_info(_dev, "attached parallel port driver\n");\r\nparport_announce_port(pp);\r\nreturn 0;\r\nexit_port:\r\nparport_remove_port(pp);\r\nexit_unmap:\r\niounmap(dd->base);\r\nexit_res:\r\nrelease_resource(dd->io);\r\nkfree(dd->io);\r\nexit_mem:\r\nkfree(dd);\r\nreturn ret;\r\n}\r\nstatic int parport_ax88796_remove(struct platform_device *pdev)\r\n{\r\nstruct parport *p = platform_get_drvdata(pdev);\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nfree_irq(p->irq, p);\r\nparport_remove_port(p);\r\niounmap(dd->base);\r\nrelease_resource(dd->io);\r\nkfree(dd->io);\r\nkfree(dd);\r\nreturn 0;\r\n}\r\nstatic int parport_ax88796_suspend(struct platform_device *dev,\r\npm_message_t state)\r\n{\r\nstruct parport *p = platform_get_drvdata(dev);\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nparport_ax88796_save_state(p, &dd->suspend);\r\nwriteb(AX_CPR_nDOE | AX_CPR_STRB, dd->spp_cpr);\r\nreturn 0;\r\n}\r\nstatic int parport_ax88796_resume(struct platform_device *dev)\r\n{\r\nstruct parport *p = platform_get_drvdata(dev);\r\nstruct ax_drvdata *dd = pp_to_drv(p);\r\nparport_ax88796_restore_state(p, &dd->suspend);\r\nreturn 0;\r\n}
