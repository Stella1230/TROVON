static inline struct reset_data *rcdev_to_reset_data(struct reset_controller_dev *rcdev)\r\n{\r\nreturn container_of(rcdev, struct reset_data, rcdev);\r\n}\r\nstatic int sun4i_a10_display_assert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct reset_data *data = rcdev_to_reset_data(rcdev);\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(data->lock, flags);\r\nreg = readl(data->reg);\r\nwritel(reg & ~BIT(data->offset + id), data->reg);\r\nspin_unlock_irqrestore(data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sun4i_a10_display_deassert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct reset_data *data = rcdev_to_reset_data(rcdev);\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(data->lock, flags);\r\nreg = readl(data->reg);\r\nwritel(reg | BIT(data->offset + id), data->reg);\r\nspin_unlock_irqrestore(data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sun4i_a10_display_status(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct reset_data *data = rcdev_to_reset_data(rcdev);\r\nreturn !(readl(data->reg) & BIT(data->offset + id));\r\n}\r\nstatic int sun4i_a10_display_reset_xlate(struct reset_controller_dev *rcdev,\r\nconst struct of_phandle_args *spec)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init sun4i_a10_display_init(struct device_node *node,\r\nconst struct sun4i_a10_display_clk_data *data)\r\n{\r\nconst char *parents[4];\r\nconst char *clk_name = node->name;\r\nstruct reset_data *reset_data;\r\nstruct clk_divider *div = NULL;\r\nstruct clk_gate *gate;\r\nstruct resource res;\r\nstruct clk_mux *mux;\r\nvoid __iomem *reg;\r\nstruct clk *clk;\r\nint ret;\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\nreg = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(reg)) {\r\npr_err("%s: Could not map the clock registers\n", clk_name);\r\nreturn;\r\n}\r\nret = of_clk_parent_fill(node, parents, data->parents);\r\nif (ret != data->parents) {\r\npr_err("%s: Could not retrieve the parents\n", clk_name);\r\ngoto unmap;\r\n}\r\nmux = kzalloc(sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\ngoto unmap;\r\nmux->reg = reg;\r\nmux->shift = data->offset_mux;\r\nmux->mask = (1 << data->width_mux) - 1;\r\nmux->lock = &sun4i_a10_display_lock;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\ngoto free_mux;\r\ngate->reg = reg;\r\ngate->bit_idx = data->offset_en;\r\ngate->lock = &sun4i_a10_display_lock;\r\nif (data->has_div) {\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\ngoto free_gate;\r\ndiv->reg = reg;\r\ndiv->shift = data->offset_div;\r\ndiv->width = data->width_div;\r\ndiv->lock = &sun4i_a10_display_lock;\r\n}\r\nclk = clk_register_composite(NULL, clk_name,\r\nparents, data->parents,\r\n&mux->hw, &clk_mux_ops,\r\ndata->has_div ? &div->hw : NULL,\r\ndata->has_div ? &clk_divider_ops : NULL,\r\n&gate->hw, &clk_gate_ops,\r\ndata->flags);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: Couldn't register the clock\n", clk_name);\r\ngoto free_div;\r\n}\r\nret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nif (ret) {\r\npr_err("%s: Couldn't register DT provider\n", clk_name);\r\ngoto free_clk;\r\n}\r\nif (!data->num_rst)\r\nreturn;\r\nreset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);\r\nif (!reset_data)\r\ngoto free_of_clk;\r\nreset_data->reg = reg;\r\nreset_data->offset = data->offset_rst;\r\nreset_data->lock = &sun4i_a10_display_lock;\r\nreset_data->rcdev.nr_resets = data->num_rst;\r\nreset_data->rcdev.ops = &sun4i_a10_display_reset_ops;\r\nreset_data->rcdev.of_node = node;\r\nif (data->num_rst == 1) {\r\nreset_data->rcdev.of_reset_n_cells = 0;\r\nreset_data->rcdev.of_xlate = &sun4i_a10_display_reset_xlate;\r\n} else {\r\nreset_data->rcdev.of_reset_n_cells = 1;\r\n}\r\nif (reset_controller_register(&reset_data->rcdev)) {\r\npr_err("%s: Couldn't register the reset controller\n",\r\nclk_name);\r\ngoto free_reset;\r\n}\r\nreturn;\r\nfree_reset:\r\nkfree(reset_data);\r\nfree_of_clk:\r\nof_clk_del_provider(node);\r\nfree_clk:\r\nclk_unregister_composite(clk);\r\nfree_div:\r\nkfree(div);\r\nfree_gate:\r\nkfree(gate);\r\nfree_mux:\r\nkfree(mux);\r\nunmap:\r\niounmap(reg);\r\nof_address_to_resource(node, 0, &res);\r\nrelease_mem_region(res.start, resource_size(&res));\r\n}\r\nstatic void __init sun4i_a10_tcon_ch0_setup(struct device_node *node)\r\n{\r\nsun4i_a10_display_init(node, &sun4i_a10_tcon_ch0_data);\r\n}\r\nstatic void __init sun4i_a10_display_setup(struct device_node *node)\r\n{\r\nsun4i_a10_display_init(node, &sun4i_a10_display_data);\r\n}
