static void dbg_hcs_params(struct fotg210_hcd *fotg210, char *label)\r\n{\r\nu32 params = fotg210_readl(fotg210, &fotg210->caps->hcs_params);\r\nfotg210_dbg(fotg210, "%s hcs_params 0x%x ports=%d\n", label, params,\r\nHCS_N_PORTS(params));\r\n}\r\nstatic void dbg_hcc_params(struct fotg210_hcd *fotg210, char *label)\r\n{\r\nu32 params = fotg210_readl(fotg210, &fotg210->caps->hcc_params);\r\nfotg210_dbg(fotg210, "%s hcc_params %04x uframes %s%s\n", label,\r\nparams,\r\nHCC_PGM_FRAMELISTLEN(params) ? "256/512/1024" : "1024",\r\nHCC_CANPARK(params) ? " park" : "");\r\n}\r\nstatic void __maybe_unused\r\ndbg_qtd(const char *label, struct fotg210_hcd *fotg210, struct fotg210_qtd *qtd)\r\n{\r\nfotg210_dbg(fotg210, "%s td %p n%08x %08x t%08x p0=%08x\n", label, qtd,\r\nhc32_to_cpup(fotg210, &qtd->hw_next),\r\nhc32_to_cpup(fotg210, &qtd->hw_alt_next),\r\nhc32_to_cpup(fotg210, &qtd->hw_token),\r\nhc32_to_cpup(fotg210, &qtd->hw_buf[0]));\r\nif (qtd->hw_buf[1])\r\nfotg210_dbg(fotg210, " p1=%08x p2=%08x p3=%08x p4=%08x\n",\r\nhc32_to_cpup(fotg210, &qtd->hw_buf[1]),\r\nhc32_to_cpup(fotg210, &qtd->hw_buf[2]),\r\nhc32_to_cpup(fotg210, &qtd->hw_buf[3]),\r\nhc32_to_cpup(fotg210, &qtd->hw_buf[4]));\r\n}\r\nstatic void __maybe_unused\r\ndbg_qh(const char *label, struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\r\n{\r\nstruct fotg210_qh_hw *hw = qh->hw;\r\nfotg210_dbg(fotg210, "%s qh %p n%08x info %x %x qtd %x\n", label, qh,\r\nhw->hw_next, hw->hw_info1, hw->hw_info2,\r\nhw->hw_current);\r\ndbg_qtd("overlay", fotg210, (struct fotg210_qtd *) &hw->hw_qtd_next);\r\n}\r\nstatic void __maybe_unused\r\ndbg_itd(const char *label, struct fotg210_hcd *fotg210, struct fotg210_itd *itd)\r\n{\r\nfotg210_dbg(fotg210, "%s[%d] itd %p, next %08x, urb %p\n", label,\r\nitd->frame, itd, hc32_to_cpu(fotg210, itd->hw_next),\r\nitd->urb);\r\nfotg210_dbg(fotg210,\r\n" trans: %08x %08x %08x %08x %08x %08x %08x %08x\n",\r\nhc32_to_cpu(fotg210, itd->hw_transaction[0]),\r\nhc32_to_cpu(fotg210, itd->hw_transaction[1]),\r\nhc32_to_cpu(fotg210, itd->hw_transaction[2]),\r\nhc32_to_cpu(fotg210, itd->hw_transaction[3]),\r\nhc32_to_cpu(fotg210, itd->hw_transaction[4]),\r\nhc32_to_cpu(fotg210, itd->hw_transaction[5]),\r\nhc32_to_cpu(fotg210, itd->hw_transaction[6]),\r\nhc32_to_cpu(fotg210, itd->hw_transaction[7]));\r\nfotg210_dbg(fotg210,\r\n" buf: %08x %08x %08x %08x %08x %08x %08x\n",\r\nhc32_to_cpu(fotg210, itd->hw_bufp[0]),\r\nhc32_to_cpu(fotg210, itd->hw_bufp[1]),\r\nhc32_to_cpu(fotg210, itd->hw_bufp[2]),\r\nhc32_to_cpu(fotg210, itd->hw_bufp[3]),\r\nhc32_to_cpu(fotg210, itd->hw_bufp[4]),\r\nhc32_to_cpu(fotg210, itd->hw_bufp[5]),\r\nhc32_to_cpu(fotg210, itd->hw_bufp[6]));\r\nfotg210_dbg(fotg210, " index: %d %d %d %d %d %d %d %d\n",\r\nitd->index[0], itd->index[1], itd->index[2],\r\nitd->index[3], itd->index[4], itd->index[5],\r\nitd->index[6], itd->index[7]);\r\n}\r\nstatic int __maybe_unused\r\ndbg_status_buf(char *buf, unsigned len, const char *label, u32 status)\r\n{\r\nreturn scnprintf(buf, len, "%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s",\r\nlabel, label[0] ? " " : "", status,\r\n(status & STS_ASS) ? " Async" : "",\r\n(status & STS_PSS) ? " Periodic" : "",\r\n(status & STS_RECL) ? " Recl" : "",\r\n(status & STS_HALT) ? " Halt" : "",\r\n(status & STS_IAA) ? " IAA" : "",\r\n(status & STS_FATAL) ? " FATAL" : "",\r\n(status & STS_FLR) ? " FLR" : "",\r\n(status & STS_PCD) ? " PCD" : "",\r\n(status & STS_ERR) ? " ERR" : "",\r\n(status & STS_INT) ? " INT" : "");\r\n}\r\nstatic int __maybe_unused\r\ndbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)\r\n{\r\nreturn scnprintf(buf, len, "%s%sintrenable %02x%s%s%s%s%s%s",\r\nlabel, label[0] ? " " : "", enable,\r\n(enable & STS_IAA) ? " IAA" : "",\r\n(enable & STS_FATAL) ? " FATAL" : "",\r\n(enable & STS_FLR) ? " FLR" : "",\r\n(enable & STS_PCD) ? " PCD" : "",\r\n(enable & STS_ERR) ? " ERR" : "",\r\n(enable & STS_INT) ? " INT" : "");\r\n}\r\nstatic int dbg_command_buf(char *buf, unsigned len, const char *label,\r\nu32 command)\r\n{\r\nreturn scnprintf(buf, len,\r\n"%s%scommand %07x %s=%d ithresh=%d%s%s%s period=%s%s %s",\r\nlabel, label[0] ? " " : "", command,\r\n(command & CMD_PARK) ? " park" : "(park)",\r\nCMD_PARK_CNT(command),\r\n(command >> 16) & 0x3f,\r\n(command & CMD_IAAD) ? " IAAD" : "",\r\n(command & CMD_ASE) ? " Async" : "",\r\n(command & CMD_PSE) ? " Periodic" : "",\r\nfls_strings[(command >> 2) & 0x3],\r\n(command & CMD_RESET) ? " Reset" : "",\r\n(command & CMD_RUN) ? "RUN" : "HALT");\r\n}\r\nstatic char *dbg_port_buf(char *buf, unsigned len, const char *label, int port,\r\nu32 status)\r\n{\r\nchar *sig;\r\nswitch (status & (3 << 10)) {\r\ncase 0 << 10:\r\nsig = "se0";\r\nbreak;\r\ncase 1 << 10:\r\nsig = "k";\r\nbreak;\r\ncase 2 << 10:\r\nsig = "j";\r\nbreak;\r\ndefault:\r\nsig = "?";\r\nbreak;\r\n}\r\nscnprintf(buf, len, "%s%sport:%d status %06x %d sig=%s%s%s%s%s%s%s%s",\r\nlabel, label[0] ? " " : "", port, status,\r\nstatus >> 25,\r\nsig,\r\n(status & PORT_RESET) ? " RESET" : "",\r\n(status & PORT_SUSPEND) ? " SUSPEND" : "",\r\n(status & PORT_RESUME) ? " RESUME" : "",\r\n(status & PORT_PEC) ? " PEC" : "",\r\n(status & PORT_PE) ? " PE" : "",\r\n(status & PORT_CSC) ? " CSC" : "",\r\n(status & PORT_CONNECT) ? " CONNECT" : "");\r\nreturn buf;\r\n}\r\nstatic inline char speed_char(u32 scratch)\r\n{\r\nswitch (scratch & (3 << 12)) {\r\ncase QH_FULL_SPEED:\r\nreturn 'f';\r\ncase QH_LOW_SPEED:\r\nreturn 'l';\r\ncase QH_HIGH_SPEED:\r\nreturn 'h';\r\ndefault:\r\nreturn '?';\r\n}\r\n}\r\nstatic inline char token_mark(struct fotg210_hcd *fotg210, __hc32 token)\r\n{\r\n__u32 v = hc32_to_cpu(fotg210, token);\r\nif (v & QTD_STS_ACTIVE)\r\nreturn '*';\r\nif (v & QTD_STS_HALT)\r\nreturn '-';\r\nif (!IS_SHORT_READ(v))\r\nreturn ' ';\r\nreturn '/';\r\n}\r\nstatic void qh_lines(struct fotg210_hcd *fotg210, struct fotg210_qh *qh,\r\nchar **nextp, unsigned *sizep)\r\n{\r\nu32 scratch;\r\nu32 hw_curr;\r\nstruct fotg210_qtd *td;\r\nunsigned temp;\r\nunsigned size = *sizep;\r\nchar *next = *nextp;\r\nchar mark;\r\n__le32 list_end = FOTG210_LIST_END(fotg210);\r\nstruct fotg210_qh_hw *hw = qh->hw;\r\nif (hw->hw_qtd_next == list_end)\r\nmark = '@';\r\nelse\r\nmark = token_mark(fotg210, hw->hw_token);\r\nif (mark == '/') {\r\nif ((hw->hw_alt_next & QTD_MASK(fotg210)) ==\r\nfotg210->async->hw->hw_alt_next)\r\nmark = '#';\r\nelse if (hw->hw_alt_next == list_end)\r\nmark = '.';\r\n}\r\nscratch = hc32_to_cpup(fotg210, &hw->hw_info1);\r\nhw_curr = (mark == '*') ? hc32_to_cpup(fotg210, &hw->hw_current) : 0;\r\ntemp = scnprintf(next, size,\r\n"qh/%p dev%d %cs ep%d %08x %08x(%08x%c %s nak%d)",\r\nqh, scratch & 0x007f,\r\nspeed_char(scratch),\r\n(scratch >> 8) & 0x000f,\r\nscratch, hc32_to_cpup(fotg210, &hw->hw_info2),\r\nhc32_to_cpup(fotg210, &hw->hw_token), mark,\r\n(cpu_to_hc32(fotg210, QTD_TOGGLE) & hw->hw_token)\r\n? "data1" : "data0",\r\n(hc32_to_cpup(fotg210, &hw->hw_alt_next) >> 1) & 0x0f);\r\nsize -= temp;\r\nnext += temp;\r\nlist_for_each_entry(td, &qh->qtd_list, qtd_list) {\r\nscratch = hc32_to_cpup(fotg210, &td->hw_token);\r\nmark = ' ';\r\nif (hw_curr == td->qtd_dma)\r\nmark = '*';\r\nelse if (hw->hw_qtd_next == cpu_to_hc32(fotg210, td->qtd_dma))\r\nmark = '+';\r\nelse if (QTD_LENGTH(scratch)) {\r\nif (td->hw_alt_next == fotg210->async->hw->hw_alt_next)\r\nmark = '#';\r\nelse if (td->hw_alt_next != list_end)\r\nmark = '/';\r\n}\r\ntemp = snprintf(next, size,\r\n"\n\t%p%c%s len=%d %08x urb %p",\r\ntd, mark, ({ char *tmp;\r\nswitch ((scratch>>8)&0x03) {\r\ncase 0:\r\ntmp = "out";\r\nbreak;\r\ncase 1:\r\ntmp = "in";\r\nbreak;\r\ncase 2:\r\ntmp = "setup";\r\nbreak;\r\ndefault:\r\ntmp = "?";\r\nbreak;\r\n} tmp; }),\r\n(scratch >> 16) & 0x7fff,\r\nscratch,\r\ntd->urb);\r\nif (size < temp)\r\ntemp = size;\r\nsize -= temp;\r\nnext += temp;\r\nif (temp == size)\r\ngoto done;\r\n}\r\ntemp = snprintf(next, size, "\n");\r\nif (size < temp)\r\ntemp = size;\r\nsize -= temp;\r\nnext += temp;\r\ndone:\r\n*sizep = size;\r\n*nextp = next;\r\n}\r\nstatic ssize_t fill_async_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct fotg210_hcd *fotg210;\r\nunsigned long flags;\r\nunsigned temp, size;\r\nchar *next;\r\nstruct fotg210_qh *qh;\r\nhcd = bus_to_hcd(buf->bus);\r\nfotg210 = hcd_to_fotg210(hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\n*next = 0;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nfor (qh = fotg210->async->qh_next.qh; size > 0 && qh;\r\nqh = qh->qh_next.qh)\r\nqh_lines(fotg210, qh, &next, &size);\r\nif (fotg210->async_unlink && size > 0) {\r\ntemp = scnprintf(next, size, "\nunlink =\n");\r\nsize -= temp;\r\nnext += temp;\r\nfor (qh = fotg210->async_unlink; size > 0 && qh;\r\nqh = qh->unlink_next)\r\nqh_lines(fotg210, qh, &next, &size);\r\n}\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn strlen(buf->output_buf);\r\n}\r\nstatic unsigned output_buf_tds_dir(char *buf, struct fotg210_hcd *fotg210,\r\nstruct fotg210_qh_hw *hw, struct fotg210_qh *qh, unsigned size)\r\n{\r\nu32 scratch = hc32_to_cpup(fotg210, &hw->hw_info1);\r\nstruct fotg210_qtd *qtd;\r\nchar *type = "";\r\nunsigned temp = 0;\r\nlist_for_each_entry(qtd, &qh->qtd_list, qtd_list) {\r\ntemp++;\r\nswitch ((hc32_to_cpu(fotg210, qtd->hw_token) >> 8) & 0x03) {\r\ncase 0:\r\ntype = "out";\r\ncontinue;\r\ncase 1:\r\ntype = "in";\r\ncontinue;\r\n}\r\n}\r\nreturn scnprintf(buf, size, "(%c%d ep%d%s [%d/%d] q%d p%d)",\r\nspeed_char(scratch), scratch & 0x007f,\r\n(scratch >> 8) & 0x000f, type, qh->usecs,\r\nqh->c_usecs, temp, (scratch >> 16) & 0x7ff);\r\n}\r\nstatic ssize_t fill_periodic_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct fotg210_hcd *fotg210;\r\nunsigned long flags;\r\nunion fotg210_shadow p, *seen;\r\nunsigned temp, size, seen_count;\r\nchar *next;\r\nunsigned i;\r\n__hc32 tag;\r\nseen = kmalloc_array(DBG_SCHED_LIMIT, sizeof(*seen), GFP_ATOMIC);\r\nif (!seen)\r\nreturn 0;\r\nseen_count = 0;\r\nhcd = bus_to_hcd(buf->bus);\r\nfotg210 = hcd_to_fotg210(hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\ntemp = scnprintf(next, size, "size = %d\n", fotg210->periodic_size);\r\nsize -= temp;\r\nnext += temp;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nfor (i = 0; i < fotg210->periodic_size; i++) {\r\np = fotg210->pshadow[i];\r\nif (likely(!p.ptr))\r\ncontinue;\r\ntag = Q_NEXT_TYPE(fotg210, fotg210->periodic[i]);\r\ntemp = scnprintf(next, size, "%4d: ", i);\r\nsize -= temp;\r\nnext += temp;\r\ndo {\r\nstruct fotg210_qh_hw *hw;\r\nswitch (hc32_to_cpu(fotg210, tag)) {\r\ncase Q_TYPE_QH:\r\nhw = p.qh->hw;\r\ntemp = scnprintf(next, size, " qh%d-%04x/%p",\r\np.qh->period,\r\nhc32_to_cpup(fotg210,\r\n&hw->hw_info2)\r\n& (QH_CMASK | QH_SMASK),\r\np.qh);\r\nsize -= temp;\r\nnext += temp;\r\nfor (temp = 0; temp < seen_count; temp++) {\r\nif (seen[temp].ptr != p.ptr)\r\ncontinue;\r\nif (p.qh->qh_next.ptr) {\r\ntemp = scnprintf(next, size,\r\n" ...");\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nbreak;\r\n}\r\nif (temp == seen_count) {\r\ntemp = output_buf_tds_dir(next,\r\nfotg210, hw,\r\np.qh, size);\r\nif (seen_count < DBG_SCHED_LIMIT)\r\nseen[seen_count++].qh = p.qh;\r\n} else\r\ntemp = 0;\r\ntag = Q_NEXT_TYPE(fotg210, hw->hw_next);\r\np = p.qh->qh_next;\r\nbreak;\r\ncase Q_TYPE_FSTN:\r\ntemp = scnprintf(next, size,\r\n" fstn-%8x/%p",\r\np.fstn->hw_prev, p.fstn);\r\ntag = Q_NEXT_TYPE(fotg210, p.fstn->hw_next);\r\np = p.fstn->fstn_next;\r\nbreak;\r\ncase Q_TYPE_ITD:\r\ntemp = scnprintf(next, size,\r\n" itd/%p", p.itd);\r\ntag = Q_NEXT_TYPE(fotg210, p.itd->hw_next);\r\np = p.itd->itd_next;\r\nbreak;\r\n}\r\nsize -= temp;\r\nnext += temp;\r\n} while (p.ptr);\r\ntemp = scnprintf(next, size, "\n");\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nkfree(seen);\r\nreturn buf->alloc_size - size;\r\n}\r\nstatic const char *rh_state_string(struct fotg210_hcd *fotg210)\r\n{\r\nswitch (fotg210->rh_state) {\r\ncase FOTG210_RH_HALTED:\r\nreturn "halted";\r\ncase FOTG210_RH_SUSPENDED:\r\nreturn "suspended";\r\ncase FOTG210_RH_RUNNING:\r\nreturn "running";\r\ncase FOTG210_RH_STOPPING:\r\nreturn "stopping";\r\n}\r\nreturn "?";\r\n}\r\nstatic ssize_t fill_registers_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct fotg210_hcd *fotg210;\r\nunsigned long flags;\r\nunsigned temp, size, i;\r\nchar *next, scratch[80];\r\nstatic const char fmt[] = "%*s\n";\r\nstatic const char label[] = "";\r\nhcd = bus_to_hcd(buf->bus);\r\nfotg210 = hcd_to_fotg210(hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nsize = scnprintf(next, size,\r\n"bus %s, device %s\n"\r\n"%s\n"\r\n"SUSPENDED(no register access)\n",\r\nhcd->self.controller->bus->name,\r\ndev_name(hcd->self.controller),\r\nhcd->product_desc);\r\ngoto done;\r\n}\r\ni = HC_VERSION(fotg210, fotg210_readl(fotg210,\r\n&fotg210->caps->hc_capbase));\r\ntemp = scnprintf(next, size,\r\n"bus %s, device %s\n"\r\n"%s\n"\r\n"EHCI %x.%02x, rh state %s\n",\r\nhcd->self.controller->bus->name,\r\ndev_name(hcd->self.controller),\r\nhcd->product_desc,\r\ni >> 8, i & 0x0ff, rh_state_string(fotg210));\r\nsize -= temp;\r\nnext += temp;\r\ni = fotg210_readl(fotg210, &fotg210->caps->hcs_params);\r\ntemp = scnprintf(next, size, "structural params 0x%08x\n", i);\r\nsize -= temp;\r\nnext += temp;\r\ni = fotg210_readl(fotg210, &fotg210->caps->hcc_params);\r\ntemp = scnprintf(next, size, "capability params 0x%08x\n", i);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_status_buf(scratch, sizeof(scratch), label,\r\nfotg210_readl(fotg210, &fotg210->regs->status));\r\ntemp = scnprintf(next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_command_buf(scratch, sizeof(scratch), label,\r\nfotg210_readl(fotg210, &fotg210->regs->command));\r\ntemp = scnprintf(next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_intr_buf(scratch, sizeof(scratch), label,\r\nfotg210_readl(fotg210, &fotg210->regs->intr_enable));\r\ntemp = scnprintf(next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = scnprintf(next, size, "uframe %04x\n",\r\nfotg210_read_frame_index(fotg210));\r\nsize -= temp;\r\nnext += temp;\r\nif (fotg210->async_unlink) {\r\ntemp = scnprintf(next, size, "async unlink qh %p\n",\r\nfotg210->async_unlink);\r\nsize -= temp;\r\nnext += temp;\r\n}\r\n#ifdef FOTG210_STATS\r\ntemp = scnprintf(next, size,\r\n"irq normal %ld err %ld iaa %ld(lost %ld)\n",\r\nfotg210->stats.normal, fotg210->stats.error,\r\nfotg210->stats.iaa, fotg210->stats.lost_iaa);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = scnprintf(next, size, "complete %ld unlink %ld\n",\r\nfotg210->stats.complete, fotg210->stats.unlink);\r\nsize -= temp;\r\nnext += temp;\r\n#endif\r\ndone:\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn buf->alloc_size - size;\r\n}\r\nstatic struct debug_buffer\r\n*alloc_buffer(struct usb_bus *bus, ssize_t (*fill_func)(struct debug_buffer *))\r\n{\r\nstruct debug_buffer *buf;\r\nbuf = kzalloc(sizeof(struct debug_buffer), GFP_KERNEL);\r\nif (buf) {\r\nbuf->bus = bus;\r\nbuf->fill_func = fill_func;\r\nmutex_init(&buf->mutex);\r\nbuf->alloc_size = PAGE_SIZE;\r\n}\r\nreturn buf;\r\n}\r\nstatic int fill_buffer(struct debug_buffer *buf)\r\n{\r\nint ret = 0;\r\nif (!buf->output_buf)\r\nbuf->output_buf = vmalloc(buf->alloc_size);\r\nif (!buf->output_buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = buf->fill_func(buf);\r\nif (ret >= 0) {\r\nbuf->count = ret;\r\nret = 0;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t debug_output(struct file *file, char __user *user_buf,\r\nsize_t len, loff_t *offset)\r\n{\r\nstruct debug_buffer *buf = file->private_data;\r\nint ret = 0;\r\nmutex_lock(&buf->mutex);\r\nif (buf->count == 0) {\r\nret = fill_buffer(buf);\r\nif (ret != 0) {\r\nmutex_unlock(&buf->mutex);\r\ngoto out;\r\n}\r\n}\r\nmutex_unlock(&buf->mutex);\r\nret = simple_read_from_buffer(user_buf, len, offset,\r\nbuf->output_buf, buf->count);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int debug_close(struct inode *inode, struct file *file)\r\n{\r\nstruct debug_buffer *buf = file->private_data;\r\nif (buf) {\r\nvfree(buf->output_buf);\r\nkfree(buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int debug_async_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private, fill_async_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic int debug_periodic_open(struct inode *inode, struct file *file)\r\n{\r\nstruct debug_buffer *buf;\r\nbuf = alloc_buffer(inode->i_private, fill_periodic_buffer);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf->alloc_size = (sizeof(void *) == 4 ? 6 : 8)*PAGE_SIZE;\r\nfile->private_data = buf;\r\nreturn 0;\r\n}\r\nstatic int debug_registers_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private,\r\nfill_registers_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic inline void create_debug_files(struct fotg210_hcd *fotg210)\r\n{\r\nstruct usb_bus *bus = &fotg210_to_hcd(fotg210)->self;\r\nfotg210->debug_dir = debugfs_create_dir(bus->bus_name,\r\nfotg210_debug_root);\r\nif (!fotg210->debug_dir)\r\nreturn;\r\nif (!debugfs_create_file("async", S_IRUGO, fotg210->debug_dir, bus,\r\n&debug_async_fops))\r\ngoto file_error;\r\nif (!debugfs_create_file("periodic", S_IRUGO, fotg210->debug_dir, bus,\r\n&debug_periodic_fops))\r\ngoto file_error;\r\nif (!debugfs_create_file("registers", S_IRUGO, fotg210->debug_dir, bus,\r\n&debug_registers_fops))\r\ngoto file_error;\r\nreturn;\r\nfile_error:\r\ndebugfs_remove_recursive(fotg210->debug_dir);\r\n}\r\nstatic inline void remove_debug_files(struct fotg210_hcd *fotg210)\r\n{\r\ndebugfs_remove_recursive(fotg210->debug_dir);\r\n}\r\nstatic int handshake(struct fotg210_hcd *fotg210, void __iomem *ptr,\r\nu32 mask, u32 done, int usec)\r\n{\r\nu32 result;\r\ndo {\r\nresult = fotg210_readl(fotg210, ptr);\r\nif (result == ~(u32)0)\r\nreturn -ENODEV;\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay(1);\r\nusec--;\r\n} while (usec > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int fotg210_halt(struct fotg210_hcd *fotg210)\r\n{\r\nu32 temp;\r\nspin_lock_irq(&fotg210->lock);\r\nfotg210_writel(fotg210, 0, &fotg210->regs->intr_enable);\r\nfotg210->command &= ~CMD_RUN;\r\ntemp = fotg210_readl(fotg210, &fotg210->regs->command);\r\ntemp &= ~(CMD_RUN | CMD_IAAD);\r\nfotg210_writel(fotg210, temp, &fotg210->regs->command);\r\nspin_unlock_irq(&fotg210->lock);\r\nsynchronize_irq(fotg210_to_hcd(fotg210)->irq);\r\nreturn handshake(fotg210, &fotg210->regs->status,\r\nSTS_HALT, STS_HALT, 16 * 125);\r\n}\r\nstatic int fotg210_reset(struct fotg210_hcd *fotg210)\r\n{\r\nint retval;\r\nu32 command = fotg210_readl(fotg210, &fotg210->regs->command);\r\nif (fotg210->debug && !dbgp_reset_prep(fotg210_to_hcd(fotg210)))\r\nfotg210->debug = NULL;\r\ncommand |= CMD_RESET;\r\ndbg_cmd(fotg210, "reset", command);\r\nfotg210_writel(fotg210, command, &fotg210->regs->command);\r\nfotg210->rh_state = FOTG210_RH_HALTED;\r\nfotg210->next_statechange = jiffies;\r\nretval = handshake(fotg210, &fotg210->regs->command,\r\nCMD_RESET, 0, 250 * 1000);\r\nif (retval)\r\nreturn retval;\r\nif (fotg210->debug)\r\ndbgp_external_startup(fotg210_to_hcd(fotg210));\r\nfotg210->port_c_suspend = fotg210->suspended_ports =\r\nfotg210->resuming_ports = 0;\r\nreturn retval;\r\n}\r\nstatic void fotg210_quiesce(struct fotg210_hcd *fotg210)\r\n{\r\nu32 temp;\r\nif (fotg210->rh_state != FOTG210_RH_RUNNING)\r\nreturn;\r\ntemp = (fotg210->command << 10) & (STS_ASS | STS_PSS);\r\nhandshake(fotg210, &fotg210->regs->status, STS_ASS | STS_PSS, temp,\r\n16 * 125);\r\nspin_lock_irq(&fotg210->lock);\r\nfotg210->command &= ~(CMD_ASE | CMD_PSE);\r\nfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\r\nspin_unlock_irq(&fotg210->lock);\r\nhandshake(fotg210, &fotg210->regs->status, STS_ASS | STS_PSS, 0,\r\n16 * 125);\r\n}\r\nstatic void fotg210_set_command_bit(struct fotg210_hcd *fotg210, u32 bit)\r\n{\r\nfotg210->command |= bit;\r\nfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\r\nfotg210_readl(fotg210, &fotg210->regs->command);\r\n}\r\nstatic void fotg210_clear_command_bit(struct fotg210_hcd *fotg210, u32 bit)\r\n{\r\nfotg210->command &= ~bit;\r\nfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\r\nfotg210_readl(fotg210, &fotg210->regs->command);\r\n}\r\nstatic void fotg210_enable_event(struct fotg210_hcd *fotg210, unsigned event,\r\nbool resched)\r\n{\r\nktime_t *timeout = &fotg210->hr_timeouts[event];\r\nif (resched)\r\n*timeout = ktime_add(ktime_get(),\r\nktime_set(0, event_delays_ns[event]));\r\nfotg210->enabled_hrtimer_events |= (1 << event);\r\nif (event < fotg210->next_hrtimer_event) {\r\nfotg210->next_hrtimer_event = event;\r\nhrtimer_start_range_ns(&fotg210->hrtimer, *timeout,\r\nNSEC_PER_MSEC, HRTIMER_MODE_ABS);\r\n}\r\n}\r\nstatic void fotg210_poll_ASS(struct fotg210_hcd *fotg210)\r\n{\r\nunsigned actual, want;\r\nif (fotg210->rh_state != FOTG210_RH_RUNNING)\r\nreturn;\r\nwant = (fotg210->command & CMD_ASE) ? STS_ASS : 0;\r\nactual = fotg210_readl(fotg210, &fotg210->regs->status) & STS_ASS;\r\nif (want != actual) {\r\nif (fotg210->ASS_poll_count++ < 20) {\r\nfotg210_enable_event(fotg210, FOTG210_HRTIMER_POLL_ASS,\r\ntrue);\r\nreturn;\r\n}\r\nfotg210_dbg(fotg210, "Waited too long for the async schedule status (%x/%x), giving up\n",\r\nwant, actual);\r\n}\r\nfotg210->ASS_poll_count = 0;\r\nif (want == 0) {\r\nif (fotg210->async_count > 0)\r\nfotg210_set_command_bit(fotg210, CMD_ASE);\r\n} else {\r\nif (fotg210->async_count == 0) {\r\nfotg210_enable_event(fotg210,\r\nFOTG210_HRTIMER_DISABLE_ASYNC,\r\ntrue);\r\n}\r\n}\r\n}\r\nstatic void fotg210_disable_ASE(struct fotg210_hcd *fotg210)\r\n{\r\nfotg210_clear_command_bit(fotg210, CMD_ASE);\r\n}\r\nstatic void fotg210_poll_PSS(struct fotg210_hcd *fotg210)\r\n{\r\nunsigned actual, want;\r\nif (fotg210->rh_state != FOTG210_RH_RUNNING)\r\nreturn;\r\nwant = (fotg210->command & CMD_PSE) ? STS_PSS : 0;\r\nactual = fotg210_readl(fotg210, &fotg210->regs->status) & STS_PSS;\r\nif (want != actual) {\r\nif (fotg210->PSS_poll_count++ < 20) {\r\nfotg210_enable_event(fotg210, FOTG210_HRTIMER_POLL_PSS,\r\ntrue);\r\nreturn;\r\n}\r\nfotg210_dbg(fotg210, "Waited too long for the periodic schedule status (%x/%x), giving up\n",\r\nwant, actual);\r\n}\r\nfotg210->PSS_poll_count = 0;\r\nif (want == 0) {\r\nif (fotg210->periodic_count > 0)\r\nfotg210_set_command_bit(fotg210, CMD_PSE);\r\n} else {\r\nif (fotg210->periodic_count == 0) {\r\nfotg210_enable_event(fotg210,\r\nFOTG210_HRTIMER_DISABLE_PERIODIC,\r\ntrue);\r\n}\r\n}\r\n}\r\nstatic void fotg210_disable_PSE(struct fotg210_hcd *fotg210)\r\n{\r\nfotg210_clear_command_bit(fotg210, CMD_PSE);\r\n}\r\nstatic void fotg210_handle_controller_death(struct fotg210_hcd *fotg210)\r\n{\r\nif (!(fotg210_readl(fotg210, &fotg210->regs->status) & STS_HALT)) {\r\nif (fotg210->died_poll_count++ < 5) {\r\nfotg210_enable_event(fotg210,\r\nFOTG210_HRTIMER_POLL_DEAD, true);\r\nreturn;\r\n}\r\nfotg210_warn(fotg210, "Waited too long for the controller to stop, giving up\n");\r\n}\r\nfotg210->rh_state = FOTG210_RH_HALTED;\r\nfotg210_writel(fotg210, 0, &fotg210->regs->intr_enable);\r\nfotg210_work(fotg210);\r\nend_unlink_async(fotg210);\r\n}\r\nstatic void fotg210_handle_intr_unlinks(struct fotg210_hcd *fotg210)\r\n{\r\nbool stopped = (fotg210->rh_state < FOTG210_RH_RUNNING);\r\nfotg210->intr_unlinking = true;\r\nwhile (fotg210->intr_unlink) {\r\nstruct fotg210_qh *qh = fotg210->intr_unlink;\r\nif (!stopped && qh->unlink_cycle == fotg210->intr_unlink_cycle)\r\nbreak;\r\nfotg210->intr_unlink = qh->unlink_next;\r\nqh->unlink_next = NULL;\r\nend_unlink_intr(fotg210, qh);\r\n}\r\nif (fotg210->intr_unlink) {\r\nfotg210_enable_event(fotg210, FOTG210_HRTIMER_UNLINK_INTR,\r\ntrue);\r\n++fotg210->intr_unlink_cycle;\r\n}\r\nfotg210->intr_unlinking = false;\r\n}\r\nstatic void start_free_itds(struct fotg210_hcd *fotg210)\r\n{\r\nif (!(fotg210->enabled_hrtimer_events &\r\nBIT(FOTG210_HRTIMER_FREE_ITDS))) {\r\nfotg210->last_itd_to_free = list_entry(\r\nfotg210->cached_itd_list.prev,\r\nstruct fotg210_itd, itd_list);\r\nfotg210_enable_event(fotg210, FOTG210_HRTIMER_FREE_ITDS, true);\r\n}\r\n}\r\nstatic void end_free_itds(struct fotg210_hcd *fotg210)\r\n{\r\nstruct fotg210_itd *itd, *n;\r\nif (fotg210->rh_state < FOTG210_RH_RUNNING)\r\nfotg210->last_itd_to_free = NULL;\r\nlist_for_each_entry_safe(itd, n, &fotg210->cached_itd_list, itd_list) {\r\nlist_del(&itd->itd_list);\r\ndma_pool_free(fotg210->itd_pool, itd, itd->itd_dma);\r\nif (itd == fotg210->last_itd_to_free)\r\nbreak;\r\n}\r\nif (!list_empty(&fotg210->cached_itd_list))\r\nstart_free_itds(fotg210);\r\n}\r\nstatic void fotg210_iaa_watchdog(struct fotg210_hcd *fotg210)\r\n{\r\nif (fotg210->rh_state != FOTG210_RH_RUNNING)\r\nreturn;\r\nif (fotg210->async_iaa) {\r\nu32 cmd, status;\r\ncmd = fotg210_readl(fotg210, &fotg210->regs->command);\r\nstatus = fotg210_readl(fotg210, &fotg210->regs->status);\r\nif ((status & STS_IAA) || !(cmd & CMD_IAAD)) {\r\nCOUNT(fotg210->stats.lost_iaa);\r\nfotg210_writel(fotg210, STS_IAA,\r\n&fotg210->regs->status);\r\n}\r\nfotg210_dbg(fotg210, "IAA watchdog: status %x cmd %x\n",\r\nstatus, cmd);\r\nend_unlink_async(fotg210);\r\n}\r\n}\r\nstatic void turn_on_io_watchdog(struct fotg210_hcd *fotg210)\r\n{\r\nif (fotg210->rh_state != FOTG210_RH_RUNNING ||\r\n(fotg210->enabled_hrtimer_events &\r\nBIT(FOTG210_HRTIMER_IO_WATCHDOG)))\r\nreturn;\r\nif (fotg210->isoc_count > 0 || (fotg210->need_io_watchdog &&\r\nfotg210->async_count + fotg210->intr_count > 0))\r\nfotg210_enable_event(fotg210, FOTG210_HRTIMER_IO_WATCHDOG,\r\ntrue);\r\n}\r\nstatic enum hrtimer_restart fotg210_hrtimer_func(struct hrtimer *t)\r\n{\r\nstruct fotg210_hcd *fotg210 =\r\ncontainer_of(t, struct fotg210_hcd, hrtimer);\r\nktime_t now;\r\nunsigned long events;\r\nunsigned long flags;\r\nunsigned e;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nevents = fotg210->enabled_hrtimer_events;\r\nfotg210->enabled_hrtimer_events = 0;\r\nfotg210->next_hrtimer_event = FOTG210_HRTIMER_NO_EVENT;\r\nnow = ktime_get();\r\nfor_each_set_bit(e, &events, FOTG210_HRTIMER_NUM_EVENTS) {\r\nif (now.tv64 >= fotg210->hr_timeouts[e].tv64)\r\nevent_handlers[e](fotg210);\r\nelse\r\nfotg210_enable_event(fotg210, e, false);\r\n}\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int check_reset_complete(struct fotg210_hcd *fotg210, int index,\r\nu32 __iomem *status_reg, int port_status)\r\n{\r\nif (!(port_status & PORT_CONNECT))\r\nreturn port_status;\r\nif (!(port_status & PORT_PE))\r\nfotg210_dbg(fotg210, "Failed to enable port %d on root hub TT\n",\r\nindex + 1);\r\nelse\r\nfotg210_dbg(fotg210, "port %d reset complete, port enabled\n",\r\nindex + 1);\r\nreturn port_status;\r\n}\r\nstatic int fotg210_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nu32 temp, status;\r\nu32 mask;\r\nint retval = 1;\r\nunsigned long flags;\r\nbuf[0] = 0;\r\nstatus = fotg210->resuming_ports;\r\nmask = PORT_CSC | PORT_PEC;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\ntemp = fotg210_readl(fotg210, &fotg210->regs->port_status);\r\nif ((temp & mask) != 0 || test_bit(0, &fotg210->port_c_suspend) ||\r\n(fotg210->reset_done[0] &&\r\ntime_after_eq(jiffies, fotg210->reset_done[0]))) {\r\nbuf[0] |= 1 << 1;\r\nstatus = STS_PCD;\r\n}\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn status ? retval : 0;\r\n}\r\nstatic void fotg210_hub_descriptor(struct fotg210_hcd *fotg210,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nint ports = HCS_N_PORTS(fotg210->hcs_params);\r\nu16 temp;\r\ndesc->bDescriptorType = USB_DT_HUB;\r\ndesc->bPwrOn2PwrGood = 10;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = ports;\r\ntemp = 1 + (ports / 8);\r\ndesc->bDescLength = 7 + 2 * temp;\r\nmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\r\nmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\r\ntemp = HUB_CHAR_INDV_PORT_OCPM;\r\ntemp |= HUB_CHAR_NO_LPSM;\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\n}\r\nstatic int fotg210_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nint ports = HCS_N_PORTS(fotg210->hcs_params);\r\nu32 __iomem *status_reg = &fotg210->regs->port_status;\r\nu32 temp, temp1, status;\r\nunsigned long flags;\r\nint retval = 0;\r\nunsigned selector;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = fotg210_readl(fotg210, status_reg);\r\ntemp &= ~PORT_RWC_BITS;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nfotg210_writel(fotg210, temp & ~PORT_PE, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nfotg210_writel(fotg210, temp | PORT_PEC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (temp & PORT_RESET)\r\ngoto error;\r\nif (!(temp & PORT_SUSPEND))\r\nbreak;\r\nif ((temp & PORT_PE) == 0)\r\ngoto error;\r\nfotg210_writel(fotg210, temp | PORT_RESUME, status_reg);\r\nfotg210->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(USB_RESUME_TIMEOUT);\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nclear_bit(wIndex, &fotg210->port_c_suspend);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nfotg210_writel(fotg210, temp | PORT_CSC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nfotg210_writel(fotg210, temp | OTGISR_OVC,\r\n&fotg210->regs->otgisr);\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nfotg210_readl(fotg210, &fotg210->regs->command);\r\nbreak;\r\ncase GetHubDescriptor:\r\nfotg210_hub_descriptor(fotg210, (struct usb_hub_descriptor *)\r\nbuf);\r\nbreak;\r\ncase GetHubStatus:\r\nmemset(buf, 0, 4);\r\nbreak;\r\ncase GetPortStatus:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nstatus = 0;\r\ntemp = fotg210_readl(fotg210, status_reg);\r\nif (temp & PORT_CSC)\r\nstatus |= USB_PORT_STAT_C_CONNECTION << 16;\r\nif (temp & PORT_PEC)\r\nstatus |= USB_PORT_STAT_C_ENABLE << 16;\r\ntemp1 = fotg210_readl(fotg210, &fotg210->regs->otgisr);\r\nif (temp1 & OTGISR_OVC)\r\nstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\r\nif (temp & PORT_RESUME) {\r\nif (!fotg210->reset_done[wIndex]) {\r\nfotg210->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\nmod_timer(&fotg210_to_hcd(fotg210)->rh_timer,\r\nfotg210->reset_done[wIndex]);\r\n}\r\nelse if (time_after_eq(jiffies,\r\nfotg210->reset_done[wIndex])) {\r\nclear_bit(wIndex, &fotg210->suspended_ports);\r\nset_bit(wIndex, &fotg210->port_c_suspend);\r\nfotg210->reset_done[wIndex] = 0;\r\ntemp = fotg210_readl(fotg210, status_reg);\r\nfotg210_writel(fotg210, temp &\r\n~(PORT_RWC_BITS | PORT_RESUME),\r\nstatus_reg);\r\nclear_bit(wIndex, &fotg210->resuming_ports);\r\nretval = handshake(fotg210, status_reg,\r\nPORT_RESUME, 0, 2000);\r\nif (retval != 0) {\r\nfotg210_err(fotg210,\r\n"port %d resume error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));\r\n}\r\n}\r\nif ((temp & PORT_RESET) && time_after_eq(jiffies,\r\nfotg210->reset_done[wIndex])) {\r\nstatus |= USB_PORT_STAT_C_RESET << 16;\r\nfotg210->reset_done[wIndex] = 0;\r\nclear_bit(wIndex, &fotg210->resuming_ports);\r\nfotg210_writel(fotg210,\r\ntemp & ~(PORT_RWC_BITS | PORT_RESET),\r\nstatus_reg);\r\nretval = handshake(fotg210, status_reg,\r\nPORT_RESET, 0, 1000);\r\nif (retval != 0) {\r\nfotg210_err(fotg210, "port %d reset error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp = check_reset_complete(fotg210, wIndex, status_reg,\r\nfotg210_readl(fotg210, status_reg));\r\n}\r\nif (!(temp & (PORT_RESUME|PORT_RESET))) {\r\nfotg210->reset_done[wIndex] = 0;\r\nclear_bit(wIndex, &fotg210->resuming_ports);\r\n}\r\nif ((temp & PORT_CONNECT) &&\r\ntest_bit(wIndex, &fotg210->companion_ports)) {\r\ntemp &= ~PORT_RWC_BITS;\r\nfotg210_writel(fotg210, temp, status_reg);\r\nfotg210_dbg(fotg210, "port %d --> companion\n",\r\nwIndex + 1);\r\ntemp = fotg210_readl(fotg210, status_reg);\r\n}\r\nif (temp & PORT_CONNECT) {\r\nstatus |= USB_PORT_STAT_CONNECTION;\r\nstatus |= fotg210_port_speed(fotg210, temp);\r\n}\r\nif (temp & PORT_PE)\r\nstatus |= USB_PORT_STAT_ENABLE;\r\nif (temp & (PORT_SUSPEND|PORT_RESUME)) {\r\nstatus |= USB_PORT_STAT_SUSPEND;\r\n} else if (test_bit(wIndex, &fotg210->suspended_ports)) {\r\nclear_bit(wIndex, &fotg210->suspended_ports);\r\nclear_bit(wIndex, &fotg210->resuming_ports);\r\nfotg210->reset_done[wIndex] = 0;\r\nif (temp & PORT_PE)\r\nset_bit(wIndex, &fotg210->port_c_suspend);\r\n}\r\ntemp1 = fotg210_readl(fotg210, &fotg210->regs->otgisr);\r\nif (temp1 & OTGISR_OVC)\r\nstatus |= USB_PORT_STAT_OVERCURRENT;\r\nif (temp & PORT_RESET)\r\nstatus |= USB_PORT_STAT_RESET;\r\nif (test_bit(wIndex, &fotg210->port_c_suspend))\r\nstatus |= USB_PORT_STAT_C_SUSPEND << 16;\r\nif (status & ~0xffff)\r\ndbg_port(fotg210, "GetStatus", wIndex + 1, temp);\r\nput_unaligned_le32(status, buf);\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nselector = wIndex >> 8;\r\nwIndex &= 0xff;\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = fotg210_readl(fotg210, status_reg);\r\ntemp &= ~PORT_RWC_BITS;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif ((temp & PORT_PE) == 0\r\n|| (temp & PORT_RESET) != 0)\r\ngoto error;\r\nfotg210_writel(fotg210, temp | PORT_SUSPEND,\r\nstatus_reg);\r\nset_bit(wIndex, &fotg210->suspended_ports);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nif (temp & PORT_RESUME)\r\ngoto error;\r\nfotg210_dbg(fotg210, "port %d reset\n", wIndex + 1);\r\ntemp |= PORT_RESET;\r\ntemp &= ~PORT_PE;\r\nfotg210->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(50);\r\nfotg210_writel(fotg210, temp, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\nif (!selector || selector > 5)\r\ngoto error;\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nfotg210_quiesce(fotg210);\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\ntemp = fotg210_readl(fotg210, status_reg) &\r\n~PORT_RWC_BITS;\r\nif (temp & PORT_PE)\r\nfotg210_writel(fotg210, temp | PORT_SUSPEND,\r\nstatus_reg);\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nfotg210_halt(fotg210);\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\ntemp = fotg210_readl(fotg210, status_reg);\r\ntemp |= selector << 16;\r\nfotg210_writel(fotg210, temp, status_reg);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nfotg210_readl(fotg210, &fotg210->regs->command);\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void __maybe_unused fotg210_relinquish_port(struct usb_hcd *hcd,\r\nint portnum)\r\n{\r\nreturn;\r\n}\r\nstatic int __maybe_unused fotg210_port_handed_over(struct usb_hcd *hcd,\r\nint portnum)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void fotg210_qtd_init(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qtd *qtd, dma_addr_t dma)\r\n{\r\nmemset(qtd, 0, sizeof(*qtd));\r\nqtd->qtd_dma = dma;\r\nqtd->hw_token = cpu_to_hc32(fotg210, QTD_STS_HALT);\r\nqtd->hw_next = FOTG210_LIST_END(fotg210);\r\nqtd->hw_alt_next = FOTG210_LIST_END(fotg210);\r\nINIT_LIST_HEAD(&qtd->qtd_list);\r\n}\r\nstatic struct fotg210_qtd *fotg210_qtd_alloc(struct fotg210_hcd *fotg210,\r\ngfp_t flags)\r\n{\r\nstruct fotg210_qtd *qtd;\r\ndma_addr_t dma;\r\nqtd = dma_pool_alloc(fotg210->qtd_pool, flags, &dma);\r\nif (qtd != NULL)\r\nfotg210_qtd_init(fotg210, qtd, dma);\r\nreturn qtd;\r\n}\r\nstatic inline void fotg210_qtd_free(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qtd *qtd)\r\n{\r\ndma_pool_free(fotg210->qtd_pool, qtd, qtd->qtd_dma);\r\n}\r\nstatic void qh_destroy(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\r\n{\r\nif (!list_empty(&qh->qtd_list) || qh->qh_next.ptr) {\r\nfotg210_dbg(fotg210, "unused qh not empty!\n");\r\nBUG();\r\n}\r\nif (qh->dummy)\r\nfotg210_qtd_free(fotg210, qh->dummy);\r\ndma_pool_free(fotg210->qh_pool, qh->hw, qh->qh_dma);\r\nkfree(qh);\r\n}\r\nstatic struct fotg210_qh *fotg210_qh_alloc(struct fotg210_hcd *fotg210,\r\ngfp_t flags)\r\n{\r\nstruct fotg210_qh *qh;\r\ndma_addr_t dma;\r\nqh = kzalloc(sizeof(*qh), GFP_ATOMIC);\r\nif (!qh)\r\ngoto done;\r\nqh->hw = (struct fotg210_qh_hw *)\r\ndma_pool_alloc(fotg210->qh_pool, flags, &dma);\r\nif (!qh->hw)\r\ngoto fail;\r\nmemset(qh->hw, 0, sizeof(*qh->hw));\r\nqh->qh_dma = dma;\r\nINIT_LIST_HEAD(&qh->qtd_list);\r\nqh->dummy = fotg210_qtd_alloc(fotg210, flags);\r\nif (qh->dummy == NULL) {\r\nfotg210_dbg(fotg210, "no dummy td\n");\r\ngoto fail1;\r\n}\r\ndone:\r\nreturn qh;\r\nfail1:\r\ndma_pool_free(fotg210->qh_pool, qh->hw, qh->qh_dma);\r\nfail:\r\nkfree(qh);\r\nreturn NULL;\r\n}\r\nstatic void fotg210_mem_cleanup(struct fotg210_hcd *fotg210)\r\n{\r\nif (fotg210->async)\r\nqh_destroy(fotg210, fotg210->async);\r\nfotg210->async = NULL;\r\nif (fotg210->dummy)\r\nqh_destroy(fotg210, fotg210->dummy);\r\nfotg210->dummy = NULL;\r\ndma_pool_destroy(fotg210->qtd_pool);\r\nfotg210->qtd_pool = NULL;\r\ndma_pool_destroy(fotg210->qh_pool);\r\nfotg210->qh_pool = NULL;\r\ndma_pool_destroy(fotg210->itd_pool);\r\nfotg210->itd_pool = NULL;\r\nif (fotg210->periodic)\r\ndma_free_coherent(fotg210_to_hcd(fotg210)->self.controller,\r\nfotg210->periodic_size * sizeof(u32),\r\nfotg210->periodic, fotg210->periodic_dma);\r\nfotg210->periodic = NULL;\r\nkfree(fotg210->pshadow);\r\nfotg210->pshadow = NULL;\r\n}\r\nstatic int fotg210_mem_init(struct fotg210_hcd *fotg210, gfp_t flags)\r\n{\r\nint i;\r\nfotg210->qtd_pool = dma_pool_create("fotg210_qtd",\r\nfotg210_to_hcd(fotg210)->self.controller,\r\nsizeof(struct fotg210_qtd),\r\n32 ,\r\n4096 );\r\nif (!fotg210->qtd_pool)\r\ngoto fail;\r\nfotg210->qh_pool = dma_pool_create("fotg210_qh",\r\nfotg210_to_hcd(fotg210)->self.controller,\r\nsizeof(struct fotg210_qh_hw),\r\n32 ,\r\n4096 );\r\nif (!fotg210->qh_pool)\r\ngoto fail;\r\nfotg210->async = fotg210_qh_alloc(fotg210, flags);\r\nif (!fotg210->async)\r\ngoto fail;\r\nfotg210->itd_pool = dma_pool_create("fotg210_itd",\r\nfotg210_to_hcd(fotg210)->self.controller,\r\nsizeof(struct fotg210_itd),\r\n64 ,\r\n4096 );\r\nif (!fotg210->itd_pool)\r\ngoto fail;\r\nfotg210->periodic = (__le32 *)\r\ndma_alloc_coherent(fotg210_to_hcd(fotg210)->self.controller,\r\nfotg210->periodic_size * sizeof(__le32),\r\n&fotg210->periodic_dma, 0);\r\nif (fotg210->periodic == NULL)\r\ngoto fail;\r\nfor (i = 0; i < fotg210->periodic_size; i++)\r\nfotg210->periodic[i] = FOTG210_LIST_END(fotg210);\r\nfotg210->pshadow = kcalloc(fotg210->periodic_size, sizeof(void *),\r\nflags);\r\nif (fotg210->pshadow != NULL)\r\nreturn 0;\r\nfail:\r\nfotg210_dbg(fotg210, "couldn't init memory\n");\r\nfotg210_mem_cleanup(fotg210);\r\nreturn -ENOMEM;\r\n}\r\nstatic int qtd_fill(struct fotg210_hcd *fotg210, struct fotg210_qtd *qtd,\r\ndma_addr_t buf, size_t len, int token, int maxpacket)\r\n{\r\nint i, count;\r\nu64 addr = buf;\r\nqtd->hw_buf[0] = cpu_to_hc32(fotg210, (u32)addr);\r\nqtd->hw_buf_hi[0] = cpu_to_hc32(fotg210, (u32)(addr >> 32));\r\ncount = 0x1000 - (buf & 0x0fff);\r\nif (likely(len < count))\r\ncount = len;\r\nelse {\r\nbuf += 0x1000;\r\nbuf &= ~0x0fff;\r\nfor (i = 1; count < len && i < 5; i++) {\r\naddr = buf;\r\nqtd->hw_buf[i] = cpu_to_hc32(fotg210, (u32)addr);\r\nqtd->hw_buf_hi[i] = cpu_to_hc32(fotg210,\r\n(u32)(addr >> 32));\r\nbuf += 0x1000;\r\nif ((count + 0x1000) < len)\r\ncount += 0x1000;\r\nelse\r\ncount = len;\r\n}\r\nif (count != len)\r\ncount -= (count % maxpacket);\r\n}\r\nqtd->hw_token = cpu_to_hc32(fotg210, (count << 16) | token);\r\nqtd->length = count;\r\nreturn count;\r\n}\r\nstatic inline void qh_update(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qh *qh, struct fotg210_qtd *qtd)\r\n{\r\nstruct fotg210_qh_hw *hw = qh->hw;\r\nBUG_ON(qh->qh_state != QH_STATE_IDLE);\r\nhw->hw_qtd_next = QTD_NEXT(fotg210, qtd->qtd_dma);\r\nhw->hw_alt_next = FOTG210_LIST_END(fotg210);\r\nif (!(hw->hw_info1 & cpu_to_hc32(fotg210, QH_TOGGLE_CTL))) {\r\nunsigned is_out, epnum;\r\nis_out = qh->is_out;\r\nepnum = (hc32_to_cpup(fotg210, &hw->hw_info1) >> 8) & 0x0f;\r\nif (unlikely(!usb_gettoggle(qh->dev, epnum, is_out))) {\r\nhw->hw_token &= ~cpu_to_hc32(fotg210, QTD_TOGGLE);\r\nusb_settoggle(qh->dev, epnum, is_out, 1);\r\n}\r\n}\r\nhw->hw_token &= cpu_to_hc32(fotg210, QTD_TOGGLE | QTD_STS_PING);\r\n}\r\nstatic void qh_refresh(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\r\n{\r\nstruct fotg210_qtd *qtd;\r\nif (list_empty(&qh->qtd_list))\r\nqtd = qh->dummy;\r\nelse {\r\nqtd = list_entry(qh->qtd_list.next,\r\nstruct fotg210_qtd, qtd_list);\r\nif (cpu_to_hc32(fotg210, qtd->qtd_dma) == qh->hw->hw_current) {\r\nqh->hw->hw_qtd_next = qtd->hw_next;\r\nqtd = NULL;\r\n}\r\n}\r\nif (qtd)\r\nqh_update(fotg210, qh, qtd);\r\n}\r\nstatic void fotg210_clear_tt_buffer_complete(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nstruct fotg210_qh *qh = ep->hcpriv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nqh->clearing_tt = 0;\r\nif (qh->qh_state == QH_STATE_IDLE && !list_empty(&qh->qtd_list)\r\n&& fotg210->rh_state == FOTG210_RH_RUNNING)\r\nqh_link_async(fotg210, qh);\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\n}\r\nstatic void fotg210_clear_tt_buffer(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qh *qh, struct urb *urb, u32 token)\r\n{\r\nif (urb->dev->tt && !usb_pipeint(urb->pipe) && !qh->clearing_tt) {\r\nstruct usb_device *tt = urb->dev->tt->hub;\r\ndev_dbg(&tt->dev,\r\n"clear tt buffer port %d, a%d ep%d t%08x\n",\r\nurb->dev->ttport, urb->dev->devnum,\r\nusb_pipeendpoint(urb->pipe), token);\r\nif (urb->dev->tt->hub !=\r\nfotg210_to_hcd(fotg210)->self.root_hub) {\r\nif (usb_hub_clear_tt_buffer(urb) == 0)\r\nqh->clearing_tt = 1;\r\n}\r\n}\r\n}\r\nstatic int qtd_copy_status(struct fotg210_hcd *fotg210, struct urb *urb,\r\nsize_t length, u32 token)\r\n{\r\nint status = -EINPROGRESS;\r\nif (likely(QTD_PID(token) != 2))\r\nurb->actual_length += length - QTD_LENGTH(token);\r\nif (unlikely(urb->unlinked))\r\nreturn status;\r\nif (unlikely(IS_SHORT_READ(token)))\r\nstatus = -EREMOTEIO;\r\nif (token & QTD_STS_HALT) {\r\nif (token & QTD_STS_BABBLE) {\r\nstatus = -EOVERFLOW;\r\n} else if (QTD_CERR(token)) {\r\nstatus = -EPIPE;\r\n} else if (token & QTD_STS_MMF) {\r\nstatus = -EPROTO;\r\n} else if (token & QTD_STS_DBE) {\r\nstatus = (QTD_PID(token) == 1)\r\n? -ENOSR\r\n: -ECOMM;\r\n} else if (token & QTD_STS_XACT) {\r\nfotg210_dbg(fotg210, "devpath %s ep%d%s 3strikes\n",\r\nurb->dev->devpath,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nstatus = -EPROTO;\r\n} else {\r\nstatus = -EPROTO;\r\n}\r\nfotg210_dbg(fotg210,\r\n"dev%d ep%d%s qtd token %08x --> status %d\n",\r\nusb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\ntoken, status);\r\n}\r\nreturn status;\r\n}\r\nstatic void fotg210_urb_done(struct fotg210_hcd *fotg210, struct urb *urb,\r\nint status)\r\n__releases(fotg210->lock)\r\n__acquires(fotg210->lock)\r\n{\r\nif (likely(urb->hcpriv != NULL)) {\r\nstruct fotg210_qh *qh = (struct fotg210_qh *) urb->hcpriv;\r\nif ((qh->hw->hw_info2 & cpu_to_hc32(fotg210, QH_SMASK)) != 0) {\r\nfotg210_to_hcd(fotg210)->self.bandwidth_int_reqs--;\r\n}\r\n}\r\nif (unlikely(urb->unlinked)) {\r\nCOUNT(fotg210->stats.unlink);\r\n} else {\r\nif (status == -EINPROGRESS || status == -EREMOTEIO)\r\nstatus = 0;\r\nCOUNT(fotg210->stats.complete);\r\n}\r\n#ifdef FOTG210_URB_TRACE\r\nfotg210_dbg(fotg210,\r\n"%s %s urb %p ep%d%s status %d len %d/%d\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\nstatus,\r\nurb->actual_length, urb->transfer_buffer_length);\r\n#endif\r\nusb_hcd_unlink_urb_from_ep(fotg210_to_hcd(fotg210), urb);\r\nspin_unlock(&fotg210->lock);\r\nusb_hcd_giveback_urb(fotg210_to_hcd(fotg210), urb, status);\r\nspin_lock(&fotg210->lock);\r\n}\r\nstatic unsigned qh_completions(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qh *qh)\r\n{\r\nstruct fotg210_qtd *last, *end = qh->dummy;\r\nstruct fotg210_qtd *qtd, *tmp;\r\nint last_status;\r\nint stopped;\r\nunsigned count = 0;\r\nu8 state;\r\nstruct fotg210_qh_hw *hw = qh->hw;\r\nif (unlikely(list_empty(&qh->qtd_list)))\r\nreturn count;\r\nstate = qh->qh_state;\r\nqh->qh_state = QH_STATE_COMPLETING;\r\nstopped = (state == QH_STATE_IDLE);\r\nrescan:\r\nlast = NULL;\r\nlast_status = -EINPROGRESS;\r\nqh->needs_rescan = 0;\r\nlist_for_each_entry_safe(qtd, tmp, &qh->qtd_list, qtd_list) {\r\nstruct urb *urb;\r\nu32 token = 0;\r\nurb = qtd->urb;\r\nif (last) {\r\nif (likely(last->urb != urb)) {\r\nfotg210_urb_done(fotg210, last->urb,\r\nlast_status);\r\ncount++;\r\nlast_status = -EINPROGRESS;\r\n}\r\nfotg210_qtd_free(fotg210, last);\r\nlast = NULL;\r\n}\r\nif (qtd == end)\r\nbreak;\r\nrmb();\r\ntoken = hc32_to_cpu(fotg210, qtd->hw_token);\r\nretry_xacterr:\r\nif ((token & QTD_STS_ACTIVE) == 0) {\r\nif (token & QTD_STS_DBE)\r\nfotg210_dbg(fotg210,\r\n"detected DataBufferErr for urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\nurb, usb_endpoint_num(&urb->ep->desc),\r\nusb_endpoint_dir_in(&urb->ep->desc)\r\n? "in" : "out",\r\nurb->transfer_buffer_length, qtd, qh);\r\nif ((token & QTD_STS_HALT) != 0) {\r\nif ((token & QTD_STS_XACT) &&\r\nQTD_CERR(token) == 0 &&\r\n++qh->xacterrs < QH_XACTERR_MAX &&\r\n!urb->unlinked) {\r\nfotg210_dbg(fotg210,\r\n"detected XactErr len %zu/%zu retry %d\n",\r\nqtd->length - QTD_LENGTH(token),\r\nqtd->length,\r\nqh->xacterrs);\r\ntoken &= ~QTD_STS_HALT;\r\ntoken |= QTD_STS_ACTIVE |\r\n(FOTG210_TUNE_CERR << 10);\r\nqtd->hw_token = cpu_to_hc32(fotg210,\r\ntoken);\r\nwmb();\r\nhw->hw_token = cpu_to_hc32(fotg210,\r\ntoken);\r\ngoto retry_xacterr;\r\n}\r\nstopped = 1;\r\n} else if (IS_SHORT_READ(token) &&\r\n!(qtd->hw_alt_next &\r\nFOTG210_LIST_END(fotg210))) {\r\nstopped = 1;\r\n}\r\n} else if (likely(!stopped\r\n&& fotg210->rh_state >= FOTG210_RH_RUNNING)) {\r\nbreak;\r\n} else {\r\nstopped = 1;\r\nif (fotg210->rh_state < FOTG210_RH_RUNNING)\r\nlast_status = -ESHUTDOWN;\r\nelse if (last_status == -EINPROGRESS && !urb->unlinked)\r\ncontinue;\r\nif (state == QH_STATE_IDLE &&\r\ncpu_to_hc32(fotg210, qtd->qtd_dma)\r\n== hw->hw_current) {\r\ntoken = hc32_to_cpu(fotg210, hw->hw_token);\r\nfotg210_clear_tt_buffer(fotg210, qh, urb,\r\ntoken);\r\n}\r\n}\r\nif (last_status == -EINPROGRESS) {\r\nlast_status = qtd_copy_status(fotg210, urb,\r\nqtd->length, token);\r\nif (last_status == -EREMOTEIO &&\r\n(qtd->hw_alt_next &\r\nFOTG210_LIST_END(fotg210)))\r\nlast_status = -EINPROGRESS;\r\nif (unlikely(last_status != -EINPROGRESS &&\r\nlast_status != -EREMOTEIO)) {\r\nif (last_status != -EPIPE)\r\nfotg210_clear_tt_buffer(fotg210, qh,\r\nurb, token);\r\n}\r\n}\r\nif (stopped && qtd->qtd_list.prev != &qh->qtd_list) {\r\nlast = list_entry(qtd->qtd_list.prev,\r\nstruct fotg210_qtd, qtd_list);\r\nlast->hw_next = qtd->hw_next;\r\n}\r\nlist_del(&qtd->qtd_list);\r\nlast = qtd;\r\nqh->xacterrs = 0;\r\n}\r\nif (likely(last != NULL)) {\r\nfotg210_urb_done(fotg210, last->urb, last_status);\r\ncount++;\r\nfotg210_qtd_free(fotg210, last);\r\n}\r\nif (unlikely(qh->needs_rescan)) {\r\nif (state == QH_STATE_IDLE)\r\ngoto rescan;\r\nif (state != QH_STATE_LINKED)\r\nqh->needs_rescan = 0;\r\n}\r\nqh->qh_state = state;\r\nif (stopped != 0 || hw->hw_qtd_next == FOTG210_LIST_END(fotg210)) {\r\nswitch (state) {\r\ncase QH_STATE_IDLE:\r\nqh_refresh(fotg210, qh);\r\nbreak;\r\ncase QH_STATE_LINKED:\r\nqh->needs_rescan = 1;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void qtd_list_free(struct fotg210_hcd *fotg210, struct urb *urb,\r\nstruct list_head *head)\r\n{\r\nstruct fotg210_qtd *qtd, *temp;\r\nlist_for_each_entry_safe(qtd, temp, head, qtd_list) {\r\nlist_del(&qtd->qtd_list);\r\nfotg210_qtd_free(fotg210, qtd);\r\n}\r\n}\r\nstatic struct list_head *qh_urb_transaction(struct fotg210_hcd *fotg210,\r\nstruct urb *urb, struct list_head *head, gfp_t flags)\r\n{\r\nstruct fotg210_qtd *qtd, *qtd_prev;\r\ndma_addr_t buf;\r\nint len, this_sg_len, maxpacket;\r\nint is_input;\r\nu32 token;\r\nint i;\r\nstruct scatterlist *sg;\r\nqtd = fotg210_qtd_alloc(fotg210, flags);\r\nif (unlikely(!qtd))\r\nreturn NULL;\r\nlist_add_tail(&qtd->qtd_list, head);\r\nqtd->urb = urb;\r\ntoken = QTD_STS_ACTIVE;\r\ntoken |= (FOTG210_TUNE_CERR << 10);\r\nlen = urb->transfer_buffer_length;\r\nis_input = usb_pipein(urb->pipe);\r\nif (usb_pipecontrol(urb->pipe)) {\r\nqtd_fill(fotg210, qtd, urb->setup_dma,\r\nsizeof(struct usb_ctrlrequest),\r\ntoken | (2 << 8), 8);\r\ntoken ^= QTD_TOGGLE;\r\nqtd_prev = qtd;\r\nqtd = fotg210_qtd_alloc(fotg210, flags);\r\nif (unlikely(!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(fotg210, qtd->qtd_dma);\r\nlist_add_tail(&qtd->qtd_list, head);\r\nif (len == 0)\r\ntoken |= (1 << 8);\r\n}\r\ni = urb->num_mapped_sgs;\r\nif (len > 0 && i > 0) {\r\nsg = urb->sg;\r\nbuf = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n} else {\r\nsg = NULL;\r\nbuf = urb->transfer_dma;\r\nthis_sg_len = len;\r\n}\r\nif (is_input)\r\ntoken |= (1 << 8);\r\nmaxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));\r\nfor (;;) {\r\nint this_qtd_len;\r\nthis_qtd_len = qtd_fill(fotg210, qtd, buf, this_sg_len, token,\r\nmaxpacket);\r\nthis_sg_len -= this_qtd_len;\r\nlen -= this_qtd_len;\r\nbuf += this_qtd_len;\r\nif (is_input)\r\nqtd->hw_alt_next = fotg210->async->hw->hw_alt_next;\r\nif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\r\ntoken ^= QTD_TOGGLE;\r\nif (likely(this_sg_len <= 0)) {\r\nif (--i <= 0 || len <= 0)\r\nbreak;\r\nsg = sg_next(sg);\r\nbuf = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n}\r\nqtd_prev = qtd;\r\nqtd = fotg210_qtd_alloc(fotg210, flags);\r\nif (unlikely(!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(fotg210, qtd->qtd_dma);\r\nlist_add_tail(&qtd->qtd_list, head);\r\n}\r\nif (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0 ||\r\nusb_pipecontrol(urb->pipe)))\r\nqtd->hw_alt_next = FOTG210_LIST_END(fotg210);\r\nif (likely(urb->transfer_buffer_length != 0)) {\r\nint one_more = 0;\r\nif (usb_pipecontrol(urb->pipe)) {\r\none_more = 1;\r\ntoken ^= 0x0100;\r\ntoken |= QTD_TOGGLE;\r\n} else if (usb_pipeout(urb->pipe)\r\n&& (urb->transfer_flags & URB_ZERO_PACKET)\r\n&& !(urb->transfer_buffer_length % maxpacket)) {\r\none_more = 1;\r\n}\r\nif (one_more) {\r\nqtd_prev = qtd;\r\nqtd = fotg210_qtd_alloc(fotg210, flags);\r\nif (unlikely(!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(fotg210, qtd->qtd_dma);\r\nlist_add_tail(&qtd->qtd_list, head);\r\nqtd_fill(fotg210, qtd, 0, 0, token, 0);\r\n}\r\n}\r\nif (likely(!(urb->transfer_flags & URB_NO_INTERRUPT)))\r\nqtd->hw_token |= cpu_to_hc32(fotg210, QTD_IOC);\r\nreturn head;\r\ncleanup:\r\nqtd_list_free(fotg210, urb, head);\r\nreturn NULL;\r\n}\r\nstatic struct fotg210_qh *qh_make(struct fotg210_hcd *fotg210, struct urb *urb,\r\ngfp_t flags)\r\n{\r\nstruct fotg210_qh *qh = fotg210_qh_alloc(fotg210, flags);\r\nu32 info1 = 0, info2 = 0;\r\nint is_input, type;\r\nint maxp = 0;\r\nstruct usb_tt *tt = urb->dev->tt;\r\nstruct fotg210_qh_hw *hw;\r\nif (!qh)\r\nreturn qh;\r\ninfo1 |= usb_pipeendpoint(urb->pipe) << 8;\r\ninfo1 |= usb_pipedevice(urb->pipe) << 0;\r\nis_input = usb_pipein(urb->pipe);\r\ntype = usb_pipetype(urb->pipe);\r\nmaxp = usb_maxpacket(urb->dev, urb->pipe, !is_input);\r\nif (max_packet(maxp) > 1024) {\r\nfotg210_dbg(fotg210, "bogus qh maxpacket %d\n",\r\nmax_packet(maxp));\r\ngoto done;\r\n}\r\nif (type == PIPE_INTERRUPT) {\r\nqh->usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,\r\nis_input, 0,\r\nhb_mult(maxp) * max_packet(maxp)));\r\nqh->start = NO_FRAME;\r\nif (urb->dev->speed == USB_SPEED_HIGH) {\r\nqh->c_usecs = 0;\r\nqh->gap_uf = 0;\r\nqh->period = urb->interval >> 3;\r\nif (qh->period == 0 && urb->interval != 1) {\r\nurb->interval = 1;\r\n} else if (qh->period > fotg210->periodic_size) {\r\nqh->period = fotg210->periodic_size;\r\nurb->interval = qh->period << 3;\r\n}\r\n} else {\r\nint think_time;\r\nqh->gap_uf = 1 + usb_calc_bus_time(urb->dev->speed,\r\nis_input, 0, maxp) / (125 * 1000);\r\nif (is_input) {\r\nqh->c_usecs = qh->usecs + HS_USECS(0);\r\nqh->usecs = HS_USECS(1);\r\n} else {\r\nqh->usecs += HS_USECS(1);\r\nqh->c_usecs = HS_USECS(0);\r\n}\r\nthink_time = tt ? tt->think_time : 0;\r\nqh->tt_usecs = NS_TO_US(think_time +\r\nusb_calc_bus_time(urb->dev->speed,\r\nis_input, 0, max_packet(maxp)));\r\nqh->period = urb->interval;\r\nif (qh->period > fotg210->periodic_size) {\r\nqh->period = fotg210->periodic_size;\r\nurb->interval = qh->period;\r\n}\r\n}\r\n}\r\nqh->dev = urb->dev;\r\nswitch (urb->dev->speed) {\r\ncase USB_SPEED_LOW:\r\ninfo1 |= QH_LOW_SPEED;\r\ncase USB_SPEED_FULL:\r\nif (type != PIPE_INTERRUPT)\r\ninfo1 |= (FOTG210_TUNE_RL_TT << 28);\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= QH_CONTROL_EP;\r\ninfo1 |= QH_TOGGLE_CTL;\r\n}\r\ninfo1 |= maxp << 16;\r\ninfo2 |= (FOTG210_TUNE_MULT_TT << 30);\r\nif (fotg210_has_fsl_portno_bug(fotg210))\r\ninfo2 |= (urb->dev->ttport-1) << 23;\r\nelse\r\ninfo2 |= urb->dev->ttport << 23;\r\nif (tt && tt->hub != fotg210_to_hcd(fotg210)->self.root_hub)\r\ninfo2 |= tt->hub->devnum << 16;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ninfo1 |= QH_HIGH_SPEED;\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= (FOTG210_TUNE_RL_HS << 28);\r\ninfo1 |= 64 << 16;\r\ninfo1 |= QH_TOGGLE_CTL;\r\ninfo2 |= (FOTG210_TUNE_MULT_HS << 30);\r\n} else if (type == PIPE_BULK) {\r\ninfo1 |= (FOTG210_TUNE_RL_HS << 28);\r\ninfo1 |= max_packet(maxp) << 16;\r\ninfo2 |= (FOTG210_TUNE_MULT_HS << 30);\r\n} else {\r\ninfo1 |= max_packet(maxp) << 16;\r\ninfo2 |= hb_mult(maxp) << 30;\r\n}\r\nbreak;\r\ndefault:\r\nfotg210_dbg(fotg210, "bogus dev %p speed %d\n", urb->dev,\r\nurb->dev->speed);\r\ndone:\r\nqh_destroy(fotg210, qh);\r\nreturn NULL;\r\n}\r\nqh->qh_state = QH_STATE_IDLE;\r\nhw = qh->hw;\r\nhw->hw_info1 = cpu_to_hc32(fotg210, info1);\r\nhw->hw_info2 = cpu_to_hc32(fotg210, info2);\r\nqh->is_out = !is_input;\r\nusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), !is_input, 1);\r\nqh_refresh(fotg210, qh);\r\nreturn qh;\r\n}\r\nstatic void enable_async(struct fotg210_hcd *fotg210)\r\n{\r\nif (fotg210->async_count++)\r\nreturn;\r\nfotg210->enabled_hrtimer_events &= ~BIT(FOTG210_HRTIMER_DISABLE_ASYNC);\r\nfotg210_poll_ASS(fotg210);\r\nturn_on_io_watchdog(fotg210);\r\n}\r\nstatic void disable_async(struct fotg210_hcd *fotg210)\r\n{\r\nif (--fotg210->async_count)\r\nreturn;\r\nWARN_ON(fotg210->async->qh_next.qh || fotg210->async_unlink);\r\nfotg210_poll_ASS(fotg210);\r\n}\r\nstatic void qh_link_async(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\r\n{\r\n__hc32 dma = QH_NEXT(fotg210, qh->qh_dma);\r\nstruct fotg210_qh *head;\r\nif (unlikely(qh->clearing_tt))\r\nreturn;\r\nWARN_ON(qh->qh_state != QH_STATE_IDLE);\r\nqh_refresh(fotg210, qh);\r\nhead = fotg210->async;\r\nqh->qh_next = head->qh_next;\r\nqh->hw->hw_next = head->hw->hw_next;\r\nwmb();\r\nhead->qh_next.qh = qh;\r\nhead->hw->hw_next = dma;\r\nqh->xacterrs = 0;\r\nqh->qh_state = QH_STATE_LINKED;\r\nenable_async(fotg210);\r\n}\r\nstatic struct fotg210_qh *qh_append_tds(struct fotg210_hcd *fotg210,\r\nstruct urb *urb, struct list_head *qtd_list,\r\nint epnum, void **ptr)\r\n{\r\nstruct fotg210_qh *qh = NULL;\r\n__hc32 qh_addr_mask = cpu_to_hc32(fotg210, 0x7f);\r\nqh = (struct fotg210_qh *) *ptr;\r\nif (unlikely(qh == NULL)) {\r\nqh = qh_make(fotg210, urb, GFP_ATOMIC);\r\n*ptr = qh;\r\n}\r\nif (likely(qh != NULL)) {\r\nstruct fotg210_qtd *qtd;\r\nif (unlikely(list_empty(qtd_list)))\r\nqtd = NULL;\r\nelse\r\nqtd = list_entry(qtd_list->next, struct fotg210_qtd,\r\nqtd_list);\r\nif (unlikely(epnum == 0)) {\r\nif (usb_pipedevice(urb->pipe) == 0)\r\nqh->hw->hw_info1 &= ~qh_addr_mask;\r\n}\r\nif (likely(qtd != NULL)) {\r\nstruct fotg210_qtd *dummy;\r\ndma_addr_t dma;\r\n__hc32 token;\r\ntoken = qtd->hw_token;\r\nqtd->hw_token = HALT_BIT(fotg210);\r\ndummy = qh->dummy;\r\ndma = dummy->qtd_dma;\r\n*dummy = *qtd;\r\ndummy->qtd_dma = dma;\r\nlist_del(&qtd->qtd_list);\r\nlist_add(&dummy->qtd_list, qtd_list);\r\nlist_splice_tail(qtd_list, &qh->qtd_list);\r\nfotg210_qtd_init(fotg210, qtd, qtd->qtd_dma);\r\nqh->dummy = qtd;\r\ndma = qtd->qtd_dma;\r\nqtd = list_entry(qh->qtd_list.prev,\r\nstruct fotg210_qtd, qtd_list);\r\nqtd->hw_next = QTD_NEXT(fotg210, dma);\r\nwmb();\r\ndummy->hw_token = token;\r\nurb->hcpriv = qh;\r\n}\r\n}\r\nreturn qh;\r\n}\r\nstatic int submit_async(struct fotg210_hcd *fotg210, struct urb *urb,\r\nstruct list_head *qtd_list, gfp_t mem_flags)\r\n{\r\nint epnum;\r\nunsigned long flags;\r\nstruct fotg210_qh *qh = NULL;\r\nint rc;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\n#ifdef FOTG210_URB_TRACE\r\n{\r\nstruct fotg210_qtd *qtd;\r\nqtd = list_entry(qtd_list->next, struct fotg210_qtd, qtd_list);\r\nfotg210_dbg(fotg210,\r\n"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nepnum & 0x0f, (epnum & USB_DIR_IN)\r\n? "in" : "out",\r\nurb->transfer_buffer_length,\r\nqtd, urb->ep->hcpriv);\r\n}\r\n#endif\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(fotg210_to_hcd(fotg210)))) {\r\nrc = -ESHUTDOWN;\r\ngoto done;\r\n}\r\nrc = usb_hcd_link_urb_to_ep(fotg210_to_hcd(fotg210), urb);\r\nif (unlikely(rc))\r\ngoto done;\r\nqh = qh_append_tds(fotg210, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nif (unlikely(qh == NULL)) {\r\nusb_hcd_unlink_urb_from_ep(fotg210_to_hcd(fotg210), urb);\r\nrc = -ENOMEM;\r\ngoto done;\r\n}\r\nif (likely(qh->qh_state == QH_STATE_IDLE))\r\nqh_link_async(fotg210, qh);\r\ndone:\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nif (unlikely(qh == NULL))\r\nqtd_list_free(fotg210, urb, qtd_list);\r\nreturn rc;\r\n}\r\nstatic void single_unlink_async(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qh *qh)\r\n{\r\nstruct fotg210_qh *prev;\r\nqh->qh_state = QH_STATE_UNLINK;\r\nif (fotg210->async_unlink)\r\nfotg210->async_unlink_last->unlink_next = qh;\r\nelse\r\nfotg210->async_unlink = qh;\r\nfotg210->async_unlink_last = qh;\r\nprev = fotg210->async;\r\nwhile (prev->qh_next.qh != qh)\r\nprev = prev->qh_next.qh;\r\nprev->hw->hw_next = qh->hw->hw_next;\r\nprev->qh_next = qh->qh_next;\r\nif (fotg210->qh_scan_next == qh)\r\nfotg210->qh_scan_next = qh->qh_next.qh;\r\n}\r\nstatic void start_iaa_cycle(struct fotg210_hcd *fotg210, bool nested)\r\n{\r\nif (fotg210->async_iaa || fotg210->async_unlinking)\r\nreturn;\r\nfotg210->async_iaa = fotg210->async_unlink;\r\nfotg210->async_unlink = NULL;\r\nif (unlikely(fotg210->rh_state < FOTG210_RH_RUNNING)) {\r\nif (!nested)\r\nend_unlink_async(fotg210);\r\n} else if (likely(fotg210->rh_state == FOTG210_RH_RUNNING)) {\r\nwmb();\r\nfotg210_writel(fotg210, fotg210->command | CMD_IAAD,\r\n&fotg210->regs->command);\r\nfotg210_readl(fotg210, &fotg210->regs->command);\r\nfotg210_enable_event(fotg210, FOTG210_HRTIMER_IAA_WATCHDOG,\r\ntrue);\r\n}\r\n}\r\nstatic void end_unlink_async(struct fotg210_hcd *fotg210)\r\n{\r\nstruct fotg210_qh *qh;\r\nrestart:\r\nfotg210->async_unlinking = true;\r\nwhile (fotg210->async_iaa) {\r\nqh = fotg210->async_iaa;\r\nfotg210->async_iaa = qh->unlink_next;\r\nqh->unlink_next = NULL;\r\nqh->qh_state = QH_STATE_IDLE;\r\nqh->qh_next.qh = NULL;\r\nqh_completions(fotg210, qh);\r\nif (!list_empty(&qh->qtd_list) &&\r\nfotg210->rh_state == FOTG210_RH_RUNNING)\r\nqh_link_async(fotg210, qh);\r\ndisable_async(fotg210);\r\n}\r\nfotg210->async_unlinking = false;\r\nif (fotg210->async_unlink) {\r\nstart_iaa_cycle(fotg210, true);\r\nif (unlikely(fotg210->rh_state < FOTG210_RH_RUNNING))\r\ngoto restart;\r\n}\r\n}\r\nstatic void unlink_empty_async(struct fotg210_hcd *fotg210)\r\n{\r\nstruct fotg210_qh *qh, *next;\r\nbool stopped = (fotg210->rh_state < FOTG210_RH_RUNNING);\r\nbool check_unlinks_later = false;\r\nnext = fotg210->async->qh_next.qh;\r\nwhile (next) {\r\nqh = next;\r\nnext = qh->qh_next.qh;\r\nif (list_empty(&qh->qtd_list) &&\r\nqh->qh_state == QH_STATE_LINKED) {\r\nif (!stopped && qh->unlink_cycle ==\r\nfotg210->async_unlink_cycle)\r\ncheck_unlinks_later = true;\r\nelse\r\nsingle_unlink_async(fotg210, qh);\r\n}\r\n}\r\nif (fotg210->async_unlink)\r\nstart_iaa_cycle(fotg210, false);\r\nif (check_unlinks_later) {\r\nfotg210_enable_event(fotg210, FOTG210_HRTIMER_ASYNC_UNLINKS,\r\ntrue);\r\n++fotg210->async_unlink_cycle;\r\n}\r\n}\r\nstatic void start_unlink_async(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qh *qh)\r\n{\r\nif (qh->qh_state != QH_STATE_LINKED) {\r\nif (qh->qh_state == QH_STATE_COMPLETING)\r\nqh->needs_rescan = 1;\r\nreturn;\r\n}\r\nsingle_unlink_async(fotg210, qh);\r\nstart_iaa_cycle(fotg210, false);\r\n}\r\nstatic void scan_async(struct fotg210_hcd *fotg210)\r\n{\r\nstruct fotg210_qh *qh;\r\nbool check_unlinks_later = false;\r\nfotg210->qh_scan_next = fotg210->async->qh_next.qh;\r\nwhile (fotg210->qh_scan_next) {\r\nqh = fotg210->qh_scan_next;\r\nfotg210->qh_scan_next = qh->qh_next.qh;\r\nrescan:\r\nif (!list_empty(&qh->qtd_list)) {\r\nint temp;\r\ntemp = qh_completions(fotg210, qh);\r\nif (qh->needs_rescan) {\r\nstart_unlink_async(fotg210, qh);\r\n} else if (list_empty(&qh->qtd_list)\r\n&& qh->qh_state == QH_STATE_LINKED) {\r\nqh->unlink_cycle = fotg210->async_unlink_cycle;\r\ncheck_unlinks_later = true;\r\n} else if (temp != 0)\r\ngoto rescan;\r\n}\r\n}\r\nif (check_unlinks_later && fotg210->rh_state == FOTG210_RH_RUNNING &&\r\n!(fotg210->enabled_hrtimer_events &\r\nBIT(FOTG210_HRTIMER_ASYNC_UNLINKS))) {\r\nfotg210_enable_event(fotg210,\r\nFOTG210_HRTIMER_ASYNC_UNLINKS, true);\r\n++fotg210->async_unlink_cycle;\r\n}\r\n}\r\nstatic union fotg210_shadow *periodic_next_shadow(struct fotg210_hcd *fotg210,\r\nunion fotg210_shadow *periodic, __hc32 tag)\r\n{\r\nswitch (hc32_to_cpu(fotg210, tag)) {\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->qh_next;\r\ncase Q_TYPE_FSTN:\r\nreturn &periodic->fstn->fstn_next;\r\ndefault:\r\nreturn &periodic->itd->itd_next;\r\n}\r\n}\r\nstatic __hc32 *shadow_next_periodic(struct fotg210_hcd *fotg210,\r\nunion fotg210_shadow *periodic, __hc32 tag)\r\n{\r\nswitch (hc32_to_cpu(fotg210, tag)) {\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->hw->hw_next;\r\ndefault:\r\nreturn periodic->hw_next;\r\n}\r\n}\r\nstatic void periodic_unlink(struct fotg210_hcd *fotg210, unsigned frame,\r\nvoid *ptr)\r\n{\r\nunion fotg210_shadow *prev_p = &fotg210->pshadow[frame];\r\n__hc32 *hw_p = &fotg210->periodic[frame];\r\nunion fotg210_shadow here = *prev_p;\r\nwhile (here.ptr && here.ptr != ptr) {\r\nprev_p = periodic_next_shadow(fotg210, prev_p,\r\nQ_NEXT_TYPE(fotg210, *hw_p));\r\nhw_p = shadow_next_periodic(fotg210, &here,\r\nQ_NEXT_TYPE(fotg210, *hw_p));\r\nhere = *prev_p;\r\n}\r\nif (!here.ptr)\r\nreturn;\r\n*prev_p = *periodic_next_shadow(fotg210, &here,\r\nQ_NEXT_TYPE(fotg210, *hw_p));\r\n*hw_p = *shadow_next_periodic(fotg210, &here,\r\nQ_NEXT_TYPE(fotg210, *hw_p));\r\n}\r\nstatic unsigned short periodic_usecs(struct fotg210_hcd *fotg210,\r\nunsigned frame, unsigned uframe)\r\n{\r\n__hc32 *hw_p = &fotg210->periodic[frame];\r\nunion fotg210_shadow *q = &fotg210->pshadow[frame];\r\nunsigned usecs = 0;\r\nstruct fotg210_qh_hw *hw;\r\nwhile (q->ptr) {\r\nswitch (hc32_to_cpu(fotg210, Q_NEXT_TYPE(fotg210, *hw_p))) {\r\ncase Q_TYPE_QH:\r\nhw = q->qh->hw;\r\nif (hw->hw_info2 & cpu_to_hc32(fotg210, 1 << uframe))\r\nusecs += q->qh->usecs;\r\nif (hw->hw_info2 & cpu_to_hc32(fotg210,\r\n1 << (8 + uframe)))\r\nusecs += q->qh->c_usecs;\r\nhw_p = &hw->hw_next;\r\nq = &q->qh->qh_next;\r\nbreak;\r\ndefault:\r\nif (q->fstn->hw_prev != FOTG210_LIST_END(fotg210))\r\nfotg210_dbg(fotg210, "ignoring FSTN cost ...\n");\r\nhw_p = &q->fstn->hw_next;\r\nq = &q->fstn->fstn_next;\r\nbreak;\r\ncase Q_TYPE_ITD:\r\nif (q->itd->hw_transaction[uframe])\r\nusecs += q->itd->stream->usecs;\r\nhw_p = &q->itd->hw_next;\r\nq = &q->itd->itd_next;\r\nbreak;\r\n}\r\n}\r\nif (usecs > fotg210->uframe_periodic_max)\r\nfotg210_err(fotg210, "uframe %d sched overrun: %d usecs\n",\r\nframe * 8 + uframe, usecs);\r\nreturn usecs;\r\n}\r\nstatic int same_tt(struct usb_device *dev1, struct usb_device *dev2)\r\n{\r\nif (!dev1->tt || !dev2->tt)\r\nreturn 0;\r\nif (dev1->tt != dev2->tt)\r\nreturn 0;\r\nif (dev1->tt->multi)\r\nreturn dev1->ttport == dev2->ttport;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int tt_no_collision(struct fotg210_hcd *fotg210, unsigned period,\r\nstruct usb_device *dev, unsigned frame, u32 uf_mask)\r\n{\r\nif (period == 0)\r\nreturn 0;\r\nfor (; frame < fotg210->periodic_size; frame += period) {\r\nunion fotg210_shadow here;\r\n__hc32 type;\r\nstruct fotg210_qh_hw *hw;\r\nhere = fotg210->pshadow[frame];\r\ntype = Q_NEXT_TYPE(fotg210, fotg210->periodic[frame]);\r\nwhile (here.ptr) {\r\nswitch (hc32_to_cpu(fotg210, type)) {\r\ncase Q_TYPE_ITD:\r\ntype = Q_NEXT_TYPE(fotg210, here.itd->hw_next);\r\nhere = here.itd->itd_next;\r\ncontinue;\r\ncase Q_TYPE_QH:\r\nhw = here.qh->hw;\r\nif (same_tt(dev, here.qh->dev)) {\r\nu32 mask;\r\nmask = hc32_to_cpu(fotg210,\r\nhw->hw_info2);\r\nmask |= mask >> 8;\r\nif (mask & uf_mask)\r\nbreak;\r\n}\r\ntype = Q_NEXT_TYPE(fotg210, hw->hw_next);\r\nhere = here.qh->qh_next;\r\ncontinue;\r\ndefault:\r\nfotg210_dbg(fotg210,\r\n"periodic frame %d bogus type %d\n",\r\nframe, type);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void enable_periodic(struct fotg210_hcd *fotg210)\r\n{\r\nif (fotg210->periodic_count++)\r\nreturn;\r\nfotg210->enabled_hrtimer_events &=\r\n~BIT(FOTG210_HRTIMER_DISABLE_PERIODIC);\r\nfotg210_poll_PSS(fotg210);\r\nturn_on_io_watchdog(fotg210);\r\n}\r\nstatic void disable_periodic(struct fotg210_hcd *fotg210)\r\n{\r\nif (--fotg210->periodic_count)\r\nreturn;\r\nfotg210_poll_PSS(fotg210);\r\n}\r\nstatic void qh_link_periodic(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period = qh->period;\r\ndev_dbg(&qh->dev->dev,\r\n"link qh%d-%04x/%p start %d [%d/%d us]\n", period,\r\nhc32_to_cpup(fotg210, &qh->hw->hw_info2) &\r\n(QH_CMASK | QH_SMASK), qh, qh->start, qh->usecs,\r\nqh->c_usecs);\r\nif (period == 0)\r\nperiod = 1;\r\nfor (i = qh->start; i < fotg210->periodic_size; i += period) {\r\nunion fotg210_shadow *prev = &fotg210->pshadow[i];\r\n__hc32 *hw_p = &fotg210->periodic[i];\r\nunion fotg210_shadow here = *prev;\r\n__hc32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(fotg210, *hw_p);\r\nif (type == cpu_to_hc32(fotg210, Q_TYPE_QH))\r\nbreak;\r\nprev = periodic_next_shadow(fotg210, prev, type);\r\nhw_p = shadow_next_periodic(fotg210, &here, type);\r\nhere = *prev;\r\n}\r\nwhile (here.ptr && qh != here.qh) {\r\nif (qh->period > here.qh->period)\r\nbreak;\r\nprev = &here.qh->qh_next;\r\nhw_p = &here.qh->hw->hw_next;\r\nhere = *prev;\r\n}\r\nif (qh != here.qh) {\r\nqh->qh_next = here;\r\nif (here.qh)\r\nqh->hw->hw_next = *hw_p;\r\nwmb();\r\nprev->qh = qh;\r\n*hw_p = QH_NEXT(fotg210, qh->qh_dma);\r\n}\r\n}\r\nqh->qh_state = QH_STATE_LINKED;\r\nqh->xacterrs = 0;\r\nfotg210_to_hcd(fotg210)->self.bandwidth_allocated += qh->period\r\n? ((qh->usecs + qh->c_usecs) / qh->period)\r\n: (qh->usecs * 8);\r\nlist_add(&qh->intr_node, &fotg210->intr_qh_list);\r\n++fotg210->intr_count;\r\nenable_periodic(fotg210);\r\n}\r\nstatic void qh_unlink_periodic(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period;\r\nperiod = qh->period;\r\nif (!period)\r\nperiod = 1;\r\nfor (i = qh->start; i < fotg210->periodic_size; i += period)\r\nperiodic_unlink(fotg210, i, qh);\r\nfotg210_to_hcd(fotg210)->self.bandwidth_allocated -= qh->period\r\n? ((qh->usecs + qh->c_usecs) / qh->period)\r\n: (qh->usecs * 8);\r\ndev_dbg(&qh->dev->dev,\r\n"unlink qh%d-%04x/%p start %d [%d/%d us]\n",\r\nqh->period, hc32_to_cpup(fotg210, &qh->hw->hw_info2) &\r\n(QH_CMASK | QH_SMASK), qh, qh->start, qh->usecs,\r\nqh->c_usecs);\r\nqh->qh_state = QH_STATE_UNLINK;\r\nqh->qh_next.ptr = NULL;\r\nif (fotg210->qh_scan_next == qh)\r\nfotg210->qh_scan_next = list_entry(qh->intr_node.next,\r\nstruct fotg210_qh, intr_node);\r\nlist_del(&qh->intr_node);\r\n}\r\nstatic void start_unlink_intr(struct fotg210_hcd *fotg210,\r\nstruct fotg210_qh *qh)\r\n{\r\nif (qh->qh_state != QH_STATE_LINKED) {\r\nif (qh->qh_state == QH_STATE_COMPLETING)\r\nqh->needs_rescan = 1;\r\nreturn;\r\n}\r\nqh_unlink_periodic(fotg210, qh);\r\nwmb();\r\nqh->unlink_cycle = fotg210->intr_unlink_cycle;\r\nif (fotg210->intr_unlink)\r\nfotg210->intr_unlink_last->unlink_next = qh;\r\nelse\r\nfotg210->intr_unlink = qh;\r\nfotg210->intr_unlink_last = qh;\r\nif (fotg210->intr_unlinking)\r\n;\r\nelse if (fotg210->rh_state < FOTG210_RH_RUNNING)\r\nfotg210_handle_intr_unlinks(fotg210);\r\nelse if (fotg210->intr_unlink == qh) {\r\nfotg210_enable_event(fotg210, FOTG210_HRTIMER_UNLINK_INTR,\r\ntrue);\r\n++fotg210->intr_unlink_cycle;\r\n}\r\n}\r\nstatic void end_unlink_intr(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\r\n{\r\nstruct fotg210_qh_hw *hw = qh->hw;\r\nint rc;\r\nqh->qh_state = QH_STATE_IDLE;\r\nhw->hw_next = FOTG210_LIST_END(fotg210);\r\nqh_completions(fotg210, qh);\r\nif (!list_empty(&qh->qtd_list) &&\r\nfotg210->rh_state == FOTG210_RH_RUNNING) {\r\nrc = qh_schedule(fotg210, qh);\r\nif (rc != 0)\r\nfotg210_err(fotg210, "can't reschedule qh %p, err %d\n",\r\nqh, rc);\r\n}\r\n--fotg210->intr_count;\r\ndisable_periodic(fotg210);\r\n}\r\nstatic int check_period(struct fotg210_hcd *fotg210, unsigned frame,\r\nunsigned uframe, unsigned period, unsigned usecs)\r\n{\r\nint claimed;\r\nif (uframe >= 8)\r\nreturn 0;\r\nusecs = fotg210->uframe_periodic_max - usecs;\r\nif (unlikely(period == 0)) {\r\ndo {\r\nfor (uframe = 0; uframe < 7; uframe++) {\r\nclaimed = periodic_usecs(fotg210, frame,\r\nuframe);\r\nif (claimed > usecs)\r\nreturn 0;\r\n}\r\n} while ((frame += 1) < fotg210->periodic_size);\r\n} else {\r\ndo {\r\nclaimed = periodic_usecs(fotg210, frame, uframe);\r\nif (claimed > usecs)\r\nreturn 0;\r\n} while ((frame += period) < fotg210->periodic_size);\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_intr_schedule(struct fotg210_hcd *fotg210, unsigned frame,\r\nunsigned uframe, const struct fotg210_qh *qh, __hc32 *c_maskp)\r\n{\r\nint retval = -ENOSPC;\r\nu8 mask = 0;\r\nif (qh->c_usecs && uframe >= 6)\r\ngoto done;\r\nif (!check_period(fotg210, frame, uframe, qh->period, qh->usecs))\r\ngoto done;\r\nif (!qh->c_usecs) {\r\nretval = 0;\r\n*c_maskp = 0;\r\ngoto done;\r\n}\r\nmask = 0x03 << (uframe + qh->gap_uf);\r\n*c_maskp = cpu_to_hc32(fotg210, mask << 8);\r\nmask |= 1 << uframe;\r\nif (tt_no_collision(fotg210, qh->period, qh->dev, frame, mask)) {\r\nif (!check_period(fotg210, frame, uframe + qh->gap_uf + 1,\r\nqh->period, qh->c_usecs))\r\ngoto done;\r\nif (!check_period(fotg210, frame, uframe + qh->gap_uf,\r\nqh->period, qh->c_usecs))\r\ngoto done;\r\nretval = 0;\r\n}\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int qh_schedule(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\r\n{\r\nint status;\r\nunsigned uframe;\r\n__hc32 c_mask;\r\nunsigned frame;\r\nstruct fotg210_qh_hw *hw = qh->hw;\r\nqh_refresh(fotg210, qh);\r\nhw->hw_next = FOTG210_LIST_END(fotg210);\r\nframe = qh->start;\r\nif (frame < qh->period) {\r\nuframe = ffs(hc32_to_cpup(fotg210, &hw->hw_info2) & QH_SMASK);\r\nstatus = check_intr_schedule(fotg210, frame, --uframe,\r\nqh, &c_mask);\r\n} else {\r\nuframe = 0;\r\nc_mask = 0;\r\nstatus = -ENOSPC;\r\n}\r\nif (status) {\r\nif (qh->period) {\r\nint i;\r\nfor (i = qh->period; status && i > 0; --i) {\r\nframe = ++fotg210->random_frame % qh->period;\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nstatus = check_intr_schedule(fotg210,\r\nframe, uframe, qh,\r\n&c_mask);\r\nif (status == 0)\r\nbreak;\r\n}\r\n}\r\n} else {\r\nframe = 0;\r\nstatus = check_intr_schedule(fotg210, 0, 0, qh,\r\n&c_mask);\r\n}\r\nif (status)\r\ngoto done;\r\nqh->start = frame;\r\nhw->hw_info2 &= cpu_to_hc32(fotg210, ~(QH_CMASK | QH_SMASK));\r\nhw->hw_info2 |= qh->period\r\n? cpu_to_hc32(fotg210, 1 << uframe)\r\n: cpu_to_hc32(fotg210, QH_SMASK);\r\nhw->hw_info2 |= c_mask;\r\n} else\r\nfotg210_dbg(fotg210, "reused qh %p schedule\n", qh);\r\nqh_link_periodic(fotg210, qh);\r\ndone:\r\nreturn status;\r\n}\r\nstatic int intr_submit(struct fotg210_hcd *fotg210, struct urb *urb,\r\nstruct list_head *qtd_list, gfp_t mem_flags)\r\n{\r\nunsigned epnum;\r\nunsigned long flags;\r\nstruct fotg210_qh *qh;\r\nint status;\r\nstruct list_head empty;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(fotg210_to_hcd(fotg210)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(fotg210_to_hcd(fotg210), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nINIT_LIST_HEAD(&empty);\r\nqh = qh_append_tds(fotg210, urb, &empty, epnum, &urb->ep->hcpriv);\r\nif (qh == NULL) {\r\nstatus = -ENOMEM;\r\ngoto done;\r\n}\r\nif (qh->qh_state == QH_STATE_IDLE) {\r\nstatus = qh_schedule(fotg210, qh);\r\nif (status)\r\ngoto done;\r\n}\r\nqh = qh_append_tds(fotg210, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nBUG_ON(qh == NULL);\r\nfotg210_to_hcd(fotg210)->self.bandwidth_int_reqs++;\r\ndone:\r\nif (unlikely(status))\r\nusb_hcd_unlink_urb_from_ep(fotg210_to_hcd(fotg210), urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nif (status)\r\nqtd_list_free(fotg210, urb, qtd_list);\r\nreturn status;\r\n}\r\nstatic void scan_intr(struct fotg210_hcd *fotg210)\r\n{\r\nstruct fotg210_qh *qh;\r\nlist_for_each_entry_safe(qh, fotg210->qh_scan_next,\r\n&fotg210->intr_qh_list, intr_node) {\r\nrescan:\r\nif (!list_empty(&qh->qtd_list)) {\r\nint temp;\r\ntemp = qh_completions(fotg210, qh);\r\nif (unlikely(qh->needs_rescan ||\r\n(list_empty(&qh->qtd_list) &&\r\nqh->qh_state == QH_STATE_LINKED)))\r\nstart_unlink_intr(fotg210, qh);\r\nelse if (temp != 0)\r\ngoto rescan;\r\n}\r\n}\r\n}\r\nstatic struct fotg210_iso_stream *iso_stream_alloc(gfp_t mem_flags)\r\n{\r\nstruct fotg210_iso_stream *stream;\r\nstream = kzalloc(sizeof(*stream), mem_flags);\r\nif (likely(stream != NULL)) {\r\nINIT_LIST_HEAD(&stream->td_list);\r\nINIT_LIST_HEAD(&stream->free_list);\r\nstream->next_uframe = -1;\r\n}\r\nreturn stream;\r\n}\r\nstatic void iso_stream_init(struct fotg210_hcd *fotg210,\r\nstruct fotg210_iso_stream *stream, struct usb_device *dev,\r\nint pipe, unsigned interval)\r\n{\r\nu32 buf1;\r\nunsigned epnum, maxp;\r\nint is_input;\r\nlong bandwidth;\r\nunsigned multi;\r\nepnum = usb_pipeendpoint(pipe);\r\nis_input = usb_pipein(pipe) ? USB_DIR_IN : 0;\r\nmaxp = usb_maxpacket(dev, pipe, !is_input);\r\nif (is_input)\r\nbuf1 = (1 << 11);\r\nelse\r\nbuf1 = 0;\r\nmaxp = max_packet(maxp);\r\nmulti = hb_mult(maxp);\r\nbuf1 |= maxp;\r\nmaxp *= multi;\r\nstream->buf0 = cpu_to_hc32(fotg210, (epnum << 8) | dev->devnum);\r\nstream->buf1 = cpu_to_hc32(fotg210, buf1);\r\nstream->buf2 = cpu_to_hc32(fotg210, multi);\r\nif (dev->speed == USB_SPEED_FULL) {\r\ninterval <<= 3;\r\nstream->usecs = NS_TO_US(usb_calc_bus_time(dev->speed,\r\nis_input, 1, maxp));\r\nstream->usecs /= 8;\r\n} else {\r\nstream->highspeed = 1;\r\nstream->usecs = HS_USECS_ISO(maxp);\r\n}\r\nbandwidth = stream->usecs * 8;\r\nbandwidth /= interval;\r\nstream->bandwidth = bandwidth;\r\nstream->udev = dev;\r\nstream->bEndpointAddress = is_input | epnum;\r\nstream->interval = interval;\r\nstream->maxp = maxp;\r\n}\r\nstatic struct fotg210_iso_stream *iso_stream_find(struct fotg210_hcd *fotg210,\r\nstruct urb *urb)\r\n{\r\nunsigned epnum;\r\nstruct fotg210_iso_stream *stream;\r\nstruct usb_host_endpoint *ep;\r\nunsigned long flags;\r\nepnum = usb_pipeendpoint(urb->pipe);\r\nif (usb_pipein(urb->pipe))\r\nep = urb->dev->ep_in[epnum];\r\nelse\r\nep = urb->dev->ep_out[epnum];\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nstream = ep->hcpriv;\r\nif (unlikely(stream == NULL)) {\r\nstream = iso_stream_alloc(GFP_ATOMIC);\r\nif (likely(stream != NULL)) {\r\nep->hcpriv = stream;\r\nstream->ep = ep;\r\niso_stream_init(fotg210, stream, urb->dev, urb->pipe,\r\nurb->interval);\r\n}\r\n} else if (unlikely(stream->hw != NULL)) {\r\nfotg210_dbg(fotg210, "dev %s ep%d%s, not iso??\n",\r\nurb->dev->devpath, epnum,\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nstream = NULL;\r\n}\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn stream;\r\n}\r\nstatic struct fotg210_iso_sched *iso_sched_alloc(unsigned packets,\r\ngfp_t mem_flags)\r\n{\r\nstruct fotg210_iso_sched *iso_sched;\r\nint size = sizeof(*iso_sched);\r\nsize += packets * sizeof(struct fotg210_iso_packet);\r\niso_sched = kzalloc(size, mem_flags);\r\nif (likely(iso_sched != NULL))\r\nINIT_LIST_HEAD(&iso_sched->td_list);\r\nreturn iso_sched;\r\n}\r\nstatic inline void itd_sched_init(struct fotg210_hcd *fotg210,\r\nstruct fotg210_iso_sched *iso_sched,\r\nstruct fotg210_iso_stream *stream, struct urb *urb)\r\n{\r\nunsigned i;\r\ndma_addr_t dma = urb->transfer_dma;\r\niso_sched->span = urb->number_of_packets * stream->interval;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstruct fotg210_iso_packet *uframe = &iso_sched->packet[i];\r\nunsigned length;\r\ndma_addr_t buf;\r\nu32 trans;\r\nlength = urb->iso_frame_desc[i].length;\r\nbuf = dma + urb->iso_frame_desc[i].offset;\r\ntrans = FOTG210_ISOC_ACTIVE;\r\ntrans |= buf & 0x0fff;\r\nif (unlikely(((i + 1) == urb->number_of_packets))\r\n&& !(urb->transfer_flags & URB_NO_INTERRUPT))\r\ntrans |= FOTG210_ITD_IOC;\r\ntrans |= length << 16;\r\nuframe->transaction = cpu_to_hc32(fotg210, trans);\r\nuframe->bufp = (buf & ~(u64)0x0fff);\r\nbuf += length;\r\nif (unlikely((uframe->bufp != (buf & ~(u64)0x0fff))))\r\nuframe->cross = 1;\r\n}\r\n}\r\nstatic void iso_sched_free(struct fotg210_iso_stream *stream,\r\nstruct fotg210_iso_sched *iso_sched)\r\n{\r\nif (!iso_sched)\r\nreturn;\r\nlist_splice(&iso_sched->td_list, &stream->free_list);\r\nkfree(iso_sched);\r\n}\r\nstatic int itd_urb_transaction(struct fotg210_iso_stream *stream,\r\nstruct fotg210_hcd *fotg210, struct urb *urb, gfp_t mem_flags)\r\n{\r\nstruct fotg210_itd *itd;\r\ndma_addr_t itd_dma;\r\nint i;\r\nunsigned num_itds;\r\nstruct fotg210_iso_sched *sched;\r\nunsigned long flags;\r\nsched = iso_sched_alloc(urb->number_of_packets, mem_flags);\r\nif (unlikely(sched == NULL))\r\nreturn -ENOMEM;\r\nitd_sched_init(fotg210, sched, stream, urb);\r\nif (urb->interval < 8)\r\nnum_itds = 1 + (sched->span + 7) / 8;\r\nelse\r\nnum_itds = urb->number_of_packets;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nfor (i = 0; i < num_itds; i++) {\r\nif (likely(!list_empty(&stream->free_list))) {\r\nitd = list_first_entry(&stream->free_list,\r\nstruct fotg210_itd, itd_list);\r\nif (itd->frame == fotg210->now_frame)\r\ngoto alloc_itd;\r\nlist_del(&itd->itd_list);\r\nitd_dma = itd->itd_dma;\r\n} else {\r\nalloc_itd:\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nitd = dma_pool_alloc(fotg210->itd_pool, mem_flags,\r\n&itd_dma);\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nif (!itd) {\r\niso_sched_free(stream, sched);\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset(itd, 0, sizeof(*itd));\r\nitd->itd_dma = itd_dma;\r\nlist_add(&itd->itd_list, &sched->td_list);\r\n}\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nurb->hcpriv = sched;\r\nurb->error_count = 0;\r\nreturn 0;\r\n}\r\nstatic inline int itd_slot_ok(struct fotg210_hcd *fotg210, u32 mod, u32 uframe,\r\nu8 usecs, u32 period)\r\n{\r\nuframe %= period;\r\ndo {\r\nif (periodic_usecs(fotg210, uframe >> 3, uframe & 0x7)\r\n> (fotg210->uframe_periodic_max - usecs))\r\nreturn 0;\r\nuframe += period;\r\n} while (uframe < mod);\r\nreturn 1;\r\n}\r\nstatic int iso_stream_schedule(struct fotg210_hcd *fotg210, struct urb *urb,\r\nstruct fotg210_iso_stream *stream)\r\n{\r\nu32 now, next, start, period, span;\r\nint status;\r\nunsigned mod = fotg210->periodic_size << 3;\r\nstruct fotg210_iso_sched *sched = urb->hcpriv;\r\nperiod = urb->interval;\r\nspan = sched->span;\r\nif (span > mod - SCHEDULE_SLOP) {\r\nfotg210_dbg(fotg210, "iso request %p too long\n", urb);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\nnow = fotg210_read_frame_index(fotg210) & (mod - 1);\r\nif (likely(!list_empty(&stream->td_list))) {\r\nu32 excess;\r\nif (!stream->highspeed && fotg210->fs_i_thresh)\r\nnext = now + fotg210->i_thresh;\r\nelse\r\nnext = now;\r\nexcess = (stream->next_uframe - period - next) & (mod - 1);\r\nif (excess >= mod - 2 * SCHEDULE_SLOP)\r\nstart = next + excess - mod + period *\r\nDIV_ROUND_UP(mod - excess, period);\r\nelse\r\nstart = next + excess + period;\r\nif (start - now >= mod) {\r\nfotg210_dbg(fotg210, "request %p would overflow (%d+%d >= %d)\n",\r\nurb, start - now - period, period,\r\nmod);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\n}\r\nelse {\r\nint done = 0;\r\nstart = SCHEDULE_SLOP + (now & ~0x07);\r\nnext = start;\r\nstart += period;\r\ndo {\r\nstart--;\r\nif (itd_slot_ok(fotg210, mod, start,\r\nstream->usecs, period))\r\ndone = 1;\r\n} while (start > next && !done);\r\nif (!done) {\r\nfotg210_dbg(fotg210, "iso resched full %p (now %d max %d)\n",\r\nurb, now, now + mod);\r\nstatus = -ENOSPC;\r\ngoto fail;\r\n}\r\n}\r\nif (unlikely(start - now + span - period >=\r\nmod - 2 * SCHEDULE_SLOP)) {\r\nfotg210_dbg(fotg210, "request %p would overflow (%d+%d >= %d)\n",\r\nurb, start - now, span - period,\r\nmod - 2 * SCHEDULE_SLOP);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\nstream->next_uframe = start & (mod - 1);\r\nurb->start_frame = stream->next_uframe;\r\nif (!stream->highspeed)\r\nurb->start_frame >>= 3;\r\nif (fotg210->isoc_count == 0)\r\nfotg210->next_frame = now >> 3;\r\nreturn 0;\r\nfail:\r\niso_sched_free(stream, sched);\r\nurb->hcpriv = NULL;\r\nreturn status;\r\n}\r\nstatic inline void itd_init(struct fotg210_hcd *fotg210,\r\nstruct fotg210_iso_stream *stream, struct fotg210_itd *itd)\r\n{\r\nint i;\r\nitd->hw_next = FOTG210_LIST_END(fotg210);\r\nitd->hw_bufp[0] = stream->buf0;\r\nitd->hw_bufp[1] = stream->buf1;\r\nitd->hw_bufp[2] = stream->buf2;\r\nfor (i = 0; i < 8; i++)\r\nitd->index[i] = -1;\r\n}\r\nstatic inline void itd_patch(struct fotg210_hcd *fotg210,\r\nstruct fotg210_itd *itd, struct fotg210_iso_sched *iso_sched,\r\nunsigned index, u16 uframe)\r\n{\r\nstruct fotg210_iso_packet *uf = &iso_sched->packet[index];\r\nunsigned pg = itd->pg;\r\nuframe &= 0x07;\r\nitd->index[uframe] = index;\r\nitd->hw_transaction[uframe] = uf->transaction;\r\nitd->hw_transaction[uframe] |= cpu_to_hc32(fotg210, pg << 12);\r\nitd->hw_bufp[pg] |= cpu_to_hc32(fotg210, uf->bufp & ~(u32)0);\r\nitd->hw_bufp_hi[pg] |= cpu_to_hc32(fotg210, (u32)(uf->bufp >> 32));\r\nif (unlikely(uf->cross)) {\r\nu64 bufp = uf->bufp + 4096;\r\nitd->pg = ++pg;\r\nitd->hw_bufp[pg] |= cpu_to_hc32(fotg210, bufp & ~(u32)0);\r\nitd->hw_bufp_hi[pg] |= cpu_to_hc32(fotg210, (u32)(bufp >> 32));\r\n}\r\n}\r\nstatic inline void itd_link(struct fotg210_hcd *fotg210, unsigned frame,\r\nstruct fotg210_itd *itd)\r\n{\r\nunion fotg210_shadow *prev = &fotg210->pshadow[frame];\r\n__hc32 *hw_p = &fotg210->periodic[frame];\r\nunion fotg210_shadow here = *prev;\r\n__hc32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(fotg210, *hw_p);\r\nif (type == cpu_to_hc32(fotg210, Q_TYPE_QH))\r\nbreak;\r\nprev = periodic_next_shadow(fotg210, prev, type);\r\nhw_p = shadow_next_periodic(fotg210, &here, type);\r\nhere = *prev;\r\n}\r\nitd->itd_next = here;\r\nitd->hw_next = *hw_p;\r\nprev->itd = itd;\r\nitd->frame = frame;\r\nwmb();\r\n*hw_p = cpu_to_hc32(fotg210, itd->itd_dma | Q_TYPE_ITD);\r\n}\r\nstatic void itd_link_urb(struct fotg210_hcd *fotg210, struct urb *urb,\r\nunsigned mod, struct fotg210_iso_stream *stream)\r\n{\r\nint packet;\r\nunsigned next_uframe, uframe, frame;\r\nstruct fotg210_iso_sched *iso_sched = urb->hcpriv;\r\nstruct fotg210_itd *itd;\r\nnext_uframe = stream->next_uframe & (mod - 1);\r\nif (unlikely(list_empty(&stream->td_list))) {\r\nfotg210_to_hcd(fotg210)->self.bandwidth_allocated\r\n+= stream->bandwidth;\r\nfotg210_dbg(fotg210,\r\n"schedule devp %s ep%d%s-iso period %d start %d.%d\n",\r\nurb->dev->devpath, stream->bEndpointAddress & 0x0f,\r\n(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out",\r\nurb->interval,\r\nnext_uframe >> 3, next_uframe & 0x7);\r\n}\r\nfor (packet = 0, itd = NULL; packet < urb->number_of_packets;) {\r\nif (itd == NULL) {\r\nitd = list_entry(iso_sched->td_list.next,\r\nstruct fotg210_itd, itd_list);\r\nlist_move_tail(&itd->itd_list, &stream->td_list);\r\nitd->stream = stream;\r\nitd->urb = urb;\r\nitd_init(fotg210, stream, itd);\r\n}\r\nuframe = next_uframe & 0x07;\r\nframe = next_uframe >> 3;\r\nitd_patch(fotg210, itd, iso_sched, packet, uframe);\r\nnext_uframe += stream->interval;\r\nnext_uframe &= mod - 1;\r\npacket++;\r\nif (((next_uframe >> 3) != frame)\r\n|| packet == urb->number_of_packets) {\r\nitd_link(fotg210, frame & (fotg210->periodic_size - 1),\r\nitd);\r\nitd = NULL;\r\n}\r\n}\r\nstream->next_uframe = next_uframe;\r\niso_sched_free(stream, iso_sched);\r\nurb->hcpriv = NULL;\r\n++fotg210->isoc_count;\r\nenable_periodic(fotg210);\r\n}\r\nstatic bool itd_complete(struct fotg210_hcd *fotg210, struct fotg210_itd *itd)\r\n{\r\nstruct urb *urb = itd->urb;\r\nstruct usb_iso_packet_descriptor *desc;\r\nu32 t;\r\nunsigned uframe;\r\nint urb_index = -1;\r\nstruct fotg210_iso_stream *stream = itd->stream;\r\nstruct usb_device *dev;\r\nbool retval = false;\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nif (likely(itd->index[uframe] == -1))\r\ncontinue;\r\nurb_index = itd->index[uframe];\r\ndesc = &urb->iso_frame_desc[urb_index];\r\nt = hc32_to_cpup(fotg210, &itd->hw_transaction[uframe]);\r\nitd->hw_transaction[uframe] = 0;\r\nif (unlikely(t & ISO_ERRS)) {\r\nurb->error_count++;\r\nif (t & FOTG210_ISOC_BUF_ERR)\r\ndesc->status = usb_pipein(urb->pipe)\r\n? -ENOSR\r\n: -ECOMM;\r\nelse if (t & FOTG210_ISOC_BABBLE)\r\ndesc->status = -EOVERFLOW;\r\nelse\r\ndesc->status = -EPROTO;\r\nif (!(t & FOTG210_ISOC_BABBLE)) {\r\ndesc->actual_length =\r\nfotg210_itdlen(urb, desc, t);\r\nurb->actual_length += desc->actual_length;\r\n}\r\n} else if (likely((t & FOTG210_ISOC_ACTIVE) == 0)) {\r\ndesc->status = 0;\r\ndesc->actual_length = fotg210_itdlen(urb, desc, t);\r\nurb->actual_length += desc->actual_length;\r\n} else {\r\ndesc->status = -EXDEV;\r\n}\r\n}\r\nif (likely((urb_index + 1) != urb->number_of_packets))\r\ngoto done;\r\ndev = urb->dev;\r\nfotg210_urb_done(fotg210, urb, 0);\r\nretval = true;\r\nurb = NULL;\r\n--fotg210->isoc_count;\r\ndisable_periodic(fotg210);\r\nif (unlikely(list_is_singular(&stream->td_list))) {\r\nfotg210_to_hcd(fotg210)->self.bandwidth_allocated\r\n-= stream->bandwidth;\r\nfotg210_dbg(fotg210,\r\n"deschedule devp %s ep%d%s-iso\n",\r\ndev->devpath, stream->bEndpointAddress & 0x0f,\r\n(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");\r\n}\r\ndone:\r\nitd->urb = NULL;\r\nlist_move_tail(&itd->itd_list, &stream->free_list);\r\nif (list_empty(&stream->td_list)) {\r\nlist_splice_tail_init(&stream->free_list,\r\n&fotg210->cached_itd_list);\r\nstart_free_itds(fotg210);\r\n}\r\nreturn retval;\r\n}\r\nstatic int itd_submit(struct fotg210_hcd *fotg210, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nstruct fotg210_iso_stream *stream;\r\nstream = iso_stream_find(fotg210, urb);\r\nif (unlikely(stream == NULL)) {\r\nfotg210_dbg(fotg210, "can't get iso stream\n");\r\nreturn -ENOMEM;\r\n}\r\nif (unlikely(urb->interval != stream->interval &&\r\nfotg210_port_speed(fotg210, 0) ==\r\nUSB_PORT_STAT_HIGH_SPEED)) {\r\nfotg210_dbg(fotg210, "can't change iso interval %d --> %d\n",\r\nstream->interval, urb->interval);\r\ngoto done;\r\n}\r\n#ifdef FOTG210_URB_TRACE\r\nfotg210_dbg(fotg210,\r\n"%s %s urb %p ep%d%s len %d, %d pkts %d uframes[%p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nurb->number_of_packets, urb->interval,\r\nstream);\r\n#endif\r\nstatus = itd_urb_transaction(stream, fotg210, urb, mem_flags);\r\nif (unlikely(status < 0)) {\r\nfotg210_dbg(fotg210, "can't init itds\n");\r\ngoto done;\r\n}\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(fotg210_to_hcd(fotg210)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(fotg210_to_hcd(fotg210), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nstatus = iso_stream_schedule(fotg210, urb, stream);\r\nif (likely(status == 0))\r\nitd_link_urb(fotg210, urb, fotg210->periodic_size << 3, stream);\r\nelse\r\nusb_hcd_unlink_urb_from_ep(fotg210_to_hcd(fotg210), urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\ndone:\r\nreturn status;\r\n}\r\nstatic inline int scan_frame_queue(struct fotg210_hcd *fotg210, unsigned frame,\r\nunsigned now_frame, bool live)\r\n{\r\nunsigned uf;\r\nbool modified;\r\nunion fotg210_shadow q, *q_p;\r\n__hc32 type, *hw_p;\r\nq_p = &fotg210->pshadow[frame];\r\nhw_p = &fotg210->periodic[frame];\r\nq.ptr = q_p->ptr;\r\ntype = Q_NEXT_TYPE(fotg210, *hw_p);\r\nmodified = false;\r\nwhile (q.ptr) {\r\nswitch (hc32_to_cpu(fotg210, type)) {\r\ncase Q_TYPE_ITD:\r\nif (frame == now_frame && live) {\r\nrmb();\r\nfor (uf = 0; uf < 8; uf++) {\r\nif (q.itd->hw_transaction[uf] &\r\nITD_ACTIVE(fotg210))\r\nbreak;\r\n}\r\nif (uf < 8) {\r\nq_p = &q.itd->itd_next;\r\nhw_p = &q.itd->hw_next;\r\ntype = Q_NEXT_TYPE(fotg210,\r\nq.itd->hw_next);\r\nq = *q_p;\r\nbreak;\r\n}\r\n}\r\n*q_p = q.itd->itd_next;\r\n*hw_p = q.itd->hw_next;\r\ntype = Q_NEXT_TYPE(fotg210, q.itd->hw_next);\r\nwmb();\r\nmodified = itd_complete(fotg210, q.itd);\r\nq = *q_p;\r\nbreak;\r\ndefault:\r\nfotg210_dbg(fotg210, "corrupt type %d frame %d shadow %p\n",\r\ntype, frame, q.ptr);\r\ncase Q_TYPE_QH:\r\ncase Q_TYPE_FSTN:\r\nq.ptr = NULL;\r\nbreak;\r\n}\r\nif (unlikely(modified && fotg210->isoc_count > 0))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void scan_isoc(struct fotg210_hcd *fotg210)\r\n{\r\nunsigned uf, now_frame, frame, ret;\r\nunsigned fmask = fotg210->periodic_size - 1;\r\nbool live;\r\nif (fotg210->rh_state >= FOTG210_RH_RUNNING) {\r\nuf = fotg210_read_frame_index(fotg210);\r\nnow_frame = (uf >> 3) & fmask;\r\nlive = true;\r\n} else {\r\nnow_frame = (fotg210->next_frame - 1) & fmask;\r\nlive = false;\r\n}\r\nfotg210->now_frame = now_frame;\r\nframe = fotg210->next_frame;\r\nfor (;;) {\r\nret = 1;\r\nwhile (ret != 0)\r\nret = scan_frame_queue(fotg210, frame,\r\nnow_frame, live);\r\nif (frame == now_frame)\r\nbreak;\r\nframe = (frame + 1) & fmask;\r\n}\r\nfotg210->next_frame = now_frame;\r\n}\r\nstatic ssize_t show_uframe_periodic_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fotg210_hcd *fotg210;\r\nint n;\r\nfotg210 = hcd_to_fotg210(bus_to_hcd(dev_get_drvdata(dev)));\r\nn = scnprintf(buf, PAGE_SIZE, "%d\n", fotg210->uframe_periodic_max);\r\nreturn n;\r\n}\r\nstatic ssize_t store_uframe_periodic_max(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct fotg210_hcd *fotg210;\r\nunsigned uframe_periodic_max;\r\nunsigned frame, uframe;\r\nunsigned short allocated_max;\r\nunsigned long flags;\r\nssize_t ret;\r\nfotg210 = hcd_to_fotg210(bus_to_hcd(dev_get_drvdata(dev)));\r\nif (kstrtouint(buf, 0, &uframe_periodic_max) < 0)\r\nreturn -EINVAL;\r\nif (uframe_periodic_max < 100 || uframe_periodic_max >= 125) {\r\nfotg210_info(fotg210, "rejecting invalid request for uframe_periodic_max=%u\n",\r\nuframe_periodic_max);\r\nreturn -EINVAL;\r\n}\r\nret = -EINVAL;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nif (uframe_periodic_max < fotg210->uframe_periodic_max) {\r\nallocated_max = 0;\r\nfor (frame = 0; frame < fotg210->periodic_size; ++frame)\r\nfor (uframe = 0; uframe < 7; ++uframe)\r\nallocated_max = max(allocated_max,\r\nperiodic_usecs(fotg210, frame,\r\nuframe));\r\nif (allocated_max > uframe_periodic_max) {\r\nfotg210_info(fotg210,\r\n"cannot decrease uframe_periodic_max because periodic bandwidth is already allocated (%u > %u)\n",\r\nallocated_max, uframe_periodic_max);\r\ngoto out_unlock;\r\n}\r\n}\r\nfotg210_info(fotg210,\r\n"setting max periodic bandwidth to %u%% (== %u usec/uframe)\n",\r\n100 * uframe_periodic_max/125, uframe_periodic_max);\r\nif (uframe_periodic_max != 100)\r\nfotg210_warn(fotg210, "max periodic bandwidth set is non-standard\n");\r\nfotg210->uframe_periodic_max = uframe_periodic_max;\r\nret = count;\r\nout_unlock:\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn ret;\r\n}\r\nstatic inline int create_sysfs_files(struct fotg210_hcd *fotg210)\r\n{\r\nstruct device *controller = fotg210_to_hcd(fotg210)->self.controller;\r\nreturn device_create_file(controller, &dev_attr_uframe_periodic_max);\r\n}\r\nstatic inline void remove_sysfs_files(struct fotg210_hcd *fotg210)\r\n{\r\nstruct device *controller = fotg210_to_hcd(fotg210)->self.controller;\r\ndevice_remove_file(controller, &dev_attr_uframe_periodic_max);\r\n}\r\nstatic void fotg210_turn_off_all_ports(struct fotg210_hcd *fotg210)\r\n{\r\nu32 __iomem *status_reg = &fotg210->regs->port_status;\r\nfotg210_writel(fotg210, PORT_RWC_BITS, status_reg);\r\n}\r\nstatic void fotg210_silence_controller(struct fotg210_hcd *fotg210)\r\n{\r\nfotg210_halt(fotg210);\r\nspin_lock_irq(&fotg210->lock);\r\nfotg210->rh_state = FOTG210_RH_HALTED;\r\nfotg210_turn_off_all_ports(fotg210);\r\nspin_unlock_irq(&fotg210->lock);\r\n}\r\nstatic void fotg210_shutdown(struct usb_hcd *hcd)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nspin_lock_irq(&fotg210->lock);\r\nfotg210->shutdown = true;\r\nfotg210->rh_state = FOTG210_RH_STOPPING;\r\nfotg210->enabled_hrtimer_events = 0;\r\nspin_unlock_irq(&fotg210->lock);\r\nfotg210_silence_controller(fotg210);\r\nhrtimer_cancel(&fotg210->hrtimer);\r\n}\r\nstatic void fotg210_work(struct fotg210_hcd *fotg210)\r\n{\r\nif (fotg210->scanning) {\r\nfotg210->need_rescan = true;\r\nreturn;\r\n}\r\nfotg210->scanning = true;\r\nrescan:\r\nfotg210->need_rescan = false;\r\nif (fotg210->async_count)\r\nscan_async(fotg210);\r\nif (fotg210->intr_count > 0)\r\nscan_intr(fotg210);\r\nif (fotg210->isoc_count > 0)\r\nscan_isoc(fotg210);\r\nif (fotg210->need_rescan)\r\ngoto rescan;\r\nfotg210->scanning = false;\r\nturn_on_io_watchdog(fotg210);\r\n}\r\nstatic void fotg210_stop(struct usb_hcd *hcd)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nfotg210_dbg(fotg210, "stop\n");\r\nspin_lock_irq(&fotg210->lock);\r\nfotg210->enabled_hrtimer_events = 0;\r\nspin_unlock_irq(&fotg210->lock);\r\nfotg210_quiesce(fotg210);\r\nfotg210_silence_controller(fotg210);\r\nfotg210_reset(fotg210);\r\nhrtimer_cancel(&fotg210->hrtimer);\r\nremove_sysfs_files(fotg210);\r\nremove_debug_files(fotg210);\r\nspin_lock_irq(&fotg210->lock);\r\nend_free_itds(fotg210);\r\nspin_unlock_irq(&fotg210->lock);\r\nfotg210_mem_cleanup(fotg210);\r\n#ifdef FOTG210_STATS\r\nfotg210_dbg(fotg210, "irq normal %ld err %ld iaa %ld (lost %ld)\n",\r\nfotg210->stats.normal, fotg210->stats.error,\r\nfotg210->stats.iaa, fotg210->stats.lost_iaa);\r\nfotg210_dbg(fotg210, "complete %ld unlink %ld\n",\r\nfotg210->stats.complete, fotg210->stats.unlink);\r\n#endif\r\ndbg_status(fotg210, "fotg210_stop completed",\r\nfotg210_readl(fotg210, &fotg210->regs->status));\r\n}\r\nstatic int hcd_fotg210_init(struct usb_hcd *hcd)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nu32 temp;\r\nint retval;\r\nu32 hcc_params;\r\nstruct fotg210_qh_hw *hw;\r\nspin_lock_init(&fotg210->lock);\r\nfotg210->need_io_watchdog = 1;\r\nhrtimer_init(&fotg210->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nfotg210->hrtimer.function = fotg210_hrtimer_func;\r\nfotg210->next_hrtimer_event = FOTG210_HRTIMER_NO_EVENT;\r\nhcc_params = fotg210_readl(fotg210, &fotg210->caps->hcc_params);\r\nfotg210->uframe_periodic_max = 100;\r\nfotg210->periodic_size = DEFAULT_I_TDPS;\r\nINIT_LIST_HEAD(&fotg210->intr_qh_list);\r\nINIT_LIST_HEAD(&fotg210->cached_itd_list);\r\nif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\r\nswitch (FOTG210_TUNE_FLS) {\r\ncase 0:\r\nfotg210->periodic_size = 1024;\r\nbreak;\r\ncase 1:\r\nfotg210->periodic_size = 512;\r\nbreak;\r\ncase 2:\r\nfotg210->periodic_size = 256;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nretval = fotg210_mem_init(fotg210, GFP_KERNEL);\r\nif (retval < 0)\r\nreturn retval;\r\nfotg210->i_thresh = 2;\r\nfotg210->async->qh_next.qh = NULL;\r\nhw = fotg210->async->hw;\r\nhw->hw_next = QH_NEXT(fotg210, fotg210->async->qh_dma);\r\nhw->hw_info1 = cpu_to_hc32(fotg210, QH_HEAD);\r\nhw->hw_token = cpu_to_hc32(fotg210, QTD_STS_HALT);\r\nhw->hw_qtd_next = FOTG210_LIST_END(fotg210);\r\nfotg210->async->qh_state = QH_STATE_LINKED;\r\nhw->hw_alt_next = QTD_NEXT(fotg210, fotg210->async->dummy->qtd_dma);\r\nif (log2_irq_thresh < 0 || log2_irq_thresh > 6)\r\nlog2_irq_thresh = 0;\r\ntemp = 1 << (16 + log2_irq_thresh);\r\nif (HCC_CANPARK(hcc_params)) {\r\nif (park) {\r\npark = min_t(unsigned, park, 3);\r\ntemp |= CMD_PARK;\r\ntemp |= park << 8;\r\n}\r\nfotg210_dbg(fotg210, "park %d\n", park);\r\n}\r\nif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\r\ntemp &= ~(3 << 2);\r\ntemp |= (FOTG210_TUNE_FLS << 2);\r\n}\r\nfotg210->command = temp;\r\nif (!(hcd->driver->flags & HCD_LOCAL_MEM))\r\nhcd->self.sg_tablesize = ~0;\r\nreturn 0;\r\n}\r\nstatic int fotg210_run(struct usb_hcd *hcd)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nu32 temp;\r\nu32 hcc_params;\r\nhcd->uses_new_polling = 1;\r\nfotg210_writel(fotg210, fotg210->periodic_dma,\r\n&fotg210->regs->frame_list);\r\nfotg210_writel(fotg210, (u32)fotg210->async->qh_dma,\r\n&fotg210->regs->async_next);\r\nhcc_params = fotg210_readl(fotg210, &fotg210->caps->hcc_params);\r\nfotg210->command &= ~(CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);\r\nfotg210->command |= CMD_RUN;\r\nfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\r\ndbg_cmd(fotg210, "init", fotg210->command);\r\ndown_write(&ehci_cf_port_reset_rwsem);\r\nfotg210->rh_state = FOTG210_RH_RUNNING;\r\nfotg210_readl(fotg210, &fotg210->regs->command);\r\nusleep_range(5000, 10000);\r\nup_write(&ehci_cf_port_reset_rwsem);\r\nfotg210->last_periodic_enable = ktime_get_real();\r\ntemp = HC_VERSION(fotg210,\r\nfotg210_readl(fotg210, &fotg210->caps->hc_capbase));\r\nfotg210_info(fotg210,\r\n"USB %x.%x started, EHCI %x.%02x\n",\r\n((fotg210->sbrn & 0xf0) >> 4), (fotg210->sbrn & 0x0f),\r\ntemp >> 8, temp & 0xff);\r\nfotg210_writel(fotg210, INTR_MASK,\r\n&fotg210->regs->intr_enable);\r\ncreate_debug_files(fotg210);\r\ncreate_sysfs_files(fotg210);\r\nreturn 0;\r\n}\r\nstatic int fotg210_setup(struct usb_hcd *hcd)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nint retval;\r\nfotg210->regs = (void __iomem *)fotg210->caps +\r\nHC_LENGTH(fotg210,\r\nfotg210_readl(fotg210, &fotg210->caps->hc_capbase));\r\ndbg_hcs_params(fotg210, "reset");\r\ndbg_hcc_params(fotg210, "reset");\r\nfotg210->hcs_params = fotg210_readl(fotg210,\r\n&fotg210->caps->hcs_params);\r\nfotg210->sbrn = HCD_USB2;\r\nretval = hcd_fotg210_init(hcd);\r\nif (retval)\r\nreturn retval;\r\nretval = fotg210_halt(fotg210);\r\nif (retval)\r\nreturn retval;\r\nfotg210_reset(fotg210);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fotg210_irq(struct usb_hcd *hcd)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nu32 status, masked_status, pcd_status = 0, cmd;\r\nint bh;\r\nspin_lock(&fotg210->lock);\r\nstatus = fotg210_readl(fotg210, &fotg210->regs->status);\r\nif (status == ~(u32) 0) {\r\nfotg210_dbg(fotg210, "device removed\n");\r\ngoto dead;\r\n}\r\nmasked_status = status & (INTR_MASK | STS_FLR);\r\nif (!masked_status ||\r\nunlikely(fotg210->rh_state == FOTG210_RH_HALTED)) {\r\nspin_unlock(&fotg210->lock);\r\nreturn IRQ_NONE;\r\n}\r\nfotg210_writel(fotg210, masked_status, &fotg210->regs->status);\r\ncmd = fotg210_readl(fotg210, &fotg210->regs->command);\r\nbh = 0;\r\ndbg_status(fotg210, "irq", status);\r\nif (likely((status & (STS_INT|STS_ERR)) != 0)) {\r\nif (likely((status & STS_ERR) == 0))\r\nCOUNT(fotg210->stats.normal);\r\nelse\r\nCOUNT(fotg210->stats.error);\r\nbh = 1;\r\n}\r\nif (status & STS_IAA) {\r\nfotg210->enabled_hrtimer_events &=\r\n~BIT(FOTG210_HRTIMER_IAA_WATCHDOG);\r\nif (fotg210->next_hrtimer_event == FOTG210_HRTIMER_IAA_WATCHDOG)\r\n++fotg210->next_hrtimer_event;\r\nif (cmd & CMD_IAAD)\r\nfotg210_dbg(fotg210, "IAA with IAAD still set?\n");\r\nif (fotg210->async_iaa) {\r\nCOUNT(fotg210->stats.iaa);\r\nend_unlink_async(fotg210);\r\n} else\r\nfotg210_dbg(fotg210, "IAA with nothing unlinked?\n");\r\n}\r\nif (status & STS_PCD) {\r\nint pstatus;\r\nu32 __iomem *status_reg = &fotg210->regs->port_status;\r\npcd_status = status;\r\nif (fotg210->rh_state == FOTG210_RH_SUSPENDED)\r\nusb_hcd_resume_root_hub(hcd);\r\npstatus = fotg210_readl(fotg210, status_reg);\r\nif (test_bit(0, &fotg210->suspended_ports) &&\r\n((pstatus & PORT_RESUME) ||\r\n!(pstatus & PORT_SUSPEND)) &&\r\n(pstatus & PORT_PE) &&\r\nfotg210->reset_done[0] == 0) {\r\nfotg210->reset_done[0] = jiffies + msecs_to_jiffies(25);\r\nset_bit(0, &fotg210->resuming_ports);\r\nfotg210_dbg(fotg210, "port 1 remote wakeup\n");\r\nmod_timer(&hcd->rh_timer, fotg210->reset_done[0]);\r\n}\r\n}\r\nif (unlikely((status & STS_FATAL) != 0)) {\r\nfotg210_err(fotg210, "fatal error\n");\r\ndbg_cmd(fotg210, "fatal", cmd);\r\ndbg_status(fotg210, "fatal", status);\r\ndead:\r\nusb_hc_died(hcd);\r\nfotg210->shutdown = true;\r\nfotg210->rh_state = FOTG210_RH_STOPPING;\r\nfotg210->command &= ~(CMD_RUN | CMD_ASE | CMD_PSE);\r\nfotg210_writel(fotg210, fotg210->command,\r\n&fotg210->regs->command);\r\nfotg210_writel(fotg210, 0, &fotg210->regs->intr_enable);\r\nfotg210_handle_controller_death(fotg210);\r\nbh = 0;\r\n}\r\nif (bh)\r\nfotg210_work(fotg210);\r\nspin_unlock(&fotg210->lock);\r\nif (pcd_status)\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fotg210_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nstruct list_head qtd_list;\r\nINIT_LIST_HEAD(&qtd_list);\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_CONTROL:\r\nif (urb->transfer_buffer_length > (16 * 1024))\r\nreturn -EMSGSIZE;\r\ndefault:\r\nif (!qh_urb_transaction(fotg210, urb, &qtd_list, mem_flags))\r\nreturn -ENOMEM;\r\nreturn submit_async(fotg210, urb, &qtd_list, mem_flags);\r\ncase PIPE_INTERRUPT:\r\nif (!qh_urb_transaction(fotg210, urb, &qtd_list, mem_flags))\r\nreturn -ENOMEM;\r\nreturn intr_submit(fotg210, urb, &qtd_list, mem_flags);\r\ncase PIPE_ISOCHRONOUS:\r\nreturn itd_submit(fotg210, urb, mem_flags);\r\n}\r\n}\r\nstatic int fotg210_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nstruct fotg210_qh *qh;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto done;\r\nswitch (usb_pipetype(urb->pipe)) {\r\ndefault:\r\nqh = (struct fotg210_qh *) urb->hcpriv;\r\nif (!qh)\r\nbreak;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\ncase QH_STATE_COMPLETING:\r\nstart_unlink_async(fotg210, qh);\r\nbreak;\r\ncase QH_STATE_UNLINK:\r\ncase QH_STATE_UNLINK_WAIT:\r\nbreak;\r\ncase QH_STATE_IDLE:\r\nqh_completions(fotg210, qh);\r\nbreak;\r\n}\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nqh = (struct fotg210_qh *) urb->hcpriv;\r\nif (!qh)\r\nbreak;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\ncase QH_STATE_COMPLETING:\r\nstart_unlink_intr(fotg210, qh);\r\nbreak;\r\ncase QH_STATE_IDLE:\r\nqh_completions(fotg210, qh);\r\nbreak;\r\ndefault:\r\nfotg210_dbg(fotg210, "bogus qh %p state %d\n",\r\nqh, qh->qh_state);\r\ngoto done;\r\n}\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\nbreak;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void fotg210_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nunsigned long flags;\r\nstruct fotg210_qh *qh, *tmp;\r\nrescan:\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nqh = ep->hcpriv;\r\nif (!qh)\r\ngoto done;\r\nif (qh->hw == NULL) {\r\nstruct fotg210_iso_stream *stream = ep->hcpriv;\r\nif (!list_empty(&stream->td_list))\r\ngoto idle_timeout;\r\nkfree(stream);\r\ngoto done;\r\n}\r\nif (fotg210->rh_state < FOTG210_RH_RUNNING)\r\nqh->qh_state = QH_STATE_IDLE;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\ncase QH_STATE_COMPLETING:\r\nfor (tmp = fotg210->async->qh_next.qh;\r\ntmp && tmp != qh;\r\ntmp = tmp->qh_next.qh)\r\ncontinue;\r\nif (tmp)\r\nstart_unlink_async(fotg210, qh);\r\ncase QH_STATE_UNLINK:\r\ncase QH_STATE_UNLINK_WAIT:\r\nidle_timeout:\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nschedule_timeout_uninterruptible(1);\r\ngoto rescan;\r\ncase QH_STATE_IDLE:\r\nif (qh->clearing_tt)\r\ngoto idle_timeout;\r\nif (list_empty(&qh->qtd_list)) {\r\nqh_destroy(fotg210, qh);\r\nbreak;\r\n}\r\ndefault:\r\nfotg210_err(fotg210, "qh %p (#%02x) state %d%s\n",\r\nqh, ep->desc.bEndpointAddress, qh->qh_state,\r\nlist_empty(&qh->qtd_list) ? "" : "(has tds)");\r\nbreak;\r\n}\r\ndone:\r\nep->hcpriv = NULL;\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\n}\r\nstatic void fotg210_endpoint_reset(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nstruct fotg210_qh *qh;\r\nint eptype = usb_endpoint_type(&ep->desc);\r\nint epnum = usb_endpoint_num(&ep->desc);\r\nint is_out = usb_endpoint_dir_out(&ep->desc);\r\nunsigned long flags;\r\nif (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)\r\nreturn;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nqh = ep->hcpriv;\r\nif (qh) {\r\nusb_settoggle(qh->dev, epnum, is_out, 0);\r\nif (!list_empty(&qh->qtd_list)) {\r\nWARN_ONCE(1, "clear_halt for a busy endpoint\n");\r\n} else if (qh->qh_state == QH_STATE_LINKED ||\r\nqh->qh_state == QH_STATE_COMPLETING) {\r\nif (eptype == USB_ENDPOINT_XFER_BULK)\r\nstart_unlink_async(fotg210, qh);\r\nelse\r\nstart_unlink_intr(fotg210, qh);\r\n}\r\n}\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\n}\r\nstatic int fotg210_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\r\nreturn (fotg210_read_frame_index(fotg210) >> 3) %\r\nfotg210->periodic_size;\r\n}\r\nstatic void fotg210_init(struct fotg210_hcd *fotg210)\r\n{\r\nu32 value;\r\niowrite32(GMIR_MDEV_INT | GMIR_MOTG_INT | GMIR_INT_POLARITY,\r\n&fotg210->regs->gmir);\r\nvalue = ioread32(&fotg210->regs->otgcsr);\r\nvalue &= ~OTGCSR_A_BUS_DROP;\r\nvalue |= OTGCSR_A_BUS_REQ;\r\niowrite32(value, &fotg210->regs->otgcsr);\r\n}\r\nstatic int fotg210_hcd_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd;\r\nstruct resource *res;\r\nint irq;\r\nint retval = -ENODEV;\r\nstruct fotg210_hcd *fotg210;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npdev->dev.power.power_state = PMSG_ON;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "Found HC with no IRQ. Check %s setup!\n",\r\ndev_name(dev));\r\nreturn -ENODEV;\r\n}\r\nirq = res->start;\r\nhcd = usb_create_hcd(&fotg210_fotg210_hc_driver, dev,\r\ndev_name(dev));\r\nif (!hcd) {\r\ndev_err(dev, "failed to create hcd with err %d\n", retval);\r\nretval = -ENOMEM;\r\ngoto fail_create_hcd;\r\n}\r\nhcd->has_tt = 1;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nretval = PTR_ERR(hcd->regs);\r\ngoto failed;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nfotg210 = hcd_to_fotg210(hcd);\r\nfotg210->caps = hcd->regs;\r\nretval = fotg210_setup(hcd);\r\nif (retval)\r\ngoto failed;\r\nfotg210_init(fotg210);\r\nretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (retval) {\r\ndev_err(dev, "failed to add hcd with err %d\n", retval);\r\ngoto failed;\r\n}\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn retval;\r\nfailed:\r\nusb_put_hcd(hcd);\r\nfail_create_hcd:\r\ndev_err(dev, "init %s fail, %d\n", dev_name(dev), retval);\r\nreturn retval;\r\n}\r\nstatic int fotg210_hcd_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nif (!hcd)\r\nreturn 0;\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int __init fotg210_hcd_init(void)\r\n{\r\nint retval = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nset_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\nif (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||\r\ntest_bit(USB_OHCI_LOADED, &usb_hcds_loaded))\r\npr_warn("Warning! fotg210_hcd should always be loaded before uhci_hcd and ohci_hcd, not after\n");\r\npr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd\n",\r\nhcd_name, sizeof(struct fotg210_qh),\r\nsizeof(struct fotg210_qtd),\r\nsizeof(struct fotg210_itd));\r\nfotg210_debug_root = debugfs_create_dir("fotg210", usb_debug_root);\r\nif (!fotg210_debug_root) {\r\nretval = -ENOENT;\r\ngoto err_debug;\r\n}\r\nretval = platform_driver_register(&fotg210_hcd_driver);\r\nif (retval < 0)\r\ngoto clean;\r\nreturn retval;\r\nclean:\r\ndebugfs_remove(fotg210_debug_root);\r\nfotg210_debug_root = NULL;\r\nerr_debug:\r\nclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\nreturn retval;\r\n}\r\nstatic void __exit fotg210_hcd_cleanup(void)\r\n{\r\nplatform_driver_unregister(&fotg210_hcd_driver);\r\ndebugfs_remove(fotg210_debug_root);\r\nclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\n}
