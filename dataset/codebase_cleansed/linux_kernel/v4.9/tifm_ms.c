static unsigned int tifm_ms_read_data(struct tifm_ms *host,\r\nunsigned char *buf, unsigned int length)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned int off = 0;\r\nwhile (host->io_pos && length) {\r\nbuf[off++] = host->io_word & 0xff;\r\nhost->io_word >>= 8;\r\nlength--;\r\nhost->io_pos--;\r\n}\r\nif (!length)\r\nreturn off;\r\nwhile (!(TIFM_MS_STAT_EMP & readl(sock->addr + SOCK_MS_STATUS))) {\r\nif (length < 4)\r\nbreak;\r\n*(unsigned int *)(buf + off) = __raw_readl(sock->addr\r\n+ SOCK_MS_DATA);\r\nlength -= 4;\r\noff += 4;\r\n}\r\nif (length\r\n&& !(TIFM_MS_STAT_EMP & readl(sock->addr + SOCK_MS_STATUS))) {\r\nhost->io_word = readl(sock->addr + SOCK_MS_DATA);\r\nfor (host->io_pos = 4; host->io_pos; --host->io_pos) {\r\nbuf[off++] = host->io_word & 0xff;\r\nhost->io_word >>= 8;\r\nlength--;\r\nif (!length)\r\nbreak;\r\n}\r\n}\r\nreturn off;\r\n}\r\nstatic unsigned int tifm_ms_write_data(struct tifm_ms *host,\r\nunsigned char *buf, unsigned int length)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned int off = 0;\r\nif (host->io_pos) {\r\nwhile (host->io_pos < 4 && length) {\r\nhost->io_word |= buf[off++] << (host->io_pos * 8);\r\nhost->io_pos++;\r\nlength--;\r\n}\r\n}\r\nif (host->io_pos == 4\r\n&& !(TIFM_MS_STAT_FUL & readl(sock->addr + SOCK_MS_STATUS))) {\r\nwritel(TIFM_MS_SYS_FDIR | readl(sock->addr + SOCK_MS_SYSTEM),\r\nsock->addr + SOCK_MS_SYSTEM);\r\nwritel(host->io_word, sock->addr + SOCK_MS_DATA);\r\nhost->io_pos = 0;\r\nhost->io_word = 0;\r\n} else if (host->io_pos) {\r\nreturn off;\r\n}\r\nif (!length)\r\nreturn off;\r\nwhile (!(TIFM_MS_STAT_FUL & readl(sock->addr + SOCK_MS_STATUS))) {\r\nif (length < 4)\r\nbreak;\r\nwritel(TIFM_MS_SYS_FDIR | readl(sock->addr + SOCK_MS_SYSTEM),\r\nsock->addr + SOCK_MS_SYSTEM);\r\n__raw_writel(*(unsigned int *)(buf + off),\r\nsock->addr + SOCK_MS_DATA);\r\nlength -= 4;\r\noff += 4;\r\n}\r\nswitch (length) {\r\ncase 3:\r\nhost->io_word |= buf[off + 2] << 16;\r\nhost->io_pos++;\r\ncase 2:\r\nhost->io_word |= buf[off + 1] << 8;\r\nhost->io_pos++;\r\ncase 1:\r\nhost->io_word |= buf[off];\r\nhost->io_pos++;\r\n}\r\noff += host->io_pos;\r\nreturn off;\r\n}\r\nstatic unsigned int tifm_ms_transfer_data(struct tifm_ms *host)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned int length;\r\nunsigned int off;\r\nunsigned int t_size, p_cnt;\r\nunsigned char *buf;\r\nstruct page *pg;\r\nunsigned long flags = 0;\r\nif (host->req->long_data) {\r\nlength = host->req->sg.length - host->block_pos;\r\noff = host->req->sg.offset + host->block_pos;\r\n} else {\r\nlength = host->req->data_len - host->block_pos;\r\noff = 0;\r\n}\r\ndev_dbg(&sock->dev, "fifo data transfer, %d, %d\n", length,\r\nhost->block_pos);\r\nwhile (length) {\r\nunsigned int uninitialized_var(p_off);\r\nif (host->req->long_data) {\r\npg = nth_page(sg_page(&host->req->sg),\r\noff >> PAGE_SHIFT);\r\np_off = offset_in_page(off);\r\np_cnt = PAGE_SIZE - p_off;\r\np_cnt = min(p_cnt, length);\r\nlocal_irq_save(flags);\r\nbuf = kmap_atomic(pg) + p_off;\r\n} else {\r\nbuf = host->req->data + host->block_pos;\r\np_cnt = host->req->data_len - host->block_pos;\r\n}\r\nt_size = host->req->data_dir == WRITE\r\n? tifm_ms_write_data(host, buf, p_cnt)\r\n: tifm_ms_read_data(host, buf, p_cnt);\r\nif (host->req->long_data) {\r\nkunmap_atomic(buf - p_off);\r\nlocal_irq_restore(flags);\r\n}\r\nif (!t_size)\r\nbreak;\r\nhost->block_pos += t_size;\r\nlength -= t_size;\r\noff += t_size;\r\n}\r\ndev_dbg(&sock->dev, "fifo data transfer, %d remaining\n", length);\r\nif (!length && (host->req->data_dir == WRITE)) {\r\nif (host->io_pos) {\r\nwritel(TIFM_MS_SYS_FDIR\r\n| readl(sock->addr + SOCK_MS_SYSTEM),\r\nsock->addr + SOCK_MS_SYSTEM);\r\nwritel(host->io_word, sock->addr + SOCK_MS_DATA);\r\n}\r\nwritel(TIFM_MS_SYS_FDIR\r\n| readl(sock->addr + SOCK_MS_SYSTEM),\r\nsock->addr + SOCK_MS_SYSTEM);\r\nwritel(0, sock->addr + SOCK_MS_DATA);\r\n} else {\r\nreadl(sock->addr + SOCK_MS_DATA);\r\n}\r\nreturn length;\r\n}\r\nstatic int tifm_ms_issue_cmd(struct tifm_ms *host)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned char *data;\r\nunsigned int data_len, cmd, sys_param;\r\nhost->cmd_flags = 0;\r\nhost->block_pos = 0;\r\nhost->io_pos = 0;\r\nhost->io_word = 0;\r\nhost->cmd_flags = 0;\r\ndata = host->req->data;\r\nhost->use_dma = !no_dma;\r\nif (host->req->long_data) {\r\ndata_len = host->req->sg.length;\r\nif (!is_power_of_2(data_len))\r\nhost->use_dma = 0;\r\n} else {\r\ndata_len = host->req->data_len;\r\nhost->use_dma = 0;\r\n}\r\nwritel(TIFM_FIFO_INT_SETALL,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\r\nwritel(TIFM_FIFO_ENABLE,\r\nsock->addr + SOCK_FIFO_CONTROL);\r\nif (host->use_dma) {\r\nif (1 != tifm_map_sg(sock, &host->req->sg, 1,\r\nhost->req->data_dir == READ\r\n? PCI_DMA_FROMDEVICE\r\n: PCI_DMA_TODEVICE)) {\r\nhost->req->error = -ENOMEM;\r\nreturn host->req->error;\r\n}\r\ndata_len = sg_dma_len(&host->req->sg);\r\nwritel(ilog2(data_len) - 2,\r\nsock->addr + SOCK_FIFO_PAGE_SIZE);\r\nwritel(TIFM_FIFO_INTMASK,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\r\nsys_param = TIFM_DMA_EN | (1 << 8);\r\nif (host->req->data_dir == WRITE)\r\nsys_param |= TIFM_DMA_TX;\r\nwritel(TIFM_FIFO_INTMASK,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\r\nwritel(sg_dma_address(&host->req->sg),\r\nsock->addr + SOCK_DMA_ADDRESS);\r\nwritel(sys_param, sock->addr + SOCK_DMA_CONTROL);\r\n} else {\r\nwritel(host->mode_mask | TIFM_MS_SYS_FIFO,\r\nsock->addr + SOCK_MS_SYSTEM);\r\nwritel(TIFM_FIFO_MORE,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\r\n}\r\nmod_timer(&host->timer, jiffies + host->timeout_jiffies);\r\nwritel(TIFM_CTRL_LED | readl(sock->addr + SOCK_CONTROL),\r\nsock->addr + SOCK_CONTROL);\r\nhost->req->error = 0;\r\nsys_param = readl(sock->addr + SOCK_MS_SYSTEM);\r\nsys_param |= TIFM_MS_SYS_INTCLR;\r\nif (host->use_dma)\r\nsys_param |= TIFM_MS_SYS_DMA;\r\nelse\r\nsys_param &= ~TIFM_MS_SYS_DMA;\r\nwritel(sys_param, sock->addr + SOCK_MS_SYSTEM);\r\ncmd = (host->req->tpc & 0xf) << 12;\r\ncmd |= data_len;\r\nwritel(cmd, sock->addr + SOCK_MS_COMMAND);\r\ndev_dbg(&sock->dev, "executing TPC %x, %x\n", cmd, sys_param);\r\nreturn 0;\r\n}\r\nstatic void tifm_ms_complete_cmd(struct tifm_ms *host)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nstruct memstick_host *msh = tifm_get_drvdata(sock);\r\nint rc;\r\ndel_timer(&host->timer);\r\nhost->req->int_reg = readl(sock->addr + SOCK_MS_STATUS) & 0xff;\r\nhost->req->int_reg = (host->req->int_reg & 1)\r\n| ((host->req->int_reg << 4) & 0xe0);\r\nwritel(TIFM_FIFO_INT_SETALL,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\r\nwritel(TIFM_DMA_RESET, sock->addr + SOCK_DMA_CONTROL);\r\nif (host->use_dma) {\r\ntifm_unmap_sg(sock, &host->req->sg, 1,\r\nhost->req->data_dir == READ\r\n? PCI_DMA_FROMDEVICE\r\n: PCI_DMA_TODEVICE);\r\n}\r\nwritel((~TIFM_CTRL_LED) & readl(sock->addr + SOCK_CONTROL),\r\nsock->addr + SOCK_CONTROL);\r\ndev_dbg(&sock->dev, "TPC complete\n");\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\n} while (!rc && tifm_ms_issue_cmd(host));\r\n}\r\nstatic int tifm_ms_check_status(struct tifm_ms *host)\r\n{\r\nif (!host->req->error) {\r\nif (!(host->cmd_flags & CMD_READY))\r\nreturn 1;\r\nif (!(host->cmd_flags & FIFO_READY))\r\nreturn 1;\r\nif (host->req->need_card_int\r\n&& !(host->cmd_flags & CARD_INT))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tifm_ms_data_event(struct tifm_dev *sock)\r\n{\r\nstruct tifm_ms *host;\r\nunsigned int fifo_status = 0, host_status = 0;\r\nint rc = 1;\r\nspin_lock(&sock->lock);\r\nhost = memstick_priv((struct memstick_host *)tifm_get_drvdata(sock));\r\nfifo_status = readl(sock->addr + SOCK_DMA_FIFO_STATUS);\r\nhost_status = readl(sock->addr + SOCK_MS_STATUS);\r\ndev_dbg(&sock->dev,\r\n"data event: fifo_status %x, host_status %x, flags %x\n",\r\nfifo_status, host_status, host->cmd_flags);\r\nif (host->req) {\r\nif (host->use_dma && (fifo_status & 1)) {\r\nhost->cmd_flags |= FIFO_READY;\r\nrc = tifm_ms_check_status(host);\r\n}\r\nif (!host->use_dma && (fifo_status & TIFM_FIFO_MORE)) {\r\nif (!tifm_ms_transfer_data(host)) {\r\nhost->cmd_flags |= FIFO_READY;\r\nrc = tifm_ms_check_status(host);\r\n}\r\n}\r\n}\r\nwritel(fifo_status, sock->addr + SOCK_DMA_FIFO_STATUS);\r\nif (!rc)\r\ntifm_ms_complete_cmd(host);\r\nspin_unlock(&sock->lock);\r\n}\r\nstatic void tifm_ms_card_event(struct tifm_dev *sock)\r\n{\r\nstruct tifm_ms *host;\r\nunsigned int host_status = 0;\r\nint rc = 1;\r\nspin_lock(&sock->lock);\r\nhost = memstick_priv((struct memstick_host *)tifm_get_drvdata(sock));\r\nhost_status = readl(sock->addr + SOCK_MS_STATUS);\r\ndev_dbg(&sock->dev, "host event: host_status %x, flags %x\n",\r\nhost_status, host->cmd_flags);\r\nif (host->req) {\r\nif (host_status & TIFM_MS_STAT_TOE)\r\nhost->req->error = -ETIME;\r\nelse if (host_status & TIFM_MS_STAT_CRC)\r\nhost->req->error = -EILSEQ;\r\nif (host_status & TIFM_MS_STAT_RDY)\r\nhost->cmd_flags |= CMD_READY;\r\nif (host_status & TIFM_MS_STAT_MSINT)\r\nhost->cmd_flags |= CARD_INT;\r\nrc = tifm_ms_check_status(host);\r\n}\r\nwritel(TIFM_MS_SYS_INTCLR | readl(sock->addr + SOCK_MS_SYSTEM),\r\nsock->addr + SOCK_MS_SYSTEM);\r\nif (!rc)\r\ntifm_ms_complete_cmd(host);\r\nspin_unlock(&sock->lock);\r\nreturn;\r\n}\r\nstatic void tifm_ms_req_tasklet(unsigned long data)\r\n{\r\nstruct memstick_host *msh = (struct memstick_host *)data;\r\nstruct tifm_ms *host = memstick_priv(msh);\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&sock->lock, flags);\r\nif (!host->req) {\r\nif (host->eject) {\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\nif (!rc)\r\nhost->req->error = -ETIME;\r\n} while (!rc);\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\nreturn;\r\n}\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\n} while (!rc && tifm_ms_issue_cmd(host));\r\n}\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\n}\r\nstatic void tifm_ms_dummy_submit(struct memstick_host *msh)\r\n{\r\nreturn;\r\n}\r\nstatic void tifm_ms_submit_req(struct memstick_host *msh)\r\n{\r\nstruct tifm_ms *host = memstick_priv(msh);\r\ntasklet_schedule(&host->notify);\r\n}\r\nstatic int tifm_ms_set_param(struct memstick_host *msh,\r\nenum memstick_param param,\r\nint value)\r\n{\r\nstruct tifm_ms *host = memstick_priv(msh);\r\nstruct tifm_dev *sock = host->dev;\r\nswitch (param) {\r\ncase MEMSTICK_POWER:\r\nif (value == MEMSTICK_POWER_ON) {\r\nhost->mode_mask = TIFM_MS_SYS_SRAC | TIFM_MS_SYS_REI;\r\nwritel(TIFM_MS_SYS_RESET, sock->addr + SOCK_MS_SYSTEM);\r\nwritel(TIFM_MS_SYS_FCLR | TIFM_MS_SYS_INTCLR,\r\nsock->addr + SOCK_MS_SYSTEM);\r\nwritel(0xffffffff, sock->addr + SOCK_MS_STATUS);\r\n} else if (value == MEMSTICK_POWER_OFF) {\r\nwritel(TIFM_MS_SYS_FCLR | TIFM_MS_SYS_INTCLR,\r\nsock->addr + SOCK_MS_SYSTEM);\r\nwritel(0xffffffff, sock->addr + SOCK_MS_STATUS);\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase MEMSTICK_INTERFACE:\r\nif (value == MEMSTICK_SERIAL) {\r\nhost->mode_mask = TIFM_MS_SYS_SRAC | TIFM_MS_SYS_REI;\r\nwritel((~TIFM_CTRL_FAST_CLK)\r\n& readl(sock->addr + SOCK_CONTROL),\r\nsock->addr + SOCK_CONTROL);\r\n} else if (value == MEMSTICK_PAR4) {\r\nhost->mode_mask = 0;\r\nwritel(TIFM_CTRL_FAST_CLK\r\n| readl(sock->addr + SOCK_CONTROL),\r\nsock->addr + SOCK_CONTROL);\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\n};\r\nreturn 0;\r\n}\r\nstatic void tifm_ms_abort(unsigned long data)\r\n{\r\nstruct tifm_ms *host = (struct tifm_ms *)data;\r\ndev_dbg(&host->dev->dev, "status %x\n",\r\nreadl(host->dev->addr + SOCK_MS_STATUS));\r\nprintk(KERN_ERR\r\n"%s : card failed to respond for a long period of time "\r\n"(%x, %x)\n",\r\ndev_name(&host->dev->dev), host->req ? host->req->tpc : 0,\r\nhost->cmd_flags);\r\ntifm_eject(host->dev);\r\n}\r\nstatic int tifm_ms_probe(struct tifm_dev *sock)\r\n{\r\nstruct memstick_host *msh;\r\nstruct tifm_ms *host;\r\nint rc = -EIO;\r\nif (!(TIFM_SOCK_STATE_OCCUPIED\r\n& readl(sock->addr + SOCK_PRESENT_STATE))) {\r\nprintk(KERN_WARNING "%s : card gone, unexpectedly\n",\r\ndev_name(&sock->dev));\r\nreturn rc;\r\n}\r\nmsh = memstick_alloc_host(sizeof(struct tifm_ms), &sock->dev);\r\nif (!msh)\r\nreturn -ENOMEM;\r\nhost = memstick_priv(msh);\r\ntifm_set_drvdata(sock, msh);\r\nhost->dev = sock;\r\nhost->timeout_jiffies = msecs_to_jiffies(1000);\r\nsetup_timer(&host->timer, tifm_ms_abort, (unsigned long)host);\r\ntasklet_init(&host->notify, tifm_ms_req_tasklet, (unsigned long)msh);\r\nmsh->request = tifm_ms_submit_req;\r\nmsh->set_param = tifm_ms_set_param;\r\nsock->card_event = tifm_ms_card_event;\r\nsock->data_event = tifm_ms_data_event;\r\nif (tifm_has_ms_pif(sock))\r\nmsh->caps |= MEMSTICK_CAP_PAR4;\r\nrc = memstick_add_host(msh);\r\nif (!rc)\r\nreturn 0;\r\nmemstick_free_host(msh);\r\nreturn rc;\r\n}\r\nstatic void tifm_ms_remove(struct tifm_dev *sock)\r\n{\r\nstruct memstick_host *msh = tifm_get_drvdata(sock);\r\nstruct tifm_ms *host = memstick_priv(msh);\r\nint rc = 0;\r\nunsigned long flags;\r\nmsh->request = tifm_ms_dummy_submit;\r\ntasklet_kill(&host->notify);\r\nspin_lock_irqsave(&sock->lock, flags);\r\nhost->eject = 1;\r\nif (host->req) {\r\ndel_timer(&host->timer);\r\nwritel(TIFM_FIFO_INT_SETALL,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\r\nwritel(TIFM_DMA_RESET, sock->addr + SOCK_DMA_CONTROL);\r\nif (host->use_dma)\r\ntifm_unmap_sg(sock, &host->req->sg, 1,\r\nhost->req->data_dir == READ\r\n? PCI_DMA_TODEVICE\r\n: PCI_DMA_FROMDEVICE);\r\nhost->req->error = -ETIME;\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\nif (!rc)\r\nhost->req->error = -ETIME;\r\n} while (!rc);\r\n}\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\nmemstick_remove_host(msh);\r\nmemstick_free_host(msh);\r\n}\r\nstatic int tifm_ms_suspend(struct tifm_dev *sock, pm_message_t state)\r\n{\r\nstruct memstick_host *msh = tifm_get_drvdata(sock);\r\nmemstick_suspend_host(msh);\r\nreturn 0;\r\n}\r\nstatic int tifm_ms_resume(struct tifm_dev *sock)\r\n{\r\nstruct memstick_host *msh = tifm_get_drvdata(sock);\r\nmemstick_resume_host(msh);\r\nreturn 0;\r\n}\r\nstatic int __init tifm_ms_init(void)\r\n{\r\nreturn tifm_register_driver(&tifm_ms_driver);\r\n}\r\nstatic void __exit tifm_ms_exit(void)\r\n{\r\ntifm_unregister_driver(&tifm_ms_driver);\r\n}
