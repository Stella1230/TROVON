static sense_reason_t\r\nsbc_emulate_readcapacity(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nunsigned long long blocks_long = dev->transport->get_blocks(dev);\r\nunsigned char *rbuf;\r\nunsigned char buf[8];\r\nu32 blocks;\r\nif (!(cdb[8] & 1) && !!(cdb[2] | cdb[3] | cdb[4] | cdb[5]))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nif (blocks_long >= 0x00000000ffffffff)\r\nblocks = 0xffffffff;\r\nelse\r\nblocks = (u32)blocks_long;\r\nbuf[0] = (blocks >> 24) & 0xff;\r\nbuf[1] = (blocks >> 16) & 0xff;\r\nbuf[2] = (blocks >> 8) & 0xff;\r\nbuf[3] = blocks & 0xff;\r\nbuf[4] = (dev->dev_attrib.block_size >> 24) & 0xff;\r\nbuf[5] = (dev->dev_attrib.block_size >> 16) & 0xff;\r\nbuf[6] = (dev->dev_attrib.block_size >> 8) & 0xff;\r\nbuf[7] = dev->dev_attrib.block_size & 0xff;\r\nrbuf = transport_kmap_data_sg(cmd);\r\nif (rbuf) {\r\nmemcpy(rbuf, buf, min_t(u32, sizeof(buf), cmd->data_length));\r\ntransport_kunmap_data_sg(cmd);\r\n}\r\ntarget_complete_cmd_with_length(cmd, GOOD, 8);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nsbc_emulate_readcapacity_16(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *sess = cmd->se_sess;\r\nint pi_prot_type = dev->dev_attrib.pi_prot_type;\r\nunsigned char *rbuf;\r\nunsigned char buf[32];\r\nunsigned long long blocks = dev->transport->get_blocks(dev);\r\nmemset(buf, 0, sizeof(buf));\r\nbuf[0] = (blocks >> 56) & 0xff;\r\nbuf[1] = (blocks >> 48) & 0xff;\r\nbuf[2] = (blocks >> 40) & 0xff;\r\nbuf[3] = (blocks >> 32) & 0xff;\r\nbuf[4] = (blocks >> 24) & 0xff;\r\nbuf[5] = (blocks >> 16) & 0xff;\r\nbuf[6] = (blocks >> 8) & 0xff;\r\nbuf[7] = blocks & 0xff;\r\nbuf[8] = (dev->dev_attrib.block_size >> 24) & 0xff;\r\nbuf[9] = (dev->dev_attrib.block_size >> 16) & 0xff;\r\nbuf[10] = (dev->dev_attrib.block_size >> 8) & 0xff;\r\nbuf[11] = dev->dev_attrib.block_size & 0xff;\r\nif (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) {\r\nif (!pi_prot_type)\r\npi_prot_type = sess->sess_prot_type;\r\nif (pi_prot_type)\r\nbuf[12] = (pi_prot_type - 1) << 1 | 0x1;\r\n}\r\nif (dev->transport->get_lbppbe)\r\nbuf[13] = dev->transport->get_lbppbe(dev) & 0x0f;\r\nif (dev->transport->get_alignment_offset_lbas) {\r\nu16 lalba = dev->transport->get_alignment_offset_lbas(dev);\r\nbuf[14] = (lalba >> 8) & 0x3f;\r\nbuf[15] = lalba & 0xff;\r\n}\r\nif (dev->dev_attrib.emulate_tpu || dev->dev_attrib.emulate_tpws) {\r\nbuf[14] |= 0x80;\r\nif (dev->dev_attrib.unmap_zeroes_data)\r\nbuf[14] |= 0x40;\r\n}\r\nrbuf = transport_kmap_data_sg(cmd);\r\nif (rbuf) {\r\nmemcpy(rbuf, buf, min_t(u32, sizeof(buf), cmd->data_length));\r\ntransport_kunmap_data_sg(cmd);\r\n}\r\ntarget_complete_cmd_with_length(cmd, GOOD, 32);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nsbc_emulate_startstop(struct se_cmd *cmd)\r\n{\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nif (!(cdb[1] & 1) || cdb[2] || cdb[3])\r\nreturn TCM_INVALID_CDB_FIELD;\r\nif (cdb[4] >> 4 & 0xf)\r\nreturn TCM_INVALID_CDB_FIELD;\r\nif (!(cdb[4] & 1) || (cdb[4] & 2) || (cdb[4] & 4))\r\nreturn TCM_INVALID_CDB_FIELD;\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nsector_t sbc_get_write_same_sectors(struct se_cmd *cmd)\r\n{\r\nu32 num_blocks;\r\nif (cmd->t_task_cdb[0] == WRITE_SAME)\r\nnum_blocks = get_unaligned_be16(&cmd->t_task_cdb[7]);\r\nelse if (cmd->t_task_cdb[0] == WRITE_SAME_16)\r\nnum_blocks = get_unaligned_be32(&cmd->t_task_cdb[10]);\r\nelse\r\nnum_blocks = get_unaligned_be32(&cmd->t_task_cdb[28]);\r\nif (num_blocks)\r\nreturn num_blocks;\r\nreturn cmd->se_dev->transport->get_blocks(cmd->se_dev) -\r\ncmd->t_task_lba + 1;\r\n}\r\nstatic sense_reason_t\r\nsbc_execute_write_same_unmap(struct se_cmd *cmd)\r\n{\r\nstruct sbc_ops *ops = cmd->protocol_data;\r\nsector_t nolb = sbc_get_write_same_sectors(cmd);\r\nsense_reason_t ret;\r\nif (nolb) {\r\nret = ops->execute_unmap(cmd, cmd->t_task_lba, nolb);\r\nif (ret)\r\nreturn ret;\r\n}\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nsbc_emulate_noop(struct se_cmd *cmd)\r\n{\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn 0;\r\n}\r\nstatic inline u32 sbc_get_size(struct se_cmd *cmd, u32 sectors)\r\n{\r\nreturn cmd->se_dev->dev_attrib.block_size * sectors;\r\n}\r\nstatic inline u32 transport_get_sectors_6(unsigned char *cdb)\r\n{\r\nreturn cdb[4] ? : 256;\r\n}\r\nstatic inline u32 transport_get_sectors_10(unsigned char *cdb)\r\n{\r\nreturn (u32)(cdb[7] << 8) + cdb[8];\r\n}\r\nstatic inline u32 transport_get_sectors_12(unsigned char *cdb)\r\n{\r\nreturn (u32)(cdb[6] << 24) + (cdb[7] << 16) + (cdb[8] << 8) + cdb[9];\r\n}\r\nstatic inline u32 transport_get_sectors_16(unsigned char *cdb)\r\n{\r\nreturn (u32)(cdb[10] << 24) + (cdb[11] << 16) +\r\n(cdb[12] << 8) + cdb[13];\r\n}\r\nstatic inline u32 transport_get_sectors_32(unsigned char *cdb)\r\n{\r\nreturn (u32)(cdb[28] << 24) + (cdb[29] << 16) +\r\n(cdb[30] << 8) + cdb[31];\r\n}\r\nstatic inline u32 transport_lba_21(unsigned char *cdb)\r\n{\r\nreturn ((cdb[1] & 0x1f) << 16) | (cdb[2] << 8) | cdb[3];\r\n}\r\nstatic inline u32 transport_lba_32(unsigned char *cdb)\r\n{\r\nreturn (cdb[2] << 24) | (cdb[3] << 16) | (cdb[4] << 8) | cdb[5];\r\n}\r\nstatic inline unsigned long long transport_lba_64(unsigned char *cdb)\r\n{\r\nunsigned int __v1, __v2;\r\n__v1 = (cdb[2] << 24) | (cdb[3] << 16) | (cdb[4] << 8) | cdb[5];\r\n__v2 = (cdb[6] << 24) | (cdb[7] << 16) | (cdb[8] << 8) | cdb[9];\r\nreturn ((unsigned long long)__v2) | (unsigned long long)__v1 << 32;\r\n}\r\nstatic inline unsigned long long transport_lba_64_ext(unsigned char *cdb)\r\n{\r\nunsigned int __v1, __v2;\r\n__v1 = (cdb[12] << 24) | (cdb[13] << 16) | (cdb[14] << 8) | cdb[15];\r\n__v2 = (cdb[16] << 24) | (cdb[17] << 16) | (cdb[18] << 8) | cdb[19];\r\nreturn ((unsigned long long)__v2) | (unsigned long long)__v1 << 32;\r\n}\r\nstatic sense_reason_t\r\nsbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *ops)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nsector_t end_lba = dev->transport->get_blocks(dev) + 1;\r\nunsigned int sectors = sbc_get_write_same_sectors(cmd);\r\nsense_reason_t ret;\r\nif ((flags[0] & 0x04) || (flags[0] & 0x02)) {\r\npr_err("WRITE_SAME PBDATA and LBDATA"\r\n" bits not supported for Block Discard"\r\n" Emulation\n");\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nif (sectors > cmd->se_dev->dev_attrib.max_write_same_len) {\r\npr_warn("WRITE_SAME sectors: %u exceeds max_write_same_len: %u\n",\r\nsectors, cmd->se_dev->dev_attrib.max_write_same_len);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (((cmd->t_task_lba + sectors) < cmd->t_task_lba) ||\r\n((cmd->t_task_lba + sectors) > end_lba)) {\r\npr_err("WRITE_SAME exceeds last lba %llu (lba %llu, sectors %u)\n",\r\n(unsigned long long)end_lba, cmd->t_task_lba, sectors);\r\nreturn TCM_ADDRESS_OUT_OF_RANGE;\r\n}\r\nif (flags[0] & 0x10) {\r\npr_warn("WRITE SAME with ANCHOR not supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (flags[0] & 0x08) {\r\nif (!ops->execute_unmap)\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\nif (!dev->dev_attrib.emulate_tpws) {\r\npr_err("Got WRITE_SAME w/ UNMAP=1, but backend device"\r\n" has emulate_tpws disabled\n");\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\ncmd->execute_cmd = sbc_execute_write_same_unmap;\r\nreturn 0;\r\n}\r\nif (!ops->execute_write_same)\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\nret = sbc_check_prot(dev, cmd, &cmd->t_task_cdb[0], sectors, true);\r\nif (ret)\r\nreturn ret;\r\ncmd->execute_cmd = ops->execute_write_same;\r\nreturn 0;\r\n}\r\nstatic sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success,\r\nint *post_ret)\r\n{\r\nunsigned char *buf, *addr;\r\nstruct scatterlist *sg;\r\nunsigned int offset;\r\nsense_reason_t ret = TCM_NO_SENSE;\r\nint i, count;\r\nbuf = kmalloc(cmd->data_length, GFP_KERNEL);\r\nif (!buf) {\r\npr_err("Unable to allocate xor_callback buf\n");\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\nsg_copy_to_buffer(cmd->t_data_sg,\r\ncmd->t_data_nents,\r\nbuf,\r\ncmd->data_length);\r\noffset = 0;\r\nfor_each_sg(cmd->t_bidi_data_sg, sg, cmd->t_bidi_data_nents, count) {\r\naddr = kmap_atomic(sg_page(sg));\r\nif (!addr) {\r\nret = TCM_OUT_OF_RESOURCES;\r\ngoto out;\r\n}\r\nfor (i = 0; i < sg->length; i++)\r\n*(addr + sg->offset + i) ^= *(buf + offset + i);\r\noffset += sg->length;\r\nkunmap_atomic(addr);\r\n}\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic sense_reason_t\r\nsbc_execute_rw(struct se_cmd *cmd)\r\n{\r\nstruct sbc_ops *ops = cmd->protocol_data;\r\nreturn ops->execute_rw(cmd, cmd->t_data_sg, cmd->t_data_nents,\r\ncmd->data_direction);\r\n}\r\nstatic sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success,\r\nint *post_ret)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nspin_lock_irq(&cmd->t_state_lock);\r\nif ((cmd->transport_state & CMD_T_SENT) && !cmd->scsi_status) {\r\ncmd->se_cmd_flags |= SCF_COMPARE_AND_WRITE_POST;\r\n*post_ret = 1;\r\n}\r\nspin_unlock_irq(&cmd->t_state_lock);\r\nup(&dev->caw_sem);\r\nreturn TCM_NO_SENSE;\r\n}\r\nstatic sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success,\r\nint *post_ret)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct scatterlist *write_sg = NULL, *sg;\r\nunsigned char *buf = NULL, *addr;\r\nstruct sg_mapping_iter m;\r\nunsigned int offset = 0, len;\r\nunsigned int nlbas = cmd->t_task_nolb;\r\nunsigned int block_size = dev->dev_attrib.block_size;\r\nunsigned int compare_len = (nlbas * block_size);\r\nsense_reason_t ret = TCM_NO_SENSE;\r\nint rc, i;\r\nif (!success && (!cmd->t_data_sg || !cmd->t_bidi_data_sg))\r\nreturn TCM_NO_SENSE;\r\nif (!cmd->data_length)\r\ngoto out;\r\nif (cmd->scsi_status) {\r\npr_err("compare_and_write_callback: non zero scsi_status:"\r\n" 0x%02x\n", cmd->scsi_status);\r\ngoto out;\r\n}\r\nbuf = kzalloc(cmd->data_length, GFP_KERNEL);\r\nif (!buf) {\r\npr_err("Unable to allocate compare_and_write buf\n");\r\nret = TCM_OUT_OF_RESOURCES;\r\ngoto out;\r\n}\r\nwrite_sg = kmalloc(sizeof(struct scatterlist) * cmd->t_data_nents,\r\nGFP_KERNEL);\r\nif (!write_sg) {\r\npr_err("Unable to allocate compare_and_write sg\n");\r\nret = TCM_OUT_OF_RESOURCES;\r\ngoto out;\r\n}\r\nsg_init_table(write_sg, cmd->t_data_nents);\r\nrc = sg_copy_to_buffer(cmd->t_data_sg, cmd->t_data_nents, buf,\r\ncmd->data_length);\r\nif (!rc) {\r\npr_err("sg_copy_to_buffer() failed for compare_and_write\n");\r\nret = TCM_OUT_OF_RESOURCES;\r\ngoto out;\r\n}\r\nfor_each_sg(cmd->t_bidi_data_sg, sg, cmd->t_bidi_data_nents, i) {\r\naddr = (unsigned char *)kmap_atomic(sg_page(sg));\r\nif (!addr) {\r\nret = TCM_OUT_OF_RESOURCES;\r\ngoto out;\r\n}\r\nlen = min(sg->length, compare_len);\r\nif (memcmp(addr, buf + offset, len)) {\r\npr_warn("Detected MISCOMPARE for addr: %p buf: %p\n",\r\naddr, buf + offset);\r\nkunmap_atomic(addr);\r\ngoto miscompare;\r\n}\r\nkunmap_atomic(addr);\r\noffset += len;\r\ncompare_len -= len;\r\nif (!compare_len)\r\nbreak;\r\n}\r\ni = 0;\r\nlen = cmd->t_task_nolb * block_size;\r\nsg_miter_start(&m, cmd->t_data_sg, cmd->t_data_nents, SG_MITER_TO_SG);\r\nwhile (len) {\r\nsg_miter_next(&m);\r\nif (block_size < PAGE_SIZE) {\r\nsg_set_page(&write_sg[i], m.page, block_size,\r\nm.piter.sg->offset + block_size);\r\n} else {\r\nsg_miter_next(&m);\r\nsg_set_page(&write_sg[i], m.page, block_size,\r\nm.piter.sg->offset);\r\n}\r\nlen -= block_size;\r\ni++;\r\n}\r\nsg_miter_stop(&m);\r\ncmd->t_data_sg_orig = cmd->t_data_sg;\r\ncmd->t_data_sg = write_sg;\r\ncmd->t_data_nents_orig = cmd->t_data_nents;\r\ncmd->t_data_nents = 1;\r\ncmd->sam_task_attr = TCM_HEAD_TAG;\r\ncmd->transport_complete_callback = compare_and_write_post;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nspin_lock_irq(&cmd->t_state_lock);\r\ncmd->t_state = TRANSPORT_PROCESSING;\r\ncmd->transport_state |= CMD_T_ACTIVE|CMD_T_BUSY|CMD_T_SENT;\r\nspin_unlock_irq(&cmd->t_state_lock);\r\n__target_execute_cmd(cmd, false);\r\nkfree(buf);\r\nreturn ret;\r\nmiscompare:\r\npr_warn("Target/%s: Send MISCOMPARE check condition and sense\n",\r\ndev->transport->name);\r\nret = TCM_MISCOMPARE_VERIFY;\r\nout:\r\nup(&dev->caw_sem);\r\nkfree(write_sg);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic sense_reason_t\r\nsbc_compare_and_write(struct se_cmd *cmd)\r\n{\r\nstruct sbc_ops *ops = cmd->protocol_data;\r\nstruct se_device *dev = cmd->se_dev;\r\nsense_reason_t ret;\r\nint rc;\r\nrc = down_interruptible(&dev->caw_sem);\r\nif (rc != 0) {\r\ncmd->transport_complete_callback = NULL;\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\ncmd->data_length = cmd->t_task_nolb * dev->dev_attrib.block_size;\r\nret = ops->execute_rw(cmd, cmd->t_bidi_data_sg, cmd->t_bidi_data_nents,\r\nDMA_FROM_DEVICE);\r\nif (ret) {\r\ncmd->transport_complete_callback = NULL;\r\nup(&dev->caw_sem);\r\nreturn ret;\r\n}\r\nreturn TCM_NO_SENSE;\r\n}\r\nstatic int\r\nsbc_set_prot_op_checks(u8 protect, bool fabric_prot, enum target_prot_type prot_type,\r\nbool is_write, struct se_cmd *cmd)\r\n{\r\nif (is_write) {\r\ncmd->prot_op = fabric_prot ? TARGET_PROT_DOUT_STRIP :\r\nprotect ? TARGET_PROT_DOUT_PASS :\r\nTARGET_PROT_DOUT_INSERT;\r\nswitch (protect) {\r\ncase 0x0:\r\ncase 0x3:\r\ncmd->prot_checks = 0;\r\nbreak;\r\ncase 0x1:\r\ncase 0x5:\r\ncmd->prot_checks = TARGET_DIF_CHECK_GUARD;\r\nif (prot_type == TARGET_DIF_TYPE1_PROT)\r\ncmd->prot_checks |= TARGET_DIF_CHECK_REFTAG;\r\nbreak;\r\ncase 0x2:\r\nif (prot_type == TARGET_DIF_TYPE1_PROT)\r\ncmd->prot_checks = TARGET_DIF_CHECK_REFTAG;\r\nbreak;\r\ncase 0x4:\r\ncmd->prot_checks = TARGET_DIF_CHECK_GUARD;\r\nbreak;\r\ndefault:\r\npr_err("Unsupported protect field %d\n", protect);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ncmd->prot_op = fabric_prot ? TARGET_PROT_DIN_INSERT :\r\nprotect ? TARGET_PROT_DIN_PASS :\r\nTARGET_PROT_DIN_STRIP;\r\nswitch (protect) {\r\ncase 0x0:\r\ncase 0x1:\r\ncase 0x5:\r\ncmd->prot_checks = TARGET_DIF_CHECK_GUARD;\r\nif (prot_type == TARGET_DIF_TYPE1_PROT)\r\ncmd->prot_checks |= TARGET_DIF_CHECK_REFTAG;\r\nbreak;\r\ncase 0x2:\r\nif (prot_type == TARGET_DIF_TYPE1_PROT)\r\ncmd->prot_checks = TARGET_DIF_CHECK_REFTAG;\r\nbreak;\r\ncase 0x3:\r\ncmd->prot_checks = 0;\r\nbreak;\r\ncase 0x4:\r\ncmd->prot_checks = TARGET_DIF_CHECK_GUARD;\r\nbreak;\r\ndefault:\r\npr_err("Unsupported protect field %d\n", protect);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\nsbc_check_prot(struct se_device *dev, struct se_cmd *cmd, unsigned char *cdb,\r\nu32 sectors, bool is_write)\r\n{\r\nu8 protect = cdb[1] >> 5;\r\nint sp_ops = cmd->se_sess->sup_prot_ops;\r\nint pi_prot_type = dev->dev_attrib.pi_prot_type;\r\nbool fabric_prot = false;\r\nif (!cmd->t_prot_sg || !cmd->t_prot_nents) {\r\nif (unlikely(protect &&\r\n!dev->dev_attrib.pi_prot_type && !cmd->se_sess->sess_prot_type)) {\r\npr_err("CDB contains protect bit, but device + fabric does"\r\n" not advertise PROTECT=1 feature bit\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (cmd->prot_pto)\r\nreturn TCM_NO_SENSE;\r\n}\r\nswitch (dev->dev_attrib.pi_prot_type) {\r\ncase TARGET_DIF_TYPE3_PROT:\r\ncmd->reftag_seed = 0xffffffff;\r\nbreak;\r\ncase TARGET_DIF_TYPE2_PROT:\r\nif (protect)\r\nreturn TCM_INVALID_CDB_FIELD;\r\ncmd->reftag_seed = cmd->t_task_lba;\r\nbreak;\r\ncase TARGET_DIF_TYPE1_PROT:\r\ncmd->reftag_seed = cmd->t_task_lba;\r\nbreak;\r\ncase TARGET_DIF_TYPE0_PROT:\r\nfabric_prot = is_write ?\r\n!!(sp_ops & (TARGET_PROT_DOUT_PASS | TARGET_PROT_DOUT_STRIP)) :\r\n!!(sp_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DIN_INSERT));\r\nif (fabric_prot && cmd->se_sess->sess_prot_type) {\r\npi_prot_type = cmd->se_sess->sess_prot_type;\r\nbreak;\r\n}\r\nif (!protect)\r\nreturn TCM_NO_SENSE;\r\ndefault:\r\npr_err("Unable to determine pi_prot_type for CDB: 0x%02x "\r\n"PROTECT: 0x%02x\n", cdb[0], protect);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (sbc_set_prot_op_checks(protect, fabric_prot, pi_prot_type, is_write, cmd))\r\nreturn TCM_INVALID_CDB_FIELD;\r\ncmd->prot_type = pi_prot_type;\r\ncmd->prot_length = dev->prot_length * sectors;\r\nif (protect)\r\ncmd->data_length = sectors * dev->dev_attrib.block_size;\r\npr_debug("%s: prot_type=%d, data_length=%d, prot_length=%d "\r\n"prot_op=%d prot_checks=%d\n",\r\n__func__, cmd->prot_type, cmd->data_length, cmd->prot_length,\r\ncmd->prot_op, cmd->prot_checks);\r\nreturn TCM_NO_SENSE;\r\n}\r\nstatic int\r\nsbc_check_dpofua(struct se_device *dev, struct se_cmd *cmd, unsigned char *cdb)\r\n{\r\nif (cdb[1] & 0x10) {\r\nif (!target_check_fua(dev)) {\r\npr_err("Got CDB: 0x%02x with DPO bit set, but device"\r\n" does not advertise support for DPO\n", cdb[0]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (cdb[1] & 0x8) {\r\nif (!target_check_fua(dev)) {\r\npr_err("Got CDB: 0x%02x with FUA bit set, but device"\r\n" does not advertise support for FUA write\n",\r\ncdb[0]);\r\nreturn -EINVAL;\r\n}\r\ncmd->se_cmd_flags |= SCF_FUA;\r\n}\r\nreturn 0;\r\n}\r\nsense_reason_t\r\nsbc_parse_cdb(struct se_cmd *cmd, struct sbc_ops *ops)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nunsigned int size;\r\nu32 sectors = 0;\r\nsense_reason_t ret;\r\ncmd->protocol_data = ops;\r\nswitch (cdb[0]) {\r\ncase READ_6:\r\nsectors = transport_get_sectors_6(cdb);\r\ncmd->t_task_lba = transport_lba_21(cdb);\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nbreak;\r\ncase READ_10:\r\nsectors = transport_get_sectors_10(cdb);\r\ncmd->t_task_lba = transport_lba_32(cdb);\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nret = sbc_check_prot(dev, cmd, cdb, sectors, false);\r\nif (ret)\r\nreturn ret;\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nbreak;\r\ncase READ_12:\r\nsectors = transport_get_sectors_12(cdb);\r\ncmd->t_task_lba = transport_lba_32(cdb);\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nret = sbc_check_prot(dev, cmd, cdb, sectors, false);\r\nif (ret)\r\nreturn ret;\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nbreak;\r\ncase READ_16:\r\nsectors = transport_get_sectors_16(cdb);\r\ncmd->t_task_lba = transport_lba_64(cdb);\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nret = sbc_check_prot(dev, cmd, cdb, sectors, false);\r\nif (ret)\r\nreturn ret;\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nbreak;\r\ncase WRITE_6:\r\nsectors = transport_get_sectors_6(cdb);\r\ncmd->t_task_lba = transport_lba_21(cdb);\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nbreak;\r\ncase WRITE_10:\r\ncase WRITE_VERIFY:\r\nsectors = transport_get_sectors_10(cdb);\r\ncmd->t_task_lba = transport_lba_32(cdb);\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nret = sbc_check_prot(dev, cmd, cdb, sectors, true);\r\nif (ret)\r\nreturn ret;\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nbreak;\r\ncase WRITE_12:\r\nsectors = transport_get_sectors_12(cdb);\r\ncmd->t_task_lba = transport_lba_32(cdb);\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nret = sbc_check_prot(dev, cmd, cdb, sectors, true);\r\nif (ret)\r\nreturn ret;\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nbreak;\r\ncase WRITE_16:\r\nsectors = transport_get_sectors_16(cdb);\r\ncmd->t_task_lba = transport_lba_64(cdb);\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nret = sbc_check_prot(dev, cmd, cdb, sectors, true);\r\nif (ret)\r\nreturn ret;\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\nbreak;\r\ncase XDWRITEREAD_10:\r\nif (cmd->data_direction != DMA_TO_DEVICE ||\r\n!(cmd->se_cmd_flags & SCF_BIDI))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nsectors = transport_get_sectors_10(cdb);\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\ncmd->t_task_lba = transport_lba_32(cdb);\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\ncmd->transport_complete_callback = &xdreadwrite_callback;\r\nbreak;\r\ncase VARIABLE_LENGTH_CMD:\r\n{\r\nu16 service_action = get_unaligned_be16(&cdb[8]);\r\nswitch (service_action) {\r\ncase XDWRITEREAD_32:\r\nsectors = transport_get_sectors_32(cdb);\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\ncmd->t_task_lba = transport_lba_64_ext(cdb);\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\ncmd->execute_cmd = sbc_execute_rw;\r\ncmd->transport_complete_callback = &xdreadwrite_callback;\r\nbreak;\r\ncase WRITE_SAME_32:\r\nsectors = transport_get_sectors_32(cdb);\r\nif (!sectors) {\r\npr_err("WSNZ=1, WRITE_SAME w/sectors=0 not"\r\n" supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nsize = sbc_get_size(cmd, 1);\r\ncmd->t_task_lba = get_unaligned_be64(&cdb[12]);\r\nret = sbc_setup_write_same(cmd, &cdb[10], ops);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\npr_err("VARIABLE_LENGTH_CMD service action"\r\n" 0x%04x not supported\n", service_action);\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nbreak;\r\n}\r\ncase COMPARE_AND_WRITE:\r\nsectors = cdb[13];\r\nif (sectors > 1) {\r\npr_err("COMPARE_AND_WRITE contains NoLB: %u greater"\r\n" than 1\n", sectors);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (sbc_check_dpofua(dev, cmd, cdb))\r\nreturn TCM_INVALID_CDB_FIELD;\r\nsize = 2 * sbc_get_size(cmd, sectors);\r\ncmd->t_task_lba = get_unaligned_be64(&cdb[2]);\r\ncmd->t_task_nolb = sectors;\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB | SCF_COMPARE_AND_WRITE;\r\ncmd->execute_cmd = sbc_compare_and_write;\r\ncmd->transport_complete_callback = compare_and_write_callback;\r\nbreak;\r\ncase READ_CAPACITY:\r\nsize = READ_CAP_LEN;\r\ncmd->execute_cmd = sbc_emulate_readcapacity;\r\nbreak;\r\ncase SERVICE_ACTION_IN_16:\r\nswitch (cmd->t_task_cdb[1] & 0x1f) {\r\ncase SAI_READ_CAPACITY_16:\r\ncmd->execute_cmd = sbc_emulate_readcapacity_16;\r\nbreak;\r\ncase SAI_REPORT_REFERRALS:\r\ncmd->execute_cmd = target_emulate_report_referrals;\r\nbreak;\r\ndefault:\r\npr_err("Unsupported SA: 0x%02x\n",\r\ncmd->t_task_cdb[1] & 0x1f);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nsize = (cdb[10] << 24) | (cdb[11] << 16) |\r\n(cdb[12] << 8) | cdb[13];\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\ncase SYNCHRONIZE_CACHE_16:\r\nif (cdb[0] == SYNCHRONIZE_CACHE) {\r\nsectors = transport_get_sectors_10(cdb);\r\ncmd->t_task_lba = transport_lba_32(cdb);\r\n} else {\r\nsectors = transport_get_sectors_16(cdb);\r\ncmd->t_task_lba = transport_lba_64(cdb);\r\n}\r\nif (ops->execute_sync_cache) {\r\ncmd->execute_cmd = ops->execute_sync_cache;\r\ngoto check_lba;\r\n}\r\nsize = 0;\r\ncmd->execute_cmd = sbc_emulate_noop;\r\nbreak;\r\ncase UNMAP:\r\nif (!ops->execute_unmap)\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\nif (!dev->dev_attrib.emulate_tpu) {\r\npr_err("Got UNMAP, but backend device has"\r\n" emulate_tpu disabled\n");\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nsize = get_unaligned_be16(&cdb[7]);\r\ncmd->execute_cmd = sbc_execute_unmap;\r\nbreak;\r\ncase WRITE_SAME_16:\r\nsectors = transport_get_sectors_16(cdb);\r\nif (!sectors) {\r\npr_err("WSNZ=1, WRITE_SAME w/sectors=0 not supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nsize = sbc_get_size(cmd, 1);\r\ncmd->t_task_lba = get_unaligned_be64(&cdb[2]);\r\nret = sbc_setup_write_same(cmd, &cdb[1], ops);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase WRITE_SAME:\r\nsectors = transport_get_sectors_10(cdb);\r\nif (!sectors) {\r\npr_err("WSNZ=1, WRITE_SAME w/sectors=0 not supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nsize = sbc_get_size(cmd, 1);\r\ncmd->t_task_lba = get_unaligned_be32(&cdb[2]);\r\nret = sbc_setup_write_same(cmd, &cdb[1], ops);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase VERIFY:\r\nsize = 0;\r\nsectors = transport_get_sectors_10(cdb);\r\ncmd->t_task_lba = transport_lba_32(cdb);\r\ncmd->execute_cmd = sbc_emulate_noop;\r\ngoto check_lba;\r\ncase REZERO_UNIT:\r\ncase SEEK_6:\r\ncase SEEK_10:\r\nsize = 0;\r\ncmd->execute_cmd = sbc_emulate_noop;\r\nbreak;\r\ncase START_STOP:\r\nsize = 0;\r\ncmd->execute_cmd = sbc_emulate_startstop;\r\nbreak;\r\ndefault:\r\nret = spc_parse_cdb(cmd, &size);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!cmd->execute_cmd)\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\nif (cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) {\r\nunsigned long long end_lba;\r\ncheck_lba:\r\nend_lba = dev->transport->get_blocks(dev) + 1;\r\nif (((cmd->t_task_lba + sectors) < cmd->t_task_lba) ||\r\n((cmd->t_task_lba + sectors) > end_lba)) {\r\npr_err("cmd exceeds last lba %llu "\r\n"(lba %llu, sectors %u)\n",\r\nend_lba, cmd->t_task_lba, sectors);\r\nreturn TCM_ADDRESS_OUT_OF_RANGE;\r\n}\r\nif (!(cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE))\r\nsize = sbc_get_size(cmd, sectors);\r\n}\r\nreturn target_cmd_size_check(cmd, size);\r\n}\r\nu32 sbc_get_device_type(struct se_device *dev)\r\n{\r\nreturn TYPE_DISK;\r\n}\r\nstatic sense_reason_t\r\nsbc_execute_unmap(struct se_cmd *cmd)\r\n{\r\nstruct sbc_ops *ops = cmd->protocol_data;\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned char *buf, *ptr = NULL;\r\nsector_t lba;\r\nint size;\r\nu32 range;\r\nsense_reason_t ret = 0;\r\nint dl, bd_dl;\r\nif (cmd->t_task_cdb[1])\r\nreturn TCM_INVALID_CDB_FIELD;\r\nif (cmd->data_length == 0) {\r\ntarget_complete_cmd(cmd, SAM_STAT_GOOD);\r\nreturn 0;\r\n}\r\nif (cmd->data_length < 8) {\r\npr_warn("UNMAP parameter list length %u too small\n",\r\ncmd->data_length);\r\nreturn TCM_PARAMETER_LIST_LENGTH_ERROR;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ndl = get_unaligned_be16(&buf[0]);\r\nbd_dl = get_unaligned_be16(&buf[2]);\r\nsize = cmd->data_length - 8;\r\nif (bd_dl > size)\r\npr_warn("UNMAP parameter list length %u too small, ignoring bd_dl %u\n",\r\ncmd->data_length, bd_dl);\r\nelse\r\nsize = bd_dl;\r\nif (size / 16 > dev->dev_attrib.max_unmap_block_desc_count) {\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto err;\r\n}\r\nptr = &buf[8];\r\npr_debug("UNMAP: Sub: %s Using dl: %u bd_dl: %u size: %u"\r\n" ptr: %p\n", dev->transport->name, dl, bd_dl, size, ptr);\r\nwhile (size >= 16) {\r\nlba = get_unaligned_be64(&ptr[0]);\r\nrange = get_unaligned_be32(&ptr[8]);\r\npr_debug("UNMAP: Using lba: %llu and range: %u\n",\r\n(unsigned long long)lba, range);\r\nif (range > dev->dev_attrib.max_unmap_lba_count) {\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto err;\r\n}\r\nif (lba + range > dev->transport->get_blocks(dev) + 1) {\r\nret = TCM_ADDRESS_OUT_OF_RANGE;\r\ngoto err;\r\n}\r\nret = ops->execute_unmap(cmd, lba, range);\r\nif (ret)\r\ngoto err;\r\nptr += 16;\r\nsize -= 16;\r\n}\r\nerr:\r\ntransport_kunmap_data_sg(cmd);\r\nif (!ret)\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn ret;\r\n}\r\nvoid\r\nsbc_dif_generate(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct t10_pi_tuple *sdt;\r\nstruct scatterlist *dsg = cmd->t_data_sg, *psg;\r\nsector_t sector = cmd->t_task_lba;\r\nvoid *daddr, *paddr;\r\nint i, j, offset = 0;\r\nunsigned int block_size = dev->dev_attrib.block_size;\r\nfor_each_sg(cmd->t_prot_sg, psg, cmd->t_prot_nents, i) {\r\npaddr = kmap_atomic(sg_page(psg)) + psg->offset;\r\ndaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\r\nfor (j = 0; j < psg->length;\r\nj += sizeof(*sdt)) {\r\n__u16 crc;\r\nunsigned int avail;\r\nif (offset >= dsg->length) {\r\noffset -= dsg->length;\r\nkunmap_atomic(daddr - dsg->offset);\r\ndsg = sg_next(dsg);\r\nif (!dsg) {\r\nkunmap_atomic(paddr - psg->offset);\r\nreturn;\r\n}\r\ndaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\r\n}\r\nsdt = paddr + j;\r\navail = min(block_size, dsg->length - offset);\r\ncrc = crc_t10dif(daddr + offset, avail);\r\nif (avail < block_size) {\r\nkunmap_atomic(daddr - dsg->offset);\r\ndsg = sg_next(dsg);\r\nif (!dsg) {\r\nkunmap_atomic(paddr - psg->offset);\r\nreturn;\r\n}\r\ndaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\r\noffset = block_size - avail;\r\ncrc = crc_t10dif_update(crc, daddr, offset);\r\n} else {\r\noffset += block_size;\r\n}\r\nsdt->guard_tag = cpu_to_be16(crc);\r\nif (cmd->prot_type == TARGET_DIF_TYPE1_PROT)\r\nsdt->ref_tag = cpu_to_be32(sector & 0xffffffff);\r\nsdt->app_tag = 0;\r\npr_debug("DIF %s INSERT sector: %llu guard_tag: 0x%04x"\r\n" app_tag: 0x%04x ref_tag: %u\n",\r\n(cmd->data_direction == DMA_TO_DEVICE) ?\r\n"WRITE" : "READ", (unsigned long long)sector,\r\nsdt->guard_tag, sdt->app_tag,\r\nbe32_to_cpu(sdt->ref_tag));\r\nsector++;\r\n}\r\nkunmap_atomic(daddr - dsg->offset);\r\nkunmap_atomic(paddr - psg->offset);\r\n}\r\n}\r\nstatic sense_reason_t\r\nsbc_dif_v1_verify(struct se_cmd *cmd, struct t10_pi_tuple *sdt,\r\n__u16 crc, sector_t sector, unsigned int ei_lba)\r\n{\r\n__be16 csum;\r\nif (!(cmd->prot_checks & TARGET_DIF_CHECK_GUARD))\r\ngoto check_ref;\r\ncsum = cpu_to_be16(crc);\r\nif (sdt->guard_tag != csum) {\r\npr_err("DIFv1 checksum failed on sector %llu guard tag 0x%04x"\r\n" csum 0x%04x\n", (unsigned long long)sector,\r\nbe16_to_cpu(sdt->guard_tag), be16_to_cpu(csum));\r\nreturn TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;\r\n}\r\ncheck_ref:\r\nif (!(cmd->prot_checks & TARGET_DIF_CHECK_REFTAG))\r\nreturn 0;\r\nif (cmd->prot_type == TARGET_DIF_TYPE1_PROT &&\r\nbe32_to_cpu(sdt->ref_tag) != (sector & 0xffffffff)) {\r\npr_err("DIFv1 Type 1 reference failed on sector: %llu tag: 0x%08x"\r\n" sector MSB: 0x%08x\n", (unsigned long long)sector,\r\nbe32_to_cpu(sdt->ref_tag), (u32)(sector & 0xffffffff));\r\nreturn TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;\r\n}\r\nif (cmd->prot_type == TARGET_DIF_TYPE2_PROT &&\r\nbe32_to_cpu(sdt->ref_tag) != ei_lba) {\r\npr_err("DIFv1 Type 2 reference failed on sector: %llu tag: 0x%08x"\r\n" ei_lba: 0x%08x\n", (unsigned long long)sector,\r\nbe32_to_cpu(sdt->ref_tag), ei_lba);\r\nreturn TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;\r\n}\r\nreturn 0;\r\n}\r\nvoid sbc_dif_copy_prot(struct se_cmd *cmd, unsigned int sectors, bool read,\r\nstruct scatterlist *sg, int sg_off)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct scatterlist *psg;\r\nvoid *paddr, *addr;\r\nunsigned int i, len, left;\r\nunsigned int offset = sg_off;\r\nif (!sg)\r\nreturn;\r\nleft = sectors * dev->prot_length;\r\nfor_each_sg(cmd->t_prot_sg, psg, cmd->t_prot_nents, i) {\r\nunsigned int psg_len, copied = 0;\r\npaddr = kmap_atomic(sg_page(psg)) + psg->offset;\r\npsg_len = min(left, psg->length);\r\nwhile (psg_len) {\r\nlen = min(psg_len, sg->length - offset);\r\naddr = kmap_atomic(sg_page(sg)) + sg->offset + offset;\r\nif (read)\r\nmemcpy(paddr + copied, addr, len);\r\nelse\r\nmemcpy(addr, paddr + copied, len);\r\nleft -= len;\r\noffset += len;\r\ncopied += len;\r\npsg_len -= len;\r\nkunmap_atomic(addr - sg->offset - offset);\r\nif (offset >= sg->length) {\r\nsg = sg_next(sg);\r\noffset = 0;\r\n}\r\n}\r\nkunmap_atomic(paddr - psg->offset);\r\n}\r\n}\r\nsense_reason_t\r\nsbc_dif_verify(struct se_cmd *cmd, sector_t start, unsigned int sectors,\r\nunsigned int ei_lba, struct scatterlist *psg, int psg_off)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct t10_pi_tuple *sdt;\r\nstruct scatterlist *dsg = cmd->t_data_sg;\r\nsector_t sector = start;\r\nvoid *daddr, *paddr;\r\nint i;\r\nsense_reason_t rc;\r\nint dsg_off = 0;\r\nunsigned int block_size = dev->dev_attrib.block_size;\r\nfor (; psg && sector < start + sectors; psg = sg_next(psg)) {\r\npaddr = kmap_atomic(sg_page(psg)) + psg->offset;\r\ndaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\r\nfor (i = psg_off; i < psg->length &&\r\nsector < start + sectors;\r\ni += sizeof(*sdt)) {\r\n__u16 crc;\r\nunsigned int avail;\r\nif (dsg_off >= dsg->length) {\r\ndsg_off -= dsg->length;\r\nkunmap_atomic(daddr - dsg->offset);\r\ndsg = sg_next(dsg);\r\nif (!dsg) {\r\nkunmap_atomic(paddr - psg->offset);\r\nreturn 0;\r\n}\r\ndaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\r\n}\r\nsdt = paddr + i;\r\npr_debug("DIF READ sector: %llu guard_tag: 0x%04x"\r\n" app_tag: 0x%04x ref_tag: %u\n",\r\n(unsigned long long)sector, sdt->guard_tag,\r\nsdt->app_tag, be32_to_cpu(sdt->ref_tag));\r\nif (sdt->app_tag == cpu_to_be16(0xffff)) {\r\ndsg_off += block_size;\r\ngoto next;\r\n}\r\navail = min(block_size, dsg->length - dsg_off);\r\ncrc = crc_t10dif(daddr + dsg_off, avail);\r\nif (avail < block_size) {\r\nkunmap_atomic(daddr - dsg->offset);\r\ndsg = sg_next(dsg);\r\nif (!dsg) {\r\nkunmap_atomic(paddr - psg->offset);\r\nreturn 0;\r\n}\r\ndaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\r\ndsg_off = block_size - avail;\r\ncrc = crc_t10dif_update(crc, daddr, dsg_off);\r\n} else {\r\ndsg_off += block_size;\r\n}\r\nrc = sbc_dif_v1_verify(cmd, sdt, crc, sector, ei_lba);\r\nif (rc) {\r\nkunmap_atomic(daddr - dsg->offset);\r\nkunmap_atomic(paddr - psg->offset);\r\ncmd->bad_sector = sector;\r\nreturn rc;\r\n}\r\nnext:\r\nsector++;\r\nei_lba++;\r\n}\r\npsg_off = 0;\r\nkunmap_atomic(daddr - dsg->offset);\r\nkunmap_atomic(paddr - psg->offset);\r\n}\r\nreturn 0;\r\n}
