static int mn88472_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic int mn88472_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct mn88472_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nunsigned int utmp;\r\nif (!dev->active) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = regmap_read(dev->regmap[0], 0x7f, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp & 0x0f) >= 0x09)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\nelse\r\n*status = 0;\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = regmap_read(dev->regmap[2], 0x92, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp & 0x0f) >= 0x0d)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\nelse if ((utmp & 0x0f) >= 0x0a)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\nelse if ((utmp & 0x0f) >= 0x07)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nelse\r\n*status = 0;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = regmap_read(dev->regmap[1], 0x84, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp & 0x0f) >= 0x08)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\nelse\r\n*status = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88472_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct mn88472_dev *dev = i2c_get_clientdata(client);\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nunsigned int utmp;\r\nu32 if_frequency;\r\nu8 buf[3], delivery_system_val, bandwidth_val, *bandwidth_vals_ptr;\r\nu8 reg_bank0_b4_val, reg_bank0_cd_val, reg_bank0_d4_val;\r\nu8 reg_bank0_d6_val;\r\ndev_dbg(&client->dev,\r\n"delivery_system=%u modulation=%u frequency=%u bandwidth_hz=%u symbol_rate=%u inversion=%d stream_id=%d\n",\r\nc->delivery_system, c->modulation, c->frequency,\r\nc->bandwidth_hz, c->symbol_rate, c->inversion, c->stream_id);\r\nif (!dev->active) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\ndelivery_system_val = 0x02;\r\nreg_bank0_b4_val = 0x00;\r\nreg_bank0_cd_val = 0x1f;\r\nreg_bank0_d4_val = 0x0a;\r\nreg_bank0_d6_val = 0x48;\r\nbreak;\r\ncase SYS_DVBT2:\r\ndelivery_system_val = 0x03;\r\nreg_bank0_b4_val = 0xf6;\r\nreg_bank0_cd_val = 0x01;\r\nreg_bank0_d4_val = 0x09;\r\nreg_bank0_d6_val = 0x46;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\ndelivery_system_val = 0x04;\r\nreg_bank0_b4_val = 0x00;\r\nreg_bank0_cd_val = 0x17;\r\nreg_bank0_d4_val = 0x09;\r\nreg_bank0_d6_val = 0x48;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\nswitch (c->bandwidth_hz) {\r\ncase 5000000:\r\nbandwidth_vals_ptr = "\xe5\x99\x9a\x1b\xa9\x1b\xa9";\r\nbandwidth_val = 0x03;\r\nbreak;\r\ncase 6000000:\r\nbandwidth_vals_ptr = "\xbf\x55\x55\x15\x6b\x15\x6b";\r\nbandwidth_val = 0x02;\r\nbreak;\r\ncase 7000000:\r\nbandwidth_vals_ptr = "\xa4\x00\x00\x0f\x2c\x0f\x2c";\r\nbandwidth_val = 0x01;\r\nbreak;\r\ncase 8000000:\r\nbandwidth_vals_ptr = "\x8f\x80\x00\x08\xee\x08\xee";\r\nbandwidth_val = 0x00;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nbandwidth_vals_ptr = NULL;\r\nbandwidth_val = 0x00;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.get_if_frequency) {\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "get_if_frequency=%d\n", if_frequency);\r\n} else {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap[2], 0x00, 0x66);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x02, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x03, delivery_system_val);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x04, bandwidth_val);\r\nif (ret)\r\ngoto err;\r\nutmp = DIV_ROUND_CLOSEST_ULL((u64)if_frequency * 0x1000000, dev->clk);\r\nbuf[0] = (utmp >> 16) & 0xff;\r\nbuf[1] = (utmp >> 8) & 0xff;\r\nbuf[2] = (utmp >> 0) & 0xff;\r\nfor (i = 0; i < 3; i++) {\r\nret = regmap_write(dev->regmap[2], 0x10 + i, buf[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (bandwidth_vals_ptr) {\r\nfor (i = 0; i < 7; i++) {\r\nret = regmap_write(dev->regmap[2], 0x13 + i,\r\nbandwidth_vals_ptr[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\n}\r\nret = regmap_write(dev->regmap[0], 0xb4, reg_bank0_b4_val);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[0], 0xcd, reg_bank0_cd_val);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[0], 0xd4, reg_bank0_d4_val);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[0], 0xd6, reg_bank0_d6_val);\r\nif (ret)\r\ngoto err;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = regmap_write(dev->regmap[0], 0x07, 0x26);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[0], 0x00, 0xba);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[0], 0x01, 0x13);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = regmap_write(dev->regmap[2], 0x2b, 0x13);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x4f, 0x05);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[1], 0xf6, 0x05);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x32, c->stream_id);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = regmap_write(dev->regmap[2], 0xf8, 0x9f);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88472_init(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct mn88472_dev *dev = i2c_get_clientdata(client);\r\nint ret, len, rem;\r\nunsigned int utmp;\r\nconst struct firmware *firmware;\r\nconst char *name = MN88472_FIRMWARE;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_write(dev->regmap[2], 0x05, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x0b, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x0c, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(dev->regmap[0], 0xf5, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (!(utmp & 0x01))\r\ngoto warm;\r\nret = request_firmware(&firmware, name, &client->dev);\r\nif (ret) {\r\ndev_err(&client->dev, "firmware file '%s' not found\n", name);\r\ngoto err;\r\n}\r\ndev_info(&client->dev, "downloading firmware from file '%s'\n", name);\r\nret = regmap_write(dev->regmap[0], 0xf5, 0x03);\r\nif (ret)\r\ngoto err_release_firmware;\r\nfor (rem = firmware->size; rem > 0; rem -= (dev->i2c_write_max - 1)) {\r\nlen = min(dev->i2c_write_max - 1, rem);\r\nret = regmap_bulk_write(dev->regmap[0], 0xf6,\r\n&firmware->data[firmware->size - rem],\r\nlen);\r\nif (ret) {\r\ndev_err(&client->dev, "firmware download failed %d\n",\r\nret);\r\ngoto err_release_firmware;\r\n}\r\n}\r\nret = regmap_read(dev->regmap[0], 0xf8, &utmp);\r\nif (ret)\r\ngoto err_release_firmware;\r\nif (utmp & 0x10) {\r\nret = -EINVAL;\r\ndev_err(&client->dev, "firmware did not run\n");\r\ngoto err_release_firmware;\r\n}\r\nret = regmap_write(dev->regmap[0], 0xf5, 0x00);\r\nif (ret)\r\ngoto err_release_firmware;\r\nrelease_firmware(firmware);\r\nwarm:\r\nswitch (dev->ts_mode) {\r\ncase SERIAL_TS_MODE:\r\nutmp = 0x1d;\r\nbreak;\r\ncase PARALLEL_TS_MODE:\r\nutmp = 0x00;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap[2], 0x08, utmp);\r\nif (ret)\r\ngoto err;\r\nswitch (dev->ts_clk) {\r\ncase VARIABLE_TS_CLOCK:\r\nutmp = 0xe3;\r\nbreak;\r\ncase FIXED_TS_CLOCK:\r\nutmp = 0xe1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap[0], 0xd9, utmp);\r\nif (ret)\r\ngoto err;\r\ndev->active = true;\r\nreturn 0;\r\nerr_release_firmware:\r\nrelease_firmware(firmware);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88472_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct i2c_client *client = fe->demodulator_priv;\r\nstruct mn88472_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_write(dev->regmap[2], 0x0c, 0x30);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x0b, 0x30);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap[2], 0x05, 0x3e);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic struct dvb_frontend *mn88472_get_dvb_frontend(struct i2c_client *client)\r\n{\r\nstruct mn88472_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn &dev->fe;\r\n}\r\nstatic int mn88472_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mn88472_config *pdata = client->dev.platform_data;\r\nstruct mn88472_dev *dev;\r\nint ret;\r\nunsigned int utmp;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n};\r\ndev_dbg(&client->dev, "\n");\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->i2c_write_max = pdata->i2c_wr_max ? pdata->i2c_wr_max : ~0;\r\ndev->clk = pdata->xtal;\r\ndev->ts_mode = pdata->ts_mode;\r\ndev->ts_clk = pdata->ts_clock;\r\ndev->client[0] = client;\r\ndev->regmap[0] = regmap_init_i2c(dev->client[0], &regmap_config);\r\nif (IS_ERR(dev->regmap[0])) {\r\nret = PTR_ERR(dev->regmap[0]);\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(dev->regmap[0], 0xff, &utmp);\r\nif (ret)\r\ngoto err_regmap_0_regmap_exit;\r\ndev_dbg(&client->dev, "chip id=%02x\n", utmp);\r\nif (utmp != 0x02) {\r\nret = -ENODEV;\r\ngoto err_regmap_0_regmap_exit;\r\n}\r\ndev->client[1] = i2c_new_dummy(client->adapter, 0x1a);\r\nif (!dev->client[1]) {\r\nret = -ENODEV;\r\ndev_err(&client->dev, "I2C registration failed\n");\r\nif (ret)\r\ngoto err_regmap_0_regmap_exit;\r\n}\r\ndev->regmap[1] = regmap_init_i2c(dev->client[1], &regmap_config);\r\nif (IS_ERR(dev->regmap[1])) {\r\nret = PTR_ERR(dev->regmap[1]);\r\ngoto err_client_1_i2c_unregister_device;\r\n}\r\ni2c_set_clientdata(dev->client[1], dev);\r\ndev->client[2] = i2c_new_dummy(client->adapter, 0x1c);\r\nif (!dev->client[2]) {\r\nret = -ENODEV;\r\ndev_err(&client->dev, "2nd I2C registration failed\n");\r\nif (ret)\r\ngoto err_regmap_1_regmap_exit;\r\n}\r\ndev->regmap[2] = regmap_init_i2c(dev->client[2], &regmap_config);\r\nif (IS_ERR(dev->regmap[2])) {\r\nret = PTR_ERR(dev->regmap[2]);\r\ngoto err_client_2_i2c_unregister_device;\r\n}\r\ni2c_set_clientdata(dev->client[2], dev);\r\nret = regmap_write(dev->regmap[2], 0x05, 0x3e);\r\nif (ret)\r\ngoto err_regmap_2_regmap_exit;\r\nmemcpy(&dev->fe.ops, &mn88472_ops, sizeof(struct dvb_frontend_ops));\r\ndev->fe.demodulator_priv = client;\r\n*pdata->fe = &dev->fe;\r\ni2c_set_clientdata(client, dev);\r\npdata->get_dvb_frontend = mn88472_get_dvb_frontend;\r\ndev_info(&client->dev, "Panasonic MN88472 successfully identified\n");\r\nreturn 0;\r\nerr_regmap_2_regmap_exit:\r\nregmap_exit(dev->regmap[2]);\r\nerr_client_2_i2c_unregister_device:\r\ni2c_unregister_device(dev->client[2]);\r\nerr_regmap_1_regmap_exit:\r\nregmap_exit(dev->regmap[1]);\r\nerr_client_1_i2c_unregister_device:\r\ni2c_unregister_device(dev->client[1]);\r\nerr_regmap_0_regmap_exit:\r\nregmap_exit(dev->regmap[0]);\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mn88472_remove(struct i2c_client *client)\r\n{\r\nstruct mn88472_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nregmap_exit(dev->regmap[2]);\r\ni2c_unregister_device(dev->client[2]);\r\nregmap_exit(dev->regmap[1]);\r\ni2c_unregister_device(dev->client[1]);\r\nregmap_exit(dev->regmap[0]);\r\nkfree(dev);\r\nreturn 0;\r\n}
