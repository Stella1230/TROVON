static int x1205_get_datetime(struct i2c_client *client, struct rtc_time *tm,\r\nunsigned char reg_base)\r\n{\r\nunsigned char dt_addr[2] = { 0, reg_base };\r\nunsigned char buf[8];\r\nint i;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.len = 2,\r\n.buf = dt_addr\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 8,\r\n.buf = buf\r\n},\r\n};\r\nif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\r\ndev_err(&client->dev, "%s: read error\n", __func__);\r\nreturn -EIO;\r\n}\r\ndev_dbg(&client->dev,\r\n"%s: raw read data - sec=%02x, min=%02x, hr=%02x, "\r\n"mday=%02x, mon=%02x, year=%02x, wday=%02x, y2k=%02x\n",\r\n__func__,\r\nbuf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7]);\r\nif (reg_base < X1205_CCR_BASE)\r\nfor (i = 0; i <= 4; i++)\r\nbuf[i] &= 0x7F;\r\ntm->tm_sec = bcd2bin(buf[CCR_SEC]);\r\ntm->tm_min = bcd2bin(buf[CCR_MIN]);\r\ntm->tm_hour = bcd2bin(buf[CCR_HOUR] & 0x3F);\r\ntm->tm_mday = bcd2bin(buf[CCR_MDAY]);\r\ntm->tm_mon = bcd2bin(buf[CCR_MONTH]) - 1;\r\ntm->tm_year = bcd2bin(buf[CCR_YEAR])\r\n+ (bcd2bin(buf[CCR_Y2K]) * 100) - 1900;\r\ntm->tm_wday = buf[CCR_WDAY];\r\ndev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d, "\r\n"mday=%d, mon=%d, year=%d, wday=%d\n",\r\n__func__,\r\ntm->tm_sec, tm->tm_min, tm->tm_hour,\r\ntm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);\r\nreturn 0;\r\n}\r\nstatic int x1205_get_status(struct i2c_client *client, unsigned char *sr)\r\n{\r\nstatic unsigned char sr_addr[2] = { 0, X1205_REG_SR };\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.len = 2,\r\n.buf = sr_addr\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = sr\r\n},\r\n};\r\nif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\r\ndev_err(&client->dev, "%s: read error\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int x1205_set_datetime(struct i2c_client *client, struct rtc_time *tm,\r\nu8 reg_base, unsigned char alm_enable)\r\n{\r\nint i, xfer;\r\nunsigned char rdata[10] = { 0, reg_base };\r\nunsigned char *buf = rdata + 2;\r\nstatic const unsigned char wel[3] = { 0, X1205_REG_SR,\r\nX1205_SR_WEL };\r\nstatic const unsigned char rwel[3] = { 0, X1205_REG_SR,\r\nX1205_SR_WEL | X1205_SR_RWEL };\r\nstatic const unsigned char diswe[3] = { 0, X1205_REG_SR, 0 };\r\ndev_dbg(&client->dev,\r\n"%s: sec=%d min=%d hour=%d mday=%d mon=%d year=%d wday=%d\n",\r\n__func__, tm->tm_sec, tm->tm_min, tm->tm_hour, tm->tm_mday,\r\ntm->tm_mon, tm->tm_year, tm->tm_wday);\r\nbuf[CCR_SEC] = bin2bcd(tm->tm_sec);\r\nbuf[CCR_MIN] = bin2bcd(tm->tm_min);\r\nbuf[CCR_HOUR] = bin2bcd(tm->tm_hour) | X1205_HR_MIL;\r\nbuf[CCR_MDAY] = bin2bcd(tm->tm_mday);\r\nbuf[CCR_MONTH] = bin2bcd(tm->tm_mon + 1);\r\nbuf[CCR_YEAR] = bin2bcd(tm->tm_year % 100);\r\nbuf[CCR_WDAY] = tm->tm_wday & 0x07;\r\nbuf[CCR_Y2K] = bin2bcd((tm->tm_year + 1900) / 100);\r\nif (reg_base < X1205_CCR_BASE)\r\nfor (i = 0; i <= 4; i++)\r\nbuf[i] |= 0x80;\r\nxfer = i2c_master_send(client, wel, 3);\r\nif (xfer != 3) {\r\ndev_err(&client->dev, "%s: wel - %d\n", __func__, xfer);\r\nreturn -EIO;\r\n}\r\nxfer = i2c_master_send(client, rwel, 3);\r\nif (xfer != 3) {\r\ndev_err(&client->dev, "%s: rwel - %d\n", __func__, xfer);\r\nreturn -EIO;\r\n}\r\nxfer = i2c_master_send(client, rdata, sizeof(rdata));\r\nif (xfer != sizeof(rdata)) {\r\ndev_err(&client->dev,\r\n"%s: result=%d addr=%02x, data=%02x\n",\r\n__func__,\r\nxfer, rdata[1], rdata[2]);\r\nreturn -EIO;\r\n}\r\nif (reg_base < X1205_CCR_BASE) {\r\nunsigned char al0e[3] = { 0, X1205_REG_INT, 0 };\r\nmsleep(10);\r\nxfer = i2c_master_send(client, rwel, 3);\r\nif (xfer != 3) {\r\ndev_err(&client->dev,\r\n"%s: aloe rwel - %d\n",\r\n__func__,\r\nxfer);\r\nreturn -EIO;\r\n}\r\nif (alm_enable)\r\nal0e[2] = X1205_INT_AL0E;\r\nxfer = i2c_master_send(client, al0e, 3);\r\nif (xfer != 3) {\r\ndev_err(&client->dev,\r\n"%s: al0e - %d\n",\r\n__func__,\r\nxfer);\r\nreturn -EIO;\r\n}\r\nmsleep(10);\r\n}\r\nxfer = i2c_master_send(client, diswe, 3);\r\nif (xfer != 3) {\r\ndev_err(&client->dev, "%s: diswe - %d\n", __func__, xfer);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int x1205_fix_osc(struct i2c_client *client)\r\n{\r\nint err;\r\nstruct rtc_time tm;\r\nmemset(&tm, 0, sizeof(tm));\r\nerr = x1205_set_datetime(client, &tm, X1205_CCR_BASE, 0);\r\nif (err < 0)\r\ndev_err(&client->dev, "unable to restart the oscillator\n");\r\nreturn err;\r\n}\r\nstatic int x1205_get_dtrim(struct i2c_client *client, int *trim)\r\n{\r\nunsigned char dtr;\r\nstatic unsigned char dtr_addr[2] = { 0, X1205_REG_DTR };\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.len = 2,\r\n.buf = dtr_addr\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &dtr\r\n},\r\n};\r\nif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\r\ndev_err(&client->dev, "%s: read error\n", __func__);\r\nreturn -EIO;\r\n}\r\ndev_dbg(&client->dev, "%s: raw dtr=%x\n", __func__, dtr);\r\n*trim = 0;\r\nif (dtr & X1205_DTR_DTR0)\r\n*trim += 20;\r\nif (dtr & X1205_DTR_DTR1)\r\n*trim += 10;\r\nif (dtr & X1205_DTR_DTR2)\r\n*trim = -*trim;\r\nreturn 0;\r\n}\r\nstatic int x1205_get_atrim(struct i2c_client *client, int *trim)\r\n{\r\ns8 atr;\r\nstatic unsigned char atr_addr[2] = { 0, X1205_REG_ATR };\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.len = 2,\r\n.buf = atr_addr\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &atr\r\n},\r\n};\r\nif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\r\ndev_err(&client->dev, "%s: read error\n", __func__);\r\nreturn -EIO;\r\n}\r\ndev_dbg(&client->dev, "%s: raw atr=%x\n", __func__, atr);\r\natr = sign_extend32(atr, 5);\r\ndev_dbg(&client->dev, "%s: raw atr=%x (%d)\n", __func__, atr, atr);\r\n*trim = (atr * 250) + 11000;\r\ndev_dbg(&client->dev, "%s: real=%d\n", __func__, *trim);\r\nreturn 0;\r\n}\r\nstatic int x1205_validate_client(struct i2c_client *client)\r\n{\r\nint i, xfer;\r\nstatic const unsigned char probe_zero_pattern[] = {\r\nX1205_REG_SR, 0x18,\r\nX1205_REG_DTR, 0xF8,\r\nX1205_REG_ATR, 0xC0,\r\nX1205_REG_INT, 0x18,\r\nX1205_REG_0, 0xFF,\r\n};\r\nstatic const struct x1205_limit probe_limits_pattern[] = {\r\n{ X1205_REG_Y2K, 0xFF, 19, 20 },\r\n{ X1205_REG_DW, 0xFF, 0, 6 },\r\n{ X1205_REG_YR, 0xFF, 0, 99 },\r\n{ X1205_REG_MO, 0xFF, 0, 12 },\r\n{ X1205_REG_DT, 0xFF, 0, 31 },\r\n{ X1205_REG_HR, 0x7F, 0, 23 },\r\n{ X1205_REG_MN, 0xFF, 0, 59 },\r\n{ X1205_REG_SC, 0xFF, 0, 59 },\r\n{ X1205_REG_Y2K1, 0xFF, 19, 20 },\r\n{ X1205_REG_Y2K0, 0xFF, 19, 20 },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(probe_zero_pattern); i += 2) {\r\nunsigned char buf;\r\nunsigned char addr[2] = { 0, probe_zero_pattern[i] };\r\nstruct i2c_msg msgs[2] = {\r\n{\r\n.addr = client->addr,\r\n.len = 2,\r\n.buf = addr\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &buf\r\n},\r\n};\r\nxfer = i2c_transfer(client->adapter, msgs, 2);\r\nif (xfer != 2) {\r\ndev_err(&client->dev,\r\n"%s: could not read register %x\n",\r\n__func__, probe_zero_pattern[i]);\r\nreturn -EIO;\r\n}\r\nif ((buf & probe_zero_pattern[i+1]) != 0) {\r\ndev_err(&client->dev,\r\n"%s: register=%02x, zero pattern=%d, value=%x\n",\r\n__func__, probe_zero_pattern[i], i, buf);\r\nreturn -ENODEV;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(probe_limits_pattern); i++) {\r\nunsigned char reg, value;\r\nunsigned char addr[2] = { 0, probe_limits_pattern[i].reg };\r\nstruct i2c_msg msgs[2] = {\r\n{\r\n.addr = client->addr,\r\n.len = 2,\r\n.buf = addr\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &reg\r\n},\r\n};\r\nxfer = i2c_transfer(client->adapter, msgs, 2);\r\nif (xfer != 2) {\r\ndev_err(&client->dev,\r\n"%s: could not read register %x\n",\r\n__func__, probe_limits_pattern[i].reg);\r\nreturn -EIO;\r\n}\r\nvalue = bcd2bin(reg & probe_limits_pattern[i].mask);\r\nif (value > probe_limits_pattern[i].max ||\r\nvalue < probe_limits_pattern[i].min) {\r\ndev_dbg(&client->dev,\r\n"%s: register=%x, lim pattern=%d, value=%d\n",\r\n__func__, probe_limits_pattern[i].reg,\r\ni, value);\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int x1205_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nint err;\r\nunsigned char intreg, status;\r\nstatic unsigned char int_addr[2] = { 0, X1205_REG_INT };\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.len = 2,\r\n.buf = int_addr\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &intreg\r\n},\r\n};\r\nif (i2c_transfer(client->adapter, &msgs[0], 2) != 2) {\r\ndev_err(&client->dev, "%s: read error\n", __func__);\r\nreturn -EIO;\r\n}\r\nerr = x1205_get_status(client, &status);\r\nif (err == 0) {\r\nalrm->pending = (status & X1205_SR_AL0) ? 1 : 0;\r\nalrm->enabled = (intreg & X1205_INT_AL0E) ? 1 : 0;\r\nerr = x1205_get_datetime(client, &alrm->time, X1205_ALM0_BASE);\r\n}\r\nreturn err;\r\n}\r\nstatic int x1205_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nreturn x1205_set_datetime(to_i2c_client(dev),\r\n&alrm->time, X1205_ALM0_BASE, alrm->enabled);\r\n}\r\nstatic int x1205_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn x1205_get_datetime(to_i2c_client(dev),\r\ntm, X1205_CCR_BASE);\r\n}\r\nstatic int x1205_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn x1205_set_datetime(to_i2c_client(dev),\r\ntm, X1205_CCR_BASE, 0);\r\n}\r\nstatic int x1205_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nint err, dtrim, atrim;\r\nerr = x1205_get_dtrim(to_i2c_client(dev), &dtrim);\r\nif (!err)\r\nseq_printf(seq, "digital_trim\t: %d ppm\n", dtrim);\r\nerr = x1205_get_atrim(to_i2c_client(dev), &atrim);\r\nif (!err)\r\nseq_printf(seq, "analog_trim\t: %d.%02d pF\n",\r\natrim / 1000, atrim % 1000);\r\nreturn 0;\r\n}\r\nstatic ssize_t x1205_sysfs_show_atrim(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint err, atrim;\r\nerr = x1205_get_atrim(to_i2c_client(dev), &atrim);\r\nif (err)\r\nreturn err;\r\nreturn sprintf(buf, "%d.%02d pF\n", atrim / 1000, atrim % 1000);\r\n}\r\nstatic ssize_t x1205_sysfs_show_dtrim(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint err, dtrim;\r\nerr = x1205_get_dtrim(to_i2c_client(dev), &dtrim);\r\nif (err)\r\nreturn err;\r\nreturn sprintf(buf, "%d ppm\n", dtrim);\r\n}\r\nstatic int x1205_sysfs_register(struct device *dev)\r\n{\r\nint err;\r\nerr = device_create_file(dev, &dev_attr_atrim);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(dev, &dev_attr_dtrim);\r\nif (err)\r\ndevice_remove_file(dev, &dev_attr_atrim);\r\nreturn err;\r\n}\r\nstatic void x1205_sysfs_unregister(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_atrim);\r\ndevice_remove_file(dev, &dev_attr_dtrim);\r\n}\r\nstatic int x1205_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint err = 0;\r\nunsigned char sr;\r\nstruct rtc_device *rtc;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\nif (x1205_validate_client(client) < 0)\r\nreturn -ENODEV;\r\nrtc = devm_rtc_device_register(&client->dev, x1205_driver.driver.name,\r\n&x1205_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\ni2c_set_clientdata(client, rtc);\r\nerr = x1205_get_status(client, &sr);\r\nif (!err) {\r\nif (sr & X1205_SR_RTCF) {\r\ndev_err(&client->dev,\r\n"power failure detected, "\r\n"please set the clock\n");\r\nudelay(50);\r\nx1205_fix_osc(client);\r\n}\r\n} else {\r\ndev_err(&client->dev, "couldn't read status\n");\r\n}\r\nerr = x1205_sysfs_register(&client->dev);\r\nif (err)\r\ndev_err(&client->dev, "Unable to create sysfs entries\n");\r\nreturn 0;\r\n}\r\nstatic int x1205_remove(struct i2c_client *client)\r\n{\r\nx1205_sysfs_unregister(&client->dev);\r\nreturn 0;\r\n}
