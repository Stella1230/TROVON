static int stmpe_keypad_read_data(struct stmpe_keypad *keypad, u8 *data)\r\n{\r\nconst struct stmpe_keypad_variant *variant = keypad->variant;\r\nstruct stmpe *stmpe = keypad->stmpe;\r\nint ret;\r\nint i;\r\nif (variant->auto_increment)\r\nreturn stmpe_block_read(stmpe, STMPE_KPC_DATA_BYTE0,\r\nvariant->num_data, data);\r\nfor (i = 0; i < variant->num_data; i++) {\r\nret = stmpe_reg_read(stmpe, STMPE_KPC_DATA_BYTE0 + i);\r\nif (ret < 0)\r\nreturn ret;\r\ndata[i] = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t stmpe_keypad_irq(int irq, void *dev)\r\n{\r\nstruct stmpe_keypad *keypad = dev;\r\nstruct input_dev *input = keypad->input;\r\nconst struct stmpe_keypad_variant *variant = keypad->variant;\r\nu8 fifo[variant->num_data];\r\nint ret;\r\nint i;\r\nret = stmpe_keypad_read_data(keypad, fifo);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < variant->num_normal_data; i++) {\r\nu8 data = fifo[i];\r\nint row = (data & STMPE_KPC_DATA_ROW) >> 3;\r\nint col = data & STMPE_KPC_DATA_COL;\r\nint code = MATRIX_SCAN_CODE(row, col, STMPE_KEYPAD_ROW_SHIFT);\r\nbool up = data & STMPE_KPC_DATA_UP;\r\nif ((data & STMPE_KPC_DATA_NOKEY_MASK)\r\n== STMPE_KPC_DATA_NOKEY_MASK)\r\ncontinue;\r\ninput_event(input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input, keypad->keymap[code], !up);\r\ninput_sync(input);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stmpe_keypad_altfunc_init(struct stmpe_keypad *keypad)\r\n{\r\nconst struct stmpe_keypad_variant *variant = keypad->variant;\r\nunsigned int col_gpios = variant->col_gpios;\r\nunsigned int row_gpios = variant->row_gpios;\r\nstruct stmpe *stmpe = keypad->stmpe;\r\nu8 pureg = stmpe->regs[STMPE_IDX_GPPUR_LSB];\r\nunsigned int pins = 0;\r\nunsigned int pu_pins = 0;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < variant->max_cols; i++) {\r\nint num = __ffs(col_gpios);\r\nif (keypad->cols & (1 << i)) {\r\npins |= 1 << num;\r\npu_pins |= 1 << num;\r\n}\r\ncol_gpios &= ~(1 << num);\r\n}\r\nfor (i = 0; i < variant->max_rows; i++) {\r\nint num = __ffs(row_gpios);\r\nif (keypad->rows & (1 << i))\r\npins |= 1 << num;\r\nrow_gpios &= ~(1 << num);\r\n}\r\nret = stmpe_set_altfunc(stmpe, pins, STMPE_BLOCK_KEYPAD);\r\nif (ret)\r\nreturn ret;\r\nif (variant->set_pullup) {\r\nu8 val;\r\nret = stmpe_reg_read(stmpe, pureg);\r\nif (ret)\r\nreturn ret;\r\nval = ret & ~pu_pins;\r\nval |= pu_pins;\r\nret = stmpe_reg_write(stmpe, pureg, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stmpe_keypad_chip_init(struct stmpe_keypad *keypad)\r\n{\r\nconst struct stmpe_keypad_variant *variant = keypad->variant;\r\nstruct stmpe *stmpe = keypad->stmpe;\r\nint ret;\r\nif (keypad->debounce_ms > STMPE_KEYPAD_MAX_DEBOUNCE)\r\nreturn -EINVAL;\r\nif (keypad->scan_count > STMPE_KEYPAD_MAX_SCAN_COUNT)\r\nreturn -EINVAL;\r\nret = stmpe_enable(stmpe, STMPE_BLOCK_KEYPAD);\r\nif (ret < 0)\r\nreturn ret;\r\nret = stmpe_keypad_altfunc_init(keypad);\r\nif (ret < 0)\r\nreturn ret;\r\nret = stmpe_reg_write(stmpe, STMPE_KPC_COL, keypad->cols);\r\nif (ret < 0)\r\nreturn ret;\r\nret = stmpe_reg_write(stmpe, STMPE_KPC_ROW_LSB, keypad->rows);\r\nif (ret < 0)\r\nreturn ret;\r\nif (variant->max_rows > 8) {\r\nret = stmpe_set_bits(stmpe, STMPE_KPC_ROW_MSB,\r\nSTMPE_KPC_ROW_MSB_ROWS,\r\nkeypad->rows >> 8);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_KPC_CTRL_MSB,\r\nSTMPE_KPC_CTRL_MSB_SCAN_COUNT,\r\nkeypad->scan_count << 4);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn stmpe_set_bits(stmpe, STMPE_KPC_CTRL_LSB,\r\nSTMPE_KPC_CTRL_LSB_SCAN |\r\nSTMPE_KPC_CTRL_LSB_DEBOUNCE,\r\nSTMPE_KPC_CTRL_LSB_SCAN |\r\n(keypad->debounce_ms << 1));\r\n}\r\nstatic void stmpe_keypad_fill_used_pins(struct stmpe_keypad *keypad,\r\nu32 used_rows, u32 used_cols)\r\n{\r\nint row, col;\r\nfor (row = 0; row < used_rows; row++) {\r\nfor (col = 0; col < used_cols; col++) {\r\nint code = MATRIX_SCAN_CODE(row, col,\r\nSTMPE_KEYPAD_ROW_SHIFT);\r\nif (keypad->keymap[code] != KEY_RESERVED) {\r\nkeypad->rows |= 1 << row;\r\nkeypad->cols |= 1 << col;\r\n}\r\n}\r\n}\r\n}\r\nstatic int stmpe_keypad_probe(struct platform_device *pdev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct stmpe_keypad *keypad;\r\nstruct input_dev *input;\r\nu32 rows;\r\nu32 cols;\r\nint error;\r\nint irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nkeypad = devm_kzalloc(&pdev->dev, sizeof(struct stmpe_keypad),\r\nGFP_KERNEL);\r\nif (!keypad)\r\nreturn -ENOMEM;\r\nkeypad->stmpe = stmpe;\r\nkeypad->variant = &stmpe_keypad_variants[stmpe->partnum];\r\nof_property_read_u32(np, "debounce-interval", &keypad->debounce_ms);\r\nof_property_read_u32(np, "st,scan-count", &keypad->scan_count);\r\nkeypad->no_autorepeat = of_property_read_bool(np, "st,no-autorepeat");\r\ninput = devm_input_allocate_device(&pdev->dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\ninput->name = "STMPE keypad";\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = &pdev->dev;\r\nerror = matrix_keypad_parse_of_params(&pdev->dev, &rows, &cols);\r\nif (error)\r\nreturn error;\r\nerror = matrix_keypad_build_keymap(NULL, NULL, rows, cols,\r\nkeypad->keymap, input);\r\nif (error)\r\nreturn error;\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nif (!keypad->no_autorepeat)\r\n__set_bit(EV_REP, input->evbit);\r\nstmpe_keypad_fill_used_pins(keypad, rows, cols);\r\nkeypad->input = input;\r\nerror = stmpe_keypad_chip_init(keypad);\r\nif (error < 0)\r\nreturn error;\r\nerror = devm_request_threaded_irq(&pdev->dev, irq,\r\nNULL, stmpe_keypad_irq,\r\nIRQF_ONESHOT, "stmpe-keypad", keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "unable to get irq: %d\n", error);\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"unable to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, keypad);\r\nreturn 0;\r\n}\r\nstatic int stmpe_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct stmpe_keypad *keypad = platform_get_drvdata(pdev);\r\nstmpe_disable(keypad->stmpe, STMPE_BLOCK_KEYPAD);\r\nreturn 0;\r\n}
