static void media_devnode_release(struct device *cd)\r\n{\r\nstruct media_devnode *devnode = to_media_devnode(cd);\r\nmutex_lock(&media_devnode_lock);\r\nclear_bit(devnode->minor, media_devnode_nums);\r\nmutex_unlock(&media_devnode_lock);\r\nif (devnode->release)\r\ndevnode->release(devnode);\r\nkfree(devnode);\r\npr_debug("%s: Media Devnode Deallocated\n", __func__);\r\n}\r\nstatic ssize_t media_read(struct file *filp, char __user *buf,\r\nsize_t sz, loff_t *off)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nif (!devnode->fops->read)\r\nreturn -EINVAL;\r\nif (!media_devnode_is_registered(devnode))\r\nreturn -EIO;\r\nreturn devnode->fops->read(filp, buf, sz, off);\r\n}\r\nstatic ssize_t media_write(struct file *filp, const char __user *buf,\r\nsize_t sz, loff_t *off)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nif (!devnode->fops->write)\r\nreturn -EINVAL;\r\nif (!media_devnode_is_registered(devnode))\r\nreturn -EIO;\r\nreturn devnode->fops->write(filp, buf, sz, off);\r\n}\r\nstatic unsigned int media_poll(struct file *filp,\r\nstruct poll_table_struct *poll)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nif (!media_devnode_is_registered(devnode))\r\nreturn POLLERR | POLLHUP;\r\nif (!devnode->fops->poll)\r\nreturn DEFAULT_POLLMASK;\r\nreturn devnode->fops->poll(filp, poll);\r\n}\r\nstatic long\r\n__media_ioctl(struct file *filp, unsigned int cmd, unsigned long arg,\r\nlong (*ioctl_func)(struct file *filp, unsigned int cmd,\r\nunsigned long arg))\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nif (!ioctl_func)\r\nreturn -ENOTTY;\r\nif (!media_devnode_is_registered(devnode))\r\nreturn -EIO;\r\nreturn ioctl_func(filp, cmd, arg);\r\n}\r\nstatic long media_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nreturn __media_ioctl(filp, cmd, arg, devnode->fops->ioctl);\r\n}\r\nstatic long media_compat_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nreturn __media_ioctl(filp, cmd, arg, devnode->fops->compat_ioctl);\r\n}\r\nstatic int media_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct media_devnode *devnode;\r\nint ret;\r\nmutex_lock(&media_devnode_lock);\r\ndevnode = container_of(inode->i_cdev, struct media_devnode, cdev);\r\nif (!media_devnode_is_registered(devnode)) {\r\nmutex_unlock(&media_devnode_lock);\r\nreturn -ENXIO;\r\n}\r\nget_device(&devnode->dev);\r\nmutex_unlock(&media_devnode_lock);\r\nfilp->private_data = devnode;\r\nif (devnode->fops->open) {\r\nret = devnode->fops->open(filp);\r\nif (ret) {\r\nput_device(&devnode->dev);\r\nfilp->private_data = NULL;\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int media_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nif (devnode->fops->release)\r\ndevnode->fops->release(filp);\r\nfilp->private_data = NULL;\r\nput_device(&devnode->dev);\r\npr_debug("%s: Media Release\n", __func__);\r\nreturn 0;\r\n}\r\nint __must_check media_devnode_register(struct media_device *mdev,\r\nstruct media_devnode *devnode,\r\nstruct module *owner)\r\n{\r\nint minor;\r\nint ret;\r\nmutex_lock(&media_devnode_lock);\r\nminor = find_next_zero_bit(media_devnode_nums, MEDIA_NUM_DEVICES, 0);\r\nif (minor == MEDIA_NUM_DEVICES) {\r\nmutex_unlock(&media_devnode_lock);\r\npr_err("could not get a free minor\n");\r\nkfree(devnode);\r\nreturn -ENFILE;\r\n}\r\nset_bit(minor, media_devnode_nums);\r\nmutex_unlock(&media_devnode_lock);\r\ndevnode->minor = minor;\r\ndevnode->media_dev = mdev;\r\ndevnode->dev.bus = &media_bus_type;\r\ndevnode->dev.devt = MKDEV(MAJOR(media_dev_t), devnode->minor);\r\ndevnode->dev.release = media_devnode_release;\r\nif (devnode->parent)\r\ndevnode->dev.parent = devnode->parent;\r\ndev_set_name(&devnode->dev, "media%d", devnode->minor);\r\ndevice_initialize(&devnode->dev);\r\ncdev_init(&devnode->cdev, &media_devnode_fops);\r\ndevnode->cdev.owner = owner;\r\ndevnode->cdev.kobj.parent = &devnode->dev.kobj;\r\nret = cdev_add(&devnode->cdev, MKDEV(MAJOR(media_dev_t), devnode->minor), 1);\r\nif (ret < 0) {\r\npr_err("%s: cdev_add failed\n", __func__);\r\ngoto cdev_add_error;\r\n}\r\nret = device_add(&devnode->dev);\r\nif (ret < 0) {\r\npr_err("%s: device_add failed\n", __func__);\r\ngoto device_add_error;\r\n}\r\nset_bit(MEDIA_FLAG_REGISTERED, &devnode->flags);\r\nreturn 0;\r\ndevice_add_error:\r\ncdev_del(&devnode->cdev);\r\ncdev_add_error:\r\nmutex_lock(&media_devnode_lock);\r\nclear_bit(devnode->minor, media_devnode_nums);\r\ndevnode->media_dev = NULL;\r\nmutex_unlock(&media_devnode_lock);\r\nput_device(&devnode->dev);\r\nreturn ret;\r\n}\r\nvoid media_devnode_unregister_prepare(struct media_devnode *devnode)\r\n{\r\nif (!media_devnode_is_registered(devnode))\r\nreturn;\r\nmutex_lock(&media_devnode_lock);\r\nclear_bit(MEDIA_FLAG_REGISTERED, &devnode->flags);\r\nmutex_unlock(&media_devnode_lock);\r\n}\r\nvoid media_devnode_unregister(struct media_devnode *devnode)\r\n{\r\nmutex_lock(&media_devnode_lock);\r\ncdev_del(&devnode->cdev);\r\nmutex_unlock(&media_devnode_lock);\r\ndevice_del(&devnode->dev);\r\ndevnode->media_dev = NULL;\r\nput_device(&devnode->dev);\r\n}\r\nstatic int __init media_devnode_init(void)\r\n{\r\nint ret;\r\npr_info("Linux media interface: v0.10\n");\r\nret = alloc_chrdev_region(&media_dev_t, 0, MEDIA_NUM_DEVICES,\r\nMEDIA_NAME);\r\nif (ret < 0) {\r\npr_warn("unable to allocate major\n");\r\nreturn ret;\r\n}\r\nret = bus_register(&media_bus_type);\r\nif (ret < 0) {\r\nunregister_chrdev_region(media_dev_t, MEDIA_NUM_DEVICES);\r\npr_warn("bus_register failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit media_devnode_exit(void)\r\n{\r\nbus_unregister(&media_bus_type);\r\nunregister_chrdev_region(media_dev_t, MEDIA_NUM_DEVICES);\r\n}
