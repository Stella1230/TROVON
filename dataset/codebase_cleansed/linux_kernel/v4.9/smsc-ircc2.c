static inline void register_bank(int iobase, int bank)\r\n{\r\noutb(((inb(iobase + IRCC_MASTER) & 0xf0) | (bank & 0x07)),\r\niobase + IRCC_MASTER);\r\n}\r\nstatic int smsc_ircc_pnp_probe(struct pnp_dev *dev,\r\nconst struct pnp_device_id *dev_id)\r\n{\r\nunsigned int firbase, sirbase;\r\nu8 dma, irq;\r\nif (!(pnp_port_valid(dev, 0) && pnp_port_valid(dev, 1) &&\r\npnp_dma_valid(dev, 0) && pnp_irq_valid(dev, 0)))\r\nreturn -EINVAL;\r\nsirbase = pnp_port_start(dev, 0);\r\nfirbase = pnp_port_start(dev, 1);\r\ndma = pnp_dma(dev, 0);\r\nirq = pnp_irq(dev, 0);\r\nif (smsc_ircc_open(firbase, sirbase, dma, irq))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __init smsc_ircc_legacy_probe(void)\r\n{\r\nint ret = 0;\r\n#ifdef CONFIG_PCI\r\nif (smsc_ircc_preconfigure_subsystems(ircc_cfg, ircc_fir, ircc_sir, ircc_dma, ircc_irq) < 0) {\r\nnet_err_ratelimited("%s, Preconfiguration failed !\n",\r\ndriver_name);\r\n}\r\n#endif\r\nif (ircc_fir > 0 && ircc_sir > 0) {\r\nnet_info_ratelimited(" Overriding FIR address 0x%04x\n",\r\nircc_fir);\r\nnet_info_ratelimited(" Overriding SIR address 0x%04x\n",\r\nircc_sir);\r\nif (smsc_ircc_open(ircc_fir, ircc_sir, ircc_dma, ircc_irq))\r\nret = -ENODEV;\r\n} else {\r\nret = -ENODEV;\r\nif (ircc_cfg > 0) {\r\nnet_info_ratelimited(" Overriding configuration address 0x%04x\n",\r\nircc_cfg);\r\nif (!smsc_superio_fdc(ircc_cfg))\r\nret = 0;\r\nif (!smsc_superio_lpc(ircc_cfg))\r\nret = 0;\r\n}\r\nif (smsc_ircc_look_for_chips() > 0)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init smsc_ircc_init(void)\r\n{\r\nint ret;\r\npr_debug("%s\n", __func__);\r\nret = platform_driver_register(&smsc_ircc_driver);\r\nif (ret) {\r\nnet_err_ratelimited("%s, Can't register driver!\n",\r\ndriver_name);\r\nreturn ret;\r\n}\r\ndev_count = 0;\r\nif (smsc_nopnp || !pnp_platform_devices ||\r\nircc_cfg || ircc_fir || ircc_sir ||\r\nircc_dma != DMA_INVAL || ircc_irq != IRQ_INVAL) {\r\nret = smsc_ircc_legacy_probe();\r\n} else {\r\nif (pnp_register_driver(&smsc_ircc_pnp_driver) == 0)\r\npnp_driver_registered = 1;\r\n}\r\nif (ret) {\r\nif (pnp_driver_registered)\r\npnp_unregister_driver(&smsc_ircc_pnp_driver);\r\nplatform_driver_unregister(&smsc_ircc_driver);\r\n}\r\nreturn ret;\r\n}\r\nstatic netdev_tx_t smsc_ircc_net_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct smsc_ircc_cb *self = netdev_priv(dev);\r\nif (self->io.speed > 115200)\r\nreturn smsc_ircc_hard_xmit_fir(skb, dev);\r\nelse\r\nreturn smsc_ircc_hard_xmit_sir(skb, dev);\r\n}\r\nstatic int smsc_ircc_open(unsigned int fir_base, unsigned int sir_base, u8 dma, u8 irq)\r\n{\r\nstruct smsc_ircc_cb *self;\r\nstruct net_device *dev;\r\nint err;\r\npr_debug("%s\n", __func__);\r\nerr = smsc_ircc_present(fir_base, sir_base);\r\nif (err)\r\ngoto err_out;\r\nerr = -ENOMEM;\r\nif (dev_count >= ARRAY_SIZE(dev_self)) {\r\nnet_warn_ratelimited("%s(), too many devices!\n", __func__);\r\ngoto err_out1;\r\n}\r\ndev = alloc_irdadev(sizeof(struct smsc_ircc_cb));\r\nif (!dev) {\r\nnet_warn_ratelimited("%s() can't allocate net device\n",\r\n__func__);\r\ngoto err_out1;\r\n}\r\n#if SMSC_IRCC2_C_NET_TIMEOUT\r\ndev->watchdog_timeo = HZ * 2;\r\n#endif\r\ndev->netdev_ops = &smsc_ircc_netdev_ops;\r\nself = netdev_priv(dev);\r\nself->netdev = dev;\r\ndev->base_addr = self->io.fir_base = fir_base;\r\ndev->irq = self->io.irq = irq;\r\ndev_self[dev_count] = self;\r\nspin_lock_init(&self->lock);\r\nself->rx_buff.truesize = SMSC_IRCC2_RX_BUFF_TRUESIZE;\r\nself->tx_buff.truesize = SMSC_IRCC2_TX_BUFF_TRUESIZE;\r\nself->rx_buff.head =\r\ndma_zalloc_coherent(NULL, self->rx_buff.truesize,\r\n&self->rx_buff_dma, GFP_KERNEL);\r\nif (self->rx_buff.head == NULL)\r\ngoto err_out2;\r\nself->tx_buff.head =\r\ndma_zalloc_coherent(NULL, self->tx_buff.truesize,\r\n&self->tx_buff_dma, GFP_KERNEL);\r\nif (self->tx_buff.head == NULL)\r\ngoto err_out3;\r\nself->rx_buff.in_frame = FALSE;\r\nself->rx_buff.state = OUTSIDE_FRAME;\r\nself->tx_buff.data = self->tx_buff.head;\r\nself->rx_buff.data = self->rx_buff.head;\r\nsmsc_ircc_setup_io(self, fir_base, sir_base, dma, irq);\r\nsmsc_ircc_setup_qos(self);\r\nsmsc_ircc_init_chip(self);\r\nif (ircc_transceiver > 0 &&\r\nircc_transceiver < SMSC_IRCC2_C_NUMBER_OF_TRANSCEIVERS)\r\nself->transceiver = ircc_transceiver;\r\nelse\r\nsmsc_ircc_probe_transceiver(self);\r\nerr = register_netdev(self->netdev);\r\nif (err) {\r\nnet_err_ratelimited("%s, Network device registration failed!\n",\r\ndriver_name);\r\ngoto err_out4;\r\n}\r\nself->pldev = platform_device_register_simple(SMSC_IRCC2_DRIVER_NAME,\r\ndev_count, NULL, 0);\r\nif (IS_ERR(self->pldev)) {\r\nerr = PTR_ERR(self->pldev);\r\ngoto err_out5;\r\n}\r\nplatform_set_drvdata(self->pldev, self);\r\nnet_info_ratelimited("IrDA: Registered device %s\n", dev->name);\r\ndev_count++;\r\nreturn 0;\r\nerr_out5:\r\nunregister_netdev(self->netdev);\r\nerr_out4:\r\ndma_free_coherent(NULL, self->tx_buff.truesize,\r\nself->tx_buff.head, self->tx_buff_dma);\r\nerr_out3:\r\ndma_free_coherent(NULL, self->rx_buff.truesize,\r\nself->rx_buff.head, self->rx_buff_dma);\r\nerr_out2:\r\nfree_netdev(self->netdev);\r\ndev_self[dev_count] = NULL;\r\nerr_out1:\r\nrelease_region(fir_base, SMSC_IRCC2_FIR_CHIP_IO_EXTENT);\r\nrelease_region(sir_base, SMSC_IRCC2_SIR_CHIP_IO_EXTENT);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int smsc_ircc_present(unsigned int fir_base, unsigned int sir_base)\r\n{\r\nunsigned char low, high, chip, config, dma, irq, version;\r\nif (!request_region(fir_base, SMSC_IRCC2_FIR_CHIP_IO_EXTENT,\r\ndriver_name)) {\r\nnet_warn_ratelimited("%s: can't get fir_base of 0x%03x\n",\r\n__func__, fir_base);\r\ngoto out1;\r\n}\r\nif (!request_region(sir_base, SMSC_IRCC2_SIR_CHIP_IO_EXTENT,\r\ndriver_name)) {\r\nnet_warn_ratelimited("%s: can't get sir_base of 0x%03x\n",\r\n__func__, sir_base);\r\ngoto out2;\r\n}\r\nregister_bank(fir_base, 3);\r\nhigh = inb(fir_base + IRCC_ID_HIGH);\r\nlow = inb(fir_base + IRCC_ID_LOW);\r\nchip = inb(fir_base + IRCC_CHIP_ID);\r\nversion = inb(fir_base + IRCC_VERSION);\r\nconfig = inb(fir_base + IRCC_INTERFACE);\r\ndma = config & IRCC_INTERFACE_DMA_MASK;\r\nirq = (config & IRCC_INTERFACE_IRQ_MASK) >> 4;\r\nif (high != 0x10 || low != 0xb8 || (chip != 0xf1 && chip != 0xf2)) {\r\nnet_warn_ratelimited("%s(), addr 0x%04x - no device found!\n",\r\n__func__, fir_base);\r\ngoto out3;\r\n}\r\nnet_info_ratelimited("SMsC IrDA Controller found\n IrCC version %d.%d, firport 0x%03x, sirport 0x%03x dma=%d, irq=%d\n",\r\nchip & 0x0f, version,\r\nfir_base, sir_base, dma, irq);\r\nreturn 0;\r\nout3:\r\nrelease_region(sir_base, SMSC_IRCC2_SIR_CHIP_IO_EXTENT);\r\nout2:\r\nrelease_region(fir_base, SMSC_IRCC2_FIR_CHIP_IO_EXTENT);\r\nout1:\r\nreturn -ENODEV;\r\n}\r\nstatic void smsc_ircc_setup_io(struct smsc_ircc_cb *self,\r\nunsigned int fir_base, unsigned int sir_base,\r\nu8 dma, u8 irq)\r\n{\r\nunsigned char config, chip_dma, chip_irq;\r\nregister_bank(fir_base, 3);\r\nconfig = inb(fir_base + IRCC_INTERFACE);\r\nchip_dma = config & IRCC_INTERFACE_DMA_MASK;\r\nchip_irq = (config & IRCC_INTERFACE_IRQ_MASK) >> 4;\r\nself->io.fir_base = fir_base;\r\nself->io.sir_base = sir_base;\r\nself->io.fir_ext = SMSC_IRCC2_FIR_CHIP_IO_EXTENT;\r\nself->io.sir_ext = SMSC_IRCC2_SIR_CHIP_IO_EXTENT;\r\nself->io.fifo_size = SMSC_IRCC2_FIFO_SIZE;\r\nself->io.speed = SMSC_IRCC2_C_IRDA_FALLBACK_SPEED;\r\nif (irq != IRQ_INVAL) {\r\nif (irq != chip_irq)\r\nnet_info_ratelimited("%s, Overriding IRQ - chip says %d, using %d\n",\r\ndriver_name, chip_irq, irq);\r\nself->io.irq = irq;\r\n} else\r\nself->io.irq = chip_irq;\r\nif (dma != DMA_INVAL) {\r\nif (dma != chip_dma)\r\nnet_info_ratelimited("%s, Overriding DMA - chip says %d, using %d\n",\r\ndriver_name, chip_dma, dma);\r\nself->io.dma = dma;\r\n} else\r\nself->io.dma = chip_dma;\r\n}\r\nstatic void smsc_ircc_setup_qos(struct smsc_ircc_cb *self)\r\n{\r\nirda_init_max_qos_capabilies(&self->qos);\r\nself->qos.baud_rate.bits = IR_9600|IR_19200|IR_38400|IR_57600|\r\nIR_115200|IR_576000|IR_1152000|(IR_4000000 << 8);\r\nself->qos.min_turn_time.bits = SMSC_IRCC2_MIN_TURN_TIME;\r\nself->qos.window_size.bits = SMSC_IRCC2_WINDOW_SIZE;\r\nirda_qos_bits_to_value(&self->qos);\r\n}\r\nstatic void smsc_ircc_init_chip(struct smsc_ircc_cb *self)\r\n{\r\nint iobase = self->io.fir_base;\r\nregister_bank(iobase, 0);\r\noutb(IRCC_MASTER_RESET, iobase + IRCC_MASTER);\r\noutb(0x00, iobase + IRCC_MASTER);\r\nregister_bank(iobase, 1);\r\noutb(((inb(iobase + IRCC_SCE_CFGA) & 0x87) | IRCC_CFGA_IRDA_SIR_A),\r\niobase + IRCC_SCE_CFGA);\r\n#ifdef smsc_669\r\noutb(((inb(iobase + IRCC_SCE_CFGB) & 0x3f) | IRCC_CFGB_MUX_COM),\r\niobase + IRCC_SCE_CFGB);\r\n#else\r\noutb(((inb(iobase + IRCC_SCE_CFGB) & 0x3f) | IRCC_CFGB_MUX_IR),\r\niobase + IRCC_SCE_CFGB);\r\n#endif\r\n(void) inb(iobase + IRCC_FIFO_THRESHOLD);\r\noutb(SMSC_IRCC2_FIFO_THRESHOLD, iobase + IRCC_FIFO_THRESHOLD);\r\nregister_bank(iobase, 4);\r\noutb((inb(iobase + IRCC_CONTROL) & 0x30), iobase + IRCC_CONTROL);\r\nregister_bank(iobase, 0);\r\noutb(0, iobase + IRCC_LCR_A);\r\nsmsc_ircc_set_sir_speed(self, SMSC_IRCC2_C_IRDA_FALLBACK_SPEED);\r\noutb(0x00, iobase + IRCC_MASTER);\r\n}\r\nstatic int smsc_ircc_net_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nstruct smsc_ircc_cb *self;\r\nunsigned long flags;\r\nint ret = 0;\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\npr_debug("%s(), %s, (cmd=0x%X)\n", __func__, dev->name, cmd);\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (!capable(CAP_NET_ADMIN))\r\nret = -EPERM;\r\nelse {\r\nspin_lock_irqsave(&self->lock, flags);\r\nsmsc_ircc_change_speed(self, irq->ifr_baudrate);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\n}\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nirda_device_set_media_busy(self->netdev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nirq->ifr_receiving = smsc_ircc_is_receiving(self);\r\nbreak;\r\n#if 0\r\ncase SIOCSDTRRTS:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nsmsc_ircc_sir_set_dtr_rts(dev, irq->ifr_dtr, irq->ifr_rts);\r\nbreak;\r\n#endif\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic void smsc_ircc_timeout(struct net_device *dev)\r\n{\r\nstruct smsc_ircc_cb *self = netdev_priv(dev);\r\nunsigned long flags;\r\nnet_warn_ratelimited("%s: transmit timed out, changing speed to: %d\n",\r\ndev->name, self->io.speed);\r\nspin_lock_irqsave(&self->lock, flags);\r\nsmsc_ircc_sir_start(self);\r\nsmsc_ircc_change_speed(self, self->io.speed);\r\nnetif_trans_update(dev);\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\n}\r\nstatic netdev_tx_t smsc_ircc_hard_xmit_sir(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct smsc_ircc_cb *self;\r\nunsigned long flags;\r\ns32 speed;\r\npr_debug("%s\n", __func__);\r\nIRDA_ASSERT(dev != NULL, return NETDEV_TX_OK;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return NETDEV_TX_OK;);\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&self->lock, flags);\r\nspeed = irda_get_next_speed(skb);\r\nif (speed != self->io.speed && speed != -1) {\r\nif (!skb->len) {\r\nsmsc_ircc_sir_wait_hw_transmitter_finish(self);\r\nsmsc_ircc_change_speed(self, speed);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nself->new_speed = speed;\r\n}\r\nself->tx_buff.data = self->tx_buff.head;\r\nself->tx_buff.len = async_wrap_skb(skb, self->tx_buff.data,\r\nself->tx_buff.truesize);\r\ndev->stats.tx_bytes += self->tx_buff.len;\r\noutb(UART_IER_THRI, self->io.sir_base + UART_IER);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void smsc_ircc_set_fir_speed(struct smsc_ircc_cb *self, u32 speed)\r\n{\r\nint fir_base, ir_mode, ctrl, fast;\r\nIRDA_ASSERT(self != NULL, return;);\r\nfir_base = self->io.fir_base;\r\nself->io.speed = speed;\r\nswitch (speed) {\r\ndefault:\r\ncase 576000:\r\nir_mode = IRCC_CFGA_IRDA_HDLC;\r\nctrl = IRCC_CRC;\r\nfast = 0;\r\npr_debug("%s(), handling baud of 576000\n", __func__);\r\nbreak;\r\ncase 1152000:\r\nir_mode = IRCC_CFGA_IRDA_HDLC;\r\nctrl = IRCC_1152 | IRCC_CRC;\r\nfast = IRCC_LCR_A_FAST | IRCC_LCR_A_GP_DATA;\r\npr_debug("%s(), handling baud of 1152000\n",\r\n__func__);\r\nbreak;\r\ncase 4000000:\r\nir_mode = IRCC_CFGA_IRDA_4PPM;\r\nctrl = IRCC_CRC;\r\nfast = IRCC_LCR_A_FAST;\r\npr_debug("%s(), handling baud of 4000000\n",\r\n__func__);\r\nbreak;\r\n}\r\n#if 0\r\nNow in tranceiver!\r\nregister_bank(fir_base, 0);\r\noutb((inb(fir_base + IRCC_LCR_A) & 0xbf) | fast, fir_base + IRCC_LCR_A);\r\n#endif\r\nregister_bank(fir_base, 1);\r\noutb(((inb(fir_base + IRCC_SCE_CFGA) & IRCC_SCE_CFGA_BLOCK_CTRL_BITS_MASK) | ir_mode), fir_base + IRCC_SCE_CFGA);\r\nregister_bank(fir_base, 4);\r\noutb((inb(fir_base + IRCC_CONTROL) & 0x30) | ctrl, fir_base + IRCC_CONTROL);\r\n}\r\nstatic void smsc_ircc_fir_start(struct smsc_ircc_cb *self)\r\n{\r\nstruct net_device *dev;\r\nint fir_base;\r\npr_debug("%s\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\ndev = self->netdev;\r\nIRDA_ASSERT(dev != NULL, return;);\r\nfir_base = self->io.fir_base;\r\noutb(inb(fir_base + IRCC_LCR_A) | IRCC_LCR_A_FIFO_RESET, fir_base + IRCC_LCR_A);\r\nregister_bank(fir_base, 1);\r\n#ifdef SMSC_669\r\noutb(((inb(fir_base + IRCC_SCE_CFGB) & 0x3f) | IRCC_CFGB_MUX_COM),\r\nfir_base + IRCC_SCE_CFGB);\r\n#else\r\noutb(((inb(fir_base + IRCC_SCE_CFGB) & 0x3f) | IRCC_CFGB_MUX_IR),\r\nfir_base + IRCC_SCE_CFGB);\r\n#endif\r\n(void) inb(fir_base + IRCC_FIFO_THRESHOLD);\r\noutb(0, fir_base + IRCC_MASTER);\r\nregister_bank(fir_base, 0);\r\noutb(IRCC_IER_ACTIVE_FRAME | IRCC_IER_EOM, fir_base + IRCC_IER);\r\noutb(IRCC_MASTER_INT_EN, fir_base + IRCC_MASTER);\r\n}\r\nstatic void smsc_ircc_fir_stop(struct smsc_ircc_cb *self)\r\n{\r\nint fir_base;\r\npr_debug("%s\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nfir_base = self->io.fir_base;\r\nregister_bank(fir_base, 0);\r\noutb(inb(fir_base + IRCC_LCR_B) & IRCC_LCR_B_SIP_ENABLE, fir_base + IRCC_LCR_B);\r\n}\r\nstatic void smsc_ircc_change_speed(struct smsc_ircc_cb *self, u32 speed)\r\n{\r\nstruct net_device *dev;\r\nint last_speed_was_sir;\r\npr_debug("%s() changing speed to: %d\n", __func__, speed);\r\nIRDA_ASSERT(self != NULL, return;);\r\ndev = self->netdev;\r\nlast_speed_was_sir = self->io.speed <= SMSC_IRCC2_MAX_SIR_SPEED;\r\n#if 0\r\nspeed= 1152000;\r\nself->io.speed = speed;\r\nlast_speed_was_sir = 0;\r\nsmsc_ircc_fir_start(self);\r\n#endif\r\nif (self->io.speed == 0)\r\nsmsc_ircc_sir_start(self);\r\n#if 0\r\nif (!last_speed_was_sir) speed = self->io.speed;\r\n#endif\r\nif (self->io.speed != speed)\r\nsmsc_ircc_set_transceiver_for_speed(self, speed);\r\nself->io.speed = speed;\r\nif (speed <= SMSC_IRCC2_MAX_SIR_SPEED) {\r\nif (!last_speed_was_sir) {\r\nsmsc_ircc_fir_stop(self);\r\nsmsc_ircc_sir_start(self);\r\n}\r\nsmsc_ircc_set_sir_speed(self, speed);\r\n} else {\r\nif (last_speed_was_sir) {\r\n#if SMSC_IRCC2_C_SIR_STOP\r\nsmsc_ircc_sir_stop(self);\r\n#endif\r\nsmsc_ircc_fir_start(self);\r\n}\r\nsmsc_ircc_set_fir_speed(self, speed);\r\n#if 0\r\nself->tx_buff.len = 10;\r\nself->tx_buff.data = self->tx_buff.head;\r\nsmsc_ircc_dma_xmit(self, 4000);\r\n#endif\r\nsmsc_ircc_dma_receive(self);\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void smsc_ircc_set_sir_speed(struct smsc_ircc_cb *self, __u32 speed)\r\n{\r\nint iobase;\r\nint fcr;\r\nint lcr;\r\nint divisor;\r\npr_debug("%s(), Setting speed to: %d\n", __func__, speed);\r\nIRDA_ASSERT(self != NULL, return;);\r\niobase = self->io.sir_base;\r\nself->io.speed = speed;\r\noutb(0, iobase + UART_IER);\r\ndivisor = SMSC_IRCC2_MAX_SIR_SPEED / speed;\r\nfcr = UART_FCR_ENABLE_FIFO;\r\nfcr |= self->io.speed < 38400 ?\r\nUART_FCR_TRIGGER_1 : UART_FCR_TRIGGER_14;\r\nlcr = UART_LCR_WLEN8;\r\noutb(UART_LCR_DLAB | lcr, iobase + UART_LCR);\r\noutb(divisor & 0xff, iobase + UART_DLL);\r\noutb(divisor >> 8, iobase + UART_DLM);\r\noutb(lcr, iobase + UART_LCR);\r\noutb(fcr, iobase + UART_FCR);\r\noutb(UART_IER_RLSI | UART_IER_RDI | UART_IER_THRI, iobase + UART_IER);\r\npr_debug("%s() speed changed to: %d\n", __func__, speed);\r\n}\r\nstatic netdev_tx_t smsc_ircc_hard_xmit_fir(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct smsc_ircc_cb *self;\r\nunsigned long flags;\r\ns32 speed;\r\nint mtt;\r\nIRDA_ASSERT(dev != NULL, return NETDEV_TX_OK;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return NETDEV_TX_OK;);\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&self->lock, flags);\r\nspeed = irda_get_next_speed(skb);\r\nif (speed != self->io.speed && speed != -1) {\r\nif (!skb->len) {\r\nsmsc_ircc_change_speed(self, speed);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nself->new_speed = speed;\r\n}\r\nskb_copy_from_linear_data(skb, self->tx_buff.head, skb->len);\r\nself->tx_buff.len = skb->len;\r\nself->tx_buff.data = self->tx_buff.head;\r\nmtt = irda_get_mtt(skb);\r\nif (mtt) {\r\nint bofs;\r\nbofs = mtt * (self->io.speed / 1000) / 8000;\r\nif (bofs > 4095)\r\nbofs = 4095;\r\nsmsc_ircc_dma_xmit(self, bofs);\r\n} else {\r\nsmsc_ircc_dma_xmit(self, 0);\r\n}\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void smsc_ircc_dma_xmit(struct smsc_ircc_cb *self, int bofs)\r\n{\r\nint iobase = self->io.fir_base;\r\nu8 ctrl;\r\npr_debug("%s\n", __func__);\r\n#if 1\r\nregister_bank(iobase, 0);\r\noutb(0x00, iobase + IRCC_LCR_B);\r\n#endif\r\nregister_bank(iobase, 1);\r\noutb(inb(iobase + IRCC_SCE_CFGB) & ~IRCC_CFGB_DMA_ENABLE,\r\niobase + IRCC_SCE_CFGB);\r\nself->io.direction = IO_XMIT;\r\nregister_bank(iobase, 4);\r\noutb(bofs & 0xff, iobase + IRCC_BOF_COUNT_LO);\r\nctrl = inb(iobase + IRCC_CONTROL) & 0xf0;\r\noutb(ctrl | ((bofs >> 8) & 0x0f), iobase + IRCC_BOF_COUNT_HI);\r\noutb(self->tx_buff.len >> 8, iobase + IRCC_TX_SIZE_HI);\r\noutb(self->tx_buff.len & 0xff, iobase + IRCC_TX_SIZE_LO);\r\nregister_bank(iobase, 1);\r\noutb(inb(iobase + IRCC_SCE_CFGB) | IRCC_CFGB_DMA_ENABLE |\r\nIRCC_CFGB_DMA_BURST, iobase + IRCC_SCE_CFGB);\r\nirda_setup_dma(self->io.dma, self->tx_buff_dma, self->tx_buff.len,\r\nDMA_TX_MODE);\r\nregister_bank(iobase, 0);\r\noutb(IRCC_IER_ACTIVE_FRAME | IRCC_IER_EOM, iobase + IRCC_IER);\r\noutb(IRCC_MASTER_INT_EN, iobase + IRCC_MASTER);\r\noutb(IRCC_LCR_B_SCE_TRANSMIT | IRCC_LCR_B_SIP_ENABLE, iobase + IRCC_LCR_B);\r\n}\r\nstatic void smsc_ircc_dma_xmit_complete(struct smsc_ircc_cb *self)\r\n{\r\nint iobase = self->io.fir_base;\r\npr_debug("%s\n", __func__);\r\n#if 0\r\nregister_bank(iobase, 0);\r\noutb(0x00, iobase + IRCC_LCR_B);\r\n#endif\r\nregister_bank(iobase, 1);\r\noutb(inb(iobase + IRCC_SCE_CFGB) & ~IRCC_CFGB_DMA_ENABLE,\r\niobase + IRCC_SCE_CFGB);\r\nregister_bank(iobase, 0);\r\nif (inb(iobase + IRCC_LSR) & IRCC_LSR_UNDERRUN) {\r\nself->netdev->stats.tx_errors++;\r\nself->netdev->stats.tx_fifo_errors++;\r\nregister_bank(iobase, 0);\r\noutb(IRCC_MASTER_ERROR_RESET, iobase + IRCC_MASTER);\r\noutb(0x00, iobase + IRCC_MASTER);\r\n} else {\r\nself->netdev->stats.tx_packets++;\r\nself->netdev->stats.tx_bytes += self->tx_buff.len;\r\n}\r\nif (self->new_speed) {\r\nsmsc_ircc_change_speed(self, self->new_speed);\r\nself->new_speed = 0;\r\n}\r\nnetif_wake_queue(self->netdev);\r\n}\r\nstatic int smsc_ircc_dma_receive(struct smsc_ircc_cb *self)\r\n{\r\nint iobase = self->io.fir_base;\r\n#if 0\r\nregister_bank(iobase, 1);\r\noutb(inb(iobase + IRCC_SCE_CFGB) & ~IRCC_CFGB_DMA_ENABLE,\r\niobase + IRCC_SCE_CFGB);\r\n#endif\r\nregister_bank(iobase, 0);\r\noutb(0x00, iobase + IRCC_LCR_B);\r\nregister_bank(iobase, 1);\r\noutb(inb(iobase + IRCC_SCE_CFGB) & ~IRCC_CFGB_DMA_ENABLE,\r\niobase + IRCC_SCE_CFGB);\r\nself->io.direction = IO_RECV;\r\nself->rx_buff.data = self->rx_buff.head;\r\nregister_bank(iobase, 4);\r\noutb((2050 >> 8) & 0x0f, iobase + IRCC_RX_SIZE_HI);\r\noutb(2050 & 0xff, iobase + IRCC_RX_SIZE_LO);\r\nirda_setup_dma(self->io.dma, self->rx_buff_dma, self->rx_buff.truesize,\r\nDMA_RX_MODE);\r\nregister_bank(iobase, 1);\r\noutb(inb(iobase + IRCC_SCE_CFGB) | IRCC_CFGB_DMA_ENABLE |\r\nIRCC_CFGB_DMA_BURST, iobase + IRCC_SCE_CFGB);\r\nregister_bank(iobase, 0);\r\noutb(IRCC_IER_ACTIVE_FRAME | IRCC_IER_EOM, iobase + IRCC_IER);\r\noutb(IRCC_MASTER_INT_EN, iobase + IRCC_MASTER);\r\nregister_bank(iobase, 0);\r\noutb(IRCC_LCR_B_SCE_RECEIVE | IRCC_LCR_B_SIP_ENABLE,\r\niobase + IRCC_LCR_B);\r\nreturn 0;\r\n}\r\nstatic void smsc_ircc_dma_receive_complete(struct smsc_ircc_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\nint len, msgcnt, lsr;\r\nint iobase = self->io.fir_base;\r\nregister_bank(iobase, 0);\r\npr_debug("%s\n", __func__);\r\n#if 0\r\nregister_bank(iobase, 0);\r\noutb(0x00, iobase + IRCC_LCR_B);\r\n#endif\r\nregister_bank(iobase, 0);\r\noutb(inb(iobase + IRCC_LSAR) & ~IRCC_LSAR_ADDRESS_MASK, iobase + IRCC_LSAR);\r\nlsr= inb(iobase + IRCC_LSR);\r\nmsgcnt = inb(iobase + IRCC_LCR_B) & 0x08;\r\npr_debug("%s: dma count = %d\n", __func__,\r\nget_dma_residue(self->io.dma));\r\nlen = self->rx_buff.truesize - get_dma_residue(self->io.dma);\r\nif (lsr & (IRCC_LSR_FRAME_ERROR | IRCC_LSR_CRC_ERROR | IRCC_LSR_SIZE_ERROR)) {\r\nself->netdev->stats.rx_errors++;\r\nif (lsr & IRCC_LSR_FRAME_ERROR)\r\nself->netdev->stats.rx_frame_errors++;\r\nif (lsr & IRCC_LSR_CRC_ERROR)\r\nself->netdev->stats.rx_crc_errors++;\r\nif (lsr & IRCC_LSR_SIZE_ERROR)\r\nself->netdev->stats.rx_length_errors++;\r\nif (lsr & (IRCC_LSR_UNDERRUN | IRCC_LSR_OVERRUN))\r\nself->netdev->stats.rx_length_errors++;\r\nreturn;\r\n}\r\nlen -= self->io.speed < 4000000 ? 2 : 4;\r\nif (len < 2 || len > 2050) {\r\nnet_warn_ratelimited("%s(), bogus len=%d\n", __func__, len);\r\nreturn;\r\n}\r\npr_debug("%s: msgcnt = %d, len=%d\n", __func__, msgcnt, len);\r\nskb = dev_alloc_skb(len + 1);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, 1);\r\nmemcpy(skb_put(skb, len), self->rx_buff.data, len);\r\nself->netdev->stats.rx_packets++;\r\nself->netdev->stats.rx_bytes += len;\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\n}\r\nstatic void smsc_ircc_sir_receive(struct smsc_ircc_cb *self)\r\n{\r\nint boguscount = 0;\r\nint iobase;\r\nIRDA_ASSERT(self != NULL, return;);\r\niobase = self->io.sir_base;\r\ndo {\r\nasync_unwrap_char(self->netdev, &self->netdev->stats, &self->rx_buff,\r\ninb(iobase + UART_RX));\r\nif (boguscount++ > 32) {\r\npr_debug("%s(), breaking!\n", __func__);\r\nbreak;\r\n}\r\n} while (inb(iobase + UART_LSR) & UART_LSR_DR);\r\n}\r\nstatic irqreturn_t smsc_ircc_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct smsc_ircc_cb *self = netdev_priv(dev);\r\nint iobase, iir, lcra, lsr;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&self->lock);\r\nif (self->io.speed <= SMSC_IRCC2_MAX_SIR_SPEED) {\r\nret = smsc_ircc_interrupt_sir(dev);\r\ngoto irq_ret_unlock;\r\n}\r\niobase = self->io.fir_base;\r\nregister_bank(iobase, 0);\r\niir = inb(iobase + IRCC_IIR);\r\nif (iir == 0)\r\ngoto irq_ret_unlock;\r\nret = IRQ_HANDLED;\r\noutb(0, iobase + IRCC_IER);\r\nlcra = inb(iobase + IRCC_LCR_A);\r\nlsr = inb(iobase + IRCC_LSR);\r\npr_debug("%s(), iir = 0x%02x\n", __func__, iir);\r\nif (iir & IRCC_IIR_EOM) {\r\nif (self->io.direction == IO_RECV)\r\nsmsc_ircc_dma_receive_complete(self);\r\nelse\r\nsmsc_ircc_dma_xmit_complete(self);\r\nsmsc_ircc_dma_receive(self);\r\n}\r\nif (iir & IRCC_IIR_ACTIVE_FRAME) {\r\n}\r\nregister_bank(iobase, 0);\r\noutb(IRCC_IER_ACTIVE_FRAME | IRCC_IER_EOM, iobase + IRCC_IER);\r\nirq_ret_unlock:\r\nspin_unlock(&self->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t smsc_ircc_interrupt_sir(struct net_device *dev)\r\n{\r\nstruct smsc_ircc_cb *self = netdev_priv(dev);\r\nint boguscount = 0;\r\nint iobase;\r\nint iir, lsr;\r\niobase = self->io.sir_base;\r\niir = inb(iobase + UART_IIR) & UART_IIR_ID;\r\nif (iir == 0)\r\nreturn IRQ_NONE;\r\nwhile (iir) {\r\nlsr = inb(iobase + UART_LSR);\r\npr_debug("%s(), iir=%02x, lsr=%02x, iobase=%#x\n",\r\n__func__, iir, lsr, iobase);\r\nswitch (iir) {\r\ncase UART_IIR_RLSI:\r\npr_debug("%s(), RLSI\n", __func__);\r\nbreak;\r\ncase UART_IIR_RDI:\r\nsmsc_ircc_sir_receive(self);\r\nbreak;\r\ncase UART_IIR_THRI:\r\nif (lsr & UART_LSR_THRE)\r\nsmsc_ircc_sir_write_wakeup(self);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), unhandled IIR=%#x\n",\r\n__func__, iir);\r\nbreak;\r\n}\r\nif (boguscount++ > 100)\r\nbreak;\r\niir = inb(iobase + UART_IIR) & UART_IIR_ID;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int smsc_ircc_request_irq(struct smsc_ircc_cb *self)\r\n{\r\nint error;\r\nerror = request_irq(self->io.irq, smsc_ircc_interrupt, 0,\r\nself->netdev->name, self->netdev);\r\nif (error)\r\npr_debug("%s(), unable to allocate irq=%d, err=%d\n",\r\n__func__, self->io.irq, error);\r\nreturn error;\r\n}\r\nstatic void smsc_ircc_start_interrupts(struct smsc_ircc_cb *self)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&self->lock, flags);\r\nself->io.speed = 0;\r\nsmsc_ircc_change_speed(self, SMSC_IRCC2_C_IRDA_FALLBACK_SPEED);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\n}\r\nstatic void smsc_ircc_stop_interrupts(struct smsc_ircc_cb *self)\r\n{\r\nint iobase = self->io.fir_base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&self->lock, flags);\r\nregister_bank(iobase, 0);\r\noutb(0, iobase + IRCC_IER);\r\noutb(IRCC_MASTER_RESET, iobase + IRCC_MASTER);\r\noutb(0x00, iobase + IRCC_MASTER);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\n}\r\nstatic int smsc_ircc_net_open(struct net_device *dev)\r\n{\r\nstruct smsc_ircc_cb *self;\r\nchar hwname[16];\r\npr_debug("%s\n", __func__);\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return 0;);\r\nif (self->io.suspended) {\r\npr_debug("%s(), device is suspended\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nif (request_irq(self->io.irq, smsc_ircc_interrupt, 0, dev->name,\r\n(void *) dev)) {\r\npr_debug("%s(), unable to allocate irq=%d\n",\r\n__func__, self->io.irq);\r\nreturn -EAGAIN;\r\n}\r\nsmsc_ircc_start_interrupts(self);\r\nsprintf(hwname, "SMSC @ 0x%03x", self->io.fir_base);\r\nself->irlap = irlap_open(dev, &self->qos, hwname);\r\nif (request_dma(self->io.dma, dev->name)) {\r\nsmsc_ircc_net_close(dev);\r\nnet_warn_ratelimited("%s(), unable to allocate DMA=%d\n",\r\n__func__, self->io.dma);\r\nreturn -EAGAIN;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int smsc_ircc_net_close(struct net_device *dev)\r\n{\r\nstruct smsc_ircc_cb *self;\r\npr_debug("%s\n", __func__);\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return 0;);\r\nnetif_stop_queue(dev);\r\nif (self->irlap)\r\nirlap_close(self->irlap);\r\nself->irlap = NULL;\r\nsmsc_ircc_stop_interrupts(self);\r\nif (!self->io.suspended)\r\nfree_irq(self->io.irq, dev);\r\ndisable_dma(self->io.dma);\r\nfree_dma(self->io.dma);\r\nreturn 0;\r\n}\r\nstatic int smsc_ircc_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct smsc_ircc_cb *self = platform_get_drvdata(dev);\r\nif (!self->io.suspended) {\r\npr_debug("%s, Suspending\n", driver_name);\r\nrtnl_lock();\r\nif (netif_running(self->netdev)) {\r\nnetif_device_detach(self->netdev);\r\nsmsc_ircc_stop_interrupts(self);\r\nfree_irq(self->io.irq, self->netdev);\r\ndisable_dma(self->io.dma);\r\n}\r\nself->io.suspended = 1;\r\nrtnl_unlock();\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc_ircc_resume(struct platform_device *dev)\r\n{\r\nstruct smsc_ircc_cb *self = platform_get_drvdata(dev);\r\nif (self->io.suspended) {\r\npr_debug("%s, Waking up\n", driver_name);\r\nrtnl_lock();\r\nsmsc_ircc_init_chip(self);\r\nif (netif_running(self->netdev)) {\r\nif (smsc_ircc_request_irq(self)) {\r\nunregister_netdevice(self->netdev);\r\n} else {\r\nenable_dma(self->io.dma);\r\nsmsc_ircc_start_interrupts(self);\r\nnetif_device_attach(self->netdev);\r\n}\r\n}\r\nself->io.suspended = 0;\r\nrtnl_unlock();\r\n}\r\nreturn 0;\r\n}\r\nstatic int __exit smsc_ircc_close(struct smsc_ircc_cb *self)\r\n{\r\npr_debug("%s\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nplatform_device_unregister(self->pldev);\r\nunregister_netdev(self->netdev);\r\nsmsc_ircc_stop_interrupts(self);\r\npr_debug("%s(), releasing 0x%03x\n", __func__,\r\nself->io.fir_base);\r\nrelease_region(self->io.fir_base, self->io.fir_ext);\r\npr_debug("%s(), releasing 0x%03x\n", __func__,\r\nself->io.sir_base);\r\nrelease_region(self->io.sir_base, self->io.sir_ext);\r\nif (self->tx_buff.head)\r\ndma_free_coherent(NULL, self->tx_buff.truesize,\r\nself->tx_buff.head, self->tx_buff_dma);\r\nif (self->rx_buff.head)\r\ndma_free_coherent(NULL, self->rx_buff.truesize,\r\nself->rx_buff.head, self->rx_buff_dma);\r\nfree_netdev(self->netdev);\r\nreturn 0;\r\n}\r\nstatic void __exit smsc_ircc_cleanup(void)\r\n{\r\nint i;\r\npr_debug("%s\n", __func__);\r\nfor (i = 0; i < 2; i++) {\r\nif (dev_self[i])\r\nsmsc_ircc_close(dev_self[i]);\r\n}\r\nif (pnp_driver_registered)\r\npnp_unregister_driver(&smsc_ircc_pnp_driver);\r\nplatform_driver_unregister(&smsc_ircc_driver);\r\n}\r\nstatic void smsc_ircc_sir_start(struct smsc_ircc_cb *self)\r\n{\r\nstruct net_device *dev;\r\nint fir_base, sir_base;\r\npr_debug("%s\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\ndev = self->netdev;\r\nIRDA_ASSERT(dev != NULL, return;);\r\nfir_base = self->io.fir_base;\r\nsir_base = self->io.sir_base;\r\noutb(IRCC_MASTER_RESET, fir_base + IRCC_MASTER);\r\n#if SMSC_IRCC2_C_SIR_STOP\r\n#endif\r\nregister_bank(fir_base, 1);\r\noutb(((inb(fir_base + IRCC_SCE_CFGA) & IRCC_SCE_CFGA_BLOCK_CTRL_BITS_MASK) | IRCC_CFGA_IRDA_SIR_A), fir_base + IRCC_SCE_CFGA);\r\noutb(UART_LCR_WLEN8, sir_base + UART_LCR);\r\noutb((UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2), sir_base + UART_MCR);\r\noutb(UART_IER_RLSI | UART_IER_RDI |UART_IER_THRI, sir_base + UART_IER);\r\npr_debug("%s() - exit\n", __func__);\r\noutb(0x00, fir_base + IRCC_MASTER);\r\n}\r\nvoid smsc_ircc_sir_stop(struct smsc_ircc_cb *self)\r\n{\r\nint iobase;\r\npr_debug("%s\n", __func__);\r\niobase = self->io.sir_base;\r\noutb(0, iobase + UART_MCR);\r\noutb(0, iobase + UART_IER);\r\n}\r\nstatic void smsc_ircc_sir_write_wakeup(struct smsc_ircc_cb *self)\r\n{\r\nint actual = 0;\r\nint iobase;\r\nint fcr;\r\nIRDA_ASSERT(self != NULL, return;);\r\npr_debug("%s\n", __func__);\r\niobase = self->io.sir_base;\r\nif (self->tx_buff.len > 0) {\r\nactual = smsc_ircc_sir_write(iobase, self->io.fifo_size,\r\nself->tx_buff.data, self->tx_buff.len);\r\nself->tx_buff.data += actual;\r\nself->tx_buff.len -= actual;\r\n} else {\r\nif (self->new_speed) {\r\npr_debug("%s(), Changing speed to %d.\n",\r\n__func__, self->new_speed);\r\nsmsc_ircc_sir_wait_hw_transmitter_finish(self);\r\nsmsc_ircc_change_speed(self, self->new_speed);\r\nself->new_speed = 0;\r\n} else {\r\nnetif_wake_queue(self->netdev);\r\n}\r\nself->netdev->stats.tx_packets++;\r\nif (self->io.speed <= 115200) {\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR;\r\nfcr |= self->io.speed < 38400 ?\r\nUART_FCR_TRIGGER_1 : UART_FCR_TRIGGER_14;\r\noutb(fcr, iobase + UART_FCR);\r\noutb(UART_IER_RDI, iobase + UART_IER);\r\n}\r\n}\r\n}\r\nstatic int smsc_ircc_sir_write(int iobase, int fifo_size, __u8 *buf, int len)\r\n{\r\nint actual = 0;\r\nif (!(inb(iobase + UART_LSR) & UART_LSR_THRE)) {\r\nnet_warn_ratelimited("%s(), failed, fifo not empty!\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nwhile (fifo_size-- > 0 && actual < len) {\r\noutb(buf[actual], iobase + UART_TX);\r\nactual++;\r\n}\r\nreturn actual;\r\n}\r\nstatic int smsc_ircc_is_receiving(struct smsc_ircc_cb *self)\r\n{\r\nreturn self->rx_buff.state != OUTSIDE_FRAME;\r\n}\r\nstatic void smsc_ircc_probe_transceiver(struct smsc_ircc_cb *self)\r\n{\r\nunsigned int i;\r\nIRDA_ASSERT(self != NULL, return;);\r\nfor (i = 0; smsc_transceivers[i].name != NULL; i++)\r\nif (smsc_transceivers[i].probe(self->io.fir_base)) {\r\nnet_info_ratelimited(" %s transceiver found\n",\r\nsmsc_transceivers[i].name);\r\nself->transceiver= i + 1;\r\nreturn;\r\n}\r\nnet_info_ratelimited("No transceiver found. Defaulting to %s\n",\r\nsmsc_transceivers[SMSC_IRCC2_C_DEFAULT_TRANSCEIVER].name);\r\nself->transceiver = SMSC_IRCC2_C_DEFAULT_TRANSCEIVER;\r\n}\r\nstatic void smsc_ircc_set_transceiver_for_speed(struct smsc_ircc_cb *self, u32 speed)\r\n{\r\nunsigned int trx;\r\ntrx = self->transceiver;\r\nif (trx > 0)\r\nsmsc_transceivers[trx - 1].set_for_speed(self->io.fir_base, speed);\r\n}\r\nstatic void smsc_ircc_sir_wait_hw_transmitter_finish(struct smsc_ircc_cb *self)\r\n{\r\nint iobase = self->io.sir_base;\r\nint count = SMSC_IRCC2_HW_TRANSMITTER_TIMEOUT_US;\r\nwhile (count-- > 0 && !(inb(iobase + UART_LSR) & UART_LSR_TEMT))\r\nudelay(1);\r\nif (count < 0)\r\npr_debug("%s(): stuck transmitter\n", __func__);\r\n}\r\nstatic int __init smsc_ircc_look_for_chips(void)\r\n{\r\nstruct smsc_chip_address *address;\r\nchar *type;\r\nunsigned int cfg_base, found;\r\nfound = 0;\r\naddress = possible_addresses;\r\nwhile (address->cfg_base) {\r\ncfg_base = address->cfg_base;\r\nif (address->type & SMSCSIO_TYPE_FDC) {\r\ntype = "FDC";\r\nif (address->type & SMSCSIO_TYPE_FLAT)\r\nif (!smsc_superio_flat(fdc_chips_flat, cfg_base, type))\r\nfound++;\r\nif (address->type & SMSCSIO_TYPE_PAGED)\r\nif (!smsc_superio_paged(fdc_chips_paged, cfg_base, type))\r\nfound++;\r\n}\r\nif (address->type & SMSCSIO_TYPE_LPC) {\r\ntype = "LPC";\r\nif (address->type & SMSCSIO_TYPE_FLAT)\r\nif (!smsc_superio_flat(lpc_chips_flat, cfg_base, type))\r\nfound++;\r\nif (address->type & SMSCSIO_TYPE_PAGED)\r\nif (!smsc_superio_paged(lpc_chips_paged, cfg_base, type))\r\nfound++;\r\n}\r\naddress++;\r\n}\r\nreturn found;\r\n}\r\nstatic int __init smsc_superio_flat(const struct smsc_chip *chips, unsigned short cfgbase, char *type)\r\n{\r\nunsigned short firbase, sirbase;\r\nu8 mode, dma, irq;\r\nint ret = -ENODEV;\r\npr_debug("%s\n", __func__);\r\nif (smsc_ircc_probe(cfgbase, SMSCSIOFLAT_DEVICEID_REG, chips, type) == NULL)\r\nreturn ret;\r\noutb(SMSCSIOFLAT_UARTMODE0C_REG, cfgbase);\r\nmode = inb(cfgbase + 1);\r\nif (!(mode & SMSCSIOFLAT_UART2MODE_VAL_IRDA))\r\nnet_warn_ratelimited("%s(): IrDA not enabled\n", __func__);\r\noutb(SMSCSIOFLAT_UART2BASEADDR_REG, cfgbase);\r\nsirbase = inb(cfgbase + 1) << 2;\r\noutb(SMSCSIOFLAT_FIRBASEADDR_REG, cfgbase);\r\nfirbase = inb(cfgbase + 1) << 3;\r\noutb(SMSCSIOFLAT_FIRDMASELECT_REG, cfgbase);\r\ndma = inb(cfgbase + 1) & SMSCSIOFLAT_FIRDMASELECT_MASK;\r\noutb(SMSCSIOFLAT_UARTIRQSELECT_REG, cfgbase);\r\nirq = inb(cfgbase + 1) & SMSCSIOFLAT_UART2IRQSELECT_MASK;\r\nnet_info_ratelimited("%s(): fir: 0x%02x, sir: 0x%02x, dma: %02d, irq: %d, mode: 0x%02x\n",\r\n__func__, firbase, sirbase, dma, irq, mode);\r\nif (firbase && smsc_ircc_open(firbase, sirbase, dma, irq) == 0)\r\nret = 0;\r\noutb(SMSCSIO_CFGEXITKEY, cfgbase);\r\nreturn ret;\r\n}\r\nstatic int __init smsc_superio_paged(const struct smsc_chip *chips, unsigned short cfg_base, char *type)\r\n{\r\nunsigned short fir_io, sir_io;\r\nint ret = -ENODEV;\r\npr_debug("%s\n", __func__);\r\nif (smsc_ircc_probe(cfg_base, 0x20, chips, type) == NULL)\r\nreturn ret;\r\noutb(0x07, cfg_base);\r\noutb(0x05, cfg_base + 1);\r\noutb(0x60, cfg_base);\r\nsir_io = inb(cfg_base + 1) << 8;\r\noutb(0x61, cfg_base);\r\nsir_io |= inb(cfg_base + 1);\r\noutb(0x62, cfg_base);\r\nfir_io = inb(cfg_base + 1) << 8;\r\noutb(0x63, cfg_base);\r\nfir_io |= inb(cfg_base + 1);\r\noutb(0x2b, cfg_base);\r\nif (fir_io && smsc_ircc_open(fir_io, sir_io, ircc_dma, ircc_irq) == 0)\r\nret = 0;\r\noutb(SMSCSIO_CFGEXITKEY, cfg_base);\r\nreturn ret;\r\n}\r\nstatic int __init smsc_access(unsigned short cfg_base, unsigned char reg)\r\n{\r\npr_debug("%s\n", __func__);\r\noutb(reg, cfg_base);\r\nreturn inb(cfg_base) != reg ? -1 : 0;\r\n}\r\nstatic const struct smsc_chip * __init smsc_ircc_probe(unsigned short cfg_base, u8 reg, const struct smsc_chip *chip, char *type)\r\n{\r\nu8 devid, xdevid, rev;\r\npr_debug("%s\n", __func__);\r\noutb(SMSCSIO_CFGEXITKEY, cfg_base);\r\nif (inb(cfg_base) == SMSCSIO_CFGEXITKEY)\r\nreturn NULL;\r\noutb(reg, cfg_base);\r\nxdevid = inb(cfg_base + 1);\r\noutb(SMSCSIO_CFGACCESSKEY, cfg_base);\r\n#if 0\r\nif (smsc_access(cfg_base,0x55))\r\nreturn NULL;\r\n#endif\r\nif (smsc_access(cfg_base, reg))\r\nreturn NULL;\r\ndevid = inb(cfg_base + 1);\r\nif (devid == 0 || devid == 0xff)\r\nreturn NULL;\r\nif (smsc_access(cfg_base, reg + 1))\r\nreturn NULL;\r\nrev = inb(cfg_base + 1);\r\nif (rev >= 128)\r\nreturn NULL;\r\nif (devid == xdevid)\r\nreturn NULL;\r\nwhile (chip->devid != devid) {\r\nchip++;\r\nif (chip->name == NULL)\r\nreturn NULL;\r\n}\r\nnet_info_ratelimited("found SMC SuperIO Chip (devid=0x%02x rev=%02X base=0x%04x): %s%s\n",\r\ndevid, rev, cfg_base, type, chip->name);\r\nif (chip->rev > rev) {\r\nnet_info_ratelimited("Revision higher than expected\n");\r\nreturn NULL;\r\n}\r\nif (chip->flags & NoIRDA)\r\nnet_info_ratelimited("chipset does not support IRDA\n");\r\nreturn chip;\r\n}\r\nstatic int __init smsc_superio_fdc(unsigned short cfg_base)\r\n{\r\nint ret = -1;\r\nif (!request_region(cfg_base, 2, driver_name)) {\r\nnet_warn_ratelimited("%s: can't get cfg_base of 0x%03x\n",\r\n__func__, cfg_base);\r\n} else {\r\nif (!smsc_superio_flat(fdc_chips_flat, cfg_base, "FDC") ||\r\n!smsc_superio_paged(fdc_chips_paged, cfg_base, "FDC"))\r\nret = 0;\r\nrelease_region(cfg_base, 2);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init smsc_superio_lpc(unsigned short cfg_base)\r\n{\r\nint ret = -1;\r\nif (!request_region(cfg_base, 2, driver_name)) {\r\nnet_warn_ratelimited("%s: can't get cfg_base of 0x%03x\n",\r\n__func__, cfg_base);\r\n} else {\r\nif (!smsc_superio_flat(lpc_chips_flat, cfg_base, "LPC") ||\r\n!smsc_superio_paged(lpc_chips_paged, cfg_base, "LPC"))\r\nret = 0;\r\nrelease_region(cfg_base, 2);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init preconfigure_smsc_chip(struct\r\nsmsc_ircc_subsystem_configuration\r\n*conf)\r\n{\r\nunsigned short iobase = conf->cfg_base;\r\nunsigned char tmpbyte;\r\noutb(LPC47N227_CFGACCESSKEY, iobase);\r\noutb(SMSCSIOFLAT_DEVICEID_REG, iobase);\r\ntmpbyte = inb(iobase +1);\r\npr_debug("Detected Chip id: 0x%02x, setting up registers...\n",\r\ntmpbyte);\r\noutb(0x24, iobase);\r\noutb(0x00, iobase + 1);\r\noutb(SMSCSIOFLAT_UART2BASEADDR_REG, iobase);\r\noutb( (conf->sir_io >> 2), iobase + 1);\r\ntmpbyte = inb(iobase + 1);\r\nif (tmpbyte != (conf->sir_io >> 2) ) {\r\nnet_warn_ratelimited("ERROR: could not configure SIR ioport\n");\r\nnet_warn_ratelimited("Try to supply ircc_cfg argument\n");\r\nreturn -ENXIO;\r\n}\r\noutb(SMSCSIOFLAT_UARTIRQSELECT_REG, iobase);\r\ntmpbyte = inb(iobase + 1);\r\ntmpbyte &= SMSCSIOFLAT_UART1IRQSELECT_MASK;\r\ntmpbyte |= (conf->fir_irq & SMSCSIOFLAT_UART2IRQSELECT_MASK);\r\noutb(tmpbyte, iobase + 1);\r\ntmpbyte = inb(iobase + 1) & SMSCSIOFLAT_UART2IRQSELECT_MASK;\r\nif (tmpbyte != conf->fir_irq) {\r\nnet_warn_ratelimited("ERROR: could not configure FIR IRQ channel\n");\r\nreturn -ENXIO;\r\n}\r\noutb(SMSCSIOFLAT_FIRBASEADDR_REG, iobase);\r\noutb((conf->fir_io >> 3), iobase + 1);\r\ntmpbyte = inb(iobase + 1);\r\nif (tmpbyte != (conf->fir_io >> 3) ) {\r\nnet_warn_ratelimited("ERROR: could not configure FIR I/O port\n");\r\nreturn -ENXIO;\r\n}\r\noutb(SMSCSIOFLAT_FIRDMASELECT_REG, iobase);\r\noutb((conf->fir_dma & LPC47N227_FIRDMASELECT_MASK), iobase + 1);\r\ntmpbyte = inb(iobase + 1) & LPC47N227_FIRDMASELECT_MASK;\r\nif (tmpbyte != (conf->fir_dma & LPC47N227_FIRDMASELECT_MASK)) {\r\nnet_warn_ratelimited("ERROR: could not configure FIR DMA channel\n");\r\nreturn -ENXIO;\r\n}\r\noutb(SMSCSIOFLAT_UARTMODE0C_REG, iobase);\r\ntmpbyte = inb(iobase + 1);\r\ntmpbyte &= ~SMSCSIOFLAT_UART2MODE_MASK |\r\nSMSCSIOFLAT_UART2MODE_VAL_IRDA;\r\noutb(tmpbyte, iobase + 1);\r\noutb(LPC47N227_APMBOOTDRIVE_REG, iobase);\r\ntmpbyte = inb(iobase + 1);\r\noutb(tmpbyte | LPC47N227_UART2AUTOPWRDOWN_MASK, iobase + 1);\r\noutb(0x0a, iobase);\r\ntmpbyte = inb(iobase + 1);\r\noutb(tmpbyte | 0x40, iobase + 1);\r\noutb(LPC47N227_UART12POWER_REG, iobase);\r\ntmpbyte = inb(iobase + 1);\r\noutb(tmpbyte | LPC47N227_UART2POWERDOWN_MASK, iobase + 1);\r\noutb(LPC47N227_FDCPOWERVALIDCONF_REG, iobase);\r\ntmpbyte = inb(iobase + 1);\r\noutb(tmpbyte | LPC47N227_VALID_MASK, iobase + 1);\r\noutb(LPC47N227_CFGEXITKEY, iobase);\r\nreturn 0;\r\n}\r\nstatic int __init preconfigure_through_82801(struct pci_dev *dev,\r\nstruct\r\nsmsc_ircc_subsystem_configuration\r\n*conf)\r\n{\r\nunsigned short tmpword;\r\nunsigned char tmpbyte;\r\nnet_info_ratelimited("Setting up Intel 82801 controller and SMSC device\n");\r\npci_read_config_byte(dev, COM_DEC, &tmpbyte);\r\ntmpbyte &= 0xf8;\r\nswitch(conf->sir_io) {\r\ncase 0x3f8:\r\ntmpbyte |= 0x00;\r\nbreak;\r\ncase 0x2f8:\r\ntmpbyte |= 0x01;\r\nbreak;\r\ncase 0x220:\r\ntmpbyte |= 0x02;\r\nbreak;\r\ncase 0x228:\r\ntmpbyte |= 0x03;\r\nbreak;\r\ncase 0x238:\r\ntmpbyte |= 0x04;\r\nbreak;\r\ncase 0x2e8:\r\ntmpbyte |= 0x05;\r\nbreak;\r\ncase 0x338:\r\ntmpbyte |= 0x06;\r\nbreak;\r\ncase 0x3e8:\r\ntmpbyte |= 0x07;\r\nbreak;\r\ndefault:\r\ntmpbyte |= 0x01;\r\n}\r\npr_debug("COM_DEC (write): 0x%02x\n", tmpbyte);\r\npci_write_config_byte(dev, COM_DEC, tmpbyte);\r\npci_read_config_word(dev, LPC_EN, &tmpword);\r\nswitch(conf->cfg_base) {\r\ncase 0x04e:\r\ntmpword |= 0x2000;\r\nbreak;\r\ncase 0x02e:\r\ntmpword |= 0x1000;\r\nbreak;\r\ncase 0x062:\r\ntmpword |= 0x0800;\r\nbreak;\r\ncase 0x060:\r\ntmpword |= 0x0400;\r\nbreak;\r\ndefault:\r\nnet_warn_ratelimited("Uncommon I/O base address: 0x%04x\n",\r\nconf->cfg_base);\r\nbreak;\r\n}\r\ntmpword &= 0xfffd;\r\ntmpword |= 0x0001;\r\npr_debug("LPC_EN (write): 0x%04x\n", tmpword);\r\npci_write_config_word(dev, LPC_EN, tmpword);\r\npci_read_config_word(dev, PCI_DMA_C, &tmpword);\r\nswitch(conf->fir_dma) {\r\ncase 0x07:\r\ntmpword |= 0xc000;\r\nbreak;\r\ncase 0x06:\r\ntmpword |= 0x3000;\r\nbreak;\r\ncase 0x05:\r\ntmpword |= 0x0c00;\r\nbreak;\r\ncase 0x03:\r\ntmpword |= 0x00c0;\r\nbreak;\r\ncase 0x02:\r\ntmpword |= 0x0030;\r\nbreak;\r\ncase 0x01:\r\ntmpword |= 0x000c;\r\nbreak;\r\ncase 0x00:\r\ntmpword |= 0x0003;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npr_debug("PCI_DMA_C (write): 0x%04x\n", tmpword);\r\npci_write_config_word(dev, PCI_DMA_C, tmpword);\r\ntmpword = conf->fir_io & 0xfff8;\r\ntmpword |= 0x0001;\r\npr_debug("GEN2_DEC (write): 0x%04x\n", tmpword);\r\npci_write_config_word(dev, GEN2_DEC, tmpword);\r\nreturn preconfigure_smsc_chip(conf);\r\n}\r\nstatic void __init preconfigure_ali_port(struct pci_dev *dev,\r\nunsigned short port)\r\n{\r\nunsigned char reg;\r\nunsigned char mask;\r\nunsigned char tmpbyte;\r\nswitch(port) {\r\ncase 0x0130:\r\ncase 0x0178:\r\nreg = 0xb0;\r\nmask = 0x80;\r\nbreak;\r\ncase 0x03f8:\r\nreg = 0xb4;\r\nmask = 0x80;\r\nbreak;\r\ncase 0x02f8:\r\nreg = 0xb4;\r\nmask = 0x30;\r\nbreak;\r\ncase 0x02e8:\r\nreg = 0xb4;\r\nmask = 0x08;\r\nbreak;\r\ndefault:\r\nnet_err_ratelimited("Failed to configure unsupported port on ALi 1533 bridge: 0x%04x\n",\r\nport);\r\nreturn;\r\n}\r\npci_read_config_byte(dev, reg, &tmpbyte);\r\ntmpbyte |= mask;\r\npci_write_config_byte(dev, reg, tmpbyte);\r\nnet_info_ratelimited("Activated ALi 1533 ISA bridge port 0x%04x\n",\r\nport);\r\n}\r\nstatic int __init preconfigure_through_ali(struct pci_dev *dev,\r\nstruct\r\nsmsc_ircc_subsystem_configuration\r\n*conf)\r\n{\r\npreconfigure_ali_port(dev, conf->sir_io);\r\npreconfigure_ali_port(dev, conf->fir_io);\r\nreturn preconfigure_smsc_chip(conf);\r\n}\r\nstatic int __init smsc_ircc_preconfigure_subsystems(unsigned short ircc_cfg,\r\nunsigned short ircc_fir,\r\nunsigned short ircc_sir,\r\nunsigned char ircc_dma,\r\nunsigned char ircc_irq)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nunsigned short ss_vendor = 0x0000;\r\nunsigned short ss_device = 0x0000;\r\nint ret = 0;\r\nfor_each_pci_dev(dev) {\r\nstruct smsc_ircc_subsystem_configuration *conf;\r\nif (dev->subsystem_vendor != 0x0000U) {\r\nss_vendor = dev->subsystem_vendor;\r\nss_device = dev->subsystem_device;\r\n}\r\nconf = subsystem_configurations;\r\nfor( ; conf->subvendor; conf++) {\r\nif(conf->vendor == dev->vendor &&\r\nconf->device == dev->device &&\r\nconf->subvendor == ss_vendor &&\r\n(conf->subdevice == ss_device ||\r\nconf->subdevice == 0xffff)) {\r\nstruct smsc_ircc_subsystem_configuration\r\ntmpconf;\r\nmemcpy(&tmpconf, conf,\r\nsizeof(struct smsc_ircc_subsystem_configuration));\r\nif (ircc_cfg != 0)\r\ntmpconf.cfg_base = ircc_cfg;\r\nif (ircc_fir != 0)\r\ntmpconf.fir_io = ircc_fir;\r\nif (ircc_sir != 0)\r\ntmpconf.sir_io = ircc_sir;\r\nif (ircc_dma != DMA_INVAL)\r\ntmpconf.fir_dma = ircc_dma;\r\nif (ircc_irq != IRQ_INVAL)\r\ntmpconf.fir_irq = ircc_irq;\r\nnet_info_ratelimited("Detected unconfigured %s SMSC IrDA chip, pre-configuring device\n",\r\nconf->name);\r\nif (conf->preconfigure)\r\nret = conf->preconfigure(dev, &tmpconf);\r\nelse\r\nret = -ENODEV;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void smsc_ircc_set_transceiver_smsc_ircc_atc(int fir_base, u32 speed)\r\n{\r\nunsigned long jiffies_now, jiffies_timeout;\r\nu8 val;\r\njiffies_now = jiffies;\r\njiffies_timeout = jiffies + SMSC_IRCC2_ATC_PROGRAMMING_TIMEOUT_JIFFIES;\r\nregister_bank(fir_base, 4);\r\noutb((inb(fir_base + IRCC_ATC) & IRCC_ATC_MASK) | IRCC_ATC_nPROGREADY|IRCC_ATC_ENABLE,\r\nfir_base + IRCC_ATC);\r\nwhile ((val = (inb(fir_base + IRCC_ATC) & IRCC_ATC_nPROGREADY)) &&\r\n!time_after(jiffies, jiffies_timeout))\r\n;\r\nif (val)\r\nnet_warn_ratelimited("%s(): ATC: 0x%02x\n",\r\n__func__, inb(fir_base + IRCC_ATC));\r\n}\r\nstatic int smsc_ircc_probe_transceiver_smsc_ircc_atc(int fir_base)\r\n{\r\nreturn 0;\r\n}\r\nstatic void smsc_ircc_set_transceiver_smsc_ircc_fast_pin_select(int fir_base, u32 speed)\r\n{\r\nu8 fast_mode;\r\nswitch (speed) {\r\ndefault:\r\ncase 576000 :\r\nfast_mode = 0;\r\nbreak;\r\ncase 1152000 :\r\ncase 4000000 :\r\nfast_mode = IRCC_LCR_A_FAST;\r\nbreak;\r\n}\r\nregister_bank(fir_base, 0);\r\noutb((inb(fir_base + IRCC_LCR_A) & 0xbf) | fast_mode, fir_base + IRCC_LCR_A);\r\n}\r\nstatic int smsc_ircc_probe_transceiver_smsc_ircc_fast_pin_select(int fir_base)\r\n{\r\nreturn 0;\r\n}\r\nstatic void smsc_ircc_set_transceiver_toshiba_sat1800(int fir_base, u32 speed)\r\n{\r\nu8 fast_mode;\r\nswitch (speed) {\r\ndefault:\r\ncase 576000 :\r\nfast_mode = 0;\r\nbreak;\r\ncase 1152000 :\r\ncase 4000000 :\r\nfast_mode = IRCC_LCR_A_GP_DATA;\r\nbreak;\r\n}\r\nregister_bank(fir_base, 0);\r\noutb((inb(fir_base + IRCC_LCR_A) & 0xbf) | fast_mode, fir_base + IRCC_LCR_A);\r\n}\r\nstatic int smsc_ircc_probe_transceiver_toshiba_sat1800(int fir_base)\r\n{\r\nreturn 0;\r\n}
