static bool bcma_wait_reg(struct bcma_bus *bus, void __iomem *addr, u32 mask,\r\nu32 value, int timeout)\r\n{\r\nunsigned long deadline = jiffies + timeout;\r\nu32 val;\r\ndo {\r\nval = readl(addr);\r\nif ((val & mask) == value)\r\nreturn true;\r\ncpu_relax();\r\nudelay(10);\r\n} while (!time_after_eq(jiffies, deadline));\r\nbcma_err(bus, "Timeout waiting for register %p\n", addr);\r\nreturn false;\r\n}\r\nvoid bcma_chipco_b_mii_write(struct bcma_drv_cc_b *ccb, u32 offset, u32 value)\r\n{\r\nstruct bcma_bus *bus = ccb->core->bus;\r\nvoid __iomem *mii = ccb->mii;\r\nwritel(offset, mii + BCMA_CCB_MII_MNG_CTL);\r\nbcma_wait_reg(bus, mii + BCMA_CCB_MII_MNG_CTL, 0x0100, 0x0000, 100);\r\nwritel(value, mii + BCMA_CCB_MII_MNG_CMD_DATA);\r\nbcma_wait_reg(bus, mii + BCMA_CCB_MII_MNG_CTL, 0x0100, 0x0000, 100);\r\n}\r\nint bcma_core_chipcommon_b_init(struct bcma_drv_cc_b *ccb)\r\n{\r\nif (ccb->setup_done)\r\nreturn 0;\r\nccb->setup_done = 1;\r\nccb->mii = ioremap_nocache(ccb->core->addr_s[1], BCMA_CORE_SIZE);\r\nif (!ccb->mii)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid bcma_core_chipcommon_b_free(struct bcma_drv_cc_b *ccb)\r\n{\r\nif (ccb->mii)\r\niounmap(ccb->mii);\r\n}
