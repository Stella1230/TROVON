static\r\nint ufs_qcom_phy_qmp_20nm_phy_calibrate(struct ufs_qcom_phy *ufs_qcom_phy,\r\nbool is_rate_B)\r\n{\r\nstruct ufs_qcom_phy_calibration *tbl_A, *tbl_B;\r\nint tbl_size_A, tbl_size_B;\r\nu8 major = ufs_qcom_phy->host_ctrl_rev_major;\r\nu16 minor = ufs_qcom_phy->host_ctrl_rev_minor;\r\nu16 step = ufs_qcom_phy->host_ctrl_rev_step;\r\nint err;\r\nif ((major == 0x1) && (minor == 0x002) && (step == 0x0000)) {\r\ntbl_size_A = ARRAY_SIZE(phy_cal_table_rate_A_1_2_0);\r\ntbl_A = phy_cal_table_rate_A_1_2_0;\r\n} else if ((major == 0x1) && (minor == 0x003) && (step == 0x0000)) {\r\ntbl_size_A = ARRAY_SIZE(phy_cal_table_rate_A_1_3_0);\r\ntbl_A = phy_cal_table_rate_A_1_3_0;\r\n} else {\r\ndev_err(ufs_qcom_phy->dev, "%s: Unknown UFS-PHY version, no calibration values\n",\r\n__func__);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ntbl_size_B = ARRAY_SIZE(phy_cal_table_rate_B);\r\ntbl_B = phy_cal_table_rate_B;\r\nerr = ufs_qcom_phy_calibrate(ufs_qcom_phy, tbl_A, tbl_size_A,\r\ntbl_B, tbl_size_B, is_rate_B);\r\nif (err)\r\ndev_err(ufs_qcom_phy->dev, "%s: ufs_qcom_phy_calibrate() failed %d\n",\r\n__func__, err);\r\nout:\r\nreturn err;\r\n}\r\nstatic\r\nvoid ufs_qcom_phy_qmp_20nm_advertise_quirks(struct ufs_qcom_phy *phy_common)\r\n{\r\nphy_common->quirks =\r\nUFS_QCOM_PHY_QUIRK_HIBERN8_EXIT_AFTER_PHY_PWR_COLLAPSE;\r\n}\r\nstatic int ufs_qcom_phy_qmp_20nm_init(struct phy *generic_phy)\r\n{\r\nstruct ufs_qcom_phy_qmp_20nm *phy = phy_get_drvdata(generic_phy);\r\nstruct ufs_qcom_phy *phy_common = &phy->common_cfg;\r\nint err = 0;\r\nerr = ufs_qcom_phy_init_clks(generic_phy, phy_common);\r\nif (err) {\r\ndev_err(phy_common->dev, "%s: ufs_qcom_phy_init_clks() failed %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nerr = ufs_qcom_phy_init_vregulators(generic_phy, phy_common);\r\nif (err) {\r\ndev_err(phy_common->dev, "%s: ufs_qcom_phy_init_vregulators() failed %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nufs_qcom_phy_qmp_20nm_advertise_quirks(phy_common);\r\nout:\r\nreturn err;\r\n}\r\nstatic\r\nvoid ufs_qcom_phy_qmp_20nm_power_control(struct ufs_qcom_phy *phy, bool val)\r\n{\r\nbool hibern8_exit_after_pwr_collapse = phy->quirks &\r\nUFS_QCOM_PHY_QUIRK_HIBERN8_EXIT_AFTER_PHY_PWR_COLLAPSE;\r\nif (val) {\r\nwritel_relaxed(0x1, phy->mmio + UFS_PHY_POWER_DOWN_CONTROL);\r\nmb();\r\nif (hibern8_exit_after_pwr_collapse) {\r\nusleep_range(1, 2);\r\nwritel_relaxed(0x0A, phy->mmio +\r\nQSERDES_COM_SYSCLK_EN_SEL_TXBAND);\r\nwritel_relaxed(0x08, phy->mmio +\r\nQSERDES_COM_SYSCLK_EN_SEL_TXBAND);\r\nmb();\r\n}\r\n} else {\r\nif (hibern8_exit_after_pwr_collapse) {\r\nwritel_relaxed(0x0A, phy->mmio +\r\nQSERDES_COM_SYSCLK_EN_SEL_TXBAND);\r\nwritel_relaxed(0x02, phy->mmio +\r\nQSERDES_COM_SYSCLK_EN_SEL_TXBAND);\r\nmb();\r\n}\r\nwritel_relaxed(0x0, phy->mmio + UFS_PHY_POWER_DOWN_CONTROL);\r\nmb();\r\n}\r\n}\r\nstatic\r\nvoid ufs_qcom_phy_qmp_20nm_set_tx_lane_enable(struct ufs_qcom_phy *phy, u32 val)\r\n{\r\nwritel_relaxed(val & UFS_PHY_TX_LANE_ENABLE_MASK,\r\nphy->mmio + UFS_PHY_TX_LANE_ENABLE);\r\nmb();\r\n}\r\nstatic inline void ufs_qcom_phy_qmp_20nm_start_serdes(struct ufs_qcom_phy *phy)\r\n{\r\nu32 tmp;\r\ntmp = readl_relaxed(phy->mmio + UFS_PHY_PHY_START);\r\ntmp &= ~MASK_SERDES_START;\r\ntmp |= (1 << OFFSET_SERDES_START);\r\nwritel_relaxed(tmp, phy->mmio + UFS_PHY_PHY_START);\r\nmb();\r\n}\r\nstatic int ufs_qcom_phy_qmp_20nm_is_pcs_ready(struct ufs_qcom_phy *phy_common)\r\n{\r\nint err = 0;\r\nu32 val;\r\nerr = readl_poll_timeout(phy_common->mmio + UFS_PHY_PCS_READY_STATUS,\r\nval, (val & MASK_PCS_READY), 10, 1000000);\r\nif (err)\r\ndev_err(phy_common->dev, "%s: poll for pcs failed err = %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_phy_qmp_20nm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct phy *generic_phy;\r\nstruct ufs_qcom_phy_qmp_20nm *phy;\r\nint err = 0;\r\nphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ngeneric_phy = ufs_qcom_phy_generic_probe(pdev, &phy->common_cfg,\r\n&ufs_qcom_phy_qmp_20nm_phy_ops, &phy_20nm_ops);\r\nif (!generic_phy) {\r\ndev_err(dev, "%s: ufs_qcom_phy_generic_probe() failed\n",\r\n__func__);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nphy_set_drvdata(generic_phy, phy);\r\nstrlcpy(phy->common_cfg.name, UFS_PHY_NAME,\r\nsizeof(phy->common_cfg.name));\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_phy_qmp_20nm_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct phy *generic_phy = to_phy(dev);\r\nstruct ufs_qcom_phy *ufs_qcom_phy = get_ufs_qcom_phy(generic_phy);\r\nint err = 0;\r\nerr = ufs_qcom_phy_remove(generic_phy, ufs_qcom_phy);\r\nif (err)\r\ndev_err(dev, "%s: ufs_qcom_phy_remove failed = %d\n",\r\n__func__, err);\r\nreturn err;\r\n}
