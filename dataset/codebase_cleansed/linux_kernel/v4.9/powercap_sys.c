static ssize_t show_constraint_name(struct device *dev,\r\nstruct device_attribute *dev_attr,\r\nchar *buf)\r\n{\r\nconst char *name;\r\nstruct powercap_zone *power_zone = to_powercap_zone(dev);\r\nint id;\r\nssize_t len = -ENODATA;\r\nstruct powercap_zone_constraint *pconst;\r\nif (!sscanf(dev_attr->attr.name, "constraint_%d_", &id))\r\nreturn -EINVAL;\r\nif (id >= power_zone->const_id_cnt)\r\nreturn -EINVAL;\r\npconst = &power_zone->constraints[id];\r\nif (pconst && pconst->ops && pconst->ops->get_name) {\r\nname = pconst->ops->get_name(power_zone, id);\r\nif (name) {\r\nsnprintf(buf, POWERCAP_CONSTRAINT_NAME_LEN,\r\n"%s\n", name);\r\nbuf[POWERCAP_CONSTRAINT_NAME_LEN] = '\0';\r\nlen = strlen(buf);\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic int create_constraint_attribute(int id, const char *name,\r\nint mode,\r\nstruct device_attribute *dev_attr,\r\nssize_t (*show)(struct device *,\r\nstruct device_attribute *, char *),\r\nssize_t (*store)(struct device *,\r\nstruct device_attribute *,\r\nconst char *, size_t)\r\n)\r\n{\r\ndev_attr->attr.name = kasprintf(GFP_KERNEL, "constraint_%d_%s",\r\nid, name);\r\nif (!dev_attr->attr.name)\r\nreturn -ENOMEM;\r\ndev_attr->attr.mode = mode;\r\ndev_attr->show = show;\r\ndev_attr->store = store;\r\nreturn 0;\r\n}\r\nstatic void free_constraint_attributes(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CONSTRAINTS_PER_ZONE; ++i) {\r\nkfree(constraint_attrs[i].power_limit_attr.attr.name);\r\nkfree(constraint_attrs[i].time_window_attr.attr.name);\r\nkfree(constraint_attrs[i].name_attr.attr.name);\r\nkfree(constraint_attrs[i].max_power_attr.attr.name);\r\nkfree(constraint_attrs[i].min_power_attr.attr.name);\r\nkfree(constraint_attrs[i].max_time_window_attr.attr.name);\r\nkfree(constraint_attrs[i].min_time_window_attr.attr.name);\r\n}\r\n}\r\nstatic int seed_constraint_attributes(void)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < MAX_CONSTRAINTS_PER_ZONE; ++i) {\r\nret = create_constraint_attribute(i, "power_limit_uw",\r\nS_IWUSR | S_IRUGO,\r\n&constraint_attrs[i].power_limit_attr,\r\nshow_constraint_power_limit_uw,\r\nstore_constraint_power_limit_uw);\r\nif (ret)\r\ngoto err_alloc;\r\nret = create_constraint_attribute(i, "time_window_us",\r\nS_IWUSR | S_IRUGO,\r\n&constraint_attrs[i].time_window_attr,\r\nshow_constraint_time_window_us,\r\nstore_constraint_time_window_us);\r\nif (ret)\r\ngoto err_alloc;\r\nret = create_constraint_attribute(i, "name", S_IRUGO,\r\n&constraint_attrs[i].name_attr,\r\nshow_constraint_name,\r\nNULL);\r\nif (ret)\r\ngoto err_alloc;\r\nret = create_constraint_attribute(i, "max_power_uw", S_IRUGO,\r\n&constraint_attrs[i].max_power_attr,\r\nshow_constraint_max_power_uw,\r\nNULL);\r\nif (ret)\r\ngoto err_alloc;\r\nret = create_constraint_attribute(i, "min_power_uw", S_IRUGO,\r\n&constraint_attrs[i].min_power_attr,\r\nshow_constraint_min_power_uw,\r\nNULL);\r\nif (ret)\r\ngoto err_alloc;\r\nret = create_constraint_attribute(i, "max_time_window_us",\r\nS_IRUGO,\r\n&constraint_attrs[i].max_time_window_attr,\r\nshow_constraint_max_time_window_us,\r\nNULL);\r\nif (ret)\r\ngoto err_alloc;\r\nret = create_constraint_attribute(i, "min_time_window_us",\r\nS_IRUGO,\r\n&constraint_attrs[i].min_time_window_attr,\r\nshow_constraint_min_time_window_us,\r\nNULL);\r\nif (ret)\r\ngoto err_alloc;\r\n}\r\nreturn 0;\r\nerr_alloc:\r\nfree_constraint_attributes();\r\nreturn ret;\r\n}\r\nstatic int create_constraints(struct powercap_zone *power_zone,\r\nint nr_constraints,\r\nconst struct powercap_zone_constraint_ops *const_ops)\r\n{\r\nint i;\r\nint ret = 0;\r\nint count;\r\nstruct powercap_zone_constraint *pconst;\r\nif (!power_zone || !const_ops || !const_ops->get_power_limit_uw ||\r\n!const_ops->set_power_limit_uw ||\r\n!const_ops->get_time_window_us ||\r\n!const_ops->set_time_window_us)\r\nreturn -EINVAL;\r\ncount = power_zone->zone_attr_count;\r\nfor (i = 0; i < nr_constraints; ++i) {\r\npconst = &power_zone->constraints[i];\r\npconst->ops = const_ops;\r\npconst->id = power_zone->const_id_cnt;\r\npower_zone->const_id_cnt++;\r\npower_zone->zone_dev_attrs[count++] =\r\n&constraint_attrs[i].power_limit_attr.attr;\r\npower_zone->zone_dev_attrs[count++] =\r\n&constraint_attrs[i].time_window_attr.attr;\r\nif (pconst->ops->get_name)\r\npower_zone->zone_dev_attrs[count++] =\r\n&constraint_attrs[i].name_attr.attr;\r\nif (pconst->ops->get_max_power_uw)\r\npower_zone->zone_dev_attrs[count++] =\r\n&constraint_attrs[i].max_power_attr.attr;\r\nif (pconst->ops->get_min_power_uw)\r\npower_zone->zone_dev_attrs[count++] =\r\n&constraint_attrs[i].min_power_attr.attr;\r\nif (pconst->ops->get_max_time_window_us)\r\npower_zone->zone_dev_attrs[count++] =\r\n&constraint_attrs[i].max_time_window_attr.attr;\r\nif (pconst->ops->get_min_time_window_us)\r\npower_zone->zone_dev_attrs[count++] =\r\n&constraint_attrs[i].min_time_window_attr.attr;\r\n}\r\npower_zone->zone_attr_count = count;\r\nreturn ret;\r\n}\r\nstatic bool control_type_valid(void *control_type)\r\n{\r\nstruct powercap_control_type *pos = NULL;\r\nbool found = false;\r\nmutex_lock(&powercap_cntrl_list_lock);\r\nlist_for_each_entry(pos, &powercap_cntrl_list, node) {\r\nif (pos == control_type) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&powercap_cntrl_list_lock);\r\nreturn found;\r\n}\r\nstatic ssize_t name_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct powercap_zone *power_zone = to_powercap_zone(dev);\r\nreturn sprintf(buf, "%s\n", power_zone->name);\r\n}\r\nstatic void create_power_zone_common_attributes(\r\nstruct powercap_zone *power_zone)\r\n{\r\nint count = 0;\r\npower_zone->zone_dev_attrs[count++] = &dev_attr_name.attr;\r\nif (power_zone->ops->get_max_energy_range_uj)\r\npower_zone->zone_dev_attrs[count++] =\r\n&dev_attr_max_energy_range_uj.attr;\r\nif (power_zone->ops->get_energy_uj) {\r\nif (power_zone->ops->reset_energy_uj)\r\ndev_attr_energy_uj.attr.mode = S_IWUSR | S_IRUGO;\r\nelse\r\ndev_attr_energy_uj.attr.mode = S_IRUGO;\r\npower_zone->zone_dev_attrs[count++] =\r\n&dev_attr_energy_uj.attr;\r\n}\r\nif (power_zone->ops->get_power_uw)\r\npower_zone->zone_dev_attrs[count++] =\r\n&dev_attr_power_uw.attr;\r\nif (power_zone->ops->get_max_power_range_uw)\r\npower_zone->zone_dev_attrs[count++] =\r\n&dev_attr_max_power_range_uw.attr;\r\npower_zone->zone_dev_attrs[count] = NULL;\r\npower_zone->zone_attr_count = count;\r\n}\r\nstatic void powercap_release(struct device *dev)\r\n{\r\nbool allocated;\r\nif (dev->parent) {\r\nstruct powercap_zone *power_zone = to_powercap_zone(dev);\r\nallocated = power_zone->allocated;\r\nidr_remove(power_zone->parent_idr, power_zone->id);\r\nidr_destroy(&power_zone->idr);\r\nkfree(power_zone->name);\r\nkfree(power_zone->zone_dev_attrs);\r\nkfree(power_zone->constraints);\r\nif (power_zone->ops->release)\r\npower_zone->ops->release(power_zone);\r\nif (allocated)\r\nkfree(power_zone);\r\n} else {\r\nstruct powercap_control_type *control_type =\r\nto_powercap_control_type(dev);\r\nallocated = control_type->allocated;\r\nidr_destroy(&control_type->idr);\r\nmutex_destroy(&control_type->lock);\r\nif (control_type->ops && control_type->ops->release)\r\ncontrol_type->ops->release(control_type);\r\nif (allocated)\r\nkfree(control_type);\r\n}\r\n}\r\nstatic ssize_t enabled_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nbool mode = true;\r\nif (dev->parent) {\r\nstruct powercap_zone *power_zone = to_powercap_zone(dev);\r\nif (power_zone->ops->get_enable)\r\nif (power_zone->ops->get_enable(power_zone, &mode))\r\nmode = false;\r\n} else {\r\nstruct powercap_control_type *control_type =\r\nto_powercap_control_type(dev);\r\nif (control_type->ops && control_type->ops->get_enable)\r\nif (control_type->ops->get_enable(control_type, &mode))\r\nmode = false;\r\n}\r\nreturn sprintf(buf, "%d\n", mode);\r\n}\r\nstatic ssize_t enabled_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nbool mode;\r\nif (strtobool(buf, &mode))\r\nreturn -EINVAL;\r\nif (dev->parent) {\r\nstruct powercap_zone *power_zone = to_powercap_zone(dev);\r\nif (power_zone->ops->set_enable)\r\nif (!power_zone->ops->set_enable(power_zone, mode))\r\nreturn len;\r\n} else {\r\nstruct powercap_control_type *control_type =\r\nto_powercap_control_type(dev);\r\nif (control_type->ops && control_type->ops->set_enable)\r\nif (!control_type->ops->set_enable(control_type, mode))\r\nreturn len;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstruct powercap_zone *powercap_register_zone(\r\nstruct powercap_zone *power_zone,\r\nstruct powercap_control_type *control_type,\r\nconst char *name,\r\nstruct powercap_zone *parent,\r\nconst struct powercap_zone_ops *ops,\r\nint nr_constraints,\r\nconst struct powercap_zone_constraint_ops *const_ops)\r\n{\r\nint result;\r\nint nr_attrs;\r\nif (!name || !control_type || !ops ||\r\nnr_constraints > MAX_CONSTRAINTS_PER_ZONE ||\r\n(!ops->get_energy_uj && !ops->get_power_uw) ||\r\n!control_type_valid(control_type))\r\nreturn ERR_PTR(-EINVAL);\r\nif (power_zone) {\r\nif (!ops->release)\r\nreturn ERR_PTR(-EINVAL);\r\nmemset(power_zone, 0, sizeof(*power_zone));\r\n} else {\r\npower_zone = kzalloc(sizeof(*power_zone), GFP_KERNEL);\r\nif (!power_zone)\r\nreturn ERR_PTR(-ENOMEM);\r\npower_zone->allocated = true;\r\n}\r\npower_zone->ops = ops;\r\npower_zone->control_type_inst = control_type;\r\nif (!parent) {\r\npower_zone->dev.parent = &control_type->dev;\r\npower_zone->parent_idr = &control_type->idr;\r\n} else {\r\npower_zone->dev.parent = &parent->dev;\r\npower_zone->parent_idr = &parent->idr;\r\n}\r\npower_zone->dev.class = &powercap_class;\r\nmutex_lock(&control_type->lock);\r\nresult = idr_alloc(power_zone->parent_idr, NULL, 0, 0, GFP_KERNEL);\r\nif (result < 0)\r\ngoto err_idr_alloc;\r\npower_zone->id = result;\r\nidr_init(&power_zone->idr);\r\npower_zone->name = kstrdup(name, GFP_KERNEL);\r\nif (!power_zone->name)\r\ngoto err_name_alloc;\r\ndev_set_name(&power_zone->dev, "%s:%x",\r\ndev_name(power_zone->dev.parent),\r\npower_zone->id);\r\npower_zone->constraints = kzalloc(sizeof(*power_zone->constraints) *\r\nnr_constraints, GFP_KERNEL);\r\nif (!power_zone->constraints)\r\ngoto err_const_alloc;\r\nnr_attrs = nr_constraints * POWERCAP_CONSTRAINTS_ATTRS +\r\nPOWERCAP_ZONE_MAX_ATTRS + 1;\r\npower_zone->zone_dev_attrs = kzalloc(sizeof(void *) *\r\nnr_attrs, GFP_KERNEL);\r\nif (!power_zone->zone_dev_attrs)\r\ngoto err_attr_alloc;\r\ncreate_power_zone_common_attributes(power_zone);\r\nresult = create_constraints(power_zone, nr_constraints, const_ops);\r\nif (result)\r\ngoto err_dev_ret;\r\npower_zone->zone_dev_attrs[power_zone->zone_attr_count] = NULL;\r\npower_zone->dev_zone_attr_group.attrs = power_zone->zone_dev_attrs;\r\npower_zone->dev_attr_groups[0] = &power_zone->dev_zone_attr_group;\r\npower_zone->dev_attr_groups[1] = NULL;\r\npower_zone->dev.groups = power_zone->dev_attr_groups;\r\nresult = device_register(&power_zone->dev);\r\nif (result)\r\ngoto err_dev_ret;\r\ncontrol_type->nr_zones++;\r\nmutex_unlock(&control_type->lock);\r\nreturn power_zone;\r\nerr_dev_ret:\r\nkfree(power_zone->zone_dev_attrs);\r\nerr_attr_alloc:\r\nkfree(power_zone->constraints);\r\nerr_const_alloc:\r\nkfree(power_zone->name);\r\nerr_name_alloc:\r\nidr_remove(power_zone->parent_idr, power_zone->id);\r\nerr_idr_alloc:\r\nif (power_zone->allocated)\r\nkfree(power_zone);\r\nmutex_unlock(&control_type->lock);\r\nreturn ERR_PTR(result);\r\n}\r\nint powercap_unregister_zone(struct powercap_control_type *control_type,\r\nstruct powercap_zone *power_zone)\r\n{\r\nif (!power_zone || !control_type)\r\nreturn -EINVAL;\r\nmutex_lock(&control_type->lock);\r\ncontrol_type->nr_zones--;\r\nmutex_unlock(&control_type->lock);\r\ndevice_unregister(&power_zone->dev);\r\nreturn 0;\r\n}\r\nstruct powercap_control_type *powercap_register_control_type(\r\nstruct powercap_control_type *control_type,\r\nconst char *name,\r\nconst struct powercap_control_type_ops *ops)\r\n{\r\nint result;\r\nif (!name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (control_type) {\r\nif (!ops || !ops->release)\r\nreturn ERR_PTR(-EINVAL);\r\nmemset(control_type, 0, sizeof(*control_type));\r\n} else {\r\ncontrol_type = kzalloc(sizeof(*control_type), GFP_KERNEL);\r\nif (!control_type)\r\nreturn ERR_PTR(-ENOMEM);\r\ncontrol_type->allocated = true;\r\n}\r\nmutex_init(&control_type->lock);\r\ncontrol_type->ops = ops;\r\nINIT_LIST_HEAD(&control_type->node);\r\ncontrol_type->dev.class = &powercap_class;\r\ndev_set_name(&control_type->dev, "%s", name);\r\nresult = device_register(&control_type->dev);\r\nif (result) {\r\nif (control_type->allocated)\r\nkfree(control_type);\r\nreturn ERR_PTR(result);\r\n}\r\nidr_init(&control_type->idr);\r\nmutex_lock(&powercap_cntrl_list_lock);\r\nlist_add_tail(&control_type->node, &powercap_cntrl_list);\r\nmutex_unlock(&powercap_cntrl_list_lock);\r\nreturn control_type;\r\n}\r\nint powercap_unregister_control_type(struct powercap_control_type *control_type)\r\n{\r\nstruct powercap_control_type *pos = NULL;\r\nif (control_type->nr_zones) {\r\ndev_err(&control_type->dev, "Zones of this type still not freed\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&powercap_cntrl_list_lock);\r\nlist_for_each_entry(pos, &powercap_cntrl_list, node) {\r\nif (pos == control_type) {\r\nlist_del(&control_type->node);\r\nmutex_unlock(&powercap_cntrl_list_lock);\r\ndevice_unregister(&control_type->dev);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&powercap_cntrl_list_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init powercap_init(void)\r\n{\r\nint result = 0;\r\nresult = seed_constraint_attributes();\r\nif (result)\r\nreturn result;\r\nresult = class_register(&powercap_class);\r\nreturn result;\r\n}
