static bool malidp_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\nlong rate, req_rate = mode->crtc_clock * 1000;\r\nif (req_rate) {\r\nrate = clk_round_rate(hwdev->mclk, req_rate);\r\nif (rate < req_rate) {\r\nDRM_DEBUG_DRIVER("mclk clock unable to reach %d kHz\n",\r\nmode->crtc_clock);\r\nreturn false;\r\n}\r\nrate = clk_round_rate(hwdev->pxlclk, req_rate);\r\nif (rate != req_rate) {\r\nDRM_DEBUG_DRIVER("pxlclk doesn't support %ld Hz\n",\r\nreq_rate);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void malidp_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\nstruct videomode vm;\r\ndrm_display_mode_to_videomode(&crtc->state->adjusted_mode, &vm);\r\nclk_prepare_enable(hwdev->pxlclk);\r\nclk_set_rate(hwdev->mclk, crtc->state->adjusted_mode.crtc_clock * 1000);\r\nclk_set_rate(hwdev->pxlclk, crtc->state->adjusted_mode.crtc_clock * 1000);\r\nhwdev->modeset(hwdev, &vm);\r\nhwdev->leave_config_mode(hwdev);\r\ndrm_crtc_vblank_on(crtc);\r\n}\r\nstatic void malidp_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\ndrm_crtc_vblank_off(crtc);\r\nhwdev->enter_config_mode(hwdev);\r\nclk_disable_unprepare(hwdev->pxlclk);\r\n}\r\nstatic int malidp_crtc_atomic_check(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\r\nstruct malidp_hw_device *hwdev = malidp->dev;\r\nstruct drm_plane *plane;\r\nconst struct drm_plane_state *pstate;\r\nu32 rot_mem_free, rot_mem_usable;\r\nint rotated_planes = 0;\r\ndrm_atomic_crtc_state_for_each_plane_state(plane, pstate, state) {\r\nif (pstate->rotation & MALIDP_ROTATED_MASK)\r\nrotated_planes++;\r\n}\r\nrot_mem_free = hwdev->rotation_memory[0];\r\nif (rotated_planes > 1)\r\nrot_mem_free += hwdev->rotation_memory[1];\r\ndrm_atomic_crtc_state_for_each_plane_state(plane, pstate, state) {\r\nstruct malidp_plane *mp = to_malidp_plane(plane);\r\nstruct malidp_plane_state *ms = to_malidp_plane_state(pstate);\r\nif (pstate->rotation & MALIDP_ROTATED_MASK) {\r\nrotated_planes--;\r\nif (!rotated_planes) {\r\nrot_mem_usable = rot_mem_free;\r\n} else {\r\nif ((mp->layer->id != DE_VIDEO1) ||\r\n(hwdev->rotation_memory[1] == 0))\r\nrot_mem_usable = rot_mem_free / 2;\r\nelse\r\nrot_mem_usable = hwdev->rotation_memory[0];\r\n}\r\nrot_mem_free -= rot_mem_usable;\r\nif (ms->rotmem_size > rot_mem_usable)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint malidp_crtc_init(struct drm_device *drm)\r\n{\r\nstruct malidp_drm *malidp = drm->dev_private;\r\nstruct drm_plane *primary = NULL, *plane;\r\nint ret;\r\nret = malidp_de_planes_init(drm);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to initialise planes\n");\r\nreturn ret;\r\n}\r\ndrm_for_each_plane(plane, drm) {\r\nif (plane->type == DRM_PLANE_TYPE_PRIMARY) {\r\nprimary = plane;\r\nbreak;\r\n}\r\n}\r\nif (!primary) {\r\nDRM_ERROR("no primary plane found\n");\r\nret = -EINVAL;\r\ngoto crtc_cleanup_planes;\r\n}\r\nret = drm_crtc_init_with_planes(drm, &malidp->crtc, primary, NULL,\r\n&malidp_crtc_funcs, NULL);\r\nif (!ret) {\r\ndrm_crtc_helper_add(&malidp->crtc, &malidp_crtc_helper_funcs);\r\nreturn 0;\r\n}\r\ncrtc_cleanup_planes:\r\nmalidp_de_planes_destroy(drm);\r\nreturn ret;\r\n}
