void vexpress_config_set_master(u32 site)\r\n{\r\nvexpress_config_site_master = site;\r\n}\r\nu32 vexpress_config_get_master(void)\r\n{\r\nreturn vexpress_config_site_master;\r\n}\r\nvoid vexpress_config_lock(void *arg)\r\n{\r\nmutex_lock(&vexpress_config_mutex);\r\n}\r\nvoid vexpress_config_unlock(void *arg)\r\n{\r\nmutex_unlock(&vexpress_config_mutex);\r\n}\r\nstatic void vexpress_config_find_prop(struct device_node *node,\r\nconst char *name, u32 *val)\r\n{\r\n*val = 0;\r\nof_node_get(node);\r\nwhile (node) {\r\nif (of_property_read_u32(node, name, val) == 0) {\r\nof_node_put(node);\r\nreturn;\r\n}\r\nnode = of_get_next_parent(node);\r\n}\r\n}\r\nint vexpress_config_get_topo(struct device_node *node, u32 *site,\r\nu32 *position, u32 *dcc)\r\n{\r\nvexpress_config_find_prop(node, "arm,vexpress,site", site);\r\nif (*site == VEXPRESS_SITE_MASTER)\r\n*site = vexpress_config_site_master;\r\nif (WARN_ON(vexpress_config_site_master == VEXPRESS_SITE_MASTER))\r\nreturn -EINVAL;\r\nvexpress_config_find_prop(node, "arm,vexpress,position", position);\r\nvexpress_config_find_prop(node, "arm,vexpress,dcc", dcc);\r\nreturn 0;\r\n}\r\nstatic void vexpress_config_devres_release(struct device *dev, void *res)\r\n{\r\nstruct vexpress_config_bridge *bridge = dev_get_drvdata(dev->parent);\r\nstruct regmap *regmap = res;\r\nbridge->ops->regmap_exit(regmap, bridge->context);\r\n}\r\nstruct regmap *devm_regmap_init_vexpress_config(struct device *dev)\r\n{\r\nstruct vexpress_config_bridge *bridge;\r\nstruct regmap *regmap;\r\nstruct regmap **res;\r\nif (WARN_ON(dev->parent->class != vexpress_config_class))\r\nreturn ERR_PTR(-ENODEV);\r\nbridge = dev_get_drvdata(dev->parent);\r\nif (WARN_ON(!bridge))\r\nreturn ERR_PTR(-EINVAL);\r\nres = devres_alloc(vexpress_config_devres_release, sizeof(*res),\r\nGFP_KERNEL);\r\nif (!res)\r\nreturn ERR_PTR(-ENOMEM);\r\nregmap = (bridge->ops->regmap_init)(dev, bridge->context);\r\nif (IS_ERR(regmap)) {\r\ndevres_free(res);\r\nreturn regmap;\r\n}\r\n*res = regmap;\r\ndevres_add(dev, res);\r\nreturn regmap;\r\n}\r\nstruct device *vexpress_config_bridge_register(struct device *parent,\r\nstruct vexpress_config_bridge_ops *ops, void *context)\r\n{\r\nstruct device *dev;\r\nstruct vexpress_config_bridge *bridge;\r\nif (!vexpress_config_class) {\r\nvexpress_config_class = class_create(THIS_MODULE,\r\n"vexpress-config");\r\nif (IS_ERR(vexpress_config_class))\r\nreturn (void *)vexpress_config_class;\r\n}\r\ndev = device_create(vexpress_config_class, parent, 0,\r\nNULL, "%s.bridge", dev_name(parent));\r\nif (IS_ERR(dev))\r\nreturn dev;\r\nbridge = devm_kmalloc(dev, sizeof(*bridge), GFP_KERNEL);\r\nif (!bridge) {\r\nput_device(dev);\r\ndevice_unregister(dev);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nbridge->ops = ops;\r\nbridge->context = context;\r\ndev_set_drvdata(dev, bridge);\r\ndev_dbg(parent, "Registered bridge '%s', parent node %p\n",\r\ndev_name(dev), parent->of_node);\r\nreturn dev;\r\n}\r\nstatic int vexpress_config_node_match(struct device *dev, const void *data)\r\n{\r\nconst struct device_node *node = data;\r\ndev_dbg(dev, "Parent node %p, looking for %p\n",\r\ndev->parent->of_node, node);\r\nreturn dev->parent->of_node == node;\r\n}\r\nstatic int vexpress_config_populate(struct device_node *node)\r\n{\r\nstruct device_node *bridge;\r\nstruct device *parent;\r\nbridge = of_parse_phandle(node, "arm,vexpress,config-bridge", 0);\r\nif (!bridge)\r\nreturn -EINVAL;\r\nparent = class_find_device(vexpress_config_class, NULL, bridge,\r\nvexpress_config_node_match);\r\nof_node_put(bridge);\r\nif (WARN_ON(!parent))\r\nreturn -ENODEV;\r\nreturn of_platform_populate(node, NULL, NULL, parent);\r\n}\r\nstatic int __init vexpress_config_init(void)\r\n{\r\nint err = 0;\r\nstruct device_node *node;\r\nfor_each_compatible_node(node, NULL, "arm,vexpress,config-bus") {\r\nerr = vexpress_config_populate(node);\r\nif (err) {\r\nof_node_put(node);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}
