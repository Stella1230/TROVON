static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fractional_divider *fd = to_clk_fd(hw);\r\nunsigned long flags = 0;\r\nunsigned long m, n;\r\nu32 val;\r\nu64 ret;\r\nif (fd->lock)\r\nspin_lock_irqsave(fd->lock, flags);\r\nelse\r\n__acquire(fd->lock);\r\nval = clk_readl(fd->reg);\r\nif (fd->lock)\r\nspin_unlock_irqrestore(fd->lock, flags);\r\nelse\r\n__release(fd->lock);\r\nm = (val & fd->mmask) >> fd->mshift;\r\nn = (val & fd->nmask) >> fd->nshift;\r\nif (!n || !m)\r\nreturn parent_rate;\r\nret = (u64)parent_rate * m;\r\ndo_div(ret, n);\r\nreturn ret;\r\n}\r\nstatic long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct clk_fractional_divider *fd = to_clk_fd(hw);\r\nunsigned long scale;\r\nunsigned long m, n;\r\nu64 ret;\r\nif (!rate || rate >= *parent_rate)\r\nreturn *parent_rate;\r\nscale = fls_long(*parent_rate / rate - 1);\r\nif (scale > fd->nwidth)\r\nrate <<= scale - fd->nwidth;\r\nrational_best_approximation(rate, *parent_rate,\r\nGENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),\r\n&m, &n);\r\nret = (u64)*parent_rate * m;\r\ndo_div(ret, n);\r\nreturn ret;\r\n}\r\nstatic int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fractional_divider *fd = to_clk_fd(hw);\r\nunsigned long flags = 0;\r\nunsigned long m, n;\r\nu32 val;\r\nrational_best_approximation(rate, parent_rate,\r\nGENMASK(fd->mwidth - 1, 0), GENMASK(fd->nwidth - 1, 0),\r\n&m, &n);\r\nif (fd->lock)\r\nspin_lock_irqsave(fd->lock, flags);\r\nelse\r\n__acquire(fd->lock);\r\nval = clk_readl(fd->reg);\r\nval &= ~(fd->mmask | fd->nmask);\r\nval |= (m << fd->mshift) | (n << fd->nshift);\r\nclk_writel(val, fd->reg);\r\nif (fd->lock)\r\nspin_unlock_irqrestore(fd->lock, flags);\r\nelse\r\n__release(fd->lock);\r\nreturn 0;\r\n}\r\nstruct clk_hw *clk_hw_register_fractional_divider(struct device *dev,\r\nconst char *name, const char *parent_name, unsigned long flags,\r\nvoid __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,\r\nu8 clk_divider_flags, spinlock_t *lock)\r\n{\r\nstruct clk_fractional_divider *fd;\r\nstruct clk_init_data init;\r\nstruct clk_hw *hw;\r\nint ret;\r\nfd = kzalloc(sizeof(*fd), GFP_KERNEL);\r\nif (!fd)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &clk_fractional_divider_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\nfd->reg = reg;\r\nfd->mshift = mshift;\r\nfd->mwidth = mwidth;\r\nfd->mmask = GENMASK(mwidth - 1, 0) << mshift;\r\nfd->nshift = nshift;\r\nfd->nwidth = nwidth;\r\nfd->nmask = GENMASK(nwidth - 1, 0) << nshift;\r\nfd->flags = clk_divider_flags;\r\nfd->lock = lock;\r\nfd->hw.init = &init;\r\nhw = &fd->hw;\r\nret = clk_hw_register(dev, hw);\r\nif (ret) {\r\nkfree(fd);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstruct clk *clk_register_fractional_divider(struct device *dev,\r\nconst char *name, const char *parent_name, unsigned long flags,\r\nvoid __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,\r\nu8 clk_divider_flags, spinlock_t *lock)\r\n{\r\nstruct clk_hw *hw;\r\nhw = clk_hw_register_fractional_divider(dev, name, parent_name, flags,\r\nreg, mshift, mwidth, nshift, nwidth, clk_divider_flags,\r\nlock);\r\nif (IS_ERR(hw))\r\nreturn ERR_CAST(hw);\r\nreturn hw->clk;\r\n}\r\nvoid clk_hw_unregister_fractional_divider(struct clk_hw *hw)\r\n{\r\nstruct clk_fractional_divider *fd;\r\nfd = to_clk_fd(hw);\r\nclk_hw_unregister(hw);\r\nkfree(fd);\r\n}
