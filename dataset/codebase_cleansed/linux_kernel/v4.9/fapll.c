static bool ti_fapll_clock_is_bypass(struct fapll_data *fd)\r\n{\r\nu32 v = readl_relaxed(fd->base);\r\nif (fd->bypass_bit_inverted)\r\nreturn !(v & FAPLL_MAIN_BP);\r\nelse\r\nreturn !!(v & FAPLL_MAIN_BP);\r\n}\r\nstatic void ti_fapll_set_bypass(struct fapll_data *fd)\r\n{\r\nu32 v = readl_relaxed(fd->base);\r\nif (fd->bypass_bit_inverted)\r\nv &= ~FAPLL_MAIN_BP;\r\nelse\r\nv |= FAPLL_MAIN_BP;\r\nwritel_relaxed(v, fd->base);\r\n}\r\nstatic void ti_fapll_clear_bypass(struct fapll_data *fd)\r\n{\r\nu32 v = readl_relaxed(fd->base);\r\nif (fd->bypass_bit_inverted)\r\nv |= FAPLL_MAIN_BP;\r\nelse\r\nv &= ~FAPLL_MAIN_BP;\r\nwritel_relaxed(v, fd->base);\r\n}\r\nstatic int ti_fapll_wait_lock(struct fapll_data *fd)\r\n{\r\nint retries = FAPLL_MAX_RETRIES;\r\nu32 v;\r\nwhile ((v = readl_relaxed(fd->base))) {\r\nif (v & FAPLL_MAIN_LOCK)\r\nreturn 0;\r\nif (retries-- <= 0)\r\nbreak;\r\nudelay(1);\r\n}\r\npr_err("%s failed to lock\n", fd->name);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ti_fapll_enable(struct clk_hw *hw)\r\n{\r\nstruct fapll_data *fd = to_fapll(hw);\r\nu32 v = readl_relaxed(fd->base);\r\nv |= FAPLL_MAIN_PLLEN;\r\nwritel_relaxed(v, fd->base);\r\nti_fapll_wait_lock(fd);\r\nreturn 0;\r\n}\r\nstatic void ti_fapll_disable(struct clk_hw *hw)\r\n{\r\nstruct fapll_data *fd = to_fapll(hw);\r\nu32 v = readl_relaxed(fd->base);\r\nv &= ~FAPLL_MAIN_PLLEN;\r\nwritel_relaxed(v, fd->base);\r\n}\r\nstatic int ti_fapll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct fapll_data *fd = to_fapll(hw);\r\nu32 v = readl_relaxed(fd->base);\r\nreturn v & FAPLL_MAIN_PLLEN;\r\n}\r\nstatic unsigned long ti_fapll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct fapll_data *fd = to_fapll(hw);\r\nu32 fapll_n, fapll_p, v;\r\nu64 rate;\r\nif (ti_fapll_clock_is_bypass(fd))\r\nreturn parent_rate;\r\nrate = parent_rate;\r\nv = readl_relaxed(fd->base);\r\nfapll_p = (v >> 8) & 0xff;\r\nif (fapll_p)\r\ndo_div(rate, fapll_p);\r\nfapll_n = v >> 16;\r\nif (fapll_n)\r\nrate *= fapll_n;\r\nreturn rate;\r\n}\r\nstatic u8 ti_fapll_get_parent(struct clk_hw *hw)\r\n{\r\nstruct fapll_data *fd = to_fapll(hw);\r\nif (ti_fapll_clock_is_bypass(fd))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ti_fapll_set_div_mult(unsigned long rate,\r\nunsigned long parent_rate,\r\nu32 *pre_div_p, u32 *mult_n)\r\n{\r\nif (rate < parent_rate) {\r\npr_warn("FAPLL main divider rates unsupported\n");\r\nreturn -EINVAL;\r\n}\r\n*mult_n = rate / parent_rate;\r\nif (*mult_n > FAPLL_MAIN_MAX_MULT_N)\r\nreturn -EINVAL;\r\n*pre_div_p = 1;\r\nreturn 0;\r\n}\r\nstatic long ti_fapll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nu32 pre_div_p, mult_n;\r\nint error;\r\nif (!rate)\r\nreturn -EINVAL;\r\nerror = ti_fapll_set_div_mult(rate, *parent_rate,\r\n&pre_div_p, &mult_n);\r\nif (error)\r\nreturn error;\r\nrate = *parent_rate / pre_div_p;\r\nrate *= mult_n;\r\nreturn rate;\r\n}\r\nstatic int ti_fapll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct fapll_data *fd = to_fapll(hw);\r\nu32 pre_div_p, mult_n, v;\r\nint error;\r\nif (!rate)\r\nreturn -EINVAL;\r\nerror = ti_fapll_set_div_mult(rate, parent_rate,\r\n&pre_div_p, &mult_n);\r\nif (error)\r\nreturn error;\r\nti_fapll_set_bypass(fd);\r\nv = readl_relaxed(fd->base);\r\nv &= ~FAPLL_MAIN_CLEAR_MASK;\r\nv |= pre_div_p << FAPLL_MAIN_DIV_P_SHIFT;\r\nv |= mult_n << FAPLL_MAIN_MULT_N_SHIFT;\r\nwritel_relaxed(v, fd->base);\r\nif (ti_fapll_is_enabled(hw))\r\nti_fapll_wait_lock(fd);\r\nti_fapll_clear_bypass(fd);\r\nreturn 0;\r\n}\r\nstatic int ti_fapll_synth_enable(struct clk_hw *hw)\r\n{\r\nstruct fapll_synth *synth = to_synth(hw);\r\nu32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);\r\nv &= ~(1 << synth->index);\r\nwritel_relaxed(v, synth->fd->base + FAPLL_PWD_OFFSET);\r\nreturn 0;\r\n}\r\nstatic void ti_fapll_synth_disable(struct clk_hw *hw)\r\n{\r\nstruct fapll_synth *synth = to_synth(hw);\r\nu32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);\r\nv |= 1 << synth->index;\r\nwritel_relaxed(v, synth->fd->base + FAPLL_PWD_OFFSET);\r\n}\r\nstatic int ti_fapll_synth_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct fapll_synth *synth = to_synth(hw);\r\nu32 v = readl_relaxed(synth->fd->base + FAPLL_PWD_OFFSET);\r\nreturn !(v & (1 << synth->index));\r\n}\r\nstatic unsigned long ti_fapll_synth_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct fapll_synth *synth = to_synth(hw);\r\nu32 synth_div_m;\r\nu64 rate;\r\nif (!synth->div)\r\nreturn 32768;\r\nif (ti_fapll_clock_is_bypass(synth->fd))\r\nreturn parent_rate;\r\nrate = parent_rate;\r\nif (synth->freq) {\r\nu32 v, synth_int_div, synth_frac_div, synth_div_freq;\r\nv = readl_relaxed(synth->freq);\r\nsynth_int_div = (v >> 24) & 0xf;\r\nsynth_frac_div = v & 0xffffff;\r\nsynth_div_freq = (synth_int_div * 10000000) + synth_frac_div;\r\nrate *= 10000000;\r\ndo_div(rate, synth_div_freq);\r\nrate *= SYNTH_PHASE_K;\r\n}\r\nsynth_div_m = readl_relaxed(synth->div) & SYNTH_MAX_DIV_M;\r\nreturn DIV_ROUND_UP_ULL(rate, synth_div_m);\r\n}\r\nstatic unsigned long ti_fapll_synth_get_frac_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct fapll_synth *synth = to_synth(hw);\r\nunsigned long current_rate, frac_rate;\r\nu32 post_div_m;\r\ncurrent_rate = ti_fapll_synth_recalc_rate(hw, parent_rate);\r\npost_div_m = readl_relaxed(synth->div) & SYNTH_MAX_DIV_M;\r\nfrac_rate = current_rate * post_div_m;\r\nreturn frac_rate;\r\n}\r\nstatic u32 ti_fapll_synth_set_frac_rate(struct fapll_synth *synth,\r\nunsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nu32 post_div_m, synth_int_div = 0, synth_frac_div = 0, v;\r\npost_div_m = DIV_ROUND_UP_ULL((u64)parent_rate * SYNTH_PHASE_K, rate);\r\npost_div_m = post_div_m / SYNTH_MAX_INT_DIV;\r\nif (post_div_m > SYNTH_MAX_DIV_M)\r\nreturn -EINVAL;\r\nif (!post_div_m)\r\npost_div_m = 1;\r\nfor (; post_div_m < SYNTH_MAX_DIV_M; post_div_m++) {\r\nsynth_int_div = DIV_ROUND_UP_ULL((u64)parent_rate *\r\nSYNTH_PHASE_K *\r\n10000000,\r\nrate * post_div_m);\r\nsynth_frac_div = synth_int_div % 10000000;\r\nsynth_int_div /= 10000000;\r\nif (synth_int_div <= SYNTH_MAX_INT_DIV)\r\nbreak;\r\n}\r\nif (synth_int_div > SYNTH_MAX_INT_DIV)\r\nreturn -EINVAL;\r\nv = readl_relaxed(synth->freq);\r\nv &= ~0x1fffffff;\r\nv |= (synth_int_div & SYNTH_MAX_INT_DIV) << 24;\r\nv |= (synth_frac_div & 0xffffff);\r\nv |= SYNTH_LDFREQ;\r\nwritel_relaxed(v, synth->freq);\r\nreturn post_div_m;\r\n}\r\nstatic long ti_fapll_synth_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct fapll_synth *synth = to_synth(hw);\r\nstruct fapll_data *fd = synth->fd;\r\nunsigned long r;\r\nif (ti_fapll_clock_is_bypass(fd) || !synth->div || !rate)\r\nreturn -EINVAL;\r\nif (!synth->freq) {\r\nunsigned long frac_rate;\r\nu32 synth_post_div_m;\r\nfrac_rate = ti_fapll_synth_get_frac_rate(hw, *parent_rate);\r\nsynth_post_div_m = DIV_ROUND_UP(frac_rate, rate);\r\nr = DIV_ROUND_UP(frac_rate, synth_post_div_m);\r\ngoto out;\r\n}\r\nr = *parent_rate * SYNTH_PHASE_K;\r\nif (rate > r)\r\ngoto out;\r\nr = DIV_ROUND_UP_ULL(r, SYNTH_MAX_INT_DIV * SYNTH_MAX_DIV_M);\r\nif (rate < r)\r\ngoto out;\r\nr = rate;\r\nout:\r\nreturn r;\r\n}\r\nstatic int ti_fapll_synth_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct fapll_synth *synth = to_synth(hw);\r\nstruct fapll_data *fd = synth->fd;\r\nunsigned long frac_rate, post_rate = 0;\r\nu32 post_div_m = 0, v;\r\nif (ti_fapll_clock_is_bypass(fd) || !synth->div || !rate)\r\nreturn -EINVAL;\r\nfrac_rate = ti_fapll_synth_get_frac_rate(hw, parent_rate);\r\nif (frac_rate < rate) {\r\nif (!synth->freq)\r\nreturn -EINVAL;\r\n} else {\r\npost_div_m = DIV_ROUND_UP(frac_rate, rate);\r\nif (post_div_m && (post_div_m <= SYNTH_MAX_DIV_M))\r\npost_rate = DIV_ROUND_UP(frac_rate, post_div_m);\r\nif (!synth->freq && !post_rate)\r\nreturn -EINVAL;\r\n}\r\nif ((post_rate != rate) && synth->freq)\r\npost_div_m = ti_fapll_synth_set_frac_rate(synth,\r\nrate,\r\nparent_rate);\r\nv = readl_relaxed(synth->div);\r\nv &= ~SYNTH_MAX_DIV_M;\r\nv |= post_div_m;\r\nv |= SYNTH_LDMDIV1;\r\nwritel_relaxed(v, synth->div);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init ti_fapll_synth_setup(struct fapll_data *fd,\r\nvoid __iomem *freq,\r\nvoid __iomem *div,\r\nint index,\r\nconst char *name,\r\nconst char *parent,\r\nstruct clk *pll_clk)\r\n{\r\nstruct clk_init_data *init;\r\nstruct fapll_synth *synth;\r\ninit = kzalloc(sizeof(*init), GFP_KERNEL);\r\nif (!init)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit->ops = &ti_fapll_synt_ops;\r\ninit->name = name;\r\ninit->parent_names = &parent;\r\ninit->num_parents = 1;\r\nsynth = kzalloc(sizeof(*synth), GFP_KERNEL);\r\nif (!synth)\r\ngoto free;\r\nsynth->fd = fd;\r\nsynth->index = index;\r\nsynth->freq = freq;\r\nsynth->div = div;\r\nsynth->name = name;\r\nsynth->hw.init = init;\r\nsynth->clk_pll = pll_clk;\r\nreturn clk_register(NULL, &synth->hw);\r\nfree:\r\nkfree(synth);\r\nkfree(init);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void __init ti_fapll_setup(struct device_node *node)\r\n{\r\nstruct fapll_data *fd;\r\nstruct clk_init_data *init = NULL;\r\nconst char *parent_name[2];\r\nstruct clk *pll_clk;\r\nint i;\r\nfd = kzalloc(sizeof(*fd), GFP_KERNEL);\r\nif (!fd)\r\nreturn;\r\nfd->outputs.clks = kzalloc(sizeof(struct clk *) *\r\nMAX_FAPLL_OUTPUTS + 1,\r\nGFP_KERNEL);\r\nif (!fd->outputs.clks)\r\ngoto free;\r\ninit = kzalloc(sizeof(*init), GFP_KERNEL);\r\nif (!init)\r\ngoto free;\r\ninit->ops = &ti_fapll_ops;\r\ninit->name = node->name;\r\ninit->num_parents = of_clk_get_parent_count(node);\r\nif (init->num_parents != 2) {\r\npr_err("%s must have two parents\n", node->name);\r\ngoto free;\r\n}\r\nof_clk_parent_fill(node, parent_name, 2);\r\ninit->parent_names = parent_name;\r\nfd->clk_ref = of_clk_get(node, 0);\r\nif (IS_ERR(fd->clk_ref)) {\r\npr_err("%s could not get clk_ref\n", node->name);\r\ngoto free;\r\n}\r\nfd->clk_bypass = of_clk_get(node, 1);\r\nif (IS_ERR(fd->clk_bypass)) {\r\npr_err("%s could not get clk_bypass\n", node->name);\r\ngoto free;\r\n}\r\nfd->base = of_iomap(node, 0);\r\nif (!fd->base) {\r\npr_err("%s could not get IO base\n", node->name);\r\ngoto free;\r\n}\r\nif (fapll_is_ddr_pll(fd->base))\r\nfd->bypass_bit_inverted = true;\r\nfd->name = node->name;\r\nfd->hw.init = init;\r\npll_clk = clk_register(NULL, &fd->hw);\r\nif (IS_ERR(pll_clk))\r\ngoto unmap;\r\nfd->outputs.clks[0] = pll_clk;\r\nfd->outputs.clk_num++;\r\nfor (i = 0; i < MAX_FAPLL_OUTPUTS; i++) {\r\nconst char *output_name;\r\nvoid __iomem *freq, *div;\r\nstruct clk *synth_clk;\r\nint output_instance;\r\nu32 v;\r\nif (of_property_read_string_index(node, "clock-output-names",\r\ni, &output_name))\r\ncontinue;\r\nif (of_property_read_u32_index(node, "clock-indices", i,\r\n&output_instance))\r\noutput_instance = i;\r\nfreq = fd->base + (output_instance * 8);\r\ndiv = freq + 4;\r\nif (is_audio_pll_clk1(freq)) {\r\nfreq = NULL;\r\ndiv = NULL;\r\n} else {\r\nv = readl_relaxed(freq);\r\nif (!v)\r\nfreq = NULL;\r\n}\r\nsynth_clk = ti_fapll_synth_setup(fd, freq, div, output_instance,\r\noutput_name, node->name,\r\npll_clk);\r\nif (IS_ERR(synth_clk))\r\ncontinue;\r\nfd->outputs.clks[output_instance] = synth_clk;\r\nfd->outputs.clk_num++;\r\nclk_register_clkdev(synth_clk, output_name, NULL);\r\n}\r\nof_clk_add_provider(node, of_clk_src_onecell_get, &fd->outputs);\r\nkfree(init);\r\nreturn;\r\nunmap:\r\niounmap(fd->base);\r\nfree:\r\nif (fd->clk_bypass)\r\nclk_put(fd->clk_bypass);\r\nif (fd->clk_ref)\r\nclk_put(fd->clk_ref);\r\nkfree(fd->outputs.clks);\r\nkfree(fd);\r\nkfree(init);\r\n}
