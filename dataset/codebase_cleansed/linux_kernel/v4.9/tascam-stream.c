static int get_clock(struct snd_tscm *tscm, u32 *data)\r\n{\r\n__be32 reg;\r\nint err;\r\nerr = snd_fw_transaction(tscm->unit, TCODE_READ_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_CLOCK_STATUS,\r\n&reg, sizeof(reg), 0);\r\nif (err >= 0)\r\n*data = be32_to_cpu(reg);\r\nreturn err;\r\n}\r\nstatic int set_clock(struct snd_tscm *tscm, unsigned int rate,\r\nenum snd_tscm_clock clock)\r\n{\r\nu32 data;\r\n__be32 reg;\r\nint err;\r\nerr = get_clock(tscm, &data);\r\nif (err < 0)\r\nreturn err;\r\ndata &= 0x0000ffff;\r\nif (rate > 0) {\r\ndata &= 0x000000ff;\r\nif ((rate % 44100) == 0) {\r\ndata |= 0x00000100;\r\nif (rate / 44100 == 2)\r\ndata |= 0x00008000;\r\n} else if ((rate % 48000) == 0) {\r\ndata |= 0x00000200;\r\nif (rate / 48000 == 2)\r\ndata |= 0x00008000;\r\n} else {\r\nreturn -EAGAIN;\r\n}\r\n}\r\nif (clock != INT_MAX) {\r\ndata &= 0x0000ff00;\r\ndata |= clock + 1;\r\n}\r\nreg = cpu_to_be32(data);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_CLOCK_STATUS,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nif (data & 0x00008000)\r\nreg = cpu_to_be32(0x0000001a);\r\nelse\r\nreg = cpu_to_be32(0x0000000d);\r\nreturn snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MULTIPLEX_MODE,\r\n&reg, sizeof(reg), 0);\r\n}\r\nint snd_tscm_stream_get_rate(struct snd_tscm *tscm, unsigned int *rate)\r\n{\r\nu32 data = 0x0;\r\nunsigned int trials = 0;\r\nint err;\r\nwhile (data == 0x0 || trials++ < 5) {\r\nerr = get_clock(tscm, &data);\r\nif (err < 0)\r\nreturn err;\r\ndata = (data & 0xff000000) >> 24;\r\n}\r\nif ((data & 0x0f) == 0x01)\r\n*rate = 44100;\r\nelse if ((data & 0x0f) == 0x02)\r\n*rate = 48000;\r\nelse\r\nreturn -EAGAIN;\r\nif ((data & 0xf0) == 0x80)\r\n*rate *= 2;\r\nelse if ((data & 0xf0) != 0x00)\r\nreturn -EAGAIN;\r\nreturn err;\r\n}\r\nint snd_tscm_stream_get_clock(struct snd_tscm *tscm, enum snd_tscm_clock *clock)\r\n{\r\nu32 data;\r\nint err;\r\nerr = get_clock(tscm, &data);\r\nif (err < 0)\r\nreturn err;\r\n*clock = ((data & 0x00ff0000) >> 16) - 1;\r\nif (*clock < 0 || *clock > SND_TSCM_CLOCK_ADAT)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int enable_data_channels(struct snd_tscm *tscm)\r\n{\r\n__be32 reg;\r\nu32 data;\r\nunsigned int i;\r\nint err;\r\ndata = 0;\r\nfor (i = 0; i < tscm->spec->pcm_capture_analog_channels; ++i)\r\ndata |= BIT(i);\r\nif (tscm->spec->has_adat)\r\ndata |= 0x0000ff00;\r\nif (tscm->spec->has_spdif)\r\ndata |= 0x00030000;\r\nreg = cpu_to_be32(data);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_TX_PCM_CHANNELS,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\ndata = 0;\r\nfor (i = 0; i < tscm->spec->pcm_playback_analog_channels; ++i)\r\ndata |= BIT(i);\r\nif (tscm->spec->has_adat)\r\ndata |= 0x0000ff00;\r\nif (tscm->spec->has_spdif)\r\ndata |= 0x00030000;\r\nreg = cpu_to_be32(data);\r\nreturn snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_RX_PCM_CHANNELS,\r\n&reg, sizeof(reg), 0);\r\n}\r\nstatic int set_stream_formats(struct snd_tscm *tscm, unsigned int rate)\r\n{\r\n__be32 reg;\r\nint err;\r\nreg = cpu_to_be32(0x00200000);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_SET_OPTION,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = enable_data_channels(tscm);\r\nif (err < 0)\r\nreturn err;\r\nreturn set_clock(tscm, rate, INT_MAX);\r\n}\r\nstatic void finish_session(struct snd_tscm *tscm)\r\n{\r\n__be32 reg;\r\nreg = 0;\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_START_STREAMING,\r\n&reg, sizeof(reg), 0);\r\nreg = 0;\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_ISOC_RX_ON,\r\n&reg, sizeof(reg), 0);\r\n}\r\nstatic int begin_session(struct snd_tscm *tscm)\r\n{\r\n__be32 reg;\r\nint err;\r\nreg = cpu_to_be32(0x00000001);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_START_STREAMING,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(0x00000001);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_ISOC_RX_ON,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(0x00002000);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_SET_OPTION,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(0x00000001);\r\nreturn snd_fw_transaction(tscm->unit,\r\nTCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_ISOC_TX_ON,\r\n&reg, sizeof(reg), 0);\r\n}\r\nstatic void release_resources(struct snd_tscm *tscm)\r\n{\r\n__be32 reg;\r\nreg = cpu_to_be32(0x00000000);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_ISOC_TX_CH,\r\n&reg, sizeof(reg), 0);\r\nreg = cpu_to_be32(0x00000000);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_UNKNOWN,\r\n&reg, sizeof(reg), 0);\r\nreg = cpu_to_be32(0x00000000);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_ISOC_RX_CH,\r\n&reg, sizeof(reg), 0);\r\nfw_iso_resources_free(&tscm->tx_resources);\r\nfw_iso_resources_free(&tscm->rx_resources);\r\n}\r\nstatic int keep_resources(struct snd_tscm *tscm, unsigned int rate)\r\n{\r\n__be32 reg;\r\nint err;\r\nerr = amdtp_tscm_set_parameters(&tscm->tx_stream, rate);\r\nif (err < 0)\r\nreturn err;\r\nerr = fw_iso_resources_allocate(&tscm->tx_resources,\r\namdtp_stream_get_max_payload(&tscm->tx_stream),\r\nfw_parent_device(tscm->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\nerr = amdtp_tscm_set_parameters(&tscm->rx_stream, rate);\r\nif (err < 0)\r\nreturn err;\r\nerr = fw_iso_resources_allocate(&tscm->rx_resources,\r\namdtp_stream_get_max_payload(&tscm->rx_stream),\r\nfw_parent_device(tscm->unit)->max_speed);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(tscm->tx_resources.channel);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_ISOC_TX_CH,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\ngoto error;\r\nreg = cpu_to_be32(0x00000002);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_UNKNOWN,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\ngoto error;\r\nreg = cpu_to_be32(tscm->rx_resources.channel);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_ISOC_RX_CH,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nrelease_resources(tscm);\r\nreturn err;\r\n}\r\nint snd_tscm_stream_init_duplex(struct snd_tscm *tscm)\r\n{\r\nunsigned int pcm_channels;\r\nint err;\r\nerr = fw_iso_resources_init(&tscm->rx_resources, tscm->unit);\r\nif (err < 0)\r\nreturn err;\r\npcm_channels = tscm->spec->pcm_playback_analog_channels;\r\nif (tscm->spec->has_adat)\r\npcm_channels += 8;\r\nif (tscm->spec->has_spdif)\r\npcm_channels += 2;\r\nerr = amdtp_tscm_init(&tscm->rx_stream, tscm->unit, AMDTP_OUT_STREAM,\r\npcm_channels);\r\nif (err < 0)\r\nreturn err;\r\nerr = fw_iso_resources_init(&tscm->tx_resources, tscm->unit);\r\nif (err < 0)\r\nreturn err;\r\npcm_channels = tscm->spec->pcm_capture_analog_channels;\r\nif (tscm->spec->has_adat)\r\npcm_channels += 8;\r\nif (tscm->spec->has_spdif)\r\npcm_channels += 2;\r\nerr = amdtp_tscm_init(&tscm->tx_stream, tscm->unit, AMDTP_IN_STREAM,\r\npcm_channels);\r\nif (err < 0)\r\namdtp_stream_destroy(&tscm->rx_stream);\r\nreturn 0;\r\n}\r\nvoid snd_tscm_stream_update_duplex(struct snd_tscm *tscm)\r\n{\r\namdtp_stream_pcm_abort(&tscm->tx_stream);\r\namdtp_stream_stop(&tscm->tx_stream);\r\namdtp_stream_pcm_abort(&tscm->rx_stream);\r\namdtp_stream_stop(&tscm->rx_stream);\r\n}\r\nvoid snd_tscm_stream_destroy_duplex(struct snd_tscm *tscm)\r\n{\r\namdtp_stream_destroy(&tscm->rx_stream);\r\namdtp_stream_destroy(&tscm->tx_stream);\r\nfw_iso_resources_destroy(&tscm->rx_resources);\r\nfw_iso_resources_destroy(&tscm->tx_resources);\r\n}\r\nint snd_tscm_stream_start_duplex(struct snd_tscm *tscm, unsigned int rate)\r\n{\r\nunsigned int curr_rate;\r\nint err;\r\nif (tscm->substreams_counter == 0)\r\nreturn 0;\r\nerr = snd_tscm_stream_get_rate(tscm, &curr_rate);\r\nif (err < 0)\r\nreturn err;\r\nif (curr_rate != rate ||\r\namdtp_streaming_error(&tscm->rx_stream) ||\r\namdtp_streaming_error(&tscm->tx_stream)) {\r\nfinish_session(tscm);\r\namdtp_stream_stop(&tscm->rx_stream);\r\namdtp_stream_stop(&tscm->tx_stream);\r\nrelease_resources(tscm);\r\n}\r\nif (!amdtp_stream_running(&tscm->rx_stream)) {\r\nerr = keep_resources(tscm, rate);\r\nif (err < 0)\r\ngoto error;\r\nerr = set_stream_formats(tscm, rate);\r\nif (err < 0)\r\ngoto error;\r\nerr = begin_session(tscm);\r\nif (err < 0)\r\ngoto error;\r\nerr = amdtp_stream_start(&tscm->rx_stream,\r\ntscm->rx_resources.channel,\r\nfw_parent_device(tscm->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\nif (!amdtp_stream_wait_callback(&tscm->rx_stream,\r\nCALLBACK_TIMEOUT)) {\r\nerr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\n}\r\nif (!amdtp_stream_running(&tscm->tx_stream)) {\r\nerr = amdtp_stream_start(&tscm->tx_stream,\r\ntscm->tx_resources.channel,\r\nfw_parent_device(tscm->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\nif (!amdtp_stream_wait_callback(&tscm->tx_stream,\r\nCALLBACK_TIMEOUT)) {\r\nerr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\namdtp_stream_stop(&tscm->rx_stream);\r\namdtp_stream_stop(&tscm->tx_stream);\r\nfinish_session(tscm);\r\nrelease_resources(tscm);\r\nreturn err;\r\n}\r\nvoid snd_tscm_stream_stop_duplex(struct snd_tscm *tscm)\r\n{\r\nif (tscm->substreams_counter > 0)\r\nreturn;\r\namdtp_stream_stop(&tscm->tx_stream);\r\namdtp_stream_stop(&tscm->rx_stream);\r\nfinish_session(tscm);\r\nrelease_resources(tscm);\r\n}\r\nvoid snd_tscm_stream_lock_changed(struct snd_tscm *tscm)\r\n{\r\ntscm->dev_lock_changed = true;\r\nwake_up(&tscm->hwdep_wait);\r\n}\r\nint snd_tscm_stream_lock_try(struct snd_tscm *tscm)\r\n{\r\nint err;\r\nspin_lock_irq(&tscm->lock);\r\nif (tscm->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto end;\r\n}\r\nif (tscm->dev_lock_count++ == 0)\r\nsnd_tscm_stream_lock_changed(tscm);\r\nerr = 0;\r\nend:\r\nspin_unlock_irq(&tscm->lock);\r\nreturn err;\r\n}\r\nvoid snd_tscm_stream_lock_release(struct snd_tscm *tscm)\r\n{\r\nspin_lock_irq(&tscm->lock);\r\nif (WARN_ON(tscm->dev_lock_count <= 0))\r\ngoto end;\r\nif (--tscm->dev_lock_count == 0)\r\nsnd_tscm_stream_lock_changed(tscm);\r\nend:\r\nspin_unlock_irq(&tscm->lock);\r\n}
