static int nlmsg_perm(u16 nlmsg_type, u32 *perm, struct nlmsg_perm *tab, size_t tabsize)\r\n{\r\nint i, err = -EINVAL;\r\nfor (i = 0; i < tabsize/sizeof(struct nlmsg_perm); i++)\r\nif (nlmsg_type == tab[i].nlmsg_type) {\r\n*perm = tab[i].perm;\r\nerr = 0;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint selinux_nlmsg_lookup(u16 sclass, u16 nlmsg_type, u32 *perm)\r\n{\r\nint err = 0;\r\nswitch (sclass) {\r\ncase SECCLASS_NETLINK_ROUTE_SOCKET:\r\nBUILD_BUG_ON(RTM_MAX != (RTM_NEWSTATS + 3));\r\nerr = nlmsg_perm(nlmsg_type, perm, nlmsg_route_perms,\r\nsizeof(nlmsg_route_perms));\r\nbreak;\r\ncase SECCLASS_NETLINK_TCPDIAG_SOCKET:\r\nerr = nlmsg_perm(nlmsg_type, perm, nlmsg_tcpdiag_perms,\r\nsizeof(nlmsg_tcpdiag_perms));\r\nbreak;\r\ncase SECCLASS_NETLINK_XFRM_SOCKET:\r\nBUILD_BUG_ON(XFRM_MSG_MAX != XFRM_MSG_MAPPING);\r\nerr = nlmsg_perm(nlmsg_type, perm, nlmsg_xfrm_perms,\r\nsizeof(nlmsg_xfrm_perms));\r\nbreak;\r\ncase SECCLASS_NETLINK_AUDIT_SOCKET:\r\nif ((nlmsg_type >= AUDIT_FIRST_USER_MSG &&\r\nnlmsg_type <= AUDIT_LAST_USER_MSG) ||\r\n(nlmsg_type >= AUDIT_FIRST_USER_MSG2 &&\r\nnlmsg_type <= AUDIT_LAST_USER_MSG2)) {\r\n*perm = NETLINK_AUDIT_SOCKET__NLMSG_RELAY;\r\n} else {\r\nerr = nlmsg_perm(nlmsg_type, perm, nlmsg_audit_perms,\r\nsizeof(nlmsg_audit_perms));\r\n}\r\nbreak;\r\ndefault:\r\nerr = -ENOENT;\r\nbreak;\r\n}\r\nreturn err;\r\n}
