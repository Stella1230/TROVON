static void vnet_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\n}\r\nstatic u32 vnet_get_msglevel(struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nreturn vp->msg_enable;\r\n}\r\nstatic void vnet_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nvp->msg_enable = value;\r\n}\r\nstatic struct vnet_port *__tx_port_find(struct vnet *vp, struct sk_buff *skb)\r\n{\r\nunsigned int hash = vnet_hashfn(skb->data);\r\nstruct hlist_head *hp = &vp->port_hash[hash];\r\nstruct vnet_port *port;\r\nhlist_for_each_entry_rcu(port, hp, hash) {\r\nif (!sunvnet_port_is_up_common(port))\r\ncontinue;\r\nif (ether_addr_equal(port->raddr, skb->data))\r\nreturn port;\r\n}\r\nlist_for_each_entry_rcu(port, &vp->port_list, list) {\r\nif (!port->switch_port)\r\ncontinue;\r\nif (!sunvnet_port_is_up_common(port))\r\ncontinue;\r\nreturn port;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct vnet_port *vnet_tx_port_find(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nreturn __tx_port_find(vp, skb);\r\n}\r\nstatic u16 vnet_select_queue(struct net_device *dev, struct sk_buff *skb,\r\nvoid *accel_priv, select_queue_fallback_t fallback)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nstruct vnet_port *port = __tx_port_find(vp, skb);\r\nif (!port)\r\nreturn 0;\r\nreturn port->q_index;\r\n}\r\nstatic int vnet_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nreturn sunvnet_start_xmit_common(skb, dev, vnet_tx_port_find);\r\n}\r\nstatic void vnet_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nreturn sunvnet_set_rx_mode_common(dev, vp);\r\n}\r\nstatic void vnet_poll_controller(struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nreturn sunvnet_poll_controller_common(dev, vp);\r\n}\r\nstatic struct vnet *vnet_new(const u64 *local_mac,\r\nstruct vio_dev *vdev)\r\n{\r\nstruct net_device *dev;\r\nstruct vnet *vp;\r\nint err, i;\r\ndev = alloc_etherdev_mqs(sizeof(*vp), VNET_MAX_TXQS, 1);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev->needed_headroom = VNET_PACKET_SKIP + 8;\r\ndev->needed_tailroom = 8;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = (*local_mac >> (5 - i) * 8) & 0xff;\r\nvp = netdev_priv(dev);\r\nspin_lock_init(&vp->lock);\r\nvp->dev = dev;\r\nINIT_LIST_HEAD(&vp->port_list);\r\nfor (i = 0; i < VNET_PORT_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&vp->port_hash[i]);\r\nINIT_LIST_HEAD(&vp->list);\r\nvp->local_mac = *local_mac;\r\ndev->netdev_ops = &vnet_ops;\r\ndev->ethtool_ops = &vnet_ethtool_ops;\r\ndev->watchdog_timeo = VNET_TX_TIMEOUT;\r\ndev->hw_features = NETIF_F_TSO | NETIF_F_GSO | NETIF_F_GSO_SOFTWARE |\r\nNETIF_F_HW_CSUM | NETIF_F_SG;\r\ndev->features = dev->hw_features;\r\nSET_NETDEV_DEV(dev, &vdev->dev);\r\nerr = register_netdev(dev);\r\nif (err) {\r\npr_err("Cannot register net device, aborting\n");\r\ngoto err_out_free_dev;\r\n}\r\nnetdev_info(dev, "Sun LDOM vnet %pM\n", dev->dev_addr);\r\nlist_add(&vp->list, &vnet_list);\r\nreturn vp;\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct vnet *vnet_find_or_create(const u64 *local_mac,\r\nstruct vio_dev *vdev)\r\n{\r\nstruct vnet *iter, *vp;\r\nmutex_lock(&vnet_list_mutex);\r\nvp = NULL;\r\nlist_for_each_entry(iter, &vnet_list, list) {\r\nif (iter->local_mac == *local_mac) {\r\nvp = iter;\r\nbreak;\r\n}\r\n}\r\nif (!vp)\r\nvp = vnet_new(local_mac, vdev);\r\nmutex_unlock(&vnet_list_mutex);\r\nreturn vp;\r\n}\r\nstatic void vnet_cleanup(void)\r\n{\r\nstruct vnet *vp;\r\nstruct net_device *dev;\r\nmutex_lock(&vnet_list_mutex);\r\nwhile (!list_empty(&vnet_list)) {\r\nvp = list_first_entry(&vnet_list, struct vnet, list);\r\nlist_del(&vp->list);\r\ndev = vp->dev;\r\nBUG_ON(!list_empty(&vp->port_list));\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\nmutex_unlock(&vnet_list_mutex);\r\n}\r\nstatic struct vnet *vnet_find_parent(struct mdesc_handle *hp,\r\nu64 port_node,\r\nstruct vio_dev *vdev)\r\n{\r\nconst u64 *local_mac = NULL;\r\nu64 a;\r\nmdesc_for_each_arc(a, hp, port_node, MDESC_ARC_TYPE_BACK) {\r\nu64 target = mdesc_arc_target(hp, a);\r\nconst char *name;\r\nname = mdesc_get_property(hp, target, "name", NULL);\r\nif (!name || strcmp(name, "network"))\r\ncontinue;\r\nlocal_mac = mdesc_get_property(hp, target,\r\nlocal_mac_prop, NULL);\r\nif (local_mac)\r\nbreak;\r\n}\r\nif (!local_mac)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn vnet_find_or_create(local_mac, vdev);\r\n}\r\nstatic void print_version(void)\r\n{\r\nprintk_once(KERN_INFO "%s", version);\r\n}\r\nstatic int vnet_port_probe(struct vio_dev *vdev, const struct vio_device_id *id)\r\n{\r\nstruct mdesc_handle *hp;\r\nstruct vnet_port *port;\r\nunsigned long flags;\r\nstruct vnet *vp;\r\nconst u64 *rmac;\r\nint len, i, err, switch_port;\r\nprint_version();\r\nhp = mdesc_grab();\r\nvp = vnet_find_parent(hp, vdev->mp, vdev);\r\nif (IS_ERR(vp)) {\r\npr_err("Cannot find port parent vnet\n");\r\nerr = PTR_ERR(vp);\r\ngoto err_out_put_mdesc;\r\n}\r\nrmac = mdesc_get_property(hp, vdev->mp, remote_macaddr_prop, &len);\r\nerr = -ENODEV;\r\nif (!rmac) {\r\npr_err("Port lacks %s property\n", remote_macaddr_prop);\r\ngoto err_out_put_mdesc;\r\n}\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!port)\r\ngoto err_out_put_mdesc;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nport->raddr[i] = (*rmac >> (5 - i) * 8) & 0xff;\r\nport->vp = vp;\r\nerr = vio_driver_init(&port->vio, vdev, VDEV_NETWORK,\r\nvnet_versions, ARRAY_SIZE(vnet_versions),\r\n&vnet_vio_ops, vp->dev->name);\r\nif (err)\r\ngoto err_out_free_port;\r\nerr = vio_ldc_alloc(&port->vio, &vnet_ldc_cfg, port);\r\nif (err)\r\ngoto err_out_free_port;\r\nnetif_napi_add(port->vp->dev, &port->napi, sunvnet_poll_common,\r\nNAPI_POLL_WEIGHT);\r\nINIT_HLIST_NODE(&port->hash);\r\nINIT_LIST_HEAD(&port->list);\r\nswitch_port = 0;\r\nif (mdesc_get_property(hp, vdev->mp, "switch-port", NULL))\r\nswitch_port = 1;\r\nport->switch_port = switch_port;\r\nport->tso = true;\r\nport->tsolen = 0;\r\nspin_lock_irqsave(&vp->lock, flags);\r\nif (switch_port)\r\nlist_add_rcu(&port->list, &vp->port_list);\r\nelse\r\nlist_add_tail_rcu(&port->list, &vp->port_list);\r\nhlist_add_head_rcu(&port->hash,\r\n&vp->port_hash[vnet_hashfn(port->raddr)]);\r\nsunvnet_port_add_txq_common(port);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\ndev_set_drvdata(&vdev->dev, port);\r\npr_info("%s: PORT ( remote-mac %pM%s )\n",\r\nvp->dev->name, port->raddr, switch_port ? " switch-port" : "");\r\nsetup_timer(&port->clean_timer, sunvnet_clean_timer_expire_common,\r\n(unsigned long)port);\r\nnapi_enable(&port->napi);\r\nvio_port_up(&port->vio);\r\nmdesc_release(hp);\r\nreturn 0;\r\nerr_out_free_port:\r\nkfree(port);\r\nerr_out_put_mdesc:\r\nmdesc_release(hp);\r\nreturn err;\r\n}\r\nstatic int vnet_port_remove(struct vio_dev *vdev)\r\n{\r\nstruct vnet_port *port = dev_get_drvdata(&vdev->dev);\r\nif (port) {\r\ndel_timer_sync(&port->vio.timer);\r\nnapi_disable(&port->napi);\r\nlist_del_rcu(&port->list);\r\nhlist_del_rcu(&port->hash);\r\nsynchronize_rcu();\r\ndel_timer_sync(&port->clean_timer);\r\nsunvnet_port_rm_txq_common(port);\r\nnetif_napi_del(&port->napi);\r\nsunvnet_port_free_tx_bufs_common(port);\r\nvio_ldc_free(&port->vio);\r\ndev_set_drvdata(&vdev->dev, NULL);\r\nkfree(port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init vnet_init(void)\r\n{\r\nreturn vio_register_driver(&vnet_port_driver);\r\n}\r\nstatic void __exit vnet_exit(void)\r\n{\r\nvio_unregister_driver(&vnet_port_driver);\r\nvnet_cleanup();\r\n}
