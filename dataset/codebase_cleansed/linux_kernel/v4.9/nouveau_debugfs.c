static int\r\nnouveau_debugfs_vbios_image(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct nouveau_drm *drm = nouveau_drm(node->minor->dev);\r\nint i;\r\nfor (i = 0; i < drm->vbios.length; i++)\r\nseq_printf(m, "%c", drm->vbios.data[i]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_debugfs_pstate_get(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct nouveau_debugfs *debugfs = nouveau_debugfs(node->minor->dev);\r\nstruct nvif_object *ctrl = &debugfs->ctrl;\r\nstruct nvif_control_pstate_info_v0 info = {};\r\nint ret, i;\r\nif (!debugfs)\r\nreturn -ENODEV;\r\nret = nvif_mthd(ctrl, NVIF_CONTROL_PSTATE_INFO, &info, sizeof(info));\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < info.count + 1; i++) {\r\nconst s32 state = i < info.count ? i :\r\nNVIF_CONTROL_PSTATE_ATTR_V0_STATE_CURRENT;\r\nstruct nvif_control_pstate_attr_v0 attr = {\r\n.state = state,\r\n.index = 0,\r\n};\r\nret = nvif_mthd(ctrl, NVIF_CONTROL_PSTATE_ATTR,\r\n&attr, sizeof(attr));\r\nif (ret)\r\nreturn ret;\r\nif (i < info.count)\r\nseq_printf(m, "%02x:", attr.state);\r\nelse\r\nseq_printf(m, "%s:", info.pwrsrc == 0 ? "DC" :\r\ninfo.pwrsrc == 1 ? "AC" : "--");\r\nattr.index = 0;\r\ndo {\r\nattr.state = state;\r\nret = nvif_mthd(ctrl, NVIF_CONTROL_PSTATE_ATTR,\r\n&attr, sizeof(attr));\r\nif (ret)\r\nreturn ret;\r\nseq_printf(m, " %s %d", attr.name, attr.min);\r\nif (attr.min != attr.max)\r\nseq_printf(m, "-%d", attr.max);\r\nseq_printf(m, " %s", attr.unit);\r\n} while (attr.index);\r\nif (state >= 0) {\r\nif (info.ustate_ac == state)\r\nseq_printf(m, " AC");\r\nif (info.ustate_dc == state)\r\nseq_printf(m, " DC");\r\nif (info.pstate == state)\r\nseq_printf(m, " *");\r\n} else {\r\nif (info.ustate_ac < -1)\r\nseq_printf(m, " AC");\r\nif (info.ustate_dc < -1)\r\nseq_printf(m, " DC");\r\n}\r\nseq_printf(m, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nnouveau_debugfs_pstate_set(struct file *file, const char __user *ubuf,\r\nsize_t len, loff_t *offp)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct nouveau_debugfs *debugfs = nouveau_debugfs(node->minor->dev);\r\nstruct nvif_object *ctrl = &debugfs->ctrl;\r\nstruct nvif_control_pstate_user_v0 args = { .pwrsrc = -EINVAL };\r\nchar buf[32] = {}, *tmp, *cur = buf;\r\nlong value, ret;\r\nif (!debugfs)\r\nreturn -ENODEV;\r\nif (len >= sizeof(buf))\r\nreturn -EINVAL;\r\nif (copy_from_user(buf, ubuf, len))\r\nreturn -EFAULT;\r\nif ((tmp = strchr(buf, '\n')))\r\n*tmp = '\0';\r\nif (!strncasecmp(cur, "dc:", 3)) {\r\nargs.pwrsrc = 0;\r\ncur += 3;\r\n} else\r\nif (!strncasecmp(cur, "ac:", 3)) {\r\nargs.pwrsrc = 1;\r\ncur += 3;\r\n}\r\nif (!strcasecmp(cur, "none"))\r\nargs.ustate = NVIF_CONTROL_PSTATE_USER_V0_STATE_UNKNOWN;\r\nelse\r\nif (!strcasecmp(cur, "auto"))\r\nargs.ustate = NVIF_CONTROL_PSTATE_USER_V0_STATE_PERFMON;\r\nelse {\r\nret = kstrtol(cur, 16, &value);\r\nif (ret)\r\nreturn ret;\r\nargs.ustate = value;\r\n}\r\nret = nvif_mthd(ctrl, NVIF_CONTROL_PSTATE_USER, &args, sizeof(args));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic int\r\nnouveau_debugfs_pstate_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, nouveau_debugfs_pstate_get, inode->i_private);\r\n}\r\nstatic int\r\nnouveau_debugfs_create_file(struct drm_minor *minor,\r\nconst struct nouveau_debugfs_files *ndf)\r\n{\r\nstruct drm_info_node *node;\r\nnode = kmalloc(sizeof(*node), GFP_KERNEL);\r\nif (node == NULL)\r\nreturn -ENOMEM;\r\nnode->minor = minor;\r\nnode->info_ent = (const void *)ndf->fops;\r\nnode->dent = debugfs_create_file(ndf->name, S_IRUGO | S_IWUSR,\r\nminor->debugfs_root, node, ndf->fops);\r\nif (!node->dent) {\r\nkfree(node);\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&minor->debugfs_lock);\r\nlist_add(&node->list, &minor->debugfs_list);\r\nmutex_unlock(&minor->debugfs_lock);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_drm_debugfs_init(struct drm_minor *minor)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(nouveau_debugfs_files); i++) {\r\nret = nouveau_debugfs_create_file(minor,\r\n&nouveau_debugfs_files[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn drm_debugfs_create_files(nouveau_debugfs_list,\r\nNOUVEAU_DEBUGFS_ENTRIES,\r\nminor->debugfs_root, minor);\r\n}\r\nvoid\r\nnouveau_drm_debugfs_cleanup(struct drm_minor *minor)\r\n{\r\nint i;\r\ndrm_debugfs_remove_files(nouveau_debugfs_list, NOUVEAU_DEBUGFS_ENTRIES,\r\nminor);\r\nfor (i = 0; i < ARRAY_SIZE(nouveau_debugfs_files); i++) {\r\ndrm_debugfs_remove_files((struct drm_info_list *)\r\nnouveau_debugfs_files[i].fops,\r\n1, minor);\r\n}\r\n}\r\nint\r\nnouveau_debugfs_init(struct nouveau_drm *drm)\r\n{\r\nint ret;\r\ndrm->debugfs = kzalloc(sizeof(*drm->debugfs), GFP_KERNEL);\r\nif (!drm->debugfs)\r\nreturn -ENOMEM;\r\nret = nvif_object_init(&drm->device.object, 0, NVIF_CLASS_CONTROL,\r\nNULL, 0, &drm->debugfs->ctrl);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_debugfs_fini(struct nouveau_drm *drm)\r\n{\r\nif (drm->debugfs && drm->debugfs->ctrl.priv)\r\nnvif_object_fini(&drm->debugfs->ctrl);\r\nkfree(drm->debugfs);\r\ndrm->debugfs = NULL;\r\n}
