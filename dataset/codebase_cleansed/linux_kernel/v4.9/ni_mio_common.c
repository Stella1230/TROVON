static void ni_writel(struct comedi_device *dev, unsigned int data, int reg)\r\n{\r\nif (dev->mmio)\r\nwritel(data, dev->mmio + reg);\r\nelse\r\noutl(data, dev->iobase + reg);\r\n}\r\nstatic void ni_writew(struct comedi_device *dev, unsigned int data, int reg)\r\n{\r\nif (dev->mmio)\r\nwritew(data, dev->mmio + reg);\r\nelse\r\noutw(data, dev->iobase + reg);\r\n}\r\nstatic void ni_writeb(struct comedi_device *dev, unsigned int data, int reg)\r\n{\r\nif (dev->mmio)\r\nwriteb(data, dev->mmio + reg);\r\nelse\r\noutb(data, dev->iobase + reg);\r\n}\r\nstatic unsigned int ni_readl(struct comedi_device *dev, int reg)\r\n{\r\nif (dev->mmio)\r\nreturn readl(dev->mmio + reg);\r\nreturn inl(dev->iobase + reg);\r\n}\r\nstatic unsigned int ni_readw(struct comedi_device *dev, int reg)\r\n{\r\nif (dev->mmio)\r\nreturn readw(dev->mmio + reg);\r\nreturn inw(dev->iobase + reg);\r\n}\r\nstatic unsigned int ni_readb(struct comedi_device *dev, int reg)\r\n{\r\nif (dev->mmio)\r\nreturn readb(dev->mmio + reg);\r\nreturn inb(dev->iobase + reg);\r\n}\r\nstatic void m_series_stc_write(struct comedi_device *dev,\r\nunsigned int data, unsigned int reg)\r\n{\r\nconst struct mio_regmap *regmap;\r\nif (reg < ARRAY_SIZE(m_series_stc_write_regmap)) {\r\nregmap = &m_series_stc_write_regmap[reg];\r\n} else {\r\ndev_warn(dev->class_dev, "%s: unhandled register=0x%x\n",\r\n__func__, reg);\r\nreturn;\r\n}\r\nswitch (regmap->size) {\r\ncase 4:\r\nni_writel(dev, data, regmap->mio_reg);\r\nbreak;\r\ncase 2:\r\nni_writew(dev, data, regmap->mio_reg);\r\nbreak;\r\ndefault:\r\ndev_warn(dev->class_dev, "%s: unmapped register=0x%x\n",\r\n__func__, reg);\r\nbreak;\r\n}\r\n}\r\nstatic unsigned int m_series_stc_read(struct comedi_device *dev,\r\nunsigned int reg)\r\n{\r\nconst struct mio_regmap *regmap;\r\nif (reg < ARRAY_SIZE(m_series_stc_read_regmap)) {\r\nregmap = &m_series_stc_read_regmap[reg];\r\n} else {\r\ndev_warn(dev->class_dev, "%s: unhandled register=0x%x\n",\r\n__func__, reg);\r\nreturn 0;\r\n}\r\nswitch (regmap->size) {\r\ncase 4:\r\nreturn ni_readl(dev, regmap->mio_reg);\r\ncase 2:\r\nreturn ni_readw(dev, regmap->mio_reg);\r\ncase 1:\r\nreturn ni_readb(dev, regmap->mio_reg);\r\ndefault:\r\ndev_warn(dev->class_dev, "%s: unmapped register=0x%x\n",\r\n__func__, reg);\r\nreturn 0;\r\n}\r\n}\r\nstatic void ni_stc_writew(struct comedi_device *dev,\r\nunsigned int data, int reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nif (devpriv->is_m_series) {\r\nm_series_stc_write(dev, data, reg);\r\n} else {\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nif (!devpriv->mite && reg < 8) {\r\nni_writew(dev, data, reg * 2);\r\n} else {\r\nni_writew(dev, reg, NI_E_STC_WINDOW_ADDR_REG);\r\nni_writew(dev, data, NI_E_STC_WINDOW_DATA_REG);\r\n}\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\n}\r\nstatic void ni_stc_writel(struct comedi_device *dev,\r\nunsigned int data, int reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (devpriv->is_m_series) {\r\nm_series_stc_write(dev, data, reg);\r\n} else {\r\nni_stc_writew(dev, data >> 16, reg);\r\nni_stc_writew(dev, data & 0xffff, reg + 1);\r\n}\r\n}\r\nstatic unsigned int ni_stc_readw(struct comedi_device *dev, int reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nunsigned int val;\r\nif (devpriv->is_m_series) {\r\nval = m_series_stc_read(dev, reg);\r\n} else {\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nif (!devpriv->mite && reg < 8) {\r\nval = ni_readw(dev, reg * 2);\r\n} else {\r\nni_writew(dev, reg, NI_E_STC_WINDOW_ADDR_REG);\r\nval = ni_readw(dev, NI_E_STC_WINDOW_DATA_REG);\r\n}\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\nreturn val;\r\n}\r\nstatic unsigned int ni_stc_readl(struct comedi_device *dev, int reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int val;\r\nif (devpriv->is_m_series) {\r\nval = m_series_stc_read(dev, reg);\r\n} else {\r\nval = ni_stc_readw(dev, reg) << 16;\r\nval |= ni_stc_readw(dev, reg + 1);\r\n}\r\nreturn val;\r\n}\r\nstatic inline void ni_set_bitfield(struct comedi_device *dev, int reg,\r\nunsigned int bit_mask,\r\nunsigned int bit_values)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);\r\nswitch (reg) {\r\ncase NISTC_INTA_ENA_REG:\r\ndevpriv->int_a_enable_reg &= ~bit_mask;\r\ndevpriv->int_a_enable_reg |= bit_values & bit_mask;\r\nni_stc_writew(dev, devpriv->int_a_enable_reg, reg);\r\nbreak;\r\ncase NISTC_INTB_ENA_REG:\r\ndevpriv->int_b_enable_reg &= ~bit_mask;\r\ndevpriv->int_b_enable_reg |= bit_values & bit_mask;\r\nni_stc_writew(dev, devpriv->int_b_enable_reg, reg);\r\nbreak;\r\ncase NISTC_IO_BIDIR_PIN_REG:\r\ndevpriv->io_bidirection_pin_reg &= ~bit_mask;\r\ndevpriv->io_bidirection_pin_reg |= bit_values & bit_mask;\r\nni_stc_writew(dev, devpriv->io_bidirection_pin_reg, reg);\r\nbreak;\r\ncase NI_E_DMA_AI_AO_SEL_REG:\r\ndevpriv->ai_ao_select_reg &= ~bit_mask;\r\ndevpriv->ai_ao_select_reg |= bit_values & bit_mask;\r\nni_writeb(dev, devpriv->ai_ao_select_reg, reg);\r\nbreak;\r\ncase NI_E_DMA_G0_G1_SEL_REG:\r\ndevpriv->g0_g1_select_reg &= ~bit_mask;\r\ndevpriv->g0_g1_select_reg |= bit_values & bit_mask;\r\nni_writeb(dev, devpriv->g0_g1_select_reg, reg);\r\nbreak;\r\ncase NI_M_CDIO_DMA_SEL_REG:\r\ndevpriv->cdio_dma_select_reg &= ~bit_mask;\r\ndevpriv->cdio_dma_select_reg |= bit_values & bit_mask;\r\nni_writeb(dev, devpriv->cdio_dma_select_reg, reg);\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "called with invalid register %d\n",\r\nreg);\r\nbreak;\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);\r\n}\r\nstatic int ni_request_ai_mite_channel(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct mite_channel *mite_chan;\r\nunsigned long flags;\r\nunsigned int bits;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nmite_chan = mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);\r\nif (!mite_chan) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ndev_err(dev->class_dev,\r\n"failed to reserve mite dma channel for analog input\n");\r\nreturn -EBUSY;\r\n}\r\nmite_chan->dir = COMEDI_INPUT;\r\ndevpriv->ai_mite_chan = mite_chan;\r\nbits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);\r\nni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,\r\nNI_E_DMA_AI_SEL_MASK, NI_E_DMA_AI_SEL(bits));\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ni_request_ao_mite_channel(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct mite_channel *mite_chan;\r\nunsigned long flags;\r\nunsigned int bits;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nmite_chan = mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);\r\nif (!mite_chan) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ndev_err(dev->class_dev,\r\n"failed to reserve mite dma channel for analog outut\n");\r\nreturn -EBUSY;\r\n}\r\nmite_chan->dir = COMEDI_OUTPUT;\r\ndevpriv->ao_mite_chan = mite_chan;\r\nbits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);\r\nni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,\r\nNI_E_DMA_AO_SEL_MASK, NI_E_DMA_AO_SEL(bits));\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ni_request_gpct_mite_channel(struct comedi_device *dev,\r\nunsigned int gpct_index,\r\nenum comedi_io_direction direction)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct ni_gpct *counter = &devpriv->counter_dev->counters[gpct_index];\r\nstruct mite_channel *mite_chan;\r\nunsigned long flags;\r\nunsigned int bits;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nmite_chan = mite_request_channel(devpriv->mite,\r\ndevpriv->gpct_mite_ring[gpct_index]);\r\nif (!mite_chan) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ndev_err(dev->class_dev,\r\n"failed to reserve mite dma channel for counter\n");\r\nreturn -EBUSY;\r\n}\r\nmite_chan->dir = direction;\r\nni_tio_set_mite_channel(counter, mite_chan);\r\nbits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);\r\nni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,\r\nNI_E_DMA_G0_G1_SEL_MASK(gpct_index),\r\nNI_E_DMA_G0_G1_SEL(gpct_index, bits));\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ni_request_cdo_mite_channel(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct mite_channel *mite_chan;\r\nunsigned long flags;\r\nunsigned int bits;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nmite_chan = mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);\r\nif (!mite_chan) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ndev_err(dev->class_dev,\r\n"failed to reserve mite dma channel for correlated digital output\n");\r\nreturn -EBUSY;\r\n}\r\nmite_chan->dir = COMEDI_OUTPUT;\r\ndevpriv->cdo_mite_chan = mite_chan;\r\nbits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);\r\nni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,\r\nNI_M_CDIO_DMA_SEL_CDO_MASK,\r\nNI_M_CDIO_DMA_SEL_CDO(bits));\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ni_release_ai_mite_channel(struct comedi_device *dev)\r\n{\r\n#ifdef PCIDMA\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ai_mite_chan) {\r\nni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,\r\nNI_E_DMA_AI_SEL_MASK, 0);\r\nmite_release_channel(devpriv->ai_mite_chan);\r\ndevpriv->ai_mite_chan = NULL;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n#endif\r\n}\r\nstatic void ni_release_ao_mite_channel(struct comedi_device *dev)\r\n{\r\n#ifdef PCIDMA\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ao_mite_chan) {\r\nni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,\r\nNI_E_DMA_AO_SEL_MASK, 0);\r\nmite_release_channel(devpriv->ao_mite_chan);\r\ndevpriv->ao_mite_chan = NULL;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n#endif\r\n}\r\nstatic void ni_release_gpct_mite_channel(struct comedi_device *dev,\r\nunsigned int gpct_index)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->counter_dev->counters[gpct_index].mite_chan) {\r\nstruct mite_channel *mite_chan =\r\ndevpriv->counter_dev->counters[gpct_index].mite_chan;\r\nni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,\r\nNI_E_DMA_G0_G1_SEL_MASK(gpct_index), 0);\r\nni_tio_set_mite_channel(&devpriv->\r\ncounter_dev->counters[gpct_index],\r\nNULL);\r\nmite_release_channel(mite_chan);\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n}\r\nstatic void ni_release_cdo_mite_channel(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->cdo_mite_chan) {\r\nni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,\r\nNI_M_CDIO_DMA_SEL_CDO_MASK, 0);\r\nmite_release_channel(devpriv->cdo_mite_chan);\r\ndevpriv->cdo_mite_chan = NULL;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n}\r\nstatic void ni_e_series_enable_second_irq(struct comedi_device *dev,\r\nunsigned int gpct_index, short enable)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int val = 0;\r\nint reg;\r\nif (devpriv->is_m_series || gpct_index > 1)\r\nreturn;\r\nif (gpct_index == 0) {\r\nreg = NISTC_INTA2_ENA_REG;\r\nif (enable)\r\nval = NISTC_INTA_ENA_G0_GATE;\r\n} else {\r\nreg = NISTC_INTB2_ENA_REG;\r\nif (enable)\r\nval = NISTC_INTB_ENA_G1_GATE;\r\n}\r\nni_stc_writew(dev, val, reg);\r\n}\r\nstatic void ni_clear_ai_fifo(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstatic const int timeout = 10000;\r\nint i;\r\nif (devpriv->is_6143) {\r\nni_writel(dev, 0x10, NI6143_AI_FIFO_CTRL_REG);\r\nni_writel(dev, 0x00, NI6143_AI_FIFO_CTRL_REG);\r\nfor (i = 0; i < timeout; i++) {\r\nif (!(ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x10))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout)\r\ndev_err(dev->class_dev, "FIFO flush timeout\n");\r\n} else {\r\nni_stc_writew(dev, 1, NISTC_ADC_FIFO_CLR_REG);\r\nif (devpriv->is_625x) {\r\nni_writeb(dev, 0, NI_M_STATIC_AI_CTRL_REG(0));\r\nni_writeb(dev, 1, NI_M_STATIC_AI_CTRL_REG(0));\r\n#if 0\r\nni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\r\nNISTC_AI_CMD1_REG);\r\nni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\r\nNISTC_AI_CMD1_REG);\r\nni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\r\nNISTC_AI_CMD1_REG);\r\n#endif\r\n}\r\n}\r\n}\r\nstatic inline void ni_ao_win_outw(struct comedi_device *dev,\r\nunsigned int data, int addr)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);\r\nni_writew(dev, data, NI611X_AO_WINDOW_DATA_REG);\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\nstatic inline void ni_ao_win_outl(struct comedi_device *dev,\r\nunsigned int data, int addr)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);\r\nni_writel(dev, data, NI611X_AO_WINDOW_DATA_REG);\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\nstatic inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nunsigned short data;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);\r\ndata = ni_readw(dev, NI611X_AO_WINDOW_DATA_REG);\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\nreturn data;\r\n}\r\nstatic inline void ni_set_bits(struct comedi_device *dev, int reg,\r\nunsigned int bits, unsigned int value)\r\n{\r\nunsigned int bit_values;\r\nif (value)\r\nbit_values = bits;\r\nelse\r\nbit_values = 0;\r\nni_set_bitfield(dev, reg, bits, bit_values);\r\n}\r\nstatic void ni_sync_ai_dma(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ai_mite_chan)\r\nmite_sync_dma(devpriv->ai_mite_chan, s);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n}\r\nstatic int ni_ai_drain_dma(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint i;\r\nstatic const int timeout = 10000;\r\nunsigned long flags;\r\nint retval = 0;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ai_mite_chan) {\r\nfor (i = 0; i < timeout; i++) {\r\nif ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\r\nNISTC_AI_STATUS1_FIFO_E) &&\r\nmite_bytes_in_transit(devpriv->ai_mite_chan) == 0)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (i == timeout) {\r\ndev_err(dev->class_dev, "timed out\n");\r\ndev_err(dev->class_dev,\r\n"mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",\r\nmite_bytes_in_transit(devpriv->ai_mite_chan),\r\nni_stc_readw(dev, NISTC_AI_STATUS1_REG));\r\nretval = -1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nni_sync_ai_dma(dev);\r\nreturn retval;\r\n}\r\nstatic int ni_ao_wait_for_dma_load(struct comedi_device *dev)\r\n{\r\nstatic const int timeout = 10000;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nunsigned short b_status;\r\nb_status = ni_stc_readw(dev, NISTC_AO_STATUS1_REG);\r\nif (b_status & NISTC_AO_STATUS1_FIFO_HF)\r\nbreak;\r\nusleep_range(10, 100);\r\n}\r\nif (i == timeout) {\r\ndev_err(dev->class_dev, "timed out waiting for dma load\n");\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ni_ao_fifo_load(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, int n)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint i;\r\nunsigned short d;\r\nunsigned int packed_data;\r\nfor (i = 0; i < n; i++) {\r\ncomedi_buf_read_samples(s, &d, 1);\r\nif (devpriv->is_6xxx) {\r\npacked_data = d & 0xffff;\r\nif (!devpriv->is_6711) {\r\ncomedi_buf_read_samples(s, &d, 1);\r\ni++;\r\npacked_data |= (d << 16) & 0xffff0000;\r\n}\r\nni_writel(dev, packed_data, NI611X_AO_FIFO_DATA_REG);\r\n} else {\r\nni_writew(dev, d, NI_E_AO_FIFO_DATA_REG);\r\n}\r\n}\r\n}\r\nstatic int ni_ao_fifo_half_empty(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nunsigned int nbytes;\r\nunsigned int nsamples;\r\nnbytes = comedi_buf_read_n_available(s);\r\nif (nbytes == 0) {\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\nreturn 0;\r\n}\r\nnsamples = comedi_bytes_to_samples(s, nbytes);\r\nif (nsamples > board->ao_fifo_depth / 2)\r\nnsamples = board->ao_fifo_depth / 2;\r\nni_ao_fifo_load(dev, s, nsamples);\r\nreturn 1;\r\n}\r\nstatic int ni_ao_prep_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int nbytes;\r\nunsigned int nsamples;\r\nni_stc_writew(dev, 1, NISTC_DAC_FIFO_CLR_REG);\r\nif (devpriv->is_6xxx)\r\nni_ao_win_outl(dev, 0x6, NI611X_AO_FIFO_OFFSET_LOAD_REG);\r\nnbytes = comedi_buf_read_n_available(s);\r\nif (nbytes == 0)\r\nreturn 0;\r\nnsamples = comedi_bytes_to_samples(s, nbytes);\r\nif (nsamples > board->ao_fifo_depth)\r\nnsamples = board->ao_fifo_depth;\r\nni_ao_fifo_load(dev, s, nsamples);\r\nreturn nsamples;\r\n}\r\nstatic void ni_ai_fifo_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, int n)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nunsigned int dl;\r\nunsigned short data;\r\nint i;\r\nif (devpriv->is_611x) {\r\nfor (i = 0; i < n / 2; i++) {\r\ndl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);\r\ndata = (dl >> 16) & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\ndata = dl & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\n}\r\nif (n % 2) {\r\ndl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);\r\ndata = dl & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\n}\r\n} else if (devpriv->is_6143) {\r\nfor (i = 0; i < n / 2; i++) {\r\ndl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\r\ndata = (dl >> 16) & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\ndata = dl & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\n}\r\nif (n % 2) {\r\nni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);\r\ndl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\r\ndata = (dl >> 16) & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\n}\r\n} else {\r\nif (n > ARRAY_SIZE(devpriv->ai_fifo_buffer)) {\r\ndev_err(dev->class_dev,\r\n"bug! ai_fifo_buffer too small\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\nreturn;\r\n}\r\nfor (i = 0; i < n; i++) {\r\ndevpriv->ai_fifo_buffer[i] =\r\nni_readw(dev, NI_E_AI_FIFO_DATA_REG);\r\n}\r\ncomedi_buf_write_samples(s, devpriv->ai_fifo_buffer, n);\r\n}\r\n}\r\nstatic void ni_handle_fifo_half_full(struct comedi_device *dev)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nint n;\r\nn = board->ai_fifo_depth / 2;\r\nni_ai_fifo_read(dev, s, n);\r\n}\r\nstatic void ni_handle_fifo_dregs(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned int dl;\r\nunsigned short data;\r\nint i;\r\nif (devpriv->is_611x) {\r\nwhile ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\r\nNISTC_AI_STATUS1_FIFO_E) == 0) {\r\ndl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);\r\ndata = dl >> 16;\r\ncomedi_buf_write_samples(s, &data, 1);\r\ndata = dl & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\n}\r\n} else if (devpriv->is_6143) {\r\ni = 0;\r\nwhile (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x04) {\r\ndl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\r\ndata = dl >> 16;\r\ncomedi_buf_write_samples(s, &data, 1);\r\ndata = dl & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\ni += 2;\r\n}\r\nif (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x01) {\r\nni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);\r\ndl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\r\ndata = (dl >> 16) & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\n}\r\n} else {\r\nunsigned short fe;\r\nfe = ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\r\nNISTC_AI_STATUS1_FIFO_E;\r\nwhile (fe == 0) {\r\nfor (i = 0;\r\ni < ARRAY_SIZE(devpriv->ai_fifo_buffer); i++) {\r\nfe = ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\r\nNISTC_AI_STATUS1_FIFO_E;\r\nif (fe)\r\nbreak;\r\ndevpriv->ai_fifo_buffer[i] =\r\nni_readw(dev, NI_E_AI_FIFO_DATA_REG);\r\n}\r\ncomedi_buf_write_samples(s, devpriv->ai_fifo_buffer, i);\r\n}\r\n}\r\n}\r\nstatic void get_last_sample_611x(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned short data;\r\nunsigned int dl;\r\nif (!devpriv->is_611x)\r\nreturn;\r\nif (ni_readb(dev, NI_E_STATUS_REG) & 0x80) {\r\ndl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);\r\ndata = dl & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\n}\r\n}\r\nstatic void get_last_sample_6143(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned short data;\r\nunsigned int dl;\r\nif (!devpriv->is_6143)\r\nreturn;\r\nif (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x01) {\r\nni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);\r\ndl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\r\ndata = (dl >> 16) & 0xffff;\r\ncomedi_buf_write_samples(s, &data, 1);\r\n}\r\n}\r\nstatic void shutdown_ai_command(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\n#ifdef PCIDMA\r\nni_ai_drain_dma(dev);\r\n#endif\r\nni_handle_fifo_dregs(dev);\r\nget_last_sample_611x(dev);\r\nget_last_sample_6143(dev);\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\nstatic void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (devpriv->aimode == AIMODE_SCAN) {\r\n#ifdef PCIDMA\r\nstatic const int timeout = 10;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nni_sync_ai_dma(dev);\r\nif ((s->async->events & COMEDI_CB_EOS))\r\nbreak;\r\nudelay(1);\r\n}\r\n#else\r\nni_handle_fifo_dregs(dev);\r\ns->async->events |= COMEDI_CB_EOS;\r\n#endif\r\n}\r\nif (devpriv->ai_cmd2 & NISTC_AI_CMD2_END_ON_EOS)\r\nshutdown_ai_command(dev);\r\n}\r\nstatic void handle_gpct_interrupt(struct comedi_device *dev,\r\nunsigned short counter_index)\r\n{\r\n#ifdef PCIDMA\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s;\r\ns = &dev->subdevices[NI_GPCT_SUBDEV(counter_index)];\r\nni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],\r\ns);\r\ncomedi_handle_events(dev, s);\r\n#endif\r\n}\r\nstatic void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)\r\n{\r\nunsigned short ack = 0;\r\nif (a_status & NISTC_AI_STATUS1_SC_TC)\r\nack |= NISTC_INTA_ACK_AI_SC_TC;\r\nif (a_status & NISTC_AI_STATUS1_START1)\r\nack |= NISTC_INTA_ACK_AI_START1;\r\nif (a_status & NISTC_AI_STATUS1_START)\r\nack |= NISTC_INTA_ACK_AI_START;\r\nif (a_status & NISTC_AI_STATUS1_STOP)\r\nack |= NISTC_INTA_ACK_AI_STOP;\r\nif (ack)\r\nni_stc_writew(dev, ack, NISTC_INTA_ACK_REG);\r\n}\r\nstatic void handle_a_interrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned short status)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (status & (NISTC_AI_STATUS1_ERR |\r\nNISTC_AI_STATUS1_SC_TC | NISTC_AI_STATUS1_START1)) {\r\nif (status == 0xffff) {\r\ndev_err(dev->class_dev, "Card removed?\n");\r\nif (comedi_is_subdevice_running(s))\r\ns->async->events |= COMEDI_CB_ERROR;\r\nreturn;\r\n}\r\nif (status & NISTC_AI_STATUS1_ERR) {\r\ndev_err(dev->class_dev, "ai error a_status=%04x\n",\r\nstatus);\r\nshutdown_ai_command(dev);\r\ns->async->events |= COMEDI_CB_ERROR;\r\nif (status & NISTC_AI_STATUS1_OVER)\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\nreturn;\r\n}\r\nif (status & NISTC_AI_STATUS1_SC_TC) {\r\nif (cmd->stop_src == TRIG_COUNT)\r\nshutdown_ai_command(dev);\r\n}\r\n}\r\n#ifndef PCIDMA\r\nif (status & NISTC_AI_STATUS1_FIFO_HF) {\r\nint i;\r\nstatic const int timeout = 10;\r\nfor (i = 0; i < timeout; ++i) {\r\nni_handle_fifo_half_full(dev);\r\nif ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\r\nNISTC_AI_STATUS1_FIFO_HF) == 0)\r\nbreak;\r\n}\r\n}\r\n#endif\r\nif (status & NISTC_AI_STATUS1_STOP)\r\nni_handle_eos(dev, s);\r\n}\r\nstatic void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)\r\n{\r\nunsigned short ack = 0;\r\nif (b_status & NISTC_AO_STATUS1_BC_TC)\r\nack |= NISTC_INTB_ACK_AO_BC_TC;\r\nif (b_status & NISTC_AO_STATUS1_OVERRUN)\r\nack |= NISTC_INTB_ACK_AO_ERR;\r\nif (b_status & NISTC_AO_STATUS1_START)\r\nack |= NISTC_INTB_ACK_AO_START;\r\nif (b_status & NISTC_AO_STATUS1_START1)\r\nack |= NISTC_INTB_ACK_AO_START1;\r\nif (b_status & NISTC_AO_STATUS1_UC_TC)\r\nack |= NISTC_INTB_ACK_AO_UC_TC;\r\nif (b_status & NISTC_AO_STATUS1_UI2_TC)\r\nack |= NISTC_INTB_ACK_AO_UI2_TC;\r\nif (b_status & NISTC_AO_STATUS1_UPDATE)\r\nack |= NISTC_INTB_ACK_AO_UPDATE;\r\nif (ack)\r\nni_stc_writew(dev, ack, NISTC_INTB_ACK_REG);\r\n}\r\nstatic void handle_b_interrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned short b_status)\r\n{\r\nif (b_status == 0xffff)\r\nreturn;\r\nif (b_status & NISTC_AO_STATUS1_OVERRUN) {\r\ndev_err(dev->class_dev,\r\n"AO FIFO underrun status=0x%04x status2=0x%04x\n",\r\nb_status, ni_stc_readw(dev, NISTC_AO_STATUS2_REG));\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\nif (s->async->cmd.stop_src != TRIG_NONE &&\r\nb_status & NISTC_AO_STATUS1_BC_TC)\r\ns->async->events |= COMEDI_CB_EOA;\r\n#ifndef PCIDMA\r\nif (b_status & NISTC_AO_STATUS1_FIFO_REQ) {\r\nint ret;\r\nret = ni_ao_fifo_half_empty(dev, s);\r\nif (!ret) {\r\ndev_err(dev->class_dev, "AO buffer underrun\n");\r\nni_set_bits(dev, NISTC_INTB_ENA_REG,\r\nNISTC_INTB_ENA_AO_FIFO |\r\nNISTC_INTB_ENA_AO_ERR, 0);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,\r\nvoid *data, unsigned int num_bytes,\r\nunsigned int chan_index)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int nsamples = comedi_bytes_to_samples(s, num_bytes);\r\nunsigned short *array = data;\r\nunsigned int *larray = data;\r\nunsigned int i;\r\n#ifdef PCIDMA\r\n__le16 *barray = data;\r\n__le32 *blarray = data;\r\n#endif\r\nfor (i = 0; i < nsamples; i++) {\r\n#ifdef PCIDMA\r\nif (s->subdev_flags & SDF_LSAMPL)\r\nlarray[i] = le32_to_cpu(blarray[i]);\r\nelse\r\narray[i] = le16_to_cpu(barray[i]);\r\n#endif\r\nif (s->subdev_flags & SDF_LSAMPL)\r\nlarray[i] += devpriv->ai_offset[chan_index];\r\nelse\r\narray[i] += devpriv->ai_offset[chan_index];\r\nchan_index++;\r\nchan_index %= cmd->chanlist_len;\r\n}\r\n}\r\nstatic int ni_ai_setup_MITE_dma(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nint retval;\r\nunsigned long flags;\r\nretval = ni_request_ai_mite_channel(dev);\r\nif (retval)\r\nreturn retval;\r\ncomedi_buf_write_alloc(s, s->async->prealloc_bufsz);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (!devpriv->ai_mite_chan) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn -EIO;\r\n}\r\nif (devpriv->is_611x || devpriv->is_6143)\r\nmite_prep_dma(devpriv->ai_mite_chan, 32, 16);\r\nelse if (devpriv->is_628x)\r\nmite_prep_dma(devpriv->ai_mite_chan, 32, 32);\r\nelse\r\nmite_prep_dma(devpriv->ai_mite_chan, 16, 16);\r\nmite_dma_arm(devpriv->ai_mite_chan);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ni_ao_setup_MITE_dma(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nint retval;\r\nunsigned long flags;\r\nretval = ni_request_ao_mite_channel(dev);\r\nif (retval)\r\nreturn retval;\r\ncomedi_buf_read_alloc(s, s->async->prealloc_bufsz);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ao_mite_chan) {\r\nif (devpriv->is_611x || devpriv->is_6713) {\r\nmite_prep_dma(devpriv->ao_mite_chan, 32, 32);\r\n} else {\r\nmite_prep_dma(devpriv->ao_mite_chan, 16, 32);\r\n}\r\nmite_dma_arm(devpriv->ao_mite_chan);\r\n} else {\r\nretval = -EIO;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int ai_personal;\r\nunsigned int ai_out_ctrl;\r\nni_release_ai_mite_channel(dev);\r\nni_stc_writew(dev, NISTC_RESET_AI_CFG_START | NISTC_RESET_AI,\r\nNISTC_RESET_REG);\r\nni_set_bits(dev, NISTC_INTA_ENA_REG, NISTC_INTA_ENA_AI_MASK, 0);\r\nni_clear_ai_fifo(dev);\r\nif (!devpriv->is_6143)\r\nni_writeb(dev, NI_E_MISC_CMD_EXT_ATRIG, NI_E_MISC_CMD_REG);\r\nni_stc_writew(dev, NISTC_AI_CMD1_DISARM, NISTC_AI_CMD1_REG);\r\nni_stc_writew(dev, NISTC_AI_MODE1_START_STOP |\r\nNISTC_AI_MODE1_RSVD\r\n,\r\nNISTC_AI_MODE1_REG);\r\nni_stc_writew(dev, 0, NISTC_AI_MODE2_REG);\r\nni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,\r\nNISTC_AI_MODE3_REG);\r\nai_personal = NISTC_AI_PERSONAL_SHIFTIN_PW |\r\nNISTC_AI_PERSONAL_SOC_POLARITY |\r\nNISTC_AI_PERSONAL_LOCALMUX_CLK_PW;\r\nai_out_ctrl = NISTC_AI_OUT_CTRL_SCAN_IN_PROG_SEL(3) |\r\nNISTC_AI_OUT_CTRL_EXTMUX_CLK_SEL(0) |\r\nNISTC_AI_OUT_CTRL_LOCALMUX_CLK_SEL(2) |\r\nNISTC_AI_OUT_CTRL_SC_TC_SEL(3);\r\nif (devpriv->is_611x) {\r\nai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_HIGH;\r\n} else if (devpriv->is_6143) {\r\nai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_LOW;\r\n} else {\r\nai_personal |= NISTC_AI_PERSONAL_CONVERT_PW;\r\nif (devpriv->is_622x)\r\nai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_HIGH;\r\nelse\r\nai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_LOW;\r\n}\r\nni_stc_writew(dev, ai_personal, NISTC_AI_PERSONAL_REG);\r\nni_stc_writew(dev, ai_out_ctrl, NISTC_AI_OUT_CTRL_REG);\r\nni_stc_writew(dev, NISTC_INTA_ACK_AI_ALL, NISTC_INTA_ACK_REG);\r\nni_stc_writew(dev, NISTC_RESET_AI_CFG_END, NISTC_RESET_REG);\r\nreturn 0;\r\n}\r\nstatic int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nint count;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\n#ifndef PCIDMA\r\nni_handle_fifo_dregs(dev);\r\n#else\r\nni_sync_ai_dma(dev);\r\n#endif\r\ncount = comedi_buf_n_bytes_ready(s);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn count;\r\n}\r\nstatic void ni_prime_channelgain_list(struct comedi_device *dev)\r\n{\r\nint i;\r\nni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE, NISTC_AI_CMD1_REG);\r\nfor (i = 0; i < NI_TIMEOUT; ++i) {\r\nif (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\r\nNISTC_AI_STATUS1_FIFO_E)) {\r\nni_stc_writew(dev, 1, NISTC_ADC_FIFO_CLR_REG);\r\nreturn;\r\n}\r\nudelay(1);\r\n}\r\ndev_err(dev->class_dev, "timeout loading channel/gain list\n");\r\n}\r\nstatic void ni_m_series_load_channelgain_list(struct comedi_device *dev,\r\nunsigned int n_chan,\r\nunsigned int *list)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int chan, range, aref;\r\nunsigned int i;\r\nunsigned int dither;\r\nunsigned int range_code;\r\nni_stc_writew(dev, 1, NISTC_CFG_MEM_CLR_REG);\r\nif ((list[0] & CR_ALT_SOURCE)) {\r\nunsigned int bypass_bits;\r\nchan = CR_CHAN(list[0]);\r\nrange = CR_RANGE(list[0]);\r\nrange_code = ni_gainlkup[board->gainlkup][range];\r\ndither = (list[0] & CR_ALT_FILTER) != 0;\r\nbypass_bits = NI_M_CFG_BYPASS_FIFO |\r\nNI_M_CFG_BYPASS_AI_CHAN(chan) |\r\nNI_M_CFG_BYPASS_AI_GAIN(range_code) |\r\ndevpriv->ai_calib_source;\r\nif (dither)\r\nbypass_bits |= NI_M_CFG_BYPASS_AI_DITHER;\r\nbypass_bits |= NI_M_CFG_BYPASS_AI_POLARITY;\r\nni_writel(dev, bypass_bits, NI_M_CFG_BYPASS_FIFO_REG);\r\n} else {\r\nni_writel(dev, 0, NI_M_CFG_BYPASS_FIFO_REG);\r\n}\r\nfor (i = 0; i < n_chan; i++) {\r\nunsigned int config_bits = 0;\r\nchan = CR_CHAN(list[i]);\r\naref = CR_AREF(list[i]);\r\nrange = CR_RANGE(list[i]);\r\ndither = (list[i] & CR_ALT_FILTER) != 0;\r\nrange_code = ni_gainlkup[board->gainlkup][range];\r\ndevpriv->ai_offset[i] = 0;\r\nswitch (aref) {\r\ncase AREF_DIFF:\r\nconfig_bits |= NI_M_AI_CFG_CHAN_TYPE_DIFF;\r\nbreak;\r\ncase AREF_COMMON:\r\nconfig_bits |= NI_M_AI_CFG_CHAN_TYPE_COMMON;\r\nbreak;\r\ncase AREF_GROUND:\r\nconfig_bits |= NI_M_AI_CFG_CHAN_TYPE_GROUND;\r\nbreak;\r\ncase AREF_OTHER:\r\nbreak;\r\n}\r\nconfig_bits |= NI_M_AI_CFG_CHAN_SEL(chan);\r\nconfig_bits |= NI_M_AI_CFG_BANK_SEL(chan);\r\nconfig_bits |= NI_M_AI_CFG_GAIN(range_code);\r\nif (i == n_chan - 1)\r\nconfig_bits |= NI_M_AI_CFG_LAST_CHAN;\r\nif (dither)\r\nconfig_bits |= NI_M_AI_CFG_DITHER;\r\nconfig_bits |= NI_M_AI_CFG_POLARITY;\r\nni_writew(dev, config_bits, NI_M_AI_CFG_FIFO_DATA_REG);\r\n}\r\nni_prime_channelgain_list(dev);\r\n}\r\nstatic void ni_load_channelgain_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int n_chan, unsigned int *list)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int offset = (s->maxdata + 1) >> 1;\r\nunsigned int chan, range, aref;\r\nunsigned int i;\r\nunsigned int hi, lo;\r\nunsigned int dither;\r\nif (devpriv->is_m_series) {\r\nni_m_series_load_channelgain_list(dev, n_chan, list);\r\nreturn;\r\n}\r\nif (n_chan == 1 && !devpriv->is_611x && !devpriv->is_6143) {\r\nif (devpriv->changain_state &&\r\ndevpriv->changain_spec == list[0]) {\r\nreturn;\r\n}\r\ndevpriv->changain_state = 1;\r\ndevpriv->changain_spec = list[0];\r\n} else {\r\ndevpriv->changain_state = 0;\r\n}\r\nni_stc_writew(dev, 1, NISTC_CFG_MEM_CLR_REG);\r\nif (devpriv->is_6143) {\r\nif ((list[0] & CR_ALT_SOURCE) &&\r\n!devpriv->ai_calib_source_enabled) {\r\nni_writew(dev, devpriv->ai_calib_source |\r\nNI6143_CALIB_CHAN_RELAY_ON,\r\nNI6143_CALIB_CHAN_REG);\r\nni_writew(dev, devpriv->ai_calib_source,\r\nNI6143_CALIB_CHAN_REG);\r\ndevpriv->ai_calib_source_enabled = 1;\r\nmsleep_interruptible(100);\r\n} else if (!(list[0] & CR_ALT_SOURCE) &&\r\ndevpriv->ai_calib_source_enabled) {\r\nni_writew(dev, devpriv->ai_calib_source |\r\nNI6143_CALIB_CHAN_RELAY_OFF,\r\nNI6143_CALIB_CHAN_REG);\r\nni_writew(dev, devpriv->ai_calib_source,\r\nNI6143_CALIB_CHAN_REG);\r\ndevpriv->ai_calib_source_enabled = 0;\r\nmsleep_interruptible(100);\r\n}\r\n}\r\nfor (i = 0; i < n_chan; i++) {\r\nif (!devpriv->is_6143 && (list[i] & CR_ALT_SOURCE))\r\nchan = devpriv->ai_calib_source;\r\nelse\r\nchan = CR_CHAN(list[i]);\r\naref = CR_AREF(list[i]);\r\nrange = CR_RANGE(list[i]);\r\ndither = (list[i] & CR_ALT_FILTER) != 0;\r\nrange = ni_gainlkup[board->gainlkup][range];\r\nif (devpriv->is_611x)\r\ndevpriv->ai_offset[i] = offset;\r\nelse\r\ndevpriv->ai_offset[i] = (range & 0x100) ? 0 : offset;\r\nhi = 0;\r\nif ((list[i] & CR_ALT_SOURCE)) {\r\nif (devpriv->is_611x)\r\nni_writew(dev, CR_CHAN(list[i]) & 0x0003,\r\nNI611X_CALIB_CHAN_SEL_REG);\r\n} else {\r\nif (devpriv->is_611x)\r\naref = AREF_DIFF;\r\nelse if (devpriv->is_6143)\r\naref = AREF_OTHER;\r\nswitch (aref) {\r\ncase AREF_DIFF:\r\nhi |= NI_E_AI_CFG_HI_TYPE_DIFF;\r\nbreak;\r\ncase AREF_COMMON:\r\nhi |= NI_E_AI_CFG_HI_TYPE_COMMON;\r\nbreak;\r\ncase AREF_GROUND:\r\nhi |= NI_E_AI_CFG_HI_TYPE_GROUND;\r\nbreak;\r\ncase AREF_OTHER:\r\nbreak;\r\n}\r\n}\r\nhi |= NI_E_AI_CFG_HI_CHAN(chan);\r\nni_writew(dev, hi, NI_E_AI_CFG_HI_REG);\r\nif (!devpriv->is_6143) {\r\nlo = NI_E_AI_CFG_LO_GAIN(range);\r\nif (i == n_chan - 1)\r\nlo |= NI_E_AI_CFG_LO_LAST_CHAN;\r\nif (dither)\r\nlo |= NI_E_AI_CFG_LO_DITHER;\r\nni_writew(dev, lo, NI_E_AI_CFG_LO_REG);\r\n}\r\n}\r\nif (!devpriv->is_611x && !devpriv->is_6143)\r\nni_prime_channelgain_list(dev);\r\n}\r\nstatic int ni_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int mask = (s->maxdata + 1) >> 1;\r\nint i, n;\r\nunsigned int signbits;\r\nunsigned int d;\r\nunsigned long dl;\r\nni_load_channelgain_list(dev, s, 1, &insn->chanspec);\r\nni_clear_ai_fifo(dev);\r\nsignbits = devpriv->ai_offset[0];\r\nif (devpriv->is_611x) {\r\nfor (n = 0; n < num_adc_stages_611x; n++) {\r\nni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\r\nNISTC_AI_CMD1_REG);\r\nudelay(1);\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\r\nNISTC_AI_CMD1_REG);\r\nd = 0;\r\nfor (i = 0; i < NI_TIMEOUT; i++) {\r\nif (ni_readb(dev, NI_E_STATUS_REG) & 0x80) {\r\nd = ni_readl(dev,\r\nNI611X_AI_FIFO_DATA_REG);\r\nd >>= 16;\r\nd &= 0xffff;\r\nbreak;\r\n}\r\nif (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\r\nNISTC_AI_STATUS1_FIFO_E)) {\r\nd = ni_readl(dev,\r\nNI611X_AI_FIFO_DATA_REG);\r\nd &= 0xffff;\r\nbreak;\r\n}\r\n}\r\nif (i == NI_TIMEOUT) {\r\ndev_err(dev->class_dev, "timeout\n");\r\nreturn -ETIME;\r\n}\r\nd += signbits;\r\ndata[n] = d;\r\n}\r\n} else if (devpriv->is_6143) {\r\nfor (n = 0; n < insn->n; n++) {\r\nni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\r\nNISTC_AI_CMD1_REG);\r\ndl = 0;\r\nfor (i = 0; i < NI_TIMEOUT; i++) {\r\nif (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) &\r\n0x01) {\r\nni_writel(dev, 0x01,\r\nNI6143_AI_FIFO_CTRL_REG);\r\ndl = ni_readl(dev,\r\nNI6143_AI_FIFO_DATA_REG);\r\nbreak;\r\n}\r\n}\r\nif (i == NI_TIMEOUT) {\r\ndev_err(dev->class_dev, "timeout\n");\r\nreturn -ETIME;\r\n}\r\ndata[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;\r\n}\r\n} else {\r\nfor (n = 0; n < insn->n; n++) {\r\nni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\r\nNISTC_AI_CMD1_REG);\r\nfor (i = 0; i < NI_TIMEOUT; i++) {\r\nif (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\r\nNISTC_AI_STATUS1_FIFO_E))\r\nbreak;\r\n}\r\nif (i == NI_TIMEOUT) {\r\ndev_err(dev->class_dev, "timeout\n");\r\nreturn -ETIME;\r\n}\r\nif (devpriv->is_m_series) {\r\ndl = ni_readl(dev, NI_M_AI_FIFO_DATA_REG);\r\ndl &= mask;\r\ndata[n] = dl;\r\n} else {\r\nd = ni_readw(dev, NI_E_AI_FIFO_DATA_REG);\r\nd += signbits;\r\ndata[n] = d;\r\n}\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni_ns_to_timer(const struct comedi_device *dev,\r\nunsigned int nanosec, unsigned int flags)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint divider;\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\ndivider = DIV_ROUND_CLOSEST(nanosec, devpriv->clock_ns);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndivider = (nanosec) / devpriv->clock_ns;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndivider = DIV_ROUND_UP(nanosec, devpriv->clock_ns);\r\nbreak;\r\n}\r\nreturn divider - 1;\r\n}\r\nstatic unsigned int ni_timer_to_ns(const struct comedi_device *dev, int timer)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nreturn devpriv->clock_ns * (timer + 1);\r\n}\r\nstatic void ni_cmd_set_mite_transfer(struct mite_ring *ring,\r\nstruct comedi_subdevice *sdev,\r\nconst struct comedi_cmd *cmd,\r\nunsigned int max_count) {\r\n#ifdef PCIDMA\r\nunsigned int nbytes = max_count;\r\nif (cmd->stop_arg > 0 && cmd->stop_arg < max_count)\r\nnbytes = cmd->stop_arg;\r\nnbytes *= comedi_bytes_per_scan(sdev);\r\nif (nbytes > sdev->async->prealloc_bufsz) {\r\nif (cmd->stop_arg > 0)\r\ndev_err(sdev->device->class_dev,\r\n"ni_cmd_set_mite_transfer: tried exact data transfer limits greater than buffer size\n");\r\nnbytes = sdev->async->prealloc_bufsz;\r\n}\r\nmite_init_ring_descriptors(ring, sdev, nbytes);\r\n#else\r\ndev_err(sdev->device->class_dev,\r\n"ni_cmd_set_mite_transfer: exact data transfer limits not implemented yet without DMA\n");\r\n#endif\r\n}\r\nstatic unsigned int ni_min_ai_scan_period_ns(struct comedi_device *dev,\r\nunsigned int num_channels)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nif (devpriv->is_611x || devpriv->is_6143)\r\nreturn board->ai_speed;\r\nreturn board->ai_speed * num_channels;\r\n}\r\nstatic int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int tmp;\r\nunsigned int sources;\r\nerr |= comedi_check_trigger_src(&cmd->start_src,\r\nTRIG_NOW | TRIG_INT | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nsources = TRIG_TIMER | TRIG_EXT;\r\nif (devpriv->is_611x || devpriv->is_6143)\r\nsources |= TRIG_NOW;\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, sources);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\ncase TRIG_INT:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_EXT:\r\ntmp = CR_CHAN(cmd->start_arg);\r\nif (tmp > 16)\r\ntmp = 16;\r\ntmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, tmp);\r\nbreak;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nni_min_ai_scan_period_ns(dev, cmd->chanlist_len));\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\r\ndevpriv->clock_ns *\r\n0xffffff);\r\n} else if (cmd->scan_begin_src == TRIG_EXT) {\r\nunsigned int tmp = CR_CHAN(cmd->scan_begin_arg);\r\nif (tmp > 16)\r\ntmp = 16;\r\ntmp |= (cmd->scan_begin_arg & (CR_INVERT | CR_EDGE));\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);\r\n} else {\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (devpriv->is_611x || devpriv->is_6143) {\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg,\r\n0);\r\n} else {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\nerr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\r\ndevpriv->clock_ns *\r\n0xffff);\r\n}\r\n} else if (cmd->convert_src == TRIG_EXT) {\r\nunsigned int tmp = CR_CHAN(cmd->convert_arg);\r\nif (tmp > 16)\r\ntmp = 16;\r\ntmp |= (cmd->convert_arg & (CR_ALT_FILTER | CR_INVERT));\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, tmp);\r\n} else if (cmd->convert_src == TRIG_NOW) {\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nunsigned int max_count = 0x01000000;\r\nif (devpriv->is_611x)\r\nmax_count -= num_adc_stages_611x;\r\nerr |= comedi_check_trigger_arg_max(&cmd->stop_arg, max_count);\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\n} else {\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ncmd->scan_begin_arg =\r\nni_timer_to_ns(dev, ni_ns_to_timer(dev,\r\ncmd->scan_begin_arg,\r\ncmd->flags));\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (!devpriv->is_611x && !devpriv->is_6143) {\r\ntmp = cmd->convert_arg;\r\ncmd->convert_arg =\r\nni_timer_to_ns(dev, ni_ns_to_timer(dev,\r\ncmd->convert_arg,\r\ncmd->flags));\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->scan_begin_arg <\r\ncmd->convert_arg * cmd->scan_end_arg) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg * cmd->scan_end_arg;\r\nerr++;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int ni_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nni_stc_writew(dev, NISTC_AI_CMD2_START1_PULSE | devpriv->ai_cmd2,\r\nNISTC_AI_CMD2_REG);\r\ns->async->inttrig = NULL;\r\nreturn 1;\r\n}\r\nstatic int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nconst struct comedi_cmd *cmd = &s->async->cmd;\r\nint timer;\r\nint mode1 = 0;\r\nint mode2 = 0;\r\nint start_stop_select = 0;\r\nunsigned int stop_count;\r\nint interrupt_a_enable = 0;\r\nunsigned int ai_trig;\r\nif (dev->irq == 0) {\r\ndev_err(dev->class_dev, "cannot run command without an irq\n");\r\nreturn -EIO;\r\n}\r\nni_clear_ai_fifo(dev);\r\nni_load_channelgain_list(dev, s, cmd->chanlist_len, cmd->chanlist);\r\nni_stc_writew(dev, NISTC_RESET_AI_CFG_START, NISTC_RESET_REG);\r\ndevpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_ENA;\r\nni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);\r\nai_trig = NISTC_AI_TRIG_START2_SEL(0) | NISTC_AI_TRIG_START1_SYNC;\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\ncase TRIG_NOW:\r\nai_trig |= NISTC_AI_TRIG_START1_EDGE |\r\nNISTC_AI_TRIG_START1_SEL(0);\r\nbreak;\r\ncase TRIG_EXT:\r\nai_trig |= NISTC_AI_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) +\r\n1);\r\nif (cmd->start_arg & CR_INVERT)\r\nai_trig |= NISTC_AI_TRIG_START1_POLARITY;\r\nif (cmd->start_arg & CR_EDGE)\r\nai_trig |= NISTC_AI_TRIG_START1_EDGE;\r\nbreak;\r\n}\r\nni_stc_writew(dev, ai_trig, NISTC_AI_TRIG_SEL_REG);\r\nmode2 &= ~NISTC_AI_MODE2_PRE_TRIGGER;\r\nmode2 &= ~NISTC_AI_MODE2_SC_INIT_LOAD_SRC;\r\nmode2 &= ~NISTC_AI_MODE2_SC_RELOAD_MODE;\r\nni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\r\nif (cmd->chanlist_len == 1 || devpriv->is_611x || devpriv->is_6143) {\r\nstart_stop_select |= NISTC_AI_STOP_POLARITY |\r\nNISTC_AI_STOP_SEL(31) |\r\nNISTC_AI_STOP_SYNC;\r\n} else {\r\nstart_stop_select |= NISTC_AI_STOP_SEL(19);\r\n}\r\nni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);\r\ndevpriv->ai_cmd2 = 0;\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nstop_count = cmd->stop_arg - 1;\r\nif (devpriv->is_611x) {\r\nstop_count += num_adc_stages_611x;\r\n}\r\nni_stc_writel(dev, stop_count, NISTC_AI_SC_LOADA_REG);\r\nmode1 |= NISTC_AI_MODE1_START_STOP |\r\nNISTC_AI_MODE1_RSVD |\r\nNISTC_AI_MODE1_TRIGGER_ONCE;\r\nni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);\r\nni_stc_writew(dev, NISTC_AI_CMD1_SC_LOAD, NISTC_AI_CMD1_REG);\r\nif (stop_count == 0) {\r\ndevpriv->ai_cmd2 |= NISTC_AI_CMD2_END_ON_EOS;\r\ninterrupt_a_enable |= NISTC_INTA_ENA_AI_STOP;\r\nif (cmd->chanlist_len > 1)\r\nstart_stop_select |= NISTC_AI_STOP_POLARITY |\r\nNISTC_AI_STOP_EDGE;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\nni_stc_writel(dev, 0, NISTC_AI_SC_LOADA_REG);\r\nmode1 |= NISTC_AI_MODE1_START_STOP |\r\nNISTC_AI_MODE1_RSVD |\r\nNISTC_AI_MODE1_CONTINUOUS;\r\nni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);\r\nni_stc_writew(dev, NISTC_AI_CMD1_SC_LOAD, NISTC_AI_CMD1_REG);\r\nbreak;\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nstart_stop_select |= NISTC_AI_START_EDGE | NISTC_AI_START_SYNC;\r\nni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);\r\nmode2 &= ~NISTC_AI_MODE2_SI_INIT_LOAD_SRC;\r\nmode2 |= NISTC_AI_MODE2_SI_RELOAD_MODE(0);\r\nni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\r\ntimer = ni_ns_to_timer(dev, cmd->scan_begin_arg,\r\nCMDF_ROUND_NEAREST);\r\nni_stc_writel(dev, timer, NISTC_AI_SI_LOADA_REG);\r\nni_stc_writew(dev, NISTC_AI_CMD1_SI_LOAD, NISTC_AI_CMD1_REG);\r\nbreak;\r\ncase TRIG_EXT:\r\nif (cmd->scan_begin_arg & CR_EDGE)\r\nstart_stop_select |= NISTC_AI_START_EDGE;\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\nstart_stop_select |= NISTC_AI_START_POLARITY;\r\nif (cmd->scan_begin_src != cmd->convert_src ||\r\n(cmd->scan_begin_arg & ~CR_EDGE) !=\r\n(cmd->convert_arg & ~CR_EDGE))\r\nstart_stop_select |= NISTC_AI_START_SYNC;\r\nstart_stop_select |=\r\nNISTC_AI_START_SEL(1 + CR_CHAN(cmd->scan_begin_arg));\r\nni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);\r\nbreak;\r\n}\r\nswitch (cmd->convert_src) {\r\ncase TRIG_TIMER:\r\ncase TRIG_NOW:\r\nif (cmd->convert_arg == 0 || cmd->convert_src == TRIG_NOW)\r\ntimer = 1;\r\nelse\r\ntimer = ni_ns_to_timer(dev, cmd->convert_arg,\r\nCMDF_ROUND_NEAREST);\r\nni_stc_writew(dev, 1, NISTC_AI_SI2_LOADA_REG);\r\nni_stc_writew(dev, timer, NISTC_AI_SI2_LOADB_REG);\r\nmode2 &= ~NISTC_AI_MODE2_SI2_INIT_LOAD_SRC;\r\nmode2 |= NISTC_AI_MODE2_SI2_RELOAD_MODE;\r\nni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\r\nni_stc_writew(dev, NISTC_AI_CMD1_SI2_LOAD, NISTC_AI_CMD1_REG);\r\nmode2 |= NISTC_AI_MODE2_SI2_INIT_LOAD_SRC;\r\nmode2 |= NISTC_AI_MODE2_SI2_RELOAD_MODE;\r\nni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\r\nbreak;\r\ncase TRIG_EXT:\r\nmode1 |= NISTC_AI_MODE1_CONVERT_SRC(1 +\r\nCR_CHAN(cmd->convert_arg));\r\nif ((cmd->convert_arg & CR_INVERT) == 0)\r\nmode1 |= NISTC_AI_MODE1_CONVERT_POLARITY;\r\nni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);\r\nmode2 |= NISTC_AI_MODE2_SC_GATE_ENA |\r\nNISTC_AI_MODE2_START_STOP_GATE_ENA;\r\nni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\r\nbreak;\r\n}\r\nif (dev->irq) {\r\ninterrupt_a_enable |= NISTC_INTA_ENA_AI_ERR |\r\nNISTC_INTA_ENA_AI_SC_TC;\r\n#ifndef PCIDMA\r\ninterrupt_a_enable |= NISTC_INTA_ENA_AI_FIFO;\r\n#endif\r\nif ((cmd->flags & CMDF_WAKE_EOS) ||\r\n(devpriv->ai_cmd2 & NISTC_AI_CMD2_END_ON_EOS)) {\r\ndevpriv->aimode = AIMODE_SCAN;\r\n} else {\r\ndevpriv->aimode = AIMODE_HALF_FULL;\r\n}\r\nswitch (devpriv->aimode) {\r\ncase AIMODE_HALF_FULL:\r\n#ifdef PCIDMA\r\nni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF_E,\r\nNISTC_AI_MODE3_REG);\r\n#else\r\nni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF,\r\nNISTC_AI_MODE3_REG);\r\n#endif\r\nbreak;\r\ncase AIMODE_SAMPLE:\r\nni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,\r\nNISTC_AI_MODE3_REG);\r\nbreak;\r\ncase AIMODE_SCAN:\r\n#ifdef PCIDMA\r\nni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,\r\nNISTC_AI_MODE3_REG);\r\n#else\r\nni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF,\r\nNISTC_AI_MODE3_REG);\r\n#endif\r\ninterrupt_a_enable |= NISTC_INTA_ENA_AI_STOP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nni_stc_writew(dev, NISTC_INTA_ACK_AI_ALL, NISTC_INTA_ACK_REG);\r\nni_set_bits(dev, NISTC_INTA_ENA_REG, interrupt_a_enable, 1);\r\n} else {\r\nni_set_bits(dev, NISTC_INTA_ENA_REG, ~0, 0);\r\n}\r\nni_stc_writew(dev, NISTC_RESET_AI_CFG_END, NISTC_RESET_REG);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nni_stc_writew(dev, NISTC_AI_CMD1_SI2_ARM |\r\nNISTC_AI_CMD1_SI_ARM |\r\nNISTC_AI_CMD1_DIV_ARM |\r\nNISTC_AI_CMD1_SC_ARM,\r\nNISTC_AI_CMD1_REG);\r\nbreak;\r\ncase TRIG_EXT:\r\nni_stc_writew(dev, NISTC_AI_CMD1_SI2_ARM |\r\nNISTC_AI_CMD1_SI_ARM |\r\nNISTC_AI_CMD1_DIV_ARM |\r\nNISTC_AI_CMD1_SC_ARM,\r\nNISTC_AI_CMD1_REG);\r\nbreak;\r\n}\r\n#ifdef PCIDMA\r\n{\r\nint retval = ni_ai_setup_MITE_dma(dev);\r\nif (retval)\r\nreturn retval;\r\n}\r\n#endif\r\nif (cmd->start_src == TRIG_NOW) {\r\nni_stc_writew(dev, NISTC_AI_CMD2_START1_PULSE |\r\ndevpriv->ai_cmd2,\r\nNISTC_AI_CMD2_REG);\r\ns->async->inttrig = NULL;\r\n} else if (cmd->start_src == TRIG_EXT) {\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = ni_ai_inttrig;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_ai_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (insn->n < 1)\r\nreturn -EINVAL;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_ALT_SOURCE:\r\nif (devpriv->is_m_series) {\r\nif (data[1] & ~NI_M_CFG_BYPASS_AI_CAL_MASK)\r\nreturn -EINVAL;\r\ndevpriv->ai_calib_source = data[1];\r\n} else if (devpriv->is_6143) {\r\nunsigned int calib_source;\r\ncalib_source = data[1] & 0xf;\r\ndevpriv->ai_calib_source = calib_source;\r\nni_writew(dev, calib_source, NI6143_CALIB_CHAN_REG);\r\n} else {\r\nunsigned int calib_source;\r\nunsigned int calib_source_adjust;\r\ncalib_source = data[1] & 0xf;\r\ncalib_source_adjust = (data[1] >> 4) & 0xff;\r\nif (calib_source >= 8)\r\nreturn -EINVAL;\r\ndevpriv->ai_calib_source = calib_source;\r\nif (devpriv->is_611x) {\r\nni_writeb(dev, calib_source_adjust,\r\nNI611X_CAL_GAIN_SEL_REG);\r\n}\r\n}\r\nreturn 2;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,\r\nvoid *data, unsigned int num_bytes,\r\nunsigned int chan_index)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int nsamples = comedi_bytes_to_samples(s, num_bytes);\r\nunsigned short *array = data;\r\nunsigned int i;\r\n#ifdef PCIDMA\r\n__le16 buf, *barray = data;\r\n#endif\r\nfor (i = 0; i < nsamples; i++) {\r\nunsigned int range = CR_RANGE(cmd->chanlist[chan_index]);\r\nunsigned short val = array[i];\r\nif (comedi_range_is_bipolar(s, range))\r\nval = comedi_offset_munge(s, val);\r\n#ifdef PCIDMA\r\nbuf = cpu_to_le16(val);\r\nbarray[i] = buf;\r\n#else\r\narray[i] = val;\r\n#endif\r\nchan_index++;\r\nchan_index %= cmd->chanlist_len;\r\n}\r\n}\r\nstatic int ni_m_series_ao_config_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec[],\r\nunsigned int n_chans, int timed)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int range;\r\nunsigned int chan;\r\nunsigned int conf;\r\nint i;\r\nint invert = 0;\r\nif (timed) {\r\nfor (i = 0; i < s->n_chan; ++i) {\r\ndevpriv->ao_conf[i] &= ~NI_M_AO_CFG_BANK_UPDATE_TIMED;\r\nni_writeb(dev, devpriv->ao_conf[i],\r\nNI_M_AO_CFG_BANK_REG(i));\r\nni_writeb(dev, 0xf, NI_M_AO_WAVEFORM_ORDER_REG(i));\r\n}\r\n}\r\nfor (i = 0; i < n_chans; i++) {\r\nconst struct comedi_krange *krange;\r\nchan = CR_CHAN(chanspec[i]);\r\nrange = CR_RANGE(chanspec[i]);\r\nkrange = s->range_table->range + range;\r\ninvert = 0;\r\nconf = 0;\r\nswitch (krange->max - krange->min) {\r\ncase 20000000:\r\nconf |= NI_M_AO_CFG_BANK_REF_INT_10V;\r\nni_writeb(dev, 0, NI_M_AO_REF_ATTENUATION_REG(chan));\r\nbreak;\r\ncase 10000000:\r\nconf |= NI_M_AO_CFG_BANK_REF_INT_5V;\r\nni_writeb(dev, 0, NI_M_AO_REF_ATTENUATION_REG(chan));\r\nbreak;\r\ncase 4000000:\r\nconf |= NI_M_AO_CFG_BANK_REF_INT_10V;\r\nni_writeb(dev, NI_M_AO_REF_ATTENUATION_X5,\r\nNI_M_AO_REF_ATTENUATION_REG(chan));\r\nbreak;\r\ncase 2000000:\r\nconf |= NI_M_AO_CFG_BANK_REF_INT_5V;\r\nni_writeb(dev, NI_M_AO_REF_ATTENUATION_X5,\r\nNI_M_AO_REF_ATTENUATION_REG(chan));\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev,\r\n"bug! unhandled ao reference voltage\n");\r\nbreak;\r\n}\r\nswitch (krange->max + krange->min) {\r\ncase 0:\r\nconf |= NI_M_AO_CFG_BANK_OFFSET_0V;\r\nbreak;\r\ncase 10000000:\r\nconf |= NI_M_AO_CFG_BANK_OFFSET_5V;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev,\r\n"bug! unhandled ao offset voltage\n");\r\nbreak;\r\n}\r\nif (timed)\r\nconf |= NI_M_AO_CFG_BANK_UPDATE_TIMED;\r\nni_writeb(dev, conf, NI_M_AO_CFG_BANK_REG(chan));\r\ndevpriv->ao_conf[chan] = conf;\r\nni_writeb(dev, i, NI_M_AO_WAVEFORM_ORDER_REG(chan));\r\n}\r\nreturn invert;\r\n}\r\nstatic int ni_old_ao_config_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec[],\r\nunsigned int n_chans)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int range;\r\nunsigned int chan;\r\nunsigned int conf;\r\nint i;\r\nint invert = 0;\r\nfor (i = 0; i < n_chans; i++) {\r\nchan = CR_CHAN(chanspec[i]);\r\nrange = CR_RANGE(chanspec[i]);\r\nconf = NI_E_AO_DACSEL(chan);\r\nif (comedi_range_is_bipolar(s, range)) {\r\nconf |= NI_E_AO_CFG_BIP;\r\ninvert = (s->maxdata + 1) >> 1;\r\n} else {\r\ninvert = 0;\r\n}\r\nif (comedi_range_is_external(s, range))\r\nconf |= NI_E_AO_EXT_REF;\r\nif (chanspec[i] & CR_DEGLITCH)\r\nconf |= NI_E_AO_DEGLITCH;\r\nif (CR_AREF(chanspec[i]) == AREF_OTHER)\r\nconf |= NI_E_AO_GROUND_REF;\r\nni_writew(dev, conf, NI_E_AO_CFG_REG);\r\ndevpriv->ao_conf[chan] = conf;\r\n}\r\nreturn invert;\r\n}\r\nstatic int ni_ao_config_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec[], unsigned int n_chans,\r\nint timed)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (devpriv->is_m_series)\r\nreturn ni_m_series_ao_config_chanlist(dev, s, chanspec, n_chans,\r\ntimed);\r\nelse\r\nreturn ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);\r\n}\r\nstatic int ni_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nint reg;\r\nint i;\r\nif (devpriv->is_6xxx) {\r\nni_ao_win_outw(dev, 1 << chan, NI671X_AO_IMMEDIATE_REG);\r\nreg = NI671X_DAC_DIRECT_DATA_REG(chan);\r\n} else if (devpriv->is_m_series) {\r\nreg = NI_M_DAC_DIRECT_DATA_REG(chan);\r\n} else {\r\nreg = NI_E_DAC_DIRECT_DATA_REG(chan);\r\n}\r\nni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\ns->readback[chan] = val;\r\nif (devpriv->is_6xxx) {\r\nval = comedi_offset_munge(s, val);\r\nni_ao_win_outw(dev, val, reg);\r\n} else if (devpriv->is_m_series) {\r\nni_writew(dev, val, reg);\r\n} else {\r\nif (comedi_range_is_bipolar(s, range))\r\nval = comedi_offset_munge(s, val);\r\nni_writew(dev, val, reg);\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni_ao_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int nbytes;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:\r\nswitch (data[1]) {\r\ncase COMEDI_OUTPUT:\r\nnbytes = comedi_samples_to_bytes(s,\r\nboard->ao_fifo_depth);\r\ndata[2] = 1 + nbytes;\r\nif (devpriv->mite)\r\ndata[2] += devpriv->mite->fifo_size;\r\nbreak;\r\ncase COMEDI_INPUT:\r\ndata[2] = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ni_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\nint interrupt_b_bits;\r\nint i;\r\nstatic const int timeout = 1000;\r\nif (!(trig_num == cmd->start_arg ||\r\n(trig_num == 0 && cmd->start_src != TRIG_INT)))\r\nreturn -EINVAL;\r\ns->async->inttrig = NULL;\r\nni_set_bits(dev, NISTC_INTB_ENA_REG,\r\nNISTC_INTB_ENA_AO_FIFO | NISTC_INTB_ENA_AO_ERR, 0);\r\ninterrupt_b_bits = NISTC_INTB_ENA_AO_ERR;\r\n#ifdef PCIDMA\r\nni_stc_writew(dev, 1, NISTC_DAC_FIFO_CLR_REG);\r\nif (devpriv->is_6xxx)\r\nni_ao_win_outl(dev, 0x6, NI611X_AO_FIFO_OFFSET_LOAD_REG);\r\nret = ni_ao_setup_MITE_dma(dev);\r\nif (ret)\r\nreturn ret;\r\nret = ni_ao_wait_for_dma_load(dev);\r\nif (ret < 0)\r\nreturn ret;\r\n#else\r\nret = ni_ao_prep_fifo(dev, s);\r\nif (ret == 0)\r\nreturn -EPIPE;\r\ninterrupt_b_bits |= NISTC_INTB_ENA_AO_FIFO;\r\n#endif\r\nni_stc_writew(dev, devpriv->ao_mode3 | NISTC_AO_MODE3_NOT_AN_UPDATE,\r\nNISTC_AO_MODE3_REG);\r\nni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);\r\nfor (i = 0; i < timeout; i++) {\r\nudelay(1);\r\nif ((ni_stc_readw(dev, NISTC_STATUS2_REG) &\r\nNISTC_STATUS2_AO_TMRDACWRS_IN_PROGRESS) == 0)\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ndev_err(dev->class_dev,\r\n"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear\n");\r\nreturn -EIO;\r\n}\r\nni_stc_writew(dev, NISTC_INTB_ACK_AO_ERR, NISTC_INTB_ACK_REG);\r\nni_set_bits(dev, NISTC_INTB_ENA_REG, interrupt_b_bits, 1);\r\nni_stc_writew(dev, NISTC_AO_CMD1_UI_ARM |\r\nNISTC_AO_CMD1_UC_ARM |\r\nNISTC_AO_CMD1_BC_ARM |\r\ndevpriv->ao_cmd1,\r\nNISTC_AO_CMD1_REG);\r\nni_stc_writew(dev, NISTC_AO_CMD2_START1_PULSE | devpriv->ao_cmd2,\r\nNISTC_AO_CMD2_REG);\r\nreturn 0;\r\n}\r\nstatic void ni_ao_cmd_personalize(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nunsigned int bits;\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\r\nbits =\r\nNISTC_AO_PERSONAL_BC_SRC_SEL |\r\n0 |\r\nNISTC_AO_PERSONAL_UPDATE_PW |\r\nNISTC_AO_PERSONAL_TMRDACWR_PW |\r\n(board->ao_fifo_depth ?\r\nNISTC_AO_PERSONAL_FIFO_ENA : NISTC_AO_PERSONAL_DMA_PIO_CTRL)\r\n;\r\n#if 0\r\nif (devpriv->is_m_series)\r\nbits |= NISTC_AO_PERSONAL_NUM_DAC;\r\n#endif\r\nni_stc_writew(dev, bits, NISTC_AO_PERSONAL_REG);\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\r\n}\r\nstatic void ni_ao_cmd_set_trigger(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int trigsel;\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\r\nif (cmd->stop_src == TRIG_NONE) {\r\ndevpriv->ao_mode1 |= NISTC_AO_MODE1_CONTINUOUS;\r\ndevpriv->ao_mode1 &= ~NISTC_AO_MODE1_TRIGGER_ONCE;\r\n} else {\r\ndevpriv->ao_mode1 &= ~NISTC_AO_MODE1_CONTINUOUS;\r\ndevpriv->ao_mode1 |= NISTC_AO_MODE1_TRIGGER_ONCE;\r\n}\r\nni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);\r\nif (cmd->start_src == TRIG_INT) {\r\ntrigsel = NISTC_AO_TRIG_START1_EDGE |\r\nNISTC_AO_TRIG_START1_SYNC;\r\n} else {\r\ntrigsel = NISTC_AO_TRIG_START1_SEL(CR_CHAN(cmd->start_arg) + 1);\r\nif (cmd->start_arg & CR_INVERT)\r\ntrigsel |= NISTC_AO_TRIG_START1_POLARITY;\r\nif (cmd->start_arg & CR_EDGE)\r\ntrigsel |= NISTC_AO_TRIG_START1_EDGE;\r\n}\r\nni_stc_writew(dev, trigsel, NISTC_AO_TRIG_SEL_REG);\r\ndevpriv->ao_mode3 &= ~NISTC_AO_MODE3_TRIG_LEN;\r\nni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\r\n}\r\nstatic void ni_ao_cmd_set_counters(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\r\nni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);\r\ndevpriv->ao_mode2 &= ~NISTC_AO_MODE2_BC_INIT_LOAD_SRC;\r\nni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);\r\nni_stc_writel(dev, 0, NISTC_AO_BC_LOADA_REG);\r\nni_stc_writew(dev, NISTC_AO_CMD1_BC_LOAD, NISTC_AO_CMD1_REG);\r\ndevpriv->ao_mode2 &= ~NISTC_AO_MODE2_UC_INIT_LOAD_SRC;\r\nni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);\r\n{\r\nunsigned int stop_arg = cmd->stop_arg > 0 ?\r\n(cmd->stop_arg & 0xffffff) : 0xffffff;\r\nif (devpriv->is_m_series) {\r\nni_stc_writel(dev, stop_arg - 1, NISTC_AO_UC_LOADA_REG);\r\nni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,\r\nNISTC_AO_CMD1_REG);\r\n} else {\r\nni_stc_writel(dev, stop_arg, NISTC_AO_UC_LOADA_REG);\r\nni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,\r\nNISTC_AO_CMD1_REG);\r\nni_stc_writel(dev, stop_arg - 1, NISTC_AO_UC_LOADA_REG);\r\n}\r\n}\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\r\n}\r\nstatic void ni_ao_cmd_set_update(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\r\ndevpriv->ao_mode1 &= ~(\r\nNISTC_AO_MODE1_UI_SRC_MASK |\r\nNISTC_AO_MODE1_UI_SRC_POLARITY |\r\nNISTC_AO_MODE1_UPDATE_SRC_MASK |\r\nNISTC_AO_MODE1_UPDATE_SRC_POLARITY\r\n);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int trigvar;\r\ndevpriv->ao_cmd2 &= ~NISTC_AO_CMD2_BC_GATE_ENA;\r\ntrigvar = ni_ns_to_timer(dev, cmd->scan_begin_arg,\r\nCMDF_ROUND_NEAREST);\r\nni_stc_writel(dev, 1, NISTC_AO_UI_LOADA_REG);\r\nni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD, NISTC_AO_CMD1_REG);\r\nni_stc_writel(dev, trigvar - 1, NISTC_AO_UI_LOADA_REG);\r\n} else {\r\ndevpriv->ao_cmd2 |= NISTC_AO_CMD2_BC_GATE_ENA;\r\ndevpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC(\r\nCR_CHAN(cmd->scan_begin_arg));\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\ndevpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC_POLARITY;\r\n}\r\nni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);\r\nni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);\r\ndevpriv->ao_mode2 &= ~(NISTC_AO_MODE2_UI_RELOAD_MODE(3) |\r\nNISTC_AO_MODE2_UI_INIT_LOAD_SRC);\r\nni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);\r\ndevpriv->ao_cmd1 |= NISTC_AO_CMD1_DAC1_UPDATE_MODE |\r\nNISTC_AO_CMD1_DAC0_UPDATE_MODE;\r\nni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\r\n}\r\nstatic void ni_ao_cmd_set_channels(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nconst struct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int bits = 0;\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\r\nif (devpriv->is_6xxx) {\r\nunsigned int i;\r\nbits = 0;\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nint chan = CR_CHAN(cmd->chanlist[i]);\r\nbits |= 1 << chan;\r\nni_ao_win_outw(dev, chan, NI611X_AO_WAVEFORM_GEN_REG);\r\n}\r\nni_ao_win_outw(dev, bits, NI611X_AO_TIMED_REG);\r\n}\r\nni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);\r\nif (cmd->scan_end_arg > 1) {\r\ndevpriv->ao_mode1 |= NISTC_AO_MODE1_MULTI_CHAN;\r\nbits = NISTC_AO_OUT_CTRL_CHANS(cmd->scan_end_arg - 1)\r\n| NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ;\r\n} else {\r\ndevpriv->ao_mode1 &= ~NISTC_AO_MODE1_MULTI_CHAN;\r\nbits = NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ;\r\nif (devpriv->is_m_series | devpriv->is_6xxx)\r\nbits |= NISTC_AO_OUT_CTRL_CHANS(0);\r\nelse\r\nbits |= NISTC_AO_OUT_CTRL_CHANS(\r\nCR_CHAN(cmd->chanlist[0]));\r\n}\r\nni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);\r\nni_stc_writew(dev, bits, NISTC_AO_OUT_CTRL_REG);\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\r\n}\r\nstatic void ni_ao_cmd_set_stop_conditions(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\r\ndevpriv->ao_mode3 |= NISTC_AO_MODE3_STOP_ON_OVERRUN_ERR;\r\nni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\r\n}\r\nstatic void ni_ao_cmd_set_fifo_mode(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\r\ndevpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_MODE_MASK;\r\n#ifdef PCIDMA\r\ndevpriv->ao_mode2 |= NISTC_AO_MODE2_FIFO_MODE_HF_F;\r\n#else\r\ndevpriv->ao_mode2 |= NISTC_AO_MODE2_FIFO_MODE_HF;\r\n#endif\r\ndevpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_REXMIT_ENA;\r\nni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);\r\nni_stc_writew(dev, NISTC_AO_START_AOFREQ_ENA, NISTC_AO_START_SEL_REG);\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\r\n}\r\nstatic void ni_ao_cmd_set_interrupts(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nif (s->async->cmd.stop_src == TRIG_COUNT)\r\nni_set_bits(dev, NISTC_INTB_ENA_REG,\r\nNISTC_INTB_ENA_AO_BC_TC, 1);\r\ns->async->inttrig = ni_ao_inttrig;\r\n}\r\nstatic int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nconst struct comedi_cmd *cmd = &s->async->cmd;\r\nif (dev->irq == 0) {\r\ndev_err(dev->class_dev, "cannot run command without an irq");\r\nreturn -EIO;\r\n}\r\nni_ao_cmd_personalize(dev, cmd);\r\nni_ao_cmd_set_trigger(dev, cmd);\r\nni_ao_cmd_set_counters(dev, cmd);\r\nni_ao_cmd_set_update(dev, cmd);\r\nni_ao_cmd_set_channels(dev, s);\r\nni_ao_cmd_set_stop_conditions(dev, cmd);\r\nni_ao_cmd_set_fifo_mode(dev);\r\nni_cmd_set_mite_transfer(devpriv->ao_mite_ring, s, cmd, 0x00ffffff);\r\nni_ao_cmd_set_interrupts(dev, s);\r\nreturn 0;\r\n}\r\nstatic int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int tmp;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_EXT:\r\ntmp = CR_CHAN(cmd->start_arg);\r\nif (tmp > 18)\r\ntmp = 18;\r\ntmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, tmp);\r\nbreak;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ao_speed);\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\r\ndevpriv->clock_ns *\r\n0xffffff);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nerr |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ncmd->scan_begin_arg =\r\nni_timer_to_ns(dev, ni_ns_to_timer(dev,\r\ncmd->scan_begin_arg,\r\ncmd->flags));\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nni_release_ao_mite_channel(dev);\r\nif (devpriv->is_m_series)\r\nni_stc_writew(dev, NISTC_RESET_AO, NISTC_RESET_REG);\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\r\nni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);\r\ndevpriv->ao_cmd1 = 0;\r\ndevpriv->ao_cmd2 = 0;\r\ndevpriv->ao_mode1 = 0;\r\ndevpriv->ao_mode2 = 0;\r\nif (devpriv->is_m_series)\r\ndevpriv->ao_mode3 = NISTC_AO_MODE3_LAST_GATE_DISABLE;\r\nelse\r\ndevpriv->ao_mode3 = 0;\r\nni_stc_writew(dev, 0, NISTC_AO_PERSONAL_REG);\r\nni_stc_writew(dev, 0, NISTC_AO_CMD1_REG);\r\nni_stc_writew(dev, 0, NISTC_AO_CMD2_REG);\r\nni_stc_writew(dev, 0, NISTC_AO_MODE1_REG);\r\nni_stc_writew(dev, 0, NISTC_AO_MODE2_REG);\r\nni_stc_writew(dev, 0, NISTC_AO_OUT_CTRL_REG);\r\nni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);\r\nni_stc_writew(dev, 0, NISTC_AO_START_SEL_REG);\r\nni_stc_writew(dev, 0, NISTC_AO_TRIG_SEL_REG);\r\nni_set_bits(dev, NISTC_INTB_ENA_REG, ~0, 0);\r\nni_stc_writew(dev, NISTC_AO_PERSONAL_BC_SRC_SEL, NISTC_AO_PERSONAL_REG);\r\nni_stc_writew(dev, NISTC_INTB_ACK_AO_ALL, NISTC_INTB_ACK_REG);\r\nif (devpriv->is_6xxx) {\r\nni_ao_win_outw(dev, (1u << s->n_chan) - 1u,\r\nNI671X_AO_IMMEDIATE_REG);\r\nni_ao_win_outw(dev, NI611X_AO_MISC_CLEAR_WG,\r\nNI611X_AO_MISC_REG);\r\n}\r\nni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\r\nreturn 0;\r\n}\r\nstatic int ni_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->dio_control &= ~NISTC_DIO_CTRL_DIR_MASK;\r\ndevpriv->dio_control |= NISTC_DIO_CTRL_DIR(s->io_bits);\r\nni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\r\nreturn insn->n;\r\n}\r\nstatic int ni_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif ((data[0] & (NISTC_DIO_SDIN | NISTC_DIO_SDOUT)) &&\r\ndevpriv->serial_interval_ns)\r\nreturn -EBUSY;\r\nif (comedi_dio_update_state(s, data)) {\r\ndevpriv->dio_output &= ~NISTC_DIO_OUT_PARALLEL_MASK;\r\ndevpriv->dio_output |= NISTC_DIO_OUT_PARALLEL(s->state);\r\nni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);\r\n}\r\ndata[1] = ni_stc_readw(dev, NISTC_DIO_IN_REG);\r\nreturn insn->n;\r\n}\r\nstatic int ni_m_series_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nni_writel(dev, s->io_bits, NI_M_DIO_DIR_REG);\r\nreturn insn->n;\r\n}\r\nstatic int ni_m_series_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\nni_writel(dev, s->state, NI_M_DIO_REG);\r\ndata[1] = ni_readl(dev, NI_M_DIO_REG);\r\nreturn insn->n;\r\n}\r\nstatic int ni_cdio_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nif (chan != i)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_cdio_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\ntmp = cmd->scan_begin_arg;\r\ntmp &= CR_PACK_FLAGS(NI_M_CDO_MODE_SAMPLE_SRC_MASK, 0, 0, CR_INVERT);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr |= -EINVAL;\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nerr |= comedi_check_trigger_arg_max(&cmd->stop_arg,\r\ns->async->prealloc_bufsz /\r\ncomedi_bytes_per_scan(s));\r\nif (err)\r\nreturn 3;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= ni_cdio_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int ni_cdo_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nconst unsigned int timeout = 1000;\r\nint retval = 0;\r\nunsigned int i;\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\ns->async->inttrig = NULL;\r\ncomedi_buf_read_alloc(s, s->async->prealloc_bufsz);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->cdo_mite_chan) {\r\nmite_prep_dma(devpriv->cdo_mite_chan, 32, 32);\r\nmite_dma_arm(devpriv->cdo_mite_chan);\r\n} else {\r\ndev_err(dev->class_dev, "BUG: no cdo mite channel?\n");\r\nretval = -EIO;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nif (retval < 0)\r\nreturn retval;\r\nfor (i = 0; i < timeout; ++i) {\r\nif (ni_readl(dev, NI_M_CDIO_STATUS_REG) &\r\nNI_M_CDIO_STATUS_CDO_FIFO_FULL)\r\nbreak;\r\nusleep_range(10, 100);\r\n}\r\nif (i == timeout) {\r\ndev_err(dev->class_dev, "dma failed to fill cdo fifo!\n");\r\ns->cancel(dev, s);\r\nreturn -EIO;\r\n}\r\nni_writel(dev, NI_M_CDO_CMD_ARM |\r\nNI_M_CDO_CMD_ERR_INT_ENA_SET |\r\nNI_M_CDO_CMD_F_E_INT_ENA_SET,\r\nNI_M_CDIO_CMD_REG);\r\nreturn retval;\r\n}\r\nstatic int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nconst struct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int cdo_mode_bits;\r\nint retval;\r\nni_writel(dev, NI_M_CDO_CMD_RESET, NI_M_CDIO_CMD_REG);\r\ncdo_mode_bits = NI_M_CDO_MODE_FIFO_MODE |\r\nNI_M_CDO_MODE_HALT_ON_ERROR |\r\nNI_M_CDO_MODE_SAMPLE_SRC(CR_CHAN(cmd->scan_begin_arg));\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\ncdo_mode_bits |= NI_M_CDO_MODE_POLARITY;\r\nni_writel(dev, cdo_mode_bits, NI_M_CDO_MODE_REG);\r\nif (s->io_bits) {\r\nni_writel(dev, s->state, NI_M_CDO_FIFO_DATA_REG);\r\nni_writel(dev, NI_M_CDO_CMD_SW_UPDATE, NI_M_CDIO_CMD_REG);\r\nni_writel(dev, s->io_bits, NI_M_CDO_MASK_ENA_REG);\r\n} else {\r\ndev_err(dev->class_dev,\r\n"attempted to run digital output command with no lines configured as outputs\n");\r\nreturn -EIO;\r\n}\r\nretval = ni_request_cdo_mite_channel(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nni_cmd_set_mite_transfer(devpriv->cdo_mite_ring, s, cmd,\r\ns->async->prealloc_bufsz /\r\ncomedi_bytes_per_scan(s));\r\ns->async->inttrig = ni_cdo_inttrig;\r\nreturn 0;\r\n}\r\nstatic int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nni_writel(dev, NI_M_CDO_CMD_DISARM |\r\nNI_M_CDO_CMD_ERR_INT_ENA_CLR |\r\nNI_M_CDO_CMD_F_E_INT_ENA_CLR |\r\nNI_M_CDO_CMD_F_REQ_INT_ENA_CLR,\r\nNI_M_CDIO_CMD_REG);\r\nni_writel(dev, 0, NI_M_CDO_MASK_ENA_REG);\r\nni_release_cdo_mite_channel(dev);\r\nreturn 0;\r\n}\r\nstatic void handle_cdio_interrupt(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int cdio_status;\r\nstruct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->cdo_mite_chan)\r\nmite_ack_linkc(devpriv->cdo_mite_chan, s, true);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ncdio_status = ni_readl(dev, NI_M_CDIO_STATUS_REG);\r\nif (cdio_status & NI_M_CDIO_STATUS_CDO_ERROR) {\r\nni_writel(dev, NI_M_CDO_CMD_ERR_INT_CONFIRM,\r\nNI_M_CDIO_CMD_REG);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\nif (cdio_status & NI_M_CDIO_STATUS_CDO_FIFO_EMPTY) {\r\nni_writel(dev, NI_M_CDO_CMD_F_E_INT_ENA_CLR,\r\nNI_M_CDIO_CMD_REG);\r\n}\r\ncomedi_handle_events(dev, s);\r\n}\r\nstatic int ni_serial_hw_readwrite8(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned char data_out,\r\nunsigned char *data_in)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int status1;\r\nint err = 0, count = 20;\r\ndevpriv->dio_output &= ~NISTC_DIO_OUT_SERIAL_MASK;\r\ndevpriv->dio_output |= NISTC_DIO_OUT_SERIAL(data_out);\r\nni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);\r\nstatus1 = ni_stc_readw(dev, NISTC_STATUS1_REG);\r\nif (status1 & NISTC_STATUS1_SERIO_IN_PROG) {\r\nerr = -EBUSY;\r\ngoto error;\r\n}\r\ndevpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_START;\r\nni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\r\ndevpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_START;\r\nwhile ((status1 = ni_stc_readw(dev, NISTC_STATUS1_REG)) &\r\nNISTC_STATUS1_SERIO_IN_PROG) {\r\nudelay((devpriv->serial_interval_ns + 999) / 1000);\r\nif (--count < 0) {\r\ndev_err(dev->class_dev,\r\n"SPI serial I/O didn't finish in time!\n");\r\nerr = -ETIME;\r\ngoto error;\r\n}\r\n}\r\nudelay((devpriv->serial_interval_ns + 999) / 1000);\r\nif (data_in)\r\n*data_in = ni_stc_readw(dev, NISTC_DIO_SERIAL_IN_REG);\r\nerror:\r\nni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\r\nreturn err;\r\n}\r\nstatic int ni_serial_sw_readwrite8(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned char data_out,\r\nunsigned char *data_in)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned char mask, input = 0;\r\nudelay((devpriv->serial_interval_ns + 999) / 1000);\r\nfor (mask = 0x80; mask; mask >>= 1) {\r\ndevpriv->dio_output &= ~NISTC_DIO_SDOUT;\r\nif (data_out & mask)\r\ndevpriv->dio_output |= NISTC_DIO_SDOUT;\r\nni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);\r\ndevpriv->dio_control |= NISTC_DIO_SDCLK;\r\nni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\r\nudelay((devpriv->serial_interval_ns + 999) / 2000);\r\ndevpriv->dio_control &= ~NISTC_DIO_SDCLK;\r\nni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\r\nudelay((devpriv->serial_interval_ns + 999) / 2000);\r\nif (ni_stc_readw(dev, NISTC_DIO_IN_REG) & NISTC_DIO_SDIN)\r\ninput |= mask;\r\n}\r\nif (data_in)\r\n*data_in = input;\r\nreturn 0;\r\n}\r\nstatic int ni_serial_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int clk_fout = devpriv->clock_and_fout;\r\nint err = insn->n;\r\nunsigned char byte_out, byte_in = 0;\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SERIAL_CLOCK:\r\ndevpriv->serial_hw_mode = 1;\r\ndevpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_ENA;\r\nif (data[1] == SERIAL_DISABLED) {\r\ndevpriv->serial_hw_mode = 0;\r\ndevpriv->dio_control &= ~(NISTC_DIO_CTRL_HW_SER_ENA |\r\nNISTC_DIO_SDCLK);\r\ndata[1] = SERIAL_DISABLED;\r\ndevpriv->serial_interval_ns = data[1];\r\n} else if (data[1] <= SERIAL_600NS) {\r\ndevpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;\r\nclk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE;\r\nclk_fout &= ~NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;\r\ndata[1] = SERIAL_600NS;\r\ndevpriv->serial_interval_ns = data[1];\r\n} else if (data[1] <= SERIAL_1_2US) {\r\ndevpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;\r\nclk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE |\r\nNISTC_CLK_FOUT_DIO_SER_OUT_DIV2;\r\ndata[1] = SERIAL_1_2US;\r\ndevpriv->serial_interval_ns = data[1];\r\n} else if (data[1] <= SERIAL_10US) {\r\ndevpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_TIMEBASE;\r\nclk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE |\r\nNISTC_CLK_FOUT_DIO_SER_OUT_DIV2;\r\ndata[1] = SERIAL_10US;\r\ndevpriv->serial_interval_ns = data[1];\r\n} else {\r\ndevpriv->dio_control &= ~(NISTC_DIO_CTRL_HW_SER_ENA |\r\nNISTC_DIO_SDCLK);\r\ndevpriv->serial_hw_mode = 0;\r\ndata[1] = (data[1] / 1000) * 1000;\r\ndevpriv->serial_interval_ns = data[1];\r\n}\r\ndevpriv->clock_and_fout = clk_fout;\r\nni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\r\nni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\r\nreturn 1;\r\ncase INSN_CONFIG_BIDIRECTIONAL_DATA:\r\nif (devpriv->serial_interval_ns == 0)\r\nreturn -EINVAL;\r\nbyte_out = data[1] & 0xFF;\r\nif (devpriv->serial_hw_mode) {\r\nerr = ni_serial_hw_readwrite8(dev, s, byte_out,\r\n&byte_in);\r\n} else if (devpriv->serial_interval_ns > 0) {\r\nerr = ni_serial_sw_readwrite8(dev, s, byte_out,\r\n&byte_in);\r\n} else {\r\ndev_err(dev->class_dev, "serial disabled!\n");\r\nreturn -EINVAL;\r\n}\r\nif (err < 0)\r\nreturn err;\r\ndata[1] = byte_in & 0xFF;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint i;\r\nfor (i = 0; i < s->n_chan; i++) {\r\nni_ao_win_outw(dev, NI_E_AO_DACSEL(i) | 0x0,\r\nNI67XX_AO_CFG2_REG);\r\n}\r\nni_ao_win_outw(dev, 0x0, NI67XX_AO_SP_UPDATES_REG);\r\n}\r\nstatic unsigned int ni_gpct_to_stc_register(struct comedi_device *dev,\r\nenum ni_gpct_register reg)\r\n{\r\nconst struct mio_regmap *regmap;\r\nif (reg < ARRAY_SIZE(ni_gpct_to_stc_regmap)) {\r\nregmap = &ni_gpct_to_stc_regmap[reg];\r\n} else {\r\ndev_warn(dev->class_dev, "%s: unhandled register=0x%x\n",\r\n__func__, reg);\r\nreturn 0;\r\n}\r\nreturn regmap->mio_reg;\r\n}\r\nstatic void ni_gpct_write_register(struct ni_gpct *counter, unsigned int bits,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct comedi_device *dev = counter->counter_dev->dev;\r\nunsigned int stc_register = ni_gpct_to_stc_register(dev, reg);\r\nif (stc_register == 0)\r\nreturn;\r\nswitch (reg) {\r\ncase NITIO_G0_CNT_MODE:\r\ncase NITIO_G1_CNT_MODE:\r\ncase NITIO_G0_GATE2:\r\ncase NITIO_G1_GATE2:\r\ncase NITIO_G0_DMA_CFG:\r\ncase NITIO_G1_DMA_CFG:\r\ncase NITIO_G0_ABZ:\r\ncase NITIO_G1_ABZ:\r\nni_writew(dev, bits, stc_register);\r\nbreak;\r\ncase NITIO_G0_LOADA:\r\ncase NITIO_G1_LOADA:\r\ncase NITIO_G0_LOADB:\r\ncase NITIO_G1_LOADB:\r\nni_stc_writel(dev, bits, stc_register);\r\nbreak;\r\ncase NITIO_G0_INT_ENA:\r\nni_set_bitfield(dev, stc_register,\r\nNISTC_INTA_ENA_G0_GATE | NISTC_INTA_ENA_G0_TC,\r\nbits);\r\nbreak;\r\ncase NITIO_G1_INT_ENA:\r\nni_set_bitfield(dev, stc_register,\r\nNISTC_INTB_ENA_G1_GATE | NISTC_INTB_ENA_G1_TC,\r\nbits);\r\nbreak;\r\ndefault:\r\nni_stc_writew(dev, bits, stc_register);\r\n}\r\n}\r\nstatic unsigned int ni_gpct_read_register(struct ni_gpct *counter,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct comedi_device *dev = counter->counter_dev->dev;\r\nunsigned int stc_register = ni_gpct_to_stc_register(dev, reg);\r\nif (stc_register == 0)\r\nreturn 0;\r\nswitch (reg) {\r\ncase NITIO_G0_DMA_STATUS:\r\ncase NITIO_G1_DMA_STATUS:\r\nreturn ni_readw(dev, stc_register);\r\ncase NITIO_G0_HW_SAVE:\r\ncase NITIO_G1_HW_SAVE:\r\ncase NITIO_G0_SW_SAVE:\r\ncase NITIO_G1_SW_SAVE:\r\nreturn ni_stc_readl(dev, stc_register);\r\ndefault:\r\nreturn ni_stc_readw(dev, stc_register);\r\n}\r\n}\r\nstatic int ni_freq_out_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int val = NISTC_CLK_FOUT_TO_DIVIDER(devpriv->clock_and_fout);\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = val;\r\nreturn insn->n;\r\n}\r\nstatic int ni_freq_out_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\ndevpriv->clock_and_fout &= ~NISTC_CLK_FOUT_ENA;\r\nni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\r\ndevpriv->clock_and_fout &= ~NISTC_CLK_FOUT_DIVIDER_MASK;\r\ndevpriv->clock_and_fout |= NISTC_CLK_FOUT_DIVIDER(val);\r\ndevpriv->clock_and_fout |= NISTC_CLK_FOUT_ENA;\r\nni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni_freq_out_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nswitch (data[1]) {\r\ncase NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:\r\ndevpriv->clock_and_fout &= ~NISTC_CLK_FOUT_TIMEBASE_SEL;\r\nbreak;\r\ncase NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC:\r\ndevpriv->clock_and_fout |= NISTC_CLK_FOUT_TIMEBASE_SEL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\nif (devpriv->clock_and_fout & NISTC_CLK_FOUT_TIMEBASE_SEL) {\r\ndata[1] = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;\r\ndata[2] = TIMEBASE_2_NS;\r\n} else {\r\ndata[1] = NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC;\r\ndata[2] = TIMEBASE_1_NS * 2;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int ni_8255_callback(struct comedi_device *dev,\r\nint dir, int port, int data, unsigned long iobase)\r\n{\r\nif (dir) {\r\nni_writeb(dev, data, iobase + 2 * port);\r\nreturn 0;\r\n}\r\nreturn ni_readb(dev, iobase + 2 * port);\r\n}\r\nstatic int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\ndata[1] = devpriv->pwm_up_count * devpriv->clock_ns;\r\ndata[2] = devpriv->pwm_down_count * devpriv->clock_ns;\r\nreturn 3;\r\n}\r\nstatic int ni_m_series_pwm_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int up_count, down_count;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_PWM_OUTPUT:\r\nswitch (data[1]) {\r\ncase CMDF_ROUND_NEAREST:\r\nup_count = DIV_ROUND_CLOSEST(data[2],\r\ndevpriv->clock_ns);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\nup_count = data[2] / devpriv->clock_ns;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\nup_count =\r\nDIV_ROUND_UP(data[2], devpriv->clock_ns);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (data[3]) {\r\ncase CMDF_ROUND_NEAREST:\r\ndown_count = DIV_ROUND_CLOSEST(data[4],\r\ndevpriv->clock_ns);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndown_count = data[4] / devpriv->clock_ns;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndown_count =\r\nDIV_ROUND_UP(data[4], devpriv->clock_ns);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (up_count * devpriv->clock_ns != data[2] ||\r\ndown_count * devpriv->clock_ns != data[4]) {\r\ndata[2] = up_count * devpriv->clock_ns;\r\ndata[4] = down_count * devpriv->clock_ns;\r\nreturn -EAGAIN;\r\n}\r\nni_writel(dev, NI_M_CAL_PWM_HIGH_TIME(up_count) |\r\nNI_M_CAL_PWM_LOW_TIME(down_count),\r\nNI_M_CAL_PWM_REG);\r\ndevpriv->pwm_up_count = up_count;\r\ndevpriv->pwm_down_count = down_count;\r\nreturn 5;\r\ncase INSN_CONFIG_GET_PWM_OUTPUT:\r\nreturn ni_get_pwm_config(dev, data);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_6143_pwm_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int up_count, down_count;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_PWM_OUTPUT:\r\nswitch (data[1]) {\r\ncase CMDF_ROUND_NEAREST:\r\nup_count = DIV_ROUND_CLOSEST(data[2],\r\ndevpriv->clock_ns);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\nup_count = data[2] / devpriv->clock_ns;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\nup_count =\r\nDIV_ROUND_UP(data[2], devpriv->clock_ns);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (data[3]) {\r\ncase CMDF_ROUND_NEAREST:\r\ndown_count = DIV_ROUND_CLOSEST(data[4],\r\ndevpriv->clock_ns);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndown_count = data[4] / devpriv->clock_ns;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndown_count =\r\nDIV_ROUND_UP(data[4], devpriv->clock_ns);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (up_count * devpriv->clock_ns != data[2] ||\r\ndown_count * devpriv->clock_ns != data[4]) {\r\ndata[2] = up_count * devpriv->clock_ns;\r\ndata[4] = down_count * devpriv->clock_ns;\r\nreturn -EAGAIN;\r\n}\r\nni_writel(dev, up_count, NI6143_CALIB_HI_TIME_REG);\r\ndevpriv->pwm_up_count = up_count;\r\nni_writel(dev, down_count, NI6143_CALIB_LO_TIME_REG);\r\ndevpriv->pwm_down_count = down_count;\r\nreturn 5;\r\ncase INSN_CONFIG_GET_PWM_OUTPUT:\r\nreturn ni_get_pwm_config(dev, data);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pack_mb88341(int addr, int val, int *bitstring)\r\n{\r\naddr++;\r\n*bitstring = ((addr & 0x1) << 11) |\r\n((addr & 0x2) << 9) |\r\n((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);\r\nreturn 12;\r\n}\r\nstatic int pack_dac8800(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = ((addr & 0x7) << 8) | (val & 0xff);\r\nreturn 11;\r\n}\r\nstatic int pack_dac8043(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = val & 0xfff;\r\nreturn 12;\r\n}\r\nstatic int pack_ad8522(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = (val & 0xfff) | (addr ? 0xc000 : 0xa000);\r\nreturn 16;\r\n}\r\nstatic int pack_ad8804(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = ((addr & 0xf) << 8) | (val & 0xff);\r\nreturn 12;\r\n}\r\nstatic int pack_ad8842(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = ((addr + 1) << 8) | (val & 0xff);\r\nreturn 12;\r\n}\r\nstatic void ni_write_caldac(struct comedi_device *dev, int addr, int val)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int loadbit = 0, bits = 0, bit, bitstring = 0;\r\nunsigned int cmd;\r\nint i;\r\nint type;\r\nif (devpriv->caldacs[addr] == val)\r\nreturn;\r\ndevpriv->caldacs[addr] = val;\r\nfor (i = 0; i < 3; i++) {\r\ntype = board->caldac[i];\r\nif (type == caldac_none)\r\nbreak;\r\nif (addr < caldacs[type].n_chans) {\r\nbits = caldacs[type].packbits(addr, val, &bitstring);\r\nloadbit = NI_E_SERIAL_CMD_DAC_LD(i);\r\nbreak;\r\n}\r\naddr -= caldacs[type].n_chans;\r\n}\r\nif (bits == 0)\r\nreturn;\r\nfor (bit = 1 << (bits - 1); bit; bit >>= 1) {\r\ncmd = (bit & bitstring) ? NI_E_SERIAL_CMD_SDATA : 0;\r\nni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);\r\nudelay(1);\r\nni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);\r\nudelay(1);\r\n}\r\nni_writeb(dev, loadbit, NI_E_SERIAL_CMD_REG);\r\nudelay(1);\r\nni_writeb(dev, 0, NI_E_SERIAL_CMD_REG);\r\n}\r\nstatic int ni_calib_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);\r\nreturn 1;\r\n}\r\nstatic int ni_calib_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\ndata[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nint i, j;\r\nint n_dacs;\r\nint n_chans = 0;\r\nint n_bits;\r\nint diffbits = 0;\r\nint type;\r\nint chan;\r\ntype = board->caldac[0];\r\nif (type == caldac_none)\r\nreturn;\r\nn_bits = caldacs[type].n_bits;\r\nfor (i = 0; i < 3; i++) {\r\ntype = board->caldac[i];\r\nif (type == caldac_none)\r\nbreak;\r\nif (caldacs[type].n_bits != n_bits)\r\ndiffbits = 1;\r\nn_chans += caldacs[type].n_chans;\r\n}\r\nn_dacs = i;\r\ns->n_chan = n_chans;\r\nif (diffbits) {\r\nunsigned int *maxdata_list = devpriv->caldac_maxdata_list;\r\nif (n_chans > MAX_N_CALDACS)\r\ndev_err(dev->class_dev,\r\n"BUG! MAX_N_CALDACS too small\n");\r\ns->maxdata_list = maxdata_list;\r\nchan = 0;\r\nfor (i = 0; i < n_dacs; i++) {\r\ntype = board->caldac[i];\r\nfor (j = 0; j < caldacs[type].n_chans; j++) {\r\nmaxdata_list[chan] =\r\n(1 << caldacs[type].n_bits) - 1;\r\nchan++;\r\n}\r\n}\r\nfor (chan = 0; chan < s->n_chan; chan++)\r\nni_write_caldac(dev, i, s->maxdata_list[i] / 2);\r\n} else {\r\ntype = board->caldac[0];\r\ns->maxdata = (1 << caldacs[type].n_bits) - 1;\r\nfor (chan = 0; chan < s->n_chan; chan++)\r\nni_write_caldac(dev, i, s->maxdata / 2);\r\n}\r\n}\r\nstatic int ni_read_eeprom(struct comedi_device *dev, int addr)\r\n{\r\nunsigned int cmd = NI_E_SERIAL_CMD_EEPROM_CS;\r\nint bit;\r\nint bitstring;\r\nbitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);\r\nni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);\r\nfor (bit = 0x8000; bit; bit >>= 1) {\r\nif (bit & bitstring)\r\ncmd |= NI_E_SERIAL_CMD_SDATA;\r\nelse\r\ncmd &= ~NI_E_SERIAL_CMD_SDATA;\r\nni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);\r\nni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);\r\n}\r\ncmd = NI_E_SERIAL_CMD_EEPROM_CS;\r\nbitstring = 0;\r\nfor (bit = 0x80; bit; bit >>= 1) {\r\nni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);\r\nni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);\r\nif (ni_readb(dev, NI_E_STATUS_REG) & NI_E_STATUS_PROMOUT)\r\nbitstring |= bit;\r\n}\r\nni_writeb(dev, 0, NI_E_SERIAL_CMD_REG);\r\nreturn bitstring;\r\n}\r\nstatic int ni_eeprom_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));\r\nreturn 1;\r\n}\r\nstatic int ni_m_series_eeprom_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\ndata[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic unsigned int ni_old_get_pfi_routing(struct comedi_device *dev,\r\nunsigned int chan)\r\n{\r\nswitch (chan) {\r\ncase 0:\r\nreturn NI_PFI_OUTPUT_AI_START1;\r\ncase 1:\r\nreturn NI_PFI_OUTPUT_AI_START2;\r\ncase 2:\r\nreturn NI_PFI_OUTPUT_AI_CONVERT;\r\ncase 3:\r\nreturn NI_PFI_OUTPUT_G_SRC1;\r\ncase 4:\r\nreturn NI_PFI_OUTPUT_G_GATE1;\r\ncase 5:\r\nreturn NI_PFI_OUTPUT_AO_UPDATE_N;\r\ncase 6:\r\nreturn NI_PFI_OUTPUT_AO_START1;\r\ncase 7:\r\nreturn NI_PFI_OUTPUT_AI_START_PULSE;\r\ncase 8:\r\nreturn NI_PFI_OUTPUT_G_SRC0;\r\ncase 9:\r\nreturn NI_PFI_OUTPUT_G_GATE0;\r\ndefault:\r\ndev_err(dev->class_dev, "bug, unhandled case in switch.\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_old_set_pfi_routing(struct comedi_device *dev,\r\nunsigned int chan, unsigned int source)\r\n{\r\nif (source != ni_old_get_pfi_routing(dev, chan))\r\nreturn -EINVAL;\r\nreturn 2;\r\n}\r\nstatic unsigned int ni_m_series_get_pfi_routing(struct comedi_device *dev,\r\nunsigned int chan)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nconst unsigned int array_offset = chan / 3;\r\nreturn NI_M_PFI_OUT_SEL_TO_SRC(chan,\r\ndevpriv->pfi_output_select_reg[array_offset]);\r\n}\r\nstatic int ni_m_series_set_pfi_routing(struct comedi_device *dev,\r\nunsigned int chan, unsigned int source)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int index = chan / 3;\r\nunsigned short val = devpriv->pfi_output_select_reg[index];\r\nif ((source & 0x1f) != source)\r\nreturn -EINVAL;\r\nval &= ~NI_M_PFI_OUT_SEL_MASK(chan);\r\nval |= NI_M_PFI_OUT_SEL(chan, source);\r\nni_writew(dev, val, NI_M_PFI_OUT_SEL_REG(index));\r\ndevpriv->pfi_output_select_reg[index] = val;\r\nreturn 2;\r\n}\r\nstatic unsigned int ni_get_pfi_routing(struct comedi_device *dev,\r\nunsigned int chan)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nreturn (devpriv->is_m_series)\r\n? ni_m_series_get_pfi_routing(dev, chan)\r\n: ni_old_get_pfi_routing(dev, chan);\r\n}\r\nstatic int ni_set_pfi_routing(struct comedi_device *dev,\r\nunsigned int chan, unsigned int source)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nreturn (devpriv->is_m_series)\r\n? ni_m_series_set_pfi_routing(dev, chan, source)\r\n: ni_old_set_pfi_routing(dev, chan, source);\r\n}\r\nstatic int ni_config_filter(struct comedi_device *dev,\r\nunsigned int pfi_channel,\r\nenum ni_pfi_filter_select filter)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int bits;\r\nif (!devpriv->is_m_series)\r\nreturn -ENOTSUPP;\r\nbits = ni_readl(dev, NI_M_PFI_FILTER_REG);\r\nbits &= ~NI_M_PFI_FILTER_SEL_MASK(pfi_channel);\r\nbits |= NI_M_PFI_FILTER_SEL(pfi_channel, filter);\r\nni_writel(dev, bits, NI_M_PFI_FILTER_REG);\r\nreturn 0;\r\n}\r\nstatic int ni_pfi_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int chan;\r\nif (insn->n < 1)\r\nreturn -EINVAL;\r\nchan = CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase COMEDI_OUTPUT:\r\nni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, 1 << chan, 1);\r\nbreak;\r\ncase COMEDI_INPUT:\r\nni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, 1 << chan, 0);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(devpriv->io_bidirection_pin_reg & (1 << chan)) ?\r\nCOMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn 0;\r\ncase INSN_CONFIG_SET_ROUTING:\r\nreturn ni_set_pfi_routing(dev, chan, data[1]);\r\ncase INSN_CONFIG_GET_ROUTING:\r\ndata[1] = ni_get_pfi_routing(dev, chan);\r\nbreak;\r\ncase INSN_CONFIG_FILTER:\r\nreturn ni_config_filter(dev, chan, data[1]);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_pfi_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (!devpriv->is_m_series)\r\nreturn -ENOTSUPP;\r\nif (comedi_dio_update_state(s, data))\r\nni_writew(dev, s->state, NI_M_PFI_DO_REG);\r\ndata[1] = ni_readw(dev, NI_M_PFI_DI_REG);\r\nreturn insn->n;\r\n}\r\nstatic int cs5529_wait_for_idle(struct comedi_device *dev)\r\n{\r\nunsigned short status;\r\nconst int timeout = HZ;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nstatus = ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG);\r\nif ((status & NI67XX_CAL_STATUS_BUSY) == 0)\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (schedule_timeout(1))\r\nreturn -EIO;\r\n}\r\nif (i == timeout) {\r\ndev_err(dev->class_dev, "timeout\n");\r\nreturn -ETIME;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cs5529_command(struct comedi_device *dev, unsigned short value)\r\n{\r\nstatic const int timeout = 100;\r\nint i;\r\nni_ao_win_outw(dev, value, NI67XX_CAL_CMD_REG);\r\nfor (i = 0; i < timeout; i++) {\r\nif (ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG) &\r\nNI67XX_CAL_STATUS_BUSY)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout)\r\ndev_err(dev->class_dev,\r\n"possible problem - never saw adc go busy?\n");\r\n}\r\nstatic int cs5529_do_conversion(struct comedi_device *dev,\r\nunsigned short *data)\r\n{\r\nint retval;\r\nunsigned short status;\r\ncs5529_command(dev, CS5529_CMD_CB | CS5529_CMD_SINGLE_CONV);\r\nretval = cs5529_wait_for_idle(dev);\r\nif (retval) {\r\ndev_err(dev->class_dev,\r\n"timeout or signal in cs5529_do_conversion()\n");\r\nreturn -ETIME;\r\n}\r\nstatus = ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG);\r\nif (status & NI67XX_CAL_STATUS_OSC_DETECT) {\r\ndev_err(dev->class_dev,\r\n"cs5529 conversion error, status CSS_OSC_DETECT\n");\r\nreturn -EIO;\r\n}\r\nif (status & NI67XX_CAL_STATUS_OVERRANGE) {\r\ndev_err(dev->class_dev,\r\n"cs5529 conversion error, overrange (ignoring)\n");\r\n}\r\nif (data) {\r\n*data = ni_ao_win_inw(dev, NI67XX_CAL_DATA_REG);\r\n*data ^= (1 << 15);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs5529_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint n, retval;\r\nunsigned short sample;\r\nunsigned int channel_select;\r\nconst unsigned int INTERNAL_REF = 0x1000;\r\nif (insn->chanspec & CR_ALT_SOURCE)\r\nchannel_select = INTERNAL_REF;\r\nelse\r\nchannel_select = CR_CHAN(insn->chanspec);\r\nni_ao_win_outw(dev, channel_select, NI67XX_AO_CAL_CHAN_SEL_REG);\r\nfor (n = 0; n < insn->n; n++) {\r\nretval = cs5529_do_conversion(dev, &sample);\r\nif (retval < 0)\r\nreturn retval;\r\ndata[n] = sample;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void cs5529_config_write(struct comedi_device *dev, unsigned int value,\r\nunsigned int reg_select_bits)\r\n{\r\nni_ao_win_outw(dev, (value >> 16) & 0xff, NI67XX_CAL_CFG_HI_REG);\r\nni_ao_win_outw(dev, value & 0xffff, NI67XX_CAL_CFG_LO_REG);\r\nreg_select_bits &= CS5529_CMD_REG_MASK;\r\ncs5529_command(dev, CS5529_CMD_CB | reg_select_bits);\r\nif (cs5529_wait_for_idle(dev))\r\ndev_err(dev->class_dev,\r\n"timeout or signal in %s\n", __func__);\r\n}\r\nstatic int init_cs5529(struct comedi_device *dev)\r\n{\r\nunsigned int config_bits = CS5529_CFG_PORT_FLAG |\r\nCS5529_CFG_WORD_RATE_2180;\r\n#if 1\r\ncs5529_config_write(dev, config_bits | CS5529_CFG_CALIB_BOTH_SELF,\r\nCS5529_CFG_REG);\r\ncs5529_do_conversion(dev, NULL);\r\n#else\r\ncs5529_config_write(dev, 0x400000, CS5529_GAIN_REG);\r\ncs5529_config_write(dev, config_bits | CS5529_CFG_CALIB_OFFSET_SELF,\r\nCS5529_CFG_REG);\r\nif (cs5529_wait_for_idle(dev))\r\ndev_err(dev->class_dev,\r\n"timeout or signal in %s\n", __func__);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int ni_mseries_get_pll_parameters(unsigned int reference_period_ns,\r\nunsigned int *freq_divider,\r\nunsigned int *freq_multiplier,\r\nunsigned int *actual_period_ns)\r\n{\r\nunsigned int div;\r\nunsigned int best_div = 1;\r\nunsigned int mult;\r\nunsigned int best_mult = 1;\r\nstatic const unsigned int pico_per_nano = 1000;\r\nconst unsigned int reference_picosec = reference_period_ns *\r\npico_per_nano;\r\nstatic const unsigned int target_picosec = 12500;\r\nint best_period_picosec = 0;\r\nfor (div = 1; div <= NI_M_PLL_MAX_DIVISOR; ++div) {\r\nfor (mult = 1; mult <= NI_M_PLL_MAX_MULTIPLIER; ++mult) {\r\nunsigned int new_period_ps =\r\n(reference_picosec * div) / mult;\r\nif (abs(new_period_ps - target_picosec) <\r\nabs(best_period_picosec - target_picosec)) {\r\nbest_period_picosec = new_period_ps;\r\nbest_div = div;\r\nbest_mult = mult;\r\n}\r\n}\r\n}\r\nif (best_period_picosec == 0)\r\nreturn -EIO;\r\n*freq_divider = best_div;\r\n*freq_multiplier = best_mult;\r\n*actual_period_ns = DIV_ROUND_CLOSEST(best_period_picosec * 4,\r\npico_per_nano);\r\nreturn 0;\r\n}\r\nstatic int ni_mseries_set_pll_master_clock(struct comedi_device *dev,\r\nunsigned int source,\r\nunsigned int period_ns)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstatic const unsigned int min_period_ns = 50;\r\nstatic const unsigned int max_period_ns = 1000;\r\nstatic const unsigned int timeout = 1000;\r\nunsigned int pll_control_bits;\r\nunsigned int freq_divider;\r\nunsigned int freq_multiplier;\r\nunsigned int rtsi;\r\nunsigned int i;\r\nint retval;\r\nif (source == NI_MIO_PLL_PXI10_CLOCK)\r\nperiod_ns = 100;\r\nif (period_ns < min_period_ns || period_ns > max_period_ns) {\r\ndev_err(dev->class_dev,\r\n"%s: you must specify an input clock frequency between %i and %i nanosec for the phased-lock loop\n",\r\n__func__, min_period_ns, max_period_ns);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->rtsi_trig_direction_reg &= ~NISTC_RTSI_TRIG_USE_CLK;\r\nni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,\r\nNISTC_RTSI_TRIG_DIR_REG);\r\npll_control_bits = NI_M_PLL_CTRL_ENA | NI_M_PLL_CTRL_VCO_MODE_75_150MHZ;\r\ndevpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_TIMEBASE1_PLL |\r\nNI_M_CLK_FOUT2_TIMEBASE3_PLL;\r\ndevpriv->clock_and_fout2 &= ~NI_M_CLK_FOUT2_PLL_SRC_MASK;\r\nswitch (source) {\r\ncase NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:\r\ndevpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_PLL_SRC_STAR;\r\nbreak;\r\ncase NI_MIO_PLL_PXI10_CLOCK:\r\ndevpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_PLL_SRC_PXI10;\r\nbreak;\r\ndefault:\r\nfor (rtsi = 0; rtsi <= NI_M_MAX_RTSI_CHAN; ++rtsi) {\r\nif (source == NI_MIO_PLL_RTSI_CLOCK(rtsi)) {\r\ndevpriv->clock_and_fout2 |=\r\nNI_M_CLK_FOUT2_PLL_SRC_RTSI(rtsi);\r\nbreak;\r\n}\r\n}\r\nif (rtsi > NI_M_MAX_RTSI_CHAN)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nretval = ni_mseries_get_pll_parameters(period_ns,\r\n&freq_divider,\r\n&freq_multiplier,\r\n&devpriv->clock_ns);\r\nif (retval < 0) {\r\ndev_err(dev->class_dev,\r\n"bug, failed to find pll parameters\n");\r\nreturn retval;\r\n}\r\nni_writew(dev, devpriv->clock_and_fout2, NI_M_CLK_FOUT2_REG);\r\npll_control_bits |= NI_M_PLL_CTRL_DIVISOR(freq_divider) |\r\nNI_M_PLL_CTRL_MULTIPLIER(freq_multiplier);\r\nni_writew(dev, pll_control_bits, NI_M_PLL_CTRL_REG);\r\ndevpriv->clock_source = source;\r\nfor (i = 0; i < timeout; ++i) {\r\nif (ni_readw(dev, NI_M_PLL_STATUS_REG) & NI_M_PLL_STATUS_LOCKED)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\ndev_err(dev->class_dev,\r\n"%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns\n",\r\n__func__, source, period_ns);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 3;\r\n}\r\nstatic int ni_set_master_clock(struct comedi_device *dev,\r\nunsigned int source, unsigned int period_ns)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (source == NI_MIO_INTERNAL_CLOCK) {\r\ndevpriv->rtsi_trig_direction_reg &= ~NISTC_RTSI_TRIG_USE_CLK;\r\nni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,\r\nNISTC_RTSI_TRIG_DIR_REG);\r\ndevpriv->clock_ns = TIMEBASE_1_NS;\r\nif (devpriv->is_m_series) {\r\ndevpriv->clock_and_fout2 &=\r\n~(NI_M_CLK_FOUT2_TIMEBASE1_PLL |\r\nNI_M_CLK_FOUT2_TIMEBASE3_PLL);\r\nni_writew(dev, devpriv->clock_and_fout2,\r\nNI_M_CLK_FOUT2_REG);\r\nni_writew(dev, 0, NI_M_PLL_CTRL_REG);\r\n}\r\ndevpriv->clock_source = source;\r\n} else {\r\nif (devpriv->is_m_series) {\r\nreturn ni_mseries_set_pll_master_clock(dev, source,\r\nperiod_ns);\r\n} else {\r\nif (source == NI_MIO_RTSI_CLOCK) {\r\ndevpriv->rtsi_trig_direction_reg |=\r\nNISTC_RTSI_TRIG_USE_CLK;\r\nni_stc_writew(dev,\r\ndevpriv->rtsi_trig_direction_reg,\r\nNISTC_RTSI_TRIG_DIR_REG);\r\nif (period_ns == 0) {\r\ndev_err(dev->class_dev,\r\n"we don't handle an unspecified clock period correctly yet, returning error\n");\r\nreturn -EINVAL;\r\n}\r\ndevpriv->clock_ns = period_ns;\r\ndevpriv->clock_source = source;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 3;\r\n}\r\nstatic int ni_valid_rtsi_output_source(struct comedi_device *dev,\r\nunsigned int chan, unsigned int source)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (chan >= NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {\r\nif (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\r\nif (source == NI_RTSI_OUTPUT_RTSI_OSC)\r\nreturn 1;\r\ndev_err(dev->class_dev,\r\n"%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards\n",\r\n__func__, chan, NISTC_RTSI_TRIG_OLD_CLK_CHAN);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nswitch (source) {\r\ncase NI_RTSI_OUTPUT_ADR_START1:\r\ncase NI_RTSI_OUTPUT_ADR_START2:\r\ncase NI_RTSI_OUTPUT_SCLKG:\r\ncase NI_RTSI_OUTPUT_DACUPDN:\r\ncase NI_RTSI_OUTPUT_DA_START1:\r\ncase NI_RTSI_OUTPUT_G_SRC0:\r\ncase NI_RTSI_OUTPUT_G_GATE0:\r\ncase NI_RTSI_OUTPUT_RGOUT0:\r\ncase NI_RTSI_OUTPUT_RTSI_BRD_0:\r\nreturn 1;\r\ncase NI_RTSI_OUTPUT_RTSI_OSC:\r\nreturn (devpriv->is_m_series) ? 1 : 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int ni_set_rtsi_routing(struct comedi_device *dev,\r\nunsigned int chan, unsigned int src)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (ni_valid_rtsi_output_source(dev, chan, src) == 0)\r\nreturn -EINVAL;\r\nif (chan < 4) {\r\ndevpriv->rtsi_trig_a_output_reg &= ~NISTC_RTSI_TRIG_MASK(chan);\r\ndevpriv->rtsi_trig_a_output_reg |= NISTC_RTSI_TRIG(chan, src);\r\nni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,\r\nNISTC_RTSI_TRIGA_OUT_REG);\r\n} else if (chan < 8) {\r\ndevpriv->rtsi_trig_b_output_reg &= ~NISTC_RTSI_TRIG_MASK(chan);\r\ndevpriv->rtsi_trig_b_output_reg |= NISTC_RTSI_TRIG(chan, src);\r\nni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,\r\nNISTC_RTSI_TRIGB_OUT_REG);\r\n}\r\nreturn 2;\r\n}\r\nstatic unsigned int ni_get_rtsi_routing(struct comedi_device *dev,\r\nunsigned int chan)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (chan < 4) {\r\nreturn NISTC_RTSI_TRIG_TO_SRC(chan,\r\ndevpriv->rtsi_trig_a_output_reg);\r\n} else if (chan < NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {\r\nreturn NISTC_RTSI_TRIG_TO_SRC(chan,\r\ndevpriv->rtsi_trig_b_output_reg);\r\n} else {\r\nif (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN)\r\nreturn NI_RTSI_OUTPUT_RTSI_OSC;\r\ndev_err(dev->class_dev, "bug! should never get here?\n");\r\nreturn 0;\r\n}\r\n}\r\nstatic int ni_rtsi_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int max_chan = NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\nif (chan < max_chan) {\r\ndevpriv->rtsi_trig_direction_reg |=\r\nNISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series);\r\n} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\r\ndevpriv->rtsi_trig_direction_reg |=\r\nNISTC_RTSI_TRIG_DRV_CLK;\r\n}\r\nni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,\r\nNISTC_RTSI_TRIG_DIR_REG);\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\nif (chan < max_chan) {\r\ndevpriv->rtsi_trig_direction_reg &=\r\n~NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series);\r\n} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\r\ndevpriv->rtsi_trig_direction_reg &=\r\n~NISTC_RTSI_TRIG_DRV_CLK;\r\n}\r\nni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,\r\nNISTC_RTSI_TRIG_DIR_REG);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\nif (chan < max_chan) {\r\ndata[1] =\r\n(devpriv->rtsi_trig_direction_reg &\r\nNISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series))\r\n? INSN_CONFIG_DIO_OUTPUT\r\n: INSN_CONFIG_DIO_INPUT;\r\n} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\r\ndata[1] = (devpriv->rtsi_trig_direction_reg &\r\nNISTC_RTSI_TRIG_DRV_CLK)\r\n? INSN_CONFIG_DIO_OUTPUT\r\n: INSN_CONFIG_DIO_INPUT;\r\n}\r\nreturn 2;\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nreturn ni_set_master_clock(dev, data[1], data[2]);\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\ndata[1] = devpriv->clock_source;\r\ndata[2] = devpriv->clock_ns;\r\nreturn 3;\r\ncase INSN_CONFIG_SET_ROUTING:\r\nreturn ni_set_rtsi_routing(dev, chan, data[1]);\r\ncase INSN_CONFIG_GET_ROUTING:\r\ndata[1] = ni_get_rtsi_routing(dev, chan);\r\nreturn 2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 1;\r\n}\r\nstatic int ni_rtsi_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = 0;\r\nreturn insn->n;\r\n}\r\nstatic void ni_rtsi_init(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\ndevpriv->clock_and_fout2 = NI_M_CLK_FOUT2_RTSI_10MHZ;\r\nif (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0)\r\ndev_err(dev->class_dev, "ni_set_master_clock failed, bug?\n");\r\ndevpriv->rtsi_trig_a_output_reg =\r\nNISTC_RTSI_TRIG(0, NI_RTSI_OUTPUT_ADR_START1) |\r\nNISTC_RTSI_TRIG(1, NI_RTSI_OUTPUT_ADR_START2) |\r\nNISTC_RTSI_TRIG(2, NI_RTSI_OUTPUT_SCLKG) |\r\nNISTC_RTSI_TRIG(3, NI_RTSI_OUTPUT_DACUPDN);\r\nni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,\r\nNISTC_RTSI_TRIGA_OUT_REG);\r\ndevpriv->rtsi_trig_b_output_reg =\r\nNISTC_RTSI_TRIG(4, NI_RTSI_OUTPUT_DA_START1) |\r\nNISTC_RTSI_TRIG(5, NI_RTSI_OUTPUT_G_SRC0) |\r\nNISTC_RTSI_TRIG(6, NI_RTSI_OUTPUT_G_GATE0);\r\nif (devpriv->is_m_series)\r\ndevpriv->rtsi_trig_b_output_reg |=\r\nNISTC_RTSI_TRIG(7, NI_RTSI_OUTPUT_RTSI_OSC);\r\nni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,\r\nNISTC_RTSI_TRIGB_OUT_REG);\r\n}\r\nstatic int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nint retval;\r\nretval = ni_request_gpct_mite_channel(dev, counter->counter_index,\r\nCOMEDI_INPUT);\r\nif (retval) {\r\ndev_err(dev->class_dev,\r\n"no dma channel available for use by counter\n");\r\nreturn retval;\r\n}\r\nni_tio_acknowledge(counter);\r\nni_e_series_enable_second_irq(dev, counter->counter_index, 1);\r\nreturn ni_tio_cmd(dev, s);\r\n}\r\nstatic int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nint retval;\r\nretval = ni_tio_cancel(counter);\r\nni_e_series_enable_second_irq(dev, counter->counter_index, 0);\r\nni_release_gpct_mite_channel(dev, counter->counter_index);\r\nreturn retval;\r\n}\r\nstatic irqreturn_t ni_E_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s_ai = dev->read_subdev;\r\nstruct comedi_subdevice *s_ao = dev->write_subdev;\r\nunsigned short a_status;\r\nunsigned short b_status;\r\nunsigned long flags;\r\n#ifdef PCIDMA\r\nstruct ni_private *devpriv = dev->private;\r\n#endif\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nsmp_mb();\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\na_status = ni_stc_readw(dev, NISTC_AI_STATUS1_REG);\r\nb_status = ni_stc_readw(dev, NISTC_AO_STATUS1_REG);\r\n#ifdef PCIDMA\r\nif (devpriv->mite) {\r\nunsigned long flags_too;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);\r\nif (s_ai && devpriv->ai_mite_chan)\r\nmite_ack_linkc(devpriv->ai_mite_chan, s_ai, false);\r\nif (s_ao && devpriv->ao_mite_chan)\r\nmite_ack_linkc(devpriv->ao_mite_chan, s_ao, false);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);\r\n}\r\n#endif\r\nack_a_interrupt(dev, a_status);\r\nack_b_interrupt(dev, b_status);\r\nif (s_ai) {\r\nif (a_status & NISTC_AI_STATUS1_INTA)\r\nhandle_a_interrupt(dev, s_ai, a_status);\r\ncomedi_handle_events(dev, s_ai);\r\n}\r\nif (s_ao) {\r\nif (b_status & NISTC_AO_STATUS1_INTB)\r\nhandle_b_interrupt(dev, s_ao, b_status);\r\ncomedi_handle_events(dev, s_ao);\r\n}\r\nhandle_gpct_interrupt(dev, 0);\r\nhandle_gpct_interrupt(dev, 1);\r\n#ifdef PCIDMA\r\nif (devpriv->is_m_series)\r\nhandle_cdio_interrupt(dev);\r\n#endif\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ni_alloc_private(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&devpriv->window_lock);\r\nspin_lock_init(&devpriv->soft_reg_copy_lock);\r\nspin_lock_init(&devpriv->mite_channel_lock);\r\nreturn 0;\r\n}\r\nstatic int ni_E_init(struct comedi_device *dev,\r\nunsigned int interrupt_pin, unsigned int irq_polarity)\r\n{\r\nconst struct ni_board_struct *board = dev->board_ptr;\r\nstruct ni_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nint i;\r\nif (board->n_aochan > MAX_N_AO_CHAN) {\r\ndev_err(dev->class_dev, "bug! n_aochan > MAX_N_AO_CHAN\n");\r\nreturn -EINVAL;\r\n}\r\ndevpriv->clock_and_fout = NISTC_CLK_FOUT_SLOW_DIV2 |\r\nNISTC_CLK_FOUT_SLOW_TIMEBASE |\r\nNISTC_CLK_FOUT_TO_BOARD_DIV2 |\r\nNISTC_CLK_FOUT_TO_BOARD;\r\nif (!devpriv->is_6xxx) {\r\ndevpriv->clock_and_fout |= (NISTC_CLK_FOUT_AI_OUT_DIV2 |\r\nNISTC_CLK_FOUT_AO_OUT_DIV2);\r\n}\r\nni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\r\nret = comedi_alloc_subdevices(dev, NI_NUM_SUBDEVICES);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[NI_AI_SUBDEV];\r\nif (board->n_adchan) {\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_DITHER;\r\nif (!devpriv->is_611x)\r\ns->subdev_flags |= SDF_GROUND | SDF_COMMON | SDF_OTHER;\r\nif (board->ai_maxdata > 0xffff)\r\ns->subdev_flags |= SDF_LSAMPL;\r\nif (devpriv->is_m_series)\r\ns->subdev_flags |= SDF_SOFT_CALIBRATED;\r\ns->n_chan = board->n_adchan;\r\ns->maxdata = board->ai_maxdata;\r\ns->range_table = ni_range_lkup[board->gainlkup];\r\ns->insn_read = ni_ai_insn_read;\r\ns->insn_config = ni_ai_insn_config;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = 512;\r\ns->do_cmdtest = ni_ai_cmdtest;\r\ns->do_cmd = ni_ai_cmd;\r\ns->cancel = ni_ai_reset;\r\ns->poll = ni_ai_poll;\r\ns->munge = ni_ai_munge;\r\nif (devpriv->mite)\r\ns->async_dma_dir = DMA_FROM_DEVICE;\r\n}\r\nni_ai_reset(dev, s);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[NI_AO_SUBDEV];\r\nif (board->n_aochan) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_DEGLITCH | SDF_GROUND;\r\nif (devpriv->is_m_series)\r\ns->subdev_flags |= SDF_SOFT_CALIBRATED;\r\ns->n_chan = board->n_aochan;\r\ns->maxdata = board->ao_maxdata;\r\ns->range_table = board->ao_range_table;\r\ns->insn_config = ni_ao_insn_config;\r\ns->insn_write = ni_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nif (dev->irq && (board->ao_fifo_depth || devpriv->mite)) {\r\ndev->write_subdev = s;\r\ns->subdev_flags |= SDF_CMD_WRITE;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmdtest = ni_ao_cmdtest;\r\ns->do_cmd = ni_ao_cmd;\r\ns->cancel = ni_ao_reset;\r\nif (!devpriv->is_m_series)\r\ns->munge = ni_ao_munge;\r\nif (devpriv->mite)\r\ns->async_dma_dir = DMA_TO_DEVICE;\r\n}\r\nif (devpriv->is_67xx)\r\ninit_ao_67xx(dev, s);\r\nni_ao_reset(dev, s);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[NI_DIO_SUBDEV];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = board->has_32dio_chan ? 32 : 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\nif (devpriv->is_m_series) {\r\n#ifdef PCIDMA\r\ns->subdev_flags |= SDF_LSAMPL;\r\ns->insn_bits = ni_m_series_dio_insn_bits;\r\ns->insn_config = ni_m_series_dio_insn_config;\r\nif (dev->irq) {\r\ns->subdev_flags |= SDF_CMD_WRITE ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmdtest = ni_cdio_cmdtest;\r\ns->do_cmd = ni_cdio_cmd;\r\ns->cancel = ni_cdio_cancel;\r\ns->async_dma_dir = DMA_BIDIRECTIONAL;\r\n}\r\nni_writel(dev, NI_M_CDO_CMD_RESET |\r\nNI_M_CDI_CMD_RESET,\r\nNI_M_CDIO_CMD_REG);\r\nni_writel(dev, s->io_bits, NI_M_DIO_DIR_REG);\r\n#endif\r\n} else {\r\ns->insn_bits = ni_dio_insn_bits;\r\ns->insn_config = ni_dio_insn_config;\r\ndevpriv->dio_control = NISTC_DIO_CTRL_DIR(s->io_bits);\r\nni_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\r\n}\r\ns = &dev->subdevices[NI_8255_DIO_SUBDEV];\r\nif (board->has_8255) {\r\nret = subdev_8255_init(dev, s, ni_8255_callback,\r\nNI_E_8255_BASE);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[NI_UNUSED_SUBDEV];\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = &dev->subdevices[NI_CALIBRATION_SUBDEV];\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_INTERNAL;\r\ns->n_chan = 1;\r\ns->maxdata = 0;\r\nif (devpriv->is_m_series) {\r\ns->insn_config = ni_m_series_pwm_config;\r\nni_writel(dev, 0x0, NI_M_CAL_PWM_REG);\r\n} else if (devpriv->is_6143) {\r\ns->insn_config = ni_6143_pwm_config;\r\n} else {\r\ns->subdev_flags |= SDF_WRITABLE;\r\ns->insn_read = ni_calib_insn_read;\r\ns->insn_write = ni_calib_insn_write;\r\ncaldac_setup(dev, s);\r\n}\r\ns = &dev->subdevices[NI_EEPROM_SUBDEV];\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_INTERNAL;\r\ns->maxdata = 0xff;\r\nif (devpriv->is_m_series) {\r\ns->n_chan = M_SERIES_EEPROM_SIZE;\r\ns->insn_read = ni_m_series_eeprom_insn_read;\r\n} else {\r\ns->n_chan = 512;\r\ns->insn_read = ni_eeprom_insn_read;\r\n}\r\ns = &dev->subdevices[NI_PFI_DIO_SUBDEV];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->maxdata = 1;\r\nif (devpriv->is_m_series) {\r\ns->n_chan = 16;\r\ns->insn_bits = ni_pfi_insn_bits;\r\nni_writew(dev, s->state, NI_M_PFI_DO_REG);\r\nfor (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {\r\nni_writew(dev, devpriv->pfi_output_select_reg[i],\r\nNI_M_PFI_OUT_SEL_REG(i));\r\n}\r\n} else {\r\ns->n_chan = 10;\r\n}\r\ns->insn_config = ni_pfi_insn_config;\r\nni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, ~0, 0);\r\ns = &dev->subdevices[NI_CS5529_CALIBRATION_SUBDEV];\r\nif (devpriv->is_67xx) {\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;\r\ns->n_chan = board->n_aochan;\r\ns->maxdata = (1 << 16) - 1;\r\ns->range_table = &range_unknown;\r\ns->insn_read = cs5529_ai_insn_read;\r\ns->insn_config = NULL;\r\ninit_cs5529(dev);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[NI_SERIAL_SUBDEV];\r\ns->type = COMEDI_SUBD_SERIAL;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 1;\r\ns->maxdata = 0xff;\r\ns->insn_config = ni_serial_insn_config;\r\ndevpriv->serial_interval_ns = 0;\r\ndevpriv->serial_hw_mode = 0;\r\ns = &dev->subdevices[NI_RTSI_SUBDEV];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->insn_bits = ni_rtsi_insn_bits;\r\ns->insn_config = ni_rtsi_insn_config;\r\nni_rtsi_init(dev);\r\ndevpriv->counter_dev = ni_gpct_device_construct(dev,\r\nni_gpct_write_register,\r\nni_gpct_read_register,\r\n(devpriv->is_m_series)\r\n? ni_gpct_variant_m_series\r\n: ni_gpct_variant_e_series,\r\nNUM_GPCT);\r\nif (!devpriv->counter_dev)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < NUM_GPCT; ++i) {\r\nstruct ni_gpct *gpct = &devpriv->counter_dev->counters[i];\r\ngpct->chip_index = 0;\r\ngpct->counter_index = i;\r\nni_tio_init_counter(gpct);\r\ns = &dev->subdevices[NI_GPCT_SUBDEV(i)];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;\r\ns->n_chan = 3;\r\ns->maxdata = (devpriv->is_m_series) ? 0xffffffff\r\n: 0x00ffffff;\r\ns->insn_read = ni_tio_insn_read;\r\ns->insn_write = ni_tio_insn_write;\r\ns->insn_config = ni_tio_insn_config;\r\n#ifdef PCIDMA\r\nif (dev->irq && devpriv->mite) {\r\ns->subdev_flags |= SDF_CMD_READ ;\r\ns->len_chanlist = 1;\r\ns->do_cmdtest = ni_tio_cmdtest;\r\ns->do_cmd = ni_gpct_cmd;\r\ns->cancel = ni_gpct_cancel;\r\ns->async_dma_dir = DMA_BIDIRECTIONAL;\r\n}\r\n#endif\r\ns->private = gpct;\r\n}\r\ns = &dev->subdevices[NI_FREQ_OUT_SUBDEV];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 1;\r\ns->maxdata = 0xf;\r\ns->insn_read = ni_freq_out_insn_read;\r\ns->insn_write = ni_freq_out_insn_write;\r\ns->insn_config = ni_freq_out_insn_config;\r\nif (dev->irq) {\r\nni_stc_writew(dev,\r\n(irq_polarity ? NISTC_INT_CTRL_INT_POL : 0) |\r\n(NISTC_INT_CTRL_3PIN_INT & 0) |\r\nNISTC_INT_CTRL_INTA_ENA |\r\nNISTC_INT_CTRL_INTB_ENA |\r\nNISTC_INT_CTRL_INTA_SEL(interrupt_pin) |\r\nNISTC_INT_CTRL_INTB_SEL(interrupt_pin),\r\nNISTC_INT_CTRL_REG);\r\n}\r\nni_writeb(dev, devpriv->ai_ao_select_reg, NI_E_DMA_AI_AO_SEL_REG);\r\nni_writeb(dev, devpriv->g0_g1_select_reg, NI_E_DMA_G0_G1_SEL_REG);\r\nif (devpriv->is_6xxx) {\r\nni_writeb(dev, 0, NI611X_MAGIC_REG);\r\n} else if (devpriv->is_m_series) {\r\nint channel;\r\nfor (channel = 0; channel < board->n_aochan; ++channel) {\r\nni_writeb(dev, 0xf,\r\nNI_M_AO_WAVEFORM_ORDER_REG(channel));\r\nni_writeb(dev, 0x0,\r\nNI_M_AO_REF_ATTENUATION_REG(channel));\r\n}\r\nni_writeb(dev, 0x0, NI_M_AO_CALIB_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mio_common_detach(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nif (devpriv)\r\nni_gpct_device_destroy(devpriv->counter_dev);\r\n}
