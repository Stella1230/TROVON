static int epia_read_regr( PIA *pi, int cont, int regr )\r\n{ int a, b, r;\r\nregr += cont_map[cont];\r\nswitch (pi->mode) {\r\ncase 0: r = regr^0x39;\r\nw0(r); w2(1); w2(3); w0(r);\r\na = r1(); w2(1); b = r1(); w2(4);\r\nreturn j44(a,b);\r\ncase 1: r = regr^0x31;\r\nw0(r); w2(1); w0(r&0x37);\r\nw2(3); w2(5); w0(r|0xf0);\r\na = r1(); b = r2(); w2(4);\r\nreturn j53(a,b);\r\ncase 2: r = regr^0x29;\r\nw0(r); w2(1); w2(0X21); w2(0x23);\r\na = r0(); w2(4);\r\nreturn a;\r\ncase 3:\r\ncase 4:\r\ncase 5: w3(regr); w2(0x24); a = r4(); w2(4);\r\nreturn a;\r\n}\r\nreturn -1;\r\n}\r\nstatic void epia_write_regr( PIA *pi, int cont, int regr, int val)\r\n{ int r;\r\nregr += cont_map[cont];\r\nswitch (pi->mode) {\r\ncase 0:\r\ncase 1:\r\ncase 2: r = regr^0x19;\r\nw0(r); w2(1); w0(val); w2(3); w2(4);\r\nbreak;\r\ncase 3:\r\ncase 4:\r\ncase 5: r = regr^0x40;\r\nw3(r); w4(val); w2(4);\r\nbreak;\r\n}\r\n}\r\nstatic void epia_connect ( PIA *pi )\r\n{ pi->saved_r0 = r0();\r\npi->saved_r2 = r2();\r\nw2(4); w0(0xa0); w0(0x50); w0(0xc0); w0(0x30); w0(0xa0); w0(0);\r\nw2(1); w2(4);\r\nif (pi->mode >= 3) {\r\nw0(0xa); w2(1); w2(4); w0(0x82); w2(4); w2(0xc); w2(4);\r\nw2(0x24); w2(0x26); w2(4);\r\n}\r\nWR(0x86,8);\r\n}\r\nstatic void epia_disconnect ( PIA *pi )\r\n{\r\nw0(pi->saved_r0);\r\nw2(1); w2(4);\r\nw0(pi->saved_r0);\r\nw2(pi->saved_r2);\r\n}\r\nstatic void epia_read_block( PIA *pi, char * buf, int count )\r\n{ int k, ph, a, b;\r\nswitch (pi->mode) {\r\ncase 0: w0(0x81); w2(1); w2(3); w0(0xc1);\r\nph = 1;\r\nfor (k=0;k<count;k++) {\r\nw2(2+ph); a = r1();\r\nw2(4+ph); b = r1();\r\nbuf[k] = j44(a,b);\r\nph = 1 - ph;\r\n}\r\nw0(0); w2(4);\r\nbreak;\r\ncase 1: w0(0x91); w2(1); w0(0x10); w2(3);\r\nw0(0x51); w2(5); w0(0xd1);\r\nph = 1;\r\nfor (k=0;k<count;k++) {\r\nw2(4+ph);\r\na = r1(); b = r2();\r\nbuf[k] = j53(a,b);\r\nph = 1 - ph;\r\n}\r\nw0(0); w2(4);\r\nbreak;\r\ncase 2: w0(0x89); w2(1); w2(0x23); w2(0x21);\r\nph = 1;\r\nfor (k=0;k<count;k++) {\r\nw2(0x24+ph);\r\nbuf[k] = r0();\r\nph = 1 - ph;\r\n}\r\nw2(6); w2(4);\r\nbreak;\r\ncase 3: if (count > 512) WR(0x84,3);\r\nw3(0); w2(0x24);\r\nfor (k=0;k<count;k++) buf[k] = r4();\r\nw2(4); WR(0x84,0);\r\nbreak;\r\ncase 4: if (count > 512) WR(0x84,3);\r\nw3(0); w2(0x24);\r\nfor (k=0;k<count/2;k++) ((u16 *)buf)[k] = r4w();\r\nw2(4); WR(0x84,0);\r\nbreak;\r\ncase 5: if (count > 512) WR(0x84,3);\r\nw3(0); w2(0x24);\r\nfor (k=0;k<count/4;k++) ((u32 *)buf)[k] = r4l();\r\nw2(4); WR(0x84,0);\r\nbreak;\r\n}\r\n}\r\nstatic void epia_write_block( PIA *pi, char * buf, int count )\r\n{ int ph, k, last, d;\r\nswitch (pi->mode) {\r\ncase 0:\r\ncase 1:\r\ncase 2: w0(0xa1); w2(1); w2(3); w2(1); w2(5);\r\nph = 0; last = 0x8000;\r\nfor (k=0;k<count;k++) {\r\nd = buf[k];\r\nif (d != last) { last = d; w0(d); }\r\nw2(4+ph);\r\nph = 1 - ph;\r\n}\r\nw2(7); w2(4);\r\nbreak;\r\ncase 3: if (count < 512) WR(0x84,1);\r\nw3(0x40);\r\nfor (k=0;k<count;k++) w4(buf[k]);\r\nif (count < 512) WR(0x84,0);\r\nbreak;\r\ncase 4: if (count < 512) WR(0x84,1);\r\nw3(0x40);\r\nfor (k=0;k<count/2;k++) w4w(((u16 *)buf)[k]);\r\nif (count < 512) WR(0x84,0);\r\nbreak;\r\ncase 5: if (count < 512) WR(0x84,1);\r\nw3(0x40);\r\nfor (k=0;k<count/4;k++) w4l(((u32 *)buf)[k]);\r\nif (count < 512) WR(0x84,0);\r\nbreak;\r\n}\r\n}\r\nstatic int epia_test_proto( PIA *pi, char * scratch, int verbose )\r\n{ int j, k, f;\r\nint e[2] = {0,0};\r\nepia_connect(pi);\r\nfor (j=0;j<2;j++) {\r\nWR(6,0xa0+j*0x10);\r\nfor (k=0;k<256;k++) {\r\nWR(2,k^0xaa);\r\nWR(3,k^0x55);\r\nif (RR(2) != (k^0xaa)) e[j]++;\r\n}\r\nWR(2,1); WR(3,1);\r\n}\r\nepia_disconnect(pi);\r\nf = 0;\r\nepia_connect(pi);\r\nWR(0x84,8);\r\nepia_read_block(pi,scratch,512);\r\nfor (k=0;k<256;k++) {\r\nif ((scratch[2*k] & 0xff) != ((k+1) & 0xff)) f++;\r\nif ((scratch[2*k+1] & 0xff) != ((-2-k) & 0xff)) f++;\r\n}\r\nWR(0x84,0);\r\nepia_disconnect(pi);\r\nif (verbose) {\r\nprintk("%s: epia: port 0x%x, mode %d, test=(%d,%d,%d)\n",\r\npi->device,pi->port,pi->mode,e[0],e[1],f);\r\n}\r\nreturn (e[0] && e[1]) || f;\r\n}\r\nstatic void epia_log_adapter( PIA *pi, char * scratch, int verbose )\r\n{ char *mode_string[6] = {"4-bit","5/3","8-bit",\r\n"EPP-8","EPP-16","EPP-32"};\r\nprintk("%s: epia %s, Shuttle EPIA at 0x%x, ",\r\npi->device,EPIA_VERSION,pi->port);\r\nprintk("mode %d (%s), delay %d\n",pi->mode,\r\nmode_string[pi->mode],pi->delay);\r\n}\r\nstatic int __init epia_init(void)\r\n{\r\nreturn paride_register(&epia);\r\n}\r\nstatic void __exit epia_exit(void)\r\n{\r\nparide_unregister(&epia);\r\n}
