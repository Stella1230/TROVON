static int ltc3589_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nstruct ltc3589 *ltc3589 = rdev_get_drvdata(rdev);\r\nint sel, shift;\r\nif (unlikely(ramp_delay <= 0))\r\nreturn -EINVAL;\r\nshift = ffs(rdev->desc->apply_bit) - 1;\r\nfor (sel = 0; sel < 4; sel++) {\r\nif ((880 << sel) >= ramp_delay) {\r\nreturn regmap_update_bits(ltc3589->regmap,\r\nLTC3589_VRRCR,\r\n0x3 << shift, sel << shift);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltc3589_set_suspend_voltage(struct regulator_dev *rdev, int uV)\r\n{\r\nstruct ltc3589 *ltc3589 = rdev_get_drvdata(rdev);\r\nint sel;\r\nsel = regulator_map_voltage_linear(rdev, uV, uV);\r\nif (sel < 0)\r\nreturn sel;\r\nreturn regmap_update_bits(ltc3589->regmap, rdev->desc->vsel_reg + 1,\r\nrdev->desc->vsel_mask, sel);\r\n}\r\nstatic int ltc3589_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct ltc3589 *ltc3589 = rdev_get_drvdata(rdev);\r\nint mask, bit = 0;\r\nmask = rdev->desc->apply_bit << 1;\r\nif (mode == REGULATOR_MODE_STANDBY)\r\nbit = mask;\r\nmask |= rdev->desc->apply_bit;\r\nbit |= rdev->desc->apply_bit;\r\nreturn regmap_update_bits(ltc3589->regmap, LTC3589_VCCR, mask, bit);\r\n}\r\nstatic int ltc3589_parse_regulators_dt(struct ltc3589 *ltc3589)\r\n{\r\nstruct device *dev = ltc3589->dev;\r\nstruct device_node *node;\r\nint i, ret;\r\nnode = of_get_child_by_name(dev->of_node, "regulators");\r\nif (!node) {\r\ndev_err(dev, "regulators node not found\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_regulator_match(dev, node, ltc3589_matches,\r\nARRAY_SIZE(ltc3589_matches));\r\nof_node_put(node);\r\nif (ret < 0) {\r\ndev_err(dev, "Error parsing regulator init data: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ret != LTC3589_NUM_REGULATORS) {\r\ndev_err(dev, "Only %d regulators described in device tree\n",\r\nret);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < LTC3589_LDO3; i++) {\r\nstruct ltc3589_regulator *desc = &ltc3589->regulator_descs[i];\r\nstruct device_node *np = ltc3589_matches[i].of_node;\r\nu32 vdiv[2];\r\nret = of_property_read_u32_array(np, "lltc,fb-voltage-divider",\r\nvdiv, 2);\r\nif (ret) {\r\ndev_err(dev, "Failed to parse voltage divider: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndesc->r1 = vdiv[0];\r\ndesc->r2 = vdiv[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct regulator_init_data *match_init_data(int index)\r\n{\r\nreturn ltc3589_matches[index].init_data;\r\n}\r\nstatic inline struct device_node *match_of_node(int index)\r\n{\r\nreturn ltc3589_matches[index].of_node;\r\n}\r\nstatic inline int ltc3589_parse_regulators_dt(struct ltc3589 *ltc3589)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline struct regulator_init_data *match_init_data(int index)\r\n{\r\nreturn NULL;\r\n}\r\nstatic inline struct device_node *match_of_node(int index)\r\n{\r\nreturn NULL;\r\n}\r\nstatic bool ltc3589_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase LTC3589_IRQSTAT:\r\ncase LTC3589_SCR1:\r\ncase LTC3589_OVEN:\r\ncase LTC3589_SCR2:\r\ncase LTC3589_VCCR:\r\ncase LTC3589_CLIRQ:\r\ncase LTC3589_B1DTV1:\r\ncase LTC3589_B1DTV2:\r\ncase LTC3589_VRRCR:\r\ncase LTC3589_B2DTV1:\r\ncase LTC3589_B2DTV2:\r\ncase LTC3589_B3DTV1:\r\ncase LTC3589_B3DTV2:\r\ncase LTC3589_L2DTV1:\r\ncase LTC3589_L2DTV2:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool ltc3589_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase LTC3589_IRQSTAT:\r\ncase LTC3589_SCR1:\r\ncase LTC3589_OVEN:\r\ncase LTC3589_SCR2:\r\ncase LTC3589_PGSTAT:\r\ncase LTC3589_VCCR:\r\ncase LTC3589_B1DTV1:\r\ncase LTC3589_B1DTV2:\r\ncase LTC3589_VRRCR:\r\ncase LTC3589_B2DTV1:\r\ncase LTC3589_B2DTV2:\r\ncase LTC3589_B3DTV1:\r\ncase LTC3589_B3DTV2:\r\ncase LTC3589_L2DTV1:\r\ncase LTC3589_L2DTV2:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool ltc3589_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase LTC3589_IRQSTAT:\r\ncase LTC3589_PGSTAT:\r\ncase LTC3589_VCCR:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic irqreturn_t ltc3589_isr(int irq, void *dev_id)\r\n{\r\nstruct ltc3589 *ltc3589 = dev_id;\r\nunsigned int i, irqstat, event;\r\nregmap_read(ltc3589->regmap, LTC3589_IRQSTAT, &irqstat);\r\nif (irqstat & LTC3589_IRQSTAT_THERMAL_WARN) {\r\nevent = REGULATOR_EVENT_OVER_TEMP;\r\nfor (i = 0; i < LTC3589_NUM_REGULATORS; i++)\r\nregulator_notifier_call_chain(ltc3589->regulators[i],\r\nevent, NULL);\r\n}\r\nif (irqstat & LTC3589_IRQSTAT_UNDERVOLT_WARN) {\r\nevent = REGULATOR_EVENT_UNDER_VOLTAGE;\r\nfor (i = 0; i < LTC3589_NUM_REGULATORS; i++)\r\nregulator_notifier_call_chain(ltc3589->regulators[i],\r\nevent, NULL);\r\n}\r\nregmap_write(ltc3589->regmap, LTC3589_CLIRQ, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline unsigned int ltc3589_scale(unsigned int uV, u32 r1, u32 r2)\r\n{\r\nuint64_t tmp;\r\nif (uV == 0)\r\nreturn 0;\r\ntmp = (uint64_t)uV * r1;\r\ndo_div(tmp, r2);\r\nreturn uV + (unsigned int)tmp;\r\n}\r\nstatic void ltc3589_apply_fb_voltage_divider(struct ltc3589_regulator *rdesc)\r\n{\r\nstruct regulator_desc *desc = &rdesc->desc;\r\nif (!rdesc->r1 || !rdesc->r2)\r\nreturn;\r\ndesc->min_uV = ltc3589_scale(desc->min_uV, rdesc->r1, rdesc->r2);\r\ndesc->uV_step = ltc3589_scale(desc->uV_step, rdesc->r1, rdesc->r2);\r\ndesc->fixed_uV = ltc3589_scale(desc->fixed_uV, rdesc->r1, rdesc->r2);\r\n}\r\nstatic int ltc3589_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct ltc3589_regulator *descs;\r\nstruct ltc3589 *ltc3589;\r\nint i, ret;\r\nltc3589 = devm_kzalloc(dev, sizeof(*ltc3589), GFP_KERNEL);\r\nif (!ltc3589)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, ltc3589);\r\nltc3589->variant = id->driver_data;\r\nltc3589->dev = dev;\r\ndescs = ltc3589->regulator_descs;\r\nmemcpy(descs, ltc3589_regulators, sizeof(ltc3589_regulators));\r\nif (ltc3589->variant == LTC3589) {\r\ndescs[LTC3589_LDO3].desc.fixed_uV = 1800000;\r\ndescs[LTC3589_LDO4].desc.volt_table = ltc3589_ldo4;\r\n} else {\r\ndescs[LTC3589_LDO3].desc.fixed_uV = 2800000;\r\ndescs[LTC3589_LDO4].desc.volt_table = ltc3589_12_ldo4;\r\n}\r\nltc3589->regmap = devm_regmap_init_i2c(client, &ltc3589_regmap_config);\r\nif (IS_ERR(ltc3589->regmap)) {\r\nret = PTR_ERR(ltc3589->regmap);\r\ndev_err(dev, "failed to initialize regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ltc3589_parse_regulators_dt(ltc3589);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < LTC3589_NUM_REGULATORS; i++) {\r\nstruct ltc3589_regulator *rdesc = &ltc3589->regulator_descs[i];\r\nstruct regulator_desc *desc = &rdesc->desc;\r\nstruct regulator_init_data *init_data;\r\nstruct regulator_config config = { };\r\ninit_data = match_init_data(i);\r\nif (i < LTC3589_LDO3)\r\nltc3589_apply_fb_voltage_divider(rdesc);\r\nconfig.dev = dev;\r\nconfig.init_data = init_data;\r\nconfig.driver_data = ltc3589;\r\nconfig.of_node = match_of_node(i);\r\nltc3589->regulators[i] = devm_regulator_register(dev, desc,\r\n&config);\r\nif (IS_ERR(ltc3589->regulators[i])) {\r\nret = PTR_ERR(ltc3589->regulators[i]);\r\ndev_err(dev, "failed to register regulator %s: %d\n",\r\ndesc->name, ret);\r\nreturn ret;\r\n}\r\n}\r\nif (client->irq) {\r\nret = devm_request_threaded_irq(dev, client->irq, NULL,\r\nltc3589_isr,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nclient->name, ltc3589);\r\nif (ret) {\r\ndev_err(dev, "Failed to request IRQ: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
