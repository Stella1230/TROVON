static int exynos_bus_get_event(struct exynos_bus *bus,\r\nstruct devfreq_event_data *edata)\r\n{\r\nstruct devfreq_event_data event_data;\r\nunsigned long load_count = 0, total_count = 0;\r\nint i, ret = 0;\r\nfor (i = 0; i < bus->edev_count; i++) {\r\nif (!bus->edev[i])\r\ncontinue;\r\nret = devfreq_event_get_event(bus->edev[i], &event_data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (i == 0 || event_data.load_count > load_count) {\r\nload_count = event_data.load_count;\r\ntotal_count = event_data.total_count;\r\n}\r\n}\r\nedata->load_count = load_count;\r\nedata->total_count = total_count;\r\nreturn ret;\r\n}\r\nstatic int exynos_bus_target(struct device *dev, unsigned long *freq, u32 flags)\r\n{\r\nstruct exynos_bus *bus = dev_get_drvdata(dev);\r\nstruct dev_pm_opp *new_opp;\r\nunsigned long old_freq, new_freq, old_volt, new_volt, tol;\r\nint ret = 0;\r\nrcu_read_lock();\r\nnew_opp = devfreq_recommended_opp(dev, freq, flags);\r\nif (IS_ERR(new_opp)) {\r\ndev_err(dev, "failed to get recommended opp instance\n");\r\nrcu_read_unlock();\r\nreturn PTR_ERR(new_opp);\r\n}\r\nnew_freq = dev_pm_opp_get_freq(new_opp);\r\nnew_volt = dev_pm_opp_get_voltage(new_opp);\r\nold_freq = dev_pm_opp_get_freq(bus->curr_opp);\r\nold_volt = dev_pm_opp_get_voltage(bus->curr_opp);\r\nrcu_read_unlock();\r\nif (old_freq == new_freq)\r\nreturn 0;\r\ntol = new_volt * bus->voltage_tolerance / 100;\r\nmutex_lock(&bus->lock);\r\nif (old_freq < new_freq) {\r\nret = regulator_set_voltage_tol(bus->regulator, new_volt, tol);\r\nif (ret < 0) {\r\ndev_err(bus->dev, "failed to set voltage\n");\r\ngoto out;\r\n}\r\n}\r\nret = clk_set_rate(bus->clk, new_freq);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to change clock of bus\n");\r\nclk_set_rate(bus->clk, old_freq);\r\ngoto out;\r\n}\r\nif (old_freq > new_freq) {\r\nret = regulator_set_voltage_tol(bus->regulator, new_volt, tol);\r\nif (ret < 0) {\r\ndev_err(bus->dev, "failed to set voltage\n");\r\ngoto out;\r\n}\r\n}\r\nbus->curr_opp = new_opp;\r\ndev_dbg(dev, "Set the frequency of bus (%lukHz -> %lukHz)\n",\r\nold_freq/1000, new_freq/1000);\r\nout:\r\nmutex_unlock(&bus->lock);\r\nreturn ret;\r\n}\r\nstatic int exynos_bus_get_dev_status(struct device *dev,\r\nstruct devfreq_dev_status *stat)\r\n{\r\nstruct exynos_bus *bus = dev_get_drvdata(dev);\r\nstruct devfreq_event_data edata;\r\nint ret;\r\nrcu_read_lock();\r\nstat->current_frequency = dev_pm_opp_get_freq(bus->curr_opp);\r\nrcu_read_unlock();\r\nret = exynos_bus_get_event(bus, &edata);\r\nif (ret < 0) {\r\nstat->total_time = stat->busy_time = 0;\r\ngoto err;\r\n}\r\nstat->busy_time = (edata.load_count * 100) / bus->ratio;\r\nstat->total_time = edata.total_count;\r\ndev_dbg(dev, "Usage of devfreq-event : %lu/%lu\n", stat->busy_time,\r\nstat->total_time);\r\nerr:\r\nret = exynos_bus_set_event(bus);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to set event to devfreq-event devices\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void exynos_bus_exit(struct device *dev)\r\n{\r\nstruct exynos_bus *bus = dev_get_drvdata(dev);\r\nint ret;\r\nret = exynos_bus_disable_edev(bus);\r\nif (ret < 0)\r\ndev_warn(dev, "failed to disable the devfreq-event devices\n");\r\nif (bus->regulator)\r\nregulator_disable(bus->regulator);\r\ndev_pm_opp_of_remove_table(dev);\r\nclk_disable_unprepare(bus->clk);\r\n}\r\nstatic int exynos_bus_passive_target(struct device *dev, unsigned long *freq,\r\nu32 flags)\r\n{\r\nstruct exynos_bus *bus = dev_get_drvdata(dev);\r\nstruct dev_pm_opp *new_opp;\r\nunsigned long old_freq, new_freq;\r\nint ret = 0;\r\nrcu_read_lock();\r\nnew_opp = devfreq_recommended_opp(dev, freq, flags);\r\nif (IS_ERR(new_opp)) {\r\ndev_err(dev, "failed to get recommended opp instance\n");\r\nrcu_read_unlock();\r\nreturn PTR_ERR(new_opp);\r\n}\r\nnew_freq = dev_pm_opp_get_freq(new_opp);\r\nold_freq = dev_pm_opp_get_freq(bus->curr_opp);\r\nrcu_read_unlock();\r\nif (old_freq == new_freq)\r\nreturn 0;\r\nmutex_lock(&bus->lock);\r\nret = clk_set_rate(bus->clk, new_freq);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to set the clock of bus\n");\r\ngoto out;\r\n}\r\n*freq = new_freq;\r\nbus->curr_opp = new_opp;\r\ndev_dbg(dev, "Set the frequency of bus (%lukHz -> %lukHz)\n",\r\nold_freq/1000, new_freq/1000);\r\nout:\r\nmutex_unlock(&bus->lock);\r\nreturn ret;\r\n}\r\nstatic void exynos_bus_passive_exit(struct device *dev)\r\n{\r\nstruct exynos_bus *bus = dev_get_drvdata(dev);\r\ndev_pm_opp_of_remove_table(dev);\r\nclk_disable_unprepare(bus->clk);\r\n}\r\nstatic int exynos_bus_parent_parse_of(struct device_node *np,\r\nstruct exynos_bus *bus)\r\n{\r\nstruct device *dev = bus->dev;\r\nint i, ret, count, size;\r\nbus->regulator = devm_regulator_get(dev, "vdd");\r\nif (IS_ERR(bus->regulator)) {\r\ndev_err(dev, "failed to get VDD regulator\n");\r\nreturn PTR_ERR(bus->regulator);\r\n}\r\nret = regulator_enable(bus->regulator);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable VDD regulator\n");\r\nreturn ret;\r\n}\r\ncount = devfreq_event_get_edev_count(dev);\r\nif (count < 0) {\r\ndev_err(dev, "failed to get the count of devfreq-event dev\n");\r\nret = count;\r\ngoto err_regulator;\r\n}\r\nbus->edev_count = count;\r\nsize = sizeof(*bus->edev) * count;\r\nbus->edev = devm_kzalloc(dev, size, GFP_KERNEL);\r\nif (!bus->edev) {\r\nret = -ENOMEM;\r\ngoto err_regulator;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nbus->edev[i] = devfreq_event_get_edev_by_phandle(dev, i);\r\nif (IS_ERR(bus->edev[i])) {\r\nret = -EPROBE_DEFER;\r\ngoto err_regulator;\r\n}\r\n}\r\nif (of_property_read_u32(np, "exynos,saturation-ratio", &bus->ratio))\r\nbus->ratio = DEFAULT_SATURATION_RATIO;\r\nif (of_property_read_u32(np, "exynos,voltage-tolerance",\r\n&bus->voltage_tolerance))\r\nbus->voltage_tolerance = DEFAULT_VOLTAGE_TOLERANCE;\r\nreturn 0;\r\nerr_regulator:\r\nregulator_disable(bus->regulator);\r\nreturn ret;\r\n}\r\nstatic int exynos_bus_parse_of(struct device_node *np,\r\nstruct exynos_bus *bus)\r\n{\r\nstruct device *dev = bus->dev;\r\nunsigned long rate;\r\nint ret;\r\nbus->clk = devm_clk_get(dev, "bus");\r\nif (IS_ERR(bus->clk)) {\r\ndev_err(dev, "failed to get bus clock\n");\r\nreturn PTR_ERR(bus->clk);\r\n}\r\nret = clk_prepare_enable(bus->clk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get enable clock\n");\r\nreturn ret;\r\n}\r\nrcu_read_lock();\r\nret = dev_pm_opp_of_add_table(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get OPP table\n");\r\nrcu_read_unlock();\r\ngoto err_clk;\r\n}\r\nrate = clk_get_rate(bus->clk);\r\nbus->curr_opp = devfreq_recommended_opp(dev, &rate, 0);\r\nif (IS_ERR(bus->curr_opp)) {\r\ndev_err(dev, "failed to find dev_pm_opp\n");\r\nrcu_read_unlock();\r\nret = PTR_ERR(bus->curr_opp);\r\ngoto err_opp;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\nerr_opp:\r\ndev_pm_opp_of_remove_table(dev);\r\nerr_clk:\r\nclk_disable_unprepare(bus->clk);\r\nreturn ret;\r\n}\r\nstatic int exynos_bus_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node, *node;\r\nstruct devfreq_dev_profile *profile;\r\nstruct devfreq_simple_ondemand_data *ondemand_data;\r\nstruct devfreq_passive_data *passive_data;\r\nstruct devfreq *parent_devfreq;\r\nstruct exynos_bus *bus;\r\nint ret, max_state;\r\nunsigned long min_freq, max_freq;\r\nif (!np) {\r\ndev_err(dev, "failed to find devicetree node\n");\r\nreturn -EINVAL;\r\n}\r\nbus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);\r\nif (!bus)\r\nreturn -ENOMEM;\r\nmutex_init(&bus->lock);\r\nbus->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, bus);\r\nret = exynos_bus_parse_of(np, bus);\r\nif (ret < 0)\r\nreturn ret;\r\nprofile = devm_kzalloc(dev, sizeof(*profile), GFP_KERNEL);\r\nif (!profile) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nnode = of_parse_phandle(dev->of_node, "devfreq", 0);\r\nif (node) {\r\nof_node_put(node);\r\ngoto passive;\r\n} else {\r\nret = exynos_bus_parent_parse_of(np, bus);\r\n}\r\nif (ret < 0)\r\ngoto err;\r\nprofile->polling_ms = 50;\r\nprofile->target = exynos_bus_target;\r\nprofile->get_dev_status = exynos_bus_get_dev_status;\r\nprofile->exit = exynos_bus_exit;\r\nondemand_data = devm_kzalloc(dev, sizeof(*ondemand_data), GFP_KERNEL);\r\nif (!ondemand_data) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nondemand_data->upthreshold = 40;\r\nondemand_data->downdifferential = 5;\r\nbus->devfreq = devm_devfreq_add_device(dev, profile, "simple_ondemand",\r\nondemand_data);\r\nif (IS_ERR(bus->devfreq)) {\r\ndev_err(dev, "failed to add devfreq device\n");\r\nret = PTR_ERR(bus->devfreq);\r\ngoto err;\r\n}\r\nret = devm_devfreq_register_opp_notifier(dev, bus->devfreq);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register opp notifier\n");\r\ngoto err;\r\n}\r\nret = exynos_bus_enable_edev(bus);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable devfreq-event devices\n");\r\ngoto err;\r\n}\r\nret = exynos_bus_set_event(bus);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to set event to devfreq-event devices\n");\r\ngoto err;\r\n}\r\ngoto out;\r\npassive:\r\nprofile->target = exynos_bus_passive_target;\r\nprofile->exit = exynos_bus_passive_exit;\r\nparent_devfreq = devfreq_get_devfreq_by_phandle(dev, 0);\r\nif (IS_ERR(parent_devfreq)) {\r\nret = -EPROBE_DEFER;\r\ngoto err;\r\n}\r\npassive_data = devm_kzalloc(dev, sizeof(*passive_data), GFP_KERNEL);\r\nif (!passive_data) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\npassive_data->parent = parent_devfreq;\r\nbus->devfreq = devm_devfreq_add_device(dev, profile, "passive",\r\npassive_data);\r\nif (IS_ERR(bus->devfreq)) {\r\ndev_err(dev,\r\n"failed to add devfreq dev with passive governor\n");\r\nret = -EPROBE_DEFER;\r\ngoto err;\r\n}\r\nout:\r\nmax_state = bus->devfreq->profile->max_state;\r\nmin_freq = (bus->devfreq->profile->freq_table[0] / 1000);\r\nmax_freq = (bus->devfreq->profile->freq_table[max_state - 1] / 1000);\r\npr_info("exynos-bus: new bus device registered: %s (%6ld KHz ~ %6ld KHz)\n",\r\ndev_name(dev), min_freq, max_freq);\r\nreturn 0;\r\nerr:\r\ndev_pm_opp_of_remove_table(dev);\r\nclk_disable_unprepare(bus->clk);\r\nreturn ret;\r\n}\r\nstatic int exynos_bus_resume(struct device *dev)\r\n{\r\nstruct exynos_bus *bus = dev_get_drvdata(dev);\r\nint ret;\r\nret = exynos_bus_enable_edev(bus);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable the devfreq-event devices\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_bus_suspend(struct device *dev)\r\n{\r\nstruct exynos_bus *bus = dev_get_drvdata(dev);\r\nint ret;\r\nret = exynos_bus_disable_edev(bus);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to disable the devfreq-event devices\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
