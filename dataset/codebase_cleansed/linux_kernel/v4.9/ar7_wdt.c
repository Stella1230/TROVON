static void ar7_wdt_kick(u32 value)\r\n{\r\nWRITE_REG(ar7_wdt->kick_lock, 0x5555);\r\nif ((READ_REG(ar7_wdt->kick_lock) & 3) == 1) {\r\nWRITE_REG(ar7_wdt->kick_lock, 0xaaaa);\r\nif ((READ_REG(ar7_wdt->kick_lock) & 3) == 3) {\r\nWRITE_REG(ar7_wdt->kick, value);\r\nreturn;\r\n}\r\n}\r\npr_err("failed to unlock WDT kick reg\n");\r\n}\r\nstatic void ar7_wdt_prescale(u32 value)\r\n{\r\nWRITE_REG(ar7_wdt->prescale_lock, 0x5a5a);\r\nif ((READ_REG(ar7_wdt->prescale_lock) & 3) == 1) {\r\nWRITE_REG(ar7_wdt->prescale_lock, 0xa5a5);\r\nif ((READ_REG(ar7_wdt->prescale_lock) & 3) == 3) {\r\nWRITE_REG(ar7_wdt->prescale, value);\r\nreturn;\r\n}\r\n}\r\npr_err("failed to unlock WDT prescale reg\n");\r\n}\r\nstatic void ar7_wdt_change(u32 value)\r\n{\r\nWRITE_REG(ar7_wdt->change_lock, 0x6666);\r\nif ((READ_REG(ar7_wdt->change_lock) & 3) == 1) {\r\nWRITE_REG(ar7_wdt->change_lock, 0xbbbb);\r\nif ((READ_REG(ar7_wdt->change_lock) & 3) == 3) {\r\nWRITE_REG(ar7_wdt->change, value);\r\nreturn;\r\n}\r\n}\r\npr_err("failed to unlock WDT change reg\n");\r\n}\r\nstatic void ar7_wdt_disable(u32 value)\r\n{\r\nWRITE_REG(ar7_wdt->disable_lock, 0x7777);\r\nif ((READ_REG(ar7_wdt->disable_lock) & 3) == 1) {\r\nWRITE_REG(ar7_wdt->disable_lock, 0xcccc);\r\nif ((READ_REG(ar7_wdt->disable_lock) & 3) == 2) {\r\nWRITE_REG(ar7_wdt->disable_lock, 0xdddd);\r\nif ((READ_REG(ar7_wdt->disable_lock) & 3) == 3) {\r\nWRITE_REG(ar7_wdt->disable, value);\r\nreturn;\r\n}\r\n}\r\n}\r\npr_err("failed to unlock WDT disable reg\n");\r\n}\r\nstatic void ar7_wdt_update_margin(int new_margin)\r\n{\r\nu32 change;\r\nu32 vbus_rate;\r\nvbus_rate = clk_get_rate(vbus_clk);\r\nchange = new_margin * (vbus_rate / prescale_value);\r\nif (change < 1)\r\nchange = 1;\r\nif (change > 0xffff)\r\nchange = 0xffff;\r\nar7_wdt_change(change);\r\nmargin = change * prescale_value / vbus_rate;\r\npr_info("timer margin %d seconds (prescale %d, change %d, freq %d)\n",\r\nmargin, prescale_value, change, vbus_rate);\r\n}\r\nstatic void ar7_wdt_enable_wdt(void)\r\n{\r\npr_debug("enabling watchdog timer\n");\r\nar7_wdt_disable(1);\r\nar7_wdt_kick(1);\r\n}\r\nstatic void ar7_wdt_disable_wdt(void)\r\n{\r\npr_debug("disabling watchdog timer\n");\r\nar7_wdt_disable(0);\r\n}\r\nstatic int ar7_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &wdt_is_open))\r\nreturn -EBUSY;\r\nar7_wdt_enable_wdt();\r\nexpect_close = 0;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int ar7_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (!expect_close)\r\npr_warn("watchdog device closed unexpectedly, will not disable the watchdog timer\n");\r\nelse if (!nowayout)\r\nar7_wdt_disable_wdt();\r\nclear_bit(0, &wdt_is_open);\r\nreturn 0;\r\n}\r\nstatic ssize_t ar7_wdt_write(struct file *file, const char *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nsize_t i;\r\nspin_lock(&wdt_lock);\r\nar7_wdt_kick(1);\r\nspin_unlock(&wdt_lock);\r\nexpect_close = 0;\r\nfor (i = 0; i < len; ++i) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 1;\r\n}\r\n}\r\nreturn len;\r\n}\r\nstatic long ar7_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstatic const struct watchdog_info ident = {\r\n.identity = LONGNAME,\r\n.firmware_version = 1,\r\n.options = (WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING |\r\nWDIOF_MAGICCLOSE),\r\n};\r\nint new_margin;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user((struct watchdog_info *)arg, &ident,\r\nsizeof(ident)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nif (put_user(0, (int *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_KEEPALIVE:\r\nar7_wdt_kick(1);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_margin, (int *)arg))\r\nreturn -EFAULT;\r\nif (new_margin < 1)\r\nreturn -EINVAL;\r\nspin_lock(&wdt_lock);\r\nar7_wdt_update_margin(new_margin);\r\nar7_wdt_kick(1);\r\nspin_unlock(&wdt_lock);\r\ncase WDIOC_GETTIMEOUT:\r\nif (put_user(margin, (int *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int ar7_wdt_probe(struct platform_device *pdev)\r\n{\r\nint rc;\r\nar7_regs_wdt =\r\nplatform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");\r\nar7_wdt = devm_ioremap_resource(&pdev->dev, ar7_regs_wdt);\r\nif (IS_ERR(ar7_wdt))\r\nreturn PTR_ERR(ar7_wdt);\r\nvbus_clk = clk_get(NULL, "vbus");\r\nif (IS_ERR(vbus_clk)) {\r\npr_err("could not get vbus clock\n");\r\nreturn PTR_ERR(vbus_clk);\r\n}\r\nar7_wdt_disable_wdt();\r\nar7_wdt_prescale(prescale_value);\r\nar7_wdt_update_margin(margin);\r\nrc = misc_register(&ar7_wdt_miscdev);\r\nif (rc) {\r\npr_err("unable to register misc device\n");\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nclk_put(vbus_clk);\r\nvbus_clk = NULL;\r\nreturn rc;\r\n}\r\nstatic int ar7_wdt_remove(struct platform_device *pdev)\r\n{\r\nmisc_deregister(&ar7_wdt_miscdev);\r\nclk_put(vbus_clk);\r\nvbus_clk = NULL;\r\nreturn 0;\r\n}\r\nstatic void ar7_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nif (!nowayout)\r\nar7_wdt_disable_wdt();\r\n}
