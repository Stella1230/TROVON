static int tangox_wdt_set_timeout(struct watchdog_device *wdt,\r\nunsigned int new_timeout)\r\n{\r\nwdt->timeout = new_timeout;\r\nreturn 0;\r\n}\r\nstatic int tangox_wdt_start(struct watchdog_device *wdt)\r\n{\r\nstruct tangox_wdt_device *dev = watchdog_get_drvdata(wdt);\r\nu32 ticks;\r\nticks = 1 + wdt->timeout * dev->clk_rate;\r\nwritel(ticks, dev->base + WD_COUNTER);\r\nreturn 0;\r\n}\r\nstatic int tangox_wdt_stop(struct watchdog_device *wdt)\r\n{\r\nstruct tangox_wdt_device *dev = watchdog_get_drvdata(wdt);\r\nwritel(0, dev->base + WD_COUNTER);\r\nreturn 0;\r\n}\r\nstatic unsigned int tangox_wdt_get_timeleft(struct watchdog_device *wdt)\r\n{\r\nstruct tangox_wdt_device *dev = watchdog_get_drvdata(wdt);\r\nu32 count;\r\ncount = readl(dev->base + WD_COUNTER);\r\nif (!count)\r\nreturn 0;\r\nreturn (count - 1) / dev->clk_rate;\r\n}\r\nstatic int tangox_wdt_restart(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct tangox_wdt_device *dev =\r\ncontainer_of(nb, struct tangox_wdt_device, restart);\r\nwritel(1, dev->base + WD_COUNTER);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int tangox_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct tangox_wdt_device *dev;\r\nstruct resource *res;\r\nu32 config;\r\nint err;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dev->base))\r\nreturn PTR_ERR(dev->base);\r\ndev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk))\r\nreturn PTR_ERR(dev->clk);\r\nerr = clk_prepare_enable(dev->clk);\r\nif (err)\r\nreturn err;\r\ndev->clk_rate = clk_get_rate(dev->clk);\r\nif (!dev->clk_rate) {\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\ndev->wdt.parent = &pdev->dev;\r\ndev->wdt.info = &tangox_wdt_info;\r\ndev->wdt.ops = &tangox_wdt_ops;\r\ndev->wdt.timeout = DEFAULT_TIMEOUT;\r\ndev->wdt.min_timeout = 1;\r\ndev->wdt.max_hw_heartbeat_ms = (U32_MAX - 1) / dev->clk_rate;\r\nwatchdog_init_timeout(&dev->wdt, timeout, &pdev->dev);\r\nwatchdog_set_nowayout(&dev->wdt, nowayout);\r\nwatchdog_set_drvdata(&dev->wdt, dev);\r\nconfig = readl(dev->base + WD_CONFIG);\r\nif (config & WD_CONFIG_DISABLE)\r\nwritel(0, dev->base + WD_COUNTER);\r\nwritel(WD_CONFIG_XTAL_IN, dev->base + WD_CONFIG);\r\nif (readl(dev->base + WD_COUNTER)) {\r\nset_bit(WDOG_HW_RUNNING, &dev->wdt.status);\r\ntangox_wdt_start(&dev->wdt);\r\n}\r\nerr = watchdog_register_device(&dev->wdt);\r\nif (err)\r\ngoto err;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->restart.notifier_call = tangox_wdt_restart;\r\ndev->restart.priority = 128;\r\nerr = register_restart_handler(&dev->restart);\r\nif (err)\r\ndev_warn(&pdev->dev, "failed to register restart handler\n");\r\ndev_info(&pdev->dev, "SMP86xx/SMP87xx watchdog registered\n");\r\nreturn 0;\r\nerr:\r\nclk_disable_unprepare(dev->clk);\r\nreturn err;\r\n}\r\nstatic int tangox_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct tangox_wdt_device *dev = platform_get_drvdata(pdev);\r\ntangox_wdt_stop(&dev->wdt);\r\nclk_disable_unprepare(dev->clk);\r\nunregister_restart_handler(&dev->restart);\r\nwatchdog_unregister_device(&dev->wdt);\r\nreturn 0;\r\n}
