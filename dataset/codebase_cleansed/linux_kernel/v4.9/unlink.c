static void\r\nnfs_free_unlinkdata(struct nfs_unlinkdata *data)\r\n{\r\nput_rpccred(data->cred);\r\nkfree(data->args.name.name);\r\nkfree(data);\r\n}\r\nstatic void nfs_async_unlink_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_unlinkdata *data = calldata;\r\nstruct inode *dir = d_inode(data->dentry->d_parent);\r\ntrace_nfs_sillyrename_unlink(data, task->tk_status);\r\nif (!NFS_PROTO(dir)->unlink_done(task, dir))\r\nrpc_restart_call_prepare(task);\r\n}\r\nstatic void nfs_async_unlink_release(void *calldata)\r\n{\r\nstruct nfs_unlinkdata *data = calldata;\r\nstruct dentry *dentry = data->dentry;\r\nstruct super_block *sb = dentry->d_sb;\r\nup_read_non_owner(&NFS_I(d_inode(dentry->d_parent))->rmdir_sem);\r\nd_lookup_done(dentry);\r\nnfs_free_unlinkdata(data);\r\ndput(dentry);\r\nnfs_sb_deactive(sb);\r\n}\r\nstatic void nfs_unlink_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_unlinkdata *data = calldata;\r\nstruct inode *dir = d_inode(data->dentry->d_parent);\r\nNFS_PROTO(dir)->unlink_rpc_prepare(task, data);\r\n}\r\nstatic void nfs_do_call_unlink(struct nfs_unlinkdata *data)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_argp = &data->args,\r\n.rpc_resp = &data->res,\r\n.rpc_cred = data->cred,\r\n};\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_message = &msg,\r\n.callback_ops = &nfs_unlink_ops,\r\n.callback_data = data,\r\n.workqueue = nfsiod_workqueue,\r\n.flags = RPC_TASK_ASYNC,\r\n};\r\nstruct rpc_task *task;\r\nstruct inode *dir = d_inode(data->dentry->d_parent);\r\nnfs_sb_active(dir->i_sb);\r\ndata->args.fh = NFS_FH(dir);\r\nnfs_fattr_init(data->res.dir_attr);\r\nNFS_PROTO(dir)->unlink_setup(&msg, dir);\r\ntask_setup_data.rpc_client = NFS_CLIENT(dir);\r\ntask = rpc_run_task(&task_setup_data);\r\nif (!IS_ERR(task))\r\nrpc_put_task_async(task);\r\n}\r\nstatic int nfs_call_unlink(struct dentry *dentry, struct nfs_unlinkdata *data)\r\n{\r\nstruct inode *dir = d_inode(dentry->d_parent);\r\nstruct dentry *alias;\r\ndown_read_non_owner(&NFS_I(dir)->rmdir_sem);\r\nalias = d_alloc_parallel(dentry->d_parent, &data->args.name, &data->wq);\r\nif (IS_ERR(alias)) {\r\nup_read_non_owner(&NFS_I(dir)->rmdir_sem);\r\nreturn 0;\r\n}\r\nif (!d_in_lookup(alias)) {\r\nint ret;\r\nvoid *devname_garbage = NULL;\r\nspin_lock(&alias->d_lock);\r\nif (d_really_is_positive(alias) &&\r\n!(alias->d_flags & DCACHE_NFSFS_RENAMED)) {\r\ndevname_garbage = alias->d_fsdata;\r\nalias->d_fsdata = data;\r\nalias->d_flags |= DCACHE_NFSFS_RENAMED;\r\nret = 1;\r\n} else\r\nret = 0;\r\nspin_unlock(&alias->d_lock);\r\ndput(alias);\r\nup_read_non_owner(&NFS_I(dir)->rmdir_sem);\r\nkfree(devname_garbage);\r\nreturn ret;\r\n}\r\ndata->dentry = alias;\r\nnfs_do_call_unlink(data);\r\nreturn 1;\r\n}\r\nstatic int\r\nnfs_async_unlink(struct dentry *dentry, const struct qstr *name)\r\n{\r\nstruct nfs_unlinkdata *data;\r\nint status = -ENOMEM;\r\nvoid *devname_garbage = NULL;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\ngoto out;\r\ndata->args.name.name = kstrdup(name->name, GFP_KERNEL);\r\nif (!data->args.name.name)\r\ngoto out_free;\r\ndata->args.name.len = name->len;\r\ndata->cred = rpc_lookup_cred();\r\nif (IS_ERR(data->cred)) {\r\nstatus = PTR_ERR(data->cred);\r\ngoto out_free_name;\r\n}\r\ndata->res.dir_attr = &data->dir_attr;\r\ninit_waitqueue_head(&data->wq);\r\nstatus = -EBUSY;\r\nspin_lock(&dentry->d_lock);\r\nif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\r\ngoto out_unlock;\r\ndentry->d_flags |= DCACHE_NFSFS_RENAMED;\r\ndevname_garbage = dentry->d_fsdata;\r\ndentry->d_fsdata = data;\r\nspin_unlock(&dentry->d_lock);\r\nkfree(devname_garbage);\r\nreturn 0;\r\nout_unlock:\r\nspin_unlock(&dentry->d_lock);\r\nput_rpccred(data->cred);\r\nout_free_name:\r\nkfree(data->args.name.name);\r\nout_free:\r\nkfree(data);\r\nout:\r\nreturn status;\r\n}\r\nvoid\r\nnfs_complete_unlink(struct dentry *dentry, struct inode *inode)\r\n{\r\nstruct nfs_unlinkdata *data;\r\nspin_lock(&dentry->d_lock);\r\ndentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\r\ndata = dentry->d_fsdata;\r\ndentry->d_fsdata = NULL;\r\nspin_unlock(&dentry->d_lock);\r\nif (NFS_STALE(inode) || !nfs_call_unlink(dentry, data))\r\nnfs_free_unlinkdata(data);\r\n}\r\nstatic void\r\nnfs_cancel_async_unlink(struct dentry *dentry)\r\n{\r\nspin_lock(&dentry->d_lock);\r\nif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\r\nstruct nfs_unlinkdata *data = dentry->d_fsdata;\r\ndentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\r\ndentry->d_fsdata = NULL;\r\nspin_unlock(&dentry->d_lock);\r\nnfs_free_unlinkdata(data);\r\nreturn;\r\n}\r\nspin_unlock(&dentry->d_lock);\r\n}\r\nstatic void nfs_async_rename_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_renamedata *data = calldata;\r\nstruct inode *old_dir = data->old_dir;\r\nstruct inode *new_dir = data->new_dir;\r\nstruct dentry *old_dentry = data->old_dentry;\r\ntrace_nfs_sillyrename_rename(old_dir, old_dentry,\r\nnew_dir, data->new_dentry, task->tk_status);\r\nif (!NFS_PROTO(old_dir)->rename_done(task, old_dir, new_dir)) {\r\nrpc_restart_call_prepare(task);\r\nreturn;\r\n}\r\nif (data->complete)\r\ndata->complete(task, data);\r\n}\r\nstatic void nfs_async_rename_release(void *calldata)\r\n{\r\nstruct nfs_renamedata *data = calldata;\r\nstruct super_block *sb = data->old_dir->i_sb;\r\nif (d_really_is_positive(data->old_dentry))\r\nnfs_mark_for_revalidate(d_inode(data->old_dentry));\r\ndput(data->old_dentry);\r\ndput(data->new_dentry);\r\niput(data->old_dir);\r\niput(data->new_dir);\r\nnfs_sb_deactive(sb);\r\nput_rpccred(data->cred);\r\nkfree(data);\r\n}\r\nstatic void nfs_rename_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_renamedata *data = calldata;\r\nNFS_PROTO(data->old_dir)->rename_rpc_prepare(task, data);\r\n}\r\nstruct rpc_task *\r\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\r\nstruct dentry *old_dentry, struct dentry *new_dentry,\r\nvoid (*complete)(struct rpc_task *, struct nfs_renamedata *))\r\n{\r\nstruct nfs_renamedata *data;\r\nstruct rpc_message msg = { };\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_message = &msg,\r\n.callback_ops = &nfs_rename_ops,\r\n.workqueue = nfsiod_workqueue,\r\n.rpc_client = NFS_CLIENT(old_dir),\r\n.flags = RPC_TASK_ASYNC,\r\n};\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ntask_setup_data.callback_data = data;\r\ndata->cred = rpc_lookup_cred();\r\nif (IS_ERR(data->cred)) {\r\nstruct rpc_task *task = ERR_CAST(data->cred);\r\nkfree(data);\r\nreturn task;\r\n}\r\nmsg.rpc_argp = &data->args;\r\nmsg.rpc_resp = &data->res;\r\nmsg.rpc_cred = data->cred;\r\ndata->old_dir = old_dir;\r\nihold(old_dir);\r\ndata->new_dir = new_dir;\r\nihold(new_dir);\r\ndata->old_dentry = dget(old_dentry);\r\ndata->new_dentry = dget(new_dentry);\r\nnfs_fattr_init(&data->old_fattr);\r\nnfs_fattr_init(&data->new_fattr);\r\ndata->complete = complete;\r\ndata->args.old_dir = NFS_FH(old_dir);\r\ndata->args.old_name = &old_dentry->d_name;\r\ndata->args.new_dir = NFS_FH(new_dir);\r\ndata->args.new_name = &new_dentry->d_name;\r\ndata->res.old_fattr = &data->old_fattr;\r\ndata->res.new_fattr = &data->new_fattr;\r\nnfs_sb_active(old_dir->i_sb);\r\nNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dir);\r\nreturn rpc_run_task(&task_setup_data);\r\n}\r\nstatic void\r\nnfs_complete_sillyrename(struct rpc_task *task, struct nfs_renamedata *data)\r\n{\r\nstruct dentry *dentry = data->old_dentry;\r\nif (task->tk_status != 0) {\r\nnfs_cancel_async_unlink(dentry);\r\nreturn;\r\n}\r\nfsnotify_nameremove(dentry, 0);\r\n}\r\nint\r\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\r\n{\r\nstatic unsigned int sillycounter;\r\nunsigned char silly[SILLYNAME_LEN + 1];\r\nunsigned long long fileid;\r\nstruct dentry *sdentry;\r\nstruct rpc_task *task;\r\nint error = -EBUSY;\r\ndfprintk(VFS, "NFS: silly-rename(%pd2, ct=%d)\n",\r\ndentry, d_count(dentry));\r\nnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\r\nif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\r\ngoto out;\r\nfileid = NFS_FILEID(d_inode(dentry));\r\nNFS_PROTO(d_inode(dentry))->return_delegation(d_inode(dentry));\r\nsdentry = NULL;\r\ndo {\r\nint slen;\r\ndput(sdentry);\r\nsillycounter++;\r\nslen = scnprintf(silly, sizeof(silly),\r\nSILLYNAME_PREFIX "%0*llx%0*x",\r\nSILLYNAME_FILEID_LEN, fileid,\r\nSILLYNAME_COUNTER_LEN, sillycounter);\r\ndfprintk(VFS, "NFS: trying to rename %pd to %s\n",\r\ndentry, silly);\r\nsdentry = lookup_one_len(silly, dentry->d_parent, slen);\r\nif (IS_ERR(sdentry))\r\ngoto out;\r\n} while (d_inode(sdentry) != NULL);\r\nerror = nfs_async_unlink(dentry, &sdentry->d_name);\r\nif (error)\r\ngoto out_dput;\r\ntask = nfs_async_rename(dir, dir, dentry, sdentry,\r\nnfs_complete_sillyrename);\r\nif (IS_ERR(task)) {\r\nerror = -EBUSY;\r\nnfs_cancel_async_unlink(dentry);\r\ngoto out_dput;\r\n}\r\nerror = rpc_wait_for_completion_task(task);\r\nif (error == 0)\r\nerror = task->tk_status;\r\nswitch (error) {\r\ncase 0:\r\nnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\r\nd_move(dentry, sdentry);\r\nbreak;\r\ncase -ERESTARTSYS:\r\nd_drop(dentry);\r\nd_drop(sdentry);\r\n}\r\nrpc_put_task(task);\r\nout_dput:\r\ndput(sdentry);\r\nout:\r\nreturn error;\r\n}
