static struct pseries_io_event * ioei_find_event(struct rtas_error_log *elog)\r\n{\r\nstruct pseries_errorlog *sect;\r\nif (unlikely(rtas_error_type(elog) != RTAS_TYPE_IO)) {\r\nprintk_once(KERN_WARNING"io_event_irq: Unexpected event type %d",\r\nrtas_error_type(elog));\r\nreturn NULL;\r\n}\r\nsect = get_pseries_errorlog(elog, PSERIES_ELOG_SECT_ID_IO_EVENT);\r\nif (unlikely(!sect)) {\r\nprintk_once(KERN_WARNING "io_event_irq: RTAS extended event "\r\n"log does not contain an IO Event section. "\r\n"Could be a bug in system firmware!\n");\r\nreturn NULL;\r\n}\r\nreturn (struct pseries_io_event *) &sect->data;\r\n}\r\nstatic irqreturn_t ioei_interrupt(int irq, void *dev_id)\r\n{\r\nstruct pseries_io_event *event;\r\nint rtas_rc;\r\nfor (;;) {\r\nrtas_rc = rtas_call(ioei_check_exception_token, 6, 1, NULL,\r\nRTAS_VECTOR_EXTERNAL_INTERRUPT,\r\nvirq_to_hw(irq),\r\nRTAS_IO_EVENTS, 1 ,\r\n__pa(ioei_rtas_buf),\r\nRTAS_DATA_BUF_SIZE);\r\nif (rtas_rc != 0)\r\nbreak;\r\nevent = ioei_find_event((struct rtas_error_log *)ioei_rtas_buf);\r\nif (!event)\r\ncontinue;\r\natomic_notifier_call_chain(&pseries_ioei_notifier_list,\r\n0, event);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init ioei_init(void)\r\n{\r\nstruct device_node *np;\r\nioei_check_exception_token = rtas_token("check-exception");\r\nif (ioei_check_exception_token == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENODEV;\r\nnp = of_find_node_by_path("/event-sources/ibm,io-events");\r\nif (np) {\r\nrequest_event_sources_irqs(np, ioei_interrupt, "IO_EVENT");\r\npr_info("IBM I/O event interrupts enabled\n");\r\nof_node_put(np);\r\n} else {\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}
