static void batadv_v_elp_start_timer(struct batadv_hard_iface *hard_iface)\r\n{\r\nunsigned int msecs;\r\nmsecs = atomic_read(&hard_iface->bat_v.elp_interval) - BATADV_JITTER;\r\nmsecs += prandom_u32() % (2 * BATADV_JITTER);\r\nqueue_delayed_work(batadv_event_workqueue, &hard_iface->bat_v.elp_wq,\r\nmsecs_to_jiffies(msecs));\r\n}\r\nstatic u32 batadv_v_elp_get_throughput(struct batadv_hardif_neigh_node *neigh)\r\n{\r\nstruct batadv_hard_iface *hard_iface = neigh->if_incoming;\r\nstruct ethtool_link_ksettings link_settings;\r\nstruct station_info sinfo;\r\nu32 throughput;\r\nint ret;\r\nthroughput = atomic_read(&hard_iface->bat_v.throughput_override);\r\nif (throughput != 0)\r\nreturn throughput;\r\nif (batadv_is_wifi_netdev(hard_iface->net_dev)) {\r\nif (hard_iface->net_dev->ieee80211_ptr) {\r\nret = cfg80211_get_station(hard_iface->net_dev,\r\nneigh->addr, &sinfo);\r\nif (ret == -ENOENT) {\r\nreturn 0;\r\n}\r\nif (!ret)\r\nreturn sinfo.expected_throughput / 100;\r\n}\r\ngoto default_throughput;\r\n}\r\nmemset(&link_settings, 0, sizeof(link_settings));\r\nrtnl_lock();\r\nret = __ethtool_get_link_ksettings(hard_iface->net_dev, &link_settings);\r\nrtnl_unlock();\r\nif (ret == 0) {\r\nif (link_settings.base.duplex == DUPLEX_FULL)\r\nhard_iface->bat_v.flags |= BATADV_FULL_DUPLEX;\r\nelse\r\nhard_iface->bat_v.flags &= ~BATADV_FULL_DUPLEX;\r\nthroughput = link_settings.base.speed;\r\nif (throughput && (throughput != SPEED_UNKNOWN))\r\nreturn throughput * 10;\r\n}\r\ndefault_throughput:\r\nif (!(hard_iface->bat_v.flags & BATADV_WARNING_DEFAULT)) {\r\nbatadv_info(hard_iface->soft_iface,\r\n"WiFi driver or ethtool info does not provide information about link speeds on interface %s, therefore defaulting to hardcoded throughput values of %u.%1u Mbps. Consider overriding the throughput manually or checking your driver.\n",\r\nhard_iface->net_dev->name,\r\nBATADV_THROUGHPUT_DEFAULT_VALUE / 10,\r\nBATADV_THROUGHPUT_DEFAULT_VALUE % 10);\r\nhard_iface->bat_v.flags |= BATADV_WARNING_DEFAULT;\r\n}\r\nreturn BATADV_THROUGHPUT_DEFAULT_VALUE;\r\n}\r\nvoid batadv_v_elp_throughput_metric_update(struct work_struct *work)\r\n{\r\nstruct batadv_hardif_neigh_node_bat_v *neigh_bat_v;\r\nstruct batadv_hardif_neigh_node *neigh;\r\nneigh_bat_v = container_of(work, struct batadv_hardif_neigh_node_bat_v,\r\nmetric_work);\r\nneigh = container_of(neigh_bat_v, struct batadv_hardif_neigh_node,\r\nbat_v);\r\newma_throughput_add(&neigh->bat_v.throughput,\r\nbatadv_v_elp_get_throughput(neigh));\r\nbatadv_hardif_neigh_put(neigh);\r\n}\r\nstatic bool\r\nbatadv_v_elp_wifi_neigh_probe(struct batadv_hardif_neigh_node *neigh)\r\n{\r\nstruct batadv_hard_iface *hard_iface = neigh->if_incoming;\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nunsigned long last_tx_diff;\r\nstruct sk_buff *skb;\r\nint probe_len, i;\r\nint elp_skb_len;\r\nif (!batadv_is_wifi_netdev(hard_iface->net_dev))\r\nreturn true;\r\nlast_tx_diff = jiffies_to_msecs(jiffies - neigh->bat_v.last_unicast_tx);\r\nif (last_tx_diff <= BATADV_ELP_PROBE_MAX_TX_DIFF)\r\nreturn true;\r\nprobe_len = max_t(int, sizeof(struct batadv_elp_packet),\r\nBATADV_ELP_MIN_PROBE_SIZE);\r\nfor (i = 0; i < BATADV_ELP_PROBES_PER_NODE; i++) {\r\nelp_skb_len = hard_iface->bat_v.elp_skb->len;\r\nskb = skb_copy_expand(hard_iface->bat_v.elp_skb, 0,\r\nprobe_len - elp_skb_len,\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn false;\r\nskb_put(skb, probe_len - hard_iface->bat_v.elp_skb->len);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Sending unicast (probe) ELP packet on interface %s to %pM\n",\r\nhard_iface->net_dev->name, neigh->addr);\r\nbatadv_send_skb_packet(skb, hard_iface, neigh->addr);\r\n}\r\nreturn true;\r\n}\r\nstatic void batadv_v_elp_periodic_work(struct work_struct *work)\r\n{\r\nstruct batadv_hardif_neigh_node *hardif_neigh;\r\nstruct batadv_hard_iface *hard_iface;\r\nstruct batadv_hard_iface_bat_v *bat_v;\r\nstruct batadv_elp_packet *elp_packet;\r\nstruct batadv_priv *bat_priv;\r\nstruct sk_buff *skb;\r\nu32 elp_interval;\r\nbat_v = container_of(work, struct batadv_hard_iface_bat_v, elp_wq.work);\r\nhard_iface = container_of(bat_v, struct batadv_hard_iface, bat_v);\r\nbat_priv = netdev_priv(hard_iface->soft_iface);\r\nif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING)\r\ngoto out;\r\nif ((hard_iface->if_status == BATADV_IF_NOT_IN_USE) ||\r\n(hard_iface->if_status == BATADV_IF_TO_BE_REMOVED))\r\ngoto out;\r\nif (hard_iface->if_status != BATADV_IF_ACTIVE)\r\ngoto restart_timer;\r\nskb = skb_copy(hard_iface->bat_v.elp_skb, GFP_ATOMIC);\r\nif (!skb)\r\ngoto restart_timer;\r\nelp_packet = (struct batadv_elp_packet *)skb->data;\r\nelp_packet->seqno = htonl(atomic_read(&hard_iface->bat_v.elp_seqno));\r\nelp_interval = atomic_read(&hard_iface->bat_v.elp_interval);\r\nelp_packet->elp_interval = htonl(elp_interval);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Sending broadcast ELP packet on interface %s, seqno %u\n",\r\nhard_iface->net_dev->name,\r\natomic_read(&hard_iface->bat_v.elp_seqno));\r\nbatadv_send_broadcast_skb(skb, hard_iface);\r\natomic_inc(&hard_iface->bat_v.elp_seqno);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(hardif_neigh, &hard_iface->neigh_list, list) {\r\nif (!batadv_v_elp_wifi_neigh_probe(hardif_neigh))\r\nbreak;\r\nif (!kref_get_unless_zero(&hardif_neigh->refcount))\r\ncontinue;\r\nqueue_work(batadv_event_workqueue,\r\n&hardif_neigh->bat_v.metric_work);\r\n}\r\nrcu_read_unlock();\r\nrestart_timer:\r\nbatadv_v_elp_start_timer(hard_iface);\r\nout:\r\nreturn;\r\n}\r\nint batadv_v_elp_iface_enable(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_elp_packet *elp_packet;\r\nunsigned char *elp_buff;\r\nu32 random_seqno;\r\nsize_t size;\r\nint res = -ENOMEM;\r\nsize = ETH_HLEN + NET_IP_ALIGN + BATADV_ELP_HLEN;\r\nhard_iface->bat_v.elp_skb = dev_alloc_skb(size);\r\nif (!hard_iface->bat_v.elp_skb)\r\ngoto out;\r\nskb_reserve(hard_iface->bat_v.elp_skb, ETH_HLEN + NET_IP_ALIGN);\r\nelp_buff = skb_put(hard_iface->bat_v.elp_skb, BATADV_ELP_HLEN);\r\nelp_packet = (struct batadv_elp_packet *)elp_buff;\r\nmemset(elp_packet, 0, BATADV_ELP_HLEN);\r\nelp_packet->packet_type = BATADV_ELP;\r\nelp_packet->version = BATADV_COMPAT_VERSION;\r\nget_random_bytes(&random_seqno, sizeof(random_seqno));\r\natomic_set(&hard_iface->bat_v.elp_seqno, random_seqno);\r\nhard_iface->bat_v.flags |= BATADV_FULL_DUPLEX;\r\nhard_iface->bat_v.flags &= ~BATADV_WARNING_DEFAULT;\r\nif (batadv_is_wifi_netdev(hard_iface->net_dev))\r\nhard_iface->bat_v.flags &= ~BATADV_FULL_DUPLEX;\r\nINIT_DELAYED_WORK(&hard_iface->bat_v.elp_wq,\r\nbatadv_v_elp_periodic_work);\r\nbatadv_v_elp_start_timer(hard_iface);\r\nres = 0;\r\nout:\r\nreturn res;\r\n}\r\nvoid batadv_v_elp_iface_disable(struct batadv_hard_iface *hard_iface)\r\n{\r\ncancel_delayed_work_sync(&hard_iface->bat_v.elp_wq);\r\ndev_kfree_skb(hard_iface->bat_v.elp_skb);\r\nhard_iface->bat_v.elp_skb = NULL;\r\n}\r\nvoid batadv_v_elp_iface_activate(struct batadv_hard_iface *primary_iface,\r\nstruct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_elp_packet *elp_packet;\r\nstruct sk_buff *skb;\r\nif (!hard_iface->bat_v.elp_skb)\r\nreturn;\r\nskb = hard_iface->bat_v.elp_skb;\r\nelp_packet = (struct batadv_elp_packet *)skb->data;\r\nether_addr_copy(elp_packet->orig,\r\nprimary_iface->net_dev->dev_addr);\r\n}\r\nvoid batadv_v_elp_primary_iface_set(struct batadv_hard_iface *primary_iface)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (primary_iface->soft_iface != hard_iface->soft_iface)\r\ncontinue;\r\nbatadv_v_elp_iface_activate(primary_iface, hard_iface);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void batadv_v_elp_neigh_update(struct batadv_priv *bat_priv,\r\nu8 *neigh_addr,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_elp_packet *elp_packet)\r\n{\r\nstruct batadv_neigh_node *neigh;\r\nstruct batadv_orig_node *orig_neigh;\r\nstruct batadv_hardif_neigh_node *hardif_neigh;\r\ns32 seqno_diff;\r\ns32 elp_latest_seqno;\r\norig_neigh = batadv_v_ogm_orig_get(bat_priv, elp_packet->orig);\r\nif (!orig_neigh)\r\nreturn;\r\nneigh = batadv_neigh_node_get_or_create(orig_neigh,\r\nif_incoming, neigh_addr);\r\nif (!neigh)\r\ngoto orig_free;\r\nhardif_neigh = batadv_hardif_neigh_get(if_incoming, neigh_addr);\r\nif (!hardif_neigh)\r\ngoto neigh_free;\r\nelp_latest_seqno = hardif_neigh->bat_v.elp_latest_seqno;\r\nseqno_diff = ntohl(elp_packet->seqno) - elp_latest_seqno;\r\nif (seqno_diff < 1 && seqno_diff > -BATADV_ELP_MAX_AGE)\r\ngoto hardif_free;\r\nneigh->last_seen = jiffies;\r\nhardif_neigh->last_seen = jiffies;\r\nhardif_neigh->bat_v.elp_latest_seqno = ntohl(elp_packet->seqno);\r\nhardif_neigh->bat_v.elp_interval = ntohl(elp_packet->elp_interval);\r\nhardif_free:\r\nif (hardif_neigh)\r\nbatadv_hardif_neigh_put(hardif_neigh);\r\nneigh_free:\r\nif (neigh)\r\nbatadv_neigh_node_put(neigh);\r\norig_free:\r\nif (orig_neigh)\r\nbatadv_orig_node_put(orig_neigh);\r\n}\r\nint batadv_v_elp_packet_recv(struct sk_buff *skb,\r\nstruct batadv_hard_iface *if_incoming)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct batadv_elp_packet *elp_packet;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct ethhdr *ethhdr = (struct ethhdr *)skb_mac_header(skb);\r\nbool ret;\r\nret = batadv_check_management_packet(skb, if_incoming, BATADV_ELP_HLEN);\r\nif (!ret)\r\nreturn NET_RX_DROP;\r\nif (batadv_is_my_mac(bat_priv, ethhdr->h_source))\r\nreturn NET_RX_DROP;\r\nif (strcmp(bat_priv->algo_ops->name, "BATMAN_V") != 0)\r\nreturn NET_RX_DROP;\r\nelp_packet = (struct batadv_elp_packet *)skb->data;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Received ELP packet from %pM seqno %u ORIG: %pM\n",\r\nethhdr->h_source, ntohl(elp_packet->seqno),\r\nelp_packet->orig);\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nbatadv_v_elp_neigh_update(bat_priv, ethhdr->h_source, if_incoming,\r\nelp_packet);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\nconsume_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}
