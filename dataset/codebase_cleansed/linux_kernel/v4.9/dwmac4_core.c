static void dwmac4_core_init(struct mac_device_info *hw, int mtu)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 value = readl(ioaddr + GMAC_CONFIG);\r\nvalue |= GMAC_CORE_INIT;\r\nif (mtu > 1500)\r\nvalue |= GMAC_CONFIG_2K;\r\nif (mtu > 2000)\r\nvalue |= GMAC_CONFIG_JE;\r\nif (hw->ps) {\r\nvalue |= GMAC_CONFIG_TE;\r\nif (hw->ps == SPEED_1000) {\r\nvalue &= ~GMAC_CONFIG_PS;\r\n} else {\r\nvalue |= GMAC_CONFIG_PS;\r\nif (hw->ps == SPEED_10)\r\nvalue &= ~GMAC_CONFIG_FES;\r\nelse\r\nvalue |= GMAC_CONFIG_FES;\r\n}\r\n}\r\nwritel(value, ioaddr + GMAC_CONFIG);\r\nvalue = GMAC_INT_DEFAULT_MASK;\r\nif (hw->pmt)\r\nvalue |= GMAC_INT_PMT_EN;\r\nif (hw->pcs)\r\nvalue |= GMAC_PCS_IRQ_DEFAULT;\r\nwritel(value, ioaddr + GMAC_INT_EN);\r\n}\r\nstatic void dwmac4_dump_regs(struct mac_device_info *hw)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nint i;\r\npr_debug("\tDWMAC4 regs (base addr = 0x%p)\n", ioaddr);\r\nfor (i = 0; i < GMAC_REG_NUM; i++) {\r\nint offset = i * 4;\r\npr_debug("\tReg No. %d (offset 0x%x): 0x%08x\n", i,\r\noffset, readl(ioaddr + offset));\r\n}\r\n}\r\nstatic int dwmac4_rx_ipc_enable(struct mac_device_info *hw)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 value = readl(ioaddr + GMAC_CONFIG);\r\nif (hw->rx_csum)\r\nvalue |= GMAC_CONFIG_IPC;\r\nelse\r\nvalue &= ~GMAC_CONFIG_IPC;\r\nwritel(value, ioaddr + GMAC_CONFIG);\r\nvalue = readl(ioaddr + GMAC_CONFIG);\r\nreturn !!(value & GMAC_CONFIG_IPC);\r\n}\r\nstatic void dwmac4_pmt(struct mac_device_info *hw, unsigned long mode)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nunsigned int pmt = 0;\r\nif (mode & WAKE_MAGIC) {\r\npr_debug("GMAC: WOL Magic frame\n");\r\npmt |= power_down | magic_pkt_en;\r\n}\r\nif (mode & WAKE_UCAST) {\r\npr_debug("GMAC: WOL on global unicast\n");\r\npmt |= power_down | global_unicast | wake_up_frame_en;\r\n}\r\nwritel(pmt, ioaddr + GMAC_PMT);\r\n}\r\nstatic void dwmac4_set_umac_addr(struct mac_device_info *hw,\r\nunsigned char *addr, unsigned int reg_n)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nstmmac_dwmac4_set_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),\r\nGMAC_ADDR_LOW(reg_n));\r\n}\r\nstatic void dwmac4_get_umac_addr(struct mac_device_info *hw,\r\nunsigned char *addr, unsigned int reg_n)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nstmmac_dwmac4_get_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),\r\nGMAC_ADDR_LOW(reg_n));\r\n}\r\nstatic void dwmac4_set_filter(struct mac_device_info *hw,\r\nstruct net_device *dev)\r\n{\r\nvoid __iomem *ioaddr = (void __iomem *)dev->base_addr;\r\nunsigned int value = 0;\r\nif (dev->flags & IFF_PROMISC) {\r\nvalue = GMAC_PACKET_FILTER_PR;\r\n} else if ((dev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(dev) > HASH_TABLE_SIZE)) {\r\nvalue = GMAC_PACKET_FILTER_PM;\r\nwritel(0xffffffff, ioaddr + GMAC_HASH_TAB_0_31);\r\nwritel(0xffffffff, ioaddr + GMAC_HASH_TAB_32_63);\r\n} else if (!netdev_mc_empty(dev)) {\r\nu32 mc_filter[2];\r\nstruct netdev_hw_addr *ha;\r\nvalue = GMAC_PACKET_FILTER_HMC;\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr =\r\n(bitrev32(~crc32_le(~0, ha->addr, 6)) >> 26);\r\nmc_filter[bit_nr >> 5] |= (1 << (bit_nr & 0x1F));\r\n}\r\nwritel(mc_filter[0], ioaddr + GMAC_HASH_TAB_0_31);\r\nwritel(mc_filter[1], ioaddr + GMAC_HASH_TAB_32_63);\r\n}\r\nif (netdev_uc_count(dev) > GMAC_MAX_PERFECT_ADDRESSES) {\r\nvalue |= GMAC_PACKET_FILTER_PR;\r\n} else if (!netdev_uc_empty(dev)) {\r\nint reg = 1;\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_uc_addr(ha, dev) {\r\ndwmac4_set_umac_addr(hw, ha->addr, reg);\r\nreg++;\r\n}\r\n}\r\nwritel(value, ioaddr + GMAC_PACKET_FILTER);\r\n}\r\nstatic void dwmac4_flow_ctrl(struct mac_device_info *hw, unsigned int duplex,\r\nunsigned int fc, unsigned int pause_time)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 channel = STMMAC_CHAN0;\r\nunsigned int flow = 0;\r\npr_debug("GMAC Flow-Control:\n");\r\nif (fc & FLOW_RX) {\r\npr_debug("\tReceive Flow-Control ON\n");\r\nflow |= GMAC_RX_FLOW_CTRL_RFE;\r\nwritel(flow, ioaddr + GMAC_RX_FLOW_CTRL);\r\n}\r\nif (fc & FLOW_TX) {\r\npr_debug("\tTransmit Flow-Control ON\n");\r\nflow |= GMAC_TX_FLOW_CTRL_TFE;\r\nwritel(flow, ioaddr + GMAC_QX_TX_FLOW_CTRL(channel));\r\nif (duplex) {\r\npr_debug("\tduplex mode: PAUSE %d\n", pause_time);\r\nflow |= (pause_time << GMAC_TX_FLOW_CTRL_PT_SHIFT);\r\nwritel(flow, ioaddr + GMAC_QX_TX_FLOW_CTRL(channel));\r\n}\r\n}\r\n}\r\nstatic void dwmac4_ctrl_ane(void __iomem *ioaddr, bool ane, bool srgmi_ral,\r\nbool loopback)\r\n{\r\ndwmac_ctrl_ane(ioaddr, GMAC_PCS_BASE, ane, srgmi_ral, loopback);\r\n}\r\nstatic void dwmac4_rane(void __iomem *ioaddr, bool restart)\r\n{\r\ndwmac_rane(ioaddr, GMAC_PCS_BASE, restart);\r\n}\r\nstatic void dwmac4_get_adv_lp(void __iomem *ioaddr, struct rgmii_adv *adv)\r\n{\r\ndwmac_get_adv_lp(ioaddr, GMAC_PCS_BASE, adv);\r\n}\r\nstatic void dwmac4_phystatus(void __iomem *ioaddr, struct stmmac_extra_stats *x)\r\n{\r\nu32 status;\r\nstatus = readl(ioaddr + GMAC_PHYIF_CONTROL_STATUS);\r\nx->irq_rgmii_n++;\r\nif (status & GMAC_PHYIF_CTRLSTATUS_LNKSTS) {\r\nint speed_value;\r\nx->pcs_link = 1;\r\nspeed_value = ((status & GMAC_PHYIF_CTRLSTATUS_SPEED) >>\r\nGMAC_PHYIF_CTRLSTATUS_SPEED_SHIFT);\r\nif (speed_value == GMAC_PHYIF_CTRLSTATUS_SPEED_125)\r\nx->pcs_speed = SPEED_1000;\r\nelse if (speed_value == GMAC_PHYIF_CTRLSTATUS_SPEED_25)\r\nx->pcs_speed = SPEED_100;\r\nelse\r\nx->pcs_speed = SPEED_10;\r\nx->pcs_duplex = (status & GMAC_PHYIF_CTRLSTATUS_LNKMOD_MASK);\r\npr_info("Link is Up - %d/%s\n", (int)x->pcs_speed,\r\nx->pcs_duplex ? "Full" : "Half");\r\n} else {\r\nx->pcs_link = 0;\r\npr_info("Link is Down\n");\r\n}\r\n}\r\nstatic int dwmac4_irq_status(struct mac_device_info *hw,\r\nstruct stmmac_extra_stats *x)\r\n{\r\nvoid __iomem *ioaddr = hw->pcsr;\r\nu32 mtl_int_qx_status;\r\nu32 intr_status;\r\nint ret = 0;\r\nintr_status = readl(ioaddr + GMAC_INT_STATUS);\r\nif ((intr_status & mmc_tx_irq))\r\nx->mmc_tx_irq_n++;\r\nif (unlikely(intr_status & mmc_rx_irq))\r\nx->mmc_rx_irq_n++;\r\nif (unlikely(intr_status & mmc_rx_csum_offload_irq))\r\nx->mmc_rx_csum_offload_irq_n++;\r\nif (unlikely(intr_status & pmt_irq)) {\r\nreadl(ioaddr + GMAC_PMT);\r\nx->irq_receive_pmt_irq_n++;\r\n}\r\nmtl_int_qx_status = readl(ioaddr + MTL_INT_STATUS);\r\nif (mtl_int_qx_status & MTL_INT_Q0) {\r\nu32 status = readl(ioaddr + MTL_CHAN_INT_CTRL(STMMAC_CHAN0));\r\nif (status & MTL_RX_OVERFLOW_INT) {\r\nwritel(status | MTL_RX_OVERFLOW_INT,\r\nioaddr + MTL_CHAN_INT_CTRL(STMMAC_CHAN0));\r\nret = CORE_IRQ_MTL_RX_OVERFLOW;\r\n}\r\n}\r\ndwmac_pcs_isr(ioaddr, GMAC_PCS_BASE, intr_status, x);\r\nif (intr_status & PCS_RGSMIIIS_IRQ)\r\ndwmac4_phystatus(ioaddr, x);\r\nreturn ret;\r\n}\r\nstatic void dwmac4_debug(void __iomem *ioaddr, struct stmmac_extra_stats *x)\r\n{\r\nu32 value;\r\nvalue = readl(ioaddr + MTL_CHAN_TX_DEBUG(STMMAC_CHAN0));\r\nif (value & MTL_DEBUG_TXSTSFSTS)\r\nx->mtl_tx_status_fifo_full++;\r\nif (value & MTL_DEBUG_TXFSTS)\r\nx->mtl_tx_fifo_not_empty++;\r\nif (value & MTL_DEBUG_TWCSTS)\r\nx->mmtl_fifo_ctrl++;\r\nif (value & MTL_DEBUG_TRCSTS_MASK) {\r\nu32 trcsts = (value & MTL_DEBUG_TRCSTS_MASK)\r\n>> MTL_DEBUG_TRCSTS_SHIFT;\r\nif (trcsts == MTL_DEBUG_TRCSTS_WRITE)\r\nx->mtl_tx_fifo_read_ctrl_write++;\r\nelse if (trcsts == MTL_DEBUG_TRCSTS_TXW)\r\nx->mtl_tx_fifo_read_ctrl_wait++;\r\nelse if (trcsts == MTL_DEBUG_TRCSTS_READ)\r\nx->mtl_tx_fifo_read_ctrl_read++;\r\nelse\r\nx->mtl_tx_fifo_read_ctrl_idle++;\r\n}\r\nif (value & MTL_DEBUG_TXPAUSED)\r\nx->mac_tx_in_pause++;\r\nvalue = readl(ioaddr + MTL_CHAN_RX_DEBUG(STMMAC_CHAN0));\r\nif (value & MTL_DEBUG_RXFSTS_MASK) {\r\nu32 rxfsts = (value & MTL_DEBUG_RXFSTS_MASK)\r\n>> MTL_DEBUG_RRCSTS_SHIFT;\r\nif (rxfsts == MTL_DEBUG_RXFSTS_FULL)\r\nx->mtl_rx_fifo_fill_level_full++;\r\nelse if (rxfsts == MTL_DEBUG_RXFSTS_AT)\r\nx->mtl_rx_fifo_fill_above_thresh++;\r\nelse if (rxfsts == MTL_DEBUG_RXFSTS_BT)\r\nx->mtl_rx_fifo_fill_below_thresh++;\r\nelse\r\nx->mtl_rx_fifo_fill_level_empty++;\r\n}\r\nif (value & MTL_DEBUG_RRCSTS_MASK) {\r\nu32 rrcsts = (value & MTL_DEBUG_RRCSTS_MASK) >>\r\nMTL_DEBUG_RRCSTS_SHIFT;\r\nif (rrcsts == MTL_DEBUG_RRCSTS_FLUSH)\r\nx->mtl_rx_fifo_read_ctrl_flush++;\r\nelse if (rrcsts == MTL_DEBUG_RRCSTS_RSTAT)\r\nx->mtl_rx_fifo_read_ctrl_read_data++;\r\nelse if (rrcsts == MTL_DEBUG_RRCSTS_RDATA)\r\nx->mtl_rx_fifo_read_ctrl_status++;\r\nelse\r\nx->mtl_rx_fifo_read_ctrl_idle++;\r\n}\r\nif (value & MTL_DEBUG_RWCSTS)\r\nx->mtl_rx_fifo_ctrl_active++;\r\nvalue = readl(ioaddr + GMAC_DEBUG);\r\nif (value & GMAC_DEBUG_TFCSTS_MASK) {\r\nu32 tfcsts = (value & GMAC_DEBUG_TFCSTS_MASK)\r\n>> GMAC_DEBUG_TFCSTS_SHIFT;\r\nif (tfcsts == GMAC_DEBUG_TFCSTS_XFER)\r\nx->mac_tx_frame_ctrl_xfer++;\r\nelse if (tfcsts == GMAC_DEBUG_TFCSTS_GEN_PAUSE)\r\nx->mac_tx_frame_ctrl_pause++;\r\nelse if (tfcsts == GMAC_DEBUG_TFCSTS_WAIT)\r\nx->mac_tx_frame_ctrl_wait++;\r\nelse\r\nx->mac_tx_frame_ctrl_idle++;\r\n}\r\nif (value & GMAC_DEBUG_TPESTS)\r\nx->mac_gmii_tx_proto_engine++;\r\nif (value & GMAC_DEBUG_RFCFCSTS_MASK)\r\nx->mac_rx_frame_ctrl_fifo = (value & GMAC_DEBUG_RFCFCSTS_MASK)\r\n>> GMAC_DEBUG_RFCFCSTS_SHIFT;\r\nif (value & GMAC_DEBUG_RPESTS)\r\nx->mac_gmii_rx_proto_engine++;\r\n}\r\nstruct mac_device_info *dwmac4_setup(void __iomem *ioaddr, int mcbins,\r\nint perfect_uc_entries, int *synopsys_id)\r\n{\r\nstruct mac_device_info *mac;\r\nu32 hwid = readl(ioaddr + GMAC_VERSION);\r\nmac = kzalloc(sizeof(const struct mac_device_info), GFP_KERNEL);\r\nif (!mac)\r\nreturn NULL;\r\nmac->pcsr = ioaddr;\r\nmac->multicast_filter_bins = mcbins;\r\nmac->unicast_filter_entries = perfect_uc_entries;\r\nmac->mcast_bits_log2 = 0;\r\nif (mac->multicast_filter_bins)\r\nmac->mcast_bits_log2 = ilog2(mac->multicast_filter_bins);\r\nmac->mac = &dwmac4_ops;\r\nmac->link.port = GMAC_CONFIG_PS;\r\nmac->link.duplex = GMAC_CONFIG_DM;\r\nmac->link.speed = GMAC_CONFIG_FES;\r\nmac->mii.addr = GMAC_MDIO_ADDR;\r\nmac->mii.data = GMAC_MDIO_DATA;\r\n*synopsys_id = stmmac_get_synopsys_id(hwid);\r\nif (*synopsys_id > DWMAC_CORE_4_00)\r\nmac->dma = &dwmac410_dma_ops;\r\nelse\r\nmac->dma = &dwmac4_dma_ops;\r\nreturn mac;\r\n}
