static int name_card(struct snd_dg00x *dg00x)\r\n{\r\nstruct fw_device *fw_dev = fw_parent_device(dg00x->unit);\r\nchar name[32] = {0};\r\nchar *model;\r\nint err;\r\nerr = fw_csr_string(dg00x->unit->directory, CSR_MODEL, name,\r\nsizeof(name));\r\nif (err < 0)\r\nreturn err;\r\nmodel = skip_spaces(name);\r\nstrcpy(dg00x->card->driver, "Digi00x");\r\nstrcpy(dg00x->card->shortname, model);\r\nstrcpy(dg00x->card->mixername, model);\r\nsnprintf(dg00x->card->longname, sizeof(dg00x->card->longname),\r\n"Digidesign %s, GUID %08x%08x at %s, S%d", model,\r\nfw_dev->config_rom[3], fw_dev->config_rom[4],\r\ndev_name(&dg00x->unit->device), 100 << fw_dev->max_speed);\r\nreturn 0;\r\n}\r\nstatic void dg00x_free(struct snd_dg00x *dg00x)\r\n{\r\nsnd_dg00x_stream_destroy_duplex(dg00x);\r\nsnd_dg00x_transaction_unregister(dg00x);\r\nfw_unit_put(dg00x->unit);\r\nmutex_destroy(&dg00x->mutex);\r\n}\r\nstatic void dg00x_card_free(struct snd_card *card)\r\n{\r\ndg00x_free(card->private_data);\r\n}\r\nstatic void do_registration(struct work_struct *work)\r\n{\r\nstruct snd_dg00x *dg00x =\r\ncontainer_of(work, struct snd_dg00x, dwork.work);\r\nint err;\r\nif (dg00x->registered)\r\nreturn;\r\nerr = snd_card_new(&dg00x->unit->device, -1, NULL, THIS_MODULE, 0,\r\n&dg00x->card);\r\nif (err < 0)\r\nreturn;\r\nerr = name_card(dg00x);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dg00x_stream_init_duplex(dg00x);\r\nif (err < 0)\r\ngoto error;\r\nsnd_dg00x_proc_init(dg00x);\r\nerr = snd_dg00x_create_pcm_devices(dg00x);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dg00x_create_midi_devices(dg00x);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dg00x_create_hwdep_device(dg00x);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dg00x_transaction_register(dg00x);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(dg00x->card);\r\nif (err < 0)\r\ngoto error;\r\ndg00x->card->private_free = dg00x_card_free;\r\ndg00x->card->private_data = dg00x;\r\ndg00x->registered = true;\r\nreturn;\r\nerror:\r\nsnd_dg00x_transaction_unregister(dg00x);\r\nsnd_dg00x_stream_destroy_duplex(dg00x);\r\nsnd_card_free(dg00x->card);\r\ndev_info(&dg00x->unit->device,\r\n"Sound card registration failed: %d\n", err);\r\n}\r\nstatic int snd_dg00x_probe(struct fw_unit *unit,\r\nconst struct ieee1394_device_id *entry)\r\n{\r\nstruct snd_dg00x *dg00x;\r\ndg00x = kzalloc(sizeof(struct snd_dg00x), GFP_KERNEL);\r\nif (dg00x == NULL)\r\nreturn -ENOMEM;\r\ndg00x->unit = fw_unit_get(unit);\r\ndev_set_drvdata(&unit->device, dg00x);\r\nmutex_init(&dg00x->mutex);\r\nspin_lock_init(&dg00x->lock);\r\ninit_waitqueue_head(&dg00x->hwdep_wait);\r\nINIT_DEFERRABLE_WORK(&dg00x->dwork, do_registration);\r\nsnd_fw_schedule_registration(unit, &dg00x->dwork);\r\nreturn 0;\r\n}\r\nstatic void snd_dg00x_update(struct fw_unit *unit)\r\n{\r\nstruct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);\r\nif (!dg00x->registered)\r\nsnd_fw_schedule_registration(unit, &dg00x->dwork);\r\nsnd_dg00x_transaction_reregister(dg00x);\r\nif (dg00x->registered) {\r\nmutex_lock(&dg00x->mutex);\r\nsnd_dg00x_stream_update_duplex(dg00x);\r\nmutex_unlock(&dg00x->mutex);\r\n}\r\n}\r\nstatic void snd_dg00x_remove(struct fw_unit *unit)\r\n{\r\nstruct snd_dg00x *dg00x = dev_get_drvdata(&unit->device);\r\ncancel_delayed_work_sync(&dg00x->dwork);\r\nif (dg00x->registered) {\r\nsnd_card_free_when_closed(dg00x->card);\r\n} else {\r\ndg00x_free(dg00x);\r\n}\r\n}\r\nstatic int __init snd_dg00x_init(void)\r\n{\r\nreturn driver_register(&dg00x_driver.driver);\r\n}\r\nstatic void __exit snd_dg00x_exit(void)\r\n{\r\ndriver_unregister(&dg00x_driver.driver);\r\n}
