struct cpio_data find_cpio_data(const char *path, void *data,\r\nsize_t len, long *nextoff)\r\n{\r\nconst size_t cpio_header_len = 8*C_NFIELDS - 2;\r\nstruct cpio_data cd = { NULL, 0, "" };\r\nconst char *p, *dptr, *nptr;\r\nunsigned int ch[C_NFIELDS], *chp, v;\r\nunsigned char c, x;\r\nsize_t mypathsize = strlen(path);\r\nint i, j;\r\np = data;\r\nwhile (len > cpio_header_len) {\r\nif (!*p) {\r\np += 4;\r\nlen -= 4;\r\ncontinue;\r\n}\r\nj = 6;\r\nchp = ch;\r\nfor (i = C_NFIELDS; i; i--) {\r\nv = 0;\r\nwhile (j--) {\r\nv <<= 4;\r\nc = *p++;\r\nx = c - '0';\r\nif (x < 10) {\r\nv += x;\r\ncontinue;\r\n}\r\nx = (c | 0x20) - 'a';\r\nif (x < 6) {\r\nv += x + 10;\r\ncontinue;\r\n}\r\ngoto quit;\r\n}\r\n*chp++ = v;\r\nj = 8;\r\n}\r\nif ((ch[C_MAGIC] - 0x070701) > 1)\r\ngoto quit;\r\nlen -= cpio_header_len;\r\ndptr = PTR_ALIGN(p + ch[C_NAMESIZE], 4);\r\nnptr = PTR_ALIGN(dptr + ch[C_FILESIZE], 4);\r\nif (nptr > p + len || dptr < p || nptr < dptr)\r\ngoto quit;\r\nif ((ch[C_MODE] & 0170000) == 0100000 &&\r\nch[C_NAMESIZE] >= mypathsize &&\r\n!memcmp(p, path, mypathsize)) {\r\nif (nextoff)\r\n*nextoff = (long)nptr - (long)data;\r\nif (ch[C_NAMESIZE] - mypathsize >= MAX_CPIO_FILE_NAME) {\r\npr_warn(\r\n"File %s exceeding MAX_CPIO_FILE_NAME [%d]\n",\r\np, MAX_CPIO_FILE_NAME);\r\n}\r\nstrlcpy(cd.name, p + mypathsize, MAX_CPIO_FILE_NAME);\r\ncd.data = (void *)dptr;\r\ncd.size = ch[C_FILESIZE];\r\nreturn cd;\r\n}\r\nlen -= (nptr - p);\r\np = nptr;\r\n}\r\nquit:\r\nreturn cd;\r\n}
