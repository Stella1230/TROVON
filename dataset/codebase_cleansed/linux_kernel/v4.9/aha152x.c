static inline void\r\nCMD_INC_RESID(struct scsi_cmnd *cmd, int inc)\r\n{\r\nscsi_set_resid(cmd, scsi_get_resid(cmd) + inc);\r\n}\r\nstatic inline void append_SC(Scsi_Cmnd **SC, Scsi_Cmnd *new_SC)\r\n{\r\nScsi_Cmnd *end;\r\nSCNEXT(new_SC) = NULL;\r\nif (!*SC)\r\n*SC = new_SC;\r\nelse {\r\nfor (end = *SC; SCNEXT(end); end = SCNEXT(end))\r\n;\r\nSCNEXT(end) = new_SC;\r\n}\r\n}\r\nstatic inline Scsi_Cmnd *remove_first_SC(Scsi_Cmnd ** SC)\r\n{\r\nScsi_Cmnd *ptr;\r\nptr = *SC;\r\nif (ptr) {\r\n*SC = SCNEXT(*SC);\r\nSCNEXT(ptr)=NULL;\r\n}\r\nreturn ptr;\r\n}\r\nstatic inline Scsi_Cmnd *remove_lun_SC(Scsi_Cmnd ** SC, int target, int lun)\r\n{\r\nScsi_Cmnd *ptr, *prev;\r\nfor (ptr = *SC, prev = NULL;\r\nptr && ((ptr->device->id != target) || (ptr->device->lun != lun));\r\nprev = ptr, ptr = SCNEXT(ptr))\r\n;\r\nif (ptr) {\r\nif (prev)\r\nSCNEXT(prev) = SCNEXT(ptr);\r\nelse\r\n*SC = SCNEXT(ptr);\r\nSCNEXT(ptr)=NULL;\r\n}\r\nreturn ptr;\r\n}\r\nstatic inline Scsi_Cmnd *remove_SC(Scsi_Cmnd **SC, Scsi_Cmnd *SCp)\r\n{\r\nScsi_Cmnd *ptr, *prev;\r\nfor (ptr = *SC, prev = NULL;\r\nptr && SCp!=ptr;\r\nprev = ptr, ptr = SCNEXT(ptr))\r\n;\r\nif (ptr) {\r\nif (prev)\r\nSCNEXT(prev) = SCNEXT(ptr);\r\nelse\r\n*SC = SCNEXT(ptr);\r\nSCNEXT(ptr)=NULL;\r\n}\r\nreturn ptr;\r\n}\r\nstatic irqreturn_t swintr(int irqno, void *dev_id)\r\n{\r\nstruct Scsi_Host *shpnt = dev_id;\r\nHOSTDATA(shpnt)->swint++;\r\nSETPORT(DMACNTRL0, INTEN);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct Scsi_Host *aha152x_probe_one(struct aha152x_setup *setup)\r\n{\r\nstruct Scsi_Host *shpnt;\r\nshpnt = scsi_host_alloc(&aha152x_driver_template, sizeof(struct aha152x_hostdata));\r\nif (!shpnt) {\r\nprintk(KERN_ERR "aha152x: scsi_host_alloc failed\n");\r\nreturn NULL;\r\n}\r\nmemset(HOSTDATA(shpnt), 0, sizeof *HOSTDATA(shpnt));\r\nINIT_LIST_HEAD(&HOSTDATA(shpnt)->host_list);\r\nlist_add_tail(&HOSTDATA(shpnt)->host_list, &aha152x_host_list);\r\nshpnt->io_port = setup->io_port;\r\nshpnt->n_io_port = IO_RANGE;\r\nshpnt->irq = setup->irq;\r\nif (!setup->tc1550) {\r\nHOSTIOPORT0 = setup->io_port;\r\nHOSTIOPORT1 = setup->io_port;\r\n} else {\r\nHOSTIOPORT0 = setup->io_port+0x10;\r\nHOSTIOPORT1 = setup->io_port-0x10;\r\n}\r\nspin_lock_init(&QLOCK);\r\nRECONNECT = setup->reconnect;\r\nSYNCHRONOUS = setup->synchronous;\r\nPARITY = setup->parity;\r\nDELAY = setup->delay;\r\nEXT_TRANS = setup->ext_trans;\r\nSETPORT(SCSIID, setup->scsiid << 4);\r\nshpnt->this_id = setup->scsiid;\r\nif (setup->reconnect)\r\nshpnt->can_queue = AHA152X_MAXQUEUE;\r\nprintk("aha152x: resetting bus...\n");\r\nSETPORT(SCSISEQ, SCSIRSTO);\r\nmdelay(256);\r\nSETPORT(SCSISEQ, 0);\r\nmdelay(DELAY);\r\nreset_ports(shpnt);\r\nprintk(KERN_INFO\r\n"aha152x%d%s: "\r\n"vital data: rev=%x, "\r\n"io=0x%03lx (0x%03lx/0x%03lx), "\r\n"irq=%d, "\r\n"scsiid=%d, "\r\n"reconnect=%s, "\r\n"parity=%s, "\r\n"synchronous=%s, "\r\n"delay=%d, "\r\n"extended translation=%s\n",\r\nshpnt->host_no, setup->tc1550 ? " (tc1550 mode)" : "",\r\nGETPORT(REV) & 0x7,\r\nshpnt->io_port, HOSTIOPORT0, HOSTIOPORT1,\r\nshpnt->irq,\r\nshpnt->this_id,\r\nRECONNECT ? "enabled" : "disabled",\r\nPARITY ? "enabled" : "disabled",\r\nSYNCHRONOUS ? "enabled" : "disabled",\r\nDELAY,\r\nEXT_TRANS ? "enabled" : "disabled");\r\nSETPORT(SIMODE0, 0);\r\nSETPORT(SIMODE1, 0);\r\nif (request_irq(shpnt->irq, swintr, IRQF_SHARED, "aha152x", shpnt)) {\r\nprintk(KERN_ERR "aha152x%d: irq %d busy.\n", shpnt->host_no, shpnt->irq);\r\ngoto out_host_put;\r\n}\r\nHOSTDATA(shpnt)->swint = 0;\r\nprintk(KERN_INFO "aha152x%d: trying software interrupt, ", shpnt->host_no);\r\nmb();\r\nSETPORT(DMACNTRL0, SWINT|INTEN);\r\nmdelay(1000);\r\nfree_irq(shpnt->irq, shpnt);\r\nif (!HOSTDATA(shpnt)->swint) {\r\nif (TESTHI(DMASTAT, INTSTAT)) {\r\nprintk("lost.\n");\r\n} else {\r\nprintk("failed.\n");\r\n}\r\nSETPORT(DMACNTRL0, INTEN);\r\nprintk(KERN_ERR "aha152x%d: irq %d possibly wrong. "\r\n"Please verify.\n", shpnt->host_no, shpnt->irq);\r\ngoto out_host_put;\r\n}\r\nprintk("ok.\n");\r\nSETPORT(SSTAT0, 0x7f);\r\nSETPORT(SSTAT1, 0xef);\r\nif (request_irq(shpnt->irq, intr, IRQF_SHARED, "aha152x", shpnt)) {\r\nprintk(KERN_ERR "aha152x%d: failed to reassign irq %d.\n", shpnt->host_no, shpnt->irq);\r\ngoto out_host_put;\r\n}\r\nif( scsi_add_host(shpnt, NULL) ) {\r\nfree_irq(shpnt->irq, shpnt);\r\nprintk(KERN_ERR "aha152x%d: failed to add host.\n", shpnt->host_no);\r\ngoto out_host_put;\r\n}\r\nscsi_scan_host(shpnt);\r\nreturn shpnt;\r\nout_host_put:\r\nlist_del(&HOSTDATA(shpnt)->host_list);\r\nscsi_host_put(shpnt);\r\nreturn NULL;\r\n}\r\nvoid aha152x_release(struct Scsi_Host *shpnt)\r\n{\r\nif (!shpnt)\r\nreturn;\r\nscsi_remove_host(shpnt);\r\nif (shpnt->irq)\r\nfree_irq(shpnt->irq, shpnt);\r\n#if !defined(PCMCIA)\r\nif (shpnt->io_port)\r\nrelease_region(shpnt->io_port, IO_RANGE);\r\n#endif\r\n#ifdef __ISAPNP__\r\nif (HOSTDATA(shpnt)->pnpdev)\r\npnp_device_detach(HOSTDATA(shpnt)->pnpdev);\r\n#endif\r\nlist_del(&HOSTDATA(shpnt)->host_list);\r\nscsi_host_put(shpnt);\r\n}\r\nstatic int setup_expected_interrupts(struct Scsi_Host *shpnt)\r\n{\r\nif(CURRENT_SC) {\r\nCURRENT_SC->SCp.phase |= 1 << 16;\r\nif(CURRENT_SC->SCp.phase & selecting) {\r\nSETPORT(SSTAT1, SELTO);\r\nSETPORT(SIMODE0, ENSELDO | (DISCONNECTED_SC ? ENSELDI : 0));\r\nSETPORT(SIMODE1, ENSELTIMO);\r\n} else {\r\nSETPORT(SIMODE0, (CURRENT_SC->SCp.phase & spiordy) ? ENSPIORDY : 0);\r\nSETPORT(SIMODE1, ENPHASEMIS | ENSCSIRST | ENSCSIPERR | ENBUSFREE);\r\n}\r\n} else if(STATE==seldi) {\r\nSETPORT(SIMODE0, 0);\r\nSETPORT(SIMODE1, ENPHASEMIS | ENSCSIRST | ENSCSIPERR | ENBUSFREE);\r\n} else {\r\nSETPORT(SIMODE0, DISCONNECTED_SC ? ENSELDI : 0);\r\nSETPORT(SIMODE1, ENSCSIRST | ( (ISSUE_SC||DONE_SC) ? ENBUSFREE : 0));\r\n}\r\nif(!HOSTDATA(shpnt)->in_intr)\r\nSETBITS(DMACNTRL0, INTEN);\r\nreturn TESTHI(DMASTAT, INTSTAT);\r\n}\r\nstatic int aha152x_internal_queue(Scsi_Cmnd *SCpnt, struct completion *complete,\r\nint phase, void (*done)(Scsi_Cmnd *))\r\n{\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nunsigned long flags;\r\nSCpnt->scsi_done = done;\r\nSCpnt->SCp.phase = not_issued | phase;\r\nSCpnt->SCp.Status = 0x1;\r\nSCpnt->SCp.Message = 0;\r\nSCpnt->SCp.have_data_in = 0;\r\nSCpnt->SCp.sent_command = 0;\r\nif(SCpnt->SCp.phase & (resetting|check_condition)) {\r\nif (!SCpnt->host_scribble || SCSEM(SCpnt) || SCNEXT(SCpnt)) {\r\nscmd_printk(KERN_ERR, SCpnt, "cannot reuse command\n");\r\nreturn FAILED;\r\n}\r\n} else {\r\nSCpnt->host_scribble = kmalloc(sizeof(struct aha152x_scdata), GFP_ATOMIC);\r\nif(!SCpnt->host_scribble) {\r\nscmd_printk(KERN_ERR, SCpnt, "allocation failed\n");\r\nreturn FAILED;\r\n}\r\n}\r\nSCNEXT(SCpnt) = NULL;\r\nSCSEM(SCpnt) = complete;\r\nif ((phase & resetting) || !scsi_sglist(SCpnt)) {\r\nSCpnt->SCp.ptr = NULL;\r\nSCpnt->SCp.this_residual = 0;\r\nscsi_set_resid(SCpnt, 0);\r\nSCpnt->SCp.buffer = NULL;\r\nSCpnt->SCp.buffers_residual = 0;\r\n} else {\r\nscsi_set_resid(SCpnt, scsi_bufflen(SCpnt));\r\nSCpnt->SCp.buffer = scsi_sglist(SCpnt);\r\nSCpnt->SCp.ptr = SG_ADDRESS(SCpnt->SCp.buffer);\r\nSCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;\r\nSCpnt->SCp.buffers_residual = scsi_sg_count(SCpnt) - 1;\r\n}\r\nDO_LOCK(flags);\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->total_commands++;\r\n#endif\r\nHOSTDATA(shpnt)->commands++;\r\nif (HOSTDATA(shpnt)->commands==1)\r\nSETPORT(PORTA, 1);\r\nappend_SC(&ISSUE_SC, SCpnt);\r\nif(!HOSTDATA(shpnt)->in_intr)\r\nsetup_expected_interrupts(shpnt);\r\nDO_UNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic int aha152x_queue_lck(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))\r\n{\r\nreturn aha152x_internal_queue(SCpnt, NULL, 0, done);\r\n}\r\nint aha152x_abort(Scsi_Cmnd *SCpnt)\r\n{\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nScsi_Cmnd *ptr;\r\nunsigned long flags;\r\nDO_LOCK(flags);\r\nptr=remove_SC(&ISSUE_SC, SCpnt);\r\nif(ptr) {\r\nHOSTDATA(shpnt)->commands--;\r\nif (!HOSTDATA(shpnt)->commands)\r\nSETPORT(PORTA, 0);\r\nDO_UNLOCK(flags);\r\nkfree(SCpnt->host_scribble);\r\nSCpnt->host_scribble=NULL;\r\nreturn SUCCESS;\r\n}\r\nDO_UNLOCK(flags);\r\nscmd_printk(KERN_ERR, SCpnt,\r\n"cannot abort running or disconnected command\n");\r\nreturn FAILED;\r\n}\r\nstatic int aha152x_device_reset(Scsi_Cmnd * SCpnt)\r\n{\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nDECLARE_COMPLETION(done);\r\nint ret, issued, disconnected;\r\nunsigned char old_cmd_len = SCpnt->cmd_len;\r\nunsigned long flags;\r\nunsigned long timeleft;\r\nif(CURRENT_SC==SCpnt) {\r\nscmd_printk(KERN_ERR, SCpnt, "cannot reset current device\n");\r\nreturn FAILED;\r\n}\r\nDO_LOCK(flags);\r\nissued = remove_SC(&ISSUE_SC, SCpnt) == NULL;\r\ndisconnected = issued && remove_SC(&DISCONNECTED_SC, SCpnt);\r\nDO_UNLOCK(flags);\r\nSCpnt->cmd_len = 0;\r\naha152x_internal_queue(SCpnt, &done, resetting, reset_done);\r\ntimeleft = wait_for_completion_timeout(&done, 100*HZ);\r\nif (!timeleft) {\r\nDO_LOCK(flags);\r\nremove_SC(&ISSUE_SC, SCpnt);\r\nDO_UNLOCK(flags);\r\n}\r\nSCpnt->cmd_len = old_cmd_len;\r\nDO_LOCK(flags);\r\nif(SCpnt->SCp.phase & resetted) {\r\nHOSTDATA(shpnt)->commands--;\r\nif (!HOSTDATA(shpnt)->commands)\r\nSETPORT(PORTA, 0);\r\nkfree(SCpnt->host_scribble);\r\nSCpnt->host_scribble=NULL;\r\nret = SUCCESS;\r\n} else {\r\nif(!issued) {\r\nappend_SC(&ISSUE_SC, SCpnt);\r\n} else if(disconnected) {\r\nappend_SC(&DISCONNECTED_SC, SCpnt);\r\n}\r\nret = FAILED;\r\n}\r\nDO_UNLOCK(flags);\r\nreturn ret;\r\n}\r\nstatic void free_hard_reset_SCs(struct Scsi_Host *shpnt, Scsi_Cmnd **SCs)\r\n{\r\nScsi_Cmnd *ptr;\r\nptr=*SCs;\r\nwhile(ptr) {\r\nScsi_Cmnd *next;\r\nif(SCDATA(ptr)) {\r\nnext = SCNEXT(ptr);\r\n} else {\r\nscmd_printk(KERN_DEBUG, ptr,\r\n"queue corrupted at %p\n", ptr);\r\nnext = NULL;\r\n}\r\nif (!ptr->device->soft_reset) {\r\nremove_SC(SCs, ptr);\r\nHOSTDATA(shpnt)->commands--;\r\nkfree(ptr->host_scribble);\r\nptr->host_scribble=NULL;\r\n}\r\nptr = next;\r\n}\r\n}\r\nstatic int aha152x_bus_reset_host(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long flags;\r\nDO_LOCK(flags);\r\nfree_hard_reset_SCs(shpnt, &ISSUE_SC);\r\nfree_hard_reset_SCs(shpnt, &DISCONNECTED_SC);\r\nSETPORT(SCSISEQ, SCSIRSTO);\r\nmdelay(256);\r\nSETPORT(SCSISEQ, 0);\r\nmdelay(DELAY);\r\nsetup_expected_interrupts(shpnt);\r\nif(HOSTDATA(shpnt)->commands==0)\r\nSETPORT(PORTA, 0);\r\nDO_UNLOCK(flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int aha152x_bus_reset(Scsi_Cmnd *SCpnt)\r\n{\r\nreturn aha152x_bus_reset_host(SCpnt->device->host);\r\n}\r\nstatic void reset_ports(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long flags;\r\nSETPORT(DMACNTRL0, RSTFIFO);\r\nSETPORT(SCSISEQ, 0);\r\nSETPORT(SXFRCTL1, 0);\r\nSETPORT(SCSISIG, 0);\r\nSETRATE(0);\r\nSETPORT(SSTAT0, 0x7f);\r\nSETPORT(SSTAT1, 0xef);\r\nSETPORT(SSTAT4, SYNCERR | FWERR | FRERR);\r\nSETPORT(DMACNTRL0, 0);\r\nSETPORT(DMACNTRL1, 0);\r\nSETPORT(BRSTCNTRL, 0xf1);\r\nSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1);\r\nDO_LOCK(flags);\r\nsetup_expected_interrupts(shpnt);\r\nDO_UNLOCK(flags);\r\n}\r\nint aha152x_host_reset_host(struct Scsi_Host *shpnt)\r\n{\r\naha152x_bus_reset_host(shpnt);\r\nreset_ports(shpnt);\r\nreturn SUCCESS;\r\n}\r\nstatic int aha152x_host_reset(Scsi_Cmnd *SCpnt)\r\n{\r\nreturn aha152x_host_reset_host(SCpnt->device->host);\r\n}\r\nstatic int aha152x_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int *info_array)\r\n{\r\nstruct Scsi_Host *shpnt = sdev->host;\r\ninfo_array[0] = 64;\r\ninfo_array[1] = 32;\r\ninfo_array[2] = (unsigned long)capacity / (64 * 32);\r\nif (info_array[2] >= 1024) {\r\nint info[3];\r\nif (scsicam_bios_param(bdev, capacity, info) < 0 ||\r\n!((info[0] == 64 && info[1] == 32) || (info[0] == 255 && info[1] == 63))) {\r\nif (EXT_TRANS) {\r\nprintk(KERN_NOTICE\r\n"aha152x: unable to verify geometry for disk with >1GB.\n"\r\n" using extended translation.\n");\r\ninfo_array[0] = 255;\r\ninfo_array[1] = 63;\r\ninfo_array[2] = (unsigned long)capacity / (255 * 63);\r\n} else {\r\nprintk(KERN_NOTICE\r\n"aha152x: unable to verify geometry for disk with >1GB.\n"\r\n" Using default translation. Please verify yourself.\n"\r\n" Perhaps you need to enable extended translation in the driver.\n"\r\n" See Documentation/scsi/aha152x.txt for details.\n");\r\n}\r\n} else {\r\ninfo_array[0] = info[0];\r\ninfo_array[1] = info[1];\r\ninfo_array[2] = info[2];\r\nif (info[0] == 255 && !EXT_TRANS) {\r\nprintk(KERN_NOTICE\r\n"aha152x: current partition table is using extended translation.\n"\r\n" using it also, although it's not explicitly enabled.\n");\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void done(struct Scsi_Host *shpnt, int error)\r\n{\r\nif (CURRENT_SC) {\r\nif(DONE_SC)\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"there's already a completed command %p "\r\n"- will cause abort\n", DONE_SC);\r\nDONE_SC = CURRENT_SC;\r\nCURRENT_SC = NULL;\r\nDONE_SC->result = error;\r\n} else\r\nprintk(KERN_ERR "aha152x: done() called outside of command\n");\r\n}\r\nstatic void run(struct work_struct *work)\r\n{\r\nstruct aha152x_hostdata *hd;\r\nlist_for_each_entry(hd, &aha152x_host_list, host_list) {\r\nstruct Scsi_Host *shost = container_of((void *)hd, struct Scsi_Host, hostdata);\r\nis_complete(shost);\r\n}\r\n}\r\nstatic irqreturn_t intr(int irqno, void *dev_id)\r\n{\r\nstruct Scsi_Host *shpnt = dev_id;\r\nunsigned long flags;\r\nunsigned char rev, dmacntrl0;\r\nrev = GETPORT(REV);\r\ndmacntrl0 = GETPORT(DMACNTRL0);\r\nif ((rev == 0xFF) && (dmacntrl0 == 0xFF))\r\nreturn IRQ_NONE;\r\nif( TESTLO(DMASTAT, INTSTAT) )\r\nreturn IRQ_NONE;\r\nCLRBITS(DMACNTRL0, INTEN);\r\nDO_LOCK(flags);\r\nif( HOSTDATA(shpnt)->service==0 ) {\r\nHOSTDATA(shpnt)->service=1;\r\nINIT_WORK(&aha152x_tq, run);\r\nschedule_work(&aha152x_tq);\r\n}\r\nDO_UNLOCK(flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void busfree_run(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long flags;\r\n#if defined(AHA152X_STAT)\r\nint action=0;\r\n#endif\r\nSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1);\r\nSETPORT(SSTAT1, CLRBUSFREE);\r\nif(CURRENT_SC) {\r\n#if defined(AHA152X_STAT)\r\naction++;\r\n#endif\r\nCURRENT_SC->SCp.phase &= ~syncneg;\r\nif(CURRENT_SC->SCp.phase & completed) {\r\ndone(shpnt, (CURRENT_SC->SCp.Status & 0xff) | ((CURRENT_SC->SCp.Message & 0xff) << 8) | (DID_OK << 16));\r\n} else if(CURRENT_SC->SCp.phase & aborted) {\r\ndone(shpnt, (CURRENT_SC->SCp.Status & 0xff) | ((CURRENT_SC->SCp.Message & 0xff) << 8) | (DID_ABORT << 16));\r\n} else if(CURRENT_SC->SCp.phase & resetted) {\r\ndone(shpnt, (CURRENT_SC->SCp.Status & 0xff) | ((CURRENT_SC->SCp.Message & 0xff) << 8) | (DID_RESET << 16));\r\n} else if(CURRENT_SC->SCp.phase & disconnected) {\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->disconnections++;\r\n#endif\r\nappend_SC(&DISCONNECTED_SC, CURRENT_SC);\r\nCURRENT_SC->SCp.phase |= 1 << 16;\r\nCURRENT_SC = NULL;\r\n} else {\r\ndone(shpnt, DID_ERROR << 16);\r\n}\r\n#if defined(AHA152X_STAT)\r\n} else {\r\nHOSTDATA(shpnt)->busfree_without_old_command++;\r\n#endif\r\n}\r\nDO_LOCK(flags);\r\nif(DONE_SC) {\r\n#if defined(AHA152X_STAT)\r\naction++;\r\n#endif\r\nif(DONE_SC->SCp.phase & check_condition) {\r\nstruct scsi_cmnd *cmd = HOSTDATA(shpnt)->done_SC;\r\nstruct aha152x_scdata *sc = SCDATA(cmd);\r\nscsi_eh_restore_cmnd(cmd, &sc->ses);\r\ncmd->SCp.Status = SAM_STAT_CHECK_CONDITION;\r\nHOSTDATA(shpnt)->commands--;\r\nif (!HOSTDATA(shpnt)->commands)\r\nSETPORT(PORTA, 0);\r\n} else if(DONE_SC->SCp.Status==SAM_STAT_CHECK_CONDITION) {\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->busfree_with_check_condition++;\r\n#endif\r\nif(!(DONE_SC->SCp.phase & not_issued)) {\r\nstruct aha152x_scdata *sc;\r\nScsi_Cmnd *ptr = DONE_SC;\r\nDONE_SC=NULL;\r\nsc = SCDATA(ptr);\r\nBUG_ON(!sc);\r\nscsi_eh_prep_cmnd(ptr, &sc->ses, NULL, 0, ~0);\r\nDO_UNLOCK(flags);\r\naha152x_internal_queue(ptr, NULL, check_condition, ptr->scsi_done);\r\nDO_LOCK(flags);\r\n}\r\n}\r\nif(DONE_SC && DONE_SC->scsi_done) {\r\nScsi_Cmnd *ptr = DONE_SC;\r\nDONE_SC=NULL;\r\nHOSTDATA(shpnt)->commands--;\r\nif (!HOSTDATA(shpnt)->commands)\r\nSETPORT(PORTA, 0);\r\nif(ptr->scsi_done != reset_done) {\r\nkfree(ptr->host_scribble);\r\nptr->host_scribble=NULL;\r\n}\r\nDO_UNLOCK(flags);\r\nptr->scsi_done(ptr);\r\nDO_LOCK(flags);\r\n}\r\nDONE_SC=NULL;\r\n#if defined(AHA152X_STAT)\r\n} else {\r\nHOSTDATA(shpnt)->busfree_without_done_command++;\r\n#endif\r\n}\r\nif(ISSUE_SC)\r\nCURRENT_SC = remove_first_SC(&ISSUE_SC);\r\nDO_UNLOCK(flags);\r\nif(CURRENT_SC) {\r\n#if defined(AHA152X_STAT)\r\naction++;\r\n#endif\r\nCURRENT_SC->SCp.phase |= selecting;\r\nSETPORT(SSTAT1, SELTO);\r\nSETPORT(SCSIID, (shpnt->this_id << OID_) | CURRENT_SC->device->id);\r\nSETPORT(SXFRCTL1, (PARITY ? ENSPCHK : 0 ) | ENSTIMER);\r\nSETPORT(SCSISEQ, ENSELO | ENAUTOATNO | (DISCONNECTED_SC ? ENRESELI : 0));\r\n} else {\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->busfree_without_new_command++;\r\n#endif\r\nSETPORT(SCSISEQ, DISCONNECTED_SC ? ENRESELI : 0);\r\n}\r\n#if defined(AHA152X_STAT)\r\nif(!action)\r\nHOSTDATA(shpnt)->busfree_without_any_action++;\r\n#endif\r\n}\r\nstatic void seldo_run(struct Scsi_Host *shpnt)\r\n{\r\nSETPORT(SCSISIG, 0);\r\nSETPORT(SSTAT1, CLRBUSFREE);\r\nSETPORT(SSTAT1, CLRPHASECHG);\r\nCURRENT_SC->SCp.phase &= ~(selecting|not_issued);\r\nSETPORT(SCSISEQ, 0);\r\nif (TESTLO(SSTAT0, SELDO)) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"aha152x: passing bus free condition\n");\r\ndone(shpnt, DID_NO_CONNECT << 16);\r\nreturn;\r\n}\r\nSETPORT(SSTAT0, CLRSELDO);\r\nADDMSGO(IDENTIFY(RECONNECT, CURRENT_SC->device->lun));\r\nif (CURRENT_SC->SCp.phase & aborting) {\r\nADDMSGO(ABORT);\r\n} else if (CURRENT_SC->SCp.phase & resetting) {\r\nADDMSGO(BUS_DEVICE_RESET);\r\n} else if (SYNCNEG==0 && SYNCHRONOUS) {\r\nCURRENT_SC->SCp.phase |= syncneg;\r\nMSGOLEN += spi_populate_sync_msg(&MSGO(MSGOLEN), 50, 8);\r\nSYNCNEG=1;\r\n}\r\nSETRATE(SYNCRATE);\r\n}\r\nstatic void selto_run(struct Scsi_Host *shpnt)\r\n{\r\nSETPORT(SCSISEQ, 0);\r\nSETPORT(SSTAT1, CLRSELTIMO);\r\nif (!CURRENT_SC)\r\nreturn;\r\nCURRENT_SC->SCp.phase &= ~selecting;\r\nif (CURRENT_SC->SCp.phase & aborted)\r\ndone(shpnt, DID_ABORT << 16);\r\nelse if (TESTLO(SSTAT0, SELINGO))\r\ndone(shpnt, DID_BUS_BUSY << 16);\r\nelse\r\ndone(shpnt, DID_NO_CONNECT << 16);\r\n}\r\nstatic void seldi_run(struct Scsi_Host *shpnt)\r\n{\r\nint selid;\r\nint target;\r\nunsigned long flags;\r\nSETPORT(SCSISIG, 0);\r\nSETPORT(SSTAT0, CLRSELDI);\r\nSETPORT(SSTAT1, CLRBUSFREE);\r\nSETPORT(SSTAT1, CLRPHASECHG);\r\nif(CURRENT_SC) {\r\nif(!(CURRENT_SC->SCp.phase & not_issued))\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"command should not have been issued yet\n");\r\nDO_LOCK(flags);\r\nappend_SC(&ISSUE_SC, CURRENT_SC);\r\nDO_UNLOCK(flags);\r\nCURRENT_SC = NULL;\r\n}\r\nif (!DISCONNECTED_SC)\r\nreturn;\r\nRECONN_TARGET=-1;\r\nselid = GETPORT(SELID) & ~(1 << shpnt->this_id);\r\nif (selid==0) {\r\nshost_printk(KERN_INFO, shpnt,\r\n"target id unknown (%02x)\n", selid);\r\nreturn;\r\n}\r\nfor(target=7; !(selid & (1 << target)); target--)\r\n;\r\nif(selid & ~(1 << target)) {\r\nshost_printk(KERN_INFO, shpnt,\r\n"multiple targets reconnected (%02x)\n", selid);\r\n}\r\nSETPORT(SCSIID, (shpnt->this_id << OID_) | target);\r\nSETPORT(SCSISEQ, 0);\r\nSETRATE(HOSTDATA(shpnt)->syncrate[target]);\r\nRECONN_TARGET=target;\r\n}\r\nstatic void msgi_run(struct Scsi_Host *shpnt)\r\n{\r\nfor(;;) {\r\nint sstat1 = GETPORT(SSTAT1);\r\nif(sstat1 & (PHASECHG|PHASEMIS|BUSFREE) || !(sstat1 & REQINIT))\r\nreturn;\r\nif (TESTLO(SSTAT0, SPIORDY))\r\nreturn;\r\nADDMSGI(GETPORT(SCSIDAT));\r\nif(!CURRENT_SC) {\r\nif(LASTSTATE!=seldi) {\r\nshost_printk(KERN_ERR, shpnt,\r\n"message in w/o current command"\r\n" not after reselection\n");\r\n}\r\nif(!(MSGI(0) & IDENTIFY_BASE)) {\r\nshost_printk(KERN_ERR, shpnt,\r\n"target didn't identify after reselection\n");\r\ncontinue;\r\n}\r\nCURRENT_SC = remove_lun_SC(&DISCONNECTED_SC, RECONN_TARGET, MSGI(0) & 0x3f);\r\nif (!CURRENT_SC) {\r\nshow_queues(shpnt);\r\nshost_printk(KERN_ERR, shpnt,\r\n"no disconnected command"\r\n" for target %d/%d\n",\r\nRECONN_TARGET, MSGI(0) & 0x3f);\r\ncontinue;\r\n}\r\nCURRENT_SC->SCp.Message = MSGI(0);\r\nCURRENT_SC->SCp.phase &= ~disconnected;\r\nMSGILEN=0;\r\ncontinue;\r\n}\r\nCURRENT_SC->SCp.Message = MSGI(0);\r\nswitch (MSGI(0)) {\r\ncase DISCONNECT:\r\nif (!RECONNECT)\r\nscmd_printk(KERN_WARNING, CURRENT_SC,\r\n"target was not allowed to disconnect\n");\r\nCURRENT_SC->SCp.phase |= disconnected;\r\nbreak;\r\ncase COMMAND_COMPLETE:\r\nCURRENT_SC->SCp.phase |= completed;\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nif (SYNCNEG==1) {\r\nscmd_printk(KERN_INFO, CURRENT_SC,\r\n"Synchronous Data Transfer Request"\r\n" was rejected\n");\r\nSYNCNEG=2;\r\n} else\r\nscmd_printk(KERN_INFO, CURRENT_SC,\r\n"inbound message (MESSAGE REJECT)\n");\r\nbreak;\r\ncase SAVE_POINTERS:\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nif(MSGILEN<2 || MSGILEN<MSGI(1)+2) {\r\ncontinue;\r\n}\r\nswitch (MSGI(2)) {\r\ncase EXTENDED_SDTR:\r\n{\r\nlong ticks;\r\nif (MSGI(1) != 3) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"SDTR message length!=3\n");\r\nbreak;\r\n}\r\nif (!HOSTDATA(shpnt)->synchronous)\r\nbreak;\r\nprintk(INFO_LEAD, CMDINFO(CURRENT_SC));\r\nspi_print_msg(&MSGI(0));\r\nprintk("\n");\r\nticks = (MSGI(3) * 4 + 49) / 50;\r\nif (syncneg) {\r\nif (ticks > 9 || MSGI(4) < 1 || MSGI(4) > 8) {\r\nADDMSGO(MESSAGE_REJECT);\r\nscmd_printk(KERN_INFO,\r\nCURRENT_SC,\r\n"received Synchronous Data Transfer Request invalid - rejected\n");\r\nbreak;\r\n}\r\nSYNCRATE |= ((ticks - 2) << 4) + MSGI(4);\r\n} else if (ticks <= 9 && MSGI(4) >= 1) {\r\nADDMSGO(EXTENDED_MESSAGE);\r\nADDMSGO(3);\r\nADDMSGO(EXTENDED_SDTR);\r\nif (ticks < 4) {\r\nticks = 4;\r\nADDMSGO(50);\r\n} else\r\nADDMSGO(MSGI(3));\r\nif (MSGI(4) > 8)\r\nMSGI(4) = 8;\r\nADDMSGO(MSGI(4));\r\nSYNCRATE |= ((ticks - 2) << 4) + MSGI(4);\r\n} else {\r\nscmd_printk(KERN_INFO,\r\nCURRENT_SC,\r\n"Synchronous Data Transfer Request too slow - Rejecting\n");\r\nADDMSGO(MESSAGE_REJECT);\r\n}\r\nSYNCNEG=2;\r\nSETRATE(SYNCRATE);\r\n}\r\nbreak;\r\ncase BUS_DEVICE_RESET:\r\n{\r\nint i;\r\nfor(i=0; i<8; i++) {\r\nHOSTDATA(shpnt)->syncrate[i]=0;\r\nHOSTDATA(shpnt)->syncneg[i]=0;\r\n}\r\n}\r\nbreak;\r\ncase EXTENDED_MODIFY_DATA_POINTER:\r\ncase EXTENDED_EXTENDED_IDENTIFY:\r\ncase EXTENDED_WDTR:\r\ndefault:\r\nADDMSGO(MESSAGE_REJECT);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nMSGILEN=0;\r\n}\r\n}\r\nstatic void msgi_end(struct Scsi_Host *shpnt)\r\n{\r\nif(MSGILEN>0)\r\nscmd_printk(KERN_WARNING, CURRENT_SC,\r\n"target left before message completed (%d)\n",\r\nMSGILEN);\r\nif (MSGOLEN > 0 && !(GETPORT(SSTAT1) & BUSFREE))\r\nSETPORT(SCSISIG, P_MSGI | SIG_ATNO);\r\n}\r\nstatic void msgo_init(struct Scsi_Host *shpnt)\r\n{\r\nif(MSGOLEN==0) {\r\nif((CURRENT_SC->SCp.phase & syncneg) && SYNCNEG==2 && SYNCRATE==0) {\r\nADDMSGO(IDENTIFY(RECONNECT, CURRENT_SC->device->lun));\r\n} else {\r\nscmd_printk(KERN_INFO, CURRENT_SC,\r\n"unexpected MESSAGE OUT phase; rejecting\n");\r\nADDMSGO(MESSAGE_REJECT);\r\n}\r\n}\r\n}\r\nstatic void msgo_run(struct Scsi_Host *shpnt)\r\n{\r\nwhile(MSGO_I<MSGOLEN) {\r\nif (TESTLO(SSTAT0, SPIORDY))\r\nreturn;\r\nif (MSGO_I==MSGOLEN-1) {\r\nSETPORT(SSTAT1, CLRATNO);\r\n}\r\nif (MSGO(MSGO_I) & IDENTIFY_BASE)\r\nCURRENT_SC->SCp.phase |= identified;\r\nif (MSGO(MSGO_I)==ABORT)\r\nCURRENT_SC->SCp.phase |= aborted;\r\nif (MSGO(MSGO_I)==BUS_DEVICE_RESET)\r\nCURRENT_SC->SCp.phase |= resetted;\r\nSETPORT(SCSIDAT, MSGO(MSGO_I++));\r\n}\r\n}\r\nstatic void msgo_end(struct Scsi_Host *shpnt)\r\n{\r\nif(MSGO_I<MSGOLEN) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"message sent incompletely (%d/%d)\n",\r\nMSGO_I, MSGOLEN);\r\nif(SYNCNEG==1) {\r\nscmd_printk(KERN_INFO, CURRENT_SC,\r\n"Synchronous Data Transfer Request was rejected\n");\r\nSYNCNEG=2;\r\n}\r\n}\r\nMSGO_I = 0;\r\nMSGOLEN = 0;\r\n}\r\nstatic void cmd_init(struct Scsi_Host *shpnt)\r\n{\r\nif (CURRENT_SC->SCp.sent_command) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"command already sent\n");\r\ndone(shpnt, DID_ERROR << 16);\r\nreturn;\r\n}\r\nCMD_I=0;\r\n}\r\nstatic void cmd_run(struct Scsi_Host *shpnt)\r\n{\r\nwhile(CMD_I<CURRENT_SC->cmd_len) {\r\nif (TESTLO(SSTAT0, SPIORDY))\r\nreturn;\r\nSETPORT(SCSIDAT, CURRENT_SC->cmnd[CMD_I++]);\r\n}\r\n}\r\nstatic void cmd_end(struct Scsi_Host *shpnt)\r\n{\r\nif(CMD_I<CURRENT_SC->cmd_len)\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"command sent incompletely (%d/%d)\n",\r\nCMD_I, CURRENT_SC->cmd_len);\r\nelse\r\nCURRENT_SC->SCp.sent_command++;\r\n}\r\nstatic void status_run(struct Scsi_Host *shpnt)\r\n{\r\nif (TESTLO(SSTAT0, SPIORDY))\r\nreturn;\r\nCURRENT_SC->SCp.Status = GETPORT(SCSIDAT);\r\n}\r\nstatic void datai_init(struct Scsi_Host *shpnt)\r\n{\r\nSETPORT(DMACNTRL0, RSTFIFO);\r\nSETPORT(DMACNTRL0, RSTFIFO|ENDMA);\r\nSETPORT(SXFRCTL0, CH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1|SCSIEN|DMAEN);\r\nSETPORT(SIMODE0, 0);\r\nSETPORT(SIMODE1, ENSCSIPERR | ENSCSIRST | ENPHASEMIS | ENBUSFREE);\r\nDATA_LEN=0;\r\n}\r\nstatic void datai_run(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long the_time;\r\nint fifodata, data_count;\r\nwhile(TESTLO(DMASTAT, INTSTAT) || TESTLO(DMASTAT, DFIFOEMP) || TESTLO(SSTAT2, SEMPTY)) {\r\nthe_time=jiffies + 100*HZ;\r\nwhile(TESTLO(DMASTAT, DFIFOFULL|INTSTAT) && time_before(jiffies,the_time))\r\nbarrier();\r\nif(TESTLO(DMASTAT, DFIFOFULL|INTSTAT)) {\r\nscmd_printk(KERN_ERR, CURRENT_SC, "datai timeout\n");\r\nbreak;\r\n}\r\nif(TESTHI(DMASTAT, DFIFOFULL)) {\r\nfifodata = 128;\r\n} else {\r\nthe_time=jiffies + 100*HZ;\r\nwhile(TESTLO(SSTAT2, SEMPTY) && time_before(jiffies,the_time))\r\nbarrier();\r\nif(TESTLO(SSTAT2, SEMPTY)) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"datai sempty timeout");\r\nbreak;\r\n}\r\nfifodata = GETPORT(FIFOSTAT);\r\n}\r\nif(CURRENT_SC->SCp.this_residual>0) {\r\nwhile(fifodata>0 && CURRENT_SC->SCp.this_residual>0) {\r\ndata_count = fifodata > CURRENT_SC->SCp.this_residual ?\r\nCURRENT_SC->SCp.this_residual :\r\nfifodata;\r\nfifodata -= data_count;\r\nif (data_count & 1) {\r\nSETPORT(DMACNTRL0, ENDMA|_8BIT);\r\n*CURRENT_SC->SCp.ptr++ = GETPORT(DATAPORT);\r\nCURRENT_SC->SCp.this_residual--;\r\nDATA_LEN++;\r\nSETPORT(DMACNTRL0, ENDMA);\r\n}\r\nif (data_count > 1) {\r\ndata_count >>= 1;\r\ninsw(DATAPORT, CURRENT_SC->SCp.ptr, data_count);\r\nCURRENT_SC->SCp.ptr += 2 * data_count;\r\nCURRENT_SC->SCp.this_residual -= 2 * data_count;\r\nDATA_LEN += 2 * data_count;\r\n}\r\nif (CURRENT_SC->SCp.this_residual == 0 &&\r\nCURRENT_SC->SCp.buffers_residual > 0) {\r\nCURRENT_SC->SCp.buffers_residual--;\r\nCURRENT_SC->SCp.buffer++;\r\nCURRENT_SC->SCp.ptr = SG_ADDRESS(CURRENT_SC->SCp.buffer);\r\nCURRENT_SC->SCp.this_residual = CURRENT_SC->SCp.buffer->length;\r\n}\r\n}\r\n} else if (fifodata > 0) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"no buffers left for %d(%d) bytes"\r\n" (data overrun!?)\n",\r\nfifodata, GETPORT(FIFOSTAT));\r\nSETPORT(DMACNTRL0, ENDMA|_8BIT);\r\nwhile(fifodata>0) {\r\nint data;\r\ndata=GETPORT(DATAPORT);\r\nfifodata--;\r\nDATA_LEN++;\r\n}\r\nSETPORT(DMACNTRL0, ENDMA|_8BIT);\r\n}\r\n}\r\nif(TESTLO(DMASTAT, INTSTAT) ||\r\nTESTLO(DMASTAT, DFIFOEMP) ||\r\nTESTLO(SSTAT2, SEMPTY) ||\r\nGETPORT(FIFOSTAT)>0) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"fifos should be empty and phase should have changed\n");\r\n}\r\nif(DATA_LEN!=GETSTCNT()) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"manual transfer count differs from automatic "\r\n"(count=%d;stcnt=%d;diff=%d;fifostat=%d)",\r\nDATA_LEN, GETSTCNT(), GETSTCNT()-DATA_LEN,\r\nGETPORT(FIFOSTAT));\r\nmdelay(10000);\r\n}\r\n}\r\nstatic void datai_end(struct Scsi_Host *shpnt)\r\n{\r\nCMD_INC_RESID(CURRENT_SC, -GETSTCNT());\r\nSETPORT(SXFRCTL0, CH1|CLRSTCNT);\r\nSETPORT(DMACNTRL0, 0);\r\n}\r\nstatic void datao_init(struct Scsi_Host *shpnt)\r\n{\r\nSETPORT(DMACNTRL0, WRITE_READ | RSTFIFO);\r\nSETPORT(DMACNTRL0, WRITE_READ | ENDMA);\r\nSETPORT(SXFRCTL0, CH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1|SCSIEN|DMAEN);\r\nSETPORT(SIMODE0, 0);\r\nSETPORT(SIMODE1, ENSCSIPERR | ENSCSIRST | ENPHASEMIS | ENBUSFREE );\r\nDATA_LEN = scsi_get_resid(CURRENT_SC);\r\n}\r\nstatic void datao_run(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long the_time;\r\nint data_count;\r\nwhile(TESTLO(DMASTAT, INTSTAT) && CURRENT_SC->SCp.this_residual>0) {\r\ndata_count = 128;\r\nif(data_count > CURRENT_SC->SCp.this_residual)\r\ndata_count=CURRENT_SC->SCp.this_residual;\r\nif(TESTLO(DMASTAT, DFIFOEMP)) {\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"datao fifo not empty (%d)",\r\nGETPORT(FIFOSTAT));\r\nbreak;\r\n}\r\nif(data_count & 1) {\r\nSETPORT(DMACNTRL0,WRITE_READ|ENDMA|_8BIT);\r\nSETPORT(DATAPORT, *CURRENT_SC->SCp.ptr++);\r\nCURRENT_SC->SCp.this_residual--;\r\nCMD_INC_RESID(CURRENT_SC, -1);\r\nSETPORT(DMACNTRL0,WRITE_READ|ENDMA);\r\n}\r\nif(data_count > 1) {\r\ndata_count >>= 1;\r\noutsw(DATAPORT, CURRENT_SC->SCp.ptr, data_count);\r\nCURRENT_SC->SCp.ptr += 2 * data_count;\r\nCURRENT_SC->SCp.this_residual -= 2 * data_count;\r\nCMD_INC_RESID(CURRENT_SC, -2 * data_count);\r\n}\r\nif(CURRENT_SC->SCp.this_residual==0 && CURRENT_SC->SCp.buffers_residual>0) {\r\nCURRENT_SC->SCp.buffers_residual--;\r\nCURRENT_SC->SCp.buffer++;\r\nCURRENT_SC->SCp.ptr = SG_ADDRESS(CURRENT_SC->SCp.buffer);\r\nCURRENT_SC->SCp.this_residual = CURRENT_SC->SCp.buffer->length;\r\n}\r\nthe_time=jiffies + 100*HZ;\r\nwhile(TESTLO(DMASTAT, DFIFOEMP|INTSTAT) && time_before(jiffies,the_time))\r\nbarrier();\r\nif(TESTLO(DMASTAT, DFIFOEMP|INTSTAT)) {\r\nscmd_printk(KERN_ERR, CURRENT_SC, "dataout timeout\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void datao_end(struct Scsi_Host *shpnt)\r\n{\r\nif(TESTLO(DMASTAT, DFIFOEMP)) {\r\nint data_count = (DATA_LEN - scsi_get_resid(CURRENT_SC)) -\r\nGETSTCNT();\r\nCMD_INC_RESID(CURRENT_SC, data_count);\r\ndata_count -= CURRENT_SC->SCp.ptr -\r\nSG_ADDRESS(CURRENT_SC->SCp.buffer);\r\nwhile(data_count>0) {\r\nCURRENT_SC->SCp.buffer--;\r\nCURRENT_SC->SCp.buffers_residual++;\r\ndata_count -= CURRENT_SC->SCp.buffer->length;\r\n}\r\nCURRENT_SC->SCp.ptr = SG_ADDRESS(CURRENT_SC->SCp.buffer) -\r\ndata_count;\r\nCURRENT_SC->SCp.this_residual = CURRENT_SC->SCp.buffer->length +\r\ndata_count;\r\n}\r\nSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1);\r\nSETPORT(DMACNTRL0, 0);\r\n}\r\nstatic int update_state(struct Scsi_Host *shpnt)\r\n{\r\nint dataphase=0;\r\nunsigned int stat0 = GETPORT(SSTAT0);\r\nunsigned int stat1 = GETPORT(SSTAT1);\r\nPREVSTATE = STATE;\r\nSTATE=unknown;\r\nif(stat1 & SCSIRSTI) {\r\nSTATE=rsti;\r\nSETPORT(SCSISEQ,0);\r\nSETPORT(SSTAT1,SCSIRSTI);\r\n} else if (stat0 & SELDI && PREVSTATE == busfree) {\r\nSTATE=seldi;\r\n} else if(stat0 & SELDO && CURRENT_SC && (CURRENT_SC->SCp.phase & selecting)) {\r\nSTATE=seldo;\r\n} else if(stat1 & SELTO) {\r\nSTATE=selto;\r\n} else if(stat1 & BUSFREE) {\r\nSTATE=busfree;\r\nSETPORT(SSTAT1,BUSFREE);\r\n} else if(stat1 & SCSIPERR) {\r\nSTATE=parerr;\r\nSETPORT(SSTAT1,SCSIPERR);\r\n} else if(stat1 & REQINIT) {\r\nswitch(GETPORT(SCSISIG) & P_MASK) {\r\ncase P_MSGI: STATE=msgi; break;\r\ncase P_MSGO: STATE=msgo; break;\r\ncase P_DATAO: STATE=datao; break;\r\ncase P_DATAI: STATE=datai; break;\r\ncase P_STATUS: STATE=status; break;\r\ncase P_CMD: STATE=cmd; break;\r\n}\r\ndataphase=1;\r\n}\r\nif((stat0 & SELDI) && STATE!=seldi && !dataphase) {\r\nscmd_printk(KERN_INFO, CURRENT_SC, "reselection missed?");\r\n}\r\nif(STATE!=PREVSTATE) {\r\nLASTSTATE=PREVSTATE;\r\n}\r\nreturn dataphase;\r\n}\r\nstatic void parerr_run(struct Scsi_Host *shpnt)\r\n{\r\nscmd_printk(KERN_ERR, CURRENT_SC, "parity error\n");\r\ndone(shpnt, DID_PARITY << 16);\r\n}\r\nstatic void rsti_run(struct Scsi_Host *shpnt)\r\n{\r\nScsi_Cmnd *ptr;\r\nshost_printk(KERN_NOTICE, shpnt, "scsi reset in\n");\r\nptr=DISCONNECTED_SC;\r\nwhile(ptr) {\r\nScsi_Cmnd *next = SCNEXT(ptr);\r\nif (!ptr->device->soft_reset) {\r\nremove_SC(&DISCONNECTED_SC, ptr);\r\nkfree(ptr->host_scribble);\r\nptr->host_scribble=NULL;\r\nptr->result = DID_RESET << 16;\r\nptr->scsi_done(ptr);\r\n}\r\nptr = next;\r\n}\r\nif(CURRENT_SC && !CURRENT_SC->device->soft_reset)\r\ndone(shpnt, DID_RESET << 16 );\r\n}\r\nstatic void is_complete(struct Scsi_Host *shpnt)\r\n{\r\nint dataphase;\r\nunsigned long flags;\r\nint pending;\r\nif(!shpnt)\r\nreturn;\r\nDO_LOCK(flags);\r\nif( HOSTDATA(shpnt)->service==0 ) {\r\nDO_UNLOCK(flags);\r\nreturn;\r\n}\r\nHOSTDATA(shpnt)->service = 0;\r\nif(HOSTDATA(shpnt)->in_intr) {\r\nDO_UNLOCK(flags);\r\naha152x_error(shpnt, "bottom-half already running!?");\r\n}\r\nHOSTDATA(shpnt)->in_intr++;\r\ndo {\r\nunsigned long start = jiffies;\r\nDO_UNLOCK(flags);\r\ndataphase=update_state(shpnt);\r\nif(PREVSTATE!=STATE && states[PREVSTATE].end)\r\nstates[PREVSTATE].end(shpnt);\r\nif(states[PREVSTATE].spio && !states[STATE].spio) {\r\nSETPORT(SXFRCTL0, CH1);\r\nSETPORT(DMACNTRL0, 0);\r\nif(CURRENT_SC)\r\nCURRENT_SC->SCp.phase &= ~spiordy;\r\n}\r\nif(dataphase) {\r\nSETPORT(SSTAT0, REQINIT);\r\nSETPORT(SCSISIG, GETPORT(SCSISIG) & P_MASK);\r\nSETPORT(SSTAT1, PHASECHG);\r\n}\r\nif(!states[PREVSTATE].spio && states[STATE].spio) {\r\nSETPORT(DMACNTRL0, 0);\r\nSETPORT(SXFRCTL0, CH1|SPIOEN);\r\nif(CURRENT_SC)\r\nCURRENT_SC->SCp.phase |= spiordy;\r\n}\r\nif(PREVSTATE!=STATE && states[STATE].init)\r\nstates[STATE].init(shpnt);\r\nif(states[STATE].run)\r\nstates[STATE].run(shpnt);\r\nelse\r\nscmd_printk(KERN_ERR, CURRENT_SC,\r\n"unexpected state (%x)\n", STATE);\r\nDO_LOCK(flags);\r\npending=setup_expected_interrupts(shpnt);\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->count[STATE]++;\r\nif(PREVSTATE!=STATE)\r\nHOSTDATA(shpnt)->count_trans[STATE]++;\r\nHOSTDATA(shpnt)->time[STATE] += jiffies-start;\r\n#endif\r\n} while(pending);\r\nHOSTDATA(shpnt)->in_intr--;\r\nSETBITS(DMACNTRL0, INTEN);\r\nDO_UNLOCK(flags);\r\n}\r\nstatic void aha152x_error(struct Scsi_Host *shpnt, char *msg)\r\n{\r\nshost_printk(KERN_EMERG, shpnt, "%s\n", msg);\r\nshow_queues(shpnt);\r\npanic("aha152x panic\n");\r\n}\r\nstatic void disp_enintr(struct Scsi_Host *shpnt)\r\n{\r\nint s0, s1;\r\ns0 = GETPORT(SIMODE0);\r\ns1 = GETPORT(SIMODE1);\r\nshost_printk(KERN_DEBUG, shpnt,\r\n"enabled interrupts (%s%s%s%s%s%s%s%s%s%s%s%s%s%s)\n",\r\n(s0 & ENSELDO) ? "ENSELDO " : "",\r\n(s0 & ENSELDI) ? "ENSELDI " : "",\r\n(s0 & ENSELINGO) ? "ENSELINGO " : "",\r\n(s0 & ENSWRAP) ? "ENSWRAP " : "",\r\n(s0 & ENSDONE) ? "ENSDONE " : "",\r\n(s0 & ENSPIORDY) ? "ENSPIORDY " : "",\r\n(s0 & ENDMADONE) ? "ENDMADONE " : "",\r\n(s1 & ENSELTIMO) ? "ENSELTIMO " : "",\r\n(s1 & ENATNTARG) ? "ENATNTARG " : "",\r\n(s1 & ENPHASEMIS) ? "ENPHASEMIS " : "",\r\n(s1 & ENBUSFREE) ? "ENBUSFREE " : "",\r\n(s1 & ENSCSIPERR) ? "ENSCSIPERR " : "",\r\n(s1 & ENPHASECHG) ? "ENPHASECHG " : "",\r\n(s1 & ENREQINIT) ? "ENREQINIT " : "");\r\n}\r\nstatic void show_command(Scsi_Cmnd *ptr)\r\n{\r\nscsi_print_command(ptr);\r\nscmd_printk(KERN_DEBUG, ptr,\r\n"request_bufflen=%d; resid=%d; "\r\n"phase |%s%s%s%s%s%s%s%s%s; next=0x%p",\r\nscsi_bufflen(ptr), scsi_get_resid(ptr),\r\n(ptr->SCp.phase & not_issued) ? "not issued|" : "",\r\n(ptr->SCp.phase & selecting) ? "selecting|" : "",\r\n(ptr->SCp.phase & identified) ? "identified|" : "",\r\n(ptr->SCp.phase & disconnected) ? "disconnected|" : "",\r\n(ptr->SCp.phase & completed) ? "completed|" : "",\r\n(ptr->SCp.phase & spiordy) ? "spiordy|" : "",\r\n(ptr->SCp.phase & syncneg) ? "syncneg|" : "",\r\n(ptr->SCp.phase & aborted) ? "aborted|" : "",\r\n(ptr->SCp.phase & resetted) ? "resetted|" : "",\r\n(SCDATA(ptr)) ? SCNEXT(ptr) : NULL);\r\n}\r\nstatic void show_queues(struct Scsi_Host *shpnt)\r\n{\r\nScsi_Cmnd *ptr;\r\nunsigned long flags;\r\nDO_LOCK(flags);\r\nprintk(KERN_DEBUG "\nqueue status:\nissue_SC:\n");\r\nfor (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr))\r\nshow_command(ptr);\r\nDO_UNLOCK(flags);\r\nprintk(KERN_DEBUG "current_SC:\n");\r\nif (CURRENT_SC)\r\nshow_command(CURRENT_SC);\r\nelse\r\nprintk(KERN_DEBUG "none\n");\r\nprintk(KERN_DEBUG "disconnected_SC:\n");\r\nfor (ptr = DISCONNECTED_SC; ptr; ptr = SCDATA(ptr) ? SCNEXT(ptr) : NULL)\r\nshow_command(ptr);\r\ndisp_enintr(shpnt);\r\n}\r\nstatic void get_command(struct seq_file *m, Scsi_Cmnd * ptr)\r\n{\r\nint i;\r\nseq_printf(m, "%p: target=%d; lun=%d; cmnd=( ",\r\nptr, ptr->device->id, (u8)ptr->device->lun);\r\nfor (i = 0; i < COMMAND_SIZE(ptr->cmnd[0]); i++)\r\nseq_printf(m, "0x%02x ", ptr->cmnd[i]);\r\nseq_printf(m, "); resid=%d; residual=%d; buffers=%d; phase |",\r\nscsi_get_resid(ptr), ptr->SCp.this_residual,\r\nptr->SCp.buffers_residual);\r\nif (ptr->SCp.phase & not_issued)\r\nseq_puts(m, "not issued|");\r\nif (ptr->SCp.phase & selecting)\r\nseq_puts(m, "selecting|");\r\nif (ptr->SCp.phase & disconnected)\r\nseq_puts(m, "disconnected|");\r\nif (ptr->SCp.phase & aborted)\r\nseq_puts(m, "aborted|");\r\nif (ptr->SCp.phase & identified)\r\nseq_puts(m, "identified|");\r\nif (ptr->SCp.phase & completed)\r\nseq_puts(m, "completed|");\r\nif (ptr->SCp.phase & spiordy)\r\nseq_puts(m, "spiordy|");\r\nif (ptr->SCp.phase & syncneg)\r\nseq_puts(m, "syncneg|");\r\nseq_printf(m, "; next=0x%p\n", SCNEXT(ptr));\r\n}\r\nstatic void get_ports(struct seq_file *m, struct Scsi_Host *shpnt)\r\n{\r\nint s;\r\nseq_printf(m, "\n%s: %s(%s) ", CURRENT_SC ? "on bus" : "waiting", states[STATE].name, states[PREVSTATE].name);\r\ns = GETPORT(SCSISEQ);\r\nseq_puts(m, "SCSISEQ( ");\r\nif (s & TEMODEO)\r\nseq_puts(m, "TARGET MODE ");\r\nif (s & ENSELO)\r\nseq_puts(m, "SELO ");\r\nif (s & ENSELI)\r\nseq_puts(m, "SELI ");\r\nif (s & ENRESELI)\r\nseq_puts(m, "RESELI ");\r\nif (s & ENAUTOATNO)\r\nseq_puts(m, "AUTOATNO ");\r\nif (s & ENAUTOATNI)\r\nseq_puts(m, "AUTOATNI ");\r\nif (s & ENAUTOATNP)\r\nseq_puts(m, "AUTOATNP ");\r\nif (s & SCSIRSTO)\r\nseq_puts(m, "SCSIRSTO ");\r\nseq_puts(m, ");");\r\nseq_puts(m, " SCSISIG(");\r\ns = GETPORT(SCSISIG);\r\nswitch (s & P_MASK) {\r\ncase P_DATAO:\r\nseq_puts(m, "DATA OUT");\r\nbreak;\r\ncase P_DATAI:\r\nseq_puts(m, "DATA IN");\r\nbreak;\r\ncase P_CMD:\r\nseq_puts(m, "COMMAND");\r\nbreak;\r\ncase P_STATUS:\r\nseq_puts(m, "STATUS");\r\nbreak;\r\ncase P_MSGO:\r\nseq_puts(m, "MESSAGE OUT");\r\nbreak;\r\ncase P_MSGI:\r\nseq_puts(m, "MESSAGE IN");\r\nbreak;\r\ndefault:\r\nseq_puts(m, "*invalid*");\r\nbreak;\r\n}\r\nseq_puts(m, "); ");\r\nseq_printf(m, "INTSTAT (%s); ", TESTHI(DMASTAT, INTSTAT) ? "hi" : "lo");\r\nseq_puts(m, "SSTAT( ");\r\ns = GETPORT(SSTAT0);\r\nif (s & TARGET)\r\nseq_puts(m, "TARGET ");\r\nif (s & SELDO)\r\nseq_puts(m, "SELDO ");\r\nif (s & SELDI)\r\nseq_puts(m, "SELDI ");\r\nif (s & SELINGO)\r\nseq_puts(m, "SELINGO ");\r\nif (s & SWRAP)\r\nseq_puts(m, "SWRAP ");\r\nif (s & SDONE)\r\nseq_puts(m, "SDONE ");\r\nif (s & SPIORDY)\r\nseq_puts(m, "SPIORDY ");\r\nif (s & DMADONE)\r\nseq_puts(m, "DMADONE ");\r\ns = GETPORT(SSTAT1);\r\nif (s & SELTO)\r\nseq_puts(m, "SELTO ");\r\nif (s & ATNTARG)\r\nseq_puts(m, "ATNTARG ");\r\nif (s & SCSIRSTI)\r\nseq_puts(m, "SCSIRSTI ");\r\nif (s & PHASEMIS)\r\nseq_puts(m, "PHASEMIS ");\r\nif (s & BUSFREE)\r\nseq_puts(m, "BUSFREE ");\r\nif (s & SCSIPERR)\r\nseq_puts(m, "SCSIPERR ");\r\nif (s & PHASECHG)\r\nseq_puts(m, "PHASECHG ");\r\nif (s & REQINIT)\r\nseq_puts(m, "REQINIT ");\r\nseq_puts(m, "); ");\r\nseq_puts(m, "SSTAT( ");\r\ns = GETPORT(SSTAT0) & GETPORT(SIMODE0);\r\nif (s & TARGET)\r\nseq_puts(m, "TARGET ");\r\nif (s & SELDO)\r\nseq_puts(m, "SELDO ");\r\nif (s & SELDI)\r\nseq_puts(m, "SELDI ");\r\nif (s & SELINGO)\r\nseq_puts(m, "SELINGO ");\r\nif (s & SWRAP)\r\nseq_puts(m, "SWRAP ");\r\nif (s & SDONE)\r\nseq_puts(m, "SDONE ");\r\nif (s & SPIORDY)\r\nseq_puts(m, "SPIORDY ");\r\nif (s & DMADONE)\r\nseq_puts(m, "DMADONE ");\r\ns = GETPORT(SSTAT1) & GETPORT(SIMODE1);\r\nif (s & SELTO)\r\nseq_puts(m, "SELTO ");\r\nif (s & ATNTARG)\r\nseq_puts(m, "ATNTARG ");\r\nif (s & SCSIRSTI)\r\nseq_puts(m, "SCSIRSTI ");\r\nif (s & PHASEMIS)\r\nseq_puts(m, "PHASEMIS ");\r\nif (s & BUSFREE)\r\nseq_puts(m, "BUSFREE ");\r\nif (s & SCSIPERR)\r\nseq_puts(m, "SCSIPERR ");\r\nif (s & PHASECHG)\r\nseq_puts(m, "PHASECHG ");\r\nif (s & REQINIT)\r\nseq_puts(m, "REQINIT ");\r\nseq_puts(m, "); ");\r\nseq_puts(m, "SXFRCTL0( ");\r\ns = GETPORT(SXFRCTL0);\r\nif (s & SCSIEN)\r\nseq_puts(m, "SCSIEN ");\r\nif (s & DMAEN)\r\nseq_puts(m, "DMAEN ");\r\nif (s & CH1)\r\nseq_puts(m, "CH1 ");\r\nif (s & CLRSTCNT)\r\nseq_puts(m, "CLRSTCNT ");\r\nif (s & SPIOEN)\r\nseq_puts(m, "SPIOEN ");\r\nif (s & CLRCH1)\r\nseq_puts(m, "CLRCH1 ");\r\nseq_puts(m, "); ");\r\nseq_puts(m, "SIGNAL( ");\r\ns = GETPORT(SCSISIG);\r\nif (s & SIG_ATNI)\r\nseq_puts(m, "ATNI ");\r\nif (s & SIG_SELI)\r\nseq_puts(m, "SELI ");\r\nif (s & SIG_BSYI)\r\nseq_puts(m, "BSYI ");\r\nif (s & SIG_REQI)\r\nseq_puts(m, "REQI ");\r\nif (s & SIG_ACKI)\r\nseq_puts(m, "ACKI ");\r\nseq_puts(m, "); ");\r\nseq_printf(m, "SELID(%02x), ", GETPORT(SELID));\r\nseq_printf(m, "STCNT(%d), ", GETSTCNT());\r\nseq_puts(m, "SSTAT2( ");\r\ns = GETPORT(SSTAT2);\r\nif (s & SOFFSET)\r\nseq_puts(m, "SOFFSET ");\r\nif (s & SEMPTY)\r\nseq_puts(m, "SEMPTY ");\r\nif (s & SFULL)\r\nseq_puts(m, "SFULL ");\r\nseq_printf(m, "); SFCNT (%d); ", s & (SFULL | SFCNT));\r\ns = GETPORT(SSTAT3);\r\nseq_printf(m, "SCSICNT (%d), OFFCNT(%d), ", (s & 0xf0) >> 4, s & 0x0f);\r\nseq_puts(m, "SSTAT4( ");\r\ns = GETPORT(SSTAT4);\r\nif (s & SYNCERR)\r\nseq_puts(m, "SYNCERR ");\r\nif (s & FWERR)\r\nseq_puts(m, "FWERR ");\r\nif (s & FRERR)\r\nseq_puts(m, "FRERR ");\r\nseq_puts(m, "); ");\r\nseq_puts(m, "DMACNTRL0( ");\r\ns = GETPORT(DMACNTRL0);\r\nseq_printf(m, "%s ", s & _8BIT ? "8BIT" : "16BIT");\r\nseq_printf(m, "%s ", s & DMA ? "DMA" : "PIO");\r\nseq_printf(m, "%s ", s & WRITE_READ ? "WRITE" : "READ");\r\nif (s & ENDMA)\r\nseq_puts(m, "ENDMA ");\r\nif (s & INTEN)\r\nseq_puts(m, "INTEN ");\r\nif (s & RSTFIFO)\r\nseq_puts(m, "RSTFIFO ");\r\nif (s & SWINT)\r\nseq_puts(m, "SWINT ");\r\nseq_puts(m, "); ");\r\nseq_puts(m, "DMASTAT( ");\r\ns = GETPORT(DMASTAT);\r\nif (s & ATDONE)\r\nseq_puts(m, "ATDONE ");\r\nif (s & WORDRDY)\r\nseq_puts(m, "WORDRDY ");\r\nif (s & DFIFOFULL)\r\nseq_puts(m, "DFIFOFULL ");\r\nif (s & DFIFOEMP)\r\nseq_puts(m, "DFIFOEMP ");\r\nseq_puts(m, ")\n");\r\nseq_puts(m, "enabled interrupts( ");\r\ns = GETPORT(SIMODE0);\r\nif (s & ENSELDO)\r\nseq_puts(m, "ENSELDO ");\r\nif (s & ENSELDI)\r\nseq_puts(m, "ENSELDI ");\r\nif (s & ENSELINGO)\r\nseq_puts(m, "ENSELINGO ");\r\nif (s & ENSWRAP)\r\nseq_puts(m, "ENSWRAP ");\r\nif (s & ENSDONE)\r\nseq_puts(m, "ENSDONE ");\r\nif (s & ENSPIORDY)\r\nseq_puts(m, "ENSPIORDY ");\r\nif (s & ENDMADONE)\r\nseq_puts(m, "ENDMADONE ");\r\ns = GETPORT(SIMODE1);\r\nif (s & ENSELTIMO)\r\nseq_puts(m, "ENSELTIMO ");\r\nif (s & ENATNTARG)\r\nseq_puts(m, "ENATNTARG ");\r\nif (s & ENPHASEMIS)\r\nseq_puts(m, "ENPHASEMIS ");\r\nif (s & ENBUSFREE)\r\nseq_puts(m, "ENBUSFREE ");\r\nif (s & ENSCSIPERR)\r\nseq_puts(m, "ENSCSIPERR ");\r\nif (s & ENPHASECHG)\r\nseq_puts(m, "ENPHASECHG ");\r\nif (s & ENREQINIT)\r\nseq_puts(m, "ENREQINIT ");\r\nseq_puts(m, ")\n");\r\n}\r\nstatic int aha152x_set_info(struct Scsi_Host *shpnt, char *buffer, int length)\r\n{\r\nif(!shpnt || !buffer || length<8 || strncmp("aha152x ", buffer, 8)!=0)\r\nreturn -EINVAL;\r\n#if defined(AHA152X_STAT)\r\nif(length>13 && strncmp("reset", buffer+8, 5)==0) {\r\nint i;\r\nHOSTDATA(shpnt)->total_commands=0;\r\nHOSTDATA(shpnt)->disconnections=0;\r\nHOSTDATA(shpnt)->busfree_without_any_action=0;\r\nHOSTDATA(shpnt)->busfree_without_old_command=0;\r\nHOSTDATA(shpnt)->busfree_without_new_command=0;\r\nHOSTDATA(shpnt)->busfree_without_done_command=0;\r\nHOSTDATA(shpnt)->busfree_with_check_condition=0;\r\nfor (i = idle; i<maxstate; i++) {\r\nHOSTDATA(shpnt)->count[i]=0;\r\nHOSTDATA(shpnt)->count_trans[i]=0;\r\nHOSTDATA(shpnt)->time[i]=0;\r\n}\r\nshost_printk(KERN_INFO, shpnt, "aha152x: stats reset.\n");\r\n} else\r\n#endif\r\n{\r\nreturn -EINVAL;\r\n}\r\nreturn length;\r\n}\r\nstatic int aha152x_show_info(struct seq_file *m, struct Scsi_Host *shpnt)\r\n{\r\nint i;\r\nScsi_Cmnd *ptr;\r\nunsigned long flags;\r\nseq_puts(m, AHA152X_REVID "\n");\r\nseq_printf(m, "ioports 0x%04lx to 0x%04lx\n",\r\nshpnt->io_port, shpnt->io_port + shpnt->n_io_port - 1);\r\nseq_printf(m, "interrupt 0x%02x\n", shpnt->irq);\r\nseq_printf(m, "disconnection/reconnection %s\n",\r\nRECONNECT ? "enabled" : "disabled");\r\nseq_printf(m, "parity checking %s\n",\r\nPARITY ? "enabled" : "disabled");\r\nseq_printf(m, "synchronous transfers %s\n",\r\nSYNCHRONOUS ? "enabled" : "disabled");\r\nseq_printf(m, "%d commands currently queued\n", HOSTDATA(shpnt)->commands);\r\nif(SYNCHRONOUS) {\r\nseq_puts(m, "synchronously operating targets (tick=50 ns):\n");\r\nfor (i = 0; i < 8; i++)\r\nif (HOSTDATA(shpnt)->syncrate[i] & 0x7f)\r\nseq_printf(m, "target %d: period %dT/%dns; req/ack offset %d\n",\r\ni,\r\n(((HOSTDATA(shpnt)->syncrate[i] & 0x70) >> 4) + 2),\r\n(((HOSTDATA(shpnt)->syncrate[i] & 0x70) >> 4) + 2) * 50,\r\nHOSTDATA(shpnt)->syncrate[i] & 0x0f);\r\n}\r\nseq_puts(m, "\nqueue status:\n");\r\nDO_LOCK(flags);\r\nif (ISSUE_SC) {\r\nseq_puts(m, "not yet issued commands:\n");\r\nfor (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr))\r\nget_command(m, ptr);\r\n} else\r\nseq_puts(m, "no not yet issued commands\n");\r\nDO_UNLOCK(flags);\r\nif (CURRENT_SC) {\r\nseq_puts(m, "current command:\n");\r\nget_command(m, CURRENT_SC);\r\n} else\r\nseq_puts(m, "no current command\n");\r\nif (DISCONNECTED_SC) {\r\nseq_puts(m, "disconnected commands:\n");\r\nfor (ptr = DISCONNECTED_SC; ptr; ptr = SCNEXT(ptr))\r\nget_command(m, ptr);\r\n} else\r\nseq_puts(m, "no disconnected commands\n");\r\nget_ports(m, shpnt);\r\n#if defined(AHA152X_STAT)\r\nseq_printf(m, "statistics:\n"\r\n"total commands: %d\n"\r\n"disconnections: %d\n"\r\n"busfree with check condition: %d\n"\r\n"busfree without old command: %d\n"\r\n"busfree without new command: %d\n"\r\n"busfree without done command: %d\n"\r\n"busfree without any action: %d\n"\r\n"state "\r\n"transitions "\r\n"count "\r\n"time\n",\r\nHOSTDATA(shpnt)->total_commands,\r\nHOSTDATA(shpnt)->disconnections,\r\nHOSTDATA(shpnt)->busfree_with_check_condition,\r\nHOSTDATA(shpnt)->busfree_without_old_command,\r\nHOSTDATA(shpnt)->busfree_without_new_command,\r\nHOSTDATA(shpnt)->busfree_without_done_command,\r\nHOSTDATA(shpnt)->busfree_without_any_action);\r\nfor(i=0; i<maxstate; i++) {\r\nseq_printf(m, "%-10s %-12d %-12d %-12ld\n",\r\nstates[i].name,\r\nHOSTDATA(shpnt)->count_trans[i],\r\nHOSTDATA(shpnt)->count[i],\r\nHOSTDATA(shpnt)->time[i]);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int aha152x_adjust_queue(struct scsi_device *device)\r\n{\r\nblk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);\r\nreturn 0;\r\n}\r\nstatic int aha152x_porttest(int io_port)\r\n{\r\nint i;\r\nSETPORT(io_port + O_DMACNTRL1, 0);\r\nfor (i = 0; i < 16; i++)\r\nSETPORT(io_port + O_STACK, i);\r\nSETPORT(io_port + O_DMACNTRL1, 0);\r\nfor (i = 0; i < 16 && GETPORT(io_port + O_STACK) == i; i++)\r\n;\r\nreturn (i == 16);\r\n}\r\nstatic int tc1550_porttest(int io_port)\r\n{\r\nint i;\r\nSETPORT(io_port + O_TC_DMACNTRL1, 0);\r\nfor (i = 0; i < 16; i++)\r\nSETPORT(io_port + O_STACK, i);\r\nSETPORT(io_port + O_TC_DMACNTRL1, 0);\r\nfor (i = 0; i < 16 && GETPORT(io_port + O_TC_STACK) == i; i++)\r\n;\r\nreturn (i == 16);\r\n}\r\nstatic int checksetup(struct aha152x_setup *setup)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ports) && (setup->io_port != ports[i]); i++)\r\n;\r\nif (i == ARRAY_SIZE(ports))\r\nreturn 0;\r\nif (!request_region(setup->io_port, IO_RANGE, "aha152x")) {\r\nprintk(KERN_ERR "aha152x: io port 0x%x busy.\n", setup->io_port);\r\nreturn 0;\r\n}\r\nif( aha152x_porttest(setup->io_port) ) {\r\nsetup->tc1550=0;\r\n} else if( tc1550_porttest(setup->io_port) ) {\r\nsetup->tc1550=1;\r\n} else {\r\nrelease_region(setup->io_port, IO_RANGE);\r\nreturn 0;\r\n}\r\nrelease_region(setup->io_port, IO_RANGE);\r\nif ((setup->irq < IRQ_MIN) || (setup->irq > IRQ_MAX))\r\nreturn 0;\r\nif ((setup->scsiid < 0) || (setup->scsiid > 7))\r\nreturn 0;\r\nif ((setup->reconnect < 0) || (setup->reconnect > 1))\r\nreturn 0;\r\nif ((setup->parity < 0) || (setup->parity > 1))\r\nreturn 0;\r\nif ((setup->synchronous < 0) || (setup->synchronous > 1))\r\nreturn 0;\r\nif ((setup->ext_trans < 0) || (setup->ext_trans > 1))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int __init aha152x_init(void)\r\n{\r\nint i, j, ok;\r\n#if defined(AUTOCONF)\r\naha152x_config conf;\r\n#endif\r\n#ifdef __ISAPNP__\r\nstruct pnp_dev *dev=NULL, *pnpdev[2] = {NULL, NULL};\r\n#endif\r\nif ( setup_count ) {\r\nprintk(KERN_INFO "aha152x: processing commandline: ");\r\nfor (i = 0; i<setup_count; i++) {\r\nif (!checksetup(&setup[i])) {\r\nprintk(KERN_ERR "\naha152x: %s\n", setup[i].conf);\r\nprintk(KERN_ERR "aha152x: invalid line\n");\r\n}\r\n}\r\nprintk("ok\n");\r\n}\r\n#if defined(SETUP0)\r\nif (setup_count < ARRAY_SIZE(setup)) {\r\nstruct aha152x_setup override = SETUP0;\r\nif (setup_count == 0 || (override.io_port != setup[0].io_port)) {\r\nif (!checksetup(&override)) {\r\nprintk(KERN_ERR "\naha152x: invalid override SETUP0={0x%x,%d,%d,%d,%d,%d,%d,%d}\n",\r\noverride.io_port,\r\noverride.irq,\r\noverride.scsiid,\r\noverride.reconnect,\r\noverride.parity,\r\noverride.synchronous,\r\noverride.delay,\r\noverride.ext_trans);\r\n} else\r\nsetup[setup_count++] = override;\r\n}\r\n}\r\n#endif\r\n#if defined(SETUP1)\r\nif (setup_count < ARRAY_SIZE(setup)) {\r\nstruct aha152x_setup override = SETUP1;\r\nif (setup_count == 0 || (override.io_port != setup[0].io_port)) {\r\nif (!checksetup(&override)) {\r\nprintk(KERN_ERR "\naha152x: invalid override SETUP1={0x%x,%d,%d,%d,%d,%d,%d,%d}\n",\r\noverride.io_port,\r\noverride.irq,\r\noverride.scsiid,\r\noverride.reconnect,\r\noverride.parity,\r\noverride.synchronous,\r\noverride.delay,\r\noverride.ext_trans);\r\n} else\r\nsetup[setup_count++] = override;\r\n}\r\n}\r\n#endif\r\n#if defined(MODULE)\r\nif (setup_count<ARRAY_SIZE(setup) && (aha152x[0]!=0 || io[0]!=0 || irq[0]!=0)) {\r\nif(aha152x[0]!=0) {\r\nsetup[setup_count].conf = "";\r\nsetup[setup_count].io_port = aha152x[0];\r\nsetup[setup_count].irq = aha152x[1];\r\nsetup[setup_count].scsiid = aha152x[2];\r\nsetup[setup_count].reconnect = aha152x[3];\r\nsetup[setup_count].parity = aha152x[4];\r\nsetup[setup_count].synchronous = aha152x[5];\r\nsetup[setup_count].delay = aha152x[6];\r\nsetup[setup_count].ext_trans = aha152x[7];\r\n} else if (io[0] != 0 || irq[0] != 0) {\r\nif(io[0]!=0) setup[setup_count].io_port = io[0];\r\nif(irq[0]!=0) setup[setup_count].irq = irq[0];\r\nsetup[setup_count].scsiid = scsiid[0];\r\nsetup[setup_count].reconnect = reconnect[0];\r\nsetup[setup_count].parity = parity[0];\r\nsetup[setup_count].synchronous = sync[0];\r\nsetup[setup_count].delay = delay[0];\r\nsetup[setup_count].ext_trans = exttrans[0];\r\n}\r\nif (checksetup(&setup[setup_count]))\r\nsetup_count++;\r\nelse\r\nprintk(KERN_ERR "aha152x: invalid module params io=0x%x, irq=%d,scsiid=%d,reconnect=%d,parity=%d,sync=%d,delay=%d,exttrans=%d\n",\r\nsetup[setup_count].io_port,\r\nsetup[setup_count].irq,\r\nsetup[setup_count].scsiid,\r\nsetup[setup_count].reconnect,\r\nsetup[setup_count].parity,\r\nsetup[setup_count].synchronous,\r\nsetup[setup_count].delay,\r\nsetup[setup_count].ext_trans);\r\n}\r\nif (setup_count<ARRAY_SIZE(setup) && (aha152x1[0]!=0 || io[1]!=0 || irq[1]!=0)) {\r\nif(aha152x1[0]!=0) {\r\nsetup[setup_count].conf = "";\r\nsetup[setup_count].io_port = aha152x1[0];\r\nsetup[setup_count].irq = aha152x1[1];\r\nsetup[setup_count].scsiid = aha152x1[2];\r\nsetup[setup_count].reconnect = aha152x1[3];\r\nsetup[setup_count].parity = aha152x1[4];\r\nsetup[setup_count].synchronous = aha152x1[5];\r\nsetup[setup_count].delay = aha152x1[6];\r\nsetup[setup_count].ext_trans = aha152x1[7];\r\n} else if (io[1] != 0 || irq[1] != 0) {\r\nif(io[1]!=0) setup[setup_count].io_port = io[1];\r\nif(irq[1]!=0) setup[setup_count].irq = irq[1];\r\nsetup[setup_count].scsiid = scsiid[1];\r\nsetup[setup_count].reconnect = reconnect[1];\r\nsetup[setup_count].parity = parity[1];\r\nsetup[setup_count].synchronous = sync[1];\r\nsetup[setup_count].delay = delay[1];\r\nsetup[setup_count].ext_trans = exttrans[1];\r\n}\r\nif (checksetup(&setup[setup_count]))\r\nsetup_count++;\r\nelse\r\nprintk(KERN_ERR "aha152x: invalid module params io=0x%x, irq=%d,scsiid=%d,reconnect=%d,parity=%d,sync=%d,delay=%d,exttrans=%d\n",\r\nsetup[setup_count].io_port,\r\nsetup[setup_count].irq,\r\nsetup[setup_count].scsiid,\r\nsetup[setup_count].reconnect,\r\nsetup[setup_count].parity,\r\nsetup[setup_count].synchronous,\r\nsetup[setup_count].delay,\r\nsetup[setup_count].ext_trans);\r\n}\r\n#endif\r\n#ifdef __ISAPNP__\r\nfor(i=0; setup_count<ARRAY_SIZE(setup) && id_table[i].vendor; i++) {\r\nwhile ( setup_count<ARRAY_SIZE(setup) &&\r\n(dev=pnp_find_dev(NULL, id_table[i].vendor, id_table[i].function, dev)) ) {\r\nif (pnp_device_attach(dev) < 0)\r\ncontinue;\r\nif (pnp_activate_dev(dev) < 0) {\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nif (!pnp_port_valid(dev, 0)) {\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nif (setup_count==1 && pnp_port_start(dev, 0)==setup[0].io_port) {\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nsetup[setup_count].io_port = pnp_port_start(dev, 0);\r\nsetup[setup_count].irq = pnp_irq(dev, 0);\r\nsetup[setup_count].scsiid = 7;\r\nsetup[setup_count].reconnect = 1;\r\nsetup[setup_count].parity = 1;\r\nsetup[setup_count].synchronous = 1;\r\nsetup[setup_count].delay = DELAY_DEFAULT;\r\nsetup[setup_count].ext_trans = 0;\r\n#if defined(__ISAPNP__)\r\npnpdev[setup_count] = dev;\r\n#endif\r\nprintk (KERN_INFO\r\n"aha152x: found ISAPnP adapter at io=0x%03x, irq=%d\n",\r\nsetup[setup_count].io_port, setup[setup_count].irq);\r\nsetup_count++;\r\n}\r\n}\r\n#endif\r\n#if defined(AUTOCONF)\r\nif (setup_count<ARRAY_SIZE(setup)) {\r\n#if !defined(SKIP_BIOSTEST)\r\nok = 0;\r\nfor (i = 0; i < ARRAY_SIZE(addresses) && !ok; i++) {\r\nvoid __iomem *p = ioremap(addresses[i], 0x4000);\r\nif (!p)\r\ncontinue;\r\nfor (j = 0; j<ARRAY_SIZE(signatures) && !ok; j++)\r\nok = check_signature(p + signatures[j].sig_offset,\r\nsignatures[j].signature, signatures[j].sig_length);\r\niounmap(p);\r\n}\r\nif (!ok && setup_count == 0)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "aha152x: BIOS test: passed, ");\r\n#else\r\nprintk(KERN_INFO "aha152x: ");\r\n#endif\r\nok = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ports) && setup_count < 2; i++) {\r\nif ((setup_count == 1) && (setup[0].io_port == ports[i]))\r\ncontinue;\r\nif (!request_region(ports[i], IO_RANGE, "aha152x")) {\r\nprintk(KERN_ERR "aha152x: io port 0x%x busy.\n", ports[i]);\r\ncontinue;\r\n}\r\nif (aha152x_porttest(ports[i])) {\r\nsetup[setup_count].tc1550 = 0;\r\nconf.cf_port =\r\n(GETPORT(ports[i] + O_PORTA) << 8) + GETPORT(ports[i] + O_PORTB);\r\n} else if (tc1550_porttest(ports[i])) {\r\nsetup[setup_count].tc1550 = 1;\r\nconf.cf_port =\r\n(GETPORT(ports[i] + O_TC_PORTA) << 8) + GETPORT(ports[i] + O_TC_PORTB);\r\n} else {\r\nrelease_region(ports[i], IO_RANGE);\r\ncontinue;\r\n}\r\nrelease_region(ports[i], IO_RANGE);\r\nok++;\r\nsetup[setup_count].io_port = ports[i];\r\nsetup[setup_count].irq = IRQ_MIN + conf.cf_irq;\r\nsetup[setup_count].scsiid = conf.cf_id;\r\nsetup[setup_count].reconnect = conf.cf_tardisc;\r\nsetup[setup_count].parity = !conf.cf_parity;\r\nsetup[setup_count].synchronous = conf.cf_syncneg;\r\nsetup[setup_count].delay = DELAY_DEFAULT;\r\nsetup[setup_count].ext_trans = 0;\r\nsetup_count++;\r\n}\r\nif (ok)\r\nprintk("auto configuration: ok, ");\r\n}\r\n#endif\r\nprintk("%d controller(s) configured\n", setup_count);\r\nfor (i=0; i<setup_count; i++) {\r\nif ( request_region(setup[i].io_port, IO_RANGE, "aha152x") ) {\r\nstruct Scsi_Host *shpnt = aha152x_probe_one(&setup[i]);\r\nif( !shpnt ) {\r\nrelease_region(setup[i].io_port, IO_RANGE);\r\n#if defined(__ISAPNP__)\r\n} else if( pnpdev[i] ) {\r\nHOSTDATA(shpnt)->pnpdev=pnpdev[i];\r\npnpdev[i]=NULL;\r\n#endif\r\n}\r\n} else {\r\nprintk(KERN_ERR "aha152x: io port 0x%x busy.\n", setup[i].io_port);\r\n}\r\n#if defined(__ISAPNP__)\r\nif( pnpdev[i] )\r\npnp_device_detach(pnpdev[i]);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit aha152x_exit(void)\r\n{\r\nstruct aha152x_hostdata *hd, *tmp;\r\nlist_for_each_entry_safe(hd, tmp, &aha152x_host_list, host_list) {\r\nstruct Scsi_Host *shost = container_of((void *)hd, struct Scsi_Host, hostdata);\r\naha152x_release(shost);\r\n}\r\n}\r\nstatic int __init aha152x_setup(char *str)\r\n{\r\nint ints[10];\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\nif(setup_count>=ARRAY_SIZE(setup)) {\r\nprintk(KERN_ERR "aha152x: you can only configure up to two controllers\n");\r\nreturn 1;\r\n}\r\nsetup[setup_count].conf = str;\r\nsetup[setup_count].io_port = ints[0] >= 1 ? ints[1] : 0x340;\r\nsetup[setup_count].irq = ints[0] >= 2 ? ints[2] : 11;\r\nsetup[setup_count].scsiid = ints[0] >= 3 ? ints[3] : 7;\r\nsetup[setup_count].reconnect = ints[0] >= 4 ? ints[4] : 1;\r\nsetup[setup_count].parity = ints[0] >= 5 ? ints[5] : 1;\r\nsetup[setup_count].synchronous = ints[0] >= 6 ? ints[6] : 1;\r\nsetup[setup_count].delay = ints[0] >= 7 ? ints[7] : DELAY_DEFAULT;\r\nsetup[setup_count].ext_trans = ints[0] >= 8 ? ints[8] : 0;\r\nif (ints[0] > 8) {\r\nprintk(KERN_NOTICE "aha152x: usage: aha152x=<IOBASE>[,<IRQ>[,<SCSI ID>"\r\n"[,<RECONNECT>[,<PARITY>[,<SYNCHRONOUS>[,<DELAY>[,<EXT_TRANS>]]]]]]]\n");\r\n} else {\r\nsetup_count++;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}
