static inline struct board_info *to_dm9000_board(struct net_device *dev)\r\n{\r\nreturn netdev_priv(dev);\r\n}\r\nstatic u8\r\nior(struct board_info *db, int reg)\r\n{\r\nwriteb(reg, db->io_addr);\r\nreturn readb(db->io_data);\r\n}\r\nstatic void\r\niow(struct board_info *db, int reg, int value)\r\n{\r\nwriteb(reg, db->io_addr);\r\nwriteb(value, db->io_data);\r\n}\r\nstatic void\r\ndm9000_reset(struct board_info *db)\r\n{\r\ndev_dbg(db->dev, "resetting device\n");\r\niow(db, DM9000_NCR, NCR_RST | NCR_MAC_LBK);\r\nudelay(100);\r\nif (ior(db, DM9000_NCR) & 1)\r\ndev_err(db->dev, "dm9000 did not respond to first reset\n");\r\niow(db, DM9000_NCR, 0);\r\niow(db, DM9000_NCR, NCR_RST | NCR_MAC_LBK);\r\nudelay(100);\r\nif (ior(db, DM9000_NCR) & 1)\r\ndev_err(db->dev, "dm9000 did not respond to second reset\n");\r\n}\r\nstatic void dm9000_outblk_8bit(void __iomem *reg, void *data, int count)\r\n{\r\niowrite8_rep(reg, data, count);\r\n}\r\nstatic void dm9000_outblk_16bit(void __iomem *reg, void *data, int count)\r\n{\r\niowrite16_rep(reg, data, (count+1) >> 1);\r\n}\r\nstatic void dm9000_outblk_32bit(void __iomem *reg, void *data, int count)\r\n{\r\niowrite32_rep(reg, data, (count+3) >> 2);\r\n}\r\nstatic void dm9000_inblk_8bit(void __iomem *reg, void *data, int count)\r\n{\r\nioread8_rep(reg, data, count);\r\n}\r\nstatic void dm9000_inblk_16bit(void __iomem *reg, void *data, int count)\r\n{\r\nioread16_rep(reg, data, (count+1) >> 1);\r\n}\r\nstatic void dm9000_inblk_32bit(void __iomem *reg, void *data, int count)\r\n{\r\nioread32_rep(reg, data, (count+3) >> 2);\r\n}\r\nstatic void dm9000_dumpblk_8bit(void __iomem *reg, int count)\r\n{\r\nint i;\r\nint tmp;\r\nfor (i = 0; i < count; i++)\r\ntmp = readb(reg);\r\n}\r\nstatic void dm9000_dumpblk_16bit(void __iomem *reg, int count)\r\n{\r\nint i;\r\nint tmp;\r\ncount = (count + 1) >> 1;\r\nfor (i = 0; i < count; i++)\r\ntmp = readw(reg);\r\n}\r\nstatic void dm9000_dumpblk_32bit(void __iomem *reg, int count)\r\n{\r\nint i;\r\nint tmp;\r\ncount = (count + 3) >> 2;\r\nfor (i = 0; i < count; i++)\r\ntmp = readl(reg);\r\n}\r\nstatic void dm9000_msleep(struct board_info *db, unsigned int ms)\r\n{\r\nif (db->in_suspend || db->in_timeout)\r\nmdelay(ms);\r\nelse\r\nmsleep(ms);\r\n}\r\nstatic int\r\ndm9000_phy_read(struct net_device *dev, int phy_reg_unused, int reg)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\nunsigned long flags;\r\nunsigned int reg_save;\r\nint ret;\r\nmutex_lock(&db->addr_lock);\r\nspin_lock_irqsave(&db->lock, flags);\r\nreg_save = readb(db->io_addr);\r\niow(db, DM9000_EPAR, DM9000_PHY | reg);\r\niow(db, DM9000_EPCR, EPCR_ERPRR | EPCR_EPOS);\r\nwriteb(reg_save, db->io_addr);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\ndm9000_msleep(db, 1);\r\nspin_lock_irqsave(&db->lock, flags);\r\nreg_save = readb(db->io_addr);\r\niow(db, DM9000_EPCR, 0x0);\r\nret = (ior(db, DM9000_EPDRH) << 8) | ior(db, DM9000_EPDRL);\r\nwriteb(reg_save, db->io_addr);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nmutex_unlock(&db->addr_lock);\r\ndm9000_dbg(db, 5, "phy_read[%02x] -> %04x\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic void\r\ndm9000_phy_write(struct net_device *dev,\r\nint phyaddr_unused, int reg, int value)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\nunsigned long flags;\r\nunsigned long reg_save;\r\ndm9000_dbg(db, 5, "phy_write[%02x] = %04x\n", reg, value);\r\nif (!db->in_timeout)\r\nmutex_lock(&db->addr_lock);\r\nspin_lock_irqsave(&db->lock, flags);\r\nreg_save = readb(db->io_addr);\r\niow(db, DM9000_EPAR, DM9000_PHY | reg);\r\niow(db, DM9000_EPDRL, value);\r\niow(db, DM9000_EPDRH, value >> 8);\r\niow(db, DM9000_EPCR, EPCR_EPOS | EPCR_ERPRW);\r\nwriteb(reg_save, db->io_addr);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\ndm9000_msleep(db, 1);\r\nspin_lock_irqsave(&db->lock, flags);\r\nreg_save = readb(db->io_addr);\r\niow(db, DM9000_EPCR, 0x0);\r\nwriteb(reg_save, db->io_addr);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nif (!db->in_timeout)\r\nmutex_unlock(&db->addr_lock);\r\n}\r\nstatic void dm9000_set_io(struct board_info *db, int byte_width)\r\n{\r\nswitch (byte_width) {\r\ncase 1:\r\ndb->dumpblk = dm9000_dumpblk_8bit;\r\ndb->outblk = dm9000_outblk_8bit;\r\ndb->inblk = dm9000_inblk_8bit;\r\nbreak;\r\ncase 3:\r\ndev_dbg(db->dev, ": 3 byte IO, falling back to 16bit\n");\r\ncase 2:\r\ndb->dumpblk = dm9000_dumpblk_16bit;\r\ndb->outblk = dm9000_outblk_16bit;\r\ndb->inblk = dm9000_inblk_16bit;\r\nbreak;\r\ncase 4:\r\ndefault:\r\ndb->dumpblk = dm9000_dumpblk_32bit;\r\ndb->outblk = dm9000_outblk_32bit;\r\ndb->inblk = dm9000_inblk_32bit;\r\nbreak;\r\n}\r\n}\r\nstatic void dm9000_schedule_poll(struct board_info *db)\r\n{\r\nif (db->type == TYPE_DM9000E)\r\nschedule_delayed_work(&db->phy_poll, HZ * 2);\r\n}\r\nstatic int dm9000_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nreturn generic_mii_ioctl(&dm->mii, if_mii(req), cmd, NULL);\r\n}\r\nstatic unsigned int\r\ndm9000_read_locked(struct board_info *db, int reg)\r\n{\r\nunsigned long flags;\r\nunsigned int ret;\r\nspin_lock_irqsave(&db->lock, flags);\r\nret = ior(db, reg);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int dm9000_wait_eeprom(struct board_info *db)\r\n{\r\nunsigned int status;\r\nint timeout = 8;\r\nwhile (1) {\r\nstatus = dm9000_read_locked(db, DM9000_EPCR);\r\nif ((status & EPCR_ERRE) == 0)\r\nbreak;\r\nmsleep(1);\r\nif (timeout-- < 0) {\r\ndev_dbg(db->dev, "timeout waiting EEPROM\n");\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ndm9000_read_eeprom(struct board_info *db, int offset, u8 *to)\r\n{\r\nunsigned long flags;\r\nif (db->flags & DM9000_PLATF_NO_EEPROM) {\r\nto[0] = 0xff;\r\nto[1] = 0xff;\r\nreturn;\r\n}\r\nmutex_lock(&db->addr_lock);\r\nspin_lock_irqsave(&db->lock, flags);\r\niow(db, DM9000_EPAR, offset);\r\niow(db, DM9000_EPCR, EPCR_ERPRR);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\ndm9000_wait_eeprom(db);\r\nmsleep(1);\r\nspin_lock_irqsave(&db->lock, flags);\r\niow(db, DM9000_EPCR, 0x0);\r\nto[0] = ior(db, DM9000_EPDRL);\r\nto[1] = ior(db, DM9000_EPDRH);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nmutex_unlock(&db->addr_lock);\r\n}\r\nstatic void\r\ndm9000_write_eeprom(struct board_info *db, int offset, u8 *data)\r\n{\r\nunsigned long flags;\r\nif (db->flags & DM9000_PLATF_NO_EEPROM)\r\nreturn;\r\nmutex_lock(&db->addr_lock);\r\nspin_lock_irqsave(&db->lock, flags);\r\niow(db, DM9000_EPAR, offset);\r\niow(db, DM9000_EPDRH, data[1]);\r\niow(db, DM9000_EPDRL, data[0]);\r\niow(db, DM9000_EPCR, EPCR_WEP | EPCR_ERPRW);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\ndm9000_wait_eeprom(db);\r\nmdelay(1);\r\nspin_lock_irqsave(&db->lock, flags);\r\niow(db, DM9000_EPCR, 0);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nmutex_unlock(&db->addr_lock);\r\n}\r\nstatic void dm9000_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nstrlcpy(info->driver, CARDNAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, to_platform_device(dm->dev)->name,\r\nsizeof(info->bus_info));\r\n}\r\nstatic u32 dm9000_get_msglevel(struct net_device *dev)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nreturn dm->msg_enable;\r\n}\r\nstatic void dm9000_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\ndm->msg_enable = value;\r\n}\r\nstatic int dm9000_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nmii_ethtool_gset(&dm->mii, cmd);\r\nreturn 0;\r\n}\r\nstatic int dm9000_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nreturn mii_ethtool_sset(&dm->mii, cmd);\r\n}\r\nstatic int dm9000_nway_reset(struct net_device *dev)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nreturn mii_nway_restart(&dm->mii);\r\n}\r\nstatic int dm9000_set_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nnetdev_features_t changed = dev->features ^ features;\r\nunsigned long flags;\r\nif (!(changed & NETIF_F_RXCSUM))\r\nreturn 0;\r\nspin_lock_irqsave(&dm->lock, flags);\r\niow(dm, DM9000_RCSR, (features & NETIF_F_RXCSUM) ? RCSR_CSUM : 0);\r\nspin_unlock_irqrestore(&dm->lock, flags);\r\nreturn 0;\r\n}\r\nstatic u32 dm9000_get_link(struct net_device *dev)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nu32 ret;\r\nif (dm->flags & DM9000_PLATF_EXT_PHY)\r\nret = mii_link_ok(&dm->mii);\r\nelse\r\nret = dm9000_read_locked(dm, DM9000_NSR) & NSR_LINKST ? 1 : 0;\r\nreturn ret;\r\n}\r\nstatic int dm9000_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn 128;\r\n}\r\nstatic int dm9000_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nint offset = ee->offset;\r\nint len = ee->len;\r\nint i;\r\nif ((len & 1) != 0 || (offset & 1) != 0)\r\nreturn -EINVAL;\r\nif (dm->flags & DM9000_PLATF_NO_EEPROM)\r\nreturn -ENOENT;\r\nee->magic = DM_EEPROM_MAGIC;\r\nfor (i = 0; i < len; i += 2)\r\ndm9000_read_eeprom(dm, (offset + i) / 2, data + i);\r\nreturn 0;\r\n}\r\nstatic int dm9000_set_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nint offset = ee->offset;\r\nint len = ee->len;\r\nint done;\r\nif (dm->flags & DM9000_PLATF_NO_EEPROM)\r\nreturn -ENOENT;\r\nif (ee->magic != DM_EEPROM_MAGIC)\r\nreturn -EINVAL;\r\nwhile (len > 0) {\r\nif (len & 1 || offset & 1) {\r\nint which = offset & 1;\r\nu8 tmp[2];\r\ndm9000_read_eeprom(dm, offset / 2, tmp);\r\ntmp[which] = *data;\r\ndm9000_write_eeprom(dm, offset / 2, tmp);\r\ndone = 1;\r\n} else {\r\ndm9000_write_eeprom(dm, offset / 2, data);\r\ndone = 2;\r\n}\r\ndata += done;\r\noffset += done;\r\nlen -= done;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dm9000_get_wol(struct net_device *dev, struct ethtool_wolinfo *w)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nmemset(w, 0, sizeof(struct ethtool_wolinfo));\r\nw->supported = dm->wake_supported ? WAKE_MAGIC : 0;\r\nw->wolopts = dm->wake_state;\r\n}\r\nstatic int dm9000_set_wol(struct net_device *dev, struct ethtool_wolinfo *w)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nunsigned long flags;\r\nu32 opts = w->wolopts;\r\nu32 wcr = 0;\r\nif (!dm->wake_supported)\r\nreturn -EOPNOTSUPP;\r\nif (opts & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\nif (opts & WAKE_MAGIC)\r\nwcr |= WCR_MAGICEN;\r\nmutex_lock(&dm->addr_lock);\r\nspin_lock_irqsave(&dm->lock, flags);\r\niow(dm, DM9000_WCR, wcr);\r\nspin_unlock_irqrestore(&dm->lock, flags);\r\nmutex_unlock(&dm->addr_lock);\r\nif (dm->wake_state != opts) {\r\nif (!dm->wake_state)\r\nirq_set_irq_wake(dm->irq_wake, 1);\r\nelse if (dm->wake_state && !opts)\r\nirq_set_irq_wake(dm->irq_wake, 0);\r\n}\r\ndm->wake_state = opts;\r\nreturn 0;\r\n}\r\nstatic void dm9000_show_carrier(struct board_info *db,\r\nunsigned carrier, unsigned nsr)\r\n{\r\nint lpa;\r\nstruct net_device *ndev = db->ndev;\r\nstruct mii_if_info *mii = &db->mii;\r\nunsigned ncr = dm9000_read_locked(db, DM9000_NCR);\r\nif (carrier) {\r\nlpa = mii->mdio_read(mii->dev, mii->phy_id, MII_LPA);\r\ndev_info(db->dev,\r\n"%s: link up, %dMbps, %s-duplex, lpa 0x%04X\n",\r\nndev->name, (nsr & NSR_SPEED) ? 10 : 100,\r\n(ncr & NCR_FDX) ? "full" : "half", lpa);\r\n} else {\r\ndev_info(db->dev, "%s: link down\n", ndev->name);\r\n}\r\n}\r\nstatic void\r\ndm9000_poll_work(struct work_struct *w)\r\n{\r\nstruct delayed_work *dw = to_delayed_work(w);\r\nstruct board_info *db = container_of(dw, struct board_info, phy_poll);\r\nstruct net_device *ndev = db->ndev;\r\nif (db->flags & DM9000_PLATF_SIMPLE_PHY &&\r\n!(db->flags & DM9000_PLATF_EXT_PHY)) {\r\nunsigned nsr = dm9000_read_locked(db, DM9000_NSR);\r\nunsigned old_carrier = netif_carrier_ok(ndev) ? 1 : 0;\r\nunsigned new_carrier;\r\nnew_carrier = (nsr & NSR_LINKST) ? 1 : 0;\r\nif (old_carrier != new_carrier) {\r\nif (netif_msg_link(db))\r\ndm9000_show_carrier(db, new_carrier, nsr);\r\nif (!new_carrier)\r\nnetif_carrier_off(ndev);\r\nelse\r\nnetif_carrier_on(ndev);\r\n}\r\n} else\r\nmii_check_media(&db->mii, netif_msg_link(db), 0);\r\nif (netif_running(ndev))\r\ndm9000_schedule_poll(db);\r\n}\r\nstatic void\r\ndm9000_release_board(struct platform_device *pdev, struct board_info *db)\r\n{\r\niounmap(db->io_addr);\r\niounmap(db->io_data);\r\nif (db->data_req)\r\nrelease_resource(db->data_req);\r\nkfree(db->data_req);\r\nif (db->addr_req)\r\nrelease_resource(db->addr_req);\r\nkfree(db->addr_req);\r\n}\r\nstatic unsigned char dm9000_type_to_char(enum dm9000_type type)\r\n{\r\nswitch (type) {\r\ncase TYPE_DM9000E: return 'e';\r\ncase TYPE_DM9000A: return 'a';\r\ncase TYPE_DM9000B: return 'b';\r\n}\r\nreturn '?';\r\n}\r\nstatic void\r\ndm9000_hash_table_unlocked(struct net_device *dev)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nint i, oft;\r\nu32 hash_val;\r\nu16 hash_table[4] = { 0, 0, 0, 0x8000 };\r\nu8 rcr = RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN;\r\ndm9000_dbg(db, 1, "entering %s\n", __func__);\r\nfor (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)\r\niow(db, oft, dev->dev_addr[i]);\r\nif (dev->flags & IFF_PROMISC)\r\nrcr |= RCR_PRMSC;\r\nif (dev->flags & IFF_ALLMULTI)\r\nrcr |= RCR_ALL;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nhash_val = ether_crc_le(6, ha->addr) & 0x3f;\r\nhash_table[hash_val / 16] |= (u16) 1 << (hash_val % 16);\r\n}\r\nfor (i = 0, oft = DM9000_MAR; i < 4; i++) {\r\niow(db, oft++, hash_table[i]);\r\niow(db, oft++, hash_table[i] >> 8);\r\n}\r\niow(db, DM9000_RCR, rcr);\r\n}\r\nstatic void\r\ndm9000_hash_table(struct net_device *dev)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&db->lock, flags);\r\ndm9000_hash_table_unlocked(dev);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic void\r\ndm9000_mask_interrupts(struct board_info *db)\r\n{\r\niow(db, DM9000_IMR, IMR_PAR);\r\n}\r\nstatic void\r\ndm9000_unmask_interrupts(struct board_info *db)\r\n{\r\niow(db, DM9000_IMR, db->imr_all);\r\n}\r\nstatic void\r\ndm9000_init_dm9000(struct net_device *dev)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\nunsigned int imr;\r\nunsigned int ncr;\r\ndm9000_dbg(db, 1, "entering %s\n", __func__);\r\ndm9000_reset(db);\r\ndm9000_mask_interrupts(db);\r\ndb->io_mode = ior(db, DM9000_ISR) >> 6;\r\nif (dev->hw_features & NETIF_F_RXCSUM)\r\niow(db, DM9000_RCSR,\r\n(dev->features & NETIF_F_RXCSUM) ? RCSR_CSUM : 0);\r\niow(db, DM9000_GPCR, GPCR_GEP_CNTL);\r\niow(db, DM9000_GPR, 0);\r\nif (db->type == TYPE_DM9000B) {\r\ndm9000_phy_write(dev, 0, MII_BMCR, BMCR_RESET);\r\ndm9000_phy_write(dev, 0, MII_DM_DSPCR, DSPCR_INIT_PARAM);\r\n}\r\nncr = (db->flags & DM9000_PLATF_EXT_PHY) ? NCR_EXT_PHY : 0;\r\nif (db->wake_supported)\r\nncr |= NCR_WAKEEN;\r\niow(db, DM9000_NCR, ncr);\r\niow(db, DM9000_TCR, 0);\r\niow(db, DM9000_BPTR, 0x3f);\r\niow(db, DM9000_FCR, 0xff);\r\niow(db, DM9000_SMCR, 0);\r\niow(db, DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);\r\niow(db, DM9000_ISR, ISR_CLR_STATUS);\r\ndm9000_hash_table_unlocked(dev);\r\nimr = IMR_PAR | IMR_PTM | IMR_PRM;\r\nif (db->type != TYPE_DM9000E)\r\nimr |= IMR_LNKCHNG;\r\ndb->imr_all = imr;\r\ndb->tx_pkt_cnt = 0;\r\ndb->queue_pkt_len = 0;\r\nnetif_trans_update(dev);\r\n}\r\nstatic void dm9000_timeout(struct net_device *dev)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\nu8 reg_save;\r\nunsigned long flags;\r\nspin_lock_irqsave(&db->lock, flags);\r\ndb->in_timeout = 1;\r\nreg_save = readb(db->io_addr);\r\nnetif_stop_queue(dev);\r\ndm9000_init_dm9000(dev);\r\ndm9000_unmask_interrupts(db);\r\nnetif_trans_update(dev);\r\nnetif_wake_queue(dev);\r\nwriteb(reg_save, db->io_addr);\r\ndb->in_timeout = 0;\r\nspin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic void dm9000_send_packet(struct net_device *dev,\r\nint ip_summed,\r\nu16 pkt_len)\r\n{\r\nstruct board_info *dm = to_dm9000_board(dev);\r\nif (dm->ip_summed != ip_summed) {\r\nif (ip_summed == CHECKSUM_NONE)\r\niow(dm, DM9000_TCCR, 0);\r\nelse\r\niow(dm, DM9000_TCCR, TCCR_IP | TCCR_UDP | TCCR_TCP);\r\ndm->ip_summed = ip_summed;\r\n}\r\niow(dm, DM9000_TXPLL, pkt_len);\r\niow(dm, DM9000_TXPLH, pkt_len >> 8);\r\niow(dm, DM9000_TCR, TCR_TXREQ);\r\n}\r\nstatic int\r\ndm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct board_info *db = netdev_priv(dev);\r\ndm9000_dbg(db, 3, "%s:\n", __func__);\r\nif (db->tx_pkt_cnt > 1)\r\nreturn NETDEV_TX_BUSY;\r\nspin_lock_irqsave(&db->lock, flags);\r\nwriteb(DM9000_MWCMD, db->io_addr);\r\n(db->outblk)(db->io_data, skb->data, skb->len);\r\ndev->stats.tx_bytes += skb->len;\r\ndb->tx_pkt_cnt++;\r\nif (db->tx_pkt_cnt == 1) {\r\ndm9000_send_packet(dev, skb->ip_summed, skb->len);\r\n} else {\r\ndb->queue_pkt_len = skb->len;\r\ndb->queue_ip_summed = skb->ip_summed;\r\nnetif_stop_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&db->lock, flags);\r\ndev_consume_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void dm9000_tx_done(struct net_device *dev, struct board_info *db)\r\n{\r\nint tx_status = ior(db, DM9000_NSR);\r\nif (tx_status & (NSR_TX2END | NSR_TX1END)) {\r\ndb->tx_pkt_cnt--;\r\ndev->stats.tx_packets++;\r\nif (netif_msg_tx_done(db))\r\ndev_dbg(db->dev, "tx done, NSR %02x\n", tx_status);\r\nif (db->tx_pkt_cnt > 0)\r\ndm9000_send_packet(dev, db->queue_ip_summed,\r\ndb->queue_pkt_len);\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic void\r\ndm9000_rx(struct net_device *dev)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\nstruct dm9000_rxhdr rxhdr;\r\nstruct sk_buff *skb;\r\nu8 rxbyte, *rdptr;\r\nbool GoodPacket;\r\nint RxLen;\r\ndo {\r\nior(db, DM9000_MRCMDX);\r\nrxbyte = readb(db->io_data);\r\nif (rxbyte & DM9000_PKT_ERR) {\r\ndev_warn(db->dev, "status check fail: %d\n", rxbyte);\r\niow(db, DM9000_RCR, 0x00);\r\nreturn;\r\n}\r\nif (!(rxbyte & DM9000_PKT_RDY))\r\nreturn;\r\nGoodPacket = true;\r\nwriteb(DM9000_MRCMD, db->io_addr);\r\n(db->inblk)(db->io_data, &rxhdr, sizeof(rxhdr));\r\nRxLen = le16_to_cpu(rxhdr.RxLen);\r\nif (netif_msg_rx_status(db))\r\ndev_dbg(db->dev, "RX: status %02x, length %04x\n",\r\nrxhdr.RxStatus, RxLen);\r\nif (RxLen < 0x40) {\r\nGoodPacket = false;\r\nif (netif_msg_rx_err(db))\r\ndev_dbg(db->dev, "RX: Bad Packet (runt)\n");\r\n}\r\nif (RxLen > DM9000_PKT_MAX) {\r\ndev_dbg(db->dev, "RST: RX Len:%x\n", RxLen);\r\n}\r\nif (rxhdr.RxStatus & (RSR_FOE | RSR_CE | RSR_AE |\r\nRSR_PLE | RSR_RWTO |\r\nRSR_LCS | RSR_RF)) {\r\nGoodPacket = false;\r\nif (rxhdr.RxStatus & RSR_FOE) {\r\nif (netif_msg_rx_err(db))\r\ndev_dbg(db->dev, "fifo error\n");\r\ndev->stats.rx_fifo_errors++;\r\n}\r\nif (rxhdr.RxStatus & RSR_CE) {\r\nif (netif_msg_rx_err(db))\r\ndev_dbg(db->dev, "crc error\n");\r\ndev->stats.rx_crc_errors++;\r\n}\r\nif (rxhdr.RxStatus & RSR_RF) {\r\nif (netif_msg_rx_err(db))\r\ndev_dbg(db->dev, "length error\n");\r\ndev->stats.rx_length_errors++;\r\n}\r\n}\r\nif (GoodPacket &&\r\n((skb = netdev_alloc_skb(dev, RxLen + 4)) != NULL)) {\r\nskb_reserve(skb, 2);\r\nrdptr = (u8 *) skb_put(skb, RxLen - 4);\r\n(db->inblk)(db->io_data, rdptr, RxLen);\r\ndev->stats.rx_bytes += RxLen;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (dev->features & NETIF_F_RXCSUM) {\r\nif ((((rxbyte & 0x1c) << 3) & rxbyte) == 0)\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb_checksum_none_assert(skb);\r\n}\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n} else {\r\n(db->dumpblk)(db->io_data, RxLen);\r\n}\r\n} while (rxbyte & DM9000_PKT_RDY);\r\n}\r\nstatic irqreturn_t dm9000_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct board_info *db = netdev_priv(dev);\r\nint int_status;\r\nunsigned long flags;\r\nu8 reg_save;\r\ndm9000_dbg(db, 3, "entering %s\n", __func__);\r\nspin_lock_irqsave(&db->lock, flags);\r\nreg_save = readb(db->io_addr);\r\ndm9000_mask_interrupts(db);\r\nint_status = ior(db, DM9000_ISR);\r\niow(db, DM9000_ISR, int_status);\r\nif (netif_msg_intr(db))\r\ndev_dbg(db->dev, "interrupt status %02x\n", int_status);\r\nif (int_status & ISR_PRS)\r\ndm9000_rx(dev);\r\nif (int_status & ISR_PTS)\r\ndm9000_tx_done(dev, db);\r\nif (db->type != TYPE_DM9000E) {\r\nif (int_status & ISR_LNKCHNG) {\r\nschedule_delayed_work(&db->phy_poll, 1);\r\n}\r\n}\r\ndm9000_unmask_interrupts(db);\r\nwriteb(reg_save, db->io_addr);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dm9000_wol_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct board_info *db = netdev_priv(dev);\r\nunsigned long flags;\r\nunsigned nsr, wcr;\r\nspin_lock_irqsave(&db->lock, flags);\r\nnsr = ior(db, DM9000_NSR);\r\nwcr = ior(db, DM9000_WCR);\r\ndev_dbg(db->dev, "%s: NSR=0x%02x, WCR=0x%02x\n", __func__, nsr, wcr);\r\nif (nsr & NSR_WAKEST) {\r\niow(db, DM9000_NSR, NSR_WAKEST);\r\nif (wcr & WCR_LINKST)\r\ndev_info(db->dev, "wake by link status change\n");\r\nif (wcr & WCR_SAMPLEST)\r\ndev_info(db->dev, "wake by sample packet\n");\r\nif (wcr & WCR_MAGICST)\r\ndev_info(db->dev, "wake by magic packet\n");\r\nif (!(wcr & (WCR_LINKST | WCR_SAMPLEST | WCR_MAGICST)))\r\ndev_err(db->dev, "wake signalled with no reason? "\r\n"NSR=0x%02x, WSR=0x%02x\n", nsr, wcr);\r\n}\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn (nsr & NSR_WAKEST) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void dm9000_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\ndm9000_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int\r\ndm9000_open(struct net_device *dev)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\nunsigned int irq_flags = irq_get_trigger_type(dev->irq);\r\nif (netif_msg_ifup(db))\r\ndev_dbg(db->dev, "enabling %s\n", dev->name);\r\nif (irq_flags == IRQF_TRIGGER_NONE)\r\ndev_warn(db->dev, "WARNING: no IRQ resource flags set.\n");\r\nirq_flags |= IRQF_SHARED;\r\niow(db, DM9000_GPR, 0);\r\nmdelay(1);\r\ndm9000_init_dm9000(dev);\r\nif (request_irq(dev->irq, dm9000_interrupt, irq_flags, dev->name, dev))\r\nreturn -EAGAIN;\r\ndm9000_unmask_interrupts(db);\r\ndb->dbug_cnt = 0;\r\nmii_check_media(&db->mii, netif_msg_link(db), 1);\r\nnetif_start_queue(dev);\r\nschedule_delayed_work(&db->phy_poll, 1);\r\nreturn 0;\r\n}\r\nstatic void\r\ndm9000_shutdown(struct net_device *dev)\r\n{\r\nstruct board_info *db = netdev_priv(dev);\r\ndm9000_phy_write(dev, 0, MII_BMCR, BMCR_RESET);\r\niow(db, DM9000_GPR, 0x01);\r\ndm9000_mask_interrupts(db);\r\niow(db, DM9000_RCR, 0x00);\r\n}\r\nstatic int\r\ndm9000_stop(struct net_device *ndev)\r\n{\r\nstruct board_info *db = netdev_priv(ndev);\r\nif (netif_msg_ifdown(db))\r\ndev_dbg(db->dev, "shutting down %s\n", ndev->name);\r\ncancel_delayed_work_sync(&db->phy_poll);\r\nnetif_stop_queue(ndev);\r\nnetif_carrier_off(ndev);\r\nfree_irq(ndev->irq, ndev);\r\ndm9000_shutdown(ndev);\r\nreturn 0;\r\n}\r\nstatic struct dm9000_plat_data *dm9000_parse_dt(struct device *dev)\r\n{\r\nstruct dm9000_plat_data *pdata;\r\nstruct device_node *np = dev->of_node;\r\nconst void *mac_addr;\r\nif (!IS_ENABLED(CONFIG_OF) || !np)\r\nreturn ERR_PTR(-ENXIO);\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (of_find_property(np, "davicom,ext-phy", NULL))\r\npdata->flags |= DM9000_PLATF_EXT_PHY;\r\nif (of_find_property(np, "davicom,no-eeprom", NULL))\r\npdata->flags |= DM9000_PLATF_NO_EEPROM;\r\nmac_addr = of_get_mac_address(np);\r\nif (mac_addr)\r\nmemcpy(pdata->dev_addr, mac_addr, sizeof(pdata->dev_addr));\r\nreturn pdata;\r\n}\r\nstatic int\r\ndm9000_probe(struct platform_device *pdev)\r\n{\r\nstruct dm9000_plat_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct board_info *db;\r\nstruct net_device *ndev;\r\nstruct device *dev = &pdev->dev;\r\nconst unsigned char *mac_src;\r\nint ret = 0;\r\nint iosize;\r\nint i;\r\nu32 id_val;\r\nint reset_gpios;\r\nenum of_gpio_flags flags;\r\nstruct regulator *power;\r\nbool inv_mac_addr = false;\r\npower = devm_regulator_get(dev, "vcc");\r\nif (IS_ERR(power)) {\r\nif (PTR_ERR(power) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_dbg(dev, "no regulator provided\n");\r\n} else {\r\nret = regulator_enable(power);\r\nif (ret != 0) {\r\ndev_err(dev,\r\n"Failed to enable power regulator: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "regulator enabled\n");\r\n}\r\nreset_gpios = of_get_named_gpio_flags(dev->of_node, "reset-gpios", 0,\r\n&flags);\r\nif (gpio_is_valid(reset_gpios)) {\r\nret = devm_gpio_request_one(dev, reset_gpios, flags,\r\n"dm9000_reset");\r\nif (ret) {\r\ndev_err(dev, "failed to request reset gpio %d: %d\n",\r\nreset_gpios, ret);\r\nreturn -ENODEV;\r\n}\r\nmsleep(2);\r\ngpio_set_value(reset_gpios, 1);\r\nmsleep(4);\r\n}\r\nif (!pdata) {\r\npdata = dm9000_parse_dt(&pdev->dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nndev = alloc_etherdev(sizeof(struct board_info));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\ndev_dbg(&pdev->dev, "dm9000_probe()\n");\r\ndb = netdev_priv(ndev);\r\ndb->dev = &pdev->dev;\r\ndb->ndev = ndev;\r\nspin_lock_init(&db->lock);\r\nmutex_init(&db->addr_lock);\r\nINIT_DELAYED_WORK(&db->phy_poll, dm9000_poll_work);\r\ndb->addr_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndb->data_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!db->addr_res || !db->data_res) {\r\ndev_err(db->dev, "insufficient resources addr=%p data=%p\n",\r\ndb->addr_res, db->data_res);\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nndev->irq = platform_get_irq(pdev, 0);\r\nif (ndev->irq < 0) {\r\ndev_err(db->dev, "interrupt resource unavailable: %d\n",\r\nndev->irq);\r\nret = ndev->irq;\r\ngoto out;\r\n}\r\ndb->irq_wake = platform_get_irq(pdev, 1);\r\nif (db->irq_wake >= 0) {\r\ndev_dbg(db->dev, "wakeup irq %d\n", db->irq_wake);\r\nret = request_irq(db->irq_wake, dm9000_wol_interrupt,\r\nIRQF_SHARED, dev_name(db->dev), ndev);\r\nif (ret) {\r\ndev_err(db->dev, "cannot get wakeup irq (%d)\n", ret);\r\n} else {\r\nret = irq_set_irq_wake(db->irq_wake, 1);\r\nif (ret) {\r\ndev_err(db->dev, "irq %d cannot set wakeup (%d)\n",\r\ndb->irq_wake, ret);\r\nret = 0;\r\n} else {\r\nirq_set_irq_wake(db->irq_wake, 0);\r\ndb->wake_supported = 1;\r\n}\r\n}\r\n}\r\niosize = resource_size(db->addr_res);\r\ndb->addr_req = request_mem_region(db->addr_res->start, iosize,\r\npdev->name);\r\nif (db->addr_req == NULL) {\r\ndev_err(db->dev, "cannot claim address reg area\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\ndb->io_addr = ioremap(db->addr_res->start, iosize);\r\nif (db->io_addr == NULL) {\r\ndev_err(db->dev, "failed to ioremap address reg\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\niosize = resource_size(db->data_res);\r\ndb->data_req = request_mem_region(db->data_res->start, iosize,\r\npdev->name);\r\nif (db->data_req == NULL) {\r\ndev_err(db->dev, "cannot claim data reg area\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\ndb->io_data = ioremap(db->data_res->start, iosize);\r\nif (db->io_data == NULL) {\r\ndev_err(db->dev, "failed to ioremap data reg\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nndev->base_addr = (unsigned long)db->io_addr;\r\ndm9000_set_io(db, iosize);\r\nif (pdata != NULL) {\r\nif (pdata->flags & DM9000_PLATF_8BITONLY)\r\ndm9000_set_io(db, 1);\r\nif (pdata->flags & DM9000_PLATF_16BITONLY)\r\ndm9000_set_io(db, 2);\r\nif (pdata->flags & DM9000_PLATF_32BITONLY)\r\ndm9000_set_io(db, 4);\r\nif (pdata->inblk != NULL)\r\ndb->inblk = pdata->inblk;\r\nif (pdata->outblk != NULL)\r\ndb->outblk = pdata->outblk;\r\nif (pdata->dumpblk != NULL)\r\ndb->dumpblk = pdata->dumpblk;\r\ndb->flags = pdata->flags;\r\n}\r\n#ifdef CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL\r\ndb->flags |= DM9000_PLATF_SIMPLE_PHY;\r\n#endif\r\ndm9000_reset(db);\r\nfor (i = 0; i < 8; i++) {\r\nid_val = ior(db, DM9000_VIDL);\r\nid_val |= (u32)ior(db, DM9000_VIDH) << 8;\r\nid_val |= (u32)ior(db, DM9000_PIDL) << 16;\r\nid_val |= (u32)ior(db, DM9000_PIDH) << 24;\r\nif (id_val == DM9000_ID)\r\nbreak;\r\ndev_err(db->dev, "read wrong id 0x%08x\n", id_val);\r\n}\r\nif (id_val != DM9000_ID) {\r\ndev_err(db->dev, "wrong id: 0x%08x\n", id_val);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nid_val = ior(db, DM9000_CHIPR);\r\ndev_dbg(db->dev, "dm9000 revision 0x%02x\n", id_val);\r\nswitch (id_val) {\r\ncase CHIPR_DM9000A:\r\ndb->type = TYPE_DM9000A;\r\nbreak;\r\ncase CHIPR_DM9000B:\r\ndb->type = TYPE_DM9000B;\r\nbreak;\r\ndefault:\r\ndev_dbg(db->dev, "ID %02x => defaulting to DM9000E\n", id_val);\r\ndb->type = TYPE_DM9000E;\r\n}\r\nif (db->type == TYPE_DM9000A || db->type == TYPE_DM9000B) {\r\nndev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM;\r\nndev->features |= ndev->hw_features;\r\n}\r\nndev->netdev_ops = &dm9000_netdev_ops;\r\nndev->watchdog_timeo = msecs_to_jiffies(watchdog);\r\nndev->ethtool_ops = &dm9000_ethtool_ops;\r\ndb->msg_enable = NETIF_MSG_LINK;\r\ndb->mii.phy_id_mask = 0x1f;\r\ndb->mii.reg_num_mask = 0x1f;\r\ndb->mii.force_media = 0;\r\ndb->mii.full_duplex = 0;\r\ndb->mii.dev = ndev;\r\ndb->mii.mdio_read = dm9000_phy_read;\r\ndb->mii.mdio_write = dm9000_phy_write;\r\nmac_src = "eeprom";\r\nfor (i = 0; i < 6; i += 2)\r\ndm9000_read_eeprom(db, i / 2, ndev->dev_addr+i);\r\nif (!is_valid_ether_addr(ndev->dev_addr) && pdata != NULL) {\r\nmac_src = "platform data";\r\nmemcpy(ndev->dev_addr, pdata->dev_addr, ETH_ALEN);\r\n}\r\nif (!is_valid_ether_addr(ndev->dev_addr)) {\r\nmac_src = "chip";\r\nfor (i = 0; i < 6; i++)\r\nndev->dev_addr[i] = ior(db, i+DM9000_PAR);\r\n}\r\nif (!is_valid_ether_addr(ndev->dev_addr)) {\r\ninv_mac_addr = true;\r\neth_hw_addr_random(ndev);\r\nmac_src = "random";\r\n}\r\nplatform_set_drvdata(pdev, ndev);\r\nret = register_netdev(ndev);\r\nif (ret == 0) {\r\nif (inv_mac_addr)\r\ndev_warn(db->dev, "%s: Invalid ethernet MAC address. Please set using ip\n",\r\nndev->name);\r\nprintk(KERN_INFO "%s: dm9000%c at %p,%p IRQ %d MAC: %pM (%s)\n",\r\nndev->name, dm9000_type_to_char(db->type),\r\ndb->io_addr, db->io_data, ndev->irq,\r\nndev->dev_addr, mac_src);\r\n}\r\nreturn 0;\r\nout:\r\ndev_err(db->dev, "not found (%d).\n", ret);\r\ndm9000_release_board(pdev, db);\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int\r\ndm9000_drv_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct board_info *db;\r\nif (ndev) {\r\ndb = netdev_priv(ndev);\r\ndb->in_suspend = 1;\r\nif (!netif_running(ndev))\r\nreturn 0;\r\nnetif_device_detach(ndev);\r\nif (!db->wake_state)\r\ndm9000_shutdown(ndev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndm9000_drv_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct board_info *db = netdev_priv(ndev);\r\nif (ndev) {\r\nif (netif_running(ndev)) {\r\nif (!db->wake_state) {\r\ndm9000_init_dm9000(ndev);\r\ndm9000_unmask_interrupts(db);\r\n}\r\nnetif_device_attach(ndev);\r\n}\r\ndb->in_suspend = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndm9000_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nunregister_netdev(ndev);\r\ndm9000_release_board(pdev, netdev_priv(ndev));\r\nfree_netdev(ndev);\r\ndev_dbg(&pdev->dev, "released and freed device\n");\r\nreturn 0;\r\n}
