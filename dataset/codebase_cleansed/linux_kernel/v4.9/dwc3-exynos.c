static int dwc3_exynos_register_phys(struct dwc3_exynos *exynos)\r\n{\r\nstruct usb_phy_generic_platform_data pdata;\r\nstruct platform_device *pdev;\r\nint ret;\r\nmemset(&pdata, 0x00, sizeof(pdata));\r\npdev = platform_device_alloc("usb_phy_generic", PLATFORM_DEVID_AUTO);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nexynos->usb2_phy = pdev;\r\npdata.type = USB_PHY_TYPE_USB2;\r\npdata.gpio_reset = -1;\r\nret = platform_device_add_data(exynos->usb2_phy, &pdata, sizeof(pdata));\r\nif (ret)\r\ngoto err1;\r\npdev = platform_device_alloc("usb_phy_generic", PLATFORM_DEVID_AUTO);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nexynos->usb3_phy = pdev;\r\npdata.type = USB_PHY_TYPE_USB3;\r\nret = platform_device_add_data(exynos->usb3_phy, &pdata, sizeof(pdata));\r\nif (ret)\r\ngoto err2;\r\nret = platform_device_add(exynos->usb2_phy);\r\nif (ret)\r\ngoto err2;\r\nret = platform_device_add(exynos->usb3_phy);\r\nif (ret)\r\ngoto err3;\r\nreturn 0;\r\nerr3:\r\nplatform_device_del(exynos->usb2_phy);\r\nerr2:\r\nplatform_device_put(exynos->usb3_phy);\r\nerr1:\r\nplatform_device_put(exynos->usb2_phy);\r\nreturn ret;\r\n}\r\nstatic int dwc3_exynos_remove_child(struct device *dev, void *unused)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nstatic int dwc3_exynos_probe(struct platform_device *pdev)\r\n{\r\nstruct dwc3_exynos *exynos;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nint ret;\r\nexynos = devm_kzalloc(dev, sizeof(*exynos), GFP_KERNEL);\r\nif (!exynos)\r\nreturn -ENOMEM;\r\nret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, exynos);\r\nexynos->dev = dev;\r\nexynos->clk = devm_clk_get(dev, "usbdrd30");\r\nif (IS_ERR(exynos->clk)) {\r\ndev_err(dev, "couldn't get clock\n");\r\nreturn -EINVAL;\r\n}\r\nclk_prepare_enable(exynos->clk);\r\nexynos->susp_clk = devm_clk_get(dev, "usbdrd30_susp_clk");\r\nif (IS_ERR(exynos->susp_clk)) {\r\ndev_info(dev, "no suspend clk specified\n");\r\nexynos->susp_clk = NULL;\r\n}\r\nclk_prepare_enable(exynos->susp_clk);\r\nif (of_device_is_compatible(node, "samsung,exynos7-dwusb3")) {\r\nexynos->axius_clk = devm_clk_get(dev, "usbdrd30_axius_clk");\r\nif (IS_ERR(exynos->axius_clk)) {\r\ndev_err(dev, "no AXI UpScaler clk specified\n");\r\nreturn -ENODEV;\r\n}\r\nclk_prepare_enable(exynos->axius_clk);\r\n} else {\r\nexynos->axius_clk = NULL;\r\n}\r\nexynos->vdd33 = devm_regulator_get(dev, "vdd33");\r\nif (IS_ERR(exynos->vdd33)) {\r\nret = PTR_ERR(exynos->vdd33);\r\ngoto err2;\r\n}\r\nret = regulator_enable(exynos->vdd33);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable VDD33 supply\n");\r\ngoto err2;\r\n}\r\nexynos->vdd10 = devm_regulator_get(dev, "vdd10");\r\nif (IS_ERR(exynos->vdd10)) {\r\nret = PTR_ERR(exynos->vdd10);\r\ngoto err3;\r\n}\r\nret = regulator_enable(exynos->vdd10);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable VDD10 supply\n");\r\ngoto err3;\r\n}\r\nret = dwc3_exynos_register_phys(exynos);\r\nif (ret) {\r\ndev_err(dev, "couldn't register PHYs\n");\r\ngoto err4;\r\n}\r\nif (node) {\r\nret = of_platform_populate(node, NULL, NULL, dev);\r\nif (ret) {\r\ndev_err(dev, "failed to add dwc3 core\n");\r\ngoto err5;\r\n}\r\n} else {\r\ndev_err(dev, "no device node, failed to add dwc3 core\n");\r\nret = -ENODEV;\r\ngoto err5;\r\n}\r\nreturn 0;\r\nerr5:\r\nplatform_device_unregister(exynos->usb2_phy);\r\nplatform_device_unregister(exynos->usb3_phy);\r\nerr4:\r\nregulator_disable(exynos->vdd10);\r\nerr3:\r\nregulator_disable(exynos->vdd33);\r\nerr2:\r\nclk_disable_unprepare(exynos->axius_clk);\r\nclk_disable_unprepare(exynos->susp_clk);\r\nclk_disable_unprepare(exynos->clk);\r\nreturn ret;\r\n}\r\nstatic int dwc3_exynos_remove(struct platform_device *pdev)\r\n{\r\nstruct dwc3_exynos *exynos = platform_get_drvdata(pdev);\r\ndevice_for_each_child(&pdev->dev, NULL, dwc3_exynos_remove_child);\r\nplatform_device_unregister(exynos->usb2_phy);\r\nplatform_device_unregister(exynos->usb3_phy);\r\nclk_disable_unprepare(exynos->axius_clk);\r\nclk_disable_unprepare(exynos->susp_clk);\r\nclk_disable_unprepare(exynos->clk);\r\nregulator_disable(exynos->vdd33);\r\nregulator_disable(exynos->vdd10);\r\nreturn 0;\r\n}\r\nstatic int dwc3_exynos_suspend(struct device *dev)\r\n{\r\nstruct dwc3_exynos *exynos = dev_get_drvdata(dev);\r\nclk_disable(exynos->axius_clk);\r\nclk_disable(exynos->clk);\r\nregulator_disable(exynos->vdd33);\r\nregulator_disable(exynos->vdd10);\r\nreturn 0;\r\n}\r\nstatic int dwc3_exynos_resume(struct device *dev)\r\n{\r\nstruct dwc3_exynos *exynos = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_enable(exynos->vdd33);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable VDD33 supply\n");\r\nreturn ret;\r\n}\r\nret = regulator_enable(exynos->vdd10);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable VDD10 supply\n");\r\nreturn ret;\r\n}\r\nclk_enable(exynos->clk);\r\nclk_enable(exynos->axius_clk);\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nreturn 0;\r\n}
