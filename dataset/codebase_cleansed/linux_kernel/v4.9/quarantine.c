static bool qlist_empty(struct qlist_head *q)\r\n{\r\nreturn !q->head;\r\n}\r\nstatic void qlist_init(struct qlist_head *q)\r\n{\r\nq->head = q->tail = NULL;\r\nq->bytes = 0;\r\n}\r\nstatic void qlist_put(struct qlist_head *q, struct qlist_node *qlink,\r\nsize_t size)\r\n{\r\nif (unlikely(qlist_empty(q)))\r\nq->head = qlink;\r\nelse\r\nq->tail->next = qlink;\r\nq->tail = qlink;\r\nqlink->next = NULL;\r\nq->bytes += size;\r\n}\r\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\r\n{\r\nif (unlikely(qlist_empty(from)))\r\nreturn;\r\nif (qlist_empty(to)) {\r\n*to = *from;\r\nqlist_init(from);\r\nreturn;\r\n}\r\nto->tail->next = from->head;\r\nto->tail = from->tail;\r\nto->bytes += from->bytes;\r\nqlist_init(from);\r\n}\r\nstatic void qlist_move(struct qlist_head *from, struct qlist_node *last,\r\nstruct qlist_head *to, size_t size)\r\n{\r\nif (unlikely(last == from->tail)) {\r\nqlist_move_all(from, to);\r\nreturn;\r\n}\r\nif (qlist_empty(to))\r\nto->head = from->head;\r\nelse\r\nto->tail->next = from->head;\r\nto->tail = last;\r\nfrom->head = last->next;\r\nlast->next = NULL;\r\nfrom->bytes -= size;\r\nto->bytes += size;\r\n}\r\nstatic struct kmem_cache *qlink_to_cache(struct qlist_node *qlink)\r\n{\r\nreturn virt_to_head_page(qlink)->slab_cache;\r\n}\r\nstatic void *qlink_to_object(struct qlist_node *qlink, struct kmem_cache *cache)\r\n{\r\nstruct kasan_free_meta *free_info =\r\ncontainer_of(qlink, struct kasan_free_meta,\r\nquarantine_link);\r\nreturn ((void *)free_info) - cache->kasan_info.free_meta_offset;\r\n}\r\nstatic void qlink_free(struct qlist_node *qlink, struct kmem_cache *cache)\r\n{\r\nvoid *object = qlink_to_object(qlink, cache);\r\nunsigned long flags;\r\nif (IS_ENABLED(CONFIG_SLAB))\r\nlocal_irq_save(flags);\r\n___cache_free(cache, object, _THIS_IP_);\r\nif (IS_ENABLED(CONFIG_SLAB))\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void qlist_free_all(struct qlist_head *q, struct kmem_cache *cache)\r\n{\r\nstruct qlist_node *qlink;\r\nif (unlikely(qlist_empty(q)))\r\nreturn;\r\nqlink = q->head;\r\nwhile (qlink) {\r\nstruct kmem_cache *obj_cache =\r\ncache ? cache : qlink_to_cache(qlink);\r\nstruct qlist_node *next = qlink->next;\r\nqlink_free(qlink, obj_cache);\r\nqlink = next;\r\n}\r\nqlist_init(q);\r\n}\r\nvoid quarantine_put(struct kasan_free_meta *info, struct kmem_cache *cache)\r\n{\r\nunsigned long flags;\r\nstruct qlist_head *q;\r\nstruct qlist_head temp = QLIST_INIT;\r\nlocal_irq_save(flags);\r\nq = this_cpu_ptr(&cpu_quarantine);\r\nqlist_put(q, &info->quarantine_link, cache->size);\r\nif (unlikely(q->bytes > QUARANTINE_PERCPU_SIZE))\r\nqlist_move_all(q, &temp);\r\nlocal_irq_restore(flags);\r\nif (unlikely(!qlist_empty(&temp))) {\r\nspin_lock_irqsave(&quarantine_lock, flags);\r\nqlist_move_all(&temp, &global_quarantine);\r\nspin_unlock_irqrestore(&quarantine_lock, flags);\r\n}\r\n}\r\nvoid quarantine_reduce(void)\r\n{\r\nsize_t new_quarantine_size, percpu_quarantines;\r\nunsigned long flags;\r\nstruct qlist_head to_free = QLIST_INIT;\r\nsize_t size_to_free = 0;\r\nstruct qlist_node *last;\r\nif (likely(READ_ONCE(global_quarantine.bytes) <=\r\nREAD_ONCE(quarantine_size)))\r\nreturn;\r\nspin_lock_irqsave(&quarantine_lock, flags);\r\nnew_quarantine_size = (READ_ONCE(totalram_pages) << PAGE_SHIFT) /\r\nQUARANTINE_FRACTION;\r\npercpu_quarantines = QUARANTINE_PERCPU_SIZE * num_online_cpus();\r\nnew_quarantine_size = (new_quarantine_size < percpu_quarantines) ?\r\n0 : new_quarantine_size - percpu_quarantines;\r\nWRITE_ONCE(quarantine_size, new_quarantine_size);\r\nlast = global_quarantine.head;\r\nwhile (last) {\r\nstruct kmem_cache *cache = qlink_to_cache(last);\r\nsize_to_free += cache->size;\r\nif (!last->next || size_to_free >\r\nglobal_quarantine.bytes - QUARANTINE_LOW_SIZE)\r\nbreak;\r\nlast = last->next;\r\n}\r\nqlist_move(&global_quarantine, last, &to_free, size_to_free);\r\nspin_unlock_irqrestore(&quarantine_lock, flags);\r\nqlist_free_all(&to_free, NULL);\r\n}\r\nstatic void qlist_move_cache(struct qlist_head *from,\r\nstruct qlist_head *to,\r\nstruct kmem_cache *cache)\r\n{\r\nstruct qlist_node *curr;\r\nif (unlikely(qlist_empty(from)))\r\nreturn;\r\ncurr = from->head;\r\nqlist_init(from);\r\nwhile (curr) {\r\nstruct qlist_node *next = curr->next;\r\nstruct kmem_cache *obj_cache = qlink_to_cache(curr);\r\nif (obj_cache == cache)\r\nqlist_put(to, curr, obj_cache->size);\r\nelse\r\nqlist_put(from, curr, obj_cache->size);\r\ncurr = next;\r\n}\r\n}\r\nstatic void per_cpu_remove_cache(void *arg)\r\n{\r\nstruct kmem_cache *cache = arg;\r\nstruct qlist_head to_free = QLIST_INIT;\r\nstruct qlist_head *q;\r\nq = this_cpu_ptr(&cpu_quarantine);\r\nqlist_move_cache(q, &to_free, cache);\r\nqlist_free_all(&to_free, cache);\r\n}\r\nvoid quarantine_remove_cache(struct kmem_cache *cache)\r\n{\r\nunsigned long flags;\r\nstruct qlist_head to_free = QLIST_INIT;\r\non_each_cpu(per_cpu_remove_cache, cache, 1);\r\nspin_lock_irqsave(&quarantine_lock, flags);\r\nqlist_move_cache(&global_quarantine, &to_free, cache);\r\nspin_unlock_irqrestore(&quarantine_lock, flags);\r\nqlist_free_all(&to_free, cache);\r\n}
