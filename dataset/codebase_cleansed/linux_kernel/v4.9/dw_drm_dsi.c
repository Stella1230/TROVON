static u32 dsi_calc_phy_rate(u32 req_kHz, struct mipi_phy_params *phy)\r\n{\r\nu32 ref_clk_ps = PHY_REF_CLK_PERIOD_PS;\r\nu32 tmp_kHz = req_kHz;\r\nu32 i = 0;\r\nu32 q_pll = 1;\r\nu32 m_pll = 0;\r\nu32 n_pll = 0;\r\nu32 r_pll = 1;\r\nu32 m_n = 0;\r\nu32 m_n_int = 0;\r\nu32 f_kHz = 0;\r\nu64 temp;\r\ndo {\r\nf_kHz = tmp_kHz;\r\nfor (i = 0; i < ARRAY_SIZE(dphy_range_info); i++)\r\nif (f_kHz >= dphy_range_info[i].min_range_kHz &&\r\nf_kHz <= dphy_range_info[i].max_range_kHz)\r\nbreak;\r\nif (i == ARRAY_SIZE(dphy_range_info)) {\r\nDRM_ERROR("%dkHz out of range\n", f_kHz);\r\nreturn 0;\r\n}\r\nphy->pll_vco_750M = dphy_range_info[i].pll_vco_750M;\r\nphy->hstx_ckg_sel = dphy_range_info[i].hstx_ckg_sel;\r\nif (phy->hstx_ckg_sel <= 7 &&\r\nphy->hstx_ckg_sel >= 4)\r\nq_pll = 0x10 >> (7 - phy->hstx_ckg_sel);\r\ntemp = f_kHz * (u64)q_pll * (u64)ref_clk_ps;\r\nm_n_int = temp / (u64)1000000000;\r\nm_n = (temp % (u64)1000000000) / (u64)100000000;\r\nif (m_n_int % 2 == 0) {\r\nif (m_n * 6 >= 50) {\r\nn_pll = 2;\r\nm_pll = (m_n_int + 1) * n_pll;\r\n} else if (m_n * 6 >= 30) {\r\nn_pll = 3;\r\nm_pll = m_n_int * n_pll + 2;\r\n} else {\r\nn_pll = 1;\r\nm_pll = m_n_int * n_pll;\r\n}\r\n} else {\r\nif (m_n * 6 >= 50) {\r\nn_pll = 1;\r\nm_pll = (m_n_int + 1) * n_pll;\r\n} else if (m_n * 6 >= 30) {\r\nn_pll = 1;\r\nm_pll = (m_n_int + 1) * n_pll;\r\n} else if (m_n * 6 >= 10) {\r\nn_pll = 3;\r\nm_pll = m_n_int * n_pll + 1;\r\n} else {\r\nn_pll = 2;\r\nm_pll = m_n_int * n_pll;\r\n}\r\n}\r\nif (n_pll == 1) {\r\nphy->pll_fbd_p = 0;\r\nphy->pll_pre_div1p = 1;\r\n} else {\r\nphy->pll_fbd_p = n_pll;\r\nphy->pll_pre_div1p = 0;\r\n}\r\nif (phy->pll_fbd_2p <= 7 && phy->pll_fbd_2p >= 4)\r\nr_pll = 0x10 >> (7 - phy->pll_fbd_2p);\r\nif (m_pll == 2) {\r\nphy->pll_pre_p = 0;\r\nphy->pll_fbd_s = 0;\r\nphy->pll_fbd_div1f = 0;\r\nphy->pll_fbd_div5f = 1;\r\n} else if (m_pll >= 2 * 2 * r_pll && m_pll <= 2 * 4 * r_pll) {\r\nphy->pll_pre_p = m_pll / (2 * r_pll);\r\nphy->pll_fbd_s = 0;\r\nphy->pll_fbd_div1f = 1;\r\nphy->pll_fbd_div5f = 0;\r\n} else if (m_pll >= 2 * 5 * r_pll && m_pll <= 2 * 150 * r_pll) {\r\nif (((m_pll / (2 * r_pll)) % 2) == 0) {\r\nphy->pll_pre_p =\r\n(m_pll / (2 * r_pll)) / 2 - 1;\r\nphy->pll_fbd_s =\r\n(m_pll / (2 * r_pll)) % 2 + 2;\r\n} else {\r\nphy->pll_pre_p =\r\n(m_pll / (2 * r_pll)) / 2;\r\nphy->pll_fbd_s =\r\n(m_pll / (2 * r_pll)) % 2;\r\n}\r\nphy->pll_fbd_div1f = 0;\r\nphy->pll_fbd_div5f = 0;\r\n} else {\r\nphy->pll_pre_p = 0;\r\nphy->pll_fbd_s = 0;\r\nphy->pll_fbd_div1f = 0;\r\nphy->pll_fbd_div5f = 1;\r\n}\r\nf_kHz = (u64)1000000000 * (u64)m_pll /\r\n((u64)ref_clk_ps * (u64)n_pll * (u64)q_pll);\r\nif (f_kHz >= req_kHz)\r\nbreak;\r\ntmp_kHz += 10;\r\n} while (true);\r\nreturn f_kHz;\r\n}\r\nstatic void dsi_get_phy_params(u32 phy_req_kHz,\r\nstruct mipi_phy_params *phy)\r\n{\r\nu32 ref_clk_ps = PHY_REF_CLK_PERIOD_PS;\r\nu32 phy_rate_kHz;\r\nu32 ui;\r\nmemset(phy, 0, sizeof(*phy));\r\nphy_rate_kHz = dsi_calc_phy_rate(phy_req_kHz, phy);\r\nif (!phy_rate_kHz)\r\nreturn;\r\nui = 1000000 / phy_rate_kHz;\r\nphy->clk_t_lpx = ROUND(50, 8 * ui);\r\nphy->clk_t_hs_prepare = ROUND(133, 16 * ui) - 1;\r\nphy->clk_t_hs_zero = ROUND(262, 8 * ui);\r\nphy->clk_t_hs_trial = 2 * (ROUND(60, 8 * ui) - 1);\r\nphy->clk_t_wakeup = ROUND(1000000, (ref_clk_ps / 1000) - 1);\r\nif (phy->clk_t_wakeup > 0xff)\r\nphy->clk_t_wakeup = 0xff;\r\nphy->data_t_wakeup = phy->clk_t_wakeup;\r\nphy->data_t_lpx = phy->clk_t_lpx;\r\nphy->data_t_hs_prepare = ROUND(125 + 10 * ui, 16 * ui) - 1;\r\nphy->data_t_hs_zero = ROUND(105 + 6 * ui, 8 * ui);\r\nphy->data_t_hs_trial = 2 * (ROUND(60 + 4 * ui, 8 * ui) - 1);\r\nphy->data_t_ta_go = 3;\r\nphy->data_t_ta_get = 4;\r\nphy->pll_enbwt = 1;\r\nphy->clklp2hs_time = ROUND(407, 8 * ui) + 12;\r\nphy->clkhs2lp_time = ROUND(105 + 12 * ui, 8 * ui);\r\nphy->lp2hs_time = ROUND(240 + 12 * ui, 8 * ui) + 1;\r\nphy->hs2lp_time = phy->clkhs2lp_time;\r\nphy->clk_to_data_delay = 1 + phy->clklp2hs_time;\r\nphy->data_to_clk_delay = ROUND(60 + 52 * ui, 8 * ui) +\r\nphy->clkhs2lp_time;\r\nphy->lane_byte_clk_kHz = phy_rate_kHz / 8;\r\nphy->clk_division =\r\nDIV_ROUND_UP(phy->lane_byte_clk_kHz, MAX_TX_ESC_CLK);\r\n}\r\nstatic u32 dsi_get_dpi_color_coding(enum mipi_dsi_pixel_format format)\r\n{\r\nu32 val;\r\nswitch (format) {\r\ncase MIPI_DSI_FMT_RGB888:\r\nval = DSI_24BITS_1;\r\nbreak;\r\ndefault:\r\nval = DSI_24BITS_1;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic void dsi_phy_tst_set(void __iomem *base, u32 reg, u32 val)\r\n{\r\nu32 reg_write = 0x10000 + reg;\r\nwritel(reg_write, base + PHY_TST_CTRL1);\r\nwritel(0x02, base + PHY_TST_CTRL0);\r\nwritel(0x00, base + PHY_TST_CTRL0);\r\nwritel(val, base + PHY_TST_CTRL1);\r\nwritel(0x02, base + PHY_TST_CTRL0);\r\nwritel(0x00, base + PHY_TST_CTRL0);\r\n}\r\nstatic void dsi_set_phy_timer(void __iomem *base,\r\nstruct mipi_phy_params *phy,\r\nu32 lanes)\r\n{\r\nu32 val;\r\nval = (lanes - 1) | (PHY_STOP_WAIT_TIME << 8);\r\nwritel(val, base + PHY_IF_CFG);\r\nval = readl(base + CLKMGR_CFG) | phy->clk_division;\r\nwritel(val, base + CLKMGR_CFG);\r\ndw_update_bits(base + PHY_TMR_CFG, 24, MASK(8), phy->hs2lp_time);\r\ndw_update_bits(base + PHY_TMR_CFG, 16, MASK(8), phy->lp2hs_time);\r\ndw_update_bits(base + PHY_TMR_LPCLK_CFG, 16, MASK(10),\r\nphy->clkhs2lp_time);\r\ndw_update_bits(base + PHY_TMR_LPCLK_CFG, 0, MASK(10),\r\nphy->clklp2hs_time);\r\ndw_update_bits(base + CLK_DATA_TMR_CFG, 8, MASK(8),\r\nphy->data_to_clk_delay);\r\ndw_update_bits(base + CLK_DATA_TMR_CFG, 0, MASK(8),\r\nphy->clk_to_data_delay);\r\n}\r\nstatic void dsi_set_mipi_phy(void __iomem *base,\r\nstruct mipi_phy_params *phy,\r\nu32 lanes)\r\n{\r\nu32 delay_count;\r\nu32 val;\r\nu32 i;\r\ndsi_set_phy_timer(base, phy, lanes);\r\nwritel(0, base + PHY_RSTZ);\r\nwritel(0, base + PHY_TST_CTRL0);\r\nwritel(1, base + PHY_TST_CTRL0);\r\nwritel(0, base + PHY_TST_CTRL0);\r\ndsi_phy_tst_set(base, CLK_TLPX, phy->clk_t_lpx);\r\ndsi_phy_tst_set(base, CLK_THS_PREPARE, phy->clk_t_hs_prepare);\r\ndsi_phy_tst_set(base, CLK_THS_ZERO, phy->clk_t_hs_zero);\r\ndsi_phy_tst_set(base, CLK_THS_TRAIL, phy->clk_t_hs_trial);\r\ndsi_phy_tst_set(base, CLK_TWAKEUP, phy->clk_t_wakeup);\r\nfor (i = 0; i < lanes; i++) {\r\ndsi_phy_tst_set(base, DATA_TLPX(i), phy->data_t_lpx);\r\ndsi_phy_tst_set(base, DATA_THS_PREPARE(i),\r\nphy->data_t_hs_prepare);\r\ndsi_phy_tst_set(base, DATA_THS_ZERO(i), phy->data_t_hs_zero);\r\ndsi_phy_tst_set(base, DATA_THS_TRAIL(i), phy->data_t_hs_trial);\r\ndsi_phy_tst_set(base, DATA_TTA_GO(i), phy->data_t_ta_go);\r\ndsi_phy_tst_set(base, DATA_TTA_GET(i), phy->data_t_ta_get);\r\ndsi_phy_tst_set(base, DATA_TWAKEUP(i), phy->data_t_wakeup);\r\n}\r\ndsi_phy_tst_set(base, PHY_CFG_I, phy->hstx_ckg_sel);\r\nval = (phy->pll_fbd_div5f << 5) + (phy->pll_fbd_div1f << 4) +\r\n(phy->pll_fbd_2p << 1) + phy->pll_enbwt;\r\ndsi_phy_tst_set(base, PHY_CFG_PLL_I, val);\r\ndsi_phy_tst_set(base, PHY_CFG_PLL_II, phy->pll_fbd_p);\r\ndsi_phy_tst_set(base, PHY_CFG_PLL_III, phy->pll_fbd_s);\r\nval = (phy->pll_pre_div1p << 7) + phy->pll_pre_p;\r\ndsi_phy_tst_set(base, PHY_CFG_PLL_IV, val);\r\nval = (5 << 5) + (phy->pll_vco_750M << 4) + (phy->pll_lpf_rs << 2) +\r\nphy->pll_lpf_cs;\r\ndsi_phy_tst_set(base, PHY_CFG_PLL_V, val);\r\nwritel(PHY_ENABLECLK, base + PHY_RSTZ);\r\nudelay(1);\r\nwritel(PHY_ENABLECLK | PHY_UNSHUTDOWNZ, base + PHY_RSTZ);\r\nudelay(1);\r\nwritel(PHY_ENABLECLK | PHY_UNRSTZ | PHY_UNSHUTDOWNZ, base + PHY_RSTZ);\r\nusleep_range(1000, 1500);\r\ndelay_count = 100;\r\nwhile (delay_count) {\r\nval = readl(base + PHY_STATUS);\r\nif ((BIT(0) | BIT(2)) & val)\r\nbreak;\r\nudelay(1);\r\ndelay_count--;\r\n}\r\nif (!delay_count)\r\nDRM_INFO("phylock and phystopstateclklane is not ready.\n");\r\n}\r\nstatic void dsi_set_mode_timing(void __iomem *base,\r\nu32 lane_byte_clk_kHz,\r\nstruct drm_display_mode *mode,\r\nenum mipi_dsi_pixel_format format)\r\n{\r\nu32 hfp, hbp, hsw, vfp, vbp, vsw;\r\nu32 hline_time;\r\nu32 hsa_time;\r\nu32 hbp_time;\r\nu32 pixel_clk_kHz;\r\nint htot, vtot;\r\nu32 val;\r\nu64 tmp;\r\nval = dsi_get_dpi_color_coding(format);\r\nwritel(val, base + DPI_COLOR_CODING);\r\nval = (mode->flags & DRM_MODE_FLAG_NHSYNC ? 1 : 0) << 2;\r\nval |= (mode->flags & DRM_MODE_FLAG_NVSYNC ? 1 : 0) << 1;\r\nwritel(val, base + DPI_CFG_POL);\r\npixel_clk_kHz = mode->clock;\r\nhtot = mode->htotal;\r\nvtot = mode->vtotal;\r\nhfp = mode->hsync_start - mode->hdisplay;\r\nhbp = mode->htotal - mode->hsync_end;\r\nhsw = mode->hsync_end - mode->hsync_start;\r\nvfp = mode->vsync_start - mode->vdisplay;\r\nvbp = mode->vtotal - mode->vsync_end;\r\nvsw = mode->vsync_end - mode->vsync_start;\r\nif (vsw > 15) {\r\nDRM_DEBUG_DRIVER("vsw exceeded 15\n");\r\nvsw = 15;\r\n}\r\nhsa_time = (hsw * lane_byte_clk_kHz) / pixel_clk_kHz;\r\nhbp_time = (hbp * lane_byte_clk_kHz) / pixel_clk_kHz;\r\ntmp = (u64)htot * (u64)lane_byte_clk_kHz;\r\nhline_time = DIV_ROUND_UP(tmp, pixel_clk_kHz);\r\nwritel(hsa_time, base + VID_HSA_TIME);\r\nwritel(hbp_time, base + VID_HBP_TIME);\r\nwritel(hline_time, base + VID_HLINE_TIME);\r\nwritel(vsw, base + VID_VSA_LINES);\r\nwritel(vbp, base + VID_VBP_LINES);\r\nwritel(vfp, base + VID_VFP_LINES);\r\nwritel(mode->vdisplay, base + VID_VACTIVE_LINES);\r\nwritel(mode->hdisplay, base + VID_PKT_SIZE);\r\nDRM_DEBUG_DRIVER("htot=%d, hfp=%d, hbp=%d, hsw=%d\n",\r\nhtot, hfp, hbp, hsw);\r\nDRM_DEBUG_DRIVER("vtol=%d, vfp=%d, vbp=%d, vsw=%d\n",\r\nvtot, vfp, vbp, vsw);\r\nDRM_DEBUG_DRIVER("hsa_time=%d, hbp_time=%d, hline_time=%d\n",\r\nhsa_time, hbp_time, hline_time);\r\n}\r\nstatic void dsi_set_video_mode(void __iomem *base, unsigned long flags)\r\n{\r\nu32 val;\r\nu32 mode_mask = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\r\nMIPI_DSI_MODE_VIDEO_SYNC_PULSE;\r\nu32 non_burst_sync_pulse = MIPI_DSI_MODE_VIDEO |\r\nMIPI_DSI_MODE_VIDEO_SYNC_PULSE;\r\nu32 non_burst_sync_event = MIPI_DSI_MODE_VIDEO;\r\nif ((flags & mode_mask) == non_burst_sync_pulse)\r\nval = DSI_NON_BURST_SYNC_PULSES;\r\nelse if ((flags & mode_mask) == non_burst_sync_event)\r\nval = DSI_NON_BURST_SYNC_EVENTS;\r\nelse\r\nval = DSI_BURST_SYNC_PULSES_1;\r\nwritel(val, base + VID_MODE_CFG);\r\nwritel(PHY_TXREQUESTCLKHS, base + LPCLK_CTRL);\r\nwritel(DSI_VIDEO_MODE, base + MODE_CFG);\r\n}\r\nstatic void dsi_mipi_init(struct dw_dsi *dsi)\r\n{\r\nstruct dsi_hw_ctx *ctx = dsi->ctx;\r\nstruct mipi_phy_params *phy = &dsi->phy;\r\nstruct drm_display_mode *mode = &dsi->cur_mode;\r\nu32 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\r\nvoid __iomem *base = ctx->base;\r\nu32 dphy_req_kHz;\r\ndphy_req_kHz = mode->clock * bpp / dsi->lanes;\r\ndsi_get_phy_params(dphy_req_kHz, phy);\r\nwritel(RESET, base + PWR_UP);\r\ndsi_set_mipi_phy(base, phy, dsi->lanes);\r\ndsi_set_mode_timing(base, phy->lane_byte_clk_kHz, mode, dsi->format);\r\ndsi_set_video_mode(base, dsi->mode_flags);\r\nwritel(POWERUP, base + PWR_UP);\r\nDRM_DEBUG_DRIVER("lanes=%d, pixel_clk=%d kHz, bytes_freq=%d kHz\n",\r\ndsi->lanes, mode->clock, phy->lane_byte_clk_kHz);\r\n}\r\nstatic void dsi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct dw_dsi *dsi = encoder_to_dsi(encoder);\r\nstruct dsi_hw_ctx *ctx = dsi->ctx;\r\nvoid __iomem *base = ctx->base;\r\nif (!dsi->enable)\r\nreturn;\r\nwritel(0, base + PWR_UP);\r\nwritel(0, base + LPCLK_CTRL);\r\nwritel(0, base + PHY_RSTZ);\r\nclk_disable_unprepare(ctx->pclk);\r\ndsi->enable = false;\r\n}\r\nstatic void dsi_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct dw_dsi *dsi = encoder_to_dsi(encoder);\r\nstruct dsi_hw_ctx *ctx = dsi->ctx;\r\nint ret;\r\nif (dsi->enable)\r\nreturn;\r\nret = clk_prepare_enable(ctx->pclk);\r\nif (ret) {\r\nDRM_ERROR("fail to enable pclk: %d\n", ret);\r\nreturn;\r\n}\r\ndsi_mipi_init(dsi);\r\ndsi->enable = true;\r\n}\r\nstatic void dsi_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\nstruct dw_dsi *dsi = encoder_to_dsi(encoder);\r\ndrm_mode_copy(&dsi->cur_mode, adj_mode);\r\n}\r\nstatic int dsi_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dw_drm_encoder_init(struct device *dev,\r\nstruct drm_device *drm_dev,\r\nstruct drm_encoder *encoder)\r\n{\r\nint ret;\r\nu32 crtc_mask = drm_of_find_possible_crtcs(drm_dev, dev->of_node);\r\nif (!crtc_mask) {\r\nDRM_ERROR("failed to find crtc mask\n");\r\nreturn -EINVAL;\r\n}\r\nencoder->possible_crtcs = crtc_mask;\r\nret = drm_encoder_init(drm_dev, encoder, &dw_encoder_funcs,\r\nDRM_MODE_ENCODER_DSI, NULL);\r\nif (ret) {\r\nDRM_ERROR("failed to init dsi encoder\n");\r\nreturn ret;\r\n}\r\ndrm_encoder_helper_add(encoder, &dw_encoder_helper_funcs);\r\nreturn 0;\r\n}\r\nstatic int dsi_host_attach(struct mipi_dsi_host *host,\r\nstruct mipi_dsi_device *mdsi)\r\n{\r\nstruct dw_dsi *dsi = host_to_dsi(host);\r\nif (mdsi->lanes < 1 || mdsi->lanes > 4) {\r\nDRM_ERROR("dsi device params invalid\n");\r\nreturn -EINVAL;\r\n}\r\ndsi->lanes = mdsi->lanes;\r\ndsi->format = mdsi->format;\r\ndsi->mode_flags = mdsi->mode_flags;\r\nreturn 0;\r\n}\r\nstatic int dsi_host_detach(struct mipi_dsi_host *host,\r\nstruct mipi_dsi_device *mdsi)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dsi_host_init(struct device *dev, struct dw_dsi *dsi)\r\n{\r\nstruct mipi_dsi_host *host = &dsi->host;\r\nint ret;\r\nhost->dev = dev;\r\nhost->ops = &dsi_host_ops;\r\nret = mipi_dsi_host_register(host);\r\nif (ret) {\r\nDRM_ERROR("failed to register dsi host\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_bridge_init(struct drm_device *dev, struct dw_dsi *dsi)\r\n{\r\nstruct drm_encoder *encoder = &dsi->encoder;\r\nstruct drm_bridge *bridge = dsi->bridge;\r\nint ret;\r\nencoder->bridge = bridge;\r\nbridge->encoder = encoder;\r\nret = drm_bridge_attach(dev, bridge);\r\nif (ret) {\r\nDRM_ERROR("failed to attach external bridge\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct dsi_data *ddata = dev_get_drvdata(dev);\r\nstruct dw_dsi *dsi = &ddata->dsi;\r\nstruct drm_device *drm_dev = data;\r\nint ret;\r\nret = dw_drm_encoder_init(dev, drm_dev, &dsi->encoder);\r\nif (ret)\r\nreturn ret;\r\nret = dsi_host_init(dev, dsi);\r\nif (ret)\r\nreturn ret;\r\nret = dsi_bridge_init(drm_dev, dsi);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void dsi_unbind(struct device *dev, struct device *master, void *data)\r\n{\r\n}\r\nstatic int dsi_parse_dt(struct platform_device *pdev, struct dw_dsi *dsi)\r\n{\r\nstruct dsi_hw_ctx *ctx = dsi->ctx;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *endpoint, *bridge_node;\r\nstruct drm_bridge *bridge;\r\nstruct resource *res;\r\nendpoint = of_graph_get_endpoint_by_regs(np, 1, -1);\r\nif (!endpoint) {\r\nDRM_ERROR("no valid endpoint node\n");\r\nreturn -ENODEV;\r\n}\r\nof_node_put(endpoint);\r\nbridge_node = of_graph_get_remote_port_parent(endpoint);\r\nif (!bridge_node) {\r\nDRM_ERROR("no valid bridge node\n");\r\nreturn -ENODEV;\r\n}\r\nof_node_put(bridge_node);\r\nbridge = of_drm_find_bridge(bridge_node);\r\nif (!bridge) {\r\nDRM_INFO("wait for external HDMI bridge driver.\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\ndsi->bridge = bridge;\r\nctx->pclk = devm_clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(ctx->pclk)) {\r\nDRM_ERROR("failed to get pclk clock\n");\r\nreturn PTR_ERR(ctx->pclk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nctx->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ctx->base)) {\r\nDRM_ERROR("failed to remap dsi io region\n");\r\nreturn PTR_ERR(ctx->base);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_probe(struct platform_device *pdev)\r\n{\r\nstruct dsi_data *data;\r\nstruct dw_dsi *dsi;\r\nstruct dsi_hw_ctx *ctx;\r\nint ret;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\nDRM_ERROR("failed to allocate dsi data.\n");\r\nreturn -ENOMEM;\r\n}\r\ndsi = &data->dsi;\r\nctx = &data->ctx;\r\ndsi->ctx = ctx;\r\nret = dsi_parse_dt(pdev, dsi);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, data);\r\nreturn component_add(&pdev->dev, &dsi_ops);\r\n}\r\nstatic int dsi_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &dsi_ops);\r\nreturn 0;\r\n}
