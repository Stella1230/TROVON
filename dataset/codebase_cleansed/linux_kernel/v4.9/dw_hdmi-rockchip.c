static int rockchip_hdmi_parse_dt(struct rockchip_hdmi *hdmi)\r\n{\r\nstruct device_node *np = hdmi->dev->of_node;\r\nhdmi->regmap = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");\r\nif (IS_ERR(hdmi->regmap)) {\r\ndev_err(hdmi->dev, "Unable to get rockchip,grf\n");\r\nreturn PTR_ERR(hdmi->regmap);\r\n}\r\nreturn 0;\r\n}\r\nstatic enum drm_mode_status\r\ndw_hdmi_rockchip_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nconst struct dw_hdmi_mpll_config *mpll_cfg = rockchip_mpll_cfg;\r\nint pclk = mode->clock * 1000;\r\nbool valid = false;\r\nint i;\r\nfor (i = 0; mpll_cfg[i].mpixelclock != (~0UL); i++) {\r\nif (pclk == mpll_cfg[i].mpixelclock) {\r\nvalid = true;\r\nbreak;\r\n}\r\n}\r\nreturn (valid) ? MODE_OK : MODE_BAD;\r\n}\r\nstatic void dw_hdmi_rockchip_encoder_disable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic bool\r\ndw_hdmi_rockchip_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void dw_hdmi_rockchip_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\n}\r\nstatic void dw_hdmi_rockchip_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct rockchip_hdmi *hdmi = to_rockchip_hdmi(encoder);\r\nu32 val;\r\nint mux;\r\nmux = drm_of_encoder_active_endpoint_id(hdmi->dev->of_node, encoder);\r\nif (mux)\r\nval = HDMI_SEL_VOP_LIT | (HDMI_SEL_VOP_LIT << 16);\r\nelse\r\nval = HDMI_SEL_VOP_LIT << 16;\r\nregmap_write(hdmi->regmap, GRF_SOC_CON6, val);\r\ndev_dbg(hdmi->dev, "vop %s output to hdmi\n",\r\n(mux) ? "LIT" : "BIG");\r\n}\r\nstatic int\r\ndw_hdmi_rockchip_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\r\ns->output_mode = ROCKCHIP_OUT_MODE_AAAA;\r\ns->output_type = DRM_MODE_CONNECTOR_HDMIA;\r\nreturn 0;\r\n}\r\nstatic int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nconst struct dw_hdmi_plat_data *plat_data;\r\nconst struct of_device_id *match;\r\nstruct drm_device *drm = data;\r\nstruct drm_encoder *encoder;\r\nstruct rockchip_hdmi *hdmi;\r\nstruct resource *iores;\r\nint irq;\r\nint ret;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nhdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\r\nif (!hdmi)\r\nreturn -ENOMEM;\r\nmatch = of_match_node(dw_hdmi_rockchip_dt_ids, pdev->dev.of_node);\r\nplat_data = match->data;\r\nhdmi->dev = &pdev->dev;\r\nencoder = &hdmi->encoder;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iores)\r\nreturn -ENXIO;\r\nencoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);\r\nif (encoder->possible_crtcs == 0)\r\nreturn -EPROBE_DEFER;\r\nret = rockchip_hdmi_parse_dt(hdmi);\r\nif (ret) {\r\ndev_err(hdmi->dev, "Unable to parse OF data\n");\r\nreturn ret;\r\n}\r\ndrm_encoder_helper_add(encoder, &dw_hdmi_rockchip_encoder_helper_funcs);\r\ndrm_encoder_init(drm, encoder, &dw_hdmi_rockchip_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, NULL);\r\nret = dw_hdmi_bind(dev, master, data, encoder, iores, irq, plat_data);\r\nif (ret)\r\ndrm_encoder_cleanup(encoder);\r\nreturn ret;\r\n}\r\nstatic void dw_hdmi_rockchip_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nreturn dw_hdmi_unbind(dev, master, data);\r\n}\r\nstatic int dw_hdmi_rockchip_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &dw_hdmi_rockchip_ops);\r\n}\r\nstatic int dw_hdmi_rockchip_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &dw_hdmi_rockchip_ops);\r\nreturn 0;\r\n}
