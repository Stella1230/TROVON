static inline u32 qspi_readl(struct atmel_qspi *aq, u32 reg)\r\n{\r\nreturn readl_relaxed(aq->regs + reg);\r\n}\r\nstatic inline void qspi_writel(struct atmel_qspi *aq, u32 reg, u32 value)\r\n{\r\nwritel_relaxed(value, aq->regs + reg);\r\n}\r\nstatic int atmel_qspi_run_transfer(struct atmel_qspi *aq,\r\nconst struct atmel_qspi_command *cmd)\r\n{\r\nvoid __iomem *ahb_mem;\r\nahb_mem = aq->mem;\r\nif (cmd->enable.bits.address)\r\nahb_mem += cmd->address;\r\nif (cmd->tx_buf)\r\n_memcpy_toio(ahb_mem, cmd->tx_buf, cmd->buf_len);\r\nelse\r\n_memcpy_fromio(cmd->rx_buf, ahb_mem, cmd->buf_len);\r\nreturn 0;\r\n}\r\nstatic void atmel_qspi_debug_command(struct atmel_qspi *aq,\r\nconst struct atmel_qspi_command *cmd,\r\nu32 ifr)\r\n{\r\nu8 cmd_buf[SPI_NOR_MAX_CMD_SIZE];\r\nsize_t len = 0;\r\nint i;\r\nif (cmd->enable.bits.instruction)\r\ncmd_buf[len++] = cmd->instruction;\r\nfor (i = cmd->enable.bits.address-1; i >= 0; --i)\r\ncmd_buf[len++] = (cmd->address >> (i << 3)) & 0xff;\r\nif (cmd->enable.bits.mode)\r\ncmd_buf[len++] = cmd->mode;\r\nif (cmd->enable.bits.dummy) {\r\nint num = cmd->num_dummy_cycles;\r\nswitch (ifr & QSPI_IFR_WIDTH_MASK) {\r\ncase QSPI_IFR_WIDTH_SINGLE_BIT_SPI:\r\ncase QSPI_IFR_WIDTH_DUAL_OUTPUT:\r\ncase QSPI_IFR_WIDTH_QUAD_OUTPUT:\r\nnum >>= 3;\r\nbreak;\r\ncase QSPI_IFR_WIDTH_DUAL_IO:\r\ncase QSPI_IFR_WIDTH_DUAL_CMD:\r\nnum >>= 2;\r\nbreak;\r\ncase QSPI_IFR_WIDTH_QUAD_IO:\r\ncase QSPI_IFR_WIDTH_QUAD_CMD:\r\nnum >>= 1;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nfor (i = 0; i < num; ++i)\r\ncmd_buf[len++] = 0;\r\n}\r\nprint_hex_dump(KERN_DEBUG, "qspi cmd: ", DUMP_PREFIX_NONE,\r\n32, 1, cmd_buf, len, false);\r\n#ifdef VERBOSE_DEBUG\r\nif (cmd->enable.bits.data && cmd->tx_buf)\r\nprint_hex_dump(KERN_DEBUG, "qspi tx : ", DUMP_PREFIX_NONE,\r\n32, 1, cmd->tx_buf, cmd->buf_len, false);\r\n#endif\r\n}\r\nstatic int atmel_qspi_run_command(struct atmel_qspi *aq,\r\nconst struct atmel_qspi_command *cmd,\r\nu32 ifr_tfrtyp, u32 ifr_width)\r\n{\r\nu32 iar, icr, ifr, sr;\r\nint err = 0;\r\niar = 0;\r\nicr = 0;\r\nifr = ifr_tfrtyp | ifr_width;\r\nif (cmd->enable.bits.instruction) {\r\nicr |= QSPI_ICR_INST(cmd->instruction);\r\nifr |= QSPI_IFR_INSTEN;\r\n}\r\nswitch (cmd->enable.bits.address) {\r\ncase 4:\r\nifr |= QSPI_IFR_ADDRL;\r\ncase 3:\r\niar = (cmd->enable.bits.data) ? 0 : cmd->address;\r\nifr |= QSPI_IFR_ADDREN;\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (cmd->enable.bits.mode && cmd->num_mode_cycles) {\r\nu32 mode_cycle_bits, mode_bits;\r\nicr |= QSPI_ICR_OPT(cmd->mode);\r\nifr |= QSPI_IFR_OPTEN;\r\nswitch (ifr & QSPI_IFR_WIDTH_MASK) {\r\ncase QSPI_IFR_WIDTH_SINGLE_BIT_SPI:\r\ncase QSPI_IFR_WIDTH_DUAL_OUTPUT:\r\ncase QSPI_IFR_WIDTH_QUAD_OUTPUT:\r\nmode_cycle_bits = 1;\r\nbreak;\r\ncase QSPI_IFR_WIDTH_DUAL_IO:\r\ncase QSPI_IFR_WIDTH_DUAL_CMD:\r\nmode_cycle_bits = 2;\r\nbreak;\r\ncase QSPI_IFR_WIDTH_QUAD_IO:\r\ncase QSPI_IFR_WIDTH_QUAD_CMD:\r\nmode_cycle_bits = 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmode_bits = cmd->num_mode_cycles * mode_cycle_bits;\r\nswitch (mode_bits) {\r\ncase 1:\r\nifr |= QSPI_IFR_OPTL_1BIT;\r\nbreak;\r\ncase 2:\r\nifr |= QSPI_IFR_OPTL_2BIT;\r\nbreak;\r\ncase 4:\r\nifr |= QSPI_IFR_OPTL_4BIT;\r\nbreak;\r\ncase 8:\r\nifr |= QSPI_IFR_OPTL_8BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (cmd->enable.bits.dummy)\r\nifr |= QSPI_IFR_NBDUM(cmd->num_dummy_cycles);\r\nif (cmd->enable.bits.data) {\r\nifr |= QSPI_IFR_DATAEN;\r\nif (!cmd->tx_buf && !cmd->rx_buf)\r\nifr |= QSPI_IFR_CRM;\r\n}\r\n(void)qspi_readl(aq, QSPI_SR);\r\natmel_qspi_debug_command(aq, cmd, ifr);\r\nqspi_writel(aq, QSPI_IAR, iar);\r\nqspi_writel(aq, QSPI_ICR, icr);\r\nqspi_writel(aq, QSPI_IFR, ifr);\r\nif (!cmd->enable.bits.data)\r\ngoto no_data;\r\n(void)qspi_readl(aq, QSPI_IFR);\r\nif (!cmd->tx_buf && !cmd->rx_buf)\r\nreturn 0;\r\nerr = atmel_qspi_run_transfer(aq, cmd);\r\nqspi_writel(aq, QSPI_CR, QSPI_CR_LASTXFER);\r\nif (err)\r\nreturn err;\r\n#if defined(DEBUG) && defined(VERBOSE_DEBUG)\r\nif (cmd->rx_buf)\r\nprint_hex_dump(KERN_DEBUG, "qspi rx : ", DUMP_PREFIX_NONE,\r\n32, 1, cmd->rx_buf, cmd->buf_len, false);\r\n#endif\r\nno_data:\r\nsr = qspi_readl(aq, QSPI_SR);\r\nif ((sr & QSPI_SR_CMD_COMPLETED) == QSPI_SR_CMD_COMPLETED)\r\nreturn err;\r\nreinit_completion(&aq->cmd_completion);\r\naq->pending = sr & QSPI_SR_CMD_COMPLETED;\r\nqspi_writel(aq, QSPI_IER, QSPI_SR_CMD_COMPLETED);\r\nif (!wait_for_completion_timeout(&aq->cmd_completion,\r\nmsecs_to_jiffies(1000)))\r\nerr = -ETIMEDOUT;\r\nqspi_writel(aq, QSPI_IDR, QSPI_SR_CMD_COMPLETED);\r\nreturn err;\r\n}\r\nstatic int atmel_qspi_read_reg(struct spi_nor *nor, u8 opcode,\r\nu8 *buf, int len)\r\n{\r\nstruct atmel_qspi *aq = nor->priv;\r\nstruct atmel_qspi_command cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.enable.bits.instruction = 1;\r\ncmd.enable.bits.data = 1;\r\ncmd.instruction = opcode;\r\ncmd.rx_buf = buf;\r\ncmd.buf_len = len;\r\nreturn atmel_qspi_run_command(aq, &cmd, QSPI_IFR_TFRTYP_TRSFR_READ,\r\nQSPI_IFR_WIDTH_SINGLE_BIT_SPI);\r\n}\r\nstatic int atmel_qspi_write_reg(struct spi_nor *nor, u8 opcode,\r\nu8 *buf, int len)\r\n{\r\nstruct atmel_qspi *aq = nor->priv;\r\nstruct atmel_qspi_command cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.enable.bits.instruction = 1;\r\ncmd.enable.bits.data = (buf != NULL && len > 0);\r\ncmd.instruction = opcode;\r\ncmd.tx_buf = buf;\r\ncmd.buf_len = len;\r\nreturn atmel_qspi_run_command(aq, &cmd, QSPI_IFR_TFRTYP_TRSFR_WRITE,\r\nQSPI_IFR_WIDTH_SINGLE_BIT_SPI);\r\n}\r\nstatic ssize_t atmel_qspi_write(struct spi_nor *nor, loff_t to, size_t len,\r\nconst u_char *write_buf)\r\n{\r\nstruct atmel_qspi *aq = nor->priv;\r\nstruct atmel_qspi_command cmd;\r\nssize_t ret;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.enable.bits.instruction = 1;\r\ncmd.enable.bits.address = nor->addr_width;\r\ncmd.enable.bits.data = 1;\r\ncmd.instruction = nor->program_opcode;\r\ncmd.address = (u32)to;\r\ncmd.tx_buf = write_buf;\r\ncmd.buf_len = len;\r\nret = atmel_qspi_run_command(aq, &cmd, QSPI_IFR_TFRTYP_TRSFR_WRITE_MEM,\r\nQSPI_IFR_WIDTH_SINGLE_BIT_SPI);\r\nreturn (ret < 0) ? ret : len;\r\n}\r\nstatic int atmel_qspi_erase(struct spi_nor *nor, loff_t offs)\r\n{\r\nstruct atmel_qspi *aq = nor->priv;\r\nstruct atmel_qspi_command cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.enable.bits.instruction = 1;\r\ncmd.enable.bits.address = nor->addr_width;\r\ncmd.instruction = nor->erase_opcode;\r\ncmd.address = (u32)offs;\r\nreturn atmel_qspi_run_command(aq, &cmd, QSPI_IFR_TFRTYP_TRSFR_WRITE,\r\nQSPI_IFR_WIDTH_SINGLE_BIT_SPI);\r\n}\r\nstatic ssize_t atmel_qspi_read(struct spi_nor *nor, loff_t from, size_t len,\r\nu_char *read_buf)\r\n{\r\nstruct atmel_qspi *aq = nor->priv;\r\nstruct atmel_qspi_command cmd;\r\nu8 num_mode_cycles, num_dummy_cycles;\r\nu32 ifr_width;\r\nssize_t ret;\r\nswitch (nor->flash_read) {\r\ncase SPI_NOR_NORMAL:\r\ncase SPI_NOR_FAST:\r\nifr_width = QSPI_IFR_WIDTH_SINGLE_BIT_SPI;\r\nbreak;\r\ncase SPI_NOR_DUAL:\r\nifr_width = QSPI_IFR_WIDTH_DUAL_OUTPUT;\r\nbreak;\r\ncase SPI_NOR_QUAD:\r\nifr_width = QSPI_IFR_WIDTH_QUAD_OUTPUT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (nor->read_dummy >= 2) {\r\nnum_mode_cycles = 2;\r\nnum_dummy_cycles = nor->read_dummy - 2;\r\n} else {\r\nnum_mode_cycles = nor->read_dummy;\r\nnum_dummy_cycles = 0;\r\n}\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.enable.bits.instruction = 1;\r\ncmd.enable.bits.address = nor->addr_width;\r\ncmd.enable.bits.mode = (num_mode_cycles > 0);\r\ncmd.enable.bits.dummy = (num_dummy_cycles > 0);\r\ncmd.enable.bits.data = 1;\r\ncmd.instruction = nor->read_opcode;\r\ncmd.address = (u32)from;\r\ncmd.mode = 0xff;\r\ncmd.num_mode_cycles = num_mode_cycles;\r\ncmd.num_dummy_cycles = num_dummy_cycles;\r\ncmd.rx_buf = read_buf;\r\ncmd.buf_len = len;\r\nret = atmel_qspi_run_command(aq, &cmd, QSPI_IFR_TFRTYP_TRSFR_READ_MEM,\r\nifr_width);\r\nreturn (ret < 0) ? ret : len;\r\n}\r\nstatic int atmel_qspi_init(struct atmel_qspi *aq)\r\n{\r\nunsigned long src_rate;\r\nu32 mr, scr, scbr;\r\nqspi_writel(aq, QSPI_CR, QSPI_CR_SWRST);\r\nmr = QSPI_MR_NBBITS(8) | QSPI_MR_SSM;\r\nqspi_writel(aq, QSPI_MR, mr);\r\nsrc_rate = clk_get_rate(aq->clk);\r\nif (!src_rate)\r\nreturn -EINVAL;\r\nscbr = DIV_ROUND_UP(src_rate, aq->clk_rate);\r\nif (scbr > 0)\r\nscbr--;\r\nscr = QSPI_SCR_SCBR(scbr);\r\nqspi_writel(aq, QSPI_SCR, scr);\r\nqspi_writel(aq, QSPI_CR, QSPI_CR_QSPIEN);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t atmel_qspi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_qspi *aq = (struct atmel_qspi *)dev_id;\r\nu32 status, mask, pending;\r\nstatus = qspi_readl(aq, QSPI_SR);\r\nmask = qspi_readl(aq, QSPI_IMR);\r\npending = status & mask;\r\nif (!pending)\r\nreturn IRQ_NONE;\r\naq->pending |= pending;\r\nif ((aq->pending & QSPI_SR_CMD_COMPLETED) == QSPI_SR_CMD_COMPLETED)\r\ncomplete(&aq->cmd_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmel_qspi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *child, *np = pdev->dev.of_node;\r\nstruct atmel_qspi *aq;\r\nstruct resource *res;\r\nstruct spi_nor *nor;\r\nstruct mtd_info *mtd;\r\nint irq, err = 0;\r\nif (of_get_child_count(np) != 1)\r\nreturn -ENODEV;\r\nchild = of_get_next_child(np, NULL);\r\naq = devm_kzalloc(&pdev->dev, sizeof(*aq), GFP_KERNEL);\r\nif (!aq) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nplatform_set_drvdata(pdev, aq);\r\ninit_completion(&aq->cmd_completion);\r\naq->pdev = pdev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qspi_base");\r\naq->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(aq->regs)) {\r\ndev_err(&pdev->dev, "missing registers\n");\r\nerr = PTR_ERR(aq->regs);\r\ngoto exit;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qspi_mmap");\r\naq->mem = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(aq->mem)) {\r\ndev_err(&pdev->dev, "missing AHB memory\n");\r\nerr = PTR_ERR(aq->mem);\r\ngoto exit;\r\n}\r\naq->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(aq->clk)) {\r\ndev_err(&pdev->dev, "missing peripheral clock\n");\r\nerr = PTR_ERR(aq->clk);\r\ngoto exit;\r\n}\r\nerr = clk_prepare_enable(aq->clk);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to enable the peripheral clock\n");\r\ngoto exit;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "missing IRQ\n");\r\nerr = irq;\r\ngoto disable_clk;\r\n}\r\nerr = devm_request_irq(&pdev->dev, irq, atmel_qspi_interrupt,\r\n0, dev_name(&pdev->dev), aq);\r\nif (err)\r\ngoto disable_clk;\r\nnor = &aq->nor;\r\nmtd = &nor->mtd;\r\nnor->dev = &pdev->dev;\r\nspi_nor_set_flash_node(nor, child);\r\nnor->priv = aq;\r\nmtd->priv = nor;\r\nnor->read_reg = atmel_qspi_read_reg;\r\nnor->write_reg = atmel_qspi_write_reg;\r\nnor->read = atmel_qspi_read;\r\nnor->write = atmel_qspi_write;\r\nnor->erase = atmel_qspi_erase;\r\nerr = of_property_read_u32(child, "spi-max-frequency", &aq->clk_rate);\r\nif (err < 0)\r\ngoto disable_clk;\r\nerr = atmel_qspi_init(aq);\r\nif (err)\r\ngoto disable_clk;\r\nerr = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\r\nif (err)\r\ngoto disable_clk;\r\nerr = mtd_device_register(mtd, NULL, 0);\r\nif (err)\r\ngoto disable_clk;\r\nof_node_put(child);\r\nreturn 0;\r\ndisable_clk:\r\nclk_disable_unprepare(aq->clk);\r\nexit:\r\nof_node_put(child);\r\nreturn err;\r\n}\r\nstatic int atmel_qspi_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_qspi *aq = platform_get_drvdata(pdev);\r\nmtd_device_unregister(&aq->nor.mtd);\r\nqspi_writel(aq, QSPI_CR, QSPI_CR_QSPIDIS);\r\nclk_disable_unprepare(aq->clk);\r\nreturn 0;\r\n}
