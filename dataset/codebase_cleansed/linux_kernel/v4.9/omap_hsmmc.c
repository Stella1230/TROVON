static int omap_hsmmc_card_detect(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nreturn mmc_gpio_get_cd(host->mmc);\r\n}\r\nstatic int omap_hsmmc_get_cover_state(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nreturn mmc_gpio_get_cd(host->mmc);\r\n}\r\nstatic int omap_hsmmc_enable_supply(struct mmc_host *mmc)\r\n{\r\nint ret;\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nstruct mmc_ios *ios = &mmc->ios;\r\nif (mmc->supply.vmmc) {\r\nret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (mmc->supply.vqmmc && !host->vqmmc_enabled) {\r\nret = regulator_enable(mmc->supply.vqmmc);\r\nif (ret) {\r\ndev_err(mmc_dev(mmc), "vmmc_aux reg enable failed\n");\r\ngoto err_vqmmc;\r\n}\r\nhost->vqmmc_enabled = 1;\r\n}\r\nreturn 0;\r\nerr_vqmmc:\r\nif (mmc->supply.vmmc)\r\nmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_disable_supply(struct mmc_host *mmc)\r\n{\r\nint ret;\r\nint status;\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nif (mmc->supply.vqmmc && host->vqmmc_enabled) {\r\nret = regulator_disable(mmc->supply.vqmmc);\r\nif (ret) {\r\ndev_err(mmc_dev(mmc), "vmmc_aux reg disable failed\n");\r\nreturn ret;\r\n}\r\nhost->vqmmc_enabled = 0;\r\n}\r\nif (mmc->supply.vmmc) {\r\nret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\r\nif (ret)\r\ngoto err_set_ocr;\r\n}\r\nreturn 0;\r\nerr_set_ocr:\r\nif (mmc->supply.vqmmc) {\r\nstatus = regulator_enable(mmc->supply.vqmmc);\r\nif (status)\r\ndev_err(mmc_dev(mmc), "vmmc_aux re-enable failed\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_set_pbias(struct omap_hsmmc_host *host, bool power_on,\r\nint vdd)\r\n{\r\nint ret;\r\nif (!host->pbias)\r\nreturn 0;\r\nif (power_on) {\r\nif (vdd <= VDD_165_195)\r\nret = regulator_set_voltage(host->pbias, VDD_1V8,\r\nVDD_1V8);\r\nelse\r\nret = regulator_set_voltage(host->pbias, VDD_3V0,\r\nVDD_3V0);\r\nif (ret < 0) {\r\ndev_err(host->dev, "pbias set voltage fail\n");\r\nreturn ret;\r\n}\r\nif (host->pbias_enabled == 0) {\r\nret = regulator_enable(host->pbias);\r\nif (ret) {\r\ndev_err(host->dev, "pbias reg enable fail\n");\r\nreturn ret;\r\n}\r\nhost->pbias_enabled = 1;\r\n}\r\n} else {\r\nif (host->pbias_enabled == 1) {\r\nret = regulator_disable(host->pbias);\r\nif (ret) {\r\ndev_err(host->dev, "pbias reg disable fail\n");\r\nreturn ret;\r\n}\r\nhost->pbias_enabled = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_set_power(struct omap_hsmmc_host *host, int power_on,\r\nint vdd)\r\n{\r\nstruct mmc_host *mmc = host->mmc;\r\nint ret = 0;\r\nif (mmc_pdata(host)->set_power)\r\nreturn mmc_pdata(host)->set_power(host->dev, power_on, vdd);\r\nif (!mmc->supply.vmmc)\r\nreturn 0;\r\nif (mmc_pdata(host)->before_set_reg)\r\nmmc_pdata(host)->before_set_reg(host->dev, power_on, vdd);\r\nret = omap_hsmmc_set_pbias(host, false, 0);\r\nif (ret)\r\nreturn ret;\r\nif (power_on) {\r\nret = omap_hsmmc_enable_supply(mmc);\r\nif (ret)\r\nreturn ret;\r\nret = omap_hsmmc_set_pbias(host, true, vdd);\r\nif (ret)\r\ngoto err_set_voltage;\r\n} else {\r\nret = omap_hsmmc_disable_supply(mmc);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (mmc_pdata(host)->after_set_reg)\r\nmmc_pdata(host)->after_set_reg(host->dev, power_on, vdd);\r\nreturn 0;\r\nerr_set_voltage:\r\nomap_hsmmc_disable_supply(mmc);\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_disable_boot_regulator(struct regulator *reg)\r\n{\r\nint ret;\r\nif (!reg)\r\nreturn 0;\r\nif (regulator_is_enabled(reg)) {\r\nret = regulator_enable(reg);\r\nif (ret)\r\nreturn ret;\r\nret = regulator_disable(reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_disable_boot_regulators(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_host *mmc = host->mmc;\r\nint ret;\r\nret = omap_hsmmc_disable_boot_regulator(mmc->supply.vmmc);\r\nif (ret) {\r\ndev_err(host->dev, "fail to disable boot enabled vmmc reg\n");\r\nreturn ret;\r\n}\r\nret = omap_hsmmc_disable_boot_regulator(mmc->supply.vqmmc);\r\nif (ret) {\r\ndev_err(host->dev,\r\n"fail to disable boot enabled vmmc_aux reg\n");\r\nreturn ret;\r\n}\r\nret = omap_hsmmc_disable_boot_regulator(host->pbias);\r\nif (ret) {\r\ndev_err(host->dev,\r\n"failed to disable boot enabled pbias reg\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)\r\n{\r\nint ocr_value = 0;\r\nint ret;\r\nstruct mmc_host *mmc = host->mmc;\r\nif (mmc_pdata(host)->set_power)\r\nreturn 0;\r\nmmc->supply.vmmc = devm_regulator_get_optional(host->dev, "vmmc");\r\nif (IS_ERR(mmc->supply.vmmc)) {\r\nret = PTR_ERR(mmc->supply.vmmc);\r\nif ((ret != -ENODEV) && host->dev->of_node)\r\nreturn ret;\r\ndev_dbg(host->dev, "unable to get vmmc regulator %ld\n",\r\nPTR_ERR(mmc->supply.vmmc));\r\nmmc->supply.vmmc = NULL;\r\n} else {\r\nocr_value = mmc_regulator_get_ocrmask(mmc->supply.vmmc);\r\nif (ocr_value > 0)\r\nmmc_pdata(host)->ocr_mask = ocr_value;\r\n}\r\nmmc->supply.vqmmc = devm_regulator_get_optional(host->dev, "vmmc_aux");\r\nif (IS_ERR(mmc->supply.vqmmc)) {\r\nret = PTR_ERR(mmc->supply.vqmmc);\r\nif ((ret != -ENODEV) && host->dev->of_node)\r\nreturn ret;\r\ndev_dbg(host->dev, "unable to get vmmc_aux regulator %ld\n",\r\nPTR_ERR(mmc->supply.vqmmc));\r\nmmc->supply.vqmmc = NULL;\r\n}\r\nhost->pbias = devm_regulator_get_optional(host->dev, "pbias");\r\nif (IS_ERR(host->pbias)) {\r\nret = PTR_ERR(host->pbias);\r\nif ((ret != -ENODEV) && host->dev->of_node) {\r\ndev_err(host->dev,\r\n"SD card detect fail? enable CONFIG_REGULATOR_PBIAS\n");\r\nreturn ret;\r\n}\r\ndev_dbg(host->dev, "unable to get pbias regulator %ld\n",\r\nPTR_ERR(host->pbias));\r\nhost->pbias = NULL;\r\n}\r\nif (mmc_pdata(host)->no_regulator_off_init)\r\nreturn 0;\r\nret = omap_hsmmc_disable_boot_regulators(host);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_gpio_init(struct mmc_host *mmc,\r\nstruct omap_hsmmc_host *host,\r\nstruct omap_hsmmc_platform_data *pdata)\r\n{\r\nint ret;\r\nif (gpio_is_valid(pdata->gpio_cod)) {\r\nret = mmc_gpio_request_cd(mmc, pdata->gpio_cod, 0);\r\nif (ret)\r\nreturn ret;\r\nhost->get_cover_state = omap_hsmmc_get_cover_state;\r\nmmc_gpio_set_cd_isr(mmc, omap_hsmmc_cover_irq);\r\n} else if (gpio_is_valid(pdata->gpio_cd)) {\r\nret = mmc_gpio_request_cd(mmc, pdata->gpio_cd, 0);\r\nif (ret)\r\nreturn ret;\r\nhost->card_detect = omap_hsmmc_card_detect;\r\n}\r\nif (gpio_is_valid(pdata->gpio_wp)) {\r\nret = mmc_gpio_request_ro(mmc, pdata->gpio_wp);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_start_clock(struct omap_hsmmc_host *host)\r\n{\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL,\r\nOMAP_HSMMC_READ(host->base, SYSCTL) | CEN);\r\n}\r\nstatic void omap_hsmmc_stop_clock(struct omap_hsmmc_host *host)\r\n{\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL,\r\nOMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);\r\nif ((OMAP_HSMMC_READ(host->base, SYSCTL) & CEN) != 0x0)\r\ndev_dbg(mmc_dev(host->mmc), "MMC Clock is not stopped\n");\r\n}\r\nstatic void omap_hsmmc_enable_irq(struct omap_hsmmc_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nu32 irq_mask = INT_EN_MASK;\r\nunsigned long flags;\r\nif (host->use_dma)\r\nirq_mask &= ~(BRR_EN | BWR_EN);\r\nif (cmd->opcode == MMC_ERASE)\r\nirq_mask &= ~DTO_EN;\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nOMAP_HSMMC_WRITE(host->base, ISE, irq_mask);\r\nif (host->flags & HSMMC_SDIO_IRQ_ENABLED)\r\nirq_mask |= CIRQ_EN;\r\nOMAP_HSMMC_WRITE(host->base, IE, irq_mask);\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\n}\r\nstatic void omap_hsmmc_disable_irq(struct omap_hsmmc_host *host)\r\n{\r\nu32 irq_mask = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\nif (host->flags & HSMMC_SDIO_IRQ_ENABLED)\r\nirq_mask |= CIRQ_EN;\r\nOMAP_HSMMC_WRITE(host->base, ISE, irq_mask);\r\nOMAP_HSMMC_WRITE(host->base, IE, irq_mask);\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\n}\r\nstatic u16 calc_divisor(struct omap_hsmmc_host *host, struct mmc_ios *ios)\r\n{\r\nu16 dsor = 0;\r\nif (ios->clock) {\r\ndsor = DIV_ROUND_UP(clk_get_rate(host->fclk), ios->clock);\r\nif (dsor > CLKD_MAX)\r\ndsor = CLKD_MAX;\r\n}\r\nreturn dsor;\r\n}\r\nstatic void omap_hsmmc_set_clock(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_ios *ios = &host->mmc->ios;\r\nunsigned long regval;\r\nunsigned long timeout;\r\nunsigned long clkdiv;\r\ndev_vdbg(mmc_dev(host->mmc), "Set clock to %uHz\n", ios->clock);\r\nomap_hsmmc_stop_clock(host);\r\nregval = OMAP_HSMMC_READ(host->base, SYSCTL);\r\nregval = regval & ~(CLKD_MASK | DTO_MASK);\r\nclkdiv = calc_divisor(host, ios);\r\nregval = regval | (clkdiv << 6) | (DTO << 16);\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL, regval);\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL,\r\nOMAP_HSMMC_READ(host->base, SYSCTL) | ICE);\r\ntimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\r\nwhile ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != ICS\r\n&& time_before(jiffies, timeout))\r\ncpu_relax();\r\nif ((mmc_pdata(host)->features & HSMMC_HAS_HSPE_SUPPORT) &&\r\n(ios->timing != MMC_TIMING_MMC_DDR52) &&\r\n(ios->timing != MMC_TIMING_UHS_DDR50) &&\r\n((OMAP_HSMMC_READ(host->base, CAPA) & HSS) == HSS)) {\r\nregval = OMAP_HSMMC_READ(host->base, HCTL);\r\nif (clkdiv && (clk_get_rate(host->fclk)/clkdiv) > 25000000)\r\nregval |= HSPE;\r\nelse\r\nregval &= ~HSPE;\r\nOMAP_HSMMC_WRITE(host->base, HCTL, regval);\r\n}\r\nomap_hsmmc_start_clock(host);\r\n}\r\nstatic void omap_hsmmc_set_bus_width(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_ios *ios = &host->mmc->ios;\r\nu32 con;\r\ncon = OMAP_HSMMC_READ(host->base, CON);\r\nif (ios->timing == MMC_TIMING_MMC_DDR52 ||\r\nios->timing == MMC_TIMING_UHS_DDR50)\r\ncon |= DDR;\r\nelse\r\ncon &= ~DDR;\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_8:\r\nOMAP_HSMMC_WRITE(host->base, CON, con | DW8);\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nOMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | FOUR_BIT);\r\nbreak;\r\ncase MMC_BUS_WIDTH_1:\r\nOMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) & ~FOUR_BIT);\r\nbreak;\r\n}\r\n}\r\nstatic void omap_hsmmc_set_bus_mode(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_ios *ios = &host->mmc->ios;\r\nu32 con;\r\ncon = OMAP_HSMMC_READ(host->base, CON);\r\nif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)\r\nOMAP_HSMMC_WRITE(host->base, CON, con | OD);\r\nelse\r\nOMAP_HSMMC_WRITE(host->base, CON, con & ~OD);\r\n}\r\nstatic int omap_hsmmc_context_restore(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_ios *ios = &host->mmc->ios;\r\nu32 hctl, capa;\r\nunsigned long timeout;\r\nif (host->con == OMAP_HSMMC_READ(host->base, CON) &&\r\nhost->hctl == OMAP_HSMMC_READ(host->base, HCTL) &&\r\nhost->sysctl == OMAP_HSMMC_READ(host->base, SYSCTL) &&\r\nhost->capa == OMAP_HSMMC_READ(host->base, CAPA))\r\nreturn 0;\r\nhost->context_loss++;\r\nif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\r\nif (host->power_mode != MMC_POWER_OFF &&\r\n(1 << ios->vdd) <= MMC_VDD_23_24)\r\nhctl = SDVS18;\r\nelse\r\nhctl = SDVS30;\r\ncapa = VS30 | VS18;\r\n} else {\r\nhctl = SDVS18;\r\ncapa = VS18;\r\n}\r\nif (host->mmc->caps & MMC_CAP_SDIO_IRQ)\r\nhctl |= IWE;\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | hctl);\r\nOMAP_HSMMC_WRITE(host->base, CAPA,\r\nOMAP_HSMMC_READ(host->base, CAPA) | capa);\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | SDBP);\r\ntimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\r\nwhile ((OMAP_HSMMC_READ(host->base, HCTL) & SDBP) != SDBP\r\n&& time_before(jiffies, timeout))\r\n;\r\nOMAP_HSMMC_WRITE(host->base, ISE, 0);\r\nOMAP_HSMMC_WRITE(host->base, IE, 0);\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nif (host->power_mode == MMC_POWER_OFF)\r\ngoto out;\r\nomap_hsmmc_set_bus_width(host);\r\nomap_hsmmc_set_clock(host);\r\nomap_hsmmc_set_bus_mode(host);\r\nout:\r\ndev_dbg(mmc_dev(host->mmc), "context is restored: restore count %d\n",\r\nhost->context_loss);\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_context_save(struct omap_hsmmc_host *host)\r\n{\r\nhost->con = OMAP_HSMMC_READ(host->base, CON);\r\nhost->hctl = OMAP_HSMMC_READ(host->base, HCTL);\r\nhost->sysctl = OMAP_HSMMC_READ(host->base, SYSCTL);\r\nhost->capa = OMAP_HSMMC_READ(host->base, CAPA);\r\n}\r\nstatic int omap_hsmmc_context_restore(struct omap_hsmmc_host *host)\r\n{\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_context_save(struct omap_hsmmc_host *host)\r\n{\r\n}\r\nstatic void send_init_stream(struct omap_hsmmc_host *host)\r\n{\r\nint reg = 0;\r\nunsigned long timeout;\r\nif (host->protect_card)\r\nreturn;\r\ndisable_irq(host->irq);\r\nOMAP_HSMMC_WRITE(host->base, IE, INT_EN_MASK);\r\nOMAP_HSMMC_WRITE(host->base, CON,\r\nOMAP_HSMMC_READ(host->base, CON) | INIT_STREAM);\r\nOMAP_HSMMC_WRITE(host->base, CMD, INIT_STREAM_CMD);\r\ntimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\r\nwhile ((reg != CC_EN) && time_before(jiffies, timeout))\r\nreg = OMAP_HSMMC_READ(host->base, STAT) & CC_EN;\r\nOMAP_HSMMC_WRITE(host->base, CON,\r\nOMAP_HSMMC_READ(host->base, CON) & ~INIT_STREAM);\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nOMAP_HSMMC_READ(host->base, STAT);\r\nenable_irq(host->irq);\r\n}\r\nstatic inline\r\nint omap_hsmmc_cover_is_closed(struct omap_hsmmc_host *host)\r\n{\r\nint r = 1;\r\nif (host->get_cover_state)\r\nr = host->get_cover_state(host->dev);\r\nreturn r;\r\n}\r\nstatic ssize_t\r\nomap_hsmmc_show_cover_switch(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nreturn sprintf(buf, "%s\n",\r\nomap_hsmmc_cover_is_closed(host) ? "closed" : "open");\r\n}\r\nstatic ssize_t\r\nomap_hsmmc_show_slot_name(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nreturn sprintf(buf, "%s\n", mmc_pdata(host)->name);\r\n}\r\nstatic void\r\nomap_hsmmc_start_command(struct omap_hsmmc_host *host, struct mmc_command *cmd,\r\nstruct mmc_data *data)\r\n{\r\nint cmdreg = 0, resptype = 0, cmdtype = 0;\r\ndev_vdbg(mmc_dev(host->mmc), "%s: CMD%d, argument 0x%08x\n",\r\nmmc_hostname(host->mmc), cmd->opcode, cmd->arg);\r\nhost->cmd = cmd;\r\nomap_hsmmc_enable_irq(host, cmd);\r\nhost->response_busy = 0;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136)\r\nresptype = 1;\r\nelse if (cmd->flags & MMC_RSP_BUSY) {\r\nresptype = 3;\r\nhost->response_busy = 1;\r\n} else\r\nresptype = 2;\r\n}\r\nif (cmd == host->mrq->stop)\r\ncmdtype = 0x3;\r\ncmdreg = (cmd->opcode << 24) | (resptype << 16) | (cmdtype << 22);\r\nif ((host->flags & AUTO_CMD23) && mmc_op_multi(cmd->opcode) &&\r\nhost->mrq->sbc) {\r\ncmdreg |= ACEN_ACMD23;\r\nOMAP_HSMMC_WRITE(host->base, SDMASA, host->mrq->sbc->arg);\r\n}\r\nif (data) {\r\ncmdreg |= DP_SELECT | MSBS | BCE;\r\nif (data->flags & MMC_DATA_READ)\r\ncmdreg |= DDIR;\r\nelse\r\ncmdreg &= ~(DDIR);\r\n}\r\nif (host->use_dma)\r\ncmdreg |= DMAE;\r\nhost->req_in_progress = 1;\r\nOMAP_HSMMC_WRITE(host->base, ARG, cmd->arg);\r\nOMAP_HSMMC_WRITE(host->base, CMD, cmdreg);\r\n}\r\nstatic int\r\nomap_hsmmc_get_dma_dir(struct omap_hsmmc_host *host, struct mmc_data *data)\r\n{\r\nif (data->flags & MMC_DATA_WRITE)\r\nreturn DMA_TO_DEVICE;\r\nelse\r\nreturn DMA_FROM_DEVICE;\r\n}\r\nstatic struct dma_chan *omap_hsmmc_get_dma_chan(struct omap_hsmmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nreturn data->flags & MMC_DATA_WRITE ? host->tx_chan : host->rx_chan;\r\n}\r\nstatic void omap_hsmmc_request_done(struct omap_hsmmc_host *host, struct mmc_request *mrq)\r\n{\r\nint dma_ch;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\nhost->req_in_progress = 0;\r\ndma_ch = host->dma_ch;\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\nomap_hsmmc_disable_irq(host);\r\nif (mrq->data && host->use_dma && dma_ch != -1)\r\nreturn;\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic void\r\nomap_hsmmc_xfer_done(struct omap_hsmmc_host *host, struct mmc_data *data)\r\n{\r\nif (!data) {\r\nstruct mmc_request *mrq = host->mrq;\r\nif (host->cmd && host->cmd->opcode == 6 &&\r\nhost->response_busy) {\r\nhost->response_busy = 0;\r\nreturn;\r\n}\r\nomap_hsmmc_request_done(host, mrq);\r\nreturn;\r\n}\r\nhost->data = NULL;\r\nif (!data->error)\r\ndata->bytes_xfered += data->blocks * (data->blksz);\r\nelse\r\ndata->bytes_xfered = 0;\r\nif (data->stop && (data->error || !host->mrq->sbc))\r\nomap_hsmmc_start_command(host, data->stop, NULL);\r\nelse\r\nomap_hsmmc_request_done(host, data->mrq);\r\n}\r\nstatic void\r\nomap_hsmmc_cmd_done(struct omap_hsmmc_host *host, struct mmc_command *cmd)\r\n{\r\nif (host->mrq->sbc && (host->cmd == host->mrq->sbc) &&\r\n!host->mrq->sbc->error && !(host->flags & AUTO_CMD23)) {\r\nhost->cmd = NULL;\r\nomap_hsmmc_start_dma_transfer(host);\r\nomap_hsmmc_start_command(host, host->mrq->cmd,\r\nhost->mrq->data);\r\nreturn;\r\n}\r\nhost->cmd = NULL;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[3] = OMAP_HSMMC_READ(host->base, RSP10);\r\ncmd->resp[2] = OMAP_HSMMC_READ(host->base, RSP32);\r\ncmd->resp[1] = OMAP_HSMMC_READ(host->base, RSP54);\r\ncmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP76);\r\n} else {\r\ncmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP10);\r\n}\r\n}\r\nif ((host->data == NULL && !host->response_busy) || cmd->error)\r\nomap_hsmmc_request_done(host, host->mrq);\r\n}\r\nstatic void omap_hsmmc_dma_cleanup(struct omap_hsmmc_host *host, int errno)\r\n{\r\nint dma_ch;\r\nunsigned long flags;\r\nhost->data->error = errno;\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\ndma_ch = host->dma_ch;\r\nhost->dma_ch = -1;\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\nif (host->use_dma && dma_ch != -1) {\r\nstruct dma_chan *chan = omap_hsmmc_get_dma_chan(host, host->data);\r\ndmaengine_terminate_all(chan);\r\ndma_unmap_sg(chan->device->dev,\r\nhost->data->sg, host->data->sg_len,\r\nomap_hsmmc_get_dma_dir(host, host->data));\r\nhost->data->host_cookie = 0;\r\n}\r\nhost->data = NULL;\r\n}\r\nstatic void omap_hsmmc_dbg_report_irq(struct omap_hsmmc_host *host, u32 status)\r\n{\r\nstatic const char *omap_hsmmc_status_bits[] = {\r\n"CC" , "TC" , "BGE", "---", "BWR" , "BRR" , "---" , "---" ,\r\n"CIRQ", "OBI" , "---", "---", "---" , "---" , "---" , "ERRI",\r\n"CTO" , "CCRC", "CEB", "CIE", "DTO" , "DCRC", "DEB" , "---" ,\r\n"ACE" , "---" , "---", "---", "CERR", "BADA", "---" , "---"\r\n};\r\nchar res[256];\r\nchar *buf = res;\r\nint len, i;\r\nlen = sprintf(buf, "MMC IRQ 0x%x :", status);\r\nbuf += len;\r\nfor (i = 0; i < ARRAY_SIZE(omap_hsmmc_status_bits); i++)\r\nif (status & (1 << i)) {\r\nlen = sprintf(buf, " %s", omap_hsmmc_status_bits[i]);\r\nbuf += len;\r\n}\r\ndev_vdbg(mmc_dev(host->mmc), "%s\n", res);\r\n}\r\nstatic inline void omap_hsmmc_dbg_report_irq(struct omap_hsmmc_host *host,\r\nu32 status)\r\n{\r\n}\r\nstatic inline void omap_hsmmc_reset_controller_fsm(struct omap_hsmmc_host *host,\r\nunsigned long bit)\r\n{\r\nunsigned long i = 0;\r\nunsigned long limit = MMC_TIMEOUT_US;\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL,\r\nOMAP_HSMMC_READ(host->base, SYSCTL) | bit);\r\nif (mmc_pdata(host)->features & HSMMC_HAS_UPDATED_RESET) {\r\nwhile ((!(OMAP_HSMMC_READ(host->base, SYSCTL) & bit))\r\n&& (i++ < limit))\r\nudelay(1);\r\n}\r\ni = 0;\r\nwhile ((OMAP_HSMMC_READ(host->base, SYSCTL) & bit) &&\r\n(i++ < limit))\r\nudelay(1);\r\nif (OMAP_HSMMC_READ(host->base, SYSCTL) & bit)\r\ndev_err(mmc_dev(host->mmc),\r\n"Timeout waiting on controller reset in %s\n",\r\n__func__);\r\n}\r\nstatic void hsmmc_command_incomplete(struct omap_hsmmc_host *host,\r\nint err, int end_cmd)\r\n{\r\nif (end_cmd) {\r\nomap_hsmmc_reset_controller_fsm(host, SRC);\r\nif (host->cmd)\r\nhost->cmd->error = err;\r\n}\r\nif (host->data) {\r\nomap_hsmmc_reset_controller_fsm(host, SRD);\r\nomap_hsmmc_dma_cleanup(host, err);\r\n} else if (host->mrq && host->mrq->cmd)\r\nhost->mrq->cmd->error = err;\r\n}\r\nstatic void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)\r\n{\r\nstruct mmc_data *data;\r\nint end_cmd = 0, end_trans = 0;\r\nint error = 0;\r\ndata = host->data;\r\ndev_vdbg(mmc_dev(host->mmc), "IRQ Status is %x\n", status);\r\nif (status & ERR_EN) {\r\nomap_hsmmc_dbg_report_irq(host, status);\r\nif (status & (CTO_EN | CCRC_EN))\r\nend_cmd = 1;\r\nif (host->data || host->response_busy) {\r\nend_trans = !end_cmd;\r\nhost->response_busy = 0;\r\n}\r\nif (status & (CTO_EN | DTO_EN))\r\nhsmmc_command_incomplete(host, -ETIMEDOUT, end_cmd);\r\nelse if (status & (CCRC_EN | DCRC_EN | DEB_EN | CEB_EN |\r\nBADA_EN))\r\nhsmmc_command_incomplete(host, -EILSEQ, end_cmd);\r\nif (status & ACE_EN) {\r\nu32 ac12;\r\nac12 = OMAP_HSMMC_READ(host->base, AC12);\r\nif (!(ac12 & ACNE) && host->mrq->sbc) {\r\nend_cmd = 1;\r\nif (ac12 & ACTO)\r\nerror = -ETIMEDOUT;\r\nelse if (ac12 & (ACCE | ACEB | ACIE))\r\nerror = -EILSEQ;\r\nhost->mrq->sbc->error = error;\r\nhsmmc_command_incomplete(host, error, end_cmd);\r\n}\r\ndev_dbg(mmc_dev(host->mmc), "AC12 err: 0x%x\n", ac12);\r\n}\r\n}\r\nOMAP_HSMMC_WRITE(host->base, STAT, status);\r\nif (end_cmd || ((status & CC_EN) && host->cmd))\r\nomap_hsmmc_cmd_done(host, host->cmd);\r\nif ((end_trans || (status & TC_EN)) && host->mrq)\r\nomap_hsmmc_xfer_done(host, data);\r\n}\r\nstatic irqreturn_t omap_hsmmc_irq(int irq, void *dev_id)\r\n{\r\nstruct omap_hsmmc_host *host = dev_id;\r\nint status;\r\nstatus = OMAP_HSMMC_READ(host->base, STAT);\r\nwhile (status & (INT_EN_MASK | CIRQ_EN)) {\r\nif (host->req_in_progress)\r\nomap_hsmmc_do_irq(host, status);\r\nif (status & CIRQ_EN)\r\nmmc_signal_sdio_irq(host->mmc);\r\nstatus = OMAP_HSMMC_READ(host->base, STAT);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void set_sd_bus_power(struct omap_hsmmc_host *host)\r\n{\r\nunsigned long i;\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | SDBP);\r\nfor (i = 0; i < loops_per_jiffy; i++) {\r\nif (OMAP_HSMMC_READ(host->base, HCTL) & SDBP)\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nstatic int omap_hsmmc_switch_opcond(struct omap_hsmmc_host *host, int vdd)\r\n{\r\nu32 reg_val = 0;\r\nint ret;\r\nif (host->dbclk)\r\nclk_disable_unprepare(host->dbclk);\r\nret = omap_hsmmc_set_power(host, 0, 0);\r\nif (!ret)\r\nret = omap_hsmmc_set_power(host, 1, vdd);\r\nif (host->dbclk)\r\nclk_prepare_enable(host->dbclk);\r\nif (ret != 0)\r\ngoto err;\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);\r\nreg_val = OMAP_HSMMC_READ(host->base, HCTL);\r\nif ((1 << vdd) <= MMC_VDD_23_24)\r\nreg_val |= SDVS18;\r\nelse\r\nreg_val |= SDVS30;\r\nOMAP_HSMMC_WRITE(host->base, HCTL, reg_val);\r\nset_sd_bus_power(host);\r\nreturn 0;\r\nerr:\r\ndev_err(mmc_dev(host->mmc), "Unable to switch operating voltage\n");\r\nreturn ret;\r\n}\r\nstatic void omap_hsmmc_protect_card(struct omap_hsmmc_host *host)\r\n{\r\nif (!host->get_cover_state)\r\nreturn;\r\nhost->reqs_blocked = 0;\r\nif (host->get_cover_state(host->dev)) {\r\nif (host->protect_card) {\r\ndev_info(host->dev, "%s: cover is closed, "\r\n"card is now accessible\n",\r\nmmc_hostname(host->mmc));\r\nhost->protect_card = 0;\r\n}\r\n} else {\r\nif (!host->protect_card) {\r\ndev_info(host->dev, "%s: cover is open, "\r\n"card is now inaccessible\n",\r\nmmc_hostname(host->mmc));\r\nhost->protect_card = 1;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t omap_hsmmc_cover_irq(int irq, void *dev_id)\r\n{\r\nstruct omap_hsmmc_host *host = dev_id;\r\nsysfs_notify(&host->mmc->class_dev.kobj, NULL, "cover_switch");\r\nomap_hsmmc_protect_card(host);\r\nmmc_detect_change(host->mmc, (HZ * 200) / 1000);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void omap_hsmmc_dma_callback(void *param)\r\n{\r\nstruct omap_hsmmc_host *host = param;\r\nstruct dma_chan *chan;\r\nstruct mmc_data *data;\r\nint req_in_progress;\r\nspin_lock_irq(&host->irq_lock);\r\nif (host->dma_ch < 0) {\r\nspin_unlock_irq(&host->irq_lock);\r\nreturn;\r\n}\r\ndata = host->mrq->data;\r\nchan = omap_hsmmc_get_dma_chan(host, data);\r\nif (!data->host_cookie)\r\ndma_unmap_sg(chan->device->dev,\r\ndata->sg, data->sg_len,\r\nomap_hsmmc_get_dma_dir(host, data));\r\nreq_in_progress = host->req_in_progress;\r\nhost->dma_ch = -1;\r\nspin_unlock_irq(&host->irq_lock);\r\nif (!req_in_progress) {\r\nstruct mmc_request *mrq = host->mrq;\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\n}\r\nstatic int omap_hsmmc_pre_dma_transfer(struct omap_hsmmc_host *host,\r\nstruct mmc_data *data,\r\nstruct omap_hsmmc_next *next,\r\nstruct dma_chan *chan)\r\n{\r\nint dma_len;\r\nif (!next && data->host_cookie &&\r\ndata->host_cookie != host->next_data.cookie) {\r\ndev_warn(host->dev, "[%s] invalid cookie: data->host_cookie %d"\r\n" host->next_data.cookie %d\n",\r\n__func__, data->host_cookie, host->next_data.cookie);\r\ndata->host_cookie = 0;\r\n}\r\nif (next || data->host_cookie != host->next_data.cookie) {\r\ndma_len = dma_map_sg(chan->device->dev, data->sg, data->sg_len,\r\nomap_hsmmc_get_dma_dir(host, data));\r\n} else {\r\ndma_len = host->next_data.dma_len;\r\nhost->next_data.dma_len = 0;\r\n}\r\nif (dma_len == 0)\r\nreturn -EINVAL;\r\nif (next) {\r\nnext->dma_len = dma_len;\r\ndata->host_cookie = ++next->cookie < 0 ? 1 : next->cookie;\r\n} else\r\nhost->dma_len = dma_len;\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_setup_dma_transfer(struct omap_hsmmc_host *host,\r\nstruct mmc_request *req)\r\n{\r\nstruct dma_async_tx_descriptor *tx;\r\nint ret = 0, i;\r\nstruct mmc_data *data = req->data;\r\nstruct dma_chan *chan;\r\nstruct dma_slave_config cfg = {\r\n.src_addr = host->mapbase + OMAP_HSMMC_DATA,\r\n.dst_addr = host->mapbase + OMAP_HSMMC_DATA,\r\n.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\r\n.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\r\n.src_maxburst = data->blksz / 4,\r\n.dst_maxburst = data->blksz / 4,\r\n};\r\nfor (i = 0; i < data->sg_len; i++) {\r\nstruct scatterlist *sgl;\r\nsgl = data->sg + i;\r\nif (sgl->length % data->blksz)\r\nreturn -EINVAL;\r\n}\r\nif ((data->blksz % 4) != 0)\r\nreturn -EINVAL;\r\nBUG_ON(host->dma_ch != -1);\r\nchan = omap_hsmmc_get_dma_chan(host, data);\r\nret = dmaengine_slave_config(chan, &cfg);\r\nif (ret)\r\nreturn ret;\r\nret = omap_hsmmc_pre_dma_transfer(host, data, NULL, chan);\r\nif (ret)\r\nreturn ret;\r\ntx = dmaengine_prep_slave_sg(chan, data->sg, data->sg_len,\r\ndata->flags & MMC_DATA_WRITE ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tx) {\r\ndev_err(mmc_dev(host->mmc), "prep_slave_sg() failed\n");\r\nreturn -1;\r\n}\r\ntx->callback = omap_hsmmc_dma_callback;\r\ntx->callback_param = host;\r\ndmaengine_submit(tx);\r\nhost->dma_ch = 1;\r\nreturn 0;\r\n}\r\nstatic void set_data_timeout(struct omap_hsmmc_host *host,\r\nunsigned int timeout_ns,\r\nunsigned int timeout_clks)\r\n{\r\nunsigned int timeout, cycle_ns;\r\nuint32_t reg, clkd, dto = 0;\r\nreg = OMAP_HSMMC_READ(host->base, SYSCTL);\r\nclkd = (reg & CLKD_MASK) >> CLKD_SHIFT;\r\nif (clkd == 0)\r\nclkd = 1;\r\ncycle_ns = 1000000000 / (host->clk_rate / clkd);\r\ntimeout = timeout_ns / cycle_ns;\r\ntimeout += timeout_clks;\r\nif (timeout) {\r\nwhile ((timeout & 0x80000000) == 0) {\r\ndto += 1;\r\ntimeout <<= 1;\r\n}\r\ndto = 31 - dto;\r\ntimeout <<= 1;\r\nif (timeout && dto)\r\ndto += 1;\r\nif (dto >= 13)\r\ndto -= 13;\r\nelse\r\ndto = 0;\r\nif (dto > 14)\r\ndto = 14;\r\n}\r\nreg &= ~DTO_MASK;\r\nreg |= dto << DTO_SHIFT;\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL, reg);\r\n}\r\nstatic void omap_hsmmc_start_dma_transfer(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_request *req = host->mrq;\r\nstruct dma_chan *chan;\r\nif (!req->data)\r\nreturn;\r\nOMAP_HSMMC_WRITE(host->base, BLK, (req->data->blksz)\r\n| (req->data->blocks << 16));\r\nset_data_timeout(host, req->data->timeout_ns,\r\nreq->data->timeout_clks);\r\nchan = omap_hsmmc_get_dma_chan(host, req->data);\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic int\r\nomap_hsmmc_prepare_data(struct omap_hsmmc_host *host, struct mmc_request *req)\r\n{\r\nint ret;\r\nhost->data = req->data;\r\nif (req->data == NULL) {\r\nOMAP_HSMMC_WRITE(host->base, BLK, 0);\r\nif (req->cmd->flags & MMC_RSP_BUSY)\r\nset_data_timeout(host, 100000000U, 0);\r\nreturn 0;\r\n}\r\nif (host->use_dma) {\r\nret = omap_hsmmc_setup_dma_transfer(host, req);\r\nif (ret != 0) {\r\ndev_err(mmc_dev(host->mmc), "MMC start dma failure\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,\r\nint err)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nstruct mmc_data *data = mrq->data;\r\nif (host->use_dma && data->host_cookie) {\r\nstruct dma_chan *c = omap_hsmmc_get_dma_chan(host, data);\r\ndma_unmap_sg(c->device->dev, data->sg, data->sg_len,\r\nomap_hsmmc_get_dma_dir(host, data));\r\ndata->host_cookie = 0;\r\n}\r\n}\r\nstatic void omap_hsmmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq,\r\nbool is_first_req)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nif (mrq->data->host_cookie) {\r\nmrq->data->host_cookie = 0;\r\nreturn ;\r\n}\r\nif (host->use_dma) {\r\nstruct dma_chan *c = omap_hsmmc_get_dma_chan(host, mrq->data);\r\nif (omap_hsmmc_pre_dma_transfer(host, mrq->data,\r\n&host->next_data, c))\r\nmrq->data->host_cookie = 0;\r\n}\r\n}\r\nstatic void omap_hsmmc_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nint err;\r\nBUG_ON(host->req_in_progress);\r\nBUG_ON(host->dma_ch != -1);\r\nif (host->protect_card) {\r\nif (host->reqs_blocked < 3) {\r\nomap_hsmmc_reset_controller_fsm(host, SRD);\r\nomap_hsmmc_reset_controller_fsm(host, SRC);\r\nhost->reqs_blocked += 1;\r\n}\r\nreq->cmd->error = -EBADF;\r\nif (req->data)\r\nreq->data->error = -EBADF;\r\nreq->cmd->retries = 0;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n} else if (host->reqs_blocked)\r\nhost->reqs_blocked = 0;\r\nWARN_ON(host->mrq != NULL);\r\nhost->mrq = req;\r\nhost->clk_rate = clk_get_rate(host->fclk);\r\nerr = omap_hsmmc_prepare_data(host, req);\r\nif (err) {\r\nreq->cmd->error = err;\r\nif (req->data)\r\nreq->data->error = err;\r\nhost->mrq = NULL;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n}\r\nif (req->sbc && !(host->flags & AUTO_CMD23)) {\r\nomap_hsmmc_start_command(host, req->sbc, NULL);\r\nreturn;\r\n}\r\nomap_hsmmc_start_dma_transfer(host);\r\nomap_hsmmc_start_command(host, req->cmd, req->data);\r\n}\r\nstatic void omap_hsmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nint do_send_init_stream = 0;\r\nif (ios->power_mode != host->power_mode) {\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nomap_hsmmc_set_power(host, 0, 0);\r\nbreak;\r\ncase MMC_POWER_UP:\r\nomap_hsmmc_set_power(host, 1, ios->vdd);\r\nbreak;\r\ncase MMC_POWER_ON:\r\ndo_send_init_stream = 1;\r\nbreak;\r\n}\r\nhost->power_mode = ios->power_mode;\r\n}\r\nomap_hsmmc_set_bus_width(host);\r\nif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\r\nif ((OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET) &&\r\n(ios->vdd == DUAL_VOLT_OCR_BIT)) {\r\nif (omap_hsmmc_switch_opcond(host, ios->vdd) != 0)\r\ndev_dbg(mmc_dev(host->mmc),\r\n"Switch operation failed\n");\r\n}\r\n}\r\nomap_hsmmc_set_clock(host);\r\nif (do_send_init_stream)\r\nsend_init_stream(host);\r\nomap_hsmmc_set_bus_mode(host);\r\n}\r\nstatic int omap_hsmmc_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nif (!host->card_detect)\r\nreturn -ENOSYS;\r\nreturn host->card_detect(host->dev);\r\n}\r\nstatic void omap_hsmmc_init_card(struct mmc_host *mmc, struct mmc_card *card)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nif (mmc_pdata(host)->init_card)\r\nmmc_pdata(host)->init_card(card);\r\n}\r\nstatic void omap_hsmmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nu32 irq_mask, con;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\ncon = OMAP_HSMMC_READ(host->base, CON);\r\nirq_mask = OMAP_HSMMC_READ(host->base, ISE);\r\nif (enable) {\r\nhost->flags |= HSMMC_SDIO_IRQ_ENABLED;\r\nirq_mask |= CIRQ_EN;\r\ncon |= CTPL | CLKEXTFREE;\r\n} else {\r\nhost->flags &= ~HSMMC_SDIO_IRQ_ENABLED;\r\nirq_mask &= ~CIRQ_EN;\r\ncon &= ~(CTPL | CLKEXTFREE);\r\n}\r\nOMAP_HSMMC_WRITE(host->base, CON, con);\r\nOMAP_HSMMC_WRITE(host->base, IE, irq_mask);\r\nif (!host->req_in_progress || !enable)\r\nOMAP_HSMMC_WRITE(host->base, ISE, irq_mask);\r\nOMAP_HSMMC_READ(host->base, IE);\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\n}\r\nstatic int omap_hsmmc_configure_wake_irq(struct omap_hsmmc_host *host)\r\n{\r\nint ret;\r\nif (!host->dev->of_node || !host->wake_irq)\r\nreturn -ENODEV;\r\nret = dev_pm_set_dedicated_wake_irq(host->dev, host->wake_irq);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc), "Unable to request wake IRQ\n");\r\ngoto err;\r\n}\r\nif (host->pdata->controller_flags & OMAP_HSMMC_SWAKEUP_MISSING) {\r\nstruct pinctrl *p = devm_pinctrl_get(host->dev);\r\nif (!p) {\r\nret = -ENODEV;\r\ngoto err_free_irq;\r\n}\r\nif (IS_ERR(pinctrl_lookup_state(p, PINCTRL_STATE_DEFAULT))) {\r\ndev_info(host->dev, "missing default pinctrl state\n");\r\ndevm_pinctrl_put(p);\r\nret = -EINVAL;\r\ngoto err_free_irq;\r\n}\r\nif (IS_ERR(pinctrl_lookup_state(p, PINCTRL_STATE_IDLE))) {\r\ndev_info(host->dev, "missing idle pinctrl state\n");\r\ndevm_pinctrl_put(p);\r\nret = -EINVAL;\r\ngoto err_free_irq;\r\n}\r\ndevm_pinctrl_put(p);\r\n}\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | IWE);\r\nreturn 0;\r\nerr_free_irq:\r\ndev_pm_clear_wake_irq(host->dev);\r\nerr:\r\ndev_warn(host->dev, "no SDIO IRQ support, falling back to polling\n");\r\nhost->wake_irq = 0;\r\nreturn ret;\r\n}\r\nstatic void omap_hsmmc_conf_bus_power(struct omap_hsmmc_host *host)\r\n{\r\nu32 hctl, capa, value;\r\nif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\r\nhctl = SDVS30;\r\ncapa = VS30 | VS18;\r\n} else {\r\nhctl = SDVS18;\r\ncapa = VS18;\r\n}\r\nvalue = OMAP_HSMMC_READ(host->base, HCTL) & ~SDVS_MASK;\r\nOMAP_HSMMC_WRITE(host->base, HCTL, value | hctl);\r\nvalue = OMAP_HSMMC_READ(host->base, CAPA);\r\nOMAP_HSMMC_WRITE(host->base, CAPA, value | capa);\r\nset_sd_bus_power(host);\r\n}\r\nstatic int omap_hsmmc_multi_io_quirk(struct mmc_card *card,\r\nunsigned int direction, int blk_size)\r\n{\r\nif (direction == MMC_DATA_READ)\r\nreturn 1;\r\nreturn blk_size;\r\n}\r\nstatic int omap_hsmmc_regs_show(struct seq_file *s, void *data)\r\n{\r\nstruct mmc_host *mmc = s->private;\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nseq_printf(s, "mmc%d:\n", mmc->index);\r\nseq_printf(s, "sdio irq mode\t%s\n",\r\n(mmc->caps & MMC_CAP_SDIO_IRQ) ? "interrupt" : "polling");\r\nif (mmc->caps & MMC_CAP_SDIO_IRQ) {\r\nseq_printf(s, "sdio irq \t%s\n",\r\n(host->flags & HSMMC_SDIO_IRQ_ENABLED) ? "enabled"\r\n: "disabled");\r\n}\r\nseq_printf(s, "ctx_loss:\t%d\n", host->context_loss);\r\npm_runtime_get_sync(host->dev);\r\nseq_puts(s, "\nregs:\n");\r\nseq_printf(s, "CON:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, CON));\r\nseq_printf(s, "PSTATE:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, PSTATE));\r\nseq_printf(s, "HCTL:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, HCTL));\r\nseq_printf(s, "SYSCTL:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, SYSCTL));\r\nseq_printf(s, "IE:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, IE));\r\nseq_printf(s, "ISE:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, ISE));\r\nseq_printf(s, "CAPA:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, CAPA));\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, omap_hsmmc_regs_show, inode->i_private);\r\n}\r\nstatic void omap_hsmmc_debugfs(struct mmc_host *mmc)\r\n{\r\nif (mmc->debugfs_root)\r\ndebugfs_create_file("regs", S_IRUSR, mmc->debugfs_root,\r\nmmc, &mmc_regs_fops);\r\n}\r\nstatic void omap_hsmmc_debugfs(struct mmc_host *mmc)\r\n{\r\n}\r\nstatic struct omap_hsmmc_platform_data *of_get_hsmmc_pdata(struct device *dev)\r\n{\r\nstruct omap_hsmmc_platform_data *pdata, *legacy;\r\nstruct device_node *np = dev->of_node;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nlegacy = dev_get_platdata(dev);\r\nif (legacy && legacy->name)\r\npdata->name = legacy->name;\r\nif (of_find_property(np, "ti,dual-volt", NULL))\r\npdata->controller_flags |= OMAP_HSMMC_SUPPORTS_DUAL_VOLT;\r\npdata->gpio_cd = -EINVAL;\r\npdata->gpio_cod = -EINVAL;\r\npdata->gpio_wp = -EINVAL;\r\nif (of_find_property(np, "ti,non-removable", NULL)) {\r\npdata->nonremovable = true;\r\npdata->no_regulator_off_init = true;\r\n}\r\nif (of_find_property(np, "ti,needs-special-reset", NULL))\r\npdata->features |= HSMMC_HAS_UPDATED_RESET;\r\nif (of_find_property(np, "ti,needs-special-hs-handling", NULL))\r\npdata->features |= HSMMC_HAS_HSPE_SUPPORT;\r\nreturn pdata;\r\n}\r\nstatic inline struct omap_hsmmc_platform_data\r\n*of_get_hsmmc_pdata(struct device *dev)\r\n{\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int omap_hsmmc_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_hsmmc_platform_data *pdata = pdev->dev.platform_data;\r\nstruct mmc_host *mmc;\r\nstruct omap_hsmmc_host *host = NULL;\r\nstruct resource *res;\r\nint ret, irq;\r\nconst struct of_device_id *match;\r\nconst struct omap_mmc_of_data *data;\r\nvoid __iomem *base;\r\nmatch = of_match_device(of_match_ptr(omap_mmc_of_match), &pdev->dev);\r\nif (match) {\r\npdata = of_get_hsmmc_pdata(&pdev->dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nif (match->data) {\r\ndata = match->data;\r\npdata->reg_offset = data->reg_offset;\r\npdata->controller_flags |= data->controller_flags;\r\n}\r\n}\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "Platform Data is missing\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (res == NULL || irq < 0)\r\nreturn -ENXIO;\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nmmc = mmc_alloc_host(sizeof(struct omap_hsmmc_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = mmc_of_parse(mmc);\r\nif (ret)\r\ngoto err1;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->pdata = pdata;\r\nhost->dev = &pdev->dev;\r\nhost->use_dma = 1;\r\nhost->dma_ch = -1;\r\nhost->irq = irq;\r\nhost->mapbase = res->start + pdata->reg_offset;\r\nhost->base = base + pdata->reg_offset;\r\nhost->power_mode = MMC_POWER_OFF;\r\nhost->next_data.cookie = 1;\r\nhost->pbias_enabled = 0;\r\nhost->vqmmc_enabled = 0;\r\nret = omap_hsmmc_gpio_init(mmc, host, pdata);\r\nif (ret)\r\ngoto err_gpio;\r\nplatform_set_drvdata(pdev, host);\r\nif (pdev->dev.of_node)\r\nhost->wake_irq = irq_of_parse_and_map(pdev->dev.of_node, 1);\r\nmmc->ops = &omap_hsmmc_ops;\r\nmmc->f_min = OMAP_MMC_MIN_CLOCK;\r\nif (pdata->max_freq > 0)\r\nmmc->f_max = pdata->max_freq;\r\nelse if (mmc->f_max == 0)\r\nmmc->f_max = OMAP_MMC_MAX_CLOCK;\r\nspin_lock_init(&host->irq_lock);\r\nhost->fclk = devm_clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(host->fclk)) {\r\nret = PTR_ERR(host->fclk);\r\nhost->fclk = NULL;\r\ngoto err1;\r\n}\r\nif (host->pdata->controller_flags & OMAP_HSMMC_BROKEN_MULTIBLOCK_READ) {\r\ndev_info(&pdev->dev, "multiblock reads disabled due to 35xx erratum 2.1.1.128; MMC read performance may suffer\n");\r\nomap_hsmmc_ops.multi_io_quirk = omap_hsmmc_multi_io_quirk;\r\n}\r\ndevice_init_wakeup(&pdev->dev, true);\r\npm_runtime_enable(host->dev);\r\npm_runtime_get_sync(host->dev);\r\npm_runtime_set_autosuspend_delay(host->dev, MMC_AUTOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(host->dev);\r\nomap_hsmmc_context_save(host);\r\nhost->dbclk = devm_clk_get(&pdev->dev, "mmchsdb_fck");\r\nif (IS_ERR(host->dbclk)) {\r\nhost->dbclk = NULL;\r\n} else if (clk_prepare_enable(host->dbclk) != 0) {\r\ndev_warn(mmc_dev(host->mmc), "Failed to enable debounce clk\n");\r\nhost->dbclk = NULL;\r\n}\r\nmmc->max_segs = 1024;\r\nmmc->max_blk_size = 512;\r\nmmc->max_blk_count = 0xFFFF;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nmmc->caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |\r\nMMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_ERASE;\r\nmmc->caps |= mmc_pdata(host)->caps;\r\nif (mmc->caps & MMC_CAP_8_BIT_DATA)\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nif (mmc_pdata(host)->nonremovable)\r\nmmc->caps |= MMC_CAP_NONREMOVABLE;\r\nmmc->pm_caps |= mmc_pdata(host)->pm_caps;\r\nomap_hsmmc_conf_bus_power(host);\r\nhost->rx_chan = dma_request_chan(&pdev->dev, "rx");\r\nif (IS_ERR(host->rx_chan)) {\r\ndev_err(mmc_dev(host->mmc), "RX DMA channel request failed\n");\r\nret = PTR_ERR(host->rx_chan);\r\ngoto err_irq;\r\n}\r\nhost->tx_chan = dma_request_chan(&pdev->dev, "tx");\r\nif (IS_ERR(host->tx_chan)) {\r\ndev_err(mmc_dev(host->mmc), "TX DMA channel request failed\n");\r\nret = PTR_ERR(host->tx_chan);\r\ngoto err_irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, host->irq, omap_hsmmc_irq, 0,\r\nmmc_hostname(mmc), host);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc), "Unable to grab HSMMC IRQ\n");\r\ngoto err_irq;\r\n}\r\nret = omap_hsmmc_reg_get(host);\r\nif (ret)\r\ngoto err_irq;\r\nmmc->ocr_avail = mmc_pdata(host)->ocr_mask;\r\nomap_hsmmc_disable_irq(host);\r\nret = omap_hsmmc_configure_wake_irq(host);\r\nif (!ret)\r\nmmc->caps |= MMC_CAP_SDIO_IRQ;\r\nomap_hsmmc_protect_card(host);\r\nmmc_add_host(mmc);\r\nif (mmc_pdata(host)->name != NULL) {\r\nret = device_create_file(&mmc->class_dev, &dev_attr_slot_name);\r\nif (ret < 0)\r\ngoto err_slot_name;\r\n}\r\nif (host->get_cover_state) {\r\nret = device_create_file(&mmc->class_dev,\r\n&dev_attr_cover_switch);\r\nif (ret < 0)\r\ngoto err_slot_name;\r\n}\r\nomap_hsmmc_debugfs(mmc);\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\nreturn 0;\r\nerr_slot_name:\r\nmmc_remove_host(mmc);\r\nerr_irq:\r\ndevice_init_wakeup(&pdev->dev, false);\r\nif (!IS_ERR_OR_NULL(host->tx_chan))\r\ndma_release_channel(host->tx_chan);\r\nif (!IS_ERR_OR_NULL(host->rx_chan))\r\ndma_release_channel(host->rx_chan);\r\npm_runtime_dont_use_autosuspend(host->dev);\r\npm_runtime_put_sync(host->dev);\r\npm_runtime_disable(host->dev);\r\nif (host->dbclk)\r\nclk_disable_unprepare(host->dbclk);\r\nerr1:\r\nerr_gpio:\r\nmmc_free_host(mmc);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_hsmmc_host *host = platform_get_drvdata(pdev);\r\npm_runtime_get_sync(host->dev);\r\nmmc_remove_host(host->mmc);\r\ndma_release_channel(host->tx_chan);\r\ndma_release_channel(host->rx_chan);\r\npm_runtime_dont_use_autosuspend(host->dev);\r\npm_runtime_put_sync(host->dev);\r\npm_runtime_disable(host->dev);\r\ndevice_init_wakeup(&pdev->dev, false);\r\nif (host->dbclk)\r\nclk_disable_unprepare(host->dbclk);\r\nmmc_free_host(host->mmc);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_suspend(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nif (!host)\r\nreturn 0;\r\npm_runtime_get_sync(host->dev);\r\nif (!(host->mmc->pm_flags & MMC_PM_KEEP_POWER)) {\r\nOMAP_HSMMC_WRITE(host->base, ISE, 0);\r\nOMAP_HSMMC_WRITE(host->base, IE, 0);\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) & ~SDBP);\r\n}\r\nif (host->dbclk)\r\nclk_disable_unprepare(host->dbclk);\r\npm_runtime_put_sync(host->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_resume(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nif (!host)\r\nreturn 0;\r\npm_runtime_get_sync(host->dev);\r\nif (host->dbclk)\r\nclk_prepare_enable(host->dbclk);\r\nif (!(host->mmc->pm_flags & MMC_PM_KEEP_POWER))\r\nomap_hsmmc_conf_bus_power(host);\r\nomap_hsmmc_protect_card(host);\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_runtime_suspend(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host;\r\nunsigned long flags;\r\nint ret = 0;\r\nhost = platform_get_drvdata(to_platform_device(dev));\r\nomap_hsmmc_context_save(host);\r\ndev_dbg(dev, "disabled\n");\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\nif ((host->mmc->caps & MMC_CAP_SDIO_IRQ) &&\r\n(host->flags & HSMMC_SDIO_IRQ_ENABLED)) {\r\nOMAP_HSMMC_WRITE(host->base, ISE, 0);\r\nOMAP_HSMMC_WRITE(host->base, IE, 0);\r\nif (!(OMAP_HSMMC_READ(host->base, PSTATE) & DLEV_DAT(1))) {\r\ndev_dbg(dev, "pending sdio irq, abort suspend\n");\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nOMAP_HSMMC_WRITE(host->base, ISE, CIRQ_EN);\r\nOMAP_HSMMC_WRITE(host->base, IE, CIRQ_EN);\r\npm_runtime_mark_last_busy(dev);\r\nret = -EBUSY;\r\ngoto abort;\r\n}\r\npinctrl_pm_select_idle_state(dev);\r\n} else {\r\npinctrl_pm_select_idle_state(dev);\r\n}\r\nabort:\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_runtime_resume(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host;\r\nunsigned long flags;\r\nhost = platform_get_drvdata(to_platform_device(dev));\r\nomap_hsmmc_context_restore(host);\r\ndev_dbg(dev, "enabled\n");\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\nif ((host->mmc->caps & MMC_CAP_SDIO_IRQ) &&\r\n(host->flags & HSMMC_SDIO_IRQ_ENABLED)) {\r\npinctrl_pm_select_default_state(host->dev);\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nOMAP_HSMMC_WRITE(host->base, ISE, CIRQ_EN);\r\nOMAP_HSMMC_WRITE(host->base, IE, CIRQ_EN);\r\n} else {\r\npinctrl_pm_select_default_state(host->dev);\r\n}\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\nreturn 0;\r\n}
