static void gbe_reset(void)\r\n{\r\ngbe->ctrlstat = 0x300aa000;\r\n}\r\nstatic void gbe_turn_off(void)\r\n{\r\nint i;\r\nunsigned int val, x, y, vpixen_off;\r\ngbe_turned_on = 0;\r\nval = gbe->vt_xy;\r\nif (GET_GBE_FIELD(VT_XY, FREEZE, val) == 1)\r\nreturn;\r\nval = gbe->ovr_control;\r\nSET_GBE_FIELD(OVR_CONTROL, OVR_DMA_ENABLE, val, 0);\r\ngbe->ovr_control = val;\r\nudelay(1000);\r\nval = gbe->frm_control;\r\nSET_GBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, val, 0);\r\ngbe->frm_control = val;\r\nudelay(1000);\r\nval = gbe->did_control;\r\nSET_GBE_FIELD(DID_CONTROL, DID_DMA_ENABLE, val, 0);\r\ngbe->did_control = val;\r\nudelay(1000);\r\nfor (i = 0; i < 10000; i++) {\r\nval = gbe->frm_inhwctrl;\r\nif (GET_GBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, val)) {\r\nudelay(10);\r\n} else {\r\nval = gbe->ovr_inhwctrl;\r\nif (GET_GBE_FIELD(OVR_INHWCTRL, OVR_DMA_ENABLE, val)) {\r\nudelay(10);\r\n} else {\r\nval = gbe->did_inhwctrl;\r\nif (GET_GBE_FIELD(DID_INHWCTRL, DID_DMA_ENABLE, val)) {\r\nudelay(10);\r\n} else\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i == 10000)\r\nprintk(KERN_ERR "gbefb: turn off DMA timed out\n");\r\nval = gbe->vt_vpixen;\r\nvpixen_off = GET_GBE_FIELD(VT_VPIXEN, VPIXEN_OFF, val);\r\nfor (i = 0; i < 100000; i++) {\r\nval = gbe->vt_xy;\r\nx = GET_GBE_FIELD(VT_XY, X, val);\r\ny = GET_GBE_FIELD(VT_XY, Y, val);\r\nif (y < vpixen_off)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == 100000)\r\nprintk(KERN_ERR\r\n"gbefb: wait for vpixen_off timed out\n");\r\nfor (i = 0; i < 10000; i++) {\r\nval = gbe->vt_xy;\r\nx = GET_GBE_FIELD(VT_XY, X, val);\r\ny = GET_GBE_FIELD(VT_XY, Y, val);\r\nif (y > vpixen_off)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == 10000)\r\nprintk(KERN_ERR "gbefb: wait for vpixen_off timed out\n");\r\nval = 0;\r\nSET_GBE_FIELD(VT_XY, FREEZE, val, 1);\r\ngbe->vt_xy = val;\r\nudelay(10000);\r\nfor (i = 0; i < 10000; i++) {\r\nval = gbe->vt_xy;\r\nif (GET_GBE_FIELD(VT_XY, FREEZE, val) != 1)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nif (i == 10000)\r\nprintk(KERN_ERR "gbefb: turn off pixel clock timed out\n");\r\nval = gbe->dotclock;\r\nSET_GBE_FIELD(DOTCLK, RUN, val, 0);\r\ngbe->dotclock = val;\r\nudelay(10000);\r\nfor (i = 0; i < 10000; i++) {\r\nval = gbe->dotclock;\r\nif (GET_GBE_FIELD(DOTCLK, RUN, val))\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nif (i == 10000)\r\nprintk(KERN_ERR "gbefb: turn off dotclock timed out\n");\r\nval = gbe->frm_size_tile;\r\nSET_GBE_FIELD(FRM_SIZE_TILE, FRM_FIFO_RESET, val, 1);\r\ngbe->frm_size_tile = val;\r\nSET_GBE_FIELD(FRM_SIZE_TILE, FRM_FIFO_RESET, val, 0);\r\ngbe->frm_size_tile = val;\r\n}\r\nstatic void gbe_turn_on(void)\r\n{\r\nunsigned int val, i;\r\nif (gbe_revision < 2) {\r\nval = gbe->vt_xy;\r\nif (GET_GBE_FIELD(VT_XY, FREEZE, val) == 0)\r\nreturn;\r\n}\r\nval = gbe->dotclock;\r\nSET_GBE_FIELD(DOTCLK, RUN, val, 1);\r\ngbe->dotclock = val;\r\nudelay(10000);\r\nfor (i = 0; i < 10000; i++) {\r\nval = gbe->dotclock;\r\nif (GET_GBE_FIELD(DOTCLK, RUN, val) != 1)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nif (i == 10000)\r\nprintk(KERN_ERR "gbefb: turn on dotclock timed out\n");\r\nval = 0;\r\nSET_GBE_FIELD(VT_XY, FREEZE, val, 0);\r\ngbe->vt_xy = val;\r\nudelay(10000);\r\nfor (i = 0; i < 10000; i++) {\r\nval = gbe->vt_xy;\r\nif (GET_GBE_FIELD(VT_XY, FREEZE, val))\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nif (i == 10000)\r\nprintk(KERN_ERR "gbefb: turn on pixel clock timed out\n");\r\nval = gbe->frm_control;\r\nSET_GBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, val, 1);\r\ngbe->frm_control = val;\r\nudelay(1000);\r\nfor (i = 0; i < 10000; i++) {\r\nval = gbe->frm_inhwctrl;\r\nif (GET_GBE_FIELD(FRM_INHWCTRL, FRM_DMA_ENABLE, val) != 1)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nif (i == 10000)\r\nprintk(KERN_ERR "gbefb: turn on DMA timed out\n");\r\ngbe_turned_on = 1;\r\n}\r\nstatic void gbe_loadcmap(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < 256; i++) {\r\nfor (j = 0; j < 1000 && gbe->cm_fifo >= 63; j++)\r\nudelay(10);\r\nif (j == 1000)\r\nprintk(KERN_ERR "gbefb: cmap FIFO timeout\n");\r\ngbe->cmap[i] = gbe_cmap[i];\r\n}\r\n}\r\nstatic int gbefb_blank(int blank, struct fb_info *info)\r\n{\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ngbe_turn_on();\r\ngbe_loadcmap();\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ngbe_turn_off();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gbefb_setup_flatpanel(struct gbe_timing_info *timing)\r\n{\r\nint fp_wid, fp_hgt, fp_vbs, fp_vbe;\r\nu32 outputVal = 0;\r\nSET_GBE_FIELD(VT_FLAGS, HDRV_INVERT, outputVal,\r\n(timing->flags & FB_SYNC_HOR_HIGH_ACT) ? 0 : 1);\r\nSET_GBE_FIELD(VT_FLAGS, VDRV_INVERT, outputVal,\r\n(timing->flags & FB_SYNC_VERT_HIGH_ACT) ? 0 : 1);\r\ngbe->vt_flags = outputVal;\r\nfp_wid = 1600;\r\nfp_hgt = 1024;\r\nfp_vbs = 0;\r\nfp_vbe = 1600;\r\ntiming->pll_m = 4;\r\ntiming->pll_n = 1;\r\ntiming->pll_p = 0;\r\noutputVal = 0;\r\nSET_GBE_FIELD(FP_DE, ON, outputVal, fp_vbs);\r\nSET_GBE_FIELD(FP_DE, OFF, outputVal, fp_vbe);\r\ngbe->fp_de = outputVal;\r\noutputVal = 0;\r\nSET_GBE_FIELD(FP_HDRV, OFF, outputVal, fp_wid);\r\ngbe->fp_hdrv = outputVal;\r\noutputVal = 0;\r\nSET_GBE_FIELD(FP_VDRV, ON, outputVal, 1);\r\nSET_GBE_FIELD(FP_VDRV, OFF, outputVal, fp_hgt + 1);\r\ngbe->fp_vdrv = outputVal;\r\n}\r\nstatic int compute_gbe_timing(struct fb_var_screeninfo *var,\r\nstruct gbe_timing_info *timing)\r\n{\r\nint pll_m, pll_n, pll_p, error, best_m, best_n, best_p, best_error;\r\nint pixclock;\r\nstruct gbe_pll_info *gbe_pll;\r\nif (gbe_revision < 2)\r\ngbe_pll = &gbe_pll_table[0];\r\nelse\r\ngbe_pll = &gbe_pll_table[1];\r\nbest_error = 1000000000;\r\nbest_n = best_m = best_p = 0;\r\nfor (pll_p = 0; pll_p < 4; pll_p++)\r\nfor (pll_m = 1; pll_m < 256; pll_m++)\r\nfor (pll_n = 1; pll_n < 64; pll_n++) {\r\npixclock = (1000000 / gbe_pll->clock_rate) *\r\n(pll_n << pll_p) / pll_m;\r\nerror = var->pixclock - pixclock;\r\nif (error < 0)\r\nerror = -error;\r\nif (error < best_error &&\r\npll_m / pll_n >\r\ngbe_pll->fvco_min / gbe_pll->clock_rate &&\r\npll_m / pll_n <\r\ngbe_pll->fvco_max / gbe_pll->clock_rate) {\r\nbest_error = error;\r\nbest_m = pll_m;\r\nbest_n = pll_n;\r\nbest_p = pll_p;\r\n}\r\n}\r\nif (!best_n || !best_m)\r\nreturn -EINVAL;\r\npixclock = (1000000 / gbe_pll->clock_rate) *\r\n(best_n << best_p) / best_m;\r\nif (timing) {\r\ntiming->width = var->xres;\r\ntiming->height = var->yres;\r\ntiming->pll_m = best_m;\r\ntiming->pll_n = best_n;\r\ntiming->pll_p = best_p;\r\ntiming->cfreq = gbe_pll->clock_rate * 1000 * timing->pll_m /\r\n(timing->pll_n << timing->pll_p);\r\ntiming->htotal = var->left_margin + var->xres +\r\nvar->right_margin + var->hsync_len;\r\ntiming->vtotal = var->upper_margin + var->yres +\r\nvar->lower_margin + var->vsync_len;\r\ntiming->fields_sec = 1000 * timing->cfreq / timing->htotal *\r\n1000 / timing->vtotal;\r\ntiming->hblank_start = var->xres;\r\ntiming->vblank_start = var->yres;\r\ntiming->hblank_end = timing->htotal;\r\ntiming->hsync_start = var->xres + var->right_margin + 1;\r\ntiming->hsync_end = timing->hsync_start + var->hsync_len;\r\ntiming->vblank_end = timing->vtotal;\r\ntiming->vsync_start = var->yres + var->lower_margin + 1;\r\ntiming->vsync_end = timing->vsync_start + var->vsync_len;\r\n}\r\nreturn pixclock;\r\n}\r\nstatic void gbe_set_timing_info(struct gbe_timing_info *timing)\r\n{\r\nint temp;\r\nunsigned int val;\r\nval = 0;\r\nSET_GBE_FIELD(DOTCLK, M, val, timing->pll_m - 1);\r\nSET_GBE_FIELD(DOTCLK, N, val, timing->pll_n - 1);\r\nSET_GBE_FIELD(DOTCLK, P, val, timing->pll_p);\r\nSET_GBE_FIELD(DOTCLK, RUN, val, 0);\r\ngbe->dotclock = val;\r\nudelay(10000);\r\nval = 0;\r\nSET_GBE_FIELD(VT_XYMAX, MAXX, val, timing->htotal);\r\nSET_GBE_FIELD(VT_XYMAX, MAXY, val, timing->vtotal);\r\ngbe->vt_xymax = val;\r\nval = 0;\r\nSET_GBE_FIELD(VT_VSYNC, VSYNC_ON, val, timing->vsync_start);\r\nSET_GBE_FIELD(VT_VSYNC, VSYNC_OFF, val, timing->vsync_end);\r\ngbe->vt_vsync = val;\r\nval = 0;\r\nSET_GBE_FIELD(VT_HSYNC, HSYNC_ON, val, timing->hsync_start);\r\nSET_GBE_FIELD(VT_HSYNC, HSYNC_OFF, val, timing->hsync_end);\r\ngbe->vt_hsync = val;\r\nval = 0;\r\nSET_GBE_FIELD(VT_VBLANK, VBLANK_ON, val, timing->vblank_start);\r\nSET_GBE_FIELD(VT_VBLANK, VBLANK_OFF, val, timing->vblank_end);\r\ngbe->vt_vblank = val;\r\nval = 0;\r\nSET_GBE_FIELD(VT_HBLANK, HBLANK_ON, val,\r\ntiming->hblank_start - 5);\r\nSET_GBE_FIELD(VT_HBLANK, HBLANK_OFF, val,\r\ntiming->hblank_end - 3);\r\ngbe->vt_hblank = val;\r\nval = 0;\r\nSET_GBE_FIELD(VT_VCMAP, VCMAP_ON, val, timing->vblank_start);\r\nSET_GBE_FIELD(VT_VCMAP, VCMAP_OFF, val, timing->vblank_end);\r\ngbe->vt_vcmap = val;\r\nval = 0;\r\nSET_GBE_FIELD(VT_HCMAP, HCMAP_ON, val, timing->hblank_start);\r\nSET_GBE_FIELD(VT_HCMAP, HCMAP_OFF, val, timing->hblank_end);\r\ngbe->vt_hcmap = val;\r\nval = 0;\r\ntemp = timing->vblank_start - timing->vblank_end - 1;\r\nif (temp > 0)\r\ntemp = -temp;\r\nif (flat_panel_enabled)\r\ngbefb_setup_flatpanel(timing);\r\nSET_GBE_FIELD(DID_START_XY, DID_STARTY, val, (u32) temp);\r\nif (timing->hblank_end >= 20)\r\nSET_GBE_FIELD(DID_START_XY, DID_STARTX, val,\r\ntiming->hblank_end - 20);\r\nelse\r\nSET_GBE_FIELD(DID_START_XY, DID_STARTX, val,\r\ntiming->htotal - (20 - timing->hblank_end));\r\ngbe->did_start_xy = val;\r\nval = 0;\r\nSET_GBE_FIELD(CRS_START_XY, CRS_STARTY, val, (u32) (temp + 1));\r\nif (timing->hblank_end >= GBE_CRS_MAGIC)\r\nSET_GBE_FIELD(CRS_START_XY, CRS_STARTX, val,\r\ntiming->hblank_end - GBE_CRS_MAGIC);\r\nelse\r\nSET_GBE_FIELD(CRS_START_XY, CRS_STARTX, val,\r\ntiming->htotal - (GBE_CRS_MAGIC -\r\ntiming->hblank_end));\r\ngbe->crs_start_xy = val;\r\nval = 0;\r\nSET_GBE_FIELD(VC_START_XY, VC_STARTY, val, (u32) temp);\r\nSET_GBE_FIELD(VC_START_XY, VC_STARTX, val, timing->hblank_end - 4);\r\ngbe->vc_start_xy = val;\r\nval = 0;\r\ntemp = timing->hblank_end - GBE_PIXEN_MAGIC_ON;\r\nif (temp < 0)\r\ntemp += timing->htotal;\r\nSET_GBE_FIELD(VT_HPIXEN, HPIXEN_ON, val, temp);\r\nSET_GBE_FIELD(VT_HPIXEN, HPIXEN_OFF, val,\r\n((temp + timing->width -\r\nGBE_PIXEN_MAGIC_OFF) % timing->htotal));\r\ngbe->vt_hpixen = val;\r\nval = 0;\r\nSET_GBE_FIELD(VT_VPIXEN, VPIXEN_ON, val, timing->vblank_end);\r\nSET_GBE_FIELD(VT_VPIXEN, VPIXEN_OFF, val, timing->vblank_start);\r\ngbe->vt_vpixen = val;\r\nval = 0;\r\nSET_GBE_FIELD(VT_FLAGS, SYNC_LOW, val, 1);\r\ngbe->vt_flags = val;\r\n}\r\nstatic int gbefb_set_par(struct fb_info *info)\r\n{\r\nint i;\r\nunsigned int val;\r\nint wholeTilesX, partTilesX, maxPixelsPerTileX;\r\nint height_pix;\r\nint xpmax, ypmax;\r\nint bytesPerPixel;\r\nstruct gbefb_par *par = (struct gbefb_par *) info->par;\r\ncompute_gbe_timing(&info->var, &par->timing);\r\nbytesPerPixel = info->var.bits_per_pixel / 8;\r\ninfo->fix.line_length = info->var.xres_virtual * bytesPerPixel;\r\nxpmax = par->timing.width;\r\nypmax = par->timing.height;\r\ngbe_turn_off();\r\ngbe_set_timing_info(&par->timing);\r\nval = 0;\r\nswitch (bytesPerPixel) {\r\ncase 1:\r\nSET_GBE_FIELD(WID, TYP, val, GBE_CMODE_I8);\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ncase 2:\r\nSET_GBE_FIELD(WID, TYP, val, GBE_CMODE_ARGB5);\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 4:\r\nSET_GBE_FIELD(WID, TYP, val, GBE_CMODE_RGB8);\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\n}\r\nSET_GBE_FIELD(WID, BUF, val, GBE_BMODE_BOTH);\r\nfor (i = 0; i < 32; i++)\r\ngbe->mode_regs[i] = val;\r\ngbe->vt_intr01 = 0xffffffff;\r\ngbe->vt_intr23 = 0xffffffff;\r\nval = 0;\r\nSET_GBE_FIELD(FRM_CONTROL, FRM_TILE_PTR, val, gbe_tiles.dma >> 9);\r\nSET_GBE_FIELD(FRM_CONTROL, FRM_DMA_ENABLE, val, 0);\r\nSET_GBE_FIELD(FRM_CONTROL, FRM_LINEAR, val, 0);\r\ngbe->frm_control = val;\r\nmaxPixelsPerTileX = 512 / bytesPerPixel;\r\nwholeTilesX = 1;\r\npartTilesX = 0;\r\nval = 0;\r\nSET_GBE_FIELD(FRM_SIZE_TILE, FRM_WIDTH_TILE, val, wholeTilesX);\r\nSET_GBE_FIELD(FRM_SIZE_TILE, FRM_RHS, val, partTilesX);\r\nswitch (bytesPerPixel) {\r\ncase 1:\r\nSET_GBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, val,\r\nGBE_FRM_DEPTH_8);\r\nbreak;\r\ncase 2:\r\nSET_GBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, val,\r\nGBE_FRM_DEPTH_16);\r\nbreak;\r\ncase 4:\r\nSET_GBE_FIELD(FRM_SIZE_TILE, FRM_DEPTH, val,\r\nGBE_FRM_DEPTH_32);\r\nbreak;\r\n}\r\ngbe->frm_size_tile = val;\r\nheight_pix = xpmax * ypmax / maxPixelsPerTileX;\r\nval = 0;\r\nSET_GBE_FIELD(FRM_SIZE_PIXEL, FB_HEIGHT_PIX, val, height_pix);\r\ngbe->frm_size_pixel = val;\r\ngbe->did_control = 0;\r\ngbe->ovr_width_tile = 0;\r\ngbe->crs_ctl = 0;\r\ngbe_turn_on();\r\nudelay(10);\r\nfor (i = 0; i < 256; i++)\r\ngbe->gmap[i] = (i << 24) | (i << 16) | (i << 8);\r\nfor (i = 0; i < 256; i++)\r\ngbe_cmap[i] = (i << 8) | (i << 16) | (i << 24);\r\ngbe_loadcmap();\r\nreturn 0;\r\n}\r\nstatic void gbefb_encode_fix(struct fb_fix_screeninfo *fix,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\r\nstrcpy(fix->id, "SGI GBE");\r\nfix->smem_start = (unsigned long) gbe_mem;\r\nfix->smem_len = gbe_mem_size;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nfix->accel = FB_ACCEL_NONE;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ndefault:\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\n}\r\nfix->ywrapstep = 0;\r\nfix->xpanstep = 0;\r\nfix->ypanstep = 0;\r\nfix->line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nfix->mmio_start = GBE_BASE;\r\nfix->mmio_len = sizeof(struct sgi_gbe);\r\n}\r\nstatic int gbefb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nint i;\r\nif (regno > 255)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nif (info->var.bits_per_pixel <= 8) {\r\ngbe_cmap[regno] = (red << 24) | (green << 16) | (blue << 8);\r\nif (gbe_turned_on) {\r\nfor (i = 0; i < 1000 && gbe->cm_fifo >= 63; i++)\r\nudelay(10);\r\nif (i == 1000) {\r\nprintk(KERN_ERR "gbefb: cmap FIFO timeout\n");\r\nreturn 1;\r\n}\r\ngbe->cmap[regno] = gbe_cmap[regno];\r\n}\r\n} else if (regno < 16) {\r\nswitch (info->var.bits_per_pixel) {\r\ncase 15:\r\ncase 16:\r\nred >>= 3;\r\ngreen >>= 3;\r\nblue >>= 3;\r\npseudo_palette[regno] =\r\n(red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\nbreak;\r\ncase 32:\r\npseudo_palette[regno] =\r\n(red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbefb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nunsigned int line_length;\r\nstruct gbe_timing_info timing;\r\nint ret;\r\nif (var->bits_per_pixel <= 8)\r\nvar->bits_per_pixel = 8;\r\nelse if (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse if (var->bits_per_pixel <= 32)\r\nvar->bits_per_pixel = 32;\r\nelse\r\nreturn -EINVAL;\r\nif ((var->xres * var->yres * var->bits_per_pixel) & 4095)\r\nreturn -EINVAL;\r\nvar->grayscale = 0;\r\nret = compute_gbe_timing(var, &timing);\r\nvar->pixclock = ret;\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nif (var->xres > var->xres_virtual || (!ywrap && !ypan))\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual || (!ywrap && !ypan))\r\nvar->yres_virtual = var->yres;\r\nif (var->vmode & FB_VMODE_CONUPDATE) {\r\nvar->vmode |= FB_VMODE_YWRAP;\r\nvar->xoffset = info->var.xoffset;\r\nvar->yoffset = info->var.yoffset;\r\n}\r\nvar->grayscale = 0;\r\nline_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nif (line_length * var->yres_virtual > gbe_mem_size)\r\nreturn -ENOMEM;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 24;\r\nvar->red.length = 8;\r\nvar->green.offset = 16;\r\nvar->green.length = 8;\r\nvar->blue.offset = 8;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 8;\r\nbreak;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nvar->left_margin = timing.htotal - timing.hsync_end;\r\nvar->right_margin = timing.hsync_start - timing.width;\r\nvar->upper_margin = timing.vtotal - timing.vsync_end;\r\nvar->lower_margin = timing.vsync_start - timing.height;\r\nvar->hsync_len = timing.hsync_end - timing.hsync_start;\r\nvar->vsync_len = timing.vsync_end - timing.vsync_start;\r\nreturn 0;\r\n}\r\nstatic int gbefb_mmap(struct fb_info *info,\r\nstruct vm_area_struct *vma)\r\n{\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nunsigned long addr;\r\nunsigned long phys_addr, phys_size;\r\nu16 *tile;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\r\nreturn -EINVAL;\r\nif (size > gbe_mem_size)\r\nreturn -EINVAL;\r\nif (offset > gbe_mem_size - size)\r\nreturn -EINVAL;\r\npgprot_val(vma->vm_page_prot) =\r\npgprot_fb(pgprot_val(vma->vm_page_prot));\r\ntile = &gbe_tiles.cpu[offset >> TILE_SHIFT];\r\naddr = vma->vm_start;\r\noffset &= TILE_MASK;\r\ndo {\r\nphys_addr = (((unsigned long) (*tile)) << TILE_SHIFT) + offset;\r\nif ((offset + size) < TILE_SIZE)\r\nphys_size = size;\r\nelse\r\nphys_size = TILE_SIZE - offset;\r\nif (remap_pfn_range(vma, addr, phys_addr >> PAGE_SHIFT,\r\nphys_size, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\noffset = 0;\r\nsize -= phys_size;\r\naddr += phys_size;\r\ntile++;\r\n} while (size);\r\nreturn 0;\r\n}\r\nstatic ssize_t gbefb_show_memsize(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", gbe_mem_size);\r\n}\r\nstatic ssize_t gbefb_show_rev(struct device *device, struct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", gbe_revision);\r\n}\r\nstatic void gbefb_remove_sysfs(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_size);\r\ndevice_remove_file(dev, &dev_attr_revision);\r\n}\r\nstatic void gbefb_create_sysfs(struct device *dev)\r\n{\r\ndevice_create_file(dev, &dev_attr_size);\r\ndevice_create_file(dev, &dev_attr_revision);\r\n}\r\nstatic int gbefb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "monitor:", 8)) {\r\nif (!strncmp(this_opt + 8, "crt", 3)) {\r\nflat_panel_enabled = 0;\r\ndefault_var = &default_var_CRT;\r\ndefault_mode = &default_mode_CRT;\r\n} else if (!strncmp(this_opt + 8, "1600sw", 6) ||\r\n!strncmp(this_opt + 8, "lcd", 3)) {\r\nflat_panel_enabled = 1;\r\ndefault_var = &default_var_LCD;\r\ndefault_mode = &default_mode_LCD;\r\n}\r\n} else if (!strncmp(this_opt, "mem:", 4)) {\r\ngbe_mem_size = memparse(this_opt + 4, &this_opt);\r\nif (gbe_mem_size > CONFIG_FB_GBE_MEM * 1024 * 1024)\r\ngbe_mem_size = CONFIG_FB_GBE_MEM * 1024 * 1024;\r\nif (gbe_mem_size < TILE_SIZE)\r\ngbe_mem_size = TILE_SIZE;\r\n} else\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbefb_probe(struct platform_device *p_dev)\r\n{\r\nint i, ret = 0;\r\nstruct fb_info *info;\r\nstruct gbefb_par *par;\r\n#ifndef MODULE\r\nchar *options = NULL;\r\n#endif\r\ninfo = framebuffer_alloc(sizeof(struct gbefb_par), &p_dev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\n#ifndef MODULE\r\nif (fb_get_options("gbefb", &options)) {\r\nret = -ENODEV;\r\ngoto out_release_framebuffer;\r\n}\r\ngbefb_setup(options);\r\n#endif\r\nif (!request_mem_region(GBE_BASE, sizeof(struct sgi_gbe), "GBE")) {\r\nprintk(KERN_ERR "gbefb: couldn't reserve mmio region\n");\r\nret = -EBUSY;\r\ngoto out_release_framebuffer;\r\n}\r\ngbe = (struct sgi_gbe *) devm_ioremap(&p_dev->dev, GBE_BASE,\r\nsizeof(struct sgi_gbe));\r\nif (!gbe) {\r\nprintk(KERN_ERR "gbefb: couldn't map mmio region\n");\r\nret = -ENXIO;\r\ngoto out_release_mem_region;\r\n}\r\ngbe_revision = gbe->ctrlstat & 15;\r\ngbe_tiles.cpu =\r\ndma_alloc_coherent(NULL, GBE_TLB_SIZE * sizeof(uint16_t),\r\n&gbe_tiles.dma, GFP_KERNEL);\r\nif (!gbe_tiles.cpu) {\r\nprintk(KERN_ERR "gbefb: couldn't allocate tiles table\n");\r\nret = -ENOMEM;\r\ngoto out_release_mem_region;\r\n}\r\nif (gbe_mem_phys) {\r\ngbe_mem = devm_ioremap_wc(&p_dev->dev, gbe_mem_phys,\r\ngbe_mem_size);\r\nif (!gbe_mem) {\r\nprintk(KERN_ERR "gbefb: couldn't map framebuffer\n");\r\nret = -ENOMEM;\r\ngoto out_tiles_free;\r\n}\r\ngbe_dma_addr = 0;\r\n} else {\r\ngbe_mem = dma_alloc_wc(NULL, gbe_mem_size, &gbe_dma_addr,\r\nGFP_KERNEL);\r\nif (!gbe_mem) {\r\nprintk(KERN_ERR "gbefb: couldn't allocate framebuffer memory\n");\r\nret = -ENOMEM;\r\ngoto out_tiles_free;\r\n}\r\ngbe_mem_phys = (unsigned long) gbe_dma_addr;\r\n}\r\npar = info->par;\r\npar->wc_cookie = arch_phys_wc_add(gbe_mem_phys, gbe_mem_size);\r\nfor (i = 0; i < (gbe_mem_size >> TILE_SHIFT); i++)\r\ngbe_tiles.cpu[i] = (gbe_mem_phys >> TILE_SHIFT) + i;\r\ninfo->fbops = &gbefb_ops;\r\ninfo->pseudo_palette = pseudo_palette;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->screen_base = gbe_mem;\r\nfb_alloc_cmap(&info->cmap, 256, 0);\r\ngbe_reset();\r\nif (fb_find_mode(&par->var, info, mode_option, NULL, 0,\r\ndefault_mode, 8) == 0)\r\npar->var = *default_var;\r\ninfo->var = par->var;\r\ngbefb_check_var(&par->var, info);\r\ngbefb_encode_fix(&info->fix, &info->var);\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR "gbefb: couldn't register framebuffer\n");\r\nret = -ENXIO;\r\ngoto out_gbe_unmap;\r\n}\r\nplatform_set_drvdata(p_dev, info);\r\ngbefb_create_sysfs(&p_dev->dev);\r\nfb_info(info, "%s rev %d @ 0x%08x using %dkB memory\n",\r\ninfo->fix.id, gbe_revision, (unsigned)GBE_BASE,\r\ngbe_mem_size >> 10);\r\nreturn 0;\r\nout_gbe_unmap:\r\narch_phys_wc_del(par->wc_cookie);\r\nif (gbe_dma_addr)\r\ndma_free_wc(NULL, gbe_mem_size, gbe_mem, gbe_mem_phys);\r\nout_tiles_free:\r\ndma_free_coherent(NULL, GBE_TLB_SIZE * sizeof(uint16_t),\r\n(void *)gbe_tiles.cpu, gbe_tiles.dma);\r\nout_release_mem_region:\r\nrelease_mem_region(GBE_BASE, sizeof(struct sgi_gbe));\r\nout_release_framebuffer:\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int gbefb_remove(struct platform_device* p_dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(p_dev);\r\nstruct gbefb_par *par = info->par;\r\nunregister_framebuffer(info);\r\ngbe_turn_off();\r\narch_phys_wc_del(par->wc_cookie);\r\nif (gbe_dma_addr)\r\ndma_free_wc(NULL, gbe_mem_size, gbe_mem, gbe_mem_phys);\r\ndma_free_coherent(NULL, GBE_TLB_SIZE * sizeof(uint16_t),\r\n(void *)gbe_tiles.cpu, gbe_tiles.dma);\r\nrelease_mem_region(GBE_BASE, sizeof(struct sgi_gbe));\r\ngbefb_remove_sysfs(&p_dev->dev);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int __init gbefb_init(void)\r\n{\r\nint ret = platform_driver_register(&gbefb_driver);\r\nif (!ret) {\r\ngbefb_device = platform_device_alloc("gbefb", 0);\r\nif (gbefb_device) {\r\nret = platform_device_add(gbefb_device);\r\n} else {\r\nret = -ENOMEM;\r\n}\r\nif (ret) {\r\nplatform_device_put(gbefb_device);\r\nplatform_driver_unregister(&gbefb_driver);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit gbefb_exit(void)\r\n{\r\nplatform_device_unregister(gbefb_device);\r\nplatform_driver_unregister(&gbefb_driver);\r\n}
