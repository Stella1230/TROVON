static unsigned long rotate_xor(unsigned long hash, const void *area,\r\nsize_t size)\r\n{\r\nsize_t i;\r\nunsigned long *ptr = (unsigned long *)area;\r\nfor (i = 0; i < size / sizeof(hash); i++) {\r\nhash = (hash << ((sizeof(hash) * 8) - 7)) | (hash >> 7);\r\nhash ^= ptr[i];\r\n}\r\nreturn hash;\r\n}\r\nstatic unsigned long get_boot_seed(void)\r\n{\r\nunsigned long hash = 0;\r\nhash = rotate_xor(hash, build_str, sizeof(build_str));\r\nhash = rotate_xor(hash, boot_params, sizeof(*boot_params));\r\nreturn hash;\r\n}\r\nstatic bool mem_overlaps(struct mem_vector *one, struct mem_vector *two)\r\n{\r\nif (one->start + one->size <= two->start)\r\nreturn false;\r\nif (one->start >= two->start + two->size)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void mem_avoid_init(unsigned long input, unsigned long input_size,\r\nunsigned long output)\r\n{\r\nunsigned long init_size = boot_params->hdr.init_size;\r\nu64 initrd_start, initrd_size;\r\nu64 cmd_line, cmd_line_size;\r\nchar *ptr;\r\nmem_avoid[MEM_AVOID_ZO_RANGE].start = input;\r\nmem_avoid[MEM_AVOID_ZO_RANGE].size = (output + init_size) - input;\r\nadd_identity_map(mem_avoid[MEM_AVOID_ZO_RANGE].start,\r\nmem_avoid[MEM_AVOID_ZO_RANGE].size);\r\ninitrd_start = (u64)boot_params->ext_ramdisk_image << 32;\r\ninitrd_start |= boot_params->hdr.ramdisk_image;\r\ninitrd_size = (u64)boot_params->ext_ramdisk_size << 32;\r\ninitrd_size |= boot_params->hdr.ramdisk_size;\r\nmem_avoid[MEM_AVOID_INITRD].start = initrd_start;\r\nmem_avoid[MEM_AVOID_INITRD].size = initrd_size;\r\ncmd_line = (u64)boot_params->ext_cmd_line_ptr << 32;\r\ncmd_line |= boot_params->hdr.cmd_line_ptr;\r\nptr = (char *)(unsigned long)cmd_line;\r\nfor (cmd_line_size = 0; ptr[cmd_line_size++]; )\r\n;\r\nmem_avoid[MEM_AVOID_CMDLINE].start = cmd_line;\r\nmem_avoid[MEM_AVOID_CMDLINE].size = cmd_line_size;\r\nadd_identity_map(mem_avoid[MEM_AVOID_CMDLINE].start,\r\nmem_avoid[MEM_AVOID_CMDLINE].size);\r\nmem_avoid[MEM_AVOID_BOOTPARAMS].start = (unsigned long)boot_params;\r\nmem_avoid[MEM_AVOID_BOOTPARAMS].size = sizeof(*boot_params);\r\nadd_identity_map(mem_avoid[MEM_AVOID_BOOTPARAMS].start,\r\nmem_avoid[MEM_AVOID_BOOTPARAMS].size);\r\n#ifdef CONFIG_X86_VERBOSE_BOOTUP\r\nadd_identity_map(0, PMD_SIZE);\r\n#endif\r\n}\r\nstatic bool mem_avoid_overlap(struct mem_vector *img,\r\nstruct mem_vector *overlap)\r\n{\r\nint i;\r\nstruct setup_data *ptr;\r\nunsigned long earliest = img->start + img->size;\r\nbool is_overlapping = false;\r\nfor (i = 0; i < MEM_AVOID_MAX; i++) {\r\nif (mem_overlaps(img, &mem_avoid[i]) &&\r\nmem_avoid[i].start < earliest) {\r\n*overlap = mem_avoid[i];\r\nearliest = overlap->start;\r\nis_overlapping = true;\r\n}\r\n}\r\nptr = (struct setup_data *)(unsigned long)boot_params->hdr.setup_data;\r\nwhile (ptr) {\r\nstruct mem_vector avoid;\r\navoid.start = (unsigned long)ptr;\r\navoid.size = sizeof(*ptr) + ptr->len;\r\nif (mem_overlaps(img, &avoid) && (avoid.start < earliest)) {\r\n*overlap = avoid;\r\nearliest = overlap->start;\r\nis_overlapping = true;\r\n}\r\nptr = (struct setup_data *)(unsigned long)ptr->next;\r\n}\r\nreturn is_overlapping;\r\n}\r\nstatic void store_slot_info(struct mem_vector *region, unsigned long image_size)\r\n{\r\nstruct slot_area slot_area;\r\nif (slot_area_index == MAX_SLOT_AREA)\r\nreturn;\r\nslot_area.addr = region->start;\r\nslot_area.num = (region->size - image_size) /\r\nCONFIG_PHYSICAL_ALIGN + 1;\r\nif (slot_area.num > 0) {\r\nslot_areas[slot_area_index++] = slot_area;\r\nslot_max += slot_area.num;\r\n}\r\n}\r\nstatic unsigned long slots_fetch_random(void)\r\n{\r\nunsigned long slot;\r\nint i;\r\nif (slot_max == 0)\r\nreturn 0;\r\nslot = kaslr_get_random_long("Physical") % slot_max;\r\nfor (i = 0; i < slot_area_index; i++) {\r\nif (slot >= slot_areas[i].num) {\r\nslot -= slot_areas[i].num;\r\ncontinue;\r\n}\r\nreturn slot_areas[i].addr + slot * CONFIG_PHYSICAL_ALIGN;\r\n}\r\nif (i == slot_area_index)\r\ndebug_putstr("slots_fetch_random() failed!?\n");\r\nreturn 0;\r\n}\r\nstatic void process_e820_entry(struct e820entry *entry,\r\nunsigned long minimum,\r\nunsigned long image_size)\r\n{\r\nstruct mem_vector region, overlap;\r\nstruct slot_area slot_area;\r\nunsigned long start_orig;\r\nif (entry->type != E820_RAM)\r\nreturn;\r\nif (IS_ENABLED(CONFIG_X86_32) && entry->addr >= KERNEL_IMAGE_SIZE)\r\nreturn;\r\nif (entry->addr + entry->size < minimum)\r\nreturn;\r\nregion.start = entry->addr;\r\nregion.size = entry->size;\r\nwhile (slot_area_index < MAX_SLOT_AREA) {\r\nstart_orig = region.start;\r\nif (region.start < minimum)\r\nregion.start = minimum;\r\nregion.start = ALIGN(region.start, CONFIG_PHYSICAL_ALIGN);\r\nif (region.start > entry->addr + entry->size)\r\nreturn;\r\nregion.size -= region.start - start_orig;\r\nif (IS_ENABLED(CONFIG_X86_32) &&\r\nregion.start + region.size > KERNEL_IMAGE_SIZE)\r\nregion.size = KERNEL_IMAGE_SIZE - region.start;\r\nif (region.size < image_size)\r\nreturn;\r\nif (!mem_avoid_overlap(&region, &overlap)) {\r\nstore_slot_info(&region, image_size);\r\nreturn;\r\n}\r\nif (overlap.start > region.start + image_size) {\r\nstruct mem_vector beginning;\r\nbeginning.start = region.start;\r\nbeginning.size = overlap.start - region.start;\r\nstore_slot_info(&beginning, image_size);\r\n}\r\nif (overlap.start + overlap.size >= region.start + region.size)\r\nreturn;\r\nregion.size -= overlap.start - region.start + overlap.size;\r\nregion.start = overlap.start + overlap.size;\r\n}\r\n}\r\nstatic unsigned long find_random_phys_addr(unsigned long minimum,\r\nunsigned long image_size)\r\n{\r\nint i;\r\nunsigned long addr;\r\nminimum = ALIGN(minimum, CONFIG_PHYSICAL_ALIGN);\r\nfor (i = 0; i < boot_params->e820_entries; i++) {\r\nprocess_e820_entry(&boot_params->e820_map[i], minimum,\r\nimage_size);\r\nif (slot_area_index == MAX_SLOT_AREA) {\r\ndebug_putstr("Aborted e820 scan (slot_areas full)!\n");\r\nbreak;\r\n}\r\n}\r\nreturn slots_fetch_random();\r\n}\r\nstatic unsigned long find_random_virt_addr(unsigned long minimum,\r\nunsigned long image_size)\r\n{\r\nunsigned long slots, random_addr;\r\nminimum = ALIGN(minimum, CONFIG_PHYSICAL_ALIGN);\r\nimage_size = ALIGN(image_size, CONFIG_PHYSICAL_ALIGN);\r\nslots = (KERNEL_IMAGE_SIZE - minimum - image_size) /\r\nCONFIG_PHYSICAL_ALIGN + 1;\r\nrandom_addr = kaslr_get_random_long("Virtual") % slots;\r\nreturn random_addr * CONFIG_PHYSICAL_ALIGN + minimum;\r\n}\r\nvoid choose_random_location(unsigned long input,\r\nunsigned long input_size,\r\nunsigned long *output,\r\nunsigned long output_size,\r\nunsigned long *virt_addr)\r\n{\r\nunsigned long random_addr, min_addr;\r\n*virt_addr = *output;\r\nif (cmdline_find_option_bool("nokaslr")) {\r\nwarn("KASLR disabled: 'nokaslr' on cmdline.");\r\nreturn;\r\n}\r\nboot_params->hdr.loadflags |= KASLR_FLAG;\r\ninitialize_identity_maps();\r\nmem_avoid_init(input, input_size, *output);\r\nmin_addr = min(*output, 512UL << 20);\r\nrandom_addr = find_random_phys_addr(min_addr, output_size);\r\nif (!random_addr) {\r\nwarn("KASLR disabled: could not find suitable E820 region!");\r\n} else {\r\nif (*output != random_addr) {\r\nadd_identity_map(random_addr, output_size);\r\n*output = random_addr;\r\n}\r\n}\r\nfinalize_identity_maps();\r\nif (IS_ENABLED(CONFIG_X86_64))\r\nrandom_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);\r\n*virt_addr = random_addr;\r\n}
