static void ocfs2_global_disk2memdqb(struct dquot *dquot, void *dp)\r\n{\r\nstruct ocfs2_global_disk_dqblk *d = dp;\r\nstruct mem_dqblk *m = &dquot->dq_dqb;\r\nif (!test_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags)) {\r\nm->dqb_ihardlimit = le64_to_cpu(d->dqb_ihardlimit);\r\nm->dqb_isoftlimit = le64_to_cpu(d->dqb_isoftlimit);\r\n}\r\nif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\r\nm->dqb_curinodes = le64_to_cpu(d->dqb_curinodes);\r\nif (!test_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags)) {\r\nm->dqb_bhardlimit = le64_to_cpu(d->dqb_bhardlimit);\r\nm->dqb_bsoftlimit = le64_to_cpu(d->dqb_bsoftlimit);\r\n}\r\nif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\r\nm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\r\nif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags))\r\nm->dqb_btime = le64_to_cpu(d->dqb_btime);\r\nif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags))\r\nm->dqb_itime = le64_to_cpu(d->dqb_itime);\r\nOCFS2_DQUOT(dquot)->dq_use_count = le32_to_cpu(d->dqb_use_count);\r\n}\r\nstatic void ocfs2_global_mem2diskdqb(void *dp, struct dquot *dquot)\r\n{\r\nstruct ocfs2_global_disk_dqblk *d = dp;\r\nstruct mem_dqblk *m = &dquot->dq_dqb;\r\nd->dqb_id = cpu_to_le32(from_kqid(&init_user_ns, dquot->dq_id));\r\nd->dqb_use_count = cpu_to_le32(OCFS2_DQUOT(dquot)->dq_use_count);\r\nd->dqb_ihardlimit = cpu_to_le64(m->dqb_ihardlimit);\r\nd->dqb_isoftlimit = cpu_to_le64(m->dqb_isoftlimit);\r\nd->dqb_curinodes = cpu_to_le64(m->dqb_curinodes);\r\nd->dqb_bhardlimit = cpu_to_le64(m->dqb_bhardlimit);\r\nd->dqb_bsoftlimit = cpu_to_le64(m->dqb_bsoftlimit);\r\nd->dqb_curspace = cpu_to_le64(m->dqb_curspace);\r\nd->dqb_btime = cpu_to_le64(m->dqb_btime);\r\nd->dqb_itime = cpu_to_le64(m->dqb_itime);\r\nd->dqb_pad1 = d->dqb_pad2 = 0;\r\n}\r\nstatic int ocfs2_global_is_id(void *dp, struct dquot *dquot)\r\n{\r\nstruct ocfs2_global_disk_dqblk *d = dp;\r\nstruct ocfs2_mem_dqinfo *oinfo =\r\nsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\r\nif (qtree_entry_unused(&oinfo->dqi_gi, dp))\r\nreturn 0;\r\nreturn qid_eq(make_kqid(&init_user_ns, dquot->dq_id.type,\r\nle32_to_cpu(d->dqb_id)),\r\ndquot->dq_id);\r\n}\r\nint ocfs2_validate_quota_block(struct super_block *sb, struct buffer_head *bh)\r\n{\r\nstruct ocfs2_disk_dqtrailer *dqt =\r\nocfs2_block_dqtrailer(sb->s_blocksize, bh->b_data);\r\ntrace_ocfs2_validate_quota_block((unsigned long long)bh->b_blocknr);\r\nBUG_ON(!buffer_uptodate(bh));\r\nreturn ocfs2_validate_meta_ecc(sb, bh->b_data, &dqt->dq_check);\r\n}\r\nint ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\r\nstruct buffer_head **bhp)\r\n{\r\nint rc;\r\n*bhp = NULL;\r\nrc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\r\nocfs2_validate_quota_block);\r\nif (rc)\r\nmlog_errno(rc);\r\nreturn rc;\r\n}\r\nssize_t ocfs2_quota_read(struct super_block *sb, int type, char *data,\r\nsize_t len, loff_t off)\r\n{\r\nstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\r\nstruct inode *gqinode = oinfo->dqi_gqinode;\r\nloff_t i_size = i_size_read(gqinode);\r\nint offset = off & (sb->s_blocksize - 1);\r\nsector_t blk = off >> sb->s_blocksize_bits;\r\nint err = 0;\r\nstruct buffer_head *bh;\r\nsize_t toread, tocopy;\r\nu64 pblock = 0, pcount = 0;\r\nif (off > i_size)\r\nreturn 0;\r\nif (off + len > i_size)\r\nlen = i_size - off;\r\ntoread = len;\r\nwhile (toread > 0) {\r\ntocopy = min_t(size_t, (sb->s_blocksize - offset), toread);\r\nif (!pcount) {\r\nerr = ocfs2_extent_map_get_blocks(gqinode, blk, &pblock,\r\n&pcount, NULL);\r\nif (err) {\r\nmlog_errno(err);\r\nreturn err;\r\n}\r\n} else {\r\npcount--;\r\npblock++;\r\n}\r\nbh = NULL;\r\nerr = ocfs2_read_quota_phys_block(gqinode, pblock, &bh);\r\nif (err) {\r\nmlog_errno(err);\r\nreturn err;\r\n}\r\nmemcpy(data, bh->b_data + offset, tocopy);\r\nbrelse(bh);\r\noffset = 0;\r\ntoread -= tocopy;\r\ndata += tocopy;\r\nblk++;\r\n}\r\nreturn len;\r\n}\r\nssize_t ocfs2_quota_write(struct super_block *sb, int type,\r\nconst char *data, size_t len, loff_t off)\r\n{\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\r\nstruct inode *gqinode = oinfo->dqi_gqinode;\r\nint offset = off & (sb->s_blocksize - 1);\r\nsector_t blk = off >> sb->s_blocksize_bits;\r\nint err = 0, new = 0, ja_type;\r\nstruct buffer_head *bh = NULL;\r\nhandle_t *handle = journal_current_handle();\r\nu64 pblock, pcount;\r\nif (!handle) {\r\nmlog(ML_ERROR, "Quota write (off=%llu, len=%llu) cancelled "\r\n"because transaction was not started.\n",\r\n(unsigned long long)off, (unsigned long long)len);\r\nreturn -EIO;\r\n}\r\nif (len > sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE - offset) {\r\nWARN_ON(1);\r\nlen = sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE - offset;\r\n}\r\nif (i_size_read(gqinode) < off + len) {\r\nloff_t rounded_end =\r\nocfs2_align_bytes_to_blocks(sb, off + len);\r\nerr = ocfs2_simple_size_update(gqinode,\r\noinfo->dqi_gqi_bh,\r\nrounded_end);\r\nif (err < 0)\r\ngoto out;\r\nnew = 1;\r\n}\r\nerr = ocfs2_extent_map_get_blocks(gqinode, blk, &pblock, &pcount, NULL);\r\nif (err) {\r\nmlog_errno(err);\r\ngoto out;\r\n}\r\nif ((offset || len < sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) &&\r\n!new) {\r\nerr = ocfs2_read_quota_phys_block(gqinode, pblock, &bh);\r\nja_type = OCFS2_JOURNAL_ACCESS_WRITE;\r\n} else {\r\nbh = sb_getblk(sb, pblock);\r\nif (!bh)\r\nerr = -ENOMEM;\r\nja_type = OCFS2_JOURNAL_ACCESS_CREATE;\r\n}\r\nif (err) {\r\nmlog_errno(err);\r\ngoto out;\r\n}\r\nlock_buffer(bh);\r\nif (new)\r\nmemset(bh->b_data, 0, sb->s_blocksize);\r\nmemcpy(bh->b_data + offset, data, len);\r\nflush_dcache_page(bh->b_page);\r\nset_buffer_uptodate(bh);\r\nunlock_buffer(bh);\r\nocfs2_set_buffer_uptodate(INODE_CACHE(gqinode), bh);\r\nerr = ocfs2_journal_access_dq(handle, INODE_CACHE(gqinode), bh,\r\nja_type);\r\nif (err < 0) {\r\nbrelse(bh);\r\ngoto out;\r\n}\r\nocfs2_journal_dirty(handle, bh);\r\nbrelse(bh);\r\nout:\r\nif (err) {\r\nmlog_errno(err);\r\nreturn err;\r\n}\r\ngqinode->i_version++;\r\nocfs2_mark_inode_dirty(handle, gqinode, oinfo->dqi_gqi_bh);\r\nreturn len;\r\n}\r\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\r\n{\r\nint status;\r\nstruct buffer_head *bh = NULL;\r\nstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\r\nif (status < 0)\r\nreturn status;\r\nspin_lock(&dq_data_lock);\r\nif (!oinfo->dqi_gqi_count++)\r\noinfo->dqi_gqi_bh = bh;\r\nelse\r\nWARN_ON(bh != oinfo->dqi_gqi_bh);\r\nspin_unlock(&dq_data_lock);\r\nif (ex) {\r\ninode_lock(oinfo->dqi_gqinode);\r\ndown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\r\n} else {\r\ndown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\r\n}\r\nreturn 0;\r\n}\r\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\r\n{\r\nif (ex) {\r\nup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\r\ninode_unlock(oinfo->dqi_gqinode);\r\n} else {\r\nup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\r\n}\r\nocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\r\nbrelse(oinfo->dqi_gqi_bh);\r\nspin_lock(&dq_data_lock);\r\nif (!--oinfo->dqi_gqi_count)\r\noinfo->dqi_gqi_bh = NULL;\r\nspin_unlock(&dq_data_lock);\r\n}\r\nint ocfs2_global_read_info(struct super_block *sb, int type)\r\n{\r\nstruct inode *gqinode = NULL;\r\nunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\r\nGROUP_QUOTA_SYSTEM_INODE };\r\nstruct ocfs2_global_disk_dqinfo dinfo;\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\r\nu64 pcount;\r\nint status;\r\ngqinode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\r\nOCFS2_INVALID_SLOT);\r\nif (!gqinode) {\r\nmlog(ML_ERROR, "failed to get global quota inode (type=%d)\n",\r\ntype);\r\nstatus = -EINVAL;\r\ngoto out_err;\r\n}\r\noinfo->dqi_gi.dqi_sb = sb;\r\noinfo->dqi_gi.dqi_type = type;\r\nocfs2_qinfo_lock_res_init(&oinfo->dqi_gqlock, oinfo);\r\noinfo->dqi_gi.dqi_entry_size = sizeof(struct ocfs2_global_disk_dqblk);\r\noinfo->dqi_gi.dqi_ops = &ocfs2_global_ops;\r\noinfo->dqi_gqi_bh = NULL;\r\noinfo->dqi_gqi_count = 0;\r\noinfo->dqi_gqinode = gqinode;\r\nstatus = ocfs2_lock_global_qf(oinfo, 0);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_err;\r\n}\r\nstatus = ocfs2_extent_map_get_blocks(gqinode, 0, &oinfo->dqi_giblk,\r\n&pcount, NULL);\r\nif (status < 0)\r\ngoto out_unlock;\r\nstatus = ocfs2_qinfo_lock(oinfo, 0);\r\nif (status < 0)\r\ngoto out_unlock;\r\nstatus = sb->s_op->quota_read(sb, type, (char *)&dinfo,\r\nsizeof(struct ocfs2_global_disk_dqinfo),\r\nOCFS2_GLOBAL_INFO_OFF);\r\nocfs2_qinfo_unlock(oinfo, 0);\r\nocfs2_unlock_global_qf(oinfo, 0);\r\nif (status != sizeof(struct ocfs2_global_disk_dqinfo)) {\r\nmlog(ML_ERROR, "Cannot read global quota info (%d).\n",\r\nstatus);\r\nif (status >= 0)\r\nstatus = -EIO;\r\nmlog_errno(status);\r\ngoto out_err;\r\n}\r\ninfo->dqi_bgrace = le32_to_cpu(dinfo.dqi_bgrace);\r\ninfo->dqi_igrace = le32_to_cpu(dinfo.dqi_igrace);\r\noinfo->dqi_syncms = le32_to_cpu(dinfo.dqi_syncms);\r\noinfo->dqi_gi.dqi_blocks = le32_to_cpu(dinfo.dqi_blocks);\r\noinfo->dqi_gi.dqi_free_blk = le32_to_cpu(dinfo.dqi_free_blk);\r\noinfo->dqi_gi.dqi_free_entry = le32_to_cpu(dinfo.dqi_free_entry);\r\noinfo->dqi_gi.dqi_blocksize_bits = sb->s_blocksize_bits;\r\noinfo->dqi_gi.dqi_usable_bs = sb->s_blocksize -\r\nOCFS2_QBLK_RESERVED_SPACE;\r\noinfo->dqi_gi.dqi_qtree_depth = qtree_depth(&oinfo->dqi_gi);\r\nINIT_DELAYED_WORK(&oinfo->dqi_sync_work, qsync_work_fn);\r\nschedule_delayed_work(&oinfo->dqi_sync_work,\r\nmsecs_to_jiffies(oinfo->dqi_syncms));\r\nout_err:\r\nreturn status;\r\nout_unlock:\r\nocfs2_unlock_global_qf(oinfo, 0);\r\nmlog_errno(status);\r\ngoto out_err;\r\n}\r\nstatic int __ocfs2_global_write_info(struct super_block *sb, int type)\r\n{\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\r\nstruct ocfs2_global_disk_dqinfo dinfo;\r\nssize_t size;\r\nspin_lock(&dq_data_lock);\r\ninfo->dqi_flags &= ~DQF_INFO_DIRTY;\r\ndinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\r\ndinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\r\nspin_unlock(&dq_data_lock);\r\ndinfo.dqi_syncms = cpu_to_le32(oinfo->dqi_syncms);\r\ndinfo.dqi_blocks = cpu_to_le32(oinfo->dqi_gi.dqi_blocks);\r\ndinfo.dqi_free_blk = cpu_to_le32(oinfo->dqi_gi.dqi_free_blk);\r\ndinfo.dqi_free_entry = cpu_to_le32(oinfo->dqi_gi.dqi_free_entry);\r\nsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\r\nsizeof(struct ocfs2_global_disk_dqinfo),\r\nOCFS2_GLOBAL_INFO_OFF);\r\nif (size != sizeof(struct ocfs2_global_disk_dqinfo)) {\r\nmlog(ML_ERROR, "Cannot write global quota info structure\n");\r\nif (size >= 0)\r\nsize = -EIO;\r\nreturn size;\r\n}\r\nreturn 0;\r\n}\r\nint ocfs2_global_write_info(struct super_block *sb, int type)\r\n{\r\nint err;\r\nstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\r\nerr = ocfs2_qinfo_lock(info, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = __ocfs2_global_write_info(sb, type);\r\nocfs2_qinfo_unlock(info, 1);\r\nreturn err;\r\n}\r\nstatic int ocfs2_global_qinit_alloc(struct super_block *sb, int type)\r\n{\r\nstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\r\nreturn oinfo->dqi_gi.dqi_qtree_depth;\r\n}\r\nstatic int ocfs2_calc_global_qinit_credits(struct super_block *sb, int type)\r\n{\r\nreturn (ocfs2_global_qinit_alloc(sb, type) + 2) *\r\nOCFS2_QUOTA_BLOCK_UPDATE_CREDITS + 1;\r\n}\r\nint __ocfs2_sync_dquot(struct dquot *dquot, int freeing)\r\n{\r\nint err, err2;\r\nstruct super_block *sb = dquot->dq_sb;\r\nint type = dquot->dq_id.type;\r\nstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\r\nstruct ocfs2_global_disk_dqblk dqblk;\r\ns64 spacechange, inodechange;\r\ntime64_t olditime, oldbtime;\r\nerr = sb->s_op->quota_read(sb, type, (char *)&dqblk,\r\nsizeof(struct ocfs2_global_disk_dqblk),\r\ndquot->dq_off);\r\nif (err != sizeof(struct ocfs2_global_disk_dqblk)) {\r\nif (err >= 0) {\r\nmlog(ML_ERROR, "Short read from global quota file "\r\n"(%u read)\n", err);\r\nerr = -EIO;\r\n}\r\ngoto out;\r\n}\r\nspin_lock(&dq_data_lock);\r\nspacechange = dquot->dq_dqb.dqb_curspace -\r\nOCFS2_DQUOT(dquot)->dq_origspace;\r\ninodechange = dquot->dq_dqb.dqb_curinodes -\r\nOCFS2_DQUOT(dquot)->dq_originodes;\r\nolditime = dquot->dq_dqb.dqb_itime;\r\noldbtime = dquot->dq_dqb.dqb_btime;\r\nocfs2_global_disk2memdqb(dquot, &dqblk);\r\ntrace_ocfs2_sync_dquot(from_kqid(&init_user_ns, dquot->dq_id),\r\ndquot->dq_dqb.dqb_curspace,\r\n(long long)spacechange,\r\ndquot->dq_dqb.dqb_curinodes,\r\n(long long)inodechange);\r\nif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\r\ndquot->dq_dqb.dqb_curspace += spacechange;\r\nif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\r\ndquot->dq_dqb.dqb_curinodes += inodechange;\r\nif (dquot->dq_dqb.dqb_bsoftlimit &&\r\ndquot->dq_dqb.dqb_curspace > dquot->dq_dqb.dqb_bsoftlimit) {\r\nif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags) &&\r\noldbtime > 0) {\r\nif (dquot->dq_dqb.dqb_btime > 0)\r\ndquot->dq_dqb.dqb_btime =\r\nmin(dquot->dq_dqb.dqb_btime, oldbtime);\r\nelse\r\ndquot->dq_dqb.dqb_btime = oldbtime;\r\n}\r\n} else {\r\ndquot->dq_dqb.dqb_btime = 0;\r\nclear_bit(DQ_BLKS_B, &dquot->dq_flags);\r\n}\r\nif (dquot->dq_dqb.dqb_isoftlimit &&\r\ndquot->dq_dqb.dqb_curinodes > dquot->dq_dqb.dqb_isoftlimit) {\r\nif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags) &&\r\nolditime > 0) {\r\nif (dquot->dq_dqb.dqb_itime > 0)\r\ndquot->dq_dqb.dqb_itime =\r\nmin(dquot->dq_dqb.dqb_itime, olditime);\r\nelse\r\ndquot->dq_dqb.dqb_itime = olditime;\r\n}\r\n} else {\r\ndquot->dq_dqb.dqb_itime = 0;\r\nclear_bit(DQ_INODES_B, &dquot->dq_flags);\r\n}\r\n__clear_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\r\n__clear_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\r\n__clear_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\r\n__clear_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\r\n__clear_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\r\n__clear_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\r\nOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\r\nOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\r\nspin_unlock(&dq_data_lock);\r\nerr = ocfs2_qinfo_lock(info, freeing);\r\nif (err < 0) {\r\nmlog(ML_ERROR, "Failed to lock quota info, losing quota write"\r\n" (type=%d, id=%u)\n", dquot->dq_id.type,\r\n(unsigned)from_kqid(&init_user_ns, dquot->dq_id));\r\ngoto out;\r\n}\r\nif (freeing)\r\nOCFS2_DQUOT(dquot)->dq_use_count--;\r\nerr = qtree_write_dquot(&info->dqi_gi, dquot);\r\nif (err < 0)\r\ngoto out_qlock;\r\nif (freeing && !OCFS2_DQUOT(dquot)->dq_use_count) {\r\nerr = qtree_release_dquot(&info->dqi_gi, dquot);\r\nif (info_dirty(sb_dqinfo(sb, type))) {\r\nerr2 = __ocfs2_global_write_info(sb, type);\r\nif (!err)\r\nerr = err2;\r\n}\r\n}\r\nout_qlock:\r\nocfs2_qinfo_unlock(info, freeing);\r\nout:\r\nif (err < 0)\r\nmlog_errno(err);\r\nreturn err;\r\n}\r\nstatic int ocfs2_sync_dquot_helper(struct dquot *dquot, unsigned long type)\r\n{\r\nhandle_t *handle;\r\nstruct super_block *sb = dquot->dq_sb;\r\nstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\r\nstruct ocfs2_super *osb = OCFS2_SB(sb);\r\nint status = 0;\r\ntrace_ocfs2_sync_dquot_helper(from_kqid(&init_user_ns, dquot->dq_id),\r\ndquot->dq_id.type,\r\ntype, sb->s_id);\r\nif (type != dquot->dq_id.type)\r\ngoto out;\r\nstatus = ocfs2_lock_global_qf(oinfo, 1);\r\nif (status < 0)\r\ngoto out;\r\nhandle = ocfs2_start_trans(osb, OCFS2_QSYNC_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out_ilock;\r\n}\r\nmutex_lock(&sb_dqopt(sb)->dqio_mutex);\r\nstatus = ocfs2_sync_dquot(dquot);\r\nif (status < 0)\r\nmlog_errno(status);\r\nstatus = ocfs2_local_write_dquot(dquot);\r\nif (status < 0)\r\nmlog_errno(status);\r\nmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\r\nocfs2_commit_trans(osb, handle);\r\nout_ilock:\r\nocfs2_unlock_global_qf(oinfo, 1);\r\nout:\r\nreturn status;\r\n}\r\nstatic void qsync_work_fn(struct work_struct *work)\r\n{\r\nstruct ocfs2_mem_dqinfo *oinfo = container_of(work,\r\nstruct ocfs2_mem_dqinfo,\r\ndqi_sync_work.work);\r\nstruct super_block *sb = oinfo->dqi_gqinode->i_sb;\r\ndquot_scan_active(sb, ocfs2_sync_dquot_helper, oinfo->dqi_type);\r\nschedule_delayed_work(&oinfo->dqi_sync_work,\r\nmsecs_to_jiffies(oinfo->dqi_syncms));\r\n}\r\nstatic int ocfs2_write_dquot(struct dquot *dquot)\r\n{\r\nhandle_t *handle;\r\nstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\r\nint status = 0;\r\ntrace_ocfs2_write_dquot(from_kqid(&init_user_ns, dquot->dq_id),\r\ndquot->dq_id.type);\r\nhandle = ocfs2_start_trans(osb, OCFS2_QWRITE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nmutex_lock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\r\nstatus = ocfs2_local_write_dquot(dquot);\r\nmutex_unlock(&sb_dqopt(dquot->dq_sb)->dqio_mutex);\r\nocfs2_commit_trans(osb, handle);\r\nout:\r\nreturn status;\r\n}\r\nstatic int ocfs2_calc_qdel_credits(struct super_block *sb, int type)\r\n{\r\nstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\r\nreturn (oinfo->dqi_gi.dqi_qtree_depth + 2) *\r\nOCFS2_QUOTA_BLOCK_UPDATE_CREDITS +\r\nOCFS2_QINFO_WRITE_CREDITS +\r\nOCFS2_INODE_UPDATE_CREDITS;\r\n}\r\nvoid ocfs2_drop_dquot_refs(struct work_struct *work)\r\n{\r\nstruct ocfs2_super *osb = container_of(work, struct ocfs2_super,\r\ndquot_drop_work);\r\nstruct llist_node *list;\r\nstruct ocfs2_dquot *odquot, *next_odquot;\r\nlist = llist_del_all(&osb->dquot_drop_list);\r\nllist_for_each_entry_safe(odquot, next_odquot, list, list) {\r\ndqput(&odquot->dq_dquot);\r\n}\r\n}\r\nstatic int ocfs2_release_dquot(struct dquot *dquot)\r\n{\r\nhandle_t *handle;\r\nstruct ocfs2_mem_dqinfo *oinfo =\r\nsb_dqinfo(dquot->dq_sb, dquot->dq_id.type)->dqi_priv;\r\nstruct ocfs2_super *osb = OCFS2_SB(dquot->dq_sb);\r\nint status = 0;\r\ntrace_ocfs2_release_dquot(from_kqid(&init_user_ns, dquot->dq_id),\r\ndquot->dq_id.type);\r\nmutex_lock(&dquot->dq_lock);\r\nif (atomic_read(&dquot->dq_count) > 1)\r\ngoto out;\r\nif (current == osb->dc_task) {\r\ndqgrab(dquot);\r\nif (llist_add(&OCFS2_DQUOT(dquot)->list, &osb->dquot_drop_list))\r\nqueue_work(osb->ocfs2_wq, &osb->dquot_drop_work);\r\ngoto out;\r\n}\r\nstatus = ocfs2_lock_global_qf(oinfo, 1);\r\nif (status < 0)\r\ngoto out;\r\nhandle = ocfs2_start_trans(osb,\r\nocfs2_calc_qdel_credits(dquot->dq_sb, dquot->dq_id.type));\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out_ilock;\r\n}\r\nstatus = ocfs2_global_release_dquot(dquot);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_trans;\r\n}\r\nstatus = ocfs2_local_release_dquot(handle, dquot);\r\nif (status < 0)\r\nmlog_errno(status);\r\ndquot->dq_off = 0;\r\nclear_bit(DQ_ACTIVE_B, &dquot->dq_flags);\r\nout_trans:\r\nocfs2_commit_trans(osb, handle);\r\nout_ilock:\r\nocfs2_unlock_global_qf(oinfo, 1);\r\nout:\r\nmutex_unlock(&dquot->dq_lock);\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int ocfs2_acquire_dquot(struct dquot *dquot)\r\n{\r\nint status = 0, err;\r\nint ex = 0;\r\nstruct super_block *sb = dquot->dq_sb;\r\nstruct ocfs2_super *osb = OCFS2_SB(sb);\r\nint type = dquot->dq_id.type;\r\nstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\r\nstruct inode *gqinode = info->dqi_gqinode;\r\nint need_alloc = ocfs2_global_qinit_alloc(sb, type);\r\nhandle_t *handle;\r\ntrace_ocfs2_acquire_dquot(from_kqid(&init_user_ns, dquot->dq_id),\r\ntype);\r\nmutex_lock(&dquot->dq_lock);\r\nstatus = ocfs2_lock_global_qf(info, 1);\r\nif (status < 0)\r\ngoto out;\r\nstatus = ocfs2_qinfo_lock(info, 0);\r\nif (status < 0)\r\ngoto out_dq;\r\nstatus = qtree_read_dquot(&info->dqi_gi, dquot);\r\nocfs2_qinfo_unlock(info, 0);\r\nif (status < 0)\r\ngoto out_dq;\r\nOCFS2_DQUOT(dquot)->dq_use_count++;\r\nOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\r\nOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\r\nif (!dquot->dq_off) {\r\nex = 1;\r\nWARN_ON(journal_current_handle());\r\nstatus = ocfs2_extend_no_holes(gqinode, NULL,\r\ni_size_read(gqinode) + (need_alloc << sb->s_blocksize_bits),\r\ni_size_read(gqinode));\r\nif (status < 0)\r\ngoto out_dq;\r\n}\r\nhandle = ocfs2_start_trans(osb,\r\nocfs2_calc_global_qinit_credits(sb, type));\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\ngoto out_dq;\r\n}\r\nstatus = ocfs2_qinfo_lock(info, ex);\r\nif (status < 0)\r\ngoto out_trans;\r\nstatus = qtree_write_dquot(&info->dqi_gi, dquot);\r\nif (ex && info_dirty(sb_dqinfo(sb, type))) {\r\nerr = __ocfs2_global_write_info(sb, type);\r\nif (!status)\r\nstatus = err;\r\n}\r\nocfs2_qinfo_unlock(info, ex);\r\nout_trans:\r\nocfs2_commit_trans(osb, handle);\r\nout_dq:\r\nocfs2_unlock_global_qf(info, 1);\r\nif (status < 0)\r\ngoto out;\r\nstatus = ocfs2_create_local_dquot(dquot);\r\nif (status < 0)\r\ngoto out;\r\nset_bit(DQ_ACTIVE_B, &dquot->dq_flags);\r\nout:\r\nmutex_unlock(&dquot->dq_lock);\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int ocfs2_get_next_id(struct super_block *sb, struct kqid *qid)\r\n{\r\nint type = qid->type;\r\nstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\r\nint status = 0;\r\ntrace_ocfs2_get_next_id(from_kqid(&init_user_ns, *qid), type);\r\nif (!sb_has_quota_loaded(sb, type)) {\r\nstatus = -ESRCH;\r\ngoto out;\r\n}\r\nstatus = ocfs2_lock_global_qf(info, 0);\r\nif (status < 0)\r\ngoto out;\r\nstatus = ocfs2_qinfo_lock(info, 0);\r\nif (status < 0)\r\ngoto out_global;\r\nstatus = qtree_get_next_id(&info->dqi_gi, qid);\r\nocfs2_qinfo_unlock(info, 0);\r\nout_global:\r\nocfs2_unlock_global_qf(info, 0);\r\nout:\r\nif (status && status != -ENOENT && status != -ESRCH)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int ocfs2_mark_dquot_dirty(struct dquot *dquot)\r\n{\r\nunsigned long mask = (1 << (DQ_LASTSET_B + QIF_ILIMITS_B)) |\r\n(1 << (DQ_LASTSET_B + QIF_BLIMITS_B)) |\r\n(1 << (DQ_LASTSET_B + QIF_INODES_B)) |\r\n(1 << (DQ_LASTSET_B + QIF_SPACE_B)) |\r\n(1 << (DQ_LASTSET_B + QIF_BTIME_B)) |\r\n(1 << (DQ_LASTSET_B + QIF_ITIME_B));\r\nint sync = 0;\r\nint status;\r\nstruct super_block *sb = dquot->dq_sb;\r\nint type = dquot->dq_id.type;\r\nstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\r\nhandle_t *handle;\r\nstruct ocfs2_super *osb = OCFS2_SB(sb);\r\ntrace_ocfs2_mark_dquot_dirty(from_kqid(&init_user_ns, dquot->dq_id),\r\ntype);\r\nspin_lock(&dq_data_lock);\r\nif (dquot->dq_flags & mask)\r\nsync = 1;\r\nspin_unlock(&dq_data_lock);\r\nif (!sync || journal_current_handle()) {\r\nstatus = ocfs2_write_dquot(dquot);\r\ngoto out;\r\n}\r\nstatus = ocfs2_lock_global_qf(oinfo, 1);\r\nif (status < 0)\r\ngoto out;\r\nhandle = ocfs2_start_trans(osb, OCFS2_QSYNC_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out_ilock;\r\n}\r\nmutex_lock(&sb_dqopt(sb)->dqio_mutex);\r\nstatus = ocfs2_sync_dquot(dquot);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto out_dlock;\r\n}\r\nstatus = ocfs2_local_write_dquot(dquot);\r\nout_dlock:\r\nmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\r\nocfs2_commit_trans(osb, handle);\r\nout_ilock:\r\nocfs2_unlock_global_qf(oinfo, 1);\r\nout:\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic int ocfs2_write_info(struct super_block *sb, int type)\r\n{\r\nhandle_t *handle;\r\nint status = 0;\r\nstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\r\nstatus = ocfs2_lock_global_qf(oinfo, 1);\r\nif (status < 0)\r\ngoto out;\r\nhandle = ocfs2_start_trans(OCFS2_SB(sb), OCFS2_QINFO_WRITE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out_ilock;\r\n}\r\nstatus = dquot_commit_info(sb, type);\r\nocfs2_commit_trans(OCFS2_SB(sb), handle);\r\nout_ilock:\r\nocfs2_unlock_global_qf(oinfo, 1);\r\nout:\r\nif (status)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nstatic struct dquot *ocfs2_alloc_dquot(struct super_block *sb, int type)\r\n{\r\nstruct ocfs2_dquot *dquot =\r\nkmem_cache_zalloc(ocfs2_dquot_cachep, GFP_NOFS);\r\nif (!dquot)\r\nreturn NULL;\r\nreturn &dquot->dq_dquot;\r\n}\r\nstatic void ocfs2_destroy_dquot(struct dquot *dquot)\r\n{\r\nkmem_cache_free(ocfs2_dquot_cachep, dquot);\r\n}
