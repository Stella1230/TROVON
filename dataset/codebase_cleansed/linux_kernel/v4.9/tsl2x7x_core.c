static int\r\ntsl2x7x_i2c_read(struct i2c_client *client, u8 reg, u8 *val)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte(client, (TSL2X7X_CMD_REG | reg));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to write register %x\n", reg);\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_byte(client);\r\nif (ret >= 0)\r\n*val = (u8)ret;\r\nelse\r\ndev_err(&client->dev, "failed to read register %x\n", reg);\r\nreturn ret;\r\n}\r\nstatic int tsl2x7x_get_lux(struct iio_dev *indio_dev)\r\n{\r\nu16 ch0, ch1;\r\nu32 lux;\r\nu64 lux64;\r\nu32 ratio;\r\nu8 buf[4];\r\nstruct tsl2x7x_lux *p;\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nint i, ret;\r\nu32 ch0lux = 0;\r\nu32 ch1lux = 0;\r\nif (mutex_trylock(&chip->als_mutex) == 0)\r\nreturn chip->als_cur_info.lux;\r\nif (chip->tsl2x7x_chip_status != TSL2X7X_CHIP_WORKING) {\r\ndev_err(&chip->client->dev, "%s: device is not enabled\n",\r\n__func__);\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nret = tsl2x7x_i2c_read(chip->client,\r\n(TSL2X7X_CMD_REG | TSL2X7X_STATUS), &buf[0]);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"%s: Failed to read STATUS Reg\n", __func__);\r\ngoto out_unlock;\r\n}\r\nif (!(buf[0] & TSL2X7X_STA_ADC_VALID)) {\r\ndev_err(&chip->client->dev,\r\n"%s: data not valid yet\n", __func__);\r\nret = chip->als_cur_info.lux;\r\ngoto out_unlock;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nret = tsl2x7x_i2c_read(chip->client,\r\n(TSL2X7X_CMD_REG |\r\n(TSL2X7X_ALS_CHAN0LO + i)), &buf[i]);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"failed to read. err=%x\n", ret);\r\ngoto out_unlock;\r\n}\r\n}\r\nret = i2c_smbus_write_byte(chip->client,\r\n(TSL2X7X_CMD_REG |\r\nTSL2X7X_CMD_SPL_FN |\r\nTSL2X7X_CMD_ALS_INT_CLR));\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"i2c_write_command failed - err = %d\n", ret);\r\ngoto out_unlock;\r\n}\r\nch0 = le16_to_cpup((const __le16 *)&buf[0]);\r\nch1 = le16_to_cpup((const __le16 *)&buf[2]);\r\nchip->als_cur_info.als_ch0 = ch0;\r\nchip->als_cur_info.als_ch1 = ch1;\r\nif ((ch0 >= chip->als_saturation) || (ch1 >= chip->als_saturation)) {\r\nlux = TSL2X7X_LUX_CALC_OVER_FLOW;\r\ngoto return_max;\r\n}\r\nif (!ch0) {\r\nret = chip->als_cur_info.lux;\r\ngoto out_unlock;\r\n}\r\nratio = (ch1 << 15) / ch0;\r\np = (struct tsl2x7x_lux *)chip->tsl2x7x_device_lux;\r\nwhile (p->ratio != 0 && p->ratio < ratio)\r\np++;\r\nif (p->ratio == 0) {\r\nlux = 0;\r\n} else {\r\nch0lux = DIV_ROUND_UP(ch0 * p->ch0,\r\ntsl2X7X_als_gainadj[chip->tsl2x7x_settings.als_gain]);\r\nch1lux = DIV_ROUND_UP(ch1 * p->ch1,\r\ntsl2X7X_als_gainadj[chip->tsl2x7x_settings.als_gain]);\r\nlux = ch0lux - ch1lux;\r\n}\r\nif (ch1lux > ch0lux) {\r\ndev_dbg(&chip->client->dev, "ch1lux > ch0lux-return last value\n");\r\nret = chip->als_cur_info.lux;\r\ngoto out_unlock;\r\n}\r\nif (chip->als_time_scale == 0)\r\nlux = 0;\r\nelse\r\nlux = (lux + (chip->als_time_scale >> 1)) /\r\nchip->als_time_scale;\r\nlux64 = lux;\r\nlux64 = lux64 * chip->tsl2x7x_settings.als_gain_trim;\r\nlux64 >>= 8;\r\nlux = lux64;\r\nlux = (lux + 500) / 1000;\r\nif (lux > TSL2X7X_LUX_CALC_OVER_FLOW)\r\nlux = TSL2X7X_LUX_CALC_OVER_FLOW;\r\nreturn_max:\r\nchip->als_cur_info.lux = lux;\r\nret = lux;\r\nout_unlock:\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic int tsl2x7x_get_prox(struct iio_dev *indio_dev)\r\n{\r\nint i;\r\nint ret;\r\nu8 status;\r\nu8 chdata[2];\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nif (mutex_trylock(&chip->prox_mutex) == 0) {\r\ndev_err(&chip->client->dev,\r\n"%s: Can't get prox mutex\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nret = tsl2x7x_i2c_read(chip->client,\r\n(TSL2X7X_CMD_REG | TSL2X7X_STATUS), &status);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "i2c err=%d\n", ret);\r\ngoto prox_poll_err;\r\n}\r\nswitch (chip->id) {\r\ncase tsl2571:\r\ncase tsl2671:\r\ncase tmd2671:\r\ncase tsl2771:\r\ncase tmd2771:\r\nif (!(status & TSL2X7X_STA_ADC_VALID))\r\ngoto prox_poll_err;\r\nbreak;\r\ncase tsl2572:\r\ncase tsl2672:\r\ncase tmd2672:\r\ncase tsl2772:\r\ncase tmd2772:\r\nif (!(status & TSL2X7X_STA_PRX_VALID))\r\ngoto prox_poll_err;\r\nbreak;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nret = tsl2x7x_i2c_read(chip->client,\r\n(TSL2X7X_CMD_REG |\r\n(TSL2X7X_PRX_LO + i)), &chdata[i]);\r\nif (ret < 0)\r\ngoto prox_poll_err;\r\n}\r\nchip->prox_data =\r\nle16_to_cpup((const __le16 *)&chdata[0]);\r\nprox_poll_err:\r\nmutex_unlock(&chip->prox_mutex);\r\nreturn chip->prox_data;\r\n}\r\nstatic void tsl2x7x_defaults(struct tsl2X7X_chip *chip)\r\n{\r\nif (chip->pdata && chip->pdata->platform_default_settings)\r\nmemcpy(&chip->tsl2x7x_settings,\r\nchip->pdata->platform_default_settings,\r\nsizeof(tsl2x7x_default_settings));\r\nelse\r\nmemcpy(&chip->tsl2x7x_settings,\r\n&tsl2x7x_default_settings,\r\nsizeof(tsl2x7x_default_settings));\r\nif (chip->pdata && chip->pdata->platform_lux_table[0].ratio != 0)\r\nmemcpy(chip->tsl2x7x_device_lux,\r\nchip->pdata->platform_lux_table,\r\nsizeof(chip->pdata->platform_lux_table));\r\nelse\r\nmemcpy(chip->tsl2x7x_device_lux,\r\n(struct tsl2x7x_lux *)tsl2x7x_default_lux_table_group[chip->id],\r\nMAX_DEFAULT_TABLE_BYTES);\r\n}\r\nstatic int tsl2x7x_als_calibrate(struct iio_dev *indio_dev)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nu8 reg_val;\r\nint gain_trim_val;\r\nint ret;\r\nint lux_val;\r\nret = i2c_smbus_write_byte(chip->client,\r\n(TSL2X7X_CMD_REG | TSL2X7X_CNTRL));\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"failed to write CNTRL register, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nreg_val = i2c_smbus_read_byte(chip->client);\r\nif ((reg_val & (TSL2X7X_CNTL_ADC_ENBL | TSL2X7X_CNTL_PWR_ON))\r\n!= (TSL2X7X_CNTL_ADC_ENBL | TSL2X7X_CNTL_PWR_ON)) {\r\ndev_err(&chip->client->dev,\r\n"%s: failed: ADC not enabled\n", __func__);\r\nreturn -1;\r\n}\r\nret = i2c_smbus_write_byte(chip->client,\r\n(TSL2X7X_CMD_REG | TSL2X7X_CNTRL));\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"failed to write ctrl reg: ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nreg_val = i2c_smbus_read_byte(chip->client);\r\nif ((reg_val & TSL2X7X_STA_ADC_VALID) != TSL2X7X_STA_ADC_VALID) {\r\ndev_err(&chip->client->dev,\r\n"%s: failed: STATUS - ADC not valid.\n", __func__);\r\nreturn -ENODATA;\r\n}\r\nlux_val = tsl2x7x_get_lux(indio_dev);\r\nif (lux_val < 0) {\r\ndev_err(&chip->client->dev,\r\n"%s: failed to get lux\n", __func__);\r\nreturn lux_val;\r\n}\r\ngain_trim_val = ((chip->tsl2x7x_settings.als_cal_target)\r\n* chip->tsl2x7x_settings.als_gain_trim) / lux_val;\r\nif ((gain_trim_val < 250) || (gain_trim_val > 4000))\r\nreturn -ERANGE;\r\nchip->tsl2x7x_settings.als_gain_trim = gain_trim_val;\r\ndev_info(&chip->client->dev,\r\n"%s als_calibrate completed\n", chip->client->name);\r\nreturn (int)gain_trim_val;\r\n}\r\nstatic int tsl2x7x_chip_on(struct iio_dev *indio_dev)\r\n{\r\nint i;\r\nint ret = 0;\r\nu8 *dev_reg;\r\nu8 utmp;\r\nint als_count;\r\nint als_time;\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nu8 reg_val = 0;\r\nif (chip->pdata && chip->pdata->power_on)\r\nchip->pdata->power_on(indio_dev);\r\nchip->tsl2x7x_config[TSL2X7X_PRX_TIME] =\r\nchip->tsl2x7x_settings.prx_time;\r\nchip->tsl2x7x_config[TSL2X7X_WAIT_TIME] =\r\nchip->tsl2x7x_settings.wait_time;\r\nchip->tsl2x7x_config[TSL2X7X_PRX_CONFIG] =\r\nchip->tsl2x7x_settings.prox_config;\r\nchip->tsl2x7x_config[TSL2X7X_ALS_MINTHRESHLO] =\r\n(chip->tsl2x7x_settings.als_thresh_low) & 0xFF;\r\nchip->tsl2x7x_config[TSL2X7X_ALS_MINTHRESHHI] =\r\n(chip->tsl2x7x_settings.als_thresh_low >> 8) & 0xFF;\r\nchip->tsl2x7x_config[TSL2X7X_ALS_MAXTHRESHLO] =\r\n(chip->tsl2x7x_settings.als_thresh_high) & 0xFF;\r\nchip->tsl2x7x_config[TSL2X7X_ALS_MAXTHRESHHI] =\r\n(chip->tsl2x7x_settings.als_thresh_high >> 8) & 0xFF;\r\nchip->tsl2x7x_config[TSL2X7X_PERSISTENCE] =\r\nchip->tsl2x7x_settings.persistence;\r\nchip->tsl2x7x_config[TSL2X7X_PRX_COUNT] =\r\nchip->tsl2x7x_settings.prox_pulse_count;\r\nchip->tsl2x7x_config[TSL2X7X_PRX_MINTHRESHLO] =\r\n(chip->tsl2x7x_settings.prox_thres_low) & 0xFF;\r\nchip->tsl2x7x_config[TSL2X7X_PRX_MINTHRESHHI] =\r\n(chip->tsl2x7x_settings.prox_thres_low >> 8) & 0xFF;\r\nchip->tsl2x7x_config[TSL2X7X_PRX_MAXTHRESHLO] =\r\n(chip->tsl2x7x_settings.prox_thres_high) & 0xFF;\r\nchip->tsl2x7x_config[TSL2X7X_PRX_MAXTHRESHHI] =\r\n(chip->tsl2x7x_settings.prox_thres_high >> 8) & 0xFF;\r\nif (chip->tsl2x7x_chip_status == TSL2X7X_CHIP_WORKING) {\r\ndev_info(&chip->client->dev, "device is already enabled\n");\r\nreturn -EINVAL;\r\n}\r\nals_count = (chip->tsl2x7x_settings.als_time * 100 + 135) / 270;\r\nif (!als_count)\r\nals_count = 1;\r\nals_time = (als_count * 27 + 5) / 10;\r\nchip->tsl2x7x_config[TSL2X7X_ALS_TIME] = 256 - als_count;\r\nchip->tsl2x7x_config[TSL2X7X_GAIN] =\r\nchip->tsl2x7x_settings.als_gain |\r\n(TSL2X7X_mA100 | TSL2X7X_DIODE1)\r\n| ((chip->tsl2x7x_settings.prox_gain) << 2);\r\nchip->als_saturation = als_count * 922;\r\nchip->als_time_scale = (als_time + 25) / 50;\r\nutmp = TSL2X7X_CNTL_PWR_ON;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2X7X_CMD_REG | TSL2X7X_CNTRL, utmp);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"%s: failed on CNTRL reg.\n", __func__);\r\nreturn ret;\r\n}\r\nfor (i = 0, dev_reg = chip->tsl2x7x_config;\r\ni < TSL2X7X_MAX_CONFIG_REG; i++) {\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2X7X_CMD_REG + i,\r\n*dev_reg++);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"failed on write to reg %d.\n", i);\r\nreturn ret;\r\n}\r\n}\r\nmdelay(3);\r\nutmp = TSL2X7X_CNTL_PWR_ON |\r\nTSL2X7X_CNTL_ADC_ENBL |\r\nTSL2X7X_CNTL_PROX_DET_ENBL;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2X7X_CMD_REG | TSL2X7X_CNTRL, utmp);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"%s: failed on 2nd CTRL reg.\n", __func__);\r\nreturn ret;\r\n}\r\nchip->tsl2x7x_chip_status = TSL2X7X_CHIP_WORKING;\r\nif (chip->tsl2x7x_settings.interrupts_en != 0) {\r\ndev_info(&chip->client->dev, "Setting Up Interrupt(s)\n");\r\nreg_val = TSL2X7X_CNTL_PWR_ON | TSL2X7X_CNTL_ADC_ENBL;\r\nif ((chip->tsl2x7x_settings.interrupts_en == 0x20) ||\r\n(chip->tsl2x7x_settings.interrupts_en == 0x30))\r\nreg_val |= TSL2X7X_CNTL_PROX_DET_ENBL;\r\nreg_val |= chip->tsl2x7x_settings.interrupts_en;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\n(TSL2X7X_CMD_REG |\r\nTSL2X7X_CNTRL), reg_val);\r\nif (ret < 0)\r\ndev_err(&chip->client->dev,\r\n"%s: failed in tsl2x7x_IOCTL_INT_SET.\n",\r\n__func__);\r\nret = i2c_smbus_write_byte(chip->client,\r\nTSL2X7X_CMD_REG |\r\nTSL2X7X_CMD_SPL_FN |\r\nTSL2X7X_CMD_PROXALS_INT_CLR);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"%s: Failed to clear Int status\n",\r\n__func__);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int tsl2x7x_chip_off(struct iio_dev *indio_dev)\r\n{\r\nint ret;\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nchip->tsl2x7x_chip_status = TSL2X7X_CHIP_SUSPENDED;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2X7X_CMD_REG | TSL2X7X_CNTRL, 0x00);\r\nif (chip->pdata && chip->pdata->power_off)\r\nchip->pdata->power_off(chip->client);\r\nreturn ret;\r\n}\r\nstatic\r\nint tsl2x7x_invoke_change(struct iio_dev *indio_dev)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nint device_status = chip->tsl2x7x_chip_status;\r\nmutex_lock(&chip->als_mutex);\r\nmutex_lock(&chip->prox_mutex);\r\nif (device_status == TSL2X7X_CHIP_WORKING)\r\ntsl2x7x_chip_off(indio_dev);\r\ntsl2x7x_chip_on(indio_dev);\r\nif (device_status != TSL2X7X_CHIP_WORKING)\r\ntsl2x7x_chip_off(indio_dev);\r\nmutex_unlock(&chip->prox_mutex);\r\nmutex_unlock(&chip->als_mutex);\r\nreturn 0;\r\n}\r\nstatic\r\nvoid tsl2x7x_prox_calculate(int *data, int length,\r\nstruct tsl2x7x_prox_stat *statP)\r\n{\r\nint i;\r\nint sample_sum;\r\nint tmp;\r\nif (!length)\r\nlength = 1;\r\nsample_sum = 0;\r\nstatP->min = INT_MAX;\r\nstatP->max = INT_MIN;\r\nfor (i = 0; i < length; i++) {\r\nsample_sum += data[i];\r\nstatP->min = min(statP->min, data[i]);\r\nstatP->max = max(statP->max, data[i]);\r\n}\r\nstatP->mean = sample_sum / length;\r\nsample_sum = 0;\r\nfor (i = 0; i < length; i++) {\r\ntmp = data[i] - statP->mean;\r\nsample_sum += tmp * tmp;\r\n}\r\nstatP->stddev = int_sqrt((long)sample_sum) / length;\r\n}\r\nstatic void tsl2x7x_prox_cal(struct iio_dev *indio_dev)\r\n{\r\nint prox_history[MAX_SAMPLES_CAL + 1];\r\nint i;\r\nstruct tsl2x7x_prox_stat prox_stat_data[2];\r\nstruct tsl2x7x_prox_stat *calP;\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nu8 tmp_irq_settings;\r\nu8 current_state = chip->tsl2x7x_chip_status;\r\nif (chip->tsl2x7x_settings.prox_max_samples_cal > MAX_SAMPLES_CAL) {\r\ndev_err(&chip->client->dev,\r\n"max prox samples cal is too big: %d\n",\r\nchip->tsl2x7x_settings.prox_max_samples_cal);\r\nchip->tsl2x7x_settings.prox_max_samples_cal = MAX_SAMPLES_CAL;\r\n}\r\ntsl2x7x_chip_off(indio_dev);\r\ntmp_irq_settings = chip->tsl2x7x_settings.interrupts_en;\r\nchip->tsl2x7x_settings.interrupts_en |= TSL2X7X_CNTL_PROX_INT_ENBL;\r\ntsl2x7x_chip_on(indio_dev);\r\nfor (i = 0; i < chip->tsl2x7x_settings.prox_max_samples_cal; i++) {\r\nmdelay(15);\r\ntsl2x7x_get_prox(indio_dev);\r\nprox_history[i] = chip->prox_data;\r\ndev_info(&chip->client->dev, "2 i=%d prox data= %d\n",\r\ni, chip->prox_data);\r\n}\r\ntsl2x7x_chip_off(indio_dev);\r\ncalP = &prox_stat_data[PROX_STAT_CAL];\r\ntsl2x7x_prox_calculate(prox_history,\r\nchip->tsl2x7x_settings.prox_max_samples_cal,\r\ncalP);\r\nchip->tsl2x7x_settings.prox_thres_high = (calP->max << 1) - calP->mean;\r\ndev_info(&chip->client->dev, " cal min=%d mean=%d max=%d\n",\r\ncalP->min, calP->mean, calP->max);\r\ndev_info(&chip->client->dev,\r\n"%s proximity threshold set to %d\n",\r\nchip->client->name, chip->tsl2x7x_settings.prox_thres_high);\r\nchip->tsl2x7x_settings.interrupts_en = tmp_irq_settings;\r\nif (current_state == TSL2X7X_CHIP_WORKING)\r\ntsl2x7x_chip_on(indio_dev);\r\n}\r\nstatic ssize_t tsl2x7x_power_state_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(dev_to_iio_dev(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", chip->tsl2x7x_chip_status);\r\n}\r\nstatic ssize_t tsl2x7x_power_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nbool value;\r\nif (strtobool(buf, &value))\r\nreturn -EINVAL;\r\nif (value)\r\ntsl2x7x_chip_on(indio_dev);\r\nelse\r\ntsl2x7x_chip_off(indio_dev);\r\nreturn len;\r\n}\r\nstatic ssize_t tsl2x7x_gain_available_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(dev_to_iio_dev(dev));\r\nswitch (chip->id) {\r\ncase tsl2571:\r\ncase tsl2671:\r\ncase tmd2671:\r\ncase tsl2771:\r\ncase tmd2771:\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", "1 8 16 128");\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", "1 8 16 120");\r\n}\r\nstatic ssize_t tsl2x7x_prox_gain_available_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", "1 2 4 8");\r\n}\r\nstatic ssize_t tsl2x7x_als_time_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(dev_to_iio_dev(dev));\r\nint y, z;\r\ny = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.als_time) + 1;\r\nz = y * TSL2X7X_MIN_ITIME;\r\ny /= 1000;\r\nz %= 1000;\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%03d\n", y, z);\r\n}\r\nstatic ssize_t tsl2x7x_als_time_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nstruct tsl2x7x_parse_result result;\r\nint ret;\r\nret = iio_str_to_fixpoint(buf, 100, &result.integer, &result.fract);\r\nif (ret)\r\nreturn ret;\r\nresult.fract /= 3;\r\nchip->tsl2x7x_settings.als_time =\r\nTSL2X7X_MAX_TIMER_CNT - (u8)result.fract;\r\ndev_info(&chip->client->dev, "%s: als time = %d",\r\n__func__, chip->tsl2x7x_settings.als_time);\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic ssize_t tsl2x7x_als_cal_target_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(dev_to_iio_dev(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nchip->tsl2x7x_settings.als_cal_target);\r\n}\r\nstatic ssize_t tsl2x7x_als_cal_target_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nunsigned long value;\r\nif (kstrtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif (value)\r\nchip->tsl2x7x_settings.als_cal_target = value;\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn len;\r\n}\r\nstatic ssize_t tsl2x7x_als_persistence_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(dev_to_iio_dev(dev));\r\nint y, z, filter_delay;\r\ny = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.als_time) + 1;\r\nz = y * TSL2X7X_MIN_ITIME;\r\nfilter_delay = z * (chip->tsl2x7x_settings.persistence & 0x0F);\r\ny = filter_delay / 1000;\r\nz = filter_delay % 1000;\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%03d\n", y, z);\r\n}\r\nstatic ssize_t tsl2x7x_als_persistence_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nstruct tsl2x7x_parse_result result;\r\nint y, z, filter_delay;\r\nint ret;\r\nret = iio_str_to_fixpoint(buf, 100, &result.integer, &result.fract);\r\nif (ret)\r\nreturn ret;\r\ny = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.als_time) + 1;\r\nz = y * TSL2X7X_MIN_ITIME;\r\nfilter_delay =\r\nDIV_ROUND_UP((result.integer * 1000) + result.fract, z);\r\nchip->tsl2x7x_settings.persistence &= 0xF0;\r\nchip->tsl2x7x_settings.persistence |= (filter_delay & 0x0F);\r\ndev_info(&chip->client->dev, "%s: als persistence = %d",\r\n__func__, filter_delay);\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic ssize_t tsl2x7x_prox_persistence_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(dev_to_iio_dev(dev));\r\nint y, z, filter_delay;\r\ny = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.prx_time) + 1;\r\nz = y * TSL2X7X_MIN_ITIME;\r\nfilter_delay = z * ((chip->tsl2x7x_settings.persistence & 0xF0) >> 4);\r\ny = filter_delay / 1000;\r\nz = filter_delay % 1000;\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%03d\n", y, z);\r\n}\r\nstatic ssize_t tsl2x7x_prox_persistence_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nstruct tsl2x7x_parse_result result;\r\nint y, z, filter_delay;\r\nint ret;\r\nret = iio_str_to_fixpoint(buf, 100, &result.integer, &result.fract);\r\nif (ret)\r\nreturn ret;\r\ny = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.prx_time) + 1;\r\nz = y * TSL2X7X_MIN_ITIME;\r\nfilter_delay =\r\nDIV_ROUND_UP((result.integer * 1000) + result.fract, z);\r\nchip->tsl2x7x_settings.persistence &= 0x0F;\r\nchip->tsl2x7x_settings.persistence |= ((filter_delay << 4) & 0xF0);\r\ndev_info(&chip->client->dev, "%s: prox persistence = %d",\r\n__func__, filter_delay);\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic ssize_t tsl2x7x_do_calibrate(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nbool value;\r\nif (strtobool(buf, &value))\r\nreturn -EINVAL;\r\nif (value)\r\ntsl2x7x_als_calibrate(indio_dev);\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn len;\r\n}\r\nstatic ssize_t tsl2x7x_luxtable_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(dev_to_iio_dev(dev));\r\nint i = 0;\r\nint offset = 0;\r\nwhile (i < (TSL2X7X_MAX_LUX_TABLE_SIZE * 3)) {\r\noffset += snprintf(buf + offset, PAGE_SIZE, "%u,%u,%u,",\r\nchip->tsl2x7x_device_lux[i].ratio,\r\nchip->tsl2x7x_device_lux[i].ch0,\r\nchip->tsl2x7x_device_lux[i].ch1);\r\nif (chip->tsl2x7x_device_lux[i].ratio == 0) {\r\noffset--;\r\nbreak;\r\n}\r\ni++;\r\n}\r\noffset += snprintf(buf + offset, PAGE_SIZE, "\n");\r\nreturn offset;\r\n}\r\nstatic ssize_t tsl2x7x_luxtable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nint value[ARRAY_SIZE(chip->tsl2x7x_device_lux) * 3 + 1];\r\nint n;\r\nget_options(buf, ARRAY_SIZE(value), value);\r\nn = value[0];\r\nif ((n % 3) || n < 6 ||\r\nn > ((ARRAY_SIZE(chip->tsl2x7x_device_lux) - 1) * 3)) {\r\ndev_info(dev, "LUX TABLE INPUT ERROR 1 Value[0]=%d\n", n);\r\nreturn -EINVAL;\r\n}\r\nif ((value[(n - 2)] | value[(n - 1)] | value[n]) != 0) {\r\ndev_info(dev, "LUX TABLE INPUT ERROR 2 Value[0]=%d\n", n);\r\nreturn -EINVAL;\r\n}\r\nif (chip->tsl2x7x_chip_status == TSL2X7X_CHIP_WORKING)\r\ntsl2x7x_chip_off(indio_dev);\r\nmemset(chip->tsl2x7x_device_lux, 0, sizeof(chip->tsl2x7x_device_lux));\r\nmemcpy(chip->tsl2x7x_device_lux, &value[1], (value[0] * 4));\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn len;\r\n}\r\nstatic ssize_t tsl2x7x_do_prox_calibrate(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nbool value;\r\nif (strtobool(buf, &value))\r\nreturn -EINVAL;\r\nif (value)\r\ntsl2x7x_prox_cal(indio_dev);\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn len;\r\n}\r\nstatic int tsl2x7x_read_interrupt_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nif (chan->type == IIO_INTENSITY)\r\nret = !!(chip->tsl2x7x_settings.interrupts_en & 0x10);\r\nelse\r\nret = !!(chip->tsl2x7x_settings.interrupts_en & 0x20);\r\nreturn ret;\r\n}\r\nstatic int tsl2x7x_write_interrupt_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint val)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nif (chan->type == IIO_INTENSITY) {\r\nif (val)\r\nchip->tsl2x7x_settings.interrupts_en |= 0x10;\r\nelse\r\nchip->tsl2x7x_settings.interrupts_en &= 0x20;\r\n} else {\r\nif (val)\r\nchip->tsl2x7x_settings.interrupts_en |= 0x20;\r\nelse\r\nchip->tsl2x7x_settings.interrupts_en &= 0x10;\r\n}\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn 0;\r\n}\r\nstatic int tsl2x7x_write_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nif (chan->type == IIO_INTENSITY) {\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nchip->tsl2x7x_settings.als_thresh_high = val;\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\nchip->tsl2x7x_settings.als_thresh_low = val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nchip->tsl2x7x_settings.prox_thres_high = val;\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\nchip->tsl2x7x_settings.prox_thres_low = val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn 0;\r\n}\r\nstatic int tsl2x7x_read_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nif (chan->type == IIO_INTENSITY) {\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\n*val = chip->tsl2x7x_settings.als_thresh_high;\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\n*val = chip->tsl2x7x_settings.als_thresh_low;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\n*val = chip->tsl2x7x_settings.prox_thres_high;\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\n*val = chip->tsl2x7x_settings.prox_thres_low;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int tsl2x7x_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nint ret = -EINVAL;\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\ntsl2x7x_get_lux(indio_dev);\r\n*val = chip->als_cur_info.lux;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\ntsl2x7x_get_lux(indio_dev);\r\nif (chan->channel == 0)\r\n*val = chip->als_cur_info.als_ch0;\r\nelse\r\n*val = chip->als_cur_info.als_ch1;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_PROXIMITY:\r\ntsl2x7x_get_prox(indio_dev);\r\n*val = chip->prox_data;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (chan->type == IIO_LIGHT)\r\n*val =\r\ntsl2X7X_als_gainadj[chip->tsl2x7x_settings.als_gain];\r\nelse\r\n*val =\r\ntsl2X7X_prx_gainadj[chip->tsl2x7x_settings.prox_gain];\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\n*val = chip->tsl2x7x_settings.als_gain_trim;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tsl2x7x_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (chan->type == IIO_INTENSITY) {\r\nswitch (val) {\r\ncase 1:\r\nchip->tsl2x7x_settings.als_gain = 0;\r\nbreak;\r\ncase 8:\r\nchip->tsl2x7x_settings.als_gain = 1;\r\nbreak;\r\ncase 16:\r\nchip->tsl2x7x_settings.als_gain = 2;\r\nbreak;\r\ncase 120:\r\nswitch (chip->id) {\r\ncase tsl2572:\r\ncase tsl2672:\r\ncase tmd2672:\r\ncase tsl2772:\r\ncase tmd2772:\r\nreturn -EINVAL;\r\n}\r\nchip->tsl2x7x_settings.als_gain = 3;\r\nbreak;\r\ncase 128:\r\nswitch (chip->id) {\r\ncase tsl2571:\r\ncase tsl2671:\r\ncase tmd2671:\r\ncase tsl2771:\r\ncase tmd2771:\r\nreturn -EINVAL;\r\n}\r\nchip->tsl2x7x_settings.als_gain = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nswitch (val) {\r\ncase 1:\r\nchip->tsl2x7x_settings.prox_gain = 0;\r\nbreak;\r\ncase 2:\r\nchip->tsl2x7x_settings.prox_gain = 1;\r\nbreak;\r\ncase 4:\r\nchip->tsl2x7x_settings.prox_gain = 2;\r\nbreak;\r\ncase 8:\r\nchip->tsl2x7x_settings.prox_gain = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nchip->tsl2x7x_settings.als_gain_trim = val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntsl2x7x_invoke_change(indio_dev);\r\nreturn 0;\r\n}\r\nstatic int tsl2x7x_device_id(unsigned char *id, int target)\r\n{\r\nswitch (target) {\r\ncase tsl2571:\r\ncase tsl2671:\r\ncase tsl2771:\r\nreturn (*id & 0xf0) == TRITON_ID;\r\ncase tmd2671:\r\ncase tmd2771:\r\nreturn (*id & 0xf0) == HALIBUT_ID;\r\ncase tsl2572:\r\ncase tsl2672:\r\ncase tmd2672:\r\ncase tsl2772:\r\ncase tmd2772:\r\nreturn (*id & 0xf0) == SWORDFISH_ID;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t tsl2x7x_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\ns64 timestamp = iio_get_time_ns(indio_dev);\r\nint ret;\r\nu8 value;\r\nvalue = i2c_smbus_read_byte_data(chip->client,\r\nTSL2X7X_CMD_REG | TSL2X7X_STATUS);\r\nif (value & TSL2X7X_STA_PRX_INTR) {\r\ntsl2x7x_get_prox(indio_dev);\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_PROXIMITY,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_EITHER),\r\ntimestamp);\r\n}\r\nif (value & TSL2X7X_STA_ALS_INTR) {\r\ntsl2x7x_get_lux(indio_dev);\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_LIGHT,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_EITHER),\r\ntimestamp);\r\n}\r\nret = i2c_smbus_write_byte(chip->client,\r\nTSL2X7X_CMD_REG | TSL2X7X_CMD_SPL_FN |\r\nTSL2X7X_CMD_PROXALS_INT_CLR);\r\nif (ret < 0)\r\ndev_err(&chip->client->dev,\r\n"Failed to clear irq from event handler. err = %d\n",\r\nret);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tsl2x7x_probe(struct i2c_client *clientp,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nunsigned char device_id;\r\nstruct iio_dev *indio_dev;\r\nstruct tsl2X7X_chip *chip;\r\nindio_dev = devm_iio_device_alloc(&clientp->dev, sizeof(*chip));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nchip = iio_priv(indio_dev);\r\nchip->client = clientp;\r\ni2c_set_clientdata(clientp, indio_dev);\r\nret = tsl2x7x_i2c_read(chip->client,\r\nTSL2X7X_CHIPID, &device_id);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((!tsl2x7x_device_id(&device_id, id->driver_data)) ||\r\n(tsl2x7x_device_id(&device_id, id->driver_data) == -EINVAL)) {\r\ndev_info(&chip->client->dev,\r\n"%s: i2c device found does not match expected id\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nret = i2c_smbus_write_byte(clientp, (TSL2X7X_CMD_REG | TSL2X7X_CNTRL));\r\nif (ret < 0) {\r\ndev_err(&clientp->dev, "write to cmd reg failed. err = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nmutex_init(&chip->als_mutex);\r\nmutex_init(&chip->prox_mutex);\r\nchip->tsl2x7x_chip_status = TSL2X7X_CHIP_UNKNOWN;\r\nchip->pdata = dev_get_platdata(&clientp->dev);\r\nchip->id = id->driver_data;\r\nchip->chip_info =\r\n&tsl2x7x_chip_info_tbl[device_channel_config[id->driver_data]];\r\nindio_dev->info = chip->chip_info->info;\r\nindio_dev->dev.parent = &clientp->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = chip->client->name;\r\nindio_dev->channels = chip->chip_info->channel;\r\nindio_dev->num_channels = chip->chip_info->chan_table_elements;\r\nif (clientp->irq) {\r\nret = devm_request_threaded_irq(&clientp->dev, clientp->irq,\r\nNULL,\r\n&tsl2x7x_event_handler,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_ONESHOT,\r\n"TSL2X7X_event",\r\nindio_dev);\r\nif (ret) {\r\ndev_err(&clientp->dev,\r\n"%s: irq request failed", __func__);\r\nreturn ret;\r\n}\r\n}\r\ntsl2x7x_defaults(chip);\r\ntsl2x7x_chip_on(indio_dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&clientp->dev,\r\n"%s: iio registration failed\n", __func__);\r\nreturn ret;\r\n}\r\ndev_info(&clientp->dev, "%s Light sensor found.\n", id->name);\r\nreturn 0;\r\n}\r\nstatic int tsl2x7x_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nint ret = 0;\r\nif (chip->tsl2x7x_chip_status == TSL2X7X_CHIP_WORKING) {\r\nret = tsl2x7x_chip_off(indio_dev);\r\nchip->tsl2x7x_chip_status = TSL2X7X_CHIP_SUSPENDED;\r\n}\r\nif (chip->pdata && chip->pdata->platform_power) {\r\npm_message_t pmm = {PM_EVENT_SUSPEND};\r\nchip->pdata->platform_power(dev, pmm);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tsl2x7x_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct tsl2X7X_chip *chip = iio_priv(indio_dev);\r\nint ret = 0;\r\nif (chip->pdata && chip->pdata->platform_power) {\r\npm_message_t pmm = {PM_EVENT_RESUME};\r\nchip->pdata->platform_power(dev, pmm);\r\n}\r\nif (chip->tsl2x7x_chip_status == TSL2X7X_CHIP_SUSPENDED)\r\nret = tsl2x7x_chip_on(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int tsl2x7x_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\ntsl2x7x_chip_off(indio_dev);\r\niio_device_unregister(indio_dev);\r\nreturn 0;\r\n}
