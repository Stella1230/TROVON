static int ibmvtpm_send_crq(struct vio_dev *vdev, u64 w1, u64 w2)\r\n{\r\nreturn plpar_hcall_norets(H_SEND_CRQ, vdev->unit_address, w1, w2);\r\n}\r\nstatic int tpm_ibmvtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\r\nu16 len;\r\nint sig;\r\nif (!ibmvtpm->rtce_buf) {\r\ndev_err(ibmvtpm->dev, "ibmvtpm device is not ready\n");\r\nreturn 0;\r\n}\r\nsig = wait_event_interruptible(ibmvtpm->wq, !ibmvtpm->tpm_processing_cmd);\r\nif (sig)\r\nreturn -EINTR;\r\nlen = ibmvtpm->res_len;\r\nif (count < len) {\r\ndev_err(ibmvtpm->dev,\r\n"Invalid size in recv: count=%zd, crq_size=%d\n",\r\ncount, len);\r\nreturn -EIO;\r\n}\r\nspin_lock(&ibmvtpm->rtce_lock);\r\nmemcpy((void *)buf, (void *)ibmvtpm->rtce_buf, len);\r\nmemset(ibmvtpm->rtce_buf, 0, len);\r\nibmvtpm->res_len = 0;\r\nspin_unlock(&ibmvtpm->rtce_lock);\r\nreturn len;\r\n}\r\nstatic int tpm_ibmvtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\r\nstruct ibmvtpm_crq crq;\r\n__be64 *word = (__be64 *)&crq;\r\nint rc, sig;\r\nif (!ibmvtpm->rtce_buf) {\r\ndev_err(ibmvtpm->dev, "ibmvtpm device is not ready\n");\r\nreturn 0;\r\n}\r\nif (count > ibmvtpm->rtce_size) {\r\ndev_err(ibmvtpm->dev,\r\n"Invalid size in send: count=%zd, rtce_size=%d\n",\r\ncount, ibmvtpm->rtce_size);\r\nreturn -EIO;\r\n}\r\nif (ibmvtpm->tpm_processing_cmd) {\r\ndev_info(ibmvtpm->dev,\r\n"Need to wait for TPM to finish\n");\r\nsig = wait_event_interruptible(ibmvtpm->wq, !ibmvtpm->tpm_processing_cmd);\r\nif (sig)\r\nreturn -EINTR;\r\n}\r\nspin_lock(&ibmvtpm->rtce_lock);\r\nibmvtpm->res_len = 0;\r\nmemcpy((void *)ibmvtpm->rtce_buf, (void *)buf, count);\r\ncrq.valid = (u8)IBMVTPM_VALID_CMD;\r\ncrq.msg = (u8)VTPM_TPM_COMMAND;\r\ncrq.len = cpu_to_be16(count);\r\ncrq.data = cpu_to_be32(ibmvtpm->rtce_dma_handle);\r\nibmvtpm->tpm_processing_cmd = true;\r\nrc = ibmvtpm_send_crq(ibmvtpm->vdev, be64_to_cpu(word[0]),\r\nbe64_to_cpu(word[1]));\r\nif (rc != H_SUCCESS) {\r\ndev_err(ibmvtpm->dev, "tpm_ibmvtpm_send failed rc=%d\n", rc);\r\nrc = 0;\r\nibmvtpm->tpm_processing_cmd = false;\r\n} else\r\nrc = count;\r\nspin_unlock(&ibmvtpm->rtce_lock);\r\nreturn rc;\r\n}\r\nstatic void tpm_ibmvtpm_cancel(struct tpm_chip *chip)\r\n{\r\nreturn;\r\n}\r\nstatic u8 tpm_ibmvtpm_status(struct tpm_chip *chip)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ibmvtpm_crq_get_rtce_size(struct ibmvtpm_dev *ibmvtpm)\r\n{\r\nstruct ibmvtpm_crq crq;\r\nu64 *buf = (u64 *) &crq;\r\nint rc;\r\ncrq.valid = (u8)IBMVTPM_VALID_CMD;\r\ncrq.msg = (u8)VTPM_GET_RTCE_BUFFER_SIZE;\r\nrc = ibmvtpm_send_crq(ibmvtpm->vdev, cpu_to_be64(buf[0]),\r\ncpu_to_be64(buf[1]));\r\nif (rc != H_SUCCESS)\r\ndev_err(ibmvtpm->dev,\r\n"ibmvtpm_crq_get_rtce_size failed rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int ibmvtpm_crq_get_version(struct ibmvtpm_dev *ibmvtpm)\r\n{\r\nstruct ibmvtpm_crq crq;\r\nu64 *buf = (u64 *) &crq;\r\nint rc;\r\ncrq.valid = (u8)IBMVTPM_VALID_CMD;\r\ncrq.msg = (u8)VTPM_GET_VERSION;\r\nrc = ibmvtpm_send_crq(ibmvtpm->vdev, cpu_to_be64(buf[0]),\r\ncpu_to_be64(buf[1]));\r\nif (rc != H_SUCCESS)\r\ndev_err(ibmvtpm->dev,\r\n"ibmvtpm_crq_get_version failed rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int ibmvtpm_crq_send_init_complete(struct ibmvtpm_dev *ibmvtpm)\r\n{\r\nint rc;\r\nrc = ibmvtpm_send_crq(ibmvtpm->vdev, INIT_CRQ_COMP_CMD, 0);\r\nif (rc != H_SUCCESS)\r\ndev_err(ibmvtpm->dev,\r\n"ibmvtpm_crq_send_init_complete failed rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int ibmvtpm_crq_send_init(struct ibmvtpm_dev *ibmvtpm)\r\n{\r\nint rc;\r\nrc = ibmvtpm_send_crq(ibmvtpm->vdev, INIT_CRQ_CMD, 0);\r\nif (rc != H_SUCCESS)\r\ndev_err(ibmvtpm->dev,\r\n"ibmvtpm_crq_send_init failed rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int tpm_ibmvtpm_remove(struct vio_dev *vdev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&vdev->dev);\r\nstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\r\nint rc = 0;\r\ntpm_chip_unregister(chip);\r\nfree_irq(vdev->irq, ibmvtpm);\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\r\n} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\r\ndma_unmap_single(ibmvtpm->dev, ibmvtpm->crq_dma_handle,\r\nCRQ_RES_BUF_SIZE, DMA_BIDIRECTIONAL);\r\nfree_page((unsigned long)ibmvtpm->crq_queue.crq_addr);\r\nif (ibmvtpm->rtce_buf) {\r\ndma_unmap_single(ibmvtpm->dev, ibmvtpm->rtce_dma_handle,\r\nibmvtpm->rtce_size, DMA_BIDIRECTIONAL);\r\nkfree(ibmvtpm->rtce_buf);\r\n}\r\nkfree(ibmvtpm);\r\nreturn 0;\r\n}\r\nstatic unsigned long tpm_ibmvtpm_get_desired_dma(struct vio_dev *vdev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&vdev->dev);\r\nstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\r\nif (!ibmvtpm)\r\nreturn CRQ_RES_BUF_SIZE + PAGE_SIZE;\r\nreturn CRQ_RES_BUF_SIZE + ibmvtpm->rtce_size;\r\n}\r\nstatic int tpm_ibmvtpm_suspend(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\r\nstruct ibmvtpm_crq crq;\r\nu64 *buf = (u64 *) &crq;\r\nint rc = 0;\r\ncrq.valid = (u8)IBMVTPM_VALID_CMD;\r\ncrq.msg = (u8)VTPM_PREPARE_TO_SUSPEND;\r\nrc = ibmvtpm_send_crq(ibmvtpm->vdev, cpu_to_be64(buf[0]),\r\ncpu_to_be64(buf[1]));\r\nif (rc != H_SUCCESS)\r\ndev_err(ibmvtpm->dev,\r\n"tpm_ibmvtpm_suspend failed rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int ibmvtpm_reset_crq(struct ibmvtpm_dev *ibmvtpm)\r\n{\r\nint rc = 0;\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_FREE_CRQ,\r\nibmvtpm->vdev->unit_address);\r\n} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\r\nmemset(ibmvtpm->crq_queue.crq_addr, 0, CRQ_RES_BUF_SIZE);\r\nibmvtpm->crq_queue.index = 0;\r\nreturn plpar_hcall_norets(H_REG_CRQ, ibmvtpm->vdev->unit_address,\r\nibmvtpm->crq_dma_handle, CRQ_RES_BUF_SIZE);\r\n}\r\nstatic int tpm_ibmvtpm_resume(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\r\nint rc = 0;\r\ndo {\r\nif (rc)\r\nmsleep(100);\r\nrc = plpar_hcall_norets(H_ENABLE_CRQ,\r\nibmvtpm->vdev->unit_address);\r\n} while (rc == H_IN_PROGRESS || rc == H_BUSY || H_IS_LONG_BUSY(rc));\r\nif (rc) {\r\ndev_err(dev, "Error enabling ibmvtpm rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nrc = vio_enable_interrupts(ibmvtpm->vdev);\r\nif (rc) {\r\ndev_err(dev, "Error vio_enable_interrupts rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nrc = ibmvtpm_crq_send_init(ibmvtpm);\r\nif (rc)\r\ndev_err(dev, "Error send_init rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic bool tpm_ibmvtpm_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nreturn (status == 0);\r\n}\r\nstatic struct ibmvtpm_crq *ibmvtpm_crq_get_next(struct ibmvtpm_dev *ibmvtpm)\r\n{\r\nstruct ibmvtpm_crq_queue *crq_q = &ibmvtpm->crq_queue;\r\nstruct ibmvtpm_crq *crq = &crq_q->crq_addr[crq_q->index];\r\nif (crq->valid & VTPM_MSG_RES) {\r\nif (++crq_q->index == crq_q->num_entry)\r\ncrq_q->index = 0;\r\nsmp_rmb();\r\n} else\r\ncrq = NULL;\r\nreturn crq;\r\n}\r\nstatic void ibmvtpm_crq_process(struct ibmvtpm_crq *crq,\r\nstruct ibmvtpm_dev *ibmvtpm)\r\n{\r\nint rc = 0;\r\nswitch (crq->valid) {\r\ncase VALID_INIT_CRQ:\r\nswitch (crq->msg) {\r\ncase INIT_CRQ_RES:\r\ndev_info(ibmvtpm->dev, "CRQ initialized\n");\r\nrc = ibmvtpm_crq_send_init_complete(ibmvtpm);\r\nif (rc)\r\ndev_err(ibmvtpm->dev, "Unable to send CRQ init complete rc=%d\n", rc);\r\nreturn;\r\ncase INIT_CRQ_COMP_RES:\r\ndev_info(ibmvtpm->dev,\r\n"CRQ initialization completed\n");\r\nreturn;\r\ndefault:\r\ndev_err(ibmvtpm->dev, "Unknown crq message type: %d\n", crq->msg);\r\nreturn;\r\n}\r\ncase IBMVTPM_VALID_CMD:\r\nswitch (crq->msg) {\r\ncase VTPM_GET_RTCE_BUFFER_SIZE_RES:\r\nif (be16_to_cpu(crq->len) <= 0) {\r\ndev_err(ibmvtpm->dev, "Invalid rtce size\n");\r\nreturn;\r\n}\r\nibmvtpm->rtce_size = be16_to_cpu(crq->len);\r\nibmvtpm->rtce_buf = kmalloc(ibmvtpm->rtce_size,\r\nGFP_ATOMIC);\r\nif (!ibmvtpm->rtce_buf) {\r\ndev_err(ibmvtpm->dev, "Failed to allocate memory for rtce buffer\n");\r\nreturn;\r\n}\r\nibmvtpm->rtce_dma_handle = dma_map_single(ibmvtpm->dev,\r\nibmvtpm->rtce_buf, ibmvtpm->rtce_size,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(ibmvtpm->dev,\r\nibmvtpm->rtce_dma_handle)) {\r\nkfree(ibmvtpm->rtce_buf);\r\nibmvtpm->rtce_buf = NULL;\r\ndev_err(ibmvtpm->dev, "Failed to dma map rtce buffer\n");\r\n}\r\nreturn;\r\ncase VTPM_GET_VERSION_RES:\r\nibmvtpm->vtpm_version = be32_to_cpu(crq->data);\r\nreturn;\r\ncase VTPM_TPM_COMMAND_RES:\r\nibmvtpm->res_len = be16_to_cpu(crq->len);\r\nibmvtpm->tpm_processing_cmd = false;\r\nwake_up_interruptible(&ibmvtpm->wq);\r\nreturn;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic irqreturn_t ibmvtpm_interrupt(int irq, void *vtpm_instance)\r\n{\r\nstruct ibmvtpm_dev *ibmvtpm = (struct ibmvtpm_dev *) vtpm_instance;\r\nstruct ibmvtpm_crq *crq;\r\nwhile ((crq = ibmvtpm_crq_get_next(ibmvtpm)) != NULL) {\r\nibmvtpm_crq_process(crq, ibmvtpm);\r\ncrq->valid = 0;\r\nsmp_wmb();\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,\r\nconst struct vio_device_id *id)\r\n{\r\nstruct ibmvtpm_dev *ibmvtpm;\r\nstruct device *dev = &vio_dev->dev;\r\nstruct ibmvtpm_crq_queue *crq_q;\r\nstruct tpm_chip *chip;\r\nint rc = -ENOMEM, rc1;\r\nchip = tpmm_chip_alloc(dev, &tpm_ibmvtpm);\r\nif (IS_ERR(chip))\r\nreturn PTR_ERR(chip);\r\nibmvtpm = kzalloc(sizeof(struct ibmvtpm_dev), GFP_KERNEL);\r\nif (!ibmvtpm) {\r\ndev_err(dev, "kzalloc for ibmvtpm failed\n");\r\ngoto cleanup;\r\n}\r\nibmvtpm->dev = dev;\r\nibmvtpm->vdev = vio_dev;\r\ncrq_q = &ibmvtpm->crq_queue;\r\ncrq_q->crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);\r\nif (!crq_q->crq_addr) {\r\ndev_err(dev, "Unable to allocate memory for crq_addr\n");\r\ngoto cleanup;\r\n}\r\ncrq_q->num_entry = CRQ_RES_BUF_SIZE / sizeof(*crq_q->crq_addr);\r\nibmvtpm->crq_dma_handle = dma_map_single(dev, crq_q->crq_addr,\r\nCRQ_RES_BUF_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(dev, ibmvtpm->crq_dma_handle)) {\r\ndev_err(dev, "dma mapping failed\n");\r\ngoto cleanup;\r\n}\r\nrc = plpar_hcall_norets(H_REG_CRQ, vio_dev->unit_address,\r\nibmvtpm->crq_dma_handle, CRQ_RES_BUF_SIZE);\r\nif (rc == H_RESOURCE)\r\nrc = ibmvtpm_reset_crq(ibmvtpm);\r\nif (rc) {\r\ndev_err(dev, "Unable to register CRQ rc=%d\n", rc);\r\ngoto reg_crq_cleanup;\r\n}\r\nrc = request_irq(vio_dev->irq, ibmvtpm_interrupt, 0,\r\ntpm_ibmvtpm_driver_name, ibmvtpm);\r\nif (rc) {\r\ndev_err(dev, "Error %d register irq 0x%x\n", rc, vio_dev->irq);\r\ngoto init_irq_cleanup;\r\n}\r\nrc = vio_enable_interrupts(vio_dev);\r\nif (rc) {\r\ndev_err(dev, "Error %d enabling interrupts\n", rc);\r\ngoto init_irq_cleanup;\r\n}\r\ninit_waitqueue_head(&ibmvtpm->wq);\r\ncrq_q->index = 0;\r\ndev_set_drvdata(&chip->dev, ibmvtpm);\r\nspin_lock_init(&ibmvtpm->rtce_lock);\r\nrc = ibmvtpm_crq_send_init(ibmvtpm);\r\nif (rc)\r\ngoto init_irq_cleanup;\r\nrc = ibmvtpm_crq_get_version(ibmvtpm);\r\nif (rc)\r\ngoto init_irq_cleanup;\r\nrc = ibmvtpm_crq_get_rtce_size(ibmvtpm);\r\nif (rc)\r\ngoto init_irq_cleanup;\r\nreturn tpm_chip_register(chip);\r\ninit_irq_cleanup:\r\ndo {\r\nrc1 = plpar_hcall_norets(H_FREE_CRQ, vio_dev->unit_address);\r\n} while (rc1 == H_BUSY || H_IS_LONG_BUSY(rc1));\r\nreg_crq_cleanup:\r\ndma_unmap_single(dev, ibmvtpm->crq_dma_handle, CRQ_RES_BUF_SIZE,\r\nDMA_BIDIRECTIONAL);\r\ncleanup:\r\nif (ibmvtpm) {\r\nif (crq_q->crq_addr)\r\nfree_page((unsigned long)crq_q->crq_addr);\r\nkfree(ibmvtpm);\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init ibmvtpm_module_init(void)\r\n{\r\nreturn vio_register_driver(&ibmvtpm_driver);\r\n}\r\nstatic void __exit ibmvtpm_module_exit(void)\r\n{\r\nvio_unregister_driver(&ibmvtpm_driver);\r\n}
