static void sdhci_sirf_set_bus_width(struct sdhci_host *host, int width)\r\n{\r\nu8 ctrl;\r\nctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\r\nctrl &= ~(SDHCI_CTRL_4BITBUS | SDHCI_SIRF_8BITBUS);\r\nif (width == MMC_BUS_WIDTH_8)\r\nctrl |= SDHCI_SIRF_8BITBUS;\r\nelse if (width == MMC_BUS_WIDTH_4)\r\nctrl |= SDHCI_CTRL_4BITBUS;\r\nsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\r\n}\r\nstatic u32 sdhci_sirf_readl_le(struct sdhci_host *host, int reg)\r\n{\r\nu32 val = readl(host->ioaddr + reg);\r\nif (unlikely((reg == SDHCI_CAPABILITIES_1) &&\r\n(host->mmc->caps & MMC_CAP_UHS_SDR50))) {\r\nval = SDHCI_SUPPORT_DDR50 |\r\nSDHCI_SUPPORT_SDR50 | SDHCI_USE_SDR50_TUNING;\r\n}\r\nif (unlikely(reg == SDHCI_SLOT_INT_STATUS)) {\r\nu32 prss = val;\r\nprss &= ~(0xFF << 16);\r\nval = prss | (SDHCI_SPEC_300 << 16);\r\n}\r\nreturn val;\r\n}\r\nstatic u16 sdhci_sirf_readw_le(struct sdhci_host *host, int reg)\r\n{\r\nu16 ret = 0;\r\nret = readw(host->ioaddr + reg);\r\nif (unlikely(reg == SDHCI_HOST_VERSION)) {\r\nret = readw(host->ioaddr + SDHCI_HOST_VERSION);\r\nret |= SDHCI_SPEC_300;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sdhci_sirf_execute_tuning(struct sdhci_host *host, u32 opcode)\r\n{\r\nint tuning_seq_cnt = 3;\r\nint phase;\r\nu8 tuned_phase_cnt = 0;\r\nint rc = 0, longest_range = 0;\r\nint start = -1, end = 0, tuning_value = -1, range = 0;\r\nu16 clock_setting;\r\nstruct mmc_host *mmc = host->mmc;\r\nclock_setting = sdhci_readw(host, SDHCI_CLK_DELAY_SETTING);\r\nclock_setting &= ~0x3fff;\r\nretry:\r\nphase = 0;\r\ntuned_phase_cnt = 0;\r\ndo {\r\nsdhci_writel(host,\r\nclock_setting | phase,\r\nSDHCI_CLK_DELAY_SETTING);\r\nif (!mmc_send_tuning(mmc, opcode, NULL)) {\r\ntuned_phase_cnt++;\r\ndev_dbg(mmc_dev(mmc), "%s: Found good phase = %d\n",\r\nmmc_hostname(mmc), phase);\r\nif (start == -1)\r\nstart = phase;\r\nend = phase;\r\nrange++;\r\nif (phase == (SIRF_TUNING_COUNT - 1)\r\n&& range > longest_range)\r\ntuning_value = (start + end) / 2;\r\n} else {\r\ndev_dbg(mmc_dev(mmc), "%s: Found bad phase = %d\n",\r\nmmc_hostname(mmc), phase);\r\nif (range > longest_range) {\r\ntuning_value = (start + end) / 2;\r\nlongest_range = range;\r\n}\r\nstart = -1;\r\nend = range = 0;\r\n}\r\n} while (++phase < SIRF_TUNING_COUNT);\r\nif (tuned_phase_cnt && tuning_value > 0) {\r\nphase = tuning_value;\r\nsdhci_writel(host,\r\nclock_setting | phase,\r\nSDHCI_CLK_DELAY_SETTING);\r\ndev_dbg(mmc_dev(mmc), "%s: Setting the tuning phase to %d\n",\r\nmmc_hostname(mmc), phase);\r\n} else {\r\nif (--tuning_seq_cnt)\r\ngoto retry;\r\ndev_dbg(mmc_dev(mmc), "%s: No tuning point found\n",\r\nmmc_hostname(mmc));\r\nrc = -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic int sdhci_sirf_probe(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host;\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_sirf_priv *priv;\r\nstruct clk *clk;\r\nint gpio_cd;\r\nint ret;\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "unable to get clock");\r\nreturn PTR_ERR(clk);\r\n}\r\nif (pdev->dev.of_node)\r\ngpio_cd = of_get_named_gpio(pdev->dev.of_node, "cd-gpios", 0);\r\nelse\r\ngpio_cd = -EINVAL;\r\nhost = sdhci_pltfm_init(pdev, &sdhci_sirf_pdata, sizeof(struct sdhci_sirf_priv));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\npltfm_host->clk = clk;\r\npriv = sdhci_pltfm_priv(pltfm_host);\r\npriv->gpio_cd = gpio_cd;\r\nsdhci_get_of_property(pdev);\r\nret = clk_prepare_enable(pltfm_host->clk);\r\nif (ret)\r\ngoto err_clk_prepare;\r\nret = sdhci_add_host(host);\r\nif (ret)\r\ngoto err_sdhci_add;\r\nif (gpio_is_valid(priv->gpio_cd)) {\r\nret = mmc_gpio_request_cd(host->mmc, priv->gpio_cd, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "card detect irq request failed: %d\n",\r\nret);\r\ngoto err_request_cd;\r\n}\r\nmmc_gpiod_request_cd_irq(host->mmc);\r\n}\r\nreturn 0;\r\nerr_request_cd:\r\nsdhci_remove_host(host, 0);\r\nerr_sdhci_add:\r\nclk_disable_unprepare(pltfm_host->clk);\r\nerr_clk_prepare:\r\nsdhci_pltfm_free(pdev);\r\nreturn ret;\r\n}\r\nstatic int sdhci_sirf_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nint ret;\r\nret = sdhci_suspend_host(host);\r\nif (ret)\r\nreturn ret;\r\nclk_disable(pltfm_host->clk);\r\nreturn 0;\r\n}\r\nstatic int sdhci_sirf_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nint ret;\r\nret = clk_enable(pltfm_host->clk);\r\nif (ret) {\r\ndev_dbg(dev, "Resume: Error enabling clock\n");\r\nreturn ret;\r\n}\r\nreturn sdhci_resume_host(host);\r\n}
