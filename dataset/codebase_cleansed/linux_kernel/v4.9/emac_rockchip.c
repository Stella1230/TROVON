static void emac_rockchip_set_mac_speed(void *priv, unsigned int speed)\r\n{\r\nstruct rockchip_priv_data *emac = priv;\r\nu32 speed_offset = emac->soc_data->grf_speed_offset;\r\nu32 data;\r\nint err = 0;\r\nswitch (speed) {\r\ncase 10:\r\ndata = (1 << (speed_offset + 16)) | (0 << speed_offset);\r\nbreak;\r\ncase 100:\r\ndata = (1 << (speed_offset + 16)) | (1 << speed_offset);\r\nbreak;\r\ndefault:\r\npr_err("speed %u not supported\n", speed);\r\nreturn;\r\n}\r\nerr = regmap_write(emac->grf, emac->soc_data->grf_offset, data);\r\nif (err)\r\npr_err("unable to apply speed %u to grf (%d)\n", speed, err);\r\n}\r\nstatic int emac_rockchip_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct net_device *ndev;\r\nstruct rockchip_priv_data *priv;\r\nconst struct of_device_id *match;\r\nu32 data;\r\nint err, interface;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nndev = alloc_etherdev(sizeof(struct rockchip_priv_data));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ndev);\r\nSET_NETDEV_DEV(ndev, dev);\r\npriv = netdev_priv(ndev);\r\npriv->emac.drv_name = DRV_NAME;\r\npriv->emac.drv_version = DRV_VERSION;\r\npriv->emac.set_mac_speed = emac_rockchip_set_mac_speed;\r\ninterface = of_get_phy_mode(dev->of_node);\r\nif (interface != PHY_INTERFACE_MODE_RMII) {\r\ndev_err(dev, "unsupported phy interface mode %d\n", interface);\r\nerr = -ENOTSUPP;\r\ngoto out_netdev;\r\n}\r\npriv->grf = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"rockchip,grf");\r\nif (IS_ERR(priv->grf)) {\r\ndev_err(dev, "failed to retrieve global register file (%ld)\n",\r\nPTR_ERR(priv->grf));\r\nerr = PTR_ERR(priv->grf);\r\ngoto out_netdev;\r\n}\r\nmatch = of_match_node(emac_rockchip_dt_ids, dev->of_node);\r\npriv->soc_data = match->data;\r\npriv->emac.clk = devm_clk_get(dev, "hclk");\r\nif (IS_ERR(priv->emac.clk)) {\r\ndev_err(dev, "failed to retrieve host clock (%ld)\n",\r\nPTR_ERR(priv->emac.clk));\r\nerr = PTR_ERR(priv->emac.clk);\r\ngoto out_netdev;\r\n}\r\npriv->refclk = devm_clk_get(dev, "macref");\r\nif (IS_ERR(priv->refclk)) {\r\ndev_err(dev, "failed to retrieve reference clock (%ld)\n",\r\nPTR_ERR(priv->refclk));\r\nerr = PTR_ERR(priv->refclk);\r\ngoto out_netdev;\r\n}\r\nerr = clk_prepare_enable(priv->refclk);\r\nif (err) {\r\ndev_err(dev, "failed to enable reference clock (%d)\n", err);\r\ngoto out_netdev;\r\n}\r\npriv->regulator = devm_regulator_get_optional(dev, "phy");\r\nif (IS_ERR(priv->regulator)) {\r\nif (PTR_ERR(priv->regulator) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_err(dev, "no regulator found\n");\r\npriv->regulator = NULL;\r\n}\r\nif (priv->regulator) {\r\nerr = regulator_enable(priv->regulator);\r\nif (err) {\r\ndev_err(dev, "failed to enable phy-supply (%d)\n", err);\r\ngoto out_clk_disable;\r\n}\r\n}\r\ndata = (1 << (priv->soc_data->grf_speed_offset + 16)) |\r\n(1 << priv->soc_data->grf_speed_offset);\r\ndata |= (1 << (priv->soc_data->grf_mode_offset + 16)) |\r\n(0 << priv->soc_data->grf_mode_offset);\r\nerr = regmap_write(priv->grf, priv->soc_data->grf_offset, data);\r\nif (err) {\r\ndev_err(dev, "unable to apply initial settings to grf (%d)\n",\r\nerr);\r\ngoto out_regulator_disable;\r\n}\r\nerr = clk_set_rate(priv->refclk, 50000000);\r\nif (err)\r\ndev_err(dev,\r\n"failed to change reference clock rate (%d)\n", err);\r\nif (priv->soc_data->need_div_macclk) {\r\npriv->macclk = devm_clk_get(dev, "macclk");\r\nif (IS_ERR(priv->macclk)) {\r\ndev_err(dev, "failed to retrieve mac clock (%ld)\n",\r\nPTR_ERR(priv->macclk));\r\nerr = PTR_ERR(priv->macclk);\r\ngoto out_regulator_disable;\r\n}\r\nerr = clk_prepare_enable(priv->macclk);\r\nif (err) {\r\ndev_err(dev, "failed to enable mac clock (%d)\n", err);\r\ngoto out_regulator_disable;\r\n}\r\nerr = clk_set_rate(priv->macclk, 25000000);\r\nif (err)\r\ndev_err(dev,\r\n"failed to change mac clock rate (%d)\n", err);\r\n}\r\nerr = arc_emac_probe(ndev, interface);\r\nif (err) {\r\ndev_err(dev, "failed to probe arc emac (%d)\n", err);\r\ngoto out_regulator_disable;\r\n}\r\nreturn 0;\r\nout_regulator_disable:\r\nif (priv->regulator)\r\nregulator_disable(priv->regulator);\r\nout_clk_disable:\r\nclk_disable_unprepare(priv->refclk);\r\nout_netdev:\r\nfree_netdev(ndev);\r\nreturn err;\r\n}\r\nstatic int emac_rockchip_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct rockchip_priv_data *priv = netdev_priv(ndev);\r\nint err;\r\nerr = arc_emac_remove(ndev);\r\nclk_disable_unprepare(priv->refclk);\r\nif (priv->regulator)\r\nregulator_disable(priv->regulator);\r\nfree_netdev(ndev);\r\nreturn err;\r\n}
