static int mdp5_hw_init(struct msm_kms *kms)\r\n{\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nstruct platform_device *pdev = mdp5_kms->pdev;\r\nunsigned long flags;\r\npm_runtime_get_sync(&pdev->dev);\r\nmdp5_enable(mdp5_kms);\r\nspin_lock_irqsave(&mdp5_kms->resource_lock, flags);\r\nmdp5_write(mdp5_kms, REG_MDP5_DISP_INTF_SEL, 0);\r\nspin_unlock_irqrestore(&mdp5_kms->resource_lock, flags);\r\nmdp5_ctlm_hw_reset(mdp5_kms->ctlm);\r\nmdp5_disable(mdp5_kms);\r\npm_runtime_put_sync(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void mdp5_prepare_commit(struct msm_kms *kms, struct drm_atomic_state *state)\r\n{\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nmdp5_enable(mdp5_kms);\r\n}\r\nstatic void mdp5_complete_commit(struct msm_kms *kms, struct drm_atomic_state *state)\r\n{\r\nint i;\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nstruct drm_plane *plane;\r\nstruct drm_plane_state *plane_state;\r\nfor_each_plane_in_state(state, plane, plane_state, i)\r\nmdp5_plane_complete_commit(plane, plane_state);\r\nmdp5_disable(mdp5_kms);\r\n}\r\nstatic void mdp5_wait_for_crtc_commit_done(struct msm_kms *kms,\r\nstruct drm_crtc *crtc)\r\n{\r\nmdp5_crtc_wait_for_commit_done(crtc);\r\n}\r\nstatic long mdp5_round_pixclk(struct msm_kms *kms, unsigned long rate,\r\nstruct drm_encoder *encoder)\r\n{\r\nreturn rate;\r\n}\r\nstatic int mdp5_set_split_display(struct msm_kms *kms,\r\nstruct drm_encoder *encoder,\r\nstruct drm_encoder *slave_encoder,\r\nbool is_cmd_mode)\r\n{\r\nif (is_cmd_mode)\r\nreturn mdp5_cmd_encoder_set_split_display(encoder,\r\nslave_encoder);\r\nelse\r\nreturn mdp5_encoder_set_split_display(encoder, slave_encoder);\r\n}\r\nstatic void mdp5_kms_destroy(struct msm_kms *kms)\r\n{\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nstruct msm_mmu *mmu = mdp5_kms->mmu;\r\nif (mmu) {\r\nmmu->funcs->detach(mmu, iommu_ports, ARRAY_SIZE(iommu_ports));\r\nmmu->funcs->destroy(mmu);\r\n}\r\n}\r\nint mdp5_disable(struct mdp5_kms *mdp5_kms)\r\n{\r\nDBG("");\r\nclk_disable_unprepare(mdp5_kms->ahb_clk);\r\nclk_disable_unprepare(mdp5_kms->axi_clk);\r\nclk_disable_unprepare(mdp5_kms->core_clk);\r\nif (mdp5_kms->lut_clk)\r\nclk_disable_unprepare(mdp5_kms->lut_clk);\r\nreturn 0;\r\n}\r\nint mdp5_enable(struct mdp5_kms *mdp5_kms)\r\n{\r\nDBG("");\r\nclk_prepare_enable(mdp5_kms->ahb_clk);\r\nclk_prepare_enable(mdp5_kms->axi_clk);\r\nclk_prepare_enable(mdp5_kms->core_clk);\r\nif (mdp5_kms->lut_clk)\r\nclk_prepare_enable(mdp5_kms->lut_clk);\r\nreturn 0;\r\n}\r\nstatic struct drm_encoder *construct_encoder(struct mdp5_kms *mdp5_kms,\r\nenum mdp5_intf_type intf_type, int intf_num,\r\nenum mdp5_intf_mode intf_mode, struct mdp5_ctl *ctl)\r\n{\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct mdp5_interface intf = {\r\n.num = intf_num,\r\n.type = intf_type,\r\n.mode = intf_mode,\r\n};\r\nif ((intf_type == INTF_DSI) &&\r\n(intf_mode == MDP5_INTF_DSI_MODE_COMMAND))\r\nencoder = mdp5_cmd_encoder_init(dev, &intf, ctl);\r\nelse\r\nencoder = mdp5_encoder_init(dev, &intf, ctl);\r\nif (IS_ERR(encoder)) {\r\ndev_err(dev->dev, "failed to construct encoder\n");\r\nreturn encoder;\r\n}\r\nencoder->possible_crtcs = (1 << priv->num_crtcs) - 1;\r\npriv->encoders[priv->num_encoders++] = encoder;\r\nreturn encoder;\r\n}\r\nstatic int get_dsi_id_from_intf(const struct mdp5_cfg_hw *hw_cfg, int intf_num)\r\n{\r\nconst enum mdp5_intf_type *intfs = hw_cfg->intf.connect;\r\nconst int intf_cnt = ARRAY_SIZE(hw_cfg->intf.connect);\r\nint id = 0, i;\r\nfor (i = 0; i < intf_cnt; i++) {\r\nif (intfs[i] == INTF_DSI) {\r\nif (intf_num == i)\r\nreturn id;\r\nid++;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int modeset_init_intf(struct mdp5_kms *mdp5_kms, int intf_num)\r\n{\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nconst struct mdp5_cfg_hw *hw_cfg =\r\nmdp5_cfg_get_hw_config(mdp5_kms->cfg);\r\nenum mdp5_intf_type intf_type = hw_cfg->intf.connect[intf_num];\r\nstruct mdp5_ctl_manager *ctlm = mdp5_kms->ctlm;\r\nstruct mdp5_ctl *ctl;\r\nstruct drm_encoder *encoder;\r\nint ret = 0;\r\nswitch (intf_type) {\r\ncase INTF_DISABLED:\r\nbreak;\r\ncase INTF_eDP:\r\nif (!priv->edp)\r\nbreak;\r\nctl = mdp5_ctlm_request(ctlm, intf_num);\r\nif (!ctl) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nencoder = construct_encoder(mdp5_kms, INTF_eDP, intf_num,\r\nMDP5_INTF_MODE_NONE, ctl);\r\nif (IS_ERR(encoder)) {\r\nret = PTR_ERR(encoder);\r\nbreak;\r\n}\r\nret = msm_edp_modeset_init(priv->edp, dev, encoder);\r\nbreak;\r\ncase INTF_HDMI:\r\nif (!priv->hdmi)\r\nbreak;\r\nctl = mdp5_ctlm_request(ctlm, intf_num);\r\nif (!ctl) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nencoder = construct_encoder(mdp5_kms, INTF_HDMI, intf_num,\r\nMDP5_INTF_MODE_NONE, ctl);\r\nif (IS_ERR(encoder)) {\r\nret = PTR_ERR(encoder);\r\nbreak;\r\n}\r\nret = msm_hdmi_modeset_init(priv->hdmi, dev, encoder);\r\nbreak;\r\ncase INTF_DSI:\r\n{\r\nint dsi_id = get_dsi_id_from_intf(hw_cfg, intf_num);\r\nstruct drm_encoder *dsi_encs[MSM_DSI_ENCODER_NUM];\r\nenum mdp5_intf_mode mode;\r\nint i;\r\nif ((dsi_id >= ARRAY_SIZE(priv->dsi)) || (dsi_id < 0)) {\r\ndev_err(dev->dev, "failed to find dsi from intf %d\n",\r\nintf_num);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!priv->dsi[dsi_id])\r\nbreak;\r\nctl = mdp5_ctlm_request(ctlm, intf_num);\r\nif (!ctl) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nfor (i = 0; i < MSM_DSI_ENCODER_NUM; i++) {\r\nmode = (i == MSM_DSI_CMD_ENCODER_ID) ?\r\nMDP5_INTF_DSI_MODE_COMMAND :\r\nMDP5_INTF_DSI_MODE_VIDEO;\r\ndsi_encs[i] = construct_encoder(mdp5_kms, INTF_DSI,\r\nintf_num, mode, ctl);\r\nif (IS_ERR(dsi_encs[i])) {\r\nret = PTR_ERR(dsi_encs[i]);\r\nbreak;\r\n}\r\n}\r\nret = msm_dsi_modeset_init(priv->dsi[dsi_id], dev, dsi_encs);\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(dev->dev, "unknown intf: %d\n", intf_type);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int modeset_init(struct mdp5_kms *mdp5_kms)\r\n{\r\nstatic const enum mdp5_pipe crtcs[] = {\r\nSSPP_RGB0, SSPP_RGB1, SSPP_RGB2, SSPP_RGB3,\r\n};\r\nstatic const enum mdp5_pipe vig_planes[] = {\r\nSSPP_VIG0, SSPP_VIG1, SSPP_VIG2, SSPP_VIG3,\r\n};\r\nstatic const enum mdp5_pipe dma_planes[] = {\r\nSSPP_DMA0, SSPP_DMA1,\r\n};\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nconst struct mdp5_cfg_hw *hw_cfg;\r\nint i, ret;\r\nhw_cfg = mdp5_cfg_get_hw_config(mdp5_kms->cfg);\r\nfor (i = 0; i < hw_cfg->pipe_rgb.count; i++) {\r\nstruct drm_plane *plane;\r\nstruct drm_crtc *crtc;\r\nplane = mdp5_plane_init(dev, crtcs[i], true,\r\nhw_cfg->pipe_rgb.base[i], hw_cfg->pipe_rgb.caps);\r\nif (IS_ERR(plane)) {\r\nret = PTR_ERR(plane);\r\ndev_err(dev->dev, "failed to construct plane for %s (%d)\n",\r\npipe2name(crtcs[i]), ret);\r\ngoto fail;\r\n}\r\ncrtc = mdp5_crtc_init(dev, plane, i);\r\nif (IS_ERR(crtc)) {\r\nret = PTR_ERR(crtc);\r\ndev_err(dev->dev, "failed to construct crtc for %s (%d)\n",\r\npipe2name(crtcs[i]), ret);\r\ngoto fail;\r\n}\r\npriv->crtcs[priv->num_crtcs++] = crtc;\r\n}\r\nfor (i = 0; i < hw_cfg->pipe_vig.count; i++) {\r\nstruct drm_plane *plane;\r\nplane = mdp5_plane_init(dev, vig_planes[i], false,\r\nhw_cfg->pipe_vig.base[i], hw_cfg->pipe_vig.caps);\r\nif (IS_ERR(plane)) {\r\nret = PTR_ERR(plane);\r\ndev_err(dev->dev, "failed to construct %s plane: %d\n",\r\npipe2name(vig_planes[i]), ret);\r\ngoto fail;\r\n}\r\n}\r\nfor (i = 0; i < hw_cfg->pipe_dma.count; i++) {\r\nstruct drm_plane *plane;\r\nplane = mdp5_plane_init(dev, dma_planes[i], false,\r\nhw_cfg->pipe_dma.base[i], hw_cfg->pipe_dma.caps);\r\nif (IS_ERR(plane)) {\r\nret = PTR_ERR(plane);\r\ndev_err(dev->dev, "failed to construct %s plane: %d\n",\r\npipe2name(dma_planes[i]), ret);\r\ngoto fail;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(hw_cfg->intf.connect); i++) {\r\nret = modeset_init_intf(mdp5_kms, i);\r\nif (ret)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic void read_mdp_hw_revision(struct mdp5_kms *mdp5_kms,\r\nu32 *major, u32 *minor)\r\n{\r\nu32 version;\r\nmdp5_enable(mdp5_kms);\r\nversion = mdp5_read(mdp5_kms, REG_MDP5_HW_VERSION);\r\nmdp5_disable(mdp5_kms);\r\n*major = FIELD(version, MDP5_HW_VERSION_MAJOR);\r\n*minor = FIELD(version, MDP5_HW_VERSION_MINOR);\r\nDBG("MDP5 version v%d.%d", *major, *minor);\r\n}\r\nstatic int get_clk(struct platform_device *pdev, struct clk **clkp,\r\nconst char *name, bool mandatory)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct clk *clk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk) && mandatory) {\r\ndev_err(dev, "failed to get %s (%ld)\n", name, PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nif (IS_ERR(clk))\r\nDBG("skipping %s", name);\r\nelse\r\n*clkp = clk;\r\nreturn 0;\r\n}\r\nstatic struct drm_encoder *get_encoder_from_crtc(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_encoder *encoder;\r\ndrm_for_each_encoder(encoder, dev)\r\nif (encoder->crtc == crtc)\r\nreturn encoder;\r\nreturn NULL;\r\n}\r\nstatic int mdp5_get_scanoutpos(struct drm_device *dev, unsigned int pipe,\r\nunsigned int flags, int *vpos, int *hpos,\r\nktime_t *stime, ktime_t *etime,\r\nconst struct drm_display_mode *mode)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct drm_crtc *crtc;\r\nstruct drm_encoder *encoder;\r\nint line, vsw, vbp, vactive_start, vactive_end, vfp_end;\r\nint ret = 0;\r\ncrtc = priv->crtcs[pipe];\r\nif (!crtc) {\r\nDRM_ERROR("Invalid crtc %d\n", pipe);\r\nreturn 0;\r\n}\r\nencoder = get_encoder_from_crtc(crtc);\r\nif (!encoder) {\r\nDRM_ERROR("no encoder found for crtc %d\n", pipe);\r\nreturn 0;\r\n}\r\nret |= DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE;\r\nvsw = mode->crtc_vsync_end - mode->crtc_vsync_start;\r\nvbp = mode->crtc_vtotal - mode->crtc_vsync_end;\r\nvactive_start = vsw + vbp + 1;\r\nvactive_end = vactive_start + mode->crtc_vdisplay;\r\nvfp_end = mode->crtc_vtotal;\r\nif (stime)\r\n*stime = ktime_get();\r\nline = mdp5_encoder_get_linecount(encoder);\r\nif (line < vactive_start) {\r\nline -= vactive_start;\r\nret |= DRM_SCANOUTPOS_IN_VBLANK;\r\n} else if (line > vactive_end) {\r\nline = line - vfp_end - vactive_start;\r\nret |= DRM_SCANOUTPOS_IN_VBLANK;\r\n} else {\r\nline -= vactive_start;\r\n}\r\n*vpos = line;\r\n*hpos = 0;\r\nif (etime)\r\n*etime = ktime_get();\r\nreturn ret;\r\n}\r\nstatic int mdp5_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,\r\nint *max_error,\r\nstruct timeval *vblank_time,\r\nunsigned flags)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct drm_crtc *crtc;\r\nif (pipe < 0 || pipe >= priv->num_crtcs) {\r\nDRM_ERROR("Invalid crtc %d\n", pipe);\r\nreturn -EINVAL;\r\n}\r\ncrtc = priv->crtcs[pipe];\r\nif (!crtc) {\r\nDRM_ERROR("Invalid crtc %d\n", pipe);\r\nreturn -EINVAL;\r\n}\r\nreturn drm_calc_vbltimestamp_from_scanoutpos(dev, pipe, max_error,\r\nvblank_time, flags,\r\n&crtc->mode);\r\n}\r\nstatic u32 mdp5_get_vblank_counter(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct drm_crtc *crtc;\r\nstruct drm_encoder *encoder;\r\nif (pipe < 0 || pipe >= priv->num_crtcs)\r\nreturn 0;\r\ncrtc = priv->crtcs[pipe];\r\nif (!crtc)\r\nreturn 0;\r\nencoder = get_encoder_from_crtc(crtc);\r\nif (!encoder)\r\nreturn 0;\r\nreturn mdp5_encoder_get_framecount(encoder);\r\n}\r\nstruct msm_kms *mdp5_kms_init(struct drm_device *dev)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct platform_device *pdev;\r\nstruct mdp5_kms *mdp5_kms;\r\nstruct mdp5_cfg *config;\r\nstruct msm_kms *kms;\r\nstruct msm_mmu *mmu;\r\nint irq, i, ret;\r\nkms = priv->kms;\r\nif (!kms)\r\nreturn NULL;\r\nmdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nmdp_kms_init(&mdp5_kms->base, &kms_funcs);\r\npdev = mdp5_kms->pdev;\r\nirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ndev_err(&pdev->dev, "failed to get irq: %d\n", ret);\r\ngoto fail;\r\n}\r\nkms->irq = irq;\r\nconfig = mdp5_cfg_get_config(mdp5_kms->cfg);\r\nmdp5_enable(mdp5_kms);\r\nfor (i = 0; i < MDP5_INTF_NUM_MAX; i++) {\r\nif (mdp5_cfg_intf_is_virtual(config->hw->intf.connect[i]) ||\r\n!config->hw->intf.base[i])\r\ncontinue;\r\nmdp5_write(mdp5_kms, REG_MDP5_INTF_TIMING_ENGINE_EN(i), 0);\r\nmdp5_write(mdp5_kms, REG_MDP5_INTF_FRAME_LINE_COUNT_EN(i), 0x3);\r\n}\r\nmdp5_disable(mdp5_kms);\r\nmdelay(16);\r\nif (config->platform.iommu) {\r\nmmu = msm_iommu_new(&pdev->dev, config->platform.iommu);\r\nif (IS_ERR(mmu)) {\r\nret = PTR_ERR(mmu);\r\ndev_err(&pdev->dev, "failed to init iommu: %d\n", ret);\r\niommu_domain_free(config->platform.iommu);\r\ngoto fail;\r\n}\r\nret = mmu->funcs->attach(mmu, iommu_ports,\r\nARRAY_SIZE(iommu_ports));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to attach iommu: %d\n",\r\nret);\r\nmmu->funcs->destroy(mmu);\r\ngoto fail;\r\n}\r\n} else {\r\ndev_info(&pdev->dev,\r\n"no iommu, fallback to phys contig buffers for scanout\n");\r\nmmu = NULL;\r\n}\r\nmdp5_kms->mmu = mmu;\r\nmdp5_kms->id = msm_register_mmu(dev, mmu);\r\nif (mdp5_kms->id < 0) {\r\nret = mdp5_kms->id;\r\ndev_err(&pdev->dev, "failed to register mdp5 iommu: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = modeset_init(mdp5_kms);\r\nif (ret) {\r\ndev_err(&pdev->dev, "modeset_init failed: %d\n", ret);\r\ngoto fail;\r\n}\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\ndev->mode_config.max_width = config->hw->lm.max_width;\r\ndev->mode_config.max_height = config->hw->lm.max_height;\r\ndev->driver->get_vblank_timestamp = mdp5_get_vblank_timestamp;\r\ndev->driver->get_scanout_position = mdp5_get_scanoutpos;\r\ndev->driver->get_vblank_counter = mdp5_get_vblank_counter;\r\ndev->max_vblank_count = 0xffffffff;\r\ndev->vblank_disable_immediate = true;\r\nreturn kms;\r\nfail:\r\nif (kms)\r\nmdp5_kms_destroy(kms);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void mdp5_destroy(struct platform_device *pdev)\r\n{\r\nstruct mdp5_kms *mdp5_kms = platform_get_drvdata(pdev);\r\nif (mdp5_kms->ctlm)\r\nmdp5_ctlm_destroy(mdp5_kms->ctlm);\r\nif (mdp5_kms->smp)\r\nmdp5_smp_destroy(mdp5_kms->smp);\r\nif (mdp5_kms->cfg)\r\nmdp5_cfg_destroy(mdp5_kms->cfg);\r\nif (mdp5_kms->rpm_enabled)\r\npm_runtime_disable(&pdev->dev);\r\n}\r\nstatic int mdp5_init(struct platform_device *pdev, struct drm_device *dev)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct mdp5_kms *mdp5_kms;\r\nstruct mdp5_cfg *config;\r\nu32 major, minor;\r\nint ret;\r\nmdp5_kms = devm_kzalloc(&pdev->dev, sizeof(*mdp5_kms), GFP_KERNEL);\r\nif (!mdp5_kms) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nplatform_set_drvdata(pdev, mdp5_kms);\r\nspin_lock_init(&mdp5_kms->resource_lock);\r\nmdp5_kms->dev = dev;\r\nmdp5_kms->pdev = pdev;\r\nmdp5_kms->mmio = msm_ioremap(pdev, "mdp_phys", "MDP5");\r\nif (IS_ERR(mdp5_kms->mmio)) {\r\nret = PTR_ERR(mdp5_kms->mmio);\r\ngoto fail;\r\n}\r\nret = get_clk(pdev, &mdp5_kms->axi_clk, "bus_clk", true);\r\nif (ret)\r\ngoto fail;\r\nret = get_clk(pdev, &mdp5_kms->ahb_clk, "iface_clk", true);\r\nif (ret)\r\ngoto fail;\r\nret = get_clk(pdev, &mdp5_kms->core_clk, "core_clk", true);\r\nif (ret)\r\ngoto fail;\r\nret = get_clk(pdev, &mdp5_kms->vsync_clk, "vsync_clk", true);\r\nif (ret)\r\ngoto fail;\r\nget_clk(pdev, &mdp5_kms->lut_clk, "lut_clk", false);\r\nclk_set_rate(mdp5_kms->core_clk, 200000000);\r\npm_runtime_enable(&pdev->dev);\r\nmdp5_kms->rpm_enabled = true;\r\nread_mdp_hw_revision(mdp5_kms, &major, &minor);\r\nmdp5_kms->cfg = mdp5_cfg_init(mdp5_kms, major, minor);\r\nif (IS_ERR(mdp5_kms->cfg)) {\r\nret = PTR_ERR(mdp5_kms->cfg);\r\nmdp5_kms->cfg = NULL;\r\ngoto fail;\r\n}\r\nconfig = mdp5_cfg_get_config(mdp5_kms->cfg);\r\nmdp5_kms->caps = config->hw->mdp.caps;\r\nclk_set_rate(mdp5_kms->core_clk, config->hw->max_clk);\r\nif (mdp5_kms->caps & MDP_CAP_SMP) {\r\nmdp5_kms->smp = mdp5_smp_init(mdp5_kms->dev, &config->hw->smp);\r\nif (IS_ERR(mdp5_kms->smp)) {\r\nret = PTR_ERR(mdp5_kms->smp);\r\nmdp5_kms->smp = NULL;\r\ngoto fail;\r\n}\r\n}\r\nmdp5_kms->ctlm = mdp5_ctlm_init(dev, mdp5_kms->mmio, mdp5_kms->cfg);\r\nif (IS_ERR(mdp5_kms->ctlm)) {\r\nret = PTR_ERR(mdp5_kms->ctlm);\r\nmdp5_kms->ctlm = NULL;\r\ngoto fail;\r\n}\r\npriv->kms = &mdp5_kms->base.base;\r\nreturn 0;\r\nfail:\r\nmdp5_destroy(pdev);\r\nreturn ret;\r\n}\r\nstatic int mdp5_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(master);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nDBG("");\r\nreturn mdp5_init(pdev, ddev);\r\n}\r\nstatic void mdp5_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nmdp5_destroy(pdev);\r\n}\r\nstatic int mdp5_dev_probe(struct platform_device *pdev)\r\n{\r\nDBG("");\r\nreturn component_add(&pdev->dev, &mdp5_ops);\r\n}\r\nstatic int mdp5_dev_remove(struct platform_device *pdev)\r\n{\r\nDBG("");\r\ncomponent_del(&pdev->dev, &mdp5_ops);\r\nreturn 0;\r\n}\r\nvoid __init msm_mdp_register(void)\r\n{\r\nDBG("");\r\nplatform_driver_register(&mdp5_driver);\r\n}\r\nvoid __exit msm_mdp_unregister(void)\r\n{\r\nDBG("");\r\nplatform_driver_unregister(&mdp5_driver);\r\n}
