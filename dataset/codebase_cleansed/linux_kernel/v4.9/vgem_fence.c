static const char *vgem_fence_get_driver_name(struct fence *fence)\r\n{\r\nreturn "vgem";\r\n}\r\nstatic const char *vgem_fence_get_timeline_name(struct fence *fence)\r\n{\r\nreturn "unbound";\r\n}\r\nstatic bool vgem_fence_signaled(struct fence *fence)\r\n{\r\nreturn false;\r\n}\r\nstatic bool vgem_fence_enable_signaling(struct fence *fence)\r\n{\r\nreturn true;\r\n}\r\nstatic void vgem_fence_release(struct fence *base)\r\n{\r\nstruct vgem_fence *fence = container_of(base, typeof(*fence), base);\r\ndel_timer_sync(&fence->timer);\r\nfence_free(&fence->base);\r\n}\r\nstatic void vgem_fence_value_str(struct fence *fence, char *str, int size)\r\n{\r\nsnprintf(str, size, "%u", fence->seqno);\r\n}\r\nstatic void vgem_fence_timeline_value_str(struct fence *fence, char *str,\r\nint size)\r\n{\r\nsnprintf(str, size, "%u", fence_is_signaled(fence) ? fence->seqno : 0);\r\n}\r\nstatic void vgem_fence_timeout(unsigned long data)\r\n{\r\nstruct vgem_fence *fence = (struct vgem_fence *)data;\r\nfence_signal(&fence->base);\r\n}\r\nstatic struct fence *vgem_fence_create(struct vgem_file *vfile,\r\nunsigned int flags)\r\n{\r\nstruct vgem_fence *fence;\r\nfence = kzalloc(sizeof(*fence), GFP_KERNEL);\r\nif (!fence)\r\nreturn NULL;\r\nspin_lock_init(&fence->lock);\r\nfence_init(&fence->base, &vgem_fence_ops, &fence->lock,\r\nfence_context_alloc(1), 1);\r\nsetup_timer(&fence->timer, vgem_fence_timeout, (unsigned long)fence);\r\nmod_timer(&fence->timer, jiffies + VGEM_FENCE_TIMEOUT);\r\nreturn &fence->base;\r\n}\r\nstatic int attach_dmabuf(struct drm_device *dev,\r\nstruct drm_gem_object *obj)\r\n{\r\nstruct dma_buf *dmabuf;\r\nif (obj->dma_buf)\r\nreturn 0;\r\ndmabuf = dev->driver->gem_prime_export(dev, obj, 0);\r\nif (IS_ERR(dmabuf))\r\nreturn PTR_ERR(dmabuf);\r\nobj->dma_buf = dmabuf;\r\ndrm_gem_object_reference(obj);\r\nreturn 0;\r\n}\r\nint vgem_fence_attach_ioctl(struct drm_device *dev,\r\nvoid *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_vgem_fence_attach *arg = data;\r\nstruct vgem_file *vfile = file->driver_priv;\r\nstruct reservation_object *resv;\r\nstruct drm_gem_object *obj;\r\nstruct fence *fence;\r\nint ret;\r\nif (arg->flags & ~VGEM_FENCE_WRITE)\r\nreturn -EINVAL;\r\nif (arg->pad)\r\nreturn -EINVAL;\r\nobj = drm_gem_object_lookup(file, arg->handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nret = attach_dmabuf(dev, obj);\r\nif (ret)\r\ngoto err;\r\nfence = vgem_fence_create(vfile, arg->flags);\r\nif (!fence) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nresv = obj->dma_buf->resv;\r\nif (!reservation_object_test_signaled_rcu(resv,\r\narg->flags & VGEM_FENCE_WRITE)) {\r\nret = -EBUSY;\r\ngoto err_fence;\r\n}\r\nret = 0;\r\nmutex_lock(&resv->lock.base);\r\nif (arg->flags & VGEM_FENCE_WRITE)\r\nreservation_object_add_excl_fence(resv, fence);\r\nelse if ((ret = reservation_object_reserve_shared(resv)) == 0)\r\nreservation_object_add_shared_fence(resv, fence);\r\nmutex_unlock(&resv->lock.base);\r\nif (ret == 0) {\r\nmutex_lock(&vfile->fence_mutex);\r\nret = idr_alloc(&vfile->fence_idr, fence, 1, 0, GFP_KERNEL);\r\nmutex_unlock(&vfile->fence_mutex);\r\nif (ret > 0) {\r\narg->out_fence = ret;\r\nret = 0;\r\n}\r\n}\r\nerr_fence:\r\nif (ret) {\r\nfence_signal(fence);\r\nfence_put(fence);\r\n}\r\nerr:\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nint vgem_fence_signal_ioctl(struct drm_device *dev,\r\nvoid *data,\r\nstruct drm_file *file)\r\n{\r\nstruct vgem_file *vfile = file->driver_priv;\r\nstruct drm_vgem_fence_signal *arg = data;\r\nstruct fence *fence;\r\nint ret = 0;\r\nif (arg->flags)\r\nreturn -EINVAL;\r\nmutex_lock(&vfile->fence_mutex);\r\nfence = idr_replace(&vfile->fence_idr, NULL, arg->fence);\r\nmutex_unlock(&vfile->fence_mutex);\r\nif (!fence)\r\nreturn -ENOENT;\r\nif (IS_ERR(fence))\r\nreturn PTR_ERR(fence);\r\nif (fence_is_signaled(fence))\r\nret = -ETIMEDOUT;\r\nfence_signal(fence);\r\nfence_put(fence);\r\nreturn ret;\r\n}\r\nint vgem_fence_open(struct vgem_file *vfile)\r\n{\r\nmutex_init(&vfile->fence_mutex);\r\nidr_init(&vfile->fence_idr);\r\nreturn 0;\r\n}\r\nstatic int __vgem_fence_idr_fini(int id, void *p, void *data)\r\n{\r\nfence_signal(p);\r\nfence_put(p);\r\nreturn 0;\r\n}\r\nvoid vgem_fence_close(struct vgem_file *vfile)\r\n{\r\nidr_for_each(&vfile->fence_idr, __vgem_fence_idr_fini, vfile);\r\nidr_destroy(&vfile->fence_idr);\r\n}
