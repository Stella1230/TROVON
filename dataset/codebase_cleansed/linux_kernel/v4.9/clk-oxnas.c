static inline struct clk_oxnas *to_clk_oxnas(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct clk_oxnas, hw);\r\n}\r\nstatic int oxnas_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_oxnas *std = to_clk_oxnas(hw);\r\nint ret;\r\nunsigned int val;\r\nret = regmap_read(std->regmap, CLK_STAT_REGOFFSET, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn val & BIT(std->bit);\r\n}\r\nstatic int oxnas_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_oxnas *std = to_clk_oxnas(hw);\r\nregmap_write(std->regmap, CLK_SET_REGOFFSET, BIT(std->bit));\r\nreturn 0;\r\n}\r\nstatic void oxnas_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_oxnas *std = to_clk_oxnas(hw);\r\nregmap_write(std->regmap, CLK_CLR_REGOFFSET, BIT(std->bit));\r\n}\r\nstatic int oxnas_stdclk_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct clk_oxnas_data *clk_oxnas;\r\nstruct regmap *regmap;\r\nint i;\r\nclk_oxnas = devm_kzalloc(&pdev->dev, sizeof(*clk_oxnas), GFP_KERNEL);\r\nif (!clk_oxnas)\r\nreturn -ENOMEM;\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap)) {\r\ndev_err(&pdev->dev, "failed to have parent regmap\n");\r\nreturn PTR_ERR(regmap);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(clk_oxnas_init); i++) {\r\nstruct clk_oxnas *_clk;\r\n_clk = &clk_oxnas->clk_oxnas[i];\r\n_clk->bit = clk_oxnas_init[i].bit;\r\n_clk->hw.init = clk_oxnas_init[i].clk_init;\r\n_clk->regmap = regmap;\r\nclk_oxnas->clks[i] =\r\ndevm_clk_register(&pdev->dev, &_clk->hw);\r\nif (WARN_ON(IS_ERR(clk_oxnas->clks[i])))\r\nreturn PTR_ERR(clk_oxnas->clks[i]);\r\n}\r\nclk_oxnas->onecell_data->clks = clk_oxnas->clks;\r\nclk_oxnas->onecell_data->clk_num = ARRAY_SIZE(clk_oxnas_init);\r\nreturn of_clk_add_provider(np, of_clk_src_onecell_get,\r\nclk_oxnas->onecell_data);\r\n}
