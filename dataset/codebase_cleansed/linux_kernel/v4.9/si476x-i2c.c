static int si476x_core_config_pinmux(struct si476x_core *core)\r\n{\r\nint err;\r\ndev_dbg(&core->client->dev, "Configuring pinmux\n");\r\nerr = si476x_core_cmd_dig_audio_pin_cfg(core,\r\ncore->pinmux.dclk,\r\ncore->pinmux.dfs,\r\ncore->pinmux.dout,\r\ncore->pinmux.xout);\r\nif (err < 0) {\r\ndev_err(&core->client->dev,\r\n"Failed to configure digital audio pins(err = %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = si476x_core_cmd_zif_pin_cfg(core,\r\ncore->pinmux.iqclk,\r\ncore->pinmux.iqfs,\r\ncore->pinmux.iout,\r\ncore->pinmux.qout);\r\nif (err < 0) {\r\ndev_err(&core->client->dev,\r\n"Failed to configure ZIF pins(err = %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = si476x_core_cmd_ic_link_gpo_ctl_pin_cfg(core,\r\ncore->pinmux.icin,\r\ncore->pinmux.icip,\r\ncore->pinmux.icon,\r\ncore->pinmux.icop);\r\nif (err < 0) {\r\ndev_err(&core->client->dev,\r\n"Failed to configure IC-Link/GPO pins(err = %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = si476x_core_cmd_ana_audio_pin_cfg(core,\r\ncore->pinmux.lrout);\r\nif (err < 0) {\r\ndev_err(&core->client->dev,\r\n"Failed to configure analog audio pins(err = %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = si476x_core_cmd_intb_pin_cfg(core,\r\ncore->pinmux.intb,\r\ncore->pinmux.a1);\r\nif (err < 0) {\r\ndev_err(&core->client->dev,\r\n"Failed to configure interrupt pins(err = %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void si476x_core_schedule_polling_work(struct si476x_core *core)\r\n{\r\nschedule_delayed_work(&core->status_monitor,\r\nusecs_to_jiffies(SI476X_STATUS_POLL_US));\r\n}\r\nint si476x_core_start(struct si476x_core *core, bool soft)\r\n{\r\nstruct i2c_client *client = core->client;\r\nint err;\r\nif (!soft) {\r\nif (gpio_is_valid(core->gpio_reset))\r\ngpio_set_value_cansleep(core->gpio_reset, 1);\r\nif (client->irq)\r\nenable_irq(client->irq);\r\nudelay(100);\r\nif (!client->irq) {\r\natomic_set(&core->is_alive, 1);\r\nsi476x_core_schedule_polling_work(core);\r\n}\r\n} else {\r\nif (client->irq)\r\nenable_irq(client->irq);\r\nelse {\r\natomic_set(&core->is_alive, 1);\r\nsi476x_core_schedule_polling_work(core);\r\n}\r\n}\r\nerr = si476x_core_cmd_power_up(core,\r\n&core->power_up_parameters);\r\nif (err < 0) {\r\ndev_err(&core->client->dev,\r\n"Power up failure(err = %d)\n",\r\nerr);\r\ngoto disable_irq;\r\n}\r\nif (client->irq)\r\natomic_set(&core->is_alive, 1);\r\nerr = si476x_core_config_pinmux(core);\r\nif (err < 0) {\r\ndev_err(&core->client->dev,\r\n"Failed to configure pinmux(err = %d)\n",\r\nerr);\r\ngoto disable_irq;\r\n}\r\nif (client->irq) {\r\nerr = regmap_write(core->regmap,\r\nSI476X_PROP_INT_CTL_ENABLE,\r\nSI476X_RDSIEN |\r\nSI476X_STCIEN |\r\nSI476X_CTSIEN);\r\nif (err < 0) {\r\ndev_err(&core->client->dev,\r\n"Failed to configure interrupt sources"\r\n"(err = %d)\n", err);\r\ngoto disable_irq;\r\n}\r\n}\r\nreturn 0;\r\ndisable_irq:\r\nif (err == -ENODEV)\r\natomic_set(&core->is_alive, 0);\r\nif (client->irq)\r\ndisable_irq(client->irq);\r\nelse\r\ncancel_delayed_work_sync(&core->status_monitor);\r\nif (gpio_is_valid(core->gpio_reset))\r\ngpio_set_value_cansleep(core->gpio_reset, 0);\r\nreturn err;\r\n}\r\nint si476x_core_stop(struct si476x_core *core, bool soft)\r\n{\r\nint err = 0;\r\natomic_set(&core->is_alive, 0);\r\nif (soft) {\r\nstruct si476x_power_down_args args = {\r\n.xosc = false,\r\n};\r\nerr = si476x_core_cmd_power_down(core, &args);\r\n}\r\nif (core->client->irq)\r\ndisable_irq(core->client->irq);\r\nelse\r\ncancel_delayed_work_sync(&core->status_monitor);\r\nif (!soft) {\r\nif (gpio_is_valid(core->gpio_reset))\r\ngpio_set_value_cansleep(core->gpio_reset, 0);\r\n}\r\nreturn err;\r\n}\r\nint si476x_core_set_power_state(struct si476x_core *core,\r\nenum si476x_power_state next_state)\r\n{\r\nint err = 0;\r\nif (core->power_state == SI476X_POWER_INCONSISTENT) {\r\ndev_err(&core->client->dev,\r\n"The device in inconsistent power state\n");\r\nreturn -EINVAL;\r\n}\r\nif (next_state != core->power_state) {\r\nswitch (next_state) {\r\ncase SI476X_POWER_UP_FULL:\r\nerr = regulator_bulk_enable(ARRAY_SIZE(core->supplies),\r\ncore->supplies);\r\nif (err < 0) {\r\ncore->power_state = SI476X_POWER_INCONSISTENT;\r\nbreak;\r\n}\r\nudelay(100);\r\nerr = si476x_core_start(core, false);\r\nif (err < 0)\r\ngoto disable_regulators;\r\ncore->power_state = next_state;\r\nbreak;\r\ncase SI476X_POWER_DOWN:\r\ncore->power_state = next_state;\r\nerr = si476x_core_stop(core, false);\r\nif (err < 0)\r\ncore->power_state = SI476X_POWER_INCONSISTENT;\r\ndisable_regulators:\r\nerr = regulator_bulk_disable(ARRAY_SIZE(core->supplies),\r\ncore->supplies);\r\nif (err < 0)\r\ncore->power_state = SI476X_POWER_INCONSISTENT;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic inline void si476x_core_report_drainer_stop(struct si476x_core *core)\r\n{\r\nmutex_lock(&core->rds_drainer_status_lock);\r\ncore->rds_drainer_is_working = false;\r\nmutex_unlock(&core->rds_drainer_status_lock);\r\n}\r\nstatic inline void si476x_core_start_rds_drainer_once(struct si476x_core *core)\r\n{\r\nmutex_lock(&core->rds_drainer_status_lock);\r\nif (!core->rds_drainer_is_working) {\r\ncore->rds_drainer_is_working = true;\r\nschedule_work(&core->rds_fifo_drainer);\r\n}\r\nmutex_unlock(&core->rds_drainer_status_lock);\r\n}\r\nstatic void si476x_core_drain_rds_fifo(struct work_struct *work)\r\n{\r\nint err;\r\nstruct si476x_core *core = container_of(work, struct si476x_core,\r\nrds_fifo_drainer);\r\nstruct si476x_rds_status_report report;\r\nsi476x_core_lock(core);\r\nerr = si476x_core_cmd_fm_rds_status(core, true, false, false, &report);\r\nif (!err) {\r\nint i = report.rdsfifoused;\r\ndev_dbg(&core->client->dev,\r\n"%d elements in RDS FIFO. Draining.\n", i);\r\nfor (; i > 0; --i) {\r\nerr = si476x_core_cmd_fm_rds_status(core, false, false,\r\n(i == 1), &report);\r\nif (err < 0)\r\ngoto unlock;\r\nkfifo_in(&core->rds_fifo, report.rds,\r\nsizeof(report.rds));\r\ndev_dbg(&core->client->dev, "RDS data:\n %*ph\n",\r\n(int)sizeof(report.rds), report.rds);\r\n}\r\ndev_dbg(&core->client->dev, "Drrrrained!\n");\r\nwake_up_interruptible(&core->rds_read_queue);\r\n}\r\nunlock:\r\nsi476x_core_unlock(core);\r\nsi476x_core_report_drainer_stop(core);\r\n}\r\nstatic void si476x_core_pronounce_dead(struct si476x_core *core)\r\n{\r\ndev_info(&core->client->dev, "Core device is dead.\n");\r\natomic_set(&core->is_alive, 0);\r\nwake_up_interruptible(&core->rds_read_queue);\r\natomic_set(&core->cts, 1);\r\nwake_up(&core->command);\r\natomic_set(&core->stc, 1);\r\nwake_up(&core->tuning);\r\n}\r\nint si476x_core_i2c_xfer(struct si476x_core *core,\r\nenum si476x_i2c_type type,\r\nchar *buf, int count)\r\n{\r\nstatic int io_errors_count;\r\nint err;\r\nif (type == SI476X_I2C_SEND)\r\nerr = i2c_master_send(core->client, buf, count);\r\nelse\r\nerr = i2c_master_recv(core->client, buf, count);\r\nif (err < 0) {\r\nif (io_errors_count++ > SI476X_MAX_IO_ERRORS)\r\nsi476x_core_pronounce_dead(core);\r\n} else {\r\nio_errors_count = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int si476x_core_get_status(struct si476x_core *core)\r\n{\r\nu8 response;\r\nint err = si476x_core_i2c_xfer(core, SI476X_I2C_RECV,\r\n&response, sizeof(response));\r\nreturn (err < 0) ? err : response;\r\n}\r\nstatic void si476x_core_get_and_signal_status(struct si476x_core *core)\r\n{\r\nint status = si476x_core_get_status(core);\r\nif (status < 0) {\r\ndev_err(&core->client->dev, "Failed to get status\n");\r\nreturn;\r\n}\r\nif (status & SI476X_CTS) {\r\ndev_dbg(&core->client->dev, "[interrupt] CTSINT\n");\r\natomic_set(&core->cts, 1);\r\nwake_up(&core->command);\r\n}\r\nif (status & SI476X_FM_RDS_INT) {\r\ndev_dbg(&core->client->dev, "[interrupt] RDSINT\n");\r\nsi476x_core_start_rds_drainer_once(core);\r\n}\r\nif (status & SI476X_STC_INT) {\r\ndev_dbg(&core->client->dev, "[interrupt] STCINT\n");\r\natomic_set(&core->stc, 1);\r\nwake_up(&core->tuning);\r\n}\r\n}\r\nstatic void si476x_core_poll_loop(struct work_struct *work)\r\n{\r\nstruct si476x_core *core = SI476X_WORK_TO_CORE(work);\r\nsi476x_core_get_and_signal_status(core);\r\nif (atomic_read(&core->is_alive))\r\nsi476x_core_schedule_polling_work(core);\r\n}\r\nstatic irqreturn_t si476x_core_interrupt(int irq, void *dev)\r\n{\r\nstruct si476x_core *core = dev;\r\nsi476x_core_get_and_signal_status(core);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int si476x_core_fwver_to_revision(struct si476x_core *core,\r\nint func, int major,\r\nint minor1, int minor2)\r\n{\r\nswitch (func) {\r\ncase SI476X_FUNC_FM_RECEIVER:\r\nswitch (major) {\r\ncase 5:\r\nreturn SI476X_REVISION_A10;\r\ncase 8:\r\nreturn SI476X_REVISION_A20;\r\ncase 10:\r\nreturn SI476X_REVISION_A30;\r\ndefault:\r\ngoto unknown_revision;\r\n}\r\ncase SI476X_FUNC_AM_RECEIVER:\r\nswitch (major) {\r\ncase 5:\r\nreturn SI476X_REVISION_A10;\r\ncase 7:\r\nreturn SI476X_REVISION_A20;\r\ncase 9:\r\nreturn SI476X_REVISION_A30;\r\ndefault:\r\ngoto unknown_revision;\r\n}\r\ncase SI476X_FUNC_WB_RECEIVER:\r\nswitch (major) {\r\ncase 3:\r\nreturn SI476X_REVISION_A10;\r\ncase 5:\r\nreturn SI476X_REVISION_A20;\r\ncase 7:\r\nreturn SI476X_REVISION_A30;\r\ndefault:\r\ngoto unknown_revision;\r\n}\r\ncase SI476X_FUNC_BOOTLOADER:\r\ndefault:\r\nBUG();\r\nreturn -1;\r\n}\r\nunknown_revision:\r\ndev_err(&core->client->dev,\r\n"Unsupported version of the firmware: %d.%d.%d, "\r\n"reverting to A10 compatible functions\n",\r\nmajor, minor1, minor2);\r\nreturn SI476X_REVISION_A10;\r\n}\r\nstatic int si476x_core_get_revision_info(struct si476x_core *core)\r\n{\r\nint rval;\r\nstruct si476x_func_info info;\r\nsi476x_core_lock(core);\r\nrval = si476x_core_set_power_state(core, SI476X_POWER_UP_FULL);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si476x_core_cmd_func_info(core, &info);\r\nif (rval < 0)\r\ngoto power_down;\r\ncore->revision = si476x_core_fwver_to_revision(core, info.func,\r\ninfo.firmware.major,\r\ninfo.firmware.minor[0],\r\ninfo.firmware.minor[1]);\r\npower_down:\r\nsi476x_core_set_power_state(core, SI476X_POWER_DOWN);\r\nexit:\r\nsi476x_core_unlock(core);\r\nreturn rval;\r\n}\r\nbool si476x_core_has_am(struct si476x_core *core)\r\n{\r\nreturn core->chip_id == SI476X_CHIP_SI4761 ||\r\ncore->chip_id == SI476X_CHIP_SI4764;\r\n}\r\nbool si476x_core_has_diversity(struct si476x_core *core)\r\n{\r\nreturn core->chip_id == SI476X_CHIP_SI4764;\r\n}\r\nbool si476x_core_is_a_secondary_tuner(struct si476x_core *core)\r\n{\r\nreturn si476x_core_has_diversity(core) &&\r\n(core->diversity_mode == SI476X_PHDIV_SECONDARY_ANTENNA ||\r\ncore->diversity_mode == SI476X_PHDIV_SECONDARY_COMBINING);\r\n}\r\nbool si476x_core_is_a_primary_tuner(struct si476x_core *core)\r\n{\r\nreturn si476x_core_has_diversity(core) &&\r\n(core->diversity_mode == SI476X_PHDIV_PRIMARY_ANTENNA ||\r\ncore->diversity_mode == SI476X_PHDIV_PRIMARY_COMBINING);\r\n}\r\nbool si476x_core_is_in_am_receiver_mode(struct si476x_core *core)\r\n{\r\nreturn si476x_core_has_am(core) &&\r\n(core->power_up_parameters.func == SI476X_FUNC_AM_RECEIVER);\r\n}\r\nbool si476x_core_is_powered_up(struct si476x_core *core)\r\n{\r\nreturn core->power_state == SI476X_POWER_UP_FULL;\r\n}\r\nstatic int si476x_core_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint rval;\r\nstruct si476x_core *core;\r\nstruct si476x_platform_data *pdata;\r\nstruct mfd_cell *cell;\r\nint cell_num;\r\ncore = devm_kzalloc(&client->dev, sizeof(*core), GFP_KERNEL);\r\nif (!core) {\r\ndev_err(&client->dev,\r\n"failed to allocate 'struct si476x_core'\n");\r\nreturn -ENOMEM;\r\n}\r\ncore->client = client;\r\ncore->regmap = devm_regmap_init_si476x(core);\r\nif (IS_ERR(core->regmap)) {\r\nrval = PTR_ERR(core->regmap);\r\ndev_err(&client->dev,\r\n"Failed to allocate register map: %d\n",\r\nrval);\r\nreturn rval;\r\n}\r\ni2c_set_clientdata(client, core);\r\natomic_set(&core->is_alive, 0);\r\ncore->power_state = SI476X_POWER_DOWN;\r\npdata = dev_get_platdata(&client->dev);\r\nif (pdata) {\r\nmemcpy(&core->power_up_parameters,\r\n&pdata->power_up_parameters,\r\nsizeof(core->power_up_parameters));\r\ncore->gpio_reset = -1;\r\nif (gpio_is_valid(pdata->gpio_reset)) {\r\nrval = gpio_request(pdata->gpio_reset, "si476x reset");\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"Failed to request gpio: %d\n", rval);\r\nreturn rval;\r\n}\r\ncore->gpio_reset = pdata->gpio_reset;\r\ngpio_direction_output(core->gpio_reset, 0);\r\n}\r\ncore->diversity_mode = pdata->diversity_mode;\r\nmemcpy(&core->pinmux, &pdata->pinmux,\r\nsizeof(struct si476x_pinmux));\r\n} else {\r\ndev_err(&client->dev, "No platform data provided\n");\r\nreturn -EINVAL;\r\n}\r\ncore->supplies[0].supply = "vd";\r\ncore->supplies[1].supply = "va";\r\ncore->supplies[2].supply = "vio1";\r\ncore->supplies[3].supply = "vio2";\r\nrval = devm_regulator_bulk_get(&client->dev,\r\nARRAY_SIZE(core->supplies),\r\ncore->supplies);\r\nif (rval) {\r\ndev_err(&client->dev, "Failet to gett all of the regulators\n");\r\ngoto free_gpio;\r\n}\r\nmutex_init(&core->cmd_lock);\r\ninit_waitqueue_head(&core->command);\r\ninit_waitqueue_head(&core->tuning);\r\nrval = kfifo_alloc(&core->rds_fifo,\r\nSI476X_DRIVER_RDS_FIFO_DEPTH *\r\nsizeof(struct v4l2_rds_data),\r\nGFP_KERNEL);\r\nif (rval) {\r\ndev_err(&client->dev, "Could not allocate the FIFO\n");\r\ngoto free_gpio;\r\n}\r\nmutex_init(&core->rds_drainer_status_lock);\r\ninit_waitqueue_head(&core->rds_read_queue);\r\nINIT_WORK(&core->rds_fifo_drainer, si476x_core_drain_rds_fifo);\r\nif (client->irq) {\r\nrval = devm_request_threaded_irq(&client->dev,\r\nclient->irq, NULL,\r\nsi476x_core_interrupt,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\nclient->name, core);\r\nif (rval < 0) {\r\ndev_err(&client->dev, "Could not request IRQ %d\n",\r\nclient->irq);\r\ngoto free_kfifo;\r\n}\r\ndisable_irq(client->irq);\r\ndev_dbg(&client->dev, "IRQ requested.\n");\r\ncore->rds_fifo_depth = 20;\r\n} else {\r\nINIT_DELAYED_WORK(&core->status_monitor,\r\nsi476x_core_poll_loop);\r\ndev_info(&client->dev,\r\n"No IRQ number specified, will use polling\n");\r\ncore->rds_fifo_depth = 5;\r\n}\r\ncore->chip_id = id->driver_data;\r\nrval = si476x_core_get_revision_info(core);\r\nif (rval < 0) {\r\nrval = -ENODEV;\r\ngoto free_kfifo;\r\n}\r\ncell_num = 0;\r\ncell = &core->cells[SI476X_RADIO_CELL];\r\ncell->name = "si476x-radio";\r\ncell_num++;\r\n#ifdef CONFIG_SND_SOC_SI476X\r\nif ((core->chip_id == SI476X_CHIP_SI4761 ||\r\ncore->chip_id == SI476X_CHIP_SI4764) &&\r\ncore->pinmux.dclk == SI476X_DCLK_DAUDIO &&\r\ncore->pinmux.dfs == SI476X_DFS_DAUDIO &&\r\ncore->pinmux.dout == SI476X_DOUT_I2S_OUTPUT &&\r\ncore->pinmux.xout == SI476X_XOUT_TRISTATE) {\r\ncell = &core->cells[SI476X_CODEC_CELL];\r\ncell->name = "si476x-codec";\r\ncell_num++;\r\n}\r\n#endif\r\nrval = mfd_add_devices(&client->dev,\r\n(client->adapter->nr << 8) + client->addr,\r\ncore->cells, cell_num,\r\nNULL, 0, NULL);\r\nif (!rval)\r\nreturn 0;\r\nfree_kfifo:\r\nkfifo_free(&core->rds_fifo);\r\nfree_gpio:\r\nif (gpio_is_valid(core->gpio_reset))\r\ngpio_free(core->gpio_reset);\r\nreturn rval;\r\n}\r\nstatic int si476x_core_remove(struct i2c_client *client)\r\n{\r\nstruct si476x_core *core = i2c_get_clientdata(client);\r\nsi476x_core_pronounce_dead(core);\r\nmfd_remove_devices(&client->dev);\r\nif (client->irq)\r\ndisable_irq(client->irq);\r\nelse\r\ncancel_delayed_work_sync(&core->status_monitor);\r\nkfifo_free(&core->rds_fifo);\r\nif (gpio_is_valid(core->gpio_reset))\r\ngpio_free(core->gpio_reset);\r\nreturn 0;\r\n}
