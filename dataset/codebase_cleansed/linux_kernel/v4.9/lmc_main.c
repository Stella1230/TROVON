int lmc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nlmc_ctl_t ctl;\r\nint ret = -EOPNOTSUPP;\r\nu16 regVal;\r\nunsigned long flags;\r\nlmc_trace(dev, "lmc_ioctl in");\r\nswitch (cmd) {\r\ncase LMCIOCGINFO:\r\nif (copy_to_user(ifr->ifr_data, &sc->ictl, sizeof(lmc_ctl_t)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nbreak;\r\ncase LMCIOCSINFO:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nif(dev->flags & IFF_UP){\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nif (copy_from_user(&ctl, ifr->ifr_data, sizeof(lmc_ctl_t))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nsc->lmc_media->set_status (sc, &ctl);\r\nif(ctl.crc_length != sc->ictl.crc_length) {\r\nsc->lmc_media->set_crc_length(sc, ctl.crc_length);\r\nif (sc->ictl.crc_length == LMC_CTL_CRC_LENGTH_16)\r\nsc->TxDescriptControlInit |= LMC_TDES_ADD_CRC_DISABLE;\r\nelse\r\nsc->TxDescriptControlInit &= ~LMC_TDES_ADD_CRC_DISABLE;\r\n}\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nret = 0;\r\nbreak;\r\ncase LMCIOCIFTYPE:\r\n{\r\nu16 old_type = sc->if_type;\r\nu16 new_type;\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nif (copy_from_user(&new_type, ifr->ifr_data, sizeof(u16))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (new_type == old_type)\r\n{\r\nret = 0 ;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nlmc_proto_close(sc);\r\nsc->if_type = new_type;\r\nlmc_proto_attach(sc);\r\nret = lmc_proto_open(sc);\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nbreak;\r\n}\r\ncase LMCIOCGETXINFO:\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nsc->lmc_xinfo.Magic0 = 0xBEEFCAFE;\r\nsc->lmc_xinfo.PciCardType = sc->lmc_cardtype;\r\nsc->lmc_xinfo.PciSlotNumber = 0;\r\nsc->lmc_xinfo.DriverMajorVersion = DRIVER_MAJOR_VERSION;\r\nsc->lmc_xinfo.DriverMinorVersion = DRIVER_MINOR_VERSION;\r\nsc->lmc_xinfo.DriverSubVersion = DRIVER_SUB_VERSION;\r\nsc->lmc_xinfo.XilinxRevisionNumber =\r\nlmc_mii_readreg (sc, 0, 3) & 0xf;\r\nsc->lmc_xinfo.MaxFrameSize = LMC_PKT_BUF_SZ;\r\nsc->lmc_xinfo.link_status = sc->lmc_media->get_link_status (sc);\r\nsc->lmc_xinfo.mii_reg16 = lmc_mii_readreg (sc, 0, 16);\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nsc->lmc_xinfo.Magic1 = 0xDEADBEEF;\r\nif (copy_to_user(ifr->ifr_data, &sc->lmc_xinfo,\r\nsizeof(struct lmc_xinfo)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nbreak;\r\ncase LMCIOCGETLMCSTATS:\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nif (sc->lmc_cardtype == LMC_CARDTYPE_T1) {\r\nlmc_mii_writereg(sc, 0, 17, T1FRAMER_FERR_LSB);\r\nsc->extra_stats.framingBitErrorCount +=\r\nlmc_mii_readreg(sc, 0, 18) & 0xff;\r\nlmc_mii_writereg(sc, 0, 17, T1FRAMER_FERR_MSB);\r\nsc->extra_stats.framingBitErrorCount +=\r\n(lmc_mii_readreg(sc, 0, 18) & 0xff) << 8;\r\nlmc_mii_writereg(sc, 0, 17, T1FRAMER_LCV_LSB);\r\nsc->extra_stats.lineCodeViolationCount +=\r\nlmc_mii_readreg(sc, 0, 18) & 0xff;\r\nlmc_mii_writereg(sc, 0, 17, T1FRAMER_LCV_MSB);\r\nsc->extra_stats.lineCodeViolationCount +=\r\n(lmc_mii_readreg(sc, 0, 18) & 0xff) << 8;\r\nlmc_mii_writereg(sc, 0, 17, T1FRAMER_AERR);\r\nregVal = lmc_mii_readreg(sc, 0, 18) & 0xff;\r\nsc->extra_stats.lossOfFrameCount +=\r\n(regVal & T1FRAMER_LOF_MASK) >> 4;\r\nsc->extra_stats.changeOfFrameAlignmentCount +=\r\n(regVal & T1FRAMER_COFA_MASK) >> 2;\r\nsc->extra_stats.severelyErroredFrameCount +=\r\nregVal & T1FRAMER_SEF_MASK;\r\n}\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nif (copy_to_user(ifr->ifr_data, &sc->lmc_device->stats,\r\nsizeof(sc->lmc_device->stats)) ||\r\ncopy_to_user(ifr->ifr_data + sizeof(sc->lmc_device->stats),\r\n&sc->extra_stats, sizeof(sc->extra_stats)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nbreak;\r\ncase LMCIOCCLEARLMCSTATS:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nmemset(&sc->lmc_device->stats, 0, sizeof(sc->lmc_device->stats));\r\nmemset(&sc->extra_stats, 0, sizeof(sc->extra_stats));\r\nsc->extra_stats.check = STATCHECK;\r\nsc->extra_stats.version_size = (DRIVER_VERSION << 16) +\r\nsizeof(sc->lmc_device->stats) + sizeof(sc->extra_stats);\r\nsc->extra_stats.lmc_cardtype = sc->lmc_cardtype;\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nret = 0;\r\nbreak;\r\ncase LMCIOCSETCIRCUIT:\r\nif (!capable(CAP_NET_ADMIN)){\r\nret = -EPERM;\r\nbreak;\r\n}\r\nif(dev->flags & IFF_UP){\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nif (copy_from_user(&ctl, ifr->ifr_data, sizeof(lmc_ctl_t))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nsc->lmc_media->set_circuit_type(sc, ctl.circuit_type);\r\nsc->ictl.circuit_type = ctl.circuit_type;\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nret = 0;\r\nbreak;\r\ncase LMCIOCRESET:\r\nif (!capable(CAP_NET_ADMIN)){\r\nret = -EPERM;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nprintk (" REG16 before reset +%04x\n", lmc_mii_readreg (sc, 0, 16));\r\nlmc_running_reset (dev);\r\nprintk (" REG16 after reset +%04x\n", lmc_mii_readreg (sc, 0, 16));\r\nLMC_EVENT_LOG(LMC_EVENT_FORCEDRESET, LMC_CSR_READ (sc, csr_status), lmc_mii_readreg (sc, 0, 16));\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nret = 0;\r\nbreak;\r\n#ifdef DEBUG\r\ncase LMCIOCDUMPEVENTLOG:\r\nif (copy_to_user(ifr->ifr_data, &lmcEventLogIndex, sizeof(u32))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (copy_to_user(ifr->ifr_data + sizeof(u32), lmcEventLogBuf,\r\nsizeof(lmcEventLogBuf)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nbreak;\r\n#endif\r\ncase LMCIOCT1CONTROL:\r\nif (sc->lmc_cardtype != LMC_CARDTYPE_T1){\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nbreak;\r\ncase LMCIOCXILINX:\r\n{\r\nstruct lmc_xilinx_control xc;\r\nif (!capable(CAP_NET_ADMIN)){\r\nret = -EPERM;\r\nbreak;\r\n}\r\nnetif_stop_queue(dev);\r\nif (copy_from_user(&xc, ifr->ifr_data, sizeof(struct lmc_xilinx_control))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nswitch(xc.command){\r\ncase lmc_xilinx_reset:\r\n{\r\nu16 mii;\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nmii = lmc_mii_readreg (sc, 0, 16);\r\nlmc_gpio_mkinput(sc, 0xff);\r\nlmc_gpio_mkoutput(sc, LMC_GEP_RESET);\r\nsc->lmc_gpio &= ~LMC_GEP_RESET;\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nudelay(50);\r\nsc->lmc_gpio |= LMC_GEP_RESET;\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nlmc_gpio_mkinput(sc, 0xff);\r\nsc->lmc_media->set_link_status (sc, 1);\r\nsc->lmc_media->set_status (sc, NULL);\r\n{\r\nint i;\r\nfor(i = 0; i < 5; i++){\r\nlmc_led_on(sc, LMC_DS3_LED0);\r\nmdelay(100);\r\nlmc_led_off(sc, LMC_DS3_LED0);\r\nlmc_led_on(sc, LMC_DS3_LED1);\r\nmdelay(100);\r\nlmc_led_off(sc, LMC_DS3_LED1);\r\nlmc_led_on(sc, LMC_DS3_LED3);\r\nmdelay(100);\r\nlmc_led_off(sc, LMC_DS3_LED3);\r\nlmc_led_on(sc, LMC_DS3_LED2);\r\nmdelay(100);\r\nlmc_led_off(sc, LMC_DS3_LED2);\r\n}\r\n}\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nret = 0x0;\r\n}\r\nbreak;\r\ncase lmc_xilinx_load_prom:\r\n{\r\nu16 mii;\r\nint timeout = 500000;\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nmii = lmc_mii_readreg (sc, 0, 16);\r\nlmc_gpio_mkinput(sc, 0xff);\r\nlmc_gpio_mkoutput(sc, LMC_GEP_DP | LMC_GEP_RESET);\r\nsc->lmc_gpio &= ~(LMC_GEP_RESET | LMC_GEP_DP);\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nudelay(50);\r\nsc->lmc_gpio |= LMC_GEP_DP | LMC_GEP_RESET;\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nwhile( (LMC_CSR_READ(sc, csr_gp) & LMC_GEP_INIT) == 0 &&\r\n(timeout-- > 0))\r\ncpu_relax();\r\nlmc_gpio_mkinput(sc, 0xff);\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nret = 0x0;\r\nbreak;\r\n}\r\ncase lmc_xilinx_load:\r\n{\r\nchar *data;\r\nint pos;\r\nint timeout = 500000;\r\nif (!xc.data) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndata = kmalloc(xc.len, GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nif(copy_from_user(data, xc.data, xc.len))\r\n{\r\nkfree(data);\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nprintk("%s: Starting load of data Len: %d at 0x%p == 0x%p\n", dev->name, xc.len, xc.data, data);\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nlmc_gpio_mkinput(sc, 0xff);\r\nsc->lmc_gpio = 0x00;\r\nsc->lmc_gpio &= ~LMC_GEP_DP;\r\nsc->lmc_gpio &= ~LMC_GEP_RESET;\r\nsc->lmc_gpio |= LMC_GEP_MODE;\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nlmc_gpio_mkoutput(sc, LMC_GEP_MODE | LMC_GEP_DP | LMC_GEP_RESET);\r\nudelay(50);\r\nlmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);\r\nsc->lmc_gpio = 0x00;\r\nsc->lmc_gpio |= LMC_GEP_MODE;\r\nsc->lmc_gpio |= LMC_GEP_DATA;\r\nsc->lmc_gpio |= LMC_GEP_CLK;\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nlmc_gpio_mkoutput(sc, LMC_GEP_DATA | LMC_GEP_CLK | LMC_GEP_MODE );\r\nwhile( (LMC_CSR_READ(sc, csr_gp) & LMC_GEP_INIT) == 0 &&\r\n(timeout-- > 0))\r\ncpu_relax();\r\nprintk(KERN_DEBUG "%s: Waited %d for the Xilinx to clear it's memory\n", dev->name, 500000-timeout);\r\nfor(pos = 0; pos < xc.len; pos++){\r\nswitch(data[pos]){\r\ncase 0:\r\nsc->lmc_gpio &= ~LMC_GEP_DATA;\r\nbreak;\r\ncase 1:\r\nsc->lmc_gpio |= LMC_GEP_DATA;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s Bad data in xilinx programming data at %d, got %d wanted 0 or 1\n", dev->name, pos, data[pos]);\r\nsc->lmc_gpio |= LMC_GEP_DATA;\r\n}\r\nsc->lmc_gpio &= ~LMC_GEP_CLK;\r\nsc->lmc_gpio |= LMC_GEP_MODE;\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nudelay(1);\r\nsc->lmc_gpio |= LMC_GEP_CLK;\r\nsc->lmc_gpio |= LMC_GEP_MODE;\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nudelay(1);\r\n}\r\nif((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_INIT) == 0){\r\nprintk(KERN_WARNING "%s: Reprogramming FAILED. Needs to be reprogrammed. (corrupted data)\n", dev->name);\r\n}\r\nelse if((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0){\r\nprintk(KERN_WARNING "%s: Reprogramming FAILED. Needs to be reprogrammed. (done)\n", dev->name);\r\n}\r\nelse {\r\nprintk(KERN_DEBUG "%s: Done reprogramming Xilinx, %d bits, good luck!\n", dev->name, pos);\r\n}\r\nlmc_gpio_mkinput(sc, 0xff);\r\nsc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;\r\nlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\r\nsc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;\r\nlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nkfree(data);\r\nret = 0;\r\nbreak;\r\n}\r\ndefault:\r\nret = -EBADE;\r\nbreak;\r\n}\r\nnetif_wake_queue(dev);\r\nsc->lmc_txfull = 0;\r\n}\r\nbreak;\r\ndefault:\r\nret = lmc_proto_ioctl (sc, ifr, cmd);\r\nbreak;\r\n}\r\nlmc_trace(dev, "lmc_ioctl out");\r\nreturn ret;\r\n}\r\nstatic void lmc_watchdog (unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nint link_status;\r\nu32 ticks;\r\nunsigned long flags;\r\nlmc_trace(dev, "lmc_watchdog in");\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nif(sc->check != 0xBEAFCAFE){\r\nprintk("LMC: Corrupt net_device struct, breaking out\n");\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nreturn;\r\n}\r\nLMC_CSR_WRITE (sc, csr_15, 0x00000011);\r\nsc->lmc_cmdmode |= TULIP_CMD_TXRUN | TULIP_CMD_RXRUN;\r\nLMC_CSR_WRITE (sc, csr_command, sc->lmc_cmdmode);\r\nif (sc->lmc_ok == 0)\r\ngoto kick_timer;\r\nLMC_EVENT_LOG(LMC_EVENT_WATCHDOG, LMC_CSR_READ (sc, csr_status), lmc_mii_readreg (sc, 0, 16));\r\nif (sc->lmc_taint_tx == sc->lastlmc_taint_tx &&\r\nsc->lmc_device->stats.tx_packets > sc->lasttx_packets &&\r\nsc->tx_TimeoutInd == 0)\r\n{\r\nsc->tx_TimeoutInd = 1;\r\n}\r\nelse if (sc->lmc_taint_tx == sc->lastlmc_taint_tx &&\r\nsc->lmc_device->stats.tx_packets > sc->lasttx_packets &&\r\nsc->tx_TimeoutInd)\r\n{\r\nLMC_EVENT_LOG(LMC_EVENT_XMTINTTMO, LMC_CSR_READ (sc, csr_status), 0);\r\nsc->tx_TimeoutDisplay = 1;\r\nsc->extra_stats.tx_TimeoutCnt++;\r\nlmc_running_reset (dev);\r\nLMC_EVENT_LOG(LMC_EVENT_RESET1, LMC_CSR_READ (sc, csr_status), 0);\r\nLMC_EVENT_LOG(LMC_EVENT_RESET2, lmc_mii_readreg (sc, 0, 16), lmc_mii_readreg (sc, 0, 17));\r\nsc->tx_TimeoutInd = 0;\r\nsc->lastlmc_taint_tx = sc->lmc_taint_tx;\r\nsc->lasttx_packets = sc->lmc_device->stats.tx_packets;\r\n} else {\r\nsc->tx_TimeoutInd = 0;\r\nsc->lastlmc_taint_tx = sc->lmc_taint_tx;\r\nsc->lasttx_packets = sc->lmc_device->stats.tx_packets;\r\n}\r\nlink_status = sc->lmc_media->get_link_status (sc);\r\nif ((link_status == 0) && (sc->last_link_status != 0)) {\r\nprintk(KERN_WARNING "%s: hardware/physical link down\n", dev->name);\r\nsc->last_link_status = 0;\r\nnetif_carrier_off(dev);\r\n}\r\nif (link_status != 0 && sc->last_link_status == 0) {\r\nprintk(KERN_WARNING "%s: hardware/physical link up\n", dev->name);\r\nsc->last_link_status = 1;\r\nnetif_carrier_on(dev);\r\n}\r\nsc->lmc_media->watchdog(sc);\r\nLMC_CSR_WRITE(sc, csr_rxpoll, 0);\r\nif(sc->failed_ring == 1){\r\nsc->failed_ring = 0;\r\nlmc_softreset(sc);\r\n}\r\nif(sc->failed_recv_alloc == 1){\r\nsc->failed_recv_alloc = 0;\r\nlmc_softreset(sc);\r\n}\r\nkick_timer:\r\nticks = LMC_CSR_READ (sc, csr_gp_timer);\r\nLMC_CSR_WRITE (sc, csr_gp_timer, 0xffffffffUL);\r\nsc->ictl.ticks = 0x0000ffff - (ticks & 0x0000ffff);\r\nsc->timer.expires = jiffies + (HZ);\r\nadd_timer (&sc->timer);\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nlmc_trace(dev, "lmc_watchdog out");\r\n}\r\nstatic int lmc_attach(struct net_device *dev, unsigned short encoding,\r\nunsigned short parity)\r\n{\r\nif (encoding == ENCODING_NRZ && parity == PARITY_CRC16_PR1_CCITT)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int lmc_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nlmc_softc_t *sc;\r\nstruct net_device *dev;\r\nu16 subdevice;\r\nu16 AdapModelNum;\r\nint err;\r\nstatic int cards_found;\r\nerr = pcim_enable_device(pdev);\r\nif (err) {\r\nprintk(KERN_ERR "lmc: pci enable failed: %d\n", err);\r\nreturn err;\r\n}\r\nerr = pci_request_regions(pdev, "lmc");\r\nif (err) {\r\nprintk(KERN_ERR "lmc: pci_request_region failed\n");\r\nreturn err;\r\n}\r\nsc = devm_kzalloc(&pdev->dev, sizeof(lmc_softc_t), GFP_KERNEL);\r\nif (!sc)\r\nreturn -ENOMEM;\r\ndev = alloc_hdlcdev(sc);\r\nif (!dev) {\r\nprintk(KERN_ERR "lmc:alloc_netdev for device failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->type = ARPHRD_HDLC;\r\ndev_to_hdlc(dev)->xmit = lmc_start_xmit;\r\ndev_to_hdlc(dev)->attach = lmc_attach;\r\ndev->netdev_ops = &lmc_ops;\r\ndev->watchdog_timeo = HZ;\r\ndev->tx_queue_len = 100;\r\nsc->lmc_device = dev;\r\nsc->name = dev->name;\r\nsc->if_type = LMC_PPP;\r\nsc->check = 0xBEAFCAFE;\r\ndev->base_addr = pci_resource_start(pdev, 0);\r\ndev->irq = pdev->irq;\r\npci_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nlmc_proto_attach(sc);\r\nspin_lock_init(&sc->lmc_lock);\r\npci_set_master(pdev);\r\nprintk(KERN_INFO "%s: detected at %lx, irq %d\n", dev->name,\r\ndev->base_addr, dev->irq);\r\nerr = register_hdlc_device(dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: register_netdev failed.\n", dev->name);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nsc->lmc_cardtype = LMC_CARDTYPE_UNKNOWN;\r\nsc->lmc_timing = LMC_CTL_CLOCK_SOURCE_EXT;\r\nif ((subdevice = pdev->subsystem_device) == PCI_VENDOR_ID_LMC)\r\nsubdevice = pdev->subsystem_vendor;\r\nswitch (subdevice) {\r\ncase PCI_DEVICE_ID_LMC_HSSI:\r\nprintk(KERN_INFO "%s: LMC HSSI\n", dev->name);\r\nsc->lmc_cardtype = LMC_CARDTYPE_HSSI;\r\nsc->lmc_media = &lmc_hssi_media;\r\nbreak;\r\ncase PCI_DEVICE_ID_LMC_DS3:\r\nprintk(KERN_INFO "%s: LMC DS3\n", dev->name);\r\nsc->lmc_cardtype = LMC_CARDTYPE_DS3;\r\nsc->lmc_media = &lmc_ds3_media;\r\nbreak;\r\ncase PCI_DEVICE_ID_LMC_SSI:\r\nprintk(KERN_INFO "%s: LMC SSI\n", dev->name);\r\nsc->lmc_cardtype = LMC_CARDTYPE_SSI;\r\nsc->lmc_media = &lmc_ssi_media;\r\nbreak;\r\ncase PCI_DEVICE_ID_LMC_T1:\r\nprintk(KERN_INFO "%s: LMC T1\n", dev->name);\r\nsc->lmc_cardtype = LMC_CARDTYPE_T1;\r\nsc->lmc_media = &lmc_t1_media;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: LMC UNKNOWN CARD!\n", dev->name);\r\nbreak;\r\n}\r\nlmc_initcsrs (sc, dev->base_addr, 8);\r\nlmc_gpio_mkinput (sc, 0xff);\r\nsc->lmc_gpio = 0;\r\nsc->lmc_media->defaults (sc);\r\nsc->lmc_media->set_link_status (sc, LMC_LINK_UP);\r\nAdapModelNum = (lmc_mii_readreg (sc, 0, 3) & 0x3f0) >> 4;\r\nif ((AdapModelNum != LMC_ADAP_T1 ||\r\nsubdevice != PCI_DEVICE_ID_LMC_T1) &&\r\n(AdapModelNum != LMC_ADAP_SSI ||\r\nsubdevice != PCI_DEVICE_ID_LMC_SSI) &&\r\n(AdapModelNum != LMC_ADAP_DS3 ||\r\nsubdevice != PCI_DEVICE_ID_LMC_DS3) &&\r\n(AdapModelNum != LMC_ADAP_HSSI ||\r\nsubdevice != PCI_DEVICE_ID_LMC_HSSI))\r\nprintk(KERN_WARNING "%s: Model number (%d) miscompare for PCI"\r\n" Subsystem ID = 0x%04x\n",\r\ndev->name, AdapModelNum, subdevice);\r\nLMC_CSR_WRITE (sc, csr_gp_timer, 0xFFFFFFFFUL);\r\nsc->board_idx = cards_found++;\r\nsc->extra_stats.check = STATCHECK;\r\nsc->extra_stats.version_size = (DRIVER_VERSION << 16) +\r\nsizeof(sc->lmc_device->stats) + sizeof(sc->extra_stats);\r\nsc->extra_stats.lmc_cardtype = sc->lmc_cardtype;\r\nsc->lmc_ok = 0;\r\nsc->last_link_status = 0;\r\nlmc_trace(dev, "lmc_init_one out");\r\nreturn 0;\r\n}\r\nstatic void lmc_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev) {\r\nprintk(KERN_DEBUG "%s: removing...\n", dev->name);\r\nunregister_hdlc_device(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nstatic int lmc_open(struct net_device *dev)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nint err;\r\nlmc_trace(dev, "lmc_open in");\r\nlmc_led_on(sc, LMC_DS3_LED0);\r\nlmc_dec_reset(sc);\r\nlmc_reset(sc);\r\nLMC_EVENT_LOG(LMC_EVENT_RESET1, LMC_CSR_READ(sc, csr_status), 0);\r\nLMC_EVENT_LOG(LMC_EVENT_RESET2, lmc_mii_readreg(sc, 0, 16),\r\nlmc_mii_readreg(sc, 0, 17));\r\nif (sc->lmc_ok){\r\nlmc_trace(dev, "lmc_open lmc_ok out");\r\nreturn 0;\r\n}\r\nlmc_softreset (sc);\r\nif (request_irq (dev->irq, lmc_interrupt, IRQF_SHARED, dev->name, dev)){\r\nprintk(KERN_WARNING "%s: could not get irq: %d\n", dev->name, dev->irq);\r\nlmc_trace(dev, "lmc_open irq failed out");\r\nreturn -EAGAIN;\r\n}\r\nsc->got_irq = 1;\r\nsc->lmc_miireg16 |= LMC_MII16_LED_ALL;\r\nsc->lmc_media->set_link_status (sc, LMC_LINK_UP);\r\nsc->lmc_media->set_status (sc, NULL);\r\nsc->TxDescriptControlInit = (\r\nLMC_TDES_INTERRUPT_ON_COMPLETION\r\n| LMC_TDES_FIRST_SEGMENT\r\n| LMC_TDES_LAST_SEGMENT\r\n| LMC_TDES_SECOND_ADDR_CHAINED\r\n| LMC_TDES_DISABLE_PADDING\r\n);\r\nif (sc->ictl.crc_length == LMC_CTL_CRC_LENGTH_16) {\r\nsc->TxDescriptControlInit |= LMC_TDES_ADD_CRC_DISABLE;\r\n}\r\nsc->lmc_media->set_crc_length(sc, sc->ictl.crc_length);\r\nif ((err = lmc_proto_open(sc)) != 0)\r\nreturn err;\r\nnetif_start_queue(dev);\r\nsc->extra_stats.tx_tbusy0++;\r\nsc->lmc_intrmask = 0;\r\nsc->lmc_intrmask |= (TULIP_STS_NORMALINTR\r\n| TULIP_STS_RXINTR\r\n| TULIP_STS_TXINTR\r\n| TULIP_STS_ABNRMLINTR\r\n| TULIP_STS_SYSERROR\r\n| TULIP_STS_TXSTOPPED\r\n| TULIP_STS_TXUNDERFLOW\r\n| TULIP_STS_RXSTOPPED\r\n| TULIP_STS_RXNOBUF\r\n);\r\nLMC_CSR_WRITE (sc, csr_intr, sc->lmc_intrmask);\r\nsc->lmc_cmdmode |= TULIP_CMD_TXRUN;\r\nsc->lmc_cmdmode |= TULIP_CMD_RXRUN;\r\nLMC_CSR_WRITE (sc, csr_command, sc->lmc_cmdmode);\r\nsc->lmc_ok = 1;\r\nsc->last_link_status = 1;\r\ninit_timer (&sc->timer);\r\nsc->timer.expires = jiffies + HZ;\r\nsc->timer.data = (unsigned long) dev;\r\nsc->timer.function = lmc_watchdog;\r\nadd_timer (&sc->timer);\r\nlmc_trace(dev, "lmc_open out");\r\nreturn 0;\r\n}\r\nstatic void lmc_running_reset (struct net_device *dev)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nlmc_trace(dev, "lmc_running_reset in");\r\nLMC_CSR_WRITE (sc, csr_intr, 0x00000000);\r\nlmc_dec_reset (sc);\r\nlmc_reset (sc);\r\nlmc_softreset (sc);\r\nsc->lmc_media->set_link_status (sc, 1);\r\nsc->lmc_media->set_status (sc, NULL);\r\nnetif_wake_queue(dev);\r\nsc->lmc_txfull = 0;\r\nsc->extra_stats.tx_tbusy0++;\r\nsc->lmc_intrmask = TULIP_DEFAULT_INTR_MASK;\r\nLMC_CSR_WRITE (sc, csr_intr, sc->lmc_intrmask);\r\nsc->lmc_cmdmode |= (TULIP_CMD_TXRUN | TULIP_CMD_RXRUN);\r\nLMC_CSR_WRITE (sc, csr_command, sc->lmc_cmdmode);\r\nlmc_trace(dev, "lmc_runnin_reset_out");\r\n}\r\nstatic int lmc_close(struct net_device *dev)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nlmc_trace(dev, "lmc_close in");\r\nsc->lmc_ok = 0;\r\nsc->lmc_media->set_link_status (sc, 0);\r\ndel_timer (&sc->timer);\r\nlmc_proto_close(sc);\r\nlmc_ifdown (dev);\r\nlmc_trace(dev, "lmc_close out");\r\nreturn 0;\r\n}\r\nstatic int lmc_ifdown (struct net_device *dev)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nu32 csr6;\r\nint i;\r\nlmc_trace(dev, "lmc_ifdown in");\r\nnetif_stop_queue(dev);\r\nsc->extra_stats.tx_tbusy1++;\r\nLMC_CSR_WRITE (sc, csr_intr, 0x00000000);\r\ncsr6 = LMC_CSR_READ (sc, csr_command);\r\ncsr6 &= ~LMC_DEC_ST;\r\ncsr6 &= ~LMC_DEC_SR;\r\nLMC_CSR_WRITE (sc, csr_command, csr6);\r\nsc->lmc_device->stats.rx_missed_errors +=\r\nLMC_CSR_READ(sc, csr_missed_frames) & 0xffff;\r\nif(sc->got_irq == 1){\r\nfree_irq (dev->irq, dev);\r\nsc->got_irq = 0;\r\n}\r\nfor (i = 0; i < LMC_RXDESCS; i++)\r\n{\r\nstruct sk_buff *skb = sc->lmc_rxq[i];\r\nsc->lmc_rxq[i] = NULL;\r\nsc->lmc_rxring[i].status = 0;\r\nsc->lmc_rxring[i].length = 0;\r\nsc->lmc_rxring[i].buffer1 = 0xDEADBEEF;\r\nif (skb != NULL)\r\ndev_kfree_skb(skb);\r\nsc->lmc_rxq[i] = NULL;\r\n}\r\nfor (i = 0; i < LMC_TXDESCS; i++)\r\n{\r\nif (sc->lmc_txq[i] != NULL)\r\ndev_kfree_skb(sc->lmc_txq[i]);\r\nsc->lmc_txq[i] = NULL;\r\n}\r\nlmc_led_off (sc, LMC_MII16_LED_ALL);\r\nnetif_wake_queue(dev);\r\nsc->extra_stats.tx_tbusy0++;\r\nlmc_trace(dev, "lmc_ifdown out");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t lmc_interrupt (int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_instance;\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nu32 csr;\r\nint i;\r\ns32 stat;\r\nunsigned int badtx;\r\nu32 firstcsr;\r\nint max_work = LMC_RXDESCS;\r\nint handled = 0;\r\nlmc_trace(dev, "lmc_interrupt in");\r\nspin_lock(&sc->lmc_lock);\r\ncsr = LMC_CSR_READ (sc, csr_status);\r\nif ( ! (csr & sc->lmc_intrmask)) {\r\ngoto lmc_int_fail_out;\r\n}\r\nfirstcsr = csr;\r\nwhile (csr & sc->lmc_intrmask) {\r\nhandled = 1;\r\nLMC_CSR_WRITE (sc, csr_status, csr);\r\nif (csr & TULIP_STS_ABNRMLINTR){\r\nlmc_running_reset (dev);\r\nbreak;\r\n}\r\nif (csr & TULIP_STS_RXINTR){\r\nlmc_trace(dev, "rx interrupt");\r\nlmc_rx (dev);\r\n}\r\nif (csr & (TULIP_STS_TXINTR | TULIP_STS_TXNOBUF | TULIP_STS_TXSTOPPED)) {\r\nint n_compl = 0 ;\r\nsc->extra_stats.tx_NoCompleteCnt = 0;\r\nbadtx = sc->lmc_taint_tx;\r\ni = badtx % LMC_TXDESCS;\r\nwhile ((badtx < sc->lmc_next_tx)) {\r\nstat = sc->lmc_txring[i].status;\r\nLMC_EVENT_LOG (LMC_EVENT_XMTINT, stat,\r\nsc->lmc_txring[i].length);\r\nif (stat & 0x80000000)\r\nbreak;\r\nn_compl++ ;\r\nif (sc->lmc_txq[i] == NULL)\r\ncontinue;\r\nif (stat & 0x8000) {\r\nsc->lmc_device->stats.tx_errors++;\r\nif (stat & 0x4104)\r\nsc->lmc_device->stats.tx_aborted_errors++;\r\nif (stat & 0x0C00)\r\nsc->lmc_device->stats.tx_carrier_errors++;\r\nif (stat & 0x0200)\r\nsc->lmc_device->stats.tx_window_errors++;\r\nif (stat & 0x0002)\r\nsc->lmc_device->stats.tx_fifo_errors++;\r\n} else {\r\nsc->lmc_device->stats.tx_bytes += sc->lmc_txring[i].length & 0x7ff;\r\nsc->lmc_device->stats.tx_packets++;\r\n}\r\ndev_kfree_skb_irq(sc->lmc_txq[i]);\r\nsc->lmc_txq[i] = NULL;\r\nbadtx++;\r\ni = badtx % LMC_TXDESCS;\r\n}\r\nif (sc->lmc_next_tx - badtx > LMC_TXDESCS)\r\n{\r\nprintk ("%s: out of sync pointer\n", dev->name);\r\nbadtx += LMC_TXDESCS;\r\n}\r\nLMC_EVENT_LOG(LMC_EVENT_TBUSY0, n_compl, 0);\r\nsc->lmc_txfull = 0;\r\nnetif_wake_queue(dev);\r\nsc->extra_stats.tx_tbusy0++;\r\n#ifdef DEBUG\r\nsc->extra_stats.dirtyTx = badtx;\r\nsc->extra_stats.lmc_next_tx = sc->lmc_next_tx;\r\nsc->extra_stats.lmc_txfull = sc->lmc_txfull;\r\n#endif\r\nsc->lmc_taint_tx = badtx;\r\n}\r\nif (csr & TULIP_STS_SYSERROR) {\r\nu32 error;\r\nprintk (KERN_WARNING "%s: system bus error csr: %#8.8x\n", dev->name, csr);\r\nerror = csr>>23 & 0x7;\r\nswitch(error){\r\ncase 0x000:\r\nprintk(KERN_WARNING "%s: Parity Fault (bad)\n", dev->name);\r\nbreak;\r\ncase 0x001:\r\nprintk(KERN_WARNING "%s: Master Abort (naughty)\n", dev->name);\r\nbreak;\r\ncase 0x010:\r\nprintk(KERN_WARNING "%s: Target Abort (not so naughty)\n", dev->name);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: This bus error code was supposed to be reserved!\n", dev->name);\r\n}\r\nlmc_dec_reset (sc);\r\nlmc_reset (sc);\r\nLMC_EVENT_LOG(LMC_EVENT_RESET1, LMC_CSR_READ (sc, csr_status), 0);\r\nLMC_EVENT_LOG(LMC_EVENT_RESET2,\r\nlmc_mii_readreg (sc, 0, 16),\r\nlmc_mii_readreg (sc, 0, 17));\r\n}\r\nif(max_work-- <= 0)\r\nbreak;\r\ncsr = LMC_CSR_READ (sc, csr_status);\r\n}\r\nLMC_EVENT_LOG(LMC_EVENT_INT, firstcsr, csr);\r\nlmc_int_fail_out:\r\nspin_unlock(&sc->lmc_lock);\r\nlmc_trace(dev, "lmc_interrupt out");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic netdev_tx_t lmc_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nu32 flag;\r\nint entry;\r\nunsigned long flags;\r\nlmc_trace(dev, "lmc_start_xmit in");\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nentry = sc->lmc_next_tx % LMC_TXDESCS;\r\nsc->lmc_txq[entry] = skb;\r\nsc->lmc_txring[entry].buffer1 = virt_to_bus (skb->data);\r\nLMC_CONSOLE_LOG("xmit", skb->data, skb->len);\r\n#ifndef GCOM\r\nif (sc->lmc_next_tx - sc->lmc_taint_tx < LMC_TXDESCS / 2)\r\n{\r\nflag = 0x60000000;\r\nnetif_wake_queue(dev);\r\n}\r\nelse if (sc->lmc_next_tx - sc->lmc_taint_tx == LMC_TXDESCS / 2)\r\n{\r\nflag = 0xe0000000;\r\nnetif_wake_queue(dev);\r\n}\r\nelse if (sc->lmc_next_tx - sc->lmc_taint_tx < LMC_TXDESCS - 1)\r\n{\r\nflag = 0x60000000;\r\nnetif_wake_queue(dev);\r\n}\r\nelse\r\n{\r\nflag = 0xe0000000;\r\nsc->lmc_txfull = 1;\r\nnetif_stop_queue(dev);\r\n}\r\n#else\r\nflag = LMC_TDES_INTERRUPT_ON_COMPLETION;\r\nif (sc->lmc_next_tx - sc->lmc_taint_tx >= LMC_TXDESCS - 1)\r\n{\r\nsc->lmc_txfull = 1;\r\nnetif_stop_queue(dev);\r\nsc->extra_stats.tx_tbusy1++;\r\nLMC_EVENT_LOG(LMC_EVENT_TBUSY1, entry, 0);\r\n}\r\n#endif\r\nif (entry == LMC_TXDESCS - 1)\r\nflag |= LMC_TDES_END_OF_RING;\r\nflag = sc->lmc_txring[entry].length = (skb->len) | flag |\r\nsc->TxDescriptControlInit;\r\nsc->extra_stats.tx_NoCompleteCnt++;\r\nsc->lmc_next_tx++;\r\nLMC_EVENT_LOG(LMC_EVENT_XMT, flag, entry);\r\nsc->lmc_txring[entry].status = 0x80000000;\r\nLMC_CSR_WRITE (sc, csr_txpoll, 0);\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nlmc_trace(dev, "lmc_start_xmit_out");\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int lmc_rx(struct net_device *dev)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nint i;\r\nint rx_work_limit = LMC_RXDESCS;\r\nunsigned int next_rx;\r\nint rxIntLoopCnt;\r\nint localLengthErrCnt = 0;\r\nlong stat;\r\nstruct sk_buff *skb, *nsb;\r\nu16 len;\r\nlmc_trace(dev, "lmc_rx in");\r\nlmc_led_on(sc, LMC_DS3_LED3);\r\nrxIntLoopCnt = 0;\r\ni = sc->lmc_next_rx % LMC_RXDESCS;\r\nnext_rx = sc->lmc_next_rx;\r\nwhile (((stat = sc->lmc_rxring[i].status) & LMC_RDES_OWN_BIT) != DESC_OWNED_BY_DC21X4)\r\n{\r\nrxIntLoopCnt++;\r\nlen = ((stat & LMC_RDES_FRAME_LENGTH) >> RDES_FRAME_LENGTH_BIT_NUMBER);\r\nif ((stat & 0x0300) != 0x0300) {\r\nif ((stat & 0x0000ffff) != 0x7fff) {\r\nsc->lmc_device->stats.rx_length_errors++;\r\ngoto skip_packet;\r\n}\r\n}\r\nif (stat & 0x00000008) {\r\nsc->lmc_device->stats.rx_errors++;\r\nsc->lmc_device->stats.rx_frame_errors++;\r\ngoto skip_packet;\r\n}\r\nif (stat & 0x00000004) {\r\nsc->lmc_device->stats.rx_errors++;\r\nsc->lmc_device->stats.rx_crc_errors++;\r\ngoto skip_packet;\r\n}\r\nif (len > LMC_PKT_BUF_SZ) {\r\nsc->lmc_device->stats.rx_length_errors++;\r\nlocalLengthErrCnt++;\r\ngoto skip_packet;\r\n}\r\nif (len < sc->lmc_crcSize + 2) {\r\nsc->lmc_device->stats.rx_length_errors++;\r\nsc->extra_stats.rx_SmallPktCnt++;\r\nlocalLengthErrCnt++;\r\ngoto skip_packet;\r\n}\r\nif(stat & 0x00004000){\r\nprintk(KERN_WARNING "%s: Receiver descriptor error, receiver out of sync?\n", dev->name);\r\n}\r\nlen -= sc->lmc_crcSize;\r\nskb = sc->lmc_rxq[i];\r\nif (!skb) {\r\nnsb = dev_alloc_skb (LMC_PKT_BUF_SZ + 2);\r\nif (nsb) {\r\nsc->lmc_rxq[i] = nsb;\r\nnsb->dev = dev;\r\nsc->lmc_rxring[i].buffer1 = virt_to_bus(skb_tail_pointer(nsb));\r\n}\r\nsc->failed_recv_alloc = 1;\r\ngoto skip_packet;\r\n}\r\nsc->lmc_device->stats.rx_packets++;\r\nsc->lmc_device->stats.rx_bytes += len;\r\nLMC_CONSOLE_LOG("recv", skb->data, len);\r\nif(len > (LMC_MTU - (LMC_MTU>>2))){\r\ngive_it_anyways:\r\nsc->lmc_rxq[i] = NULL;\r\nsc->lmc_rxring[i].buffer1 = 0x0;\r\nskb_put (skb, len);\r\nskb->protocol = lmc_proto_type(sc, skb);\r\nskb_reset_mac_header(skb);\r\nskb->dev = dev;\r\nlmc_proto_netif(sc, skb);\r\nnsb = dev_alloc_skb (LMC_PKT_BUF_SZ + 2);\r\nif (nsb) {\r\nsc->lmc_rxq[i] = nsb;\r\nnsb->dev = dev;\r\nsc->lmc_rxring[i].buffer1 = virt_to_bus(skb_tail_pointer(nsb));\r\n}\r\nelse {\r\nsc->extra_stats.rx_BuffAllocErr++;\r\nLMC_EVENT_LOG(LMC_EVENT_RCVINT, stat, len);\r\nsc->failed_recv_alloc = 1;\r\ngoto skip_out_of_mem;\r\n}\r\n}\r\nelse {\r\nnsb = dev_alloc_skb(len);\r\nif(!nsb) {\r\ngoto give_it_anyways;\r\n}\r\nskb_copy_from_linear_data(skb, skb_put(nsb, len), len);\r\nnsb->protocol = lmc_proto_type(sc, nsb);\r\nskb_reset_mac_header(nsb);\r\nnsb->dev = dev;\r\nlmc_proto_netif(sc, nsb);\r\n}\r\nskip_packet:\r\nLMC_EVENT_LOG(LMC_EVENT_RCVINT, stat, len);\r\nsc->lmc_rxring[i].status = DESC_OWNED_BY_DC21X4;\r\nsc->lmc_next_rx++;\r\ni = sc->lmc_next_rx % LMC_RXDESCS;\r\nrx_work_limit--;\r\nif (rx_work_limit < 0)\r\nbreak;\r\n}\r\nif (rxIntLoopCnt > sc->extra_stats.rxIntLoopCnt)\r\nsc->extra_stats.rxIntLoopCnt = rxIntLoopCnt;\r\n#ifdef DEBUG\r\nif (rxIntLoopCnt == 0)\r\n{\r\nfor (i = 0; i < LMC_RXDESCS; i++)\r\n{\r\nif ((sc->lmc_rxring[i].status & LMC_RDES_OWN_BIT)\r\n!= DESC_OWNED_BY_DC21X4)\r\n{\r\nrxIntLoopCnt++;\r\n}\r\n}\r\nLMC_EVENT_LOG(LMC_EVENT_RCVEND, rxIntLoopCnt, 0);\r\n}\r\n#endif\r\nlmc_led_off(sc, LMC_DS3_LED3);\r\nskip_out_of_mem:\r\nlmc_trace(dev, "lmc_rx out");\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *lmc_get_stats(struct net_device *dev)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nunsigned long flags;\r\nlmc_trace(dev, "lmc_get_stats in");\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nsc->lmc_device->stats.rx_missed_errors += LMC_CSR_READ(sc, csr_missed_frames) & 0xffff;\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nlmc_trace(dev, "lmc_get_stats out");\r\nreturn &sc->lmc_device->stats;\r\n}\r\nunsigned lmc_mii_readreg (lmc_softc_t * const sc, unsigned devaddr, unsigned regno)\r\n{\r\nint i;\r\nint command = (0xf6 << 10) | (devaddr << 5) | regno;\r\nint retval = 0;\r\nlmc_trace(sc->lmc_device, "lmc_mii_readreg in");\r\nLMC_MII_SYNC (sc);\r\nlmc_trace(sc->lmc_device, "lmc_mii_readreg: done sync");\r\nfor (i = 15; i >= 0; i--)\r\n{\r\nint dataval = (command & (1 << i)) ? 0x20000 : 0;\r\nLMC_CSR_WRITE (sc, csr_9, dataval);\r\nlmc_delay ();\r\nLMC_CSR_WRITE (sc, csr_9, dataval | 0x10000);\r\nlmc_delay ();\r\n}\r\nlmc_trace(sc->lmc_device, "lmc_mii_readreg: done1");\r\nfor (i = 19; i > 0; i--)\r\n{\r\nLMC_CSR_WRITE (sc, csr_9, 0x40000);\r\nlmc_delay ();\r\nretval = (retval << 1) | ((LMC_CSR_READ (sc, csr_9) & 0x80000) ? 1 : 0);\r\nLMC_CSR_WRITE (sc, csr_9, 0x40000 | 0x10000);\r\nlmc_delay ();\r\n}\r\nlmc_trace(sc->lmc_device, "lmc_mii_readreg out");\r\nreturn (retval >> 1) & 0xffff;\r\n}\r\nvoid lmc_mii_writereg (lmc_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data)\r\n{\r\nint i = 32;\r\nint command = (0x5002 << 16) | (devaddr << 23) | (regno << 18) | data;\r\nlmc_trace(sc->lmc_device, "lmc_mii_writereg in");\r\nLMC_MII_SYNC (sc);\r\ni = 31;\r\nwhile (i >= 0)\r\n{\r\nint datav;\r\nif (command & (1 << i))\r\ndatav = 0x20000;\r\nelse\r\ndatav = 0x00000;\r\nLMC_CSR_WRITE (sc, csr_9, datav);\r\nlmc_delay ();\r\nLMC_CSR_WRITE (sc, csr_9, (datav | 0x10000));\r\nlmc_delay ();\r\ni--;\r\n}\r\ni = 2;\r\nwhile (i > 0)\r\n{\r\nLMC_CSR_WRITE (sc, csr_9, 0x40000);\r\nlmc_delay ();\r\nLMC_CSR_WRITE (sc, csr_9, 0x50000);\r\nlmc_delay ();\r\ni--;\r\n}\r\nlmc_trace(sc->lmc_device, "lmc_mii_writereg out");\r\n}\r\nstatic void lmc_softreset (lmc_softc_t * const sc)\r\n{\r\nint i;\r\nlmc_trace(sc->lmc_device, "lmc_softreset in");\r\nsc->lmc_txfull = 0;\r\nsc->lmc_next_rx = 0;\r\nsc->lmc_next_tx = 0;\r\nsc->lmc_taint_rx = 0;\r\nsc->lmc_taint_tx = 0;\r\nfor (i = 0; i < LMC_RXDESCS; i++)\r\n{\r\nstruct sk_buff *skb;\r\nif (sc->lmc_rxq[i] == NULL)\r\n{\r\nskb = dev_alloc_skb (LMC_PKT_BUF_SZ + 2);\r\nif(skb == NULL){\r\nprintk(KERN_WARNING "%s: Failed to allocate receiver ring, will try again\n", sc->name);\r\nsc->failed_ring = 1;\r\nbreak;\r\n}\r\nelse{\r\nsc->lmc_rxq[i] = skb;\r\n}\r\n}\r\nelse\r\n{\r\nskb = sc->lmc_rxq[i];\r\n}\r\nskb->dev = sc->lmc_device;\r\nsc->lmc_rxring[i].status = 0x80000000;\r\nsc->lmc_rxring[i].length = skb_tailroom(skb);\r\nsc->lmc_rxring[i].buffer1 = virt_to_bus (skb->data);\r\nsc->lmc_rxring[i].buffer2 = virt_to_bus (&sc->lmc_rxring[i + 1]);\r\n}\r\nif (i != 0) {\r\nsc->lmc_rxring[i - 1].length |= 0x02000000;\r\nsc->lmc_rxring[i - 1].buffer2 = virt_to_bus(&sc->lmc_rxring[0]);\r\n}\r\nLMC_CSR_WRITE (sc, csr_rxlist, virt_to_bus (sc->lmc_rxring));\r\nfor (i = 0; i < LMC_TXDESCS; i++)\r\n{\r\nif (sc->lmc_txq[i] != NULL){\r\ndev_kfree_skb(sc->lmc_txq[i]);\r\nsc->lmc_device->stats.tx_dropped++;\r\n}\r\nsc->lmc_txq[i] = NULL;\r\nsc->lmc_txring[i].status = 0x00000000;\r\nsc->lmc_txring[i].buffer2 = virt_to_bus (&sc->lmc_txring[i + 1]);\r\n}\r\nsc->lmc_txring[i - 1].buffer2 = virt_to_bus (&sc->lmc_txring[0]);\r\nLMC_CSR_WRITE (sc, csr_txlist, virt_to_bus (sc->lmc_txring));\r\nlmc_trace(sc->lmc_device, "lmc_softreset out");\r\n}\r\nvoid lmc_gpio_mkinput(lmc_softc_t * const sc, u32 bits)\r\n{\r\nlmc_trace(sc->lmc_device, "lmc_gpio_mkinput in");\r\nsc->lmc_gpio_io &= ~bits;\r\nLMC_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET | (sc->lmc_gpio_io));\r\nlmc_trace(sc->lmc_device, "lmc_gpio_mkinput out");\r\n}\r\nvoid lmc_gpio_mkoutput(lmc_softc_t * const sc, u32 bits)\r\n{\r\nlmc_trace(sc->lmc_device, "lmc_gpio_mkoutput in");\r\nsc->lmc_gpio_io |= bits;\r\nLMC_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET | (sc->lmc_gpio_io));\r\nlmc_trace(sc->lmc_device, "lmc_gpio_mkoutput out");\r\n}\r\nvoid lmc_led_on(lmc_softc_t * const sc, u32 led)\r\n{\r\nlmc_trace(sc->lmc_device, "lmc_led_on in");\r\nif((~sc->lmc_miireg16) & led){\r\nlmc_trace(sc->lmc_device, "lmc_led_on aon out");\r\nreturn;\r\n}\r\nsc->lmc_miireg16 &= ~led;\r\nlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\r\nlmc_trace(sc->lmc_device, "lmc_led_on out");\r\n}\r\nvoid lmc_led_off(lmc_softc_t * const sc, u32 led)\r\n{\r\nlmc_trace(sc->lmc_device, "lmc_led_off in");\r\nif(sc->lmc_miireg16 & led){\r\nlmc_trace(sc->lmc_device, "lmc_led_off aoff out");\r\nreturn;\r\n}\r\nsc->lmc_miireg16 |= led;\r\nlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\r\nlmc_trace(sc->lmc_device, "lmc_led_off out");\r\n}\r\nstatic void lmc_reset(lmc_softc_t * const sc)\r\n{\r\nlmc_trace(sc->lmc_device, "lmc_reset in");\r\nsc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;\r\nlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\r\nsc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;\r\nlmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);\r\nlmc_gpio_mkoutput(sc, LMC_GEP_RESET);\r\nsc->lmc_gpio &= ~(LMC_GEP_RESET);\r\nLMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);\r\nudelay(50);\r\nlmc_gpio_mkinput(sc, LMC_GEP_RESET);\r\nsc->lmc_media->init(sc);\r\nsc->extra_stats.resetCount++;\r\nlmc_trace(sc->lmc_device, "lmc_reset out");\r\n}\r\nstatic void lmc_dec_reset(lmc_softc_t * const sc)\r\n{\r\nu32 val;\r\nlmc_trace(sc->lmc_device, "lmc_dec_reset in");\r\nsc->lmc_intrmask = 0;\r\nLMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);\r\nLMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\r\nudelay(25);\r\n#ifdef __sparc__\r\nsc->lmc_busmode = LMC_CSR_READ(sc, csr_busmode);\r\nsc->lmc_busmode = 0x00100000;\r\nsc->lmc_busmode &= ~TULIP_BUSMODE_SWRESET;\r\nLMC_CSR_WRITE(sc, csr_busmode, sc->lmc_busmode);\r\n#endif\r\nsc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);\r\nsc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS\r\n| TULIP_CMD_FULLDUPLEX\r\n| TULIP_CMD_PASSBADPKT\r\n| TULIP_CMD_NOHEARTBEAT\r\n| TULIP_CMD_PORTSELECT\r\n| TULIP_CMD_RECEIVEALL\r\n| TULIP_CMD_MUSTBEONE\r\n);\r\nsc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE\r\n| TULIP_CMD_THRESHOLDCTL\r\n| TULIP_CMD_STOREFWD\r\n| TULIP_CMD_TXTHRSHLDCTL\r\n);\r\nLMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);\r\nval = LMC_CSR_READ(sc, csr_sia_general);\r\nval |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);\r\nLMC_CSR_WRITE(sc, csr_sia_general, val);\r\nlmc_trace(sc->lmc_device, "lmc_dec_reset out");\r\n}\r\nstatic void lmc_initcsrs(lmc_softc_t * const sc, lmc_csrptr_t csr_base,\r\nsize_t csr_size)\r\n{\r\nlmc_trace(sc->lmc_device, "lmc_initcsrs in");\r\nsc->lmc_csrs.csr_busmode = csr_base + 0 * csr_size;\r\nsc->lmc_csrs.csr_txpoll = csr_base + 1 * csr_size;\r\nsc->lmc_csrs.csr_rxpoll = csr_base + 2 * csr_size;\r\nsc->lmc_csrs.csr_rxlist = csr_base + 3 * csr_size;\r\nsc->lmc_csrs.csr_txlist = csr_base + 4 * csr_size;\r\nsc->lmc_csrs.csr_status = csr_base + 5 * csr_size;\r\nsc->lmc_csrs.csr_command = csr_base + 6 * csr_size;\r\nsc->lmc_csrs.csr_intr = csr_base + 7 * csr_size;\r\nsc->lmc_csrs.csr_missed_frames = csr_base + 8 * csr_size;\r\nsc->lmc_csrs.csr_9 = csr_base + 9 * csr_size;\r\nsc->lmc_csrs.csr_10 = csr_base + 10 * csr_size;\r\nsc->lmc_csrs.csr_11 = csr_base + 11 * csr_size;\r\nsc->lmc_csrs.csr_12 = csr_base + 12 * csr_size;\r\nsc->lmc_csrs.csr_13 = csr_base + 13 * csr_size;\r\nsc->lmc_csrs.csr_14 = csr_base + 14 * csr_size;\r\nsc->lmc_csrs.csr_15 = csr_base + 15 * csr_size;\r\nlmc_trace(sc->lmc_device, "lmc_initcsrs out");\r\n}\r\nstatic void lmc_driver_timeout(struct net_device *dev)\r\n{\r\nlmc_softc_t *sc = dev_to_sc(dev);\r\nu32 csr6;\r\nunsigned long flags;\r\nlmc_trace(dev, "lmc_driver_timeout in");\r\nspin_lock_irqsave(&sc->lmc_lock, flags);\r\nprintk("%s: Xmitter busy|\n", dev->name);\r\nsc->extra_stats.tx_tbusy_calls++;\r\nif (jiffies - dev_trans_start(dev) < TX_TIMEOUT)\r\ngoto bug_out;\r\nLMC_EVENT_LOG(LMC_EVENT_XMTPRCTMO,\r\nLMC_CSR_READ (sc, csr_status),\r\nsc->extra_stats.tx_ProcTimeout);\r\nlmc_running_reset (dev);\r\nLMC_EVENT_LOG(LMC_EVENT_RESET1, LMC_CSR_READ (sc, csr_status), 0);\r\nLMC_EVENT_LOG(LMC_EVENT_RESET2,\r\nlmc_mii_readreg (sc, 0, 16),\r\nlmc_mii_readreg (sc, 0, 17));\r\ncsr6 = LMC_CSR_READ (sc, csr_command);\r\nLMC_CSR_WRITE (sc, csr_command, csr6 | 0x0002);\r\nLMC_CSR_WRITE (sc, csr_command, csr6 | 0x2002);\r\nLMC_CSR_WRITE (sc, csr_txpoll, 0);\r\nsc->lmc_device->stats.tx_errors++;\r\nsc->extra_stats.tx_ProcTimeout++;\r\nnetif_trans_update(dev);\r\nbug_out:\r\nspin_unlock_irqrestore(&sc->lmc_lock, flags);\r\nlmc_trace(dev, "lmc_driver_timeout out");\r\n}
