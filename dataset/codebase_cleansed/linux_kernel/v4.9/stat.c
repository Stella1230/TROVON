void update_stats(struct stats *stats, u64 val)\r\n{\r\ndouble delta;\r\nstats->n++;\r\ndelta = val - stats->mean;\r\nstats->mean += delta / stats->n;\r\nstats->M2 += delta*(val - stats->mean);\r\nif (val > stats->max)\r\nstats->max = val;\r\nif (val < stats->min)\r\nstats->min = val;\r\n}\r\ndouble avg_stats(struct stats *stats)\r\n{\r\nreturn stats->mean;\r\n}\r\ndouble stddev_stats(struct stats *stats)\r\n{\r\ndouble variance, variance_mean;\r\nif (stats->n < 2)\r\nreturn 0.0;\r\nvariance = stats->M2 / (stats->n - 1);\r\nvariance_mean = variance / stats->n;\r\nreturn sqrt(variance_mean);\r\n}\r\ndouble rel_stddev_stats(double stddev, double avg)\r\n{\r\ndouble pct = 0.0;\r\nif (avg)\r\npct = 100.0 * stddev/avg;\r\nreturn pct;\r\n}\r\nbool __perf_evsel_stat__is(struct perf_evsel *evsel,\r\nenum perf_stat_evsel_id id)\r\n{\r\nstruct perf_stat_evsel *ps = evsel->priv;\r\nreturn ps->id == id;\r\n}\r\nvoid perf_stat_evsel_id_init(struct perf_evsel *evsel)\r\n{\r\nstruct perf_stat_evsel *ps = evsel->priv;\r\nint i;\r\nfor (i = 0; i < PERF_STAT_EVSEL_ID__MAX; i++) {\r\nif (!strcmp(perf_evsel__name(evsel), id_str[i])) {\r\nps->id = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void perf_evsel__reset_stat_priv(struct perf_evsel *evsel)\r\n{\r\nint i;\r\nstruct perf_stat_evsel *ps = evsel->priv;\r\nfor (i = 0; i < 3; i++)\r\ninit_stats(&ps->res_stats[i]);\r\nperf_stat_evsel_id_init(evsel);\r\n}\r\nstatic int perf_evsel__alloc_stat_priv(struct perf_evsel *evsel)\r\n{\r\nevsel->priv = zalloc(sizeof(struct perf_stat_evsel));\r\nif (evsel->priv == NULL)\r\nreturn -ENOMEM;\r\nperf_evsel__reset_stat_priv(evsel);\r\nreturn 0;\r\n}\r\nstatic void perf_evsel__free_stat_priv(struct perf_evsel *evsel)\r\n{\r\nzfree(&evsel->priv);\r\n}\r\nstatic int perf_evsel__alloc_prev_raw_counts(struct perf_evsel *evsel,\r\nint ncpus, int nthreads)\r\n{\r\nstruct perf_counts *counts;\r\ncounts = perf_counts__new(ncpus, nthreads);\r\nif (counts)\r\nevsel->prev_raw_counts = counts;\r\nreturn counts ? 0 : -ENOMEM;\r\n}\r\nstatic void perf_evsel__free_prev_raw_counts(struct perf_evsel *evsel)\r\n{\r\nperf_counts__delete(evsel->prev_raw_counts);\r\nevsel->prev_raw_counts = NULL;\r\n}\r\nstatic int perf_evsel__alloc_stats(struct perf_evsel *evsel, bool alloc_raw)\r\n{\r\nint ncpus = perf_evsel__nr_cpus(evsel);\r\nint nthreads = thread_map__nr(evsel->threads);\r\nif (perf_evsel__alloc_stat_priv(evsel) < 0 ||\r\nperf_evsel__alloc_counts(evsel, ncpus, nthreads) < 0 ||\r\n(alloc_raw && perf_evsel__alloc_prev_raw_counts(evsel, ncpus, nthreads) < 0))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint perf_evlist__alloc_stats(struct perf_evlist *evlist, bool alloc_raw)\r\n{\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(evlist, evsel) {\r\nif (perf_evsel__alloc_stats(evsel, alloc_raw))\r\ngoto out_free;\r\n}\r\nreturn 0;\r\nout_free:\r\nperf_evlist__free_stats(evlist);\r\nreturn -1;\r\n}\r\nvoid perf_evlist__free_stats(struct perf_evlist *evlist)\r\n{\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(evlist, evsel) {\r\nperf_evsel__free_stat_priv(evsel);\r\nperf_evsel__free_counts(evsel);\r\nperf_evsel__free_prev_raw_counts(evsel);\r\n}\r\n}\r\nvoid perf_evlist__reset_stats(struct perf_evlist *evlist)\r\n{\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(evlist, evsel) {\r\nperf_evsel__reset_stat_priv(evsel);\r\nperf_evsel__reset_counts(evsel);\r\n}\r\n}\r\nstatic void zero_per_pkg(struct perf_evsel *counter)\r\n{\r\nif (counter->per_pkg_mask)\r\nmemset(counter->per_pkg_mask, 0, MAX_NR_CPUS);\r\n}\r\nstatic int check_per_pkg(struct perf_evsel *counter,\r\nstruct perf_counts_values *vals, int cpu, bool *skip)\r\n{\r\nunsigned long *mask = counter->per_pkg_mask;\r\nstruct cpu_map *cpus = perf_evsel__cpus(counter);\r\nint s;\r\n*skip = false;\r\nif (!counter->per_pkg)\r\nreturn 0;\r\nif (cpu_map__empty(cpus))\r\nreturn 0;\r\nif (!mask) {\r\nmask = zalloc(MAX_NR_CPUS);\r\nif (!mask)\r\nreturn -ENOMEM;\r\ncounter->per_pkg_mask = mask;\r\n}\r\nif (!(vals->run && vals->ena))\r\nreturn 0;\r\ns = cpu_map__get_socket(cpus, cpu, NULL);\r\nif (s < 0)\r\nreturn -1;\r\n*skip = test_and_set_bit(s, mask) == 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nprocess_counter_values(struct perf_stat_config *config, struct perf_evsel *evsel,\r\nint cpu, int thread,\r\nstruct perf_counts_values *count)\r\n{\r\nstruct perf_counts_values *aggr = &evsel->counts->aggr;\r\nstatic struct perf_counts_values zero;\r\nbool skip = false;\r\nif (check_per_pkg(evsel, count, cpu, &skip)) {\r\npr_err("failed to read per-pkg counter\n");\r\nreturn -1;\r\n}\r\nif (skip)\r\ncount = &zero;\r\nswitch (config->aggr_mode) {\r\ncase AGGR_THREAD:\r\ncase AGGR_CORE:\r\ncase AGGR_SOCKET:\r\ncase AGGR_NONE:\r\nif (!evsel->snapshot)\r\nperf_evsel__compute_deltas(evsel, cpu, thread, count);\r\nperf_counts_values__scale(count, config->scale, NULL);\r\nif (config->aggr_mode == AGGR_NONE)\r\nperf_stat__update_shadow_stats(evsel, count->values, cpu);\r\nbreak;\r\ncase AGGR_GLOBAL:\r\naggr->val += count->val;\r\nif (config->scale) {\r\naggr->ena += count->ena;\r\naggr->run += count->run;\r\n}\r\ncase AGGR_UNSET:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_counter_maps(struct perf_stat_config *config,\r\nstruct perf_evsel *counter)\r\n{\r\nint nthreads = thread_map__nr(counter->threads);\r\nint ncpus = perf_evsel__nr_cpus(counter);\r\nint cpu, thread;\r\nif (counter->system_wide)\r\nnthreads = 1;\r\nfor (thread = 0; thread < nthreads; thread++) {\r\nfor (cpu = 0; cpu < ncpus; cpu++) {\r\nif (process_counter_values(config, counter, cpu, thread,\r\nperf_counts(counter->counts, cpu, thread)))\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint perf_stat_process_counter(struct perf_stat_config *config,\r\nstruct perf_evsel *counter)\r\n{\r\nstruct perf_counts_values *aggr = &counter->counts->aggr;\r\nstruct perf_stat_evsel *ps = counter->priv;\r\nu64 *count = counter->counts->aggr.values;\r\nu64 val;\r\nint i, ret;\r\naggr->val = aggr->ena = aggr->run = 0;\r\nif (config->interval)\r\ninit_stats(ps->res_stats);\r\nif (counter->per_pkg)\r\nzero_per_pkg(counter);\r\nret = process_counter_maps(config, counter);\r\nif (ret)\r\nreturn ret;\r\nif (config->aggr_mode != AGGR_GLOBAL)\r\nreturn 0;\r\nif (!counter->snapshot)\r\nperf_evsel__compute_deltas(counter, -1, -1, aggr);\r\nperf_counts_values__scale(aggr, config->scale, &counter->counts->scaled);\r\nfor (i = 0; i < 3; i++)\r\nupdate_stats(&ps->res_stats[i], count[i]);\r\nif (verbose) {\r\nfprintf(config->output, "%s: %" PRIu64 " %" PRIu64 " %" PRIu64 "\n",\r\nperf_evsel__name(counter), count[0], count[1], count[2]);\r\n}\r\nval = counter->scale * *count;\r\nperf_stat__update_shadow_stats(counter, &val, 0);\r\nreturn 0;\r\n}\r\nint perf_event__process_stat_event(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nstruct perf_counts_values count;\r\nstruct stat_event *st = &event->stat;\r\nstruct perf_evsel *counter;\r\ncount.val = st->val;\r\ncount.ena = st->ena;\r\ncount.run = st->run;\r\ncounter = perf_evlist__id2evsel(session->evlist, st->id);\r\nif (!counter) {\r\npr_err("Failed to resolve counter for stat event.\n");\r\nreturn -EINVAL;\r\n}\r\n*perf_counts(counter->counts, st->cpu, st->thread) = count;\r\ncounter->supported = true;\r\nreturn 0;\r\n}\r\nsize_t perf_event__fprintf_stat(union perf_event *event, FILE *fp)\r\n{\r\nstruct stat_event *st = (struct stat_event *) event;\r\nsize_t ret;\r\nret = fprintf(fp, "\n... id %" PRIu64 ", cpu %d, thread %d\n",\r\nst->id, st->cpu, st->thread);\r\nret += fprintf(fp, "... value %" PRIu64 ", enabled %" PRIu64 ", running %" PRIu64 "\n",\r\nst->val, st->ena, st->run);\r\nreturn ret;\r\n}\r\nsize_t perf_event__fprintf_stat_round(union perf_event *event, FILE *fp)\r\n{\r\nstruct stat_round_event *rd = (struct stat_round_event *)event;\r\nsize_t ret;\r\nret = fprintf(fp, "\n... time %" PRIu64 ", type %s\n", rd->time,\r\nrd->type == PERF_STAT_ROUND_TYPE__FINAL ? "FINAL" : "INTERVAL");\r\nreturn ret;\r\n}\r\nsize_t perf_event__fprintf_stat_config(union perf_event *event, FILE *fp)\r\n{\r\nstruct perf_stat_config sc;\r\nsize_t ret;\r\nperf_event__read_stat_config(&sc, &event->stat_config);\r\nret = fprintf(fp, "\n");\r\nret += fprintf(fp, "... aggr_mode %d\n", sc.aggr_mode);\r\nret += fprintf(fp, "... scale %d\n", sc.scale);\r\nret += fprintf(fp, "... interval %u\n", sc.interval);\r\nreturn ret;\r\n}
