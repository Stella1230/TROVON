static int speedstep_find_register(void)\r\n{\r\nif (!speedstep_chipset_dev)\r\nreturn -ENODEV;\r\npci_read_config_dword(speedstep_chipset_dev, 0x40, &pmbase);\r\nif (!(pmbase & 0x01)) {\r\npr_err("could not find speedstep register\n");\r\nreturn -ENODEV;\r\n}\r\npmbase &= 0xFFFFFFFE;\r\nif (!pmbase) {\r\npr_err("could not find speedstep register\n");\r\nreturn -ENODEV;\r\n}\r\npr_debug("pmbase is 0x%x\n", pmbase);\r\nreturn 0;\r\n}\r\nstatic void speedstep_set_state(unsigned int state)\r\n{\r\nu8 pm2_blk;\r\nu8 value;\r\nunsigned long flags;\r\nif (state > 0x1)\r\nreturn;\r\nlocal_irq_save(flags);\r\nvalue = inb(pmbase + 0x50);\r\npr_debug("read at pmbase 0x%x + 0x50 returned 0x%x\n", pmbase, value);\r\nvalue &= 0xFE;\r\nvalue |= state;\r\npr_debug("writing 0x%x to pmbase 0x%x + 0x50\n", value, pmbase);\r\npm2_blk = inb(pmbase + 0x20);\r\npm2_blk |= 0x01;\r\noutb(pm2_blk, (pmbase + 0x20));\r\noutb(value, (pmbase + 0x50));\r\npm2_blk &= 0xfe;\r\noutb(pm2_blk, (pmbase + 0x20));\r\nvalue = inb(pmbase + 0x50);\r\nlocal_irq_restore(flags);\r\npr_debug("read at pmbase 0x%x + 0x50 returned 0x%x\n", pmbase, value);\r\nif (state == (value & 0x1))\r\npr_debug("change to %u MHz succeeded\n",\r\nspeedstep_get_frequency(speedstep_processor) / 1000);\r\nelse\r\npr_err("change failed - I/O error\n");\r\nreturn;\r\n}\r\nstatic void _speedstep_set_state(void *_state)\r\n{\r\nspeedstep_set_state(*(unsigned int *)_state);\r\n}\r\nstatic int speedstep_activate(void)\r\n{\r\nu16 value = 0;\r\nif (!speedstep_chipset_dev)\r\nreturn -EINVAL;\r\npci_read_config_word(speedstep_chipset_dev, 0x00A0, &value);\r\nif (!(value & 0x08)) {\r\nvalue |= 0x08;\r\npr_debug("activating SpeedStep (TM) registers\n");\r\npci_write_config_word(speedstep_chipset_dev, 0x00A0, value);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int speedstep_detect_chipset(void)\r\n{\r\nspeedstep_chipset_dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82801DB_12,\r\nPCI_ANY_ID, PCI_ANY_ID,\r\nNULL);\r\nif (speedstep_chipset_dev)\r\nreturn 4;\r\nspeedstep_chipset_dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82801CA_12,\r\nPCI_ANY_ID, PCI_ANY_ID,\r\nNULL);\r\nif (speedstep_chipset_dev)\r\nreturn 3;\r\nspeedstep_chipset_dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82801BA_10,\r\nPCI_ANY_ID, PCI_ANY_ID,\r\nNULL);\r\nif (speedstep_chipset_dev) {\r\nstatic struct pci_dev *hostbridge;\r\nhostbridge = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82815_MC,\r\nPCI_ANY_ID, PCI_ANY_ID,\r\nNULL);\r\nif (!hostbridge)\r\nreturn 2;\r\nif (hostbridge->revision < 5) {\r\npr_debug("hostbridge does not support speedstep\n");\r\nspeedstep_chipset_dev = NULL;\r\npci_dev_put(hostbridge);\r\nreturn 0;\r\n}\r\npci_dev_put(hostbridge);\r\nreturn 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic void get_freq_data(void *_speed)\r\n{\r\nunsigned int *speed = _speed;\r\n*speed = speedstep_get_frequency(speedstep_processor);\r\n}\r\nstatic unsigned int speedstep_get(unsigned int cpu)\r\n{\r\nunsigned int speed;\r\nif (smp_call_function_single(cpu, get_freq_data, &speed, 1) != 0)\r\nBUG();\r\npr_debug("detected %u kHz as current frequency\n", speed);\r\nreturn speed;\r\n}\r\nstatic int speedstep_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nunsigned int policy_cpu;\r\npolicy_cpu = cpumask_any_and(policy->cpus, cpu_online_mask);\r\nsmp_call_function_single(policy_cpu, _speedstep_set_state, &index,\r\ntrue);\r\nreturn 0;\r\n}\r\nstatic void get_freqs_on_cpu(void *_get_freqs)\r\n{\r\nstruct get_freqs *get_freqs = _get_freqs;\r\nget_freqs->ret =\r\nspeedstep_get_freqs(speedstep_processor,\r\n&speedstep_freqs[SPEEDSTEP_LOW].frequency,\r\n&speedstep_freqs[SPEEDSTEP_HIGH].frequency,\r\n&get_freqs->policy->cpuinfo.transition_latency,\r\n&speedstep_set_state);\r\n}\r\nstatic int speedstep_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int policy_cpu;\r\nstruct get_freqs gf;\r\n#ifdef CONFIG_SMP\r\ncpumask_copy(policy->cpus, topology_sibling_cpumask(policy->cpu));\r\n#endif\r\npolicy_cpu = cpumask_any_and(policy->cpus, cpu_online_mask);\r\ngf.policy = policy;\r\nsmp_call_function_single(policy_cpu, get_freqs_on_cpu, &gf, 1);\r\nif (gf.ret)\r\nreturn gf.ret;\r\nreturn cpufreq_table_validate_and_show(policy, speedstep_freqs);\r\n}\r\nstatic int __init speedstep_init(void)\r\n{\r\nif (!x86_match_cpu(ss_smi_ids))\r\nreturn -ENODEV;\r\nspeedstep_processor = speedstep_detect_processor();\r\nif (!speedstep_processor) {\r\npr_debug("Intel(R) SpeedStep(TM) capable processor "\r\n"not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (!speedstep_detect_chipset()) {\r\npr_debug("Intel(R) SpeedStep(TM) for this chipset not "\r\n"(yet) available.\n");\r\nreturn -ENODEV;\r\n}\r\nif (speedstep_activate()) {\r\npci_dev_put(speedstep_chipset_dev);\r\nreturn -EINVAL;\r\n}\r\nif (speedstep_find_register())\r\nreturn -ENODEV;\r\nreturn cpufreq_register_driver(&speedstep_driver);\r\n}\r\nstatic void __exit speedstep_exit(void)\r\n{\r\npci_dev_put(speedstep_chipset_dev);\r\ncpufreq_unregister_driver(&speedstep_driver);\r\n}
