static void __cg14_reset(struct cg14_par *par)\r\n{\r\nstruct cg14_regs __iomem *regs = par->regs;\r\nu8 val;\r\nval = sbus_readb(&regs->mcr);\r\nval &= ~(CG14_MCR_PIXMODE_MASK);\r\nsbus_writeb(val, &regs->mcr);\r\n}\r\nstatic int cg14_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct cg14_par *par = (struct cg14_par *) info->par;\r\nunsigned long flags;\r\nspin_lock_irqsave(&par->lock, flags);\r\n__cg14_reset(par);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nif (var->xoffset || var->yoffset || var->vmode)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cg14_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct cg14_par *par = (struct cg14_par *) info->par;\r\nstruct cg14_clut __iomem *clut = par->clut;\r\nunsigned long flags;\r\nu32 val;\r\nif (regno >= 256)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nval = (red | (green << 8) | (blue << 16));\r\nspin_lock_irqsave(&par->lock, flags);\r\nsbus_writel(val, &clut->c_clut[regno]);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cg14_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct cg14_par *par = (struct cg14_par *) info->par;\r\nreturn sbusfb_mmap_helper(par->mmap_map,\r\ninfo->fix.smem_start, info->fix.smem_len,\r\npar->iospace, vma);\r\n}\r\nstatic int cg14_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct cg14_par *par = (struct cg14_par *) info->par;\r\nstruct cg14_regs __iomem *regs = par->regs;\r\nstruct mdi_cfginfo kmdi, __user *mdii;\r\nunsigned long flags;\r\nint cur_mode, mode, ret = 0;\r\nswitch (cmd) {\r\ncase MDI_RESET:\r\nspin_lock_irqsave(&par->lock, flags);\r\n__cg14_reset(par);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nbreak;\r\ncase MDI_GET_CFGINFO:\r\nmemset(&kmdi, 0, sizeof(kmdi));\r\nspin_lock_irqsave(&par->lock, flags);\r\nkmdi.mdi_type = FBTYPE_MDICOLOR;\r\nkmdi.mdi_height = info->var.yres;\r\nkmdi.mdi_width = info->var.xres;\r\nkmdi.mdi_mode = par->mode;\r\nkmdi.mdi_pixfreq = 72;\r\nkmdi.mdi_size = par->ramsize;\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nmdii = (struct mdi_cfginfo __user *) arg;\r\nif (copy_to_user(mdii, &kmdi, sizeof(kmdi)))\r\nret = -EFAULT;\r\nbreak;\r\ncase MDI_SET_PIXELMODE:\r\nif (get_user(mode, (int __user *) arg)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&par->lock, flags);\r\ncur_mode = sbus_readb(&regs->mcr);\r\ncur_mode &= ~CG14_MCR_PIXMODE_MASK;\r\nswitch(mode) {\r\ncase MDI_32_PIX:\r\ncur_mode |= (CG14_MCR_PIXMODE_32 <<\r\nCG14_MCR_PIXMODE_SHIFT);\r\nbreak;\r\ncase MDI_16_PIX:\r\ncur_mode |= (CG14_MCR_PIXMODE_16 <<\r\nCG14_MCR_PIXMODE_SHIFT);\r\nbreak;\r\ncase MDI_8_PIX:\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nif (!ret) {\r\nsbus_writeb(cur_mode, &regs->mcr);\r\npar->mode = mode;\r\n}\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nbreak;\r\ndefault:\r\nret = sbusfb_ioctl_helper(cmd, arg, info,\r\nFBTYPE_MDICOLOR, 8,\r\ninfo->fix.smem_len);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void cg14_init_fix(struct fb_info *info, int linebytes,\r\nstruct device_node *dp)\r\n{\r\nconst char *name = dp->name;\r\nstrlcpy(info->fix.id, name, sizeof(info->fix.id));\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.line_length = linebytes;\r\ninfo->fix.accel = FB_ACCEL_SUN_CG14;\r\n}\r\nstatic void cg14_unmap_regs(struct platform_device *op, struct fb_info *info,\r\nstruct cg14_par *par)\r\n{\r\nif (par->regs)\r\nof_iounmap(&op->resource[0],\r\npar->regs, sizeof(struct cg14_regs));\r\nif (par->clut)\r\nof_iounmap(&op->resource[0],\r\npar->clut, sizeof(struct cg14_clut));\r\nif (par->cursor)\r\nof_iounmap(&op->resource[0],\r\npar->cursor, sizeof(struct cg14_cursor));\r\nif (info->screen_base)\r\nof_iounmap(&op->resource[1],\r\ninfo->screen_base, info->fix.smem_len);\r\n}\r\nstatic int cg14_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct fb_info *info;\r\nstruct cg14_par *par;\r\nint is_8mb, linebytes, i, err;\r\ninfo = framebuffer_alloc(sizeof(struct cg14_par), &op->dev);\r\nerr = -ENOMEM;\r\nif (!info)\r\ngoto out_err;\r\npar = info->par;\r\nspin_lock_init(&par->lock);\r\nsbusfb_fill_var(&info->var, dp, 8);\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\nlinebytes = of_getintprop_default(dp, "linebytes",\r\ninfo->var.xres);\r\ninfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\r\nif (!strcmp(dp->parent->name, "sbus") ||\r\n!strcmp(dp->parent->name, "sbi")) {\r\ninfo->fix.smem_start = op->resource[0].start;\r\npar->iospace = op->resource[0].flags & IORESOURCE_BITS;\r\n} else {\r\ninfo->fix.smem_start = op->resource[1].start;\r\npar->iospace = op->resource[0].flags & IORESOURCE_BITS;\r\n}\r\npar->regs = of_ioremap(&op->resource[0], 0,\r\nsizeof(struct cg14_regs), "cg14 regs");\r\npar->clut = of_ioremap(&op->resource[0], CG14_CLUT1,\r\nsizeof(struct cg14_clut), "cg14 clut");\r\npar->cursor = of_ioremap(&op->resource[0], CG14_CURSORREGS,\r\nsizeof(struct cg14_cursor), "cg14 cursor");\r\ninfo->screen_base = of_ioremap(&op->resource[1], 0,\r\ninfo->fix.smem_len, "cg14 ram");\r\nif (!par->regs || !par->clut || !par->cursor || !info->screen_base)\r\ngoto out_unmap_regs;\r\nis_8mb = (((op->resource[1].end - op->resource[1].start) + 1) ==\r\n(8 * 1024 * 1024));\r\nBUILD_BUG_ON(sizeof(par->mmap_map) != sizeof(__cg14_mmap_map));\r\nmemcpy(&par->mmap_map, &__cg14_mmap_map, sizeof(par->mmap_map));\r\nfor (i = 0; i < CG14_MMAP_ENTRIES; i++) {\r\nstruct sbus_mmap_map *map = &par->mmap_map[i];\r\nif (!map->size)\r\nbreak;\r\nif (map->poff & 0x80000000)\r\nmap->poff = (map->poff & 0x7fffffff) +\r\n(op->resource[0].start -\r\nop->resource[1].start);\r\nif (is_8mb &&\r\nmap->size >= 0x100000 &&\r\nmap->size <= 0x400000)\r\nmap->size *= 2;\r\n}\r\npar->mode = MDI_8_PIX;\r\npar->ramsize = (is_8mb ? 0x800000 : 0x400000);\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\ninfo->fbops = &cg14_ops;\r\n__cg14_reset(par);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0))\r\ngoto out_unmap_regs;\r\nfb_set_cmap(&info->cmap, info);\r\ncg14_init_fix(info, linebytes, dp);\r\nerr = register_framebuffer(info);\r\nif (err < 0)\r\ngoto out_dealloc_cmap;\r\ndev_set_drvdata(&op->dev, info);\r\nprintk(KERN_INFO "%s: cgfourteen at %lx:%lx, %dMB\n",\r\ndp->full_name,\r\npar->iospace, info->fix.smem_start,\r\npar->ramsize >> 20);\r\nreturn 0;\r\nout_dealloc_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nout_unmap_regs:\r\ncg14_unmap_regs(op, info, par);\r\nframebuffer_release(info);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int cg14_remove(struct platform_device *op)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&op->dev);\r\nstruct cg14_par *par = info->par;\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\ncg14_unmap_regs(op, info, par);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int __init cg14_init(void)\r\n{\r\nif (fb_get_options("cg14fb", NULL))\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&cg14_driver);\r\n}\r\nstatic void __exit cg14_exit(void)\r\n{\r\nplatform_driver_unregister(&cg14_driver);\r\n}
