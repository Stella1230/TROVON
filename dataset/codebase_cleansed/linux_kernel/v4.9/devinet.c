static u32 inet_addr_hash(const struct net *net, __be32 addr)\r\n{\r\nu32 val = (__force u32) addr ^ net_hash_mix(net);\r\nreturn hash_32(val, IN4_ADDR_HSIZE_SHIFT);\r\n}\r\nstatic void inet_hash_insert(struct net *net, struct in_ifaddr *ifa)\r\n{\r\nu32 hash = inet_addr_hash(net, ifa->ifa_local);\r\nASSERT_RTNL();\r\nhlist_add_head_rcu(&ifa->hash, &inet_addr_lst[hash]);\r\n}\r\nstatic void inet_hash_remove(struct in_ifaddr *ifa)\r\n{\r\nASSERT_RTNL();\r\nhlist_del_init_rcu(&ifa->hash);\r\n}\r\nstruct net_device *__ip_dev_find(struct net *net, __be32 addr, bool devref)\r\n{\r\nu32 hash = inet_addr_hash(net, addr);\r\nstruct net_device *result = NULL;\r\nstruct in_ifaddr *ifa;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(ifa, &inet_addr_lst[hash], hash) {\r\nif (ifa->ifa_local == addr) {\r\nstruct net_device *dev = ifa->ifa_dev->dev;\r\nif (!net_eq(dev_net(dev), net))\r\ncontinue;\r\nresult = dev;\r\nbreak;\r\n}\r\n}\r\nif (!result) {\r\nstruct flowi4 fl4 = { .daddr = addr };\r\nstruct fib_result res = { 0 };\r\nstruct fib_table *local;\r\nlocal = fib_get_table(net, RT_TABLE_LOCAL);\r\nif (local &&\r\n!fib_table_lookup(local, &fl4, &res, FIB_LOOKUP_NOREF) &&\r\nres.type == RTN_LOCAL)\r\nresult = FIB_RES_DEV(res);\r\n}\r\nif (result && devref)\r\ndev_hold(result);\r\nrcu_read_unlock();\r\nreturn result;\r\n}\r\nstatic int devinet_sysctl_register(struct in_device *idev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void devinet_sysctl_unregister(struct in_device *idev)\r\n{\r\n}\r\nstatic struct in_ifaddr *inet_alloc_ifa(void)\r\n{\r\nreturn kzalloc(sizeof(struct in_ifaddr), GFP_KERNEL);\r\n}\r\nstatic void inet_rcu_free_ifa(struct rcu_head *head)\r\n{\r\nstruct in_ifaddr *ifa = container_of(head, struct in_ifaddr, rcu_head);\r\nif (ifa->ifa_dev)\r\nin_dev_put(ifa->ifa_dev);\r\nkfree(ifa);\r\n}\r\nstatic void inet_free_ifa(struct in_ifaddr *ifa)\r\n{\r\ncall_rcu(&ifa->rcu_head, inet_rcu_free_ifa);\r\n}\r\nvoid in_dev_finish_destroy(struct in_device *idev)\r\n{\r\nstruct net_device *dev = idev->dev;\r\nWARN_ON(idev->ifa_list);\r\nWARN_ON(idev->mc_list);\r\nkfree(rcu_dereference_protected(idev->mc_hash, 1));\r\n#ifdef NET_REFCNT_DEBUG\r\npr_debug("%s: %p=%s\n", __func__, idev, dev ? dev->name : "NIL");\r\n#endif\r\ndev_put(dev);\r\nif (!idev->dead)\r\npr_err("Freeing alive in_device %p\n", idev);\r\nelse\r\nkfree(idev);\r\n}\r\nstatic struct in_device *inetdev_init(struct net_device *dev)\r\n{\r\nstruct in_device *in_dev;\r\nint err = -ENOMEM;\r\nASSERT_RTNL();\r\nin_dev = kzalloc(sizeof(*in_dev), GFP_KERNEL);\r\nif (!in_dev)\r\ngoto out;\r\nmemcpy(&in_dev->cnf, dev_net(dev)->ipv4.devconf_dflt,\r\nsizeof(in_dev->cnf));\r\nin_dev->cnf.sysctl = NULL;\r\nin_dev->dev = dev;\r\nin_dev->arp_parms = neigh_parms_alloc(dev, &arp_tbl);\r\nif (!in_dev->arp_parms)\r\ngoto out_kfree;\r\nif (IPV4_DEVCONF(in_dev->cnf, FORWARDING))\r\ndev_disable_lro(dev);\r\ndev_hold(dev);\r\nin_dev_hold(in_dev);\r\nerr = devinet_sysctl_register(in_dev);\r\nif (err) {\r\nin_dev->dead = 1;\r\nin_dev_put(in_dev);\r\nin_dev = NULL;\r\ngoto out;\r\n}\r\nip_mc_init_dev(in_dev);\r\nif (dev->flags & IFF_UP)\r\nip_mc_up(in_dev);\r\nrcu_assign_pointer(dev->ip_ptr, in_dev);\r\nout:\r\nreturn in_dev ?: ERR_PTR(err);\r\nout_kfree:\r\nkfree(in_dev);\r\nin_dev = NULL;\r\ngoto out;\r\n}\r\nstatic void in_dev_rcu_put(struct rcu_head *head)\r\n{\r\nstruct in_device *idev = container_of(head, struct in_device, rcu_head);\r\nin_dev_put(idev);\r\n}\r\nstatic void inetdev_destroy(struct in_device *in_dev)\r\n{\r\nstruct in_ifaddr *ifa;\r\nstruct net_device *dev;\r\nASSERT_RTNL();\r\ndev = in_dev->dev;\r\nin_dev->dead = 1;\r\nip_mc_destroy_dev(in_dev);\r\nwhile ((ifa = in_dev->ifa_list) != NULL) {\r\ninet_del_ifa(in_dev, &in_dev->ifa_list, 0);\r\ninet_free_ifa(ifa);\r\n}\r\nRCU_INIT_POINTER(dev->ip_ptr, NULL);\r\ndevinet_sysctl_unregister(in_dev);\r\nneigh_parms_release(&arp_tbl, in_dev->arp_parms);\r\narp_ifdown(dev);\r\ncall_rcu(&in_dev->rcu_head, in_dev_rcu_put);\r\n}\r\nint inet_addr_onlink(struct in_device *in_dev, __be32 a, __be32 b)\r\n{\r\nrcu_read_lock();\r\nfor_primary_ifa(in_dev) {\r\nif (inet_ifa_match(a, ifa)) {\r\nif (!b || inet_ifa_match(b, ifa)) {\r\nrcu_read_unlock();\r\nreturn 1;\r\n}\r\n}\r\n} endfor_ifa(in_dev);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\r\nint destroy, struct nlmsghdr *nlh, u32 portid)\r\n{\r\nstruct in_ifaddr *promote = NULL;\r\nstruct in_ifaddr *ifa, *ifa1 = *ifap;\r\nstruct in_ifaddr *last_prim = in_dev->ifa_list;\r\nstruct in_ifaddr *prev_prom = NULL;\r\nint do_promote = IN_DEV_PROMOTE_SECONDARIES(in_dev);\r\nASSERT_RTNL();\r\nif (in_dev->dead)\r\ngoto no_promotions;\r\nif (!(ifa1->ifa_flags & IFA_F_SECONDARY)) {\r\nstruct in_ifaddr **ifap1 = &ifa1->ifa_next;\r\nwhile ((ifa = *ifap1) != NULL) {\r\nif (!(ifa->ifa_flags & IFA_F_SECONDARY) &&\r\nifa1->ifa_scope <= ifa->ifa_scope)\r\nlast_prim = ifa;\r\nif (!(ifa->ifa_flags & IFA_F_SECONDARY) ||\r\nifa1->ifa_mask != ifa->ifa_mask ||\r\n!inet_ifa_match(ifa1->ifa_address, ifa)) {\r\nifap1 = &ifa->ifa_next;\r\nprev_prom = ifa;\r\ncontinue;\r\n}\r\nif (!do_promote) {\r\ninet_hash_remove(ifa);\r\n*ifap1 = ifa->ifa_next;\r\nrtmsg_ifa(RTM_DELADDR, ifa, nlh, portid);\r\nblocking_notifier_call_chain(&inetaddr_chain,\r\nNETDEV_DOWN, ifa);\r\ninet_free_ifa(ifa);\r\n} else {\r\npromote = ifa;\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (ifa = promote; ifa; ifa = ifa->ifa_next) {\r\nif (ifa1->ifa_mask == ifa->ifa_mask &&\r\ninet_ifa_match(ifa1->ifa_address, ifa))\r\nfib_del_ifaddr(ifa, ifa1);\r\n}\r\nno_promotions:\r\n*ifap = ifa1->ifa_next;\r\ninet_hash_remove(ifa1);\r\nrtmsg_ifa(RTM_DELADDR, ifa1, nlh, portid);\r\nblocking_notifier_call_chain(&inetaddr_chain, NETDEV_DOWN, ifa1);\r\nif (promote) {\r\nstruct in_ifaddr *next_sec = promote->ifa_next;\r\nif (prev_prom) {\r\nprev_prom->ifa_next = promote->ifa_next;\r\npromote->ifa_next = last_prim->ifa_next;\r\nlast_prim->ifa_next = promote;\r\n}\r\npromote->ifa_flags &= ~IFA_F_SECONDARY;\r\nrtmsg_ifa(RTM_NEWADDR, promote, nlh, portid);\r\nblocking_notifier_call_chain(&inetaddr_chain,\r\nNETDEV_UP, promote);\r\nfor (ifa = next_sec; ifa; ifa = ifa->ifa_next) {\r\nif (ifa1->ifa_mask != ifa->ifa_mask ||\r\n!inet_ifa_match(ifa1->ifa_address, ifa))\r\ncontinue;\r\nfib_add_ifaddr(ifa);\r\n}\r\n}\r\nif (destroy)\r\ninet_free_ifa(ifa1);\r\n}\r\nstatic void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\r\nint destroy)\r\n{\r\n__inet_del_ifa(in_dev, ifap, destroy, NULL, 0);\r\n}\r\nstatic int __inet_insert_ifa(struct in_ifaddr *ifa, struct nlmsghdr *nlh,\r\nu32 portid)\r\n{\r\nstruct in_device *in_dev = ifa->ifa_dev;\r\nstruct in_ifaddr *ifa1, **ifap, **last_primary;\r\nASSERT_RTNL();\r\nif (!ifa->ifa_local) {\r\ninet_free_ifa(ifa);\r\nreturn 0;\r\n}\r\nifa->ifa_flags &= ~IFA_F_SECONDARY;\r\nlast_primary = &in_dev->ifa_list;\r\nfor (ifap = &in_dev->ifa_list; (ifa1 = *ifap) != NULL;\r\nifap = &ifa1->ifa_next) {\r\nif (!(ifa1->ifa_flags & IFA_F_SECONDARY) &&\r\nifa->ifa_scope <= ifa1->ifa_scope)\r\nlast_primary = &ifa1->ifa_next;\r\nif (ifa1->ifa_mask == ifa->ifa_mask &&\r\ninet_ifa_match(ifa1->ifa_address, ifa)) {\r\nif (ifa1->ifa_local == ifa->ifa_local) {\r\ninet_free_ifa(ifa);\r\nreturn -EEXIST;\r\n}\r\nif (ifa1->ifa_scope != ifa->ifa_scope) {\r\ninet_free_ifa(ifa);\r\nreturn -EINVAL;\r\n}\r\nifa->ifa_flags |= IFA_F_SECONDARY;\r\n}\r\n}\r\nif (!(ifa->ifa_flags & IFA_F_SECONDARY)) {\r\nprandom_seed((__force u32) ifa->ifa_local);\r\nifap = last_primary;\r\n}\r\nifa->ifa_next = *ifap;\r\n*ifap = ifa;\r\ninet_hash_insert(dev_net(in_dev->dev), ifa);\r\ncancel_delayed_work(&check_lifetime_work);\r\nqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\r\nrtmsg_ifa(RTM_NEWADDR, ifa, nlh, portid);\r\nblocking_notifier_call_chain(&inetaddr_chain, NETDEV_UP, ifa);\r\nreturn 0;\r\n}\r\nstatic int inet_insert_ifa(struct in_ifaddr *ifa)\r\n{\r\nreturn __inet_insert_ifa(ifa, NULL, 0);\r\n}\r\nstatic int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)\r\n{\r\nstruct in_device *in_dev = __in_dev_get_rtnl(dev);\r\nASSERT_RTNL();\r\nif (!in_dev) {\r\ninet_free_ifa(ifa);\r\nreturn -ENOBUFS;\r\n}\r\nipv4_devconf_setall(in_dev);\r\nneigh_parms_data_state_setall(in_dev->arp_parms);\r\nif (ifa->ifa_dev != in_dev) {\r\nWARN_ON(ifa->ifa_dev);\r\nin_dev_hold(in_dev);\r\nifa->ifa_dev = in_dev;\r\n}\r\nif (ipv4_is_loopback(ifa->ifa_local))\r\nifa->ifa_scope = RT_SCOPE_HOST;\r\nreturn inet_insert_ifa(ifa);\r\n}\r\nstruct in_device *inetdev_by_index(struct net *net, int ifindex)\r\n{\r\nstruct net_device *dev;\r\nstruct in_device *in_dev = NULL;\r\nrcu_read_lock();\r\ndev = dev_get_by_index_rcu(net, ifindex);\r\nif (dev)\r\nin_dev = rcu_dereference_rtnl(dev->ip_ptr);\r\nrcu_read_unlock();\r\nreturn in_dev;\r\n}\r\nstruct in_ifaddr *inet_ifa_byprefix(struct in_device *in_dev, __be32 prefix,\r\n__be32 mask)\r\n{\r\nASSERT_RTNL();\r\nfor_primary_ifa(in_dev) {\r\nif (ifa->ifa_mask == mask && inet_ifa_match(prefix, ifa))\r\nreturn ifa;\r\n} endfor_ifa(in_dev);\r\nreturn NULL;\r\n}\r\nstatic int ip_mc_config(struct sock *sk, bool join, const struct in_ifaddr *ifa)\r\n{\r\nstruct ip_mreqn mreq = {\r\n.imr_multiaddr.s_addr = ifa->ifa_address,\r\n.imr_ifindex = ifa->ifa_dev->dev->ifindex,\r\n};\r\nint ret;\r\nASSERT_RTNL();\r\nlock_sock(sk);\r\nif (join)\r\nret = ip_mc_join_group(sk, &mreq);\r\nelse\r\nret = ip_mc_leave_group(sk, &mreq);\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic int inet_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *tb[IFA_MAX+1];\r\nstruct in_device *in_dev;\r\nstruct ifaddrmsg *ifm;\r\nstruct in_ifaddr *ifa, **ifap;\r\nint err = -EINVAL;\r\nASSERT_RTNL();\r\nerr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);\r\nif (err < 0)\r\ngoto errout;\r\nifm = nlmsg_data(nlh);\r\nin_dev = inetdev_by_index(net, ifm->ifa_index);\r\nif (!in_dev) {\r\nerr = -ENODEV;\r\ngoto errout;\r\n}\r\nfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\r\nifap = &ifa->ifa_next) {\r\nif (tb[IFA_LOCAL] &&\r\nifa->ifa_local != nla_get_in_addr(tb[IFA_LOCAL]))\r\ncontinue;\r\nif (tb[IFA_LABEL] && nla_strcmp(tb[IFA_LABEL], ifa->ifa_label))\r\ncontinue;\r\nif (tb[IFA_ADDRESS] &&\r\n(ifm->ifa_prefixlen != ifa->ifa_prefixlen ||\r\n!inet_ifa_match(nla_get_in_addr(tb[IFA_ADDRESS]), ifa)))\r\ncontinue;\r\nif (ipv4_is_multicast(ifa->ifa_address))\r\nip_mc_config(net->ipv4.mc_autojoin_sk, false, ifa);\r\n__inet_del_ifa(in_dev, ifap, 1, nlh, NETLINK_CB(skb).portid);\r\nreturn 0;\r\n}\r\nerr = -EADDRNOTAVAIL;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic void check_lifetime(struct work_struct *work)\r\n{\r\nunsigned long now, next, next_sec, next_sched;\r\nstruct in_ifaddr *ifa;\r\nstruct hlist_node *n;\r\nint i;\r\nnow = jiffies;\r\nnext = round_jiffies_up(now + ADDR_CHECK_FREQUENCY);\r\nfor (i = 0; i < IN4_ADDR_HSIZE; i++) {\r\nbool change_needed = false;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(ifa, &inet_addr_lst[i], hash) {\r\nunsigned long age;\r\nif (ifa->ifa_flags & IFA_F_PERMANENT)\r\ncontinue;\r\nage = (now - ifa->ifa_tstamp +\r\nADDRCONF_TIMER_FUZZ_MINUS) / HZ;\r\nif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\r\nage >= ifa->ifa_valid_lft) {\r\nchange_needed = true;\r\n} else if (ifa->ifa_preferred_lft ==\r\nINFINITY_LIFE_TIME) {\r\ncontinue;\r\n} else if (age >= ifa->ifa_preferred_lft) {\r\nif (time_before(ifa->ifa_tstamp +\r\nifa->ifa_valid_lft * HZ, next))\r\nnext = ifa->ifa_tstamp +\r\nifa->ifa_valid_lft * HZ;\r\nif (!(ifa->ifa_flags & IFA_F_DEPRECATED))\r\nchange_needed = true;\r\n} else if (time_before(ifa->ifa_tstamp +\r\nifa->ifa_preferred_lft * HZ,\r\nnext)) {\r\nnext = ifa->ifa_tstamp +\r\nifa->ifa_preferred_lft * HZ;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!change_needed)\r\ncontinue;\r\nrtnl_lock();\r\nhlist_for_each_entry_safe(ifa, n, &inet_addr_lst[i], hash) {\r\nunsigned long age;\r\nif (ifa->ifa_flags & IFA_F_PERMANENT)\r\ncontinue;\r\nage = (now - ifa->ifa_tstamp +\r\nADDRCONF_TIMER_FUZZ_MINUS) / HZ;\r\nif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\r\nage >= ifa->ifa_valid_lft) {\r\nstruct in_ifaddr **ifap;\r\nfor (ifap = &ifa->ifa_dev->ifa_list;\r\n*ifap != NULL; ifap = &(*ifap)->ifa_next) {\r\nif (*ifap == ifa) {\r\ninet_del_ifa(ifa->ifa_dev,\r\nifap, 1);\r\nbreak;\r\n}\r\n}\r\n} else if (ifa->ifa_preferred_lft !=\r\nINFINITY_LIFE_TIME &&\r\nage >= ifa->ifa_preferred_lft &&\r\n!(ifa->ifa_flags & IFA_F_DEPRECATED)) {\r\nifa->ifa_flags |= IFA_F_DEPRECATED;\r\nrtmsg_ifa(RTM_NEWADDR, ifa, NULL, 0);\r\n}\r\n}\r\nrtnl_unlock();\r\n}\r\nnext_sec = round_jiffies_up(next);\r\nnext_sched = next;\r\nif (time_before(next_sec, next + ADDRCONF_TIMER_FUZZ))\r\nnext_sched = next_sec;\r\nnow = jiffies;\r\nif (time_before(next_sched, now + ADDRCONF_TIMER_FUZZ_MAX))\r\nnext_sched = now + ADDRCONF_TIMER_FUZZ_MAX;\r\nqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work,\r\nnext_sched - now);\r\n}\r\nstatic void set_ifa_lifetime(struct in_ifaddr *ifa, __u32 valid_lft,\r\n__u32 prefered_lft)\r\n{\r\nunsigned long timeout;\r\nifa->ifa_flags &= ~(IFA_F_PERMANENT | IFA_F_DEPRECATED);\r\ntimeout = addrconf_timeout_fixup(valid_lft, HZ);\r\nif (addrconf_finite_timeout(timeout))\r\nifa->ifa_valid_lft = timeout;\r\nelse\r\nifa->ifa_flags |= IFA_F_PERMANENT;\r\ntimeout = addrconf_timeout_fixup(prefered_lft, HZ);\r\nif (addrconf_finite_timeout(timeout)) {\r\nif (timeout == 0)\r\nifa->ifa_flags |= IFA_F_DEPRECATED;\r\nifa->ifa_preferred_lft = timeout;\r\n}\r\nifa->ifa_tstamp = jiffies;\r\nif (!ifa->ifa_cstamp)\r\nifa->ifa_cstamp = ifa->ifa_tstamp;\r\n}\r\nstatic struct in_ifaddr *rtm_to_ifaddr(struct net *net, struct nlmsghdr *nlh,\r\n__u32 *pvalid_lft, __u32 *pprefered_lft)\r\n{\r\nstruct nlattr *tb[IFA_MAX+1];\r\nstruct in_ifaddr *ifa;\r\nstruct ifaddrmsg *ifm;\r\nstruct net_device *dev;\r\nstruct in_device *in_dev;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv4_policy);\r\nif (err < 0)\r\ngoto errout;\r\nifm = nlmsg_data(nlh);\r\nerr = -EINVAL;\r\nif (ifm->ifa_prefixlen > 32 || !tb[IFA_LOCAL])\r\ngoto errout;\r\ndev = __dev_get_by_index(net, ifm->ifa_index);\r\nerr = -ENODEV;\r\nif (!dev)\r\ngoto errout;\r\nin_dev = __in_dev_get_rtnl(dev);\r\nerr = -ENOBUFS;\r\nif (!in_dev)\r\ngoto errout;\r\nifa = inet_alloc_ifa();\r\nif (!ifa)\r\ngoto errout;\r\nipv4_devconf_setall(in_dev);\r\nneigh_parms_data_state_setall(in_dev->arp_parms);\r\nin_dev_hold(in_dev);\r\nif (!tb[IFA_ADDRESS])\r\ntb[IFA_ADDRESS] = tb[IFA_LOCAL];\r\nINIT_HLIST_NODE(&ifa->hash);\r\nifa->ifa_prefixlen = ifm->ifa_prefixlen;\r\nifa->ifa_mask = inet_make_mask(ifm->ifa_prefixlen);\r\nifa->ifa_flags = tb[IFA_FLAGS] ? nla_get_u32(tb[IFA_FLAGS]) :\r\nifm->ifa_flags;\r\nifa->ifa_scope = ifm->ifa_scope;\r\nifa->ifa_dev = in_dev;\r\nifa->ifa_local = nla_get_in_addr(tb[IFA_LOCAL]);\r\nifa->ifa_address = nla_get_in_addr(tb[IFA_ADDRESS]);\r\nif (tb[IFA_BROADCAST])\r\nifa->ifa_broadcast = nla_get_in_addr(tb[IFA_BROADCAST]);\r\nif (tb[IFA_LABEL])\r\nnla_strlcpy(ifa->ifa_label, tb[IFA_LABEL], IFNAMSIZ);\r\nelse\r\nmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\r\nif (tb[IFA_CACHEINFO]) {\r\nstruct ifa_cacheinfo *ci;\r\nci = nla_data(tb[IFA_CACHEINFO]);\r\nif (!ci->ifa_valid || ci->ifa_prefered > ci->ifa_valid) {\r\nerr = -EINVAL;\r\ngoto errout_free;\r\n}\r\n*pvalid_lft = ci->ifa_valid;\r\n*pprefered_lft = ci->ifa_prefered;\r\n}\r\nreturn ifa;\r\nerrout_free:\r\ninet_free_ifa(ifa);\r\nerrout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct in_ifaddr *find_matching_ifa(struct in_ifaddr *ifa)\r\n{\r\nstruct in_device *in_dev = ifa->ifa_dev;\r\nstruct in_ifaddr *ifa1, **ifap;\r\nif (!ifa->ifa_local)\r\nreturn NULL;\r\nfor (ifap = &in_dev->ifa_list; (ifa1 = *ifap) != NULL;\r\nifap = &ifa1->ifa_next) {\r\nif (ifa1->ifa_mask == ifa->ifa_mask &&\r\ninet_ifa_match(ifa1->ifa_address, ifa) &&\r\nifa1->ifa_local == ifa->ifa_local)\r\nreturn ifa1;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int inet_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct in_ifaddr *ifa;\r\nstruct in_ifaddr *ifa_existing;\r\n__u32 valid_lft = INFINITY_LIFE_TIME;\r\n__u32 prefered_lft = INFINITY_LIFE_TIME;\r\nASSERT_RTNL();\r\nifa = rtm_to_ifaddr(net, nlh, &valid_lft, &prefered_lft);\r\nif (IS_ERR(ifa))\r\nreturn PTR_ERR(ifa);\r\nifa_existing = find_matching_ifa(ifa);\r\nif (!ifa_existing) {\r\nset_ifa_lifetime(ifa, valid_lft, prefered_lft);\r\nif (ifa->ifa_flags & IFA_F_MCAUTOJOIN) {\r\nint ret = ip_mc_config(net->ipv4.mc_autojoin_sk,\r\ntrue, ifa);\r\nif (ret < 0) {\r\ninet_free_ifa(ifa);\r\nreturn ret;\r\n}\r\n}\r\nreturn __inet_insert_ifa(ifa, nlh, NETLINK_CB(skb).portid);\r\n} else {\r\ninet_free_ifa(ifa);\r\nif (nlh->nlmsg_flags & NLM_F_EXCL ||\r\n!(nlh->nlmsg_flags & NLM_F_REPLACE))\r\nreturn -EEXIST;\r\nifa = ifa_existing;\r\nset_ifa_lifetime(ifa, valid_lft, prefered_lft);\r\ncancel_delayed_work(&check_lifetime_work);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&check_lifetime_work, 0);\r\nrtmsg_ifa(RTM_NEWADDR, ifa, nlh, NETLINK_CB(skb).portid);\r\n}\r\nreturn 0;\r\n}\r\nstatic int inet_abc_len(__be32 addr)\r\n{\r\nint rc = -1;\r\nif (ipv4_is_zeronet(addr))\r\nrc = 0;\r\nelse {\r\n__u32 haddr = ntohl(addr);\r\nif (IN_CLASSA(haddr))\r\nrc = 8;\r\nelse if (IN_CLASSB(haddr))\r\nrc = 16;\r\nelse if (IN_CLASSC(haddr))\r\nrc = 24;\r\n}\r\nreturn rc;\r\n}\r\nint devinet_ioctl(struct net *net, unsigned int cmd, void __user *arg)\r\n{\r\nstruct ifreq ifr;\r\nstruct sockaddr_in sin_orig;\r\nstruct sockaddr_in *sin = (struct sockaddr_in *)&ifr.ifr_addr;\r\nstruct in_device *in_dev;\r\nstruct in_ifaddr **ifap = NULL;\r\nstruct in_ifaddr *ifa = NULL;\r\nstruct net_device *dev;\r\nchar *colon;\r\nint ret = -EFAULT;\r\nint tryaddrmatch = 0;\r\nif (copy_from_user(&ifr, arg, sizeof(struct ifreq)))\r\ngoto out;\r\nifr.ifr_name[IFNAMSIZ - 1] = 0;\r\nmemcpy(&sin_orig, sin, sizeof(*sin));\r\ncolon = strchr(ifr.ifr_name, ':');\r\nif (colon)\r\n*colon = 0;\r\ndev_load(net, ifr.ifr_name);\r\nswitch (cmd) {\r\ncase SIOCGIFADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCGIFNETMASK:\r\ntryaddrmatch = (sin_orig.sin_family == AF_INET);\r\nmemset(sin, 0, sizeof(*sin));\r\nsin->sin_family = AF_INET;\r\nbreak;\r\ncase SIOCSIFFLAGS:\r\nret = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\ngoto out;\r\nbreak;\r\ncase SIOCSIFADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCSIFNETMASK:\r\nret = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\ngoto out;\r\nret = -EINVAL;\r\nif (sin->sin_family != AF_INET)\r\ngoto out;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nrtnl_lock();\r\nret = -ENODEV;\r\ndev = __dev_get_by_name(net, ifr.ifr_name);\r\nif (!dev)\r\ngoto done;\r\nif (colon)\r\n*colon = ':';\r\nin_dev = __in_dev_get_rtnl(dev);\r\nif (in_dev) {\r\nif (tryaddrmatch) {\r\nfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\r\nifap = &ifa->ifa_next) {\r\nif (!strcmp(ifr.ifr_name, ifa->ifa_label) &&\r\nsin_orig.sin_addr.s_addr ==\r\nifa->ifa_local) {\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!ifa) {\r\nfor (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;\r\nifap = &ifa->ifa_next)\r\nif (!strcmp(ifr.ifr_name, ifa->ifa_label))\r\nbreak;\r\n}\r\n}\r\nret = -EADDRNOTAVAIL;\r\nif (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)\r\ngoto done;\r\nswitch (cmd) {\r\ncase SIOCGIFADDR:\r\nsin->sin_addr.s_addr = ifa->ifa_local;\r\ngoto rarok;\r\ncase SIOCGIFBRDADDR:\r\nsin->sin_addr.s_addr = ifa->ifa_broadcast;\r\ngoto rarok;\r\ncase SIOCGIFDSTADDR:\r\nsin->sin_addr.s_addr = ifa->ifa_address;\r\ngoto rarok;\r\ncase SIOCGIFNETMASK:\r\nsin->sin_addr.s_addr = ifa->ifa_mask;\r\ngoto rarok;\r\ncase SIOCSIFFLAGS:\r\nif (colon) {\r\nret = -EADDRNOTAVAIL;\r\nif (!ifa)\r\nbreak;\r\nret = 0;\r\nif (!(ifr.ifr_flags & IFF_UP))\r\ninet_del_ifa(in_dev, ifap, 1);\r\nbreak;\r\n}\r\nret = dev_change_flags(dev, ifr.ifr_flags);\r\nbreak;\r\ncase SIOCSIFADDR:\r\nret = -EINVAL;\r\nif (inet_abc_len(sin->sin_addr.s_addr) < 0)\r\nbreak;\r\nif (!ifa) {\r\nret = -ENOBUFS;\r\nifa = inet_alloc_ifa();\r\nif (!ifa)\r\nbreak;\r\nINIT_HLIST_NODE(&ifa->hash);\r\nif (colon)\r\nmemcpy(ifa->ifa_label, ifr.ifr_name, IFNAMSIZ);\r\nelse\r\nmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\r\n} else {\r\nret = 0;\r\nif (ifa->ifa_local == sin->sin_addr.s_addr)\r\nbreak;\r\ninet_del_ifa(in_dev, ifap, 0);\r\nifa->ifa_broadcast = 0;\r\nifa->ifa_scope = 0;\r\n}\r\nifa->ifa_address = ifa->ifa_local = sin->sin_addr.s_addr;\r\nif (!(dev->flags & IFF_POINTOPOINT)) {\r\nifa->ifa_prefixlen = inet_abc_len(ifa->ifa_address);\r\nifa->ifa_mask = inet_make_mask(ifa->ifa_prefixlen);\r\nif ((dev->flags & IFF_BROADCAST) &&\r\nifa->ifa_prefixlen < 31)\r\nifa->ifa_broadcast = ifa->ifa_address |\r\n~ifa->ifa_mask;\r\n} else {\r\nifa->ifa_prefixlen = 32;\r\nifa->ifa_mask = inet_make_mask(32);\r\n}\r\nset_ifa_lifetime(ifa, INFINITY_LIFE_TIME, INFINITY_LIFE_TIME);\r\nret = inet_set_ifa(dev, ifa);\r\nbreak;\r\ncase SIOCSIFBRDADDR:\r\nret = 0;\r\nif (ifa->ifa_broadcast != sin->sin_addr.s_addr) {\r\ninet_del_ifa(in_dev, ifap, 0);\r\nifa->ifa_broadcast = sin->sin_addr.s_addr;\r\ninet_insert_ifa(ifa);\r\n}\r\nbreak;\r\ncase SIOCSIFDSTADDR:\r\nret = 0;\r\nif (ifa->ifa_address == sin->sin_addr.s_addr)\r\nbreak;\r\nret = -EINVAL;\r\nif (inet_abc_len(sin->sin_addr.s_addr) < 0)\r\nbreak;\r\nret = 0;\r\ninet_del_ifa(in_dev, ifap, 0);\r\nifa->ifa_address = sin->sin_addr.s_addr;\r\ninet_insert_ifa(ifa);\r\nbreak;\r\ncase SIOCSIFNETMASK:\r\nret = -EINVAL;\r\nif (bad_mask(sin->sin_addr.s_addr, 0))\r\nbreak;\r\nret = 0;\r\nif (ifa->ifa_mask != sin->sin_addr.s_addr) {\r\n__be32 old_mask = ifa->ifa_mask;\r\ninet_del_ifa(in_dev, ifap, 0);\r\nifa->ifa_mask = sin->sin_addr.s_addr;\r\nifa->ifa_prefixlen = inet_mask_len(ifa->ifa_mask);\r\nif ((dev->flags & IFF_BROADCAST) &&\r\n(ifa->ifa_prefixlen < 31) &&\r\n(ifa->ifa_broadcast ==\r\n(ifa->ifa_local|~old_mask))) {\r\nifa->ifa_broadcast = (ifa->ifa_local |\r\n~sin->sin_addr.s_addr);\r\n}\r\ninet_insert_ifa(ifa);\r\n}\r\nbreak;\r\n}\r\ndone:\r\nrtnl_unlock();\r\nout:\r\nreturn ret;\r\nrarok:\r\nrtnl_unlock();\r\nret = copy_to_user(arg, &ifr, sizeof(struct ifreq)) ? -EFAULT : 0;\r\ngoto out;\r\n}\r\nstatic int inet_gifconf(struct net_device *dev, char __user *buf, int len)\r\n{\r\nstruct in_device *in_dev = __in_dev_get_rtnl(dev);\r\nstruct in_ifaddr *ifa;\r\nstruct ifreq ifr;\r\nint done = 0;\r\nif (!in_dev)\r\ngoto out;\r\nfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\r\nif (!buf) {\r\ndone += sizeof(ifr);\r\ncontinue;\r\n}\r\nif (len < (int) sizeof(ifr))\r\nbreak;\r\nmemset(&ifr, 0, sizeof(struct ifreq));\r\nstrcpy(ifr.ifr_name, ifa->ifa_label);\r\n(*(struct sockaddr_in *)&ifr.ifr_addr).sin_family = AF_INET;\r\n(*(struct sockaddr_in *)&ifr.ifr_addr).sin_addr.s_addr =\r\nifa->ifa_local;\r\nif (copy_to_user(buf, &ifr, sizeof(struct ifreq))) {\r\ndone = -EFAULT;\r\nbreak;\r\n}\r\nbuf += sizeof(struct ifreq);\r\nlen -= sizeof(struct ifreq);\r\ndone += sizeof(struct ifreq);\r\n}\r\nout:\r\nreturn done;\r\n}\r\n__be32 inet_select_addr(const struct net_device *dev, __be32 dst, int scope)\r\n{\r\n__be32 addr = 0;\r\nstruct in_device *in_dev;\r\nstruct net *net = dev_net(dev);\r\nint master_idx;\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (!in_dev)\r\ngoto no_in_dev;\r\nfor_primary_ifa(in_dev) {\r\nif (ifa->ifa_scope > scope)\r\ncontinue;\r\nif (!dst || inet_ifa_match(dst, ifa)) {\r\naddr = ifa->ifa_local;\r\nbreak;\r\n}\r\nif (!addr)\r\naddr = ifa->ifa_local;\r\n} endfor_ifa(in_dev);\r\nif (addr)\r\ngoto out_unlock;\r\nno_in_dev:\r\nmaster_idx = l3mdev_master_ifindex_rcu(dev);\r\nif (master_idx &&\r\n(dev = dev_get_by_index_rcu(net, master_idx)) &&\r\n(in_dev = __in_dev_get_rcu(dev))) {\r\nfor_primary_ifa(in_dev) {\r\nif (ifa->ifa_scope != RT_SCOPE_LINK &&\r\nifa->ifa_scope <= scope) {\r\naddr = ifa->ifa_local;\r\ngoto out_unlock;\r\n}\r\n} endfor_ifa(in_dev);\r\n}\r\nfor_each_netdev_rcu(net, dev) {\r\nif (l3mdev_master_ifindex_rcu(dev) != master_idx)\r\ncontinue;\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (!in_dev)\r\ncontinue;\r\nfor_primary_ifa(in_dev) {\r\nif (ifa->ifa_scope != RT_SCOPE_LINK &&\r\nifa->ifa_scope <= scope) {\r\naddr = ifa->ifa_local;\r\ngoto out_unlock;\r\n}\r\n} endfor_ifa(in_dev);\r\n}\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn addr;\r\n}\r\nstatic __be32 confirm_addr_indev(struct in_device *in_dev, __be32 dst,\r\n__be32 local, int scope)\r\n{\r\nint same = 0;\r\n__be32 addr = 0;\r\nfor_ifa(in_dev) {\r\nif (!addr &&\r\n(local == ifa->ifa_local || !local) &&\r\nifa->ifa_scope <= scope) {\r\naddr = ifa->ifa_local;\r\nif (same)\r\nbreak;\r\n}\r\nif (!same) {\r\nsame = (!local || inet_ifa_match(local, ifa)) &&\r\n(!dst || inet_ifa_match(dst, ifa));\r\nif (same && addr) {\r\nif (local || !dst)\r\nbreak;\r\nif (inet_ifa_match(addr, ifa))\r\nbreak;\r\nif (ifa->ifa_scope <= scope) {\r\naddr = ifa->ifa_local;\r\nbreak;\r\n}\r\nsame = 0;\r\n}\r\n}\r\n} endfor_ifa(in_dev);\r\nreturn same ? addr : 0;\r\n}\r\n__be32 inet_confirm_addr(struct net *net, struct in_device *in_dev,\r\n__be32 dst, __be32 local, int scope)\r\n{\r\n__be32 addr = 0;\r\nstruct net_device *dev;\r\nif (in_dev)\r\nreturn confirm_addr_indev(in_dev, dst, local, scope);\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(net, dev) {\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (in_dev) {\r\naddr = confirm_addr_indev(in_dev, dst, local, scope);\r\nif (addr)\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn addr;\r\n}\r\nint register_inetaddr_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&inetaddr_chain, nb);\r\n}\r\nint unregister_inetaddr_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&inetaddr_chain, nb);\r\n}\r\nstatic void inetdev_changename(struct net_device *dev, struct in_device *in_dev)\r\n{\r\nstruct in_ifaddr *ifa;\r\nint named = 0;\r\nfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\r\nchar old[IFNAMSIZ], *dot;\r\nmemcpy(old, ifa->ifa_label, IFNAMSIZ);\r\nmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\r\nif (named++ == 0)\r\ngoto skip;\r\ndot = strchr(old, ':');\r\nif (!dot) {\r\nsprintf(old, ":%d", named);\r\ndot = old;\r\n}\r\nif (strlen(dot) + strlen(dev->name) < IFNAMSIZ)\r\nstrcat(ifa->ifa_label, dot);\r\nelse\r\nstrcpy(ifa->ifa_label + (IFNAMSIZ - strlen(dot) - 1), dot);\r\nskip:\r\nrtmsg_ifa(RTM_NEWADDR, ifa, NULL, 0);\r\n}\r\n}\r\nstatic bool inetdev_valid_mtu(unsigned int mtu)\r\n{\r\nreturn mtu >= 68;\r\n}\r\nstatic void inetdev_send_gratuitous_arp(struct net_device *dev,\r\nstruct in_device *in_dev)\r\n{\r\nstruct in_ifaddr *ifa;\r\nfor (ifa = in_dev->ifa_list; ifa;\r\nifa = ifa->ifa_next) {\r\narp_send(ARPOP_REQUEST, ETH_P_ARP,\r\nifa->ifa_local, dev,\r\nifa->ifa_local, NULL,\r\ndev->dev_addr, NULL);\r\n}\r\n}\r\nstatic int inetdev_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct in_device *in_dev = __in_dev_get_rtnl(dev);\r\nASSERT_RTNL();\r\nif (!in_dev) {\r\nif (event == NETDEV_REGISTER) {\r\nin_dev = inetdev_init(dev);\r\nif (IS_ERR(in_dev))\r\nreturn notifier_from_errno(PTR_ERR(in_dev));\r\nif (dev->flags & IFF_LOOPBACK) {\r\nIN_DEV_CONF_SET(in_dev, NOXFRM, 1);\r\nIN_DEV_CONF_SET(in_dev, NOPOLICY, 1);\r\n}\r\n} else if (event == NETDEV_CHANGEMTU) {\r\nif (inetdev_valid_mtu(dev->mtu))\r\nin_dev = inetdev_init(dev);\r\n}\r\ngoto out;\r\n}\r\nswitch (event) {\r\ncase NETDEV_REGISTER:\r\npr_debug("%s: bug\n", __func__);\r\nRCU_INIT_POINTER(dev->ip_ptr, NULL);\r\nbreak;\r\ncase NETDEV_UP:\r\nif (!inetdev_valid_mtu(dev->mtu))\r\nbreak;\r\nif (dev->flags & IFF_LOOPBACK) {\r\nstruct in_ifaddr *ifa = inet_alloc_ifa();\r\nif (ifa) {\r\nINIT_HLIST_NODE(&ifa->hash);\r\nifa->ifa_local =\r\nifa->ifa_address = htonl(INADDR_LOOPBACK);\r\nifa->ifa_prefixlen = 8;\r\nifa->ifa_mask = inet_make_mask(8);\r\nin_dev_hold(in_dev);\r\nifa->ifa_dev = in_dev;\r\nifa->ifa_scope = RT_SCOPE_HOST;\r\nmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\r\nset_ifa_lifetime(ifa, INFINITY_LIFE_TIME,\r\nINFINITY_LIFE_TIME);\r\nipv4_devconf_setall(in_dev);\r\nneigh_parms_data_state_setall(in_dev->arp_parms);\r\ninet_insert_ifa(ifa);\r\n}\r\n}\r\nip_mc_up(in_dev);\r\ncase NETDEV_CHANGEADDR:\r\nif (!IN_DEV_ARP_NOTIFY(in_dev))\r\nbreak;\r\ncase NETDEV_NOTIFY_PEERS:\r\ninetdev_send_gratuitous_arp(dev, in_dev);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nip_mc_down(in_dev);\r\nbreak;\r\ncase NETDEV_PRE_TYPE_CHANGE:\r\nip_mc_unmap(in_dev);\r\nbreak;\r\ncase NETDEV_POST_TYPE_CHANGE:\r\nip_mc_remap(in_dev);\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nif (inetdev_valid_mtu(dev->mtu))\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\ninetdev_destroy(in_dev);\r\nbreak;\r\ncase NETDEV_CHANGENAME:\r\ninetdev_changename(dev, in_dev);\r\ndevinet_sysctl_unregister(in_dev);\r\ndevinet_sysctl_register(in_dev);\r\nbreak;\r\n}\r\nout:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic size_t inet_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(IFNAMSIZ)\r\n+ nla_total_size(4)\r\n+ nla_total_size(sizeof(struct ifa_cacheinfo));\r\n}\r\nstatic inline u32 cstamp_delta(unsigned long cstamp)\r\n{\r\nreturn (cstamp - INITIAL_JIFFIES) * 100UL / HZ;\r\n}\r\nstatic int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,\r\nunsigned long tstamp, u32 preferred, u32 valid)\r\n{\r\nstruct ifa_cacheinfo ci;\r\nci.cstamp = cstamp_delta(cstamp);\r\nci.tstamp = cstamp_delta(tstamp);\r\nci.ifa_prefered = preferred;\r\nci.ifa_valid = valid;\r\nreturn nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);\r\n}\r\nstatic int inet_fill_ifaddr(struct sk_buff *skb, struct in_ifaddr *ifa,\r\nu32 portid, u32 seq, int event, unsigned int flags)\r\n{\r\nstruct ifaddrmsg *ifm;\r\nstruct nlmsghdr *nlh;\r\nu32 preferred, valid;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*ifm), flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nifm = nlmsg_data(nlh);\r\nifm->ifa_family = AF_INET;\r\nifm->ifa_prefixlen = ifa->ifa_prefixlen;\r\nifm->ifa_flags = ifa->ifa_flags;\r\nifm->ifa_scope = ifa->ifa_scope;\r\nifm->ifa_index = ifa->ifa_dev->dev->ifindex;\r\nif (!(ifm->ifa_flags & IFA_F_PERMANENT)) {\r\npreferred = ifa->ifa_preferred_lft;\r\nvalid = ifa->ifa_valid_lft;\r\nif (preferred != INFINITY_LIFE_TIME) {\r\nlong tval = (jiffies - ifa->ifa_tstamp) / HZ;\r\nif (preferred > tval)\r\npreferred -= tval;\r\nelse\r\npreferred = 0;\r\nif (valid != INFINITY_LIFE_TIME) {\r\nif (valid > tval)\r\nvalid -= tval;\r\nelse\r\nvalid = 0;\r\n}\r\n}\r\n} else {\r\npreferred = INFINITY_LIFE_TIME;\r\nvalid = INFINITY_LIFE_TIME;\r\n}\r\nif ((ifa->ifa_address &&\r\nnla_put_in_addr(skb, IFA_ADDRESS, ifa->ifa_address)) ||\r\n(ifa->ifa_local &&\r\nnla_put_in_addr(skb, IFA_LOCAL, ifa->ifa_local)) ||\r\n(ifa->ifa_broadcast &&\r\nnla_put_in_addr(skb, IFA_BROADCAST, ifa->ifa_broadcast)) ||\r\n(ifa->ifa_label[0] &&\r\nnla_put_string(skb, IFA_LABEL, ifa->ifa_label)) ||\r\nnla_put_u32(skb, IFA_FLAGS, ifa->ifa_flags) ||\r\nput_cacheinfo(skb, ifa->ifa_cstamp, ifa->ifa_tstamp,\r\npreferred, valid))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int inet_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint h, s_h;\r\nint idx, s_idx;\r\nint ip_idx, s_ip_idx;\r\nstruct net_device *dev;\r\nstruct in_device *in_dev;\r\nstruct in_ifaddr *ifa;\r\nstruct hlist_head *head;\r\ns_h = cb->args[0];\r\ns_idx = idx = cb->args[1];\r\ns_ip_idx = ip_idx = cb->args[2];\r\nfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\r\nidx = 0;\r\nhead = &net->dev_index_head[h];\r\nrcu_read_lock();\r\ncb->seq = atomic_read(&net->ipv4.dev_addr_genid) ^\r\nnet->dev_base_seq;\r\nhlist_for_each_entry_rcu(dev, head, index_hlist) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nif (h > s_h || idx > s_idx)\r\ns_ip_idx = 0;\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (!in_dev)\r\ngoto cont;\r\nfor (ifa = in_dev->ifa_list, ip_idx = 0; ifa;\r\nifa = ifa->ifa_next, ip_idx++) {\r\nif (ip_idx < s_ip_idx)\r\ncontinue;\r\nif (inet_fill_ifaddr(skb, ifa,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWADDR, NLM_F_MULTI) < 0) {\r\nrcu_read_unlock();\r\ngoto done;\r\n}\r\nnl_dump_check_consistent(cb, nlmsg_hdr(skb));\r\n}\r\ncont:\r\nidx++;\r\n}\r\nrcu_read_unlock();\r\n}\r\ndone:\r\ncb->args[0] = h;\r\ncb->args[1] = idx;\r\ncb->args[2] = ip_idx;\r\nreturn skb->len;\r\n}\r\nstatic void rtmsg_ifa(int event, struct in_ifaddr *ifa, struct nlmsghdr *nlh,\r\nu32 portid)\r\n{\r\nstruct sk_buff *skb;\r\nu32 seq = nlh ? nlh->nlmsg_seq : 0;\r\nint err = -ENOBUFS;\r\nstruct net *net;\r\nnet = dev_net(ifa->ifa_dev->dev);\r\nskb = nlmsg_new(inet_nlmsg_size(), GFP_KERNEL);\r\nif (!skb)\r\ngoto errout;\r\nerr = inet_fill_ifaddr(skb, ifa, portid, seq, event, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, portid, RTNLGRP_IPV4_IFADDR, nlh, GFP_KERNEL);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_IPV4_IFADDR, err);\r\n}\r\nstatic size_t inet_get_link_af_size(const struct net_device *dev,\r\nu32 ext_filter_mask)\r\n{\r\nstruct in_device *in_dev = rcu_dereference_rtnl(dev->ip_ptr);\r\nif (!in_dev)\r\nreturn 0;\r\nreturn nla_total_size(IPV4_DEVCONF_MAX * 4);\r\n}\r\nstatic int inet_fill_link_af(struct sk_buff *skb, const struct net_device *dev,\r\nu32 ext_filter_mask)\r\n{\r\nstruct in_device *in_dev = rcu_dereference_rtnl(dev->ip_ptr);\r\nstruct nlattr *nla;\r\nint i;\r\nif (!in_dev)\r\nreturn -ENODATA;\r\nnla = nla_reserve(skb, IFLA_INET_CONF, IPV4_DEVCONF_MAX * 4);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nfor (i = 0; i < IPV4_DEVCONF_MAX; i++)\r\n((u32 *) nla_data(nla))[i] = in_dev->cnf.data[i];\r\nreturn 0;\r\n}\r\nstatic int inet_validate_link_af(const struct net_device *dev,\r\nconst struct nlattr *nla)\r\n{\r\nstruct nlattr *a, *tb[IFLA_INET_MAX+1];\r\nint err, rem;\r\nif (dev && !__in_dev_get_rtnl(dev))\r\nreturn -EAFNOSUPPORT;\r\nerr = nla_parse_nested(tb, IFLA_INET_MAX, nla, inet_af_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[IFLA_INET_CONF]) {\r\nnla_for_each_nested(a, tb[IFLA_INET_CONF], rem) {\r\nint cfgid = nla_type(a);\r\nif (nla_len(a) < 4)\r\nreturn -EINVAL;\r\nif (cfgid <= 0 || cfgid > IPV4_DEVCONF_MAX)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int inet_set_link_af(struct net_device *dev, const struct nlattr *nla)\r\n{\r\nstruct in_device *in_dev = __in_dev_get_rtnl(dev);\r\nstruct nlattr *a, *tb[IFLA_INET_MAX+1];\r\nint rem;\r\nif (!in_dev)\r\nreturn -EAFNOSUPPORT;\r\nif (nla_parse_nested(tb, IFLA_INET_MAX, nla, NULL) < 0)\r\nBUG();\r\nif (tb[IFLA_INET_CONF]) {\r\nnla_for_each_nested(a, tb[IFLA_INET_CONF], rem)\r\nipv4_devconf_set(in_dev, nla_type(a), nla_get_u32(a));\r\n}\r\nreturn 0;\r\n}\r\nstatic int inet_netconf_msgsize_devconf(int type)\r\n{\r\nint size = NLMSG_ALIGN(sizeof(struct netconfmsg))\r\n+ nla_total_size(4);\r\nbool all = false;\r\nif (type == NETCONFA_ALL)\r\nall = true;\r\nif (all || type == NETCONFA_FORWARDING)\r\nsize += nla_total_size(4);\r\nif (all || type == NETCONFA_RP_FILTER)\r\nsize += nla_total_size(4);\r\nif (all || type == NETCONFA_MC_FORWARDING)\r\nsize += nla_total_size(4);\r\nif (all || type == NETCONFA_PROXY_NEIGH)\r\nsize += nla_total_size(4);\r\nif (all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN)\r\nsize += nla_total_size(4);\r\nreturn size;\r\n}\r\nstatic int inet_netconf_fill_devconf(struct sk_buff *skb, int ifindex,\r\nstruct ipv4_devconf *devconf, u32 portid,\r\nu32 seq, int event, unsigned int flags,\r\nint type)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct netconfmsg *ncm;\r\nbool all = false;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct netconfmsg),\r\nflags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nif (type == NETCONFA_ALL)\r\nall = true;\r\nncm = nlmsg_data(nlh);\r\nncm->ncm_family = AF_INET;\r\nif (nla_put_s32(skb, NETCONFA_IFINDEX, ifindex) < 0)\r\ngoto nla_put_failure;\r\nif ((all || type == NETCONFA_FORWARDING) &&\r\nnla_put_s32(skb, NETCONFA_FORWARDING,\r\nIPV4_DEVCONF(*devconf, FORWARDING)) < 0)\r\ngoto nla_put_failure;\r\nif ((all || type == NETCONFA_RP_FILTER) &&\r\nnla_put_s32(skb, NETCONFA_RP_FILTER,\r\nIPV4_DEVCONF(*devconf, RP_FILTER)) < 0)\r\ngoto nla_put_failure;\r\nif ((all || type == NETCONFA_MC_FORWARDING) &&\r\nnla_put_s32(skb, NETCONFA_MC_FORWARDING,\r\nIPV4_DEVCONF(*devconf, MC_FORWARDING)) < 0)\r\ngoto nla_put_failure;\r\nif ((all || type == NETCONFA_PROXY_NEIGH) &&\r\nnla_put_s32(skb, NETCONFA_PROXY_NEIGH,\r\nIPV4_DEVCONF(*devconf, PROXY_ARP)) < 0)\r\ngoto nla_put_failure;\r\nif ((all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN) &&\r\nnla_put_s32(skb, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\r\nIPV4_DEVCONF(*devconf, IGNORE_ROUTES_WITH_LINKDOWN)) < 0)\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nvoid inet_netconf_notify_devconf(struct net *net, int type, int ifindex,\r\nstruct ipv4_devconf *devconf)\r\n{\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(inet_netconf_msgsize_devconf(type), GFP_KERNEL);\r\nif (!skb)\r\ngoto errout;\r\nerr = inet_netconf_fill_devconf(skb, ifindex, devconf, 0, 0,\r\nRTM_NEWNETCONF, 0, type);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_IPV4_NETCONF, NULL, GFP_KERNEL);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_IPV4_NETCONF, err);\r\n}\r\nstatic int inet_netconf_get_devconf(struct sk_buff *in_skb,\r\nstruct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct nlattr *tb[NETCONFA_MAX+1];\r\nstruct netconfmsg *ncm;\r\nstruct sk_buff *skb;\r\nstruct ipv4_devconf *devconf;\r\nstruct in_device *in_dev;\r\nstruct net_device *dev;\r\nint ifindex;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\r\ndevconf_ipv4_policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = -EINVAL;\r\nif (!tb[NETCONFA_IFINDEX])\r\ngoto errout;\r\nifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\r\nswitch (ifindex) {\r\ncase NETCONFA_IFINDEX_ALL:\r\ndevconf = net->ipv4.devconf_all;\r\nbreak;\r\ncase NETCONFA_IFINDEX_DEFAULT:\r\ndevconf = net->ipv4.devconf_dflt;\r\nbreak;\r\ndefault:\r\ndev = __dev_get_by_index(net, ifindex);\r\nif (!dev)\r\ngoto errout;\r\nin_dev = __in_dev_get_rtnl(dev);\r\nif (!in_dev)\r\ngoto errout;\r\ndevconf = &in_dev->cnf;\r\nbreak;\r\n}\r\nerr = -ENOBUFS;\r\nskb = nlmsg_new(inet_netconf_msgsize_devconf(NETCONFA_ALL), GFP_KERNEL);\r\nif (!skb)\r\ngoto errout;\r\nerr = inet_netconf_fill_devconf(skb, ifindex, devconf,\r\nNETLINK_CB(in_skb).portid,\r\nnlh->nlmsg_seq, RTM_NEWNETCONF, 0,\r\nNETCONFA_ALL);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nerr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int inet_netconf_dump_devconf(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint h, s_h;\r\nint idx, s_idx;\r\nstruct net_device *dev;\r\nstruct in_device *in_dev;\r\nstruct hlist_head *head;\r\ns_h = cb->args[0];\r\ns_idx = idx = cb->args[1];\r\nfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\r\nidx = 0;\r\nhead = &net->dev_index_head[h];\r\nrcu_read_lock();\r\ncb->seq = atomic_read(&net->ipv4.dev_addr_genid) ^\r\nnet->dev_base_seq;\r\nhlist_for_each_entry_rcu(dev, head, index_hlist) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (!in_dev)\r\ngoto cont;\r\nif (inet_netconf_fill_devconf(skb, dev->ifindex,\r\n&in_dev->cnf,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWNETCONF,\r\nNLM_F_MULTI,\r\nNETCONFA_ALL) < 0) {\r\nrcu_read_unlock();\r\ngoto done;\r\n}\r\nnl_dump_check_consistent(cb, nlmsg_hdr(skb));\r\ncont:\r\nidx++;\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (h == NETDEV_HASHENTRIES) {\r\nif (inet_netconf_fill_devconf(skb, NETCONFA_IFINDEX_ALL,\r\nnet->ipv4.devconf_all,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWNETCONF, NLM_F_MULTI,\r\nNETCONFA_ALL) < 0)\r\ngoto done;\r\nelse\r\nh++;\r\n}\r\nif (h == NETDEV_HASHENTRIES + 1) {\r\nif (inet_netconf_fill_devconf(skb, NETCONFA_IFINDEX_DEFAULT,\r\nnet->ipv4.devconf_dflt,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWNETCONF, NLM_F_MULTI,\r\nNETCONFA_ALL) < 0)\r\ngoto done;\r\nelse\r\nh++;\r\n}\r\ndone:\r\ncb->args[0] = h;\r\ncb->args[1] = idx;\r\nreturn skb->len;\r\n}\r\nstatic void devinet_copy_dflt_conf(struct net *net, int i)\r\n{\r\nstruct net_device *dev;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(net, dev) {\r\nstruct in_device *in_dev;\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (in_dev && !test_bit(i, in_dev->cnf.state))\r\nin_dev->cnf.data[i] = net->ipv4.devconf_dflt->data[i];\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void inet_forward_change(struct net *net)\r\n{\r\nstruct net_device *dev;\r\nint on = IPV4_DEVCONF_ALL(net, FORWARDING);\r\nIPV4_DEVCONF_ALL(net, ACCEPT_REDIRECTS) = !on;\r\nIPV4_DEVCONF_DFLT(net, FORWARDING) = on;\r\ninet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\r\nNETCONFA_IFINDEX_ALL,\r\nnet->ipv4.devconf_all);\r\ninet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\r\nNETCONFA_IFINDEX_DEFAULT,\r\nnet->ipv4.devconf_dflt);\r\nfor_each_netdev(net, dev) {\r\nstruct in_device *in_dev;\r\nif (on)\r\ndev_disable_lro(dev);\r\nin_dev = __in_dev_get_rtnl(dev);\r\nif (in_dev) {\r\nIN_DEV_CONF_SET(in_dev, FORWARDING, on);\r\ninet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\r\ndev->ifindex, &in_dev->cnf);\r\n}\r\n}\r\n}\r\nstatic int devinet_conf_ifindex(struct net *net, struct ipv4_devconf *cnf)\r\n{\r\nif (cnf == net->ipv4.devconf_dflt)\r\nreturn NETCONFA_IFINDEX_DEFAULT;\r\nelse if (cnf == net->ipv4.devconf_all)\r\nreturn NETCONFA_IFINDEX_ALL;\r\nelse {\r\nstruct in_device *idev\r\n= container_of(cnf, struct in_device, cnf);\r\nreturn idev->dev->ifindex;\r\n}\r\n}\r\nstatic int devinet_conf_proc(struct ctl_table *ctl, int write,\r\nvoid __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\nint old_value = *(int *)ctl->data;\r\nint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\r\nint new_value = *(int *)ctl->data;\r\nif (write) {\r\nstruct ipv4_devconf *cnf = ctl->extra1;\r\nstruct net *net = ctl->extra2;\r\nint i = (int *)ctl->data - cnf->data;\r\nint ifindex;\r\nset_bit(i, cnf->state);\r\nif (cnf == net->ipv4.devconf_dflt)\r\ndevinet_copy_dflt_conf(net, i);\r\nif (i == IPV4_DEVCONF_ACCEPT_LOCAL - 1 ||\r\ni == IPV4_DEVCONF_ROUTE_LOCALNET - 1)\r\nif ((new_value == 0) && (old_value != 0))\r\nrt_cache_flush(net);\r\nif (i == IPV4_DEVCONF_RP_FILTER - 1 &&\r\nnew_value != old_value) {\r\nifindex = devinet_conf_ifindex(net, cnf);\r\ninet_netconf_notify_devconf(net, NETCONFA_RP_FILTER,\r\nifindex, cnf);\r\n}\r\nif (i == IPV4_DEVCONF_PROXY_ARP - 1 &&\r\nnew_value != old_value) {\r\nifindex = devinet_conf_ifindex(net, cnf);\r\ninet_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,\r\nifindex, cnf);\r\n}\r\nif (i == IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN - 1 &&\r\nnew_value != old_value) {\r\nifindex = devinet_conf_ifindex(net, cnf);\r\ninet_netconf_notify_devconf(net, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\r\nifindex, cnf);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int devinet_sysctl_forward(struct ctl_table *ctl, int write,\r\nvoid __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\nint *valp = ctl->data;\r\nint val = *valp;\r\nloff_t pos = *ppos;\r\nint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\r\nif (write && *valp != val) {\r\nstruct net *net = ctl->extra2;\r\nif (valp != &IPV4_DEVCONF_DFLT(net, FORWARDING)) {\r\nif (!rtnl_trylock()) {\r\n*valp = val;\r\n*ppos = pos;\r\nreturn restart_syscall();\r\n}\r\nif (valp == &IPV4_DEVCONF_ALL(net, FORWARDING)) {\r\ninet_forward_change(net);\r\n} else {\r\nstruct ipv4_devconf *cnf = ctl->extra1;\r\nstruct in_device *idev =\r\ncontainer_of(cnf, struct in_device, cnf);\r\nif (*valp)\r\ndev_disable_lro(idev->dev);\r\ninet_netconf_notify_devconf(net,\r\nNETCONFA_FORWARDING,\r\nidev->dev->ifindex,\r\ncnf);\r\n}\r\nrtnl_unlock();\r\nrt_cache_flush(net);\r\n} else\r\ninet_netconf_notify_devconf(net, NETCONFA_FORWARDING,\r\nNETCONFA_IFINDEX_DEFAULT,\r\nnet->ipv4.devconf_dflt);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipv4_doint_and_flush(struct ctl_table *ctl, int write,\r\nvoid __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\nint *valp = ctl->data;\r\nint val = *valp;\r\nint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\r\nstruct net *net = ctl->extra2;\r\nif (write && *valp != val)\r\nrt_cache_flush(net);\r\nreturn ret;\r\n}\r\nstatic int __devinet_sysctl_register(struct net *net, char *dev_name,\r\nint ifindex, struct ipv4_devconf *p)\r\n{\r\nint i;\r\nstruct devinet_sysctl_table *t;\r\nchar path[sizeof("net/ipv4/conf/") + IFNAMSIZ];\r\nt = kmemdup(&devinet_sysctl, sizeof(*t), GFP_KERNEL);\r\nif (!t)\r\ngoto out;\r\nfor (i = 0; i < ARRAY_SIZE(t->devinet_vars) - 1; i++) {\r\nt->devinet_vars[i].data += (char *)p - (char *)&ipv4_devconf;\r\nt->devinet_vars[i].extra1 = p;\r\nt->devinet_vars[i].extra2 = net;\r\n}\r\nsnprintf(path, sizeof(path), "net/ipv4/conf/%s", dev_name);\r\nt->sysctl_header = register_net_sysctl(net, path, t->devinet_vars);\r\nif (!t->sysctl_header)\r\ngoto free;\r\np->sysctl = t;\r\ninet_netconf_notify_devconf(net, NETCONFA_ALL, ifindex, p);\r\nreturn 0;\r\nfree:\r\nkfree(t);\r\nout:\r\nreturn -ENOBUFS;\r\n}\r\nstatic void __devinet_sysctl_unregister(struct ipv4_devconf *cnf)\r\n{\r\nstruct devinet_sysctl_table *t = cnf->sysctl;\r\nif (!t)\r\nreturn;\r\ncnf->sysctl = NULL;\r\nunregister_net_sysctl_table(t->sysctl_header);\r\nkfree(t);\r\n}\r\nstatic int devinet_sysctl_register(struct in_device *idev)\r\n{\r\nint err;\r\nif (!sysctl_dev_name_is_allowed(idev->dev->name))\r\nreturn -EINVAL;\r\nerr = neigh_sysctl_register(idev->dev, idev->arp_parms, NULL);\r\nif (err)\r\nreturn err;\r\nerr = __devinet_sysctl_register(dev_net(idev->dev), idev->dev->name,\r\nidev->dev->ifindex, &idev->cnf);\r\nif (err)\r\nneigh_sysctl_unregister(idev->arp_parms);\r\nreturn err;\r\n}\r\nstatic void devinet_sysctl_unregister(struct in_device *idev)\r\n{\r\n__devinet_sysctl_unregister(&idev->cnf);\r\nneigh_sysctl_unregister(idev->arp_parms);\r\n}\r\nstatic __net_init int devinet_init_net(struct net *net)\r\n{\r\nint err;\r\nstruct ipv4_devconf *all, *dflt;\r\n#ifdef CONFIG_SYSCTL\r\nstruct ctl_table *tbl = ctl_forward_entry;\r\nstruct ctl_table_header *forw_hdr;\r\n#endif\r\nerr = -ENOMEM;\r\nall = &ipv4_devconf;\r\ndflt = &ipv4_devconf_dflt;\r\nif (!net_eq(net, &init_net)) {\r\nall = kmemdup(all, sizeof(ipv4_devconf), GFP_KERNEL);\r\nif (!all)\r\ngoto err_alloc_all;\r\ndflt = kmemdup(dflt, sizeof(ipv4_devconf_dflt), GFP_KERNEL);\r\nif (!dflt)\r\ngoto err_alloc_dflt;\r\n#ifdef CONFIG_SYSCTL\r\ntbl = kmemdup(tbl, sizeof(ctl_forward_entry), GFP_KERNEL);\r\nif (!tbl)\r\ngoto err_alloc_ctl;\r\ntbl[0].data = &all->data[IPV4_DEVCONF_FORWARDING - 1];\r\ntbl[0].extra1 = all;\r\ntbl[0].extra2 = net;\r\n#endif\r\n}\r\n#ifdef CONFIG_SYSCTL\r\nerr = __devinet_sysctl_register(net, "all", NETCONFA_IFINDEX_ALL, all);\r\nif (err < 0)\r\ngoto err_reg_all;\r\nerr = __devinet_sysctl_register(net, "default",\r\nNETCONFA_IFINDEX_DEFAULT, dflt);\r\nif (err < 0)\r\ngoto err_reg_dflt;\r\nerr = -ENOMEM;\r\nforw_hdr = register_net_sysctl(net, "net/ipv4", tbl);\r\nif (!forw_hdr)\r\ngoto err_reg_ctl;\r\nnet->ipv4.forw_hdr = forw_hdr;\r\n#endif\r\nnet->ipv4.devconf_all = all;\r\nnet->ipv4.devconf_dflt = dflt;\r\nreturn 0;\r\n#ifdef CONFIG_SYSCTL\r\nerr_reg_ctl:\r\n__devinet_sysctl_unregister(dflt);\r\nerr_reg_dflt:\r\n__devinet_sysctl_unregister(all);\r\nerr_reg_all:\r\nif (tbl != ctl_forward_entry)\r\nkfree(tbl);\r\nerr_alloc_ctl:\r\n#endif\r\nif (dflt != &ipv4_devconf_dflt)\r\nkfree(dflt);\r\nerr_alloc_dflt:\r\nif (all != &ipv4_devconf)\r\nkfree(all);\r\nerr_alloc_all:\r\nreturn err;\r\n}\r\nstatic __net_exit void devinet_exit_net(struct net *net)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nstruct ctl_table *tbl;\r\ntbl = net->ipv4.forw_hdr->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ipv4.forw_hdr);\r\n__devinet_sysctl_unregister(net->ipv4.devconf_dflt);\r\n__devinet_sysctl_unregister(net->ipv4.devconf_all);\r\nkfree(tbl);\r\n#endif\r\nkfree(net->ipv4.devconf_dflt);\r\nkfree(net->ipv4.devconf_all);\r\n}\r\nvoid __init devinet_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < IN4_ADDR_HSIZE; i++)\r\nINIT_HLIST_HEAD(&inet_addr_lst[i]);\r\nregister_pernet_subsys(&devinet_ops);\r\nregister_gifconf(PF_INET, inet_gifconf);\r\nregister_netdevice_notifier(&ip_netdev_notifier);\r\nqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\r\nrtnl_af_register(&inet_af_ops);\r\nrtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL, NULL);\r\nrtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL, NULL);\r\nrtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr, NULL);\r\nrtnl_register(PF_INET, RTM_GETNETCONF, inet_netconf_get_devconf,\r\ninet_netconf_dump_devconf, NULL);\r\n}
