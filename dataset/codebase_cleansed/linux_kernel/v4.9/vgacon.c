bool vgacon_text_force(void)\r\n{\r\nreturn vgacon_text_mode_force ? true : false;\r\n}\r\nstatic int __init text_mode(char *str)\r\n{\r\nvgacon_text_mode_force = 1;\r\nreturn 1;\r\n}\r\nstatic int __init no_scroll(char *str)\r\n{\r\nvga_hardscroll_user_enable = vga_hardscroll_enabled = 0;\r\nreturn 1;\r\n}\r\nstatic inline void write_vga(unsigned char reg, unsigned int val)\r\n{\r\nunsigned int v1, v2;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&vga_lock, flags);\r\n#ifndef SLOW_VGA\r\nv1 = reg + (val & 0xff00);\r\nv2 = reg + 1 + ((val << 8) & 0xff00);\r\noutw(v1, vga_video_port_reg);\r\noutw(v2, vga_video_port_reg);\r\n#else\r\noutb_p(reg, vga_video_port_reg);\r\noutb_p(val >> 8, vga_video_port_val);\r\noutb_p(reg + 1, vga_video_port_reg);\r\noutb_p(val & 0xff, vga_video_port_val);\r\n#endif\r\nraw_spin_unlock_irqrestore(&vga_lock, flags);\r\n}\r\nstatic inline void vga_set_mem_top(struct vc_data *c)\r\n{\r\nwrite_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);\r\n}\r\nstatic void vgacon_scrollback_init(int pitch)\r\n{\r\nint rows = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024/pitch;\r\nif (vgacon_scrollback) {\r\nvgacon_scrollback_cnt = 0;\r\nvgacon_scrollback_tail = 0;\r\nvgacon_scrollback_cur = 0;\r\nvgacon_scrollback_rows = rows - 1;\r\nvgacon_scrollback_size = rows * pitch;\r\n}\r\n}\r\nstatic void vgacon_scrollback_startup(void)\r\n{\r\nvgacon_scrollback = kcalloc(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024, GFP_NOWAIT);\r\nvgacon_scrollback_init(vga_video_num_columns * 2);\r\n}\r\nstatic void vgacon_scrollback_update(struct vc_data *c, int t, int count)\r\n{\r\nvoid *p;\r\nif (!vgacon_scrollback_size || c->vc_num != fg_console)\r\nreturn;\r\np = (void *) (c->vc_origin + t * c->vc_size_row);\r\nwhile (count--) {\r\nscr_memcpyw(vgacon_scrollback + vgacon_scrollback_tail,\r\np, c->vc_size_row);\r\nvgacon_scrollback_cnt++;\r\np += c->vc_size_row;\r\nvgacon_scrollback_tail += c->vc_size_row;\r\nif (vgacon_scrollback_tail >= vgacon_scrollback_size)\r\nvgacon_scrollback_tail = 0;\r\nif (vgacon_scrollback_cnt > vgacon_scrollback_rows)\r\nvgacon_scrollback_cnt = vgacon_scrollback_rows;\r\nvgacon_scrollback_cur = vgacon_scrollback_cnt;\r\n}\r\n}\r\nstatic void vgacon_restore_screen(struct vc_data *c)\r\n{\r\nvgacon_scrollback_save = 0;\r\nif (!vga_is_gfx && !vgacon_scrollback_restore) {\r\nscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\r\nc->vc_screenbuf_size > vga_vram_size ?\r\nvga_vram_size : c->vc_screenbuf_size);\r\nvgacon_scrollback_restore = 1;\r\nvgacon_scrollback_cur = vgacon_scrollback_cnt;\r\n}\r\n}\r\nstatic void vgacon_scrolldelta(struct vc_data *c, int lines)\r\n{\r\nint start, end, count, soff;\r\nif (!lines) {\r\nc->vc_visible_origin = c->vc_origin;\r\nvga_set_mem_top(c);\r\nreturn;\r\n}\r\nif (!vgacon_scrollback)\r\nreturn;\r\nif (!vgacon_scrollback_save) {\r\nvgacon_cursor(c, CM_ERASE);\r\nvgacon_save_screen(c);\r\nvgacon_scrollback_save = 1;\r\n}\r\nvgacon_scrollback_restore = 0;\r\nstart = vgacon_scrollback_cur + lines;\r\nend = start + abs(lines);\r\nif (start < 0)\r\nstart = 0;\r\nif (start > vgacon_scrollback_cnt)\r\nstart = vgacon_scrollback_cnt;\r\nif (end < 0)\r\nend = 0;\r\nif (end > vgacon_scrollback_cnt)\r\nend = vgacon_scrollback_cnt;\r\nvgacon_scrollback_cur = start;\r\ncount = end - start;\r\nsoff = vgacon_scrollback_tail - ((vgacon_scrollback_cnt - end) *\r\nc->vc_size_row);\r\nsoff -= count * c->vc_size_row;\r\nif (soff < 0)\r\nsoff += vgacon_scrollback_size;\r\ncount = vgacon_scrollback_cnt - start;\r\nif (count > c->vc_rows)\r\ncount = c->vc_rows;\r\nif (count) {\r\nint copysize;\r\nint diff = c->vc_rows - count;\r\nvoid *d = (void *) c->vc_origin;\r\nvoid *s = (void *) c->vc_screenbuf;\r\ncount *= c->vc_size_row;\r\ncopysize = min(count, vgacon_scrollback_size - soff);\r\nscr_memcpyw(d, vgacon_scrollback + soff, copysize);\r\nd += copysize;\r\ncount -= copysize;\r\nif (count) {\r\nscr_memcpyw(d, vgacon_scrollback, count);\r\nd += count;\r\n}\r\nif (diff)\r\nscr_memcpyw(d, s, diff * c->vc_size_row);\r\n} else\r\nvgacon_cursor(c, CM_MOVE);\r\n}\r\nstatic void vgacon_restore_screen(struct vc_data *c)\r\n{\r\nif (c->vc_origin != c->vc_visible_origin)\r\nvgacon_scrolldelta(c, 0);\r\n}\r\nstatic void vgacon_scrolldelta(struct vc_data *c, int lines)\r\n{\r\nif (!lines)\r\nc->vc_visible_origin = c->vc_origin;\r\nelse {\r\nint margin = c->vc_size_row * 4;\r\nint ul, we, p, st;\r\nif (vga_rolled_over >\r\n(c->vc_scr_end - vga_vram_base) + margin) {\r\nul = c->vc_scr_end - vga_vram_base;\r\nwe = vga_rolled_over + c->vc_size_row;\r\n} else {\r\nul = 0;\r\nwe = vga_vram_size;\r\n}\r\np = (c->vc_visible_origin - vga_vram_base - ul + we) % we +\r\nlines * c->vc_size_row;\r\nst = (c->vc_origin - vga_vram_base - ul + we) % we;\r\nif (st < 2 * margin)\r\nmargin = 0;\r\nif (p < margin)\r\np = 0;\r\nif (p > st - margin)\r\np = st;\r\nc->vc_visible_origin = vga_vram_base + (p + ul) % we;\r\n}\r\nvga_set_mem_top(c);\r\n}\r\nstatic const char *vgacon_startup(void)\r\n{\r\nconst char *display_desc = NULL;\r\nu16 saved1, saved2;\r\nvolatile u16 *p;\r\nif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||\r\nscreen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {\r\nno_vga:\r\n#ifdef CONFIG_DUMMY_CONSOLE\r\nconswitchp = &dummy_con;\r\nreturn conswitchp->con_startup();\r\n#else\r\nreturn NULL;\r\n#endif\r\n}\r\nif ((screen_info.orig_video_mode == 0) &&\r\n(screen_info.orig_video_lines == 0) &&\r\n(screen_info.orig_video_cols == 0))\r\ngoto no_vga;\r\nif ((screen_info.orig_video_mode == 0x0D) ||\r\n(screen_info.orig_video_mode == 0x0E) ||\r\n(screen_info.orig_video_mode == 0x10) ||\r\n(screen_info.orig_video_mode == 0x12) ||\r\n(screen_info.orig_video_mode == 0x6A))\r\ngoto no_vga;\r\nvga_video_num_lines = screen_info.orig_video_lines;\r\nvga_video_num_columns = screen_info.orig_video_cols;\r\nvgastate.vgabase = NULL;\r\nif (screen_info.orig_video_mode == 7) {\r\nvga_vram_base = 0xb0000;\r\nvga_video_port_reg = VGA_CRT_IM;\r\nvga_video_port_val = VGA_CRT_DM;\r\nif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\r\nstatic struct resource ega_console_resource =\r\n{ .name = "ega", .start = 0x3B0, .end = 0x3BF };\r\nvga_video_type = VIDEO_TYPE_EGAM;\r\nvga_vram_size = 0x8000;\r\ndisplay_desc = "EGA+";\r\nrequest_resource(&ioport_resource,\r\n&ega_console_resource);\r\n} else {\r\nstatic struct resource mda1_console_resource =\r\n{ .name = "mda", .start = 0x3B0, .end = 0x3BB };\r\nstatic struct resource mda2_console_resource =\r\n{ .name = "mda", .start = 0x3BF, .end = 0x3BF };\r\nvga_video_type = VIDEO_TYPE_MDA;\r\nvga_vram_size = 0x2000;\r\ndisplay_desc = "*MDA";\r\nrequest_resource(&ioport_resource,\r\n&mda1_console_resource);\r\nrequest_resource(&ioport_resource,\r\n&mda2_console_resource);\r\nvga_video_font_height = 14;\r\n}\r\n} else {\r\nvga_can_do_color = 1;\r\nvga_vram_base = 0xb8000;\r\nvga_video_port_reg = VGA_CRT_IC;\r\nvga_video_port_val = VGA_CRT_DC;\r\nif ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {\r\nint i;\r\nvga_vram_size = 0x8000;\r\nif (!screen_info.orig_video_isVGA) {\r\nstatic struct resource ega_console_resource\r\n= { .name = "ega", .start = 0x3C0, .end = 0x3DF };\r\nvga_video_type = VIDEO_TYPE_EGAC;\r\ndisplay_desc = "EGA";\r\nrequest_resource(&ioport_resource,\r\n&ega_console_resource);\r\n} else {\r\nstatic struct resource vga_console_resource\r\n= { .name = "vga+", .start = 0x3C0, .end = 0x3DF };\r\nvga_video_type = VIDEO_TYPE_VGAC;\r\ndisplay_desc = "VGA+";\r\nrequest_resource(&ioport_resource,\r\n&vga_console_resource);\r\n#ifdef VGA_CAN_DO_64KB\r\nvga_vram_base = 0xa0000;\r\nvga_vram_size = 0x10000;\r\noutb_p(6, VGA_GFX_I);\r\noutb_p(6, VGA_GFX_D);\r\n#endif\r\nfor (i = 0; i < 16; i++) {\r\ninb_p(VGA_IS1_RC);\r\noutb_p(i, VGA_ATT_W);\r\noutb_p(i, VGA_ATT_W);\r\n}\r\noutb_p(0x20, VGA_ATT_W);\r\nfor (i = 0; i < 16; i++) {\r\noutb_p(color_table[i], VGA_PEL_IW);\r\noutb_p(default_red[i], VGA_PEL_D);\r\noutb_p(default_grn[i], VGA_PEL_D);\r\noutb_p(default_blu[i], VGA_PEL_D);\r\n}\r\n}\r\n} else {\r\nstatic struct resource cga_console_resource =\r\n{ .name = "cga", .start = 0x3D4, .end = 0x3D5 };\r\nvga_video_type = VIDEO_TYPE_CGA;\r\nvga_vram_size = 0x2000;\r\ndisplay_desc = "*CGA";\r\nrequest_resource(&ioport_resource,\r\n&cga_console_resource);\r\nvga_video_font_height = 8;\r\n}\r\n}\r\nvga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);\r\nvga_vram_end = vga_vram_base + vga_vram_size;\r\np = (volatile u16 *) vga_vram_base;\r\nsaved1 = scr_readw(p);\r\nsaved2 = scr_readw(p + 1);\r\nscr_writew(0xAA55, p);\r\nscr_writew(0x55AA, p + 1);\r\nif (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {\r\nscr_writew(saved1, p);\r\nscr_writew(saved2, p + 1);\r\ngoto no_vga;\r\n}\r\nscr_writew(0x55AA, p);\r\nscr_writew(0xAA55, p + 1);\r\nif (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {\r\nscr_writew(saved1, p);\r\nscr_writew(saved2, p + 1);\r\ngoto no_vga;\r\n}\r\nscr_writew(saved1, p);\r\nscr_writew(saved2, p + 1);\r\nif (vga_video_type == VIDEO_TYPE_EGAC\r\n|| vga_video_type == VIDEO_TYPE_VGAC\r\n|| vga_video_type == VIDEO_TYPE_EGAM) {\r\nvga_hardscroll_enabled = vga_hardscroll_user_enable;\r\nvga_default_font_height = screen_info.orig_video_points;\r\nvga_video_font_height = screen_info.orig_video_points;\r\nvga_scan_lines =\r\nvga_video_font_height * vga_video_num_lines;\r\n}\r\nvgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;\r\nvgacon_yres = vga_scan_lines;\r\nif (!vga_init_done) {\r\nvgacon_scrollback_startup();\r\nvga_init_done = 1;\r\n}\r\nreturn display_desc;\r\n}\r\nstatic void vgacon_init(struct vc_data *c, int init)\r\n{\r\nstruct uni_pagedir *p;\r\nc->vc_can_do_color = vga_can_do_color;\r\nif (init) {\r\nc->vc_cols = vga_video_num_columns;\r\nc->vc_rows = vga_video_num_lines;\r\n} else\r\nvc_resize(c, vga_video_num_columns, vga_video_num_lines);\r\nc->vc_scan_lines = vga_scan_lines;\r\nc->vc_font.height = vga_video_font_height;\r\nc->vc_complement_mask = 0x7700;\r\nif (vga_512_chars)\r\nc->vc_hi_font_mask = 0x0800;\r\np = *c->vc_uni_pagedir_loc;\r\nif (c->vc_uni_pagedir_loc != &vgacon_uni_pagedir) {\r\ncon_free_unimap(c);\r\nc->vc_uni_pagedir_loc = &vgacon_uni_pagedir;\r\nvgacon_refcount++;\r\n}\r\nif (!vgacon_uni_pagedir && p)\r\ncon_set_default_unimap(c);\r\nif (global_cursor_default == -1)\r\nglobal_cursor_default =\r\n!(screen_info.flags & VIDEO_FLAGS_NOCURSOR);\r\n}\r\nstatic void vgacon_deinit(struct vc_data *c)\r\n{\r\nif (con_is_visible(c)) {\r\nc->vc_visible_origin = vga_vram_base;\r\nvga_set_mem_top(c);\r\n}\r\nif (!--vgacon_refcount)\r\ncon_free_unimap(c);\r\nc->vc_uni_pagedir_loc = &c->vc_uni_pagedir;\r\ncon_set_default_unimap(c);\r\n}\r\nstatic u8 vgacon_build_attr(struct vc_data *c, u8 color, u8 intensity,\r\nu8 blink, u8 underline, u8 reverse, u8 italic)\r\n{\r\nu8 attr = color;\r\nif (vga_can_do_color) {\r\nif (italic)\r\nattr = (attr & 0xF0) | c->vc_itcolor;\r\nelse if (underline)\r\nattr = (attr & 0xf0) | c->vc_ulcolor;\r\nelse if (intensity == 0)\r\nattr = (attr & 0xf0) | c->vc_halfcolor;\r\n}\r\nif (reverse)\r\nattr =\r\n((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &\r\n0x77);\r\nif (blink)\r\nattr ^= 0x80;\r\nif (intensity == 2)\r\nattr ^= 0x08;\r\nif (!vga_can_do_color) {\r\nif (italic)\r\nattr = (attr & 0xF8) | 0x02;\r\nelse if (underline)\r\nattr = (attr & 0xf8) | 0x01;\r\nelse if (intensity == 0)\r\nattr = (attr & 0xf0) | 0x08;\r\n}\r\nreturn attr;\r\n}\r\nstatic void vgacon_invert_region(struct vc_data *c, u16 * p, int count)\r\n{\r\nint col = vga_can_do_color;\r\nwhile (count--) {\r\nu16 a = scr_readw(p);\r\nif (col)\r\na = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\r\n(((a) & 0x0700) << 4);\r\nelse\r\na ^= ((a & 0x0700) == 0x0100) ? 0x7000 : 0x7700;\r\nscr_writew(a, p++);\r\n}\r\n}\r\nstatic void vgacon_set_cursor_size(int xpos, int from, int to)\r\n{\r\nunsigned long flags;\r\nint curs, cure;\r\n#ifdef TRIDENT_GLITCH\r\nif (xpos < 16)\r\nfrom--, to--;\r\n#endif\r\nif ((from == cursor_size_lastfrom) && (to == cursor_size_lastto))\r\nreturn;\r\ncursor_size_lastfrom = from;\r\ncursor_size_lastto = to;\r\nraw_spin_lock_irqsave(&vga_lock, flags);\r\nif (vga_video_type >= VIDEO_TYPE_VGAC) {\r\noutb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);\r\ncurs = inb_p(vga_video_port_val);\r\noutb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);\r\ncure = inb_p(vga_video_port_val);\r\n} else {\r\ncurs = 0;\r\ncure = 0;\r\n}\r\ncurs = (curs & 0xc0) | from;\r\ncure = (cure & 0xe0) | to;\r\noutb_p(VGA_CRTC_CURSOR_START, vga_video_port_reg);\r\noutb_p(curs, vga_video_port_val);\r\noutb_p(VGA_CRTC_CURSOR_END, vga_video_port_reg);\r\noutb_p(cure, vga_video_port_val);\r\nraw_spin_unlock_irqrestore(&vga_lock, flags);\r\n}\r\nstatic void vgacon_cursor(struct vc_data *c, int mode)\r\n{\r\nif (c->vc_mode != KD_TEXT)\r\nreturn;\r\nvgacon_restore_screen(c);\r\nswitch (mode) {\r\ncase CM_ERASE:\r\nwrite_vga(14, (c->vc_pos - vga_vram_base) / 2);\r\nif (vga_video_type >= VIDEO_TYPE_VGAC)\r\nvgacon_set_cursor_size(c->vc_x, 31, 30);\r\nelse\r\nvgacon_set_cursor_size(c->vc_x, 31, 31);\r\nbreak;\r\ncase CM_MOVE:\r\ncase CM_DRAW:\r\nwrite_vga(14, (c->vc_pos - vga_vram_base) / 2);\r\nswitch (c->vc_cursor_type & 0x0f) {\r\ncase CUR_UNDERLINE:\r\nvgacon_set_cursor_size(c->vc_x,\r\nc->vc_font.height -\r\n(c->vc_font.height <\r\n10 ? 2 : 3),\r\nc->vc_font.height -\r\n(c->vc_font.height <\r\n10 ? 1 : 2));\r\nbreak;\r\ncase CUR_TWO_THIRDS:\r\nvgacon_set_cursor_size(c->vc_x,\r\nc->vc_font.height / 3,\r\nc->vc_font.height -\r\n(c->vc_font.height <\r\n10 ? 1 : 2));\r\nbreak;\r\ncase CUR_LOWER_THIRD:\r\nvgacon_set_cursor_size(c->vc_x,\r\n(c->vc_font.height * 2) / 3,\r\nc->vc_font.height -\r\n(c->vc_font.height <\r\n10 ? 1 : 2));\r\nbreak;\r\ncase CUR_LOWER_HALF:\r\nvgacon_set_cursor_size(c->vc_x,\r\nc->vc_font.height / 2,\r\nc->vc_font.height -\r\n(c->vc_font.height <\r\n10 ? 1 : 2));\r\nbreak;\r\ncase CUR_NONE:\r\nif (vga_video_type >= VIDEO_TYPE_VGAC)\r\nvgacon_set_cursor_size(c->vc_x, 31, 30);\r\nelse\r\nvgacon_set_cursor_size(c->vc_x, 31, 31);\r\nbreak;\r\ndefault:\r\nvgacon_set_cursor_size(c->vc_x, 1,\r\nc->vc_font.height);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int vgacon_doresize(struct vc_data *c,\r\nunsigned int width, unsigned int height)\r\n{\r\nunsigned long flags;\r\nunsigned int scanlines = height * c->vc_font.height;\r\nu8 scanlines_lo = 0, r7 = 0, vsync_end = 0, mode, max_scan;\r\nraw_spin_lock_irqsave(&vga_lock, flags);\r\nvgacon_xres = width * VGA_FONTWIDTH;\r\nvgacon_yres = height * c->vc_font.height;\r\nif (vga_video_type >= VIDEO_TYPE_VGAC) {\r\noutb_p(VGA_CRTC_MAX_SCAN, vga_video_port_reg);\r\nmax_scan = inb_p(vga_video_port_val);\r\nif (max_scan & 0x80)\r\nscanlines <<= 1;\r\noutb_p(VGA_CRTC_MODE, vga_video_port_reg);\r\nmode = inb_p(vga_video_port_val);\r\nif (mode & 0x04)\r\nscanlines >>= 1;\r\nscanlines -= 1;\r\nscanlines_lo = scanlines & 0xff;\r\noutb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);\r\nr7 = inb_p(vga_video_port_val) & ~0x42;\r\nif (scanlines & 0x100)\r\nr7 |= 0x02;\r\nif (scanlines & 0x200)\r\nr7 |= 0x40;\r\noutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\r\nvsync_end = inb_p(vga_video_port_val);\r\noutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\r\noutb_p(vsync_end & ~0x80, vga_video_port_val);\r\n}\r\noutb_p(VGA_CRTC_H_DISP, vga_video_port_reg);\r\noutb_p(width - 1, vga_video_port_val);\r\noutb_p(VGA_CRTC_OFFSET, vga_video_port_reg);\r\noutb_p(width >> 1, vga_video_port_val);\r\nif (vga_video_type >= VIDEO_TYPE_VGAC) {\r\noutb_p(VGA_CRTC_V_DISP_END, vga_video_port_reg);\r\noutb_p(scanlines_lo, vga_video_port_val);\r\noutb_p(VGA_CRTC_OVERFLOW, vga_video_port_reg);\r\noutb_p(r7,vga_video_port_val);\r\noutb_p(VGA_CRTC_V_SYNC_END, vga_video_port_reg);\r\noutb_p(vsync_end, vga_video_port_val);\r\n}\r\nraw_spin_unlock_irqrestore(&vga_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vgacon_switch(struct vc_data *c)\r\n{\r\nint x = c->vc_cols * VGA_FONTWIDTH;\r\nint y = c->vc_rows * c->vc_font.height;\r\nint rows = screen_info.orig_video_lines * vga_default_font_height/\r\nc->vc_font.height;\r\nvga_video_num_columns = c->vc_cols;\r\nvga_video_num_lines = c->vc_rows;\r\nif (!vga_is_gfx) {\r\nscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\r\nc->vc_screenbuf_size > vga_vram_size ?\r\nvga_vram_size : c->vc_screenbuf_size);\r\nif ((vgacon_xres != x || vgacon_yres != y) &&\r\n(!(vga_video_num_columns % 2) &&\r\nvga_video_num_columns <= screen_info.orig_video_cols &&\r\nvga_video_num_lines <= rows))\r\nvgacon_doresize(c, c->vc_cols, c->vc_rows);\r\n}\r\nvgacon_scrollback_init(c->vc_size_row);\r\nreturn 0;\r\n}\r\nstatic void vga_set_palette(struct vc_data *vc, const unsigned char *table)\r\n{\r\nint i, j;\r\nvga_w(vgastate.vgabase, VGA_PEL_MSK, 0xff);\r\nfor (i = j = 0; i < 16; i++) {\r\nvga_w(vgastate.vgabase, VGA_PEL_IW, table[i]);\r\nvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\r\nvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\r\nvga_w(vgastate.vgabase, VGA_PEL_D, vc->vc_palette[j++] >> 2);\r\n}\r\n}\r\nstatic void vgacon_set_palette(struct vc_data *vc, const unsigned char *table)\r\n{\r\n#ifdef CAN_LOAD_PALETTE\r\nif (vga_video_type != VIDEO_TYPE_VGAC || vga_palette_blanked\r\n|| !con_is_visible(vc))\r\nreturn;\r\nvga_set_palette(vc, table);\r\n#endif\r\n}\r\nstatic void vga_vesa_blank(struct vgastate *state, int mode)\r\n{\r\nif (!vga_vesa_blanked) {\r\nraw_spin_lock_irq(&vga_lock);\r\nvga_state.SeqCtrlIndex = vga_r(state->vgabase, VGA_SEQ_I);\r\nvga_state.CrtCtrlIndex = inb_p(vga_video_port_reg);\r\nvga_state.CrtMiscIO = vga_r(state->vgabase, VGA_MIS_R);\r\nraw_spin_unlock_irq(&vga_lock);\r\noutb_p(0x00, vga_video_port_reg);\r\nvga_state.HorizontalTotal = inb_p(vga_video_port_val);\r\noutb_p(0x01, vga_video_port_reg);\r\nvga_state.HorizDisplayEnd = inb_p(vga_video_port_val);\r\noutb_p(0x04, vga_video_port_reg);\r\nvga_state.StartHorizRetrace = inb_p(vga_video_port_val);\r\noutb_p(0x05, vga_video_port_reg);\r\nvga_state.EndHorizRetrace = inb_p(vga_video_port_val);\r\noutb_p(0x07, vga_video_port_reg);\r\nvga_state.Overflow = inb_p(vga_video_port_val);\r\noutb_p(0x10, vga_video_port_reg);\r\nvga_state.StartVertRetrace = inb_p(vga_video_port_val);\r\noutb_p(0x11, vga_video_port_reg);\r\nvga_state.EndVertRetrace = inb_p(vga_video_port_val);\r\noutb_p(0x17, vga_video_port_reg);\r\nvga_state.ModeControl = inb_p(vga_video_port_val);\r\nvga_state.ClockingMode = vga_rseq(state->vgabase, VGA_SEQ_CLOCK_MODE);\r\n}\r\nraw_spin_lock_irq(&vga_lock);\r\nvga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode | 0x20);\r\nif ((vga_state.CrtMiscIO & 0x80) == 0x80)\r\nvga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO & 0xEF);\r\nif (mode & VESA_VSYNC_SUSPEND) {\r\noutb_p(0x10, vga_video_port_reg);\r\noutb_p(0xff, vga_video_port_val);\r\noutb_p(0x11, vga_video_port_reg);\r\noutb_p(0x40, vga_video_port_val);\r\noutb_p(0x07, vga_video_port_reg);\r\noutb_p(vga_state.Overflow | 0x84, vga_video_port_val);\r\n}\r\nif (mode & VESA_HSYNC_SUSPEND) {\r\noutb_p(0x04, vga_video_port_reg);\r\noutb_p(0xff, vga_video_port_val);\r\noutb_p(0x05, vga_video_port_reg);\r\noutb_p(0x00, vga_video_port_val);\r\n}\r\nvga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);\r\noutb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);\r\nraw_spin_unlock_irq(&vga_lock);\r\n}\r\nstatic void vga_vesa_unblank(struct vgastate *state)\r\n{\r\nraw_spin_lock_irq(&vga_lock);\r\nvga_w(state->vgabase, VGA_MIS_W, vga_state.CrtMiscIO);\r\noutb_p(0x00, vga_video_port_reg);\r\noutb_p(vga_state.HorizontalTotal, vga_video_port_val);\r\noutb_p(0x01, vga_video_port_reg);\r\noutb_p(vga_state.HorizDisplayEnd, vga_video_port_val);\r\noutb_p(0x04, vga_video_port_reg);\r\noutb_p(vga_state.StartHorizRetrace, vga_video_port_val);\r\noutb_p(0x05, vga_video_port_reg);\r\noutb_p(vga_state.EndHorizRetrace, vga_video_port_val);\r\noutb_p(0x07, vga_video_port_reg);\r\noutb_p(vga_state.Overflow, vga_video_port_val);\r\noutb_p(0x10, vga_video_port_reg);\r\noutb_p(vga_state.StartVertRetrace, vga_video_port_val);\r\noutb_p(0x11, vga_video_port_reg);\r\noutb_p(vga_state.EndVertRetrace, vga_video_port_val);\r\noutb_p(0x17, vga_video_port_reg);\r\noutb_p(vga_state.ModeControl, vga_video_port_val);\r\nvga_wseq(state->vgabase, VGA_SEQ_CLOCK_MODE, vga_state.ClockingMode);\r\nvga_w(state->vgabase, VGA_SEQ_I, vga_state.SeqCtrlIndex);\r\noutb_p(vga_state.CrtCtrlIndex, vga_video_port_reg);\r\nraw_spin_unlock_irq(&vga_lock);\r\n}\r\nstatic void vga_pal_blank(struct vgastate *state)\r\n{\r\nint i;\r\nvga_w(state->vgabase, VGA_PEL_MSK, 0xff);\r\nfor (i = 0; i < 16; i++) {\r\nvga_w(state->vgabase, VGA_PEL_IW, i);\r\nvga_w(state->vgabase, VGA_PEL_D, 0);\r\nvga_w(state->vgabase, VGA_PEL_D, 0);\r\nvga_w(state->vgabase, VGA_PEL_D, 0);\r\n}\r\n}\r\nstatic int vgacon_blank(struct vc_data *c, int blank, int mode_switch)\r\n{\r\nswitch (blank) {\r\ncase 0:\r\nif (vga_vesa_blanked) {\r\nvga_vesa_unblank(&vgastate);\r\nvga_vesa_blanked = 0;\r\n}\r\nif (vga_palette_blanked) {\r\nvga_set_palette(c, color_table);\r\nvga_palette_blanked = 0;\r\nreturn 0;\r\n}\r\nvga_is_gfx = 0;\r\nreturn 1;\r\ncase 1:\r\ncase -1:\r\nif (!mode_switch && vga_video_type == VIDEO_TYPE_VGAC) {\r\nvga_pal_blank(&vgastate);\r\nvga_palette_blanked = 1;\r\nreturn 0;\r\n}\r\nvgacon_set_origin(c);\r\nscr_memsetw((void *) vga_vram_base, BLANK,\r\nc->vc_screenbuf_size);\r\nif (mode_switch)\r\nvga_is_gfx = 1;\r\nreturn 1;\r\ndefault:\r\nif (vga_video_type == VIDEO_TYPE_VGAC) {\r\nvga_vesa_blank(&vgastate, blank - 1);\r\nvga_vesa_blanked = blank;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nstatic int vgacon_do_font_op(struct vgastate *state,char *arg,int set,int ch512)\r\n{\r\nunsigned short video_port_status = vga_video_port_reg + 6;\r\nint font_select = 0x00, beg, i;\r\nchar *charmap;\r\nbool clear_attribs = false;\r\nif (vga_video_type != VIDEO_TYPE_EGAM) {\r\ncharmap = (char *) VGA_MAP_MEM(colourmap, 0);\r\nbeg = 0x0e;\r\n#ifdef VGA_CAN_DO_64KB\r\nif (vga_video_type == VIDEO_TYPE_VGAC)\r\nbeg = 0x06;\r\n#endif\r\n} else {\r\ncharmap = (char *) VGA_MAP_MEM(blackwmap, 0);\r\nbeg = 0x0a;\r\n}\r\n#ifdef BROKEN_GRAPHICS_PROGRAMS\r\nif (!arg)\r\nreturn -EINVAL;\r\nvga_font_is_default = 0;\r\nfont_select = ch512 ? 0x04 : 0x00;\r\n#else\r\nif (set) {\r\nvga_font_is_default = !arg;\r\nif (!arg)\r\nch512 = 0;\r\nfont_select = arg ? (ch512 ? 0x0e : 0x0a) : 0x00;\r\n}\r\nif (!vga_font_is_default)\r\ncharmap += 4 * cmapsz;\r\n#endif\r\nraw_spin_lock_irq(&vga_lock);\r\nvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x1);\r\nvga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x04);\r\nvga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x07);\r\nvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);\r\nvga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x02);\r\nvga_wgfx(state->vgabase, VGA_GFX_MODE, 0x00);\r\nvga_wgfx(state->vgabase, VGA_GFX_MISC, 0x00);\r\nraw_spin_unlock_irq(&vga_lock);\r\nif (arg) {\r\nif (set)\r\nfor (i = 0; i < cmapsz; i++) {\r\nvga_writeb(arg[i], charmap + i);\r\ncond_resched();\r\n}\r\nelse\r\nfor (i = 0; i < cmapsz; i++) {\r\narg[i] = vga_readb(charmap + i);\r\ncond_resched();\r\n}\r\nif (ch512) {\r\ncharmap += 2 * cmapsz;\r\narg += cmapsz;\r\nif (set)\r\nfor (i = 0; i < cmapsz; i++) {\r\nvga_writeb(arg[i], charmap + i);\r\ncond_resched();\r\n}\r\nelse\r\nfor (i = 0; i < cmapsz; i++) {\r\narg[i] = vga_readb(charmap + i);\r\ncond_resched();\r\n}\r\n}\r\n}\r\nraw_spin_lock_irq(&vga_lock);\r\nvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x01);\r\nvga_wseq(state->vgabase, VGA_SEQ_PLANE_WRITE, 0x03);\r\nvga_wseq(state->vgabase, VGA_SEQ_MEMORY_MODE, 0x03);\r\nif (set)\r\nvga_wseq(state->vgabase, VGA_SEQ_CHARACTER_MAP, font_select);\r\nvga_wseq(state->vgabase, VGA_SEQ_RESET, 0x03);\r\nvga_wgfx(state->vgabase, VGA_GFX_PLANE_READ, 0x00);\r\nvga_wgfx(state->vgabase, VGA_GFX_MODE, 0x10);\r\nvga_wgfx(state->vgabase, VGA_GFX_MISC, beg);\r\nif ((set) && (ch512 != vga_512_chars)) {\r\nvga_512_chars = ch512;\r\ninb_p(video_port_status);\r\nvga_wattr(state->vgabase, VGA_ATC_PLANE_ENABLE, ch512 ? 0x07 : 0x0f);\r\ninb_p(video_port_status);\r\nvga_wattr(state->vgabase, VGA_AR_ENABLE_DISPLAY, 0);\r\nclear_attribs = true;\r\n}\r\nraw_spin_unlock_irq(&vga_lock);\r\nif (clear_attribs) {\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nstruct vc_data *c = vc_cons[i].d;\r\nif (c && c->vc_sw == &vga_con) {\r\nc->vc_hi_font_mask = 0x00;\r\nclear_buffer_attributes(c);\r\nc->vc_hi_font_mask = ch512 ? 0x0800 : 0;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vgacon_adjust_height(struct vc_data *vc, unsigned fontheight)\r\n{\r\nunsigned char ovr, vde, fsr;\r\nint rows, maxscan, i;\r\nrows = vc->vc_scan_lines / fontheight;\r\nmaxscan = rows * fontheight - 1;\r\nraw_spin_lock_irq(&vga_lock);\r\noutb_p(0x07, vga_video_port_reg);\r\novr = inb_p(vga_video_port_val);\r\noutb_p(0x09, vga_video_port_reg);\r\nfsr = inb_p(vga_video_port_val);\r\nraw_spin_unlock_irq(&vga_lock);\r\nvde = maxscan & 0xff;\r\novr = (ovr & 0xbd) +\r\n((maxscan & 0x100) >> 7) + ((maxscan & 0x200) >> 3);\r\nfsr = (fsr & 0xe0) + (fontheight - 1);\r\nraw_spin_lock_irq(&vga_lock);\r\noutb_p(0x07, vga_video_port_reg);\r\noutb_p(ovr, vga_video_port_val);\r\noutb_p(0x09, vga_video_port_reg);\r\noutb_p(fsr, vga_video_port_val);\r\noutb_p(0x12, vga_video_port_reg);\r\noutb_p(vde, vga_video_port_val);\r\nraw_spin_unlock_irq(&vga_lock);\r\nvga_video_font_height = fontheight;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nstruct vc_data *c = vc_cons[i].d;\r\nif (c && c->vc_sw == &vga_con) {\r\nif (con_is_visible(c)) {\r\ncursor_size_lastfrom = 0;\r\ncursor_size_lastto = 0;\r\nc->vc_sw->con_cursor(c, CM_DRAW);\r\n}\r\nc->vc_font.height = fontheight;\r\nvc_resize(c, 0, rows);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vgacon_font_set(struct vc_data *c, struct console_font *font, unsigned flags)\r\n{\r\nunsigned charcount = font->charcount;\r\nint rc;\r\nif (vga_video_type < VIDEO_TYPE_EGAM)\r\nreturn -EINVAL;\r\nif (font->width != VGA_FONTWIDTH ||\r\n(charcount != 256 && charcount != 512))\r\nreturn -EINVAL;\r\nrc = vgacon_do_font_op(&vgastate, font->data, 1, charcount == 512);\r\nif (rc)\r\nreturn rc;\r\nif (!(flags & KD_FONT_FLAG_DONT_RECALC))\r\nrc = vgacon_adjust_height(c, font->height);\r\nreturn rc;\r\n}\r\nstatic int vgacon_font_get(struct vc_data *c, struct console_font *font)\r\n{\r\nif (vga_video_type < VIDEO_TYPE_EGAM)\r\nreturn -EINVAL;\r\nfont->width = VGA_FONTWIDTH;\r\nfont->height = c->vc_font.height;\r\nfont->charcount = vga_512_chars ? 512 : 256;\r\nif (!font->data)\r\nreturn 0;\r\nreturn vgacon_do_font_op(&vgastate, font->data, 0, vga_512_chars);\r\n}\r\nstatic int vgacon_resize(struct vc_data *c, unsigned int width,\r\nunsigned int height, unsigned int user)\r\n{\r\nif (width % 2 || width > screen_info.orig_video_cols ||\r\nheight > (screen_info.orig_video_lines * vga_default_font_height)/\r\nc->vc_font.height)\r\nreturn (user) ? 0 : -EINVAL;\r\nif (con_is_visible(c) && !vga_is_gfx)\r\nvgacon_doresize(c, width, height);\r\nreturn 0;\r\n}\r\nstatic int vgacon_set_origin(struct vc_data *c)\r\n{\r\nif (vga_is_gfx ||\r\n(console_blanked && !vga_palette_blanked))\r\nreturn 0;\r\nc->vc_origin = c->vc_visible_origin = vga_vram_base;\r\nvga_set_mem_top(c);\r\nvga_rolled_over = 0;\r\nreturn 1;\r\n}\r\nstatic void vgacon_save_screen(struct vc_data *c)\r\n{\r\nstatic int vga_bootup_console = 0;\r\nif (!vga_bootup_console) {\r\nvga_bootup_console = 1;\r\nc->vc_x = screen_info.orig_x;\r\nc->vc_y = screen_info.orig_y;\r\n}\r\nif (!vga_is_gfx)\r\nscr_memcpyw((u16 *) c->vc_screenbuf, (u16 *) c->vc_origin,\r\nc->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);\r\n}\r\nstatic int vgacon_scroll(struct vc_data *c, int t, int b, int dir,\r\nint lines)\r\n{\r\nunsigned long oldo;\r\nunsigned int delta;\r\nif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\r\nreturn 0;\r\nif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\r\nreturn 0;\r\nvgacon_restore_screen(c);\r\noldo = c->vc_origin;\r\ndelta = lines * c->vc_size_row;\r\nif (dir == SM_UP) {\r\nvgacon_scrollback_update(c, t, lines);\r\nif (c->vc_scr_end + delta >= vga_vram_end) {\r\nscr_memcpyw((u16 *) vga_vram_base,\r\n(u16 *) (oldo + delta),\r\nc->vc_screenbuf_size - delta);\r\nc->vc_origin = vga_vram_base;\r\nvga_rolled_over = oldo - vga_vram_base;\r\n} else\r\nc->vc_origin += delta;\r\nscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\r\ndelta), c->vc_video_erase_char,\r\ndelta);\r\n} else {\r\nif (oldo - delta < vga_vram_base) {\r\nscr_memmovew((u16 *) (vga_vram_end -\r\nc->vc_screenbuf_size +\r\ndelta), (u16 *) oldo,\r\nc->vc_screenbuf_size - delta);\r\nc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\r\nvga_rolled_over = 0;\r\n} else\r\nc->vc_origin -= delta;\r\nc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\r\nscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\r\ndelta);\r\n}\r\nc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\r\nc->vc_visible_origin = c->vc_origin;\r\nvga_set_mem_top(c);\r\nc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\r\nreturn 1;\r\n}\r\nstatic int vgacon_dummy(struct vc_data *c)\r\n{\r\nreturn 0;\r\n}
