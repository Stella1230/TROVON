static inline u8 *dh_pack_data(void *dst, const void *src, size_t size)\r\n{\r\nmemcpy(dst, src, size);\r\nreturn dst + size;\r\n}\r\nstatic inline const u8 *dh_unpack_data(void *dst, const void *src, size_t size)\r\n{\r\nmemcpy(dst, src, size);\r\nreturn src + size;\r\n}\r\nstatic inline int dh_data_size(const struct dh *p)\r\n{\r\nreturn p->key_size + p->p_size + p->g_size;\r\n}\r\nint crypto_dh_key_len(const struct dh *p)\r\n{\r\nreturn DH_KPP_SECRET_MIN_SIZE + dh_data_size(p);\r\n}\r\nint crypto_dh_encode_key(char *buf, unsigned int len, const struct dh *params)\r\n{\r\nu8 *ptr = buf;\r\nstruct kpp_secret secret = {\r\n.type = CRYPTO_KPP_SECRET_TYPE_DH,\r\n.len = len\r\n};\r\nif (unlikely(!buf))\r\nreturn -EINVAL;\r\nif (len != crypto_dh_key_len(params))\r\nreturn -EINVAL;\r\nptr = dh_pack_data(ptr, &secret, sizeof(secret));\r\nptr = dh_pack_data(ptr, &params->key_size, sizeof(params->key_size));\r\nptr = dh_pack_data(ptr, &params->p_size, sizeof(params->p_size));\r\nptr = dh_pack_data(ptr, &params->g_size, sizeof(params->g_size));\r\nptr = dh_pack_data(ptr, params->key, params->key_size);\r\nptr = dh_pack_data(ptr, params->p, params->p_size);\r\ndh_pack_data(ptr, params->g, params->g_size);\r\nreturn 0;\r\n}\r\nint crypto_dh_decode_key(const char *buf, unsigned int len, struct dh *params)\r\n{\r\nconst u8 *ptr = buf;\r\nstruct kpp_secret secret;\r\nif (unlikely(!buf || len < DH_KPP_SECRET_MIN_SIZE))\r\nreturn -EINVAL;\r\nptr = dh_unpack_data(&secret, ptr, sizeof(secret));\r\nif (secret.type != CRYPTO_KPP_SECRET_TYPE_DH)\r\nreturn -EINVAL;\r\nptr = dh_unpack_data(&params->key_size, ptr, sizeof(params->key_size));\r\nptr = dh_unpack_data(&params->p_size, ptr, sizeof(params->p_size));\r\nptr = dh_unpack_data(&params->g_size, ptr, sizeof(params->g_size));\r\nif (secret.len != crypto_dh_key_len(params))\r\nreturn -EINVAL;\r\nparams->key = (void *)ptr;\r\nparams->p = (void *)(ptr + params->key_size);\r\nparams->g = (void *)(ptr + params->key_size + params->p_size);\r\nreturn 0;\r\n}
