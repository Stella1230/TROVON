static size_t\r\nintel_bts_info_priv_size(struct auxtrace_record *itr __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nreturn INTEL_BTS_AUXTRACE_PRIV_SIZE;\r\n}\r\nstatic int intel_bts_info_fill(struct auxtrace_record *itr,\r\nstruct perf_session *session,\r\nstruct auxtrace_info_event *auxtrace_info,\r\nsize_t priv_size)\r\n{\r\nstruct intel_bts_recording *btsr =\r\ncontainer_of(itr, struct intel_bts_recording, itr);\r\nstruct perf_pmu *intel_bts_pmu = btsr->intel_bts_pmu;\r\nstruct perf_event_mmap_page *pc;\r\nstruct perf_tsc_conversion tc = { .time_mult = 0, };\r\nbool cap_user_time_zero = false;\r\nint err;\r\nif (priv_size != INTEL_BTS_AUXTRACE_PRIV_SIZE)\r\nreturn -EINVAL;\r\nif (!session->evlist->nr_mmaps)\r\nreturn -EINVAL;\r\npc = session->evlist->mmap[0].base;\r\nif (pc) {\r\nerr = perf_read_tsc_conversion(pc, &tc);\r\nif (err) {\r\nif (err != -EOPNOTSUPP)\r\nreturn err;\r\n} else {\r\ncap_user_time_zero = tc.time_mult != 0;\r\n}\r\nif (!cap_user_time_zero)\r\nui__warning("Intel BTS: TSC not available\n");\r\n}\r\nauxtrace_info->type = PERF_AUXTRACE_INTEL_BTS;\r\nauxtrace_info->priv[INTEL_BTS_PMU_TYPE] = intel_bts_pmu->type;\r\nauxtrace_info->priv[INTEL_BTS_TIME_SHIFT] = tc.time_shift;\r\nauxtrace_info->priv[INTEL_BTS_TIME_MULT] = tc.time_mult;\r\nauxtrace_info->priv[INTEL_BTS_TIME_ZERO] = tc.time_zero;\r\nauxtrace_info->priv[INTEL_BTS_CAP_USER_TIME_ZERO] = cap_user_time_zero;\r\nauxtrace_info->priv[INTEL_BTS_SNAPSHOT_MODE] = btsr->snapshot_mode;\r\nreturn 0;\r\n}\r\nstatic int intel_bts_recording_options(struct auxtrace_record *itr,\r\nstruct perf_evlist *evlist,\r\nstruct record_opts *opts)\r\n{\r\nstruct intel_bts_recording *btsr =\r\ncontainer_of(itr, struct intel_bts_recording, itr);\r\nstruct perf_pmu *intel_bts_pmu = btsr->intel_bts_pmu;\r\nstruct perf_evsel *evsel, *intel_bts_evsel = NULL;\r\nconst struct cpu_map *cpus = evlist->cpus;\r\nbool privileged = geteuid() == 0 || perf_event_paranoid() < 0;\r\nbtsr->evlist = evlist;\r\nbtsr->snapshot_mode = opts->auxtrace_snapshot_mode;\r\nevlist__for_each_entry(evlist, evsel) {\r\nif (evsel->attr.type == intel_bts_pmu->type) {\r\nif (intel_bts_evsel) {\r\npr_err("There may be only one " INTEL_BTS_PMU_NAME " event\n");\r\nreturn -EINVAL;\r\n}\r\nevsel->attr.freq = 0;\r\nevsel->attr.sample_period = 1;\r\nintel_bts_evsel = evsel;\r\nopts->full_auxtrace = true;\r\n}\r\n}\r\nif (opts->auxtrace_snapshot_mode && !opts->full_auxtrace) {\r\npr_err("Snapshot mode (-S option) requires " INTEL_BTS_PMU_NAME " PMU event (-e " INTEL_BTS_PMU_NAME ")\n");\r\nreturn -EINVAL;\r\n}\r\nif (!opts->full_auxtrace)\r\nreturn 0;\r\nif (opts->full_auxtrace && !cpu_map__empty(cpus)) {\r\npr_err(INTEL_BTS_PMU_NAME " does not support per-cpu recording\n");\r\nreturn -EINVAL;\r\n}\r\nif (opts->auxtrace_snapshot_mode) {\r\nif (!opts->auxtrace_snapshot_size && !opts->auxtrace_mmap_pages) {\r\nif (privileged) {\r\nopts->auxtrace_mmap_pages = MiB(4) / page_size;\r\n} else {\r\nopts->auxtrace_mmap_pages = KiB(128) / page_size;\r\nif (opts->mmap_pages == UINT_MAX)\r\nopts->mmap_pages = KiB(256) / page_size;\r\n}\r\n} else if (!opts->auxtrace_mmap_pages && !privileged &&\r\nopts->mmap_pages == UINT_MAX) {\r\nopts->mmap_pages = KiB(256) / page_size;\r\n}\r\nif (!opts->auxtrace_snapshot_size)\r\nopts->auxtrace_snapshot_size =\r\nopts->auxtrace_mmap_pages * (size_t)page_size;\r\nif (!opts->auxtrace_mmap_pages) {\r\nsize_t sz = opts->auxtrace_snapshot_size;\r\nsz = round_up(sz, page_size) / page_size;\r\nopts->auxtrace_mmap_pages = roundup_pow_of_two(sz);\r\n}\r\nif (opts->auxtrace_snapshot_size >\r\nopts->auxtrace_mmap_pages * (size_t)page_size) {\r\npr_err("Snapshot size %zu must not be greater than AUX area tracing mmap size %zu\n",\r\nopts->auxtrace_snapshot_size,\r\nopts->auxtrace_mmap_pages * (size_t)page_size);\r\nreturn -EINVAL;\r\n}\r\nif (!opts->auxtrace_snapshot_size || !opts->auxtrace_mmap_pages) {\r\npr_err("Failed to calculate default snapshot size and/or AUX area tracing mmap pages\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug2("Intel BTS snapshot size: %zu\n",\r\nopts->auxtrace_snapshot_size);\r\n}\r\nif (opts->full_auxtrace && !opts->auxtrace_mmap_pages) {\r\nif (privileged) {\r\nopts->auxtrace_mmap_pages = MiB(4) / page_size;\r\n} else {\r\nopts->auxtrace_mmap_pages = KiB(128) / page_size;\r\nif (opts->mmap_pages == UINT_MAX)\r\nopts->mmap_pages = KiB(256) / page_size;\r\n}\r\n}\r\nif (opts->auxtrace_mmap_pages) {\r\nsize_t sz = opts->auxtrace_mmap_pages * (size_t)page_size;\r\nsize_t min_sz;\r\nif (opts->auxtrace_snapshot_mode)\r\nmin_sz = KiB(4);\r\nelse\r\nmin_sz = KiB(8);\r\nif (sz < min_sz || !is_power_of_2(sz)) {\r\npr_err("Invalid mmap size for Intel BTS: must be at least %zuKiB and a power of 2\n",\r\nmin_sz / 1024);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (intel_bts_evsel) {\r\nperf_evlist__to_front(evlist, intel_bts_evsel);\r\nif (!cpu_map__empty(cpus))\r\nperf_evsel__set_sample_bit(intel_bts_evsel, CPU);\r\n}\r\nif (opts->full_auxtrace) {\r\nstruct perf_evsel *tracking_evsel;\r\nint err;\r\nerr = parse_events(evlist, "dummy:u", NULL);\r\nif (err)\r\nreturn err;\r\ntracking_evsel = perf_evlist__last(evlist);\r\nperf_evlist__set_tracking_event(evlist, tracking_evsel);\r\ntracking_evsel->attr.freq = 0;\r\ntracking_evsel->attr.sample_period = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_bts_parse_snapshot_options(struct auxtrace_record *itr,\r\nstruct record_opts *opts,\r\nconst char *str)\r\n{\r\nstruct intel_bts_recording *btsr =\r\ncontainer_of(itr, struct intel_bts_recording, itr);\r\nunsigned long long snapshot_size = 0;\r\nchar *endptr;\r\nif (str) {\r\nsnapshot_size = strtoull(str, &endptr, 0);\r\nif (*endptr || snapshot_size > SIZE_MAX)\r\nreturn -1;\r\n}\r\nopts->auxtrace_snapshot_mode = true;\r\nopts->auxtrace_snapshot_size = snapshot_size;\r\nbtsr->snapshot_size = snapshot_size;\r\nreturn 0;\r\n}\r\nstatic u64 intel_bts_reference(struct auxtrace_record *itr __maybe_unused)\r\n{\r\nreturn rdtsc();\r\n}\r\nstatic int intel_bts_alloc_snapshot_refs(struct intel_bts_recording *btsr,\r\nint idx)\r\n{\r\nconst size_t sz = sizeof(struct intel_bts_snapshot_ref);\r\nint cnt = btsr->snapshot_ref_cnt, new_cnt = cnt * 2;\r\nstruct intel_bts_snapshot_ref *refs;\r\nif (!new_cnt)\r\nnew_cnt = 16;\r\nwhile (new_cnt <= idx)\r\nnew_cnt *= 2;\r\nrefs = calloc(new_cnt, sz);\r\nif (!refs)\r\nreturn -ENOMEM;\r\nmemcpy(refs, btsr->snapshot_refs, cnt * sz);\r\nbtsr->snapshot_refs = refs;\r\nbtsr->snapshot_ref_cnt = new_cnt;\r\nreturn 0;\r\n}\r\nstatic void intel_bts_free_snapshot_refs(struct intel_bts_recording *btsr)\r\n{\r\nint i;\r\nfor (i = 0; i < btsr->snapshot_ref_cnt; i++)\r\nzfree(&btsr->snapshot_refs[i].ref_buf);\r\nzfree(&btsr->snapshot_refs);\r\n}\r\nstatic void intel_bts_recording_free(struct auxtrace_record *itr)\r\n{\r\nstruct intel_bts_recording *btsr =\r\ncontainer_of(itr, struct intel_bts_recording, itr);\r\nintel_bts_free_snapshot_refs(btsr);\r\nfree(btsr);\r\n}\r\nstatic int intel_bts_snapshot_start(struct auxtrace_record *itr)\r\n{\r\nstruct intel_bts_recording *btsr =\r\ncontainer_of(itr, struct intel_bts_recording, itr);\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(btsr->evlist, evsel) {\r\nif (evsel->attr.type == btsr->intel_bts_pmu->type)\r\nreturn perf_evsel__disable(evsel);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int intel_bts_snapshot_finish(struct auxtrace_record *itr)\r\n{\r\nstruct intel_bts_recording *btsr =\r\ncontainer_of(itr, struct intel_bts_recording, itr);\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(btsr->evlist, evsel) {\r\nif (evsel->attr.type == btsr->intel_bts_pmu->type)\r\nreturn perf_evsel__enable(evsel);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic bool intel_bts_first_wrap(u64 *data, size_t buf_size)\r\n{\r\nint i, a, b;\r\nb = buf_size >> 3;\r\na = b - 512;\r\nif (a < 0)\r\na = 0;\r\nfor (i = a; i < b; i++) {\r\nif (data[i])\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int intel_bts_find_snapshot(struct auxtrace_record *itr, int idx,\r\nstruct auxtrace_mmap *mm, unsigned char *data,\r\nu64 *head, u64 *old)\r\n{\r\nstruct intel_bts_recording *btsr =\r\ncontainer_of(itr, struct intel_bts_recording, itr);\r\nbool wrapped;\r\nint err;\r\npr_debug3("%s: mmap index %d old head %zu new head %zu\n",\r\n__func__, idx, (size_t)*old, (size_t)*head);\r\nif (idx >= btsr->snapshot_ref_cnt) {\r\nerr = intel_bts_alloc_snapshot_refs(btsr, idx);\r\nif (err)\r\ngoto out_err;\r\n}\r\nwrapped = btsr->snapshot_refs[idx].wrapped;\r\nif (!wrapped && intel_bts_first_wrap((u64 *)data, mm->len)) {\r\nbtsr->snapshot_refs[idx].wrapped = true;\r\nwrapped = true;\r\n}\r\nif (wrapped) {\r\n*old = *head;\r\n*head += mm->len;\r\n} else {\r\nif (mm->mask)\r\n*old &= mm->mask;\r\nelse\r\n*old %= mm->len;\r\nif (*old > *head)\r\n*head += mm->len;\r\n}\r\npr_debug3("%s: wrap-around %sdetected, adjusted old head %zu adjusted new head %zu\n",\r\n__func__, wrapped ? "" : "not ", (size_t)*old, (size_t)*head);\r\nreturn 0;\r\nout_err:\r\npr_err("%s: failed, error %d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int intel_bts_read_finish(struct auxtrace_record *itr, int idx)\r\n{\r\nstruct intel_bts_recording *btsr =\r\ncontainer_of(itr, struct intel_bts_recording, itr);\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(btsr->evlist, evsel) {\r\nif (evsel->attr.type == btsr->intel_bts_pmu->type)\r\nreturn perf_evlist__enable_event_idx(btsr->evlist,\r\nevsel, idx);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstruct auxtrace_record *intel_bts_recording_init(int *err)\r\n{\r\nstruct perf_pmu *intel_bts_pmu = perf_pmu__find(INTEL_BTS_PMU_NAME);\r\nstruct intel_bts_recording *btsr;\r\nif (!intel_bts_pmu)\r\nreturn NULL;\r\nif (setenv("JITDUMP_USE_ARCH_TIMESTAMP", "1", 1)) {\r\n*err = -errno;\r\nreturn NULL;\r\n}\r\nbtsr = zalloc(sizeof(struct intel_bts_recording));\r\nif (!btsr) {\r\n*err = -ENOMEM;\r\nreturn NULL;\r\n}\r\nbtsr->intel_bts_pmu = intel_bts_pmu;\r\nbtsr->itr.recording_options = intel_bts_recording_options;\r\nbtsr->itr.info_priv_size = intel_bts_info_priv_size;\r\nbtsr->itr.info_fill = intel_bts_info_fill;\r\nbtsr->itr.free = intel_bts_recording_free;\r\nbtsr->itr.snapshot_start = intel_bts_snapshot_start;\r\nbtsr->itr.snapshot_finish = intel_bts_snapshot_finish;\r\nbtsr->itr.find_snapshot = intel_bts_find_snapshot;\r\nbtsr->itr.parse_snapshot_options = intel_bts_parse_snapshot_options;\r\nbtsr->itr.reference = intel_bts_reference;\r\nbtsr->itr.read_finish = intel_bts_read_finish;\r\nbtsr->itr.alignment = sizeof(struct branch);\r\nreturn &btsr->itr;\r\n}
