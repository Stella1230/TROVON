static unsigned long timer16_get_counter(struct timer16_priv *p)\r\n{\r\nunsigned short v1, v2, v3;\r\nunsigned char o1, o2;\r\no1 = ioread8(p->mapcommon + TISRC) & p->ovf;\r\ndo {\r\no2 = o1;\r\nv1 = ioread16be(p->mapbase + TCNT);\r\nv2 = ioread16be(p->mapbase + TCNT);\r\nv3 = ioread16be(p->mapbase + TCNT);\r\no1 = ioread8(p->mapcommon + TISRC) & p->ovf;\r\n} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)\r\n|| (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));\r\nif (likely(!o1))\r\nreturn v2;\r\nelse\r\nreturn v2 + 0x10000;\r\n}\r\nstatic irqreturn_t timer16_interrupt(int irq, void *dev_id)\r\n{\r\nstruct timer16_priv *p = (struct timer16_priv *)dev_id;\r\nbclr(p->ovf, p->mapcommon + TISRC);\r\np->total_cycles += 0x10000;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline struct timer16_priv *cs_to_priv(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct timer16_priv, cs);\r\n}\r\nstatic cycle_t timer16_clocksource_read(struct clocksource *cs)\r\n{\r\nstruct timer16_priv *p = cs_to_priv(cs);\r\nunsigned long raw, value;\r\nvalue = p->total_cycles;\r\nraw = timer16_get_counter(p);\r\nreturn value + raw;\r\n}\r\nstatic int timer16_enable(struct clocksource *cs)\r\n{\r\nstruct timer16_priv *p = cs_to_priv(cs);\r\nWARN_ON(p->cs_enabled);\r\np->total_cycles = 0;\r\niowrite16be(0x0000, p->mapbase + TCNT);\r\niowrite8(0x83, p->mapbase + TCR);\r\nbset(p->ovie, p->mapcommon + TISRC);\r\nbset(p->enb, p->mapcommon + TSTR);\r\np->cs_enabled = true;\r\nreturn 0;\r\n}\r\nstatic void timer16_disable(struct clocksource *cs)\r\n{\r\nstruct timer16_priv *p = cs_to_priv(cs);\r\nWARN_ON(!p->cs_enabled);\r\nbclr(p->ovie, p->mapcommon + TISRC);\r\nbclr(p->enb, p->mapcommon + TSTR);\r\np->cs_enabled = false;\r\n}\r\nstatic int __init h8300_16timer_init(struct device_node *node)\r\n{\r\nvoid __iomem *base[2];\r\nint ret, irq;\r\nunsigned int ch;\r\nstruct clk *clk;\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("failed to get clock for clocksource\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nret = -ENXIO;\r\nbase[REG_CH] = of_iomap(node, 0);\r\nif (!base[REG_CH]) {\r\npr_err("failed to map registers for clocksource\n");\r\ngoto free_clk;\r\n}\r\nbase[REG_COMM] = of_iomap(node, 1);\r\nif (!base[REG_COMM]) {\r\npr_err("failed to map registers for clocksource\n");\r\ngoto unmap_ch;\r\n}\r\nret = -EINVAL;\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (!irq) {\r\npr_err("failed to get irq for clockevent\n");\r\ngoto unmap_comm;\r\n}\r\nof_property_read_u32(node, "renesas,channel", &ch);\r\ntimer16_priv.mapbase = base[REG_CH];\r\ntimer16_priv.mapcommon = base[REG_COMM];\r\ntimer16_priv.enb = ch;\r\ntimer16_priv.ovf = ch;\r\ntimer16_priv.ovie = 4 + ch;\r\nret = request_irq(irq, timer16_interrupt,\r\nIRQF_TIMER, timer16_priv.cs.name, &timer16_priv);\r\nif (ret < 0) {\r\npr_err("failed to request irq %d of clocksource\n", irq);\r\ngoto unmap_comm;\r\n}\r\nclocksource_register_hz(&timer16_priv.cs,\r\nclk_get_rate(clk) / 8);\r\nreturn 0;\r\nunmap_comm:\r\niounmap(base[REG_COMM]);\r\nunmap_ch:\r\niounmap(base[REG_CH]);\r\nfree_clk:\r\nclk_put(clk);\r\nreturn ret;\r\n}
