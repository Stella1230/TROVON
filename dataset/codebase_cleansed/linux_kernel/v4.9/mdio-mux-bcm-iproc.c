static int iproc_mdio_wait_for_idle(void __iomem *base, bool result)\r\n{\r\nunsigned int timeout = 1000;\r\nu32 val;\r\ndo {\r\nval = readl(base + MDIO_STAT_OFFSET);\r\nif ((val & MDIO_STAT_DONE) == result)\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n} while (timeout--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int start_miim_ops(void __iomem *base,\r\nu16 phyid, u32 reg, u16 val, u32 op)\r\n{\r\nu32 param;\r\nint ret;\r\nwritel(0, base + MDIO_CTRL_OFFSET);\r\nret = iproc_mdio_wait_for_idle(base, 0);\r\nif (ret)\r\ngoto err;\r\nparam = readl(base + MDIO_PARAM_OFFSET);\r\nparam |= phyid << MDIO_PARAM_PHY_ID;\r\nparam |= val << MDIO_PARAM_PHY_DATA;\r\nif (reg & MII_ADDR_C45)\r\nparam |= BIT(MDIO_PARAM_C45_SEL);\r\nwritel(param, base + MDIO_PARAM_OFFSET);\r\nwritel(reg, base + MDIO_ADDR_OFFSET);\r\nwritel(op, base + MDIO_CTRL_OFFSET);\r\nret = iproc_mdio_wait_for_idle(base, 1);\r\nif (ret)\r\ngoto err;\r\nif (op == MDIO_CTRL_READ_OP)\r\nret = readl(base + MDIO_READ_OFFSET) & MDIO_READ_DATA_MASK;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int iproc_mdiomux_read(struct mii_bus *bus, int phyid, int reg)\r\n{\r\nstruct iproc_mdiomux_desc *md = bus->priv;\r\nint ret;\r\nret = start_miim_ops(md->base, phyid, reg, 0, MDIO_CTRL_READ_OP);\r\nif (ret < 0)\r\ndev_err(&bus->dev, "mdiomux read operation failed!!!");\r\nreturn ret;\r\n}\r\nstatic int iproc_mdiomux_write(struct mii_bus *bus,\r\nint phyid, int reg, u16 val)\r\n{\r\nstruct iproc_mdiomux_desc *md = bus->priv;\r\nint ret;\r\nret = start_miim_ops(md->base, phyid, reg, val, MDIO_CTRL_WRITE_OP);\r\nif (ret < 0)\r\ndev_err(&bus->dev, "mdiomux write operation failed!!!");\r\nreturn ret;\r\n}\r\nstatic int mdio_mux_iproc_switch_fn(int current_child, int desired_child,\r\nvoid *data)\r\n{\r\nstruct iproc_mdiomux_desc *md = data;\r\nu32 param, bus_id;\r\nbool bus_dir;\r\nbus_dir = (desired_child < EXT_BUS_START_ADDR);\r\nbus_id = bus_dir ? desired_child : (desired_child - EXT_BUS_START_ADDR);\r\nparam = (bus_dir ? 1 : 0) << MDIO_PARAM_INTERNAL_SEL;\r\nparam |= (bus_id << MDIO_PARAM_BUS_ID);\r\nwritel(param, md->base + MDIO_PARAM_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int mdio_mux_iproc_probe(struct platform_device *pdev)\r\n{\r\nstruct iproc_mdiomux_desc *md;\r\nstruct mii_bus *bus;\r\nstruct resource *res;\r\nint rc;\r\nmd = devm_kzalloc(&pdev->dev, sizeof(*md), GFP_KERNEL);\r\nif (!md)\r\nreturn -ENOMEM;\r\nmd->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmd->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(md->base)) {\r\ndev_err(&pdev->dev, "failed to ioremap register\n");\r\nreturn PTR_ERR(md->base);\r\n}\r\nmd->mii_bus = mdiobus_alloc();\r\nif (!md->mii_bus) {\r\ndev_err(&pdev->dev, "mdiomux bus alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nbus = md->mii_bus;\r\nbus->priv = md;\r\nbus->name = "iProc MDIO mux bus";\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%s-%d", pdev->name, pdev->id);\r\nbus->parent = &pdev->dev;\r\nbus->read = iproc_mdiomux_read;\r\nbus->write = iproc_mdiomux_write;\r\nbus->phy_mask = ~0;\r\nbus->dev.of_node = pdev->dev.of_node;\r\nrc = mdiobus_register(bus);\r\nif (rc) {\r\ndev_err(&pdev->dev, "mdiomux registration failed\n");\r\ngoto out;\r\n}\r\nplatform_set_drvdata(pdev, md);\r\nrc = mdio_mux_init(md->dev, mdio_mux_iproc_switch_fn,\r\n&md->mux_handle, md, md->mii_bus);\r\nif (rc) {\r\ndev_info(md->dev, "mdiomux initialization failed\n");\r\ngoto out;\r\n}\r\ndev_info(md->dev, "iProc mdiomux registered\n");\r\nreturn 0;\r\nout:\r\nmdiobus_free(bus);\r\nreturn rc;\r\n}\r\nstatic int mdio_mux_iproc_remove(struct platform_device *pdev)\r\n{\r\nstruct iproc_mdiomux_desc *md = dev_get_platdata(&pdev->dev);\r\nmdio_mux_uninit(md->mux_handle);\r\nmdiobus_unregister(md->mii_bus);\r\nmdiobus_free(md->mii_bus);\r\nreturn 0;\r\n}
