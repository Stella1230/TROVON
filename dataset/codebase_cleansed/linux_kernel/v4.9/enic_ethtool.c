static void enic_intr_coal_set_rx(struct enic *enic, u32 timer)\r\n{\r\nint i;\r\nint intr;\r\nfor (i = 0; i < enic->rq_count; i++) {\r\nintr = enic_msix_rq_intr(enic, i);\r\nvnic_intr_coalescing_timer_set(&enic->intr[intr], timer);\r\n}\r\n}\r\nstatic int enic_get_ksettings(struct net_device *netdev,\r\nstruct ethtool_link_ksettings *ecmd)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nstruct ethtool_link_settings *base = &ecmd->base;\r\nethtool_link_ksettings_add_link_mode(ecmd, supported,\r\n10000baseT_Full);\r\nethtool_link_ksettings_add_link_mode(ecmd, supported, FIBRE);\r\nethtool_link_ksettings_add_link_mode(ecmd, advertising,\r\n10000baseT_Full);\r\nethtool_link_ksettings_add_link_mode(ecmd, advertising, FIBRE);\r\nbase->port = PORT_FIBRE;\r\nif (netif_carrier_ok(netdev)) {\r\nbase->speed = vnic_dev_port_speed(enic->vdev);\r\nbase->duplex = DUPLEX_FULL;\r\n} else {\r\nbase->speed = SPEED_UNKNOWN;\r\nbase->duplex = DUPLEX_UNKNOWN;\r\n}\r\nbase->autoneg = AUTONEG_DISABLE;\r\nreturn 0;\r\n}\r\nstatic void enic_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nstruct vnic_devcmd_fw_info *fw_info;\r\nint err;\r\nerr = enic_dev_fw_info(enic, &fw_info);\r\nif (err == -ENOMEM)\r\nreturn;\r\nstrlcpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));\r\nstrlcpy(drvinfo->fw_version, fw_info->fw_version,\r\nsizeof(drvinfo->fw_version));\r\nstrlcpy(drvinfo->bus_info, pci_name(enic->pdev),\r\nsizeof(drvinfo->bus_info));\r\n}\r\nstatic void enic_get_strings(struct net_device *netdev, u32 stringset,\r\nu8 *data)\r\n{\r\nunsigned int i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < enic_n_tx_stats; i++) {\r\nmemcpy(data, enic_tx_stats[i].name, ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < enic_n_rx_stats; i++) {\r\nmemcpy(data, enic_rx_stats[i].name, ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < enic_n_gen_stats; i++) {\r\nmemcpy(data, enic_gen_stats[i].name, ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int enic_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn enic_n_tx_stats + enic_n_rx_stats + enic_n_gen_stats;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void enic_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nstruct vnic_stats *vstats;\r\nunsigned int i;\r\nint err;\r\nerr = enic_dev_stats_dump(enic, &vstats);\r\nif (err == -ENOMEM)\r\nreturn;\r\nfor (i = 0; i < enic_n_tx_stats; i++)\r\n*(data++) = ((u64 *)&vstats->tx)[enic_tx_stats[i].index];\r\nfor (i = 0; i < enic_n_rx_stats; i++)\r\n*(data++) = ((u64 *)&vstats->rx)[enic_rx_stats[i].index];\r\nfor (i = 0; i < enic_n_gen_stats; i++)\r\n*(data++) = ((u64 *)&enic->gen_stats)[enic_gen_stats[i].index];\r\n}\r\nstatic u32 enic_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nreturn enic->msg_enable;\r\n}\r\nstatic void enic_set_msglevel(struct net_device *netdev, u32 value)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nenic->msg_enable = value;\r\n}\r\nstatic int enic_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ecmd)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nstruct enic_rx_coal *rxcoal = &enic->rx_coalesce_setting;\r\nif (vnic_dev_get_intr_mode(enic->vdev) == VNIC_DEV_INTR_MODE_MSIX)\r\necmd->tx_coalesce_usecs = enic->tx_coalesce_usecs;\r\necmd->rx_coalesce_usecs = enic->rx_coalesce_usecs;\r\nif (rxcoal->use_adaptive_rx_coalesce)\r\necmd->use_adaptive_rx_coalesce = 1;\r\necmd->rx_coalesce_usecs_low = rxcoal->small_pkt_range_start;\r\necmd->rx_coalesce_usecs_high = rxcoal->range_end;\r\nreturn 0;\r\n}\r\nstatic int enic_coalesce_valid(struct enic *enic,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nu32 coalesce_usecs_max = vnic_dev_get_intr_coal_timer_max(enic->vdev);\r\nu32 rx_coalesce_usecs_high = min_t(u32, coalesce_usecs_max,\r\nec->rx_coalesce_usecs_high);\r\nu32 rx_coalesce_usecs_low = min_t(u32, coalesce_usecs_max,\r\nec->rx_coalesce_usecs_low);\r\nif (ec->rx_max_coalesced_frames ||\r\nec->rx_coalesce_usecs_irq ||\r\nec->rx_max_coalesced_frames_irq ||\r\nec->tx_max_coalesced_frames ||\r\nec->tx_coalesce_usecs_irq ||\r\nec->tx_max_coalesced_frames_irq ||\r\nec->stats_block_coalesce_usecs ||\r\nec->use_adaptive_tx_coalesce ||\r\nec->pkt_rate_low ||\r\nec->rx_max_coalesced_frames_low ||\r\nec->tx_coalesce_usecs_low ||\r\nec->tx_max_coalesced_frames_low ||\r\nec->pkt_rate_high ||\r\nec->rx_max_coalesced_frames_high ||\r\nec->tx_coalesce_usecs_high ||\r\nec->tx_max_coalesced_frames_high ||\r\nec->rate_sample_interval)\r\nreturn -EINVAL;\r\nif ((vnic_dev_get_intr_mode(enic->vdev) != VNIC_DEV_INTR_MODE_MSIX) &&\r\nec->tx_coalesce_usecs)\r\nreturn -EINVAL;\r\nif ((ec->tx_coalesce_usecs > coalesce_usecs_max) ||\r\n(ec->rx_coalesce_usecs > coalesce_usecs_max) ||\r\n(ec->rx_coalesce_usecs_low > coalesce_usecs_max) ||\r\n(ec->rx_coalesce_usecs_high > coalesce_usecs_max))\r\nnetdev_info(enic->netdev, "ethtool_set_coalesce: adaptor supports max coalesce value of %d. Setting max value.\n",\r\ncoalesce_usecs_max);\r\nif (ec->rx_coalesce_usecs_high &&\r\n(rx_coalesce_usecs_high <\r\nrx_coalesce_usecs_low + ENIC_AIC_LARGE_PKT_DIFF))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int enic_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ecmd)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nu32 tx_coalesce_usecs;\r\nu32 rx_coalesce_usecs;\r\nu32 rx_coalesce_usecs_low;\r\nu32 rx_coalesce_usecs_high;\r\nu32 coalesce_usecs_max;\r\nunsigned int i, intr;\r\nint ret;\r\nstruct enic_rx_coal *rxcoal = &enic->rx_coalesce_setting;\r\nret = enic_coalesce_valid(enic, ecmd);\r\nif (ret)\r\nreturn ret;\r\ncoalesce_usecs_max = vnic_dev_get_intr_coal_timer_max(enic->vdev);\r\ntx_coalesce_usecs = min_t(u32, ecmd->tx_coalesce_usecs,\r\ncoalesce_usecs_max);\r\nrx_coalesce_usecs = min_t(u32, ecmd->rx_coalesce_usecs,\r\ncoalesce_usecs_max);\r\nrx_coalesce_usecs_low = min_t(u32, ecmd->rx_coalesce_usecs_low,\r\ncoalesce_usecs_max);\r\nrx_coalesce_usecs_high = min_t(u32, ecmd->rx_coalesce_usecs_high,\r\ncoalesce_usecs_max);\r\nif (vnic_dev_get_intr_mode(enic->vdev) == VNIC_DEV_INTR_MODE_MSIX) {\r\nfor (i = 0; i < enic->wq_count; i++) {\r\nintr = enic_msix_wq_intr(enic, i);\r\nvnic_intr_coalescing_timer_set(&enic->intr[intr],\r\ntx_coalesce_usecs);\r\n}\r\nenic->tx_coalesce_usecs = tx_coalesce_usecs;\r\n}\r\nrxcoal->use_adaptive_rx_coalesce = !!ecmd->use_adaptive_rx_coalesce;\r\nif (!rxcoal->use_adaptive_rx_coalesce)\r\nenic_intr_coal_set_rx(enic, rx_coalesce_usecs);\r\nif (ecmd->rx_coalesce_usecs_high) {\r\nrxcoal->range_end = rx_coalesce_usecs_high;\r\nrxcoal->small_pkt_range_start = rx_coalesce_usecs_low;\r\nrxcoal->large_pkt_range_start = rx_coalesce_usecs_low +\r\nENIC_AIC_LARGE_PKT_DIFF;\r\n}\r\nenic->rx_coalesce_usecs = rx_coalesce_usecs;\r\nreturn 0;\r\n}\r\nstatic int enic_grxclsrlall(struct enic *enic, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nint j, ret = 0, cnt = 0;\r\ncmd->data = enic->rfs_h.max - enic->rfs_h.free;\r\nfor (j = 0; j < (1 << ENIC_RFS_FLW_BITSHIFT); j++) {\r\nstruct hlist_head *hhead;\r\nstruct hlist_node *tmp;\r\nstruct enic_rfs_fltr_node *n;\r\nhhead = &enic->rfs_h.ht_head[j];\r\nhlist_for_each_entry_safe(n, tmp, hhead, node) {\r\nif (cnt == cmd->rule_cnt)\r\nreturn -EMSGSIZE;\r\nrule_locs[cnt] = n->fltr_id;\r\ncnt++;\r\n}\r\n}\r\ncmd->rule_cnt = cnt;\r\nreturn ret;\r\n}\r\nstatic int enic_grxclsrule(struct enic *enic, struct ethtool_rxnfc *cmd)\r\n{\r\nstruct ethtool_rx_flow_spec *fsp =\r\n(struct ethtool_rx_flow_spec *)&cmd->fs;\r\nstruct enic_rfs_fltr_node *n;\r\nn = htbl_fltr_search(enic, (u16)fsp->location);\r\nif (!n)\r\nreturn -EINVAL;\r\nswitch (n->keys.basic.ip_proto) {\r\ncase IPPROTO_TCP:\r\nfsp->flow_type = TCP_V4_FLOW;\r\nbreak;\r\ncase IPPROTO_UDP:\r\nfsp->flow_type = UDP_V4_FLOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nfsp->h_u.tcp_ip4_spec.ip4src = flow_get_u32_src(&n->keys);\r\nfsp->m_u.tcp_ip4_spec.ip4src = (__u32)~0;\r\nfsp->h_u.tcp_ip4_spec.ip4dst = flow_get_u32_dst(&n->keys);\r\nfsp->m_u.tcp_ip4_spec.ip4dst = (__u32)~0;\r\nfsp->h_u.tcp_ip4_spec.psrc = n->keys.ports.src;\r\nfsp->m_u.tcp_ip4_spec.psrc = (__u16)~0;\r\nfsp->h_u.tcp_ip4_spec.pdst = n->keys.ports.dst;\r\nfsp->m_u.tcp_ip4_spec.pdst = (__u16)~0;\r\nfsp->ring_cookie = n->rq_id;\r\nreturn 0;\r\n}\r\nstatic int enic_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct enic *enic = netdev_priv(dev);\r\nint ret = 0;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = enic->rq_count;\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLCNT:\r\nspin_lock_bh(&enic->rfs_h.lock);\r\ncmd->rule_cnt = enic->rfs_h.max - enic->rfs_h.free;\r\ncmd->data = enic->rfs_h.max;\r\nspin_unlock_bh(&enic->rfs_h.lock);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLALL:\r\nspin_lock_bh(&enic->rfs_h.lock);\r\nret = enic_grxclsrlall(enic, cmd, rule_locs);\r\nspin_unlock_bh(&enic->rfs_h.lock);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRULE:\r\nspin_lock_bh(&enic->rfs_h.lock);\r\nret = enic_grxclsrule(enic, cmd);\r\nspin_unlock_bh(&enic->rfs_h.lock);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int enic_get_tunable(struct net_device *dev,\r\nconst struct ethtool_tunable *tuna, void *data)\r\n{\r\nstruct enic *enic = netdev_priv(dev);\r\nint ret = 0;\r\nswitch (tuna->id) {\r\ncase ETHTOOL_RX_COPYBREAK:\r\n*(u32 *)data = enic->rx_copybreak;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int enic_set_tunable(struct net_device *dev,\r\nconst struct ethtool_tunable *tuna,\r\nconst void *data)\r\n{\r\nstruct enic *enic = netdev_priv(dev);\r\nint ret = 0;\r\nswitch (tuna->id) {\r\ncase ETHTOOL_RX_COPYBREAK:\r\nenic->rx_copybreak = *(u32 *)data;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 enic_get_rxfh_key_size(struct net_device *netdev)\r\n{\r\nreturn ENIC_RSS_LEN;\r\n}\r\nstatic int enic_get_rxfh(struct net_device *netdev, u32 *indir, u8 *hkey,\r\nu8 *hfunc)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nif (hkey)\r\nmemcpy(hkey, enic->rss_key, ENIC_RSS_LEN);\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nreturn 0;\r\n}\r\nstatic int enic_set_rxfh(struct net_device *netdev, const u32 *indir,\r\nconst u8 *hkey, const u8 hfunc)\r\n{\r\nstruct enic *enic = netdev_priv(netdev);\r\nif ((hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP) ||\r\nindir)\r\nreturn -EINVAL;\r\nif (hkey)\r\nmemcpy(enic->rss_key, hkey, ENIC_RSS_LEN);\r\nreturn __enic_set_rsskey(enic);\r\n}\r\nvoid enic_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &enic_ethtool_ops;\r\n}
