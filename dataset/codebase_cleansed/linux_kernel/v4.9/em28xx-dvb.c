static inline void print_err_status(struct em28xx *dev,\r\nint packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\ndprintk(1, "URB status %d [%s].\n", status, errmsg);\r\n} else {\r\ndprintk(1, "URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic inline int em28xx_dvb_urb_data_copy(struct em28xx *dev, struct urb *urb)\r\n{\r\nint xfer_bulk, num_packets, i;\r\nif (!dev)\r\nreturn 0;\r\nif (dev->disconnected)\r\nreturn 0;\r\nif (urb->status < 0)\r\nprint_err_status(dev, -1, urb->status);\r\nxfer_bulk = usb_pipebulk(urb->pipe);\r\nif (xfer_bulk)\r\nnum_packets = 1;\r\nelse\r\nnum_packets = urb->number_of_packets;\r\nfor (i = 0; i < num_packets; i++) {\r\nif (xfer_bulk) {\r\nif (urb->status < 0) {\r\nprint_err_status(dev, i, urb->status);\r\nif (urb->status != -EPROTO)\r\ncontinue;\r\n}\r\nif (!urb->actual_length)\r\ncontinue;\r\ndvb_dmx_swfilter(&dev->dvb->demux, urb->transfer_buffer,\r\nurb->actual_length);\r\n} else {\r\nif (urb->iso_frame_desc[i].status < 0) {\r\nprint_err_status(dev, i,\r\nurb->iso_frame_desc[i].status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\nif (!urb->iso_frame_desc[i].actual_length)\r\ncontinue;\r\ndvb_dmx_swfilter(&dev->dvb->demux,\r\nurb->transfer_buffer +\r\nurb->iso_frame_desc[i].offset,\r\nurb->iso_frame_desc[i].actual_length);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int em28xx_start_streaming(struct em28xx_dvb *dvb)\r\n{\r\nint rc;\r\nstruct em28xx_i2c_bus *i2c_bus = dvb->adapter.priv;\r\nstruct em28xx *dev = i2c_bus->dev;\r\nint dvb_max_packet_size, packet_multiplier, dvb_alt;\r\nif (dev->dvb_xfer_bulk) {\r\nif (!dev->dvb_ep_bulk)\r\nreturn -ENODEV;\r\ndvb_max_packet_size = 512;\r\npacket_multiplier = EM28XX_DVB_BULK_PACKET_MULTIPLIER;\r\ndvb_alt = 0;\r\n} else {\r\nif (!dev->dvb_ep_isoc)\r\nreturn -ENODEV;\r\ndvb_max_packet_size = dev->dvb_max_pkt_size_isoc;\r\nif (dvb_max_packet_size < 0)\r\nreturn dvb_max_packet_size;\r\npacket_multiplier = EM28XX_DVB_NUM_ISOC_PACKETS;\r\ndvb_alt = dev->dvb_alt_isoc;\r\n}\r\nusb_set_interface(dev->udev, dev->ifnum, dvb_alt);\r\nrc = em28xx_set_mode(dev, EM28XX_DIGITAL_MODE);\r\nif (rc < 0)\r\nreturn rc;\r\ndprintk(1, "Using %d buffers each with %d x %d bytes, alternate %d\n",\r\nEM28XX_DVB_NUM_BUFS,\r\npacket_multiplier,\r\ndvb_max_packet_size, dvb_alt);\r\nreturn em28xx_init_usb_xfer(dev, EM28XX_DIGITAL_MODE,\r\ndev->dvb_xfer_bulk,\r\nEM28XX_DVB_NUM_BUFS,\r\ndvb_max_packet_size,\r\npacket_multiplier,\r\nem28xx_dvb_urb_data_copy);\r\n}\r\nstatic int em28xx_stop_streaming(struct em28xx_dvb *dvb)\r\n{\r\nstruct em28xx_i2c_bus *i2c_bus = dvb->adapter.priv;\r\nstruct em28xx *dev = i2c_bus->dev;\r\nem28xx_stop_urbs(dev);\r\nreturn 0;\r\n}\r\nstatic int em28xx_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct em28xx_dvb *dvb = demux->priv;\r\nint rc, ret;\r\nif (!demux->dmx.frontend)\r\nreturn -EINVAL;\r\nmutex_lock(&dvb->lock);\r\ndvb->nfeeds++;\r\nrc = dvb->nfeeds;\r\nif (dvb->nfeeds == 1) {\r\nret = em28xx_start_streaming(dvb);\r\nif (ret < 0)\r\nrc = ret;\r\n}\r\nmutex_unlock(&dvb->lock);\r\nreturn rc;\r\n}\r\nstatic int em28xx_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct em28xx_dvb *dvb = demux->priv;\r\nint err = 0;\r\nmutex_lock(&dvb->lock);\r\ndvb->nfeeds--;\r\nif (0 == dvb->nfeeds)\r\nerr = em28xx_stop_streaming(dvb);\r\nmutex_unlock(&dvb->lock);\r\nreturn err;\r\n}\r\nstatic int em28xx_dvb_bus_ctrl(struct dvb_frontend *fe, int acquire)\r\n{\r\nstruct em28xx_i2c_bus *i2c_bus = fe->dvb->priv;\r\nstruct em28xx *dev = i2c_bus->dev;\r\nif (acquire)\r\nreturn em28xx_set_mode(dev, EM28XX_DIGITAL_MODE);\r\nelse\r\nreturn em28xx_set_mode(dev, EM28XX_SUSPEND);\r\n}\r\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct em28xx_dvb *dvb = fe->sec_priv;\r\nint status;\r\nif (!dvb)\r\nreturn -EINVAL;\r\nif (enable) {\r\ndown(&dvb->pll_mutex);\r\nstatus = dvb->gate_ctrl(fe, 1);\r\n} else {\r\nstatus = dvb->gate_ctrl(fe, 0);\r\nup(&dvb->pll_mutex);\r\n}\r\nreturn status;\r\n}\r\nstatic void hauppauge_hvr930c_init(struct em28xx *dev)\r\n{\r\nint i;\r\nstruct em28xx_reg_seq hauppauge_hvr930c_init[] = {\r\n{EM2874_R80_GPIO_P0_CTRL, 0xff, 0xff, 0x65},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xfb, 0xff, 0x32},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xff, 0xff, 0xb8},\r\n{ -1, -1, -1, -1},\r\n};\r\nstruct em28xx_reg_seq hauppauge_hvr930c_end[] = {\r\n{EM2874_R80_GPIO_P0_CTRL, 0xef, 0xff, 0x01},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xaf, 0xff, 0x65},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xef, 0xff, 0x76},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xef, 0xff, 0x01},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xcf, 0xff, 0x0b},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xef, 0xff, 0x40},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xcf, 0xff, 0x65},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xef, 0xff, 0x65},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xcf, 0xff, 0x0b},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xef, 0xff, 0x65},\r\n{ -1, -1, -1, -1},\r\n};\r\nstruct {\r\nunsigned char r[4];\r\nint len;\r\n} regs[] = {\r\n{{ 0x06, 0x02, 0x00, 0x31 }, 4},\r\n{{ 0x01, 0x02 }, 2},\r\n{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0xff, 0xaf }, 4},\r\n{{ 0x01, 0x00, 0x03, 0xa0 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0x73, 0xaf }, 4},\r\n{{ 0x04, 0x00 }, 2},\r\n{{ 0x00, 0x04 }, 2},\r\n{{ 0x00, 0x04, 0x00, 0x0a }, 4},\r\n{{ 0x04, 0x14 }, 2},\r\n{{ 0x04, 0x14, 0x00, 0x00 }, 4},\r\n};\r\nem28xx_gpio_set(dev, hauppauge_hvr930c_init);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x44);\r\nmsleep(10);\r\ndev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\r\nfor (i = 0; i < ARRAY_SIZE(regs); i++)\r\ni2c_master_send(&dev->i2c_client[dev->def_i2c_bus], regs[i].r, regs[i].len);\r\nem28xx_gpio_set(dev, hauppauge_hvr930c_end);\r\nmsleep(100);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x44);\r\nmsleep(30);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x45);\r\nmsleep(10);\r\n}\r\nstatic void terratec_h5_init(struct em28xx *dev)\r\n{\r\nint i;\r\nstruct em28xx_reg_seq terratec_h5_init[] = {\r\n{EM2820_R08_GPIO_CTRL, 0xff, 0xff, 10},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xf6, 0xff, 100},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xf2, 0xff, 50},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xf6, 0xff, 100},\r\n{ -1, -1, -1, -1},\r\n};\r\nstruct em28xx_reg_seq terratec_h5_end[] = {\r\n{EM2874_R80_GPIO_P0_CTRL, 0xe6, 0xff, 100},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xa6, 0xff, 50},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xe6, 0xff, 100},\r\n{ -1, -1, -1, -1},\r\n};\r\nstruct {\r\nunsigned char r[4];\r\nint len;\r\n} regs[] = {\r\n{{ 0x06, 0x02, 0x00, 0x31 }, 4},\r\n{{ 0x01, 0x02 }, 2},\r\n{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0xff, 0xaf }, 4},\r\n{{ 0x01, 0x00, 0x03, 0xa0 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0x73, 0xaf }, 4},\r\n{{ 0x04, 0x00 }, 2},\r\n{{ 0x00, 0x04 }, 2},\r\n{{ 0x00, 0x04, 0x00, 0x0a }, 4},\r\n{{ 0x04, 0x14 }, 2},\r\n{{ 0x04, 0x14, 0x00, 0x00 }, 4},\r\n};\r\nem28xx_gpio_set(dev, terratec_h5_init);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x45);\r\nmsleep(10);\r\ndev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\r\nfor (i = 0; i < ARRAY_SIZE(regs); i++)\r\ni2c_master_send(&dev->i2c_client[dev->def_i2c_bus], regs[i].r, regs[i].len);\r\nem28xx_gpio_set(dev, terratec_h5_end);\r\n}\r\nstatic void terratec_htc_stick_init(struct em28xx *dev)\r\n{\r\nint i;\r\nstruct em28xx_reg_seq terratec_htc_stick_init[] = {\r\n{EM2820_R08_GPIO_CTRL, 0xff, 0xff, 10},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xf6, 0xff, 100},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xe6, 0xff, 50},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xf6, 0xff, 100},\r\n{ -1, -1, -1, -1},\r\n};\r\nstruct em28xx_reg_seq terratec_htc_stick_end[] = {\r\n{EM2874_R80_GPIO_P0_CTRL, 0xb6, 0xff, 100},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xf6, 0xff, 50},\r\n{ -1, -1, -1, -1},\r\n};\r\nstruct {\r\nunsigned char r[4];\r\nint len;\r\n} regs[] = {\r\n{{ 0x06, 0x02, 0x00, 0x31 }, 4},\r\n{{ 0x01, 0x02 }, 2},\r\n{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0xff, 0xaf }, 4},\r\n};\r\nem28xx_gpio_set(dev, terratec_htc_stick_init);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x44);\r\nmsleep(10);\r\ndev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\r\nfor (i = 0; i < ARRAY_SIZE(regs); i++)\r\ni2c_master_send(&dev->i2c_client[dev->def_i2c_bus], regs[i].r, regs[i].len);\r\nem28xx_gpio_set(dev, terratec_htc_stick_end);\r\n}\r\nstatic void terratec_htc_usb_xs_init(struct em28xx *dev)\r\n{\r\nint i;\r\nstruct em28xx_reg_seq terratec_htc_usb_xs_init[] = {\r\n{EM2820_R08_GPIO_CTRL, 0xff, 0xff, 10},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xb2, 0xff, 100},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xb2, 0xff, 50},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xb6, 0xff, 100},\r\n{ -1, -1, -1, -1},\r\n};\r\nstruct em28xx_reg_seq terratec_htc_usb_xs_end[] = {\r\n{EM2874_R80_GPIO_P0_CTRL, 0xa6, 0xff, 100},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xa6, 0xff, 50},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xe6, 0xff, 100},\r\n{ -1, -1, -1, -1},\r\n};\r\nstruct {\r\nunsigned char r[4];\r\nint len;\r\n} regs[] = {\r\n{{ 0x06, 0x02, 0x00, 0x31 }, 4},\r\n{{ 0x01, 0x02 }, 2},\r\n{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0xff, 0xaf }, 4},\r\n{{ 0x01, 0x00, 0x03, 0xa0 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0x73, 0xaf }, 4},\r\n{{ 0x04, 0x00 }, 2},\r\n{{ 0x00, 0x04 }, 2},\r\n{{ 0x00, 0x04, 0x00, 0x0a }, 4},\r\n{{ 0x04, 0x14 }, 2},\r\n{{ 0x04, 0x14, 0x00, 0x00 }, 4},\r\n};\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\r\nem28xx_gpio_set(dev, terratec_htc_usb_xs_init);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x40);\r\nmsleep(10);\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x44);\r\nmsleep(10);\r\ndev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\r\nfor (i = 0; i < ARRAY_SIZE(regs); i++)\r\ni2c_master_send(&dev->i2c_client[dev->def_i2c_bus], regs[i].r, regs[i].len);\r\nem28xx_gpio_set(dev, terratec_htc_usb_xs_end);\r\n}\r\nstatic void pctv_520e_init(struct em28xx *dev)\r\n{\r\nint i;\r\nstruct {\r\nunsigned char r[4];\r\nint len;\r\n} regs[] = {\r\n{{ 0x06, 0x02, 0x00, 0x31 }, 4},\r\n{{ 0x01, 0x02 }, 2},\r\n{{ 0x01, 0x02, 0x00, 0xc6 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0xff, 0xaf }, 4},\r\n{{ 0x01, 0x00, 0x03, 0xa0 }, 4},\r\n{{ 0x01, 0x00 }, 2},\r\n{{ 0x01, 0x00, 0x73, 0xaf }, 4},\r\n};\r\ndev->i2c_client[dev->def_i2c_bus].addr = 0x82 >> 1;\r\nfor (i = 0; i < ARRAY_SIZE(regs); i++)\r\ni2c_master_send(&dev->i2c_client[dev->def_i2c_bus], regs[i].r, regs[i].len);\r\n}\r\nstatic int em28xx_pctv_290e_set_lna(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct em28xx_i2c_bus *i2c_bus = fe->dvb->priv;\r\nstruct em28xx *dev = i2c_bus->dev;\r\n#ifdef CONFIG_GPIOLIB\r\nstruct em28xx_dvb *dvb = dev->dvb;\r\nint ret;\r\nunsigned long flags;\r\nif (c->lna == 1)\r\nflags = GPIOF_OUT_INIT_HIGH;\r\nelse\r\nflags = GPIOF_OUT_INIT_LOW;\r\nret = gpio_request_one(dvb->lna_gpio, flags, NULL);\r\nif (ret)\r\nem28xx_errdev("gpio request failed %d\n", ret);\r\nelse\r\ngpio_free(dvb->lna_gpio);\r\nreturn ret;\r\n#else\r\ndev_warn(&dev->udev->dev, "%s: LNA control is disabled (lna=%u)\n",\r\nKBUILD_MODNAME, c->lna);\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int em28xx_pctv_292e_set_lna(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct em28xx_i2c_bus *i2c_bus = fe->dvb->priv;\r\nstruct em28xx *dev = i2c_bus->dev;\r\nu8 lna;\r\nif (c->lna == 1)\r\nlna = 0x01;\r\nelse\r\nlna = 0x00;\r\nreturn em28xx_write_reg_bits(dev, EM2874_R80_GPIO_P0_CTRL, lna, 0x01);\r\n}\r\nstatic int em28xx_mt352_terratec_xs_init(struct dvb_frontend *fe)\r\n{\r\nstatic u8 clock_config[] = { CLOCK_CTL, 0x38, 0x2c };\r\nstatic u8 reset[] = { RESET, 0x80 };\r\nstatic u8 adc_ctl_1_cfg[] = { ADC_CTL_1, 0x40 };\r\nstatic u8 agc_cfg[] = { AGC_TARGET, 0x28, 0xa0 };\r\nstatic u8 input_freq_cfg[] = { INPUT_FREQ_1, 0x31, 0xb8 };\r\nstatic u8 rs_err_cfg[] = { RS_ERR_PER_1, 0x00, 0x4d };\r\nstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\r\nstatic u8 trl_nom_cfg[] = { TRL_NOMINAL_RATE_1, 0x64, 0x00 };\r\nstatic u8 tps_given_cfg[] = { TPS_GIVEN_1, 0x40, 0x80, 0x50 };\r\nstatic u8 tuner_go[] = { TUNER_GO, 0x01};\r\nmt352_write(fe, clock_config, sizeof(clock_config));\r\nudelay(200);\r\nmt352_write(fe, reset, sizeof(reset));\r\nmt352_write(fe, adc_ctl_1_cfg, sizeof(adc_ctl_1_cfg));\r\nmt352_write(fe, agc_cfg, sizeof(agc_cfg));\r\nmt352_write(fe, input_freq_cfg, sizeof(input_freq_cfg));\r\nmt352_write(fe, rs_err_cfg, sizeof(rs_err_cfg));\r\nmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\r\nmt352_write(fe, trl_nom_cfg, sizeof(trl_nom_cfg));\r\nmt352_write(fe, tps_given_cfg, sizeof(tps_given_cfg));\r\nmt352_write(fe, tuner_go, sizeof(tuner_go));\r\nreturn 0;\r\n}\r\nstatic void px_bcud_init(struct em28xx *dev)\r\n{\r\nint i;\r\nstruct {\r\nunsigned char r[4];\r\nint len;\r\n} regs1[] = {\r\n{{ 0x0e, 0x77 }, 2},\r\n{{ 0x0f, 0x77 }, 2},\r\n{{ 0x03, 0x90 }, 2},\r\n}, regs2[] = {\r\n{{ 0x07, 0x01 }, 2},\r\n{{ 0x08, 0x10 }, 2},\r\n{{ 0x13, 0x00 }, 2},\r\n{{ 0x17, 0x00 }, 2},\r\n{{ 0x03, 0x01 }, 2},\r\n{{ 0x10, 0xb1 }, 2},\r\n{{ 0x11, 0x40 }, 2},\r\n{{ 0x85, 0x7a }, 2},\r\n{{ 0x87, 0x04 }, 2},\r\n};\r\nstatic struct em28xx_reg_seq gpio[] = {\r\n{EM28XX_R06_I2C_CLK, 0x40, 0xff, 300},\r\n{EM2874_R80_GPIO_P0_CTRL, 0xfd, 0xff, 60},\r\n{EM28XX_R15_RGAIN, 0x20, 0xff, 0},\r\n{EM28XX_R16_GGAIN, 0x20, 0xff, 0},\r\n{EM28XX_R17_BGAIN, 0x20, 0xff, 0},\r\n{EM28XX_R18_ROFFSET, 0x00, 0xff, 0},\r\n{EM28XX_R19_GOFFSET, 0x00, 0xff, 0},\r\n{EM28XX_R1A_BOFFSET, 0x00, 0xff, 0},\r\n{EM28XX_R23_UOFFSET, 0x00, 0xff, 0},\r\n{EM28XX_R24_VOFFSET, 0x00, 0xff, 0},\r\n{EM28XX_R26_COMPR, 0x00, 0xff, 0},\r\n{0x13, 0x08, 0xff, 0},\r\n{EM28XX_R12_VINENABLE, 0x27, 0xff, 0},\r\n{EM28XX_R0C_USBSUSP, 0x10, 0xff, 0},\r\n{EM28XX_R27_OUTFMT, 0x00, 0xff, 0},\r\n{EM28XX_R10_VINMODE, 0x00, 0xff, 0},\r\n{EM28XX_R11_VINCTRL, 0x11, 0xff, 0},\r\n{EM2874_R50_IR_CONFIG, 0x01, 0xff, 0},\r\n{EM2874_R5F_TS_ENABLE, 0x80, 0xff, 0},\r\n{EM28XX_R06_I2C_CLK, 0x46, 0xff, 0},\r\n};\r\nem28xx_write_reg(dev, EM28XX_R06_I2C_CLK, 0x46);\r\ndev->dvb->i2c_client_demod->addr = 0x14;\r\nfor (i = 0; i < ARRAY_SIZE(regs1); i++)\r\ni2c_master_send(dev->dvb->i2c_client_demod, regs1[i].r,\r\nregs1[i].len);\r\ndev->dvb->i2c_client_demod->addr = 0x15;\r\nfor (i = 0; i < ARRAY_SIZE(regs2); i++)\r\ni2c_master_send(dev->dvb->i2c_client_demod, regs2[i].r,\r\nregs2[i].len);\r\nfor (i = 0; i < ARRAY_SIZE(gpio); i++) {\r\nem28xx_write_reg_bits(dev, gpio[i].reg, gpio[i].val,\r\ngpio[i].mask);\r\nif (gpio[i].sleep > 0)\r\nmsleep(gpio[i].sleep);\r\n}\r\n}\r\nstatic int em28xx_attach_xc3028(u8 addr, struct em28xx *dev)\r\n{\r\nstruct dvb_frontend *fe;\r\nstruct xc2028_config cfg;\r\nstruct xc2028_ctrl ctl;\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.i2c_adap = &dev->i2c_adap[dev->def_i2c_bus];\r\ncfg.i2c_addr = addr;\r\nmemset(&ctl, 0, sizeof(ctl));\r\nem28xx_setup_xc3028(dev, &ctl);\r\ncfg.ctrl = &ctl;\r\nif (!dev->dvb->fe[0]) {\r\nem28xx_errdev("/2: dvb frontend not attached. "\r\n"Can't attach xc3028\n");\r\nreturn -EINVAL;\r\n}\r\nfe = dvb_attach(xc2028_attach, dev->dvb->fe[0], &cfg);\r\nif (!fe) {\r\nem28xx_errdev("/2: xc3028 attach failed\n");\r\ndvb_frontend_detach(dev->dvb->fe[0]);\r\ndev->dvb->fe[0] = NULL;\r\nreturn -EINVAL;\r\n}\r\nem28xx_info("%s/2: xc3028 attached\n", dev->name);\r\nreturn 0;\r\n}\r\nstatic int em28xx_register_dvb(struct em28xx_dvb *dvb, struct module *module,\r\nstruct em28xx *dev, struct device *device)\r\n{\r\nint result;\r\nbool create_rf_connector = false;\r\nmutex_init(&dvb->lock);\r\nresult = dvb_register_adapter(&dvb->adapter, dev->name, module, device,\r\nadapter_nr);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_register_adapter failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_adapter;\r\n}\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\ndvb->adapter.mdev = dev->media_dev;\r\n#endif\r\ndvb->fe[0]->ops.ts_bus_ctrl = em28xx_dvb_bus_ctrl;\r\nif (dvb->fe[1])\r\ndvb->fe[1]->ops.ts_bus_ctrl = em28xx_dvb_bus_ctrl;\r\ndvb->adapter.priv = &dev->i2c_bus[dev->def_i2c_bus];\r\nresult = dvb_register_frontend(&dvb->adapter, dvb->fe[0]);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_register_frontend failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_frontend0;\r\n}\r\nif (dvb->fe[1]) {\r\nresult = dvb_register_frontend(&dvb->adapter, dvb->fe[1]);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: 2nd dvb_register_frontend failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_frontend1;\r\n}\r\n}\r\ndvb->demux.dmx.capabilities =\r\nDMX_TS_FILTERING | DMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING;\r\ndvb->demux.priv = dvb;\r\ndvb->demux.filternum = 256;\r\ndvb->demux.feednum = 256;\r\ndvb->demux.start_feed = em28xx_start_feed;\r\ndvb->demux.stop_feed = em28xx_stop_feed;\r\nresult = dvb_dmx_init(&dvb->demux);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_dmx_init failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_dmx;\r\n}\r\ndvb->dmxdev.filternum = 256;\r\ndvb->dmxdev.demux = &dvb->demux.dmx;\r\ndvb->dmxdev.capabilities = 0;\r\nresult = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_dmxdev_init failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_dmxdev;\r\n}\r\ndvb->fe_hw.source = DMX_FRONTEND_0;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: add_frontend failed (DMX_FRONTEND_0, errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_fe_hw;\r\n}\r\ndvb->fe_mem.source = DMX_MEMORY_FE;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: add_frontend failed (DMX_MEMORY_FE, errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_fe_mem;\r\n}\r\nresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: connect_frontend failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_fe_conn;\r\n}\r\ndvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);\r\nif (!dev->has_video || (dev->tuner_type == TUNER_ABSENT))\r\ncreate_rf_connector = true;\r\nresult = dvb_create_media_graph(&dvb->adapter, create_rf_connector);\r\nif (result < 0)\r\ngoto fail_create_graph;\r\nreturn 0;\r\nfail_create_graph:\r\ndvb_net_release(&dvb->net);\r\nfail_fe_conn:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nfail_fe_mem:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nfail_fe_hw:\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\nfail_dmxdev:\r\ndvb_dmx_release(&dvb->demux);\r\nfail_dmx:\r\nif (dvb->fe[1])\r\ndvb_unregister_frontend(dvb->fe[1]);\r\ndvb_unregister_frontend(dvb->fe[0]);\r\nfail_frontend1:\r\nif (dvb->fe[1])\r\ndvb_frontend_detach(dvb->fe[1]);\r\nfail_frontend0:\r\ndvb_frontend_detach(dvb->fe[0]);\r\ndvb_unregister_adapter(&dvb->adapter);\r\nfail_adapter:\r\nreturn result;\r\n}\r\nstatic void em28xx_unregister_dvb(struct em28xx_dvb *dvb)\r\n{\r\ndvb_net_release(&dvb->net);\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\ndvb_dmx_release(&dvb->demux);\r\nif (dvb->fe[1])\r\ndvb_unregister_frontend(dvb->fe[1]);\r\ndvb_unregister_frontend(dvb->fe[0]);\r\nif (dvb->fe[1] && !dvb->dont_attach_fe1)\r\ndvb_frontend_detach(dvb->fe[1]);\r\ndvb_frontend_detach(dvb->fe[0]);\r\ndvb_unregister_adapter(&dvb->adapter);\r\n}\r\nstatic int em28xx_dvb_init(struct em28xx *dev)\r\n{\r\nint result = 0;\r\nstruct em28xx_dvb *dvb;\r\nif (dev->is_audio_only) {\r\nreturn 0;\r\n}\r\nif (!dev->board.has_dvb) {\r\nreturn 0;\r\n}\r\nem28xx_info("Binding DVB extension\n");\r\ndvb = kzalloc(sizeof(struct em28xx_dvb), GFP_KERNEL);\r\nif (dvb == NULL) {\r\nem28xx_info("em28xx_dvb: memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dvb = dvb;\r\ndvb->fe[0] = dvb->fe[1] = NULL;\r\nif (dev->dvb_xfer_bulk) {\r\nresult = em28xx_alloc_urbs(dev, EM28XX_DIGITAL_MODE,\r\ndev->dvb_xfer_bulk,\r\nEM28XX_DVB_NUM_BUFS,\r\n512,\r\nEM28XX_DVB_BULK_PACKET_MULTIPLIER);\r\n} else {\r\nresult = em28xx_alloc_urbs(dev, EM28XX_DIGITAL_MODE,\r\ndev->dvb_xfer_bulk,\r\nEM28XX_DVB_NUM_BUFS,\r\ndev->dvb_max_pkt_size_isoc,\r\nEM28XX_DVB_NUM_ISOC_PACKETS);\r\n}\r\nif (result) {\r\nem28xx_errdev("em28xx_dvb: failed to pre-allocate USB transfer buffers for DVB.\n");\r\nkfree(dvb);\r\ndev->dvb = NULL;\r\nreturn result;\r\n}\r\nmutex_lock(&dev->lock);\r\nem28xx_set_mode(dev, EM28XX_DIGITAL_MODE);\r\nswitch (dev->model) {\r\ncase EM2874_BOARD_LEADERSHIP_ISDBT:\r\ndvb->fe[0] = dvb_attach(s921_attach,\r\n&sharp_isdbt, &dev->i2c_adap[dev->def_i2c_bus]);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2883_BOARD_HAUPPAUGE_WINTV_HVR_850:\r\ncase EM2883_BOARD_HAUPPAUGE_WINTV_HVR_950:\r\ncase EM2880_BOARD_PINNACLE_PCTV_HD_PRO:\r\ncase EM2880_BOARD_AMD_ATI_TV_WONDER_HD_600:\r\ndvb->fe[0] = dvb_attach(lgdt330x_attach,\r\n&em2880_lgdt3303_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (em28xx_attach_xc3028(0x61, dev) < 0) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2880_BOARD_KWORLD_DVB_310U:\r\ndvb->fe[0] = dvb_attach(zl10353_attach,\r\n&em28xx_zl10353_with_xc3028,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (em28xx_attach_xc3028(0x61, dev) < 0) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2880_BOARD_HAUPPAUGE_WINTV_HVR_900:\r\ncase EM2882_BOARD_TERRATEC_HYBRID_XS:\r\ncase EM2880_BOARD_EMPIRE_DUAL_TV:\r\ndvb->fe[0] = dvb_attach(zl10353_attach,\r\n&em28xx_zl10353_xc3028_no_i2c_gate,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (em28xx_attach_xc3028(0x61, dev) < 0) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2880_BOARD_TERRATEC_HYBRID_XS:\r\ncase EM2880_BOARD_TERRATEC_HYBRID_XS_FR:\r\ncase EM2881_BOARD_PINNACLE_HYBRID_PRO:\r\ncase EM2882_BOARD_DIKOM_DK300:\r\ncase EM2882_BOARD_KWORLD_VS_DVBT:\r\ndvb->fe[0] = dvb_attach(zl10353_attach,\r\n&em28xx_zl10353_xc3028_no_i2c_gate,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (dvb->fe[0] == NULL) {\r\ndvb->fe[0] = dvb_attach(mt352_attach,\r\n&terratec_xs_mt352_cfg,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\n}\r\nif (em28xx_attach_xc3028(0x61, dev) < 0) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2870_BOARD_TERRATEC_XS_MT2060:\r\ndvb->fe[0] = dvb_attach(zl10353_attach,\r\n&em28xx_zl10353_no_i2c_gate_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (dvb->fe[0] != NULL) {\r\ndvb_attach(mt2060_attach, dvb->fe[0],\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&em28xx_mt2060_config, 1220);\r\n}\r\nbreak;\r\ncase EM2870_BOARD_KWORLD_355U:\r\ndvb->fe[0] = dvb_attach(zl10353_attach,\r\n&em28xx_zl10353_no_i2c_gate_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (dvb->fe[0] != NULL)\r\ndvb_attach(qt1010_attach, dvb->fe[0],\r\n&dev->i2c_adap[dev->def_i2c_bus], &em28xx_qt1010_config);\r\nbreak;\r\ncase EM2883_BOARD_KWORLD_HYBRID_330U:\r\ncase EM2882_BOARD_EVGA_INDTUBE:\r\ndvb->fe[0] = dvb_attach(s5h1409_attach,\r\n&em28xx_s5h1409_with_xc3028,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (em28xx_attach_xc3028(0x61, dev) < 0) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2882_BOARD_KWORLD_ATSC_315U:\r\ndvb->fe[0] = dvb_attach(lgdt330x_attach,\r\n&em2880_lgdt3303_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (dvb->fe[0] != NULL) {\r\nif (!dvb_attach(simple_tuner_attach, dvb->fe[0],\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n0x61, TUNER_THOMSON_DTT761X)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nbreak;\r\ncase EM2880_BOARD_HAUPPAUGE_WINTV_HVR_900_R2:\r\ncase EM2882_BOARD_PINNACLE_HYBRID_PRO_330E:\r\ndvb->fe[0] = dvb_attach(drxd_attach, &em28xx_drxd, NULL,\r\n&dev->i2c_adap[dev->def_i2c_bus], &dev->udev->dev);\r\nif (em28xx_attach_xc3028(0x61, dev) < 0) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2870_BOARD_REDDO_DVB_C_USB_BOX:\r\ndvb->fe[0] = dvb_attach(tda10023_attach,\r\n&em28xx_tda10023_config,\r\n&dev->i2c_adap[dev->def_i2c_bus], 0x48);\r\nif (dvb->fe[0]) {\r\nif (!dvb_attach(simple_tuner_attach, dvb->fe[0],\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n0x60, TUNER_PHILIPS_CU1216L)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nbreak;\r\ncase EM2870_BOARD_KWORLD_A340:\r\ndvb->fe[0] = dvb_attach(lgdt3305_attach,\r\n&em2870_lgdt3304_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&kworld_a340_config)) {\r\ndvb_frontend_detach(dvb->fe[0]);\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM28174_BOARD_PCTV_290E:\r\ndvb->lna_gpio = CXD2820R_GPIO_E | CXD2820R_GPIO_O |\r\nCXD2820R_GPIO_L;\r\ndvb->fe[0] = dvb_attach(cxd2820r_attach,\r\n&em28xx_cxd2820r_config,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&dvb->lna_gpio);\r\nif (dvb->fe[0]) {\r\nif (!dvb_attach(tda18271_attach,\r\ndvb->fe[0],\r\n0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&em28xx_cxd2820r_tda18271_config)) {\r\ndvb_frontend_detach(dvb->fe[0]);\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\n#ifdef CONFIG_GPIOLIB\r\nresult = gpio_request_one(dvb->lna_gpio,\r\nGPIOF_OUT_INIT_LOW, NULL);\r\nif (result)\r\nem28xx_errdev("gpio request failed %d\n",\r\nresult);\r\nelse\r\ngpio_free(dvb->lna_gpio);\r\nresult = 0;\r\n#endif\r\ndvb->fe[0]->ops.set_lna = em28xx_pctv_290e_set_lna;\r\n}\r\nbreak;\r\ncase EM2884_BOARD_HAUPPAUGE_WINTV_HVR_930C:\r\n{\r\nstruct xc5000_config cfg;\r\nhauppauge_hvr930c_init(dev);\r\ndvb->fe[0] = dvb_attach(drxk_attach,\r\n&hauppauge_930c_drxk, &dev->i2c_adap[dev->def_i2c_bus]);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->fe[0]->sec_priv = dvb;\r\nsema_init(&dvb->pll_mutex, 1);\r\ndvb->gate_ctrl = dvb->fe[0]->ops.i2c_gate_ctrl;\r\ndvb->fe[0]->ops.i2c_gate_ctrl = drxk_gate_ctrl;\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.i2c_address = 0x61;\r\ncfg.if_khz = 4000;\r\nif (dvb->fe[0]->ops.i2c_gate_ctrl)\r\ndvb->fe[0]->ops.i2c_gate_ctrl(dvb->fe[0], 1);\r\nif (!dvb_attach(xc5000_attach, dvb->fe[0], &dev->i2c_adap[dev->def_i2c_bus],\r\n&cfg)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (dvb->fe[0]->ops.i2c_gate_ctrl)\r\ndvb->fe[0]->ops.i2c_gate_ctrl(dvb->fe[0], 0);\r\nbreak;\r\n}\r\ncase EM2884_BOARD_TERRATEC_H5:\r\nterratec_h5_init(dev);\r\ndvb->fe[0] = dvb_attach(drxk_attach, &terratec_h5_drxk, &dev->i2c_adap[dev->def_i2c_bus]);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->fe[0]->sec_priv = dvb;\r\nsema_init(&dvb->pll_mutex, 1);\r\ndvb->gate_ctrl = dvb->fe[0]->ops.i2c_gate_ctrl;\r\ndvb->fe[0]->ops.i2c_gate_ctrl = drxk_gate_ctrl;\r\nif (dvb->fe[0]->ops.i2c_gate_ctrl)\r\ndvb->fe[0]->ops.i2c_gate_ctrl(dvb->fe[0], 1);\r\nif (!dvb_attach(tda18271c2dd_attach, dvb->fe[0], &dev->i2c_adap[dev->def_i2c_bus], 0x60)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (dvb->fe[0]->ops.i2c_gate_ctrl)\r\ndvb->fe[0]->ops.i2c_gate_ctrl(dvb->fe[0], 0);\r\nbreak;\r\ncase EM2884_BOARD_C3TECH_DIGITAL_DUO:\r\ndvb->fe[0] = dvb_attach(mb86a20s_attach,\r\n&c3tech_duo_mb86a20s_config,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (dvb->fe[0] != NULL)\r\ndvb_attach(tda18271_attach, dvb->fe[0], 0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&c3tech_duo_tda18271_config);\r\nbreak;\r\ncase EM28174_BOARD_PCTV_460E: {\r\nstruct i2c_client *client;\r\nstruct i2c_board_info board_info;\r\nstruct tda10071_platform_data tda10071_pdata = {};\r\nstruct a8293_platform_data a8293_pdata = {};\r\ntda10071_pdata.clk = 40444000,\r\ntda10071_pdata.i2c_wr_max = 64,\r\ntda10071_pdata.ts_mode = TDA10071_TS_SERIAL,\r\ntda10071_pdata.pll_multiplier = 20,\r\ntda10071_pdata.tuner_i2c_addr = 0x14,\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "tda10071_cx24118", I2C_NAME_SIZE);\r\nboard_info.addr = 0x55;\r\nboard_info.platform_data = &tda10071_pdata;\r\nrequest_module("tda10071");\r\nclient = i2c_new_device(&dev->i2c_adap[dev->def_i2c_bus], &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->fe[0] = tda10071_pdata.get_dvb_frontend(client);\r\ndvb->i2c_client_demod = client;\r\na8293_pdata.dvb_frontend = dvb->fe[0];\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "a8293", I2C_NAME_SIZE);\r\nboard_info.addr = 0x08;\r\nboard_info.platform_data = &a8293_pdata;\r\nrequest_module("a8293");\r\nclient = i2c_new_device(&dev->i2c_adap[dev->def_i2c_bus], &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_sec = client;\r\nbreak;\r\n}\r\ncase EM2874_BOARD_DELOCK_61959:\r\ncase EM2874_BOARD_MAXMEDIA_UB425_TC:\r\ndvb->fe[0] = dvb_attach(drxk_attach, &maxmedia_ub425_tc_drxk,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (dvb->fe[0]) {\r\ndvb->fe[0]->ops.i2c_gate_ctrl = NULL;\r\nif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&em28xx_cxd2820r_tda18271_config)) {\r\ndvb_frontend_detach(dvb->fe[0]);\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nbreak;\r\ncase EM2884_BOARD_PCTV_510E:\r\ncase EM2884_BOARD_PCTV_520E:\r\npctv_520e_init(dev);\r\ndvb->fe[0] = dvb_attach(drxk_attach, &pctv_520e_drxk,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (dvb->fe[0]) {\r\nif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&em28xx_cxd2820r_tda18271_config)) {\r\ndvb_frontend_detach(dvb->fe[0]);\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nbreak;\r\ncase EM2884_BOARD_ELGATO_EYETV_HYBRID_2008:\r\ncase EM2884_BOARD_CINERGY_HTC_STICK:\r\nterratec_htc_stick_init(dev);\r\ndvb->fe[0] = dvb_attach(drxk_attach, &terratec_htc_stick_drxk,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&em28xx_cxd2820r_tda18271_config)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2884_BOARD_TERRATEC_HTC_USB_XS:\r\nterratec_htc_usb_xs_init(dev);\r\ndvb->fe[0] = dvb_attach(drxk_attach, &terratec_htc_stick_drxk,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&em28xx_cxd2820r_tda18271_config)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2874_BOARD_KWORLD_UB435Q_V2:\r\ndvb->fe[0] = dvb_attach(lgdt3305_attach,\r\n&em2874_lgdt3305_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (!dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&kworld_ub435q_v2_config)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase EM2874_BOARD_KWORLD_UB435Q_V3:\r\n{\r\nstruct i2c_client *client;\r\nstruct i2c_adapter *adapter = &dev->i2c_adap[dev->def_i2c_bus];\r\nstruct i2c_board_info board_info = {\r\n.type = "tda18212",\r\n.addr = 0x60,\r\n.platform_data = &kworld_ub435q_v3_config,\r\n};\r\ndvb->fe[0] = dvb_attach(lgdt3305_attach,\r\n&em2874_lgdt3305_nogate_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus]);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nkworld_ub435q_v3_config.fe = dvb->fe[0];\r\nrequest_module("tda18212");\r\nclient = i2c_new_device(adapter, &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\ndvb_frontend_detach(dvb->fe[0]);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\ndvb_frontend_detach(dvb->fe[0]);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_tuner = client;\r\nbreak;\r\n}\r\ncase EM2874_BOARD_PCTV_HD_MINI_80E:\r\ndvb->fe[0] = dvb_attach(drx39xxj_attach, &dev->i2c_adap[dev->def_i2c_bus]);\r\nif (dvb->fe[0] != NULL) {\r\ndvb->fe[0] = dvb_attach(tda18271_attach, dvb->fe[0], 0x60,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n&pinnacle_80e_dvb_config);\r\nif (!dvb->fe[0]) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nbreak;\r\ncase EM28178_BOARD_PCTV_461E: {\r\nstruct i2c_client *client;\r\nstruct i2c_adapter *i2c_adapter;\r\nstruct i2c_board_info board_info;\r\nstruct m88ds3103_platform_data m88ds3103_pdata = {};\r\nstruct ts2020_config ts2020_config = {};\r\nstruct a8293_platform_data a8293_pdata = {};\r\nm88ds3103_pdata.clk = 27000000;\r\nm88ds3103_pdata.i2c_wr_max = 33;\r\nm88ds3103_pdata.ts_mode = M88DS3103_TS_PARALLEL;\r\nm88ds3103_pdata.ts_clk = 16000;\r\nm88ds3103_pdata.ts_clk_pol = 1;\r\nm88ds3103_pdata.agc = 0x99;\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "m88ds3103", I2C_NAME_SIZE);\r\nboard_info.addr = 0x68;\r\nboard_info.platform_data = &m88ds3103_pdata;\r\nrequest_module("m88ds3103");\r\nclient = i2c_new_device(&dev->i2c_adap[dev->def_i2c_bus], &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->fe[0] = m88ds3103_pdata.get_dvb_frontend(client);\r\ni2c_adapter = m88ds3103_pdata.get_i2c_adapter(client);\r\ndvb->i2c_client_demod = client;\r\nts2020_config.fe = dvb->fe[0];\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "ts2022", I2C_NAME_SIZE);\r\nboard_info.addr = 0x60;\r\nboard_info.platform_data = &ts2020_config;\r\nrequest_module("ts2020");\r\nclient = i2c_new_device(i2c_adapter, &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_tuner = client;\r\ndvb->fe[0]->ops.read_signal_strength =\r\ndvb->fe[0]->ops.tuner_ops.get_rf_strength;\r\na8293_pdata.dvb_frontend = dvb->fe[0];\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "a8293", I2C_NAME_SIZE);\r\nboard_info.addr = 0x08;\r\nboard_info.platform_data = &a8293_pdata;\r\nrequest_module("a8293");\r\nclient = i2c_new_device(&dev->i2c_adap[dev->def_i2c_bus], &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nmodule_put(dvb->i2c_client_tuner->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_tuner);\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nmodule_put(dvb->i2c_client_tuner->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_tuner);\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_sec = client;\r\nbreak;\r\n}\r\ncase EM28178_BOARD_PCTV_292E:\r\n{\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info;\r\nstruct si2168_config si2168_config;\r\nstruct si2157_config si2157_config;\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &dvb->fe[0];\r\nsi2168_config.ts_mode = SI2168_TS_PARALLEL;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(&dev->i2c_adap[dev->def_i2c_bus], &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_demod = client;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = dvb->fe[0];\r\nsi2157_config.if_port = 1;\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nsi2157_config.mdev = dev->media_dev;\r\n#endif\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(adapter, &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_tuner = client;\r\ndvb->fe[0]->ops.set_lna = em28xx_pctv_292e_set_lna;\r\n}\r\nbreak;\r\ncase EM28178_BOARD_TERRATEC_T2_STICK_HD:\r\n{\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info;\r\nstruct si2168_config si2168_config;\r\nstruct si2157_config si2157_config;\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &dvb->fe[0];\r\nsi2168_config.ts_mode = SI2168_TS_PARALLEL;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(&dev->i2c_adap[dev->def_i2c_bus], &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_demod = client;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = dvb->fe[0];\r\nsi2157_config.if_port = 0;\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nsi2157_config.mdev = dev->media_dev;\r\n#endif\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2146", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module("si2157");\r\nclient = i2c_new_device(adapter, &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_tuner = client;\r\n}\r\nbreak;\r\ncase EM28178_BOARD_PLEX_PX_BCUD:\r\n{\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info;\r\nstruct tc90522_config tc90522_config;\r\nstruct qm1d1c0042_config qm1d1c0042_config;\r\nmemset(&tc90522_config, 0, sizeof(tc90522_config));\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "tc90522sat", I2C_NAME_SIZE);\r\ninfo.addr = 0x15;\r\ninfo.platform_data = &tc90522_config;\r\nrequest_module("tc90522");\r\nclient = i2c_new_device(&dev->i2c_adap[dev->def_i2c_bus], &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_demod = client;\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nmemset(&qm1d1c0042_config, 0,\r\nsizeof(qm1d1c0042_config));\r\nqm1d1c0042_config.fe = tc90522_config.fe;\r\nqm1d1c0042_config.lpf = 1;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "qm1d1c0042", I2C_NAME_SIZE);\r\ninfo.addr = 0x61;\r\ninfo.platform_data = &qm1d1c0042_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(tc90522_config.tuner_i2c,\r\n&info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_tuner = client;\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->fe[0] = tc90522_config.fe;\r\npx_bcud_init(dev);\r\n}\r\nbreak;\r\ncase EM28174_BOARD_HAUPPAUGE_WINTV_DUALHD_DVB:\r\n{\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info;\r\nstruct si2168_config si2168_config;\r\nstruct si2157_config si2157_config;\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &dvb->fe[0];\r\nsi2168_config.ts_mode = SI2168_TS_SERIAL;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(&dev->i2c_adap[dev->def_i2c_bus], &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_demod = client;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = dvb->fe[0];\r\nsi2157_config.if_port = 1;\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nsi2157_config.mdev = dev->media_dev;\r\n#endif\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(adapter, &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nmodule_put(dvb->i2c_client_demod->dev.driver->owner);\r\ni2c_unregister_device(dvb->i2c_client_demod);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndvb->i2c_client_tuner = client;\r\n}\r\nbreak;\r\ndefault:\r\nem28xx_errdev("/2: The frontend of your DVB/ATSC card"\r\n" isn't supported yet\n");\r\nbreak;\r\n}\r\nif (NULL == dvb->fe[0]) {\r\nem28xx_errdev("/2: frontend initialization failed\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->fe[0]->callback = em28xx_tuner_callback;\r\nif (dvb->fe[1])\r\ndvb->fe[1]->callback = em28xx_tuner_callback;\r\nresult = em28xx_register_dvb(dvb, THIS_MODULE, dev, &dev->udev->dev);\r\nif (result < 0)\r\ngoto out_free;\r\nem28xx_info("DVB extension successfully initialized\n");\r\nkref_get(&dev->ref);\r\nret:\r\nem28xx_set_mode(dev, EM28XX_SUSPEND);\r\nmutex_unlock(&dev->lock);\r\nreturn result;\r\nout_free:\r\nkfree(dvb);\r\ndev->dvb = NULL;\r\ngoto ret;\r\n}\r\nstatic inline void prevent_sleep(struct dvb_frontend_ops *ops)\r\n{\r\nops->set_voltage = NULL;\r\nops->sleep = NULL;\r\nops->tuner_ops.sleep = NULL;\r\n}\r\nstatic int em28xx_dvb_fini(struct em28xx *dev)\r\n{\r\nstruct em28xx_dvb *dvb;\r\nstruct i2c_client *client;\r\nif (dev->is_audio_only) {\r\nreturn 0;\r\n}\r\nif (!dev->board.has_dvb) {\r\nreturn 0;\r\n}\r\nif (!dev->dvb)\r\nreturn 0;\r\nem28xx_info("Closing DVB extension\n");\r\ndvb = dev->dvb;\r\nem28xx_uninit_usb_xfer(dev, EM28XX_DIGITAL_MODE);\r\nif (dev->disconnected) {\r\nif (dvb->fe[0]) {\r\nprevent_sleep(&dvb->fe[0]->ops);\r\ndvb->fe[0]->exit = DVB_FE_DEVICE_REMOVED;\r\n}\r\nif (dvb->fe[1]) {\r\nprevent_sleep(&dvb->fe[1]->ops);\r\ndvb->fe[1]->exit = DVB_FE_DEVICE_REMOVED;\r\n}\r\n}\r\nclient = dvb->i2c_client_sec;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nclient = dvb->i2c_client_tuner;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nclient = dvb->i2c_client_demod;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nem28xx_unregister_dvb(dvb);\r\nkfree(dvb);\r\ndev->dvb = NULL;\r\nkref_put(&dev->ref, em28xx_free_device);\r\nreturn 0;\r\n}\r\nstatic int em28xx_dvb_suspend(struct em28xx *dev)\r\n{\r\nint ret = 0;\r\nif (dev->is_audio_only)\r\nreturn 0;\r\nif (!dev->board.has_dvb)\r\nreturn 0;\r\nem28xx_info("Suspending DVB extension\n");\r\nif (dev->dvb) {\r\nstruct em28xx_dvb *dvb = dev->dvb;\r\nif (dvb->fe[0]) {\r\nret = dvb_frontend_suspend(dvb->fe[0]);\r\nem28xx_info("fe0 suspend %d\n", ret);\r\n}\r\nif (dvb->fe[1]) {\r\ndvb_frontend_suspend(dvb->fe[1]);\r\nem28xx_info("fe1 suspend %d\n", ret);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int em28xx_dvb_resume(struct em28xx *dev)\r\n{\r\nint ret = 0;\r\nif (dev->is_audio_only)\r\nreturn 0;\r\nif (!dev->board.has_dvb)\r\nreturn 0;\r\nem28xx_info("Resuming DVB extension\n");\r\nif (dev->dvb) {\r\nstruct em28xx_dvb *dvb = dev->dvb;\r\nif (dvb->fe[0]) {\r\nret = dvb_frontend_resume(dvb->fe[0]);\r\nem28xx_info("fe0 resume %d\n", ret);\r\n}\r\nif (dvb->fe[1]) {\r\nret = dvb_frontend_resume(dvb->fe[1]);\r\nem28xx_info("fe1 resume %d\n", ret);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init em28xx_dvb_register(void)\r\n{\r\nreturn em28xx_register_extension(&dvb_ops);\r\n}\r\nstatic void __exit em28xx_dvb_unregister(void)\r\n{\r\nem28xx_unregister_extension(&dvb_ops);\r\n}
