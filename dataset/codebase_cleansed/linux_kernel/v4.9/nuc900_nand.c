static inline struct nuc900_nand *mtd_to_nuc900(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd_to_nand(mtd), struct nuc900_nand, chip);\r\n}\r\nstatic unsigned char nuc900_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nunsigned char ret;\r\nstruct nuc900_nand *nand = mtd_to_nuc900(mtd);\r\nret = (unsigned char)read_data_reg(nand);\r\nreturn ret;\r\n}\r\nstatic void nuc900_nand_read_buf(struct mtd_info *mtd,\r\nunsigned char *buf, int len)\r\n{\r\nint i;\r\nstruct nuc900_nand *nand = mtd_to_nuc900(mtd);\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = (unsigned char)read_data_reg(nand);\r\n}\r\nstatic void nuc900_nand_write_buf(struct mtd_info *mtd,\r\nconst unsigned char *buf, int len)\r\n{\r\nint i;\r\nstruct nuc900_nand *nand = mtd_to_nuc900(mtd);\r\nfor (i = 0; i < len; i++)\r\nwrite_data_reg(nand, buf[i]);\r\n}\r\nstatic int nuc900_check_rb(struct nuc900_nand *nand)\r\n{\r\nunsigned int val;\r\nspin_lock(&nand->lock);\r\nval = __raw_readl(nand->reg + REG_SMISR);\r\nval &= READYBUSY;\r\nspin_unlock(&nand->lock);\r\nreturn val;\r\n}\r\nstatic int nuc900_nand_devready(struct mtd_info *mtd)\r\n{\r\nstruct nuc900_nand *nand = mtd_to_nuc900(mtd);\r\nint ready;\r\nready = (nuc900_check_rb(nand)) ? 1 : 0;\r\nreturn ready;\r\n}\r\nstatic void nuc900_nand_command_lp(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nregister struct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct nuc900_nand *nand = mtd_to_nuc900(mtd);\r\nif (command == NAND_CMD_READOOB) {\r\ncolumn += mtd->writesize;\r\ncommand = NAND_CMD_READ0;\r\n}\r\nwrite_cmd_reg(nand, command & 0xff);\r\nif (column != -1 || page_addr != -1) {\r\nif (column != -1) {\r\nif (chip->options & NAND_BUSWIDTH_16 &&\r\n!nand_opcode_8bits(command))\r\ncolumn >>= 1;\r\nwrite_addr_reg(nand, column);\r\nwrite_addr_reg(nand, column >> 8 | ENDADDR);\r\n}\r\nif (page_addr != -1) {\r\nwrite_addr_reg(nand, page_addr);\r\nif (chip->chipsize > (128 << 20)) {\r\nwrite_addr_reg(nand, page_addr >> 8);\r\nwrite_addr_reg(nand, page_addr >> 16 | ENDADDR);\r\n} else {\r\nwrite_addr_reg(nand, page_addr >> 8 | ENDADDR);\r\n}\r\n}\r\n}\r\nswitch (command) {\r\ncase NAND_CMD_CACHEDPROG:\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_RNDIN:\r\ncase NAND_CMD_STATUS:\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nif (chip->dev_ready)\r\nbreak;\r\nudelay(chip->chip_delay);\r\nwrite_cmd_reg(nand, NAND_CMD_STATUS);\r\nwrite_cmd_reg(nand, command);\r\nwhile (!nuc900_check_rb(nand))\r\n;\r\nreturn;\r\ncase NAND_CMD_RNDOUT:\r\nwrite_cmd_reg(nand, NAND_CMD_RNDOUTSTART);\r\nreturn;\r\ncase NAND_CMD_READ0:\r\nwrite_cmd_reg(nand, NAND_CMD_READSTART);\r\ndefault:\r\nif (!chip->dev_ready) {\r\nudelay(chip->chip_delay);\r\nreturn;\r\n}\r\n}\r\nndelay(100);\r\nwhile (!chip->dev_ready(mtd))\r\n;\r\n}\r\nstatic void nuc900_nand_enable(struct nuc900_nand *nand)\r\n{\r\nunsigned int val;\r\nspin_lock(&nand->lock);\r\n__raw_writel(RESET_FMI, (nand->reg + REG_FMICSR));\r\nval = __raw_readl(nand->reg + REG_FMICSR);\r\nif (!(val & NAND_EN))\r\n__raw_writel(val | NAND_EN, nand->reg + REG_FMICSR);\r\nval = __raw_readl(nand->reg + REG_SMCSR);\r\nval &= ~(SWRST|PSIZE|DMARWEN|BUSWID|ECC4EN|NANDCS);\r\nval |= WP;\r\n__raw_writel(val, nand->reg + REG_SMCSR);\r\nspin_unlock(&nand->lock);\r\n}\r\nstatic int nuc900_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct nuc900_nand *nuc900_nand;\r\nstruct nand_chip *chip;\r\nstruct mtd_info *mtd;\r\nstruct resource *res;\r\nnuc900_nand = devm_kzalloc(&pdev->dev, sizeof(struct nuc900_nand),\r\nGFP_KERNEL);\r\nif (!nuc900_nand)\r\nreturn -ENOMEM;\r\nchip = &(nuc900_nand->chip);\r\nmtd = nand_to_mtd(chip);\r\nmtd->dev.parent = &pdev->dev;\r\nspin_lock_init(&nuc900_nand->lock);\r\nnuc900_nand->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(nuc900_nand->clk))\r\nreturn -ENOENT;\r\nclk_enable(nuc900_nand->clk);\r\nchip->cmdfunc = nuc900_nand_command_lp;\r\nchip->dev_ready = nuc900_nand_devready;\r\nchip->read_byte = nuc900_nand_read_byte;\r\nchip->write_buf = nuc900_nand_write_buf;\r\nchip->read_buf = nuc900_nand_read_buf;\r\nchip->chip_delay = 50;\r\nchip->options = 0;\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nchip->ecc.algo = NAND_ECC_HAMMING;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnuc900_nand->reg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(nuc900_nand->reg))\r\nreturn PTR_ERR(nuc900_nand->reg);\r\nnuc900_nand_enable(nuc900_nand);\r\nif (nand_scan(mtd, 1))\r\nreturn -ENXIO;\r\nmtd_device_register(mtd, partitions, ARRAY_SIZE(partitions));\r\nplatform_set_drvdata(pdev, nuc900_nand);\r\nreturn 0;\r\n}\r\nstatic int nuc900_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct nuc900_nand *nuc900_nand = platform_get_drvdata(pdev);\r\nnand_release(nand_to_mtd(&nuc900_nand->chip));\r\nclk_disable(nuc900_nand->clk);\r\nreturn 0;\r\n}
