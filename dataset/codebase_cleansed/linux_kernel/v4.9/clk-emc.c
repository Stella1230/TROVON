static unsigned long emc_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct tegra_clk_emc *tegra;\r\nu32 val, div;\r\ntegra = container_of(hw, struct tegra_clk_emc, hw);\r\nparent_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\r\nval = readl(tegra->clk_regs + CLK_SOURCE_EMC);\r\ndiv = val & CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR_MASK;\r\nreturn parent_rate / (div + 2) * 2;\r\n}\r\nstatic int emc_determine_rate(struct clk_hw *hw, struct clk_rate_request *req)\r\n{\r\nstruct tegra_clk_emc *tegra;\r\nu8 ram_code = tegra_read_ram_code();\r\nstruct emc_timing *timing = NULL;\r\nint i;\r\ntegra = container_of(hw, struct tegra_clk_emc, hw);\r\nfor (i = 0; i < tegra->num_timings; i++) {\r\nif (tegra->timings[i].ram_code != ram_code)\r\ncontinue;\r\ntiming = tegra->timings + i;\r\nif (timing->rate > req->max_rate) {\r\ni = min(i, 1);\r\nreq->rate = tegra->timings[i - 1].rate;\r\nreturn 0;\r\n}\r\nif (timing->rate < req->min_rate)\r\ncontinue;\r\nif (timing->rate >= req->rate) {\r\nreq->rate = timing->rate;\r\nreturn 0;\r\n}\r\n}\r\nif (timing) {\r\nreq->rate = timing->rate;\r\nreturn 0;\r\n}\r\nreq->rate = clk_hw_get_rate(hw);\r\nreturn 0;\r\n}\r\nstatic u8 emc_get_parent(struct clk_hw *hw)\r\n{\r\nstruct tegra_clk_emc *tegra;\r\nu32 val;\r\ntegra = container_of(hw, struct tegra_clk_emc, hw);\r\nval = readl(tegra->clk_regs + CLK_SOURCE_EMC);\r\nreturn (val >> CLK_SOURCE_EMC_EMC_2X_CLK_SRC_SHIFT)\r\n& CLK_SOURCE_EMC_EMC_2X_CLK_SRC_MASK;\r\n}\r\nstatic struct tegra_emc *emc_ensure_emc_driver(struct tegra_clk_emc *tegra)\r\n{\r\nstruct platform_device *pdev;\r\nif (tegra->emc)\r\nreturn tegra->emc;\r\nif (!tegra->emc_node)\r\nreturn NULL;\r\npdev = of_find_device_by_node(tegra->emc_node);\r\nif (!pdev) {\r\npr_err("%s: could not get external memory controller\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nof_node_put(tegra->emc_node);\r\ntegra->emc_node = NULL;\r\ntegra->emc = platform_get_drvdata(pdev);\r\nif (!tegra->emc) {\r\npr_err("%s: cannot find EMC driver\n", __func__);\r\nreturn NULL;\r\n}\r\nreturn tegra->emc;\r\n}\r\nstatic int emc_set_timing(struct tegra_clk_emc *tegra,\r\nstruct emc_timing *timing)\r\n{\r\nint err;\r\nu8 div;\r\nu32 car_value;\r\nunsigned long flags = 0;\r\nstruct tegra_emc *emc = emc_ensure_emc_driver(tegra);\r\nif (!emc)\r\nreturn -ENOENT;\r\npr_debug("going to rate %ld prate %ld p %s\n", timing->rate,\r\ntiming->parent_rate, __clk_get_name(timing->parent));\r\nif (emc_get_parent(&tegra->hw) == timing->parent_index &&\r\nclk_get_rate(timing->parent) != timing->parent_rate) {\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\ntegra->changing_timing = true;\r\nerr = clk_set_rate(timing->parent, timing->parent_rate);\r\nif (err) {\r\npr_err("cannot change parent %s rate to %ld: %d\n",\r\n__clk_get_name(timing->parent), timing->parent_rate,\r\nerr);\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(timing->parent);\r\nif (err) {\r\npr_err("cannot enable parent clock: %d\n", err);\r\nreturn err;\r\n}\r\ndiv = timing->parent_rate / (timing->rate / 2) - 2;\r\nerr = tegra_emc_prepare_timing_change(emc, timing->rate);\r\nif (err)\r\nreturn err;\r\nspin_lock_irqsave(tegra->lock, flags);\r\ncar_value = readl(tegra->clk_regs + CLK_SOURCE_EMC);\r\ncar_value &= ~CLK_SOURCE_EMC_EMC_2X_CLK_SRC(~0);\r\ncar_value |= CLK_SOURCE_EMC_EMC_2X_CLK_SRC(timing->parent_index);\r\ncar_value &= ~CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR(~0);\r\ncar_value |= CLK_SOURCE_EMC_EMC_2X_CLK_DIVISOR(div);\r\nwritel(car_value, tegra->clk_regs + CLK_SOURCE_EMC);\r\nspin_unlock_irqrestore(tegra->lock, flags);\r\ntegra_emc_complete_timing_change(emc, timing->rate);\r\nclk_hw_reparent(&tegra->hw, __clk_get_hw(timing->parent));\r\nclk_disable_unprepare(tegra->prev_parent);\r\ntegra->prev_parent = timing->parent;\r\ntegra->changing_timing = false;\r\nreturn 0;\r\n}\r\nstatic struct emc_timing *get_backup_timing(struct tegra_clk_emc *tegra,\r\nint timing_index)\r\n{\r\nint i;\r\nu32 ram_code = tegra_read_ram_code();\r\nstruct emc_timing *timing;\r\nfor (i = timing_index+1; i < tegra->num_timings; i++) {\r\ntiming = tegra->timings + i;\r\nif (timing->ram_code != ram_code)\r\ncontinue;\r\nif (emc_parent_clk_sources[timing->parent_index] !=\r\nemc_parent_clk_sources[\r\ntegra->timings[timing_index].parent_index])\r\nreturn timing;\r\n}\r\nfor (i = timing_index-1; i >= 0; --i) {\r\ntiming = tegra->timings + i;\r\nif (timing->ram_code != ram_code)\r\ncontinue;\r\nif (emc_parent_clk_sources[timing->parent_index] !=\r\nemc_parent_clk_sources[\r\ntegra->timings[timing_index].parent_index])\r\nreturn timing;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int emc_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct tegra_clk_emc *tegra;\r\nstruct emc_timing *timing = NULL;\r\nint i, err;\r\nu32 ram_code = tegra_read_ram_code();\r\ntegra = container_of(hw, struct tegra_clk_emc, hw);\r\nif (clk_hw_get_rate(hw) == rate)\r\nreturn 0;\r\nif (tegra->changing_timing)\r\nreturn 0;\r\nfor (i = 0; i < tegra->num_timings; i++) {\r\nif (tegra->timings[i].rate == rate &&\r\ntegra->timings[i].ram_code == ram_code) {\r\ntiming = tegra->timings + i;\r\nbreak;\r\n}\r\n}\r\nif (!timing) {\r\npr_err("cannot switch to rate %ld without emc table\n", rate);\r\nreturn -EINVAL;\r\n}\r\nif (emc_parent_clk_sources[emc_get_parent(hw)] ==\r\nemc_parent_clk_sources[timing->parent_index] &&\r\nclk_get_rate(timing->parent) != timing->parent_rate) {\r\nstruct emc_timing *backup_timing;\r\nbackup_timing = get_backup_timing(tegra, i);\r\nif (!backup_timing) {\r\npr_err("cannot find backup timing\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("using %ld as backup rate when going to %ld\n",\r\nbackup_timing->rate, rate);\r\nerr = emc_set_timing(tegra, backup_timing);\r\nif (err) {\r\npr_err("cannot set backup timing: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nreturn emc_set_timing(tegra, timing);\r\n}\r\nstatic int load_one_timing_from_dt(struct tegra_clk_emc *tegra,\r\nstruct emc_timing *timing,\r\nstruct device_node *node)\r\n{\r\nint err, i;\r\nu32 tmp;\r\nerr = of_property_read_u32(node, "clock-frequency", &tmp);\r\nif (err) {\r\npr_err("timing %s: failed to read rate\n", node->full_name);\r\nreturn err;\r\n}\r\ntiming->rate = tmp;\r\nerr = of_property_read_u32(node, "nvidia,parent-clock-frequency", &tmp);\r\nif (err) {\r\npr_err("timing %s: failed to read parent rate\n",\r\nnode->full_name);\r\nreturn err;\r\n}\r\ntiming->parent_rate = tmp;\r\ntiming->parent = of_clk_get_by_name(node, "emc-parent");\r\nif (IS_ERR(timing->parent)) {\r\npr_err("timing %s: failed to get parent clock\n",\r\nnode->full_name);\r\nreturn PTR_ERR(timing->parent);\r\n}\r\ntiming->parent_index = 0xff;\r\nfor (i = 0; i < ARRAY_SIZE(emc_parent_clk_names); i++) {\r\nif (!strcmp(emc_parent_clk_names[i],\r\n__clk_get_name(timing->parent))) {\r\ntiming->parent_index = i;\r\nbreak;\r\n}\r\n}\r\nif (timing->parent_index == 0xff) {\r\npr_err("timing %s: %s is not a valid parent\n",\r\nnode->full_name, __clk_get_name(timing->parent));\r\nclk_put(timing->parent);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cmp_timings(const void *_a, const void *_b)\r\n{\r\nconst struct emc_timing *a = _a;\r\nconst struct emc_timing *b = _b;\r\nif (a->rate < b->rate)\r\nreturn -1;\r\nelse if (a->rate == b->rate)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int load_timings_from_dt(struct tegra_clk_emc *tegra,\r\nstruct device_node *node,\r\nu32 ram_code)\r\n{\r\nstruct device_node *child;\r\nint child_count = of_get_child_count(node);\r\nint i = 0, err;\r\ntegra->timings = kcalloc(child_count, sizeof(struct emc_timing),\r\nGFP_KERNEL);\r\nif (!tegra->timings)\r\nreturn -ENOMEM;\r\ntegra->num_timings = child_count;\r\nfor_each_child_of_node(node, child) {\r\nstruct emc_timing *timing = tegra->timings + (i++);\r\nerr = load_one_timing_from_dt(tegra, timing, child);\r\nif (err) {\r\nof_node_put(child);\r\nreturn err;\r\n}\r\ntiming->ram_code = ram_code;\r\n}\r\nsort(tegra->timings, tegra->num_timings, sizeof(struct emc_timing),\r\ncmp_timings, NULL);\r\nreturn 0;\r\n}\r\nstruct clk *tegra_clk_register_emc(void __iomem *base, struct device_node *np,\r\nspinlock_t *lock)\r\n{\r\nstruct tegra_clk_emc *tegra;\r\nstruct clk_init_data init;\r\nstruct device_node *node;\r\nu32 node_ram_code;\r\nstruct clk *clk;\r\nint err;\r\ntegra = kcalloc(1, sizeof(*tegra), GFP_KERNEL);\r\nif (!tegra)\r\nreturn ERR_PTR(-ENOMEM);\r\ntegra->clk_regs = base;\r\ntegra->lock = lock;\r\ntegra->num_timings = 0;\r\nfor_each_child_of_node(np, node) {\r\nerr = of_property_read_u32(node, "nvidia,ram-code",\r\n&node_ram_code);\r\nif (err)\r\ncontinue;\r\nerr = load_timings_from_dt(tegra, node, node_ram_code);\r\nof_node_put(node);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nbreak;\r\n}\r\nif (tegra->num_timings == 0)\r\npr_warn("%s: no memory timings registered\n", __func__);\r\ntegra->emc_node = of_parse_phandle(np,\r\n"nvidia,external-memory-controller", 0);\r\nif (!tegra->emc_node)\r\npr_warn("%s: couldn't find node for EMC driver\n", __func__);\r\ninit.name = "emc";\r\ninit.ops = &tegra_clk_emc_ops;\r\ninit.flags = 0;\r\ninit.parent_names = emc_parent_clk_names;\r\ninit.num_parents = ARRAY_SIZE(emc_parent_clk_names);\r\ntegra->hw.init = &init;\r\nclk = clk_register(NULL, &tegra->hw);\r\nif (IS_ERR(clk))\r\nreturn clk;\r\ntegra->prev_parent = clk_hw_get_parent_by_index(\r\n&tegra->hw, emc_get_parent(&tegra->hw))->clk;\r\ntegra->changing_timing = false;\r\nclk_register_clkdev(clk, "emc", "tegra-clk-debug");\r\nclk_prepare_enable(clk);\r\nreturn clk;\r\n}
