static void mx25_tsadc_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct mx25_tsadc *tsadc = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nu32 status;\r\nchained_irq_enter(chip, desc);\r\nregmap_read(tsadc->regs, MX25_TSC_TGSR, &status);\r\nif (status & MX25_TGSR_GCQ_INT)\r\ngeneric_handle_irq(irq_find_mapping(tsadc->domain, 1));\r\nif (status & MX25_TGSR_TCQ_INT)\r\ngeneric_handle_irq(irq_find_mapping(tsadc->domain, 0));\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int mx25_tsadc_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct mx25_tsadc *tsadc = d->host_data;\r\nirq_set_chip_data(irq, tsadc);\r\nirq_set_chip_and_handler(irq, &dummy_irq_chip,\r\nhandle_level_irq);\r\nirq_modify_status(irq, IRQ_NOREQUEST, IRQ_NOPROBE);\r\nreturn 0;\r\n}\r\nstatic int mx25_tsadc_setup_irq(struct platform_device *pdev,\r\nstruct mx25_tsadc *tsadc)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nint irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(dev, "Failed to get irq\n");\r\nreturn irq;\r\n}\r\ntsadc->domain = irq_domain_add_simple(np, 2, 0, &mx25_tsadc_domain_ops,\r\ntsadc);\r\nif (!tsadc->domain) {\r\ndev_err(dev, "Failed to add irq domain\n");\r\nreturn -ENOMEM;\r\n}\r\nirq_set_chained_handler(irq, mx25_tsadc_irq_handler);\r\nirq_set_handler_data(irq, tsadc);\r\nreturn 0;\r\n}\r\nstatic void mx25_tsadc_setup_clk(struct platform_device *pdev,\r\nstruct mx25_tsadc *tsadc)\r\n{\r\nunsigned clk_div;\r\ndev_dbg(&pdev->dev, "Found master clock at %lu Hz\n",\r\nclk_get_rate(tsadc->clk));\r\nclk_div = DIV_ROUND_UP(clk_get_rate(tsadc->clk), 1750000);\r\ndev_dbg(&pdev->dev, "Setting up ADC clock divider to %u\n", clk_div);\r\nclk_div -= 2;\r\nclk_div /= 2;\r\nclk_div = max_t(unsigned, 4, clk_div);\r\ndev_dbg(&pdev->dev, "Resulting ADC conversion clock at %lu Hz\n",\r\nclk_get_rate(tsadc->clk) / (2 * clk_div + 2));\r\nregmap_update_bits(tsadc->regs, MX25_TSC_TGCR,\r\nMX25_TGCR_ADCCLKCFG(0x1f),\r\nMX25_TGCR_ADCCLKCFG(clk_div));\r\n}\r\nstatic int mx25_tsadc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct mx25_tsadc *tsadc;\r\nstruct resource *res;\r\nint ret;\r\nvoid __iomem *iomem;\r\ntsadc = devm_kzalloc(dev, sizeof(*tsadc), GFP_KERNEL);\r\nif (!tsadc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niomem = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(iomem))\r\nreturn PTR_ERR(iomem);\r\ntsadc->regs = devm_regmap_init_mmio(dev, iomem,\r\n&mx25_tsadc_regmap_config);\r\nif (IS_ERR(tsadc->regs)) {\r\ndev_err(dev, "Failed to initialize regmap\n");\r\nreturn PTR_ERR(tsadc->regs);\r\n}\r\ntsadc->clk = devm_clk_get(dev, "ipg");\r\nif (IS_ERR(tsadc->clk)) {\r\ndev_err(dev, "Failed to get ipg clock\n");\r\nreturn PTR_ERR(tsadc->clk);\r\n}\r\nmx25_tsadc_setup_clk(pdev, tsadc);\r\nregmap_update_bits(tsadc->regs, MX25_TSC_TGCR, MX25_TGCR_CLK_EN,\r\nMX25_TGCR_CLK_EN);\r\nregmap_update_bits(tsadc->regs, MX25_TSC_TGCR, MX25_TGCR_TSC_RST,\r\nMX25_TGCR_TSC_RST);\r\nregmap_update_bits(tsadc->regs, MX25_TSC_TGCR, MX25_TGCR_POWERMODE_MASK,\r\nMX25_TGCR_POWERMODE_SAVE);\r\nregmap_update_bits(tsadc->regs, MX25_TSC_TGCR, MX25_TGCR_INTREFEN,\r\nMX25_TGCR_INTREFEN);\r\nret = mx25_tsadc_setup_irq(pdev, tsadc);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, tsadc);\r\nof_platform_populate(np, NULL, NULL, dev);\r\nreturn 0;\r\n}
