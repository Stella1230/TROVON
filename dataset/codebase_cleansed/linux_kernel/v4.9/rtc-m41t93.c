static inline int m41t93_set_reg(struct spi_device *spi, u8 addr, u8 data)\r\n{\r\nu8 buf[2];\r\nbuf[0] = addr | 0x80;\r\nbuf[1] = data;\r\nreturn spi_write(spi, buf, sizeof(buf));\r\n}\r\nstatic int m41t93_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nint tmp;\r\nu8 buf[9] = {0x80};\r\nu8 * const data = &buf[1];\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"write", tm->tm_sec, tm->tm_min,\r\ntm->tm_hour, tm->tm_mday,\r\ntm->tm_mon, tm->tm_year, tm->tm_wday);\r\nif (tm->tm_year < 100) {\r\ndev_warn(&spi->dev, "unsupported date (before 2000-01-01).\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = spi_w8r8(spi, M41T93_REG_FLAGS);\r\nif (tmp < 0)\r\nreturn tmp;\r\nif (tmp & M41T93_FLAG_OF) {\r\ndev_warn(&spi->dev, "OF bit is set, resetting.\n");\r\nm41t93_set_reg(spi, M41T93_REG_FLAGS, tmp & ~M41T93_FLAG_OF);\r\ntmp = spi_w8r8(spi, M41T93_REG_FLAGS);\r\nif (tmp < 0) {\r\nreturn tmp;\r\n} else if (tmp & M41T93_FLAG_OF) {\r\nu8 reset_osc = buf[M41T93_REG_ST_SEC] | M41T93_FLAG_ST;\r\ndev_warn(&spi->dev,\r\n"OF bit is still set, kickstarting clock.\n");\r\nm41t93_set_reg(spi, M41T93_REG_ST_SEC, reset_osc);\r\nreset_osc &= ~M41T93_FLAG_ST;\r\nm41t93_set_reg(spi, M41T93_REG_ST_SEC, reset_osc);\r\n}\r\n}\r\ndata[M41T93_REG_SSEC] = 0;\r\ndata[M41T93_REG_ST_SEC] = bin2bcd(tm->tm_sec);\r\ndata[M41T93_REG_MIN] = bin2bcd(tm->tm_min);\r\ndata[M41T93_REG_CENT_HOUR] = bin2bcd(tm->tm_hour) |\r\n((tm->tm_year/100-1) << 6);\r\ndata[M41T93_REG_DAY] = bin2bcd(tm->tm_mday);\r\ndata[M41T93_REG_WDAY] = bin2bcd(tm->tm_wday + 1);\r\ndata[M41T93_REG_MON] = bin2bcd(tm->tm_mon + 1);\r\ndata[M41T93_REG_YEAR] = bin2bcd(tm->tm_year % 100);\r\nreturn spi_write(spi, buf, sizeof(buf));\r\n}\r\nstatic int m41t93_get_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nconst u8 start_addr = 0;\r\nu8 buf[8];\r\nint century_after_1900;\r\nint tmp;\r\nint ret = 0;\r\ntmp = spi_w8r8(spi, M41T93_REG_ALM_HOUR_HT);\r\nif (tmp < 0)\r\nreturn tmp;\r\nif (tmp & M41T93_FLAG_HT) {\r\ndev_dbg(&spi->dev, "HT bit is set, reenable clock update.\n");\r\nm41t93_set_reg(spi, M41T93_REG_ALM_HOUR_HT,\r\ntmp & ~M41T93_FLAG_HT);\r\n}\r\ntmp = spi_w8r8(spi, M41T93_REG_FLAGS);\r\nif (tmp < 0)\r\nreturn tmp;\r\nif (tmp & M41T93_FLAG_OF) {\r\nret = -EINVAL;\r\ndev_warn(&spi->dev, "OF bit is set, write time to restart.\n");\r\n}\r\nif (tmp & M41T93_FLAG_BL)\r\ndev_warn(&spi->dev, "BL bit is set, replace battery.\n");\r\ntmp = spi_write_then_read(spi, &start_addr, 1, buf, sizeof(buf));\r\nif (tmp < 0)\r\nreturn tmp;\r\ntm->tm_sec = bcd2bin(buf[M41T93_REG_ST_SEC]);\r\ntm->tm_min = bcd2bin(buf[M41T93_REG_MIN]);\r\ntm->tm_hour = bcd2bin(buf[M41T93_REG_CENT_HOUR] & 0x3f);\r\ntm->tm_mday = bcd2bin(buf[M41T93_REG_DAY]);\r\ntm->tm_mon = bcd2bin(buf[M41T93_REG_MON]) - 1;\r\ntm->tm_wday = bcd2bin(buf[M41T93_REG_WDAY] & 0x0f) - 1;\r\ncentury_after_1900 = (buf[M41T93_REG_CENT_HOUR] >> 6) + 1;\r\ntm->tm_year = bcd2bin(buf[M41T93_REG_YEAR]) + century_after_1900 * 100;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"read", tm->tm_sec, tm->tm_min,\r\ntm->tm_hour, tm->tm_mday,\r\ntm->tm_mon, tm->tm_year, tm->tm_wday);\r\nreturn ret < 0 ? ret : rtc_valid_tm(tm);\r\n}\r\nstatic int m41t93_probe(struct spi_device *spi)\r\n{\r\nstruct rtc_device *rtc;\r\nint res;\r\nspi->bits_per_word = 8;\r\nspi_setup(spi);\r\nres = spi_w8r8(spi, M41T93_REG_WDAY);\r\nif (res < 0 || (res & 0xf8) != 0) {\r\ndev_err(&spi->dev, "not found 0x%x.\n", res);\r\nreturn -ENODEV;\r\n}\r\nrtc = devm_rtc_device_register(&spi->dev, m41t93_driver.driver.name,\r\n&m41t93_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\nspi_set_drvdata(spi, rtc);\r\nreturn 0;\r\n}
