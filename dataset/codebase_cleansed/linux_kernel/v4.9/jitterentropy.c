static __u64 jent_loop_shuffle(struct rand_data *ec,\r\nunsigned int bits, unsigned int min)\r\n{\r\n__u64 time = 0;\r\n__u64 shuffle = 0;\r\nunsigned int i = 0;\r\nunsigned int mask = (1<<bits) - 1;\r\njent_get_nstime(&time);\r\nif (ec)\r\ntime ^= ec->data;\r\nfor (i = 0; (DATA_SIZE_BITS / bits) > i; i++) {\r\nshuffle ^= time & mask;\r\ntime = time >> bits;\r\n}\r\nreturn (shuffle + (1<<min));\r\n}\r\nstatic __u64 jent_fold_time(struct rand_data *ec, __u64 time,\r\n__u64 *folded, __u64 loop_cnt)\r\n{\r\nunsigned int i;\r\n__u64 j = 0;\r\n__u64 new = 0;\r\n#define MAX_FOLD_LOOP_BIT 4\r\n#define MIN_FOLD_LOOP_BIT 0\r\n__u64 fold_loop_cnt =\r\njent_loop_shuffle(ec, MAX_FOLD_LOOP_BIT, MIN_FOLD_LOOP_BIT);\r\nif (loop_cnt)\r\nfold_loop_cnt = loop_cnt;\r\nfor (j = 0; j < fold_loop_cnt; j++) {\r\nnew = 0;\r\nfor (i = 1; (DATA_SIZE_BITS) >= i; i++) {\r\n__u64 tmp = time << (DATA_SIZE_BITS - i);\r\ntmp = tmp >> (DATA_SIZE_BITS - 1);\r\nnew ^= tmp;\r\n}\r\n}\r\n*folded = new;\r\nreturn fold_loop_cnt;\r\n}\r\nstatic unsigned int jent_memaccess(struct rand_data *ec, __u64 loop_cnt)\r\n{\r\nunsigned char *tmpval = NULL;\r\nunsigned int wrap = 0;\r\n__u64 i = 0;\r\n#define MAX_ACC_LOOP_BIT 7\r\n#define MIN_ACC_LOOP_BIT 0\r\n__u64 acc_loop_cnt =\r\njent_loop_shuffle(ec, MAX_ACC_LOOP_BIT, MIN_ACC_LOOP_BIT);\r\nif (NULL == ec || NULL == ec->mem)\r\nreturn 0;\r\nwrap = ec->memblocksize * ec->memblocks;\r\nif (loop_cnt)\r\nacc_loop_cnt = loop_cnt;\r\nfor (i = 0; i < (ec->memaccessloops + acc_loop_cnt); i++) {\r\ntmpval = ec->mem + ec->memlocation;\r\n*tmpval = (*tmpval + 1) & 0xff;\r\nec->memlocation = ec->memlocation + ec->memblocksize - 1;\r\nec->memlocation = ec->memlocation % wrap;\r\n}\r\nreturn i;\r\n}\r\nstatic void jent_stuck(struct rand_data *ec, __u64 current_delta)\r\n{\r\n__s64 delta2 = ec->last_delta - current_delta;\r\n__s64 delta3 = delta2 - ec->last_delta2;\r\nec->last_delta = current_delta;\r\nec->last_delta2 = delta2;\r\nif (!current_delta || !delta2 || !delta3)\r\nec->stuck = 1;\r\n}\r\nstatic __u64 jent_measure_jitter(struct rand_data *ec)\r\n{\r\n__u64 time = 0;\r\n__u64 data = 0;\r\n__u64 current_delta = 0;\r\njent_memaccess(ec, 0);\r\njent_get_nstime(&time);\r\ncurrent_delta = time - ec->prev_time;\r\nec->prev_time = time;\r\njent_fold_time(ec, current_delta, &data, 0);\r\njent_stuck(ec, current_delta);\r\nreturn data;\r\n}\r\nstatic __u64 jent_unbiased_bit(struct rand_data *entropy_collector)\r\n{\r\ndo {\r\n__u64 a = jent_measure_jitter(entropy_collector);\r\n__u64 b = jent_measure_jitter(entropy_collector);\r\nif (a == b)\r\ncontinue;\r\nif (1 == a)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n} while (1);\r\n}\r\nstatic void jent_stir_pool(struct rand_data *entropy_collector)\r\n{\r\nunion c {\r\n__u64 u64;\r\n__u32 u32[2];\r\n};\r\nunion c constant;\r\nunion c mixer;\r\nunsigned int i = 0;\r\nconstant.u32[1] = 0x67452301;\r\nconstant.u32[0] = 0xefcdab89;\r\nmixer.u32[1] = 0x98badcfe;\r\nmixer.u32[0] = 0x10325476;\r\nfor (i = 0; i < DATA_SIZE_BITS; i++) {\r\nif ((entropy_collector->data >> i) & 1)\r\nmixer.u64 ^= constant.u64;\r\nmixer.u64 = jent_rol64(mixer.u64, 1);\r\n}\r\nentropy_collector->data ^= mixer.u64;\r\n}\r\nstatic void jent_gen_entropy(struct rand_data *ec)\r\n{\r\nunsigned int k = 0;\r\njent_measure_jitter(ec);\r\nwhile (1) {\r\n__u64 data = 0;\r\nif (ec->disable_unbias == 1)\r\ndata = jent_measure_jitter(ec);\r\nelse\r\ndata = jent_unbiased_bit(ec);\r\nif (ec->stuck) {\r\nec->data ^= data;\r\nec->stuck = 0;\r\ncontinue;\r\n}\r\nec->data ^= data;\r\nec->data ^= ((ec->data >> 63) & 1);\r\nec->data ^= ((ec->data >> 60) & 1);\r\nec->data ^= ((ec->data >> 55) & 1);\r\nec->data ^= ((ec->data >> 30) & 1);\r\nec->data ^= ((ec->data >> 27) & 1);\r\nec->data ^= ((ec->data >> 22) & 1);\r\nec->data = jent_rol64(ec->data, 1);\r\nif (++k >= (DATA_SIZE_BITS * ec->osr))\r\nbreak;\r\n}\r\nif (ec->stir)\r\njent_stir_pool(ec);\r\n}\r\nstatic void jent_fips_test(struct rand_data *ec)\r\n{\r\nif (!jent_fips_enabled())\r\nreturn;\r\nif (!ec->old_data) {\r\nec->old_data = ec->data;\r\njent_gen_entropy(ec);\r\n}\r\nif (ec->data == ec->old_data)\r\njent_panic("jitterentropy: Duplicate output detected\n");\r\nec->old_data = ec->data;\r\n}\r\nint jent_read_entropy(struct rand_data *ec, unsigned char *data,\r\nunsigned int len)\r\n{\r\nunsigned char *p = data;\r\nif (!ec)\r\nreturn -1;\r\nwhile (0 < len) {\r\nunsigned int tocopy;\r\njent_gen_entropy(ec);\r\njent_fips_test(ec);\r\nif ((DATA_SIZE_BITS / 8) < len)\r\ntocopy = (DATA_SIZE_BITS / 8);\r\nelse\r\ntocopy = len;\r\njent_memcpy(p, &ec->data, tocopy);\r\nlen -= tocopy;\r\np += tocopy;\r\n}\r\nreturn 0;\r\n}\r\nstruct rand_data *jent_entropy_collector_alloc(unsigned int osr,\r\nunsigned int flags)\r\n{\r\nstruct rand_data *entropy_collector;\r\nentropy_collector = jent_zalloc(sizeof(struct rand_data));\r\nif (!entropy_collector)\r\nreturn NULL;\r\nif (!(flags & JENT_DISABLE_MEMORY_ACCESS)) {\r\nentropy_collector->mem = jent_zalloc(JENT_MEMORY_SIZE);\r\nif (!entropy_collector->mem) {\r\njent_zfree(entropy_collector);\r\nreturn NULL;\r\n}\r\nentropy_collector->memblocksize = JENT_MEMORY_BLOCKSIZE;\r\nentropy_collector->memblocks = JENT_MEMORY_BLOCKS;\r\nentropy_collector->memaccessloops = JENT_MEMORY_ACCESSLOOPS;\r\n}\r\nif (0 == osr)\r\nosr = 1;\r\nentropy_collector->osr = osr;\r\nentropy_collector->stir = 1;\r\nif (flags & JENT_DISABLE_STIR)\r\nentropy_collector->stir = 0;\r\nif (flags & JENT_DISABLE_UNBIAS)\r\nentropy_collector->disable_unbias = 1;\r\njent_gen_entropy(entropy_collector);\r\nreturn entropy_collector;\r\n}\r\nvoid jent_entropy_collector_free(struct rand_data *entropy_collector)\r\n{\r\njent_zfree(entropy_collector->mem);\r\nentropy_collector->mem = NULL;\r\njent_zfree(entropy_collector);\r\nentropy_collector = NULL;\r\n}\r\nint jent_entropy_init(void)\r\n{\r\nint i;\r\n__u64 delta_sum = 0;\r\n__u64 old_delta = 0;\r\nint time_backwards = 0;\r\nint count_var = 0;\r\nint count_mod = 0;\r\n#define TESTLOOPCOUNT 300\r\n#define CLEARCACHE 100\r\nfor (i = 0; (TESTLOOPCOUNT + CLEARCACHE) > i; i++) {\r\n__u64 time = 0;\r\n__u64 time2 = 0;\r\n__u64 folded = 0;\r\n__u64 delta = 0;\r\nunsigned int lowdelta = 0;\r\njent_get_nstime(&time);\r\njent_fold_time(NULL, time, &folded, 1<<MIN_FOLD_LOOP_BIT);\r\njent_get_nstime(&time2);\r\nif (!time || !time2)\r\nreturn JENT_ENOTIME;\r\ndelta = time2 - time;\r\nif (!delta)\r\nreturn JENT_ECOARSETIME;\r\nif (CLEARCACHE > i)\r\ncontinue;\r\nif (!(time2 > time))\r\ntime_backwards++;\r\nlowdelta = time2 - time;\r\nif (!(lowdelta % 100))\r\ncount_mod++;\r\nif (i) {\r\nif (delta != old_delta)\r\ncount_var++;\r\nif (delta > old_delta)\r\ndelta_sum += (delta - old_delta);\r\nelse\r\ndelta_sum += (old_delta - delta);\r\n}\r\nold_delta = delta;\r\n}\r\nif (3 < time_backwards)\r\nreturn JENT_ENOMONOTONIC;\r\nif (!delta_sum)\r\nreturn JENT_EVARVAR;\r\nif (delta_sum <= 1)\r\nreturn JENT_EMINVARVAR;\r\nif ((TESTLOOPCOUNT/10 * 9) < count_mod)\r\nreturn JENT_ECOARSETIME;\r\nreturn 0;\r\n}
