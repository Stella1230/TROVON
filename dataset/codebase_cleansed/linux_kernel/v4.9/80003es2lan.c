static s32 e1000_init_phy_params_80003es2lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nif (hw->phy.media_type != e1000_media_type_copper) {\r\nphy->type = e1000_phy_none;\r\nreturn 0;\r\n} else {\r\nphy->ops.power_up = e1000_power_up_phy_copper;\r\nphy->ops.power_down = e1000_power_down_phy_copper_80003es2lan;\r\n}\r\nphy->addr = 1;\r\nphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\r\nphy->reset_delay_us = 100;\r\nphy->type = e1000_phy_gg82563;\r\nret_val = e1000e_get_phy_id(hw);\r\nif (phy->id != GG82563_E_PHY_ID)\r\nreturn -E1000_ERR_PHY;\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_init_nvm_params_80003es2lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = er32(EECD);\r\nu16 size;\r\nnvm->opcode_bits = 8;\r\nnvm->delay_usec = 1;\r\nswitch (nvm->override) {\r\ncase e1000_nvm_override_spi_large:\r\nnvm->page_size = 32;\r\nnvm->address_bits = 16;\r\nbreak;\r\ncase e1000_nvm_override_spi_small:\r\nnvm->page_size = 8;\r\nnvm->address_bits = 8;\r\nbreak;\r\ndefault:\r\nnvm->page_size = eecd & E1000_EECD_ADDR_BITS ? 32 : 8;\r\nnvm->address_bits = eecd & E1000_EECD_ADDR_BITS ? 16 : 8;\r\nbreak;\r\n}\r\nnvm->type = e1000_nvm_eeprom_spi;\r\nsize = (u16)((eecd & E1000_EECD_SIZE_EX_MASK) >>\r\nE1000_EECD_SIZE_EX_SHIFT);\r\nsize += NVM_WORD_SIZE_BASE_SHIFT;\r\nif (size > 14)\r\nsize = 14;\r\nnvm->word_size = BIT(size);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_init_mac_params_80003es2lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nswitch (hw->adapter->pdev->device) {\r\ncase E1000_DEV_ID_80003ES2LAN_SERDES_DPT:\r\nhw->phy.media_type = e1000_media_type_internal_serdes;\r\nmac->ops.check_for_link = e1000e_check_for_serdes_link;\r\nmac->ops.setup_physical_interface =\r\ne1000e_setup_fiber_serdes_link;\r\nbreak;\r\ndefault:\r\nhw->phy.media_type = e1000_media_type_copper;\r\nmac->ops.check_for_link = e1000e_check_for_copper_link;\r\nmac->ops.setup_physical_interface =\r\ne1000_setup_copper_link_80003es2lan;\r\nbreak;\r\n}\r\nmac->mta_reg_count = 128;\r\nmac->rar_entry_count = E1000_RAR_ENTRIES;\r\nmac->has_fwsm = true;\r\nmac->arc_subsystem_valid = !!(er32(FWSM) & E1000_FWSM_MODE_MASK);\r\nmac->adaptive_ifs = false;\r\nhw->mac.ops.set_lan_id(hw);\r\nreturn 0;\r\n}\r\nstatic s32 e1000_get_variants_80003es2lan(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\ns32 rc;\r\nrc = e1000_init_mac_params_80003es2lan(hw);\r\nif (rc)\r\nreturn rc;\r\nrc = e1000_init_nvm_params_80003es2lan(hw);\r\nif (rc)\r\nreturn rc;\r\nrc = e1000_init_phy_params_80003es2lan(hw);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_acquire_phy_80003es2lan(struct e1000_hw *hw)\r\n{\r\nu16 mask;\r\nmask = hw->bus.func ? E1000_SWFW_PHY1_SM : E1000_SWFW_PHY0_SM;\r\nreturn e1000_acquire_swfw_sync_80003es2lan(hw, mask);\r\n}\r\nstatic void e1000_release_phy_80003es2lan(struct e1000_hw *hw)\r\n{\r\nu16 mask;\r\nmask = hw->bus.func ? E1000_SWFW_PHY1_SM : E1000_SWFW_PHY0_SM;\r\ne1000_release_swfw_sync_80003es2lan(hw, mask);\r\n}\r\nstatic s32 e1000_acquire_mac_csr_80003es2lan(struct e1000_hw *hw)\r\n{\r\nu16 mask;\r\nmask = E1000_SWFW_CSR_SM;\r\nreturn e1000_acquire_swfw_sync_80003es2lan(hw, mask);\r\n}\r\nstatic void e1000_release_mac_csr_80003es2lan(struct e1000_hw *hw)\r\n{\r\nu16 mask;\r\nmask = E1000_SWFW_CSR_SM;\r\ne1000_release_swfw_sync_80003es2lan(hw, mask);\r\n}\r\nstatic s32 e1000_acquire_nvm_80003es2lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nret_val = e1000_acquire_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000e_acquire_nvm(hw);\r\nif (ret_val)\r\ne1000_release_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\r\nreturn ret_val;\r\n}\r\nstatic void e1000_release_nvm_80003es2lan(struct e1000_hw *hw)\r\n{\r\ne1000e_release_nvm(hw);\r\ne1000_release_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);\r\n}\r\nstatic s32 e1000_acquire_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask)\r\n{\r\nu32 swfw_sync;\r\nu32 swmask = mask;\r\nu32 fwmask = mask << 16;\r\ns32 i = 0;\r\ns32 timeout = 50;\r\nwhile (i < timeout) {\r\nif (e1000e_get_hw_semaphore(hw))\r\nreturn -E1000_ERR_SWFW_SYNC;\r\nswfw_sync = er32(SW_FW_SYNC);\r\nif (!(swfw_sync & (fwmask | swmask)))\r\nbreak;\r\ne1000e_put_hw_semaphore(hw);\r\nmdelay(5);\r\ni++;\r\n}\r\nif (i == timeout) {\r\ne_dbg("Driver can't access resource, SW_FW_SYNC timeout.\n");\r\nreturn -E1000_ERR_SWFW_SYNC;\r\n}\r\nswfw_sync |= swmask;\r\new32(SW_FW_SYNC, swfw_sync);\r\ne1000e_put_hw_semaphore(hw);\r\nreturn 0;\r\n}\r\nstatic void e1000_release_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask)\r\n{\r\nu32 swfw_sync;\r\nwhile (e1000e_get_hw_semaphore(hw) != 0)\r\n;\r\nswfw_sync = er32(SW_FW_SYNC);\r\nswfw_sync &= ~mask;\r\new32(SW_FW_SYNC, swfw_sync);\r\ne1000e_put_hw_semaphore(hw);\r\n}\r\nstatic s32 e1000_read_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw,\r\nu32 offset, u16 *data)\r\n{\r\ns32 ret_val;\r\nu32 page_select;\r\nu16 temp;\r\nret_val = e1000_acquire_phy_80003es2lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((offset & MAX_PHY_REG_ADDRESS) < GG82563_MIN_ALT_REG) {\r\npage_select = GG82563_PHY_PAGE_SELECT;\r\n} else {\r\npage_select = GG82563_PHY_PAGE_SELECT_ALT;\r\n}\r\ntemp = (u16)((u16)offset >> GG82563_PAGE_SHIFT);\r\nret_val = e1000e_write_phy_reg_mdic(hw, page_select, temp);\r\nif (ret_val) {\r\ne1000_release_phy_80003es2lan(hw);\r\nreturn ret_val;\r\n}\r\nif (hw->dev_spec.e80003es2lan.mdic_wa_enable) {\r\nusleep_range(200, 400);\r\nret_val = e1000e_read_phy_reg_mdic(hw, page_select, &temp);\r\nif (((u16)offset >> GG82563_PAGE_SHIFT) != temp) {\r\ne1000_release_phy_80003es2lan(hw);\r\nreturn -E1000_ERR_PHY;\r\n}\r\nusleep_range(200, 400);\r\nret_val = e1000e_read_phy_reg_mdic(hw,\r\nMAX_PHY_REG_ADDRESS & offset,\r\ndata);\r\nusleep_range(200, 400);\r\n} else {\r\nret_val = e1000e_read_phy_reg_mdic(hw,\r\nMAX_PHY_REG_ADDRESS & offset,\r\ndata);\r\n}\r\ne1000_release_phy_80003es2lan(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_write_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw,\r\nu32 offset, u16 data)\r\n{\r\ns32 ret_val;\r\nu32 page_select;\r\nu16 temp;\r\nret_val = e1000_acquire_phy_80003es2lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nif ((offset & MAX_PHY_REG_ADDRESS) < GG82563_MIN_ALT_REG) {\r\npage_select = GG82563_PHY_PAGE_SELECT;\r\n} else {\r\npage_select = GG82563_PHY_PAGE_SELECT_ALT;\r\n}\r\ntemp = (u16)((u16)offset >> GG82563_PAGE_SHIFT);\r\nret_val = e1000e_write_phy_reg_mdic(hw, page_select, temp);\r\nif (ret_val) {\r\ne1000_release_phy_80003es2lan(hw);\r\nreturn ret_val;\r\n}\r\nif (hw->dev_spec.e80003es2lan.mdic_wa_enable) {\r\nusleep_range(200, 400);\r\nret_val = e1000e_read_phy_reg_mdic(hw, page_select, &temp);\r\nif (((u16)offset >> GG82563_PAGE_SHIFT) != temp) {\r\ne1000_release_phy_80003es2lan(hw);\r\nreturn -E1000_ERR_PHY;\r\n}\r\nusleep_range(200, 400);\r\nret_val = e1000e_write_phy_reg_mdic(hw,\r\nMAX_PHY_REG_ADDRESS &\r\noffset, data);\r\nusleep_range(200, 400);\r\n} else {\r\nret_val = e1000e_write_phy_reg_mdic(hw,\r\nMAX_PHY_REG_ADDRESS &\r\noffset, data);\r\n}\r\ne1000_release_phy_80003es2lan(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_write_nvm_80003es2lan(struct e1000_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\nreturn e1000e_write_nvm_spi(hw, offset, words, data);\r\n}\r\nstatic s32 e1000_get_cfg_done_80003es2lan(struct e1000_hw *hw)\r\n{\r\ns32 timeout = PHY_CFG_TIMEOUT;\r\nu32 mask = E1000_NVM_CFG_DONE_PORT_0;\r\nif (hw->bus.func == 1)\r\nmask = E1000_NVM_CFG_DONE_PORT_1;\r\nwhile (timeout) {\r\nif (er32(EEMNGCTL) & mask)\r\nbreak;\r\nusleep_range(1000, 2000);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\ne_dbg("MNG configuration cycle has not completed.\n");\r\nreturn -E1000_ERR_RESET;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_phy_force_speed_duplex_80003es2lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 phy_data;\r\nbool link;\r\nret_val = e1e_rphy(hw, M88E1000_PHY_SPEC_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~GG82563_PSCR_CROSSOVER_MODE_AUTO;\r\nret_val = e1e_wphy(hw, GG82563_PHY_SPEC_CTRL, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\ne_dbg("GG82563 PSCR: %X\n", phy_data);\r\nret_val = e1e_rphy(hw, MII_BMCR, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\ne1000e_phy_force_speed_duplex_setup(hw, &phy_data);\r\nphy_data |= BMCR_RESET;\r\nret_val = e1e_wphy(hw, MII_BMCR, phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nudelay(1);\r\nif (hw->phy.autoneg_wait_to_complete) {\r\ne_dbg("Waiting for forced speed/duplex link on GG82563 phy.\n");\r\nret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\r\n100000, &link);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (!link) {\r\nret_val = e1000e_phy_reset_dsp(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = e1000e_phy_has_link_generic(hw, PHY_FORCE_LIMIT,\r\n100000, &link);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = e1e_rphy(hw, GG82563_PHY_MAC_SPEC_CTRL, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nphy_data &= ~GG82563_MSCR_TX_CLK_MASK;\r\nif (hw->mac.forced_speed_duplex & E1000_ALL_10_SPEED)\r\nphy_data |= GG82563_MSCR_TX_CLK_10MBPS_2_5;\r\nelse\r\nphy_data |= GG82563_MSCR_TX_CLK_100MBPS_25;\r\nphy_data |= GG82563_MSCR_ASSERT_CRS_ON_TX;\r\nret_val = e1e_wphy(hw, GG82563_PHY_MAC_SPEC_CTRL, phy_data);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_get_cable_length_80003es2lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nu16 phy_data, index;\r\nret_val = e1e_rphy(hw, GG82563_PHY_DSP_DISTANCE, &phy_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nindex = phy_data & GG82563_DSPD_CABLE_LENGTH;\r\nif (index >= GG82563_CABLE_LENGTH_TABLE_SIZE - 5)\r\nreturn -E1000_ERR_PHY;\r\nphy->min_cable_length = e1000_gg82563_cable_length_table[index];\r\nphy->max_cable_length = e1000_gg82563_cable_length_table[index + 5];\r\nphy->cable_length = (phy->min_cable_length + phy->max_cable_length) / 2;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_get_link_up_info_80003es2lan(struct e1000_hw *hw, u16 *speed,\r\nu16 *duplex)\r\n{\r\ns32 ret_val;\r\nif (hw->phy.media_type == e1000_media_type_copper) {\r\nret_val = e1000e_get_speed_and_duplex_copper(hw, speed, duplex);\r\nhw->phy.ops.cfg_on_link_up(hw);\r\n} else {\r\nret_val = e1000e_get_speed_and_duplex_fiber_serdes(hw,\r\nspeed,\r\nduplex);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_reset_hw_80003es2lan(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nu16 kum_reg_data;\r\nret_val = e1000e_disable_pcie_master(hw);\r\nif (ret_val)\r\ne_dbg("PCI-E Master disable polling has failed.\n");\r\ne_dbg("Masking off all interrupts\n");\r\new32(IMC, 0xffffffff);\r\new32(RCTL, 0);\r\new32(TCTL, E1000_TCTL_PSP);\r\ne1e_flush();\r\nusleep_range(10000, 20000);\r\nctrl = er32(CTRL);\r\nret_val = e1000_acquire_phy_80003es2lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\ne_dbg("Issuing a global reset to MAC\n");\r\new32(CTRL, ctrl | E1000_CTRL_RST);\r\ne1000_release_phy_80003es2lan(hw);\r\nret_val =\r\ne1000_read_kmrn_reg_80003es2lan(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\r\n&kum_reg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nkum_reg_data |= E1000_KMRNCTRLSTA_IBIST_DISABLE;\r\ne1000_write_kmrn_reg_80003es2lan(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\r\nkum_reg_data);\r\nret_val = e1000e_get_auto_rd_done(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\new32(IMC, 0xffffffff);\r\ner32(ICR);\r\nreturn e1000_check_alt_mac_addr_generic(hw);\r\n}\r\nstatic s32 e1000_init_hw_80003es2lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nu32 reg_data;\r\ns32 ret_val;\r\nu16 kum_reg_data;\r\nu16 i;\r\ne1000_initialize_hw_bits_80003es2lan(hw);\r\nret_val = mac->ops.id_led_init(hw);\r\nif (ret_val)\r\ne_dbg("Error initializing identification LED\n");\r\ne_dbg("Initializing the IEEE VLAN\n");\r\nmac->ops.clear_vfta(hw);\r\ne1000e_init_rx_addrs(hw, mac->rar_entry_count);\r\ne_dbg("Zeroing the MTA\n");\r\nfor (i = 0; i < mac->mta_reg_count; i++)\r\nE1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);\r\nret_val = mac->ops.setup_link(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\ne1000_read_kmrn_reg_80003es2lan(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\r\n&kum_reg_data);\r\nkum_reg_data |= E1000_KMRNCTRLSTA_IBIST_DISABLE;\r\ne1000_write_kmrn_reg_80003es2lan(hw, E1000_KMRNCTRLSTA_INBAND_PARAM,\r\nkum_reg_data);\r\nreg_data = er32(TXDCTL(0));\r\nreg_data = ((reg_data & ~E1000_TXDCTL_WTHRESH) |\r\nE1000_TXDCTL_FULL_TX_DESC_WB | E1000_TXDCTL_COUNT_DESC);\r\new32(TXDCTL(0), reg_data);\r\nreg_data = er32(TXDCTL(1));\r\nreg_data = ((reg_data & ~E1000_TXDCTL_WTHRESH) |\r\nE1000_TXDCTL_FULL_TX_DESC_WB | E1000_TXDCTL_COUNT_DESC);\r\new32(TXDCTL(1), reg_data);\r\nreg_data = er32(TCTL);\r\nreg_data |= E1000_TCTL_RTLC;\r\new32(TCTL, reg_data);\r\nreg_data = er32(TCTL_EXT);\r\nreg_data &= ~E1000_TCTL_EXT_GCEX_MASK;\r\nreg_data |= DEFAULT_TCTL_EXT_GCEX_80003ES2LAN;\r\new32(TCTL_EXT, reg_data);\r\nreg_data = er32(TIPG);\r\nreg_data &= ~E1000_TIPG_IPGT_MASK;\r\nreg_data |= DEFAULT_TIPG_IPGT_1000_80003ES2LAN;\r\new32(TIPG, reg_data);\r\nreg_data = E1000_READ_REG_ARRAY(hw, E1000_FFLT, 0x0001);\r\nreg_data &= ~0x00100000;\r\nE1000_WRITE_REG_ARRAY(hw, E1000_FFLT, 0x0001, reg_data);\r\nhw->dev_spec.e80003es2lan.mdic_wa_enable = true;\r\nret_val =\r\ne1000_read_kmrn_reg_80003es2lan(hw, E1000_KMRNCTRLSTA_OFFSET >>\r\nE1000_KMRNCTRLSTA_OFFSET_SHIFT, &i);\r\nif (!ret_val) {\r\nif ((i & E1000_KMRNCTRLSTA_OPMODE_MASK) ==\r\nE1000_KMRNCTRLSTA_OPMODE_INBAND_MDIO)\r\nhw->dev_spec.e80003es2lan.mdic_wa_enable = false;\r\n}\r\ne1000_clear_hw_cntrs_80003es2lan(hw);\r\nreturn ret_val;\r\n}\r\nstatic void e1000_initialize_hw_bits_80003es2lan(struct e1000_hw *hw)\r\n{\r\nu32 reg;\r\nreg = er32(TXDCTL(0));\r\nreg |= BIT(22);\r\new32(TXDCTL(0), reg);\r\nreg = er32(TXDCTL(1));\r\nreg |= BIT(22);\r\new32(TXDCTL(1), reg);\r\nreg = er32(TARC(0));\r\nreg &= ~(0xF << 27);\r\nif (hw->phy.media_type != e1000_media_type_copper)\r\nreg &= ~BIT(20);\r\new32(TARC(0), reg);\r\nreg = er32(TARC(1));\r\nif (er32(TCTL) & E1000_TCTL_MULR)\r\nreg &= ~BIT(28);\r\nelse\r\nreg |= BIT(28);\r\new32(TARC(1), reg);\r\nreg = er32(RFCTL);\r\nreg |= (E1000_RFCTL_IPV6_EX_DIS | E1000_RFCTL_NEW_IPV6_EXT_DIS);\r\new32(RFCTL, reg);\r\n}\r\nstatic s32 e1000_copper_link_setup_gg82563_80003es2lan(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nu32 reg;\r\nu16 data;\r\nret_val = e1e_rphy(hw, GG82563_PHY_MAC_SPEC_CTRL, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata |= GG82563_MSCR_ASSERT_CRS_ON_TX;\r\ndata |= GG82563_MSCR_TX_CLK_1000MBPS_25;\r\nret_val = e1e_wphy(hw, GG82563_PHY_MAC_SPEC_CTRL, data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1e_rphy(hw, GG82563_PHY_SPEC_CTRL, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata &= ~GG82563_PSCR_CROSSOVER_MODE_MASK;\r\nswitch (phy->mdix) {\r\ncase 1:\r\ndata |= GG82563_PSCR_CROSSOVER_MODE_MDI;\r\nbreak;\r\ncase 2:\r\ndata |= GG82563_PSCR_CROSSOVER_MODE_MDIX;\r\nbreak;\r\ncase 0:\r\ndefault:\r\ndata |= GG82563_PSCR_CROSSOVER_MODE_AUTO;\r\nbreak;\r\n}\r\ndata &= ~GG82563_PSCR_POLARITY_REVERSAL_DISABLE;\r\nif (phy->disable_polarity_correction)\r\ndata |= GG82563_PSCR_POLARITY_REVERSAL_DISABLE;\r\nret_val = e1e_wphy(hw, GG82563_PHY_SPEC_CTRL, data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = hw->phy.ops.commit(hw);\r\nif (ret_val) {\r\ne_dbg("Error Resetting the PHY\n");\r\nreturn ret_val;\r\n}\r\nreg = E1000_KMRNCTRLSTA_OFFSET_FIFO_CTRL;\r\ndata = (E1000_KMRNCTRLSTA_FIFO_CTRL_RX_BYPASS |\r\nE1000_KMRNCTRLSTA_FIFO_CTRL_TX_BYPASS);\r\nret_val = e1000_write_kmrn_reg_80003es2lan(hw, reg, data);\r\nif (ret_val)\r\nreturn ret_val;\r\nreg = E1000_KMRNCTRLSTA_OFFSET_MAC2PHY_OPMODE;\r\nret_val = e1000_read_kmrn_reg_80003es2lan(hw, reg, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata |= E1000_KMRNCTRLSTA_OPMODE_E_IDLE;\r\nret_val = e1000_write_kmrn_reg_80003es2lan(hw, reg, data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1e_rphy(hw, GG82563_PHY_SPEC_CTRL_2, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata &= ~GG82563_PSCR2_REVERSE_AUTO_NEG;\r\nret_val = e1e_wphy(hw, GG82563_PHY_SPEC_CTRL_2, data);\r\nif (ret_val)\r\nreturn ret_val;\r\nreg = er32(CTRL_EXT);\r\nreg &= ~E1000_CTRL_EXT_LINK_MODE_MASK;\r\new32(CTRL_EXT, reg);\r\nret_val = e1e_rphy(hw, GG82563_PHY_PWR_MGMT_CTRL, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (!hw->mac.ops.check_mng_mode(hw)) {\r\ndata |= GG82563_PMCR_ENABLE_ELECTRICAL_IDLE;\r\nret_val = e1e_wphy(hw, GG82563_PHY_PWR_MGMT_CTRL, data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata &= ~GG82563_KMCR_PASS_FALSE_CARRIER;\r\nret_val = e1e_wphy(hw, GG82563_PHY_KMRN_MODE_CTRL, data);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = e1e_rphy(hw, GG82563_PHY_INBAND_CTRL, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\ndata |= GG82563_ICR_DIS_PADDING;\r\nret_val = e1e_wphy(hw, GG82563_PHY_INBAND_CTRL, data);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn 0;\r\n}\r\nstatic s32 e1000_setup_copper_link_80003es2lan(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nu16 reg_data;\r\nctrl = er32(CTRL);\r\nctrl |= E1000_CTRL_SLU;\r\nctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\r\new32(CTRL, ctrl);\r\nret_val = e1000_write_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 4),\r\n0xFFFF);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_read_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 9),\r\n&reg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nreg_data |= 0x3F;\r\nret_val = e1000_write_kmrn_reg_80003es2lan(hw, GG82563_REG(0x34, 9),\r\nreg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val =\r\ne1000_read_kmrn_reg_80003es2lan(hw,\r\nE1000_KMRNCTRLSTA_OFFSET_INB_CTRL,\r\n&reg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nreg_data |= E1000_KMRNCTRLSTA_INB_CTRL_DIS_PADDING;\r\nret_val =\r\ne1000_write_kmrn_reg_80003es2lan(hw,\r\nE1000_KMRNCTRLSTA_OFFSET_INB_CTRL,\r\nreg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_copper_link_setup_gg82563_80003es2lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn e1000e_setup_copper_link(hw);\r\n}\r\nstatic s32 e1000_cfg_on_link_up_80003es2lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 speed;\r\nu16 duplex;\r\nif (hw->phy.media_type == e1000_media_type_copper) {\r\nret_val = e1000e_get_speed_and_duplex_copper(hw, &speed,\r\n&duplex);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (speed == SPEED_1000)\r\nret_val = e1000_cfg_kmrn_1000_80003es2lan(hw);\r\nelse\r\nret_val = e1000_cfg_kmrn_10_100_80003es2lan(hw, duplex);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_cfg_kmrn_10_100_80003es2lan(struct e1000_hw *hw, u16 duplex)\r\n{\r\ns32 ret_val;\r\nu32 tipg;\r\nu32 i = 0;\r\nu16 reg_data, reg_data2;\r\nreg_data = E1000_KMRNCTRLSTA_HD_CTRL_10_100_DEFAULT;\r\nret_val =\r\ne1000_write_kmrn_reg_80003es2lan(hw,\r\nE1000_KMRNCTRLSTA_OFFSET_HD_CTRL,\r\nreg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\ntipg = er32(TIPG);\r\ntipg &= ~E1000_TIPG_IPGT_MASK;\r\ntipg |= DEFAULT_TIPG_IPGT_10_100_80003ES2LAN;\r\new32(TIPG, tipg);\r\ndo {\r\nret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data2);\r\nif (ret_val)\r\nreturn ret_val;\r\ni++;\r\n} while ((reg_data != reg_data2) && (i < GG82563_MAX_KMRN_RETRY));\r\nif (duplex == HALF_DUPLEX)\r\nreg_data |= GG82563_KMCR_PASS_FALSE_CARRIER;\r\nelse\r\nreg_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;\r\nreturn e1e_wphy(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);\r\n}\r\nstatic s32 e1000_cfg_kmrn_1000_80003es2lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 reg_data, reg_data2;\r\nu32 tipg;\r\nu32 i = 0;\r\nreg_data = E1000_KMRNCTRLSTA_HD_CTRL_1000_DEFAULT;\r\nret_val =\r\ne1000_write_kmrn_reg_80003es2lan(hw,\r\nE1000_KMRNCTRLSTA_OFFSET_HD_CTRL,\r\nreg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\ntipg = er32(TIPG);\r\ntipg &= ~E1000_TIPG_IPGT_MASK;\r\ntipg |= DEFAULT_TIPG_IPGT_1000_80003ES2LAN;\r\new32(TIPG, tipg);\r\ndo {\r\nret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1e_rphy(hw, GG82563_PHY_KMRN_MODE_CTRL, &reg_data2);\r\nif (ret_val)\r\nreturn ret_val;\r\ni++;\r\n} while ((reg_data != reg_data2) && (i < GG82563_MAX_KMRN_RETRY));\r\nreg_data &= ~GG82563_KMCR_PASS_FALSE_CARRIER;\r\nreturn e1e_wphy(hw, GG82563_PHY_KMRN_MODE_CTRL, reg_data);\r\n}\r\nstatic s32 e1000_read_kmrn_reg_80003es2lan(struct e1000_hw *hw, u32 offset,\r\nu16 *data)\r\n{\r\nu32 kmrnctrlsta;\r\ns32 ret_val;\r\nret_val = e1000_acquire_mac_csr_80003es2lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nkmrnctrlsta = ((offset << E1000_KMRNCTRLSTA_OFFSET_SHIFT) &\r\nE1000_KMRNCTRLSTA_OFFSET) | E1000_KMRNCTRLSTA_REN;\r\new32(KMRNCTRLSTA, kmrnctrlsta);\r\ne1e_flush();\r\nudelay(2);\r\nkmrnctrlsta = er32(KMRNCTRLSTA);\r\n*data = (u16)kmrnctrlsta;\r\ne1000_release_mac_csr_80003es2lan(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_write_kmrn_reg_80003es2lan(struct e1000_hw *hw, u32 offset,\r\nu16 data)\r\n{\r\nu32 kmrnctrlsta;\r\ns32 ret_val;\r\nret_val = e1000_acquire_mac_csr_80003es2lan(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nkmrnctrlsta = ((offset << E1000_KMRNCTRLSTA_OFFSET_SHIFT) &\r\nE1000_KMRNCTRLSTA_OFFSET) | data;\r\new32(KMRNCTRLSTA, kmrnctrlsta);\r\ne1e_flush();\r\nudelay(2);\r\ne1000_release_mac_csr_80003es2lan(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 e1000_read_mac_addr_80003es2lan(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nret_val = e1000_check_alt_mac_addr_generic(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn e1000_read_mac_addr_generic(hw);\r\n}\r\nstatic void e1000_power_down_phy_copper_80003es2lan(struct e1000_hw *hw)\r\n{\r\nif (!(hw->mac.ops.check_mng_mode(hw) ||\r\nhw->phy.ops.check_reset_block(hw)))\r\ne1000_power_down_phy_copper(hw);\r\n}\r\nstatic void e1000_clear_hw_cntrs_80003es2lan(struct e1000_hw *hw)\r\n{\r\ne1000e_clear_hw_cntrs_base(hw);\r\ner32(PRC64);\r\ner32(PRC127);\r\ner32(PRC255);\r\ner32(PRC511);\r\ner32(PRC1023);\r\ner32(PRC1522);\r\ner32(PTC64);\r\ner32(PTC127);\r\ner32(PTC255);\r\ner32(PTC511);\r\ner32(PTC1023);\r\ner32(PTC1522);\r\ner32(ALGNERRC);\r\ner32(RXERRC);\r\ner32(TNCRS);\r\ner32(CEXTERR);\r\ner32(TSCTC);\r\ner32(TSCTFC);\r\ner32(MGTPRC);\r\ner32(MGTPDC);\r\ner32(MGTPTC);\r\ner32(IAC);\r\ner32(ICRXOC);\r\ner32(ICRXPTC);\r\ner32(ICRXATC);\r\ner32(ICTXPTC);\r\ner32(ICTXATC);\r\ner32(ICTXQEC);\r\ner32(ICTXQMTC);\r\ner32(ICRXDMTC);\r\n}
