int\r\nsnd_seq_oss_midi_lookup_ports(int client)\r\n{\r\nstruct snd_seq_client_info *clinfo;\r\nstruct snd_seq_port_info *pinfo;\r\nclinfo = kzalloc(sizeof(*clinfo), GFP_KERNEL);\r\npinfo = kzalloc(sizeof(*pinfo), GFP_KERNEL);\r\nif (! clinfo || ! pinfo) {\r\nkfree(clinfo);\r\nkfree(pinfo);\r\nreturn -ENOMEM;\r\n}\r\nclinfo->client = -1;\r\nwhile (snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT, clinfo) == 0) {\r\nif (clinfo->client == client)\r\ncontinue;\r\npinfo->addr.client = clinfo->client;\r\npinfo->addr.port = -1;\r\nwhile (snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT, pinfo) == 0)\r\nsnd_seq_oss_midi_check_new_port(pinfo);\r\n}\r\nkfree(clinfo);\r\nkfree(pinfo);\r\nreturn 0;\r\n}\r\nstatic struct seq_oss_midi *\r\nget_mdev(int dev)\r\n{\r\nstruct seq_oss_midi *mdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&register_lock, flags);\r\nmdev = midi_devs[dev];\r\nif (mdev)\r\nsnd_use_lock_use(&mdev->use_lock);\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nreturn mdev;\r\n}\r\nstatic struct seq_oss_midi *\r\nfind_slot(int client, int port)\r\n{\r\nint i;\r\nstruct seq_oss_midi *mdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&register_lock, flags);\r\nfor (i = 0; i < max_midi_devs; i++) {\r\nmdev = midi_devs[i];\r\nif (mdev && mdev->client == client && mdev->port == port) {\r\nsnd_use_lock_use(&mdev->use_lock);\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nreturn mdev;\r\n}\r\n}\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nreturn NULL;\r\n}\r\nint\r\nsnd_seq_oss_midi_check_new_port(struct snd_seq_port_info *pinfo)\r\n{\r\nint i;\r\nstruct seq_oss_midi *mdev;\r\nunsigned long flags;\r\nif (! (pinfo->type & SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC))\r\nreturn 0;\r\nif ((pinfo->capability & PERM_WRITE) != PERM_WRITE &&\r\n(pinfo->capability & PERM_READ) != PERM_READ)\r\nreturn 0;\r\nif ((mdev = find_slot(pinfo->addr.client, pinfo->addr.port)) != NULL) {\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn 0;\r\n}\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nmdev->client = pinfo->addr.client;\r\nmdev->port = pinfo->addr.port;\r\nmdev->flags = pinfo->capability;\r\nmdev->opened = 0;\r\nsnd_use_lock_init(&mdev->use_lock);\r\nstrlcpy(mdev->name, pinfo->name, sizeof(mdev->name));\r\nif (snd_midi_event_new(MAX_MIDI_EVENT_BUF, &mdev->coder) < 0) {\r\npr_err("ALSA: seq_oss: can't malloc midi coder\n");\r\nkfree(mdev);\r\nreturn -ENOMEM;\r\n}\r\nsnd_midi_event_no_status(mdev->coder, 1);\r\nspin_lock_irqsave(&register_lock, flags);\r\nfor (i = 0; i < max_midi_devs; i++) {\r\nif (midi_devs[i] == NULL)\r\nbreak;\r\n}\r\nif (i >= max_midi_devs) {\r\nif (max_midi_devs >= SNDRV_SEQ_OSS_MAX_MIDI_DEVS) {\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nsnd_midi_event_free(mdev->coder);\r\nkfree(mdev);\r\nreturn -ENOMEM;\r\n}\r\nmax_midi_devs++;\r\n}\r\nmdev->seq_device = i;\r\nmidi_devs[mdev->seq_device] = mdev;\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_midi_check_exit_port(int client, int port)\r\n{\r\nstruct seq_oss_midi *mdev;\r\nunsigned long flags;\r\nint index;\r\nif ((mdev = find_slot(client, port)) != NULL) {\r\nspin_lock_irqsave(&register_lock, flags);\r\nmidi_devs[mdev->seq_device] = NULL;\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nsnd_use_lock_free(&mdev->use_lock);\r\nsnd_use_lock_sync(&mdev->use_lock);\r\nsnd_midi_event_free(mdev->coder);\r\nkfree(mdev);\r\n}\r\nspin_lock_irqsave(&register_lock, flags);\r\nfor (index = max_midi_devs - 1; index >= 0; index--) {\r\nif (midi_devs[index])\r\nbreak;\r\n}\r\nmax_midi_devs = index + 1;\r\nspin_unlock_irqrestore(&register_lock, flags);\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_seq_oss_midi_clear_all(void)\r\n{\r\nint i;\r\nstruct seq_oss_midi *mdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&register_lock, flags);\r\nfor (i = 0; i < max_midi_devs; i++) {\r\nif ((mdev = midi_devs[i]) != NULL) {\r\nsnd_midi_event_free(mdev->coder);\r\nkfree(mdev);\r\nmidi_devs[i] = NULL;\r\n}\r\n}\r\nmax_midi_devs = 0;\r\nspin_unlock_irqrestore(&register_lock, flags);\r\n}\r\nvoid\r\nsnd_seq_oss_midi_setup(struct seq_oss_devinfo *dp)\r\n{\r\ndp->max_mididev = max_midi_devs;\r\n}\r\nvoid\r\nsnd_seq_oss_midi_cleanup(struct seq_oss_devinfo *dp)\r\n{\r\nint i;\r\nfor (i = 0; i < dp->max_mididev; i++)\r\nsnd_seq_oss_midi_close(dp, i);\r\ndp->max_mididev = 0;\r\n}\r\nvoid\r\nsnd_seq_oss_midi_open_all(struct seq_oss_devinfo *dp, int file_mode)\r\n{\r\nint i;\r\nfor (i = 0; i < dp->max_mididev; i++)\r\nsnd_seq_oss_midi_open(dp, i, file_mode);\r\n}\r\nstatic struct seq_oss_midi *\r\nget_mididev(struct seq_oss_devinfo *dp, int dev)\r\n{\r\nif (dev < 0 || dev >= dp->max_mididev)\r\nreturn NULL;\r\nreturn get_mdev(dev);\r\n}\r\nint\r\nsnd_seq_oss_midi_open(struct seq_oss_devinfo *dp, int dev, int fmode)\r\n{\r\nint perm;\r\nstruct seq_oss_midi *mdev;\r\nstruct snd_seq_port_subscribe subs;\r\nif ((mdev = get_mididev(dp, dev)) == NULL)\r\nreturn -ENODEV;\r\nif (mdev->opened && mdev->devinfo != dp) {\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn -EBUSY;\r\n}\r\nperm = 0;\r\nif (is_write_mode(fmode))\r\nperm |= PERM_WRITE;\r\nif (is_read_mode(fmode))\r\nperm |= PERM_READ;\r\nperm &= mdev->flags;\r\nif (perm == 0) {\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn -ENXIO;\r\n}\r\nif ((mdev->opened & perm) == perm) {\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn 0;\r\n}\r\nperm &= ~mdev->opened;\r\nmemset(&subs, 0, sizeof(subs));\r\nif (perm & PERM_WRITE) {\r\nsubs.sender = dp->addr;\r\nsubs.dest.client = mdev->client;\r\nsubs.dest.port = mdev->port;\r\nif (snd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs) >= 0)\r\nmdev->opened |= PERM_WRITE;\r\n}\r\nif (perm & PERM_READ) {\r\nsubs.sender.client = mdev->client;\r\nsubs.sender.port = mdev->port;\r\nsubs.dest = dp->addr;\r\nsubs.flags = SNDRV_SEQ_PORT_SUBS_TIMESTAMP;\r\nsubs.queue = dp->queue;\r\nif (snd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT, &subs) >= 0)\r\nmdev->opened |= PERM_READ;\r\n}\r\nif (! mdev->opened) {\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn -ENXIO;\r\n}\r\nmdev->devinfo = dp;\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_midi_close(struct seq_oss_devinfo *dp, int dev)\r\n{\r\nstruct seq_oss_midi *mdev;\r\nstruct snd_seq_port_subscribe subs;\r\nif ((mdev = get_mididev(dp, dev)) == NULL)\r\nreturn -ENODEV;\r\nif (! mdev->opened || mdev->devinfo != dp) {\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn 0;\r\n}\r\nmemset(&subs, 0, sizeof(subs));\r\nif (mdev->opened & PERM_WRITE) {\r\nsubs.sender = dp->addr;\r\nsubs.dest.client = mdev->client;\r\nsubs.dest.port = mdev->port;\r\nsnd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, &subs);\r\n}\r\nif (mdev->opened & PERM_READ) {\r\nsubs.sender.client = mdev->client;\r\nsubs.sender.port = mdev->port;\r\nsubs.dest = dp->addr;\r\nsnd_seq_kernel_client_ctl(dp->cseq, SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT, &subs);\r\n}\r\nmdev->opened = 0;\r\nmdev->devinfo = NULL;\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_midi_filemode(struct seq_oss_devinfo *dp, int dev)\r\n{\r\nstruct seq_oss_midi *mdev;\r\nint mode;\r\nif ((mdev = get_mididev(dp, dev)) == NULL)\r\nreturn 0;\r\nmode = 0;\r\nif (mdev->opened & PERM_WRITE)\r\nmode |= SNDRV_SEQ_OSS_FILE_WRITE;\r\nif (mdev->opened & PERM_READ)\r\nmode |= SNDRV_SEQ_OSS_FILE_READ;\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn mode;\r\n}\r\nvoid\r\nsnd_seq_oss_midi_reset(struct seq_oss_devinfo *dp, int dev)\r\n{\r\nstruct seq_oss_midi *mdev;\r\nif ((mdev = get_mididev(dp, dev)) == NULL)\r\nreturn;\r\nif (! mdev->opened) {\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn;\r\n}\r\nif (mdev->opened & PERM_WRITE) {\r\nstruct snd_seq_event ev;\r\nint c;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.dest.client = mdev->client;\r\nev.dest.port = mdev->port;\r\nev.queue = dp->queue;\r\nev.source.port = dp->port;\r\nif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_SYNTH) {\r\nev.type = SNDRV_SEQ_EVENT_SENSING;\r\nsnd_seq_oss_dispatch(dp, &ev, 0, 0);\r\n}\r\nfor (c = 0; c < 16; c++) {\r\nev.type = SNDRV_SEQ_EVENT_CONTROLLER;\r\nev.data.control.channel = c;\r\nev.data.control.param = MIDI_CTL_ALL_NOTES_OFF;\r\nsnd_seq_oss_dispatch(dp, &ev, 0, 0);\r\nif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC) {\r\nev.data.control.param =\r\nMIDI_CTL_RESET_CONTROLLERS;\r\nsnd_seq_oss_dispatch(dp, &ev, 0, 0);\r\nev.type = SNDRV_SEQ_EVENT_PITCHBEND;\r\nev.data.control.value = 0;\r\nsnd_seq_oss_dispatch(dp, &ev, 0, 0);\r\n}\r\n}\r\n}\r\nsnd_use_lock_free(&mdev->use_lock);\r\n}\r\nvoid\r\nsnd_seq_oss_midi_get_addr(struct seq_oss_devinfo *dp, int dev, struct snd_seq_addr *addr)\r\n{\r\nstruct seq_oss_midi *mdev;\r\nif ((mdev = get_mididev(dp, dev)) == NULL)\r\nreturn;\r\naddr->client = mdev->client;\r\naddr->port = mdev->port;\r\nsnd_use_lock_free(&mdev->use_lock);\r\n}\r\nint\r\nsnd_seq_oss_midi_input(struct snd_seq_event *ev, int direct, void *private_data)\r\n{\r\nstruct seq_oss_devinfo *dp = (struct seq_oss_devinfo *)private_data;\r\nstruct seq_oss_midi *mdev;\r\nint rc;\r\nif (dp->readq == NULL)\r\nreturn 0;\r\nif ((mdev = find_slot(ev->source.client, ev->source.port)) == NULL)\r\nreturn 0;\r\nif (! (mdev->opened & PERM_READ)) {\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn 0;\r\n}\r\nif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC)\r\nrc = send_synth_event(dp, ev, mdev->seq_device);\r\nelse\r\nrc = send_midi_event(dp, ev, mdev);\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nsend_synth_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, int dev)\r\n{\r\nunion evrec ossev;\r\nmemset(&ossev, 0, sizeof(ossev));\r\nswitch (ev->type) {\r\ncase SNDRV_SEQ_EVENT_NOTEON:\r\nossev.v.cmd = MIDI_NOTEON; break;\r\ncase SNDRV_SEQ_EVENT_NOTEOFF:\r\nossev.v.cmd = MIDI_NOTEOFF; break;\r\ncase SNDRV_SEQ_EVENT_KEYPRESS:\r\nossev.v.cmd = MIDI_KEY_PRESSURE; break;\r\ncase SNDRV_SEQ_EVENT_CONTROLLER:\r\nossev.l.cmd = MIDI_CTL_CHANGE; break;\r\ncase SNDRV_SEQ_EVENT_PGMCHANGE:\r\nossev.l.cmd = MIDI_PGM_CHANGE; break;\r\ncase SNDRV_SEQ_EVENT_CHANPRESS:\r\nossev.l.cmd = MIDI_CHN_PRESSURE; break;\r\ncase SNDRV_SEQ_EVENT_PITCHBEND:\r\nossev.l.cmd = MIDI_PITCH_BEND; break;\r\ndefault:\r\nreturn 0;\r\n}\r\nossev.v.dev = dev;\r\nswitch (ev->type) {\r\ncase SNDRV_SEQ_EVENT_NOTEON:\r\ncase SNDRV_SEQ_EVENT_NOTEOFF:\r\ncase SNDRV_SEQ_EVENT_KEYPRESS:\r\nossev.v.code = EV_CHN_VOICE;\r\nossev.v.note = ev->data.note.note;\r\nossev.v.parm = ev->data.note.velocity;\r\nossev.v.chn = ev->data.note.channel;\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_CONTROLLER:\r\ncase SNDRV_SEQ_EVENT_PGMCHANGE:\r\ncase SNDRV_SEQ_EVENT_CHANPRESS:\r\nossev.l.code = EV_CHN_COMMON;\r\nossev.l.p1 = ev->data.control.param;\r\nossev.l.val = ev->data.control.value;\r\nossev.l.chn = ev->data.control.channel;\r\nbreak;\r\ncase SNDRV_SEQ_EVENT_PITCHBEND:\r\nossev.l.code = EV_CHN_COMMON;\r\nossev.l.val = ev->data.control.value + 8192;\r\nossev.l.chn = ev->data.control.channel;\r\nbreak;\r\n}\r\nsnd_seq_oss_readq_put_timestamp(dp->readq, ev->time.tick, dp->seq_mode);\r\nsnd_seq_oss_readq_put_event(dp->readq, &ossev);\r\nreturn 0;\r\n}\r\nstatic int\r\nsend_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq_oss_midi *mdev)\r\n{\r\nchar msg[32];\r\nint len;\r\nsnd_seq_oss_readq_put_timestamp(dp->readq, ev->time.tick, dp->seq_mode);\r\nif (!dp->timer->running)\r\nlen = snd_seq_oss_timer_start(dp->timer);\r\nif (ev->type == SNDRV_SEQ_EVENT_SYSEX) {\r\nif ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) == SNDRV_SEQ_EVENT_LENGTH_VARIABLE)\r\nsnd_seq_oss_readq_puts(dp->readq, mdev->seq_device,\r\nev->data.ext.ptr, ev->data.ext.len);\r\n} else {\r\nlen = snd_midi_event_decode(mdev->coder, msg, sizeof(msg), ev);\r\nif (len > 0)\r\nsnd_seq_oss_readq_puts(dp->readq, mdev->seq_device, msg, len);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nsnd_seq_oss_midi_putc(struct seq_oss_devinfo *dp, int dev, unsigned char c, struct snd_seq_event *ev)\r\n{\r\nstruct seq_oss_midi *mdev;\r\nif ((mdev = get_mididev(dp, dev)) == NULL)\r\nreturn -ENODEV;\r\nif (snd_midi_event_encode_byte(mdev->coder, c, ev) > 0) {\r\nsnd_seq_oss_fill_addr(dp, ev, mdev->client, mdev->port);\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn 0;\r\n}\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn -EINVAL;\r\n}\r\nint\r\nsnd_seq_oss_midi_make_info(struct seq_oss_devinfo *dp, int dev, struct midi_info *inf)\r\n{\r\nstruct seq_oss_midi *mdev;\r\nif ((mdev = get_mididev(dp, dev)) == NULL)\r\nreturn -ENXIO;\r\ninf->device = dev;\r\ninf->dev_type = 0;\r\ninf->capabilities = 0;\r\nstrlcpy(inf->name, mdev->name, sizeof(inf->name));\r\nsnd_use_lock_free(&mdev->use_lock);\r\nreturn 0;\r\n}\r\nstatic char *\r\ncapmode_str(int val)\r\n{\r\nval &= PERM_READ|PERM_WRITE;\r\nif (val == (PERM_READ|PERM_WRITE))\r\nreturn "read/write";\r\nelse if (val == PERM_READ)\r\nreturn "read";\r\nelse if (val == PERM_WRITE)\r\nreturn "write";\r\nelse\r\nreturn "none";\r\n}\r\nvoid\r\nsnd_seq_oss_midi_info_read(struct snd_info_buffer *buf)\r\n{\r\nint i;\r\nstruct seq_oss_midi *mdev;\r\nsnd_iprintf(buf, "\nNumber of MIDI devices: %d\n", max_midi_devs);\r\nfor (i = 0; i < max_midi_devs; i++) {\r\nsnd_iprintf(buf, "\nmidi %d: ", i);\r\nmdev = get_mdev(i);\r\nif (mdev == NULL) {\r\nsnd_iprintf(buf, "*empty*\n");\r\ncontinue;\r\n}\r\nsnd_iprintf(buf, "[%s] ALSA port %d:%d\n", mdev->name,\r\nmdev->client, mdev->port);\r\nsnd_iprintf(buf, " capability %s / opened %s\n",\r\ncapmode_str(mdev->flags),\r\ncapmode_str(mdev->opened));\r\nsnd_use_lock_free(&mdev->use_lock);\r\n}\r\n}
