static void omap_wdt_reload(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\nwhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x08)\r\ncpu_relax();\r\nwdev->wdt_trgr_pattern = ~wdev->wdt_trgr_pattern;\r\nwritel_relaxed(wdev->wdt_trgr_pattern, (base + OMAP_WATCHDOG_TGR));\r\nwhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x08)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_enable(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\nwritel_relaxed(0xBBBB, base + OMAP_WATCHDOG_SPR);\r\nwhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x10)\r\ncpu_relax();\r\nwritel_relaxed(0x4444, base + OMAP_WATCHDOG_SPR);\r\nwhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x10)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_disable(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\nwritel_relaxed(0xAAAA, base + OMAP_WATCHDOG_SPR);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x10)\r\ncpu_relax();\r\nwritel_relaxed(0x5555, base + OMAP_WATCHDOG_SPR);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x10)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_set_timer(struct omap_wdt_dev *wdev,\r\nunsigned int timeout)\r\n{\r\nu32 pre_margin = GET_WLDR_VAL(timeout);\r\nvoid __iomem *base = wdev->base;\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x04)\r\ncpu_relax();\r\nwritel_relaxed(pre_margin, base + OMAP_WATCHDOG_LDR);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x04)\r\ncpu_relax();\r\n}\r\nstatic int omap_wdt_start(struct watchdog_device *wdog)\r\n{\r\nstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\r\nvoid __iomem *base = wdev->base;\r\nmutex_lock(&wdev->lock);\r\nwdev->omap_wdt_users = true;\r\npm_runtime_get_sync(wdev->dev);\r\nomap_wdt_disable(wdev);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x01)\r\ncpu_relax();\r\nwritel_relaxed((1 << 5) | (PTV << 2), base + OMAP_WATCHDOG_CNTRL);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x01)\r\ncpu_relax();\r\nomap_wdt_set_timer(wdev, wdog->timeout);\r\nomap_wdt_reload(wdev);\r\nomap_wdt_enable(wdev);\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_stop(struct watchdog_device *wdog)\r\n{\r\nstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\r\nmutex_lock(&wdev->lock);\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\nwdev->omap_wdt_users = false;\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_ping(struct watchdog_device *wdog)\r\n{\r\nstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\r\nmutex_lock(&wdev->lock);\r\nomap_wdt_reload(wdev);\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_set_timeout(struct watchdog_device *wdog,\r\nunsigned int timeout)\r\n{\r\nstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\r\nmutex_lock(&wdev->lock);\r\nomap_wdt_disable(wdev);\r\nomap_wdt_set_timer(wdev, timeout);\r\nomap_wdt_enable(wdev);\r\nomap_wdt_reload(wdev);\r\nwdog->timeout = timeout;\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int omap_wdt_get_timeleft(struct watchdog_device *wdog)\r\n{\r\nstruct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);\r\nvoid __iomem *base = wdev->base;\r\nu32 value;\r\nvalue = readl_relaxed(base + OMAP_WATCHDOG_CRR);\r\nreturn GET_WCCR_SECS(value);\r\n}\r\nstatic int omap_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_wd_timer_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct resource *res;\r\nstruct omap_wdt_dev *wdev;\r\nint ret;\r\nwdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);\r\nif (!wdev)\r\nreturn -ENOMEM;\r\nwdev->omap_wdt_users = false;\r\nwdev->dev = &pdev->dev;\r\nwdev->wdt_trgr_pattern = 0x1234;\r\nmutex_init(&wdev->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdev->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(wdev->base))\r\nreturn PTR_ERR(wdev->base);\r\nwdev->wdog.info = &omap_wdt_info;\r\nwdev->wdog.ops = &omap_wdt_ops;\r\nwdev->wdog.min_timeout = TIMER_MARGIN_MIN;\r\nwdev->wdog.max_timeout = TIMER_MARGIN_MAX;\r\nwdev->wdog.parent = &pdev->dev;\r\nif (watchdog_init_timeout(&wdev->wdog, timer_margin, &pdev->dev) < 0)\r\nwdev->wdog.timeout = TIMER_MARGIN_DEFAULT;\r\nwatchdog_set_nowayout(&wdev->wdog, nowayout);\r\nplatform_set_drvdata(pdev, wdev);\r\npm_runtime_enable(wdev->dev);\r\npm_runtime_get_sync(wdev->dev);\r\nif (pdata && pdata->read_reset_sources) {\r\nu32 rs = pdata->read_reset_sources();\r\nif (rs & (1 << OMAP_MPU_WD_RST_SRC_ID_SHIFT))\r\nwdev->wdog.bootstatus = WDIOF_CARDRESET;\r\n}\r\nif (!early_enable)\r\nomap_wdt_disable(wdev);\r\nret = watchdog_register_device(&wdev->wdog);\r\nif (ret) {\r\npm_runtime_disable(wdev->dev);\r\nreturn ret;\r\n}\r\npr_info("OMAP Watchdog Timer Rev 0x%02x: initial timeout %d sec\n",\r\nreadl_relaxed(wdev->base + OMAP_WATCHDOG_REV) & 0xFF,\r\nwdev->wdog.timeout);\r\nif (early_enable)\r\nomap_wdt_start(&wdev->wdog);\r\npm_runtime_put(wdev->dev);\r\nreturn 0;\r\n}\r\nstatic void omap_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\r\nmutex_lock(&wdev->lock);\r\nif (wdev->omap_wdt_users) {\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\nmutex_unlock(&wdev->lock);\r\n}\r\nstatic int omap_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\r\npm_runtime_disable(wdev->dev);\r\nwatchdog_unregister_device(&wdev->wdog);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\r\nmutex_lock(&wdev->lock);\r\nif (wdev->omap_wdt_users) {\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_resume(struct platform_device *pdev)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\r\nmutex_lock(&wdev->lock);\r\nif (wdev->omap_wdt_users) {\r\npm_runtime_get_sync(wdev->dev);\r\nomap_wdt_enable(wdev);\r\nomap_wdt_reload(wdev);\r\n}\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}
