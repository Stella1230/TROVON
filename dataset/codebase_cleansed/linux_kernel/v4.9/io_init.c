static inline u64 sal_get_hubdev_info(u64 handle, u64 address)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_GET_HUBDEV_INFO,\r\n(u64) handle, (u64) address, 0, 0, 0, 0, 0);\r\nreturn ret_stuff.v0;\r\n}\r\nstatic inline u64 sal_get_pcibus_info(u64 segment, u64 busnum, u64 address)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_GET_PCIBUS_INFO,\r\n(u64) segment, (u64) busnum, (u64) address, 0, 0, 0, 0);\r\nreturn ret_stuff.v0;\r\n}\r\nstatic inline u64\r\nsal_get_pcidev_info(u64 segment, u64 bus_number, u64 devfn, u64 pci_dev,\r\nu64 sn_irq_info)\r\n{\r\nstruct ia64_sal_retval ret_stuff;\r\nret_stuff.status = 0;\r\nret_stuff.v0 = 0;\r\nSAL_CALL_NOLOCK(ret_stuff,\r\n(u64) SN_SAL_IOIF_GET_PCIDEV_INFO,\r\n(u64) segment, (u64) bus_number, (u64) devfn,\r\n(u64) pci_dev,\r\nsn_irq_info, 0, 0);\r\nreturn ret_stuff.v0;\r\n}\r\nstatic void __init sn_fixup_ionodes(void)\r\n{\r\nstruct hubdev_info *hubdev;\r\nu64 status;\r\nu64 nasid;\r\nint i;\r\nextern void sn_common_hubdev_init(struct hubdev_info *);\r\nfor (i = 0; i < num_cnodes; i++) {\r\nhubdev = (struct hubdev_info *)(NODEPDA(i)->pdinfo);\r\nnasid = cnodeid_to_nasid(i);\r\nhubdev->max_segment_number = 0xffffffff;\r\nhubdev->max_pcibus_number = 0xff;\r\nstatus = sal_get_hubdev_info(nasid, (u64) __pa(hubdev));\r\nif (status)\r\ncontinue;\r\nif (hubdev->max_segment_number) {\r\nmax_segment_number = hubdev->max_segment_number;\r\nmax_pcibus_number = hubdev->max_pcibus_number;\r\n}\r\nsn_common_hubdev_init(hubdev);\r\n}\r\n}\r\nstatic void\r\nsn_legacy_pci_window_fixup(struct resource *res,\r\nu64 legacy_io, u64 legacy_mem)\r\n{\r\nres[0].name = "legacy_io";\r\nres[0].flags = IORESOURCE_IO;\r\nres[0].start = legacy_io;\r\nres[0].end = res[0].start + 0xffff;\r\nres[0].parent = &ioport_resource;\r\nres[1].name = "legacy_mem";\r\nres[1].flags = IORESOURCE_MEM;\r\nres[1].start = legacy_mem;\r\nres[1].end = res[1].start + (1024 * 1024) - 1;\r\nres[1].parent = &iomem_resource;\r\n}\r\nvoid\r\nsn_io_slot_fixup(struct pci_dev *dev)\r\n{\r\nint idx;\r\nstruct resource *res;\r\nunsigned long size;\r\nstruct pcidev_info *pcidev_info;\r\nstruct sn_irq_info *sn_irq_info;\r\nint status;\r\npcidev_info = kzalloc(sizeof(struct pcidev_info), GFP_KERNEL);\r\nif (!pcidev_info)\r\npanic("%s: Unable to alloc memory for pcidev_info", __func__);\r\nsn_irq_info = kzalloc(sizeof(struct sn_irq_info), GFP_KERNEL);\r\nif (!sn_irq_info)\r\npanic("%s: Unable to alloc memory for sn_irq_info", __func__);\r\nstatus = sal_get_pcidev_info((u64) pci_domain_nr(dev),\r\n(u64) dev->bus->number,\r\ndev->devfn,\r\n(u64) __pa(pcidev_info),\r\n(u64) __pa(sn_irq_info));\r\nBUG_ON(status);\r\nfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\r\nif (!pcidev_info->pdi_pio_mapped_addr[idx])\r\ncontinue;\r\nres = &dev->resource[idx];\r\nsize = res->end - res->start;\r\nif (size == 0)\r\ncontinue;\r\nres->start = pcidev_info->pdi_pio_mapped_addr[idx];\r\nres->end = res->start + size;\r\nif (res->parent && res->parent->child)\r\nrelease_resource(res);\r\nif (res->flags & IORESOURCE_IO)\r\ninsert_resource(&ioport_resource, res);\r\nelse\r\ninsert_resource(&iomem_resource, res);\r\nif (idx == PCI_ROM_RESOURCE) {\r\npci_disable_rom(dev);\r\nres->flags = IORESOURCE_MEM | IORESOURCE_ROM_SHADOW |\r\nIORESOURCE_PCI_FIXED;\r\n}\r\n}\r\nsn_pci_fixup_slot(dev, pcidev_info, sn_irq_info);\r\n}\r\nstatic void __init\r\nsn_pci_controller_fixup(int segment, int busnum, struct pci_bus *bus)\r\n{\r\ns64 status = 0;\r\nstruct pci_controller *controller;\r\nstruct pcibus_bussoft *prom_bussoft_ptr;\r\nstruct resource *res;\r\nLIST_HEAD(resources);\r\nstatus = sal_get_pcibus_info((u64) segment, (u64) busnum,\r\n(u64) ia64_tpa(&prom_bussoft_ptr));\r\nif (status > 0)\r\nreturn;\r\nprom_bussoft_ptr = __va(prom_bussoft_ptr);\r\ncontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\r\nBUG_ON(!controller);\r\ncontroller->segment = segment;\r\nres = kcalloc(2, sizeof(struct resource), GFP_KERNEL);\r\nBUG_ON(!res);\r\ncontroller->platform_data = prom_bussoft_ptr;\r\nsn_legacy_pci_window_fixup(res,\r\nprom_bussoft_ptr->bs_legacy_io,\r\nprom_bussoft_ptr->bs_legacy_mem);\r\npci_add_resource_offset(&resources, &res[0],\r\nprom_bussoft_ptr->bs_legacy_io);\r\npci_add_resource_offset(&resources, &res[1],\r\nprom_bussoft_ptr->bs_legacy_mem);\r\nbus = pci_scan_root_bus(NULL, busnum, &pci_root_ops, controller,\r\n&resources);\r\nif (bus == NULL) {\r\nkfree(res);\r\nkfree(controller);\r\nreturn;\r\n}\r\npci_bus_add_devices(bus);\r\n}\r\nvoid\r\nsn_bus_fixup(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *pci_dev = NULL;\r\nstruct pcibus_bussoft *prom_bussoft_ptr;\r\nif (!bus->parent) {\r\nprom_bussoft_ptr = PCI_CONTROLLER(bus)->platform_data;\r\nif (prom_bussoft_ptr == NULL) {\r\nprintk(KERN_ERR\r\n"sn_bus_fixup: 0x%04x:0x%02x Unable to "\r\n"obtain prom_bussoft_ptr\n",\r\npci_domain_nr(bus), bus->number);\r\nreturn;\r\n}\r\nsn_common_bus_fixup(bus, prom_bussoft_ptr);\r\n}\r\nlist_for_each_entry(pci_dev, &bus->devices, bus_list) {\r\nsn_io_slot_fixup(pci_dev);\r\n}\r\n}\r\nvoid __init sn_io_init(void)\r\n{\r\nint i, j;\r\nsn_fixup_ionodes();\r\nfor (i = 0; i <= max_segment_number; i++)\r\nfor (j = 0; j <= max_pcibus_number; j++)\r\nsn_pci_controller_fixup(i, j, NULL);\r\n}
