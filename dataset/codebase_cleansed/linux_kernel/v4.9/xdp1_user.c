static int set_link_xdp_fd(int ifindex, int fd)\r\n{\r\nstruct sockaddr_nl sa;\r\nint sock, seq = 0, len, ret = -1;\r\nchar buf[4096];\r\nstruct nlattr *nla, *nla_xdp;\r\nstruct {\r\nstruct nlmsghdr nh;\r\nstruct ifinfomsg ifinfo;\r\nchar attrbuf[64];\r\n} req;\r\nstruct nlmsghdr *nh;\r\nstruct nlmsgerr *err;\r\nmemset(&sa, 0, sizeof(sa));\r\nsa.nl_family = AF_NETLINK;\r\nsock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\r\nif (sock < 0) {\r\nprintf("open netlink socket: %s\n", strerror(errno));\r\nreturn -1;\r\n}\r\nif (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\r\nprintf("bind to netlink: %s\n", strerror(errno));\r\ngoto cleanup;\r\n}\r\nmemset(&req, 0, sizeof(req));\r\nreq.nh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\r\nreq.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;\r\nreq.nh.nlmsg_type = RTM_SETLINK;\r\nreq.nh.nlmsg_pid = 0;\r\nreq.nh.nlmsg_seq = ++seq;\r\nreq.ifinfo.ifi_family = AF_UNSPEC;\r\nreq.ifinfo.ifi_index = ifindex;\r\nnla = (struct nlattr *)(((char *)&req)\r\n+ NLMSG_ALIGN(req.nh.nlmsg_len));\r\nnla->nla_type = NLA_F_NESTED | 43;\r\nnla_xdp = (struct nlattr *)((char *)nla + NLA_HDRLEN);\r\nnla_xdp->nla_type = 1;\r\nnla_xdp->nla_len = NLA_HDRLEN + sizeof(int);\r\nmemcpy((char *)nla_xdp + NLA_HDRLEN, &fd, sizeof(fd));\r\nnla->nla_len = NLA_HDRLEN + nla_xdp->nla_len;\r\nreq.nh.nlmsg_len += NLA_ALIGN(nla->nla_len);\r\nif (send(sock, &req, req.nh.nlmsg_len, 0) < 0) {\r\nprintf("send to netlink: %s\n", strerror(errno));\r\ngoto cleanup;\r\n}\r\nlen = recv(sock, buf, sizeof(buf), 0);\r\nif (len < 0) {\r\nprintf("recv from netlink: %s\n", strerror(errno));\r\ngoto cleanup;\r\n}\r\nfor (nh = (struct nlmsghdr *)buf; NLMSG_OK(nh, len);\r\nnh = NLMSG_NEXT(nh, len)) {\r\nif (nh->nlmsg_pid != getpid()) {\r\nprintf("Wrong pid %d, expected %d\n",\r\nnh->nlmsg_pid, getpid());\r\ngoto cleanup;\r\n}\r\nif (nh->nlmsg_seq != seq) {\r\nprintf("Wrong seq %d, expected %d\n",\r\nnh->nlmsg_seq, seq);\r\ngoto cleanup;\r\n}\r\nswitch (nh->nlmsg_type) {\r\ncase NLMSG_ERROR:\r\nerr = (struct nlmsgerr *)NLMSG_DATA(nh);\r\nif (!err->error)\r\ncontinue;\r\nprintf("nlmsg error %s\n", strerror(-err->error));\r\ngoto cleanup;\r\ncase NLMSG_DONE:\r\nbreak;\r\n}\r\n}\r\nret = 0;\r\ncleanup:\r\nclose(sock);\r\nreturn ret;\r\n}\r\nstatic void int_exit(int sig)\r\n{\r\nset_link_xdp_fd(ifindex, -1);\r\nexit(0);\r\n}\r\nstatic void poll_stats(int interval)\r\n{\r\nunsigned int nr_cpus = sysconf(_SC_NPROCESSORS_CONF);\r\nconst unsigned int nr_keys = 256;\r\n__u64 values[nr_cpus], prev[nr_keys][nr_cpus];\r\n__u32 key;\r\nint i;\r\nmemset(prev, 0, sizeof(prev));\r\nwhile (1) {\r\nsleep(interval);\r\nfor (key = 0; key < nr_keys; key++) {\r\n__u64 sum = 0;\r\nassert(bpf_lookup_elem(map_fd[0], &key, values) == 0);\r\nfor (i = 0; i < nr_cpus; i++)\r\nsum += (values[i] - prev[key][i]);\r\nif (sum)\r\nprintf("proto %u: %10llu pkt/s\n",\r\nkey, sum / interval);\r\nmemcpy(prev[key], values, sizeof(values));\r\n}\r\n}\r\n}\r\nint main(int ac, char **argv)\r\n{\r\nchar filename[256];\r\nsnprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);\r\nif (ac != 2) {\r\nprintf("usage: %s IFINDEX\n", argv[0]);\r\nreturn 1;\r\n}\r\nifindex = strtoul(argv[1], NULL, 0);\r\nif (load_bpf_file(filename)) {\r\nprintf("%s", bpf_log_buf);\r\nreturn 1;\r\n}\r\nif (!prog_fd[0]) {\r\nprintf("load_bpf_file: %s\n", strerror(errno));\r\nreturn 1;\r\n}\r\nsignal(SIGINT, int_exit);\r\nif (set_link_xdp_fd(ifindex, prog_fd[0]) < 0) {\r\nprintf("link set xdp fd failed\n");\r\nreturn 1;\r\n}\r\npoll_stats(2);\r\nreturn 0;\r\n}
