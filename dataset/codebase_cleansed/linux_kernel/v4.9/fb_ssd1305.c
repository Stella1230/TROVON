static int init_display(struct fbtft_par *par)\r\n{\r\npar->fbtftops.reset(par);\r\nif (par->gamma.curves[0] == 0) {\r\nmutex_lock(&par->gamma.lock);\r\nif (par->info->var.yres == 64)\r\npar->gamma.curves[0] = 0xCF;\r\nelse\r\npar->gamma.curves[0] = 0x8F;\r\nmutex_unlock(&par->gamma.lock);\r\n}\r\nwrite_reg(par, 0xAE);\r\nwrite_reg(par, 0xD5);\r\nwrite_reg(par, 0x80);\r\nwrite_reg(par, 0xA8);\r\nif (par->info->var.yres == 64)\r\nwrite_reg(par, 0x3F);\r\nelse\r\nwrite_reg(par, 0x1F);\r\nwrite_reg(par, 0xD3);\r\nwrite_reg(par, 0x0);\r\nwrite_reg(par, 0x40 | 0x0);\r\nwrite_reg(par, 0x8D);\r\nwrite_reg(par, 0x14);\r\nwrite_reg(par, 0x20);\r\nwrite_reg(par, 0x01);\r\nwrite_reg(par, 0xA0 | ((par->info->var.rotate == 180) ? 0x0 : 0x1));\r\nwrite_reg(par, ((par->info->var.rotate == 180) ? 0xC8 : 0xC0));\r\nwrite_reg(par, 0xDA);\r\nif (par->info->var.yres == 64) {\r\nwrite_reg(par, 0x12);\r\n} else {\r\nwrite_reg(par, 0x02);\r\n}\r\nwrite_reg(par, 0xD9);\r\nwrite_reg(par, 0xF1);\r\nwrite_reg(par, 0xA4);\r\nwrite_reg(par, 0xA6);\r\nwrite_reg(par, 0xAF);\r\nreturn 0;\r\n}\r\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\r\n{\r\nwrite_reg(par, 0x00 | ((par->info->var.rotate == 180) ? 0x0 : 0x4));\r\nwrite_reg(par, 0x10 | 0x0);\r\nwrite_reg(par, 0x40 | 0x0);\r\n}\r\nstatic int blank(struct fbtft_par *par, bool on)\r\n{\r\nif (on)\r\nwrite_reg(par, 0xAE);\r\nelse\r\nwrite_reg(par, 0xAF);\r\nreturn 0;\r\n}\r\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\r\n{\r\ncurves[0] &= 0xFF;\r\nwrite_reg(par, 0x81);\r\nwrite_reg(par, curves[0]);\r\nreturn 0;\r\n}\r\nstatic int write_vmem(struct fbtft_par *par, size_t offset, size_t len)\r\n{\r\nu16 *vmem16 = (u16 *)par->info->screen_buffer;\r\nu8 *buf = par->txbuf.buf;\r\nint x, y, i;\r\nint ret;\r\nfor (x = 0; x < par->info->var.xres; x++) {\r\nfor (y = 0; y < par->info->var.yres / 8; y++) {\r\n*buf = 0x00;\r\nfor (i = 0; i < 8; i++)\r\n*buf |= (vmem16[(y * 8 + i) *\r\npar->info->var.xres + x] ?\r\n1 : 0) << i;\r\nbuf++;\r\n}\r\n}\r\ngpio_set_value(par->gpio.dc, 1);\r\nret = par->fbtftops.write(par, par->txbuf.buf,\r\npar->info->var.xres * par->info->var.yres /\r\n8);\r\nif (ret < 0)\r\ndev_err(par->info->device, "write failed and returned: %d\n",\r\nret);\r\nreturn ret;\r\n}
