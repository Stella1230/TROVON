static inline struct clk_div *to_clk_div(struct clk_hw *hw)\r\n{\r\nstruct clk_divider *divider = to_clk_divider(hw);\r\nreturn container_of(divider, struct clk_div, divider);\r\n}\r\nstatic unsigned long clk_div_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_div *div = to_clk_div(hw);\r\nreturn div->ops->recalc_rate(&div->divider.hw, parent_rate);\r\n}\r\nstatic long clk_div_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_div *div = to_clk_div(hw);\r\nreturn div->ops->round_rate(&div->divider.hw, rate, prate);\r\n}\r\nstatic int clk_div_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_div *div = to_clk_div(hw);\r\nint ret;\r\nret = div->ops->set_rate(&div->divider.hw, rate, parent_rate);\r\nif (!ret)\r\nret = mxs_clk_wait(div->reg, div->busy);\r\nreturn ret;\r\n}\r\nstruct clk *mxs_clk_div(const char *name, const char *parent_name,\r\nvoid __iomem *reg, u8 shift, u8 width, u8 busy)\r\n{\r\nstruct clk_div *div;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &clk_div_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.parent_names = (parent_name ? &parent_name: NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\ndiv->reg = reg;\r\ndiv->busy = busy;\r\ndiv->divider.reg = reg;\r\ndiv->divider.shift = shift;\r\ndiv->divider.width = width;\r\ndiv->divider.flags = CLK_DIVIDER_ONE_BASED;\r\ndiv->divider.lock = &mxs_lock;\r\ndiv->divider.hw.init = &init;\r\ndiv->ops = &clk_divider_ops;\r\nclk = clk_register(NULL, &div->divider.hw);\r\nif (IS_ERR(clk))\r\nkfree(div);\r\nreturn clk;\r\n}
