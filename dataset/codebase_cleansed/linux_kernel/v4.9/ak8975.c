static long ak8975_raw_to_gauss(u16 data)\r\n{\r\nreturn (((long)data + 128) * 3000) / 256;\r\n}\r\nstatic long ak8963_09911_raw_to_gauss(u16 data)\r\n{\r\nreturn (((long)data + 128) * 6000) / 256;\r\n}\r\nstatic long ak09912_raw_to_gauss(u16 data)\r\n{\r\nreturn (((long)data + 128) * 1500) / 256;\r\n}\r\nstatic int ak8975_power_on(const struct ak8975_data *data)\r\n{\r\nint ret;\r\nret = regulator_enable(data->vdd);\r\nif (ret) {\r\ndev_warn(&data->client->dev,\r\n"Failed to enable specified Vdd supply\n");\r\nreturn ret;\r\n}\r\nret = regulator_enable(data->vid);\r\nif (ret) {\r\ndev_warn(&data->client->dev,\r\n"Failed to enable specified Vid supply\n");\r\nreturn ret;\r\n}\r\nusleep_range(500, 1000);\r\nreturn 0;\r\n}\r\nstatic void ak8975_power_off(const struct ak8975_data *data)\r\n{\r\nregulator_disable(data->vid);\r\nregulator_disable(data->vdd);\r\n}\r\nstatic int ak8975_who_i_am(struct i2c_client *client,\r\nenum asahi_compass_chipset type)\r\n{\r\nu8 wia_val[2];\r\nint ret;\r\nret = i2c_smbus_read_i2c_block_data_or_emulated(\r\nclient, AK09912_REG_WIA1, 2, wia_val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error reading WIA\n");\r\nreturn ret;\r\n}\r\nif (wia_val[0] != AK8975_DEVICE_ID)\r\nreturn -ENODEV;\r\nswitch (type) {\r\ncase AK8975:\r\ncase AK8963:\r\nreturn 0;\r\ncase AK09911:\r\nif (wia_val[1] == AK09911_DEVICE_ID)\r\nreturn 0;\r\nbreak;\r\ncase AK09912:\r\nif (wia_val[1] == AK09912_DEVICE_ID)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Type %d unknown\n", type);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int ak8975_set_mode(struct ak8975_data *data, enum ak_ctrl_mode mode)\r\n{\r\nu8 regval;\r\nint ret;\r\nregval = (data->cntl_cache & ~data->def->ctrl_masks[CNTL_MODE]) |\r\ndata->def->ctrl_modes[mode];\r\nret = i2c_smbus_write_byte_data(data->client,\r\ndata->def->ctrl_regs[CNTL], regval);\r\nif (ret < 0) {\r\nreturn ret;\r\n}\r\ndata->cntl_cache = regval;\r\nusleep_range(100, 500);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ak8975_irq_handler(int irq, void *data)\r\n{\r\nstruct ak8975_data *ak8975 = data;\r\nset_bit(0, &ak8975->flags);\r\nwake_up(&ak8975->data_ready_queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ak8975_setup_irq(struct ak8975_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint rc;\r\nint irq;\r\ninit_waitqueue_head(&data->data_ready_queue);\r\nclear_bit(0, &data->flags);\r\nif (client->irq)\r\nirq = client->irq;\r\nelse\r\nirq = gpio_to_irq(data->eoc_gpio);\r\nrc = devm_request_irq(&client->dev, irq, ak8975_irq_handler,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\ndev_name(&client->dev), data);\r\nif (rc < 0) {\r\ndev_err(&client->dev,\r\n"irq %d request failed, (gpio %d): %d\n",\r\nirq, data->eoc_gpio, rc);\r\nreturn rc;\r\n}\r\ndata->eoc_irq = irq;\r\nreturn rc;\r\n}\r\nstatic int ak8975_setup(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = ak8975_set_mode(data, FUSE_ROM);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in setting fuse access mode\n");\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_i2c_block_data_or_emulated(\r\nclient, data->def->ctrl_regs[ASA_BASE],\r\n3, data->asa);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Not able to read asa data\n");\r\nreturn ret;\r\n}\r\nret = ak8975_set_mode(data, POWER_DOWN);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in setting power-down mode\n");\r\nreturn ret;\r\n}\r\nif (data->eoc_gpio > 0 || client->irq > 0) {\r\nret = ak8975_setup_irq(data);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Error setting data ready interrupt\n");\r\nreturn ret;\r\n}\r\n}\r\ndata->raw_to_gauss[0] = data->def->raw_to_gauss(data->asa[0]);\r\ndata->raw_to_gauss[1] = data->def->raw_to_gauss(data->asa[1]);\r\ndata->raw_to_gauss[2] = data->def->raw_to_gauss(data->asa[2]);\r\nreturn 0;\r\n}\r\nstatic int wait_conversion_complete_gpio(struct ak8975_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nu32 timeout_ms = AK8975_MAX_CONVERSION_TIMEOUT;\r\nint ret;\r\nwhile (timeout_ms) {\r\nmsleep(AK8975_CONVERSION_DONE_POLL_TIME);\r\nif (gpio_get_value(data->eoc_gpio))\r\nbreak;\r\ntimeout_ms -= AK8975_CONVERSION_DONE_POLL_TIME;\r\n}\r\nif (!timeout_ms) {\r\ndev_err(&client->dev, "Conversion timeout happened\n");\r\nreturn -EINVAL;\r\n}\r\nret = i2c_smbus_read_byte_data(client, data->def->ctrl_regs[ST1]);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error in reading ST1\n");\r\nreturn ret;\r\n}\r\nstatic int wait_conversion_complete_polled(struct ak8975_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nu8 read_status;\r\nu32 timeout_ms = AK8975_MAX_CONVERSION_TIMEOUT;\r\nint ret;\r\nwhile (timeout_ms) {\r\nmsleep(AK8975_CONVERSION_DONE_POLL_TIME);\r\nret = i2c_smbus_read_byte_data(client,\r\ndata->def->ctrl_regs[ST1]);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in reading ST1\n");\r\nreturn ret;\r\n}\r\nread_status = ret;\r\nif (read_status)\r\nbreak;\r\ntimeout_ms -= AK8975_CONVERSION_DONE_POLL_TIME;\r\n}\r\nif (!timeout_ms) {\r\ndev_err(&client->dev, "Conversion timeout happened\n");\r\nreturn -EINVAL;\r\n}\r\nreturn read_status;\r\n}\r\nstatic int wait_conversion_complete_interrupt(struct ak8975_data *data)\r\n{\r\nint ret;\r\nret = wait_event_timeout(data->data_ready_queue,\r\ntest_bit(0, &data->flags),\r\nAK8975_DATA_READY_TIMEOUT);\r\nclear_bit(0, &data->flags);\r\nreturn ret > 0 ? 0 : -ETIME;\r\n}\r\nstatic int ak8975_start_read_axis(struct ak8975_data *data,\r\nconst struct i2c_client *client)\r\n{\r\nint ret = ak8975_set_mode(data, MODE_ONCE);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in setting operating mode\n");\r\nreturn ret;\r\n}\r\nif (data->eoc_irq)\r\nret = wait_conversion_complete_interrupt(data);\r\nelse if (gpio_is_valid(data->eoc_gpio))\r\nret = wait_conversion_complete_gpio(data);\r\nelse\r\nret = wait_conversion_complete_polled(data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & data->def->ctrl_masks[ST1_DRDY]) {\r\nret = i2c_smbus_read_byte_data(client,\r\ndata->def->ctrl_regs[ST2]);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in reading ST2\n");\r\nreturn ret;\r\n}\r\nif (ret & (data->def->ctrl_masks[ST2_DERR] |\r\ndata->def->ctrl_masks[ST2_HOFL])) {\r\ndev_err(&client->dev, "ST2 status error 0x%x\n", ret);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak8975_read_axis(struct iio_dev *indio_dev, int index, int *val)\r\n{\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nconst struct i2c_client *client = data->client;\r\nconst struct ak_def *def = data->def;\r\nu16 buff;\r\nint ret;\r\npm_runtime_get_sync(&data->client->dev);\r\nmutex_lock(&data->lock);\r\nret = ak8975_start_read_axis(data, client);\r\nif (ret)\r\ngoto exit;\r\nret = i2c_smbus_read_i2c_block_data_or_emulated(\r\nclient, def->data_regs[index],\r\nsizeof(buff), (u8*)&buff);\r\nif (ret < 0)\r\ngoto exit;\r\nmutex_unlock(&data->lock);\r\npm_runtime_mark_last_busy(&data->client->dev);\r\npm_runtime_put_autosuspend(&data->client->dev);\r\nbuff = le16_to_cpu(buff);\r\n*val = clamp_t(s16, buff, -def->range, def->range);\r\nreturn IIO_VAL_INT;\r\nexit:\r\nmutex_unlock(&data->lock);\r\ndev_err(&client->dev, "Error in reading axis\n");\r\nreturn ret;\r\n}\r\nstatic int ak8975_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn ak8975_read_axis(indio_dev, chan->address, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = data->raw_to_gauss[chan->address];\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic const struct iio_mount_matrix *\r\nak8975_get_mount_matrix(const struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nreturn &((struct ak8975_data *)iio_priv(indio_dev))->orientation;\r\n}\r\nstatic const char *ak8975_match_acpi_device(struct device *dev,\r\nenum asahi_compass_chipset *chipset)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\n*chipset = (int)id->driver_data;\r\nreturn dev_name(dev);\r\n}\r\nstatic void ak8975_fill_buffer(struct iio_dev *indio_dev)\r\n{\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nconst struct i2c_client *client = data->client;\r\nconst struct ak_def *def = data->def;\r\nint ret;\r\ns16 buff[8];\r\nmutex_lock(&data->lock);\r\nret = ak8975_start_read_axis(data, client);\r\nif (ret)\r\ngoto unlock;\r\nret = i2c_smbus_read_i2c_block_data_or_emulated(client,\r\ndef->data_regs[0],\r\n3 * sizeof(buff[0]),\r\n(u8 *)buff);\r\nif (ret < 0)\r\ngoto unlock;\r\nmutex_unlock(&data->lock);\r\nbuff[0] = clamp_t(s16, le16_to_cpu(buff[0]), -def->range, def->range);\r\nbuff[1] = clamp_t(s16, le16_to_cpu(buff[1]), -def->range, def->range);\r\nbuff[2] = clamp_t(s16, le16_to_cpu(buff[2]), -def->range, def->range);\r\niio_push_to_buffers_with_timestamp(indio_dev, buff,\r\niio_get_time_ns(indio_dev));\r\nreturn;\r\nunlock:\r\nmutex_unlock(&data->lock);\r\ndev_err(&client->dev, "Error in reading axes block\n");\r\n}\r\nstatic irqreturn_t ak8975_handle_trigger(int irq, void *p)\r\n{\r\nconst struct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nak8975_fill_buffer(indio_dev);\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ak8975_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ak8975_data *data;\r\nstruct iio_dev *indio_dev;\r\nint eoc_gpio;\r\nint err;\r\nconst char *name = NULL;\r\nenum asahi_compass_chipset chipset = AK_MAX_TYPE;\r\nconst struct ak8975_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nif (pdata)\r\neoc_gpio = pdata->eoc_gpio;\r\nelse if (client->dev.of_node)\r\neoc_gpio = of_get_gpio(client->dev.of_node, 0);\r\nelse\r\neoc_gpio = -1;\r\nif (eoc_gpio == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (gpio_is_valid(eoc_gpio)) {\r\nerr = devm_gpio_request_one(&client->dev, eoc_gpio,\r\nGPIOF_IN, "ak_8975");\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"failed to request GPIO %d, error %d\n",\r\neoc_gpio, err);\r\nreturn err;\r\n}\r\n}\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\ndata->eoc_gpio = eoc_gpio;\r\ndata->eoc_irq = 0;\r\nif (!pdata) {\r\nerr = of_iio_read_mount_matrix(&client->dev,\r\n"mount-matrix",\r\n&data->orientation);\r\nif (err)\r\nreturn err;\r\n} else\r\ndata->orientation = pdata->orientation;\r\nif (id) {\r\nchipset = (enum asahi_compass_chipset)(id->driver_data);\r\nname = id->name;\r\n} else if (ACPI_HANDLE(&client->dev)) {\r\nname = ak8975_match_acpi_device(&client->dev, &chipset);\r\nif (!name)\r\nreturn -ENODEV;\r\n} else\r\nreturn -ENOSYS;\r\nif (chipset >= AK_MAX_TYPE) {\r\ndev_err(&client->dev, "AKM device type unsupported: %d\n",\r\nchipset);\r\nreturn -ENODEV;\r\n}\r\ndata->def = &ak_def_array[chipset];\r\ndata->vdd = devm_regulator_get(&client->dev, "vdd");\r\nif (IS_ERR(data->vdd))\r\nreturn PTR_ERR(data->vdd);\r\ndata->vid = devm_regulator_get(&client->dev, "vid");\r\nif (IS_ERR(data->vid))\r\nreturn PTR_ERR(data->vid);\r\nerr = ak8975_power_on(data);\r\nif (err)\r\nreturn err;\r\nerr = ak8975_who_i_am(client, data->def->type);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unexpected device\n");\r\ngoto power_off;\r\n}\r\ndev_dbg(&client->dev, "Asahi compass chip %s\n", name);\r\nerr = ak8975_setup(client);\r\nif (err < 0) {\r\ndev_err(&client->dev, "%s initialization fails\n", name);\r\ngoto power_off;\r\n}\r\nmutex_init(&data->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = ak8975_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ak8975_channels);\r\nindio_dev->info = &ak8975_info;\r\nindio_dev->available_scan_masks = ak8975_scan_masks;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = name;\r\nerr = iio_triggered_buffer_setup(indio_dev, NULL, ak8975_handle_trigger,\r\nNULL);\r\nif (err) {\r\ndev_err(&client->dev, "triggered buffer setup failed\n");\r\ngoto power_off;\r\n}\r\nerr = iio_device_register(indio_dev);\r\nif (err) {\r\ndev_err(&client->dev, "device register failed\n");\r\ngoto cleanup_buffer;\r\n}\r\npm_runtime_get_noresume(&client->dev);\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_enable(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev, 50);\r\npm_runtime_use_autosuspend(&client->dev);\r\npm_runtime_put(&client->dev);\r\nreturn 0;\r\ncleanup_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\npower_off:\r\nak8975_power_off(data);\r\nreturn err;\r\n}\r\nstatic int ak8975_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\npm_runtime_get_sync(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\npm_runtime_disable(&client->dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nak8975_set_mode(data, POWER_DOWN);\r\nak8975_power_off(data);\r\nreturn 0;\r\n}\r\nstatic int ak8975_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = ak8975_set_mode(data, POWER_DOWN);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in setting power-down mode\n");\r\nreturn ret;\r\n}\r\nak8975_power_off(data);\r\nreturn 0;\r\n}\r\nstatic int ak8975_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nint ret;\r\nak8975_power_on(data);\r\nret = ak8975_set_mode(data, POWER_DOWN);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in setting power-down mode\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
