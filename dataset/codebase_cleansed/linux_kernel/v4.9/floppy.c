static inline void fallback_on_nodma_alloc(char **addr, size_t l)\r\n{\r\n#ifdef FLOPPY_CAN_FALLBACK_ON_NODMA\r\nif (*addr)\r\nreturn;\r\nif (can_use_virtual_dma != 2)\r\nreturn;\r\npr_info("DMA memory shortage. Temporarily falling back on virtual DMA\n");\r\n*addr = (char *)nodma_mem_alloc(l);\r\n#else\r\nreturn;\r\n#endif\r\n}\r\nstatic inline bool drive_no_geom(int drive)\r\n{\r\nreturn !current_type[drive] && !ITYPE(UDRS->fd_device);\r\n}\r\nstatic inline int fd_eject(int drive)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic inline void set_debugt(void)\r\n{\r\ndebugtimer = jiffies;\r\n}\r\nstatic inline void debugt(const char *func, const char *msg)\r\n{\r\nif (DP->flags & DEBUGT)\r\npr_info("%s:%s dtime=%lu\n", func, msg, jiffies - debugtimer);\r\n}\r\nstatic inline void set_debugt(void) { }\r\nstatic inline void debugt(const char *func, const char *msg) { }\r\nstatic void is_alive(const char *func, const char *message)\r\n{\r\nif (test_bit(0, &fdc_busy) && command_status < 2 &&\r\n!delayed_work_pending(&fd_timeout)) {\r\nDPRINT("%s: timeout handler died. %s\n", func, message);\r\n}\r\n}\r\nstatic void __reschedule_timeout(int drive, const char *message)\r\n{\r\nunsigned long delay;\r\nif (drive == current_reqD)\r\ndrive = current_drive;\r\nif (drive < 0 || drive >= N_DRIVE) {\r\ndelay = 20UL * HZ;\r\ndrive = 0;\r\n} else\r\ndelay = UDP->timeout;\r\nmod_delayed_work(floppy_wq, &fd_timeout, delay);\r\nif (UDP->flags & FD_DEBUG)\r\nDPRINT("reschedule timeout %s\n", message);\r\ntimeout_message = message;\r\n}\r\nstatic void reschedule_timeout(int drive, const char *message)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&floppy_lock, flags);\r\n__reschedule_timeout(drive, message);\r\nspin_unlock_irqrestore(&floppy_lock, flags);\r\n}\r\nstatic int disk_change(int drive)\r\n{\r\nint fdc = FDC(drive);\r\nif (time_before(jiffies, UDRS->select_date + UDP->select_delay))\r\nDPRINT("WARNING disk change called early\n");\r\nif (!(FDCS->dor & (0x10 << UNIT(drive))) ||\r\n(FDCS->dor & 3) != UNIT(drive) || fdc != FDC(drive)) {\r\nDPRINT("probing disk change on unselected drive\n");\r\nDPRINT("drive=%d fdc=%d dor=%x\n", drive, FDC(drive),\r\n(unsigned int)FDCS->dor);\r\n}\r\ndebug_dcl(UDP->flags,\r\n"checking disk change line for drive %d\n", drive);\r\ndebug_dcl(UDP->flags, "jiffies=%lu\n", jiffies);\r\ndebug_dcl(UDP->flags, "disk change line=%x\n", fd_inb(FD_DIR) & 0x80);\r\ndebug_dcl(UDP->flags, "flags=%lx\n", UDRS->flags);\r\nif (UDP->flags & FD_BROKEN_DCL)\r\nreturn test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\r\nif ((fd_inb(FD_DIR) ^ UDP->flags) & 0x80) {\r\nset_bit(FD_VERIFY_BIT, &UDRS->flags);\r\nif (UDRS->maxblock)\r\nset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\r\nif (UDRS->keep_data >= 0) {\r\nif ((UDP->flags & FTD_MSG) &&\r\ncurrent_type[drive] != NULL)\r\nDPRINT("Disk type is undefined after disk change\n");\r\ncurrent_type[drive] = NULL;\r\nfloppy_sizes[TOMINOR(drive)] = MAX_DISK_SIZE << 1;\r\n}\r\nreturn 1;\r\n} else {\r\nUDRS->last_checked = jiffies;\r\nclear_bit(FD_DISK_NEWCHANGE_BIT, &UDRS->flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int is_selected(int dor, int unit)\r\n{\r\nreturn ((dor & (0x10 << unit)) && (dor & 3) == unit);\r\n}\r\nstatic bool is_ready_state(int status)\r\n{\r\nint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\r\nreturn state == STATUS_READY;\r\n}\r\nstatic int set_dor(int fdc, char mask, char data)\r\n{\r\nunsigned char unit;\r\nunsigned char drive;\r\nunsigned char newdor;\r\nunsigned char olddor;\r\nif (FDCS->address == -1)\r\nreturn -1;\r\nolddor = FDCS->dor;\r\nnewdor = (olddor & mask) | data;\r\nif (newdor != olddor) {\r\nunit = olddor & 0x3;\r\nif (is_selected(olddor, unit) && !is_selected(newdor, unit)) {\r\ndrive = REVDRIVE(fdc, unit);\r\ndebug_dcl(UDP->flags,\r\n"calling disk change from set_dor\n");\r\ndisk_change(drive);\r\n}\r\nFDCS->dor = newdor;\r\nfd_outb(newdor, FD_DOR);\r\nunit = newdor & 0x3;\r\nif (!is_selected(olddor, unit) && is_selected(newdor, unit)) {\r\ndrive = REVDRIVE(fdc, unit);\r\nUDRS->select_date = jiffies;\r\n}\r\n}\r\nreturn olddor;\r\n}\r\nstatic void twaddle(void)\r\n{\r\nif (DP->select_delay)\r\nreturn;\r\nfd_outb(FDCS->dor & ~(0x10 << UNIT(current_drive)), FD_DOR);\r\nfd_outb(FDCS->dor, FD_DOR);\r\nDRS->select_date = jiffies;\r\n}\r\nstatic void reset_fdc_info(int mode)\r\n{\r\nint drive;\r\nFDCS->spec1 = FDCS->spec2 = -1;\r\nFDCS->need_configure = 1;\r\nFDCS->perp_mode = 1;\r\nFDCS->rawcmd = 0;\r\nfor (drive = 0; drive < N_DRIVE; drive++)\r\nif (FDC(drive) == fdc && (mode || UDRS->track != NEED_1_RECAL))\r\nUDRS->track = NEED_2_RECAL;\r\n}\r\nstatic void set_fdc(int drive)\r\n{\r\nif (drive >= 0 && drive < N_DRIVE) {\r\nfdc = FDC(drive);\r\ncurrent_drive = drive;\r\n}\r\nif (fdc != 1 && fdc != 0) {\r\npr_info("bad fdc value\n");\r\nreturn;\r\n}\r\nset_dor(fdc, ~0, 8);\r\n#if N_FDC > 1\r\nset_dor(1 - fdc, ~8, 0);\r\n#endif\r\nif (FDCS->rawcmd == 2)\r\nreset_fdc_info(1);\r\nif (fd_inb(FD_STATUS) != STATUS_READY)\r\nFDCS->reset = 1;\r\n}\r\nstatic int lock_fdc(int drive)\r\n{\r\nif (WARN(atomic_read(&usage_count) == 0,\r\n"Trying to lock fdc while usage count=0\n"))\r\nreturn -1;\r\nif (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))\r\nreturn -EINTR;\r\ncommand_status = FD_COMMAND_NONE;\r\nreschedule_timeout(drive, "lock fdc");\r\nset_fdc(drive);\r\nreturn 0;\r\n}\r\nstatic void unlock_fdc(void)\r\n{\r\nif (!test_bit(0, &fdc_busy))\r\nDPRINT("FDC access conflict!\n");\r\nraw_cmd = NULL;\r\ncommand_status = FD_COMMAND_NONE;\r\ncancel_delayed_work(&fd_timeout);\r\ndo_floppy = NULL;\r\ncont = NULL;\r\nclear_bit(0, &fdc_busy);\r\nwake_up(&fdc_wait);\r\n}\r\nstatic void motor_off_callback(unsigned long nr)\r\n{\r\nunsigned char mask = ~(0x10 << UNIT(nr));\r\nset_dor(FDC(nr), mask, 0);\r\n}\r\nstatic void floppy_off(unsigned int drive)\r\n{\r\nunsigned long volatile delta;\r\nint fdc = FDC(drive);\r\nif (!(FDCS->dor & (0x10 << UNIT(drive))))\r\nreturn;\r\ndel_timer(motor_off_timer + drive);\r\nif (UDP->rps) {\r\ndelta = jiffies - UDRS->first_read_date + HZ -\r\nUDP->spindown_offset;\r\ndelta = ((delta * UDP->rps) % HZ) / UDP->rps;\r\nmotor_off_timer[drive].expires =\r\njiffies + UDP->spindown - delta;\r\n}\r\nadd_timer(motor_off_timer + drive);\r\n}\r\nstatic void scandrives(void)\r\n{\r\nint i;\r\nint drive;\r\nint saved_drive;\r\nif (DP->select_delay)\r\nreturn;\r\nsaved_drive = current_drive;\r\nfor (i = 0; i < N_DRIVE; i++) {\r\ndrive = (saved_drive + i + 1) % N_DRIVE;\r\nif (UDRS->fd_ref == 0 || UDP->select_delay != 0)\r\ncontinue;\r\nset_fdc(drive);\r\nif (!(set_dor(fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &\r\n(0x10 << UNIT(drive))))\r\nset_dor(fdc, ~(0x10 << UNIT(drive)), 0);\r\n}\r\nset_fdc(saved_drive);\r\n}\r\nstatic void empty(void)\r\n{\r\n}\r\nstatic void floppy_work_workfn(struct work_struct *work)\r\n{\r\nfloppy_work_fn();\r\n}\r\nstatic void schedule_bh(void (*handler)(void))\r\n{\r\nWARN_ON(work_pending(&floppy_work));\r\nfloppy_work_fn = handler;\r\nqueue_work(floppy_wq, &floppy_work);\r\n}\r\nstatic void fd_timer_workfn(struct work_struct *work)\r\n{\r\nfd_timer_fn();\r\n}\r\nstatic void cancel_activity(void)\r\n{\r\ndo_floppy = NULL;\r\ncancel_delayed_work_sync(&fd_timer);\r\ncancel_work_sync(&floppy_work);\r\n}\r\nstatic void fd_watchdog(void)\r\n{\r\ndebug_dcl(DP->flags, "calling disk change from watchdog\n");\r\nif (disk_change(current_drive)) {\r\nDPRINT("disk removed during i/o\n");\r\ncancel_activity();\r\ncont->done(0);\r\nreset_fdc();\r\n} else {\r\ncancel_delayed_work(&fd_timer);\r\nfd_timer_fn = fd_watchdog;\r\nqueue_delayed_work(floppy_wq, &fd_timer, HZ / 10);\r\n}\r\n}\r\nstatic void main_command_interrupt(void)\r\n{\r\ncancel_delayed_work(&fd_timer);\r\ncont->interrupt();\r\n}\r\nstatic int fd_wait_for_completion(unsigned long expires,\r\nvoid (*function)(void))\r\n{\r\nif (FDCS->reset) {\r\nreset_fdc();\r\nreturn 1;\r\n}\r\nif (time_before(jiffies, expires)) {\r\ncancel_delayed_work(&fd_timer);\r\nfd_timer_fn = function;\r\nqueue_delayed_work(floppy_wq, &fd_timer, expires - jiffies);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void setup_DMA(void)\r\n{\r\nunsigned long f;\r\nif (raw_cmd->length == 0) {\r\nint i;\r\npr_info("zero dma transfer size:");\r\nfor (i = 0; i < raw_cmd->cmd_count; i++)\r\npr_cont("%x,", raw_cmd->cmd[i]);\r\npr_cont("\n");\r\ncont->done(0);\r\nFDCS->reset = 1;\r\nreturn;\r\n}\r\nif (((unsigned long)raw_cmd->kernel_data) % 512) {\r\npr_info("non aligned address: %p\n", raw_cmd->kernel_data);\r\ncont->done(0);\r\nFDCS->reset = 1;\r\nreturn;\r\n}\r\nf = claim_dma_lock();\r\nfd_disable_dma();\r\n#ifdef fd_dma_setup\r\nif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\r\n(raw_cmd->flags & FD_RAW_READ) ?\r\nDMA_MODE_READ : DMA_MODE_WRITE, FDCS->address) < 0) {\r\nrelease_dma_lock(f);\r\ncont->done(0);\r\nFDCS->reset = 1;\r\nreturn;\r\n}\r\nrelease_dma_lock(f);\r\n#else\r\nfd_clear_dma_ff();\r\nfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\r\nfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\r\nDMA_MODE_READ : DMA_MODE_WRITE);\r\nfd_set_dma_addr(raw_cmd->kernel_data);\r\nfd_set_dma_count(raw_cmd->length);\r\nvirtual_dma_port = FDCS->address;\r\nfd_enable_dma();\r\nrelease_dma_lock(f);\r\n#endif\r\n}\r\nstatic int wait_til_ready(void)\r\n{\r\nint status;\r\nint counter;\r\nif (FDCS->reset)\r\nreturn -1;\r\nfor (counter = 0; counter < 10000; counter++) {\r\nstatus = fd_inb(FD_STATUS);\r\nif (status & STATUS_READY)\r\nreturn status;\r\n}\r\nif (initialized) {\r\nDPRINT("Getstatus times out (%x) on fdc %d\n", status, fdc);\r\nshow_floppy();\r\n}\r\nFDCS->reset = 1;\r\nreturn -1;\r\n}\r\nstatic int output_byte(char byte)\r\n{\r\nint status = wait_til_ready();\r\nif (status < 0)\r\nreturn -1;\r\nif (is_ready_state(status)) {\r\nfd_outb(byte, FD_DATA);\r\noutput_log[output_log_pos].data = byte;\r\noutput_log[output_log_pos].status = status;\r\noutput_log[output_log_pos].jiffies = jiffies;\r\noutput_log_pos = (output_log_pos + 1) % OLOGSIZE;\r\nreturn 0;\r\n}\r\nFDCS->reset = 1;\r\nif (initialized) {\r\nDPRINT("Unable to send byte %x to FDC. Fdc=%x Status=%x\n",\r\nbyte, fdc, status);\r\nshow_floppy();\r\n}\r\nreturn -1;\r\n}\r\nstatic int result(void)\r\n{\r\nint i;\r\nint status = 0;\r\nfor (i = 0; i < MAX_REPLIES; i++) {\r\nstatus = wait_til_ready();\r\nif (status < 0)\r\nbreak;\r\nstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\r\nif ((status & ~STATUS_BUSY) == STATUS_READY) {\r\nresultjiffies = jiffies;\r\nresultsize = i;\r\nreturn i;\r\n}\r\nif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\r\nreply_buffer[i] = fd_inb(FD_DATA);\r\nelse\r\nbreak;\r\n}\r\nif (initialized) {\r\nDPRINT("get result error. Fdc=%d Last status=%x Read bytes=%d\n",\r\nfdc, status, i);\r\nshow_floppy();\r\n}\r\nFDCS->reset = 1;\r\nreturn -1;\r\n}\r\nstatic int need_more_output(void)\r\n{\r\nint status = wait_til_ready();\r\nif (status < 0)\r\nreturn -1;\r\nif (is_ready_state(status))\r\nreturn MORE_OUTPUT;\r\nreturn result();\r\n}\r\nstatic void perpendicular_mode(void)\r\n{\r\nunsigned char perp_mode;\r\nif (raw_cmd->rate & 0x40) {\r\nswitch (raw_cmd->rate & 3) {\r\ncase 0:\r\nperp_mode = 2;\r\nbreak;\r\ncase 3:\r\nperp_mode = 3;\r\nbreak;\r\ndefault:\r\nDPRINT("Invalid data rate for perpendicular mode!\n");\r\ncont->done(0);\r\nFDCS->reset = 1;\r\nreturn;\r\n}\r\n} else\r\nperp_mode = 0;\r\nif (FDCS->perp_mode == perp_mode)\r\nreturn;\r\nif (FDCS->version >= FDC_82077_ORIG) {\r\noutput_byte(FD_PERPENDICULAR);\r\noutput_byte(perp_mode);\r\nFDCS->perp_mode = perp_mode;\r\n} else if (perp_mode) {\r\nDPRINT("perpendicular mode not supported by this FDC.\n");\r\n}\r\n}\r\nstatic int fdc_configure(void)\r\n{\r\noutput_byte(FD_CONFIGURE);\r\nif (need_more_output() != MORE_OUTPUT)\r\nreturn 0;\r\noutput_byte(0);\r\noutput_byte(0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));\r\noutput_byte(0);\r\nreturn 1;\r\n}\r\nstatic void fdc_specify(void)\r\n{\r\nunsigned char spec1;\r\nunsigned char spec2;\r\nunsigned long srt;\r\nunsigned long hlt;\r\nunsigned long hut;\r\nunsigned long dtr = NOMINAL_DTR;\r\nunsigned long scale_dtr = NOMINAL_DTR;\r\nint hlt_max_code = 0x7f;\r\nint hut_max_code = 0xf;\r\nif (FDCS->need_configure && FDCS->version >= FDC_82072A) {\r\nfdc_configure();\r\nFDCS->need_configure = 0;\r\n}\r\nswitch (raw_cmd->rate & 0x03) {\r\ncase 3:\r\ndtr = 1000;\r\nbreak;\r\ncase 1:\r\ndtr = 300;\r\nif (FDCS->version >= FDC_82078) {\r\noutput_byte(FD_DRIVESPEC);\r\nif (need_more_output() == MORE_OUTPUT) {\r\noutput_byte(UNIT(current_drive));\r\noutput_byte(0xc0);\r\n}\r\n}\r\nbreak;\r\ncase 2:\r\ndtr = 250;\r\nbreak;\r\n}\r\nif (FDCS->version >= FDC_82072) {\r\nscale_dtr = dtr;\r\nhlt_max_code = 0x00;\r\nhut_max_code = 0x0;\r\n}\r\nsrt = 16 - DIV_ROUND_UP(DP->srt * scale_dtr / 1000, NOMINAL_DTR);\r\nif (slow_floppy)\r\nsrt = srt / 4;\r\nSUPBOUND(srt, 0xf);\r\nINFBOUND(srt, 0);\r\nhlt = DIV_ROUND_UP(DP->hlt * scale_dtr / 2, NOMINAL_DTR);\r\nif (hlt < 0x01)\r\nhlt = 0x01;\r\nelse if (hlt > 0x7f)\r\nhlt = hlt_max_code;\r\nhut = DIV_ROUND_UP(DP->hut * scale_dtr / 16, NOMINAL_DTR);\r\nif (hut < 0x1)\r\nhut = 0x1;\r\nelse if (hut > 0xf)\r\nhut = hut_max_code;\r\nspec1 = (srt << 4) | hut;\r\nspec2 = (hlt << 1) | (use_virtual_dma & 1);\r\nif (FDCS->spec1 != spec1 || FDCS->spec2 != spec2) {\r\noutput_byte(FD_SPECIFY);\r\noutput_byte(FDCS->spec1 = spec1);\r\noutput_byte(FDCS->spec2 = spec2);\r\n}\r\n}\r\nstatic int fdc_dtr(void)\r\n{\r\nif ((raw_cmd->rate & 3) == FDCS->dtr)\r\nreturn 0;\r\nfd_outb(raw_cmd->rate & 3, FD_DCR);\r\nFDCS->dtr = raw_cmd->rate & 3;\r\nreturn fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);\r\n}\r\nstatic void tell_sector(void)\r\n{\r\npr_cont(": track %d, head %d, sector %d, size %d",\r\nR_TRACK, R_HEAD, R_SECTOR, R_SIZECODE);\r\n}\r\nstatic void print_errors(void)\r\n{\r\nDPRINT("");\r\nif (ST0 & ST0_ECE) {\r\npr_cont("Recalibrate failed!");\r\n} else if (ST2 & ST2_CRC) {\r\npr_cont("data CRC error");\r\ntell_sector();\r\n} else if (ST1 & ST1_CRC) {\r\npr_cont("CRC error");\r\ntell_sector();\r\n} else if ((ST1 & (ST1_MAM | ST1_ND)) ||\r\n(ST2 & ST2_MAM)) {\r\nif (!probing) {\r\npr_cont("sector not found");\r\ntell_sector();\r\n} else\r\npr_cont("probe failed...");\r\n} else if (ST2 & ST2_WC) {\r\npr_cont("wrong cylinder");\r\n} else if (ST2 & ST2_BC) {\r\npr_cont("bad cylinder");\r\n} else {\r\npr_cont("unknown error. ST[0..2] are: 0x%x 0x%x 0x%x",\r\nST0, ST1, ST2);\r\ntell_sector();\r\n}\r\npr_cont("\n");\r\n}\r\nstatic int interpret_errors(void)\r\n{\r\nchar bad;\r\nif (inr != 7) {\r\nDPRINT("-- FDC reply error\n");\r\nFDCS->reset = 1;\r\nreturn 1;\r\n}\r\nswitch (ST0 & ST0_INTR) {\r\ncase 0x40:\r\nif (ST1 & ST1_EOC)\r\nreturn 0;\r\nbad = 1;\r\nif (ST1 & ST1_WP) {\r\nDPRINT("Drive is write protected\n");\r\nclear_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\r\ncont->done(0);\r\nbad = 2;\r\n} else if (ST1 & ST1_ND) {\r\nset_bit(FD_NEED_TWADDLE_BIT, &DRS->flags);\r\n} else if (ST1 & ST1_OR) {\r\nif (DP->flags & FTD_MSG)\r\nDPRINT("Over/Underrun - retrying\n");\r\nbad = 0;\r\n} else if (*errors >= DP->max_errors.reporting) {\r\nprint_errors();\r\n}\r\nif (ST2 & ST2_WC || ST2 & ST2_BC)\r\nDRS->track = NEED_2_RECAL;\r\nreturn bad;\r\ncase 0x80:\r\nDPRINT("Invalid FDC command given!\n");\r\ncont->done(0);\r\nreturn 2;\r\ncase 0xc0:\r\nDPRINT("Abnormal termination caused by polling\n");\r\ncont->error();\r\nreturn 2;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void setup_rw_floppy(void)\r\n{\r\nint i;\r\nint r;\r\nint flags;\r\nint dflags;\r\nunsigned long ready_date;\r\nvoid (*function)(void);\r\nflags = raw_cmd->flags;\r\nif (flags & (FD_RAW_READ | FD_RAW_WRITE))\r\nflags |= FD_RAW_INTR;\r\nif ((flags & FD_RAW_SPIN) && !(flags & FD_RAW_NO_MOTOR)) {\r\nready_date = DRS->spinup_date + DP->spinup;\r\nif (time_after(ready_date, jiffies + DP->select_delay)) {\r\nready_date -= DP->select_delay;\r\nfunction = floppy_start;\r\n} else\r\nfunction = setup_rw_floppy;\r\nif (fd_wait_for_completion(ready_date, function))\r\nreturn;\r\n}\r\ndflags = DRS->flags;\r\nif ((flags & FD_RAW_READ) || (flags & FD_RAW_WRITE))\r\nsetup_DMA();\r\nif (flags & FD_RAW_INTR)\r\ndo_floppy = main_command_interrupt;\r\nr = 0;\r\nfor (i = 0; i < raw_cmd->cmd_count; i++)\r\nr |= output_byte(raw_cmd->cmd[i]);\r\ndebugt(__func__, "rw_command");\r\nif (r) {\r\ncont->error();\r\nreset_fdc();\r\nreturn;\r\n}\r\nif (!(flags & FD_RAW_INTR)) {\r\ninr = result();\r\ncont->interrupt();\r\n} else if (flags & FD_RAW_NEED_DISK)\r\nfd_watchdog();\r\n}\r\nstatic void seek_interrupt(void)\r\n{\r\ndebugt(__func__, "");\r\nif (inr != 2 || (ST0 & 0xF8) != 0x20) {\r\nDPRINT("seek failed\n");\r\nDRS->track = NEED_2_RECAL;\r\ncont->error();\r\ncont->redo();\r\nreturn;\r\n}\r\nif (DRS->track >= 0 && DRS->track != ST1 && !blind_seek) {\r\ndebug_dcl(DP->flags,\r\n"clearing NEWCHANGE flag because of effective seek\n");\r\ndebug_dcl(DP->flags, "jiffies=%lu\n", jiffies);\r\nclear_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\r\nDRS->select_date = jiffies;\r\n}\r\nDRS->track = ST1;\r\nfloppy_ready();\r\n}\r\nstatic void check_wp(void)\r\n{\r\nif (test_bit(FD_VERIFY_BIT, &DRS->flags)) {\r\noutput_byte(FD_GETSTATUS);\r\noutput_byte(UNIT(current_drive));\r\nif (result() != 1) {\r\nFDCS->reset = 1;\r\nreturn;\r\n}\r\nclear_bit(FD_VERIFY_BIT, &DRS->flags);\r\nclear_bit(FD_NEED_TWADDLE_BIT, &DRS->flags);\r\ndebug_dcl(DP->flags,\r\n"checking whether disk is write protected\n");\r\ndebug_dcl(DP->flags, "wp=%x\n", ST3 & 0x40);\r\nif (!(ST3 & 0x40))\r\nset_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\r\nelse\r\nclear_bit(FD_DISK_WRITABLE_BIT, &DRS->flags);\r\n}\r\n}\r\nstatic void seek_floppy(void)\r\n{\r\nint track;\r\nblind_seek = 0;\r\ndebug_dcl(DP->flags, "calling disk change from %s\n", __func__);\r\nif (!test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\r\ndisk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\r\nset_bit(FD_DISK_CHANGED_BIT, &DRS->flags);\r\ncont->done(0);\r\ncont->redo();\r\nreturn;\r\n}\r\nif (DRS->track <= NEED_1_RECAL) {\r\nrecalibrate_floppy();\r\nreturn;\r\n} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\r\n(raw_cmd->flags & FD_RAW_NEED_DISK) &&\r\n(DRS->track <= NO_TRACK || DRS->track == raw_cmd->track)) {\r\nif (raw_cmd->track)\r\ntrack = raw_cmd->track - 1;\r\nelse {\r\nif (DP->flags & FD_SILENT_DCL_CLEAR) {\r\nset_dor(fdc, ~(0x10 << UNIT(current_drive)), 0);\r\nblind_seek = 1;\r\nraw_cmd->flags |= FD_RAW_NEED_SEEK;\r\n}\r\ntrack = 1;\r\n}\r\n} else {\r\ncheck_wp();\r\nif (raw_cmd->track != DRS->track &&\r\n(raw_cmd->flags & FD_RAW_NEED_SEEK))\r\ntrack = raw_cmd->track;\r\nelse {\r\nsetup_rw_floppy();\r\nreturn;\r\n}\r\n}\r\ndo_floppy = seek_interrupt;\r\noutput_byte(FD_SEEK);\r\noutput_byte(UNIT(current_drive));\r\nif (output_byte(track) < 0) {\r\nreset_fdc();\r\nreturn;\r\n}\r\ndebugt(__func__, "");\r\n}\r\nstatic void recal_interrupt(void)\r\n{\r\ndebugt(__func__, "");\r\nif (inr != 2)\r\nFDCS->reset = 1;\r\nelse if (ST0 & ST0_ECE) {\r\nswitch (DRS->track) {\r\ncase NEED_1_RECAL:\r\ndebugt(__func__, "need 1 recal");\r\ncont->error();\r\ncont->redo();\r\nreturn;\r\ncase NEED_2_RECAL:\r\ndebugt(__func__, "need 2 recal");\r\ndebug_dcl(DP->flags,\r\n"clearing NEWCHANGE flag because of second recalibrate\n");\r\nclear_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\r\nDRS->select_date = jiffies;\r\ndefault:\r\ndebugt(__func__, "default");\r\nDRS->track = NEED_1_RECAL;\r\nbreak;\r\n}\r\n} else\r\nDRS->track = ST1;\r\nfloppy_ready();\r\n}\r\nstatic void print_result(char *message, int inr)\r\n{\r\nint i;\r\nDPRINT("%s ", message);\r\nif (inr >= 0)\r\nfor (i = 0; i < inr; i++)\r\npr_cont("repl[%d]=%x ", i, reply_buffer[i]);\r\npr_cont("\n");\r\n}\r\nirqreturn_t floppy_interrupt(int irq, void *dev_id)\r\n{\r\nint do_print;\r\nunsigned long f;\r\nvoid (*handler)(void) = do_floppy;\r\nlasthandler = handler;\r\ninterruptjiffies = jiffies;\r\nf = claim_dma_lock();\r\nfd_disable_dma();\r\nrelease_dma_lock(f);\r\ndo_floppy = NULL;\r\nif (fdc >= N_FDC || FDCS->address == -1) {\r\npr_info("DOR0=%x\n", fdc_state[0].dor);\r\npr_info("floppy interrupt on bizarre fdc %d\n", fdc);\r\npr_info("handler=%pf\n", handler);\r\nis_alive(__func__, "bizarre fdc");\r\nreturn IRQ_NONE;\r\n}\r\nFDCS->reset = 0;\r\ndo_print = !handler && print_unex && initialized;\r\ninr = result();\r\nif (do_print)\r\nprint_result("unexpected interrupt", inr);\r\nif (inr == 0) {\r\nint max_sensei = 4;\r\ndo {\r\noutput_byte(FD_SENSEI);\r\ninr = result();\r\nif (do_print)\r\nprint_result("sensei", inr);\r\nmax_sensei--;\r\n} while ((ST0 & 0x83) != UNIT(current_drive) &&\r\ninr == 2 && max_sensei);\r\n}\r\nif (!handler) {\r\nFDCS->reset = 1;\r\nreturn IRQ_NONE;\r\n}\r\nschedule_bh(handler);\r\nis_alive(__func__, "normal interrupt end");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void recalibrate_floppy(void)\r\n{\r\ndebugt(__func__, "");\r\ndo_floppy = recal_interrupt;\r\noutput_byte(FD_RECALIBRATE);\r\nif (output_byte(UNIT(current_drive)) < 0)\r\nreset_fdc();\r\n}\r\nstatic void reset_interrupt(void)\r\n{\r\ndebugt(__func__, "");\r\nresult();\r\nif (FDCS->reset) {\r\npr_info("reset set in interrupt, calling %pf\n", cont->error);\r\ncont->error();\r\n}\r\ncont->redo();\r\n}\r\nstatic void reset_fdc(void)\r\n{\r\nunsigned long flags;\r\ndo_floppy = reset_interrupt;\r\nFDCS->reset = 0;\r\nreset_fdc_info(0);\r\nflags = claim_dma_lock();\r\nfd_disable_dma();\r\nrelease_dma_lock(flags);\r\nif (FDCS->version >= FDC_82072A)\r\nfd_outb(0x80 | (FDCS->dtr & 3), FD_STATUS);\r\nelse {\r\nfd_outb(FDCS->dor & ~0x04, FD_DOR);\r\nudelay(FD_RESET_DELAY);\r\nfd_outb(FDCS->dor, FD_DOR);\r\n}\r\n}\r\nstatic void show_floppy(void)\r\n{\r\nint i;\r\npr_info("\n");\r\npr_info("floppy driver state\n");\r\npr_info("-------------------\n");\r\npr_info("now=%lu last interrupt=%lu diff=%lu last called handler=%pf\n",\r\njiffies, interruptjiffies, jiffies - interruptjiffies,\r\nlasthandler);\r\npr_info("timeout_message=%s\n", timeout_message);\r\npr_info("last output bytes:\n");\r\nfor (i = 0; i < OLOGSIZE; i++)\r\npr_info("%2x %2x %lu\n",\r\noutput_log[(i + output_log_pos) % OLOGSIZE].data,\r\noutput_log[(i + output_log_pos) % OLOGSIZE].status,\r\noutput_log[(i + output_log_pos) % OLOGSIZE].jiffies);\r\npr_info("last result at %lu\n", resultjiffies);\r\npr_info("last redo_fd_request at %lu\n", lastredo);\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,\r\nreply_buffer, resultsize, true);\r\npr_info("status=%x\n", fd_inb(FD_STATUS));\r\npr_info("fdc_busy=%lu\n", fdc_busy);\r\nif (do_floppy)\r\npr_info("do_floppy=%pf\n", do_floppy);\r\nif (work_pending(&floppy_work))\r\npr_info("floppy_work.func=%pf\n", floppy_work.func);\r\nif (delayed_work_pending(&fd_timer))\r\npr_info("delayed work.function=%p expires=%ld\n",\r\nfd_timer.work.func,\r\nfd_timer.timer.expires - jiffies);\r\nif (delayed_work_pending(&fd_timeout))\r\npr_info("timer_function=%p expires=%ld\n",\r\nfd_timeout.work.func,\r\nfd_timeout.timer.expires - jiffies);\r\npr_info("cont=%p\n", cont);\r\npr_info("current_req=%p\n", current_req);\r\npr_info("command_status=%d\n", command_status);\r\npr_info("\n");\r\n}\r\nstatic void floppy_shutdown(struct work_struct *arg)\r\n{\r\nunsigned long flags;\r\nif (initialized)\r\nshow_floppy();\r\ncancel_activity();\r\nflags = claim_dma_lock();\r\nfd_disable_dma();\r\nrelease_dma_lock(flags);\r\nif (initialized)\r\nDPRINT("floppy timeout called\n");\r\nFDCS->reset = 1;\r\nif (cont) {\r\ncont->done(0);\r\ncont->redo();\r\n} else {\r\npr_info("no cont in shutdown!\n");\r\nprocess_fd_request();\r\n}\r\nis_alive(__func__, "");\r\n}\r\nstatic int start_motor(void (*function)(void))\r\n{\r\nint mask;\r\nint data;\r\nmask = 0xfc;\r\ndata = UNIT(current_drive);\r\nif (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {\r\nif (!(FDCS->dor & (0x10 << UNIT(current_drive)))) {\r\nset_debugt();\r\nDRS->first_read_date = 0;\r\nDRS->spinup_date = jiffies;\r\ndata |= (0x10 << UNIT(current_drive));\r\n}\r\n} else if (FDCS->dor & (0x10 << UNIT(current_drive)))\r\nmask &= ~(0x10 << UNIT(current_drive));\r\ndel_timer(motor_off_timer + current_drive);\r\nset_dor(fdc, mask, data);\r\nreturn fd_wait_for_completion(DRS->select_date + DP->select_delay,\r\nfunction);\r\n}\r\nstatic void floppy_ready(void)\r\n{\r\nif (FDCS->reset) {\r\nreset_fdc();\r\nreturn;\r\n}\r\nif (start_motor(floppy_ready))\r\nreturn;\r\nif (fdc_dtr())\r\nreturn;\r\ndebug_dcl(DP->flags, "calling disk change from floppy_ready\n");\r\nif (!(raw_cmd->flags & FD_RAW_NO_MOTOR) &&\r\ndisk_change(current_drive) && !DP->select_delay)\r\ntwaddle();\r\n#ifdef fd_chose_dma_mode\r\nif ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {\r\nunsigned long flags = claim_dma_lock();\r\nfd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);\r\nrelease_dma_lock(flags);\r\n}\r\n#endif\r\nif (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {\r\nperpendicular_mode();\r\nfdc_specify();\r\nseek_floppy();\r\n} else {\r\nif ((raw_cmd->flags & FD_RAW_READ) ||\r\n(raw_cmd->flags & FD_RAW_WRITE))\r\nfdc_specify();\r\nsetup_rw_floppy();\r\n}\r\n}\r\nstatic void floppy_start(void)\r\n{\r\nreschedule_timeout(current_reqD, "floppy start");\r\nscandrives();\r\ndebug_dcl(DP->flags, "setting NEWCHANGE in floppy_start\n");\r\nset_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\r\nfloppy_ready();\r\n}\r\nstatic void do_wakeup(void)\r\n{\r\nreschedule_timeout(MAXTIMEOUT, "do wakeup");\r\ncont = NULL;\r\ncommand_status += 2;\r\nwake_up(&command_done);\r\n}\r\nstatic int wait_til_done(void (*handler)(void), bool interruptible)\r\n{\r\nint ret;\r\nschedule_bh(handler);\r\nif (interruptible)\r\nwait_event_interruptible(command_done, command_status >= 2);\r\nelse\r\nwait_event(command_done, command_status >= 2);\r\nif (command_status < 2) {\r\ncancel_activity();\r\ncont = &intr_cont;\r\nreset_fdc();\r\nreturn -EINTR;\r\n}\r\nif (FDCS->reset)\r\ncommand_status = FD_COMMAND_ERROR;\r\nif (command_status == FD_COMMAND_OKAY)\r\nret = 0;\r\nelse\r\nret = -EIO;\r\ncommand_status = FD_COMMAND_NONE;\r\nreturn ret;\r\n}\r\nstatic void generic_done(int result)\r\n{\r\ncommand_status = result;\r\ncont = &wakeup_cont;\r\n}\r\nstatic void generic_success(void)\r\n{\r\ncont->done(1);\r\n}\r\nstatic void generic_failure(void)\r\n{\r\ncont->done(0);\r\n}\r\nstatic void success_and_wakeup(void)\r\n{\r\ngeneric_success();\r\ncont->redo();\r\n}\r\nstatic int next_valid_format(void)\r\n{\r\nint probed_format;\r\nprobed_format = DRS->probed_format;\r\nwhile (1) {\r\nif (probed_format >= 8 || !DP->autodetect[probed_format]) {\r\nDRS->probed_format = 0;\r\nreturn 1;\r\n}\r\nif (floppy_type[DP->autodetect[probed_format]].sect) {\r\nDRS->probed_format = probed_format;\r\nreturn 0;\r\n}\r\nprobed_format++;\r\n}\r\n}\r\nstatic void bad_flp_intr(void)\r\n{\r\nint err_count;\r\nif (probing) {\r\nDRS->probed_format++;\r\nif (!next_valid_format())\r\nreturn;\r\n}\r\nerr_count = ++(*errors);\r\nINFBOUND(DRWE->badness, err_count);\r\nif (err_count > DP->max_errors.abort)\r\ncont->done(0);\r\nif (err_count > DP->max_errors.reset)\r\nFDCS->reset = 1;\r\nelse if (err_count > DP->max_errors.recal)\r\nDRS->track = NEED_2_RECAL;\r\n}\r\nstatic void set_floppy(int drive)\r\n{\r\nint type = ITYPE(UDRS->fd_device);\r\nif (type)\r\n_floppy = floppy_type + type;\r\nelse\r\n_floppy = current_type[drive];\r\n}\r\nstatic void format_interrupt(void)\r\n{\r\nswitch (interpret_errors()) {\r\ncase 1:\r\ncont->error();\r\ncase 2:\r\nbreak;\r\ncase 0:\r\ncont->done(1);\r\n}\r\ncont->redo();\r\n}\r\nstatic void setup_format_params(int track)\r\n{\r\nint n;\r\nint il;\r\nint count;\r\nint head_shift;\r\nint track_shift;\r\nstruct fparm {\r\nunsigned char track, head, sect, size;\r\n} *here = (struct fparm *)floppy_track_buffer;\r\nraw_cmd = &default_raw_cmd;\r\nraw_cmd->track = track;\r\nraw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\r\nFD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\r\nraw_cmd->rate = _floppy->rate & 0x43;\r\nraw_cmd->cmd_count = NR_F;\r\nCOMMAND = FM_MODE(_floppy, FD_FORMAT);\r\nDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\r\nF_SIZECODE = FD_SIZECODE(_floppy);\r\nF_SECT_PER_TRACK = _floppy->sect << 2 >> F_SIZECODE;\r\nF_GAP = _floppy->fmt_gap;\r\nF_FILL = FD_FILL_BYTE;\r\nraw_cmd->kernel_data = floppy_track_buffer;\r\nraw_cmd->length = 4 * F_SECT_PER_TRACK;\r\nhead_shift = (F_SECT_PER_TRACK + 5) / 6;\r\ntrack_shift = 2 * head_shift + 3;\r\nn = (track_shift * format_req.track + head_shift * format_req.head)\r\n% F_SECT_PER_TRACK;\r\nil = 1;\r\nif (_floppy->fmt_gap < 0x22)\r\nil++;\r\nfor (count = 0; count < F_SECT_PER_TRACK; ++count) {\r\nhere[count].track = format_req.track;\r\nhere[count].head = format_req.head;\r\nhere[count].sect = 0;\r\nhere[count].size = F_SIZECODE;\r\n}\r\nfor (count = 1; count <= F_SECT_PER_TRACK; ++count) {\r\nhere[n].sect = count;\r\nn = (n + il) % F_SECT_PER_TRACK;\r\nif (here[n].sect) {\r\n++n;\r\nif (n >= F_SECT_PER_TRACK) {\r\nn -= F_SECT_PER_TRACK;\r\nwhile (here[n].sect)\r\n++n;\r\n}\r\n}\r\n}\r\nif (_floppy->stretch & FD_SECTBASEMASK) {\r\nfor (count = 0; count < F_SECT_PER_TRACK; count++)\r\nhere[count].sect += FD_SECTBASE(_floppy) - 1;\r\n}\r\n}\r\nstatic void redo_format(void)\r\n{\r\nbuffer_track = -1;\r\nsetup_format_params(format_req.track << STRETCH(_floppy));\r\nfloppy_start();\r\ndebugt(__func__, "queue format request");\r\n}\r\nstatic int do_format(int drive, struct format_descr *tmp_format_req)\r\n{\r\nint ret;\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nset_floppy(drive);\r\nif (!_floppy ||\r\n_floppy->track > DP->tracks ||\r\ntmp_format_req->track >= _floppy->track ||\r\ntmp_format_req->head >= _floppy->head ||\r\n(_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) ||\r\n!_floppy->fmt_gap) {\r\nprocess_fd_request();\r\nreturn -EINVAL;\r\n}\r\nformat_req = *tmp_format_req;\r\nformat_errors = 0;\r\ncont = &format_cont;\r\nerrors = &format_errors;\r\nret = wait_til_done(redo_format, true);\r\nif (ret == -EINTR)\r\nreturn -EINTR;\r\nprocess_fd_request();\r\nreturn ret;\r\n}\r\nstatic void floppy_end_request(struct request *req, int error)\r\n{\r\nunsigned int nr_sectors = current_count_sectors;\r\nunsigned int drive = (unsigned long)req->rq_disk->private_data;\r\nif (error)\r\nnr_sectors = blk_rq_cur_sectors(req);\r\nif (__blk_end_request(req, error, nr_sectors << 9))\r\nreturn;\r\nfloppy_off(drive);\r\ncurrent_req = NULL;\r\n}\r\nstatic void request_done(int uptodate)\r\n{\r\nstruct request *req = current_req;\r\nstruct request_queue *q;\r\nunsigned long flags;\r\nint block;\r\nchar msg[sizeof("request done ") + sizeof(int) * 3];\r\nprobing = 0;\r\nsnprintf(msg, sizeof(msg), "request done %d", uptodate);\r\nreschedule_timeout(MAXTIMEOUT, msg);\r\nif (!req) {\r\npr_info("floppy.c: no request in request_done\n");\r\nreturn;\r\n}\r\nq = req->q;\r\nif (uptodate) {\r\nblock = current_count_sectors + blk_rq_pos(req);\r\nINFBOUND(DRS->maxblock, block);\r\nif (block > _floppy->sect)\r\nDRS->maxtrack = 1;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nfloppy_end_request(req, 0);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\n} else {\r\nif (rq_data_dir(req) == WRITE) {\r\nDRWE->write_errors++;\r\nif (DRWE->write_errors == 1) {\r\nDRWE->first_error_sector = blk_rq_pos(req);\r\nDRWE->first_error_generation = DRS->generation;\r\n}\r\nDRWE->last_error_sector = blk_rq_pos(req);\r\nDRWE->last_error_generation = DRS->generation;\r\n}\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nfloppy_end_request(req, -EIO);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\n}\r\n}\r\nstatic void rw_interrupt(void)\r\n{\r\nint eoc;\r\nint ssize;\r\nint heads;\r\nint nr_sectors;\r\nif (R_HEAD >= 2) {\r\nreturn;\r\n}\r\nif (!DRS->first_read_date)\r\nDRS->first_read_date = jiffies;\r\nnr_sectors = 0;\r\nssize = DIV_ROUND_UP(1 << SIZECODE, 4);\r\nif (ST1 & ST1_EOC)\r\neoc = 1;\r\nelse\r\neoc = 0;\r\nif (COMMAND & 0x80)\r\nheads = 2;\r\nelse\r\nheads = 1;\r\nnr_sectors = (((R_TRACK - TRACK) * heads +\r\nR_HEAD - HEAD) * SECT_PER_TRACK +\r\nR_SECTOR - SECTOR + eoc) << SIZECODE >> 2;\r\nif (nr_sectors / ssize >\r\nDIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {\r\nDPRINT("long rw: %x instead of %lx\n",\r\nnr_sectors, current_count_sectors);\r\npr_info("rs=%d s=%d\n", R_SECTOR, SECTOR);\r\npr_info("rh=%d h=%d\n", R_HEAD, HEAD);\r\npr_info("rt=%d t=%d\n", R_TRACK, TRACK);\r\npr_info("heads=%d eoc=%d\n", heads, eoc);\r\npr_info("spt=%d st=%d ss=%d\n",\r\nSECT_PER_TRACK, fsector_t, ssize);\r\npr_info("in_sector_offset=%d\n", in_sector_offset);\r\n}\r\nnr_sectors -= in_sector_offset;\r\nINFBOUND(nr_sectors, 0);\r\nSUPBOUND(current_count_sectors, nr_sectors);\r\nswitch (interpret_errors()) {\r\ncase 2:\r\ncont->redo();\r\nreturn;\r\ncase 1:\r\nif (!current_count_sectors) {\r\ncont->error();\r\ncont->redo();\r\nreturn;\r\n}\r\nbreak;\r\ncase 0:\r\nif (!current_count_sectors) {\r\ncont->redo();\r\nreturn;\r\n}\r\ncurrent_type[current_drive] = _floppy;\r\nfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\r\nbreak;\r\n}\r\nif (probing) {\r\nif (DP->flags & FTD_MSG)\r\nDPRINT("Auto-detected floppy type %s in fd%d\n",\r\n_floppy->name, current_drive);\r\ncurrent_type[current_drive] = _floppy;\r\nfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\r\nprobing = 0;\r\n}\r\nif (CT(COMMAND) != FD_READ ||\r\nraw_cmd->kernel_data == bio_data(current_req->bio)) {\r\ncont->done(1);\r\n} else if (CT(COMMAND) == FD_READ) {\r\nbuffer_track = raw_cmd->track;\r\nbuffer_drive = current_drive;\r\nINFBOUND(buffer_max, nr_sectors + fsector_t);\r\n}\r\ncont->redo();\r\n}\r\nstatic int buffer_chain_size(void)\r\n{\r\nstruct bio_vec bv;\r\nint size;\r\nstruct req_iterator iter;\r\nchar *base;\r\nbase = bio_data(current_req->bio);\r\nsize = 0;\r\nrq_for_each_segment(bv, current_req, iter) {\r\nif (page_address(bv.bv_page) + bv.bv_offset != base + size)\r\nbreak;\r\nsize += bv.bv_len;\r\n}\r\nreturn size >> 9;\r\n}\r\nstatic int transfer_size(int ssize, int max_sector, int max_size)\r\n{\r\nSUPBOUND(max_sector, fsector_t + max_size);\r\nmax_sector -= (max_sector % _floppy->sect) % ssize;\r\ncurrent_count_sectors = max_sector - fsector_t;\r\nreturn max_sector;\r\n}\r\nstatic void copy_buffer(int ssize, int max_sector, int max_sector_2)\r\n{\r\nint remaining;\r\nstruct bio_vec bv;\r\nchar *buffer;\r\nchar *dma_buffer;\r\nint size;\r\nstruct req_iterator iter;\r\nmax_sector = transfer_size(ssize,\r\nmin(max_sector, max_sector_2),\r\nblk_rq_sectors(current_req));\r\nif (current_count_sectors <= 0 && CT(COMMAND) == FD_WRITE &&\r\nbuffer_max > fsector_t + blk_rq_sectors(current_req))\r\ncurrent_count_sectors = min_t(int, buffer_max - fsector_t,\r\nblk_rq_sectors(current_req));\r\nremaining = current_count_sectors << 9;\r\nif (remaining > blk_rq_bytes(current_req) && CT(COMMAND) == FD_WRITE) {\r\nDPRINT("in copy buffer\n");\r\npr_info("current_count_sectors=%ld\n", current_count_sectors);\r\npr_info("remaining=%d\n", remaining >> 9);\r\npr_info("current_req->nr_sectors=%u\n",\r\nblk_rq_sectors(current_req));\r\npr_info("current_req->current_nr_sectors=%u\n",\r\nblk_rq_cur_sectors(current_req));\r\npr_info("max_sector=%d\n", max_sector);\r\npr_info("ssize=%d\n", ssize);\r\n}\r\nbuffer_max = max(max_sector, buffer_max);\r\ndma_buffer = floppy_track_buffer + ((fsector_t - buffer_min) << 9);\r\nsize = blk_rq_cur_bytes(current_req);\r\nrq_for_each_segment(bv, current_req, iter) {\r\nif (!remaining)\r\nbreak;\r\nsize = bv.bv_len;\r\nSUPBOUND(size, remaining);\r\nbuffer = page_address(bv.bv_page) + bv.bv_offset;\r\nif (dma_buffer + size >\r\nfloppy_track_buffer + (max_buffer_sectors << 10) ||\r\ndma_buffer < floppy_track_buffer) {\r\nDPRINT("buffer overrun in copy buffer %d\n",\r\n(int)((floppy_track_buffer - dma_buffer) >> 9));\r\npr_info("fsector_t=%d buffer_min=%d\n",\r\nfsector_t, buffer_min);\r\npr_info("current_count_sectors=%ld\n",\r\ncurrent_count_sectors);\r\nif (CT(COMMAND) == FD_READ)\r\npr_info("read\n");\r\nif (CT(COMMAND) == FD_WRITE)\r\npr_info("write\n");\r\nbreak;\r\n}\r\nif (((unsigned long)buffer) % 512)\r\nDPRINT("%p buffer not aligned\n", buffer);\r\nif (CT(COMMAND) == FD_READ)\r\nmemcpy(buffer, dma_buffer, size);\r\nelse\r\nmemcpy(dma_buffer, buffer, size);\r\nremaining -= size;\r\ndma_buffer += size;\r\n}\r\nif (remaining) {\r\nif (remaining > 0)\r\nmax_sector -= remaining >> 9;\r\nDPRINT("weirdness: remaining %d\n", remaining >> 9);\r\n}\r\n}\r\nstatic void virtualdmabug_workaround(void)\r\n{\r\nint hard_sectors;\r\nint end_sector;\r\nif (CT(COMMAND) == FD_WRITE) {\r\nCOMMAND &= ~0x80;\r\nhard_sectors = raw_cmd->length >> (7 + SIZECODE);\r\nend_sector = SECTOR + hard_sectors - 1;\r\nif (end_sector > SECT_PER_TRACK) {\r\npr_info("too many sectors %d > %d\n",\r\nend_sector, SECT_PER_TRACK);\r\nreturn;\r\n}\r\nSECT_PER_TRACK = end_sector;\r\n}\r\n}\r\nstatic int make_raw_rw_request(void)\r\n{\r\nint aligned_sector_t;\r\nint max_sector;\r\nint max_size;\r\nint tracksize;\r\nint ssize;\r\nif (WARN(max_buffer_sectors == 0, "VFS: Block I/O scheduled on unopened device\n"))\r\nreturn 0;\r\nset_fdc((long)current_req->rq_disk->private_data);\r\nraw_cmd = &default_raw_cmd;\r\nraw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK;\r\nraw_cmd->cmd_count = NR_RW;\r\nif (rq_data_dir(current_req) == READ) {\r\nraw_cmd->flags |= FD_RAW_READ;\r\nCOMMAND = FM_MODE(_floppy, FD_READ);\r\n} else if (rq_data_dir(current_req) == WRITE) {\r\nraw_cmd->flags |= FD_RAW_WRITE;\r\nCOMMAND = FM_MODE(_floppy, FD_WRITE);\r\n} else {\r\nDPRINT("%s: unknown command\n", __func__);\r\nreturn 0;\r\n}\r\nmax_sector = _floppy->sect * _floppy->head;\r\nTRACK = (int)blk_rq_pos(current_req) / max_sector;\r\nfsector_t = (int)blk_rq_pos(current_req) % max_sector;\r\nif (_floppy->track && TRACK >= _floppy->track) {\r\nif (blk_rq_cur_sectors(current_req) & 1) {\r\ncurrent_count_sectors = 1;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nHEAD = fsector_t / _floppy->sect;\r\nif (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) ||\r\ntest_bit(FD_NEED_TWADDLE_BIT, &DRS->flags)) &&\r\nfsector_t < _floppy->sect)\r\nmax_sector = _floppy->sect;\r\nif ((_floppy->rate & FD_2M) && (!TRACK) && (!HEAD)) {\r\nmax_sector = 2 * _floppy->sect / 3;\r\nif (fsector_t >= max_sector) {\r\ncurrent_count_sectors =\r\nmin_t(int, _floppy->sect - fsector_t,\r\nblk_rq_sectors(current_req));\r\nreturn 1;\r\n}\r\nSIZECODE = 2;\r\n} else\r\nSIZECODE = FD_SIZECODE(_floppy);\r\nraw_cmd->rate = _floppy->rate & 0x43;\r\nif ((_floppy->rate & FD_2M) && (TRACK || HEAD) && raw_cmd->rate == 2)\r\nraw_cmd->rate = 1;\r\nif (SIZECODE)\r\nSIZECODE2 = 0xff;\r\nelse\r\nSIZECODE2 = 0x80;\r\nraw_cmd->track = TRACK << STRETCH(_floppy);\r\nDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, HEAD);\r\nGAP = _floppy->gap;\r\nssize = DIV_ROUND_UP(1 << SIZECODE, 4);\r\nSECT_PER_TRACK = _floppy->sect << 2 >> SIZECODE;\r\nSECTOR = ((fsector_t % _floppy->sect) << 2 >> SIZECODE) +\r\nFD_SECTBASE(_floppy);\r\ntracksize = _floppy->sect - _floppy->sect % ssize;\r\nif (tracksize < _floppy->sect) {\r\nSECT_PER_TRACK++;\r\nif (tracksize <= fsector_t % _floppy->sect)\r\nSECTOR--;\r\nwhile (tracksize <= fsector_t % _floppy->sect) {\r\nwhile (tracksize + ssize > _floppy->sect) {\r\nSIZECODE--;\r\nssize >>= 1;\r\n}\r\nSECTOR++;\r\nSECT_PER_TRACK++;\r\ntracksize += ssize;\r\n}\r\nmax_sector = HEAD * _floppy->sect + tracksize;\r\n} else if (!TRACK && !HEAD && !(_floppy->rate & FD_2M) && probing) {\r\nmax_sector = _floppy->sect;\r\n} else if (!HEAD && CT(COMMAND) == FD_WRITE) {\r\nmax_sector = _floppy->sect;\r\n}\r\nin_sector_offset = (fsector_t % _floppy->sect) % ssize;\r\naligned_sector_t = fsector_t - in_sector_offset;\r\nmax_size = blk_rq_sectors(current_req);\r\nif ((raw_cmd->track == buffer_track) &&\r\n(current_drive == buffer_drive) &&\r\n(fsector_t >= buffer_min) && (fsector_t < buffer_max)) {\r\nif (CT(COMMAND) == FD_READ) {\r\ncopy_buffer(1, max_sector, buffer_max);\r\nreturn 1;\r\n}\r\n} else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {\r\nif (CT(COMMAND) == FD_WRITE) {\r\nunsigned int sectors;\r\nsectors = fsector_t + blk_rq_sectors(current_req);\r\nif (sectors > ssize && sectors < ssize + ssize)\r\nmax_size = ssize + ssize;\r\nelse\r\nmax_size = ssize;\r\n}\r\nraw_cmd->flags &= ~FD_RAW_WRITE;\r\nraw_cmd->flags |= FD_RAW_READ;\r\nCOMMAND = FM_MODE(_floppy, FD_READ);\r\n} else if ((unsigned long)bio_data(current_req->bio) < MAX_DMA_ADDRESS) {\r\nunsigned long dma_limit;\r\nint direct, indirect;\r\nindirect =\r\ntransfer_size(ssize, max_sector,\r\nmax_buffer_sectors * 2) - fsector_t;\r\nmax_size = buffer_chain_size();\r\ndma_limit = (MAX_DMA_ADDRESS -\r\n((unsigned long)bio_data(current_req->bio))) >> 9;\r\nif ((unsigned long)max_size > dma_limit)\r\nmax_size = dma_limit;\r\nif (CROSS_64KB(bio_data(current_req->bio), max_size << 9))\r\nmax_size = (K_64 -\r\n((unsigned long)bio_data(current_req->bio)) %\r\nK_64) >> 9;\r\ndirect = transfer_size(ssize, max_sector, max_size) - fsector_t;\r\nif (!direct ||\r\n(indirect * 2 > direct * 3 &&\r\n*errors < DP->max_errors.read_track &&\r\n((!probing ||\r\n(DP->read_track & (1 << DRS->probed_format)))))) {\r\nmax_size = blk_rq_sectors(current_req);\r\n} else {\r\nraw_cmd->kernel_data = bio_data(current_req->bio);\r\nraw_cmd->length = current_count_sectors << 9;\r\nif (raw_cmd->length == 0) {\r\nDPRINT("%s: zero dma transfer attempted\n", __func__);\r\nDPRINT("indirect=%d direct=%d fsector_t=%d\n",\r\nindirect, direct, fsector_t);\r\nreturn 0;\r\n}\r\nvirtualdmabug_workaround();\r\nreturn 2;\r\n}\r\n}\r\nif (CT(COMMAND) == FD_READ)\r\nmax_size = max_sector;\r\nif (buffer_track != raw_cmd->track ||\r\nbuffer_drive != current_drive ||\r\nfsector_t > buffer_max ||\r\nfsector_t < buffer_min ||\r\n((CT(COMMAND) == FD_READ ||\r\n(!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) &&\r\nmax_sector > 2 * max_buffer_sectors + buffer_min &&\r\nmax_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {\r\nbuffer_track = -1;\r\nbuffer_drive = current_drive;\r\nbuffer_max = buffer_min = aligned_sector_t;\r\n}\r\nraw_cmd->kernel_data = floppy_track_buffer +\r\n((aligned_sector_t - buffer_min) << 9);\r\nif (CT(COMMAND) == FD_WRITE) {\r\nif (in_sector_offset && buffer_track == -1)\r\nDPRINT("internal error offset !=0 on write\n");\r\nbuffer_track = raw_cmd->track;\r\nbuffer_drive = current_drive;\r\ncopy_buffer(ssize, max_sector,\r\n2 * max_buffer_sectors + buffer_min);\r\n} else\r\ntransfer_size(ssize, max_sector,\r\n2 * max_buffer_sectors + buffer_min -\r\naligned_sector_t);\r\nraw_cmd->length = in_sector_offset + current_count_sectors;\r\nraw_cmd->length = ((raw_cmd->length - 1) | (ssize - 1)) + 1;\r\nraw_cmd->length <<= 9;\r\nif ((raw_cmd->length < current_count_sectors << 9) ||\r\n(raw_cmd->kernel_data != bio_data(current_req->bio) &&\r\nCT(COMMAND) == FD_WRITE &&\r\n(aligned_sector_t + (raw_cmd->length >> 9) > buffer_max ||\r\naligned_sector_t < buffer_min)) ||\r\nraw_cmd->length % (128 << SIZECODE) ||\r\nraw_cmd->length <= 0 || current_count_sectors <= 0) {\r\nDPRINT("fractionary current count b=%lx s=%lx\n",\r\nraw_cmd->length, current_count_sectors);\r\nif (raw_cmd->kernel_data != bio_data(current_req->bio))\r\npr_info("addr=%d, length=%ld\n",\r\n(int)((raw_cmd->kernel_data -\r\nfloppy_track_buffer) >> 9),\r\ncurrent_count_sectors);\r\npr_info("st=%d ast=%d mse=%d msi=%d\n",\r\nfsector_t, aligned_sector_t, max_sector, max_size);\r\npr_info("ssize=%x SIZECODE=%d\n", ssize, SIZECODE);\r\npr_info("command=%x SECTOR=%d HEAD=%d, TRACK=%d\n",\r\nCOMMAND, SECTOR, HEAD, TRACK);\r\npr_info("buffer drive=%d\n", buffer_drive);\r\npr_info("buffer track=%d\n", buffer_track);\r\npr_info("buffer_min=%d\n", buffer_min);\r\npr_info("buffer_max=%d\n", buffer_max);\r\nreturn 0;\r\n}\r\nif (raw_cmd->kernel_data != bio_data(current_req->bio)) {\r\nif (raw_cmd->kernel_data < floppy_track_buffer ||\r\ncurrent_count_sectors < 0 ||\r\nraw_cmd->length < 0 ||\r\nraw_cmd->kernel_data + raw_cmd->length >\r\nfloppy_track_buffer + (max_buffer_sectors << 10)) {\r\nDPRINT("buffer overrun in schedule dma\n");\r\npr_info("fsector_t=%d buffer_min=%d current_count=%ld\n",\r\nfsector_t, buffer_min, raw_cmd->length >> 9);\r\npr_info("current_count_sectors=%ld\n",\r\ncurrent_count_sectors);\r\nif (CT(COMMAND) == FD_READ)\r\npr_info("read\n");\r\nif (CT(COMMAND) == FD_WRITE)\r\npr_info("write\n");\r\nreturn 0;\r\n}\r\n} else if (raw_cmd->length > blk_rq_bytes(current_req) ||\r\ncurrent_count_sectors > blk_rq_sectors(current_req)) {\r\nDPRINT("buffer overrun in direct transfer\n");\r\nreturn 0;\r\n} else if (raw_cmd->length < current_count_sectors << 9) {\r\nDPRINT("more sectors than bytes\n");\r\npr_info("bytes=%ld\n", raw_cmd->length >> 9);\r\npr_info("sectors=%ld\n", current_count_sectors);\r\n}\r\nif (raw_cmd->length == 0) {\r\nDPRINT("zero dma transfer attempted from make_raw_request\n");\r\nreturn 0;\r\n}\r\nvirtualdmabug_workaround();\r\nreturn 2;\r\n}\r\nstatic int set_next_request(void)\r\n{\r\nstruct request_queue *q;\r\nint old_pos = fdc_queue;\r\ndo {\r\nq = disks[fdc_queue]->queue;\r\nif (++fdc_queue == N_DRIVE)\r\nfdc_queue = 0;\r\nif (q) {\r\ncurrent_req = blk_fetch_request(q);\r\nif (current_req)\r\nbreak;\r\n}\r\n} while (fdc_queue != old_pos);\r\nreturn current_req != NULL;\r\n}\r\nstatic void redo_fd_request(void)\r\n{\r\nint drive;\r\nint tmp;\r\nlastredo = jiffies;\r\nif (current_drive < N_DRIVE)\r\nfloppy_off(current_drive);\r\ndo_request:\r\nif (!current_req) {\r\nint pending;\r\nspin_lock_irq(&floppy_lock);\r\npending = set_next_request();\r\nspin_unlock_irq(&floppy_lock);\r\nif (!pending) {\r\ndo_floppy = NULL;\r\nunlock_fdc();\r\nreturn;\r\n}\r\n}\r\ndrive = (long)current_req->rq_disk->private_data;\r\nset_fdc(drive);\r\nreschedule_timeout(current_reqD, "redo fd request");\r\nset_floppy(drive);\r\nraw_cmd = &default_raw_cmd;\r\nraw_cmd->flags = 0;\r\nif (start_motor(redo_fd_request))\r\nreturn;\r\ndisk_change(current_drive);\r\nif (test_bit(current_drive, &fake_change) ||\r\ntest_bit(FD_DISK_CHANGED_BIT, &DRS->flags)) {\r\nDPRINT("disk absent or changed during operation\n");\r\nrequest_done(0);\r\ngoto do_request;\r\n}\r\nif (!_floppy) {\r\nif (!probing) {\r\nDRS->probed_format = 0;\r\nif (next_valid_format()) {\r\nDPRINT("no autodetectable formats\n");\r\n_floppy = NULL;\r\nrequest_done(0);\r\ngoto do_request;\r\n}\r\n}\r\nprobing = 1;\r\n_floppy = floppy_type + DP->autodetect[DRS->probed_format];\r\n} else\r\nprobing = 0;\r\nerrors = &(current_req->errors);\r\ntmp = make_raw_rw_request();\r\nif (tmp < 2) {\r\nrequest_done(tmp);\r\ngoto do_request;\r\n}\r\nif (test_bit(FD_NEED_TWADDLE_BIT, &DRS->flags))\r\ntwaddle();\r\nschedule_bh(floppy_start);\r\ndebugt(__func__, "queue fd request");\r\nreturn;\r\n}\r\nstatic void process_fd_request(void)\r\n{\r\ncont = &rw_cont;\r\nschedule_bh(redo_fd_request);\r\n}\r\nstatic void do_fd_request(struct request_queue *q)\r\n{\r\nif (WARN(max_buffer_sectors == 0,\r\n"VFS: %s called on non-open device\n", __func__))\r\nreturn;\r\nif (WARN(atomic_read(&usage_count) == 0,\r\n"warning: usage count=0, current_req=%p sect=%ld type=%x flags=%llx\n",\r\ncurrent_req, (long)blk_rq_pos(current_req), current_req->cmd_type,\r\n(unsigned long long) current_req->cmd_flags))\r\nreturn;\r\nif (test_and_set_bit(0, &fdc_busy)) {\r\nis_alive(__func__, "old request running");\r\nreturn;\r\n}\r\ncommand_status = FD_COMMAND_NONE;\r\n__reschedule_timeout(MAXTIMEOUT, "fd_request");\r\nset_fdc(0);\r\nprocess_fd_request();\r\nis_alive(__func__, "");\r\n}\r\nstatic int poll_drive(bool interruptible, int flag)\r\n{\r\nraw_cmd = &default_raw_cmd;\r\nraw_cmd->flags = flag;\r\nraw_cmd->track = 0;\r\nraw_cmd->cmd_count = 0;\r\ncont = &poll_cont;\r\ndebug_dcl(DP->flags, "setting NEWCHANGE in poll_drive\n");\r\nset_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\r\nreturn wait_til_done(floppy_ready, interruptible);\r\n}\r\nstatic void reset_intr(void)\r\n{\r\npr_info("weird, reset interrupt called\n");\r\n}\r\nstatic int user_reset_fdc(int drive, int arg, bool interruptible)\r\n{\r\nint ret;\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nif (arg == FD_RESET_ALWAYS)\r\nFDCS->reset = 1;\r\nif (FDCS->reset) {\r\ncont = &reset_cont;\r\nret = wait_til_done(reset_fdc, interruptible);\r\nif (ret == -EINTR)\r\nreturn -EINTR;\r\n}\r\nprocess_fd_request();\r\nreturn 0;\r\n}\r\nstatic inline int fd_copyout(void __user *param, const void *address,\r\nunsigned long size)\r\n{\r\nreturn copy_to_user(param, address, size) ? -EFAULT : 0;\r\n}\r\nstatic inline int fd_copyin(void __user *param, void *address,\r\nunsigned long size)\r\n{\r\nreturn copy_from_user(address, param, size) ? -EFAULT : 0;\r\n}\r\nstatic const char *drive_name(int type, int drive)\r\n{\r\nstruct floppy_struct *floppy;\r\nif (type)\r\nfloppy = floppy_type + type;\r\nelse {\r\nif (UDP->native_format)\r\nfloppy = floppy_type + UDP->native_format;\r\nelse\r\nreturn "(null)";\r\n}\r\nif (floppy->name)\r\nreturn floppy->name;\r\nelse\r\nreturn "(null)";\r\n}\r\nstatic void raw_cmd_done(int flag)\r\n{\r\nint i;\r\nif (!flag) {\r\nraw_cmd->flags |= FD_RAW_FAILURE;\r\nraw_cmd->flags |= FD_RAW_HARDFAILURE;\r\n} else {\r\nraw_cmd->reply_count = inr;\r\nif (raw_cmd->reply_count > MAX_REPLIES)\r\nraw_cmd->reply_count = 0;\r\nfor (i = 0; i < raw_cmd->reply_count; i++)\r\nraw_cmd->reply[i] = reply_buffer[i];\r\nif (raw_cmd->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\r\nunsigned long flags;\r\nflags = claim_dma_lock();\r\nraw_cmd->length = fd_get_dma_residue();\r\nrelease_dma_lock(flags);\r\n}\r\nif ((raw_cmd->flags & FD_RAW_SOFTFAILURE) &&\r\n(!raw_cmd->reply_count || (raw_cmd->reply[0] & 0xc0)))\r\nraw_cmd->flags |= FD_RAW_FAILURE;\r\nif (disk_change(current_drive))\r\nraw_cmd->flags |= FD_RAW_DISK_CHANGE;\r\nelse\r\nraw_cmd->flags &= ~FD_RAW_DISK_CHANGE;\r\nif (raw_cmd->flags & FD_RAW_NO_MOTOR_AFTER)\r\nmotor_off_callback(current_drive);\r\nif (raw_cmd->next &&\r\n(!(raw_cmd->flags & FD_RAW_FAILURE) ||\r\n!(raw_cmd->flags & FD_RAW_STOP_IF_FAILURE)) &&\r\n((raw_cmd->flags & FD_RAW_FAILURE) ||\r\n!(raw_cmd->flags & FD_RAW_STOP_IF_SUCCESS))) {\r\nraw_cmd = raw_cmd->next;\r\nreturn;\r\n}\r\n}\r\ngeneric_done(flag);\r\n}\r\nstatic int raw_cmd_copyout(int cmd, void __user *param,\r\nstruct floppy_raw_cmd *ptr)\r\n{\r\nint ret;\r\nwhile (ptr) {\r\nstruct floppy_raw_cmd cmd = *ptr;\r\ncmd.next = NULL;\r\ncmd.kernel_data = NULL;\r\nret = copy_to_user(param, &cmd, sizeof(cmd));\r\nif (ret)\r\nreturn -EFAULT;\r\nparam += sizeof(struct floppy_raw_cmd);\r\nif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\r\nif (ptr->length >= 0 &&\r\nptr->length <= ptr->buffer_length) {\r\nlong length = ptr->buffer_length - ptr->length;\r\nret = fd_copyout(ptr->data, ptr->kernel_data,\r\nlength);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nptr = ptr->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic void raw_cmd_free(struct floppy_raw_cmd **ptr)\r\n{\r\nstruct floppy_raw_cmd *next;\r\nstruct floppy_raw_cmd *this;\r\nthis = *ptr;\r\n*ptr = NULL;\r\nwhile (this) {\r\nif (this->buffer_length) {\r\nfd_dma_mem_free((unsigned long)this->kernel_data,\r\nthis->buffer_length);\r\nthis->buffer_length = 0;\r\n}\r\nnext = this->next;\r\nkfree(this);\r\nthis = next;\r\n}\r\n}\r\nstatic int raw_cmd_copyin(int cmd, void __user *param,\r\nstruct floppy_raw_cmd **rcmd)\r\n{\r\nstruct floppy_raw_cmd *ptr;\r\nint ret;\r\nint i;\r\n*rcmd = NULL;\r\nloop:\r\nptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\r\nif (!ptr)\r\nreturn -ENOMEM;\r\n*rcmd = ptr;\r\nret = copy_from_user(ptr, param, sizeof(*ptr));\r\nptr->next = NULL;\r\nptr->buffer_length = 0;\r\nptr->kernel_data = NULL;\r\nif (ret)\r\nreturn -EFAULT;\r\nparam += sizeof(struct floppy_raw_cmd);\r\nif (ptr->cmd_count > 33)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 16; i++)\r\nptr->reply[i] = 0;\r\nptr->resultcode = 0;\r\nif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\r\nif (ptr->length <= 0)\r\nreturn -EINVAL;\r\nptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\r\nfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\r\nif (!ptr->kernel_data)\r\nreturn -ENOMEM;\r\nptr->buffer_length = ptr->length;\r\n}\r\nif (ptr->flags & FD_RAW_WRITE) {\r\nret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (ptr->flags & FD_RAW_MORE) {\r\nrcmd = &(ptr->next);\r\nptr->rate &= 0x43;\r\ngoto loop;\r\n}\r\nreturn 0;\r\n}\r\nstatic int raw_cmd_ioctl(int cmd, void __user *param)\r\n{\r\nstruct floppy_raw_cmd *my_raw_cmd;\r\nint drive;\r\nint ret2;\r\nint ret;\r\nif (FDCS->rawcmd <= 1)\r\nFDCS->rawcmd = 1;\r\nfor (drive = 0; drive < N_DRIVE; drive++) {\r\nif (FDC(drive) != fdc)\r\ncontinue;\r\nif (drive == current_drive) {\r\nif (UDRS->fd_ref > 1) {\r\nFDCS->rawcmd = 2;\r\nbreak;\r\n}\r\n} else if (UDRS->fd_ref) {\r\nFDCS->rawcmd = 2;\r\nbreak;\r\n}\r\n}\r\nif (FDCS->reset)\r\nreturn -EIO;\r\nret = raw_cmd_copyin(cmd, param, &my_raw_cmd);\r\nif (ret) {\r\nraw_cmd_free(&my_raw_cmd);\r\nreturn ret;\r\n}\r\nraw_cmd = my_raw_cmd;\r\ncont = &raw_cmd_cont;\r\nret = wait_til_done(floppy_start, true);\r\ndebug_dcl(DP->flags, "calling disk change from raw_cmd ioctl\n");\r\nif (ret != -EINTR && FDCS->reset)\r\nret = -EIO;\r\nDRS->track = NO_TRACK;\r\nret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);\r\nif (!ret)\r\nret = ret2;\r\nraw_cmd_free(&my_raw_cmd);\r\nreturn ret;\r\n}\r\nstatic int invalidate_drive(struct block_device *bdev)\r\n{\r\nset_bit((long)bdev->bd_disk->private_data, &fake_change);\r\nprocess_fd_request();\r\ncheck_disk_change(bdev);\r\nreturn 0;\r\n}\r\nstatic int set_geometry(unsigned int cmd, struct floppy_struct *g,\r\nint drive, int type, struct block_device *bdev)\r\n{\r\nint cnt;\r\nif (g->sect <= 0 ||\r\ng->head <= 0 ||\r\ng->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||\r\n(g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\r\nreturn -EINVAL;\r\nif (type) {\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nmutex_lock(&open_lock);\r\nif (lock_fdc(drive)) {\r\nmutex_unlock(&open_lock);\r\nreturn -EINTR;\r\n}\r\nfloppy_type[type] = *g;\r\nfloppy_type[type].name = "user format";\r\nfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\r\nfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\r\nfloppy_type[type].size + 1;\r\nprocess_fd_request();\r\nfor (cnt = 0; cnt < N_DRIVE; cnt++) {\r\nstruct block_device *bdev = opened_bdev[cnt];\r\nif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\r\ncontinue;\r\n__invalidate_device(bdev, true);\r\n}\r\nmutex_unlock(&open_lock);\r\n} else {\r\nint oldStretch;\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nif (cmd != FDDEFPRM) {\r\nif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\r\nreturn -EINTR;\r\n}\r\noldStretch = g->stretch;\r\nuser_params[drive] = *g;\r\nif (buffer_drive == drive)\r\nSUPBOUND(buffer_max, user_params[drive].sect);\r\ncurrent_type[drive] = &user_params[drive];\r\nfloppy_sizes[drive] = user_params[drive].size;\r\nif (cmd == FDDEFPRM)\r\nDRS->keep_data = -1;\r\nelse\r\nDRS->keep_data = 1;\r\nif (DRS->maxblock > user_params[drive].sect ||\r\nDRS->maxtrack ||\r\n((user_params[drive].sect ^ oldStretch) &\r\n(FD_SWAPSIDES | FD_SECTBASEMASK)))\r\ninvalidate_drive(bdev);\r\nelse\r\nprocess_fd_request();\r\n}\r\nreturn 0;\r\n}\r\nstatic int normalize_ioctl(unsigned int *cmd, int *size)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ioctl_table); i++) {\r\nif ((*cmd & 0xffff) == (ioctl_table[i] & 0xffff)) {\r\n*size = _IOC_SIZE(*cmd);\r\n*cmd = ioctl_table[i];\r\nif (*size > _IOC_SIZE(*cmd)) {\r\npr_info("ioctl not yet supported\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int get_floppy_geometry(int drive, int type, struct floppy_struct **g)\r\n{\r\nif (type)\r\n*g = &floppy_type[type];\r\nelse {\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nif (poll_drive(false, 0) == -EINTR)\r\nreturn -EINTR;\r\nprocess_fd_request();\r\n*g = current_type[drive];\r\n}\r\nif (!*g)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nint drive = (long)bdev->bd_disk->private_data;\r\nint type = ITYPE(drive_state[drive].fd_device);\r\nstruct floppy_struct *g;\r\nint ret;\r\nret = get_floppy_geometry(drive, type, &g);\r\nif (ret)\r\nreturn ret;\r\ngeo->heads = g->head;\r\ngeo->sectors = g->sect;\r\ngeo->cylinders = g->track;\r\nreturn 0;\r\n}\r\nstatic int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\r\nunsigned long param)\r\n{\r\nint drive = (long)bdev->bd_disk->private_data;\r\nint type = ITYPE(UDRS->fd_device);\r\nint i;\r\nint ret;\r\nint size;\r\nunion inparam {\r\nstruct floppy_struct g;\r\nstruct format_descr f;\r\nstruct floppy_max_errors max_errors;\r\nstruct floppy_drive_params dp;\r\n} inparam;\r\nconst void *outparam;\r\nif (cmd == CDROMEJECT ||\r\ncmd == 0x6470) {\r\nDPRINT("obsolete eject ioctl\n");\r\nDPRINT("please use floppycontrol --eject\n");\r\ncmd = FDEJECT;\r\n}\r\nif (!((cmd & 0xff00) == 0x0200))\r\nreturn -EINVAL;\r\nret = normalize_ioctl(&cmd, &size);\r\nif (ret)\r\nreturn ret;\r\nif (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||\r\n((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))\r\nreturn -EPERM;\r\nif (WARN_ON(size < 0 || size > sizeof(inparam)))\r\nreturn -EINVAL;\r\nmemset(&inparam, 0, sizeof(inparam));\r\nif (_IOC_DIR(cmd) & _IOC_WRITE) {\r\nret = fd_copyin((void __user *)param, &inparam, size);\r\nif (ret)\r\nreturn ret;\r\n}\r\nswitch (cmd) {\r\ncase FDEJECT:\r\nif (UDRS->fd_ref != 1)\r\nreturn -EBUSY;\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nret = fd_eject(UNIT(drive));\r\nset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\r\nset_bit(FD_VERIFY_BIT, &UDRS->flags);\r\nprocess_fd_request();\r\nreturn ret;\r\ncase FDCLRPRM:\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\ncurrent_type[drive] = NULL;\r\nfloppy_sizes[drive] = MAX_DISK_SIZE << 1;\r\nUDRS->keep_data = 0;\r\nreturn invalidate_drive(bdev);\r\ncase FDSETPRM:\r\ncase FDDEFPRM:\r\nreturn set_geometry(cmd, &inparam.g, drive, type, bdev);\r\ncase FDGETPRM:\r\nret = get_floppy_geometry(drive, type,\r\n(struct floppy_struct **)&outparam);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase FDMSGON:\r\nUDP->flags |= FTD_MSG;\r\nreturn 0;\r\ncase FDMSGOFF:\r\nUDP->flags &= ~FTD_MSG;\r\nreturn 0;\r\ncase FDFMTBEG:\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\r\nreturn -EINTR;\r\nret = UDRS->flags;\r\nprocess_fd_request();\r\nif (ret & FD_VERIFY)\r\nreturn -ENODEV;\r\nif (!(ret & FD_DISK_WRITABLE))\r\nreturn -EROFS;\r\nreturn 0;\r\ncase FDFMTTRK:\r\nif (UDRS->fd_ref != 1)\r\nreturn -EBUSY;\r\nreturn do_format(drive, &inparam.f);\r\ncase FDFMTEND:\r\ncase FDFLUSH:\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nreturn invalidate_drive(bdev);\r\ncase FDSETEMSGTRESH:\r\nUDP->max_errors.reporting = (unsigned short)(param & 0x0f);\r\nreturn 0;\r\ncase FDGETMAXERRS:\r\noutparam = &UDP->max_errors;\r\nbreak;\r\ncase FDSETMAXERRS:\r\nUDP->max_errors = inparam.max_errors;\r\nbreak;\r\ncase FDGETDRVTYP:\r\noutparam = drive_name(type, drive);\r\nSUPBOUND(size, strlen((const char *)outparam) + 1);\r\nbreak;\r\ncase FDSETDRVPRM:\r\n*UDP = inparam.dp;\r\nbreak;\r\ncase FDGETDRVPRM:\r\noutparam = UDP;\r\nbreak;\r\ncase FDPOLLDRVSTAT:\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\r\nreturn -EINTR;\r\nprocess_fd_request();\r\ncase FDGETDRVSTAT:\r\noutparam = UDRS;\r\nbreak;\r\ncase FDRESET:\r\nreturn user_reset_fdc(drive, (int)param, true);\r\ncase FDGETFDCSTAT:\r\noutparam = UFDCS;\r\nbreak;\r\ncase FDWERRORCLR:\r\nmemset(UDRWE, 0, sizeof(*UDRWE));\r\nreturn 0;\r\ncase FDWERRORGET:\r\noutparam = UDRWE;\r\nbreak;\r\ncase FDRAWCMD:\r\nif (type)\r\nreturn -EINVAL;\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\nset_floppy(drive);\r\ni = raw_cmd_ioctl(cmd, (void __user *)param);\r\nif (i == -EINTR)\r\nreturn -EINTR;\r\nprocess_fd_request();\r\nreturn i;\r\ncase FDTWADDLE:\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\ntwaddle();\r\nprocess_fd_request();\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (_IOC_DIR(cmd) & _IOC_READ)\r\nreturn fd_copyout((void __user *)param, outparam, size);\r\nreturn 0;\r\n}\r\nstatic int fd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nint ret;\r\nmutex_lock(&floppy_mutex);\r\nret = fd_locked_ioctl(bdev, mode, cmd, param);\r\nmutex_unlock(&floppy_mutex);\r\nreturn ret;\r\n}\r\nstatic void __init config_types(void)\r\n{\r\nbool has_drive = false;\r\nint drive;\r\ndrive = 0;\r\nif (!UDP->cmos)\r\nUDP->cmos = FLOPPY0_TYPE;\r\ndrive = 1;\r\nif (!UDP->cmos && FLOPPY1_TYPE)\r\nUDP->cmos = FLOPPY1_TYPE;\r\nfor (drive = 0; drive < N_DRIVE; drive++) {\r\nunsigned int type = UDP->cmos;\r\nstruct floppy_drive_params *params;\r\nconst char *name = NULL;\r\nchar temparea[32];\r\nif (type < ARRAY_SIZE(default_drive_params)) {\r\nparams = &default_drive_params[type].params;\r\nif (type) {\r\nname = default_drive_params[type].name;\r\nallowed_drive_mask |= 1 << drive;\r\n} else\r\nallowed_drive_mask &= ~(1 << drive);\r\n} else {\r\nparams = &default_drive_params[0].params;\r\nsnprintf(temparea, sizeof(temparea),\r\n"unknown type %d (usb?)", type);\r\nname = temparea;\r\n}\r\nif (name) {\r\nconst char *prepend;\r\nif (!has_drive) {\r\nprepend = "";\r\nhas_drive = true;\r\npr_info("Floppy drive(s):");\r\n} else {\r\nprepend = ",";\r\n}\r\npr_cont("%s fd%d is %s", prepend, drive, name);\r\n}\r\n*UDP = *params;\r\n}\r\nif (has_drive)\r\npr_cont("\n");\r\n}\r\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nint drive = (long)disk->private_data;\r\nmutex_lock(&floppy_mutex);\r\nmutex_lock(&open_lock);\r\nif (!UDRS->fd_ref--) {\r\nDPRINT("floppy_release with fd_ref == 0");\r\nUDRS->fd_ref = 0;\r\n}\r\nif (!UDRS->fd_ref)\r\nopened_bdev[drive] = NULL;\r\nmutex_unlock(&open_lock);\r\nmutex_unlock(&floppy_mutex);\r\n}\r\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint drive = (long)bdev->bd_disk->private_data;\r\nint old_dev, new_dev;\r\nint try;\r\nint res = -EBUSY;\r\nchar *tmp;\r\nmutex_lock(&floppy_mutex);\r\nmutex_lock(&open_lock);\r\nold_dev = UDRS->fd_device;\r\nif (opened_bdev[drive] && opened_bdev[drive] != bdev)\r\ngoto out2;\r\nif (!UDRS->fd_ref && (UDP->flags & FD_BROKEN_DCL)) {\r\nset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\r\nset_bit(FD_VERIFY_BIT, &UDRS->flags);\r\n}\r\nUDRS->fd_ref++;\r\nopened_bdev[drive] = bdev;\r\nres = -ENXIO;\r\nif (!floppy_track_buffer) {\r\nif ((UDP->cmos == 6) || (UDP->cmos == 5))\r\ntry = 64;\r\nelse\r\ntry = 32;\r\ntmp = (char *)fd_dma_mem_alloc(1024 * try);\r\nif (!tmp && !floppy_track_buffer) {\r\ntry >>= 1;\r\nINFBOUND(try, 16);\r\ntmp = (char *)fd_dma_mem_alloc(1024 * try);\r\n}\r\nif (!tmp && !floppy_track_buffer)\r\nfallback_on_nodma_alloc(&tmp, 2048 * try);\r\nif (!tmp && !floppy_track_buffer) {\r\nDPRINT("Unable to allocate DMA memory\n");\r\ngoto out;\r\n}\r\nif (floppy_track_buffer) {\r\nif (tmp)\r\nfd_dma_mem_free((unsigned long)tmp, try * 1024);\r\n} else {\r\nbuffer_min = buffer_max = -1;\r\nfloppy_track_buffer = tmp;\r\nmax_buffer_sectors = try;\r\n}\r\n}\r\nnew_dev = MINOR(bdev->bd_dev);\r\nUDRS->fd_device = new_dev;\r\nset_capacity(disks[drive], floppy_sizes[new_dev]);\r\nif (old_dev != -1 && old_dev != new_dev) {\r\nif (buffer_drive == drive)\r\nbuffer_track = -1;\r\n}\r\nif (UFDCS->rawcmd == 1)\r\nUFDCS->rawcmd = 2;\r\nif (!(mode & FMODE_NDELAY)) {\r\nif (mode & (FMODE_READ|FMODE_WRITE)) {\r\nUDRS->last_checked = 0;\r\nclear_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags);\r\ncheck_disk_change(bdev);\r\nif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags))\r\ngoto out;\r\nif (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags))\r\ngoto out;\r\n}\r\nres = -EROFS;\r\nif ((mode & FMODE_WRITE) &&\r\n!test_bit(FD_DISK_WRITABLE_BIT, &UDRS->flags))\r\ngoto out;\r\n}\r\nmutex_unlock(&open_lock);\r\nmutex_unlock(&floppy_mutex);\r\nreturn 0;\r\nout:\r\nUDRS->fd_ref--;\r\nif (!UDRS->fd_ref)\r\nopened_bdev[drive] = NULL;\r\nout2:\r\nmutex_unlock(&open_lock);\r\nmutex_unlock(&floppy_mutex);\r\nreturn res;\r\n}\r\nstatic unsigned int floppy_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nint drive = (long)disk->private_data;\r\nif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\r\ntest_bit(FD_VERIFY_BIT, &UDRS->flags))\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\nif (time_after(jiffies, UDRS->last_checked + UDP->checkfreq)) {\r\nif (lock_fdc(drive))\r\nreturn -EINTR;\r\npoll_drive(false, 0);\r\nprocess_fd_request();\r\n}\r\nif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\r\ntest_bit(FD_VERIFY_BIT, &UDRS->flags) ||\r\ntest_bit(drive, &fake_change) ||\r\ndrive_no_geom(drive))\r\nreturn DISK_EVENT_MEDIA_CHANGE;\r\nreturn 0;\r\n}\r\nstatic void floppy_rb0_cb(struct bio *bio)\r\n{\r\nstruct rb0_cbdata *cbdata = (struct rb0_cbdata *)bio->bi_private;\r\nint drive = cbdata->drive;\r\nif (bio->bi_error) {\r\npr_info("floppy: error %d while reading block 0\n",\r\nbio->bi_error);\r\nset_bit(FD_OPEN_SHOULD_FAIL_BIT, &UDRS->flags);\r\n}\r\ncomplete(&cbdata->complete);\r\n}\r\nstatic int __floppy_read_block_0(struct block_device *bdev, int drive)\r\n{\r\nstruct bio bio;\r\nstruct bio_vec bio_vec;\r\nstruct page *page;\r\nstruct rb0_cbdata cbdata;\r\nsize_t size;\r\npage = alloc_page(GFP_NOIO);\r\nif (!page) {\r\nprocess_fd_request();\r\nreturn -ENOMEM;\r\n}\r\nsize = bdev->bd_block_size;\r\nif (!size)\r\nsize = 1024;\r\ncbdata.drive = drive;\r\nbio_init(&bio);\r\nbio.bi_io_vec = &bio_vec;\r\nbio_vec.bv_page = page;\r\nbio_vec.bv_len = size;\r\nbio_vec.bv_offset = 0;\r\nbio.bi_vcnt = 1;\r\nbio.bi_iter.bi_size = size;\r\nbio.bi_bdev = bdev;\r\nbio.bi_iter.bi_sector = 0;\r\nbio.bi_flags |= (1 << BIO_QUIET);\r\nbio.bi_private = &cbdata;\r\nbio.bi_end_io = floppy_rb0_cb;\r\nbio_set_op_attrs(&bio, REQ_OP_READ, 0);\r\nsubmit_bio(&bio);\r\nprocess_fd_request();\r\ninit_completion(&cbdata.complete);\r\nwait_for_completion(&cbdata.complete);\r\n__free_page(page);\r\nreturn 0;\r\n}\r\nstatic int floppy_revalidate(struct gendisk *disk)\r\n{\r\nint drive = (long)disk->private_data;\r\nint cf;\r\nint res = 0;\r\nif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\r\ntest_bit(FD_VERIFY_BIT, &UDRS->flags) ||\r\ntest_bit(drive, &fake_change) ||\r\ndrive_no_geom(drive)) {\r\nif (WARN(atomic_read(&usage_count) == 0,\r\n"VFS: revalidate called on non-open device.\n"))\r\nreturn -EFAULT;\r\nres = lock_fdc(drive);\r\nif (res)\r\nreturn res;\r\ncf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\r\ntest_bit(FD_VERIFY_BIT, &UDRS->flags));\r\nif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\r\nprocess_fd_request();\r\nreturn 0;\r\n}\r\nUDRS->maxblock = 0;\r\nUDRS->maxtrack = 0;\r\nif (buffer_drive == drive)\r\nbuffer_track = -1;\r\nclear_bit(drive, &fake_change);\r\nclear_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\r\nif (cf)\r\nUDRS->generation++;\r\nif (drive_no_geom(drive)) {\r\nres = __floppy_read_block_0(opened_bdev[drive], drive);\r\n} else {\r\nif (cf)\r\npoll_drive(false, FD_RAW_NEED_DISK);\r\nprocess_fd_request();\r\n}\r\n}\r\nset_capacity(disk, floppy_sizes[UDRS->fd_device]);\r\nreturn res;\r\n}\r\nstatic char __init get_fdc_version(void)\r\n{\r\nint r;\r\noutput_byte(FD_DUMPREGS);\r\nif (FDCS->reset)\r\nreturn FDC_NONE;\r\nr = result();\r\nif (r <= 0x00)\r\nreturn FDC_NONE;\r\nif ((r == 1) && (reply_buffer[0] == 0x80)) {\r\npr_info("FDC %d is an 8272A\n", fdc);\r\nreturn FDC_8272A;\r\n}\r\nif (r != 10) {\r\npr_info("FDC %d init: DUMPREGS: unexpected return of %d bytes.\n",\r\nfdc, r);\r\nreturn FDC_UNKNOWN;\r\n}\r\nif (!fdc_configure()) {\r\npr_info("FDC %d is an 82072\n", fdc);\r\nreturn FDC_82072;\r\n}\r\noutput_byte(FD_PERPENDICULAR);\r\nif (need_more_output() == MORE_OUTPUT) {\r\noutput_byte(0);\r\n} else {\r\npr_info("FDC %d is an 82072A\n", fdc);\r\nreturn FDC_82072A;\r\n}\r\noutput_byte(FD_UNLOCK);\r\nr = result();\r\nif ((r == 1) && (reply_buffer[0] == 0x80)) {\r\npr_info("FDC %d is a pre-1991 82077\n", fdc);\r\nreturn FDC_82077_ORIG;\r\n}\r\nif ((r != 1) || (reply_buffer[0] != 0x00)) {\r\npr_info("FDC %d init: UNLOCK: unexpected return of %d bytes.\n",\r\nfdc, r);\r\nreturn FDC_UNKNOWN;\r\n}\r\noutput_byte(FD_PARTID);\r\nr = result();\r\nif (r != 1) {\r\npr_info("FDC %d init: PARTID: unexpected return of %d bytes.\n",\r\nfdc, r);\r\nreturn FDC_UNKNOWN;\r\n}\r\nif (reply_buffer[0] == 0x80) {\r\npr_info("FDC %d is a post-1991 82077\n", fdc);\r\nreturn FDC_82077;\r\n}\r\nswitch (reply_buffer[0] >> 5) {\r\ncase 0x0:\r\npr_info("FDC %d is an 82078.\n", fdc);\r\nreturn FDC_82078;\r\ncase 0x1:\r\npr_info("FDC %d is a 44pin 82078\n", fdc);\r\nreturn FDC_82078;\r\ncase 0x2:\r\npr_info("FDC %d is a S82078B\n", fdc);\r\nreturn FDC_S82078B;\r\ncase 0x3:\r\npr_info("FDC %d is a National Semiconductor PC87306\n", fdc);\r\nreturn FDC_87306;\r\ndefault:\r\npr_info("FDC %d init: 82078 variant with unknown PARTID=%d.\n",\r\nfdc, reply_buffer[0] >> 5);\r\nreturn FDC_82078_UNKN;\r\n}\r\n}\r\nstatic void __init floppy_set_flags(int *ints, int param, int param2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\r\nif (param)\r\ndefault_drive_params[i].params.flags |= param2;\r\nelse\r\ndefault_drive_params[i].params.flags &= ~param2;\r\n}\r\nDPRINT("%s flag 0x%x\n", param2 ? "Setting" : "Clearing", param);\r\n}\r\nstatic void __init daring(int *ints, int param, int param2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\r\nif (param) {\r\ndefault_drive_params[i].params.select_delay = 0;\r\ndefault_drive_params[i].params.flags |=\r\nFD_SILENT_DCL_CLEAR;\r\n} else {\r\ndefault_drive_params[i].params.select_delay =\r\n2 * HZ / 100;\r\ndefault_drive_params[i].params.flags &=\r\n~FD_SILENT_DCL_CLEAR;\r\n}\r\n}\r\nDPRINT("Assuming %s floppy hardware\n", param ? "standard" : "broken");\r\n}\r\nstatic void __init set_cmos(int *ints, int dummy, int dummy2)\r\n{\r\nint current_drive = 0;\r\nif (ints[0] != 2) {\r\nDPRINT("wrong number of parameters for CMOS\n");\r\nreturn;\r\n}\r\ncurrent_drive = ints[1];\r\nif (current_drive < 0 || current_drive >= 8) {\r\nDPRINT("bad drive for set_cmos\n");\r\nreturn;\r\n}\r\n#if N_FDC > 1\r\nif (current_drive >= 4 && !FDC2)\r\nFDC2 = 0x370;\r\n#endif\r\nDP->cmos = ints[2];\r\nDPRINT("setting CMOS code to %d\n", ints[2]);\r\n}\r\nstatic int __init floppy_setup(char *str)\r\n{\r\nint i;\r\nint param;\r\nint ints[11];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nif (str) {\r\nfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\r\nif (strcmp(str, config_params[i].name) == 0) {\r\nif (ints[0])\r\nparam = ints[1];\r\nelse\r\nparam = config_params[i].def_param;\r\nif (config_params[i].fn)\r\nconfig_params[i].fn(ints, param,\r\nconfig_params[i].\r\nparam2);\r\nif (config_params[i].var) {\r\nDPRINT("%s=%d\n", str, param);\r\n*config_params[i].var = param;\r\n}\r\nreturn 1;\r\n}\r\n}\r\n}\r\nif (str) {\r\nDPRINT("unknown floppy option [%s]\n", str);\r\nDPRINT("allowed options are:");\r\nfor (i = 0; i < ARRAY_SIZE(config_params); i++)\r\npr_cont(" %s", config_params[i].name);\r\npr_cont("\n");\r\n} else\r\nDPRINT("botched floppy option\n");\r\nDPRINT("Read Documentation/blockdev/floppy.txt\n");\r\nreturn 0;\r\n}\r\nstatic ssize_t floppy_cmos_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *p = to_platform_device(dev);\r\nint drive;\r\ndrive = p->id;\r\nreturn sprintf(buf, "%X\n", UDP->cmos);\r\n}\r\nstatic void floppy_device_release(struct device *dev)\r\n{\r\n}\r\nstatic int floppy_resume(struct device *dev)\r\n{\r\nint fdc;\r\nfor (fdc = 0; fdc < N_FDC; fdc++)\r\nif (FDCS->address != -1)\r\nuser_reset_fdc(-1, FD_RESET_ALWAYS, false);\r\nreturn 0;\r\n}\r\nstatic bool floppy_available(int drive)\r\n{\r\nif (!(allowed_drive_mask & (1 << drive)))\r\nreturn false;\r\nif (fdc_state[FDC(drive)].version == FDC_NONE)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct kobject *floppy_find(dev_t dev, int *part, void *data)\r\n{\r\nint drive = (*part & 3) | ((*part & 0x80) >> 5);\r\nif (drive >= N_DRIVE || !floppy_available(drive))\r\nreturn NULL;\r\nif (((*part >> 2) & 0x1f) >= ARRAY_SIZE(floppy_type))\r\nreturn NULL;\r\n*part = 0;\r\nreturn get_disk(disks[drive]);\r\n}\r\nstatic int __init do_floppy_init(void)\r\n{\r\nint i, unit, drive, err;\r\nset_debugt();\r\ninterruptjiffies = resultjiffies = jiffies;\r\n#if defined(CONFIG_PPC)\r\nif (check_legacy_ioport(FDC1))\r\nreturn -ENODEV;\r\n#endif\r\nraw_cmd = NULL;\r\nfloppy_wq = alloc_ordered_workqueue("floppy", 0);\r\nif (!floppy_wq)\r\nreturn -ENOMEM;\r\nfor (drive = 0; drive < N_DRIVE; drive++) {\r\ndisks[drive] = alloc_disk(1);\r\nif (!disks[drive]) {\r\nerr = -ENOMEM;\r\ngoto out_put_disk;\r\n}\r\ndisks[drive]->queue = blk_init_queue(do_fd_request, &floppy_lock);\r\nif (!disks[drive]->queue) {\r\nerr = -ENOMEM;\r\ngoto out_put_disk;\r\n}\r\nblk_queue_max_hw_sectors(disks[drive]->queue, 64);\r\ndisks[drive]->major = FLOPPY_MAJOR;\r\ndisks[drive]->first_minor = TOMINOR(drive);\r\ndisks[drive]->fops = &floppy_fops;\r\nsprintf(disks[drive]->disk_name, "fd%d", drive);\r\ninit_timer(&motor_off_timer[drive]);\r\nmotor_off_timer[drive].data = drive;\r\nmotor_off_timer[drive].function = motor_off_callback;\r\n}\r\nerr = register_blkdev(FLOPPY_MAJOR, "fd");\r\nif (err)\r\ngoto out_put_disk;\r\nerr = platform_driver_register(&floppy_driver);\r\nif (err)\r\ngoto out_unreg_blkdev;\r\nblk_register_region(MKDEV(FLOPPY_MAJOR, 0), 256, THIS_MODULE,\r\nfloppy_find, NULL, NULL);\r\nfor (i = 0; i < 256; i++)\r\nif (ITYPE(i))\r\nfloppy_sizes[i] = floppy_type[ITYPE(i)].size;\r\nelse\r\nfloppy_sizes[i] = MAX_DISK_SIZE << 1;\r\nreschedule_timeout(MAXTIMEOUT, "floppy init");\r\nconfig_types();\r\nfor (i = 0; i < N_FDC; i++) {\r\nfdc = i;\r\nmemset(FDCS, 0, sizeof(*FDCS));\r\nFDCS->dtr = -1;\r\nFDCS->dor = 0x4;\r\n#if defined(__sparc__) || defined(__mc68000__)\r\n#ifdef __mc68000__\r\nif (MACH_IS_SUN3X)\r\n#endif\r\nFDCS->version = FDC_82072A;\r\n#endif\r\n}\r\nuse_virtual_dma = can_use_virtual_dma & 1;\r\nfdc_state[0].address = FDC1;\r\nif (fdc_state[0].address == -1) {\r\ncancel_delayed_work(&fd_timeout);\r\nerr = -ENODEV;\r\ngoto out_unreg_region;\r\n}\r\n#if N_FDC > 1\r\nfdc_state[1].address = FDC2;\r\n#endif\r\nfdc = 0;\r\nerr = floppy_grab_irq_and_dma();\r\nif (err) {\r\ncancel_delayed_work(&fd_timeout);\r\nerr = -EBUSY;\r\ngoto out_unreg_region;\r\n}\r\nfor (drive = 0; drive < N_DRIVE; drive++) {\r\nmemset(UDRS, 0, sizeof(*UDRS));\r\nmemset(UDRWE, 0, sizeof(*UDRWE));\r\nset_bit(FD_DISK_NEWCHANGE_BIT, &UDRS->flags);\r\nset_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\r\nset_bit(FD_VERIFY_BIT, &UDRS->flags);\r\nUDRS->fd_device = -1;\r\nfloppy_track_buffer = NULL;\r\nmax_buffer_sectors = 0;\r\n}\r\nmsleep(10);\r\nfor (i = 0; i < N_FDC; i++) {\r\nfdc = i;\r\nFDCS->driver_version = FD_DRIVER_VERSION;\r\nfor (unit = 0; unit < 4; unit++)\r\nFDCS->track[unit] = 0;\r\nif (FDCS->address == -1)\r\ncontinue;\r\nFDCS->rawcmd = 2;\r\nif (user_reset_fdc(-1, FD_RESET_ALWAYS, false)) {\r\nfloppy_release_regions(fdc);\r\nFDCS->address = -1;\r\nFDCS->version = FDC_NONE;\r\ncontinue;\r\n}\r\nFDCS->version = get_fdc_version();\r\nif (FDCS->version == FDC_NONE) {\r\nfloppy_release_regions(fdc);\r\nFDCS->address = -1;\r\ncontinue;\r\n}\r\nif (can_use_virtual_dma == 2 && FDCS->version < FDC_82072A)\r\ncan_use_virtual_dma = 0;\r\nhave_no_fdc = 0;\r\nuser_reset_fdc(-1, FD_RESET_ALWAYS, false);\r\n}\r\nfdc = 0;\r\ncancel_delayed_work(&fd_timeout);\r\ncurrent_drive = 0;\r\ninitialized = true;\r\nif (have_no_fdc) {\r\nDPRINT("no floppy controllers found\n");\r\nerr = have_no_fdc;\r\ngoto out_release_dma;\r\n}\r\nfor (drive = 0; drive < N_DRIVE; drive++) {\r\nif (!floppy_available(drive))\r\ncontinue;\r\nfloppy_device[drive].name = floppy_device_name;\r\nfloppy_device[drive].id = drive;\r\nfloppy_device[drive].dev.release = floppy_device_release;\r\nfloppy_device[drive].dev.groups = floppy_dev_groups;\r\nerr = platform_device_register(&floppy_device[drive]);\r\nif (err)\r\ngoto out_remove_drives;\r\ndisks[drive]->private_data = (void *)(long)drive;\r\ndisks[drive]->flags |= GENHD_FL_REMOVABLE;\r\ndevice_add_disk(&floppy_device[drive].dev, disks[drive]);\r\n}\r\nreturn 0;\r\nout_remove_drives:\r\nwhile (drive--) {\r\nif (floppy_available(drive)) {\r\ndel_gendisk(disks[drive]);\r\nplatform_device_unregister(&floppy_device[drive]);\r\n}\r\n}\r\nout_release_dma:\r\nif (atomic_read(&usage_count))\r\nfloppy_release_irq_and_dma();\r\nout_unreg_region:\r\nblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\r\nplatform_driver_unregister(&floppy_driver);\r\nout_unreg_blkdev:\r\nunregister_blkdev(FLOPPY_MAJOR, "fd");\r\nout_put_disk:\r\ndestroy_workqueue(floppy_wq);\r\nfor (drive = 0; drive < N_DRIVE; drive++) {\r\nif (!disks[drive])\r\nbreak;\r\nif (disks[drive]->queue) {\r\ndel_timer_sync(&motor_off_timer[drive]);\r\nblk_cleanup_queue(disks[drive]->queue);\r\ndisks[drive]->queue = NULL;\r\n}\r\nput_disk(disks[drive]);\r\n}\r\nreturn err;\r\n}\r\nstatic __init void floppy_async_init(void *data, async_cookie_t cookie)\r\n{\r\ndo_floppy_init();\r\n}\r\nstatic int __init floppy_init(void)\r\n{\r\n#ifdef MODULE\r\nreturn do_floppy_init();\r\n#else\r\nasync_schedule(floppy_async_init, NULL);\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void floppy_release_allocated_regions(int fdc, const struct io_region *p)\r\n{\r\nwhile (p != io_regions) {\r\np--;\r\nrelease_region(FDCS->address + p->offset, p->size);\r\n}\r\n}\r\nstatic int floppy_request_regions(int fdc)\r\n{\r\nconst struct io_region *p;\r\nfor (p = io_regions; p < ARRAY_END(io_regions); p++) {\r\nif (!request_region(FDCS->address + p->offset,\r\np->size, "floppy")) {\r\nDPRINT("Floppy io-port 0x%04lx in use\n",\r\nFDCS->address + p->offset);\r\nfloppy_release_allocated_regions(fdc, p);\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void floppy_release_regions(int fdc)\r\n{\r\nfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\r\n}\r\nstatic int floppy_grab_irq_and_dma(void)\r\n{\r\nif (atomic_inc_return(&usage_count) > 1)\r\nreturn 0;\r\nflush_workqueue(floppy_wq);\r\nif (fd_request_irq()) {\r\nDPRINT("Unable to grab IRQ%d for the floppy driver\n",\r\nFLOPPY_IRQ);\r\natomic_dec(&usage_count);\r\nreturn -1;\r\n}\r\nif (fd_request_dma()) {\r\nDPRINT("Unable to grab DMA%d for the floppy driver\n",\r\nFLOPPY_DMA);\r\nif (can_use_virtual_dma & 2)\r\nuse_virtual_dma = can_use_virtual_dma = 1;\r\nif (!(can_use_virtual_dma & 1)) {\r\nfd_free_irq();\r\natomic_dec(&usage_count);\r\nreturn -1;\r\n}\r\n}\r\nfor (fdc = 0; fdc < N_FDC; fdc++) {\r\nif (FDCS->address != -1) {\r\nif (floppy_request_regions(fdc))\r\ngoto cleanup;\r\n}\r\n}\r\nfor (fdc = 0; fdc < N_FDC; fdc++) {\r\nif (FDCS->address != -1) {\r\nreset_fdc_info(1);\r\nfd_outb(FDCS->dor, FD_DOR);\r\n}\r\n}\r\nfdc = 0;\r\nset_dor(0, ~0, 8);\r\nfor (fdc = 0; fdc < N_FDC; fdc++)\r\nif (FDCS->address != -1)\r\nfd_outb(FDCS->dor, FD_DOR);\r\nfdc = 0;\r\nirqdma_allocated = 1;\r\nreturn 0;\r\ncleanup:\r\nfd_free_irq();\r\nfd_free_dma();\r\nwhile (--fdc >= 0)\r\nfloppy_release_regions(fdc);\r\natomic_dec(&usage_count);\r\nreturn -1;\r\n}\r\nstatic void floppy_release_irq_and_dma(void)\r\n{\r\nint old_fdc;\r\n#ifndef __sparc__\r\nint drive;\r\n#endif\r\nlong tmpsize;\r\nunsigned long tmpaddr;\r\nif (!atomic_dec_and_test(&usage_count))\r\nreturn;\r\nif (irqdma_allocated) {\r\nfd_disable_dma();\r\nfd_free_dma();\r\nfd_free_irq();\r\nirqdma_allocated = 0;\r\n}\r\nset_dor(0, ~0, 8);\r\n#if N_FDC > 1\r\nset_dor(1, ~8, 0);\r\n#endif\r\nif (floppy_track_buffer && max_buffer_sectors) {\r\ntmpsize = max_buffer_sectors * 1024;\r\ntmpaddr = (unsigned long)floppy_track_buffer;\r\nfloppy_track_buffer = NULL;\r\nmax_buffer_sectors = 0;\r\nbuffer_min = buffer_max = -1;\r\nfd_dma_mem_free(tmpaddr, tmpsize);\r\n}\r\n#ifndef __sparc__\r\nfor (drive = 0; drive < N_FDC * 4; drive++)\r\nif (timer_pending(motor_off_timer + drive))\r\npr_info("motor off timer %d still active\n", drive);\r\n#endif\r\nif (delayed_work_pending(&fd_timeout))\r\npr_info("floppy timer still active:%s\n", timeout_message);\r\nif (delayed_work_pending(&fd_timer))\r\npr_info("auxiliary floppy timer still active\n");\r\nif (work_pending(&floppy_work))\r\npr_info("work still pending\n");\r\nold_fdc = fdc;\r\nfor (fdc = 0; fdc < N_FDC; fdc++)\r\nif (FDCS->address != -1)\r\nfloppy_release_regions(fdc);\r\nfdc = old_fdc;\r\n}\r\nstatic void __init parse_floppy_cfg_string(char *cfg)\r\n{\r\nchar *ptr;\r\nwhile (*cfg) {\r\nptr = cfg;\r\nwhile (*cfg && *cfg != ' ' && *cfg != '\t')\r\ncfg++;\r\nif (*cfg) {\r\n*cfg = '\0';\r\ncfg++;\r\n}\r\nif (*ptr)\r\nfloppy_setup(ptr);\r\n}\r\n}\r\nstatic int __init floppy_module_init(void)\r\n{\r\nif (floppy)\r\nparse_floppy_cfg_string(floppy);\r\nreturn floppy_init();\r\n}\r\nstatic void __exit floppy_module_exit(void)\r\n{\r\nint drive;\r\nblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\r\nunregister_blkdev(FLOPPY_MAJOR, "fd");\r\nplatform_driver_unregister(&floppy_driver);\r\ndestroy_workqueue(floppy_wq);\r\nfor (drive = 0; drive < N_DRIVE; drive++) {\r\ndel_timer_sync(&motor_off_timer[drive]);\r\nif (floppy_available(drive)) {\r\ndel_gendisk(disks[drive]);\r\nplatform_device_unregister(&floppy_device[drive]);\r\n}\r\nblk_cleanup_queue(disks[drive]->queue);\r\nif (!(allowed_drive_mask & (1 << drive)) ||\r\nfdc_state[FDC(drive)].version == FDC_NONE)\r\ndisks[drive]->queue = NULL;\r\nput_disk(disks[drive]);\r\n}\r\ncancel_delayed_work_sync(&fd_timeout);\r\ncancel_delayed_work_sync(&fd_timer);\r\nif (atomic_read(&usage_count))\r\nfloppy_release_irq_and_dma();\r\nfd_eject(0);\r\n}
