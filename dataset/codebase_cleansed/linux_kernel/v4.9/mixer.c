static const struct usbmix_name_map *\r\nfind_map(struct mixer_build *state, int unitid, int control)\r\n{\r\nconst struct usbmix_name_map *p = state->map;\r\nif (!p)\r\nreturn NULL;\r\nfor (p = state->map; p->id; p++) {\r\nif (p->id == unitid &&\r\n(!control || !p->control || control == p->control))\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\ncheck_mapped_name(const struct usbmix_name_map *p, char *buf, int buflen)\r\n{\r\nif (!p || !p->name)\r\nreturn 0;\r\nbuflen--;\r\nreturn strlcpy(buf, p->name, buflen);\r\n}\r\nstatic inline int\r\ncheck_ignored_ctl(const struct usbmix_name_map *p)\r\n{\r\nif (!p || p->name || p->dB)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline void check_mapped_dB(const struct usbmix_name_map *p,\r\nstruct usb_mixer_elem_info *cval)\r\n{\r\nif (p && p->dB) {\r\ncval->dBmin = p->dB->min;\r\ncval->dBmax = p->dB->max;\r\ncval->initialized = 1;\r\n}\r\n}\r\nstatic int check_mapped_selector_name(struct mixer_build *state, int unitid,\r\nint index, char *buf, int buflen)\r\n{\r\nconst struct usbmix_selector_map *p;\r\nif (!state->selector_map)\r\nreturn 0;\r\nfor (p = state->selector_map; p->id; p++) {\r\nif (p->id == unitid && index < p->count)\r\nreturn strlcpy(buf, p->names[index], buflen);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *find_audio_control_unit(struct mixer_build *state,\r\nunsigned char unit)\r\n{\r\nstruct uac_feature_unit_descriptor *hdr = NULL;\r\nwhile ((hdr = snd_usb_find_desc(state->buffer, state->buflen, hdr,\r\nUSB_DT_CS_INTERFACE)) != NULL) {\r\nif (hdr->bLength >= 4 &&\r\nhdr->bDescriptorSubtype >= UAC_INPUT_TERMINAL &&\r\nhdr->bDescriptorSubtype <= UAC2_SAMPLE_RATE_CONVERTER &&\r\nhdr->bUnitID == unit)\r\nreturn hdr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int snd_usb_copy_string_desc(struct mixer_build *state,\r\nint index, char *buf, int maxlen)\r\n{\r\nint len = usb_string(state->chip->dev, index, buf, maxlen - 1);\r\nbuf[len] = 0;\r\nreturn len;\r\n}\r\nstatic int convert_signed_value(struct usb_mixer_elem_info *cval, int val)\r\n{\r\nswitch (cval->val_type) {\r\ncase USB_MIXER_BOOLEAN:\r\nreturn !!val;\r\ncase USB_MIXER_INV_BOOLEAN:\r\nreturn !val;\r\ncase USB_MIXER_U8:\r\nval &= 0xff;\r\nbreak;\r\ncase USB_MIXER_S8:\r\nval &= 0xff;\r\nif (val >= 0x80)\r\nval -= 0x100;\r\nbreak;\r\ncase USB_MIXER_U16:\r\nval &= 0xffff;\r\nbreak;\r\ncase USB_MIXER_S16:\r\nval &= 0xffff;\r\nif (val >= 0x8000)\r\nval -= 0x10000;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic int convert_bytes_value(struct usb_mixer_elem_info *cval, int val)\r\n{\r\nswitch (cval->val_type) {\r\ncase USB_MIXER_BOOLEAN:\r\nreturn !!val;\r\ncase USB_MIXER_INV_BOOLEAN:\r\nreturn !val;\r\ncase USB_MIXER_S8:\r\ncase USB_MIXER_U8:\r\nreturn val & 0xff;\r\ncase USB_MIXER_S16:\r\ncase USB_MIXER_U16:\r\nreturn val & 0xffff;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_relative_value(struct usb_mixer_elem_info *cval, int val)\r\n{\r\nif (!cval->res)\r\ncval->res = 1;\r\nif (val < cval->min)\r\nreturn 0;\r\nelse if (val >= cval->max)\r\nreturn (cval->max - cval->min + cval->res - 1) / cval->res;\r\nelse\r\nreturn (val - cval->min) / cval->res;\r\n}\r\nstatic int get_abs_value(struct usb_mixer_elem_info *cval, int val)\r\n{\r\nif (val < 0)\r\nreturn cval->min;\r\nif (!cval->res)\r\ncval->res = 1;\r\nval *= cval->res;\r\nval += cval->min;\r\nif (val > cval->max)\r\nreturn cval->max;\r\nreturn val;\r\n}\r\nstatic int uac2_ctl_value_size(int val_type)\r\n{\r\nswitch (val_type) {\r\ncase USB_MIXER_S32:\r\ncase USB_MIXER_U32:\r\nreturn 4;\r\ncase USB_MIXER_S16:\r\ncase USB_MIXER_U16:\r\nreturn 2;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_ctl_value_v1(struct usb_mixer_elem_info *cval, int request,\r\nint validx, int *value_ret)\r\n{\r\nstruct snd_usb_audio *chip = cval->head.mixer->chip;\r\nunsigned char buf[2];\r\nint val_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;\r\nint timeout = 10;\r\nint idx = 0, err;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn -EIO;\r\nwhile (timeout-- > 0) {\r\nidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\r\nif (snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), request,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\r\nvalidx, idx, buf, val_len) >= val_len) {\r\n*value_ret = convert_signed_value(cval, snd_usb_combine_bytes(buf, val_len));\r\nerr = 0;\r\ngoto out;\r\n}\r\n}\r\nusb_audio_dbg(chip,\r\n"cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\n",\r\nrequest, validx, idx, cval->val_type);\r\nerr = -EINVAL;\r\nout:\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int get_ctl_value_v2(struct usb_mixer_elem_info *cval, int request,\r\nint validx, int *value_ret)\r\n{\r\nstruct snd_usb_audio *chip = cval->head.mixer->chip;\r\nunsigned char buf[4 + 3 * sizeof(__u32)];\r\nunsigned char *val;\r\nint idx = 0, ret, size;\r\n__u8 bRequest;\r\nif (request == UAC_GET_CUR) {\r\nbRequest = UAC2_CS_CUR;\r\nsize = uac2_ctl_value_size(cval->val_type);\r\n} else {\r\nbRequest = UAC2_CS_RANGE;\r\nsize = sizeof(buf);\r\n}\r\nmemset(buf, 0, sizeof(buf));\r\nret = snd_usb_lock_shutdown(chip) ? -EIO : 0;\r\nif (ret)\r\ngoto error;\r\nidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\r\nret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), bRequest,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\r\nvalidx, idx, buf, size);\r\nsnd_usb_unlock_shutdown(chip);\r\nif (ret < 0) {\r\nerror:\r\nusb_audio_err(chip,\r\n"cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\n",\r\nrequest, validx, idx, cval->val_type);\r\nreturn ret;\r\n}\r\nswitch (request) {\r\ncase UAC_GET_CUR:\r\nval = buf;\r\nbreak;\r\ncase UAC_GET_MIN:\r\nval = buf + sizeof(__u16);\r\nbreak;\r\ncase UAC_GET_MAX:\r\nval = buf + sizeof(__u16) * 2;\r\nbreak;\r\ncase UAC_GET_RES:\r\nval = buf + sizeof(__u16) * 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*value_ret = convert_signed_value(cval, snd_usb_combine_bytes(val, sizeof(__u16)));\r\nreturn 0;\r\n}\r\nstatic int get_ctl_value(struct usb_mixer_elem_info *cval, int request,\r\nint validx, int *value_ret)\r\n{\r\nvalidx += cval->idx_off;\r\nreturn (cval->head.mixer->protocol == UAC_VERSION_1) ?\r\nget_ctl_value_v1(cval, request, validx, value_ret) :\r\nget_ctl_value_v2(cval, request, validx, value_ret);\r\n}\r\nstatic int get_cur_ctl_value(struct usb_mixer_elem_info *cval,\r\nint validx, int *value)\r\n{\r\nreturn get_ctl_value(cval, UAC_GET_CUR, validx, value);\r\n}\r\nstatic inline int get_cur_mix_raw(struct usb_mixer_elem_info *cval,\r\nint channel, int *value)\r\n{\r\nreturn get_ctl_value(cval, UAC_GET_CUR,\r\n(cval->control << 8) | channel,\r\nvalue);\r\n}\r\nint snd_usb_get_cur_mix_value(struct usb_mixer_elem_info *cval,\r\nint channel, int index, int *value)\r\n{\r\nint err;\r\nif (cval->cached & (1 << channel)) {\r\n*value = cval->cache_val[index];\r\nreturn 0;\r\n}\r\nerr = get_cur_mix_raw(cval, channel, value);\r\nif (err < 0) {\r\nif (!cval->head.mixer->ignore_ctl_error)\r\nusb_audio_dbg(cval->head.mixer->chip,\r\n"cannot get current value for control %d ch %d: err = %d\n",\r\ncval->control, channel, err);\r\nreturn err;\r\n}\r\ncval->cached |= 1 << channel;\r\ncval->cache_val[index] = *value;\r\nreturn 0;\r\n}\r\nint snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,\r\nint request, int validx, int value_set)\r\n{\r\nstruct snd_usb_audio *chip = cval->head.mixer->chip;\r\nunsigned char buf[4];\r\nint idx = 0, val_len, err, timeout = 10;\r\nvalidx += cval->idx_off;\r\nif (cval->head.mixer->protocol == UAC_VERSION_1) {\r\nval_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;\r\n} else {\r\nval_len = uac2_ctl_value_size(cval->val_type);\r\nif (request != UAC_SET_CUR) {\r\nusb_audio_dbg(chip, "RANGE setting not yet supported\n");\r\nreturn -EINVAL;\r\n}\r\nrequest = UAC2_CS_CUR;\r\n}\r\nvalue_set = convert_bytes_value(cval, value_set);\r\nbuf[0] = value_set & 0xff;\r\nbuf[1] = (value_set >> 8) & 0xff;\r\nbuf[2] = (value_set >> 16) & 0xff;\r\nbuf[3] = (value_set >> 24) & 0xff;\r\nerr = snd_usb_lock_shutdown(chip);\r\nif (err < 0)\r\nreturn -EIO;\r\nwhile (timeout-- > 0) {\r\nidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\r\nif (snd_usb_ctl_msg(chip->dev,\r\nusb_sndctrlpipe(chip->dev, 0), request,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\r\nvalidx, idx, buf, val_len) >= 0) {\r\nerr = 0;\r\ngoto out;\r\n}\r\n}\r\nusb_audio_dbg(chip, "cannot set ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d, data = %#x/%#x\n",\r\nrequest, validx, idx, cval->val_type, buf[0], buf[1]);\r\nerr = -EINVAL;\r\nout:\r\nsnd_usb_unlock_shutdown(chip);\r\nreturn err;\r\n}\r\nstatic int set_cur_ctl_value(struct usb_mixer_elem_info *cval,\r\nint validx, int value)\r\n{\r\nreturn snd_usb_mixer_set_ctl_value(cval, UAC_SET_CUR, validx, value);\r\n}\r\nint snd_usb_set_cur_mix_value(struct usb_mixer_elem_info *cval, int channel,\r\nint index, int value)\r\n{\r\nint err;\r\nunsigned int read_only = (channel == 0) ?\r\ncval->master_readonly :\r\ncval->ch_readonly & (1 << (channel - 1));\r\nif (read_only) {\r\nusb_audio_dbg(cval->head.mixer->chip,\r\n"%s(): channel %d of control %d is read_only\n",\r\n__func__, channel, cval->control);\r\nreturn 0;\r\n}\r\nerr = snd_usb_mixer_set_ctl_value(cval,\r\nUAC_SET_CUR, (cval->control << 8) | channel,\r\nvalue);\r\nif (err < 0)\r\nreturn err;\r\ncval->cached |= 1 << channel;\r\ncval->cache_val[index] = value;\r\nreturn 0;\r\n}\r\nint snd_usb_mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *_tlv)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nDECLARE_TLV_DB_MINMAX(scale, 0, 0);\r\nif (size < sizeof(scale))\r\nreturn -ENOMEM;\r\nscale[2] = cval->dBmin;\r\nscale[3] = cval->dBmax;\r\nif (copy_to_user(_tlv, scale, sizeof(scale)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int check_matrix_bitmap(unsigned char *bmap,\r\nint ich, int och, int num_outs)\r\n{\r\nint idx = ich * num_outs + och;\r\nreturn bmap[idx >> 3] & (0x80 >> (idx & 7));\r\n}\r\nint snd_usb_mixer_add_control(struct usb_mixer_elem_list *list,\r\nstruct snd_kcontrol *kctl)\r\n{\r\nstruct usb_mixer_interface *mixer = list->mixer;\r\nint err;\r\nwhile (snd_ctl_find_id(mixer->chip->card, &kctl->id))\r\nkctl->id.index++;\r\nif ((err = snd_ctl_add(mixer->chip->card, kctl)) < 0) {\r\nusb_audio_dbg(mixer->chip, "cannot add control (err = %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nlist->kctl = kctl;\r\nlist->next_id_elem = mixer->id_elems[list->id];\r\nmixer->id_elems[list->id] = list;\r\nreturn 0;\r\n}\r\nstatic int get_term_name(struct mixer_build *state, struct usb_audio_term *iterm,\r\nunsigned char *name, int maxlen, int term_only)\r\n{\r\nstruct iterm_name_combo *names;\r\nif (iterm->name)\r\nreturn snd_usb_copy_string_desc(state, iterm->name,\r\nname, maxlen);\r\nif (iterm->type >> 16) {\r\nif (term_only)\r\nreturn 0;\r\nswitch (iterm->type >> 16) {\r\ncase UAC_SELECTOR_UNIT:\r\nstrcpy(name, "Selector");\r\nreturn 8;\r\ncase UAC1_PROCESSING_UNIT:\r\nstrcpy(name, "Process Unit");\r\nreturn 12;\r\ncase UAC1_EXTENSION_UNIT:\r\nstrcpy(name, "Ext Unit");\r\nreturn 8;\r\ncase UAC_MIXER_UNIT:\r\nstrcpy(name, "Mixer");\r\nreturn 5;\r\ndefault:\r\nreturn sprintf(name, "Unit %d", iterm->id);\r\n}\r\n}\r\nswitch (iterm->type & 0xff00) {\r\ncase 0x0100:\r\nstrcpy(name, "PCM");\r\nreturn 3;\r\ncase 0x0200:\r\nstrcpy(name, "Mic");\r\nreturn 3;\r\ncase 0x0400:\r\nstrcpy(name, "Headset");\r\nreturn 7;\r\ncase 0x0500:\r\nstrcpy(name, "Phone");\r\nreturn 5;\r\n}\r\nfor (names = iterm_names; names->type; names++) {\r\nif (names->type == iterm->type) {\r\nstrcpy(name, names->name);\r\nreturn strlen(names->name);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_input_term(struct mixer_build *state, int id,\r\nstruct usb_audio_term *term)\r\n{\r\nint err;\r\nvoid *p1;\r\nmemset(term, 0, sizeof(*term));\r\nwhile ((p1 = find_audio_control_unit(state, id)) != NULL) {\r\nunsigned char *hdr = p1;\r\nterm->id = id;\r\nswitch (hdr[2]) {\r\ncase UAC_INPUT_TERMINAL:\r\nif (state->mixer->protocol == UAC_VERSION_1) {\r\nstruct uac_input_terminal_descriptor *d = p1;\r\nterm->type = le16_to_cpu(d->wTerminalType);\r\nterm->channels = d->bNrChannels;\r\nterm->chconfig = le16_to_cpu(d->wChannelConfig);\r\nterm->name = d->iTerminal;\r\n} else {\r\nstruct uac2_input_terminal_descriptor *d = p1;\r\nerr = check_input_term(state, d->bCSourceID, term);\r\nif (err < 0)\r\nreturn err;\r\nterm->id = id;\r\nterm->type = le16_to_cpu(d->wTerminalType);\r\nterm->channels = d->bNrChannels;\r\nterm->chconfig = le32_to_cpu(d->bmChannelConfig);\r\nterm->name = d->iTerminal;\r\n}\r\nreturn 0;\r\ncase UAC_FEATURE_UNIT: {\r\nstruct uac_feature_unit_descriptor *d = p1;\r\nid = d->bSourceID;\r\nbreak;\r\n}\r\ncase UAC_MIXER_UNIT: {\r\nstruct uac_mixer_unit_descriptor *d = p1;\r\nterm->type = d->bDescriptorSubtype << 16;\r\nterm->channels = uac_mixer_unit_bNrChannels(d);\r\nterm->chconfig = uac_mixer_unit_wChannelConfig(d, state->mixer->protocol);\r\nterm->name = uac_mixer_unit_iMixer(d);\r\nreturn 0;\r\n}\r\ncase UAC_SELECTOR_UNIT:\r\ncase UAC2_CLOCK_SELECTOR: {\r\nstruct uac_selector_unit_descriptor *d = p1;\r\nerr = check_input_term(state, d->baSourceID[0], term);\r\nif (err < 0)\r\nreturn err;\r\nterm->type = d->bDescriptorSubtype << 16;\r\nterm->id = id;\r\nterm->name = uac_selector_unit_iSelector(d);\r\nreturn 0;\r\n}\r\ncase UAC1_PROCESSING_UNIT:\r\ncase UAC1_EXTENSION_UNIT:\r\ncase UAC2_EXTENSION_UNIT_V2: {\r\nstruct uac_processing_unit_descriptor *d = p1;\r\nif (state->mixer->protocol == UAC_VERSION_2 &&\r\nhdr[2] == UAC2_EFFECT_UNIT) {\r\nreturn 0;\r\n}\r\nif (d->bNrInPins) {\r\nid = d->baSourceID[0];\r\nbreak;\r\n}\r\nterm->type = d->bDescriptorSubtype << 16;\r\nterm->channels = uac_processing_unit_bNrChannels(d);\r\nterm->chconfig = uac_processing_unit_wChannelConfig(d, state->mixer->protocol);\r\nterm->name = uac_processing_unit_iProcessing(d, state->mixer->protocol);\r\nreturn 0;\r\n}\r\ncase UAC2_CLOCK_SOURCE: {\r\nstruct uac_clock_source_descriptor *d = p1;\r\nterm->type = d->bDescriptorSubtype << 16;\r\nterm->id = id;\r\nterm->name = d->iClockSource;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nvoid snd_usb_mixer_elem_free(struct snd_kcontrol *kctl)\r\n{\r\nkfree(kctl->private_data);\r\nkctl->private_data = NULL;\r\n}\r\nstatic void volume_control_quirks(struct usb_mixer_elem_info *cval,\r\nstruct snd_kcontrol *kctl)\r\n{\r\nstruct snd_usb_audio *chip = cval->head.mixer->chip;\r\nswitch (chip->usb_id) {\r\ncase USB_ID(0x0763, 0x2030):\r\ncase USB_ID(0x0763, 0x2031):\r\nif (strcmp(kctl->id.name, "Effect Duration") == 0) {\r\ncval->min = 0x0000;\r\ncval->max = 0xffff;\r\ncval->res = 0x00e6;\r\nbreak;\r\n}\r\nif (strcmp(kctl->id.name, "Effect Volume") == 0 ||\r\nstrcmp(kctl->id.name, "Effect Feedback Volume") == 0) {\r\ncval->min = 0x00;\r\ncval->max = 0xff;\r\nbreak;\r\n}\r\nif (strstr(kctl->id.name, "Effect Return") != NULL) {\r\ncval->min = 0xb706;\r\ncval->max = 0xff7b;\r\ncval->res = 0x0073;\r\nbreak;\r\n}\r\nif ((strstr(kctl->id.name, "Playback Volume") != NULL) ||\r\n(strstr(kctl->id.name, "Effect Send") != NULL)) {\r\ncval->min = 0xb5fb;\r\ncval->max = 0xfcfe;\r\ncval->res = 0x0073;\r\n}\r\nbreak;\r\ncase USB_ID(0x0763, 0x2081):\r\ncase USB_ID(0x0763, 0x2080):\r\nif (strcmp(kctl->id.name, "Effect Duration") == 0) {\r\nusb_audio_info(chip,\r\n"set quirk for FTU Effect Duration\n");\r\ncval->min = 0x0000;\r\ncval->max = 0x7f00;\r\ncval->res = 0x0100;\r\nbreak;\r\n}\r\nif (strcmp(kctl->id.name, "Effect Volume") == 0 ||\r\nstrcmp(kctl->id.name, "Effect Feedback Volume") == 0) {\r\nusb_audio_info(chip,\r\n"set quirks for FTU Effect Feedback/Volume\n");\r\ncval->min = 0x00;\r\ncval->max = 0x7f;\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_ID(0x0471, 0x0101):\r\ncase USB_ID(0x0471, 0x0104):\r\ncase USB_ID(0x0471, 0x0105):\r\ncase USB_ID(0x0672, 0x1041):\r\nif (!strcmp(kctl->id.name, "PCM Playback Volume") &&\r\ncval->min == -15616) {\r\nusb_audio_info(chip,\r\n"set volume quirk for UDA1321/N101 chip\n");\r\ncval->max = -256;\r\n}\r\nbreak;\r\ncase USB_ID(0x046d, 0x09a4):\r\nif (!strcmp(kctl->id.name, "Mic Capture Volume")) {\r\nusb_audio_info(chip,\r\n"set volume quirk for QuickCam E3500\n");\r\ncval->min = 6080;\r\ncval->max = 8768;\r\ncval->res = 192;\r\n}\r\nbreak;\r\ncase USB_ID(0x046d, 0x0807):\r\ncase USB_ID(0x046d, 0x0808):\r\ncase USB_ID(0x046d, 0x0809):\r\ncase USB_ID(0x046d, 0x0819):\r\ncase USB_ID(0x046d, 0x081b):\r\ncase USB_ID(0x046d, 0x081d):\r\ncase USB_ID(0x046d, 0x0825):\r\ncase USB_ID(0x046d, 0x0826):\r\ncase USB_ID(0x046d, 0x08ca):\r\ncase USB_ID(0x046d, 0x0991):\r\nif (!strcmp(kctl->id.name, "Mic Capture Volume")) {\r\nusb_audio_info(chip,\r\n"set resolution quirk: cval->res = 384\n");\r\ncval->res = 384;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int get_min_max_with_quirks(struct usb_mixer_elem_info *cval,\r\nint default_min, struct snd_kcontrol *kctl)\r\n{\r\ncval->min = default_min;\r\ncval->max = cval->min + 1;\r\ncval->res = 1;\r\ncval->dBmin = cval->dBmax = 0;\r\nif (cval->val_type == USB_MIXER_BOOLEAN ||\r\ncval->val_type == USB_MIXER_INV_BOOLEAN) {\r\ncval->initialized = 1;\r\n} else {\r\nint minchn = 0;\r\nif (cval->cmask) {\r\nint i;\r\nfor (i = 0; i < MAX_CHANNELS; i++)\r\nif (cval->cmask & (1 << i)) {\r\nminchn = i + 1;\r\nbreak;\r\n}\r\n}\r\nif (get_ctl_value(cval, UAC_GET_MAX, (cval->control << 8) | minchn, &cval->max) < 0 ||\r\nget_ctl_value(cval, UAC_GET_MIN, (cval->control << 8) | minchn, &cval->min) < 0) {\r\nusb_audio_err(cval->head.mixer->chip,\r\n"%d:%d: cannot get min/max values for control %d (id %d)\n",\r\ncval->head.id, snd_usb_ctrl_intf(cval->head.mixer->chip),\r\ncval->control, cval->head.id);\r\nreturn -EINVAL;\r\n}\r\nif (get_ctl_value(cval, UAC_GET_RES,\r\n(cval->control << 8) | minchn,\r\n&cval->res) < 0) {\r\ncval->res = 1;\r\n} else {\r\nint last_valid_res = cval->res;\r\nwhile (cval->res > 1) {\r\nif (snd_usb_mixer_set_ctl_value(cval, UAC_SET_RES,\r\n(cval->control << 8) | minchn,\r\ncval->res / 2) < 0)\r\nbreak;\r\ncval->res /= 2;\r\n}\r\nif (get_ctl_value(cval, UAC_GET_RES,\r\n(cval->control << 8) | minchn, &cval->res) < 0)\r\ncval->res = last_valid_res;\r\n}\r\nif (cval->res == 0)\r\ncval->res = 1;\r\nif (cval->min + cval->res < cval->max) {\r\nint last_valid_res = cval->res;\r\nint saved, test, check;\r\nget_cur_mix_raw(cval, minchn, &saved);\r\nfor (;;) {\r\ntest = saved;\r\nif (test < cval->max)\r\ntest += cval->res;\r\nelse\r\ntest -= cval->res;\r\nif (test < cval->min || test > cval->max ||\r\nsnd_usb_set_cur_mix_value(cval, minchn, 0, test) ||\r\nget_cur_mix_raw(cval, minchn, &check)) {\r\ncval->res = last_valid_res;\r\nbreak;\r\n}\r\nif (test == check)\r\nbreak;\r\ncval->res *= 2;\r\n}\r\nsnd_usb_set_cur_mix_value(cval, minchn, 0, saved);\r\n}\r\ncval->initialized = 1;\r\n}\r\nif (kctl)\r\nvolume_control_quirks(cval, kctl);\r\ncval->dBmin = (convert_signed_value(cval, cval->min) * 100) / 256;\r\ncval->dBmax = (convert_signed_value(cval, cval->max) * 100) / 256;\r\nif (cval->dBmin > cval->dBmax) {\r\nif (cval->dBmin < 0)\r\ncval->dBmax = 0;\r\nelse if (cval->dBmin > 0)\r\ncval->dBmin = 0;\r\nif (cval->dBmin > cval->dBmax) {\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixer_ctl_feature_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nif (cval->val_type == USB_MIXER_BOOLEAN ||\r\ncval->val_type == USB_MIXER_INV_BOOLEAN)\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nelse\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = cval->channels;\r\nif (cval->val_type == USB_MIXER_BOOLEAN ||\r\ncval->val_type == USB_MIXER_INV_BOOLEAN) {\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\n} else {\r\nif (!cval->initialized) {\r\nget_min_max_with_quirks(cval, 0, kcontrol);\r\nif (cval->initialized && cval->dBmin >= cval->dBmax) {\r\nkcontrol->vd[0].access &=\r\n~(SNDRV_CTL_ELEM_ACCESS_TLV_READ |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK);\r\nsnd_ctl_notify(cval->head.mixer->chip->card,\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\n&kcontrol->id);\r\n}\r\n}\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max =\r\n(cval->max - cval->min + cval->res - 1) / cval->res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixer_ctl_feature_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nint c, cnt, val, err;\r\nucontrol->value.integer.value[0] = cval->min;\r\nif (cval->cmask) {\r\ncnt = 0;\r\nfor (c = 0; c < MAX_CHANNELS; c++) {\r\nif (!(cval->cmask & (1 << c)))\r\ncontinue;\r\nerr = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &val);\r\nif (err < 0)\r\nreturn filter_error(cval, err);\r\nval = get_relative_value(cval, val);\r\nucontrol->value.integer.value[cnt] = val;\r\ncnt++;\r\n}\r\nreturn 0;\r\n} else {\r\nerr = snd_usb_get_cur_mix_value(cval, 0, 0, &val);\r\nif (err < 0)\r\nreturn filter_error(cval, err);\r\nval = get_relative_value(cval, val);\r\nucontrol->value.integer.value[0] = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixer_ctl_feature_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nint c, cnt, val, oval, err;\r\nint changed = 0;\r\nif (cval->cmask) {\r\ncnt = 0;\r\nfor (c = 0; c < MAX_CHANNELS; c++) {\r\nif (!(cval->cmask & (1 << c)))\r\ncontinue;\r\nerr = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &oval);\r\nif (err < 0)\r\nreturn filter_error(cval, err);\r\nval = ucontrol->value.integer.value[cnt];\r\nval = get_abs_value(cval, val);\r\nif (oval != val) {\r\nsnd_usb_set_cur_mix_value(cval, c + 1, cnt, val);\r\nchanged = 1;\r\n}\r\ncnt++;\r\n}\r\n} else {\r\nerr = snd_usb_get_cur_mix_value(cval, 0, 0, &oval);\r\nif (err < 0)\r\nreturn filter_error(cval, err);\r\nval = ucontrol->value.integer.value[0];\r\nval = get_abs_value(cval, val);\r\nif (val != oval) {\r\nsnd_usb_set_cur_mix_value(cval, 0, 0, val);\r\nchanged = 1;\r\n}\r\n}\r\nreturn changed;\r\n}\r\nstatic size_t append_ctl_name(struct snd_kcontrol *kctl, const char *str)\r\n{\r\nreturn strlcat(kctl->id.name, str, sizeof(kctl->id.name));\r\n}\r\nstatic void check_no_speaker_on_headset(struct snd_kcontrol *kctl,\r\nstruct snd_card *card)\r\n{\r\nconst char *names_to_check[] = {\r\n"Headset", "headset", "Headphone", "headphone", NULL};\r\nconst char **s;\r\nbool found = false;\r\nif (strcmp("Speaker", kctl->id.name))\r\nreturn;\r\nfor (s = names_to_check; *s; s++)\r\nif (strstr(card->shortname, *s)) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn;\r\nstrlcpy(kctl->id.name, "Headphone", sizeof(kctl->id.name));\r\n}\r\nstatic void build_feature_ctl(struct mixer_build *state, void *raw_desc,\r\nunsigned int ctl_mask, int control,\r\nstruct usb_audio_term *iterm, int unitid,\r\nint readonly_mask)\r\n{\r\nstruct uac_feature_unit_descriptor *desc = raw_desc;\r\nstruct usb_feature_control_info *ctl_info;\r\nunsigned int len = 0;\r\nint mapped_name = 0;\r\nint nameid = uac_feature_unit_iFeature(desc);\r\nstruct snd_kcontrol *kctl;\r\nstruct usb_mixer_elem_info *cval;\r\nconst struct usbmix_name_map *map;\r\nunsigned int range;\r\ncontrol++;\r\nif (control == UAC_FU_GRAPHIC_EQUALIZER) {\r\nreturn;\r\n}\r\nmap = find_map(state, unitid, control);\r\nif (check_ignored_ctl(map))\r\nreturn;\r\ncval = kzalloc(sizeof(*cval), GFP_KERNEL);\r\nif (!cval)\r\nreturn;\r\nsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\r\ncval->control = control;\r\ncval->cmask = ctl_mask;\r\nctl_info = &audio_feature_info[control-1];\r\nif (state->mixer->protocol == UAC_VERSION_1)\r\ncval->val_type = ctl_info->type;\r\nelse\r\ncval->val_type = ctl_info->type_uac2 >= 0 ?\r\nctl_info->type_uac2 : ctl_info->type;\r\nif (ctl_mask == 0) {\r\ncval->channels = 1;\r\ncval->master_readonly = readonly_mask;\r\n} else {\r\nint i, c = 0;\r\nfor (i = 0; i < 16; i++)\r\nif (ctl_mask & (1 << i))\r\nc++;\r\ncval->channels = c;\r\ncval->ch_readonly = readonly_mask;\r\n}\r\nif (cval->channels == readonly_mask)\r\nkctl = snd_ctl_new1(&usb_feature_unit_ctl_ro, cval);\r\nelse\r\nkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\r\nif (!kctl) {\r\nusb_audio_err(state->chip, "cannot malloc kcontrol\n");\r\nkfree(cval);\r\nreturn;\r\n}\r\nkctl->private_free = snd_usb_mixer_elem_free;\r\nlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\r\nmapped_name = len != 0;\r\nif (!len && nameid)\r\nlen = snd_usb_copy_string_desc(state, nameid,\r\nkctl->id.name, sizeof(kctl->id.name));\r\nswitch (control) {\r\ncase UAC_FU_MUTE:\r\ncase UAC_FU_VOLUME:\r\nif (!len) {\r\nlen = get_term_name(state, iterm, kctl->id.name,\r\nsizeof(kctl->id.name), 1);\r\nif (!len)\r\nlen = get_term_name(state, &state->oterm,\r\nkctl->id.name,\r\nsizeof(kctl->id.name), 1);\r\nif (!len)\r\nsnprintf(kctl->id.name, sizeof(kctl->id.name),\r\n"Feature %d", unitid);\r\n}\r\nif (!mapped_name)\r\ncheck_no_speaker_on_headset(kctl, state->mixer->chip->card);\r\nif (!mapped_name && !(state->oterm.type >> 16)) {\r\nif ((state->oterm.type & 0xff00) == 0x0100)\r\nappend_ctl_name(kctl, " Capture");\r\nelse\r\nappend_ctl_name(kctl, " Playback");\r\n}\r\nappend_ctl_name(kctl, control == UAC_FU_MUTE ?\r\n" Switch" : " Volume");\r\nbreak;\r\ndefault:\r\nif (!len)\r\nstrlcpy(kctl->id.name, audio_feature_info[control-1].name,\r\nsizeof(kctl->id.name));\r\nbreak;\r\n}\r\nget_min_max_with_quirks(cval, 0, kctl);\r\nif (control == UAC_FU_VOLUME) {\r\ncheck_mapped_dB(map, cval);\r\nif (cval->dBmin < cval->dBmax || !cval->initialized) {\r\nkctl->tlv.c = snd_usb_mixer_vol_tlv;\r\nkctl->vd[0].access |=\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\r\n}\r\n}\r\nsnd_usb_mixer_fu_apply_quirk(state->mixer, cval, unitid, kctl);\r\nrange = (cval->max - cval->min) / cval->res;\r\nif (range > 384) {\r\nusb_audio_warn(state->chip,\r\n"Warning! Unlikely big volume range (=%u), cval->res is probably wrong.",\r\nrange);\r\nusb_audio_warn(state->chip,\r\n"[%d] FU [%s] ch = %d, val = %d/%d/%d",\r\ncval->head.id, kctl->id.name, cval->channels,\r\ncval->min, cval->max, cval->res);\r\n}\r\nusb_audio_dbg(state->chip, "[%d] FU [%s] ch = %d, val = %d/%d/%d\n",\r\ncval->head.id, kctl->id.name, cval->channels,\r\ncval->min, cval->max, cval->res);\r\nsnd_usb_mixer_add_control(&cval->head, kctl);\r\n}\r\nstatic int parse_clock_source_unit(struct mixer_build *state, int unitid,\r\nvoid *_ftr)\r\n{\r\nstruct uac_clock_source_descriptor *hdr = _ftr;\r\nstruct usb_mixer_elem_info *cval;\r\nstruct snd_kcontrol *kctl;\r\nchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nint ret;\r\nif (state->mixer->protocol != UAC_VERSION_2)\r\nreturn -EINVAL;\r\nif (hdr->bLength != sizeof(*hdr)) {\r\nusb_audio_dbg(state->chip,\r\n"Bogus clock source descriptor length of %d, ignoring.\n",\r\nhdr->bLength);\r\nreturn 0;\r\n}\r\nif (!uac2_control_is_readable(hdr->bmControls,\r\nilog2(UAC2_CS_CONTROL_CLOCK_VALID)))\r\nreturn 0;\r\ncval = kzalloc(sizeof(*cval), GFP_KERNEL);\r\nif (!cval)\r\nreturn -ENOMEM;\r\nsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, hdr->bClockID);\r\ncval->min = 0;\r\ncval->max = 1;\r\ncval->channels = 1;\r\ncval->val_type = USB_MIXER_BOOLEAN;\r\ncval->control = UAC2_CS_CONTROL_CLOCK_VALID;\r\nif (uac2_control_is_writeable(hdr->bmControls,\r\nilog2(UAC2_CS_CONTROL_CLOCK_VALID)))\r\nkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\r\nelse {\r\ncval->master_readonly = 1;\r\nkctl = snd_ctl_new1(&usb_feature_unit_ctl_ro, cval);\r\n}\r\nif (!kctl) {\r\nkfree(cval);\r\nreturn -ENOMEM;\r\n}\r\nkctl->private_free = snd_usb_mixer_elem_free;\r\nret = snd_usb_copy_string_desc(state, hdr->iClockSource,\r\nname, sizeof(name));\r\nif (ret > 0)\r\nsnprintf(kctl->id.name, sizeof(kctl->id.name),\r\n"%s Validity", name);\r\nelse\r\nsnprintf(kctl->id.name, sizeof(kctl->id.name),\r\n"Clock Source %d Validity", hdr->bClockID);\r\nreturn snd_usb_mixer_add_control(&cval->head, kctl);\r\n}\r\nstatic int parse_audio_feature_unit(struct mixer_build *state, int unitid,\r\nvoid *_ftr)\r\n{\r\nint channels, i, j;\r\nstruct usb_audio_term iterm;\r\nunsigned int master_bits, first_ch_bits;\r\nint err, csize;\r\nstruct uac_feature_unit_descriptor *hdr = _ftr;\r\n__u8 *bmaControls;\r\nif (state->mixer->protocol == UAC_VERSION_1) {\r\ncsize = hdr->bControlSize;\r\nif (!csize) {\r\nusb_audio_dbg(state->chip,\r\n"unit %u: invalid bControlSize == 0\n",\r\nunitid);\r\nreturn -EINVAL;\r\n}\r\nchannels = (hdr->bLength - 7) / csize - 1;\r\nbmaControls = hdr->bmaControls;\r\nif (hdr->bLength < 7 + csize) {\r\nusb_audio_err(state->chip,\r\n"unit %u: invalid UAC_FEATURE_UNIT descriptor\n",\r\nunitid);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nstruct uac2_feature_unit_descriptor *ftr = _ftr;\r\ncsize = 4;\r\nchannels = (hdr->bLength - 6) / 4 - 1;\r\nbmaControls = ftr->bmaControls;\r\nif (hdr->bLength < 6 + csize) {\r\nusb_audio_err(state->chip,\r\n"unit %u: invalid UAC_FEATURE_UNIT descriptor\n",\r\nunitid);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((err = parse_audio_unit(state, hdr->bSourceID)) < 0)\r\nreturn err;\r\nerr = check_input_term(state, hdr->bSourceID, &iterm);\r\nif (err < 0)\r\nreturn err;\r\nmaster_bits = snd_usb_combine_bytes(bmaControls, csize);\r\nswitch (state->chip->usb_id) {\r\ncase USB_ID(0x08bb, 0x2702):\r\nusb_audio_info(state->chip,\r\n"usbmixer: master volume quirk for PCM2702 chip\n");\r\nmaster_bits &= ~UAC_CONTROL_BIT(UAC_FU_VOLUME);\r\nbreak;\r\ncase USB_ID(0x1130, 0xf211):\r\nusb_audio_info(state->chip,\r\n"usbmixer: volume control quirk for Tenx TP6911 Audio Headset\n");\r\nchannels = 0;\r\nbreak;\r\n}\r\nif (channels > 0)\r\nfirst_ch_bits = snd_usb_combine_bytes(bmaControls + csize, csize);\r\nelse\r\nfirst_ch_bits = 0;\r\nif (state->mixer->protocol == UAC_VERSION_1) {\r\nfor (i = 0; i < 10; i++) {\r\nunsigned int ch_bits = 0;\r\nfor (j = 0; j < channels; j++) {\r\nunsigned int mask;\r\nmask = snd_usb_combine_bytes(bmaControls +\r\ncsize * (j+1), csize);\r\nif (mask & (1 << i))\r\nch_bits |= (1 << j);\r\n}\r\nif (ch_bits & 1)\r\nbuild_feature_ctl(state, _ftr, ch_bits, i,\r\n&iterm, unitid, 0);\r\nif (master_bits & (1 << i))\r\nbuild_feature_ctl(state, _ftr, 0, i, &iterm,\r\nunitid, 0);\r\n}\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(audio_feature_info); i++) {\r\nunsigned int ch_bits = 0;\r\nunsigned int ch_read_only = 0;\r\nfor (j = 0; j < channels; j++) {\r\nunsigned int mask;\r\nmask = snd_usb_combine_bytes(bmaControls +\r\ncsize * (j+1), csize);\r\nif (uac2_control_is_readable(mask, i)) {\r\nch_bits |= (1 << j);\r\nif (!uac2_control_is_writeable(mask, i))\r\nch_read_only |= (1 << j);\r\n}\r\n}\r\nif (ch_bits & 1)\r\nbuild_feature_ctl(state, _ftr, ch_bits, i,\r\n&iterm, unitid, ch_read_only);\r\nif (uac2_control_is_readable(master_bits, i))\r\nbuild_feature_ctl(state, _ftr, 0, i, &iterm, unitid,\r\n!uac2_control_is_writeable(master_bits, i));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void build_mixer_unit_ctl(struct mixer_build *state,\r\nstruct uac_mixer_unit_descriptor *desc,\r\nint in_pin, int in_ch, int unitid,\r\nstruct usb_audio_term *iterm)\r\n{\r\nstruct usb_mixer_elem_info *cval;\r\nunsigned int num_outs = uac_mixer_unit_bNrChannels(desc);\r\nunsigned int i, len;\r\nstruct snd_kcontrol *kctl;\r\nconst struct usbmix_name_map *map;\r\nmap = find_map(state, unitid, 0);\r\nif (check_ignored_ctl(map))\r\nreturn;\r\ncval = kzalloc(sizeof(*cval), GFP_KERNEL);\r\nif (!cval)\r\nreturn;\r\nsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\r\ncval->control = in_ch + 1;\r\ncval->val_type = USB_MIXER_S16;\r\nfor (i = 0; i < num_outs; i++) {\r\n__u8 *c = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\r\nif (check_matrix_bitmap(c, in_ch, i, num_outs)) {\r\ncval->cmask |= (1 << i);\r\ncval->channels++;\r\n}\r\n}\r\nget_min_max(cval, 0);\r\nkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\r\nif (!kctl) {\r\nusb_audio_err(state->chip, "cannot malloc kcontrol\n");\r\nkfree(cval);\r\nreturn;\r\n}\r\nkctl->private_free = snd_usb_mixer_elem_free;\r\nlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\r\nif (!len)\r\nlen = get_term_name(state, iterm, kctl->id.name,\r\nsizeof(kctl->id.name), 0);\r\nif (!len)\r\nlen = sprintf(kctl->id.name, "Mixer Source %d", in_ch + 1);\r\nappend_ctl_name(kctl, " Volume");\r\nusb_audio_dbg(state->chip, "[%d] MU [%s] ch = %d, val = %d/%d\n",\r\ncval->head.id, kctl->id.name, cval->channels, cval->min, cval->max);\r\nsnd_usb_mixer_add_control(&cval->head, kctl);\r\n}\r\nstatic int parse_audio_mixer_unit(struct mixer_build *state, int unitid,\r\nvoid *raw_desc)\r\n{\r\nstruct uac_mixer_unit_descriptor *desc = raw_desc;\r\nstruct usb_audio_term iterm;\r\nint input_pins, num_ins, num_outs;\r\nint pin, ich, err;\r\nif (desc->bLength < 11 || !(input_pins = desc->bNrInPins) ||\r\n!(num_outs = uac_mixer_unit_bNrChannels(desc))) {\r\nusb_audio_err(state->chip,\r\n"invalid MIXER UNIT descriptor %d\n",\r\nunitid);\r\nreturn -EINVAL;\r\n}\r\nnum_ins = 0;\r\nich = 0;\r\nfor (pin = 0; pin < input_pins; pin++) {\r\nerr = parse_audio_unit(state, desc->baSourceID[pin]);\r\nif (err < 0)\r\ncontinue;\r\nif (desc->bLength <= 10 + input_pins)\r\ncontinue;\r\nerr = check_input_term(state, desc->baSourceID[pin], &iterm);\r\nif (err < 0)\r\nreturn err;\r\nnum_ins += iterm.channels;\r\nfor (; ich < num_ins; ich++) {\r\nint och, ich_has_controls = 0;\r\nfor (och = 0; och < num_outs; och++) {\r\n__u8 *c = uac_mixer_unit_bmControls(desc,\r\nstate->mixer->protocol);\r\nif (check_matrix_bitmap(c, ich, och, num_outs)) {\r\nich_has_controls = 1;\r\nbreak;\r\n}\r\n}\r\nif (ich_has_controls)\r\nbuild_mixer_unit_ctl(state, desc, pin, ich,\r\nunitid, &iterm);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixer_ctl_procunit_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nint err, val;\r\nerr = get_cur_ctl_value(cval, cval->control << 8, &val);\r\nif (err < 0) {\r\nucontrol->value.integer.value[0] = cval->min;\r\nreturn filter_error(cval, err);\r\n}\r\nval = get_relative_value(cval, val);\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int mixer_ctl_procunit_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nint val, oval, err;\r\nerr = get_cur_ctl_value(cval, cval->control << 8, &oval);\r\nif (err < 0)\r\nreturn filter_error(cval, err);\r\nval = ucontrol->value.integer.value[0];\r\nval = get_abs_value(cval, val);\r\nif (val != oval) {\r\nset_cur_ctl_value(cval, cval->control << 8, val);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\r\nvoid *raw_desc, struct procunit_info *list,\r\nchar *name)\r\n{\r\nstruct uac_processing_unit_descriptor *desc = raw_desc;\r\nint num_ins = desc->bNrInPins;\r\nstruct usb_mixer_elem_info *cval;\r\nstruct snd_kcontrol *kctl;\r\nint i, err, nameid, type, len;\r\nstruct procunit_info *info;\r\nstruct procunit_value_info *valinfo;\r\nconst struct usbmix_name_map *map;\r\nstatic struct procunit_value_info default_value_info[] = {\r\n{ 0x01, "Switch", USB_MIXER_BOOLEAN },\r\n{ 0 }\r\n};\r\nstatic struct procunit_info default_info = {\r\n0, NULL, default_value_info\r\n};\r\nif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\r\ndesc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\r\nusb_audio_err(state->chip, "invalid %s descriptor (id %d)\n", name, unitid);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_ins; i++) {\r\nif ((err = parse_audio_unit(state, desc->baSourceID[i])) < 0)\r\nreturn err;\r\n}\r\ntype = le16_to_cpu(desc->wProcessType);\r\nfor (info = list; info && info->type; info++)\r\nif (info->type == type)\r\nbreak;\r\nif (!info || !info->type)\r\ninfo = &default_info;\r\nfor (valinfo = info->values; valinfo->control; valinfo++) {\r\n__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\r\nif (!(controls[valinfo->control / 8] & (1 << ((valinfo->control % 8) - 1))))\r\ncontinue;\r\nmap = find_map(state, unitid, valinfo->control);\r\nif (check_ignored_ctl(map))\r\ncontinue;\r\ncval = kzalloc(sizeof(*cval), GFP_KERNEL);\r\nif (!cval)\r\nreturn -ENOMEM;\r\nsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\r\ncval->control = valinfo->control;\r\ncval->val_type = valinfo->val_type;\r\ncval->channels = 1;\r\nif (type == UAC_PROCESS_UP_DOWNMIX && cval->control == UAC_UD_MODE_SELECT) {\r\n__u8 *control_spec = uac_processing_unit_specific(desc, state->mixer->protocol);\r\ncval->min = 1;\r\ncval->max = control_spec[0];\r\ncval->res = 1;\r\ncval->initialized = 1;\r\n} else {\r\nif (type == USB_XU_CLOCK_RATE) {\r\ncval->min = 0;\r\ncval->max = 5;\r\ncval->res = 1;\r\ncval->initialized = 1;\r\n} else\r\nget_min_max(cval, valinfo->min_value);\r\n}\r\nkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\r\nif (!kctl) {\r\nkfree(cval);\r\nreturn -ENOMEM;\r\n}\r\nkctl->private_free = snd_usb_mixer_elem_free;\r\nif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\r\n;\r\n} else if (info->name) {\r\nstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\r\n} else {\r\nnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\r\nlen = 0;\r\nif (nameid)\r\nlen = snd_usb_copy_string_desc(state, nameid,\r\nkctl->id.name,\r\nsizeof(kctl->id.name));\r\nif (!len)\r\nstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\r\n}\r\nappend_ctl_name(kctl, " ");\r\nappend_ctl_name(kctl, valinfo->suffix);\r\nusb_audio_dbg(state->chip,\r\n"[%d] PU [%s] ch = %d, val = %d/%d\n",\r\ncval->head.id, kctl->id.name, cval->channels,\r\ncval->min, cval->max);\r\nerr = snd_usb_mixer_add_control(&cval->head, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_audio_processing_unit(struct mixer_build *state, int unitid,\r\nvoid *raw_desc)\r\n{\r\nreturn build_audio_procunit(state, unitid, raw_desc,\r\nprocunits, "Processing Unit");\r\n}\r\nstatic int parse_audio_extension_unit(struct mixer_build *state, int unitid,\r\nvoid *raw_desc)\r\n{\r\nreturn build_audio_procunit(state, unitid, raw_desc,\r\nextunits, "Extension Unit");\r\n}\r\nstatic int mixer_ctl_selector_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nconst char **itemlist = (const char **)kcontrol->private_value;\r\nif (snd_BUG_ON(!itemlist))\r\nreturn -EINVAL;\r\nreturn snd_ctl_enum_info(uinfo, 1, cval->max, itemlist);\r\n}\r\nstatic int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nint val, err;\r\nerr = get_cur_ctl_value(cval, cval->control << 8, &val);\r\nif (err < 0) {\r\nucontrol->value.enumerated.item[0] = 0;\r\nreturn filter_error(cval, err);\r\n}\r\nval = get_relative_value(cval, val);\r\nucontrol->value.enumerated.item[0] = val;\r\nreturn 0;\r\n}\r\nstatic int mixer_ctl_selector_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *cval = kcontrol->private_data;\r\nint val, oval, err;\r\nerr = get_cur_ctl_value(cval, cval->control << 8, &oval);\r\nif (err < 0)\r\nreturn filter_error(cval, err);\r\nval = ucontrol->value.enumerated.item[0];\r\nval = get_abs_value(cval, val);\r\nif (val != oval) {\r\nset_cur_ctl_value(cval, cval->control << 8, val);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void usb_mixer_selector_elem_free(struct snd_kcontrol *kctl)\r\n{\r\nint i, num_ins = 0;\r\nif (kctl->private_data) {\r\nstruct usb_mixer_elem_info *cval = kctl->private_data;\r\nnum_ins = cval->max;\r\nkfree(cval);\r\nkctl->private_data = NULL;\r\n}\r\nif (kctl->private_value) {\r\nchar **itemlist = (char **)kctl->private_value;\r\nfor (i = 0; i < num_ins; i++)\r\nkfree(itemlist[i]);\r\nkfree(itemlist);\r\nkctl->private_value = 0;\r\n}\r\n}\r\nstatic int parse_audio_selector_unit(struct mixer_build *state, int unitid,\r\nvoid *raw_desc)\r\n{\r\nstruct uac_selector_unit_descriptor *desc = raw_desc;\r\nunsigned int i, nameid, len;\r\nint err;\r\nstruct usb_mixer_elem_info *cval;\r\nstruct snd_kcontrol *kctl;\r\nconst struct usbmix_name_map *map;\r\nchar **namelist;\r\nif (!desc->bNrInPins || desc->bLength < 5 + desc->bNrInPins) {\r\nusb_audio_err(state->chip,\r\n"invalid SELECTOR UNIT descriptor %d\n", unitid);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < desc->bNrInPins; i++) {\r\nif ((err = parse_audio_unit(state, desc->baSourceID[i])) < 0)\r\nreturn err;\r\n}\r\nif (desc->bNrInPins == 1)\r\nreturn 0;\r\nmap = find_map(state, unitid, 0);\r\nif (check_ignored_ctl(map))\r\nreturn 0;\r\ncval = kzalloc(sizeof(*cval), GFP_KERNEL);\r\nif (!cval)\r\nreturn -ENOMEM;\r\nsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\r\ncval->val_type = USB_MIXER_U8;\r\ncval->channels = 1;\r\ncval->min = 1;\r\ncval->max = desc->bNrInPins;\r\ncval->res = 1;\r\ncval->initialized = 1;\r\nif (state->mixer->protocol == UAC_VERSION_1)\r\ncval->control = 0;\r\nelse\r\ncval->control = (desc->bDescriptorSubtype == UAC2_CLOCK_SELECTOR) ?\r\nUAC2_CX_CLOCK_SELECTOR : UAC2_SU_SELECTOR;\r\nnamelist = kmalloc(sizeof(char *) * desc->bNrInPins, GFP_KERNEL);\r\nif (!namelist) {\r\nkfree(cval);\r\nreturn -ENOMEM;\r\n}\r\n#define MAX_ITEM_NAME_LEN 64\r\nfor (i = 0; i < desc->bNrInPins; i++) {\r\nstruct usb_audio_term iterm;\r\nlen = 0;\r\nnamelist[i] = kmalloc(MAX_ITEM_NAME_LEN, GFP_KERNEL);\r\nif (!namelist[i]) {\r\nwhile (i--)\r\nkfree(namelist[i]);\r\nkfree(namelist);\r\nkfree(cval);\r\nreturn -ENOMEM;\r\n}\r\nlen = check_mapped_selector_name(state, unitid, i, namelist[i],\r\nMAX_ITEM_NAME_LEN);\r\nif (! len && check_input_term(state, desc->baSourceID[i], &iterm) >= 0)\r\nlen = get_term_name(state, &iterm, namelist[i], MAX_ITEM_NAME_LEN, 0);\r\nif (! len)\r\nsprintf(namelist[i], "Input %u", i);\r\n}\r\nkctl = snd_ctl_new1(&mixer_selectunit_ctl, cval);\r\nif (! kctl) {\r\nusb_audio_err(state->chip, "cannot malloc kcontrol\n");\r\nkfree(namelist);\r\nkfree(cval);\r\nreturn -ENOMEM;\r\n}\r\nkctl->private_value = (unsigned long)namelist;\r\nkctl->private_free = usb_mixer_selector_elem_free;\r\nnameid = uac_selector_unit_iSelector(desc);\r\nlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\r\nif (len)\r\n;\r\nelse if (nameid)\r\nsnd_usb_copy_string_desc(state, nameid, kctl->id.name,\r\nsizeof(kctl->id.name));\r\nelse {\r\nlen = get_term_name(state, &state->oterm,\r\nkctl->id.name, sizeof(kctl->id.name), 0);\r\nif (!len)\r\nstrlcpy(kctl->id.name, "USB", sizeof(kctl->id.name));\r\nif (desc->bDescriptorSubtype == UAC2_CLOCK_SELECTOR)\r\nappend_ctl_name(kctl, " Clock Source");\r\nelse if ((state->oterm.type & 0xff00) == 0x0100)\r\nappend_ctl_name(kctl, " Capture Source");\r\nelse\r\nappend_ctl_name(kctl, " Playback Source");\r\n}\r\nusb_audio_dbg(state->chip, "[%d] SU [%s] items = %d\n",\r\ncval->head.id, kctl->id.name, desc->bNrInPins);\r\nreturn snd_usb_mixer_add_control(&cval->head, kctl);\r\n}\r\nstatic int parse_audio_unit(struct mixer_build *state, int unitid)\r\n{\r\nunsigned char *p1;\r\nif (test_and_set_bit(unitid, state->unitbitmap))\r\nreturn 0;\r\np1 = find_audio_control_unit(state, unitid);\r\nif (!p1) {\r\nusb_audio_err(state->chip, "unit %d not found!\n", unitid);\r\nreturn -EINVAL;\r\n}\r\nswitch (p1[2]) {\r\ncase UAC_INPUT_TERMINAL:\r\nreturn 0;\r\ncase UAC_MIXER_UNIT:\r\nreturn parse_audio_mixer_unit(state, unitid, p1);\r\ncase UAC2_CLOCK_SOURCE:\r\nreturn parse_clock_source_unit(state, unitid, p1);\r\ncase UAC_SELECTOR_UNIT:\r\ncase UAC2_CLOCK_SELECTOR:\r\nreturn parse_audio_selector_unit(state, unitid, p1);\r\ncase UAC_FEATURE_UNIT:\r\nreturn parse_audio_feature_unit(state, unitid, p1);\r\ncase UAC1_PROCESSING_UNIT:\r\nif (state->mixer->protocol == UAC_VERSION_1)\r\nreturn parse_audio_processing_unit(state, unitid, p1);\r\nelse\r\nreturn 0;\r\ncase UAC1_EXTENSION_UNIT:\r\nif (state->mixer->protocol == UAC_VERSION_1)\r\nreturn parse_audio_extension_unit(state, unitid, p1);\r\nelse\r\nreturn parse_audio_processing_unit(state, unitid, p1);\r\ncase UAC2_EXTENSION_UNIT_V2:\r\nreturn parse_audio_extension_unit(state, unitid, p1);\r\ndefault:\r\nusb_audio_err(state->chip,\r\n"unit %u: unexpected type 0x%02x\n", unitid, p1[2]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\r\n{\r\nkfree(mixer->id_elems);\r\nif (mixer->urb) {\r\nkfree(mixer->urb->transfer_buffer);\r\nusb_free_urb(mixer->urb);\r\n}\r\nusb_free_urb(mixer->rc_urb);\r\nkfree(mixer->rc_setup_packet);\r\nkfree(mixer);\r\n}\r\nstatic int snd_usb_mixer_dev_free(struct snd_device *device)\r\n{\r\nstruct usb_mixer_interface *mixer = device->device_data;\r\nsnd_usb_mixer_free(mixer);\r\nreturn 0;\r\n}\r\nstatic int snd_usb_mixer_controls(struct usb_mixer_interface *mixer)\r\n{\r\nstruct mixer_build state;\r\nint err;\r\nconst struct usbmix_ctl_map *map;\r\nvoid *p;\r\nmemset(&state, 0, sizeof(state));\r\nstate.chip = mixer->chip;\r\nstate.mixer = mixer;\r\nstate.buffer = mixer->hostif->extra;\r\nstate.buflen = mixer->hostif->extralen;\r\nfor (map = usbmix_ctl_maps; map->id; map++) {\r\nif (map->id == state.chip->usb_id) {\r\nstate.map = map->map;\r\nstate.selector_map = map->selector_map;\r\nmixer->ignore_ctl_error = map->ignore_ctl_error;\r\nbreak;\r\n}\r\n}\r\np = NULL;\r\nwhile ((p = snd_usb_find_csint_desc(mixer->hostif->extra,\r\nmixer->hostif->extralen,\r\np, UAC_OUTPUT_TERMINAL)) != NULL) {\r\nif (mixer->protocol == UAC_VERSION_1) {\r\nstruct uac1_output_terminal_descriptor *desc = p;\r\nif (desc->bLength < sizeof(*desc))\r\ncontinue;\r\nset_bit(desc->bTerminalID, state.unitbitmap);\r\nstate.oterm.id = desc->bTerminalID;\r\nstate.oterm.type = le16_to_cpu(desc->wTerminalType);\r\nstate.oterm.name = desc->iTerminal;\r\nerr = parse_audio_unit(&state, desc->bSourceID);\r\nif (err < 0 && err != -EINVAL)\r\nreturn err;\r\n} else {\r\nstruct uac2_output_terminal_descriptor *desc = p;\r\nif (desc->bLength < sizeof(*desc))\r\ncontinue;\r\nset_bit(desc->bTerminalID, state.unitbitmap);\r\nstate.oterm.id = desc->bTerminalID;\r\nstate.oterm.type = le16_to_cpu(desc->wTerminalType);\r\nstate.oterm.name = desc->iTerminal;\r\nerr = parse_audio_unit(&state, desc->bSourceID);\r\nif (err < 0 && err != -EINVAL)\r\nreturn err;\r\nerr = parse_audio_unit(&state, desc->bCSourceID);\r\nif (err < 0 && err != -EINVAL)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_usb_mixer_notify_id(struct usb_mixer_interface *mixer, int unitid)\r\n{\r\nstruct usb_mixer_elem_list *list;\r\nfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem)\r\nsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&list->kctl->id);\r\n}\r\nstatic void snd_usb_mixer_dump_cval(struct snd_info_buffer *buffer,\r\nstruct usb_mixer_elem_list *list)\r\n{\r\nstruct usb_mixer_elem_info *cval = (struct usb_mixer_elem_info *)list;\r\nstatic char *val_types[] = {"BOOLEAN", "INV_BOOLEAN",\r\n"S8", "U8", "S16", "U16"};\r\nsnd_iprintf(buffer, " Info: id=%i, control=%i, cmask=0x%x, "\r\n"channels=%i, type=\"%s\"\n", cval->head.id,\r\ncval->control, cval->cmask, cval->channels,\r\nval_types[cval->val_type]);\r\nsnd_iprintf(buffer, " Volume: min=%i, max=%i, dBmin=%i, dBmax=%i\n",\r\ncval->min, cval->max, cval->dBmin, cval->dBmax);\r\n}\r\nstatic void snd_usb_mixer_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_usb_audio *chip = entry->private_data;\r\nstruct usb_mixer_interface *mixer;\r\nstruct usb_mixer_elem_list *list;\r\nint unitid;\r\nlist_for_each_entry(mixer, &chip->mixer_list, list) {\r\nsnd_iprintf(buffer,\r\n"USB Mixer: usb_id=0x%08x, ctrlif=%i, ctlerr=%i\n",\r\nchip->usb_id, snd_usb_ctrl_intf(chip),\r\nmixer->ignore_ctl_error);\r\nsnd_iprintf(buffer, "Card: %s\n", chip->card->longname);\r\nfor (unitid = 0; unitid < MAX_ID_ELEMS; unitid++) {\r\nfor (list = mixer->id_elems[unitid]; list;\r\nlist = list->next_id_elem) {\r\nsnd_iprintf(buffer, " Unit: %i\n", list->id);\r\nif (list->kctl)\r\nsnd_iprintf(buffer,\r\n" Control: name=\"%s\", index=%i\n",\r\nlist->kctl->id.name,\r\nlist->kctl->id.index);\r\nif (list->dump)\r\nlist->dump(buffer, list);\r\n}\r\n}\r\n}\r\n}\r\nstatic void snd_usb_mixer_interrupt_v2(struct usb_mixer_interface *mixer,\r\nint attribute, int value, int index)\r\n{\r\nstruct usb_mixer_elem_list *list;\r\n__u8 unitid = (index >> 8) & 0xff;\r\n__u8 control = (value >> 8) & 0xff;\r\n__u8 channel = value & 0xff;\r\nunsigned int count = 0;\r\nif (channel >= MAX_CHANNELS) {\r\nusb_audio_dbg(mixer->chip,\r\n"%s(): bogus channel number %d\n",\r\n__func__, channel);\r\nreturn;\r\n}\r\nfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem)\r\ncount++;\r\nif (count == 0)\r\nreturn;\r\nfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem) {\r\nstruct usb_mixer_elem_info *info;\r\nif (!list->kctl)\r\ncontinue;\r\ninfo = (struct usb_mixer_elem_info *)list;\r\nif (count > 1 && info->control != control)\r\ncontinue;\r\nswitch (attribute) {\r\ncase UAC2_CS_CUR:\r\nif (channel)\r\ninfo->cached &= ~(1 << channel);\r\nelse\r\ninfo->cached = 0;\r\nsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&info->head.kctl->id);\r\nbreak;\r\ncase UAC2_CS_RANGE:\r\nbreak;\r\ncase UAC2_CS_MEM:\r\nbreak;\r\ndefault:\r\nusb_audio_dbg(mixer->chip,\r\n"unknown attribute %d in interrupt\n",\r\nattribute);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void snd_usb_mixer_interrupt(struct urb *urb)\r\n{\r\nstruct usb_mixer_interface *mixer = urb->context;\r\nint len = urb->actual_length;\r\nint ustatus = urb->status;\r\nif (ustatus != 0)\r\ngoto requeue;\r\nif (mixer->protocol == UAC_VERSION_1) {\r\nstruct uac1_status_word *status;\r\nfor (status = urb->transfer_buffer;\r\nlen >= sizeof(*status);\r\nlen -= sizeof(*status), status++) {\r\ndev_dbg(&urb->dev->dev, "status interrupt: %02x %02x\n",\r\nstatus->bStatusType,\r\nstatus->bOriginator);\r\nif ((status->bStatusType & UAC1_STATUS_TYPE_ORIG_MASK) !=\r\nUAC1_STATUS_TYPE_ORIG_AUDIO_CONTROL_IF)\r\ncontinue;\r\nif (status->bStatusType & UAC1_STATUS_TYPE_MEM_CHANGED)\r\nsnd_usb_mixer_rc_memory_change(mixer, status->bOriginator);\r\nelse\r\nsnd_usb_mixer_notify_id(mixer, status->bOriginator);\r\n}\r\n} else {\r\nstruct uac2_interrupt_data_msg *msg;\r\nfor (msg = urb->transfer_buffer;\r\nlen >= sizeof(*msg);\r\nlen -= sizeof(*msg), msg++) {\r\nif ((msg->bInfo & UAC2_INTERRUPT_DATA_MSG_VENDOR) ||\r\n(msg->bInfo & UAC2_INTERRUPT_DATA_MSG_EP))\r\ncontinue;\r\nsnd_usb_mixer_interrupt_v2(mixer, msg->bAttribute,\r\nle16_to_cpu(msg->wValue),\r\nle16_to_cpu(msg->wIndex));\r\n}\r\n}\r\nrequeue:\r\nif (ustatus != -ENOENT &&\r\nustatus != -ECONNRESET &&\r\nustatus != -ESHUTDOWN) {\r\nurb->dev = mixer->chip->dev;\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\n}\r\nstatic int snd_usb_mixer_status_create(struct usb_mixer_interface *mixer)\r\n{\r\nstruct usb_endpoint_descriptor *ep;\r\nvoid *transfer_buffer;\r\nint buffer_length;\r\nunsigned int epnum;\r\nif (get_iface_desc(mixer->hostif)->bNumEndpoints < 1)\r\nreturn 0;\r\nep = get_endpoint(mixer->hostif, 0);\r\nif (!usb_endpoint_dir_in(ep) || !usb_endpoint_xfer_int(ep))\r\nreturn 0;\r\nepnum = usb_endpoint_num(ep);\r\nbuffer_length = le16_to_cpu(ep->wMaxPacketSize);\r\ntransfer_buffer = kmalloc(buffer_length, GFP_KERNEL);\r\nif (!transfer_buffer)\r\nreturn -ENOMEM;\r\nmixer->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!mixer->urb) {\r\nkfree(transfer_buffer);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_int_urb(mixer->urb, mixer->chip->dev,\r\nusb_rcvintpipe(mixer->chip->dev, epnum),\r\ntransfer_buffer, buffer_length,\r\nsnd_usb_mixer_interrupt, mixer, ep->bInterval);\r\nusb_submit_urb(mixer->urb, GFP_KERNEL);\r\nreturn 0;\r\n}\r\nint snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,\r\nint ignore_error)\r\n{\r\nstatic struct snd_device_ops dev_ops = {\r\n.dev_free = snd_usb_mixer_dev_free\r\n};\r\nstruct usb_mixer_interface *mixer;\r\nstruct snd_info_entry *entry;\r\nint err;\r\nstrcpy(chip->card->mixername, "USB Mixer");\r\nmixer = kzalloc(sizeof(*mixer), GFP_KERNEL);\r\nif (!mixer)\r\nreturn -ENOMEM;\r\nmixer->chip = chip;\r\nmixer->ignore_ctl_error = ignore_error;\r\nmixer->id_elems = kcalloc(MAX_ID_ELEMS, sizeof(*mixer->id_elems),\r\nGFP_KERNEL);\r\nif (!mixer->id_elems) {\r\nkfree(mixer);\r\nreturn -ENOMEM;\r\n}\r\nmixer->hostif = &usb_ifnum_to_if(chip->dev, ctrlif)->altsetting[0];\r\nswitch (get_iface_desc(mixer->hostif)->bInterfaceProtocol) {\r\ncase UAC_VERSION_1:\r\ndefault:\r\nmixer->protocol = UAC_VERSION_1;\r\nbreak;\r\ncase UAC_VERSION_2:\r\nmixer->protocol = UAC_VERSION_2;\r\nbreak;\r\n}\r\nif ((err = snd_usb_mixer_controls(mixer)) < 0 ||\r\n(err = snd_usb_mixer_status_create(mixer)) < 0)\r\ngoto _error;\r\nsnd_usb_mixer_apply_create_quirk(mixer);\r\nerr = snd_device_new(chip->card, SNDRV_DEV_CODEC, mixer, &dev_ops);\r\nif (err < 0)\r\ngoto _error;\r\nif (list_empty(&chip->mixer_list) &&\r\n!snd_card_proc_new(chip->card, "usbmixer", &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_usb_mixer_proc_read);\r\nlist_add(&mixer->list, &chip->mixer_list);\r\nreturn 0;\r\n_error:\r\nsnd_usb_mixer_free(mixer);\r\nreturn err;\r\n}\r\nvoid snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\r\n{\r\nusb_kill_urb(mixer->urb);\r\nusb_kill_urb(mixer->rc_urb);\r\n}\r\nstatic void snd_usb_mixer_inactivate(struct usb_mixer_interface *mixer)\r\n{\r\nusb_kill_urb(mixer->urb);\r\nusb_kill_urb(mixer->rc_urb);\r\n}\r\nstatic int snd_usb_mixer_activate(struct usb_mixer_interface *mixer)\r\n{\r\nint err;\r\nif (mixer->urb) {\r\nerr = usb_submit_urb(mixer->urb, GFP_NOIO);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_usb_mixer_suspend(struct usb_mixer_interface *mixer)\r\n{\r\nsnd_usb_mixer_inactivate(mixer);\r\nreturn 0;\r\n}\r\nstatic int restore_mixer_value(struct usb_mixer_elem_list *list)\r\n{\r\nstruct usb_mixer_elem_info *cval = (struct usb_mixer_elem_info *)list;\r\nint c, err, idx;\r\nif (cval->cmask) {\r\nidx = 0;\r\nfor (c = 0; c < MAX_CHANNELS; c++) {\r\nif (!(cval->cmask & (1 << c)))\r\ncontinue;\r\nif (cval->cached & (1 << (c + 1))) {\r\nerr = snd_usb_set_cur_mix_value(cval, c + 1, idx,\r\ncval->cache_val[idx]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nidx++;\r\n}\r\n} else {\r\nif (cval->cached) {\r\nerr = snd_usb_set_cur_mix_value(cval, 0, 0, *cval->cache_val);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_usb_mixer_resume(struct usb_mixer_interface *mixer, bool reset_resume)\r\n{\r\nstruct usb_mixer_elem_list *list;\r\nint id, err;\r\nif (reset_resume) {\r\nfor (id = 0; id < MAX_ID_ELEMS; id++) {\r\nfor (list = mixer->id_elems[id]; list;\r\nlist = list->next_id_elem) {\r\nif (list->resume) {\r\nerr = list->resume(list);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\n}\r\n}\r\nreturn snd_usb_mixer_activate(mixer);\r\n}\r\nvoid snd_usb_mixer_elem_init_std(struct usb_mixer_elem_list *list,\r\nstruct usb_mixer_interface *mixer,\r\nint unitid)\r\n{\r\nlist->mixer = mixer;\r\nlist->id = unitid;\r\nlist->dump = snd_usb_mixer_dump_cval;\r\n#ifdef CONFIG_PM\r\nlist->resume = restore_mixer_value;\r\n#endif\r\n}
