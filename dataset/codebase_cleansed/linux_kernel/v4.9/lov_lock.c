static struct lov_sublock_env *lov_sublock_env_get(const struct lu_env *env,\r\nconst struct cl_lock *parent,\r\nstruct lov_lock_sub *lls)\r\n{\r\nstruct lov_sublock_env *subenv;\r\nstruct lov_io *lio = lov_env_io(env);\r\nstruct cl_io *io = lio->lis_cl.cis_io;\r\nstruct lov_io_sub *sub;\r\nsubenv = &lov_env_session(env)->ls_subenv;\r\nif (!io || !cl_object_same(io->ci_obj, parent->cll_descr.cld_obj)) {\r\nsubenv->lse_env = env;\r\nsubenv->lse_io = io;\r\nsubenv->lse_sub = NULL;\r\n} else {\r\nsub = lov_sub_get(env, lio, lls->sub_stripe);\r\nif (!IS_ERR(sub)) {\r\nsubenv->lse_env = sub->sub_env;\r\nsubenv->lse_io = sub->sub_io;\r\nsubenv->lse_sub = sub;\r\n} else {\r\nsubenv = (void *)sub;\r\n}\r\n}\r\nreturn subenv;\r\n}\r\nstatic void lov_sublock_env_put(struct lov_sublock_env *subenv)\r\n{\r\nif (subenv && subenv->lse_sub)\r\nlov_sub_put(subenv->lse_sub);\r\n}\r\nstatic int lov_sublock_init(const struct lu_env *env,\r\nconst struct cl_lock *parent,\r\nstruct lov_lock_sub *lls)\r\n{\r\nstruct lov_sublock_env *subenv;\r\nint result;\r\nsubenv = lov_sublock_env_get(env, parent, lls);\r\nif (!IS_ERR(subenv)) {\r\nresult = cl_lock_init(subenv->lse_env, &lls->sub_lock,\r\nsubenv->lse_io);\r\nlov_sublock_env_put(subenv);\r\n} else {\r\nresult = PTR_ERR(subenv);\r\n}\r\nreturn result;\r\n}\r\nstatic struct lov_lock *lov_lock_sub_init(const struct lu_env *env,\r\nconst struct cl_object *obj,\r\nstruct cl_lock *lock)\r\n{\r\nint result = 0;\r\nint i;\r\nint nr;\r\nu64 start;\r\nu64 end;\r\nu64 file_start;\r\nu64 file_end;\r\nstruct lov_object *loo = cl2lov(obj);\r\nstruct lov_layout_raid0 *r0 = lov_r0(loo);\r\nstruct lov_lock *lovlck;\r\nfile_start = cl_offset(lov2cl(loo), lock->cll_descr.cld_start);\r\nfile_end = cl_offset(lov2cl(loo), lock->cll_descr.cld_end + 1) - 1;\r\nfor (i = 0, nr = 0; i < r0->lo_nr; i++) {\r\nif (likely(r0->lo_sub[i]) &&\r\nlov_stripe_intersects(loo->lo_lsm, i,\r\nfile_start, file_end, &start, &end))\r\nnr++;\r\n}\r\nLASSERT(nr > 0);\r\nlovlck = libcfs_kvzalloc(offsetof(struct lov_lock, lls_sub[nr]),\r\nGFP_NOFS);\r\nif (!lovlck)\r\nreturn ERR_PTR(-ENOMEM);\r\nlovlck->lls_nr = nr;\r\nfor (i = 0, nr = 0; i < r0->lo_nr; ++i) {\r\nif (likely(r0->lo_sub[i]) &&\r\nlov_stripe_intersects(loo->lo_lsm, i,\r\nfile_start, file_end, &start, &end)) {\r\nstruct lov_lock_sub *lls = &lovlck->lls_sub[nr];\r\nstruct cl_lock_descr *descr;\r\ndescr = &lls->sub_lock.cll_descr;\r\nLASSERT(!descr->cld_obj);\r\ndescr->cld_obj = lovsub2cl(r0->lo_sub[i]);\r\ndescr->cld_start = cl_index(descr->cld_obj, start);\r\ndescr->cld_end = cl_index(descr->cld_obj, end);\r\ndescr->cld_mode = lock->cll_descr.cld_mode;\r\ndescr->cld_gid = lock->cll_descr.cld_gid;\r\ndescr->cld_enq_flags = lock->cll_descr.cld_enq_flags;\r\nlls->sub_stripe = i;\r\nresult = lov_sublock_init(env, lock, lls);\r\nif (result < 0)\r\nbreak;\r\nlls->sub_initialized = 1;\r\nnr++;\r\n}\r\n}\r\nLASSERT(ergo(result == 0, nr == lovlck->lls_nr));\r\nif (result != 0) {\r\nfor (i = 0; i < nr; ++i) {\r\nif (!lovlck->lls_sub[i].sub_initialized)\r\nbreak;\r\ncl_lock_fini(env, &lovlck->lls_sub[i].sub_lock);\r\n}\r\nkvfree(lovlck);\r\nlovlck = ERR_PTR(result);\r\n}\r\nreturn lovlck;\r\n}\r\nstatic void lov_lock_fini(const struct lu_env *env,\r\nstruct cl_lock_slice *slice)\r\n{\r\nstruct lov_lock *lovlck;\r\nint i;\r\nlovlck = cl2lov_lock(slice);\r\nfor (i = 0; i < lovlck->lls_nr; ++i) {\r\nLASSERT(!lovlck->lls_sub[i].sub_is_enqueued);\r\nif (lovlck->lls_sub[i].sub_initialized)\r\ncl_lock_fini(env, &lovlck->lls_sub[i].sub_lock);\r\n}\r\nkvfree(lovlck);\r\n}\r\nstatic int lov_lock_enqueue(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice,\r\nstruct cl_io *io, struct cl_sync_io *anchor)\r\n{\r\nstruct cl_lock *lock = slice->cls_lock;\r\nstruct lov_lock *lovlck = cl2lov_lock(slice);\r\nint i;\r\nint rc = 0;\r\nfor (i = 0; i < lovlck->lls_nr; ++i) {\r\nstruct lov_lock_sub *lls = &lovlck->lls_sub[i];\r\nstruct lov_sublock_env *subenv;\r\nsubenv = lov_sublock_env_get(env, lock, lls);\r\nif (IS_ERR(subenv)) {\r\nrc = PTR_ERR(subenv);\r\nbreak;\r\n}\r\nrc = cl_lock_enqueue(subenv->lse_env, subenv->lse_io,\r\n&lls->sub_lock, anchor);\r\nlov_sublock_env_put(subenv);\r\nif (rc != 0)\r\nbreak;\r\nlls->sub_is_enqueued = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic void lov_lock_cancel(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice)\r\n{\r\nstruct cl_lock *lock = slice->cls_lock;\r\nstruct lov_lock *lovlck = cl2lov_lock(slice);\r\nint i;\r\nfor (i = 0; i < lovlck->lls_nr; ++i) {\r\nstruct lov_lock_sub *lls = &lovlck->lls_sub[i];\r\nstruct cl_lock *sublock = &lls->sub_lock;\r\nstruct lov_sublock_env *subenv;\r\nif (!lls->sub_is_enqueued)\r\ncontinue;\r\nlls->sub_is_enqueued = 0;\r\nsubenv = lov_sublock_env_get(env, lock, lls);\r\nif (!IS_ERR(subenv)) {\r\ncl_lock_cancel(subenv->lse_env, sublock);\r\nlov_sublock_env_put(subenv);\r\n} else {\r\nCL_LOCK_DEBUG(D_ERROR, env, slice->cls_lock,\r\n"lov_lock_cancel fails with %ld.\n",\r\nPTR_ERR(subenv));\r\n}\r\n}\r\n}\r\nstatic int lov_lock_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct cl_lock_slice *slice)\r\n{\r\nstruct lov_lock *lck = cl2lov_lock(slice);\r\nint i;\r\n(*p)(env, cookie, "%d\n", lck->lls_nr);\r\nfor (i = 0; i < lck->lls_nr; ++i) {\r\nstruct lov_lock_sub *sub;\r\nsub = &lck->lls_sub[i];\r\n(*p)(env, cookie, " %d %x: ", i, sub->sub_is_enqueued);\r\ncl_lock_print(env, cookie, p, &sub->sub_lock);\r\n}\r\nreturn 0;\r\n}\r\nint lov_lock_init_raid0(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_lock *lock, const struct cl_io *io)\r\n{\r\nstruct lov_lock *lck;\r\nint result = 0;\r\nlck = lov_lock_sub_init(env, obj, lock);\r\nif (!IS_ERR(lck))\r\ncl_lock_slice_add(lock, &lck->lls_cl, obj, &lov_lock_ops);\r\nelse\r\nresult = PTR_ERR(lck);\r\nreturn result;\r\n}\r\nstatic void lov_empty_lock_fini(const struct lu_env *env,\r\nstruct cl_lock_slice *slice)\r\n{\r\nstruct lov_lock *lck = cl2lov_lock(slice);\r\nkmem_cache_free(lov_lock_kmem, lck);\r\n}\r\nstatic int lov_empty_lock_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p,\r\nconst struct cl_lock_slice *slice)\r\n{\r\n(*p)(env, cookie, "empty\n");\r\nreturn 0;\r\n}\r\nint lov_lock_init_empty(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_lock *lock, const struct cl_io *io)\r\n{\r\nstruct lov_lock *lck;\r\nint result = -ENOMEM;\r\nlck = kmem_cache_zalloc(lov_lock_kmem, GFP_NOFS);\r\nif (lck) {\r\ncl_lock_slice_add(lock, &lck->lls_cl, obj, &lov_empty_lock_ops);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}
