static int atmel_read(struct atmel_captouch_device *capdev,\r\nu8 reg, u8 *data, size_t len)\r\n{\r\nstruct i2c_client *client = capdev->client;\r\nstruct device *dev = &client->dev;\r\nstruct i2c_msg msg[2];\r\nint err;\r\nif (len > sizeof(capdev->xfer_buf) - 2)\r\nreturn -EINVAL;\r\ncapdev->xfer_buf[0] = reg;\r\ncapdev->xfer_buf[1] = len;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].buf = capdev->xfer_buf;\r\nmsg[0].len = 2;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = capdev->xfer_buf;\r\nmsg[1].len = len + 2;\r\nerr = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\r\nif (err != ARRAY_SIZE(msg))\r\nreturn err < 0 ? err : -EIO;\r\nif (capdev->xfer_buf[0] != reg) {\r\ndev_err(dev,\r\n"I2C read error: register address does not match (%#02x vs %02x)\n",\r\ncapdev->xfer_buf[0], reg);\r\nreturn -ECOMM;\r\n}\r\nmemcpy(data, &capdev->xfer_buf[2], len);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t atmel_captouch_isr(int irq, void *data)\r\n{\r\nstruct atmel_captouch_device *capdev = data;\r\nstruct device *dev = &capdev->client->dev;\r\nint error;\r\nint i;\r\nu8 new_btn;\r\nu8 changed_btn;\r\nerror = atmel_read(capdev, REG_KEY_STATE, &new_btn, 1);\r\nif (error) {\r\ndev_err(dev, "failed to read button state: %d\n", error);\r\ngoto out;\r\n}\r\ndev_dbg(dev, "%s: button state %#02x\n", __func__, new_btn);\r\nchanged_btn = new_btn ^ capdev->prev_btn;\r\ncapdev->prev_btn = new_btn;\r\nfor (i = 0; i < capdev->num_btn; i++) {\r\nif (changed_btn & BIT(i))\r\ninput_report_key(capdev->input,\r\ncapdev->keycodes[i],\r\nnew_btn & BIT(i));\r\n}\r\ninput_sync(capdev->input);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmel_captouch_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct atmel_captouch_device *capdev;\r\nstruct device *dev = &client->dev;\r\nstruct device_node *node;\r\nint i;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK)) {\r\ndev_err(dev, "needed i2c functionality is not supported\n");\r\nreturn -EINVAL;\r\n}\r\ncapdev = devm_kzalloc(dev, sizeof(*capdev), GFP_KERNEL);\r\nif (!capdev)\r\nreturn -ENOMEM;\r\ncapdev->client = client;\r\ni2c_set_clientdata(client, capdev);\r\nerr = atmel_read(capdev, REG_KEY_STATE,\r\n&capdev->prev_btn, sizeof(capdev->prev_btn));\r\nif (err) {\r\ndev_err(dev, "failed to read initial button state: %d\n", err);\r\nreturn err;\r\n}\r\ncapdev->input = devm_input_allocate_device(dev);\r\nif (!capdev->input) {\r\ndev_err(dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ncapdev->input->id.bustype = BUS_I2C;\r\ncapdev->input->id.product = 0x880A;\r\ncapdev->input->id.version = 0;\r\ncapdev->input->name = "ATMegaXX Capacitive Button Controller";\r\n__set_bit(EV_KEY, capdev->input->evbit);\r\nnode = dev->of_node;\r\nif (!node) {\r\ndev_err(dev, "failed to find matching node in device tree\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_bool(node, "autorepeat"))\r\n__set_bit(EV_REP, capdev->input->evbit);\r\ncapdev->num_btn = of_property_count_u32_elems(node, "linux,keymap");\r\nif (capdev->num_btn > MAX_NUM_OF_BUTTONS)\r\ncapdev->num_btn = MAX_NUM_OF_BUTTONS;\r\nerr = of_property_read_u32_array(node, "linux,keycodes",\r\ncapdev->keycodes,\r\ncapdev->num_btn);\r\nif (err) {\r\ndev_err(dev,\r\n"failed to read linux,keycode property: %d\n", err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < capdev->num_btn; i++)\r\n__set_bit(capdev->keycodes[i], capdev->input->keybit);\r\ncapdev->input->keycode = capdev->keycodes;\r\ncapdev->input->keycodesize = sizeof(capdev->keycodes[0]);\r\ncapdev->input->keycodemax = capdev->num_btn;\r\nerr = input_register_device(capdev->input);\r\nif (err)\r\nreturn err;\r\nerr = devm_request_threaded_irq(dev, client->irq,\r\nNULL, atmel_captouch_isr,\r\nIRQF_ONESHOT,\r\n"atmel_captouch", capdev);\r\nif (err) {\r\ndev_err(dev, "failed to request irq %d: %d\n",\r\nclient->irq, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
