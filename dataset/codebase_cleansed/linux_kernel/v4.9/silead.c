static int silead_ts_request_input_dev(struct silead_ts_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nint error;\r\ndata->input = devm_input_allocate_device(dev);\r\nif (!data->input) {\r\ndev_err(dev,\r\n"Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_set_abs_params(data->input, ABS_MT_POSITION_X, 0, 4095, 0, 0);\r\ninput_set_abs_params(data->input, ABS_MT_POSITION_Y, 0, 4095, 0, 0);\r\ntouchscreen_parse_properties(data->input, true, &data->prop);\r\ninput_mt_init_slots(data->input, data->max_fingers,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED |\r\nINPUT_MT_TRACK);\r\ndata->input->name = SILEAD_TS_NAME;\r\ndata->input->phys = "input/ts";\r\ndata->input->id.bustype = BUS_I2C;\r\nerror = input_register_device(data->input);\r\nif (error) {\r\ndev_err(dev, "Failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void silead_ts_set_power(struct i2c_client *client,\r\nenum silead_ts_power state)\r\n{\r\nstruct silead_ts_data *data = i2c_get_clientdata(client);\r\nif (data->gpio_power) {\r\ngpiod_set_value_cansleep(data->gpio_power, state);\r\nmsleep(SILEAD_POWER_SLEEP);\r\n}\r\n}\r\nstatic void silead_ts_read_data(struct i2c_client *client)\r\n{\r\nstruct silead_ts_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input = data->input;\r\nstruct device *dev = &client->dev;\r\nu8 *bufp, buf[SILEAD_TS_DATA_LEN];\r\nint touch_nr, error, i;\r\nerror = i2c_smbus_read_i2c_block_data(client, SILEAD_REG_DATA,\r\nSILEAD_TS_DATA_LEN, buf);\r\nif (error < 0) {\r\ndev_err(dev, "Data read error %d\n", error);\r\nreturn;\r\n}\r\ntouch_nr = buf[0];\r\nif (touch_nr > data->max_fingers) {\r\ndev_warn(dev, "More touches reported then supported %d > %d\n",\r\ntouch_nr, data->max_fingers);\r\ntouch_nr = data->max_fingers;\r\n}\r\nbufp = buf + SILEAD_POINT_DATA_LEN;\r\nfor (i = 0; i < touch_nr; i++, bufp += SILEAD_POINT_DATA_LEN) {\r\ndata->id[i] = (bufp[SILEAD_POINT_X_MSB_OFF] &\r\nSILEAD_TOUCH_ID_MASK) >> 4;\r\ntouchscreen_set_mt_pos(&data->pos[i], &data->prop,\r\nget_unaligned_le16(&bufp[SILEAD_POINT_X_OFF]) & 0xfff,\r\nget_unaligned_le16(&bufp[SILEAD_POINT_Y_OFF]) & 0xfff);\r\n}\r\ninput_mt_assign_slots(input, data->slots, data->pos, touch_nr, 0);\r\nfor (i = 0; i < touch_nr; i++) {\r\ninput_mt_slot(input, data->slots[i]);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\r\ninput_report_abs(input, ABS_MT_POSITION_X, data->pos[i].x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, data->pos[i].y);\r\ndev_dbg(dev, "x=%d y=%d hw_id=%d sw_id=%d\n", data->pos[i].x,\r\ndata->pos[i].y, data->id[i], data->slots[i]);\r\n}\r\ninput_mt_sync_frame(input);\r\ninput_sync(input);\r\n}\r\nstatic int silead_ts_init(struct i2c_client *client)\r\n{\r\nstruct silead_ts_data *data = i2c_get_clientdata(client);\r\nint error;\r\nerror = i2c_smbus_write_byte_data(client, SILEAD_REG_RESET,\r\nSILEAD_CMD_RESET);\r\nif (error)\r\ngoto i2c_write_err;\r\nusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\r\nerror = i2c_smbus_write_byte_data(client, SILEAD_REG_TOUCH_NR,\r\ndata->max_fingers);\r\nif (error)\r\ngoto i2c_write_err;\r\nusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\r\nerror = i2c_smbus_write_byte_data(client, SILEAD_REG_CLOCK,\r\nSILEAD_CLOCK);\r\nif (error)\r\ngoto i2c_write_err;\r\nusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\r\nerror = i2c_smbus_write_byte_data(client, SILEAD_REG_RESET,\r\nSILEAD_CMD_START);\r\nif (error)\r\ngoto i2c_write_err;\r\nusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\r\nreturn 0;\r\ni2c_write_err:\r\ndev_err(&client->dev, "Registers clear error %d\n", error);\r\nreturn error;\r\n}\r\nstatic int silead_ts_reset(struct i2c_client *client)\r\n{\r\nint error;\r\nerror = i2c_smbus_write_byte_data(client, SILEAD_REG_RESET,\r\nSILEAD_CMD_RESET);\r\nif (error)\r\ngoto i2c_write_err;\r\nusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\r\nerror = i2c_smbus_write_byte_data(client, SILEAD_REG_CLOCK,\r\nSILEAD_CLOCK);\r\nif (error)\r\ngoto i2c_write_err;\r\nusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\r\nerror = i2c_smbus_write_byte_data(client, SILEAD_REG_POWER,\r\nSILEAD_CMD_START);\r\nif (error)\r\ngoto i2c_write_err;\r\nusleep_range(SILEAD_CMD_SLEEP_MIN, SILEAD_CMD_SLEEP_MAX);\r\nreturn 0;\r\ni2c_write_err:\r\ndev_err(&client->dev, "Chip reset error %d\n", error);\r\nreturn error;\r\n}\r\nstatic int silead_ts_startup(struct i2c_client *client)\r\n{\r\nint error;\r\nerror = i2c_smbus_write_byte_data(client, SILEAD_REG_RESET, 0x00);\r\nif (error) {\r\ndev_err(&client->dev, "Startup error %d\n", error);\r\nreturn error;\r\n}\r\nmsleep(SILEAD_STARTUP_SLEEP);\r\nreturn 0;\r\n}\r\nstatic int silead_ts_load_fw(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct silead_ts_data *data = i2c_get_clientdata(client);\r\nunsigned int fw_size, i;\r\nconst struct firmware *fw;\r\nstruct silead_fw_data *fw_data;\r\nint error;\r\ndev_dbg(dev, "Firmware file name: %s", data->fw_name);\r\nerror = request_firmware(&fw, data->fw_name, dev);\r\nif (error) {\r\ndev_err(dev, "Firmware request error %d\n", error);\r\nreturn error;\r\n}\r\nfw_size = fw->size / sizeof(*fw_data);\r\nfw_data = (struct silead_fw_data *)fw->data;\r\nfor (i = 0; i < fw_size; i++) {\r\nerror = i2c_smbus_write_i2c_block_data(client,\r\nfw_data[i].offset,\r\n4,\r\n(u8 *)&fw_data[i].val);\r\nif (error) {\r\ndev_err(dev, "Firmware load error %d\n", error);\r\nbreak;\r\n}\r\n}\r\nrelease_firmware(fw);\r\nreturn error ?: 0;\r\n}\r\nstatic u32 silead_ts_get_status(struct i2c_client *client)\r\n{\r\nint error;\r\n__le32 status;\r\nerror = i2c_smbus_read_i2c_block_data(client, SILEAD_REG_STATUS,\r\nsizeof(status), (u8 *)&status);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Status read error %d\n", error);\r\nreturn error;\r\n}\r\nreturn le32_to_cpu(status);\r\n}\r\nstatic int silead_ts_get_id(struct i2c_client *client)\r\n{\r\nstruct silead_ts_data *data = i2c_get_clientdata(client);\r\n__le32 chip_id;\r\nint error;\r\nerror = i2c_smbus_read_i2c_block_data(client, SILEAD_REG_ID,\r\nsizeof(chip_id), (u8 *)&chip_id);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Chip ID read error %d\n", error);\r\nreturn error;\r\n}\r\ndata->chip_id = le32_to_cpu(chip_id);\r\ndev_info(&client->dev, "Silead chip ID: 0x%8X", data->chip_id);\r\nreturn 0;\r\n}\r\nstatic int silead_ts_setup(struct i2c_client *client)\r\n{\r\nint error;\r\nu32 status;\r\nsilead_ts_set_power(client, SILEAD_POWER_OFF);\r\nsilead_ts_set_power(client, SILEAD_POWER_ON);\r\nerror = silead_ts_get_id(client);\r\nif (error)\r\nreturn error;\r\nerror = silead_ts_init(client);\r\nif (error)\r\nreturn error;\r\nerror = silead_ts_reset(client);\r\nif (error)\r\nreturn error;\r\nerror = silead_ts_load_fw(client);\r\nif (error)\r\nreturn error;\r\nerror = silead_ts_startup(client);\r\nif (error)\r\nreturn error;\r\nstatus = silead_ts_get_status(client);\r\nif (status != SILEAD_STATUS_OK) {\r\ndev_err(&client->dev,\r\n"Initialization error, status: 0x%X\n", status);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t silead_ts_threaded_irq_handler(int irq, void *id)\r\n{\r\nstruct silead_ts_data *data = id;\r\nstruct i2c_client *client = data->client;\r\nsilead_ts_read_data(client);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void silead_ts_read_props(struct i2c_client *client)\r\n{\r\nstruct silead_ts_data *data = i2c_get_clientdata(client);\r\nstruct device *dev = &client->dev;\r\nconst char *str;\r\nint error;\r\nerror = device_property_read_u32(dev, "silead,max-fingers",\r\n&data->max_fingers);\r\nif (error) {\r\ndev_dbg(dev, "Max fingers read error %d\n", error);\r\ndata->max_fingers = 5;\r\n}\r\nerror = device_property_read_string(dev, "firmware-name", &str);\r\nif (!error)\r\nsnprintf(data->fw_name, sizeof(data->fw_name),\r\n"silead/%s", str);\r\nelse\r\ndev_dbg(dev, "Firmware file name read error. Using default.");\r\n}\r\nstatic int silead_ts_set_default_fw_name(struct silead_ts_data *data,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct acpi_device_id *acpi_id;\r\nstruct device *dev = &data->client->dev;\r\nint i;\r\nif (ACPI_HANDLE(dev)) {\r\nacpi_id = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!acpi_id)\r\nreturn -ENODEV;\r\nsnprintf(data->fw_name, sizeof(data->fw_name),\r\n"silead/%s.fw", acpi_id->id);\r\nfor (i = 0; i < strlen(data->fw_name); i++)\r\ndata->fw_name[i] = tolower(data->fw_name[i]);\r\n} else {\r\nsnprintf(data->fw_name, sizeof(data->fw_name),\r\n"silead/%s.fw", id->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int silead_ts_set_default_fw_name(struct silead_ts_data *data,\r\nconst struct i2c_device_id *id)\r\n{\r\nsnprintf(data->fw_name, sizeof(data->fw_name),\r\n"silead/%s.fw", id->name);\r\nreturn 0;\r\n}\r\nstatic int silead_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct silead_ts_data *data;\r\nstruct device *dev = &client->dev;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_I2C |\r\nI2C_FUNC_SMBUS_READ_I2C_BLOCK |\r\nI2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) {\r\ndev_err(dev, "I2C functionality check failed\n");\r\nreturn -ENXIO;\r\n}\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\nerror = silead_ts_set_default_fw_name(data, id);\r\nif (error)\r\nreturn error;\r\nsilead_ts_read_props(client);\r\nif (client->irq <= 0)\r\nreturn -ENODEV;\r\ndata->gpio_power = devm_gpiod_get_optional(dev, "power", GPIOD_OUT_LOW);\r\nif (IS_ERR(data->gpio_power)) {\r\nif (PTR_ERR(data->gpio_power) != -EPROBE_DEFER)\r\ndev_err(dev, "Shutdown GPIO request failed\n");\r\nreturn PTR_ERR(data->gpio_power);\r\n}\r\nerror = silead_ts_setup(client);\r\nif (error)\r\nreturn error;\r\nerror = silead_ts_request_input_dev(data);\r\nif (error)\r\nreturn error;\r\nerror = devm_request_threaded_irq(dev, client->irq,\r\nNULL, silead_ts_threaded_irq_handler,\r\nIRQF_ONESHOT, client->name, data);\r\nif (error) {\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev, "IRQ request failed %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused silead_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nsilead_ts_set_power(client, SILEAD_POWER_OFF);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused silead_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint error, status;\r\nsilead_ts_set_power(client, SILEAD_POWER_ON);\r\nerror = silead_ts_reset(client);\r\nif (error)\r\nreturn error;\r\nerror = silead_ts_startup(client);\r\nif (error)\r\nreturn error;\r\nstatus = silead_ts_get_status(client);\r\nif (status != SILEAD_STATUS_OK) {\r\ndev_err(dev, "Resume error, status: 0x%02x\n", status);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}
