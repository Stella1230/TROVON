static void\r\nvc4_overflow_mem_work(struct work_struct *work)\r\n{\r\nstruct vc4_dev *vc4 =\r\ncontainer_of(work, struct vc4_dev, overflow_mem_work);\r\nstruct drm_device *dev = vc4->dev;\r\nstruct vc4_bo *bo;\r\nbo = vc4_bo_create(dev, 256 * 1024, true);\r\nif (IS_ERR(bo)) {\r\nDRM_ERROR("Couldn't allocate binner overflow mem\n");\r\nreturn;\r\n}\r\nif (vc4->overflow_mem) {\r\nstruct vc4_exec_info *current_exec;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&vc4->job_lock, irqflags);\r\ncurrent_exec = vc4_first_bin_job(vc4);\r\nif (!current_exec)\r\ncurrent_exec = vc4_last_render_job(vc4);\r\nif (current_exec) {\r\nvc4->overflow_mem->seqno = current_exec->seqno;\r\nlist_add_tail(&vc4->overflow_mem->unref_head,\r\n&current_exec->unref_list);\r\nvc4->overflow_mem = NULL;\r\n}\r\nspin_unlock_irqrestore(&vc4->job_lock, irqflags);\r\n}\r\nif (vc4->overflow_mem)\r\ndrm_gem_object_unreference_unlocked(&vc4->overflow_mem->base.base);\r\nvc4->overflow_mem = bo;\r\nV3D_WRITE(V3D_BPOA, bo->base.paddr);\r\nV3D_WRITE(V3D_BPOS, bo->base.base.size);\r\nV3D_WRITE(V3D_INTCTL, V3D_INT_OUTOMEM);\r\nV3D_WRITE(V3D_INTENA, V3D_INT_OUTOMEM);\r\n}\r\nstatic void\r\nvc4_irq_finish_bin_job(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nstruct vc4_exec_info *exec = vc4_first_bin_job(vc4);\r\nif (!exec)\r\nreturn;\r\nvc4_move_job_to_render(dev, exec);\r\nvc4_submit_next_bin_job(dev);\r\n}\r\nstatic void\r\nvc4_cancel_bin_job(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nstruct vc4_exec_info *exec = vc4_first_bin_job(vc4);\r\nif (!exec)\r\nreturn;\r\nlist_move_tail(&exec->head, &vc4->bin_job_list);\r\nvc4_submit_next_bin_job(dev);\r\n}\r\nstatic void\r\nvc4_irq_finish_render_job(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nstruct vc4_exec_info *exec = vc4_first_render_job(vc4);\r\nif (!exec)\r\nreturn;\r\nvc4->finished_seqno++;\r\nlist_move_tail(&exec->head, &vc4->job_done_list);\r\nvc4_submit_next_render_job(dev);\r\nwake_up_all(&vc4->job_wait_queue);\r\nschedule_work(&vc4->job_done_work);\r\n}\r\nirqreturn_t\r\nvc4_irq(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = arg;\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nuint32_t intctl;\r\nirqreturn_t status = IRQ_NONE;\r\nbarrier();\r\nintctl = V3D_READ(V3D_INTCTL);\r\nV3D_WRITE(V3D_INTCTL, intctl);\r\nif (intctl & V3D_INT_OUTOMEM) {\r\nV3D_WRITE(V3D_INTDIS, V3D_INT_OUTOMEM);\r\nschedule_work(&vc4->overflow_mem_work);\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (intctl & V3D_INT_FLDONE) {\r\nspin_lock(&vc4->job_lock);\r\nvc4_irq_finish_bin_job(dev);\r\nspin_unlock(&vc4->job_lock);\r\nstatus = IRQ_HANDLED;\r\n}\r\nif (intctl & V3D_INT_FRDONE) {\r\nspin_lock(&vc4->job_lock);\r\nvc4_irq_finish_render_job(dev);\r\nspin_unlock(&vc4->job_lock);\r\nstatus = IRQ_HANDLED;\r\n}\r\nreturn status;\r\n}\r\nvoid\r\nvc4_irq_preinstall(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\ninit_waitqueue_head(&vc4->job_wait_queue);\r\nINIT_WORK(&vc4->overflow_mem_work, vc4_overflow_mem_work);\r\nV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\r\n}\r\nint\r\nvc4_irq_postinstall(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nV3D_WRITE(V3D_INTENA, V3D_DRIVER_IRQS);\r\nreturn 0;\r\n}\r\nvoid\r\nvc4_irq_uninstall(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nV3D_WRITE(V3D_INTDIS, V3D_DRIVER_IRQS);\r\nV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\r\ncancel_work_sync(&vc4->overflow_mem_work);\r\n}\r\nvoid vc4_irq_reset(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nunsigned long irqflags;\r\nV3D_WRITE(V3D_INTCTL, V3D_DRIVER_IRQS);\r\nV3D_WRITE(V3D_INTENA, V3D_DRIVER_IRQS);\r\nspin_lock_irqsave(&vc4->job_lock, irqflags);\r\nvc4_cancel_bin_job(dev);\r\nvc4_irq_finish_render_job(dev);\r\nspin_unlock_irqrestore(&vc4->job_lock, irqflags);\r\n}
