static inline int eeti_ts_irq_active(struct eeti_ts_priv *priv)\r\n{\r\nreturn gpio_get_value(priv->irq_gpio) == priv->irq_active_high;\r\n}\r\nstatic void eeti_ts_read(struct work_struct *work)\r\n{\r\nchar buf[6];\r\nunsigned int x, y, res, pressed, to = 100;\r\nstruct eeti_ts_priv *priv =\r\ncontainer_of(work, struct eeti_ts_priv, work);\r\nmutex_lock(&priv->mutex);\r\nwhile (eeti_ts_irq_active(priv) && --to)\r\ni2c_master_recv(priv->client, buf, sizeof(buf));\r\nif (!to) {\r\ndev_err(&priv->client->dev,\r\n"unable to clear IRQ - line stuck?\n");\r\ngoto out;\r\n}\r\nif (!(buf[0] & 0x80))\r\ngoto out;\r\npressed = buf[0] & REPORT_BIT_PRESSED;\r\nres = REPORT_RES_BITS(buf[0] & (REPORT_BIT_AD0 | REPORT_BIT_AD1));\r\nx = buf[2] | (buf[1] << 8);\r\ny = buf[4] | (buf[3] << 8);\r\nx >>= res - EETI_TS_BITDEPTH;\r\ny >>= res - EETI_TS_BITDEPTH;\r\nif (flip_x)\r\nx = EETI_MAXVAL - x;\r\nif (flip_y)\r\ny = EETI_MAXVAL - y;\r\nif (buf[0] & REPORT_BIT_HAS_PRESSURE)\r\ninput_report_abs(priv->input, ABS_PRESSURE, buf[5]);\r\ninput_report_abs(priv->input, ABS_X, x);\r\ninput_report_abs(priv->input, ABS_Y, y);\r\ninput_report_key(priv->input, BTN_TOUCH, !!pressed);\r\ninput_sync(priv->input);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic irqreturn_t eeti_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct eeti_ts_priv *priv = dev_id;\r\nschedule_work(&priv->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void eeti_ts_start(struct eeti_ts_priv *priv)\r\n{\r\nenable_irq(priv->irq);\r\neeti_ts_read(&priv->work);\r\n}\r\nstatic void eeti_ts_stop(struct eeti_ts_priv *priv)\r\n{\r\ndisable_irq(priv->irq);\r\ncancel_work_sync(&priv->work);\r\n}\r\nstatic int eeti_ts_open(struct input_dev *dev)\r\n{\r\nstruct eeti_ts_priv *priv = input_get_drvdata(dev);\r\neeti_ts_start(priv);\r\nreturn 0;\r\n}\r\nstatic void eeti_ts_close(struct input_dev *dev)\r\n{\r\nstruct eeti_ts_priv *priv = input_get_drvdata(dev);\r\neeti_ts_stop(priv);\r\n}\r\nstatic int eeti_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *idp)\r\n{\r\nstruct eeti_ts_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct eeti_ts_priv *priv;\r\nstruct input_dev *input;\r\nunsigned int irq_flags;\r\nint err = -ENOMEM;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&client->dev, "failed to allocate driver data\n");\r\ngoto err0;\r\n}\r\nmutex_init(&priv->mutex);\r\ninput = input_allocate_device();\r\nif (!input) {\r\ndev_err(&client->dev, "Failed to allocate input device.\n");\r\ngoto err1;\r\n}\r\ninput->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input, ABS_X, 0, EETI_MAXVAL, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, EETI_MAXVAL, 0, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, 0xff, 0, 0);\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = &client->dev;\r\ninput->open = eeti_ts_open;\r\ninput->close = eeti_ts_close;\r\npriv->client = client;\r\npriv->input = input;\r\npriv->irq_gpio = pdata->irq_gpio;\r\npriv->irq = gpio_to_irq(pdata->irq_gpio);\r\nerr = gpio_request_one(pdata->irq_gpio, GPIOF_IN, client->name);\r\nif (err < 0)\r\ngoto err1;\r\npriv->irq_active_high = pdata->irq_active_high;\r\nirq_flags = priv->irq_active_high ?\r\nIRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;\r\nINIT_WORK(&priv->work, eeti_ts_read);\r\ni2c_set_clientdata(client, priv);\r\ninput_set_drvdata(input, priv);\r\nerr = input_register_device(input);\r\nif (err)\r\ngoto err2;\r\nerr = request_irq(priv->irq, eeti_ts_isr, irq_flags,\r\nclient->name, priv);\r\nif (err) {\r\ndev_err(&client->dev, "Unable to request touchscreen IRQ.\n");\r\ngoto err3;\r\n}\r\neeti_ts_stop(priv);\r\ndevice_init_wakeup(&client->dev, 0);\r\nreturn 0;\r\nerr3:\r\ninput_unregister_device(input);\r\ninput = NULL;\r\nerr2:\r\ngpio_free(pdata->irq_gpio);\r\nerr1:\r\ninput_free_device(input);\r\nkfree(priv);\r\nerr0:\r\nreturn err;\r\n}\r\nstatic int eeti_ts_remove(struct i2c_client *client)\r\n{\r\nstruct eeti_ts_priv *priv = i2c_get_clientdata(client);\r\nfree_irq(priv->irq, priv);\r\nenable_irq(priv->irq);\r\ninput_unregister_device(priv->input);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused eeti_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct eeti_ts_priv *priv = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = priv->input;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\neeti_ts_stop(priv);\r\nmutex_unlock(&input_dev->mutex);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(priv->irq);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused eeti_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct eeti_ts_priv *priv = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = priv->input;\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(priv->irq);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\neeti_ts_start(priv);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}
