static struct rockchip_clk_provider *__init rk3188_common_clk_init(struct device_node *np)\r\n{\r\nstruct rockchip_clk_provider *ctx;\r\nvoid __iomem *reg_base;\r\nreg_base = of_iomap(np, 0);\r\nif (!reg_base) {\r\npr_err("%s: could not map cru region\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);\r\nif (IS_ERR(ctx)) {\r\npr_err("%s: rockchip clk init failed\n", __func__);\r\niounmap(reg_base);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nrockchip_clk_register_branches(ctx, common_clk_branches,\r\nARRAY_SIZE(common_clk_branches));\r\nrockchip_register_softrst(np, 9, reg_base + RK2928_SOFTRST_CON(0),\r\nROCKCHIP_SOFTRST_HIWORD_MASK);\r\nrockchip_register_restart_notifier(ctx, RK2928_GLB_SRST_FST, NULL);\r\nreturn ctx;\r\n}\r\nstatic void __init rk3066a_clk_init(struct device_node *np)\r\n{\r\nstruct rockchip_clk_provider *ctx;\r\nctx = rk3188_common_clk_init(np);\r\nif (IS_ERR(ctx))\r\nreturn;\r\nrockchip_clk_register_plls(ctx, rk3066_pll_clks,\r\nARRAY_SIZE(rk3066_pll_clks),\r\nRK3066_GRF_SOC_STATUS);\r\nrockchip_clk_register_branches(ctx, rk3066a_clk_branches,\r\nARRAY_SIZE(rk3066a_clk_branches));\r\nrockchip_clk_register_armclk(ctx, ARMCLK, "armclk",\r\nmux_armclk_p, ARRAY_SIZE(mux_armclk_p),\r\n&rk3066_cpuclk_data, rk3066_cpuclk_rates,\r\nARRAY_SIZE(rk3066_cpuclk_rates));\r\nrockchip_clk_protect_critical(rk3188_critical_clocks,\r\nARRAY_SIZE(rk3188_critical_clocks));\r\nrockchip_clk_of_add_provider(np, ctx);\r\n}\r\nstatic void __init rk3188a_clk_init(struct device_node *np)\r\n{\r\nstruct rockchip_clk_provider *ctx;\r\nstruct clk *clk1, *clk2;\r\nunsigned long rate;\r\nint ret;\r\nctx = rk3188_common_clk_init(np);\r\nif (IS_ERR(ctx))\r\nreturn;\r\nrockchip_clk_register_plls(ctx, rk3188_pll_clks,\r\nARRAY_SIZE(rk3188_pll_clks),\r\nRK3188_GRF_SOC_STATUS);\r\nrockchip_clk_register_branches(ctx, rk3188_clk_branches,\r\nARRAY_SIZE(rk3188_clk_branches));\r\nrockchip_clk_register_armclk(ctx, ARMCLK, "armclk",\r\nmux_armclk_p, ARRAY_SIZE(mux_armclk_p),\r\n&rk3188_cpuclk_data, rk3188_cpuclk_rates,\r\nARRAY_SIZE(rk3188_cpuclk_rates));\r\nclk1 = __clk_lookup("aclk_cpu_pre");\r\nclk2 = __clk_lookup("gpll");\r\nif (clk1 && clk2) {\r\nrate = clk_get_rate(clk1);\r\nret = clk_set_parent(clk1, clk2);\r\nif (ret < 0)\r\npr_warn("%s: could not reparent aclk_cpu_pre to gpll\n",\r\n__func__);\r\nclk_set_rate(clk1, rate);\r\n} else {\r\npr_warn("%s: missing clocks to reparent aclk_cpu_pre to gpll\n",\r\n__func__);\r\n}\r\nrockchip_clk_protect_critical(rk3188_critical_clocks,\r\nARRAY_SIZE(rk3188_critical_clocks));\r\nrockchip_clk_of_add_provider(np, ctx);\r\n}\r\nstatic void __init rk3188_clk_init(struct device_node *np)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rk3188_pll_clks); i++) {\r\nstruct rockchip_pll_clock *pll = &rk3188_pll_clks[i];\r\nstruct rockchip_pll_rate_table *rate;\r\nif (!pll->rate_table)\r\ncontinue;\r\nrate = pll->rate_table;\r\nwhile (rate->rate > 0) {\r\nrate->nb = 1;\r\nrate++;\r\n}\r\n}\r\nrk3188a_clk_init(np);\r\n}
