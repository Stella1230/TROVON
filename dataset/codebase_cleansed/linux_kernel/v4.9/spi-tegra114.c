static inline u32 tegra_spi_readl(struct tegra_spi_data *tspi,\r\nunsigned long reg)\r\n{\r\nreturn readl(tspi->base + reg);\r\n}\r\nstatic inline void tegra_spi_writel(struct tegra_spi_data *tspi,\r\nu32 val, unsigned long reg)\r\n{\r\nwritel(val, tspi->base + reg);\r\nif (reg != SPI_TX_FIFO)\r\nreadl(tspi->base + SPI_COMMAND1);\r\n}\r\nstatic void tegra_spi_clear_status(struct tegra_spi_data *tspi)\r\n{\r\nu32 val;\r\nval = tegra_spi_readl(tspi, SPI_TRANS_STATUS);\r\ntegra_spi_writel(tspi, val, SPI_TRANS_STATUS);\r\nval = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\r\nif (val & SPI_ERR)\r\ntegra_spi_writel(tspi, SPI_ERR | SPI_FIFO_ERROR,\r\nSPI_FIFO_STATUS);\r\n}\r\nstatic unsigned tegra_spi_calculate_curr_xfer_param(\r\nstruct spi_device *spi, struct tegra_spi_data *tspi,\r\nstruct spi_transfer *t)\r\n{\r\nunsigned remain_len = t->len - tspi->cur_pos;\r\nunsigned max_word;\r\nunsigned bits_per_word = t->bits_per_word;\r\nunsigned max_len;\r\nunsigned total_fifo_words;\r\ntspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);\r\nif (bits_per_word == 8 || bits_per_word == 16) {\r\ntspi->is_packed = 1;\r\ntspi->words_per_32bit = 32/bits_per_word;\r\n} else {\r\ntspi->is_packed = 0;\r\ntspi->words_per_32bit = 1;\r\n}\r\nif (tspi->is_packed) {\r\nmax_len = min(remain_len, tspi->max_buf_size);\r\ntspi->curr_dma_words = max_len/tspi->bytes_per_word;\r\ntotal_fifo_words = (max_len + 3) / 4;\r\n} else {\r\nmax_word = (remain_len - 1) / tspi->bytes_per_word + 1;\r\nmax_word = min(max_word, tspi->max_buf_size/4);\r\ntspi->curr_dma_words = max_word;\r\ntotal_fifo_words = max_word;\r\n}\r\nreturn total_fifo_words;\r\n}\r\nstatic unsigned tegra_spi_fill_tx_fifo_from_client_txbuf(\r\nstruct tegra_spi_data *tspi, struct spi_transfer *t)\r\n{\r\nunsigned nbytes;\r\nunsigned tx_empty_count;\r\nu32 fifo_status;\r\nunsigned max_n_32bit;\r\nunsigned i, count;\r\nunsigned int written_words;\r\nunsigned fifo_words_left;\r\nu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;\r\nfifo_status = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\r\ntx_empty_count = SPI_TX_FIFO_EMPTY_COUNT(fifo_status);\r\nif (tspi->is_packed) {\r\nfifo_words_left = tx_empty_count * tspi->words_per_32bit;\r\nwritten_words = min(fifo_words_left, tspi->curr_dma_words);\r\nnbytes = written_words * tspi->bytes_per_word;\r\nmax_n_32bit = DIV_ROUND_UP(nbytes, 4);\r\nfor (count = 0; count < max_n_32bit; count++) {\r\nu32 x = 0;\r\nfor (i = 0; (i < 4) && nbytes; i++, nbytes--)\r\nx |= (u32)(*tx_buf++) << (i * 8);\r\ntegra_spi_writel(tspi, x, SPI_TX_FIFO);\r\n}\r\n} else {\r\nmax_n_32bit = min(tspi->curr_dma_words, tx_empty_count);\r\nwritten_words = max_n_32bit;\r\nnbytes = written_words * tspi->bytes_per_word;\r\nfor (count = 0; count < max_n_32bit; count++) {\r\nu32 x = 0;\r\nfor (i = 0; nbytes && (i < tspi->bytes_per_word);\r\ni++, nbytes--)\r\nx |= (u32)(*tx_buf++) << (i * 8);\r\ntegra_spi_writel(tspi, x, SPI_TX_FIFO);\r\n}\r\n}\r\ntspi->cur_tx_pos += written_words * tspi->bytes_per_word;\r\nreturn written_words;\r\n}\r\nstatic unsigned int tegra_spi_read_rx_fifo_to_client_rxbuf(\r\nstruct tegra_spi_data *tspi, struct spi_transfer *t)\r\n{\r\nunsigned rx_full_count;\r\nu32 fifo_status;\r\nunsigned i, count;\r\nunsigned int read_words = 0;\r\nunsigned len;\r\nu8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;\r\nfifo_status = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\r\nrx_full_count = SPI_RX_FIFO_FULL_COUNT(fifo_status);\r\nif (tspi->is_packed) {\r\nlen = tspi->curr_dma_words * tspi->bytes_per_word;\r\nfor (count = 0; count < rx_full_count; count++) {\r\nu32 x = tegra_spi_readl(tspi, SPI_RX_FIFO);\r\nfor (i = 0; len && (i < 4); i++, len--)\r\n*rx_buf++ = (x >> i*8) & 0xFF;\r\n}\r\ntspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\r\nread_words += tspi->curr_dma_words;\r\n} else {\r\nu32 rx_mask = ((u32)1 << t->bits_per_word) - 1;\r\nfor (count = 0; count < rx_full_count; count++) {\r\nu32 x = tegra_spi_readl(tspi, SPI_RX_FIFO) & rx_mask;\r\nfor (i = 0; (i < tspi->bytes_per_word); i++)\r\n*rx_buf++ = (x >> (i*8)) & 0xFF;\r\n}\r\ntspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;\r\nread_words += rx_full_count;\r\n}\r\nreturn read_words;\r\n}\r\nstatic void tegra_spi_copy_client_txbuf_to_spi_txbuf(\r\nstruct tegra_spi_data *tspi, struct spi_transfer *t)\r\n{\r\ndma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,\r\ntspi->dma_buf_size, DMA_TO_DEVICE);\r\nif (tspi->is_packed) {\r\nunsigned len = tspi->curr_dma_words * tspi->bytes_per_word;\r\nmemcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);\r\n} else {\r\nunsigned int i;\r\nunsigned int count;\r\nu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;\r\nunsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;\r\nfor (count = 0; count < tspi->curr_dma_words; count++) {\r\nu32 x = 0;\r\nfor (i = 0; consume && (i < tspi->bytes_per_word);\r\ni++, consume--)\r\nx |= (u32)(*tx_buf++) << (i * 8);\r\ntspi->tx_dma_buf[count] = x;\r\n}\r\n}\r\ntspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\r\ndma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,\r\ntspi->dma_buf_size, DMA_TO_DEVICE);\r\n}\r\nstatic void tegra_spi_copy_spi_rxbuf_to_client_rxbuf(\r\nstruct tegra_spi_data *tspi, struct spi_transfer *t)\r\n{\r\ndma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,\r\ntspi->dma_buf_size, DMA_FROM_DEVICE);\r\nif (tspi->is_packed) {\r\nunsigned len = tspi->curr_dma_words * tspi->bytes_per_word;\r\nmemcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);\r\n} else {\r\nunsigned int i;\r\nunsigned int count;\r\nunsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;\r\nu32 rx_mask = ((u32)1 << t->bits_per_word) - 1;\r\nfor (count = 0; count < tspi->curr_dma_words; count++) {\r\nu32 x = tspi->rx_dma_buf[count] & rx_mask;\r\nfor (i = 0; (i < tspi->bytes_per_word); i++)\r\n*rx_buf++ = (x >> (i*8)) & 0xFF;\r\n}\r\n}\r\ntspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\r\ndma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\r\ntspi->dma_buf_size, DMA_FROM_DEVICE);\r\n}\r\nstatic void tegra_spi_dma_complete(void *args)\r\n{\r\nstruct completion *dma_complete = args;\r\ncomplete(dma_complete);\r\n}\r\nstatic int tegra_spi_start_tx_dma(struct tegra_spi_data *tspi, int len)\r\n{\r\nreinit_completion(&tspi->tx_dma_complete);\r\ntspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,\r\ntspi->tx_dma_phys, len, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tspi->tx_dma_desc) {\r\ndev_err(tspi->dev, "Not able to get desc for Tx\n");\r\nreturn -EIO;\r\n}\r\ntspi->tx_dma_desc->callback = tegra_spi_dma_complete;\r\ntspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;\r\ndmaengine_submit(tspi->tx_dma_desc);\r\ndma_async_issue_pending(tspi->tx_dma_chan);\r\nreturn 0;\r\n}\r\nstatic int tegra_spi_start_rx_dma(struct tegra_spi_data *tspi, int len)\r\n{\r\nreinit_completion(&tspi->rx_dma_complete);\r\ntspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,\r\ntspi->rx_dma_phys, len, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tspi->rx_dma_desc) {\r\ndev_err(tspi->dev, "Not able to get desc for Rx\n");\r\nreturn -EIO;\r\n}\r\ntspi->rx_dma_desc->callback = tegra_spi_dma_complete;\r\ntspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;\r\ndmaengine_submit(tspi->rx_dma_desc);\r\ndma_async_issue_pending(tspi->rx_dma_chan);\r\nreturn 0;\r\n}\r\nstatic int tegra_spi_start_dma_based_transfer(\r\nstruct tegra_spi_data *tspi, struct spi_transfer *t)\r\n{\r\nu32 val;\r\nunsigned int len;\r\nint ret = 0;\r\nu32 status;\r\nstatus = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\r\nif ((status & SPI_FIFO_EMPTY) != SPI_FIFO_EMPTY) {\r\ndev_err(tspi->dev, "Rx/Tx fifo are not empty status 0x%08x\n",\r\n(unsigned)status);\r\nreturn -EIO;\r\n}\r\nval = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);\r\ntegra_spi_writel(tspi, val, SPI_DMA_BLK);\r\nif (tspi->is_packed)\r\nlen = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,\r\n4) * 4;\r\nelse\r\nlen = tspi->curr_dma_words * 4;\r\nif (len & 0xF)\r\nval |= SPI_TX_TRIG_1 | SPI_RX_TRIG_1;\r\nelse if (((len) >> 4) & 0x1)\r\nval |= SPI_TX_TRIG_4 | SPI_RX_TRIG_4;\r\nelse\r\nval |= SPI_TX_TRIG_8 | SPI_RX_TRIG_8;\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\nval |= SPI_IE_TX;\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\nval |= SPI_IE_RX;\r\ntegra_spi_writel(tspi, val, SPI_DMA_CTL);\r\ntspi->dma_control_reg = val;\r\nif (tspi->cur_direction & DATA_DIR_TX) {\r\ntegra_spi_copy_client_txbuf_to_spi_txbuf(tspi, t);\r\nret = tegra_spi_start_tx_dma(tspi, len);\r\nif (ret < 0) {\r\ndev_err(tspi->dev,\r\n"Starting tx dma failed, err %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (tspi->cur_direction & DATA_DIR_RX) {\r\ndma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\r\ntspi->dma_buf_size, DMA_FROM_DEVICE);\r\nret = tegra_spi_start_rx_dma(tspi, len);\r\nif (ret < 0) {\r\ndev_err(tspi->dev,\r\n"Starting rx dma failed, err %d\n", ret);\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ndmaengine_terminate_all(tspi->tx_dma_chan);\r\nreturn ret;\r\n}\r\n}\r\ntspi->is_curr_dma_xfer = true;\r\ntspi->dma_control_reg = val;\r\nval |= SPI_DMA_EN;\r\ntegra_spi_writel(tspi, val, SPI_DMA_CTL);\r\nreturn ret;\r\n}\r\nstatic int tegra_spi_start_cpu_based_transfer(\r\nstruct tegra_spi_data *tspi, struct spi_transfer *t)\r\n{\r\nu32 val;\r\nunsigned cur_words;\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ncur_words = tegra_spi_fill_tx_fifo_from_client_txbuf(tspi, t);\r\nelse\r\ncur_words = tspi->curr_dma_words;\r\nval = SPI_DMA_BLK_SET(cur_words - 1);\r\ntegra_spi_writel(tspi, val, SPI_DMA_BLK);\r\nval = 0;\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\nval |= SPI_IE_TX;\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\nval |= SPI_IE_RX;\r\ntegra_spi_writel(tspi, val, SPI_DMA_CTL);\r\ntspi->dma_control_reg = val;\r\ntspi->is_curr_dma_xfer = false;\r\nval |= SPI_DMA_EN;\r\ntegra_spi_writel(tspi, val, SPI_DMA_CTL);\r\nreturn 0;\r\n}\r\nstatic int tegra_spi_init_dma_param(struct tegra_spi_data *tspi,\r\nbool dma_to_memory)\r\n{\r\nstruct dma_chan *dma_chan;\r\nu32 *dma_buf;\r\ndma_addr_t dma_phys;\r\nint ret;\r\nstruct dma_slave_config dma_sconfig;\r\ndma_chan = dma_request_slave_channel_reason(tspi->dev,\r\ndma_to_memory ? "rx" : "tx");\r\nif (IS_ERR(dma_chan)) {\r\nret = PTR_ERR(dma_chan);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(tspi->dev,\r\n"Dma channel is not available: %d\n", ret);\r\nreturn ret;\r\n}\r\ndma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,\r\n&dma_phys, GFP_KERNEL);\r\nif (!dma_buf) {\r\ndev_err(tspi->dev, " Not able to allocate the dma buffer\n");\r\ndma_release_channel(dma_chan);\r\nreturn -ENOMEM;\r\n}\r\nif (dma_to_memory) {\r\ndma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;\r\ndma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndma_sconfig.src_maxburst = 0;\r\n} else {\r\ndma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;\r\ndma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndma_sconfig.dst_maxburst = 0;\r\n}\r\nret = dmaengine_slave_config(dma_chan, &dma_sconfig);\r\nif (ret)\r\ngoto scrub;\r\nif (dma_to_memory) {\r\ntspi->rx_dma_chan = dma_chan;\r\ntspi->rx_dma_buf = dma_buf;\r\ntspi->rx_dma_phys = dma_phys;\r\n} else {\r\ntspi->tx_dma_chan = dma_chan;\r\ntspi->tx_dma_buf = dma_buf;\r\ntspi->tx_dma_phys = dma_phys;\r\n}\r\nreturn 0;\r\nscrub:\r\ndma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);\r\ndma_release_channel(dma_chan);\r\nreturn ret;\r\n}\r\nstatic void tegra_spi_deinit_dma_param(struct tegra_spi_data *tspi,\r\nbool dma_to_memory)\r\n{\r\nu32 *dma_buf;\r\ndma_addr_t dma_phys;\r\nstruct dma_chan *dma_chan;\r\nif (dma_to_memory) {\r\ndma_buf = tspi->rx_dma_buf;\r\ndma_chan = tspi->rx_dma_chan;\r\ndma_phys = tspi->rx_dma_phys;\r\ntspi->rx_dma_chan = NULL;\r\ntspi->rx_dma_buf = NULL;\r\n} else {\r\ndma_buf = tspi->tx_dma_buf;\r\ndma_chan = tspi->tx_dma_chan;\r\ndma_phys = tspi->tx_dma_phys;\r\ntspi->tx_dma_buf = NULL;\r\ntspi->tx_dma_chan = NULL;\r\n}\r\nif (!dma_chan)\r\nreturn;\r\ndma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);\r\ndma_release_channel(dma_chan);\r\n}\r\nstatic u32 tegra_spi_setup_transfer_one(struct spi_device *spi,\r\nstruct spi_transfer *t, bool is_first_of_msg)\r\n{\r\nstruct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);\r\nu32 speed = t->speed_hz;\r\nu8 bits_per_word = t->bits_per_word;\r\nu32 command1;\r\nint req_mode;\r\nif (speed != tspi->cur_speed) {\r\nclk_set_rate(tspi->clk, speed);\r\ntspi->cur_speed = speed;\r\n}\r\ntspi->cur_spi = spi;\r\ntspi->cur_pos = 0;\r\ntspi->cur_rx_pos = 0;\r\ntspi->cur_tx_pos = 0;\r\ntspi->curr_xfer = t;\r\nif (is_first_of_msg) {\r\ntegra_spi_clear_status(tspi);\r\ncommand1 = tspi->def_command1_reg;\r\ncommand1 |= SPI_BIT_LENGTH(bits_per_word - 1);\r\ncommand1 &= ~SPI_CONTROL_MODE_MASK;\r\nreq_mode = spi->mode & 0x3;\r\nif (req_mode == SPI_MODE_0)\r\ncommand1 |= SPI_CONTROL_MODE_0;\r\nelse if (req_mode == SPI_MODE_1)\r\ncommand1 |= SPI_CONTROL_MODE_1;\r\nelse if (req_mode == SPI_MODE_2)\r\ncommand1 |= SPI_CONTROL_MODE_2;\r\nelse if (req_mode == SPI_MODE_3)\r\ncommand1 |= SPI_CONTROL_MODE_3;\r\nif (tspi->cs_control) {\r\nif (tspi->cs_control != spi)\r\ntegra_spi_writel(tspi, command1, SPI_COMMAND1);\r\ntspi->cs_control = NULL;\r\n} else\r\ntegra_spi_writel(tspi, command1, SPI_COMMAND1);\r\ncommand1 |= SPI_CS_SW_HW;\r\nif (spi->mode & SPI_CS_HIGH)\r\ncommand1 |= SPI_CS_SS_VAL;\r\nelse\r\ncommand1 &= ~SPI_CS_SS_VAL;\r\ntegra_spi_writel(tspi, 0, SPI_COMMAND2);\r\n} else {\r\ncommand1 = tspi->command1_reg;\r\ncommand1 &= ~SPI_BIT_LENGTH(~0);\r\ncommand1 |= SPI_BIT_LENGTH(bits_per_word - 1);\r\n}\r\nreturn command1;\r\n}\r\nstatic int tegra_spi_start_transfer_one(struct spi_device *spi,\r\nstruct spi_transfer *t, u32 command1)\r\n{\r\nstruct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);\r\nunsigned total_fifo_words;\r\nint ret;\r\ntotal_fifo_words = tegra_spi_calculate_curr_xfer_param(spi, tspi, t);\r\nif (tspi->is_packed)\r\ncommand1 |= SPI_PACKED;\r\ncommand1 &= ~(SPI_CS_SEL_MASK | SPI_TX_EN | SPI_RX_EN);\r\ntspi->cur_direction = 0;\r\nif (t->rx_buf) {\r\ncommand1 |= SPI_RX_EN;\r\ntspi->cur_direction |= DATA_DIR_RX;\r\n}\r\nif (t->tx_buf) {\r\ncommand1 |= SPI_TX_EN;\r\ntspi->cur_direction |= DATA_DIR_TX;\r\n}\r\ncommand1 |= SPI_CS_SEL(spi->chip_select);\r\ntegra_spi_writel(tspi, command1, SPI_COMMAND1);\r\ntspi->command1_reg = command1;\r\ndev_dbg(tspi->dev, "The def 0x%x and written 0x%x\n",\r\ntspi->def_command1_reg, (unsigned)command1);\r\nif (total_fifo_words > SPI_FIFO_DEPTH)\r\nret = tegra_spi_start_dma_based_transfer(tspi, t);\r\nelse\r\nret = tegra_spi_start_cpu_based_transfer(tspi, t);\r\nreturn ret;\r\n}\r\nstatic int tegra_spi_setup(struct spi_device *spi)\r\n{\r\nstruct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);\r\nu32 val;\r\nunsigned long flags;\r\nint ret;\r\ndev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",\r\nspi->bits_per_word,\r\nspi->mode & SPI_CPOL ? "" : "~",\r\nspi->mode & SPI_CPHA ? "" : "~",\r\nspi->max_speed_hz);\r\nret = pm_runtime_get_sync(tspi->dev);\r\nif (ret < 0) {\r\ndev_err(tspi->dev, "pm runtime failed, e = %d\n", ret);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nval = tspi->def_command1_reg;\r\nif (spi->mode & SPI_CS_HIGH)\r\nval &= ~SPI_CS_POL_INACTIVE(spi->chip_select);\r\nelse\r\nval |= SPI_CS_POL_INACTIVE(spi->chip_select);\r\ntspi->def_command1_reg = val;\r\ntegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\npm_runtime_put(tspi->dev);\r\nreturn 0;\r\n}\r\nstatic void tegra_spi_transfer_delay(int delay)\r\n{\r\nif (!delay)\r\nreturn;\r\nif (delay >= 1000)\r\nmdelay(delay / 1000);\r\nudelay(delay % 1000);\r\n}\r\nstatic int tegra_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nbool is_first_msg = true;\r\nstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\r\nstruct spi_transfer *xfer;\r\nstruct spi_device *spi = msg->spi;\r\nint ret;\r\nbool skip = false;\r\nmsg->status = 0;\r\nmsg->actual_length = 0;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nu32 cmd1;\r\nreinit_completion(&tspi->xfer_completion);\r\ncmd1 = tegra_spi_setup_transfer_one(spi, xfer, is_first_msg);\r\nif (!xfer->len) {\r\nret = 0;\r\nskip = true;\r\ngoto complete_xfer;\r\n}\r\nret = tegra_spi_start_transfer_one(spi, xfer, cmd1);\r\nif (ret < 0) {\r\ndev_err(tspi->dev,\r\n"spi can not start transfer, err %d\n", ret);\r\ngoto complete_xfer;\r\n}\r\nis_first_msg = false;\r\nret = wait_for_completion_timeout(&tspi->xfer_completion,\r\nSPI_DMA_TIMEOUT);\r\nif (WARN_ON(ret == 0)) {\r\ndev_err(tspi->dev,\r\n"spi trasfer timeout, err %d\n", ret);\r\nret = -EIO;\r\ngoto complete_xfer;\r\n}\r\nif (tspi->tx_status || tspi->rx_status) {\r\ndev_err(tspi->dev, "Error in Transfer\n");\r\nret = -EIO;\r\ngoto complete_xfer;\r\n}\r\nmsg->actual_length += xfer->len;\r\ncomplete_xfer:\r\nif (ret < 0 || skip) {\r\ntegra_spi_writel(tspi, tspi->def_command1_reg,\r\nSPI_COMMAND1);\r\ntegra_spi_transfer_delay(xfer->delay_usecs);\r\ngoto exit;\r\n} else if (list_is_last(&xfer->transfer_list,\r\n&msg->transfers)) {\r\nif (xfer->cs_change)\r\ntspi->cs_control = spi;\r\nelse {\r\ntegra_spi_writel(tspi, tspi->def_command1_reg,\r\nSPI_COMMAND1);\r\ntegra_spi_transfer_delay(xfer->delay_usecs);\r\n}\r\n} else if (xfer->cs_change) {\r\ntegra_spi_writel(tspi, tspi->def_command1_reg,\r\nSPI_COMMAND1);\r\ntegra_spi_transfer_delay(xfer->delay_usecs);\r\n}\r\n}\r\nret = 0;\r\nexit:\r\nmsg->status = ret;\r\nspi_finalize_current_message(master);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t handle_cpu_based_xfer(struct tegra_spi_data *tspi)\r\n{\r\nstruct spi_transfer *t = tspi->curr_xfer;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nif (tspi->tx_status || tspi->rx_status) {\r\ndev_err(tspi->dev, "CpuXfer ERROR bit set 0x%x\n",\r\ntspi->status_reg);\r\ndev_err(tspi->dev, "CpuXfer 0x%08x:0x%08x\n",\r\ntspi->command1_reg, tspi->dma_control_reg);\r\nreset_control_assert(tspi->rst);\r\nudelay(2);\r\nreset_control_deassert(tspi->rst);\r\ncomplete(&tspi->xfer_completion);\r\ngoto exit;\r\n}\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\ntegra_spi_read_rx_fifo_to_client_rxbuf(tspi, t);\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ntspi->cur_pos = tspi->cur_tx_pos;\r\nelse\r\ntspi->cur_pos = tspi->cur_rx_pos;\r\nif (tspi->cur_pos == t->len) {\r\ncomplete(&tspi->xfer_completion);\r\ngoto exit;\r\n}\r\ntegra_spi_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);\r\ntegra_spi_start_cpu_based_transfer(tspi, t);\r\nexit:\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t handle_dma_based_xfer(struct tegra_spi_data *tspi)\r\n{\r\nstruct spi_transfer *t = tspi->curr_xfer;\r\nlong wait_status;\r\nint err = 0;\r\nunsigned total_fifo_words;\r\nunsigned long flags;\r\nif (tspi->cur_direction & DATA_DIR_TX) {\r\nif (tspi->tx_status) {\r\ndmaengine_terminate_all(tspi->tx_dma_chan);\r\nerr += 1;\r\n} else {\r\nwait_status = wait_for_completion_interruptible_timeout(\r\n&tspi->tx_dma_complete, SPI_DMA_TIMEOUT);\r\nif (wait_status <= 0) {\r\ndmaengine_terminate_all(tspi->tx_dma_chan);\r\ndev_err(tspi->dev, "TxDma Xfer failed\n");\r\nerr += 1;\r\n}\r\n}\r\n}\r\nif (tspi->cur_direction & DATA_DIR_RX) {\r\nif (tspi->rx_status) {\r\ndmaengine_terminate_all(tspi->rx_dma_chan);\r\nerr += 2;\r\n} else {\r\nwait_status = wait_for_completion_interruptible_timeout(\r\n&tspi->rx_dma_complete, SPI_DMA_TIMEOUT);\r\nif (wait_status <= 0) {\r\ndmaengine_terminate_all(tspi->rx_dma_chan);\r\ndev_err(tspi->dev, "RxDma Xfer failed\n");\r\nerr += 2;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nif (err) {\r\ndev_err(tspi->dev, "DmaXfer: ERROR bit set 0x%x\n",\r\ntspi->status_reg);\r\ndev_err(tspi->dev, "DmaXfer 0x%08x:0x%08x\n",\r\ntspi->command1_reg, tspi->dma_control_reg);\r\nreset_control_assert(tspi->rst);\r\nudelay(2);\r\nreset_control_deassert(tspi->rst);\r\ncomplete(&tspi->xfer_completion);\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\ntegra_spi_copy_spi_rxbuf_to_client_rxbuf(tspi, t);\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ntspi->cur_pos = tspi->cur_tx_pos;\r\nelse\r\ntspi->cur_pos = tspi->cur_rx_pos;\r\nif (tspi->cur_pos == t->len) {\r\ncomplete(&tspi->xfer_completion);\r\ngoto exit;\r\n}\r\ntotal_fifo_words = tegra_spi_calculate_curr_xfer_param(tspi->cur_spi,\r\ntspi, t);\r\nif (total_fifo_words > SPI_FIFO_DEPTH)\r\nerr = tegra_spi_start_dma_based_transfer(tspi, t);\r\nelse\r\nerr = tegra_spi_start_cpu_based_transfer(tspi, t);\r\nexit:\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tegra_spi_isr_thread(int irq, void *context_data)\r\n{\r\nstruct tegra_spi_data *tspi = context_data;\r\nif (!tspi->is_curr_dma_xfer)\r\nreturn handle_cpu_based_xfer(tspi);\r\nreturn handle_dma_based_xfer(tspi);\r\n}\r\nstatic irqreturn_t tegra_spi_isr(int irq, void *context_data)\r\n{\r\nstruct tegra_spi_data *tspi = context_data;\r\ntspi->status_reg = tegra_spi_readl(tspi, SPI_FIFO_STATUS);\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ntspi->tx_status = tspi->status_reg &\r\n(SPI_TX_FIFO_UNF | SPI_TX_FIFO_OVF);\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\ntspi->rx_status = tspi->status_reg &\r\n(SPI_RX_FIFO_OVF | SPI_RX_FIFO_UNF);\r\ntegra_spi_clear_status(tspi);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int tegra_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct tegra_spi_data *tspi;\r\nstruct resource *r;\r\nint ret, spi_irq;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*tspi));\r\nif (!master) {\r\ndev_err(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\ntspi = spi_master_get_devdata(master);\r\nif (of_property_read_u32(pdev->dev.of_node, "spi-max-frequency",\r\n&master->max_speed_hz))\r\nmaster->max_speed_hz = 25000000;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->setup = tegra_spi_setup;\r\nmaster->transfer_one_message = tegra_spi_transfer_one_message;\r\nmaster->num_chipselect = MAX_CHIP_SELECT;\r\nmaster->auto_runtime_pm = true;\r\ntspi->master = master;\r\ntspi->dev = &pdev->dev;\r\nspin_lock_init(&tspi->lock);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntspi->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(tspi->base)) {\r\nret = PTR_ERR(tspi->base);\r\ngoto exit_free_master;\r\n}\r\ntspi->phys = r->start;\r\nspi_irq = platform_get_irq(pdev, 0);\r\ntspi->irq = spi_irq;\r\nret = request_threaded_irq(tspi->irq, tegra_spi_isr,\r\ntegra_spi_isr_thread, IRQF_ONESHOT,\r\ndev_name(&pdev->dev), tspi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",\r\ntspi->irq);\r\ngoto exit_free_master;\r\n}\r\ntspi->clk = devm_clk_get(&pdev->dev, "spi");\r\nif (IS_ERR(tspi->clk)) {\r\ndev_err(&pdev->dev, "can not get clock\n");\r\nret = PTR_ERR(tspi->clk);\r\ngoto exit_free_irq;\r\n}\r\ntspi->rst = devm_reset_control_get(&pdev->dev, "spi");\r\nif (IS_ERR(tspi->rst)) {\r\ndev_err(&pdev->dev, "can not get reset\n");\r\nret = PTR_ERR(tspi->rst);\r\ngoto exit_free_irq;\r\n}\r\ntspi->max_buf_size = SPI_FIFO_DEPTH << 2;\r\ntspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;\r\nret = tegra_spi_init_dma_param(tspi, true);\r\nif (ret < 0)\r\ngoto exit_free_irq;\r\nret = tegra_spi_init_dma_param(tspi, false);\r\nif (ret < 0)\r\ngoto exit_rx_dma_free;\r\ntspi->max_buf_size = tspi->dma_buf_size;\r\ninit_completion(&tspi->tx_dma_complete);\r\ninit_completion(&tspi->rx_dma_complete);\r\ninit_completion(&tspi->xfer_completion);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = tegra_spi_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto exit_pm_disable;\r\n}\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);\r\ngoto exit_pm_disable;\r\n}\r\ntspi->def_command1_reg = SPI_M_S;\r\ntegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);\r\npm_runtime_put(&pdev->dev);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can not register to master err %d\n", ret);\r\ngoto exit_pm_disable;\r\n}\r\nreturn ret;\r\nexit_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra_spi_runtime_suspend(&pdev->dev);\r\ntegra_spi_deinit_dma_param(tspi, false);\r\nexit_rx_dma_free:\r\ntegra_spi_deinit_dma_param(tspi, true);\r\nexit_free_irq:\r\nfree_irq(spi_irq, tspi);\r\nexit_free_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int tegra_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\r\nfree_irq(tspi->irq, tspi);\r\nif (tspi->tx_dma_chan)\r\ntegra_spi_deinit_dma_param(tspi, false);\r\nif (tspi->rx_dma_chan)\r\ntegra_spi_deinit_dma_param(tspi, true);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra_spi_runtime_suspend(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int tegra_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nreturn spi_master_suspend(master);\r\n}\r\nstatic int tegra_spi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\r\nint ret;\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "pm runtime failed, e = %d\n", ret);\r\nreturn ret;\r\n}\r\ntegra_spi_writel(tspi, tspi->command1_reg, SPI_COMMAND1);\r\npm_runtime_put(dev);\r\nreturn spi_master_resume(master);\r\n}\r\nstatic int tegra_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\r\ntegra_spi_readl(tspi, SPI_COMMAND1);\r\nclk_disable_unprepare(tspi->clk);\r\nreturn 0;\r\n}\r\nstatic int tegra_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_spi_data *tspi = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(tspi->clk);\r\nif (ret < 0) {\r\ndev_err(tspi->dev, "clk_prepare failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
