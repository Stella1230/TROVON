static void hanwang_parse_packet(struct hanwang *hanwang)\r\n{\r\nunsigned char *data = hanwang->data;\r\nstruct input_dev *input_dev = hanwang->dev;\r\nstruct usb_device *dev = hanwang->usbdev;\r\nenum hanwang_tablet_type type = hanwang->features->type;\r\nint i;\r\nu16 p;\r\nif (type == HANWANG_ART_MASTER_II) {\r\nhanwang->current_tool = BTN_TOOL_PEN;\r\nhanwang->current_id = STYLUS_DEVICE_ID;\r\n}\r\nswitch (data[0]) {\r\ncase 0x02:\r\nswitch (data[1]) {\r\ncase 0x80:\r\nif (type != HANWANG_ART_MASTER_II) {\r\nhanwang->current_id = 0;\r\ninput_report_key(input_dev,\r\nhanwang->current_tool, 0);\r\n}\r\nbreak;\r\ncase 0x00:\r\nif (type == HANWANG_ART_MASTER_II) {\r\nhanwang->current_id = 0;\r\ninput_report_key(input_dev,\r\nhanwang->current_tool, 0);\r\n}\r\nbreak;\r\ncase 0xc2:\r\nswitch (data[3] & 0xf0) {\r\ncase 0x20:\r\ncase 0x30:\r\nhanwang->current_id = STYLUS_DEVICE_ID;\r\nhanwang->current_tool = BTN_TOOL_PEN;\r\ninput_report_key(input_dev, BTN_TOOL_PEN, 1);\r\nbreak;\r\ncase 0xa0:\r\ncase 0xb0:\r\nhanwang->current_id = ERASER_DEVICE_ID;\r\nhanwang->current_tool = BTN_TOOL_RUBBER;\r\ninput_report_key(input_dev, BTN_TOOL_RUBBER, 1);\r\nbreak;\r\ndefault:\r\nhanwang->current_id = 0;\r\ndev_dbg(&dev->dev,\r\n"unknown tablet tool %02x\n", data[0]);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nswitch (type) {\r\ncase HANWANG_ART_MASTER_III:\r\np = (data[6] << 3) |\r\n((data[7] & 0xc0) >> 5) |\r\n(data[1] & 0x01);\r\nbreak;\r\ncase HANWANG_ART_MASTER_HD:\r\ncase HANWANG_ART_MASTER_II:\r\np = (data[7] >> 6) | (data[6] << 2);\r\nbreak;\r\ndefault:\r\np = 0;\r\nbreak;\r\n}\r\ninput_report_abs(input_dev, ABS_X,\r\nbe16_to_cpup((__be16 *)&data[2]));\r\ninput_report_abs(input_dev, ABS_Y,\r\nbe16_to_cpup((__be16 *)&data[4]));\r\ninput_report_abs(input_dev, ABS_PRESSURE, p);\r\ninput_report_abs(input_dev, ABS_TILT_X, data[7] & 0x3f);\r\ninput_report_abs(input_dev, ABS_TILT_Y, data[8] & 0x7f);\r\ninput_report_key(input_dev, BTN_STYLUS, data[1] & 0x02);\r\nif (type != HANWANG_ART_MASTER_II)\r\ninput_report_key(input_dev, BTN_STYLUS2,\r\ndata[1] & 0x04);\r\nelse\r\ninput_report_key(input_dev, BTN_TOOL_PEN, 1);\r\nbreak;\r\n}\r\ninput_report_abs(input_dev, ABS_MISC, hanwang->current_id);\r\ninput_event(input_dev, EV_MSC, MSC_SERIAL,\r\nhanwang->features->pid);\r\nbreak;\r\ncase 0x0c:\r\nhanwang->current_id = PAD_DEVICE_ID;\r\nswitch (type) {\r\ncase HANWANG_ART_MASTER_III:\r\ninput_report_key(input_dev, BTN_TOOL_FINGER,\r\ndata[1] || data[2] || data[3]);\r\ninput_report_abs(input_dev, ABS_WHEEL, data[1]);\r\ninput_report_key(input_dev, BTN_0, data[2]);\r\nfor (i = 0; i < 8; i++)\r\ninput_report_key(input_dev,\r\nBTN_1 + i, data[3] & (1 << i));\r\nbreak;\r\ncase HANWANG_ART_MASTER_HD:\r\ninput_report_key(input_dev, BTN_TOOL_FINGER, data[1] ||\r\ndata[2] || data[3] || data[4] ||\r\ndata[5] || data[6]);\r\ninput_report_abs(input_dev, ABS_RX,\r\n((data[1] & 0x1f) << 8) | data[2]);\r\ninput_report_abs(input_dev, ABS_RY,\r\n((data[3] & 0x1f) << 8) | data[4]);\r\ninput_report_key(input_dev, BTN_0, data[5] & 0x01);\r\nfor (i = 0; i < 4; i++) {\r\ninput_report_key(input_dev,\r\nBTN_1 + i, data[5] & (1 << i));\r\ninput_report_key(input_dev,\r\nBTN_5 + i, data[6] & (1 << i));\r\n}\r\nbreak;\r\ncase HANWANG_ART_MASTER_II:\r\ndev_dbg(&dev->dev, "error packet %02x\n", data[0]);\r\nreturn;\r\n}\r\ninput_report_abs(input_dev, ABS_MISC, hanwang->current_id);\r\ninput_event(input_dev, EV_MSC, MSC_SERIAL, 0xffffffff);\r\nbreak;\r\ndefault:\r\ndev_dbg(&dev->dev, "error packet %02x\n", data[0]);\r\nbreak;\r\n}\r\ninput_sync(input_dev);\r\n}\r\nstatic void hanwang_irq(struct urb *urb)\r\n{\r\nstruct hanwang *hanwang = urb->context;\r\nstruct usb_device *dev = hanwang->usbdev;\r\nint retval;\r\nswitch (urb->status) {\r\ncase 0:\r\n;\r\nhanwang_parse_packet(hanwang);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_err(&dev->dev, "%s - urb shutting down with status: %d",\r\n__func__, urb->status);\r\nreturn;\r\ndefault:\r\ndev_err(&dev->dev, "%s - nonzero urb status received: %d",\r\n__func__, urb->status);\r\nbreak;\r\n}\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&dev->dev, "%s - usb_submit_urb failed with result %d",\r\n__func__, retval);\r\n}\r\nstatic int hanwang_open(struct input_dev *dev)\r\n{\r\nstruct hanwang *hanwang = input_get_drvdata(dev);\r\nhanwang->irq->dev = hanwang->usbdev;\r\nif (usb_submit_urb(hanwang->irq, GFP_KERNEL))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void hanwang_close(struct input_dev *dev)\r\n{\r\nstruct hanwang *hanwang = input_get_drvdata(dev);\r\nusb_kill_urb(hanwang->irq);\r\n}\r\nstatic bool get_features(struct usb_device *dev, struct hanwang *hanwang)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(features_array); i++) {\r\nif (le16_to_cpu(dev->descriptor.idProduct) ==\r\nfeatures_array[i].pid) {\r\nhanwang->features = &features_array[i];\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int hanwang_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct hanwang *hanwang;\r\nstruct input_dev *input_dev;\r\nint error;\r\nint i;\r\nhanwang = kzalloc(sizeof(struct hanwang), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!hanwang || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nif (!get_features(dev, hanwang)) {\r\nerror = -ENXIO;\r\ngoto fail1;\r\n}\r\nhanwang->data = usb_alloc_coherent(dev, hanwang->features->pkg_len,\r\nGFP_KERNEL, &hanwang->data_dma);\r\nif (!hanwang->data) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nhanwang->irq = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!hanwang->irq) {\r\nerror = -ENOMEM;\r\ngoto fail2;\r\n}\r\nhanwang->usbdev = dev;\r\nhanwang->dev = input_dev;\r\nusb_make_path(dev, hanwang->phys, sizeof(hanwang->phys));\r\nstrlcat(hanwang->phys, "/input0", sizeof(hanwang->phys));\r\nstrlcpy(hanwang->name, hanwang->features->name, sizeof(hanwang->name));\r\ninput_dev->name = hanwang->name;\r\ninput_dev->phys = hanwang->phys;\r\nusb_to_input_id(dev, &input_dev->id);\r\ninput_dev->dev.parent = &intf->dev;\r\ninput_set_drvdata(input_dev, hanwang);\r\ninput_dev->open = hanwang_open;\r\ninput_dev->close = hanwang_close;\r\nfor (i = 0; i < ARRAY_SIZE(hw_eventtypes); ++i)\r\n__set_bit(hw_eventtypes[i], input_dev->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(hw_absevents); ++i)\r\n__set_bit(hw_absevents[i], input_dev->absbit);\r\nfor (i = 0; i < ARRAY_SIZE(hw_btnevents); ++i)\r\n__set_bit(hw_btnevents[i], input_dev->keybit);\r\nfor (i = 0; i < ARRAY_SIZE(hw_mscevents); ++i)\r\n__set_bit(hw_mscevents[i], input_dev->mscbit);\r\ninput_set_abs_params(input_dev, ABS_X,\r\n0, hanwang->features->max_x, 4, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\n0, hanwang->features->max_y, 4, 0);\r\ninput_set_abs_params(input_dev, ABS_TILT_X,\r\n0, hanwang->features->max_tilt_x, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_TILT_Y,\r\n0, hanwang->features->max_tilt_y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\n0, hanwang->features->max_pressure, 0, 0);\r\nendpoint = &intf->cur_altsetting->endpoint[0].desc;\r\nusb_fill_int_urb(hanwang->irq, dev,\r\nusb_rcvintpipe(dev, endpoint->bEndpointAddress),\r\nhanwang->data, hanwang->features->pkg_len,\r\nhanwang_irq, hanwang, endpoint->bInterval);\r\nhanwang->irq->transfer_dma = hanwang->data_dma;\r\nhanwang->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nerror = input_register_device(hanwang->dev);\r\nif (error)\r\ngoto fail3;\r\nusb_set_intfdata(intf, hanwang);\r\nreturn 0;\r\nfail3: usb_free_urb(hanwang->irq);\r\nfail2: usb_free_coherent(dev, hanwang->features->pkg_len,\r\nhanwang->data, hanwang->data_dma);\r\nfail1: input_free_device(input_dev);\r\nkfree(hanwang);\r\nreturn error;\r\n}\r\nstatic void hanwang_disconnect(struct usb_interface *intf)\r\n{\r\nstruct hanwang *hanwang = usb_get_intfdata(intf);\r\ninput_unregister_device(hanwang->dev);\r\nusb_free_urb(hanwang->irq);\r\nusb_free_coherent(interface_to_usbdev(intf),\r\nhanwang->features->pkg_len, hanwang->data,\r\nhanwang->data_dma);\r\nkfree(hanwang);\r\nusb_set_intfdata(intf, NULL);\r\n}
