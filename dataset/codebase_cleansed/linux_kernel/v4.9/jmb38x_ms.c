static unsigned int jmb38x_ms_read_data(struct jmb38x_ms_host *host,\r\nunsigned char *buf, unsigned int length)\r\n{\r\nunsigned int off = 0;\r\nwhile (host->io_pos && length) {\r\nbuf[off++] = host->io_word[0] & 0xff;\r\nhost->io_word[0] >>= 8;\r\nlength--;\r\nhost->io_pos--;\r\n}\r\nif (!length)\r\nreturn off;\r\nwhile (!(STATUS_FIFO_EMPTY & readl(host->addr + STATUS))) {\r\nif (length < 4)\r\nbreak;\r\n*(unsigned int *)(buf + off) = __raw_readl(host->addr + DATA);\r\nlength -= 4;\r\noff += 4;\r\n}\r\nif (length\r\n&& !(STATUS_FIFO_EMPTY & readl(host->addr + STATUS))) {\r\nhost->io_word[0] = readl(host->addr + DATA);\r\nfor (host->io_pos = 4; host->io_pos; --host->io_pos) {\r\nbuf[off++] = host->io_word[0] & 0xff;\r\nhost->io_word[0] >>= 8;\r\nlength--;\r\nif (!length)\r\nbreak;\r\n}\r\n}\r\nreturn off;\r\n}\r\nstatic unsigned int jmb38x_ms_read_reg_data(struct jmb38x_ms_host *host,\r\nunsigned char *buf,\r\nunsigned int length)\r\n{\r\nunsigned int off = 0;\r\nwhile (host->io_pos > 4 && length) {\r\nbuf[off++] = host->io_word[0] & 0xff;\r\nhost->io_word[0] >>= 8;\r\nlength--;\r\nhost->io_pos--;\r\n}\r\nif (!length)\r\nreturn off;\r\nwhile (host->io_pos && length) {\r\nbuf[off++] = host->io_word[1] & 0xff;\r\nhost->io_word[1] >>= 8;\r\nlength--;\r\nhost->io_pos--;\r\n}\r\nreturn off;\r\n}\r\nstatic unsigned int jmb38x_ms_write_data(struct jmb38x_ms_host *host,\r\nunsigned char *buf,\r\nunsigned int length)\r\n{\r\nunsigned int off = 0;\r\nif (host->io_pos) {\r\nwhile (host->io_pos < 4 && length) {\r\nhost->io_word[0] |= buf[off++] << (host->io_pos * 8);\r\nhost->io_pos++;\r\nlength--;\r\n}\r\n}\r\nif (host->io_pos == 4\r\n&& !(STATUS_FIFO_FULL & readl(host->addr + STATUS))) {\r\nwritel(host->io_word[0], host->addr + DATA);\r\nhost->io_pos = 0;\r\nhost->io_word[0] = 0;\r\n} else if (host->io_pos) {\r\nreturn off;\r\n}\r\nif (!length)\r\nreturn off;\r\nwhile (!(STATUS_FIFO_FULL & readl(host->addr + STATUS))) {\r\nif (length < 4)\r\nbreak;\r\n__raw_writel(*(unsigned int *)(buf + off),\r\nhost->addr + DATA);\r\nlength -= 4;\r\noff += 4;\r\n}\r\nswitch (length) {\r\ncase 3:\r\nhost->io_word[0] |= buf[off + 2] << 16;\r\nhost->io_pos++;\r\ncase 2:\r\nhost->io_word[0] |= buf[off + 1] << 8;\r\nhost->io_pos++;\r\ncase 1:\r\nhost->io_word[0] |= buf[off];\r\nhost->io_pos++;\r\n}\r\noff += host->io_pos;\r\nreturn off;\r\n}\r\nstatic unsigned int jmb38x_ms_write_reg_data(struct jmb38x_ms_host *host,\r\nunsigned char *buf,\r\nunsigned int length)\r\n{\r\nunsigned int off = 0;\r\nwhile (host->io_pos < 4 && length) {\r\nhost->io_word[0] &= ~(0xff << (host->io_pos * 8));\r\nhost->io_word[0] |= buf[off++] << (host->io_pos * 8);\r\nhost->io_pos++;\r\nlength--;\r\n}\r\nif (!length)\r\nreturn off;\r\nwhile (host->io_pos < 8 && length) {\r\nhost->io_word[1] &= ~(0xff << (host->io_pos * 8));\r\nhost->io_word[1] |= buf[off++] << (host->io_pos * 8);\r\nhost->io_pos++;\r\nlength--;\r\n}\r\nreturn off;\r\n}\r\nstatic int jmb38x_ms_transfer_data(struct jmb38x_ms_host *host)\r\n{\r\nunsigned int length;\r\nunsigned int off;\r\nunsigned int t_size, p_cnt;\r\nunsigned char *buf;\r\nstruct page *pg;\r\nunsigned long flags = 0;\r\nif (host->req->long_data) {\r\nlength = host->req->sg.length - host->block_pos;\r\noff = host->req->sg.offset + host->block_pos;\r\n} else {\r\nlength = host->req->data_len - host->block_pos;\r\noff = 0;\r\n}\r\nwhile (length) {\r\nunsigned int uninitialized_var(p_off);\r\nif (host->req->long_data) {\r\npg = nth_page(sg_page(&host->req->sg),\r\noff >> PAGE_SHIFT);\r\np_off = offset_in_page(off);\r\np_cnt = PAGE_SIZE - p_off;\r\np_cnt = min(p_cnt, length);\r\nlocal_irq_save(flags);\r\nbuf = kmap_atomic(pg) + p_off;\r\n} else {\r\nbuf = host->req->data + host->block_pos;\r\np_cnt = host->req->data_len - host->block_pos;\r\n}\r\nif (host->req->data_dir == WRITE)\r\nt_size = !(host->cmd_flags & REG_DATA)\r\n? jmb38x_ms_write_data(host, buf, p_cnt)\r\n: jmb38x_ms_write_reg_data(host, buf, p_cnt);\r\nelse\r\nt_size = !(host->cmd_flags & REG_DATA)\r\n? jmb38x_ms_read_data(host, buf, p_cnt)\r\n: jmb38x_ms_read_reg_data(host, buf, p_cnt);\r\nif (host->req->long_data) {\r\nkunmap_atomic(buf - p_off);\r\nlocal_irq_restore(flags);\r\n}\r\nif (!t_size)\r\nbreak;\r\nhost->block_pos += t_size;\r\nlength -= t_size;\r\noff += t_size;\r\n}\r\nif (!length && host->req->data_dir == WRITE) {\r\nif (host->cmd_flags & REG_DATA) {\r\nwritel(host->io_word[0], host->addr + TPC_P0);\r\nwritel(host->io_word[1], host->addr + TPC_P1);\r\n} else if (host->io_pos) {\r\nwritel(host->io_word[0], host->addr + DATA);\r\n}\r\n}\r\nreturn length;\r\n}\r\nstatic int jmb38x_ms_issue_cmd(struct memstick_host *msh)\r\n{\r\nstruct jmb38x_ms_host *host = memstick_priv(msh);\r\nunsigned char *data;\r\nunsigned int data_len, cmd, t_val;\r\nif (!(STATUS_HAS_MEDIA & readl(host->addr + STATUS))) {\r\ndev_dbg(&msh->dev, "no media status\n");\r\nhost->req->error = -ETIME;\r\nreturn host->req->error;\r\n}\r\ndev_dbg(&msh->dev, "control %08x\n", readl(host->addr + HOST_CONTROL));\r\ndev_dbg(&msh->dev, "status %08x\n", readl(host->addr + INT_STATUS));\r\ndev_dbg(&msh->dev, "hstatus %08x\n", readl(host->addr + STATUS));\r\nhost->cmd_flags = 0;\r\nhost->block_pos = 0;\r\nhost->io_pos = 0;\r\nhost->io_word[0] = 0;\r\nhost->io_word[1] = 0;\r\ncmd = host->req->tpc << 16;\r\ncmd |= TPC_DATA_SEL;\r\nif (host->req->data_dir == READ)\r\ncmd |= TPC_DIR;\r\nif (host->req->need_card_int) {\r\nif (host->ifmode == MEMSTICK_SERIAL)\r\ncmd |= TPC_GET_INT;\r\nelse\r\ncmd |= TPC_WAIT_INT;\r\n}\r\ndata = host->req->data;\r\nif (!no_dma)\r\nhost->cmd_flags |= DMA_DATA;\r\nif (host->req->long_data) {\r\ndata_len = host->req->sg.length;\r\n} else {\r\ndata_len = host->req->data_len;\r\nhost->cmd_flags &= ~DMA_DATA;\r\n}\r\nif (data_len <= 8) {\r\ncmd &= ~(TPC_DATA_SEL | 0xf);\r\nhost->cmd_flags |= REG_DATA;\r\ncmd |= data_len & 0xf;\r\nhost->cmd_flags &= ~DMA_DATA;\r\n}\r\nif (host->cmd_flags & DMA_DATA) {\r\nif (1 != dma_map_sg(&host->chip->pdev->dev, &host->req->sg, 1,\r\nhost->req->data_dir == READ\r\n? DMA_FROM_DEVICE\r\n: DMA_TO_DEVICE)) {\r\nhost->req->error = -ENOMEM;\r\nreturn host->req->error;\r\n}\r\ndata_len = sg_dma_len(&host->req->sg);\r\nwritel(sg_dma_address(&host->req->sg),\r\nhost->addr + DMA_ADDRESS);\r\nwritel(((1 << 16) & BLOCK_COUNT_MASK)\r\n| (data_len & BLOCK_SIZE_MASK),\r\nhost->addr + BLOCK);\r\nwritel(DMA_CONTROL_ENABLE, host->addr + DMA_CONTROL);\r\n} else if (!(host->cmd_flags & REG_DATA)) {\r\nwritel(((1 << 16) & BLOCK_COUNT_MASK)\r\n| (data_len & BLOCK_SIZE_MASK),\r\nhost->addr + BLOCK);\r\nt_val = readl(host->addr + INT_STATUS_ENABLE);\r\nt_val |= host->req->data_dir == READ\r\n? INT_STATUS_FIFO_RRDY\r\n: INT_STATUS_FIFO_WRDY;\r\nwritel(t_val, host->addr + INT_STATUS_ENABLE);\r\nwritel(t_val, host->addr + INT_SIGNAL_ENABLE);\r\n} else {\r\ncmd &= ~(TPC_DATA_SEL | 0xf);\r\nhost->cmd_flags |= REG_DATA;\r\ncmd |= data_len & 0xf;\r\nif (host->req->data_dir == WRITE) {\r\njmb38x_ms_transfer_data(host);\r\nwritel(host->io_word[0], host->addr + TPC_P0);\r\nwritel(host->io_word[1], host->addr + TPC_P1);\r\n}\r\n}\r\nmod_timer(&host->timer, jiffies + host->timeout_jiffies);\r\nwritel(HOST_CONTROL_LED | readl(host->addr + HOST_CONTROL),\r\nhost->addr + HOST_CONTROL);\r\nhost->req->error = 0;\r\nwritel(cmd, host->addr + TPC);\r\ndev_dbg(&msh->dev, "executing TPC %08x, len %x\n", cmd, data_len);\r\nreturn 0;\r\n}\r\nstatic void jmb38x_ms_complete_cmd(struct memstick_host *msh, int last)\r\n{\r\nstruct jmb38x_ms_host *host = memstick_priv(msh);\r\nunsigned int t_val = 0;\r\nint rc;\r\ndel_timer(&host->timer);\r\ndev_dbg(&msh->dev, "c control %08x\n",\r\nreadl(host->addr + HOST_CONTROL));\r\ndev_dbg(&msh->dev, "c status %08x\n",\r\nreadl(host->addr + INT_STATUS));\r\ndev_dbg(&msh->dev, "c hstatus %08x\n", readl(host->addr + STATUS));\r\nhost->req->int_reg = readl(host->addr + STATUS) & 0xff;\r\nwritel(0, host->addr + BLOCK);\r\nwritel(0, host->addr + DMA_CONTROL);\r\nif (host->cmd_flags & DMA_DATA) {\r\ndma_unmap_sg(&host->chip->pdev->dev, &host->req->sg, 1,\r\nhost->req->data_dir == READ\r\n? DMA_FROM_DEVICE : DMA_TO_DEVICE);\r\n} else {\r\nt_val = readl(host->addr + INT_STATUS_ENABLE);\r\nif (host->req->data_dir == READ)\r\nt_val &= ~INT_STATUS_FIFO_RRDY;\r\nelse\r\nt_val &= ~INT_STATUS_FIFO_WRDY;\r\nwritel(t_val, host->addr + INT_STATUS_ENABLE);\r\nwritel(t_val, host->addr + INT_SIGNAL_ENABLE);\r\n}\r\nwritel((~HOST_CONTROL_LED) & readl(host->addr + HOST_CONTROL),\r\nhost->addr + HOST_CONTROL);\r\nif (!last) {\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\n} while (!rc && jmb38x_ms_issue_cmd(msh));\r\n} else {\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\nif (!rc)\r\nhost->req->error = -ETIME;\r\n} while (!rc);\r\n}\r\n}\r\nstatic irqreturn_t jmb38x_ms_isr(int irq, void *dev_id)\r\n{\r\nstruct memstick_host *msh = dev_id;\r\nstruct jmb38x_ms_host *host = memstick_priv(msh);\r\nunsigned int irq_status;\r\nspin_lock(&host->lock);\r\nirq_status = readl(host->addr + INT_STATUS);\r\ndev_dbg(&host->chip->pdev->dev, "irq_status = %08x\n", irq_status);\r\nif (irq_status == 0 || irq_status == (~0)) {\r\nspin_unlock(&host->lock);\r\nreturn IRQ_NONE;\r\n}\r\nif (host->req) {\r\nif (irq_status & INT_STATUS_ANY_ERR) {\r\nif (irq_status & INT_STATUS_CRC_ERR)\r\nhost->req->error = -EILSEQ;\r\nelse if (irq_status & INT_STATUS_TPC_ERR) {\r\ndev_dbg(&host->chip->pdev->dev, "TPC_ERR\n");\r\njmb38x_ms_complete_cmd(msh, 0);\r\n} else\r\nhost->req->error = -ETIME;\r\n} else {\r\nif (host->cmd_flags & DMA_DATA) {\r\nif (irq_status & INT_STATUS_EOTRAN)\r\nhost->cmd_flags |= FIFO_READY;\r\n} else {\r\nif (irq_status & (INT_STATUS_FIFO_RRDY\r\n| INT_STATUS_FIFO_WRDY))\r\njmb38x_ms_transfer_data(host);\r\nif (irq_status & INT_STATUS_EOTRAN) {\r\njmb38x_ms_transfer_data(host);\r\nhost->cmd_flags |= FIFO_READY;\r\n}\r\n}\r\nif (irq_status & INT_STATUS_EOTPC) {\r\nhost->cmd_flags |= CMD_READY;\r\nif (host->cmd_flags & REG_DATA) {\r\nif (host->req->data_dir == READ) {\r\nhost->io_word[0]\r\n= readl(host->addr\r\n+ TPC_P0);\r\nhost->io_word[1]\r\n= readl(host->addr\r\n+ TPC_P1);\r\nhost->io_pos = 8;\r\njmb38x_ms_transfer_data(host);\r\n}\r\nhost->cmd_flags |= FIFO_READY;\r\n}\r\n}\r\n}\r\n}\r\nif (irq_status & (INT_STATUS_MEDIA_IN | INT_STATUS_MEDIA_OUT)) {\r\ndev_dbg(&host->chip->pdev->dev, "media changed\n");\r\nmemstick_detect_change(msh);\r\n}\r\nwritel(irq_status, host->addr + INT_STATUS);\r\nif (host->req\r\n&& (((host->cmd_flags & CMD_READY)\r\n&& (host->cmd_flags & FIFO_READY))\r\n|| host->req->error))\r\njmb38x_ms_complete_cmd(msh, 0);\r\nspin_unlock(&host->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void jmb38x_ms_abort(unsigned long data)\r\n{\r\nstruct memstick_host *msh = (struct memstick_host *)data;\r\nstruct jmb38x_ms_host *host = memstick_priv(msh);\r\nunsigned long flags;\r\ndev_dbg(&host->chip->pdev->dev, "abort\n");\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (host->req) {\r\nhost->req->error = -ETIME;\r\njmb38x_ms_complete_cmd(msh, 0);\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void jmb38x_ms_req_tasklet(unsigned long data)\r\n{\r\nstruct memstick_host *msh = (struct memstick_host *)data;\r\nstruct jmb38x_ms_host *host = memstick_priv(msh);\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (!host->req) {\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\ndev_dbg(&host->chip->pdev->dev, "tasklet req %d\n", rc);\r\n} while (!rc && jmb38x_ms_issue_cmd(msh));\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void jmb38x_ms_dummy_submit(struct memstick_host *msh)\r\n{\r\nreturn;\r\n}\r\nstatic void jmb38x_ms_submit_req(struct memstick_host *msh)\r\n{\r\nstruct jmb38x_ms_host *host = memstick_priv(msh);\r\ntasklet_schedule(&host->notify);\r\n}\r\nstatic int jmb38x_ms_reset(struct jmb38x_ms_host *host)\r\n{\r\nint cnt;\r\nwritel(HOST_CONTROL_RESET_REQ | HOST_CONTROL_CLOCK_EN\r\n| readl(host->addr + HOST_CONTROL),\r\nhost->addr + HOST_CONTROL);\r\nmmiowb();\r\nfor (cnt = 0; cnt < 20; ++cnt) {\r\nif (!(HOST_CONTROL_RESET_REQ\r\n& readl(host->addr + HOST_CONTROL)))\r\ngoto reset_next;\r\nndelay(20);\r\n}\r\ndev_dbg(&host->chip->pdev->dev, "reset_req timeout\n");\r\nreset_next:\r\nwritel(HOST_CONTROL_RESET | HOST_CONTROL_CLOCK_EN\r\n| readl(host->addr + HOST_CONTROL),\r\nhost->addr + HOST_CONTROL);\r\nmmiowb();\r\nfor (cnt = 0; cnt < 20; ++cnt) {\r\nif (!(HOST_CONTROL_RESET\r\n& readl(host->addr + HOST_CONTROL)))\r\ngoto reset_ok;\r\nndelay(20);\r\n}\r\ndev_dbg(&host->chip->pdev->dev, "reset timeout\n");\r\nreturn -EIO;\r\nreset_ok:\r\nmmiowb();\r\nwritel(INT_STATUS_ALL, host->addr + INT_SIGNAL_ENABLE);\r\nwritel(INT_STATUS_ALL, host->addr + INT_STATUS_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int jmb38x_ms_set_param(struct memstick_host *msh,\r\nenum memstick_param param,\r\nint value)\r\n{\r\nstruct jmb38x_ms_host *host = memstick_priv(msh);\r\nunsigned int host_ctl = readl(host->addr + HOST_CONTROL);\r\nunsigned int clock_ctl = CLOCK_CONTROL_BY_MMIO, clock_delay = 0;\r\nint rc = 0;\r\nswitch (param) {\r\ncase MEMSTICK_POWER:\r\nif (value == MEMSTICK_POWER_ON) {\r\nrc = jmb38x_ms_reset(host);\r\nif (rc)\r\nreturn rc;\r\nhost_ctl = 7;\r\nhost_ctl |= HOST_CONTROL_POWER_EN\r\n| HOST_CONTROL_CLOCK_EN;\r\nwritel(host_ctl, host->addr + HOST_CONTROL);\r\nwritel(host->id ? PAD_PU_PD_ON_MS_SOCK1\r\n: PAD_PU_PD_ON_MS_SOCK0,\r\nhost->addr + PAD_PU_PD);\r\nwritel(PAD_OUTPUT_ENABLE_MS,\r\nhost->addr + PAD_OUTPUT_ENABLE);\r\nmsleep(10);\r\ndev_dbg(&host->chip->pdev->dev, "power on\n");\r\n} else if (value == MEMSTICK_POWER_OFF) {\r\nhost_ctl &= ~(HOST_CONTROL_POWER_EN\r\n| HOST_CONTROL_CLOCK_EN);\r\nwritel(host_ctl, host->addr + HOST_CONTROL);\r\nwritel(0, host->addr + PAD_OUTPUT_ENABLE);\r\nwritel(PAD_PU_PD_OFF, host->addr + PAD_PU_PD);\r\ndev_dbg(&host->chip->pdev->dev, "power off\n");\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase MEMSTICK_INTERFACE:\r\ndev_dbg(&host->chip->pdev->dev,\r\n"Set Host Interface Mode to %d\n", value);\r\nhost_ctl &= ~(HOST_CONTROL_FAST_CLK | HOST_CONTROL_REI |\r\nHOST_CONTROL_REO);\r\nhost_ctl |= HOST_CONTROL_TDELAY_EN | HOST_CONTROL_HW_OC_P;\r\nhost_ctl &= ~(3 << HOST_CONTROL_IF_SHIFT);\r\nif (value == MEMSTICK_SERIAL) {\r\nhost_ctl |= HOST_CONTROL_IF_SERIAL\r\n<< HOST_CONTROL_IF_SHIFT;\r\nhost_ctl |= HOST_CONTROL_REI;\r\nclock_ctl |= CLOCK_CONTROL_40MHZ;\r\nclock_delay = 0;\r\n} else if (value == MEMSTICK_PAR4) {\r\nhost_ctl |= HOST_CONTROL_FAST_CLK;\r\nhost_ctl |= HOST_CONTROL_IF_PAR4\r\n<< HOST_CONTROL_IF_SHIFT;\r\nhost_ctl |= HOST_CONTROL_REO;\r\nclock_ctl |= CLOCK_CONTROL_40MHZ;\r\nclock_delay = 4;\r\n} else if (value == MEMSTICK_PAR8) {\r\nhost_ctl |= HOST_CONTROL_FAST_CLK;\r\nhost_ctl |= HOST_CONTROL_IF_PAR8\r\n<< HOST_CONTROL_IF_SHIFT;\r\nclock_ctl |= CLOCK_CONTROL_50MHZ;\r\nclock_delay = 0;\r\n} else\r\nreturn -EINVAL;\r\nwritel(host_ctl, host->addr + HOST_CONTROL);\r\nwritel(CLOCK_CONTROL_OFF, host->addr + CLOCK_CONTROL);\r\nwritel(clock_ctl, host->addr + CLOCK_CONTROL);\r\npci_write_config_byte(host->chip->pdev,\r\nPCI_CTL_CLOCK_DLY_ADDR + 1,\r\nclock_delay);\r\nhost->ifmode = value;\r\nbreak;\r\n};\r\nreturn 0;\r\n}\r\nstatic int jmb38x_ms_pmos(struct pci_dev *pdev, int flag)\r\n{\r\nunsigned char val;\r\npci_read_config_byte(pdev, PCI_PMOS0_CONTROL, &val);\r\nif (flag)\r\nval |= PMOS0_ACTIVE_BITS;\r\nelse\r\nval &= ~PMOS0_ACTIVE_BITS;\r\npci_write_config_byte(pdev, PCI_PMOS0_CONTROL, val);\r\ndev_dbg(&pdev->dev, "JMB38x: set PMOS0 val 0x%x\n", val);\r\nif (pci_resource_flags(pdev, 1)) {\r\npci_read_config_byte(pdev, PCI_PMOS1_CONTROL, &val);\r\nif (flag)\r\nval |= PMOS1_ACTIVE_BITS;\r\nelse\r\nval &= ~PMOS1_ACTIVE_BITS;\r\npci_write_config_byte(pdev, PCI_PMOS1_CONTROL, val);\r\ndev_dbg(&pdev->dev, "JMB38x: set PMOS1 val 0x%x\n", val);\r\n}\r\npci_read_config_byte(pdev, PCI_CLOCK_CTL, &val);\r\npci_write_config_byte(pdev, PCI_CLOCK_CTL, val & ~0x0f);\r\npci_write_config_byte(pdev, PCI_CLOCK_CTL, val | 0x01);\r\ndev_dbg(&pdev->dev, "Clock Control by PCI config is disabled!\n");\r\nreturn 0;\r\n}\r\nstatic int jmb38x_ms_suspend(struct pci_dev *dev, pm_message_t state)\r\n{\r\nstruct jmb38x_ms *jm = pci_get_drvdata(dev);\r\nint cnt;\r\nfor (cnt = 0; cnt < jm->host_cnt; ++cnt) {\r\nif (!jm->hosts[cnt])\r\nbreak;\r\nmemstick_suspend_host(jm->hosts[cnt]);\r\n}\r\npci_save_state(dev);\r\npci_enable_wake(dev, pci_choose_state(dev, state), 0);\r\npci_disable_device(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, state));\r\nreturn 0;\r\n}\r\nstatic int jmb38x_ms_resume(struct pci_dev *dev)\r\n{\r\nstruct jmb38x_ms *jm = pci_get_drvdata(dev);\r\nint rc;\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nrc = pci_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\npci_set_master(dev);\r\njmb38x_ms_pmos(dev, 1);\r\nfor (rc = 0; rc < jm->host_cnt; ++rc) {\r\nif (!jm->hosts[rc])\r\nbreak;\r\nmemstick_resume_host(jm->hosts[rc]);\r\nmemstick_detect_change(jm->hosts[rc]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int jmb38x_ms_count_slots(struct pci_dev *pdev)\r\n{\r\nint cnt, rc = 0;\r\nfor (cnt = 0; cnt < PCI_ROM_RESOURCE; ++cnt) {\r\nif (!(IORESOURCE_MEM & pci_resource_flags(pdev, cnt)))\r\nbreak;\r\nif (256 != pci_resource_len(pdev, cnt))\r\nbreak;\r\n++rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic struct memstick_host *jmb38x_ms_alloc_host(struct jmb38x_ms *jm, int cnt)\r\n{\r\nstruct memstick_host *msh;\r\nstruct jmb38x_ms_host *host;\r\nmsh = memstick_alloc_host(sizeof(struct jmb38x_ms_host),\r\n&jm->pdev->dev);\r\nif (!msh)\r\nreturn NULL;\r\nhost = memstick_priv(msh);\r\nhost->chip = jm;\r\nhost->addr = ioremap(pci_resource_start(jm->pdev, cnt),\r\npci_resource_len(jm->pdev, cnt));\r\nif (!host->addr)\r\ngoto err_out_free;\r\nspin_lock_init(&host->lock);\r\nhost->id = cnt;\r\nsnprintf(host->host_id, sizeof(host->host_id), DRIVER_NAME ":slot%d",\r\nhost->id);\r\nhost->irq = jm->pdev->irq;\r\nhost->timeout_jiffies = msecs_to_jiffies(1000);\r\ntasklet_init(&host->notify, jmb38x_ms_req_tasklet, (unsigned long)msh);\r\nmsh->request = jmb38x_ms_submit_req;\r\nmsh->set_param = jmb38x_ms_set_param;\r\nmsh->caps = MEMSTICK_CAP_PAR4 | MEMSTICK_CAP_PAR8;\r\nsetup_timer(&host->timer, jmb38x_ms_abort, (unsigned long)msh);\r\nif (!request_irq(host->irq, jmb38x_ms_isr, IRQF_SHARED, host->host_id,\r\nmsh))\r\nreturn msh;\r\niounmap(host->addr);\r\nerr_out_free:\r\nkfree(msh);\r\nreturn NULL;\r\n}\r\nstatic void jmb38x_ms_free_host(struct memstick_host *msh)\r\n{\r\nstruct jmb38x_ms_host *host = memstick_priv(msh);\r\nfree_irq(host->irq, msh);\r\niounmap(host->addr);\r\nmemstick_free_host(msh);\r\n}\r\nstatic int jmb38x_ms_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *dev_id)\r\n{\r\nstruct jmb38x_ms *jm;\r\nint pci_dev_busy = 0;\r\nint rc, cnt;\r\nrc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (rc)\r\nreturn rc;\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\npci_set_master(pdev);\r\nrc = pci_request_regions(pdev, DRIVER_NAME);\r\nif (rc) {\r\npci_dev_busy = 1;\r\ngoto err_out;\r\n}\r\njmb38x_ms_pmos(pdev, 1);\r\ncnt = jmb38x_ms_count_slots(pdev);\r\nif (!cnt) {\r\nrc = -ENODEV;\r\npci_dev_busy = 1;\r\ngoto err_out;\r\n}\r\njm = kzalloc(sizeof(struct jmb38x_ms)\r\n+ cnt * sizeof(struct memstick_host *), GFP_KERNEL);\r\nif (!jm) {\r\nrc = -ENOMEM;\r\ngoto err_out_int;\r\n}\r\njm->pdev = pdev;\r\njm->host_cnt = cnt;\r\npci_set_drvdata(pdev, jm);\r\nfor (cnt = 0; cnt < jm->host_cnt; ++cnt) {\r\njm->hosts[cnt] = jmb38x_ms_alloc_host(jm, cnt);\r\nif (!jm->hosts[cnt])\r\nbreak;\r\nrc = memstick_add_host(jm->hosts[cnt]);\r\nif (rc) {\r\njmb38x_ms_free_host(jm->hosts[cnt]);\r\njm->hosts[cnt] = NULL;\r\nbreak;\r\n}\r\n}\r\nif (cnt)\r\nreturn 0;\r\nrc = -ENODEV;\r\npci_set_drvdata(pdev, NULL);\r\nkfree(jm);\r\nerr_out_int:\r\npci_release_regions(pdev);\r\nerr_out:\r\nif (!pci_dev_busy)\r\npci_disable_device(pdev);\r\nreturn rc;\r\n}\r\nstatic void jmb38x_ms_remove(struct pci_dev *dev)\r\n{\r\nstruct jmb38x_ms *jm = pci_get_drvdata(dev);\r\nstruct jmb38x_ms_host *host;\r\nint cnt;\r\nunsigned long flags;\r\nfor (cnt = 0; cnt < jm->host_cnt; ++cnt) {\r\nif (!jm->hosts[cnt])\r\nbreak;\r\nhost = memstick_priv(jm->hosts[cnt]);\r\njm->hosts[cnt]->request = jmb38x_ms_dummy_submit;\r\ntasklet_kill(&host->notify);\r\nwritel(0, host->addr + INT_SIGNAL_ENABLE);\r\nwritel(0, host->addr + INT_STATUS_ENABLE);\r\nmmiowb();\r\ndev_dbg(&jm->pdev->dev, "interrupts off\n");\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (host->req) {\r\nhost->req->error = -ETIME;\r\njmb38x_ms_complete_cmd(jm->hosts[cnt], 1);\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nmemstick_remove_host(jm->hosts[cnt]);\r\ndev_dbg(&jm->pdev->dev, "host removed\n");\r\njmb38x_ms_free_host(jm->hosts[cnt]);\r\n}\r\njmb38x_ms_pmos(dev, 0);\r\npci_set_drvdata(dev, NULL);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\nkfree(jm);\r\n}
