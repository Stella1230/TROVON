static int get_ramp_delay(int ramp_delay)\r\n{\r\nunsigned char cnt = 0;\r\nramp_delay /= 6250;\r\nwhile (true) {\r\nramp_delay = ramp_delay >> 1;\r\nif (ramp_delay == 0)\r\nbreak;\r\ncnt++;\r\n}\r\nif (cnt > 3)\r\ncnt = 3;\r\nreturn cnt;\r\n}\r\nstatic int s2mps11_regulator_set_voltage_time_sel(struct regulator_dev *rdev,\r\nunsigned int old_selector,\r\nunsigned int new_selector)\r\n{\r\nstruct s2mps11_info *s2mps11 = rdev_get_drvdata(rdev);\r\nunsigned int ramp_delay = 0;\r\nint old_volt, new_volt;\r\nswitch (rdev_get_id(rdev)) {\r\ncase S2MPS11_BUCK2:\r\nramp_delay = s2mps11->ramp_delay2;\r\nbreak;\r\ncase S2MPS11_BUCK3:\r\ncase S2MPS11_BUCK4:\r\nramp_delay = s2mps11->ramp_delay34;\r\nbreak;\r\ncase S2MPS11_BUCK5:\r\nramp_delay = s2mps11->ramp_delay5;\r\nbreak;\r\ncase S2MPS11_BUCK6:\r\ncase S2MPS11_BUCK1:\r\nramp_delay = s2mps11->ramp_delay16;\r\nbreak;\r\ncase S2MPS11_BUCK7:\r\ncase S2MPS11_BUCK8:\r\ncase S2MPS11_BUCK10:\r\nramp_delay = s2mps11->ramp_delay7810;\r\nbreak;\r\ncase S2MPS11_BUCK9:\r\nramp_delay = s2mps11->ramp_delay9;\r\n}\r\nif (ramp_delay == 0)\r\nramp_delay = rdev->desc->ramp_delay;\r\nold_volt = rdev->desc->min_uV + (rdev->desc->uV_step * old_selector);\r\nnew_volt = rdev->desc->min_uV + (rdev->desc->uV_step * new_selector);\r\nreturn DIV_ROUND_UP(abs(new_volt - old_volt), ramp_delay);\r\n}\r\nstatic int s2mps11_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nstruct s2mps11_info *s2mps11 = rdev_get_drvdata(rdev);\r\nunsigned int ramp_val, ramp_shift, ramp_reg = S2MPS11_REG_RAMP_BUCK;\r\nunsigned int ramp_enable = 1, enable_shift = 0;\r\nint ret;\r\nswitch (rdev_get_id(rdev)) {\r\ncase S2MPS11_BUCK1:\r\nif (ramp_delay > s2mps11->ramp_delay16)\r\ns2mps11->ramp_delay16 = ramp_delay;\r\nelse\r\nramp_delay = s2mps11->ramp_delay16;\r\nramp_shift = S2MPS11_BUCK16_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPS11_BUCK2:\r\nenable_shift = S2MPS11_BUCK2_RAMP_EN_SHIFT;\r\nif (!ramp_delay) {\r\nramp_enable = 0;\r\nbreak;\r\n}\r\ns2mps11->ramp_delay2 = ramp_delay;\r\nramp_shift = S2MPS11_BUCK2_RAMP_SHIFT;\r\nramp_reg = S2MPS11_REG_RAMP;\r\nbreak;\r\ncase S2MPS11_BUCK3:\r\nenable_shift = S2MPS11_BUCK3_RAMP_EN_SHIFT;\r\nif (!ramp_delay) {\r\nramp_enable = 0;\r\nbreak;\r\n}\r\nif (ramp_delay > s2mps11->ramp_delay34)\r\ns2mps11->ramp_delay34 = ramp_delay;\r\nelse\r\nramp_delay = s2mps11->ramp_delay34;\r\nramp_shift = S2MPS11_BUCK34_RAMP_SHIFT;\r\nramp_reg = S2MPS11_REG_RAMP;\r\nbreak;\r\ncase S2MPS11_BUCK4:\r\nenable_shift = S2MPS11_BUCK4_RAMP_EN_SHIFT;\r\nif (!ramp_delay) {\r\nramp_enable = 0;\r\nbreak;\r\n}\r\nif (ramp_delay > s2mps11->ramp_delay34)\r\ns2mps11->ramp_delay34 = ramp_delay;\r\nelse\r\nramp_delay = s2mps11->ramp_delay34;\r\nramp_shift = S2MPS11_BUCK34_RAMP_SHIFT;\r\nramp_reg = S2MPS11_REG_RAMP;\r\nbreak;\r\ncase S2MPS11_BUCK5:\r\ns2mps11->ramp_delay5 = ramp_delay;\r\nramp_shift = S2MPS11_BUCK5_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPS11_BUCK6:\r\nenable_shift = S2MPS11_BUCK6_RAMP_EN_SHIFT;\r\nif (!ramp_delay) {\r\nramp_enable = 0;\r\nbreak;\r\n}\r\nif (ramp_delay > s2mps11->ramp_delay16)\r\ns2mps11->ramp_delay16 = ramp_delay;\r\nelse\r\nramp_delay = s2mps11->ramp_delay16;\r\nramp_shift = S2MPS11_BUCK16_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPS11_BUCK7:\r\ncase S2MPS11_BUCK8:\r\ncase S2MPS11_BUCK10:\r\nif (ramp_delay > s2mps11->ramp_delay7810)\r\ns2mps11->ramp_delay7810 = ramp_delay;\r\nelse\r\nramp_delay = s2mps11->ramp_delay7810;\r\nramp_shift = S2MPS11_BUCK7810_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPS11_BUCK9:\r\ns2mps11->ramp_delay9 = ramp_delay;\r\nramp_shift = S2MPS11_BUCK9_RAMP_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!ramp_enable)\r\ngoto ramp_disable;\r\nif ((rdev_get_id(rdev) >= S2MPS11_BUCK2 &&\r\nrdev_get_id(rdev) <= S2MPS11_BUCK4) ||\r\nrdev_get_id(rdev) == S2MPS11_BUCK6) {\r\nret = regmap_update_bits(rdev->regmap, S2MPS11_REG_RAMP,\r\n1 << enable_shift, 1 << enable_shift);\r\nif (ret) {\r\ndev_err(&rdev->dev, "failed to enable ramp rate\n");\r\nreturn ret;\r\n}\r\n}\r\nramp_val = get_ramp_delay(ramp_delay);\r\nreturn regmap_update_bits(rdev->regmap, ramp_reg, 0x3 << ramp_shift,\r\nramp_val << ramp_shift);\r\nramp_disable:\r\nreturn regmap_update_bits(rdev->regmap, S2MPS11_REG_RAMP,\r\n1 << enable_shift, 0);\r\n}\r\nstatic int s2mps14_regulator_enable(struct regulator_dev *rdev)\r\n{\r\nstruct s2mps11_info *s2mps11 = rdev_get_drvdata(rdev);\r\nunsigned int val;\r\nswitch (s2mps11->dev_type) {\r\ncase S2MPS13X:\r\ncase S2MPS14X:\r\nif (test_bit(rdev_get_id(rdev), s2mps11->suspend_state))\r\nval = S2MPS14_ENABLE_SUSPEND;\r\nelse if (gpio_is_valid(s2mps11->ext_control_gpio[rdev_get_id(rdev)]))\r\nval = S2MPS14_ENABLE_EXT_CONTROL;\r\nelse\r\nval = rdev->desc->enable_mask;\r\nbreak;\r\ncase S2MPU02:\r\nif (test_bit(rdev_get_id(rdev), s2mps11->suspend_state))\r\nval = S2MPU02_ENABLE_SUSPEND;\r\nelse\r\nval = rdev->desc->enable_mask;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, val);\r\n}\r\nstatic int s2mps14_regulator_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nint ret;\r\nunsigned int val, state;\r\nstruct s2mps11_info *s2mps11 = rdev_get_drvdata(rdev);\r\nint rdev_id = rdev_get_id(rdev);\r\nswitch (s2mps11->dev_type) {\r\ncase S2MPS13X:\r\ncase S2MPS14X:\r\nswitch (rdev_id) {\r\ncase S2MPS14_LDO3:\r\nreturn 0;\r\ndefault:\r\nstate = S2MPS14_ENABLE_SUSPEND;\r\nbreak;\r\n}\r\nbreak;\r\ncase S2MPU02:\r\nswitch (rdev_id) {\r\ncase S2MPU02_LDO13:\r\ncase S2MPU02_LDO14:\r\ncase S2MPU02_LDO15:\r\ncase S2MPU02_LDO17:\r\ncase S2MPU02_BUCK7:\r\nstate = S2MPU02_DISABLE_SUSPEND;\r\nbreak;\r\ndefault:\r\nstate = S2MPU02_ENABLE_SUSPEND;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = regmap_read(rdev->regmap, rdev->desc->enable_reg, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nset_bit(rdev_get_id(rdev), s2mps11->suspend_state);\r\nif (!(val & rdev->desc->enable_mask))\r\nreturn 0;\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, state);\r\n}\r\nstatic int s2mps14_pmic_enable_ext_control(struct s2mps11_info *s2mps11,\r\nstruct regulator_dev *rdev)\r\n{\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, S2MPS14_ENABLE_EXT_CONTROL);\r\n}\r\nstatic void s2mps14_pmic_dt_parse_ext_control_gpio(struct platform_device *pdev,\r\nstruct of_regulator_match *rdata, struct s2mps11_info *s2mps11)\r\n{\r\nint *gpio = s2mps11->ext_control_gpio;\r\nunsigned int i;\r\nunsigned int valid_regulators[3] = { S2MPS14_LDO10, S2MPS14_LDO11,\r\nS2MPS14_LDO12 };\r\nfor (i = 0; i < ARRAY_SIZE(valid_regulators); i++) {\r\nunsigned int reg = valid_regulators[i];\r\nif (!rdata[reg].init_data || !rdata[reg].of_node)\r\ncontinue;\r\ngpio[reg] = of_get_named_gpio(rdata[reg].of_node,\r\n"samsung,ext-control-gpios", 0);\r\nif (gpio_is_valid(gpio[reg]))\r\ndev_dbg(&pdev->dev, "Using GPIO %d for ext-control over %d/%s\n",\r\ngpio[reg], reg, rdata[reg].name);\r\n}\r\n}\r\nstatic int s2mps11_pmic_dt_parse(struct platform_device *pdev,\r\nstruct of_regulator_match *rdata, struct s2mps11_info *s2mps11,\r\nunsigned int rdev_num)\r\n{\r\nstruct device_node *reg_np;\r\nreg_np = of_get_child_by_name(pdev->dev.parent->of_node, "regulators");\r\nif (!reg_np) {\r\ndev_err(&pdev->dev, "could not find regulators sub-node\n");\r\nreturn -EINVAL;\r\n}\r\nof_regulator_match(&pdev->dev, reg_np, rdata, rdev_num);\r\nif (s2mps11->dev_type == S2MPS14X)\r\ns2mps14_pmic_dt_parse_ext_control_gpio(pdev, rdata, s2mps11);\r\nof_node_put(reg_np);\r\nreturn 0;\r\n}\r\nstatic int s2mpu02_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nunsigned int ramp_val, ramp_shift, ramp_reg;\r\nswitch (rdev_get_id(rdev)) {\r\ncase S2MPU02_BUCK1:\r\nramp_shift = S2MPU02_BUCK1_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPU02_BUCK2:\r\nramp_shift = S2MPU02_BUCK2_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPU02_BUCK3:\r\nramp_shift = S2MPU02_BUCK3_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPU02_BUCK4:\r\nramp_shift = S2MPU02_BUCK4_RAMP_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nramp_reg = S2MPU02_REG_RAMP1;\r\nramp_val = get_ramp_delay(ramp_delay);\r\nreturn regmap_update_bits(rdev->regmap, ramp_reg,\r\nS2MPU02_BUCK1234_RAMP_MASK << ramp_shift,\r\nramp_val << ramp_shift);\r\n}\r\nstatic int s2mps11_pmic_probe(struct platform_device *pdev)\r\n{\r\nstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct sec_platform_data *pdata = NULL;\r\nstruct of_regulator_match *rdata = NULL;\r\nstruct regulator_config config = { };\r\nstruct s2mps11_info *s2mps11;\r\nunsigned int rdev_num = 0;\r\nint i, ret = 0;\r\nconst struct regulator_desc *regulators;\r\ns2mps11 = devm_kzalloc(&pdev->dev, sizeof(struct s2mps11_info),\r\nGFP_KERNEL);\r\nif (!s2mps11)\r\nreturn -ENOMEM;\r\ns2mps11->dev_type = platform_get_device_id(pdev)->driver_data;\r\nswitch (s2mps11->dev_type) {\r\ncase S2MPS11X:\r\nrdev_num = ARRAY_SIZE(s2mps11_regulators);\r\nregulators = s2mps11_regulators;\r\nBUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mps11_regulators));\r\nbreak;\r\ncase S2MPS13X:\r\nrdev_num = ARRAY_SIZE(s2mps13_regulators);\r\nregulators = s2mps13_regulators;\r\nBUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mps13_regulators));\r\nbreak;\r\ncase S2MPS14X:\r\nrdev_num = ARRAY_SIZE(s2mps14_regulators);\r\nregulators = s2mps14_regulators;\r\nBUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mps14_regulators));\r\nbreak;\r\ncase S2MPS15X:\r\nrdev_num = ARRAY_SIZE(s2mps15_regulators);\r\nregulators = s2mps15_regulators;\r\nBUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mps15_regulators));\r\nbreak;\r\ncase S2MPU02:\r\nrdev_num = ARRAY_SIZE(s2mpu02_regulators);\r\nregulators = s2mpu02_regulators;\r\nBUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mpu02_regulators));\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Invalid device type: %u\n",\r\ns2mps11->dev_type);\r\nreturn -EINVAL;\r\n}\r\ns2mps11->ext_control_gpio = devm_kmalloc(&pdev->dev,\r\nsizeof(*s2mps11->ext_control_gpio) * rdev_num,\r\nGFP_KERNEL);\r\nif (!s2mps11->ext_control_gpio)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < rdev_num; i++)\r\ns2mps11->ext_control_gpio[i] = -EINVAL;\r\nif (!iodev->dev->of_node) {\r\nif (iodev->pdata) {\r\npdata = iodev->pdata;\r\ngoto common_reg;\r\n} else {\r\ndev_err(pdev->dev.parent,\r\n"Platform data or DT node not supplied\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nrdata = kzalloc(sizeof(*rdata) * rdev_num, GFP_KERNEL);\r\nif (!rdata)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < rdev_num; i++)\r\nrdata[i].name = regulators[i].name;\r\nret = s2mps11_pmic_dt_parse(pdev, rdata, s2mps11, rdev_num);\r\nif (ret)\r\ngoto out;\r\ncommon_reg:\r\nplatform_set_drvdata(pdev, s2mps11);\r\nconfig.dev = &pdev->dev;\r\nconfig.regmap = iodev->regmap_pmic;\r\nconfig.driver_data = s2mps11;\r\nconfig.ena_gpio_flags = GPIOF_OUT_INIT_HIGH;\r\nconfig.ena_gpio_initialized = true;\r\nfor (i = 0; i < rdev_num; i++) {\r\nstruct regulator_dev *regulator;\r\nif (pdata) {\r\nconfig.init_data = pdata->regulators[i].initdata;\r\nconfig.of_node = pdata->regulators[i].reg_node;\r\n} else {\r\nconfig.init_data = rdata[i].init_data;\r\nconfig.of_node = rdata[i].of_node;\r\n}\r\nconfig.ena_gpio = s2mps11->ext_control_gpio[i];\r\nregulator = devm_regulator_register(&pdev->dev,\r\n&regulators[i], &config);\r\nif (IS_ERR(regulator)) {\r\nret = PTR_ERR(regulator);\r\ndev_err(&pdev->dev, "regulator init failed for %d\n",\r\ni);\r\ngoto out;\r\n}\r\nif (gpio_is_valid(s2mps11->ext_control_gpio[i])) {\r\nret = s2mps14_pmic_enable_ext_control(s2mps11,\r\nregulator);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to enable GPIO control over %s: %d\n",\r\nregulator->desc->name, ret);\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nkfree(rdata);\r\nreturn ret;\r\n}
