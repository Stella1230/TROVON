static ssize_t vtpm_proxy_fops_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct proxy_dev *proxy_dev = filp->private_data;\r\nsize_t len;\r\nint sig, rc;\r\nsig = wait_event_interruptible(proxy_dev->wq,\r\nproxy_dev->req_len != 0 ||\r\n!(proxy_dev->state & STATE_OPENED_FLAG));\r\nif (sig)\r\nreturn -EINTR;\r\nmutex_lock(&proxy_dev->buf_lock);\r\nif (!(proxy_dev->state & STATE_OPENED_FLAG)) {\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn -EPIPE;\r\n}\r\nlen = proxy_dev->req_len;\r\nif (count < len) {\r\nmutex_unlock(&proxy_dev->buf_lock);\r\npr_debug("Invalid size in recv: count=%zd, req_len=%zd\n",\r\ncount, len);\r\nreturn -EIO;\r\n}\r\nrc = copy_to_user(buf, proxy_dev->buffer, len);\r\nmemset(proxy_dev->buffer, 0, len);\r\nproxy_dev->req_len = 0;\r\nif (!rc)\r\nproxy_dev->state |= STATE_WAIT_RESPONSE_FLAG;\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nif (rc)\r\nreturn -EFAULT;\r\nreturn len;\r\n}\r\nstatic ssize_t vtpm_proxy_fops_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct proxy_dev *proxy_dev = filp->private_data;\r\nmutex_lock(&proxy_dev->buf_lock);\r\nif (!(proxy_dev->state & STATE_OPENED_FLAG)) {\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn -EPIPE;\r\n}\r\nif (count > sizeof(proxy_dev->buffer) ||\r\n!(proxy_dev->state & STATE_WAIT_RESPONSE_FLAG)) {\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn -EIO;\r\n}\r\nproxy_dev->state &= ~STATE_WAIT_RESPONSE_FLAG;\r\nproxy_dev->req_len = 0;\r\nif (copy_from_user(proxy_dev->buffer, buf, count)) {\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn -EFAULT;\r\n}\r\nproxy_dev->resp_len = count;\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nwake_up_interruptible(&proxy_dev->wq);\r\nreturn count;\r\n}\r\nstatic unsigned int vtpm_proxy_fops_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct proxy_dev *proxy_dev = filp->private_data;\r\nunsigned ret;\r\npoll_wait(filp, &proxy_dev->wq, wait);\r\nret = POLLOUT;\r\nmutex_lock(&proxy_dev->buf_lock);\r\nif (proxy_dev->req_len)\r\nret |= POLLIN | POLLRDNORM;\r\nif (!(proxy_dev->state & STATE_OPENED_FLAG))\r\nret |= POLLHUP;\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn ret;\r\n}\r\nstatic void vtpm_proxy_fops_open(struct file *filp)\r\n{\r\nstruct proxy_dev *proxy_dev = filp->private_data;\r\nproxy_dev->state |= STATE_OPENED_FLAG;\r\n}\r\nstatic void vtpm_proxy_fops_undo_open(struct proxy_dev *proxy_dev)\r\n{\r\nmutex_lock(&proxy_dev->buf_lock);\r\nproxy_dev->state &= ~STATE_OPENED_FLAG;\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nwake_up_interruptible(&proxy_dev->wq);\r\n}\r\nstatic int vtpm_proxy_fops_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct proxy_dev *proxy_dev = filp->private_data;\r\nfilp->private_data = NULL;\r\nvtpm_proxy_delete_device(proxy_dev);\r\nreturn 0;\r\n}\r\nstatic int vtpm_proxy_tpm_op_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\r\nsize_t len;\r\nmutex_lock(&proxy_dev->buf_lock);\r\nif (!(proxy_dev->state & STATE_OPENED_FLAG)) {\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn -EPIPE;\r\n}\r\nlen = proxy_dev->resp_len;\r\nif (count < len) {\r\ndev_err(&chip->dev,\r\n"Invalid size in recv: count=%zd, resp_len=%zd\n",\r\ncount, len);\r\nlen = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(buf, proxy_dev->buffer, len);\r\nproxy_dev->resp_len = 0;\r\nout:\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn len;\r\n}\r\nstatic int vtpm_proxy_tpm_op_send(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\r\nint rc = 0;\r\nif (count > sizeof(proxy_dev->buffer)) {\r\ndev_err(&chip->dev,\r\n"Invalid size in send: count=%zd, buffer size=%zd\n",\r\ncount, sizeof(proxy_dev->buffer));\r\nreturn -EIO;\r\n}\r\nmutex_lock(&proxy_dev->buf_lock);\r\nif (!(proxy_dev->state & STATE_OPENED_FLAG)) {\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn -EPIPE;\r\n}\r\nproxy_dev->resp_len = 0;\r\nproxy_dev->req_len = count;\r\nmemcpy(proxy_dev->buffer, buf, count);\r\nproxy_dev->state &= ~STATE_WAIT_RESPONSE_FLAG;\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nwake_up_interruptible(&proxy_dev->wq);\r\nreturn rc;\r\n}\r\nstatic void vtpm_proxy_tpm_op_cancel(struct tpm_chip *chip)\r\n{\r\n}\r\nstatic u8 vtpm_proxy_tpm_op_status(struct tpm_chip *chip)\r\n{\r\nstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\r\nif (proxy_dev->resp_len)\r\nreturn VTPM_PROXY_REQ_COMPLETE_FLAG;\r\nreturn 0;\r\n}\r\nstatic bool vtpm_proxy_tpm_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\r\nbool ret;\r\nmutex_lock(&proxy_dev->buf_lock);\r\nret = !(proxy_dev->state & STATE_OPENED_FLAG);\r\nmutex_unlock(&proxy_dev->buf_lock);\r\nreturn ret;\r\n}\r\nstatic void vtpm_proxy_work(struct work_struct *work)\r\n{\r\nstruct proxy_dev *proxy_dev = container_of(work, struct proxy_dev,\r\nwork);\r\nint rc;\r\nrc = tpm_chip_register(proxy_dev->chip);\r\nif (rc)\r\ngoto err;\r\nreturn;\r\nerr:\r\nvtpm_proxy_fops_undo_open(proxy_dev);\r\n}\r\nstatic void vtpm_proxy_work_stop(struct proxy_dev *proxy_dev)\r\n{\r\nvtpm_proxy_fops_undo_open(proxy_dev);\r\nflush_work(&proxy_dev->work);\r\n}\r\nstatic inline void vtpm_proxy_work_start(struct proxy_dev *proxy_dev)\r\n{\r\nqueue_work(workqueue, &proxy_dev->work);\r\n}\r\nstatic struct proxy_dev *vtpm_proxy_create_proxy_dev(void)\r\n{\r\nstruct proxy_dev *proxy_dev;\r\nstruct tpm_chip *chip;\r\nint err;\r\nproxy_dev = kzalloc(sizeof(*proxy_dev), GFP_KERNEL);\r\nif (proxy_dev == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit_waitqueue_head(&proxy_dev->wq);\r\nmutex_init(&proxy_dev->buf_lock);\r\nINIT_WORK(&proxy_dev->work, vtpm_proxy_work);\r\nchip = tpm_chip_alloc(NULL, &vtpm_proxy_tpm_ops);\r\nif (IS_ERR(chip)) {\r\nerr = PTR_ERR(chip);\r\ngoto err_proxy_dev_free;\r\n}\r\ndev_set_drvdata(&chip->dev, proxy_dev);\r\nproxy_dev->chip = chip;\r\nreturn proxy_dev;\r\nerr_proxy_dev_free:\r\nkfree(proxy_dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic inline void vtpm_proxy_delete_proxy_dev(struct proxy_dev *proxy_dev)\r\n{\r\nput_device(&proxy_dev->chip->dev);\r\nkfree(proxy_dev);\r\n}\r\nstatic struct file *vtpm_proxy_create_device(\r\nstruct vtpm_proxy_new_dev *vtpm_new_dev)\r\n{\r\nstruct proxy_dev *proxy_dev;\r\nint rc, fd;\r\nstruct file *file;\r\nif (vtpm_new_dev->flags & ~VTPM_PROXY_FLAGS_ALL)\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\nproxy_dev = vtpm_proxy_create_proxy_dev();\r\nif (IS_ERR(proxy_dev))\r\nreturn ERR_CAST(proxy_dev);\r\nproxy_dev->flags = vtpm_new_dev->flags;\r\nfd = get_unused_fd_flags(O_RDWR);\r\nif (fd < 0) {\r\nrc = fd;\r\ngoto err_delete_proxy_dev;\r\n}\r\nfile = anon_inode_getfile("[vtpms]", &vtpm_proxy_fops, proxy_dev,\r\nO_RDWR);\r\nif (IS_ERR(file)) {\r\nrc = PTR_ERR(file);\r\ngoto err_put_unused_fd;\r\n}\r\nvtpm_proxy_fops_open(file);\r\nif (proxy_dev->flags & VTPM_PROXY_FLAG_TPM2)\r\nproxy_dev->chip->flags |= TPM_CHIP_FLAG_TPM2;\r\nvtpm_proxy_work_start(proxy_dev);\r\nvtpm_new_dev->fd = fd;\r\nvtpm_new_dev->major = MAJOR(proxy_dev->chip->dev.devt);\r\nvtpm_new_dev->minor = MINOR(proxy_dev->chip->dev.devt);\r\nvtpm_new_dev->tpm_num = proxy_dev->chip->dev_num;\r\nreturn file;\r\nerr_put_unused_fd:\r\nput_unused_fd(fd);\r\nerr_delete_proxy_dev:\r\nvtpm_proxy_delete_proxy_dev(proxy_dev);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic void vtpm_proxy_delete_device(struct proxy_dev *proxy_dev)\r\n{\r\nvtpm_proxy_work_stop(proxy_dev);\r\nvtpm_proxy_fops_undo_open(proxy_dev);\r\ntpm_chip_unregister(proxy_dev->chip);\r\nvtpm_proxy_delete_proxy_dev(proxy_dev);\r\n}\r\nstatic long vtpmx_fops_ioctl(struct file *f, unsigned int ioctl,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nstruct vtpm_proxy_new_dev __user *vtpm_new_dev_p;\r\nstruct vtpm_proxy_new_dev vtpm_new_dev;\r\nstruct file *file;\r\nswitch (ioctl) {\r\ncase VTPM_PROXY_IOC_NEW_DEV:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nvtpm_new_dev_p = argp;\r\nif (copy_from_user(&vtpm_new_dev, vtpm_new_dev_p,\r\nsizeof(vtpm_new_dev)))\r\nreturn -EFAULT;\r\nfile = vtpm_proxy_create_device(&vtpm_new_dev);\r\nif (IS_ERR(file))\r\nreturn PTR_ERR(file);\r\nif (copy_to_user(vtpm_new_dev_p, &vtpm_new_dev,\r\nsizeof(vtpm_new_dev))) {\r\nput_unused_fd(vtpm_new_dev.fd);\r\nfput(file);\r\nreturn -EFAULT;\r\n}\r\nfd_install(vtpm_new_dev.fd, file);\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic long vtpmx_fops_compat_ioctl(struct file *f, unsigned int ioctl,\r\nunsigned long arg)\r\n{\r\nreturn vtpmx_fops_ioctl(f, ioctl, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int vtpmx_init(void)\r\n{\r\nreturn misc_register(&vtpmx_miscdev);\r\n}\r\nstatic void vtpmx_cleanup(void)\r\n{\r\nmisc_deregister(&vtpmx_miscdev);\r\n}\r\nstatic int __init vtpm_module_init(void)\r\n{\r\nint rc;\r\nrc = vtpmx_init();\r\nif (rc) {\r\npr_err("couldn't create vtpmx device\n");\r\nreturn rc;\r\n}\r\nworkqueue = create_workqueue("tpm-vtpm");\r\nif (!workqueue) {\r\npr_err("couldn't create workqueue\n");\r\nrc = -ENOMEM;\r\ngoto err_vtpmx_cleanup;\r\n}\r\nreturn 0;\r\nerr_vtpmx_cleanup:\r\nvtpmx_cleanup();\r\nreturn rc;\r\n}\r\nstatic void __exit vtpm_module_exit(void)\r\n{\r\ndestroy_workqueue(workqueue);\r\nvtpmx_cleanup();\r\n}
