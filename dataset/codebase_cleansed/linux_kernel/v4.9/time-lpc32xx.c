static u64 notrace lpc32xx_read_sched_clock(void)\r\n{\r\nreturn readl(clocksource_timer_counter);\r\n}\r\nstatic unsigned long lpc32xx_delay_timer_read(void)\r\n{\r\nreturn readl(clocksource_timer_counter);\r\n}\r\nstatic int lpc32xx_clkevt_next_event(unsigned long delta,\r\nstruct clock_event_device *evtdev)\r\n{\r\nstruct lpc32xx_clock_event_ddata *ddata =\r\ncontainer_of(evtdev, struct lpc32xx_clock_event_ddata, evtdev);\r\nwritel_relaxed(LPC32XX_TIMER_TCR_CRST, ddata->base + LPC32XX_TIMER_TCR);\r\nwritel_relaxed(delta, ddata->base + LPC32XX_TIMER_MR0);\r\nwritel_relaxed(LPC32XX_TIMER_TCR_CEN, ddata->base + LPC32XX_TIMER_TCR);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_clkevt_shutdown(struct clock_event_device *evtdev)\r\n{\r\nstruct lpc32xx_clock_event_ddata *ddata =\r\ncontainer_of(evtdev, struct lpc32xx_clock_event_ddata, evtdev);\r\nwritel_relaxed(0, ddata->base + LPC32XX_TIMER_TCR);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_clkevt_oneshot(struct clock_event_device *evtdev)\r\n{\r\nstruct lpc32xx_clock_event_ddata *ddata =\r\ncontainer_of(evtdev, struct lpc32xx_clock_event_ddata, evtdev);\r\nwritel_relaxed(0, ddata->base + LPC32XX_TIMER_TCR);\r\nwritel_relaxed(LPC32XX_TIMER_MCR_MR0I | LPC32XX_TIMER_MCR_MR0R |\r\nLPC32XX_TIMER_MCR_MR0S, ddata->base + LPC32XX_TIMER_MCR);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_clkevt_periodic(struct clock_event_device *evtdev)\r\n{\r\nstruct lpc32xx_clock_event_ddata *ddata =\r\ncontainer_of(evtdev, struct lpc32xx_clock_event_ddata, evtdev);\r\nwritel_relaxed(LPC32XX_TIMER_MCR_MR0I | LPC32XX_TIMER_MCR_MR0R,\r\nddata->base + LPC32XX_TIMER_MCR);\r\nwritel_relaxed(LPC32XX_TIMER_TCR_CRST, ddata->base + LPC32XX_TIMER_TCR);\r\nwritel_relaxed(ddata->ticks_per_jiffy, ddata->base + LPC32XX_TIMER_MR0);\r\nwritel_relaxed(LPC32XX_TIMER_TCR_CEN, ddata->base + LPC32XX_TIMER_TCR);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t lpc32xx_clock_event_handler(int irq, void *dev_id)\r\n{\r\nstruct lpc32xx_clock_event_ddata *ddata = dev_id;\r\nwritel_relaxed(LPC32XX_TIMER_IR_MR0INT, ddata->base + LPC32XX_TIMER_IR);\r\nddata->evtdev.event_handler(&ddata->evtdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init lpc32xx_clocksource_init(struct device_node *np)\r\n{\r\nvoid __iomem *base;\r\nunsigned long rate;\r\nstruct clk *clk;\r\nint ret;\r\nclk = of_clk_get_by_name(np, "timerclk");\r\nif (IS_ERR(clk)) {\r\npr_err("clock get failed (%ld)\n", PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("clock enable failed (%d)\n", ret);\r\ngoto err_clk_enable;\r\n}\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_err("unable to map registers\n");\r\nret = -EADDRNOTAVAIL;\r\ngoto err_iomap;\r\n}\r\nwritel_relaxed(LPC32XX_TIMER_TCR_CRST, base + LPC32XX_TIMER_TCR);\r\nwritel_relaxed(0, base + LPC32XX_TIMER_PR);\r\nwritel_relaxed(0, base + LPC32XX_TIMER_MCR);\r\nwritel_relaxed(0, base + LPC32XX_TIMER_CTCR);\r\nwritel_relaxed(LPC32XX_TIMER_TCR_CEN, base + LPC32XX_TIMER_TCR);\r\nrate = clk_get_rate(clk);\r\nret = clocksource_mmio_init(base + LPC32XX_TIMER_TC, "lpc3220 timer",\r\nrate, 300, 32, clocksource_mmio_readl_up);\r\nif (ret) {\r\npr_err("failed to init clocksource (%d)\n", ret);\r\ngoto err_clocksource_init;\r\n}\r\nclocksource_timer_counter = base + LPC32XX_TIMER_TC;\r\nlpc32xx_delay_timer.freq = rate;\r\nregister_current_timer_delay(&lpc32xx_delay_timer);\r\nsched_clock_register(lpc32xx_read_sched_clock, 32, rate);\r\nreturn 0;\r\nerr_clocksource_init:\r\niounmap(base);\r\nerr_iomap:\r\nclk_disable_unprepare(clk);\r\nerr_clk_enable:\r\nclk_put(clk);\r\nreturn ret;\r\n}\r\nstatic int __init lpc32xx_clockevent_init(struct device_node *np)\r\n{\r\nvoid __iomem *base;\r\nunsigned long rate;\r\nstruct clk *clk;\r\nint ret, irq;\r\nclk = of_clk_get_by_name(np, "timerclk");\r\nif (IS_ERR(clk)) {\r\npr_err("clock get failed (%ld)\n", PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("clock enable failed (%d)\n", ret);\r\ngoto err_clk_enable;\r\n}\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_err("unable to map registers\n");\r\nret = -EADDRNOTAVAIL;\r\ngoto err_iomap;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\npr_err("get irq failed\n");\r\nret = -ENOENT;\r\ngoto err_irq;\r\n}\r\nwritel_relaxed(0, base + LPC32XX_TIMER_TCR);\r\nwritel_relaxed(0, base + LPC32XX_TIMER_PR);\r\nwritel_relaxed(0, base + LPC32XX_TIMER_CTCR);\r\nwritel_relaxed(LPC32XX_TIMER_IR_MR0INT, base + LPC32XX_TIMER_IR);\r\nrate = clk_get_rate(clk);\r\nlpc32xx_clk_event_ddata.base = base;\r\nlpc32xx_clk_event_ddata.ticks_per_jiffy = DIV_ROUND_CLOSEST(rate, HZ);\r\nclockevents_config_and_register(&lpc32xx_clk_event_ddata.evtdev,\r\nrate, 1, -1);\r\nret = request_irq(irq, lpc32xx_clock_event_handler,\r\nIRQF_TIMER | IRQF_IRQPOLL, "lpc3220 clockevent",\r\n&lpc32xx_clk_event_ddata);\r\nif (ret) {\r\npr_err("request irq failed\n");\r\ngoto err_irq;\r\n}\r\nreturn 0;\r\nerr_irq:\r\niounmap(base);\r\nerr_iomap:\r\nclk_disable_unprepare(clk);\r\nerr_clk_enable:\r\nclk_put(clk);\r\nreturn ret;\r\n}\r\nstatic int __init lpc32xx_timer_init(struct device_node *np)\r\n{\r\nstatic int has_clocksource, has_clockevent;\r\nint ret = 0;\r\nif (!has_clocksource) {\r\nret = lpc32xx_clocksource_init(np);\r\nif (!ret) {\r\nhas_clocksource = 1;\r\nreturn 0;\r\n}\r\n}\r\nif (!has_clockevent) {\r\nret = lpc32xx_clockevent_init(np);\r\nif (!ret) {\r\nhas_clockevent = 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn ret;\r\n}
