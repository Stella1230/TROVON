static void ep_bd_list_free(struct bdc_ep *ep, u32 num_tabs)\r\n{\r\nstruct bd_list *bd_list = &ep->bd_list;\r\nstruct bdc *bdc = ep->bdc;\r\nstruct bd_table *bd_table;\r\nint index;\r\ndev_dbg(bdc->dev, "%s ep:%s num_tabs:%d\n",\r\n__func__, ep->name, num_tabs);\r\nif (!bd_list->bd_table_array) {\r\ndev_dbg(bdc->dev, "%s already freed\n", ep->name);\r\nreturn;\r\n}\r\nfor (index = 0; index < num_tabs; index++) {\r\nbd_table = bd_list->bd_table_array[index];\r\ndev_dbg(bdc->dev, "bd_table:%p index:%d\n", bd_table, index);\r\nif (!bd_table) {\r\ndev_dbg(bdc->dev, "bd_table not allocated\n");\r\ncontinue;\r\n}\r\nif (!bd_table->start_bd) {\r\ndev_dbg(bdc->dev, "bd dma pool not allocated\n");\r\ncontinue;\r\n}\r\ndev_dbg(bdc->dev,\r\n"Free dma pool start_bd:%p dma:%llx\n",\r\nbd_table->start_bd,\r\n(unsigned long long)bd_table->dma);\r\ndma_pool_free(bdc->bd_table_pool,\r\nbd_table->start_bd,\r\nbd_table->dma);\r\nkfree(bd_table);\r\n}\r\nkfree(ep->bd_list.bd_table_array);\r\n}\r\nstatic inline void chain_table(struct bd_table *prev_table,\r\nstruct bd_table *next_table,\r\nu32 bd_p_tab)\r\n{\r\nprev_table->start_bd[bd_p_tab-1].offset[0] =\r\ncpu_to_le32(lower_32_bits(next_table->dma));\r\nprev_table->start_bd[bd_p_tab-1].offset[1] =\r\ncpu_to_le32(upper_32_bits(next_table->dma));\r\nprev_table->start_bd[bd_p_tab-1].offset[2] =\r\n0x0;\r\nprev_table->start_bd[bd_p_tab-1].offset[3] =\r\ncpu_to_le32(MARK_CHAIN_BD);\r\n}\r\nstatic int ep_bd_list_alloc(struct bdc_ep *ep)\r\n{\r\nstruct bd_table *prev_table = NULL;\r\nint index, num_tabs, bd_p_tab;\r\nstruct bdc *bdc = ep->bdc;\r\nstruct bd_table *bd_table;\r\ndma_addr_t dma;\r\nif (usb_endpoint_xfer_isoc(ep->desc))\r\nnum_tabs = NUM_TABLES_ISOCH;\r\nelse\r\nnum_tabs = NUM_TABLES;\r\nbd_p_tab = NUM_BDS_PER_TABLE;\r\ndev_dbg(bdc->dev,\r\n"%s ep:%p num_tabs:%d\n",\r\n__func__, ep, num_tabs);\r\nep->bd_list.bd_table_array = kzalloc(\r\nnum_tabs * sizeof(struct bd_table *),\r\nGFP_ATOMIC);\r\nif (!ep->bd_list.bd_table_array)\r\nreturn -ENOMEM;\r\nfor (index = 0; index < num_tabs; index++) {\r\nbd_table = kzalloc(sizeof(struct bd_table), GFP_ATOMIC);\r\nif (!bd_table)\r\ngoto fail;\r\nbd_table->start_bd = dma_pool_alloc(bdc->bd_table_pool,\r\nGFP_ATOMIC,\r\n&dma);\r\nif (!bd_table->start_bd) {\r\nkfree(bd_table);\r\ngoto fail;\r\n}\r\nbd_table->dma = dma;\r\ndev_dbg(bdc->dev,\r\n"index:%d start_bd:%p dma=%08llx prev_table:%p\n",\r\nindex, bd_table->start_bd,\r\n(unsigned long long)bd_table->dma, prev_table);\r\nep->bd_list.bd_table_array[index] = bd_table;\r\nmemset(bd_table->start_bd, 0, bd_p_tab * sizeof(struct bdc_bd));\r\nif (prev_table)\r\nchain_table(prev_table, bd_table, bd_p_tab);\r\nprev_table = bd_table;\r\n}\r\nchain_table(prev_table, ep->bd_list.bd_table_array[0], bd_p_tab);\r\nep->bd_list.num_tabs = num_tabs;\r\nep->bd_list.max_bdi = (num_tabs * bd_p_tab) - 1;\r\nep->bd_list.num_tabs = num_tabs;\r\nep->bd_list.num_bds_table = bd_p_tab;\r\nep->bd_list.eqp_bdi = 0;\r\nep->bd_list.hwd_bdi = 0;\r\nreturn 0;\r\nfail:\r\nep_bd_list_free(ep, num_tabs);\r\nreturn -ENOMEM;\r\n}\r\nstatic inline int bd_needed_req(struct bdc_req *req)\r\n{\r\nint bd_needed = 0;\r\nint remaining;\r\nif (req->usb_req.length == 0)\r\nreturn 1;\r\nremaining = req->usb_req.length % BD_MAX_BUFF_SIZE;\r\nif (remaining)\r\nbd_needed++;\r\nremaining = req->usb_req.length / BD_MAX_BUFF_SIZE;\r\nbd_needed += remaining;\r\nreturn bd_needed;\r\n}\r\nstatic int bd_add_to_bdi(struct bdc_ep *ep, dma_addr_t bd_dma_addr)\r\n{\r\nstruct bd_list *bd_list = &ep->bd_list;\r\ndma_addr_t dma_first_bd, dma_last_bd;\r\nstruct bdc *bdc = ep->bdc;\r\nstruct bd_table *bd_table;\r\nbool found = false;\r\nint tbi, bdi;\r\ndma_first_bd = dma_last_bd = 0;\r\ndev_dbg(bdc->dev, "%s %llx\n",\r\n__func__, (unsigned long long)bd_dma_addr);\r\nfor (tbi = 0; tbi < bd_list->num_tabs; tbi++) {\r\nbd_table = bd_list->bd_table_array[tbi];\r\ndma_first_bd = bd_table->dma;\r\ndma_last_bd = bd_table->dma +\r\n(sizeof(struct bdc_bd) *\r\n(bd_list->num_bds_table - 1));\r\ndev_dbg(bdc->dev, "dma_first_bd:%llx dma_last_bd:%llx\n",\r\n(unsigned long long)dma_first_bd,\r\n(unsigned long long)dma_last_bd);\r\nif (bd_dma_addr >= dma_first_bd && bd_dma_addr <= dma_last_bd) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (unlikely(!found)) {\r\ndev_err(bdc->dev, "%s FATAL err, bd not found\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nbdi = (bd_dma_addr - dma_first_bd) / sizeof(struct bdc_bd);\r\nreturn (bdi + (tbi * bd_list->num_bds_table));\r\n}\r\nstatic int bdi_to_tbi(struct bdc_ep *ep, int bdi)\r\n{\r\nint tbi;\r\ntbi = bdi / ep->bd_list.num_bds_table;\r\ndev_vdbg(ep->bdc->dev,\r\n"bdi:%d num_bds_table:%d tbi:%d\n",\r\nbdi, ep->bd_list.num_bds_table, tbi);\r\nreturn tbi;\r\n}\r\nstatic inline int find_end_bdi(struct bdc_ep *ep, int next_hwd_bdi)\r\n{\r\nint end_bdi;\r\nend_bdi = next_hwd_bdi - 1;\r\nif (end_bdi < 0)\r\nend_bdi = ep->bd_list.max_bdi - 1;\r\nelse if ((end_bdi % (ep->bd_list.num_bds_table-1)) == 0)\r\nend_bdi--;\r\nreturn end_bdi;\r\n}\r\nstatic int bd_available_ep(struct bdc_ep *ep)\r\n{\r\nstruct bd_list *bd_list = &ep->bd_list;\r\nint available1, available2;\r\nstruct bdc *bdc = ep->bdc;\r\nint chain_bd1, chain_bd2;\r\nint available_bd = 0;\r\navailable1 = available2 = chain_bd1 = chain_bd2 = 0;\r\nif (bd_list->eqp_bdi == bd_list->hwd_bdi)\r\nreturn bd_list->max_bdi - bd_list->num_tabs;\r\nif (bd_list->hwd_bdi < bd_list->eqp_bdi) {\r\navailable1 = bd_list->max_bdi - bd_list->eqp_bdi;\r\navailable2 = bd_list->hwd_bdi;\r\nchain_bd1 = available1 / bd_list->num_bds_table;\r\nchain_bd2 = available2 / bd_list->num_bds_table;\r\ndev_vdbg(bdc->dev, "chain_bd1:%d chain_bd2:%d\n",\r\nchain_bd1, chain_bd2);\r\navailable_bd = available1 + available2 - chain_bd1 - chain_bd2;\r\n} else {\r\navailable1 = bd_list->hwd_bdi - bd_list->eqp_bdi;\r\nif ((bd_list->hwd_bdi - bd_list->eqp_bdi)\r\n<= bd_list->num_bds_table) {\r\nif (!(bdi_to_tbi(ep, bd_list->hwd_bdi)\r\n== bdi_to_tbi(ep, bd_list->eqp_bdi))) {\r\navailable_bd = available1 - 1;\r\n}\r\n} else {\r\nchain_bd1 = available1 / bd_list->num_bds_table;\r\navailable_bd = available1 - chain_bd1;\r\n}\r\n}\r\navailable_bd--;\r\ndev_vdbg(bdc->dev, "available_bd:%d\n", available_bd);\r\nreturn available_bd;\r\n}\r\nvoid bdc_notify_xfr(struct bdc *bdc, u32 epnum)\r\n{\r\nstruct bdc_ep *ep = bdc->bdc_ep_array[epnum];\r\ndev_vdbg(bdc->dev, "%s epnum:%d\n", __func__, epnum);\r\nif (unlikely(ep->flags & BDC_EP_STOP))\r\nep->flags &= ~BDC_EP_STOP;\r\nbdc_writel(bdc->regs, BDC_XSFNTF, epnum);\r\n}\r\nstatic struct bdc_bd *bdi_to_bd(struct bdc_ep *ep, int bdi)\r\n{\r\nint tbi = bdi_to_tbi(ep, bdi);\r\nint local_bdi = 0;\r\nlocal_bdi = bdi - (tbi * ep->bd_list.num_bds_table);\r\ndev_vdbg(ep->bdc->dev,\r\n"%s bdi:%d local_bdi:%d\n",\r\n__func__, bdi, local_bdi);\r\nreturn (ep->bd_list.bd_table_array[tbi]->start_bd + local_bdi);\r\n}\r\nstatic void ep_bdlist_eqp_adv(struct bdc_ep *ep)\r\n{\r\nep->bd_list.eqp_bdi++;\r\nif (((ep->bd_list.eqp_bdi + 1) % ep->bd_list.num_bds_table) == 0)\r\nep->bd_list.eqp_bdi++;\r\nif (ep->bd_list.eqp_bdi == (ep->bd_list.max_bdi + 1))\r\nep->bd_list.eqp_bdi = 0;\r\n}\r\nstatic int setup_first_bd_ep0(struct bdc *bdc, struct bdc_req *req, u32 *dword3)\r\n{\r\nu16 wValue;\r\nu32 req_len;\r\nreq->ep->dir = 0;\r\nreq_len = req->usb_req.length;\r\nswitch (bdc->ep0_state) {\r\ncase WAIT_FOR_DATA_START:\r\n*dword3 |= BD_TYPE_DS;\r\nif (bdc->setup_pkt.bRequestType & USB_DIR_IN)\r\n*dword3 |= BD_DIR_IN;\r\nwValue = le16_to_cpu(bdc->setup_pkt.wValue);\r\nif ((wValue > req_len) &&\r\n(req_len % bdc->gadget.ep0->maxpacket == 0)) {\r\ndev_dbg(bdc->dev, "ZLP needed wVal:%d len:%d MaxP:%d\n",\r\nwValue, req_len,\r\nbdc->gadget.ep0->maxpacket);\r\nbdc->zlp_needed = true;\r\n}\r\nbreak;\r\ncase WAIT_FOR_STATUS_START:\r\n*dword3 |= BD_TYPE_SS;\r\nif (!le16_to_cpu(bdc->setup_pkt.wLength) ||\r\n!(bdc->setup_pkt.bRequestType & USB_DIR_IN))\r\n*dword3 |= BD_DIR_IN;\r\nbreak;\r\ndefault:\r\ndev_err(bdc->dev,\r\n"Unknown ep0 state for queueing bd ep0_state:%s\n",\r\nep0_state_string[bdc->ep0_state]);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_bd_list_xfr(struct bdc *bdc, struct bdc_req *req, int num_bds)\r\n{\r\ndma_addr_t buf_add = req->usb_req.dma;\r\nu32 maxp, tfs, dword2, dword3;\r\nstruct bd_transfer *bd_xfr;\r\nstruct bd_list *bd_list;\r\nstruct bdc_ep *ep;\r\nstruct bdc_bd *bd;\r\nint ret, bdnum;\r\nu32 req_len;\r\nep = req->ep;\r\nbd_list = &ep->bd_list;\r\nbd_xfr = &req->bd_xfr;\r\nbd_xfr->req = req;\r\nbd_xfr->start_bdi = bd_list->eqp_bdi;\r\nbd = bdi_to_bd(ep, bd_list->eqp_bdi);\r\nreq_len = req->usb_req.length;\r\nmaxp = usb_endpoint_maxp(ep->desc) & 0x7ff;\r\ntfs = roundup(req->usb_req.length, maxp);\r\ntfs = tfs/maxp;\r\ndev_vdbg(bdc->dev, "%s ep:%s num_bds:%d tfs:%d r_len:%d bd:%p\n",\r\n__func__, ep->name, num_bds, tfs, req_len, bd);\r\nfor (bdnum = 0; bdnum < num_bds; bdnum++) {\r\ndword2 = dword3 = 0;\r\nif (!bdnum) {\r\ndword3 |= BD_SOT|BD_SBF|(tfs<<BD_TFS_SHIFT);\r\ndword2 |= BD_LTF;\r\nif (ep->ep_num == 1) {\r\nret = setup_first_bd_ep0(bdc, req, &dword3);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nif (!req->ep->dir)\r\ndword3 |= BD_ISP;\r\nif (req_len > BD_MAX_BUFF_SIZE) {\r\ndword2 |= BD_MAX_BUFF_SIZE;\r\nreq_len -= BD_MAX_BUFF_SIZE;\r\n} else {\r\ndword2 |= req_len;\r\ndword3 |= BD_IOC;\r\ndword3 |= BD_EOT;\r\n}\r\ndword2 |= BD_INTR_TARGET(0);\r\nbd = bdi_to_bd(ep, ep->bd_list.eqp_bdi);\r\nif (unlikely(!bd)) {\r\ndev_err(bdc->dev, "Err bd pointing to wrong addr\n");\r\nreturn -EINVAL;\r\n}\r\nbd->offset[0] = cpu_to_le32(lower_32_bits(buf_add));\r\nbd->offset[1] = cpu_to_le32(upper_32_bits(buf_add));\r\nbd->offset[2] = cpu_to_le32(dword2);\r\nbd->offset[3] = cpu_to_le32(dword3);\r\nep_bdlist_eqp_adv(ep);\r\nbuf_add += BD_MAX_BUFF_SIZE;\r\ndev_vdbg(bdc->dev, "buf_add:%08llx req_len:%d bd:%p eqp:%d\n",\r\n(unsigned long long)buf_add, req_len, bd,\r\nep->bd_list.eqp_bdi);\r\nbd = bdi_to_bd(ep, ep->bd_list.eqp_bdi);\r\nbd->offset[3] = cpu_to_le32(BD_SBF);\r\n}\r\nbd = bdi_to_bd(ep, bd_xfr->start_bdi);\r\nbd->offset[3] &= cpu_to_le32(~BD_SBF);\r\nbd_xfr->num_bds = num_bds;\r\nbd_xfr->next_hwd_bdi = ep->bd_list.eqp_bdi;\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic int bdc_queue_xfr(struct bdc *bdc, struct bdc_req *req)\r\n{\r\nint num_bds, bd_available;\r\nstruct bdc_ep *ep;\r\nint ret;\r\nep = req->ep;\r\ndev_dbg(bdc->dev, "%s req:%p\n", __func__, req);\r\ndev_dbg(bdc->dev, "eqp_bdi:%d hwd_bdi:%d\n",\r\nep->bd_list.eqp_bdi, ep->bd_list.hwd_bdi);\r\nnum_bds = bd_needed_req(req);\r\nbd_available = bd_available_ep(ep);\r\nif (num_bds > bd_available)\r\nreturn -ENOMEM;\r\nret = setup_bd_list_xfr(bdc, req, num_bds);\r\nif (ret)\r\nreturn ret;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nbdc_dbg_bd_list(bdc, ep);\r\nbdc_notify_xfr(bdc, ep->ep_num);\r\nreturn 0;\r\n}\r\nstatic void bdc_req_complete(struct bdc_ep *ep, struct bdc_req *req,\r\nint status)\r\n{\r\nstruct bdc *bdc = ep->bdc;\r\nif (req == NULL || &req->queue == NULL || &req->usb_req == NULL)\r\nreturn;\r\ndev_dbg(bdc->dev, "%s ep:%s status:%d\n", __func__, ep->name, status);\r\nlist_del(&req->queue);\r\nreq->usb_req.status = status;\r\nusb_gadget_unmap_request(&bdc->gadget, &req->usb_req, ep->dir);\r\nif (req->usb_req.complete) {\r\nspin_unlock(&bdc->lock);\r\nusb_gadget_giveback_request(&ep->usb_ep, &req->usb_req);\r\nspin_lock(&bdc->lock);\r\n}\r\n}\r\nint bdc_ep_disable(struct bdc_ep *ep)\r\n{\r\nstruct bdc_req *req;\r\nstruct bdc *bdc;\r\nint ret;\r\nret = 0;\r\nbdc = ep->bdc;\r\ndev_dbg(bdc->dev, "%s() ep->ep_num=%d\n", __func__, ep->ep_num);\r\nret = bdc_stop_ep(bdc, ep->ep_num);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct bdc_req,\r\nqueue);\r\nbdc_req_complete(ep, req, -ESHUTDOWN);\r\n}\r\nret = bdc_dconfig_ep(bdc, ep);\r\nif (ret)\r\ndev_warn(bdc->dev,\r\n"dconfig fail but continue with memory free");\r\nep->flags = 0;\r\nif (ep->ep_num == 1)\r\nreturn 0;\r\nep_bd_list_free(ep, ep->bd_list.num_tabs);\r\nep->desc = NULL;\r\nep->comp_desc = NULL;\r\nep->usb_ep.desc = NULL;\r\nep->ep_type = 0;\r\nreturn ret;\r\n}\r\nint bdc_ep_enable(struct bdc_ep *ep)\r\n{\r\nstruct bdc *bdc;\r\nint ret = 0;\r\nbdc = ep->bdc;\r\ndev_dbg(bdc->dev, "%s NUM_TABLES:%d %d\n",\r\n__func__, NUM_TABLES, NUM_TABLES_ISOCH);\r\nret = ep_bd_list_alloc(ep);\r\nif (ret) {\r\ndev_err(bdc->dev, "ep bd list allocation failed:%d\n", ret);\r\nreturn -ENOMEM;\r\n}\r\nbdc_dbg_bd_list(bdc, ep);\r\nep->flags |= BDC_EP_ENABLED;\r\nif (ep->ep_num == 1)\r\nreturn ret;\r\nret = bdc_config_ep(bdc, ep);\r\nif (ret)\r\nreturn ret;\r\nep->usb_ep.maxpacket = usb_endpoint_maxp(ep->desc);\r\nep->usb_ep.desc = ep->desc;\r\nep->usb_ep.comp_desc = ep->comp_desc;\r\nep->ep_type = usb_endpoint_type(ep->desc);\r\nep->flags |= BDC_EP_ENABLED;\r\nreturn 0;\r\n}\r\nstatic int ep0_queue_status_stage(struct bdc *bdc)\r\n{\r\nstruct bdc_req *status_req;\r\nstruct bdc_ep *ep;\r\nstatus_req = &bdc->status_req;\r\nep = bdc->bdc_ep_array[1];\r\nstatus_req->ep = ep;\r\nstatus_req->usb_req.length = 0;\r\nstatus_req->usb_req.status = -EINPROGRESS;\r\nstatus_req->usb_req.actual = 0;\r\nstatus_req->usb_req.complete = NULL;\r\nbdc_queue_xfr(bdc, status_req);\r\nreturn 0;\r\n}\r\nstatic int ep0_queue(struct bdc_ep *ep, struct bdc_req *req)\r\n{\r\nstruct bdc *bdc;\r\nint ret;\r\nbdc = ep->bdc;\r\ndev_dbg(bdc->dev, "%s()\n", __func__);\r\nreq->usb_req.actual = 0;\r\nreq->usb_req.status = -EINPROGRESS;\r\nreq->epnum = ep->ep_num;\r\nif (bdc->delayed_status) {\r\nbdc->delayed_status = false;\r\nif (bdc->ep0_state == WAIT_FOR_STATUS_START) {\r\nep0_queue_status_stage(bdc);\r\nbdc->ep0_state = WAIT_FOR_STATUS_XMIT;\r\nreturn 0;\r\n}\r\n} else {\r\nif (req->usb_req.length == 0)\r\nreturn 0;\r\n}\r\nret = usb_gadget_map_request(&bdc->gadget, &req->usb_req, ep->dir);\r\nif (ret) {\r\ndev_err(bdc->dev, "dma mapping failed %s\n", ep->name);\r\nreturn ret;\r\n}\r\nreturn bdc_queue_xfr(bdc, req);\r\n}\r\nstatic int ep0_queue_data_stage(struct bdc *bdc)\r\n{\r\nstruct bdc_ep *ep;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nep = bdc->bdc_ep_array[1];\r\nbdc->ep0_req.ep = ep;\r\nbdc->ep0_req.usb_req.complete = NULL;\r\nreturn ep0_queue(ep, &bdc->ep0_req);\r\n}\r\nstatic int ep_queue(struct bdc_ep *ep, struct bdc_req *req)\r\n{\r\nstruct bdc *bdc;\r\nint ret = 0;\r\nif (!req || !ep->usb_ep.desc)\r\nreturn -EINVAL;\r\nbdc = ep->bdc;\r\nreq->usb_req.actual = 0;\r\nreq->usb_req.status = -EINPROGRESS;\r\nreq->epnum = ep->ep_num;\r\nret = usb_gadget_map_request(&bdc->gadget, &req->usb_req, ep->dir);\r\nif (ret) {\r\ndev_err(bdc->dev, "dma mapping failed\n");\r\nreturn ret;\r\n}\r\nreturn bdc_queue_xfr(bdc, req);\r\n}\r\nstatic int ep_dequeue(struct bdc_ep *ep, struct bdc_req *req)\r\n{\r\nint start_bdi, end_bdi, tbi, eqp_bdi, curr_hw_dqpi;\r\nbool start_pending, end_pending;\r\nbool first_remove = false;\r\nstruct bdc_req *first_req;\r\nstruct bdc_bd *bd_start;\r\nstruct bd_table *table;\r\ndma_addr_t next_bd_dma;\r\nu64 deq_ptr_64 = 0;\r\nstruct bdc *bdc;\r\nu32 tmp_32;\r\nint ret;\r\nbdc = ep->bdc;\r\nstart_pending = end_pending = false;\r\neqp_bdi = ep->bd_list.eqp_bdi - 1;\r\nif (eqp_bdi < 0)\r\neqp_bdi = ep->bd_list.max_bdi;\r\nstart_bdi = req->bd_xfr.start_bdi;\r\nend_bdi = find_end_bdi(ep, req->bd_xfr.next_hwd_bdi);\r\ndev_dbg(bdc->dev, "%s ep:%s start:%d end:%d\n",\r\n__func__, ep->name, start_bdi, end_bdi);\r\ndev_dbg(bdc->dev, "ep_dequeue ep=%p ep->desc=%p\n",\r\nep, (void *)ep->usb_ep.desc);\r\nret = bdc_stop_ep(bdc, ep->ep_num);\r\nif (ret)\r\nreturn 0;\r\ntmp_32 = bdc_readl(bdc->regs, BDC_EPSTS0(0));\r\ndeq_ptr_64 = tmp_32;\r\ntmp_32 = bdc_readl(bdc->regs, BDC_EPSTS1(0));\r\ndeq_ptr_64 |= ((u64)tmp_32 << 32);\r\ncurr_hw_dqpi = bd_add_to_bdi(ep, deq_ptr_64);\r\nif (curr_hw_dqpi < 0)\r\nreturn curr_hw_dqpi;\r\nif (curr_hw_dqpi > eqp_bdi) {\r\nif (start_bdi >= curr_hw_dqpi || start_bdi <= eqp_bdi) {\r\nstart_pending = true;\r\nend_pending = true;\r\n} else if (end_bdi >= curr_hw_dqpi || end_bdi <= eqp_bdi) {\r\nend_pending = true;\r\n}\r\n} else {\r\nif (start_bdi >= curr_hw_dqpi) {\r\nstart_pending = true;\r\nend_pending = true;\r\n} else if (end_bdi >= curr_hw_dqpi) {\r\nend_pending = true;\r\n}\r\n}\r\ndev_dbg(bdc->dev,\r\n"start_pending:%d end_pending:%d speed:%d\n",\r\nstart_pending, end_pending, bdc->gadget.speed);\r\nif (!start_pending && !end_pending)\r\nreturn -EINVAL;\r\nif (bdc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn 0;\r\ntbi = bdi_to_tbi(ep, req->bd_xfr.next_hwd_bdi);\r\ntable = ep->bd_list.bd_table_array[tbi];\r\nnext_bd_dma = table->dma +\r\nsizeof(struct bdc_bd)*(req->bd_xfr.next_hwd_bdi -\r\ntbi * ep->bd_list.num_bds_table);\r\nfirst_req = list_first_entry(&ep->queue, struct bdc_req,\r\nqueue);\r\nif (req == first_req)\r\nfirst_remove = true;\r\nif (start_pending && !first_remove) {\r\nbd_start = bdi_to_bd(ep, start_bdi);\r\nbd_start->offset[0] = cpu_to_le32(lower_32_bits(next_bd_dma));\r\nbd_start->offset[1] = cpu_to_le32(upper_32_bits(next_bd_dma));\r\nbd_start->offset[2] = 0x0;\r\nbd_start->offset[3] = cpu_to_le32(MARK_CHAIN_BD);\r\nbdc_dbg_bd_list(bdc, ep);\r\n} else if (end_pending) {\r\nret = bdc_ep_bla(bdc, ep, next_bd_dma);\r\nif (ret) {\r\ndev_err(bdc->dev, "error in ep_bla:%d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ep_set_halt(struct bdc_ep *ep, u32 value)\r\n{\r\nstruct bdc *bdc;\r\nint ret;\r\nbdc = ep->bdc;\r\ndev_dbg(bdc->dev, "%s ep:%s value=%d\n", __func__, ep->name, value);\r\nif (value) {\r\ndev_dbg(bdc->dev, "Halt\n");\r\nif (ep->ep_num == 1)\r\nbdc->ep0_state = WAIT_FOR_SETUP;\r\nret = bdc_ep_set_stall(bdc, ep->ep_num);\r\nif (ret)\r\ndev_err(bdc->dev, "failed to set STALL on %s\n",\r\nep->name);\r\nelse\r\nep->flags |= BDC_EP_STALL;\r\n} else {\r\ndev_dbg(bdc->dev, "Before Clear\n");\r\nret = bdc_ep_clear_stall(bdc, ep->ep_num);\r\nif (ret)\r\ndev_err(bdc->dev, "failed to clear STALL on %s\n",\r\nep->name);\r\nelse\r\nep->flags &= ~BDC_EP_STALL;\r\ndev_dbg(bdc->dev, "After Clear\n");\r\n}\r\nreturn ret;\r\n}\r\nvoid bdc_free_ep(struct bdc *bdc)\r\n{\r\nstruct bdc_ep *ep;\r\nu8 epnum;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nfor (epnum = 1; epnum < bdc->num_eps; epnum++) {\r\nep = bdc->bdc_ep_array[epnum];\r\nif (!ep)\r\ncontinue;\r\nif (ep->flags & BDC_EP_ENABLED)\r\nep_bd_list_free(ep, ep->bd_list.num_tabs);\r\nif (epnum != 1)\r\nlist_del(&ep->usb_ep.ep_list);\r\nkfree(ep);\r\n}\r\n}\r\nstatic int bdc_set_test_mode(struct bdc *bdc)\r\n{\r\nu32 usb2_pm;\r\nusb2_pm = bdc_readl(bdc->regs, BDC_USPPM2);\r\nusb2_pm &= ~BDC_PTC_MASK;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nswitch (bdc->test_mode) {\r\ncase TEST_J:\r\ncase TEST_K:\r\ncase TEST_SE0_NAK:\r\ncase TEST_PACKET:\r\ncase TEST_FORCE_EN:\r\nusb2_pm |= bdc->test_mode << 28;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(bdc->dev, "usb2_pm=%08x", usb2_pm);\r\nbdc_writel(bdc->regs, BDC_USPPM2, usb2_pm);\r\nreturn 0;\r\n}\r\nstatic void handle_xsr_succ_status(struct bdc *bdc, struct bdc_ep *ep,\r\nstruct bdc_sr *sreport)\r\n{\r\nint short_bdi, start_bdi, end_bdi, max_len_bds, chain_bds;\r\nstruct bd_list *bd_list = &ep->bd_list;\r\nint actual_length, length_short;\r\nstruct bd_transfer *bd_xfr;\r\nstruct bdc_bd *short_bd;\r\nstruct bdc_req *req;\r\nu64 deq_ptr_64 = 0;\r\nint status = 0;\r\nint sr_status;\r\nu32 tmp_32;\r\ndev_dbg(bdc->dev, "%s ep:%p\n", __func__, ep);\r\nbdc_dbg_srr(bdc, 0);\r\nif (ep->ignore_next_sr) {\r\nep->ignore_next_sr = false;\r\nreturn;\r\n}\r\nif (unlikely(list_empty(&ep->queue))) {\r\ndev_warn(bdc->dev, "xfr srr with no BD's queued\n");\r\nreturn;\r\n}\r\nreq = list_entry(ep->queue.next, struct bdc_req,\r\nqueue);\r\nbd_xfr = &req->bd_xfr;\r\nsr_status = XSF_STS(le32_to_cpu(sreport->offset[3]));\r\nif (sr_status == XSF_SHORT && bd_xfr->num_bds > 1) {\r\ntmp_32 = le32_to_cpu(sreport->offset[0]);\r\ndeq_ptr_64 = tmp_32;\r\ntmp_32 = le32_to_cpu(sreport->offset[1]);\r\ndeq_ptr_64 |= ((u64)tmp_32 << 32);\r\nshort_bdi = bd_add_to_bdi(ep, deq_ptr_64);\r\nif (unlikely(short_bdi < 0))\r\ndev_warn(bdc->dev, "bd doesn't exist?\n");\r\nstart_bdi = bd_xfr->start_bdi;\r\nif (start_bdi <= short_bdi) {\r\nmax_len_bds = short_bdi - start_bdi;\r\nif (max_len_bds <= bd_list->num_bds_table) {\r\nif (!(bdi_to_tbi(ep, start_bdi) ==\r\nbdi_to_tbi(ep, short_bdi)))\r\nmax_len_bds--;\r\n} else {\r\nchain_bds = max_len_bds/bd_list->num_bds_table;\r\nmax_len_bds -= chain_bds;\r\n}\r\n} else {\r\nchain_bds = (bd_list->max_bdi - start_bdi)/\r\nbd_list->num_bds_table;\r\nchain_bds += short_bdi/bd_list->num_bds_table;\r\nmax_len_bds = bd_list->max_bdi - start_bdi;\r\nmax_len_bds += short_bdi;\r\nmax_len_bds -= chain_bds;\r\n}\r\nend_bdi = find_end_bdi(ep, bd_xfr->next_hwd_bdi);\r\nif (!(end_bdi == short_bdi))\r\nep->ignore_next_sr = true;\r\nactual_length = max_len_bds * BD_MAX_BUFF_SIZE;\r\nshort_bd = bdi_to_bd(ep, short_bdi);\r\nlength_short = le32_to_cpu(short_bd->offset[2]) & 0x1FFFFF;\r\nlength_short -= SR_BD_LEN(le32_to_cpu(sreport->offset[2]));\r\nactual_length += length_short;\r\nreq->usb_req.actual = actual_length;\r\n} else {\r\nreq->usb_req.actual = req->usb_req.length -\r\nSR_BD_LEN(le32_to_cpu(sreport->offset[2]));\r\ndev_dbg(bdc->dev,\r\n"len=%d actual=%d bd_xfr->next_hwd_bdi:%d\n",\r\nreq->usb_req.length, req->usb_req.actual,\r\nbd_xfr->next_hwd_bdi);\r\n}\r\nep->bd_list.hwd_bdi = bd_xfr->next_hwd_bdi;\r\nif (req->usb_req.actual < req->usb_req.length) {\r\ndev_dbg(bdc->dev, "short xfr on %d\n", ep->ep_num);\r\nif (req->usb_req.short_not_ok)\r\nstatus = -EREMOTEIO;\r\n}\r\nbdc_req_complete(ep, bd_xfr->req, status);\r\n}\r\nvoid bdc_xsf_ep0_setup_recv(struct bdc *bdc, struct bdc_sr *sreport)\r\n{\r\nstruct usb_ctrlrequest *setup_pkt;\r\nu32 len;\r\ndev_dbg(bdc->dev,\r\n"%s ep0_state:%s\n",\r\n__func__, ep0_state_string[bdc->ep0_state]);\r\nsetup_pkt = &bdc->setup_pkt;\r\nmemcpy(setup_pkt, &sreport->offset[0], sizeof(*setup_pkt));\r\nlen = le16_to_cpu(setup_pkt->wLength);\r\nif (!len)\r\nbdc->ep0_state = WAIT_FOR_STATUS_START;\r\nelse\r\nbdc->ep0_state = WAIT_FOR_DATA_START;\r\ndev_dbg(bdc->dev,\r\n"%s exit ep0_state:%s\n",\r\n__func__, ep0_state_string[bdc->ep0_state]);\r\n}\r\nstatic void ep0_stall(struct bdc *bdc)\r\n{\r\nstruct bdc_ep *ep = bdc->bdc_ep_array[1];\r\nstruct bdc_req *req;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nbdc->delayed_status = false;\r\nep_set_halt(ep, 1);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct bdc_req,\r\nqueue);\r\nbdc_req_complete(ep, req, -ESHUTDOWN);\r\n}\r\n}\r\nstatic int ep0_set_address(struct bdc *bdc, struct usb_ctrlrequest *ctrl)\r\n{\r\nenum usb_device_state state = bdc->gadget.state;\r\nint ret = 0;\r\nu32 addr;\r\naddr = le16_to_cpu(ctrl->wValue);\r\ndev_dbg(bdc->dev,\r\n"%s addr:%d dev state:%d\n",\r\n__func__, addr, state);\r\nif (addr > 127)\r\nreturn -EINVAL;\r\nswitch (state) {\r\ncase USB_STATE_DEFAULT:\r\ncase USB_STATE_ADDRESS:\r\nret = bdc_address_device(bdc, addr);\r\nif (ret)\r\nreturn ret;\r\nif (addr)\r\nusb_gadget_set_state(&bdc->gadget, USB_STATE_ADDRESS);\r\nelse\r\nusb_gadget_set_state(&bdc->gadget, USB_STATE_DEFAULT);\r\nbdc->dev_addr = addr;\r\nbreak;\r\ndefault:\r\ndev_warn(bdc->dev,\r\n"SET Address in wrong device state %d\n",\r\nstate);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ep0_handle_feature_dev(struct bdc *bdc, u16 wValue,\r\nu16 wIndex, bool set)\r\n{\r\nenum usb_device_state state = bdc->gadget.state;\r\nu32 usppms = 0;\r\ndev_dbg(bdc->dev, "%s set:%d dev state:%d\n",\r\n__func__, set, state);\r\nswitch (wValue) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\ndev_dbg(bdc->dev, "USB_DEVICE_REMOTE_WAKEUP\n");\r\nif (set)\r\nbdc->devstatus |= REMOTE_WAKE_ENABLE;\r\nelse\r\nbdc->devstatus &= ~REMOTE_WAKE_ENABLE;\r\nbreak;\r\ncase USB_DEVICE_TEST_MODE:\r\ndev_dbg(bdc->dev, "USB_DEVICE_TEST_MODE\n");\r\nif ((wIndex & 0xFF) ||\r\n(bdc->gadget.speed != USB_SPEED_HIGH) || !set)\r\nreturn -EINVAL;\r\nbdc->test_mode = wIndex >> 8;\r\nbreak;\r\ncase USB_DEVICE_U1_ENABLE:\r\ndev_dbg(bdc->dev, "USB_DEVICE_U1_ENABLE\n");\r\nif (bdc->gadget.speed != USB_SPEED_SUPER ||\r\nstate != USB_STATE_CONFIGURED)\r\nreturn -EINVAL;\r\nusppms = bdc_readl(bdc->regs, BDC_USPPMS);\r\nif (set) {\r\nusppms &= ~BDC_U1T(BDC_U1T_MASK);\r\nusppms |= BDC_U1T(U1_TIMEOUT);\r\nusppms |= BDC_U1E | BDC_PORT_W1S;\r\nbdc->devstatus |= (1 << USB_DEV_STAT_U1_ENABLED);\r\n} else {\r\nusppms &= ~BDC_U1E;\r\nusppms |= BDC_PORT_W1S;\r\nbdc->devstatus &= ~(1 << USB_DEV_STAT_U1_ENABLED);\r\n}\r\nbdc_writel(bdc->regs, BDC_USPPMS, usppms);\r\nbreak;\r\ncase USB_DEVICE_U2_ENABLE:\r\ndev_dbg(bdc->dev, "USB_DEVICE_U2_ENABLE\n");\r\nif (bdc->gadget.speed != USB_SPEED_SUPER ||\r\nstate != USB_STATE_CONFIGURED)\r\nreturn -EINVAL;\r\nusppms = bdc_readl(bdc->regs, BDC_USPPMS);\r\nif (set) {\r\nusppms |= BDC_U2E;\r\nusppms |= BDC_U2A;\r\nbdc->devstatus |= (1 << USB_DEV_STAT_U2_ENABLED);\r\n} else {\r\nusppms &= ~BDC_U2E;\r\nusppms &= ~BDC_U2A;\r\nbdc->devstatus &= ~(1 << USB_DEV_STAT_U2_ENABLED);\r\n}\r\nbdc_writel(bdc->regs, BDC_USPPMS, usppms);\r\nbreak;\r\ncase USB_DEVICE_LTM_ENABLE:\r\ndev_dbg(bdc->dev, "USB_DEVICE_LTM_ENABLE?\n");\r\nif (bdc->gadget.speed != USB_SPEED_SUPER ||\r\nstate != USB_STATE_CONFIGURED)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\ndev_err(bdc->dev, "Unknown wValue:%d\n", wValue);\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ep0_handle_feature(struct bdc *bdc,\r\nstruct usb_ctrlrequest *setup_pkt, bool set)\r\n{\r\nenum usb_device_state state = bdc->gadget.state;\r\nstruct bdc_ep *ep;\r\nu16 wValue;\r\nu16 wIndex;\r\nint epnum;\r\nwValue = le16_to_cpu(setup_pkt->wValue);\r\nwIndex = le16_to_cpu(setup_pkt->wIndex);\r\ndev_dbg(bdc->dev,\r\n"%s wValue=%d wIndex=%d devstate=%08x speed=%d set=%d",\r\n__func__, wValue, wIndex, state,\r\nbdc->gadget.speed, set);\r\nswitch (setup_pkt->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nreturn ep0_handle_feature_dev(bdc, wValue, wIndex, set);\r\ncase USB_RECIP_INTERFACE:\r\ndev_dbg(bdc->dev, "USB_RECIP_INTERFACE\n");\r\nif (wValue != USB_INTRF_FUNC_SUSPEND)\r\nreturn -EINVAL;\r\nif (set) {\r\nif (wIndex & USB_INTRF_FUNC_SUSPEND_RW) {\r\ndev_dbg(bdc->dev, "SET REMOTE_WAKEUP\n");\r\nbdc->devstatus |= REMOTE_WAKE_ENABLE;\r\n} else {\r\ndev_dbg(bdc->dev, "CLEAR REMOTE_WAKEUP\n");\r\nbdc->devstatus &= ~REMOTE_WAKE_ENABLE;\r\n}\r\n}\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\ndev_dbg(bdc->dev, "USB_RECIP_ENDPOINT\n");\r\nif (wValue != USB_ENDPOINT_HALT)\r\nreturn -EINVAL;\r\nepnum = wIndex & USB_ENDPOINT_NUMBER_MASK;\r\nif (epnum) {\r\nif ((wIndex & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\r\nepnum = epnum * 2 + 1;\r\nelse\r\nepnum *= 2;\r\n} else {\r\nepnum = 1;\r\n}\r\nif (epnum == 1 && !set) {\r\ndev_dbg(bdc->dev, "ep0 stall already cleared\n");\r\nreturn 0;\r\n}\r\ndev_dbg(bdc->dev, "epnum=%d\n", epnum);\r\nep = bdc->bdc_ep_array[epnum];\r\nif (!ep)\r\nreturn -EINVAL;\r\nreturn ep_set_halt(ep, set);\r\ndefault:\r\ndev_err(bdc->dev, "Unknown recipient\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ep0_handle_status(struct bdc *bdc,\r\nstruct usb_ctrlrequest *setup_pkt)\r\n{\r\nenum usb_device_state state = bdc->gadget.state;\r\nstruct bdc_ep *ep;\r\nu16 usb_status = 0;\r\nu32 epnum;\r\nu16 wIndex;\r\nif (state == USB_STATE_DEFAULT)\r\nreturn -EINVAL;\r\nwIndex = le16_to_cpu(setup_pkt->wIndex);\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nusb_status = bdc->devstatus;\r\nswitch (setup_pkt->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\ndev_dbg(bdc->dev,\r\n"USB_RECIP_DEVICE devstatus:%08x\n",\r\nbdc->devstatus);\r\nif (bdc->gadget.speed == USB_SPEED_SUPER)\r\nusb_status &= ~REMOTE_WAKE_ENABLE;\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\ndev_dbg(bdc->dev, "USB_RECIP_INTERFACE\n");\r\nif (bdc->gadget.speed == USB_SPEED_SUPER) {\r\nif (bdc->devstatus & REMOTE_WAKE_ENABLE)\r\nusb_status |= REMOTE_WAKE_ENABLE;\r\n} else {\r\nusb_status = 0;\r\n}\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\ndev_dbg(bdc->dev, "USB_RECIP_ENDPOINT\n");\r\nepnum = wIndex & USB_ENDPOINT_NUMBER_MASK;\r\nif (epnum) {\r\nif ((wIndex & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\r\nepnum = epnum*2 + 1;\r\nelse\r\nepnum *= 2;\r\n} else {\r\nepnum = 1;\r\n}\r\nep = bdc->bdc_ep_array[epnum];\r\nif (!ep) {\r\ndev_err(bdc->dev, "ISSUE, GET_STATUS for invalid EP ?");\r\nreturn -EINVAL;\r\n}\r\nif (ep->flags & BDC_EP_STALL)\r\nusb_status |= 1 << USB_ENDPOINT_HALT;\r\nbreak;\r\ndefault:\r\ndev_err(bdc->dev, "Unknown recipient for get_status\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(bdc->dev, "usb_status=%08x\n", usb_status);\r\n*(__le16 *)bdc->ep0_response_buff = cpu_to_le16(usb_status);\r\nbdc->ep0_req.usb_req.length = 2;\r\nbdc->ep0_req.usb_req.buf = &bdc->ep0_response_buff;\r\nep0_queue_data_stage(bdc);\r\nreturn 0;\r\n}\r\nstatic void ep0_set_sel_cmpl(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\n}\r\nstatic int ep0_set_sel(struct bdc *bdc,\r\nstruct usb_ctrlrequest *setup_pkt)\r\n{\r\nstruct bdc_ep *ep;\r\nu16 wLength;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nwLength = le16_to_cpu(setup_pkt->wLength);\r\nif (unlikely(wLength != 6)) {\r\ndev_err(bdc->dev, "%s Wrong wLength:%d\n", __func__, wLength);\r\nreturn -EINVAL;\r\n}\r\nep = bdc->bdc_ep_array[1];\r\nbdc->ep0_req.ep = ep;\r\nbdc->ep0_req.usb_req.length = 6;\r\nbdc->ep0_req.usb_req.buf = bdc->ep0_response_buff;\r\nbdc->ep0_req.usb_req.complete = ep0_set_sel_cmpl;\r\nep0_queue_data_stage(bdc);\r\nreturn 0;\r\n}\r\nstatic int ep0_queue_zlp(struct bdc *bdc)\r\n{\r\nint ret;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nbdc->ep0_req.ep = bdc->bdc_ep_array[1];\r\nbdc->ep0_req.usb_req.length = 0;\r\nbdc->ep0_req.usb_req.complete = NULL;\r\nbdc->ep0_state = WAIT_FOR_DATA_START;\r\nret = bdc_queue_xfr(bdc, &bdc->ep0_req);\r\nif (ret) {\r\ndev_err(bdc->dev, "err queueing zlp :%d\n", ret);\r\nreturn ret;\r\n}\r\nbdc->ep0_state = WAIT_FOR_DATA_XMIT;\r\nreturn 0;\r\n}\r\nstatic int handle_control_request(struct bdc *bdc)\r\n{\r\nenum usb_device_state state = bdc->gadget.state;\r\nstruct usb_ctrlrequest *setup_pkt;\r\nint delegate_setup = 0;\r\nint ret = 0;\r\nint config = 0;\r\nsetup_pkt = &bdc->setup_pkt;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nif ((setup_pkt->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (setup_pkt->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\ndev_dbg(bdc->dev, "USB_REQ_SET_ADDRESS\n");\r\nret = ep0_set_address(bdc, setup_pkt);\r\nbdc->devstatus &= DEVSTATUS_CLEAR;\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\ndev_dbg(bdc->dev, "USB_REQ_SET_CONFIGURATION\n");\r\nif (state == USB_STATE_ADDRESS) {\r\nusb_gadget_set_state(&bdc->gadget,\r\nUSB_STATE_CONFIGURED);\r\n} else if (state == USB_STATE_CONFIGURED) {\r\nconfig = le16_to_cpu(setup_pkt->wValue);\r\nif (!config)\r\nusb_gadget_set_state(\r\n&bdc->gadget,\r\nUSB_STATE_ADDRESS);\r\n}\r\ndelegate_setup = 1;\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\ndev_dbg(bdc->dev, "USB_REQ_SET_FEATURE\n");\r\nret = ep0_handle_feature(bdc, setup_pkt, 1);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ndev_dbg(bdc->dev, "USB_REQ_CLEAR_FEATURE\n");\r\nret = ep0_handle_feature(bdc, setup_pkt, 0);\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\ndev_dbg(bdc->dev, "USB_REQ_GET_STATUS\n");\r\nret = ep0_handle_status(bdc, setup_pkt);\r\nbreak;\r\ncase USB_REQ_SET_SEL:\r\ndev_dbg(bdc->dev, "USB_REQ_SET_SEL\n");\r\nret = ep0_set_sel(bdc, setup_pkt);\r\nbreak;\r\ncase USB_REQ_SET_ISOCH_DELAY:\r\ndev_warn(bdc->dev,\r\n"USB_REQ_SET_ISOCH_DELAY not handled\n");\r\nret = 0;\r\nbreak;\r\ndefault:\r\ndelegate_setup = 1;\r\n}\r\n} else {\r\ndelegate_setup = 1;\r\n}\r\nif (delegate_setup) {\r\nspin_unlock(&bdc->lock);\r\nret = bdc->gadget_driver->setup(&bdc->gadget, setup_pkt);\r\nspin_lock(&bdc->lock);\r\n}\r\nreturn ret;\r\n}\r\nvoid bdc_xsf_ep0_data_start(struct bdc *bdc, struct bdc_sr *sreport)\r\n{\r\nstruct bdc_ep *ep;\r\nint ret = 0;\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nep = bdc->bdc_ep_array[1];\r\nif (ep->flags & BDC_EP_STALL) {\r\nret = ep_set_halt(ep, 0);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (bdc->ep0_state != WAIT_FOR_DATA_START)\r\ndev_warn(bdc->dev,\r\n"Data stage not expected ep0_state:%s\n",\r\nep0_state_string[bdc->ep0_state]);\r\nret = handle_control_request(bdc);\r\nif (ret == USB_GADGET_DELAYED_STATUS) {\r\nbdc->delayed_status = true;\r\nreturn;\r\n}\r\nif (!ret) {\r\nbdc->ep0_state = WAIT_FOR_DATA_XMIT;\r\ndev_dbg(bdc->dev,\r\n"ep0_state:%s", ep0_state_string[bdc->ep0_state]);\r\nreturn;\r\n}\r\nerr:\r\nep0_stall(bdc);\r\n}\r\nvoid bdc_xsf_ep0_status_start(struct bdc *bdc, struct bdc_sr *sreport)\r\n{\r\nstruct usb_ctrlrequest *setup_pkt;\r\nstruct bdc_ep *ep;\r\nint ret = 0;\r\ndev_dbg(bdc->dev,\r\n"%s ep0_state:%s",\r\n__func__, ep0_state_string[bdc->ep0_state]);\r\nep = bdc->bdc_ep_array[1];\r\nif (bdc->zlp_needed)\r\nbdc->zlp_needed = false;\r\nif (ep->flags & BDC_EP_STALL) {\r\nret = ep_set_halt(ep, 0);\r\nif (ret)\r\ngoto err;\r\n}\r\nif ((bdc->ep0_state != WAIT_FOR_STATUS_START) &&\r\n(bdc->ep0_state != WAIT_FOR_DATA_XMIT))\r\ndev_err(bdc->dev,\r\n"Status stage recv but ep0_state:%s\n",\r\nep0_state_string[bdc->ep0_state]);\r\nif (bdc->ep0_state == WAIT_FOR_DATA_XMIT) {\r\nbdc->ep0_state = STATUS_PENDING;\r\ndev_dbg(bdc->dev,\r\n"status started but data not transmitted yet\n");\r\nreturn;\r\n}\r\nsetup_pkt = &bdc->setup_pkt;\r\nif (!le16_to_cpu(setup_pkt->wLength)) {\r\nret = handle_control_request(bdc);\r\nif (ret == USB_GADGET_DELAYED_STATUS) {\r\nbdc->delayed_status = true;\r\nreturn;\r\n}\r\n}\r\nif (!ret) {\r\nep0_queue_status_stage(bdc);\r\nbdc->ep0_state = WAIT_FOR_STATUS_XMIT;\r\ndev_dbg(bdc->dev,\r\n"ep0_state:%s", ep0_state_string[bdc->ep0_state]);\r\nreturn;\r\n}\r\nerr:\r\nep0_stall(bdc);\r\n}\r\nstatic void ep0_xsf_complete(struct bdc *bdc, struct bdc_sr *sreport)\r\n{\r\ndev_dbg(bdc->dev, "%s\n", __func__);\r\nswitch (bdc->ep0_state) {\r\ncase WAIT_FOR_DATA_XMIT:\r\nbdc->ep0_state = WAIT_FOR_STATUS_START;\r\nbreak;\r\ncase WAIT_FOR_STATUS_XMIT:\r\nbdc->ep0_state = WAIT_FOR_SETUP;\r\nif (bdc->test_mode) {\r\nint ret;\r\ndev_dbg(bdc->dev, "test_mode:%d\n", bdc->test_mode);\r\nret = bdc_set_test_mode(bdc);\r\nif (ret < 0) {\r\ndev_err(bdc->dev, "Err in setting Test mode\n");\r\nreturn;\r\n}\r\nbdc->test_mode = 0;\r\n}\r\nbreak;\r\ncase STATUS_PENDING:\r\nbdc_xsf_ep0_status_start(bdc, sreport);\r\nbreak;\r\ndefault:\r\ndev_err(bdc->dev,\r\n"Unknown ep0_state:%s\n",\r\nep0_state_string[bdc->ep0_state]);\r\n}\r\n}\r\nvoid bdc_sr_xsf(struct bdc *bdc, struct bdc_sr *sreport)\r\n{\r\nstruct bdc_ep *ep;\r\nu32 sr_status;\r\nu8 ep_num;\r\nep_num = (le32_to_cpu(sreport->offset[3])>>4) & 0x1f;\r\nep = bdc->bdc_ep_array[ep_num];\r\nif (!ep || !(ep->flags & BDC_EP_ENABLED)) {\r\ndev_err(bdc->dev, "xsf for ep not enabled\n");\r\nreturn;\r\n}\r\nif (bdc->devstatus & FUNC_WAKE_ISSUED) {\r\nbdc->devstatus &= ~(FUNC_WAKE_ISSUED);\r\ndev_dbg(bdc->dev, "%s clearing FUNC_WAKE_ISSUED flag\n",\r\n__func__);\r\n}\r\nsr_status = XSF_STS(le32_to_cpu(sreport->offset[3]));\r\ndev_dbg_ratelimited(bdc->dev, "%s sr_status=%d ep:%s\n",\r\n__func__, sr_status, ep->name);\r\nswitch (sr_status) {\r\ncase XSF_SUCC:\r\ncase XSF_SHORT:\r\nhandle_xsr_succ_status(bdc, ep, sreport);\r\nif (ep_num == 1)\r\nep0_xsf_complete(bdc, sreport);\r\nbreak;\r\ncase XSF_SETUP_RECV:\r\ncase XSF_DATA_START:\r\ncase XSF_STATUS_START:\r\nif (ep_num != 1) {\r\ndev_err(bdc->dev,\r\n"ep0 related packets on non ep0 endpoint");\r\nreturn;\r\n}\r\nbdc->sr_xsf_ep0[sr_status - XSF_SETUP_RECV](bdc, sreport);\r\nbreak;\r\ncase XSF_BABB:\r\nif (ep_num == 1) {\r\ndev_dbg(bdc->dev, "Babble on ep0 zlp_need:%d\n",\r\nbdc->zlp_needed);\r\nif (bdc->zlp_needed) {\r\nep0_queue_zlp(bdc);\r\nreturn;\r\n}\r\n}\r\ndev_warn(bdc->dev, "Babble on ep not handled\n");\r\nbreak;\r\ndefault:\r\ndev_warn(bdc->dev, "sr status not handled:%x\n", sr_status);\r\nbreak;\r\n}\r\n}\r\nstatic int bdc_gadget_ep_queue(struct usb_ep *_ep,\r\nstruct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct bdc_req *req;\r\nunsigned long flags;\r\nstruct bdc_ep *ep;\r\nstruct bdc *bdc;\r\nint ret;\r\nif (!_ep || !_ep->desc)\r\nreturn -ESHUTDOWN;\r\nif (!_req || !_req->complete || !_req->buf)\r\nreturn -EINVAL;\r\nep = to_bdc_ep(_ep);\r\nreq = to_bdc_req(_req);\r\nbdc = ep->bdc;\r\ndev_dbg(bdc->dev, "%s ep:%p req:%p\n", __func__, ep, req);\r\ndev_dbg(bdc->dev, "queuing request %p to %s length %d zero:%d\n",\r\n_req, ep->name, _req->length, _req->zero);\r\nif (!ep->usb_ep.desc) {\r\ndev_warn(bdc->dev,\r\n"trying to queue req %p to disabled %s\n",\r\n_req, ep->name);\r\nreturn -ESHUTDOWN;\r\n}\r\nif (_req->length > MAX_XFR_LEN) {\r\ndev_warn(bdc->dev,\r\n"req length > supported MAX:%d requested:%d\n",\r\nMAX_XFR_LEN, _req->length);\r\nreturn -EOPNOTSUPP;\r\n}\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nif (ep == bdc->bdc_ep_array[1])\r\nret = ep0_queue(ep, req);\r\nelse\r\nret = ep_queue(ep, req);\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int bdc_gadget_ep_dequeue(struct usb_ep *_ep,\r\nstruct usb_request *_req)\r\n{\r\nstruct bdc_req *req;\r\nunsigned long flags;\r\nstruct bdc_ep *ep;\r\nstruct bdc *bdc;\r\nint ret;\r\nif (!_ep || !_req)\r\nreturn -EINVAL;\r\nep = to_bdc_ep(_ep);\r\nreq = to_bdc_req(_req);\r\nbdc = ep->bdc;\r\ndev_dbg(bdc->dev, "%s ep:%s req:%p\n", __func__, ep->name, req);\r\nbdc_dbg_bd_list(bdc, ep);\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->usb_req == _req)\r\nbreak;\r\n}\r\nif (&req->usb_req != _req) {\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\ndev_err(bdc->dev, "usb_req !=req n");\r\nreturn -EINVAL;\r\n}\r\nret = ep_dequeue(ep, req);\r\nif (ret) {\r\nret = -EOPNOTSUPP;\r\ngoto err;\r\n}\r\nbdc_req_complete(ep, req, -ECONNRESET);\r\nerr:\r\nbdc_dbg_bd_list(bdc, ep);\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int bdc_gadget_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nunsigned long flags;\r\nstruct bdc_ep *ep;\r\nstruct bdc *bdc;\r\nint ret;\r\nep = to_bdc_ep(_ep);\r\nbdc = ep->bdc;\r\ndev_dbg(bdc->dev, "%s ep:%s value=%d\n", __func__, ep->name, value);\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nif (usb_endpoint_xfer_isoc(ep->usb_ep.desc))\r\nret = -EINVAL;\r\nelse if (!list_empty(&ep->queue))\r\nret = -EAGAIN;\r\nelse\r\nret = ep_set_halt(ep, value);\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct usb_request *bdc_gadget_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct bdc_req *req;\r\nstruct bdc_ep *ep;\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nep = to_bdc_ep(_ep);\r\nreq->ep = ep;\r\nreq->epnum = ep->ep_num;\r\nreq->usb_req.dma = DMA_ADDR_INVALID;\r\ndev_dbg(ep->bdc->dev, "%s ep:%s req:%p\n", __func__, ep->name, req);\r\nreturn &req->usb_req;\r\n}\r\nstatic void bdc_gadget_free_request(struct usb_ep *_ep,\r\nstruct usb_request *_req)\r\n{\r\nstruct bdc_req *req;\r\nreq = to_bdc_req(_req);\r\nkfree(req);\r\n}\r\nstatic int bdc_gadget_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nunsigned long flags;\r\nstruct bdc_ep *ep;\r\nstruct bdc *bdc;\r\nint ret;\r\nif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\r\npr_debug("bdc_gadget_ep_enable invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nif (!desc->wMaxPacketSize) {\r\npr_debug("bdc_gadget_ep_enable missing wMaxPacketSize\n");\r\nreturn -EINVAL;\r\n}\r\nep = to_bdc_ep(_ep);\r\nbdc = ep->bdc;\r\nif (ep == bdc->bdc_ep_array[1])\r\nreturn -EINVAL;\r\nif (!bdc->gadget_driver\r\n|| bdc->gadget.speed == USB_SPEED_UNKNOWN) {\r\nreturn -ESHUTDOWN;\r\n}\r\ndev_dbg(bdc->dev, "%s Enabling %s\n", __func__, ep->name);\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nep->desc = desc;\r\nep->comp_desc = _ep->comp_desc;\r\nret = bdc_ep_enable(ep);\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int bdc_gadget_ep_disable(struct usb_ep *_ep)\r\n{\r\nunsigned long flags;\r\nstruct bdc_ep *ep;\r\nstruct bdc *bdc;\r\nint ret;\r\nif (!_ep) {\r\npr_debug("bdc: invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nep = to_bdc_ep(_ep);\r\nbdc = ep->bdc;\r\nif (ep == bdc->bdc_ep_array[1]) {\r\ndev_warn(bdc->dev, "%s called for ep0\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(bdc->dev,\r\n"%s() ep:%s ep->flags:%08x\n",\r\n__func__, ep->name, ep->flags);\r\nif (!(ep->flags & BDC_EP_ENABLED)) {\r\ndev_warn(bdc->dev, "%s is already disabled\n", ep->name);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&bdc->lock, flags);\r\nret = bdc_ep_disable(ep);\r\nspin_unlock_irqrestore(&bdc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int init_ep(struct bdc *bdc, u32 epnum, u32 dir)\r\n{\r\nstruct bdc_ep *ep;\r\ndev_dbg(bdc->dev, "%s epnum=%d dir=%d\n", __func__, epnum, dir);\r\nep = kzalloc(sizeof(*ep), GFP_KERNEL);\r\nif (!ep)\r\nreturn -ENOMEM;\r\nep->bdc = bdc;\r\nep->dir = dir;\r\nif (dir)\r\nep->usb_ep.caps.dir_in = true;\r\nelse\r\nep->usb_ep.caps.dir_out = true;\r\nif (epnum == 1) {\r\nep->ep_num = 1;\r\nbdc->bdc_ep_array[ep->ep_num] = ep;\r\nsnprintf(ep->name, sizeof(ep->name), "ep%d", epnum - 1);\r\nusb_ep_set_maxpacket_limit(&ep->usb_ep, EP0_MAX_PKT_SIZE);\r\nep->usb_ep.caps.type_control = true;\r\nep->comp_desc = NULL;\r\nbdc->gadget.ep0 = &ep->usb_ep;\r\n} else {\r\nif (dir)\r\nep->ep_num = epnum * 2 - 1;\r\nelse\r\nep->ep_num = epnum * 2 - 2;\r\nbdc->bdc_ep_array[ep->ep_num] = ep;\r\nsnprintf(ep->name, sizeof(ep->name), "ep%d%s", epnum - 1,\r\ndir & 1 ? "in" : "out");\r\nusb_ep_set_maxpacket_limit(&ep->usb_ep, 1024);\r\nep->usb_ep.caps.type_iso = true;\r\nep->usb_ep.caps.type_bulk = true;\r\nep->usb_ep.caps.type_int = true;\r\nep->usb_ep.max_streams = 0;\r\nlist_add_tail(&ep->usb_ep.ep_list, &bdc->gadget.ep_list);\r\n}\r\nep->usb_ep.ops = &bdc_gadget_ep_ops;\r\nep->usb_ep.name = ep->name;\r\nep->flags = 0;\r\nep->ignore_next_sr = false;\r\ndev_dbg(bdc->dev, "ep=%p ep->usb_ep.name=%s epnum=%d ep->epnum=%d\n",\r\nep, ep->usb_ep.name, epnum, ep->ep_num);\r\nINIT_LIST_HEAD(&ep->queue);\r\nreturn 0;\r\n}\r\nint bdc_init_ep(struct bdc *bdc)\r\n{\r\nu8 epnum;\r\nint ret;\r\ndev_dbg(bdc->dev, "%s()\n", __func__);\r\nINIT_LIST_HEAD(&bdc->gadget.ep_list);\r\nret = init_ep(bdc, 1, 0);\r\nif (ret) {\r\ndev_err(bdc->dev, "init ep ep0 fail %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (epnum = 2; epnum <= bdc->num_eps / 2; epnum++) {\r\nret = init_ep(bdc, epnum, 0);\r\nif (ret) {\r\ndev_err(bdc->dev,\r\n"init ep failed for:%d error: %d\n",\r\nepnum, ret);\r\nreturn ret;\r\n}\r\nret = init_ep(bdc, epnum, 1);\r\nif (ret) {\r\ndev_err(bdc->dev,\r\n"init ep failed for:%d error: %d\n",\r\nepnum, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
