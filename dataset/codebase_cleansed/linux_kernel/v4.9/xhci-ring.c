dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg,\r\nunion xhci_trb *trb)\r\n{\r\nunsigned long segment_offset;\r\nif (!seg || !trb || trb < seg->trbs)\r\nreturn 0;\r\nsegment_offset = trb - seg->trbs;\r\nif (segment_offset >= TRBS_PER_SEGMENT)\r\nreturn 0;\r\nreturn seg->dma + (segment_offset * sizeof(*trb));\r\n}\r\nstatic bool trb_is_link(union xhci_trb *trb)\r\n{\r\nreturn TRB_TYPE_LINK_LE32(trb->link.control);\r\n}\r\nstatic bool last_trb_on_seg(struct xhci_segment *seg, union xhci_trb *trb)\r\n{\r\nreturn trb == &seg->trbs[TRBS_PER_SEGMENT - 1];\r\n}\r\nstatic bool last_trb_on_ring(struct xhci_ring *ring,\r\nstruct xhci_segment *seg, union xhci_trb *trb)\r\n{\r\nreturn last_trb_on_seg(seg, trb) && (seg->next == ring->first_seg);\r\n}\r\nstatic bool link_trb_toggles_cycle(union xhci_trb *trb)\r\n{\r\nreturn le32_to_cpu(trb->link.control) & LINK_TOGGLE;\r\n}\r\nstatic void next_trb(struct xhci_hcd *xhci,\r\nstruct xhci_ring *ring,\r\nstruct xhci_segment **seg,\r\nunion xhci_trb **trb)\r\n{\r\nif (trb_is_link(*trb)) {\r\n*seg = (*seg)->next;\r\n*trb = ((*seg)->trbs);\r\n} else {\r\n(*trb)++;\r\n}\r\n}\r\nstatic void inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring)\r\n{\r\nring->deq_updates++;\r\nif (ring->type == TYPE_EVENT) {\r\nif (!last_trb_on_seg(ring->deq_seg, ring->dequeue)) {\r\nring->dequeue++;\r\nreturn;\r\n}\r\nif (last_trb_on_ring(ring, ring->deq_seg, ring->dequeue))\r\nring->cycle_state ^= 1;\r\nring->deq_seg = ring->deq_seg->next;\r\nring->dequeue = ring->deq_seg->trbs;\r\nreturn;\r\n}\r\nif (!trb_is_link(ring->dequeue)) {\r\nring->dequeue++;\r\nring->num_trbs_free++;\r\n}\r\nwhile (trb_is_link(ring->dequeue)) {\r\nring->deq_seg = ring->deq_seg->next;\r\nring->dequeue = ring->deq_seg->trbs;\r\n}\r\nreturn;\r\n}\r\nstatic void inc_enq(struct xhci_hcd *xhci, struct xhci_ring *ring,\r\nbool more_trbs_coming)\r\n{\r\nu32 chain;\r\nunion xhci_trb *next;\r\nchain = le32_to_cpu(ring->enqueue->generic.field[3]) & TRB_CHAIN;\r\nif (!trb_is_link(ring->enqueue))\r\nring->num_trbs_free--;\r\nnext = ++(ring->enqueue);\r\nring->enq_updates++;\r\nwhile (trb_is_link(next)) {\r\nif (!chain && !more_trbs_coming)\r\nbreak;\r\nif (!(ring->type == TYPE_ISOC &&\r\n(xhci->quirks & XHCI_AMD_0x96_HOST)) &&\r\n!xhci_link_trb_quirk(xhci)) {\r\nnext->link.control &= cpu_to_le32(~TRB_CHAIN);\r\nnext->link.control |= cpu_to_le32(chain);\r\n}\r\nwmb();\r\nnext->link.control ^= cpu_to_le32(TRB_CYCLE);\r\nif (link_trb_toggles_cycle(next))\r\nring->cycle_state ^= 1;\r\nring->enq_seg = ring->enq_seg->next;\r\nring->enqueue = ring->enq_seg->trbs;\r\nnext = ring->enqueue;\r\n}\r\n}\r\nstatic inline int room_on_ring(struct xhci_hcd *xhci, struct xhci_ring *ring,\r\nunsigned int num_trbs)\r\n{\r\nint num_trbs_in_deq_seg;\r\nif (ring->num_trbs_free < num_trbs)\r\nreturn 0;\r\nif (ring->type != TYPE_COMMAND && ring->type != TYPE_EVENT) {\r\nnum_trbs_in_deq_seg = ring->dequeue - ring->deq_seg->trbs;\r\nif (ring->num_trbs_free < num_trbs + num_trbs_in_deq_seg)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid xhci_ring_cmd_db(struct xhci_hcd *xhci)\r\n{\r\nif (!(xhci->cmd_ring_state & CMD_RING_STATE_RUNNING))\r\nreturn;\r\nxhci_dbg(xhci, "// Ding dong!\n");\r\nwritel(DB_VALUE_HOST, &xhci->dba->doorbell[0]);\r\nreadl(&xhci->dba->doorbell[0]);\r\n}\r\nstatic int xhci_abort_cmd_ring(struct xhci_hcd *xhci)\r\n{\r\nu64 temp_64;\r\nint ret;\r\nxhci_dbg(xhci, "Abort command ring\n");\r\ntemp_64 = xhci_read_64(xhci, &xhci->op_regs->cmd_ring);\r\nxhci->cmd_ring_state = CMD_RING_STATE_ABORTED;\r\nmod_timer(&xhci->cmd_timer, jiffies + (2 * XHCI_CMD_DEFAULT_TIMEOUT));\r\nxhci_write_64(xhci, temp_64 | CMD_RING_ABORT,\r\n&xhci->op_regs->cmd_ring);\r\nret = xhci_handshake(&xhci->op_regs->cmd_ring,\r\nCMD_RING_RUNNING, 0, 5 * 1000 * 1000);\r\nif (ret < 0) {\r\nxhci_write_64(xhci, temp_64 | CMD_RING_ABORT,\r\n&xhci->op_regs->cmd_ring);\r\nudelay(1000);\r\nret = xhci_handshake(&xhci->op_regs->cmd_ring,\r\nCMD_RING_RUNNING, 0, 3 * 1000 * 1000);\r\nif (ret == 0)\r\nreturn 0;\r\nxhci_err(xhci, "Stopped the command ring failed, "\r\n"maybe the host is dead\n");\r\ndel_timer(&xhci->cmd_timer);\r\nxhci->xhc_state |= XHCI_STATE_DYING;\r\nxhci_quiesce(xhci);\r\nxhci_halt(xhci);\r\nreturn -ESHUTDOWN;\r\n}\r\nreturn 0;\r\n}\r\nvoid xhci_ring_ep_doorbell(struct xhci_hcd *xhci,\r\nunsigned int slot_id,\r\nunsigned int ep_index,\r\nunsigned int stream_id)\r\n{\r\n__le32 __iomem *db_addr = &xhci->dba->doorbell[slot_id];\r\nstruct xhci_virt_ep *ep = &xhci->devs[slot_id]->eps[ep_index];\r\nunsigned int ep_state = ep->ep_state;\r\nif ((ep_state & EP_HALT_PENDING) || (ep_state & SET_DEQ_PENDING) ||\r\n(ep_state & EP_HALTED))\r\nreturn;\r\nwritel(DB_VALUE(ep_index, stream_id), db_addr);\r\n}\r\nstatic void ring_doorbell_for_active_rings(struct xhci_hcd *xhci,\r\nunsigned int slot_id,\r\nunsigned int ep_index)\r\n{\r\nunsigned int stream_id;\r\nstruct xhci_virt_ep *ep;\r\nep = &xhci->devs[slot_id]->eps[ep_index];\r\nif (!(ep->ep_state & EP_HAS_STREAMS)) {\r\nif (ep->ring && !(list_empty(&ep->ring->td_list)))\r\nxhci_ring_ep_doorbell(xhci, slot_id, ep_index, 0);\r\nreturn;\r\n}\r\nfor (stream_id = 1; stream_id < ep->stream_info->num_streams;\r\nstream_id++) {\r\nstruct xhci_stream_info *stream_info = ep->stream_info;\r\nif (!list_empty(&stream_info->stream_rings[stream_id]->td_list))\r\nxhci_ring_ep_doorbell(xhci, slot_id, ep_index,\r\nstream_id);\r\n}\r\n}\r\nstruct xhci_ring *xhci_triad_to_transfer_ring(struct xhci_hcd *xhci,\r\nunsigned int slot_id, unsigned int ep_index,\r\nunsigned int stream_id)\r\n{\r\nstruct xhci_virt_ep *ep;\r\nep = &xhci->devs[slot_id]->eps[ep_index];\r\nif (!(ep->ep_state & EP_HAS_STREAMS))\r\nreturn ep->ring;\r\nif (stream_id == 0) {\r\nxhci_warn(xhci,\r\n"WARN: Slot ID %u, ep index %u has streams, "\r\n"but URB has no stream ID.\n",\r\nslot_id, ep_index);\r\nreturn NULL;\r\n}\r\nif (stream_id < ep->stream_info->num_streams)\r\nreturn ep->stream_info->stream_rings[stream_id];\r\nxhci_warn(xhci,\r\n"WARN: Slot ID %u, ep index %u has "\r\n"stream IDs 1 to %u allocated, "\r\n"but stream ID %u is requested.\n",\r\nslot_id, ep_index,\r\nep->stream_info->num_streams - 1,\r\nstream_id);\r\nreturn NULL;\r\n}\r\nvoid xhci_find_new_dequeue_state(struct xhci_hcd *xhci,\r\nunsigned int slot_id, unsigned int ep_index,\r\nunsigned int stream_id, struct xhci_td *cur_td,\r\nstruct xhci_dequeue_state *state)\r\n{\r\nstruct xhci_virt_device *dev = xhci->devs[slot_id];\r\nstruct xhci_virt_ep *ep = &dev->eps[ep_index];\r\nstruct xhci_ring *ep_ring;\r\nstruct xhci_segment *new_seg;\r\nunion xhci_trb *new_deq;\r\ndma_addr_t addr;\r\nu64 hw_dequeue;\r\nbool cycle_found = false;\r\nbool td_last_trb_found = false;\r\nep_ring = xhci_triad_to_transfer_ring(xhci, slot_id,\r\nep_index, stream_id);\r\nif (!ep_ring) {\r\nxhci_warn(xhci, "WARN can't find new dequeue state "\r\n"for invalid stream ID %u.\n",\r\nstream_id);\r\nreturn;\r\n}\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Finding endpoint context");\r\nif (ep->ep_state & EP_HAS_STREAMS) {\r\nstruct xhci_stream_ctx *ctx =\r\n&ep->stream_info->stream_ctx_array[stream_id];\r\nhw_dequeue = le64_to_cpu(ctx->stream_ring);\r\n} else {\r\nstruct xhci_ep_ctx *ep_ctx\r\n= xhci_get_ep_ctx(xhci, dev->out_ctx, ep_index);\r\nhw_dequeue = le64_to_cpu(ep_ctx->deq);\r\n}\r\nnew_seg = ep_ring->deq_seg;\r\nnew_deq = ep_ring->dequeue;\r\nstate->new_cycle_state = hw_dequeue & 0x1;\r\ndo {\r\nif (!cycle_found && xhci_trb_virt_to_dma(new_seg, new_deq)\r\n== (dma_addr_t)(hw_dequeue & ~0xf)) {\r\ncycle_found = true;\r\nif (td_last_trb_found)\r\nbreak;\r\n}\r\nif (new_deq == cur_td->last_trb)\r\ntd_last_trb_found = true;\r\nif (cycle_found &&\r\nTRB_TYPE_LINK_LE32(new_deq->generic.field[3]) &&\r\nnew_deq->generic.field[3] & cpu_to_le32(LINK_TOGGLE))\r\nstate->new_cycle_state ^= 0x1;\r\nnext_trb(xhci, ep_ring, &new_seg, &new_deq);\r\nif (new_deq == ep->ring->dequeue) {\r\nxhci_err(xhci, "Error: Failed finding new dequeue state\n");\r\nstate->new_deq_seg = NULL;\r\nstate->new_deq_ptr = NULL;\r\nreturn;\r\n}\r\n} while (!cycle_found || !td_last_trb_found);\r\nstate->new_deq_seg = new_seg;\r\nstate->new_deq_ptr = new_deq;\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Cycle state = 0x%x", state->new_cycle_state);\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"New dequeue segment = %p (virtual)",\r\nstate->new_deq_seg);\r\naddr = xhci_trb_virt_to_dma(state->new_deq_seg, state->new_deq_ptr);\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"New dequeue pointer = 0x%llx (DMA)",\r\n(unsigned long long) addr);\r\n}\r\nstatic void td_to_noop(struct xhci_hcd *xhci, struct xhci_ring *ep_ring,\r\nstruct xhci_td *cur_td, bool flip_cycle)\r\n{\r\nstruct xhci_segment *cur_seg;\r\nunion xhci_trb *cur_trb;\r\nfor (cur_seg = cur_td->start_seg, cur_trb = cur_td->first_trb;\r\ntrue;\r\nnext_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {\r\nif (TRB_TYPE_LINK_LE32(cur_trb->generic.field[3])) {\r\ncur_trb->generic.field[3] &= cpu_to_le32(~TRB_CHAIN);\r\nif (flip_cycle)\r\ncur_trb->generic.field[3] ^=\r\ncpu_to_le32(TRB_CYCLE);\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Cancel (unchain) link TRB");\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Address = %p (0x%llx dma); "\r\n"in seg %p (0x%llx dma)",\r\ncur_trb,\r\n(unsigned long long)xhci_trb_virt_to_dma(cur_seg, cur_trb),\r\ncur_seg,\r\n(unsigned long long)cur_seg->dma);\r\n} else {\r\ncur_trb->generic.field[0] = 0;\r\ncur_trb->generic.field[1] = 0;\r\ncur_trb->generic.field[2] = 0;\r\ncur_trb->generic.field[3] &= cpu_to_le32(TRB_CYCLE);\r\nif (flip_cycle && cur_trb != cur_td->first_trb &&\r\ncur_trb != cur_td->last_trb)\r\ncur_trb->generic.field[3] ^=\r\ncpu_to_le32(TRB_CYCLE);\r\ncur_trb->generic.field[3] |= cpu_to_le32(\r\nTRB_TYPE(TRB_TR_NOOP));\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"TRB to noop at offset 0x%llx",\r\n(unsigned long long)\r\nxhci_trb_virt_to_dma(cur_seg, cur_trb));\r\n}\r\nif (cur_trb == cur_td->last_trb)\r\nbreak;\r\n}\r\n}\r\nstatic void xhci_stop_watchdog_timer_in_irq(struct xhci_hcd *xhci,\r\nstruct xhci_virt_ep *ep)\r\n{\r\nep->ep_state &= ~EP_HALT_PENDING;\r\nif (del_timer(&ep->stop_cmd_timer))\r\nep->stop_cmds_pending--;\r\n}\r\nstatic void xhci_giveback_urb_in_irq(struct xhci_hcd *xhci,\r\nstruct xhci_td *cur_td, int status)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct urb *urb;\r\nstruct urb_priv *urb_priv;\r\nurb = cur_td->urb;\r\nurb_priv = urb->hcpriv;\r\nurb_priv->td_cnt++;\r\nhcd = bus_to_hcd(urb->dev->bus);\r\nif (urb_priv->td_cnt == urb_priv->length) {\r\nif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\nxhci_to_hcd(xhci)->self.bandwidth_isoc_reqs--;\r\nif (xhci_to_hcd(xhci)->self.bandwidth_isoc_reqs == 0) {\r\nif (xhci->quirks & XHCI_AMD_PLL_FIX)\r\nusb_amd_quirk_pll_enable();\r\n}\r\n}\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock(&xhci->lock);\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\nxhci_urb_free_priv(urb_priv);\r\nspin_lock(&xhci->lock);\r\n}\r\n}\r\nvoid xhci_unmap_td_bounce_buffer(struct xhci_hcd *xhci, struct xhci_ring *ring,\r\nstruct xhci_td *td)\r\n{\r\nstruct device *dev = xhci_to_hcd(xhci)->self.controller;\r\nstruct xhci_segment *seg = td->bounce_seg;\r\nstruct urb *urb = td->urb;\r\nif (!seg || !urb)\r\nreturn;\r\nif (usb_urb_dir_out(urb)) {\r\ndma_unmap_single(dev, seg->bounce_dma, ring->bounce_buf_len,\r\nDMA_TO_DEVICE);\r\nreturn;\r\n}\r\nsg_pcopy_from_buffer(urb->sg, urb->num_mapped_sgs, seg->bounce_buf,\r\nseg->bounce_len, seg->bounce_offs);\r\ndma_unmap_single(dev, seg->bounce_dma, ring->bounce_buf_len,\r\nDMA_FROM_DEVICE);\r\nseg->bounce_len = 0;\r\nseg->bounce_offs = 0;\r\n}\r\nstatic void xhci_handle_cmd_stop_ep(struct xhci_hcd *xhci, int slot_id,\r\nunion xhci_trb *trb, struct xhci_event_cmd *event)\r\n{\r\nunsigned int ep_index;\r\nstruct xhci_ring *ep_ring;\r\nstruct xhci_virt_ep *ep;\r\nstruct list_head *entry;\r\nstruct xhci_td *cur_td = NULL;\r\nstruct xhci_td *last_unlinked_td;\r\nstruct xhci_dequeue_state deq_state;\r\nif (unlikely(TRB_TO_SUSPEND_PORT(le32_to_cpu(trb->generic.field[3])))) {\r\nif (!xhci->devs[slot_id])\r\nxhci_warn(xhci, "Stop endpoint command "\r\n"completion for disabled slot %u\n",\r\nslot_id);\r\nreturn;\r\n}\r\nmemset(&deq_state, 0, sizeof(deq_state));\r\nep_index = TRB_TO_EP_INDEX(le32_to_cpu(trb->generic.field[3]));\r\nep = &xhci->devs[slot_id]->eps[ep_index];\r\nif (list_empty(&ep->cancelled_td_list)) {\r\nxhci_stop_watchdog_timer_in_irq(xhci, ep);\r\nep->stopped_td = NULL;\r\nring_doorbell_for_active_rings(xhci, slot_id, ep_index);\r\nreturn;\r\n}\r\nlist_for_each(entry, &ep->cancelled_td_list) {\r\ncur_td = list_entry(entry, struct xhci_td, cancelled_td_list);\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Removing canceled TD starting at 0x%llx (dma).",\r\n(unsigned long long)xhci_trb_virt_to_dma(\r\ncur_td->start_seg, cur_td->first_trb));\r\nep_ring = xhci_urb_to_transfer_ring(xhci, cur_td->urb);\r\nif (!ep_ring) {\r\nxhci_warn(xhci, "WARN Cancelled URB %p "\r\n"has invalid stream ID %u.\n",\r\ncur_td->urb,\r\ncur_td->urb->stream_id);\r\ngoto remove_finished_td;\r\n}\r\nif (cur_td == ep->stopped_td)\r\nxhci_find_new_dequeue_state(xhci, slot_id, ep_index,\r\ncur_td->urb->stream_id,\r\ncur_td, &deq_state);\r\nelse\r\ntd_to_noop(xhci, ep_ring, cur_td, false);\r\nremove_finished_td:\r\nlist_del_init(&cur_td->td_list);\r\n}\r\nlast_unlinked_td = cur_td;\r\nxhci_stop_watchdog_timer_in_irq(xhci, ep);\r\nif (deq_state.new_deq_ptr && deq_state.new_deq_seg) {\r\nxhci_queue_new_dequeue_state(xhci, slot_id, ep_index,\r\nep->stopped_td->urb->stream_id, &deq_state);\r\nxhci_ring_cmd_db(xhci);\r\n} else {\r\nring_doorbell_for_active_rings(xhci, slot_id, ep_index);\r\n}\r\nep->stopped_td = NULL;\r\ndo {\r\ncur_td = list_entry(ep->cancelled_td_list.next,\r\nstruct xhci_td, cancelled_td_list);\r\nlist_del_init(&cur_td->cancelled_td_list);\r\nep_ring = xhci_urb_to_transfer_ring(xhci, cur_td->urb);\r\nif (ep_ring && cur_td->bounce_seg)\r\nxhci_unmap_td_bounce_buffer(xhci, ep_ring, cur_td);\r\nxhci_giveback_urb_in_irq(xhci, cur_td, 0);\r\nif (xhci->xhc_state & XHCI_STATE_DYING)\r\nreturn;\r\n} while (cur_td != last_unlinked_td);\r\n}\r\nstatic void xhci_kill_ring_urbs(struct xhci_hcd *xhci, struct xhci_ring *ring)\r\n{\r\nstruct xhci_td *cur_td;\r\nwhile (!list_empty(&ring->td_list)) {\r\ncur_td = list_first_entry(&ring->td_list,\r\nstruct xhci_td, td_list);\r\nlist_del_init(&cur_td->td_list);\r\nif (!list_empty(&cur_td->cancelled_td_list))\r\nlist_del_init(&cur_td->cancelled_td_list);\r\nif (cur_td->bounce_seg)\r\nxhci_unmap_td_bounce_buffer(xhci, ring, cur_td);\r\nxhci_giveback_urb_in_irq(xhci, cur_td, -ESHUTDOWN);\r\n}\r\n}\r\nstatic void xhci_kill_endpoint_urbs(struct xhci_hcd *xhci,\r\nint slot_id, int ep_index)\r\n{\r\nstruct xhci_td *cur_td;\r\nstruct xhci_virt_ep *ep;\r\nstruct xhci_ring *ring;\r\nep = &xhci->devs[slot_id]->eps[ep_index];\r\nif ((ep->ep_state & EP_HAS_STREAMS) ||\r\n(ep->ep_state & EP_GETTING_NO_STREAMS)) {\r\nint stream_id;\r\nfor (stream_id = 0; stream_id < ep->stream_info->num_streams;\r\nstream_id++) {\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Killing URBs for slot ID %u, ep index %u, stream %u",\r\nslot_id, ep_index, stream_id + 1);\r\nxhci_kill_ring_urbs(xhci,\r\nep->stream_info->stream_rings[stream_id]);\r\n}\r\n} else {\r\nring = ep->ring;\r\nif (!ring)\r\nreturn;\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Killing URBs for slot ID %u, ep index %u",\r\nslot_id, ep_index);\r\nxhci_kill_ring_urbs(xhci, ring);\r\n}\r\nwhile (!list_empty(&ep->cancelled_td_list)) {\r\ncur_td = list_first_entry(&ep->cancelled_td_list,\r\nstruct xhci_td, cancelled_td_list);\r\nlist_del_init(&cur_td->cancelled_td_list);\r\nxhci_giveback_urb_in_irq(xhci, cur_td, -ESHUTDOWN);\r\n}\r\n}\r\nvoid xhci_stop_endpoint_command_watchdog(unsigned long arg)\r\n{\r\nstruct xhci_hcd *xhci;\r\nstruct xhci_virt_ep *ep;\r\nint ret, i, j;\r\nunsigned long flags;\r\nep = (struct xhci_virt_ep *) arg;\r\nxhci = ep->xhci;\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nep->stop_cmds_pending--;\r\nif (xhci->xhc_state & XHCI_STATE_REMOVING) {\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn;\r\n}\r\nif (xhci->xhc_state & XHCI_STATE_DYING) {\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Stop EP timer ran, but another timer marked "\r\n"xHCI as DYING, exiting.");\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn;\r\n}\r\nif (!(ep->stop_cmds_pending == 0 && (ep->ep_state & EP_HALT_PENDING))) {\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Stop EP timer ran, but no command pending, "\r\n"exiting.");\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn;\r\n}\r\nxhci_warn(xhci, "xHCI host not responding to stop endpoint command.\n");\r\nxhci_warn(xhci, "Assuming host is dying, halting host.\n");\r\nxhci->xhc_state |= XHCI_STATE_DYING;\r\nxhci_quiesce(xhci);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nret = xhci_halt(xhci);\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nif (ret < 0) {\r\nxhci_warn(xhci, "Non-responsive xHCI host is not halting.\n");\r\nxhci_warn(xhci, "Completing active URBs anyway.\n");\r\n}\r\nfor (i = 0; i < MAX_HC_SLOTS; i++) {\r\nif (!xhci->devs[i])\r\ncontinue;\r\nfor (j = 0; j < 31; j++)\r\nxhci_kill_endpoint_urbs(xhci, i, j);\r\n}\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Calling usb_hc_died()");\r\nusb_hc_died(xhci_to_hcd(xhci));\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"xHCI host controller is dead.");\r\n}\r\nstatic void update_ring_for_set_deq_completion(struct xhci_hcd *xhci,\r\nstruct xhci_virt_device *dev,\r\nstruct xhci_ring *ep_ring,\r\nunsigned int ep_index)\r\n{\r\nunion xhci_trb *dequeue_temp;\r\nint num_trbs_free_temp;\r\nbool revert = false;\r\nnum_trbs_free_temp = ep_ring->num_trbs_free;\r\ndequeue_temp = ep_ring->dequeue;\r\nif (trb_is_link(ep_ring->dequeue)) {\r\nep_ring->deq_seg = ep_ring->deq_seg->next;\r\nep_ring->dequeue = ep_ring->deq_seg->trbs;\r\n}\r\nwhile (ep_ring->dequeue != dev->eps[ep_index].queued_deq_ptr) {\r\nep_ring->num_trbs_free++;\r\nep_ring->dequeue++;\r\nif (trb_is_link(ep_ring->dequeue)) {\r\nif (ep_ring->dequeue ==\r\ndev->eps[ep_index].queued_deq_ptr)\r\nbreak;\r\nep_ring->deq_seg = ep_ring->deq_seg->next;\r\nep_ring->dequeue = ep_ring->deq_seg->trbs;\r\n}\r\nif (ep_ring->dequeue == dequeue_temp) {\r\nrevert = true;\r\nbreak;\r\n}\r\n}\r\nif (revert) {\r\nxhci_dbg(xhci, "Unable to find new dequeue pointer\n");\r\nep_ring->num_trbs_free = num_trbs_free_temp;\r\n}\r\n}\r\nstatic void xhci_handle_cmd_set_deq(struct xhci_hcd *xhci, int slot_id,\r\nunion xhci_trb *trb, u32 cmd_comp_code)\r\n{\r\nunsigned int ep_index;\r\nunsigned int stream_id;\r\nstruct xhci_ring *ep_ring;\r\nstruct xhci_virt_device *dev;\r\nstruct xhci_virt_ep *ep;\r\nstruct xhci_ep_ctx *ep_ctx;\r\nstruct xhci_slot_ctx *slot_ctx;\r\nep_index = TRB_TO_EP_INDEX(le32_to_cpu(trb->generic.field[3]));\r\nstream_id = TRB_TO_STREAM_ID(le32_to_cpu(trb->generic.field[2]));\r\ndev = xhci->devs[slot_id];\r\nep = &dev->eps[ep_index];\r\nep_ring = xhci_stream_id_to_ring(dev, ep_index, stream_id);\r\nif (!ep_ring) {\r\nxhci_warn(xhci, "WARN Set TR deq ptr command for freed stream ID %u\n",\r\nstream_id);\r\ngoto cleanup;\r\n}\r\nep_ctx = xhci_get_ep_ctx(xhci, dev->out_ctx, ep_index);\r\nslot_ctx = xhci_get_slot_ctx(xhci, dev->out_ctx);\r\nif (cmd_comp_code != COMP_SUCCESS) {\r\nunsigned int ep_state;\r\nunsigned int slot_state;\r\nswitch (cmd_comp_code) {\r\ncase COMP_TRB_ERR:\r\nxhci_warn(xhci, "WARN Set TR Deq Ptr cmd invalid because of stream ID configuration\n");\r\nbreak;\r\ncase COMP_CTX_STATE:\r\nxhci_warn(xhci, "WARN Set TR Deq Ptr cmd failed due to incorrect slot or ep state.\n");\r\nep_state = le32_to_cpu(ep_ctx->ep_info);\r\nep_state &= EP_STATE_MASK;\r\nslot_state = le32_to_cpu(slot_ctx->dev_state);\r\nslot_state = GET_SLOT_STATE(slot_state);\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Slot state = %u, EP state = %u",\r\nslot_state, ep_state);\r\nbreak;\r\ncase COMP_EBADSLT:\r\nxhci_warn(xhci, "WARN Set TR Deq Ptr cmd failed because slot %u was not enabled.\n",\r\nslot_id);\r\nbreak;\r\ndefault:\r\nxhci_warn(xhci, "WARN Set TR Deq Ptr cmd with unknown completion code of %u.\n",\r\ncmd_comp_code);\r\nbreak;\r\n}\r\n} else {\r\nu64 deq;\r\nif (ep->ep_state & EP_HAS_STREAMS) {\r\nstruct xhci_stream_ctx *ctx =\r\n&ep->stream_info->stream_ctx_array[stream_id];\r\ndeq = le64_to_cpu(ctx->stream_ring) & SCTX_DEQ_MASK;\r\n} else {\r\ndeq = le64_to_cpu(ep_ctx->deq) & ~EP_CTX_CYCLE_MASK;\r\n}\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Successful Set TR Deq Ptr cmd, deq = @%08llx", deq);\r\nif (xhci_trb_virt_to_dma(ep->queued_deq_seg,\r\nep->queued_deq_ptr) == deq) {\r\nupdate_ring_for_set_deq_completion(xhci, dev,\r\nep_ring, ep_index);\r\n} else {\r\nxhci_warn(xhci, "Mismatch between completed Set TR Deq Ptr command & xHCI internal state.\n");\r\nxhci_warn(xhci, "ep deq seg = %p, deq ptr = %p\n",\r\nep->queued_deq_seg, ep->queued_deq_ptr);\r\n}\r\n}\r\ncleanup:\r\ndev->eps[ep_index].ep_state &= ~SET_DEQ_PENDING;\r\ndev->eps[ep_index].queued_deq_seg = NULL;\r\ndev->eps[ep_index].queued_deq_ptr = NULL;\r\nring_doorbell_for_active_rings(xhci, slot_id, ep_index);\r\n}\r\nstatic void xhci_handle_cmd_reset_ep(struct xhci_hcd *xhci, int slot_id,\r\nunion xhci_trb *trb, u32 cmd_comp_code)\r\n{\r\nunsigned int ep_index;\r\nep_index = TRB_TO_EP_INDEX(le32_to_cpu(trb->generic.field[3]));\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_reset_ep,\r\n"Ignoring reset ep completion code of %u", cmd_comp_code);\r\nif (xhci->quirks & XHCI_RESET_EP_QUIRK) {\r\nstruct xhci_command *command;\r\ncommand = xhci_alloc_command(xhci, false, false, GFP_ATOMIC);\r\nif (!command) {\r\nxhci_warn(xhci, "WARN Cannot submit cfg ep: ENOMEM\n");\r\nreturn;\r\n}\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\r\n"Queueing configure endpoint command");\r\nxhci_queue_configure_endpoint(xhci, command,\r\nxhci->devs[slot_id]->in_ctx->dma, slot_id,\r\nfalse);\r\nxhci_ring_cmd_db(xhci);\r\n} else {\r\nxhci->devs[slot_id]->eps[ep_index].ep_state &= ~EP_HALTED;\r\n}\r\n}\r\nstatic void xhci_handle_cmd_enable_slot(struct xhci_hcd *xhci, int slot_id,\r\nu32 cmd_comp_code)\r\n{\r\nif (cmd_comp_code == COMP_SUCCESS)\r\nxhci->slot_id = slot_id;\r\nelse\r\nxhci->slot_id = 0;\r\n}\r\nstatic void xhci_handle_cmd_disable_slot(struct xhci_hcd *xhci, int slot_id)\r\n{\r\nstruct xhci_virt_device *virt_dev;\r\nvirt_dev = xhci->devs[slot_id];\r\nif (!virt_dev)\r\nreturn;\r\nif (xhci->quirks & XHCI_EP_LIMIT_QUIRK)\r\nxhci_free_device_endpoint_resources(xhci, virt_dev, true);\r\nxhci_free_virt_device(xhci, slot_id);\r\n}\r\nstatic void xhci_handle_cmd_config_ep(struct xhci_hcd *xhci, int slot_id,\r\nstruct xhci_event_cmd *event, u32 cmd_comp_code)\r\n{\r\nstruct xhci_virt_device *virt_dev;\r\nstruct xhci_input_control_ctx *ctrl_ctx;\r\nunsigned int ep_index;\r\nunsigned int ep_state;\r\nu32 add_flags, drop_flags;\r\nvirt_dev = xhci->devs[slot_id];\r\nctrl_ctx = xhci_get_input_control_ctx(virt_dev->in_ctx);\r\nif (!ctrl_ctx) {\r\nxhci_warn(xhci, "Could not get input context, bad type.\n");\r\nreturn;\r\n}\r\nadd_flags = le32_to_cpu(ctrl_ctx->add_flags);\r\ndrop_flags = le32_to_cpu(ctrl_ctx->drop_flags);\r\nep_index = xhci_last_valid_endpoint(add_flags) - 1;\r\nif (xhci->quirks & XHCI_RESET_EP_QUIRK &&\r\nep_index != (unsigned int) -1 &&\r\nadd_flags - SLOT_FLAG == drop_flags) {\r\nep_state = virt_dev->eps[ep_index].ep_state;\r\nif (!(ep_state & EP_HALTED))\r\nreturn;\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\r\n"Completed config ep cmd - "\r\n"last ep index = %d, state = %d",\r\nep_index, ep_state);\r\nvirt_dev->eps[ep_index].ep_state &= ~EP_HALTED;\r\nring_doorbell_for_active_rings(xhci, slot_id, ep_index);\r\nreturn;\r\n}\r\nreturn;\r\n}\r\nstatic void xhci_handle_cmd_reset_dev(struct xhci_hcd *xhci, int slot_id,\r\nstruct xhci_event_cmd *event)\r\n{\r\nxhci_dbg(xhci, "Completed reset device command.\n");\r\nif (!xhci->devs[slot_id])\r\nxhci_warn(xhci, "Reset device command completion "\r\n"for disabled slot %u\n", slot_id);\r\n}\r\nstatic void xhci_handle_cmd_nec_get_fw(struct xhci_hcd *xhci,\r\nstruct xhci_event_cmd *event)\r\n{\r\nif (!(xhci->quirks & XHCI_NEC_HOST)) {\r\nxhci->error_bitmask |= 1 << 6;\r\nreturn;\r\n}\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\r\n"NEC firmware version %2x.%02x",\r\nNEC_FW_MAJOR(le32_to_cpu(event->status)),\r\nNEC_FW_MINOR(le32_to_cpu(event->status)));\r\n}\r\nstatic void xhci_complete_del_and_free_cmd(struct xhci_command *cmd, u32 status)\r\n{\r\nlist_del(&cmd->cmd_list);\r\nif (cmd->completion) {\r\ncmd->status = status;\r\ncomplete(cmd->completion);\r\n} else {\r\nkfree(cmd);\r\n}\r\n}\r\nvoid xhci_cleanup_command_queue(struct xhci_hcd *xhci)\r\n{\r\nstruct xhci_command *cur_cmd, *tmp_cmd;\r\nlist_for_each_entry_safe(cur_cmd, tmp_cmd, &xhci->cmd_list, cmd_list)\r\nxhci_complete_del_and_free_cmd(cur_cmd, COMP_CMD_ABORT);\r\n}\r\nstatic void xhci_handle_stopped_cmd_ring(struct xhci_hcd *xhci,\r\nstruct xhci_command *cur_cmd)\r\n{\r\nstruct xhci_command *i_cmd, *tmp_cmd;\r\nu32 cycle_state;\r\nlist_for_each_entry_safe(i_cmd, tmp_cmd, &xhci->cmd_list,\r\ncmd_list) {\r\nif (i_cmd->status != COMP_CMD_ABORT)\r\ncontinue;\r\ni_cmd->status = COMP_CMD_STOP;\r\nxhci_dbg(xhci, "Turn aborted command %p to no-op\n",\r\ni_cmd->command_trb);\r\ncycle_state = le32_to_cpu(\r\ni_cmd->command_trb->generic.field[3]) & TRB_CYCLE;\r\ni_cmd->command_trb->generic.field[0] = 0;\r\ni_cmd->command_trb->generic.field[1] = 0;\r\ni_cmd->command_trb->generic.field[2] = 0;\r\ni_cmd->command_trb->generic.field[3] = cpu_to_le32(\r\nTRB_TYPE(TRB_CMD_NOOP) | cycle_state);\r\n}\r\nxhci->cmd_ring_state = CMD_RING_STATE_RUNNING;\r\nif ((xhci->cmd_ring->dequeue != xhci->cmd_ring->enqueue) &&\r\n!(xhci->xhc_state & XHCI_STATE_DYING)) {\r\nxhci->current_cmd = cur_cmd;\r\nmod_timer(&xhci->cmd_timer, jiffies + XHCI_CMD_DEFAULT_TIMEOUT);\r\nxhci_ring_cmd_db(xhci);\r\n}\r\nreturn;\r\n}\r\nvoid xhci_handle_command_timeout(unsigned long data)\r\n{\r\nstruct xhci_hcd *xhci;\r\nint ret;\r\nunsigned long flags;\r\nu64 hw_ring_state;\r\nbool second_timeout = false;\r\nxhci = (struct xhci_hcd *) data;\r\nspin_lock_irqsave(&xhci->lock, flags);\r\nif (xhci->current_cmd) {\r\nif (xhci->current_cmd->status == COMP_CMD_ABORT)\r\nsecond_timeout = true;\r\nxhci->current_cmd->status = COMP_CMD_ABORT;\r\n}\r\nhw_ring_state = xhci_read_64(xhci, &xhci->op_regs->cmd_ring);\r\nif ((xhci->cmd_ring_state & CMD_RING_STATE_RUNNING) &&\r\n(hw_ring_state & CMD_RING_RUNNING)) {\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nxhci_dbg(xhci, "Command timeout\n");\r\nret = xhci_abort_cmd_ring(xhci);\r\nif (unlikely(ret == -ESHUTDOWN)) {\r\nxhci_err(xhci, "Abort command ring failed\n");\r\nxhci_cleanup_command_queue(xhci);\r\nusb_hc_died(xhci_to_hcd(xhci)->primary_hcd);\r\nxhci_dbg(xhci, "xHCI host controller is dead.\n");\r\n}\r\nreturn;\r\n}\r\nif (second_timeout || xhci->xhc_state & XHCI_STATE_REMOVING) {\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nxhci_dbg(xhci, "command timed out twice, ring start fail?\n");\r\nxhci_cleanup_command_queue(xhci);\r\nreturn;\r\n}\r\nxhci_dbg(xhci, "Command timeout on stopped ring\n");\r\nxhci_handle_stopped_cmd_ring(xhci, xhci->current_cmd);\r\nspin_unlock_irqrestore(&xhci->lock, flags);\r\nreturn;\r\n}\r\nstatic void handle_cmd_completion(struct xhci_hcd *xhci,\r\nstruct xhci_event_cmd *event)\r\n{\r\nint slot_id = TRB_TO_SLOT_ID(le32_to_cpu(event->flags));\r\nu64 cmd_dma;\r\ndma_addr_t cmd_dequeue_dma;\r\nu32 cmd_comp_code;\r\nunion xhci_trb *cmd_trb;\r\nstruct xhci_command *cmd;\r\nu32 cmd_type;\r\ncmd_dma = le64_to_cpu(event->cmd_trb);\r\ncmd_trb = xhci->cmd_ring->dequeue;\r\ncmd_dequeue_dma = xhci_trb_virt_to_dma(xhci->cmd_ring->deq_seg,\r\ncmd_trb);\r\nif (cmd_dequeue_dma == 0) {\r\nxhci->error_bitmask |= 1 << 4;\r\nreturn;\r\n}\r\nif (cmd_dma != (u64) cmd_dequeue_dma) {\r\nxhci->error_bitmask |= 1 << 5;\r\nreturn;\r\n}\r\ncmd = list_entry(xhci->cmd_list.next, struct xhci_command, cmd_list);\r\ndel_timer(&xhci->cmd_timer);\r\ntrace_xhci_cmd_completion(cmd_trb, (struct xhci_generic_trb *) event);\r\ncmd_comp_code = GET_COMP_CODE(le32_to_cpu(event->status));\r\nif (cmd_comp_code == COMP_CMD_STOP) {\r\nxhci_handle_stopped_cmd_ring(xhci, cmd);\r\nreturn;\r\n}\r\nif (cmd->command_trb != xhci->cmd_ring->dequeue) {\r\nxhci_err(xhci,\r\n"Command completion event does not match command\n");\r\nreturn;\r\n}\r\nif (cmd_comp_code == COMP_CMD_ABORT) {\r\nxhci->cmd_ring_state = CMD_RING_STATE_STOPPED;\r\nif (cmd->status == COMP_CMD_ABORT)\r\ngoto event_handled;\r\n}\r\ncmd_type = TRB_FIELD_TO_TYPE(le32_to_cpu(cmd_trb->generic.field[3]));\r\nswitch (cmd_type) {\r\ncase TRB_ENABLE_SLOT:\r\nxhci_handle_cmd_enable_slot(xhci, slot_id, cmd_comp_code);\r\nbreak;\r\ncase TRB_DISABLE_SLOT:\r\nxhci_handle_cmd_disable_slot(xhci, slot_id);\r\nbreak;\r\ncase TRB_CONFIG_EP:\r\nif (!cmd->completion)\r\nxhci_handle_cmd_config_ep(xhci, slot_id, event,\r\ncmd_comp_code);\r\nbreak;\r\ncase TRB_EVAL_CONTEXT:\r\nbreak;\r\ncase TRB_ADDR_DEV:\r\nbreak;\r\ncase TRB_STOP_RING:\r\nWARN_ON(slot_id != TRB_TO_SLOT_ID(\r\nle32_to_cpu(cmd_trb->generic.field[3])));\r\nxhci_handle_cmd_stop_ep(xhci, slot_id, cmd_trb, event);\r\nbreak;\r\ncase TRB_SET_DEQ:\r\nWARN_ON(slot_id != TRB_TO_SLOT_ID(\r\nle32_to_cpu(cmd_trb->generic.field[3])));\r\nxhci_handle_cmd_set_deq(xhci, slot_id, cmd_trb, cmd_comp_code);\r\nbreak;\r\ncase TRB_CMD_NOOP:\r\nif (cmd->status == COMP_CMD_STOP)\r\ncmd_comp_code = COMP_CMD_STOP;\r\nbreak;\r\ncase TRB_RESET_EP:\r\nWARN_ON(slot_id != TRB_TO_SLOT_ID(\r\nle32_to_cpu(cmd_trb->generic.field[3])));\r\nxhci_handle_cmd_reset_ep(xhci, slot_id, cmd_trb, cmd_comp_code);\r\nbreak;\r\ncase TRB_RESET_DEV:\r\nslot_id = TRB_TO_SLOT_ID(\r\nle32_to_cpu(cmd_trb->generic.field[3]));\r\nxhci_handle_cmd_reset_dev(xhci, slot_id, event);\r\nbreak;\r\ncase TRB_NEC_GET_FW:\r\nxhci_handle_cmd_nec_get_fw(xhci, event);\r\nbreak;\r\ndefault:\r\nxhci->error_bitmask |= 1 << 6;\r\nbreak;\r\n}\r\nif (cmd->cmd_list.next != &xhci->cmd_list) {\r\nxhci->current_cmd = list_entry(cmd->cmd_list.next,\r\nstruct xhci_command, cmd_list);\r\nmod_timer(&xhci->cmd_timer, jiffies + XHCI_CMD_DEFAULT_TIMEOUT);\r\n}\r\nevent_handled:\r\nxhci_complete_del_and_free_cmd(cmd, cmd_comp_code);\r\ninc_deq(xhci, xhci->cmd_ring);\r\n}\r\nstatic void handle_vendor_event(struct xhci_hcd *xhci,\r\nunion xhci_trb *event)\r\n{\r\nu32 trb_type;\r\ntrb_type = TRB_FIELD_TO_TYPE(le32_to_cpu(event->generic.field[3]));\r\nxhci_dbg(xhci, "Vendor specific event TRB type = %u\n", trb_type);\r\nif (trb_type == TRB_NEC_CMD_COMP && (xhci->quirks & XHCI_NEC_HOST))\r\nhandle_cmd_completion(xhci, &event->event_cmd);\r\n}\r\nstatic unsigned int find_faked_portnum_from_hw_portnum(struct usb_hcd *hcd,\r\nstruct xhci_hcd *xhci, u32 port_id)\r\n{\r\nunsigned int i;\r\nunsigned int num_similar_speed_ports = 0;\r\nfor (i = 0; i < (port_id - 1); i++) {\r\nu8 port_speed = xhci->port_array[i];\r\nif (port_speed == 0 || port_speed == DUPLICATE_ENTRY)\r\ncontinue;\r\nif ((port_speed == 0x03) == (hcd->speed >= HCD_USB3))\r\nnum_similar_speed_ports++;\r\n}\r\nreturn num_similar_speed_ports;\r\n}\r\nstatic void handle_device_notification(struct xhci_hcd *xhci,\r\nunion xhci_trb *event)\r\n{\r\nu32 slot_id;\r\nstruct usb_device *udev;\r\nslot_id = TRB_TO_SLOT_ID(le32_to_cpu(event->generic.field[3]));\r\nif (!xhci->devs[slot_id]) {\r\nxhci_warn(xhci, "Device Notification event for "\r\n"unused slot %u\n", slot_id);\r\nreturn;\r\n}\r\nxhci_dbg(xhci, "Device Wake Notification event for slot ID %u\n",\r\nslot_id);\r\nudev = xhci->devs[slot_id]->udev;\r\nif (udev && udev->parent)\r\nusb_wakeup_notification(udev->parent, udev->portnum);\r\n}\r\nstatic void handle_port_status(struct xhci_hcd *xhci,\r\nunion xhci_trb *event)\r\n{\r\nstruct usb_hcd *hcd;\r\nu32 port_id;\r\nu32 temp, temp1;\r\nint max_ports;\r\nint slot_id;\r\nunsigned int faked_port_index;\r\nu8 major_revision;\r\nstruct xhci_bus_state *bus_state;\r\n__le32 __iomem **port_array;\r\nbool bogus_port_status = false;\r\nif (GET_COMP_CODE(le32_to_cpu(event->generic.field[2])) != COMP_SUCCESS) {\r\nxhci_warn(xhci, "WARN: xHC returned failed port status event\n");\r\nxhci->error_bitmask |= 1 << 8;\r\n}\r\nport_id = GET_PORT_ID(le32_to_cpu(event->generic.field[0]));\r\nxhci_dbg(xhci, "Port Status Change Event for port %d\n", port_id);\r\nmax_ports = HCS_MAX_PORTS(xhci->hcs_params1);\r\nif ((port_id <= 0) || (port_id > max_ports)) {\r\nxhci_warn(xhci, "Invalid port id %d\n", port_id);\r\ninc_deq(xhci, xhci->event_ring);\r\nreturn;\r\n}\r\nmajor_revision = xhci->port_array[port_id - 1];\r\nhcd = xhci_to_hcd(xhci);\r\nif ((major_revision == 0x03) != (hcd->speed >= HCD_USB3))\r\nhcd = xhci->shared_hcd;\r\nif (major_revision == 0) {\r\nxhci_warn(xhci, "Event for port %u not in "\r\n"Extended Capabilities, ignoring.\n",\r\nport_id);\r\nbogus_port_status = true;\r\ngoto cleanup;\r\n}\r\nif (major_revision == DUPLICATE_ENTRY) {\r\nxhci_warn(xhci, "Event for port %u duplicated in"\r\n"Extended Capabilities, ignoring.\n",\r\nport_id);\r\nbogus_port_status = true;\r\ngoto cleanup;\r\n}\r\nbus_state = &xhci->bus_state[hcd_index(hcd)];\r\nif (hcd->speed >= HCD_USB3)\r\nport_array = xhci->usb3_ports;\r\nelse\r\nport_array = xhci->usb2_ports;\r\nfaked_port_index = find_faked_portnum_from_hw_portnum(hcd, xhci,\r\nport_id);\r\ntemp = readl(port_array[faked_port_index]);\r\nif (hcd->state == HC_STATE_SUSPENDED) {\r\nxhci_dbg(xhci, "resume root hub\n");\r\nusb_hcd_resume_root_hub(hcd);\r\n}\r\nif (hcd->speed >= HCD_USB3 && (temp & PORT_PLS_MASK) == XDEV_INACTIVE)\r\nbus_state->port_remote_wakeup &= ~(1 << faked_port_index);\r\nif ((temp & PORT_PLC) && (temp & PORT_PLS_MASK) == XDEV_RESUME) {\r\nxhci_dbg(xhci, "port resume event for port %d\n", port_id);\r\ntemp1 = readl(&xhci->op_regs->command);\r\nif (!(temp1 & CMD_RUN)) {\r\nxhci_warn(xhci, "xHC is not running.\n");\r\ngoto cleanup;\r\n}\r\nif (DEV_SUPERSPEED_ANY(temp)) {\r\nxhci_dbg(xhci, "remote wake SS port %d\n", port_id);\r\nbus_state->port_remote_wakeup |= 1 << faked_port_index;\r\nxhci_test_and_clear_bit(xhci, port_array,\r\nfaked_port_index, PORT_PLC);\r\nxhci_set_link_state(xhci, port_array, faked_port_index,\r\nXDEV_U0);\r\nbogus_port_status = true;\r\ngoto cleanup;\r\n} else if (!test_bit(faked_port_index,\r\n&bus_state->resuming_ports)) {\r\nxhci_dbg(xhci, "resume HS port %d\n", port_id);\r\nbus_state->resume_done[faked_port_index] = jiffies +\r\nmsecs_to_jiffies(USB_RESUME_TIMEOUT);\r\nset_bit(faked_port_index, &bus_state->resuming_ports);\r\nmod_timer(&hcd->rh_timer,\r\nbus_state->resume_done[faked_port_index]);\r\n}\r\n}\r\nif ((temp & PORT_PLC) && (temp & PORT_PLS_MASK) == XDEV_U0 &&\r\nDEV_SUPERSPEED_ANY(temp)) {\r\nxhci_dbg(xhci, "resume SS port %d finished\n", port_id);\r\nslot_id = xhci_find_slot_id_by_port(hcd, xhci,\r\nfaked_port_index + 1);\r\nif (slot_id && xhci->devs[slot_id])\r\nxhci_ring_device(xhci, slot_id);\r\nif (bus_state->port_remote_wakeup & (1 << faked_port_index)) {\r\nbus_state->port_remote_wakeup &=\r\n~(1 << faked_port_index);\r\nxhci_test_and_clear_bit(xhci, port_array,\r\nfaked_port_index, PORT_PLC);\r\nusb_wakeup_notification(hcd->self.root_hub,\r\nfaked_port_index + 1);\r\nbogus_port_status = true;\r\ngoto cleanup;\r\n}\r\n}\r\nif (!DEV_SUPERSPEED_ANY(temp) &&\r\ntest_and_clear_bit(faked_port_index,\r\n&bus_state->rexit_ports)) {\r\ncomplete(&bus_state->rexit_done[faked_port_index]);\r\nbogus_port_status = true;\r\ngoto cleanup;\r\n}\r\nif (hcd->speed < HCD_USB3)\r\nxhci_test_and_clear_bit(xhci, port_array, faked_port_index,\r\nPORT_PLC);\r\ncleanup:\r\ninc_deq(xhci, xhci->event_ring);\r\nif (bogus_port_status)\r\nreturn;\r\nxhci_dbg(xhci, "%s: starting port polling.\n", __func__);\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nspin_unlock(&xhci->lock);\r\nusb_hcd_poll_rh_status(hcd);\r\nspin_lock(&xhci->lock);\r\n}\r\nstruct xhci_segment *trb_in_td(struct xhci_hcd *xhci,\r\nstruct xhci_segment *start_seg,\r\nunion xhci_trb *start_trb,\r\nunion xhci_trb *end_trb,\r\ndma_addr_t suspect_dma,\r\nbool debug)\r\n{\r\ndma_addr_t start_dma;\r\ndma_addr_t end_seg_dma;\r\ndma_addr_t end_trb_dma;\r\nstruct xhci_segment *cur_seg;\r\nstart_dma = xhci_trb_virt_to_dma(start_seg, start_trb);\r\ncur_seg = start_seg;\r\ndo {\r\nif (start_dma == 0)\r\nreturn NULL;\r\nend_seg_dma = xhci_trb_virt_to_dma(cur_seg,\r\n&cur_seg->trbs[TRBS_PER_SEGMENT - 1]);\r\nend_trb_dma = xhci_trb_virt_to_dma(cur_seg, end_trb);\r\nif (debug)\r\nxhci_warn(xhci,\r\n"Looking for event-dma %016llx trb-start %016llx trb-end %016llx seg-start %016llx seg-end %016llx\n",\r\n(unsigned long long)suspect_dma,\r\n(unsigned long long)start_dma,\r\n(unsigned long long)end_trb_dma,\r\n(unsigned long long)cur_seg->dma,\r\n(unsigned long long)end_seg_dma);\r\nif (end_trb_dma > 0) {\r\nif (start_dma <= end_trb_dma) {\r\nif (suspect_dma >= start_dma && suspect_dma <= end_trb_dma)\r\nreturn cur_seg;\r\n} else {\r\nif ((suspect_dma >= start_dma &&\r\nsuspect_dma <= end_seg_dma) ||\r\n(suspect_dma >= cur_seg->dma &&\r\nsuspect_dma <= end_trb_dma))\r\nreturn cur_seg;\r\n}\r\nreturn NULL;\r\n} else {\r\nif (suspect_dma >= start_dma && suspect_dma <= end_seg_dma)\r\nreturn cur_seg;\r\n}\r\ncur_seg = cur_seg->next;\r\nstart_dma = xhci_trb_virt_to_dma(cur_seg, &cur_seg->trbs[0]);\r\n} while (cur_seg != start_seg);\r\nreturn NULL;\r\n}\r\nstatic void xhci_cleanup_halted_endpoint(struct xhci_hcd *xhci,\r\nunsigned int slot_id, unsigned int ep_index,\r\nunsigned int stream_id,\r\nstruct xhci_td *td, union xhci_trb *event_trb)\r\n{\r\nstruct xhci_virt_ep *ep = &xhci->devs[slot_id]->eps[ep_index];\r\nstruct xhci_command *command;\r\ncommand = xhci_alloc_command(xhci, false, false, GFP_ATOMIC);\r\nif (!command)\r\nreturn;\r\nep->ep_state |= EP_HALTED;\r\nep->stopped_stream = stream_id;\r\nxhci_queue_reset_ep(xhci, command, slot_id, ep_index);\r\nxhci_cleanup_stalled_ring(xhci, ep_index, td);\r\nep->stopped_stream = 0;\r\nxhci_ring_cmd_db(xhci);\r\n}\r\nstatic int xhci_requires_manual_halt_cleanup(struct xhci_hcd *xhci,\r\nstruct xhci_ep_ctx *ep_ctx,\r\nunsigned int trb_comp_code)\r\n{\r\nif (trb_comp_code == COMP_TX_ERR ||\r\ntrb_comp_code == COMP_BABBLE ||\r\ntrb_comp_code == COMP_SPLIT_ERR)\r\nif ((ep_ctx->ep_info & cpu_to_le32(EP_STATE_MASK)) ==\r\ncpu_to_le32(EP_STATE_HALTED))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code)\r\n{\r\nif (trb_comp_code >= 224 && trb_comp_code <= 255) {\r\nxhci_dbg(xhci, "Vendor defined info completion code %u\n",\r\ntrb_comp_code);\r\nxhci_dbg(xhci, "Treating code as success.\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int finish_td(struct xhci_hcd *xhci, struct xhci_td *td,\r\nunion xhci_trb *event_trb, struct xhci_transfer_event *event,\r\nstruct xhci_virt_ep *ep, int *status, bool skip)\r\n{\r\nstruct xhci_virt_device *xdev;\r\nstruct xhci_ring *ep_ring;\r\nunsigned int slot_id;\r\nint ep_index;\r\nstruct urb *urb = NULL;\r\nstruct xhci_ep_ctx *ep_ctx;\r\nint ret = 0;\r\nstruct urb_priv *urb_priv;\r\nu32 trb_comp_code;\r\nslot_id = TRB_TO_SLOT_ID(le32_to_cpu(event->flags));\r\nxdev = xhci->devs[slot_id];\r\nep_index = TRB_TO_EP_ID(le32_to_cpu(event->flags)) - 1;\r\nep_ring = xhci_dma_to_transfer_ring(ep, le64_to_cpu(event->buffer));\r\nep_ctx = xhci_get_ep_ctx(xhci, xdev->out_ctx, ep_index);\r\ntrb_comp_code = GET_COMP_CODE(le32_to_cpu(event->transfer_len));\r\nif (skip)\r\ngoto td_cleanup;\r\nif (trb_comp_code == COMP_STOP_INVAL ||\r\ntrb_comp_code == COMP_STOP ||\r\ntrb_comp_code == COMP_STOP_SHORT) {\r\nep->stopped_td = td;\r\nreturn 0;\r\n}\r\nif (trb_comp_code == COMP_STALL ||\r\nxhci_requires_manual_halt_cleanup(xhci, ep_ctx,\r\ntrb_comp_code)) {\r\nxhci_cleanup_halted_endpoint(xhci, slot_id, ep_index,\r\nep_ring->stream_id, td, event_trb);\r\n} else {\r\nwhile (ep_ring->dequeue != td->last_trb)\r\ninc_deq(xhci, ep_ring);\r\ninc_deq(xhci, ep_ring);\r\n}\r\ntd_cleanup:\r\nurb = td->urb;\r\nurb_priv = urb->hcpriv;\r\nif (td->bounce_seg)\r\nxhci_unmap_td_bounce_buffer(xhci, ep_ring, td);\r\nif (urb->actual_length > urb->transfer_buffer_length) {\r\nxhci_warn(xhci, "URB transfer length is wrong, xHC issue? req. len = %u, act. len = %u\n",\r\nurb->transfer_buffer_length,\r\nurb->actual_length);\r\nurb->actual_length = 0;\r\nif (td->urb->transfer_flags & URB_SHORT_NOT_OK)\r\n*status = -EREMOTEIO;\r\nelse\r\n*status = 0;\r\n}\r\nlist_del_init(&td->td_list);\r\nif (!list_empty(&td->cancelled_td_list))\r\nlist_del_init(&td->cancelled_td_list);\r\nurb_priv->td_cnt++;\r\nif (urb_priv->td_cnt == urb_priv->length) {\r\nret = 1;\r\nif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\nxhci_to_hcd(xhci)->self.bandwidth_isoc_reqs--;\r\nif (xhci_to_hcd(xhci)->self.bandwidth_isoc_reqs == 0) {\r\nif (xhci->quirks & XHCI_AMD_PLL_FIX)\r\nusb_amd_quirk_pll_enable();\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int process_ctrl_td(struct xhci_hcd *xhci, struct xhci_td *td,\r\nunion xhci_trb *event_trb, struct xhci_transfer_event *event,\r\nstruct xhci_virt_ep *ep, int *status)\r\n{\r\nstruct xhci_virt_device *xdev;\r\nstruct xhci_ring *ep_ring;\r\nunsigned int slot_id;\r\nint ep_index;\r\nstruct xhci_ep_ctx *ep_ctx;\r\nu32 trb_comp_code;\r\nslot_id = TRB_TO_SLOT_ID(le32_to_cpu(event->flags));\r\nxdev = xhci->devs[slot_id];\r\nep_index = TRB_TO_EP_ID(le32_to_cpu(event->flags)) - 1;\r\nep_ring = xhci_dma_to_transfer_ring(ep, le64_to_cpu(event->buffer));\r\nep_ctx = xhci_get_ep_ctx(xhci, xdev->out_ctx, ep_index);\r\ntrb_comp_code = GET_COMP_CODE(le32_to_cpu(event->transfer_len));\r\nswitch (trb_comp_code) {\r\ncase COMP_SUCCESS:\r\nif (event_trb == ep_ring->dequeue) {\r\nxhci_warn(xhci, "WARN: Success on ctrl setup TRB "\r\n"without IOC set??\n");\r\n*status = -ESHUTDOWN;\r\n} else if (event_trb != td->last_trb) {\r\nxhci_warn(xhci, "WARN: Success on ctrl data TRB "\r\n"without IOC set??\n");\r\n*status = -ESHUTDOWN;\r\n} else {\r\n*status = 0;\r\n}\r\nbreak;\r\ncase COMP_SHORT_TX:\r\nif (td->urb->transfer_flags & URB_SHORT_NOT_OK)\r\n*status = -EREMOTEIO;\r\nelse\r\n*status = 0;\r\nbreak;\r\ncase COMP_STOP_SHORT:\r\nif (event_trb == ep_ring->dequeue || event_trb == td->last_trb)\r\nxhci_warn(xhci, "WARN: Stopped Short Packet on ctrl setup or status TRB\n");\r\nelse\r\ntd->urb->actual_length =\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\nreturn finish_td(xhci, td, event_trb, event, ep, status, false);\r\ncase COMP_STOP:\r\nif (event_trb != ep_ring->dequeue && event_trb != td->last_trb)\r\ntd->urb->actual_length =\r\ntd->urb->transfer_buffer_length -\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\ncase COMP_STOP_INVAL:\r\nreturn finish_td(xhci, td, event_trb, event, ep, status, false);\r\ndefault:\r\nif (!xhci_requires_manual_halt_cleanup(xhci,\r\nep_ctx, trb_comp_code))\r\nbreak;\r\nxhci_dbg(xhci, "TRB error code %u, "\r\n"halted endpoint index = %u\n",\r\ntrb_comp_code, ep_index);\r\ncase COMP_STALL:\r\nif (event_trb != ep_ring->dequeue &&\r\nevent_trb != td->last_trb)\r\ntd->urb->actual_length =\r\ntd->urb->transfer_buffer_length -\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\nelse if (!td->urb_length_set)\r\ntd->urb->actual_length = 0;\r\nreturn finish_td(xhci, td, event_trb, event, ep, status, false);\r\n}\r\nif (event_trb != ep_ring->dequeue) {\r\nif (event_trb == td->last_trb) {\r\nif (td->urb_length_set) {\r\nif ((*status == -EINPROGRESS || *status == 0) &&\r\n(td->urb->transfer_flags\r\n& URB_SHORT_NOT_OK))\r\n*status = -EREMOTEIO;\r\n} else {\r\ntd->urb->actual_length =\r\ntd->urb->transfer_buffer_length;\r\n}\r\n} else {\r\ntd->urb_length_set = true;\r\ntd->urb->actual_length =\r\ntd->urb->transfer_buffer_length -\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\nxhci_dbg(xhci, "Waiting for status "\r\n"stage event\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn finish_td(xhci, td, event_trb, event, ep, status, false);\r\n}\r\nstatic int process_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,\r\nunion xhci_trb *event_trb, struct xhci_transfer_event *event,\r\nstruct xhci_virt_ep *ep, int *status)\r\n{\r\nstruct xhci_ring *ep_ring;\r\nstruct urb_priv *urb_priv;\r\nint idx;\r\nint len = 0;\r\nunion xhci_trb *cur_trb;\r\nstruct xhci_segment *cur_seg;\r\nstruct usb_iso_packet_descriptor *frame;\r\nu32 trb_comp_code;\r\nbool skip_td = false;\r\nep_ring = xhci_dma_to_transfer_ring(ep, le64_to_cpu(event->buffer));\r\ntrb_comp_code = GET_COMP_CODE(le32_to_cpu(event->transfer_len));\r\nurb_priv = td->urb->hcpriv;\r\nidx = urb_priv->td_cnt;\r\nframe = &td->urb->iso_frame_desc[idx];\r\nswitch (trb_comp_code) {\r\ncase COMP_SUCCESS:\r\nif (EVENT_TRB_LEN(le32_to_cpu(event->transfer_len)) == 0) {\r\nframe->status = 0;\r\nbreak;\r\n}\r\nif ((xhci->quirks & XHCI_TRUST_TX_LENGTH))\r\ntrb_comp_code = COMP_SHORT_TX;\r\ncase COMP_STOP_SHORT:\r\ncase COMP_SHORT_TX:\r\nframe->status = td->urb->transfer_flags & URB_SHORT_NOT_OK ?\r\n-EREMOTEIO : 0;\r\nbreak;\r\ncase COMP_BW_OVER:\r\nframe->status = -ECOMM;\r\nskip_td = true;\r\nbreak;\r\ncase COMP_BUFF_OVER:\r\ncase COMP_BABBLE:\r\nframe->status = -EOVERFLOW;\r\nskip_td = true;\r\nbreak;\r\ncase COMP_DEV_ERR:\r\ncase COMP_STALL:\r\nframe->status = -EPROTO;\r\nskip_td = true;\r\nbreak;\r\ncase COMP_TX_ERR:\r\nframe->status = -EPROTO;\r\nif (event_trb != td->last_trb)\r\nreturn 0;\r\nskip_td = true;\r\nbreak;\r\ncase COMP_STOP:\r\ncase COMP_STOP_INVAL:\r\nbreak;\r\ndefault:\r\nframe->status = -1;\r\nbreak;\r\n}\r\nif (trb_comp_code == COMP_SUCCESS || skip_td) {\r\nframe->actual_length = frame->length;\r\ntd->urb->actual_length += frame->length;\r\n} else if (trb_comp_code == COMP_STOP_SHORT) {\r\nframe->actual_length =\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\ntd->urb->actual_length += frame->actual_length;\r\n} else {\r\nfor (cur_trb = ep_ring->dequeue,\r\ncur_seg = ep_ring->deq_seg; cur_trb != event_trb;\r\nnext_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {\r\nif (!TRB_TYPE_NOOP_LE32(cur_trb->generic.field[3]) &&\r\n!TRB_TYPE_LINK_LE32(cur_trb->generic.field[3]))\r\nlen += TRB_LEN(le32_to_cpu(cur_trb->generic.field[2]));\r\n}\r\nlen += TRB_LEN(le32_to_cpu(cur_trb->generic.field[2])) -\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\nif (trb_comp_code != COMP_STOP_INVAL) {\r\nframe->actual_length = len;\r\ntd->urb->actual_length += len;\r\n}\r\n}\r\nreturn finish_td(xhci, td, event_trb, event, ep, status, false);\r\n}\r\nstatic int skip_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,\r\nstruct xhci_transfer_event *event,\r\nstruct xhci_virt_ep *ep, int *status)\r\n{\r\nstruct xhci_ring *ep_ring;\r\nstruct urb_priv *urb_priv;\r\nstruct usb_iso_packet_descriptor *frame;\r\nint idx;\r\nep_ring = xhci_dma_to_transfer_ring(ep, le64_to_cpu(event->buffer));\r\nurb_priv = td->urb->hcpriv;\r\nidx = urb_priv->td_cnt;\r\nframe = &td->urb->iso_frame_desc[idx];\r\nframe->status = -EXDEV;\r\nframe->actual_length = 0;\r\nwhile (ep_ring->dequeue != td->last_trb)\r\ninc_deq(xhci, ep_ring);\r\ninc_deq(xhci, ep_ring);\r\nreturn finish_td(xhci, td, NULL, event, ep, status, true);\r\n}\r\nstatic int process_bulk_intr_td(struct xhci_hcd *xhci, struct xhci_td *td,\r\nunion xhci_trb *event_trb, struct xhci_transfer_event *event,\r\nstruct xhci_virt_ep *ep, int *status)\r\n{\r\nstruct xhci_ring *ep_ring;\r\nunion xhci_trb *cur_trb;\r\nstruct xhci_segment *cur_seg;\r\nu32 trb_comp_code;\r\nep_ring = xhci_dma_to_transfer_ring(ep, le64_to_cpu(event->buffer));\r\ntrb_comp_code = GET_COMP_CODE(le32_to_cpu(event->transfer_len));\r\nswitch (trb_comp_code) {\r\ncase COMP_SUCCESS:\r\nif (event_trb != td->last_trb ||\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len)) != 0) {\r\nxhci_warn(xhci, "WARN Successful completion "\r\n"on short TX\n");\r\nif (td->urb->transfer_flags & URB_SHORT_NOT_OK)\r\n*status = -EREMOTEIO;\r\nelse\r\n*status = 0;\r\nif ((xhci->quirks & XHCI_TRUST_TX_LENGTH))\r\ntrb_comp_code = COMP_SHORT_TX;\r\n} else {\r\n*status = 0;\r\n}\r\nbreak;\r\ncase COMP_STOP_SHORT:\r\ncase COMP_SHORT_TX:\r\nif (td->urb->transfer_flags & URB_SHORT_NOT_OK)\r\n*status = -EREMOTEIO;\r\nelse\r\n*status = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (trb_comp_code == COMP_SHORT_TX)\r\nxhci_dbg(xhci, "ep %#x - asked for %d bytes, "\r\n"%d bytes untransferred\n",\r\ntd->urb->ep->desc.bEndpointAddress,\r\ntd->urb->transfer_buffer_length,\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len)));\r\nif (trb_comp_code == COMP_STOP_SHORT) {\r\ntd->urb->actual_length =\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\nif (td->urb->transfer_buffer_length <\r\ntd->urb->actual_length) {\r\nxhci_warn(xhci, "HC gave bad length of %d bytes txed\n",\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len)));\r\ntd->urb->actual_length = 0;\r\n}\r\n} else if (event_trb == td->last_trb) {\r\nif (EVENT_TRB_LEN(le32_to_cpu(event->transfer_len)) != 0) {\r\ntd->urb->actual_length =\r\ntd->urb->transfer_buffer_length -\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\nif (td->urb->transfer_buffer_length <\r\ntd->urb->actual_length) {\r\nxhci_warn(xhci, "HC gave bad length "\r\n"of %d bytes left\n",\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len)));\r\ntd->urb->actual_length = 0;\r\nif (td->urb->transfer_flags & URB_SHORT_NOT_OK)\r\n*status = -EREMOTEIO;\r\nelse\r\n*status = 0;\r\n}\r\nif (*status == -EINPROGRESS) {\r\nif (td->urb->transfer_flags & URB_SHORT_NOT_OK)\r\n*status = -EREMOTEIO;\r\nelse\r\n*status = 0;\r\n}\r\n} else {\r\ntd->urb->actual_length =\r\ntd->urb->transfer_buffer_length;\r\nif (*status == -EREMOTEIO)\r\n*status = 0;\r\n}\r\n} else {\r\ntd->urb->actual_length = 0;\r\nfor (cur_trb = ep_ring->dequeue, cur_seg = ep_ring->deq_seg;\r\ncur_trb != event_trb;\r\nnext_trb(xhci, ep_ring, &cur_seg, &cur_trb)) {\r\nif (!TRB_TYPE_NOOP_LE32(cur_trb->generic.field[3]) &&\r\n!TRB_TYPE_LINK_LE32(cur_trb->generic.field[3]))\r\ntd->urb->actual_length +=\r\nTRB_LEN(le32_to_cpu(cur_trb->generic.field[2]));\r\n}\r\nif (trb_comp_code != COMP_STOP_INVAL)\r\ntd->urb->actual_length +=\r\nTRB_LEN(le32_to_cpu(cur_trb->generic.field[2])) -\r\nEVENT_TRB_LEN(le32_to_cpu(event->transfer_len));\r\n}\r\nreturn finish_td(xhci, td, event_trb, event, ep, status, false);\r\n}\r\nstatic int handle_tx_event(struct xhci_hcd *xhci,\r\nstruct xhci_transfer_event *event)\r\n__releases(&xhci->lock\r\nstatic int xhci_handle_event(struct xhci_hcd *xhci)\r\n{\r\nunion xhci_trb *event;\r\nint update_ptrs = 1;\r\nint ret;\r\nif (!xhci->event_ring || !xhci->event_ring->dequeue) {\r\nxhci->error_bitmask |= 1 << 1;\r\nreturn 0;\r\n}\r\nevent = xhci->event_ring->dequeue;\r\nif ((le32_to_cpu(event->event_cmd.flags) & TRB_CYCLE) !=\r\nxhci->event_ring->cycle_state) {\r\nxhci->error_bitmask |= 1 << 2;\r\nreturn 0;\r\n}\r\nrmb();\r\nswitch ((le32_to_cpu(event->event_cmd.flags) & TRB_TYPE_BITMASK)) {\r\ncase TRB_TYPE(TRB_COMPLETION):\r\nhandle_cmd_completion(xhci, &event->event_cmd);\r\nbreak;\r\ncase TRB_TYPE(TRB_PORT_STATUS):\r\nhandle_port_status(xhci, event);\r\nupdate_ptrs = 0;\r\nbreak;\r\ncase TRB_TYPE(TRB_TRANSFER):\r\nret = handle_tx_event(xhci, &event->trans_event);\r\nif (ret < 0)\r\nxhci->error_bitmask |= 1 << 9;\r\nelse\r\nupdate_ptrs = 0;\r\nbreak;\r\ncase TRB_TYPE(TRB_DEV_NOTE):\r\nhandle_device_notification(xhci, event);\r\nbreak;\r\ndefault:\r\nif ((le32_to_cpu(event->event_cmd.flags) & TRB_TYPE_BITMASK) >=\r\nTRB_TYPE(48))\r\nhandle_vendor_event(xhci, event);\r\nelse\r\nxhci->error_bitmask |= 1 << 3;\r\n}\r\nif (xhci->xhc_state & XHCI_STATE_DYING) {\r\nxhci_dbg(xhci, "xHCI host dying, returning from "\r\n"event handler.\n");\r\nreturn 0;\r\n}\r\nif (update_ptrs)\r\ninc_deq(xhci, xhci->event_ring);\r\nreturn 1;\r\n}\r\nirqreturn_t xhci_irq(struct usb_hcd *hcd)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nu32 status;\r\nu64 temp_64;\r\nunion xhci_trb *event_ring_deq;\r\ndma_addr_t deq;\r\nspin_lock(&xhci->lock);\r\nstatus = readl(&xhci->op_regs->status);\r\nif (status == 0xffffffff)\r\ngoto hw_died;\r\nif (!(status & STS_EINT)) {\r\nspin_unlock(&xhci->lock);\r\nreturn IRQ_NONE;\r\n}\r\nif (status & STS_FATAL) {\r\nxhci_warn(xhci, "WARNING: Host System Error\n");\r\nxhci_halt(xhci);\r\nhw_died:\r\nspin_unlock(&xhci->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatus |= STS_EINT;\r\nwritel(status, &xhci->op_regs->status);\r\nif (hcd->irq) {\r\nu32 irq_pending;\r\nirq_pending = readl(&xhci->ir_set->irq_pending);\r\nirq_pending |= IMAN_IP;\r\nwritel(irq_pending, &xhci->ir_set->irq_pending);\r\n}\r\nif (xhci->xhc_state & XHCI_STATE_DYING ||\r\nxhci->xhc_state & XHCI_STATE_HALTED) {\r\nxhci_dbg(xhci, "xHCI dying, ignoring interrupt. "\r\n"Shouldn't IRQs be disabled?\n");\r\ntemp_64 = xhci_read_64(xhci, &xhci->ir_set->erst_dequeue);\r\nxhci_write_64(xhci, temp_64 | ERST_EHB,\r\n&xhci->ir_set->erst_dequeue);\r\nspin_unlock(&xhci->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nevent_ring_deq = xhci->event_ring->dequeue;\r\nwhile (xhci_handle_event(xhci) > 0) {}\r\ntemp_64 = xhci_read_64(xhci, &xhci->ir_set->erst_dequeue);\r\nif (event_ring_deq != xhci->event_ring->dequeue) {\r\ndeq = xhci_trb_virt_to_dma(xhci->event_ring->deq_seg,\r\nxhci->event_ring->dequeue);\r\nif (deq == 0)\r\nxhci_warn(xhci, "WARN something wrong with SW event "\r\n"ring dequeue ptr.\n");\r\ntemp_64 &= ERST_PTR_MASK;\r\ntemp_64 |= ((u64) deq & (u64) ~ERST_PTR_MASK);\r\n}\r\ntemp_64 |= ERST_EHB;\r\nxhci_write_64(xhci, temp_64, &xhci->ir_set->erst_dequeue);\r\nspin_unlock(&xhci->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t xhci_msi_irq(int irq, void *hcd)\r\n{\r\nreturn xhci_irq(hcd);\r\n}\r\nstatic void queue_trb(struct xhci_hcd *xhci, struct xhci_ring *ring,\r\nbool more_trbs_coming,\r\nu32 field1, u32 field2, u32 field3, u32 field4)\r\n{\r\nstruct xhci_generic_trb *trb;\r\ntrb = &ring->enqueue->generic;\r\ntrb->field[0] = cpu_to_le32(field1);\r\ntrb->field[1] = cpu_to_le32(field2);\r\ntrb->field[2] = cpu_to_le32(field3);\r\ntrb->field[3] = cpu_to_le32(field4);\r\ninc_enq(xhci, ring, more_trbs_coming);\r\n}\r\nstatic int prepare_ring(struct xhci_hcd *xhci, struct xhci_ring *ep_ring,\r\nu32 ep_state, unsigned int num_trbs, gfp_t mem_flags)\r\n{\r\nunsigned int num_trbs_needed;\r\nswitch (ep_state) {\r\ncase EP_STATE_DISABLED:\r\nxhci_warn(xhci, "WARN urb submitted to disabled ep\n");\r\nreturn -ENOENT;\r\ncase EP_STATE_ERROR:\r\nxhci_warn(xhci, "WARN waiting for error on ep to be cleared\n");\r\nreturn -EINVAL;\r\ncase EP_STATE_HALTED:\r\nxhci_dbg(xhci, "WARN halted endpoint, queueing URB anyway.\n");\r\ncase EP_STATE_STOPPED:\r\ncase EP_STATE_RUNNING:\r\nbreak;\r\ndefault:\r\nxhci_err(xhci, "ERROR unknown endpoint state for ep\n");\r\nreturn -EINVAL;\r\n}\r\nwhile (1) {\r\nif (room_on_ring(xhci, ep_ring, num_trbs))\r\nbreak;\r\nif (ep_ring == xhci->cmd_ring) {\r\nxhci_err(xhci, "Do not support expand command ring\n");\r\nreturn -ENOMEM;\r\n}\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_ring_expansion,\r\n"ERROR no room on ep ring, try ring expansion");\r\nnum_trbs_needed = num_trbs - ep_ring->num_trbs_free;\r\nif (xhci_ring_expansion(xhci, ep_ring, num_trbs_needed,\r\nmem_flags)) {\r\nxhci_err(xhci, "Ring expansion failed\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nwhile (trb_is_link(ep_ring->enqueue)) {\r\nif (!xhci_link_trb_quirk(xhci) &&\r\n!(ep_ring->type == TYPE_ISOC &&\r\n(xhci->quirks & XHCI_AMD_0x96_HOST)))\r\nep_ring->enqueue->link.control &=\r\ncpu_to_le32(~TRB_CHAIN);\r\nelse\r\nep_ring->enqueue->link.control |=\r\ncpu_to_le32(TRB_CHAIN);\r\nwmb();\r\nep_ring->enqueue->link.control ^= cpu_to_le32(TRB_CYCLE);\r\nif (link_trb_toggles_cycle(ep_ring->enqueue))\r\nep_ring->cycle_state ^= 1;\r\nep_ring->enq_seg = ep_ring->enq_seg->next;\r\nep_ring->enqueue = ep_ring->enq_seg->trbs;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prepare_transfer(struct xhci_hcd *xhci,\r\nstruct xhci_virt_device *xdev,\r\nunsigned int ep_index,\r\nunsigned int stream_id,\r\nunsigned int num_trbs,\r\nstruct urb *urb,\r\nunsigned int td_index,\r\ngfp_t mem_flags)\r\n{\r\nint ret;\r\nstruct urb_priv *urb_priv;\r\nstruct xhci_td *td;\r\nstruct xhci_ring *ep_ring;\r\nstruct xhci_ep_ctx *ep_ctx = xhci_get_ep_ctx(xhci, xdev->out_ctx, ep_index);\r\nep_ring = xhci_stream_id_to_ring(xdev, ep_index, stream_id);\r\nif (!ep_ring) {\r\nxhci_dbg(xhci, "Can't prepare ring for bad stream ID %u\n",\r\nstream_id);\r\nreturn -EINVAL;\r\n}\r\nret = prepare_ring(xhci, ep_ring,\r\nle32_to_cpu(ep_ctx->ep_info) & EP_STATE_MASK,\r\nnum_trbs, mem_flags);\r\nif (ret)\r\nreturn ret;\r\nurb_priv = urb->hcpriv;\r\ntd = urb_priv->td[td_index];\r\nINIT_LIST_HEAD(&td->td_list);\r\nINIT_LIST_HEAD(&td->cancelled_td_list);\r\nif (td_index == 0) {\r\nret = usb_hcd_link_urb_to_ep(bus_to_hcd(urb->dev->bus), urb);\r\nif (unlikely(ret))\r\nreturn ret;\r\n}\r\ntd->urb = urb;\r\nlist_add_tail(&td->td_list, &ep_ring->td_list);\r\ntd->start_seg = ep_ring->enq_seg;\r\ntd->first_trb = ep_ring->enqueue;\r\nurb_priv->td[td_index] = td;\r\nreturn 0;\r\n}\r\nstatic unsigned int count_trbs(u64 addr, u64 len)\r\n{\r\nunsigned int num_trbs;\r\nnum_trbs = DIV_ROUND_UP(len + (addr & (TRB_MAX_BUFF_SIZE - 1)),\r\nTRB_MAX_BUFF_SIZE);\r\nif (num_trbs == 0)\r\nnum_trbs++;\r\nreturn num_trbs;\r\n}\r\nstatic inline unsigned int count_trbs_needed(struct urb *urb)\r\n{\r\nreturn count_trbs(urb->transfer_dma, urb->transfer_buffer_length);\r\n}\r\nstatic unsigned int count_sg_trbs_needed(struct urb *urb)\r\n{\r\nstruct scatterlist *sg;\r\nunsigned int i, len, full_len, num_trbs = 0;\r\nfull_len = urb->transfer_buffer_length;\r\nfor_each_sg(urb->sg, sg, urb->num_mapped_sgs, i) {\r\nlen = sg_dma_len(sg);\r\nnum_trbs += count_trbs(sg_dma_address(sg), len);\r\nlen = min_t(unsigned int, len, full_len);\r\nfull_len -= len;\r\nif (full_len == 0)\r\nbreak;\r\n}\r\nreturn num_trbs;\r\n}\r\nstatic unsigned int count_isoc_trbs_needed(struct urb *urb, int i)\r\n{\r\nu64 addr, len;\r\naddr = (u64) (urb->transfer_dma + urb->iso_frame_desc[i].offset);\r\nlen = urb->iso_frame_desc[i].length;\r\nreturn count_trbs(addr, len);\r\n}\r\nstatic void check_trb_math(struct urb *urb, int running_total)\r\n{\r\nif (unlikely(running_total != urb->transfer_buffer_length))\r\ndev_err(&urb->dev->dev, "%s - ep %#x - Miscalculated tx length, "\r\n"queued %#x (%d), asked for %#x (%d)\n",\r\n__func__,\r\nurb->ep->desc.bEndpointAddress,\r\nrunning_total, running_total,\r\nurb->transfer_buffer_length,\r\nurb->transfer_buffer_length);\r\n}\r\nstatic void giveback_first_trb(struct xhci_hcd *xhci, int slot_id,\r\nunsigned int ep_index, unsigned int stream_id, int start_cycle,\r\nstruct xhci_generic_trb *start_trb)\r\n{\r\nwmb();\r\nif (start_cycle)\r\nstart_trb->field[3] |= cpu_to_le32(start_cycle);\r\nelse\r\nstart_trb->field[3] &= cpu_to_le32(~TRB_CYCLE);\r\nxhci_ring_ep_doorbell(xhci, slot_id, ep_index, stream_id);\r\n}\r\nstatic void check_interval(struct xhci_hcd *xhci, struct urb *urb,\r\nstruct xhci_ep_ctx *ep_ctx)\r\n{\r\nint xhci_interval;\r\nint ep_interval;\r\nxhci_interval = EP_INTERVAL_TO_UFRAMES(le32_to_cpu(ep_ctx->ep_info));\r\nep_interval = urb->interval;\r\nif (urb->dev->speed == USB_SPEED_LOW ||\r\nurb->dev->speed == USB_SPEED_FULL)\r\nep_interval *= 8;\r\nif (xhci_interval != ep_interval) {\r\ndev_dbg_ratelimited(&urb->dev->dev,\r\n"Driver uses different interval (%d microframe%s) than xHCI (%d microframe%s)\n",\r\nep_interval, ep_interval == 1 ? "" : "s",\r\nxhci_interval, xhci_interval == 1 ? "" : "s");\r\nurb->interval = xhci_interval;\r\nif (urb->dev->speed == USB_SPEED_LOW ||\r\nurb->dev->speed == USB_SPEED_FULL)\r\nurb->interval /= 8;\r\n}\r\n}\r\nint xhci_queue_intr_tx(struct xhci_hcd *xhci, gfp_t mem_flags,\r\nstruct urb *urb, int slot_id, unsigned int ep_index)\r\n{\r\nstruct xhci_ep_ctx *ep_ctx;\r\nep_ctx = xhci_get_ep_ctx(xhci, xhci->devs[slot_id]->out_ctx, ep_index);\r\ncheck_interval(xhci, urb, ep_ctx);\r\nreturn xhci_queue_bulk_tx(xhci, mem_flags, urb, slot_id, ep_index);\r\n}\r\nstatic u32 xhci_td_remainder(struct xhci_hcd *xhci, int transferred,\r\nint trb_buff_len, unsigned int td_total_len,\r\nstruct urb *urb, bool more_trbs_coming)\r\n{\r\nu32 maxp, total_packet_count;\r\nif (xhci->hci_version < 0x100 && !(xhci->quirks & XHCI_MTK_HOST))\r\nreturn ((td_total_len - transferred) >> 10);\r\nif (!more_trbs_coming || (transferred == 0 && trb_buff_len == 0) ||\r\ntrb_buff_len == td_total_len)\r\nreturn 0;\r\nif (xhci->quirks & XHCI_MTK_HOST)\r\ntrb_buff_len = 0;\r\nmaxp = GET_MAX_PACKET(usb_endpoint_maxp(&urb->ep->desc));\r\ntotal_packet_count = DIV_ROUND_UP(td_total_len, maxp);\r\nreturn (total_packet_count - ((transferred + trb_buff_len) / maxp));\r\n}\r\nstatic int xhci_align_td(struct xhci_hcd *xhci, struct urb *urb, u32 enqd_len,\r\nu32 *trb_buff_len, struct xhci_segment *seg)\r\n{\r\nstruct device *dev = xhci_to_hcd(xhci)->self.controller;\r\nunsigned int unalign;\r\nunsigned int max_pkt;\r\nu32 new_buff_len;\r\nmax_pkt = GET_MAX_PACKET(usb_endpoint_maxp(&urb->ep->desc));\r\nunalign = (enqd_len + *trb_buff_len) % max_pkt;\r\nif (unalign == 0)\r\nreturn 0;\r\nxhci_dbg(xhci, "Unaligned %d bytes, buff len %d\n",\r\nunalign, *trb_buff_len);\r\nif (*trb_buff_len > unalign) {\r\n*trb_buff_len -= unalign;\r\nxhci_dbg(xhci, "split align, new buff len %d\n", *trb_buff_len);\r\nreturn 0;\r\n}\r\nnew_buff_len = max_pkt - (enqd_len % max_pkt);\r\nif (new_buff_len > (urb->transfer_buffer_length - enqd_len))\r\nnew_buff_len = (urb->transfer_buffer_length - enqd_len);\r\nif (usb_urb_dir_out(urb)) {\r\nsg_pcopy_to_buffer(urb->sg, urb->num_mapped_sgs,\r\nseg->bounce_buf, new_buff_len, enqd_len);\r\nseg->bounce_dma = dma_map_single(dev, seg->bounce_buf,\r\nmax_pkt, DMA_TO_DEVICE);\r\n} else {\r\nseg->bounce_dma = dma_map_single(dev, seg->bounce_buf,\r\nmax_pkt, DMA_FROM_DEVICE);\r\n}\r\nif (dma_mapping_error(dev, seg->bounce_dma)) {\r\nxhci_warn(xhci, "Failed mapping bounce buffer, not aligning\n");\r\nreturn 0;\r\n}\r\n*trb_buff_len = new_buff_len;\r\nseg->bounce_len = new_buff_len;\r\nseg->bounce_offs = enqd_len;\r\nxhci_dbg(xhci, "Bounce align, new buff len %d\n", *trb_buff_len);\r\nreturn 1;\r\n}\r\nint xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,\r\nstruct urb *urb, int slot_id, unsigned int ep_index)\r\n{\r\nstruct xhci_ring *ring;\r\nstruct urb_priv *urb_priv;\r\nstruct xhci_td *td;\r\nstruct xhci_generic_trb *start_trb;\r\nstruct scatterlist *sg = NULL;\r\nbool more_trbs_coming = true;\r\nbool need_zero_pkt = false;\r\nbool first_trb = true;\r\nunsigned int num_trbs;\r\nunsigned int start_cycle, num_sgs = 0;\r\nunsigned int enqd_len, block_len, trb_buff_len, full_len;\r\nint sent_len, ret;\r\nu32 field, length_field, remainder;\r\nu64 addr, send_addr;\r\nring = xhci_urb_to_transfer_ring(xhci, urb);\r\nif (!ring)\r\nreturn -EINVAL;\r\nfull_len = urb->transfer_buffer_length;\r\nif (urb->num_sgs) {\r\nnum_sgs = urb->num_mapped_sgs;\r\nsg = urb->sg;\r\naddr = (u64) sg_dma_address(sg);\r\nblock_len = sg_dma_len(sg);\r\nnum_trbs = count_sg_trbs_needed(urb);\r\n} else {\r\nnum_trbs = count_trbs_needed(urb);\r\naddr = (u64) urb->transfer_dma;\r\nblock_len = full_len;\r\n}\r\nret = prepare_transfer(xhci, xhci->devs[slot_id],\r\nep_index, urb->stream_id,\r\nnum_trbs, urb, 0, mem_flags);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nurb_priv = urb->hcpriv;\r\nif (urb->transfer_flags & URB_ZERO_PACKET && urb_priv->length > 1)\r\nneed_zero_pkt = true;\r\ntd = urb_priv->td[0];\r\nstart_trb = &ring->enqueue->generic;\r\nstart_cycle = ring->cycle_state;\r\nsend_addr = addr;\r\nfor (enqd_len = 0; first_trb || enqd_len < full_len;\r\nenqd_len += trb_buff_len) {\r\nfield = TRB_TYPE(TRB_NORMAL);\r\ntrb_buff_len = TRB_BUFF_LEN_UP_TO_BOUNDARY(addr);\r\ntrb_buff_len = min_t(unsigned int, trb_buff_len, block_len);\r\nif (enqd_len + trb_buff_len > full_len)\r\ntrb_buff_len = full_len - enqd_len;\r\nif (first_trb) {\r\nfirst_trb = false;\r\nif (start_cycle == 0)\r\nfield |= TRB_CYCLE;\r\n} else\r\nfield |= ring->cycle_state;\r\nif (enqd_len + trb_buff_len < full_len) {\r\nfield |= TRB_CHAIN;\r\nif (trb_is_link(ring->enqueue + 1)) {\r\nif (xhci_align_td(xhci, urb, enqd_len,\r\n&trb_buff_len,\r\nring->enq_seg)) {\r\nsend_addr = ring->enq_seg->bounce_dma;\r\ntd->bounce_seg = ring->enq_seg;\r\n}\r\n}\r\n}\r\nif (enqd_len + trb_buff_len >= full_len) {\r\nfield &= ~TRB_CHAIN;\r\nfield |= TRB_IOC;\r\nmore_trbs_coming = false;\r\ntd->last_trb = ring->enqueue;\r\n}\r\nif (usb_urb_dir_in(urb))\r\nfield |= TRB_ISP;\r\nremainder = xhci_td_remainder(xhci, enqd_len, trb_buff_len,\r\nfull_len, urb, more_trbs_coming);\r\nlength_field = TRB_LEN(trb_buff_len) |\r\nTRB_TD_SIZE(remainder) |\r\nTRB_INTR_TARGET(0);\r\nqueue_trb(xhci, ring, more_trbs_coming | need_zero_pkt,\r\nlower_32_bits(send_addr),\r\nupper_32_bits(send_addr),\r\nlength_field,\r\nfield);\r\naddr += trb_buff_len;\r\nsent_len = trb_buff_len;\r\nwhile (sg && sent_len >= block_len) {\r\n--num_sgs;\r\nsent_len -= block_len;\r\nif (num_sgs != 0) {\r\nsg = sg_next(sg);\r\nblock_len = sg_dma_len(sg);\r\naddr = (u64) sg_dma_address(sg);\r\naddr += sent_len;\r\n}\r\n}\r\nblock_len -= sent_len;\r\nsend_addr = addr;\r\n}\r\nif (need_zero_pkt) {\r\nret = prepare_transfer(xhci, xhci->devs[slot_id],\r\nep_index, urb->stream_id,\r\n1, urb, 1, mem_flags);\r\nurb_priv->td[1]->last_trb = ring->enqueue;\r\nfield = TRB_TYPE(TRB_NORMAL) | ring->cycle_state | TRB_IOC;\r\nqueue_trb(xhci, ring, 0, 0, 0, TRB_INTR_TARGET(0), field);\r\n}\r\ncheck_trb_math(urb, enqd_len);\r\ngiveback_first_trb(xhci, slot_id, ep_index, urb->stream_id,\r\nstart_cycle, start_trb);\r\nreturn 0;\r\n}\r\nint xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags,\r\nstruct urb *urb, int slot_id, unsigned int ep_index)\r\n{\r\nstruct xhci_ring *ep_ring;\r\nint num_trbs;\r\nint ret;\r\nstruct usb_ctrlrequest *setup;\r\nstruct xhci_generic_trb *start_trb;\r\nint start_cycle;\r\nu32 field, length_field, remainder;\r\nstruct urb_priv *urb_priv;\r\nstruct xhci_td *td;\r\nep_ring = xhci_urb_to_transfer_ring(xhci, urb);\r\nif (!ep_ring)\r\nreturn -EINVAL;\r\nif (!urb->setup_packet)\r\nreturn -EINVAL;\r\nnum_trbs = 2;\r\nif (urb->transfer_buffer_length > 0)\r\nnum_trbs++;\r\nret = prepare_transfer(xhci, xhci->devs[slot_id],\r\nep_index, urb->stream_id,\r\nnum_trbs, urb, 0, mem_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nurb_priv = urb->hcpriv;\r\ntd = urb_priv->td[0];\r\nstart_trb = &ep_ring->enqueue->generic;\r\nstart_cycle = ep_ring->cycle_state;\r\nsetup = (struct usb_ctrlrequest *) urb->setup_packet;\r\nfield = 0;\r\nfield |= TRB_IDT | TRB_TYPE(TRB_SETUP);\r\nif (start_cycle == 0)\r\nfield |= 0x1;\r\nif ((xhci->hci_version >= 0x100) || (xhci->quirks & XHCI_MTK_HOST)) {\r\nif (urb->transfer_buffer_length > 0) {\r\nif (setup->bRequestType & USB_DIR_IN)\r\nfield |= TRB_TX_TYPE(TRB_DATA_IN);\r\nelse\r\nfield |= TRB_TX_TYPE(TRB_DATA_OUT);\r\n}\r\n}\r\nqueue_trb(xhci, ep_ring, true,\r\nsetup->bRequestType | setup->bRequest << 8 | le16_to_cpu(setup->wValue) << 16,\r\nle16_to_cpu(setup->wIndex) | le16_to_cpu(setup->wLength) << 16,\r\nTRB_LEN(8) | TRB_INTR_TARGET(0),\r\nfield);\r\nif (usb_urb_dir_in(urb))\r\nfield = TRB_ISP | TRB_TYPE(TRB_DATA);\r\nelse\r\nfield = TRB_TYPE(TRB_DATA);\r\nremainder = xhci_td_remainder(xhci, 0,\r\nurb->transfer_buffer_length,\r\nurb->transfer_buffer_length,\r\nurb, 1);\r\nlength_field = TRB_LEN(urb->transfer_buffer_length) |\r\nTRB_TD_SIZE(remainder) |\r\nTRB_INTR_TARGET(0);\r\nif (urb->transfer_buffer_length > 0) {\r\nif (setup->bRequestType & USB_DIR_IN)\r\nfield |= TRB_DIR_IN;\r\nqueue_trb(xhci, ep_ring, true,\r\nlower_32_bits(urb->transfer_dma),\r\nupper_32_bits(urb->transfer_dma),\r\nlength_field,\r\nfield | ep_ring->cycle_state);\r\n}\r\ntd->last_trb = ep_ring->enqueue;\r\nif (urb->transfer_buffer_length > 0 && setup->bRequestType & USB_DIR_IN)\r\nfield = 0;\r\nelse\r\nfield = TRB_DIR_IN;\r\nqueue_trb(xhci, ep_ring, false,\r\n0,\r\n0,\r\nTRB_INTR_TARGET(0),\r\nfield | TRB_IOC | TRB_TYPE(TRB_STATUS) | ep_ring->cycle_state);\r\ngiveback_first_trb(xhci, slot_id, ep_index, 0,\r\nstart_cycle, start_trb);\r\nreturn 0;\r\n}\r\nstatic unsigned int xhci_get_burst_count(struct xhci_hcd *xhci,\r\nstruct urb *urb, unsigned int total_packet_count)\r\n{\r\nunsigned int max_burst;\r\nif (xhci->hci_version < 0x100 || urb->dev->speed < USB_SPEED_SUPER)\r\nreturn 0;\r\nmax_burst = urb->ep->ss_ep_comp.bMaxBurst;\r\nreturn DIV_ROUND_UP(total_packet_count, max_burst + 1) - 1;\r\n}\r\nstatic unsigned int xhci_get_last_burst_packet_count(struct xhci_hcd *xhci,\r\nstruct urb *urb, unsigned int total_packet_count)\r\n{\r\nunsigned int max_burst;\r\nunsigned int residue;\r\nif (xhci->hci_version < 0x100)\r\nreturn 0;\r\nif (urb->dev->speed >= USB_SPEED_SUPER) {\r\nmax_burst = urb->ep->ss_ep_comp.bMaxBurst;\r\nresidue = total_packet_count % (max_burst + 1);\r\nif (residue == 0)\r\nreturn max_burst;\r\nreturn residue - 1;\r\n}\r\nif (total_packet_count == 0)\r\nreturn 0;\r\nreturn total_packet_count - 1;\r\n}\r\nstatic int xhci_get_isoc_frame_id(struct xhci_hcd *xhci,\r\nstruct urb *urb, int index)\r\n{\r\nint start_frame, ist, ret = 0;\r\nint start_frame_id, end_frame_id, current_frame_id;\r\nif (urb->dev->speed == USB_SPEED_LOW ||\r\nurb->dev->speed == USB_SPEED_FULL)\r\nstart_frame = urb->start_frame + index * urb->interval;\r\nelse\r\nstart_frame = (urb->start_frame + index * urb->interval) >> 3;\r\nist = HCS_IST(xhci->hcs_params2) & 0x7;\r\nif (HCS_IST(xhci->hcs_params2) & (1 << 3))\r\nist <<= 3;\r\ncurrent_frame_id = readl(&xhci->run_regs->microframe_index);\r\nstart_frame_id = roundup(current_frame_id + ist + 1, 8);\r\nend_frame_id = rounddown(current_frame_id + 895 * 8, 8);\r\nstart_frame &= 0x7ff;\r\nstart_frame_id = (start_frame_id >> 3) & 0x7ff;\r\nend_frame_id = (end_frame_id >> 3) & 0x7ff;\r\nxhci_dbg(xhci, "%s: index %d, reg 0x%x start_frame_id 0x%x, end_frame_id 0x%x, start_frame 0x%x\n",\r\n__func__, index, readl(&xhci->run_regs->microframe_index),\r\nstart_frame_id, end_frame_id, start_frame);\r\nif (start_frame_id < end_frame_id) {\r\nif (start_frame > end_frame_id ||\r\nstart_frame < start_frame_id)\r\nret = -EINVAL;\r\n} else if (start_frame_id > end_frame_id) {\r\nif ((start_frame > end_frame_id &&\r\nstart_frame < start_frame_id))\r\nret = -EINVAL;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nif (index == 0) {\r\nif (ret == -EINVAL || start_frame == start_frame_id) {\r\nstart_frame = start_frame_id + 1;\r\nif (urb->dev->speed == USB_SPEED_LOW ||\r\nurb->dev->speed == USB_SPEED_FULL)\r\nurb->start_frame = start_frame;\r\nelse\r\nurb->start_frame = start_frame << 3;\r\nret = 0;\r\n}\r\n}\r\nif (ret) {\r\nxhci_warn(xhci, "Frame ID %d (reg %d, index %d) beyond range (%d, %d)\n",\r\nstart_frame, current_frame_id, index,\r\nstart_frame_id, end_frame_id);\r\nxhci_warn(xhci, "Ignore frame ID field, use SIA bit instead\n");\r\nreturn ret;\r\n}\r\nreturn start_frame;\r\n}\r\nstatic int xhci_queue_isoc_tx(struct xhci_hcd *xhci, gfp_t mem_flags,\r\nstruct urb *urb, int slot_id, unsigned int ep_index)\r\n{\r\nstruct xhci_ring *ep_ring;\r\nstruct urb_priv *urb_priv;\r\nstruct xhci_td *td;\r\nint num_tds, trbs_per_td;\r\nstruct xhci_generic_trb *start_trb;\r\nbool first_trb;\r\nint start_cycle;\r\nu32 field, length_field;\r\nint running_total, trb_buff_len, td_len, td_remain_len, ret;\r\nu64 start_addr, addr;\r\nint i, j;\r\nbool more_trbs_coming;\r\nstruct xhci_virt_ep *xep;\r\nint frame_id;\r\nxep = &xhci->devs[slot_id]->eps[ep_index];\r\nep_ring = xhci->devs[slot_id]->eps[ep_index].ring;\r\nnum_tds = urb->number_of_packets;\r\nif (num_tds < 1) {\r\nxhci_dbg(xhci, "Isoc URB with zero packets?\n");\r\nreturn -EINVAL;\r\n}\r\nstart_addr = (u64) urb->transfer_dma;\r\nstart_trb = &ep_ring->enqueue->generic;\r\nstart_cycle = ep_ring->cycle_state;\r\nurb_priv = urb->hcpriv;\r\nfor (i = 0; i < num_tds; i++) {\r\nunsigned int total_pkt_count, max_pkt;\r\nunsigned int burst_count, last_burst_pkt_count;\r\nu32 sia_frame_id;\r\nfirst_trb = true;\r\nrunning_total = 0;\r\naddr = start_addr + urb->iso_frame_desc[i].offset;\r\ntd_len = urb->iso_frame_desc[i].length;\r\ntd_remain_len = td_len;\r\nmax_pkt = GET_MAX_PACKET(usb_endpoint_maxp(&urb->ep->desc));\r\ntotal_pkt_count = DIV_ROUND_UP(td_len, max_pkt);\r\nif (total_pkt_count == 0)\r\ntotal_pkt_count++;\r\nburst_count = xhci_get_burst_count(xhci, urb, total_pkt_count);\r\nlast_burst_pkt_count = xhci_get_last_burst_packet_count(xhci,\r\nurb, total_pkt_count);\r\ntrbs_per_td = count_isoc_trbs_needed(urb, i);\r\nret = prepare_transfer(xhci, xhci->devs[slot_id], ep_index,\r\nurb->stream_id, trbs_per_td, urb, i, mem_flags);\r\nif (ret < 0) {\r\nif (i == 0)\r\nreturn ret;\r\ngoto cleanup;\r\n}\r\ntd = urb_priv->td[i];\r\nsia_frame_id = TRB_SIA;\r\nif (!(urb->transfer_flags & URB_ISO_ASAP) &&\r\nHCC_CFC(xhci->hcc_params)) {\r\nframe_id = xhci_get_isoc_frame_id(xhci, urb, i);\r\nif (frame_id >= 0)\r\nsia_frame_id = TRB_FRAME_ID(frame_id);\r\n}\r\nfield = TRB_TYPE(TRB_ISOC) |\r\nTRB_TLBPC(last_burst_pkt_count) |\r\nsia_frame_id |\r\n(i ? ep_ring->cycle_state : !start_cycle);\r\nif (!xep->use_extended_tbc)\r\nfield |= TRB_TBC(burst_count);\r\nfor (j = 0; j < trbs_per_td; j++) {\r\nu32 remainder = 0;\r\nif (!first_trb)\r\nfield = TRB_TYPE(TRB_NORMAL) |\r\nep_ring->cycle_state;\r\nif (usb_urb_dir_in(urb))\r\nfield |= TRB_ISP;\r\nif (j < trbs_per_td - 1) {\r\nmore_trbs_coming = true;\r\nfield |= TRB_CHAIN;\r\n} else {\r\nmore_trbs_coming = false;\r\ntd->last_trb = ep_ring->enqueue;\r\nfield |= TRB_IOC;\r\nif (xhci->hci_version >= 0x100 &&\r\n!(xhci->quirks & XHCI_AVOID_BEI) &&\r\ni < num_tds - 1)\r\nfield |= TRB_BEI;\r\n}\r\ntrb_buff_len = TRB_BUFF_LEN_UP_TO_BOUNDARY(addr);\r\nif (trb_buff_len > td_remain_len)\r\ntrb_buff_len = td_remain_len;\r\nremainder = xhci_td_remainder(xhci, running_total,\r\ntrb_buff_len, td_len,\r\nurb, more_trbs_coming);\r\nlength_field = TRB_LEN(trb_buff_len) |\r\nTRB_INTR_TARGET(0);\r\nif (first_trb && xep->use_extended_tbc)\r\nlength_field |= TRB_TD_SIZE_TBC(burst_count);\r\nelse\r\nlength_field |= TRB_TD_SIZE(remainder);\r\nfirst_trb = false;\r\nqueue_trb(xhci, ep_ring, more_trbs_coming,\r\nlower_32_bits(addr),\r\nupper_32_bits(addr),\r\nlength_field,\r\nfield);\r\nrunning_total += trb_buff_len;\r\naddr += trb_buff_len;\r\ntd_remain_len -= trb_buff_len;\r\n}\r\nif (running_total != td_len) {\r\nxhci_err(xhci, "ISOC TD length unmatch\n");\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\n}\r\nif (HCC_CFC(xhci->hcc_params))\r\nxep->next_frame_id = urb->start_frame + num_tds * urb->interval;\r\nif (xhci_to_hcd(xhci)->self.bandwidth_isoc_reqs == 0) {\r\nif (xhci->quirks & XHCI_AMD_PLL_FIX)\r\nusb_amd_quirk_pll_disable();\r\n}\r\nxhci_to_hcd(xhci)->self.bandwidth_isoc_reqs++;\r\ngiveback_first_trb(xhci, slot_id, ep_index, urb->stream_id,\r\nstart_cycle, start_trb);\r\nreturn 0;\r\ncleanup:\r\nfor (i--; i >= 0; i--)\r\nlist_del_init(&urb_priv->td[i]->td_list);\r\nurb_priv->td[0]->last_trb = ep_ring->enqueue;\r\ntd_to_noop(xhci, ep_ring, urb_priv->td[0], true);\r\nep_ring->enqueue = urb_priv->td[0]->first_trb;\r\nep_ring->enq_seg = urb_priv->td[0]->start_seg;\r\nep_ring->cycle_state = start_cycle;\r\nep_ring->num_trbs_free = ep_ring->num_trbs_free_temp;\r\nusb_hcd_unlink_urb_from_ep(bus_to_hcd(urb->dev->bus), urb);\r\nreturn ret;\r\n}\r\nint xhci_queue_isoc_tx_prepare(struct xhci_hcd *xhci, gfp_t mem_flags,\r\nstruct urb *urb, int slot_id, unsigned int ep_index)\r\n{\r\nstruct xhci_virt_device *xdev;\r\nstruct xhci_ring *ep_ring;\r\nstruct xhci_ep_ctx *ep_ctx;\r\nint start_frame;\r\nint num_tds, num_trbs, i;\r\nint ret;\r\nstruct xhci_virt_ep *xep;\r\nint ist;\r\nxdev = xhci->devs[slot_id];\r\nxep = &xhci->devs[slot_id]->eps[ep_index];\r\nep_ring = xdev->eps[ep_index].ring;\r\nep_ctx = xhci_get_ep_ctx(xhci, xdev->out_ctx, ep_index);\r\nnum_trbs = 0;\r\nnum_tds = urb->number_of_packets;\r\nfor (i = 0; i < num_tds; i++)\r\nnum_trbs += count_isoc_trbs_needed(urb, i);\r\nret = prepare_ring(xhci, ep_ring, le32_to_cpu(ep_ctx->ep_info) & EP_STATE_MASK,\r\nnum_trbs, mem_flags);\r\nif (ret)\r\nreturn ret;\r\ncheck_interval(xhci, urb, ep_ctx);\r\nif (HCC_CFC(xhci->hcc_params) && !list_empty(&ep_ring->td_list)) {\r\nif ((le32_to_cpu(ep_ctx->ep_info) & EP_STATE_MASK) ==\r\nEP_STATE_RUNNING) {\r\nurb->start_frame = xep->next_frame_id;\r\ngoto skip_start_over;\r\n}\r\n}\r\nstart_frame = readl(&xhci->run_regs->microframe_index);\r\nstart_frame &= 0x3fff;\r\nist = HCS_IST(xhci->hcs_params2) & 0x7;\r\nif (HCS_IST(xhci->hcs_params2) & (1 << 3))\r\nist <<= 3;\r\nstart_frame += ist + XHCI_CFC_DELAY;\r\nstart_frame = roundup(start_frame, 8);\r\nif (urb->dev->speed == USB_SPEED_LOW ||\r\nurb->dev->speed == USB_SPEED_FULL) {\r\nstart_frame = roundup(start_frame, urb->interval << 3);\r\nurb->start_frame = start_frame >> 3;\r\n} else {\r\nstart_frame = roundup(start_frame, urb->interval);\r\nurb->start_frame = start_frame;\r\n}\r\nskip_start_over:\r\nep_ring->num_trbs_free_temp = ep_ring->num_trbs_free;\r\nreturn xhci_queue_isoc_tx(xhci, mem_flags, urb, slot_id, ep_index);\r\n}\r\nstatic int queue_command(struct xhci_hcd *xhci, struct xhci_command *cmd,\r\nu32 field1, u32 field2,\r\nu32 field3, u32 field4, bool command_must_succeed)\r\n{\r\nint reserved_trbs = xhci->cmd_ring_reserved_trbs;\r\nint ret;\r\nif ((xhci->xhc_state & XHCI_STATE_DYING) ||\r\n(xhci->xhc_state & XHCI_STATE_HALTED)) {\r\nxhci_dbg(xhci, "xHCI dying or halted, can't queue_command\n");\r\nreturn -ESHUTDOWN;\r\n}\r\nif (!command_must_succeed)\r\nreserved_trbs++;\r\nret = prepare_ring(xhci, xhci->cmd_ring, EP_STATE_RUNNING,\r\nreserved_trbs, GFP_ATOMIC);\r\nif (ret < 0) {\r\nxhci_err(xhci, "ERR: No room for command on command ring\n");\r\nif (command_must_succeed)\r\nxhci_err(xhci, "ERR: Reserved TRB counting for "\r\n"unfailable commands failed.\n");\r\nreturn ret;\r\n}\r\ncmd->command_trb = xhci->cmd_ring->enqueue;\r\nlist_add_tail(&cmd->cmd_list, &xhci->cmd_list);\r\nif (xhci->cmd_list.next == &cmd->cmd_list &&\r\n!timer_pending(&xhci->cmd_timer)) {\r\nxhci->current_cmd = cmd;\r\nmod_timer(&xhci->cmd_timer, jiffies + XHCI_CMD_DEFAULT_TIMEOUT);\r\n}\r\nqueue_trb(xhci, xhci->cmd_ring, false, field1, field2, field3,\r\nfield4 | xhci->cmd_ring->cycle_state);\r\nreturn 0;\r\n}\r\nint xhci_queue_slot_control(struct xhci_hcd *xhci, struct xhci_command *cmd,\r\nu32 trb_type, u32 slot_id)\r\n{\r\nreturn queue_command(xhci, cmd, 0, 0, 0,\r\nTRB_TYPE(trb_type) | SLOT_ID_FOR_TRB(slot_id), false);\r\n}\r\nint xhci_queue_address_device(struct xhci_hcd *xhci, struct xhci_command *cmd,\r\ndma_addr_t in_ctx_ptr, u32 slot_id, enum xhci_setup_dev setup)\r\n{\r\nreturn queue_command(xhci, cmd, lower_32_bits(in_ctx_ptr),\r\nupper_32_bits(in_ctx_ptr), 0,\r\nTRB_TYPE(TRB_ADDR_DEV) | SLOT_ID_FOR_TRB(slot_id)\r\n| (setup == SETUP_CONTEXT_ONLY ? TRB_BSR : 0), false);\r\n}\r\nint xhci_queue_vendor_command(struct xhci_hcd *xhci, struct xhci_command *cmd,\r\nu32 field1, u32 field2, u32 field3, u32 field4)\r\n{\r\nreturn queue_command(xhci, cmd, field1, field2, field3, field4, false);\r\n}\r\nint xhci_queue_reset_device(struct xhci_hcd *xhci, struct xhci_command *cmd,\r\nu32 slot_id)\r\n{\r\nreturn queue_command(xhci, cmd, 0, 0, 0,\r\nTRB_TYPE(TRB_RESET_DEV) | SLOT_ID_FOR_TRB(slot_id),\r\nfalse);\r\n}\r\nint xhci_queue_configure_endpoint(struct xhci_hcd *xhci,\r\nstruct xhci_command *cmd, dma_addr_t in_ctx_ptr,\r\nu32 slot_id, bool command_must_succeed)\r\n{\r\nreturn queue_command(xhci, cmd, lower_32_bits(in_ctx_ptr),\r\nupper_32_bits(in_ctx_ptr), 0,\r\nTRB_TYPE(TRB_CONFIG_EP) | SLOT_ID_FOR_TRB(slot_id),\r\ncommand_must_succeed);\r\n}\r\nint xhci_queue_evaluate_context(struct xhci_hcd *xhci, struct xhci_command *cmd,\r\ndma_addr_t in_ctx_ptr, u32 slot_id, bool command_must_succeed)\r\n{\r\nreturn queue_command(xhci, cmd, lower_32_bits(in_ctx_ptr),\r\nupper_32_bits(in_ctx_ptr), 0,\r\nTRB_TYPE(TRB_EVAL_CONTEXT) | SLOT_ID_FOR_TRB(slot_id),\r\ncommand_must_succeed);\r\n}\r\nint xhci_queue_stop_endpoint(struct xhci_hcd *xhci, struct xhci_command *cmd,\r\nint slot_id, unsigned int ep_index, int suspend)\r\n{\r\nu32 trb_slot_id = SLOT_ID_FOR_TRB(slot_id);\r\nu32 trb_ep_index = EP_ID_FOR_TRB(ep_index);\r\nu32 type = TRB_TYPE(TRB_STOP_RING);\r\nu32 trb_suspend = SUSPEND_PORT_FOR_TRB(suspend);\r\nreturn queue_command(xhci, cmd, 0, 0, 0,\r\ntrb_slot_id | trb_ep_index | type | trb_suspend, false);\r\n}\r\nvoid xhci_queue_new_dequeue_state(struct xhci_hcd *xhci,\r\nunsigned int slot_id, unsigned int ep_index,\r\nunsigned int stream_id,\r\nstruct xhci_dequeue_state *deq_state)\r\n{\r\ndma_addr_t addr;\r\nu32 trb_slot_id = SLOT_ID_FOR_TRB(slot_id);\r\nu32 trb_ep_index = EP_ID_FOR_TRB(ep_index);\r\nu32 trb_stream_id = STREAM_ID_FOR_TRB(stream_id);\r\nu32 trb_sct = 0;\r\nu32 type = TRB_TYPE(TRB_SET_DEQ);\r\nstruct xhci_virt_ep *ep;\r\nstruct xhci_command *cmd;\r\nint ret;\r\nxhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,\r\n"Set TR Deq Ptr cmd, new deq seg = %p (0x%llx dma), new deq ptr = %p (0x%llx dma), new cycle = %u",\r\ndeq_state->new_deq_seg,\r\n(unsigned long long)deq_state->new_deq_seg->dma,\r\ndeq_state->new_deq_ptr,\r\n(unsigned long long)xhci_trb_virt_to_dma(\r\ndeq_state->new_deq_seg, deq_state->new_deq_ptr),\r\ndeq_state->new_cycle_state);\r\naddr = xhci_trb_virt_to_dma(deq_state->new_deq_seg,\r\ndeq_state->new_deq_ptr);\r\nif (addr == 0) {\r\nxhci_warn(xhci, "WARN Cannot submit Set TR Deq Ptr\n");\r\nxhci_warn(xhci, "WARN deq seg = %p, deq pt = %p\n",\r\ndeq_state->new_deq_seg, deq_state->new_deq_ptr);\r\nreturn;\r\n}\r\nep = &xhci->devs[slot_id]->eps[ep_index];\r\nif ((ep->ep_state & SET_DEQ_PENDING)) {\r\nxhci_warn(xhci, "WARN Cannot submit Set TR Deq Ptr\n");\r\nxhci_warn(xhci, "A Set TR Deq Ptr command is pending.\n");\r\nreturn;\r\n}\r\ncmd = xhci_alloc_command(xhci, false, false, GFP_ATOMIC);\r\nif (!cmd) {\r\nxhci_warn(xhci, "WARN Cannot submit Set TR Deq Ptr: ENOMEM\n");\r\nreturn;\r\n}\r\nep->queued_deq_seg = deq_state->new_deq_seg;\r\nep->queued_deq_ptr = deq_state->new_deq_ptr;\r\nif (stream_id)\r\ntrb_sct = SCT_FOR_TRB(SCT_PRI_TR);\r\nret = queue_command(xhci, cmd,\r\nlower_32_bits(addr) | trb_sct | deq_state->new_cycle_state,\r\nupper_32_bits(addr), trb_stream_id,\r\ntrb_slot_id | trb_ep_index | type, false);\r\nif (ret < 0) {\r\nxhci_free_command(xhci, cmd);\r\nreturn;\r\n}\r\nep->ep_state |= SET_DEQ_PENDING;\r\n}\r\nint xhci_queue_reset_ep(struct xhci_hcd *xhci, struct xhci_command *cmd,\r\nint slot_id, unsigned int ep_index)\r\n{\r\nu32 trb_slot_id = SLOT_ID_FOR_TRB(slot_id);\r\nu32 trb_ep_index = EP_ID_FOR_TRB(ep_index);\r\nu32 type = TRB_TYPE(TRB_RESET_EP);\r\nreturn queue_command(xhci, cmd, 0, 0, 0,\r\ntrb_slot_id | trb_ep_index | type, false);\r\n}
