static void adf_chr_drv_destroy(void)\r\n{\r\ndevice_destroy(adf_ctl_drv.drv_class, MKDEV(adf_ctl_drv.major, 0));\r\ncdev_del(&adf_ctl_drv.drv_cdev);\r\nclass_destroy(adf_ctl_drv.drv_class);\r\nunregister_chrdev_region(MKDEV(adf_ctl_drv.major, 0), 1);\r\n}\r\nstatic int adf_chr_drv_create(void)\r\n{\r\ndev_t dev_id;\r\nstruct device *drv_device;\r\nif (alloc_chrdev_region(&dev_id, 0, 1, DEVICE_NAME)) {\r\npr_err("QAT: unable to allocate chrdev region\n");\r\nreturn -EFAULT;\r\n}\r\nadf_ctl_drv.drv_class = class_create(THIS_MODULE, DEVICE_NAME);\r\nif (IS_ERR(adf_ctl_drv.drv_class)) {\r\npr_err("QAT: class_create failed for adf_ctl\n");\r\ngoto err_chrdev_unreg;\r\n}\r\nadf_ctl_drv.major = MAJOR(dev_id);\r\ncdev_init(&adf_ctl_drv.drv_cdev, &adf_ctl_ops);\r\nif (cdev_add(&adf_ctl_drv.drv_cdev, dev_id, 1)) {\r\npr_err("QAT: cdev add failed\n");\r\ngoto err_class_destr;\r\n}\r\ndrv_device = device_create(adf_ctl_drv.drv_class, NULL,\r\nMKDEV(adf_ctl_drv.major, 0),\r\nNULL, DEVICE_NAME);\r\nif (IS_ERR(drv_device)) {\r\npr_err("QAT: failed to create device\n");\r\ngoto err_cdev_del;\r\n}\r\nreturn 0;\r\nerr_cdev_del:\r\ncdev_del(&adf_ctl_drv.drv_cdev);\r\nerr_class_destr:\r\nclass_destroy(adf_ctl_drv.drv_class);\r\nerr_chrdev_unreg:\r\nunregister_chrdev_region(dev_id, 1);\r\nreturn -EFAULT;\r\n}\r\nstatic int adf_ctl_alloc_resources(struct adf_user_cfg_ctl_data **ctl_data,\r\nunsigned long arg)\r\n{\r\nstruct adf_user_cfg_ctl_data *cfg_data;\r\ncfg_data = kzalloc(sizeof(*cfg_data), GFP_KERNEL);\r\nif (!cfg_data)\r\nreturn -ENOMEM;\r\ncfg_data->device_id = ADF_CFG_NO_DEVICE;\r\nif (copy_from_user(cfg_data, (void __user *)arg, sizeof(*cfg_data))) {\r\npr_err("QAT: failed to copy from user cfg_data.\n");\r\nkfree(cfg_data);\r\nreturn -EIO;\r\n}\r\n*ctl_data = cfg_data;\r\nreturn 0;\r\n}\r\nstatic int adf_add_key_value_data(struct adf_accel_dev *accel_dev,\r\nconst char *section,\r\nconst struct adf_user_cfg_key_val *key_val)\r\n{\r\nif (key_val->type == ADF_HEX) {\r\nlong *ptr = (long *)key_val->val;\r\nlong val = *ptr;\r\nif (adf_cfg_add_key_value_param(accel_dev, section,\r\nkey_val->key, (void *)val,\r\nkey_val->type)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"failed to add hex keyvalue.\n");\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nif (adf_cfg_add_key_value_param(accel_dev, section,\r\nkey_val->key, key_val->val,\r\nkey_val->type)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"failed to add keyvalue.\n");\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adf_copy_key_value_data(struct adf_accel_dev *accel_dev,\r\nstruct adf_user_cfg_ctl_data *ctl_data)\r\n{\r\nstruct adf_user_cfg_key_val key_val;\r\nstruct adf_user_cfg_key_val *params_head;\r\nstruct adf_user_cfg_section section, *section_head;\r\nsection_head = ctl_data->config_section;\r\nwhile (section_head) {\r\nif (copy_from_user(&section, (void __user *)section_head,\r\nsizeof(*section_head))) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"failed to copy section info\n");\r\ngoto out_err;\r\n}\r\nif (adf_cfg_section_add(accel_dev, section.name)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"failed to add section.\n");\r\ngoto out_err;\r\n}\r\nparams_head = section.params;\r\nwhile (params_head) {\r\nif (copy_from_user(&key_val, (void __user *)params_head,\r\nsizeof(key_val))) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to copy keyvalue.\n");\r\ngoto out_err;\r\n}\r\nif (adf_add_key_value_data(accel_dev, section.name,\r\n&key_val)) {\r\ngoto out_err;\r\n}\r\nparams_head = key_val.next;\r\n}\r\nsection_head = section.next;\r\n}\r\nreturn 0;\r\nout_err:\r\nadf_cfg_del_all(accel_dev);\r\nreturn -EFAULT;\r\n}\r\nstatic int adf_ctl_ioctl_dev_config(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nstruct adf_user_cfg_ctl_data *ctl_data;\r\nstruct adf_accel_dev *accel_dev;\r\nret = adf_ctl_alloc_resources(&ctl_data, arg);\r\nif (ret)\r\nreturn ret;\r\naccel_dev = adf_devmgr_get_dev_by_id(ctl_data->device_id);\r\nif (!accel_dev) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (adf_dev_started(accel_dev)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (adf_copy_key_value_data(accel_dev, ctl_data)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nset_bit(ADF_STATUS_CONFIGURED, &accel_dev->status);\r\nout:\r\nkfree(ctl_data);\r\nreturn ret;\r\n}\r\nstatic int adf_ctl_is_device_in_use(int id)\r\n{\r\nstruct adf_accel_dev *dev;\r\nlist_for_each_entry(dev, adf_devmgr_get_head(), list) {\r\nif (id == dev->accel_id || id == ADF_CFG_ALL_DEVICES) {\r\nif (adf_devmgr_in_reset(dev) || adf_dev_in_use(dev)) {\r\ndev_info(&GET_DEV(dev),\r\n"device qat_dev%d is busy\n",\r\ndev->accel_id);\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void adf_ctl_stop_devices(uint32_t id)\r\n{\r\nstruct adf_accel_dev *accel_dev;\r\nlist_for_each_entry(accel_dev, adf_devmgr_get_head(), list) {\r\nif (id == accel_dev->accel_id || id == ADF_CFG_ALL_DEVICES) {\r\nif (!adf_dev_started(accel_dev))\r\ncontinue;\r\nif (!accel_dev->is_vf)\r\ncontinue;\r\nadf_dev_stop(accel_dev);\r\nadf_dev_shutdown(accel_dev);\r\n}\r\n}\r\nlist_for_each_entry(accel_dev, adf_devmgr_get_head(), list) {\r\nif (id == accel_dev->accel_id || id == ADF_CFG_ALL_DEVICES) {\r\nif (!adf_dev_started(accel_dev))\r\ncontinue;\r\nadf_dev_stop(accel_dev);\r\nadf_dev_shutdown(accel_dev);\r\n}\r\n}\r\n}\r\nstatic int adf_ctl_ioctl_dev_stop(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nstruct adf_user_cfg_ctl_data *ctl_data;\r\nret = adf_ctl_alloc_resources(&ctl_data, arg);\r\nif (ret)\r\nreturn ret;\r\nif (adf_devmgr_verify_id(ctl_data->device_id)) {\r\npr_err("QAT: Device %d not found\n", ctl_data->device_id);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = adf_ctl_is_device_in_use(ctl_data->device_id);\r\nif (ret)\r\ngoto out;\r\nif (ctl_data->device_id == ADF_CFG_ALL_DEVICES)\r\npr_info("QAT: Stopping all acceleration devices.\n");\r\nelse\r\npr_info("QAT: Stopping acceleration device qat_dev%d.\n",\r\nctl_data->device_id);\r\nadf_ctl_stop_devices(ctl_data->device_id);\r\nout:\r\nkfree(ctl_data);\r\nreturn ret;\r\n}\r\nstatic int adf_ctl_ioctl_dev_start(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nstruct adf_user_cfg_ctl_data *ctl_data;\r\nstruct adf_accel_dev *accel_dev;\r\nret = adf_ctl_alloc_resources(&ctl_data, arg);\r\nif (ret)\r\nreturn ret;\r\nret = -ENODEV;\r\naccel_dev = adf_devmgr_get_dev_by_id(ctl_data->device_id);\r\nif (!accel_dev)\r\ngoto out;\r\nif (!adf_dev_started(accel_dev)) {\r\ndev_info(&GET_DEV(accel_dev),\r\n"Starting acceleration device qat_dev%d.\n",\r\nctl_data->device_id);\r\nret = adf_dev_init(accel_dev);\r\nif (!ret)\r\nret = adf_dev_start(accel_dev);\r\n} else {\r\ndev_info(&GET_DEV(accel_dev),\r\n"Acceleration device qat_dev%d already started.\n",\r\nctl_data->device_id);\r\n}\r\nif (ret) {\r\ndev_err(&GET_DEV(accel_dev), "Failed to start qat_dev%d\n",\r\nctl_data->device_id);\r\nadf_dev_stop(accel_dev);\r\nadf_dev_shutdown(accel_dev);\r\n}\r\nout:\r\nkfree(ctl_data);\r\nreturn ret;\r\n}\r\nstatic int adf_ctl_ioctl_get_num_devices(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nuint32_t num_devices = 0;\r\nadf_devmgr_get_num_dev(&num_devices);\r\nif (copy_to_user((void __user *)arg, &num_devices, sizeof(num_devices)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int adf_ctl_ioctl_get_status(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct adf_hw_device_data *hw_data;\r\nstruct adf_dev_status_info dev_info;\r\nstruct adf_accel_dev *accel_dev;\r\nif (copy_from_user(&dev_info, (void __user *)arg,\r\nsizeof(struct adf_dev_status_info))) {\r\npr_err("QAT: failed to copy from user.\n");\r\nreturn -EFAULT;\r\n}\r\naccel_dev = adf_devmgr_get_dev_by_id(dev_info.accel_id);\r\nif (!accel_dev)\r\nreturn -ENODEV;\r\nhw_data = accel_dev->hw_device;\r\ndev_info.state = adf_dev_started(accel_dev) ? DEV_UP : DEV_DOWN;\r\ndev_info.num_ae = hw_data->get_num_aes(hw_data);\r\ndev_info.num_accel = hw_data->get_num_accels(hw_data);\r\ndev_info.num_logical_accel = hw_data->num_logical_accel;\r\ndev_info.banks_per_accel = hw_data->num_banks\r\n/ hw_data->num_logical_accel;\r\nstrlcpy(dev_info.name, hw_data->dev_class->name, sizeof(dev_info.name));\r\ndev_info.instance_id = hw_data->instance_id;\r\ndev_info.type = hw_data->dev_class->type;\r\ndev_info.bus = accel_to_pci_dev(accel_dev)->bus->number;\r\ndev_info.dev = PCI_SLOT(accel_to_pci_dev(accel_dev)->devfn);\r\ndev_info.fun = PCI_FUNC(accel_to_pci_dev(accel_dev)->devfn);\r\nif (copy_to_user((void __user *)arg, &dev_info,\r\nsizeof(struct adf_dev_status_info))) {\r\ndev_err(&GET_DEV(accel_dev), "failed to copy status.\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic long adf_ctl_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&adf_ctl_lock))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase IOCTL_CONFIG_SYS_RESOURCE_PARAMETERS:\r\nret = adf_ctl_ioctl_dev_config(fp, cmd, arg);\r\nbreak;\r\ncase IOCTL_STOP_ACCEL_DEV:\r\nret = adf_ctl_ioctl_dev_stop(fp, cmd, arg);\r\nbreak;\r\ncase IOCTL_START_ACCEL_DEV:\r\nret = adf_ctl_ioctl_dev_start(fp, cmd, arg);\r\nbreak;\r\ncase IOCTL_GET_NUM_DEVICES:\r\nret = adf_ctl_ioctl_get_num_devices(fp, cmd, arg);\r\nbreak;\r\ncase IOCTL_STATUS_ACCEL_DEV:\r\nret = adf_ctl_ioctl_get_status(fp, cmd, arg);\r\nbreak;\r\ndefault:\r\npr_err("QAT: Invalid ioctl\n");\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nmutex_unlock(&adf_ctl_lock);\r\nreturn ret;\r\n}\r\nstatic int __init adf_register_ctl_device_driver(void)\r\n{\r\nmutex_init(&adf_ctl_lock);\r\nif (adf_chr_drv_create())\r\ngoto err_chr_dev;\r\nif (adf_init_aer())\r\ngoto err_aer;\r\nif (adf_init_pf_wq())\r\ngoto err_pf_wq;\r\nif (adf_init_vf_wq())\r\ngoto err_vf_wq;\r\nif (qat_crypto_register())\r\ngoto err_crypto_register;\r\nreturn 0;\r\nerr_crypto_register:\r\nadf_exit_vf_wq();\r\nerr_vf_wq:\r\nadf_exit_pf_wq();\r\nerr_pf_wq:\r\nadf_exit_aer();\r\nerr_aer:\r\nadf_chr_drv_destroy();\r\nerr_chr_dev:\r\nmutex_destroy(&adf_ctl_lock);\r\nreturn -EFAULT;\r\n}\r\nstatic void __exit adf_unregister_ctl_device_driver(void)\r\n{\r\nadf_chr_drv_destroy();\r\nadf_exit_aer();\r\nadf_exit_vf_wq();\r\nadf_exit_pf_wq();\r\nqat_crypto_unregister();\r\nadf_clean_vf_map(false);\r\nmutex_destroy(&adf_ctl_lock);\r\n}
