static u32 da9150_fg_read_attr(struct da9150_fg *fg, u8 code, u8 size)\r\n{\r\nu8 buf[size];\r\nu8 read_addr;\r\nu32 res = 0;\r\nint i;\r\nread_addr = (code & DA9150_QIF_CODE_MASK) | DA9150_QIF_READ;\r\nda9150_read_qif(fg->da9150, read_addr, size, buf);\r\nfor (i = 0; i < size; ++i)\r\nres |= (buf[i] << (i * DA9150_QIF_BYTE_SIZE));\r\nreturn res;\r\n}\r\nstatic void da9150_fg_write_attr(struct da9150_fg *fg, u8 code, u8 size,\r\nu32 val)\r\n{\r\nu8 buf[size];\r\nu8 write_addr;\r\nint i;\r\nwrite_addr = (code & DA9150_QIF_CODE_MASK) | DA9150_QIF_WRITE;\r\nfor (i = 0; i < size; ++i) {\r\nbuf[i] = (val >> (i * DA9150_QIF_BYTE_SIZE)) &\r\nDA9150_QIF_BYTE_MASK;\r\n}\r\nda9150_write_qif(fg->da9150, write_addr, size, buf);\r\n}\r\nstatic void da9150_fg_read_sync_start(struct da9150_fg *fg)\r\n{\r\nint i = 0;\r\nu32 res = 0;\r\nmutex_lock(&fg->io_lock);\r\nres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\r\nDA9150_QIF_SYNC_SIZE);\r\nif (res > 0)\r\nda9150_fg_write_attr(fg, DA9150_QIF_SYNC,\r\nDA9150_QIF_SYNC_SIZE, 0);\r\nres = 0;\r\nwhile ((res == 0) && (i++ < DA9150_QIF_SYNC_RETRIES)) {\r\nusleep_range(DA9150_QIF_SYNC_TIMEOUT,\r\nDA9150_QIF_SYNC_TIMEOUT * 2);\r\nres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\r\nDA9150_QIF_SYNC_SIZE);\r\n}\r\nif (res == 0)\r\ndev_err(fg->dev, "Failed to perform QIF read sync!\n");\r\n}\r\nstatic inline void da9150_fg_read_sync_end(struct da9150_fg *fg)\r\n{\r\nmutex_unlock(&fg->io_lock);\r\n}\r\nstatic u32 da9150_fg_read_attr_sync(struct da9150_fg *fg, u8 code, u8 size)\r\n{\r\nu32 val;\r\nda9150_fg_read_sync_start(fg);\r\nval = da9150_fg_read_attr(fg, code, size);\r\nda9150_fg_read_sync_end(fg);\r\nreturn val;\r\n}\r\nstatic void da9150_fg_write_attr_sync(struct da9150_fg *fg, u8 code, u8 size,\r\nu32 val)\r\n{\r\nint i = 0;\r\nu32 res = 0, sync_val;\r\nmutex_lock(&fg->io_lock);\r\nres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\r\nDA9150_QIF_SYNC_SIZE);\r\nwhile ((res == 0) && (i++ < DA9150_QIF_SYNC_RETRIES)) {\r\nusleep_range(DA9150_QIF_SYNC_TIMEOUT,\r\nDA9150_QIF_SYNC_TIMEOUT * 2);\r\nres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\r\nDA9150_QIF_SYNC_SIZE);\r\n}\r\nif (res == 0) {\r\ndev_err(fg->dev, "Timeout waiting for existing QIF sync!\n");\r\nmutex_unlock(&fg->io_lock);\r\nreturn;\r\n}\r\nda9150_fg_write_attr(fg, code, size, val);\r\ni = 0;\r\nsync_val = res;\r\nwhile ((res == sync_val) && (i++ < DA9150_QIF_SYNC_RETRIES)) {\r\nusleep_range(DA9150_QIF_SYNC_TIMEOUT,\r\nDA9150_QIF_SYNC_TIMEOUT * 2);\r\nres = da9150_fg_read_attr(fg, DA9150_QIF_SYNC,\r\nDA9150_QIF_SYNC_SIZE);\r\n}\r\nmutex_unlock(&fg->io_lock);\r\nif (res != (sync_val + 1))\r\ndev_err(fg->dev, "Error performing QIF sync write for code %d\n",\r\ncode);\r\n}\r\nstatic int da9150_fg_capacity(struct da9150_fg *fg,\r\nunion power_supply_propval *val)\r\n{\r\nval->intval = da9150_fg_read_attr_sync(fg, DA9150_QIF_SOC_PCT,\r\nDA9150_QIF_SOC_PCT_SIZE);\r\nif (val->intval > 100)\r\nval->intval = 100;\r\nreturn 0;\r\n}\r\nstatic int da9150_fg_current_avg(struct da9150_fg *fg,\r\nunion power_supply_propval *val)\r\n{\r\nu32 iavg, sd_gain, shunt_val;\r\nu64 div, res;\r\nda9150_fg_read_sync_start(fg);\r\niavg = da9150_fg_read_attr(fg, DA9150_QIF_IAVG,\r\nDA9150_QIF_IAVG_SIZE);\r\nshunt_val = da9150_fg_read_attr(fg, DA9150_QIF_SHUNT_VAL,\r\nDA9150_QIF_SHUNT_VAL_SIZE);\r\nsd_gain = da9150_fg_read_attr(fg, DA9150_QIF_SD_GAIN,\r\nDA9150_QIF_SD_GAIN_SIZE);\r\nda9150_fg_read_sync_end(fg);\r\ndiv = (u64) (sd_gain * shunt_val * 65536ULL);\r\ndo_div(div, 1000000);\r\nres = (u64) (iavg * 1000000ULL);\r\ndo_div(res, div);\r\nval->intval = (int) res;\r\nreturn 0;\r\n}\r\nstatic int da9150_fg_voltage_avg(struct da9150_fg *fg,\r\nunion power_supply_propval *val)\r\n{\r\nu64 res;\r\nval->intval = da9150_fg_read_attr_sync(fg, DA9150_QIF_UAVG,\r\nDA9150_QIF_UAVG_SIZE);\r\nres = (u64) (val->intval * 186ULL);\r\ndo_div(res, 10000);\r\nval->intval = (int) res;\r\nreturn 0;\r\n}\r\nstatic int da9150_fg_charge_full(struct da9150_fg *fg,\r\nunion power_supply_propval *val)\r\n{\r\nval->intval = da9150_fg_read_attr_sync(fg, DA9150_QIF_FCC_MAH,\r\nDA9150_QIF_FCC_MAH_SIZE);\r\nval->intval = val->intval * 1000;\r\nreturn 0;\r\n}\r\nstatic int da9150_fg_temp(struct da9150_fg *fg,\r\nunion power_supply_propval *val)\r\n{\r\nval->intval = da9150_fg_read_attr_sync(fg, DA9150_QIF_NTCAVG,\r\nDA9150_QIF_NTCAVG_SIZE);\r\nval->intval = (val->intval * 10) / 1048576;\r\nreturn 0;\r\n}\r\nstatic int da9150_fg_get_prop(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct da9150_fg *fg = dev_get_drvdata(psy->dev.parent);\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = da9150_fg_capacity(fg, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nret = da9150_fg_current_avg(fg, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\nret = da9150_fg_voltage_avg(fg, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nret = da9150_fg_charge_full(fg, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nret = da9150_fg_temp(fg, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool da9150_fg_soc_changed(struct da9150_fg *fg)\r\n{\r\nunion power_supply_propval val;\r\nda9150_fg_capacity(fg, &val);\r\nif (val.intval != fg->soc) {\r\nfg->soc = val.intval;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void da9150_fg_work(struct work_struct *work)\r\n{\r\nstruct da9150_fg *fg = container_of(work, struct da9150_fg, work.work);\r\nif (da9150_fg_soc_changed(fg))\r\npower_supply_changed(fg->battery);\r\nschedule_delayed_work(&fg->work, msecs_to_jiffies(fg->interval));\r\n}\r\nstatic void da9150_fg_soc_event_config(struct da9150_fg *fg)\r\n{\r\nint soc;\r\nsoc = da9150_fg_read_attr_sync(fg, DA9150_QIF_SOC_PCT,\r\nDA9150_QIF_SOC_PCT_SIZE);\r\nif (soc > fg->warn_soc) {\r\nda9150_fg_write_attr_sync(fg, DA9150_QIF_DISCHARGE_LIMIT,\r\nDA9150_QIF_DISCHARGE_LIMIT_SIZE,\r\nfg->warn_soc + 1);\r\n} else if ((soc <= fg->warn_soc) && (soc > fg->crit_soc)) {\r\nda9150_fg_write_attr_sync(fg, DA9150_QIF_DISCHARGE_LIMIT,\r\nDA9150_QIF_DISCHARGE_LIMIT_SIZE,\r\nfg->crit_soc + 1);\r\nda9150_fg_write_attr_sync(fg, DA9150_QIF_CHARGE_LIMIT,\r\nDA9150_QIF_CHARGE_LIMIT_SIZE,\r\nfg->warn_soc);\r\n} else if (soc <= fg->crit_soc) {\r\nda9150_fg_write_attr_sync(fg, DA9150_QIF_CHARGE_LIMIT,\r\nDA9150_QIF_CHARGE_LIMIT_SIZE,\r\nfg->crit_soc);\r\n}\r\n}\r\nstatic irqreturn_t da9150_fg_irq(int irq, void *data)\r\n{\r\nstruct da9150_fg *fg = data;\r\nu32 e_fg_status;\r\ne_fg_status = da9150_fg_read_attr(fg, DA9150_QIF_E_FG_STATUS,\r\nDA9150_QIF_E_FG_STATUS_SIZE);\r\nif (e_fg_status & DA9150_FG_IRQ_SOC_MASK)\r\nda9150_fg_soc_event_config(fg);\r\nda9150_fg_write_attr(fg, DA9150_QIF_E_FG_STATUS,\r\nDA9150_QIF_E_FG_STATUS_SIZE, e_fg_status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct da9150_fg_pdata *da9150_fg_dt_pdata(struct device *dev)\r\n{\r\nstruct device_node *fg_node = dev->of_node;\r\nstruct da9150_fg_pdata *pdata;\r\npdata = devm_kzalloc(dev, sizeof(struct da9150_fg_pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nof_property_read_u32(fg_node, "dlg,update-interval",\r\n&pdata->update_interval);\r\nof_property_read_u8(fg_node, "dlg,warn-soc-level",\r\n&pdata->warn_soc_lvl);\r\nof_property_read_u8(fg_node, "dlg,crit-soc-level",\r\n&pdata->crit_soc_lvl);\r\nreturn pdata;\r\n}\r\nstatic int da9150_fg_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct da9150 *da9150 = dev_get_drvdata(dev->parent);\r\nstruct da9150_fg_pdata *fg_pdata = dev_get_platdata(dev);\r\nstruct da9150_fg *fg;\r\nint ver, irq, ret = 0;\r\nfg = devm_kzalloc(dev, sizeof(*fg), GFP_KERNEL);\r\nif (fg == NULL)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, fg);\r\nfg->da9150 = da9150;\r\nfg->dev = dev;\r\nmutex_init(&fg->io_lock);\r\nda9150_set_bits(da9150, DA9150_CORE2WIRE_CTRL_A, DA9150_FG_QIF_EN_MASK,\r\nDA9150_FG_QIF_EN_MASK);\r\nfg->battery = devm_power_supply_register(dev, &fg_desc, NULL);\r\nif (IS_ERR(fg->battery)) {\r\nret = PTR_ERR(fg->battery);\r\nreturn ret;\r\n}\r\nver = da9150_fg_read_attr(fg, DA9150_QIF_FW_MAIN_VER,\r\nDA9150_QIF_FW_MAIN_VER_SIZE);\r\ndev_info(dev, "Version: 0x%x\n", ver);\r\nif (dev->of_node) {\r\nfg_pdata = da9150_fg_dt_pdata(dev);\r\ndev->platform_data = fg_pdata;\r\n}\r\nif (fg_pdata) {\r\nfg->interval = fg_pdata->update_interval;\r\nif (fg_pdata->warn_soc_lvl > 100)\r\ndev_warn(dev, "Invalid SOC warning level provided, Ignoring");\r\nelse\r\nfg->warn_soc = fg_pdata->warn_soc_lvl;\r\nif ((fg_pdata->crit_soc_lvl > 100) ||\r\n(fg_pdata->crit_soc_lvl >= fg_pdata->warn_soc_lvl))\r\ndev_warn(dev, "Invalid SOC critical level provided, Ignoring");\r\nelse\r\nfg->crit_soc = fg_pdata->crit_soc_lvl;\r\n}\r\nda9150_fg_soc_event_config(fg);\r\nif (fg->interval) {\r\nINIT_DELAYED_WORK(&fg->work, da9150_fg_work);\r\nschedule_delayed_work(&fg->work,\r\nmsecs_to_jiffies(fg->interval));\r\n}\r\nirq = platform_get_irq_byname(pdev, "FG");\r\nif (irq < 0) {\r\ndev_err(dev, "Failed to get IRQ FG: %d\n", irq);\r\nret = irq;\r\ngoto irq_fail;\r\n}\r\nret = devm_request_threaded_irq(dev, irq, NULL, da9150_fg_irq,\r\nIRQF_ONESHOT, "FG", fg);\r\nif (ret) {\r\ndev_err(dev, "Failed to request IRQ %d: %d\n", irq, ret);\r\ngoto irq_fail;\r\n}\r\nreturn 0;\r\nirq_fail:\r\nif (fg->interval)\r\ncancel_delayed_work(&fg->work);\r\nreturn ret;\r\n}\r\nstatic int da9150_fg_remove(struct platform_device *pdev)\r\n{\r\nstruct da9150_fg *fg = platform_get_drvdata(pdev);\r\nif (fg->interval)\r\ncancel_delayed_work(&fg->work);\r\nreturn 0;\r\n}\r\nstatic int da9150_fg_resume(struct platform_device *pdev)\r\n{\r\nstruct da9150_fg *fg = platform_get_drvdata(pdev);\r\nif (fg->interval)\r\nflush_delayed_work(&fg->work);\r\nreturn 0;\r\n}
