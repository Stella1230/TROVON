static int sst_byt_parse_module(struct sst_dsp *dsp, struct sst_fw *fw,\r\nstruct sst_byt_fw_module_header *module)\r\n{\r\nstruct dma_block_info *block;\r\nstruct sst_module *mod;\r\nstruct sst_module_template template;\r\nint count;\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.id = module->type;\r\ntemplate.entry = module->entry_point;\r\nmod = sst_module_new(fw, &template, NULL);\r\nif (mod == NULL)\r\nreturn -ENOMEM;\r\nblock = (void *)module + sizeof(*module);\r\nfor (count = 0; count < module->blocks; count++) {\r\nif (block->size <= 0) {\r\ndev_err(dsp->dev, "block %d size invalid\n", count);\r\nreturn -EINVAL;\r\n}\r\nswitch (block->type) {\r\ncase SST_BYT_IRAM:\r\nmod->offset = block->ram_offset +\r\ndsp->addr.iram_offset;\r\nmod->type = SST_MEM_IRAM;\r\nbreak;\r\ncase SST_BYT_DRAM:\r\nmod->offset = block->ram_offset +\r\ndsp->addr.dram_offset;\r\nmod->type = SST_MEM_DRAM;\r\nbreak;\r\ncase SST_BYT_CACHE:\r\nmod->offset = block->ram_offset +\r\n(dsp->addr.fw_ext - dsp->addr.lpe);\r\nmod->type = SST_MEM_CACHE;\r\nbreak;\r\ndefault:\r\ndev_err(dsp->dev, "wrong ram type 0x%x in block0x%x\n",\r\nblock->type, count);\r\nreturn -EINVAL;\r\n}\r\nmod->size = block->size;\r\nmod->data = (void *)block + sizeof(*block);\r\nsst_module_alloc_blocks(mod);\r\nblock = (void *)block + sizeof(*block) + block->size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_byt_parse_fw_image(struct sst_fw *sst_fw)\r\n{\r\nstruct fw_header *header;\r\nstruct sst_byt_fw_module_header *module;\r\nstruct sst_dsp *dsp = sst_fw->dsp;\r\nint ret, count;\r\nheader = (struct fw_header *)sst_fw->dma_buf;\r\nif ((strncmp(header->signature, SST_BYT_FW_SIGN, 4) != 0) ||\r\n(sst_fw->size != header->file_size + sizeof(*header))) {\r\ndev_err(dsp->dev, "Invalid FW sign/filesize mismatch\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dsp->dev,\r\n"header sign=%4s size=0x%x modules=0x%x fmt=0x%x size=%zu\n",\r\nheader->signature, header->file_size, header->modules,\r\nheader->file_format, sizeof(*header));\r\nmodule = (void *)sst_fw->dma_buf + sizeof(*header);\r\nfor (count = 0; count < header->modules; count++) {\r\nret = sst_byt_parse_module(dsp, sst_fw, module);\r\nif (ret < 0) {\r\ndev_err(dsp->dev, "invalid module %d\n", count);\r\nreturn ret;\r\n}\r\nmodule = (void *)module + sizeof(*module) + module->mod_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sst_byt_dump_shim(struct sst_dsp *sst)\r\n{\r\nint i;\r\nu64 reg;\r\nfor (i = 0; i <= 0xF0; i += 8) {\r\nreg = sst_dsp_shim_read64_unlocked(sst, i);\r\nif (reg)\r\ndev_dbg(sst->dev, "shim 0x%2.2x value 0x%16.16llx\n",\r\ni, reg);\r\n}\r\nfor (i = 0x00; i <= 0xff; i += 4) {\r\nreg = readl(sst->addr.pci_cfg + i);\r\nif (reg)\r\ndev_dbg(sst->dev, "pci 0x%2.2x value 0x%8.8x\n",\r\ni, (u32)reg);\r\n}\r\n}\r\nstatic irqreturn_t sst_byt_irq(int irq, void *context)\r\n{\r\nstruct sst_dsp *sst = (struct sst_dsp *) context;\r\nu64 isrx;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&sst->spinlock);\r\nisrx = sst_dsp_shim_read64_unlocked(sst, SST_ISRX);\r\nif (isrx & SST_ISRX_DONE) {\r\nsst_dsp_shim_update_bits64_unlocked(sst, SST_IPCX,\r\nSST_BYT_IPCX_DONE, 0);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nif (isrx & SST_BYT_ISRX_REQUEST) {\r\nsst_dsp_shim_update_bits64_unlocked(sst, SST_IMRX,\r\nSST_BYT_IMRX_REQUEST,\r\nSST_BYT_IMRX_REQUEST);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nspin_unlock(&sst->spinlock);\r\nreturn ret;\r\n}\r\nstatic void sst_byt_boot(struct sst_dsp *sst)\r\n{\r\nint tries = 10;\r\nmemcpy_toio(sst->addr.lpe + SST_BYT_MAILBOX_OFFSET,\r\n&sst->pdata->fw_base, sizeof(u32));\r\nsst_dsp_shim_update_bits64(sst, SST_CSR, SST_BYT_CSR_STALL, 0x0);\r\nwhile (tries--) {\r\nif (!(sst_dsp_shim_read64(sst, SST_CSR) &\r\nSST_BYT_CSR_PWAITMODE))\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (tries < 0) {\r\ndev_err(sst->dev, "unable to start DSP\n");\r\nsst_byt_dump_shim(sst);\r\n}\r\n}\r\nstatic void sst_byt_reset(struct sst_dsp *sst)\r\n{\r\nsst_dsp_shim_update_bits64(sst, SST_CSR,\r\nSST_BYT_CSR_RST | SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL,\r\nSST_BYT_CSR_RST | SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL);\r\nudelay(10);\r\nsst_dsp_shim_update_bits64(sst, SST_CSR, SST_BYT_CSR_RST, 0);\r\n}\r\nstatic int sst_byt_resource_map(struct sst_dsp *sst, struct sst_pdata *pdata)\r\n{\r\nsst->addr.lpe_base = pdata->lpe_base;\r\nsst->addr.lpe = ioremap(pdata->lpe_base, pdata->lpe_size);\r\nif (!sst->addr.lpe)\r\nreturn -ENODEV;\r\nsst->addr.pci_cfg = ioremap(pdata->pcicfg_base, pdata->pcicfg_size);\r\nif (!sst->addr.pci_cfg) {\r\niounmap(sst->addr.lpe);\r\nreturn -ENODEV;\r\n}\r\nsst->addr.fw_ext = ioremap(pdata->fw_base, pdata->fw_size);\r\nif (!sst->addr.fw_ext) {\r\niounmap(sst->addr.pci_cfg);\r\niounmap(sst->addr.lpe);\r\nreturn -ENODEV;\r\n}\r\nsst->addr.shim = sst->addr.lpe + sst->addr.shim_offset;\r\nsst_dsp_mailbox_init(sst, SST_BYT_MAILBOX_OFFSET + 0x204,\r\nSST_BYT_IPC_MAX_PAYLOAD_SIZE,\r\nSST_BYT_MAILBOX_OFFSET,\r\nSST_BYT_IPC_MAX_PAYLOAD_SIZE);\r\nsst->irq = pdata->irq;\r\nreturn 0;\r\n}\r\nstatic int sst_byt_init(struct sst_dsp *sst, struct sst_pdata *pdata)\r\n{\r\nconst struct sst_adsp_memregion *region;\r\nstruct device *dev;\r\nint ret = -ENODEV, i, j, region_count;\r\nu32 offset, size;\r\ndev = sst->dev;\r\nswitch (sst->id) {\r\ncase SST_DEV_ID_BYT:\r\nregion = byt_region;\r\nregion_count = ARRAY_SIZE(byt_region);\r\nsst->addr.iram_offset = SST_BYT_IRAM_OFFSET;\r\nsst->addr.dram_offset = SST_BYT_DRAM_OFFSET;\r\nsst->addr.shim_offset = SST_BYT_SHIM_OFFSET;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "failed to get mem resources\n");\r\nreturn ret;\r\n}\r\nret = sst_byt_resource_map(sst, pdata);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to map resources\n");\r\nreturn ret;\r\n}\r\nret = dma_coerce_mask_and_coherent(sst->dma_dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nsst_dsp_shim_update_bits64(sst, SST_IMRX, 0x3, 0x0);\r\nsst_dsp_shim_update_bits64(sst, SST_IMRD, 0x3, 0x0);\r\nfor (i = 0; i < region_count; i++) {\r\noffset = region[i].start;\r\nsize = (region[i].end - region[i].start) / region[i].blocks;\r\nfor (j = 0; j < region[i].blocks; j++) {\r\nsst_mem_block_register(sst, offset, size,\r\nregion[i].type, NULL, j, sst);\r\noffset += size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sst_byt_free(struct sst_dsp *sst)\r\n{\r\nsst_mem_block_unregister_all(sst);\r\niounmap(sst->addr.lpe);\r\niounmap(sst->addr.pci_cfg);\r\niounmap(sst->addr.fw_ext);\r\n}
