void reset_scoop(struct device *dev)\r\n{\r\nstruct scoop_dev *sdev = dev_get_drvdata(dev);\r\niowrite16(0x0100, sdev->base + SCOOP_MCR);\r\niowrite16(0x0000, sdev->base + SCOOP_CDR);\r\niowrite16(0x0000, sdev->base + SCOOP_CCR);\r\niowrite16(0x0000, sdev->base + SCOOP_IMR);\r\niowrite16(0x00FF, sdev->base + SCOOP_IRM);\r\niowrite16(0x0000, sdev->base + SCOOP_ISR);\r\niowrite16(0x0000, sdev->base + SCOOP_IRM);\r\n}\r\nstatic void __scoop_gpio_set(struct scoop_dev *sdev,\r\nunsigned offset, int value)\r\n{\r\nunsigned short gpwr;\r\ngpwr = ioread16(sdev->base + SCOOP_GPWR);\r\nif (value)\r\ngpwr |= 1 << (offset + 1);\r\nelse\r\ngpwr &= ~(1 << (offset + 1));\r\niowrite16(gpwr, sdev->base + SCOOP_GPWR);\r\n}\r\nstatic void scoop_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct scoop_dev *sdev = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&sdev->scoop_lock, flags);\r\n__scoop_gpio_set(sdev, offset, value);\r\nspin_unlock_irqrestore(&sdev->scoop_lock, flags);\r\n}\r\nstatic int scoop_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct scoop_dev *sdev = gpiochip_get_data(chip);\r\nreturn !!(ioread16(sdev->base + SCOOP_GPRR) & (1 << (offset + 1)));\r\n}\r\nstatic int scoop_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct scoop_dev *sdev = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nunsigned short gpcr;\r\nspin_lock_irqsave(&sdev->scoop_lock, flags);\r\ngpcr = ioread16(sdev->base + SCOOP_GPCR);\r\ngpcr &= ~(1 << (offset + 1));\r\niowrite16(gpcr, sdev->base + SCOOP_GPCR);\r\nspin_unlock_irqrestore(&sdev->scoop_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int scoop_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct scoop_dev *sdev = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nunsigned short gpcr;\r\nspin_lock_irqsave(&sdev->scoop_lock, flags);\r\n__scoop_gpio_set(sdev, offset, value);\r\ngpcr = ioread16(sdev->base + SCOOP_GPCR);\r\ngpcr |= 1 << (offset + 1);\r\niowrite16(gpcr, sdev->base + SCOOP_GPCR);\r\nspin_unlock_irqrestore(&sdev->scoop_lock, flags);\r\nreturn 0;\r\n}\r\nunsigned short read_scoop_reg(struct device *dev, unsigned short reg)\r\n{\r\nstruct scoop_dev *sdev = dev_get_drvdata(dev);\r\nreturn ioread16(sdev->base + reg);\r\n}\r\nvoid write_scoop_reg(struct device *dev, unsigned short reg, unsigned short data)\r\n{\r\nstruct scoop_dev *sdev = dev_get_drvdata(dev);\r\niowrite16(data, sdev->base + reg);\r\n}\r\nstatic void check_scoop_reg(struct scoop_dev *sdev)\r\n{\r\nunsigned short mcr;\r\nmcr = ioread16(sdev->base + SCOOP_MCR);\r\nif ((mcr & 0x100) == 0)\r\niowrite16(0x0101, sdev->base + SCOOP_MCR);\r\n}\r\nstatic int scoop_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct scoop_dev *sdev = platform_get_drvdata(dev);\r\ncheck_scoop_reg(sdev);\r\nsdev->scoop_gpwr = ioread16(sdev->base + SCOOP_GPWR);\r\niowrite16((sdev->scoop_gpwr & ~sdev->suspend_clr) | sdev->suspend_set, sdev->base + SCOOP_GPWR);\r\nreturn 0;\r\n}\r\nstatic int scoop_resume(struct platform_device *dev)\r\n{\r\nstruct scoop_dev *sdev = platform_get_drvdata(dev);\r\ncheck_scoop_reg(sdev);\r\niowrite16(sdev->scoop_gpwr, sdev->base + SCOOP_GPWR);\r\nreturn 0;\r\n}\r\nstatic int scoop_probe(struct platform_device *pdev)\r\n{\r\nstruct scoop_dev *devptr;\r\nstruct scoop_config *inf;\r\nstruct resource *mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nint ret;\r\nif (!mem)\r\nreturn -EINVAL;\r\ndevptr = kzalloc(sizeof(struct scoop_dev), GFP_KERNEL);\r\nif (!devptr)\r\nreturn -ENOMEM;\r\nspin_lock_init(&devptr->scoop_lock);\r\ninf = pdev->dev.platform_data;\r\ndevptr->base = ioremap(mem->start, resource_size(mem));\r\nif (!devptr->base) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nplatform_set_drvdata(pdev, devptr);\r\nprintk("Sharp Scoop Device found at 0x%08x -> 0x%8p\n",(unsigned int)mem->start, devptr->base);\r\niowrite16(0x0140, devptr->base + SCOOP_MCR);\r\nreset_scoop(&pdev->dev);\r\niowrite16(0x0000, devptr->base + SCOOP_CPR);\r\niowrite16(inf->io_dir & 0xffff, devptr->base + SCOOP_GPCR);\r\niowrite16(inf->io_out & 0xffff, devptr->base + SCOOP_GPWR);\r\ndevptr->suspend_clr = inf->suspend_clr;\r\ndevptr->suspend_set = inf->suspend_set;\r\ndevptr->gpio.base = -1;\r\nif (inf->gpio_base != 0) {\r\ndevptr->gpio.label = dev_name(&pdev->dev);\r\ndevptr->gpio.base = inf->gpio_base;\r\ndevptr->gpio.ngpio = 12;\r\ndevptr->gpio.set = scoop_gpio_set;\r\ndevptr->gpio.get = scoop_gpio_get;\r\ndevptr->gpio.direction_input = scoop_gpio_direction_input;\r\ndevptr->gpio.direction_output = scoop_gpio_direction_output;\r\nret = gpiochip_add_data(&devptr->gpio, devptr);\r\nif (ret)\r\ngoto err_gpio;\r\n}\r\nreturn 0;\r\nerr_gpio:\r\nplatform_set_drvdata(pdev, NULL);\r\nerr_ioremap:\r\niounmap(devptr->base);\r\nkfree(devptr);\r\nreturn ret;\r\n}\r\nstatic int scoop_remove(struct platform_device *pdev)\r\n{\r\nstruct scoop_dev *sdev = platform_get_drvdata(pdev);\r\nif (!sdev)\r\nreturn -EINVAL;\r\nif (sdev->gpio.base != -1)\r\ngpiochip_remove(&sdev->gpio);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(sdev->base);\r\nkfree(sdev);\r\nreturn 0;\r\n}\r\nstatic int __init scoop_init(void)\r\n{\r\nreturn platform_driver_register(&scoop_driver);\r\n}
