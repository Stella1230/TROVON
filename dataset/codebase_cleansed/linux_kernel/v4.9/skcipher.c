static unsigned int crypto_skcipher_extsize(struct crypto_alg *alg)\r\n{\r\nif (alg->cra_type == &crypto_blkcipher_type)\r\nreturn sizeof(struct crypto_blkcipher *);\r\nif (alg->cra_type == &crypto_ablkcipher_type ||\r\nalg->cra_type == &crypto_givcipher_type)\r\nreturn sizeof(struct crypto_ablkcipher *);\r\nreturn crypto_alg_extsize(alg);\r\n}\r\nstatic int skcipher_setkey_blkcipher(struct crypto_skcipher *tfm,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);\r\nstruct crypto_blkcipher *blkcipher = *ctx;\r\nint err;\r\ncrypto_blkcipher_clear_flags(blkcipher, ~0);\r\ncrypto_blkcipher_set_flags(blkcipher, crypto_skcipher_get_flags(tfm) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_blkcipher_setkey(blkcipher, key, keylen);\r\ncrypto_skcipher_set_flags(tfm, crypto_blkcipher_get_flags(blkcipher) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int skcipher_crypt_blkcipher(struct skcipher_request *req,\r\nint (*crypt)(struct blkcipher_desc *,\r\nstruct scatterlist *,\r\nstruct scatterlist *,\r\nunsigned int))\r\n{\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\r\nstruct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);\r\nstruct blkcipher_desc desc = {\r\n.tfm = *ctx,\r\n.info = req->iv,\r\n.flags = req->base.flags,\r\n};\r\nreturn crypt(&desc, req->dst, req->src, req->cryptlen);\r\n}\r\nstatic int skcipher_encrypt_blkcipher(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);\r\nstruct blkcipher_alg *alg = &tfm->__crt_alg->cra_blkcipher;\r\nreturn skcipher_crypt_blkcipher(req, alg->encrypt);\r\n}\r\nstatic int skcipher_decrypt_blkcipher(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);\r\nstruct blkcipher_alg *alg = &tfm->__crt_alg->cra_blkcipher;\r\nreturn skcipher_crypt_blkcipher(req, alg->decrypt);\r\n}\r\nstatic void crypto_exit_skcipher_ops_blkcipher(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_blkcipher **ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_blkcipher(*ctx);\r\n}\r\nstatic int crypto_init_skcipher_ops_blkcipher(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_alg *calg = tfm->__crt_alg;\r\nstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\r\nstruct crypto_blkcipher **ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_blkcipher *blkcipher;\r\nstruct crypto_tfm *btfm;\r\nif (!crypto_mod_get(calg))\r\nreturn -EAGAIN;\r\nbtfm = __crypto_alloc_tfm(calg, CRYPTO_ALG_TYPE_BLKCIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(btfm)) {\r\ncrypto_mod_put(calg);\r\nreturn PTR_ERR(btfm);\r\n}\r\nblkcipher = __crypto_blkcipher_cast(btfm);\r\n*ctx = blkcipher;\r\ntfm->exit = crypto_exit_skcipher_ops_blkcipher;\r\nskcipher->setkey = skcipher_setkey_blkcipher;\r\nskcipher->encrypt = skcipher_encrypt_blkcipher;\r\nskcipher->decrypt = skcipher_decrypt_blkcipher;\r\nskcipher->ivsize = crypto_blkcipher_ivsize(blkcipher);\r\nskcipher->keysize = calg->cra_blkcipher.max_keysize;\r\nreturn 0;\r\n}\r\nstatic int skcipher_setkey_ablkcipher(struct crypto_skcipher *tfm,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);\r\nstruct crypto_ablkcipher *ablkcipher = *ctx;\r\nint err;\r\ncrypto_ablkcipher_clear_flags(ablkcipher, ~0);\r\ncrypto_ablkcipher_set_flags(ablkcipher,\r\ncrypto_skcipher_get_flags(tfm) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(ablkcipher, key, keylen);\r\ncrypto_skcipher_set_flags(tfm,\r\ncrypto_ablkcipher_get_flags(ablkcipher) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int skcipher_crypt_ablkcipher(struct skcipher_request *req,\r\nint (*crypt)(struct ablkcipher_request *))\r\n{\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\r\nstruct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);\r\nstruct ablkcipher_request *subreq = skcipher_request_ctx(req);\r\nablkcipher_request_set_tfm(subreq, *ctx);\r\nablkcipher_request_set_callback(subreq, skcipher_request_flags(req),\r\nreq->base.complete, req->base.data);\r\nablkcipher_request_set_crypt(subreq, req->src, req->dst, req->cryptlen,\r\nreq->iv);\r\nreturn crypt(subreq);\r\n}\r\nstatic int skcipher_encrypt_ablkcipher(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);\r\nstruct ablkcipher_alg *alg = &tfm->__crt_alg->cra_ablkcipher;\r\nreturn skcipher_crypt_ablkcipher(req, alg->encrypt);\r\n}\r\nstatic int skcipher_decrypt_ablkcipher(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);\r\nstruct ablkcipher_alg *alg = &tfm->__crt_alg->cra_ablkcipher;\r\nreturn skcipher_crypt_ablkcipher(req, alg->decrypt);\r\n}\r\nstatic void crypto_exit_skcipher_ops_ablkcipher(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_ablkcipher **ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_ablkcipher(*ctx);\r\n}\r\nstatic int crypto_init_skcipher_ops_ablkcipher(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_alg *calg = tfm->__crt_alg;\r\nstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\r\nstruct crypto_ablkcipher **ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_ablkcipher *ablkcipher;\r\nstruct crypto_tfm *abtfm;\r\nif (!crypto_mod_get(calg))\r\nreturn -EAGAIN;\r\nabtfm = __crypto_alloc_tfm(calg, 0, 0);\r\nif (IS_ERR(abtfm)) {\r\ncrypto_mod_put(calg);\r\nreturn PTR_ERR(abtfm);\r\n}\r\nablkcipher = __crypto_ablkcipher_cast(abtfm);\r\n*ctx = ablkcipher;\r\ntfm->exit = crypto_exit_skcipher_ops_ablkcipher;\r\nskcipher->setkey = skcipher_setkey_ablkcipher;\r\nskcipher->encrypt = skcipher_encrypt_ablkcipher;\r\nskcipher->decrypt = skcipher_decrypt_ablkcipher;\r\nskcipher->ivsize = crypto_ablkcipher_ivsize(ablkcipher);\r\nskcipher->reqsize = crypto_ablkcipher_reqsize(ablkcipher) +\r\nsizeof(struct ablkcipher_request);\r\nskcipher->keysize = calg->cra_ablkcipher.max_keysize;\r\nreturn 0;\r\n}\r\nstatic void crypto_skcipher_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\r\nstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\r\nalg->exit(skcipher);\r\n}\r\nstatic int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\r\nstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\r\nif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\r\nreturn crypto_init_skcipher_ops_blkcipher(tfm);\r\nif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\r\ntfm->__crt_alg->cra_type == &crypto_givcipher_type)\r\nreturn crypto_init_skcipher_ops_ablkcipher(tfm);\r\nskcipher->setkey = alg->setkey;\r\nskcipher->encrypt = alg->encrypt;\r\nskcipher->decrypt = alg->decrypt;\r\nskcipher->ivsize = alg->ivsize;\r\nskcipher->keysize = alg->max_keysize;\r\nif (alg->exit)\r\nskcipher->base.exit = crypto_skcipher_exit_tfm;\r\nif (alg->init)\r\nreturn alg->init(skcipher);\r\nreturn 0;\r\n}\r\nstatic void crypto_skcipher_free_instance(struct crypto_instance *inst)\r\n{\r\nstruct skcipher_instance *skcipher =\r\ncontainer_of(inst, struct skcipher_instance, s.base);\r\nskcipher->free(skcipher);\r\n}\r\nstatic void crypto_skcipher_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nstruct skcipher_alg *skcipher = container_of(alg, struct skcipher_alg,\r\nbase);\r\nseq_printf(m, "type : skcipher\n");\r\nseq_printf(m, "async : %s\n",\r\nalg->cra_flags & CRYPTO_ALG_ASYNC ? "yes" : "no");\r\nseq_printf(m, "blocksize : %u\n", alg->cra_blocksize);\r\nseq_printf(m, "min keysize : %u\n", skcipher->min_keysize);\r\nseq_printf(m, "max keysize : %u\n", skcipher->max_keysize);\r\nseq_printf(m, "ivsize : %u\n", skcipher->ivsize);\r\nseq_printf(m, "chunksize : %u\n", skcipher->chunksize);\r\n}\r\nstatic int crypto_skcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_blkcipher rblkcipher;\r\nstruct skcipher_alg *skcipher = container_of(alg, struct skcipher_alg,\r\nbase);\r\nstrncpy(rblkcipher.type, "skcipher", sizeof(rblkcipher.type));\r\nstrncpy(rblkcipher.geniv, "<none>", sizeof(rblkcipher.geniv));\r\nrblkcipher.blocksize = alg->cra_blocksize;\r\nrblkcipher.min_keysize = skcipher->min_keysize;\r\nrblkcipher.max_keysize = skcipher->max_keysize;\r\nrblkcipher.ivsize = skcipher->ivsize;\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\r\nsizeof(struct crypto_report_blkcipher), &rblkcipher))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_skcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint crypto_grab_skcipher(struct crypto_skcipher_spawn *spawn,\r\nconst char *name, u32 type, u32 mask)\r\n{\r\nspawn->base.frontend = &crypto_skcipher_type2;\r\nreturn crypto_grab_spawn(&spawn->base, name, type, mask);\r\n}\r\nstruct crypto_skcipher *crypto_alloc_skcipher(const char *alg_name,\r\nu32 type, u32 mask)\r\n{\r\nreturn crypto_alloc_tfm(alg_name, &crypto_skcipher_type2, type, mask);\r\n}\r\nint crypto_has_skcipher2(const char *alg_name, u32 type, u32 mask)\r\n{\r\nreturn crypto_type_has_alg(alg_name, &crypto_skcipher_type2,\r\ntype, mask);\r\n}\r\nstatic int skcipher_prepare_alg(struct skcipher_alg *alg)\r\n{\r\nstruct crypto_alg *base = &alg->base;\r\nif (alg->ivsize > PAGE_SIZE / 8 || alg->chunksize > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\nif (!alg->chunksize)\r\nalg->chunksize = base->cra_blocksize;\r\nbase->cra_type = &crypto_skcipher_type2;\r\nbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\r\nbase->cra_flags |= CRYPTO_ALG_TYPE_SKCIPHER;\r\nreturn 0;\r\n}\r\nint crypto_register_skcipher(struct skcipher_alg *alg)\r\n{\r\nstruct crypto_alg *base = &alg->base;\r\nint err;\r\nerr = skcipher_prepare_alg(alg);\r\nif (err)\r\nreturn err;\r\nreturn crypto_register_alg(base);\r\n}\r\nvoid crypto_unregister_skcipher(struct skcipher_alg *alg)\r\n{\r\ncrypto_unregister_alg(&alg->base);\r\n}\r\nint crypto_register_skciphers(struct skcipher_alg *algs, int count)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nret = crypto_register_skcipher(&algs[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (--i; i >= 0; --i)\r\ncrypto_unregister_skcipher(&algs[i]);\r\nreturn ret;\r\n}\r\nvoid crypto_unregister_skciphers(struct skcipher_alg *algs, int count)\r\n{\r\nint i;\r\nfor (i = count - 1; i >= 0; --i)\r\ncrypto_unregister_skcipher(&algs[i]);\r\n}\r\nint skcipher_register_instance(struct crypto_template *tmpl,\r\nstruct skcipher_instance *inst)\r\n{\r\nint err;\r\nerr = skcipher_prepare_alg(&inst->alg);\r\nif (err)\r\nreturn err;\r\nreturn crypto_register_instance(tmpl, skcipher_crypto_instance(inst));\r\n}
