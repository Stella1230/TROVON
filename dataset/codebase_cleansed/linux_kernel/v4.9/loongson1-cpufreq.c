static int ls1x_cpufreq_notifier(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nif (val == CPUFREQ_POSTCHANGE)\r\ncurrent_cpu_data.udelay_val = loops_per_jiffy;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int ls1x_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nstruct device *cpu_dev = get_cpu_device(policy->cpu);\r\nunsigned int old_freq, new_freq;\r\nold_freq = policy->cur;\r\nnew_freq = policy->freq_table[index].frequency;\r\nclk_set_parent(policy->clk, cpufreq->osc_clk);\r\n__raw_writel(__raw_readl(LS1X_CLK_PLL_DIV) | RST_CPU_EN | RST_CPU,\r\nLS1X_CLK_PLL_DIV);\r\n__raw_writel(__raw_readl(LS1X_CLK_PLL_DIV) & ~(RST_CPU_EN | RST_CPU),\r\nLS1X_CLK_PLL_DIV);\r\nclk_set_rate(cpufreq->mux_clk, new_freq * 1000);\r\nclk_set_parent(policy->clk, cpufreq->mux_clk);\r\ndev_dbg(cpu_dev, "%u KHz --> %u KHz\n", old_freq, new_freq);\r\nreturn 0;\r\n}\r\nstatic int ls1x_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nstruct device *cpu_dev = get_cpu_device(policy->cpu);\r\nstruct cpufreq_frequency_table *freq_tbl;\r\nunsigned int pll_freq, freq;\r\nint steps, i, ret;\r\npll_freq = clk_get_rate(cpufreq->pll_clk) / 1000;\r\nsteps = 1 << DIV_CPU_WIDTH;\r\nfreq_tbl = kcalloc(steps, sizeof(*freq_tbl), GFP_KERNEL);\r\nif (!freq_tbl)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < (steps - 1); i++) {\r\nfreq = pll_freq / (i + 1);\r\nif ((freq < cpufreq->min_freq) || (freq > cpufreq->max_freq))\r\nfreq_tbl[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nelse\r\nfreq_tbl[i].frequency = freq;\r\ndev_dbg(cpu_dev,\r\n"cpufreq table: index %d: frequency %d\n", i,\r\nfreq_tbl[i].frequency);\r\n}\r\nfreq_tbl[i].frequency = CPUFREQ_TABLE_END;\r\npolicy->clk = cpufreq->clk;\r\nret = cpufreq_generic_init(policy, freq_tbl, 0);\r\nif (ret)\r\nkfree(freq_tbl);\r\nreturn ret;\r\n}\r\nstatic int ls1x_cpufreq_exit(struct cpufreq_policy *policy)\r\n{\r\nkfree(policy->freq_table);\r\nreturn 0;\r\n}\r\nstatic int ls1x_cpufreq_remove(struct platform_device *pdev)\r\n{\r\ncpufreq_unregister_notifier(&ls1x_cpufreq_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\ncpufreq_unregister_driver(&ls1x_cpufreq_driver);\r\nreturn 0;\r\n}\r\nstatic int ls1x_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_ls1x_cpufreq *pdata = dev_get_platdata(&pdev->dev);\r\nstruct clk *clk;\r\nint ret;\r\nif (!pdata || !pdata->clk_name || !pdata->osc_clk_name) {\r\ndev_err(&pdev->dev, "platform data missing\n");\r\nreturn -EINVAL;\r\n}\r\ncpufreq =\r\ndevm_kzalloc(&pdev->dev, sizeof(struct ls1x_cpufreq), GFP_KERNEL);\r\nif (!cpufreq)\r\nreturn -ENOMEM;\r\ncpufreq->dev = &pdev->dev;\r\nclk = devm_clk_get(&pdev->dev, pdata->clk_name);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "unable to get %s clock\n",\r\npdata->clk_name);\r\nreturn PTR_ERR(clk);\r\n}\r\ncpufreq->clk = clk;\r\nclk = clk_get_parent(clk);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "unable to get parent of %s clock\n",\r\n__clk_get_name(cpufreq->clk));\r\nreturn PTR_ERR(clk);\r\n}\r\ncpufreq->mux_clk = clk;\r\nclk = clk_get_parent(clk);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "unable to get parent of %s clock\n",\r\n__clk_get_name(cpufreq->mux_clk));\r\nreturn PTR_ERR(clk);\r\n}\r\ncpufreq->pll_clk = clk;\r\nclk = devm_clk_get(&pdev->dev, pdata->osc_clk_name);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "unable to get %s clock\n",\r\npdata->osc_clk_name);\r\nreturn PTR_ERR(clk);\r\n}\r\ncpufreq->osc_clk = clk;\r\ncpufreq->max_freq = pdata->max_freq;\r\ncpufreq->min_freq = pdata->min_freq;\r\nret = cpufreq_register_driver(&ls1x_cpufreq_driver);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to register CPUFreq driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = cpufreq_register_notifier(&ls1x_cpufreq_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to register CPUFreq notifier: %d\n",ret);\r\ncpufreq_unregister_driver(&ls1x_cpufreq_driver);\r\n}\r\nreturn ret;\r\n}
