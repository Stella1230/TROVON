void ath9k_hw_analog_shift_regwrite(struct ath_hw *ah, u32 reg, u32 val)\r\n{\r\nREG_WRITE(ah, reg, val);\r\nif (ah->config.analog_shiftreg)\r\nudelay(100);\r\n}\r\nvoid ath9k_hw_analog_shift_rmw(struct ath_hw *ah, u32 reg, u32 mask,\r\nu32 shift, u32 val)\r\n{\r\nREG_RMW(ah, reg, ((val << shift) & mask), mask);\r\nif (ah->config.analog_shiftreg)\r\nudelay(100);\r\n}\r\nint16_t ath9k_hw_interpolate(u16 target, u16 srcLeft, u16 srcRight,\r\nint16_t targetLeft, int16_t targetRight)\r\n{\r\nint16_t rv;\r\nif (srcRight == srcLeft) {\r\nrv = targetLeft;\r\n} else {\r\nrv = (int16_t) (((target - srcLeft) * targetRight +\r\n(srcRight - target) * targetLeft) /\r\n(srcRight - srcLeft));\r\n}\r\nreturn rv;\r\n}\r\nbool ath9k_hw_get_lower_upper_index(u8 target, u8 *pList, u16 listSize,\r\nu16 *indexL, u16 *indexR)\r\n{\r\nu16 i;\r\nif (target <= pList[0]) {\r\n*indexL = *indexR = 0;\r\nreturn true;\r\n}\r\nif (target >= pList[listSize - 1]) {\r\n*indexL = *indexR = (u16) (listSize - 1);\r\nreturn true;\r\n}\r\nfor (i = 0; i < listSize - 1; i++) {\r\nif (pList[i] == target) {\r\n*indexL = *indexR = i;\r\nreturn true;\r\n}\r\nif (target < pList[i + 1]) {\r\n*indexL = i;\r\n*indexR = (u16) (i + 1);\r\nreturn false;\r\n}\r\n}\r\nreturn false;\r\n}\r\nvoid ath9k_hw_usb_gen_fill_eeprom(struct ath_hw *ah, u16 *eep_data,\r\nint eep_start_loc, int size)\r\n{\r\nint i = 0, j, addr;\r\nu32 addrdata[8];\r\nu32 data[8];\r\nfor (addr = 0; addr < size; addr++) {\r\naddrdata[i] = AR5416_EEPROM_OFFSET +\r\n((addr + eep_start_loc) << AR5416_EEPROM_S);\r\ni++;\r\nif (i == 8) {\r\nREG_READ_MULTI(ah, addrdata, data, i);\r\nfor (j = 0; j < i; j++) {\r\n*eep_data = data[j];\r\neep_data++;\r\n}\r\ni = 0;\r\n}\r\n}\r\nif (i != 0) {\r\nREG_READ_MULTI(ah, addrdata, data, i);\r\nfor (j = 0; j < i; j++) {\r\n*eep_data = data[j];\r\neep_data++;\r\n}\r\n}\r\n}\r\nstatic bool ath9k_hw_nvram_read_array(u16 *blob, size_t blob_size,\r\noff_t offset, u16 *data)\r\n{\r\nif (offset > blob_size)\r\nreturn false;\r\n*data = blob[offset];\r\nreturn true;\r\n}\r\nstatic bool ath9k_hw_nvram_read_pdata(struct ath9k_platform_data *pdata,\r\noff_t offset, u16 *data)\r\n{\r\nreturn ath9k_hw_nvram_read_array(pdata->eeprom_data,\r\nARRAY_SIZE(pdata->eeprom_data),\r\noffset, data);\r\n}\r\nstatic bool ath9k_hw_nvram_read_firmware(const struct firmware *eeprom_blob,\r\noff_t offset, u16 *data)\r\n{\r\nreturn ath9k_hw_nvram_read_array((u16 *) eeprom_blob->data,\r\neeprom_blob->size / sizeof(u16),\r\noffset, data);\r\n}\r\nbool ath9k_hw_nvram_read(struct ath_hw *ah, u32 off, u16 *data)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_platform_data *pdata = ah->dev->platform_data;\r\nbool ret;\r\nif (ah->eeprom_blob)\r\nret = ath9k_hw_nvram_read_firmware(ah->eeprom_blob, off, data);\r\nelse if (pdata && !pdata->use_eeprom && pdata->eeprom_data)\r\nret = ath9k_hw_nvram_read_pdata(pdata, off, data);\r\nelse\r\nret = common->bus_ops->eeprom_read(common, off, data);\r\nif (!ret)\r\nath_dbg(common, EEPROM,\r\n"unable to read eeprom region at offset %u\n", off);\r\nreturn ret;\r\n}\r\nint ath9k_hw_nvram_swap_data(struct ath_hw *ah, bool *swap_needed, int size)\r\n{\r\nu16 magic;\r\nu16 *eepdata;\r\nint i;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (!ath9k_hw_nvram_read(ah, AR5416_EEPROM_MAGIC_OFFSET, &magic)) {\r\nath_err(common, "Reading Magic # failed\n");\r\nreturn -EIO;\r\n}\r\n*swap_needed = false;\r\nif (swab16(magic) == AR5416_EEPROM_MAGIC) {\r\nif (ah->ah_flags & AH_NO_EEP_SWAP) {\r\nath_info(common,\r\n"Ignoring endianness difference in EEPROM magic bytes.\n");\r\n} else {\r\n*swap_needed = true;\r\n}\r\n} else if (magic != AR5416_EEPROM_MAGIC) {\r\nif (ath9k_hw_use_flash(ah))\r\nreturn 0;\r\nath_err(common,\r\n"Invalid EEPROM Magic (0x%04x).\n", magic);\r\nreturn -EINVAL;\r\n}\r\neepdata = (u16 *)(&ah->eeprom);\r\nif (*swap_needed) {\r\nath_dbg(common, EEPROM,\r\n"EEPROM Endianness is not native.. Changing.\n");\r\nfor (i = 0; i < size; i++)\r\neepdata[i] = swab16(eepdata[i]);\r\n}\r\nreturn 0;\r\n}\r\nbool ath9k_hw_nvram_validate_checksum(struct ath_hw *ah, int size)\r\n{\r\nu32 i, sum = 0;\r\nu16 *eepdata = (u16 *)(&ah->eeprom);\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nfor (i = 0; i < size; i++)\r\nsum ^= eepdata[i];\r\nif (sum != 0xffff) {\r\nath_err(common, "Bad EEPROM checksum 0x%x\n", sum);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool ath9k_hw_nvram_check_version(struct ath_hw *ah, int version, int minrev)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (ah->eep_ops->get_eeprom_ver(ah) != version ||\r\nah->eep_ops->get_eeprom_rev(ah) < minrev) {\r\nath_err(common, "Bad EEPROM VER 0x%04x or REV 0x%04x\n",\r\nah->eep_ops->get_eeprom_ver(ah),\r\nah->eep_ops->get_eeprom_rev(ah));\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid ath9k_hw_fill_vpd_table(u8 pwrMin, u8 pwrMax, u8 *pPwrList,\r\nu8 *pVpdList, u16 numIntercepts,\r\nu8 *pRetVpdList)\r\n{\r\nu16 i, k;\r\nu8 currPwr = pwrMin;\r\nu16 idxL = 0, idxR = 0;\r\nfor (i = 0; i <= (pwrMax - pwrMin) / 2; i++) {\r\nath9k_hw_get_lower_upper_index(currPwr, pPwrList,\r\nnumIntercepts, &(idxL),\r\n&(idxR));\r\nif (idxR < 1)\r\nidxR = 1;\r\nif (idxL == numIntercepts - 1)\r\nidxL = (u16) (numIntercepts - 2);\r\nif (pPwrList[idxL] == pPwrList[idxR])\r\nk = pVpdList[idxL];\r\nelse\r\nk = (u16)(((currPwr - pPwrList[idxL]) * pVpdList[idxR] +\r\n(pPwrList[idxR] - currPwr) * pVpdList[idxL]) /\r\n(pPwrList[idxR] - pPwrList[idxL]));\r\npRetVpdList[i] = (u8) k;\r\ncurrPwr += 2;\r\n}\r\n}\r\nvoid ath9k_hw_get_legacy_target_powers(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nstruct cal_target_power_leg *powInfo,\r\nu16 numChannels,\r\nstruct cal_target_power_leg *pNewPower,\r\nu16 numRates, bool isExtTarget)\r\n{\r\nstruct chan_centers centers;\r\nu16 clo, chi;\r\nint i;\r\nint matchIndex = -1, lowIndex = -1;\r\nu16 freq;\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nfreq = (isExtTarget) ? centers.ext_center : centers.ctl_center;\r\nif (freq <= ath9k_hw_fbin2freq(powInfo[0].bChannel,\r\nIS_CHAN_2GHZ(chan))) {\r\nmatchIndex = 0;\r\n} else {\r\nfor (i = 0; (i < numChannels) &&\r\n(powInfo[i].bChannel != AR5416_BCHAN_UNUSED); i++) {\r\nif (freq == ath9k_hw_fbin2freq(powInfo[i].bChannel,\r\nIS_CHAN_2GHZ(chan))) {\r\nmatchIndex = i;\r\nbreak;\r\n} else if (freq < ath9k_hw_fbin2freq(powInfo[i].bChannel,\r\nIS_CHAN_2GHZ(chan)) && i > 0 &&\r\nfreq > ath9k_hw_fbin2freq(powInfo[i - 1].bChannel,\r\nIS_CHAN_2GHZ(chan))) {\r\nlowIndex = i - 1;\r\nbreak;\r\n}\r\n}\r\nif ((matchIndex == -1) && (lowIndex == -1))\r\nmatchIndex = i - 1;\r\n}\r\nif (matchIndex != -1) {\r\n*pNewPower = powInfo[matchIndex];\r\n} else {\r\nclo = ath9k_hw_fbin2freq(powInfo[lowIndex].bChannel,\r\nIS_CHAN_2GHZ(chan));\r\nchi = ath9k_hw_fbin2freq(powInfo[lowIndex + 1].bChannel,\r\nIS_CHAN_2GHZ(chan));\r\nfor (i = 0; i < numRates; i++) {\r\npNewPower->tPow2x[i] =\r\n(u8)ath9k_hw_interpolate(freq, clo, chi,\r\npowInfo[lowIndex].tPow2x[i],\r\npowInfo[lowIndex + 1].tPow2x[i]);\r\n}\r\n}\r\n}\r\nvoid ath9k_hw_get_target_powers(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nstruct cal_target_power_ht *powInfo,\r\nu16 numChannels,\r\nstruct cal_target_power_ht *pNewPower,\r\nu16 numRates, bool isHt40Target)\r\n{\r\nstruct chan_centers centers;\r\nu16 clo, chi;\r\nint i;\r\nint matchIndex = -1, lowIndex = -1;\r\nu16 freq;\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nfreq = isHt40Target ? centers.synth_center : centers.ctl_center;\r\nif (freq <= ath9k_hw_fbin2freq(powInfo[0].bChannel, IS_CHAN_2GHZ(chan))) {\r\nmatchIndex = 0;\r\n} else {\r\nfor (i = 0; (i < numChannels) &&\r\n(powInfo[i].bChannel != AR5416_BCHAN_UNUSED); i++) {\r\nif (freq == ath9k_hw_fbin2freq(powInfo[i].bChannel,\r\nIS_CHAN_2GHZ(chan))) {\r\nmatchIndex = i;\r\nbreak;\r\n} else\r\nif (freq < ath9k_hw_fbin2freq(powInfo[i].bChannel,\r\nIS_CHAN_2GHZ(chan)) && i > 0 &&\r\nfreq > ath9k_hw_fbin2freq(powInfo[i - 1].bChannel,\r\nIS_CHAN_2GHZ(chan))) {\r\nlowIndex = i - 1;\r\nbreak;\r\n}\r\n}\r\nif ((matchIndex == -1) && (lowIndex == -1))\r\nmatchIndex = i - 1;\r\n}\r\nif (matchIndex != -1) {\r\n*pNewPower = powInfo[matchIndex];\r\n} else {\r\nclo = ath9k_hw_fbin2freq(powInfo[lowIndex].bChannel,\r\nIS_CHAN_2GHZ(chan));\r\nchi = ath9k_hw_fbin2freq(powInfo[lowIndex + 1].bChannel,\r\nIS_CHAN_2GHZ(chan));\r\nfor (i = 0; i < numRates; i++) {\r\npNewPower->tPow2x[i] = (u8)ath9k_hw_interpolate(freq,\r\nclo, chi,\r\npowInfo[lowIndex].tPow2x[i],\r\npowInfo[lowIndex + 1].tPow2x[i]);\r\n}\r\n}\r\n}\r\nu16 ath9k_hw_get_max_edge_power(u16 freq, struct cal_ctl_edges *pRdEdgesPower,\r\nbool is2GHz, int num_band_edges)\r\n{\r\nu16 twiceMaxEdgePower = MAX_RATE_POWER;\r\nint i;\r\nfor (i = 0; (i < num_band_edges) &&\r\n(pRdEdgesPower[i].bChannel != AR5416_BCHAN_UNUSED); i++) {\r\nif (freq == ath9k_hw_fbin2freq(pRdEdgesPower[i].bChannel, is2GHz)) {\r\ntwiceMaxEdgePower = CTL_EDGE_TPOWER(pRdEdgesPower[i].ctl);\r\nbreak;\r\n} else if ((i > 0) &&\r\n(freq < ath9k_hw_fbin2freq(pRdEdgesPower[i].bChannel,\r\nis2GHz))) {\r\nif (ath9k_hw_fbin2freq(pRdEdgesPower[i - 1].bChannel,\r\nis2GHz) < freq &&\r\nCTL_EDGE_FLAGS(pRdEdgesPower[i - 1].ctl)) {\r\ntwiceMaxEdgePower =\r\nCTL_EDGE_TPOWER(pRdEdgesPower[i - 1].ctl);\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn twiceMaxEdgePower;\r\n}\r\nu16 ath9k_hw_get_scaled_power(struct ath_hw *ah, u16 power_limit,\r\nu8 antenna_reduction)\r\n{\r\nu16 reduction = antenna_reduction;\r\nswitch (ar5416_get_ntxchains(ah->txchainmask)) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nreduction += POWER_CORRECTION_FOR_TWO_CHAIN;\r\nbreak;\r\ncase 3:\r\nreduction += POWER_CORRECTION_FOR_THREE_CHAIN;\r\nbreak;\r\n}\r\nif (power_limit > reduction)\r\npower_limit -= reduction;\r\nelse\r\npower_limit = 0;\r\nreturn power_limit;\r\n}\r\nvoid ath9k_hw_update_regulatory_maxpower(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\r\nswitch (ar5416_get_ntxchains(ah->txchainmask)) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nregulatory->max_power_level += POWER_CORRECTION_FOR_TWO_CHAIN;\r\nbreak;\r\ncase 3:\r\nregulatory->max_power_level += POWER_CORRECTION_FOR_THREE_CHAIN;\r\nbreak;\r\ndefault:\r\nath_dbg(common, EEPROM, "Invalid chainmask configuration\n");\r\nbreak;\r\n}\r\n}\r\nvoid ath9k_hw_get_gain_boundaries_pdadcs(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nvoid *pRawDataSet,\r\nu8 *bChans, u16 availPiers,\r\nu16 tPdGainOverlap,\r\nu16 *pPdGainBoundaries, u8 *pPDADCValues,\r\nu16 numXpdGains)\r\n{\r\nint i, j, k;\r\nint16_t ss;\r\nu16 idxL = 0, idxR = 0, numPiers;\r\nstatic u8 vpdTableL[AR5416_NUM_PD_GAINS]\r\n[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\r\nstatic u8 vpdTableR[AR5416_NUM_PD_GAINS]\r\n[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\r\nstatic u8 vpdTableI[AR5416_NUM_PD_GAINS]\r\n[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\r\nu8 *pVpdL, *pVpdR, *pPwrL, *pPwrR;\r\nu8 minPwrT4[AR5416_NUM_PD_GAINS];\r\nu8 maxPwrT4[AR5416_NUM_PD_GAINS];\r\nint16_t vpdStep;\r\nint16_t tmpVal;\r\nu16 sizeCurrVpdTable, maxIndex, tgtIndex;\r\nbool match;\r\nint16_t minDelta = 0;\r\nstruct chan_centers centers;\r\nint pdgain_boundary_default;\r\nstruct cal_data_per_freq *data_def = pRawDataSet;\r\nstruct cal_data_per_freq_4k *data_4k = pRawDataSet;\r\nstruct cal_data_per_freq_ar9287 *data_9287 = pRawDataSet;\r\nbool eeprom_4k = AR_SREV_9285(ah) || AR_SREV_9271(ah);\r\nint intercepts;\r\nif (AR_SREV_9287(ah))\r\nintercepts = AR9287_PD_GAIN_ICEPTS;\r\nelse\r\nintercepts = AR5416_PD_GAIN_ICEPTS;\r\nmemset(&minPwrT4, 0, AR5416_NUM_PD_GAINS);\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nfor (numPiers = 0; numPiers < availPiers; numPiers++) {\r\nif (bChans[numPiers] == AR5416_BCHAN_UNUSED)\r\nbreak;\r\n}\r\nmatch = ath9k_hw_get_lower_upper_index((u8)FREQ2FBIN(centers.synth_center,\r\nIS_CHAN_2GHZ(chan)),\r\nbChans, numPiers, &idxL, &idxR);\r\nif (match) {\r\nif (AR_SREV_9287(ah)) {\r\nfor (i = 0; i < numXpdGains; i++) {\r\nminPwrT4[i] = data_9287[idxL].pwrPdg[i][0];\r\nmaxPwrT4[i] = data_9287[idxL].pwrPdg[i][intercepts - 1];\r\nath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\r\ndata_9287[idxL].pwrPdg[i],\r\ndata_9287[idxL].vpdPdg[i],\r\nintercepts,\r\nvpdTableI[i]);\r\n}\r\n} else if (eeprom_4k) {\r\nfor (i = 0; i < numXpdGains; i++) {\r\nminPwrT4[i] = data_4k[idxL].pwrPdg[i][0];\r\nmaxPwrT4[i] = data_4k[idxL].pwrPdg[i][intercepts - 1];\r\nath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\r\ndata_4k[idxL].pwrPdg[i],\r\ndata_4k[idxL].vpdPdg[i],\r\nintercepts,\r\nvpdTableI[i]);\r\n}\r\n} else {\r\nfor (i = 0; i < numXpdGains; i++) {\r\nminPwrT4[i] = data_def[idxL].pwrPdg[i][0];\r\nmaxPwrT4[i] = data_def[idxL].pwrPdg[i][intercepts - 1];\r\nath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\r\ndata_def[idxL].pwrPdg[i],\r\ndata_def[idxL].vpdPdg[i],\r\nintercepts,\r\nvpdTableI[i]);\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < numXpdGains; i++) {\r\nif (AR_SREV_9287(ah)) {\r\npVpdL = data_9287[idxL].vpdPdg[i];\r\npPwrL = data_9287[idxL].pwrPdg[i];\r\npVpdR = data_9287[idxR].vpdPdg[i];\r\npPwrR = data_9287[idxR].pwrPdg[i];\r\n} else if (eeprom_4k) {\r\npVpdL = data_4k[idxL].vpdPdg[i];\r\npPwrL = data_4k[idxL].pwrPdg[i];\r\npVpdR = data_4k[idxR].vpdPdg[i];\r\npPwrR = data_4k[idxR].pwrPdg[i];\r\n} else {\r\npVpdL = data_def[idxL].vpdPdg[i];\r\npPwrL = data_def[idxL].pwrPdg[i];\r\npVpdR = data_def[idxR].vpdPdg[i];\r\npPwrR = data_def[idxR].pwrPdg[i];\r\n}\r\nminPwrT4[i] = max(pPwrL[0], pPwrR[0]);\r\nmaxPwrT4[i] =\r\nmin(pPwrL[intercepts - 1],\r\npPwrR[intercepts - 1]);\r\nath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\r\npPwrL, pVpdL,\r\nintercepts,\r\nvpdTableL[i]);\r\nath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\r\npPwrR, pVpdR,\r\nintercepts,\r\nvpdTableR[i]);\r\nfor (j = 0; j <= (maxPwrT4[i] - minPwrT4[i]) / 2; j++) {\r\nvpdTableI[i][j] =\r\n(u8)(ath9k_hw_interpolate((u16)\r\nFREQ2FBIN(centers.\r\nsynth_center,\r\nIS_CHAN_2GHZ\r\n(chan)),\r\nbChans[idxL], bChans[idxR],\r\nvpdTableL[i][j], vpdTableR[i][j]));\r\n}\r\n}\r\n}\r\nk = 0;\r\nfor (i = 0; i < numXpdGains; i++) {\r\nif (i == (numXpdGains - 1))\r\npPdGainBoundaries[i] =\r\n(u16)(maxPwrT4[i] / 2);\r\nelse\r\npPdGainBoundaries[i] =\r\n(u16)((maxPwrT4[i] + minPwrT4[i + 1]) / 4);\r\npPdGainBoundaries[i] =\r\nmin((u16)MAX_RATE_POWER, pPdGainBoundaries[i]);\r\nminDelta = 0;\r\nif (i == 0) {\r\nif (AR_SREV_9280_20_OR_LATER(ah))\r\nss = (int16_t)(0 - (minPwrT4[i] / 2));\r\nelse\r\nss = 0;\r\n} else {\r\nss = (int16_t)((pPdGainBoundaries[i - 1] -\r\n(minPwrT4[i] / 2)) -\r\ntPdGainOverlap + 1 + minDelta);\r\n}\r\nvpdStep = (int16_t)(vpdTableI[i][1] - vpdTableI[i][0]);\r\nvpdStep = (int16_t)((vpdStep < 1) ? 1 : vpdStep);\r\nwhile ((ss < 0) && (k < (AR5416_NUM_PDADC_VALUES - 1))) {\r\ntmpVal = (int16_t)(vpdTableI[i][0] + ss * vpdStep);\r\npPDADCValues[k++] = (u8)((tmpVal < 0) ? 0 : tmpVal);\r\nss++;\r\n}\r\nsizeCurrVpdTable = (u8) ((maxPwrT4[i] - minPwrT4[i]) / 2 + 1);\r\ntgtIndex = (u8)(pPdGainBoundaries[i] + tPdGainOverlap -\r\n(minPwrT4[i] / 2));\r\nmaxIndex = (tgtIndex < sizeCurrVpdTable) ?\r\ntgtIndex : sizeCurrVpdTable;\r\nwhile ((ss < maxIndex) && (k < (AR5416_NUM_PDADC_VALUES - 1))) {\r\npPDADCValues[k++] = vpdTableI[i][ss++];\r\n}\r\nvpdStep = (int16_t)(vpdTableI[i][sizeCurrVpdTable - 1] -\r\nvpdTableI[i][sizeCurrVpdTable - 2]);\r\nvpdStep = (int16_t)((vpdStep < 1) ? 1 : vpdStep);\r\nif (tgtIndex >= maxIndex) {\r\nwhile ((ss <= tgtIndex) &&\r\n(k < (AR5416_NUM_PDADC_VALUES - 1))) {\r\ntmpVal = (int16_t)((vpdTableI[i][sizeCurrVpdTable - 1] +\r\n(ss - maxIndex + 1) * vpdStep));\r\npPDADCValues[k++] = (u8)((tmpVal > 255) ?\r\n255 : tmpVal);\r\nss++;\r\n}\r\n}\r\n}\r\nif (eeprom_4k)\r\npdgain_boundary_default = 58;\r\nelse\r\npdgain_boundary_default = pPdGainBoundaries[i - 1];\r\nwhile (i < AR5416_PD_GAINS_IN_MASK) {\r\npPdGainBoundaries[i] = pdgain_boundary_default;\r\ni++;\r\n}\r\nwhile (k < AR5416_NUM_PDADC_VALUES) {\r\npPDADCValues[k] = pPDADCValues[k - 1];\r\nk++;\r\n}\r\n}\r\nint ath9k_hw_eeprom_init(struct ath_hw *ah)\r\n{\r\nint status;\r\nif (AR_SREV_9300_20_OR_LATER(ah))\r\nah->eep_ops = &eep_ar9300_ops;\r\nelse if (AR_SREV_9287(ah)) {\r\nah->eep_ops = &eep_ar9287_ops;\r\n} else if (AR_SREV_9285(ah) || AR_SREV_9271(ah)) {\r\nah->eep_ops = &eep_4k_ops;\r\n} else {\r\nah->eep_ops = &eep_def_ops;\r\n}\r\nif (!ah->eep_ops->fill_eeprom(ah))\r\nreturn -EIO;\r\nstatus = ah->eep_ops->check_eeprom(ah);\r\nreturn status;\r\n}
