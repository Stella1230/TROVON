static int flat_core_dump(struct coredump_params *cprm)\r\n{\r\npr_warn("Process %s:%d received signr %d and should have core dumped\n",\r\ncurrent->comm, current->pid, cprm->siginfo->si_signo);\r\nreturn 1;\r\n}\r\nstatic int create_flat_tables(struct linux_binprm *bprm, unsigned long arg_start)\r\n{\r\nchar __user *p;\r\nunsigned long __user *sp;\r\nlong i, len;\r\np = (char __user *)arg_start;\r\nsp = (unsigned long __user *)current->mm->start_stack;\r\nsp -= bprm->envc + 1;\r\nsp -= bprm->argc + 1;\r\nsp -= flat_argvp_envp_on_stack() ? 2 : 0;\r\nsp -= 1;\r\ncurrent->mm->start_stack = (unsigned long)sp & -FLAT_STACK_ALIGN;\r\nsp = (unsigned long __user *)current->mm->start_stack;\r\n__put_user(bprm->argc, sp++);\r\nif (flat_argvp_envp_on_stack()) {\r\nunsigned long argv, envp;\r\nargv = (unsigned long)(sp + 2);\r\nenvp = (unsigned long)(sp + 2 + bprm->argc + 1);\r\n__put_user(argv, sp++);\r\n__put_user(envp, sp++);\r\n}\r\ncurrent->mm->arg_start = (unsigned long)p;\r\nfor (i = bprm->argc; i > 0; i--) {\r\n__put_user((unsigned long)p, sp++);\r\nlen = strnlen_user(p, MAX_ARG_STRLEN);\r\nif (!len || len > MAX_ARG_STRLEN)\r\nreturn -EINVAL;\r\np += len;\r\n}\r\n__put_user(0, sp++);\r\ncurrent->mm->arg_end = (unsigned long)p;\r\ncurrent->mm->env_start = (unsigned long) p;\r\nfor (i = bprm->envc; i > 0; i--) {\r\n__put_user((unsigned long)p, sp++);\r\nlen = strnlen_user(p, MAX_ARG_STRLEN);\r\nif (!len || len > MAX_ARG_STRLEN)\r\nreturn -EINVAL;\r\np += len;\r\n}\r\n__put_user(0, sp++);\r\ncurrent->mm->env_end = (unsigned long)p;\r\nreturn 0;\r\n}\r\nstatic int decompress_exec(\r\nstruct linux_binprm *bprm,\r\nunsigned long offset,\r\nchar *dst,\r\nlong len,\r\nint fd)\r\n{\r\nunsigned char *buf;\r\nz_stream strm;\r\nloff_t fpos;\r\nint ret, retval;\r\npr_debug("decompress_exec(offset=%lx,buf=%p,len=%lx)\n", offset, dst, len);\r\nmemset(&strm, 0, sizeof(strm));\r\nstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\r\nif (strm.workspace == NULL) {\r\npr_debug("no memory for decompress workspace\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\r\nif (buf == NULL) {\r\npr_debug("no memory for read buffer\n");\r\nretval = -ENOMEM;\r\ngoto out_free;\r\n}\r\nfpos = offset;\r\nret = kernel_read(bprm->file, offset, buf, LBUFSIZE);\r\nstrm.next_in = buf;\r\nstrm.avail_in = ret;\r\nstrm.total_in = 0;\r\nfpos += ret;\r\nretval = -ENOEXEC;\r\nif (ret < 10) {\r\npr_debug("file too small?\n");\r\ngoto out_free_buf;\r\n}\r\nif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\r\npr_debug("unknown compression magic?\n");\r\ngoto out_free_buf;\r\n}\r\nif (buf[2] != 8) {\r\npr_debug("unknown compression method?\n");\r\ngoto out_free_buf;\r\n}\r\nif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\r\n(buf[3] & RESERVED)) {\r\npr_debug("unknown flags?\n");\r\ngoto out_free_buf;\r\n}\r\nret = 10;\r\nif (buf[3] & EXTRA_FIELD) {\r\nret += 2 + buf[10] + (buf[11] << 8);\r\nif (unlikely(ret >= LBUFSIZE)) {\r\npr_debug("buffer overflow (EXTRA)?\n");\r\ngoto out_free_buf;\r\n}\r\n}\r\nif (buf[3] & ORIG_NAME) {\r\nwhile (ret < LBUFSIZE && buf[ret++] != 0)\r\n;\r\nif (unlikely(ret == LBUFSIZE)) {\r\npr_debug("buffer overflow (ORIG_NAME)?\n");\r\ngoto out_free_buf;\r\n}\r\n}\r\nif (buf[3] & COMMENT) {\r\nwhile (ret < LBUFSIZE && buf[ret++] != 0)\r\n;\r\nif (unlikely(ret == LBUFSIZE)) {\r\npr_debug("buffer overflow (COMMENT)?\n");\r\ngoto out_free_buf;\r\n}\r\n}\r\nstrm.next_in += ret;\r\nstrm.avail_in -= ret;\r\nstrm.next_out = dst;\r\nstrm.avail_out = len;\r\nstrm.total_out = 0;\r\nif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\r\npr_debug("zlib init failed?\n");\r\ngoto out_free_buf;\r\n}\r\nwhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\r\nret = kernel_read(bprm->file, fpos, buf, LBUFSIZE);\r\nif (ret <= 0)\r\nbreak;\r\nlen -= ret;\r\nstrm.next_in = buf;\r\nstrm.avail_in = ret;\r\nstrm.total_in = 0;\r\nfpos += ret;\r\n}\r\nif (ret < 0) {\r\npr_debug("decompression failed (%d), %s\n",\r\nret, strm.msg);\r\ngoto out_zlib;\r\n}\r\nretval = 0;\r\nout_zlib:\r\nzlib_inflateEnd(&strm);\r\nout_free_buf:\r\nkfree(buf);\r\nout_free:\r\nkfree(strm.workspace);\r\nreturn retval;\r\n}\r\nstatic unsigned long\r\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\r\n{\r\nunsigned long addr;\r\nint id;\r\nunsigned long start_brk;\r\nunsigned long start_data;\r\nunsigned long text_len;\r\nunsigned long start_code;\r\n#ifdef CONFIG_BINFMT_SHARED_FLAT\r\nif (r == 0)\r\nid = curid;\r\nelse {\r\nid = (r >> 24) & 0xff;\r\nr &= 0x00ffffff;\r\n}\r\nif (id >= MAX_SHARED_LIBS) {\r\npr_err("reference 0x%lx to shared library %d", r, id);\r\ngoto failed;\r\n}\r\nif (curid != id) {\r\nif (internalp) {\r\npr_err("reloc address 0x%lx not in same module "\r\n"(%d != %d)", r, curid, id);\r\ngoto failed;\r\n} else if (!p->lib_list[id].loaded &&\r\nload_flat_shared_library(id, p) < 0) {\r\npr_err("failed to load library %d", id);\r\ngoto failed;\r\n}\r\nif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\r\np->lib_list[curid].build_date < p->lib_list[id].build_date) {\r\npr_err("library %d is younger than %d", id, curid);\r\ngoto failed;\r\n}\r\n}\r\n#else\r\nid = 0;\r\n#endif\r\nstart_brk = p->lib_list[id].start_brk;\r\nstart_data = p->lib_list[id].start_data;\r\nstart_code = p->lib_list[id].start_code;\r\ntext_len = p->lib_list[id].text_len;\r\nif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\r\npr_err("reloc outside program 0x%lx (0 - 0x%lx/0x%lx)",\r\nr, start_brk-start_data+text_len, text_len);\r\ngoto failed;\r\n}\r\nif (r < text_len)\r\naddr = r + start_code;\r\nelse\r\naddr = r - text_len + start_data;\r\nreturn addr;\r\nfailed:\r\npr_cont(", killing %s!\n", current->comm);\r\nsend_sig(SIGSEGV, current, 0);\r\nreturn RELOC_FAILED;\r\n}\r\nstatic void old_reloc(unsigned long rl)\r\n{\r\nstatic const char *segment[] = { "TEXT", "DATA", "BSS", "*UNKNOWN*" };\r\nflat_v2_reloc_t r;\r\nunsigned long __user *ptr;\r\nunsigned long val;\r\nr.value = rl;\r\n#if defined(CONFIG_COLDFIRE)\r\nptr = (unsigned long __user *)(current->mm->start_code + r.reloc.offset);\r\n#else\r\nptr = (unsigned long __user *)(current->mm->start_data + r.reloc.offset);\r\n#endif\r\nget_user(val, ptr);\r\npr_debug("Relocation of variable at DATASEG+%x "\r\n"(address %p, currently %lx) into segment %s\n",\r\nr.reloc.offset, ptr, val, segment[r.reloc.type]);\r\nswitch (r.reloc.type) {\r\ncase OLD_FLAT_RELOC_TYPE_TEXT:\r\nval += current->mm->start_code;\r\nbreak;\r\ncase OLD_FLAT_RELOC_TYPE_DATA:\r\nval += current->mm->start_data;\r\nbreak;\r\ncase OLD_FLAT_RELOC_TYPE_BSS:\r\nval += current->mm->end_data;\r\nbreak;\r\ndefault:\r\npr_err("Unknown relocation type=%x\n", r.reloc.type);\r\nbreak;\r\n}\r\nput_user(val, ptr);\r\npr_debug("Relocation became %lx\n", val);\r\n}\r\nstatic int load_flat_file(struct linux_binprm *bprm,\r\nstruct lib_info *libinfo, int id, unsigned long *extra_stack)\r\n{\r\nstruct flat_hdr *hdr;\r\nunsigned long textpos, datapos, realdatastart;\r\nunsigned long text_len, data_len, bss_len, stack_len, full_data, flags;\r\nunsigned long len, memp, memp_size, extra, rlim;\r\nunsigned long __user *reloc, *rp;\r\nstruct inode *inode;\r\nint i, rev, relocs;\r\nloff_t fpos;\r\nunsigned long start_code, end_code;\r\nssize_t result;\r\nint ret;\r\nhdr = ((struct flat_hdr *) bprm->buf);\r\ninode = file_inode(bprm->file);\r\ntext_len = ntohl(hdr->data_start);\r\ndata_len = ntohl(hdr->data_end) - ntohl(hdr->data_start);\r\nbss_len = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\r\nstack_len = ntohl(hdr->stack_size);\r\nif (extra_stack) {\r\nstack_len += *extra_stack;\r\n*extra_stack = stack_len;\r\n}\r\nrelocs = ntohl(hdr->reloc_count);\r\nflags = ntohl(hdr->flags);\r\nrev = ntohl(hdr->rev);\r\nfull_data = data_len + relocs * sizeof(unsigned long);\r\nif (strncmp(hdr->magic, "bFLT", 4)) {\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nif (flags & FLAT_FLAG_KTRACE)\r\npr_info("Loading file: %s\n", bprm->filename);\r\nif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\r\npr_err("bad flat file version 0x%x (supported 0x%lx and 0x%lx)\n",\r\nrev, FLAT_VERSION, OLD_FLAT_VERSION);\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nif (rev == OLD_FLAT_VERSION && id != 0) {\r\npr_err("shared libraries are not available before rev 0x%lx\n",\r\nFLAT_VERSION);\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nif ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {\r\npr_err("bad header\n");\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\r\nflags = FLAT_FLAG_RAM;\r\n#ifndef CONFIG_BINFMT_ZFLAT\r\nif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\r\npr_err("Support for ZFLAT executables is not enabled.\n");\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\n#endif\r\nrlim = rlimit(RLIMIT_DATA);\r\nif (rlim >= RLIM_INFINITY)\r\nrlim = ~0;\r\nif (data_len + bss_len > rlim) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (id == 0) {\r\nret = flush_old_exec(bprm);\r\nif (ret)\r\ngoto err;\r\nset_personality(PER_LINUX_32BIT);\r\nsetup_new_exec(bprm);\r\n}\r\nextra = max_t(unsigned long, bss_len + stack_len,\r\nrelocs * sizeof(unsigned long));\r\nif (!IS_ENABLED(CONFIG_MMU) && !(flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP))) {\r\npr_debug("ROM mapping of file (we hope)\n");\r\ntextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\r\nMAP_PRIVATE|MAP_EXECUTABLE, 0);\r\nif (!textpos || IS_ERR_VALUE(textpos)) {\r\nret = textpos;\r\nif (!textpos)\r\nret = -ENOMEM;\r\npr_err("Unable to mmap process text, errno %d\n", ret);\r\ngoto err;\r\n}\r\nlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\r\nlen = PAGE_ALIGN(len);\r\nrealdatastart = vm_mmap(NULL, 0, len,\r\nPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\r\nif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\r\nret = realdatastart;\r\nif (!realdatastart)\r\nret = -ENOMEM;\r\npr_err("Unable to allocate RAM for process data, "\r\n"errno %d\n", ret);\r\nvm_munmap(textpos, text_len);\r\ngoto err;\r\n}\r\ndatapos = ALIGN(realdatastart +\r\nMAX_SHARED_LIBS * sizeof(unsigned long),\r\nFLAT_DATA_ALIGN);\r\npr_debug("Allocated data+bss+stack (%ld bytes): %lx\n",\r\ndata_len + bss_len + stack_len, datapos);\r\nfpos = ntohl(hdr->data_start);\r\n#ifdef CONFIG_BINFMT_ZFLAT\r\nif (flags & FLAT_FLAG_GZDATA) {\r\nresult = decompress_exec(bprm, fpos, (char *)datapos,\r\nfull_data, 0);\r\n} else\r\n#endif\r\n{\r\nresult = read_code(bprm->file, datapos, fpos,\r\nfull_data);\r\n}\r\nif (IS_ERR_VALUE(result)) {\r\nret = result;\r\npr_err("Unable to read data+bss, errno %d\n", ret);\r\nvm_munmap(textpos, text_len);\r\nvm_munmap(realdatastart, len);\r\ngoto err;\r\n}\r\nreloc = (unsigned long __user *)\r\n(datapos + (ntohl(hdr->reloc_start) - text_len));\r\nmemp = realdatastart;\r\nmemp_size = len;\r\n} else {\r\nlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\r\nlen = PAGE_ALIGN(len);\r\ntextpos = vm_mmap(NULL, 0, len,\r\nPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\r\nif (!textpos || IS_ERR_VALUE(textpos)) {\r\nret = textpos;\r\nif (!textpos)\r\nret = -ENOMEM;\r\npr_err("Unable to allocate RAM for process text/data, "\r\n"errno %d\n", ret);\r\ngoto err;\r\n}\r\nrealdatastart = textpos + ntohl(hdr->data_start);\r\ndatapos = ALIGN(realdatastart +\r\nMAX_SHARED_LIBS * sizeof(unsigned long),\r\nFLAT_DATA_ALIGN);\r\nreloc = (unsigned long __user *)\r\n(datapos + (ntohl(hdr->reloc_start) - text_len));\r\nmemp = textpos;\r\nmemp_size = len;\r\n#ifdef CONFIG_BINFMT_ZFLAT\r\nif (flags & FLAT_FLAG_GZIP) {\r\n#ifndef CONFIG_MMU\r\nresult = decompress_exec(bprm, sizeof(struct flat_hdr),\r\n(((char *)textpos) + sizeof(struct flat_hdr)),\r\n(text_len + full_data\r\n- sizeof(struct flat_hdr)),\r\n0);\r\nmemmove((void *) datapos, (void *) realdatastart,\r\nfull_data);\r\n#else\r\nlong unz_text_len = text_len - sizeof(struct flat_hdr);\r\nlong unz_len = unz_text_len + full_data;\r\nchar *unz_data = vmalloc(unz_len);\r\nif (!unz_data) {\r\nresult = -ENOMEM;\r\n} else {\r\nresult = decompress_exec(bprm, sizeof(struct flat_hdr),\r\nunz_data, unz_len, 0);\r\nif (result == 0 &&\r\n(copy_to_user((void __user *)textpos + sizeof(struct flat_hdr),\r\nunz_data, unz_text_len) ||\r\ncopy_to_user((void __user *)datapos,\r\nunz_data + unz_text_len, full_data)))\r\nresult = -EFAULT;\r\nvfree(unz_data);\r\n}\r\n#endif\r\n} else if (flags & FLAT_FLAG_GZDATA) {\r\nresult = read_code(bprm->file, textpos, 0, text_len);\r\nif (!IS_ERR_VALUE(result)) {\r\n#ifndef CONFIG_MMU\r\nresult = decompress_exec(bprm, text_len, (char *) datapos,\r\nfull_data, 0);\r\n#else\r\nchar *unz_data = vmalloc(full_data);\r\nif (!unz_data) {\r\nresult = -ENOMEM;\r\n} else {\r\nresult = decompress_exec(bprm, text_len,\r\nunz_data, full_data, 0);\r\nif (result == 0 &&\r\ncopy_to_user((void __user *)datapos,\r\nunz_data, full_data))\r\nresult = -EFAULT;\r\nvfree(unz_data);\r\n}\r\n#endif\r\n}\r\n} else\r\n#endif\r\n{\r\nresult = read_code(bprm->file, textpos, 0, text_len);\r\nif (!IS_ERR_VALUE(result))\r\nresult = read_code(bprm->file, datapos,\r\nntohl(hdr->data_start),\r\nfull_data);\r\n}\r\nif (IS_ERR_VALUE(result)) {\r\nret = result;\r\npr_err("Unable to read code+data+bss, errno %d\n", ret);\r\nvm_munmap(textpos, text_len + data_len + extra +\r\nMAX_SHARED_LIBS * sizeof(unsigned long));\r\ngoto err;\r\n}\r\n}\r\nstart_code = textpos + sizeof(struct flat_hdr);\r\nend_code = textpos + text_len;\r\ntext_len -= sizeof(struct flat_hdr);\r\nif (id == 0) {\r\ncurrent->mm->start_code = start_code;\r\ncurrent->mm->end_code = end_code;\r\ncurrent->mm->start_data = datapos;\r\ncurrent->mm->end_data = datapos + data_len;\r\ncurrent->mm->start_brk = datapos + data_len + bss_len;\r\ncurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\r\n#ifndef CONFIG_MMU\r\ncurrent->mm->context.end_brk = memp + memp_size - stack_len;\r\n#endif\r\n}\r\nif (flags & FLAT_FLAG_KTRACE) {\r\npr_info("Mapping is %lx, Entry point is %x, data_start is %x\n",\r\ntextpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\r\npr_info("%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\n",\r\nid ? "Lib" : "Load", bprm->filename,\r\nstart_code, end_code, datapos, datapos + data_len,\r\ndatapos + data_len, (datapos + data_len + bss_len + 3) & ~3);\r\n}\r\nlibinfo->lib_list[id].start_code = start_code;\r\nlibinfo->lib_list[id].start_data = datapos;\r\nlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\r\nlibinfo->lib_list[id].text_len = text_len;\r\nlibinfo->lib_list[id].loaded = 1;\r\nlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\r\nlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\r\nif (flags & FLAT_FLAG_GOTPIC) {\r\nfor (rp = (unsigned long __user *)datapos; ; rp++) {\r\nunsigned long addr, rp_val;\r\nif (get_user(rp_val, rp))\r\nreturn -EFAULT;\r\nif (rp_val == 0xffffffff)\r\nbreak;\r\nif (rp_val) {\r\naddr = calc_reloc(rp_val, libinfo, id, 0);\r\nif (addr == RELOC_FAILED) {\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nif (put_user(addr, rp))\r\nreturn -EFAULT;\r\n}\r\n}\r\n}\r\nif (rev > OLD_FLAT_VERSION) {\r\nunsigned long __maybe_unused persistent = 0;\r\nfor (i = 0; i < relocs; i++) {\r\nunsigned long addr, relval;\r\nif (get_user(relval, reloc + i))\r\nreturn -EFAULT;\r\nrelval = ntohl(relval);\r\nif (flat_set_persistent(relval, &persistent))\r\ncontinue;\r\naddr = flat_get_relocate_addr(relval);\r\nrp = (unsigned long __user *)calc_reloc(addr, libinfo, id, 1);\r\nif (rp == (unsigned long __user *)RELOC_FAILED) {\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\naddr = flat_get_addr_from_rp(rp, relval, flags,\r\n&persistent);\r\nif (addr != 0) {\r\nif ((flags & FLAT_FLAG_GOTPIC) == 0)\r\naddr = ntohl(addr);\r\naddr = calc_reloc(addr, libinfo, id, 0);\r\nif (addr == RELOC_FAILED) {\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nflat_put_addr_at_rp(rp, addr, relval);\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < relocs; i++) {\r\nunsigned long relval;\r\nif (get_user(relval, reloc + i))\r\nreturn -EFAULT;\r\nrelval = ntohl(relval);\r\nold_reloc(relval);\r\n}\r\n}\r\nflush_icache_range(start_code, end_code);\r\nif (clear_user((void __user *)(datapos + data_len), bss_len +\r\n(memp + memp_size - stack_len -\r\nlibinfo->lib_list[id].start_brk) +\r\nstack_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int load_flat_shared_library(int id, struct lib_info *libs)\r\n{\r\nstruct linux_binprm bprm;\r\nint res;\r\nchar buf[16];\r\nmemset(&bprm, 0, sizeof(bprm));\r\nsprintf(buf, "/lib/lib%d.so", id);\r\nbprm.filename = buf;\r\nbprm.file = open_exec(bprm.filename);\r\nres = PTR_ERR(bprm.file);\r\nif (IS_ERR(bprm.file))\r\nreturn res;\r\nbprm.cred = prepare_exec_creds();\r\nres = -ENOMEM;\r\nif (!bprm.cred)\r\ngoto out;\r\nbprm.cred_prepared = 1;\r\nres = prepare_binprm(&bprm);\r\nif (!res)\r\nres = load_flat_file(&bprm, libs, id, NULL);\r\nabort_creds(bprm.cred);\r\nout:\r\nallow_write_access(bprm.file);\r\nfput(bprm.file);\r\nreturn res;\r\n}\r\nstatic int load_flat_binary(struct linux_binprm *bprm)\r\n{\r\nstruct lib_info libinfo;\r\nstruct pt_regs *regs = current_pt_regs();\r\nunsigned long stack_len = 0;\r\nunsigned long start_addr;\r\nint res;\r\nint i, j;\r\nmemset(&libinfo, 0, sizeof(libinfo));\r\n#ifndef CONFIG_MMU\r\nstack_len += PAGE_SIZE * MAX_ARG_PAGES - bprm->p;\r\n#endif\r\nstack_len += (bprm->argc + 1) * sizeof(char *);\r\nstack_len += (bprm->envc + 1) * sizeof(char *);\r\nstack_len = ALIGN(stack_len, FLAT_STACK_ALIGN);\r\nres = load_flat_file(bprm, &libinfo, 0, &stack_len);\r\nif (res < 0)\r\nreturn res;\r\nfor (i = 0; i < MAX_SHARED_LIBS; i++) {\r\nif (!libinfo.lib_list[i].loaded)\r\ncontinue;\r\nfor (j = 0; j < MAX_SHARED_LIBS; j++) {\r\nunsigned long val = libinfo.lib_list[j].loaded ?\r\nlibinfo.lib_list[j].start_data : UNLOADED_LIB;\r\nunsigned long __user *p = (unsigned long __user *)\r\nlibinfo.lib_list[i].start_data;\r\np -= j + 1;\r\nif (put_user(val, p))\r\nreturn -EFAULT;\r\n}\r\n}\r\ninstall_exec_creds(bprm);\r\nset_binfmt(&flat_format);\r\n#ifdef CONFIG_MMU\r\nres = setup_arg_pages(bprm, STACK_TOP, EXSTACK_DEFAULT);\r\nif (!res)\r\nres = create_flat_tables(bprm, bprm->p);\r\n#else\r\ncurrent->mm->start_stack =\r\n((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;\r\npr_debug("sp=%lx\n", current->mm->start_stack);\r\nres = transfer_args_to_stack(bprm, &current->mm->start_stack);\r\nif (!res)\r\nres = create_flat_tables(bprm, current->mm->start_stack);\r\n#endif\r\nif (res)\r\nreturn res;\r\nstart_addr = libinfo.lib_list[0].entry;\r\n#ifdef CONFIG_BINFMT_SHARED_FLAT\r\nfor (i = MAX_SHARED_LIBS-1; i > 0; i--) {\r\nif (libinfo.lib_list[i].loaded) {\r\nunsigned long __user *sp;\r\ncurrent->mm->start_stack -= sizeof(unsigned long);\r\nsp = (unsigned long __user *)current->mm->start_stack;\r\n__put_user(start_addr, sp);\r\nstart_addr = libinfo.lib_list[i].entry;\r\n}\r\n}\r\n#endif\r\n#ifdef FLAT_PLAT_INIT\r\nFLAT_PLAT_INIT(regs);\r\n#endif\r\npr_debug("start_thread(regs=0x%p, entry=0x%lx, start_stack=0x%lx)\n",\r\nregs, start_addr, current->mm->start_stack);\r\nstart_thread(regs, start_addr, current->mm->start_stack);\r\nreturn 0;\r\n}\r\nstatic int __init init_flat_binfmt(void)\r\n{\r\nregister_binfmt(&flat_format);\r\nreturn 0;\r\n}
