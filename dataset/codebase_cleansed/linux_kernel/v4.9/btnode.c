void nilfs_btnode_cache_clear(struct address_space *btnc)\r\n{\r\ninvalidate_mapping_pages(btnc, 0, -1);\r\ntruncate_inode_pages(btnc, 0);\r\n}\r\nstruct buffer_head *\r\nnilfs_btnode_create_block(struct address_space *btnc, __u64 blocknr)\r\n{\r\nstruct inode *inode = NILFS_BTNC_I(btnc);\r\nstruct buffer_head *bh;\r\nbh = nilfs_grab_buffer(inode, btnc, blocknr, BIT(BH_NILFS_Node));\r\nif (unlikely(!bh))\r\nreturn NULL;\r\nif (unlikely(buffer_mapped(bh) || buffer_uptodate(bh) ||\r\nbuffer_dirty(bh))) {\r\nbrelse(bh);\r\nBUG();\r\n}\r\nmemset(bh->b_data, 0, 1 << inode->i_blkbits);\r\nbh->b_bdev = inode->i_sb->s_bdev;\r\nbh->b_blocknr = blocknr;\r\nset_buffer_mapped(bh);\r\nset_buffer_uptodate(bh);\r\nunlock_page(bh->b_page);\r\nput_page(bh->b_page);\r\nreturn bh;\r\n}\r\nint nilfs_btnode_submit_block(struct address_space *btnc, __u64 blocknr,\r\nsector_t pblocknr, int mode, int mode_flags,\r\nstruct buffer_head **pbh, sector_t *submit_ptr)\r\n{\r\nstruct buffer_head *bh;\r\nstruct inode *inode = NILFS_BTNC_I(btnc);\r\nstruct page *page;\r\nint err;\r\nbh = nilfs_grab_buffer(inode, btnc, blocknr, BIT(BH_NILFS_Node));\r\nif (unlikely(!bh))\r\nreturn -ENOMEM;\r\nerr = -EEXIST;\r\npage = bh->b_page;\r\nif (buffer_uptodate(bh) || buffer_dirty(bh))\r\ngoto found;\r\nif (pblocknr == 0) {\r\npblocknr = blocknr;\r\nif (inode->i_ino != NILFS_DAT_INO) {\r\nstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\r\nerr = nilfs_dat_translate(nilfs->ns_dat, blocknr,\r\n&pblocknr);\r\nif (unlikely(err)) {\r\nbrelse(bh);\r\ngoto out_locked;\r\n}\r\n}\r\n}\r\nif (mode_flags & REQ_RAHEAD) {\r\nif (pblocknr != *submit_ptr + 1 || !trylock_buffer(bh)) {\r\nerr = -EBUSY;\r\nbrelse(bh);\r\ngoto out_locked;\r\n}\r\n} else {\r\nlock_buffer(bh);\r\n}\r\nif (buffer_uptodate(bh)) {\r\nunlock_buffer(bh);\r\nerr = -EEXIST;\r\ngoto found;\r\n}\r\nset_buffer_mapped(bh);\r\nbh->b_bdev = inode->i_sb->s_bdev;\r\nbh->b_blocknr = pblocknr;\r\nbh->b_end_io = end_buffer_read_sync;\r\nget_bh(bh);\r\nsubmit_bh(mode, mode_flags, bh);\r\nbh->b_blocknr = blocknr;\r\n*submit_ptr = pblocknr;\r\nerr = 0;\r\nfound:\r\n*pbh = bh;\r\nout_locked:\r\nunlock_page(page);\r\nput_page(page);\r\nreturn err;\r\n}\r\nvoid nilfs_btnode_delete(struct buffer_head *bh)\r\n{\r\nstruct address_space *mapping;\r\nstruct page *page = bh->b_page;\r\npgoff_t index = page_index(page);\r\nint still_dirty;\r\nget_page(page);\r\nlock_page(page);\r\nwait_on_page_writeback(page);\r\nnilfs_forget_buffer(bh);\r\nstill_dirty = PageDirty(page);\r\nmapping = page->mapping;\r\nunlock_page(page);\r\nput_page(page);\r\nif (!still_dirty && mapping)\r\ninvalidate_inode_pages2_range(mapping, index, index);\r\n}\r\nint nilfs_btnode_prepare_change_key(struct address_space *btnc,\r\nstruct nilfs_btnode_chkey_ctxt *ctxt)\r\n{\r\nstruct buffer_head *obh, *nbh;\r\nstruct inode *inode = NILFS_BTNC_I(btnc);\r\n__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\r\nint err;\r\nif (oldkey == newkey)\r\nreturn 0;\r\nobh = ctxt->bh;\r\nctxt->newbh = NULL;\r\nif (inode->i_blkbits == PAGE_SHIFT) {\r\nlock_page(obh->b_page);\r\nretry:\r\nerr = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\r\nif (err)\r\ngoto failed_unlock;\r\nif (unlikely(oldkey != obh->b_page->index))\r\nNILFS_PAGE_BUG(obh->b_page,\r\n"invalid oldkey %lld (newkey=%lld)",\r\n(unsigned long long)oldkey,\r\n(unsigned long long)newkey);\r\nspin_lock_irq(&btnc->tree_lock);\r\nerr = radix_tree_insert(&btnc->page_tree, newkey, obh->b_page);\r\nspin_unlock_irq(&btnc->tree_lock);\r\nradix_tree_preload_end();\r\nif (!err)\r\nreturn 0;\r\nelse if (err != -EEXIST)\r\ngoto failed_unlock;\r\nerr = invalidate_inode_pages2_range(btnc, newkey, newkey);\r\nif (!err)\r\ngoto retry;\r\nunlock_page(obh->b_page);\r\n}\r\nnbh = nilfs_btnode_create_block(btnc, newkey);\r\nif (!nbh)\r\nreturn -ENOMEM;\r\nBUG_ON(nbh == obh);\r\nctxt->newbh = nbh;\r\nreturn 0;\r\nfailed_unlock:\r\nunlock_page(obh->b_page);\r\nreturn err;\r\n}\r\nvoid nilfs_btnode_commit_change_key(struct address_space *btnc,\r\nstruct nilfs_btnode_chkey_ctxt *ctxt)\r\n{\r\nstruct buffer_head *obh = ctxt->bh, *nbh = ctxt->newbh;\r\n__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\r\nstruct page *opage;\r\nif (oldkey == newkey)\r\nreturn;\r\nif (nbh == NULL) {\r\nopage = obh->b_page;\r\nif (unlikely(oldkey != opage->index))\r\nNILFS_PAGE_BUG(opage,\r\n"invalid oldkey %lld (newkey=%lld)",\r\n(unsigned long long)oldkey,\r\n(unsigned long long)newkey);\r\nmark_buffer_dirty(obh);\r\nspin_lock_irq(&btnc->tree_lock);\r\nradix_tree_delete(&btnc->page_tree, oldkey);\r\nradix_tree_tag_set(&btnc->page_tree, newkey,\r\nPAGECACHE_TAG_DIRTY);\r\nspin_unlock_irq(&btnc->tree_lock);\r\nopage->index = obh->b_blocknr = newkey;\r\nunlock_page(opage);\r\n} else {\r\nnilfs_copy_buffer(nbh, obh);\r\nmark_buffer_dirty(nbh);\r\nnbh->b_blocknr = newkey;\r\nctxt->bh = nbh;\r\nnilfs_btnode_delete(obh);\r\n}\r\n}\r\nvoid nilfs_btnode_abort_change_key(struct address_space *btnc,\r\nstruct nilfs_btnode_chkey_ctxt *ctxt)\r\n{\r\nstruct buffer_head *nbh = ctxt->newbh;\r\n__u64 oldkey = ctxt->oldkey, newkey = ctxt->newkey;\r\nif (oldkey == newkey)\r\nreturn;\r\nif (nbh == NULL) {\r\nspin_lock_irq(&btnc->tree_lock);\r\nradix_tree_delete(&btnc->page_tree, newkey);\r\nspin_unlock_irq(&btnc->tree_lock);\r\nunlock_page(ctxt->bh->b_page);\r\n} else\r\nbrelse(nbh);\r\n}
