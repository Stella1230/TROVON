static inline void omap_8250_rx_dma_flush(struct uart_8250_port *p) { }\r\nstatic u32 uart_read(struct uart_8250_port *up, u32 reg)\r\n{\r\nreturn readl(up->port.membase + (reg << up->port.regshift));\r\n}\r\nstatic void omap8250_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nstruct omap8250_priv *priv = up->port.private_data;\r\nu8 lcr;\r\nserial8250_do_set_mctrl(port, mctrl);\r\nlcr = serial_in(up, UART_LCR);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nif ((mctrl & TIOCM_RTS) && (port->status & UPSTAT_AUTORTS))\r\npriv->efr |= UART_EFR_RTS;\r\nelse\r\npriv->efr &= ~UART_EFR_RTS;\r\nserial_out(up, UART_EFR, priv->efr);\r\nserial_out(up, UART_LCR, lcr);\r\n}\r\nstatic void omap_8250_mdr1_errataset(struct uart_8250_port *up,\r\nstruct omap8250_priv *priv)\r\n{\r\nu8 timeout = 255;\r\nu8 old_mdr1;\r\nold_mdr1 = serial_in(up, UART_OMAP_MDR1);\r\nif (old_mdr1 == priv->mdr1)\r\nreturn;\r\nserial_out(up, UART_OMAP_MDR1, priv->mdr1);\r\nudelay(2);\r\nserial_out(up, UART_FCR, up->fcr | UART_FCR_CLEAR_XMIT |\r\nUART_FCR_CLEAR_RCVR);\r\nwhile (UART_LSR_THRE != (serial_in(up, UART_LSR) &\r\n(UART_LSR_THRE | UART_LSR_DR))) {\r\ntimeout--;\r\nif (!timeout) {\r\ndev_crit(up->port.dev, "Errata i202: timedout %x\n",\r\nserial_in(up, UART_LSR));\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\nstatic void omap_8250_get_divisor(struct uart_port *port, unsigned int baud,\r\nstruct omap8250_priv *priv)\r\n{\r\nunsigned int uartclk = port->uartclk;\r\nunsigned int div_13, div_16;\r\nunsigned int abs_d13, abs_d16;\r\nif (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST) {\r\npriv->quot = port->custom_divisor & 0xffff;\r\nif (port->custom_divisor & (1 << 16))\r\npriv->mdr1 = UART_OMAP_MDR1_13X_MODE;\r\nelse\r\npriv->mdr1 = UART_OMAP_MDR1_16X_MODE;\r\nreturn;\r\n}\r\ndiv_13 = DIV_ROUND_CLOSEST(uartclk, 13 * baud);\r\ndiv_16 = DIV_ROUND_CLOSEST(uartclk, 16 * baud);\r\nif (!div_13)\r\ndiv_13 = 1;\r\nif (!div_16)\r\ndiv_16 = 1;\r\nabs_d13 = abs(baud - uartclk / 13 / div_13);\r\nabs_d16 = abs(baud - uartclk / 16 / div_16);\r\nif (abs_d13 >= abs_d16) {\r\npriv->mdr1 = UART_OMAP_MDR1_16X_MODE;\r\npriv->quot = div_16;\r\n} else {\r\npriv->mdr1 = UART_OMAP_MDR1_13X_MODE;\r\npriv->quot = div_13;\r\n}\r\n}\r\nstatic void omap8250_update_scr(struct uart_8250_port *up,\r\nstruct omap8250_priv *priv)\r\n{\r\nu8 old_scr;\r\nold_scr = serial_in(up, UART_OMAP_SCR);\r\nif (old_scr == priv->scr)\r\nreturn;\r\nif (priv->scr & OMAP_UART_SCR_DMAMODE_MASK)\r\nserial_out(up, UART_OMAP_SCR,\r\npriv->scr & ~OMAP_UART_SCR_DMAMODE_MASK);\r\nserial_out(up, UART_OMAP_SCR, priv->scr);\r\n}\r\nstatic void omap8250_update_mdr1(struct uart_8250_port *up,\r\nstruct omap8250_priv *priv)\r\n{\r\nif (priv->habit & UART_ERRATA_i202_MDR1_ACCESS)\r\nomap_8250_mdr1_errataset(up, priv);\r\nelse\r\nserial_out(up, UART_OMAP_MDR1, priv->mdr1);\r\n}\r\nstatic void omap8250_restore_regs(struct uart_8250_port *up)\r\n{\r\nstruct omap8250_priv *priv = up->port.private_data;\r\nstruct uart_8250_dma *dma = up->dma;\r\nif (dma && dma->tx_running) {\r\npriv->delayed_restore = 1;\r\nreturn;\r\n}\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, UART_EFR_ECB);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_A);\r\nserial8250_out_MCR(up, UART_MCR_TCRTLR);\r\nserial_out(up, UART_FCR, up->fcr);\r\nomap8250_update_scr(up, priv);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_TI752_TCR, OMAP_UART_TCR_RESTORE(16) |\r\nOMAP_UART_TCR_HALT(52));\r\nserial_out(up, UART_TI752_TLR,\r\nTRIGGER_TLR_MASK(TX_TRIGGER) << UART_TI752_TLR_TX |\r\nTRIGGER_TLR_MASK(RX_TRIGGER) << UART_TI752_TLR_RX);\r\nserial_out(up, UART_LCR, 0);\r\nserial8250_out_MCR(up, up->mcr);\r\nserial_out(up, UART_IER, up->ier);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_dl_write(up, priv->quot);\r\nserial_out(up, UART_EFR, priv->efr);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_XON1, priv->xon);\r\nserial_out(up, UART_XOFF1, priv->xoff);\r\nserial_out(up, UART_LCR, up->lcr);\r\nomap8250_update_mdr1(up, priv);\r\nup->port.ops->set_mctrl(&up->port, up->port.mctrl);\r\n}\r\nstatic void omap_8250_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nstruct omap8250_priv *priv = up->port.private_data;\r\nunsigned char cval = 0;\r\nunsigned int baud;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncval = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\ncval = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\ncval = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= UART_LCR_STOP;\r\nif (termios->c_cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(termios->c_cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nif (termios->c_cflag & CMSPAR)\r\ncval |= UART_LCR_SPAR;\r\nbaud = uart_get_baud_rate(port, termios, old,\r\nport->uartclk / 16 / 0xffff,\r\nport->uartclk / 13);\r\nomap_8250_get_divisor(port, baud, priv);\r\npm_runtime_get_sync(port->dev);\r\nspin_lock_irq(&port->lock);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (termios->c_iflag & INPCK)\r\nup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (termios->c_iflag & (IGNBRK | PARMRK))\r\nup->port.read_status_mask |= UART_LSR_BI;\r\nup->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= UART_LSR_BI;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= UART_LSR_DR;\r\nup->ier &= ~UART_IER_MSI;\r\nif (UART_ENABLE_MS(&up->port, termios->c_cflag))\r\nup->ier |= UART_IER_MSI;\r\nup->lcr = cval;\r\nup->fcr = UART_FCR_ENABLE_FIFO;\r\nup->fcr |= TRIGGER_FCR_MASK(TX_TRIGGER) << OMAP_UART_FCR_TX_TRIG;\r\nup->fcr |= TRIGGER_FCR_MASK(RX_TRIGGER) << OMAP_UART_FCR_RX_TRIG;\r\npriv->scr = OMAP_UART_SCR_RX_TRIG_GRANU1_MASK | OMAP_UART_SCR_TX_EMPTY |\r\nOMAP_UART_SCR_TX_TRIG_GRANU1_MASK;\r\nif (up->dma)\r\npriv->scr |= OMAP_UART_SCR_DMAMODE_1 |\r\nOMAP_UART_SCR_DMAMODE_CTL;\r\npriv->xon = termios->c_cc[VSTART];\r\npriv->xoff = termios->c_cc[VSTOP];\r\npriv->efr = 0;\r\nup->port.status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS | UPSTAT_AUTOXOFF);\r\nif (termios->c_cflag & CRTSCTS && up->port.flags & UPF_HARD_FLOW) {\r\nup->port.status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;\r\npriv->efr |= UART_EFR_CTS;\r\n} else if (up->port.flags & UPF_SOFT_FLOW) {\r\nif (termios->c_iflag & IXOFF) {\r\nup->port.status |= UPSTAT_AUTOXOFF;\r\npriv->efr |= OMAP_UART_SW_TX;\r\n}\r\n}\r\nomap8250_restore_regs(up);\r\nspin_unlock_irq(&up->port.lock);\r\npm_runtime_mark_last_busy(port->dev);\r\npm_runtime_put_autosuspend(port->dev);\r\npriv->calc_latency = USEC_PER_SEC * 64 * 8 / baud;\r\npriv->latency = priv->calc_latency;\r\nschedule_work(&priv->qos_work);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\n}\r\nstatic void omap_8250_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nu8 efr;\r\npm_runtime_get_sync(port->dev);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nefr = serial_in(up, UART_EFR);\r\nserial_out(up, UART_EFR, efr | UART_EFR_ECB);\r\nserial_out(up, UART_LCR, 0);\r\nserial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);\r\nserial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);\r\nserial_out(up, UART_EFR, efr);\r\nserial_out(up, UART_LCR, 0);\r\npm_runtime_mark_last_busy(port->dev);\r\npm_runtime_put_autosuspend(port->dev);\r\n}\r\nstatic void omap_serial_fill_features_erratas(struct uart_8250_port *up,\r\nstruct omap8250_priv *priv)\r\n{\r\nu32 mvr, scheme;\r\nu16 revision, major, minor;\r\nmvr = uart_read(up, UART_OMAP_MVER);\r\nscheme = mvr >> OMAP_UART_MVR_SCHEME_SHIFT;\r\nswitch (scheme) {\r\ncase 0:\r\nmajor = (mvr & OMAP_UART_LEGACY_MVR_MAJ_MASK) >>\r\nOMAP_UART_LEGACY_MVR_MAJ_SHIFT;\r\nminor = (mvr & OMAP_UART_LEGACY_MVR_MIN_MASK);\r\nbreak;\r\ncase 1:\r\nmajor = (mvr & OMAP_UART_MVR_MAJ_MASK) >>\r\nOMAP_UART_MVR_MAJ_SHIFT;\r\nminor = (mvr & OMAP_UART_MVR_MIN_MASK);\r\nbreak;\r\ndefault:\r\ndev_warn(up->port.dev,\r\n"Unknown revision, defaulting to highest\n");\r\nmajor = 0xff;\r\nminor = 0xff;\r\n}\r\nrevision = UART_BUILD_REVISION(major, minor);\r\nswitch (revision) {\r\ncase OMAP_UART_REV_46:\r\npriv->habit |= UART_ERRATA_i202_MDR1_ACCESS;\r\nbreak;\r\ncase OMAP_UART_REV_52:\r\npriv->habit |= UART_ERRATA_i202_MDR1_ACCESS |\r\nOMAP_UART_WER_HAS_TX_WAKEUP;\r\nbreak;\r\ncase OMAP_UART_REV_63:\r\npriv->habit |= UART_ERRATA_i202_MDR1_ACCESS |\r\nOMAP_UART_WER_HAS_TX_WAKEUP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void omap8250_uart_qos_work(struct work_struct *work)\r\n{\r\nstruct omap8250_priv *priv;\r\npriv = container_of(work, struct omap8250_priv, qos_work);\r\npm_qos_update_request(&priv->pm_qos_request, priv->latency);\r\n}\r\nstatic irqreturn_t omap8250_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nunsigned int iir;\r\nint ret;\r\n#ifdef CONFIG_SERIAL_8250_DMA\r\nif (up->dma) {\r\nret = omap_8250_dma_handle_irq(port);\r\nreturn IRQ_RETVAL(ret);\r\n}\r\n#endif\r\nserial8250_rpm_get(up);\r\niir = serial_port_in(port, UART_IIR);\r\nret = serial8250_handle_irq(port, iir);\r\nserial8250_rpm_put(up);\r\nreturn IRQ_RETVAL(ret);\r\n}\r\nstatic int omap_8250_startup(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nstruct omap8250_priv *priv = port->private_data;\r\nint ret;\r\nif (priv->wakeirq) {\r\nret = dev_pm_set_dedicated_wake_irq(port->dev, priv->wakeirq);\r\nif (ret)\r\nreturn ret;\r\n}\r\npm_runtime_get_sync(port->dev);\r\nup->mcr = 0;\r\nserial_out(up, UART_FCR, UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nserial_out(up, UART_LCR, UART_LCR_WLEN8);\r\nup->lsr_saved_flags = 0;\r\nup->msr_saved_flags = 0;\r\nif (up->dma) {\r\nret = serial8250_request_dma(up);\r\nif (ret) {\r\ndev_warn_ratelimited(port->dev,\r\n"failed to request DMA\n");\r\nup->dma = NULL;\r\n}\r\n}\r\nret = request_irq(port->irq, omap8250_irq, IRQF_SHARED,\r\ndev_name(port->dev), port);\r\nif (ret < 0)\r\ngoto err;\r\nup->ier = UART_IER_RLSI | UART_IER_RDI;\r\nserial_out(up, UART_IER, up->ier);\r\n#ifdef CONFIG_PM\r\nup->capabilities |= UART_CAP_RPM;\r\n#endif\r\npriv->wer = OMAP_UART_WER_MOD_WKUP;\r\nif (priv->habit & OMAP_UART_WER_HAS_TX_WAKEUP)\r\npriv->wer |= OMAP_UART_TX_WAKEUP_EN;\r\nserial_out(up, UART_OMAP_WER, priv->wer);\r\nif (up->dma)\r\nup->dma->rx_dma(up);\r\npm_runtime_mark_last_busy(port->dev);\r\npm_runtime_put_autosuspend(port->dev);\r\nreturn 0;\r\nerr:\r\npm_runtime_mark_last_busy(port->dev);\r\npm_runtime_put_autosuspend(port->dev);\r\ndev_pm_clear_wake_irq(port->dev);\r\nreturn ret;\r\n}\r\nstatic void omap_8250_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nstruct omap8250_priv *priv = port->private_data;\r\nflush_work(&priv->qos_work);\r\nif (up->dma)\r\nomap_8250_rx_dma_flush(up);\r\npm_runtime_get_sync(port->dev);\r\nserial_out(up, UART_OMAP_WER, 0);\r\nup->ier = 0;\r\nserial_out(up, UART_IER, 0);\r\nif (up->dma)\r\nserial8250_release_dma(up);\r\nif (up->lcr & UART_LCR_SBC)\r\nserial_out(up, UART_LCR, up->lcr & ~UART_LCR_SBC);\r\nserial_out(up, UART_FCR, UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\npm_runtime_mark_last_busy(port->dev);\r\npm_runtime_put_autosuspend(port->dev);\r\nfree_irq(port->irq, port);\r\ndev_pm_clear_wake_irq(port->dev);\r\n}\r\nstatic void omap_8250_throttle(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nunsigned long flags;\r\npm_runtime_get_sync(port->dev);\r\nspin_lock_irqsave(&port->lock, flags);\r\nup->ier &= ~(UART_IER_RLSI | UART_IER_RDI);\r\nserial_out(up, UART_IER, up->ier);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\npm_runtime_mark_last_busy(port->dev);\r\npm_runtime_put_autosuspend(port->dev);\r\n}\r\nstatic int omap_8250_rs485_config(struct uart_port *port,\r\nstruct serial_rs485 *rs485)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nrs485->delay_rts_before_send = min(rs485->delay_rts_before_send, 100U);\r\nrs485->delay_rts_after_send = min(rs485->delay_rts_after_send, 100U);\r\nport->rs485 = *rs485;\r\nif (rs485->flags & SER_RS485_ENABLED) {\r\nint ret = serial8250_em485_init(up);\r\nif (ret) {\r\nrs485->flags &= ~SER_RS485_ENABLED;\r\nport->rs485.flags &= ~SER_RS485_ENABLED;\r\n}\r\nreturn ret;\r\n}\r\nserial8250_em485_destroy(up);\r\nreturn 0;\r\n}\r\nstatic void omap_8250_unthrottle(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nunsigned long flags;\r\npm_runtime_get_sync(port->dev);\r\nspin_lock_irqsave(&port->lock, flags);\r\nup->ier |= UART_IER_RLSI | UART_IER_RDI;\r\nserial_out(up, UART_IER, up->ier);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\npm_runtime_mark_last_busy(port->dev);\r\npm_runtime_put_autosuspend(port->dev);\r\n}\r\nstatic void __dma_rx_do_complete(struct uart_8250_port *p)\r\n{\r\nstruct omap8250_priv *priv = p->port.private_data;\r\nstruct uart_8250_dma *dma = p->dma;\r\nstruct tty_port *tty_port = &p->port.state->port;\r\nstruct dma_tx_state state;\r\nint count;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&priv->rx_dma_lock, flags);\r\nif (!dma->rx_running)\r\ngoto unlock;\r\ndma->rx_running = 0;\r\ndmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);\r\ncount = dma->rx_size - state.residue;\r\nret = tty_insert_flip_string(tty_port, dma->rx_buf, count);\r\np->port.icount.rx += ret;\r\np->port.icount.buf_overrun += count - ret;\r\nunlock:\r\nspin_unlock_irqrestore(&priv->rx_dma_lock, flags);\r\ntty_flip_buffer_push(tty_port);\r\n}\r\nstatic void __dma_rx_complete(void *param)\r\n{\r\n__dma_rx_do_complete(param);\r\nomap_8250_rx_dma(param);\r\n}\r\nstatic void omap_8250_rx_dma_flush(struct uart_8250_port *p)\r\n{\r\nstruct omap8250_priv *priv = p->port.private_data;\r\nstruct uart_8250_dma *dma = p->dma;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&priv->rx_dma_lock, flags);\r\nif (!dma->rx_running) {\r\nspin_unlock_irqrestore(&priv->rx_dma_lock, flags);\r\nreturn;\r\n}\r\nret = dmaengine_pause(dma->rxchan);\r\nif (WARN_ON_ONCE(ret))\r\npriv->rx_dma_broken = true;\r\nspin_unlock_irqrestore(&priv->rx_dma_lock, flags);\r\n__dma_rx_do_complete(p);\r\ndmaengine_terminate_all(dma->rxchan);\r\n}\r\nstatic int omap_8250_rx_dma(struct uart_8250_port *p)\r\n{\r\nstruct omap8250_priv *priv = p->port.private_data;\r\nstruct uart_8250_dma *dma = p->dma;\r\nint err = 0;\r\nstruct dma_async_tx_descriptor *desc;\r\nunsigned long flags;\r\nif (priv->rx_dma_broken)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&priv->rx_dma_lock, flags);\r\nif (dma->rx_running)\r\ngoto out;\r\ndesc = dmaengine_prep_slave_single(dma->rxchan, dma->rx_addr,\r\ndma->rx_size, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\ndma->rx_running = 1;\r\ndesc->callback = __dma_rx_complete;\r\ndesc->callback_param = p;\r\ndma->rx_cookie = dmaengine_submit(desc);\r\ndma_async_issue_pending(dma->rxchan);\r\nout:\r\nspin_unlock_irqrestore(&priv->rx_dma_lock, flags);\r\nreturn err;\r\n}\r\nstatic void omap_8250_dma_tx_complete(void *param)\r\n{\r\nstruct uart_8250_port *p = param;\r\nstruct uart_8250_dma *dma = p->dma;\r\nstruct circ_buf *xmit = &p->port.state->xmit;\r\nunsigned long flags;\r\nbool en_thri = false;\r\nstruct omap8250_priv *priv = p->port.private_data;\r\ndma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\nspin_lock_irqsave(&p->port.lock, flags);\r\ndma->tx_running = 0;\r\nxmit->tail += dma->tx_size;\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\np->port.icount.tx += dma->tx_size;\r\nif (priv->delayed_restore) {\r\npriv->delayed_restore = 0;\r\nomap8250_restore_regs(p);\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&p->port);\r\nif (!uart_circ_empty(xmit) && !uart_tx_stopped(&p->port)) {\r\nint ret;\r\nret = omap_8250_tx_dma(p);\r\nif (ret)\r\nen_thri = true;\r\n} else if (p->capabilities & UART_CAP_RPM) {\r\nen_thri = true;\r\n}\r\nif (en_thri) {\r\ndma->tx_err = 1;\r\np->ier |= UART_IER_THRI;\r\nserial_port_out(&p->port, UART_IER, p->ier);\r\n}\r\nspin_unlock_irqrestore(&p->port.lock, flags);\r\n}\r\nstatic int omap_8250_tx_dma(struct uart_8250_port *p)\r\n{\r\nstruct uart_8250_dma *dma = p->dma;\r\nstruct omap8250_priv *priv = p->port.private_data;\r\nstruct circ_buf *xmit = &p->port.state->xmit;\r\nstruct dma_async_tx_descriptor *desc;\r\nunsigned int skip_byte = 0;\r\nint ret;\r\nif (dma->tx_running)\r\nreturn 0;\r\nif (uart_tx_stopped(&p->port) || uart_circ_empty(xmit)) {\r\nif (dma->tx_err || p->capabilities & UART_CAP_RPM) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nif (p->ier & UART_IER_THRI) {\r\np->ier &= ~UART_IER_THRI;\r\nserial_out(p, UART_IER, p->ier);\r\n}\r\nreturn 0;\r\n}\r\ndma->tx_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\nif (priv->habit & OMAP_DMA_TX_KICK) {\r\nu8 tx_lvl;\r\ntx_lvl = serial_in(p, UART_OMAP_TX_LVL);\r\nif (tx_lvl == p->tx_loadsz) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nif (dma->tx_size < 4) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nskip_byte = 1;\r\n}\r\ndesc = dmaengine_prep_slave_single(dma->txchan,\r\ndma->tx_addr + xmit->tail + skip_byte,\r\ndma->tx_size - skip_byte, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\ndma->tx_running = 1;\r\ndesc->callback = omap_8250_dma_tx_complete;\r\ndesc->callback_param = p;\r\ndma->tx_cookie = dmaengine_submit(desc);\r\ndma_sync_single_for_device(dma->txchan->device->dev, dma->tx_addr,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\ndma_async_issue_pending(dma->txchan);\r\nif (dma->tx_err)\r\ndma->tx_err = 0;\r\nif (p->ier & UART_IER_THRI) {\r\np->ier &= ~UART_IER_THRI;\r\nserial_out(p, UART_IER, p->ier);\r\n}\r\nif (skip_byte)\r\nserial_out(p, UART_TX, xmit->buf[xmit->tail]);\r\nreturn 0;\r\nerr:\r\ndma->tx_err = 1;\r\nreturn ret;\r\n}\r\nstatic bool handle_rx_dma(struct uart_8250_port *up, unsigned int iir)\r\n{\r\nswitch (iir & 0x3f) {\r\ncase UART_IIR_RLSI:\r\ncase UART_IIR_RX_TIMEOUT:\r\ncase UART_IIR_RDI:\r\nomap_8250_rx_dma_flush(up);\r\nreturn true;\r\n}\r\nreturn omap_8250_rx_dma(up);\r\n}\r\nstatic int omap_8250_dma_handle_irq(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nunsigned char status;\r\nunsigned long flags;\r\nu8 iir;\r\nserial8250_rpm_get(up);\r\niir = serial_port_in(port, UART_IIR);\r\nif (iir & UART_IIR_NO_INT) {\r\nserial8250_rpm_put(up);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&port->lock, flags);\r\nstatus = serial_port_in(port, UART_LSR);\r\nif (status & (UART_LSR_DR | UART_LSR_BI)) {\r\nif (handle_rx_dma(up, iir)) {\r\nstatus = serial8250_rx_chars(up, status);\r\nomap_8250_rx_dma(up);\r\n}\r\n}\r\nserial8250_modem_status(up);\r\nif (status & UART_LSR_THRE && up->dma->tx_err) {\r\nif (uart_tx_stopped(&up->port) ||\r\nuart_circ_empty(&up->port.state->xmit)) {\r\nup->dma->tx_err = 0;\r\nserial8250_tx_chars(up);\r\n} else {\r\nif (omap_8250_tx_dma(up))\r\nserial8250_tx_chars(up);\r\n}\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nserial8250_rpm_put(up);\r\nreturn 1;\r\n}\r\nstatic bool the_no_dma_filter_fn(struct dma_chan *chan, void *param)\r\n{\r\nreturn false;\r\n}\r\nstatic inline int omap_8250_rx_dma(struct uart_8250_port *p)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int omap8250_no_handle_irq(struct uart_port *port)\r\n{\r\nWARN_ONCE(1, "Unexpected irq handling before port startup\n");\r\nreturn 0;\r\n}\r\nstatic int omap8250_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nstruct omap8250_priv *priv;\r\nstruct uart_8250_port up;\r\nint ret;\r\nvoid __iomem *membase;\r\nif (!regs || !irq) {\r\ndev_err(&pdev->dev, "missing registers or irq\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmembase = devm_ioremap_nocache(&pdev->dev, regs->start,\r\nresource_size(regs));\r\nif (!membase)\r\nreturn -ENODEV;\r\nmemset(&up, 0, sizeof(up));\r\nup.port.dev = &pdev->dev;\r\nup.port.mapbase = regs->start;\r\nup.port.membase = membase;\r\nup.port.irq = irq->start;\r\nup.port.type = PORT_8250;\r\nup.port.iotype = UPIO_MEM;\r\nup.port.flags = UPF_FIXED_PORT | UPF_FIXED_TYPE | UPF_SOFT_FLOW |\r\nUPF_HARD_FLOW;\r\nup.port.private_data = priv;\r\nup.port.regshift = 2;\r\nup.port.fifosize = 64;\r\nup.tx_loadsz = 64;\r\nup.capabilities = UART_CAP_FIFO;\r\n#ifdef CONFIG_PM\r\nup.capabilities |= UART_CAP_RPM;\r\n#endif\r\nup.port.set_termios = omap_8250_set_termios;\r\nup.port.set_mctrl = omap8250_set_mctrl;\r\nup.port.pm = omap_8250_pm;\r\nup.port.startup = omap_8250_startup;\r\nup.port.shutdown = omap_8250_shutdown;\r\nup.port.throttle = omap_8250_throttle;\r\nup.port.unthrottle = omap_8250_unthrottle;\r\nup.port.rs485_config = omap_8250_rs485_config;\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *id;\r\nret = of_alias_get_id(pdev->dev.of_node, "serial");\r\nof_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&up.port.uartclk);\r\npriv->wakeirq = irq_of_parse_and_map(pdev->dev.of_node, 1);\r\nid = of_match_device(of_match_ptr(omap8250_dt_ids), &pdev->dev);\r\nif (id && id->data)\r\npriv->habit |= *(u8 *)id->data;\r\n} else {\r\nret = pdev->id;\r\n}\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias/pdev id\n");\r\nreturn ret;\r\n}\r\nup.port.line = ret;\r\nif (!up.port.uartclk) {\r\nup.port.uartclk = DEFAULT_CLK_SPEED;\r\ndev_warn(&pdev->dev,\r\n"No clock speed specified: using default: %d\n",\r\nDEFAULT_CLK_SPEED);\r\n}\r\npriv->latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;\r\npriv->calc_latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;\r\npm_qos_add_request(&priv->pm_qos_request, PM_QOS_CPU_DMA_LATENCY,\r\npriv->latency);\r\nINIT_WORK(&priv->qos_work, omap8250_uart_qos_work);\r\nspin_lock_init(&priv->rx_dma_lock);\r\ndevice_init_wakeup(&pdev->dev, true);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, -1);\r\npm_runtime_irq_safe(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nomap_serial_fill_features_erratas(&up, priv);\r\nup.port.handle_irq = omap8250_no_handle_irq;\r\n#ifdef CONFIG_SERIAL_8250_DMA\r\nif (pdev->dev.of_node) {\r\nret = of_property_count_strings(pdev->dev.of_node, "dma-names");\r\nif (ret == 2) {\r\nup.dma = &priv->omap8250_dma;\r\npriv->omap8250_dma.fn = the_no_dma_filter_fn;\r\npriv->omap8250_dma.tx_dma = omap_8250_tx_dma;\r\npriv->omap8250_dma.rx_dma = omap_8250_rx_dma;\r\npriv->omap8250_dma.rx_size = RX_TRIGGER;\r\npriv->omap8250_dma.rxconf.src_maxburst = RX_TRIGGER;\r\npriv->omap8250_dma.txconf.dst_maxburst = TX_TRIGGER;\r\nif (of_machine_is_compatible("ti,am33xx"))\r\npriv->habit |= OMAP_DMA_TX_KICK;\r\npriv->rx_dma_broken = true;\r\n}\r\n}\r\n#endif\r\nret = serial8250_register_8250_port(&up);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "unable to register 8250 port\n");\r\ngoto err;\r\n}\r\npriv->line = ret;\r\nplatform_set_drvdata(pdev, priv);\r\npm_runtime_mark_last_busy(&pdev->dev);\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nreturn 0;\r\nerr:\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int omap8250_remove(struct platform_device *pdev)\r\n{\r\nstruct omap8250_priv *priv = platform_get_drvdata(pdev);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nserial8250_unregister_port(priv->line);\r\npm_qos_remove_request(&priv->pm_qos_request);\r\ndevice_init_wakeup(&pdev->dev, false);\r\nreturn 0;\r\n}\r\nstatic int omap8250_prepare(struct device *dev)\r\n{\r\nstruct omap8250_priv *priv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn 0;\r\npriv->is_suspending = true;\r\nreturn 0;\r\n}\r\nstatic void omap8250_complete(struct device *dev)\r\n{\r\nstruct omap8250_priv *priv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn;\r\npriv->is_suspending = false;\r\n}\r\nstatic int omap8250_suspend(struct device *dev)\r\n{\r\nstruct omap8250_priv *priv = dev_get_drvdata(dev);\r\nserial8250_suspend_port(priv->line);\r\nflush_work(&priv->qos_work);\r\nreturn 0;\r\n}\r\nstatic int omap8250_resume(struct device *dev)\r\n{\r\nstruct omap8250_priv *priv = dev_get_drvdata(dev);\r\nserial8250_resume_port(priv->line);\r\nreturn 0;\r\n}\r\nstatic int omap8250_lost_context(struct uart_8250_port *up)\r\n{\r\nu32 val;\r\nval = serial_in(up, UART_OMAP_SCR);\r\nif (!val)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int omap8250_soft_reset(struct device *dev)\r\n{\r\nstruct omap8250_priv *priv = dev_get_drvdata(dev);\r\nstruct uart_8250_port *up = serial8250_get_port(priv->line);\r\nint timeout = 100;\r\nint sysc;\r\nint syss;\r\nsysc = serial_in(up, UART_OMAP_SYSC);\r\nsysc |= OMAP_UART_SYSC_SOFTRESET;\r\nserial_out(up, UART_OMAP_SYSC, sysc);\r\ndo {\r\nudelay(1);\r\nsyss = serial_in(up, UART_OMAP_SYSS);\r\n} while (--timeout && !(syss & OMAP_UART_SYSS_RESETDONE));\r\nif (!timeout) {\r\ndev_err(dev, "timed out waiting for reset done\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap8250_runtime_suspend(struct device *dev)\r\n{\r\nstruct omap8250_priv *priv = dev_get_drvdata(dev);\r\nstruct uart_8250_port *up;\r\nup = serial8250_get_port(priv->line);\r\nif (priv->is_suspending && !console_suspend_enabled) {\r\nif (uart_console(&up->port))\r\nreturn -EBUSY;\r\n}\r\nif (priv->habit & UART_ERRATA_CLOCK_DISABLE) {\r\nint ret;\r\nret = omap8250_soft_reset(dev);\r\nif (ret)\r\nreturn ret;\r\nomap8250_update_mdr1(up, priv);\r\n}\r\nif (up->dma && up->dma->rxchan)\r\nomap_8250_rx_dma_flush(up);\r\npriv->latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;\r\nschedule_work(&priv->qos_work);\r\nreturn 0;\r\n}\r\nstatic int omap8250_runtime_resume(struct device *dev)\r\n{\r\nstruct omap8250_priv *priv = dev_get_drvdata(dev);\r\nstruct uart_8250_port *up;\r\nif (!priv)\r\nreturn 0;\r\nup = serial8250_get_port(priv->line);\r\nif (omap8250_lost_context(up))\r\nomap8250_restore_regs(up);\r\nif (up->dma && up->dma->rxchan)\r\nomap_8250_rx_dma(up);\r\npriv->latency = priv->calc_latency;\r\nschedule_work(&priv->qos_work);\r\nreturn 0;\r\n}\r\nstatic int __init omap8250_console_fixup(void)\r\n{\r\nchar *omap_str;\r\nchar *options;\r\nu8 idx;\r\nif (strstr(boot_command_line, "console=ttyS"))\r\nreturn 0;\r\nomap_str = strstr(boot_command_line, "console=ttyO");\r\nif (!omap_str)\r\nreturn 0;\r\nomap_str += 12;\r\nif ('0' <= *omap_str && *omap_str <= '9')\r\nidx = *omap_str - '0';\r\nelse\r\nreturn 0;\r\nomap_str++;\r\nif (omap_str[0] == ',') {\r\nomap_str++;\r\noptions = omap_str;\r\n} else {\r\noptions = NULL;\r\n}\r\nadd_preferred_console("ttyS", idx, options);\r\npr_err("WARNING: Your 'console=ttyO%d' has been replaced by 'ttyS%d'\n",\r\nidx, idx);\r\npr_err("This ensures that you still see kernel messages. Please\n");\r\npr_err("update your kernel commandline.\n");\r\nreturn 0;\r\n}
