static ssize_t tcm_qla2xxx_parse_wwn(const char *name, u64 *wwn, int strict)\r\n{\r\nconst char *cp;\r\nchar c;\r\nu32 nibble;\r\nu32 byte = 0;\r\nu32 pos = 0;\r\nu32 err;\r\n*wwn = 0;\r\nfor (cp = name; cp < &name[TCM_QLA2XXX_NAMELEN - 1]; cp++) {\r\nc = *cp;\r\nif (c == '\n' && cp[1] == '\0')\r\ncontinue;\r\nif (strict && pos++ == 2 && byte++ < 7) {\r\npos = 0;\r\nif (c == ':')\r\ncontinue;\r\nerr = 1;\r\ngoto fail;\r\n}\r\nif (c == '\0') {\r\nerr = 2;\r\nif (strict && byte != 8)\r\ngoto fail;\r\nreturn cp - name;\r\n}\r\nerr = 3;\r\nif (isdigit(c))\r\nnibble = c - '0';\r\nelse if (isxdigit(c) && (islower(c) || !strict))\r\nnibble = tolower(c) - 'a' + 10;\r\nelse\r\ngoto fail;\r\n*wwn = (*wwn << 4) | nibble;\r\n}\r\nerr = 4;\r\nfail:\r\npr_debug("err %u len %zu pos %u byte %u\n",\r\nerr, cp - name, pos, byte);\r\nreturn -1;\r\n}\r\nstatic ssize_t tcm_qla2xxx_format_wwn(char *buf, size_t len, u64 wwn)\r\n{\r\nu8 b[8];\r\nput_unaligned_be64(wwn, b);\r\nreturn snprintf(buf, len,\r\n"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x",\r\nb[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\r\n}\r\nstatic char *tcm_qla2xxx_get_fabric_name(void)\r\n{\r\nreturn "qla2xxx";\r\n}\r\nstatic int tcm_qla2xxx_npiv_extract_wwn(const char *ns, u64 *nm)\r\n{\r\nunsigned int i, j;\r\nu8 wwn[8];\r\nmemset(wwn, 0, sizeof(wwn));\r\nfor (i = 0, j = 0; i < 16; i++) {\r\nint value;\r\nvalue = hex_to_bin(*ns++);\r\nif (value >= 0)\r\nj = (j << 4) | value;\r\nelse\r\nreturn -EINVAL;\r\nif (i % 2) {\r\nwwn[i/2] = j & 0xff;\r\nj = 0;\r\n}\r\n}\r\n*nm = wwn_to_u64(wwn);\r\nreturn 0;\r\n}\r\nstatic int tcm_qla2xxx_npiv_parse_wwn(\r\nconst char *name,\r\nsize_t count,\r\nu64 *wwpn,\r\nu64 *wwnn)\r\n{\r\nunsigned int cnt = count;\r\nint rc;\r\n*wwpn = 0;\r\n*wwnn = 0;\r\nif (name[cnt-1] == '\n' || name[cnt-1] == 0)\r\ncnt--;\r\nif ((cnt != (16+1+16)) || (name[16] != ':'))\r\nreturn -EINVAL;\r\nrc = tcm_qla2xxx_npiv_extract_wwn(&name[0], wwpn);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = tcm_qla2xxx_npiv_extract_wwn(&name[17], wwnn);\r\nif (rc != 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic char *tcm_qla2xxx_npiv_get_fabric_name(void)\r\n{\r\nreturn "qla2xxx_npiv";\r\n}\r\nstatic char *tcm_qla2xxx_get_fabric_wwn(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nstruct tcm_qla2xxx_lport *lport = tpg->lport;\r\nreturn lport->lport_naa_name;\r\n}\r\nstatic u16 tcm_qla2xxx_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn tpg->lport_tpgt;\r\n}\r\nstatic int tcm_qla2xxx_check_demo_mode(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn tpg->tpg_attrib.generate_node_acls;\r\n}\r\nstatic int tcm_qla2xxx_check_demo_mode_cache(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn tpg->tpg_attrib.cache_dynamic_acls;\r\n}\r\nstatic int tcm_qla2xxx_check_demo_write_protect(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn tpg->tpg_attrib.demo_mode_write_protect;\r\n}\r\nstatic int tcm_qla2xxx_check_prod_write_protect(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn tpg->tpg_attrib.prod_mode_write_protect;\r\n}\r\nstatic int tcm_qla2xxx_check_demo_mode_login_only(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn tpg->tpg_attrib.demo_mode_login_only;\r\n}\r\nstatic int tcm_qla2xxx_check_prot_fabric_only(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn tpg->tpg_attrib.fabric_prot_type;\r\n}\r\nstatic u32 tcm_qla2xxx_tpg_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn tpg->lport_tpgt;\r\n}\r\nstatic void tcm_qla2xxx_complete_mcmd(struct work_struct *work)\r\n{\r\nstruct qla_tgt_mgmt_cmd *mcmd = container_of(work,\r\nstruct qla_tgt_mgmt_cmd, free_work);\r\ntransport_generic_free_cmd(&mcmd->se_cmd, 0);\r\n}\r\nstatic void tcm_qla2xxx_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd)\r\n{\r\nINIT_WORK(&mcmd->free_work, tcm_qla2xxx_complete_mcmd);\r\nqueue_work(tcm_qla2xxx_free_wq, &mcmd->free_work);\r\n}\r\nstatic void tcm_qla2xxx_complete_free(struct work_struct *work)\r\n{\r\nstruct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);\r\ncmd->cmd_in_wq = 0;\r\nWARN_ON(cmd->cmd_flags & BIT_16);\r\ncmd->vha->tgt_counters.qla_core_ret_sta_ctio++;\r\ncmd->cmd_flags |= BIT_16;\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\n}\r\nstatic void tcm_qla2xxx_free_cmd(struct qla_tgt_cmd *cmd)\r\n{\r\ncmd->vha->tgt_counters.core_qla_free_cmd++;\r\ncmd->cmd_in_wq = 1;\r\nBUG_ON(cmd->cmd_flags & BIT_20);\r\ncmd->cmd_flags |= BIT_20;\r\nINIT_WORK(&cmd->work, tcm_qla2xxx_complete_free);\r\nqueue_work_on(smp_processor_id(), tcm_qla2xxx_free_wq, &cmd->work);\r\n}\r\nstatic int tcm_qla2xxx_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nstruct qla_tgt_cmd *cmd;\r\nif ((se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) == 0) {\r\ncmd = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);\r\ncmd->cmd_flags |= BIT_14;\r\n}\r\nreturn target_put_sess_cmd(se_cmd);\r\n}\r\nstatic void tcm_qla2xxx_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct qla_tgt_cmd *cmd;\r\nif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) {\r\nstruct qla_tgt_mgmt_cmd *mcmd = container_of(se_cmd,\r\nstruct qla_tgt_mgmt_cmd, se_cmd);\r\nqlt_free_mcmd(mcmd);\r\nreturn;\r\n}\r\ncmd = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);\r\nqlt_free_cmd(cmd);\r\n}\r\nstatic void tcm_qla2xxx_close_session(struct se_session *se_sess)\r\n{\r\nstruct qla_tgt_sess *sess = se_sess->fabric_sess_ptr;\r\nstruct scsi_qla_host *vha;\r\nunsigned long flags;\r\nBUG_ON(!sess);\r\nvha = sess->vha;\r\nspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\r\ntarget_sess_cmd_list_set_waiting(se_sess);\r\nqlt_put_sess(sess);\r\nspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\r\n}\r\nstatic u32 tcm_qla2xxx_sess_get_index(struct se_session *se_sess)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_qla2xxx_write_pending(struct se_cmd *se_cmd)\r\n{\r\nstruct qla_tgt_cmd *cmd = container_of(se_cmd,\r\nstruct qla_tgt_cmd, se_cmd);\r\nif (cmd->aborted) {\r\npr_debug("write_pending aborted cmd[%p] refcount %d "\r\n"transport_state %x, t_state %x, se_cmd_flags %x\n",\r\ncmd,cmd->se_cmd.cmd_kref.refcount.counter,\r\ncmd->se_cmd.transport_state,\r\ncmd->se_cmd.t_state,\r\ncmd->se_cmd.se_cmd_flags);\r\nreturn 0;\r\n}\r\ncmd->cmd_flags |= BIT_3;\r\ncmd->bufflen = se_cmd->data_length;\r\ncmd->dma_data_direction = target_reverse_dma_direction(se_cmd);\r\ncmd->sg_cnt = se_cmd->t_data_nents;\r\ncmd->sg = se_cmd->t_data_sg;\r\ncmd->prot_sg_cnt = se_cmd->t_prot_nents;\r\ncmd->prot_sg = se_cmd->t_prot_sg;\r\ncmd->blk_sz = se_cmd->se_dev->dev_attrib.block_size;\r\nse_cmd->pi_err = 0;\r\nreturn qlt_rdy_to_xfer(cmd);\r\n}\r\nstatic int tcm_qla2xxx_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&se_cmd->t_state_lock, flags);\r\nif (se_cmd->t_state == TRANSPORT_WRITE_PENDING ||\r\nse_cmd->t_state == TRANSPORT_COMPLETE_QF_WP) {\r\nspin_unlock_irqrestore(&se_cmd->t_state_lock, flags);\r\nwait_for_completion_timeout(&se_cmd->t_transport_stop_comp,\r\n50);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&se_cmd->t_state_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void tcm_qla2xxx_set_default_node_attrs(struct se_node_acl *nacl)\r\n{\r\nreturn;\r\n}\r\nstatic int tcm_qla2xxx_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nif (!(se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {\r\nstruct qla_tgt_cmd *cmd = container_of(se_cmd,\r\nstruct qla_tgt_cmd, se_cmd);\r\nreturn cmd->state;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcm_qla2xxx_handle_cmd(scsi_qla_host_t *vha, struct qla_tgt_cmd *cmd,\r\nunsigned char *cdb, uint32_t data_length, int fcp_task_attr,\r\nint data_dir, int bidi)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct se_session *se_sess;\r\nstruct qla_tgt_sess *sess;\r\n#ifdef CONFIG_TCM_QLA2XXX_DEBUG\r\nstruct se_portal_group *se_tpg;\r\nstruct tcm_qla2xxx_tpg *tpg;\r\n#endif\r\nint flags = TARGET_SCF_ACK_KREF;\r\nif (bidi)\r\nflags |= TARGET_SCF_BIDI_OP;\r\nif (se_cmd->cpuid != WORK_CPU_UNBOUND)\r\nflags |= TARGET_SCF_USE_CPUID;\r\nsess = cmd->sess;\r\nif (!sess) {\r\npr_err("Unable to locate struct qla_tgt_sess from qla_tgt_cmd\n");\r\nreturn -EINVAL;\r\n}\r\nse_sess = sess->se_sess;\r\nif (!se_sess) {\r\npr_err("Unable to locate active struct se_session\n");\r\nreturn -EINVAL;\r\n}\r\n#ifdef CONFIG_TCM_QLA2XXX_DEBUG\r\nse_tpg = se_sess->se_tpg;\r\ntpg = container_of(se_tpg, struct tcm_qla2xxx_tpg, se_tpg);\r\nif (unlikely(tpg->tpg_attrib.jam_host)) {\r\nreturn 0;\r\n}\r\n#endif\r\ncmd->vha->tgt_counters.qla_core_sbt_cmd++;\r\nreturn target_submit_cmd(se_cmd, se_sess, cdb, &cmd->sense_buffer[0],\r\ncmd->unpacked_lun, data_length, fcp_task_attr,\r\ndata_dir, flags);\r\n}\r\nstatic void tcm_qla2xxx_handle_data_work(struct work_struct *work)\r\n{\r\nstruct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);\r\nunsigned long flags;\r\ncmd->cmd_in_wq = 0;\r\nspin_lock_irqsave(&cmd->cmd_lock, flags);\r\ncmd->cmd_flags |= CMD_FLAG_DATA_WORK;\r\nif (cmd->aborted) {\r\ncmd->cmd_flags |= CMD_FLAG_DATA_WORK_FREE;\r\nspin_unlock_irqrestore(&cmd->cmd_lock, flags);\r\ntcm_qla2xxx_free_cmd(cmd);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&cmd->cmd_lock, flags);\r\ncmd->vha->tgt_counters.qla_core_ret_ctio++;\r\nif (!cmd->write_data_transferred) {\r\nif (cmd->se_cmd.transport_state & CMD_T_ABORTED) {\r\ncomplete(&cmd->se_cmd.t_transport_stop_comp);\r\nreturn;\r\n}\r\nif (cmd->se_cmd.pi_err)\r\ntransport_generic_request_failure(&cmd->se_cmd,\r\ncmd->se_cmd.pi_err);\r\nelse\r\ntransport_generic_request_failure(&cmd->se_cmd,\r\nTCM_CHECK_CONDITION_ABORT_CMD);\r\nreturn;\r\n}\r\nreturn target_execute_cmd(&cmd->se_cmd);\r\n}\r\nstatic void tcm_qla2xxx_handle_data(struct qla_tgt_cmd *cmd)\r\n{\r\ncmd->cmd_flags |= BIT_10;\r\ncmd->cmd_in_wq = 1;\r\nINIT_WORK(&cmd->work, tcm_qla2xxx_handle_data_work);\r\nqueue_work_on(smp_processor_id(), tcm_qla2xxx_free_wq, &cmd->work);\r\n}\r\nstatic void tcm_qla2xxx_handle_dif_work(struct work_struct *work)\r\n{\r\nstruct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);\r\nkref_get(&cmd->se_cmd.cmd_kref);\r\ntransport_generic_request_failure(&cmd->se_cmd, cmd->se_cmd.pi_err);\r\n}\r\nstatic void tcm_qla2xxx_handle_dif_err(struct qla_tgt_cmd *cmd)\r\n{\r\nINIT_WORK(&cmd->work, tcm_qla2xxx_handle_dif_work);\r\nqueue_work(tcm_qla2xxx_free_wq, &cmd->work);\r\n}\r\nstatic int tcm_qla2xxx_handle_tmr(struct qla_tgt_mgmt_cmd *mcmd, uint32_t lun,\r\nuint8_t tmr_func, uint32_t tag)\r\n{\r\nstruct qla_tgt_sess *sess = mcmd->sess;\r\nstruct se_cmd *se_cmd = &mcmd->se_cmd;\r\nreturn target_submit_tmr(se_cmd, sess->se_sess, NULL, lun, mcmd,\r\ntmr_func, GFP_ATOMIC, tag, TARGET_SCF_ACK_KREF);\r\n}\r\nstatic int tcm_qla2xxx_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nstruct qla_tgt_cmd *cmd = container_of(se_cmd,\r\nstruct qla_tgt_cmd, se_cmd);\r\nif (cmd->aborted) {\r\npr_debug("queue_data_in aborted cmd[%p] refcount %d "\r\n"transport_state %x, t_state %x, se_cmd_flags %x\n",\r\ncmd,cmd->se_cmd.cmd_kref.refcount.counter,\r\ncmd->se_cmd.transport_state,\r\ncmd->se_cmd.t_state,\r\ncmd->se_cmd.se_cmd_flags);\r\nreturn 0;\r\n}\r\ncmd->cmd_flags |= BIT_4;\r\ncmd->bufflen = se_cmd->data_length;\r\ncmd->dma_data_direction = target_reverse_dma_direction(se_cmd);\r\ncmd->sg_cnt = se_cmd->t_data_nents;\r\ncmd->sg = se_cmd->t_data_sg;\r\ncmd->offset = 0;\r\ncmd->prot_sg_cnt = se_cmd->t_prot_nents;\r\ncmd->prot_sg = se_cmd->t_prot_sg;\r\ncmd->blk_sz = se_cmd->se_dev->dev_attrib.block_size;\r\nse_cmd->pi_err = 0;\r\nreturn qlt_xmit_response(cmd, QLA_TGT_XMIT_DATA|QLA_TGT_XMIT_STATUS,\r\nse_cmd->scsi_status);\r\n}\r\nstatic int tcm_qla2xxx_queue_status(struct se_cmd *se_cmd)\r\n{\r\nstruct qla_tgt_cmd *cmd = container_of(se_cmd,\r\nstruct qla_tgt_cmd, se_cmd);\r\nint xmit_type = QLA_TGT_XMIT_STATUS;\r\ncmd->bufflen = se_cmd->data_length;\r\ncmd->sg = NULL;\r\ncmd->sg_cnt = 0;\r\ncmd->offset = 0;\r\ncmd->dma_data_direction = target_reverse_dma_direction(se_cmd);\r\nif (cmd->cmd_flags & BIT_5) {\r\npr_crit("Bit_5 already set for cmd = %p.\n", cmd);\r\ndump_stack();\r\n}\r\ncmd->cmd_flags |= BIT_5;\r\nif (se_cmd->data_direction == DMA_FROM_DEVICE) {\r\nif (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\r\nse_cmd->se_cmd_flags &= ~SCF_OVERFLOW_BIT;\r\nse_cmd->residual_count = 0;\r\n}\r\nse_cmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\r\nse_cmd->residual_count += se_cmd->data_length;\r\ncmd->bufflen = 0;\r\n}\r\nreturn qlt_xmit_response(cmd, xmit_type, se_cmd->scsi_status);\r\n}\r\nstatic void tcm_qla2xxx_queue_tm_rsp(struct se_cmd *se_cmd)\r\n{\r\nstruct se_tmr_req *se_tmr = se_cmd->se_tmr_req;\r\nstruct qla_tgt_mgmt_cmd *mcmd = container_of(se_cmd,\r\nstruct qla_tgt_mgmt_cmd, se_cmd);\r\npr_debug("queue_tm_rsp: mcmd: %p func: 0x%02x response: 0x%02x\n",\r\nmcmd, se_tmr->function, se_tmr->response);\r\nswitch (se_tmr->response) {\r\ncase TMR_FUNCTION_COMPLETE:\r\nmcmd->fc_tm_rsp = FC_TM_SUCCESS;\r\nbreak;\r\ncase TMR_TASK_DOES_NOT_EXIST:\r\nmcmd->fc_tm_rsp = FC_TM_BAD_CMD;\r\nbreak;\r\ncase TMR_FUNCTION_REJECTED:\r\nmcmd->fc_tm_rsp = FC_TM_REJECT;\r\nbreak;\r\ncase TMR_LUN_DOES_NOT_EXIST:\r\ndefault:\r\nmcmd->fc_tm_rsp = FC_TM_FAILED;\r\nbreak;\r\n}\r\nqlt_xmit_tm_rsp(mcmd);\r\n}\r\nstatic void tcm_qla2xxx_aborted_task(struct se_cmd *se_cmd)\r\n{\r\nstruct qla_tgt_cmd *cmd = container_of(se_cmd,\r\nstruct qla_tgt_cmd, se_cmd);\r\nunsigned long flags;\r\nif (qlt_abort_cmd(cmd))\r\nreturn;\r\nspin_lock_irqsave(&cmd->cmd_lock, flags);\r\nif ((cmd->state == QLA_TGT_STATE_NEW)||\r\n((cmd->state == QLA_TGT_STATE_DATA_IN) &&\r\nDATA_WORK_NOT_FREE(cmd->cmd_flags)) ) {\r\ncmd->cmd_flags |= CMD_FLAG_DATA_WORK_FREE;\r\nspin_unlock_irqrestore(&cmd->cmd_lock, flags);\r\ntcm_qla2xxx_free_cmd(cmd);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&cmd->cmd_lock, flags);\r\nreturn;\r\n}\r\nstatic void tcm_qla2xxx_clear_nacl_from_fcport_map(struct qla_tgt_sess *sess)\r\n{\r\nstruct se_node_acl *se_nacl = sess->se_sess->se_node_acl;\r\nstruct se_portal_group *se_tpg = se_nacl->se_tpg;\r\nstruct se_wwn *se_wwn = se_tpg->se_tpg_wwn;\r\nstruct tcm_qla2xxx_lport *lport = container_of(se_wwn,\r\nstruct tcm_qla2xxx_lport, lport_wwn);\r\nstruct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,\r\nstruct tcm_qla2xxx_nacl, se_node_acl);\r\nvoid *node;\r\npr_debug("fc_rport domain: port_id 0x%06x\n", nacl->nport_id);\r\nnode = btree_remove32(&lport->lport_fcport_map, nacl->nport_id);\r\nif (WARN_ON(node && (node != se_nacl))) {\r\nbtree_insert32(&lport->lport_fcport_map, nacl->nport_id,\r\nnode, GFP_ATOMIC);\r\n}\r\npr_debug("Removed from fcport_map: %p for WWNN: 0x%016LX, port_id: 0x%06x\n",\r\nse_nacl, nacl->nport_wwnn, nacl->nport_id);\r\ntcm_qla2xxx_clear_sess_lookup(lport, nacl, sess);\r\n}\r\nstatic void tcm_qla2xxx_shutdown_sess(struct qla_tgt_sess *sess)\r\n{\r\nassert_spin_locked(&sess->vha->hw->tgt.sess_lock);\r\ntarget_sess_cmd_list_set_waiting(sess->se_sess);\r\n}\r\nstatic int tcm_qla2xxx_init_nodeacl(struct se_node_acl *se_nacl,\r\nconst char *name)\r\n{\r\nstruct tcm_qla2xxx_nacl *nacl =\r\ncontainer_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);\r\nu64 wwnn;\r\nif (tcm_qla2xxx_parse_wwn(name, &wwnn, 1) < 0)\r\nreturn -EINVAL;\r\nnacl->nport_wwnn = wwnn;\r\ntcm_qla2xxx_format_wwn(&nacl->nport_name[0], TCM_QLA2XXX_NAMELEN, wwnn);\r\nreturn 0;\r\n}\r\nstatic ssize_t tcm_qla2xxx_tpg_enable_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn snprintf(page, PAGE_SIZE, "%d\n",\r\natomic_read(&tpg->lport_tpg_enabled));\r\n}\r\nstatic void tcm_qla2xxx_depend_tpg(struct work_struct *work)\r\n{\r\nstruct tcm_qla2xxx_tpg *base_tpg = container_of(work,\r\nstruct tcm_qla2xxx_tpg, tpg_base_work);\r\nstruct se_portal_group *se_tpg = &base_tpg->se_tpg;\r\nstruct scsi_qla_host *base_vha = base_tpg->lport->qla_vha;\r\nif (!target_depend_item(&se_tpg->tpg_group.cg_item)) {\r\natomic_set(&base_tpg->lport_tpg_enabled, 1);\r\nqlt_enable_vha(base_vha);\r\n}\r\ncomplete(&base_tpg->tpg_base_comp);\r\n}\r\nstatic void tcm_qla2xxx_undepend_tpg(struct work_struct *work)\r\n{\r\nstruct tcm_qla2xxx_tpg *base_tpg = container_of(work,\r\nstruct tcm_qla2xxx_tpg, tpg_base_work);\r\nstruct se_portal_group *se_tpg = &base_tpg->se_tpg;\r\nstruct scsi_qla_host *base_vha = base_tpg->lport->qla_vha;\r\nif (!qlt_stop_phase1(base_vha->vha_tgt.qla_tgt)) {\r\natomic_set(&base_tpg->lport_tpg_enabled, 0);\r\ntarget_undepend_item(&se_tpg->tpg_group.cg_item);\r\n}\r\ncomplete(&base_tpg->tpg_base_comp);\r\n}\r\nstatic ssize_t tcm_qla2xxx_tpg_enable_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nunsigned long op;\r\nint rc;\r\nrc = kstrtoul(page, 0, &op);\r\nif (rc < 0) {\r\npr_err("kstrtoul() returned %d\n", rc);\r\nreturn -EINVAL;\r\n}\r\nif ((op != 1) && (op != 0)) {\r\npr_err("Illegal value for tpg_enable: %lu\n", op);\r\nreturn -EINVAL;\r\n}\r\nif (op) {\r\nif (atomic_read(&tpg->lport_tpg_enabled))\r\nreturn -EEXIST;\r\nINIT_WORK(&tpg->tpg_base_work, tcm_qla2xxx_depend_tpg);\r\n} else {\r\nif (!atomic_read(&tpg->lport_tpg_enabled))\r\nreturn count;\r\nINIT_WORK(&tpg->tpg_base_work, tcm_qla2xxx_undepend_tpg);\r\n}\r\ninit_completion(&tpg->tpg_base_comp);\r\nschedule_work(&tpg->tpg_base_work);\r\nwait_for_completion(&tpg->tpg_base_comp);\r\nif (op) {\r\nif (!atomic_read(&tpg->lport_tpg_enabled))\r\nreturn -ENODEV;\r\n} else {\r\nif (atomic_read(&tpg->lport_tpg_enabled))\r\nreturn -EPERM;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t tcm_qla2xxx_tpg_dynamic_sessions_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn target_show_dynamic_sessions(to_tpg(item), page);\r\n}\r\nstatic ssize_t tcm_qla2xxx_tpg_fabric_prot_type_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nunsigned long val;\r\nint ret = kstrtoul(page, 0, &val);\r\nif (ret) {\r\npr_err("kstrtoul() returned %d for fabric_prot_type\n", ret);\r\nreturn ret;\r\n}\r\nif (val != 0 && val != 1 && val != 3) {\r\npr_err("Invalid qla2xxx fabric_prot_type: %lu\n", val);\r\nreturn -EINVAL;\r\n}\r\ntpg->tpg_attrib.fabric_prot_type = val;\r\nreturn count;\r\n}\r\nstatic ssize_t tcm_qla2xxx_tpg_fabric_prot_type_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nreturn sprintf(page, "%d\n", tpg->tpg_attrib.fabric_prot_type);\r\n}\r\nstatic struct se_portal_group *tcm_qla2xxx_make_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct tcm_qla2xxx_lport *lport = container_of(wwn,\r\nstruct tcm_qla2xxx_lport, lport_wwn);\r\nstruct tcm_qla2xxx_tpg *tpg;\r\nunsigned long tpgt;\r\nint ret;\r\nif (strstr(name, "tpgt_") != name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (kstrtoul(name + 5, 10, &tpgt) || tpgt > USHRT_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nif ((tpgt != 1)) {\r\npr_err("In non NPIV mode, a single TPG=1 is used for HW port mappings\n");\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\ntpg = kzalloc(sizeof(struct tcm_qla2xxx_tpg), GFP_KERNEL);\r\nif (!tpg) {\r\npr_err("Unable to allocate struct tcm_qla2xxx_tpg\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ntpg->lport = lport;\r\ntpg->lport_tpgt = tpgt;\r\ntpg->tpg_attrib.generate_node_acls = 1;\r\ntpg->tpg_attrib.demo_mode_write_protect = 1;\r\ntpg->tpg_attrib.cache_dynamic_acls = 1;\r\ntpg->tpg_attrib.demo_mode_login_only = 1;\r\ntpg->tpg_attrib.jam_host = 0;\r\nret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);\r\nif (ret < 0) {\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\nlport->tpg_1 = tpg;\r\nreturn &tpg->se_tpg;\r\n}\r\nstatic void tcm_qla2xxx_drop_tpg(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nstruct tcm_qla2xxx_lport *lport = tpg->lport;\r\nstruct scsi_qla_host *vha = lport->qla_vha;\r\nif (vha->vha_tgt.qla_tgt && !vha->vha_tgt.qla_tgt->tgt_stop)\r\nqlt_stop_phase1(vha->vha_tgt.qla_tgt);\r\ncore_tpg_deregister(se_tpg);\r\nlport->tpg_1 = NULL;\r\nkfree(tpg);\r\n}\r\nstatic ssize_t tcm_qla2xxx_npiv_tpg_enable_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn tcm_qla2xxx_tpg_enable_show(item, page);\r\n}\r\nstatic ssize_t tcm_qla2xxx_npiv_tpg_enable_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct se_wwn *se_wwn = se_tpg->se_tpg_wwn;\r\nstruct tcm_qla2xxx_lport *lport = container_of(se_wwn,\r\nstruct tcm_qla2xxx_lport, lport_wwn);\r\nstruct scsi_qla_host *vha = lport->qla_vha;\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nunsigned long op;\r\nint rc;\r\nrc = kstrtoul(page, 0, &op);\r\nif (rc < 0) {\r\npr_err("kstrtoul() returned %d\n", rc);\r\nreturn -EINVAL;\r\n}\r\nif ((op != 1) && (op != 0)) {\r\npr_err("Illegal value for tpg_enable: %lu\n", op);\r\nreturn -EINVAL;\r\n}\r\nif (op) {\r\nif (atomic_read(&tpg->lport_tpg_enabled))\r\nreturn -EEXIST;\r\natomic_set(&tpg->lport_tpg_enabled, 1);\r\nqlt_enable_vha(vha);\r\n} else {\r\nif (!atomic_read(&tpg->lport_tpg_enabled))\r\nreturn count;\r\natomic_set(&tpg->lport_tpg_enabled, 0);\r\nqlt_stop_phase1(vha->vha_tgt.qla_tgt);\r\n}\r\nreturn count;\r\n}\r\nstatic struct se_portal_group *tcm_qla2xxx_npiv_make_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct tcm_qla2xxx_lport *lport = container_of(wwn,\r\nstruct tcm_qla2xxx_lport, lport_wwn);\r\nstruct tcm_qla2xxx_tpg *tpg;\r\nunsigned long tpgt;\r\nint ret;\r\nif (strstr(name, "tpgt_") != name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (kstrtoul(name + 5, 10, &tpgt) || tpgt > USHRT_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\ntpg = kzalloc(sizeof(struct tcm_qla2xxx_tpg), GFP_KERNEL);\r\nif (!tpg) {\r\npr_err("Unable to allocate struct tcm_qla2xxx_tpg\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ntpg->lport = lport;\r\ntpg->lport_tpgt = tpgt;\r\ntpg->tpg_attrib.generate_node_acls = 1;\r\ntpg->tpg_attrib.demo_mode_write_protect = 1;\r\ntpg->tpg_attrib.cache_dynamic_acls = 1;\r\ntpg->tpg_attrib.demo_mode_login_only = 1;\r\nret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);\r\nif (ret < 0) {\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\nlport->tpg_1 = tpg;\r\nreturn &tpg->se_tpg;\r\n}\r\nstatic struct qla_tgt_sess *tcm_qla2xxx_find_sess_by_s_id(\r\nscsi_qla_host_t *vha,\r\nconst uint8_t *s_id)\r\n{\r\nstruct tcm_qla2xxx_lport *lport;\r\nstruct se_node_acl *se_nacl;\r\nstruct tcm_qla2xxx_nacl *nacl;\r\nu32 key;\r\nlport = vha->vha_tgt.target_lport_ptr;\r\nif (!lport) {\r\npr_err("Unable to locate struct tcm_qla2xxx_lport\n");\r\ndump_stack();\r\nreturn NULL;\r\n}\r\nkey = sid_to_key(s_id);\r\npr_debug("find_sess_by_s_id: 0x%06x\n", key);\r\nse_nacl = btree_lookup32(&lport->lport_fcport_map, key);\r\nif (!se_nacl) {\r\npr_debug("Unable to locate s_id: 0x%06x\n", key);\r\nreturn NULL;\r\n}\r\npr_debug("find_sess_by_s_id: located se_nacl: %p, initiatorname: %s\n",\r\nse_nacl, se_nacl->initiatorname);\r\nnacl = container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);\r\nif (!nacl->qla_tgt_sess) {\r\npr_err("Unable to locate struct qla_tgt_sess\n");\r\nreturn NULL;\r\n}\r\nreturn nacl->qla_tgt_sess;\r\n}\r\nstatic void tcm_qla2xxx_set_sess_by_s_id(\r\nstruct tcm_qla2xxx_lport *lport,\r\nstruct se_node_acl *new_se_nacl,\r\nstruct tcm_qla2xxx_nacl *nacl,\r\nstruct se_session *se_sess,\r\nstruct qla_tgt_sess *qla_tgt_sess,\r\nuint8_t *s_id)\r\n{\r\nu32 key;\r\nvoid *slot;\r\nint rc;\r\nkey = sid_to_key(s_id);\r\npr_debug("set_sess_by_s_id: %06x\n", key);\r\nslot = btree_lookup32(&lport->lport_fcport_map, key);\r\nif (!slot) {\r\nif (new_se_nacl) {\r\npr_debug("Setting up new fc_port entry to new_se_nacl\n");\r\nnacl->nport_id = key;\r\nrc = btree_insert32(&lport->lport_fcport_map, key,\r\nnew_se_nacl, GFP_ATOMIC);\r\nif (rc)\r\nprintk(KERN_ERR "Unable to insert s_id into fcport_map: %06x\n",\r\n(int)key);\r\n} else {\r\npr_debug("Wiping nonexisting fc_port entry\n");\r\n}\r\nqla_tgt_sess->se_sess = se_sess;\r\nnacl->qla_tgt_sess = qla_tgt_sess;\r\nreturn;\r\n}\r\nif (nacl->qla_tgt_sess) {\r\nif (new_se_nacl == NULL) {\r\npr_debug("Clearing existing nacl->qla_tgt_sess and fc_port entry\n");\r\nbtree_remove32(&lport->lport_fcport_map, key);\r\nnacl->qla_tgt_sess = NULL;\r\nreturn;\r\n}\r\npr_debug("Replacing existing nacl->qla_tgt_sess and fc_port entry\n");\r\nbtree_update32(&lport->lport_fcport_map, key, new_se_nacl);\r\nqla_tgt_sess->se_sess = se_sess;\r\nnacl->qla_tgt_sess = qla_tgt_sess;\r\nreturn;\r\n}\r\nif (new_se_nacl == NULL) {\r\npr_debug("Clearing existing fc_port entry\n");\r\nbtree_remove32(&lport->lport_fcport_map, key);\r\nreturn;\r\n}\r\npr_debug("Replacing existing fc_port entry w/o active nacl->qla_tgt_sess\n");\r\nbtree_update32(&lport->lport_fcport_map, key, new_se_nacl);\r\nqla_tgt_sess->se_sess = se_sess;\r\nnacl->qla_tgt_sess = qla_tgt_sess;\r\npr_debug("Setup nacl->qla_tgt_sess %p by s_id for se_nacl: %p, initiatorname: %s\n",\r\nnacl->qla_tgt_sess, new_se_nacl, new_se_nacl->initiatorname);\r\n}\r\nstatic struct qla_tgt_sess *tcm_qla2xxx_find_sess_by_loop_id(\r\nscsi_qla_host_t *vha,\r\nconst uint16_t loop_id)\r\n{\r\nstruct tcm_qla2xxx_lport *lport;\r\nstruct se_node_acl *se_nacl;\r\nstruct tcm_qla2xxx_nacl *nacl;\r\nstruct tcm_qla2xxx_fc_loopid *fc_loopid;\r\nlport = vha->vha_tgt.target_lport_ptr;\r\nif (!lport) {\r\npr_err("Unable to locate struct tcm_qla2xxx_lport\n");\r\ndump_stack();\r\nreturn NULL;\r\n}\r\npr_debug("find_sess_by_loop_id: Using loop_id: 0x%04x\n", loop_id);\r\nfc_loopid = lport->lport_loopid_map + loop_id;\r\nse_nacl = fc_loopid->se_nacl;\r\nif (!se_nacl) {\r\npr_debug("Unable to locate se_nacl by loop_id: 0x%04x\n",\r\nloop_id);\r\nreturn NULL;\r\n}\r\nnacl = container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);\r\nif (!nacl->qla_tgt_sess) {\r\npr_err("Unable to locate struct qla_tgt_sess\n");\r\nreturn NULL;\r\n}\r\nreturn nacl->qla_tgt_sess;\r\n}\r\nstatic void tcm_qla2xxx_set_sess_by_loop_id(\r\nstruct tcm_qla2xxx_lport *lport,\r\nstruct se_node_acl *new_se_nacl,\r\nstruct tcm_qla2xxx_nacl *nacl,\r\nstruct se_session *se_sess,\r\nstruct qla_tgt_sess *qla_tgt_sess,\r\nuint16_t loop_id)\r\n{\r\nstruct se_node_acl *saved_nacl;\r\nstruct tcm_qla2xxx_fc_loopid *fc_loopid;\r\npr_debug("set_sess_by_loop_id: Using loop_id: 0x%04x\n", loop_id);\r\nfc_loopid = &((struct tcm_qla2xxx_fc_loopid *)\r\nlport->lport_loopid_map)[loop_id];\r\nsaved_nacl = fc_loopid->se_nacl;\r\nif (!saved_nacl) {\r\npr_debug("Setting up new fc_loopid->se_nacl to new_se_nacl\n");\r\nfc_loopid->se_nacl = new_se_nacl;\r\nif (qla_tgt_sess->se_sess != se_sess)\r\nqla_tgt_sess->se_sess = se_sess;\r\nif (nacl->qla_tgt_sess != qla_tgt_sess)\r\nnacl->qla_tgt_sess = qla_tgt_sess;\r\nreturn;\r\n}\r\nif (nacl->qla_tgt_sess) {\r\nif (new_se_nacl == NULL) {\r\npr_debug("Clearing nacl->qla_tgt_sess and fc_loopid->se_nacl\n");\r\nfc_loopid->se_nacl = NULL;\r\nnacl->qla_tgt_sess = NULL;\r\nreturn;\r\n}\r\npr_debug("Replacing existing nacl->qla_tgt_sess and fc_loopid->se_nacl\n");\r\nfc_loopid->se_nacl = new_se_nacl;\r\nif (qla_tgt_sess->se_sess != se_sess)\r\nqla_tgt_sess->se_sess = se_sess;\r\nif (nacl->qla_tgt_sess != qla_tgt_sess)\r\nnacl->qla_tgt_sess = qla_tgt_sess;\r\nreturn;\r\n}\r\nif (new_se_nacl == NULL) {\r\npr_debug("Clearing fc_loopid->se_nacl\n");\r\nfc_loopid->se_nacl = NULL;\r\nreturn;\r\n}\r\npr_debug("Replacing existing fc_loopid->se_nacl w/o active nacl->qla_tgt_sess\n");\r\nfc_loopid->se_nacl = new_se_nacl;\r\nif (qla_tgt_sess->se_sess != se_sess)\r\nqla_tgt_sess->se_sess = se_sess;\r\nif (nacl->qla_tgt_sess != qla_tgt_sess)\r\nnacl->qla_tgt_sess = qla_tgt_sess;\r\npr_debug("Setup nacl->qla_tgt_sess %p by loop_id for se_nacl: %p, initiatorname: %s\n",\r\nnacl->qla_tgt_sess, new_se_nacl, new_se_nacl->initiatorname);\r\n}\r\nstatic void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *lport,\r\nstruct tcm_qla2xxx_nacl *nacl, struct qla_tgt_sess *sess)\r\n{\r\nstruct se_session *se_sess = sess->se_sess;\r\nunsigned char be_sid[3];\r\nbe_sid[0] = sess->s_id.b.domain;\r\nbe_sid[1] = sess->s_id.b.area;\r\nbe_sid[2] = sess->s_id.b.al_pa;\r\ntcm_qla2xxx_set_sess_by_s_id(lport, NULL, nacl, se_sess,\r\nsess, be_sid);\r\ntcm_qla2xxx_set_sess_by_loop_id(lport, NULL, nacl, se_sess,\r\nsess, sess->loop_id);\r\n}\r\nstatic void tcm_qla2xxx_free_session(struct qla_tgt_sess *sess)\r\n{\r\nstruct qla_tgt *tgt = sess->tgt;\r\nstruct qla_hw_data *ha = tgt->ha;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nstruct se_session *se_sess;\r\nstruct tcm_qla2xxx_lport *lport;\r\nBUG_ON(in_interrupt());\r\nse_sess = sess->se_sess;\r\nif (!se_sess) {\r\npr_err("struct qla_tgt_sess->se_sess is NULL\n");\r\ndump_stack();\r\nreturn;\r\n}\r\nlport = vha->vha_tgt.target_lport_ptr;\r\nif (!lport) {\r\npr_err("Unable to locate struct tcm_qla2xxx_lport\n");\r\ndump_stack();\r\nreturn;\r\n}\r\ntarget_wait_for_sess_cmds(se_sess);\r\ntransport_deregister_session_configfs(sess->se_sess);\r\ntransport_deregister_session(sess->se_sess);\r\n}\r\nstatic int tcm_qla2xxx_session_cb(struct se_portal_group *se_tpg,\r\nstruct se_session *se_sess, void *p)\r\n{\r\nstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\r\nstruct tcm_qla2xxx_tpg, se_tpg);\r\nstruct tcm_qla2xxx_lport *lport = tpg->lport;\r\nstruct qla_hw_data *ha = lport->qla_vha->hw;\r\nstruct se_node_acl *se_nacl = se_sess->se_node_acl;\r\nstruct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,\r\nstruct tcm_qla2xxx_nacl, se_node_acl);\r\nstruct qla_tgt_sess *qlat_sess = p;\r\nuint16_t loop_id = qlat_sess->loop_id;\r\nunsigned long flags;\r\nunsigned char be_sid[3];\r\nbe_sid[0] = qlat_sess->s_id.b.domain;\r\nbe_sid[1] = qlat_sess->s_id.b.area;\r\nbe_sid[2] = qlat_sess->s_id.b.al_pa;\r\nspin_lock_irqsave(&ha->tgt.sess_lock, flags);\r\ntcm_qla2xxx_set_sess_by_s_id(lport, se_nacl, nacl,\r\nse_sess, qlat_sess, be_sid);\r\ntcm_qla2xxx_set_sess_by_loop_id(lport, se_nacl, nacl,\r\nse_sess, qlat_sess, loop_id);\r\nspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int tcm_qla2xxx_check_initiator_node_acl(\r\nscsi_qla_host_t *vha,\r\nunsigned char *fc_wwpn,\r\nstruct qla_tgt_sess *qlat_sess)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct tcm_qla2xxx_lport *lport;\r\nstruct tcm_qla2xxx_tpg *tpg;\r\nstruct se_session *se_sess;\r\nunsigned char port_name[36];\r\nint num_tags = (ha->cur_fw_xcb_count) ? ha->cur_fw_xcb_count :\r\nTCM_QLA2XXX_DEFAULT_TAGS;\r\nlport = vha->vha_tgt.target_lport_ptr;\r\nif (!lport) {\r\npr_err("Unable to locate struct tcm_qla2xxx_lport\n");\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\ntpg = lport->tpg_1;\r\nif (!tpg) {\r\npr_err("Unable to lcoate struct tcm_qla2xxx_lport->tpg_1\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&port_name, 0, 36);\r\nsnprintf(port_name, sizeof(port_name), "%8phC", fc_wwpn);\r\nse_sess = target_alloc_session(&tpg->se_tpg, num_tags,\r\nsizeof(struct qla_tgt_cmd),\r\nTARGET_PROT_ALL, port_name,\r\nqlat_sess, tcm_qla2xxx_session_cb);\r\nif (IS_ERR(se_sess))\r\nreturn PTR_ERR(se_sess);\r\nreturn 0;\r\n}\r\nstatic void tcm_qla2xxx_update_sess(struct qla_tgt_sess *sess, port_id_t s_id,\r\nuint16_t loop_id, bool conf_compl_supported)\r\n{\r\nstruct qla_tgt *tgt = sess->tgt;\r\nstruct qla_hw_data *ha = tgt->ha;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nstruct tcm_qla2xxx_lport *lport = vha->vha_tgt.target_lport_ptr;\r\nstruct se_node_acl *se_nacl = sess->se_sess->se_node_acl;\r\nstruct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,\r\nstruct tcm_qla2xxx_nacl, se_node_acl);\r\nu32 key;\r\nif (sess->loop_id != loop_id || sess->s_id.b24 != s_id.b24)\r\npr_info("Updating session %p from port %8phC loop_id %d -> %d s_id %x:%x:%x -> %x:%x:%x\n",\r\nsess, sess->port_name,\r\nsess->loop_id, loop_id, sess->s_id.b.domain,\r\nsess->s_id.b.area, sess->s_id.b.al_pa, s_id.b.domain,\r\ns_id.b.area, s_id.b.al_pa);\r\nif (sess->loop_id != loop_id) {\r\nif (lport->lport_loopid_map[sess->loop_id].se_nacl == se_nacl)\r\nlport->lport_loopid_map[sess->loop_id].se_nacl = NULL;\r\nlport->lport_loopid_map[loop_id].se_nacl = se_nacl;\r\nsess->loop_id = loop_id;\r\n}\r\nif (sess->s_id.b24 != s_id.b24) {\r\nkey = (((u32) sess->s_id.b.domain << 16) |\r\n((u32) sess->s_id.b.area << 8) |\r\n((u32) sess->s_id.b.al_pa));\r\nif (btree_lookup32(&lport->lport_fcport_map, key))\r\nWARN(btree_remove32(&lport->lport_fcport_map, key) != se_nacl,\r\n"Found wrong se_nacl when updating s_id %x:%x:%x\n",\r\nsess->s_id.b.domain, sess->s_id.b.area, sess->s_id.b.al_pa);\r\nelse\r\nWARN(1, "No lport_fcport_map entry for s_id %x:%x:%x\n",\r\nsess->s_id.b.domain, sess->s_id.b.area, sess->s_id.b.al_pa);\r\nkey = (((u32) s_id.b.domain << 16) |\r\n((u32) s_id.b.area << 8) |\r\n((u32) s_id.b.al_pa));\r\nif (btree_lookup32(&lport->lport_fcport_map, key)) {\r\nWARN(1, "Already have lport_fcport_map entry for s_id %x:%x:%x\n",\r\ns_id.b.domain, s_id.b.area, s_id.b.al_pa);\r\nbtree_update32(&lport->lport_fcport_map, key, se_nacl);\r\n} else {\r\nbtree_insert32(&lport->lport_fcport_map, key, se_nacl, GFP_ATOMIC);\r\n}\r\nsess->s_id = s_id;\r\nnacl->nport_id = key;\r\n}\r\nsess->conf_compl_supported = conf_compl_supported;\r\nsess->logout_on_delete = 1;\r\nsess->keep_nport_handle = 0;\r\n}\r\nstatic int tcm_qla2xxx_init_lport(struct tcm_qla2xxx_lport *lport)\r\n{\r\nint rc;\r\nrc = btree_init32(&lport->lport_fcport_map);\r\nif (rc) {\r\npr_err("Unable to initialize lport->lport_fcport_map btree\n");\r\nreturn rc;\r\n}\r\nlport->lport_loopid_map = vmalloc(sizeof(struct tcm_qla2xxx_fc_loopid) *\r\n65536);\r\nif (!lport->lport_loopid_map) {\r\npr_err("Unable to allocate lport->lport_loopid_map of %zu bytes\n",\r\nsizeof(struct tcm_qla2xxx_fc_loopid) * 65536);\r\nbtree_destroy32(&lport->lport_fcport_map);\r\nreturn -ENOMEM;\r\n}\r\nmemset(lport->lport_loopid_map, 0, sizeof(struct tcm_qla2xxx_fc_loopid)\r\n* 65536);\r\npr_debug("qla2xxx: Allocated lport_loopid_map of %zu bytes\n",\r\nsizeof(struct tcm_qla2xxx_fc_loopid) * 65536);\r\nreturn 0;\r\n}\r\nstatic int tcm_qla2xxx_lport_register_cb(struct scsi_qla_host *vha,\r\nvoid *target_lport_ptr,\r\nu64 npiv_wwpn, u64 npiv_wwnn)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct tcm_qla2xxx_lport *lport =\r\n(struct tcm_qla2xxx_lport *)target_lport_ptr;\r\nha->tgt.tgt_ops = &tcm_qla2xxx_template;\r\nvha->vha_tgt.target_lport_ptr = target_lport_ptr;\r\nlport->qla_vha = vha;\r\nreturn 0;\r\n}\r\nstatic struct se_wwn *tcm_qla2xxx_make_lport(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct tcm_qla2xxx_lport *lport;\r\nu64 wwpn;\r\nint ret = -ENODEV;\r\nif (tcm_qla2xxx_parse_wwn(name, &wwpn, 1) < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nlport = kzalloc(sizeof(struct tcm_qla2xxx_lport), GFP_KERNEL);\r\nif (!lport) {\r\npr_err("Unable to allocate struct tcm_qla2xxx_lport\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nlport->lport_wwpn = wwpn;\r\ntcm_qla2xxx_format_wwn(&lport->lport_name[0], TCM_QLA2XXX_NAMELEN,\r\nwwpn);\r\nsprintf(lport->lport_naa_name, "naa.%016llx", (unsigned long long) wwpn);\r\nret = tcm_qla2xxx_init_lport(lport);\r\nif (ret != 0)\r\ngoto out;\r\nret = qlt_lport_register(lport, wwpn, 0, 0,\r\ntcm_qla2xxx_lport_register_cb);\r\nif (ret != 0)\r\ngoto out_lport;\r\nreturn &lport->lport_wwn;\r\nout_lport:\r\nvfree(lport->lport_loopid_map);\r\nbtree_destroy32(&lport->lport_fcport_map);\r\nout:\r\nkfree(lport);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void tcm_qla2xxx_drop_lport(struct se_wwn *wwn)\r\n{\r\nstruct tcm_qla2xxx_lport *lport = container_of(wwn,\r\nstruct tcm_qla2xxx_lport, lport_wwn);\r\nstruct scsi_qla_host *vha = lport->qla_vha;\r\nstruct se_node_acl *node;\r\nu32 key = 0;\r\nif (vha->vha_tgt.qla_tgt && !vha->vha_tgt.qla_tgt->tgt_stopped)\r\nqlt_stop_phase2(vha->vha_tgt.qla_tgt);\r\nqlt_lport_deregister(vha);\r\nvfree(lport->lport_loopid_map);\r\nbtree_for_each_safe32(&lport->lport_fcport_map, key, node)\r\nbtree_remove32(&lport->lport_fcport_map, key);\r\nbtree_destroy32(&lport->lport_fcport_map);\r\nkfree(lport);\r\n}\r\nstatic int tcm_qla2xxx_lport_register_npiv_cb(struct scsi_qla_host *base_vha,\r\nvoid *target_lport_ptr,\r\nu64 npiv_wwpn, u64 npiv_wwnn)\r\n{\r\nstruct fc_vport *vport;\r\nstruct Scsi_Host *sh = base_vha->host;\r\nstruct scsi_qla_host *npiv_vha;\r\nstruct tcm_qla2xxx_lport *lport =\r\n(struct tcm_qla2xxx_lport *)target_lport_ptr;\r\nstruct tcm_qla2xxx_lport *base_lport =\r\n(struct tcm_qla2xxx_lport *)base_vha->vha_tgt.target_lport_ptr;\r\nstruct fc_vport_identifiers vport_id;\r\nif (!qla_tgt_mode_enabled(base_vha)) {\r\npr_err("qla2xxx base_vha not enabled for target mode\n");\r\nreturn -EPERM;\r\n}\r\nif (!base_lport || !base_lport->tpg_1 ||\r\n!atomic_read(&base_lport->tpg_1->lport_tpg_enabled)) {\r\npr_err("qla2xxx base_lport or tpg_1 not available\n");\r\nreturn -EPERM;\r\n}\r\nmemset(&vport_id, 0, sizeof(vport_id));\r\nvport_id.port_name = npiv_wwpn;\r\nvport_id.node_name = npiv_wwnn;\r\nvport_id.roles = FC_PORT_ROLE_FCP_INITIATOR;\r\nvport_id.vport_type = FC_PORTTYPE_NPIV;\r\nvport_id.disable = false;\r\nvport = fc_vport_create(sh, 0, &vport_id);\r\nif (!vport) {\r\npr_err("fc_vport_create failed for qla2xxx_npiv\n");\r\nreturn -ENODEV;\r\n}\r\nnpiv_vha = (struct scsi_qla_host *)vport->dd_data;\r\nnpiv_vha->vha_tgt.target_lport_ptr = target_lport_ptr;\r\nlport->qla_vha = npiv_vha;\r\nscsi_host_get(npiv_vha->host);\r\nreturn 0;\r\n}\r\nstatic struct se_wwn *tcm_qla2xxx_npiv_make_lport(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct tcm_qla2xxx_lport *lport;\r\nu64 phys_wwpn, npiv_wwpn, npiv_wwnn;\r\nchar *p, tmp[128];\r\nint ret;\r\nsnprintf(tmp, 128, "%s", name);\r\np = strchr(tmp, '@');\r\nif (!p) {\r\npr_err("Unable to locate NPIV '@' seperator\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n*p++ = '\0';\r\nif (tcm_qla2xxx_parse_wwn(tmp, &phys_wwpn, 1) < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (tcm_qla2xxx_npiv_parse_wwn(p, strlen(p)+1,\r\n&npiv_wwpn, &npiv_wwnn) < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nlport = kzalloc(sizeof(struct tcm_qla2xxx_lport), GFP_KERNEL);\r\nif (!lport) {\r\npr_err("Unable to allocate struct tcm_qla2xxx_lport for NPIV\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nlport->lport_npiv_wwpn = npiv_wwpn;\r\nlport->lport_npiv_wwnn = npiv_wwnn;\r\nsprintf(lport->lport_naa_name, "naa.%016llx", (unsigned long long) npiv_wwpn);\r\nret = tcm_qla2xxx_init_lport(lport);\r\nif (ret != 0)\r\ngoto out;\r\nret = qlt_lport_register(lport, phys_wwpn, npiv_wwpn, npiv_wwnn,\r\ntcm_qla2xxx_lport_register_npiv_cb);\r\nif (ret != 0)\r\ngoto out_lport;\r\nreturn &lport->lport_wwn;\r\nout_lport:\r\nvfree(lport->lport_loopid_map);\r\nbtree_destroy32(&lport->lport_fcport_map);\r\nout:\r\nkfree(lport);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void tcm_qla2xxx_npiv_drop_lport(struct se_wwn *wwn)\r\n{\r\nstruct tcm_qla2xxx_lport *lport = container_of(wwn,\r\nstruct tcm_qla2xxx_lport, lport_wwn);\r\nstruct scsi_qla_host *npiv_vha = lport->qla_vha;\r\nstruct qla_hw_data *ha = npiv_vha->hw;\r\nscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\r\nscsi_host_put(npiv_vha->host);\r\nfc_vport_terminate(npiv_vha->fc_vport);\r\nscsi_host_put(base_vha->host);\r\nkfree(lport);\r\n}\r\nstatic ssize_t tcm_qla2xxx_wwn_version_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page,\r\n"TCM QLOGIC QLA2XXX NPIV capable fabric module %s on %s/%s on "\r\nUTS_RELEASE"\n", TCM_QLA2XXX_VERSION, utsname()->sysname,\r\nutsname()->machine);\r\n}\r\nstatic int tcm_qla2xxx_register_configfs(void)\r\n{\r\nint ret;\r\npr_debug("TCM QLOGIC QLA2XXX fabric module %s on %s/%s on "\r\nUTS_RELEASE"\n", TCM_QLA2XXX_VERSION, utsname()->sysname,\r\nutsname()->machine);\r\nret = target_register_template(&tcm_qla2xxx_ops);\r\nif (ret)\r\nreturn ret;\r\nret = target_register_template(&tcm_qla2xxx_npiv_ops);\r\nif (ret)\r\ngoto out_fabric;\r\ntcm_qla2xxx_free_wq = alloc_workqueue("tcm_qla2xxx_free",\r\nWQ_MEM_RECLAIM, 0);\r\nif (!tcm_qla2xxx_free_wq) {\r\nret = -ENOMEM;\r\ngoto out_fabric_npiv;\r\n}\r\ntcm_qla2xxx_cmd_wq = alloc_workqueue("tcm_qla2xxx_cmd", 0, 0);\r\nif (!tcm_qla2xxx_cmd_wq) {\r\nret = -ENOMEM;\r\ngoto out_free_wq;\r\n}\r\nreturn 0;\r\nout_free_wq:\r\ndestroy_workqueue(tcm_qla2xxx_free_wq);\r\nout_fabric_npiv:\r\ntarget_unregister_template(&tcm_qla2xxx_npiv_ops);\r\nout_fabric:\r\ntarget_unregister_template(&tcm_qla2xxx_ops);\r\nreturn ret;\r\n}\r\nstatic void tcm_qla2xxx_deregister_configfs(void)\r\n{\r\ndestroy_workqueue(tcm_qla2xxx_cmd_wq);\r\ndestroy_workqueue(tcm_qla2xxx_free_wq);\r\ntarget_unregister_template(&tcm_qla2xxx_ops);\r\ntarget_unregister_template(&tcm_qla2xxx_npiv_ops);\r\n}\r\nstatic int __init tcm_qla2xxx_init(void)\r\n{\r\nint ret;\r\nret = tcm_qla2xxx_register_configfs();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void __exit tcm_qla2xxx_exit(void)\r\n{\r\ntcm_qla2xxx_deregister_configfs();\r\n}
