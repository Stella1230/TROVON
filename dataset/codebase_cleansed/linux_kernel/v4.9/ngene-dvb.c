static ssize_t ts_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct ngene_channel *chan = dvbdev->priv;\r\nstruct ngene *dev = chan->dev;\r\nif (wait_event_interruptible(dev->tsout_rbuf.queue,\r\ndvb_ringbuffer_free\r\n(&dev->tsout_rbuf) >= count) < 0)\r\nreturn 0;\r\ndvb_ringbuffer_write_user(&dev->tsout_rbuf, buf, count);\r\nreturn count;\r\n}\r\nstatic ssize_t ts_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct ngene_channel *chan = dvbdev->priv;\r\nstruct ngene *dev = chan->dev;\r\nint left, avail;\r\nleft = count;\r\nwhile (left) {\r\nif (wait_event_interruptible(\r\ndev->tsin_rbuf.queue,\r\ndvb_ringbuffer_avail(&dev->tsin_rbuf) > 0) < 0)\r\nreturn -EAGAIN;\r\navail = dvb_ringbuffer_avail(&dev->tsin_rbuf);\r\nif (avail > left)\r\navail = left;\r\ndvb_ringbuffer_read_user(&dev->tsin_rbuf, buf, avail);\r\nleft -= avail;\r\nbuf += avail;\r\n}\r\nreturn count;\r\n}\r\nstatic void swap_buffer(u32 *p, u32 len)\r\n{\r\nwhile (len) {\r\n*p = swab32(*p);\r\np++;\r\nlen -= 4;\r\n}\r\n}\r\nvoid *tsin_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)\r\n{\r\nstruct ngene_channel *chan = priv;\r\nstruct ngene *dev = chan->dev;\r\nif (flags & DF_SWAP32)\r\nswap_buffer(buf, len);\r\nif (dev->ci.en && chan->number == 2) {\r\nwhile (len >= 188) {\r\nif (memcmp(buf, fill_ts, sizeof fill_ts) != 0) {\r\nif (dvb_ringbuffer_free(&dev->tsin_rbuf) >= 188) {\r\ndvb_ringbuffer_write(&dev->tsin_rbuf, buf, 188);\r\nwake_up(&dev->tsin_rbuf.queue);\r\n#ifdef DEBUG_CI_XFER\r\nok++;\r\n#endif\r\n}\r\n#ifdef DEBUG_CI_XFER\r\nelse\r\noverflow++;\r\n#endif\r\n}\r\n#ifdef DEBUG_CI_XFER\r\nelse\r\nstripped++;\r\nif (ok % 100 == 0 && overflow)\r\nprintk(KERN_WARNING "%s: ok %u overflow %u dropped %u\n", __func__, ok, overflow, stripped);\r\n#endif\r\nbuf += 188;\r\nlen -= 188;\r\n}\r\nreturn NULL;\r\n}\r\nif (chan->users > 0)\r\ndvb_dmx_swfilter(&chan->demux, buf, len);\r\nreturn NULL;\r\n}\r\nvoid *tsout_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)\r\n{\r\nstruct ngene_channel *chan = priv;\r\nstruct ngene *dev = chan->dev;\r\nu32 alen;\r\nalen = dvb_ringbuffer_avail(&dev->tsout_rbuf);\r\nalen -= alen % 188;\r\nif (alen < len)\r\nFillTSBuffer(buf + alen, len - alen, flags);\r\nelse\r\nalen = len;\r\ndvb_ringbuffer_read(&dev->tsout_rbuf, buf, alen);\r\nif (flags & DF_SWAP32)\r\nswap_buffer((u32 *)buf, alen);\r\nwake_up_interruptible(&dev->tsout_rbuf.queue);\r\nreturn buf;\r\n}\r\nint ngene_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct ngene_channel *chan = dvbdmx->priv;\r\nif (chan->users == 0) {\r\nif (!chan->dev->cmd_timeout_workaround || !chan->running)\r\nset_transfer(chan, 1);\r\n}\r\nreturn ++chan->users;\r\n}\r\nint ngene_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct ngene_channel *chan = dvbdmx->priv;\r\nif (--chan->users)\r\nreturn chan->users;\r\nif (!chan->dev->cmd_timeout_workaround)\r\nset_transfer(chan, 0);\r\nreturn 0;\r\n}\r\nint my_dvb_dmx_ts_card_init(struct dvb_demux *dvbdemux, char *id,\r\nint (*start_feed)(struct dvb_demux_feed *),\r\nint (*stop_feed)(struct dvb_demux_feed *),\r\nvoid *priv)\r\n{\r\ndvbdemux->priv = priv;\r\ndvbdemux->filternum = 256;\r\ndvbdemux->feednum = 256;\r\ndvbdemux->start_feed = start_feed;\r\ndvbdemux->stop_feed = stop_feed;\r\ndvbdemux->write_to_decoder = NULL;\r\ndvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING);\r\nreturn dvb_dmx_init(dvbdemux);\r\n}\r\nint my_dvb_dmxdev_ts_card_init(struct dmxdev *dmxdev,\r\nstruct dvb_demux *dvbdemux,\r\nstruct dmx_frontend *hw_frontend,\r\nstruct dmx_frontend *mem_frontend,\r\nstruct dvb_adapter *dvb_adapter)\r\n{\r\nint ret;\r\ndmxdev->filternum = 256;\r\ndmxdev->demux = &dvbdemux->dmx;\r\ndmxdev->capabilities = 0;\r\nret = dvb_dmxdev_init(dmxdev, dvb_adapter);\r\nif (ret < 0)\r\nreturn ret;\r\nhw_frontend->source = DMX_FRONTEND_0;\r\ndvbdemux->dmx.add_frontend(&dvbdemux->dmx, hw_frontend);\r\nmem_frontend->source = DMX_MEMORY_FE;\r\ndvbdemux->dmx.add_frontend(&dvbdemux->dmx, mem_frontend);\r\nreturn dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, hw_frontend);\r\n}
