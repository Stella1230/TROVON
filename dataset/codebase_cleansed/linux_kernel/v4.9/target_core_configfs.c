static inline struct se_hba *\r\nitem_to_hba(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct se_hba, hba_group);\r\n}\r\nstatic ssize_t target_core_item_version_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "Target Engine Core ConfigFS Infrastructure %s"\r\n" on %s/%s on "UTS_RELEASE"\n", TARGET_CORE_VERSION,\r\nutsname()->sysname, utsname()->machine);\r\n}\r\nstatic ssize_t target_core_item_dbroot_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%s\n", db_root);\r\n}\r\nstatic ssize_t target_core_item_dbroot_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nssize_t read_bytes;\r\nstruct file *fp;\r\nmutex_lock(&g_tf_lock);\r\nif (!list_empty(&g_tf_list)) {\r\nmutex_unlock(&g_tf_lock);\r\npr_err("db_root: cannot be changed: target drivers registered");\r\nreturn -EINVAL;\r\n}\r\nif (count > (DB_ROOT_LEN - 1)) {\r\nmutex_unlock(&g_tf_lock);\r\npr_err("db_root: count %d exceeds DB_ROOT_LEN-1: %u\n",\r\n(int)count, DB_ROOT_LEN - 1);\r\nreturn -EINVAL;\r\n}\r\nread_bytes = snprintf(db_root_stage, DB_ROOT_LEN, "%s", page);\r\nif (!read_bytes) {\r\nmutex_unlock(&g_tf_lock);\r\nreturn -EINVAL;\r\n}\r\nif (db_root_stage[read_bytes - 1] == '\n')\r\ndb_root_stage[read_bytes - 1] = '\0';\r\nfp = filp_open(db_root_stage, O_RDONLY, 0);\r\nif (IS_ERR(fp)) {\r\nmutex_unlock(&g_tf_lock);\r\npr_err("db_root: cannot open: %s\n", db_root_stage);\r\nreturn -EINVAL;\r\n}\r\nif (!S_ISDIR(fp->f_inode->i_mode)) {\r\nfilp_close(fp, 0);\r\nmutex_unlock(&g_tf_lock);\r\npr_err("db_root: not a directory: %s\n", db_root_stage);\r\nreturn -EINVAL;\r\n}\r\nfilp_close(fp, 0);\r\nstrncpy(db_root, db_root_stage, read_bytes);\r\nmutex_unlock(&g_tf_lock);\r\nreturn read_bytes;\r\n}\r\nstatic struct target_fabric_configfs *target_core_get_fabric(\r\nconst char *name)\r\n{\r\nstruct target_fabric_configfs *tf;\r\nif (!name)\r\nreturn NULL;\r\nmutex_lock(&g_tf_lock);\r\nlist_for_each_entry(tf, &g_tf_list, tf_list) {\r\nif (!strcmp(tf->tf_ops->name, name)) {\r\natomic_inc(&tf->tf_access_cnt);\r\nmutex_unlock(&g_tf_lock);\r\nreturn tf;\r\n}\r\n}\r\nmutex_unlock(&g_tf_lock);\r\nreturn NULL;\r\n}\r\nstatic struct config_group *target_core_register_fabric(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct target_fabric_configfs *tf;\r\nint ret;\r\npr_debug("Target_Core_ConfigFS: REGISTER -> group: %p name:"\r\n" %s\n", group, name);\r\ntf = target_core_get_fabric(name);\r\nif (!tf) {\r\npr_debug("target_core_register_fabric() trying autoload for %s\n",\r\nname);\r\nif (!strncmp(name, "iscsi", 5)) {\r\nret = request_module("iscsi_target_mod");\r\nif (ret < 0) {\r\npr_debug("request_module() failed for"\r\n" iscsi_target_mod.ko: %d\n", ret);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n} else if (!strncmp(name, "loopback", 8)) {\r\nret = request_module("tcm_loop");\r\nif (ret < 0) {\r\npr_debug("request_module() failed for"\r\n" tcm_loop.ko: %d\n", ret);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\ntf = target_core_get_fabric(name);\r\n}\r\nif (!tf) {\r\npr_debug("target_core_get_fabric() failed for %s\n",\r\nname);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npr_debug("Target_Core_ConfigFS: REGISTER -> Located fabric:"\r\n" %s\n", tf->tf_ops->name);\r\npr_debug("Target_Core_ConfigFS: REGISTER tfc_wwn_cit -> %p\n",\r\n&tf->tf_wwn_cit);\r\nconfig_group_init_type_name(&tf->tf_group, name, &tf->tf_wwn_cit);\r\nconfig_group_init_type_name(&tf->tf_disc_group, "discovery_auth",\r\n&tf->tf_discovery_cit);\r\nconfigfs_add_default_group(&tf->tf_disc_group, &tf->tf_group);\r\npr_debug("Target_Core_ConfigFS: REGISTER -> Allocated Fabric:"\r\n" %s\n", tf->tf_group.cg_item.ci_name);\r\nreturn &tf->tf_group;\r\n}\r\nstatic void target_core_deregister_fabric(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct target_fabric_configfs *tf = container_of(\r\nto_config_group(item), struct target_fabric_configfs, tf_group);\r\npr_debug("Target_Core_ConfigFS: DEREGISTER -> Looking up %s in"\r\n" tf list\n", config_item_name(item));\r\npr_debug("Target_Core_ConfigFS: DEREGISTER -> located fabric:"\r\n" %s\n", tf->tf_ops->name);\r\natomic_dec(&tf->tf_access_cnt);\r\npr_debug("Target_Core_ConfigFS: DEREGISTER -> Releasing ci"\r\n" %s\n", config_item_name(item));\r\nconfigfs_remove_default_groups(&tf->tf_group);\r\nconfig_item_put(item);\r\n}\r\nint target_depend_item(struct config_item *item)\r\n{\r\nreturn configfs_depend_item(&target_core_fabrics, item);\r\n}\r\nvoid target_undepend_item(struct config_item *item)\r\n{\r\nreturn configfs_undepend_item(item);\r\n}\r\nstatic int target_fabric_tf_ops_check(const struct target_core_fabric_ops *tfo)\r\n{\r\nif (!tfo->name) {\r\npr_err("Missing tfo->name\n");\r\nreturn -EINVAL;\r\n}\r\nif (strlen(tfo->name) >= TARGET_FABRIC_NAME_SIZE) {\r\npr_err("Passed name: %s exceeds TARGET_FABRIC"\r\n"_NAME_SIZE\n", tfo->name);\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->get_fabric_name) {\r\npr_err("Missing tfo->get_fabric_name()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->tpg_get_wwn) {\r\npr_err("Missing tfo->tpg_get_wwn()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->tpg_get_tag) {\r\npr_err("Missing tfo->tpg_get_tag()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->tpg_check_demo_mode) {\r\npr_err("Missing tfo->tpg_check_demo_mode()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->tpg_check_demo_mode_cache) {\r\npr_err("Missing tfo->tpg_check_demo_mode_cache()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->tpg_check_demo_mode_write_protect) {\r\npr_err("Missing tfo->tpg_check_demo_mode_write_protect()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->tpg_check_prod_mode_write_protect) {\r\npr_err("Missing tfo->tpg_check_prod_mode_write_protect()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->tpg_get_inst_index) {\r\npr_err("Missing tfo->tpg_get_inst_index()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->release_cmd) {\r\npr_err("Missing tfo->release_cmd()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->sess_get_index) {\r\npr_err("Missing tfo->sess_get_index()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->write_pending) {\r\npr_err("Missing tfo->write_pending()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->write_pending_status) {\r\npr_err("Missing tfo->write_pending_status()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->set_default_node_attributes) {\r\npr_err("Missing tfo->set_default_node_attributes()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->get_cmd_state) {\r\npr_err("Missing tfo->get_cmd_state()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->queue_data_in) {\r\npr_err("Missing tfo->queue_data_in()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->queue_status) {\r\npr_err("Missing tfo->queue_status()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->queue_tm_rsp) {\r\npr_err("Missing tfo->queue_tm_rsp()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->aborted_task) {\r\npr_err("Missing tfo->aborted_task()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->fabric_make_wwn) {\r\npr_err("Missing tfo->fabric_make_wwn()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->fabric_drop_wwn) {\r\npr_err("Missing tfo->fabric_drop_wwn()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->fabric_make_tpg) {\r\npr_err("Missing tfo->fabric_make_tpg()\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tfo->fabric_drop_tpg) {\r\npr_err("Missing tfo->fabric_drop_tpg()\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint target_register_template(const struct target_core_fabric_ops *fo)\r\n{\r\nstruct target_fabric_configfs *tf;\r\nint ret;\r\nret = target_fabric_tf_ops_check(fo);\r\nif (ret)\r\nreturn ret;\r\ntf = kzalloc(sizeof(struct target_fabric_configfs), GFP_KERNEL);\r\nif (!tf) {\r\npr_err("%s: could not allocate memory!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&tf->tf_list);\r\natomic_set(&tf->tf_access_cnt, 0);\r\ntf->tf_ops = fo;\r\ntarget_fabric_setup_cits(tf);\r\nmutex_lock(&g_tf_lock);\r\nlist_add_tail(&tf->tf_list, &g_tf_list);\r\nmutex_unlock(&g_tf_lock);\r\nreturn 0;\r\n}\r\nvoid target_unregister_template(const struct target_core_fabric_ops *fo)\r\n{\r\nstruct target_fabric_configfs *t;\r\nmutex_lock(&g_tf_lock);\r\nlist_for_each_entry(t, &g_tf_list, tf_list) {\r\nif (!strcmp(t->tf_ops->name, fo->name)) {\r\nBUG_ON(atomic_read(&t->tf_access_cnt));\r\nlist_del(&t->tf_list);\r\nmutex_unlock(&g_tf_lock);\r\nrcu_barrier();\r\nkfree(t);\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&g_tf_lock);\r\n}\r\nstatic inline struct se_dev_attrib *to_attrib(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct se_dev_attrib,\r\nda_group);\r\n}\r\nstatic void dev_set_t10_wwn_model_alias(struct se_device *dev)\r\n{\r\nconst char *configname;\r\nconfigname = config_item_name(&dev->dev_group.cg_item);\r\nif (strlen(configname) >= 16) {\r\npr_warn("dev[%p]: Backstore name '%s' is too long for "\r\n"INQUIRY_MODEL, truncating to 16 bytes\n", dev,\r\nconfigname);\r\n}\r\nsnprintf(&dev->t10_wwn.model[0], 16, "%s", configname);\r\n}\r\nstatic ssize_t emulate_model_alias_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nstruct se_device *dev = da->da_dev;\r\nbool flag;\r\nint ret;\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change model alias"\r\n" while export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (flag) {\r\ndev_set_t10_wwn_model_alias(dev);\r\n} else {\r\nstrncpy(&dev->t10_wwn.model[0],\r\ndev->transport->inquiry_prod, 16);\r\n}\r\nda->emulate_model_alias = flag;\r\nreturn count;\r\n}\r\nstatic ssize_t emulate_write_cache_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nbool flag;\r\nint ret;\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (flag && da->da_dev->transport->get_write_cache) {\r\npr_err("emulate_write_cache not supported for this device\n");\r\nreturn -EINVAL;\r\n}\r\nda->emulate_write_cache = flag;\r\npr_debug("dev[%p]: SE Device WRITE_CACHE_EMULATION flag: %d\n",\r\nda->da_dev, flag);\r\nreturn count;\r\n}\r\nstatic ssize_t emulate_ua_intlck_ctrl_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nu32 val;\r\nint ret;\r\nret = kstrtou32(page, 0, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val != 0 && val != 1 && val != 2) {\r\npr_err("Illegal value %d\n", val);\r\nreturn -EINVAL;\r\n}\r\nif (da->da_dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device"\r\n" UA_INTRLCK_CTRL while export_count is %d\n",\r\nda->da_dev, da->da_dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nda->emulate_ua_intlck_ctrl = val;\r\npr_debug("dev[%p]: SE Device UA_INTRLCK_CTRL flag: %d\n",\r\nda->da_dev, val);\r\nreturn count;\r\n}\r\nstatic ssize_t emulate_tas_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nbool flag;\r\nint ret;\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (da->da_dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device TAS while"\r\n" export_count is %d\n",\r\nda->da_dev, da->da_dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nda->emulate_tas = flag;\r\npr_debug("dev[%p]: SE Device TASK_ABORTED status bit: %s\n",\r\nda->da_dev, flag ? "Enabled" : "Disabled");\r\nreturn count;\r\n}\r\nstatic ssize_t emulate_tpu_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nbool flag;\r\nint ret;\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (flag && !da->max_unmap_block_desc_count) {\r\npr_err("Generic Block Discard not supported\n");\r\nreturn -ENOSYS;\r\n}\r\nda->emulate_tpu = flag;\r\npr_debug("dev[%p]: SE Device Thin Provisioning UNMAP bit: %d\n",\r\nda->da_dev, flag);\r\nreturn count;\r\n}\r\nstatic ssize_t emulate_tpws_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nbool flag;\r\nint ret;\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (flag && !da->max_unmap_block_desc_count) {\r\npr_err("Generic Block Discard not supported\n");\r\nreturn -ENOSYS;\r\n}\r\nda->emulate_tpws = flag;\r\npr_debug("dev[%p]: SE Device Thin Provisioning WRITE_SAME: %d\n",\r\nda->da_dev, flag);\r\nreturn count;\r\n}\r\nstatic ssize_t pi_prot_type_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nint old_prot = da->pi_prot_type, ret;\r\nstruct se_device *dev = da->da_dev;\r\nu32 flag;\r\nret = kstrtou32(page, 0, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (flag != 0 && flag != 1 && flag != 2 && flag != 3) {\r\npr_err("Illegal value %d for pi_prot_type\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag == 2) {\r\npr_err("DIF TYPE2 protection currently not supported\n");\r\nreturn -ENOSYS;\r\n}\r\nif (da->hw_pi_prot_type) {\r\npr_warn("DIF protection enabled on underlying hardware,"\r\n" ignoring\n");\r\nreturn count;\r\n}\r\nif (!dev->transport->init_prot || !dev->transport->free_prot) {\r\nif (flag == 0)\r\nreturn count;\r\npr_err("DIF protection not supported by backend: %s\n",\r\ndev->transport->name);\r\nreturn -ENOSYS;\r\n}\r\nif (!(dev->dev_flags & DF_CONFIGURED)) {\r\npr_err("DIF protection requires device to be configured\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device PROT type while"\r\n" export_count is %d\n", dev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nda->pi_prot_type = flag;\r\nif (flag && !old_prot) {\r\nret = dev->transport->init_prot(dev);\r\nif (ret) {\r\nda->pi_prot_type = old_prot;\r\nreturn ret;\r\n}\r\n} else if (!flag && old_prot) {\r\ndev->transport->free_prot(dev);\r\n}\r\npr_debug("dev[%p]: SE Device Protection Type: %d\n", dev, flag);\r\nreturn count;\r\n}\r\nstatic ssize_t pi_prot_format_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nstruct se_device *dev = da->da_dev;\r\nbool flag;\r\nint ret;\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!flag)\r\nreturn count;\r\nif (!dev->transport->format_prot) {\r\npr_err("DIF protection format not supported by backend %s\n",\r\ndev->transport->name);\r\nreturn -ENOSYS;\r\n}\r\nif (!(dev->dev_flags & DF_CONFIGURED)) {\r\npr_err("DIF protection format requires device to be configured\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to format SE Device PROT type while"\r\n" export_count is %d\n", dev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nret = dev->transport->format_prot(dev);\r\nif (ret)\r\nreturn ret;\r\npr_debug("dev[%p]: SE Device Protection Format complete\n", dev);\r\nreturn count;\r\n}\r\nstatic ssize_t force_pr_aptpl_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nbool flag;\r\nint ret;\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (da->da_dev->export_count) {\r\npr_err("dev[%p]: Unable to set force_pr_aptpl while"\r\n" export_count is %d\n",\r\nda->da_dev, da->da_dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nda->force_pr_aptpl = flag;\r\npr_debug("dev[%p]: SE Device force_pr_aptpl: %d\n", da->da_dev, flag);\r\nreturn count;\r\n}\r\nstatic ssize_t emulate_rest_reord_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nbool flag;\r\nint ret;\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (flag != 0) {\r\nprintk(KERN_ERR "dev[%p]: SE Device emulation of restricted"\r\n" reordering not implemented\n", da->da_dev);\r\nreturn -ENOSYS;\r\n}\r\nda->emulate_rest_reord = flag;\r\npr_debug("dev[%p]: SE Device emulate_rest_reord: %d\n",\r\nda->da_dev, flag);\r\nreturn count;\r\n}\r\nstatic ssize_t unmap_zeroes_data_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nbool flag;\r\nint ret;\r\nret = strtobool(page, &flag);\r\nif (ret < 0)\r\nreturn ret;\r\nif (da->da_dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device"\r\n" unmap_zeroes_data while export_count is %d\n",\r\nda->da_dev, da->da_dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif (flag && !da->max_unmap_block_desc_count) {\r\npr_err("dev[%p]: Thin Provisioning LBPRZ will not be set"\r\n" because max_unmap_block_desc_count is zero\n",\r\nda->da_dev);\r\nreturn -ENOSYS;\r\n}\r\nda->unmap_zeroes_data = flag;\r\npr_debug("dev[%p]: SE Device Thin Provisioning LBPRZ bit: %d\n",\r\nda->da_dev, flag);\r\nreturn count;\r\n}\r\nstatic ssize_t queue_depth_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nstruct se_device *dev = da->da_dev;\r\nu32 val;\r\nint ret;\r\nret = kstrtou32(page, 0, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device TCQ while"\r\n" export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif (!val) {\r\npr_err("dev[%p]: Illegal ZERO value for queue_depth\n", dev);\r\nreturn -EINVAL;\r\n}\r\nif (val > dev->dev_attrib.queue_depth) {\r\nif (val > dev->dev_attrib.hw_queue_depth) {\r\npr_err("dev[%p]: Passed queue_depth:"\r\n" %u exceeds TCM/SE_Device MAX"\r\n" TCQ: %u\n", dev, val,\r\ndev->dev_attrib.hw_queue_depth);\r\nreturn -EINVAL;\r\n}\r\n}\r\nda->queue_depth = dev->queue_depth = val;\r\npr_debug("dev[%p]: SE Device TCQ Depth changed to: %u\n", dev, val);\r\nreturn count;\r\n}\r\nstatic ssize_t optimal_sectors_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nu32 val;\r\nint ret;\r\nret = kstrtou32(page, 0, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (da->da_dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device"\r\n" optimal_sectors while export_count is %d\n",\r\nda->da_dev, da->da_dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif (val > da->hw_max_sectors) {\r\npr_err("dev[%p]: Passed optimal_sectors %u cannot be"\r\n" greater than hw_max_sectors: %u\n",\r\nda->da_dev, val, da->hw_max_sectors);\r\nreturn -EINVAL;\r\n}\r\nda->optimal_sectors = val;\r\npr_debug("dev[%p]: SE Device optimal_sectors changed to %u\n",\r\nda->da_dev, val);\r\nreturn count;\r\n}\r\nstatic ssize_t block_size_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_dev_attrib *da = to_attrib(item);\r\nu32 val;\r\nint ret;\r\nret = kstrtou32(page, 0, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (da->da_dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device block_size"\r\n" while export_count is %d\n",\r\nda->da_dev, da->da_dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif (val != 512 && val != 1024 && val != 2048 && val != 4096) {\r\npr_err("dev[%p]: Illegal value for block_device: %u"\r\n" for SE device, must be 512, 1024, 2048 or 4096\n",\r\nda->da_dev, val);\r\nreturn -EINVAL;\r\n}\r\nda->block_size = val;\r\nif (da->max_bytes_per_io)\r\nda->hw_max_sectors = da->max_bytes_per_io / val;\r\npr_debug("dev[%p]: SE Device block_size changed to %u\n",\r\nda->da_dev, val);\r\nreturn count;\r\n}\r\nstatic struct t10_wwn *to_t10_wwn(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct t10_wwn, t10_wwn_group);\r\n}\r\nstatic ssize_t target_wwn_vpd_unit_serial_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "T10 VPD Unit Serial Number: %s\n",\r\n&to_t10_wwn(item)->unit_serial[0]);\r\n}\r\nstatic ssize_t target_wwn_vpd_unit_serial_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct t10_wwn *t10_wwn = to_t10_wwn(item);\r\nstruct se_device *dev = t10_wwn->t10_dev;\r\nunsigned char buf[INQUIRY_VPD_SERIAL_LEN];\r\nif (dev->dev_flags & DF_FIRMWARE_VPD_UNIT_SERIAL) {\r\npr_err("Underlying SCSI device firmware provided VPD"\r\n" Unit Serial, ignoring request\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (strlen(page) >= INQUIRY_VPD_SERIAL_LEN) {\r\npr_err("Emulated VPD Unit Serial exceeds"\r\n" INQUIRY_VPD_SERIAL_LEN: %d\n", INQUIRY_VPD_SERIAL_LEN);\r\nreturn -EOVERFLOW;\r\n}\r\nif (dev->export_count) {\r\npr_err("Unable to set VPD Unit Serial while"\r\n" active %d $FABRIC_MOD exports exist\n",\r\ndev->export_count);\r\nreturn -EINVAL;\r\n}\r\nmemset(buf, 0, INQUIRY_VPD_SERIAL_LEN);\r\nsnprintf(buf, INQUIRY_VPD_SERIAL_LEN, "%s", page);\r\nsnprintf(dev->t10_wwn.unit_serial, INQUIRY_VPD_SERIAL_LEN,\r\n"%s", strstrip(buf));\r\ndev->dev_flags |= DF_EMULATED_VPD_UNIT_SERIAL;\r\npr_debug("Target_Core_ConfigFS: Set emulated VPD Unit Serial:"\r\n" %s\n", dev->t10_wwn.unit_serial);\r\nreturn count;\r\n}\r\nstatic ssize_t target_wwn_vpd_protocol_identifier_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct t10_wwn *t10_wwn = to_t10_wwn(item);\r\nstruct t10_vpd *vpd;\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nssize_t len = 0;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nspin_lock(&t10_wwn->t10_vpd_lock);\r\nlist_for_each_entry(vpd, &t10_wwn->t10_vpd_list, vpd_list) {\r\nif (!vpd->protocol_identifier_set)\r\ncontinue;\r\ntransport_dump_vpd_proto_id(vpd, buf, VPD_TMP_BUF_SIZE);\r\nif (len + strlen(buf) >= PAGE_SIZE)\r\nbreak;\r\nlen += sprintf(page+len, "%s", buf);\r\n}\r\nspin_unlock(&t10_wwn->t10_vpd_lock);\r\nreturn len;\r\n}\r\nstatic struct se_device *pr_to_dev(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct se_device,\r\ndev_pr_group);\r\n}\r\nstatic ssize_t target_core_dev_pr_show_spc3_res(struct se_device *dev,\r\nchar *page)\r\n{\r\nstruct se_node_acl *se_nacl;\r\nstruct t10_pr_registration *pr_reg;\r\nchar i_buf[PR_REG_ISID_ID_LEN];\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\npr_reg = dev->dev_pr_res_holder;\r\nif (!pr_reg)\r\nreturn sprintf(page, "No SPC-3 Reservation holder\n");\r\nse_nacl = pr_reg->pr_reg_nacl;\r\ncore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\nreturn sprintf(page, "SPC-3 Reservation: %s Initiator: %s%s\n",\r\nse_nacl->se_tpg->se_tpg_tfo->get_fabric_name(),\r\nse_nacl->initiatorname, i_buf);\r\n}\r\nstatic ssize_t target_core_dev_pr_show_spc2_res(struct se_device *dev,\r\nchar *page)\r\n{\r\nstruct se_node_acl *se_nacl;\r\nssize_t len;\r\nse_nacl = dev->dev_reserved_node_acl;\r\nif (se_nacl) {\r\nlen = sprintf(page,\r\n"SPC-2 Reservation: %s Initiator: %s\n",\r\nse_nacl->se_tpg->se_tpg_tfo->get_fabric_name(),\r\nse_nacl->initiatorname);\r\n} else {\r\nlen = sprintf(page, "No SPC-2 Reservation holder\n");\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t target_pr_res_holder_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nint ret;\r\nif (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\r\nreturn sprintf(page, "Passthrough\n");\r\nspin_lock(&dev->dev_reservation_lock);\r\nif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\r\nret = target_core_dev_pr_show_spc2_res(dev, page);\r\nelse\r\nret = target_core_dev_pr_show_spc3_res(dev, page);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t target_pr_res_pr_all_tgt_pts_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nssize_t len = 0;\r\nspin_lock(&dev->dev_reservation_lock);\r\nif (!dev->dev_pr_res_holder) {\r\nlen = sprintf(page, "No SPC-3 Reservation holder\n");\r\n} else if (dev->dev_pr_res_holder->pr_reg_all_tg_pt) {\r\nlen = sprintf(page, "SPC-3 Reservation: All Target"\r\n" Ports registration\n");\r\n} else {\r\nlen = sprintf(page, "SPC-3 Reservation: Single"\r\n" Target Port registration\n");\r\n}\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t target_pr_res_pr_generation_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "0x%08x\n", pr_to_dev(item)->t10_pr.pr_generation);\r\n}\r\nstatic ssize_t target_pr_res_pr_holder_tg_port_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nstruct se_node_acl *se_nacl;\r\nstruct se_portal_group *se_tpg;\r\nstruct t10_pr_registration *pr_reg;\r\nconst struct target_core_fabric_ops *tfo;\r\nssize_t len = 0;\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_reg = dev->dev_pr_res_holder;\r\nif (!pr_reg) {\r\nlen = sprintf(page, "No SPC-3 Reservation holder\n");\r\ngoto out_unlock;\r\n}\r\nse_nacl = pr_reg->pr_reg_nacl;\r\nse_tpg = se_nacl->se_tpg;\r\ntfo = se_tpg->se_tpg_tfo;\r\nlen += sprintf(page+len, "SPC-3 Reservation: %s"\r\n" Target Node Endpoint: %s\n", tfo->get_fabric_name(),\r\ntfo->tpg_get_wwn(se_tpg));\r\nlen += sprintf(page+len, "SPC-3 Reservation: Relative Port"\r\n" Identifier Tag: %hu %s Portal Group Tag: %hu"\r\n" %s Logical Unit: %llu\n", pr_reg->tg_pt_sep_rtpi,\r\ntfo->get_fabric_name(), tfo->tpg_get_tag(se_tpg),\r\ntfo->get_fabric_name(), pr_reg->pr_aptpl_target_lun);\r\nout_unlock:\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t target_pr_res_pr_registered_i_pts_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nconst struct target_core_fabric_ops *tfo;\r\nstruct t10_pr_registration *pr_reg;\r\nunsigned char buf[384];\r\nchar i_buf[PR_REG_ISID_ID_LEN];\r\nssize_t len = 0;\r\nint reg_count = 0;\r\nlen += sprintf(page+len, "SPC-3 PR Registrations:\n");\r\nspin_lock(&dev->t10_pr.registration_lock);\r\nlist_for_each_entry(pr_reg, &dev->t10_pr.registration_list,\r\npr_reg_list) {\r\nmemset(buf, 0, 384);\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\ntfo = pr_reg->pr_reg_nacl->se_tpg->se_tpg_tfo;\r\ncore_pr_dump_initiator_port(pr_reg, i_buf,\r\nPR_REG_ISID_ID_LEN);\r\nsprintf(buf, "%s Node: %s%s Key: 0x%016Lx PRgen: 0x%08x\n",\r\ntfo->get_fabric_name(),\r\npr_reg->pr_reg_nacl->initiatorname, i_buf, pr_reg->pr_res_key,\r\npr_reg->pr_res_generation);\r\nif (len + strlen(buf) >= PAGE_SIZE)\r\nbreak;\r\nlen += sprintf(page+len, "%s", buf);\r\nreg_count++;\r\n}\r\nspin_unlock(&dev->t10_pr.registration_lock);\r\nif (!reg_count)\r\nlen += sprintf(page+len, "None\n");\r\nreturn len;\r\n}\r\nstatic ssize_t target_pr_res_pr_type_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nstruct t10_pr_registration *pr_reg;\r\nssize_t len = 0;\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_reg = dev->dev_pr_res_holder;\r\nif (pr_reg) {\r\nlen = sprintf(page, "SPC-3 Reservation Type: %s\n",\r\ncore_scsi3_pr_dump_type(pr_reg->pr_res_type));\r\n} else {\r\nlen = sprintf(page, "No SPC-3 Reservation holder\n");\r\n}\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t target_pr_res_type_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nif (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\r\nreturn sprintf(page, "SPC_PASSTHROUGH\n");\r\nelse if (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\r\nreturn sprintf(page, "SPC2_RESERVATIONS\n");\r\nelse\r\nreturn sprintf(page, "SPC3_PERSISTENT_RESERVATIONS\n");\r\n}\r\nstatic ssize_t target_pr_res_aptpl_active_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nif (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\r\nreturn 0;\r\nreturn sprintf(page, "APTPL Bit Status: %s\n",\r\n(dev->t10_pr.pr_aptpl_active) ? "Activated" : "Disabled");\r\n}\r\nstatic ssize_t target_pr_res_aptpl_metadata_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nif (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\r\nreturn 0;\r\nreturn sprintf(page, "Ready to process PR APTPL metadata..\n");\r\n}\r\nstatic ssize_t target_pr_res_aptpl_metadata_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_device *dev = pr_to_dev(item);\r\nunsigned char *i_fabric = NULL, *i_port = NULL, *isid = NULL;\r\nunsigned char *t_fabric = NULL, *t_port = NULL;\r\nchar *orig, *ptr, *opts;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nunsigned long long tmp_ll;\r\nu64 sa_res_key = 0;\r\nu64 mapped_lun = 0, target_lun = 0;\r\nint ret = -1, res_holder = 0, all_tg_pt = 0, arg, token;\r\nu16 tpgt = 0;\r\nu8 type = 0;\r\nif (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\r\nreturn count;\r\nif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\r\nreturn count;\r\nif (dev->export_count) {\r\npr_debug("Unable to process APTPL metadata while"\r\n" active fabric exports exist\n");\r\nreturn -EINVAL;\r\n}\r\nopts = kstrdup(page, GFP_KERNEL);\r\nif (!opts)\r\nreturn -ENOMEM;\r\norig = opts;\r\nwhile ((ptr = strsep(&opts, ",\n")) != NULL) {\r\nif (!*ptr)\r\ncontinue;\r\ntoken = match_token(ptr, tokens, args);\r\nswitch (token) {\r\ncase Opt_initiator_fabric:\r\ni_fabric = match_strdup(args);\r\nif (!i_fabric) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbreak;\r\ncase Opt_initiator_node:\r\ni_port = match_strdup(args);\r\nif (!i_port) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (strlen(i_port) >= PR_APTPL_MAX_IPORT_LEN) {\r\npr_err("APTPL metadata initiator_node="\r\n" exceeds PR_APTPL_MAX_IPORT_LEN: %d\n",\r\nPR_APTPL_MAX_IPORT_LEN);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase Opt_initiator_sid:\r\nisid = match_strdup(args);\r\nif (!isid) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (strlen(isid) >= PR_REG_ISID_LEN) {\r\npr_err("APTPL metadata initiator_isid"\r\n"= exceeds PR_REG_ISID_LEN: %d\n",\r\nPR_REG_ISID_LEN);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase Opt_sa_res_key:\r\nret = kstrtoull(args->from, 0, &tmp_ll);\r\nif (ret < 0) {\r\npr_err("kstrtoull() failed for sa_res_key=\n");\r\ngoto out;\r\n}\r\nsa_res_key = (u64)tmp_ll;\r\nbreak;\r\ncase Opt_res_holder:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\nres_holder = arg;\r\nbreak;\r\ncase Opt_res_type:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\ntype = (u8)arg;\r\nbreak;\r\ncase Opt_res_scope:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\nbreak;\r\ncase Opt_res_all_tg_pt:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\nall_tg_pt = (int)arg;\r\nbreak;\r\ncase Opt_mapped_lun:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\nmapped_lun = (u64)arg;\r\nbreak;\r\ncase Opt_target_fabric:\r\nt_fabric = match_strdup(args);\r\nif (!t_fabric) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbreak;\r\ncase Opt_target_node:\r\nt_port = match_strdup(args);\r\nif (!t_port) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (strlen(t_port) >= PR_APTPL_MAX_TPORT_LEN) {\r\npr_err("APTPL metadata target_node="\r\n" exceeds PR_APTPL_MAX_TPORT_LEN: %d\n",\r\nPR_APTPL_MAX_TPORT_LEN);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase Opt_tpgt:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\ntpgt = (u16)arg;\r\nbreak;\r\ncase Opt_port_rtpi:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\nbreak;\r\ncase Opt_target_lun:\r\nret = match_int(args, &arg);\r\nif (ret)\r\ngoto out;\r\ntarget_lun = (u64)arg;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (!i_port || !t_port || !sa_res_key) {\r\npr_err("Illegal parameters for APTPL registration\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (res_holder && !(type)) {\r\npr_err("Illegal PR type: 0x%02x for reservation"\r\n" holder\n", type);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = core_scsi3_alloc_aptpl_registration(&dev->t10_pr, sa_res_key,\r\ni_port, isid, mapped_lun, t_port, tpgt, target_lun,\r\nres_holder, all_tg_pt, type);\r\nout:\r\nkfree(i_fabric);\r\nkfree(i_port);\r\nkfree(isid);\r\nkfree(t_fabric);\r\nkfree(t_port);\r\nkfree(orig);\r\nreturn (ret == 0) ? count : ret;\r\n}\r\nstatic inline struct se_device *to_device(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct se_device, dev_group);\r\n}\r\nstatic ssize_t target_dev_info_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nint bl = 0;\r\nssize_t read_bytes = 0;\r\ntransport_dump_dev_state(dev, page, &bl);\r\nread_bytes += bl;\r\nread_bytes += dev->transport->show_configfs_dev_params(dev,\r\npage+read_bytes);\r\nreturn read_bytes;\r\n}\r\nstatic ssize_t target_dev_control_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nreturn dev->transport->set_configfs_dev_params(dev, page, count);\r\n}\r\nstatic ssize_t target_dev_alias_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nif (!(dev->dev_flags & DF_USING_ALIAS))\r\nreturn 0;\r\nreturn snprintf(page, PAGE_SIZE, "%s\n", dev->dev_alias);\r\n}\r\nstatic ssize_t target_dev_alias_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nstruct se_hba *hba = dev->se_hba;\r\nssize_t read_bytes;\r\nif (count > (SE_DEV_ALIAS_LEN-1)) {\r\npr_err("alias count: %d exceeds"\r\n" SE_DEV_ALIAS_LEN-1: %u\n", (int)count,\r\nSE_DEV_ALIAS_LEN-1);\r\nreturn -EINVAL;\r\n}\r\nread_bytes = snprintf(&dev->dev_alias[0], SE_DEV_ALIAS_LEN, "%s", page);\r\nif (!read_bytes)\r\nreturn -EINVAL;\r\nif (dev->dev_alias[read_bytes - 1] == '\n')\r\ndev->dev_alias[read_bytes - 1] = '\0';\r\ndev->dev_flags |= DF_USING_ALIAS;\r\npr_debug("Target_Core_ConfigFS: %s/%s set alias: %s\n",\r\nconfig_item_name(&hba->hba_group.cg_item),\r\nconfig_item_name(&dev->dev_group.cg_item),\r\ndev->dev_alias);\r\nreturn read_bytes;\r\n}\r\nstatic ssize_t target_dev_udev_path_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nif (!(dev->dev_flags & DF_USING_UDEV_PATH))\r\nreturn 0;\r\nreturn snprintf(page, PAGE_SIZE, "%s\n", dev->udev_path);\r\n}\r\nstatic ssize_t target_dev_udev_path_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nstruct se_hba *hba = dev->se_hba;\r\nssize_t read_bytes;\r\nif (count > (SE_UDEV_PATH_LEN-1)) {\r\npr_err("udev_path count: %d exceeds"\r\n" SE_UDEV_PATH_LEN-1: %u\n", (int)count,\r\nSE_UDEV_PATH_LEN-1);\r\nreturn -EINVAL;\r\n}\r\nread_bytes = snprintf(&dev->udev_path[0], SE_UDEV_PATH_LEN,\r\n"%s", page);\r\nif (!read_bytes)\r\nreturn -EINVAL;\r\nif (dev->udev_path[read_bytes - 1] == '\n')\r\ndev->udev_path[read_bytes - 1] = '\0';\r\ndev->dev_flags |= DF_USING_UDEV_PATH;\r\npr_debug("Target_Core_ConfigFS: %s/%s set udev_path: %s\n",\r\nconfig_item_name(&hba->hba_group.cg_item),\r\nconfig_item_name(&dev->dev_group.cg_item),\r\ndev->udev_path);\r\nreturn read_bytes;\r\n}\r\nstatic ssize_t target_dev_enable_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nreturn snprintf(page, PAGE_SIZE, "%d\n", !!(dev->dev_flags & DF_CONFIGURED));\r\n}\r\nstatic ssize_t target_dev_enable_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nchar *ptr;\r\nint ret;\r\nptr = strstr(page, "1");\r\nif (!ptr) {\r\npr_err("For dev_enable ops, only valid value"\r\n" is \"1\"\n");\r\nreturn -EINVAL;\r\n}\r\nret = target_configure_device(dev);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t target_dev_alua_lu_gp_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nstruct config_item *lu_ci;\r\nstruct t10_alua_lu_gp *lu_gp;\r\nstruct t10_alua_lu_gp_member *lu_gp_mem;\r\nssize_t len = 0;\r\nlu_gp_mem = dev->dev_alua_lu_gp_mem;\r\nif (!lu_gp_mem)\r\nreturn 0;\r\nspin_lock(&lu_gp_mem->lu_gp_mem_lock);\r\nlu_gp = lu_gp_mem->lu_gp;\r\nif (lu_gp) {\r\nlu_ci = &lu_gp->lu_gp_group.cg_item;\r\nlen += sprintf(page, "LU Group Alias: %s\nLU Group ID: %hu\n",\r\nconfig_item_name(lu_ci), lu_gp->lu_gp_id);\r\n}\r\nspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t target_dev_alua_lu_gp_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nstruct se_hba *hba = dev->se_hba;\r\nstruct t10_alua_lu_gp *lu_gp = NULL, *lu_gp_new = NULL;\r\nstruct t10_alua_lu_gp_member *lu_gp_mem;\r\nunsigned char buf[LU_GROUP_NAME_BUF];\r\nint move = 0;\r\nlu_gp_mem = dev->dev_alua_lu_gp_mem;\r\nif (!lu_gp_mem)\r\nreturn count;\r\nif (count > LU_GROUP_NAME_BUF) {\r\npr_err("ALUA LU Group Alias too large!\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(buf, 0, LU_GROUP_NAME_BUF);\r\nmemcpy(buf, page, count);\r\nif (strcmp(strstrip(buf), "NULL")) {\r\nlu_gp_new = core_alua_get_lu_gp_by_name(strstrip(buf));\r\nif (!lu_gp_new)\r\nreturn -ENODEV;\r\n}\r\nspin_lock(&lu_gp_mem->lu_gp_mem_lock);\r\nlu_gp = lu_gp_mem->lu_gp;\r\nif (lu_gp) {\r\nif (!lu_gp_new) {\r\npr_debug("Target_Core_ConfigFS: Releasing %s/%s"\r\n" from ALUA LU Group: core/alua/lu_gps/%s, ID:"\r\n" %hu\n",\r\nconfig_item_name(&hba->hba_group.cg_item),\r\nconfig_item_name(&dev->dev_group.cg_item),\r\nconfig_item_name(&lu_gp->lu_gp_group.cg_item),\r\nlu_gp->lu_gp_id);\r\n__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);\r\nspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\r\nreturn count;\r\n}\r\n__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);\r\nmove = 1;\r\n}\r\n__core_alua_attach_lu_gp_mem(lu_gp_mem, lu_gp_new);\r\nspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\r\npr_debug("Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:"\r\n" core/alua/lu_gps/%s, ID: %hu\n",\r\n(move) ? "Moving" : "Adding",\r\nconfig_item_name(&hba->hba_group.cg_item),\r\nconfig_item_name(&dev->dev_group.cg_item),\r\nconfig_item_name(&lu_gp_new->lu_gp_group.cg_item),\r\nlu_gp_new->lu_gp_id);\r\ncore_alua_put_lu_gp_from_name(lu_gp_new);\r\nreturn count;\r\n}\r\nstatic ssize_t target_dev_lba_map_show(struct config_item *item, char *page)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nstruct t10_alua_lba_map *map;\r\nstruct t10_alua_lba_map_member *mem;\r\nchar *b = page;\r\nint bl = 0;\r\nchar state;\r\nspin_lock(&dev->t10_alua.lba_map_lock);\r\nif (!list_empty(&dev->t10_alua.lba_map_list))\r\nbl += sprintf(b + bl, "%u %u\n",\r\ndev->t10_alua.lba_map_segment_size,\r\ndev->t10_alua.lba_map_segment_multiplier);\r\nlist_for_each_entry(map, &dev->t10_alua.lba_map_list, lba_map_list) {\r\nbl += sprintf(b + bl, "%llu %llu",\r\nmap->lba_map_first_lba, map->lba_map_last_lba);\r\nlist_for_each_entry(mem, &map->lba_map_mem_list,\r\nlba_map_mem_list) {\r\nswitch (mem->lba_map_mem_alua_state) {\r\ncase ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED:\r\nstate = 'O';\r\nbreak;\r\ncase ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:\r\nstate = 'A';\r\nbreak;\r\ncase ALUA_ACCESS_STATE_STANDBY:\r\nstate = 'S';\r\nbreak;\r\ncase ALUA_ACCESS_STATE_UNAVAILABLE:\r\nstate = 'U';\r\nbreak;\r\ndefault:\r\nstate = '.';\r\nbreak;\r\n}\r\nbl += sprintf(b + bl, " %d:%c",\r\nmem->lba_map_mem_alua_pg_id, state);\r\n}\r\nbl += sprintf(b + bl, "\n");\r\n}\r\nspin_unlock(&dev->t10_alua.lba_map_lock);\r\nreturn bl;\r\n}\r\nstatic ssize_t target_dev_lba_map_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_device *dev = to_device(item);\r\nstruct t10_alua_lba_map *lba_map = NULL;\r\nstruct list_head lba_list;\r\nchar *map_entries, *orig, *ptr;\r\nchar state;\r\nint pg_num = -1, pg;\r\nint ret = 0, num = 0, pg_id, alua_state;\r\nunsigned long start_lba = -1, end_lba = -1;\r\nunsigned long segment_size = -1, segment_mult = -1;\r\norig = map_entries = kstrdup(page, GFP_KERNEL);\r\nif (!map_entries)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&lba_list);\r\nwhile ((ptr = strsep(&map_entries, "\n")) != NULL) {\r\nif (!*ptr)\r\ncontinue;\r\nif (num == 0) {\r\nif (sscanf(ptr, "%lu %lu\n",\r\n&segment_size, &segment_mult) != 2) {\r\npr_err("Invalid line %d\n", num);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nnum++;\r\ncontinue;\r\n}\r\nif (sscanf(ptr, "%lu %lu", &start_lba, &end_lba) != 2) {\r\npr_err("Invalid line %d\n", num);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nptr = strchr(ptr, ' ');\r\nif (!ptr) {\r\npr_err("Invalid line %d, missing end lba\n", num);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nptr++;\r\nptr = strchr(ptr, ' ');\r\nif (!ptr) {\r\npr_err("Invalid line %d, missing state definitions\n",\r\nnum);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nptr++;\r\nlba_map = core_alua_allocate_lba_map(&lba_list,\r\nstart_lba, end_lba);\r\nif (IS_ERR(lba_map)) {\r\nret = PTR_ERR(lba_map);\r\nbreak;\r\n}\r\npg = 0;\r\nwhile (sscanf(ptr, "%d:%c", &pg_id, &state) == 2) {\r\nswitch (state) {\r\ncase 'O':\r\nalua_state = ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED;\r\nbreak;\r\ncase 'A':\r\nalua_state = ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED;\r\nbreak;\r\ncase 'S':\r\nalua_state = ALUA_ACCESS_STATE_STANDBY;\r\nbreak;\r\ncase 'U':\r\nalua_state = ALUA_ACCESS_STATE_UNAVAILABLE;\r\nbreak;\r\ndefault:\r\npr_err("Invalid ALUA state '%c'\n", state);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = core_alua_allocate_lba_map_mem(lba_map,\r\npg_id, alua_state);\r\nif (ret) {\r\npr_err("Invalid target descriptor %d:%c "\r\n"at line %d\n",\r\npg_id, state, num);\r\nbreak;\r\n}\r\npg++;\r\nptr = strchr(ptr, ' ');\r\nif (ptr)\r\nptr++;\r\nelse\r\nbreak;\r\n}\r\nif (pg_num == -1)\r\npg_num = pg;\r\nelse if (pg != pg_num) {\r\npr_err("Only %d from %d port groups definitions "\r\n"at line %d\n", pg, pg_num, num);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nnum++;\r\n}\r\nout:\r\nif (ret) {\r\ncore_alua_free_lba_map(&lba_list);\r\ncount = ret;\r\n} else\r\ncore_alua_set_lba_map(dev, &lba_list,\r\nsegment_size, segment_mult);\r\nkfree(orig);\r\nreturn count;\r\n}\r\nstatic void target_core_dev_release(struct config_item *item)\r\n{\r\nstruct config_group *dev_cg = to_config_group(item);\r\nstruct se_device *dev =\r\ncontainer_of(dev_cg, struct se_device, dev_group);\r\ntarget_free_device(dev);\r\n}\r\nstatic inline struct t10_alua_lu_gp *to_lu_gp(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct t10_alua_lu_gp,\r\nlu_gp_group);\r\n}\r\nstatic ssize_t target_lu_gp_lu_gp_id_show(struct config_item *item, char *page)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp = to_lu_gp(item);\r\nif (!lu_gp->lu_gp_valid_id)\r\nreturn 0;\r\nreturn sprintf(page, "%hu\n", lu_gp->lu_gp_id);\r\n}\r\nstatic ssize_t target_lu_gp_lu_gp_id_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp = to_lu_gp(item);\r\nstruct config_group *alua_lu_gp_cg = &lu_gp->lu_gp_group;\r\nunsigned long lu_gp_id;\r\nint ret;\r\nret = kstrtoul(page, 0, &lu_gp_id);\r\nif (ret < 0) {\r\npr_err("kstrtoul() returned %d for"\r\n" lu_gp_id\n", ret);\r\nreturn ret;\r\n}\r\nif (lu_gp_id > 0x0000ffff) {\r\npr_err("ALUA lu_gp_id: %lu exceeds maximum:"\r\n" 0x0000ffff\n", lu_gp_id);\r\nreturn -EINVAL;\r\n}\r\nret = core_alua_set_lu_gp_id(lu_gp, (u16)lu_gp_id);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\npr_debug("Target_Core_ConfigFS: Set ALUA Logical Unit"\r\n" Group: core/alua/lu_gps/%s to ID: %hu\n",\r\nconfig_item_name(&alua_lu_gp_cg->cg_item),\r\nlu_gp->lu_gp_id);\r\nreturn count;\r\n}\r\nstatic ssize_t target_lu_gp_members_show(struct config_item *item, char *page)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp = to_lu_gp(item);\r\nstruct se_device *dev;\r\nstruct se_hba *hba;\r\nstruct t10_alua_lu_gp_member *lu_gp_mem;\r\nssize_t len = 0, cur_len;\r\nunsigned char buf[LU_GROUP_NAME_BUF];\r\nmemset(buf, 0, LU_GROUP_NAME_BUF);\r\nspin_lock(&lu_gp->lu_gp_lock);\r\nlist_for_each_entry(lu_gp_mem, &lu_gp->lu_gp_mem_list, lu_gp_mem_list) {\r\ndev = lu_gp_mem->lu_gp_mem_dev;\r\nhba = dev->se_hba;\r\ncur_len = snprintf(buf, LU_GROUP_NAME_BUF, "%s/%s\n",\r\nconfig_item_name(&hba->hba_group.cg_item),\r\nconfig_item_name(&dev->dev_group.cg_item));\r\ncur_len++;\r\nif ((cur_len + len) > PAGE_SIZE) {\r\npr_warn("Ran out of lu_gp_show_attr"\r\n"_members buffer\n");\r\nbreak;\r\n}\r\nmemcpy(page+len, buf, cur_len);\r\nlen += cur_len;\r\n}\r\nspin_unlock(&lu_gp->lu_gp_lock);\r\nreturn len;\r\n}\r\nstatic void target_core_alua_lu_gp_release(struct config_item *item)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp = container_of(to_config_group(item),\r\nstruct t10_alua_lu_gp, lu_gp_group);\r\ncore_alua_free_lu_gp(lu_gp);\r\n}\r\nstatic struct config_group *target_core_alua_create_lu_gp(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp;\r\nstruct config_group *alua_lu_gp_cg = NULL;\r\nstruct config_item *alua_lu_gp_ci = NULL;\r\nlu_gp = core_alua_allocate_lu_gp(name, 0);\r\nif (IS_ERR(lu_gp))\r\nreturn NULL;\r\nalua_lu_gp_cg = &lu_gp->lu_gp_group;\r\nalua_lu_gp_ci = &alua_lu_gp_cg->cg_item;\r\nconfig_group_init_type_name(alua_lu_gp_cg, name,\r\n&target_core_alua_lu_gp_cit);\r\npr_debug("Target_Core_ConfigFS: Allocated ALUA Logical Unit"\r\n" Group: core/alua/lu_gps/%s\n",\r\nconfig_item_name(alua_lu_gp_ci));\r\nreturn alua_lu_gp_cg;\r\n}\r\nstatic void target_core_alua_drop_lu_gp(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct t10_alua_lu_gp *lu_gp = container_of(to_config_group(item),\r\nstruct t10_alua_lu_gp, lu_gp_group);\r\npr_debug("Target_Core_ConfigFS: Releasing ALUA Logical Unit"\r\n" Group: core/alua/lu_gps/%s, ID: %hu\n",\r\nconfig_item_name(item), lu_gp->lu_gp_id);\r\nconfig_item_put(item);\r\n}\r\nstatic inline struct t10_alua_tg_pt_gp *to_tg_pt_gp(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct t10_alua_tg_pt_gp,\r\ntg_pt_gp_group);\r\n}\r\nstatic ssize_t target_tg_pt_gp_alua_access_state_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%d\n",\r\natomic_read(&to_tg_pt_gp(item)->tg_pt_gp_alua_access_state));\r\n}\r\nstatic ssize_t target_tg_pt_gp_alua_access_state_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\r\nstruct se_device *dev = tg_pt_gp->tg_pt_gp_dev;\r\nunsigned long tmp;\r\nint new_state, ret;\r\nif (!tg_pt_gp->tg_pt_gp_valid_id) {\r\npr_err("Unable to do implicit ALUA on non valid"\r\n" tg_pt_gp ID: %hu\n", tg_pt_gp->tg_pt_gp_valid_id);\r\nreturn -EINVAL;\r\n}\r\nif (!(dev->dev_flags & DF_CONFIGURED)) {\r\npr_err("Unable to set alua_access_state while device is"\r\n" not configured\n");\r\nreturn -ENODEV;\r\n}\r\nret = kstrtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract new ALUA access state from"\r\n" %s\n", page);\r\nreturn ret;\r\n}\r\nnew_state = (int)tmp;\r\nif (!(tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICIT_ALUA)) {\r\npr_err("Unable to process implicit configfs ALUA"\r\n" transition while TPGS_IMPLICIT_ALUA is disabled\n");\r\nreturn -EINVAL;\r\n}\r\nif (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA &&\r\nnew_state == ALUA_ACCESS_STATE_LBA_DEPENDENT) {\r\npr_err("Unable to process implicit configfs ALUA transition"\r\n" while explicit ALUA management is enabled\n");\r\nreturn -EINVAL;\r\n}\r\nret = core_alua_do_port_transition(tg_pt_gp, dev,\r\nNULL, NULL, new_state, 0);\r\nreturn (!ret) ? count : -EINVAL;\r\n}\r\nstatic ssize_t target_tg_pt_gp_alua_access_status_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\r\nreturn sprintf(page, "%s\n",\r\ncore_alua_dump_status(tg_pt_gp->tg_pt_gp_alua_access_status));\r\n}\r\nstatic ssize_t target_tg_pt_gp_alua_access_status_store(\r\nstruct config_item *item, const char *page, size_t count)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\r\nunsigned long tmp;\r\nint new_status, ret;\r\nif (!tg_pt_gp->tg_pt_gp_valid_id) {\r\npr_err("Unable to do set ALUA access status on non"\r\n" valid tg_pt_gp ID: %hu\n",\r\ntg_pt_gp->tg_pt_gp_valid_id);\r\nreturn -EINVAL;\r\n}\r\nret = kstrtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract new ALUA access status"\r\n" from %s\n", page);\r\nreturn ret;\r\n}\r\nnew_status = (int)tmp;\r\nif ((new_status != ALUA_STATUS_NONE) &&\r\n(new_status != ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG) &&\r\n(new_status != ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA)) {\r\npr_err("Illegal ALUA access status: 0x%02x\n",\r\nnew_status);\r\nreturn -EINVAL;\r\n}\r\ntg_pt_gp->tg_pt_gp_alua_access_status = new_status;\r\nreturn count;\r\n}\r\nstatic ssize_t target_tg_pt_gp_alua_access_type_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn core_alua_show_access_type(to_tg_pt_gp(item), page);\r\n}\r\nstatic ssize_t target_tg_pt_gp_alua_access_type_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nreturn core_alua_store_access_type(to_tg_pt_gp(item), page, count);\r\n}\r\nstatic ssize_t target_tg_pt_gp_alua_write_metadata_show(\r\nstruct config_item *item, char *page)\r\n{\r\nreturn sprintf(page, "%d\n",\r\nto_tg_pt_gp(item)->tg_pt_gp_write_metadata);\r\n}\r\nstatic ssize_t target_tg_pt_gp_alua_write_metadata_store(\r\nstruct config_item *item, const char *page, size_t count)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\r\nunsigned long tmp;\r\nint ret;\r\nret = kstrtoul(page, 0, &tmp);\r\nif (ret < 0) {\r\npr_err("Unable to extract alua_write_metadata\n");\r\nreturn ret;\r\n}\r\nif ((tmp != 0) && (tmp != 1)) {\r\npr_err("Illegal value for alua_write_metadata:"\r\n" %lu\n", tmp);\r\nreturn -EINVAL;\r\n}\r\ntg_pt_gp->tg_pt_gp_write_metadata = (int)tmp;\r\nreturn count;\r\n}\r\nstatic ssize_t target_tg_pt_gp_nonop_delay_msecs_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn core_alua_show_nonop_delay_msecs(to_tg_pt_gp(item), page);\r\n}\r\nstatic ssize_t target_tg_pt_gp_nonop_delay_msecs_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nreturn core_alua_store_nonop_delay_msecs(to_tg_pt_gp(item), page,\r\ncount);\r\n}\r\nstatic ssize_t target_tg_pt_gp_trans_delay_msecs_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn core_alua_show_trans_delay_msecs(to_tg_pt_gp(item), page);\r\n}\r\nstatic ssize_t target_tg_pt_gp_trans_delay_msecs_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nreturn core_alua_store_trans_delay_msecs(to_tg_pt_gp(item), page,\r\ncount);\r\n}\r\nstatic ssize_t target_tg_pt_gp_implicit_trans_secs_show(\r\nstruct config_item *item, char *page)\r\n{\r\nreturn core_alua_show_implicit_trans_secs(to_tg_pt_gp(item), page);\r\n}\r\nstatic ssize_t target_tg_pt_gp_implicit_trans_secs_store(\r\nstruct config_item *item, const char *page, size_t count)\r\n{\r\nreturn core_alua_store_implicit_trans_secs(to_tg_pt_gp(item), page,\r\ncount);\r\n}\r\nstatic ssize_t target_tg_pt_gp_preferred_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn core_alua_show_preferred_bit(to_tg_pt_gp(item), page);\r\n}\r\nstatic ssize_t target_tg_pt_gp_preferred_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nreturn core_alua_store_preferred_bit(to_tg_pt_gp(item), page, count);\r\n}\r\nstatic ssize_t target_tg_pt_gp_tg_pt_gp_id_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\r\nif (!tg_pt_gp->tg_pt_gp_valid_id)\r\nreturn 0;\r\nreturn sprintf(page, "%hu\n", tg_pt_gp->tg_pt_gp_id);\r\n}\r\nstatic ssize_t target_tg_pt_gp_tg_pt_gp_id_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\r\nstruct config_group *alua_tg_pt_gp_cg = &tg_pt_gp->tg_pt_gp_group;\r\nunsigned long tg_pt_gp_id;\r\nint ret;\r\nret = kstrtoul(page, 0, &tg_pt_gp_id);\r\nif (ret < 0) {\r\npr_err("kstrtoul() returned %d for"\r\n" tg_pt_gp_id\n", ret);\r\nreturn ret;\r\n}\r\nif (tg_pt_gp_id > 0x0000ffff) {\r\npr_err("ALUA tg_pt_gp_id: %lu exceeds maximum:"\r\n" 0x0000ffff\n", tg_pt_gp_id);\r\nreturn -EINVAL;\r\n}\r\nret = core_alua_set_tg_pt_gp_id(tg_pt_gp, (u16)tg_pt_gp_id);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\npr_debug("Target_Core_ConfigFS: Set ALUA Target Port Group: "\r\n"core/alua/tg_pt_gps/%s to ID: %hu\n",\r\nconfig_item_name(&alua_tg_pt_gp_cg->cg_item),\r\ntg_pt_gp->tg_pt_gp_id);\r\nreturn count;\r\n}\r\nstatic ssize_t target_tg_pt_gp_members_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\r\nstruct se_lun *lun;\r\nssize_t len = 0, cur_len;\r\nunsigned char buf[TG_PT_GROUP_NAME_BUF];\r\nmemset(buf, 0, TG_PT_GROUP_NAME_BUF);\r\nspin_lock(&tg_pt_gp->tg_pt_gp_lock);\r\nlist_for_each_entry(lun, &tg_pt_gp->tg_pt_gp_lun_list,\r\nlun_tg_pt_gp_link) {\r\nstruct se_portal_group *tpg = lun->lun_tpg;\r\ncur_len = snprintf(buf, TG_PT_GROUP_NAME_BUF, "%s/%s/tpgt_%hu"\r\n"/%s\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_wwn(tpg),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg),\r\nconfig_item_name(&lun->lun_group.cg_item));\r\ncur_len++;\r\nif ((cur_len + len) > PAGE_SIZE) {\r\npr_warn("Ran out of lu_gp_show_attr"\r\n"_members buffer\n");\r\nbreak;\r\n}\r\nmemcpy(page+len, buf, cur_len);\r\nlen += cur_len;\r\n}\r\nspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\r\nreturn len;\r\n}\r\nstatic void target_core_alua_tg_pt_gp_release(struct config_item *item)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = container_of(to_config_group(item),\r\nstruct t10_alua_tg_pt_gp, tg_pt_gp_group);\r\ncore_alua_free_tg_pt_gp(tg_pt_gp);\r\n}\r\nstatic struct config_group *target_core_alua_create_tg_pt_gp(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct t10_alua *alua = container_of(group, struct t10_alua,\r\nalua_tg_pt_gps_group);\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nstruct config_group *alua_tg_pt_gp_cg = NULL;\r\nstruct config_item *alua_tg_pt_gp_ci = NULL;\r\ntg_pt_gp = core_alua_allocate_tg_pt_gp(alua->t10_dev, name, 0);\r\nif (!tg_pt_gp)\r\nreturn NULL;\r\nalua_tg_pt_gp_cg = &tg_pt_gp->tg_pt_gp_group;\r\nalua_tg_pt_gp_ci = &alua_tg_pt_gp_cg->cg_item;\r\nconfig_group_init_type_name(alua_tg_pt_gp_cg, name,\r\n&target_core_alua_tg_pt_gp_cit);\r\npr_debug("Target_Core_ConfigFS: Allocated ALUA Target Port"\r\n" Group: alua/tg_pt_gps/%s\n",\r\nconfig_item_name(alua_tg_pt_gp_ci));\r\nreturn alua_tg_pt_gp_cg;\r\n}\r\nstatic void target_core_alua_drop_tg_pt_gp(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp = container_of(to_config_group(item),\r\nstruct t10_alua_tg_pt_gp, tg_pt_gp_group);\r\npr_debug("Target_Core_ConfigFS: Releasing ALUA Target Port"\r\n" Group: alua/tg_pt_gps/%s, ID: %hu\n",\r\nconfig_item_name(item), tg_pt_gp->tg_pt_gp_id);\r\nconfig_item_put(item);\r\n}\r\nstatic struct config_group *target_core_stat_mkdir(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic void target_core_stat_rmdir(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nreturn;\r\n}\r\nstatic struct config_group *target_core_make_subdev(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct t10_alua_tg_pt_gp *tg_pt_gp;\r\nstruct config_item *hba_ci = &group->cg_item;\r\nstruct se_hba *hba = item_to_hba(hba_ci);\r\nstruct target_backend *tb = hba->backend;\r\nstruct se_device *dev;\r\nint errno = -ENOMEM, ret;\r\nret = mutex_lock_interruptible(&hba->hba_access_mutex);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ndev = target_alloc_device(hba, name);\r\nif (!dev)\r\ngoto out_unlock;\r\nconfig_group_init_type_name(&dev->dev_group, name, &tb->tb_dev_cit);\r\nconfig_group_init_type_name(&dev->dev_attrib.da_group, "attrib",\r\n&tb->tb_dev_attrib_cit);\r\nconfigfs_add_default_group(&dev->dev_attrib.da_group, &dev->dev_group);\r\nconfig_group_init_type_name(&dev->dev_pr_group, "pr",\r\n&tb->tb_dev_pr_cit);\r\nconfigfs_add_default_group(&dev->dev_pr_group, &dev->dev_group);\r\nconfig_group_init_type_name(&dev->t10_wwn.t10_wwn_group, "wwn",\r\n&tb->tb_dev_wwn_cit);\r\nconfigfs_add_default_group(&dev->t10_wwn.t10_wwn_group,\r\n&dev->dev_group);\r\nconfig_group_init_type_name(&dev->t10_alua.alua_tg_pt_gps_group,\r\n"alua", &tb->tb_dev_alua_tg_pt_gps_cit);\r\nconfigfs_add_default_group(&dev->t10_alua.alua_tg_pt_gps_group,\r\n&dev->dev_group);\r\nconfig_group_init_type_name(&dev->dev_stat_grps.stat_group,\r\n"statistics", &tb->tb_dev_stat_cit);\r\nconfigfs_add_default_group(&dev->dev_stat_grps.stat_group,\r\n&dev->dev_group);\r\ntg_pt_gp = core_alua_allocate_tg_pt_gp(dev, "default_tg_pt_gp", 1);\r\nif (!tg_pt_gp)\r\ngoto out_free_device;\r\ndev->t10_alua.default_tg_pt_gp = tg_pt_gp;\r\nconfig_group_init_type_name(&tg_pt_gp->tg_pt_gp_group,\r\n"default_tg_pt_gp", &target_core_alua_tg_pt_gp_cit);\r\nconfigfs_add_default_group(&tg_pt_gp->tg_pt_gp_group,\r\n&dev->t10_alua.alua_tg_pt_gps_group);\r\ntarget_stat_setup_dev_default_groups(dev);\r\nmutex_unlock(&hba->hba_access_mutex);\r\nreturn &dev->dev_group;\r\nout_free_device:\r\ntarget_free_device(dev);\r\nout_unlock:\r\nmutex_unlock(&hba->hba_access_mutex);\r\nreturn ERR_PTR(errno);\r\n}\r\nstatic void target_core_drop_subdev(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct config_group *dev_cg = to_config_group(item);\r\nstruct se_device *dev =\r\ncontainer_of(dev_cg, struct se_device, dev_group);\r\nstruct se_hba *hba;\r\nhba = item_to_hba(&dev->se_hba->hba_group.cg_item);\r\nmutex_lock(&hba->hba_access_mutex);\r\nconfigfs_remove_default_groups(&dev->dev_stat_grps.stat_group);\r\nconfigfs_remove_default_groups(&dev->t10_alua.alua_tg_pt_gps_group);\r\ndev->t10_alua.default_tg_pt_gp = NULL;\r\nconfigfs_remove_default_groups(dev_cg);\r\nconfig_item_put(item);\r\nmutex_unlock(&hba->hba_access_mutex);\r\n}\r\nstatic inline struct se_hba *to_hba(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct se_hba, hba_group);\r\n}\r\nstatic ssize_t target_hba_info_show(struct config_item *item, char *page)\r\n{\r\nstruct se_hba *hba = to_hba(item);\r\nreturn sprintf(page, "HBA Index: %d plugin: %s version: %s\n",\r\nhba->hba_id, hba->backend->ops->name,\r\nTARGET_CORE_VERSION);\r\n}\r\nstatic ssize_t target_hba_mode_show(struct config_item *item, char *page)\r\n{\r\nstruct se_hba *hba = to_hba(item);\r\nint hba_mode = 0;\r\nif (hba->hba_flags & HBA_FLAGS_PSCSI_MODE)\r\nhba_mode = 1;\r\nreturn sprintf(page, "%d\n", hba_mode);\r\n}\r\nstatic ssize_t target_hba_mode_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_hba *hba = to_hba(item);\r\nunsigned long mode_flag;\r\nint ret;\r\nif (hba->backend->ops->pmode_enable_hba == NULL)\r\nreturn -EINVAL;\r\nret = kstrtoul(page, 0, &mode_flag);\r\nif (ret < 0) {\r\npr_err("Unable to extract hba mode flag: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (hba->dev_count) {\r\npr_err("Unable to set hba_mode with active devices\n");\r\nreturn -EINVAL;\r\n}\r\nret = hba->backend->ops->pmode_enable_hba(hba, mode_flag);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nif (ret > 0)\r\nhba->hba_flags |= HBA_FLAGS_PSCSI_MODE;\r\nelse if (ret == 0)\r\nhba->hba_flags &= ~HBA_FLAGS_PSCSI_MODE;\r\nreturn count;\r\n}\r\nstatic void target_core_hba_release(struct config_item *item)\r\n{\r\nstruct se_hba *hba = container_of(to_config_group(item),\r\nstruct se_hba, hba_group);\r\ncore_delete_hba(hba);\r\n}\r\nstatic struct config_group *target_core_call_addhbatotarget(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nchar *se_plugin_str, *str, *str2;\r\nstruct se_hba *hba;\r\nchar buf[TARGET_CORE_NAME_MAX_LEN];\r\nunsigned long plugin_dep_id = 0;\r\nint ret;\r\nmemset(buf, 0, TARGET_CORE_NAME_MAX_LEN);\r\nif (strlen(name) >= TARGET_CORE_NAME_MAX_LEN) {\r\npr_err("Passed *name strlen(): %d exceeds"\r\n" TARGET_CORE_NAME_MAX_LEN: %d\n", (int)strlen(name),\r\nTARGET_CORE_NAME_MAX_LEN);\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\n}\r\nsnprintf(buf, TARGET_CORE_NAME_MAX_LEN, "%s", name);\r\nstr = strstr(buf, "_");\r\nif (!str) {\r\npr_err("Unable to locate \"_\" for $SUBSYSTEM_PLUGIN_$HOST_ID\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nse_plugin_str = buf;\r\nstr2 = strstr(str+1, "_");\r\nif (str2) {\r\n*str2 = '\0';\r\nstr2++;\r\nstr = str2;\r\n} else {\r\n*str = '\0';\r\nstr++;\r\n}\r\nret = kstrtoul(str, 0, &plugin_dep_id);\r\nif (ret < 0) {\r\npr_err("kstrtoul() returned %d for"\r\n" plugin_dep_id\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\ntransport_subsystem_check_init();\r\nhba = core_alloc_hba(se_plugin_str, plugin_dep_id, 0);\r\nif (IS_ERR(hba))\r\nreturn ERR_CAST(hba);\r\nconfig_group_init_type_name(&hba->hba_group, name,\r\n&target_core_hba_cit);\r\nreturn &hba->hba_group;\r\n}\r\nstatic void target_core_call_delhbafromtarget(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nconfig_item_put(item);\r\n}\r\nvoid target_setup_backend_cits(struct target_backend *tb)\r\n{\r\ntarget_core_setup_dev_cit(tb);\r\ntarget_core_setup_dev_attrib_cit(tb);\r\ntarget_core_setup_dev_pr_cit(tb);\r\ntarget_core_setup_dev_wwn_cit(tb);\r\ntarget_core_setup_dev_alua_tg_pt_gps_cit(tb);\r\ntarget_core_setup_dev_stat_cit(tb);\r\n}\r\nstatic int __init target_core_init_configfs(void)\r\n{\r\nstruct configfs_subsystem *subsys = &target_core_fabrics;\r\nstruct t10_alua_lu_gp *lu_gp;\r\nint ret;\r\npr_debug("TARGET_CORE[0]: Loading Generic Kernel Storage"\r\n" Engine: %s on %s/%s on "UTS_RELEASE"\n",\r\nTARGET_CORE_VERSION, utsname()->sysname, utsname()->machine);\r\nconfig_group_init(&subsys->su_group);\r\nmutex_init(&subsys->su_mutex);\r\nret = init_se_kmem_caches();\r\nif (ret < 0)\r\nreturn ret;\r\nconfig_group_init_type_name(&target_core_hbagroup, "core",\r\n&target_core_cit);\r\nconfigfs_add_default_group(&target_core_hbagroup, &subsys->su_group);\r\nconfig_group_init_type_name(&alua_group, "alua", &target_core_alua_cit);\r\nconfigfs_add_default_group(&alua_group, &target_core_hbagroup);\r\nconfig_group_init_type_name(&alua_lu_gps_group, "lu_gps",\r\n&target_core_alua_lu_gps_cit);\r\nconfigfs_add_default_group(&alua_lu_gps_group, &alua_group);\r\nlu_gp = core_alua_allocate_lu_gp("default_lu_gp", 1);\r\nif (IS_ERR(lu_gp)) {\r\nret = -ENOMEM;\r\ngoto out_global;\r\n}\r\nconfig_group_init_type_name(&lu_gp->lu_gp_group, "default_lu_gp",\r\n&target_core_alua_lu_gp_cit);\r\nconfigfs_add_default_group(&lu_gp->lu_gp_group, &alua_lu_gps_group);\r\ndefault_lu_gp = lu_gp;\r\nret = configfs_register_subsystem(subsys);\r\nif (ret < 0) {\r\npr_err("Error %d while registering subsystem %s\n",\r\nret, subsys->su_group.cg_item.ci_namebuf);\r\ngoto out_global;\r\n}\r\npr_debug("TARGET_CORE[0]: Initialized ConfigFS Fabric"\r\n" Infrastructure: "TARGET_CORE_VERSION" on %s/%s"\r\n" on "UTS_RELEASE"\n", utsname()->sysname, utsname()->machine);\r\nret = rd_module_init();\r\nif (ret < 0)\r\ngoto out;\r\nret = core_dev_setup_virtual_lun0();\r\nif (ret < 0)\r\ngoto out;\r\nret = target_xcopy_setup_pt();\r\nif (ret < 0)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nconfigfs_unregister_subsystem(subsys);\r\ncore_dev_release_virtual_lun0();\r\nrd_module_exit();\r\nout_global:\r\nif (default_lu_gp) {\r\ncore_alua_free_lu_gp(default_lu_gp);\r\ndefault_lu_gp = NULL;\r\n}\r\nrelease_se_kmem_caches();\r\nreturn ret;\r\n}\r\nstatic void __exit target_core_exit_configfs(void)\r\n{\r\nconfigfs_remove_default_groups(&alua_lu_gps_group);\r\nconfigfs_remove_default_groups(&alua_group);\r\nconfigfs_remove_default_groups(&target_core_hbagroup);\r\nconfigfs_unregister_subsystem(&target_core_fabrics);\r\ncore_alua_free_lu_gp(default_lu_gp);\r\ndefault_lu_gp = NULL;\r\npr_debug("TARGET_CORE[0]: Released ConfigFS Fabric"\r\n" Infrastructure\n");\r\ncore_dev_release_virtual_lun0();\r\nrd_module_exit();\r\ntarget_xcopy_release_pt();\r\nrelease_se_kmem_caches();\r\n}
