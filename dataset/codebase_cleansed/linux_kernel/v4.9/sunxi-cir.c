static irqreturn_t sunxi_ir_irq(int irqno, void *dev_id)\r\n{\r\nunsigned long status;\r\nunsigned char dt;\r\nunsigned int cnt, rc;\r\nstruct sunxi_ir *ir = dev_id;\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nspin_lock(&ir->ir_lock);\r\nstatus = readl(ir->base + SUNXI_IR_RXSTA_REG);\r\nwritel(status | REG_RXSTA_CLEARALL, ir->base + SUNXI_IR_RXSTA_REG);\r\nif (status & (REG_RXINT_RAI_EN | REG_RXINT_RPEI_EN)) {\r\nrc = REG_RXSTA_GET_AC(status);\r\nrc = rc > ir->fifo_size ? ir->fifo_size : rc;\r\nfor (cnt = 0; cnt < rc; cnt++) {\r\ndt = readb(ir->base + SUNXI_IR_RXFIFO_REG);\r\nrawir.pulse = (dt & 0x80) != 0;\r\nrawir.duration = ((dt & 0x7f) + 1) * SUNXI_IR_SAMPLE;\r\nir_raw_event_store_with_filter(ir->rc, &rawir);\r\n}\r\n}\r\nif (status & REG_RXINT_ROI_EN) {\r\nir_raw_event_reset(ir->rc);\r\n} else if (status & REG_RXINT_RPEI_EN) {\r\nir_raw_event_set_idle(ir->rc, true);\r\nir_raw_event_handle(ir->rc);\r\n}\r\nspin_unlock(&ir->ir_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sunxi_ir_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nunsigned long tmp = 0;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *dn = dev->of_node;\r\nstruct resource *res;\r\nstruct sunxi_ir *ir;\r\nir = devm_kzalloc(dev, sizeof(struct sunxi_ir), GFP_KERNEL);\r\nif (!ir)\r\nreturn -ENOMEM;\r\nspin_lock_init(&ir->ir_lock);\r\nif (of_device_is_compatible(dn, "allwinner,sun5i-a13-ir"))\r\nir->fifo_size = 64;\r\nelse\r\nir->fifo_size = 16;\r\nir->apb_clk = devm_clk_get(dev, "apb");\r\nif (IS_ERR(ir->apb_clk)) {\r\ndev_err(dev, "failed to get a apb clock.\n");\r\nreturn PTR_ERR(ir->apb_clk);\r\n}\r\nir->clk = devm_clk_get(dev, "ir");\r\nif (IS_ERR(ir->clk)) {\r\ndev_err(dev, "failed to get a ir clock.\n");\r\nreturn PTR_ERR(ir->clk);\r\n}\r\nir->rst = devm_reset_control_get_optional(dev, NULL);\r\nif (IS_ERR(ir->rst)) {\r\nret = PTR_ERR(ir->rst);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\nir->rst = NULL;\r\n} else {\r\nret = reset_control_deassert(ir->rst);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = clk_set_rate(ir->clk, SUNXI_IR_BASE_CLK);\r\nif (ret) {\r\ndev_err(dev, "set ir base clock failed!\n");\r\ngoto exit_reset_assert;\r\n}\r\nif (clk_prepare_enable(ir->apb_clk)) {\r\ndev_err(dev, "try to enable apb_ir_clk failed\n");\r\nret = -EINVAL;\r\ngoto exit_reset_assert;\r\n}\r\nif (clk_prepare_enable(ir->clk)) {\r\ndev_err(dev, "try to enable ir_clk failed\n");\r\nret = -EINVAL;\r\ngoto exit_clkdisable_apb_clk;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nir->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ir->base)) {\r\ndev_err(dev, "failed to map registers\n");\r\nret = PTR_ERR(ir->base);\r\ngoto exit_clkdisable_clk;\r\n}\r\nir->rc = rc_allocate_device();\r\nif (!ir->rc) {\r\ndev_err(dev, "failed to allocate device\n");\r\nret = -ENOMEM;\r\ngoto exit_clkdisable_clk;\r\n}\r\nir->rc->priv = ir;\r\nir->rc->input_name = SUNXI_IR_DEV;\r\nir->rc->input_phys = "sunxi-ir/input0";\r\nir->rc->input_id.bustype = BUS_HOST;\r\nir->rc->input_id.vendor = 0x0001;\r\nir->rc->input_id.product = 0x0001;\r\nir->rc->input_id.version = 0x0100;\r\nir->map_name = of_get_property(dn, "linux,rc-map-name", NULL);\r\nir->rc->map_name = ir->map_name ?: RC_MAP_EMPTY;\r\nir->rc->dev.parent = dev;\r\nir->rc->driver_type = RC_DRIVER_IR_RAW;\r\nir->rc->allowed_protocols = RC_BIT_ALL;\r\nir->rc->rx_resolution = SUNXI_IR_SAMPLE;\r\nir->rc->timeout = MS_TO_NS(SUNXI_IR_TIMEOUT);\r\nir->rc->driver_name = SUNXI_IR_DEV;\r\nret = rc_register_device(ir->rc);\r\nif (ret) {\r\ndev_err(dev, "failed to register rc device\n");\r\ngoto exit_free_dev;\r\n}\r\nplatform_set_drvdata(pdev, ir);\r\nir->irq = platform_get_irq(pdev, 0);\r\nif (ir->irq < 0) {\r\ndev_err(dev, "no irq resource\n");\r\nret = ir->irq;\r\ngoto exit_free_dev;\r\n}\r\nret = devm_request_irq(dev, ir->irq, sunxi_ir_irq, 0, SUNXI_IR_DEV, ir);\r\nif (ret) {\r\ndev_err(dev, "failed request irq\n");\r\ngoto exit_free_dev;\r\n}\r\nwritel(REG_CTL_MD, ir->base+SUNXI_IR_CTL_REG);\r\nwritel(REG_CIR_NTHR(SUNXI_IR_RXNOISE)|REG_CIR_ITHR(SUNXI_IR_RXIDLE),\r\nir->base + SUNXI_IR_CIR_REG);\r\nwritel(REG_RXCTL_RPPI, ir->base + SUNXI_IR_RXCTL_REG);\r\nwritel(REG_RXSTA_CLEARALL, ir->base + SUNXI_IR_RXSTA_REG);\r\nwritel(REG_RXINT_ROI_EN | REG_RXINT_RPEI_EN |\r\nREG_RXINT_RAI_EN | REG_RXINT_RAL(ir->fifo_size / 2 - 1),\r\nir->base + SUNXI_IR_RXINT_REG);\r\ntmp = readl(ir->base + SUNXI_IR_CTL_REG);\r\nwritel(tmp | REG_CTL_GEN | REG_CTL_RXEN, ir->base + SUNXI_IR_CTL_REG);\r\ndev_info(dev, "initialized sunXi IR driver\n");\r\nreturn 0;\r\nexit_free_dev:\r\nrc_free_device(ir->rc);\r\nexit_clkdisable_clk:\r\nclk_disable_unprepare(ir->clk);\r\nexit_clkdisable_apb_clk:\r\nclk_disable_unprepare(ir->apb_clk);\r\nexit_reset_assert:\r\nif (ir->rst)\r\nreset_control_assert(ir->rst);\r\nreturn ret;\r\n}\r\nstatic int sunxi_ir_remove(struct platform_device *pdev)\r\n{\r\nunsigned long flags;\r\nstruct sunxi_ir *ir = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(ir->clk);\r\nclk_disable_unprepare(ir->apb_clk);\r\nif (ir->rst)\r\nreset_control_assert(ir->rst);\r\nspin_lock_irqsave(&ir->ir_lock, flags);\r\nwritel(0, ir->base + SUNXI_IR_RXINT_REG);\r\nwritel(REG_RXSTA_CLEARALL, ir->base + SUNXI_IR_RXSTA_REG);\r\nwritel(0, ir->base + SUNXI_IR_CTL_REG);\r\nspin_unlock_irqrestore(&ir->ir_lock, flags);\r\nrc_unregister_device(ir->rc);\r\nreturn 0;\r\n}
