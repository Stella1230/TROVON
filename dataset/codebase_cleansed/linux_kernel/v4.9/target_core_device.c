sense_reason_t\r\ntransport_lookup_cmd_lun(struct se_cmd *se_cmd, u64 unpacked_lun)\r\n{\r\nstruct se_lun *se_lun = NULL;\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nstruct se_node_acl *nacl = se_sess->se_node_acl;\r\nstruct se_dev_entry *deve;\r\nsense_reason_t ret = TCM_NO_SENSE;\r\nrcu_read_lock();\r\ndeve = target_nacl_find_deve(nacl, unpacked_lun);\r\nif (deve) {\r\natomic_long_inc(&deve->total_cmds);\r\nif (se_cmd->data_direction == DMA_TO_DEVICE)\r\natomic_long_add(se_cmd->data_length,\r\n&deve->write_bytes);\r\nelse if (se_cmd->data_direction == DMA_FROM_DEVICE)\r\natomic_long_add(se_cmd->data_length,\r\n&deve->read_bytes);\r\nse_lun = rcu_dereference(deve->se_lun);\r\nse_cmd->se_lun = rcu_dereference(deve->se_lun);\r\nse_cmd->pr_res_key = deve->pr_res_key;\r\nse_cmd->orig_fe_lun = unpacked_lun;\r\nse_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;\r\npercpu_ref_get(&se_lun->lun_ref);\r\nse_cmd->lun_ref_active = true;\r\nif ((se_cmd->data_direction == DMA_TO_DEVICE) &&\r\ndeve->lun_access_ro) {\r\npr_err("TARGET_CORE[%s]: Detected WRITE_PROTECTED LUN"\r\n" Access for 0x%08llx\n",\r\nse_cmd->se_tfo->get_fabric_name(),\r\nunpacked_lun);\r\nrcu_read_unlock();\r\nret = TCM_WRITE_PROTECTED;\r\ngoto ref_dev;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!se_lun) {\r\nif (unpacked_lun != 0) {\r\npr_err("TARGET_CORE[%s]: Detected NON_EXISTENT_LUN"\r\n" Access for 0x%08llx\n",\r\nse_cmd->se_tfo->get_fabric_name(),\r\nunpacked_lun);\r\nreturn TCM_NON_EXISTENT_LUN;\r\n}\r\nse_lun = se_sess->se_tpg->tpg_virt_lun0;\r\nse_cmd->se_lun = se_sess->se_tpg->tpg_virt_lun0;\r\nse_cmd->orig_fe_lun = 0;\r\nse_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;\r\npercpu_ref_get(&se_lun->lun_ref);\r\nse_cmd->lun_ref_active = true;\r\nif ((se_cmd->data_direction != DMA_FROM_DEVICE) &&\r\n(se_cmd->data_direction != DMA_NONE)) {\r\nret = TCM_WRITE_PROTECTED;\r\ngoto ref_dev;\r\n}\r\n}\r\nref_dev:\r\nse_cmd->se_dev = rcu_dereference_raw(se_lun->lun_se_dev);\r\natomic_long_inc(&se_cmd->se_dev->num_cmds);\r\nif (se_cmd->data_direction == DMA_TO_DEVICE)\r\natomic_long_add(se_cmd->data_length,\r\n&se_cmd->se_dev->write_bytes);\r\nelse if (se_cmd->data_direction == DMA_FROM_DEVICE)\r\natomic_long_add(se_cmd->data_length,\r\n&se_cmd->se_dev->read_bytes);\r\nreturn ret;\r\n}\r\nint transport_lookup_tmr_lun(struct se_cmd *se_cmd, u64 unpacked_lun)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_lun *se_lun = NULL;\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nstruct se_node_acl *nacl = se_sess->se_node_acl;\r\nstruct se_tmr_req *se_tmr = se_cmd->se_tmr_req;\r\nunsigned long flags;\r\nrcu_read_lock();\r\ndeve = target_nacl_find_deve(nacl, unpacked_lun);\r\nif (deve) {\r\nse_tmr->tmr_lun = rcu_dereference(deve->se_lun);\r\nse_cmd->se_lun = rcu_dereference(deve->se_lun);\r\nse_lun = rcu_dereference(deve->se_lun);\r\nse_cmd->pr_res_key = deve->pr_res_key;\r\nse_cmd->orig_fe_lun = unpacked_lun;\r\n}\r\nrcu_read_unlock();\r\nif (!se_lun) {\r\npr_debug("TARGET_CORE[%s]: Detected NON_EXISTENT_LUN"\r\n" Access for 0x%08llx\n",\r\nse_cmd->se_tfo->get_fabric_name(),\r\nunpacked_lun);\r\nreturn -ENODEV;\r\n}\r\nse_cmd->se_dev = rcu_dereference_raw(se_lun->lun_se_dev);\r\nse_tmr->tmr_dev = rcu_dereference_raw(se_lun->lun_se_dev);\r\nspin_lock_irqsave(&se_tmr->tmr_dev->se_tmr_lock, flags);\r\nlist_add_tail(&se_tmr->tmr_list, &se_tmr->tmr_dev->dev_tmr_list);\r\nspin_unlock_irqrestore(&se_tmr->tmr_dev->se_tmr_lock, flags);\r\nreturn 0;\r\n}\r\nbool target_lun_is_rdonly(struct se_cmd *cmd)\r\n{\r\nstruct se_session *se_sess = cmd->se_sess;\r\nstruct se_dev_entry *deve;\r\nbool ret;\r\nrcu_read_lock();\r\ndeve = target_nacl_find_deve(se_sess->se_node_acl, cmd->orig_fe_lun);\r\nret = deve && deve->lun_access_ro;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstruct se_dev_entry *core_get_se_deve_from_rtpi(\r\nstruct se_node_acl *nacl,\r\nu16 rtpi)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_lun *lun;\r\nstruct se_portal_group *tpg = nacl->se_tpg;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\r\nlun = rcu_dereference(deve->se_lun);\r\nif (!lun) {\r\npr_err("%s device entries device pointer is"\r\n" NULL, but Initiator has access.\n",\r\ntpg->se_tpg_tfo->get_fabric_name());\r\ncontinue;\r\n}\r\nif (lun->lun_rtpi != rtpi)\r\ncontinue;\r\nkref_get(&deve->pr_kref);\r\nrcu_read_unlock();\r\nreturn deve;\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nvoid core_free_device_list_for_node(\r\nstruct se_node_acl *nacl,\r\nstruct se_portal_group *tpg)\r\n{\r\nstruct se_dev_entry *deve;\r\nmutex_lock(&nacl->lun_entry_mutex);\r\nhlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\r\nstruct se_lun *lun = rcu_dereference_check(deve->se_lun,\r\nlockdep_is_held(&nacl->lun_entry_mutex));\r\ncore_disable_device_list_for_node(lun, deve, nacl, tpg);\r\n}\r\nmutex_unlock(&nacl->lun_entry_mutex);\r\n}\r\nvoid core_update_device_list_access(\r\nu64 mapped_lun,\r\nbool lun_access_ro,\r\nstruct se_node_acl *nacl)\r\n{\r\nstruct se_dev_entry *deve;\r\nmutex_lock(&nacl->lun_entry_mutex);\r\ndeve = target_nacl_find_deve(nacl, mapped_lun);\r\nif (deve)\r\ndeve->lun_access_ro = lun_access_ro;\r\nmutex_unlock(&nacl->lun_entry_mutex);\r\n}\r\nstruct se_dev_entry *target_nacl_find_deve(struct se_node_acl *nacl, u64 mapped_lun)\r\n{\r\nstruct se_dev_entry *deve;\r\nhlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link)\r\nif (deve->mapped_lun == mapped_lun)\r\nreturn deve;\r\nreturn NULL;\r\n}\r\nvoid target_pr_kref_release(struct kref *kref)\r\n{\r\nstruct se_dev_entry *deve = container_of(kref, struct se_dev_entry,\r\npr_kref);\r\ncomplete(&deve->pr_comp);\r\n}\r\nstatic void\r\ntarget_luns_data_has_changed(struct se_node_acl *nacl, struct se_dev_entry *new,\r\nbool skip_new)\r\n{\r\nstruct se_dev_entry *tmp;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp, &nacl->lun_entry_hlist, link) {\r\nif (skip_new && tmp == new)\r\ncontinue;\r\ncore_scsi3_ua_allocate(tmp, 0x3F,\r\nASCQ_3FH_REPORTED_LUNS_DATA_HAS_CHANGED);\r\n}\r\nrcu_read_unlock();\r\n}\r\nint core_enable_device_list_for_node(\r\nstruct se_lun *lun,\r\nstruct se_lun_acl *lun_acl,\r\nu64 mapped_lun,\r\nbool lun_access_ro,\r\nstruct se_node_acl *nacl,\r\nstruct se_portal_group *tpg)\r\n{\r\nstruct se_dev_entry *orig, *new;\r\nnew = kzalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new) {\r\npr_err("Unable to allocate se_dev_entry memory\n");\r\nreturn -ENOMEM;\r\n}\r\natomic_set(&new->ua_count, 0);\r\nspin_lock_init(&new->ua_lock);\r\nINIT_LIST_HEAD(&new->ua_list);\r\nINIT_LIST_HEAD(&new->lun_link);\r\nnew->mapped_lun = mapped_lun;\r\nkref_init(&new->pr_kref);\r\ninit_completion(&new->pr_comp);\r\nnew->lun_access_ro = lun_access_ro;\r\nnew->creation_time = get_jiffies_64();\r\nnew->attach_count++;\r\nmutex_lock(&nacl->lun_entry_mutex);\r\norig = target_nacl_find_deve(nacl, mapped_lun);\r\nif (orig && orig->se_lun) {\r\nstruct se_lun *orig_lun = rcu_dereference_check(orig->se_lun,\r\nlockdep_is_held(&nacl->lun_entry_mutex));\r\nif (orig_lun != lun) {\r\npr_err("Existing orig->se_lun doesn't match new lun"\r\n" for dynamic -> explicit NodeACL conversion:"\r\n" %s\n", nacl->initiatorname);\r\nmutex_unlock(&nacl->lun_entry_mutex);\r\nkfree(new);\r\nreturn -EINVAL;\r\n}\r\nBUG_ON(orig->se_lun_acl != NULL);\r\nrcu_assign_pointer(new->se_lun, lun);\r\nrcu_assign_pointer(new->se_lun_acl, lun_acl);\r\nhlist_del_rcu(&orig->link);\r\nhlist_add_head_rcu(&new->link, &nacl->lun_entry_hlist);\r\nmutex_unlock(&nacl->lun_entry_mutex);\r\nspin_lock(&lun->lun_deve_lock);\r\nlist_del(&orig->lun_link);\r\nlist_add_tail(&new->lun_link, &lun->lun_deve_list);\r\nspin_unlock(&lun->lun_deve_lock);\r\nkref_put(&orig->pr_kref, target_pr_kref_release);\r\nwait_for_completion(&orig->pr_comp);\r\ntarget_luns_data_has_changed(nacl, new, true);\r\nkfree_rcu(orig, rcu_head);\r\nreturn 0;\r\n}\r\nrcu_assign_pointer(new->se_lun, lun);\r\nrcu_assign_pointer(new->se_lun_acl, lun_acl);\r\nhlist_add_head_rcu(&new->link, &nacl->lun_entry_hlist);\r\nmutex_unlock(&nacl->lun_entry_mutex);\r\nspin_lock(&lun->lun_deve_lock);\r\nlist_add_tail(&new->lun_link, &lun->lun_deve_list);\r\nspin_unlock(&lun->lun_deve_lock);\r\ntarget_luns_data_has_changed(nacl, new, true);\r\nreturn 0;\r\n}\r\nvoid core_disable_device_list_for_node(\r\nstruct se_lun *lun,\r\nstruct se_dev_entry *orig,\r\nstruct se_node_acl *nacl,\r\nstruct se_portal_group *tpg)\r\n{\r\nstruct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);\r\nspin_lock(&lun->lun_deve_lock);\r\nlist_del(&orig->lun_link);\r\nspin_unlock(&lun->lun_deve_lock);\r\ncore_scsi3_ua_release_all(orig);\r\nhlist_del_rcu(&orig->link);\r\nclear_bit(DEF_PR_REG_ACTIVE, &orig->deve_flags);\r\norig->lun_access_ro = false;\r\norig->creation_time = 0;\r\norig->attach_count--;\r\nkref_put(&orig->pr_kref, target_pr_kref_release);\r\nwait_for_completion(&orig->pr_comp);\r\nrcu_assign_pointer(orig->se_lun, NULL);\r\nrcu_assign_pointer(orig->se_lun_acl, NULL);\r\nkfree_rcu(orig, rcu_head);\r\ncore_scsi3_free_pr_reg_from_nacl(dev, nacl);\r\ntarget_luns_data_has_changed(nacl, NULL, false);\r\n}\r\nvoid core_clear_lun_from_tpg(struct se_lun *lun, struct se_portal_group *tpg)\r\n{\r\nstruct se_node_acl *nacl;\r\nstruct se_dev_entry *deve;\r\nmutex_lock(&tpg->acl_node_mutex);\r\nlist_for_each_entry(nacl, &tpg->acl_node_list, acl_list) {\r\nmutex_lock(&nacl->lun_entry_mutex);\r\nhlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\r\nstruct se_lun *tmp_lun = rcu_dereference_check(deve->se_lun,\r\nlockdep_is_held(&nacl->lun_entry_mutex));\r\nif (lun != tmp_lun)\r\ncontinue;\r\ncore_disable_device_list_for_node(lun, deve, nacl, tpg);\r\n}\r\nmutex_unlock(&nacl->lun_entry_mutex);\r\n}\r\nmutex_unlock(&tpg->acl_node_mutex);\r\n}\r\nint core_alloc_rtpi(struct se_lun *lun, struct se_device *dev)\r\n{\r\nstruct se_lun *tmp;\r\nspin_lock(&dev->se_port_lock);\r\nif (dev->export_count == 0x0000ffff) {\r\npr_warn("Reached dev->dev_port_count =="\r\n" 0x0000ffff\n");\r\nspin_unlock(&dev->se_port_lock);\r\nreturn -ENOSPC;\r\n}\r\nagain:\r\nlun->lun_rtpi = dev->dev_rpti_counter++;\r\nif (!lun->lun_rtpi)\r\ngoto again;\r\nlist_for_each_entry(tmp, &dev->dev_sep_list, lun_dev_link) {\r\nif (lun->lun_rtpi == tmp->lun_rtpi)\r\ngoto again;\r\n}\r\nspin_unlock(&dev->se_port_lock);\r\nreturn 0;\r\n}\r\nstatic void se_release_vpd_for_dev(struct se_device *dev)\r\n{\r\nstruct t10_vpd *vpd, *vpd_tmp;\r\nspin_lock(&dev->t10_wwn.t10_vpd_lock);\r\nlist_for_each_entry_safe(vpd, vpd_tmp,\r\n&dev->t10_wwn.t10_vpd_list, vpd_list) {\r\nlist_del(&vpd->vpd_list);\r\nkfree(vpd);\r\n}\r\nspin_unlock(&dev->t10_wwn.t10_vpd_lock);\r\n}\r\nstatic u32 se_dev_align_max_sectors(u32 max_sectors, u32 block_size)\r\n{\r\nu32 aligned_max_sectors;\r\nu32 alignment;\r\nalignment = max(1ul, PAGE_SIZE / block_size);\r\naligned_max_sectors = rounddown(max_sectors, alignment);\r\nif (max_sectors != aligned_max_sectors)\r\npr_info("Rounding down aligned max_sectors from %u to %u\n",\r\nmax_sectors, aligned_max_sectors);\r\nreturn aligned_max_sectors;\r\n}\r\nint core_dev_add_lun(\r\nstruct se_portal_group *tpg,\r\nstruct se_device *dev,\r\nstruct se_lun *lun)\r\n{\r\nint rc;\r\nrc = core_tpg_add_lun(tpg, lun, false, dev);\r\nif (rc < 0)\r\nreturn rc;\r\npr_debug("%s_TPG[%u]_LUN[%llu] - Activated %s Logical Unit from"\r\n" CORE HBA: %u\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg), lun->unpacked_lun,\r\ntpg->se_tpg_tfo->get_fabric_name(), dev->se_hba->hba_id);\r\nif (tpg->se_tpg_tfo->tpg_check_demo_mode(tpg)) {\r\nstruct se_node_acl *acl;\r\nmutex_lock(&tpg->acl_node_mutex);\r\nlist_for_each_entry(acl, &tpg->acl_node_list, acl_list) {\r\nif (acl->dynamic_node_acl &&\r\n(!tpg->se_tpg_tfo->tpg_check_demo_mode_login_only ||\r\n!tpg->se_tpg_tfo->tpg_check_demo_mode_login_only(tpg))) {\r\ncore_tpg_add_node_to_devs(acl, tpg, lun);\r\n}\r\n}\r\nmutex_unlock(&tpg->acl_node_mutex);\r\n}\r\nreturn 0;\r\n}\r\nvoid core_dev_del_lun(\r\nstruct se_portal_group *tpg,\r\nstruct se_lun *lun)\r\n{\r\npr_debug("%s_TPG[%u]_LUN[%llu] - Deactivating %s Logical Unit from"\r\n" device object\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg), lun->unpacked_lun,\r\ntpg->se_tpg_tfo->get_fabric_name());\r\ncore_tpg_remove_lun(tpg, lun);\r\n}\r\nstruct se_lun_acl *core_dev_init_initiator_node_lun_acl(\r\nstruct se_portal_group *tpg,\r\nstruct se_node_acl *nacl,\r\nu64 mapped_lun,\r\nint *ret)\r\n{\r\nstruct se_lun_acl *lacl;\r\nif (strlen(nacl->initiatorname) >= TRANSPORT_IQN_LEN) {\r\npr_err("%s InitiatorName exceeds maximum size.\n",\r\ntpg->se_tpg_tfo->get_fabric_name());\r\n*ret = -EOVERFLOW;\r\nreturn NULL;\r\n}\r\nlacl = kzalloc(sizeof(struct se_lun_acl), GFP_KERNEL);\r\nif (!lacl) {\r\npr_err("Unable to allocate memory for struct se_lun_acl.\n");\r\n*ret = -ENOMEM;\r\nreturn NULL;\r\n}\r\nlacl->mapped_lun = mapped_lun;\r\nlacl->se_lun_nacl = nacl;\r\nreturn lacl;\r\n}\r\nint core_dev_add_initiator_node_lun_acl(\r\nstruct se_portal_group *tpg,\r\nstruct se_lun_acl *lacl,\r\nstruct se_lun *lun,\r\nbool lun_access_ro)\r\n{\r\nstruct se_node_acl *nacl = lacl->se_lun_nacl;\r\nstruct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);\r\nif (!nacl)\r\nreturn -EINVAL;\r\nif (lun->lun_access_ro)\r\nlun_access_ro = true;\r\nlacl->se_lun = lun;\r\nif (core_enable_device_list_for_node(lun, lacl, lacl->mapped_lun,\r\nlun_access_ro, nacl, tpg) < 0)\r\nreturn -EINVAL;\r\npr_debug("%s_TPG[%hu]_LUN[%llu->%llu] - Added %s ACL for "\r\n" InitiatorNode: %s\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg), lun->unpacked_lun, lacl->mapped_lun,\r\nlun_access_ro ? "RO" : "RW",\r\nnacl->initiatorname);\r\ncore_scsi3_check_aptpl_registration(dev, tpg, lun, nacl,\r\nlacl->mapped_lun);\r\nreturn 0;\r\n}\r\nint core_dev_del_initiator_node_lun_acl(\r\nstruct se_lun *lun,\r\nstruct se_lun_acl *lacl)\r\n{\r\nstruct se_portal_group *tpg = lun->lun_tpg;\r\nstruct se_node_acl *nacl;\r\nstruct se_dev_entry *deve;\r\nnacl = lacl->se_lun_nacl;\r\nif (!nacl)\r\nreturn -EINVAL;\r\nmutex_lock(&nacl->lun_entry_mutex);\r\ndeve = target_nacl_find_deve(nacl, lacl->mapped_lun);\r\nif (deve)\r\ncore_disable_device_list_for_node(lun, deve, nacl, tpg);\r\nmutex_unlock(&nacl->lun_entry_mutex);\r\npr_debug("%s_TPG[%hu]_LUN[%llu] - Removed ACL for"\r\n" InitiatorNode: %s Mapped LUN: %llu\n",\r\ntpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg), lun->unpacked_lun,\r\nnacl->initiatorname, lacl->mapped_lun);\r\nreturn 0;\r\n}\r\nvoid core_dev_free_initiator_node_lun_acl(\r\nstruct se_portal_group *tpg,\r\nstruct se_lun_acl *lacl)\r\n{\r\npr_debug("%s_TPG[%hu] - Freeing ACL for %s InitiatorNode: %s"\r\n" Mapped LUN: %llu\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg),\r\ntpg->se_tpg_tfo->get_fabric_name(),\r\nlacl->se_lun_nacl->initiatorname, lacl->mapped_lun);\r\nkfree(lacl);\r\n}\r\nstatic void scsi_dump_inquiry(struct se_device *dev)\r\n{\r\nstruct t10_wwn *wwn = &dev->t10_wwn;\r\nchar buf[17];\r\nint i, device_type;\r\nfor (i = 0; i < 8; i++)\r\nif (wwn->vendor[i] >= 0x20)\r\nbuf[i] = wwn->vendor[i];\r\nelse\r\nbuf[i] = ' ';\r\nbuf[i] = '\0';\r\npr_debug(" Vendor: %s\n", buf);\r\nfor (i = 0; i < 16; i++)\r\nif (wwn->model[i] >= 0x20)\r\nbuf[i] = wwn->model[i];\r\nelse\r\nbuf[i] = ' ';\r\nbuf[i] = '\0';\r\npr_debug(" Model: %s\n", buf);\r\nfor (i = 0; i < 4; i++)\r\nif (wwn->revision[i] >= 0x20)\r\nbuf[i] = wwn->revision[i];\r\nelse\r\nbuf[i] = ' ';\r\nbuf[i] = '\0';\r\npr_debug(" Revision: %s\n", buf);\r\ndevice_type = dev->transport->get_device_type(dev);\r\npr_debug(" Type: %s ", scsi_device_type(device_type));\r\n}\r\nstruct se_device *target_alloc_device(struct se_hba *hba, const char *name)\r\n{\r\nstruct se_device *dev;\r\nstruct se_lun *xcopy_lun;\r\ndev = hba->backend->ops->alloc_device(hba, name);\r\nif (!dev)\r\nreturn NULL;\r\ndev->dev_link_magic = SE_DEV_LINK_MAGIC;\r\ndev->se_hba = hba;\r\ndev->transport = hba->backend->ops;\r\ndev->prot_length = sizeof(struct t10_pi_tuple);\r\ndev->hba_index = hba->hba_index;\r\nINIT_LIST_HEAD(&dev->dev_list);\r\nINIT_LIST_HEAD(&dev->dev_sep_list);\r\nINIT_LIST_HEAD(&dev->dev_tmr_list);\r\nINIT_LIST_HEAD(&dev->delayed_cmd_list);\r\nINIT_LIST_HEAD(&dev->state_list);\r\nINIT_LIST_HEAD(&dev->qf_cmd_list);\r\nINIT_LIST_HEAD(&dev->g_dev_node);\r\nspin_lock_init(&dev->execute_task_lock);\r\nspin_lock_init(&dev->delayed_cmd_lock);\r\nspin_lock_init(&dev->dev_reservation_lock);\r\nspin_lock_init(&dev->se_port_lock);\r\nspin_lock_init(&dev->se_tmr_lock);\r\nspin_lock_init(&dev->qf_cmd_lock);\r\nsema_init(&dev->caw_sem, 1);\r\nINIT_LIST_HEAD(&dev->t10_wwn.t10_vpd_list);\r\nspin_lock_init(&dev->t10_wwn.t10_vpd_lock);\r\nINIT_LIST_HEAD(&dev->t10_pr.registration_list);\r\nINIT_LIST_HEAD(&dev->t10_pr.aptpl_reg_list);\r\nspin_lock_init(&dev->t10_pr.registration_lock);\r\nspin_lock_init(&dev->t10_pr.aptpl_reg_lock);\r\nINIT_LIST_HEAD(&dev->t10_alua.tg_pt_gps_list);\r\nspin_lock_init(&dev->t10_alua.tg_pt_gps_lock);\r\nINIT_LIST_HEAD(&dev->t10_alua.lba_map_list);\r\nspin_lock_init(&dev->t10_alua.lba_map_lock);\r\ndev->t10_wwn.t10_dev = dev;\r\ndev->t10_alua.t10_dev = dev;\r\ndev->dev_attrib.da_dev = dev;\r\ndev->dev_attrib.emulate_model_alias = DA_EMULATE_MODEL_ALIAS;\r\ndev->dev_attrib.emulate_dpo = 1;\r\ndev->dev_attrib.emulate_fua_write = 1;\r\ndev->dev_attrib.emulate_fua_read = 1;\r\ndev->dev_attrib.emulate_write_cache = DA_EMULATE_WRITE_CACHE;\r\ndev->dev_attrib.emulate_ua_intlck_ctrl = DA_EMULATE_UA_INTLLCK_CTRL;\r\ndev->dev_attrib.emulate_tas = DA_EMULATE_TAS;\r\ndev->dev_attrib.emulate_tpu = DA_EMULATE_TPU;\r\ndev->dev_attrib.emulate_tpws = DA_EMULATE_TPWS;\r\ndev->dev_attrib.emulate_caw = DA_EMULATE_CAW;\r\ndev->dev_attrib.emulate_3pc = DA_EMULATE_3PC;\r\ndev->dev_attrib.pi_prot_type = TARGET_DIF_TYPE0_PROT;\r\ndev->dev_attrib.enforce_pr_isids = DA_ENFORCE_PR_ISIDS;\r\ndev->dev_attrib.force_pr_aptpl = DA_FORCE_PR_APTPL;\r\ndev->dev_attrib.is_nonrot = DA_IS_NONROT;\r\ndev->dev_attrib.emulate_rest_reord = DA_EMULATE_REST_REORD;\r\ndev->dev_attrib.max_unmap_lba_count = DA_MAX_UNMAP_LBA_COUNT;\r\ndev->dev_attrib.max_unmap_block_desc_count =\r\nDA_MAX_UNMAP_BLOCK_DESC_COUNT;\r\ndev->dev_attrib.unmap_granularity = DA_UNMAP_GRANULARITY_DEFAULT;\r\ndev->dev_attrib.unmap_granularity_alignment =\r\nDA_UNMAP_GRANULARITY_ALIGNMENT_DEFAULT;\r\ndev->dev_attrib.unmap_zeroes_data =\r\nDA_UNMAP_ZEROES_DATA_DEFAULT;\r\ndev->dev_attrib.max_write_same_len = DA_MAX_WRITE_SAME_LEN;\r\nxcopy_lun = &dev->xcopy_lun;\r\nrcu_assign_pointer(xcopy_lun->lun_se_dev, dev);\r\ninit_completion(&xcopy_lun->lun_ref_comp);\r\nINIT_LIST_HEAD(&xcopy_lun->lun_deve_list);\r\nINIT_LIST_HEAD(&xcopy_lun->lun_dev_link);\r\nmutex_init(&xcopy_lun->lun_tg_pt_md_mutex);\r\nxcopy_lun->lun_tpg = &xcopy_pt_tpg;\r\nreturn dev;\r\n}\r\nbool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,\r\nstruct request_queue *q)\r\n{\r\nint block_size = queue_logical_block_size(q);\r\nif (!blk_queue_discard(q))\r\nreturn false;\r\nattrib->max_unmap_lba_count =\r\nq->limits.max_discard_sectors >> (ilog2(block_size) - 9);\r\nattrib->max_unmap_block_desc_count = 1;\r\nattrib->unmap_granularity = q->limits.discard_granularity / block_size;\r\nattrib->unmap_granularity_alignment = q->limits.discard_alignment /\r\nblock_size;\r\nattrib->unmap_zeroes_data = q->limits.discard_zeroes_data;\r\nreturn true;\r\n}\r\nsector_t target_to_linux_sector(struct se_device *dev, sector_t lb)\r\n{\r\nswitch (dev->dev_attrib.block_size) {\r\ncase 4096:\r\nreturn lb << 3;\r\ncase 2048:\r\nreturn lb << 2;\r\ncase 1024:\r\nreturn lb << 1;\r\ndefault:\r\nreturn lb;\r\n}\r\n}\r\nint target_configure_device(struct se_device *dev)\r\n{\r\nstruct se_hba *hba = dev->se_hba;\r\nint ret;\r\nif (dev->dev_flags & DF_CONFIGURED) {\r\npr_err("se_dev->se_dev_ptr already set for storage"\r\n" object\n");\r\nreturn -EEXIST;\r\n}\r\nret = dev->transport->configure_device(dev);\r\nif (ret)\r\ngoto out;\r\ndev->dev_attrib.block_size = dev->dev_attrib.hw_block_size;\r\ndev->dev_attrib.queue_depth = dev->dev_attrib.hw_queue_depth;\r\ndev->dev_attrib.hw_max_sectors =\r\nse_dev_align_max_sectors(dev->dev_attrib.hw_max_sectors,\r\ndev->dev_attrib.hw_block_size);\r\ndev->dev_attrib.optimal_sectors = dev->dev_attrib.hw_max_sectors;\r\ndev->dev_index = scsi_get_new_index(SCSI_DEVICE_INDEX);\r\ndev->creation_time = get_jiffies_64();\r\nret = core_setup_alua(dev);\r\nif (ret)\r\ngoto out;\r\ndev->tmr_wq = alloc_workqueue("tmr-%s", WQ_MEM_RECLAIM | WQ_UNBOUND, 1,\r\ndev->transport->name);\r\nif (!dev->tmr_wq) {\r\npr_err("Unable to create tmr workqueue for %s\n",\r\ndev->transport->name);\r\nret = -ENOMEM;\r\ngoto out_free_alua;\r\n}\r\nINIT_WORK(&dev->qf_work_queue, target_qf_do_work);\r\nif (!(dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)) {\r\nstrncpy(&dev->t10_wwn.vendor[0], "LIO-ORG", 8);\r\nstrncpy(&dev->t10_wwn.model[0],\r\ndev->transport->inquiry_prod, 16);\r\nstrncpy(&dev->t10_wwn.revision[0],\r\ndev->transport->inquiry_rev, 4);\r\n}\r\nscsi_dump_inquiry(dev);\r\nspin_lock(&hba->device_lock);\r\nhba->dev_count++;\r\nspin_unlock(&hba->device_lock);\r\nmutex_lock(&g_device_mutex);\r\nlist_add_tail(&dev->g_dev_node, &g_device_list);\r\nmutex_unlock(&g_device_mutex);\r\ndev->dev_flags |= DF_CONFIGURED;\r\nreturn 0;\r\nout_free_alua:\r\ncore_alua_free_lu_gp_mem(dev);\r\nout:\r\nse_release_vpd_for_dev(dev);\r\nreturn ret;\r\n}\r\nvoid target_free_device(struct se_device *dev)\r\n{\r\nstruct se_hba *hba = dev->se_hba;\r\nWARN_ON(!list_empty(&dev->dev_sep_list));\r\nif (dev->dev_flags & DF_CONFIGURED) {\r\ndestroy_workqueue(dev->tmr_wq);\r\nmutex_lock(&g_device_mutex);\r\nlist_del(&dev->g_dev_node);\r\nmutex_unlock(&g_device_mutex);\r\nspin_lock(&hba->device_lock);\r\nhba->dev_count--;\r\nspin_unlock(&hba->device_lock);\r\n}\r\ncore_alua_free_lu_gp_mem(dev);\r\ncore_alua_set_lba_map(dev, NULL, 0, 0);\r\ncore_scsi3_free_all_registrations(dev);\r\nse_release_vpd_for_dev(dev);\r\nif (dev->transport->free_prot)\r\ndev->transport->free_prot(dev);\r\ndev->transport->free_device(dev);\r\n}\r\nint core_dev_setup_virtual_lun0(void)\r\n{\r\nstruct se_hba *hba;\r\nstruct se_device *dev;\r\nchar buf[] = "rd_pages=8,rd_nullio=1";\r\nint ret;\r\nhba = core_alloc_hba("rd_mcp", 0, HBA_FLAGS_INTERNAL_USE);\r\nif (IS_ERR(hba))\r\nreturn PTR_ERR(hba);\r\ndev = target_alloc_device(hba, "virt_lun0");\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto out_free_hba;\r\n}\r\nhba->backend->ops->set_configfs_dev_params(dev, buf, sizeof(buf));\r\nret = target_configure_device(dev);\r\nif (ret)\r\ngoto out_free_se_dev;\r\nlun0_hba = hba;\r\ng_lun0_dev = dev;\r\nreturn 0;\r\nout_free_se_dev:\r\ntarget_free_device(dev);\r\nout_free_hba:\r\ncore_delete_hba(hba);\r\nreturn ret;\r\n}\r\nvoid core_dev_release_virtual_lun0(void)\r\n{\r\nstruct se_hba *hba = lun0_hba;\r\nif (!hba)\r\nreturn;\r\nif (g_lun0_dev)\r\ntarget_free_device(g_lun0_dev);\r\ncore_delete_hba(hba);\r\n}\r\nsense_reason_t\r\npassthrough_parse_cdb(struct se_cmd *cmd,\r\nsense_reason_t (*exec_cmd)(struct se_cmd *cmd))\r\n{\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nswitch (cdb[0]) {\r\ncase READ_10:\r\ncase READ_12:\r\ncase READ_16:\r\ncase SEND_DIAGNOSTIC:\r\ncase VERIFY:\r\ncase VERIFY_16:\r\ncase WRITE_VERIFY:\r\ncase WRITE_VERIFY_12:\r\ncase MAINTENANCE_IN:\r\nbreak;\r\ndefault:\r\ncdb[1] &= 0x1f;\r\nbreak;\r\n}\r\nif (cdb[0] == REPORT_LUNS) {\r\ncmd->execute_cmd = spc_emulate_report_luns;\r\nreturn TCM_NO_SENSE;\r\n}\r\nswitch (cdb[0]) {\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_12:\r\ncase READ_16:\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_12:\r\ncase WRITE_16:\r\ncase WRITE_VERIFY:\r\ncase WRITE_VERIFY_12:\r\ncase 0x8e:\r\ncase COMPARE_AND_WRITE:\r\ncase XDWRITEREAD_10:\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\nbreak;\r\ncase VARIABLE_LENGTH_CMD:\r\nswitch (get_unaligned_be16(&cdb[8])) {\r\ncase READ_32:\r\ncase WRITE_32:\r\ncase 0x0c:\r\ncase XDWRITEREAD_32:\r\ncmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\r\nbreak;\r\n}\r\n}\r\ncmd->execute_cmd = exec_cmd;\r\nreturn TCM_NO_SENSE;\r\n}
