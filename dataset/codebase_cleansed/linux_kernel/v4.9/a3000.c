static irqreturn_t a3000_intr(int irq, void *data)\r\n{\r\nstruct Scsi_Host *instance = data;\r\nstruct a3000_hostdata *hdata = shost_priv(instance);\r\nunsigned int status = hdata->regs->ISTR;\r\nunsigned long flags;\r\nif (!(status & ISTR_INT_P))\r\nreturn IRQ_NONE;\r\nif (status & ISTR_INTS) {\r\nspin_lock_irqsave(instance->host_lock, flags);\r\nwd33c93_intr(instance);\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\npr_warning("Non-serviced A3000 SCSI-interrupt? ISTR = %02x\n", status);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int dma_setup(struct scsi_cmnd *cmd, int dir_in)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct a3000_hostdata *hdata = shost_priv(instance);\r\nstruct WD33C93_hostdata *wh = &hdata->wh;\r\nstruct a3000_scsiregs *regs = hdata->regs;\r\nunsigned short cntr = CNTR_PDMD | CNTR_INTEN;\r\nunsigned long addr = virt_to_bus(cmd->SCp.ptr);\r\nif (addr & A3000_XFER_MASK) {\r\nwh->dma_bounce_len = (cmd->SCp.this_residual + 511) & ~0x1ff;\r\nwh->dma_bounce_buffer = kmalloc(wh->dma_bounce_len,\r\nGFP_KERNEL);\r\nif (!wh->dma_bounce_buffer) {\r\nwh->dma_bounce_len = 0;\r\nreturn 1;\r\n}\r\nif (!dir_in) {\r\nmemcpy(wh->dma_bounce_buffer, cmd->SCp.ptr,\r\ncmd->SCp.this_residual);\r\n}\r\naddr = virt_to_bus(wh->dma_bounce_buffer);\r\n}\r\nif (!dir_in)\r\ncntr |= CNTR_DDIR;\r\nwh->dma_dir = dir_in;\r\nregs->CNTR = cntr;\r\nregs->ACR = addr;\r\nif (dir_in) {\r\ncache_clear(addr, cmd->SCp.this_residual);\r\n} else {\r\ncache_push(addr, cmd->SCp.this_residual);\r\n}\r\nmb();\r\nregs->ST_DMA = 1;\r\nmb();\r\nreturn 0;\r\n}\r\nstatic void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,\r\nint status)\r\n{\r\nstruct a3000_hostdata *hdata = shost_priv(instance);\r\nstruct WD33C93_hostdata *wh = &hdata->wh;\r\nstruct a3000_scsiregs *regs = hdata->regs;\r\nunsigned short cntr = CNTR_PDMD;\r\nif (!wh->dma_dir)\r\ncntr |= CNTR_DDIR;\r\nregs->CNTR = cntr;\r\nmb();\r\nif (wh->dma_dir) {\r\nregs->FLUSH = 1;\r\nmb();\r\nwhile (!(regs->ISTR & ISTR_FE_FLG))\r\nbarrier();\r\nmb();\r\n}\r\nregs->CINT = 1;\r\nregs->SP_DMA = 1;\r\nmb();\r\nregs->CNTR = CNTR_PDMD | CNTR_INTEN;\r\nmb();\r\nif (status && wh->dma_bounce_buffer) {\r\nif (SCpnt) {\r\nif (wh->dma_dir && SCpnt)\r\nmemcpy(SCpnt->SCp.ptr, wh->dma_bounce_buffer,\r\nSCpnt->SCp.this_residual);\r\nkfree(wh->dma_bounce_buffer);\r\nwh->dma_bounce_buffer = NULL;\r\nwh->dma_bounce_len = 0;\r\n} else {\r\nkfree(wh->dma_bounce_buffer);\r\nwh->dma_bounce_buffer = NULL;\r\nwh->dma_bounce_len = 0;\r\n}\r\n}\r\n}\r\nstatic int a3000_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nspin_lock_irq(instance->host_lock);\r\nwd33c93_host_reset(cmd);\r\nspin_unlock_irq(instance->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int __init amiga_a3000_scsi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct Scsi_Host *instance;\r\nint error;\r\nstruct a3000_scsiregs *regs;\r\nwd33c93_regs wdregs;\r\nstruct a3000_hostdata *hdata;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nif (!request_mem_region(res->start, resource_size(res), "wd33c93"))\r\nreturn -EBUSY;\r\ninstance = scsi_host_alloc(&amiga_a3000_scsi_template,\r\nsizeof(struct a3000_hostdata));\r\nif (!instance) {\r\nerror = -ENOMEM;\r\ngoto fail_alloc;\r\n}\r\ninstance->irq = IRQ_AMIGA_PORTS;\r\nregs = ZTWO_VADDR(res->start);\r\nregs->DAWR = DAWR_A3000;\r\nwdregs.SASR = &regs->SASR;\r\nwdregs.SCMD = &regs->SCMD;\r\nhdata = shost_priv(instance);\r\nhdata->wh.no_sync = 0xff;\r\nhdata->wh.fast = 0;\r\nhdata->wh.dma_mode = CTRL_DMA;\r\nhdata->regs = regs;\r\nwd33c93_init(instance, wdregs, dma_setup, dma_stop, WD33C93_FS_12_15);\r\nerror = request_irq(IRQ_AMIGA_PORTS, a3000_intr, IRQF_SHARED,\r\n"A3000 SCSI", instance);\r\nif (error)\r\ngoto fail_irq;\r\nregs->CNTR = CNTR_PDMD | CNTR_INTEN;\r\nerror = scsi_add_host(instance, NULL);\r\nif (error)\r\ngoto fail_host;\r\nplatform_set_drvdata(pdev, instance);\r\nscsi_scan_host(instance);\r\nreturn 0;\r\nfail_host:\r\nfree_irq(IRQ_AMIGA_PORTS, instance);\r\nfail_irq:\r\nscsi_host_put(instance);\r\nfail_alloc:\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn error;\r\n}\r\nstatic int __exit amiga_a3000_scsi_remove(struct platform_device *pdev)\r\n{\r\nstruct Scsi_Host *instance = platform_get_drvdata(pdev);\r\nstruct a3000_hostdata *hdata = shost_priv(instance);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhdata->regs->CNTR = 0;\r\nscsi_remove_host(instance);\r\nfree_irq(IRQ_AMIGA_PORTS, instance);\r\nscsi_host_put(instance);\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn 0;\r\n}
