static inline struct device *_vop_dev(struct _vop_vdev *vdev)\r\n{\r\nreturn vdev->vdev.dev.parent;\r\n}\r\nstatic inline unsigned _vop_desc_size(struct mic_device_desc __iomem *desc)\r\n{\r\nreturn sizeof(*desc)\r\n+ ioread8(&desc->num_vq) * sizeof(struct mic_vqconfig)\r\n+ ioread8(&desc->feature_len) * 2\r\n+ ioread8(&desc->config_len);\r\n}\r\nstatic inline struct mic_vqconfig __iomem *\r\n_vop_vq_config(struct mic_device_desc __iomem *desc)\r\n{\r\nreturn (struct mic_vqconfig __iomem *)(desc + 1);\r\n}\r\nstatic inline u8 __iomem *\r\n_vop_vq_features(struct mic_device_desc __iomem *desc)\r\n{\r\nreturn (u8 __iomem *)(_vop_vq_config(desc) + ioread8(&desc->num_vq));\r\n}\r\nstatic inline u8 __iomem *\r\n_vop_vq_configspace(struct mic_device_desc __iomem *desc)\r\n{\r\nreturn _vop_vq_features(desc) + ioread8(&desc->feature_len) * 2;\r\n}\r\nstatic inline unsigned\r\n_vop_total_desc_size(struct mic_device_desc __iomem *desc)\r\n{\r\nreturn _vop_aligned_desc_size(desc) + sizeof(struct mic_device_ctrl);\r\n}\r\nstatic u64 vop_get_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i, bits;\r\nu32 features = 0;\r\nstruct mic_device_desc __iomem *desc = to_vopvdev(vdev)->desc;\r\nu8 __iomem *in_features = _vop_vq_features(desc);\r\nint feature_len = ioread8(&desc->feature_len);\r\nbits = min_t(unsigned, feature_len, sizeof(vdev->features)) * 8;\r\nfor (i = 0; i < bits; i++)\r\nif (ioread8(&in_features[i / 8]) & (BIT(i % 8)))\r\nfeatures |= BIT(i);\r\nreturn features;\r\n}\r\nstatic int vop_finalize_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i, bits;\r\nstruct mic_device_desc __iomem *desc = to_vopvdev(vdev)->desc;\r\nu8 feature_len = ioread8(&desc->feature_len);\r\nu8 __iomem *out_features =\r\n_vop_vq_features(desc) + feature_len;\r\nvring_transport_features(vdev);\r\nmemset_io(out_features, 0, feature_len);\r\nbits = min_t(unsigned, feature_len,\r\nsizeof(vdev->features)) * 8;\r\nfor (i = 0; i < bits; i++) {\r\nif (__virtio_test_bit(vdev, i))\r\niowrite8(ioread8(&out_features[i / 8]) | (1 << (i % 8)),\r\n&out_features[i / 8]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vop_get(struct virtio_device *vdev, unsigned int offset,\r\nvoid *buf, unsigned len)\r\n{\r\nstruct mic_device_desc __iomem *desc = to_vopvdev(vdev)->desc;\r\nif (offset + len > ioread8(&desc->config_len))\r\nreturn;\r\nmemcpy_fromio(buf, _vop_vq_configspace(desc) + offset, len);\r\n}\r\nstatic void vop_set(struct virtio_device *vdev, unsigned int offset,\r\nconst void *buf, unsigned len)\r\n{\r\nstruct mic_device_desc __iomem *desc = to_vopvdev(vdev)->desc;\r\nif (offset + len > ioread8(&desc->config_len))\r\nreturn;\r\nmemcpy_toio(_vop_vq_configspace(desc) + offset, buf, len);\r\n}\r\nstatic u8 vop_get_status(struct virtio_device *vdev)\r\n{\r\nreturn ioread8(&to_vopvdev(vdev)->desc->status);\r\n}\r\nstatic void vop_set_status(struct virtio_device *dev, u8 status)\r\n{\r\nstruct _vop_vdev *vdev = to_vopvdev(dev);\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nif (!status)\r\nreturn;\r\niowrite8(status, &vdev->desc->status);\r\nvpdev->hw_ops->send_intr(vpdev, vdev->c2h_vdev_db);\r\n}\r\nstatic void vop_reset_inform_host(struct virtio_device *dev)\r\n{\r\nstruct _vop_vdev *vdev = to_vopvdev(dev);\r\nstruct mic_device_ctrl __iomem *dc = vdev->dc;\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nint retry;\r\niowrite8(0, &dc->host_ack);\r\niowrite8(1, &dc->vdev_reset);\r\nvpdev->hw_ops->send_intr(vpdev, vdev->c2h_vdev_db);\r\nfor (retry = 100; retry--;) {\r\nif (ioread8(&dc->host_ack))\r\nbreak;\r\nmsleep(100);\r\n};\r\ndev_dbg(_vop_dev(vdev), "%s: retry: %d\n", __func__, retry);\r\niowrite8(0, &vdev->desc->status);\r\n}\r\nstatic void vop_reset(struct virtio_device *dev)\r\n{\r\nstruct _vop_vdev *vdev = to_vopvdev(dev);\r\ndev_dbg(_vop_dev(vdev), "%s: virtio id %d\n",\r\n__func__, dev->id.device);\r\nvop_reset_inform_host(dev);\r\ncomplete_all(&vdev->reset_done);\r\n}\r\nstatic bool vop_notify(struct virtqueue *vq)\r\n{\r\nstruct _vop_vdev *vdev = vq->priv;\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nvpdev->hw_ops->send_intr(vpdev, vdev->c2h_vdev_db);\r\nreturn true;\r\n}\r\nstatic void vop_del_vq(struct virtqueue *vq, int n)\r\n{\r\nstruct _vop_vdev *vdev = to_vopvdev(vq->vdev);\r\nstruct vring *vr = (struct vring *)(vq + 1);\r\nstruct vop_device *vpdev = vdev->vpdev;\r\ndma_unmap_single(&vpdev->dev, vdev->used[n],\r\nvdev->used_size[n], DMA_BIDIRECTIONAL);\r\nfree_pages((unsigned long)vr->used, get_order(vdev->used_size[n]));\r\nvring_del_virtqueue(vq);\r\nvpdev->hw_ops->iounmap(vpdev, vdev->vr[n]);\r\nvdev->vr[n] = NULL;\r\n}\r\nstatic void vop_del_vqs(struct virtio_device *dev)\r\n{\r\nstruct _vop_vdev *vdev = to_vopvdev(dev);\r\nstruct virtqueue *vq, *n;\r\nint idx = 0;\r\ndev_dbg(_vop_dev(vdev), "%s\n", __func__);\r\nlist_for_each_entry_safe(vq, n, &dev->vqs, list)\r\nvop_del_vq(vq, idx++);\r\n}\r\nstatic struct virtqueue *vop_find_vq(struct virtio_device *dev,\r\nunsigned index,\r\nvoid (*callback)(struct virtqueue *vq),\r\nconst char *name)\r\n{\r\nstruct _vop_vdev *vdev = to_vopvdev(dev);\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nstruct mic_vqconfig __iomem *vqconfig;\r\nstruct mic_vqconfig config;\r\nstruct virtqueue *vq;\r\nvoid __iomem *va;\r\nstruct _mic_vring_info __iomem *info;\r\nvoid *used;\r\nint vr_size, _vr_size, err, magic;\r\nstruct vring *vr;\r\nu8 type = ioread8(&vdev->desc->type);\r\nif (index >= ioread8(&vdev->desc->num_vq))\r\nreturn ERR_PTR(-ENOENT);\r\nif (!name)\r\nreturn ERR_PTR(-ENOENT);\r\nvqconfig = _vop_vq_config(vdev->desc) + index;\r\nmemcpy_fromio(&config, vqconfig, sizeof(config));\r\n_vr_size = vring_size(le16_to_cpu(config.num), MIC_VIRTIO_RING_ALIGN);\r\nvr_size = PAGE_ALIGN(_vr_size + sizeof(struct _mic_vring_info));\r\nva = vpdev->hw_ops->ioremap(vpdev, le64_to_cpu(config.address),\r\nvr_size);\r\nif (!va)\r\nreturn ERR_PTR(-ENOMEM);\r\nvdev->vr[index] = va;\r\nmemset_io(va, 0x0, _vr_size);\r\nvq = vring_new_virtqueue(\r\nindex,\r\nle16_to_cpu(config.num), MIC_VIRTIO_RING_ALIGN,\r\ndev,\r\nfalse,\r\n(void __force *)va, vop_notify, callback, name);\r\nif (!vq) {\r\nerr = -ENOMEM;\r\ngoto unmap;\r\n}\r\ninfo = va + _vr_size;\r\nmagic = ioread32(&info->magic);\r\nif (WARN(magic != MIC_MAGIC + type + index, "magic mismatch")) {\r\nerr = -EIO;\r\ngoto unmap;\r\n}\r\nvdev->used_size[index] = PAGE_ALIGN(sizeof(__u16) * 3 +\r\nsizeof(struct vring_used_elem) *\r\nle16_to_cpu(config.num));\r\nused = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\r\nget_order(vdev->used_size[index]));\r\nif (!used) {\r\nerr = -ENOMEM;\r\ndev_err(_vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto del_vq;\r\n}\r\nvdev->used[index] = dma_map_single(&vpdev->dev, used,\r\nvdev->used_size[index],\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(&vpdev->dev, vdev->used[index])) {\r\nerr = -ENOMEM;\r\ndev_err(_vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto free_used;\r\n}\r\nwriteq(vdev->used[index], &vqconfig->used_address);\r\nvr = (struct vring *)(vq + 1);\r\nvr->used = used;\r\nvq->priv = vdev;\r\nreturn vq;\r\nfree_used:\r\nfree_pages((unsigned long)used,\r\nget_order(vdev->used_size[index]));\r\ndel_vq:\r\nvring_del_virtqueue(vq);\r\nunmap:\r\nvpdev->hw_ops->iounmap(vpdev, vdev->vr[index]);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int vop_find_vqs(struct virtio_device *dev, unsigned nvqs,\r\nstruct virtqueue *vqs[],\r\nvq_callback_t *callbacks[],\r\nconst char * const names[])\r\n{\r\nstruct _vop_vdev *vdev = to_vopvdev(dev);\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nstruct mic_device_ctrl __iomem *dc = vdev->dc;\r\nint i, err, retry;\r\nif (nvqs > ioread8(&vdev->desc->num_vq))\r\nreturn -ENOENT;\r\nfor (i = 0; i < nvqs; ++i) {\r\ndev_dbg(_vop_dev(vdev), "%s: %d: %s\n",\r\n__func__, i, names[i]);\r\nvqs[i] = vop_find_vq(dev, i, callbacks[i], names[i]);\r\nif (IS_ERR(vqs[i])) {\r\nerr = PTR_ERR(vqs[i]);\r\ngoto error;\r\n}\r\n}\r\niowrite8(1, &dc->used_address_updated);\r\nvpdev->hw_ops->send_intr(vpdev, vdev->c2h_vdev_db);\r\nfor (retry = 100; --retry;) {\r\nif (!ioread8(&dc->used_address_updated))\r\nbreak;\r\nmsleep(100);\r\n};\r\ndev_dbg(_vop_dev(vdev), "%s: retry: %d\n", __func__, retry);\r\nif (!retry) {\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nvop_del_vqs(dev);\r\nreturn err;\r\n}\r\nstatic irqreturn_t vop_virtio_intr_handler(int irq, void *data)\r\n{\r\nstruct _vop_vdev *vdev = data;\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nstruct virtqueue *vq;\r\nvpdev->hw_ops->ack_interrupt(vpdev, vdev->h2c_vdev_db);\r\nlist_for_each_entry(vq, &vdev->vdev.vqs, list)\r\nvring_interrupt(0, vq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void vop_virtio_release_dev(struct device *_d)\r\n{\r\n}\r\nstatic int _vop_add_device(struct mic_device_desc __iomem *d,\r\nunsigned int offset, struct vop_device *vpdev,\r\nint dnode)\r\n{\r\nstruct _vop_vdev *vdev;\r\nint ret;\r\nu8 type = ioread8(&d->type);\r\nvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\r\nif (!vdev)\r\nreturn -ENOMEM;\r\nvdev->vpdev = vpdev;\r\nvdev->vdev.dev.parent = &vpdev->dev;\r\nvdev->vdev.dev.release = vop_virtio_release_dev;\r\nvdev->vdev.id.device = type;\r\nvdev->vdev.config = &vop_vq_config_ops;\r\nvdev->desc = d;\r\nvdev->dc = (void __iomem *)d + _vop_aligned_desc_size(d);\r\nvdev->dnode = dnode;\r\nvdev->vdev.priv = (void *)(u64)dnode;\r\ninit_completion(&vdev->reset_done);\r\nvdev->h2c_vdev_db = vpdev->hw_ops->next_db(vpdev);\r\nvdev->virtio_cookie = vpdev->hw_ops->request_irq(vpdev,\r\nvop_virtio_intr_handler, "virtio intr",\r\nvdev, vdev->h2c_vdev_db);\r\nif (IS_ERR(vdev->virtio_cookie)) {\r\nret = PTR_ERR(vdev->virtio_cookie);\r\ngoto kfree;\r\n}\r\niowrite8((u8)vdev->h2c_vdev_db, &vdev->dc->h2c_vdev_db);\r\nvdev->c2h_vdev_db = ioread8(&vdev->dc->c2h_vdev_db);\r\nret = register_virtio_device(&vdev->vdev);\r\nif (ret) {\r\ndev_err(_vop_dev(vdev),\r\n"Failed to register vop device %u type %u\n",\r\noffset, type);\r\ngoto free_irq;\r\n}\r\nwriteq((u64)vdev, &vdev->dc->vdev);\r\ndev_dbg(_vop_dev(vdev), "%s: registered vop device %u type %u vdev %p\n",\r\n__func__, offset, type, vdev);\r\nreturn 0;\r\nfree_irq:\r\nvpdev->hw_ops->free_irq(vpdev, vdev->virtio_cookie, vdev);\r\nkfree:\r\nkfree(vdev);\r\nreturn ret;\r\n}\r\nstatic int vop_match_desc(struct device *dev, void *data)\r\n{\r\nstruct virtio_device *_dev = dev_to_virtio(dev);\r\nstruct _vop_vdev *vdev = to_vopvdev(_dev);\r\nreturn vdev->desc == (void __iomem *)data;\r\n}\r\nstatic void _vop_handle_config_change(struct mic_device_desc __iomem *d,\r\nunsigned int offset,\r\nstruct vop_device *vpdev)\r\n{\r\nstruct mic_device_ctrl __iomem *dc\r\n= (void __iomem *)d + _vop_aligned_desc_size(d);\r\nstruct _vop_vdev *vdev = (struct _vop_vdev *)readq(&dc->vdev);\r\nif (ioread8(&dc->config_change) != MIC_VIRTIO_PARAM_CONFIG_CHANGED)\r\nreturn;\r\ndev_dbg(&vpdev->dev, "%s %d\n", __func__, __LINE__);\r\nvirtio_config_changed(&vdev->vdev);\r\niowrite8(1, &dc->guest_ack);\r\n}\r\nstatic int _vop_remove_device(struct mic_device_desc __iomem *d,\r\nunsigned int offset, struct vop_device *vpdev)\r\n{\r\nstruct mic_device_ctrl __iomem *dc\r\n= (void __iomem *)d + _vop_aligned_desc_size(d);\r\nstruct _vop_vdev *vdev = (struct _vop_vdev *)readq(&dc->vdev);\r\nu8 status;\r\nint ret = -1;\r\nif (ioread8(&dc->config_change) == MIC_VIRTIO_PARAM_DEV_REMOVE) {\r\ndev_dbg(&vpdev->dev,\r\n"%s %d config_change %d type %d vdev %p\n",\r\n__func__, __LINE__,\r\nioread8(&dc->config_change), ioread8(&d->type), vdev);\r\nstatus = ioread8(&d->status);\r\nreinit_completion(&vdev->reset_done);\r\nunregister_virtio_device(&vdev->vdev);\r\nvpdev->hw_ops->free_irq(vpdev, vdev->virtio_cookie, vdev);\r\niowrite8(-1, &dc->h2c_vdev_db);\r\nif (status & VIRTIO_CONFIG_S_DRIVER_OK)\r\nwait_for_completion(&vdev->reset_done);\r\nkfree(vdev);\r\niowrite8(1, &dc->guest_ack);\r\ndev_dbg(&vpdev->dev, "%s %d guest_ack %d\n",\r\n__func__, __LINE__, ioread8(&dc->guest_ack));\r\niowrite8(-1, &d->type);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void _vop_scan_devices(void __iomem *dp, struct vop_device *vpdev,\r\nbool remove, int dnode)\r\n{\r\ns8 type;\r\nunsigned int i;\r\nstruct mic_device_desc __iomem *d;\r\nstruct mic_device_ctrl __iomem *dc;\r\nstruct device *dev;\r\nint ret;\r\nfor (i = sizeof(struct mic_bootparam);\r\ni < MIC_DP_SIZE; i += _vop_total_desc_size(d)) {\r\nd = dp + i;\r\ndc = (void __iomem *)d + _vop_aligned_desc_size(d);\r\nrmb();\r\ntype = ioread8(&d->type);\r\nif (type == 0)\r\nbreak;\r\nif (type == -1)\r\ncontinue;\r\ndev = device_find_child(&vpdev->dev, (void __force *)d,\r\nvop_match_desc);\r\nif (dev) {\r\nif (remove)\r\niowrite8(MIC_VIRTIO_PARAM_DEV_REMOVE,\r\n&dc->config_change);\r\nput_device(dev);\r\n_vop_handle_config_change(d, i, vpdev);\r\nret = _vop_remove_device(d, i, vpdev);\r\nif (remove) {\r\niowrite8(0, &dc->config_change);\r\niowrite8(0, &dc->guest_ack);\r\n}\r\ncontinue;\r\n}\r\ndev_dbg(&vpdev->dev, "%s %d Adding new virtio device %p\n",\r\n__func__, __LINE__, d);\r\nif (!remove)\r\n_vop_add_device(d, i, vpdev, dnode);\r\n}\r\n}\r\nstatic void vop_scan_devices(struct vop_info *vi,\r\nstruct vop_device *vpdev, bool remove)\r\n{\r\nvoid __iomem *dp = vpdev->hw_ops->get_remote_dp(vpdev);\r\nif (!dp)\r\nreturn;\r\nmutex_lock(&vi->vop_mutex);\r\n_vop_scan_devices(dp, vpdev, remove, vpdev->dnode);\r\nmutex_unlock(&vi->vop_mutex);\r\n}\r\nstatic void vop_hotplug_devices(struct work_struct *work)\r\n{\r\nstruct vop_info *vi = container_of(work, struct vop_info,\r\nhotplug_work);\r\nvop_scan_devices(vi, vi->vpdev, !REMOVE_DEVICES);\r\n}\r\nstatic irqreturn_t vop_extint_handler(int irq, void *data)\r\n{\r\nstruct vop_info *vi = data;\r\nstruct mic_bootparam __iomem *bp;\r\nstruct vop_device *vpdev = vi->vpdev;\r\nbp = vpdev->hw_ops->get_remote_dp(vpdev);\r\ndev_dbg(&vpdev->dev, "%s %d hotplug work\n",\r\n__func__, __LINE__);\r\nvpdev->hw_ops->ack_interrupt(vpdev, ioread8(&bp->h2c_config_db));\r\nschedule_work(&vi->hotplug_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vop_driver_probe(struct vop_device *vpdev)\r\n{\r\nstruct vop_info *vi;\r\nint rc;\r\nvi = kzalloc(sizeof(*vi), GFP_KERNEL);\r\nif (!vi) {\r\nrc = -ENOMEM;\r\ngoto exit;\r\n}\r\ndev_set_drvdata(&vpdev->dev, vi);\r\nvi->vpdev = vpdev;\r\nmutex_init(&vi->vop_mutex);\r\nINIT_WORK(&vi->hotplug_work, vop_hotplug_devices);\r\nif (vpdev->dnode) {\r\nrc = vop_host_init(vi);\r\nif (rc < 0)\r\ngoto free;\r\n} else {\r\nstruct mic_bootparam __iomem *bootparam;\r\nvop_scan_devices(vi, vpdev, !REMOVE_DEVICES);\r\nvi->h2c_config_db = vpdev->hw_ops->next_db(vpdev);\r\nvi->cookie = vpdev->hw_ops->request_irq(vpdev,\r\nvop_extint_handler,\r\n"virtio_config_intr",\r\nvi, vi->h2c_config_db);\r\nif (IS_ERR(vi->cookie)) {\r\nrc = PTR_ERR(vi->cookie);\r\ngoto free;\r\n}\r\nbootparam = vpdev->hw_ops->get_remote_dp(vpdev);\r\niowrite8(vi->h2c_config_db, &bootparam->h2c_config_db);\r\n}\r\nvop_init_debugfs(vi);\r\nreturn 0;\r\nfree:\r\nkfree(vi);\r\nexit:\r\nreturn rc;\r\n}\r\nstatic void vop_driver_remove(struct vop_device *vpdev)\r\n{\r\nstruct vop_info *vi = dev_get_drvdata(&vpdev->dev);\r\nif (vpdev->dnode) {\r\nvop_host_uninit(vi);\r\n} else {\r\nstruct mic_bootparam __iomem *bootparam =\r\nvpdev->hw_ops->get_remote_dp(vpdev);\r\nif (bootparam)\r\niowrite8(-1, &bootparam->h2c_config_db);\r\nvpdev->hw_ops->free_irq(vpdev, vi->cookie, vi);\r\nflush_work(&vi->hotplug_work);\r\nvop_scan_devices(vi, vpdev, REMOVE_DEVICES);\r\n}\r\nvop_exit_debugfs(vi);\r\nkfree(vi);\r\n}
