static void nvmet_execute_prop_set(struct nvmet_req *req)\r\n{\r\nu16 status = 0;\r\nif (!(req->cmd->prop_set.attrib & 1)) {\r\nu64 val = le64_to_cpu(req->cmd->prop_set.value);\r\nswitch (le32_to_cpu(req->cmd->prop_set.offset)) {\r\ncase NVME_REG_CC:\r\nnvmet_update_cc(req->sq->ctrl, val);\r\nbreak;\r\ndefault:\r\nstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\r\nbreak;\r\n}\r\n} else {\r\nstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\r\n}\r\nnvmet_req_complete(req, status);\r\n}\r\nstatic void nvmet_execute_prop_get(struct nvmet_req *req)\r\n{\r\nstruct nvmet_ctrl *ctrl = req->sq->ctrl;\r\nu16 status = 0;\r\nu64 val = 0;\r\nif (req->cmd->prop_get.attrib & 1) {\r\nswitch (le32_to_cpu(req->cmd->prop_get.offset)) {\r\ncase NVME_REG_CAP:\r\nval = ctrl->cap;\r\nbreak;\r\ndefault:\r\nstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\r\nbreak;\r\n}\r\n} else {\r\nswitch (le32_to_cpu(req->cmd->prop_get.offset)) {\r\ncase NVME_REG_VS:\r\nval = ctrl->subsys->ver;\r\nbreak;\r\ncase NVME_REG_CC:\r\nval = ctrl->cc;\r\nbreak;\r\ncase NVME_REG_CSTS:\r\nval = ctrl->csts;\r\nbreak;\r\ndefault:\r\nstatus = NVME_SC_INVALID_FIELD | NVME_SC_DNR;\r\nbreak;\r\n}\r\n}\r\nreq->rsp->result64 = cpu_to_le64(val);\r\nnvmet_req_complete(req, status);\r\n}\r\nint nvmet_parse_fabrics_cmd(struct nvmet_req *req)\r\n{\r\nstruct nvme_command *cmd = req->cmd;\r\nreq->ns = NULL;\r\nswitch (cmd->fabrics.fctype) {\r\ncase nvme_fabrics_type_property_set:\r\nreq->data_len = 0;\r\nreq->execute = nvmet_execute_prop_set;\r\nbreak;\r\ncase nvme_fabrics_type_property_get:\r\nreq->data_len = 0;\r\nreq->execute = nvmet_execute_prop_get;\r\nbreak;\r\ndefault:\r\npr_err("received unknown capsule type 0x%x\n",\r\ncmd->fabrics.fctype);\r\nreturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 nvmet_install_queue(struct nvmet_ctrl *ctrl, struct nvmet_req *req)\r\n{\r\nstruct nvmf_connect_command *c = &req->cmd->connect;\r\nu16 qid = le16_to_cpu(c->qid);\r\nu16 sqsize = le16_to_cpu(c->sqsize);\r\nstruct nvmet_ctrl *old;\r\nold = cmpxchg(&req->sq->ctrl, NULL, ctrl);\r\nif (old) {\r\npr_warn("queue already connected!\n");\r\nreturn NVME_SC_CONNECT_CTRL_BUSY | NVME_SC_DNR;\r\n}\r\nnvmet_cq_setup(ctrl, req->cq, qid, sqsize);\r\nnvmet_sq_setup(ctrl, req->sq, qid, sqsize);\r\nreturn 0;\r\n}\r\nstatic void nvmet_execute_admin_connect(struct nvmet_req *req)\r\n{\r\nstruct nvmf_connect_command *c = &req->cmd->connect;\r\nstruct nvmf_connect_data *d;\r\nstruct nvmet_ctrl *ctrl = NULL;\r\nu16 status = 0;\r\nd = kmap(sg_page(req->sg)) + req->sg->offset;\r\nreq->rsp->result = 0;\r\nif (c->recfmt != 0) {\r\npr_warn("invalid connect version (%d).\n",\r\nle16_to_cpu(c->recfmt));\r\nstatus = NVME_SC_CONNECT_FORMAT | NVME_SC_DNR;\r\ngoto out;\r\n}\r\nif (unlikely(d->cntlid != cpu_to_le16(0xffff))) {\r\npr_warn("connect attempt for invalid controller ID %#x\n",\r\nd->cntlid);\r\nstatus = NVME_SC_CONNECT_INVALID_PARAM | NVME_SC_DNR;\r\nreq->rsp->result = IPO_IATTR_CONNECT_DATA(cntlid);\r\ngoto out;\r\n}\r\nstatus = nvmet_alloc_ctrl(d->subsysnqn, d->hostnqn, req,\r\nle32_to_cpu(c->kato), &ctrl);\r\nif (status)\r\ngoto out;\r\nstatus = nvmet_install_queue(ctrl, req);\r\nif (status) {\r\nnvmet_ctrl_put(ctrl);\r\ngoto out;\r\n}\r\npr_info("creating controller %d for NQN %s.\n",\r\nctrl->cntlid, ctrl->hostnqn);\r\nreq->rsp->result16 = cpu_to_le16(ctrl->cntlid);\r\nout:\r\nkunmap(sg_page(req->sg));\r\nnvmet_req_complete(req, status);\r\n}\r\nstatic void nvmet_execute_io_connect(struct nvmet_req *req)\r\n{\r\nstruct nvmf_connect_command *c = &req->cmd->connect;\r\nstruct nvmf_connect_data *d;\r\nstruct nvmet_ctrl *ctrl = NULL;\r\nu16 qid = le16_to_cpu(c->qid);\r\nu16 status = 0;\r\nd = kmap(sg_page(req->sg)) + req->sg->offset;\r\nreq->rsp->result = 0;\r\nif (c->recfmt != 0) {\r\npr_warn("invalid connect version (%d).\n",\r\nle16_to_cpu(c->recfmt));\r\nstatus = NVME_SC_CONNECT_FORMAT | NVME_SC_DNR;\r\ngoto out;\r\n}\r\nstatus = nvmet_ctrl_find_get(d->subsysnqn, d->hostnqn,\r\nle16_to_cpu(d->cntlid),\r\nreq, &ctrl);\r\nif (status)\r\ngoto out;\r\nif (unlikely(qid > ctrl->subsys->max_qid)) {\r\npr_warn("invalid queue id (%d)\n", qid);\r\nstatus = NVME_SC_CONNECT_INVALID_PARAM | NVME_SC_DNR;\r\nreq->rsp->result = IPO_IATTR_CONNECT_SQE(qid);\r\ngoto out_ctrl_put;\r\n}\r\nstatus = nvmet_install_queue(ctrl, req);\r\nif (status) {\r\nreq->rsp->result16 = cpu_to_le16(ctrl->cntlid);\r\ngoto out_ctrl_put;\r\n}\r\npr_info("adding queue %d to ctrl %d.\n", qid, ctrl->cntlid);\r\nout:\r\nkunmap(sg_page(req->sg));\r\nnvmet_req_complete(req, status);\r\nreturn;\r\nout_ctrl_put:\r\nnvmet_ctrl_put(ctrl);\r\ngoto out;\r\n}\r\nint nvmet_parse_connect_cmd(struct nvmet_req *req)\r\n{\r\nstruct nvme_command *cmd = req->cmd;\r\nreq->ns = NULL;\r\nif (req->cmd->common.opcode != nvme_fabrics_command) {\r\npr_err("invalid command 0x%x on unconnected queue.\n",\r\ncmd->fabrics.opcode);\r\nreturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\r\n}\r\nif (cmd->fabrics.fctype != nvme_fabrics_type_connect) {\r\npr_err("invalid capsule type 0x%x on unconnected queue.\n",\r\ncmd->fabrics.fctype);\r\nreturn NVME_SC_INVALID_OPCODE | NVME_SC_DNR;\r\n}\r\nreq->data_len = sizeof(struct nvmf_connect_data);\r\nif (cmd->connect.qid == 0)\r\nreq->execute = nvmet_execute_admin_connect;\r\nelse\r\nreq->execute = nvmet_execute_io_connect;\r\nreturn 0;\r\n}
