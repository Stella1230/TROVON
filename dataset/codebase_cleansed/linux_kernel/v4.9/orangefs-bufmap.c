static void install(struct slot_map *m, int count, unsigned long *map)\r\n{\r\nspin_lock(&m->q.lock);\r\nm->c = m->count = count;\r\nm->map = map;\r\nwake_up_all_locked(&m->q);\r\nspin_unlock(&m->q.lock);\r\n}\r\nstatic void mark_killed(struct slot_map *m)\r\n{\r\nspin_lock(&m->q.lock);\r\nm->c -= m->count + 1;\r\nspin_unlock(&m->q.lock);\r\n}\r\nstatic void run_down(struct slot_map *m)\r\n{\r\nDEFINE_WAIT(wait);\r\nspin_lock(&m->q.lock);\r\nif (m->c != -1) {\r\nfor (;;) {\r\nif (likely(list_empty(&wait.task_list)))\r\n__add_wait_queue_tail(&m->q, &wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (m->c == -1)\r\nbreak;\r\nspin_unlock(&m->q.lock);\r\nschedule();\r\nspin_lock(&m->q.lock);\r\n}\r\n__remove_wait_queue(&m->q, &wait);\r\n__set_current_state(TASK_RUNNING);\r\n}\r\nm->map = NULL;\r\nspin_unlock(&m->q.lock);\r\n}\r\nstatic void put(struct slot_map *m, int slot)\r\n{\r\nint v;\r\nspin_lock(&m->q.lock);\r\n__clear_bit(slot, m->map);\r\nv = ++m->c;\r\nif (unlikely(v == 1))\r\nwake_up_locked(&m->q);\r\nelse if (unlikely(v == -1))\r\nwake_up_all_locked(&m->q);\r\nspin_unlock(&m->q.lock);\r\n}\r\nstatic int wait_for_free(struct slot_map *m)\r\n{\r\nlong left = slot_timeout_secs * HZ;\r\nDEFINE_WAIT(wait);\r\ndo {\r\nlong n = left, t;\r\nif (likely(list_empty(&wait.task_list)))\r\n__add_wait_queue_tail_exclusive(&m->q, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (m->c > 0)\r\nbreak;\r\nif (m->c < 0) {\r\nif (n > ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS * HZ)\r\nn = ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS * HZ;\r\n}\r\nspin_unlock(&m->q.lock);\r\nt = schedule_timeout(n);\r\nspin_lock(&m->q.lock);\r\nif (unlikely(!t) && n != left && m->c < 0)\r\nleft = t;\r\nelse\r\nleft = t + (left - n);\r\nif (unlikely(signal_pending(current)))\r\nleft = -EINTR;\r\n} while (left > 0);\r\nif (!list_empty(&wait.task_list))\r\nlist_del(&wait.task_list);\r\nelse if (left <= 0 && waitqueue_active(&m->q))\r\n__wake_up_locked_key(&m->q, TASK_INTERRUPTIBLE, NULL);\r\n__set_current_state(TASK_RUNNING);\r\nif (likely(left > 0))\r\nreturn 0;\r\nreturn left < 0 ? -EINTR : -ETIMEDOUT;\r\n}\r\nstatic int get(struct slot_map *m)\r\n{\r\nint res = 0;\r\nspin_lock(&m->q.lock);\r\nif (unlikely(m->c <= 0))\r\nres = wait_for_free(m);\r\nif (likely(!res)) {\r\nm->c--;\r\nres = find_first_zero_bit(m->map, m->count);\r\n__set_bit(res, m->map);\r\n}\r\nspin_unlock(&m->q.lock);\r\nreturn res;\r\n}\r\nstatic void\r\norangefs_bufmap_unmap(struct orangefs_bufmap *bufmap)\r\n{\r\nint i;\r\nfor (i = 0; i < bufmap->page_count; i++)\r\nput_page(bufmap->page_array[i]);\r\n}\r\nstatic void\r\norangefs_bufmap_free(struct orangefs_bufmap *bufmap)\r\n{\r\nkfree(bufmap->page_array);\r\nkfree(bufmap->desc_array);\r\nkfree(bufmap->buffer_index_array);\r\nkfree(bufmap);\r\n}\r\nint orangefs_bufmap_size_query(void)\r\n{\r\nstruct orangefs_bufmap *bufmap;\r\nint size = 0;\r\nspin_lock(&orangefs_bufmap_lock);\r\nbufmap = __orangefs_bufmap;\r\nif (bufmap)\r\nsize = bufmap->desc_size;\r\nspin_unlock(&orangefs_bufmap_lock);\r\nreturn size;\r\n}\r\nint orangefs_bufmap_shift_query(void)\r\n{\r\nstruct orangefs_bufmap *bufmap;\r\nint shift = 0;\r\nspin_lock(&orangefs_bufmap_lock);\r\nbufmap = __orangefs_bufmap;\r\nif (bufmap)\r\nshift = bufmap->desc_shift;\r\nspin_unlock(&orangefs_bufmap_lock);\r\nreturn shift;\r\n}\r\nint orangefs_get_bufmap_init(void)\r\n{\r\nreturn __orangefs_bufmap ? 1 : 0;\r\n}\r\nstatic struct orangefs_bufmap *\r\norangefs_bufmap_alloc(struct ORANGEFS_dev_map_desc *user_desc)\r\n{\r\nstruct orangefs_bufmap *bufmap;\r\nbufmap = kzalloc(sizeof(*bufmap), GFP_KERNEL);\r\nif (!bufmap)\r\ngoto out;\r\nbufmap->total_size = user_desc->total_size;\r\nbufmap->desc_count = user_desc->count;\r\nbufmap->desc_size = user_desc->size;\r\nbufmap->desc_shift = ilog2(bufmap->desc_size);\r\nbufmap->buffer_index_array =\r\nkzalloc(DIV_ROUND_UP(bufmap->desc_count, BITS_PER_LONG), GFP_KERNEL);\r\nif (!bufmap->buffer_index_array) {\r\ngossip_err("orangefs: could not allocate %d buffer indices\n",\r\nbufmap->desc_count);\r\ngoto out_free_bufmap;\r\n}\r\nbufmap->desc_array =\r\nkcalloc(bufmap->desc_count, sizeof(struct orangefs_bufmap_desc),\r\nGFP_KERNEL);\r\nif (!bufmap->desc_array) {\r\ngossip_err("orangefs: could not allocate %d descriptors\n",\r\nbufmap->desc_count);\r\ngoto out_free_index_array;\r\n}\r\nbufmap->page_count = bufmap->total_size / PAGE_SIZE;\r\nbufmap->page_array =\r\nkcalloc(bufmap->page_count, sizeof(struct page *), GFP_KERNEL);\r\nif (!bufmap->page_array)\r\ngoto out_free_desc_array;\r\nreturn bufmap;\r\nout_free_desc_array:\r\nkfree(bufmap->desc_array);\r\nout_free_index_array:\r\nkfree(bufmap->buffer_index_array);\r\nout_free_bufmap:\r\nkfree(bufmap);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic int\r\norangefs_bufmap_map(struct orangefs_bufmap *bufmap,\r\nstruct ORANGEFS_dev_map_desc *user_desc)\r\n{\r\nint pages_per_desc = bufmap->desc_size / PAGE_SIZE;\r\nint offset = 0, ret, i;\r\nret = get_user_pages_fast((unsigned long)user_desc->ptr,\r\nbufmap->page_count, 1, bufmap->page_array);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != bufmap->page_count) {\r\ngossip_err("orangefs error: asked for %d pages, only got %d.\n",\r\nbufmap->page_count, ret);\r\nfor (i = 0; i < ret; i++) {\r\nSetPageError(bufmap->page_array[i]);\r\nput_page(bufmap->page_array[i]);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < bufmap->page_count; i++)\r\nflush_dcache_page(bufmap->page_array[i]);\r\nfor (offset = 0, i = 0; i < bufmap->desc_count; i++) {\r\nbufmap->desc_array[i].page_array = &bufmap->page_array[offset];\r\nbufmap->desc_array[i].array_count = pages_per_desc;\r\nbufmap->desc_array[i].uaddr =\r\n(user_desc->ptr + (i * pages_per_desc * PAGE_SIZE));\r\noffset += pages_per_desc;\r\n}\r\nreturn 0;\r\n}\r\nint orangefs_bufmap_initialize(struct ORANGEFS_dev_map_desc *user_desc)\r\n{\r\nstruct orangefs_bufmap *bufmap;\r\nint ret = -EINVAL;\r\ngossip_debug(GOSSIP_BUFMAP_DEBUG,\r\n"orangefs_bufmap_initialize: called (ptr ("\r\n"%p) sz (%d) cnt(%d).\n",\r\nuser_desc->ptr,\r\nuser_desc->size,\r\nuser_desc->count);\r\nif (PAGE_ALIGN((unsigned long)user_desc->ptr) !=\r\n(unsigned long)user_desc->ptr) {\r\ngossip_err("orangefs error: memory alignment (front). %p\n",\r\nuser_desc->ptr);\r\ngoto out;\r\n}\r\nif (PAGE_ALIGN(((unsigned long)user_desc->ptr + user_desc->total_size))\r\n!= (unsigned long)(user_desc->ptr + user_desc->total_size)) {\r\ngossip_err("orangefs error: memory alignment (back).(%p + %d)\n",\r\nuser_desc->ptr,\r\nuser_desc->total_size);\r\ngoto out;\r\n}\r\nif (user_desc->total_size != (user_desc->size * user_desc->count)) {\r\ngossip_err("orangefs error: user provided an oddly sized buffer: (%d, %d, %d)\n",\r\nuser_desc->total_size,\r\nuser_desc->size,\r\nuser_desc->count);\r\ngoto out;\r\n}\r\nif ((user_desc->size % PAGE_SIZE) != 0) {\r\ngossip_err("orangefs error: bufmap size not page size divisible (%d).\n",\r\nuser_desc->size);\r\ngoto out;\r\n}\r\nret = -ENOMEM;\r\nbufmap = orangefs_bufmap_alloc(user_desc);\r\nif (!bufmap)\r\ngoto out;\r\nret = orangefs_bufmap_map(bufmap, user_desc);\r\nif (ret)\r\ngoto out_free_bufmap;\r\nspin_lock(&orangefs_bufmap_lock);\r\nif (__orangefs_bufmap) {\r\nspin_unlock(&orangefs_bufmap_lock);\r\ngossip_err("orangefs: error: bufmap already initialized.\n");\r\nret = -EINVAL;\r\ngoto out_unmap_bufmap;\r\n}\r\n__orangefs_bufmap = bufmap;\r\ninstall(&rw_map,\r\nbufmap->desc_count,\r\nbufmap->buffer_index_array);\r\ninstall(&readdir_map,\r\nORANGEFS_READDIR_DEFAULT_DESC_COUNT,\r\nbufmap->readdir_index_array);\r\nspin_unlock(&orangefs_bufmap_lock);\r\ngossip_debug(GOSSIP_BUFMAP_DEBUG,\r\n"orangefs_bufmap_initialize: exiting normally\n");\r\nreturn 0;\r\nout_unmap_bufmap:\r\norangefs_bufmap_unmap(bufmap);\r\nout_free_bufmap:\r\norangefs_bufmap_free(bufmap);\r\nout:\r\nreturn ret;\r\n}\r\nvoid orangefs_bufmap_finalize(void)\r\n{\r\nstruct orangefs_bufmap *bufmap = __orangefs_bufmap;\r\nif (!bufmap)\r\nreturn;\r\ngossip_debug(GOSSIP_BUFMAP_DEBUG, "orangefs_bufmap_finalize: called\n");\r\nmark_killed(&rw_map);\r\nmark_killed(&readdir_map);\r\ngossip_debug(GOSSIP_BUFMAP_DEBUG,\r\n"orangefs_bufmap_finalize: exiting normally\n");\r\n}\r\nvoid orangefs_bufmap_run_down(void)\r\n{\r\nstruct orangefs_bufmap *bufmap = __orangefs_bufmap;\r\nif (!bufmap)\r\nreturn;\r\nrun_down(&rw_map);\r\nrun_down(&readdir_map);\r\nspin_lock(&orangefs_bufmap_lock);\r\n__orangefs_bufmap = NULL;\r\nspin_unlock(&orangefs_bufmap_lock);\r\norangefs_bufmap_unmap(bufmap);\r\norangefs_bufmap_free(bufmap);\r\n}\r\nint orangefs_bufmap_get(void)\r\n{\r\nreturn get(&rw_map);\r\n}\r\nvoid orangefs_bufmap_put(int buffer_index)\r\n{\r\nput(&rw_map, buffer_index);\r\n}\r\nint orangefs_readdir_index_get(void)\r\n{\r\nreturn get(&readdir_map);\r\n}\r\nvoid orangefs_readdir_index_put(int buffer_index)\r\n{\r\nput(&readdir_map, buffer_index);\r\n}\r\nint orangefs_bufmap_copy_from_iovec(struct iov_iter *iter,\r\nint buffer_index,\r\nsize_t size)\r\n{\r\nstruct orangefs_bufmap_desc *to;\r\nint i;\r\ngossip_debug(GOSSIP_BUFMAP_DEBUG,\r\n"%s: buffer_index:%d: size:%zu:\n",\r\n__func__, buffer_index, size);\r\nto = &__orangefs_bufmap->desc_array[buffer_index];\r\nfor (i = 0; size; i++) {\r\nstruct page *page = to->page_array[i];\r\nsize_t n = size;\r\nif (n > PAGE_SIZE)\r\nn = PAGE_SIZE;\r\nn = copy_page_from_iter(page, 0, n, iter);\r\nif (!n)\r\nreturn -EFAULT;\r\nsize -= n;\r\n}\r\nreturn 0;\r\n}\r\nint orangefs_bufmap_copy_to_iovec(struct iov_iter *iter,\r\nint buffer_index,\r\nsize_t size)\r\n{\r\nstruct orangefs_bufmap_desc *from;\r\nint i;\r\nfrom = &__orangefs_bufmap->desc_array[buffer_index];\r\ngossip_debug(GOSSIP_BUFMAP_DEBUG,\r\n"%s: buffer_index:%d: size:%zu:\n",\r\n__func__, buffer_index, size);\r\nfor (i = 0; size; i++) {\r\nstruct page *page = from->page_array[i];\r\nsize_t n = size;\r\nif (n > PAGE_SIZE)\r\nn = PAGE_SIZE;\r\nn = copy_page_to_iter(page, 0, n, iter);\r\nif (!n)\r\nreturn -EFAULT;\r\nsize -= n;\r\n}\r\nreturn 0;\r\n}
