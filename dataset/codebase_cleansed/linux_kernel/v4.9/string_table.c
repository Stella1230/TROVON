struct ceph_string *ceph_find_or_create_string(const char* str, size_t len)\r\n{\r\nstruct ceph_string *cs, *exist;\r\nstruct rb_node **p, *parent;\r\nint ret;\r\nexist = NULL;\r\nspin_lock(&string_tree_lock);\r\np = &string_tree.rb_node;\r\nwhile (*p) {\r\nexist = rb_entry(*p, struct ceph_string, node);\r\nret = ceph_compare_string(exist, str, len);\r\nif (ret > 0)\r\np = &(*p)->rb_left;\r\nelse if (ret < 0)\r\np = &(*p)->rb_right;\r\nelse\r\nbreak;\r\nexist = NULL;\r\n}\r\nif (exist && !kref_get_unless_zero(&exist->kref)) {\r\nrb_erase(&exist->node, &string_tree);\r\nRB_CLEAR_NODE(&exist->node);\r\nexist = NULL;\r\n}\r\nspin_unlock(&string_tree_lock);\r\nif (exist)\r\nreturn exist;\r\ncs = kmalloc(sizeof(*cs) + len + 1, GFP_NOFS);\r\nif (!cs)\r\nreturn NULL;\r\nkref_init(&cs->kref);\r\ncs->len = len;\r\nmemcpy(cs->str, str, len);\r\ncs->str[len] = 0;\r\nretry:\r\nexist = NULL;\r\nparent = NULL;\r\np = &string_tree.rb_node;\r\nspin_lock(&string_tree_lock);\r\nwhile (*p) {\r\nparent = *p;\r\nexist = rb_entry(*p, struct ceph_string, node);\r\nret = ceph_compare_string(exist, str, len);\r\nif (ret > 0)\r\np = &(*p)->rb_left;\r\nelse if (ret < 0)\r\np = &(*p)->rb_right;\r\nelse\r\nbreak;\r\nexist = NULL;\r\n}\r\nret = 0;\r\nif (!exist) {\r\nrb_link_node(&cs->node, parent, p);\r\nrb_insert_color(&cs->node, &string_tree);\r\n} else if (!kref_get_unless_zero(&exist->kref)) {\r\nrb_erase(&exist->node, &string_tree);\r\nRB_CLEAR_NODE(&exist->node);\r\nret = -EAGAIN;\r\n}\r\nspin_unlock(&string_tree_lock);\r\nif (ret == -EAGAIN)\r\ngoto retry;\r\nif (exist) {\r\nkfree(cs);\r\ncs = exist;\r\n}\r\nreturn cs;\r\n}\r\nvoid ceph_release_string(struct kref *ref)\r\n{\r\nstruct ceph_string *cs = container_of(ref, struct ceph_string, kref);\r\nspin_lock(&string_tree_lock);\r\nif (!RB_EMPTY_NODE(&cs->node)) {\r\nrb_erase(&cs->node, &string_tree);\r\nRB_CLEAR_NODE(&cs->node);\r\n}\r\nspin_unlock(&string_tree_lock);\r\nkfree_rcu(cs, rcu);\r\n}\r\nbool ceph_strings_empty(void)\r\n{\r\nreturn RB_EMPTY_ROOT(&string_tree);\r\n}
