enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw)\r\n{\r\nreturn ixgbe_media_type_copper;\r\n}\r\ns32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mac_info *mac = &hw->mac;\r\nstruct ixgbe_phy_info *phy = &hw->phy;\r\nphy->ops.set_phy_power = ixgbe_set_copper_phy_power;\r\nmac->mcft_size = IXGBE_X540_MC_TBL_SIZE;\r\nmac->vft_size = IXGBE_X540_VFT_TBL_SIZE;\r\nmac->num_rar_entries = IXGBE_X540_RAR_ENTRIES;\r\nmac->rx_pb_size = IXGBE_X540_RX_PB_SIZE;\r\nmac->max_rx_queues = IXGBE_X540_MAX_RX_QUEUES;\r\nmac->max_tx_queues = IXGBE_X540_MAX_TX_QUEUES;\r\nmac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw, ixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\nreturn hw->phy.ops.setup_link_speed(hw, speed,\r\nautoneg_wait_to_complete);\r\n}\r\ns32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nu32 ctrl, i;\r\nstatus = hw->mac.ops.stop_adapter(hw);\r\nif (status)\r\nreturn status;\r\nixgbe_clear_tx_pending(hw);\r\nmac_reset_top:\r\nctrl = IXGBE_CTRL_RST;\r\nctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);\r\nIXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nusleep_range(1000, 1200);\r\nfor (i = 0; i < 10; i++) {\r\nctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);\r\nif (!(ctrl & IXGBE_CTRL_RST_MASK))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (ctrl & IXGBE_CTRL_RST_MASK) {\r\nstatus = IXGBE_ERR_RESET_FAILED;\r\nhw_dbg(hw, "Reset polling failed to complete.\n");\r\n}\r\nmsleep(100);\r\nif (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {\r\nhw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\r\ngoto mac_reset_top;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(0), 384 << IXGBE_RXPBSIZE_SHIFT);\r\nhw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);\r\nhw->mac.num_rar_entries = IXGBE_X540_MAX_TX_QUEUES;\r\nhw->mac.ops.init_rx_addrs(hw);\r\nhw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);\r\nif (is_valid_ether_addr(hw->mac.san_addr)) {\r\nhw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;\r\nhw->mac.ops.set_rar(hw, hw->mac.san_mac_rar_index,\r\nhw->mac.san_addr, 0, IXGBE_RAH_AV);\r\nhw->mac.ops.clear_vmdq(hw, hw->mac.san_mac_rar_index,\r\nIXGBE_CLEAR_VMDQ_ALL);\r\nhw->mac.num_rar_entries--;\r\n}\r\nhw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,\r\n&hw->mac.wwpn_prefix);\r\nreturn status;\r\n}\r\ns32 ixgbe_start_hw_X540(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val;\r\nret_val = ixgbe_start_hw_generic(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn ixgbe_start_hw_gen2(hw);\r\n}\r\ns32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\r\nu32 eec;\r\nu16 eeprom_size;\r\nif (eeprom->type == ixgbe_eeprom_uninitialized) {\r\neeprom->semaphore_delay = 10;\r\neeprom->type = ixgbe_flash;\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\neeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>\r\nIXGBE_EEC_SIZE_SHIFT);\r\neeprom->word_size = BIT(eeprom_size +\r\nIXGBE_EEPROM_WORD_SIZE_SHIFT);\r\nhw_dbg(hw, "Eeprom params: type = %d, size = %d\n",\r\neeprom->type, eeprom->word_size);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data)\r\n{\r\ns32 status;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = ixgbe_read_eerd_generic(hw, offset, data);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw,\r\nu16 offset, u16 words, u16 *data)\r\n{\r\ns32 status;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = ixgbe_read_eerd_buffer_generic(hw, offset, words, data);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data)\r\n{\r\ns32 status;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = ixgbe_write_eewr_generic(hw, offset, data);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw,\r\nu16 offset, u16 words, u16 *data)\r\n{\r\ns32 status;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = ixgbe_write_eewr_buffer_generic(hw, offset, words, data);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)\r\n{\r\nu16 i;\r\nu16 j;\r\nu16 checksum = 0;\r\nu16 length = 0;\r\nu16 pointer = 0;\r\nu16 word = 0;\r\nu16 checksum_last_word = IXGBE_EEPROM_CHECKSUM;\r\nu16 ptr_start = IXGBE_PCIE_ANALOG_PTR;\r\nfor (i = 0; i < checksum_last_word; i++) {\r\nif (ixgbe_read_eerd_generic(hw, i, &word)) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nchecksum += word;\r\n}\r\nfor (i = ptr_start; i < IXGBE_FW_PTR; i++) {\r\nif (i == IXGBE_PHY_PTR || i == IXGBE_OPTION_ROM_PTR)\r\ncontinue;\r\nif (ixgbe_read_eerd_generic(hw, i, &pointer)) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nbreak;\r\n}\r\nif (pointer == 0xFFFF || pointer == 0 ||\r\npointer >= hw->eeprom.word_size)\r\ncontinue;\r\nif (ixgbe_read_eerd_generic(hw, pointer, &length)) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn IXGBE_ERR_EEPROM;\r\nbreak;\r\n}\r\nif (length == 0xFFFF || length == 0 ||\r\n(pointer + length) >= hw->eeprom.word_size)\r\ncontinue;\r\nfor (j = pointer + 1; j <= pointer + length; j++) {\r\nif (ixgbe_read_eerd_generic(hw, j, &word)) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nchecksum += word;\r\n}\r\n}\r\nchecksum = (u16)IXGBE_EEPROM_SUM - checksum;\r\nreturn (s32)checksum;\r\n}\r\nstatic s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw,\r\nu16 *checksum_val)\r\n{\r\ns32 status;\r\nu16 checksum;\r\nu16 read_checksum = 0;\r\nstatus = hw->eeprom.ops.read(hw, 0, &checksum);\r\nif (status) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn status;\r\n}\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = hw->eeprom.ops.calc_checksum(hw);\r\nif (status < 0)\r\ngoto out;\r\nchecksum = (u16)(status & 0xffff);\r\nstatus = ixgbe_read_eerd_generic(hw, IXGBE_EEPROM_CHECKSUM,\r\n&read_checksum);\r\nif (status)\r\ngoto out;\r\nif (read_checksum != checksum) {\r\nhw_dbg(hw, "Invalid EEPROM checksum");\r\nstatus = IXGBE_ERR_EEPROM_CHECKSUM;\r\n}\r\nif (checksum_val)\r\n*checksum_val = checksum;\r\nout:\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nu16 checksum;\r\nstatus = hw->eeprom.ops.read(hw, 0, &checksum);\r\nif (status) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn status;\r\n}\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = hw->eeprom.ops.calc_checksum(hw);\r\nif (status < 0)\r\ngoto out;\r\nchecksum = (u16)(status & 0xffff);\r\nstatus = ixgbe_write_eewr_generic(hw, IXGBE_EEPROM_CHECKSUM, checksum);\r\nif (status)\r\ngoto out;\r\nstatus = ixgbe_update_flash_X540(hw);\r\nout:\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)\r\n{\r\nu32 flup;\r\ns32 status;\r\nstatus = ixgbe_poll_flash_update_done_X540(hw);\r\nif (status == IXGBE_ERR_EEPROM) {\r\nhw_dbg(hw, "Flash update time out\n");\r\nreturn status;\r\n}\r\nflup = IXGBE_READ_REG(hw, IXGBE_EEC(hw)) | IXGBE_EEC_FLUP;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), flup);\r\nstatus = ixgbe_poll_flash_update_done_X540(hw);\r\nif (status == 0)\r\nhw_dbg(hw, "Flash update complete\n");\r\nelse\r\nhw_dbg(hw, "Flash update time out\n");\r\nif (hw->revision_id == 0) {\r\nflup = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\nif (flup & IXGBE_EEC_SEC1VAL) {\r\nflup |= IXGBE_EEC_FLUP;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC(hw), flup);\r\n}\r\nstatus = ixgbe_poll_flash_update_done_X540(hw);\r\nif (status == 0)\r\nhw_dbg(hw, "Flash update complete\n");\r\nelse\r\nhw_dbg(hw, "Flash update time out\n");\r\n}\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)\r\n{\r\nu32 i;\r\nu32 reg;\r\nfor (i = 0; i < IXGBE_FLUDONE_ATTEMPTS; i++) {\r\nreg = IXGBE_READ_REG(hw, IXGBE_EEC(hw));\r\nif (reg & IXGBE_EEC_FLUDONE)\r\nreturn 0;\r\nudelay(5);\r\n}\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\ns32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)\r\n{\r\nu32 swmask = mask & IXGBE_GSSR_NVM_PHY_MASK;\r\nu32 swi2c_mask = mask & IXGBE_GSSR_I2C_MASK;\r\nu32 fwmask = swmask << 5;\r\nu32 timeout = 200;\r\nu32 hwmask = 0;\r\nu32 swfw_sync;\r\nu32 i;\r\nif (swmask & IXGBE_GSSR_EEP_SM)\r\nhwmask = IXGBE_GSSR_FLASH_SM;\r\nif (mask & IXGBE_GSSR_SW_MNG_SM)\r\nswmask |= IXGBE_GSSR_SW_MNG_SM;\r\nswmask |= swi2c_mask;\r\nfwmask |= swi2c_mask << 2;\r\nfor (i = 0; i < timeout; i++) {\r\nif (ixgbe_get_swfw_sync_semaphore(hw))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\r\nif (!(swfw_sync & (fwmask | swmask | hwmask))) {\r\nswfw_sync |= swmask;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nusleep_range(5000, 6000);\r\nreturn 0;\r\n}\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nusleep_range(5000, 10000);\r\n}\r\nif (swmask == IXGBE_GSSR_SW_MNG_SM) {\r\nhw_dbg(hw, "Failed to get SW only semaphore\n");\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\n}\r\nif (ixgbe_get_swfw_sync_semaphore(hw))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\r\nif (swfw_sync & (fwmask | hwmask)) {\r\nswfw_sync |= swmask;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nusleep_range(5000, 6000);\r\nreturn 0;\r\n}\r\nif (swfw_sync & swmask) {\r\nu32 rmask = IXGBE_GSSR_EEP_SM | IXGBE_GSSR_PHY0_SM |\r\nIXGBE_GSSR_PHY1_SM | IXGBE_GSSR_MAC_CSR_SM;\r\nif (swi2c_mask)\r\nrmask |= IXGBE_GSSR_I2C_MASK;\r\nixgbe_release_swfw_sync_X540(hw, rmask);\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\n}\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\n}\r\nvoid ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)\r\n{\r\nu32 swmask = mask & (IXGBE_GSSR_NVM_PHY_MASK | IXGBE_GSSR_SW_MNG_SM);\r\nu32 swfw_sync;\r\nif (mask & IXGBE_GSSR_I2C_MASK)\r\nswmask |= mask & IXGBE_GSSR_I2C_MASK;\r\nixgbe_get_swfw_sync_semaphore(hw);\r\nswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\r\nswfw_sync &= ~swmask;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nusleep_range(5000, 6000);\r\n}\r\nstatic s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)\r\n{\r\nu32 timeout = 2000;\r\nu32 i;\r\nu32 swsm;\r\nfor (i = 0; i < timeout; i++) {\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\r\nif (!(swsm & IXGBE_SWSM_SMBI))\r\nbreak;\r\nusleep_range(50, 100);\r\n}\r\nif (i == timeout) {\r\nhw_dbg(hw,\r\n"Software semaphore SMBI between device drivers not granted.\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nfor (i = 0; i < timeout; i++) {\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\r\nif (!(swsm & IXGBE_SWFW_REGSMP))\r\nreturn 0;\r\nusleep_range(50, 100);\r\n}\r\nhw_dbg(hw, "REGSMP Software NVM semaphore not granted\n");\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nstatic void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)\r\n{\r\nu32 swsm;\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));\r\nswsm &= ~IXGBE_SWFW_REGSMP;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swsm);\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));\r\nswsm &= ~IXGBE_SWSM_SMBI;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nvoid ixgbe_init_swfw_sync_X540(struct ixgbe_hw *hw)\r\n{\r\nixgbe_get_swfw_sync_semaphore(hw);\r\nixgbe_release_swfw_sync_semaphore(hw);\r\n}\r\ns32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)\r\n{\r\nu32 macc_reg;\r\nu32 ledctl_reg;\r\nixgbe_link_speed speed;\r\nbool link_up;\r\nhw->mac.ops.check_link(hw, &speed, &link_up, false);\r\nif (!link_up) {\r\nmacc_reg = IXGBE_READ_REG(hw, IXGBE_MACC);\r\nmacc_reg |= IXGBE_MACC_FLU | IXGBE_MACC_FSV_10G | IXGBE_MACC_FS;\r\nIXGBE_WRITE_REG(hw, IXGBE_MACC, macc_reg);\r\n}\r\nledctl_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nledctl_reg &= ~IXGBE_LED_MODE_MASK(index);\r\nledctl_reg |= IXGBE_LED_BLINK(index);\r\nIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, ledctl_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}\r\ns32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index)\r\n{\r\nu32 macc_reg;\r\nu32 ledctl_reg;\r\nledctl_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nledctl_reg &= ~IXGBE_LED_MODE_MASK(index);\r\nledctl_reg |= IXGBE_LED_LINK_ACTIVE << IXGBE_LED_MODE_SHIFT(index);\r\nledctl_reg &= ~IXGBE_LED_BLINK(index);\r\nIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, ledctl_reg);\r\nmacc_reg = IXGBE_READ_REG(hw, IXGBE_MACC);\r\nmacc_reg &= ~(IXGBE_MACC_FLU | IXGBE_MACC_FSV_10G | IXGBE_MACC_FS);\r\nIXGBE_WRITE_REG(hw, IXGBE_MACC, macc_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}
