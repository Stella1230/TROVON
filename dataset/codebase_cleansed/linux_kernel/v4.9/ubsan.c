static bool was_reported(struct source_location *location)\r\n{\r\nreturn test_and_set_bit(REPORTED_BIT, &location->reported);\r\n}\r\nstatic void print_source_location(const char *prefix,\r\nstruct source_location *loc)\r\n{\r\npr_err("%s %s:%d:%d\n", prefix, loc->file_name,\r\nloc->line & LINE_MASK, loc->column & COLUMN_MASK);\r\n}\r\nstatic bool suppress_report(struct source_location *loc)\r\n{\r\nreturn current->in_ubsan || was_reported(loc);\r\n}\r\nstatic bool type_is_int(struct type_descriptor *type)\r\n{\r\nreturn type->type_kind == type_kind_int;\r\n}\r\nstatic bool type_is_signed(struct type_descriptor *type)\r\n{\r\nWARN_ON(!type_is_int(type));\r\nreturn type->type_info & 1;\r\n}\r\nstatic unsigned type_bit_width(struct type_descriptor *type)\r\n{\r\nreturn 1 << (type->type_info >> 1);\r\n}\r\nstatic bool is_inline_int(struct type_descriptor *type)\r\n{\r\nunsigned inline_bits = sizeof(unsigned long)*8;\r\nunsigned bits = type_bit_width(type);\r\nWARN_ON(!type_is_int(type));\r\nreturn bits <= inline_bits;\r\n}\r\nstatic s_max get_signed_val(struct type_descriptor *type, unsigned long val)\r\n{\r\nif (is_inline_int(type)) {\r\nunsigned extra_bits = sizeof(s_max)*8 - type_bit_width(type);\r\nreturn ((s_max)val) << extra_bits >> extra_bits;\r\n}\r\nif (type_bit_width(type) == 64)\r\nreturn *(s64 *)val;\r\nreturn *(s_max *)val;\r\n}\r\nstatic bool val_is_negative(struct type_descriptor *type, unsigned long val)\r\n{\r\nreturn type_is_signed(type) && get_signed_val(type, val) < 0;\r\n}\r\nstatic u_max get_unsigned_val(struct type_descriptor *type, unsigned long val)\r\n{\r\nif (is_inline_int(type))\r\nreturn val;\r\nif (type_bit_width(type) == 64)\r\nreturn *(u64 *)val;\r\nreturn *(u_max *)val;\r\n}\r\nstatic void val_to_string(char *str, size_t size, struct type_descriptor *type,\r\nunsigned long value)\r\n{\r\nif (type_is_int(type)) {\r\nif (type_bit_width(type) == 128) {\r\n#if defined(CONFIG_ARCH_SUPPORTS_INT128) && defined(__SIZEOF_INT128__)\r\nu_max val = get_unsigned_val(type, value);\r\nscnprintf(str, size, "0x%08x%08x%08x%08x",\r\n(u32)(val >> 96),\r\n(u32)(val >> 64),\r\n(u32)(val >> 32),\r\n(u32)(val));\r\n#else\r\nWARN_ON(1);\r\n#endif\r\n} else if (type_is_signed(type)) {\r\nscnprintf(str, size, "%lld",\r\n(s64)get_signed_val(type, value));\r\n} else {\r\nscnprintf(str, size, "%llu",\r\n(u64)get_unsigned_val(type, value));\r\n}\r\n}\r\n}\r\nstatic bool location_is_valid(struct source_location *loc)\r\n{\r\nreturn loc->file_name != NULL;\r\n}\r\nstatic void ubsan_prologue(struct source_location *location,\r\nunsigned long *flags)\r\n{\r\ncurrent->in_ubsan++;\r\nspin_lock_irqsave(&report_lock, *flags);\r\npr_err("========================================"\r\n"========================================\n");\r\nprint_source_location("UBSAN: Undefined behaviour in", location);\r\n}\r\nstatic void ubsan_epilogue(unsigned long *flags)\r\n{\r\ndump_stack();\r\npr_err("========================================"\r\n"========================================\n");\r\nspin_unlock_irqrestore(&report_lock, *flags);\r\ncurrent->in_ubsan--;\r\n}\r\nstatic void handle_overflow(struct overflow_data *data, unsigned long lhs,\r\nunsigned long rhs, char op)\r\n{\r\nstruct type_descriptor *type = data->type;\r\nunsigned long flags;\r\nchar lhs_val_str[VALUE_LENGTH];\r\nchar rhs_val_str[VALUE_LENGTH];\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\nval_to_string(lhs_val_str, sizeof(lhs_val_str), type, lhs);\r\nval_to_string(rhs_val_str, sizeof(rhs_val_str), type, rhs);\r\npr_err("%s integer overflow:\n",\r\ntype_is_signed(type) ? "signed" : "unsigned");\r\npr_err("%s %c %s cannot be represented in type %s\n",\r\nlhs_val_str,\r\nop,\r\nrhs_val_str,\r\ntype->type_name);\r\nubsan_epilogue(&flags);\r\n}\r\nvoid __ubsan_handle_add_overflow(struct overflow_data *data,\r\nunsigned long lhs,\r\nunsigned long rhs)\r\n{\r\nhandle_overflow(data, lhs, rhs, '+');\r\n}\r\nvoid __ubsan_handle_sub_overflow(struct overflow_data *data,\r\nunsigned long lhs,\r\nunsigned long rhs)\r\n{\r\nhandle_overflow(data, lhs, rhs, '-');\r\n}\r\nvoid __ubsan_handle_mul_overflow(struct overflow_data *data,\r\nunsigned long lhs,\r\nunsigned long rhs)\r\n{\r\nhandle_overflow(data, lhs, rhs, '*');\r\n}\r\nvoid __ubsan_handle_negate_overflow(struct overflow_data *data,\r\nunsigned long old_val)\r\n{\r\nunsigned long flags;\r\nchar old_val_str[VALUE_LENGTH];\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\nval_to_string(old_val_str, sizeof(old_val_str), data->type, old_val);\r\npr_err("negation of %s cannot be represented in type %s:\n",\r\nold_val_str, data->type->type_name);\r\nubsan_epilogue(&flags);\r\n}\r\nvoid __ubsan_handle_divrem_overflow(struct overflow_data *data,\r\nunsigned long lhs,\r\nunsigned long rhs)\r\n{\r\nunsigned long flags;\r\nchar rhs_val_str[VALUE_LENGTH];\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\nval_to_string(rhs_val_str, sizeof(rhs_val_str), data->type, rhs);\r\nif (type_is_signed(data->type) && get_signed_val(data->type, rhs) == -1)\r\npr_err("division of %s by -1 cannot be represented in type %s\n",\r\nrhs_val_str, data->type->type_name);\r\nelse\r\npr_err("division by zero\n");\r\nubsan_epilogue(&flags);\r\n}\r\nstatic void handle_null_ptr_deref(struct type_mismatch_data *data)\r\n{\r\nunsigned long flags;\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\npr_err("%s null pointer of type %s\n",\r\ntype_check_kinds[data->type_check_kind],\r\ndata->type->type_name);\r\nubsan_epilogue(&flags);\r\n}\r\nstatic void handle_missaligned_access(struct type_mismatch_data *data,\r\nunsigned long ptr)\r\n{\r\nunsigned long flags;\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\npr_err("%s misaligned address %p for type %s\n",\r\ntype_check_kinds[data->type_check_kind],\r\n(void *)ptr, data->type->type_name);\r\npr_err("which requires %ld byte alignment\n", data->alignment);\r\nubsan_epilogue(&flags);\r\n}\r\nstatic void handle_object_size_mismatch(struct type_mismatch_data *data,\r\nunsigned long ptr)\r\n{\r\nunsigned long flags;\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\npr_err("%s address %p with insufficient space\n",\r\ntype_check_kinds[data->type_check_kind],\r\n(void *) ptr);\r\npr_err("for an object of type %s\n", data->type->type_name);\r\nubsan_epilogue(&flags);\r\n}\r\nvoid __ubsan_handle_type_mismatch(struct type_mismatch_data *data,\r\nunsigned long ptr)\r\n{\r\nif (!ptr)\r\nhandle_null_ptr_deref(data);\r\nelse if (data->alignment && !IS_ALIGNED(ptr, data->alignment))\r\nhandle_missaligned_access(data, ptr);\r\nelse\r\nhandle_object_size_mismatch(data, ptr);\r\n}\r\nvoid __ubsan_handle_nonnull_return(struct nonnull_return_data *data)\r\n{\r\nunsigned long flags;\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\npr_err("null pointer returned from function declared to never return null\n");\r\nif (location_is_valid(&data->attr_location))\r\nprint_source_location("returns_nonnull attribute specified in",\r\n&data->attr_location);\r\nubsan_epilogue(&flags);\r\n}\r\nvoid __ubsan_handle_vla_bound_not_positive(struct vla_bound_data *data,\r\nunsigned long bound)\r\n{\r\nunsigned long flags;\r\nchar bound_str[VALUE_LENGTH];\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\nval_to_string(bound_str, sizeof(bound_str), data->type, bound);\r\npr_err("variable length array bound value %s <= 0\n", bound_str);\r\nubsan_epilogue(&flags);\r\n}\r\nvoid __ubsan_handle_out_of_bounds(struct out_of_bounds_data *data,\r\nunsigned long index)\r\n{\r\nunsigned long flags;\r\nchar index_str[VALUE_LENGTH];\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\nval_to_string(index_str, sizeof(index_str), data->index_type, index);\r\npr_err("index %s is out of range for type %s\n", index_str,\r\ndata->array_type->type_name);\r\nubsan_epilogue(&flags);\r\n}\r\nvoid __ubsan_handle_shift_out_of_bounds(struct shift_out_of_bounds_data *data,\r\nunsigned long lhs, unsigned long rhs)\r\n{\r\nunsigned long flags;\r\nstruct type_descriptor *rhs_type = data->rhs_type;\r\nstruct type_descriptor *lhs_type = data->lhs_type;\r\nchar rhs_str[VALUE_LENGTH];\r\nchar lhs_str[VALUE_LENGTH];\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\nval_to_string(rhs_str, sizeof(rhs_str), rhs_type, rhs);\r\nval_to_string(lhs_str, sizeof(lhs_str), lhs_type, lhs);\r\nif (val_is_negative(rhs_type, rhs))\r\npr_err("shift exponent %s is negative\n", rhs_str);\r\nelse if (get_unsigned_val(rhs_type, rhs) >=\r\ntype_bit_width(lhs_type))\r\npr_err("shift exponent %s is too large for %u-bit type %s\n",\r\nrhs_str,\r\ntype_bit_width(lhs_type),\r\nlhs_type->type_name);\r\nelse if (val_is_negative(lhs_type, lhs))\r\npr_err("left shift of negative value %s\n",\r\nlhs_str);\r\nelse\r\npr_err("left shift of %s by %s places cannot be"\r\n" represented in type %s\n",\r\nlhs_str, rhs_str,\r\nlhs_type->type_name);\r\nubsan_epilogue(&flags);\r\n}\r\nvoid __noreturn\r\n__ubsan_handle_builtin_unreachable(struct unreachable_data *data)\r\n{\r\nunsigned long flags;\r\nubsan_prologue(&data->location, &flags);\r\npr_err("calling __builtin_unreachable()\n");\r\nubsan_epilogue(&flags);\r\npanic("can't return from __builtin_unreachable()");\r\n}\r\nvoid __ubsan_handle_load_invalid_value(struct invalid_value_data *data,\r\nunsigned long val)\r\n{\r\nunsigned long flags;\r\nchar val_str[VALUE_LENGTH];\r\nif (suppress_report(&data->location))\r\nreturn;\r\nubsan_prologue(&data->location, &flags);\r\nval_to_string(val_str, sizeof(val_str), data->type, val);\r\npr_err("load of value %s is not a valid value for type %s\n",\r\nval_str, data->type->type_name);\r\nubsan_epilogue(&flags);\r\n}
