static bool\r\nmrf24j40_short_reg_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_RXMCR:\r\ncase REG_PANIDL:\r\ncase REG_PANIDH:\r\ncase REG_SADRL:\r\ncase REG_SADRH:\r\ncase REG_EADR0:\r\ncase REG_EADR1:\r\ncase REG_EADR2:\r\ncase REG_EADR3:\r\ncase REG_EADR4:\r\ncase REG_EADR5:\r\ncase REG_EADR6:\r\ncase REG_EADR7:\r\ncase REG_RXFLUSH:\r\ncase REG_ORDER:\r\ncase REG_TXMCR:\r\ncase REG_ACKTMOUT:\r\ncase REG_ESLOTG1:\r\ncase REG_SYMTICKL:\r\ncase REG_SYMTICKH:\r\ncase REG_PACON0:\r\ncase REG_PACON1:\r\ncase REG_PACON2:\r\ncase REG_TXBCON0:\r\ncase REG_TXNCON:\r\ncase REG_TXG1CON:\r\ncase REG_TXG2CON:\r\ncase REG_ESLOTG23:\r\ncase REG_ESLOTG45:\r\ncase REG_ESLOTG67:\r\ncase REG_TXPEND:\r\ncase REG_WAKECON:\r\ncase REG_FROMOFFSET:\r\ncase REG_TXBCON1:\r\ncase REG_GATECLK:\r\ncase REG_TXTIME:\r\ncase REG_HSYMTMRL:\r\ncase REG_HSYMTMRH:\r\ncase REG_SOFTRST:\r\ncase REG_SECCON0:\r\ncase REG_SECCON1:\r\ncase REG_TXSTBL:\r\ncase REG_RXSR:\r\ncase REG_INTCON:\r\ncase REG_TRISGPIO:\r\ncase REG_GPIO:\r\ncase REG_RFCTL:\r\ncase REG_SECCR2:\r\ncase REG_SLPACK:\r\ncase REG_BBREG0:\r\ncase REG_BBREG1:\r\ncase REG_BBREG2:\r\ncase REG_BBREG3:\r\ncase REG_BBREG4:\r\ncase REG_BBREG6:\r\ncase REG_CCAEDTH:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nmrf24j40_short_reg_readable(struct device *dev, unsigned int reg)\r\n{\r\nbool rc;\r\nrc = mrf24j40_short_reg_writeable(dev, reg);\r\nif (rc)\r\nreturn rc;\r\nswitch (reg) {\r\ncase REG_TXSTAT:\r\ncase REG_INTSTAT:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nmrf24j40_short_reg_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_TXSTAT:\r\ncase REG_INTSTAT:\r\ncase REG_RXFLUSH:\r\ncase REG_TXNCON:\r\ncase REG_SOFTRST:\r\ncase REG_RFCTL:\r\ncase REG_TXBCON0:\r\ncase REG_TXG1CON:\r\ncase REG_TXG2CON:\r\ncase REG_TXBCON1:\r\ncase REG_SECCON0:\r\ncase REG_RXSR:\r\ncase REG_SLPACK:\r\ncase REG_SECCR2:\r\ncase REG_BBREG6:\r\ncase REG_BBREG1:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nmrf24j40_short_reg_precious(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_INTSTAT:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nmrf24j40_long_reg_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_RFCON0:\r\ncase REG_RFCON1:\r\ncase REG_RFCON2:\r\ncase REG_RFCON3:\r\ncase REG_RFCON5:\r\ncase REG_RFCON6:\r\ncase REG_RFCON7:\r\ncase REG_RFCON8:\r\ncase REG_SLPCAL2:\r\ncase REG_SLPCON0:\r\ncase REG_SLPCON1:\r\ncase REG_WAKETIMEL:\r\ncase REG_WAKETIMEH:\r\ncase REG_REMCNTL:\r\ncase REG_REMCNTH:\r\ncase REG_MAINCNT0:\r\ncase REG_MAINCNT1:\r\ncase REG_MAINCNT2:\r\ncase REG_MAINCNT3:\r\ncase REG_TESTMODE:\r\ncase REG_ASSOEAR0:\r\ncase REG_ASSOEAR1:\r\ncase REG_ASSOEAR2:\r\ncase REG_ASSOEAR3:\r\ncase REG_ASSOEAR4:\r\ncase REG_ASSOEAR5:\r\ncase REG_ASSOEAR6:\r\ncase REG_ASSOEAR7:\r\ncase REG_ASSOSAR0:\r\ncase REG_ASSOSAR1:\r\ncase REG_UNONCE0:\r\ncase REG_UNONCE1:\r\ncase REG_UNONCE2:\r\ncase REG_UNONCE3:\r\ncase REG_UNONCE4:\r\ncase REG_UNONCE5:\r\ncase REG_UNONCE6:\r\ncase REG_UNONCE7:\r\ncase REG_UNONCE8:\r\ncase REG_UNONCE9:\r\ncase REG_UNONCE10:\r\ncase REG_UNONCE11:\r\ncase REG_UNONCE12:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nmrf24j40_long_reg_readable(struct device *dev, unsigned int reg)\r\n{\r\nbool rc;\r\nrc = mrf24j40_long_reg_writeable(dev, reg);\r\nif (rc)\r\nreturn rc;\r\nswitch (reg) {\r\ncase REG_SLPCAL0:\r\ncase REG_SLPCAL1:\r\ncase REG_RFSTATE:\r\ncase REG_RSSI:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nmrf24j40_long_reg_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_SLPCAL0:\r\ncase REG_SLPCAL1:\r\ncase REG_SLPCAL2:\r\ncase REG_RFSTATE:\r\ncase REG_RSSI:\r\ncase REG_MAINCNT3:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int mrf24j40_long_regmap_write(void *context, const void *data,\r\nsize_t count)\r\n{\r\nstruct spi_device *spi = context;\r\nu8 buf[3];\r\nif (count > 3)\r\nreturn -EINVAL;\r\nmemcpy(buf, data, count);\r\nbuf[1] |= (1 << 4);\r\nreturn spi_write(spi, buf, count);\r\n}\r\nstatic int\r\nmrf24j40_long_regmap_read(void *context, const void *reg, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nstruct spi_device *spi = context;\r\nreturn spi_write_then_read(spi, reg, reg_size, val, val_size);\r\n}\r\nstatic void write_tx_buf_complete(void *context)\r\n{\r\nstruct mrf24j40 *devrec = context;\r\n__le16 fc = ieee802154_get_fc_from_skb(devrec->tx_skb);\r\nu8 val = BIT_TXNTRIG;\r\nint ret;\r\nif (ieee802154_is_secen(fc))\r\nval |= BIT_TXNSECEN;\r\nif (ieee802154_is_ackreq(fc))\r\nval |= BIT_TXNACKREQ;\r\ndevrec->tx_post_msg.complete = NULL;\r\ndevrec->tx_post_buf[0] = MRF24J40_WRITESHORT(REG_TXNCON);\r\ndevrec->tx_post_buf[1] = val;\r\nret = spi_async(devrec->spi, &devrec->tx_post_msg);\r\nif (ret)\r\ndev_err(printdev(devrec), "SPI write Failed for transmit buf\n");\r\n}\r\nstatic int write_tx_buf(struct mrf24j40 *devrec, u16 reg,\r\nconst u8 *data, size_t length)\r\n{\r\nu16 cmd;\r\nint ret;\r\nif (length > TX_FIFO_SIZE-2) {\r\ndev_err(printdev(devrec), "write_tx_buf() was passed too large a buffer. Performing short write.\n");\r\nlength = TX_FIFO_SIZE-2;\r\n}\r\ncmd = MRF24J40_WRITELONG(reg);\r\ndevrec->tx_hdr_buf[0] = cmd >> 8 & 0xff;\r\ndevrec->tx_hdr_buf[1] = cmd & 0xff;\r\ndevrec->tx_len_buf[0] = 0x0;\r\ndevrec->tx_len_buf[1] = length;\r\ndevrec->tx_buf_trx.tx_buf = data;\r\ndevrec->tx_buf_trx.len = length;\r\nret = spi_async(devrec->spi, &devrec->tx_msg);\r\nif (ret)\r\ndev_err(printdev(devrec), "SPI write Failed for TX buf\n");\r\nreturn ret;\r\n}\r\nstatic int mrf24j40_tx(struct ieee802154_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\ndev_dbg(printdev(devrec), "tx packet of %d bytes\n", skb->len);\r\ndevrec->tx_skb = skb;\r\nreturn write_tx_buf(devrec, 0x000, skb->data, skb->len);\r\n}\r\nstatic int mrf24j40_ed(struct ieee802154_hw *hw, u8 *level)\r\n{\r\npr_warn("mrf24j40: ed not implemented\n");\r\n*level = 0;\r\nreturn 0;\r\n}\r\nstatic int mrf24j40_start(struct ieee802154_hw *hw)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\ndev_dbg(printdev(devrec), "start\n");\r\nreturn regmap_update_bits(devrec->regmap_short, REG_INTCON,\r\nBIT_TXNIE | BIT_RXIE | BIT_SECIE, 0);\r\n}\r\nstatic void mrf24j40_stop(struct ieee802154_hw *hw)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\ndev_dbg(printdev(devrec), "stop\n");\r\nregmap_update_bits(devrec->regmap_short, REG_INTCON,\r\nBIT_TXNIE | BIT_TXNIE, BIT_TXNIE | BIT_TXNIE);\r\n}\r\nstatic int mrf24j40_set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nu8 val;\r\nint ret;\r\ndev_dbg(printdev(devrec), "Set Channel %d\n", channel);\r\nWARN_ON(page != 0);\r\nWARN_ON(channel < MRF24J40_CHAN_MIN);\r\nWARN_ON(channel > MRF24J40_CHAN_MAX);\r\nval = (channel - 11) << RFCON0_CH_SHIFT | RFOPT_RECOMMEND;\r\nret = regmap_update_bits(devrec->regmap_long, REG_RFCON0,\r\nRFCON0_CH_MASK, val);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(devrec->regmap_short, REG_RFCTL, BIT_RFRST,\r\nBIT_RFRST);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(devrec->regmap_short, REG_RFCTL, BIT_RFRST, 0);\r\nif (!ret)\r\nudelay(SET_CHANNEL_DELAY_US);\r\nreturn ret;\r\n}\r\nstatic int mrf24j40_filter(struct ieee802154_hw *hw,\r\nstruct ieee802154_hw_addr_filt *filt,\r\nunsigned long changed)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\ndev_dbg(printdev(devrec), "filter\n");\r\nif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\r\nu8 addrh, addrl;\r\naddrh = le16_to_cpu(filt->short_addr) >> 8 & 0xff;\r\naddrl = le16_to_cpu(filt->short_addr) & 0xff;\r\nregmap_write(devrec->regmap_short, REG_SADRH, addrh);\r\nregmap_write(devrec->regmap_short, REG_SADRL, addrl);\r\ndev_dbg(printdev(devrec),\r\n"Set short addr to %04hx\n", filt->short_addr);\r\n}\r\nif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\r\nu8 i, addr[8];\r\nmemcpy(addr, &filt->ieee_addr, 8);\r\nfor (i = 0; i < 8; i++)\r\nregmap_write(devrec->regmap_short, REG_EADR0 + i,\r\naddr[i]);\r\n#ifdef DEBUG\r\npr_debug("Set long addr to: ");\r\nfor (i = 0; i < 8; i++)\r\npr_debug("%02hhx ", addr[7 - i]);\r\npr_debug("\n");\r\n#endif\r\n}\r\nif (changed & IEEE802154_AFILT_PANID_CHANGED) {\r\nu8 panidl, panidh;\r\npanidh = le16_to_cpu(filt->pan_id) >> 8 & 0xff;\r\npanidl = le16_to_cpu(filt->pan_id) & 0xff;\r\nregmap_write(devrec->regmap_short, REG_PANIDH, panidh);\r\nregmap_write(devrec->regmap_short, REG_PANIDL, panidl);\r\ndev_dbg(printdev(devrec), "Set PANID to %04hx\n", filt->pan_id);\r\n}\r\nif (changed & IEEE802154_AFILT_PANC_CHANGED) {\r\nu8 val;\r\nint ret;\r\nif (filt->pan_coord)\r\nval = BIT_PANCOORD;\r\nelse\r\nval = 0;\r\nret = regmap_update_bits(devrec->regmap_short, REG_RXMCR,\r\nBIT_PANCOORD, val);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(printdev(devrec), "Set Pan Coord to %s\n",\r\nfilt->pan_coord ? "on" : "off");\r\n}\r\nreturn 0;\r\n}\r\nstatic void mrf24j40_handle_rx_read_buf_unlock(struct mrf24j40 *devrec)\r\n{\r\nint ret;\r\ndevrec->rx_msg.complete = NULL;\r\ndevrec->rx_buf[0] = MRF24J40_WRITESHORT(REG_BBREG1);\r\ndevrec->rx_buf[1] = 0x00;\r\nret = spi_async(devrec->spi, &devrec->rx_msg);\r\nif (ret)\r\ndev_err(printdev(devrec), "failed to unlock rx buffer\n");\r\n}\r\nstatic void mrf24j40_handle_rx_read_buf_complete(void *context)\r\n{\r\nstruct mrf24j40 *devrec = context;\r\nu8 len = devrec->rx_buf[2];\r\nu8 rx_local_buf[RX_FIFO_SIZE];\r\nstruct sk_buff *skb;\r\nmemcpy(rx_local_buf, devrec->rx_fifo_buf, len);\r\nmrf24j40_handle_rx_read_buf_unlock(devrec);\r\nskb = dev_alloc_skb(IEEE802154_MTU);\r\nif (!skb) {\r\ndev_err(printdev(devrec), "failed to allocate skb\n");\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, len), rx_local_buf, len);\r\nieee802154_rx_irqsafe(devrec->hw, skb, 0);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_DEBUG, "mrf24j40 rx: ", DUMP_PREFIX_OFFSET, 16, 1,\r\nrx_local_buf, len, 0);\r\npr_debug("mrf24j40 rx: lqi: %02hhx rssi: %02hhx\n",\r\ndevrec->rx_lqi_buf[0], devrec->rx_lqi_buf[1]);\r\n#endif\r\n}\r\nstatic void mrf24j40_handle_rx_read_buf(void *context)\r\n{\r\nstruct mrf24j40 *devrec = context;\r\nu16 cmd;\r\nint ret;\r\nif (!ieee802154_is_valid_psdu_len(devrec->rx_buf[2]))\r\ndevrec->rx_buf[2] = IEEE802154_MTU;\r\ncmd = MRF24J40_READLONG(REG_RX_FIFO + 1);\r\ndevrec->rx_addr_buf[0] = cmd >> 8 & 0xff;\r\ndevrec->rx_addr_buf[1] = cmd & 0xff;\r\ndevrec->rx_fifo_buf_trx.len = devrec->rx_buf[2];\r\nret = spi_async(devrec->spi, &devrec->rx_buf_msg);\r\nif (ret) {\r\ndev_err(printdev(devrec), "failed to read rx buffer\n");\r\nmrf24j40_handle_rx_read_buf_unlock(devrec);\r\n}\r\n}\r\nstatic void mrf24j40_handle_rx_read_len(void *context)\r\n{\r\nstruct mrf24j40 *devrec = context;\r\nu16 cmd;\r\nint ret;\r\ndevrec->rx_msg.complete = mrf24j40_handle_rx_read_buf;\r\ndevrec->rx_trx.len = 3;\r\ncmd = MRF24J40_READLONG(REG_RX_FIFO);\r\ndevrec->rx_buf[0] = cmd >> 8 & 0xff;\r\ndevrec->rx_buf[1] = cmd & 0xff;\r\nret = spi_async(devrec->spi, &devrec->rx_msg);\r\nif (ret) {\r\ndev_err(printdev(devrec), "failed to read rx buffer length\n");\r\nmrf24j40_handle_rx_read_buf_unlock(devrec);\r\n}\r\n}\r\nstatic int mrf24j40_handle_rx(struct mrf24j40 *devrec)\r\n{\r\ndevrec->rx_msg.complete = mrf24j40_handle_rx_read_len;\r\ndevrec->rx_trx.len = 2;\r\ndevrec->rx_buf[0] = MRF24J40_WRITESHORT(REG_BBREG1);\r\ndevrec->rx_buf[1] = BIT_RXDECINV;\r\nreturn spi_async(devrec->spi, &devrec->rx_msg);\r\n}\r\nstatic int\r\nmrf24j40_csma_params(struct ieee802154_hw *hw, u8 min_be, u8 max_be,\r\nu8 retries)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nu8 val;\r\nval = min_be << TXMCR_MIN_BE_SHIFT;\r\nval |= retries << TXMCR_CSMA_RETRIES_SHIFT;\r\nreturn regmap_update_bits(devrec->regmap_short, REG_TXMCR,\r\nTXMCR_MIN_BE_MASK | TXMCR_CSMA_RETRIES_MASK,\r\nval);\r\n}\r\nstatic int mrf24j40_set_cca_mode(struct ieee802154_hw *hw,\r\nconst struct wpan_phy_cca *cca)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nu8 val;\r\nswitch (cca->mode) {\r\ncase NL802154_CCA_ENERGY:\r\nval = 2;\r\nbreak;\r\ncase NL802154_CCA_CARRIER:\r\nval = 1;\r\nbreak;\r\ncase NL802154_CCA_ENERGY_CARRIER:\r\nswitch (cca->opt) {\r\ncase NL802154_CCA_OPT_ENERGY_CARRIER_AND:\r\nval = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(devrec->regmap_short, REG_BBREG2,\r\nBBREG2_CCA_MODE_MASK,\r\nval << BBREG2_CCA_MODE_SHIFT);\r\n}\r\nstatic int mrf24j40_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mrf24j40_ed_levels_map); i++) {\r\nif (mrf24j40_ed_levels_map[i][0] == mbm)\r\nreturn regmap_write(devrec->regmap_short, REG_CCAEDTH,\r\nmrf24j40_ed_levels_map[i][1]);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mrf24j40_set_txpower(struct ieee802154_hw *hw, s32 mbm)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\ns32 small_scale;\r\nu8 val;\r\nif (0 >= mbm && mbm > -1000) {\r\nval = TXPWRL_0 << TXPWRL_SHIFT;\r\nsmall_scale = mbm;\r\n} else if (-1000 >= mbm && mbm > -2000) {\r\nval = TXPWRL_10 << TXPWRL_SHIFT;\r\nsmall_scale = mbm + 1000;\r\n} else if (-2000 >= mbm && mbm > -3000) {\r\nval = TXPWRL_20 << TXPWRL_SHIFT;\r\nsmall_scale = mbm + 2000;\r\n} else if (-3000 >= mbm && mbm > -4000) {\r\nval = TXPWRL_30 << TXPWRL_SHIFT;\r\nsmall_scale = mbm + 3000;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nswitch (small_scale) {\r\ncase 0:\r\nval |= (TXPWRS_0 << TXPWRS_SHIFT);\r\nbreak;\r\ncase -50:\r\nval |= (TXPWRS_0_5 << TXPWRS_SHIFT);\r\nbreak;\r\ncase -120:\r\nval |= (TXPWRS_1_2 << TXPWRS_SHIFT);\r\nbreak;\r\ncase -190:\r\nval |= (TXPWRS_1_9 << TXPWRS_SHIFT);\r\nbreak;\r\ncase -280:\r\nval |= (TXPWRS_2_8 << TXPWRS_SHIFT);\r\nbreak;\r\ncase -370:\r\nval |= (TXPWRS_3_7 << TXPWRS_SHIFT);\r\nbreak;\r\ncase -490:\r\nval |= (TXPWRS_4_9 << TXPWRS_SHIFT);\r\nbreak;\r\ncase -630:\r\nval |= (TXPWRS_6_3 << TXPWRS_SHIFT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(devrec->regmap_long, REG_RFCON3,\r\nTXPWRL_MASK | TXPWRS_MASK, val);\r\n}\r\nstatic int mrf24j40_set_promiscuous_mode(struct ieee802154_hw *hw, bool on)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nint ret;\r\nif (on) {\r\nret = regmap_update_bits(devrec->regmap_short, REG_RXMCR,\r\nBIT_PROMI | BIT_ERRPKT | BIT_NOACKRSP,\r\nBIT_PROMI | BIT_ERRPKT | BIT_NOACKRSP);\r\n} else {\r\nret = regmap_update_bits(devrec->regmap_short, REG_RXMCR,\r\nBIT_PROMI | BIT_ERRPKT | BIT_NOACKRSP,\r\n0);\r\n}\r\nreturn ret;\r\n}\r\nstatic void mrf24j40_intstat_complete(void *context)\r\n{\r\nstruct mrf24j40 *devrec = context;\r\nu8 intstat = devrec->irq_buf[1];\r\nenable_irq(devrec->spi->irq);\r\nif (intstat & BIT_SECIF)\r\nregmap_write_async(devrec->regmap_short, REG_SECCON0,\r\nBIT_SECIGNORE);\r\nif (intstat & BIT_TXNIF)\r\nieee802154_xmit_complete(devrec->hw, devrec->tx_skb, false);\r\nif (intstat & BIT_RXIF)\r\nmrf24j40_handle_rx(devrec);\r\n}\r\nstatic irqreturn_t mrf24j40_isr(int irq, void *data)\r\n{\r\nstruct mrf24j40 *devrec = data;\r\nint ret;\r\ndisable_irq_nosync(irq);\r\ndevrec->irq_buf[0] = MRF24J40_READSHORT(REG_INTSTAT);\r\ndevrec->irq_buf[1] = 0;\r\nret = spi_async(devrec->spi, &devrec->irq_msg);\r\nif (ret) {\r\nenable_irq(irq);\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mrf24j40_hw_init(struct mrf24j40 *devrec)\r\n{\r\nu32 irq_type;\r\nint ret;\r\nret = regmap_write(devrec->regmap_short, REG_SOFTRST, 0x07);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_short, REG_PACON2, 0x98);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_short, REG_TXSTBL, 0x95);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_long, REG_RFCON0, 0x03);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_long, REG_RFCON1, 0x01);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_long, REG_RFCON2, 0x80);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_long, REG_RFCON6, 0x90);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_long, REG_RFCON7, 0x80);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_long, REG_RFCON8, 0x10);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_long, REG_SLPCON1, 0x21);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_short, REG_BBREG2, 0x80);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_short, REG_CCAEDTH, 0x60);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_short, REG_BBREG6, 0x40);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_short, REG_RFCTL, 0x04);\r\nif (ret)\r\ngoto err_ret;\r\nret = regmap_write(devrec->regmap_short, REG_RFCTL, 0x0);\r\nif (ret)\r\ngoto err_ret;\r\nudelay(192);\r\nret = regmap_update_bits(devrec->regmap_short, REG_RXMCR, 0x03, 0x00);\r\nif (ret)\r\ngoto err_ret;\r\nif (spi_get_device_id(devrec->spi)->driver_data == MRF24J40MC) {\r\nregmap_update_bits(devrec->regmap_long, REG_TESTMODE, 0x07,\r\n0x07);\r\nregmap_update_bits(devrec->regmap_short, REG_TRISGPIO, 0x08,\r\n0x08);\r\nregmap_update_bits(devrec->regmap_short, REG_GPIO, 0x08, 0x08);\r\nregmap_write(devrec->regmap_long, REG_RFCON3, 0x28);\r\n}\r\nirq_type = irq_get_trigger_type(devrec->spi->irq);\r\nif (irq_type == IRQ_TYPE_EDGE_RISING ||\r\nirq_type == IRQ_TYPE_EDGE_FALLING)\r\ndev_warn(&devrec->spi->dev,\r\n"Using edge triggered irq's are not recommended, because it can cause races and result in a non-functional driver!\n");\r\nswitch (irq_type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nret = regmap_update_bits(devrec->regmap_long, REG_SLPCON0,\r\nBIT_INTEDGE, BIT_INTEDGE);\r\nif (ret)\r\ngoto err_ret;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic void\r\nmrf24j40_setup_tx_spi_messages(struct mrf24j40 *devrec)\r\n{\r\nspi_message_init(&devrec->tx_msg);\r\ndevrec->tx_msg.context = devrec;\r\ndevrec->tx_msg.complete = write_tx_buf_complete;\r\ndevrec->tx_hdr_trx.len = 2;\r\ndevrec->tx_hdr_trx.tx_buf = devrec->tx_hdr_buf;\r\nspi_message_add_tail(&devrec->tx_hdr_trx, &devrec->tx_msg);\r\ndevrec->tx_len_trx.len = 2;\r\ndevrec->tx_len_trx.tx_buf = devrec->tx_len_buf;\r\nspi_message_add_tail(&devrec->tx_len_trx, &devrec->tx_msg);\r\nspi_message_add_tail(&devrec->tx_buf_trx, &devrec->tx_msg);\r\nspi_message_init(&devrec->tx_post_msg);\r\ndevrec->tx_post_msg.context = devrec;\r\ndevrec->tx_post_trx.len = 2;\r\ndevrec->tx_post_trx.tx_buf = devrec->tx_post_buf;\r\nspi_message_add_tail(&devrec->tx_post_trx, &devrec->tx_post_msg);\r\n}\r\nstatic void\r\nmrf24j40_setup_rx_spi_messages(struct mrf24j40 *devrec)\r\n{\r\nspi_message_init(&devrec->rx_msg);\r\ndevrec->rx_msg.context = devrec;\r\ndevrec->rx_trx.len = 2;\r\ndevrec->rx_trx.tx_buf = devrec->rx_buf;\r\ndevrec->rx_trx.rx_buf = devrec->rx_buf;\r\nspi_message_add_tail(&devrec->rx_trx, &devrec->rx_msg);\r\nspi_message_init(&devrec->rx_buf_msg);\r\ndevrec->rx_buf_msg.context = devrec;\r\ndevrec->rx_buf_msg.complete = mrf24j40_handle_rx_read_buf_complete;\r\ndevrec->rx_addr_trx.len = 2;\r\ndevrec->rx_addr_trx.tx_buf = devrec->rx_addr_buf;\r\nspi_message_add_tail(&devrec->rx_addr_trx, &devrec->rx_buf_msg);\r\ndevrec->rx_fifo_buf_trx.rx_buf = devrec->rx_fifo_buf;\r\nspi_message_add_tail(&devrec->rx_fifo_buf_trx, &devrec->rx_buf_msg);\r\ndevrec->rx_lqi_trx.len = 2;\r\ndevrec->rx_lqi_trx.rx_buf = devrec->rx_lqi_buf;\r\nspi_message_add_tail(&devrec->rx_lqi_trx, &devrec->rx_buf_msg);\r\n}\r\nstatic void\r\nmrf24j40_setup_irq_spi_messages(struct mrf24j40 *devrec)\r\n{\r\nspi_message_init(&devrec->irq_msg);\r\ndevrec->irq_msg.context = devrec;\r\ndevrec->irq_msg.complete = mrf24j40_intstat_complete;\r\ndevrec->irq_trx.len = 2;\r\ndevrec->irq_trx.tx_buf = devrec->irq_buf;\r\ndevrec->irq_trx.rx_buf = devrec->irq_buf;\r\nspi_message_add_tail(&devrec->irq_trx, &devrec->irq_msg);\r\n}\r\nstatic void mrf24j40_phy_setup(struct mrf24j40 *devrec)\r\n{\r\nieee802154_random_extended_addr(&devrec->hw->phy->perm_extended_addr);\r\ndevrec->hw->phy->current_channel = 11;\r\ndevrec->hw->phy->supported.max_minbe = 3;\r\ndevrec->hw->phy->supported.min_maxbe = 5;\r\ndevrec->hw->phy->supported.max_maxbe = 5;\r\ndevrec->hw->phy->cca.mode = NL802154_CCA_CARRIER;\r\ndevrec->hw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\r\nBIT(NL802154_CCA_CARRIER) |\r\nBIT(NL802154_CCA_ENERGY_CARRIER);\r\ndevrec->hw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND);\r\ndevrec->hw->phy->cca_ed_level = -6900;\r\ndevrec->hw->phy->supported.cca_ed_levels = mrf24j40_ed_levels;\r\ndevrec->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(mrf24j40_ed_levels);\r\nswitch (spi_get_device_id(devrec->spi)->driver_data) {\r\ncase MRF24J40:\r\ncase MRF24J40MA:\r\ndevrec->hw->phy->supported.tx_powers = mrf24j40ma_powers;\r\ndevrec->hw->phy->supported.tx_powers_size = ARRAY_SIZE(mrf24j40ma_powers);\r\ndevrec->hw->phy->flags |= WPAN_PHY_FLAG_TXPOWER;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int mrf24j40_probe(struct spi_device *spi)\r\n{\r\nint ret = -ENOMEM, irq_type;\r\nstruct ieee802154_hw *hw;\r\nstruct mrf24j40 *devrec;\r\ndev_info(&spi->dev, "probe(). IRQ: %d\n", spi->irq);\r\nhw = ieee802154_alloc_hw(sizeof(*devrec), &mrf24j40_ops);\r\nif (!hw)\r\ngoto err_ret;\r\ndevrec = hw->priv;\r\ndevrec->spi = spi;\r\nspi_set_drvdata(spi, devrec);\r\ndevrec->hw = hw;\r\ndevrec->hw->parent = &spi->dev;\r\ndevrec->hw->phy->supported.channels[0] = CHANNEL_MASK;\r\ndevrec->hw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\r\nIEEE802154_HW_CSMA_PARAMS |\r\nIEEE802154_HW_PROMISCUOUS;\r\ndevrec->hw->phy->flags = WPAN_PHY_FLAG_CCA_MODE |\r\nWPAN_PHY_FLAG_CCA_ED_LEVEL;\r\nmrf24j40_setup_tx_spi_messages(devrec);\r\nmrf24j40_setup_rx_spi_messages(devrec);\r\nmrf24j40_setup_irq_spi_messages(devrec);\r\ndevrec->regmap_short = devm_regmap_init_spi(spi,\r\n&mrf24j40_short_regmap);\r\nif (IS_ERR(devrec->regmap_short)) {\r\nret = PTR_ERR(devrec->regmap_short);\r\ndev_err(&spi->dev, "Failed to allocate short register map: %d\n",\r\nret);\r\ngoto err_register_device;\r\n}\r\ndevrec->regmap_long = devm_regmap_init(&spi->dev,\r\n&mrf24j40_long_regmap_bus,\r\nspi, &mrf24j40_long_regmap);\r\nif (IS_ERR(devrec->regmap_long)) {\r\nret = PTR_ERR(devrec->regmap_long);\r\ndev_err(&spi->dev, "Failed to allocate long register map: %d\n",\r\nret);\r\ngoto err_register_device;\r\n}\r\nif (spi->max_speed_hz > MAX_SPI_SPEED_HZ) {\r\ndev_warn(&spi->dev, "spi clock above possible maximum: %d",\r\nMAX_SPI_SPEED_HZ);\r\nreturn -EINVAL;\r\n}\r\nret = mrf24j40_hw_init(devrec);\r\nif (ret)\r\ngoto err_register_device;\r\nmrf24j40_phy_setup(devrec);\r\nirq_type = irq_get_trigger_type(spi->irq);\r\nif (!irq_type)\r\nirq_type = IRQF_TRIGGER_LOW;\r\nret = devm_request_irq(&spi->dev, spi->irq, mrf24j40_isr,\r\nirq_type, dev_name(&spi->dev), devrec);\r\nif (ret) {\r\ndev_err(printdev(devrec), "Unable to get IRQ");\r\ngoto err_register_device;\r\n}\r\ndev_dbg(printdev(devrec), "registered mrf24j40\n");\r\nret = ieee802154_register_hw(devrec->hw);\r\nif (ret)\r\ngoto err_register_device;\r\nreturn 0;\r\nerr_register_device:\r\nieee802154_free_hw(devrec->hw);\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic int mrf24j40_remove(struct spi_device *spi)\r\n{\r\nstruct mrf24j40 *devrec = spi_get_drvdata(spi);\r\ndev_dbg(printdev(devrec), "remove\n");\r\nieee802154_unregister_hw(devrec->hw);\r\nieee802154_free_hw(devrec->hw);\r\nreturn 0;\r\n}
