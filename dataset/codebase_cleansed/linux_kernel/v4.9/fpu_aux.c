static void fnop(void)\r\n{\r\n}\r\nstatic void fclex(void)\r\n{\r\npartial_status &=\r\n~(SW_Backward | SW_Summary | SW_Stack_Fault | SW_Precision |\r\nSW_Underflow | SW_Overflow | SW_Zero_Div | SW_Denorm_Op |\r\nSW_Invalid);\r\nno_ip_update = 1;\r\n}\r\nvoid fpstate_init_soft(struct swregs_state *soft)\r\n{\r\nstruct address *oaddr, *iaddr;\r\nmemset(soft, 0, sizeof(*soft));\r\nsoft->cwd = 0x037f;\r\nsoft->swd = 0;\r\nsoft->ftop = 0;\r\nsoft->twd = 0xffff;\r\noaddr = (struct address *)&soft->foo;\r\noaddr->offset = 0;\r\noaddr->selector = 0;\r\niaddr = (struct address *)&soft->fip;\r\niaddr->offset = 0;\r\niaddr->selector = 0;\r\niaddr->opcode = 0;\r\nsoft->no_update = 1;\r\n}\r\nvoid finit(void)\r\n{\r\nfpstate_init_soft(&current->thread.fpu.state.soft);\r\n}\r\nvoid finit_(void)\r\n{\r\n(finit_table[FPU_rm]) ();\r\n}\r\nstatic void fstsw_ax(void)\r\n{\r\n*(short *)&FPU_EAX = status_word();\r\nno_ip_update = 1;\r\n}\r\nvoid fstsw_(void)\r\n{\r\n(fstsw_table[FPU_rm]) ();\r\n}\r\nvoid fp_nop(void)\r\n{\r\n(fp_nop_table[FPU_rm]) ();\r\n}\r\nvoid fld_i_(void)\r\n{\r\nFPU_REG *st_new_ptr;\r\nint i;\r\nu_char tag;\r\nif (STACK_OVERFLOW) {\r\nFPU_stack_overflow();\r\nreturn;\r\n}\r\ni = FPU_rm;\r\nif (NOT_EMPTY(i)) {\r\nreg_copy(&st(i), st_new_ptr);\r\ntag = FPU_gettagi(i);\r\npush();\r\nFPU_settag0(tag);\r\n} else {\r\nif (control_word & CW_Invalid) {\r\nFPU_stack_underflow();\r\n} else\r\nEXCEPTION(EX_StackUnder);\r\n}\r\n}\r\nvoid fxch_i(void)\r\n{\r\nFPU_REG t;\r\nint i = FPU_rm;\r\nFPU_REG *st0_ptr = &st(0), *sti_ptr = &st(i);\r\nlong tag_word = fpu_tag_word;\r\nint regnr = top & 7, regnri = ((regnr + i) & 7);\r\nu_char st0_tag = (tag_word >> (regnr * 2)) & 3;\r\nu_char sti_tag = (tag_word >> (regnri * 2)) & 3;\r\nif (st0_tag == TAG_Empty) {\r\nif (sti_tag == TAG_Empty) {\r\nFPU_stack_underflow();\r\nFPU_stack_underflow_i(i);\r\nreturn;\r\n}\r\nif (control_word & CW_Invalid) {\r\nFPU_copy_to_reg0(sti_ptr, sti_tag);\r\n}\r\nFPU_stack_underflow_i(i);\r\nreturn;\r\n}\r\nif (sti_tag == TAG_Empty) {\r\nif (control_word & CW_Invalid) {\r\nFPU_copy_to_regi(st0_ptr, st0_tag, i);\r\n}\r\nFPU_stack_underflow();\r\nreturn;\r\n}\r\nclear_C1();\r\nreg_copy(st0_ptr, &t);\r\nreg_copy(sti_ptr, st0_ptr);\r\nreg_copy(&t, sti_ptr);\r\ntag_word &= ~(3 << (regnr * 2)) & ~(3 << (regnri * 2));\r\ntag_word |= (sti_tag << (regnr * 2)) | (st0_tag << (regnri * 2));\r\nfpu_tag_word = tag_word;\r\n}\r\nstatic void fcmovCC(void)\r\n{\r\nint i = FPU_rm;\r\nFPU_REG *st0_ptr = &st(0);\r\nFPU_REG *sti_ptr = &st(i);\r\nlong tag_word = fpu_tag_word;\r\nint regnr = top & 7;\r\nint regnri = (top + i) & 7;\r\nu_char sti_tag = (tag_word >> (regnri * 2)) & 3;\r\nif (sti_tag == TAG_Empty) {\r\nFPU_stack_underflow();\r\nclear_C1();\r\nreturn;\r\n}\r\nreg_copy(sti_ptr, st0_ptr);\r\ntag_word &= ~(3 << (regnr * 2));\r\ntag_word |= (sti_tag << (regnr * 2));\r\nfpu_tag_word = tag_word;\r\n}\r\nvoid fcmovb(void)\r\n{\r\nif (FPU_EFLAGS & X86_EFLAGS_CF)\r\nfcmovCC();\r\n}\r\nvoid fcmove(void)\r\n{\r\nif (FPU_EFLAGS & X86_EFLAGS_ZF)\r\nfcmovCC();\r\n}\r\nvoid fcmovbe(void)\r\n{\r\nif (FPU_EFLAGS & (X86_EFLAGS_CF|X86_EFLAGS_ZF))\r\nfcmovCC();\r\n}\r\nvoid fcmovu(void)\r\n{\r\nif (FPU_EFLAGS & X86_EFLAGS_PF)\r\nfcmovCC();\r\n}\r\nvoid fcmovnb(void)\r\n{\r\nif (!(FPU_EFLAGS & X86_EFLAGS_CF))\r\nfcmovCC();\r\n}\r\nvoid fcmovne(void)\r\n{\r\nif (!(FPU_EFLAGS & X86_EFLAGS_ZF))\r\nfcmovCC();\r\n}\r\nvoid fcmovnbe(void)\r\n{\r\nif (!(FPU_EFLAGS & (X86_EFLAGS_CF|X86_EFLAGS_ZF)))\r\nfcmovCC();\r\n}\r\nvoid fcmovnu(void)\r\n{\r\nif (!(FPU_EFLAGS & X86_EFLAGS_PF))\r\nfcmovCC();\r\n}\r\nvoid ffree_(void)\r\n{\r\nFPU_settagi(FPU_rm, TAG_Empty);\r\n}\r\nvoid ffreep(void)\r\n{\r\nFPU_settagi(FPU_rm, TAG_Empty);\r\nFPU_pop();\r\n}\r\nvoid fst_i_(void)\r\n{\r\nFPU_copy_to_regi(&st(0), FPU_gettag0(), FPU_rm);\r\n}\r\nvoid fstp_i(void)\r\n{\r\nFPU_copy_to_regi(&st(0), FPU_gettag0(), FPU_rm);\r\nFPU_pop();\r\n}
