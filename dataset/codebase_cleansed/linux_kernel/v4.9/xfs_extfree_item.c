static inline struct xfs_efi_log_item *EFI_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_efi_log_item, efi_item);\r\n}\r\nvoid\r\nxfs_efi_item_free(\r\nstruct xfs_efi_log_item *efip)\r\n{\r\nkmem_free(efip->efi_item.li_lv_shadow);\r\nif (efip->efi_format.efi_nextents > XFS_EFI_MAX_FAST_EXTENTS)\r\nkmem_free(efip);\r\nelse\r\nkmem_zone_free(xfs_efi_zone, efip);\r\n}\r\nstatic inline int\r\nxfs_efi_item_sizeof(\r\nstruct xfs_efi_log_item *efip)\r\n{\r\nreturn sizeof(struct xfs_efi_log_format) +\r\n(efip->efi_format.efi_nextents - 1) * sizeof(xfs_extent_t);\r\n}\r\nSTATIC void\r\nxfs_efi_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\n*nvecs += 1;\r\n*nbytes += xfs_efi_item_sizeof(EFI_ITEM(lip));\r\n}\r\nSTATIC void\r\nxfs_efi_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_efi_log_item *efip = EFI_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nASSERT(atomic_read(&efip->efi_next_extent) ==\r\nefip->efi_format.efi_nextents);\r\nefip->efi_format.efi_type = XFS_LI_EFI;\r\nefip->efi_format.efi_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_EFI_FORMAT,\r\n&efip->efi_format,\r\nxfs_efi_item_sizeof(efip));\r\n}\r\nSTATIC void\r\nxfs_efi_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_efi_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\nstruct xfs_efi_log_item *efip = EFI_ITEM(lip);\r\nxfs_efi_release(efip);\r\n}\r\nSTATIC uint\r\nxfs_efi_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_efi_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nif (lip->li_flags & XFS_LI_ABORTED)\r\nxfs_efi_item_free(EFI_ITEM(lip));\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_efi_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nreturn lsn;\r\n}\r\nSTATIC void\r\nxfs_efi_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_efi_log_item *\r\nxfs_efi_init(\r\nstruct xfs_mount *mp,\r\nuint nextents)\r\n{\r\nstruct xfs_efi_log_item *efip;\r\nuint size;\r\nASSERT(nextents > 0);\r\nif (nextents > XFS_EFI_MAX_FAST_EXTENTS) {\r\nsize = (uint)(sizeof(xfs_efi_log_item_t) +\r\n((nextents - 1) * sizeof(xfs_extent_t)));\r\nefip = kmem_zalloc(size, KM_SLEEP);\r\n} else {\r\nefip = kmem_zone_zalloc(xfs_efi_zone, KM_SLEEP);\r\n}\r\nxfs_log_item_init(mp, &efip->efi_item, XFS_LI_EFI, &xfs_efi_item_ops);\r\nefip->efi_format.efi_nextents = nextents;\r\nefip->efi_format.efi_id = (uintptr_t)(void *)efip;\r\natomic_set(&efip->efi_next_extent, 0);\r\natomic_set(&efip->efi_refcount, 2);\r\nreturn efip;\r\n}\r\nint\r\nxfs_efi_copy_format(xfs_log_iovec_t *buf, xfs_efi_log_format_t *dst_efi_fmt)\r\n{\r\nxfs_efi_log_format_t *src_efi_fmt = buf->i_addr;\r\nuint i;\r\nuint len = sizeof(xfs_efi_log_format_t) +\r\n(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_t);\r\nuint len32 = sizeof(xfs_efi_log_format_32_t) +\r\n(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_32_t);\r\nuint len64 = sizeof(xfs_efi_log_format_64_t) +\r\n(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_64_t);\r\nif (buf->i_len == len) {\r\nmemcpy((char *)dst_efi_fmt, (char*)src_efi_fmt, len);\r\nreturn 0;\r\n} else if (buf->i_len == len32) {\r\nxfs_efi_log_format_32_t *src_efi_fmt_32 = buf->i_addr;\r\ndst_efi_fmt->efi_type = src_efi_fmt_32->efi_type;\r\ndst_efi_fmt->efi_size = src_efi_fmt_32->efi_size;\r\ndst_efi_fmt->efi_nextents = src_efi_fmt_32->efi_nextents;\r\ndst_efi_fmt->efi_id = src_efi_fmt_32->efi_id;\r\nfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\r\ndst_efi_fmt->efi_extents[i].ext_start =\r\nsrc_efi_fmt_32->efi_extents[i].ext_start;\r\ndst_efi_fmt->efi_extents[i].ext_len =\r\nsrc_efi_fmt_32->efi_extents[i].ext_len;\r\n}\r\nreturn 0;\r\n} else if (buf->i_len == len64) {\r\nxfs_efi_log_format_64_t *src_efi_fmt_64 = buf->i_addr;\r\ndst_efi_fmt->efi_type = src_efi_fmt_64->efi_type;\r\ndst_efi_fmt->efi_size = src_efi_fmt_64->efi_size;\r\ndst_efi_fmt->efi_nextents = src_efi_fmt_64->efi_nextents;\r\ndst_efi_fmt->efi_id = src_efi_fmt_64->efi_id;\r\nfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\r\ndst_efi_fmt->efi_extents[i].ext_start =\r\nsrc_efi_fmt_64->efi_extents[i].ext_start;\r\ndst_efi_fmt->efi_extents[i].ext_len =\r\nsrc_efi_fmt_64->efi_extents[i].ext_len;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EFSCORRUPTED;\r\n}\r\nvoid\r\nxfs_efi_release(\r\nstruct xfs_efi_log_item *efip)\r\n{\r\nif (atomic_dec_and_test(&efip->efi_refcount)) {\r\nxfs_trans_ail_remove(&efip->efi_item, SHUTDOWN_LOG_IO_ERROR);\r\nxfs_efi_item_free(efip);\r\n}\r\n}\r\nstatic inline struct xfs_efd_log_item *EFD_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_efd_log_item, efd_item);\r\n}\r\nSTATIC void\r\nxfs_efd_item_free(struct xfs_efd_log_item *efdp)\r\n{\r\nkmem_free(efdp->efd_item.li_lv_shadow);\r\nif (efdp->efd_format.efd_nextents > XFS_EFD_MAX_FAST_EXTENTS)\r\nkmem_free(efdp);\r\nelse\r\nkmem_zone_free(xfs_efd_zone, efdp);\r\n}\r\nstatic inline int\r\nxfs_efd_item_sizeof(\r\nstruct xfs_efd_log_item *efdp)\r\n{\r\nreturn sizeof(xfs_efd_log_format_t) +\r\n(efdp->efd_format.efd_nextents - 1) * sizeof(xfs_extent_t);\r\n}\r\nSTATIC void\r\nxfs_efd_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\n*nvecs += 1;\r\n*nbytes += xfs_efd_item_sizeof(EFD_ITEM(lip));\r\n}\r\nSTATIC void\r\nxfs_efd_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_efd_log_item *efdp = EFD_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nASSERT(efdp->efd_next_extent == efdp->efd_format.efd_nextents);\r\nefdp->efd_format.efd_type = XFS_LI_EFD;\r\nefdp->efd_format.efd_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_EFD_FORMAT,\r\n&efdp->efd_format,\r\nxfs_efd_item_sizeof(efdp));\r\n}\r\nSTATIC void\r\nxfs_efd_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_efd_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\n}\r\nSTATIC uint\r\nxfs_efd_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_efd_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_efd_log_item *efdp = EFD_ITEM(lip);\r\nif (lip->li_flags & XFS_LI_ABORTED) {\r\nxfs_efi_release(efdp->efd_efip);\r\nxfs_efd_item_free(efdp);\r\n}\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_efd_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nstruct xfs_efd_log_item *efdp = EFD_ITEM(lip);\r\nxfs_efi_release(efdp->efd_efip);\r\nxfs_efd_item_free(efdp);\r\nreturn (xfs_lsn_t)-1;\r\n}\r\nSTATIC void\r\nxfs_efd_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_efd_log_item *\r\nxfs_efd_init(\r\nstruct xfs_mount *mp,\r\nstruct xfs_efi_log_item *efip,\r\nuint nextents)\r\n{\r\nstruct xfs_efd_log_item *efdp;\r\nuint size;\r\nASSERT(nextents > 0);\r\nif (nextents > XFS_EFD_MAX_FAST_EXTENTS) {\r\nsize = (uint)(sizeof(xfs_efd_log_item_t) +\r\n((nextents - 1) * sizeof(xfs_extent_t)));\r\nefdp = kmem_zalloc(size, KM_SLEEP);\r\n} else {\r\nefdp = kmem_zone_zalloc(xfs_efd_zone, KM_SLEEP);\r\n}\r\nxfs_log_item_init(mp, &efdp->efd_item, XFS_LI_EFD, &xfs_efd_item_ops);\r\nefdp->efd_efip = efip;\r\nefdp->efd_format.efd_nextents = nextents;\r\nefdp->efd_format.efd_efi_id = efip->efi_format.efi_id;\r\nreturn efdp;\r\n}\r\nint\r\nxfs_efi_recover(\r\nstruct xfs_mount *mp,\r\nstruct xfs_efi_log_item *efip)\r\n{\r\nstruct xfs_efd_log_item *efdp;\r\nstruct xfs_trans *tp;\r\nint i;\r\nint error = 0;\r\nxfs_extent_t *extp;\r\nxfs_fsblock_t startblock_fsb;\r\nstruct xfs_owner_info oinfo;\r\nASSERT(!test_bit(XFS_EFI_RECOVERED, &efip->efi_flags));\r\nfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\r\nextp = &efip->efi_format.efi_extents[i];\r\nstartblock_fsb = XFS_BB_TO_FSB(mp,\r\nXFS_FSB_TO_DADDR(mp, extp->ext_start));\r\nif (startblock_fsb == 0 ||\r\nextp->ext_len == 0 ||\r\nstartblock_fsb >= mp->m_sb.sb_dblocks ||\r\nextp->ext_len >= mp->m_sb.sb_agblocks) {\r\nset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\r\nxfs_efi_release(efip);\r\nreturn -EIO;\r\n}\r\n}\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\r\nif (error)\r\nreturn error;\r\nefdp = xfs_trans_get_efd(tp, efip, efip->efi_format.efi_nextents);\r\nxfs_rmap_skip_owner_update(&oinfo);\r\nfor (i = 0; i < efip->efi_format.efi_nextents; i++) {\r\nextp = &efip->efi_format.efi_extents[i];\r\nerror = xfs_trans_free_extent(tp, efdp, extp->ext_start,\r\nextp->ext_len, &oinfo);\r\nif (error)\r\ngoto abort_error;\r\n}\r\nset_bit(XFS_EFI_RECOVERED, &efip->efi_flags);\r\nerror = xfs_trans_commit(tp);\r\nreturn error;\r\nabort_error:\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}
