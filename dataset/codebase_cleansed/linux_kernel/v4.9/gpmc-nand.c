static bool gpmc_hwecc_bch_capable(enum omap_ecc ecc_opt)\r\n{\r\nif (soc_is_am33xx() || soc_is_am43xx() || cpu_is_omap44xx() ||\r\nsoc_is_omap54xx() || soc_is_dra7xx())\r\nreturn 1;\r\nif (ecc_opt == OMAP_ECC_BCH4_CODE_HW_DETECTION_SW ||\r\necc_opt == OMAP_ECC_BCH8_CODE_HW_DETECTION_SW) {\r\nif (cpu_is_omap24xx())\r\nreturn 0;\r\nelse if (cpu_is_omap3630() && (GET_OMAP_REVISION() == 0))\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nif ((cpu_is_omap34xx() || cpu_is_omap3630()) &&\r\n((ecc_opt == OMAP_ECC_BCH4_CODE_HW) ||\r\n(ecc_opt == OMAP_ECC_BCH8_CODE_HW)))\r\nreturn 0;\r\nif (ecc_opt == OMAP_ECC_HAM1_CODE_HW ||\r\necc_opt == OMAP_ECC_HAM1_CODE_SW)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void gpmc_set_legacy(struct omap_nand_platform_data *gpmc_nand_data,\r\nstruct gpmc_settings *s)\r\n{\r\nif (gpmc_nand_data->dev_ready) {\r\ns->wait_on_read = true;\r\ns->wait_on_write = true;\r\n}\r\nif (gpmc_nand_data->devsize == NAND_BUSWIDTH_16)\r\ns->device_width = GPMC_DEVWIDTH_16BIT;\r\nelse\r\ns->device_width = GPMC_DEVWIDTH_8BIT;\r\n}\r\nint gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data,\r\nstruct gpmc_timings *gpmc_t)\r\n{\r\nint err = 0;\r\nstruct gpmc_settings s;\r\nstruct platform_device *pdev;\r\nstruct resource gpmc_nand_res[] = {\r\n{ .flags = IORESOURCE_MEM, },\r\n{ .flags = IORESOURCE_IRQ, },\r\n{ .flags = IORESOURCE_IRQ, },\r\n};\r\nBUG_ON(gpmc_nand_data->cs >= GPMC_CS_NUM);\r\nerr = gpmc_cs_request(gpmc_nand_data->cs, NAND_IO_SIZE,\r\n(unsigned long *)&gpmc_nand_res[0].start);\r\nif (err < 0) {\r\npr_err("omap2-gpmc: Cannot request GPMC CS %d, error %d\n",\r\ngpmc_nand_data->cs, err);\r\nreturn err;\r\n}\r\ngpmc_nand_res[0].end = gpmc_nand_res[0].start + NAND_IO_SIZE - 1;\r\ngpmc_nand_res[1].start = gpmc_get_client_irq(GPMC_IRQ_FIFOEVENTENABLE);\r\ngpmc_nand_res[2].start = gpmc_get_client_irq(GPMC_IRQ_COUNT_EVENT);\r\nmemset(&s, 0, sizeof(struct gpmc_settings));\r\ngpmc_set_legacy(gpmc_nand_data, &s);\r\ns.device_nand = true;\r\nif (gpmc_t) {\r\nerr = gpmc_cs_set_timings(gpmc_nand_data->cs, gpmc_t, &s);\r\nif (err < 0) {\r\npr_err("omap2-gpmc: Unable to set gpmc timings: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\nerr = gpmc_cs_program_settings(gpmc_nand_data->cs, &s);\r\nif (err < 0)\r\ngoto out_free_cs;\r\nerr = gpmc_configure(GPMC_CONFIG_WP, 0);\r\nif (err < 0)\r\ngoto out_free_cs;\r\nif (!gpmc_hwecc_bch_capable(gpmc_nand_data->ecc_opt)) {\r\npr_err("omap2-nand: Unsupported NAND ECC scheme selected\n");\r\nerr = -EINVAL;\r\ngoto out_free_cs;\r\n}\r\npdev = platform_device_alloc("omap2-nand", gpmc_nand_data->cs);\r\nif (pdev) {\r\nerr = platform_device_add_resources(pdev, gpmc_nand_res,\r\nARRAY_SIZE(gpmc_nand_res));\r\nif (!err)\r\npdev->dev.platform_data = gpmc_nand_data;\r\n} else {\r\nerr = -ENOMEM;\r\n}\r\nif (err)\r\ngoto out_free_pdev;\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to register NAND device\n");\r\ngoto out_free_pdev;\r\n}\r\nreturn 0;\r\nout_free_pdev:\r\nplatform_device_put(pdev);\r\nout_free_cs:\r\ngpmc_cs_free(gpmc_nand_data->cs);\r\nreturn err;\r\n}
