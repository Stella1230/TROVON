static int v9fs_fid_readpage(struct p9_fid *fid, struct page *page)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nstruct bio_vec bvec = {.bv_page = page, .bv_len = PAGE_SIZE};\r\nstruct iov_iter to;\r\nint retval, err;\r\np9_debug(P9_DEBUG_VFS, "\n");\r\nBUG_ON(!PageLocked(page));\r\nretval = v9fs_readpage_from_fscache(inode, page);\r\nif (retval == 0)\r\nreturn retval;\r\niov_iter_bvec(&to, ITER_BVEC | READ, &bvec, 1, PAGE_SIZE);\r\nretval = p9_client_read(fid, page_offset(page), &to, &err);\r\nif (err) {\r\nv9fs_uncache_page(inode, page);\r\nretval = err;\r\ngoto done;\r\n}\r\nzero_user(page, retval, PAGE_SIZE - retval);\r\nflush_dcache_page(page);\r\nSetPageUptodate(page);\r\nv9fs_readpage_to_fscache(inode, page);\r\nretval = 0;\r\ndone:\r\nunlock_page(page);\r\nreturn retval;\r\n}\r\nstatic int v9fs_vfs_readpage(struct file *filp, struct page *page)\r\n{\r\nreturn v9fs_fid_readpage(filp->private_data, page);\r\n}\r\nstatic int v9fs_vfs_readpages(struct file *filp, struct address_space *mapping,\r\nstruct list_head *pages, unsigned nr_pages)\r\n{\r\nint ret = 0;\r\nstruct inode *inode;\r\ninode = mapping->host;\r\np9_debug(P9_DEBUG_VFS, "inode: %p file: %p\n", inode, filp);\r\nret = v9fs_readpages_from_fscache(inode, mapping, pages, &nr_pages);\r\nif (ret == 0)\r\nreturn ret;\r\nret = read_cache_pages(mapping, pages, (void *)v9fs_vfs_readpage, filp);\r\np9_debug(P9_DEBUG_VFS, " = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int v9fs_release_page(struct page *page, gfp_t gfp)\r\n{\r\nif (PagePrivate(page))\r\nreturn 0;\r\nreturn v9fs_fscache_release_page(page, gfp);\r\n}\r\nstatic void v9fs_invalidate_page(struct page *page, unsigned int offset,\r\nunsigned int length)\r\n{\r\nif (offset == 0 && length == PAGE_SIZE)\r\nv9fs_fscache_invalidate_page(page);\r\n}\r\nstatic int v9fs_vfs_writepage_locked(struct page *page)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nstruct v9fs_inode *v9inode = V9FS_I(inode);\r\nloff_t size = i_size_read(inode);\r\nstruct iov_iter from;\r\nstruct bio_vec bvec;\r\nint err, len;\r\nif (page->index == size >> PAGE_SHIFT)\r\nlen = size & ~PAGE_MASK;\r\nelse\r\nlen = PAGE_SIZE;\r\nbvec.bv_page = page;\r\nbvec.bv_offset = 0;\r\nbvec.bv_len = len;\r\niov_iter_bvec(&from, ITER_BVEC | WRITE, &bvec, 1, len);\r\nBUG_ON(!v9inode->writeback_fid);\r\nset_page_writeback(page);\r\np9_client_write(v9inode->writeback_fid, page_offset(page), &from, &err);\r\nend_page_writeback(page);\r\nreturn err;\r\n}\r\nstatic int v9fs_vfs_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nint retval;\r\np9_debug(P9_DEBUG_VFS, "page %p\n", page);\r\nretval = v9fs_vfs_writepage_locked(page);\r\nif (retval < 0) {\r\nif (retval == -EAGAIN) {\r\nredirty_page_for_writepage(wbc, page);\r\nretval = 0;\r\n} else {\r\nSetPageError(page);\r\nmapping_set_error(page->mapping, retval);\r\n}\r\n} else\r\nretval = 0;\r\nunlock_page(page);\r\nreturn retval;\r\n}\r\nstatic int v9fs_launder_page(struct page *page)\r\n{\r\nint retval;\r\nstruct inode *inode = page->mapping->host;\r\nv9fs_fscache_wait_on_page_write(inode, page);\r\nif (clear_page_dirty_for_io(page)) {\r\nretval = v9fs_vfs_writepage_locked(page);\r\nif (retval)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nv9fs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\r\n{\r\nstruct file *file = iocb->ki_filp;\r\nloff_t pos = iocb->ki_pos;\r\nssize_t n;\r\nint err = 0;\r\nif (iov_iter_rw(iter) == WRITE) {\r\nn = p9_client_write(file->private_data, pos, iter, &err);\r\nif (n) {\r\nstruct inode *inode = file_inode(file);\r\nloff_t i_size = i_size_read(inode);\r\nif (pos + n > i_size)\r\ninode_add_bytes(inode, pos + n - i_size);\r\n}\r\n} else {\r\nn = p9_client_read(file->private_data, pos, iter, &err);\r\n}\r\nreturn n ? n : err;\r\n}\r\nstatic int v9fs_write_begin(struct file *filp, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned flags,\r\nstruct page **pagep, void **fsdata)\r\n{\r\nint retval = 0;\r\nstruct page *page;\r\nstruct v9fs_inode *v9inode;\r\npgoff_t index = pos >> PAGE_SHIFT;\r\nstruct inode *inode = mapping->host;\r\np9_debug(P9_DEBUG_VFS, "filp %p, mapping %p\n", filp, mapping);\r\nv9inode = V9FS_I(inode);\r\nstart:\r\npage = grab_cache_page_write_begin(mapping, index, flags);\r\nif (!page) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nBUG_ON(!v9inode->writeback_fid);\r\nif (PageUptodate(page))\r\ngoto out;\r\nif (len == PAGE_SIZE)\r\ngoto out;\r\nretval = v9fs_fid_readpage(v9inode->writeback_fid, page);\r\nput_page(page);\r\nif (!retval)\r\ngoto start;\r\nout:\r\n*pagep = page;\r\nreturn retval;\r\n}\r\nstatic int v9fs_write_end(struct file *filp, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned copied,\r\nstruct page *page, void *fsdata)\r\n{\r\nloff_t last_pos = pos + copied;\r\nstruct inode *inode = page->mapping->host;\r\np9_debug(P9_DEBUG_VFS, "filp %p, mapping %p\n", filp, mapping);\r\nif (unlikely(copied < len)) {\r\nunsigned from = pos & (PAGE_SIZE - 1);\r\nzero_user(page, from + copied, len - copied);\r\nflush_dcache_page(page);\r\n}\r\nif (!PageUptodate(page))\r\nSetPageUptodate(page);\r\nif (last_pos > inode->i_size) {\r\ninode_add_bytes(inode, last_pos - inode->i_size);\r\ni_size_write(inode, last_pos);\r\n}\r\nset_page_dirty(page);\r\nunlock_page(page);\r\nput_page(page);\r\nreturn copied;\r\n}
