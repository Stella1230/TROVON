static int wcnss_ctrl_smd_callback(struct qcom_smd_channel *channel,\r\nconst void *data,\r\nsize_t count)\r\n{\r\nstruct wcnss_ctrl *wcnss = qcom_smd_get_drvdata(channel);\r\nconst struct wcnss_download_nv_resp *nvresp;\r\nconst struct wcnss_version_resp *version;\r\nconst struct wcnss_msg_hdr *hdr = data;\r\nswitch (hdr->type) {\r\ncase WCNSS_VERSION_RESP:\r\nif (count != sizeof(*version)) {\r\ndev_err(wcnss->dev,\r\n"invalid size of version response\n");\r\nbreak;\r\n}\r\nversion = data;\r\ndev_info(wcnss->dev, "WCNSS Version %d.%d %d.%d\n",\r\nversion->major, version->minor,\r\nversion->version, version->revision);\r\ncomplete(&wcnss->ack);\r\nbreak;\r\ncase WCNSS_DOWNLOAD_NV_RESP:\r\nif (count != sizeof(*nvresp)) {\r\ndev_err(wcnss->dev,\r\n"invalid size of download response\n");\r\nbreak;\r\n}\r\nnvresp = data;\r\nwcnss->ack_status = nvresp->status;\r\ncomplete(&wcnss->ack);\r\nbreak;\r\ncase WCNSS_CBC_COMPLETE_IND:\r\ndev_dbg(wcnss->dev, "cold boot complete\n");\r\ncomplete(&wcnss->cbc);\r\nbreak;\r\ndefault:\r\ndev_info(wcnss->dev, "unknown message type %d\n", hdr->type);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wcnss_request_version(struct wcnss_ctrl *wcnss)\r\n{\r\nstruct wcnss_msg_hdr msg;\r\nint ret;\r\nmsg.type = WCNSS_VERSION_REQ;\r\nmsg.len = sizeof(msg);\r\nret = qcom_smd_send(wcnss->channel, &msg, sizeof(msg));\r\nif (ret < 0)\r\nreturn ret;\r\nret = wait_for_completion_timeout(&wcnss->ack, WCNSS_CBC_TIMEOUT);\r\nif (!ret) {\r\ndev_err(wcnss->dev, "timeout waiting for version response\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wcnss_download_nv(struct wcnss_ctrl *wcnss, bool *expect_cbc)\r\n{\r\nstruct wcnss_download_nv_req *req;\r\nconst struct firmware *fw;\r\nconst void *data;\r\nssize_t left;\r\nint ret;\r\nreq = kzalloc(sizeof(*req) + NV_FRAGMENT_SIZE, GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nret = request_firmware(&fw, NVBIN_FILE, wcnss->dev);\r\nif (ret < 0) {\r\ndev_err(wcnss->dev, "Failed to load nv file %s: %d\n",\r\nNVBIN_FILE, ret);\r\ngoto free_req;\r\n}\r\ndata = fw->data;\r\nleft = fw->size;\r\nreq->hdr.type = WCNSS_DOWNLOAD_NV_REQ;\r\nreq->hdr.len = sizeof(*req) + NV_FRAGMENT_SIZE;\r\nreq->last = 0;\r\nreq->frag_size = NV_FRAGMENT_SIZE;\r\nreq->seq = 0;\r\ndo {\r\nif (left <= NV_FRAGMENT_SIZE) {\r\nreq->last = 1;\r\nreq->frag_size = left;\r\nreq->hdr.len = sizeof(*req) + left;\r\n}\r\nmemcpy(req->fragment, data, req->frag_size);\r\nret = qcom_smd_send(wcnss->channel, req, req->hdr.len);\r\nif (ret < 0) {\r\ndev_err(wcnss->dev, "failed to send smd packet\n");\r\ngoto release_fw;\r\n}\r\nreq->seq++;\r\ndata += req->hdr.len;\r\nleft -= NV_FRAGMENT_SIZE;\r\n} while (left > 0);\r\nret = wait_for_completion_timeout(&wcnss->ack, WCNSS_REQUEST_TIMEOUT);\r\nif (!ret) {\r\ndev_err(wcnss->dev, "timeout waiting for nv upload ack\n");\r\nret = -ETIMEDOUT;\r\n} else {\r\n*expect_cbc = wcnss->ack_status == WCNSS_ACK_COLD_BOOTING;\r\nret = 0;\r\n}\r\nrelease_fw:\r\nrelease_firmware(fw);\r\nfree_req:\r\nkfree(req);\r\nreturn ret;\r\n}\r\nstruct qcom_smd_channel *qcom_wcnss_open_channel(void *wcnss, const char *name, qcom_smd_cb_t cb)\r\n{\r\nstruct wcnss_ctrl *_wcnss = wcnss;\r\nreturn qcom_smd_open_channel(_wcnss->channel, name, cb);\r\n}\r\nstatic void wcnss_async_probe(struct work_struct *work)\r\n{\r\nstruct wcnss_ctrl *wcnss = container_of(work, struct wcnss_ctrl, probe_work);\r\nbool expect_cbc;\r\nint ret;\r\nret = wcnss_request_version(wcnss);\r\nif (ret < 0)\r\nreturn;\r\nret = wcnss_download_nv(wcnss, &expect_cbc);\r\nif (ret < 0)\r\nreturn;\r\nif (expect_cbc) {\r\nret = wait_for_completion_timeout(&wcnss->cbc, WCNSS_REQUEST_TIMEOUT);\r\nif (!ret)\r\ndev_err(wcnss->dev, "expected cold boot completion\n");\r\n}\r\nof_platform_populate(wcnss->dev->of_node, NULL, NULL, wcnss->dev);\r\n}\r\nstatic int wcnss_ctrl_probe(struct qcom_smd_device *sdev)\r\n{\r\nstruct wcnss_ctrl *wcnss;\r\nwcnss = devm_kzalloc(&sdev->dev, sizeof(*wcnss), GFP_KERNEL);\r\nif (!wcnss)\r\nreturn -ENOMEM;\r\nwcnss->dev = &sdev->dev;\r\nwcnss->channel = sdev->channel;\r\ninit_completion(&wcnss->ack);\r\ninit_completion(&wcnss->cbc);\r\nINIT_WORK(&wcnss->probe_work, wcnss_async_probe);\r\nqcom_smd_set_drvdata(sdev->channel, wcnss);\r\ndev_set_drvdata(&sdev->dev, wcnss);\r\nschedule_work(&wcnss->probe_work);\r\nreturn 0;\r\n}\r\nstatic void wcnss_ctrl_remove(struct qcom_smd_device *sdev)\r\n{\r\nstruct wcnss_ctrl *wcnss = qcom_smd_get_drvdata(sdev->channel);\r\ncancel_work_sync(&wcnss->probe_work);\r\nof_platform_depopulate(&sdev->dev);\r\n}
