static inline void cc10001_adc_write_reg(struct cc10001_adc_device *adc_dev,\r\nu32 reg, u32 val)\r\n{\r\nwritel(val, adc_dev->reg_base + reg);\r\n}\r\nstatic inline u32 cc10001_adc_read_reg(struct cc10001_adc_device *adc_dev,\r\nu32 reg)\r\n{\r\nreturn readl(adc_dev->reg_base + reg);\r\n}\r\nstatic void cc10001_adc_power_up(struct cc10001_adc_device *adc_dev)\r\n{\r\ncc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_DOWN, 0);\r\nndelay(adc_dev->start_delay_ns);\r\n}\r\nstatic void cc10001_adc_power_down(struct cc10001_adc_device *adc_dev)\r\n{\r\ncc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_DOWN,\r\nCC10001_ADC_POWER_DOWN_SET);\r\n}\r\nstatic void cc10001_adc_start(struct cc10001_adc_device *adc_dev,\r\nunsigned int channel)\r\n{\r\nu32 val;\r\nval = (channel & CC10001_ADC_CH_MASK) | CC10001_ADC_MODE_SINGLE_CONV;\r\ncc10001_adc_write_reg(adc_dev, CC10001_ADC_CONFIG, val);\r\nudelay(1);\r\nval = cc10001_adc_read_reg(adc_dev, CC10001_ADC_CONFIG);\r\nval = val | CC10001_ADC_START_CONV;\r\ncc10001_adc_write_reg(adc_dev, CC10001_ADC_CONFIG, val);\r\n}\r\nstatic u16 cc10001_adc_poll_done(struct iio_dev *indio_dev,\r\nunsigned int channel,\r\nunsigned int delay)\r\n{\r\nstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\r\nunsigned int poll_count = 0;\r\nwhile (!(cc10001_adc_read_reg(adc_dev, CC10001_ADC_EOC) &\r\nCC10001_ADC_EOC_SET)) {\r\nndelay(delay);\r\nif (poll_count++ == CC10001_MAX_POLL_COUNT)\r\nreturn CC10001_INVALID_SAMPLED;\r\n}\r\npoll_count = 0;\r\nwhile ((cc10001_adc_read_reg(adc_dev, CC10001_ADC_CHSEL_SAMPLED) &\r\nCC10001_ADC_CH_MASK) != channel) {\r\nndelay(delay);\r\nif (poll_count++ == CC10001_MAX_POLL_COUNT)\r\nreturn CC10001_INVALID_SAMPLED;\r\n}\r\nreturn cc10001_adc_read_reg(adc_dev, CC10001_ADC_DDATA_OUT) &\r\nCC10001_ADC_DATA_MASK;\r\n}\r\nstatic irqreturn_t cc10001_adc_trigger_h(int irq, void *p)\r\n{\r\nstruct cc10001_adc_device *adc_dev;\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev;\r\nunsigned int delay_ns;\r\nunsigned int channel;\r\nunsigned int scan_idx;\r\nbool sample_invalid;\r\nu16 *data;\r\nint i;\r\nindio_dev = pf->indio_dev;\r\nadc_dev = iio_priv(indio_dev);\r\ndata = adc_dev->buf;\r\nmutex_lock(&adc_dev->lock);\r\nif (!adc_dev->shared)\r\ncc10001_adc_power_up(adc_dev);\r\ndelay_ns = adc_dev->eoc_delay_ns / CC10001_MAX_POLL_COUNT;\r\ni = 0;\r\nsample_invalid = false;\r\nfor_each_set_bit(scan_idx, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nchannel = indio_dev->channels[scan_idx].channel;\r\ncc10001_adc_start(adc_dev, channel);\r\ndata[i] = cc10001_adc_poll_done(indio_dev, channel, delay_ns);\r\nif (data[i] == CC10001_INVALID_SAMPLED) {\r\ndev_warn(&indio_dev->dev,\r\n"invalid sample on channel %d\n", channel);\r\nsample_invalid = true;\r\ngoto done;\r\n}\r\ni++;\r\n}\r\ndone:\r\nif (!adc_dev->shared)\r\ncc10001_adc_power_down(adc_dev);\r\nmutex_unlock(&adc_dev->lock);\r\nif (!sample_invalid)\r\niio_push_to_buffers_with_timestamp(indio_dev, data,\r\niio_get_time_ns(indio_dev));\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u16 cc10001_adc_read_raw_voltage(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\r\nunsigned int delay_ns;\r\nu16 val;\r\nif (!adc_dev->shared)\r\ncc10001_adc_power_up(adc_dev);\r\ndelay_ns = adc_dev->eoc_delay_ns / CC10001_MAX_POLL_COUNT;\r\ncc10001_adc_start(adc_dev, chan->channel);\r\nval = cc10001_adc_poll_done(indio_dev, chan->channel, delay_ns);\r\nif (!adc_dev->shared)\r\ncc10001_adc_power_down(adc_dev);\r\nreturn val;\r\n}\r\nstatic int cc10001_adc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (iio_buffer_enabled(indio_dev))\r\nreturn -EBUSY;\r\nmutex_lock(&adc_dev->lock);\r\n*val = cc10001_adc_read_raw_voltage(indio_dev, chan);\r\nmutex_unlock(&adc_dev->lock);\r\nif (*val == CC10001_INVALID_SAMPLED)\r\nreturn -EIO;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = regulator_get_voltage(adc_dev->reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret / 1000;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int cc10001_update_scan_mode(struct iio_dev *indio_dev,\r\nconst unsigned long *scan_mask)\r\n{\r\nstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\r\nkfree(adc_dev->buf);\r\nadc_dev->buf = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);\r\nif (!adc_dev->buf)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int cc10001_adc_channel_init(struct iio_dev *indio_dev,\r\nunsigned long channel_map)\r\n{\r\nstruct iio_chan_spec *chan_array, *timestamp;\r\nunsigned int bit, idx = 0;\r\nindio_dev->num_channels = bitmap_weight(&channel_map,\r\nCC10001_ADC_NUM_CHANNELS) + 1;\r\nchan_array = devm_kcalloc(&indio_dev->dev, indio_dev->num_channels,\r\nsizeof(struct iio_chan_spec),\r\nGFP_KERNEL);\r\nif (!chan_array)\r\nreturn -ENOMEM;\r\nfor_each_set_bit(bit, &channel_map, CC10001_ADC_NUM_CHANNELS) {\r\nstruct iio_chan_spec *chan = &chan_array[idx];\r\nchan->type = IIO_VOLTAGE;\r\nchan->indexed = 1;\r\nchan->channel = bit;\r\nchan->scan_index = idx;\r\nchan->scan_type.sign = 'u';\r\nchan->scan_type.realbits = 10;\r\nchan->scan_type.storagebits = 16;\r\nchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\r\nchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\r\nidx++;\r\n}\r\ntimestamp = &chan_array[idx];\r\ntimestamp->type = IIO_TIMESTAMP;\r\ntimestamp->channel = -1;\r\ntimestamp->scan_index = idx;\r\ntimestamp->scan_type.sign = 's';\r\ntimestamp->scan_type.realbits = 64;\r\ntimestamp->scan_type.storagebits = 64;\r\nindio_dev->channels = chan_array;\r\nreturn 0;\r\n}\r\nstatic int cc10001_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct cc10001_adc_device *adc_dev;\r\nunsigned long adc_clk_rate;\r\nstruct resource *res;\r\nstruct iio_dev *indio_dev;\r\nunsigned long channel_map;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc_dev));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nadc_dev = iio_priv(indio_dev);\r\nchannel_map = GENMASK(CC10001_ADC_NUM_CHANNELS - 1, 0);\r\nif (!of_property_read_u32(node, "adc-reserved-channels", &ret)) {\r\nadc_dev->shared = true;\r\nchannel_map &= ~ret;\r\n}\r\nadc_dev->reg = devm_regulator_get(&pdev->dev, "vref");\r\nif (IS_ERR(adc_dev->reg))\r\nreturn PTR_ERR(adc_dev->reg);\r\nret = regulator_enable(adc_dev->reg);\r\nif (ret)\r\nreturn ret;\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->info = &cc10001_adc_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nadc_dev->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(adc_dev->reg_base)) {\r\nret = PTR_ERR(adc_dev->reg_base);\r\ngoto err_disable_reg;\r\n}\r\nadc_dev->adc_clk = devm_clk_get(&pdev->dev, "adc");\r\nif (IS_ERR(adc_dev->adc_clk)) {\r\ndev_err(&pdev->dev, "failed to get the clock\n");\r\nret = PTR_ERR(adc_dev->adc_clk);\r\ngoto err_disable_reg;\r\n}\r\nret = clk_prepare_enable(adc_dev->adc_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable the clock\n");\r\ngoto err_disable_reg;\r\n}\r\nadc_clk_rate = clk_get_rate(adc_dev->adc_clk);\r\nif (!adc_clk_rate) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "null clock rate!\n");\r\ngoto err_disable_clk;\r\n}\r\nadc_dev->eoc_delay_ns = NSEC_PER_SEC / adc_clk_rate;\r\nadc_dev->start_delay_ns = adc_dev->eoc_delay_ns * CC10001_WAIT_CYCLES;\r\nif (adc_dev->shared)\r\ncc10001_adc_power_up(adc_dev);\r\nret = cc10001_adc_channel_init(indio_dev, channel_map);\r\nif (ret < 0)\r\ngoto err_disable_clk;\r\nmutex_init(&adc_dev->lock);\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\n&cc10001_adc_trigger_h, NULL);\r\nif (ret < 0)\r\ngoto err_disable_clk;\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto err_cleanup_buffer;\r\nplatform_set_drvdata(pdev, indio_dev);\r\nreturn 0;\r\nerr_cleanup_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerr_disable_clk:\r\nclk_disable_unprepare(adc_dev->adc_clk);\r\nerr_disable_reg:\r\nregulator_disable(adc_dev->reg);\r\nreturn ret;\r\n}\r\nstatic int cc10001_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct cc10001_adc_device *adc_dev = iio_priv(indio_dev);\r\ncc10001_adc_power_down(adc_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nclk_disable_unprepare(adc_dev->adc_clk);\r\nregulator_disable(adc_dev->reg);\r\nreturn 0;\r\n}
