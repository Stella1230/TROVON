static void omap_mcbsp_set_threshold(struct snd_pcm_substream *substream,\r\nunsigned int packet_size)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nint words;\r\nif (packet_size)\r\nwords = packet_size;\r\nelse\r\nwords = 1;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nomap_mcbsp_set_tx_threshold(mcbsp, words);\r\nelse\r\nomap_mcbsp_set_rx_threshold(mcbsp, words);\r\n}\r\nstatic int omap_mcbsp_hwrule_min_buffersize(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *buffer_size = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct omap_mcbsp *mcbsp = rule->private;\r\nstruct snd_interval frames;\r\nint size;\r\nsnd_interval_any(&frames);\r\nsize = mcbsp->pdata->buffer_size;\r\nframes.min = size / channels->min;\r\nframes.integer = 1;\r\nreturn snd_interval_refine(buffer_size, &frames);\r\n}\r\nstatic int omap_mcbsp_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nint err = 0;\r\nif (!cpu_dai->active)\r\nerr = omap_mcbsp_request(mcbsp);\r\nif (mcbsp->pdata->buffer_size) {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\nomap_mcbsp_hwrule_min_buffersize,\r\nmcbsp,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nsnd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, 2);\r\n}\r\nreturn err;\r\n}\r\nstatic void omap_mcbsp_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nif (!cpu_dai->active) {\r\nomap_mcbsp_free(mcbsp);\r\nmcbsp->configured = 0;\r\n}\r\n}\r\nstatic int omap_mcbsp_dai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nint err = 0, play = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nmcbsp->active++;\r\nomap_mcbsp_start(mcbsp, play, !play);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nomap_mcbsp_stop(mcbsp, play, !play);\r\nmcbsp->active--;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic snd_pcm_sframes_t omap_mcbsp_dai_delay(\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nu16 fifo_use;\r\nsnd_pcm_sframes_t delay;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfifo_use = omap_mcbsp_get_tx_delay(mcbsp);\r\nelse\r\nfifo_use = omap_mcbsp_get_rx_delay(mcbsp);\r\ndelay = fifo_use / substream->runtime->channels;\r\nreturn delay;\r\n}\r\nstatic int omap_mcbsp_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct omap_mcbsp_reg_cfg *regs = &mcbsp->cfg_regs;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint wlen, channels, wpf;\r\nint pkt_size = 0;\r\nunsigned int format, div, framesize, master;\r\ndma_data = snd_soc_dai_get_dma_data(cpu_dai, substream);\r\nchannels = params_channels(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nwlen = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nwlen = 32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (mcbsp->pdata->buffer_size) {\r\nif (mcbsp->dma_op_mode == MCBSP_DMA_MODE_THRESHOLD) {\r\nint period_words, max_thrsh;\r\nint divider = 0;\r\nperiod_words = params_period_bytes(params) / (wlen / 8);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nmax_thrsh = mcbsp->max_tx_thres;\r\nelse\r\nmax_thrsh = mcbsp->max_rx_thres;\r\ndivider = period_words / max_thrsh;\r\nif (period_words % max_thrsh)\r\ndivider++;\r\nwhile (period_words % divider &&\r\ndivider < period_words)\r\ndivider++;\r\nif (divider == period_words)\r\nreturn -EINVAL;\r\npkt_size = period_words / divider;\r\n} else if (channels > 1) {\r\npkt_size = channels;\r\n}\r\nomap_mcbsp_set_threshold(substream, pkt_size);\r\n}\r\ndma_data->maxburst = pkt_size;\r\nif (mcbsp->configured) {\r\nreturn 0;\r\n}\r\nregs->rcr2 &= ~(RPHASE | RFRLEN2(0x7f) | RWDLEN2(7));\r\nregs->xcr2 &= ~(RPHASE | XFRLEN2(0x7f) | XWDLEN2(7));\r\nregs->rcr1 &= ~(RFRLEN1(0x7f) | RWDLEN1(7));\r\nregs->xcr1 &= ~(XFRLEN1(0x7f) | XWDLEN1(7));\r\nformat = mcbsp->fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nwpf = channels;\r\nif (channels == 2 && (format == SND_SOC_DAIFMT_I2S ||\r\nformat == SND_SOC_DAIFMT_LEFT_J)) {\r\nregs->rcr2 |= RPHASE;\r\nregs->xcr2 |= XPHASE;\r\nwpf--;\r\nregs->rcr2 |= RFRLEN2(wpf - 1);\r\nregs->xcr2 |= XFRLEN2(wpf - 1);\r\n}\r\nregs->rcr1 |= RFRLEN1(wpf - 1);\r\nregs->xcr1 |= XFRLEN1(wpf - 1);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nregs->rcr2 |= RWDLEN2(OMAP_MCBSP_WORD_16);\r\nregs->rcr1 |= RWDLEN1(OMAP_MCBSP_WORD_16);\r\nregs->xcr2 |= XWDLEN2(OMAP_MCBSP_WORD_16);\r\nregs->xcr1 |= XWDLEN1(OMAP_MCBSP_WORD_16);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nregs->rcr2 |= RWDLEN2(OMAP_MCBSP_WORD_32);\r\nregs->rcr1 |= RWDLEN1(OMAP_MCBSP_WORD_32);\r\nregs->xcr2 |= XWDLEN2(OMAP_MCBSP_WORD_32);\r\nregs->xcr1 |= XWDLEN1(OMAP_MCBSP_WORD_32);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmaster = mcbsp->fmt & SND_SOC_DAIFMT_MASTER_MASK;\r\nif (master == SND_SOC_DAIFMT_CBS_CFS) {\r\ndiv = mcbsp->clk_div ? mcbsp->clk_div : 1;\r\nframesize = (mcbsp->in_freq / div) / params_rate(params);\r\nif (framesize < wlen * channels) {\r\nprintk(KERN_ERR "%s: not enough bandwidth for desired rate and "\r\n"channels\n", __func__);\r\nreturn -EINVAL;\r\n}\r\n} else\r\nframesize = wlen * channels;\r\nregs->srgr2 &= ~FPER(0xfff);\r\nregs->srgr1 &= ~FWID(0xff);\r\nswitch (format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nregs->srgr2 |= FPER(framesize - 1);\r\nregs->srgr1 |= FWID((framesize >> 1) - 1);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nregs->srgr2 |= FPER(framesize - 1);\r\nregs->srgr1 |= FWID(0);\r\nbreak;\r\n}\r\nomap_mcbsp_config(mcbsp, &mcbsp->cfg_regs);\r\nmcbsp->wlen = wlen;\r\nmcbsp->configured = 1;\r\nreturn 0;\r\n}\r\nstatic int omap_mcbsp_dai_set_dai_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct omap_mcbsp_reg_cfg *regs = &mcbsp->cfg_regs;\r\nbool inv_fs = false;\r\nif (mcbsp->configured)\r\nreturn 0;\r\nmcbsp->fmt = fmt;\r\nmemset(regs, 0, sizeof(*regs));\r\nregs->spcr2 |= XINTM(3) | FREE;\r\nregs->spcr1 |= RINTM(3);\r\nif (!mcbsp->pdata->has_ccr) {\r\nregs->rcr2 |= RFIG;\r\nregs->xcr2 |= XFIG;\r\n}\r\nif (mcbsp->pdata->has_ccr) {\r\nregs->xccr = DXENDLY(1) | XDMAEN | XDISABLE;\r\nregs->rccr = RFULL_CYCLE | RDMAEN | RDISABLE;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nregs->rcr2 |= RDATDLY(1);\r\nregs->xcr2 |= XDATDLY(1);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nregs->rcr2 |= RDATDLY(0);\r\nregs->xcr2 |= XDATDLY(0);\r\nregs->spcr1 |= RJUST(2);\r\ninv_fs = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nregs->rcr2 |= RDATDLY(1);\r\nregs->xcr2 |= XDATDLY(1);\r\ninv_fs = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nregs->rcr2 |= RDATDLY(0);\r\nregs->xcr2 |= XDATDLY(0);\r\ninv_fs = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nregs->pcr0 |= FSXM | FSRM |\r\nCLKXM | CLKRM;\r\nregs->srgr2 |= FSGM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nregs->srgr2 |= FSGM;\r\nregs->pcr0 |= FSXM | FSRM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nregs->pcr0 |= FSXP | FSRP |\r\nCLKXP | CLKRP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nregs->pcr0 |= CLKXP | CLKRP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nregs->pcr0 |= FSXP | FSRP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (inv_fs == true)\r\nregs->pcr0 ^= FSXP | FSRP;\r\nreturn 0;\r\n}\r\nstatic int omap_mcbsp_dai_set_clkdiv(struct snd_soc_dai *cpu_dai,\r\nint div_id, int div)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct omap_mcbsp_reg_cfg *regs = &mcbsp->cfg_regs;\r\nif (div_id != OMAP_MCBSP_CLKGDV)\r\nreturn -ENODEV;\r\nmcbsp->clk_div = div;\r\nregs->srgr1 &= ~CLKGDV(0xff);\r\nregs->srgr1 |= CLKGDV(div - 1);\r\nreturn 0;\r\n}\r\nstatic int omap_mcbsp_dai_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq,\r\nint dir)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct omap_mcbsp_reg_cfg *regs = &mcbsp->cfg_regs;\r\nint err = 0;\r\nif (mcbsp->active) {\r\nif (freq == mcbsp->in_freq)\r\nreturn 0;\r\nelse\r\nreturn -EBUSY;\r\n}\r\nmcbsp->in_freq = freq;\r\nregs->srgr2 &= ~CLKSM;\r\nregs->pcr0 &= ~SCLKME;\r\nswitch (clk_id) {\r\ncase OMAP_MCBSP_SYSCLK_CLK:\r\nregs->srgr2 |= CLKSM;\r\nbreak;\r\ncase OMAP_MCBSP_SYSCLK_CLKS_FCLK:\r\nif (mcbsp_omap1()) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = omap2_mcbsp_set_clks_src(mcbsp,\r\nMCBSP_CLKS_PRCM_SRC);\r\nbreak;\r\ncase OMAP_MCBSP_SYSCLK_CLKS_EXT:\r\nif (mcbsp_omap1()) {\r\nerr = 0;\r\nbreak;\r\n}\r\nerr = omap2_mcbsp_set_clks_src(mcbsp,\r\nMCBSP_CLKS_PAD_SRC);\r\nbreak;\r\ncase OMAP_MCBSP_SYSCLK_CLKX_EXT:\r\nregs->srgr2 |= CLKSM;\r\nregs->pcr0 |= SCLKME;\r\nregs->pcr0 &= ~CLKXM;\r\nbreak;\r\ncase OMAP_MCBSP_SYSCLK_CLKR_EXT:\r\nregs->pcr0 |= SCLKME;\r\nregs->pcr0 &= ~CLKRM;\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\n}\r\nreturn err;\r\n}\r\nstatic int omap_mcbsp_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(dai);\r\npm_runtime_enable(mcbsp->dev);\r\nsnd_soc_dai_init_dma_data(dai,\r\n&mcbsp->dma_data[SNDRV_PCM_STREAM_PLAYBACK],\r\n&mcbsp->dma_data[SNDRV_PCM_STREAM_CAPTURE]);\r\nreturn 0;\r\n}\r\nstatic int omap_mcbsp_remove(struct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(dai);\r\npm_runtime_disable(mcbsp->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_mcbsp_st_info_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nint max = mc->max;\r\nint min = mc->min;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = min;\r\nuinfo->value.integer.max = max;\r\nreturn 0;\r\n}\r\nstatic int omap_mcbsp_st_put_mode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nu8 value = ucontrol->value.integer.value[0];\r\nif (value == omap_st_is_enabled(mcbsp))\r\nreturn 0;\r\nif (value)\r\nomap_st_enable(mcbsp);\r\nelse\r\nomap_st_disable(mcbsp);\r\nreturn 1;\r\n}\r\nstatic int omap_mcbsp_st_get_mode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nucontrol->value.integer.value[0] = omap_st_is_enabled(mcbsp);\r\nreturn 0;\r\n}\r\nint omap_mcbsp_st_add_controls(struct snd_soc_pcm_runtime *rtd, int port_id)\r\n{\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\r\nif (!mcbsp->st_data) {\r\ndev_warn(mcbsp->dev, "No sidetone data for port\n");\r\nreturn 0;\r\n}\r\nswitch (port_id) {\r\ncase 2:\r\nreturn snd_soc_add_dai_controls(cpu_dai,\r\nomap_mcbsp2_st_controls,\r\nARRAY_SIZE(omap_mcbsp2_st_controls));\r\ncase 3:\r\nreturn snd_soc_add_dai_controls(cpu_dai,\r\nomap_mcbsp3_st_controls,\r\nARRAY_SIZE(omap_mcbsp3_st_controls));\r\ndefault:\r\ndev_err(mcbsp->dev, "Port %d not supported\n", port_id);\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int asoc_mcbsp_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_mcbsp_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct omap_mcbsp *mcbsp;\r\nconst struct of_device_id *match;\r\nint ret;\r\nmatch = of_match_device(omap_mcbsp_of_match, &pdev->dev);\r\nif (match) {\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct omap_mcbsp_platform_data *pdata_quirk = pdata;\r\nint buffer_size;\r\npdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct omap_mcbsp_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nmemcpy(pdata, match->data, sizeof(*pdata));\r\nif (!of_property_read_u32(node, "ti,buffer-size", &buffer_size))\r\npdata->buffer_size = buffer_size;\r\nif (pdata_quirk)\r\npdata->force_ick_on = pdata_quirk->force_ick_on;\r\n} else if (!pdata) {\r\ndev_err(&pdev->dev, "missing platform data.\n");\r\nreturn -EINVAL;\r\n}\r\nmcbsp = devm_kzalloc(&pdev->dev, sizeof(struct omap_mcbsp), GFP_KERNEL);\r\nif (!mcbsp)\r\nreturn -ENOMEM;\r\nmcbsp->id = pdev->id;\r\nmcbsp->pdata = pdata;\r\nmcbsp->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, mcbsp);\r\nret = omap_mcbsp_init(pdev);\r\nif (ret)\r\nreturn ret;\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&omap_mcbsp_component,\r\n&omap_mcbsp_dai, 1);\r\nif (ret)\r\nreturn ret;\r\nreturn omap_pcm_platform_register(&pdev->dev);\r\n}\r\nstatic int asoc_mcbsp_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_mcbsp *mcbsp = platform_get_drvdata(pdev);\r\nif (mcbsp->pdata->ops && mcbsp->pdata->ops->free)\r\nmcbsp->pdata->ops->free(mcbsp->id);\r\nomap_mcbsp_cleanup(mcbsp);\r\nclk_put(mcbsp->fclk);\r\nreturn 0;\r\n}
