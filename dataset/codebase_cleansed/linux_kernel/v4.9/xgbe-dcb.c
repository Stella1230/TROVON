static int xgbe_dcb_ieee_getets(struct net_device *netdev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nets->ets_cap = pdata->hw_feat.tc_cnt;\r\nif (pdata->ets) {\r\nets->cbs = pdata->ets->cbs;\r\nmemcpy(ets->tc_tx_bw, pdata->ets->tc_tx_bw,\r\nsizeof(ets->tc_tx_bw));\r\nmemcpy(ets->tc_tsa, pdata->ets->tc_tsa,\r\nsizeof(ets->tc_tsa));\r\nmemcpy(ets->prio_tc, pdata->ets->prio_tc,\r\nsizeof(ets->prio_tc));\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_dcb_ieee_setets(struct net_device *netdev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nunsigned int i, tc_ets, tc_ets_weight;\r\nu8 max_tc = 0;\r\ntc_ets = 0;\r\ntc_ets_weight = 0;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nnetif_dbg(pdata, drv, netdev,\r\n"TC%u: tx_bw=%hhu, rx_bw=%hhu, tsa=%hhu\n", i,\r\nets->tc_tx_bw[i], ets->tc_rx_bw[i],\r\nets->tc_tsa[i]);\r\nnetif_dbg(pdata, drv, netdev, "PRIO%u: TC=%hhu\n", i,\r\nets->prio_tc[i]);\r\nmax_tc = max_t(u8, max_tc, ets->prio_tc[i]);\r\nif ((ets->tc_tx_bw[i] || ets->tc_tsa[i]))\r\nmax_tc = max_t(u8, max_tc, i);\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\ntc_ets = 1;\r\ntc_ets_weight += ets->tc_tx_bw[i];\r\nbreak;\r\ndefault:\r\nnetif_err(pdata, drv, netdev,\r\n"unsupported TSA algorithm (%hhu)\n",\r\nets->tc_tsa[i]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (max_tc >= pdata->hw_feat.tc_cnt) {\r\nnetif_err(pdata, drv, netdev,\r\n"exceeded number of supported traffic classes\n");\r\nreturn -EINVAL;\r\n}\r\nif (tc_ets && (tc_ets_weight != 100)) {\r\nnetif_err(pdata, drv, netdev,\r\n"sum of ETS algorithm weights is not 100 (%u)\n",\r\ntc_ets_weight);\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->ets) {\r\npdata->ets = devm_kzalloc(pdata->dev, sizeof(*pdata->ets),\r\nGFP_KERNEL);\r\nif (!pdata->ets)\r\nreturn -ENOMEM;\r\n}\r\npdata->num_tcs = max_tc + 1;\r\nmemcpy(pdata->ets, ets, sizeof(*pdata->ets));\r\npdata->hw_if.config_dcb_tc(pdata);\r\nreturn 0;\r\n}\r\nstatic int xgbe_dcb_ieee_getpfc(struct net_device *netdev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\npfc->pfc_cap = pdata->hw_feat.tc_cnt;\r\nif (pdata->pfc) {\r\npfc->pfc_en = pdata->pfc->pfc_en;\r\npfc->mbc = pdata->pfc->mbc;\r\npfc->delay = pdata->pfc->delay;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_dcb_ieee_setpfc(struct net_device *netdev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nnetif_dbg(pdata, drv, netdev,\r\n"cap=%hhu, en=%#hhx, mbc=%hhu, delay=%hhu\n",\r\npfc->pfc_cap, pfc->pfc_en, pfc->mbc, pfc->delay);\r\nif (pfc->pfc_en & ~((1 << pdata->hw_feat.tc_cnt) - 1)) {\r\nnetif_err(pdata, drv, netdev,\r\n"PFC requested for unsupported traffic class\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->pfc) {\r\npdata->pfc = devm_kzalloc(pdata->dev, sizeof(*pdata->pfc),\r\nGFP_KERNEL);\r\nif (!pdata->pfc)\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(pdata->pfc, pfc, sizeof(*pdata->pfc));\r\npdata->hw_if.config_dcb_pfc(pdata);\r\nreturn 0;\r\n}\r\nstatic u8 xgbe_dcb_getdcbx(struct net_device *netdev)\r\n{\r\nreturn DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;\r\n}\r\nstatic u8 xgbe_dcb_setdcbx(struct net_device *netdev, u8 dcbx)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nu8 support = xgbe_dcb_getdcbx(netdev);\r\nnetif_dbg(pdata, drv, netdev, "DCBX=%#hhx\n", dcbx);\r\nif (dcbx & ~support)\r\nreturn 1;\r\nif ((dcbx & support) != support)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nconst struct dcbnl_rtnl_ops *xgbe_get_dcbnl_ops(void)\r\n{\r\nreturn &xgbe_dcbnl_ops;\r\n}
