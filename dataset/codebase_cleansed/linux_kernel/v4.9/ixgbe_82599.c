bool ixgbe_mng_enabled(struct ixgbe_hw *hw)\r\n{\r\nu32 fwsm, manc, factps;\r\nfwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));\r\nif ((fwsm & IXGBE_FWSM_MODE_MASK) != IXGBE_FWSM_FW_MODE_PT)\r\nreturn false;\r\nmanc = IXGBE_READ_REG(hw, IXGBE_MANC);\r\nif (!(manc & IXGBE_MANC_RCV_TCO_EN))\r\nreturn false;\r\nfactps = IXGBE_READ_REG(hw, IXGBE_FACTPS(hw));\r\nif (factps & IXGBE_FACTPS_MNGCG)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mac_info *mac = &hw->mac;\r\nif ((mac->ops.get_media_type(hw) == ixgbe_media_type_fiber) &&\r\n!ixgbe_mng_enabled(hw)) {\r\nmac->ops.disable_tx_laser =\r\n&ixgbe_disable_tx_laser_multispeed_fiber;\r\nmac->ops.enable_tx_laser =\r\n&ixgbe_enable_tx_laser_multispeed_fiber;\r\nmac->ops.flap_tx_laser = &ixgbe_flap_tx_laser_multispeed_fiber;\r\n} else {\r\nmac->ops.disable_tx_laser = NULL;\r\nmac->ops.enable_tx_laser = NULL;\r\nmac->ops.flap_tx_laser = NULL;\r\n}\r\nif (hw->phy.multispeed_fiber) {\r\nmac->ops.setup_link = &ixgbe_setup_mac_link_multispeed_fiber;\r\nmac->ops.setup_mac_link = ixgbe_setup_mac_link_82599;\r\nmac->ops.set_rate_select_speed =\r\nixgbe_set_hard_rate_select_speed;\r\n} else {\r\nif ((mac->ops.get_media_type(hw) ==\r\nixgbe_media_type_backplane) &&\r\n(hw->phy.smart_speed == ixgbe_smart_speed_auto ||\r\nhw->phy.smart_speed == ixgbe_smart_speed_on) &&\r\n!ixgbe_verify_lesm_fw_enabled_82599(hw))\r\nmac->ops.setup_link = &ixgbe_setup_mac_link_smartspeed;\r\nelse\r\nmac->ops.setup_link = &ixgbe_setup_mac_link_82599;\r\n}\r\n}\r\nstatic s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 list_offset, data_offset, data_value;\r\nif (hw->phy.sfp_type != ixgbe_sfp_type_unknown) {\r\nixgbe_init_mac_link_ops_82599(hw);\r\nhw->phy.ops.reset = NULL;\r\nret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,\r\n&data_offset);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = hw->mac.ops.acquire_swfw_sync(hw,\r\nIXGBE_GSSR_MAC_CSR_SM);\r\nif (ret_val)\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nif (hw->eeprom.ops.read(hw, ++data_offset, &data_value))\r\ngoto setup_sfp_err;\r\nwhile (data_value != 0xffff) {\r\nIXGBE_WRITE_REG(hw, IXGBE_CORECTL, data_value);\r\nIXGBE_WRITE_FLUSH(hw);\r\nif (hw->eeprom.ops.read(hw, ++data_offset, &data_value))\r\ngoto setup_sfp_err;\r\n}\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);\r\nusleep_range(hw->eeprom.semaphore_delay * 1000,\r\nhw->eeprom.semaphore_delay * 2000);\r\nret_val = hw->mac.ops.prot_autoc_write(hw,\r\nhw->mac.orig_autoc | IXGBE_AUTOC_LMS_10G_SERIAL,\r\nfalse);\r\nif (ret_val) {\r\nhw_dbg(hw, " sfp module setup not complete\n");\r\nreturn IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;\r\n}\r\n}\r\nreturn 0;\r\nsetup_sfp_err:\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);\r\nusleep_range(hw->eeprom.semaphore_delay * 1000,\r\nhw->eeprom.semaphore_delay * 2000);\r\nhw_err(hw, "eeprom read at offset %d failed\n", data_offset);\r\nreturn IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;\r\n}\r\nstatic s32 prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked,\r\nu32 *reg_val)\r\n{\r\ns32 ret_val;\r\n*locked = false;\r\nif (ixgbe_verify_lesm_fw_enabled_82599(hw)) {\r\nret_val = hw->mac.ops.acquire_swfw_sync(hw,\r\nIXGBE_GSSR_MAC_CSR_SM);\r\nif (ret_val)\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\n*locked = true;\r\n}\r\n*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nreturn 0;\r\n}\r\nstatic s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 autoc, bool locked)\r\n{\r\ns32 ret_val = 0;\r\nif (ixgbe_check_reset_blocked(hw))\r\ngoto out;\r\nif (!locked && ixgbe_verify_lesm_fw_enabled_82599(hw)) {\r\nret_val = hw->mac.ops.acquire_swfw_sync(hw,\r\nIXGBE_GSSR_MAC_CSR_SM);\r\nif (ret_val)\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nlocked = true;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);\r\nret_val = ixgbe_reset_pipeline_82599(hw);\r\nout:\r\nif (locked)\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbe_get_invariants_82599(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mac_info *mac = &hw->mac;\r\nixgbe_init_mac_link_ops_82599(hw);\r\nmac->mcft_size = IXGBE_82599_MC_TBL_SIZE;\r\nmac->vft_size = IXGBE_82599_VFT_TBL_SIZE;\r\nmac->num_rar_entries = IXGBE_82599_RAR_ENTRIES;\r\nmac->rx_pb_size = IXGBE_82599_RX_PB_SIZE;\r\nmac->max_rx_queues = IXGBE_82599_MAX_RX_QUEUES;\r\nmac->max_tx_queues = IXGBE_82599_MAX_TX_QUEUES;\r\nmac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mac_info *mac = &hw->mac;\r\nstruct ixgbe_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nu32 esdp;\r\nif (hw->device_id == IXGBE_DEV_ID_82599_QSFP_SF_QP) {\r\nhw->phy.qsfp_shared_i2c_bus = true;\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nesdp |= IXGBE_ESDP_SDP0_DIR;\r\nesdp &= ~IXGBE_ESDP_SDP1_DIR;\r\nesdp &= ~IXGBE_ESDP_SDP0;\r\nesdp &= ~IXGBE_ESDP_SDP0_NATIVE;\r\nesdp &= ~IXGBE_ESDP_SDP1_NATIVE;\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\r\nIXGBE_WRITE_FLUSH(hw);\r\nphy->ops.read_i2c_byte = &ixgbe_read_i2c_byte_82599;\r\nphy->ops.write_i2c_byte = &ixgbe_write_i2c_byte_82599;\r\n}\r\nret_val = phy->ops.identify(hw);\r\nixgbe_init_mac_link_ops_82599(hw);\r\nif (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {\r\nmac->ops.setup_link = &ixgbe_setup_copper_link_82599;\r\nmac->ops.get_link_capabilities =\r\n&ixgbe_get_copper_link_capabilities_generic;\r\n}\r\nswitch (hw->phy.type) {\r\ncase ixgbe_phy_tn:\r\nphy->ops.check_link = &ixgbe_check_phy_link_tnx;\r\nphy->ops.setup_link = &ixgbe_setup_phy_link_tnx;\r\nphy->ops.get_firmware_version =\r\n&ixgbe_get_phy_firmware_version_tnx;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,\r\nixgbe_link_speed *speed,\r\nbool *autoneg)\r\n{\r\nu32 autoc = 0;\r\nif (hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||\r\nhw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1) {\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\n*autoneg = true;\r\nreturn 0;\r\n}\r\nif (hw->mac.orig_link_settings_stored)\r\nautoc = hw->mac.orig_autoc;\r\nelse\r\nautoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nswitch (autoc & IXGBE_AUTOC_LMS_MASK) {\r\ncase IXGBE_AUTOC_LMS_1G_LINK_NO_AN:\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\n*autoneg = false;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_10G_LINK_NO_AN:\r\n*speed = IXGBE_LINK_SPEED_10GB_FULL;\r\n*autoneg = false;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_1G_AN:\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\n*autoneg = true;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_10G_SERIAL:\r\n*speed = IXGBE_LINK_SPEED_10GB_FULL;\r\n*autoneg = false;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_KX4_KX_KR:\r\ncase IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN:\r\n*speed = IXGBE_LINK_SPEED_UNKNOWN;\r\nif (autoc & IXGBE_AUTOC_KR_SUPP)\r\n*speed |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (autoc & IXGBE_AUTOC_KX4_SUPP)\r\n*speed |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (autoc & IXGBE_AUTOC_KX_SUPP)\r\n*speed |= IXGBE_LINK_SPEED_1GB_FULL;\r\n*autoneg = true;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII:\r\n*speed = IXGBE_LINK_SPEED_100_FULL;\r\nif (autoc & IXGBE_AUTOC_KR_SUPP)\r\n*speed |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (autoc & IXGBE_AUTOC_KX4_SUPP)\r\n*speed |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (autoc & IXGBE_AUTOC_KX_SUPP)\r\n*speed |= IXGBE_LINK_SPEED_1GB_FULL;\r\n*autoneg = true;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_SGMII_1G_100M:\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL | IXGBE_LINK_SPEED_100_FULL;\r\n*autoneg = false;\r\nbreak;\r\ndefault:\r\nreturn IXGBE_ERR_LINK_SETUP;\r\n}\r\nif (hw->phy.multispeed_fiber) {\r\n*speed |= IXGBE_LINK_SPEED_10GB_FULL |\r\nIXGBE_LINK_SPEED_1GB_FULL;\r\nif (hw->phy.media_type == ixgbe_media_type_fiber_qsfp)\r\n*autoneg = false;\r\nelse\r\n*autoneg = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw)\r\n{\r\nswitch (hw->phy.type) {\r\ncase ixgbe_phy_cu_unknown:\r\ncase ixgbe_phy_tn:\r\nreturn ixgbe_media_type_copper;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hw->device_id) {\r\ncase IXGBE_DEV_ID_82599_KX4:\r\ncase IXGBE_DEV_ID_82599_KX4_MEZZ:\r\ncase IXGBE_DEV_ID_82599_COMBO_BACKPLANE:\r\ncase IXGBE_DEV_ID_82599_KR:\r\ncase IXGBE_DEV_ID_82599_BACKPLANE_FCOE:\r\ncase IXGBE_DEV_ID_82599_XAUI_LOM:\r\nreturn ixgbe_media_type_backplane;\r\ncase IXGBE_DEV_ID_82599_SFP:\r\ncase IXGBE_DEV_ID_82599_SFP_FCOE:\r\ncase IXGBE_DEV_ID_82599_SFP_EM:\r\ncase IXGBE_DEV_ID_82599_SFP_SF2:\r\ncase IXGBE_DEV_ID_82599_SFP_SF_QP:\r\ncase IXGBE_DEV_ID_82599EN_SFP:\r\nreturn ixgbe_media_type_fiber;\r\ncase IXGBE_DEV_ID_82599_CX4:\r\nreturn ixgbe_media_type_cx4;\r\ncase IXGBE_DEV_ID_82599_T3_LOM:\r\nreturn ixgbe_media_type_copper;\r\ncase IXGBE_DEV_ID_82599_LS:\r\nreturn ixgbe_media_type_fiber_lco;\r\ncase IXGBE_DEV_ID_82599_QSFP_SF_QP:\r\nreturn ixgbe_media_type_fiber_qsfp;\r\ndefault:\r\nreturn ixgbe_media_type_unknown;\r\n}\r\n}\r\nstatic void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw)\r\n{\r\nu32 autoc2_reg;\r\nu16 ee_ctrl_2 = 0;\r\nhw->eeprom.ops.read(hw, IXGBE_EEPROM_CTRL_2, &ee_ctrl_2);\r\nif (!ixgbe_mng_present(hw) && !hw->wol_enabled &&\r\nee_ctrl_2 & IXGBE_EEPROM_CCD_BIT) {\r\nautoc2_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\r\nautoc2_reg |= IXGBE_AUTOC2_LINK_DISABLE_ON_D3_MASK;\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2_reg);\r\n}\r\n}\r\nstatic s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,\r\nbool autoneg_wait_to_complete)\r\n{\r\nu32 autoc_reg;\r\nu32 links_reg;\r\nu32 i;\r\ns32 status = 0;\r\nbool got_lock = false;\r\nif (ixgbe_verify_lesm_fw_enabled_82599(hw)) {\r\nstatus = hw->mac.ops.acquire_swfw_sync(hw,\r\nIXGBE_GSSR_MAC_CSR_SM);\r\nif (status)\r\nreturn status;\r\ngot_lock = true;\r\n}\r\nixgbe_reset_pipeline_82599(hw);\r\nif (got_lock)\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);\r\nif (autoneg_wait_to_complete) {\r\nautoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nif ((autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\r\nIXGBE_AUTOC_LMS_KX4_KX_KR ||\r\n(autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\r\nIXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||\r\n(autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\r\nIXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {\r\nlinks_reg = 0;\r\nfor (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {\r\nlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\nif (links_reg & IXGBE_LINKS_KX_AN_COMP)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {\r\nstatus = IXGBE_ERR_AUTONEG_NOT_COMPLETE;\r\nhw_dbg(hw, "Autoneg did not complete.\n");\r\n}\r\n}\r\n}\r\nmsleep(50);\r\nreturn status;\r\n}\r\nstatic void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)\r\n{\r\nu32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nif (ixgbe_check_reset_blocked(hw))\r\nreturn;\r\nesdp_reg |= IXGBE_ESDP_SDP3;\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(100);\r\n}\r\nstatic void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)\r\n{\r\nu32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nesdp_reg &= ~IXGBE_ESDP_SDP3;\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nmsleep(100);\r\n}\r\nstatic void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)\r\n{\r\nif (ixgbe_check_reset_blocked(hw))\r\nreturn;\r\nif (hw->mac.autotry_restart) {\r\nixgbe_disable_tx_laser_multispeed_fiber(hw);\r\nixgbe_enable_tx_laser_multispeed_fiber(hw);\r\nhw->mac.autotry_restart = false;\r\n}\r\n}\r\nstatic void\r\nixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed)\r\n{\r\nu32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nswitch (speed) {\r\ncase IXGBE_LINK_SPEED_10GB_FULL:\r\nesdp_reg |= (IXGBE_ESDP_SDP5_DIR | IXGBE_ESDP_SDP5);\r\nbreak;\r\ncase IXGBE_LINK_SPEED_1GB_FULL:\r\nesdp_reg &= ~IXGBE_ESDP_SDP5;\r\nesdp_reg |= IXGBE_ESDP_SDP5_DIR;\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "Invalid fixed module speed\n");\r\nreturn;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nstatic s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\ns32 status = 0;\r\nixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;\r\ns32 i, j;\r\nbool link_up = false;\r\nu32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nhw->phy.autoneg_advertised = 0;\r\nif (speed & IXGBE_LINK_SPEED_10GB_FULL)\r\nhw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (speed & IXGBE_LINK_SPEED_1GB_FULL)\r\nhw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;\r\nif (speed & IXGBE_LINK_SPEED_100_FULL)\r\nhw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_100_FULL;\r\nhw->phy.smart_speed_active = false;\r\nfor (j = 0; j < IXGBE_SMARTSPEED_MAX_RETRIES; j++) {\r\nstatus = ixgbe_setup_mac_link_82599(hw, speed,\r\nautoneg_wait_to_complete);\r\nif (status != 0)\r\ngoto out;\r\nfor (i = 0; i < 5; i++) {\r\nmdelay(100);\r\nstatus = hw->mac.ops.check_link(hw, &link_speed,\r\n&link_up, false);\r\nif (status != 0)\r\ngoto out;\r\nif (link_up)\r\ngoto out;\r\n}\r\n}\r\nif (((autoc_reg & IXGBE_AUTOC_KR_SUPP) == 0) ||\r\n((autoc_reg & IXGBE_AUTOC_KX4_KX_SUPP_MASK) == 0))\r\ngoto out;\r\nhw->phy.smart_speed_active = true;\r\nstatus = ixgbe_setup_mac_link_82599(hw, speed,\r\nautoneg_wait_to_complete);\r\nif (status != 0)\r\ngoto out;\r\nfor (i = 0; i < 6; i++) {\r\nmdelay(100);\r\nstatus = hw->mac.ops.check_link(hw, &link_speed,\r\n&link_up, false);\r\nif (status != 0)\r\ngoto out;\r\nif (link_up)\r\ngoto out;\r\n}\r\nhw->phy.smart_speed_active = false;\r\nstatus = ixgbe_setup_mac_link_82599(hw, speed,\r\nautoneg_wait_to_complete);\r\nout:\r\nif (link_up && (link_speed == IXGBE_LINK_SPEED_1GB_FULL))\r\nhw_dbg(hw, "Smartspeed has downgraded the link speed from the maximum advertised\n");\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\nbool autoneg = false;\r\ns32 status;\r\nu32 pma_pmd_1g, link_mode, links_reg, i;\r\nu32 autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\r\nu32 pma_pmd_10g_serial = autoc2 & IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK;\r\nixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;\r\nu32 current_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nu32 orig_autoc = 0;\r\nu32 autoc = current_autoc;\r\nstatus = hw->mac.ops.get_link_capabilities(hw, &link_capabilities,\r\n&autoneg);\r\nif (status)\r\nreturn status;\r\nspeed &= link_capabilities;\r\nif (speed == IXGBE_LINK_SPEED_UNKNOWN)\r\nreturn IXGBE_ERR_LINK_SETUP;\r\nif (hw->mac.orig_link_settings_stored)\r\norig_autoc = hw->mac.orig_autoc;\r\nelse\r\norig_autoc = autoc;\r\nlink_mode = autoc & IXGBE_AUTOC_LMS_MASK;\r\npma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;\r\nif (link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR ||\r\nlink_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||\r\nlink_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {\r\nautoc &= ~(IXGBE_AUTOC_KX4_KX_SUPP_MASK | IXGBE_AUTOC_KR_SUPP);\r\nif (speed & IXGBE_LINK_SPEED_10GB_FULL) {\r\nif (orig_autoc & IXGBE_AUTOC_KX4_SUPP)\r\nautoc |= IXGBE_AUTOC_KX4_SUPP;\r\nif ((orig_autoc & IXGBE_AUTOC_KR_SUPP) &&\r\n(hw->phy.smart_speed_active == false))\r\nautoc |= IXGBE_AUTOC_KR_SUPP;\r\n}\r\nif (speed & IXGBE_LINK_SPEED_1GB_FULL)\r\nautoc |= IXGBE_AUTOC_KX_SUPP;\r\n} else if ((pma_pmd_1g == IXGBE_AUTOC_1G_SFI) &&\r\n(link_mode == IXGBE_AUTOC_LMS_1G_LINK_NO_AN ||\r\nlink_mode == IXGBE_AUTOC_LMS_1G_AN)) {\r\nif ((speed == IXGBE_LINK_SPEED_10GB_FULL) &&\r\n(pma_pmd_10g_serial == IXGBE_AUTOC2_10G_SFI)) {\r\nautoc &= ~IXGBE_AUTOC_LMS_MASK;\r\nautoc |= IXGBE_AUTOC_LMS_10G_SERIAL;\r\n}\r\n} else if ((pma_pmd_10g_serial == IXGBE_AUTOC2_10G_SFI) &&\r\n(link_mode == IXGBE_AUTOC_LMS_10G_SERIAL)) {\r\nif ((speed == IXGBE_LINK_SPEED_1GB_FULL) &&\r\n(pma_pmd_1g == IXGBE_AUTOC_1G_SFI)) {\r\nautoc &= ~IXGBE_AUTOC_LMS_MASK;\r\nif (autoneg)\r\nautoc |= IXGBE_AUTOC_LMS_1G_AN;\r\nelse\r\nautoc |= IXGBE_AUTOC_LMS_1G_LINK_NO_AN;\r\n}\r\n}\r\nif (autoc != current_autoc) {\r\nstatus = hw->mac.ops.prot_autoc_write(hw, autoc, false);\r\nif (status)\r\nreturn status;\r\nif (autoneg_wait_to_complete) {\r\nif (link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR ||\r\nlink_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||\r\nlink_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {\r\nlinks_reg = 0;\r\nfor (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {\r\nlinks_reg =\r\nIXGBE_READ_REG(hw, IXGBE_LINKS);\r\nif (links_reg & IXGBE_LINKS_KX_AN_COMP)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {\r\nstatus =\r\nIXGBE_ERR_AUTONEG_NOT_COMPLETE;\r\nhw_dbg(hw, "Autoneg did not complete.\n");\r\n}\r\n}\r\n}\r\nmsleep(50);\r\n}\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\ns32 status;\r\nstatus = hw->phy.ops.setup_link_speed(hw, speed,\r\nautoneg_wait_to_complete);\r\nixgbe_start_mac_link_82599(hw, autoneg_wait_to_complete);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)\r\n{\r\nixgbe_link_speed link_speed;\r\ns32 status;\r\nu32 ctrl, i, autoc, autoc2;\r\nu32 curr_lms;\r\nbool link_up = false;\r\nstatus = hw->mac.ops.stop_adapter(hw);\r\nif (status)\r\nreturn status;\r\nixgbe_clear_tx_pending(hw);\r\nstatus = hw->phy.ops.init(hw);\r\nif (status == IXGBE_ERR_SFP_NOT_SUPPORTED)\r\nreturn status;\r\nif (hw->phy.sfp_setup_needed) {\r\nstatus = hw->mac.ops.setup_sfp(hw);\r\nhw->phy.sfp_setup_needed = false;\r\n}\r\nif (status == IXGBE_ERR_SFP_NOT_SUPPORTED)\r\nreturn status;\r\nif (hw->phy.reset_disable == false && hw->phy.ops.reset != NULL)\r\nhw->phy.ops.reset(hw);\r\ncurr_lms = IXGBE_READ_REG(hw, IXGBE_AUTOC) & IXGBE_AUTOC_LMS_MASK;\r\nmac_reset_top:\r\nctrl = IXGBE_CTRL_LNK_RST;\r\nif (!hw->force_full_reset) {\r\nhw->mac.ops.check_link(hw, &link_speed, &link_up, false);\r\nif (link_up)\r\nctrl = IXGBE_CTRL_RST;\r\n}\r\nctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);\r\nIXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nusleep_range(1000, 1200);\r\nfor (i = 0; i < 10; i++) {\r\nctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);\r\nif (!(ctrl & IXGBE_CTRL_RST_MASK))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (ctrl & IXGBE_CTRL_RST_MASK) {\r\nstatus = IXGBE_ERR_RESET_FAILED;\r\nhw_dbg(hw, "Reset polling failed to complete.\n");\r\n}\r\nmsleep(50);\r\nif (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {\r\nhw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\r\ngoto mac_reset_top;\r\n}\r\nautoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nautoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\r\nif (autoc2 & IXGBE_AUTOC2_LINK_DISABLE_MASK) {\r\nautoc2 &= ~IXGBE_AUTOC2_LINK_DISABLE_MASK;\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nif (hw->mac.orig_link_settings_stored == false) {\r\nhw->mac.orig_autoc = autoc;\r\nhw->mac.orig_autoc2 = autoc2;\r\nhw->mac.orig_link_settings_stored = true;\r\n} else {\r\nif ((hw->phy.multispeed_fiber && ixgbe_mng_enabled(hw)) ||\r\nhw->wol_enabled)\r\nhw->mac.orig_autoc =\r\n(hw->mac.orig_autoc & ~IXGBE_AUTOC_LMS_MASK) |\r\ncurr_lms;\r\nif (autoc != hw->mac.orig_autoc) {\r\nstatus = hw->mac.ops.prot_autoc_write(hw,\r\nhw->mac.orig_autoc,\r\nfalse);\r\nif (status)\r\nreturn status;\r\n}\r\nif ((autoc2 & IXGBE_AUTOC2_UPPER_MASK) !=\r\n(hw->mac.orig_autoc2 & IXGBE_AUTOC2_UPPER_MASK)) {\r\nautoc2 &= ~IXGBE_AUTOC2_UPPER_MASK;\r\nautoc2 |= (hw->mac.orig_autoc2 &\r\nIXGBE_AUTOC2_UPPER_MASK);\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2);\r\n}\r\n}\r\nhw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);\r\nhw->mac.num_rar_entries = 128;\r\nhw->mac.ops.init_rx_addrs(hw);\r\nhw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);\r\nif (is_valid_ether_addr(hw->mac.san_addr)) {\r\nhw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;\r\nhw->mac.ops.set_rar(hw, hw->mac.san_mac_rar_index,\r\nhw->mac.san_addr, 0, IXGBE_RAH_AV);\r\nhw->mac.ops.clear_vmdq(hw, hw->mac.san_mac_rar_index,\r\nIXGBE_CLEAR_VMDQ_ALL);\r\nhw->mac.num_rar_entries--;\r\n}\r\nhw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,\r\n&hw->mac.wwpn_prefix);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_fdir_check_cmd_complete(struct ixgbe_hw *hw, u32 *fdircmd)\r\n{\r\nint i;\r\nfor (i = 0; i < IXGBE_FDIRCMD_CMD_POLL; i++) {\r\n*fdircmd = IXGBE_READ_REG(hw, IXGBE_FDIRCMD);\r\nif (!(*fdircmd & IXGBE_FDIRCMD_CMD_MASK))\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn IXGBE_ERR_FDIR_CMD_INCOMPLETE;\r\n}\r\ns32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw)\r\n{\r\nint i;\r\nu32 fdirctrl = IXGBE_READ_REG(hw, IXGBE_FDIRCTRL);\r\nu32 fdircmd;\r\ns32 err;\r\nfdirctrl &= ~IXGBE_FDIRCTRL_INIT_DONE;\r\nerr = ixgbe_fdir_check_cmd_complete(hw, &fdircmd);\r\nif (err) {\r\nhw_dbg(hw, "Flow Director previous command did not complete, aborting table re-initialization.\n");\r\nreturn err;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRFREE, 0);\r\nIXGBE_WRITE_FLUSH(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,\r\n(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) |\r\nIXGBE_FDIRCMD_CLEARHT));\r\nIXGBE_WRITE_FLUSH(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,\r\n(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) &\r\n~IXGBE_FDIRCMD_CLEARHT));\r\nIXGBE_WRITE_FLUSH(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, 0x00);\r\nIXGBE_WRITE_FLUSH(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRCTRL, fdirctrl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nfor (i = 0; i < IXGBE_FDIR_INIT_DONE_POLL; i++) {\r\nif (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &\r\nIXGBE_FDIRCTRL_INIT_DONE)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (i >= IXGBE_FDIR_INIT_DONE_POLL) {\r\nhw_dbg(hw, "Flow Director Signature poll time exceeded!\n");\r\nreturn IXGBE_ERR_FDIR_REINIT_FAILED;\r\n}\r\nIXGBE_READ_REG(hw, IXGBE_FDIRUSTAT);\r\nIXGBE_READ_REG(hw, IXGBE_FDIRFSTAT);\r\nIXGBE_READ_REG(hw, IXGBE_FDIRMATCH);\r\nIXGBE_READ_REG(hw, IXGBE_FDIRMISS);\r\nIXGBE_READ_REG(hw, IXGBE_FDIRLEN);\r\nreturn 0;\r\n}\r\nstatic void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw, u32 fdirctrl)\r\n{\r\nint i;\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRHKEY, IXGBE_ATR_BUCKET_HASH_KEY);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRSKEY, IXGBE_ATR_SIGNATURE_HASH_KEY);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRCTRL, fdirctrl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nfor (i = 0; i < IXGBE_FDIR_INIT_DONE_POLL; i++) {\r\nif (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &\r\nIXGBE_FDIRCTRL_INIT_DONE)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (i >= IXGBE_FDIR_INIT_DONE_POLL)\r\nhw_dbg(hw, "Flow Director poll time exceeded!\n");\r\n}\r\ns32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl)\r\n{\r\nfdirctrl |= (0x6 << IXGBE_FDIRCTRL_FLEX_SHIFT) |\r\n(0xA << IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT) |\r\n(4 << IXGBE_FDIRCTRL_FULL_THRESH_SHIFT);\r\nixgbe_fdir_enable_82599(hw, fdirctrl);\r\nreturn 0;\r\n}\r\ns32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl)\r\n{\r\nfdirctrl |= IXGBE_FDIRCTRL_PERFECT_MATCH |\r\n(IXGBE_FDIR_DROP_QUEUE << IXGBE_FDIRCTRL_DROP_Q_SHIFT) |\r\n(0x6 << IXGBE_FDIRCTRL_FLEX_SHIFT) |\r\n(0xA << IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT) |\r\n(4 << IXGBE_FDIRCTRL_FULL_THRESH_SHIFT);\r\nixgbe_fdir_enable_82599(hw, fdirctrl);\r\nreturn 0;\r\n}\r\nstatic u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,\r\nunion ixgbe_atr_hash_dword common)\r\n{\r\nu32 hi_hash_dword, lo_hash_dword, flow_vm_vlan;\r\nu32 sig_hash = 0, bucket_hash = 0, common_hash = 0;\r\nflow_vm_vlan = ntohl(input.dword);\r\nhi_hash_dword = ntohl(common.dword);\r\nlo_hash_dword = (hi_hash_dword >> 16) | (hi_hash_dword << 16);\r\nhi_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan >> 16);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(0);\r\nlo_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan << 16);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(1);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(2);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(3);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(4);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(5);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(6);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(7);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(8);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(9);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(10);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(11);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(12);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(13);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(14);\r\nIXGBE_COMPUTE_SIG_HASH_ITERATION(15);\r\nbucket_hash ^= common_hash;\r\nbucket_hash &= IXGBE_ATR_HASH_MASK;\r\nsig_hash ^= common_hash << 16;\r\nsig_hash &= IXGBE_ATR_HASH_MASK << 16;\r\nreturn sig_hash ^ bucket_hash;\r\n}\r\ns32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,\r\nunion ixgbe_atr_hash_dword input,\r\nunion ixgbe_atr_hash_dword common,\r\nu8 queue)\r\n{\r\nu64 fdirhashcmd;\r\nu8 flow_type;\r\nbool tunnel;\r\nu32 fdircmd;\r\ntunnel = !!(input.formatted.flow_type & IXGBE_ATR_L4TYPE_TUNNEL_MASK);\r\nflow_type = input.formatted.flow_type &\r\n(IXGBE_ATR_L4TYPE_TUNNEL_MASK - 1);\r\nswitch (flow_type) {\r\ncase IXGBE_ATR_FLOW_TYPE_TCPV4:\r\ncase IXGBE_ATR_FLOW_TYPE_UDPV4:\r\ncase IXGBE_ATR_FLOW_TYPE_SCTPV4:\r\ncase IXGBE_ATR_FLOW_TYPE_TCPV6:\r\ncase IXGBE_ATR_FLOW_TYPE_UDPV6:\r\ncase IXGBE_ATR_FLOW_TYPE_SCTPV6:\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, " Error on flow type input\n");\r\nreturn IXGBE_ERR_CONFIG;\r\n}\r\nfdircmd = IXGBE_FDIRCMD_CMD_ADD_FLOW | IXGBE_FDIRCMD_FILTER_UPDATE |\r\nIXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;\r\nfdircmd |= (u32)flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;\r\nfdircmd |= (u32)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;\r\nif (tunnel)\r\nfdircmd |= IXGBE_FDIRCMD_TUNNEL_FILTER;\r\nfdirhashcmd = (u64)fdircmd << 32;\r\nfdirhashcmd |= ixgbe_atr_compute_sig_hash_82599(input, common);\r\nIXGBE_WRITE_REG64(hw, IXGBE_FDIRHASH, fdirhashcmd);\r\nhw_dbg(hw, "Tx Queue=%x hash=%x\n", queue, (u32)fdirhashcmd);\r\nreturn 0;\r\n}\r\nvoid ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,\r\nunion ixgbe_atr_input *input_mask)\r\n{\r\nu32 hi_hash_dword, lo_hash_dword, flow_vm_vlan;\r\nu32 bucket_hash = 0, hi_dword = 0;\r\nint i;\r\nfor (i = 0; i <= 10; i++)\r\ninput->dword_stream[i] &= input_mask->dword_stream[i];\r\nflow_vm_vlan = ntohl(input->dword_stream[0]);\r\nfor (i = 1; i <= 10; i++)\r\nhi_dword ^= input->dword_stream[i];\r\nhi_hash_dword = ntohl(hi_dword);\r\nlo_hash_dword = (hi_hash_dword >> 16) | (hi_hash_dword << 16);\r\nhi_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan >> 16);\r\nIXGBE_COMPUTE_BKT_HASH_ITERATION(0);\r\nlo_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan << 16);\r\nfor (i = 1; i <= 15; i++)\r\nIXGBE_COMPUTE_BKT_HASH_ITERATION(i);\r\ninput->formatted.bkt_hash = bucket_hash & 0x1FFF;\r\n}\r\nstatic u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask)\r\n{\r\nu32 mask = ntohs(input_mask->formatted.dst_port);\r\nmask <<= IXGBE_FDIRTCPM_DPORTM_SHIFT;\r\nmask |= ntohs(input_mask->formatted.src_port);\r\nmask = ((mask & 0x55555555) << 1) | ((mask & 0xAAAAAAAA) >> 1);\r\nmask = ((mask & 0x33333333) << 2) | ((mask & 0xCCCCCCCC) >> 2);\r\nmask = ((mask & 0x0F0F0F0F) << 4) | ((mask & 0xF0F0F0F0) >> 4);\r\nreturn ((mask & 0x00FF00FF) << 8) | ((mask & 0xFF00FF00) >> 8);\r\n}\r\ns32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,\r\nunion ixgbe_atr_input *input_mask)\r\n{\r\nu32 fdirm = IXGBE_FDIRM_DIPv6;\r\nu32 fdirtcpm;\r\nif (input_mask->formatted.bkt_hash)\r\nhw_dbg(hw, " bucket hash should always be 0 in mask\n");\r\nswitch (input_mask->formatted.vm_pool & 0x7F) {\r\ncase 0x0:\r\nfdirm |= IXGBE_FDIRM_POOL;\r\ncase 0x7F:\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, " Error on vm pool mask\n");\r\nreturn IXGBE_ERR_CONFIG;\r\n}\r\nswitch (input_mask->formatted.flow_type & IXGBE_ATR_L4TYPE_MASK) {\r\ncase 0x0:\r\nfdirm |= IXGBE_FDIRM_L4P;\r\nif (input_mask->formatted.dst_port ||\r\ninput_mask->formatted.src_port) {\r\nhw_dbg(hw, " Error on src/dst port mask\n");\r\nreturn IXGBE_ERR_CONFIG;\r\n}\r\ncase IXGBE_ATR_L4TYPE_MASK:\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, " Error on flow type mask\n");\r\nreturn IXGBE_ERR_CONFIG;\r\n}\r\nswitch (ntohs(input_mask->formatted.vlan_id) & 0xEFFF) {\r\ncase 0x0000:\r\nfdirm |= IXGBE_FDIRM_VLANID;\r\ncase 0x0FFF:\r\nfdirm |= IXGBE_FDIRM_VLANP;\r\nbreak;\r\ncase 0xE000:\r\nfdirm |= IXGBE_FDIRM_VLANID;\r\ncase 0xEFFF:\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, " Error on VLAN mask\n");\r\nreturn IXGBE_ERR_CONFIG;\r\n}\r\nswitch (input_mask->formatted.flex_bytes & 0xFFFF) {\r\ncase 0x0000:\r\nfdirm |= IXGBE_FDIRM_FLEX;\r\ncase 0xFFFF:\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, " Error on flexible byte mask\n");\r\nreturn IXGBE_ERR_CONFIG;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRM, fdirm);\r\nfdirtcpm = ixgbe_get_fdirtcpm_82599(input_mask);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRTCPM, ~fdirtcpm);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRUDPM, ~fdirtcpm);\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\ncase ixgbe_mac_x550em_a:\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRSCTPM, ~fdirtcpm);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIP4M,\r\n~input_mask->formatted.src_ip[0]);\r\nIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRDIP4M,\r\n~input_mask->formatted.dst_ip[0]);\r\nreturn 0;\r\n}\r\ns32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,\r\nunion ixgbe_atr_input *input,\r\nu16 soft_id, u8 queue)\r\n{\r\nu32 fdirport, fdirvlan, fdirhash, fdircmd;\r\ns32 err;\r\nIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(0),\r\ninput->formatted.src_ip[0]);\r\nIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(1),\r\ninput->formatted.src_ip[1]);\r\nIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(2),\r\ninput->formatted.src_ip[2]);\r\nIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPSA, input->formatted.src_ip[0]);\r\nIXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPDA, input->formatted.dst_ip[0]);\r\nfdirport = ntohs(input->formatted.dst_port);\r\nfdirport <<= IXGBE_FDIRPORT_DESTINATION_SHIFT;\r\nfdirport |= ntohs(input->formatted.src_port);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRPORT, fdirport);\r\nfdirvlan = IXGBE_STORE_AS_BE16(input->formatted.flex_bytes);\r\nfdirvlan <<= IXGBE_FDIRVLAN_FLEX_SHIFT;\r\nfdirvlan |= ntohs(input->formatted.vlan_id);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRVLAN, fdirvlan);\r\nfdirhash = input->formatted.bkt_hash;\r\nfdirhash |= soft_id << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT;\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);\r\nIXGBE_WRITE_FLUSH(hw);\r\nfdircmd = IXGBE_FDIRCMD_CMD_ADD_FLOW | IXGBE_FDIRCMD_FILTER_UPDATE |\r\nIXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;\r\nif (queue == IXGBE_FDIR_DROP_QUEUE)\r\nfdircmd |= IXGBE_FDIRCMD_DROP;\r\nfdircmd |= input->formatted.flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;\r\nfdircmd |= (u32)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;\r\nfdircmd |= (u32)input->formatted.vm_pool << IXGBE_FDIRCMD_VT_POOL_SHIFT;\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD, fdircmd);\r\nerr = ixgbe_fdir_check_cmd_complete(hw, &fdircmd);\r\nif (err) {\r\nhw_dbg(hw, "Flow Director command did not complete!\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\ns32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,\r\nunion ixgbe_atr_input *input,\r\nu16 soft_id)\r\n{\r\nu32 fdirhash;\r\nu32 fdircmd;\r\ns32 err;\r\nfdirhash = input->formatted.bkt_hash;\r\nfdirhash |= soft_id << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT;\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);\r\nIXGBE_WRITE_FLUSH(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD, IXGBE_FDIRCMD_CMD_QUERY_REM_FILT);\r\nerr = ixgbe_fdir_check_cmd_complete(hw, &fdircmd);\r\nif (err) {\r\nhw_dbg(hw, "Flow Director command did not complete!\n");\r\nreturn err;\r\n}\r\nif (fdircmd & IXGBE_FDIRCMD_FILTER_VALID) {\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);\r\nIXGBE_WRITE_FLUSH(hw);\r\nIXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,\r\nIXGBE_FDIRCMD_CMD_REMOVE_FLOW);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val)\r\n{\r\nu32 core_ctl;\r\nIXGBE_WRITE_REG(hw, IXGBE_CORECTL, IXGBE_CORECTL_WRITE_CMD |\r\n(reg << 8));\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(10);\r\ncore_ctl = IXGBE_READ_REG(hw, IXGBE_CORECTL);\r\n*val = (u8)core_ctl;\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val)\r\n{\r\nu32 core_ctl;\r\ncore_ctl = (reg << 8) | val;\r\nIXGBE_WRITE_REG(hw, IXGBE_CORECTL, core_ctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nret_val = ixgbe_start_hw_generic(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = ixgbe_start_hw_gen2(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nhw->mac.autotry_restart = true;\r\nreturn ixgbe_verify_fw_version_82599(hw);\r\n}\r\nstatic s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nstatus = ixgbe_identify_phy_generic(hw);\r\nif (status) {\r\nif (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_copper)\r\nreturn status;\r\nstatus = ixgbe_identify_module_generic(hw);\r\n}\r\nif (hw->phy.type == ixgbe_phy_unknown) {\r\nhw->phy.type = ixgbe_phy_none;\r\nstatus = 0;\r\n}\r\nif (hw->phy.type == ixgbe_phy_sfp_unsupported)\r\nreturn IXGBE_ERR_SFP_NOT_SUPPORTED;\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, u32 regval)\r\n{\r\nhw->mac.ops.disable_rx_buff(hw);\r\nif (regval & IXGBE_RXCTRL_RXEN)\r\nhw->mac.ops.enable_rx(hw);\r\nelse\r\nhw->mac.ops.disable_rx(hw);\r\nhw->mac.ops.enable_rx_buff(hw);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw)\r\n{\r\ns32 status = IXGBE_ERR_EEPROM_VERSION;\r\nu16 fw_offset, fw_ptp_cfg_offset;\r\nu16 offset;\r\nu16 fw_version = 0;\r\nif (hw->phy.media_type != ixgbe_media_type_fiber)\r\nreturn 0;\r\noffset = IXGBE_FW_PTR;\r\nif (hw->eeprom.ops.read(hw, offset, &fw_offset))\r\ngoto fw_version_err;\r\nif (fw_offset == 0 || fw_offset == 0xFFFF)\r\nreturn IXGBE_ERR_EEPROM_VERSION;\r\noffset = fw_offset + IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR;\r\nif (hw->eeprom.ops.read(hw, offset, &fw_ptp_cfg_offset))\r\ngoto fw_version_err;\r\nif (fw_ptp_cfg_offset == 0 || fw_ptp_cfg_offset == 0xFFFF)\r\nreturn IXGBE_ERR_EEPROM_VERSION;\r\noffset = fw_ptp_cfg_offset + IXGBE_FW_PATCH_VERSION_4;\r\nif (hw->eeprom.ops.read(hw, offset, &fw_version))\r\ngoto fw_version_err;\r\nif (fw_version > 0x5)\r\nstatus = 0;\r\nreturn status;\r\nfw_version_err:\r\nhw_err(hw, "eeprom read at offset %d failed\n", offset);\r\nreturn IXGBE_ERR_EEPROM_VERSION;\r\n}\r\nstatic bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw)\r\n{\r\nu16 fw_offset, fw_lesm_param_offset, fw_lesm_state;\r\ns32 status;\r\nstatus = hw->eeprom.ops.read(hw, IXGBE_FW_PTR, &fw_offset);\r\nif (status || fw_offset == 0 || fw_offset == 0xFFFF)\r\nreturn false;\r\nstatus = hw->eeprom.ops.read(hw, (fw_offset +\r\nIXGBE_FW_LESM_PARAMETERS_PTR),\r\n&fw_lesm_param_offset);\r\nif (status ||\r\nfw_lesm_param_offset == 0 || fw_lesm_param_offset == 0xFFFF)\r\nreturn false;\r\nstatus = hw->eeprom.ops.read(hw, (fw_lesm_param_offset +\r\nIXGBE_FW_LESM_STATE_1),\r\n&fw_lesm_state);\r\nif (!status && (fw_lesm_state & IXGBE_FW_LESM_STATE_ENABLED))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw, u16 offset,\r\nu16 words, u16 *data)\r\n{\r\nstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\r\nif (eeprom->type == ixgbe_eeprom_spi &&\r\noffset + (words - 1) <= IXGBE_EERD_MAX_ADDR)\r\nreturn ixgbe_read_eerd_buffer_generic(hw, offset, words, data);\r\nreturn ixgbe_read_eeprom_buffer_bit_bang_generic(hw, offset, words,\r\ndata);\r\n}\r\nstatic s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,\r\nu16 offset, u16 *data)\r\n{\r\nstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\r\nif (eeprom->type == ixgbe_eeprom_spi && offset <= IXGBE_EERD_MAX_ADDR)\r\nreturn ixgbe_read_eerd_generic(hw, offset, data);\r\nreturn ixgbe_read_eeprom_bit_bang_generic(hw, offset, data);\r\n}\r\nstatic s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val;\r\nu32 anlp1_reg = 0;\r\nu32 i, autoc_reg, autoc2_reg;\r\nautoc2_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\r\nif (autoc2_reg & IXGBE_AUTOC2_LINK_DISABLE_MASK) {\r\nautoc2_reg &= ~IXGBE_AUTOC2_LINK_DISABLE_MASK;\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nautoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nautoc_reg |= IXGBE_AUTOC_AN_RESTART;\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC,\r\nautoc_reg ^ (0x4 << IXGBE_AUTOC_LMS_SHIFT));\r\nfor (i = 0; i < 10; i++) {\r\nusleep_range(4000, 8000);\r\nanlp1_reg = IXGBE_READ_REG(hw, IXGBE_ANLP1);\r\nif (anlp1_reg & IXGBE_ANLP1_AN_STATE_MASK)\r\nbreak;\r\n}\r\nif (!(anlp1_reg & IXGBE_ANLP1_AN_STATE_MASK)) {\r\nhw_dbg(hw, "auto negotiation not completed\n");\r\nret_val = IXGBE_ERR_RESET_FAILED;\r\ngoto reset_pipeline_out;\r\n}\r\nret_val = 0;\r\nreset_pipeline_out:\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 dev_addr, u8 *data)\r\n{\r\nu32 esdp;\r\ns32 status;\r\ns32 timeout = 200;\r\nif (hw->phy.qsfp_shared_i2c_bus == true) {\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nesdp |= IXGBE_ESDP_SDP0;\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\r\nIXGBE_WRITE_FLUSH(hw);\r\nwhile (timeout) {\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nif (esdp & IXGBE_ESDP_SDP1)\r\nbreak;\r\nusleep_range(5000, 10000);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\nhw_dbg(hw, "Driver can't access resource, acquiring I2C bus timeout.\n");\r\nstatus = IXGBE_ERR_I2C;\r\ngoto release_i2c_access;\r\n}\r\n}\r\nstatus = ixgbe_read_i2c_byte_generic(hw, byte_offset, dev_addr, data);\r\nrelease_i2c_access:\r\nif (hw->phy.qsfp_shared_i2c_bus == true) {\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nesdp &= ~IXGBE_ESDP_SDP0;\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 dev_addr, u8 data)\r\n{\r\nu32 esdp;\r\ns32 status;\r\ns32 timeout = 200;\r\nif (hw->phy.qsfp_shared_i2c_bus == true) {\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nesdp |= IXGBE_ESDP_SDP0;\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\r\nIXGBE_WRITE_FLUSH(hw);\r\nwhile (timeout) {\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nif (esdp & IXGBE_ESDP_SDP1)\r\nbreak;\r\nusleep_range(5000, 10000);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\nhw_dbg(hw, "Driver can't access resource, acquiring I2C bus timeout.\n");\r\nstatus = IXGBE_ERR_I2C;\r\ngoto release_i2c_access;\r\n}\r\n}\r\nstatus = ixgbe_write_i2c_byte_generic(hw, byte_offset, dev_addr, data);\r\nrelease_i2c_access:\r\nif (hw->phy.qsfp_shared_i2c_bus == true) {\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nesdp &= ~IXGBE_ESDP_SDP0;\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nreturn status;\r\n}
