void debug_mutex_lock_common(struct mutex *lock, struct mutex_waiter *waiter)\r\n{\r\nmemset(waiter, MUTEX_DEBUG_INIT, sizeof(*waiter));\r\nwaiter->magic = waiter;\r\nINIT_LIST_HEAD(&waiter->list);\r\n}\r\nvoid debug_mutex_wake_waiter(struct mutex *lock, struct mutex_waiter *waiter)\r\n{\r\nSMP_DEBUG_LOCKS_WARN_ON(!spin_is_locked(&lock->wait_lock));\r\nDEBUG_LOCKS_WARN_ON(list_empty(&lock->wait_list));\r\nDEBUG_LOCKS_WARN_ON(waiter->magic != waiter);\r\nDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\r\n}\r\nvoid debug_mutex_free_waiter(struct mutex_waiter *waiter)\r\n{\r\nDEBUG_LOCKS_WARN_ON(!list_empty(&waiter->list));\r\nmemset(waiter, MUTEX_DEBUG_FREE, sizeof(*waiter));\r\n}\r\nvoid debug_mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,\r\nstruct task_struct *task)\r\n{\r\nSMP_DEBUG_LOCKS_WARN_ON(!spin_is_locked(&lock->wait_lock));\r\ntask->blocked_on = waiter;\r\n}\r\nvoid mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter,\r\nstruct task_struct *task)\r\n{\r\nDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\r\nDEBUG_LOCKS_WARN_ON(waiter->task != task);\r\nDEBUG_LOCKS_WARN_ON(task->blocked_on != waiter);\r\ntask->blocked_on = NULL;\r\nlist_del_init(&waiter->list);\r\nwaiter->task = NULL;\r\n}\r\nvoid debug_mutex_unlock(struct mutex *lock)\r\n{\r\nif (likely(debug_locks)) {\r\nDEBUG_LOCKS_WARN_ON(lock->magic != lock);\r\nif (!lock->owner)\r\nDEBUG_LOCKS_WARN_ON(!lock->owner);\r\nelse\r\nDEBUG_LOCKS_WARN_ON(lock->owner != current);\r\nDEBUG_LOCKS_WARN_ON(!lock->wait_list.prev && !lock->wait_list.next);\r\n}\r\nmutex_clear_owner(lock);\r\natomic_set(&lock->count, 1);\r\n}\r\nvoid debug_mutex_init(struct mutex *lock, const char *name,\r\nstruct lock_class_key *key)\r\n{\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\ndebug_check_no_locks_freed((void *)lock, sizeof(*lock));\r\nlockdep_init_map(&lock->dep_map, name, key, 0);\r\n#endif\r\nlock->magic = lock;\r\n}\r\nvoid mutex_destroy(struct mutex *lock)\r\n{\r\nDEBUG_LOCKS_WARN_ON(mutex_is_locked(lock));\r\nlock->magic = NULL;\r\n}
