static void __init jz4740_cgu_init(struct device_node *np)\r\n{\r\nint retval;\r\ncgu = ingenic_cgu_new(jz4740_cgu_clocks,\r\nARRAY_SIZE(jz4740_cgu_clocks), np);\r\nif (!cgu) {\r\npr_err("%s: failed to initialise CGU\n", __func__);\r\nreturn;\r\n}\r\nretval = ingenic_cgu_register_clocks(cgu);\r\nif (retval)\r\npr_err("%s: failed to register CGU Clocks\n", __func__);\r\n}\r\nvoid jz4740_clock_set_wait_mode(enum jz4740_wait_mode mode)\r\n{\r\nuint32_t lcr = readl(cgu->base + CGU_REG_LCR);\r\nswitch (mode) {\r\ncase JZ4740_WAIT_MODE_IDLE:\r\nlcr &= ~LCR_SLEEP;\r\nbreak;\r\ncase JZ4740_WAIT_MODE_SLEEP:\r\nlcr |= LCR_SLEEP;\r\nbreak;\r\n}\r\nwritel(lcr, cgu->base + CGU_REG_LCR);\r\n}\r\nvoid jz4740_clock_udc_disable_auto_suspend(void)\r\n{\r\nuint32_t clkgr = readl(cgu->base + CGU_REG_CLKGR);\r\nclkgr &= ~CLKGR_UDC;\r\nwritel(clkgr, cgu->base + CGU_REG_CLKGR);\r\n}\r\nvoid jz4740_clock_udc_enable_auto_suspend(void)\r\n{\r\nuint32_t clkgr = readl(cgu->base + CGU_REG_CLKGR);\r\nclkgr |= CLKGR_UDC;\r\nwritel(clkgr, cgu->base + CGU_REG_CLKGR);\r\n}\r\nvoid jz4740_clock_suspend(void)\r\n{\r\nuint32_t clkgr, cppcr;\r\nclkgr = readl(cgu->base + CGU_REG_CLKGR);\r\nclkgr |= JZ_CLOCK_GATE_TCU | JZ_CLOCK_GATE_DMAC | JZ_CLOCK_GATE_UART0;\r\nwritel(clkgr, cgu->base + CGU_REG_CLKGR);\r\ncppcr = readl(cgu->base + CGU_REG_CPPCR);\r\ncppcr &= ~BIT(jz4740_cgu_clocks[JZ4740_CLK_PLL].pll.enable_bit);\r\nwritel(cppcr, cgu->base + CGU_REG_CPPCR);\r\n}\r\nvoid jz4740_clock_resume(void)\r\n{\r\nuint32_t clkgr, cppcr, stable;\r\ncppcr = readl(cgu->base + CGU_REG_CPPCR);\r\ncppcr |= BIT(jz4740_cgu_clocks[JZ4740_CLK_PLL].pll.enable_bit);\r\nwritel(cppcr, cgu->base + CGU_REG_CPPCR);\r\nstable = BIT(jz4740_cgu_clocks[JZ4740_CLK_PLL].pll.stable_bit);\r\ndo {\r\ncppcr = readl(cgu->base + CGU_REG_CPPCR);\r\n} while (!(cppcr & stable));\r\nclkgr = readl(cgu->base + CGU_REG_CLKGR);\r\nclkgr &= ~JZ_CLOCK_GATE_TCU;\r\nclkgr &= ~JZ_CLOCK_GATE_DMAC;\r\nclkgr &= ~JZ_CLOCK_GATE_UART0;\r\nwritel(clkgr, cgu->base + CGU_REG_CLKGR);\r\n}
