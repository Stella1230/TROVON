static inline struct tegra_dpaux *to_dpaux(struct drm_dp_aux *aux)\r\n{\r\nreturn container_of(aux, struct tegra_dpaux, aux);\r\n}\r\nstatic inline struct tegra_dpaux *work_to_dpaux(struct work_struct *work)\r\n{\r\nreturn container_of(work, struct tegra_dpaux, work);\r\n}\r\nstatic inline u32 tegra_dpaux_readl(struct tegra_dpaux *dpaux,\r\nunsigned long offset)\r\n{\r\nreturn readl(dpaux->regs + (offset << 2));\r\n}\r\nstatic inline void tegra_dpaux_writel(struct tegra_dpaux *dpaux,\r\nu32 value, unsigned long offset)\r\n{\r\nwritel(value, dpaux->regs + (offset << 2));\r\n}\r\nstatic void tegra_dpaux_write_fifo(struct tegra_dpaux *dpaux, const u8 *buffer,\r\nsize_t size)\r\n{\r\nsize_t i, j;\r\nfor (i = 0; i < DIV_ROUND_UP(size, 4); i++) {\r\nsize_t num = min_t(size_t, size - i * 4, 4);\r\nu32 value = 0;\r\nfor (j = 0; j < num; j++)\r\nvalue |= buffer[i * 4 + j] << (j * 8);\r\ntegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXDATA_WRITE(i));\r\n}\r\n}\r\nstatic void tegra_dpaux_read_fifo(struct tegra_dpaux *dpaux, u8 *buffer,\r\nsize_t size)\r\n{\r\nsize_t i, j;\r\nfor (i = 0; i < DIV_ROUND_UP(size, 4); i++) {\r\nsize_t num = min_t(size_t, size - i * 4, 4);\r\nu32 value;\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXDATA_READ(i));\r\nfor (j = 0; j < num; j++)\r\nbuffer[i * 4 + j] = value >> (j * 8);\r\n}\r\n}\r\nstatic ssize_t tegra_dpaux_transfer(struct drm_dp_aux *aux,\r\nstruct drm_dp_aux_msg *msg)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(250);\r\nstruct tegra_dpaux *dpaux = to_dpaux(aux);\r\nunsigned long status;\r\nssize_t ret = 0;\r\nu32 value;\r\nif (msg->size > 16)\r\nreturn -EINVAL;\r\nif (msg->size < 1) {\r\nswitch (msg->request & ~DP_AUX_I2C_MOT) {\r\ncase DP_AUX_I2C_WRITE_STATUS_UPDATE:\r\ncase DP_AUX_I2C_WRITE:\r\ncase DP_AUX_I2C_READ:\r\nvalue = DPAUX_DP_AUXCTL_CMD_ADDRESS_ONLY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nvalue = DPAUX_DP_AUXCTL_CMDLEN(msg->size - 1);\r\n}\r\nswitch (msg->request & ~DP_AUX_I2C_MOT) {\r\ncase DP_AUX_I2C_WRITE:\r\nif (msg->request & DP_AUX_I2C_MOT)\r\nvalue |= DPAUX_DP_AUXCTL_CMD_MOT_WR;\r\nelse\r\nvalue |= DPAUX_DP_AUXCTL_CMD_I2C_WR;\r\nbreak;\r\ncase DP_AUX_I2C_READ:\r\nif (msg->request & DP_AUX_I2C_MOT)\r\nvalue |= DPAUX_DP_AUXCTL_CMD_MOT_RD;\r\nelse\r\nvalue |= DPAUX_DP_AUXCTL_CMD_I2C_RD;\r\nbreak;\r\ncase DP_AUX_I2C_WRITE_STATUS_UPDATE:\r\nif (msg->request & DP_AUX_I2C_MOT)\r\nvalue |= DPAUX_DP_AUXCTL_CMD_MOT_RQ;\r\nelse\r\nvalue |= DPAUX_DP_AUXCTL_CMD_I2C_RQ;\r\nbreak;\r\ncase DP_AUX_NATIVE_WRITE:\r\nvalue |= DPAUX_DP_AUXCTL_CMD_AUX_WR;\r\nbreak;\r\ncase DP_AUX_NATIVE_READ:\r\nvalue |= DPAUX_DP_AUXCTL_CMD_AUX_RD;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntegra_dpaux_writel(dpaux, msg->address, DPAUX_DP_AUXADDR);\r\ntegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXCTL);\r\nif ((msg->request & DP_AUX_I2C_READ) == 0) {\r\ntegra_dpaux_write_fifo(dpaux, msg->buffer, msg->size);\r\nret = msg->size;\r\n}\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXCTL);\r\nvalue |= DPAUX_DP_AUXCTL_TRANSACTREQ;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXCTL);\r\nstatus = wait_for_completion_timeout(&dpaux->complete, timeout);\r\nif (!status)\r\nreturn -ETIMEDOUT;\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXSTAT);\r\ntegra_dpaux_writel(dpaux, 0xf00, DPAUX_DP_AUXSTAT);\r\nif (value & DPAUX_DP_AUXSTAT_TIMEOUT_ERROR)\r\nreturn -ETIMEDOUT;\r\nif ((value & DPAUX_DP_AUXSTAT_RX_ERROR) ||\r\n(value & DPAUX_DP_AUXSTAT_SINKSTAT_ERROR) ||\r\n(value & DPAUX_DP_AUXSTAT_NO_STOP_ERROR))\r\nreturn -EIO;\r\nswitch ((value & DPAUX_DP_AUXSTAT_REPLY_TYPE_MASK) >> 16) {\r\ncase 0x00:\r\nmsg->reply = DP_AUX_NATIVE_REPLY_ACK;\r\nbreak;\r\ncase 0x01:\r\nmsg->reply = DP_AUX_NATIVE_REPLY_NACK;\r\nbreak;\r\ncase 0x02:\r\nmsg->reply = DP_AUX_NATIVE_REPLY_DEFER;\r\nbreak;\r\ncase 0x04:\r\nmsg->reply = DP_AUX_I2C_REPLY_NACK;\r\nbreak;\r\ncase 0x08:\r\nmsg->reply = DP_AUX_I2C_REPLY_DEFER;\r\nbreak;\r\n}\r\nif ((msg->size > 0) && (msg->reply == DP_AUX_NATIVE_REPLY_ACK)) {\r\nif (msg->request & DP_AUX_I2C_READ) {\r\nsize_t count = value & DPAUX_DP_AUXSTAT_REPLY_MASK;\r\nif (WARN_ON(count != msg->size))\r\ncount = min_t(size_t, count, msg->size);\r\ntegra_dpaux_read_fifo(dpaux, msg->buffer, count);\r\nret = count;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void tegra_dpaux_hotplug(struct work_struct *work)\r\n{\r\nstruct tegra_dpaux *dpaux = work_to_dpaux(work);\r\nif (dpaux->output)\r\ndrm_helper_hpd_irq_event(dpaux->output->connector.dev);\r\n}\r\nstatic irqreturn_t tegra_dpaux_irq(int irq, void *data)\r\n{\r\nstruct tegra_dpaux *dpaux = data;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nu32 value;\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_INTR_AUX);\r\ntegra_dpaux_writel(dpaux, value, DPAUX_INTR_AUX);\r\nif (value & (DPAUX_INTR_PLUG_EVENT | DPAUX_INTR_UNPLUG_EVENT))\r\nschedule_work(&dpaux->work);\r\nif (value & DPAUX_INTR_IRQ_EVENT) {\r\n}\r\nif (value & DPAUX_INTR_AUX_DONE)\r\ncomplete(&dpaux->complete);\r\nreturn ret;\r\n}\r\nstatic void tegra_dpaux_pad_power_down(struct tegra_dpaux *dpaux)\r\n{\r\nu32 value = tegra_dpaux_readl(dpaux, DPAUX_HYBRID_SPARE);\r\nvalue |= DPAUX_HYBRID_SPARE_PAD_POWER_DOWN;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_SPARE);\r\n}\r\nstatic void tegra_dpaux_pad_power_up(struct tegra_dpaux *dpaux)\r\n{\r\nu32 value = tegra_dpaux_readl(dpaux, DPAUX_HYBRID_SPARE);\r\nvalue &= ~DPAUX_HYBRID_SPARE_PAD_POWER_DOWN;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_SPARE);\r\n}\r\nstatic int tegra_dpaux_pad_config(struct tegra_dpaux *dpaux, unsigned function)\r\n{\r\nu32 value;\r\nswitch (function) {\r\ncase DPAUX_PADCTL_FUNC_AUX:\r\nvalue = DPAUX_HYBRID_PADCTL_AUX_CMH(2) |\r\nDPAUX_HYBRID_PADCTL_AUX_DRVZ(4) |\r\nDPAUX_HYBRID_PADCTL_AUX_DRVI(0x18) |\r\nDPAUX_HYBRID_PADCTL_AUX_INPUT_RCV |\r\nDPAUX_HYBRID_PADCTL_MODE_AUX;\r\nbreak;\r\ncase DPAUX_PADCTL_FUNC_I2C:\r\nvalue = DPAUX_HYBRID_PADCTL_I2C_SDA_INPUT_RCV |\r\nDPAUX_HYBRID_PADCTL_I2C_SCL_INPUT_RCV |\r\nDPAUX_HYBRID_PADCTL_MODE_I2C;\r\nbreak;\r\ncase DPAUX_PADCTL_FUNC_OFF:\r\ntegra_dpaux_pad_power_down(dpaux);\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\ntegra_dpaux_writel(dpaux, value, DPAUX_HYBRID_PADCTL);\r\ntegra_dpaux_pad_power_up(dpaux);\r\nreturn 0;\r\n}\r\nstatic int tegra_dpaux_get_groups_count(struct pinctrl_dev *pinctrl)\r\n{\r\nreturn ARRAY_SIZE(tegra_dpaux_groups);\r\n}\r\nstatic const char *tegra_dpaux_get_group_name(struct pinctrl_dev *pinctrl,\r\nunsigned int group)\r\n{\r\nreturn tegra_dpaux_groups[group];\r\n}\r\nstatic int tegra_dpaux_get_group_pins(struct pinctrl_dev *pinctrl,\r\nunsigned group, const unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\n*pins = tegra_dpaux_pin_numbers;\r\n*num_pins = ARRAY_SIZE(tegra_dpaux_pin_numbers);\r\nreturn 0;\r\n}\r\nstatic int tegra_dpaux_get_functions_count(struct pinctrl_dev *pinctrl)\r\n{\r\nreturn ARRAY_SIZE(tegra_dpaux_functions);\r\n}\r\nstatic const char *tegra_dpaux_get_function_name(struct pinctrl_dev *pinctrl,\r\nunsigned int function)\r\n{\r\nreturn tegra_dpaux_functions[function];\r\n}\r\nstatic int tegra_dpaux_get_function_groups(struct pinctrl_dev *pinctrl,\r\nunsigned int function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\n*num_groups = ARRAY_SIZE(tegra_dpaux_groups);\r\n*groups = tegra_dpaux_groups;\r\nreturn 0;\r\n}\r\nstatic int tegra_dpaux_set_mux(struct pinctrl_dev *pinctrl,\r\nunsigned int function, unsigned int group)\r\n{\r\nstruct tegra_dpaux *dpaux = pinctrl_dev_get_drvdata(pinctrl);\r\nreturn tegra_dpaux_pad_config(dpaux, function);\r\n}\r\nstatic int tegra_dpaux_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_dpaux *dpaux;\r\nstruct resource *regs;\r\nu32 value;\r\nint err;\r\ndpaux = devm_kzalloc(&pdev->dev, sizeof(*dpaux), GFP_KERNEL);\r\nif (!dpaux)\r\nreturn -ENOMEM;\r\nINIT_WORK(&dpaux->work, tegra_dpaux_hotplug);\r\ninit_completion(&dpaux->complete);\r\nINIT_LIST_HEAD(&dpaux->list);\r\ndpaux->dev = &pdev->dev;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndpaux->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(dpaux->regs))\r\nreturn PTR_ERR(dpaux->regs);\r\ndpaux->irq = platform_get_irq(pdev, 0);\r\nif (dpaux->irq < 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ\n");\r\nreturn -ENXIO;\r\n}\r\nif (!pdev->dev.pm_domain) {\r\ndpaux->rst = devm_reset_control_get(&pdev->dev, "dpaux");\r\nif (IS_ERR(dpaux->rst)) {\r\ndev_err(&pdev->dev,\r\n"failed to get reset control: %ld\n",\r\nPTR_ERR(dpaux->rst));\r\nreturn PTR_ERR(dpaux->rst);\r\n}\r\n}\r\ndpaux->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dpaux->clk)) {\r\ndev_err(&pdev->dev, "failed to get module clock: %ld\n",\r\nPTR_ERR(dpaux->clk));\r\nreturn PTR_ERR(dpaux->clk);\r\n}\r\nerr = clk_prepare_enable(dpaux->clk);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to enable module clock: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (dpaux->rst)\r\nreset_control_deassert(dpaux->rst);\r\ndpaux->clk_parent = devm_clk_get(&pdev->dev, "parent");\r\nif (IS_ERR(dpaux->clk_parent)) {\r\ndev_err(&pdev->dev, "failed to get parent clock: %ld\n",\r\nPTR_ERR(dpaux->clk_parent));\r\nerr = PTR_ERR(dpaux->clk_parent);\r\ngoto assert_reset;\r\n}\r\nerr = clk_prepare_enable(dpaux->clk_parent);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to enable parent clock: %d\n",\r\nerr);\r\ngoto assert_reset;\r\n}\r\nerr = clk_set_rate(dpaux->clk_parent, 270000000);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to set clock to 270 MHz: %d\n",\r\nerr);\r\ngoto disable_parent_clk;\r\n}\r\ndpaux->vdd = devm_regulator_get(&pdev->dev, "vdd");\r\nif (IS_ERR(dpaux->vdd)) {\r\ndev_err(&pdev->dev, "failed to get VDD supply: %ld\n",\r\nPTR_ERR(dpaux->vdd));\r\nerr = PTR_ERR(dpaux->vdd);\r\ngoto disable_parent_clk;\r\n}\r\nerr = devm_request_irq(dpaux->dev, dpaux->irq, tegra_dpaux_irq, 0,\r\ndev_name(dpaux->dev), dpaux);\r\nif (err < 0) {\r\ndev_err(dpaux->dev, "failed to request IRQ#%u: %d\n",\r\ndpaux->irq, err);\r\ngoto disable_parent_clk;\r\n}\r\ndisable_irq(dpaux->irq);\r\ndpaux->aux.transfer = tegra_dpaux_transfer;\r\ndpaux->aux.dev = &pdev->dev;\r\nerr = drm_dp_aux_register(&dpaux->aux);\r\nif (err < 0)\r\ngoto disable_parent_clk;\r\nerr = tegra_dpaux_pad_config(dpaux, DPAUX_HYBRID_PADCTL_MODE_I2C);\r\nif (err < 0)\r\nreturn err;\r\n#ifdef CONFIG_GENERIC_PINCONF\r\ndpaux->desc.name = dev_name(&pdev->dev);\r\ndpaux->desc.pins = tegra_dpaux_pins;\r\ndpaux->desc.npins = ARRAY_SIZE(tegra_dpaux_pins);\r\ndpaux->desc.pctlops = &tegra_dpaux_pinctrl_ops;\r\ndpaux->desc.pmxops = &tegra_dpaux_pinmux_ops;\r\ndpaux->desc.owner = THIS_MODULE;\r\ndpaux->pinctrl = devm_pinctrl_register(&pdev->dev, &dpaux->desc, dpaux);\r\nif (!dpaux->pinctrl) {\r\ndev_err(&pdev->dev, "failed to register pincontrol\n");\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nvalue = DPAUX_INTR_AUX_DONE | DPAUX_INTR_IRQ_EVENT |\r\nDPAUX_INTR_UNPLUG_EVENT | DPAUX_INTR_PLUG_EVENT;\r\ntegra_dpaux_writel(dpaux, value, DPAUX_INTR_EN_AUX);\r\ntegra_dpaux_writel(dpaux, value, DPAUX_INTR_AUX);\r\nmutex_lock(&dpaux_lock);\r\nlist_add_tail(&dpaux->list, &dpaux_list);\r\nmutex_unlock(&dpaux_lock);\r\nplatform_set_drvdata(pdev, dpaux);\r\nreturn 0;\r\ndisable_parent_clk:\r\nclk_disable_unprepare(dpaux->clk_parent);\r\nassert_reset:\r\nif (dpaux->rst)\r\nreset_control_assert(dpaux->rst);\r\nclk_disable_unprepare(dpaux->clk);\r\nreturn err;\r\n}\r\nstatic int tegra_dpaux_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_dpaux *dpaux = platform_get_drvdata(pdev);\r\ntegra_dpaux_pad_power_down(dpaux);\r\ndrm_dp_aux_unregister(&dpaux->aux);\r\nmutex_lock(&dpaux_lock);\r\nlist_del(&dpaux->list);\r\nmutex_unlock(&dpaux_lock);\r\ncancel_work_sync(&dpaux->work);\r\nclk_disable_unprepare(dpaux->clk_parent);\r\nif (dpaux->rst)\r\nreset_control_assert(dpaux->rst);\r\nclk_disable_unprepare(dpaux->clk);\r\nreturn 0;\r\n}\r\nstruct drm_dp_aux *drm_dp_aux_find_by_of_node(struct device_node *np)\r\n{\r\nstruct tegra_dpaux *dpaux;\r\nmutex_lock(&dpaux_lock);\r\nlist_for_each_entry(dpaux, &dpaux_list, list)\r\nif (np == dpaux->dev->of_node) {\r\nmutex_unlock(&dpaux_lock);\r\nreturn &dpaux->aux;\r\n}\r\nmutex_unlock(&dpaux_lock);\r\nreturn NULL;\r\n}\r\nint drm_dp_aux_attach(struct drm_dp_aux *aux, struct tegra_output *output)\r\n{\r\nstruct tegra_dpaux *dpaux = to_dpaux(aux);\r\nunsigned long timeout;\r\nint err;\r\noutput->connector.polled = DRM_CONNECTOR_POLL_HPD;\r\ndpaux->output = output;\r\nerr = regulator_enable(dpaux->vdd);\r\nif (err < 0)\r\nreturn err;\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nenum drm_connector_status status;\r\nstatus = drm_dp_aux_detect(aux);\r\nif (status == connector_status_connected) {\r\nenable_irq(dpaux->irq);\r\nreturn 0;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint drm_dp_aux_detach(struct drm_dp_aux *aux)\r\n{\r\nstruct tegra_dpaux *dpaux = to_dpaux(aux);\r\nunsigned long timeout;\r\nint err;\r\ndisable_irq(dpaux->irq);\r\nerr = regulator_disable(dpaux->vdd);\r\nif (err < 0)\r\nreturn err;\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nenum drm_connector_status status;\r\nstatus = drm_dp_aux_detect(aux);\r\nif (status == connector_status_disconnected) {\r\ndpaux->output = NULL;\r\nreturn 0;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nenum drm_connector_status drm_dp_aux_detect(struct drm_dp_aux *aux)\r\n{\r\nstruct tegra_dpaux *dpaux = to_dpaux(aux);\r\nu32 value;\r\nvalue = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXSTAT);\r\nif (value & DPAUX_DP_AUXSTAT_HPD_STATUS)\r\nreturn connector_status_connected;\r\nreturn connector_status_disconnected;\r\n}\r\nint drm_dp_aux_enable(struct drm_dp_aux *aux)\r\n{\r\nstruct tegra_dpaux *dpaux = to_dpaux(aux);\r\nreturn tegra_dpaux_pad_config(dpaux, DPAUX_PADCTL_FUNC_AUX);\r\n}\r\nint drm_dp_aux_disable(struct drm_dp_aux *aux)\r\n{\r\nstruct tegra_dpaux *dpaux = to_dpaux(aux);\r\ntegra_dpaux_pad_power_down(dpaux);\r\nreturn 0;\r\n}\r\nint drm_dp_aux_prepare(struct drm_dp_aux *aux, u8 encoding)\r\n{\r\nint err;\r\nerr = drm_dp_dpcd_writeb(aux, DP_MAIN_LINK_CHANNEL_CODING_SET,\r\nencoding);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint drm_dp_aux_train(struct drm_dp_aux *aux, struct drm_dp_link *link,\r\nu8 pattern)\r\n{\r\nu8 tp = pattern & DP_TRAINING_PATTERN_MASK;\r\nu8 status[DP_LINK_STATUS_SIZE], values[4];\r\nunsigned int i;\r\nint err;\r\nerr = drm_dp_dpcd_writeb(aux, DP_TRAINING_PATTERN_SET, pattern);\r\nif (err < 0)\r\nreturn err;\r\nif (tp == DP_TRAINING_PATTERN_DISABLE)\r\nreturn 0;\r\nfor (i = 0; i < link->num_lanes; i++)\r\nvalues[i] = DP_TRAIN_MAX_PRE_EMPHASIS_REACHED |\r\nDP_TRAIN_PRE_EMPH_LEVEL_0 |\r\nDP_TRAIN_MAX_SWING_REACHED |\r\nDP_TRAIN_VOLTAGE_SWING_LEVEL_0;\r\nerr = drm_dp_dpcd_write(aux, DP_TRAINING_LANE0_SET, values,\r\nlink->num_lanes);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(500, 1000);\r\nerr = drm_dp_dpcd_read_link_status(aux, status);\r\nif (err < 0)\r\nreturn err;\r\nswitch (tp) {\r\ncase DP_TRAINING_PATTERN_1:\r\nif (!drm_dp_clock_recovery_ok(status, link->num_lanes))\r\nreturn -EAGAIN;\r\nbreak;\r\ncase DP_TRAINING_PATTERN_2:\r\nif (!drm_dp_channel_eq_ok(status, link->num_lanes))\r\nreturn -EAGAIN;\r\nbreak;\r\ndefault:\r\ndev_err(aux->dev, "unsupported training pattern %u\n", tp);\r\nreturn -EINVAL;\r\n}\r\nerr = drm_dp_dpcd_writeb(aux, DP_EDP_CONFIGURATION_SET, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}
