static void apci3120_addon_write(struct comedi_device *dev,\r\nunsigned int val, unsigned int reg)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\noutw(reg, devpriv->addon + APCI3120_ADDON_ADDR_REG);\r\noutw(val & 0xffff, devpriv->addon + APCI3120_ADDON_DATA_REG);\r\noutw(reg + 2, devpriv->addon + APCI3120_ADDON_ADDR_REG);\r\noutw((val >> 16) & 0xffff, devpriv->addon + APCI3120_ADDON_DATA_REG);\r\n}\r\nstatic void apci3120_init_dma(struct comedi_device *dev,\r\nstruct apci3120_dmabuf *dmabuf)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\noutl(AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO,\r\ndevpriv->amcc + AMCC_OP_REG_AGCSTS);\r\napci3120_addon_write(dev, AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO,\r\nAMCC_OP_REG_AGCSTS);\r\noutl(RESET_A2P_FLAGS | EN_A2P_TRANSFERS,\r\ndevpriv->amcc + AMCC_OP_REG_MCSR);\r\napci3120_addon_write(dev, dmabuf->hw, AMCC_OP_REG_AMWAR);\r\napci3120_addon_write(dev, dmabuf->use_size, AMCC_OP_REG_AMWTC);\r\noutl(APCI3120_FIFO_ADVANCE_ON_BYTE_2 | AINT_WRITE_COMPL,\r\ndevpriv->amcc + AMCC_OP_REG_INTCSR);\r\noutw(APCI3120_ADDON_CTRL_AMWEN_ENA | APCI3120_ADDON_CTRL_A2P_FIFO_ENA,\r\ndevpriv->addon + APCI3120_ADDON_CTRL_REG);\r\n}\r\nstatic void apci3120_setup_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nstruct apci3120_dmabuf *dmabuf0 = &devpriv->dmabuf[0];\r\nstruct apci3120_dmabuf *dmabuf1 = &devpriv->dmabuf[1];\r\nunsigned int dmalen0 = dmabuf0->size;\r\nunsigned int dmalen1 = dmabuf1->size;\r\nunsigned int scan_bytes;\r\nscan_bytes = comedi_samples_to_bytes(s, cmd->scan_end_arg);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (dmalen0 > (cmd->stop_arg * scan_bytes))\r\ndmalen0 = cmd->stop_arg * scan_bytes;\r\nelse if (dmalen1 > (cmd->stop_arg * scan_bytes - dmalen0))\r\ndmalen1 = cmd->stop_arg * scan_bytes - dmalen0;\r\n}\r\nif (cmd->flags & CMDF_WAKE_EOS) {\r\nif (dmalen0 > scan_bytes) {\r\ndmalen0 = scan_bytes;\r\nif (cmd->scan_end_arg & 1)\r\ndmalen0 += 2;\r\n}\r\nif (dmalen1 > scan_bytes) {\r\ndmalen1 = scan_bytes;\r\nif (cmd->scan_end_arg & 1)\r\ndmalen1 -= 2;\r\nif (dmalen1 < 4)\r\ndmalen1 = 4;\r\n}\r\n} else {\r\nif (dmalen0 > s->async->prealloc_bufsz)\r\ndmalen0 = s->async->prealloc_bufsz;\r\nif (dmalen1 > s->async->prealloc_bufsz)\r\ndmalen1 = s->async->prealloc_bufsz;\r\n}\r\ndmabuf0->use_size = dmalen0;\r\ndmabuf1->use_size = dmalen1;\r\napci3120_init_dma(dev, dmabuf0);\r\n}\r\nstatic unsigned int apci3120_ns_to_timer(struct comedi_device *dev,\r\nunsigned int timer,\r\nunsigned int ns,\r\nunsigned int flags)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nunsigned int prescale = (timer == 0) ? 10 : 1000;\r\nunsigned int timer_base = devpriv->osc_base * prescale;\r\nunsigned int divisor;\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_UP:\r\ndivisor = DIV_ROUND_UP(ns, timer_base);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndivisor = ns / timer_base;\r\nbreak;\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\ndivisor = DIV_ROUND_CLOSEST(ns, timer_base);\r\nbreak;\r\n}\r\nif (timer == 2) {\r\nif (divisor > 0x00ffffff)\r\ndivisor = 0x00ffffff;\r\n} else {\r\nif (divisor > 0xffff)\r\ndivisor = 0xffff;\r\n}\r\nif (divisor < 2)\r\ndivisor = 2;\r\nreturn divisor;\r\n}\r\nstatic void apci3120_clr_timer2_interrupt(struct comedi_device *dev)\r\n{\r\ninb(dev->iobase + APCI3120_CTR0_REG);\r\n}\r\nstatic void apci3120_timer_write(struct comedi_device *dev,\r\nunsigned int timer, unsigned int val)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\noutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits) |\r\nAPCI3120_CTR0_TIMER_SEL(timer),\r\ndev->iobase + APCI3120_CTR0_REG);\r\noutw(val & 0xffff, dev->iobase + APCI3120_TIMER_REG);\r\nif (timer == 2) {\r\noutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits) |\r\nAPCI3120_CTR0_TIMER_SEL(timer + 1),\r\ndev->iobase + APCI3120_CTR0_REG);\r\noutw((val >> 16) & 0xffff, dev->iobase + APCI3120_TIMER_REG);\r\n}\r\n}\r\nstatic unsigned int apci3120_timer_read(struct comedi_device *dev,\r\nunsigned int timer)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nunsigned int val;\r\noutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits) |\r\nAPCI3120_CTR0_TIMER_SEL(timer),\r\ndev->iobase + APCI3120_CTR0_REG);\r\nval = inw(dev->iobase + APCI3120_TIMER_REG);\r\nif (timer == 2) {\r\noutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits) |\r\nAPCI3120_CTR0_TIMER_SEL(timer + 1),\r\ndev->iobase + APCI3120_CTR0_REG);\r\nval |= (inw(dev->iobase + APCI3120_TIMER_REG) << 16);\r\n}\r\nreturn val;\r\n}\r\nstatic void apci3120_timer_set_mode(struct comedi_device *dev,\r\nunsigned int timer, unsigned int mode)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\ndevpriv->timer_mode &= ~APCI3120_TIMER_MODE_MASK(timer);\r\ndevpriv->timer_mode |= APCI3120_TIMER_MODE(timer, mode);\r\noutb(devpriv->timer_mode, dev->iobase + APCI3120_TIMER_MODE_REG);\r\n}\r\nstatic void apci3120_timer_enable(struct comedi_device *dev,\r\nunsigned int timer, bool enable)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nif (enable)\r\ndevpriv->ctrl |= APCI3120_CTRL_GATE(timer);\r\nelse\r\ndevpriv->ctrl &= ~APCI3120_CTRL_GATE(timer);\r\noutw(devpriv->ctrl, dev->iobase + APCI3120_CTRL_REG);\r\n}\r\nstatic void apci3120_exttrig_enable(struct comedi_device *dev, bool enable)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nif (enable)\r\ndevpriv->ctrl |= APCI3120_CTRL_EXT_TRIG;\r\nelse\r\ndevpriv->ctrl &= ~APCI3120_CTRL_EXT_TRIG;\r\noutw(devpriv->ctrl, dev->iobase + APCI3120_CTRL_REG);\r\n}\r\nstatic void apci3120_set_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nint n_chan, unsigned int *chanlist)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nint i;\r\nfor (i = 0; i < n_chan; i++) {\r\nunsigned int chan = CR_CHAN(chanlist[i]);\r\nunsigned int range = CR_RANGE(chanlist[i]);\r\nunsigned int val;\r\nval = APCI3120_CHANLIST_MUX(chan) |\r\nAPCI3120_CHANLIST_GAIN(range) |\r\nAPCI3120_CHANLIST_INDEX(i);\r\nif (comedi_range_is_unipolar(s, range))\r\nval |= APCI3120_CHANLIST_UNIPOLAR;\r\noutw(val, dev->iobase + APCI3120_CHANLIST_REG);\r\n}\r\ninw(dev->iobase + APCI3120_TIMER_MODE_REG);\r\ndevpriv->ctrl = APCI3120_CTRL_PR(n_chan - 1) | APCI3120_CTRL_PA(0);\r\noutw(devpriv->ctrl, dev->iobase + APCI3120_CTRL_REG);\r\nif (n_chan > 1)\r\ndevpriv->mode |= APCI3120_MODE_SCAN_ENA;\r\n}\r\nstatic void apci3120_interrupt_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nstruct apci3120_dmabuf *dmabuf;\r\nunsigned int nbytes;\r\nunsigned int nsamples;\r\ndmabuf = &devpriv->dmabuf[devpriv->cur_dmabuf];\r\nnbytes = dmabuf->use_size - inl(devpriv->amcc + AMCC_OP_REG_MWTC);\r\nif (nbytes < dmabuf->use_size)\r\ndev_err(dev->class_dev, "Interrupted DMA transfer!\n");\r\nif (nbytes & 1) {\r\ndev_err(dev->class_dev, "Odd count of bytes in DMA ring!\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\nreturn;\r\n}\r\nnsamples = comedi_bytes_to_samples(s, nbytes);\r\nif (nsamples) {\r\ncomedi_buf_write_samples(s, dmabuf->virt, nsamples);\r\nif (!(cmd->flags & CMDF_WAKE_EOS))\r\nasync->events |= COMEDI_CB_EOS;\r\n}\r\nif ((async->events & COMEDI_CB_CANCEL_MASK) ||\r\n(cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg))\r\nreturn;\r\nif (devpriv->use_double_buffer) {\r\ndevpriv->cur_dmabuf = !devpriv->cur_dmabuf;\r\ndmabuf = &devpriv->dmabuf[devpriv->cur_dmabuf];\r\napci3120_init_dma(dev, dmabuf);\r\n} else {\r\napci3120_init_dma(dev, dmabuf);\r\n}\r\n}\r\nstatic irqreturn_t apci3120_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct apci3120_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int status;\r\nunsigned int int_amcc;\r\nstatus = inw(dev->iobase + APCI3120_STATUS_REG);\r\nint_amcc = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);\r\nif (!(status & APCI3120_STATUS_INT_MASK) &&\r\n!(int_amcc & ANY_S593X_INT)) {\r\ndev_err(dev->class_dev, "IRQ from unknown source\n");\r\nreturn IRQ_NONE;\r\n}\r\noutl(int_amcc | AINT_INT_MASK, devpriv->amcc + AMCC_OP_REG_INTCSR);\r\nif (devpriv->ctrl & APCI3120_CTRL_EXT_TRIG)\r\napci3120_exttrig_enable(dev, false);\r\nif (int_amcc & MASTER_ABORT_INT)\r\ndev_err(dev->class_dev, "AMCC IRQ - MASTER DMA ABORT!\n");\r\nif (int_amcc & TARGET_ABORT_INT)\r\ndev_err(dev->class_dev, "AMCC IRQ - TARGET DMA ABORT!\n");\r\nif ((status & APCI3120_STATUS_EOS_INT) &&\r\n(devpriv->mode & APCI3120_MODE_EOS_IRQ_ENA)) {\r\nunsigned short val;\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nval = inw(dev->iobase + APCI3120_AI_FIFO_REG);\r\ncomedi_buf_write_samples(s, &val, 1);\r\n}\r\ndevpriv->mode |= APCI3120_MODE_EOS_IRQ_ENA;\r\noutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\r\n}\r\nif (status & APCI3120_STATUS_TIMER2_INT) {\r\napci3120_clr_timer2_interrupt(dev);\r\n}\r\nif (status & APCI3120_STATUS_AMCC_INT) {\r\noutl(AINT_WT_COMPLETE, devpriv->amcc + AMCC_OP_REG_INTCSR);\r\napci3120_interrupt_dma(dev, s);\r\n}\r\nif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int apci3120_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int divisor;\r\ndevpriv->mode = APCI3120_MODE_TIMER2_CLK_OSC |\r\nAPCI3120_MODE_TIMER2_AS_TIMER;\r\noutl(AINT_WT_COMPLETE, devpriv->amcc + AMCC_OP_REG_INTCSR);\r\ndevpriv->cur_dmabuf = 0;\r\napci3120_set_chanlist(dev, s, cmd->chanlist_len, cmd->chanlist);\r\nif (cmd->start_src == TRIG_EXT)\r\napci3120_exttrig_enable(dev, true);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ndivisor = apci3120_ns_to_timer(dev, 1, cmd->scan_begin_arg,\r\ncmd->flags);\r\napci3120_timer_set_mode(dev, 1, APCI3120_TIMER_MODE2);\r\napci3120_timer_write(dev, 1, divisor);\r\n}\r\ndivisor = apci3120_ns_to_timer(dev, 0, cmd->convert_arg, cmd->flags);\r\napci3120_timer_set_mode(dev, 0, APCI3120_TIMER_MODE2);\r\napci3120_timer_write(dev, 0, divisor);\r\nif (devpriv->use_dma)\r\napci3120_setup_dma(dev, s);\r\nelse\r\ndevpriv->mode |= APCI3120_MODE_EOS_IRQ_ENA;\r\noutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\r\nif (cmd->scan_begin_src == TRIG_TIMER)\r\napci3120_timer_enable(dev, 1, true);\r\napci3120_timer_enable(dev, 0, true);\r\nreturn 0;\r\n}\r\nstatic int apci3120_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int arg;\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_FOLLOW);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\n100000);\r\n}\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 10000);\r\nerr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->convert_arg * cmd->scan_end_arg;\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int apci3120_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\noutw(0, devpriv->addon + 4);\r\napci3120_addon_write(dev, 0, AMCC_OP_REG_AGCSTS);\r\noutl(0, devpriv->amcc + AMCC_OP_REG_MCSR);\r\ndevpriv->ctrl = 0;\r\noutw(devpriv->ctrl, dev->iobase + APCI3120_CTRL_REG);\r\ndevpriv->mode = 0;\r\noutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\r\ninw(dev->iobase + APCI3120_STATUS_REG);\r\ndevpriv->cur_dmabuf = 0;\r\nreturn 0;\r\n}\r\nstatic int apci3120_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inw(dev->iobase + APCI3120_STATUS_REG);\r\nif ((status & APCI3120_STATUS_EOC_INT) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int apci3120_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nunsigned int divisor;\r\nint ret;\r\nint i;\r\ndevpriv->mode = APCI3120_MODE_TIMER2_CLK_OSC |\r\nAPCI3120_MODE_TIMER2_AS_TIMER;\r\noutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\r\napci3120_set_chanlist(dev, s, 1, &insn->chanspec);\r\napci3120_timer_set_mode(dev, 0, APCI3120_TIMER_MODE4);\r\napci3120_timer_enable(dev, 0, true);\r\ndivisor = apci3120_ns_to_timer(dev, 0, 10000, CMDF_ROUND_NEAREST);\r\nfor (i = 0; i < insn->n; i++) {\r\napci3120_timer_write(dev, 0, divisor);\r\nret = comedi_timeout(dev, s, insn, apci3120_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = inw(dev->iobase + APCI3120_AI_FIFO_REG);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int apci3120_ao_ready(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inw(dev->iobase + APCI3120_STATUS_REG);\r\nif (status & APCI3120_STATUS_DA_READY)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int apci3120_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\nint ret;\r\nret = comedi_timeout(dev, s, insn, apci3120_ao_ready, 0);\r\nif (ret)\r\nreturn ret;\r\noutw(APCI3120_AO_MUX(chan) | APCI3120_AO_DATA(val),\r\ndev->iobase + APCI3120_AO_REG(chan));\r\ns->readback[chan] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int apci3120_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int status;\r\nstatus = inw(dev->iobase + APCI3120_STATUS_REG);\r\ndata[1] = APCI3120_STATUS_TO_DI_BITS(status);\r\nreturn insn->n;\r\n}\r\nstatic int apci3120_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nif (comedi_dio_update_state(s, data)) {\r\ndevpriv->do_bits = s->state;\r\noutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits),\r\ndev->iobase + APCI3120_CTR0_REG);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int apci3120_timer_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nunsigned int divisor;\r\nunsigned int status;\r\nunsigned int mode;\r\nunsigned int timer_mode;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_ARM:\r\napci3120_clr_timer2_interrupt(dev);\r\ndivisor = apci3120_ns_to_timer(dev, 2, data[1],\r\nCMDF_ROUND_DOWN);\r\napci3120_timer_write(dev, 2, divisor);\r\napci3120_timer_enable(dev, 2, true);\r\nbreak;\r\ncase INSN_CONFIG_DISARM:\r\napci3120_timer_enable(dev, 2, false);\r\napci3120_clr_timer2_interrupt(dev);\r\nbreak;\r\ncase INSN_CONFIG_GET_COUNTER_STATUS:\r\ndata[1] = 0;\r\ndata[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING |\r\nCOMEDI_COUNTER_TERMINAL_COUNT;\r\nif (devpriv->ctrl & APCI3120_CTRL_GATE(2)) {\r\ndata[1] |= COMEDI_COUNTER_ARMED;\r\ndata[1] |= COMEDI_COUNTER_COUNTING;\r\n}\r\nstatus = inw(dev->iobase + APCI3120_STATUS_REG);\r\nif (status & APCI3120_STATUS_TIMER2_INT) {\r\ndata[1] &= ~COMEDI_COUNTER_COUNTING;\r\ndata[1] |= COMEDI_COUNTER_TERMINAL_COUNT;\r\n}\r\nbreak;\r\ncase INSN_CONFIG_SET_COUNTER_MODE:\r\nswitch (data[1]) {\r\ncase I8254_MODE0:\r\nmode = APCI3120_MODE_TIMER2_AS_COUNTER;\r\ntimer_mode = APCI3120_TIMER_MODE0;\r\nbreak;\r\ncase I8254_MODE2:\r\nmode = APCI3120_MODE_TIMER2_AS_TIMER;\r\ntimer_mode = APCI3120_TIMER_MODE2;\r\nbreak;\r\ncase I8254_MODE4:\r\nmode = APCI3120_MODE_TIMER2_AS_TIMER;\r\ntimer_mode = APCI3120_TIMER_MODE4;\r\nbreak;\r\ncase I8254_MODE5:\r\nmode = APCI3120_MODE_TIMER2_AS_WDOG;\r\ntimer_mode = APCI3120_TIMER_MODE5;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\napci3120_timer_enable(dev, 2, false);\r\napci3120_clr_timer2_interrupt(dev);\r\napci3120_timer_set_mode(dev, 2, timer_mode);\r\ndevpriv->mode &= ~APCI3120_MODE_TIMER2_AS_MASK;\r\ndevpriv->mode |= mode;\r\noutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int apci3120_timer_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = apci3120_timer_read(dev, 2);\r\nreturn insn->n;\r\n}\r\nstatic void apci3120_dma_alloc(struct comedi_device *dev)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nstruct apci3120_dmabuf *dmabuf;\r\nint order;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\ndmabuf = &devpriv->dmabuf[i];\r\nfor (order = 2; order >= 0; order--) {\r\ndmabuf->virt = dma_alloc_coherent(dev->hw_dev,\r\nPAGE_SIZE << order,\r\n&dmabuf->hw,\r\nGFP_KERNEL);\r\nif (dmabuf->virt)\r\nbreak;\r\n}\r\nif (!dmabuf->virt)\r\nbreak;\r\ndmabuf->size = PAGE_SIZE << order;\r\nif (i == 0)\r\ndevpriv->use_dma = 1;\r\nif (i == 1)\r\ndevpriv->use_double_buffer = 1;\r\n}\r\n}\r\nstatic void apci3120_dma_free(struct comedi_device *dev)\r\n{\r\nstruct apci3120_private *devpriv = dev->private;\r\nstruct apci3120_dmabuf *dmabuf;\r\nint i;\r\nif (!devpriv)\r\nreturn;\r\nfor (i = 0; i < 2; i++) {\r\ndmabuf = &devpriv->dmabuf[i];\r\nif (dmabuf->virt) {\r\ndma_free_coherent(dev->hw_dev, dmabuf->size,\r\ndmabuf->virt, dmabuf->hw);\r\n}\r\n}\r\n}\r\nstatic void apci3120_reset(struct comedi_device *dev)\r\n{\r\noutb(0, dev->iobase + APCI3120_MODE_REG);\r\noutw(0, dev->iobase + APCI3120_CTRL_REG);\r\ninw(dev->iobase + APCI3120_STATUS_REG);\r\n}\r\nstatic int apci3120_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct apci3120_board *board = NULL;\r\nstruct apci3120_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nunsigned int status;\r\nint ret;\r\nif (context < ARRAY_SIZE(apci3120_boardtypes))\r\nboard = &apci3120_boardtypes[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\npci_set_master(pcidev);\r\ndev->iobase = pci_resource_start(pcidev, 1);\r\ndevpriv->amcc = pci_resource_start(pcidev, 0);\r\ndevpriv->addon = pci_resource_start(pcidev, 2);\r\napci3120_reset(dev);\r\nif (pcidev->irq > 0) {\r\nret = request_irq(pcidev->irq, apci3120_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0) {\r\ndev->irq = pcidev->irq;\r\napci3120_dma_alloc(dev);\r\n}\r\n}\r\nstatus = inw(dev->iobase + APCI3120_STATUS_REG);\r\nif (APCI3120_STATUS_TO_VERSION(status) == APCI3120_REVB ||\r\ncontext == BOARD_APCI3001)\r\ndevpriv->osc_base = APCI3120_REVB_OSC_BASE;\r\nelse\r\ndevpriv->osc_base = APCI3120_REVA_OSC_BASE;\r\nret = comedi_alloc_subdevices(dev, 5);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;\r\ns->n_chan = 16;\r\ns->maxdata = board->ai_is_16bit ? 0xffff : 0x0fff;\r\ns->range_table = &apci3120_ai_range;\r\ns->insn_read = apci3120_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmdtest = apci3120_ai_cmdtest;\r\ns->do_cmd = apci3120_ai_cmd;\r\ns->cancel = apci3120_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = 8;\r\ns->maxdata = 0x3fff;\r\ns->range_table = &range_bipolar10;\r\ns->insn_write = apci3120_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = apci3120_di_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = apci3120_do_insn_bits;\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_TIMER;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 1;\r\ns->maxdata = 0x00ffffff;\r\ns->insn_config = apci3120_timer_insn_config;\r\ns->insn_read = apci3120_timer_insn_read;\r\nreturn 0;\r\n}\r\nstatic void apci3120_detach(struct comedi_device *dev)\r\n{\r\ncomedi_pci_detach(dev);\r\napci3120_dma_free(dev);\r\n}\r\nstatic int apci3120_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &apci3120_driver, id->driver_data);\r\n}
