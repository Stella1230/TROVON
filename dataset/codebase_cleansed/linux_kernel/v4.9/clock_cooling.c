static int clock_cooling_get_idr(int *id)\r\n{\r\nint ret;\r\nmutex_lock(&cooling_clock_lock);\r\nret = idr_alloc(&clock_idr, NULL, 0, 0, GFP_KERNEL);\r\nmutex_unlock(&cooling_clock_lock);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n*id = ret;\r\nreturn 0;\r\n}\r\nstatic void release_idr(int id)\r\n{\r\nmutex_lock(&cooling_clock_lock);\r\nidr_remove(&clock_idr, id);\r\nmutex_unlock(&cooling_clock_lock);\r\n}\r\nstatic int clock_cooling_get_property(struct clock_cooling_device *ccdev,\r\nunsigned long input,\r\nunsigned long *output,\r\nenum clock_cooling_property property)\r\n{\r\nint i;\r\nunsigned long max_level = 0, level = 0;\r\nunsigned int freq = CPUFREQ_ENTRY_INVALID;\r\nint descend = -1;\r\nstruct cpufreq_frequency_table *pos, *table = ccdev->freq_table;\r\nif (!output)\r\nreturn -EINVAL;\r\nif (!table)\r\nreturn -EINVAL;\r\ncpufreq_for_each_valid_entry(pos, table) {\r\nif (freq == pos->frequency)\r\ncontinue;\r\nif (freq != CPUFREQ_ENTRY_INVALID && descend == -1)\r\ndescend = freq > pos->frequency;\r\nfreq = pos->frequency;\r\nmax_level++;\r\n}\r\nif (max_level == 0)\r\nreturn -EINVAL;\r\nmax_level--;\r\nif (property == GET_MAXL) {\r\n*output = max_level;\r\nreturn 0;\r\n}\r\nif (property == GET_FREQ)\r\nlevel = descend ? input : (max_level - input);\r\ni = 0;\r\ncpufreq_for_each_valid_entry(pos, table) {\r\nif (freq == pos->frequency)\r\ncontinue;\r\nfreq = pos->frequency;\r\nif (property == GET_LEVEL && (unsigned int)input == freq) {\r\n*output = descend ? i : (max_level - i);\r\nreturn 0;\r\n}\r\nif (property == GET_FREQ && level == i) {\r\n*output = freq;\r\nreturn 0;\r\n}\r\ni++;\r\n}\r\nreturn -EINVAL;\r\n}\r\nunsigned long clock_cooling_get_level(struct thermal_cooling_device *cdev,\r\nunsigned long freq)\r\n{\r\nstruct clock_cooling_device *ccdev = cdev->devdata;\r\nunsigned long val;\r\nif (clock_cooling_get_property(ccdev, (unsigned long)freq, &val,\r\nGET_LEVEL))\r\nreturn THERMAL_CSTATE_INVALID;\r\nreturn val;\r\n}\r\nstatic unsigned long\r\nclock_cooling_get_frequency(struct clock_cooling_device *ccdev,\r\nunsigned long level)\r\n{\r\nint ret = 0;\r\nunsigned long freq;\r\nret = clock_cooling_get_property(ccdev, level, &freq, GET_FREQ);\r\nif (ret)\r\nreturn 0;\r\nreturn freq;\r\n}\r\nstatic int clock_cooling_apply(struct clock_cooling_device *ccdev,\r\nunsigned long cooling_state)\r\n{\r\nunsigned long clip_freq, cur_freq;\r\nint ret = 0;\r\nif (ccdev->clock_state == cooling_state)\r\nreturn 0;\r\nclip_freq = clock_cooling_get_frequency(ccdev, cooling_state);\r\nif (!clip_freq)\r\nreturn -EINVAL;\r\ncur_freq = clk_get_rate(ccdev->clk);\r\nmutex_lock(&ccdev->lock);\r\nccdev->clock_state = cooling_state;\r\nccdev->clock_val = clip_freq;\r\nif (cur_freq > clip_freq)\r\nret = clk_set_rate(ccdev->clk, clip_freq);\r\nmutex_unlock(&ccdev->lock);\r\nreturn ret;\r\n}\r\nstatic int clock_cooling_clock_notifier(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct clock_cooling_device *ccdev = to_clock_cooling_device(nb);\r\nswitch (event) {\r\ncase PRE_RATE_CHANGE:\r\nif (ndata->new_rate > ccdev->clock_val)\r\nreturn NOTIFY_BAD;\r\ncase POST_RATE_CHANGE:\r\ncase ABORT_RATE_CHANGE:\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic int clock_cooling_get_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct clock_cooling_device *ccdev = cdev->devdata;\r\nunsigned long count = 0;\r\nint ret;\r\nret = clock_cooling_get_property(ccdev, 0, &count, GET_MAXL);\r\nif (!ret)\r\n*state = count;\r\nreturn ret;\r\n}\r\nstatic int clock_cooling_get_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct clock_cooling_device *ccdev = cdev->devdata;\r\n*state = ccdev->clock_state;\r\nreturn 0;\r\n}\r\nstatic int clock_cooling_set_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long state)\r\n{\r\nstruct clock_cooling_device *clock_device = cdev->devdata;\r\nreturn clock_cooling_apply(clock_device, state);\r\n}\r\nstruct thermal_cooling_device *\r\nclock_cooling_register(struct device *dev, const char *clock_name)\r\n{\r\nstruct thermal_cooling_device *cdev;\r\nstruct clock_cooling_device *ccdev = NULL;\r\nchar dev_name[THERMAL_NAME_LENGTH];\r\nint ret = 0;\r\nccdev = devm_kzalloc(dev, sizeof(*ccdev), GFP_KERNEL);\r\nif (!ccdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&ccdev->lock);\r\nccdev->dev = dev;\r\nccdev->clk = devm_clk_get(dev, clock_name);\r\nif (IS_ERR(ccdev->clk))\r\nreturn ERR_CAST(ccdev->clk);\r\nret = clock_cooling_get_idr(&ccdev->id);\r\nif (ret)\r\nreturn ERR_PTR(-EINVAL);\r\nsnprintf(dev_name, sizeof(dev_name), "thermal-clock-%d", ccdev->id);\r\ncdev = thermal_cooling_device_register(dev_name, ccdev,\r\n&clock_cooling_ops);\r\nif (IS_ERR(cdev)) {\r\nrelease_idr(ccdev->id);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nccdev->cdev = cdev;\r\nccdev->clk_rate_change_nb.notifier_call = clock_cooling_clock_notifier;\r\nret = dev_pm_opp_init_cpufreq_table(dev, &ccdev->freq_table);\r\nif (ret) {\r\nrelease_idr(ccdev->id);\r\nreturn ERR_PTR(ret);\r\n}\r\nccdev->clock_state = 0;\r\nccdev->clock_val = clock_cooling_get_frequency(ccdev, 0);\r\nclk_notifier_register(ccdev->clk, &ccdev->clk_rate_change_nb);\r\nreturn cdev;\r\n}\r\nvoid clock_cooling_unregister(struct thermal_cooling_device *cdev)\r\n{\r\nstruct clock_cooling_device *ccdev;\r\nif (!cdev)\r\nreturn;\r\nccdev = cdev->devdata;\r\nclk_notifier_unregister(ccdev->clk, &ccdev->clk_rate_change_nb);\r\ndev_pm_opp_free_cpufreq_table(ccdev->dev, &ccdev->freq_table);\r\nthermal_cooling_device_unregister(ccdev->cdev);\r\nrelease_idr(ccdev->id);\r\n}
