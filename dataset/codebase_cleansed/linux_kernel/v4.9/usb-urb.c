static void usb_urb_complete(struct urb *urb)\r\n{\r\nstruct usb_data_stream *stream = urb->context;\r\nint ptype = usb_pipetype(urb->pipe);\r\nint i;\r\nu8 *b;\r\ndeb_uxfer("'%s' urb completed. status: %d, length: %d/%d, pack_num: %d, errors: %d\n",\r\nptype == PIPE_ISOCHRONOUS ? "isoc" : "bulk",\r\nurb->status,urb->actual_length,urb->transfer_buffer_length,\r\nurb->number_of_packets,urb->error_count);\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndeb_ts("urb completition error %d.\n", urb->status);\r\nbreak;\r\n}\r\nb = (u8 *) urb->transfer_buffer;\r\nswitch (ptype) {\r\ncase PIPE_ISOCHRONOUS:\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (urb->iso_frame_desc[i].status != 0)\r\ndeb_ts("iso frame descriptor has an error: %d\n",urb->iso_frame_desc[i].status);\r\nelse if (urb->iso_frame_desc[i].actual_length > 0)\r\nstream->complete(stream, b + urb->iso_frame_desc[i].offset, urb->iso_frame_desc[i].actual_length);\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\ndebug_dump(b,20,deb_uxfer);\r\nbreak;\r\ncase PIPE_BULK:\r\nif (urb->actual_length > 0)\r\nstream->complete(stream, b, urb->actual_length);\r\nbreak;\r\ndefault:\r\nerr("unknown endpoint type in completition handler.");\r\nreturn;\r\n}\r\nusb_submit_urb(urb,GFP_ATOMIC);\r\n}\r\nint usb_urb_kill(struct usb_data_stream *stream)\r\n{\r\nint i;\r\nfor (i = 0; i < stream->urbs_submitted; i++) {\r\ndeb_ts("killing URB no. %d.\n",i);\r\nusb_kill_urb(stream->urb_list[i]);\r\n}\r\nstream->urbs_submitted = 0;\r\nreturn 0;\r\n}\r\nint usb_urb_submit(struct usb_data_stream *stream)\r\n{\r\nint i,ret;\r\nfor (i = 0; i < stream->urbs_initialized; i++) {\r\ndeb_ts("submitting URB no. %d\n",i);\r\nif ((ret = usb_submit_urb(stream->urb_list[i],GFP_ATOMIC))) {\r\nerr("could not submit URB no. %d - get them all back",i);\r\nusb_urb_kill(stream);\r\nreturn ret;\r\n}\r\nstream->urbs_submitted++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_free_stream_buffers(struct usb_data_stream *stream)\r\n{\r\nif (stream->state & USB_STATE_URB_BUF) {\r\nwhile (stream->buf_num) {\r\nstream->buf_num--;\r\ndeb_mem("freeing buffer %d\n",stream->buf_num);\r\nusb_free_coherent(stream->udev, stream->buf_size,\r\nstream->buf_list[stream->buf_num],\r\nstream->dma_addr[stream->buf_num]);\r\n}\r\n}\r\nstream->state &= ~USB_STATE_URB_BUF;\r\nreturn 0;\r\n}\r\nstatic int usb_allocate_stream_buffers(struct usb_data_stream *stream, int num, unsigned long size)\r\n{\r\nstream->buf_num = 0;\r\nstream->buf_size = size;\r\ndeb_mem("all in all I will use %lu bytes for streaming\n",num*size);\r\nfor (stream->buf_num = 0; stream->buf_num < num; stream->buf_num++) {\r\ndeb_mem("allocating buffer %d\n",stream->buf_num);\r\nif (( stream->buf_list[stream->buf_num] =\r\nusb_alloc_coherent(stream->udev, size, GFP_ATOMIC,\r\n&stream->dma_addr[stream->buf_num]) ) == NULL) {\r\ndeb_mem("not enough memory for urb-buffer allocation.\n");\r\nusb_free_stream_buffers(stream);\r\nreturn -ENOMEM;\r\n}\r\ndeb_mem("buffer %d: %p (dma: %Lu)\n",\r\nstream->buf_num,\r\nstream->buf_list[stream->buf_num], (long long)stream->dma_addr[stream->buf_num]);\r\nmemset(stream->buf_list[stream->buf_num],0,size);\r\nstream->state |= USB_STATE_URB_BUF;\r\n}\r\ndeb_mem("allocation successful\n");\r\nreturn 0;\r\n}\r\nstatic int usb_bulk_urb_init(struct usb_data_stream *stream)\r\n{\r\nint i, j;\r\nif ((i = usb_allocate_stream_buffers(stream,stream->props.count,\r\nstream->props.u.bulk.buffersize)) < 0)\r\nreturn i;\r\nfor (i = 0; i < stream->props.count; i++) {\r\nstream->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!stream->urb_list[i]) {\r\ndeb_mem("not enough memory for urb_alloc_urb!.\n");\r\nfor (j = 0; j < i; j++)\r\nusb_free_urb(stream->urb_list[j]);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb( stream->urb_list[i], stream->udev,\r\nusb_rcvbulkpipe(stream->udev,stream->props.endpoint),\r\nstream->buf_list[i],\r\nstream->props.u.bulk.buffersize,\r\nusb_urb_complete, stream);\r\nstream->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\nstream->urb_list[i]->transfer_dma = stream->dma_addr[i];\r\nstream->urbs_initialized++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_isoc_urb_init(struct usb_data_stream *stream)\r\n{\r\nint i,j;\r\nif ((i = usb_allocate_stream_buffers(stream,stream->props.count,\r\nstream->props.u.isoc.framesize*stream->props.u.isoc.framesperurb)) < 0)\r\nreturn i;\r\nfor (i = 0; i < stream->props.count; i++) {\r\nstruct urb *urb;\r\nint frame_offset = 0;\r\nstream->urb_list[i] = usb_alloc_urb(stream->props.u.isoc.framesperurb, GFP_ATOMIC);\r\nif (!stream->urb_list[i]) {\r\ndeb_mem("not enough memory for urb_alloc_urb!\n");\r\nfor (j = 0; j < i; j++)\r\nusb_free_urb(stream->urb_list[j]);\r\nreturn -ENOMEM;\r\n}\r\nurb = stream->urb_list[i];\r\nurb->dev = stream->udev;\r\nurb->context = stream;\r\nurb->complete = usb_urb_complete;\r\nurb->pipe = usb_rcvisocpipe(stream->udev,stream->props.endpoint);\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nurb->interval = stream->props.u.isoc.interval;\r\nurb->number_of_packets = stream->props.u.isoc.framesperurb;\r\nurb->transfer_buffer_length = stream->buf_size;\r\nurb->transfer_buffer = stream->buf_list[i];\r\nurb->transfer_dma = stream->dma_addr[i];\r\nfor (j = 0; j < stream->props.u.isoc.framesperurb; j++) {\r\nurb->iso_frame_desc[j].offset = frame_offset;\r\nurb->iso_frame_desc[j].length = stream->props.u.isoc.framesize;\r\nframe_offset += stream->props.u.isoc.framesize;\r\n}\r\nstream->urbs_initialized++;\r\n}\r\nreturn 0;\r\n}\r\nint usb_urb_init(struct usb_data_stream *stream, struct usb_data_stream_properties *props)\r\n{\r\nif (stream == NULL || props == NULL)\r\nreturn -EINVAL;\r\nmemcpy(&stream->props, props, sizeof(*props));\r\nusb_clear_halt(stream->udev,usb_rcvbulkpipe(stream->udev,stream->props.endpoint));\r\nif (stream->complete == NULL) {\r\nerr("there is no data callback - this doesn't make sense.");\r\nreturn -EINVAL;\r\n}\r\nswitch (stream->props.type) {\r\ncase USB_BULK:\r\nreturn usb_bulk_urb_init(stream);\r\ncase USB_ISOC:\r\nreturn usb_isoc_urb_init(stream);\r\ndefault:\r\nerr("unknown URB-type for data transfer.");\r\nreturn -EINVAL;\r\n}\r\n}\r\nint usb_urb_exit(struct usb_data_stream *stream)\r\n{\r\nint i;\r\nusb_urb_kill(stream);\r\nfor (i = 0; i < stream->urbs_initialized; i++) {\r\nif (stream->urb_list[i] != NULL) {\r\ndeb_mem("freeing URB no. %d.\n",i);\r\nusb_free_urb(stream->urb_list[i]);\r\n}\r\n}\r\nstream->urbs_initialized = 0;\r\nusb_free_stream_buffers(stream);\r\nreturn 0;\r\n}
