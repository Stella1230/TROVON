static bool max98504_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX98504_INTERRUPT_STATUS:\r\ncase MAX98504_INTERRUPT_FLAGS:\r\ncase MAX98504_INTERRUPT_FLAG_CLEARS:\r\ncase MAX98504_WATCHDOG_CLEAR:\r\ncase MAX98504_GLOBAL_ENABLE:\r\ncase MAX98504_SOFTWARE_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool max98504_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX98504_SOFTWARE_RESET:\r\ncase MAX98504_WATCHDOG_CLEAR:\r\ncase MAX98504_INTERRUPT_FLAG_CLEARS:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic int max98504_pcm_rx_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\r\nstruct max98504_priv *max98504 = snd_soc_component_get_drvdata(c);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nregmap_write(max98504->regmap, MAX98504_PCM_RX_ENABLE,\r\nmax98504->pcm_rx_channels);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nregmap_write(max98504->regmap, MAX98504_PCM_RX_ENABLE, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98504_component_probe(struct snd_soc_component *c)\r\n{\r\nstruct max98504_priv *max98504 = snd_soc_component_get_drvdata(c);\r\nstruct regmap *map = max98504->regmap;\r\nint ret;\r\nret = regulator_bulk_enable(MAX98504_NUM_SUPPLIES, max98504->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\nregmap_write(map, MAX98504_SOFTWARE_RESET, 0x1);\r\nmsleep(20);\r\nif (!max98504->brownout_enable)\r\nreturn 0;\r\nregmap_write(map, MAX98504_PVDD_BROWNOUT_ENABLE, 0x1);\r\nregmap_write(map, MAX98504_PVDD_BROWNOUT_CONFIG_1,\r\n(max98504->brownout_threshold & 0x1f) << 3 |\r\n(max98504->brownout_attenuation & 0x3));\r\nregmap_write(map, MAX98504_PVDD_BROWNOUT_CONFIG_2,\r\nmax98504->brownout_attack_hold & 0xff);\r\nregmap_write(map, MAX98504_PVDD_BROWNOUT_CONFIG_3,\r\nmax98504->brownout_timed_hold & 0xff);\r\nregmap_write(map, MAX98504_PVDD_BROWNOUT_CONFIG_4,\r\nmax98504->brownout_release_rate & 0xff);\r\nreturn 0;\r\n}\r\nstatic void max98504_component_remove(struct snd_soc_component *c)\r\n{\r\nstruct max98504_priv *max98504 = snd_soc_component_get_drvdata(c);\r\nregulator_bulk_disable(MAX98504_NUM_SUPPLIES, max98504->supplies);\r\n}\r\nstatic int max98504_set_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct max98504_priv *max98504 = snd_soc_dai_get_drvdata(dai);\r\nstruct regmap *map = max98504->regmap;\r\nswitch (dai->id) {\r\ncase MAX98504_DAI_ID_PCM:\r\nregmap_write(map, MAX98504_PCM_TX_ENABLE, tx_mask);\r\nmax98504->pcm_rx_channels = rx_mask;\r\nbreak;\r\ncase MAX98504_DAI_ID_PDM:\r\nregmap_write(map, MAX98504_PDM_TX_ENABLE, tx_mask);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98504_set_channel_map(struct snd_soc_dai *dai,\r\nunsigned int tx_num, unsigned int *tx_slot,\r\nunsigned int rx_num, unsigned int *rx_slot)\r\n{\r\nstruct max98504_priv *max98504 = snd_soc_dai_get_drvdata(dai);\r\nstruct regmap *map = max98504->regmap;\r\nunsigned int i, sources = 0;\r\nfor (i = 0; i < tx_num; i++)\r\nif (tx_slot[i])\r\nsources |= (1 << i);\r\nswitch (dai->id) {\r\ncase MAX98504_DAI_ID_PCM:\r\nregmap_write(map, MAX98504_PCM_TX_CHANNEL_SOURCES,\r\nsources);\r\nbreak;\r\ncase MAX98504_DAI_ID_PDM:\r\nregmap_write(map, MAX98504_PDM_TX_CONTROL, sources);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nregmap_write(map, MAX98504_MEASUREMENT_ENABLE, sources ? 0x3 : 0x01);\r\nreturn 0;\r\n}\r\nstatic int max98504_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct max98504_priv *max98504;\r\nint i, ret;\r\nmax98504 = devm_kzalloc(dev, sizeof(*max98504), GFP_KERNEL);\r\nif (!max98504)\r\nreturn -ENOMEM;\r\nif (node) {\r\nif (!of_property_read_u32(node, "maxim,brownout-threshold",\r\n&max98504->brownout_threshold))\r\nmax98504->brownout_enable = true;\r\nof_property_read_u32(node, "maxim,brownout-attenuation",\r\n&max98504->brownout_attenuation);\r\nof_property_read_u32(node, "maxim,brownout-attack-hold-ms",\r\n&max98504->brownout_attack_hold);\r\nof_property_read_u32(node, "maxim,brownout-timed-hold-ms",\r\n&max98504->brownout_timed_hold);\r\nof_property_read_u32(node, "maxim,brownout-release-rate-ms",\r\n&max98504->brownout_release_rate);\r\n}\r\nmax98504->regmap = devm_regmap_init_i2c(client, &max98504_regmap);\r\nif (IS_ERR(max98504->regmap)) {\r\nret = PTR_ERR(max98504->regmap);\r\ndev_err(&client->dev, "regmap initialization failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < MAX98504_NUM_SUPPLIES; i++)\r\nmax98504->supplies[i].supply = max98504_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, MAX98504_NUM_SUPPLIES,\r\nmax98504->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\ni2c_set_clientdata(client, max98504);\r\nreturn devm_snd_soc_register_component(dev, &max98504_component_driver,\r\nmax98504_dai, ARRAY_SIZE(max98504_dai));\r\n}
