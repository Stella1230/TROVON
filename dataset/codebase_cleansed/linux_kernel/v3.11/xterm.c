static void *xterm_init(char *str, int device, const struct chan_opts *opts)\r\n{\r\nstruct xterm_chan *data;\r\ndata = uml_kmalloc(sizeof(*data), UM_GFP_KERNEL);\r\nif (data == NULL)\r\nreturn NULL;\r\n*data = ((struct xterm_chan) { .pid = -1,\r\n.helper_pid = -1,\r\n.device = device,\r\n.title = opts->xterm_title,\r\n.raw = opts->raw } );\r\nreturn data;\r\n}\r\nstatic int __init xterm_setup(char *line, int *add)\r\n{\r\n*add = 0;\r\nterminal_emulator = line;\r\nline = strchr(line, ',');\r\nif (line == NULL)\r\nreturn 0;\r\n*line++ = '\0';\r\nif (*line)\r\ntitle_switch = line;\r\nline = strchr(line, ',');\r\nif (line == NULL)\r\nreturn 0;\r\n*line++ = '\0';\r\nif (*line)\r\nexec_switch = line;\r\nreturn 0;\r\n}\r\nstatic int xterm_open(int input, int output, int primary, void *d,\r\nchar **dev_out)\r\n{\r\nstruct xterm_chan *data = d;\r\nint pid, fd, new, err;\r\nchar title[256], file[] = "/tmp/xterm-pipeXXXXXX";\r\nchar *argv[] = { terminal_emulator, title_switch, title, exec_switch,\r\nOS_LIB_PATH "/uml/port-helper", "-uml-socket",\r\nfile, NULL };\r\nif (access(argv[4], X_OK) < 0)\r\nargv[4] = "port-helper";\r\nif (getenv("DISPLAY") == NULL) {\r\nprintk(UM_KERN_ERR "xterm_open: $DISPLAY not set.\n");\r\nreturn -ENODEV;\r\n}\r\nfd = mkstemp(file);\r\nif (fd < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "xterm_open : mkstemp failed, errno = %d\n",\r\nerrno);\r\nreturn err;\r\n}\r\nif (unlink(file)) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "xterm_open : unlink failed, errno = %d\n",\r\nerrno);\r\nclose(fd);\r\nreturn err;\r\n}\r\nclose(fd);\r\nfd = os_create_unix_socket(file, sizeof(file), 1);\r\nif (fd < 0) {\r\nprintk(UM_KERN_ERR "xterm_open : create_unix_socket failed, "\r\n"errno = %d\n", -fd);\r\nreturn fd;\r\n}\r\nsprintf(title, data->title, data->device);\r\npid = run_helper(NULL, NULL, argv);\r\nif (pid < 0) {\r\nerr = pid;\r\nprintk(UM_KERN_ERR "xterm_open : run_helper failed, "\r\n"errno = %d\n", -err);\r\ngoto out_close1;\r\n}\r\nerr = os_set_fd_block(fd, 0);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "xterm_open : failed to set descriptor "\r\n"non-blocking, err = %d\n", -err);\r\ngoto out_kill;\r\n}\r\nnew = xterm_fd(fd, &data->helper_pid);\r\nif (new < 0) {\r\nerr = new;\r\nprintk(UM_KERN_ERR "xterm_open : os_rcv_fd failed, err = %d\n",\r\n-err);\r\ngoto out_kill;\r\n}\r\nerr = os_set_fd_block(new, 0);\r\nif (err) {\r\nprintk(UM_KERN_ERR "xterm_open : failed to set xterm "\r\n"descriptor non-blocking, err = %d\n", -err);\r\ngoto out_close2;\r\n}\r\nCATCH_EINTR(err = tcgetattr(new, &data->tt));\r\nif (err) {\r\nnew = err;\r\ngoto out_close2;\r\n}\r\nif (data->raw) {\r\nerr = raw(new);\r\nif (err) {\r\nnew = err;\r\ngoto out_close2;\r\n}\r\n}\r\nunlink(file);\r\ndata->pid = pid;\r\n*dev_out = NULL;\r\nreturn new;\r\nout_close2:\r\nclose(new);\r\nout_kill:\r\nos_kill_process(pid, 1);\r\nout_close1:\r\nclose(fd);\r\nreturn err;\r\n}\r\nstatic void xterm_close(int fd, void *d)\r\n{\r\nstruct xterm_chan *data = d;\r\nif (data->pid != -1)\r\nos_kill_process(data->pid, 1);\r\ndata->pid = -1;\r\nif (data->helper_pid != -1)\r\nos_kill_process(data->helper_pid, 0);\r\ndata->helper_pid = -1;\r\nos_close_file(fd);\r\n}
