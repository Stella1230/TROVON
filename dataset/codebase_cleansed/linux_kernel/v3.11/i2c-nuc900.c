static inline void nuc900_i2c_master_complete(struct nuc900_i2c *i2c, int ret)\r\n{\r\ndev_dbg(i2c->dev, "master_complete %d\n", ret);\r\ni2c->msg_ptr = 0;\r\ni2c->msg = NULL;\r\ni2c->msg_idx++;\r\ni2c->msg_num = 0;\r\nif (ret)\r\ni2c->msg_idx = ret;\r\nwake_up(&i2c->wait);\r\n}\r\nstatic inline void nuc900_i2c_disable_irq(struct nuc900_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + CSR);\r\nwritel(tmp & ~IRQEN, i2c->regs + CSR);\r\n}\r\nstatic inline void nuc900_i2c_enable_irq(struct nuc900_i2c *i2c)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(i2c->regs + CSR);\r\nwritel(tmp | IRQEN, i2c->regs + CSR);\r\n}\r\nstatic void nuc900_i2c_message_start(struct nuc900_i2c *i2c,\r\nstruct i2c_msg *msg)\r\n{\r\nunsigned int addr = (msg->addr & 0x7f) << 1;\r\nif (msg->flags & I2C_M_RD)\r\naddr |= 0x1;\r\nwritel(addr & 0xff, i2c->regs + TXR);\r\nwritel(I2C_CMD_START | I2C_CMD_WRITE, i2c->regs + CMDR);\r\n}\r\nstatic inline void nuc900_i2c_stop(struct nuc900_i2c *i2c, int ret)\r\n{\r\ndev_dbg(i2c->dev, "STOP\n");\r\ni2c->state = STATE_STOP;\r\nwritel(I2C_CMD_STOP, i2c->regs + CMDR);\r\nnuc900_i2c_master_complete(i2c, ret);\r\nnuc900_i2c_disable_irq(i2c);\r\n}\r\nstatic inline int is_lastmsg(struct nuc900_i2c *i2c)\r\n{\r\nreturn i2c->msg_idx >= (i2c->msg_num - 1);\r\n}\r\nstatic inline int is_msglast(struct nuc900_i2c *i2c)\r\n{\r\nreturn i2c->msg_ptr == i2c->msg->len-1;\r\n}\r\nstatic inline int is_msgend(struct nuc900_i2c *i2c)\r\n{\r\nreturn i2c->msg_ptr >= i2c->msg->len;\r\n}\r\nstatic void i2c_nuc900_irq_nextbyte(struct nuc900_i2c *i2c,\r\nunsigned long iicstat)\r\n{\r\nunsigned char byte;\r\nswitch (i2c->state) {\r\ncase STATE_IDLE:\r\ndev_err(i2c->dev, "%s: called in STATE_IDLE\n", __func__);\r\nbreak;\r\ncase STATE_STOP:\r\ndev_err(i2c->dev, "%s: called in STATE_STOP\n", __func__);\r\nnuc900_i2c_disable_irq(i2c);\r\nbreak;\r\ncase STATE_START:\r\nif (iicstat & SLAVE_ACK &&\r\n!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {\r\ndev_dbg(i2c->dev, "ack was not received\n");\r\nnuc900_i2c_stop(i2c, -ENXIO);\r\nbreak;\r\n}\r\nif (i2c->msg->flags & I2C_M_RD)\r\ni2c->state = STATE_READ;\r\nelse\r\ni2c->state = STATE_WRITE;\r\nif (is_lastmsg(i2c) && i2c->msg->len == 0) {\r\nnuc900_i2c_stop(i2c, 0);\r\nbreak;\r\n}\r\nif (i2c->state == STATE_READ)\r\ngoto prepare_read;\r\ncase STATE_WRITE:\r\nif (!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {\r\nif (iicstat & SLAVE_ACK) {\r\ndev_dbg(i2c->dev, "WRITE: No Ack\n");\r\nnuc900_i2c_stop(i2c, -ECONNREFUSED);\r\nbreak;\r\n}\r\n}\r\nretry_write:\r\nif (!is_msgend(i2c)) {\r\nbyte = i2c->msg->buf[i2c->msg_ptr++];\r\nwriteb(byte, i2c->regs + TXR);\r\nwritel(I2C_CMD_WRITE, i2c->regs + CMDR);\r\n} else if (!is_lastmsg(i2c)) {\r\ndev_dbg(i2c->dev, "WRITE: Next Message\n");\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx++;\r\ni2c->msg++;\r\nif (i2c->msg->flags & I2C_M_NOSTART) {\r\nif (i2c->msg->flags & I2C_M_RD) {\r\nnuc900_i2c_stop(i2c, -EINVAL);\r\n}\r\ngoto retry_write;\r\n} else {\r\nnuc900_i2c_message_start(i2c, i2c->msg);\r\ni2c->state = STATE_START;\r\n}\r\n} else {\r\nnuc900_i2c_stop(i2c, 0);\r\n}\r\nbreak;\r\ncase STATE_READ:\r\nbyte = readb(i2c->regs + RXR);\r\ni2c->msg->buf[i2c->msg_ptr++] = byte;\r\nprepare_read:\r\nif (is_msglast(i2c)) {\r\nif (is_lastmsg(i2c))\r\nwritel(I2C_CMD_READ | I2C_CMD_NACK,\r\ni2c->regs + CMDR);\r\n} else if (is_msgend(i2c)) {\r\nif (is_lastmsg(i2c)) {\r\ndev_dbg(i2c->dev, "READ: Send Stop\n");\r\nnuc900_i2c_stop(i2c, 0);\r\n} else {\r\ndev_dbg(i2c->dev, "READ: Next Transfer\n");\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx++;\r\ni2c->msg++;\r\nwritel(I2C_CMD_READ, i2c->regs + CMDR);\r\n}\r\n} else {\r\nwritel(I2C_CMD_READ, i2c->regs + CMDR);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t nuc900_i2c_irq(int irqno, void *dev_id)\r\n{\r\nstruct nuc900_i2c *i2c = dev_id;\r\nunsigned long status;\r\nstatus = readl(i2c->regs + CSR);\r\nwritel(status | IRQFLAG, i2c->regs + CSR);\r\nif (status & ARBIT_LOST) {\r\ndev_err(i2c->dev, "deal with arbitration loss\n");\r\ngoto out;\r\n}\r\nif (i2c->state == STATE_IDLE) {\r\ndev_dbg(i2c->dev, "IRQ: error i2c->state == IDLE\n");\r\ngoto out;\r\n}\r\ni2c_nuc900_irq_nextbyte(i2c, status);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nuc900_i2c_set_master(struct nuc900_i2c *i2c)\r\n{\r\nint timeout = 400;\r\nwhile (timeout-- > 0) {\r\nif (((readl(i2c->regs + SWR) & I2CSTART) == I2CSTART) &&\r\n((readl(i2c->regs + CSR) & I2CBUSY) == 0)) {\r\nreturn 0;\r\n}\r\nmsleep(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int nuc900_i2c_doxfer(struct nuc900_i2c *i2c,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nunsigned long iicstat, timeout;\r\nint spins = 20;\r\nint ret;\r\nret = nuc900_i2c_set_master(i2c);\r\nif (ret != 0) {\r\ndev_err(i2c->dev, "cannot get bus (error %d)\n", ret);\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nspin_lock_irq(&i2c->lock);\r\ni2c->msg = msgs;\r\ni2c->msg_num = num;\r\ni2c->msg_ptr = 0;\r\ni2c->msg_idx = 0;\r\ni2c->state = STATE_START;\r\nnuc900_i2c_message_start(i2c, msgs);\r\nspin_unlock_irq(&i2c->lock);\r\ntimeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);\r\nret = i2c->msg_idx;\r\nif (timeout == 0)\r\ndev_dbg(i2c->dev, "timeout\n");\r\nelse if (ret != num)\r\ndev_dbg(i2c->dev, "incomplete xfer (%d)\n", ret);\r\ndev_dbg(i2c->dev, "waiting for bus idle\n");\r\ndo {\r\niicstat = readl(i2c->regs + CSR);\r\n} while ((iicstat & I2CBUSY) && --spins);\r\nif (!spins) {\r\nmsleep(1);\r\niicstat = readl(i2c->regs + CSR);\r\n}\r\nif (iicstat & I2CBUSY)\r\ndev_warn(i2c->dev, "timeout waiting for bus idle\n");\r\nout:\r\nreturn ret;\r\n}\r\nstatic int nuc900_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct nuc900_i2c *i2c = (struct nuc900_i2c *)adap->algo_data;\r\nint retry;\r\nint ret;\r\nnuc900_i2c_enable_irq(i2c);\r\nfor (retry = 0; retry < adap->retries; retry++) {\r\nret = nuc900_i2c_doxfer(i2c, msgs, num);\r\nif (ret != -EAGAIN)\r\nreturn ret;\r\ndev_dbg(i2c->dev, "Retrying transmission (%d)\n", retry);\r\nudelay(100);\r\n}\r\nreturn -EREMOTEIO;\r\n}\r\nstatic u32 nuc900_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_NOSTART |\r\nI2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic int nuc900_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct nuc900_i2c *i2c;\r\nstruct nuc900_platform_i2c *pdata;\r\nstruct resource *res;\r\nint ret;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\ni2c = kzalloc(sizeof(struct nuc900_i2c), GFP_KERNEL);\r\nif (!i2c) {\r\ndev_err(&pdev->dev, "no memory for state\n");\r\nreturn -ENOMEM;\r\n}\r\nstrlcpy(i2c->adap.name, "nuc900-i2c0", sizeof(i2c->adap.name));\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &nuc900_i2c_algorithm;\r\ni2c->adap.retries = 2;\r\ni2c->adap.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nspin_lock_init(&i2c->lock);\r\ninit_waitqueue_head(&i2c->wait);\r\ni2c->dev = &pdev->dev;\r\ni2c->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2c->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nret = -ENOENT;\r\ngoto err_noclk;\r\n}\r\ndev_dbg(&pdev->dev, "clock source %p\n", i2c->clk);\r\nclk_enable(i2c->clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "cannot find IO resource\n");\r\nret = -ENOENT;\r\ngoto err_clk;\r\n}\r\ni2c->ioarea = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (i2c->ioarea == NULL) {\r\ndev_err(&pdev->dev, "cannot request IO\n");\r\nret = -ENXIO;\r\ngoto err_clk;\r\n}\r\ni2c->regs = ioremap(res->start, resource_size(res));\r\nif (i2c->regs == NULL) {\r\ndev_err(&pdev->dev, "cannot map IO\n");\r\nret = -ENXIO;\r\ngoto err_ioarea;\r\n}\r\ndev_dbg(&pdev->dev, "registers %p (%p, %p)\n",\r\ni2c->regs, i2c->ioarea, res);\r\ni2c->adap.algo_data = i2c;\r\ni2c->adap.dev.parent = &pdev->dev;\r\nmfp_set_groupg(&pdev->dev, NULL);\r\nclk_get_rate(i2c->clk);\r\nret = (i2c->clk.apbfreq)/(pdata->bus_freq * 5) - 1;\r\nwritel(ret & 0xffff, i2c->regs + DIVIDER);\r\ni2c->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_err(&pdev->dev, "cannot find IRQ\n");\r\ngoto err_iomap;\r\n}\r\nret = request_irq(i2c->irq, nuc900_i2c_irq, IRQF_SHARED,\r\ndev_name(&pdev->dev), i2c);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "cannot claim IRQ %d\n", i2c->irq);\r\ngoto err_iomap;\r\n}\r\ni2c->adap.nr = pdata->bus_num;\r\nret = i2c_add_numbered_adapter(&i2c->adap);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add bus to i2c core\n");\r\ngoto err_irq;\r\n}\r\nplatform_set_drvdata(pdev, i2c);\r\ndev_info(&pdev->dev, "%s: NUC900 I2C adapter\n",\r\ndev_name(&i2c->adap.dev));\r\nreturn 0;\r\nerr_irq:\r\nfree_irq(i2c->irq, i2c);\r\nerr_iomap:\r\niounmap(i2c->regs);\r\nerr_ioarea:\r\nrelease_resource(i2c->ioarea);\r\nkfree(i2c->ioarea);\r\nerr_clk:\r\nclk_disable(i2c->clk);\r\nclk_put(i2c->clk);\r\nerr_noclk:\r\nkfree(i2c);\r\nreturn ret;\r\n}\r\nstatic int nuc900_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct nuc900_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nfree_irq(i2c->irq, i2c);\r\nclk_disable(i2c->clk);\r\nclk_put(i2c->clk);\r\niounmap(i2c->regs);\r\nrelease_resource(i2c->ioarea);\r\nkfree(i2c->ioarea);\r\nkfree(i2c);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_adap_nuc900_init(void)\r\n{\r\nreturn platform_driver_register(&nuc900_i2c_driver);\r\n}\r\nstatic void __exit i2c_adap_nuc900_exit(void)\r\n{\r\nplatform_driver_unregister(&nuc900_i2c_driver);\r\n}
