static inline unsigned keyring_hash(const char *desc)\r\n{\r\nunsigned bucket = 0;\r\nfor (; *desc; desc++)\r\nbucket += (unsigned char)*desc;\r\nreturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\r\n}\r\nstatic void keyring_publish_name(struct key *keyring)\r\n{\r\nint bucket;\r\nif (keyring->description) {\r\nbucket = keyring_hash(keyring->description);\r\nwrite_lock(&keyring_name_lock);\r\nif (!keyring_name_hash[bucket].next)\r\nINIT_LIST_HEAD(&keyring_name_hash[bucket]);\r\nlist_add_tail(&keyring->type_data.link,\r\n&keyring_name_hash[bucket]);\r\nwrite_unlock(&keyring_name_lock);\r\n}\r\n}\r\nstatic int keyring_instantiate(struct key *keyring,\r\nstruct key_preparsed_payload *prep)\r\n{\r\nint ret;\r\nret = -EINVAL;\r\nif (prep->datalen == 0) {\r\nkeyring_publish_name(keyring);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int keyring_match(const struct key *keyring, const void *description)\r\n{\r\nreturn keyring->description &&\r\nstrcmp(keyring->description, description) == 0;\r\n}\r\nstatic void keyring_destroy(struct key *keyring)\r\n{\r\nstruct keyring_list *klist;\r\nint loop;\r\nif (keyring->description) {\r\nwrite_lock(&keyring_name_lock);\r\nif (keyring->type_data.link.next != NULL &&\r\n!list_empty(&keyring->type_data.link))\r\nlist_del(&keyring->type_data.link);\r\nwrite_unlock(&keyring_name_lock);\r\n}\r\nklist = rcu_access_pointer(keyring->payload.subscriptions);\r\nif (klist) {\r\nfor (loop = klist->nkeys - 1; loop >= 0; loop--)\r\nkey_put(rcu_access_pointer(klist->keys[loop]));\r\nkfree(klist);\r\n}\r\n}\r\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\r\n{\r\nstruct keyring_list *klist;\r\nif (keyring->description)\r\nseq_puts(m, keyring->description);\r\nelse\r\nseq_puts(m, "[anon]");\r\nif (key_is_instantiated(keyring)) {\r\nrcu_read_lock();\r\nklist = rcu_dereference(keyring->payload.subscriptions);\r\nif (klist)\r\nseq_printf(m, ": %u/%u", klist->nkeys, klist->maxkeys);\r\nelse\r\nseq_puts(m, ": empty");\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic long keyring_read(const struct key *keyring,\r\nchar __user *buffer, size_t buflen)\r\n{\r\nstruct keyring_list *klist;\r\nstruct key *key;\r\nsize_t qty, tmp;\r\nint loop, ret;\r\nret = 0;\r\nklist = rcu_dereference_locked_keyring(keyring);\r\nif (klist) {\r\nqty = klist->nkeys * sizeof(key_serial_t);\r\nif (buffer && buflen > 0) {\r\nif (buflen > qty)\r\nbuflen = qty;\r\nret = -EFAULT;\r\nfor (loop = 0; loop < klist->nkeys; loop++) {\r\nkey = rcu_deref_link_locked(klist, loop,\r\nkeyring);\r\ntmp = sizeof(key_serial_t);\r\nif (tmp > buflen)\r\ntmp = buflen;\r\nif (copy_to_user(buffer,\r\n&key->serial,\r\ntmp) != 0)\r\ngoto error;\r\nbuflen -= tmp;\r\nif (buflen == 0)\r\nbreak;\r\nbuffer += tmp;\r\n}\r\n}\r\nret = qty;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\r\nconst struct cred *cred, key_perm_t perm,\r\nunsigned long flags, struct key *dest)\r\n{\r\nstruct key *keyring;\r\nint ret;\r\nkeyring = key_alloc(&key_type_keyring, description,\r\nuid, gid, cred, perm, flags);\r\nif (!IS_ERR(keyring)) {\r\nret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\r\nif (ret < 0) {\r\nkey_put(keyring);\r\nkeyring = ERR_PTR(ret);\r\n}\r\n}\r\nreturn keyring;\r\n}\r\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\r\nconst struct cred *cred,\r\nstruct key_type *type,\r\nconst void *description,\r\nkey_match_func_t match,\r\nbool no_state_check)\r\n{\r\nstruct {\r\nstruct key *keyring;\r\nstruct keyring_list *keylist;\r\nint kix;\r\n} stack[KEYRING_SEARCH_MAX_DEPTH];\r\nstruct keyring_list *keylist;\r\nstruct timespec now;\r\nunsigned long possessed, kflags;\r\nstruct key *keyring, *key;\r\nkey_ref_t key_ref;\r\nlong err;\r\nint sp, nkeys, kix;\r\nkeyring = key_ref_to_ptr(keyring_ref);\r\npossessed = is_key_possessed(keyring_ref);\r\nkey_check(keyring);\r\nerr = key_task_permission(keyring_ref, cred, KEY_SEARCH);\r\nif (err < 0) {\r\nkey_ref = ERR_PTR(err);\r\ngoto error;\r\n}\r\nkey_ref = ERR_PTR(-ENOTDIR);\r\nif (keyring->type != &key_type_keyring)\r\ngoto error;\r\nrcu_read_lock();\r\nnow = current_kernel_time();\r\nerr = -EAGAIN;\r\nsp = 0;\r\nkey_ref = ERR_PTR(-EAGAIN);\r\nkflags = keyring->flags;\r\nif (keyring->type == type && match(keyring, description)) {\r\nkey = keyring;\r\nif (no_state_check)\r\ngoto found;\r\nif (kflags & (1 << KEY_FLAG_REVOKED))\r\ngoto error_2;\r\nif (key->expiry && now.tv_sec >= key->expiry)\r\ngoto error_2;\r\nkey_ref = ERR_PTR(key->type_data.reject_error);\r\nif (kflags & (1 << KEY_FLAG_NEGATIVE))\r\ngoto error_2;\r\ngoto found;\r\n}\r\nkey_ref = ERR_PTR(-EAGAIN);\r\nif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED) |\r\n(1 << KEY_FLAG_NEGATIVE)) ||\r\n(keyring->expiry && now.tv_sec >= keyring->expiry))\r\ngoto error_2;\r\ndescend:\r\nkflags = keyring->flags;\r\nif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED)))\r\ngoto not_this_keyring;\r\nkeylist = rcu_dereference(keyring->payload.subscriptions);\r\nif (!keylist)\r\ngoto not_this_keyring;\r\nnkeys = keylist->nkeys;\r\nsmp_rmb();\r\nfor (kix = 0; kix < nkeys; kix++) {\r\nkey = rcu_dereference(keylist->keys[kix]);\r\nkflags = key->flags;\r\nif (key->type != type)\r\ncontinue;\r\nif (!no_state_check) {\r\nif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED)))\r\ncontinue;\r\nif (key->expiry && now.tv_sec >= key->expiry)\r\ncontinue;\r\n}\r\nif (!match(key, description))\r\ncontinue;\r\nif (key_task_permission(make_key_ref(key, possessed),\r\ncred, KEY_SEARCH) < 0)\r\ncontinue;\r\nif (no_state_check)\r\ngoto found;\r\nif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\r\nerr = key->type_data.reject_error;\r\ncontinue;\r\n}\r\ngoto found;\r\n}\r\nkix = 0;\r\nascend:\r\nnkeys = keylist->nkeys;\r\nsmp_rmb();\r\nfor (; kix < nkeys; kix++) {\r\nkey = rcu_dereference(keylist->keys[kix]);\r\nif (key->type != &key_type_keyring)\r\ncontinue;\r\nif (sp >= KEYRING_SEARCH_MAX_DEPTH)\r\ncontinue;\r\nif (key_task_permission(make_key_ref(key, possessed),\r\ncred, KEY_SEARCH) < 0)\r\ncontinue;\r\nstack[sp].keyring = keyring;\r\nstack[sp].keylist = keylist;\r\nstack[sp].kix = kix;\r\nsp++;\r\nkeyring = key;\r\ngoto descend;\r\n}\r\nnot_this_keyring:\r\nif (sp > 0) {\r\nsp--;\r\nkeyring = stack[sp].keyring;\r\nkeylist = stack[sp].keylist;\r\nkix = stack[sp].kix + 1;\r\ngoto ascend;\r\n}\r\nkey_ref = ERR_PTR(err);\r\ngoto error_2;\r\nfound:\r\natomic_inc(&key->usage);\r\nkey->last_used_at = now.tv_sec;\r\nkeyring->last_used_at = now.tv_sec;\r\nwhile (sp > 0)\r\nstack[--sp].keyring->last_used_at = now.tv_sec;\r\nkey_check(key);\r\nkey_ref = make_key_ref(key, possessed);\r\nerror_2:\r\nrcu_read_unlock();\r\nerror:\r\nreturn key_ref;\r\n}\r\nkey_ref_t keyring_search(key_ref_t keyring,\r\nstruct key_type *type,\r\nconst char *description)\r\n{\r\nif (!type->match)\r\nreturn ERR_PTR(-ENOKEY);\r\nreturn keyring_search_aux(keyring, current->cred,\r\ntype, description, type->match, false);\r\n}\r\nkey_ref_t __keyring_search_one(key_ref_t keyring_ref,\r\nconst struct key_type *ktype,\r\nconst char *description,\r\nkey_perm_t perm)\r\n{\r\nstruct keyring_list *klist;\r\nunsigned long possessed;\r\nstruct key *keyring, *key;\r\nint nkeys, loop;\r\nkeyring = key_ref_to_ptr(keyring_ref);\r\npossessed = is_key_possessed(keyring_ref);\r\nrcu_read_lock();\r\nklist = rcu_dereference(keyring->payload.subscriptions);\r\nif (klist) {\r\nnkeys = klist->nkeys;\r\nsmp_rmb();\r\nfor (loop = 0; loop < nkeys ; loop++) {\r\nkey = rcu_dereference(klist->keys[loop]);\r\nif (key->type == ktype &&\r\n(!key->type->match ||\r\nkey->type->match(key, description)) &&\r\nkey_permission(make_key_ref(key, possessed),\r\nperm) == 0 &&\r\n!(key->flags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED)))\r\n)\r\ngoto found;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn ERR_PTR(-ENOKEY);\r\nfound:\r\natomic_inc(&key->usage);\r\nkeyring->last_used_at = key->last_used_at =\r\ncurrent_kernel_time().tv_sec;\r\nrcu_read_unlock();\r\nreturn make_key_ref(key, possessed);\r\n}\r\nstruct key *find_keyring_by_name(const char *name, bool skip_perm_check)\r\n{\r\nstruct key *keyring;\r\nint bucket;\r\nif (!name)\r\nreturn ERR_PTR(-EINVAL);\r\nbucket = keyring_hash(name);\r\nread_lock(&keyring_name_lock);\r\nif (keyring_name_hash[bucket].next) {\r\nlist_for_each_entry(keyring,\r\n&keyring_name_hash[bucket],\r\ntype_data.link\r\n) {\r\nif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\r\ncontinue;\r\nif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\r\ncontinue;\r\nif (strcmp(keyring->description, name) != 0)\r\ncontinue;\r\nif (!skip_perm_check &&\r\nkey_permission(make_key_ref(keyring, 0),\r\nKEY_SEARCH) < 0)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&keyring->usage))\r\ncontinue;\r\nkeyring->last_used_at = current_kernel_time().tv_sec;\r\ngoto out;\r\n}\r\n}\r\nkeyring = ERR_PTR(-ENOKEY);\r\nout:\r\nread_unlock(&keyring_name_lock);\r\nreturn keyring;\r\n}\r\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\r\n{\r\nstruct {\r\nstruct keyring_list *keylist;\r\nint kix;\r\n} stack[KEYRING_SEARCH_MAX_DEPTH];\r\nstruct keyring_list *keylist;\r\nstruct key *subtree, *key;\r\nint sp, nkeys, kix, ret;\r\nrcu_read_lock();\r\nret = -EDEADLK;\r\nif (A == B)\r\ngoto cycle_detected;\r\nsubtree = B;\r\nsp = 0;\r\ndescend:\r\nif (test_bit(KEY_FLAG_REVOKED, &subtree->flags))\r\ngoto not_this_keyring;\r\nkeylist = rcu_dereference(subtree->payload.subscriptions);\r\nif (!keylist)\r\ngoto not_this_keyring;\r\nkix = 0;\r\nascend:\r\nnkeys = keylist->nkeys;\r\nsmp_rmb();\r\nfor (; kix < nkeys; kix++) {\r\nkey = rcu_dereference(keylist->keys[kix]);\r\nif (key == A)\r\ngoto cycle_detected;\r\nif (key->type == &key_type_keyring) {\r\nif (sp >= KEYRING_SEARCH_MAX_DEPTH)\r\ngoto too_deep;\r\nstack[sp].keylist = keylist;\r\nstack[sp].kix = kix;\r\nsp++;\r\nsubtree = key;\r\ngoto descend;\r\n}\r\n}\r\nnot_this_keyring:\r\nif (sp > 0) {\r\nsp--;\r\nkeylist = stack[sp].keylist;\r\nkix = stack[sp].kix + 1;\r\ngoto ascend;\r\n}\r\nret = 0;\r\nerror:\r\nrcu_read_unlock();\r\nreturn ret;\r\ntoo_deep:\r\nret = -ELOOP;\r\ngoto error;\r\ncycle_detected:\r\nret = -EDEADLK;\r\ngoto error;\r\n}\r\nstatic void keyring_unlink_rcu_disposal(struct rcu_head *rcu)\r\n{\r\nstruct keyring_list *klist =\r\ncontainer_of(rcu, struct keyring_list, rcu);\r\nif (klist->delkey != USHRT_MAX)\r\nkey_put(rcu_access_pointer(klist->keys[klist->delkey]));\r\nkfree(klist);\r\n}\r\nint __key_link_begin(struct key *keyring, const struct key_type *type,\r\nconst char *description, unsigned long *_prealloc)\r\n__acquires(&keyring->sem\r\nint __key_link_check_live_key(struct key *keyring, struct key *key)\r\n{\r\nif (key->type == &key_type_keyring)\r\nreturn keyring_detect_cycle(keyring, key);\r\nreturn 0;\r\n}\r\nvoid __key_link(struct key *keyring, struct key *key,\r\nunsigned long *_prealloc)\r\n{\r\nstruct keyring_list *klist, *nklist;\r\nstruct key *discard;\r\nnklist = (struct keyring_list *)(*_prealloc & ~KEY_LINK_FIXQUOTA);\r\n*_prealloc = 0;\r\nkenter("%d,%d,%p", keyring->serial, key->serial, nklist);\r\nklist = rcu_dereference_locked_keyring(keyring);\r\natomic_inc(&key->usage);\r\nkeyring->last_used_at = key->last_used_at =\r\ncurrent_kernel_time().tv_sec;\r\nif (nklist) {\r\nkdebug("reissue %hu/%hu/%hu",\r\nnklist->delkey, nklist->nkeys, nklist->maxkeys);\r\nRCU_INIT_POINTER(nklist->keys[nklist->delkey], key);\r\nrcu_assign_pointer(keyring->payload.subscriptions, nklist);\r\nif (klist) {\r\nkdebug("dispose %hu/%hu/%hu",\r\nklist->delkey, klist->nkeys, klist->maxkeys);\r\ncall_rcu(&klist->rcu, keyring_unlink_rcu_disposal);\r\n}\r\n} else if (klist->delkey < klist->nkeys) {\r\nkdebug("replace %hu/%hu/%hu",\r\nklist->delkey, klist->nkeys, klist->maxkeys);\r\ndiscard = rcu_dereference_protected(\r\nklist->keys[klist->delkey],\r\nrwsem_is_locked(&keyring->sem));\r\nrcu_assign_pointer(klist->keys[klist->delkey], key);\r\nkey_put(discard);\r\n} else {\r\nkdebug("append %hu/%hu/%hu",\r\nklist->delkey, klist->nkeys, klist->maxkeys);\r\nRCU_INIT_POINTER(klist->keys[klist->delkey], key);\r\nsmp_wmb();\r\nklist->nkeys++;\r\n}\r\n}\r\nvoid __key_link_end(struct key *keyring, struct key_type *type,\r\nunsigned long prealloc)\r\n__releases(&keyring->sem\r\nint key_link(struct key *keyring, struct key *key)\r\n{\r\nunsigned long prealloc;\r\nint ret;\r\nkey_check(keyring);\r\nkey_check(key);\r\nret = __key_link_begin(keyring, key->type, key->description, &prealloc);\r\nif (ret == 0) {\r\nret = __key_link_check_live_key(keyring, key);\r\nif (ret == 0)\r\n__key_link(keyring, key, &prealloc);\r\n__key_link_end(keyring, key->type, prealloc);\r\n}\r\nreturn ret;\r\n}\r\nint key_unlink(struct key *keyring, struct key *key)\r\n{\r\nstruct keyring_list *klist, *nklist;\r\nint loop, ret;\r\nkey_check(keyring);\r\nkey_check(key);\r\nret = -ENOTDIR;\r\nif (keyring->type != &key_type_keyring)\r\ngoto error;\r\ndown_write(&keyring->sem);\r\nklist = rcu_dereference_locked_keyring(keyring);\r\nif (klist) {\r\nfor (loop = 0; loop < klist->nkeys; loop++)\r\nif (rcu_access_pointer(klist->keys[loop]) == key)\r\ngoto key_is_present;\r\n}\r\nup_write(&keyring->sem);\r\nret = -ENOENT;\r\ngoto error;\r\nkey_is_present:\r\nnklist = kmalloc(sizeof(*klist) +\r\nsizeof(struct key *) * klist->maxkeys,\r\nGFP_KERNEL);\r\nif (!nklist)\r\ngoto nomem;\r\nnklist->maxkeys = klist->maxkeys;\r\nnklist->nkeys = klist->nkeys - 1;\r\nif (loop > 0)\r\nmemcpy(&nklist->keys[0],\r\n&klist->keys[0],\r\nloop * sizeof(struct key *));\r\nif (loop < nklist->nkeys)\r\nmemcpy(&nklist->keys[loop],\r\n&klist->keys[loop + 1],\r\n(nklist->nkeys - loop) * sizeof(struct key *));\r\nkey_payload_reserve(keyring,\r\nkeyring->datalen - KEYQUOTA_LINK_BYTES);\r\nrcu_assign_pointer(keyring->payload.subscriptions, nklist);\r\nup_write(&keyring->sem);\r\nklist->delkey = loop;\r\ncall_rcu(&klist->rcu, keyring_unlink_rcu_disposal);\r\nret = 0;\r\nerror:\r\nreturn ret;\r\nnomem:\r\nret = -ENOMEM;\r\nup_write(&keyring->sem);\r\ngoto error;\r\n}\r\nstatic void keyring_clear_rcu_disposal(struct rcu_head *rcu)\r\n{\r\nstruct keyring_list *klist;\r\nint loop;\r\nklist = container_of(rcu, struct keyring_list, rcu);\r\nfor (loop = klist->nkeys - 1; loop >= 0; loop--)\r\nkey_put(rcu_access_pointer(klist->keys[loop]));\r\nkfree(klist);\r\n}\r\nint keyring_clear(struct key *keyring)\r\n{\r\nstruct keyring_list *klist;\r\nint ret;\r\nret = -ENOTDIR;\r\nif (keyring->type == &key_type_keyring) {\r\ndown_write(&keyring->sem);\r\nklist = rcu_dereference_locked_keyring(keyring);\r\nif (klist) {\r\nkey_payload_reserve(keyring,\r\nsizeof(struct keyring_list));\r\nrcu_assign_pointer(keyring->payload.subscriptions,\r\nNULL);\r\n}\r\nup_write(&keyring->sem);\r\nif (klist)\r\ncall_rcu(&klist->rcu, keyring_clear_rcu_disposal);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void keyring_revoke(struct key *keyring)\r\n{\r\nstruct keyring_list *klist;\r\nklist = rcu_dereference_locked_keyring(keyring);\r\nkey_payload_reserve(keyring, 0);\r\nif (klist) {\r\nrcu_assign_pointer(keyring->payload.subscriptions, NULL);\r\ncall_rcu(&klist->rcu, keyring_clear_rcu_disposal);\r\n}\r\n}\r\nvoid keyring_gc(struct key *keyring, time_t limit)\r\n{\r\nstruct keyring_list *klist, *new;\r\nstruct key *key;\r\nint loop, keep, max;\r\nkenter("{%x,%s}", key_serial(keyring), keyring->description);\r\ndown_write(&keyring->sem);\r\nklist = rcu_dereference_locked_keyring(keyring);\r\nif (!klist)\r\ngoto no_klist;\r\nkeep = 0;\r\nfor (loop = klist->nkeys - 1; loop >= 0; loop--)\r\nif (!key_is_dead(rcu_deref_link_locked(klist, loop, keyring),\r\nlimit))\r\nkeep++;\r\nif (keep == klist->nkeys)\r\ngoto just_return;\r\nmax = roundup(keep, 4);\r\nnew = kmalloc(sizeof(struct keyring_list) + max * sizeof(struct key *),\r\nGFP_KERNEL);\r\nif (!new)\r\ngoto nomem;\r\nnew->maxkeys = max;\r\nnew->nkeys = 0;\r\nnew->delkey = 0;\r\nkeep = 0;\r\nfor (loop = klist->nkeys - 1; loop >= 0; loop--) {\r\nkey = rcu_deref_link_locked(klist, loop, keyring);\r\nif (!key_is_dead(key, limit)) {\r\nif (keep >= max)\r\ngoto discard_new;\r\nRCU_INIT_POINTER(new->keys[keep++], key_get(key));\r\n}\r\n}\r\nnew->nkeys = keep;\r\nkey_payload_reserve(keyring,\r\nsizeof(struct keyring_list) +\r\nKEYQUOTA_LINK_BYTES * keep);\r\nif (keep == 0) {\r\nrcu_assign_pointer(keyring->payload.subscriptions, NULL);\r\nkfree(new);\r\n} else {\r\nrcu_assign_pointer(keyring->payload.subscriptions, new);\r\n}\r\nup_write(&keyring->sem);\r\ncall_rcu(&klist->rcu, keyring_clear_rcu_disposal);\r\nkleave(" [yes]");\r\nreturn;\r\ndiscard_new:\r\nnew->nkeys = keep;\r\nkeyring_clear_rcu_disposal(&new->rcu);\r\nup_write(&keyring->sem);\r\nkleave(" [discard]");\r\nreturn;\r\njust_return:\r\nup_write(&keyring->sem);\r\nkleave(" [no dead]");\r\nreturn;\r\nno_klist:\r\nup_write(&keyring->sem);\r\nkleave(" [no_klist]");\r\nreturn;\r\nnomem:\r\nup_write(&keyring->sem);\r\nkleave(" [oom]");\r\n}
