static inline struct cpuacct *cgroup_ca(struct cgroup *cgrp)\r\n{\r\nreturn container_of(cgroup_subsys_state(cgrp, cpuacct_subsys_id),\r\nstruct cpuacct, css);\r\n}\r\nstatic inline struct cpuacct *task_ca(struct task_struct *tsk)\r\n{\r\nreturn container_of(task_subsys_state(tsk, cpuacct_subsys_id),\r\nstruct cpuacct, css);\r\n}\r\nstatic inline struct cpuacct *__parent_ca(struct cpuacct *ca)\r\n{\r\nreturn cgroup_ca(ca->css.cgroup->parent);\r\n}\r\nstatic inline struct cpuacct *parent_ca(struct cpuacct *ca)\r\n{\r\nif (!ca->css.cgroup->parent)\r\nreturn NULL;\r\nreturn cgroup_ca(ca->css.cgroup->parent);\r\n}\r\nstatic struct cgroup_subsys_state *cpuacct_css_alloc(struct cgroup *cgrp)\r\n{\r\nstruct cpuacct *ca;\r\nif (!cgrp->parent)\r\nreturn &root_cpuacct.css;\r\nca = kzalloc(sizeof(*ca), GFP_KERNEL);\r\nif (!ca)\r\ngoto out;\r\nca->cpuusage = alloc_percpu(u64);\r\nif (!ca->cpuusage)\r\ngoto out_free_ca;\r\nca->cpustat = alloc_percpu(struct kernel_cpustat);\r\nif (!ca->cpustat)\r\ngoto out_free_cpuusage;\r\nreturn &ca->css;\r\nout_free_cpuusage:\r\nfree_percpu(ca->cpuusage);\r\nout_free_ca:\r\nkfree(ca);\r\nout:\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void cpuacct_css_free(struct cgroup *cgrp)\r\n{\r\nstruct cpuacct *ca = cgroup_ca(cgrp);\r\nfree_percpu(ca->cpustat);\r\nfree_percpu(ca->cpuusage);\r\nkfree(ca);\r\n}\r\nstatic u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu)\r\n{\r\nu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\r\nu64 data;\r\n#ifndef CONFIG_64BIT\r\nraw_spin_lock_irq(&cpu_rq(cpu)->lock);\r\ndata = *cpuusage;\r\nraw_spin_unlock_irq(&cpu_rq(cpu)->lock);\r\n#else\r\ndata = *cpuusage;\r\n#endif\r\nreturn data;\r\n}\r\nstatic void cpuacct_cpuusage_write(struct cpuacct *ca, int cpu, u64 val)\r\n{\r\nu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\r\n#ifndef CONFIG_64BIT\r\nraw_spin_lock_irq(&cpu_rq(cpu)->lock);\r\n*cpuusage = val;\r\nraw_spin_unlock_irq(&cpu_rq(cpu)->lock);\r\n#else\r\n*cpuusage = val;\r\n#endif\r\n}\r\nstatic u64 cpuusage_read(struct cgroup *cgrp, struct cftype *cft)\r\n{\r\nstruct cpuacct *ca = cgroup_ca(cgrp);\r\nu64 totalcpuusage = 0;\r\nint i;\r\nfor_each_present_cpu(i)\r\ntotalcpuusage += cpuacct_cpuusage_read(ca, i);\r\nreturn totalcpuusage;\r\n}\r\nstatic int cpuusage_write(struct cgroup *cgrp, struct cftype *cftype,\r\nu64 reset)\r\n{\r\nstruct cpuacct *ca = cgroup_ca(cgrp);\r\nint err = 0;\r\nint i;\r\nif (reset) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nfor_each_present_cpu(i)\r\ncpuacct_cpuusage_write(ca, i, 0);\r\nout:\r\nreturn err;\r\n}\r\nstatic int cpuacct_percpu_seq_read(struct cgroup *cgroup, struct cftype *cft,\r\nstruct seq_file *m)\r\n{\r\nstruct cpuacct *ca = cgroup_ca(cgroup);\r\nu64 percpu;\r\nint i;\r\nfor_each_present_cpu(i) {\r\npercpu = cpuacct_cpuusage_read(ca, i);\r\nseq_printf(m, "%llu ", (unsigned long long) percpu);\r\n}\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int cpuacct_stats_show(struct cgroup *cgrp, struct cftype *cft,\r\nstruct cgroup_map_cb *cb)\r\n{\r\nstruct cpuacct *ca = cgroup_ca(cgrp);\r\nint cpu;\r\ns64 val = 0;\r\nfor_each_online_cpu(cpu) {\r\nstruct kernel_cpustat *kcpustat = per_cpu_ptr(ca->cpustat, cpu);\r\nval += kcpustat->cpustat[CPUTIME_USER];\r\nval += kcpustat->cpustat[CPUTIME_NICE];\r\n}\r\nval = cputime64_to_clock_t(val);\r\ncb->fill(cb, cpuacct_stat_desc[CPUACCT_STAT_USER], val);\r\nval = 0;\r\nfor_each_online_cpu(cpu) {\r\nstruct kernel_cpustat *kcpustat = per_cpu_ptr(ca->cpustat, cpu);\r\nval += kcpustat->cpustat[CPUTIME_SYSTEM];\r\nval += kcpustat->cpustat[CPUTIME_IRQ];\r\nval += kcpustat->cpustat[CPUTIME_SOFTIRQ];\r\n}\r\nval = cputime64_to_clock_t(val);\r\ncb->fill(cb, cpuacct_stat_desc[CPUACCT_STAT_SYSTEM], val);\r\nreturn 0;\r\n}\r\nvoid cpuacct_charge(struct task_struct *tsk, u64 cputime)\r\n{\r\nstruct cpuacct *ca;\r\nint cpu;\r\ncpu = task_cpu(tsk);\r\nrcu_read_lock();\r\nca = task_ca(tsk);\r\nwhile (true) {\r\nu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\r\n*cpuusage += cputime;\r\nca = parent_ca(ca);\r\nif (!ca)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid cpuacct_account_field(struct task_struct *p, int index, u64 val)\r\n{\r\nstruct kernel_cpustat *kcpustat;\r\nstruct cpuacct *ca;\r\nrcu_read_lock();\r\nca = task_ca(p);\r\nwhile (ca != &root_cpuacct) {\r\nkcpustat = this_cpu_ptr(ca->cpustat);\r\nkcpustat->cpustat[index] += val;\r\nca = __parent_ca(ca);\r\n}\r\nrcu_read_unlock();\r\n}
