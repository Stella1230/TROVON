static inline void\r\nip_set_type_lock(void)\r\n{\r\nmutex_lock(&ip_set_type_mutex);\r\n}\r\nstatic inline void\r\nip_set_type_unlock(void)\r\n{\r\nmutex_unlock(&ip_set_type_mutex);\r\n}\r\nstatic struct ip_set_type *\r\nfind_set_type(const char *name, u8 family, u8 revision)\r\n{\r\nstruct ip_set_type *type;\r\nlist_for_each_entry_rcu(type, &ip_set_type_list, list)\r\nif (STREQ(type->name, name) &&\r\n(type->family == family ||\r\ntype->family == NFPROTO_UNSPEC) &&\r\nrevision >= type->revision_min &&\r\nrevision <= type->revision_max)\r\nreturn type;\r\nreturn NULL;\r\n}\r\nstatic bool\r\nload_settype(const char *name)\r\n{\r\nnfnl_unlock(NFNL_SUBSYS_IPSET);\r\npr_debug("try to load ip_set_%s\n", name);\r\nif (request_module("ip_set_%s", name) < 0) {\r\npr_warning("Can't find ip_set type %s\n", name);\r\nnfnl_lock(NFNL_SUBSYS_IPSET);\r\nreturn false;\r\n}\r\nnfnl_lock(NFNL_SUBSYS_IPSET);\r\nreturn true;\r\n}\r\nstatic int\r\n__find_set_type_get(const char *name, u8 family, u8 revision,\r\nstruct ip_set_type **found, bool retry)\r\n{\r\nstruct ip_set_type *type;\r\nint err;\r\nif (retry && !load_settype(name))\r\nreturn -IPSET_ERR_FIND_TYPE;\r\nrcu_read_lock();\r\n*found = find_set_type(name, family, revision);\r\nif (*found) {\r\nerr = !try_module_get((*found)->me) ? -EFAULT : 0;\r\ngoto unlock;\r\n}\r\nlist_for_each_entry_rcu(type, &ip_set_type_list, list)\r\nif (STREQ(type->name, name)) {\r\nerr = -IPSET_ERR_FIND_TYPE;\r\ngoto unlock;\r\n}\r\nrcu_read_unlock();\r\nreturn retry ? -IPSET_ERR_FIND_TYPE :\r\n__find_set_type_get(name, family, revision, found, true);\r\nunlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int\r\n__find_set_type_minmax(const char *name, u8 family, u8 *min, u8 *max,\r\nbool retry)\r\n{\r\nstruct ip_set_type *type;\r\nbool found = false;\r\nif (retry && !load_settype(name))\r\nreturn -IPSET_ERR_FIND_TYPE;\r\n*min = 255; *max = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(type, &ip_set_type_list, list)\r\nif (STREQ(type->name, name) &&\r\n(type->family == family ||\r\ntype->family == NFPROTO_UNSPEC)) {\r\nfound = true;\r\nif (type->revision_min < *min)\r\n*min = type->revision_min;\r\nif (type->revision_max > *max)\r\n*max = type->revision_max;\r\n}\r\nrcu_read_unlock();\r\nif (found)\r\nreturn 0;\r\nreturn retry ? -IPSET_ERR_FIND_TYPE :\r\n__find_set_type_minmax(name, family, min, max, true);\r\n}\r\nint\r\nip_set_type_register(struct ip_set_type *type)\r\n{\r\nint ret = 0;\r\nif (type->protocol != IPSET_PROTOCOL) {\r\npr_warning("ip_set type %s, family %s, revision %u:%u uses "\r\n"wrong protocol version %u (want %u)\n",\r\ntype->name, family_name(type->family),\r\ntype->revision_min, type->revision_max,\r\ntype->protocol, IPSET_PROTOCOL);\r\nreturn -EINVAL;\r\n}\r\nip_set_type_lock();\r\nif (find_set_type(type->name, type->family, type->revision_min)) {\r\npr_warning("ip_set type %s, family %s with revision min %u "\r\n"already registered!\n", type->name,\r\nfamily_name(type->family), type->revision_min);\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nlist_add_rcu(&type->list, &ip_set_type_list);\r\npr_debug("type %s, family %s, revision %u:%u registered.\n",\r\ntype->name, family_name(type->family),\r\ntype->revision_min, type->revision_max);\r\nunlock:\r\nip_set_type_unlock();\r\nreturn ret;\r\n}\r\nvoid\r\nip_set_type_unregister(struct ip_set_type *type)\r\n{\r\nip_set_type_lock();\r\nif (!find_set_type(type->name, type->family, type->revision_min)) {\r\npr_warning("ip_set type %s, family %s with revision min %u "\r\n"not registered\n", type->name,\r\nfamily_name(type->family), type->revision_min);\r\ngoto unlock;\r\n}\r\nlist_del_rcu(&type->list);\r\npr_debug("type %s, family %s with revision min %u unregistered.\n",\r\ntype->name, family_name(type->family), type->revision_min);\r\nunlock:\r\nip_set_type_unlock();\r\nsynchronize_rcu();\r\n}\r\nvoid *\r\nip_set_alloc(size_t size)\r\n{\r\nvoid *members = NULL;\r\nif (size < KMALLOC_MAX_SIZE)\r\nmembers = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\r\nif (members) {\r\npr_debug("%p: allocated with kmalloc\n", members);\r\nreturn members;\r\n}\r\nmembers = vzalloc(size);\r\nif (!members)\r\nreturn NULL;\r\npr_debug("%p: allocated with vmalloc\n", members);\r\nreturn members;\r\n}\r\nvoid\r\nip_set_free(void *members)\r\n{\r\npr_debug("%p: free with %s\n", members,\r\nis_vmalloc_addr(members) ? "vfree" : "kfree");\r\nif (is_vmalloc_addr(members))\r\nvfree(members);\r\nelse\r\nkfree(members);\r\n}\r\nstatic inline bool\r\nflag_nested(const struct nlattr *nla)\r\n{\r\nreturn nla->nla_type & NLA_F_NESTED;\r\n}\r\nint\r\nip_set_get_ipaddr4(struct nlattr *nla, __be32 *ipaddr)\r\n{\r\nstruct nlattr *tb[IPSET_ATTR_IPADDR_MAX+1];\r\nif (unlikely(!flag_nested(nla)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (nla_parse_nested(tb, IPSET_ATTR_IPADDR_MAX, nla, ipaddr_policy))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_IPADDR_IPV4)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\n*ipaddr = nla_get_be32(tb[IPSET_ATTR_IPADDR_IPV4]);\r\nreturn 0;\r\n}\r\nint\r\nip_set_get_ipaddr6(struct nlattr *nla, union nf_inet_addr *ipaddr)\r\n{\r\nstruct nlattr *tb[IPSET_ATTR_IPADDR_MAX+1];\r\nif (unlikely(!flag_nested(nla)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (nla_parse_nested(tb, IPSET_ATTR_IPADDR_MAX, nla, ipaddr_policy))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_IPADDR_IPV6)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nmemcpy(ipaddr, nla_data(tb[IPSET_ATTR_IPADDR_IPV6]),\r\nsizeof(struct in6_addr));\r\nreturn 0;\r\n}\r\nint\r\nip_set_get_extensions(struct ip_set *set, struct nlattr *tb[],\r\nstruct ip_set_ext *ext)\r\n{\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!(set->extensions & IPSET_EXT_TIMEOUT))\r\nreturn -IPSET_ERR_TIMEOUT;\r\next->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\nif (tb[IPSET_ATTR_BYTES] || tb[IPSET_ATTR_PACKETS]) {\r\nif (!(set->extensions & IPSET_EXT_COUNTER))\r\nreturn -IPSET_ERR_COUNTER;\r\nif (tb[IPSET_ATTR_BYTES])\r\next->bytes = be64_to_cpu(nla_get_be64(\r\ntb[IPSET_ATTR_BYTES]));\r\nif (tb[IPSET_ATTR_PACKETS])\r\next->packets = be64_to_cpu(nla_get_be64(\r\ntb[IPSET_ATTR_PACKETS]));\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\n__ip_set_get(struct ip_set *set)\r\n{\r\nwrite_lock_bh(&ip_set_ref_lock);\r\nset->ref++;\r\nwrite_unlock_bh(&ip_set_ref_lock);\r\n}\r\nstatic inline void\r\n__ip_set_put(struct ip_set *set)\r\n{\r\nwrite_lock_bh(&ip_set_ref_lock);\r\nBUG_ON(set->ref == 0);\r\nset->ref--;\r\nwrite_unlock_bh(&ip_set_ref_lock);\r\n}\r\nstatic inline struct ip_set *\r\nip_set_rcu_get(ip_set_id_t index)\r\n{\r\nstruct ip_set *set;\r\nrcu_read_lock();\r\nset = rcu_dereference(ip_set_list)[index];\r\nrcu_read_unlock();\r\nreturn set;\r\n}\r\nint\r\nip_set_test(ip_set_id_t index, const struct sk_buff *skb,\r\nconst struct xt_action_param *par, struct ip_set_adt_opt *opt)\r\n{\r\nstruct ip_set *set = ip_set_rcu_get(index);\r\nint ret = 0;\r\nBUG_ON(set == NULL);\r\npr_debug("set %s, index %u\n", set->name, index);\r\nif (opt->dim < set->type->dimension ||\r\n!(opt->family == set->family || set->family == NFPROTO_UNSPEC))\r\nreturn 0;\r\nread_lock_bh(&set->lock);\r\nret = set->variant->kadt(set, skb, par, IPSET_TEST, opt);\r\nread_unlock_bh(&set->lock);\r\nif (ret == -EAGAIN) {\r\npr_debug("element must be competed, ADD is triggered\n");\r\nwrite_lock_bh(&set->lock);\r\nset->variant->kadt(set, skb, par, IPSET_ADD, opt);\r\nwrite_unlock_bh(&set->lock);\r\nret = 1;\r\n} else {\r\nif ((opt->cmdflags & IPSET_FLAG_RETURN_NOMATCH) &&\r\n(set->type->features & IPSET_TYPE_NOMATCH) &&\r\n(ret > 0 || ret == -ENOTEMPTY))\r\nret = -ret;\r\n}\r\nreturn (ret < 0 ? 0 : ret);\r\n}\r\nint\r\nip_set_add(ip_set_id_t index, const struct sk_buff *skb,\r\nconst struct xt_action_param *par, struct ip_set_adt_opt *opt)\r\n{\r\nstruct ip_set *set = ip_set_rcu_get(index);\r\nint ret;\r\nBUG_ON(set == NULL);\r\npr_debug("set %s, index %u\n", set->name, index);\r\nif (opt->dim < set->type->dimension ||\r\n!(opt->family == set->family || set->family == NFPROTO_UNSPEC))\r\nreturn 0;\r\nwrite_lock_bh(&set->lock);\r\nret = set->variant->kadt(set, skb, par, IPSET_ADD, opt);\r\nwrite_unlock_bh(&set->lock);\r\nreturn ret;\r\n}\r\nint\r\nip_set_del(ip_set_id_t index, const struct sk_buff *skb,\r\nconst struct xt_action_param *par, struct ip_set_adt_opt *opt)\r\n{\r\nstruct ip_set *set = ip_set_rcu_get(index);\r\nint ret = 0;\r\nBUG_ON(set == NULL);\r\npr_debug("set %s, index %u\n", set->name, index);\r\nif (opt->dim < set->type->dimension ||\r\n!(opt->family == set->family || set->family == NFPROTO_UNSPEC))\r\nreturn 0;\r\nwrite_lock_bh(&set->lock);\r\nret = set->variant->kadt(set, skb, par, IPSET_DEL, opt);\r\nwrite_unlock_bh(&set->lock);\r\nreturn ret;\r\n}\r\nip_set_id_t\r\nip_set_get_byname(const char *name, struct ip_set **set)\r\n{\r\nip_set_id_t i, index = IPSET_INVALID_ID;\r\nstruct ip_set *s;\r\nrcu_read_lock();\r\nfor (i = 0; i < ip_set_max; i++) {\r\ns = rcu_dereference(ip_set_list)[i];\r\nif (s != NULL && STREQ(s->name, name)) {\r\n__ip_set_get(s);\r\nindex = i;\r\n*set = s;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn index;\r\n}\r\nvoid\r\nip_set_put_byindex(ip_set_id_t index)\r\n{\r\nstruct ip_set *set;\r\nrcu_read_lock();\r\nset = rcu_dereference(ip_set_list)[index];\r\nif (set != NULL)\r\n__ip_set_put(set);\r\nrcu_read_unlock();\r\n}\r\nconst char *\r\nip_set_name_byindex(ip_set_id_t index)\r\n{\r\nconst struct ip_set *set = ip_set_rcu_get(index);\r\nBUG_ON(set == NULL);\r\nBUG_ON(set->ref == 0);\r\nreturn set->name;\r\n}\r\nip_set_id_t\r\nip_set_nfnl_get(const char *name)\r\n{\r\nip_set_id_t i, index = IPSET_INVALID_ID;\r\nstruct ip_set *s;\r\nnfnl_lock(NFNL_SUBSYS_IPSET);\r\nfor (i = 0; i < ip_set_max; i++) {\r\ns = nfnl_set(i);\r\nif (s != NULL && STREQ(s->name, name)) {\r\n__ip_set_get(s);\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nnfnl_unlock(NFNL_SUBSYS_IPSET);\r\nreturn index;\r\n}\r\nip_set_id_t\r\nip_set_nfnl_get_byindex(ip_set_id_t index)\r\n{\r\nstruct ip_set *set;\r\nif (index > ip_set_max)\r\nreturn IPSET_INVALID_ID;\r\nnfnl_lock(NFNL_SUBSYS_IPSET);\r\nset = nfnl_set(index);\r\nif (set)\r\n__ip_set_get(set);\r\nelse\r\nindex = IPSET_INVALID_ID;\r\nnfnl_unlock(NFNL_SUBSYS_IPSET);\r\nreturn index;\r\n}\r\nvoid\r\nip_set_nfnl_put(ip_set_id_t index)\r\n{\r\nstruct ip_set *set;\r\nnfnl_lock(NFNL_SUBSYS_IPSET);\r\nset = nfnl_set(index);\r\nif (set != NULL)\r\n__ip_set_put(set);\r\nnfnl_unlock(NFNL_SUBSYS_IPSET);\r\n}\r\nstatic inline bool\r\nprotocol_failed(const struct nlattr * const tb[])\r\n{\r\nreturn !tb[IPSET_ATTR_PROTOCOL] ||\r\nnla_get_u8(tb[IPSET_ATTR_PROTOCOL]) != IPSET_PROTOCOL;\r\n}\r\nstatic inline u32\r\nflag_exist(const struct nlmsghdr *nlh)\r\n{\r\nreturn nlh->nlmsg_flags & NLM_F_EXCL ? 0 : IPSET_FLAG_EXIST;\r\n}\r\nstatic struct nlmsghdr *\r\nstart_msg(struct sk_buff *skb, u32 portid, u32 seq, unsigned int flags,\r\nenum ipset_cmd cmd)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nnlh = nlmsg_put(skb, portid, seq, cmd | (NFNL_SUBSYS_IPSET << 8),\r\nsizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\nreturn NULL;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = NFPROTO_IPV4;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nreturn nlh;\r\n}\r\nstatic struct ip_set *\r\nfind_set_and_id(const char *name, ip_set_id_t *id)\r\n{\r\nstruct ip_set *set = NULL;\r\nip_set_id_t i;\r\n*id = IPSET_INVALID_ID;\r\nfor (i = 0; i < ip_set_max; i++) {\r\nset = nfnl_set(i);\r\nif (set != NULL && STREQ(set->name, name)) {\r\n*id = i;\r\nbreak;\r\n}\r\n}\r\nreturn (*id == IPSET_INVALID_ID ? NULL : set);\r\n}\r\nstatic inline struct ip_set *\r\nfind_set(const char *name)\r\n{\r\nip_set_id_t id;\r\nreturn find_set_and_id(name, &id);\r\n}\r\nstatic int\r\nfind_free_id(const char *name, ip_set_id_t *index, struct ip_set **set)\r\n{\r\nstruct ip_set *s;\r\nip_set_id_t i;\r\n*index = IPSET_INVALID_ID;\r\nfor (i = 0; i < ip_set_max; i++) {\r\ns = nfnl_set(i);\r\nif (s == NULL) {\r\nif (*index == IPSET_INVALID_ID)\r\n*index = i;\r\n} else if (STREQ(name, s->name)) {\r\n*set = s;\r\nreturn -EEXIST;\r\n}\r\n}\r\nif (*index == IPSET_INVALID_ID)\r\nreturn -IPSET_ERR_MAX_SETS;\r\nreturn 0;\r\n}\r\nstatic int\r\nip_set_none(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nip_set_create(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct ip_set *set, *clash = NULL;\r\nip_set_id_t index = IPSET_INVALID_ID;\r\nstruct nlattr *tb[IPSET_ATTR_CREATE_MAX+1] = {};\r\nconst char *name, *typename;\r\nu8 family, revision;\r\nu32 flags = flag_exist(nlh);\r\nint ret = 0;\r\nif (unlikely(protocol_failed(attr) ||\r\nattr[IPSET_ATTR_SETNAME] == NULL ||\r\nattr[IPSET_ATTR_TYPENAME] == NULL ||\r\nattr[IPSET_ATTR_REVISION] == NULL ||\r\nattr[IPSET_ATTR_FAMILY] == NULL ||\r\n(attr[IPSET_ATTR_DATA] != NULL &&\r\n!flag_nested(attr[IPSET_ATTR_DATA]))))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nname = nla_data(attr[IPSET_ATTR_SETNAME]);\r\ntypename = nla_data(attr[IPSET_ATTR_TYPENAME]);\r\nfamily = nla_get_u8(attr[IPSET_ATTR_FAMILY]);\r\nrevision = nla_get_u8(attr[IPSET_ATTR_REVISION]);\r\npr_debug("setname: %s, typename: %s, family: %s, revision: %u\n",\r\nname, typename, family_name(family), revision);\r\nset = kzalloc(sizeof(struct ip_set), GFP_KERNEL);\r\nif (!set)\r\nreturn -ENOMEM;\r\nrwlock_init(&set->lock);\r\nstrlcpy(set->name, name, IPSET_MAXNAMELEN);\r\nset->family = family;\r\nset->revision = revision;\r\nret = find_set_type_get(typename, family, revision, &(set->type));\r\nif (ret)\r\ngoto out;\r\nif (attr[IPSET_ATTR_DATA] &&\r\nnla_parse_nested(tb, IPSET_ATTR_CREATE_MAX, attr[IPSET_ATTR_DATA],\r\nset->type->create_policy)) {\r\nret = -IPSET_ERR_PROTOCOL;\r\ngoto put_out;\r\n}\r\nret = set->type->create(set, tb, flags);\r\nif (ret != 0)\r\ngoto put_out;\r\nret = find_free_id(set->name, &index, &clash);\r\nif (ret == -EEXIST) {\r\nif ((flags & IPSET_FLAG_EXIST) &&\r\nSTREQ(set->type->name, clash->type->name) &&\r\nset->type->family == clash->type->family &&\r\nset->type->revision_min == clash->type->revision_min &&\r\nset->type->revision_max == clash->type->revision_max &&\r\nset->variant->same_set(set, clash))\r\nret = 0;\r\ngoto cleanup;\r\n} else if (ret == -IPSET_ERR_MAX_SETS) {\r\nstruct ip_set **list, **tmp;\r\nip_set_id_t i = ip_set_max + IP_SET_INC;\r\nif (i < ip_set_max || i == IPSET_INVALID_ID)\r\ngoto cleanup;\r\nlist = kzalloc(sizeof(struct ip_set *) * i, GFP_KERNEL);\r\nif (!list)\r\ngoto cleanup;\r\ntmp = nfnl_dereference(ip_set_list);\r\nmemcpy(list, tmp, sizeof(struct ip_set *) * ip_set_max);\r\nrcu_assign_pointer(ip_set_list, list);\r\nsynchronize_net();\r\nindex = ip_set_max;\r\nip_set_max = i;\r\nkfree(tmp);\r\nret = 0;\r\n} else if (ret)\r\ngoto cleanup;\r\npr_debug("create: '%s' created with index %u!\n", set->name, index);\r\nnfnl_set(index) = set;\r\nreturn ret;\r\ncleanup:\r\nset->variant->destroy(set);\r\nput_out:\r\nmodule_put(set->type->me);\r\nout:\r\nkfree(set);\r\nreturn ret;\r\n}\r\nstatic void\r\nip_set_destroy_set(ip_set_id_t index)\r\n{\r\nstruct ip_set *set = nfnl_set(index);\r\npr_debug("set: %s\n", set->name);\r\nnfnl_set(index) = NULL;\r\nset->variant->destroy(set);\r\nmodule_put(set->type->me);\r\nkfree(set);\r\n}\r\nstatic int\r\nip_set_destroy(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct ip_set *s;\r\nip_set_id_t i;\r\nint ret = 0;\r\nif (unlikely(protocol_failed(attr)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nread_lock_bh(&ip_set_ref_lock);\r\nif (!attr[IPSET_ATTR_SETNAME]) {\r\nfor (i = 0; i < ip_set_max; i++) {\r\ns = nfnl_set(i);\r\nif (s != NULL && s->ref) {\r\nret = -IPSET_ERR_BUSY;\r\ngoto out;\r\n}\r\n}\r\nread_unlock_bh(&ip_set_ref_lock);\r\nfor (i = 0; i < ip_set_max; i++) {\r\ns = nfnl_set(i);\r\nif (s != NULL)\r\nip_set_destroy_set(i);\r\n}\r\n} else {\r\ns = find_set_and_id(nla_data(attr[IPSET_ATTR_SETNAME]), &i);\r\nif (s == NULL) {\r\nret = -ENOENT;\r\ngoto out;\r\n} else if (s->ref) {\r\nret = -IPSET_ERR_BUSY;\r\ngoto out;\r\n}\r\nread_unlock_bh(&ip_set_ref_lock);\r\nip_set_destroy_set(i);\r\n}\r\nreturn 0;\r\nout:\r\nread_unlock_bh(&ip_set_ref_lock);\r\nreturn ret;\r\n}\r\nstatic void\r\nip_set_flush_set(struct ip_set *set)\r\n{\r\npr_debug("set: %s\n", set->name);\r\nwrite_lock_bh(&set->lock);\r\nset->variant->flush(set);\r\nwrite_unlock_bh(&set->lock);\r\n}\r\nstatic int\r\nip_set_flush(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct ip_set *s;\r\nip_set_id_t i;\r\nif (unlikely(protocol_failed(attr)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (!attr[IPSET_ATTR_SETNAME]) {\r\nfor (i = 0; i < ip_set_max; i++) {\r\ns = nfnl_set(i);\r\nif (s != NULL)\r\nip_set_flush_set(s);\r\n}\r\n} else {\r\ns = find_set(nla_data(attr[IPSET_ATTR_SETNAME]));\r\nif (s == NULL)\r\nreturn -ENOENT;\r\nip_set_flush_set(s);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nip_set_rename(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct ip_set *set, *s;\r\nconst char *name2;\r\nip_set_id_t i;\r\nint ret = 0;\r\nif (unlikely(protocol_failed(attr) ||\r\nattr[IPSET_ATTR_SETNAME] == NULL ||\r\nattr[IPSET_ATTR_SETNAME2] == NULL))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nset = find_set(nla_data(attr[IPSET_ATTR_SETNAME]));\r\nif (set == NULL)\r\nreturn -ENOENT;\r\nread_lock_bh(&ip_set_ref_lock);\r\nif (set->ref != 0) {\r\nret = -IPSET_ERR_REFERENCED;\r\ngoto out;\r\n}\r\nname2 = nla_data(attr[IPSET_ATTR_SETNAME2]);\r\nfor (i = 0; i < ip_set_max; i++) {\r\ns = nfnl_set(i);\r\nif (s != NULL && STREQ(s->name, name2)) {\r\nret = -IPSET_ERR_EXIST_SETNAME2;\r\ngoto out;\r\n}\r\n}\r\nstrncpy(set->name, name2, IPSET_MAXNAMELEN);\r\nout:\r\nread_unlock_bh(&ip_set_ref_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nip_set_swap(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct ip_set *from, *to;\r\nip_set_id_t from_id, to_id;\r\nchar from_name[IPSET_MAXNAMELEN];\r\nif (unlikely(protocol_failed(attr) ||\r\nattr[IPSET_ATTR_SETNAME] == NULL ||\r\nattr[IPSET_ATTR_SETNAME2] == NULL))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nfrom = find_set_and_id(nla_data(attr[IPSET_ATTR_SETNAME]), &from_id);\r\nif (from == NULL)\r\nreturn -ENOENT;\r\nto = find_set_and_id(nla_data(attr[IPSET_ATTR_SETNAME2]), &to_id);\r\nif (to == NULL)\r\nreturn -IPSET_ERR_EXIST_SETNAME2;\r\nif (!(from->type->features == to->type->features &&\r\nfrom->type->family == to->type->family))\r\nreturn -IPSET_ERR_TYPE_MISMATCH;\r\nstrncpy(from_name, from->name, IPSET_MAXNAMELEN);\r\nstrncpy(from->name, to->name, IPSET_MAXNAMELEN);\r\nstrncpy(to->name, from_name, IPSET_MAXNAMELEN);\r\nwrite_lock_bh(&ip_set_ref_lock);\r\nswap(from->ref, to->ref);\r\nnfnl_set(from_id) = to;\r\nnfnl_set(to_id) = from;\r\nwrite_unlock_bh(&ip_set_ref_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nip_set_dump_done(struct netlink_callback *cb)\r\n{\r\nif (cb->args[2]) {\r\npr_debug("release set %s\n", nfnl_set(cb->args[1])->name);\r\nip_set_put_byindex((ip_set_id_t) cb->args[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\ndump_attrs(struct nlmsghdr *nlh)\r\n{\r\nconst struct nlattr *attr;\r\nint rem;\r\npr_debug("dump nlmsg\n");\r\nnlmsg_for_each_attr(attr, nlh, sizeof(struct nfgenmsg), rem) {\r\npr_debug("type: %u, len %u\n", nla_type(attr), attr->nla_len);\r\n}\r\n}\r\nstatic int\r\ndump_init(struct netlink_callback *cb)\r\n{\r\nstruct nlmsghdr *nlh = nlmsg_hdr(cb->skb);\r\nint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\r\nstruct nlattr *cda[IPSET_ATTR_CMD_MAX+1];\r\nstruct nlattr *attr = (void *)nlh + min_len;\r\nu32 dump_type;\r\nip_set_id_t index;\r\nnla_parse(cda, IPSET_ATTR_CMD_MAX,\r\nattr, nlh->nlmsg_len - min_len, ip_set_setname_policy);\r\nif (cda[IPSET_ATTR_SETNAME]) {\r\nstruct ip_set *set;\r\nset = find_set_and_id(nla_data(cda[IPSET_ATTR_SETNAME]),\r\n&index);\r\nif (set == NULL)\r\nreturn -ENOENT;\r\ndump_type = DUMP_ONE;\r\ncb->args[1] = index;\r\n} else\r\ndump_type = DUMP_ALL;\r\nif (cda[IPSET_ATTR_FLAGS]) {\r\nu32 f = ip_set_get_h32(cda[IPSET_ATTR_FLAGS]);\r\ndump_type |= (f << 16);\r\n}\r\ncb->args[0] = dump_type;\r\nreturn 0;\r\n}\r\nstatic int\r\nip_set_dump_start(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nip_set_id_t index = IPSET_INVALID_ID, max;\r\nstruct ip_set *set = NULL;\r\nstruct nlmsghdr *nlh = NULL;\r\nunsigned int flags = NETLINK_CB(cb->skb).portid ? NLM_F_MULTI : 0;\r\nu32 dump_type, dump_flags;\r\nint ret = 0;\r\nif (!cb->args[0]) {\r\nret = dump_init(cb);\r\nif (ret < 0) {\r\nnlh = nlmsg_hdr(cb->skb);\r\nif (nlh->nlmsg_flags & NLM_F_ACK)\r\nnetlink_ack(cb->skb, nlh, ret);\r\nreturn ret;\r\n}\r\n}\r\nif (cb->args[1] >= ip_set_max)\r\ngoto out;\r\ndump_type = DUMP_TYPE(cb->args[0]);\r\ndump_flags = DUMP_FLAGS(cb->args[0]);\r\nmax = dump_type == DUMP_ONE ? cb->args[1] + 1 : ip_set_max;\r\ndump_last:\r\npr_debug("args[0]: %u %u args[1]: %ld\n",\r\ndump_type, dump_flags, cb->args[1]);\r\nfor (; cb->args[1] < max; cb->args[1]++) {\r\nindex = (ip_set_id_t) cb->args[1];\r\nset = nfnl_set(index);\r\nif (set == NULL) {\r\nif (dump_type == DUMP_ONE) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\ncontinue;\r\n}\r\nif (dump_type != DUMP_ONE &&\r\n((dump_type == DUMP_ALL) ==\r\n!!(set->type->features & IPSET_DUMP_LAST)))\r\ncontinue;\r\npr_debug("List set: %s\n", set->name);\r\nif (!cb->args[2]) {\r\npr_debug("reference set\n");\r\n__ip_set_get(set);\r\n}\r\nnlh = start_msg(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, flags,\r\nIPSET_CMD_LIST);\r\nif (!nlh) {\r\nret = -EMSGSIZE;\r\ngoto release_refcount;\r\n}\r\nif (nla_put_u8(skb, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL) ||\r\nnla_put_string(skb, IPSET_ATTR_SETNAME, set->name))\r\ngoto nla_put_failure;\r\nif (dump_flags & IPSET_FLAG_LIST_SETNAME)\r\ngoto next_set;\r\nswitch (cb->args[2]) {\r\ncase 0:\r\nif (nla_put_string(skb, IPSET_ATTR_TYPENAME,\r\nset->type->name) ||\r\nnla_put_u8(skb, IPSET_ATTR_FAMILY,\r\nset->family) ||\r\nnla_put_u8(skb, IPSET_ATTR_REVISION,\r\nset->revision))\r\ngoto nla_put_failure;\r\nret = set->variant->head(set, skb);\r\nif (ret < 0)\r\ngoto release_refcount;\r\nif (dump_flags & IPSET_FLAG_LIST_HEADER)\r\ngoto next_set;\r\ndefault:\r\nread_lock_bh(&set->lock);\r\nret = set->variant->list(set, skb, cb);\r\nread_unlock_bh(&set->lock);\r\nif (!cb->args[2])\r\ngoto next_set;\r\ngoto release_refcount;\r\n}\r\n}\r\nif (dump_type == DUMP_ALL) {\r\ndump_type = DUMP_LAST;\r\ncb->args[0] = dump_type | (dump_flags << 16);\r\ncb->args[1] = 0;\r\ngoto dump_last;\r\n}\r\ngoto out;\r\nnla_put_failure:\r\nret = -EFAULT;\r\nnext_set:\r\nif (dump_type == DUMP_ONE)\r\ncb->args[1] = IPSET_INVALID_ID;\r\nelse\r\ncb->args[1]++;\r\nrelease_refcount:\r\nif (ret || !cb->args[2]) {\r\npr_debug("release set %s\n", nfnl_set(index)->name);\r\nip_set_put_byindex(index);\r\ncb->args[2] = 0;\r\n}\r\nout:\r\nif (nlh) {\r\nnlmsg_end(skb, nlh);\r\npr_debug("nlmsg_len: %u\n", nlh->nlmsg_len);\r\ndump_attrs(nlh);\r\n}\r\nreturn ret < 0 ? ret : skb->len;\r\n}\r\nstatic int\r\nip_set_dump(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nif (unlikely(protocol_failed(attr)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\n{\r\nstruct netlink_dump_control c = {\r\n.dump = ip_set_dump_start,\r\n.done = ip_set_dump_done,\r\n};\r\nreturn netlink_dump_start(ctnl, skb, nlh, &c);\r\n}\r\n}\r\nstatic int\r\ncall_ad(struct sock *ctnl, struct sk_buff *skb, struct ip_set *set,\r\nstruct nlattr *tb[], enum ipset_adt adt,\r\nu32 flags, bool use_lineno)\r\n{\r\nint ret;\r\nu32 lineno = 0;\r\nbool eexist = flags & IPSET_FLAG_EXIST, retried = false;\r\ndo {\r\nwrite_lock_bh(&set->lock);\r\nret = set->variant->uadt(set, tb, adt, &lineno, flags, retried);\r\nwrite_unlock_bh(&set->lock);\r\nretried = true;\r\n} while (ret == -EAGAIN &&\r\nset->variant->resize &&\r\n(ret = set->variant->resize(set, retried)) == 0);\r\nif (!ret || (ret == -IPSET_ERR_EXIST && eexist))\r\nreturn 0;\r\nif (lineno && use_lineno) {\r\nstruct nlmsghdr *rep, *nlh = nlmsg_hdr(skb);\r\nstruct sk_buff *skb2;\r\nstruct nlmsgerr *errmsg;\r\nsize_t payload = sizeof(*errmsg) + nlmsg_len(nlh);\r\nint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\r\nstruct nlattr *cda[IPSET_ATTR_CMD_MAX+1];\r\nstruct nlattr *cmdattr;\r\nu32 *errline;\r\nskb2 = nlmsg_new(payload, GFP_KERNEL);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nrep = __nlmsg_put(skb2, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq, NLMSG_ERROR, payload, 0);\r\nerrmsg = nlmsg_data(rep);\r\nerrmsg->error = ret;\r\nmemcpy(&errmsg->msg, nlh, nlh->nlmsg_len);\r\ncmdattr = (void *)&errmsg->msg + min_len;\r\nnla_parse(cda, IPSET_ATTR_CMD_MAX,\r\ncmdattr, nlh->nlmsg_len - min_len,\r\nip_set_adt_policy);\r\nerrline = nla_data(cda[IPSET_ATTR_LINENO]);\r\n*errline = lineno;\r\nnetlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);\r\nreturn -EINTR;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nip_set_uadd(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct ip_set *set;\r\nstruct nlattr *tb[IPSET_ATTR_ADT_MAX+1] = {};\r\nconst struct nlattr *nla;\r\nu32 flags = flag_exist(nlh);\r\nbool use_lineno;\r\nint ret = 0;\r\nif (unlikely(protocol_failed(attr) ||\r\nattr[IPSET_ATTR_SETNAME] == NULL ||\r\n!((attr[IPSET_ATTR_DATA] != NULL) ^\r\n(attr[IPSET_ATTR_ADT] != NULL)) ||\r\n(attr[IPSET_ATTR_DATA] != NULL &&\r\n!flag_nested(attr[IPSET_ATTR_DATA])) ||\r\n(attr[IPSET_ATTR_ADT] != NULL &&\r\n(!flag_nested(attr[IPSET_ATTR_ADT]) ||\r\nattr[IPSET_ATTR_LINENO] == NULL))))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nset = find_set(nla_data(attr[IPSET_ATTR_SETNAME]));\r\nif (set == NULL)\r\nreturn -ENOENT;\r\nuse_lineno = !!attr[IPSET_ATTR_LINENO];\r\nif (attr[IPSET_ATTR_DATA]) {\r\nif (nla_parse_nested(tb, IPSET_ATTR_ADT_MAX,\r\nattr[IPSET_ATTR_DATA],\r\nset->type->adt_policy))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = call_ad(ctnl, skb, set, tb, IPSET_ADD, flags,\r\nuse_lineno);\r\n} else {\r\nint nla_rem;\r\nnla_for_each_nested(nla, attr[IPSET_ATTR_ADT], nla_rem) {\r\nmemset(tb, 0, sizeof(tb));\r\nif (nla_type(nla) != IPSET_ATTR_DATA ||\r\n!flag_nested(nla) ||\r\nnla_parse_nested(tb, IPSET_ATTR_ADT_MAX, nla,\r\nset->type->adt_policy))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = call_ad(ctnl, skb, set, tb, IPSET_ADD,\r\nflags, use_lineno);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nip_set_udel(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct ip_set *set;\r\nstruct nlattr *tb[IPSET_ATTR_ADT_MAX+1] = {};\r\nconst struct nlattr *nla;\r\nu32 flags = flag_exist(nlh);\r\nbool use_lineno;\r\nint ret = 0;\r\nif (unlikely(protocol_failed(attr) ||\r\nattr[IPSET_ATTR_SETNAME] == NULL ||\r\n!((attr[IPSET_ATTR_DATA] != NULL) ^\r\n(attr[IPSET_ATTR_ADT] != NULL)) ||\r\n(attr[IPSET_ATTR_DATA] != NULL &&\r\n!flag_nested(attr[IPSET_ATTR_DATA])) ||\r\n(attr[IPSET_ATTR_ADT] != NULL &&\r\n(!flag_nested(attr[IPSET_ATTR_ADT]) ||\r\nattr[IPSET_ATTR_LINENO] == NULL))))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nset = find_set(nla_data(attr[IPSET_ATTR_SETNAME]));\r\nif (set == NULL)\r\nreturn -ENOENT;\r\nuse_lineno = !!attr[IPSET_ATTR_LINENO];\r\nif (attr[IPSET_ATTR_DATA]) {\r\nif (nla_parse_nested(tb, IPSET_ATTR_ADT_MAX,\r\nattr[IPSET_ATTR_DATA],\r\nset->type->adt_policy))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = call_ad(ctnl, skb, set, tb, IPSET_DEL, flags,\r\nuse_lineno);\r\n} else {\r\nint nla_rem;\r\nnla_for_each_nested(nla, attr[IPSET_ATTR_ADT], nla_rem) {\r\nmemset(tb, 0, sizeof(*tb));\r\nif (nla_type(nla) != IPSET_ATTR_DATA ||\r\n!flag_nested(nla) ||\r\nnla_parse_nested(tb, IPSET_ATTR_ADT_MAX, nla,\r\nset->type->adt_policy))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = call_ad(ctnl, skb, set, tb, IPSET_DEL,\r\nflags, use_lineno);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nip_set_utest(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct ip_set *set;\r\nstruct nlattr *tb[IPSET_ATTR_ADT_MAX+1] = {};\r\nint ret = 0;\r\nif (unlikely(protocol_failed(attr) ||\r\nattr[IPSET_ATTR_SETNAME] == NULL ||\r\nattr[IPSET_ATTR_DATA] == NULL ||\r\n!flag_nested(attr[IPSET_ATTR_DATA])))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nset = find_set(nla_data(attr[IPSET_ATTR_SETNAME]));\r\nif (set == NULL)\r\nreturn -ENOENT;\r\nif (nla_parse_nested(tb, IPSET_ATTR_ADT_MAX, attr[IPSET_ATTR_DATA],\r\nset->type->adt_policy))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nread_lock_bh(&set->lock);\r\nret = set->variant->uadt(set, tb, IPSET_TEST, NULL, 0, 0);\r\nread_unlock_bh(&set->lock);\r\nif (ret == -EAGAIN)\r\nret = 1;\r\nreturn (ret < 0 && ret != -ENOTEMPTY) ? ret :\r\nret > 0 ? 0 : -IPSET_ERR_EXIST;\r\n}\r\nstatic int\r\nip_set_header(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nconst struct ip_set *set;\r\nstruct sk_buff *skb2;\r\nstruct nlmsghdr *nlh2;\r\nint ret = 0;\r\nif (unlikely(protocol_failed(attr) ||\r\nattr[IPSET_ATTR_SETNAME] == NULL))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nset = find_set(nla_data(attr[IPSET_ATTR_SETNAME]));\r\nif (set == NULL)\r\nreturn -ENOENT;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nnlh2 = start_msg(skb2, NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0,\r\nIPSET_CMD_HEADER);\r\nif (!nlh2)\r\ngoto nlmsg_failure;\r\nif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL) ||\r\nnla_put_string(skb2, IPSET_ATTR_SETNAME, set->name) ||\r\nnla_put_string(skb2, IPSET_ATTR_TYPENAME, set->type->name) ||\r\nnla_put_u8(skb2, IPSET_ATTR_FAMILY, set->family) ||\r\nnla_put_u8(skb2, IPSET_ATTR_REVISION, set->revision))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb2, nlh2);\r\nret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb2, nlh2);\r\nnlmsg_failure:\r\nkfree_skb(skb2);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nip_set_type(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct sk_buff *skb2;\r\nstruct nlmsghdr *nlh2;\r\nu8 family, min, max;\r\nconst char *typename;\r\nint ret = 0;\r\nif (unlikely(protocol_failed(attr) ||\r\nattr[IPSET_ATTR_TYPENAME] == NULL ||\r\nattr[IPSET_ATTR_FAMILY] == NULL))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nfamily = nla_get_u8(attr[IPSET_ATTR_FAMILY]);\r\ntypename = nla_data(attr[IPSET_ATTR_TYPENAME]);\r\nret = find_set_type_minmax(typename, family, &min, &max);\r\nif (ret)\r\nreturn ret;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nnlh2 = start_msg(skb2, NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0,\r\nIPSET_CMD_TYPE);\r\nif (!nlh2)\r\ngoto nlmsg_failure;\r\nif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL) ||\r\nnla_put_string(skb2, IPSET_ATTR_TYPENAME, typename) ||\r\nnla_put_u8(skb2, IPSET_ATTR_FAMILY, family) ||\r\nnla_put_u8(skb2, IPSET_ATTR_REVISION, max) ||\r\nnla_put_u8(skb2, IPSET_ATTR_REVISION_MIN, min))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb2, nlh2);\r\npr_debug("Send TYPE, nlmsg_len: %u\n", nlh2->nlmsg_len);\r\nret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb2, nlh2);\r\nnlmsg_failure:\r\nkfree_skb(skb2);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nip_set_protocol(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const attr[])\r\n{\r\nstruct sk_buff *skb2;\r\nstruct nlmsghdr *nlh2;\r\nint ret = 0;\r\nif (unlikely(attr[IPSET_ATTR_PROTOCOL] == NULL))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nnlh2 = start_msg(skb2, NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0,\r\nIPSET_CMD_PROTOCOL);\r\nif (!nlh2)\r\ngoto nlmsg_failure;\r\nif (nla_put_u8(skb2, IPSET_ATTR_PROTOCOL, IPSET_PROTOCOL))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb2, nlh2);\r\nret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb2, nlh2);\r\nnlmsg_failure:\r\nkfree_skb(skb2);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nip_set_sockfn_get(struct sock *sk, int optval, void __user *user, int *len)\r\n{\r\nunsigned int *op;\r\nvoid *data;\r\nint copylen = *len, ret = 0;\r\nif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (optval != SO_IP_SET)\r\nreturn -EBADF;\r\nif (*len < sizeof(unsigned int))\r\nreturn -EINVAL;\r\ndata = vmalloc(*len);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (copy_from_user(data, user, *len) != 0) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nop = (unsigned int *) data;\r\nif (*op < IP_SET_OP_VERSION) {\r\nstruct ip_set_req_version *req_version = data;\r\nif (req_version->version != IPSET_PROTOCOL) {\r\nret = -EPROTO;\r\ngoto done;\r\n}\r\n}\r\nswitch (*op) {\r\ncase IP_SET_OP_VERSION: {\r\nstruct ip_set_req_version *req_version = data;\r\nif (*len != sizeof(struct ip_set_req_version)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nreq_version->version = IPSET_PROTOCOL;\r\nret = copy_to_user(user, req_version,\r\nsizeof(struct ip_set_req_version));\r\ngoto done;\r\n}\r\ncase IP_SET_OP_GET_BYNAME: {\r\nstruct ip_set_req_get_set *req_get = data;\r\nip_set_id_t id;\r\nif (*len != sizeof(struct ip_set_req_get_set)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nreq_get->set.name[IPSET_MAXNAMELEN - 1] = '\0';\r\nnfnl_lock(NFNL_SUBSYS_IPSET);\r\nfind_set_and_id(req_get->set.name, &id);\r\nreq_get->set.index = id;\r\nnfnl_unlock(NFNL_SUBSYS_IPSET);\r\ngoto copy;\r\n}\r\ncase IP_SET_OP_GET_BYINDEX: {\r\nstruct ip_set_req_get_set *req_get = data;\r\nstruct ip_set *set;\r\nif (*len != sizeof(struct ip_set_req_get_set) ||\r\nreq_get->set.index >= ip_set_max) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nnfnl_lock(NFNL_SUBSYS_IPSET);\r\nset = nfnl_set(req_get->set.index);\r\nstrncpy(req_get->set.name, set ? set->name : "",\r\nIPSET_MAXNAMELEN);\r\nnfnl_unlock(NFNL_SUBSYS_IPSET);\r\ngoto copy;\r\n}\r\ndefault:\r\nret = -EBADMSG;\r\ngoto done;\r\n}\r\ncopy:\r\nret = copy_to_user(user, data, copylen);\r\ndone:\r\nvfree(data);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int __init\r\nip_set_init(void)\r\n{\r\nstruct ip_set **list;\r\nint ret;\r\nif (max_sets)\r\nip_set_max = max_sets;\r\nif (ip_set_max >= IPSET_INVALID_ID)\r\nip_set_max = IPSET_INVALID_ID - 1;\r\nlist = kzalloc(sizeof(struct ip_set *) * ip_set_max, GFP_KERNEL);\r\nif (!list)\r\nreturn -ENOMEM;\r\nrcu_assign_pointer(ip_set_list, list);\r\nret = nfnetlink_subsys_register(&ip_set_netlink_subsys);\r\nif (ret != 0) {\r\npr_err("ip_set: cannot register with nfnetlink.\n");\r\nkfree(list);\r\nreturn ret;\r\n}\r\nret = nf_register_sockopt(&so_set);\r\nif (ret != 0) {\r\npr_err("SO_SET registry failed: %d\n", ret);\r\nnfnetlink_subsys_unregister(&ip_set_netlink_subsys);\r\nkfree(list);\r\nreturn ret;\r\n}\r\npr_notice("ip_set: protocol %u\n", IPSET_PROTOCOL);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nip_set_fini(void)\r\n{\r\nstruct ip_set **list = rcu_dereference_protected(ip_set_list, 1);\r\nnf_unregister_sockopt(&so_set);\r\nnfnetlink_subsys_unregister(&ip_set_netlink_subsys);\r\nkfree(list);\r\npr_debug("these are the famous last words\n");\r\n}
