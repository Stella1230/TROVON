static int sch_transaction(void)\r\n{\r\nint temp;\r\nint result = 0;\r\nint retries = 0;\r\ndev_dbg(&sch_adapter.dev, "Transaction (pre): CNT=%02x, CMD=%02x, "\r\n"ADD=%02x, DAT0=%02x, DAT1=%02x\n", inb(SMBHSTCNT),\r\ninb(SMBHSTCMD), inb(SMBHSTADD), inb(SMBHSTDAT0),\r\ninb(SMBHSTDAT1));\r\ntemp = inb(SMBHSTSTS) & 0x0f;\r\nif (temp) {\r\nif (temp & 0x01) {\r\ndev_dbg(&sch_adapter.dev, "Completion (%02x). "\r\n"Clear...\n", temp);\r\n}\r\nif (temp & 0x06) {\r\ndev_dbg(&sch_adapter.dev, "SMBus error (%02x). "\r\n"Resetting...\n", temp);\r\n}\r\noutb(temp, SMBHSTSTS);\r\ntemp = inb(SMBHSTSTS) & 0x0f;\r\nif (temp) {\r\ndev_err(&sch_adapter.dev,\r\n"SMBus is not ready: (%02x)\n", temp);\r\nreturn -EAGAIN;\r\n}\r\n}\r\noutb(inb(SMBHSTCNT) | 0x10, SMBHSTCNT);\r\ndo {\r\nusleep_range(100, 200);\r\ntemp = inb(SMBHSTSTS) & 0x0f;\r\n} while ((temp & 0x08) && (retries++ < MAX_RETRIES));\r\nif (retries > MAX_RETRIES) {\r\ndev_err(&sch_adapter.dev, "SMBus Timeout!\n");\r\nresult = -ETIMEDOUT;\r\n}\r\nif (temp & 0x04) {\r\nresult = -EIO;\r\ndev_dbg(&sch_adapter.dev, "Bus collision! SMBus may be "\r\n"locked until next hard reset. (sorry!)\n");\r\n} else if (temp & 0x02) {\r\nresult = -EIO;\r\ndev_err(&sch_adapter.dev, "Error: no response!\n");\r\n} else if (temp & 0x01) {\r\ndev_dbg(&sch_adapter.dev, "Post complete!\n");\r\noutb(temp, SMBHSTSTS);\r\ntemp = inb(SMBHSTSTS) & 0x07;\r\nif (temp & 0x06) {\r\ndev_dbg(&sch_adapter.dev, "Failed reset at end of "\r\n"transaction (%02x), Bus error!\n", temp);\r\n}\r\n} else {\r\nresult = -ENXIO;\r\ndev_dbg(&sch_adapter.dev, "No such address.\n");\r\n}\r\ndev_dbg(&sch_adapter.dev, "Transaction (post): CNT=%02x, CMD=%02x, "\r\n"ADD=%02x, DAT0=%02x, DAT1=%02x\n", inb(SMBHSTCNT),\r\ninb(SMBHSTCMD), inb(SMBHSTADD), inb(SMBHSTDAT0),\r\ninb(SMBHSTDAT1));\r\nreturn result;\r\n}\r\nstatic s32 sch_access(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data *data)\r\n{\r\nint i, len, temp, rc;\r\ntemp = inb(SMBHSTSTS) & 0x0f;\r\nif (temp & 0x08) {\r\ndev_dbg(&sch_adapter.dev, "SMBus busy (%02x)\n", temp);\r\nreturn -EAGAIN;\r\n}\r\ntemp = inw(SMBHSTCLK);\r\nif (!temp) {\r\ndev_notice(&sch_adapter.dev,\r\n"Clock divider unitialized. Setting defaults\n");\r\noutw(backbone_speed / (4 * 100), SMBHSTCLK);\r\n}\r\ndev_dbg(&sch_adapter.dev, "access size: %d %s\n", size,\r\n(read_write)?"READ":"WRITE");\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\noutb((addr << 1) | read_write, SMBHSTADD);\r\nsize = SCH_QUICK;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\noutb((addr << 1) | read_write, SMBHSTADD);\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb(command, SMBHSTCMD);\r\nsize = SCH_BYTE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\noutb((addr << 1) | read_write, SMBHSTADD);\r\noutb(command, SMBHSTCMD);\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb(data->byte, SMBHSTDAT0);\r\nsize = SCH_BYTE_DATA;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\noutb((addr << 1) | read_write, SMBHSTADD);\r\noutb(command, SMBHSTCMD);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\noutb(data->word & 0xff, SMBHSTDAT0);\r\noutb((data->word & 0xff00) >> 8, SMBHSTDAT1);\r\n}\r\nsize = SCH_WORD_DATA;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\noutb((addr << 1) | read_write, SMBHSTADD);\r\noutb(command, SMBHSTCMD);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = data->block[0];\r\nif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EINVAL;\r\noutb(len, SMBHSTDAT0);\r\nfor (i = 1; i <= len; i++)\r\noutb(data->block[i], SMBBLKDAT+i-1);\r\n}\r\nsize = SCH_BLOCK_DATA;\r\nbreak;\r\ndefault:\r\ndev_warn(&adap->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\ndev_dbg(&sch_adapter.dev, "write size %d to 0x%04x\n", size, SMBHSTCNT);\r\noutb((inb(SMBHSTCNT) & 0xb0) | (size & 0x7), SMBHSTCNT);\r\nrc = sch_transaction();\r\nif (rc)\r\nreturn rc;\r\nif ((read_write == I2C_SMBUS_WRITE) || (size == SCH_QUICK))\r\nreturn 0;\r\nswitch (size) {\r\ncase SCH_BYTE:\r\ncase SCH_BYTE_DATA:\r\ndata->byte = inb(SMBHSTDAT0);\r\nbreak;\r\ncase SCH_WORD_DATA:\r\ndata->word = inb(SMBHSTDAT0) + (inb(SMBHSTDAT1) << 8);\r\nbreak;\r\ncase SCH_BLOCK_DATA:\r\ndata->block[0] = inb(SMBHSTDAT0);\r\nif (data->block[0] == 0 || data->block[0] > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EPROTO;\r\nfor (i = 1; i <= data->block[0]; i++)\r\ndata->block[i] = inb(SMBBLKDAT+i-1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 sch_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA;\r\n}\r\nstatic int smbus_sch_probe(struct platform_device *dev)\r\n{\r\nstruct resource *res;\r\nint retval;\r\nres = platform_get_resource(dev, IORESOURCE_IO, 0);\r\nif (!res)\r\nreturn -EBUSY;\r\nif (!request_region(res->start, resource_size(res), dev->name)) {\r\ndev_err(&dev->dev, "SMBus region 0x%x already in use!\n",\r\nsch_smba);\r\nreturn -EBUSY;\r\n}\r\nsch_smba = res->start;\r\ndev_dbg(&dev->dev, "SMBA = 0x%X\n", sch_smba);\r\nsch_adapter.dev.parent = &dev->dev;\r\nsnprintf(sch_adapter.name, sizeof(sch_adapter.name),\r\n"SMBus SCH adapter at %04x", sch_smba);\r\nretval = i2c_add_adapter(&sch_adapter);\r\nif (retval) {\r\ndev_err(&dev->dev, "Couldn't register adapter!\n");\r\nrelease_region(res->start, resource_size(res));\r\nsch_smba = 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic int smbus_sch_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nif (sch_smba) {\r\ni2c_del_adapter(&sch_adapter);\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nrelease_region(res->start, resource_size(res));\r\nsch_smba = 0;\r\n}\r\nreturn 0;\r\n}
