static void vmlogrdr_iucv_path_complete(struct iucv_path *path, u8 ipuser[16])\r\n{\r\nstruct vmlogrdr_priv_t * logptr = path->private;\r\nspin_lock(&logptr->priv_lock);\r\nlogptr->connection_established = 1;\r\nspin_unlock(&logptr->priv_lock);\r\nwake_up(&conn_wait_queue);\r\n}\r\nstatic void vmlogrdr_iucv_path_severed(struct iucv_path *path, u8 ipuser[16])\r\n{\r\nstruct vmlogrdr_priv_t * logptr = path->private;\r\nu8 reason = (u8) ipuser[8];\r\npr_err("vmlogrdr: connection severed with reason %i\n", reason);\r\niucv_path_sever(path, NULL);\r\nkfree(path);\r\nlogptr->path = NULL;\r\nspin_lock(&logptr->priv_lock);\r\nlogptr->connection_established = 0;\r\nlogptr->iucv_path_severed = 1;\r\nspin_unlock(&logptr->priv_lock);\r\nwake_up(&conn_wait_queue);\r\nwake_up_interruptible(&read_wait_queue);\r\n}\r\nstatic void vmlogrdr_iucv_message_pending(struct iucv_path *path,\r\nstruct iucv_message *msg)\r\n{\r\nstruct vmlogrdr_priv_t * logptr = path->private;\r\nspin_lock(&logptr->priv_lock);\r\nmemcpy(&logptr->local_interrupt_buffer, msg, sizeof(*msg));\r\natomic_inc(&logptr->receive_ready);\r\nspin_unlock(&logptr->priv_lock);\r\nwake_up_interruptible(&read_wait_queue);\r\n}\r\nstatic int vmlogrdr_get_recording_class_AB(void)\r\n{\r\nstatic const char cp_command[] = "QUERY COMMAND RECORDING ";\r\nchar cp_response[80];\r\nchar *tail;\r\nint len,i;\r\ncpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\r\nlen = strnlen(cp_response,sizeof(cp_response));\r\ntail=strnchr(cp_response,len,'=');\r\nif (!tail)\r\nreturn 0;\r\ntail++;\r\nif (!strncmp("ANY",tail,3))\r\nreturn 1;\r\nif (!strncmp("NONE",tail,4))\r\nreturn 0;\r\nfor (i=tail-cp_response; i<len; i++)\r\nif ( cp_response[i]=='A' || cp_response[i]=='B' )\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int vmlogrdr_recording(struct vmlogrdr_priv_t * logptr,\r\nint action, int purge)\r\n{\r\nchar cp_command[80];\r\nchar cp_response[160];\r\nchar *onoff, *qid_string;\r\nint rc;\r\nonoff = ((action == 1) ? "ON" : "OFF");\r\nqid_string = ((recording_class_AB == 1) ? " QID * " : "");\r\nif (purge && (action == 1)) {\r\nmemset(cp_command, 0x00, sizeof(cp_command));\r\nmemset(cp_response, 0x00, sizeof(cp_response));\r\nsnprintf(cp_command, sizeof(cp_command),\r\n"RECORDING %s PURGE %s",\r\nlogptr->recording_name,\r\nqid_string);\r\ncpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\r\n}\r\nmemset(cp_command, 0x00, sizeof(cp_command));\r\nmemset(cp_response, 0x00, sizeof(cp_response));\r\nsnprintf(cp_command, sizeof(cp_command), "RECORDING %s %s %s",\r\nlogptr->recording_name,\r\nonoff,\r\nqid_string);\r\ncpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\r\nif (strstr(cp_response,"Command complete"))\r\nrc = 0;\r\nelse\r\nrc = -EIO;\r\nif (purge && (action == 0)) {\r\nmemset(cp_command, 0x00, sizeof(cp_command));\r\nmemset(cp_response, 0x00, sizeof(cp_response));\r\nsnprintf(cp_command, sizeof(cp_command),\r\n"RECORDING %s PURGE %s",\r\nlogptr->recording_name,\r\nqid_string);\r\ncpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\r\n}\r\nreturn rc;\r\n}\r\nstatic int vmlogrdr_open (struct inode *inode, struct file *filp)\r\n{\r\nint dev_num = 0;\r\nstruct vmlogrdr_priv_t * logptr = NULL;\r\nint connect_rc = 0;\r\nint ret;\r\ndev_num = iminor(inode);\r\nif (dev_num > MAXMINOR)\r\nreturn -ENODEV;\r\nlogptr = &sys_ser[dev_num];\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EOPNOTSUPP;\r\nspin_lock_bh(&logptr->priv_lock);\r\nif (logptr->dev_in_use) {\r\nspin_unlock_bh(&logptr->priv_lock);\r\nreturn -EBUSY;\r\n}\r\nlogptr->dev_in_use = 1;\r\nlogptr->connection_established = 0;\r\nlogptr->iucv_path_severed = 0;\r\natomic_set(&logptr->receive_ready, 0);\r\nlogptr->buffer_free = 1;\r\nspin_unlock_bh(&logptr->priv_lock);\r\nfilp->private_data = logptr;\r\nfilp->f_op = &vmlogrdr_fops;\r\nif (logptr->autorecording) {\r\nret = vmlogrdr_recording(logptr,1,logptr->autopurge);\r\nif (ret)\r\npr_warning("vmlogrdr: failed to start "\r\n"recording automatically\n");\r\n}\r\nlogptr->path = iucv_path_alloc(10, 0, GFP_KERNEL);\r\nif (!logptr->path)\r\ngoto out_dev;\r\nconnect_rc = iucv_path_connect(logptr->path, &vmlogrdr_iucv_handler,\r\nlogptr->system_service, NULL, NULL,\r\nlogptr);\r\nif (connect_rc) {\r\npr_err("vmlogrdr: iucv connection to %s "\r\n"failed with rc %i \n",\r\nlogptr->system_service, connect_rc);\r\ngoto out_path;\r\n}\r\nwait_event(conn_wait_queue, (logptr->connection_established)\r\n|| (logptr->iucv_path_severed));\r\nif (logptr->iucv_path_severed)\r\ngoto out_record;\r\nnonseekable_open(inode, filp);\r\nreturn 0;\r\nout_record:\r\nif (logptr->autorecording)\r\nvmlogrdr_recording(logptr,0,logptr->autopurge);\r\nout_path:\r\nkfree(logptr->path);\r\nlogptr->path = NULL;\r\nout_dev:\r\nlogptr->dev_in_use = 0;\r\nreturn -EIO;\r\n}\r\nstatic int vmlogrdr_release (struct inode *inode, struct file *filp)\r\n{\r\nint ret;\r\nstruct vmlogrdr_priv_t * logptr = filp->private_data;\r\niucv_path_sever(logptr->path, NULL);\r\nkfree(logptr->path);\r\nlogptr->path = NULL;\r\nif (logptr->autorecording) {\r\nret = vmlogrdr_recording(logptr,0,logptr->autopurge);\r\nif (ret)\r\npr_warning("vmlogrdr: failed to stop "\r\n"recording automatically\n");\r\n}\r\nlogptr->dev_in_use = 0;\r\nreturn 0;\r\n}\r\nstatic int vmlogrdr_receive_data(struct vmlogrdr_priv_t *priv)\r\n{\r\nint rc, *temp;\r\nint user_data_count, iucv_data_count;\r\nchar * buffer;\r\nif (atomic_read(&priv->receive_ready)) {\r\nspin_lock_bh(&priv->priv_lock);\r\nif (priv->residual_length){\r\niucv_data_count = priv->residual_length;\r\nuser_data_count = 0;\r\nbuffer = priv->buffer;\r\n} else {\r\niucv_data_count = priv->local_interrupt_buffer.length;\r\nuser_data_count = sizeof(int);\r\ntemp = (int*)priv->buffer;\r\n*temp= iucv_data_count + sizeof(FENCE);\r\nbuffer = priv->buffer + sizeof(int);\r\n}\r\nif (iucv_data_count > NET_BUFFER_SIZE)\r\niucv_data_count = NET_BUFFER_SIZE;\r\nrc = iucv_message_receive(priv->path,\r\n&priv->local_interrupt_buffer,\r\n0, buffer, iucv_data_count,\r\n&priv->residual_length);\r\nspin_unlock_bh(&priv->priv_lock);\r\nif (rc == 5)\r\nrc = 0;\r\nif (rc == 9)\r\natomic_set(&priv->receive_ready, 0);\r\n} else {\r\nrc = 1;\r\n}\r\nif (!rc) {\r\npriv->buffer_free = 0;\r\nuser_data_count += iucv_data_count;\r\npriv->current_position = priv->buffer;\r\nif (priv->residual_length == 0){\r\natomic_dec(&priv->receive_ready);\r\nbuffer = priv->buffer + user_data_count;\r\nmemcpy(buffer, FENCE, sizeof(FENCE));\r\nuser_data_count += sizeof(FENCE);\r\n}\r\npriv->remaining = user_data_count;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t vmlogrdr_read(struct file *filp, char __user *data,\r\nsize_t count, loff_t * ppos)\r\n{\r\nint rc;\r\nstruct vmlogrdr_priv_t * priv = filp->private_data;\r\nwhile (priv->buffer_free) {\r\nrc = vmlogrdr_receive_data(priv);\r\nif (rc) {\r\nrc = wait_event_interruptible(read_wait_queue,\r\natomic_read(&priv->receive_ready));\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nif (count > priv->remaining)\r\ncount = priv->remaining;\r\nif (copy_to_user(data, priv->current_position, count))\r\nreturn -EFAULT;\r\n*ppos += count;\r\npriv->current_position += count;\r\npriv->remaining -= count;\r\nif (priv->remaining == 0)\r\npriv->buffer_free = 1;\r\nreturn count;\r\n}\r\nstatic ssize_t vmlogrdr_autopurge_store(struct device * dev,\r\nstruct device_attribute *attr,\r\nconst char * buf, size_t count)\r\n{\r\nstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\r\nssize_t ret = count;\r\nswitch (buf[0]) {\r\ncase '0':\r\npriv->autopurge=0;\r\nbreak;\r\ncase '1':\r\npriv->autopurge=1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t vmlogrdr_autopurge_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", priv->autopurge);\r\n}\r\nstatic ssize_t vmlogrdr_purge_store(struct device * dev,\r\nstruct device_attribute *attr,\r\nconst char * buf, size_t count)\r\n{\r\nchar cp_command[80];\r\nchar cp_response[80];\r\nstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\r\nif (buf[0] != '1')\r\nreturn -EINVAL;\r\nmemset(cp_command, 0x00, sizeof(cp_command));\r\nmemset(cp_response, 0x00, sizeof(cp_response));\r\nif (recording_class_AB)\r\nsnprintf(cp_command, sizeof(cp_command),\r\n"RECORDING %s PURGE QID * ",\r\npriv->recording_name);\r\nelse\r\nsnprintf(cp_command, sizeof(cp_command),\r\n"RECORDING %s PURGE ",\r\npriv->recording_name);\r\ncpcmd(cp_command, cp_response, sizeof(cp_response), NULL);\r\nreturn count;\r\n}\r\nstatic ssize_t vmlogrdr_autorecording_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\r\nssize_t ret = count;\r\nswitch (buf[0]) {\r\ncase '0':\r\npriv->autorecording=0;\r\nbreak;\r\ncase '1':\r\npriv->autorecording=1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t vmlogrdr_autorecording_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", priv->autorecording);\r\n}\r\nstatic ssize_t vmlogrdr_recording_store(struct device * dev,\r\nstruct device_attribute *attr,\r\nconst char * buf, size_t count)\r\n{\r\nstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\r\nssize_t ret;\r\nswitch (buf[0]) {\r\ncase '0':\r\nret = vmlogrdr_recording(priv,0,0);\r\nbreak;\r\ncase '1':\r\nret = vmlogrdr_recording(priv,1,0);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn count;\r\n}\r\nstatic ssize_t vmlogrdr_recording_status_show(struct device_driver *driver,\r\nchar *buf)\r\n{\r\nstatic const char cp_command[] = "QUERY RECORDING ";\r\nint len;\r\ncpcmd(cp_command, buf, 4096, NULL);\r\nlen = strlen(buf);\r\nreturn len;\r\n}\r\nstatic int vmlogrdr_pm_prepare(struct device *dev)\r\n{\r\nint rc;\r\nstruct vmlogrdr_priv_t *priv = dev_get_drvdata(dev);\r\nrc = 0;\r\nif (priv) {\r\nspin_lock_bh(&priv->priv_lock);\r\nif (priv->dev_in_use)\r\nrc = -EBUSY;\r\nspin_unlock_bh(&priv->priv_lock);\r\n}\r\nif (rc)\r\npr_err("vmlogrdr: device %s is busy. Refuse to suspend.\n",\r\ndev_name(dev));\r\nreturn rc;\r\n}\r\nstatic int vmlogrdr_register_driver(void)\r\n{\r\nint ret;\r\nret = iucv_register(&vmlogrdr_iucv_handler, 1);\r\nif (ret)\r\ngoto out;\r\nret = driver_register(&vmlogrdr_driver);\r\nif (ret)\r\ngoto out_iucv;\r\nvmlogrdr_class = class_create(THIS_MODULE, "vmlogrdr");\r\nif (IS_ERR(vmlogrdr_class)) {\r\nret = PTR_ERR(vmlogrdr_class);\r\nvmlogrdr_class = NULL;\r\ngoto out_driver;\r\n}\r\nreturn 0;\r\nout_driver:\r\ndriver_unregister(&vmlogrdr_driver);\r\nout_iucv:\r\niucv_unregister(&vmlogrdr_iucv_handler, 1);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void vmlogrdr_unregister_driver(void)\r\n{\r\nclass_destroy(vmlogrdr_class);\r\nvmlogrdr_class = NULL;\r\ndriver_unregister(&vmlogrdr_driver);\r\niucv_unregister(&vmlogrdr_iucv_handler, 1);\r\n}\r\nstatic int vmlogrdr_register_device(struct vmlogrdr_priv_t *priv)\r\n{\r\nstruct device *dev;\r\nint ret;\r\ndev = kzalloc(sizeof(struct device), GFP_KERNEL);\r\nif (dev) {\r\ndev_set_name(dev, priv->internal_name);\r\ndev->bus = &iucv_bus;\r\ndev->parent = iucv_root;\r\ndev->driver = &vmlogrdr_driver;\r\ndev->groups = vmlogrdr_attr_groups;\r\ndev_set_drvdata(dev, priv);\r\ndev->release = (void (*)(struct device *))kfree;\r\n} else\r\nreturn -ENOMEM;\r\nret = device_register(dev);\r\nif (ret) {\r\nput_device(dev);\r\nreturn ret;\r\n}\r\npriv->class_device = device_create(vmlogrdr_class, dev,\r\nMKDEV(vmlogrdr_major,\r\npriv->minor_num),\r\npriv, "%s", dev_name(dev));\r\nif (IS_ERR(priv->class_device)) {\r\nret = PTR_ERR(priv->class_device);\r\npriv->class_device=NULL;\r\ndevice_unregister(dev);\r\nreturn ret;\r\n}\r\npriv->device = dev;\r\nreturn 0;\r\n}\r\nstatic int vmlogrdr_unregister_device(struct vmlogrdr_priv_t *priv)\r\n{\r\ndevice_destroy(vmlogrdr_class, MKDEV(vmlogrdr_major, priv->minor_num));\r\nif (priv->device != NULL) {\r\ndevice_unregister(priv->device);\r\npriv->device=NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmlogrdr_register_cdev(dev_t dev)\r\n{\r\nint rc = 0;\r\nvmlogrdr_cdev = cdev_alloc();\r\nif (!vmlogrdr_cdev) {\r\nreturn -ENOMEM;\r\n}\r\nvmlogrdr_cdev->owner = THIS_MODULE;\r\nvmlogrdr_cdev->ops = &vmlogrdr_fops;\r\nvmlogrdr_cdev->dev = dev;\r\nrc = cdev_add(vmlogrdr_cdev, vmlogrdr_cdev->dev, MAXMINOR);\r\nif (!rc)\r\nreturn 0;\r\nkobject_put(&vmlogrdr_cdev->kobj);\r\nvmlogrdr_cdev=NULL;\r\nreturn rc;\r\n}\r\nstatic void vmlogrdr_cleanup(void)\r\n{\r\nint i;\r\nif (vmlogrdr_cdev) {\r\ncdev_del(vmlogrdr_cdev);\r\nvmlogrdr_cdev=NULL;\r\n}\r\nfor (i=0; i < MAXMINOR; ++i ) {\r\nvmlogrdr_unregister_device(&sys_ser[i]);\r\nfree_page((unsigned long)sys_ser[i].buffer);\r\n}\r\nvmlogrdr_unregister_driver();\r\nif (vmlogrdr_major) {\r\nunregister_chrdev_region(MKDEV(vmlogrdr_major, 0), MAXMINOR);\r\nvmlogrdr_major=0;\r\n}\r\n}\r\nstatic int __init vmlogrdr_init(void)\r\n{\r\nint rc;\r\nint i;\r\ndev_t dev;\r\nif (! MACHINE_IS_VM) {\r\npr_err("not running under VM, driver not loaded.\n");\r\nreturn -ENODEV;\r\n}\r\nrecording_class_AB = vmlogrdr_get_recording_class_AB();\r\nrc = alloc_chrdev_region(&dev, 0, MAXMINOR, "vmlogrdr");\r\nif (rc)\r\nreturn rc;\r\nvmlogrdr_major = MAJOR(dev);\r\nrc=vmlogrdr_register_driver();\r\nif (rc)\r\ngoto cleanup;\r\nfor (i=0; i < MAXMINOR; ++i ) {\r\nsys_ser[i].buffer = (char *) get_zeroed_page(GFP_KERNEL);\r\nif (!sys_ser[i].buffer) {\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nsys_ser[i].current_position = sys_ser[i].buffer;\r\nrc=vmlogrdr_register_device(&sys_ser[i]);\r\nif (rc)\r\nbreak;\r\n}\r\nif (rc)\r\ngoto cleanup;\r\nrc = vmlogrdr_register_cdev(dev);\r\nif (rc)\r\ngoto cleanup;\r\nreturn 0;\r\ncleanup:\r\nvmlogrdr_cleanup();\r\nreturn rc;\r\n}\r\nstatic void __exit vmlogrdr_exit(void)\r\n{\r\nvmlogrdr_cleanup();\r\nreturn;\r\n}
