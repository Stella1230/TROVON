static inline int is_pen_down(struct da9034_touch *touch)\r\n{\r\nreturn da903x_query_status(touch->da9034_dev, DA9034_STATUS_PEN_DOWN);\r\n}\r\nstatic inline int detect_pen_down(struct da9034_touch *touch, int on)\r\n{\r\nif (on)\r\nreturn da903x_set_bits(touch->da9034_dev,\r\nDA9034_AUTO_CTRL2, DA9034_PEN_DETECT);\r\nelse\r\nreturn da903x_clr_bits(touch->da9034_dev,\r\nDA9034_AUTO_CTRL2, DA9034_PEN_DETECT);\r\n}\r\nstatic int read_tsi(struct da9034_touch *touch)\r\n{\r\nuint8_t _x, _y, _v;\r\nint ret;\r\nret = da903x_read(touch->da9034_dev, DA9034_TSI_X_MSB, &_x);\r\nif (ret)\r\nreturn ret;\r\nret = da903x_read(touch->da9034_dev, DA9034_TSI_Y_MSB, &_y);\r\nif (ret)\r\nreturn ret;\r\nret = da903x_read(touch->da9034_dev, DA9034_TSI_XY_LSB, &_v);\r\nif (ret)\r\nreturn ret;\r\ntouch->last_x = ((_x << 2) & 0x3fc) | (_v & 0x3);\r\ntouch->last_y = ((_y << 2) & 0x3fc) | ((_v & 0xc) >> 2);\r\nreturn 0;\r\n}\r\nstatic inline int start_tsi(struct da9034_touch *touch)\r\n{\r\nreturn da903x_set_bits(touch->da9034_dev,\r\nDA9034_AUTO_CTRL2, DA9034_AUTO_TSI_EN);\r\n}\r\nstatic inline int stop_tsi(struct da9034_touch *touch)\r\n{\r\nreturn da903x_clr_bits(touch->da9034_dev,\r\nDA9034_AUTO_CTRL2, DA9034_AUTO_TSI_EN);\r\n}\r\nstatic inline void report_pen_down(struct da9034_touch *touch)\r\n{\r\nint x = touch->last_x;\r\nint y = touch->last_y;\r\nx &= 0xfff;\r\nif (touch->x_inverted)\r\nx = 1024 - x;\r\ny &= 0xfff;\r\nif (touch->y_inverted)\r\ny = 1024 - y;\r\ninput_report_abs(touch->input_dev, ABS_X, x);\r\ninput_report_abs(touch->input_dev, ABS_Y, y);\r\ninput_report_key(touch->input_dev, BTN_TOUCH, 1);\r\ninput_sync(touch->input_dev);\r\n}\r\nstatic inline void report_pen_up(struct da9034_touch *touch)\r\n{\r\ninput_report_key(touch->input_dev, BTN_TOUCH, 0);\r\ninput_sync(touch->input_dev);\r\n}\r\nstatic void da9034_event_handler(struct da9034_touch *touch, int event)\r\n{\r\nint err;\r\nswitch (touch->state) {\r\ncase STATE_IDLE:\r\nif (event != EVENT_PEN_DOWN)\r\nbreak;\r\nerr = start_tsi(touch);\r\nif (err)\r\ngoto err_reset;\r\ntouch->state = STATE_BUSY;\r\nbreak;\r\ncase STATE_BUSY:\r\nif (event != EVENT_TSI_READY)\r\nbreak;\r\nerr = read_tsi(touch);\r\nif (err)\r\ngoto err_reset;\r\nerr = stop_tsi(touch);\r\nif (err)\r\ngoto err_reset;\r\ntouch->state = STATE_STOP;\r\nmdelay(1);\r\nda9034_event_handler(touch,\r\nis_pen_down(touch) ? EVENT_PEN_DOWN :\r\nEVENT_PEN_UP);\r\nbreak;\r\ncase STATE_STOP:\r\nif (event == EVENT_PEN_DOWN) {\r\nreport_pen_down(touch);\r\nschedule_delayed_work(&touch->tsi_work,\r\nmsecs_to_jiffies(touch->interval_ms));\r\ntouch->state = STATE_WAIT;\r\n}\r\nif (event == EVENT_PEN_UP) {\r\nreport_pen_up(touch);\r\ntouch->state = STATE_IDLE;\r\n}\r\nbreak;\r\ncase STATE_WAIT:\r\nif (event != EVENT_TIMEDOUT)\r\nbreak;\r\nif (is_pen_down(touch)) {\r\nstart_tsi(touch);\r\ntouch->state = STATE_BUSY;\r\n} else {\r\nreport_pen_up(touch);\r\ntouch->state = STATE_IDLE;\r\n}\r\nbreak;\r\n}\r\nreturn;\r\nerr_reset:\r\ntouch->state = STATE_IDLE;\r\nstop_tsi(touch);\r\ndetect_pen_down(touch, 1);\r\n}\r\nstatic void da9034_tsi_work(struct work_struct *work)\r\n{\r\nstruct da9034_touch *touch =\r\ncontainer_of(work, struct da9034_touch, tsi_work.work);\r\nda9034_event_handler(touch, EVENT_TIMEDOUT);\r\n}\r\nstatic int da9034_touch_notifier(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct da9034_touch *touch =\r\ncontainer_of(nb, struct da9034_touch, notifier);\r\nif (event & DA9034_EVENT_TSI_READY)\r\nda9034_event_handler(touch, EVENT_TSI_READY);\r\nif ((event & DA9034_EVENT_PEN_DOWN) && touch->state == STATE_IDLE)\r\nda9034_event_handler(touch, EVENT_PEN_DOWN);\r\nreturn 0;\r\n}\r\nstatic int da9034_touch_open(struct input_dev *dev)\r\n{\r\nstruct da9034_touch *touch = input_get_drvdata(dev);\r\nint ret;\r\nret = da903x_register_notifier(touch->da9034_dev, &touch->notifier,\r\nDA9034_EVENT_PEN_DOWN | DA9034_EVENT_TSI_READY);\r\nif (ret)\r\nreturn -EBUSY;\r\nret = da903x_set_bits(touch->da9034_dev,\r\nDA9034_MANUAL_CTRL, DA9034_LDO_ADC_EN);\r\nif (ret)\r\nreturn ret;\r\nret = da903x_write(touch->da9034_dev, DA9034_TSI_CTRL1, 0x1b);\r\nif (ret)\r\nreturn ret;\r\nret = da903x_write(touch->da9034_dev, DA9034_TSI_CTRL2, 0x00);\r\nif (ret)\r\nreturn ret;\r\ntouch->state = STATE_IDLE;\r\ndetect_pen_down(touch, 1);\r\nreturn 0;\r\n}\r\nstatic void da9034_touch_close(struct input_dev *dev)\r\n{\r\nstruct da9034_touch *touch = input_get_drvdata(dev);\r\nda903x_unregister_notifier(touch->da9034_dev, &touch->notifier,\r\nDA9034_EVENT_PEN_DOWN | DA9034_EVENT_TSI_READY);\r\ncancel_delayed_work_sync(&touch->tsi_work);\r\ntouch->state = STATE_IDLE;\r\nstop_tsi(touch);\r\ndetect_pen_down(touch, 0);\r\nda903x_clr_bits(touch->da9034_dev,\r\nDA9034_MANUAL_CTRL, DA9034_LDO_ADC_EN);\r\n}\r\nstatic int da9034_touch_probe(struct platform_device *pdev)\r\n{\r\nstruct da9034_touch_pdata *pdata = pdev->dev.platform_data;\r\nstruct da9034_touch *touch;\r\nstruct input_dev *input_dev;\r\nint ret;\r\ntouch = kzalloc(sizeof(struct da9034_touch), GFP_KERNEL);\r\nif (touch == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ntouch->da9034_dev = pdev->dev.parent;\r\nif (pdata) {\r\ntouch->interval_ms = pdata->interval_ms;\r\ntouch->x_inverted = pdata->x_inverted;\r\ntouch->y_inverted = pdata->y_inverted;\r\n} else\r\ntouch->interval_ms = 10;\r\nINIT_DELAYED_WORK(&touch->tsi_work, da9034_tsi_work);\r\ntouch->notifier.notifier_call = da9034_touch_notifier;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nret = -ENOMEM;\r\ngoto err_free_touch;\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->open = da9034_touch_open;\r\ninput_dev->close = da9034_touch_close;\r\ninput_dev->dev.parent = &pdev->dev;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(ABS_X, input_dev->absbit);\r\n__set_bit(ABS_Y, input_dev->absbit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, 1023, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, 1023, 0, 0);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ntouch->input_dev = input_dev;\r\ninput_set_drvdata(input_dev, touch);\r\nret = input_register_device(input_dev);\r\nif (ret)\r\ngoto err_free_input;\r\nplatform_set_drvdata(pdev, touch);\r\nreturn 0;\r\nerr_free_input:\r\ninput_free_device(input_dev);\r\nerr_free_touch:\r\nkfree(touch);\r\nreturn ret;\r\n}\r\nstatic int da9034_touch_remove(struct platform_device *pdev)\r\n{\r\nstruct da9034_touch *touch = platform_get_drvdata(pdev);\r\ninput_unregister_device(touch->input_dev);\r\nkfree(touch);\r\nreturn 0;\r\n}
