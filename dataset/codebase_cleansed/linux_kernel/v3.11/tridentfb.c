static inline int is_oldclock(int id)\r\n{\r\nreturn (id == TGUI9440) ||\r\n(id == TGUI9660) ||\r\n(id == CYBER9320);\r\n}\r\nstatic inline int is_oldprotect(int id)\r\n{\r\nreturn is_oldclock(id) ||\r\n(id == PROVIDIA9685) ||\r\n(id == CYBER9382) ||\r\n(id == CYBER9385);\r\n}\r\nstatic inline int is_blade(int id)\r\n{\r\nreturn (id == BLADE3D) ||\r\n(id == CYBERBLADEE4) ||\r\n(id == CYBERBLADEi7) ||\r\n(id == CYBERBLADEi7D) ||\r\n(id == CYBERBLADEi1) ||\r\n(id == CYBERBLADEi1D) ||\r\n(id == CYBERBLADEAi1) ||\r\n(id == CYBERBLADEAi1D);\r\n}\r\nstatic inline int is_xp(int id)\r\n{\r\nreturn (id == CYBERBLADEXPAi1) ||\r\n(id == CYBERBLADEXPm8) ||\r\n(id == CYBERBLADEXPm16);\r\n}\r\nstatic inline int is3Dchip(int id)\r\n{\r\nreturn is_blade(id) || is_xp(id) ||\r\n(id == CYBER9397) || (id == CYBER9397DVD) ||\r\n(id == CYBER9520) || (id == CYBER9525DVD) ||\r\n(id == IMAGE975) || (id == IMAGE985);\r\n}\r\nstatic inline int iscyber(int id)\r\n{\r\nswitch (id) {\r\ncase CYBER9388:\r\ncase CYBER9382:\r\ncase CYBER9385:\r\ncase CYBER9397:\r\ncase CYBER9397DVD:\r\ncase CYBER9520:\r\ncase CYBER9525DVD:\r\ncase CYBERBLADEE4:\r\ncase CYBERBLADEi7D:\r\ncase CYBERBLADEi1:\r\ncase CYBERBLADEi1D:\r\ncase CYBERBLADEAi1:\r\ncase CYBERBLADEAi1D:\r\ncase CYBERBLADEXPAi1:\r\nreturn 1;\r\ncase CYBER9320:\r\ncase CYBERBLADEi7:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void t_outb(struct tridentfb_par *p, u8 val, u16 reg)\r\n{\r\nfb_writeb(val, p->io_virt + reg);\r\n}\r\nstatic inline u8 t_inb(struct tridentfb_par *p, u16 reg)\r\n{\r\nreturn fb_readb(p->io_virt + reg);\r\n}\r\nstatic inline void writemmr(struct tridentfb_par *par, u16 r, u32 v)\r\n{\r\nfb_writel(v, par->io_virt + r);\r\n}\r\nstatic inline u32 readmmr(struct tridentfb_par *par, u16 r)\r\n{\r\nreturn fb_readl(par->io_virt + r);\r\n}\r\nstatic void blade_init_accel(struct tridentfb_par *par, int pitch, int bpp)\r\n{\r\nint v1 = (pitch >> 3) << 20;\r\nint tmp = bpp == 24 ? 2 : (bpp >> 4);\r\nint v2 = v1 | (tmp << 29);\r\nwritemmr(par, 0x21C0, v2);\r\nwritemmr(par, 0x21C4, v2);\r\nwritemmr(par, 0x21B8, v2);\r\nwritemmr(par, 0x21BC, v2);\r\nwritemmr(par, 0x21D0, v1);\r\nwritemmr(par, 0x21D4, v1);\r\nwritemmr(par, 0x21C8, v1);\r\nwritemmr(par, 0x21CC, v1);\r\nwritemmr(par, 0x216C, 0);\r\n}\r\nstatic void blade_wait_engine(struct tridentfb_par *par)\r\n{\r\nwhile (readmmr(par, STATUS) & 0xFA800000)\r\ncpu_relax();\r\n}\r\nstatic void blade_fill_rect(struct tridentfb_par *par,\r\nu32 x, u32 y, u32 w, u32 h, u32 c, u32 rop)\r\n{\r\nwritemmr(par, COLOR, c);\r\nwritemmr(par, ROP, rop ? ROP_X : ROP_S);\r\nwritemmr(par, CMD, 0x20000000 | 1 << 19 | 1 << 4 | 2 << 2);\r\nwritemmr(par, DST1, point(x, y));\r\nwritemmr(par, DST2, point(x + w - 1, y + h - 1));\r\n}\r\nstatic void blade_image_blit(struct tridentfb_par *par, const char *data,\r\nu32 x, u32 y, u32 w, u32 h, u32 c, u32 b)\r\n{\r\nunsigned size = ((w + 31) >> 5) * h;\r\nwritemmr(par, COLOR, c);\r\nwritemmr(par, BGCOLOR, b);\r\nwritemmr(par, CMD, 0xa0000000 | 3 << 19);\r\nwritemmr(par, DST1, point(x, y));\r\nwritemmr(par, DST2, point(x + w - 1, y + h - 1));\r\nmemcpy(par->io_virt + 0x10000, data, 4 * size);\r\n}\r\nstatic void blade_copy_rect(struct tridentfb_par *par,\r\nu32 x1, u32 y1, u32 x2, u32 y2, u32 w, u32 h)\r\n{\r\nint direction = 2;\r\nu32 s1 = point(x1, y1);\r\nu32 s2 = point(x1 + w - 1, y1 + h - 1);\r\nu32 d1 = point(x2, y2);\r\nu32 d2 = point(x2 + w - 1, y2 + h - 1);\r\nif ((y1 > y2) || ((y1 == y2) && (x1 > x2)))\r\ndirection = 0;\r\nwritemmr(par, ROP, ROP_S);\r\nwritemmr(par, CMD, 0xE0000000 | 1 << 19 | 1 << 4 | 1 << 2 | direction);\r\nwritemmr(par, SRC1, direction ? s2 : s1);\r\nwritemmr(par, SRC2, direction ? s1 : s2);\r\nwritemmr(par, DST1, direction ? d2 : d1);\r\nwritemmr(par, DST2, direction ? d1 : d2);\r\n}\r\nstatic void xp_init_accel(struct tridentfb_par *par, int pitch, int bpp)\r\n{\r\nunsigned char x = bpp == 24 ? 3 : (bpp >> 4);\r\nint v1 = pitch << (bpp == 24 ? 20 : (18 + x));\r\nswitch (pitch << (bpp >> 3)) {\r\ncase 8192:\r\ncase 512:\r\nx |= 0x00;\r\nbreak;\r\ncase 1024:\r\nx |= 0x04;\r\nbreak;\r\ncase 2048:\r\nx |= 0x08;\r\nbreak;\r\ncase 4096:\r\nx |= 0x0C;\r\nbreak;\r\n}\r\nt_outb(par, x, 0x2125);\r\npar->eng_oper = x | 0x40;\r\nwritemmr(par, 0x2154, v1);\r\nwritemmr(par, 0x2150, v1);\r\nt_outb(par, 3, 0x2126);\r\n}\r\nstatic void xp_wait_engine(struct tridentfb_par *par)\r\n{\r\nint count = 0;\r\nint timeout = 0;\r\nwhile (t_inb(par, STATUS) & 0x80) {\r\ncount++;\r\nif (count == 10000000) {\r\ncount = 9990000;\r\ntimeout++;\r\nif (timeout == 8) {\r\nt_outb(par, 0x00, STATUS);\r\nreturn;\r\n}\r\n}\r\ncpu_relax();\r\n}\r\n}\r\nstatic void xp_fill_rect(struct tridentfb_par *par,\r\nu32 x, u32 y, u32 w, u32 h, u32 c, u32 rop)\r\n{\r\nwritemmr(par, 0x2127, ROP_P);\r\nwritemmr(par, 0x2158, c);\r\nwritemmr(par, DRAWFL, 0x4000);\r\nwritemmr(par, OLDDIM, point(h, w));\r\nwritemmr(par, OLDDST, point(y, x));\r\nt_outb(par, 0x01, OLDCMD);\r\nt_outb(par, par->eng_oper, 0x2125);\r\n}\r\nstatic void xp_copy_rect(struct tridentfb_par *par,\r\nu32 x1, u32 y1, u32 x2, u32 y2, u32 w, u32 h)\r\n{\r\nu32 x1_tmp, x2_tmp, y1_tmp, y2_tmp;\r\nint direction = 0x0004;\r\nif ((x1 < x2) && (y1 == y2)) {\r\ndirection |= 0x0200;\r\nx1_tmp = x1 + w - 1;\r\nx2_tmp = x2 + w - 1;\r\n} else {\r\nx1_tmp = x1;\r\nx2_tmp = x2;\r\n}\r\nif (y1 < y2) {\r\ndirection |= 0x0100;\r\ny1_tmp = y1 + h - 1;\r\ny2_tmp = y2 + h - 1;\r\n} else {\r\ny1_tmp = y1;\r\ny2_tmp = y2;\r\n}\r\nwritemmr(par, DRAWFL, direction);\r\nt_outb(par, ROP_S, 0x2127);\r\nwritemmr(par, OLDSRC, point(y1_tmp, x1_tmp));\r\nwritemmr(par, OLDDST, point(y2_tmp, x2_tmp));\r\nwritemmr(par, OLDDIM, point(h, w));\r\nt_outb(par, 0x01, OLDCMD);\r\n}\r\nstatic void image_init_accel(struct tridentfb_par *par, int pitch, int bpp)\r\n{\r\nint tmp = bpp == 24 ? 2: (bpp >> 4);\r\nwritemmr(par, 0x2120, 0xF0000000);\r\nwritemmr(par, 0x2120, 0x40000000 | tmp);\r\nwritemmr(par, 0x2120, 0x80000000);\r\nwritemmr(par, 0x2144, 0x00000000);\r\nwritemmr(par, 0x2148, 0x00000000);\r\nwritemmr(par, 0x2150, 0x00000000);\r\nwritemmr(par, 0x2154, 0x00000000);\r\nwritemmr(par, 0x2120, 0x60000000 | (pitch << 16) | pitch);\r\nwritemmr(par, 0x216C, 0x00000000);\r\nwritemmr(par, 0x2170, 0x00000000);\r\nwritemmr(par, 0x217C, 0x00000000);\r\nwritemmr(par, 0x2120, 0x10000000);\r\nwritemmr(par, 0x2130, (2047 << 16) | 2047);\r\n}\r\nstatic void image_wait_engine(struct tridentfb_par *par)\r\n{\r\nwhile (readmmr(par, 0x2164) & 0xF0000000)\r\ncpu_relax();\r\n}\r\nstatic void image_fill_rect(struct tridentfb_par *par,\r\nu32 x, u32 y, u32 w, u32 h, u32 c, u32 rop)\r\n{\r\nwritemmr(par, 0x2120, 0x80000000);\r\nwritemmr(par, 0x2120, 0x90000000 | ROP_S);\r\nwritemmr(par, 0x2144, c);\r\nwritemmr(par, DST1, point(x, y));\r\nwritemmr(par, DST2, point(x + w - 1, y + h - 1));\r\nwritemmr(par, 0x2124, 0x80000000 | 3 << 22 | 1 << 10 | 1 << 9);\r\n}\r\nstatic void image_copy_rect(struct tridentfb_par *par,\r\nu32 x1, u32 y1, u32 x2, u32 y2, u32 w, u32 h)\r\n{\r\nint direction = 0x4;\r\nu32 s1 = point(x1, y1);\r\nu32 s2 = point(x1 + w - 1, y1 + h - 1);\r\nu32 d1 = point(x2, y2);\r\nu32 d2 = point(x2 + w - 1, y2 + h - 1);\r\nif ((y1 > y2) || ((y1 == y2) && (x1 > x2)))\r\ndirection = 0;\r\nwritemmr(par, 0x2120, 0x80000000);\r\nwritemmr(par, 0x2120, 0x90000000 | ROP_S);\r\nwritemmr(par, SRC1, direction ? s2 : s1);\r\nwritemmr(par, SRC2, direction ? s1 : s2);\r\nwritemmr(par, DST1, direction ? d2 : d1);\r\nwritemmr(par, DST2, direction ? d1 : d2);\r\nwritemmr(par, 0x2124,\r\n0x80000000 | 1 << 22 | 1 << 10 | 1 << 7 | direction);\r\n}\r\nstatic void tgui_init_accel(struct tridentfb_par *par, int pitch, int bpp)\r\n{\r\nunsigned char x = bpp == 24 ? 3 : (bpp >> 4);\r\nwritemmr(par, 0x2148, 0);\r\nwritemmr(par, 0x214C, point(4095, 2047));\r\nswitch ((pitch * bpp) / 8) {\r\ncase 8192:\r\ncase 512:\r\nx |= 0x00;\r\nbreak;\r\ncase 1024:\r\nx |= 0x04;\r\nbreak;\r\ncase 2048:\r\nx |= 0x08;\r\nbreak;\r\ncase 4096:\r\nx |= 0x0C;\r\nbreak;\r\n}\r\nfb_writew(x, par->io_virt + 0x2122);\r\n}\r\nstatic void tgui_fill_rect(struct tridentfb_par *par,\r\nu32 x, u32 y, u32 w, u32 h, u32 c, u32 rop)\r\n{\r\nt_outb(par, ROP_P, 0x2127);\r\nwritemmr(par, OLDCLR, c);\r\nwritemmr(par, DRAWFL, 0x4020);\r\nwritemmr(par, OLDDIM, point(w - 1, h - 1));\r\nwritemmr(par, OLDDST, point(x, y));\r\nt_outb(par, 1, OLDCMD);\r\n}\r\nstatic void tgui_copy_rect(struct tridentfb_par *par,\r\nu32 x1, u32 y1, u32 x2, u32 y2, u32 w, u32 h)\r\n{\r\nint flags = 0;\r\nu16 x1_tmp, x2_tmp, y1_tmp, y2_tmp;\r\nif ((x1 < x2) && (y1 == y2)) {\r\nflags |= 0x0200;\r\nx1_tmp = x1 + w - 1;\r\nx2_tmp = x2 + w - 1;\r\n} else {\r\nx1_tmp = x1;\r\nx2_tmp = x2;\r\n}\r\nif (y1 < y2) {\r\nflags |= 0x0100;\r\ny1_tmp = y1 + h - 1;\r\ny2_tmp = y2 + h - 1;\r\n} else {\r\ny1_tmp = y1;\r\ny2_tmp = y2;\r\n}\r\nwritemmr(par, DRAWFL, 0x4 | flags);\r\nt_outb(par, ROP_S, 0x2127);\r\nwritemmr(par, OLDSRC, point(x1_tmp, y1_tmp));\r\nwritemmr(par, OLDDST, point(x2_tmp, y2_tmp));\r\nwritemmr(par, OLDDIM, point(w - 1, h - 1));\r\nt_outb(par, 1, OLDCMD);\r\n}\r\nstatic void tridentfb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *fr)\r\n{\r\nstruct tridentfb_par *par = info->par;\r\nint col;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_fillrect(info, fr);\r\nreturn;\r\n}\r\nif (info->var.bits_per_pixel == 8) {\r\ncol = fr->color;\r\ncol |= col << 8;\r\ncol |= col << 16;\r\n} else\r\ncol = ((u32 *)(info->pseudo_palette))[fr->color];\r\npar->wait_engine(par);\r\npar->fill_rect(par, fr->dx, fr->dy, fr->width,\r\nfr->height, col, fr->rop);\r\n}\r\nstatic void tridentfb_imageblit(struct fb_info *info,\r\nconst struct fb_image *img)\r\n{\r\nstruct tridentfb_par *par = info->par;\r\nint col, bgcol;\r\nif ((info->flags & FBINFO_HWACCEL_DISABLED) || img->depth != 1) {\r\ncfb_imageblit(info, img);\r\nreturn;\r\n}\r\nif (info->var.bits_per_pixel == 8) {\r\ncol = img->fg_color;\r\ncol |= col << 8;\r\ncol |= col << 16;\r\nbgcol = img->bg_color;\r\nbgcol |= bgcol << 8;\r\nbgcol |= bgcol << 16;\r\n} else {\r\ncol = ((u32 *)(info->pseudo_palette))[img->fg_color];\r\nbgcol = ((u32 *)(info->pseudo_palette))[img->bg_color];\r\n}\r\npar->wait_engine(par);\r\nif (par->image_blit)\r\npar->image_blit(par, img->data, img->dx, img->dy,\r\nimg->width, img->height, col, bgcol);\r\nelse\r\ncfb_imageblit(info, img);\r\n}\r\nstatic void tridentfb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *ca)\r\n{\r\nstruct tridentfb_par *par = info->par;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_copyarea(info, ca);\r\nreturn;\r\n}\r\npar->wait_engine(par);\r\npar->copy_rect(par, ca->sx, ca->sy, ca->dx, ca->dy,\r\nca->width, ca->height);\r\n}\r\nstatic int tridentfb_sync(struct fb_info *info)\r\n{\r\nstruct tridentfb_par *par = info->par;\r\nif (!(info->flags & FBINFO_HWACCEL_DISABLED))\r\npar->wait_engine(par);\r\nreturn 0;\r\n}\r\nstatic inline unsigned char read3X4(struct tridentfb_par *par, int reg)\r\n{\r\nreturn vga_mm_rcrt(par->io_virt, reg);\r\n}\r\nstatic inline void write3X4(struct tridentfb_par *par, int reg,\r\nunsigned char val)\r\n{\r\nvga_mm_wcrt(par->io_virt, reg, val);\r\n}\r\nstatic inline unsigned char read3CE(struct tridentfb_par *par,\r\nunsigned char reg)\r\n{\r\nreturn vga_mm_rgfx(par->io_virt, reg);\r\n}\r\nstatic inline void writeAttr(struct tridentfb_par *par, int reg,\r\nunsigned char val)\r\n{\r\nfb_readb(par->io_virt + VGA_IS1_RC);\r\nvga_mm_wattr(par->io_virt, reg, val);\r\n}\r\nstatic inline void write3CE(struct tridentfb_par *par, int reg,\r\nunsigned char val)\r\n{\r\nvga_mm_wgfx(par->io_virt, reg, val);\r\n}\r\nstatic void enable_mmio(struct tridentfb_par *par)\r\n{\r\nvga_io_rseq(0x0B);\r\nvga_io_wseq(NewMode1, 0x80);\r\nif (!is_oldprotect(par->chip_id))\r\nvga_io_wseq(Protection, 0x92);\r\noutb(PCIReg, 0x3D4);\r\noutb(inb(0x3D5) | 0x01, 0x3D5);\r\n}\r\nstatic void disable_mmio(struct tridentfb_par *par)\r\n{\r\nvga_mm_rseq(par->io_virt, 0x0B);\r\nvga_mm_wseq(par->io_virt, NewMode1, 0x80);\r\nif (!is_oldprotect(par->chip_id))\r\nvga_mm_wseq(par->io_virt, Protection, 0x92);\r\nt_outb(par, PCIReg, 0x3D4);\r\nt_outb(par, t_inb(par, 0x3D5) & ~0x01, 0x3D5);\r\n}\r\nstatic inline void crtc_unlock(struct tridentfb_par *par)\r\n{\r\nwrite3X4(par, VGA_CRTC_V_SYNC_END,\r\nread3X4(par, VGA_CRTC_V_SYNC_END) & 0x7F);\r\n}\r\nstatic int get_nativex(struct tridentfb_par *par)\r\n{\r\nint x, y, tmp;\r\nif (nativex)\r\nreturn nativex;\r\ntmp = (read3CE(par, VertStretch) >> 4) & 3;\r\nswitch (tmp) {\r\ncase 0:\r\nx = 1280; y = 1024;\r\nbreak;\r\ncase 2:\r\nx = 1024; y = 768;\r\nbreak;\r\ncase 3:\r\nx = 800; y = 600;\r\nbreak;\r\ncase 4:\r\nx = 1400; y = 1050;\r\nbreak;\r\ncase 1:\r\ndefault:\r\nx = 640; y = 480;\r\nbreak;\r\n}\r\noutput("%dx%d flat panel found\n", x, y);\r\nreturn x;\r\n}\r\nstatic inline void set_lwidth(struct tridentfb_par *par, int width)\r\n{\r\nwrite3X4(par, VGA_CRTC_OFFSET, width & 0xFF);\r\nwrite3X4(par, AddColReg,\r\n(read3X4(par, AddColReg) & 0xCF) | ((width & 0x300) >> 4));\r\n}\r\nstatic void screen_stretch(struct tridentfb_par *par)\r\n{\r\nif (par->chip_id != CYBERBLADEXPAi1)\r\nwrite3CE(par, BiosReg, 0);\r\nelse\r\nwrite3CE(par, BiosReg, 8);\r\nwrite3CE(par, VertStretch, (read3CE(par, VertStretch) & 0x7C) | 1);\r\nwrite3CE(par, HorStretch, (read3CE(par, HorStretch) & 0x7C) | 1);\r\n}\r\nstatic inline void screen_center(struct tridentfb_par *par)\r\n{\r\nwrite3CE(par, VertStretch, (read3CE(par, VertStretch) & 0x7C) | 0x80);\r\nwrite3CE(par, HorStretch, (read3CE(par, HorStretch) & 0x7C) | 0x80);\r\n}\r\nstatic void set_screen_start(struct tridentfb_par *par, int base)\r\n{\r\nu8 tmp;\r\nwrite3X4(par, VGA_CRTC_START_LO, base & 0xFF);\r\nwrite3X4(par, VGA_CRTC_START_HI, (base & 0xFF00) >> 8);\r\ntmp = read3X4(par, CRTCModuleTest) & 0xDF;\r\nwrite3X4(par, CRTCModuleTest, tmp | ((base & 0x10000) >> 11));\r\ntmp = read3X4(par, CRTHiOrd) & 0xF8;\r\nwrite3X4(par, CRTHiOrd, tmp | ((base & 0xE0000) >> 17));\r\n}\r\nstatic void set_vclk(struct tridentfb_par *par, unsigned long freq)\r\n{\r\nint m, n, k;\r\nunsigned long fi, d, di;\r\nunsigned char best_m = 0, best_n = 0, best_k = 0;\r\nunsigned char hi, lo;\r\nunsigned char shift = !is_oldclock(par->chip_id) ? 2 : 1;\r\nd = 20000;\r\nfor (k = shift; k >= 0; k--)\r\nfor (m = 1; m < 32; m++) {\r\nn = ((m + 2) << shift) - 8;\r\nfor (n = (n < 0 ? 0 : n); n < 122; n++) {\r\nfi = ((14318l * (n + 8)) / (m + 2)) >> k;\r\ndi = abs(fi - freq);\r\nif (di < d || (di == d && k == best_k)) {\r\nd = di;\r\nbest_n = n;\r\nbest_m = m;\r\nbest_k = k;\r\n}\r\nif (fi > freq)\r\nbreak;\r\n}\r\n}\r\nif (is_oldclock(par->chip_id)) {\r\nlo = best_n | (best_m << 7);\r\nhi = (best_m >> 1) | (best_k << 4);\r\n} else {\r\nlo = best_n;\r\nhi = best_m | (best_k << 6);\r\n}\r\nif (is3Dchip(par->chip_id)) {\r\nvga_mm_wseq(par->io_virt, ClockHigh, hi);\r\nvga_mm_wseq(par->io_virt, ClockLow, lo);\r\n} else {\r\nt_outb(par, lo, 0x43C8);\r\nt_outb(par, hi, 0x43C9);\r\n}\r\ndebug("VCLK = %X %X\n", hi, lo);\r\n}\r\nstatic void set_number_of_lines(struct tridentfb_par *par, int lines)\r\n{\r\nint tmp = read3CE(par, CyberEnhance) & 0x8F;\r\nif (lines > 1024)\r\ntmp |= 0x50;\r\nelse if (lines > 768)\r\ntmp |= 0x30;\r\nelse if (lines > 600)\r\ntmp |= 0x20;\r\nelse if (lines > 480)\r\ntmp |= 0x10;\r\nwrite3CE(par, CyberEnhance, tmp);\r\n}\r\nstatic int is_flatpanel(struct tridentfb_par *par)\r\n{\r\nif (fp)\r\nreturn 1;\r\nif (crt || !iscyber(par->chip_id))\r\nreturn 0;\r\nreturn (read3CE(par, FPConfig) & 0x10) ? 1 : 0;\r\n}\r\nstatic unsigned int get_memsize(struct tridentfb_par *par)\r\n{\r\nunsigned char tmp, tmp2;\r\nunsigned int k;\r\nif (memsize)\r\nk = memsize * Kb;\r\nelse\r\nswitch (par->chip_id) {\r\ncase CYBER9525DVD:\r\nk = 2560 * Kb;\r\nbreak;\r\ndefault:\r\ntmp = read3X4(par, SPR) & 0x0F;\r\nswitch (tmp) {\r\ncase 0x01:\r\nk = 512 * Kb;\r\nbreak;\r\ncase 0x02:\r\nk = 6 * Mb;\r\nbreak;\r\ncase 0x03:\r\nk = 1 * Mb;\r\nbreak;\r\ncase 0x04:\r\nk = 8 * Mb;\r\nbreak;\r\ncase 0x06:\r\nk = 10 * Mb;\r\nbreak;\r\ncase 0x07:\r\nk = 2 * Mb;\r\nbreak;\r\ncase 0x08:\r\nk = 12 * Mb;\r\nbreak;\r\ncase 0x0A:\r\nk = 14 * Mb;\r\nbreak;\r\ncase 0x0C:\r\nk = 16 * Mb;\r\nbreak;\r\ncase 0x0E:\r\ntmp2 = vga_mm_rseq(par->io_virt, 0xC1);\r\nswitch (tmp2) {\r\ncase 0x00:\r\nk = 20 * Mb;\r\nbreak;\r\ncase 0x01:\r\nk = 24 * Mb;\r\nbreak;\r\ncase 0x10:\r\nk = 28 * Mb;\r\nbreak;\r\ncase 0x11:\r\nk = 32 * Mb;\r\nbreak;\r\ndefault:\r\nk = 1 * Mb;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x0F:\r\nk = 4 * Mb;\r\nbreak;\r\ndefault:\r\nk = 1 * Mb;\r\nbreak;\r\n}\r\n}\r\nk -= memdiff * Kb;\r\noutput("framebuffer size = %d Kb\n", k / Kb);\r\nreturn k;\r\n}\r\nstatic int tridentfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct tridentfb_par *par = info->par;\r\nint bpp = var->bits_per_pixel;\r\nint line_length;\r\nint ramdac = 230000;\r\ndebug("enter\n");\r\nif (bpp == 24)\r\nbpp = var->bits_per_pixel = 32;\r\nif (bpp != 8 && bpp != 16 && bpp != 32)\r\nreturn -EINVAL;\r\nif (par->chip_id == TGUI9440 && bpp == 32)\r\nreturn -EINVAL;\r\nif (par->flatpanel && nativex && var->xres > nativex)\r\nreturn -EINVAL;\r\nvar->xres = (var->xres + 7) & ~0x7;\r\nif (var->xres > var->xres_virtual)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres_virtual = var->yres;\r\nif (var->xres_virtual > 4095 || var->yres > 2048)\r\nreturn -EINVAL;\r\nif (var->yres_virtual > 0xffff)\r\nreturn -EINVAL;\r\nline_length = var->xres_virtual * bpp / 8;\r\nif (!is3Dchip(par->chip_id) &&\r\n!(info->flags & FBINFO_HWACCEL_DISABLED)) {\r\nif (line_length <= 512)\r\nvar->xres_virtual = 512 * 8 / bpp;\r\nelse if (line_length <= 1024)\r\nvar->xres_virtual = 1024 * 8 / bpp;\r\nelse if (line_length <= 2048)\r\nvar->xres_virtual = 2048 * 8 / bpp;\r\nelse if (line_length <= 4096)\r\nvar->xres_virtual = 4096 * 8 / bpp;\r\nelse if (line_length <= 8192)\r\nvar->xres_virtual = 8192 * 8 / bpp;\r\nelse\r\nreturn -EINVAL;\r\nline_length = var->xres_virtual * bpp / 8;\r\n}\r\nif (line_length * (var->yres_virtual - var->yres) > (4 << 20))\r\nvar->yres_virtual = ((4 << 20) / line_length) + var->yres;\r\nif (line_length * var->yres_virtual > info->fix.smem_len)\r\nreturn -EINVAL;\r\nswitch (bpp) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (is_xp(par->chip_id))\r\nramdac = 350000;\r\nswitch (par->chip_id) {\r\ncase TGUI9440:\r\nramdac = (bpp >= 16) ? 45000 : 90000;\r\nbreak;\r\ncase CYBER9320:\r\ncase TGUI9660:\r\nramdac = 135000;\r\nbreak;\r\ncase PROVIDIA9685:\r\ncase CYBER9388:\r\ncase CYBER9382:\r\ncase CYBER9385:\r\nramdac = 170000;\r\nbreak;\r\n}\r\nif (bpp == 32)\r\nramdac /= 2;\r\nif (PICOS2KHZ(var->pixclock) > ramdac)\r\nreturn -EINVAL;\r\ndebug("exit\n");\r\nreturn 0;\r\n}\r\nstatic int tridentfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct tridentfb_par *par = info->par;\r\nunsigned int offset;\r\ndebug("enter\n");\r\noffset = (var->xoffset + (var->yoffset * info->var.xres_virtual))\r\n* info->var.bits_per_pixel / 32;\r\nset_screen_start(par, offset);\r\ndebug("exit\n");\r\nreturn 0;\r\n}\r\nstatic inline void shadowmode_on(struct tridentfb_par *par)\r\n{\r\nwrite3CE(par, CyberControl, read3CE(par, CyberControl) | 0x81);\r\n}\r\nstatic inline void shadowmode_off(struct tridentfb_par *par)\r\n{\r\nwrite3CE(par, CyberControl, read3CE(par, CyberControl) & 0x7E);\r\n}\r\nstatic int tridentfb_set_par(struct fb_info *info)\r\n{\r\nstruct tridentfb_par *par = info->par;\r\nu32 htotal, hdispend, hsyncstart, hsyncend, hblankstart, hblankend;\r\nu32 vtotal, vdispend, vsyncstart, vsyncend, vblankstart, vblankend;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint bpp = var->bits_per_pixel;\r\nunsigned char tmp;\r\nunsigned long vclk;\r\ndebug("enter\n");\r\nhdispend = var->xres / 8 - 1;\r\nhsyncstart = (var->xres + var->right_margin) / 8;\r\nhsyncend = (var->xres + var->right_margin + var->hsync_len) / 8;\r\nhtotal = (var->xres + var->left_margin + var->right_margin +\r\nvar->hsync_len) / 8 - 5;\r\nhblankstart = hdispend + 1;\r\nhblankend = htotal + 3;\r\nvdispend = var->yres - 1;\r\nvsyncstart = var->yres + var->lower_margin;\r\nvsyncend = vsyncstart + var->vsync_len;\r\nvtotal = var->upper_margin + vsyncend - 2;\r\nvblankstart = vdispend + 1;\r\nvblankend = vtotal;\r\nif (info->var.vmode & FB_VMODE_INTERLACED) {\r\nvtotal /= 2;\r\nvdispend /= 2;\r\nvsyncstart /= 2;\r\nvsyncend /= 2;\r\nvblankstart /= 2;\r\nvblankend /= 2;\r\n}\r\nenable_mmio(par);\r\ncrtc_unlock(par);\r\nwrite3CE(par, CyberControl, 8);\r\ntmp = 0xEB;\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT)\r\ntmp &= ~0x40;\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT)\r\ntmp &= ~0x80;\r\nif (par->flatpanel && var->xres < nativex) {\r\nt_outb(par, tmp | 0xC0, VGA_MIS_W);\r\nshadowmode_on(par);\r\nif (center)\r\nscreen_center(par);\r\nelse if (stretch)\r\nscreen_stretch(par);\r\n} else {\r\nt_outb(par, tmp, VGA_MIS_W);\r\nwrite3CE(par, CyberControl, 8);\r\n}\r\nwrite3X4(par, VGA_CRTC_V_TOTAL, vtotal & 0xFF);\r\nwrite3X4(par, VGA_CRTC_V_DISP_END, vdispend & 0xFF);\r\nwrite3X4(par, VGA_CRTC_V_SYNC_START, vsyncstart & 0xFF);\r\nwrite3X4(par, VGA_CRTC_V_SYNC_END, (vsyncend & 0x0F));\r\nwrite3X4(par, VGA_CRTC_V_BLANK_START, vblankstart & 0xFF);\r\nwrite3X4(par, VGA_CRTC_V_BLANK_END, vblankend & 0xFF);\r\nwrite3X4(par, VGA_CRTC_H_TOTAL, htotal & 0xFF);\r\nwrite3X4(par, VGA_CRTC_H_DISP, hdispend & 0xFF);\r\nwrite3X4(par, VGA_CRTC_H_SYNC_START, hsyncstart & 0xFF);\r\nwrite3X4(par, VGA_CRTC_H_SYNC_END,\r\n(hsyncend & 0x1F) | ((hblankend & 0x20) << 2));\r\nwrite3X4(par, VGA_CRTC_H_BLANK_START, hblankstart & 0xFF);\r\nwrite3X4(par, VGA_CRTC_H_BLANK_END, hblankend & 0x1F);\r\ntmp = 0x10;\r\nif (vtotal & 0x100) tmp |= 0x01;\r\nif (vdispend & 0x100) tmp |= 0x02;\r\nif (vsyncstart & 0x100) tmp |= 0x04;\r\nif (vblankstart & 0x100) tmp |= 0x08;\r\nif (vtotal & 0x200) tmp |= 0x20;\r\nif (vdispend & 0x200) tmp |= 0x40;\r\nif (vsyncstart & 0x200) tmp |= 0x80;\r\nwrite3X4(par, VGA_CRTC_OVERFLOW, tmp);\r\ntmp = read3X4(par, CRTHiOrd) & 0x07;\r\ntmp |= 0x08;\r\nif (vtotal & 0x400) tmp |= 0x80;\r\nif (vblankstart & 0x400) tmp |= 0x40;\r\nif (vsyncstart & 0x400) tmp |= 0x20;\r\nif (vdispend & 0x400) tmp |= 0x10;\r\nwrite3X4(par, CRTHiOrd, tmp);\r\ntmp = (htotal >> 8) & 0x01;\r\ntmp |= (hdispend >> 7) & 0x02;\r\ntmp |= (hsyncstart >> 5) & 0x08;\r\ntmp |= (hblankstart >> 4) & 0x10;\r\nwrite3X4(par, HorizOverflow, tmp);\r\ntmp = 0x40;\r\nif (vblankstart & 0x200) tmp |= 0x20;\r\nwrite3X4(par, VGA_CRTC_MAX_SCAN, tmp);\r\nwrite3X4(par, VGA_CRTC_LINE_COMPARE, 0xFF);\r\nwrite3X4(par, VGA_CRTC_PRESET_ROW, 0);\r\nwrite3X4(par, VGA_CRTC_MODE, 0xC3);\r\nwrite3X4(par, LinearAddReg, 0x20);\r\ntmp = (info->var.vmode & FB_VMODE_INTERLACED) ? 0x84 : 0x80;\r\nwrite3X4(par, CRTCModuleTest, tmp);\r\ntmp = read3CE(par, MiscIntContReg) & ~0x4;\r\nif (info->var.vmode & FB_VMODE_INTERLACED)\r\ntmp |= 0x4;\r\nwrite3CE(par, MiscIntContReg, tmp);\r\nwrite3X4(par, GraphEngReg, 0x80);\r\nswitch (bpp) {\r\ncase 8:\r\ntmp = 0x00;\r\nbreak;\r\ncase 16:\r\ntmp = 0x05;\r\nbreak;\r\ncase 24:\r\ntmp = 0x29;\r\nbreak;\r\ncase 32:\r\ntmp = 0x09;\r\nbreak;\r\n}\r\nwrite3X4(par, PixelBusReg, tmp);\r\ntmp = read3X4(par, DRAMControl);\r\nif (!is_oldprotect(par->chip_id))\r\ntmp |= 0x10;\r\nif (iscyber(par->chip_id))\r\ntmp |= 0x20;\r\nwrite3X4(par, DRAMControl, tmp);\r\nwrite3X4(par, InterfaceSel, read3X4(par, InterfaceSel) | 0x40);\r\nif (!is_xp(par->chip_id))\r\nwrite3X4(par, Performance, read3X4(par, Performance) | 0x10);\r\nif (par->chip_id != TGUI9440 && par->chip_id != IMAGE975)\r\nwrite3X4(par, PCIReg, read3X4(par, PCIReg) | 0x06);\r\nvga_mm_wseq(par->io_virt, 0, 3);\r\nvga_mm_wseq(par->io_virt, 1, 1);\r\nvga_mm_wseq(par->io_virt, 2, 0x0F);\r\nvga_mm_wseq(par->io_virt, 3, 0);\r\nvga_mm_wseq(par->io_virt, 4, 0x0E);\r\nvclk = PICOS2KHZ(info->var.pixclock);\r\ntmp = read3CE(par, MiscExtFunc) & 0xF0;\r\nif (bpp == 32 || (par->chip_id == TGUI9440 && bpp == 16)) {\r\ntmp |= 8;\r\nvclk *= 2;\r\n}\r\nset_vclk(par, vclk);\r\nwrite3CE(par, MiscExtFunc, tmp | 0x12);\r\nwrite3CE(par, 0x5, 0x40);\r\nwrite3CE(par, 0x6, 0x05);\r\nwrite3CE(par, 0x7, 0x0F);\r\nwriteAttr(par, 0x10, 0x41);\r\nwriteAttr(par, 0x12, 0x0F);\r\nwriteAttr(par, 0x13, 0);\r\nfor (tmp = 0; tmp < 0x10; tmp++)\r\nwriteAttr(par, tmp, tmp);\r\nfb_readb(par->io_virt + VGA_IS1_RC);\r\nt_outb(par, 0x20, VGA_ATT_W);\r\nswitch (bpp) {\r\ncase 8:\r\ntmp = 0;\r\nbreak;\r\ncase 16:\r\ntmp = 0x30;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ntmp = 0xD0;\r\nbreak;\r\n}\r\nt_inb(par, VGA_PEL_IW);\r\nt_inb(par, VGA_PEL_MSK);\r\nt_inb(par, VGA_PEL_MSK);\r\nt_inb(par, VGA_PEL_MSK);\r\nt_inb(par, VGA_PEL_MSK);\r\nt_outb(par, tmp, VGA_PEL_MSK);\r\nt_inb(par, VGA_PEL_IW);\r\nif (par->flatpanel)\r\nset_number_of_lines(par, info->var.yres);\r\ninfo->fix.line_length = info->var.xres_virtual * bpp / 8;\r\nset_lwidth(par, info->fix.line_length / 8);\r\nif (!(info->flags & FBINFO_HWACCEL_DISABLED))\r\npar->init_accel(par, info->var.xres_virtual, bpp);\r\ninfo->fix.visual = (bpp == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\ninfo->cmap.len = (bpp == 8) ? 256 : 16;\r\ndebug("exit\n");\r\nreturn 0;\r\n}\r\nstatic int tridentfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nint bpp = info->var.bits_per_pixel;\r\nstruct tridentfb_par *par = info->par;\r\nif (regno >= info->cmap.len)\r\nreturn 1;\r\nif (bpp == 8) {\r\nt_outb(par, 0xFF, VGA_PEL_MSK);\r\nt_outb(par, regno, VGA_PEL_IW);\r\nt_outb(par, red >> 10, VGA_PEL_D);\r\nt_outb(par, green >> 10, VGA_PEL_D);\r\nt_outb(par, blue >> 10, VGA_PEL_D);\r\n} else if (regno < 16) {\r\nif (bpp == 16) {\r\nu32 col;\r\ncol = (red & 0xF800) | ((green & 0xFC00) >> 5) |\r\n((blue & 0xF800) >> 11);\r\ncol |= col << 16;\r\n((u32 *)(info->pseudo_palette))[regno] = col;\r\n} else if (bpp == 32)\r\n((u32 *)info->pseudo_palette)[regno] =\r\n((transp & 0xFF00) << 16) |\r\n((red & 0xFF00) << 8) |\r\n((green & 0xFF00)) |\r\n((blue & 0xFF00) >> 8);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tridentfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nunsigned char PMCont, DPMSCont;\r\nstruct tridentfb_par *par = info->par;\r\ndebug("enter\n");\r\nif (par->flatpanel)\r\nreturn 0;\r\nt_outb(par, 0x04, 0x83C8);\r\nPMCont = t_inb(par, 0x83C6) & 0xFC;\r\nDPMSCont = read3CE(par, PowerStatus) & 0xFC;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nPMCont |= 0x03;\r\nDPMSCont |= 0x00;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nPMCont |= 0x02;\r\nDPMSCont |= 0x01;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nPMCont |= 0x02;\r\nDPMSCont |= 0x02;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nPMCont |= 0x00;\r\nDPMSCont |= 0x03;\r\nbreak;\r\n}\r\nwrite3CE(par, PowerStatus, DPMSCont);\r\nt_outb(par, 4, 0x83C8);\r\nt_outb(par, PMCont, 0x83C6);\r\ndebug("exit\n");\r\nreturn (blank_mode == FB_BLANK_NORMAL) ? 1 : 0;\r\n}\r\nstatic int trident_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint err;\r\nunsigned char revision;\r\nstruct fb_info *info;\r\nstruct tridentfb_par *default_par;\r\nint chip3D;\r\nint chip_id;\r\nerr = pci_enable_device(dev);\r\nif (err)\r\nreturn err;\r\ninfo = framebuffer_alloc(sizeof(struct tridentfb_par), &dev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\ndefault_par = info->par;\r\nchip_id = id->device;\r\nif (chip_id == TGUI9660) {\r\nrevision = vga_io_rseq(RevisionID);\r\nswitch (revision) {\r\ncase 0x21:\r\nchip_id = PROVIDIA9685;\r\nbreak;\r\ncase 0x22:\r\ncase 0x23:\r\nchip_id = CYBER9397;\r\nbreak;\r\ncase 0x2A:\r\nchip_id = CYBER9397DVD;\r\nbreak;\r\ncase 0x30:\r\ncase 0x33:\r\ncase 0x34:\r\ncase 0x35:\r\ncase 0x38:\r\ncase 0x3A:\r\ncase 0xB3:\r\nchip_id = CYBER9385;\r\nbreak;\r\ncase 0x40 ... 0x43:\r\nchip_id = CYBER9382;\r\nbreak;\r\ncase 0x4A:\r\nchip_id = CYBER9388;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nchip3D = is3Dchip(chip_id);\r\nif (is_xp(chip_id)) {\r\ndefault_par->init_accel = xp_init_accel;\r\ndefault_par->wait_engine = xp_wait_engine;\r\ndefault_par->fill_rect = xp_fill_rect;\r\ndefault_par->copy_rect = xp_copy_rect;\r\ntridentfb_fix.accel = FB_ACCEL_TRIDENT_BLADEXP;\r\n} else if (is_blade(chip_id)) {\r\ndefault_par->init_accel = blade_init_accel;\r\ndefault_par->wait_engine = blade_wait_engine;\r\ndefault_par->fill_rect = blade_fill_rect;\r\ndefault_par->copy_rect = blade_copy_rect;\r\ndefault_par->image_blit = blade_image_blit;\r\ntridentfb_fix.accel = FB_ACCEL_TRIDENT_BLADE3D;\r\n} else if (chip3D) {\r\ndefault_par->init_accel = image_init_accel;\r\ndefault_par->wait_engine = image_wait_engine;\r\ndefault_par->fill_rect = image_fill_rect;\r\ndefault_par->copy_rect = image_copy_rect;\r\ntridentfb_fix.accel = FB_ACCEL_TRIDENT_3DIMAGE;\r\n} else {\r\ndefault_par->init_accel = tgui_init_accel;\r\ndefault_par->wait_engine = xp_wait_engine;\r\ndefault_par->fill_rect = tgui_fill_rect;\r\ndefault_par->copy_rect = tgui_copy_rect;\r\ntridentfb_fix.accel = FB_ACCEL_TRIDENT_TGUI;\r\n}\r\ndefault_par->chip_id = chip_id;\r\ntridentfb_fix.mmio_start = pci_resource_start(dev, 1);\r\ntridentfb_fix.mmio_len = pci_resource_len(dev, 1);\r\nif (!request_mem_region(tridentfb_fix.mmio_start,\r\ntridentfb_fix.mmio_len, "tridentfb")) {\r\ndebug("request_region failed!\n");\r\nframebuffer_release(info);\r\nreturn -1;\r\n}\r\ndefault_par->io_virt = ioremap_nocache(tridentfb_fix.mmio_start,\r\ntridentfb_fix.mmio_len);\r\nif (!default_par->io_virt) {\r\ndebug("ioremap failed\n");\r\nerr = -1;\r\ngoto out_unmap1;\r\n}\r\nenable_mmio(default_par);\r\ntridentfb_fix.smem_start = pci_resource_start(dev, 0);\r\ntridentfb_fix.smem_len = get_memsize(default_par);\r\nif (!request_mem_region(tridentfb_fix.smem_start,\r\ntridentfb_fix.smem_len, "tridentfb")) {\r\ndebug("request_mem_region failed!\n");\r\ndisable_mmio(info->par);\r\nerr = -1;\r\ngoto out_unmap1;\r\n}\r\ninfo->screen_base = ioremap_nocache(tridentfb_fix.smem_start,\r\ntridentfb_fix.smem_len);\r\nif (!info->screen_base) {\r\ndebug("ioremap failed\n");\r\nerr = -1;\r\ngoto out_unmap2;\r\n}\r\ndefault_par->flatpanel = is_flatpanel(default_par);\r\nif (default_par->flatpanel)\r\nnativex = get_nativex(default_par);\r\ninfo->fix = tridentfb_fix;\r\ninfo->fbops = &tridentfb_ops;\r\ninfo->pseudo_palette = default_par->pseudo_pal;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\nif (!noaccel && default_par->init_accel) {\r\ninfo->flags &= ~FBINFO_HWACCEL_DISABLED;\r\ninfo->flags |= FBINFO_HWACCEL_COPYAREA;\r\ninfo->flags |= FBINFO_HWACCEL_FILLRECT;\r\n} else\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\nif (is_blade(chip_id) && chip_id != BLADE3D)\r\ninfo->flags |= FBINFO_READS_FAST;\r\ninfo->pixmap.addr = kmalloc(4096, GFP_KERNEL);\r\nif (!info->pixmap.addr) {\r\nerr = -ENOMEM;\r\ngoto out_unmap2;\r\n}\r\ninfo->pixmap.size = 4096;\r\ninfo->pixmap.buf_align = 4;\r\ninfo->pixmap.scan_align = 1;\r\ninfo->pixmap.access_align = 32;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\nif (default_par->image_blit) {\r\ninfo->flags |= FBINFO_HWACCEL_IMAGEBLIT;\r\ninfo->pixmap.scan_align = 4;\r\n}\r\nif (noaccel) {\r\nprintk(KERN_DEBUG "disabling acceleration\n");\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\ninfo->pixmap.scan_align = 1;\r\n}\r\nif (!fb_find_mode(&info->var, info,\r\nmode_option, NULL, 0, NULL, bpp)) {\r\nerr = -EINVAL;\r\ngoto out_unmap2;\r\n}\r\nerr = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (err < 0)\r\ngoto out_unmap2;\r\ninfo->var.activate |= FB_ACTIVATE_NOW;\r\ninfo->device = &dev->dev;\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR "tridentfb: could not register framebuffer\n");\r\nfb_dealloc_cmap(&info->cmap);\r\nerr = -EINVAL;\r\ngoto out_unmap2;\r\n}\r\noutput("fb%d: %s frame buffer device %dx%d-%dbpp\n",\r\ninfo->node, info->fix.id, info->var.xres,\r\ninfo->var.yres, info->var.bits_per_pixel);\r\npci_set_drvdata(dev, info);\r\nreturn 0;\r\nout_unmap2:\r\nkfree(info->pixmap.addr);\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nrelease_mem_region(tridentfb_fix.smem_start, tridentfb_fix.smem_len);\r\ndisable_mmio(info->par);\r\nout_unmap1:\r\nif (default_par->io_virt)\r\niounmap(default_par->io_virt);\r\nrelease_mem_region(tridentfb_fix.mmio_start, tridentfb_fix.mmio_len);\r\nframebuffer_release(info);\r\nreturn err;\r\n}\r\nstatic void trident_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct tridentfb_par *par = info->par;\r\nunregister_framebuffer(info);\r\niounmap(par->io_virt);\r\niounmap(info->screen_base);\r\nrelease_mem_region(tridentfb_fix.smem_start, tridentfb_fix.smem_len);\r\nrelease_mem_region(tridentfb_fix.mmio_start, tridentfb_fix.mmio_len);\r\npci_set_drvdata(dev, NULL);\r\nkfree(info->pixmap.addr);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nstatic int __init tridentfb_setup(char *options)\r\n{\r\nchar *opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nif (!strncmp(opt, "noaccel", 7))\r\nnoaccel = 1;\r\nelse if (!strncmp(opt, "fp", 2))\r\nfp = 1;\r\nelse if (!strncmp(opt, "crt", 3))\r\nfp = 0;\r\nelse if (!strncmp(opt, "bpp=", 4))\r\nbpp = simple_strtoul(opt + 4, NULL, 0);\r\nelse if (!strncmp(opt, "center", 6))\r\ncenter = 1;\r\nelse if (!strncmp(opt, "stretch", 7))\r\nstretch = 1;\r\nelse if (!strncmp(opt, "memsize=", 8))\r\nmemsize = simple_strtoul(opt + 8, NULL, 0);\r\nelse if (!strncmp(opt, "memdiff=", 8))\r\nmemdiff = simple_strtoul(opt + 8, NULL, 0);\r\nelse if (!strncmp(opt, "nativex=", 8))\r\nnativex = simple_strtoul(opt + 8, NULL, 0);\r\nelse\r\nmode_option = opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init tridentfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("tridentfb", &option))\r\nreturn -ENODEV;\r\ntridentfb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&tridentfb_pci_driver);\r\n}\r\nstatic void __exit tridentfb_exit(void)\r\n{\r\npci_unregister_driver(&tridentfb_pci_driver);\r\n}
