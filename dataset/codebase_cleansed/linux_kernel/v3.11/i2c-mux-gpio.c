static void i2c_mux_gpio_set(const struct gpiomux *mux, unsigned val)\r\n{\r\nint i;\r\nfor (i = 0; i < mux->data.n_gpios; i++)\r\ngpio_set_value(mux->gpio_base + mux->data.gpios[i],\r\nval & (1 << i));\r\n}\r\nstatic int i2c_mux_gpio_select(struct i2c_adapter *adap, void *data, u32 chan)\r\n{\r\nstruct gpiomux *mux = data;\r\ni2c_mux_gpio_set(mux, mux->data.values[chan]);\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_gpio_deselect(struct i2c_adapter *adap, void *data, u32 chan)\r\n{\r\nstruct gpiomux *mux = data;\r\ni2c_mux_gpio_set(mux, mux->data.idle);\r\nreturn 0;\r\n}\r\nstatic int match_gpio_chip_by_label(struct gpio_chip *chip,\r\nvoid *data)\r\n{\r\nreturn !strcmp(chip->label, data);\r\n}\r\nstatic int i2c_mux_gpio_probe_dt(struct gpiomux *mux,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *adapter_np, *child;\r\nstruct i2c_adapter *adapter;\r\nunsigned *values, *gpios;\r\nint i = 0;\r\nif (!np)\r\nreturn -ENODEV;\r\nadapter_np = of_parse_phandle(np, "i2c-parent", 0);\r\nif (!adapter_np) {\r\ndev_err(&pdev->dev, "Cannot parse i2c-parent\n");\r\nreturn -ENODEV;\r\n}\r\nadapter = of_find_i2c_adapter_by_node(adapter_np);\r\nif (!adapter) {\r\ndev_err(&pdev->dev, "Cannot find parent bus\n");\r\nreturn -ENODEV;\r\n}\r\nmux->data.parent = i2c_adapter_id(adapter);\r\nput_device(&adapter->dev);\r\nmux->data.n_values = of_get_child_count(np);\r\nvalues = devm_kzalloc(&pdev->dev,\r\nsizeof(*mux->data.values) * mux->data.n_values,\r\nGFP_KERNEL);\r\nif (!values) {\r\ndev_err(&pdev->dev, "Cannot allocate values array");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nof_property_read_u32(child, "reg", values + i);\r\ni++;\r\n}\r\nmux->data.values = values;\r\nif (of_property_read_u32(np, "idle-state", &mux->data.idle))\r\nmux->data.idle = I2C_MUX_GPIO_NO_IDLE;\r\nmux->data.n_gpios = of_gpio_named_count(np, "mux-gpios");\r\nif (mux->data.n_gpios < 0) {\r\ndev_err(&pdev->dev, "Missing mux-gpios property in the DT.\n");\r\nreturn -EINVAL;\r\n}\r\ngpios = devm_kzalloc(&pdev->dev,\r\nsizeof(*mux->data.gpios) * mux->data.n_gpios, GFP_KERNEL);\r\nif (!gpios) {\r\ndev_err(&pdev->dev, "Cannot allocate gpios array");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < mux->data.n_gpios; i++)\r\ngpios[i] = of_get_named_gpio(np, "mux-gpios", i);\r\nmux->data.gpios = gpios;\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_gpio_probe_dt(struct gpiomux *mux,\r\nstruct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int i2c_mux_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct gpiomux *mux;\r\nstruct i2c_adapter *parent;\r\nint (*deselect) (struct i2c_adapter *, void *, u32);\r\nunsigned initial_state, gpio_base;\r\nint i, ret;\r\nmux = devm_kzalloc(&pdev->dev, sizeof(*mux), GFP_KERNEL);\r\nif (!mux) {\r\ndev_err(&pdev->dev, "Cannot allocate gpiomux structure");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, mux);\r\nif (!pdev->dev.platform_data) {\r\nret = i2c_mux_gpio_probe_dt(mux, pdev);\r\nif (ret < 0)\r\nreturn ret;\r\n} else\r\nmemcpy(&mux->data, pdev->dev.platform_data, sizeof(mux->data));\r\nif (mux->data.gpio_chip) {\r\nstruct gpio_chip *gpio;\r\ngpio = gpiochip_find(mux->data.gpio_chip,\r\nmatch_gpio_chip_by_label);\r\nif (!gpio)\r\nreturn -EPROBE_DEFER;\r\ngpio_base = gpio->base;\r\n} else {\r\ngpio_base = 0;\r\n}\r\nparent = i2c_get_adapter(mux->data.parent);\r\nif (!parent) {\r\ndev_err(&pdev->dev, "Parent adapter (%d) not found\n",\r\nmux->data.parent);\r\nreturn -ENODEV;\r\n}\r\nmux->parent = parent;\r\nmux->gpio_base = gpio_base;\r\nmux->adap = devm_kzalloc(&pdev->dev,\r\nsizeof(*mux->adap) * mux->data.n_values,\r\nGFP_KERNEL);\r\nif (!mux->adap) {\r\ndev_err(&pdev->dev, "Cannot allocate i2c_adapter structure");\r\nret = -ENOMEM;\r\ngoto alloc_failed;\r\n}\r\nif (mux->data.idle != I2C_MUX_GPIO_NO_IDLE) {\r\ninitial_state = mux->data.idle;\r\ndeselect = i2c_mux_gpio_deselect;\r\n} else {\r\ninitial_state = mux->data.values[0];\r\ndeselect = NULL;\r\n}\r\nfor (i = 0; i < mux->data.n_gpios; i++) {\r\nret = gpio_request(gpio_base + mux->data.gpios[i], "i2c-mux-gpio");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request GPIO %d\n",\r\nmux->data.gpios[i]);\r\ngoto err_request_gpio;\r\n}\r\nret = gpio_direction_output(gpio_base + mux->data.gpios[i],\r\ninitial_state & (1 << i));\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to set direction of GPIO %d to output\n",\r\nmux->data.gpios[i]);\r\ni++;\r\ngoto err_request_gpio;\r\n}\r\n}\r\nfor (i = 0; i < mux->data.n_values; i++) {\r\nu32 nr = mux->data.base_nr ? (mux->data.base_nr + i) : 0;\r\nunsigned int class = mux->data.classes ? mux->data.classes[i] : 0;\r\nmux->adap[i] = i2c_add_mux_adapter(parent, &pdev->dev, mux, nr,\r\ni, class,\r\ni2c_mux_gpio_select, deselect);\r\nif (!mux->adap[i]) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "Failed to add adapter %d\n", i);\r\ngoto add_adapter_failed;\r\n}\r\n}\r\ndev_info(&pdev->dev, "%d port mux on %s adapter\n",\r\nmux->data.n_values, parent->name);\r\nreturn 0;\r\nadd_adapter_failed:\r\nfor (; i > 0; i--)\r\ni2c_del_mux_adapter(mux->adap[i - 1]);\r\ni = mux->data.n_gpios;\r\nerr_request_gpio:\r\nfor (; i > 0; i--)\r\ngpio_free(gpio_base + mux->data.gpios[i - 1]);\r\nalloc_failed:\r\ni2c_put_adapter(parent);\r\nreturn ret;\r\n}\r\nstatic int i2c_mux_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct gpiomux *mux = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < mux->data.n_values; i++)\r\ni2c_del_mux_adapter(mux->adap[i]);\r\nfor (i = 0; i < mux->data.n_gpios; i++)\r\ngpio_free(mux->gpio_base + mux->data.gpios[i]);\r\ni2c_put_adapter(mux->parent);\r\nreturn 0;\r\n}
