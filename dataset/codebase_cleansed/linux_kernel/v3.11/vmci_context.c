static void ctx_signal_notify(struct vmci_ctx *context)\r\n{\r\n*context->notify = true;\r\n}\r\nstatic void ctx_clear_notify(struct vmci_ctx *context)\r\n{\r\n*context->notify = false;\r\n}\r\nstatic void ctx_clear_notify_call(struct vmci_ctx *context)\r\n{\r\nif (context->pending_datagrams == 0 &&\r\nvmci_handle_arr_get_size(context->pending_doorbell_array) == 0)\r\nctx_clear_notify(context);\r\n}\r\nvoid vmci_ctx_check_signal_notify(struct vmci_ctx *context)\r\n{\r\nspin_lock(&context->lock);\r\nif (context->pending_datagrams)\r\nctx_signal_notify(context);\r\nspin_unlock(&context->lock);\r\n}\r\nstruct vmci_ctx *vmci_ctx_create(u32 cid, u32 priv_flags,\r\nuintptr_t event_hnd,\r\nint user_version,\r\nconst struct cred *cred)\r\n{\r\nstruct vmci_ctx *context;\r\nint error;\r\nif (cid == VMCI_INVALID_ID) {\r\npr_devel("Invalid context ID for VMCI context\n");\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (priv_flags & ~VMCI_PRIVILEGE_ALL_FLAGS) {\r\npr_devel("Invalid flag (flags=0x%x) for VMCI context\n",\r\npriv_flags);\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (user_version == 0) {\r\npr_devel("Invalid suer_version %d\n", user_version);\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\ncontext = kzalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context) {\r\npr_warn("Failed to allocate memory for VMCI context\n");\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\nkref_init(&context->kref);\r\nspin_lock_init(&context->lock);\r\nINIT_LIST_HEAD(&context->list_item);\r\nINIT_LIST_HEAD(&context->datagram_queue);\r\nINIT_LIST_HEAD(&context->notifier_list);\r\ninit_waitqueue_head(&context->host_context.wait_queue);\r\ncontext->queue_pair_array = vmci_handle_arr_create(0);\r\nif (!context->queue_pair_array) {\r\nerror = -ENOMEM;\r\ngoto err_free_ctx;\r\n}\r\ncontext->doorbell_array = vmci_handle_arr_create(0);\r\nif (!context->doorbell_array) {\r\nerror = -ENOMEM;\r\ngoto err_free_qp_array;\r\n}\r\ncontext->pending_doorbell_array = vmci_handle_arr_create(0);\r\nif (!context->pending_doorbell_array) {\r\nerror = -ENOMEM;\r\ngoto err_free_db_array;\r\n}\r\ncontext->user_version = user_version;\r\ncontext->priv_flags = priv_flags;\r\nif (cred)\r\ncontext->cred = get_cred(cred);\r\ncontext->notify = &ctx_dummy_notify;\r\ncontext->notify_page = NULL;\r\nspin_lock(&ctx_list.lock);\r\nwhile (vmci_ctx_exists(cid)) {\r\ncid = max(cid, VMCI_RESERVED_CID_LIMIT - 1) + 1;\r\nif (cid == VMCI_INVALID_ID)\r\ncid = VMCI_RESERVED_CID_LIMIT;\r\n}\r\ncontext->cid = cid;\r\nlist_add_tail_rcu(&context->list_item, &ctx_list.head);\r\nspin_unlock(&ctx_list.lock);\r\nreturn context;\r\nerr_free_db_array:\r\nvmci_handle_arr_destroy(context->doorbell_array);\r\nerr_free_qp_array:\r\nvmci_handle_arr_destroy(context->queue_pair_array);\r\nerr_free_ctx:\r\nkfree(context);\r\nerr_out:\r\nreturn ERR_PTR(error);\r\n}\r\nvoid vmci_ctx_destroy(struct vmci_ctx *context)\r\n{\r\nspin_lock(&ctx_list.lock);\r\nlist_del_rcu(&context->list_item);\r\nspin_unlock(&ctx_list.lock);\r\nsynchronize_rcu();\r\nvmci_ctx_put(context);\r\n}\r\nstatic int ctx_fire_notification(u32 context_id, u32 priv_flags)\r\n{\r\nu32 i, array_size;\r\nstruct vmci_ctx *sub_ctx;\r\nstruct vmci_handle_arr *subscriber_array;\r\nstruct vmci_handle context_handle =\r\nvmci_make_handle(context_id, VMCI_EVENT_HANDLER);\r\nsubscriber_array = vmci_handle_arr_create(0);\r\nif (subscriber_array == NULL)\r\nreturn VMCI_ERROR_NO_MEM;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sub_ctx, &ctx_list.head, list_item) {\r\nstruct vmci_handle_list *node;\r\nif (vmci_deny_interaction(priv_flags, sub_ctx->priv_flags))\r\ncontinue;\r\nlist_for_each_entry_rcu(node, &sub_ctx->notifier_list, node) {\r\nif (!vmci_handle_is_equal(node->handle, context_handle))\r\ncontinue;\r\nvmci_handle_arr_append_entry(&subscriber_array,\r\nvmci_make_handle(sub_ctx->cid,\r\nVMCI_EVENT_HANDLER));\r\n}\r\n}\r\nrcu_read_unlock();\r\narray_size = vmci_handle_arr_get_size(subscriber_array);\r\nfor (i = 0; i < array_size; i++) {\r\nint result;\r\nstruct vmci_event_ctx ev;\r\nev.msg.hdr.dst = vmci_handle_arr_get_entry(subscriber_array, i);\r\nev.msg.hdr.src = vmci_make_handle(VMCI_HYPERVISOR_CONTEXT_ID,\r\nVMCI_CONTEXT_RESOURCE_ID);\r\nev.msg.hdr.payload_size = sizeof(ev) - sizeof(ev.msg.hdr);\r\nev.msg.event_data.event = VMCI_EVENT_CTX_REMOVED;\r\nev.payload.context_id = context_id;\r\nresult = vmci_datagram_dispatch(VMCI_HYPERVISOR_CONTEXT_ID,\r\n&ev.msg.hdr, false);\r\nif (result < VMCI_SUCCESS) {\r\npr_devel("Failed to enqueue event datagram (type=%d) for context (ID=0x%x)\n",\r\nev.msg.event_data.event,\r\nev.msg.hdr.dst.context);\r\n}\r\n}\r\nvmci_handle_arr_destroy(subscriber_array);\r\nreturn VMCI_SUCCESS;\r\n}\r\nint vmci_ctx_pending_datagrams(u32 cid, u32 *pending)\r\n{\r\nstruct vmci_ctx *context;\r\ncontext = vmci_ctx_get(cid);\r\nif (context == NULL)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nspin_lock(&context->lock);\r\nif (pending)\r\n*pending = context->pending_datagrams;\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nreturn VMCI_SUCCESS;\r\n}\r\nint vmci_ctx_enqueue_datagram(u32 cid, struct vmci_datagram *dg)\r\n{\r\nstruct vmci_datagram_queue_entry *dq_entry;\r\nstruct vmci_ctx *context;\r\nstruct vmci_handle dg_src;\r\nsize_t vmci_dg_size;\r\nvmci_dg_size = VMCI_DG_SIZE(dg);\r\nif (vmci_dg_size > VMCI_MAX_DG_SIZE) {\r\npr_devel("Datagram too large (bytes=%Zu)\n", vmci_dg_size);\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\n}\r\ncontext = vmci_ctx_get(cid);\r\nif (!context) {\r\npr_devel("Invalid context (ID=0x%x)\n", cid);\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\n}\r\ndq_entry = kmalloc(sizeof(*dq_entry), GFP_KERNEL);\r\nif (dq_entry == NULL) {\r\npr_warn("Failed to allocate memory for datagram\n");\r\nvmci_ctx_put(context);\r\nreturn VMCI_ERROR_NO_MEM;\r\n}\r\ndq_entry->dg = dg;\r\ndq_entry->dg_size = vmci_dg_size;\r\ndg_src = dg->src;\r\nINIT_LIST_HEAD(&dq_entry->list_item);\r\nspin_lock(&context->lock);\r\nif (context->datagram_queue_size + vmci_dg_size >=\r\nVMCI_MAX_DATAGRAM_QUEUE_SIZE &&\r\n(!vmci_handle_is_equal(dg_src,\r\nvmci_make_handle\r\n(VMCI_HYPERVISOR_CONTEXT_ID,\r\nVMCI_CONTEXT_RESOURCE_ID)) ||\r\ncontext->datagram_queue_size + vmci_dg_size >=\r\nVMCI_MAX_DATAGRAM_AND_EVENT_QUEUE_SIZE)) {\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nkfree(dq_entry);\r\npr_devel("Context (ID=0x%x) receive queue is full\n", cid);\r\nreturn VMCI_ERROR_NO_RESOURCES;\r\n}\r\nlist_add(&dq_entry->list_item, &context->datagram_queue);\r\ncontext->pending_datagrams++;\r\ncontext->datagram_queue_size += vmci_dg_size;\r\nctx_signal_notify(context);\r\nwake_up(&context->host_context.wait_queue);\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nreturn vmci_dg_size;\r\n}\r\nbool vmci_ctx_exists(u32 cid)\r\n{\r\nstruct vmci_ctx *context;\r\nbool exists = false;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(context, &ctx_list.head, list_item) {\r\nif (context->cid == cid) {\r\nexists = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn exists;\r\n}\r\nstruct vmci_ctx *vmci_ctx_get(u32 cid)\r\n{\r\nstruct vmci_ctx *c, *context = NULL;\r\nif (cid == VMCI_INVALID_ID)\r\nreturn NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(c, &ctx_list.head, list_item) {\r\nif (c->cid == cid) {\r\ncontext = c;\r\nkref_get(&context->kref);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn context;\r\n}\r\nstatic void ctx_free_ctx(struct kref *kref)\r\n{\r\nstruct vmci_ctx *context = container_of(kref, struct vmci_ctx, kref);\r\nstruct vmci_datagram_queue_entry *dq_entry, *dq_entry_tmp;\r\nstruct vmci_handle temp_handle;\r\nstruct vmci_handle_list *notifier, *tmp;\r\nctx_fire_notification(context->cid, context->priv_flags);\r\ntemp_handle = vmci_handle_arr_get_entry(context->queue_pair_array, 0);\r\nwhile (!vmci_handle_is_equal(temp_handle, VMCI_INVALID_HANDLE)) {\r\nif (vmci_qp_broker_detach(temp_handle,\r\ncontext) < VMCI_SUCCESS) {\r\nvmci_handle_arr_remove_entry(context->queue_pair_array,\r\ntemp_handle);\r\n}\r\ntemp_handle =\r\nvmci_handle_arr_get_entry(context->queue_pair_array, 0);\r\n}\r\nlist_for_each_entry_safe(dq_entry, dq_entry_tmp,\r\n&context->datagram_queue, list_item) {\r\nWARN_ON(dq_entry->dg_size != VMCI_DG_SIZE(dq_entry->dg));\r\nlist_del(&dq_entry->list_item);\r\nkfree(dq_entry->dg);\r\nkfree(dq_entry);\r\n}\r\nlist_for_each_entry_safe(notifier, tmp,\r\n&context->notifier_list, node) {\r\nlist_del(&notifier->node);\r\nkfree(notifier);\r\n}\r\nvmci_handle_arr_destroy(context->queue_pair_array);\r\nvmci_handle_arr_destroy(context->doorbell_array);\r\nvmci_handle_arr_destroy(context->pending_doorbell_array);\r\nvmci_ctx_unset_notify(context);\r\nif (context->cred)\r\nput_cred(context->cred);\r\nkfree(context);\r\n}\r\nvoid vmci_ctx_put(struct vmci_ctx *context)\r\n{\r\nkref_put(&context->kref, ctx_free_ctx);\r\n}\r\nint vmci_ctx_dequeue_datagram(struct vmci_ctx *context,\r\nsize_t *max_size,\r\nstruct vmci_datagram **dg)\r\n{\r\nstruct vmci_datagram_queue_entry *dq_entry;\r\nstruct list_head *list_item;\r\nint rv;\r\nspin_lock(&context->lock);\r\nif (context->pending_datagrams == 0) {\r\nctx_clear_notify_call(context);\r\nspin_unlock(&context->lock);\r\npr_devel("No datagrams pending\n");\r\nreturn VMCI_ERROR_NO_MORE_DATAGRAMS;\r\n}\r\nlist_item = context->datagram_queue.next;\r\ndq_entry =\r\nlist_entry(list_item, struct vmci_datagram_queue_entry, list_item);\r\nif (*max_size < dq_entry->dg_size) {\r\n*max_size = dq_entry->dg_size;\r\nspin_unlock(&context->lock);\r\npr_devel("Caller's buffer should be at least (size=%u bytes)\n",\r\n(u32) *max_size);\r\nreturn VMCI_ERROR_NO_MEM;\r\n}\r\nlist_del(list_item);\r\ncontext->pending_datagrams--;\r\ncontext->datagram_queue_size -= dq_entry->dg_size;\r\nif (context->pending_datagrams == 0) {\r\nctx_clear_notify_call(context);\r\nrv = VMCI_SUCCESS;\r\n} else {\r\nstruct vmci_datagram_queue_entry *next_entry;\r\nlist_item = context->datagram_queue.next;\r\nnext_entry =\r\nlist_entry(list_item, struct vmci_datagram_queue_entry,\r\nlist_item);\r\nrv = (int)next_entry->dg_size;\r\n}\r\nspin_unlock(&context->lock);\r\n*dg = dq_entry->dg;\r\ndq_entry->dg = NULL;\r\nkfree(dq_entry);\r\nreturn rv;\r\n}\r\nvoid vmci_ctx_unset_notify(struct vmci_ctx *context)\r\n{\r\nstruct page *notify_page;\r\nspin_lock(&context->lock);\r\nnotify_page = context->notify_page;\r\ncontext->notify = &ctx_dummy_notify;\r\ncontext->notify_page = NULL;\r\nspin_unlock(&context->lock);\r\nif (notify_page) {\r\nkunmap(notify_page);\r\nput_page(notify_page);\r\n}\r\n}\r\nint vmci_ctx_add_notification(u32 context_id, u32 remote_cid)\r\n{\r\nstruct vmci_ctx *context;\r\nstruct vmci_handle_list *notifier, *n;\r\nint result;\r\nbool exists = false;\r\ncontext = vmci_ctx_get(context_id);\r\nif (!context)\r\nreturn VMCI_ERROR_NOT_FOUND;\r\nif (VMCI_CONTEXT_IS_VM(context_id) && VMCI_CONTEXT_IS_VM(remote_cid)) {\r\npr_devel("Context removed notifications for other VMs not supported (src=0x%x, remote=0x%x)\n",\r\ncontext_id, remote_cid);\r\nresult = VMCI_ERROR_DST_UNREACHABLE;\r\ngoto out;\r\n}\r\nif (context->priv_flags & VMCI_PRIVILEGE_FLAG_RESTRICTED) {\r\nresult = VMCI_ERROR_NO_ACCESS;\r\ngoto out;\r\n}\r\nnotifier = kmalloc(sizeof(struct vmci_handle_list), GFP_KERNEL);\r\nif (!notifier) {\r\nresult = VMCI_ERROR_NO_MEM;\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&notifier->node);\r\nnotifier->handle = vmci_make_handle(remote_cid, VMCI_EVENT_HANDLER);\r\nspin_lock(&context->lock);\r\nlist_for_each_entry(n, &context->notifier_list, node) {\r\nif (vmci_handle_is_equal(n->handle, notifier->handle)) {\r\nexists = true;\r\nbreak;\r\n}\r\n}\r\nif (exists) {\r\nkfree(notifier);\r\nresult = VMCI_ERROR_ALREADY_EXISTS;\r\n} else {\r\nlist_add_tail_rcu(&notifier->node, &context->notifier_list);\r\ncontext->n_notifiers++;\r\nresult = VMCI_SUCCESS;\r\n}\r\nspin_unlock(&context->lock);\r\nout:\r\nvmci_ctx_put(context);\r\nreturn result;\r\n}\r\nint vmci_ctx_remove_notification(u32 context_id, u32 remote_cid)\r\n{\r\nstruct vmci_ctx *context;\r\nstruct vmci_handle_list *notifier, *tmp;\r\nstruct vmci_handle handle;\r\nbool found = false;\r\ncontext = vmci_ctx_get(context_id);\r\nif (!context)\r\nreturn VMCI_ERROR_NOT_FOUND;\r\nhandle = vmci_make_handle(remote_cid, VMCI_EVENT_HANDLER);\r\nspin_lock(&context->lock);\r\nlist_for_each_entry_safe(notifier, tmp,\r\n&context->notifier_list, node) {\r\nif (vmci_handle_is_equal(notifier->handle, handle)) {\r\nlist_del_rcu(&notifier->node);\r\ncontext->n_notifiers--;\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&context->lock);\r\nif (found) {\r\nsynchronize_rcu();\r\nkfree(notifier);\r\n}\r\nvmci_ctx_put(context);\r\nreturn found ? VMCI_SUCCESS : VMCI_ERROR_NOT_FOUND;\r\n}\r\nstatic int vmci_ctx_get_chkpt_notifiers(struct vmci_ctx *context,\r\nu32 *buf_size, void **pbuf)\r\n{\r\nu32 *notifiers;\r\nsize_t data_size;\r\nstruct vmci_handle_list *entry;\r\nint i = 0;\r\nif (context->n_notifiers == 0) {\r\n*buf_size = 0;\r\n*pbuf = NULL;\r\nreturn VMCI_SUCCESS;\r\n}\r\ndata_size = context->n_notifiers * sizeof(*notifiers);\r\nif (*buf_size < data_size) {\r\n*buf_size = data_size;\r\nreturn VMCI_ERROR_MORE_DATA;\r\n}\r\nnotifiers = kmalloc(data_size, GFP_ATOMIC);\r\nif (!notifiers)\r\nreturn VMCI_ERROR_NO_MEM;\r\nlist_for_each_entry(entry, &context->notifier_list, node)\r\nnotifiers[i++] = entry->handle.context;\r\n*buf_size = data_size;\r\n*pbuf = notifiers;\r\nreturn VMCI_SUCCESS;\r\n}\r\nstatic int vmci_ctx_get_chkpt_doorbells(struct vmci_ctx *context,\r\nu32 *buf_size, void **pbuf)\r\n{\r\nstruct dbell_cpt_state *dbells;\r\nsize_t n_doorbells;\r\nint i;\r\nn_doorbells = vmci_handle_arr_get_size(context->doorbell_array);\r\nif (n_doorbells > 0) {\r\nsize_t data_size = n_doorbells * sizeof(*dbells);\r\nif (*buf_size < data_size) {\r\n*buf_size = data_size;\r\nreturn VMCI_ERROR_MORE_DATA;\r\n}\r\ndbells = kmalloc(data_size, GFP_ATOMIC);\r\nif (!dbells)\r\nreturn VMCI_ERROR_NO_MEM;\r\nfor (i = 0; i < n_doorbells; i++)\r\ndbells[i].handle = vmci_handle_arr_get_entry(\r\ncontext->doorbell_array, i);\r\n*buf_size = data_size;\r\n*pbuf = dbells;\r\n} else {\r\n*buf_size = 0;\r\n*pbuf = NULL;\r\n}\r\nreturn VMCI_SUCCESS;\r\n}\r\nint vmci_ctx_get_chkpt_state(u32 context_id,\r\nu32 cpt_type,\r\nu32 *buf_size,\r\nvoid **pbuf)\r\n{\r\nstruct vmci_ctx *context;\r\nint result;\r\ncontext = vmci_ctx_get(context_id);\r\nif (!context)\r\nreturn VMCI_ERROR_NOT_FOUND;\r\nspin_lock(&context->lock);\r\nswitch (cpt_type) {\r\ncase VMCI_NOTIFICATION_CPT_STATE:\r\nresult = vmci_ctx_get_chkpt_notifiers(context, buf_size, pbuf);\r\nbreak;\r\ncase VMCI_WELLKNOWN_CPT_STATE:\r\n*buf_size = 0;\r\n*pbuf = NULL;\r\nresult = VMCI_SUCCESS;\r\nbreak;\r\ncase VMCI_DOORBELL_CPT_STATE:\r\nresult = vmci_ctx_get_chkpt_doorbells(context, buf_size, pbuf);\r\nbreak;\r\ndefault:\r\npr_devel("Invalid cpt state (type=%d)\n", cpt_type);\r\nresult = VMCI_ERROR_INVALID_ARGS;\r\nbreak;\r\n}\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nreturn result;\r\n}\r\nint vmci_ctx_set_chkpt_state(u32 context_id,\r\nu32 cpt_type,\r\nu32 buf_size,\r\nvoid *cpt_buf)\r\n{\r\nu32 i;\r\nu32 current_id;\r\nint result = VMCI_SUCCESS;\r\nu32 num_ids = buf_size / sizeof(u32);\r\nif (cpt_type == VMCI_WELLKNOWN_CPT_STATE && num_ids > 0) {\r\npr_warn("Attempt to restore checkpoint with obsolete wellknown handles\n");\r\nreturn VMCI_ERROR_OBSOLETE;\r\n}\r\nif (cpt_type != VMCI_NOTIFICATION_CPT_STATE) {\r\npr_devel("Invalid cpt state (type=%d)\n", cpt_type);\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\n}\r\nfor (i = 0; i < num_ids && result == VMCI_SUCCESS; i++) {\r\ncurrent_id = ((u32 *)cpt_buf)[i];\r\nresult = vmci_ctx_add_notification(context_id, current_id);\r\nif (result != VMCI_SUCCESS)\r\nbreak;\r\n}\r\nif (result != VMCI_SUCCESS)\r\npr_devel("Failed to set cpt state (type=%d) (error=%d)\n",\r\ncpt_type, result);\r\nreturn result;\r\n}\r\nint vmci_ctx_rcv_notifications_get(u32 context_id,\r\nstruct vmci_handle_arr **db_handle_array,\r\nstruct vmci_handle_arr **qp_handle_array)\r\n{\r\nstruct vmci_ctx *context;\r\nint result = VMCI_SUCCESS;\r\ncontext = vmci_ctx_get(context_id);\r\nif (context == NULL)\r\nreturn VMCI_ERROR_NOT_FOUND;\r\nspin_lock(&context->lock);\r\n*db_handle_array = context->pending_doorbell_array;\r\ncontext->pending_doorbell_array = vmci_handle_arr_create(0);\r\nif (!context->pending_doorbell_array) {\r\ncontext->pending_doorbell_array = *db_handle_array;\r\n*db_handle_array = NULL;\r\nresult = VMCI_ERROR_NO_MEM;\r\n}\r\n*qp_handle_array = NULL;\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nreturn result;\r\n}\r\nvoid vmci_ctx_rcv_notifications_release(u32 context_id,\r\nstruct vmci_handle_arr *db_handle_array,\r\nstruct vmci_handle_arr *qp_handle_array,\r\nbool success)\r\n{\r\nstruct vmci_ctx *context = vmci_ctx_get(context_id);\r\nspin_lock(&context->lock);\r\nif (!success) {\r\nstruct vmci_handle handle;\r\nhandle = vmci_handle_arr_remove_tail(\r\ncontext->pending_doorbell_array);\r\nwhile (!vmci_handle_is_invalid(handle)) {\r\nif (!vmci_handle_arr_has_entry(db_handle_array,\r\nhandle)) {\r\nvmci_handle_arr_append_entry(\r\n&db_handle_array, handle);\r\n}\r\nhandle = vmci_handle_arr_remove_tail(\r\ncontext->pending_doorbell_array);\r\n}\r\nvmci_handle_arr_destroy(context->pending_doorbell_array);\r\ncontext->pending_doorbell_array = db_handle_array;\r\ndb_handle_array = NULL;\r\n} else {\r\nctx_clear_notify_call(context);\r\n}\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nif (db_handle_array)\r\nvmci_handle_arr_destroy(db_handle_array);\r\nif (qp_handle_array)\r\nvmci_handle_arr_destroy(qp_handle_array);\r\n}\r\nint vmci_ctx_dbell_create(u32 context_id, struct vmci_handle handle)\r\n{\r\nstruct vmci_ctx *context;\r\nint result;\r\nif (context_id == VMCI_INVALID_ID || vmci_handle_is_invalid(handle))\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\ncontext = vmci_ctx_get(context_id);\r\nif (context == NULL)\r\nreturn VMCI_ERROR_NOT_FOUND;\r\nspin_lock(&context->lock);\r\nif (!vmci_handle_arr_has_entry(context->doorbell_array, handle)) {\r\nvmci_handle_arr_append_entry(&context->doorbell_array, handle);\r\nresult = VMCI_SUCCESS;\r\n} else {\r\nresult = VMCI_ERROR_DUPLICATE_ENTRY;\r\n}\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nreturn result;\r\n}\r\nint vmci_ctx_dbell_destroy(u32 context_id, struct vmci_handle handle)\r\n{\r\nstruct vmci_ctx *context;\r\nstruct vmci_handle removed_handle;\r\nif (context_id == VMCI_INVALID_ID || vmci_handle_is_invalid(handle))\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\ncontext = vmci_ctx_get(context_id);\r\nif (context == NULL)\r\nreturn VMCI_ERROR_NOT_FOUND;\r\nspin_lock(&context->lock);\r\nremoved_handle =\r\nvmci_handle_arr_remove_entry(context->doorbell_array, handle);\r\nvmci_handle_arr_remove_entry(context->pending_doorbell_array, handle);\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nreturn vmci_handle_is_invalid(removed_handle) ?\r\nVMCI_ERROR_NOT_FOUND : VMCI_SUCCESS;\r\n}\r\nint vmci_ctx_dbell_destroy_all(u32 context_id)\r\n{\r\nstruct vmci_ctx *context;\r\nstruct vmci_handle handle;\r\nif (context_id == VMCI_INVALID_ID)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\ncontext = vmci_ctx_get(context_id);\r\nif (context == NULL)\r\nreturn VMCI_ERROR_NOT_FOUND;\r\nspin_lock(&context->lock);\r\ndo {\r\nstruct vmci_handle_arr *arr = context->doorbell_array;\r\nhandle = vmci_handle_arr_remove_tail(arr);\r\n} while (!vmci_handle_is_invalid(handle));\r\ndo {\r\nstruct vmci_handle_arr *arr = context->pending_doorbell_array;\r\nhandle = vmci_handle_arr_remove_tail(arr);\r\n} while (!vmci_handle_is_invalid(handle));\r\nspin_unlock(&context->lock);\r\nvmci_ctx_put(context);\r\nreturn VMCI_SUCCESS;\r\n}\r\nint vmci_ctx_notify_dbell(u32 src_cid,\r\nstruct vmci_handle handle,\r\nu32 src_priv_flags)\r\n{\r\nstruct vmci_ctx *dst_context;\r\nint result;\r\nif (vmci_handle_is_invalid(handle))\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\ndst_context = vmci_ctx_get(handle.context);\r\nif (!dst_context) {\r\npr_devel("Invalid context (ID=0x%x)\n", handle.context);\r\nreturn VMCI_ERROR_NOT_FOUND;\r\n}\r\nif (src_cid != handle.context) {\r\nu32 dst_priv_flags;\r\nif (VMCI_CONTEXT_IS_VM(src_cid) &&\r\nVMCI_CONTEXT_IS_VM(handle.context)) {\r\npr_devel("Doorbell notification from VM to VM not supported (src=0x%x, dst=0x%x)\n",\r\nsrc_cid, handle.context);\r\nresult = VMCI_ERROR_DST_UNREACHABLE;\r\ngoto out;\r\n}\r\nresult = vmci_dbell_get_priv_flags(handle, &dst_priv_flags);\r\nif (result < VMCI_SUCCESS) {\r\npr_warn("Failed to get privilege flags for destination (handle=0x%x:0x%x)\n",\r\nhandle.context, handle.resource);\r\ngoto out;\r\n}\r\nif (src_cid != VMCI_HOST_CONTEXT_ID ||\r\nsrc_priv_flags == VMCI_NO_PRIVILEGE_FLAGS) {\r\nsrc_priv_flags = vmci_context_get_priv_flags(src_cid);\r\n}\r\nif (vmci_deny_interaction(src_priv_flags, dst_priv_flags)) {\r\nresult = VMCI_ERROR_NO_ACCESS;\r\ngoto out;\r\n}\r\n}\r\nif (handle.context == VMCI_HOST_CONTEXT_ID) {\r\nresult = vmci_dbell_host_context_notify(src_cid, handle);\r\n} else {\r\nspin_lock(&dst_context->lock);\r\nif (!vmci_handle_arr_has_entry(dst_context->doorbell_array,\r\nhandle)) {\r\nresult = VMCI_ERROR_NOT_FOUND;\r\n} else {\r\nif (!vmci_handle_arr_has_entry(\r\ndst_context->pending_doorbell_array,\r\nhandle)) {\r\nvmci_handle_arr_append_entry(\r\n&dst_context->pending_doorbell_array,\r\nhandle);\r\nctx_signal_notify(dst_context);\r\nwake_up(&dst_context->host_context.wait_queue);\r\n}\r\nresult = VMCI_SUCCESS;\r\n}\r\nspin_unlock(&dst_context->lock);\r\n}\r\nout:\r\nvmci_ctx_put(dst_context);\r\nreturn result;\r\n}\r\nbool vmci_ctx_supports_host_qp(struct vmci_ctx *context)\r\n{\r\nreturn context && context->user_version >= VMCI_VERSION_HOSTQP;\r\n}\r\nint vmci_ctx_qp_create(struct vmci_ctx *context, struct vmci_handle handle)\r\n{\r\nint result;\r\nif (context == NULL || vmci_handle_is_invalid(handle))\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nif (!vmci_handle_arr_has_entry(context->queue_pair_array, handle)) {\r\nvmci_handle_arr_append_entry(&context->queue_pair_array,\r\nhandle);\r\nresult = VMCI_SUCCESS;\r\n} else {\r\nresult = VMCI_ERROR_DUPLICATE_ENTRY;\r\n}\r\nreturn result;\r\n}\r\nint vmci_ctx_qp_destroy(struct vmci_ctx *context, struct vmci_handle handle)\r\n{\r\nstruct vmci_handle hndl;\r\nif (context == NULL || vmci_handle_is_invalid(handle))\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nhndl = vmci_handle_arr_remove_entry(context->queue_pair_array, handle);\r\nreturn vmci_handle_is_invalid(hndl) ?\r\nVMCI_ERROR_NOT_FOUND : VMCI_SUCCESS;\r\n}\r\nbool vmci_ctx_qp_exists(struct vmci_ctx *context, struct vmci_handle handle)\r\n{\r\nif (context == NULL || vmci_handle_is_invalid(handle))\r\nreturn false;\r\nreturn vmci_handle_arr_has_entry(context->queue_pair_array, handle);\r\n}\r\nu32 vmci_context_get_priv_flags(u32 context_id)\r\n{\r\nif (vmci_host_code_active()) {\r\nu32 flags;\r\nstruct vmci_ctx *context;\r\ncontext = vmci_ctx_get(context_id);\r\nif (!context)\r\nreturn VMCI_LEAST_PRIVILEGE_FLAGS;\r\nflags = context->priv_flags;\r\nvmci_ctx_put(context);\r\nreturn flags;\r\n}\r\nreturn VMCI_NO_PRIVILEGE_FLAGS;\r\n}\r\nbool vmci_is_context_owner(u32 context_id, kuid_t uid)\r\n{\r\nbool is_owner = false;\r\nif (vmci_host_code_active()) {\r\nstruct vmci_ctx *context = vmci_ctx_get(context_id);\r\nif (context) {\r\nif (context->cred)\r\nis_owner = uid_eq(context->cred->uid, uid);\r\nvmci_ctx_put(context);\r\n}\r\n}\r\nreturn is_owner;\r\n}
