static int kxsd9_write_scale(struct iio_dev *indio_dev, int micro)\r\n{\r\nint ret, i;\r\nstruct kxsd9_state *st = iio_priv(indio_dev);\r\nbool foundit = false;\r\nfor (i = 0; i < 4; i++)\r\nif (micro == kxsd9_micro_scales[i]) {\r\nfoundit = true;\r\nbreak;\r\n}\r\nif (!foundit)\r\nreturn -EINVAL;\r\nmutex_lock(&st->buf_lock);\r\nret = spi_w8r8(st->us, KXSD9_READ(KXSD9_REG_CTRL_C));\r\nif (ret)\r\ngoto error_ret;\r\nst->tx[0] = KXSD9_WRITE(KXSD9_REG_CTRL_C);\r\nst->tx[1] = (ret & ~KXSD9_FS_MASK) | i;\r\nret = spi_write(st->us, st->tx, 2);\r\nerror_ret:\r\nmutex_unlock(&st->buf_lock);\r\nreturn ret;\r\n}\r\nstatic int kxsd9_read(struct iio_dev *indio_dev, u8 address)\r\n{\r\nint ret;\r\nstruct kxsd9_state *st = iio_priv(indio_dev);\r\nstruct spi_transfer xfers[] = {\r\n{\r\n.bits_per_word = 8,\r\n.len = 1,\r\n.delay_usecs = 200,\r\n.tx_buf = st->tx,\r\n}, {\r\n.bits_per_word = 8,\r\n.len = 2,\r\n.rx_buf = st->rx,\r\n},\r\n};\r\nmutex_lock(&st->buf_lock);\r\nst->tx[0] = KXSD9_READ(address);\r\nret = spi_sync_transfer(st->us, xfers, ARRAY_SIZE(xfers));\r\nif (ret)\r\nreturn ret;\r\nreturn (((u16)(st->rx[0])) << 8) | (st->rx[1] & 0xF0);\r\n}\r\nstatic int kxsd9_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nint ret = -EINVAL;\r\nif (mask == IIO_CHAN_INFO_SCALE) {\r\nif (val)\r\nreturn -EINVAL;\r\nret = kxsd9_write_scale(indio_dev, val2);\r\n}\r\nreturn ret;\r\n}\r\nstatic int kxsd9_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret = -EINVAL;\r\nstruct kxsd9_state *st = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = kxsd9_read(indio_dev, chan->address);\r\nif (ret < 0)\r\ngoto error_ret;\r\n*val = ret;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = spi_w8r8(st->us, KXSD9_READ(KXSD9_REG_CTRL_C));\r\nif (ret)\r\ngoto error_ret;\r\n*val2 = kxsd9_micro_scales[ret & KXSD9_FS_MASK];\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\nbreak;\r\n}\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int kxsd9_power_up(struct kxsd9_state *st)\r\n{\r\nint ret;\r\nst->tx[0] = 0x0d;\r\nst->tx[1] = 0x40;\r\nret = spi_write(st->us, st->tx, 2);\r\nif (ret)\r\nreturn ret;\r\nst->tx[0] = 0x0c;\r\nst->tx[1] = 0x9b;\r\nreturn spi_write(st->us, st->tx, 2);\r\n}\r\nstatic int kxsd9_probe(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct kxsd9_state *st;\r\nint ret;\r\nindio_dev = iio_device_alloc(sizeof(*st));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->us = spi;\r\nmutex_init(&st->buf_lock);\r\nindio_dev->channels = kxsd9_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(kxsd9_channels);\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->info = &kxsd9_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nspi->mode = SPI_MODE_0;\r\nspi_setup(spi);\r\nkxsd9_power_up(st);\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_free_dev;\r\nreturn 0;\r\nerror_free_dev:\r\niio_device_free(indio_dev);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int kxsd9_remove(struct spi_device *spi)\r\n{\r\niio_device_unregister(spi_get_drvdata(spi));\r\niio_device_free(spi_get_drvdata(spi));\r\nreturn 0;\r\n}
