static int perf_event__repipe_synth(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nuint32_t size;\r\nvoid *buf = event;\r\nsize = event->header.size;\r\nwhile (size) {\r\nint ret = write(inject->output, buf, size);\r\nif (ret < 0)\r\nreturn -errno;\r\nsize -= ret;\r\nbuf += ret;\r\ninject->bytes_written += ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_event__repipe_op2_synth(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_session *session\r\n__maybe_unused)\r\n{\r\nreturn perf_event__repipe_synth(tool, event, NULL);\r\n}\r\nstatic int perf_event__repipe_event_type_synth(struct perf_tool *tool,\r\nunion perf_event *event)\r\n{\r\nreturn perf_event__repipe_synth(tool, event, NULL);\r\n}\r\nstatic int perf_event__repipe_tracing_data_synth(union perf_event *event,\r\nstruct perf_session *session\r\n__maybe_unused)\r\n{\r\nreturn perf_event__repipe_synth(NULL, event, NULL);\r\n}\r\nstatic int perf_event__repipe_attr(union perf_event *event,\r\nstruct perf_evlist **pevlist __maybe_unused)\r\n{\r\nint ret;\r\nret = perf_event__process_attr(event, pevlist);\r\nif (ret)\r\nreturn ret;\r\nreturn perf_event__repipe_synth(NULL, event, NULL);\r\n}\r\nstatic int perf_event__repipe(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nreturn perf_event__repipe_synth(tool, event, machine);\r\n}\r\nstatic int perf_event__repipe_sample(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nif (evsel->handler.func) {\r\ninject_handler f = evsel->handler.func;\r\nreturn f(tool, event, sample, evsel, machine);\r\n}\r\nbuild_id__mark_dso_hit(tool, event, sample, evsel, machine);\r\nreturn perf_event__repipe_synth(tool, event, machine);\r\n}\r\nstatic int perf_event__repipe_mmap(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_mmap(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_fork(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_fork(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_tracing_data(union perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nint err;\r\nperf_event__repipe_synth(NULL, event, NULL);\r\nerr = perf_event__process_tracing_data(event, session);\r\nreturn err;\r\n}\r\nstatic int dso__read_build_id(struct dso *self)\r\n{\r\nif (self->has_build_id)\r\nreturn 0;\r\nif (filename__read_build_id(self->long_name, self->build_id,\r\nsizeof(self->build_id)) > 0) {\r\nself->has_build_id = true;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int dso__inject_build_id(struct dso *self, struct perf_tool *tool,\r\nstruct machine *machine)\r\n{\r\nu16 misc = PERF_RECORD_MISC_USER;\r\nint err;\r\nif (dso__read_build_id(self) < 0) {\r\npr_debug("no build_id found for %s\n", self->long_name);\r\nreturn -1;\r\n}\r\nif (self->kernel)\r\nmisc = PERF_RECORD_MISC_KERNEL;\r\nerr = perf_event__synthesize_build_id(tool, self, misc, perf_event__repipe,\r\nmachine);\r\nif (err) {\r\npr_err("Can't synthesize build_id event for %s\n", self->long_name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_event__inject_buildid(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nstruct thread *thread;\r\nu8 cpumode;\r\ncpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nthread = machine__findnew_thread(machine, event->ip.pid);\r\nif (thread == NULL) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\ngoto repipe;\r\n}\r\nthread__find_addr_map(thread, machine, cpumode, MAP__FUNCTION,\r\nevent->ip.ip, &al);\r\nif (al.map != NULL) {\r\nif (!al.map->dso->hit) {\r\nal.map->dso->hit = 1;\r\nif (map__load(al.map, NULL) >= 0) {\r\ndso__inject_build_id(al.map->dso, tool, machine);\r\n} else {\r\n#ifdef LIBELF_SUPPORT\r\npr_warning("no symbols found in %s, maybe "\r\n"install a debug package?\n",\r\nal.map->dso->long_name);\r\n#endif\r\n}\r\n}\r\n}\r\nrepipe:\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn 0;\r\n}\r\nstatic int perf_inject__sched_process_exit(struct perf_tool *tool,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nstruct event_entry *ent;\r\nlist_for_each_entry(ent, &inject->samples, node) {\r\nif (sample->tid == ent->tid) {\r\nlist_del_init(&ent->node);\r\nfree(ent);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_inject__sched_switch(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nstruct event_entry *ent;\r\nperf_inject__sched_process_exit(tool, event, sample, evsel, machine);\r\nent = malloc(event->header.size + sizeof(struct event_entry));\r\nif (ent == NULL) {\r\ncolor_fprintf(stderr, PERF_COLOR_RED,\r\n"Not enough memory to process sched switch event!");\r\nreturn -1;\r\n}\r\nent->tid = sample->tid;\r\nmemcpy(&ent->event, event, event->header.size);\r\nlist_add(&ent->node, &inject->samples);\r\nreturn 0;\r\n}\r\nstatic int perf_inject__sched_stat(struct perf_tool *tool,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct event_entry *ent;\r\nunion perf_event *event_sw;\r\nstruct perf_sample sample_sw;\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nu32 pid = perf_evsel__intval(evsel, sample, "pid");\r\nlist_for_each_entry(ent, &inject->samples, node) {\r\nif (pid == ent->tid)\r\ngoto found;\r\n}\r\nreturn 0;\r\nfound:\r\nevent_sw = &ent->event[0];\r\nperf_evsel__parse_sample(evsel, event_sw, &sample_sw);\r\nsample_sw.period = sample->period;\r\nsample_sw.time = sample->time;\r\nperf_event__synthesize_sample(event_sw, evsel->attr.sample_type,\r\n&sample_sw, false);\r\nbuild_id__mark_dso_hit(tool, event_sw, &sample_sw, evsel, machine);\r\nreturn perf_event__repipe(tool, event_sw, &sample_sw, machine);\r\n}\r\nstatic void sig_handler(int sig __maybe_unused)\r\n{\r\nsession_done = 1;\r\n}\r\nstatic int perf_evsel__check_stype(struct perf_evsel *evsel,\r\nu64 sample_type, const char *sample_msg)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nconst char *name = perf_evsel__name(evsel);\r\nif (!(attr->sample_type & sample_type)) {\r\npr_err("Samples for %s event do not have %s attribute set.",\r\nname, sample_msg);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __cmd_inject(struct perf_inject *inject)\r\n{\r\nstruct perf_session *session;\r\nint ret = -EINVAL;\r\nsignal(SIGINT, sig_handler);\r\nif (inject->build_ids || inject->sched_stat) {\r\ninject->tool.mmap = perf_event__repipe_mmap;\r\ninject->tool.fork = perf_event__repipe_fork;\r\ninject->tool.tracing_data = perf_event__repipe_tracing_data;\r\n}\r\nsession = perf_session__new(inject->input_name, O_RDONLY, false, true, &inject->tool);\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\nif (inject->build_ids) {\r\ninject->tool.sample = perf_event__inject_buildid;\r\n} else if (inject->sched_stat) {\r\nstruct perf_evsel *evsel;\r\ninject->tool.ordered_samples = true;\r\nlist_for_each_entry(evsel, &session->evlist->entries, node) {\r\nconst char *name = perf_evsel__name(evsel);\r\nif (!strcmp(name, "sched:sched_switch")) {\r\nif (perf_evsel__check_stype(evsel, PERF_SAMPLE_TID, "TID"))\r\nreturn -EINVAL;\r\nevsel->handler.func = perf_inject__sched_switch;\r\n} else if (!strcmp(name, "sched:sched_process_exit"))\r\nevsel->handler.func = perf_inject__sched_process_exit;\r\nelse if (!strncmp(name, "sched:sched_stat_", 17))\r\nevsel->handler.func = perf_inject__sched_stat;\r\n}\r\n}\r\nif (!inject->pipe_output)\r\nlseek(inject->output, session->header.data_offset, SEEK_SET);\r\nret = perf_session__process_events(session, &inject->tool);\r\nif (!inject->pipe_output) {\r\nsession->header.data_size = inject->bytes_written;\r\nperf_session__write_header(session, session->evlist, inject->output, true);\r\n}\r\nperf_session__delete(session);\r\nreturn ret;\r\n}\r\nint cmd_inject(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nstruct perf_inject inject = {\r\n.tool = {\r\n.sample = perf_event__repipe_sample,\r\n.mmap = perf_event__repipe,\r\n.comm = perf_event__repipe,\r\n.fork = perf_event__repipe,\r\n.exit = perf_event__repipe,\r\n.lost = perf_event__repipe,\r\n.read = perf_event__repipe_sample,\r\n.throttle = perf_event__repipe,\r\n.unthrottle = perf_event__repipe,\r\n.attr = perf_event__repipe_attr,\r\n.event_type = perf_event__repipe_event_type_synth,\r\n.tracing_data = perf_event__repipe_tracing_data_synth,\r\n.build_id = perf_event__repipe_op2_synth,\r\n},\r\n.input_name = "-",\r\n.samples = LIST_HEAD_INIT(inject.samples),\r\n};\r\nconst char *output_name = "-";\r\nconst struct option options[] = {\r\nOPT_BOOLEAN('b', "build-ids", &inject.build_ids,\r\n"Inject build-ids into the output stream"),\r\nOPT_STRING('i', "input", &inject.input_name, "file",\r\n"input file name"),\r\nOPT_STRING('o', "output", &output_name, "file",\r\n"output file name"),\r\nOPT_BOOLEAN('s', "sched-stat", &inject.sched_stat,\r\n"Merge sched-stat and sched-switch for getting events "\r\n"where and how long tasks slept"),\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show build ids, etc)"),\r\nOPT_END()\r\n};\r\nconst char * const inject_usage[] = {\r\n"perf inject [<options>]",\r\nNULL\r\n};\r\nargc = parse_options(argc, argv, options, inject_usage, 0);\r\nif (argc)\r\nusage_with_options(inject_usage, options);\r\nif (!strcmp(output_name, "-")) {\r\ninject.pipe_output = 1;\r\ninject.output = STDOUT_FILENO;\r\n} else {\r\ninject.output = open(output_name, O_CREAT | O_WRONLY | O_TRUNC,\r\nS_IRUSR | S_IWUSR);\r\nif (inject.output < 0) {\r\nperror("failed to create output file");\r\nreturn -1;\r\n}\r\n}\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nreturn __cmd_inject(&inject);\r\n}
