static void ene_set_reg_addr(struct ene_device *dev, u16 reg)\r\n{\r\noutb(reg >> 8, dev->hw_io + ENE_ADDR_HI);\r\noutb(reg & 0xFF, dev->hw_io + ENE_ADDR_LO);\r\n}\r\nstatic u8 ene_read_reg(struct ene_device *dev, u16 reg)\r\n{\r\nu8 retval;\r\nene_set_reg_addr(dev, reg);\r\nretval = inb(dev->hw_io + ENE_IO);\r\ndbg_regs("reg %04x == %02x", reg, retval);\r\nreturn retval;\r\n}\r\nstatic void ene_write_reg(struct ene_device *dev, u16 reg, u8 value)\r\n{\r\ndbg_regs("reg %04x <- %02x", reg, value);\r\nene_set_reg_addr(dev, reg);\r\noutb(value, dev->hw_io + ENE_IO);\r\n}\r\nstatic void ene_set_reg_mask(struct ene_device *dev, u16 reg, u8 mask)\r\n{\r\ndbg_regs("reg %04x |= %02x", reg, mask);\r\nene_set_reg_addr(dev, reg);\r\noutb(inb(dev->hw_io + ENE_IO) | mask, dev->hw_io + ENE_IO);\r\n}\r\nstatic void ene_clear_reg_mask(struct ene_device *dev, u16 reg, u8 mask)\r\n{\r\ndbg_regs("reg %04x &= ~%02x ", reg, mask);\r\nene_set_reg_addr(dev, reg);\r\noutb(inb(dev->hw_io + ENE_IO) & ~mask, dev->hw_io + ENE_IO);\r\n}\r\nstatic void ene_set_clear_reg_mask(struct ene_device *dev, u16 reg, u8 mask,\r\nbool set)\r\n{\r\nif (set)\r\nene_set_reg_mask(dev, reg, mask);\r\nelse\r\nene_clear_reg_mask(dev, reg, mask);\r\n}\r\nstatic int ene_hw_detect(struct ene_device *dev)\r\n{\r\nu8 chip_major, chip_minor;\r\nu8 hw_revision, old_ver;\r\nu8 fw_reg2, fw_reg1;\r\nene_clear_reg_mask(dev, ENE_ECSTS, ENE_ECSTS_RSRVD);\r\nchip_major = ene_read_reg(dev, ENE_ECVER_MAJOR);\r\nchip_minor = ene_read_reg(dev, ENE_ECVER_MINOR);\r\nene_set_reg_mask(dev, ENE_ECSTS, ENE_ECSTS_RSRVD);\r\nhw_revision = ene_read_reg(dev, ENE_ECHV);\r\nold_ver = ene_read_reg(dev, ENE_HW_VER_OLD);\r\ndev->pll_freq = (ene_read_reg(dev, ENE_PLLFRH) << 4) +\r\n(ene_read_reg(dev, ENE_PLLFRL) >> 4);\r\nif (sample_period != ENE_DEFAULT_SAMPLE_PERIOD)\r\ndev->rx_period_adjust =\r\ndev->pll_freq == ENE_DEFAULT_PLL_FREQ ? 2 : 4;\r\nif (hw_revision == 0xFF) {\r\npr_warn("device seems to be disabled\n");\r\npr_warn("send a mail to lirc-list@lists.sourceforge.net\n");\r\npr_warn("please attach output of acpidump and dmidecode\n");\r\nreturn -ENODEV;\r\n}\r\npr_notice("chip is 0x%02x%02x - kbver = 0x%02x, rev = 0x%02x\n",\r\nchip_major, chip_minor, old_ver, hw_revision);\r\npr_notice("PLL freq = %d\n", dev->pll_freq);\r\nif (chip_major == 0x33) {\r\npr_warn("chips 0x33xx aren't supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (chip_major == 0x39 && chip_minor == 0x26 && hw_revision == 0xC0) {\r\ndev->hw_revision = ENE_HW_C;\r\npr_notice("KB3926C detected\n");\r\n} else if (old_ver == 0x24 && hw_revision == 0xC0) {\r\ndev->hw_revision = ENE_HW_B;\r\npr_notice("KB3926B detected\n");\r\n} else {\r\ndev->hw_revision = ENE_HW_D;\r\npr_notice("KB3926D or higher detected\n");\r\n}\r\nif (dev->hw_revision < ENE_HW_C)\r\nreturn 0;\r\nfw_reg1 = ene_read_reg(dev, ENE_FW1);\r\nfw_reg2 = ene_read_reg(dev, ENE_FW2);\r\npr_notice("Firmware regs: %02x %02x\n", fw_reg1, fw_reg2);\r\ndev->hw_use_gpio_0a = !!(fw_reg2 & ENE_FW2_GP0A);\r\ndev->hw_learning_and_tx_capable = !!(fw_reg2 & ENE_FW2_LEARNING);\r\ndev->hw_extra_buffer = !!(fw_reg1 & ENE_FW1_HAS_EXTRA_BUF);\r\nif (dev->hw_learning_and_tx_capable)\r\ndev->hw_fan_input = !!(fw_reg2 & ENE_FW2_FAN_INPUT);\r\npr_notice("Hardware features:\n");\r\nif (dev->hw_learning_and_tx_capable) {\r\npr_notice("* Supports transmitting & learning mode\n");\r\npr_notice(" This feature is rare and therefore,\n");\r\npr_notice(" you are welcome to test it,\n");\r\npr_notice(" and/or contact the author via:\n");\r\npr_notice(" lirc-list@lists.sourceforge.net\n");\r\npr_notice(" or maximlevitsky@gmail.com\n");\r\npr_notice("* Uses GPIO %s for IR raw input\n",\r\ndev->hw_use_gpio_0a ? "40" : "0A");\r\nif (dev->hw_fan_input)\r\npr_notice("* Uses unused fan feedback input as source of demodulated IR data\n");\r\n}\r\nif (!dev->hw_fan_input)\r\npr_notice("* Uses GPIO %s for IR demodulated input\n",\r\ndev->hw_use_gpio_0a ? "0A" : "40");\r\nif (dev->hw_extra_buffer)\r\npr_notice("* Uses new style input buffer\n");\r\nreturn 0;\r\n}\r\nstatic void ene_rx_setup_hw_buffer(struct ene_device *dev)\r\n{\r\nu16 tmp;\r\nene_rx_read_hw_pointer(dev);\r\ndev->r_pointer = dev->w_pointer;\r\nif (!dev->hw_extra_buffer) {\r\ndev->buffer_len = ENE_FW_PACKET_SIZE * 2;\r\nreturn;\r\n}\r\ntmp = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER);\r\ntmp |= ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER+1) << 8;\r\ndev->extra_buf1_address = tmp;\r\ndev->extra_buf1_len = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 2);\r\ntmp = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 3);\r\ntmp |= ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 4) << 8;\r\ndev->extra_buf2_address = tmp;\r\ndev->extra_buf2_len = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 5);\r\ndev->buffer_len = dev->extra_buf1_len + dev->extra_buf2_len + 8;\r\npr_notice("Hardware uses 2 extended buffers:\n");\r\npr_notice(" 0x%04x - len : %d\n",\r\ndev->extra_buf1_address, dev->extra_buf1_len);\r\npr_notice(" 0x%04x - len : %d\n",\r\ndev->extra_buf2_address, dev->extra_buf2_len);\r\npr_notice("Total buffer len = %d\n", dev->buffer_len);\r\nif (dev->buffer_len > 64 || dev->buffer_len < 16)\r\ngoto error;\r\nif (dev->extra_buf1_address > 0xFBFC ||\r\ndev->extra_buf1_address < 0xEC00)\r\ngoto error;\r\nif (dev->extra_buf2_address > 0xFBFC ||\r\ndev->extra_buf2_address < 0xEC00)\r\ngoto error;\r\nif (dev->r_pointer > dev->buffer_len)\r\ngoto error;\r\nene_set_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\r\nreturn;\r\nerror:\r\npr_warn("Error validating extra buffers, device probably won't work\n");\r\ndev->hw_extra_buffer = false;\r\nene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\r\n}\r\nstatic void ene_rx_restore_hw_buffer(struct ene_device *dev)\r\n{\r\nif (!dev->hw_extra_buffer)\r\nreturn;\r\nene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 0,\r\ndev->extra_buf1_address & 0xFF);\r\nene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 1,\r\ndev->extra_buf1_address >> 8);\r\nene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 2, dev->extra_buf1_len);\r\nene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 3,\r\ndev->extra_buf2_address & 0xFF);\r\nene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 4,\r\ndev->extra_buf2_address >> 8);\r\nene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 5,\r\ndev->extra_buf2_len);\r\nene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\r\n}\r\nstatic void ene_rx_read_hw_pointer(struct ene_device *dev)\r\n{\r\nif (dev->hw_extra_buffer)\r\ndev->w_pointer = ene_read_reg(dev, ENE_FW_RX_POINTER);\r\nelse\r\ndev->w_pointer = ene_read_reg(dev, ENE_FW2)\r\n& ENE_FW2_BUF_WPTR ? 0 : ENE_FW_PACKET_SIZE;\r\ndbg_verbose("RB: HW write pointer: %02x, driver read pointer: %02x",\r\ndev->w_pointer, dev->r_pointer);\r\n}\r\nstatic int ene_rx_get_sample_reg(struct ene_device *dev)\r\n{\r\nint r_pointer;\r\nif (dev->r_pointer == dev->w_pointer) {\r\ndbg_verbose("RB: hit end, try update w_pointer");\r\nene_rx_read_hw_pointer(dev);\r\n}\r\nif (dev->r_pointer == dev->w_pointer) {\r\ndbg_verbose("RB: end of data at %d", dev->r_pointer);\r\nreturn 0;\r\n}\r\ndbg_verbose("RB: reading at offset %d", dev->r_pointer);\r\nr_pointer = dev->r_pointer;\r\ndev->r_pointer++;\r\nif (dev->r_pointer == dev->buffer_len)\r\ndev->r_pointer = 0;\r\ndbg_verbose("RB: next read will be from offset %d", dev->r_pointer);\r\nif (r_pointer < 8) {\r\ndbg_verbose("RB: read at main buffer at %d", r_pointer);\r\nreturn ENE_FW_SAMPLE_BUFFER + r_pointer;\r\n}\r\nr_pointer -= 8;\r\nif (r_pointer < dev->extra_buf1_len) {\r\ndbg_verbose("RB: read at 1st extra buffer at %d", r_pointer);\r\nreturn dev->extra_buf1_address + r_pointer;\r\n}\r\nr_pointer -= dev->extra_buf1_len;\r\nif (r_pointer < dev->extra_buf2_len) {\r\ndbg_verbose("RB: read at 2nd extra buffer at %d", r_pointer);\r\nreturn dev->extra_buf2_address + r_pointer;\r\n}\r\ndbg("attempt to read beyond ring buffer end");\r\nreturn 0;\r\n}\r\nstatic void ene_rx_sense_carrier(struct ene_device *dev)\r\n{\r\nDEFINE_IR_RAW_EVENT(ev);\r\nint carrier, duty_cycle;\r\nint period = ene_read_reg(dev, ENE_CIRCAR_PRD);\r\nint hperiod = ene_read_reg(dev, ENE_CIRCAR_HPRD);\r\nif (!(period & ENE_CIRCAR_PRD_VALID))\r\nreturn;\r\nperiod &= ~ENE_CIRCAR_PRD_VALID;\r\nif (!period)\r\nreturn;\r\ndbg("RX: hardware carrier period = %02x", period);\r\ndbg("RX: hardware carrier pulse period = %02x", hperiod);\r\ncarrier = 2000000 / period;\r\nduty_cycle = (hperiod * 100) / period;\r\ndbg("RX: sensed carrier = %d Hz, duty cycle %d%%",\r\ncarrier, duty_cycle);\r\nif (dev->carrier_detect_enabled) {\r\nev.carrier_report = true;\r\nev.carrier = carrier;\r\nev.duty_cycle = duty_cycle;\r\nir_raw_event_store(dev->rdev, &ev);\r\n}\r\n}\r\nstatic void ene_rx_enable_cir_engine(struct ene_device *dev, bool enable)\r\n{\r\nene_set_clear_reg_mask(dev, ENE_CIRCFG,\r\nENE_CIRCFG_RX_EN | ENE_CIRCFG_RX_IRQ, enable);\r\n}\r\nstatic void ene_rx_select_input(struct ene_device *dev, bool gpio_0a)\r\n{\r\nene_set_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_GPIO0A, gpio_0a);\r\n}\r\nstatic void ene_rx_enable_fan_input(struct ene_device *dev, bool enable)\r\n{\r\nif (!dev->hw_fan_input)\r\nreturn;\r\nif (!enable)\r\nene_write_reg(dev, ENE_FAN_AS_IN1, 0);\r\nelse {\r\nene_write_reg(dev, ENE_FAN_AS_IN1, ENE_FAN_AS_IN1_EN);\r\nene_write_reg(dev, ENE_FAN_AS_IN2, ENE_FAN_AS_IN2_EN);\r\n}\r\n}\r\nstatic void ene_rx_setup(struct ene_device *dev)\r\n{\r\nbool learning_mode = dev->learning_mode_enabled ||\r\ndev->carrier_detect_enabled;\r\nint sample_period_adjust = 0;\r\ndbg("RX: setup receiver, learning mode = %d", learning_mode);\r\nene_write_reg(dev, ENE_CIRCFG2, 0x00);\r\nif (sample_period == ENE_DEFAULT_SAMPLE_PERIOD)\r\nsample_period_adjust =\r\ndev->pll_freq == ENE_DEFAULT_PLL_FREQ ? 1 : 2;\r\nene_write_reg(dev, ENE_CIRRLC_CFG,\r\n(sample_period + sample_period_adjust) |\r\nENE_CIRRLC_CFG_OVERFLOW);\r\nif (dev->hw_revision < ENE_HW_C)\r\ngoto select_timeout;\r\nif (learning_mode) {\r\nWARN_ON(!dev->hw_learning_and_tx_capable);\r\nene_rx_select_input(dev, !dev->hw_use_gpio_0a);\r\ndev->rx_fan_input_inuse = false;\r\nene_set_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_CARR_DEMOD);\r\nene_write_reg(dev, ENE_CIRCAR_PULS, 0x63);\r\nene_set_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_CARR_DETECT,\r\ndev->carrier_detect_enabled || debug);\r\n} else {\r\nif (dev->hw_fan_input)\r\ndev->rx_fan_input_inuse = true;\r\nelse\r\nene_rx_select_input(dev, dev->hw_use_gpio_0a);\r\nene_clear_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_CARR_DEMOD);\r\nene_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_CARR_DETECT);\r\n}\r\nselect_timeout:\r\nif (dev->rx_fan_input_inuse) {\r\ndev->rdev->rx_resolution = US_TO_NS(ENE_FW_SAMPLE_PERIOD_FAN);\r\ndev->rdev->min_timeout = dev->rdev->max_timeout =\r\nUS_TO_NS(ENE_FW_SMPL_BUF_FAN_MSK *\r\nENE_FW_SAMPLE_PERIOD_FAN);\r\n} else {\r\ndev->rdev->rx_resolution = US_TO_NS(sample_period);\r\ndev->rdev->min_timeout = US_TO_NS(127 * sample_period);\r\ndev->rdev->max_timeout = US_TO_NS(200000);\r\n}\r\nif (dev->hw_learning_and_tx_capable)\r\ndev->rdev->tx_resolution = US_TO_NS(sample_period);\r\nif (dev->rdev->timeout > dev->rdev->max_timeout)\r\ndev->rdev->timeout = dev->rdev->max_timeout;\r\nif (dev->rdev->timeout < dev->rdev->min_timeout)\r\ndev->rdev->timeout = dev->rdev->min_timeout;\r\n}\r\nstatic void ene_rx_enable(struct ene_device *dev)\r\n{\r\nu8 reg_value;\r\nif (dev->hw_revision < ENE_HW_C) {\r\nene_write_reg(dev, ENEB_IRQ, dev->irq << 1);\r\nene_write_reg(dev, ENEB_IRQ_UNK1, 0x01);\r\n} else {\r\nreg_value = ene_read_reg(dev, ENE_IRQ) & 0xF0;\r\nreg_value |= ENE_IRQ_UNK_EN;\r\nreg_value &= ~ENE_IRQ_STATUS;\r\nreg_value |= (dev->irq & ENE_IRQ_MASK);\r\nene_write_reg(dev, ENE_IRQ, reg_value);\r\n}\r\nene_rx_enable_fan_input(dev, dev->rx_fan_input_inuse);\r\nene_rx_enable_cir_engine(dev, !dev->rx_fan_input_inuse);\r\nene_irq_status(dev);\r\nene_set_reg_mask(dev, ENE_FW1, ENE_FW1_ENABLE | ENE_FW1_IRQ);\r\nir_raw_event_set_idle(dev->rdev, true);\r\ndev->rx_enabled = true;\r\n}\r\nstatic void ene_rx_disable(struct ene_device *dev)\r\n{\r\nene_rx_enable_cir_engine(dev, false);\r\nene_rx_enable_fan_input(dev, false);\r\nene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_ENABLE | ENE_FW1_IRQ);\r\nir_raw_event_set_idle(dev->rdev, true);\r\ndev->rx_enabled = false;\r\n}\r\nstatic void ene_rx_reset(struct ene_device *dev)\r\n{\r\nene_clear_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_RX_EN);\r\nene_set_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_RX_EN);\r\n}\r\nstatic void ene_tx_set_carrier(struct ene_device *dev)\r\n{\r\nu8 tx_puls_width;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\nene_set_clear_reg_mask(dev, ENE_CIRCFG,\r\nENE_CIRCFG_TX_CARR, dev->tx_period > 0);\r\nif (!dev->tx_period)\r\ngoto unlock;\r\nBUG_ON(dev->tx_duty_cycle >= 100 || dev->tx_duty_cycle <= 0);\r\ntx_puls_width = dev->tx_period / (100 / dev->tx_duty_cycle);\r\nif (!tx_puls_width)\r\ntx_puls_width = 1;\r\ndbg("TX: pulse distance = %d * 500 ns", dev->tx_period);\r\ndbg("TX: pulse width = %d * 500 ns", tx_puls_width);\r\nene_write_reg(dev, ENE_CIRMOD_PRD, dev->tx_period | ENE_CIRMOD_PRD_POL);\r\nene_write_reg(dev, ENE_CIRMOD_HPRD, tx_puls_width);\r\nunlock:\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\n}\r\nstatic void ene_tx_set_transmitters(struct ene_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\nene_set_clear_reg_mask(dev, ENE_GPIOFS8, ENE_GPIOFS8_GPIO41,\r\n!!(dev->transmitter_mask & 0x01));\r\nene_set_clear_reg_mask(dev, ENE_GPIOFS1, ENE_GPIOFS1_GPIO0D,\r\n!!(dev->transmitter_mask & 0x02));\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\n}\r\nstatic void ene_tx_enable(struct ene_device *dev)\r\n{\r\nu8 conf1 = ene_read_reg(dev, ENE_CIRCFG);\r\nu8 fwreg2 = ene_read_reg(dev, ENE_FW2);\r\ndev->saved_conf1 = conf1;\r\nif (fwreg2 & ENE_FW2_EMMITER1_CONN)\r\ndbg("TX: Transmitter #1 is connected");\r\nif (fwreg2 & ENE_FW2_EMMITER2_CONN)\r\ndbg("TX: Transmitter #2 is connected");\r\nif (!(fwreg2 & (ENE_FW2_EMMITER1_CONN | ENE_FW2_EMMITER2_CONN)))\r\npr_warn("TX: transmitter cable isn't connected!\n");\r\nif (dev->hw_revision == ENE_HW_C)\r\nconf1 &= ~ENE_CIRCFG_RX_EN;\r\nconf1 |= ENE_CIRCFG_TX_EN | ENE_CIRCFG_TX_IRQ;\r\nene_write_reg(dev, ENE_CIRCFG, conf1);\r\n}\r\nstatic void ene_tx_disable(struct ene_device *dev)\r\n{\r\nene_write_reg(dev, ENE_CIRCFG, dev->saved_conf1);\r\ndev->tx_buffer = NULL;\r\n}\r\nstatic void ene_tx_sample(struct ene_device *dev)\r\n{\r\nu8 raw_tx;\r\nu32 sample;\r\nbool pulse = dev->tx_sample_pulse;\r\nif (!dev->tx_buffer) {\r\npr_warn("TX: BUG: attempt to transmit NULL buffer\n");\r\nreturn;\r\n}\r\nif (!dev->tx_sample) {\r\nif (dev->tx_pos == dev->tx_len) {\r\nif (!dev->tx_done) {\r\ndbg("TX: no more data to send");\r\ndev->tx_done = true;\r\ngoto exit;\r\n} else {\r\ndbg("TX: last sample sent by hardware");\r\nene_tx_disable(dev);\r\ncomplete(&dev->tx_complete);\r\nreturn;\r\n}\r\n}\r\nsample = dev->tx_buffer[dev->tx_pos++];\r\ndev->tx_sample_pulse = !dev->tx_sample_pulse;\r\ndev->tx_sample = DIV_ROUND_CLOSEST(sample, sample_period);\r\nif (!dev->tx_sample)\r\ndev->tx_sample = 1;\r\n}\r\nraw_tx = min(dev->tx_sample , (unsigned int)ENE_CIRRLC_OUT_MASK);\r\ndev->tx_sample -= raw_tx;\r\ndbg("TX: sample %8d (%s)", raw_tx * sample_period,\r\npulse ? "pulse" : "space");\r\nif (pulse)\r\nraw_tx |= ENE_CIRRLC_OUT_PULSE;\r\nene_write_reg(dev,\r\ndev->tx_reg ? ENE_CIRRLC_OUT1 : ENE_CIRRLC_OUT0, raw_tx);\r\ndev->tx_reg = !dev->tx_reg;\r\nexit:\r\nif (txsim)\r\nmod_timer(&dev->tx_sim_timer, jiffies + HZ / 500);\r\n}\r\nstatic void ene_tx_irqsim(unsigned long data)\r\n{\r\nstruct ene_device *dev = (struct ene_device *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\nene_tx_sample(dev);\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\n}\r\nstatic int ene_irq_status(struct ene_device *dev)\r\n{\r\nu8 irq_status;\r\nu8 fw_flags1, fw_flags2;\r\nint retval = 0;\r\nfw_flags2 = ene_read_reg(dev, ENE_FW2);\r\nif (dev->hw_revision < ENE_HW_C) {\r\nirq_status = ene_read_reg(dev, ENEB_IRQ_STATUS);\r\nif (!(irq_status & ENEB_IRQ_STATUS_IR))\r\nreturn 0;\r\nene_clear_reg_mask(dev, ENEB_IRQ_STATUS, ENEB_IRQ_STATUS_IR);\r\nreturn ENE_IRQ_RX;\r\n}\r\nirq_status = ene_read_reg(dev, ENE_IRQ);\r\nif (!(irq_status & ENE_IRQ_STATUS))\r\nreturn 0;\r\nene_write_reg(dev, ENE_IRQ, irq_status & ~ENE_IRQ_STATUS);\r\nene_write_reg(dev, ENE_IRQ, irq_status & ~ENE_IRQ_STATUS);\r\nif (fw_flags2 & ENE_FW2_RXIRQ) {\r\nretval |= ENE_IRQ_RX;\r\nene_write_reg(dev, ENE_FW2, fw_flags2 & ~ENE_FW2_RXIRQ);\r\n}\r\nfw_flags1 = ene_read_reg(dev, ENE_FW1);\r\nif (fw_flags1 & ENE_FW1_TXIRQ) {\r\nene_write_reg(dev, ENE_FW1, fw_flags1 & ~ENE_FW1_TXIRQ);\r\nretval |= ENE_IRQ_TX;\r\n}\r\nreturn retval;\r\n}\r\nstatic irqreturn_t ene_isr(int irq, void *data)\r\n{\r\nu16 hw_value, reg;\r\nint hw_sample, irq_status;\r\nbool pulse;\r\nunsigned long flags;\r\nirqreturn_t retval = IRQ_NONE;\r\nstruct ene_device *dev = (struct ene_device *)data;\r\nDEFINE_IR_RAW_EVENT(ev);\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\ndbg_verbose("ISR called");\r\nene_rx_read_hw_pointer(dev);\r\nirq_status = ene_irq_status(dev);\r\nif (!irq_status)\r\ngoto unlock;\r\nretval = IRQ_HANDLED;\r\nif (irq_status & ENE_IRQ_TX) {\r\ndbg_verbose("TX interrupt");\r\nif (!dev->hw_learning_and_tx_capable) {\r\ndbg("TX interrupt on unsupported device!");\r\ngoto unlock;\r\n}\r\nene_tx_sample(dev);\r\n}\r\nif (!(irq_status & ENE_IRQ_RX))\r\ngoto unlock;\r\ndbg_verbose("RX interrupt");\r\nif (dev->hw_learning_and_tx_capable)\r\nene_rx_sense_carrier(dev);\r\nif (!dev->hw_extra_buffer)\r\ndev->r_pointer = dev->w_pointer == 0 ? ENE_FW_PACKET_SIZE : 0;\r\nwhile (1) {\r\nreg = ene_rx_get_sample_reg(dev);\r\ndbg_verbose("next sample to read at: %04x", reg);\r\nif (!reg)\r\nbreak;\r\nhw_value = ene_read_reg(dev, reg);\r\nif (dev->rx_fan_input_inuse) {\r\nint offset = ENE_FW_SMPL_BUF_FAN - ENE_FW_SAMPLE_BUFFER;\r\nhw_value |= ene_read_reg(dev, reg + offset) << 8;\r\npulse = hw_value & ENE_FW_SMPL_BUF_FAN_PLS;\r\nhw_value &= ENE_FW_SMPL_BUF_FAN_MSK;\r\nhw_sample = hw_value * ENE_FW_SAMPLE_PERIOD_FAN;\r\n} else {\r\npulse = !(hw_value & ENE_FW_SAMPLE_SPACE);\r\nhw_value &= ~ENE_FW_SAMPLE_SPACE;\r\nhw_sample = hw_value * sample_period;\r\nif (dev->rx_period_adjust) {\r\nhw_sample *= 100;\r\nhw_sample /= (100 + dev->rx_period_adjust);\r\n}\r\n}\r\nif (!dev->hw_extra_buffer && !hw_sample) {\r\ndev->r_pointer = dev->w_pointer;\r\ncontinue;\r\n}\r\ndbg("RX: %d (%s)", hw_sample, pulse ? "pulse" : "space");\r\nev.duration = US_TO_NS(hw_sample);\r\nev.pulse = pulse;\r\nir_raw_event_store_with_filter(dev->rdev, &ev);\r\n}\r\nir_raw_event_handle(dev->rdev);\r\nunlock:\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\nreturn retval;\r\n}\r\nstatic void ene_setup_default_settings(struct ene_device *dev)\r\n{\r\ndev->tx_period = 32;\r\ndev->tx_duty_cycle = 50;\r\ndev->transmitter_mask = 0x03;\r\ndev->learning_mode_enabled = learning_mode_force;\r\ndev->rdev->timeout = US_TO_NS(150000);\r\n}\r\nstatic void ene_setup_hw_settings(struct ene_device *dev)\r\n{\r\nif (dev->hw_learning_and_tx_capable) {\r\nene_tx_set_carrier(dev);\r\nene_tx_set_transmitters(dev);\r\n}\r\nene_rx_setup(dev);\r\n}\r\nstatic int ene_open(struct rc_dev *rdev)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\nene_rx_enable(dev);\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ene_close(struct rc_dev *rdev)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\nene_rx_disable(dev);\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\n}\r\nstatic int ene_set_tx_mask(struct rc_dev *rdev, u32 tx_mask)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\ndbg("TX: attempt to set transmitter mask %02x", tx_mask);\r\nif (!tx_mask || tx_mask & ~0x03) {\r\ndbg("TX: invalid mask");\r\nreturn 2;\r\n}\r\ndev->transmitter_mask = tx_mask;\r\nene_tx_set_transmitters(dev);\r\nreturn 0;\r\n}\r\nstatic int ene_set_tx_carrier(struct rc_dev *rdev, u32 carrier)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\nu32 period;\r\ndbg("TX: attempt to set tx carrier to %d kHz", carrier);\r\nif (carrier == 0)\r\nreturn -EINVAL;\r\nperiod = 2000000 / carrier;\r\nif (period && (period > ENE_CIRMOD_PRD_MAX ||\r\nperiod < ENE_CIRMOD_PRD_MIN)) {\r\ndbg("TX: out of range %d-%d kHz carrier",\r\n2000 / ENE_CIRMOD_PRD_MIN, 2000 / ENE_CIRMOD_PRD_MAX);\r\nreturn -1;\r\n}\r\ndev->tx_period = period;\r\nene_tx_set_carrier(dev);\r\nreturn 0;\r\n}\r\nstatic int ene_set_tx_duty_cycle(struct rc_dev *rdev, u32 duty_cycle)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\ndbg("TX: setting duty cycle to %d%%", duty_cycle);\r\ndev->tx_duty_cycle = duty_cycle;\r\nene_tx_set_carrier(dev);\r\nreturn 0;\r\n}\r\nstatic int ene_set_learning_mode(struct rc_dev *rdev, int enable)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\nunsigned long flags;\r\nif (enable == dev->learning_mode_enabled)\r\nreturn 0;\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\ndev->learning_mode_enabled = enable;\r\nene_rx_disable(dev);\r\nene_rx_setup(dev);\r\nene_rx_enable(dev);\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ene_set_carrier_report(struct rc_dev *rdev, int enable)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\nunsigned long flags;\r\nif (enable == dev->carrier_detect_enabled)\r\nreturn 0;\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\ndev->carrier_detect_enabled = enable;\r\nene_rx_disable(dev);\r\nene_rx_setup(dev);\r\nene_rx_enable(dev);\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ene_set_idle(struct rc_dev *rdev, bool idle)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\nif (idle) {\r\nene_rx_reset(dev);\r\ndbg("RX: end of data");\r\n}\r\n}\r\nstatic int ene_transmit(struct rc_dev *rdev, unsigned *buf, unsigned n)\r\n{\r\nstruct ene_device *dev = rdev->priv;\r\nunsigned long flags;\r\ndev->tx_buffer = buf;\r\ndev->tx_len = n;\r\ndev->tx_pos = 0;\r\ndev->tx_reg = 0;\r\ndev->tx_done = 0;\r\ndev->tx_sample = 0;\r\ndev->tx_sample_pulse = 0;\r\ndbg("TX: %d samples", dev->tx_len);\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\nene_tx_enable(dev);\r\nene_tx_sample(dev);\r\nene_tx_sample(dev);\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\nif (wait_for_completion_timeout(&dev->tx_complete, 2 * HZ) == 0) {\r\ndbg("TX: timeout");\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\nene_tx_disable(dev);\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\n} else\r\ndbg("TX: done");\r\nreturn n;\r\n}\r\nstatic int ene_probe(struct pnp_dev *pnp_dev, const struct pnp_device_id *id)\r\n{\r\nint error = -ENOMEM;\r\nstruct rc_dev *rdev;\r\nstruct ene_device *dev;\r\ndev = kzalloc(sizeof(struct ene_device), GFP_KERNEL);\r\nrdev = rc_allocate_device();\r\nif (!dev || !rdev)\r\ngoto exit_free_dev_rdev;\r\nerror = -ENODEV;\r\ndev->hw_io = -1;\r\ndev->irq = -1;\r\nif (!pnp_port_valid(pnp_dev, 0) ||\r\npnp_port_len(pnp_dev, 0) < ENE_IO_SIZE)\r\ngoto exit_free_dev_rdev;\r\nif (!pnp_irq_valid(pnp_dev, 0))\r\ngoto exit_free_dev_rdev;\r\nspin_lock_init(&dev->hw_lock);\r\ndev->hw_io = pnp_port_start(pnp_dev, 0);\r\npnp_set_drvdata(pnp_dev, dev);\r\ndev->pnp_dev = pnp_dev;\r\nif (sample_period < 5 || sample_period > 0x7F)\r\nsample_period = ENE_DEFAULT_SAMPLE_PERIOD;\r\nerror = ene_hw_detect(dev);\r\nif (error)\r\ngoto exit_free_dev_rdev;\r\nif (!dev->hw_learning_and_tx_capable && txsim) {\r\ndev->hw_learning_and_tx_capable = true;\r\nsetup_timer(&dev->tx_sim_timer, ene_tx_irqsim,\r\n(long unsigned int)dev);\r\npr_warn("Simulation of TX activated\n");\r\n}\r\nif (!dev->hw_learning_and_tx_capable)\r\nlearning_mode_force = false;\r\nrdev->driver_type = RC_DRIVER_IR_RAW;\r\nrdev->allowed_protos = RC_BIT_ALL;\r\nrdev->priv = dev;\r\nrdev->open = ene_open;\r\nrdev->close = ene_close;\r\nrdev->s_idle = ene_set_idle;\r\nrdev->driver_name = ENE_DRIVER_NAME;\r\nrdev->map_name = RC_MAP_RC6_MCE;\r\nrdev->input_name = "ENE eHome Infrared Remote Receiver";\r\nif (dev->hw_learning_and_tx_capable) {\r\nrdev->s_learning_mode = ene_set_learning_mode;\r\ninit_completion(&dev->tx_complete);\r\nrdev->tx_ir = ene_transmit;\r\nrdev->s_tx_mask = ene_set_tx_mask;\r\nrdev->s_tx_carrier = ene_set_tx_carrier;\r\nrdev->s_tx_duty_cycle = ene_set_tx_duty_cycle;\r\nrdev->s_carrier_report = ene_set_carrier_report;\r\nrdev->input_name = "ENE eHome Infrared Remote Transceiver";\r\n}\r\ndev->rdev = rdev;\r\nene_rx_setup_hw_buffer(dev);\r\nene_setup_default_settings(dev);\r\nene_setup_hw_settings(dev);\r\ndevice_set_wakeup_capable(&pnp_dev->dev, true);\r\ndevice_set_wakeup_enable(&pnp_dev->dev, true);\r\nerror = rc_register_device(rdev);\r\nif (error < 0)\r\ngoto exit_free_dev_rdev;\r\nerror = -EBUSY;\r\nif (!request_region(dev->hw_io, ENE_IO_SIZE, ENE_DRIVER_NAME)) {\r\ngoto exit_unregister_device;\r\n}\r\ndev->irq = pnp_irq(pnp_dev, 0);\r\nif (request_irq(dev->irq, ene_isr,\r\nIRQF_SHARED, ENE_DRIVER_NAME, (void *)dev)) {\r\ngoto exit_release_hw_io;\r\n}\r\npr_notice("driver has been successfully loaded\n");\r\nreturn 0;\r\nexit_release_hw_io:\r\nrelease_region(dev->hw_io, ENE_IO_SIZE);\r\nexit_unregister_device:\r\nrc_unregister_device(rdev);\r\nrdev = NULL;\r\nexit_free_dev_rdev:\r\nrc_free_device(rdev);\r\nkfree(dev);\r\nreturn error;\r\n}\r\nstatic void ene_remove(struct pnp_dev *pnp_dev)\r\n{\r\nstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->hw_lock, flags);\r\nene_rx_disable(dev);\r\nene_rx_restore_hw_buffer(dev);\r\nspin_unlock_irqrestore(&dev->hw_lock, flags);\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->hw_io, ENE_IO_SIZE);\r\nrc_unregister_device(dev->rdev);\r\nkfree(dev);\r\n}\r\nstatic void ene_enable_wake(struct ene_device *dev, int enable)\r\n{\r\nenable = enable && device_may_wakeup(&dev->pnp_dev->dev);\r\ndbg("wake on IR %s", enable ? "enabled" : "disabled");\r\nene_set_clear_reg_mask(dev, ENE_FW1, ENE_FW1_WAKE, enable);\r\n}\r\nstatic int ene_suspend(struct pnp_dev *pnp_dev, pm_message_t state)\r\n{\r\nstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\r\nene_enable_wake(dev, true);\r\nreturn 0;\r\n}\r\nstatic int ene_resume(struct pnp_dev *pnp_dev)\r\n{\r\nstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\r\nene_setup_hw_settings(dev);\r\nif (dev->rx_enabled)\r\nene_rx_enable(dev);\r\nene_enable_wake(dev, false);\r\nreturn 0;\r\n}\r\nstatic void ene_shutdown(struct pnp_dev *pnp_dev)\r\n{\r\nstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\r\nene_enable_wake(dev, true);\r\n}\r\nstatic int __init ene_init(void)\r\n{\r\nreturn pnp_register_driver(&ene_driver);\r\n}\r\nstatic void ene_exit(void)\r\n{\r\npnp_unregister_driver(&ene_driver);\r\n}
