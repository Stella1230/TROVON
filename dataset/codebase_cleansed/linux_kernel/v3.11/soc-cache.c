static bool snd_soc_set_cache_val(void *base, unsigned int idx,\r\nunsigned int val, unsigned int word_size)\r\n{\r\nswitch (word_size) {\r\ncase 1: {\r\nu8 *cache = base;\r\nif (cache[idx] == val)\r\nreturn true;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ncase 2: {\r\nu16 *cache = base;\r\nif (cache[idx] == val)\r\nreturn true;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn false;\r\n}\r\nstatic unsigned int snd_soc_get_cache_val(const void *base, unsigned int idx,\r\nunsigned int word_size)\r\n{\r\nif (!base)\r\nreturn -1;\r\nswitch (word_size) {\r\ncase 1: {\r\nconst u8 *cache = base;\r\nreturn cache[idx];\r\n}\r\ncase 2: {\r\nconst u16 *cache = base;\r\nreturn cache[idx];\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn -1;\r\n}\r\nstatic int snd_soc_flat_cache_sync(struct snd_soc_codec *codec)\r\n{\r\nint i;\r\nint ret;\r\nconst struct snd_soc_codec_driver *codec_drv;\r\nunsigned int val;\r\ncodec_drv = codec->driver;\r\nfor (i = 0; i < codec_drv->reg_cache_size; ++i) {\r\nret = snd_soc_cache_read(codec, i, &val);\r\nif (ret)\r\nreturn ret;\r\nif (codec->reg_def_copy)\r\nif (snd_soc_get_cache_val(codec->reg_def_copy,\r\ni, codec_drv->reg_word_size) == val)\r\ncontinue;\r\nWARN_ON(!snd_soc_codec_writable_register(codec, i));\r\nret = snd_soc_write(codec, i, val);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(codec->dev, "ASoC: Synced register %#x, value = %#x\n",\r\ni, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_soc_flat_cache_write(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int value)\r\n{\r\nsnd_soc_set_cache_val(codec->reg_cache, reg, value,\r\ncodec->driver->reg_word_size);\r\nreturn 0;\r\n}\r\nstatic int snd_soc_flat_cache_read(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int *value)\r\n{\r\n*value = snd_soc_get_cache_val(codec->reg_cache, reg,\r\ncodec->driver->reg_word_size);\r\nreturn 0;\r\n}\r\nstatic int snd_soc_flat_cache_exit(struct snd_soc_codec *codec)\r\n{\r\nif (!codec->reg_cache)\r\nreturn 0;\r\nkfree(codec->reg_cache);\r\ncodec->reg_cache = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_soc_flat_cache_init(struct snd_soc_codec *codec)\r\n{\r\nif (codec->reg_def_copy)\r\ncodec->reg_cache = kmemdup(codec->reg_def_copy,\r\ncodec->reg_size, GFP_KERNEL);\r\nelse\r\ncodec->reg_cache = kzalloc(codec->reg_size, GFP_KERNEL);\r\nif (!codec->reg_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint snd_soc_cache_init(struct snd_soc_codec *codec)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cache_types); ++i)\r\nif (cache_types[i].id == codec->compress_type)\r\nbreak;\r\nif (i == ARRAY_SIZE(cache_types)) {\r\ndev_warn(codec->dev, "ASoC: Could not match compress type: %d\n",\r\ncodec->compress_type);\r\ni = 0;\r\n}\r\nmutex_init(&codec->cache_rw_mutex);\r\ncodec->cache_ops = &cache_types[i];\r\nif (codec->cache_ops->init) {\r\nif (codec->cache_ops->name)\r\ndev_dbg(codec->dev, "ASoC: Initializing %s cache for %s codec\n",\r\ncodec->cache_ops->name, codec->name);\r\nreturn codec->cache_ops->init(codec);\r\n}\r\nreturn -ENOSYS;\r\n}\r\nint snd_soc_cache_exit(struct snd_soc_codec *codec)\r\n{\r\nif (codec->cache_ops && codec->cache_ops->exit) {\r\nif (codec->cache_ops->name)\r\ndev_dbg(codec->dev, "ASoC: Destroying %s cache for %s codec\n",\r\ncodec->cache_ops->name, codec->name);\r\nreturn codec->cache_ops->exit(codec);\r\n}\r\nreturn -ENOSYS;\r\n}\r\nint snd_soc_cache_read(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int *value)\r\n{\r\nint ret;\r\nmutex_lock(&codec->cache_rw_mutex);\r\nif (value && codec->cache_ops && codec->cache_ops->read) {\r\nret = codec->cache_ops->read(codec, reg, value);\r\nmutex_unlock(&codec->cache_rw_mutex);\r\nreturn ret;\r\n}\r\nmutex_unlock(&codec->cache_rw_mutex);\r\nreturn -ENOSYS;\r\n}\r\nint snd_soc_cache_write(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int value)\r\n{\r\nint ret;\r\nmutex_lock(&codec->cache_rw_mutex);\r\nif (codec->cache_ops && codec->cache_ops->write) {\r\nret = codec->cache_ops->write(codec, reg, value);\r\nmutex_unlock(&codec->cache_rw_mutex);\r\nreturn ret;\r\n}\r\nmutex_unlock(&codec->cache_rw_mutex);\r\nreturn -ENOSYS;\r\n}\r\nint snd_soc_cache_sync(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nconst char *name;\r\nif (!codec->cache_sync) {\r\nreturn 0;\r\n}\r\nif (!codec->cache_ops || !codec->cache_ops->sync)\r\nreturn -ENOSYS;\r\nif (codec->cache_ops->name)\r\nname = codec->cache_ops->name;\r\nelse\r\nname = "unknown";\r\nif (codec->cache_ops->name)\r\ndev_dbg(codec->dev, "ASoC: Syncing %s cache for %s codec\n",\r\ncodec->cache_ops->name, codec->name);\r\ntrace_snd_soc_cache_sync(codec, name, "start");\r\nret = codec->cache_ops->sync(codec);\r\nif (!ret)\r\ncodec->cache_sync = 0;\r\ntrace_snd_soc_cache_sync(codec, name, "end");\r\nreturn ret;\r\n}\r\nstatic int snd_soc_get_reg_access_index(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nconst struct snd_soc_codec_driver *codec_drv;\r\nunsigned int min, max, index;\r\ncodec_drv = codec->driver;\r\nmin = 0;\r\nmax = codec_drv->reg_access_size - 1;\r\ndo {\r\nindex = (min + max) / 2;\r\nif (codec_drv->reg_access_default[index].reg == reg)\r\nreturn index;\r\nif (codec_drv->reg_access_default[index].reg < reg)\r\nmin = index + 1;\r\nelse\r\nmax = index;\r\n} while (min <= max);\r\nreturn -1;\r\n}\r\nint snd_soc_default_volatile_register(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nint index;\r\nif (reg >= codec->driver->reg_cache_size)\r\nreturn 1;\r\nindex = snd_soc_get_reg_access_index(codec, reg);\r\nif (index < 0)\r\nreturn 0;\r\nreturn codec->driver->reg_access_default[index].vol;\r\n}\r\nint snd_soc_default_readable_register(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nint index;\r\nif (reg >= codec->driver->reg_cache_size)\r\nreturn 1;\r\nindex = snd_soc_get_reg_access_index(codec, reg);\r\nif (index < 0)\r\nreturn 0;\r\nreturn codec->driver->reg_access_default[index].read;\r\n}\r\nint snd_soc_default_writable_register(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nint index;\r\nif (reg >= codec->driver->reg_cache_size)\r\nreturn 1;\r\nindex = snd_soc_get_reg_access_index(codec, reg);\r\nif (index < 0)\r\nreturn 0;\r\nreturn codec->driver->reg_access_default[index].write;\r\n}
