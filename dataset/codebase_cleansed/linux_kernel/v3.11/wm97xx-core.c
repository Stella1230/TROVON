int wm97xx_reg_read(struct wm97xx *wm, u16 reg)\r\n{\r\nif (wm->ac97)\r\nreturn wm->ac97->bus->ops->read(wm->ac97, reg);\r\nelse\r\nreturn -1;\r\n}\r\nvoid wm97xx_reg_write(struct wm97xx *wm, u16 reg, u16 val)\r\n{\r\nif (reg >= AC97_WM9713_DIG1 && reg <= AC97_WM9713_DIG3)\r\nwm->dig[(reg - AC97_WM9713_DIG1) >> 1] = val;\r\nif (reg >= AC97_GPIO_CFG && reg <= AC97_MISC_AFE)\r\nwm->gpio[(reg - AC97_GPIO_CFG) >> 1] = val;\r\nif (reg == 0x5a)\r\nwm->misc = val;\r\nif (wm->ac97)\r\nwm->ac97->bus->ops->write(wm->ac97, reg, val);\r\n}\r\nint wm97xx_read_aux_adc(struct wm97xx *wm, u16 adcsel)\r\n{\r\nint power_adc = 0, auxval;\r\nu16 power = 0;\r\nint rc = 0;\r\nint timeout = 0;\r\nmutex_lock(&wm->codec_mutex);\r\nif (wm->id == WM9713_ID2 &&\r\n(power = wm97xx_reg_read(wm, AC97_EXTENDED_MID)) & 0x8000) {\r\npower_adc = 1;\r\nwm97xx_reg_write(wm, AC97_EXTENDED_MID, power & 0x7fff);\r\n}\r\nwm->codec->aux_prepare(wm);\r\nwm->pen_probably_down = 1;\r\nwhile (rc != RC_VALID && timeout++ < 5)\r\nrc = wm->codec->poll_sample(wm, adcsel, &auxval);\r\nif (power_adc)\r\nwm97xx_reg_write(wm, AC97_EXTENDED_MID, power | 0x8000);\r\nwm->codec->dig_restore(wm);\r\nwm->pen_probably_down = 0;\r\nif (timeout >= 5) {\r\ndev_err(wm->dev,\r\n"timeout reading auxadc %d, disabling digitiser\n",\r\nadcsel);\r\nwm->codec->dig_enable(wm, false);\r\n}\r\nmutex_unlock(&wm->codec_mutex);\r\nreturn (rc == RC_VALID ? auxval & 0xfff : -EBUSY);\r\n}\r\nenum wm97xx_gpio_status wm97xx_get_gpio(struct wm97xx *wm, u32 gpio)\r\n{\r\nu16 status;\r\nenum wm97xx_gpio_status ret;\r\nmutex_lock(&wm->codec_mutex);\r\nstatus = wm97xx_reg_read(wm, AC97_GPIO_STATUS);\r\nif (status & gpio)\r\nret = WM97XX_GPIO_HIGH;\r\nelse\r\nret = WM97XX_GPIO_LOW;\r\nmutex_unlock(&wm->codec_mutex);\r\nreturn ret;\r\n}\r\nvoid wm97xx_set_gpio(struct wm97xx *wm, u32 gpio,\r\nenum wm97xx_gpio_status status)\r\n{\r\nu16 reg;\r\nmutex_lock(&wm->codec_mutex);\r\nreg = wm97xx_reg_read(wm, AC97_GPIO_STATUS);\r\nif (status == WM97XX_GPIO_HIGH)\r\nreg |= gpio;\r\nelse\r\nreg &= ~gpio;\r\nif (wm->id == WM9712_ID2 && wm->variant != WM97xx_WM1613)\r\nwm97xx_reg_write(wm, AC97_GPIO_STATUS, reg << 1);\r\nelse\r\nwm97xx_reg_write(wm, AC97_GPIO_STATUS, reg);\r\nmutex_unlock(&wm->codec_mutex);\r\n}\r\nvoid wm97xx_config_gpio(struct wm97xx *wm, u32 gpio, enum wm97xx_gpio_dir dir,\r\nenum wm97xx_gpio_pol pol, enum wm97xx_gpio_sticky sticky,\r\nenum wm97xx_gpio_wake wake)\r\n{\r\nu16 reg;\r\nmutex_lock(&wm->codec_mutex);\r\nreg = wm97xx_reg_read(wm, AC97_GPIO_POLARITY);\r\nif (pol == WM97XX_GPIO_POL_HIGH)\r\nreg |= gpio;\r\nelse\r\nreg &= ~gpio;\r\nwm97xx_reg_write(wm, AC97_GPIO_POLARITY, reg);\r\nreg = wm97xx_reg_read(wm, AC97_GPIO_STICKY);\r\nif (sticky == WM97XX_GPIO_STICKY)\r\nreg |= gpio;\r\nelse\r\nreg &= ~gpio;\r\nwm97xx_reg_write(wm, AC97_GPIO_STICKY, reg);\r\nreg = wm97xx_reg_read(wm, AC97_GPIO_WAKEUP);\r\nif (wake == WM97XX_GPIO_WAKE)\r\nreg |= gpio;\r\nelse\r\nreg &= ~gpio;\r\nwm97xx_reg_write(wm, AC97_GPIO_WAKEUP, reg);\r\nreg = wm97xx_reg_read(wm, AC97_GPIO_CFG);\r\nif (dir == WM97XX_GPIO_IN)\r\nreg |= gpio;\r\nelse\r\nreg &= ~gpio;\r\nwm97xx_reg_write(wm, AC97_GPIO_CFG, reg);\r\nmutex_unlock(&wm->codec_mutex);\r\n}\r\nvoid wm97xx_set_suspend_mode(struct wm97xx *wm, u16 mode)\r\n{\r\nwm->suspend_mode = mode;\r\ndevice_init_wakeup(&wm->input_dev->dev, mode != 0);\r\n}\r\nstatic void wm97xx_pen_irq_worker(struct work_struct *work)\r\n{\r\nstruct wm97xx *wm = container_of(work, struct wm97xx, pen_event_work);\r\nint pen_was_down = wm->pen_is_down;\r\nif (wm->id == WM9705_ID2) {\r\nif (wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD) &\r\nWM97XX_PEN_DOWN)\r\nwm->pen_is_down = 1;\r\nelse\r\nwm->pen_is_down = 0;\r\n} else {\r\nu16 status, pol;\r\nmutex_lock(&wm->codec_mutex);\r\nstatus = wm97xx_reg_read(wm, AC97_GPIO_STATUS);\r\npol = wm97xx_reg_read(wm, AC97_GPIO_POLARITY);\r\nif (WM97XX_GPIO_13 & pol & status) {\r\nwm->pen_is_down = 1;\r\nwm97xx_reg_write(wm, AC97_GPIO_POLARITY, pol &\r\n~WM97XX_GPIO_13);\r\n} else {\r\nwm->pen_is_down = 0;\r\nwm97xx_reg_write(wm, AC97_GPIO_POLARITY, pol |\r\nWM97XX_GPIO_13);\r\n}\r\nif (wm->id == WM9712_ID2 && wm->variant != WM97xx_WM1613)\r\nwm97xx_reg_write(wm, AC97_GPIO_STATUS, (status &\r\n~WM97XX_GPIO_13) << 1);\r\nelse\r\nwm97xx_reg_write(wm, AC97_GPIO_STATUS, status &\r\n~WM97XX_GPIO_13);\r\nmutex_unlock(&wm->codec_mutex);\r\n}\r\nif (!wm->mach_ops->acc_enabled || wm->mach_ops->acc_pen_down) {\r\nif (wm->pen_is_down && !pen_was_down) {\r\nqueue_delayed_work(wm->ts_workq, &wm->ts_reader, 1);\r\n}\r\nif (!wm->pen_is_down && pen_was_down)\r\nwm->pen_is_down = 1;\r\n}\r\nif (!wm->pen_is_down && wm->mach_ops->acc_enabled)\r\nwm->mach_ops->acc_pen_up(wm);\r\nwm->mach_ops->irq_enable(wm, 1);\r\n}\r\nstatic irqreturn_t wm97xx_pen_interrupt(int irq, void *dev_id)\r\n{\r\nstruct wm97xx *wm = dev_id;\r\nif (!work_pending(&wm->pen_event_work)) {\r\nwm->mach_ops->irq_enable(wm, 0);\r\nqueue_work(wm->ts_workq, &wm->pen_event_work);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm97xx_init_pen_irq(struct wm97xx *wm)\r\n{\r\nu16 reg;\r\nBUG_ON(!wm->mach_ops->irq_enable);\r\nif (request_irq(wm->pen_irq, wm97xx_pen_interrupt, IRQF_SHARED,\r\n"wm97xx-pen", wm)) {\r\ndev_err(wm->dev,\r\n"Failed to register pen down interrupt, polling");\r\nwm->pen_irq = 0;\r\nreturn -EINVAL;\r\n}\r\nif (wm->id != WM9705_ID2) {\r\nBUG_ON(!wm->mach_ops->irq_gpio);\r\nreg = wm97xx_reg_read(wm, AC97_MISC_AFE);\r\nwm97xx_reg_write(wm, AC97_MISC_AFE,\r\nreg & ~(wm->mach_ops->irq_gpio));\r\nreg = wm97xx_reg_read(wm, 0x5a);\r\nwm97xx_reg_write(wm, 0x5a, reg & ~0x0001);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm97xx_read_samples(struct wm97xx *wm)\r\n{\r\nstruct wm97xx_data data;\r\nint rc;\r\nmutex_lock(&wm->codec_mutex);\r\nif (wm->mach_ops && wm->mach_ops->acc_enabled)\r\nrc = wm->mach_ops->acc_pen_down(wm);\r\nelse\r\nrc = wm->codec->poll_touch(wm, &data);\r\nif (rc & RC_PENUP) {\r\nif (wm->pen_is_down) {\r\nwm->pen_is_down = 0;\r\ndev_dbg(wm->dev, "pen up\n");\r\ninput_report_abs(wm->input_dev, ABS_PRESSURE, 0);\r\ninput_report_key(wm->input_dev, BTN_TOUCH, 0);\r\ninput_sync(wm->input_dev);\r\n} else if (!(rc & RC_AGAIN)) {\r\nif (wm->ts_reader_interval < HZ / 10)\r\nwm->ts_reader_interval++;\r\n}\r\n} else if (rc & RC_VALID) {\r\ndev_dbg(wm->dev,\r\n"pen down: x=%x:%d, y=%x:%d, pressure=%x:%d\n",\r\ndata.x >> 12, data.x & 0xfff, data.y >> 12,\r\ndata.y & 0xfff, data.p >> 12, data.p & 0xfff);\r\nif (abs_x[0] > (data.x & 0xfff) ||\r\nabs_x[1] < (data.x & 0xfff) ||\r\nabs_y[0] > (data.y & 0xfff) ||\r\nabs_y[1] < (data.y & 0xfff)) {\r\ndev_dbg(wm->dev, "Measurement out of range, dropping it\n");\r\nrc = RC_AGAIN;\r\ngoto out;\r\n}\r\ninput_report_abs(wm->input_dev, ABS_X, data.x & 0xfff);\r\ninput_report_abs(wm->input_dev, ABS_Y, data.y & 0xfff);\r\ninput_report_abs(wm->input_dev, ABS_PRESSURE, data.p & 0xfff);\r\ninput_report_key(wm->input_dev, BTN_TOUCH, 1);\r\ninput_sync(wm->input_dev);\r\nwm->pen_is_down = 1;\r\nwm->ts_reader_interval = wm->ts_reader_min_interval;\r\n} else if (rc & RC_PENDOWN) {\r\ndev_dbg(wm->dev, "pen down\n");\r\nwm->pen_is_down = 1;\r\nwm->ts_reader_interval = wm->ts_reader_min_interval;\r\n}\r\nout:\r\nmutex_unlock(&wm->codec_mutex);\r\nreturn rc;\r\n}\r\nstatic void wm97xx_ts_reader(struct work_struct *work)\r\n{\r\nint rc;\r\nstruct wm97xx *wm = container_of(work, struct wm97xx, ts_reader.work);\r\nBUG_ON(!wm->codec);\r\ndo {\r\nrc = wm97xx_read_samples(wm);\r\n} while (rc & RC_AGAIN);\r\nif (wm->pen_is_down || !wm->pen_irq)\r\nqueue_delayed_work(wm->ts_workq, &wm->ts_reader,\r\nwm->ts_reader_interval);\r\n}\r\nstatic int wm97xx_ts_input_open(struct input_dev *idev)\r\n{\r\nstruct wm97xx *wm = input_get_drvdata(idev);\r\nwm->ts_workq = create_singlethread_workqueue("kwm97xx");\r\nif (wm->ts_workq == NULL) {\r\ndev_err(wm->dev,\r\n"Failed to create workqueue\n");\r\nreturn -EINVAL;\r\n}\r\nif (wm->mach_ops && wm->mach_ops->acc_enabled)\r\nwm->codec->acc_enable(wm, 1);\r\nwm->codec->dig_enable(wm, 1);\r\nINIT_DELAYED_WORK(&wm->ts_reader, wm97xx_ts_reader);\r\nINIT_WORK(&wm->pen_event_work, wm97xx_pen_irq_worker);\r\nwm->ts_reader_min_interval = HZ >= 100 ? HZ / 100 : 1;\r\nif (wm->ts_reader_min_interval < 1)\r\nwm->ts_reader_min_interval = 1;\r\nwm->ts_reader_interval = wm->ts_reader_min_interval;\r\nwm->pen_is_down = 0;\r\nif (wm->pen_irq)\r\nwm97xx_init_pen_irq(wm);\r\nelse\r\ndev_err(wm->dev, "No IRQ specified\n");\r\nif (wm->pen_irq == 0)\r\nqueue_delayed_work(wm->ts_workq, &wm->ts_reader,\r\nwm->ts_reader_interval);\r\nreturn 0;\r\n}\r\nstatic void wm97xx_ts_input_close(struct input_dev *idev)\r\n{\r\nstruct wm97xx *wm = input_get_drvdata(idev);\r\nu16 reg;\r\nif (wm->pen_irq) {\r\nif (wm->id != WM9705_ID2) {\r\nBUG_ON(!wm->mach_ops->irq_gpio);\r\nreg = wm97xx_reg_read(wm, AC97_MISC_AFE);\r\nwm97xx_reg_write(wm, AC97_MISC_AFE,\r\nreg | wm->mach_ops->irq_gpio);\r\n}\r\nfree_irq(wm->pen_irq, wm);\r\n}\r\nwm->pen_is_down = 0;\r\nif (cancel_work_sync(&wm->pen_event_work))\r\nwm->mach_ops->irq_enable(wm, 1);\r\ncancel_delayed_work_sync(&wm->ts_reader);\r\ndestroy_workqueue(wm->ts_workq);\r\nwm->codec->dig_enable(wm, 0);\r\nif (wm->mach_ops && wm->mach_ops->acc_enabled)\r\nwm->codec->acc_enable(wm, 0);\r\n}\r\nstatic int wm97xx_probe(struct device *dev)\r\n{\r\nstruct wm97xx *wm;\r\nstruct wm97xx_pdata *pdata = dev->platform_data;\r\nint ret = 0, id = 0;\r\nwm = kzalloc(sizeof(struct wm97xx), GFP_KERNEL);\r\nif (!wm)\r\nreturn -ENOMEM;\r\nmutex_init(&wm->codec_mutex);\r\nwm->dev = dev;\r\ndev_set_drvdata(dev, wm);\r\nwm->ac97 = to_ac97_t(dev);\r\nid = wm97xx_reg_read(wm, AC97_VENDOR_ID1);\r\nif (id != WM97XX_ID1) {\r\ndev_err(dev, "Device with vendor %04x is not a wm97xx\n", id);\r\nret = -ENODEV;\r\ngoto alloc_err;\r\n}\r\nwm->id = wm97xx_reg_read(wm, AC97_VENDOR_ID2);\r\nwm->variant = WM97xx_GENERIC;\r\ndev_info(wm->dev, "detected a wm97%02x codec\n", wm->id & 0xff);\r\nswitch (wm->id & 0xff) {\r\n#ifdef CONFIG_TOUCHSCREEN_WM9705\r\ncase 0x05:\r\nwm->codec = &wm9705_codec;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_TOUCHSCREEN_WM9712\r\ncase 0x12:\r\nwm->codec = &wm9712_codec;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_TOUCHSCREEN_WM9713\r\ncase 0x13:\r\nwm->codec = &wm9713_codec;\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(wm->dev, "Support for wm97%02x not compiled in.\n",\r\nwm->id & 0xff);\r\nret = -ENODEV;\r\ngoto alloc_err;\r\n}\r\nwm->codec->phy_init(wm);\r\nwm->gpio[0] = wm97xx_reg_read(wm, AC97_GPIO_CFG);\r\nwm->gpio[1] = wm97xx_reg_read(wm, AC97_GPIO_POLARITY);\r\nwm->gpio[2] = wm97xx_reg_read(wm, AC97_GPIO_STICKY);\r\nwm->gpio[3] = wm97xx_reg_read(wm, AC97_GPIO_WAKEUP);\r\nwm->gpio[4] = wm97xx_reg_read(wm, AC97_GPIO_STATUS);\r\nwm->gpio[5] = wm97xx_reg_read(wm, AC97_MISC_AFE);\r\nwm->input_dev = input_allocate_device();\r\nif (wm->input_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto alloc_err;\r\n}\r\nwm->input_dev->name = "wm97xx touchscreen";\r\nwm->input_dev->phys = "wm97xx";\r\nwm->input_dev->open = wm97xx_ts_input_open;\r\nwm->input_dev->close = wm97xx_ts_input_close;\r\n__set_bit(EV_ABS, wm->input_dev->evbit);\r\n__set_bit(EV_KEY, wm->input_dev->evbit);\r\n__set_bit(BTN_TOUCH, wm->input_dev->keybit);\r\ninput_set_abs_params(wm->input_dev, ABS_X, abs_x[0], abs_x[1],\r\nabs_x[2], 0);\r\ninput_set_abs_params(wm->input_dev, ABS_Y, abs_y[0], abs_y[1],\r\nabs_y[2], 0);\r\ninput_set_abs_params(wm->input_dev, ABS_PRESSURE, abs_p[0], abs_p[1],\r\nabs_p[2], 0);\r\ninput_set_drvdata(wm->input_dev, wm);\r\nwm->input_dev->dev.parent = dev;\r\nret = input_register_device(wm->input_dev);\r\nif (ret < 0)\r\ngoto dev_alloc_err;\r\nwm->battery_dev = platform_device_alloc("wm97xx-battery", -1);\r\nif (!wm->battery_dev) {\r\nret = -ENOMEM;\r\ngoto batt_err;\r\n}\r\nplatform_set_drvdata(wm->battery_dev, wm);\r\nwm->battery_dev->dev.parent = dev;\r\nwm->battery_dev->dev.platform_data = pdata;\r\nret = platform_device_add(wm->battery_dev);\r\nif (ret < 0)\r\ngoto batt_reg_err;\r\nwm->touch_dev = platform_device_alloc("wm97xx-touch", -1);\r\nif (!wm->touch_dev) {\r\nret = -ENOMEM;\r\ngoto touch_err;\r\n}\r\nplatform_set_drvdata(wm->touch_dev, wm);\r\nwm->touch_dev->dev.parent = dev;\r\nwm->touch_dev->dev.platform_data = pdata;\r\nret = platform_device_add(wm->touch_dev);\r\nif (ret < 0)\r\ngoto touch_reg_err;\r\nreturn ret;\r\ntouch_reg_err:\r\nplatform_device_put(wm->touch_dev);\r\ntouch_err:\r\nplatform_device_del(wm->battery_dev);\r\nbatt_reg_err:\r\nplatform_device_put(wm->battery_dev);\r\nbatt_err:\r\ninput_unregister_device(wm->input_dev);\r\nwm->input_dev = NULL;\r\ndev_alloc_err:\r\ninput_free_device(wm->input_dev);\r\nalloc_err:\r\nkfree(wm);\r\nreturn ret;\r\n}\r\nstatic int wm97xx_remove(struct device *dev)\r\n{\r\nstruct wm97xx *wm = dev_get_drvdata(dev);\r\nplatform_device_unregister(wm->battery_dev);\r\nplatform_device_unregister(wm->touch_dev);\r\ninput_unregister_device(wm->input_dev);\r\nkfree(wm);\r\nreturn 0;\r\n}\r\nstatic int wm97xx_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct wm97xx *wm = dev_get_drvdata(dev);\r\nu16 reg;\r\nint suspend_mode;\r\nif (device_may_wakeup(&wm->input_dev->dev))\r\nsuspend_mode = wm->suspend_mode;\r\nelse\r\nsuspend_mode = 0;\r\nif (wm->input_dev->users)\r\ncancel_delayed_work_sync(&wm->ts_reader);\r\nreg = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER2);\r\nreg &= ~WM97XX_PRP_DET_DIG;\r\nif (wm->input_dev->users)\r\nreg |= suspend_mode;\r\nwm->ac97->bus->ops->write(wm->ac97, AC97_WM97XX_DIGITISER2, reg);\r\nif (wm->id == WM9713_ID2 &&\r\n(!wm->input_dev->users || !suspend_mode)) {\r\nreg = wm97xx_reg_read(wm, AC97_EXTENDED_MID) | 0x8000;\r\nwm97xx_reg_write(wm, AC97_EXTENDED_MID, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm97xx_resume(struct device *dev)\r\n{\r\nstruct wm97xx *wm = dev_get_drvdata(dev);\r\nif (wm->id == WM9713_ID2) {\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG1, wm->dig[0]);\r\nwm97xx_reg_write(wm, 0x5a, wm->misc);\r\nif (wm->input_dev->users) {\r\nu16 reg;\r\nreg = wm97xx_reg_read(wm, AC97_EXTENDED_MID) & 0x7fff;\r\nwm97xx_reg_write(wm, AC97_EXTENDED_MID, reg);\r\n}\r\n}\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG2, wm->dig[1]);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG3, wm->dig[2]);\r\nwm97xx_reg_write(wm, AC97_GPIO_CFG, wm->gpio[0]);\r\nwm97xx_reg_write(wm, AC97_GPIO_POLARITY, wm->gpio[1]);\r\nwm97xx_reg_write(wm, AC97_GPIO_STICKY, wm->gpio[2]);\r\nwm97xx_reg_write(wm, AC97_GPIO_WAKEUP, wm->gpio[3]);\r\nwm97xx_reg_write(wm, AC97_GPIO_STATUS, wm->gpio[4]);\r\nwm97xx_reg_write(wm, AC97_MISC_AFE, wm->gpio[5]);\r\nif (wm->input_dev->users && !wm->pen_irq) {\r\nwm->ts_reader_interval = wm->ts_reader_min_interval;\r\nqueue_delayed_work(wm->ts_workq, &wm->ts_reader,\r\nwm->ts_reader_interval);\r\n}\r\nreturn 0;\r\n}\r\nint wm97xx_register_mach_ops(struct wm97xx *wm,\r\nstruct wm97xx_mach_ops *mach_ops)\r\n{\r\nmutex_lock(&wm->codec_mutex);\r\nif (wm->mach_ops) {\r\nmutex_unlock(&wm->codec_mutex);\r\nreturn -EINVAL;\r\n}\r\nwm->mach_ops = mach_ops;\r\nmutex_unlock(&wm->codec_mutex);\r\nreturn 0;\r\n}\r\nvoid wm97xx_unregister_mach_ops(struct wm97xx *wm)\r\n{\r\nmutex_lock(&wm->codec_mutex);\r\nwm->mach_ops = NULL;\r\nmutex_unlock(&wm->codec_mutex);\r\n}\r\nstatic int __init wm97xx_init(void)\r\n{\r\nreturn driver_register(&wm97xx_driver);\r\n}\r\nstatic void __exit wm97xx_exit(void)\r\n{\r\ndriver_unregister(&wm97xx_driver);\r\n}
