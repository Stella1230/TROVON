static struct iscsi_login *iscsi_login_init_conn(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_login *login;\r\nlogin = kzalloc(sizeof(struct iscsi_login), GFP_KERNEL);\r\nif (!login) {\r\npr_err("Unable to allocate memory for struct iscsi_login.\n");\r\nreturn NULL;\r\n}\r\nlogin->conn = conn;\r\nlogin->first_request = 1;\r\nlogin->req_buf = kzalloc(MAX_KEY_VALUE_PAIRS, GFP_KERNEL);\r\nif (!login->req_buf) {\r\npr_err("Unable to allocate memory for response buffer.\n");\r\ngoto out_login;\r\n}\r\nlogin->rsp_buf = kzalloc(MAX_KEY_VALUE_PAIRS, GFP_KERNEL);\r\nif (!login->rsp_buf) {\r\npr_err("Unable to allocate memory for request buffer.\n");\r\ngoto out_req_buf;\r\n}\r\nconn->conn_ops = kzalloc(sizeof(struct iscsi_conn_ops), GFP_KERNEL);\r\nif (!conn->conn_ops) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_conn_ops.\n");\r\ngoto out_rsp_buf;\r\n}\r\ninit_waitqueue_head(&conn->queues_wq);\r\nINIT_LIST_HEAD(&conn->conn_list);\r\nINIT_LIST_HEAD(&conn->conn_cmd_list);\r\nINIT_LIST_HEAD(&conn->immed_queue_list);\r\nINIT_LIST_HEAD(&conn->response_queue_list);\r\ninit_completion(&conn->conn_post_wait_comp);\r\ninit_completion(&conn->conn_wait_comp);\r\ninit_completion(&conn->conn_wait_rcfr_comp);\r\ninit_completion(&conn->conn_waiting_on_uc_comp);\r\ninit_completion(&conn->conn_logout_comp);\r\ninit_completion(&conn->rx_half_close_comp);\r\ninit_completion(&conn->tx_half_close_comp);\r\nspin_lock_init(&conn->cmd_lock);\r\nspin_lock_init(&conn->conn_usage_lock);\r\nspin_lock_init(&conn->immed_queue_lock);\r\nspin_lock_init(&conn->nopin_timer_lock);\r\nspin_lock_init(&conn->response_queue_lock);\r\nspin_lock_init(&conn->state_lock);\r\nif (!zalloc_cpumask_var(&conn->conn_cpumask, GFP_KERNEL)) {\r\npr_err("Unable to allocate conn->conn_cpumask\n");\r\ngoto out_conn_ops;\r\n}\r\nconn->conn_login = login;\r\nreturn login;\r\nout_conn_ops:\r\nkfree(conn->conn_ops);\r\nout_rsp_buf:\r\nkfree(login->rsp_buf);\r\nout_req_buf:\r\nkfree(login->req_buf);\r\nout_login:\r\nkfree(login);\r\nreturn NULL;\r\n}\r\nint iscsi_login_setup_crypto(struct iscsi_conn *conn)\r\n{\r\nconn->conn_rx_hash.flags = 0;\r\nconn->conn_rx_hash.tfm = crypto_alloc_hash("crc32c", 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(conn->conn_rx_hash.tfm)) {\r\npr_err("crypto_alloc_hash() failed for conn_rx_tfm\n");\r\nreturn -ENOMEM;\r\n}\r\nconn->conn_tx_hash.flags = 0;\r\nconn->conn_tx_hash.tfm = crypto_alloc_hash("crc32c", 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(conn->conn_tx_hash.tfm)) {\r\npr_err("crypto_alloc_hash() failed for conn_tx_tfm\n");\r\ncrypto_free_hash(conn->conn_rx_hash.tfm);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_login_check_initiator_version(\r\nstruct iscsi_conn *conn,\r\nu8 version_max,\r\nu8 version_min)\r\n{\r\nif ((version_max != 0x00) || (version_min != 0x00)) {\r\npr_err("Unsupported iSCSI IETF Pre-RFC Revision,"\r\n" version Min/Max 0x%02x/0x%02x, rejecting login.\n",\r\nversion_min, version_max);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_NO_VERSION);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint iscsi_check_for_session_reinstatement(struct iscsi_conn *conn)\r\n{\r\nint sessiontype;\r\nstruct iscsi_param *initiatorname_param = NULL, *sessiontype_param = NULL;\r\nstruct iscsi_portal_group *tpg = conn->tpg;\r\nstruct iscsi_session *sess = NULL, *sess_p = NULL;\r\nstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\r\nstruct se_session *se_sess, *se_sess_tmp;\r\ninitiatorname_param = iscsi_find_param_from_key(\r\nINITIATORNAME, conn->param_list);\r\nsessiontype_param = iscsi_find_param_from_key(\r\nSESSIONTYPE, conn->param_list);\r\nif (!initiatorname_param || !sessiontype_param) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_MISSING_FIELDS);\r\nreturn -1;\r\n}\r\nsessiontype = (strncmp(sessiontype_param->value, NORMAL, 6)) ? 1 : 0;\r\nspin_lock_bh(&se_tpg->session_lock);\r\nlist_for_each_entry_safe(se_sess, se_sess_tmp, &se_tpg->tpg_sess_list,\r\nsess_list) {\r\nsess_p = se_sess->fabric_sess_ptr;\r\nspin_lock(&sess_p->conn_lock);\r\nif (atomic_read(&sess_p->session_fall_back_to_erl0) ||\r\natomic_read(&sess_p->session_logout) ||\r\n(sess_p->time2retain_timer_flags & ISCSI_TF_EXPIRED)) {\r\nspin_unlock(&sess_p->conn_lock);\r\ncontinue;\r\n}\r\nif (!memcmp(sess_p->isid, conn->sess->isid, 6) &&\r\n(!strcmp(sess_p->sess_ops->InitiatorName,\r\ninitiatorname_param->value) &&\r\n(sess_p->sess_ops->SessionType == sessiontype))) {\r\natomic_set(&sess_p->session_reinstatement, 1);\r\nspin_unlock(&sess_p->conn_lock);\r\niscsit_inc_session_usage_count(sess_p);\r\niscsit_stop_time2retain_timer(sess_p);\r\nsess = sess_p;\r\nbreak;\r\n}\r\nspin_unlock(&sess_p->conn_lock);\r\n}\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nif (!sess)\r\nreturn 0;\r\npr_debug("%s iSCSI Session SID %u is still active for %s,"\r\n" preforming session reinstatement.\n", (sessiontype) ?\r\n"Discovery" : "Normal", sess->sid,\r\nsess->sess_ops->InitiatorName);\r\nspin_lock_bh(&sess->conn_lock);\r\nif (sess->session_state == TARG_SESS_STATE_FAILED) {\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_dec_session_usage_count(sess);\r\ntarget_put_session(sess->se_sess);\r\nreturn 0;\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsit_stop_session(sess, 1, 1);\r\niscsit_dec_session_usage_count(sess);\r\ntarget_put_session(sess->se_sess);\r\nreturn 0;\r\n}\r\nstatic void iscsi_login_set_conn_values(\r\nstruct iscsi_session *sess,\r\nstruct iscsi_conn *conn,\r\n__be16 cid)\r\n{\r\nconn->sess = sess;\r\nconn->cid = be16_to_cpu(cid);\r\nget_random_bytes(&conn->stat_sn, sizeof(u32));\r\nmutex_lock(&auth_id_lock);\r\nconn->auth_id = iscsit_global->auth_id++;\r\nmutex_unlock(&auth_id_lock);\r\n}\r\nstatic int iscsi_login_zero_tsih_s1(\r\nstruct iscsi_conn *conn,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_session *sess = NULL;\r\nstruct iscsi_login_req *pdu = (struct iscsi_login_req *)buf;\r\nint ret;\r\nsess = kzalloc(sizeof(struct iscsi_session), GFP_KERNEL);\r\nif (!sess) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\npr_err("Could not allocate memory for session\n");\r\nreturn -ENOMEM;\r\n}\r\niscsi_login_set_conn_values(sess, conn, pdu->cid);\r\nsess->init_task_tag = pdu->itt;\r\nmemcpy(&sess->isid, pdu->isid, 6);\r\nsess->exp_cmd_sn = be32_to_cpu(pdu->cmdsn);\r\nINIT_LIST_HEAD(&sess->sess_conn_list);\r\nINIT_LIST_HEAD(&sess->sess_ooo_cmdsn_list);\r\nINIT_LIST_HEAD(&sess->cr_active_list);\r\nINIT_LIST_HEAD(&sess->cr_inactive_list);\r\ninit_completion(&sess->async_msg_comp);\r\ninit_completion(&sess->reinstatement_comp);\r\ninit_completion(&sess->session_wait_comp);\r\ninit_completion(&sess->session_waiting_on_uc_comp);\r\nmutex_init(&sess->cmdsn_mutex);\r\nspin_lock_init(&sess->conn_lock);\r\nspin_lock_init(&sess->cr_a_lock);\r\nspin_lock_init(&sess->cr_i_lock);\r\nspin_lock_init(&sess->session_usage_lock);\r\nspin_lock_init(&sess->ttt_lock);\r\nidr_preload(GFP_KERNEL);\r\nspin_lock_bh(&sess_idr_lock);\r\nret = idr_alloc(&sess_idr, NULL, 0, 0, GFP_NOWAIT);\r\nif (ret >= 0)\r\nsess->session_index = ret;\r\nspin_unlock_bh(&sess_idr_lock);\r\nidr_preload_end();\r\nif (ret < 0) {\r\npr_err("idr_alloc() for sess_idr failed\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nkfree(sess);\r\nreturn -ENOMEM;\r\n}\r\nsess->creation_time = get_jiffies_64();\r\nspin_lock_init(&sess->session_stats_lock);\r\nsess->max_cmd_sn = be32_to_cpu(pdu->cmdsn);\r\nsess->sess_ops = kzalloc(sizeof(struct iscsi_sess_ops), GFP_KERNEL);\r\nif (!sess->sess_ops) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_sess_ops.\n");\r\nkfree(sess);\r\nreturn -ENOMEM;\r\n}\r\nsess->se_sess = transport_init_session();\r\nif (IS_ERR(sess->se_sess)) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nkfree(sess);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_login_zero_tsih_s2(\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_node_attrib *na;\r\nstruct iscsi_session *sess = conn->sess;\r\nunsigned char buf[32];\r\nbool iser = false;\r\nsess->tpg = conn->tpg;\r\nsess->tsih = ++ISCSI_TPG_S(sess)->ntsih;\r\nif (!sess->tsih)\r\nsess->tsih = ++ISCSI_TPG_S(sess)->ntsih;\r\nif (iscsi_copy_param_list(&conn->param_list,\r\nISCSI_TPG_C(conn)->param_list, 1) < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nif (conn->conn_transport->transport_type == ISCSI_INFINIBAND)\r\niser = true;\r\niscsi_set_keys_to_negotiate(conn->param_list, iser);\r\nif (sess->sess_ops->SessionType)\r\nreturn iscsi_set_keys_irrelevant_for_discovery(\r\nconn->param_list);\r\nna = iscsit_tpg_get_node_attrib(sess);\r\nmemset(buf, 0, 32);\r\nsprintf(buf, "TargetPortalGroupTag=%hu", ISCSI_TPG_S(sess)->tpgt);\r\nif (iscsi_change_param_value(buf, conn->param_list, 0) < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nmemset(buf, 0, 32);\r\nsprintf(buf, "ErrorRecoveryLevel=%d", na->default_erl);\r\nif (iscsi_change_param_value(buf, conn->param_list, 0) < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nif (iscsi_login_disable_FIM_keys(conn->param_list, conn) < 0)\r\nreturn -1;\r\nif (iser) {\r\nstruct iscsi_param *param;\r\nunsigned long mrdsl, off;\r\nint rc;\r\nsprintf(buf, "RDMAExtensions=Yes");\r\nif (iscsi_change_param_value(buf, conn->param_list, 0) < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nparam = iscsi_find_param_from_key("MaxRecvDataSegmentLength",\r\nconn->param_list);\r\nif (!param) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nrc = strict_strtoul(param->value, 0, &mrdsl);\r\nif (rc < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\noff = mrdsl % PAGE_SIZE;\r\nif (!off)\r\nreturn 0;\r\nif (mrdsl < PAGE_SIZE)\r\nmrdsl = PAGE_SIZE;\r\nelse\r\nmrdsl -= off;\r\npr_warn("Aligning ISER MaxRecvDataSegmentLength: %lu down"\r\n" to PAGE_SIZE\n", mrdsl);\r\nsprintf(buf, "MaxRecvDataSegmentLength=%lu\n", mrdsl);\r\nif (iscsi_change_param_value(buf, conn->param_list, 0) < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iscsi_login_disable_FIM_keys(\r\nstruct iscsi_param_list *param_list,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_param *param;\r\nparam = iscsi_find_param_from_key("OFMarker", param_list);\r\nif (!param) {\r\npr_err("iscsi_find_param_from_key() for"\r\n" OFMarker failed\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nparam = iscsi_find_param_from_key("OFMarkInt", param_list);\r\nif (!param) {\r\npr_err("iscsi_find_param_from_key() for"\r\n" IFMarker failed\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nparam = iscsi_find_param_from_key("IFMarker", param_list);\r\nif (!param) {\r\npr_err("iscsi_find_param_from_key() for"\r\n" IFMarker failed\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nparam = iscsi_find_param_from_key("IFMarkInt", param_list);\r\nif (!param) {\r\npr_err("iscsi_find_param_from_key() for"\r\n" IFMarker failed\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nparam->state &= ~PSTATE_NEGOTIATE;\r\nreturn 0;\r\n}\r\nstatic int iscsi_login_non_zero_tsih_s1(\r\nstruct iscsi_conn *conn,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_login_req *pdu = (struct iscsi_login_req *)buf;\r\niscsi_login_set_conn_values(NULL, conn, pdu->cid);\r\nreturn 0;\r\n}\r\nstatic int iscsi_login_non_zero_tsih_s2(\r\nstruct iscsi_conn *conn,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_portal_group *tpg = conn->tpg;\r\nstruct iscsi_session *sess = NULL, *sess_p = NULL;\r\nstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\r\nstruct se_session *se_sess, *se_sess_tmp;\r\nstruct iscsi_login_req *pdu = (struct iscsi_login_req *)buf;\r\nbool iser = false;\r\nspin_lock_bh(&se_tpg->session_lock);\r\nlist_for_each_entry_safe(se_sess, se_sess_tmp, &se_tpg->tpg_sess_list,\r\nsess_list) {\r\nsess_p = (struct iscsi_session *)se_sess->fabric_sess_ptr;\r\nif (atomic_read(&sess_p->session_fall_back_to_erl0) ||\r\natomic_read(&sess_p->session_logout) ||\r\n(sess_p->time2retain_timer_flags & ISCSI_TF_EXPIRED))\r\ncontinue;\r\nif (!memcmp(sess_p->isid, pdu->isid, 6) &&\r\n(sess_p->tsih == be16_to_cpu(pdu->tsih))) {\r\niscsit_inc_session_usage_count(sess_p);\r\niscsit_stop_time2retain_timer(sess_p);\r\nsess = sess_p;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&se_tpg->session_lock);\r\nif (!sess) {\r\npr_err("Initiator attempting to add a connection to"\r\n" a non-existent session, rejecting iSCSI Login.\n");\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_NO_SESSION);\r\nreturn -1;\r\n}\r\nspin_lock_bh(&sess->conn_lock);\r\nif (sess->session_state == TARG_SESS_STATE_FAILED)\r\natomic_set(&sess->session_continuation, 1);\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsi_login_set_conn_values(sess, conn, pdu->cid);\r\nif (iscsi_copy_param_list(&conn->param_list,\r\nISCSI_TPG_C(conn)->param_list, 0) < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nif (conn->conn_transport->transport_type == ISCSI_INFINIBAND)\r\niser = true;\r\niscsi_set_keys_to_negotiate(conn->param_list, iser);\r\nmemset(buf, 0, 32);\r\nsprintf(buf, "TargetPortalGroupTag=%hu", ISCSI_TPG_S(sess)->tpgt);\r\nif (iscsi_change_param_value(buf, conn->param_list, 0) < 0) {\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_NO_RESOURCES);\r\nreturn -1;\r\n}\r\nreturn iscsi_login_disable_FIM_keys(conn->param_list, conn);\r\n}\r\nint iscsi_login_post_auth_non_zero_tsih(\r\nstruct iscsi_conn *conn,\r\nu16 cid,\r\nu32 exp_statsn)\r\n{\r\nstruct iscsi_conn *conn_ptr = NULL;\r\nstruct iscsi_conn_recovery *cr = NULL;\r\nstruct iscsi_session *sess = conn->sess;\r\nconn_ptr = iscsit_get_conn_from_cid_rcfr(sess, cid);\r\nif (conn_ptr) {\r\npr_err("Connection exists with CID %hu for %s,"\r\n" performing connection reinstatement.\n",\r\nconn_ptr->cid, sess->sess_ops->InitiatorName);\r\niscsit_connection_reinstatement_rcfr(conn_ptr);\r\niscsit_dec_conn_usage_count(conn_ptr);\r\n}\r\nif (sess->sess_ops->ErrorRecoveryLevel == 2) {\r\ncr = iscsit_get_inactive_connection_recovery_entry(\r\nsess, cid);\r\nif (cr) {\r\npr_debug("Performing implicit logout"\r\n" for connection recovery on CID: %hu\n",\r\nconn->cid);\r\niscsit_discard_cr_cmds_by_expstatsn(cr, exp_statsn);\r\n}\r\n}\r\npr_debug("Adding CID %hu to existing session for %s.\n",\r\ncid, sess->sess_ops->InitiatorName);\r\nif ((atomic_read(&sess->nconn) + 1) > sess->sess_ops->MaxConnections) {\r\npr_err("Adding additional connection to this session"\r\n" would exceed MaxConnections %d, login failed.\n",\r\nsess->sess_ops->MaxConnections);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_ISID_ERROR);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void iscsi_post_login_start_timers(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nif (conn->conn_transport->transport_type == ISCSI_INFINIBAND)\r\nreturn;\r\nif (!sess->sess_ops->SessionType)\r\niscsit_start_nopin_timer(conn);\r\n}\r\nstatic int iscsi_post_login_handler(\r\nstruct iscsi_np *np,\r\nstruct iscsi_conn *conn,\r\nu8 zero_tsih)\r\n{\r\nint stop_timer = 0;\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct se_session *se_sess = sess->se_sess;\r\nstruct iscsi_portal_group *tpg = ISCSI_TPG_S(sess);\r\nstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\r\nstruct iscsi_thread_set *ts;\r\niscsit_inc_conn_usage_count(conn);\r\niscsit_collect_login_stats(conn, ISCSI_STATUS_CLS_SUCCESS,\r\nISCSI_LOGIN_STATUS_ACCEPT);\r\npr_debug("Moving to TARG_CONN_STATE_LOGGED_IN.\n");\r\nconn->conn_state = TARG_CONN_STATE_LOGGED_IN;\r\niscsi_set_connection_parameters(conn->conn_ops, conn->param_list);\r\niscsit_set_sync_and_steering_values(conn);\r\nts = iscsi_get_thread_set();\r\nif (!zero_tsih) {\r\niscsi_set_session_parameters(sess->sess_ops,\r\nconn->param_list, 0);\r\niscsi_release_param_list(conn->param_list);\r\nconn->param_list = NULL;\r\nspin_lock_bh(&sess->conn_lock);\r\natomic_set(&sess->session_continuation, 0);\r\nif (sess->session_state == TARG_SESS_STATE_FAILED) {\r\npr_debug("Moving to"\r\n" TARG_SESS_STATE_LOGGED_IN.\n");\r\nsess->session_state = TARG_SESS_STATE_LOGGED_IN;\r\nstop_timer = 1;\r\n}\r\npr_debug("iSCSI Login successful on CID: %hu from %s to"\r\n" %s:%hu,%hu\n", conn->cid, conn->login_ip,\r\nconn->local_ip, conn->local_port, tpg->tpgt);\r\nlist_add_tail(&conn->conn_list, &sess->sess_conn_list);\r\natomic_inc(&sess->nconn);\r\npr_debug("Incremented iSCSI Connection count to %hu"\r\n" from node: %s\n", atomic_read(&sess->nconn),\r\nsess->sess_ops->InitiatorName);\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsi_post_login_start_timers(conn);\r\niscsi_activate_thread_set(conn, ts);\r\niscsit_thread_get_cpumask(conn);\r\nconn->conn_rx_reset_cpumask = 1;\r\nconn->conn_tx_reset_cpumask = 1;\r\niscsit_dec_conn_usage_count(conn);\r\nif (stop_timer) {\r\nspin_lock_bh(&se_tpg->session_lock);\r\niscsit_stop_time2retain_timer(sess);\r\nspin_unlock_bh(&se_tpg->session_lock);\r\n}\r\niscsit_dec_session_usage_count(sess);\r\nreturn 0;\r\n}\r\niscsi_set_session_parameters(sess->sess_ops, conn->param_list, 1);\r\niscsi_release_param_list(conn->param_list);\r\nconn->param_list = NULL;\r\niscsit_determine_maxcmdsn(sess);\r\nspin_lock_bh(&se_tpg->session_lock);\r\n__transport_register_session(&sess->tpg->tpg_se_tpg,\r\nse_sess->se_node_acl, se_sess, sess);\r\npr_debug("Moving to TARG_SESS_STATE_LOGGED_IN.\n");\r\nsess->session_state = TARG_SESS_STATE_LOGGED_IN;\r\npr_debug("iSCSI Login successful on CID: %hu from %s to %s:%hu,%hu\n",\r\nconn->cid, conn->login_ip, conn->local_ip, conn->local_port,\r\ntpg->tpgt);\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_add_tail(&conn->conn_list, &sess->sess_conn_list);\r\natomic_inc(&sess->nconn);\r\npr_debug("Incremented iSCSI Connection count to %hu from node:"\r\n" %s\n", atomic_read(&sess->nconn),\r\nsess->sess_ops->InitiatorName);\r\nspin_unlock_bh(&sess->conn_lock);\r\nsess->sid = tpg->sid++;\r\nif (!sess->sid)\r\nsess->sid = tpg->sid++;\r\npr_debug("Established iSCSI session from node: %s\n",\r\nsess->sess_ops->InitiatorName);\r\ntpg->nsessions++;\r\nif (tpg->tpg_tiqn)\r\ntpg->tpg_tiqn->tiqn_nsessions++;\r\npr_debug("Incremented number of active iSCSI sessions to %u on"\r\n" iSCSI Target Portal Group: %hu\n", tpg->nsessions, tpg->tpgt);\r\nspin_unlock_bh(&se_tpg->session_lock);\r\niscsi_post_login_start_timers(conn);\r\niscsi_activate_thread_set(conn, ts);\r\niscsit_thread_get_cpumask(conn);\r\nconn->conn_rx_reset_cpumask = 1;\r\nconn->conn_tx_reset_cpumask = 1;\r\niscsit_dec_conn_usage_count(conn);\r\nreturn 0;\r\n}\r\nstatic void iscsi_handle_login_thread_timeout(unsigned long data)\r\n{\r\nstruct iscsi_np *np = (struct iscsi_np *) data;\r\nspin_lock_bh(&np->np_thread_lock);\r\npr_err("iSCSI Login timeout on Network Portal %s:%hu\n",\r\nnp->np_ip, np->np_port);\r\nif (np->np_login_timer_flags & ISCSI_TF_STOP) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\nreturn;\r\n}\r\nif (np->np_thread)\r\nsend_sig(SIGINT, np->np_thread, 1);\r\nnp->np_login_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&np->np_thread_lock);\r\n}\r\nstatic void iscsi_start_login_thread_timer(struct iscsi_np *np)\r\n{\r\nspin_lock_bh(&np->np_thread_lock);\r\ninit_timer(&np->np_login_timer);\r\nnp->np_login_timer.expires = (get_jiffies_64() + TA_LOGIN_TIMEOUT * HZ);\r\nnp->np_login_timer.data = (unsigned long)np;\r\nnp->np_login_timer.function = iscsi_handle_login_thread_timeout;\r\nnp->np_login_timer_flags &= ~ISCSI_TF_STOP;\r\nnp->np_login_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&np->np_login_timer);\r\npr_debug("Added timeout timer to iSCSI login request for"\r\n" %u seconds.\n", TA_LOGIN_TIMEOUT);\r\nspin_unlock_bh(&np->np_thread_lock);\r\n}\r\nstatic void iscsi_stop_login_thread_timer(struct iscsi_np *np)\r\n{\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (!(np->np_login_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\nreturn;\r\n}\r\nnp->np_login_timer_flags |= ISCSI_TF_STOP;\r\nspin_unlock_bh(&np->np_thread_lock);\r\ndel_timer_sync(&np->np_login_timer);\r\nspin_lock_bh(&np->np_thread_lock);\r\nnp->np_login_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&np->np_thread_lock);\r\n}\r\nint iscsit_setup_np(\r\nstruct iscsi_np *np,\r\nstruct __kernel_sockaddr_storage *sockaddr)\r\n{\r\nstruct socket *sock = NULL;\r\nint backlog = 5, ret, opt = 0, len;\r\nswitch (np->np_network_transport) {\r\ncase ISCSI_TCP:\r\nnp->np_ip_proto = IPPROTO_TCP;\r\nnp->np_sock_type = SOCK_STREAM;\r\nbreak;\r\ncase ISCSI_SCTP_TCP:\r\nnp->np_ip_proto = IPPROTO_SCTP;\r\nnp->np_sock_type = SOCK_STREAM;\r\nbreak;\r\ncase ISCSI_SCTP_UDP:\r\nnp->np_ip_proto = IPPROTO_SCTP;\r\nnp->np_sock_type = SOCK_SEQPACKET;\r\nbreak;\r\ndefault:\r\npr_err("Unsupported network_transport: %d\n",\r\nnp->np_network_transport);\r\nreturn -EINVAL;\r\n}\r\nnp->np_ip_proto = IPPROTO_TCP;\r\nnp->np_sock_type = SOCK_STREAM;\r\nret = sock_create(sockaddr->ss_family, np->np_sock_type,\r\nnp->np_ip_proto, &sock);\r\nif (ret < 0) {\r\npr_err("sock_create() failed.\n");\r\nreturn ret;\r\n}\r\nnp->np_socket = sock;\r\nmemcpy(&np->np_sockaddr, sockaddr,\r\nsizeof(struct __kernel_sockaddr_storage));\r\nif (sockaddr->ss_family == AF_INET6)\r\nlen = sizeof(struct sockaddr_in6);\r\nelse\r\nlen = sizeof(struct sockaddr_in);\r\nopt = 1;\r\nif (np->np_network_transport == ISCSI_TCP) {\r\nret = kernel_setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\r\n(char *)&opt, sizeof(opt));\r\nif (ret < 0) {\r\npr_err("kernel_setsockopt() for TCP_NODELAY"\r\n" failed: %d\n", ret);\r\ngoto fail;\r\n}\r\n}\r\nret = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\r\n(char *)&opt, sizeof(opt));\r\nif (ret < 0) {\r\npr_err("kernel_setsockopt() for SO_REUSEADDR"\r\n" failed\n");\r\ngoto fail;\r\n}\r\nret = kernel_setsockopt(sock, IPPROTO_IP, IP_FREEBIND,\r\n(char *)&opt, sizeof(opt));\r\nif (ret < 0) {\r\npr_err("kernel_setsockopt() for IP_FREEBIND"\r\n" failed\n");\r\ngoto fail;\r\n}\r\nret = kernel_bind(sock, (struct sockaddr *)&np->np_sockaddr, len);\r\nif (ret < 0) {\r\npr_err("kernel_bind() failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = kernel_listen(sock, backlog);\r\nif (ret != 0) {\r\npr_err("kernel_listen() failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nnp->np_socket = NULL;\r\nif (sock)\r\nsock_release(sock);\r\nreturn ret;\r\n}\r\nint iscsi_target_setup_login_socket(\r\nstruct iscsi_np *np,\r\nstruct __kernel_sockaddr_storage *sockaddr)\r\n{\r\nstruct iscsit_transport *t;\r\nint rc;\r\nt = iscsit_get_transport(np->np_network_transport);\r\nif (!t)\r\nreturn -EINVAL;\r\nrc = t->iscsit_setup_np(np, sockaddr);\r\nif (rc < 0) {\r\niscsit_put_transport(t);\r\nreturn rc;\r\n}\r\nnp->np_transport = t;\r\nreturn 0;\r\n}\r\nint iscsit_accept_np(struct iscsi_np *np, struct iscsi_conn *conn)\r\n{\r\nstruct socket *new_sock, *sock = np->np_socket;\r\nstruct sockaddr_in sock_in;\r\nstruct sockaddr_in6 sock_in6;\r\nint rc, err;\r\nrc = kernel_accept(sock, &new_sock, 0);\r\nif (rc < 0)\r\nreturn rc;\r\nconn->sock = new_sock;\r\nconn->login_family = np->np_sockaddr.ss_family;\r\nif (np->np_sockaddr.ss_family == AF_INET6) {\r\nmemset(&sock_in6, 0, sizeof(struct sockaddr_in6));\r\nrc = conn->sock->ops->getname(conn->sock,\r\n(struct sockaddr *)&sock_in6, &err, 1);\r\nif (!rc) {\r\nsnprintf(conn->login_ip, sizeof(conn->login_ip), "%pI6c",\r\n&sock_in6.sin6_addr.in6_u);\r\nconn->login_port = ntohs(sock_in6.sin6_port);\r\n}\r\nrc = conn->sock->ops->getname(conn->sock,\r\n(struct sockaddr *)&sock_in6, &err, 0);\r\nif (!rc) {\r\nsnprintf(conn->local_ip, sizeof(conn->local_ip), "%pI6c",\r\n&sock_in6.sin6_addr.in6_u);\r\nconn->local_port = ntohs(sock_in6.sin6_port);\r\n}\r\n} else {\r\nmemset(&sock_in, 0, sizeof(struct sockaddr_in));\r\nrc = conn->sock->ops->getname(conn->sock,\r\n(struct sockaddr *)&sock_in, &err, 1);\r\nif (!rc) {\r\nsprintf(conn->login_ip, "%pI4",\r\n&sock_in.sin_addr.s_addr);\r\nconn->login_port = ntohs(sock_in.sin_port);\r\n}\r\nrc = conn->sock->ops->getname(conn->sock,\r\n(struct sockaddr *)&sock_in, &err, 0);\r\nif (!rc) {\r\nsprintf(conn->local_ip, "%pI4",\r\n&sock_in.sin_addr.s_addr);\r\nconn->local_port = ntohs(sock_in.sin_port);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_get_login_rx(struct iscsi_conn *conn, struct iscsi_login *login)\r\n{\r\nstruct iscsi_login_req *login_req;\r\nu32 padding = 0, payload_length;\r\nif (iscsi_login_rx_data(conn, login->req, ISCSI_HDR_LEN) < 0)\r\nreturn -1;\r\nlogin_req = (struct iscsi_login_req *)login->req;\r\npayload_length = ntoh24(login_req->dlength);\r\npadding = ((-payload_length) & 3);\r\npr_debug("Got Login Command, Flags 0x%02x, ITT: 0x%08x,"\r\n" CmdSN: 0x%08x, ExpStatSN: 0x%08x, CID: %hu, Length: %u\n",\r\nlogin_req->flags, login_req->itt, login_req->cmdsn,\r\nlogin_req->exp_statsn, login_req->cid, payload_length);\r\nif (login->first_request) {\r\nlogin_req = (struct iscsi_login_req *)login->req;\r\nlogin->leading_connection = (!login_req->tsih) ? 1 : 0;\r\nlogin->current_stage = ISCSI_LOGIN_CURRENT_STAGE(login_req->flags);\r\nlogin->version_min = login_req->min_version;\r\nlogin->version_max = login_req->max_version;\r\nmemcpy(login->isid, login_req->isid, 6);\r\nlogin->cmd_sn = be32_to_cpu(login_req->cmdsn);\r\nlogin->init_task_tag = login_req->itt;\r\nlogin->initial_exp_statsn = be32_to_cpu(login_req->exp_statsn);\r\nlogin->cid = be16_to_cpu(login_req->cid);\r\nlogin->tsih = be16_to_cpu(login_req->tsih);\r\n}\r\nif (iscsi_target_check_login_request(conn, login) < 0)\r\nreturn -1;\r\nmemset(login->req_buf, 0, MAX_KEY_VALUE_PAIRS);\r\nif (iscsi_login_rx_data(conn, login->req_buf,\r\npayload_length + padding) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint iscsit_put_login_tx(struct iscsi_conn *conn, struct iscsi_login *login,\r\nu32 length)\r\n{\r\nif (iscsi_login_tx_data(conn, login->rsp, login->rsp_buf, length) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int\r\niscsit_conn_set_transport(struct iscsi_conn *conn, struct iscsit_transport *t)\r\n{\r\nint rc;\r\nif (!t->owner) {\r\nconn->conn_transport = t;\r\nreturn 0;\r\n}\r\nrc = try_module_get(t->owner);\r\nif (!rc) {\r\npr_err("try_module_get() failed for %s\n", t->name);\r\nreturn -EINVAL;\r\n}\r\nconn->conn_transport = t;\r\nreturn 0;\r\n}\r\nstatic int __iscsi_target_login_thread(struct iscsi_np *np)\r\n{\r\nu8 *buffer, zero_tsih = 0;\r\nint ret = 0, rc, stop;\r\nstruct iscsi_conn *conn = NULL;\r\nstruct iscsi_login *login;\r\nstruct iscsi_portal_group *tpg = NULL;\r\nstruct iscsi_login_req *pdu;\r\nflush_signals(current);\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (np->np_thread_state == ISCSI_NP_THREAD_RESET) {\r\nnp->np_thread_state = ISCSI_NP_THREAD_ACTIVE;\r\ncomplete(&np->np_restart_comp);\r\n} else {\r\nnp->np_thread_state = ISCSI_NP_THREAD_ACTIVE;\r\n}\r\nspin_unlock_bh(&np->np_thread_lock);\r\nconn = kzalloc(sizeof(struct iscsi_conn), GFP_KERNEL);\r\nif (!conn) {\r\npr_err("Could not allocate memory for"\r\n" new connection\n");\r\nreturn 1;\r\n}\r\npr_debug("Moving to TARG_CONN_STATE_FREE.\n");\r\nconn->conn_state = TARG_CONN_STATE_FREE;\r\nif (iscsit_conn_set_transport(conn, np->np_transport) < 0) {\r\nkfree(conn);\r\nreturn 1;\r\n}\r\nrc = np->np_transport->iscsit_accept_np(np, conn);\r\nif (rc == -ENOSYS) {\r\ncomplete(&np->np_restart_comp);\r\niscsit_put_transport(conn->conn_transport);\r\nkfree(conn);\r\nconn = NULL;\r\ngoto exit;\r\n} else if (rc < 0) {\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (np->np_thread_state == ISCSI_NP_THREAD_RESET) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\ncomplete(&np->np_restart_comp);\r\nif (ret == -ENODEV) {\r\niscsit_put_transport(conn->conn_transport);\r\nkfree(conn);\r\nconn = NULL;\r\ngoto out;\r\n}\r\nreturn 1;\r\n}\r\nspin_unlock_bh(&np->np_thread_lock);\r\niscsit_put_transport(conn->conn_transport);\r\nkfree(conn);\r\nconn = NULL;\r\ngoto out;\r\n}\r\nlogin = iscsi_login_init_conn(conn);\r\nif (!login) {\r\ngoto new_sess_out;\r\n}\r\niscsi_start_login_thread_timer(np);\r\npr_debug("Moving to TARG_CONN_STATE_XPT_UP.\n");\r\nconn->conn_state = TARG_CONN_STATE_XPT_UP;\r\nrc = np->np_transport->iscsit_get_login_rx(conn, login);\r\nif (rc == 1)\r\nreturn 1;\r\nelse if (rc < 0)\r\ngoto new_sess_out;\r\nbuffer = &login->req[0];\r\npdu = (struct iscsi_login_req *)buffer;\r\nconn->login_itt = pdu->itt;\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (np->np_thread_state != ISCSI_NP_THREAD_ACTIVE) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\npr_err("iSCSI Network Portal on %s:%hu currently not"\r\n" active.\n", np->np_ip, np->np_port);\r\niscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\r\nISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\r\ngoto new_sess_out;\r\n}\r\nspin_unlock_bh(&np->np_thread_lock);\r\nconn->network_transport = np->np_network_transport;\r\npr_debug("Received iSCSI login request from %s on %s Network"\r\n" Portal %s:%hu\n", conn->login_ip, np->np_transport->name,\r\nconn->local_ip, conn->local_port);\r\npr_debug("Moving to TARG_CONN_STATE_IN_LOGIN.\n");\r\nconn->conn_state = TARG_CONN_STATE_IN_LOGIN;\r\nif (iscsi_login_check_initiator_version(conn, pdu->max_version,\r\npdu->min_version) < 0)\r\ngoto new_sess_out;\r\nzero_tsih = (pdu->tsih == 0x0000);\r\nif (zero_tsih) {\r\nif (iscsi_login_zero_tsih_s1(conn, buffer) < 0)\r\ngoto new_sess_out;\r\n} else {\r\nif (iscsi_login_non_zero_tsih_s1(conn, buffer) < 0)\r\ngoto new_sess_out;\r\n}\r\nrc = iscsi_target_locate_portal(np, conn, login);\r\nif (rc < 0) {\r\ntpg = conn->tpg;\r\ngoto new_sess_out;\r\n}\r\ntpg = conn->tpg;\r\nif (!tpg) {\r\npr_err("Unable to locate struct iscsi_conn->tpg\n");\r\ngoto new_sess_out;\r\n}\r\nif (zero_tsih) {\r\nif (iscsi_login_zero_tsih_s2(conn) < 0)\r\ngoto new_sess_out;\r\n} else {\r\nif (iscsi_login_non_zero_tsih_s2(conn, buffer) < 0)\r\ngoto old_sess_out;\r\n}\r\nif (iscsi_target_start_negotiation(login, conn) < 0)\r\ngoto new_sess_out;\r\nif (!conn->sess) {\r\npr_err("struct iscsi_conn session pointer is NULL!\n");\r\ngoto new_sess_out;\r\n}\r\niscsi_stop_login_thread_timer(np);\r\nif (signal_pending(current))\r\ngoto new_sess_out;\r\nret = iscsi_post_login_handler(np, conn, zero_tsih);\r\nif (ret < 0)\r\ngoto new_sess_out;\r\niscsit_deaccess_np(np, tpg);\r\ntpg = NULL;\r\nreturn 1;\r\nnew_sess_out:\r\npr_err("iSCSI Login negotiation failed.\n");\r\niscsit_collect_login_stats(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\r\nISCSI_LOGIN_STATUS_INIT_ERR);\r\nif (!zero_tsih || !conn->sess)\r\ngoto old_sess_out;\r\nif (conn->sess->se_sess)\r\ntransport_free_session(conn->sess->se_sess);\r\nif (conn->sess->session_index != 0) {\r\nspin_lock_bh(&sess_idr_lock);\r\nidr_remove(&sess_idr, conn->sess->session_index);\r\nspin_unlock_bh(&sess_idr_lock);\r\n}\r\nkfree(conn->sess->sess_ops);\r\nkfree(conn->sess);\r\nold_sess_out:\r\niscsi_stop_login_thread_timer(np);\r\nif (!zero_tsih && conn->sess) {\r\nspin_lock_bh(&conn->sess->conn_lock);\r\nif (conn->sess->session_state == TARG_SESS_STATE_FAILED) {\r\nstruct se_portal_group *se_tpg =\r\n&ISCSI_TPG_C(conn)->tpg_se_tpg;\r\natomic_set(&conn->sess->session_continuation, 0);\r\nspin_unlock_bh(&conn->sess->conn_lock);\r\nspin_lock_bh(&se_tpg->session_lock);\r\niscsit_start_time2retain_handler(conn->sess);\r\nspin_unlock_bh(&se_tpg->session_lock);\r\n} else\r\nspin_unlock_bh(&conn->sess->conn_lock);\r\niscsit_dec_session_usage_count(conn->sess);\r\n}\r\nif (!IS_ERR(conn->conn_rx_hash.tfm))\r\ncrypto_free_hash(conn->conn_rx_hash.tfm);\r\nif (!IS_ERR(conn->conn_tx_hash.tfm))\r\ncrypto_free_hash(conn->conn_tx_hash.tfm);\r\nif (conn->conn_cpumask)\r\nfree_cpumask_var(conn->conn_cpumask);\r\nkfree(conn->conn_ops);\r\nif (conn->param_list) {\r\niscsi_release_param_list(conn->param_list);\r\nconn->param_list = NULL;\r\n}\r\niscsi_target_nego_release(conn);\r\nif (conn->sock) {\r\nsock_release(conn->sock);\r\nconn->sock = NULL;\r\n}\r\nif (conn->conn_transport->iscsit_free_conn)\r\nconn->conn_transport->iscsit_free_conn(conn);\r\niscsit_put_transport(conn->conn_transport);\r\nkfree(conn);\r\nif (tpg) {\r\niscsit_deaccess_np(np, tpg);\r\ntpg = NULL;\r\n}\r\nout:\r\nstop = kthread_should_stop();\r\nif (!stop && signal_pending(current)) {\r\nspin_lock_bh(&np->np_thread_lock);\r\nstop = (np->np_thread_state == ISCSI_NP_THREAD_SHUTDOWN);\r\nspin_unlock_bh(&np->np_thread_lock);\r\n}\r\nif (!stop)\r\nreturn 1;\r\nexit:\r\niscsi_stop_login_thread_timer(np);\r\nspin_lock_bh(&np->np_thread_lock);\r\nnp->np_thread_state = ISCSI_NP_THREAD_EXIT;\r\nnp->np_thread = NULL;\r\nspin_unlock_bh(&np->np_thread_lock);\r\nreturn 0;\r\n}\r\nint iscsi_target_login_thread(void *arg)\r\n{\r\nstruct iscsi_np *np = arg;\r\nint ret;\r\nallow_signal(SIGINT);\r\nwhile (!kthread_should_stop()) {\r\nret = __iscsi_target_login_thread(np);\r\nif (ret != 1)\r\nbreak;\r\n}\r\nreturn 0;\r\n}
