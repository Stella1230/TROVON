int drm_get_platform_dev(struct platform_device *platdev,\r\nstruct drm_driver *driver)\r\n{\r\nstruct drm_device *dev;\r\nint ret;\r\nDRM_DEBUG("\n");\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->platformdev = platdev;\r\ndev->dev = &platdev->dev;\r\nmutex_lock(&drm_global_mutex);\r\nret = drm_fill_in_dev(dev, NULL, driver);\r\nif (ret) {\r\nprintk(KERN_ERR "DRM: Fill_in_dev failed.\n");\r\ngoto err_g1;\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_MODESET)) {\r\nret = drm_get_minor(dev, &dev->control, DRM_MINOR_CONTROL);\r\nif (ret)\r\ngoto err_g1;\r\n}\r\nret = drm_get_minor(dev, &dev->primary, DRM_MINOR_LEGACY);\r\nif (ret)\r\ngoto err_g2;\r\nif (dev->driver->load) {\r\nret = dev->driver->load(dev, 0);\r\nif (ret)\r\ngoto err_g3;\r\n}\r\nif (drm_core_check_feature(dev, DRIVER_MODESET)) {\r\nret = drm_mode_group_init_legacy_group(dev,\r\n&dev->primary->mode_group);\r\nif (ret)\r\ngoto err_g3;\r\n}\r\nlist_add_tail(&dev->driver_item, &driver->device_list);\r\nmutex_unlock(&drm_global_mutex);\r\nDRM_INFO("Initialized %s %d.%d.%d %s on minor %d\n",\r\ndriver->name, driver->major, driver->minor, driver->patchlevel,\r\ndriver->date, dev->primary->index);\r\nreturn 0;\r\nerr_g3:\r\ndrm_put_minor(&dev->primary);\r\nerr_g2:\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\ndrm_put_minor(&dev->control);\r\nerr_g1:\r\nkfree(dev);\r\nmutex_unlock(&drm_global_mutex);\r\nreturn ret;\r\n}\r\nstatic int drm_platform_get_irq(struct drm_device *dev)\r\n{\r\nreturn platform_get_irq(dev->platformdev, 0);\r\n}\r\nstatic const char *drm_platform_get_name(struct drm_device *dev)\r\n{\r\nreturn dev->platformdev->name;\r\n}\r\nstatic int drm_platform_set_busid(struct drm_device *dev, struct drm_master *master)\r\n{\r\nint len, ret, id;\r\nmaster->unique_len = 13 + strlen(dev->platformdev->name);\r\nmaster->unique_size = master->unique_len;\r\nmaster->unique = kmalloc(master->unique_len + 1, GFP_KERNEL);\r\nif (master->unique == NULL)\r\nreturn -ENOMEM;\r\nid = dev->platformdev->id;\r\nif (id == -1)\r\nid = 0;\r\nlen = snprintf(master->unique, master->unique_len,\r\n"platform:%s:%02d", dev->platformdev->name, id);\r\nif (len > master->unique_len) {\r\nDRM_ERROR("Unique buffer overflowed\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev->devname =\r\nkmalloc(strlen(dev->platformdev->name) +\r\nmaster->unique_len + 2, GFP_KERNEL);\r\nif (dev->devname == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsprintf(dev->devname, "%s@%s", dev->platformdev->name,\r\nmaster->unique);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nint drm_platform_init(struct drm_driver *driver, struct platform_device *platform_device)\r\n{\r\nDRM_DEBUG("\n");\r\ndriver->kdriver.platform_device = platform_device;\r\ndriver->bus = &drm_platform_bus;\r\nINIT_LIST_HEAD(&driver->device_list);\r\nreturn drm_get_platform_dev(platform_device, driver);\r\n}\r\nvoid drm_platform_exit(struct drm_driver *driver, struct platform_device *platform_device)\r\n{\r\nstruct drm_device *dev, *tmp;\r\nDRM_DEBUG("\n");\r\nlist_for_each_entry_safe(dev, tmp, &driver->device_list, driver_item)\r\ndrm_put_dev(dev);\r\nDRM_INFO("Module unloaded\n");\r\n}
