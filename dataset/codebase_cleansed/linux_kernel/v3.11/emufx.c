static inline mm_segment_t snd_enter_user(void)\r\n{\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\nreturn fs;\r\n}\r\nstatic inline void snd_leave_user(mm_segment_t fs)\r\n{\r\nset_fs(fs);\r\n}\r\nstatic int snd_emu10k1_gpr_ctl_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_emu10k1_fx8010_ctl *ctl =\r\n(struct snd_emu10k1_fx8010_ctl *) kcontrol->private_value;\r\nif (ctl->min == 0 && ctl->max == 1)\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nelse\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = ctl->vcount;\r\nuinfo->value.integer.min = ctl->min;\r\nuinfo->value.integer.max = ctl->max;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_gpr_ctl_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_fx8010_ctl *ctl =\r\n(struct snd_emu10k1_fx8010_ctl *) kcontrol->private_value;\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (i = 0; i < ctl->vcount; i++)\r\nucontrol->value.integer.value[i] = ctl->value[i];\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_gpr_ctl_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_emu10k1 *emu = snd_kcontrol_chip(kcontrol);\r\nstruct snd_emu10k1_fx8010_ctl *ctl =\r\n(struct snd_emu10k1_fx8010_ctl *) kcontrol->private_value;\r\nunsigned long flags;\r\nunsigned int nval, val;\r\nunsigned int i, j;\r\nint change = 0;\r\nspin_lock_irqsave(&emu->reg_lock, flags);\r\nfor (i = 0; i < ctl->vcount; i++) {\r\nnval = ucontrol->value.integer.value[i];\r\nif (nval < ctl->min)\r\nnval = ctl->min;\r\nif (nval > ctl->max)\r\nnval = ctl->max;\r\nif (nval != ctl->value[i])\r\nchange = 1;\r\nval = ctl->value[i] = nval;\r\nswitch (ctl->translation) {\r\ncase EMU10K1_GPR_TRANSLATION_NONE:\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[i], 0, val);\r\nbreak;\r\ncase EMU10K1_GPR_TRANSLATION_TABLE100:\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[i], 0, db_table[val]);\r\nbreak;\r\ncase EMU10K1_GPR_TRANSLATION_BASS:\r\nif ((ctl->count % 5) != 0 || (ctl->count / 5) != ctl->vcount) {\r\nchange = -EIO;\r\ngoto __error;\r\n}\r\nfor (j = 0; j < 5; j++)\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[j * ctl->vcount + i], 0, bass_table[val][j]);\r\nbreak;\r\ncase EMU10K1_GPR_TRANSLATION_TREBLE:\r\nif ((ctl->count % 5) != 0 || (ctl->count / 5) != ctl->vcount) {\r\nchange = -EIO;\r\ngoto __error;\r\n}\r\nfor (j = 0; j < 5; j++)\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[j * ctl->vcount + i], 0, treble_table[val][j]);\r\nbreak;\r\ncase EMU10K1_GPR_TRANSLATION_ONOFF:\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + ctl->gpr[i], 0, onoff_table[val]);\r\nbreak;\r\n}\r\n}\r\n__error:\r\nspin_unlock_irqrestore(&emu->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic void snd_emu10k1_fx8010_interrupt(struct snd_emu10k1 *emu)\r\n{\r\nstruct snd_emu10k1_fx8010_irq *irq, *nirq;\r\nirq = emu->fx8010.irq_handlers;\r\nwhile (irq) {\r\nnirq = irq->next;\r\nif (snd_emu10k1_ptr_read(emu, emu->gpr_base + irq->gpr_running, 0) & 0xffff0000) {\r\nif (irq->handler)\r\nirq->handler(emu, irq->private_data);\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + irq->gpr_running, 0, 1);\r\n}\r\nirq = nirq;\r\n}\r\n}\r\nint snd_emu10k1_fx8010_register_irq_handler(struct snd_emu10k1 *emu,\r\nsnd_fx8010_irq_handler_t *handler,\r\nunsigned char gpr_running,\r\nvoid *private_data,\r\nstruct snd_emu10k1_fx8010_irq **r_irq)\r\n{\r\nstruct snd_emu10k1_fx8010_irq *irq;\r\nunsigned long flags;\r\nirq = kmalloc(sizeof(*irq), GFP_ATOMIC);\r\nif (irq == NULL)\r\nreturn -ENOMEM;\r\nirq->handler = handler;\r\nirq->gpr_running = gpr_running;\r\nirq->private_data = private_data;\r\nirq->next = NULL;\r\nspin_lock_irqsave(&emu->fx8010.irq_lock, flags);\r\nif (emu->fx8010.irq_handlers == NULL) {\r\nemu->fx8010.irq_handlers = irq;\r\nemu->dsp_interrupt = snd_emu10k1_fx8010_interrupt;\r\nsnd_emu10k1_intr_enable(emu, INTE_FXDSPENABLE);\r\n} else {\r\nirq->next = emu->fx8010.irq_handlers;\r\nemu->fx8010.irq_handlers = irq;\r\n}\r\nspin_unlock_irqrestore(&emu->fx8010.irq_lock, flags);\r\nif (r_irq)\r\n*r_irq = irq;\r\nreturn 0;\r\n}\r\nint snd_emu10k1_fx8010_unregister_irq_handler(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_irq *irq)\r\n{\r\nstruct snd_emu10k1_fx8010_irq *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->fx8010.irq_lock, flags);\r\nif ((tmp = emu->fx8010.irq_handlers) == irq) {\r\nemu->fx8010.irq_handlers = tmp->next;\r\nif (emu->fx8010.irq_handlers == NULL) {\r\nsnd_emu10k1_intr_disable(emu, INTE_FXDSPENABLE);\r\nemu->dsp_interrupt = NULL;\r\n}\r\n} else {\r\nwhile (tmp && tmp->next != irq)\r\ntmp = tmp->next;\r\nif (tmp)\r\ntmp->next = tmp->next->next;\r\n}\r\nspin_unlock_irqrestore(&emu->fx8010.irq_lock, flags);\r\nkfree(irq);\r\nreturn 0;\r\n}\r\nstatic void snd_emu10k1_write_op(struct snd_emu10k1_fx8010_code *icode,\r\nunsigned int *ptr,\r\nu32 op, u32 r, u32 a, u32 x, u32 y)\r\n{\r\nu_int32_t *code;\r\nif (snd_BUG_ON(*ptr >= 512))\r\nreturn;\r\ncode = (u_int32_t __force *)icode->code + (*ptr) * 2;\r\nset_bit(*ptr, icode->code_valid);\r\ncode[0] = ((x & 0x3ff) << 10) | (y & 0x3ff);\r\ncode[1] = ((op & 0x0f) << 20) | ((r & 0x3ff) << 10) | (a & 0x3ff);\r\n(*ptr)++;\r\n}\r\nstatic void snd_emu10k1_audigy_write_op(struct snd_emu10k1_fx8010_code *icode,\r\nunsigned int *ptr,\r\nu32 op, u32 r, u32 a, u32 x, u32 y)\r\n{\r\nu_int32_t *code;\r\nif (snd_BUG_ON(*ptr >= 1024))\r\nreturn;\r\ncode = (u_int32_t __force *)icode->code + (*ptr) * 2;\r\nset_bit(*ptr, icode->code_valid);\r\ncode[0] = ((x & 0x7ff) << 12) | (y & 0x7ff);\r\ncode[1] = ((op & 0x0f) << 24) | ((r & 0x7ff) << 12) | (a & 0x7ff);\r\n(*ptr)++;\r\n}\r\nstatic void snd_emu10k1_efx_write(struct snd_emu10k1 *emu, unsigned int pc, unsigned int data)\r\n{\r\npc += emu->audigy ? A_MICROCODEBASE : MICROCODEBASE;\r\nsnd_emu10k1_ptr_write(emu, pc, 0, data);\r\n}\r\nunsigned int snd_emu10k1_efx_read(struct snd_emu10k1 *emu, unsigned int pc)\r\n{\r\npc += emu->audigy ? A_MICROCODEBASE : MICROCODEBASE;\r\nreturn snd_emu10k1_ptr_read(emu, pc, 0);\r\n}\r\nstatic int snd_emu10k1_gpr_poke(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nint gpr;\r\nu32 val;\r\nfor (gpr = 0; gpr < (emu->audigy ? 0x200 : 0x100); gpr++) {\r\nif (!test_bit(gpr, icode->gpr_valid))\r\ncontinue;\r\nif (get_user(val, &icode->gpr_map[gpr]))\r\nreturn -EFAULT;\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + gpr, 0, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_gpr_peek(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nint gpr;\r\nu32 val;\r\nfor (gpr = 0; gpr < (emu->audigy ? 0x200 : 0x100); gpr++) {\r\nset_bit(gpr, icode->gpr_valid);\r\nval = snd_emu10k1_ptr_read(emu, emu->gpr_base + gpr, 0);\r\nif (put_user(val, &icode->gpr_map[gpr]))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_tram_poke(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nint tram;\r\nu32 addr, val;\r\nfor (tram = 0; tram < (emu->audigy ? 0x100 : 0xa0); tram++) {\r\nif (!test_bit(tram, icode->tram_valid))\r\ncontinue;\r\nif (get_user(val, &icode->tram_data_map[tram]) ||\r\nget_user(addr, &icode->tram_addr_map[tram]))\r\nreturn -EFAULT;\r\nsnd_emu10k1_ptr_write(emu, TANKMEMDATAREGBASE + tram, 0, val);\r\nif (!emu->audigy) {\r\nsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, addr);\r\n} else {\r\nsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + tram, 0, addr << 12);\r\nsnd_emu10k1_ptr_write(emu, A_TANKMEMCTLREGBASE + tram, 0, addr >> 20);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_tram_peek(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nint tram;\r\nu32 val, addr;\r\nmemset(icode->tram_valid, 0, sizeof(icode->tram_valid));\r\nfor (tram = 0; tram < (emu->audigy ? 0x100 : 0xa0); tram++) {\r\nset_bit(tram, icode->tram_valid);\r\nval = snd_emu10k1_ptr_read(emu, TANKMEMDATAREGBASE + tram, 0);\r\nif (!emu->audigy) {\r\naddr = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0);\r\n} else {\r\naddr = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + tram, 0) >> 12;\r\naddr |= snd_emu10k1_ptr_read(emu, A_TANKMEMCTLREGBASE + tram, 0) << 20;\r\n}\r\nif (put_user(val, &icode->tram_data_map[tram]) ||\r\nput_user(addr, &icode->tram_addr_map[tram]))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_code_poke(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nu32 pc, lo, hi;\r\nfor (pc = 0; pc < (emu->audigy ? 2*1024 : 2*512); pc += 2) {\r\nif (!test_bit(pc / 2, icode->code_valid))\r\ncontinue;\r\nif (get_user(lo, &icode->code[pc + 0]) ||\r\nget_user(hi, &icode->code[pc + 1]))\r\nreturn -EFAULT;\r\nsnd_emu10k1_efx_write(emu, pc + 0, lo);\r\nsnd_emu10k1_efx_write(emu, pc + 1, hi);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_code_peek(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nu32 pc;\r\nmemset(icode->code_valid, 0, sizeof(icode->code_valid));\r\nfor (pc = 0; pc < (emu->audigy ? 2*1024 : 2*512); pc += 2) {\r\nset_bit(pc / 2, icode->code_valid);\r\nif (put_user(snd_emu10k1_efx_read(emu, pc + 0), &icode->code[pc + 0]))\r\nreturn -EFAULT;\r\nif (put_user(snd_emu10k1_efx_read(emu, pc + 1), &icode->code[pc + 1]))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct snd_emu10k1_fx8010_ctl *\r\nsnd_emu10k1_look_for_ctl(struct snd_emu10k1 *emu, struct snd_ctl_elem_id *id)\r\n{\r\nstruct snd_emu10k1_fx8010_ctl *ctl;\r\nstruct snd_kcontrol *kcontrol;\r\nlist_for_each_entry(ctl, &emu->fx8010.gpr_ctl, list) {\r\nkcontrol = ctl->kcontrol;\r\nif (kcontrol->id.iface == id->iface &&\r\n!strcmp(kcontrol->id.name, id->name) &&\r\nkcontrol->id.index == id->index)\r\nreturn ctl;\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int *copy_tlv(const unsigned int __user *_tlv)\r\n{\r\nunsigned int data[2];\r\nunsigned int *tlv;\r\nif (!_tlv)\r\nreturn NULL;\r\nif (copy_from_user(data, _tlv, sizeof(data)))\r\nreturn NULL;\r\nif (data[1] >= MAX_TLV_SIZE)\r\nreturn NULL;\r\ntlv = kmalloc(data[1] + sizeof(data), GFP_KERNEL);\r\nif (!tlv)\r\nreturn NULL;\r\nmemcpy(tlv, data, sizeof(data));\r\nif (copy_from_user(tlv + 2, _tlv + 2, data[1])) {\r\nkfree(tlv);\r\nreturn NULL;\r\n}\r\nreturn tlv;\r\n}\r\nstatic int copy_gctl(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_control_gpr *gctl,\r\nstruct snd_emu10k1_fx8010_control_gpr __user *_gctl,\r\nint idx)\r\n{\r\nstruct snd_emu10k1_fx8010_control_old_gpr __user *octl;\r\nif (emu->support_tlv)\r\nreturn copy_from_user(gctl, &_gctl[idx], sizeof(*gctl));\r\noctl = (struct snd_emu10k1_fx8010_control_old_gpr __user *)_gctl;\r\nif (copy_from_user(gctl, &octl[idx], sizeof(*octl)))\r\nreturn -EFAULT;\r\ngctl->tlv = NULL;\r\nreturn 0;\r\n}\r\nstatic int copy_gctl_to_user(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_control_gpr __user *_gctl,\r\nstruct snd_emu10k1_fx8010_control_gpr *gctl,\r\nint idx)\r\n{\r\nstruct snd_emu10k1_fx8010_control_old_gpr __user *octl;\r\nif (emu->support_tlv)\r\nreturn copy_to_user(&_gctl[idx], gctl, sizeof(*gctl));\r\noctl = (struct snd_emu10k1_fx8010_control_old_gpr __user *)_gctl;\r\nreturn copy_to_user(&octl[idx], gctl, sizeof(*octl));\r\n}\r\nstatic int snd_emu10k1_verify_controls(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nunsigned int i;\r\nstruct snd_ctl_elem_id __user *_id;\r\nstruct snd_ctl_elem_id id;\r\nstruct snd_emu10k1_fx8010_control_gpr *gctl;\r\nint err;\r\nfor (i = 0, _id = icode->gpr_del_controls;\r\ni < icode->gpr_del_control_count; i++, _id++) {\r\nif (copy_from_user(&id, _id, sizeof(id)))\r\nreturn -EFAULT;\r\nif (snd_emu10k1_look_for_ctl(emu, &id) == NULL)\r\nreturn -ENOENT;\r\n}\r\ngctl = kmalloc(sizeof(*gctl), GFP_KERNEL);\r\nif (! gctl)\r\nreturn -ENOMEM;\r\nerr = 0;\r\nfor (i = 0; i < icode->gpr_add_control_count; i++) {\r\nif (copy_gctl(emu, gctl, icode->gpr_add_controls, i)) {\r\nerr = -EFAULT;\r\ngoto __error;\r\n}\r\nif (snd_emu10k1_look_for_ctl(emu, &gctl->id))\r\ncontinue;\r\ndown_read(&emu->card->controls_rwsem);\r\nif (snd_ctl_find_id(emu->card, &gctl->id) != NULL) {\r\nup_read(&emu->card->controls_rwsem);\r\nerr = -EEXIST;\r\ngoto __error;\r\n}\r\nup_read(&emu->card->controls_rwsem);\r\nif (gctl->id.iface != SNDRV_CTL_ELEM_IFACE_MIXER &&\r\ngctl->id.iface != SNDRV_CTL_ELEM_IFACE_PCM) {\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\n}\r\nfor (i = 0; i < icode->gpr_list_control_count; i++) {\r\nif (copy_gctl(emu, gctl, icode->gpr_list_controls, i)) {\r\nerr = -EFAULT;\r\ngoto __error;\r\n}\r\n}\r\n__error:\r\nkfree(gctl);\r\nreturn err;\r\n}\r\nstatic void snd_emu10k1_ctl_private_free(struct snd_kcontrol *kctl)\r\n{\r\nstruct snd_emu10k1_fx8010_ctl *ctl;\r\nctl = (struct snd_emu10k1_fx8010_ctl *) kctl->private_value;\r\nkctl->private_value = 0;\r\nlist_del(&ctl->list);\r\nkfree(ctl);\r\nif (kctl->tlv.p)\r\nkfree(kctl->tlv.p);\r\n}\r\nstatic int snd_emu10k1_add_controls(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nunsigned int i, j;\r\nstruct snd_emu10k1_fx8010_control_gpr *gctl;\r\nstruct snd_emu10k1_fx8010_ctl *ctl, *nctl;\r\nstruct snd_kcontrol_new knew;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_ctl_elem_value *val;\r\nint err = 0;\r\nval = kmalloc(sizeof(*val), GFP_KERNEL);\r\ngctl = kmalloc(sizeof(*gctl), GFP_KERNEL);\r\nnctl = kmalloc(sizeof(*nctl), GFP_KERNEL);\r\nif (!val || !gctl || !nctl) {\r\nerr = -ENOMEM;\r\ngoto __error;\r\n}\r\nfor (i = 0; i < icode->gpr_add_control_count; i++) {\r\nif (copy_gctl(emu, gctl, icode->gpr_add_controls, i)) {\r\nerr = -EFAULT;\r\ngoto __error;\r\n}\r\nif (gctl->id.iface != SNDRV_CTL_ELEM_IFACE_MIXER &&\r\ngctl->id.iface != SNDRV_CTL_ELEM_IFACE_PCM) {\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\nif (! gctl->id.name[0]) {\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\nctl = snd_emu10k1_look_for_ctl(emu, &gctl->id);\r\nmemset(&knew, 0, sizeof(knew));\r\nknew.iface = gctl->id.iface;\r\nknew.name = gctl->id.name;\r\nknew.index = gctl->id.index;\r\nknew.device = gctl->id.device;\r\nknew.subdevice = gctl->id.subdevice;\r\nknew.info = snd_emu10k1_gpr_ctl_info;\r\nknew.tlv.p = copy_tlv(gctl->tlv);\r\nif (knew.tlv.p)\r\nknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nknew.get = snd_emu10k1_gpr_ctl_get;\r\nknew.put = snd_emu10k1_gpr_ctl_put;\r\nmemset(nctl, 0, sizeof(*nctl));\r\nnctl->vcount = gctl->vcount;\r\nnctl->count = gctl->count;\r\nfor (j = 0; j < 32; j++) {\r\nnctl->gpr[j] = gctl->gpr[j];\r\nnctl->value[j] = ~gctl->value[j];\r\nval->value.integer.value[j] = gctl->value[j];\r\n}\r\nnctl->min = gctl->min;\r\nnctl->max = gctl->max;\r\nnctl->translation = gctl->translation;\r\nif (ctl == NULL) {\r\nctl = kmalloc(sizeof(*ctl), GFP_KERNEL);\r\nif (ctl == NULL) {\r\nerr = -ENOMEM;\r\nkfree(knew.tlv.p);\r\ngoto __error;\r\n}\r\nknew.private_value = (unsigned long)ctl;\r\n*ctl = *nctl;\r\nif ((err = snd_ctl_add(emu->card, kctl = snd_ctl_new1(&knew, emu))) < 0) {\r\nkfree(ctl);\r\nkfree(knew.tlv.p);\r\ngoto __error;\r\n}\r\nkctl->private_free = snd_emu10k1_ctl_private_free;\r\nctl->kcontrol = kctl;\r\nlist_add_tail(&ctl->list, &emu->fx8010.gpr_ctl);\r\n} else {\r\nnctl->list = ctl->list;\r\nnctl->kcontrol = ctl->kcontrol;\r\n*ctl = *nctl;\r\nsnd_ctl_notify(emu->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &ctl->kcontrol->id);\r\n}\r\nsnd_emu10k1_gpr_ctl_put(ctl->kcontrol, val);\r\n}\r\n__error:\r\nkfree(nctl);\r\nkfree(gctl);\r\nkfree(val);\r\nreturn err;\r\n}\r\nstatic int snd_emu10k1_del_controls(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nunsigned int i;\r\nstruct snd_ctl_elem_id id;\r\nstruct snd_ctl_elem_id __user *_id;\r\nstruct snd_emu10k1_fx8010_ctl *ctl;\r\nstruct snd_card *card = emu->card;\r\nfor (i = 0, _id = icode->gpr_del_controls;\r\ni < icode->gpr_del_control_count; i++, _id++) {\r\nif (copy_from_user(&id, _id, sizeof(id)))\r\nreturn -EFAULT;\r\ndown_write(&card->controls_rwsem);\r\nctl = snd_emu10k1_look_for_ctl(emu, &id);\r\nif (ctl)\r\nsnd_ctl_remove(card, ctl->kcontrol);\r\nup_write(&card->controls_rwsem);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_list_controls(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nunsigned int i = 0, j;\r\nunsigned int total = 0;\r\nstruct snd_emu10k1_fx8010_control_gpr *gctl;\r\nstruct snd_emu10k1_fx8010_ctl *ctl;\r\nstruct snd_ctl_elem_id *id;\r\ngctl = kmalloc(sizeof(*gctl), GFP_KERNEL);\r\nif (! gctl)\r\nreturn -ENOMEM;\r\nlist_for_each_entry(ctl, &emu->fx8010.gpr_ctl, list) {\r\ntotal++;\r\nif (icode->gpr_list_controls &&\r\ni < icode->gpr_list_control_count) {\r\nmemset(gctl, 0, sizeof(*gctl));\r\nid = &ctl->kcontrol->id;\r\ngctl->id.iface = id->iface;\r\nstrlcpy(gctl->id.name, id->name, sizeof(gctl->id.name));\r\ngctl->id.index = id->index;\r\ngctl->id.device = id->device;\r\ngctl->id.subdevice = id->subdevice;\r\ngctl->vcount = ctl->vcount;\r\ngctl->count = ctl->count;\r\nfor (j = 0; j < 32; j++) {\r\ngctl->gpr[j] = ctl->gpr[j];\r\ngctl->value[j] = ctl->value[j];\r\n}\r\ngctl->min = ctl->min;\r\ngctl->max = ctl->max;\r\ngctl->translation = ctl->translation;\r\nif (copy_gctl_to_user(emu, icode->gpr_list_controls,\r\ngctl, i)) {\r\nkfree(gctl);\r\nreturn -EFAULT;\r\n}\r\ni++;\r\n}\r\n}\r\nicode->gpr_list_control_total = total;\r\nkfree(gctl);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_icode_poke(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nint err = 0;\r\nmutex_lock(&emu->fx8010.lock);\r\nif ((err = snd_emu10k1_verify_controls(emu, icode)) < 0)\r\ngoto __error;\r\nstrlcpy(emu->fx8010.name, icode->name, sizeof(emu->fx8010.name));\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg | A_DBG_SINGLE_STEP);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg | EMU10K1_DBG_SINGLE_STEP);\r\nif ((err = snd_emu10k1_del_controls(emu, icode)) < 0 ||\r\n(err = snd_emu10k1_gpr_poke(emu, icode)) < 0 ||\r\n(err = snd_emu10k1_tram_poke(emu, icode)) < 0 ||\r\n(err = snd_emu10k1_code_poke(emu, icode)) < 0 ||\r\n(err = snd_emu10k1_add_controls(emu, icode)) < 0)\r\ngoto __error;\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg);\r\n__error:\r\nmutex_unlock(&emu->fx8010.lock);\r\nreturn err;\r\n}\r\nstatic int snd_emu10k1_icode_peek(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_code *icode)\r\n{\r\nint err;\r\nmutex_lock(&emu->fx8010.lock);\r\nstrlcpy(icode->name, emu->fx8010.name, sizeof(icode->name));\r\nerr = snd_emu10k1_gpr_peek(emu, icode);\r\nif (err >= 0)\r\nerr = snd_emu10k1_tram_peek(emu, icode);\r\nif (err >= 0)\r\nerr = snd_emu10k1_code_peek(emu, icode);\r\nif (err >= 0)\r\nerr = snd_emu10k1_list_controls(emu, icode);\r\nmutex_unlock(&emu->fx8010.lock);\r\nreturn err;\r\n}\r\nstatic int snd_emu10k1_ipcm_poke(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_pcm_rec *ipcm)\r\n{\r\nunsigned int i;\r\nint err = 0;\r\nstruct snd_emu10k1_fx8010_pcm *pcm;\r\nif (ipcm->substream >= EMU10K1_FX8010_PCM_COUNT)\r\nreturn -EINVAL;\r\nif (ipcm->channels > 32)\r\nreturn -EINVAL;\r\npcm = &emu->fx8010.pcm[ipcm->substream];\r\nmutex_lock(&emu->fx8010.lock);\r\nspin_lock_irq(&emu->reg_lock);\r\nif (pcm->opened) {\r\nerr = -EBUSY;\r\ngoto __error;\r\n}\r\nif (ipcm->channels == 0) {\r\npcm->valid = 0;\r\n} else {\r\nif (ipcm->channels != 2) {\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\npcm->valid = 1;\r\npcm->opened = 0;\r\npcm->channels = ipcm->channels;\r\npcm->tram_start = ipcm->tram_start;\r\npcm->buffer_size = ipcm->buffer_size;\r\npcm->gpr_size = ipcm->gpr_size;\r\npcm->gpr_count = ipcm->gpr_count;\r\npcm->gpr_tmpcount = ipcm->gpr_tmpcount;\r\npcm->gpr_ptr = ipcm->gpr_ptr;\r\npcm->gpr_trigger = ipcm->gpr_trigger;\r\npcm->gpr_running = ipcm->gpr_running;\r\nfor (i = 0; i < pcm->channels; i++)\r\npcm->etram[i] = ipcm->etram[i];\r\n}\r\n__error:\r\nspin_unlock_irq(&emu->reg_lock);\r\nmutex_unlock(&emu->fx8010.lock);\r\nreturn err;\r\n}\r\nstatic int snd_emu10k1_ipcm_peek(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_pcm_rec *ipcm)\r\n{\r\nunsigned int i;\r\nint err = 0;\r\nstruct snd_emu10k1_fx8010_pcm *pcm;\r\nif (ipcm->substream >= EMU10K1_FX8010_PCM_COUNT)\r\nreturn -EINVAL;\r\npcm = &emu->fx8010.pcm[ipcm->substream];\r\nmutex_lock(&emu->fx8010.lock);\r\nspin_lock_irq(&emu->reg_lock);\r\nipcm->channels = pcm->channels;\r\nipcm->tram_start = pcm->tram_start;\r\nipcm->buffer_size = pcm->buffer_size;\r\nipcm->gpr_size = pcm->gpr_size;\r\nipcm->gpr_ptr = pcm->gpr_ptr;\r\nipcm->gpr_count = pcm->gpr_count;\r\nipcm->gpr_tmpcount = pcm->gpr_tmpcount;\r\nipcm->gpr_trigger = pcm->gpr_trigger;\r\nipcm->gpr_running = pcm->gpr_running;\r\nfor (i = 0; i < pcm->channels; i++)\r\nipcm->etram[i] = pcm->etram[i];\r\nipcm->res1 = ipcm->res2 = 0;\r\nipcm->pad = 0;\r\nspin_unlock_irq(&emu->reg_lock);\r\nmutex_unlock(&emu->fx8010.lock);\r\nreturn err;\r\n}\r\nstatic void\r\nsnd_emu10k1_init_mono_control(struct snd_emu10k1_fx8010_control_gpr *ctl,\r\nconst char *name, int gpr, int defval)\r\n{\r\nctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(ctl->id.name, name);\r\nctl->vcount = ctl->count = 1;\r\nctl->gpr[0] = gpr + 0; ctl->value[0] = defval;\r\nif (high_res_gpr_volume) {\r\nctl->min = 0;\r\nctl->max = 0x7fffffff;\r\nctl->tlv = snd_emu10k1_db_linear;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_NONE;\r\n} else {\r\nctl->min = 0;\r\nctl->max = 100;\r\nctl->tlv = snd_emu10k1_db_scale1;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_TABLE100;\r\n}\r\n}\r\nstatic void\r\nsnd_emu10k1_init_stereo_control(struct snd_emu10k1_fx8010_control_gpr *ctl,\r\nconst char *name, int gpr, int defval)\r\n{\r\nctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(ctl->id.name, name);\r\nctl->vcount = ctl->count = 2;\r\nctl->gpr[0] = gpr + 0; ctl->value[0] = defval;\r\nctl->gpr[1] = gpr + 1; ctl->value[1] = defval;\r\nif (high_res_gpr_volume) {\r\nctl->min = 0;\r\nctl->max = 0x7fffffff;\r\nctl->tlv = snd_emu10k1_db_linear;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_NONE;\r\n} else {\r\nctl->min = 0;\r\nctl->max = 100;\r\nctl->tlv = snd_emu10k1_db_scale1;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_TABLE100;\r\n}\r\n}\r\nstatic void\r\nsnd_emu10k1_init_mono_onoff_control(struct snd_emu10k1_fx8010_control_gpr *ctl,\r\nconst char *name, int gpr, int defval)\r\n{\r\nctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(ctl->id.name, name);\r\nctl->vcount = ctl->count = 1;\r\nctl->gpr[0] = gpr + 0; ctl->value[0] = defval;\r\nctl->min = 0;\r\nctl->max = 1;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_ONOFF;\r\n}\r\nstatic void\r\nsnd_emu10k1_init_stereo_onoff_control(struct snd_emu10k1_fx8010_control_gpr *ctl,\r\nconst char *name, int gpr, int defval)\r\n{\r\nctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(ctl->id.name, name);\r\nctl->vcount = ctl->count = 2;\r\nctl->gpr[0] = gpr + 0; ctl->value[0] = defval;\r\nctl->gpr[1] = gpr + 1; ctl->value[1] = defval;\r\nctl->min = 0;\r\nctl->max = 1;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_ONOFF;\r\n}\r\nstatic int snd_emu10k1_audigy_dsp_convert_32_to_2x16(\r\nstruct snd_emu10k1_fx8010_code *icode,\r\nu32 *ptr, int tmp, int bit_shifter16,\r\nint reg_in, int reg_out)\r\n{\r\nA_OP(icode, ptr, iACC3, A_GPR(tmp + 1), reg_in, A_C_00000000, A_C_00000000);\r\nA_OP(icode, ptr, iANDXOR, A_GPR(tmp), A_GPR(tmp + 1), A_GPR(bit_shifter16 - 1), A_C_00000000);\r\nA_OP(icode, ptr, iTSTNEG, A_GPR(tmp + 2), A_GPR(tmp), A_C_80000000, A_GPR(bit_shifter16 - 2));\r\nA_OP(icode, ptr, iANDXOR, A_GPR(tmp + 2), A_GPR(tmp + 2), A_C_80000000, A_C_00000000);\r\nA_OP(icode, ptr, iANDXOR, A_GPR(tmp), A_GPR(tmp), A_GPR(bit_shifter16 - 3), A_C_00000000);\r\nA_OP(icode, ptr, iMACINT0, A_GPR(tmp), A_C_00000000, A_GPR(tmp), A_C_00010000);\r\nA_OP(icode, ptr, iANDXOR, reg_out, A_GPR(tmp), A_C_ffffffff, A_GPR(tmp + 2));\r\nA_OP(icode, ptr, iACC3, reg_out + 1, A_GPR(tmp + 1), A_C_00000000, A_C_00000000);\r\nreturn 1;\r\n}\r\nstatic int _snd_emu10k1_audigy_init_efx(struct snd_emu10k1 *emu)\r\n{\r\nint err, i, z, gpr, nctl;\r\nint bit_shifter16;\r\nconst int playback = 10;\r\nconst int capture = playback + (SND_EMU10K1_PLAYBACK_CHANNELS * 2);\r\nconst int stereo_mix = capture + 2;\r\nconst int tmp = 0x88;\r\nu32 ptr;\r\nstruct snd_emu10k1_fx8010_code *icode = NULL;\r\nstruct snd_emu10k1_fx8010_control_gpr *controls = NULL, *ctl;\r\nu32 *gpr_map;\r\nmm_segment_t seg;\r\nif ((icode = kzalloc(sizeof(*icode), GFP_KERNEL)) == NULL ||\r\n(icode->gpr_map = (u_int32_t __user *)\r\nkcalloc(512 + 256 + 256 + 2 * 1024, sizeof(u_int32_t),\r\nGFP_KERNEL)) == NULL ||\r\n(controls = kcalloc(SND_EMU10K1_GPR_CONTROLS,\r\nsizeof(*controls), GFP_KERNEL)) == NULL) {\r\nerr = -ENOMEM;\r\ngoto __err;\r\n}\r\ngpr_map = (u32 __force *)icode->gpr_map;\r\nicode->tram_data_map = icode->gpr_map + 512;\r\nicode->tram_addr_map = icode->tram_data_map + 256;\r\nicode->code = icode->tram_addr_map + 256;\r\nfor (i = 0; i < 512; i++)\r\nset_bit(i, icode->gpr_valid);\r\nfor (i = 0; i < 256; i++)\r\nset_bit(i, icode->tram_valid);\r\nstrcpy(icode->name, "Audigy DSP code for ALSA");\r\nptr = 0;\r\nnctl = 0;\r\ngpr = stereo_mix + 10;\r\ngpr_map[gpr++] = 0x00007fff;\r\ngpr_map[gpr++] = 0x00008000;\r\ngpr_map[gpr++] = 0x0000ffff;\r\nbit_shifter16 = gpr;\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, (emu->fx8010.dbg = 0) | A_DBG_SINGLE_STEP);\r\n#if 1\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_FRONT));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+1), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT_FRONT));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "PCM Front Playback Volume", gpr, 100);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+2), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_REAR));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+3), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT_REAR));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "PCM Surround Playback Volume", gpr, 100);\r\ngpr += 2;\r\nif (emu->card_capabilities->spk71) {\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+6), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT_SIDE));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+7), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT_SIDE));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "PCM Side Playback Volume", gpr, 100);\r\ngpr += 2;\r\n}\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+4), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_CENTER));\r\nsnd_emu10k1_init_mono_control(&controls[nctl++], "PCM Center Playback Volume", gpr, 100);\r\ngpr++;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+5), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LFE));\r\nsnd_emu10k1_init_mono_control(&controls[nctl++], "PCM LFE Playback Volume", gpr, 100);\r\ngpr++;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(stereo_mix), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(stereo_mix+1), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Wave Playback Volume", gpr, 100);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(stereo_mix+0), A_GPR(stereo_mix+0), A_GPR(gpr), A_FXBUS(FXBUS_MIDI_LEFT));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(stereo_mix+1), A_GPR(stereo_mix+1), A_GPR(gpr+1), A_FXBUS(FXBUS_MIDI_RIGHT));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Synth Playback Volume", gpr, 100);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(capture+0), A_C_00000000, A_GPR(gpr), A_FXBUS(FXBUS_PCM_LEFT));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(capture+1), A_C_00000000, A_GPR(gpr+1), A_FXBUS(FXBUS_PCM_RIGHT));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "PCM Capture Volume", gpr, 0);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(capture+0), A_GPR(capture+0), A_GPR(gpr), A_FXBUS(FXBUS_MIDI_LEFT));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(capture+1), A_GPR(capture+1), A_GPR(gpr+1), A_FXBUS(FXBUS_MIDI_RIGHT));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Synth Capture Volume", gpr, 0);\r\ngpr += 2;\r\n#define A_ADD_VOLUME_IN(var,vol,input) \\r\nA_OP(icode, &ptr, iMAC0, A_GPR(var), A_GPR(var), A_GPR(vol), A_EXTIN(input))\r\nif (emu->card_capabilities->emu_model) {\r\nif (emu->card_capabilities->ca0108_chip) {\r\nA_OP(icode, &ptr, iMACINT0, A_GPR(tmp), A_C_00000000, A3_EMU32IN(0x0), A_C_00000001);\r\nA_OP(icode, &ptr, iMAC0, A_GPR(capture+0), A_GPR(capture+0), A_GPR(gpr), A_GPR(tmp));\r\nA_OP(icode, &ptr, iMACINT0, A_GPR(tmp), A_C_00000000, A3_EMU32IN(0x1), A_C_00000001);\r\nA_OP(icode, &ptr, iMAC0, A_GPR(capture+1), A_GPR(capture+1), A_GPR(gpr), A_GPR(tmp));\r\n} else {\r\nA_OP(icode, &ptr, iMAC0, A_GPR(capture+0), A_GPR(capture+0), A_GPR(gpr), A_P16VIN(0x0));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(capture+1), A_GPR(capture+1), A_GPR(gpr+1), A_P16VIN(0x1));\r\n}\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "EMU Capture Volume", gpr, 0);\r\ngpr += 2;\r\n}\r\nA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_AC97_L);\r\nA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_AC97_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "AMic Playback Volume", gpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_AC97_L);\r\nA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_AC97_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Mic Capture Volume", gpr, 0);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iINTERP, A_EXTOUT(A_EXTOUT_MIC_CAP), A_EXTIN(A_EXTIN_AC97_L), 0xcd, A_EXTIN(A_EXTIN_AC97_R));\r\nA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_SPDIF_CD_L);\r\nA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_SPDIF_CD_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++],\r\nemu->card_capabilities->ac97_chip ? "Audigy CD Playback Volume" : "CD Playback Volume",\r\ngpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_SPDIF_CD_L);\r\nA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_SPDIF_CD_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++],\r\nemu->card_capabilities->ac97_chip ? "Audigy CD Capture Volume" : "CD Capture Volume",\r\ngpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_OPT_SPDIF_L);\r\nA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_OPT_SPDIF_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], SNDRV_CTL_NAME_IEC958("Optical ",PLAYBACK,VOLUME), gpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_OPT_SPDIF_L);\r\nA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_OPT_SPDIF_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], SNDRV_CTL_NAME_IEC958("Optical ",CAPTURE,VOLUME), gpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_LINE2_L);\r\nA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_LINE2_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++],\r\nemu->card_capabilities->ac97_chip ? "Line2 Playback Volume" : "Line Playback Volume",\r\ngpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_LINE2_L);\r\nA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_LINE2_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++],\r\nemu->card_capabilities->ac97_chip ? "Line2 Capture Volume" : "Line Capture Volume",\r\ngpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_ADC_L);\r\nA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_ADC_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Analog Mix Playback Volume", gpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_ADC_L);\r\nA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_ADC_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Analog Mix Capture Volume", gpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(stereo_mix, gpr, A_EXTIN_AUX2_L);\r\nA_ADD_VOLUME_IN(stereo_mix+1, gpr+1, A_EXTIN_AUX2_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++],\r\nemu->card_capabilities->ac97_chip ? "Aux2 Playback Volume" : "Aux Playback Volume",\r\ngpr, 0);\r\ngpr += 2;\r\nA_ADD_VOLUME_IN(capture, gpr, A_EXTIN_AUX2_L);\r\nA_ADD_VOLUME_IN(capture+1, gpr+1, A_EXTIN_AUX2_R);\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++],\r\nemu->card_capabilities->ac97_chip ? "Aux2 Capture Volume" : "Aux Capture Volume",\r\ngpr, 0);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback), A_GPR(playback), A_GPR(gpr), A_GPR(stereo_mix));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+1), A_GPR(playback+1), A_GPR(gpr+1), A_GPR(stereo_mix+1));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Front Playback Volume", gpr, 100);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+2), A_GPR(playback+2), A_GPR(gpr), A_GPR(stereo_mix));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+3), A_GPR(playback+3), A_GPR(gpr+1), A_GPR(stereo_mix+1));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Surround Playback Volume", gpr, 0);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iINTERP, A_GPR(tmp), A_GPR(stereo_mix), 0xcd, A_GPR(stereo_mix+1));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+4), A_GPR(playback+4), A_GPR(gpr), A_GPR(tmp));\r\nsnd_emu10k1_init_mono_control(&controls[nctl++], "Center Playback Volume", gpr, 0);\r\ngpr++;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+5), A_GPR(playback+5), A_GPR(gpr), A_GPR(tmp));\r\nsnd_emu10k1_init_mono_control(&controls[nctl++], "LFE Playback Volume", gpr, 0);\r\ngpr++;\r\nif (emu->card_capabilities->spk71) {\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+6), A_GPR(playback+6), A_GPR(gpr), A_GPR(stereo_mix));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+7), A_GPR(playback+7), A_GPR(gpr+1), A_GPR(stereo_mix+1));\r\nsnd_emu10k1_init_stereo_control(&controls[nctl++], "Side Playback Volume", gpr, 0);\r\ngpr += 2;\r\n}\r\n#define A_PUT_OUTPUT(out,src) A_OP(icode, &ptr, iACC3, A_EXTOUT(out), A_C_00000000, A_C_00000000, A_GPR(src))\r\n#define A_PUT_STEREO_OUTPUT(out1,out2,src) \\r\n{A_PUT_OUTPUT(out1,src); A_PUT_OUTPUT(out2,src+1);}\r\n#define _A_SWITCH(icode, ptr, dst, src, sw) \\r\nA_OP((icode), ptr, iMACINT0, dst, A_C_00000000, src, sw);\r\n#define A_SWITCH(icode, ptr, dst, src, sw) \\r\n_A_SWITCH(icode, ptr, A_GPR(dst), A_GPR(src), A_GPR(sw))\r\n#define _A_SWITCH_NEG(icode, ptr, dst, src) \\r\nA_OP((icode), ptr, iANDXOR, dst, src, A_C_00000001, A_C_00000001);\r\n#define A_SWITCH_NEG(icode, ptr, dst, src) \\r\n_A_SWITCH_NEG(icode, ptr, A_GPR(dst), A_GPR(src))\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 0), A_GPR(playback + 0), A_C_00000000, A_C_00000000);\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 1), A_GPR(playback + 1), A_C_00000000, A_C_00000000);\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 2), A_GPR(playback + 2), A_C_00000000, A_C_00000000);\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 3), A_GPR(playback + 3), A_C_00000000, A_C_00000000);\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 4), A_GPR(playback + 4), A_C_00000000, A_C_00000000);\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 5), A_GPR(playback + 5), A_C_00000000, A_C_00000000);\r\nif (emu->card_capabilities->spk71) {\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 6), A_GPR(playback + 6), A_C_00000000, A_C_00000000);\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 7), A_GPR(playback + 7), A_C_00000000, A_C_00000000);\r\n}\r\nctl = &controls[nctl + 0];\r\nctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(ctl->id.name, "Tone Control - Bass");\r\nctl->vcount = 2;\r\nctl->count = 10;\r\nctl->min = 0;\r\nctl->max = 40;\r\nctl->value[0] = ctl->value[1] = 20;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_BASS;\r\nctl = &controls[nctl + 1];\r\nctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(ctl->id.name, "Tone Control - Treble");\r\nctl->vcount = 2;\r\nctl->count = 10;\r\nctl->min = 0;\r\nctl->max = 40;\r\nctl->value[0] = ctl->value[1] = 20;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_TREBLE;\r\n#define BASS_GPR 0x8c\r\n#define TREBLE_GPR 0x96\r\nfor (z = 0; z < 5; z++) {\r\nint j;\r\nfor (j = 0; j < 2; j++) {\r\ncontrols[nctl + 0].gpr[z * 2 + j] = BASS_GPR + z * 2 + j;\r\ncontrols[nctl + 1].gpr[z * 2 + j] = TREBLE_GPR + z * 2 + j;\r\n}\r\n}\r\nfor (z = 0; z < 4; z++) {\r\nint j, k, l, d;\r\nfor (j = 0; j < 2; j++) {\r\nk = 0xb0 + (z * 8) + (j * 4);\r\nl = 0xe0 + (z * 8) + (j * 4);\r\nd = playback + SND_EMU10K1_PLAYBACK_CHANNELS + z * 2 + j;\r\nA_OP(icode, &ptr, iMAC0, A_C_00000000, A_C_00000000, A_GPR(d), A_GPR(BASS_GPR + 0 + j));\r\nA_OP(icode, &ptr, iMACMV, A_GPR(k+1), A_GPR(k), A_GPR(k+1), A_GPR(BASS_GPR + 4 + j));\r\nA_OP(icode, &ptr, iMACMV, A_GPR(k), A_GPR(d), A_GPR(k), A_GPR(BASS_GPR + 2 + j));\r\nA_OP(icode, &ptr, iMACMV, A_GPR(k+3), A_GPR(k+2), A_GPR(k+3), A_GPR(BASS_GPR + 8 + j));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(k+2), A_GPR_ACCU, A_GPR(k+2), A_GPR(BASS_GPR + 6 + j));\r\nA_OP(icode, &ptr, iACC3, A_GPR(k+2), A_GPR(k+2), A_GPR(k+2), A_C_00000000);\r\nA_OP(icode, &ptr, iMAC0, A_C_00000000, A_C_00000000, A_GPR(k+2), A_GPR(TREBLE_GPR + 0 + j));\r\nA_OP(icode, &ptr, iMACMV, A_GPR(l+1), A_GPR(l), A_GPR(l+1), A_GPR(TREBLE_GPR + 4 + j));\r\nA_OP(icode, &ptr, iMACMV, A_GPR(l), A_GPR(k+2), A_GPR(l), A_GPR(TREBLE_GPR + 2 + j));\r\nA_OP(icode, &ptr, iMACMV, A_GPR(l+3), A_GPR(l+2), A_GPR(l+3), A_GPR(TREBLE_GPR + 8 + j));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(l+2), A_GPR_ACCU, A_GPR(l+2), A_GPR(TREBLE_GPR + 6 + j));\r\nA_OP(icode, &ptr, iMACINT0, A_GPR(l+2), A_C_00000000, A_GPR(l+2), A_C_00000010);\r\nA_OP(icode, &ptr, iACC3, A_GPR(d), A_GPR(l+2), A_C_00000000, A_C_00000000);\r\nif (z == 2)\r\nbreak;\r\n}\r\n}\r\nnctl += 2;\r\n#undef BASS_GPR\r\n#undef TREBLE_GPR\r\nfor (z = 0; z < 8; z++) {\r\nA_SWITCH(icode, &ptr, tmp + 0, playback + SND_EMU10K1_PLAYBACK_CHANNELS + z, gpr + 0);\r\nA_SWITCH_NEG(icode, &ptr, tmp + 1, gpr + 0);\r\nA_SWITCH(icode, &ptr, tmp + 1, playback + z, tmp + 1);\r\nA_OP(icode, &ptr, iACC3, A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + z), A_GPR(tmp + 0), A_GPR(tmp + 1), A_C_00000000);\r\n}\r\nsnd_emu10k1_init_stereo_onoff_control(controls + nctl++, "Tone Control - Switch", gpr, 0);\r\ngpr += 2;\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+0+SND_EMU10K1_PLAYBACK_CHANNELS), A_C_00000000, A_GPR(gpr), A_GPR(playback+0+SND_EMU10K1_PLAYBACK_CHANNELS));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+1+SND_EMU10K1_PLAYBACK_CHANNELS), A_C_00000000, A_GPR(gpr), A_GPR(playback+1+SND_EMU10K1_PLAYBACK_CHANNELS));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+2+SND_EMU10K1_PLAYBACK_CHANNELS), A_C_00000000, A_GPR(gpr), A_GPR(playback+2+SND_EMU10K1_PLAYBACK_CHANNELS));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+3+SND_EMU10K1_PLAYBACK_CHANNELS), A_C_00000000, A_GPR(gpr), A_GPR(playback+3+SND_EMU10K1_PLAYBACK_CHANNELS));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+4+SND_EMU10K1_PLAYBACK_CHANNELS), A_C_00000000, A_GPR(gpr), A_GPR(playback+4+SND_EMU10K1_PLAYBACK_CHANNELS));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+5+SND_EMU10K1_PLAYBACK_CHANNELS), A_C_00000000, A_GPR(gpr), A_GPR(playback+5+SND_EMU10K1_PLAYBACK_CHANNELS));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+6+SND_EMU10K1_PLAYBACK_CHANNELS), A_C_00000000, A_GPR(gpr), A_GPR(playback+6+SND_EMU10K1_PLAYBACK_CHANNELS));\r\nA_OP(icode, &ptr, iMAC0, A_GPR(playback+7+SND_EMU10K1_PLAYBACK_CHANNELS), A_C_00000000, A_GPR(gpr), A_GPR(playback+7+SND_EMU10K1_PLAYBACK_CHANNELS));\r\nsnd_emu10k1_init_mono_control(&controls[nctl++], "Wave Master Playback Volume", gpr, 0);\r\ngpr += 2;\r\nA_PUT_STEREO_OUTPUT(A_EXTOUT_AFRONT_L, A_EXTOUT_AFRONT_R, playback + SND_EMU10K1_PLAYBACK_CHANNELS);\r\nA_PUT_STEREO_OUTPUT(A_EXTOUT_AREAR_L, A_EXTOUT_AREAR_R, playback+2 + SND_EMU10K1_PLAYBACK_CHANNELS);\r\nA_PUT_OUTPUT(A_EXTOUT_ACENTER, playback+4 + SND_EMU10K1_PLAYBACK_CHANNELS);\r\nA_PUT_OUTPUT(A_EXTOUT_ALFE, playback+5 + SND_EMU10K1_PLAYBACK_CHANNELS);\r\nif (emu->card_capabilities->spk71)\r\nA_PUT_STEREO_OUTPUT(A_EXTOUT_ASIDE_L, A_EXTOUT_ASIDE_R, playback+6 + SND_EMU10K1_PLAYBACK_CHANNELS);\r\nA_PUT_STEREO_OUTPUT(A_EXTOUT_HEADPHONE_L, A_EXTOUT_HEADPHONE_R, playback + SND_EMU10K1_PLAYBACK_CHANNELS);\r\nif (emu->card_capabilities->emu_model) {\r\nsnd_printk(KERN_INFO "EMU outputs on\n");\r\nfor (z = 0; z < 8; z++) {\r\nif (emu->card_capabilities->ca0108_chip) {\r\nA_OP(icode, &ptr, iACC3, A3_EMU32OUT(z), A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + z), A_C_00000000, A_C_00000000);\r\n} else {\r\nA_OP(icode, &ptr, iACC3, A_EMU32OUTL(z), A_GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + z), A_C_00000000, A_C_00000000);\r\n}\r\n}\r\n}\r\ngpr_map[gpr++] = 0;\r\ngpr_map[gpr++] = 0x1008;\r\ngpr_map[gpr++] = 0xffff0000;\r\nfor (z = 0; z < 2; z++) {\r\nA_OP(icode, &ptr, iMAC0, A_GPR(tmp + 2), A_FXBUS(FXBUS_PT_LEFT + z), A_C_00000000, A_C_00000000);\r\nA_OP(icode, &ptr, iSKIP, A_GPR_COND, A_GPR_COND, A_GPR(gpr - 2), A_C_00000001);\r\nA_OP(icode, &ptr, iACC3, A_GPR(tmp + 2), A_C_00000000, A_C_00010000, A_GPR(tmp + 2));\r\nA_OP(icode, &ptr, iANDXOR, A_GPR(tmp + 2), A_GPR(tmp + 2), A_GPR(gpr - 1), A_C_00000000);\r\nA_SWITCH(icode, &ptr, tmp + 0, tmp + 2, gpr + z);\r\nA_SWITCH_NEG(icode, &ptr, tmp + 1, gpr + z);\r\nA_SWITCH(icode, &ptr, tmp + 1, playback + SND_EMU10K1_PLAYBACK_CHANNELS + z, tmp + 1);\r\nif ((z==1) && (emu->card_capabilities->spdif_bug)) {\r\nsnd_printk(KERN_INFO "Installing spdif_bug patch: %s\n", emu->card_capabilities->name);\r\nA_OP(icode, &ptr, iACC3, A_EXTOUT(A_EXTOUT_FRONT_L + z), A_GPR(gpr - 3), A_C_00000000, A_C_00000000);\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 3), A_GPR(tmp + 0), A_GPR(tmp + 1), A_C_00000000);\r\n} else {\r\nA_OP(icode, &ptr, iACC3, A_EXTOUT(A_EXTOUT_FRONT_L + z), A_GPR(tmp + 0), A_GPR(tmp + 1), A_C_00000000);\r\n}\r\n}\r\nsnd_emu10k1_init_stereo_onoff_control(controls + nctl++, SNDRV_CTL_NAME_IEC958("Optical Raw ",PLAYBACK,SWITCH), gpr, 0);\r\ngpr += 2;\r\nA_PUT_STEREO_OUTPUT(A_EXTOUT_REAR_L, A_EXTOUT_REAR_R, playback+2 + SND_EMU10K1_PLAYBACK_CHANNELS);\r\nA_PUT_OUTPUT(A_EXTOUT_CENTER, playback+4 + SND_EMU10K1_PLAYBACK_CHANNELS);\r\nA_PUT_OUTPUT(A_EXTOUT_LFE, playback+5 + SND_EMU10K1_PLAYBACK_CHANNELS);\r\n#ifdef EMU10K1_CAPTURE_DIGITAL_OUT\r\nA_PUT_STEREO_OUTPUT(A_EXTOUT_ADC_CAP_L, A_EXTOUT_ADC_CAP_R, playback + SND_EMU10K1_PLAYBACK_CHANNELS);\r\n#else\r\nA_PUT_OUTPUT(A_EXTOUT_ADC_CAP_L, capture);\r\nA_PUT_OUTPUT(A_EXTOUT_ADC_CAP_R, capture+1);\r\n#endif\r\nif (emu->card_capabilities->emu_model) {\r\nif (emu->card_capabilities->ca0108_chip) {\r\nsnd_printk(KERN_INFO "EMU2 inputs on\n");\r\nfor (z = 0; z < 0x10; z++) {\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp,\r\nbit_shifter16,\r\nA3_EMU32IN(z),\r\nA_FXBUS2(z*2) );\r\n}\r\n} else {\r\nsnd_printk(KERN_INFO "EMU inputs on\n");\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_P16VIN(0x0), A_FXBUS2(0) );\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(2) );\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x1), A_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(4) );\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x2), A_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(6) );\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x3), A_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(0x8) );\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x4), A_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(0xa) );\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x5), A_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(0xc) );\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x6), A_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16( icode, &ptr, tmp, bit_shifter16, A_GPR(gpr - 1), A_FXBUS2(0xe) );\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x7), A_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, &ptr, tmp,\r\nbit_shifter16,\r\nA_GPR(gpr - 1),\r\nA_FXBUS2(0x10));\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x8),\r\nA_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, &ptr, tmp,\r\nbit_shifter16,\r\nA_GPR(gpr - 1),\r\nA_FXBUS2(0x12));\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0x9),\r\nA_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, &ptr, tmp,\r\nbit_shifter16,\r\nA_GPR(gpr - 1),\r\nA_FXBUS2(0x14));\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0xa),\r\nA_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, &ptr, tmp,\r\nbit_shifter16,\r\nA_GPR(gpr - 1),\r\nA_FXBUS2(0x16));\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0xb),\r\nA_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, &ptr, tmp,\r\nbit_shifter16,\r\nA_GPR(gpr - 1),\r\nA_FXBUS2(0x18));\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0xc),\r\nA_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, &ptr, tmp,\r\nbit_shifter16,\r\nA_GPR(gpr - 1),\r\nA_FXBUS2(0x1a));\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0xd),\r\nA_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, &ptr, tmp,\r\nbit_shifter16,\r\nA_GPR(gpr - 1),\r\nA_FXBUS2(0x1c));\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0xe),\r\nA_C_00000000, A_C_00000000);\r\ngpr_map[gpr++] = 0x00000000;\r\nsnd_emu10k1_audigy_dsp_convert_32_to_2x16(icode, &ptr, tmp,\r\nbit_shifter16,\r\nA_GPR(gpr - 1),\r\nA_FXBUS2(0x1e));\r\nA_OP(icode, &ptr, iACC3, A_GPR(gpr - 1), A_P16VIN(0xf),\r\nA_C_00000000, A_C_00000000);\r\n}\r\n#if 0\r\nfor (z = 4; z < 8; z++) {\r\nA_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_C_00000000);\r\n}\r\nfor (z = 0xc; z < 0x10; z++) {\r\nA_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_C_00000000);\r\n}\r\n#endif\r\n} else {\r\nfor (z = 0; z < 16; z++) {\r\nA_OP(icode, &ptr, iACC3, A_FXBUS2(z), A_C_00000000, A_C_00000000, A_EXTIN(z));\r\n}\r\n}\r\n#endif\r\nif (gpr > tmp) {\r\nsnd_BUG();\r\nerr = -EIO;\r\ngoto __err;\r\n}\r\nwhile (ptr < 0x400)\r\nA_OP(icode, &ptr, 0x0f, 0xc0, 0xc0, 0xcf, 0xc0);\r\nseg = snd_enter_user();\r\nicode->gpr_add_control_count = nctl;\r\nicode->gpr_add_controls = (struct snd_emu10k1_fx8010_control_gpr __user *)controls;\r\nemu->support_tlv = 1;\r\nerr = snd_emu10k1_icode_poke(emu, icode);\r\nemu->support_tlv = 0;\r\nsnd_leave_user(seg);\r\n__err:\r\nkfree(controls);\r\nif (icode != NULL) {\r\nkfree((void __force *)icode->gpr_map);\r\nkfree(icode);\r\n}\r\nreturn err;\r\n}\r\nstatic void _volume(struct snd_emu10k1_fx8010_code *icode, u32 *ptr, u32 dst, u32 src, u32 vol)\r\n{\r\nOP(icode, ptr, iMAC0, dst, C_00000000, src, vol);\r\nOP(icode, ptr, iANDXOR, C_00000000, vol, C_ffffffff, C_7fffffff);\r\nOP(icode, ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000001);\r\nOP(icode, ptr, iACC3, dst, src, C_00000000, C_00000000);\r\n}\r\nstatic void _volume_add(struct snd_emu10k1_fx8010_code *icode, u32 *ptr, u32 dst, u32 src, u32 vol)\r\n{\r\nOP(icode, ptr, iANDXOR, C_00000000, vol, C_ffffffff, C_7fffffff);\r\nOP(icode, ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000002);\r\nOP(icode, ptr, iMACINT0, dst, dst, src, C_00000001);\r\nOP(icode, ptr, iSKIP, C_00000000, C_7fffffff, C_7fffffff, C_00000001);\r\nOP(icode, ptr, iMAC0, dst, dst, src, vol);\r\n}\r\nstatic void _volume_out(struct snd_emu10k1_fx8010_code *icode, u32 *ptr, u32 dst, u32 src, u32 vol)\r\n{\r\nOP(icode, ptr, iANDXOR, C_00000000, vol, C_ffffffff, C_7fffffff);\r\nOP(icode, ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000002);\r\nOP(icode, ptr, iACC3, dst, src, C_00000000, C_00000000);\r\nOP(icode, ptr, iSKIP, C_00000000, C_7fffffff, C_7fffffff, C_00000001);\r\nOP(icode, ptr, iMAC0, dst, C_00000000, src, vol);\r\n}\r\nstatic int _snd_emu10k1_init_efx(struct snd_emu10k1 *emu)\r\n{\r\nint err, i, z, gpr, tmp, playback, capture;\r\nu32 ptr;\r\nstruct snd_emu10k1_fx8010_code *icode;\r\nstruct snd_emu10k1_fx8010_pcm_rec *ipcm = NULL;\r\nstruct snd_emu10k1_fx8010_control_gpr *controls = NULL, *ctl;\r\nu32 *gpr_map;\r\nmm_segment_t seg;\r\nif ((icode = kzalloc(sizeof(*icode), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nif ((icode->gpr_map = (u_int32_t __user *)\r\nkcalloc(256 + 160 + 160 + 2 * 512, sizeof(u_int32_t),\r\nGFP_KERNEL)) == NULL ||\r\n(controls = kcalloc(SND_EMU10K1_GPR_CONTROLS,\r\nsizeof(struct snd_emu10k1_fx8010_control_gpr),\r\nGFP_KERNEL)) == NULL ||\r\n(ipcm = kzalloc(sizeof(*ipcm), GFP_KERNEL)) == NULL) {\r\nerr = -ENOMEM;\r\ngoto __err;\r\n}\r\ngpr_map = (u32 __force *)icode->gpr_map;\r\nicode->tram_data_map = icode->gpr_map + 256;\r\nicode->tram_addr_map = icode->tram_data_map + 160;\r\nicode->code = icode->tram_addr_map + 160;\r\nfor (i = 0; i < 256; i++)\r\nset_bit(i, icode->gpr_valid);\r\nfor (i = 0; i < 160; i++)\r\nset_bit(i, icode->tram_valid);\r\nstrcpy(icode->name, "SB Live! FX8010 code for ALSA v1.2 by Jaroslav Kysela");\r\nptr = 0; i = 0;\r\nplayback = SND_EMU10K1_INPUTS;\r\ncapture = playback + (SND_EMU10K1_PLAYBACK_CHANNELS * 2);\r\ngpr = capture + SND_EMU10K1_CAPTURE_CHANNELS;\r\ntmp = 0x88;\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, (emu->fx8010.dbg = 0) | EMU10K1_DBG_SINGLE_STEP);\r\nOP(icode, &ptr, iMACINT0, GPR(0), C_00000000, FXBUS(FXBUS_PCM_LEFT), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(1), C_00000000, FXBUS(FXBUS_PCM_RIGHT), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(2), C_00000000, FXBUS(FXBUS_MIDI_LEFT), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(3), C_00000000, FXBUS(FXBUS_MIDI_RIGHT), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(4), C_00000000, FXBUS(FXBUS_PCM_LEFT_REAR), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(5), C_00000000, FXBUS(FXBUS_PCM_RIGHT_REAR), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(6), C_00000000, FXBUS(FXBUS_PCM_CENTER), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(7), C_00000000, FXBUS(FXBUS_PCM_LFE), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(8), C_00000000, C_00000000, C_00000000);\r\nOP(icode, &ptr, iMACINT0, GPR(9), C_00000000, C_00000000, C_00000000);\r\nOP(icode, &ptr, iMACINT0, GPR(10), C_00000000, FXBUS(FXBUS_PCM_LEFT_FRONT), C_00000004);\r\nOP(icode, &ptr, iMACINT0, GPR(11), C_00000000, FXBUS(FXBUS_PCM_RIGHT_FRONT), C_00000004);\r\nipcm->substream = 0;\r\nipcm->channels = 2;\r\nipcm->tram_start = 0;\r\nipcm->buffer_size = (64 * 1024) / 2;\r\nipcm->gpr_size = gpr++;\r\nipcm->gpr_ptr = gpr++;\r\nipcm->gpr_count = gpr++;\r\nipcm->gpr_tmpcount = gpr++;\r\nipcm->gpr_trigger = gpr++;\r\nipcm->gpr_running = gpr++;\r\nipcm->etram[0] = 0;\r\nipcm->etram[1] = 1;\r\ngpr_map[gpr + 0] = 0xfffff000;\r\ngpr_map[gpr + 1] = 0xffff0000;\r\ngpr_map[gpr + 2] = 0x70000000;\r\ngpr_map[gpr + 3] = 0x00000007;\r\ngpr_map[gpr + 4] = 0x001f << 11;\r\ngpr_map[gpr + 5] = 0x001c << 11;\r\ngpr_map[gpr + 6] = (0x22 - 0x01) - 1;\r\ngpr_map[gpr + 7] = (0x22 - 0x06) - 1;\r\ngpr_map[gpr + 8] = 0x2000000 + (2<<11);\r\ngpr_map[gpr + 9] = 0x4000000 + (2<<11);\r\ngpr_map[gpr + 10] = 1<<11;\r\ngpr_map[gpr + 11] = (0x24 - 0x0a) - 1;\r\ngpr_map[gpr + 12] = 0;\r\nOP(icode, &ptr, iMAC0, C_00000000, GPR(ipcm->gpr_trigger), C_00000000, C_00000000);\r\nOP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_ZERO, GPR(gpr + 6));\r\nOP(icode, &ptr, iMAC0, C_00000000, GPR(ipcm->gpr_running), C_00000000, C_00000000);\r\nOP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000004);\r\nOP(icode, &ptr, iANDXOR, GPR(tmp + 0), GPR_DBAC, GPR(gpr + 4), C_00000000);\r\nOP(icode, &ptr, iMACINT0, C_00000000, GPR(tmp + 0), C_ffffffff, GPR(gpr + 5));\r\nOP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, GPR(gpr + 7));\r\nOP(icode, &ptr, iACC3, GPR(gpr + 12), C_00000010, C_00000001, C_00000000);\r\nOP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00000000, C_00000001);\r\nOP(icode, &ptr, iACC3, GPR(gpr + 12), GPR(gpr + 12), C_ffffffff, C_00000000);\r\nOP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, GPR(gpr + 11));\r\nOP(icode, &ptr, iACC3, GPR(gpr + 12), C_00000001, C_00000000, C_00000000);\r\nOP(icode, &ptr, iANDXOR, GPR(tmp + 0), ETRAM_DATA(ipcm->etram[0]), GPR(gpr + 0), C_00000000);\r\nOP(icode, &ptr, iLOG, GPR(tmp + 0), GPR(tmp + 0), GPR(gpr + 3), C_00000000);\r\nOP(icode, &ptr, iANDXOR, GPR(8), GPR(tmp + 0), GPR(gpr + 1), GPR(gpr + 2));\r\nOP(icode, &ptr, iSKIP, C_00000000, GPR_COND, CC_REG_MINUS, C_00000001);\r\nOP(icode, &ptr, iANDXOR, GPR(8), GPR(8), GPR(gpr + 1), GPR(gpr + 2));\r\nOP(icode, &ptr, iANDXOR, GPR(tmp + 0), ETRAM_DATA(ipcm->etram[1]), GPR(gpr + 0), C_00000000);\r\nOP(icode, &ptr, iLOG, GPR(tmp + 0), GPR(tmp + 0), GPR(gpr + 3), C_00000000);\r\nOP(icode, &ptr, iANDXOR, GPR(9), GPR(tmp + 0), GPR(gpr + 1), GPR(gpr + 2));\r\nOP(icode, &ptr, iSKIP, C_00000000, GPR_COND, CC_REG_MINUS, C_00000001);\r\nOP(icode, &ptr, iANDXOR, GPR(9), GPR(9), GPR(gpr + 1), GPR(gpr + 2));\r\nOP(icode, &ptr, iACC3, GPR(tmp + 0), GPR(ipcm->gpr_ptr), C_00000001, C_00000000);\r\nOP(icode, &ptr, iMACINT0, C_00000000, GPR(tmp + 0), C_ffffffff, GPR(ipcm->gpr_size));\r\nOP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_MINUS, C_00000001);\r\nOP(icode, &ptr, iACC3, GPR(tmp + 0), C_00000000, C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, GPR(ipcm->gpr_ptr), GPR(tmp + 0), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, GPR(ipcm->gpr_tmpcount), GPR(ipcm->gpr_tmpcount), C_ffffffff, C_00000000);\r\nOP(icode, &ptr, iSKIP, GPR_COND, GPR_COND, CC_REG_NONZERO, C_00000002);\r\nOP(icode, &ptr, iACC3, GPR(ipcm->gpr_tmpcount), GPR(ipcm->gpr_count), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, GPR_IRQ, C_80000000, C_00000000, C_00000000);\r\nOP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00000001, C_00010000);\r\nOP(icode, &ptr, iANDXOR, GPR(ipcm->gpr_running), GPR(ipcm->gpr_running), C_00010000, C_00000001);\r\nOP(icode, &ptr, iSKIP, C_00000000, C_7fffffff, C_7fffffff, C_00000002);\r\nOP(icode, &ptr, iMACINT1, ETRAM_ADDR(ipcm->etram[0]), GPR(gpr + 8), GPR_DBAC, C_ffffffff);\r\nOP(icode, &ptr, iMACINT1, ETRAM_ADDR(ipcm->etram[1]), GPR(gpr + 9), GPR_DBAC, C_ffffffff);\r\ngpr += 13;\r\nfor (z = 0; z < 2; z++)\r\nVOLUME(icode, &ptr, playback + z, z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Wave Playback Volume", gpr, 100);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++)\r\nVOLUME(icode, &ptr, playback + 2 + z, z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Wave Surround Playback Volume", gpr, 0);\r\ngpr += 2;\r\nOP(icode, &ptr, iACC3, GPR(tmp + 0), FXBUS(FXBUS_PCM_LEFT), FXBUS(FXBUS_PCM_RIGHT), C_00000000);\r\nOP(icode, &ptr, iMACINT0, GPR(tmp + 0), C_00000000, GPR(tmp + 0), C_00000002);\r\nVOLUME(icode, &ptr, playback + 4, tmp + 0, gpr);\r\nsnd_emu10k1_init_mono_control(controls + i++, "Wave Center Playback Volume", gpr++, 0);\r\nVOLUME(icode, &ptr, playback + 5, tmp + 0, gpr);\r\nsnd_emu10k1_init_mono_control(controls + i++, "Wave LFE Playback Volume", gpr++, 0);\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH(icode, &ptr, tmp + 0, z, gpr + 2 + z);\r\nVOLUME(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Wave Capture Volume", gpr, 0);\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, "Wave Capture Switch", gpr + 2, 0);\r\ngpr += 4;\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADD(icode, &ptr, playback + z, 2 + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Synth Playback Volume", gpr, 100);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH(icode, &ptr, tmp + 0, 2 + z, gpr + 2 + z);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Synth Capture Volume", gpr, 0);\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, "Synth Capture Switch", gpr + 2, 0);\r\ngpr += 4;\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADD(icode, &ptr, playback + 2 + z, 4 + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Surround Digital Playback Volume", gpr, 100);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH(icode, &ptr, tmp + 0, 4 + z, gpr + 2 + z);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Surround Capture Volume", gpr, 0);\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, "Surround Capture Switch", gpr + 2, 0);\r\ngpr += 4;\r\nVOLUME_ADD(icode, &ptr, playback + 4, 6, gpr);\r\nsnd_emu10k1_init_mono_control(controls + i++, "Center Digital Playback Volume", gpr++, 100);\r\nVOLUME_ADD(icode, &ptr, playback + 5, 7, gpr);\r\nsnd_emu10k1_init_mono_control(controls + i++, "LFE Digital Playback Volume", gpr++, 100);\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADD(icode, &ptr, playback + z, 10 + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Front Playback Volume", gpr, 100);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH(icode, &ptr, tmp + 0, 10 + z, gpr + 2);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Front Capture Volume", gpr, 0);\r\nsnd_emu10k1_init_mono_onoff_control(controls + i++, "Front Capture Switch", gpr + 2, 0);\r\ngpr += 3;\r\nif (emu->fx8010.extin_mask & ((1<<EXTIN_AC97_L)|(1<<EXTIN_AC97_R))) {\r\nVOLUME_ADDIN(icode, &ptr, playback + 0, EXTIN_AC97_L, gpr); gpr++;\r\nVOLUME_ADDIN(icode, &ptr, playback + 1, EXTIN_AC97_R, gpr); gpr++;\r\nsnd_emu10k1_init_stereo_control(controls + i++, "AC97 Playback Volume", gpr-2, 0);\r\nVOLUME_ADDIN(icode, &ptr, capture + 0, EXTIN_AC97_L, gpr); gpr++;\r\nVOLUME_ADDIN(icode, &ptr, capture + 1, EXTIN_AC97_R, gpr); gpr++;\r\nsnd_emu10k1_init_stereo_control(controls + i++, "AC97 Capture Volume", gpr-2, 100);\r\n}\r\nif (emu->fx8010.extin_mask & ((1<<EXTIN_SPDIF_CD_L)|(1<<EXTIN_SPDIF_CD_R))) {\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_SPDIF_CD_L + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958("TTL ",PLAYBACK,VOLUME), gpr, 0);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_SPDIF_CD_L + z, gpr + 2 + z);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958("TTL ",CAPTURE,VOLUME), gpr, 0);\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, SNDRV_CTL_NAME_IEC958("TTL ",CAPTURE,SWITCH), gpr + 2, 0);\r\ngpr += 4;\r\n}\r\nif (emu->fx8010.extin_mask & ((1<<EXTIN_ZOOM_L)|(1<<EXTIN_ZOOM_R))) {\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_ZOOM_L + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Zoom Video Playback Volume", gpr, 0);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_ZOOM_L + z, gpr + 2 + z);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Zoom Video Capture Volume", gpr, 0);\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, "Zoom Video Capture Switch", gpr + 2, 0);\r\ngpr += 4;\r\n}\r\nif (emu->fx8010.extin_mask & ((1<<EXTIN_TOSLINK_L)|(1<<EXTIN_TOSLINK_R))) {\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_TOSLINK_L + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958("LiveDrive ",PLAYBACK,VOLUME), gpr, 0);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_TOSLINK_L + z, gpr + 2 + z);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958("LiveDrive ",CAPTURE,VOLUME), gpr, 0);\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, SNDRV_CTL_NAME_IEC958("LiveDrive ",CAPTURE,SWITCH), gpr + 2, 0);\r\ngpr += 4;\r\n}\r\nif (emu->fx8010.extin_mask & ((1<<EXTIN_LINE1_L)|(1<<EXTIN_LINE1_R))) {\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_LINE1_L + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Line LiveDrive Playback Volume", gpr, 0);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_LINE1_L + z, gpr + 2 + z);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Line LiveDrive Capture Volume", gpr, 0);\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, "Line LiveDrive Capture Switch", gpr + 2, 0);\r\ngpr += 4;\r\n}\r\nif (emu->fx8010.extin_mask & ((1<<EXTIN_COAX_SPDIF_L)|(1<<EXTIN_COAX_SPDIF_R))) {\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_COAX_SPDIF_L + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958("Coaxial ",PLAYBACK,VOLUME), gpr, 0);\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_COAX_SPDIF_L + z, gpr + 2 + z);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, SNDRV_CTL_NAME_IEC958("Coaxial ",CAPTURE,VOLUME), gpr, 0);\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, SNDRV_CTL_NAME_IEC958("Coaxial ",CAPTURE,SWITCH), gpr + 2, 0);\r\ngpr += 4;\r\n}\r\nif (emu->fx8010.extin_mask & ((1<<EXTIN_LINE2_L)|(1<<EXTIN_LINE2_R))) {\r\nfor (z = 0; z < 2; z++)\r\nVOLUME_ADDIN(icode, &ptr, playback + z, EXTIN_LINE2_L + z, gpr + z);\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Line2 LiveDrive Playback Volume", gpr, 0);\r\ncontrols[i-1].id.index = 1;\r\ngpr += 2;\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH_IN(icode, &ptr, tmp + 0, EXTIN_LINE2_L + z, gpr + 2 + z);\r\nVOLUME_ADD(icode, &ptr, capture + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Line2 LiveDrive Capture Volume", gpr, 0);\r\ncontrols[i-1].id.index = 1;\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, "Line2 LiveDrive Capture Switch", gpr + 2, 0);\r\ncontrols[i-1].id.index = 1;\r\ngpr += 4;\r\n}\r\nOP(icode, &ptr, iACC3, GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 0), GPR(playback + 0), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 1), GPR(playback + 1), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 2), GPR(playback + 2), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 3), GPR(playback + 3), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 4), GPR(playback + 4), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 5), GPR(playback + 5), C_00000000, C_00000000);\r\nctl = &controls[i + 0];\r\nctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(ctl->id.name, "Tone Control - Bass");\r\nctl->vcount = 2;\r\nctl->count = 10;\r\nctl->min = 0;\r\nctl->max = 40;\r\nctl->value[0] = ctl->value[1] = 20;\r\nctl->tlv = snd_emu10k1_bass_treble_db_scale;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_BASS;\r\nctl = &controls[i + 1];\r\nctl->id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(ctl->id.name, "Tone Control - Treble");\r\nctl->vcount = 2;\r\nctl->count = 10;\r\nctl->min = 0;\r\nctl->max = 40;\r\nctl->value[0] = ctl->value[1] = 20;\r\nctl->tlv = snd_emu10k1_bass_treble_db_scale;\r\nctl->translation = EMU10K1_GPR_TRANSLATION_TREBLE;\r\n#define BASS_GPR 0x8c\r\n#define TREBLE_GPR 0x96\r\nfor (z = 0; z < 5; z++) {\r\nint j;\r\nfor (j = 0; j < 2; j++) {\r\ncontrols[i + 0].gpr[z * 2 + j] = BASS_GPR + z * 2 + j;\r\ncontrols[i + 1].gpr[z * 2 + j] = TREBLE_GPR + z * 2 + j;\r\n}\r\n}\r\nfor (z = 0; z < 3; z++) {\r\nint j, k, l, d;\r\nfor (j = 0; j < 2; j++) {\r\nk = 0xa0 + (z * 8) + (j * 4);\r\nl = 0xd0 + (z * 8) + (j * 4);\r\nd = playback + SND_EMU10K1_PLAYBACK_CHANNELS + z * 2 + j;\r\nOP(icode, &ptr, iMAC0, C_00000000, C_00000000, GPR(d), GPR(BASS_GPR + 0 + j));\r\nOP(icode, &ptr, iMACMV, GPR(k+1), GPR(k), GPR(k+1), GPR(BASS_GPR + 4 + j));\r\nOP(icode, &ptr, iMACMV, GPR(k), GPR(d), GPR(k), GPR(BASS_GPR + 2 + j));\r\nOP(icode, &ptr, iMACMV, GPR(k+3), GPR(k+2), GPR(k+3), GPR(BASS_GPR + 8 + j));\r\nOP(icode, &ptr, iMAC0, GPR(k+2), GPR_ACCU, GPR(k+2), GPR(BASS_GPR + 6 + j));\r\nOP(icode, &ptr, iACC3, GPR(k+2), GPR(k+2), GPR(k+2), C_00000000);\r\nOP(icode, &ptr, iMAC0, C_00000000, C_00000000, GPR(k+2), GPR(TREBLE_GPR + 0 + j));\r\nOP(icode, &ptr, iMACMV, GPR(l+1), GPR(l), GPR(l+1), GPR(TREBLE_GPR + 4 + j));\r\nOP(icode, &ptr, iMACMV, GPR(l), GPR(k+2), GPR(l), GPR(TREBLE_GPR + 2 + j));\r\nOP(icode, &ptr, iMACMV, GPR(l+3), GPR(l+2), GPR(l+3), GPR(TREBLE_GPR + 8 + j));\r\nOP(icode, &ptr, iMAC0, GPR(l+2), GPR_ACCU, GPR(l+2), GPR(TREBLE_GPR + 6 + j));\r\nOP(icode, &ptr, iMACINT0, GPR(l+2), C_00000000, GPR(l+2), C_00000010);\r\nOP(icode, &ptr, iACC3, GPR(d), GPR(l+2), C_00000000, C_00000000);\r\nif (z == 2)\r\nbreak;\r\n}\r\n}\r\ni += 2;\r\n#undef BASS_GPR\r\n#undef TREBLE_GPR\r\nfor (z = 0; z < 6; z++) {\r\nSWITCH(icode, &ptr, tmp + 0, playback + SND_EMU10K1_PLAYBACK_CHANNELS + z, gpr + 0);\r\nSWITCH_NEG(icode, &ptr, tmp + 1, gpr + 0);\r\nSWITCH(icode, &ptr, tmp + 1, playback + z, tmp + 1);\r\nOP(icode, &ptr, iACC3, GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + z), GPR(tmp + 0), GPR(tmp + 1), C_00000000);\r\n}\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, "Tone Control - Switch", gpr, 0);\r\ngpr += 2;\r\nif (emu->fx8010.extout_mask & ((1<<EXTOUT_AC97_L)|(1<<EXTOUT_AC97_R))) {\r\nfor (z = 0; z < 2; z++)\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_L + z), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + z), C_00000000, C_00000000);\r\n}\r\nif (emu->fx8010.extout_mask & ((1<<EXTOUT_TOSLINK_L)|(1<<EXTOUT_TOSLINK_R))) {\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH(icode, &ptr, tmp + 0, 8 + z, gpr + z);\r\nSWITCH_NEG(icode, &ptr, tmp + 1, gpr + z);\r\nSWITCH(icode, &ptr, tmp + 1, playback + SND_EMU10K1_PLAYBACK_CHANNELS + z, tmp + 1);\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_TOSLINK_L + z), GPR(tmp + 0), GPR(tmp + 1), C_00000000);\r\n#ifdef EMU10K1_CAPTURE_DIGITAL_OUT\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ADC_CAP_L + z), GPR(tmp + 0), GPR(tmp + 1), C_00000000);\r\n#endif\r\n}\r\nsnd_emu10k1_init_stereo_onoff_control(controls + i++, SNDRV_CTL_NAME_IEC958("Optical Raw ",PLAYBACK,SWITCH), gpr, 0);\r\ngpr += 2;\r\n}\r\nif (emu->fx8010.extout_mask & ((1<<EXTOUT_HEADPHONE_L)|(1<<EXTOUT_HEADPHONE_R))) {\r\nfor (z = 0; z < 2; z++) {\r\nSWITCH(icode, &ptr, tmp + 0, playback + SND_EMU10K1_PLAYBACK_CHANNELS + 4 + z, gpr + 2 + z);\r\nSWITCH_NEG(icode, &ptr, tmp + 1, gpr + 2 + z);\r\nSWITCH(icode, &ptr, tmp + 1, playback + SND_EMU10K1_PLAYBACK_CHANNELS + z, tmp + 1);\r\nOP(icode, &ptr, iACC3, GPR(tmp + 0), GPR(tmp + 0), GPR(tmp + 1), C_00000000);\r\nVOLUME_OUT(icode, &ptr, EXTOUT_HEADPHONE_L + z, tmp + 0, gpr + z);\r\n}\r\nsnd_emu10k1_init_stereo_control(controls + i++, "Headphone Playback Volume", gpr + 0, 0);\r\ncontrols[i-1].id.index = 1;\r\nsnd_emu10k1_init_mono_onoff_control(controls + i++, "Headphone Center Playback Switch", gpr + 2, 0);\r\ncontrols[i-1].id.index = 1;\r\nsnd_emu10k1_init_mono_onoff_control(controls + i++, "Headphone LFE Playback Switch", gpr + 3, 0);\r\ncontrols[i-1].id.index = 1;\r\ngpr += 4;\r\n}\r\nif (emu->fx8010.extout_mask & ((1<<EXTOUT_REAR_L)|(1<<EXTOUT_REAR_R)))\r\nfor (z = 0; z < 2; z++)\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_REAR_L + z), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 2 + z), C_00000000, C_00000000);\r\nif (emu->fx8010.extout_mask & ((1<<EXTOUT_AC97_REAR_L)|(1<<EXTOUT_AC97_REAR_R)))\r\nfor (z = 0; z < 2; z++)\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_REAR_L + z), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 2 + z), C_00000000, C_00000000);\r\nif (emu->fx8010.extout_mask & (1<<EXTOUT_AC97_CENTER)) {\r\n#ifndef EMU10K1_CENTER_LFE_FROM_FRONT\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_CENTER), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 4), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ACENTER), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 4), C_00000000, C_00000000);\r\n#else\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_CENTER), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 0), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ACENTER), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 0), C_00000000, C_00000000);\r\n#endif\r\n}\r\nif (emu->fx8010.extout_mask & (1<<EXTOUT_AC97_LFE)) {\r\n#ifndef EMU10K1_CENTER_LFE_FROM_FRONT\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_LFE), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 5), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ALFE), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 5), C_00000000, C_00000000);\r\n#else\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_AC97_LFE), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 1), C_00000000, C_00000000);\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ALFE), GPR(playback + SND_EMU10K1_PLAYBACK_CHANNELS + 1), C_00000000, C_00000000);\r\n#endif\r\n}\r\n#ifndef EMU10K1_CAPTURE_DIGITAL_OUT\r\nfor (z = 0; z < 2; z++)\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_ADC_CAP_L + z), GPR(capture + z), C_00000000, C_00000000);\r\n#endif\r\nif (emu->fx8010.extout_mask & (1<<EXTOUT_MIC_CAP))\r\nOP(icode, &ptr, iACC3, EXTOUT(EXTOUT_MIC_CAP), GPR(capture + 2), C_00000000, C_00000000);\r\nif (emu->card_capabilities->sblive51) {\r\nOP(icode, &ptr, iACC3, FXBUS2(14), C_00000000, C_00000000, EXTIN(0));\r\nOP(icode, &ptr, iACC3, FXBUS2(15), C_00000000, C_00000000, EXTIN(1));\r\nOP(icode, &ptr, iACC3, FXBUS2(0), C_00000000, C_00000000, EXTIN(2));\r\nOP(icode, &ptr, iACC3, FXBUS2(3), C_00000000, C_00000000, EXTIN(3));\r\nfor (z = 4; z < 14; z++)\r\nOP(icode, &ptr, iACC3, FXBUS2(z), C_00000000, C_00000000, EXTIN(z));\r\n} else {\r\nfor (z = 0; z < 16; z++)\r\nOP(icode, &ptr, iACC3, FXBUS2(z), C_00000000, C_00000000, EXTIN(z));\r\n}\r\nif (gpr > tmp) {\r\nsnd_BUG();\r\nerr = -EIO;\r\ngoto __err;\r\n}\r\nif (i > SND_EMU10K1_GPR_CONTROLS) {\r\nsnd_BUG();\r\nerr = -EIO;\r\ngoto __err;\r\n}\r\nwhile (ptr < 0x200)\r\nOP(icode, &ptr, iACC3, C_00000000, C_00000000, C_00000000, C_00000000);\r\nif ((err = snd_emu10k1_fx8010_tram_setup(emu, ipcm->buffer_size)) < 0)\r\ngoto __err;\r\nseg = snd_enter_user();\r\nicode->gpr_add_control_count = i;\r\nicode->gpr_add_controls = (struct snd_emu10k1_fx8010_control_gpr __user *)controls;\r\nemu->support_tlv = 1;\r\nerr = snd_emu10k1_icode_poke(emu, icode);\r\nemu->support_tlv = 0;\r\nsnd_leave_user(seg);\r\nif (err >= 0)\r\nerr = snd_emu10k1_ipcm_poke(emu, ipcm);\r\n__err:\r\nkfree(ipcm);\r\nkfree(controls);\r\nif (icode != NULL) {\r\nkfree((void __force *)icode->gpr_map);\r\nkfree(icode);\r\n}\r\nreturn err;\r\n}\r\nint snd_emu10k1_init_efx(struct snd_emu10k1 *emu)\r\n{\r\nspin_lock_init(&emu->fx8010.irq_lock);\r\nINIT_LIST_HEAD(&emu->fx8010.gpr_ctl);\r\nif (emu->audigy)\r\nreturn _snd_emu10k1_audigy_init_efx(emu);\r\nelse\r\nreturn _snd_emu10k1_init_efx(emu);\r\n}\r\nvoid snd_emu10k1_free_efx(struct snd_emu10k1 *emu)\r\n{\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg = A_DBG_SINGLE_STEP);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg = EMU10K1_DBG_SINGLE_STEP);\r\n}\r\nint snd_emu10k1_fx8010_tram_setup(struct snd_emu10k1 *emu, u32 size)\r\n{\r\nu8 size_reg = 0;\r\nif (size != 0) {\r\nsize = (size - 1) >> 13;\r\nwhile (size) {\r\nsize >>= 1;\r\nsize_reg++;\r\n}\r\nsize = 0x2000 << size_reg;\r\n}\r\nif ((emu->fx8010.etram_pages.bytes / 2) == size)\r\nreturn 0;\r\nspin_lock_irq(&emu->emu_lock);\r\noutl(HCFG_LOCKTANKCACHE_MASK | inl(emu->port + HCFG), emu->port + HCFG);\r\nspin_unlock_irq(&emu->emu_lock);\r\nsnd_emu10k1_ptr_write(emu, TCB, 0, 0);\r\nsnd_emu10k1_ptr_write(emu, TCBS, 0, 0);\r\nif (emu->fx8010.etram_pages.area != NULL) {\r\nsnd_dma_free_pages(&emu->fx8010.etram_pages);\r\nemu->fx8010.etram_pages.area = NULL;\r\nemu->fx8010.etram_pages.bytes = 0;\r\n}\r\nif (size > 0) {\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(emu->pci),\r\nsize * 2, &emu->fx8010.etram_pages) < 0)\r\nreturn -ENOMEM;\r\nmemset(emu->fx8010.etram_pages.area, 0, size * 2);\r\nsnd_emu10k1_ptr_write(emu, TCB, 0, emu->fx8010.etram_pages.addr);\r\nsnd_emu10k1_ptr_write(emu, TCBS, 0, size_reg);\r\nspin_lock_irq(&emu->emu_lock);\r\noutl(inl(emu->port + HCFG) & ~HCFG_LOCKTANKCACHE_MASK, emu->port + HCFG);\r\nspin_unlock_irq(&emu->emu_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1_fx8010_open(struct snd_hwdep * hw, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic void copy_string(char *dst, char *src, char *null, int idx)\r\n{\r\nif (src == NULL)\r\nsprintf(dst, "%s %02X", null, idx);\r\nelse\r\nstrcpy(dst, src);\r\n}\r\nstatic void snd_emu10k1_fx8010_info(struct snd_emu10k1 *emu,\r\nstruct snd_emu10k1_fx8010_info *info)\r\n{\r\nchar **fxbus, **extin, **extout;\r\nunsigned short fxbus_mask, extin_mask, extout_mask;\r\nint res;\r\ninfo->internal_tram_size = emu->fx8010.itram_size;\r\ninfo->external_tram_size = emu->fx8010.etram_pages.bytes / 2;\r\nfxbus = fxbuses;\r\nextin = emu->audigy ? audigy_ins : creative_ins;\r\nextout = emu->audigy ? audigy_outs : creative_outs;\r\nfxbus_mask = emu->fx8010.fxbus_mask;\r\nextin_mask = emu->fx8010.extin_mask;\r\nextout_mask = emu->fx8010.extout_mask;\r\nfor (res = 0; res < 16; res++, fxbus++, extin++, extout++) {\r\ncopy_string(info->fxbus_names[res], fxbus_mask & (1 << res) ? *fxbus : NULL, "FXBUS", res);\r\ncopy_string(info->extin_names[res], extin_mask & (1 << res) ? *extin : NULL, "Unused", res);\r\ncopy_string(info->extout_names[res], extout_mask & (1 << res) ? *extout : NULL, "Unused", res);\r\n}\r\nfor (res = 16; res < 32; res++, extout++)\r\ncopy_string(info->extout_names[res], extout_mask & (1 << res) ? *extout : NULL, "Unused", res);\r\ninfo->gpr_controls = emu->fx8010.gpr_count;\r\n}\r\nstatic int snd_emu10k1_fx8010_ioctl(struct snd_hwdep * hw, struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_emu10k1 *emu = hw->private_data;\r\nstruct snd_emu10k1_fx8010_info *info;\r\nstruct snd_emu10k1_fx8010_code *icode;\r\nstruct snd_emu10k1_fx8010_pcm_rec *ipcm;\r\nunsigned int addr;\r\nvoid __user *argp = (void __user *)arg;\r\nint res;\r\nswitch (cmd) {\r\ncase SNDRV_EMU10K1_IOCTL_PVERSION:\r\nemu->support_tlv = 1;\r\nreturn put_user(SNDRV_EMU10K1_VERSION, (int __user *)argp);\r\ncase SNDRV_EMU10K1_IOCTL_INFO:\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nsnd_emu10k1_fx8010_info(emu, info);\r\nif (copy_to_user(argp, info, sizeof(*info))) {\r\nkfree(info);\r\nreturn -EFAULT;\r\n}\r\nkfree(info);\r\nreturn 0;\r\ncase SNDRV_EMU10K1_IOCTL_CODE_POKE:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nicode = memdup_user(argp, sizeof(*icode));\r\nif (IS_ERR(icode))\r\nreturn PTR_ERR(icode);\r\nres = snd_emu10k1_icode_poke(emu, icode);\r\nkfree(icode);\r\nreturn res;\r\ncase SNDRV_EMU10K1_IOCTL_CODE_PEEK:\r\nicode = memdup_user(argp, sizeof(*icode));\r\nif (IS_ERR(icode))\r\nreturn PTR_ERR(icode);\r\nres = snd_emu10k1_icode_peek(emu, icode);\r\nif (res == 0 && copy_to_user(argp, icode, sizeof(*icode))) {\r\nkfree(icode);\r\nreturn -EFAULT;\r\n}\r\nkfree(icode);\r\nreturn res;\r\ncase SNDRV_EMU10K1_IOCTL_PCM_POKE:\r\nipcm = memdup_user(argp, sizeof(*ipcm));\r\nif (IS_ERR(ipcm))\r\nreturn PTR_ERR(ipcm);\r\nres = snd_emu10k1_ipcm_poke(emu, ipcm);\r\nkfree(ipcm);\r\nreturn res;\r\ncase SNDRV_EMU10K1_IOCTL_PCM_PEEK:\r\nipcm = memdup_user(argp, sizeof(*ipcm));\r\nif (IS_ERR(ipcm))\r\nreturn PTR_ERR(ipcm);\r\nres = snd_emu10k1_ipcm_peek(emu, ipcm);\r\nif (res == 0 && copy_to_user(argp, ipcm, sizeof(*ipcm))) {\r\nkfree(ipcm);\r\nreturn -EFAULT;\r\n}\r\nkfree(ipcm);\r\nreturn res;\r\ncase SNDRV_EMU10K1_IOCTL_TRAM_SETUP:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (get_user(addr, (unsigned int __user *)argp))\r\nreturn -EFAULT;\r\nmutex_lock(&emu->fx8010.lock);\r\nres = snd_emu10k1_fx8010_tram_setup(emu, addr);\r\nmutex_unlock(&emu->fx8010.lock);\r\nreturn res;\r\ncase SNDRV_EMU10K1_IOCTL_STOP:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg |= A_DBG_SINGLE_STEP);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg |= EMU10K1_DBG_SINGLE_STEP);\r\nreturn 0;\r\ncase SNDRV_EMU10K1_IOCTL_CONTINUE:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg = 0);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg = 0);\r\nreturn 0;\r\ncase SNDRV_EMU10K1_IOCTL_ZERO_TRAM_COUNTER:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg | A_DBG_ZC);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg | EMU10K1_DBG_ZC);\r\nudelay(10);\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg);\r\nreturn 0;\r\ncase SNDRV_EMU10K1_IOCTL_SINGLE_STEP:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (get_user(addr, (unsigned int __user *)argp))\r\nreturn -EFAULT;\r\nif (addr > 0x1ff)\r\nreturn -EINVAL;\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg |= A_DBG_SINGLE_STEP | addr);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg |= EMU10K1_DBG_SINGLE_STEP | addr);\r\nudelay(10);\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg |= A_DBG_SINGLE_STEP | A_DBG_STEP_ADDR | addr);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg |= EMU10K1_DBG_SINGLE_STEP | EMU10K1_DBG_STEP | addr);\r\nreturn 0;\r\ncase SNDRV_EMU10K1_IOCTL_DBG_READ:\r\nif (emu->audigy)\r\naddr = snd_emu10k1_ptr_read(emu, A_DBG, 0);\r\nelse\r\naddr = snd_emu10k1_ptr_read(emu, DBG, 0);\r\nif (put_user(addr, (unsigned int __user *)argp))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int snd_emu10k1_fx8010_release(struct snd_hwdep * hw, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nint snd_emu10k1_fx8010_new(struct snd_emu10k1 *emu, int device,\r\nstruct snd_hwdep **rhwdep)\r\n{\r\nstruct snd_hwdep *hw;\r\nint err;\r\nif (rhwdep)\r\n*rhwdep = NULL;\r\nif ((err = snd_hwdep_new(emu->card, "FX8010", device, &hw)) < 0)\r\nreturn err;\r\nstrcpy(hw->name, "EMU10K1 (FX8010)");\r\nhw->iface = SNDRV_HWDEP_IFACE_EMU10K1;\r\nhw->ops.open = snd_emu10k1_fx8010_open;\r\nhw->ops.ioctl = snd_emu10k1_fx8010_ioctl;\r\nhw->ops.release = snd_emu10k1_fx8010_release;\r\nhw->private_data = emu;\r\nif (rhwdep)\r\n*rhwdep = hw;\r\nreturn 0;\r\n}\r\nint snd_emu10k1_efx_alloc_pm_buffer(struct snd_emu10k1 *emu)\r\n{\r\nint len;\r\nlen = emu->audigy ? 0x200 : 0x100;\r\nemu->saved_gpr = kmalloc(len * 4, GFP_KERNEL);\r\nif (! emu->saved_gpr)\r\nreturn -ENOMEM;\r\nlen = emu->audigy ? 0x100 : 0xa0;\r\nemu->tram_val_saved = kmalloc(len * 4, GFP_KERNEL);\r\nemu->tram_addr_saved = kmalloc(len * 4, GFP_KERNEL);\r\nif (! emu->tram_val_saved || ! emu->tram_addr_saved)\r\nreturn -ENOMEM;\r\nlen = emu->audigy ? 2 * 1024 : 2 * 512;\r\nemu->saved_icode = vmalloc(len * 4);\r\nif (! emu->saved_icode)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid snd_emu10k1_efx_free_pm_buffer(struct snd_emu10k1 *emu)\r\n{\r\nkfree(emu->saved_gpr);\r\nkfree(emu->tram_val_saved);\r\nkfree(emu->tram_addr_saved);\r\nvfree(emu->saved_icode);\r\n}\r\nvoid snd_emu10k1_efx_suspend(struct snd_emu10k1 *emu)\r\n{\r\nint i, len;\r\nlen = emu->audigy ? 0x200 : 0x100;\r\nfor (i = 0; i < len; i++)\r\nemu->saved_gpr[i] = snd_emu10k1_ptr_read(emu, emu->gpr_base + i, 0);\r\nlen = emu->audigy ? 0x100 : 0xa0;\r\nfor (i = 0; i < len; i++) {\r\nemu->tram_val_saved[i] = snd_emu10k1_ptr_read(emu, TANKMEMDATAREGBASE + i, 0);\r\nemu->tram_addr_saved[i] = snd_emu10k1_ptr_read(emu, TANKMEMADDRREGBASE + i, 0);\r\nif (emu->audigy) {\r\nemu->tram_addr_saved[i] >>= 12;\r\nemu->tram_addr_saved[i] |=\r\nsnd_emu10k1_ptr_read(emu, A_TANKMEMCTLREGBASE + i, 0) << 20;\r\n}\r\n}\r\nlen = emu->audigy ? 2 * 1024 : 2 * 512;\r\nfor (i = 0; i < len; i++)\r\nemu->saved_icode[i] = snd_emu10k1_efx_read(emu, i);\r\n}\r\nvoid snd_emu10k1_efx_resume(struct snd_emu10k1 *emu)\r\n{\r\nint i, len;\r\nif (emu->fx8010.etram_pages.bytes > 0) {\r\nunsigned size, size_reg = 0;\r\nsize = emu->fx8010.etram_pages.bytes / 2;\r\nsize = (size - 1) >> 13;\r\nwhile (size) {\r\nsize >>= 1;\r\nsize_reg++;\r\n}\r\noutl(HCFG_LOCKTANKCACHE_MASK | inl(emu->port + HCFG), emu->port + HCFG);\r\nsnd_emu10k1_ptr_write(emu, TCB, 0, emu->fx8010.etram_pages.addr);\r\nsnd_emu10k1_ptr_write(emu, TCBS, 0, size_reg);\r\noutl(inl(emu->port + HCFG) & ~HCFG_LOCKTANKCACHE_MASK, emu->port + HCFG);\r\n}\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg | A_DBG_SINGLE_STEP);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg | EMU10K1_DBG_SINGLE_STEP);\r\nlen = emu->audigy ? 0x200 : 0x100;\r\nfor (i = 0; i < len; i++)\r\nsnd_emu10k1_ptr_write(emu, emu->gpr_base + i, 0, emu->saved_gpr[i]);\r\nlen = emu->audigy ? 0x100 : 0xa0;\r\nfor (i = 0; i < len; i++) {\r\nsnd_emu10k1_ptr_write(emu, TANKMEMDATAREGBASE + i, 0,\r\nemu->tram_val_saved[i]);\r\nif (! emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + i, 0,\r\nemu->tram_addr_saved[i]);\r\nelse {\r\nsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + i, 0,\r\nemu->tram_addr_saved[i] << 12);\r\nsnd_emu10k1_ptr_write(emu, TANKMEMADDRREGBASE + i, 0,\r\nemu->tram_addr_saved[i] >> 20);\r\n}\r\n}\r\nlen = emu->audigy ? 2 * 1024 : 2 * 512;\r\nfor (i = 0; i < len; i++)\r\nsnd_emu10k1_efx_write(emu, i, emu->saved_icode[i]);\r\nif (emu->audigy)\r\nsnd_emu10k1_ptr_write(emu, A_DBG, 0, emu->fx8010.dbg);\r\nelse\r\nsnd_emu10k1_ptr_write(emu, DBG, 0, emu->fx8010.dbg);\r\n}
