static int\r\nisl_upload_firmware(islpci_private *priv)\r\n{\r\nu32 reg, rc;\r\nvoid __iomem *device_base = priv->device_base;\r\nreg = readl(device_base + ISL38XX_CTRL_STAT_REG);\r\nreg &= ~ISL38XX_CTRL_STAT_RESET;\r\nreg &= ~ISL38XX_CTRL_STAT_RAMBOOT;\r\nwritel(reg, device_base + ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nreg |= ISL38XX_CTRL_STAT_RESET;\r\nwritel(reg, device_base + ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nreg &= ~ISL38XX_CTRL_STAT_RESET;\r\nwritel(reg, device_base + ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nmdelay(50);\r\n{\r\nconst struct firmware *fw_entry = NULL;\r\nlong fw_len;\r\nconst u32 *fw_ptr;\r\nrc = request_firmware(&fw_entry, priv->firmware, PRISM_FW_PDEV);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: request_firmware() failed for '%s'\n",\r\n"prism54", priv->firmware);\r\nreturn rc;\r\n}\r\nreg = ISL38XX_DEV_FIRMWARE_ADDRES;\r\nfw_ptr = (u32 *) fw_entry->data;\r\nfw_len = fw_entry->size;\r\nif (fw_len % 4) {\r\nprintk(KERN_ERR\r\n"%s: firmware '%s' size is not multiple of 32bit, aborting!\n",\r\n"prism54", priv->firmware);\r\nrelease_firmware(fw_entry);\r\nreturn -EILSEQ; ;\r\n}\r\nwhile (fw_len > 0) {\r\nlong _fw_len =\r\n(fw_len >\r\nISL38XX_MEMORY_WINDOW_SIZE) ?\r\nISL38XX_MEMORY_WINDOW_SIZE : fw_len;\r\nu32 __iomem *dev_fw_ptr = device_base + ISL38XX_DIRECT_MEM_WIN;\r\nisl38xx_w32_flush(device_base, reg,\r\nISL38XX_DIR_MEM_BASE_REG);\r\nwmb();\r\nreg += _fw_len;\r\nfw_len -= _fw_len;\r\nwhile (_fw_len > 0) {\r\n__raw_writel(*fw_ptr, dev_fw_ptr);\r\nfw_ptr++, dev_fw_ptr++;\r\n_fw_len -= 4;\r\n}\r\n(void) readl(device_base + ISL38XX_PCI_POSTING_FLUSH);\r\nwmb();\r\nBUG_ON(_fw_len != 0);\r\n}\r\nBUG_ON(fw_len != 0);\r\nprintk(KERN_DEBUG "%s: firmware version: %.8s\n",\r\npriv->ndev->name, fw_entry->data + 40);\r\nrelease_firmware(fw_entry);\r\n}\r\nreg = readl(device_base + ISL38XX_CTRL_STAT_REG);\r\nreg &= ~ISL38XX_CTRL_STAT_CLKRUN;\r\nreg &= ~ISL38XX_CTRL_STAT_RESET;\r\nreg |= ISL38XX_CTRL_STAT_RAMBOOT;\r\nisl38xx_w32_flush(device_base, reg, ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nreg |= ISL38XX_CTRL_STAT_RESET;\r\nwritel(reg, device_base + ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nreg &= ~ISL38XX_CTRL_STAT_RESET;\r\nwritel(reg, device_base + ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nreturn 0;\r\n}\r\nirqreturn_t\r\nislpci_interrupt(int irq, void *config)\r\n{\r\nu32 reg;\r\nislpci_private *priv = config;\r\nstruct net_device *ndev = priv->ndev;\r\nvoid __iomem *device = priv->device_base;\r\nint powerstate = ISL38XX_PSM_POWERSAVE_STATE;\r\nspin_lock(&priv->slock);\r\nreg = readl(device + ISL38XX_CTRL_STAT_REG);\r\nif (reg & ISL38XX_CTRL_STAT_SLEEPMODE)\r\n{\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "Assuming someone else called the IRQ\n");\r\n#endif\r\nspin_unlock(&priv->slock);\r\nreturn IRQ_NONE;\r\n}\r\nreg = readl(device + ISL38XX_INT_IDENT_REG);\r\nreg &= readl(device + ISL38XX_INT_EN_REG);\r\nreg &= ISL38XX_INT_SOURCES;\r\nif (reg != 0) {\r\nif (islpci_get_state(priv) != PRV_STATE_SLEEP)\r\npowerstate = ISL38XX_PSM_ACTIVE_STATE;\r\nisl38xx_w32_flush(device, reg, ISL38XX_INT_ACK_REG);\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_FUNCTION_CALLS,\r\n"IRQ: Identification register 0x%p 0x%x\n", device, reg);\r\n#endif\r\nif (reg & ISL38XX_INT_IDENT_UPDATE) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "IRQ: Update flag\n");\r\nDEBUG(SHOW_QUEUE_INDEXES,\r\n"CB drv Qs: [%i][%i][%i][%i][%i][%i]\n",\r\nle32_to_cpu(priv->control_block->\r\ndriver_curr_frag[0]),\r\nle32_to_cpu(priv->control_block->\r\ndriver_curr_frag[1]),\r\nle32_to_cpu(priv->control_block->\r\ndriver_curr_frag[2]),\r\nle32_to_cpu(priv->control_block->\r\ndriver_curr_frag[3]),\r\nle32_to_cpu(priv->control_block->\r\ndriver_curr_frag[4]),\r\nle32_to_cpu(priv->control_block->\r\ndriver_curr_frag[5])\r\n);\r\nDEBUG(SHOW_QUEUE_INDEXES,\r\n"CB dev Qs: [%i][%i][%i][%i][%i][%i]\n",\r\nle32_to_cpu(priv->control_block->\r\ndevice_curr_frag[0]),\r\nle32_to_cpu(priv->control_block->\r\ndevice_curr_frag[1]),\r\nle32_to_cpu(priv->control_block->\r\ndevice_curr_frag[2]),\r\nle32_to_cpu(priv->control_block->\r\ndevice_curr_frag[3]),\r\nle32_to_cpu(priv->control_block->\r\ndevice_curr_frag[4]),\r\nle32_to_cpu(priv->control_block->\r\ndevice_curr_frag[5])\r\n);\r\n#endif\r\nislpci_eth_cleanup_transmit(priv, priv->control_block);\r\npowerstate = ISL38XX_PSM_ACTIVE_STATE;\r\nif (isl38xx_in_queue(priv->control_block,\r\nISL38XX_CB_RX_MGMTQ) != 0) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING,\r\n"Received frame in Management Queue\n");\r\n#endif\r\nislpci_mgt_receive(ndev);\r\nislpci_mgt_cleanup_transmit(ndev);\r\nislpci_mgmt_rx_fill(ndev);\r\n}\r\nwhile (isl38xx_in_queue(priv->control_block,\r\nISL38XX_CB_RX_DATA_LQ) != 0) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING,\r\n"Received frame in Data Low Queue\n");\r\n#endif\r\nislpci_eth_receive(priv);\r\n}\r\nif (priv->data_low_tx_full) {\r\nif (ISL38XX_CB_TX_QSIZE -\r\nisl38xx_in_queue(priv->control_block,\r\nISL38XX_CB_TX_DATA_LQ) >=\r\nISL38XX_MIN_QTHRESHOLD) {\r\nnetif_wake_queue(priv->ndev);\r\npriv->data_low_tx_full = 0;\r\n}\r\n}\r\n}\r\nif (reg & ISL38XX_INT_IDENT_INIT) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING,\r\n"IRQ: Init flag, device initialized\n");\r\n#endif\r\nwake_up(&priv->reset_done);\r\n}\r\nif (reg & ISL38XX_INT_IDENT_SLEEP) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "IRQ: Sleep flag\n");\r\n#endif\r\nisl38xx_handle_sleep_request(priv->control_block,\r\n&powerstate,\r\npriv->device_base);\r\n}\r\nif (reg & ISL38XX_INT_IDENT_WAKEUP) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "IRQ: Wakeup flag\n");\r\n#endif\r\nisl38xx_handle_wakeup(priv->control_block,\r\n&powerstate, priv->device_base);\r\n}\r\n} else {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "Assuming someone else called the IRQ\n");\r\n#endif\r\nspin_unlock(&priv->slock);\r\nreturn IRQ_NONE;\r\n}\r\nif (islpci_get_state(priv) == PRV_STATE_SLEEP\r\n&& powerstate == ISL38XX_PSM_ACTIVE_STATE)\r\nislpci_set_state(priv, PRV_STATE_READY);\r\nif (islpci_get_state(priv) != PRV_STATE_SLEEP\r\n&& powerstate == ISL38XX_PSM_POWERSAVE_STATE)\r\nislpci_set_state(priv, PRV_STATE_SLEEP);\r\nspin_unlock(&priv->slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nislpci_open(struct net_device *ndev)\r\n{\r\nu32 rc;\r\nislpci_private *priv = netdev_priv(ndev);\r\nrc = islpci_reset(priv,1);\r\nif (rc) {\r\nprism54_bring_down(priv);\r\nreturn rc;\r\n}\r\nnetif_start_queue(ndev);\r\nif (priv->iw_mode == IW_MODE_INFRA || priv->iw_mode == IW_MODE_ADHOC)\r\nnetif_carrier_off(ndev);\r\nelse\r\nnetif_carrier_on(ndev);\r\nreturn 0;\r\n}\r\nstatic int\r\nislpci_close(struct net_device *ndev)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nprintk(KERN_DEBUG "%s: islpci_close ()\n", ndev->name);\r\nnetif_stop_queue(ndev);\r\nreturn prism54_bring_down(priv);\r\n}\r\nstatic int\r\nprism54_bring_down(islpci_private *priv)\r\n{\r\nvoid __iomem *device_base = priv->device_base;\r\nu32 reg;\r\nislpci_set_state(priv, PRV_STATE_PREBOOT);\r\nisl38xx_disable_interrupts(priv->device_base);\r\nsynchronize_irq(priv->pdev->irq);\r\nreg = readl(device_base + ISL38XX_CTRL_STAT_REG);\r\nreg &= ~(ISL38XX_CTRL_STAT_RESET | ISL38XX_CTRL_STAT_RAMBOOT);\r\nwritel(reg, device_base + ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nreg |= ISL38XX_CTRL_STAT_RESET;\r\nwritel(reg, device_base + ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nudelay(ISL38XX_WRITEIO_DELAY);\r\nreg &= ~ISL38XX_CTRL_STAT_RESET;\r\nwritel(reg, device_base + ISL38XX_CTRL_STAT_REG);\r\nwmb();\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(50));\r\nreturn 0;\r\n}\r\nstatic int\r\nislpci_upload_fw(islpci_private *priv)\r\n{\r\nislpci_state_t old_state;\r\nu32 rc;\r\nold_state = islpci_set_state(priv, PRV_STATE_BOOT);\r\nprintk(KERN_DEBUG "%s: uploading firmware...\n", priv->ndev->name);\r\nrc = isl_upload_firmware(priv);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: could not upload firmware ('%s')\n",\r\npriv->ndev->name, priv->firmware);\r\nislpci_set_state(priv, old_state);\r\nreturn rc;\r\n}\r\nprintk(KERN_DEBUG "%s: firmware upload complete\n",\r\npriv->ndev->name);\r\nislpci_set_state(priv, PRV_STATE_POSTBOOT);\r\nreturn 0;\r\n}\r\nstatic int\r\nislpci_reset_if(islpci_private *priv)\r\n{\r\nlong remaining;\r\nint result = -ETIME;\r\nint count;\r\nDEFINE_WAIT(wait);\r\nprepare_to_wait(&priv->reset_done, &wait, TASK_UNINTERRUPTIBLE);\r\nisl38xx_interface_reset(priv->device_base, priv->device_host_address);\r\nislpci_set_state(priv, PRV_STATE_PREINIT);\r\nfor(count = 0; count < 2 && result; count++) {\r\nremaining = schedule_timeout_uninterruptible(HZ);\r\nif(remaining > 0) {\r\nresult = 0;\r\nbreak;\r\n}\r\nprintk(KERN_ERR "%s: no 'reset complete' IRQ seen - retrying\n",\r\npriv->ndev->name);\r\n}\r\nfinish_wait(&priv->reset_done, &wait);\r\nif (result) {\r\nprintk(KERN_ERR "%s: interface reset failure\n", priv->ndev->name);\r\nreturn result;\r\n}\r\nislpci_set_state(priv, PRV_STATE_INIT);\r\nisl38xx_enable_common_interrupts(priv->device_base);\r\ndown_write(&priv->mib_sem);\r\nresult = mgt_commit(priv);\r\nif (result) {\r\nprintk(KERN_ERR "%s: interface reset failure\n", priv->ndev->name);\r\nup_write(&priv->mib_sem);\r\nreturn result;\r\n}\r\nup_write(&priv->mib_sem);\r\nislpci_set_state(priv, PRV_STATE_READY);\r\nprintk(KERN_DEBUG "%s: interface reset complete\n", priv->ndev->name);\r\nreturn 0;\r\n}\r\nint\r\nislpci_reset(islpci_private *priv, int reload_firmware)\r\n{\r\nisl38xx_control_block *cb =\r\n(isl38xx_control_block *) priv->control_block;\r\nunsigned counter;\r\nint rc;\r\nif (reload_firmware)\r\nislpci_set_state(priv, PRV_STATE_PREBOOT);\r\nelse\r\nislpci_set_state(priv, PRV_STATE_POSTBOOT);\r\nprintk(KERN_DEBUG "%s: resetting device...\n", priv->ndev->name);\r\nisl38xx_disable_interrupts(priv->device_base);\r\npriv->index_mgmt_tx = 0;\r\npriv->index_mgmt_rx = 0;\r\nfor (counter = 0; counter < ISL38XX_CB_QCOUNT; counter++) {\r\ncb->driver_curr_frag[counter] = cpu_to_le32(0);\r\ncb->device_curr_frag[counter] = cpu_to_le32(0);\r\n}\r\nfor (counter = 0; counter < ISL38XX_CB_MGMT_QSIZE; counter++) {\r\nisl38xx_fragment *frag = &cb->rx_data_mgmt[counter];\r\nfrag->size = cpu_to_le16(MGMT_FRAME_SIZE);\r\nfrag->flags = 0;\r\nfrag->address = cpu_to_le32(priv->mgmt_rx[counter].pci_addr);\r\n}\r\nfor (counter = 0; counter < ISL38XX_CB_RX_QSIZE; counter++) {\r\ncb->rx_data_low[counter].address =\r\ncpu_to_le32((u32) priv->pci_map_rx_address[counter]);\r\n}\r\npriv->control_block->driver_curr_frag[ISL38XX_CB_RX_DATA_LQ] =\r\ncpu_to_le32(ISL38XX_CB_RX_QSIZE);\r\npriv->control_block->driver_curr_frag[ISL38XX_CB_RX_MGMTQ] =\r\ncpu_to_le32(ISL38XX_CB_MGMT_QSIZE);\r\npriv->free_data_rx = 0;\r\npriv->free_data_tx = 0;\r\npriv->data_low_tx_full = 0;\r\nif (reload_firmware) {\r\nrc = islpci_upload_fw(priv);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: islpci_reset: failure\n",\r\npriv->ndev->name);\r\nreturn rc;\r\n}\r\n}\r\nrc = islpci_reset_if(priv);\r\nif (rc)\r\nprintk(KERN_ERR "prism54: Your card/socket may be faulty, or IRQ line too busy :(\n");\r\nreturn rc;\r\n}\r\nstatic int\r\nislpci_alloc_memory(islpci_private *priv)\r\n{\r\nint counter;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nprintk(KERN_DEBUG "islpci_alloc_memory\n");\r\n#endif\r\nif (!(priv->device_base =\r\nioremap(pci_resource_start(priv->pdev, 0),\r\nISL38XX_PCI_MEM_SIZE))) {\r\nprintk(KERN_ERR "PCI memory remapping failed\n");\r\nreturn -1;\r\n}\r\npriv->driver_mem_address = pci_alloc_consistent(priv->pdev,\r\nHOST_MEM_BLOCK,\r\n&priv->\r\ndevice_host_address);\r\nif (!priv->driver_mem_address) {\r\nprintk(KERN_ERR "%s: could not allocate DMA memory, aborting!",\r\n"prism54");\r\nreturn -1;\r\n}\r\npriv->control_block =\r\n(isl38xx_control_block *) priv->driver_mem_address;\r\npriv->device_psm_buffer =\r\npriv->device_host_address + CONTROL_BLOCK_SIZE;\r\nfor (counter = 0; counter < ISL38XX_CB_QCOUNT; counter++) {\r\npriv->control_block->driver_curr_frag[counter] = cpu_to_le32(0);\r\npriv->control_block->device_curr_frag[counter] = cpu_to_le32(0);\r\n}\r\npriv->index_mgmt_rx = 0;\r\nmemset(priv->mgmt_rx, 0, sizeof(priv->mgmt_rx));\r\nmemset(priv->mgmt_tx, 0, sizeof(priv->mgmt_tx));\r\nif (islpci_mgmt_rx_fill(priv->ndev) < 0)\r\ngoto out_free;\r\nmemset(priv->data_low_rx, 0, sizeof (priv->data_low_rx));\r\nmemset(priv->pci_map_rx_address, 0, sizeof (priv->pci_map_rx_address));\r\nfor (counter = 0; counter < ISL38XX_CB_RX_QSIZE; counter++) {\r\nstruct sk_buff *skb;\r\nif (!(skb = dev_alloc_skb(MAX_FRAGMENT_SIZE_RX + 2))) {\r\nprintk(KERN_ERR "Error allocating skb.\n");\r\nskb = NULL;\r\ngoto out_free;\r\n}\r\nskb_reserve(skb, (4 - (long) skb->data) & 0x03);\r\npriv->data_low_rx[counter] = skb;\r\npriv->pci_map_rx_address[counter] =\r\npci_map_single(priv->pdev, (void *) skb->data,\r\nMAX_FRAGMENT_SIZE_RX + 2,\r\nPCI_DMA_FROMDEVICE);\r\nif (!priv->pci_map_rx_address[counter]) {\r\nprintk(KERN_ERR "failed to map skb DMA'able\n");\r\ngoto out_free;\r\n}\r\n}\r\nprism54_acl_init(&priv->acl);\r\nprism54_wpa_bss_ie_init(priv);\r\nif (mgt_init(priv))\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nislpci_free_memory(priv);\r\nreturn -1;\r\n}\r\nint\r\nislpci_free_memory(islpci_private *priv)\r\n{\r\nint counter;\r\nif (priv->device_base)\r\niounmap(priv->device_base);\r\npriv->device_base = NULL;\r\nif (priv->driver_mem_address)\r\npci_free_consistent(priv->pdev, HOST_MEM_BLOCK,\r\npriv->driver_mem_address,\r\npriv->device_host_address);\r\npriv->driver_mem_address = NULL;\r\npriv->device_host_address = 0;\r\npriv->device_psm_buffer = 0;\r\npriv->control_block = NULL;\r\nfor (counter = 0; counter < ISL38XX_CB_MGMT_QSIZE; counter++) {\r\nstruct islpci_membuf *buf = &priv->mgmt_rx[counter];\r\nif (buf->pci_addr)\r\npci_unmap_single(priv->pdev, buf->pci_addr,\r\nbuf->size, PCI_DMA_FROMDEVICE);\r\nbuf->pci_addr = 0;\r\nkfree(buf->mem);\r\nbuf->size = 0;\r\nbuf->mem = NULL;\r\n}\r\nfor (counter = 0; counter < ISL38XX_CB_RX_QSIZE; counter++) {\r\nif (priv->pci_map_rx_address[counter])\r\npci_unmap_single(priv->pdev,\r\npriv->pci_map_rx_address[counter],\r\nMAX_FRAGMENT_SIZE_RX + 2,\r\nPCI_DMA_FROMDEVICE);\r\npriv->pci_map_rx_address[counter] = 0;\r\nif (priv->data_low_rx[counter])\r\ndev_kfree_skb(priv->data_low_rx[counter]);\r\npriv->data_low_rx[counter] = NULL;\r\n}\r\nprism54_acl_clean(&priv->acl);\r\nprism54_wpa_bss_ie_clean(priv);\r\nmgt_clean(priv);\r\nreturn 0;\r\n}\r\nstatic void islpci_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\n}\r\nstruct net_device *\r\nislpci_setup(struct pci_dev *pdev)\r\n{\r\nislpci_private *priv;\r\nstruct net_device *ndev = alloc_etherdev(sizeof (islpci_private));\r\nif (!ndev)\r\nreturn ndev;\r\npci_set_drvdata(pdev, ndev);\r\n#if defined(SET_NETDEV_DEV)\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\n#endif\r\nndev->base_addr = pci_resource_start(pdev, 0);\r\nndev->irq = pdev->irq;\r\nndev->netdev_ops = &islpci_netdev_ops;\r\nndev->wireless_handlers = &prism54_handler_def;\r\nndev->ethtool_ops = &islpci_ethtool_ops;\r\nndev->addr_len = ETH_ALEN;\r\nmemcpy(ndev->dev_addr, dummy_mac, 6);\r\nndev->watchdog_timeo = ISLPCI_TX_TIMEOUT;\r\npriv = netdev_priv(ndev);\r\npriv->ndev = ndev;\r\npriv->pdev = pdev;\r\npriv->monitor_type = ARPHRD_IEEE80211;\r\npriv->ndev->type = (priv->iw_mode == IW_MODE_MONITOR) ?\r\npriv->monitor_type : ARPHRD_ETHER;\r\npriv->wireless_data.spy_data = &priv->spy_data;\r\nndev->wireless_data = &priv->wireless_data;\r\nndev->mem_start = (unsigned long) priv->device_base;\r\nndev->mem_end = ndev->mem_start + ISL38XX_PCI_MEM_SIZE;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "PCI Memory remapped to 0x%p\n", priv->device_base);\r\n#endif\r\ninit_waitqueue_head(&priv->reset_done);\r\nmutex_init(&priv->mgmt_lock);\r\npriv->mgmt_received = NULL;\r\ninit_waitqueue_head(&priv->mgmt_wqueue);\r\nmutex_init(&priv->stats_lock);\r\nspin_lock_init(&priv->slock);\r\npriv->state = PRV_STATE_OFF;\r\npriv->state_off = 1;\r\nINIT_WORK(&priv->stats_work, prism54_update_stats);\r\npriv->stats_timestamp = 0;\r\nINIT_WORK(&priv->reset_task, islpci_do_reset_and_wake);\r\npriv->reset_task_pending = 0;\r\nif (islpci_alloc_memory(priv))\r\ngoto do_free_netdev;\r\nswitch (pdev->device) {\r\ncase 0x3877:\r\nstrcpy(priv->firmware, ISL3877_IMAGE_FILE);\r\nbreak;\r\ncase 0x3886:\r\nstrcpy(priv->firmware, ISL3886_IMAGE_FILE);\r\nbreak;\r\ndefault:\r\nstrcpy(priv->firmware, ISL3890_IMAGE_FILE);\r\nbreak;\r\n}\r\nif (register_netdev(ndev)) {\r\nDEBUG(SHOW_ERROR_MESSAGES,\r\n"ERROR: register_netdev() failed\n");\r\ngoto do_islpci_free_memory;\r\n}\r\nreturn ndev;\r\ndo_islpci_free_memory:\r\nislpci_free_memory(priv);\r\ndo_free_netdev:\r\npci_set_drvdata(pdev, NULL);\r\nfree_netdev(ndev);\r\npriv = NULL;\r\nreturn NULL;\r\n}\r\nislpci_state_t\r\nislpci_set_state(islpci_private *priv, islpci_state_t new_state)\r\n{\r\nislpci_state_t old_state;\r\nold_state = priv->state;\r\nswitch (new_state) {\r\ncase PRV_STATE_OFF:\r\npriv->state_off++;\r\ndefault:\r\npriv->state = new_state;\r\nbreak;\r\ncase PRV_STATE_PREBOOT:\r\nif (old_state == PRV_STATE_OFF)\r\npriv->state_off--;\r\nif (!priv->state_off)\r\npriv->state = new_state;\r\nbreak;\r\n}\r\n#if 0\r\nprintk(KERN_DEBUG "%s: state transition %d -> %d (off#%d)\n",\r\npriv->ndev->name, old_state, new_state, priv->state_off);\r\n#endif\r\nBUG_ON(priv->state_off < 0);\r\nBUG_ON(priv->state_off && (priv->state != PRV_STATE_OFF));\r\nBUG_ON(!priv->state_off && (priv->state == PRV_STATE_OFF));\r\nreturn old_state;\r\n}
