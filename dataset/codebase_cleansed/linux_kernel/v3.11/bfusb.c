static struct urb *bfusb_get_completed(struct bfusb_data *data)\r\n{\r\nstruct sk_buff *skb;\r\nstruct urb *urb = NULL;\r\nBT_DBG("bfusb %p", data);\r\nskb = skb_dequeue(&data->completed_q);\r\nif (skb) {\r\nurb = ((struct bfusb_data_scb *) skb->cb)->urb;\r\nkfree_skb(skb);\r\n}\r\nreturn urb;\r\n}\r\nstatic void bfusb_unlink_urbs(struct bfusb_data *data)\r\n{\r\nstruct sk_buff *skb;\r\nstruct urb *urb;\r\nBT_DBG("bfusb %p", data);\r\nwhile ((skb = skb_dequeue(&data->pending_q))) {\r\nurb = ((struct bfusb_data_scb *) skb->cb)->urb;\r\nusb_kill_urb(urb);\r\nskb_queue_tail(&data->completed_q, skb);\r\n}\r\nwhile ((urb = bfusb_get_completed(data)))\r\nusb_free_urb(urb);\r\n}\r\nstatic int bfusb_send_bulk(struct bfusb_data *data, struct sk_buff *skb)\r\n{\r\nstruct bfusb_data_scb *scb = (void *) skb->cb;\r\nstruct urb *urb = bfusb_get_completed(data);\r\nint err, pipe;\r\nBT_DBG("bfusb %p skb %p len %d", data, skb, skb->len);\r\nif (!urb && !(urb = usb_alloc_urb(0, GFP_ATOMIC)))\r\nreturn -ENOMEM;\r\npipe = usb_sndbulkpipe(data->udev, data->bulk_out_ep);\r\nusb_fill_bulk_urb(urb, data->udev, pipe, skb->data, skb->len,\r\nbfusb_tx_complete, skb);\r\nscb->urb = urb;\r\nskb_queue_tail(&data->pending_q, skb);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\nBT_ERR("%s bulk tx submit failed urb %p err %d",\r\ndata->hdev->name, urb, err);\r\nskb_unlink(skb, &data->pending_q);\r\nusb_free_urb(urb);\r\n} else\r\natomic_inc(&data->pending_tx);\r\nreturn err;\r\n}\r\nstatic void bfusb_tx_wakeup(struct bfusb_data *data)\r\n{\r\nstruct sk_buff *skb;\r\nBT_DBG("bfusb %p", data);\r\nif (test_and_set_bit(BFUSB_TX_PROCESS, &data->state)) {\r\nset_bit(BFUSB_TX_WAKEUP, &data->state);\r\nreturn;\r\n}\r\ndo {\r\nclear_bit(BFUSB_TX_WAKEUP, &data->state);\r\nwhile ((atomic_read(&data->pending_tx) < BFUSB_MAX_BULK_TX) &&\r\n(skb = skb_dequeue(&data->transmit_q))) {\r\nif (bfusb_send_bulk(data, skb) < 0) {\r\nskb_queue_head(&data->transmit_q, skb);\r\nbreak;\r\n}\r\n}\r\n} while (test_bit(BFUSB_TX_WAKEUP, &data->state));\r\nclear_bit(BFUSB_TX_PROCESS, &data->state);\r\n}\r\nstatic void bfusb_tx_complete(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct bfusb_data *data = (struct bfusb_data *) skb->dev;\r\nBT_DBG("bfusb %p urb %p skb %p len %d", data, urb, skb, skb->len);\r\natomic_dec(&data->pending_tx);\r\nif (!test_bit(HCI_RUNNING, &data->hdev->flags))\r\nreturn;\r\nif (!urb->status)\r\ndata->hdev->stat.byte_tx += skb->len;\r\nelse\r\ndata->hdev->stat.err_tx++;\r\nread_lock(&data->lock);\r\nskb_unlink(skb, &data->pending_q);\r\nskb_queue_tail(&data->completed_q, skb);\r\nbfusb_tx_wakeup(data);\r\nread_unlock(&data->lock);\r\n}\r\nstatic int bfusb_rx_submit(struct bfusb_data *data, struct urb *urb)\r\n{\r\nstruct bfusb_data_scb *scb;\r\nstruct sk_buff *skb;\r\nint err, pipe, size = HCI_MAX_FRAME_SIZE + 32;\r\nBT_DBG("bfusb %p urb %p", data, urb);\r\nif (!urb && !(urb = usb_alloc_urb(0, GFP_ATOMIC)))\r\nreturn -ENOMEM;\r\nskb = bt_skb_alloc(size, GFP_ATOMIC);\r\nif (!skb) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nskb->dev = (void *) data;\r\nscb = (struct bfusb_data_scb *) skb->cb;\r\nscb->urb = urb;\r\npipe = usb_rcvbulkpipe(data->udev, data->bulk_in_ep);\r\nusb_fill_bulk_urb(urb, data->udev, pipe, skb->data, size,\r\nbfusb_rx_complete, skb);\r\nskb_queue_tail(&data->pending_q, skb);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\nBT_ERR("%s bulk rx submit failed urb %p err %d",\r\ndata->hdev->name, urb, err);\r\nskb_unlink(skb, &data->pending_q);\r\nkfree_skb(skb);\r\nusb_free_urb(urb);\r\n}\r\nreturn err;\r\n}\r\nstatic inline int bfusb_recv_block(struct bfusb_data *data, int hdr, unsigned char *buf, int len)\r\n{\r\nBT_DBG("bfusb %p hdr 0x%02x data %p len %d", data, hdr, buf, len);\r\nif (hdr & 0x10) {\r\nBT_ERR("%s error in block", data->hdev->name);\r\nkfree_skb(data->reassembly);\r\ndata->reassembly = NULL;\r\nreturn -EIO;\r\n}\r\nif (hdr & 0x04) {\r\nstruct sk_buff *skb;\r\nunsigned char pkt_type;\r\nint pkt_len = 0;\r\nif (data->reassembly) {\r\nBT_ERR("%s unexpected start block", data->hdev->name);\r\nkfree_skb(data->reassembly);\r\ndata->reassembly = NULL;\r\n}\r\nif (len < 1) {\r\nBT_ERR("%s no packet type found", data->hdev->name);\r\nreturn -EPROTO;\r\n}\r\npkt_type = *buf++; len--;\r\nswitch (pkt_type) {\r\ncase HCI_EVENT_PKT:\r\nif (len >= HCI_EVENT_HDR_SIZE) {\r\nstruct hci_event_hdr *hdr = (struct hci_event_hdr *) buf;\r\npkt_len = HCI_EVENT_HDR_SIZE + hdr->plen;\r\n} else {\r\nBT_ERR("%s event block is too short", data->hdev->name);\r\nreturn -EILSEQ;\r\n}\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nif (len >= HCI_ACL_HDR_SIZE) {\r\nstruct hci_acl_hdr *hdr = (struct hci_acl_hdr *) buf;\r\npkt_len = HCI_ACL_HDR_SIZE + __le16_to_cpu(hdr->dlen);\r\n} else {\r\nBT_ERR("%s data block is too short", data->hdev->name);\r\nreturn -EILSEQ;\r\n}\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nif (len >= HCI_SCO_HDR_SIZE) {\r\nstruct hci_sco_hdr *hdr = (struct hci_sco_hdr *) buf;\r\npkt_len = HCI_SCO_HDR_SIZE + hdr->dlen;\r\n} else {\r\nBT_ERR("%s audio block is too short", data->hdev->name);\r\nreturn -EILSEQ;\r\n}\r\nbreak;\r\n}\r\nskb = bt_skb_alloc(pkt_len, GFP_ATOMIC);\r\nif (!skb) {\r\nBT_ERR("%s no memory for the packet", data->hdev->name);\r\nreturn -ENOMEM;\r\n}\r\nskb->dev = (void *) data->hdev;\r\nbt_cb(skb)->pkt_type = pkt_type;\r\ndata->reassembly = skb;\r\n} else {\r\nif (!data->reassembly) {\r\nBT_ERR("%s unexpected continuation block", data->hdev->name);\r\nreturn -EIO;\r\n}\r\n}\r\nif (len > 0)\r\nmemcpy(skb_put(data->reassembly, len), buf, len);\r\nif (hdr & 0x08) {\r\nhci_recv_frame(data->reassembly);\r\ndata->reassembly = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bfusb_rx_complete(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct bfusb_data *data = (struct bfusb_data *) skb->dev;\r\nunsigned char *buf = urb->transfer_buffer;\r\nint count = urb->actual_length;\r\nint err, hdr, len;\r\nBT_DBG("bfusb %p urb %p skb %p len %d", data, urb, skb, skb->len);\r\nread_lock(&data->lock);\r\nif (!test_bit(HCI_RUNNING, &data->hdev->flags))\r\ngoto unlock;\r\nif (urb->status || !count)\r\ngoto resubmit;\r\ndata->hdev->stat.byte_rx += count;\r\nskb_put(skb, count);\r\nwhile (count) {\r\nhdr = buf[0] | (buf[1] << 8);\r\nif (hdr & 0x4000) {\r\nlen = 0;\r\ncount -= 2;\r\nbuf += 2;\r\n} else {\r\nlen = (buf[2] == 0) ? 256 : buf[2];\r\ncount -= 3;\r\nbuf += 3;\r\n}\r\nif (count < len) {\r\nBT_ERR("%s block extends over URB buffer ranges",\r\ndata->hdev->name);\r\n}\r\nif ((hdr & 0xe1) == 0xc1)\r\nbfusb_recv_block(data, hdr, buf, len);\r\ncount -= len;\r\nbuf += len;\r\n}\r\nskb_unlink(skb, &data->pending_q);\r\nkfree_skb(skb);\r\nbfusb_rx_submit(data, urb);\r\nread_unlock(&data->lock);\r\nreturn;\r\nresubmit:\r\nurb->dev = data->udev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\nBT_ERR("%s bulk resubmit failed urb %p err %d",\r\ndata->hdev->name, urb, err);\r\n}\r\nunlock:\r\nread_unlock(&data->lock);\r\n}\r\nstatic int bfusb_open(struct hci_dev *hdev)\r\n{\r\nstruct bfusb_data *data = hci_get_drvdata(hdev);\r\nunsigned long flags;\r\nint i, err;\r\nBT_DBG("hdev %p bfusb %p", hdev, data);\r\nif (test_and_set_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nwrite_lock_irqsave(&data->lock, flags);\r\nerr = bfusb_rx_submit(data, NULL);\r\nif (!err) {\r\nfor (i = 1; i < BFUSB_MAX_BULK_RX; i++)\r\nbfusb_rx_submit(data, NULL);\r\n} else {\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\n}\r\nwrite_unlock_irqrestore(&data->lock, flags);\r\nreturn err;\r\n}\r\nstatic int bfusb_flush(struct hci_dev *hdev)\r\n{\r\nstruct bfusb_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("hdev %p bfusb %p", hdev, data);\r\nskb_queue_purge(&data->transmit_q);\r\nreturn 0;\r\n}\r\nstatic int bfusb_close(struct hci_dev *hdev)\r\n{\r\nstruct bfusb_data *data = hci_get_drvdata(hdev);\r\nunsigned long flags;\r\nBT_DBG("hdev %p bfusb %p", hdev, data);\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nwrite_lock_irqsave(&data->lock, flags);\r\nwrite_unlock_irqrestore(&data->lock, flags);\r\nbfusb_unlink_urbs(data);\r\nbfusb_flush(hdev);\r\nreturn 0;\r\n}\r\nstatic int bfusb_send_frame(struct sk_buff *skb)\r\n{\r\nstruct hci_dev *hdev = (struct hci_dev *) skb->dev;\r\nstruct bfusb_data *data;\r\nstruct sk_buff *nskb;\r\nunsigned char buf[3];\r\nint sent = 0, size, count;\r\nBT_DBG("hdev %p skb %p type %d len %d", hdev, skb, bt_cb(skb)->pkt_type, skb->len);\r\nif (!hdev) {\r\nBT_ERR("Frame for unknown HCI device (hdev=NULL)");\r\nreturn -ENODEV;\r\n}\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\ndata = hci_get_drvdata(hdev);\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n};\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\ncount = skb->len;\r\nnskb = bt_skb_alloc(count + 32, GFP_ATOMIC);\r\nif (!nskb) {\r\nBT_ERR("Can't allocate memory for new packet");\r\nreturn -ENOMEM;\r\n}\r\nnskb->dev = (void *) data;\r\nwhile (count) {\r\nsize = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE);\r\nbuf[0] = 0xc1 | ((sent == 0) ? 0x04 : 0) | ((count == size) ? 0x08 : 0);\r\nbuf[1] = 0x00;\r\nbuf[2] = (size == BFUSB_MAX_BLOCK_SIZE) ? 0 : size;\r\nmemcpy(skb_put(nskb, 3), buf, 3);\r\nskb_copy_from_linear_data_offset(skb, sent, skb_put(nskb, size), size);\r\nsent += size;\r\ncount -= size;\r\n}\r\nif ((nskb->len % data->bulk_pkt_size) == 0) {\r\nbuf[0] = 0xdd;\r\nbuf[1] = 0x00;\r\nmemcpy(skb_put(nskb, 2), buf, 2);\r\n}\r\nread_lock(&data->lock);\r\nskb_queue_tail(&data->transmit_q, nskb);\r\nbfusb_tx_wakeup(data);\r\nread_unlock(&data->lock);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int bfusb_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int bfusb_load_firmware(struct bfusb_data *data,\r\nconst unsigned char *firmware, int count)\r\n{\r\nunsigned char *buf;\r\nint err, pipe, len, size, sent = 0;\r\nBT_DBG("bfusb %p udev %p", data, data->udev);\r\nBT_INFO("BlueFRITZ! USB loading firmware");\r\nbuf = kmalloc(BFUSB_MAX_BLOCK_SIZE + 3, GFP_KERNEL);\r\nif (!buf) {\r\nBT_ERR("Can't allocate memory chunk for firmware");\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_sndctrlpipe(data->udev, 0);\r\nif (usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,\r\n0, 1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT) < 0) {\r\nBT_ERR("Can't change to loading configuration");\r\nkfree(buf);\r\nreturn -EBUSY;\r\n}\r\ndata->udev->toggle[0] = data->udev->toggle[1] = 0;\r\npipe = usb_sndbulkpipe(data->udev, data->bulk_out_ep);\r\nwhile (count) {\r\nsize = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE + 3);\r\nmemcpy(buf, firmware + sent, size);\r\nerr = usb_bulk_msg(data->udev, pipe, buf, size,\r\n&len, BFUSB_BLOCK_TIMEOUT);\r\nif (err || (len != size)) {\r\nBT_ERR("Error in firmware loading");\r\ngoto error;\r\n}\r\nsent += size;\r\ncount -= size;\r\n}\r\nerr = usb_bulk_msg(data->udev, pipe, NULL, 0,\r\n&len, BFUSB_BLOCK_TIMEOUT);\r\nif (err < 0) {\r\nBT_ERR("Error in null packet request");\r\ngoto error;\r\n}\r\npipe = usb_sndctrlpipe(data->udev, 0);\r\nerr = usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,\r\n0, 2, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\nif (err < 0) {\r\nBT_ERR("Can't change to running configuration");\r\ngoto error;\r\n}\r\ndata->udev->toggle[0] = data->udev->toggle[1] = 0;\r\nBT_INFO("BlueFRITZ! USB device ready");\r\nkfree(buf);\r\nreturn 0;\r\nerror:\r\nkfree(buf);\r\npipe = usb_sndctrlpipe(data->udev, 0);\r\nusb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,\r\n0, 0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\nreturn err;\r\n}\r\nstatic int bfusb_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nconst struct firmware *firmware;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_host_endpoint *bulk_out_ep;\r\nstruct usb_host_endpoint *bulk_in_ep;\r\nstruct hci_dev *hdev;\r\nstruct bfusb_data *data;\r\nBT_DBG("intf %p id %p", intf, id);\r\nif (intf->cur_altsetting->desc.bNumEndpoints < 2)\r\nreturn -EIO;\r\nbulk_out_ep = &intf->cur_altsetting->endpoint[0];\r\nbulk_in_ep = &intf->cur_altsetting->endpoint[1];\r\nif (!bulk_out_ep || !bulk_in_ep) {\r\nBT_ERR("Bulk endpoints not found");\r\ngoto done;\r\n}\r\ndata = devm_kzalloc(&intf->dev, sizeof(struct bfusb_data), GFP_KERNEL);\r\nif (!data) {\r\nBT_ERR("Can't allocate memory for control structure");\r\ngoto done;\r\n}\r\ndata->udev = udev;\r\ndata->bulk_in_ep = bulk_in_ep->desc.bEndpointAddress;\r\ndata->bulk_out_ep = bulk_out_ep->desc.bEndpointAddress;\r\ndata->bulk_pkt_size = le16_to_cpu(bulk_out_ep->desc.wMaxPacketSize);\r\nrwlock_init(&data->lock);\r\ndata->reassembly = NULL;\r\nskb_queue_head_init(&data->transmit_q);\r\nskb_queue_head_init(&data->pending_q);\r\nskb_queue_head_init(&data->completed_q);\r\nif (request_firmware(&firmware, "bfubase.frm", &udev->dev) < 0) {\r\nBT_ERR("Firmware request failed");\r\ngoto done;\r\n}\r\nBT_DBG("firmware data %p size %zu", firmware->data, firmware->size);\r\nif (bfusb_load_firmware(data, firmware->data, firmware->size) < 0) {\r\nBT_ERR("Firmware loading failed");\r\ngoto release;\r\n}\r\nrelease_firmware(firmware);\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can't allocate HCI device");\r\ngoto done;\r\n}\r\ndata->hdev = hdev;\r\nhdev->bus = HCI_USB;\r\nhci_set_drvdata(hdev, data);\r\nSET_HCIDEV_DEV(hdev, &intf->dev);\r\nhdev->open = bfusb_open;\r\nhdev->close = bfusb_close;\r\nhdev->flush = bfusb_flush;\r\nhdev->send = bfusb_send_frame;\r\nhdev->ioctl = bfusb_ioctl;\r\nif (hci_register_dev(hdev) < 0) {\r\nBT_ERR("Can't register HCI device");\r\nhci_free_dev(hdev);\r\ngoto done;\r\n}\r\nusb_set_intfdata(intf, data);\r\nreturn 0;\r\nrelease:\r\nrelease_firmware(firmware);\r\ndone:\r\nreturn -EIO;\r\n}\r\nstatic void bfusb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct bfusb_data *data = usb_get_intfdata(intf);\r\nstruct hci_dev *hdev = data->hdev;\r\nBT_DBG("intf %p", intf);\r\nif (!hdev)\r\nreturn;\r\nusb_set_intfdata(intf, NULL);\r\nbfusb_close(hdev);\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\n}
