static int\r\nnouveau_pm_perflvl_aux(struct drm_device *dev, struct nouveau_pm_level *perflvl,\r\nstruct nouveau_pm_level *a, struct nouveau_pm_level *b)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nint ret;\r\nif (therm && therm->fan_set &&\r\na->fanspeed && b->fanspeed && b->fanspeed > a->fanspeed) {\r\nret = therm->fan_set(therm, perflvl->fanspeed);\r\nif (ret && ret != -ENODEV) {\r\nNV_ERROR(drm, "fanspeed set failed: %d\n", ret);\r\n}\r\n}\r\nif (pm->voltage.supported && pm->voltage_set) {\r\nif (perflvl->volt_min && b->volt_min > a->volt_min) {\r\nret = pm->voltage_set(dev, perflvl->volt_min);\r\nif (ret) {\r\nNV_ERROR(drm, "voltage set failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_pm_perflvl_set(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nvoid *state;\r\nint ret;\r\nif (perflvl == pm->cur)\r\nreturn 0;\r\nret = nouveau_pm_perflvl_aux(dev, perflvl, pm->cur, perflvl);\r\nif (ret)\r\nreturn ret;\r\nstate = pm->clocks_pre(dev, perflvl);\r\nif (IS_ERR(state)) {\r\nret = PTR_ERR(state);\r\ngoto error;\r\n}\r\nret = pm->clocks_set(dev, state);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_pm_perflvl_aux(dev, perflvl, perflvl, pm->cur);\r\nif (ret)\r\nreturn ret;\r\npm->cur = perflvl;\r\nreturn 0;\r\nerror:\r\nnouveau_pm_perflvl_aux(dev, perflvl, perflvl, pm->cur);\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_pm_trigger(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_timer *ptimer = nouveau_timer(drm->device);\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_pm_profile *profile = NULL;\r\nstruct nouveau_pm_level *perflvl = NULL;\r\nint ret;\r\nif (power_supply_is_system_supplied())\r\nprofile = pm->profile_ac;\r\nelse\r\nprofile = pm->profile_dc;\r\nif (profile != pm->profile) {\r\npm->profile->func->fini(pm->profile);\r\npm->profile = profile;\r\npm->profile->func->init(pm->profile);\r\n}\r\nperflvl = profile->func->select(profile);\r\nif (perflvl != pm->cur) {\r\nu64 time0 = ptimer->read(ptimer);\r\nNV_INFO(drm, "setting performance level: %d", perflvl->id);\r\nret = nouveau_pm_perflvl_set(dev, perflvl);\r\nif (ret)\r\nNV_INFO(drm, "> reclocking failed: %d\n\n", ret);\r\nNV_INFO(drm, "> reclocking took %lluns\n\n",\r\nptimer->read(ptimer) - time0);\r\n}\r\n}\r\nstatic struct nouveau_pm_profile *\r\nprofile_find(struct drm_device *dev, const char *string)\r\n{\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_pm_profile *profile;\r\nlist_for_each_entry(profile, &pm->profiles, head) {\r\nif (!strncmp(profile->name, string, sizeof(profile->name)))\r\nreturn profile;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nnouveau_pm_profile_set(struct drm_device *dev, const char *profile)\r\n{\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_pm_profile *ac = NULL, *dc = NULL;\r\nchar string[16], *cur = string, *ptr;\r\nif (nouveau_perflvl_wr != 7777)\r\nreturn -EPERM;\r\nstrncpy(string, profile, sizeof(string));\r\nstring[sizeof(string) - 1] = 0;\r\nif ((ptr = strchr(string, '\n')))\r\n*ptr = '\0';\r\nptr = strsep(&cur, ",");\r\nif (ptr)\r\nac = profile_find(dev, ptr);\r\nptr = strsep(&cur, ",");\r\nif (ptr)\r\ndc = profile_find(dev, ptr);\r\nelse\r\ndc = ac;\r\nif (ac == NULL || dc == NULL)\r\nreturn -EINVAL;\r\npm->profile_ac = ac;\r\npm->profile_dc = dc;\r\nnouveau_pm_trigger(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_pm_static_dummy(struct nouveau_pm_profile *profile)\r\n{\r\n}\r\nstatic struct nouveau_pm_level *\r\nnouveau_pm_static_select(struct nouveau_pm_profile *profile)\r\n{\r\nreturn container_of(profile, struct nouveau_pm_level, profile);\r\n}\r\nstatic int\r\nnouveau_pm_perflvl_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nint ret;\r\nmemset(perflvl, 0, sizeof(*perflvl));\r\nif (pm->clocks_get) {\r\nret = pm->clocks_get(dev, perflvl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pm->voltage.supported && pm->voltage_get) {\r\nret = pm->voltage_get(dev);\r\nif (ret > 0) {\r\nperflvl->volt_min = ret;\r\nperflvl->volt_max = ret;\r\n}\r\n}\r\nif (therm && therm->fan_get) {\r\nret = therm->fan_get(therm);\r\nif (ret >= 0)\r\nperflvl->fanspeed = ret;\r\n}\r\nnouveau_mem_timing_read(dev, &perflvl->timing);\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_pm_perflvl_info(struct nouveau_pm_level *perflvl, char *ptr, int len)\r\n{\r\nchar c[16], s[16], v[32], f[16], m[16];\r\nc[0] = '\0';\r\nif (perflvl->core)\r\nsnprintf(c, sizeof(c), " core %dMHz", perflvl->core / 1000);\r\ns[0] = '\0';\r\nif (perflvl->shader)\r\nsnprintf(s, sizeof(s), " shader %dMHz", perflvl->shader / 1000);\r\nm[0] = '\0';\r\nif (perflvl->memory)\r\nsnprintf(m, sizeof(m), " memory %dMHz", perflvl->memory / 1000);\r\nv[0] = '\0';\r\nif (perflvl->volt_min && perflvl->volt_min != perflvl->volt_max) {\r\nsnprintf(v, sizeof(v), " voltage %dmV-%dmV",\r\nperflvl->volt_min / 1000, perflvl->volt_max / 1000);\r\n} else\r\nif (perflvl->volt_min) {\r\nsnprintf(v, sizeof(v), " voltage %dmV",\r\nperflvl->volt_min / 1000);\r\n}\r\nf[0] = '\0';\r\nif (perflvl->fanspeed)\r\nsnprintf(f, sizeof(f), " fanspeed %d%%", perflvl->fanspeed);\r\nsnprintf(ptr, len, "%s%s%s%s%s\n", c, s, m, v, f);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_get_perflvl_info(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct nouveau_pm_level *perflvl =\r\ncontainer_of(a, struct nouveau_pm_level, dev_attr);\r\nchar *ptr = buf;\r\nint len = PAGE_SIZE;\r\nsnprintf(ptr, len, "%d:", perflvl->id);\r\nptr += strlen(buf);\r\nlen -= strlen(buf);\r\nnouveau_pm_perflvl_info(perflvl, ptr, len);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_get_perflvl(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(to_pci_dev(d));\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_pm_level cur;\r\nint len = PAGE_SIZE, ret;\r\nchar *ptr = buf;\r\nsnprintf(ptr, len, "profile: %s, %s\nc:",\r\npm->profile_ac->name, pm->profile_dc->name);\r\nptr += strlen(buf);\r\nlen -= strlen(buf);\r\nret = nouveau_pm_perflvl_get(dev, &cur);\r\nif (ret == 0)\r\nnouveau_pm_perflvl_info(&cur, ptr, len);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_set_perflvl(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(to_pci_dev(d));\r\nint ret;\r\nret = nouveau_pm_profile_set(dev, buf);\r\nif (ret)\r\nreturn ret;\r\nreturn strlen(buf);\r\n}\r\nstatic int\r\nnouveau_sysfs_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct device *d = &dev->pdev->dev;\r\nint ret, i;\r\nret = device_create_file(d, &dev_attr_performance_level);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nstruct nouveau_pm_level *perflvl = &pm->perflvl[i];\r\nperflvl->dev_attr.attr.name = perflvl->name;\r\nperflvl->dev_attr.attr.mode = S_IRUGO;\r\nperflvl->dev_attr.show = nouveau_pm_get_perflvl_info;\r\nperflvl->dev_attr.store = NULL;\r\nsysfs_attr_init(&perflvl->dev_attr.attr);\r\nret = device_create_file(d, &perflvl->dev_attr);\r\nif (ret) {\r\nNV_ERROR(drm, "failed pervlvl %d sysfs: %d\n",\r\nperflvl->id, i);\r\nperflvl->dev_attr.attr.name = NULL;\r\nnouveau_pm_fini(dev);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_sysfs_fini(struct drm_device *dev)\r\n{\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct device *d = &dev->pdev->dev;\r\nint i;\r\ndevice_remove_file(d, &dev_attr_performance_level);\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nstruct nouveau_pm_level *pl = &pm->perflvl[i];\r\nif (!pl->dev_attr.attr.name)\r\nbreak;\r\ndevice_remove_file(d, &pl->dev_attr);\r\n}\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_show_temp(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nint temp = therm->temp_get(therm);\r\nif (temp < 0)\r\nreturn temp;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_show_temp1_auto_point1_pwm(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", 100);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_temp1_auto_point1_temp(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ntherm->attr_get(therm, NOUVEAU_THERM_ATTR_THRS_FAN_BOOST) * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_temp1_auto_point1_temp(struct device *d,\r\nstruct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntherm->attr_set(therm, NOUVEAU_THERM_ATTR_THRS_FAN_BOOST,\r\nvalue / 1000);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_temp1_auto_point1_temp_hyst(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ntherm->attr_get(therm, NOUVEAU_THERM_ATTR_THRS_FAN_BOOST_HYST) * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_temp1_auto_point1_temp_hyst(struct device *d,\r\nstruct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntherm->attr_set(therm, NOUVEAU_THERM_ATTR_THRS_FAN_BOOST_HYST,\r\nvalue / 1000);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_max_temp(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ntherm->attr_get(therm, NOUVEAU_THERM_ATTR_THRS_DOWN_CLK) * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_max_temp(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntherm->attr_set(therm, NOUVEAU_THERM_ATTR_THRS_DOWN_CLK, value / 1000);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_max_temp_hyst(struct device *d, struct device_attribute *a,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ntherm->attr_get(therm, NOUVEAU_THERM_ATTR_THRS_DOWN_CLK_HYST) * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_max_temp_hyst(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntherm->attr_set(therm, NOUVEAU_THERM_ATTR_THRS_DOWN_CLK_HYST,\r\nvalue / 1000);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_critical_temp(struct device *d, struct device_attribute *a,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ntherm->attr_get(therm, NOUVEAU_THERM_ATTR_THRS_CRITICAL) * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_critical_temp(struct device *d, struct device_attribute *a,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntherm->attr_set(therm, NOUVEAU_THERM_ATTR_THRS_CRITICAL, value / 1000);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_critical_temp_hyst(struct device *d, struct device_attribute *a,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ntherm->attr_get(therm, NOUVEAU_THERM_ATTR_THRS_CRITICAL_HYST) * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_critical_temp_hyst(struct device *d,\r\nstruct device_attribute *a,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntherm->attr_set(therm, NOUVEAU_THERM_ATTR_THRS_CRITICAL_HYST,\r\nvalue / 1000);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_emergency_temp(struct device *d, struct device_attribute *a,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ntherm->attr_get(therm, NOUVEAU_THERM_ATTR_THRS_SHUTDOWN) * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_emergency_temp(struct device *d, struct device_attribute *a,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntherm->attr_set(therm, NOUVEAU_THERM_ATTR_THRS_SHUTDOWN, value / 1000);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_emergency_temp_hyst(struct device *d, struct device_attribute *a,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ntherm->attr_get(therm, NOUVEAU_THERM_ATTR_THRS_SHUTDOWN_HYST) * 1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_emergency_temp_hyst(struct device *d,\r\nstruct device_attribute *a,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntherm->attr_set(therm, NOUVEAU_THERM_ATTR_THRS_SHUTDOWN_HYST,\r\nvalue / 1000);\r\nreturn count;\r\n}\r\nstatic ssize_t nouveau_hwmon_show_name(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "nouveau\n");\r\n}\r\nstatic ssize_t nouveau_hwmon_show_update_rate(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "1000\n");\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_show_fan1_input(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", therm->fan_sense(therm));\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_get_pwm1_enable(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nint ret;\r\nret = therm->attr_get(therm, NOUVEAU_THERM_ATTR_FAN_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_pwm1_enable(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nint ret;\r\nif (strict_strtol(buf, 10, &value) == -EINVAL)\r\nreturn -EINVAL;\r\nret = therm->attr_set(therm, NOUVEAU_THERM_ATTR_FAN_MODE, value);\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_get_pwm1(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nint ret;\r\nret = therm->fan_get(therm);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_pwm1(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nint ret = -ENODEV;\r\nlong value;\r\nif (nouveau_perflvl_wr != 7777)\r\nreturn -EPERM;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn -EINVAL;\r\nret = therm->fan_set(therm, value);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_get_pwm1_min(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nint ret;\r\nret = therm->attr_get(therm, NOUVEAU_THERM_ATTR_FAN_MIN_DUTY);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_pwm1_min(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nint ret;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn -EINVAL;\r\nret = therm->attr_set(therm, NOUVEAU_THERM_ATTR_FAN_MIN_DUTY, value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_get_pwm1_max(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nint ret;\r\nret = therm->attr_get(therm, NOUVEAU_THERM_ATTR_FAN_MAX_DUTY);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_pwm1_max(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nlong value;\r\nint ret;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn -EINVAL;\r\nret = therm->attr_set(therm, NOUVEAU_THERM_ATTR_FAN_MAX_DUTY, value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int\r\nnouveau_hwmon_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\n#if defined(CONFIG_HWMON) || (defined(MODULE) && defined(CONFIG_HWMON_MODULE))\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_therm *therm = nouveau_therm(drm->device);\r\nstruct device *hwmon_dev;\r\nint ret = 0;\r\nif (!therm || !therm->temp_get || !therm->attr_get || !therm->attr_set)\r\nreturn -ENODEV;\r\nhwmon_dev = hwmon_device_register(&dev->pdev->dev);\r\nif (IS_ERR(hwmon_dev)) {\r\nret = PTR_ERR(hwmon_dev);\r\nNV_ERROR(drm, "Unable to register hwmon device: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(hwmon_dev, dev);\r\nret = sysfs_create_group(&hwmon_dev->kobj, &hwmon_default_attrgroup);\r\nif (ret) {\r\nif (ret)\r\ngoto error;\r\n}\r\nif (therm->temp_get(therm) >= 0) {\r\nret = sysfs_create_group(&hwmon_dev->kobj, &hwmon_temp_attrgroup);\r\nif (ret) {\r\nif (ret)\r\ngoto error;\r\n}\r\n}\r\nif (therm->fan_get && therm->fan_get(therm) >= 0) {\r\nret = sysfs_create_group(&hwmon_dev->kobj,\r\n&hwmon_pwm_fan_attrgroup);\r\nif (ret)\r\ngoto error;\r\n}\r\nif (therm->fan_sense(therm) >= 0) {\r\nret = sysfs_create_group(&hwmon_dev->kobj,\r\n&hwmon_fan_rpm_attrgroup);\r\nif (ret)\r\ngoto error;\r\n}\r\npm->hwmon = hwmon_dev;\r\nreturn 0;\r\nerror:\r\nNV_ERROR(drm, "Unable to create some hwmon sysfs files: %d\n", ret);\r\nhwmon_device_unregister(hwmon_dev);\r\npm->hwmon = NULL;\r\nreturn ret;\r\n#else\r\npm->hwmon = NULL;\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void\r\nnouveau_hwmon_fini(struct drm_device *dev)\r\n{\r\n#if defined(CONFIG_HWMON) || (defined(MODULE) && defined(CONFIG_HWMON_MODULE))\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nif (pm->hwmon) {\r\nsysfs_remove_group(&pm->hwmon->kobj, &hwmon_default_attrgroup);\r\nsysfs_remove_group(&pm->hwmon->kobj, &hwmon_temp_attrgroup);\r\nsysfs_remove_group(&pm->hwmon->kobj, &hwmon_pwm_fan_attrgroup);\r\nsysfs_remove_group(&pm->hwmon->kobj, &hwmon_fan_rpm_attrgroup);\r\nhwmon_device_unregister(pm->hwmon);\r\n}\r\n#endif\r\n}\r\nstatic int\r\nnouveau_pm_acpi_event(struct notifier_block *nb, unsigned long val, void *data)\r\n{\r\nstruct nouveau_pm *pm = container_of(nb, struct nouveau_pm, acpi_nb);\r\nstruct nouveau_drm *drm = nouveau_drm(pm->dev);\r\nstruct acpi_bus_event *entry = (struct acpi_bus_event *)data;\r\nif (strcmp(entry->device_class, "ac_adapter") == 0) {\r\nbool ac = power_supply_is_system_supplied();\r\nNV_DEBUG(drm, "power supply changed: %s\n", ac ? "AC" : "DC");\r\nnouveau_pm_trigger(pm->dev);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nint\r\nnouveau_pm_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_pm *pm;\r\nchar info[256];\r\nint ret, i;\r\npm = drm->pm = kzalloc(sizeof(*pm), GFP_KERNEL);\r\nif (!pm)\r\nreturn -ENOMEM;\r\npm->dev = dev;\r\nif (device->card_type < NV_40) {\r\npm->clocks_get = nv04_pm_clocks_get;\r\npm->clocks_pre = nv04_pm_clocks_pre;\r\npm->clocks_set = nv04_pm_clocks_set;\r\nif (nouveau_gpio(drm->device)) {\r\npm->voltage_get = nouveau_voltage_gpio_get;\r\npm->voltage_set = nouveau_voltage_gpio_set;\r\n}\r\n} else\r\nif (device->card_type < NV_50) {\r\npm->clocks_get = nv40_pm_clocks_get;\r\npm->clocks_pre = nv40_pm_clocks_pre;\r\npm->clocks_set = nv40_pm_clocks_set;\r\npm->voltage_get = nouveau_voltage_gpio_get;\r\npm->voltage_set = nouveau_voltage_gpio_set;\r\n} else\r\nif (device->card_type < NV_C0) {\r\nif (device->chipset < 0xa3 ||\r\ndevice->chipset == 0xaa ||\r\ndevice->chipset == 0xac) {\r\npm->clocks_get = nv50_pm_clocks_get;\r\npm->clocks_pre = nv50_pm_clocks_pre;\r\npm->clocks_set = nv50_pm_clocks_set;\r\n} else {\r\npm->clocks_get = nva3_pm_clocks_get;\r\npm->clocks_pre = nva3_pm_clocks_pre;\r\npm->clocks_set = nva3_pm_clocks_set;\r\n}\r\npm->voltage_get = nouveau_voltage_gpio_get;\r\npm->voltage_set = nouveau_voltage_gpio_set;\r\n} else\r\nif (device->card_type < NV_E0) {\r\npm->clocks_get = nvc0_pm_clocks_get;\r\npm->clocks_pre = nvc0_pm_clocks_pre;\r\npm->clocks_set = nvc0_pm_clocks_set;\r\npm->voltage_get = nouveau_voltage_gpio_get;\r\npm->voltage_set = nouveau_voltage_gpio_set;\r\n}\r\nnouveau_volt_init(dev);\r\nINIT_LIST_HEAD(&pm->profiles);\r\nret = nouveau_pm_perflvl_get(dev, &pm->boot);\r\nif (ret) {\r\nNV_ERROR(drm, "failed to determine boot perflvl\n");\r\nreturn ret;\r\n}\r\nstrncpy(pm->boot.name, "boot", 4);\r\nstrncpy(pm->boot.profile.name, "boot", 4);\r\npm->boot.profile.func = &nouveau_pm_static_profile_func;\r\nlist_add(&pm->boot.profile.head, &pm->profiles);\r\npm->profile_ac = &pm->boot.profile;\r\npm->profile_dc = &pm->boot.profile;\r\npm->profile = &pm->boot.profile;\r\npm->cur = &pm->boot;\r\nnouveau_perf_init(dev);\r\nNV_INFO(drm, "%d available performance level(s)\n", pm->nr_perflvl);\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nnouveau_pm_perflvl_info(&pm->perflvl[i], info, sizeof(info));\r\nNV_INFO(drm, "%d:%s", pm->perflvl[i].id, info);\r\n}\r\nnouveau_pm_perflvl_info(&pm->boot, info, sizeof(info));\r\nNV_INFO(drm, "c:%s", info);\r\nif (nouveau_perflvl != NULL)\r\nnouveau_pm_profile_set(dev, nouveau_perflvl);\r\nnouveau_sysfs_init(dev);\r\nnouveau_hwmon_init(dev);\r\n#if defined(CONFIG_ACPI) && defined(CONFIG_POWER_SUPPLY)\r\npm->acpi_nb.notifier_call = nouveau_pm_acpi_event;\r\nregister_acpi_notifier(&pm->acpi_nb);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_pm_fini(struct drm_device *dev)\r\n{\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_pm_profile *profile, *tmp;\r\nlist_for_each_entry_safe(profile, tmp, &pm->profiles, head) {\r\nlist_del(&profile->head);\r\nprofile->func->destroy(profile);\r\n}\r\nif (pm->cur != &pm->boot)\r\nnouveau_pm_perflvl_set(dev, &pm->boot);\r\nnouveau_perf_fini(dev);\r\nnouveau_volt_fini(dev);\r\n#if defined(CONFIG_ACPI) && defined(CONFIG_POWER_SUPPLY)\r\nunregister_acpi_notifier(&pm->acpi_nb);\r\n#endif\r\nnouveau_hwmon_fini(dev);\r\nnouveau_sysfs_fini(dev);\r\nnouveau_drm(dev)->pm = NULL;\r\nkfree(pm);\r\n}\r\nvoid\r\nnouveau_pm_resume(struct drm_device *dev)\r\n{\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_pm_level *perflvl;\r\nif (!pm->cur || pm->cur == &pm->boot)\r\nreturn;\r\nperflvl = pm->cur;\r\npm->cur = &pm->boot;\r\nnouveau_pm_perflvl_set(dev, perflvl);\r\n}
