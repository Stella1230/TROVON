static int ax25_std_state1_machine(ax25_cb *ax25, struct sk_buff *skb, int frametype, int pf, int type)\r\n{\r\nswitch (frametype) {\r\ncase AX25_SABM:\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\r\nax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\r\nbreak;\r\ncase AX25_SABME:\r\nax25->modulus = AX25_EMODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_EWINDOW];\r\nax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\r\nbreak;\r\ncase AX25_DISC:\r\nax25_send_control(ax25, AX25_DM, pf, AX25_RESPONSE);\r\nbreak;\r\ncase AX25_UA:\r\nif (pf) {\r\nax25_calculate_rtt(ax25);\r\nax25_stop_t1timer(ax25);\r\nax25_start_t3timer(ax25);\r\nax25_start_idletimer(ax25);\r\nax25->vs = 0;\r\nax25->va = 0;\r\nax25->vr = 0;\r\nax25->state = AX25_STATE_3;\r\nax25->n2count = 0;\r\nif (ax25->sk != NULL) {\r\nbh_lock_sock(ax25->sk);\r\nax25->sk->sk_state = TCP_ESTABLISHED;\r\nif (!sock_flag(ax25->sk, SOCK_DEAD))\r\nax25->sk->sk_state_change(ax25->sk);\r\nbh_unlock_sock(ax25->sk);\r\n}\r\n}\r\nbreak;\r\ncase AX25_DM:\r\nif (pf) {\r\nif (ax25->modulus == AX25_MODULUS) {\r\nax25_disconnect(ax25, ECONNREFUSED);\r\n} else {\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ax25_std_state2_machine(ax25_cb *ax25, struct sk_buff *skb, int frametype, int pf, int type)\r\n{\r\nswitch (frametype) {\r\ncase AX25_SABM:\r\ncase AX25_SABME:\r\nax25_send_control(ax25, AX25_DM, pf, AX25_RESPONSE);\r\nbreak;\r\ncase AX25_DISC:\r\nax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\r\nax25_disconnect(ax25, 0);\r\nbreak;\r\ncase AX25_DM:\r\ncase AX25_UA:\r\nif (pf)\r\nax25_disconnect(ax25, 0);\r\nbreak;\r\ncase AX25_I:\r\ncase AX25_REJ:\r\ncase AX25_RNR:\r\ncase AX25_RR:\r\nif (pf) ax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ax25_std_state3_machine(ax25_cb *ax25, struct sk_buff *skb, int frametype, int ns, int nr, int pf, int type)\r\n{\r\nint queued = 0;\r\nswitch (frametype) {\r\ncase AX25_SABM:\r\ncase AX25_SABME:\r\nif (frametype == AX25_SABM) {\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\r\n} else {\r\nax25->modulus = AX25_EMODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_EWINDOW];\r\n}\r\nax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\r\nax25_stop_t1timer(ax25);\r\nax25_stop_t2timer(ax25);\r\nax25_start_t3timer(ax25);\r\nax25_start_idletimer(ax25);\r\nax25->condition = 0x00;\r\nax25->vs = 0;\r\nax25->va = 0;\r\nax25->vr = 0;\r\nax25_requeue_frames(ax25);\r\nbreak;\r\ncase AX25_DISC:\r\nax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\r\nax25_disconnect(ax25, 0);\r\nbreak;\r\ncase AX25_DM:\r\nax25_disconnect(ax25, ECONNRESET);\r\nbreak;\r\ncase AX25_RR:\r\ncase AX25_RNR:\r\nif (frametype == AX25_RR)\r\nax25->condition &= ~AX25_COND_PEER_RX_BUSY;\r\nelse\r\nax25->condition |= AX25_COND_PEER_RX_BUSY;\r\nif (type == AX25_COMMAND && pf)\r\nax25_std_enquiry_response(ax25);\r\nif (ax25_validate_nr(ax25, nr)) {\r\nax25_check_iframes_acked(ax25, nr);\r\n} else {\r\nax25_std_nr_error_recovery(ax25);\r\nax25->state = AX25_STATE_1;\r\n}\r\nbreak;\r\ncase AX25_REJ:\r\nax25->condition &= ~AX25_COND_PEER_RX_BUSY;\r\nif (type == AX25_COMMAND && pf)\r\nax25_std_enquiry_response(ax25);\r\nif (ax25_validate_nr(ax25, nr)) {\r\nax25_frames_acked(ax25, nr);\r\nax25_calculate_rtt(ax25);\r\nax25_stop_t1timer(ax25);\r\nax25_start_t3timer(ax25);\r\nax25_requeue_frames(ax25);\r\n} else {\r\nax25_std_nr_error_recovery(ax25);\r\nax25->state = AX25_STATE_1;\r\n}\r\nbreak;\r\ncase AX25_I:\r\nif (!ax25_validate_nr(ax25, nr)) {\r\nax25_std_nr_error_recovery(ax25);\r\nax25->state = AX25_STATE_1;\r\nbreak;\r\n}\r\nif (ax25->condition & AX25_COND_PEER_RX_BUSY) {\r\nax25_frames_acked(ax25, nr);\r\n} else {\r\nax25_check_iframes_acked(ax25, nr);\r\n}\r\nif (ax25->condition & AX25_COND_OWN_RX_BUSY) {\r\nif (pf) ax25_std_enquiry_response(ax25);\r\nbreak;\r\n}\r\nif (ns == ax25->vr) {\r\nax25->vr = (ax25->vr + 1) % ax25->modulus;\r\nqueued = ax25_rx_iframe(ax25, skb);\r\nif (ax25->condition & AX25_COND_OWN_RX_BUSY)\r\nax25->vr = ns;\r\nax25->condition &= ~AX25_COND_REJECT;\r\nif (pf) {\r\nax25_std_enquiry_response(ax25);\r\n} else {\r\nif (!(ax25->condition & AX25_COND_ACK_PENDING)) {\r\nax25->condition |= AX25_COND_ACK_PENDING;\r\nax25_start_t2timer(ax25);\r\n}\r\n}\r\n} else {\r\nif (ax25->condition & AX25_COND_REJECT) {\r\nif (pf) ax25_std_enquiry_response(ax25);\r\n} else {\r\nax25->condition |= AX25_COND_REJECT;\r\nax25_send_control(ax25, AX25_REJ, pf, AX25_RESPONSE);\r\nax25->condition &= ~AX25_COND_ACK_PENDING;\r\n}\r\n}\r\nbreak;\r\ncase AX25_FRMR:\r\ncase AX25_ILLEGAL:\r\nax25_std_establish_data_link(ax25);\r\nax25->state = AX25_STATE_1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn queued;\r\n}\r\nstatic int ax25_std_state4_machine(ax25_cb *ax25, struct sk_buff *skb, int frametype, int ns, int nr, int pf, int type)\r\n{\r\nint queued = 0;\r\nswitch (frametype) {\r\ncase AX25_SABM:\r\ncase AX25_SABME:\r\nif (frametype == AX25_SABM) {\r\nax25->modulus = AX25_MODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_WINDOW];\r\n} else {\r\nax25->modulus = AX25_EMODULUS;\r\nax25->window = ax25->ax25_dev->values[AX25_VALUES_EWINDOW];\r\n}\r\nax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\r\nax25_stop_t1timer(ax25);\r\nax25_stop_t2timer(ax25);\r\nax25_start_t3timer(ax25);\r\nax25_start_idletimer(ax25);\r\nax25->condition = 0x00;\r\nax25->vs = 0;\r\nax25->va = 0;\r\nax25->vr = 0;\r\nax25->state = AX25_STATE_3;\r\nax25->n2count = 0;\r\nax25_requeue_frames(ax25);\r\nbreak;\r\ncase AX25_DISC:\r\nax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);\r\nax25_disconnect(ax25, 0);\r\nbreak;\r\ncase AX25_DM:\r\nax25_disconnect(ax25, ECONNRESET);\r\nbreak;\r\ncase AX25_RR:\r\ncase AX25_RNR:\r\nif (frametype == AX25_RR)\r\nax25->condition &= ~AX25_COND_PEER_RX_BUSY;\r\nelse\r\nax25->condition |= AX25_COND_PEER_RX_BUSY;\r\nif (type == AX25_RESPONSE && pf) {\r\nax25_stop_t1timer(ax25);\r\nax25->n2count = 0;\r\nif (ax25_validate_nr(ax25, nr)) {\r\nax25_frames_acked(ax25, nr);\r\nif (ax25->vs == ax25->va) {\r\nax25_start_t3timer(ax25);\r\nax25->state = AX25_STATE_3;\r\n} else {\r\nax25_requeue_frames(ax25);\r\n}\r\n} else {\r\nax25_std_nr_error_recovery(ax25);\r\nax25->state = AX25_STATE_1;\r\n}\r\nbreak;\r\n}\r\nif (type == AX25_COMMAND && pf)\r\nax25_std_enquiry_response(ax25);\r\nif (ax25_validate_nr(ax25, nr)) {\r\nax25_frames_acked(ax25, nr);\r\n} else {\r\nax25_std_nr_error_recovery(ax25);\r\nax25->state = AX25_STATE_1;\r\n}\r\nbreak;\r\ncase AX25_REJ:\r\nax25->condition &= ~AX25_COND_PEER_RX_BUSY;\r\nif (pf && type == AX25_RESPONSE) {\r\nax25_stop_t1timer(ax25);\r\nax25->n2count = 0;\r\nif (ax25_validate_nr(ax25, nr)) {\r\nax25_frames_acked(ax25, nr);\r\nif (ax25->vs == ax25->va) {\r\nax25_start_t3timer(ax25);\r\nax25->state = AX25_STATE_3;\r\n} else {\r\nax25_requeue_frames(ax25);\r\n}\r\n} else {\r\nax25_std_nr_error_recovery(ax25);\r\nax25->state = AX25_STATE_1;\r\n}\r\nbreak;\r\n}\r\nif (type == AX25_COMMAND && pf)\r\nax25_std_enquiry_response(ax25);\r\nif (ax25_validate_nr(ax25, nr)) {\r\nax25_frames_acked(ax25, nr);\r\nax25_requeue_frames(ax25);\r\n} else {\r\nax25_std_nr_error_recovery(ax25);\r\nax25->state = AX25_STATE_1;\r\n}\r\nbreak;\r\ncase AX25_I:\r\nif (!ax25_validate_nr(ax25, nr)) {\r\nax25_std_nr_error_recovery(ax25);\r\nax25->state = AX25_STATE_1;\r\nbreak;\r\n}\r\nax25_frames_acked(ax25, nr);\r\nif (ax25->condition & AX25_COND_OWN_RX_BUSY) {\r\nif (pf)\r\nax25_std_enquiry_response(ax25);\r\nbreak;\r\n}\r\nif (ns == ax25->vr) {\r\nax25->vr = (ax25->vr + 1) % ax25->modulus;\r\nqueued = ax25_rx_iframe(ax25, skb);\r\nif (ax25->condition & AX25_COND_OWN_RX_BUSY)\r\nax25->vr = ns;\r\nax25->condition &= ~AX25_COND_REJECT;\r\nif (pf) {\r\nax25_std_enquiry_response(ax25);\r\n} else {\r\nif (!(ax25->condition & AX25_COND_ACK_PENDING)) {\r\nax25->condition |= AX25_COND_ACK_PENDING;\r\nax25_start_t2timer(ax25);\r\n}\r\n}\r\n} else {\r\nif (ax25->condition & AX25_COND_REJECT) {\r\nif (pf) ax25_std_enquiry_response(ax25);\r\n} else {\r\nax25->condition |= AX25_COND_REJECT;\r\nax25_send_control(ax25, AX25_REJ, pf, AX25_RESPONSE);\r\nax25->condition &= ~AX25_COND_ACK_PENDING;\r\n}\r\n}\r\nbreak;\r\ncase AX25_FRMR:\r\ncase AX25_ILLEGAL:\r\nax25_std_establish_data_link(ax25);\r\nax25->state = AX25_STATE_1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn queued;\r\n}\r\nint ax25_std_frame_in(ax25_cb *ax25, struct sk_buff *skb, int type)\r\n{\r\nint queued = 0, frametype, ns, nr, pf;\r\nframetype = ax25_decode(ax25, skb, &ns, &nr, &pf);\r\nswitch (ax25->state) {\r\ncase AX25_STATE_1:\r\nqueued = ax25_std_state1_machine(ax25, skb, frametype, pf, type);\r\nbreak;\r\ncase AX25_STATE_2:\r\nqueued = ax25_std_state2_machine(ax25, skb, frametype, pf, type);\r\nbreak;\r\ncase AX25_STATE_3:\r\nqueued = ax25_std_state3_machine(ax25, skb, frametype, ns, nr, pf, type);\r\nbreak;\r\ncase AX25_STATE_4:\r\nqueued = ax25_std_state4_machine(ax25, skb, frametype, ns, nr, pf, type);\r\nbreak;\r\n}\r\nax25_kick(ax25);\r\nreturn queued;\r\n}
