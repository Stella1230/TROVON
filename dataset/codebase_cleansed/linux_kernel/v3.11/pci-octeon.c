int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nif (octeon_pcibios_map_irq)\r\nreturn octeon_pcibios_map_irq(dev, slot, pin);\r\nelse\r\npanic("octeon_pcibios_map_irq not set.");\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nuint16_t config;\r\nuint32_t dconfig;\r\nint pos;\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 64 / 4);\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 64);\r\npci_read_config_word(dev, PCI_COMMAND, &config);\r\nconfig |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;\r\npci_write_config_word(dev, PCI_COMMAND, config);\r\nif (dev->subordinate) {\r\npci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER, 64);\r\npci_read_config_word(dev, PCI_BRIDGE_CONTROL, &config);\r\nconfig |= PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR;\r\npci_write_config_word(dev, PCI_BRIDGE_CONTROL, config);\r\n}\r\nconfig = PCI_EXP_DEVCTL_CERE;\r\nconfig |= PCI_EXP_DEVCTL_NFERE;\r\nconfig |= PCI_EXP_DEVCTL_FERE;\r\nconfig |= PCI_EXP_DEVCTL_URRE;\r\npcie_capability_set_word(dev, PCI_EXP_DEVCTL, config);\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\nif (pos) {\r\npci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS,\r\n&dconfig);\r\npci_write_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS,\r\ndconfig);\r\npci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, 0);\r\npci_read_config_dword(dev, pos + PCI_ERR_COR_STATUS, &dconfig);\r\npci_write_config_dword(dev, pos + PCI_ERR_COR_STATUS, dconfig);\r\npci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, 0);\r\npci_read_config_dword(dev, pos + PCI_ERR_CAP, &dconfig);\r\nif (config & PCI_ERR_CAP_ECRC_GENC)\r\nconfig |= PCI_ERR_CAP_ECRC_GENE;\r\nif (config & PCI_ERR_CAP_ECRC_CHKC)\r\nconfig |= PCI_ERR_CAP_ECRC_CHKE;\r\npci_write_config_dword(dev, pos + PCI_ERR_CAP, dconfig);\r\npci_write_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND,\r\nPCI_ERR_ROOT_CMD_COR_EN |\r\nPCI_ERR_ROOT_CMD_NONFATAL_EN |\r\nPCI_ERR_ROOT_CMD_FATAL_EN);\r\npci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &dconfig);\r\npci_write_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, dconfig);\r\n}\r\ndev->dev.archdata.dma_ops = octeon_pci_dma_map_ops;\r\nreturn 0;\r\n}\r\nconst char *octeon_get_pci_interrupts(void)\r\n{\r\nswitch (octeon_bootinfo->board_type) {\r\ncase CVMX_BOARD_TYPE_NAO38:\r\nreturn "AAAAADABAAAAAAAAAAAAAAAAAAAAAAAA";\r\ncase CVMX_BOARD_TYPE_EBH3100:\r\ncase CVMX_BOARD_TYPE_CN3010_EVB_HS5:\r\ncase CVMX_BOARD_TYPE_CN3005_EVB_HS5:\r\nreturn "AAABAAAAAAAAAAAAAAAAAAAAAAAAAAAA";\r\ncase CVMX_BOARD_TYPE_BBGW_REF:\r\nreturn "AABCD";\r\ncase CVMX_BOARD_TYPE_THUNDER:\r\ncase CVMX_BOARD_TYPE_EBH3000:\r\ndefault:\r\nreturn "";\r\n}\r\n}\r\nint __init octeon_pci_pcibios_map_irq(const struct pci_dev *dev,\r\nu8 slot, u8 pin)\r\n{\r\nint irq_num;\r\nconst char *interrupts;\r\nint dev_num;\r\ninterrupts = octeon_get_pci_interrupts();\r\ndev_num = dev->devfn >> 3;\r\nif (dev_num < strlen(interrupts))\r\nirq_num = ((interrupts[dev_num] - 'A' + pin - 1) & 3) +\r\nOCTEON_IRQ_PCI_INT0;\r\nelse\r\nirq_num = ((slot + pin - 3) & 3) + OCTEON_IRQ_PCI_INT0;\r\nreturn irq_num;\r\n}\r\nstatic int octeon_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint reg, int size, u32 *val)\r\n{\r\nunion octeon_pci_address pci_addr;\r\npci_addr.u64 = 0;\r\npci_addr.s.upper = 2;\r\npci_addr.s.io = 1;\r\npci_addr.s.did = 3;\r\npci_addr.s.subdid = 1;\r\npci_addr.s.endian_swap = 1;\r\npci_addr.s.bus = bus->number;\r\npci_addr.s.dev = devfn >> 3;\r\npci_addr.s.func = devfn & 0x7;\r\npci_addr.s.reg = reg;\r\n#if PCI_CONFIG_SPACE_DELAY\r\nudelay(PCI_CONFIG_SPACE_DELAY);\r\n#endif\r\nswitch (size) {\r\ncase 4:\r\n*val = le32_to_cpu(cvmx_read64_uint32(pci_addr.u64));\r\nreturn PCIBIOS_SUCCESSFUL;\r\ncase 2:\r\n*val = le16_to_cpu(cvmx_read64_uint16(pci_addr.u64));\r\nreturn PCIBIOS_SUCCESSFUL;\r\ncase 1:\r\n*val = cvmx_read64_uint8(pci_addr.u64);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\nstatic int octeon_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint reg, int size, u32 val)\r\n{\r\nunion octeon_pci_address pci_addr;\r\npci_addr.u64 = 0;\r\npci_addr.s.upper = 2;\r\npci_addr.s.io = 1;\r\npci_addr.s.did = 3;\r\npci_addr.s.subdid = 1;\r\npci_addr.s.endian_swap = 1;\r\npci_addr.s.bus = bus->number;\r\npci_addr.s.dev = devfn >> 3;\r\npci_addr.s.func = devfn & 0x7;\r\npci_addr.s.reg = reg;\r\n#if PCI_CONFIG_SPACE_DELAY\r\nudelay(PCI_CONFIG_SPACE_DELAY);\r\n#endif\r\nswitch (size) {\r\ncase 4:\r\ncvmx_write64_uint32(pci_addr.u64, cpu_to_le32(val));\r\nreturn PCIBIOS_SUCCESSFUL;\r\ncase 2:\r\ncvmx_write64_uint16(pci_addr.u64, cpu_to_le16(val));\r\nreturn PCIBIOS_SUCCESSFUL;\r\ncase 1:\r\ncvmx_write64_uint8(pci_addr.u64, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\nstatic void octeon_pci_initialize(void)\r\n{\r\nunion cvmx_pci_cfg01 cfg01;\r\nunion cvmx_npi_ctl_status ctl_status;\r\nunion cvmx_pci_ctl_status_2 ctl_status_2;\r\nunion cvmx_pci_cfg19 cfg19;\r\nunion cvmx_pci_cfg16 cfg16;\r\nunion cvmx_pci_cfg22 cfg22;\r\nunion cvmx_pci_cfg56 cfg56;\r\ncvmx_write_csr(CVMX_CIU_SOFT_PRST, 0x1);\r\ncvmx_read_csr(CVMX_CIU_SOFT_PRST);\r\nudelay(2000);\r\nctl_status.u64 = 0;\r\nctl_status.s.max_word = 1;\r\nctl_status.s.timer = 1;\r\ncvmx_write_csr(CVMX_NPI_CTL_STATUS, ctl_status.u64);\r\ncvmx_write_csr(CVMX_CIU_SOFT_PRST, 0x4);\r\ncvmx_read_csr(CVMX_CIU_SOFT_PRST);\r\nudelay(2000);\r\nctl_status_2.u32 = 0;\r\nctl_status_2.s.tsr_hwm = 1;\r\nctl_status_2.s.bar2pres = 1;\r\nctl_status_2.s.bar2_enb = 1;\r\nctl_status_2.s.bar2_cax = 1;\r\nctl_status_2.s.bar2_esx = 1;\r\nctl_status_2.s.pmo_amod = 1;\r\nif (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_BIG) {\r\nctl_status_2.s.bb1_hole = OCTEON_PCI_BAR1_HOLE_BITS;\r\nctl_status_2.s.bb1_siz = 1;\r\nctl_status_2.s.bb_ca = 1;\r\nctl_status_2.s.bb_es = 1;\r\nctl_status_2.s.bb1 = 1;\r\nctl_status_2.s.bb0 = 1;\r\n}\r\nocteon_npi_write32(CVMX_NPI_PCI_CTL_STATUS_2, ctl_status_2.u32);\r\nudelay(2000);\r\nctl_status_2.u32 = octeon_npi_read32(CVMX_NPI_PCI_CTL_STATUS_2);\r\npr_notice("PCI Status: %s %s-bit\n",\r\nctl_status_2.s.ap_pcix ? "PCI-X" : "PCI",\r\nctl_status_2.s.ap_64ad ? "64" : "32");\r\nif (OCTEON_IS_MODEL(OCTEON_CN58XX) || OCTEON_IS_MODEL(OCTEON_CN50XX)) {\r\nunion cvmx_pci_cnt_reg cnt_reg_start;\r\nunion cvmx_pci_cnt_reg cnt_reg_end;\r\nunsigned long cycles, pci_clock;\r\ncnt_reg_start.u64 = cvmx_read_csr(CVMX_NPI_PCI_CNT_REG);\r\ncycles = read_c0_cvmcount();\r\nudelay(1000);\r\ncnt_reg_end.u64 = cvmx_read_csr(CVMX_NPI_PCI_CNT_REG);\r\ncycles = read_c0_cvmcount() - cycles;\r\npci_clock = (cnt_reg_end.s.pcicnt - cnt_reg_start.s.pcicnt) /\r\n(cycles / (mips_hpt_frequency / 1000000));\r\npr_notice("PCI Clock: %lu MHz\n", pci_clock);\r\n}\r\nif (ctl_status_2.s.ap_pcix) {\r\ncfg19.u32 = 0;\r\ncfg19.s.tdomc = 4;\r\ncfg19.s.mdrrmc = 2;\r\ncfg19.s.mrbcm = 1;\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG19, cfg19.u32);\r\n}\r\ncfg01.u32 = 0;\r\ncfg01.s.msae = 1;\r\ncfg01.s.me = 1;\r\ncfg01.s.pee = 1;\r\ncfg01.s.see = 1;\r\ncfg01.s.fbbe = 1;\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);\r\n#ifdef USE_OCTEON_INTERNAL_ARBITER\r\n{\r\nunion cvmx_npi_pci_int_arb_cfg pci_int_arb_cfg;\r\npci_int_arb_cfg.u64 = 0;\r\npci_int_arb_cfg.s.en = 1;\r\ncvmx_write_csr(CVMX_NPI_PCI_INT_ARB_CFG, pci_int_arb_cfg.u64);\r\n}\r\n#endif\r\ncfg16.u32 = 0;\r\ncfg16.s.mltd = 1;\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG16, cfg16.u32);\r\ncfg22.u32 = 0;\r\ncfg22.s.mrv = 0xff;\r\ncfg22.s.flush = 1;\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG22, cfg22.u32);\r\ncfg56.u32 = 0;\r\ncfg56.s.pxcid = 7;\r\ncfg56.s.ncp = 0xe8;\r\ncfg56.s.dpere = 1;\r\ncfg56.s.roe = 1;\r\ncfg56.s.mmbc = 1;\r\ncfg56.s.most = 3;\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG56, cfg56.u32);\r\nocteon_npi_write32(CVMX_NPI_PCI_READ_CMD_6, 0x21);\r\nocteon_npi_write32(CVMX_NPI_PCI_READ_CMD_C, 0x31);\r\nocteon_npi_write32(CVMX_NPI_PCI_READ_CMD_E, 0x31);\r\n}\r\nstatic int __init octeon_pci_setup(void)\r\n{\r\nunion cvmx_npi_mem_access_subidx mem_access;\r\nint index;\r\nif (octeon_has_feature(OCTEON_FEATURE_PCIE))\r\nreturn 0;\r\nocteon_pcibios_map_irq = octeon_pci_pcibios_map_irq;\r\nif (OCTEON_IS_MODEL(OCTEON_CN31XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN38XX_PASS2) ||\r\nOCTEON_IS_MODEL(OCTEON_CN38XX_PASS1))\r\nocteon_dma_bar_type = OCTEON_DMA_BAR_TYPE_SMALL;\r\nelse\r\nocteon_dma_bar_type = OCTEON_DMA_BAR_TYPE_BIG;\r\nset_io_port_base(OCTEON_PCI_IOSPACE_BASE);\r\nioport_resource.start = 0;\r\nioport_resource.end = OCTEON_PCI_IOSPACE_SIZE - 1;\r\nif (!octeon_is_pci_host()) {\r\npr_notice("Not in host mode, PCI Controller not initialized\n");\r\nreturn 0;\r\n}\r\npr_notice("%s Octeon big bar support\n",\r\n(octeon_dma_bar_type ==\r\nOCTEON_DMA_BAR_TYPE_BIG) ? "Enabling" : "Disabling");\r\nocteon_pci_initialize();\r\nmem_access.u64 = 0;\r\nmem_access.s.esr = 1;\r\nmem_access.s.esw = 1;\r\nmem_access.s.nsr = 0;\r\nmem_access.s.nsw = 0;\r\nmem_access.s.ror = 0;\r\nmem_access.s.row = 0;\r\nmem_access.s.ba = 0;\r\ncvmx_write_csr(CVMX_NPI_MEM_ACCESS_SUBID3, mem_access.u64);\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG08,\r\n(u32)(OCTEON_BAR2_PCI_ADDRESS & 0xffffffffull));\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG09,\r\n(u32)(OCTEON_BAR2_PCI_ADDRESS >> 32));\r\nif (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_BIG) {\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG04, 0);\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG05, 0);\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG06, 2ul << 30);\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG07, 0);\r\nocteon_bar1_pci_phys = 0x80000000ull;\r\nfor (index = 0; index < 32; index++) {\r\nunion cvmx_pci_bar1_indexx bar1_index;\r\nbar1_index.u32 = 0;\r\nbar1_index.s.addr_idx =\r\n(octeon_bar1_pci_phys >> 22) + index;\r\nbar1_index.s.ca = 1;\r\nbar1_index.s.end_swp = 1;\r\nbar1_index.s.addr_v = 1;\r\nocteon_npi_write32(CVMX_NPI_PCI_BAR1_INDEXX(index),\r\nbar1_index.u32);\r\n}\r\nocteon_pci_mem_resource.start =\r\nOCTEON_PCI_MEMSPACE_OFFSET + (4ul << 30) -\r\n(OCTEON_PCI_BAR1_HOLE_SIZE << 20);\r\nocteon_pci_mem_resource.end =\r\nocteon_pci_mem_resource.start + (1ul << 30);\r\n} else {\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG04, 128ul << 20);\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG05, 0);\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG06, 0);\r\nocteon_npi_write32(CVMX_NPI_PCI_CFG07, 0);\r\nocteon_bar1_pci_phys =\r\nvirt_to_phys(octeon_swiotlb) & ~((1ull << 22) - 1);\r\nfor (index = 0; index < 32; index++) {\r\nunion cvmx_pci_bar1_indexx bar1_index;\r\nbar1_index.u32 = 0;\r\nbar1_index.s.addr_idx =\r\n(octeon_bar1_pci_phys >> 22) + index;\r\nbar1_index.s.ca = 1;\r\nbar1_index.s.end_swp = 1;\r\nbar1_index.s.addr_v = 1;\r\nocteon_npi_write32(CVMX_NPI_PCI_BAR1_INDEXX(index),\r\nbar1_index.u32);\r\n}\r\nocteon_pci_mem_resource.start =\r\nOCTEON_PCI_MEMSPACE_OFFSET + (128ul << 20) +\r\n(4ul << 10);\r\nocteon_pci_mem_resource.end =\r\nocteon_pci_mem_resource.start + (1ul << 30);\r\n}\r\nregister_pci_controller(&octeon_pci_controller);\r\ncvmx_write_csr(CVMX_NPI_PCI_INT_SUM2, -1);\r\nif (IS_ERR(platform_device_register_simple("octeon_pci_edac",\r\n-1, NULL, 0)))\r\npr_err("Registation of co_pci_edac failed!\n");\r\nocteon_pci_dma_init();\r\nreturn 0;\r\n}
