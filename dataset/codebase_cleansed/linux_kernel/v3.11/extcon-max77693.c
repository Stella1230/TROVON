static int max77693_muic_set_debounce_time(struct max77693_muic_info *info,\r\nenum max77693_muic_adc_debounce_time time)\r\n{\r\nint ret;\r\nswitch (time) {\r\ncase ADC_DEBOUNCE_TIME_5MS:\r\ncase ADC_DEBOUNCE_TIME_10MS:\r\ncase ADC_DEBOUNCE_TIME_25MS:\r\ncase ADC_DEBOUNCE_TIME_38_62MS:\r\nret = max77693_update_reg(info->max77693->regmap_muic,\r\nMAX77693_MUIC_REG_CTRL3,\r\ntime << CONTROL3_ADCDBSET_SHIFT,\r\nCONTROL3_ADCDBSET_MASK);\r\nif (ret) {\r\ndev_err(info->dev, "failed to set ADC debounce time\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "invalid ADC debounce time\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max77693_muic_set_path(struct max77693_muic_info *info,\r\nu8 val, bool attached)\r\n{\r\nint ret = 0;\r\nu8 ctrl1, ctrl2 = 0;\r\nif (attached)\r\nctrl1 = val;\r\nelse\r\nctrl1 = CONTROL1_SW_OPEN;\r\nret = max77693_update_reg(info->max77693->regmap_muic,\r\nMAX77693_MUIC_REG_CTRL1, ctrl1, COMP_SW_MASK);\r\nif (ret < 0) {\r\ndev_err(info->dev, "failed to update MUIC register\n");\r\nreturn ret;\r\n}\r\nif (attached)\r\nctrl2 |= CONTROL2_CPEN_MASK;\r\nelse\r\nctrl2 |= CONTROL2_LOWPWR_MASK;\r\nret = max77693_update_reg(info->max77693->regmap_muic,\r\nMAX77693_MUIC_REG_CTRL2, ctrl2,\r\nCONTROL2_LOWPWR_MASK | CONTROL2_CPEN_MASK);\r\nif (ret < 0) {\r\ndev_err(info->dev, "failed to update MUIC register\n");\r\nreturn ret;\r\n}\r\ndev_info(info->dev,\r\n"CONTROL1 : 0x%02x, CONTROL2 : 0x%02x, state : %s\n",\r\nctrl1, ctrl2, attached ? "attached" : "detached");\r\nreturn 0;\r\n}\r\nstatic int max77693_muic_get_cable_type(struct max77693_muic_info *info,\r\nenum max77693_muic_cable_group group, bool *attached)\r\n{\r\nint cable_type = 0;\r\nint adc;\r\nint adc1k;\r\nint adclow;\r\nint vbvolt;\r\nint chg_type;\r\nswitch (group) {\r\ncase MAX77693_CABLE_GROUP_ADC:\r\nadc = info->status[0] & STATUS1_ADC_MASK;\r\nadc >>= STATUS1_ADC_SHIFT;\r\nif (adc == MAX77693_MUIC_ADC_OPEN) {\r\n*attached = false;\r\ncable_type = info->prev_cable_type;\r\ninfo->prev_cable_type = MAX77693_MUIC_ADC_OPEN;\r\n} else {\r\n*attached = true;\r\ncable_type = info->prev_cable_type = adc;\r\n}\r\nbreak;\r\ncase MAX77693_CABLE_GROUP_ADC_GND:\r\nadc = info->status[0] & STATUS1_ADC_MASK;\r\nadc >>= STATUS1_ADC_SHIFT;\r\nif (adc == MAX77693_MUIC_ADC_OPEN) {\r\n*attached = false;\r\ncable_type = info->prev_cable_type_gnd;\r\ninfo->prev_cable_type_gnd = MAX77693_MUIC_ADC_OPEN;\r\n} else {\r\n*attached = true;\r\nadclow = info->status[0] & STATUS1_ADCLOW_MASK;\r\nadclow >>= STATUS1_ADCLOW_SHIFT;\r\nadc1k = info->status[0] & STATUS1_ADC1K_MASK;\r\nadc1k >>= STATUS1_ADC1K_SHIFT;\r\nvbvolt = info->status[1] & STATUS2_VBVOLT_MASK;\r\nvbvolt >>= STATUS2_VBVOLT_SHIFT;\r\ncable_type = ((0x1 << 8)\r\n| (vbvolt << 2)\r\n| (adclow << 1)\r\n| adc1k);\r\ninfo->prev_cable_type = adc;\r\ninfo->prev_cable_type_gnd = cable_type;\r\n}\r\nbreak;\r\ncase MAX77693_CABLE_GROUP_CHG:\r\nchg_type = info->status[1] & STATUS2_CHGTYP_MASK;\r\nchg_type >>= STATUS2_CHGTYP_SHIFT;\r\nif (chg_type == MAX77693_CHARGER_TYPE_NONE) {\r\n*attached = false;\r\ncable_type = info->prev_chg_type;\r\ninfo->prev_chg_type = MAX77693_CHARGER_TYPE_NONE;\r\n} else {\r\n*attached = true;\r\ncable_type = info->prev_chg_type = chg_type;\r\n}\r\nbreak;\r\ncase MAX77693_CABLE_GROUP_VBVOLT:\r\nadc = info->status[0] & STATUS1_ADC_MASK;\r\nadc >>= STATUS1_ADC_SHIFT;\r\nchg_type = info->status[1] & STATUS2_CHGTYP_MASK;\r\nchg_type >>= STATUS2_CHGTYP_SHIFT;\r\nif (adc == MAX77693_MUIC_ADC_OPEN\r\n&& chg_type == MAX77693_CHARGER_TYPE_NONE)\r\n*attached = false;\r\nelse\r\n*attached = true;\r\nvbvolt = info->status[1] & STATUS2_VBVOLT_MASK;\r\nvbvolt >>= STATUS2_VBVOLT_SHIFT;\r\ncable_type = vbvolt;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "Unknown cable group (%d)\n", group);\r\ncable_type = -EINVAL;\r\nbreak;\r\n}\r\nreturn cable_type;\r\n}\r\nstatic int max77693_muic_dock_handler(struct max77693_muic_info *info,\r\nint cable_type, bool attached)\r\n{\r\nint ret = 0;\r\nint vbvolt;\r\nbool cable_attached;\r\nchar dock_name[CABLE_NAME_MAX];\r\ndev_info(info->dev,\r\n"external connector is %s (adc:0x%02x)\n",\r\nattached ? "attached" : "detached", cable_type);\r\nswitch (cable_type) {\r\ncase MAX77693_MUIC_ADC_RESERVED_ACC_3:\r\nvbvolt = max77693_muic_get_cable_type(info,\r\nMAX77693_CABLE_GROUP_VBVOLT, &cable_attached);\r\nif (attached && !vbvolt) {\r\ndev_warn(info->dev,\r\n"Cannot detect external power supply\n");\r\nreturn 0;\r\n}\r\nret = max77693_muic_set_path(info, info->path_usb, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state(info->edev, "Dock-Smart", attached);\r\nextcon_set_cable_state(info->edev, "MHL", attached);\r\ngoto out;\r\ncase MAX77693_MUIC_ADC_FACTORY_MODE_UART_ON:\r\nstrcpy(dock_name, "Dock-Car");\r\nbreak;\r\ncase MAX77693_MUIC_ADC_AUDIO_MODE_REMOTE:\r\nstrcpy(dock_name, "Dock-Desk");\r\nbreak;\r\ncase MAX77693_MUIC_ADC_AV_CABLE_NOLOAD:\r\nstrcpy(dock_name, "Dock-Audio");\r\nif (!attached)\r\nextcon_set_cable_state(info->edev, "USB", false);\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "failed to detect %s dock device\n",\r\nattached ? "attached" : "detached");\r\nreturn -EINVAL;\r\n}\r\nret = max77693_muic_set_path(info, CONTROL1_SW_AUDIO, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state(info->edev, dock_name, attached);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int max77693_muic_dock_button_handler(struct max77693_muic_info *info,\r\nint button_type, bool attached)\r\n{\r\nstruct input_dev *dock = info->dock;\r\nunsigned int code;\r\nswitch (button_type) {\r\ncase MAX77693_MUIC_ADC_REMOTE_S3_BUTTON-1\r\n... MAX77693_MUIC_ADC_REMOTE_S3_BUTTON+1:\r\ncode = KEY_PREVIOUSSONG;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_REMOTE_S7_BUTTON-1\r\n... MAX77693_MUIC_ADC_REMOTE_S7_BUTTON+1:\r\ncode = KEY_NEXTSONG;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_REMOTE_S9_BUTTON:\r\ncode = KEY_VOLUMEDOWN;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_REMOTE_S10_BUTTON:\r\ncode = KEY_VOLUMEUP;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_REMOTE_S12_BUTTON-1\r\n... MAX77693_MUIC_ADC_REMOTE_S12_BUTTON+1:\r\ncode = KEY_PLAYPAUSE;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev,\r\n"failed to detect %s key (adc:0x%x)\n",\r\nattached ? "pressed" : "released", button_type);\r\nreturn -EINVAL;\r\n}\r\ninput_event(dock, EV_KEY, code, attached);\r\ninput_sync(dock);\r\nreturn 0;\r\n}\r\nstatic int max77693_muic_adc_ground_handler(struct max77693_muic_info *info)\r\n{\r\nint cable_type_gnd;\r\nint ret = 0;\r\nbool attached;\r\ncable_type_gnd = max77693_muic_get_cable_type(info,\r\nMAX77693_CABLE_GROUP_ADC_GND, &attached);\r\nswitch (cable_type_gnd) {\r\ncase MAX77693_MUIC_GND_USB_OTG:\r\ncase MAX77693_MUIC_GND_USB_OTG_VB:\r\nret = max77693_muic_set_path(info, CONTROL1_SW_USB, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state(info->edev, "USB-Host", attached);\r\nbreak;\r\ncase MAX77693_MUIC_GND_AV_CABLE_LOAD:\r\nret = max77693_muic_set_path(info, CONTROL1_SW_AUDIO, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state(info->edev,\r\n"Audio-video-load", attached);\r\nbreak;\r\ncase MAX77693_MUIC_GND_MHL:\r\ncase MAX77693_MUIC_GND_MHL_VB:\r\nextcon_set_cable_state(info->edev, "MHL", attached);\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "failed to detect %s cable of gnd type\n",\r\nattached ? "attached" : "detached");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max77693_muic_jig_handler(struct max77693_muic_info *info,\r\nint cable_type, bool attached)\r\n{\r\nchar cable_name[32];\r\nint ret = 0;\r\nu8 path = CONTROL1_SW_OPEN;\r\ndev_info(info->dev,\r\n"external connector is %s (adc:0x%02x)\n",\r\nattached ? "attached" : "detached", cable_type);\r\nswitch (cable_type) {\r\ncase MAX77693_MUIC_ADC_FACTORY_MODE_USB_OFF:\r\nstrcpy(cable_name, "JIG-USB-OFF");\r\npath = CONTROL1_SW_USB;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_FACTORY_MODE_USB_ON:\r\nstrcpy(cable_name, "JIG-USB-ON");\r\npath = CONTROL1_SW_USB;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_FACTORY_MODE_UART_OFF:\r\nstrcpy(cable_name, "JIG-UART-OFF");\r\npath = CONTROL1_SW_UART;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "failed to detect %s jig cable\n",\r\nattached ? "attached" : "detached");\r\nreturn -EINVAL;\r\n}\r\nret = max77693_muic_set_path(info, path, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state(info->edev, cable_name, attached);\r\nreturn 0;\r\n}\r\nstatic int max77693_muic_adc_handler(struct max77693_muic_info *info)\r\n{\r\nint cable_type;\r\nint button_type;\r\nbool attached;\r\nint ret = 0;\r\ncable_type = max77693_muic_get_cable_type(info,\r\nMAX77693_CABLE_GROUP_ADC, &attached);\r\ndev_info(info->dev,\r\n"external connector is %s (adc:0x%02x, prev_adc:0x%x)\n",\r\nattached ? "attached" : "detached", cable_type,\r\ninfo->prev_cable_type);\r\nswitch (cable_type) {\r\ncase MAX77693_MUIC_ADC_GROUND:\r\nmax77693_muic_adc_ground_handler(info);\r\nbreak;\r\ncase MAX77693_MUIC_ADC_FACTORY_MODE_USB_OFF:\r\ncase MAX77693_MUIC_ADC_FACTORY_MODE_USB_ON:\r\ncase MAX77693_MUIC_ADC_FACTORY_MODE_UART_OFF:\r\nret = max77693_muic_jig_handler(info, cable_type, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_RESERVED_ACC_3:\r\ncase MAX77693_MUIC_ADC_FACTORY_MODE_UART_ON:\r\ncase MAX77693_MUIC_ADC_AUDIO_MODE_REMOTE:\r\ncase MAX77693_MUIC_ADC_AV_CABLE_NOLOAD:\r\nret = max77693_muic_dock_handler(info, cable_type, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_REMOTE_S3_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S7_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S9_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S10_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S12_BUTTON:\r\nif (attached)\r\nbutton_type = info->prev_button_type = cable_type;\r\nelse\r\nbutton_type = info->prev_button_type;\r\nret = max77693_muic_dock_button_handler(info, button_type,\r\nattached);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase MAX77693_MUIC_ADC_SEND_END_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S1_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S2_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S4_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S5_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S6_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S8_BUTTON:\r\ncase MAX77693_MUIC_ADC_REMOTE_S11_BUTTON:\r\ncase MAX77693_MUIC_ADC_RESERVED_ACC_1:\r\ncase MAX77693_MUIC_ADC_RESERVED_ACC_2:\r\ncase MAX77693_MUIC_ADC_RESERVED_ACC_4:\r\ncase MAX77693_MUIC_ADC_RESERVED_ACC_5:\r\ncase MAX77693_MUIC_ADC_CEA936_AUDIO:\r\ncase MAX77693_MUIC_ADC_PHONE_POWERED_DEV:\r\ncase MAX77693_MUIC_ADC_TTY_CONVERTER:\r\ncase MAX77693_MUIC_ADC_UART_CABLE:\r\ncase MAX77693_MUIC_ADC_CEA936A_TYPE1_CHG:\r\ncase MAX77693_MUIC_ADC_CEA936A_TYPE2_CHG:\r\ndev_info(info->dev,\r\n"accessory is %s but it isn't used (adc:0x%x)\n",\r\nattached ? "attached" : "detached", cable_type);\r\nreturn -EAGAIN;\r\ndefault:\r\ndev_err(info->dev,\r\n"failed to detect %s accessory (adc:0x%x)\n",\r\nattached ? "attached" : "detached", cable_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max77693_muic_chg_handler(struct max77693_muic_info *info)\r\n{\r\nint chg_type;\r\nint cable_type_gnd;\r\nint cable_type;\r\nbool attached;\r\nbool cable_attached;\r\nint ret = 0;\r\nchg_type = max77693_muic_get_cable_type(info,\r\nMAX77693_CABLE_GROUP_CHG, &attached);\r\ndev_info(info->dev,\r\n"external connector is %s(chg_type:0x%x, prev_chg_type:0x%x)\n",\r\nattached ? "attached" : "detached",\r\nchg_type, info->prev_chg_type);\r\nswitch (chg_type) {\r\ncase MAX77693_CHARGER_TYPE_USB:\r\ncase MAX77693_CHARGER_TYPE_DEDICATED_CHG:\r\ncase MAX77693_CHARGER_TYPE_NONE:\r\ncable_type_gnd = max77693_muic_get_cable_type(info,\r\nMAX77693_CABLE_GROUP_ADC_GND,\r\n&cable_attached);\r\nswitch (cable_type_gnd) {\r\ncase MAX77693_MUIC_GND_MHL:\r\ncase MAX77693_MUIC_GND_MHL_VB:\r\nextcon_set_cable_state(info->edev, "MHL_TA", attached);\r\nif (!cable_attached)\r\nextcon_set_cable_state(info->edev, "MHL", cable_attached);\r\nbreak;\r\n}\r\ncable_type = max77693_muic_get_cable_type(info,\r\nMAX77693_CABLE_GROUP_ADC,\r\n&cable_attached);\r\nswitch (cable_type) {\r\ncase MAX77693_MUIC_ADC_AV_CABLE_NOLOAD:\r\nextcon_set_cable_state(info->edev, "USB", attached);\r\nif (!cable_attached)\r\nextcon_set_cable_state(info->edev, "Dock-Audio", cable_attached);\r\nbreak;\r\ncase MAX77693_MUIC_ADC_RESERVED_ACC_3:\r\nret = max77693_muic_set_path(info, info->path_usb, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state(info->edev, "Dock-Smart", attached);\r\nextcon_set_cable_state(info->edev, "MHL", attached);\r\nbreak;\r\n}\r\nswitch (chg_type) {\r\ncase MAX77693_CHARGER_TYPE_NONE:\r\nbreak;\r\ncase MAX77693_CHARGER_TYPE_USB:\r\nret = max77693_muic_set_path(info, info->path_usb, attached);\r\nif (ret < 0)\r\nreturn ret;\r\nextcon_set_cable_state(info->edev, "USB", attached);\r\nbreak;\r\ncase MAX77693_CHARGER_TYPE_DEDICATED_CHG:\r\nextcon_set_cable_state(info->edev, "TA", attached);\r\nbreak;\r\n}\r\nbreak;\r\ncase MAX77693_CHARGER_TYPE_DOWNSTREAM_PORT:\r\nextcon_set_cable_state(info->edev,\r\n"Charge-downstream", attached);\r\nbreak;\r\ncase MAX77693_CHARGER_TYPE_APPLE_500MA:\r\nextcon_set_cable_state(info->edev, "Slow-charger", attached);\r\nbreak;\r\ncase MAX77693_CHARGER_TYPE_APPLE_1A_2A:\r\nextcon_set_cable_state(info->edev, "Fast-charger", attached);\r\nbreak;\r\ncase MAX77693_CHARGER_TYPE_DEAD_BATTERY:\r\nbreak;\r\ndefault:\r\ndev_err(info->dev,\r\n"failed to detect %s accessory (chg_type:0x%x)\n",\r\nattached ? "attached" : "detached", chg_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void max77693_muic_irq_work(struct work_struct *work)\r\n{\r\nstruct max77693_muic_info *info = container_of(work,\r\nstruct max77693_muic_info, irq_work);\r\nint irq_type = -1;\r\nint i, ret = 0;\r\nif (!info->edev)\r\nreturn;\r\nmutex_lock(&info->mutex);\r\nfor (i = 0 ; i < ARRAY_SIZE(muic_irqs) ; i++)\r\nif (info->irq == muic_irqs[i].virq)\r\nirq_type = muic_irqs[i].irq;\r\nret = max77693_bulk_read(info->max77693->regmap_muic,\r\nMAX77693_MUIC_REG_STATUS1, 2, info->status);\r\nif (ret) {\r\ndev_err(info->dev, "failed to read MUIC register\n");\r\nmutex_unlock(&info->mutex);\r\nreturn;\r\n}\r\nswitch (irq_type) {\r\ncase MAX77693_MUIC_IRQ_INT1_ADC:\r\ncase MAX77693_MUIC_IRQ_INT1_ADC_LOW:\r\ncase MAX77693_MUIC_IRQ_INT1_ADC_ERR:\r\ncase MAX77693_MUIC_IRQ_INT1_ADC1K:\r\nret = max77693_muic_adc_handler(info);\r\nbreak;\r\ncase MAX77693_MUIC_IRQ_INT2_CHGTYP:\r\ncase MAX77693_MUIC_IRQ_INT2_CHGDETREUN:\r\ncase MAX77693_MUIC_IRQ_INT2_DCDTMR:\r\ncase MAX77693_MUIC_IRQ_INT2_DXOVP:\r\ncase MAX77693_MUIC_IRQ_INT2_VBVOLT:\r\ncase MAX77693_MUIC_IRQ_INT2_VIDRM:\r\nret = max77693_muic_chg_handler(info);\r\nbreak;\r\ncase MAX77693_MUIC_IRQ_INT3_EOC:\r\ncase MAX77693_MUIC_IRQ_INT3_CGMBC:\r\ncase MAX77693_MUIC_IRQ_INT3_OVP:\r\ncase MAX77693_MUIC_IRQ_INT3_MBCCHG_ERR:\r\ncase MAX77693_MUIC_IRQ_INT3_CHG_ENABLED:\r\ncase MAX77693_MUIC_IRQ_INT3_BAT_DET:\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "muic interrupt: irq %d occurred\n",\r\nirq_type);\r\nmutex_unlock(&info->mutex);\r\nreturn;\r\n}\r\nif (ret < 0)\r\ndev_err(info->dev, "failed to handle MUIC interrupt\n");\r\nmutex_unlock(&info->mutex);\r\nreturn;\r\n}\r\nstatic irqreturn_t max77693_muic_irq_handler(int irq, void *data)\r\n{\r\nstruct max77693_muic_info *info = data;\r\ninfo->irq = irq;\r\nschedule_work(&info->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max77693_muic_detect_accessory(struct max77693_muic_info *info)\r\n{\r\nint ret = 0;\r\nint adc;\r\nint chg_type;\r\nbool attached;\r\nmutex_lock(&info->mutex);\r\nret = max77693_bulk_read(info->max77693->regmap_muic,\r\nMAX77693_MUIC_REG_STATUS1, 2, info->status);\r\nif (ret) {\r\ndev_err(info->dev, "failed to read MUIC register\n");\r\nmutex_unlock(&info->mutex);\r\nreturn ret;\r\n}\r\nadc = max77693_muic_get_cable_type(info, MAX77693_CABLE_GROUP_ADC,\r\n&attached);\r\nif (attached && adc != MAX77693_MUIC_ADC_OPEN) {\r\nret = max77693_muic_adc_handler(info);\r\nif (ret < 0) {\r\ndev_err(info->dev, "Cannot detect accessory\n");\r\nmutex_unlock(&info->mutex);\r\nreturn ret;\r\n}\r\n}\r\nchg_type = max77693_muic_get_cable_type(info, MAX77693_CABLE_GROUP_CHG,\r\n&attached);\r\nif (attached && chg_type != MAX77693_CHARGER_TYPE_NONE) {\r\nret = max77693_muic_chg_handler(info);\r\nif (ret < 0) {\r\ndev_err(info->dev, "Cannot detect charger accessory\n");\r\nmutex_unlock(&info->mutex);\r\nreturn ret;\r\n}\r\n}\r\nmutex_unlock(&info->mutex);\r\nreturn 0;\r\n}\r\nstatic void max77693_muic_detect_cable_wq(struct work_struct *work)\r\n{\r\nstruct max77693_muic_info *info = container_of(to_delayed_work(work),\r\nstruct max77693_muic_info, wq_detcable);\r\nmax77693_muic_detect_accessory(info);\r\n}\r\nstatic int max77693_muic_probe(struct platform_device *pdev)\r\n{\r\nstruct max77693_dev *max77693 = dev_get_drvdata(pdev->dev.parent);\r\nstruct max77693_platform_data *pdata = dev_get_platdata(max77693->dev);\r\nstruct max77693_muic_info *info;\r\nstruct max77693_reg_data *init_data;\r\nint num_init_data;\r\nint delay_jiffies;\r\nint ret;\r\nint i;\r\nu8 id;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(struct max77693_muic_info),\r\nGFP_KERNEL);\r\nif (!info) {\r\ndev_err(&pdev->dev, "failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->dev = &pdev->dev;\r\ninfo->max77693 = max77693;\r\nif (info->max77693->regmap_muic) {\r\ndev_dbg(&pdev->dev, "allocate register map\n");\r\n} else {\r\ninfo->max77693->regmap_muic = devm_regmap_init_i2c(\r\ninfo->max77693->muic,\r\n&max77693_muic_regmap_config);\r\nif (IS_ERR(info->max77693->regmap_muic)) {\r\nret = PTR_ERR(info->max77693->regmap_muic);\r\ndev_err(max77693->dev,\r\n"failed to allocate register map: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\ninfo->dock = devm_input_allocate_device(&pdev->dev);\r\nif (!info->dock) {\r\ndev_err(&pdev->dev, "%s: failed to allocate input\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ninfo->dock->name = "max77693-muic/dock";\r\ninfo->dock->phys = "max77693-muic/extcon";\r\ninfo->dock->dev.parent = &pdev->dev;\r\n__set_bit(EV_REP, info->dock->evbit);\r\ninput_set_capability(info->dock, EV_KEY, KEY_VOLUMEUP);\r\ninput_set_capability(info->dock, EV_KEY, KEY_VOLUMEDOWN);\r\ninput_set_capability(info->dock, EV_KEY, KEY_PLAYPAUSE);\r\ninput_set_capability(info->dock, EV_KEY, KEY_PREVIOUSSONG);\r\ninput_set_capability(info->dock, EV_KEY, KEY_NEXTSONG);\r\nret = input_register_device(info->dock);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Cannot register input device error(%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nmutex_init(&info->mutex);\r\nINIT_WORK(&info->irq_work, max77693_muic_irq_work);\r\nfor (i = 0; i < ARRAY_SIZE(muic_irqs); i++) {\r\nstruct max77693_muic_irq *muic_irq = &muic_irqs[i];\r\nunsigned int virq = 0;\r\nvirq = irq_create_mapping(max77693->irq_domain, muic_irq->irq);\r\nif (!virq) {\r\nret = -EINVAL;\r\ngoto err_irq;\r\n}\r\nmuic_irq->virq = virq;\r\nret = request_threaded_irq(virq, NULL,\r\nmax77693_muic_irq_handler,\r\nIRQF_NO_SUSPEND,\r\nmuic_irq->name, info);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed: irq request (IRQ: %d,"\r\n" error :%d)\n",\r\nmuic_irq->irq, ret);\r\ngoto err_irq;\r\n}\r\n}\r\ninfo->edev = devm_kzalloc(&pdev->dev, sizeof(struct extcon_dev),\r\nGFP_KERNEL);\r\nif (!info->edev) {\r\ndev_err(&pdev->dev, "failed to allocate memory for extcon\n");\r\nret = -ENOMEM;\r\ngoto err_irq;\r\n}\r\ninfo->edev->name = DEV_NAME;\r\ninfo->edev->supported_cable = max77693_extcon_cable;\r\nret = extcon_dev_register(info->edev, NULL);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register extcon device\n");\r\ngoto err_irq;\r\n}\r\nif (pdata->muic_data) {\r\ninit_data = pdata->muic_data->init_data;\r\nnum_init_data = pdata->muic_data->num_init_data;\r\n} else {\r\ninit_data = default_init_data;\r\nnum_init_data = ARRAY_SIZE(default_init_data);\r\n}\r\nfor (i = 0 ; i < num_init_data ; i++) {\r\nenum max77693_irq_source irq_src\r\n= MAX77693_IRQ_GROUP_NR;\r\nmax77693_write_reg(info->max77693->regmap_muic,\r\ninit_data[i].addr,\r\ninit_data[i].data);\r\nswitch (init_data[i].addr) {\r\ncase MAX77693_MUIC_REG_INTMASK1:\r\nirq_src = MUIC_INT1;\r\nbreak;\r\ncase MAX77693_MUIC_REG_INTMASK2:\r\nirq_src = MUIC_INT2;\r\nbreak;\r\ncase MAX77693_MUIC_REG_INTMASK3:\r\nirq_src = MUIC_INT3;\r\nbreak;\r\n}\r\nif (irq_src < MAX77693_IRQ_GROUP_NR)\r\ninfo->max77693->irq_masks_cur[irq_src]\r\n= init_data[i].data;\r\n}\r\nif (pdata->muic_data) {\r\nstruct max77693_muic_platform_data *muic_pdata = pdata->muic_data;\r\nif (muic_pdata->path_uart)\r\ninfo->path_uart = muic_pdata->path_uart;\r\nelse\r\ninfo->path_uart = CONTROL1_SW_UART;\r\nif (muic_pdata->path_usb)\r\ninfo->path_usb = muic_pdata->path_usb;\r\nelse\r\ninfo->path_usb = CONTROL1_SW_USB;\r\nif (muic_pdata->detcable_delay_ms)\r\ndelay_jiffies =\r\nmsecs_to_jiffies(muic_pdata->detcable_delay_ms);\r\nelse\r\ndelay_jiffies = msecs_to_jiffies(DELAY_MS_DEFAULT);\r\n} else {\r\ninfo->path_usb = CONTROL1_SW_USB;\r\ninfo->path_uart = CONTROL1_SW_UART;\r\ndelay_jiffies = msecs_to_jiffies(DELAY_MS_DEFAULT);\r\n}\r\nmax77693_muic_set_path(info, info->path_uart, true);\r\nret = max77693_read_reg(info->max77693->regmap_muic,\r\nMAX77693_MUIC_REG_ID, &id);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to read revision number\n");\r\ngoto err_extcon;\r\n}\r\ndev_info(info->dev, "device ID : 0x%x\n", id);\r\nmax77693_muic_set_debounce_time(info, ADC_DEBOUNCE_TIME_25MS);\r\nINIT_DELAYED_WORK(&info->wq_detcable, max77693_muic_detect_cable_wq);\r\nschedule_delayed_work(&info->wq_detcable, delay_jiffies);\r\nreturn ret;\r\nerr_extcon:\r\nextcon_dev_unregister(info->edev);\r\nerr_irq:\r\nwhile (--i >= 0)\r\nfree_irq(muic_irqs[i].virq, info);\r\nreturn ret;\r\n}\r\nstatic int max77693_muic_remove(struct platform_device *pdev)\r\n{\r\nstruct max77693_muic_info *info = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(muic_irqs); i++)\r\nfree_irq(muic_irqs[i].virq, info);\r\ncancel_work_sync(&info->irq_work);\r\ninput_unregister_device(info->dock);\r\nextcon_dev_unregister(info->edev);\r\nreturn 0;\r\n}
