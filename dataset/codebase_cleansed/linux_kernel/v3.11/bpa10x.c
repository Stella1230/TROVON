static int bpa10x_recv(struct hci_dev *hdev, int queue, void *buf, int count)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s queue %d buffer %p count %d", hdev->name,\r\nqueue, buf, count);\r\nif (queue < 0 || queue > 1)\r\nreturn -EILSEQ;\r\nhdev->stat.byte_rx += count;\r\nwhile (count) {\r\nstruct sk_buff *skb = data->rx_skb[queue];\r\nstruct { __u8 type; int expect; } *scb;\r\nint type, len = 0;\r\nif (!skb) {\r\ntype = *((__u8 *) buf);\r\ncount--; buf++;\r\nswitch (type) {\r\ncase HCI_EVENT_PKT:\r\nif (count >= HCI_EVENT_HDR_SIZE) {\r\nstruct hci_event_hdr *h = buf;\r\nlen = HCI_EVENT_HDR_SIZE + h->plen;\r\n} else\r\nreturn -EILSEQ;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nif (count >= HCI_ACL_HDR_SIZE) {\r\nstruct hci_acl_hdr *h = buf;\r\nlen = HCI_ACL_HDR_SIZE +\r\n__le16_to_cpu(h->dlen);\r\n} else\r\nreturn -EILSEQ;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nif (count >= HCI_SCO_HDR_SIZE) {\r\nstruct hci_sco_hdr *h = buf;\r\nlen = HCI_SCO_HDR_SIZE + h->dlen;\r\n} else\r\nreturn -EILSEQ;\r\nbreak;\r\ncase HCI_VENDOR_PKT:\r\nif (count >= HCI_VENDOR_HDR_SIZE) {\r\nstruct hci_vendor_hdr *h = buf;\r\nlen = HCI_VENDOR_HDR_SIZE +\r\n__le16_to_cpu(h->dlen);\r\n} else\r\nreturn -EILSEQ;\r\nbreak;\r\n}\r\nskb = bt_skb_alloc(len, GFP_ATOMIC);\r\nif (!skb) {\r\nBT_ERR("%s no memory for packet", hdev->name);\r\nreturn -ENOMEM;\r\n}\r\nskb->dev = (void *) hdev;\r\ndata->rx_skb[queue] = skb;\r\nscb = (void *) skb->cb;\r\nscb->type = type;\r\nscb->expect = len;\r\n} else {\r\nscb = (void *) skb->cb;\r\nlen = scb->expect;\r\n}\r\nlen = min(len, count);\r\nmemcpy(skb_put(skb, len), buf, len);\r\nscb->expect -= len;\r\nif (scb->expect == 0) {\r\ndata->rx_skb[queue] = NULL;\r\nbt_cb(skb)->pkt_type = scb->type;\r\nhci_recv_frame(skb);\r\n}\r\ncount -= len; buf += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bpa10x_tx_complete(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = urb->context;\r\nstruct hci_dev *hdev = (struct hci_dev *) skb->dev;\r\nBT_DBG("%s urb %p status %d count %d", hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\ngoto done;\r\nif (!urb->status)\r\nhdev->stat.byte_tx += urb->transfer_buffer_length;\r\nelse\r\nhdev->stat.err_tx++;\r\ndone:\r\nkfree(urb->setup_packet);\r\nkfree_skb(skb);\r\n}\r\nstatic void bpa10x_rx_complete(struct urb *urb)\r\n{\r\nstruct hci_dev *hdev = urb->context;\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s urb %p status %d count %d", hdev->name,\r\nurb, urb->status, urb->actual_length);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn;\r\nif (urb->status == 0) {\r\nif (bpa10x_recv(hdev, usb_pipebulk(urb->pipe),\r\nurb->transfer_buffer,\r\nurb->actual_length) < 0) {\r\nBT_ERR("%s corrupted event packet", hdev->name);\r\nhdev->stat.err_rx++;\r\n}\r\n}\r\nusb_anchor_urb(urb, &data->rx_anchor);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nBT_ERR("%s urb %p failed to resubmit (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\n}\r\nstatic inline int bpa10x_submit_intr_urb(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nstruct urb *urb;\r\nunsigned char *buf;\r\nunsigned int pipe;\r\nint err, size = 16;\r\nBT_DBG("%s", hdev->name);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvintpipe(data->udev, 0x81);\r\nusb_fill_int_urb(urb, data->udev, pipe, buf, size,\r\nbpa10x_rx_complete, hdev, 1);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nusb_anchor_urb(urb, &data->rx_anchor);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err < 0) {\r\nBT_ERR("%s urb %p submission failed (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic inline int bpa10x_submit_bulk_urb(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nstruct urb *urb;\r\nunsigned char *buf;\r\nunsigned int pipe;\r\nint err, size = 64;\r\nBT_DBG("%s", hdev->name);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvbulkpipe(data->udev, 0x82);\r\nusb_fill_bulk_urb(urb, data->udev, pipe,\r\nbuf, size, bpa10x_rx_complete, hdev);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nusb_anchor_urb(urb, &data->rx_anchor);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err < 0) {\r\nBT_ERR("%s urb %p submission failed (%d)",\r\nhdev->name, urb, -err);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic int bpa10x_open(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (test_and_set_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nerr = bpa10x_submit_intr_urb(hdev);\r\nif (err < 0)\r\ngoto error;\r\nerr = bpa10x_submit_bulk_urb(hdev);\r\nif (err < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nusb_kill_anchored_urbs(&data->rx_anchor);\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nreturn err;\r\n}\r\nstatic int bpa10x_close(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s", hdev->name);\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nusb_kill_anchored_urbs(&data->rx_anchor);\r\nreturn 0;\r\n}\r\nstatic int bpa10x_flush(struct hci_dev *hdev)\r\n{\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s", hdev->name);\r\nusb_kill_anchored_urbs(&data->tx_anchor);\r\nreturn 0;\r\n}\r\nstatic int bpa10x_send_frame(struct sk_buff *skb)\r\n{\r\nstruct hci_dev *hdev = (struct hci_dev *) skb->dev;\r\nstruct bpa10x_data *data = hci_get_drvdata(hdev);\r\nstruct usb_ctrlrequest *dr;\r\nstruct urb *urb;\r\nunsigned int pipe;\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\nreturn -ENOMEM;\r\n*skb_push(skb, 1) = bt_cb(skb)->pkt_type;\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\ndr = kmalloc(sizeof(*dr), GFP_ATOMIC);\r\nif (!dr) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\ndr->bRequestType = USB_TYPE_VENDOR;\r\ndr->bRequest = 0;\r\ndr->wIndex = 0;\r\ndr->wValue = 0;\r\ndr->wLength = __cpu_to_le16(skb->len);\r\npipe = usb_sndctrlpipe(data->udev, 0x00);\r\nusb_fill_control_urb(urb, data->udev, pipe, (void *) dr,\r\nskb->data, skb->len, bpa10x_tx_complete, skb);\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\npipe = usb_sndbulkpipe(data->udev, 0x02);\r\nusb_fill_bulk_urb(urb, data->udev, pipe,\r\nskb->data, skb->len, bpa10x_tx_complete, skb);\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\npipe = usb_sndbulkpipe(data->udev, 0x02);\r\nusb_fill_bulk_urb(urb, data->udev, pipe,\r\nskb->data, skb->len, bpa10x_tx_complete, skb);\r\nhdev->stat.sco_tx++;\r\nbreak;\r\ndefault:\r\nusb_free_urb(urb);\r\nreturn -EILSEQ;\r\n}\r\nusb_anchor_urb(urb, &data->tx_anchor);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nBT_ERR("%s urb %p submission failed", hdev->name, urb);\r\nkfree(urb->setup_packet);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\nreturn 0;\r\n}\r\nstatic int bpa10x_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct bpa10x_data *data;\r\nstruct hci_dev *hdev;\r\nint err;\r\nBT_DBG("intf %p id %p", intf, id);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->udev = interface_to_usbdev(intf);\r\ninit_usb_anchor(&data->tx_anchor);\r\ninit_usb_anchor(&data->rx_anchor);\r\nhdev = hci_alloc_dev();\r\nif (!hdev)\r\nreturn -ENOMEM;\r\nhdev->bus = HCI_USB;\r\nhci_set_drvdata(hdev, data);\r\ndata->hdev = hdev;\r\nSET_HCIDEV_DEV(hdev, &intf->dev);\r\nhdev->open = bpa10x_open;\r\nhdev->close = bpa10x_close;\r\nhdev->flush = bpa10x_flush;\r\nhdev->send = bpa10x_send_frame;\r\nset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\r\nerr = hci_register_dev(hdev);\r\nif (err < 0) {\r\nhci_free_dev(hdev);\r\nreturn err;\r\n}\r\nusb_set_intfdata(intf, data);\r\nreturn 0;\r\n}\r\nstatic void bpa10x_disconnect(struct usb_interface *intf)\r\n{\r\nstruct bpa10x_data *data = usb_get_intfdata(intf);\r\nBT_DBG("intf %p", intf);\r\nif (!data)\r\nreturn;\r\nusb_set_intfdata(intf, NULL);\r\nhci_unregister_dev(data->hdev);\r\nhci_free_dev(data->hdev);\r\nkfree_skb(data->rx_skb[0]);\r\nkfree_skb(data->rx_skb[1]);\r\n}
