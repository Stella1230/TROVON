s32 send_set_req(struct poseidon *pd, u8 cmdid, s32 param, s32 *cmd_status)\r\n{\r\ns32 ret;\r\ns8 data[32] = {};\r\nu16 lower_16, upper_16;\r\nif (pd->state & POSEIDON_STATE_DISCONNECT)\r\nreturn -ENODEV;\r\nmdelay(30);\r\nif (param == 0) {\r\nupper_16 = lower_16 = 0;\r\n} else {\r\nlower_16 = (unsigned short)(param & 0xffff);\r\nupper_16 = (unsigned short)((param >> 16) & 0xffff);\r\n}\r\nret = usb_control_msg(pd->udev,\r\nusb_rcvctrlpipe(pd->udev, 0),\r\nREQ_SET_CMD | cmdid,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nlower_16,\r\nupper_16,\r\n&data,\r\nsizeof(*cmd_status),\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (!ret) {\r\nreturn -ENXIO;\r\n} else {\r\nmemcpy((char *)cmd_status, &(data[0]), sizeof(*cmd_status));\r\n}\r\nreturn 0;\r\n}\r\ns32 send_get_req(struct poseidon *pd, u8 cmdid, s32 param,\r\nvoid *buf, s32 *cmd_status, s32 datalen)\r\n{\r\ns32 ret;\r\ns8 data[128] = {};\r\nu16 lower_16, upper_16;\r\nif (pd->state & POSEIDON_STATE_DISCONNECT)\r\nreturn -ENODEV;\r\nmdelay(30);\r\nif (param == 0) {\r\nupper_16 = lower_16 = 0;\r\n} else {\r\nlower_16 = (unsigned short)(param & 0xffff);\r\nupper_16 = (unsigned short)((param >> 16) & 0xffff);\r\n}\r\nret = usb_control_msg(pd->udev,\r\nusb_rcvctrlpipe(pd->udev, 0),\r\nREQ_GET_CMD | cmdid,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nlower_16,\r\nupper_16,\r\n&data,\r\n(datalen + sizeof(*cmd_status)),\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (ret < 0) {\r\nreturn -ENXIO;\r\n} else {\r\nmemcpy((char *)cmd_status, &data[0], sizeof(*cmd_status));\r\nmemcpy((char *)buf, &data[sizeof(*cmd_status)], datalen);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm_notifier_block(struct notifier_block *nb,\r\nunsigned long event, void *dummy)\r\n{\r\nstruct poseidon *pd = NULL;\r\nstruct list_head *node, *next;\r\nswitch (event) {\r\ncase PM_POST_HIBERNATION:\r\nlist_for_each_safe(node, next, &pd_device_list) {\r\nstruct usb_device *udev;\r\nstruct usb_interface *iface;\r\nint rc = 0;\r\npd = container_of(node, struct poseidon, device_list);\r\nudev = pd->udev;\r\niface = pd->interface;\r\nrc = usb_lock_device_for_reset(udev, iface);\r\nif (rc >= 0) {\r\nusb_reset_device(udev);\r\nusb_unlock_device(udev);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlog("event :%ld\n", event);\r\nreturn 0;\r\n}\r\nint set_tuner_mode(struct poseidon *pd, unsigned char mode)\r\n{\r\ns32 ret, cmd_status;\r\nif (pd->state & POSEIDON_STATE_DISCONNECT)\r\nreturn -ENODEV;\r\nret = send_set_req(pd, TUNE_MODE_SELECT, mode, &cmd_status);\r\nif (ret || cmd_status)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nvoid poseidon_delete(struct kref *kref)\r\n{\r\nstruct poseidon *pd = container_of(kref, struct poseidon, kref);\r\nif (!pd)\r\nreturn;\r\nlist_del_init(&pd->device_list);\r\npd_dvb_usb_device_cleanup(pd);\r\nif (pd->udev) {\r\nusb_put_dev(pd->udev);\r\npd->udev = NULL;\r\n}\r\nif (pd->interface) {\r\nusb_put_intf(pd->interface);\r\npd->interface = NULL;\r\n}\r\nkfree(pd);\r\nlog();\r\n}\r\nstatic int firmware_download(struct usb_device *udev)\r\n{\r\nint ret = 0, actual_length;\r\nconst struct firmware *fw = NULL;\r\nvoid *fwbuf = NULL;\r\nsize_t fwlength = 0, offset;\r\nsize_t max_packet_size;\r\nret = request_firmware(&fw, firmware_name, &udev->dev);\r\nif (ret) {\r\nlog("download err : %d", ret);\r\nreturn ret;\r\n}\r\nfwlength = fw->size;\r\nfwbuf = kmemdup(fw->data, fwlength, GFP_KERNEL);\r\nif (!fwbuf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmax_packet_size = udev->ep_out[0x1]->desc.wMaxPacketSize;\r\nlog("\t\t download size : %d", (int)max_packet_size);\r\nfor (offset = 0; offset < fwlength; offset += max_packet_size) {\r\nactual_length = 0;\r\nret = usb_bulk_msg(udev,\r\nusb_sndbulkpipe(udev, 0x01),\r\nfwbuf + offset,\r\nmin(max_packet_size, fwlength - offset),\r\n&actual_length,\r\nHZ * 10);\r\nif (ret)\r\nbreak;\r\n}\r\nkfree(fwbuf);\r\nout:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic inline struct poseidon *get_pd(struct usb_interface *intf)\r\n{\r\nreturn usb_get_intfdata(intf);\r\n}\r\nstatic inline void set_map_flags(struct poseidon *pd, struct usb_device *udev)\r\n{\r\npd->portnum = udev->portnum;\r\n}\r\nstatic inline int get_autopm_ref(struct poseidon *pd)\r\n{\r\nreturn pd->video_data.users + pd->vbi_data.users + pd->audio.users\r\n+ atomic_read(&pd->dvb_data.users) +\r\n!list_empty(&pd->radio_data.fm_dev.fh_list);\r\n}\r\nstatic inline struct poseidon *fixup(struct poseidon *pd)\r\n{\r\nint count;\r\ncount = get_autopm_ref(pd);\r\nlog("count : %d, ref count : %d", count, get_pm_count(pd));\r\nwhile (count--)\r\nusb_autopm_put_interface(pd->interface);\r\nusb_put_dev(pd->udev);\r\nusb_put_intf(pd->interface);\r\nlog("event : %d\n", pd->msg.event);\r\nreturn pd;\r\n}\r\nstatic struct poseidon *find_old_poseidon(struct usb_device *udev)\r\n{\r\nstruct poseidon *pd;\r\nlist_for_each_entry(pd, &pd_device_list, device_list) {\r\nif (pd->portnum == udev->portnum && in_hibernation(pd))\r\nreturn fixup(pd);\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int is_working(struct poseidon *pd)\r\n{\r\nreturn get_pm_count(pd) > 0;\r\n}\r\nstatic int poseidon_suspend(struct usb_interface *intf, pm_message_t msg)\r\n{\r\nstruct poseidon *pd = get_pd(intf);\r\nif (!pd)\r\nreturn 0;\r\nif (!is_working(pd)) {\r\nif (get_pm_count(pd) <= 0 && !in_hibernation(pd)) {\r\npd->msg.event = PM_EVENT_AUTO_SUSPEND;\r\npd->pm_resume = NULL;\r\nprintk(KERN_DEBUG "TLG2300 auto suspend\n");\r\n}\r\nreturn 0;\r\n}\r\npd->msg = msg;\r\nlogpm(pd);\r\nreturn pd->pm_suspend ? pd->pm_suspend(pd) : 0;\r\n}\r\nstatic int poseidon_resume(struct usb_interface *intf)\r\n{\r\nstruct poseidon *pd = get_pd(intf);\r\nif (!pd)\r\nreturn 0;\r\nprintk(KERN_DEBUG "TLG2300 resume\n");\r\nif (!is_working(pd)) {\r\nif (PM_EVENT_AUTO_SUSPEND == pd->msg.event)\r\npd->msg = PMSG_ON;\r\nreturn 0;\r\n}\r\nif (in_hibernation(pd)) {\r\nlogpm(pd);\r\nreturn 0;\r\n}\r\nlogpm(pd);\r\nreturn pd->pm_resume ? pd->pm_resume(pd) : 0;\r\n}\r\nstatic void hibernation_resume(struct work_struct *w)\r\n{\r\nstruct poseidon *pd = container_of(w, struct poseidon, pm_work);\r\nint count;\r\npd->msg.event = 0;\r\npd->state &= ~POSEIDON_STATE_DISCONNECT;\r\ncount = get_autopm_ref(pd);\r\nwhile (count--)\r\nusb_autopm_get_interface(pd->interface);\r\nlogpm(pd);\r\nif (pd->pm_resume)\r\npd->pm_resume(pd);\r\n}\r\nstatic inline struct poseidon *find_old_poseidon(struct usb_device *udev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic inline void set_map_flags(struct poseidon *pd, struct usb_device *udev)\r\n{\r\n}\r\nstatic int check_firmware(struct usb_device *udev, int *down_firmware)\r\n{\r\nvoid *buf;\r\nint ret;\r\nstruct cmd_firmware_vers_s *cmd_firm;\r\nbuf = kzalloc(sizeof(*cmd_firm) + sizeof(u32), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, 0),\r\nREQ_GET_CMD | GET_FW_ID,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\n0,\r\nbuf,\r\nsizeof(*cmd_firm) + sizeof(u32),\r\nUSB_CTRL_GET_TIMEOUT);\r\nkfree(buf);\r\nif (ret < 0) {\r\n*down_firmware = 1;\r\nreturn firmware_download(udev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int poseidon_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct poseidon *pd = NULL;\r\nint ret = 0;\r\nint new_one = 0;\r\ncheck_firmware(udev, &ret);\r\nif (ret)\r\nreturn 0;\r\npd = find_old_poseidon(udev);\r\nif (!pd) {\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\nkref_init(&pd->kref);\r\nset_map_flags(pd, udev);\r\nnew_one = 1;\r\n}\r\npd->udev = usb_get_dev(udev);\r\npd->interface = usb_get_intf(interface);\r\nusb_set_intfdata(interface, pd);\r\nif (new_one) {\r\nlogpm(pd);\r\nmutex_init(&pd->lock);\r\nret = v4l2_device_register(&interface->dev, &pd->v4l2_dev);\r\nret = pd_video_init(pd);\r\nposeidon_audio_init(pd);\r\nposeidon_fm_init(pd);\r\npd_dvb_usb_device_init(pd);\r\nINIT_LIST_HEAD(&pd->device_list);\r\nlist_add_tail(&pd->device_list, &pd_device_list);\r\n}\r\ndevice_init_wakeup(&udev->dev, 1);\r\n#ifdef CONFIG_PM\r\npm_runtime_set_autosuspend_delay(&pd->udev->dev,\r\n1000 * PM_SUSPEND_DELAY);\r\nusb_enable_autosuspend(pd->udev);\r\nif (in_hibernation(pd)) {\r\nINIT_WORK(&pd->pm_work, hibernation_resume);\r\nschedule_work(&pd->pm_work);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void poseidon_disconnect(struct usb_interface *interface)\r\n{\r\nstruct poseidon *pd = get_pd(interface);\r\nif (!pd)\r\nreturn;\r\nlogpm(pd);\r\nif (in_hibernation(pd))\r\nreturn;\r\nmutex_lock(&pd->lock);\r\npd->state |= POSEIDON_STATE_DISCONNECT;\r\nmutex_unlock(&pd->lock);\r\nstop_all_video_stream(pd);\r\ndvb_stop_streaming(&pd->dvb_data);\r\nv4l2_device_unregister(&pd->v4l2_dev);\r\npd_dvb_usb_device_exit(pd);\r\nposeidon_fm_exit(pd);\r\nposeidon_audio_free(pd);\r\npd_video_exit(pd);\r\nusb_set_intfdata(interface, NULL);\r\nkref_put(&pd->kref, poseidon_delete);\r\n}\r\nstatic int __init poseidon_init(void)\r\n{\r\nint ret;\r\nret = usb_register(&poseidon_driver);\r\nif (ret)\r\nreturn ret;\r\nregister_pm_notifier(&pm_notifer);\r\nreturn ret;\r\n}\r\nstatic void __exit poseidon_exit(void)\r\n{\r\nlog();\r\nunregister_pm_notifier(&pm_notifer);\r\nusb_deregister(&poseidon_driver);\r\n}
