static ssize_t show_status(struct device *dev, struct device_attribute *attr,\r\nchar *out)\r\n{\r\nchar *s = out;\r\nint i = 0;\r\nBUG_ON(!the_controller || !out);\r\nspin_lock(&the_controller->lock);\r\nout += sprintf(out, "prt sta spd bus dev socket "\r\n"local_busid\n");\r\nfor (i = 0; i < VHCI_NPORTS; i++) {\r\nstruct vhci_device *vdev = port_to_vdev(i);\r\nspin_lock(&vdev->ud.lock);\r\nout += sprintf(out, "%03u %03u ", i, vdev->ud.status);\r\nif (vdev->ud.status == VDEV_ST_USED) {\r\nout += sprintf(out, "%03u %08x ",\r\nvdev->speed, vdev->devid);\r\nout += sprintf(out, "%16p ", vdev->ud.tcp_socket);\r\nout += sprintf(out, "%s", dev_name(&vdev->udev->dev));\r\n} else {\r\nout += sprintf(out, "000 000 000 0000000000000000 0-0");\r\n}\r\nout += sprintf(out, "\n");\r\nspin_unlock(&vdev->ud.lock);\r\n}\r\nspin_unlock(&the_controller->lock);\r\nreturn out - s;\r\n}\r\nstatic int vhci_port_disconnect(__u32 rhport)\r\n{\r\nstruct vhci_device *vdev;\r\nusbip_dbg_vhci_sysfs("enter\n");\r\nspin_lock(&the_controller->lock);\r\nvdev = port_to_vdev(rhport);\r\nspin_lock(&vdev->ud.lock);\r\nif (vdev->ud.status == VDEV_ST_NULL) {\r\npr_err("not connected %d\n", vdev->ud.status);\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock(&the_controller->lock);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock(&the_controller->lock);\r\nusbip_event_add(&vdev->ud, VDEV_EVENT_DOWN);\r\nreturn 0;\r\n}\r\nstatic ssize_t store_detach(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint err;\r\n__u32 rhport = 0;\r\nsscanf(buf, "%u", &rhport);\r\nif (rhport >= VHCI_NPORTS) {\r\ndev_err(dev, "invalid port %u\n", rhport);\r\nreturn -EINVAL;\r\n}\r\nerr = vhci_port_disconnect(rhport);\r\nif (err < 0)\r\nreturn -EINVAL;\r\nusbip_dbg_vhci_sysfs("Leave\n");\r\nreturn count;\r\n}\r\nstatic int valid_args(__u32 rhport, enum usb_device_speed speed)\r\n{\r\nif (rhport >= VHCI_NPORTS) {\r\npr_err("port %u\n", rhport);\r\nreturn -EINVAL;\r\n}\r\nswitch (speed) {\r\ncase USB_SPEED_LOW:\r\ncase USB_SPEED_FULL:\r\ncase USB_SPEED_HIGH:\r\ncase USB_SPEED_WIRELESS:\r\nbreak;\r\ndefault:\r\npr_err("speed %d\n", speed);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t store_attach(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vhci_device *vdev;\r\nstruct socket *socket;\r\nint sockfd = 0;\r\n__u32 rhport = 0, devid = 0, speed = 0;\r\nsscanf(buf, "%u %u %u %u", &rhport, &sockfd, &devid, &speed);\r\nusbip_dbg_vhci_sysfs("rhport(%u) sockfd(%u) devid(%u) speed(%u)\n",\r\nrhport, sockfd, devid, speed);\r\nif (valid_args(rhport, speed) < 0)\r\nreturn -EINVAL;\r\nsocket = sockfd_to_socket(sockfd);\r\nif (!socket)\r\nreturn -EINVAL;\r\nspin_lock(&the_controller->lock);\r\nvdev = port_to_vdev(rhport);\r\nspin_lock(&vdev->ud.lock);\r\nif (vdev->ud.status != VDEV_ST_NULL) {\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock(&the_controller->lock);\r\nfput(socket->file);\r\ndev_err(dev, "port %d already used\n", rhport);\r\nreturn -EINVAL;\r\n}\r\ndev_info(dev, "rhport(%u) sockfd(%d) devid(%u) speed(%u)\n",\r\nrhport, sockfd, devid, speed);\r\nvdev->devid = devid;\r\nvdev->speed = speed;\r\nvdev->ud.tcp_socket = socket;\r\nvdev->ud.status = VDEV_ST_NOTASSIGNED;\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock(&the_controller->lock);\r\nvdev->ud.tcp_rx = kthread_get_run(vhci_rx_loop, &vdev->ud, "vhci_rx");\r\nvdev->ud.tcp_tx = kthread_get_run(vhci_tx_loop, &vdev->ud, "vhci_tx");\r\nrh_port_connect(rhport, speed);\r\nreturn count;\r\n}
