static struct rb_node *release_next(struct tracer_stat *ts,\r\nstruct rb_node *node)\r\n{\r\nstruct stat_node *snode;\r\nstruct rb_node *parent = rb_parent(node);\r\nif (node->rb_left)\r\nreturn node->rb_left;\r\nelse if (node->rb_right)\r\nreturn node->rb_right;\r\nelse {\r\nif (!parent)\r\n;\r\nelse if (parent->rb_left == node)\r\nparent->rb_left = NULL;\r\nelse\r\nparent->rb_right = NULL;\r\nsnode = container_of(node, struct stat_node, node);\r\nif (ts->stat_release)\r\nts->stat_release(snode->stat);\r\nkfree(snode);\r\nreturn parent;\r\n}\r\n}\r\nstatic void __reset_stat_session(struct stat_session *session)\r\n{\r\nstruct rb_node *node = session->stat_root.rb_node;\r\nwhile (node)\r\nnode = release_next(session->ts, node);\r\nsession->stat_root = RB_ROOT;\r\n}\r\nstatic void reset_stat_session(struct stat_session *session)\r\n{\r\nmutex_lock(&session->stat_mutex);\r\n__reset_stat_session(session);\r\nmutex_unlock(&session->stat_mutex);\r\n}\r\nstatic void destroy_session(struct stat_session *session)\r\n{\r\ndebugfs_remove(session->file);\r\n__reset_stat_session(session);\r\nmutex_destroy(&session->stat_mutex);\r\nkfree(session);\r\n}\r\nstatic int insert_stat(struct rb_root *root, void *stat, cmp_stat_t cmp)\r\n{\r\nstruct rb_node **new = &(root->rb_node), *parent = NULL;\r\nstruct stat_node *data;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->stat = stat;\r\nwhile (*new) {\r\nstruct stat_node *this;\r\nint result;\r\nthis = container_of(*new, struct stat_node, node);\r\nresult = cmp(data->stat, this->stat);\r\nparent = *new;\r\nif (result >= 0)\r\nnew = &((*new)->rb_left);\r\nelse\r\nnew = &((*new)->rb_right);\r\n}\r\nrb_link_node(&data->node, parent, new);\r\nrb_insert_color(&data->node, root);\r\nreturn 0;\r\n}\r\nstatic int dummy_cmp(void *p1, void *p2)\r\n{\r\nreturn -1;\r\n}\r\nstatic int stat_seq_init(struct stat_session *session)\r\n{\r\nstruct tracer_stat *ts = session->ts;\r\nstruct rb_root *root = &session->stat_root;\r\nvoid *stat;\r\nint ret = 0;\r\nint i;\r\nmutex_lock(&session->stat_mutex);\r\n__reset_stat_session(session);\r\nif (!ts->stat_cmp)\r\nts->stat_cmp = dummy_cmp;\r\nstat = ts->stat_start(ts);\r\nif (!stat)\r\ngoto exit;\r\nret = insert_stat(root, stat, ts->stat_cmp);\r\nif (ret)\r\ngoto exit;\r\nfor (i = 1; ; i++) {\r\nstat = ts->stat_next(stat, i);\r\nif (!stat)\r\nbreak;\r\nret = insert_stat(root, stat, ts->stat_cmp);\r\nif (ret)\r\ngoto exit_free_rbtree;\r\n}\r\nexit:\r\nmutex_unlock(&session->stat_mutex);\r\nreturn ret;\r\nexit_free_rbtree:\r\n__reset_stat_session(session);\r\nmutex_unlock(&session->stat_mutex);\r\nreturn ret;\r\n}\r\nstatic void *stat_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct stat_session *session = s->private;\r\nstruct rb_node *node;\r\nint n = *pos;\r\nint i;\r\nmutex_lock(&session->stat_mutex);\r\nif (session->ts->stat_headers) {\r\nif (n == 0)\r\nreturn SEQ_START_TOKEN;\r\nn--;\r\n}\r\nnode = rb_first(&session->stat_root);\r\nfor (i = 0; node && i < n; i++)\r\nnode = rb_next(node);\r\nreturn node;\r\n}\r\nstatic void *stat_seq_next(struct seq_file *s, void *p, loff_t *pos)\r\n{\r\nstruct stat_session *session = s->private;\r\nstruct rb_node *node = p;\r\n(*pos)++;\r\nif (p == SEQ_START_TOKEN)\r\nreturn rb_first(&session->stat_root);\r\nreturn rb_next(node);\r\n}\r\nstatic void stat_seq_stop(struct seq_file *s, void *p)\r\n{\r\nstruct stat_session *session = s->private;\r\nmutex_unlock(&session->stat_mutex);\r\n}\r\nstatic int stat_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct stat_session *session = s->private;\r\nstruct stat_node *l = container_of(v, struct stat_node, node);\r\nif (v == SEQ_START_TOKEN)\r\nreturn session->ts->stat_headers(s);\r\nreturn session->ts->stat_show(s, l->stat);\r\n}\r\nstatic int tracing_stat_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nstruct seq_file *m;\r\nstruct stat_session *session = inode->i_private;\r\nret = stat_seq_init(session);\r\nif (ret)\r\nreturn ret;\r\nret = seq_open(file, &trace_stat_seq_ops);\r\nif (ret) {\r\nreset_stat_session(session);\r\nreturn ret;\r\n}\r\nm = file->private_data;\r\nm->private = session;\r\nreturn ret;\r\n}\r\nstatic int tracing_stat_release(struct inode *i, struct file *f)\r\n{\r\nstruct stat_session *session = i->i_private;\r\nreset_stat_session(session);\r\nreturn seq_release(i, f);\r\n}\r\nstatic int tracing_stat_init(void)\r\n{\r\nstruct dentry *d_tracing;\r\nd_tracing = tracing_init_dentry();\r\nif (!d_tracing)\r\nreturn 0;\r\nstat_dir = debugfs_create_dir("trace_stat", d_tracing);\r\nif (!stat_dir)\r\npr_warning("Could not create debugfs "\r\n"'trace_stat' entry\n");\r\nreturn 0;\r\n}\r\nstatic int init_stat_file(struct stat_session *session)\r\n{\r\nif (!stat_dir && tracing_stat_init())\r\nreturn -ENODEV;\r\nsession->file = debugfs_create_file(session->ts->name, 0644,\r\nstat_dir,\r\nsession, &tracing_stat_fops);\r\nif (!session->file)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint register_stat_tracer(struct tracer_stat *trace)\r\n{\r\nstruct stat_session *session, *node;\r\nint ret;\r\nif (!trace)\r\nreturn -EINVAL;\r\nif (!trace->stat_start || !trace->stat_next || !trace->stat_show)\r\nreturn -EINVAL;\r\nmutex_lock(&all_stat_sessions_mutex);\r\nlist_for_each_entry(node, &all_stat_sessions, session_list) {\r\nif (node->ts == trace) {\r\nmutex_unlock(&all_stat_sessions_mutex);\r\nreturn -EINVAL;\r\n}\r\n}\r\nmutex_unlock(&all_stat_sessions_mutex);\r\nsession = kzalloc(sizeof(*session), GFP_KERNEL);\r\nif (!session)\r\nreturn -ENOMEM;\r\nsession->ts = trace;\r\nINIT_LIST_HEAD(&session->session_list);\r\nmutex_init(&session->stat_mutex);\r\nret = init_stat_file(session);\r\nif (ret) {\r\ndestroy_session(session);\r\nreturn ret;\r\n}\r\nmutex_lock(&all_stat_sessions_mutex);\r\nlist_add_tail(&session->session_list, &all_stat_sessions);\r\nmutex_unlock(&all_stat_sessions_mutex);\r\nreturn 0;\r\n}\r\nvoid unregister_stat_tracer(struct tracer_stat *trace)\r\n{\r\nstruct stat_session *node, *tmp;\r\nmutex_lock(&all_stat_sessions_mutex);\r\nlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\r\nif (node->ts == trace) {\r\nlist_del(&node->session_list);\r\ndestroy_session(node);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&all_stat_sessions_mutex);\r\n}
