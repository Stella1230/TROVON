static void assign_alt_irq (struct pci_func * cur_func, u8 class_code)\r\n{\r\nint j;\r\nfor (j = 0; j < 4; j++) {\r\nif (cur_func->irq[j] == 0xff) {\r\nswitch (class_code) {\r\ncase PCI_BASE_CLASS_STORAGE:\r\ncur_func->irq[j] = SCSI_IRQ;\r\nbreak;\r\ncase PCI_BASE_CLASS_NETWORK:\r\ncur_func->irq[j] = LAN_IRQ;\r\nbreak;\r\ndefault:\r\ncur_func->irq[j] = OTHER_IRQ;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nint ibmphp_configure_card (struct pci_func *func, u8 slotno)\r\n{\r\nu16 vendor_id;\r\nu32 class;\r\nu8 class_code;\r\nu8 hdr_type, device, sec_number;\r\nu8 function;\r\nstruct pci_func *newfunc;\r\nstruct pci_func *cur_func, *prev_func;\r\nint rc, i, j;\r\nint cleanup_count;\r\nu8 flag;\r\nu8 valid_device = 0x00;\r\ndebug ("inside configure_card, func->busno = %x\n", func->busno);\r\ndevice = func->device;\r\ncur_func = func;\r\nfor (function = 0x00; function < 0x08; function++) {\r\nunsigned int devfn = PCI_DEVFN(device, function);\r\nibmphp_pci_bus->number = cur_func->busno;\r\ncur_func->function = function;\r\ndebug ("inside the loop, cur_func->busno = %x, cur_func->device = %x, cur_func->function = %x\n",\r\ncur_func->busno, cur_func->device, cur_func->function);\r\npci_bus_read_config_word (ibmphp_pci_bus, devfn, PCI_VENDOR_ID, &vendor_id);\r\ndebug ("vendor_id is %x\n", vendor_id);\r\nif (vendor_id != PCI_VENDOR_ID_NOTVALID) {\r\ndebug ("found valid device, vendor_id = %x\n", vendor_id);\r\n++valid_device;\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_HEADER_TYPE, &hdr_type);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, PCI_CLASS_REVISION, &class);\r\nclass_code = class >> 24;\r\ndebug ("hrd_type = %x, class = %x, class_code %x\n", hdr_type, class, class_code);\r\nclass >>= 8;\r\nif (class == PCI_CLASS_NOT_DEFINED_VGA) {\r\nerr ("The device %x is VGA compatible and as is not supported for hot plugging. "\r\n"Please choose another device.\n", cur_func->device);\r\nreturn -ENODEV;\r\n} else if (class == PCI_CLASS_DISPLAY_VGA) {\r\nerr ("The device %x is not supported for hot plugging. "\r\n"Please choose another device.\n", cur_func->device);\r\nreturn -ENODEV;\r\n}\r\nswitch (hdr_type) {\r\ncase PCI_HEADER_TYPE_NORMAL:\r\ndebug ("single device case.... vendor id = %x, hdr_type = %x, class = %x\n", vendor_id, hdr_type, class);\r\nassign_alt_irq (cur_func, class_code);\r\nif ((rc = configure_device (cur_func)) < 0) {\r\nerr ("was not able to configure devfunc %x on bus %x.\n",\r\ncur_func->device, cur_func->busno);\r\ncleanup_count = 6;\r\ngoto error;\r\n}\r\ncur_func->next = NULL;\r\nfunction = 0x8;\r\nbreak;\r\ncase PCI_HEADER_TYPE_MULTIDEVICE:\r\nassign_alt_irq (cur_func, class_code);\r\nif ((rc = configure_device (cur_func)) < 0) {\r\nerr ("was not able to configure devfunc %x on bus %x...bailing out\n",\r\ncur_func->device, cur_func->busno);\r\ncleanup_count = 6;\r\ngoto error;\r\n}\r\nnewfunc = kzalloc(sizeof(*newfunc), GFP_KERNEL);\r\nif (!newfunc) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nnewfunc->busno = cur_func->busno;\r\nnewfunc->device = device;\r\ncur_func->next = newfunc;\r\ncur_func = newfunc;\r\nfor (j = 0; j < 4; j++)\r\nnewfunc->irq[j] = cur_func->irq[j];\r\nbreak;\r\ncase PCI_HEADER_TYPE_MULTIBRIDGE:\r\nclass >>= 8;\r\nif (class != PCI_CLASS_BRIDGE_PCI) {\r\nerr ("This %x is not PCI-to-PCI bridge, and as is not supported for hot-plugging. "\r\n"Please insert another card.\n", cur_func->device);\r\nreturn -ENODEV;\r\n}\r\nassign_alt_irq (cur_func, class_code);\r\nrc = configure_bridge (&cur_func, slotno);\r\nif (rc == -ENODEV) {\r\nerr ("You chose to insert Single Bridge, or nested bridges, this is not supported...\n");\r\nerr ("Bus %x, devfunc %x\n", cur_func->busno, cur_func->device);\r\nreturn rc;\r\n}\r\nif (rc) {\r\nerr ("was not able to hot-add PPB properly.\n");\r\nfunc->bus = 1;\r\ncleanup_count = 2;\r\ngoto error;\r\n}\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, &sec_number);\r\nflag = 0;\r\nfor (i = 0; i < 32; i++) {\r\nif (func->devices[i]) {\r\nnewfunc = kzalloc(sizeof(*newfunc), GFP_KERNEL);\r\nif (!newfunc) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nnewfunc->busno = sec_number;\r\nnewfunc->device = (u8) i;\r\nfor (j = 0; j < 4; j++)\r\nnewfunc->irq[j] = cur_func->irq[j];\r\nif (flag) {\r\nfor (prev_func = cur_func; prev_func->next; prev_func = prev_func->next) ;\r\nprev_func->next = newfunc;\r\n} else\r\ncur_func->next = newfunc;\r\nrc = ibmphp_configure_card (newfunc, slotno);\r\nif (rc) {\r\nfunc->bus = 1;\r\ncleanup_count = 2;\r\ngoto error;\r\n}\r\nflag = 1;\r\n}\r\n}\r\nnewfunc = kzalloc(sizeof(*newfunc), GFP_KERNEL);\r\nif (!newfunc) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nnewfunc->busno = cur_func->busno;\r\nnewfunc->device = device;\r\nfor (j = 0; j < 4; j++)\r\nnewfunc->irq[j] = cur_func->irq[j];\r\nfor (prev_func = cur_func; prev_func->next; prev_func = prev_func->next) ;\r\nprev_func->next = newfunc;\r\ncur_func = newfunc;\r\nbreak;\r\ncase PCI_HEADER_TYPE_BRIDGE:\r\nclass >>= 8;\r\ndebug ("class now is %x\n", class);\r\nif (class != PCI_CLASS_BRIDGE_PCI) {\r\nerr ("This %x is not PCI-to-PCI bridge, and as is not supported for hot-plugging. "\r\n"Please insert another card.\n", cur_func->device);\r\nreturn -ENODEV;\r\n}\r\nassign_alt_irq (cur_func, class_code);\r\ndebug ("cur_func->busno b4 configure_bridge is %x\n", cur_func->busno);\r\nrc = configure_bridge (&cur_func, slotno);\r\nif (rc == -ENODEV) {\r\nerr ("You chose to insert Single Bridge, or nested bridges, this is not supported...\n");\r\nerr ("Bus %x, devfunc %x\n", cur_func->busno, cur_func->device);\r\nreturn rc;\r\n}\r\nif (rc) {\r\nfunc->bus = 1;\r\nerr ("was not able to hot-add PPB properly.\n");\r\ncleanup_count = 2;\r\ngoto error;\r\n}\r\ndebug ("cur_func->busno = %x, device = %x, function = %x\n",\r\ncur_func->busno, device, function);\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, &sec_number);\r\ndebug ("after configuring bridge..., sec_number = %x\n", sec_number);\r\nflag = 0;\r\nfor (i = 0; i < 32; i++) {\r\nif (func->devices[i]) {\r\ndebug ("inside for loop, device is %x\n", i);\r\nnewfunc = kzalloc(sizeof(*newfunc), GFP_KERNEL);\r\nif (!newfunc) {\r\nerr (" out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nnewfunc->busno = sec_number;\r\nnewfunc->device = (u8) i;\r\nfor (j = 0; j < 4; j++)\r\nnewfunc->irq[j] = cur_func->irq[j];\r\nif (flag) {\r\nfor (prev_func = cur_func; prev_func->next; prev_func = prev_func->next) ;\r\nprev_func->next = newfunc;\r\n} else\r\ncur_func->next = newfunc;\r\nrc = ibmphp_configure_card (newfunc, slotno);\r\nif (rc) {\r\nfunc->bus = 1;\r\ncleanup_count = 2;\r\ngoto error;\r\n}\r\nflag = 1;\r\n}\r\n}\r\nfunction = 0x8;\r\nbreak;\r\ndefault:\r\nerr ("MAJOR PROBLEM!!!!, header type not supported? %x\n", hdr_type);\r\nreturn -ENXIO;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!valid_device) {\r\nerr ("Cannot find any valid devices on the card. Or unable to read from card.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\nerror:\r\nfor (i = 0; i < cleanup_count; i++) {\r\nif (cur_func->io[i]) {\r\nibmphp_remove_resource (cur_func->io[i]);\r\ncur_func->io[i] = NULL;\r\n} else if (cur_func->pfmem[i]) {\r\nibmphp_remove_resource (cur_func->pfmem[i]);\r\ncur_func->pfmem[i] = NULL;\r\n} else if (cur_func->mem[i]) {\r\nibmphp_remove_resource (cur_func->mem[i]);\r\ncur_func->mem[i] = NULL;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int configure_device (struct pci_func *func)\r\n{\r\nu32 bar[6];\r\nu32 address[] = {\r\nPCI_BASE_ADDRESS_0,\r\nPCI_BASE_ADDRESS_1,\r\nPCI_BASE_ADDRESS_2,\r\nPCI_BASE_ADDRESS_3,\r\nPCI_BASE_ADDRESS_4,\r\nPCI_BASE_ADDRESS_5,\r\n0\r\n};\r\nu8 irq;\r\nint count;\r\nint len[6];\r\nstruct resource_node *io[6];\r\nstruct resource_node *mem[6];\r\nstruct resource_node *mem_tmp;\r\nstruct resource_node *pfmem[6];\r\nunsigned int devfn;\r\ndebug ("%s - inside\n", __func__);\r\ndevfn = PCI_DEVFN(func->device, func->function);\r\nibmphp_pci_bus->number = func->busno;\r\nfor (count = 0; address[count]; count++) {\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], 0xFFFFFFFF);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &bar[count]);\r\nif (!bar[count])\r\ncontinue;\r\ndebug ("Device %x BAR %d wants %x\n", func->device, count, bar[count]);\r\nif (bar[count] & PCI_BASE_ADDRESS_SPACE_IO) {\r\ndebug ("inside IO SPACE\n");\r\nlen[count] = bar[count] & 0xFFFFFFFC;\r\nlen[count] = ~len[count] + 1;\r\ndebug ("len[count] in IO %x, count %d\n", len[count], count);\r\nio[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!io[count]) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nio[count]->type = IO;\r\nio[count]->busno = func->busno;\r\nio[count]->devfunc = PCI_DEVFN(func->device, func->function);\r\nio[count]->len = len[count];\r\nif (ibmphp_check_resource(io[count], 0) == 0) {\r\nibmphp_add_resource (io[count]);\r\nfunc->io[count] = io[count];\r\n} else {\r\nerr ("cannot allocate requested io for bus %x device %x function %x len %x\n",\r\nfunc->busno, func->device, func->function, len[count]);\r\nkfree (io[count]);\r\nreturn -EIO;\r\n}\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], func->io[count]->start);\r\ndebug ("b4 writing, the IO address is %x\n", func->io[count]->start);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &bar[count]);\r\ndebug ("after writing.... the start address is %x\n", bar[count]);\r\n} else {\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_PREFETCH) {\r\ndebug ("PFMEM SPACE\n");\r\nlen[count] = bar[count] & 0xFFFFFFF0;\r\nlen[count] = ~len[count] + 1;\r\ndebug ("len[count] in PFMEM %x, count %d\n", len[count], count);\r\npfmem[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!pfmem[count]) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\npfmem[count]->type = PFMEM;\r\npfmem[count]->busno = func->busno;\r\npfmem[count]->devfunc = PCI_DEVFN(func->device,\r\nfunc->function);\r\npfmem[count]->len = len[count];\r\npfmem[count]->fromMem = 0;\r\nif (ibmphp_check_resource (pfmem[count], 0) == 0) {\r\nibmphp_add_resource (pfmem[count]);\r\nfunc->pfmem[count] = pfmem[count];\r\n} else {\r\nmem_tmp = kzalloc(sizeof(*mem_tmp), GFP_KERNEL);\r\nif (!mem_tmp) {\r\nerr ("out of system memory\n");\r\nkfree (pfmem[count]);\r\nreturn -ENOMEM;\r\n}\r\nmem_tmp->type = MEM;\r\nmem_tmp->busno = pfmem[count]->busno;\r\nmem_tmp->devfunc = pfmem[count]->devfunc;\r\nmem_tmp->len = pfmem[count]->len;\r\ndebug ("there's no pfmem... going into mem.\n");\r\nif (ibmphp_check_resource (mem_tmp, 0) == 0) {\r\nibmphp_add_resource (mem_tmp);\r\npfmem[count]->fromMem = 1;\r\npfmem[count]->rangeno = mem_tmp->rangeno;\r\npfmem[count]->start = mem_tmp->start;\r\npfmem[count]->end = mem_tmp->end;\r\nibmphp_add_pfmem_from_mem (pfmem[count]);\r\nfunc->pfmem[count] = pfmem[count];\r\n} else {\r\nerr ("cannot allocate requested pfmem for bus %x, device %x, len %x\n",\r\nfunc->busno, func->device, len[count]);\r\nkfree (mem_tmp);\r\nkfree (pfmem[count]);\r\nreturn -EIO;\r\n}\r\n}\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], func->pfmem[count]->start);\r\ndebug ("b4 writing, start address is %x\n", func->pfmem[count]->start);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &bar[count]);\r\ndebug ("after writing, start address is %x\n", bar[count]);\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\ndebug ("inside the mem 64 case, count %d\n", count);\r\ncount += 1;\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], 0x00000000);\r\n}\r\n} else {\r\ndebug ("REGULAR MEM SPACE\n");\r\nlen[count] = bar[count] & 0xFFFFFFF0;\r\nlen[count] = ~len[count] + 1;\r\ndebug ("len[count] in Mem %x, count %d\n", len[count], count);\r\nmem[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!mem[count]) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmem[count]->type = MEM;\r\nmem[count]->busno = func->busno;\r\nmem[count]->devfunc = PCI_DEVFN(func->device,\r\nfunc->function);\r\nmem[count]->len = len[count];\r\nif (ibmphp_check_resource (mem[count], 0) == 0) {\r\nibmphp_add_resource (mem[count]);\r\nfunc->mem[count] = mem[count];\r\n} else {\r\nerr ("cannot allocate requested mem for bus %x, device %x, len %x\n",\r\nfunc->busno, func->device, len[count]);\r\nkfree (mem[count]);\r\nreturn -EIO;\r\n}\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], func->mem[count]->start);\r\ndebug ("b4 writing, start address is %x\n", func->mem[count]->start);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &bar[count]);\r\ndebug ("after writing, the address is %x\n", bar[count]);\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\ndebug ("inside mem 64 case, reg. mem, count %d\n", count);\r\ncount += 1;\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], 0x00000000);\r\n}\r\n}\r\n}\r\n}\r\nfunc->bus = 0;\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_INTERRUPT_PIN, &irq);\r\nif ((irq > 0x00) && (irq < 0x05))\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_INTERRUPT_LINE, func->irq[irq - 1]);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_CACHE_LINE_SIZE, CACHE);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_LATENCY_TIMER, LATENCY);\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, PCI_ROM_ADDRESS, 0x00L);\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_COMMAND, DEVICEENABLE);\r\nreturn 0;\r\n}\r\nstatic int configure_bridge (struct pci_func **func_passed, u8 slotno)\r\n{\r\nint count;\r\nint i;\r\nint rc;\r\nu8 sec_number;\r\nu8 io_base;\r\nu16 pfmem_base;\r\nu32 bar[2];\r\nu32 len[2];\r\nu8 flag_io = 0;\r\nu8 flag_mem = 0;\r\nu8 flag_pfmem = 0;\r\nu8 need_io_upper = 0;\r\nu8 need_pfmem_upper = 0;\r\nstruct res_needed *amount_needed = NULL;\r\nstruct resource_node *io = NULL;\r\nstruct resource_node *bus_io[2] = {NULL, NULL};\r\nstruct resource_node *mem = NULL;\r\nstruct resource_node *bus_mem[2] = {NULL, NULL};\r\nstruct resource_node *mem_tmp = NULL;\r\nstruct resource_node *pfmem = NULL;\r\nstruct resource_node *bus_pfmem[2] = {NULL, NULL};\r\nstruct bus_node *bus;\r\nu32 address[] = {\r\nPCI_BASE_ADDRESS_0,\r\nPCI_BASE_ADDRESS_1,\r\n0\r\n};\r\nstruct pci_func *func = *func_passed;\r\nunsigned int devfn;\r\nu8 irq;\r\nint retval;\r\ndebug ("%s - enter\n", __func__);\r\ndevfn = PCI_DEVFN(func->function, func->device);\r\nibmphp_pci_bus->number = func->busno;\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_PRIMARY_BUS, func->busno);\r\nsec_number = find_sec_number (func->busno, slotno);\r\nif (sec_number == 0xff) {\r\nerr ("cannot allocate secondary bus number for the bridged device\n");\r\nreturn -EINVAL;\r\n}\r\ndebug ("after find_sec_number, the number we got is %x\n", sec_number);\r\ndebug ("AFTER FIND_SEC_NUMBER, func->busno IS %x\n", func->busno);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, sec_number);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_SUBORDINATE_BUS, sec_number);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_CACHE_LINE_SIZE, CACHE);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_LATENCY_TIMER, LATENCY);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_SEC_LATENCY_TIMER, LATENCY);\r\ndebug ("func->busno is %x\n", func->busno);\r\ndebug ("sec_number after writing is %x\n", sec_number);\r\nfor (count = 0; address[count]; count++) {\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], 0xFFFFFFFF);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &bar[count]);\r\nif (!bar[count]) {\r\ndebug ("so we come here then, eh?, count = %d\n", count);\r\ncontinue;\r\n}\r\ndebug ("Bar %d wants %x\n", count, bar[count]);\r\nif (bar[count] & PCI_BASE_ADDRESS_SPACE_IO) {\r\nlen[count] = bar[count] & 0xFFFFFFFC;\r\nlen[count] = ~len[count] + 1;\r\ndebug ("len[count] in IO = %x\n", len[count]);\r\nbus_io[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!bus_io[count]) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nbus_io[count]->type = IO;\r\nbus_io[count]->busno = func->busno;\r\nbus_io[count]->devfunc = PCI_DEVFN(func->device,\r\nfunc->function);\r\nbus_io[count]->len = len[count];\r\nif (ibmphp_check_resource (bus_io[count], 0) == 0) {\r\nibmphp_add_resource (bus_io[count]);\r\nfunc->io[count] = bus_io[count];\r\n} else {\r\nerr ("cannot allocate requested io for bus %x, device %x, len %x\n",\r\nfunc->busno, func->device, len[count]);\r\nkfree (bus_io[count]);\r\nreturn -EIO;\r\n}\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], func->io[count]->start);\r\n} else {\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_PREFETCH) {\r\nlen[count] = bar[count] & 0xFFFFFFF0;\r\nlen[count] = ~len[count] + 1;\r\ndebug ("len[count] in PFMEM = %x\n", len[count]);\r\nbus_pfmem[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!bus_pfmem[count]) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nbus_pfmem[count]->type = PFMEM;\r\nbus_pfmem[count]->busno = func->busno;\r\nbus_pfmem[count]->devfunc = PCI_DEVFN(func->device,\r\nfunc->function);\r\nbus_pfmem[count]->len = len[count];\r\nbus_pfmem[count]->fromMem = 0;\r\nif (ibmphp_check_resource (bus_pfmem[count], 0) == 0) {\r\nibmphp_add_resource (bus_pfmem[count]);\r\nfunc->pfmem[count] = bus_pfmem[count];\r\n} else {\r\nmem_tmp = kzalloc(sizeof(*mem_tmp), GFP_KERNEL);\r\nif (!mem_tmp) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nmem_tmp->type = MEM;\r\nmem_tmp->busno = bus_pfmem[count]->busno;\r\nmem_tmp->devfunc = bus_pfmem[count]->devfunc;\r\nmem_tmp->len = bus_pfmem[count]->len;\r\nif (ibmphp_check_resource (mem_tmp, 0) == 0) {\r\nibmphp_add_resource (mem_tmp);\r\nbus_pfmem[count]->fromMem = 1;\r\nbus_pfmem[count]->rangeno = mem_tmp->rangeno;\r\nibmphp_add_pfmem_from_mem (bus_pfmem[count]);\r\nfunc->pfmem[count] = bus_pfmem[count];\r\n} else {\r\nerr ("cannot allocate requested pfmem for bus %x, device %x, len %x\n",\r\nfunc->busno, func->device, len[count]);\r\nkfree (mem_tmp);\r\nkfree (bus_pfmem[count]);\r\nreturn -EIO;\r\n}\r\n}\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], func->pfmem[count]->start);\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\ncount += 1;\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], 0x00000000);\r\n}\r\n} else {\r\nlen[count] = bar[count] & 0xFFFFFFF0;\r\nlen[count] = ~len[count] + 1;\r\ndebug ("len[count] in Memory is %x\n", len[count]);\r\nbus_mem[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\r\nif (!bus_mem[count]) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nbus_mem[count]->type = MEM;\r\nbus_mem[count]->busno = func->busno;\r\nbus_mem[count]->devfunc = PCI_DEVFN(func->device,\r\nfunc->function);\r\nbus_mem[count]->len = len[count];\r\nif (ibmphp_check_resource (bus_mem[count], 0) == 0) {\r\nibmphp_add_resource (bus_mem[count]);\r\nfunc->mem[count] = bus_mem[count];\r\n} else {\r\nerr ("cannot allocate requested mem for bus %x, device %x, len %x\n",\r\nfunc->busno, func->device, len[count]);\r\nkfree (bus_mem[count]);\r\nreturn -EIO;\r\n}\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], func->mem[count]->start);\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\ncount += 1;\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], 0x00000000);\r\n}\r\n}\r\n}\r\n}\r\namount_needed = scan_behind_bridge (func, sec_number);\r\nif (amount_needed == NULL)\r\nreturn -ENOMEM;\r\nibmphp_pci_bus->number = func->busno;\r\ndebug ("after coming back from scan_behind_bridge\n");\r\ndebug ("amount_needed->not_correct = %x\n", amount_needed->not_correct);\r\ndebug ("amount_needed->io = %x\n", amount_needed->io);\r\ndebug ("amount_needed->mem = %x\n", amount_needed->mem);\r\ndebug ("amount_needed->pfmem = %x\n", amount_needed->pfmem);\r\nif (amount_needed->not_correct) {\r\ndebug ("amount_needed is not correct\n");\r\nfor (count = 0; address[count]; count++) {\r\nif (bus_io[count]) {\r\nibmphp_remove_resource (bus_io[count]);\r\nfunc->io[count] = NULL;\r\n} else if (bus_pfmem[count]) {\r\nibmphp_remove_resource (bus_pfmem[count]);\r\nfunc->pfmem[count] = NULL;\r\n} else if (bus_mem[count]) {\r\nibmphp_remove_resource (bus_mem[count]);\r\nfunc->mem[count] = NULL;\r\n}\r\n}\r\nkfree (amount_needed);\r\nreturn -ENODEV;\r\n}\r\nif (!amount_needed->io) {\r\ndebug ("it doesn't want IO?\n");\r\nflag_io = 1;\r\n} else {\r\ndebug ("it wants %x IO behind the bridge\n", amount_needed->io);\r\nio = kzalloc(sizeof(*io), GFP_KERNEL);\r\nif (!io) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nio->type = IO;\r\nio->busno = func->busno;\r\nio->devfunc = PCI_DEVFN(func->device, func->function);\r\nio->len = amount_needed->io;\r\nif (ibmphp_check_resource (io, 1) == 0) {\r\ndebug ("were we able to add io\n");\r\nibmphp_add_resource (io);\r\nflag_io = 1;\r\n}\r\n}\r\nif (!amount_needed->mem) {\r\ndebug ("it doesn't want n.e.memory?\n");\r\nflag_mem = 1;\r\n} else {\r\ndebug ("it wants %x memory behind the bridge\n", amount_needed->mem);\r\nmem = kzalloc(sizeof(*mem), GFP_KERNEL);\r\nif (!mem) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nmem->type = MEM;\r\nmem->busno = func->busno;\r\nmem->devfunc = PCI_DEVFN(func->device, func->function);\r\nmem->len = amount_needed->mem;\r\nif (ibmphp_check_resource (mem, 1) == 0) {\r\nibmphp_add_resource (mem);\r\nflag_mem = 1;\r\ndebug ("were we able to add mem\n");\r\n}\r\n}\r\nif (!amount_needed->pfmem) {\r\ndebug ("it doesn't want n.e.pfmem mem?\n");\r\nflag_pfmem = 1;\r\n} else {\r\ndebug ("it wants %x pfmemory behind the bridge\n", amount_needed->pfmem);\r\npfmem = kzalloc(sizeof(*pfmem), GFP_KERNEL);\r\nif (!pfmem) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\npfmem->type = PFMEM;\r\npfmem->busno = func->busno;\r\npfmem->devfunc = PCI_DEVFN(func->device, func->function);\r\npfmem->len = amount_needed->pfmem;\r\npfmem->fromMem = 0;\r\nif (ibmphp_check_resource (pfmem, 1) == 0) {\r\nibmphp_add_resource (pfmem);\r\nflag_pfmem = 1;\r\n} else {\r\nmem_tmp = kzalloc(sizeof(*mem_tmp), GFP_KERNEL);\r\nif (!mem_tmp) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nmem_tmp->type = MEM;\r\nmem_tmp->busno = pfmem->busno;\r\nmem_tmp->devfunc = pfmem->devfunc;\r\nmem_tmp->len = pfmem->len;\r\nif (ibmphp_check_resource (mem_tmp, 1) == 0) {\r\nibmphp_add_resource (mem_tmp);\r\npfmem->fromMem = 1;\r\npfmem->rangeno = mem_tmp->rangeno;\r\nibmphp_add_pfmem_from_mem (pfmem);\r\nflag_pfmem = 1;\r\n}\r\n}\r\n}\r\ndebug ("b4 if (flag_io && flag_mem && flag_pfmem)\n");\r\ndebug ("flag_io = %x, flag_mem = %x, flag_pfmem = %x\n", flag_io, flag_mem, flag_pfmem);\r\nif (flag_io && flag_mem && flag_pfmem) {\r\nbus = ibmphp_find_res_bus (sec_number);\r\nif (!bus) {\r\nbus = kzalloc(sizeof(*bus), GFP_KERNEL);\r\nif (!bus) {\r\nerr ("out of system memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nbus->busno = sec_number;\r\ndebug ("b4 adding new bus\n");\r\nrc = add_new_bus (bus, io, mem, pfmem, func->busno);\r\n} else if (!(bus->rangeIO) && !(bus->rangeMem) && !(bus->rangePFMem))\r\nrc = add_new_bus (bus, io, mem, pfmem, 0xFF);\r\nelse {\r\nerr ("expected bus structure not empty?\n");\r\nretval = -EIO;\r\ngoto error;\r\n}\r\nif (rc) {\r\nif (rc == -ENOMEM) {\r\nibmphp_remove_bus (bus, func->busno);\r\nkfree (amount_needed);\r\nreturn rc;\r\n}\r\nretval = rc;\r\ngoto error;\r\n}\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_IO_BASE, &io_base);\r\npci_bus_read_config_word (ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, &pfmem_base);\r\nif ((io_base & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {\r\ndebug ("io 32\n");\r\nneed_io_upper = 1;\r\n}\r\nif ((pfmem_base & PCI_PREF_RANGE_TYPE_MASK) == PCI_PREF_RANGE_TYPE_64) {\r\ndebug ("pfmem 64\n");\r\nneed_pfmem_upper = 1;\r\n}\r\nif (bus->noIORanges) {\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_IO_BASE, 0x00 | bus->rangeIO->start >> 8);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_IO_LIMIT, 0x00 | bus->rangeIO->end >> 8);\r\nif (need_io_upper) {\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_IO_BASE_UPPER16, 0x0000);\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_IO_LIMIT_UPPER16, 0x0000);\r\n}\r\n} else {\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_IO_BASE, 0x00);\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_IO_LIMIT, 0x00);\r\n}\r\nif (bus->noMemRanges) {\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_MEMORY_BASE, 0x0000 | bus->rangeMem->start >> 16);\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_MEMORY_LIMIT, 0x0000 | bus->rangeMem->end >> 16);\r\n} else {\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_MEMORY_BASE, 0xffff);\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_MEMORY_LIMIT, 0x0000);\r\n}\r\nif (bus->noPFMemRanges) {\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, 0x0000 | bus->rangePFMem->start >> 16);\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, 0x0000 | bus->rangePFMem->end >> 16);\r\nif (need_pfmem_upper) {\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, PCI_PREF_BASE_UPPER32, 0x00000000);\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, PCI_PREF_LIMIT_UPPER32, 0x00000000);\r\n}\r\n} else {\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, 0xffff);\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, 0x0000);\r\n}\r\ndebug ("b4 writing control information\n");\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_INTERRUPT_PIN, &irq);\r\nif ((irq > 0x00) && (irq < 0x05))\r\npci_bus_write_config_byte (ibmphp_pci_bus, devfn, PCI_INTERRUPT_LINE, func->irq[irq - 1]);\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_COMMAND, DEVICEENABLE);\r\npci_bus_write_config_word (ibmphp_pci_bus, devfn, PCI_BRIDGE_CONTROL, 0x07);\r\nfor (i = 0; i < 32; i++) {\r\nif (amount_needed->devices[i]) {\r\ndebug ("device where devices[i] is 1 = %x\n", i);\r\nfunc->devices[i] = 1;\r\n}\r\n}\r\nfunc->bus = 1;\r\nfunc_passed = &func;\r\ndebug ("func->busno b4 returning is %x\n", func->busno);\r\ndebug ("func->busno b4 returning in the other structure is %x\n", (*func_passed)->busno);\r\nkfree (amount_needed);\r\nreturn 0;\r\n} else {\r\nerr ("Configuring bridge was unsuccessful...\n");\r\nmem_tmp = NULL;\r\nretval = -EIO;\r\ngoto error;\r\n}\r\nerror:\r\nkfree(amount_needed);\r\nif (pfmem)\r\nibmphp_remove_resource (pfmem);\r\nif (io)\r\nibmphp_remove_resource (io);\r\nif (mem)\r\nibmphp_remove_resource (mem);\r\nfor (i = 0; i < 2; i++) {\r\nif (bus_io[i]) {\r\nibmphp_remove_resource (bus_io[i]);\r\nfunc->io[i] = NULL;\r\n} else if (bus_pfmem[i]) {\r\nibmphp_remove_resource (bus_pfmem[i]);\r\nfunc->pfmem[i] = NULL;\r\n} else if (bus_mem[i]) {\r\nibmphp_remove_resource (bus_mem[i]);\r\nfunc->mem[i] = NULL;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic struct res_needed *scan_behind_bridge (struct pci_func * func, u8 busno)\r\n{\r\nint count, len[6];\r\nu16 vendor_id;\r\nu8 hdr_type;\r\nu8 device, function;\r\nunsigned int devfn;\r\nint howmany = 0;\r\nu32 bar[6], class;\r\nu32 address[] = {\r\nPCI_BASE_ADDRESS_0,\r\nPCI_BASE_ADDRESS_1,\r\nPCI_BASE_ADDRESS_2,\r\nPCI_BASE_ADDRESS_3,\r\nPCI_BASE_ADDRESS_4,\r\nPCI_BASE_ADDRESS_5,\r\n0\r\n};\r\nstruct res_needed *amount;\r\namount = kzalloc(sizeof(*amount), GFP_KERNEL);\r\nif (amount == NULL)\r\nreturn NULL;\r\nibmphp_pci_bus->number = busno;\r\ndebug ("the bus_no behind the bridge is %x\n", busno);\r\ndebug ("scanning devices behind the bridge...\n");\r\nfor (device = 0; device < 32; device++) {\r\namount->devices[device] = 0;\r\nfor (function = 0; function < 8; function++) {\r\ndevfn = PCI_DEVFN(device, function);\r\npci_bus_read_config_word (ibmphp_pci_bus, devfn, PCI_VENDOR_ID, &vendor_id);\r\nif (vendor_id != PCI_VENDOR_ID_NOTVALID) {\r\nhowmany++;\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_HEADER_TYPE, &hdr_type);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, PCI_CLASS_REVISION, &class);\r\ndebug ("hdr_type behind the bridge is %x\n", hdr_type);\r\nif (hdr_type & PCI_HEADER_TYPE_BRIDGE) {\r\nerr ("embedded bridges not supported for hot-plugging.\n");\r\namount->not_correct = 1;\r\nreturn amount;\r\n}\r\nclass >>= 8;\r\nif (class == PCI_CLASS_NOT_DEFINED_VGA) {\r\nerr ("The device %x is VGA compatible and as is not supported for hot plugging. "\r\n"Please choose another device.\n", device);\r\namount->not_correct = 1;\r\nreturn amount;\r\n} else if (class == PCI_CLASS_DISPLAY_VGA) {\r\nerr ("The device %x is not supported for hot plugging. "\r\n"Please choose another device.\n", device);\r\namount->not_correct = 1;\r\nreturn amount;\r\n}\r\namount->devices[device] = 1;\r\nfor (count = 0; address[count]; count++) {\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], 0xFFFFFFFF);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &bar[count]);\r\ndebug ("what is bar[count]? %x, count = %d\n", bar[count], count);\r\nif (!bar[count])\r\ncontinue;\r\ndebug ("count %d device %x function %x wants %x resources\n", count, device, function, bar[count]);\r\nif (bar[count] & PCI_BASE_ADDRESS_SPACE_IO) {\r\nlen[count] = bar[count] & 0xFFFFFFFC;\r\nlen[count] = ~len[count] + 1;\r\namount->io += len[count];\r\n} else {\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_PREFETCH) {\r\nlen[count] = bar[count] & 0xFFFFFFF0;\r\nlen[count] = ~len[count] + 1;\r\namount->pfmem += len[count];\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64)\r\ncount += 1;\r\n} else {\r\nlen[count] = bar[count] & 0xFFFFFFF0;\r\nlen[count] = ~len[count] + 1;\r\namount->mem += len[count];\r\nif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\ncount += 1;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (!howmany)\r\namount->not_correct = 1;\r\nelse\r\namount->not_correct = 0;\r\nif ((amount->io) && (amount->io < IOBRIDGE))\r\namount->io = IOBRIDGE;\r\nif ((amount->mem) && (amount->mem < MEMBRIDGE))\r\namount->mem = MEMBRIDGE;\r\nif ((amount->pfmem) && (amount->pfmem < MEMBRIDGE))\r\namount->pfmem = MEMBRIDGE;\r\nreturn amount;\r\n}\r\nstatic int unconfigure_boot_device (u8 busno, u8 device, u8 function)\r\n{\r\nu32 start_address;\r\nu32 address[] = {\r\nPCI_BASE_ADDRESS_0,\r\nPCI_BASE_ADDRESS_1,\r\nPCI_BASE_ADDRESS_2,\r\nPCI_BASE_ADDRESS_3,\r\nPCI_BASE_ADDRESS_4,\r\nPCI_BASE_ADDRESS_5,\r\n0\r\n};\r\nint count;\r\nstruct resource_node *io;\r\nstruct resource_node *mem;\r\nstruct resource_node *pfmem;\r\nstruct bus_node *bus;\r\nu32 end_address;\r\nu32 temp_end;\r\nu32 size;\r\nu32 tmp_address;\r\nunsigned int devfn;\r\ndebug ("%s - enter\n", __func__);\r\nbus = ibmphp_find_res_bus (busno);\r\nif (!bus) {\r\ndebug ("cannot find corresponding bus.\n");\r\nreturn -EINVAL;\r\n}\r\ndevfn = PCI_DEVFN(device, function);\r\nibmphp_pci_bus->number = busno;\r\nfor (count = 0; address[count]; count++) {\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &start_address);\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], 0xFFFFFFFF);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &size);\r\npci_bus_write_config_dword (ibmphp_pci_bus, devfn, address[count], start_address);\r\ndebug ("start_address is %x\n", start_address);\r\ndebug ("busno, device, function %x %x %x\n", busno, device, function);\r\nif (!size) {\r\ndebug ("is this bar no implemented?, count = %d\n", count);\r\ncontinue;\r\n}\r\ntmp_address = start_address;\r\nif (start_address & PCI_BASE_ADDRESS_SPACE_IO) {\r\nstart_address &= PCI_BASE_ADDRESS_IO_MASK;\r\nsize = size & 0xFFFFFFFC;\r\nsize = ~size + 1;\r\nend_address = start_address + size - 1;\r\nif (ibmphp_find_resource (bus, start_address, &io, IO) < 0) {\r\nerr ("cannot find corresponding IO resource to remove\n");\r\nreturn -EIO;\r\n}\r\ndebug ("io->start = %x\n", io->start);\r\ntemp_end = io->end;\r\nstart_address = io->end + 1;\r\nibmphp_remove_resource (io);\r\nwhile (temp_end < end_address) {\r\nif (ibmphp_find_resource (bus, start_address, &io, IO) < 0) {\r\nerr ("cannot find corresponding IO resource to remove\n");\r\nreturn -EIO;\r\n}\r\ndebug ("io->start = %x\n", io->start);\r\ntemp_end = io->end;\r\nstart_address = io->end + 1;\r\nibmphp_remove_resource (io);\r\n}\r\n} else {\r\nif (start_address & PCI_BASE_ADDRESS_MEM_PREFETCH) {\r\ndebug ("start address of pfmem is %x\n", start_address);\r\nstart_address &= PCI_BASE_ADDRESS_MEM_MASK;\r\nif (ibmphp_find_resource (bus, start_address, &pfmem, PFMEM) < 0) {\r\nerr ("cannot find corresponding PFMEM resource to remove\n");\r\nreturn -EIO;\r\n}\r\nif (pfmem) {\r\ndebug ("pfmem->start = %x\n", pfmem->start);\r\nibmphp_remove_resource(pfmem);\r\n}\r\n} else {\r\ndebug ("start address of mem is %x\n", start_address);\r\nstart_address &= PCI_BASE_ADDRESS_MEM_MASK;\r\nif (ibmphp_find_resource (bus, start_address, &mem, MEM) < 0) {\r\nerr ("cannot find corresponding MEM resource to remove\n");\r\nreturn -EIO;\r\n}\r\nif (mem) {\r\ndebug ("mem->start = %x\n", mem->start);\r\nibmphp_remove_resource(mem);\r\n}\r\n}\r\nif (tmp_address & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\ncount += 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int unconfigure_boot_bridge (u8 busno, u8 device, u8 function)\r\n{\r\nint count;\r\nint bus_no, pri_no, sub_no, sec_no = 0;\r\nu32 start_address, tmp_address;\r\nu8 sec_number, sub_number, pri_number;\r\nstruct resource_node *io = NULL;\r\nstruct resource_node *mem = NULL;\r\nstruct resource_node *pfmem = NULL;\r\nstruct bus_node *bus;\r\nu32 address[] = {\r\nPCI_BASE_ADDRESS_0,\r\nPCI_BASE_ADDRESS_1,\r\n0\r\n};\r\nunsigned int devfn;\r\ndevfn = PCI_DEVFN(device, function);\r\nibmphp_pci_bus->number = busno;\r\nbus_no = (int) busno;\r\ndebug ("busno is %x\n", busno);\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_PRIMARY_BUS, &pri_number);\r\ndebug ("%s - busno = %x, primary_number = %x\n", __func__, busno, pri_number);\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, &sec_number);\r\ndebug ("sec_number is %x\n", sec_number);\r\nsec_no = (int) sec_number;\r\npri_no = (int) pri_number;\r\nif (pri_no != bus_no) {\r\nerr ("primary numbers in our structures and pci config space don't match.\n");\r\nreturn -EINVAL;\r\n}\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_SUBORDINATE_BUS, &sub_number);\r\nsub_no = (int) sub_number;\r\ndebug ("sub_no is %d, sec_no is %d\n", sub_no, sec_no);\r\nif (sec_no != sub_number) {\r\nerr ("there're more buses behind this bridge. Hot removal is not supported. Please choose another card\n");\r\nreturn -ENODEV;\r\n}\r\nbus = ibmphp_find_res_bus (sec_number);\r\nif (!bus) {\r\nerr ("cannot find Bus structure for the bridged device\n");\r\nreturn -EINVAL;\r\n}\r\ndebug("bus->busno is %x\n", bus->busno);\r\ndebug("sec_number is %x\n", sec_number);\r\nibmphp_remove_bus (bus, busno);\r\nfor (count = 0; address[count]; count++) {\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, address[count], &start_address);\r\nif (!start_address) {\r\ncontinue;\r\n}\r\ntmp_address = start_address;\r\nif (start_address & PCI_BASE_ADDRESS_SPACE_IO) {\r\nstart_address &= PCI_BASE_ADDRESS_IO_MASK;\r\nif (ibmphp_find_resource (bus, start_address, &io, IO) < 0) {\r\nerr ("cannot find corresponding IO resource to remove\n");\r\nreturn -EIO;\r\n}\r\nif (io)\r\ndebug ("io->start = %x\n", io->start);\r\nibmphp_remove_resource (io);\r\n} else {\r\nif (start_address & PCI_BASE_ADDRESS_MEM_PREFETCH) {\r\nstart_address &= PCI_BASE_ADDRESS_MEM_MASK;\r\nif (ibmphp_find_resource (bus, start_address, &pfmem, PFMEM) < 0) {\r\nerr ("cannot find corresponding PFMEM resource to remove\n");\r\nreturn -EINVAL;\r\n}\r\nif (pfmem) {\r\ndebug ("pfmem->start = %x\n", pfmem->start);\r\nibmphp_remove_resource(pfmem);\r\n}\r\n} else {\r\nstart_address &= PCI_BASE_ADDRESS_MEM_MASK;\r\nif (ibmphp_find_resource (bus, start_address, &mem, MEM) < 0) {\r\nerr ("cannot find corresponding MEM resource to remove\n");\r\nreturn -EINVAL;\r\n}\r\nif (mem) {\r\ndebug ("mem->start = %x\n", mem->start);\r\nibmphp_remove_resource(mem);\r\n}\r\n}\r\nif (tmp_address & PCI_BASE_ADDRESS_MEM_TYPE_64) {\r\ncount += 1;\r\n}\r\n}\r\n}\r\ndebug ("%s - exiting, returning success\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int unconfigure_boot_card (struct slot *slot_cur)\r\n{\r\nu16 vendor_id;\r\nu32 class;\r\nu8 hdr_type;\r\nu8 device;\r\nu8 busno;\r\nu8 function;\r\nint rc;\r\nunsigned int devfn;\r\nu8 valid_device = 0x00;\r\ndebug ("%s - enter\n", __func__);\r\ndevice = slot_cur->device;\r\nbusno = slot_cur->bus;\r\ndebug ("b4 for loop, device is %x\n", device);\r\nfor (function = 0x0; function < 0x08; function++) {\r\ndevfn = PCI_DEVFN(device, function);\r\nibmphp_pci_bus->number = busno;\r\npci_bus_read_config_word (ibmphp_pci_bus, devfn, PCI_VENDOR_ID, &vendor_id);\r\nif (vendor_id != PCI_VENDOR_ID_NOTVALID) {\r\n++valid_device;\r\ndebug ("%s - found correct device\n", __func__);\r\npci_bus_read_config_byte (ibmphp_pci_bus, devfn, PCI_HEADER_TYPE, &hdr_type);\r\npci_bus_read_config_dword (ibmphp_pci_bus, devfn, PCI_CLASS_REVISION, &class);\r\ndebug ("hdr_type %x, class %x\n", hdr_type, class);\r\nclass >>= 8;\r\nif (class == PCI_CLASS_NOT_DEFINED_VGA) {\r\nerr ("The device %x function %x is VGA compatible and is not supported for hot removing. "\r\n"Please choose another device.\n", device, function);\r\nreturn -ENODEV;\r\n} else if (class == PCI_CLASS_DISPLAY_VGA) {\r\nerr ("The device %x function %x is not supported for hot removing. "\r\n"Please choose another device.\n", device, function);\r\nreturn -ENODEV;\r\n}\r\nswitch (hdr_type) {\r\ncase PCI_HEADER_TYPE_NORMAL:\r\nrc = unconfigure_boot_device (busno, device, function);\r\nif (rc) {\r\nerr ("was not able to unconfigure device %x func %x on bus %x. bailing out...\n",\r\ndevice, function, busno);\r\nreturn rc;\r\n}\r\nfunction = 0x8;\r\nbreak;\r\ncase PCI_HEADER_TYPE_MULTIDEVICE:\r\nrc = unconfigure_boot_device (busno, device, function);\r\nif (rc) {\r\nerr ("was not able to unconfigure device %x func %x on bus %x. bailing out...\n",\r\ndevice, function, busno);\r\nreturn rc;\r\n}\r\nbreak;\r\ncase PCI_HEADER_TYPE_BRIDGE:\r\nclass >>= 8;\r\nif (class != PCI_CLASS_BRIDGE_PCI) {\r\nerr ("This device %x function %x is not PCI-to-PCI bridge, "\r\n"and is not supported for hot-removing. "\r\n"Please try another card.\n", device, function);\r\nreturn -ENODEV;\r\n}\r\nrc = unconfigure_boot_bridge (busno, device, function);\r\nif (rc != 0) {\r\nerr ("was not able to hot-remove PPB properly.\n");\r\nreturn rc;\r\n}\r\nfunction = 0x8;\r\nbreak;\r\ncase PCI_HEADER_TYPE_MULTIBRIDGE:\r\nclass >>= 8;\r\nif (class != PCI_CLASS_BRIDGE_PCI) {\r\nerr ("This device %x function %x is not PCI-to-PCI bridge, "\r\n"and is not supported for hot-removing. "\r\n"Please try another card.\n", device, function);\r\nreturn -ENODEV;\r\n}\r\nrc = unconfigure_boot_bridge (busno, device, function);\r\nif (rc != 0) {\r\nerr ("was not able to hot-remove PPB properly.\n");\r\nreturn rc;\r\n}\r\nbreak;\r\ndefault:\r\nerr ("MAJOR PROBLEM!!!! Cannot read device's header\n");\r\nreturn -1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!valid_device) {\r\nerr ("Could not find device to unconfigure. Or could not read the card.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint ibmphp_unconfigure_card (struct slot **slot_cur, int the_end)\r\n{\r\nint i;\r\nint count;\r\nint rc;\r\nstruct slot *sl = *slot_cur;\r\nstruct pci_func *cur_func = NULL;\r\nstruct pci_func *temp_func;\r\ndebug ("%s - enter\n", __func__);\r\nif (!the_end) {\r\nrc = unconfigure_boot_card (sl);\r\nif ((rc == -ENODEV) || (rc == -EIO) || (rc == -EINVAL)) {\r\nreturn rc;\r\n}\r\n}\r\nif (sl->func) {\r\ncur_func = sl->func;\r\nwhile (cur_func) {\r\nif (cur_func->bus) {\r\ncount = 2;\r\n} else {\r\ncount = 6;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (cur_func->io[i]) {\r\ndebug ("io[%d] exists\n", i);\r\nif (the_end > 0)\r\nibmphp_remove_resource (cur_func->io[i]);\r\ncur_func->io[i] = NULL;\r\n}\r\nif (cur_func->mem[i]) {\r\ndebug ("mem[%d] exists\n", i);\r\nif (the_end > 0)\r\nibmphp_remove_resource (cur_func->mem[i]);\r\ncur_func->mem[i] = NULL;\r\n}\r\nif (cur_func->pfmem[i]) {\r\ndebug ("pfmem[%d] exists\n", i);\r\nif (the_end > 0)\r\nibmphp_remove_resource (cur_func->pfmem[i]);\r\ncur_func->pfmem[i] = NULL;\r\n}\r\n}\r\ntemp_func = cur_func->next;\r\nkfree (cur_func);\r\ncur_func = temp_func;\r\n}\r\n}\r\nsl->func = NULL;\r\n*slot_cur = sl;\r\ndebug ("%s - exit\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int add_new_bus (struct bus_node *bus, struct resource_node *io, struct resource_node *mem, struct resource_node *pfmem, u8 parent_busno)\r\n{\r\nstruct range_node *io_range = NULL;\r\nstruct range_node *mem_range = NULL;\r\nstruct range_node *pfmem_range = NULL;\r\nstruct bus_node *cur_bus = NULL;\r\nif (parent_busno != 0xFF) {\r\ncur_bus = ibmphp_find_res_bus (parent_busno);\r\nif (!cur_bus) {\r\nerr ("strange, cannot find bus which is supposed to be at the system... something is terribly wrong...\n");\r\nreturn -ENODEV;\r\n}\r\nlist_add (&bus->bus_list, &cur_bus->bus_list);\r\n}\r\nif (io) {\r\nio_range = kzalloc(sizeof(*io_range), GFP_KERNEL);\r\nif (!io_range) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nio_range->start = io->start;\r\nio_range->end = io->end;\r\nio_range->rangeno = 1;\r\nbus->noIORanges = 1;\r\nbus->rangeIO = io_range;\r\n}\r\nif (mem) {\r\nmem_range = kzalloc(sizeof(*mem_range), GFP_KERNEL);\r\nif (!mem_range) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmem_range->start = mem->start;\r\nmem_range->end = mem->end;\r\nmem_range->rangeno = 1;\r\nbus->noMemRanges = 1;\r\nbus->rangeMem = mem_range;\r\n}\r\nif (pfmem) {\r\npfmem_range = kzalloc(sizeof(*pfmem_range), GFP_KERNEL);\r\nif (!pfmem_range) {\r\nerr ("out of system memory\n");\r\nreturn -ENOMEM;\r\n}\r\npfmem_range->start = pfmem->start;\r\npfmem_range->end = pfmem->end;\r\npfmem_range->rangeno = 1;\r\nbus->noPFMemRanges = 1;\r\nbus->rangePFMem = pfmem_range;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 find_sec_number (u8 primary_busno, u8 slotno)\r\n{\r\nint min, max;\r\nu8 busno;\r\nstruct bus_info *bus;\r\nstruct bus_node *bus_cur;\r\nbus = ibmphp_find_same_bus_num (primary_busno);\r\nif (!bus) {\r\nerr ("cannot get slot range of the bus from the BIOS\n");\r\nreturn 0xff;\r\n}\r\nmax = bus->slot_max;\r\nmin = bus->slot_min;\r\nif ((slotno > max) || (slotno < min)) {\r\nerr ("got the wrong range\n");\r\nreturn 0xff;\r\n}\r\nbusno = (u8) (slotno - (u8) min);\r\nbusno += primary_busno + 0x01;\r\nbus_cur = ibmphp_find_res_bus (busno);\r\nif ((!bus_cur) || (!(bus_cur->rangeIO) && !(bus_cur->rangeMem) && !(bus_cur->rangePFMem)))\r\nreturn busno;\r\nreturn 0xff;\r\n}
