static int lm3530_get_mode_from_str(const char *str)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mode_map); i++)\r\nif (sysfs_streq(str, mode_map[i].mode))\r\nreturn mode_map[i].mode_val;\r\nreturn -EINVAL;\r\n}\r\nstatic void lm3530_als_configure(struct lm3530_platform_data *pdata,\r\nstruct lm3530_als_data *als)\r\n{\r\nint i;\r\nu32 als_vmin, als_vmax, als_vstep;\r\nif (pdata->als_vmax == 0) {\r\npdata->als_vmin = 0;\r\npdata->als_vmax = LM3530_ALS_WINDOW_mV;\r\n}\r\nals_vmin = pdata->als_vmin;\r\nals_vmax = pdata->als_vmax;\r\nif ((als_vmax - als_vmin) > LM3530_ALS_WINDOW_mV)\r\npdata->als_vmax = als_vmax = als_vmin + LM3530_ALS_WINDOW_mV;\r\nals_vstep = (als_vmax - als_vmin) / (LM3530_ALS_ZB_MAX + 1);\r\nfor (i = 0; i < LM3530_ALS_ZB_MAX; i++)\r\nals->zones[i] = (((als_vmin + LM3530_ALS_OFFSET_mV) +\r\nals_vstep + (i * als_vstep)) * LED_FULL) / 1000;\r\nals->config =\r\n(pdata->als_avrg_time << LM3530_ALS_AVG_TIME_SHIFT) |\r\n(LM3530_ENABLE_ALS) |\r\n(pdata->als_input_mode << LM3530_ALS_SEL_SHIFT);\r\nals->imp_sel =\r\n(pdata->als1_resistor_sel << LM3530_ALS1_IMP_SHIFT) |\r\n(pdata->als2_resistor_sel << LM3530_ALS2_IMP_SHIFT);\r\n}\r\nstatic int lm3530_led_enable(struct lm3530_data *drvdata)\r\n{\r\nint ret;\r\nif (drvdata->enable)\r\nreturn 0;\r\nret = regulator_enable(drvdata->regulator);\r\nif (ret) {\r\ndev_err(drvdata->led_dev.dev, "Failed to enable vin:%d\n", ret);\r\nreturn ret;\r\n}\r\ndrvdata->enable = true;\r\nreturn 0;\r\n}\r\nstatic void lm3530_led_disable(struct lm3530_data *drvdata)\r\n{\r\nint ret;\r\nif (!drvdata->enable)\r\nreturn;\r\nret = regulator_disable(drvdata->regulator);\r\nif (ret) {\r\ndev_err(drvdata->led_dev.dev, "Failed to disable vin:%d\n",\r\nret);\r\nreturn;\r\n}\r\ndrvdata->enable = false;\r\n}\r\nstatic int lm3530_init_registers(struct lm3530_data *drvdata)\r\n{\r\nint ret = 0;\r\nint i;\r\nu8 gen_config;\r\nu8 brt_ramp;\r\nu8 brightness;\r\nu8 reg_val[LM3530_REG_MAX];\r\nstruct lm3530_platform_data *pdata = drvdata->pdata;\r\nstruct i2c_client *client = drvdata->client;\r\nstruct lm3530_pwm_data *pwm = &pdata->pwm_data;\r\nstruct lm3530_als_data als;\r\nmemset(&als, 0, sizeof(struct lm3530_als_data));\r\ngen_config = (pdata->brt_ramp_law << LM3530_RAMP_LAW_SHIFT) |\r\n((pdata->max_current & 7) << LM3530_MAX_CURR_SHIFT);\r\nswitch (drvdata->mode) {\r\ncase LM3530_BL_MODE_MANUAL:\r\ngen_config |= LM3530_ENABLE_I2C;\r\nbreak;\r\ncase LM3530_BL_MODE_ALS:\r\ngen_config |= LM3530_ENABLE_I2C;\r\nlm3530_als_configure(pdata, &als);\r\nbreak;\r\ncase LM3530_BL_MODE_PWM:\r\ngen_config |= LM3530_ENABLE_PWM | LM3530_ENABLE_PWM_SIMPLE |\r\n(pdata->pwm_pol_hi << LM3530_PWM_POL_SHIFT);\r\nbreak;\r\n}\r\nbrt_ramp = (pdata->brt_ramp_fall << LM3530_BRT_RAMP_FALL_SHIFT) |\r\n(pdata->brt_ramp_rise << LM3530_BRT_RAMP_RISE_SHIFT);\r\nif (drvdata->brightness)\r\nbrightness = drvdata->brightness;\r\nelse\r\nbrightness = drvdata->brightness = pdata->brt_val;\r\nif (brightness > drvdata->led_dev.max_brightness)\r\nbrightness = drvdata->led_dev.max_brightness;\r\nreg_val[0] = gen_config;\r\nreg_val[1] = als.config;\r\nreg_val[2] = brt_ramp;\r\nreg_val[3] = als.imp_sel;\r\nreg_val[4] = brightness;\r\nreg_val[5] = als.zones[0];\r\nreg_val[6] = als.zones[1];\r\nreg_val[7] = als.zones[2];\r\nreg_val[8] = als.zones[3];\r\nreg_val[9] = LM3530_DEF_ZT_0;\r\nreg_val[10] = LM3530_DEF_ZT_1;\r\nreg_val[11] = LM3530_DEF_ZT_2;\r\nreg_val[12] = LM3530_DEF_ZT_3;\r\nreg_val[13] = LM3530_DEF_ZT_4;\r\nret = lm3530_led_enable(drvdata);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < LM3530_REG_MAX; i++) {\r\nif (lm3530_reg[i] == LM3530_BRT_CTRL_REG &&\r\ndrvdata->mode == LM3530_BL_MODE_PWM) {\r\nif (pwm->pwm_set_intensity)\r\npwm->pwm_set_intensity(reg_val[i],\r\ndrvdata->led_dev.max_brightness);\r\ncontinue;\r\n}\r\nret = i2c_smbus_write_byte_data(client,\r\nlm3530_reg[i], reg_val[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void lm3530_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brt_val)\r\n{\r\nint err;\r\nstruct lm3530_data *drvdata =\r\ncontainer_of(led_cdev, struct lm3530_data, led_dev);\r\nstruct lm3530_platform_data *pdata = drvdata->pdata;\r\nstruct lm3530_pwm_data *pwm = &pdata->pwm_data;\r\nu8 max_brightness = led_cdev->max_brightness;\r\nswitch (drvdata->mode) {\r\ncase LM3530_BL_MODE_MANUAL:\r\nif (!drvdata->enable) {\r\nerr = lm3530_init_registers(drvdata);\r\nif (err) {\r\ndev_err(&drvdata->client->dev,\r\n"Register Init failed: %d\n", err);\r\nbreak;\r\n}\r\n}\r\nerr = i2c_smbus_write_byte_data(drvdata->client,\r\nLM3530_BRT_CTRL_REG, brt_val);\r\nif (err)\r\ndev_err(&drvdata->client->dev,\r\n"Unable to set brightness: %d\n", err);\r\nelse\r\ndrvdata->brightness = brt_val;\r\nif (brt_val == 0)\r\nlm3530_led_disable(drvdata);\r\nbreak;\r\ncase LM3530_BL_MODE_ALS:\r\nbreak;\r\ncase LM3530_BL_MODE_PWM:\r\nif (pwm->pwm_set_intensity)\r\npwm->pwm_set_intensity(brt_val, max_brightness);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t lm3530_mode_get(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3530_data *drvdata;\r\nint i, len = 0;\r\ndrvdata = container_of(led_cdev, struct lm3530_data, led_dev);\r\nfor (i = 0; i < ARRAY_SIZE(mode_map); i++)\r\nif (drvdata->mode == mode_map[i].mode_val)\r\nlen += sprintf(buf + len, "[%s] ", mode_map[i].mode);\r\nelse\r\nlen += sprintf(buf + len, "%s ", mode_map[i].mode);\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t lm3530_mode_set(struct device *dev, struct device_attribute\r\n*attr, const char *buf, size_t size)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3530_data *drvdata;\r\nstruct lm3530_pwm_data *pwm;\r\nu8 max_brightness;\r\nint mode, err;\r\ndrvdata = container_of(led_cdev, struct lm3530_data, led_dev);\r\npwm = &drvdata->pdata->pwm_data;\r\nmax_brightness = led_cdev->max_brightness;\r\nmode = lm3530_get_mode_from_str(buf);\r\nif (mode < 0) {\r\ndev_err(dev, "Invalid mode\n");\r\nreturn mode;\r\n}\r\ndrvdata->mode = mode;\r\nif (mode != LM3530_BL_MODE_PWM && pwm->pwm_set_intensity)\r\npwm->pwm_set_intensity(0, max_brightness);\r\nerr = lm3530_init_registers(drvdata);\r\nif (err) {\r\ndev_err(dev, "Setting %s Mode failed :%d\n", buf, err);\r\nreturn err;\r\n}\r\nreturn sizeof(drvdata->mode);\r\n}\r\nstatic int lm3530_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm3530_platform_data *pdata = client->dev.platform_data;\r\nstruct lm3530_data *drvdata;\r\nint err = 0;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "platform data required\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdata->mode > LM3530_BL_MODE_PWM) {\r\ndev_err(&client->dev, "Illegal Mode request\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "I2C_FUNC_I2C not supported\n");\r\nreturn -EIO;\r\n}\r\ndrvdata = devm_kzalloc(&client->dev, sizeof(struct lm3530_data),\r\nGFP_KERNEL);\r\nif (drvdata == NULL)\r\nreturn -ENOMEM;\r\ndrvdata->mode = pdata->mode;\r\ndrvdata->client = client;\r\ndrvdata->pdata = pdata;\r\ndrvdata->brightness = LED_OFF;\r\ndrvdata->enable = false;\r\ndrvdata->led_dev.name = LM3530_LED_DEV;\r\ndrvdata->led_dev.brightness_set = lm3530_brightness_set;\r\ndrvdata->led_dev.max_brightness = MAX_BRIGHTNESS;\r\ni2c_set_clientdata(client, drvdata);\r\ndrvdata->regulator = devm_regulator_get(&client->dev, "vin");\r\nif (IS_ERR(drvdata->regulator)) {\r\ndev_err(&client->dev, "regulator get failed\n");\r\nerr = PTR_ERR(drvdata->regulator);\r\ndrvdata->regulator = NULL;\r\nreturn err;\r\n}\r\nif (drvdata->pdata->brt_val) {\r\nerr = lm3530_init_registers(drvdata);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"Register Init failed: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nerr = led_classdev_register(&client->dev, &drvdata->led_dev);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Register led class failed: %d\n", err);\r\nreturn err;\r\n}\r\nerr = device_create_file(drvdata->led_dev.dev, &dev_attr_mode);\r\nif (err < 0) {\r\ndev_err(&client->dev, "File device creation failed: %d\n", err);\r\nerr = -ENODEV;\r\ngoto err_create_file;\r\n}\r\nreturn 0;\r\nerr_create_file:\r\nled_classdev_unregister(&drvdata->led_dev);\r\nreturn err;\r\n}\r\nstatic int lm3530_remove(struct i2c_client *client)\r\n{\r\nstruct lm3530_data *drvdata = i2c_get_clientdata(client);\r\ndevice_remove_file(drvdata->led_dev.dev, &dev_attr_mode);\r\nlm3530_led_disable(drvdata);\r\nled_classdev_unregister(&drvdata->led_dev);\r\nreturn 0;\r\n}
