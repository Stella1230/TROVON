static acpi_status\r\nis_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint *count = (int *)context;\r\nif (is_dock_device(handle)) {\r\n(*count)++;\r\nreturn AE_CTRL_TERMINATE;\r\n} else {\r\nreturn AE_OK;\r\n}\r\n}\r\nstatic inline void get_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nkref_get(&bridge->ref);\r\n}\r\nstatic inline void put_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nkref_put(&bridge->ref, free_bridge);\r\n}\r\nstatic void free_bridge(struct kref *kref)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nstruct acpiphp_slot *slot, *next;\r\nstruct acpiphp_func *func, *tmp;\r\nbridge = container_of(kref, struct acpiphp_bridge, ref);\r\nlist_for_each_entry_safe(slot, next, &bridge->slots, node) {\r\nlist_for_each_entry_safe(func, tmp, &slot->funcs, sibling) {\r\nkfree(func);\r\n}\r\nkfree(slot);\r\n}\r\nif ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func)\r\nput_bridge(bridge->func->slot->bridge);\r\nput_device(&bridge->pci_bus->dev);\r\npci_dev_put(bridge->pci_dev);\r\nkfree(bridge);\r\n}\r\nstatic int post_dock_fixups(struct notifier_block *nb, unsigned long val,\r\nvoid *v)\r\n{\r\nstruct acpiphp_func *func = container_of(nb, struct acpiphp_func, nb);\r\nstruct pci_bus *bus = func->slot->bridge->pci_bus;\r\nu32 buses;\r\nif (!bus->self)\r\nreturn NOTIFY_OK;\r\npci_read_config_dword(bus->self,\r\nPCI_PRIMARY_BUS,\r\n&buses);\r\nif (((buses >> 8) & 0xff) != bus->busn_res.start) {\r\nbuses = (buses & 0xff000000)\r\n| ((unsigned int)(bus->primary) << 0)\r\n| ((unsigned int)(bus->busn_res.start) << 8)\r\n| ((unsigned int)(bus->busn_res.end) << 16);\r\npci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic bool device_is_managed_by_native_pciehp(struct pci_dev *pdev)\r\n{\r\nu32 reg32;\r\nacpi_handle tmp;\r\nstruct acpi_pci_root *root;\r\nif (pcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &reg32))\r\nreturn false;\r\nif (!(reg32 & PCI_EXP_SLTCAP_HPC))\r\nreturn false;\r\ntmp = acpi_find_root_bridge_handle(pdev);\r\nif (!tmp)\r\nreturn false;\r\nroot = acpi_pci_find_root(tmp);\r\nif (!root)\r\nreturn false;\r\nif (!(root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void acpiphp_dock_init(void *data)\r\n{\r\nstruct acpiphp_func *func = data;\r\nget_bridge(func->slot->bridge);\r\n}\r\nstatic void acpiphp_dock_release(void *data)\r\n{\r\nstruct acpiphp_func *func = data;\r\nput_bridge(func->slot->bridge);\r\n}\r\nstatic acpi_status\r\nregister_slot(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nstruct acpiphp_bridge *bridge = (struct acpiphp_bridge *)context;\r\nstruct acpiphp_slot *slot;\r\nstruct acpiphp_func *newfunc;\r\nacpi_handle tmp;\r\nacpi_status status = AE_OK;\r\nunsigned long long adr, sun;\r\nint device, function, retval, found = 0;\r\nstruct pci_bus *pbus = bridge->pci_bus;\r\nstruct pci_dev *pdev;\r\nu32 val;\r\nif (!acpi_pci_check_ejectable(pbus, handle) && !is_dock_device(handle))\r\nreturn AE_OK;\r\nstatus = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);\r\nif (ACPI_FAILURE(status)) {\r\nwarn("can't evaluate _ADR (%#x)\n", status);\r\nreturn AE_OK;\r\n}\r\ndevice = (adr >> 16) & 0xffff;\r\nfunction = adr & 0xffff;\r\npdev = bridge->pci_dev;\r\nif (pdev && device_is_managed_by_native_pciehp(pdev))\r\nreturn AE_OK;\r\nnewfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);\r\nif (!newfunc)\r\nreturn AE_NO_MEMORY;\r\nnewfunc->handle = handle;\r\nnewfunc->function = function;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))\r\nnewfunc->flags = FUNC_HAS_EJ0;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))\r\nnewfunc->flags |= FUNC_HAS_STA;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))\r\nnewfunc->flags |= FUNC_HAS_PS0;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))\r\nnewfunc->flags |= FUNC_HAS_PS3;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))\r\nnewfunc->flags |= FUNC_HAS_DCK;\r\nstatus = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);\r\nif (ACPI_FAILURE(status)) {\r\nsun = bridge->nr_slots+1;\r\n}\r\nlist_for_each_entry(slot, &bridge->slots, node)\r\nif (slot->device == device) {\r\nif (slot->sun != sun)\r\nwarn("sibling found, but _SUN doesn't match!\n");\r\nfound = 1;\r\nbreak;\r\n}\r\nif (!found) {\r\nslot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);\r\nif (!slot) {\r\nkfree(newfunc);\r\nreturn AE_NO_MEMORY;\r\n}\r\nslot->bridge = bridge;\r\nslot->device = device;\r\nslot->sun = sun;\r\nINIT_LIST_HEAD(&slot->funcs);\r\nmutex_init(&slot->crit_sect);\r\nmutex_lock(&bridge_mutex);\r\nlist_add_tail(&slot->node, &bridge->slots);\r\nmutex_unlock(&bridge_mutex);\r\nbridge->nr_slots++;\r\ndbg("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",\r\nslot->sun, pci_domain_nr(pbus), pbus->number, device);\r\nretval = acpiphp_register_hotplug_slot(slot);\r\nif (retval) {\r\nif (retval == -EBUSY)\r\nwarn("Slot %llu already registered by another "\r\n"hotplug driver\n", slot->sun);\r\nelse\r\nwarn("acpiphp_register_hotplug_slot failed "\r\n"(err code = 0x%x)\n", retval);\r\ngoto err_exit;\r\n}\r\n}\r\nnewfunc->slot = slot;\r\nmutex_lock(&bridge_mutex);\r\nlist_add_tail(&newfunc->sibling, &slot->funcs);\r\nmutex_unlock(&bridge_mutex);\r\nif (pci_bus_read_dev_vendor_id(pbus, PCI_DEVFN(device, function),\r\n&val, 60*1000))\r\nslot->flags |= (SLOT_ENABLED | SLOT_POWEREDON);\r\nif (is_dock_device(handle)) {\r\nnewfunc->flags &= ~FUNC_HAS_EJ0;\r\nif (register_hotplug_dock_device(handle,\r\n&acpiphp_dock_ops, newfunc,\r\nacpiphp_dock_init, acpiphp_dock_release))\r\ndbg("failed to register dock device\n");\r\nnewfunc->nb.notifier_call = post_dock_fixups;\r\nif (register_dock_notifier(&newfunc->nb))\r\ndbg("failed to register a dock notifier");\r\n}\r\nif (!(newfunc->flags & FUNC_HAS_DCK)) {\r\nstatus = acpi_install_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_func,\r\nnewfunc);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to register interrupt notify handler\n");\r\n} else\r\nstatus = AE_OK;\r\nreturn status;\r\nerr_exit:\r\nbridge->nr_slots--;\r\nmutex_lock(&bridge_mutex);\r\nlist_del(&slot->node);\r\nmutex_unlock(&bridge_mutex);\r\nkfree(slot);\r\nkfree(newfunc);\r\nreturn AE_OK;\r\n}\r\nstatic int detect_ejectable_slots(acpi_handle handle)\r\n{\r\nint found = acpi_pci_detect_ejectable(handle);\r\nif (!found) {\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\nis_pci_dock_device, NULL, (void *)&found, NULL);\r\n}\r\nreturn found;\r\n}\r\nstatic void init_bridge_misc(struct acpiphp_bridge *bridge)\r\n{\r\nacpi_status status;\r\nmutex_lock(&bridge_mutex);\r\nlist_add(&bridge->list, &bridge_list);\r\nmutex_unlock(&bridge_mutex);\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, bridge->handle, (u32)1,\r\nregister_slot, NULL, bridge, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nmutex_lock(&bridge_mutex);\r\nlist_del(&bridge->list);\r\nmutex_unlock(&bridge_mutex);\r\nreturn;\r\n}\r\nif (!pci_is_root_bus(bridge->pci_bus)) {\r\nif ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {\r\nstatus = acpi_remove_notify_handler(bridge->func->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_func);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to remove notify handler\n");\r\n}\r\nstatus = acpi_install_notify_handler(bridge->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_bridge,\r\nbridge);\r\nif (ACPI_FAILURE(status)) {\r\nerr("failed to register interrupt notify handler\n");\r\n}\r\n}\r\n}\r\nstatic struct acpiphp_func *acpiphp_bridge_handle_to_function(acpi_handle handle)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nstruct acpiphp_slot *slot;\r\nstruct acpiphp_func *func = NULL;\r\nmutex_lock(&bridge_mutex);\r\nlist_for_each_entry(bridge, &bridge_list, list) {\r\nlist_for_each_entry(slot, &bridge->slots, node) {\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->handle == handle) {\r\nget_bridge(func->slot->bridge);\r\nmutex_unlock(&bridge_mutex);\r\nreturn func;\r\n}\r\n}\r\n}\r\n}\r\nmutex_unlock(&bridge_mutex);\r\nreturn NULL;\r\n}\r\nstatic struct acpiphp_bridge *acpiphp_handle_to_bridge(acpi_handle handle)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nmutex_lock(&bridge_mutex);\r\nlist_for_each_entry(bridge, &bridge_list, list)\r\nif (bridge->handle == handle) {\r\nget_bridge(bridge);\r\nmutex_unlock(&bridge_mutex);\r\nreturn bridge;\r\n}\r\nmutex_unlock(&bridge_mutex);\r\nreturn NULL;\r\n}\r\nstatic void cleanup_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nstruct acpiphp_slot *slot;\r\nstruct acpiphp_func *func;\r\nacpi_status status;\r\nacpi_handle handle = bridge->handle;\r\nif (!pci_is_root_bus(bridge->pci_bus)) {\r\nstatus = acpi_remove_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_bridge);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to remove notify handler\n");\r\n}\r\nif ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {\r\nstatus = acpi_install_notify_handler(bridge->func->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_func,\r\nbridge->func);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to install interrupt notify handler\n");\r\n}\r\nlist_for_each_entry(slot, &bridge->slots, node) {\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (is_dock_device(func->handle)) {\r\nunregister_hotplug_dock_device(func->handle);\r\nunregister_dock_notifier(&func->nb);\r\n}\r\nif (!(func->flags & FUNC_HAS_DCK)) {\r\nstatus = acpi_remove_notify_handler(func->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_func);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to remove notify handler\n");\r\n}\r\n}\r\nacpiphp_unregister_hotplug_slot(slot);\r\n}\r\nmutex_lock(&bridge_mutex);\r\nlist_del(&bridge->list);\r\nmutex_unlock(&bridge_mutex);\r\n}\r\nstatic int power_on_slot(struct acpiphp_slot *slot)\r\n{\r\nacpi_status status;\r\nstruct acpiphp_func *func;\r\nint retval = 0;\r\nif (slot->flags & SLOT_POWEREDON)\r\ngoto err_exit;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->flags & FUNC_HAS_PS0) {\r\ndbg("%s: executing _PS0\n", __func__);\r\nstatus = acpi_evaluate_object(func->handle, "_PS0", NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nwarn("%s: _PS0 failed\n", __func__);\r\nretval = -1;\r\ngoto err_exit;\r\n} else\r\nbreak;\r\n}\r\n}\r\nslot->flags |= SLOT_POWEREDON;\r\nerr_exit:\r\nreturn retval;\r\n}\r\nstatic int power_off_slot(struct acpiphp_slot *slot)\r\n{\r\nacpi_status status;\r\nstruct acpiphp_func *func;\r\nint retval = 0;\r\nif ((slot->flags & SLOT_POWEREDON) == 0)\r\ngoto err_exit;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->flags & FUNC_HAS_PS3) {\r\nstatus = acpi_evaluate_object(func->handle, "_PS3", NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nwarn("%s: _PS3 failed\n", __func__);\r\nretval = -1;\r\ngoto err_exit;\r\n} else\r\nbreak;\r\n}\r\n}\r\nslot->flags &= (~SLOT_POWEREDON);\r\nerr_exit:\r\nreturn retval;\r\n}\r\nstatic unsigned char acpiphp_max_busnr(struct pci_bus *bus)\r\n{\r\nstruct list_head *tmp;\r\nunsigned char max, n;\r\nmax = bus->busn_res.start;\r\nlist_for_each(tmp, &bus->children) {\r\nn = pci_bus_max_busnr(pci_bus_b(tmp));\r\nif (n > max)\r\nmax = n;\r\n}\r\nreturn max;\r\n}\r\nstatic int acpiphp_bus_add(struct acpiphp_func *func)\r\n{\r\nstruct acpi_device *device;\r\nint ret_val;\r\nif (!acpi_bus_get_device(func->handle, &device)) {\r\ndbg("bus exists... trim\n");\r\nacpi_bus_trim(device);\r\n}\r\nret_val = acpi_bus_scan(func->handle);\r\nif (!ret_val)\r\nret_val = acpi_bus_get_device(func->handle, &device);\r\nif (ret_val)\r\ndbg("error adding bus, %x\n", -ret_val);\r\nreturn ret_val;\r\n}\r\nstatic int acpiphp_bus_trim(acpi_handle handle)\r\n{\r\nstruct acpi_device *device;\r\nint retval;\r\nretval = acpi_bus_get_device(handle, &device);\r\nif (retval) {\r\ndbg("acpi_device not found\n");\r\nreturn retval;\r\n}\r\nacpi_bus_trim(device);\r\nreturn 0;\r\n}\r\nstatic void acpiphp_set_acpi_region(struct acpiphp_slot *slot)\r\n{\r\nstruct acpiphp_func *func;\r\nunion acpi_object params[2];\r\nstruct acpi_object_list arg_list;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\narg_list.count = 2;\r\narg_list.pointer = params;\r\nparams[0].type = ACPI_TYPE_INTEGER;\r\nparams[0].integer.value = ACPI_ADR_SPACE_PCI_CONFIG;\r\nparams[1].type = ACPI_TYPE_INTEGER;\r\nparams[1].integer.value = 1;\r\nacpi_evaluate_object(func->handle, "_REG", &arg_list, NULL);\r\n}\r\n}\r\nstatic void check_hotplug_bridge(struct acpiphp_slot *slot, struct pci_dev *dev)\r\n{\r\nstruct acpiphp_func *func;\r\nif (!dev->subordinate)\r\nreturn;\r\nif (dev->is_hotplug_bridge)\r\nreturn;\r\nif (PCI_SLOT(dev->devfn) != slot->device)\r\nreturn;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (PCI_FUNC(dev->devfn) == func->function) {\r\nif ((detect_ejectable_slots(func->handle) > 0))\r\ndev->is_hotplug_bridge = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int __ref enable_device(struct acpiphp_slot *slot)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_bus *bus = slot->bridge->pci_bus;\r\nstruct acpiphp_func *func;\r\nint num, max, pass;\r\nLIST_HEAD(add_list);\r\nif (slot->flags & SLOT_ENABLED)\r\ngoto err_exit;\r\nlist_for_each_entry(func, &slot->funcs, sibling)\r\nacpiphp_bus_add(func);\r\nnum = pci_scan_slot(bus, PCI_DEVFN(slot->device, 0));\r\nif (num == 0) {\r\ndbg("No new device found\n");\r\ngoto err_exit;\r\n}\r\nmax = acpiphp_max_busnr(bus);\r\nfor (pass = 0; pass < 2; pass++) {\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) != slot->device)\r\ncontinue;\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||\r\ndev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {\r\nmax = pci_scan_bridge(bus, dev, max, pass);\r\nif (pass && dev->subordinate) {\r\ncheck_hotplug_bridge(slot, dev);\r\npcibios_resource_survey_bus(dev->subordinate);\r\n__pci_bus_size_bridges(dev->subordinate,\r\n&add_list);\r\n}\r\n}\r\n}\r\n}\r\n__pci_bus_assign_resources(bus, &add_list, NULL);\r\nacpiphp_sanitize_bus(bus);\r\nacpiphp_set_hpp_values(bus);\r\nacpiphp_set_acpi_region(slot);\r\npci_enable_bridges(bus);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (!dev->is_added)\r\ndev->current_state = PCI_D0;\r\n}\r\npci_bus_add_devices(bus);\r\nslot->flags |= SLOT_ENABLED;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\ndev = pci_get_slot(bus, PCI_DEVFN(slot->device,\r\nfunc->function));\r\nif (!dev) {\r\nslot->flags &= (~SLOT_ENABLED);\r\ncontinue;\r\n}\r\n}\r\nerr_exit:\r\nreturn 0;\r\n}\r\nstatic struct pci_dev *dev_in_slot(struct acpiphp_slot *slot)\r\n{\r\nstruct pci_bus *bus = slot->bridge->pci_bus;\r\nstruct pci_dev *dev;\r\nstruct pci_dev *ret = NULL;\r\ndown_read(&pci_bus_sem);\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\nif (PCI_SLOT(dev->devfn) == slot->device) {\r\nret = pci_dev_get(dev);\r\nbreak;\r\n}\r\nup_read(&pci_bus_sem);\r\nreturn ret;\r\n}\r\nstatic int disable_device(struct acpiphp_slot *slot)\r\n{\r\nstruct acpiphp_func *func;\r\nstruct pci_dev *pdev;\r\nwhile ((pdev = dev_in_slot(slot))) {\r\npci_stop_and_remove_bus_device(pdev);\r\npci_dev_put(pdev);\r\n}\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nacpiphp_bus_trim(func->handle);\r\n}\r\nslot->flags &= (~SLOT_ENABLED);\r\nreturn 0;\r\n}\r\nstatic unsigned int get_slot_status(struct acpiphp_slot *slot)\r\n{\r\nacpi_status status;\r\nunsigned long long sta = 0;\r\nu32 dvid;\r\nstruct acpiphp_func *func;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->flags & FUNC_HAS_STA) {\r\nstatus = acpi_evaluate_integer(func->handle, "_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && sta)\r\nbreak;\r\n} else {\r\npci_bus_read_config_dword(slot->bridge->pci_bus,\r\nPCI_DEVFN(slot->device,\r\nfunc->function),\r\nPCI_VENDOR_ID, &dvid);\r\nif (dvid != 0xffffffff) {\r\nsta = ACPI_STA_ALL;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn (unsigned int)sta;\r\n}\r\nint acpiphp_eject_slot(struct acpiphp_slot *slot)\r\n{\r\nacpi_status status;\r\nstruct acpiphp_func *func;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif ((func->flags & FUNC_HAS_EJ0)) {\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = 1;\r\nstatus = acpi_evaluate_object(func->handle, "_EJ0", &arg_list, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nwarn("%s: _EJ0 failed\n", __func__);\r\nreturn -1;\r\n} else\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpiphp_check_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nstruct acpiphp_slot *slot;\r\nint retval = 0;\r\nint enabled, disabled;\r\nenabled = disabled = 0;\r\nlist_for_each_entry(slot, &bridge->slots, node) {\r\nunsigned int status = get_slot_status(slot);\r\nif (slot->flags & SLOT_ENABLED) {\r\nif (status == ACPI_STA_ALL)\r\ncontinue;\r\nretval = acpiphp_disable_slot(slot);\r\nif (retval) {\r\nerr("Error occurred in disabling\n");\r\ngoto err_exit;\r\n} else {\r\nacpiphp_eject_slot(slot);\r\n}\r\ndisabled++;\r\n} else {\r\nif (status != ACPI_STA_ALL)\r\ncontinue;\r\nretval = acpiphp_enable_slot(slot);\r\nif (retval) {\r\nerr("Error occurred in enabling\n");\r\ngoto err_exit;\r\n}\r\nenabled++;\r\n}\r\n}\r\ndbg("%s: %d enabled, %d disabled\n", __func__, enabled, disabled);\r\nerr_exit:\r\nreturn retval;\r\n}\r\nstatic void acpiphp_set_hpp_values(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\npci_configure_slot(dev);\r\n}\r\nstatic void acpiphp_sanitize_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev, *tmp;\r\nint i;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM;\r\nlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {\r\nfor (i=0; i<PCI_BRIDGE_RESOURCES; i++) {\r\nstruct resource *res = &dev->resource[i];\r\nif ((res->flags & type_mask) && !res->start &&\r\nres->end) {\r\npci_stop_and_remove_bus_device(dev);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic acpi_status\r\ncheck_sub_bridges(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nchar objname[64];\r\nstruct acpi_buffer buffer = { .length = sizeof(objname),\r\n.pointer = objname };\r\nbridge = acpiphp_handle_to_bridge(handle);\r\nif (bridge) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\ndbg("%s: re-enumerating slots under %s\n",\r\n__func__, objname);\r\nacpiphp_check_bridge(bridge);\r\nput_bridge(bridge);\r\n}\r\nreturn AE_OK ;\r\n}\r\nvoid acpiphp_check_host_bridge(acpi_handle handle)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nbridge = acpiphp_handle_to_bridge(handle);\r\nif (bridge) {\r\nacpiphp_check_bridge(bridge);\r\nput_bridge(bridge);\r\n}\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle,\r\nACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);\r\n}\r\nstatic void _handle_hotplug_event_bridge(struct work_struct *work)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nchar objname[64];\r\nstruct acpi_buffer buffer = { .length = sizeof(objname),\r\n.pointer = objname };\r\nstruct acpi_hp_work *hp_work;\r\nacpi_handle handle;\r\nu32 type;\r\nhp_work = container_of(work, struct acpi_hp_work, work);\r\nhandle = hp_work->handle;\r\ntype = hp_work->type;\r\nbridge = (struct acpiphp_bridge *)hp_work->context;\r\nacpi_scan_lock_acquire();\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\nswitch (type) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ndbg("%s: Bus check notify on %s\n", __func__, objname);\r\ndbg("%s: re-enumerating slots under %s\n", __func__, objname);\r\nacpiphp_check_bridge(bridge);\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle,\r\nACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\ndbg("%s: Device check notify on %s\n", __func__, objname);\r\nacpiphp_check_bridge(bridge);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_WAKE:\r\ndbg("%s: Device wake notify on %s\n", __func__, objname);\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\ndbg("%s: Device eject notify on %s\n", __func__, objname);\r\nif ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {\r\nstruct acpiphp_slot *slot;\r\nslot = bridge->func->slot;\r\nif (!acpiphp_disable_slot(slot))\r\nacpiphp_eject_slot(slot);\r\n}\r\nbreak;\r\ncase ACPI_NOTIFY_FREQUENCY_MISMATCH:\r\nprintk(KERN_ERR "Device %s cannot be configured due"\r\n" to a frequency mismatch\n", objname);\r\nbreak;\r\ncase ACPI_NOTIFY_BUS_MODE_MISMATCH:\r\nprintk(KERN_ERR "Device %s cannot be configured due"\r\n" to a bus mode mismatch\n", objname);\r\nbreak;\r\ncase ACPI_NOTIFY_POWER_FAULT:\r\nprintk(KERN_ERR "Device %s has suffered a power fault\n",\r\nobjname);\r\nbreak;\r\ndefault:\r\nwarn("notify_handler: unknown event type 0x%x for %s\n", type, objname);\r\nbreak;\r\n}\r\nacpi_scan_lock_release();\r\nkfree(hp_work);\r\nput_bridge(bridge);\r\n}\r\nstatic void handle_hotplug_event_bridge(acpi_handle handle, u32 type,\r\nvoid *context)\r\n{\r\nstruct acpiphp_bridge *bridge = context;\r\nget_bridge(bridge);\r\nalloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);\r\n}\r\nstatic void hotplug_event_func(acpi_handle handle, u32 type, void *context)\r\n{\r\nstruct acpiphp_func *func = context;\r\nchar objname[64];\r\nstruct acpi_buffer buffer = { .length = sizeof(objname),\r\n.pointer = objname };\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\nswitch (type) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ndbg("%s: Bus check notify on %s\n", __func__, objname);\r\nacpiphp_enable_slot(func->slot);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\ndbg("%s: Device check notify on %s\n", __func__, objname);\r\nacpiphp_check_bridge(func->slot->bridge);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_WAKE:\r\ndbg("%s: Device wake notify on %s\n", __func__, objname);\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\ndbg("%s: Device eject notify on %s\n", __func__, objname);\r\nif (!(acpiphp_disable_slot(func->slot)))\r\nacpiphp_eject_slot(func->slot);\r\nbreak;\r\ndefault:\r\nwarn("notify_handler: unknown event type 0x%x for %s\n", type, objname);\r\nbreak;\r\n}\r\n}\r\nstatic void _handle_hotplug_event_func(struct work_struct *work)\r\n{\r\nstruct acpi_hp_work *hp_work;\r\nstruct acpiphp_func *func;\r\nhp_work = container_of(work, struct acpi_hp_work, work);\r\nfunc = hp_work->context;\r\nacpi_scan_lock_acquire();\r\nhotplug_event_func(hp_work->handle, hp_work->type, func);\r\nacpi_scan_lock_release();\r\nkfree(hp_work);\r\nput_bridge(func->slot->bridge);\r\n}\r\nstatic void handle_hotplug_event_func(acpi_handle handle, u32 type,\r\nvoid *context)\r\n{\r\nstruct acpiphp_func *func = context;\r\nget_bridge(func->slot->bridge);\r\nalloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);\r\n}\r\nvoid acpiphp_enumerate_slots(struct pci_bus *bus, acpi_handle handle)\r\n{\r\nacpi_handle dummy_handle;\r\nstruct acpiphp_bridge *bridge;\r\nif (acpiphp_disabled)\r\nreturn;\r\nif (detect_ejectable_slots(handle) <= 0)\r\nreturn;\r\nbridge = kzalloc(sizeof(struct acpiphp_bridge), GFP_KERNEL);\r\nif (bridge == NULL) {\r\nerr("out of memory\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&bridge->slots);\r\nkref_init(&bridge->ref);\r\nbridge->handle = handle;\r\nbridge->pci_dev = pci_dev_get(bus->self);\r\nbridge->pci_bus = bus;\r\nget_device(&bus->dev);\r\nif (!pci_is_root_bus(bridge->pci_bus) &&\r\nACPI_SUCCESS(acpi_get_handle(bridge->handle,\r\n"_EJ0", &dummy_handle))) {\r\ndbg("found ejectable p2p bridge\n");\r\nbridge->flags |= BRIDGE_HAS_EJ0;\r\nbridge->func = acpiphp_bridge_handle_to_function(handle);\r\n}\r\ninit_bridge_misc(bridge);\r\n}\r\nvoid acpiphp_remove_slots(struct pci_bus *bus)\r\n{\r\nstruct acpiphp_bridge *bridge, *tmp;\r\nif (acpiphp_disabled)\r\nreturn;\r\nlist_for_each_entry_safe(bridge, tmp, &bridge_list, list)\r\nif (bridge->pci_bus == bus) {\r\ncleanup_bridge(bridge);\r\nput_bridge(bridge);\r\nbreak;\r\n}\r\n}\r\nint acpiphp_enable_slot(struct acpiphp_slot *slot)\r\n{\r\nint retval;\r\nmutex_lock(&slot->crit_sect);\r\nretval = power_on_slot(slot);\r\nif (retval)\r\ngoto err_exit;\r\nif (get_slot_status(slot) == ACPI_STA_ALL) {\r\nretval = enable_device(slot);\r\nif (retval)\r\npower_off_slot(slot);\r\n} else {\r\ndbg("%s: Slot status is not ACPI_STA_ALL\n", __func__);\r\npower_off_slot(slot);\r\n}\r\nerr_exit:\r\nmutex_unlock(&slot->crit_sect);\r\nreturn retval;\r\n}\r\nint acpiphp_disable_slot(struct acpiphp_slot *slot)\r\n{\r\nint retval = 0;\r\nmutex_lock(&slot->crit_sect);\r\nretval = disable_device(slot);\r\nif (retval)\r\ngoto err_exit;\r\nretval = power_off_slot(slot);\r\nif (retval)\r\ngoto err_exit;\r\nerr_exit:\r\nmutex_unlock(&slot->crit_sect);\r\nreturn retval;\r\n}\r\nu8 acpiphp_get_power_status(struct acpiphp_slot *slot)\r\n{\r\nreturn (slot->flags & SLOT_POWEREDON);\r\n}\r\nu8 acpiphp_get_latch_status(struct acpiphp_slot *slot)\r\n{\r\nunsigned int sta;\r\nsta = get_slot_status(slot);\r\nreturn (sta & ACPI_STA_DEVICE_UI) ? 0 : 1;\r\n}\r\nu8 acpiphp_get_adapter_status(struct acpiphp_slot *slot)\r\n{\r\nunsigned int sta;\r\nsta = get_slot_status(slot);\r\nreturn (sta == 0) ? 0 : 1;\r\n}
