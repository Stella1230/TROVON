static int ad5764_write(struct iio_dev *indio_dev, unsigned int reg,\r\nunsigned int val)\r\n{\r\nstruct ad5764_state *st = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nst->data[0].d32 = cpu_to_be32((reg << 16) | val);\r\nret = spi_write(st->spi, &st->data[0].d8[1], 3);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5764_read(struct iio_dev *indio_dev, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nstruct ad5764_state *st = iio_priv(indio_dev);\r\nint ret;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = &st->data[0].d8[1],\r\n.len = 3,\r\n.cs_change = 1,\r\n}, {\r\n.rx_buf = &st->data[1].d8[1],\r\n.len = 3,\r\n},\r\n};\r\nmutex_lock(&indio_dev->mlock);\r\nst->data[0].d32 = cpu_to_be32((1 << 23) | (reg << 16));\r\nret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\r\nif (ret >= 0)\r\n*val = be32_to_cpu(st->data[1].d32) & 0xffff;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5764_chan_info_to_reg(struct iio_chan_spec const *chan, long info)\r\n{\r\nswitch (info) {\r\ncase 0:\r\nreturn AD5764_REG_DATA(chan->address);\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nreturn AD5764_REG_OFFSET(chan->address);\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nreturn AD5764_REG_FINE_GAIN(chan->address);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad5764_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long info)\r\n{\r\nconst int max_val = (1 << chan->scan_type.realbits);\r\nunsigned int reg;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val >= max_val || val < 0)\r\nreturn -EINVAL;\r\nval <<= chan->scan_type.shift;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif (val >= 128 || val < -128)\r\nreturn -EINVAL;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (val >= 32 || val < -32)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg = ad5764_chan_info_to_reg(chan, info);\r\nreturn ad5764_write(indio_dev, reg, (u16)val);\r\n}\r\nstatic int ad5764_get_channel_vref(struct ad5764_state *st,\r\nunsigned int channel)\r\n{\r\nif (st->chip_info->int_vref)\r\nreturn st->chip_info->int_vref;\r\nelse\r\nreturn regulator_get_voltage(st->vref_reg[channel / 2].consumer);\r\n}\r\nstatic int ad5764_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2, long info)\r\n{\r\nstruct ad5764_state *st = iio_priv(indio_dev);\r\nunsigned long scale_uv;\r\nunsigned int reg;\r\nint vref;\r\nint ret;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nreg = AD5764_REG_DATA(chan->address);\r\nret = ad5764_read(indio_dev, reg, val);\r\nif (ret < 0)\r\nreturn ret;\r\n*val >>= chan->scan_type.shift;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nreg = AD5764_REG_OFFSET(chan->address);\r\nret = ad5764_read(indio_dev, reg, val);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = sign_extend32(*val, 7);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nreg = AD5764_REG_FINE_GAIN(chan->address);\r\nret = ad5764_read(indio_dev, reg, val);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = sign_extend32(*val, 5);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nvref = ad5764_get_channel_vref(st, chan->channel);\r\nif (vref < 0)\r\nreturn vref;\r\nscale_uv = (vref * 4 * 100) >> chan->scan_type.realbits;\r\n*val = scale_uv / 100000;\r\n*val2 = (scale_uv % 100000) * 10;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = -(1 << chan->scan_type.realbits) / 2;\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad5764_probe(struct spi_device *spi)\r\n{\r\nenum ad5764_type type = spi_get_device_id(spi)->driver_data;\r\nstruct iio_dev *indio_dev;\r\nstruct ad5764_state *st;\r\nint ret;\r\nindio_dev = iio_device_alloc(sizeof(*st));\r\nif (indio_dev == NULL) {\r\ndev_err(&spi->dev, "Failed to allocate iio device\n");\r\nreturn -ENOMEM;\r\n}\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->spi = spi;\r\nst->chip_info = &ad5764_chip_infos[type];\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->info = &ad5764_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->num_channels = AD5764_NUM_CHANNELS;\r\nindio_dev->channels = st->chip_info->channels;\r\nif (st->chip_info->int_vref == 0) {\r\nst->vref_reg[0].supply = "vrefAB";\r\nst->vref_reg[1].supply = "vrefCD";\r\nret = regulator_bulk_get(&st->spi->dev,\r\nARRAY_SIZE(st->vref_reg), st->vref_reg);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to request vref regulators: %d\n",\r\nret);\r\ngoto error_free;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(st->vref_reg),\r\nst->vref_reg);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to enable vref regulators: %d\n",\r\nret);\r\ngoto error_free_reg;\r\n}\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to register iio device: %d\n", ret);\r\ngoto error_disable_reg;\r\n}\r\nreturn 0;\r\nerror_disable_reg:\r\nif (st->chip_info->int_vref == 0)\r\nregulator_bulk_disable(ARRAY_SIZE(st->vref_reg), st->vref_reg);\r\nerror_free_reg:\r\nif (st->chip_info->int_vref == 0)\r\nregulator_bulk_free(ARRAY_SIZE(st->vref_reg), st->vref_reg);\r\nerror_free:\r\niio_device_free(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int ad5764_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ad5764_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (st->chip_info->int_vref == 0) {\r\nregulator_bulk_disable(ARRAY_SIZE(st->vref_reg), st->vref_reg);\r\nregulator_bulk_free(ARRAY_SIZE(st->vref_reg), st->vref_reg);\r\n}\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
