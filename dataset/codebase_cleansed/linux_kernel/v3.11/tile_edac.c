static void tile_edac_check(struct mem_ctl_info *mci)\r\n{\r\nstruct tile_edac_priv *priv = mci->pvt_info;\r\nstruct mshim_mem_error mem_error;\r\nif (hv_dev_pread(priv->hv_devhdl, 0, (HV_VirtAddr)&mem_error,\r\nsizeof(struct mshim_mem_error), MSHIM_MEM_ERROR_OFF) !=\r\nsizeof(struct mshim_mem_error)) {\r\npr_err(DRV_NAME ": MSHIM_MEM_ERROR_OFF pread failure.\n");\r\nreturn;\r\n}\r\nif (mem_error.sbe_count != priv->ce_count) {\r\ndev_dbg(mci->pdev, "ECC CE err on node %d\n", priv->node);\r\npriv->ce_count = mem_error.sbe_count;\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\n0, 0, 0,\r\n0, 0, -1,\r\nmci->ctl_name, "");\r\n}\r\n}\r\nstatic int tile_edac_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct csrow_info *csrow = mci->csrows[0];\r\nstruct tile_edac_priv *priv = mci->pvt_info;\r\nstruct mshim_mem_info mem_info;\r\nstruct dimm_info *dimm = csrow->channels[0]->dimm;\r\nif (hv_dev_pread(priv->hv_devhdl, 0, (HV_VirtAddr)&mem_info,\r\nsizeof(struct mshim_mem_info), MSHIM_MEM_INFO_OFF) !=\r\nsizeof(struct mshim_mem_info)) {\r\npr_err(DRV_NAME ": MSHIM_MEM_INFO_OFF pread failure.\n");\r\nreturn -1;\r\n}\r\nif (mem_info.mem_ecc)\r\ndimm->edac_mode = EDAC_SECDED;\r\nelse\r\ndimm->edac_mode = EDAC_NONE;\r\nswitch (mem_info.mem_type) {\r\ncase DDR2:\r\ndimm->mtype = MEM_DDR2;\r\nbreak;\r\ncase DDR3:\r\ndimm->mtype = MEM_DDR3;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\ndimm->nr_pages = mem_info.mem_size >> PAGE_SHIFT;\r\ndimm->grain = TILE_EDAC_ERROR_GRAIN;\r\ndimm->dtype = DEV_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic int tile_edac_mc_probe(struct platform_device *pdev)\r\n{\r\nchar hv_file[32];\r\nint hv_devhdl;\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct tile_edac_priv *priv;\r\nint rc;\r\nsprintf(hv_file, "mshim/%d", pdev->id);\r\nhv_devhdl = hv_dev_open((HV_VirtAddr)hv_file, 0);\r\nif (hv_devhdl < 0)\r\nreturn -EINVAL;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = TILE_EDAC_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = TILE_EDAC_NR_CHANS;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(pdev->id, ARRAY_SIZE(layers), layers,\r\nsizeof(struct tile_edac_priv));\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\npriv = mci->pvt_info;\r\npriv->node = pdev->id;\r\npriv->hv_devhdl = hv_devhdl;\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = DRV_NAME;\r\n#ifdef __tilegx__\r\nmci->ctl_name = "TILEGx_Memory_Controller";\r\n#else\r\nmci->ctl_name = "TILEPro_Memory_Controller";\r\n#endif\r\nmci->dev_name = dev_name(&pdev->dev);\r\nmci->edac_check = tile_edac_check;\r\nif (tile_edac_init_csrows(mci)) {\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\n} else {\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\n}\r\nplatform_set_drvdata(pdev, mci);\r\nrc = edac_mc_add_mc(mci);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to register with EDAC core\n");\r\nedac_mc_free(mci);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tile_edac_mc_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\nedac_mc_del_mc(&pdev->dev);\r\nif (mci)\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}\r\nstatic int __init tile_edac_init(void)\r\n{\r\nchar hv_file[32];\r\nstruct platform_device *pdev;\r\nint i, err, num = 0;\r\nedac_op_state = EDAC_OPSTATE_POLL;\r\nerr = platform_driver_register(&tile_edac_mc_driver);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < TILE_MAX_MSHIMS; i++) {\r\nsprintf(hv_file, "mshim/%d", i);\r\nif (hv_dev_open((HV_VirtAddr)hv_file, 0) < 0)\r\ncontinue;\r\npdev = platform_device_register_simple(DRV_NAME, i, NULL, 0);\r\nif (IS_ERR(pdev))\r\ncontinue;\r\nmshim_pdev[i] = pdev;\r\nnum++;\r\n}\r\nif (num == 0) {\r\nplatform_driver_unregister(&tile_edac_mc_driver);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit tile_edac_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < TILE_MAX_MSHIMS; i++) {\r\nstruct platform_device *pdev = mshim_pdev[i];\r\nif (!pdev)\r\ncontinue;\r\nplatform_set_drvdata(pdev, NULL);\r\nplatform_device_unregister(pdev);\r\n}\r\nplatform_driver_unregister(&tile_edac_mc_driver);\r\n}
