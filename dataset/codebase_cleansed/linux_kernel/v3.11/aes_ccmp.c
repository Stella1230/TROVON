static void xor_128(u8 *a, u8 *b, u8 *out)\r\n{\r\nu32 * dwPtrA = (u32 *) a;\r\nu32 * dwPtrB = (u32 *) b;\r\nu32 * dwPtrOut = (u32 *) out;\r\n(*dwPtrOut++) = (*dwPtrA++) ^ (*dwPtrB++);\r\n(*dwPtrOut++) = (*dwPtrA++) ^ (*dwPtrB++);\r\n(*dwPtrOut++) = (*dwPtrA++) ^ (*dwPtrB++);\r\n(*dwPtrOut++) = (*dwPtrA++) ^ (*dwPtrB++);\r\n}\r\nstatic void xor_32(u8 *a, u8 *b, u8 *out)\r\n{\r\nu32 * dwPtrA = (u32 *) a;\r\nu32 * dwPtrB = (u32 *) b;\r\nu32 * dwPtrOut = (u32 *) out;\r\n(*dwPtrOut++) = (*dwPtrA++) ^ (*dwPtrB++);\r\n}\r\nvoid AddRoundKey(u8 *key, int round)\r\n{\r\nu8 sbox_key[4];\r\nu8 rcon_table[10] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};\r\nsbox_key[0] = sbox_table[key[13]];\r\nsbox_key[1] = sbox_table[key[14]];\r\nsbox_key[2] = sbox_table[key[15]];\r\nsbox_key[3] = sbox_table[key[12]];\r\nkey[0] = key[0] ^ rcon_table[round];\r\nxor_32(&key[0], sbox_key, &key[0]);\r\nxor_32(&key[4], &key[0], &key[4]);\r\nxor_32(&key[8], &key[4], &key[8]);\r\nxor_32(&key[12], &key[8], &key[12]);\r\n}\r\nvoid SubBytes(u8 *in, u8 *out)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = sbox_table[in[i]];\r\n}\r\nvoid ShiftRows(u8 *in, u8 *out)\r\n{\r\nout[0] = in[0];\r\nout[1] = in[5];\r\nout[2] = in[10];\r\nout[3] = in[15];\r\nout[4] = in[4];\r\nout[5] = in[9];\r\nout[6] = in[14];\r\nout[7] = in[3];\r\nout[8] = in[8];\r\nout[9] = in[13];\r\nout[10] = in[2];\r\nout[11] = in[7];\r\nout[12] = in[12];\r\nout[13] = in[1];\r\nout[14] = in[6];\r\nout[15] = in[11];\r\n}\r\nvoid MixColumns(u8 *in, u8 *out)\r\n{\r\nout[0] = dot2_table[in[0]] ^ dot3_table[in[1]] ^ in[2] ^ in[3];\r\nout[1] = in[0] ^ dot2_table[in[1]] ^ dot3_table[in[2]] ^ in[3];\r\nout[2] = in[0] ^ in[1] ^ dot2_table[in[2]] ^ dot3_table[in[3]];\r\nout[3] = dot3_table[in[0]] ^ in[1] ^ in[2] ^ dot2_table[in[3]];\r\n}\r\nvoid AESv128(u8 *key, u8 *data, u8 *ciphertext)\r\n{\r\nint i;\r\nint round;\r\nu8 TmpdataA[16];\r\nu8 TmpdataB[16];\r\nu8 abyRoundKey[16];\r\nfor (i = 0; i < 16; i++)\r\nabyRoundKey[i] = key[i];\r\nfor (round = 0; round < 11; round++) {\r\nif (round == 0) {\r\nxor_128(abyRoundKey, data, ciphertext);\r\nAddRoundKey(abyRoundKey, round);\r\n} else if (round == 10) {\r\nSubBytes(ciphertext, TmpdataA);\r\nShiftRows(TmpdataA, TmpdataB);\r\nxor_128(TmpdataB, abyRoundKey, ciphertext);\r\n} else {\r\nSubBytes(ciphertext, TmpdataA);\r\nShiftRows(TmpdataA, TmpdataB);\r\nMixColumns(&TmpdataB[0], &TmpdataA[0]);\r\nMixColumns(&TmpdataB[4], &TmpdataA[4]);\r\nMixColumns(&TmpdataB[8], &TmpdataA[8]);\r\nMixColumns(&TmpdataB[12], &TmpdataA[12]);\r\nxor_128(TmpdataA, abyRoundKey, ciphertext);\r\nAddRoundKey(abyRoundKey, round);\r\n}\r\n}\r\n}\r\nbool AESbGenCCMP(u8 * pbyRxKey, u8 * pbyFrame, u16 wFrameSize)\r\n{\r\nu8 abyNonce[13];\r\nu8 MIC_IV[16];\r\nu8 MIC_HDR1[16];\r\nu8 MIC_HDR2[16];\r\nu8 abyMIC[16];\r\nu8 abyCTRPLD[16];\r\nu8 abyTmp[16];\r\nu8 abyPlainText[16];\r\nu8 abyLastCipher[16];\r\nstruct ieee80211_hdr *pMACHeader = (struct ieee80211_hdr *) pbyFrame;\r\nu8 * pbyIV;\r\nu8 * pbyPayload;\r\nu16 wHLen = 22;\r\nu16 wPayloadSize = wFrameSize - 8 - 8 - 4 - WLAN_HDR_ADDR3_LEN;\r\nbool bA4 = false;\r\nu8 byTmp;\r\nu16 wCnt;\r\nint ii, jj, kk;\r\npbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;\r\nif (WLAN_GET_FC_TODS(*(u16 *) pbyFrame) &&\r\nWLAN_GET_FC_FROMDS(*(u16 *) pbyFrame)) {\r\nbA4 = true;\r\npbyIV += 6;\r\nwHLen += 6;\r\nwPayloadSize -= 6;\r\n}\r\npbyPayload = pbyIV + 8;\r\nabyNonce[0] = 0x00;\r\nmemcpy(&(abyNonce[1]), pMACHeader->addr2, ETH_ALEN);\r\nabyNonce[7] = pbyIV[7];\r\nabyNonce[8] = pbyIV[6];\r\nabyNonce[9] = pbyIV[5];\r\nabyNonce[10] = pbyIV[4];\r\nabyNonce[11] = pbyIV[1];\r\nabyNonce[12] = pbyIV[0];\r\nMIC_IV[0] = 0x59;\r\nmemcpy(&(MIC_IV[1]), &(abyNonce[0]), 13);\r\nMIC_IV[14] = (u8)(wPayloadSize >> 8);\r\nMIC_IV[15] = (u8)(wPayloadSize & 0xff);\r\nMIC_HDR1[0] = (u8)(wHLen >> 8);\r\nMIC_HDR1[1] = (u8)(wHLen & 0xff);\r\nbyTmp = (u8)(pMACHeader->frame_control & 0xff);\r\nMIC_HDR1[2] = byTmp & 0x8f;\r\nbyTmp = (u8)(pMACHeader->frame_control >> 8);\r\nbyTmp &= 0x87;\r\nMIC_HDR1[3] = byTmp | 0x40;\r\nmemcpy(&(MIC_HDR1[4]), pMACHeader->addr1, ETH_ALEN);\r\nmemcpy(&(MIC_HDR1[10]), pMACHeader->addr2, ETH_ALEN);\r\nmemcpy(&(MIC_HDR2[0]), pMACHeader->addr3, ETH_ALEN);\r\nbyTmp = (u8)(pMACHeader->seq_ctrl & 0xff);\r\nMIC_HDR2[6] = byTmp & 0x0f;\r\nMIC_HDR2[7] = 0;\r\nif (bA4) {\r\nmemcpy(&(MIC_HDR2[8]), pMACHeader->addr4, ETH_ALEN);\r\n} else {\r\nMIC_HDR2[8] = 0x00;\r\nMIC_HDR2[9] = 0x00;\r\nMIC_HDR2[10] = 0x00;\r\nMIC_HDR2[11] = 0x00;\r\nMIC_HDR2[12] = 0x00;\r\nMIC_HDR2[13] = 0x00;\r\n}\r\nMIC_HDR2[14] = 0x00;\r\nMIC_HDR2[15] = 0x00;\r\nAESv128(pbyRxKey, MIC_IV, abyMIC);\r\nfor (kk = 0; kk < 16; kk++)\r\nabyTmp[kk] = MIC_HDR1[kk] ^ abyMIC[kk];\r\nAESv128(pbyRxKey, abyTmp, abyMIC);\r\nfor (kk = 0; kk < 16; kk++)\r\nabyTmp[kk] = MIC_HDR2[kk] ^ abyMIC[kk];\r\nAESv128(pbyRxKey, abyTmp, abyMIC);\r\nwCnt = 1;\r\nabyCTRPLD[0] = 0x01;\r\nmemcpy(&(abyCTRPLD[1]), &(abyNonce[0]), 13);\r\nfor (jj = wPayloadSize; jj > 16; jj = jj-16) {\r\nabyCTRPLD[14] = (u8) (wCnt >> 8);\r\nabyCTRPLD[15] = (u8) (wCnt & 0xff);\r\nAESv128(pbyRxKey, abyCTRPLD, abyTmp);\r\nfor (kk = 0; kk < 16; kk++)\r\nabyPlainText[kk] = abyTmp[kk] ^ pbyPayload[kk];\r\nfor (kk = 0; kk < 16; kk++)\r\nabyTmp[kk] = abyMIC[kk] ^ abyPlainText[kk];\r\nAESv128(pbyRxKey, abyTmp, abyMIC);\r\nmemcpy(pbyPayload, abyPlainText, 16);\r\nwCnt++;\r\npbyPayload += 16;\r\n}\r\nmemcpy(&(abyLastCipher[0]), pbyPayload, jj);\r\nfor (ii = jj; ii < 16; ii++)\r\nabyLastCipher[ii] = 0x00;\r\nabyCTRPLD[14] = (u8) (wCnt >> 8);\r\nabyCTRPLD[15] = (u8) (wCnt & 0xff);\r\nAESv128(pbyRxKey, abyCTRPLD, abyTmp);\r\nfor (kk = 0; kk < 16; kk++)\r\nabyPlainText[kk] = abyTmp[kk] ^ abyLastCipher[kk];\r\nmemcpy(pbyPayload, abyPlainText, jj);\r\npbyPayload += jj;\r\nfor (ii = jj; ii < 16; ii++)\r\nabyPlainText[ii] = 0x00;\r\nfor (kk = 0; kk < 16; kk++)\r\nabyTmp[kk] = abyMIC[kk] ^ abyPlainText[kk];\r\nAESv128(pbyRxKey, abyTmp, abyMIC);\r\nwCnt = 0;\r\nabyCTRPLD[14] = (u8) (wCnt >> 8);\r\nabyCTRPLD[15] = (u8) (wCnt & 0xff);\r\nAESv128(pbyRxKey, abyCTRPLD, abyTmp);\r\nfor (kk = 0; kk < 8; kk++)\r\nabyTmp[kk] = abyTmp[kk] ^ pbyPayload[kk];\r\nif (!memcmp(abyMIC, abyTmp, 8))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}
