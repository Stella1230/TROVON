static bool event_compare(struct fsnotify_event *old, struct fsnotify_event *new)\r\n{\r\nif ((old->mask == new->mask) &&\r\n(old->to_tell == new->to_tell) &&\r\n(old->data_type == new->data_type) &&\r\n(old->name_len == new->name_len)) {\r\nswitch (old->data_type) {\r\ncase (FSNOTIFY_EVENT_INODE):\r\nif (!old->name_len ||\r\n!strcmp(old->file_name, new->file_name))\r\nreturn true;\r\nbreak;\r\ncase (FSNOTIFY_EVENT_PATH):\r\nif ((old->path.mnt == new->path.mnt) &&\r\n(old->path.dentry == new->path.dentry))\r\nreturn true;\r\nbreak;\r\ncase (FSNOTIFY_EVENT_NONE):\r\nif (old->mask & FS_Q_OVERFLOW)\r\nreturn true;\r\nelse if (old->mask & FS_IN_IGNORED)\r\nreturn false;\r\nreturn true;\r\n};\r\n}\r\nreturn false;\r\n}\r\nstatic struct fsnotify_event *inotify_merge(struct list_head *list,\r\nstruct fsnotify_event *event)\r\n{\r\nstruct fsnotify_event_holder *last_holder;\r\nstruct fsnotify_event *last_event;\r\nspin_lock(&event->lock);\r\nlast_holder = list_entry(list->prev, struct fsnotify_event_holder, event_list);\r\nlast_event = last_holder->event;\r\nif (event_compare(last_event, event))\r\nfsnotify_get_event(last_event);\r\nelse\r\nlast_event = NULL;\r\nspin_unlock(&event->lock);\r\nreturn last_event;\r\n}\r\nstatic int inotify_handle_event(struct fsnotify_group *group,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\nstruct fsnotify_event *event)\r\n{\r\nstruct inotify_inode_mark *i_mark;\r\nstruct inode *to_tell;\r\nstruct inotify_event_private_data *event_priv;\r\nstruct fsnotify_event_private_data *fsn_event_priv;\r\nstruct fsnotify_event *added_event;\r\nint wd, ret = 0;\r\nBUG_ON(vfsmount_mark);\r\npr_debug("%s: group=%p event=%p to_tell=%p mask=%x\n", __func__, group,\r\nevent, event->to_tell, event->mask);\r\nto_tell = event->to_tell;\r\ni_mark = container_of(inode_mark, struct inotify_inode_mark,\r\nfsn_mark);\r\nwd = i_mark->wd;\r\nevent_priv = kmem_cache_alloc(event_priv_cachep, GFP_KERNEL);\r\nif (unlikely(!event_priv))\r\nreturn -ENOMEM;\r\nfsn_event_priv = &event_priv->fsnotify_event_priv_data;\r\nfsnotify_get_group(group);\r\nfsn_event_priv->group = group;\r\nevent_priv->wd = wd;\r\nadded_event = fsnotify_add_notify_event(group, event, fsn_event_priv, inotify_merge);\r\nif (added_event) {\r\ninotify_free_event_priv(fsn_event_priv);\r\nif (!IS_ERR(added_event))\r\nfsnotify_put_event(added_event);\r\nelse\r\nret = PTR_ERR(added_event);\r\n}\r\nif (inode_mark->mask & IN_ONESHOT)\r\nfsnotify_destroy_mark(inode_mark, group);\r\nreturn ret;\r\n}\r\nstatic void inotify_freeing_mark(struct fsnotify_mark *fsn_mark, struct fsnotify_group *group)\r\n{\r\ninotify_ignored_and_remove_idr(fsn_mark, group);\r\n}\r\nstatic bool inotify_should_send_event(struct fsnotify_group *group, struct inode *inode,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\n__u32 mask, void *data, int data_type)\r\n{\r\nif ((inode_mark->mask & FS_EXCL_UNLINK) &&\r\n(data_type == FSNOTIFY_EVENT_PATH)) {\r\nstruct path *path = data;\r\nif (d_unlinked(path->dentry))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int idr_callback(int id, void *p, void *data)\r\n{\r\nstruct fsnotify_mark *fsn_mark;\r\nstruct inotify_inode_mark *i_mark;\r\nstatic bool warned = false;\r\nif (warned)\r\nreturn 0;\r\nwarned = true;\r\nfsn_mark = p;\r\ni_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\r\nWARN(1, "inotify closing but id=%d for fsn_mark=%p in group=%p still in "\r\n"idr. Probably leaking memory\n", id, p, data);\r\nif (fsn_mark)\r\nprintk(KERN_WARNING "fsn_mark->group=%p inode=%p wd=%d\n",\r\nfsn_mark->group, fsn_mark->i.inode, i_mark->wd);\r\nreturn 0;\r\n}\r\nstatic void inotify_free_group_priv(struct fsnotify_group *group)\r\n{\r\nidr_for_each(&group->inotify_data.idr, idr_callback, group);\r\nidr_destroy(&group->inotify_data.idr);\r\natomic_dec(&group->inotify_data.user->inotify_devs);\r\nfree_uid(group->inotify_data.user);\r\n}\r\nvoid inotify_free_event_priv(struct fsnotify_event_private_data *fsn_event_priv)\r\n{\r\nstruct inotify_event_private_data *event_priv;\r\nevent_priv = container_of(fsn_event_priv, struct inotify_event_private_data,\r\nfsnotify_event_priv_data);\r\nfsnotify_put_group(fsn_event_priv->group);\r\nkmem_cache_free(event_priv_cachep, event_priv);\r\n}
