static unsigned int hdmi_get_eld_data(struct hda_codec *codec, hda_nid_t nid,\r\nint byte_index)\r\n{\r\nunsigned int val;\r\nval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_HDMI_ELDD, byte_index);\r\n#ifdef BE_PARANOID\r\nprintk(KERN_INFO "HDMI: ELD data byte %d: 0x%x\n", byte_index, val);\r\n#endif\r\nreturn val;\r\n}\r\nstatic void hdmi_update_short_audio_desc(struct cea_sad *a,\r\nconst unsigned char *buf)\r\n{\r\nint i;\r\nint val;\r\nval = GRAB_BITS(buf, 1, 0, 7);\r\na->rates = 0;\r\nfor (i = 0; i < 7; i++)\r\nif (val & (1 << i))\r\na->rates |= cea_sampling_frequencies[i + 1];\r\na->channels = GRAB_BITS(buf, 0, 0, 3);\r\na->channels++;\r\na->sample_bits = 0;\r\na->max_bitrate = 0;\r\na->format = GRAB_BITS(buf, 0, 3, 4);\r\nswitch (a->format) {\r\ncase AUDIO_CODING_TYPE_REF_STREAM_HEADER:\r\nsnd_printd(KERN_INFO\r\n"HDMI: audio coding type 0 not expected\n");\r\nbreak;\r\ncase AUDIO_CODING_TYPE_LPCM:\r\nval = GRAB_BITS(buf, 2, 0, 3);\r\nfor (i = 0; i < 3; i++)\r\nif (val & (1 << i))\r\na->sample_bits |= cea_sample_sizes[i + 1];\r\nbreak;\r\ncase AUDIO_CODING_TYPE_AC3:\r\ncase AUDIO_CODING_TYPE_MPEG1:\r\ncase AUDIO_CODING_TYPE_MP3:\r\ncase AUDIO_CODING_TYPE_MPEG2:\r\ncase AUDIO_CODING_TYPE_AACLC:\r\ncase AUDIO_CODING_TYPE_DTS:\r\ncase AUDIO_CODING_TYPE_ATRAC:\r\na->max_bitrate = GRAB_BITS(buf, 2, 0, 8);\r\na->max_bitrate *= 8000;\r\nbreak;\r\ncase AUDIO_CODING_TYPE_SACD:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_EAC3:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_DTS_HD:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_MLP:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_DST:\r\nbreak;\r\ncase AUDIO_CODING_TYPE_WMAPRO:\r\na->profile = GRAB_BITS(buf, 2, 0, 3);\r\nbreak;\r\ncase AUDIO_CODING_TYPE_REF_CXT:\r\na->format = GRAB_BITS(buf, 2, 3, 5);\r\nif (a->format == AUDIO_CODING_XTYPE_HE_REF_CT ||\r\na->format >= AUDIO_CODING_XTYPE_FIRST_RESERVED) {\r\nsnd_printd(KERN_INFO\r\n"HDMI: audio coding xtype %d not expected\n",\r\na->format);\r\na->format = 0;\r\n} else\r\na->format += AUDIO_CODING_TYPE_HE_AAC -\r\nAUDIO_CODING_XTYPE_HE_AAC;\r\nbreak;\r\n}\r\n}\r\nint snd_hdmi_parse_eld(struct parsed_hdmi_eld *e,\r\nconst unsigned char *buf, int size)\r\n{\r\nint mnl;\r\nint i;\r\ne->eld_ver = GRAB_BITS(buf, 0, 3, 5);\r\nif (e->eld_ver != ELD_VER_CEA_861D &&\r\ne->eld_ver != ELD_VER_PARTIAL) {\r\nsnd_printd(KERN_INFO "HDMI: Unknown ELD version %d\n",\r\ne->eld_ver);\r\ngoto out_fail;\r\n}\r\ne->baseline_len = GRAB_BITS(buf, 2, 0, 8);\r\nmnl = GRAB_BITS(buf, 4, 0, 5);\r\ne->cea_edid_ver = GRAB_BITS(buf, 4, 5, 3);\r\ne->support_hdcp = GRAB_BITS(buf, 5, 0, 1);\r\ne->support_ai = GRAB_BITS(buf, 5, 1, 1);\r\ne->conn_type = GRAB_BITS(buf, 5, 2, 2);\r\ne->sad_count = GRAB_BITS(buf, 5, 4, 4);\r\ne->aud_synch_delay = GRAB_BITS(buf, 6, 0, 8) * 2;\r\ne->spk_alloc = GRAB_BITS(buf, 7, 0, 7);\r\ne->port_id = get_unaligned_le64(buf + 8);\r\ne->manufacture_id = get_unaligned_le16(buf + 16);\r\ne->product_id = get_unaligned_le16(buf + 18);\r\nif (mnl > ELD_MAX_MNL) {\r\nsnd_printd(KERN_INFO "HDMI: MNL is reserved value %d\n", mnl);\r\ngoto out_fail;\r\n} else if (ELD_FIXED_BYTES + mnl > size) {\r\nsnd_printd(KERN_INFO "HDMI: out of range MNL %d\n", mnl);\r\ngoto out_fail;\r\n} else\r\nstrlcpy(e->monitor_name, buf + ELD_FIXED_BYTES, mnl + 1);\r\nfor (i = 0; i < e->sad_count; i++) {\r\nif (ELD_FIXED_BYTES + mnl + 3 * (i + 1) > size) {\r\nsnd_printd(KERN_INFO "HDMI: out of range SAD %d\n", i);\r\ngoto out_fail;\r\n}\r\nhdmi_update_short_audio_desc(e->sad + i,\r\nbuf + ELD_FIXED_BYTES + mnl + 3 * i);\r\n}\r\nif (!e->spk_alloc)\r\ne->spk_alloc = 0xffff;\r\nreturn 0;\r\nout_fail:\r\nreturn -EINVAL;\r\n}\r\nint snd_hdmi_get_eld_size(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nreturn snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_HDMI_DIP_SIZE,\r\nAC_DIPSIZE_ELD_BUF);\r\n}\r\nint snd_hdmi_get_eld(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned char *buf, int *eld_size)\r\n{\r\nint i;\r\nint ret = 0;\r\nint size;\r\nsize = snd_hdmi_get_eld_size(codec, nid);\r\nif (size == 0) {\r\nsnd_printd(KERN_INFO "HDMI: ELD buf size is 0, force 128\n");\r\nsize = 128;\r\n}\r\nif (size < ELD_FIXED_BYTES || size > ELD_MAX_SIZE) {\r\nsnd_printd(KERN_INFO "HDMI: invalid ELD buf size %d\n", size);\r\nreturn -ERANGE;\r\n}\r\nfor (i = 0; i < size; i++) {\r\nunsigned int val = hdmi_get_eld_data(codec, nid, i);\r\nif (!(val & AC_ELDD_ELD_VALID)) {\r\nsnd_printd(KERN_INFO\r\n"HDMI: invalid ELD data byte %d\n", i);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nval &= AC_ELDD_ELD_DATA;\r\nif (!val && !i) {\r\nsnd_printdd(KERN_INFO "HDMI: 0 ELD data\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbuf[i] = val;\r\n}\r\n*eld_size = size;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void hdmi_print_pcm_rates(int pcm, char *buf, int buflen)\r\n{\r\nstatic unsigned int alsa_rates[] = {\r\n5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000, 64000,\r\n88200, 96000, 176400, 192000, 384000\r\n};\r\nint i, j;\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(alsa_rates); i++)\r\nif (pcm & (1 << i))\r\nj += snprintf(buf + j, buflen - j, " %d",\r\nalsa_rates[i]);\r\nbuf[j] = '\0';\r\n}\r\nstatic void hdmi_show_short_audio_desc(struct cea_sad *a)\r\n{\r\nchar buf[SND_PRINT_RATES_ADVISED_BUFSIZE];\r\nchar buf2[8 + SND_PRINT_BITS_ADVISED_BUFSIZE] = ", bits =";\r\nif (!a->format)\r\nreturn;\r\nhdmi_print_pcm_rates(a->rates, buf, sizeof(buf));\r\nif (a->format == AUDIO_CODING_TYPE_LPCM)\r\nsnd_print_pcm_bits(a->sample_bits, buf2 + 8, sizeof(buf2) - 8);\r\nelse if (a->max_bitrate)\r\nsnprintf(buf2, sizeof(buf2),\r\n", max bitrate = %d", a->max_bitrate);\r\nelse\r\nbuf2[0] = '\0';\r\n_snd_printd(SND_PR_VERBOSE, "HDMI: supports coding type %s:"\r\n" channels = %d, rates =%s%s\n",\r\ncea_audio_coding_type_names[a->format],\r\na->channels,\r\nbuf,\r\nbuf2);\r\n}\r\nvoid snd_print_channel_allocation(int spk_alloc, char *buf, int buflen)\r\n{\r\nint i, j;\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(cea_speaker_allocation_names); i++) {\r\nif (spk_alloc & (1 << i))\r\nj += snprintf(buf + j, buflen - j, " %s",\r\ncea_speaker_allocation_names[i]);\r\n}\r\nbuf[j] = '\0';\r\n}\r\nvoid snd_hdmi_show_eld(struct parsed_hdmi_eld *e)\r\n{\r\nint i;\r\n_snd_printd(SND_PR_VERBOSE, "HDMI: detected monitor %s at connection type %s\n",\r\ne->monitor_name,\r\neld_connection_type_names[e->conn_type]);\r\nif (e->spk_alloc) {\r\nchar buf[SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE];\r\nsnd_print_channel_allocation(e->spk_alloc, buf, sizeof(buf));\r\n_snd_printd(SND_PR_VERBOSE, "HDMI: available speakers:%s\n", buf);\r\n}\r\nfor (i = 0; i < e->sad_count; i++)\r\nhdmi_show_short_audio_desc(e->sad + i);\r\n}\r\nstatic void hdmi_print_sad_info(int i, struct cea_sad *a,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nchar buf[SND_PRINT_RATES_ADVISED_BUFSIZE];\r\nsnd_iprintf(buffer, "sad%d_coding_type\t[0x%x] %s\n",\r\ni, a->format, cea_audio_coding_type_names[a->format]);\r\nsnd_iprintf(buffer, "sad%d_channels\t\t%d\n", i, a->channels);\r\nhdmi_print_pcm_rates(a->rates, buf, sizeof(buf));\r\nsnd_iprintf(buffer, "sad%d_rates\t\t[0x%x]%s\n", i, a->rates, buf);\r\nif (a->format == AUDIO_CODING_TYPE_LPCM) {\r\nsnd_print_pcm_bits(a->sample_bits, buf, sizeof(buf));\r\nsnd_iprintf(buffer, "sad%d_bits\t\t[0x%x]%s\n",\r\ni, a->sample_bits, buf);\r\n}\r\nif (a->max_bitrate)\r\nsnd_iprintf(buffer, "sad%d_max_bitrate\t%d\n",\r\ni, a->max_bitrate);\r\nif (a->profile)\r\nsnd_iprintf(buffer, "sad%d_profile\t\t%d\n", i, a->profile);\r\n}\r\nstatic void hdmi_print_eld_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdmi_eld *eld = entry->private_data;\r\nstruct parsed_hdmi_eld *e = &eld->info;\r\nchar buf[SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE];\r\nint i;\r\nstatic char *eld_version_names[32] = {\r\n"reserved",\r\n"reserved",\r\n"CEA-861D or below",\r\n[3 ... 30] = "reserved",\r\n[31] = "partial"\r\n};\r\nstatic char *cea_edid_version_names[8] = {\r\n"no CEA EDID Timing Extension block present",\r\n"CEA-861",\r\n"CEA-861-A",\r\n"CEA-861-B, C or D",\r\n[4 ... 7] = "reserved"\r\n};\r\nmutex_lock(&eld->lock);\r\nsnd_iprintf(buffer, "monitor_present\t\t%d\n", eld->monitor_present);\r\nsnd_iprintf(buffer, "eld_valid\t\t%d\n", eld->eld_valid);\r\nif (!eld->eld_valid) {\r\nmutex_unlock(&eld->lock);\r\nreturn;\r\n}\r\nsnd_iprintf(buffer, "monitor_name\t\t%s\n", e->monitor_name);\r\nsnd_iprintf(buffer, "connection_type\t\t%s\n",\r\neld_connection_type_names[e->conn_type]);\r\nsnd_iprintf(buffer, "eld_version\t\t[0x%x] %s\n", e->eld_ver,\r\neld_version_names[e->eld_ver]);\r\nsnd_iprintf(buffer, "edid_version\t\t[0x%x] %s\n", e->cea_edid_ver,\r\ncea_edid_version_names[e->cea_edid_ver]);\r\nsnd_iprintf(buffer, "manufacture_id\t\t0x%x\n", e->manufacture_id);\r\nsnd_iprintf(buffer, "product_id\t\t0x%x\n", e->product_id);\r\nsnd_iprintf(buffer, "port_id\t\t\t0x%llx\n", (long long)e->port_id);\r\nsnd_iprintf(buffer, "support_hdcp\t\t%d\n", e->support_hdcp);\r\nsnd_iprintf(buffer, "support_ai\t\t%d\n", e->support_ai);\r\nsnd_iprintf(buffer, "audio_sync_delay\t%d\n", e->aud_synch_delay);\r\nsnd_print_channel_allocation(e->spk_alloc, buf, sizeof(buf));\r\nsnd_iprintf(buffer, "speakers\t\t[0x%x]%s\n", e->spk_alloc, buf);\r\nsnd_iprintf(buffer, "sad_count\t\t%d\n", e->sad_count);\r\nfor (i = 0; i < e->sad_count; i++)\r\nhdmi_print_sad_info(i, e->sad + i, buffer);\r\nmutex_unlock(&eld->lock);\r\n}\r\nstatic void hdmi_write_eld_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdmi_eld *eld = entry->private_data;\r\nstruct parsed_hdmi_eld *e = &eld->info;\r\nchar line[64];\r\nchar name[64];\r\nchar *sname;\r\nlong long val;\r\nunsigned int n;\r\nmutex_lock(&eld->lock);\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nif (sscanf(line, "%s %llx", name, &val) != 2)\r\ncontinue;\r\nif (!strcmp(name, "monitor_present"))\r\neld->monitor_present = val;\r\nelse if (!strcmp(name, "eld_valid"))\r\neld->eld_valid = val;\r\nelse if (!strcmp(name, "connection_type"))\r\ne->conn_type = val;\r\nelse if (!strcmp(name, "port_id"))\r\ne->port_id = val;\r\nelse if (!strcmp(name, "support_hdcp"))\r\ne->support_hdcp = val;\r\nelse if (!strcmp(name, "support_ai"))\r\ne->support_ai = val;\r\nelse if (!strcmp(name, "audio_sync_delay"))\r\ne->aud_synch_delay = val;\r\nelse if (!strcmp(name, "speakers"))\r\ne->spk_alloc = val;\r\nelse if (!strcmp(name, "sad_count"))\r\ne->sad_count = val;\r\nelse if (!strncmp(name, "sad", 3)) {\r\nsname = name + 4;\r\nn = name[3] - '0';\r\nif (name[4] >= '0' && name[4] <= '9') {\r\nsname++;\r\nn = 10 * n + name[4] - '0';\r\n}\r\nif (n >= ELD_MAX_SAD)\r\ncontinue;\r\nif (!strcmp(sname, "_coding_type"))\r\ne->sad[n].format = val;\r\nelse if (!strcmp(sname, "_channels"))\r\ne->sad[n].channels = val;\r\nelse if (!strcmp(sname, "_rates"))\r\ne->sad[n].rates = val;\r\nelse if (!strcmp(sname, "_bits"))\r\ne->sad[n].sample_bits = val;\r\nelse if (!strcmp(sname, "_max_bitrate"))\r\ne->sad[n].max_bitrate = val;\r\nelse if (!strcmp(sname, "_profile"))\r\ne->sad[n].profile = val;\r\nif (n >= e->sad_count)\r\ne->sad_count = n + 1;\r\n}\r\n}\r\nmutex_unlock(&eld->lock);\r\n}\r\nint snd_hda_eld_proc_new(struct hda_codec *codec, struct hdmi_eld *eld,\r\nint index)\r\n{\r\nchar name[32];\r\nstruct snd_info_entry *entry;\r\nint err;\r\nsnprintf(name, sizeof(name), "eld#%d.%d", codec->addr, index);\r\nerr = snd_card_proc_new(codec->bus->card, name, &entry);\r\nif (err < 0)\r\nreturn err;\r\nsnd_info_set_text_ops(entry, eld, hdmi_print_eld_info);\r\nentry->c.text.write = hdmi_write_eld_info;\r\nentry->mode |= S_IWUSR;\r\neld->proc_entry = entry;\r\nreturn 0;\r\n}\r\nvoid snd_hda_eld_proc_free(struct hda_codec *codec, struct hdmi_eld *eld)\r\n{\r\nif (!codec->bus->shutdown && eld->proc_entry) {\r\nsnd_device_free(codec->bus->card, eld->proc_entry);\r\neld->proc_entry = NULL;\r\n}\r\n}\r\nvoid snd_hdmi_eld_update_pcm_info(struct parsed_hdmi_eld *e,\r\nstruct hda_pcm_stream *hinfo)\r\n{\r\nu32 rates;\r\nu64 formats;\r\nunsigned int maxbps;\r\nunsigned int channels_max;\r\nint i;\r\nrates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\r\nSNDRV_PCM_RATE_48000;\r\nformats = SNDRV_PCM_FMTBIT_S16_LE;\r\nmaxbps = 16;\r\nchannels_max = 2;\r\nfor (i = 0; i < e->sad_count; i++) {\r\nstruct cea_sad *a = &e->sad[i];\r\nrates |= a->rates;\r\nif (a->channels > channels_max)\r\nchannels_max = a->channels;\r\nif (a->format == AUDIO_CODING_TYPE_LPCM) {\r\nif (a->sample_bits & AC_SUPPCM_BITS_20) {\r\nformats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nif (maxbps < 20)\r\nmaxbps = 20;\r\n}\r\nif (a->sample_bits & AC_SUPPCM_BITS_24) {\r\nformats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nif (maxbps < 24)\r\nmaxbps = 24;\r\n}\r\n}\r\n}\r\nhinfo->rates &= rates;\r\nhinfo->formats &= formats;\r\nhinfo->maxbps = min(hinfo->maxbps, maxbps);\r\nhinfo->channels_max = min(hinfo->channels_max, channels_max);\r\n}
