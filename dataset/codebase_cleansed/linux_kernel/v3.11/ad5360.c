static unsigned int ad5360_get_channel_vref_index(struct ad5360_state *st,\r\nunsigned int channel)\r\n{\r\nunsigned int i;\r\ni = channel / st->chip_info->channels_per_group;\r\nif (i >= st->chip_info->num_vrefs)\r\ni = st->chip_info->num_vrefs - 1;\r\nreturn i;\r\n}\r\nstatic int ad5360_get_channel_vref(struct ad5360_state *st,\r\nunsigned int channel)\r\n{\r\nunsigned int i = ad5360_get_channel_vref_index(st, channel);\r\nreturn regulator_get_voltage(st->vref_reg[i].consumer);\r\n}\r\nstatic int ad5360_write_unlocked(struct iio_dev *indio_dev,\r\nunsigned int cmd, unsigned int addr, unsigned int val,\r\nunsigned int shift)\r\n{\r\nstruct ad5360_state *st = iio_priv(indio_dev);\r\nval <<= shift;\r\nval |= AD5360_CMD(cmd) | AD5360_ADDR(addr);\r\nst->data[0].d32 = cpu_to_be32(val);\r\nreturn spi_write(st->spi, &st->data[0].d8[1], 3);\r\n}\r\nstatic int ad5360_write(struct iio_dev *indio_dev, unsigned int cmd,\r\nunsigned int addr, unsigned int val, unsigned int shift)\r\n{\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad5360_write_unlocked(indio_dev, cmd, addr, val, shift);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5360_read(struct iio_dev *indio_dev, unsigned int type,\r\nunsigned int addr)\r\n{\r\nstruct ad5360_state *st = iio_priv(indio_dev);\r\nint ret;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = &st->data[0].d8[1],\r\n.len = 3,\r\n.cs_change = 1,\r\n}, {\r\n.rx_buf = &st->data[1].d8[1],\r\n.len = 3,\r\n},\r\n};\r\nmutex_lock(&indio_dev->mlock);\r\nst->data[0].d32 = cpu_to_be32(AD5360_CMD(AD5360_CMD_SPECIAL_FUNCTION) |\r\nAD5360_ADDR(AD5360_REG_SF_READBACK) |\r\nAD5360_READBACK_TYPE(type) |\r\nAD5360_READBACK_ADDR(addr));\r\nret = spi_sync_transfer(st->spi, t, ARRAY_SIZE(t));\r\nif (ret >= 0)\r\nret = be32_to_cpu(st->data[1].d32) & 0xffff;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ad5360_read_dac_powerdown(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad5360_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", (bool)(st->ctrl & AD5360_SF_CTRL_PWR_DOWN));\r\n}\r\nstatic int ad5360_update_ctrl(struct iio_dev *indio_dev, unsigned int set,\r\nunsigned int clr)\r\n{\r\nstruct ad5360_state *st = iio_priv(indio_dev);\r\nunsigned int ret;\r\nmutex_lock(&indio_dev->mlock);\r\nst->ctrl |= set;\r\nst->ctrl &= ~clr;\r\nret = ad5360_write_unlocked(indio_dev, AD5360_CMD_SPECIAL_FUNCTION,\r\nAD5360_REG_SF_CTRL, st->ctrl, 0);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ad5360_write_dac_powerdown(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nbool pwr_down;\r\nint ret;\r\nret = strtobool(buf, &pwr_down);\r\nif (ret)\r\nreturn ret;\r\nif (pwr_down)\r\nret = ad5360_update_ctrl(indio_dev, AD5360_SF_CTRL_PWR_DOWN, 0);\r\nelse\r\nret = ad5360_update_ctrl(indio_dev, 0, AD5360_SF_CTRL_PWR_DOWN);\r\nreturn ret ? ret : len;\r\n}\r\nstatic int ad5360_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct ad5360_state *st = iio_priv(indio_dev);\r\nint max_val = (1 << chan->scan_type.realbits);\r\nunsigned int ofs_index;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val >= max_val || val < 0)\r\nreturn -EINVAL;\r\nreturn ad5360_write(indio_dev, AD5360_CMD_WRITE_DATA,\r\nchan->address, val, chan->scan_type.shift);\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif (val >= max_val || val < 0)\r\nreturn -EINVAL;\r\nreturn ad5360_write(indio_dev, AD5360_CMD_WRITE_OFFSET,\r\nchan->address, val, chan->scan_type.shift);\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (val >= max_val || val < 0)\r\nreturn -EINVAL;\r\nreturn ad5360_write(indio_dev, AD5360_CMD_WRITE_GAIN,\r\nchan->address, val, chan->scan_type.shift);\r\ncase IIO_CHAN_INFO_OFFSET:\r\nif (val <= -max_val || val > 0)\r\nreturn -EINVAL;\r\nval = -val;\r\nval >>= (chan->scan_type.realbits - 14);\r\nofs_index = ad5360_get_channel_vref_index(st, chan->channel);\r\nreturn ad5360_write(indio_dev, AD5360_CMD_SPECIAL_FUNCTION,\r\nAD5360_REG_SF_OFS(ofs_index), val, 0);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad5360_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct ad5360_state *st = iio_priv(indio_dev);\r\nunsigned int ofs_index;\r\nint scale_uv;\r\nint ret;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = ad5360_read(indio_dev, AD5360_READBACK_X1A,\r\nchan->address);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret >> chan->scan_type.shift;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nscale_uv = ad5360_get_channel_vref(st, chan->channel) * 4 * 100;\r\nif (scale_uv < 0)\r\nreturn scale_uv;\r\nscale_uv >>= (chan->scan_type.realbits);\r\n*val = scale_uv / 100000;\r\n*val2 = (scale_uv % 100000) * 10;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nret = ad5360_read(indio_dev, AD5360_READBACK_OFFSET,\r\nchan->address);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nret = ad5360_read(indio_dev, AD5360_READBACK_GAIN,\r\nchan->address);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nofs_index = ad5360_get_channel_vref_index(st, chan->channel);\r\nret = ad5360_read(indio_dev, AD5360_READBACK_SF,\r\nAD5360_REG_SF_OFS(ofs_index));\r\nif (ret < 0)\r\nreturn ret;\r\nret <<= (chan->scan_type.realbits - 14);\r\n*val = -ret;\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad5360_alloc_channels(struct iio_dev *indio_dev)\r\n{\r\nstruct ad5360_state *st = iio_priv(indio_dev);\r\nstruct iio_chan_spec *channels;\r\nunsigned int i;\r\nchannels = kcalloc(st->chip_info->num_channels,\r\nsizeof(struct iio_chan_spec), GFP_KERNEL);\r\nif (!channels)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < st->chip_info->num_channels; ++i) {\r\nchannels[i] = st->chip_info->channel_template;\r\nchannels[i].channel = i;\r\nchannels[i].address = AD5360_CHAN_ADDR(i);\r\n}\r\nindio_dev->channels = channels;\r\nreturn 0;\r\n}\r\nstatic int ad5360_probe(struct spi_device *spi)\r\n{\r\nenum ad5360_type type = spi_get_device_id(spi)->driver_data;\r\nstruct iio_dev *indio_dev;\r\nstruct ad5360_state *st;\r\nunsigned int i;\r\nint ret;\r\nindio_dev = iio_device_alloc(sizeof(*st));\r\nif (indio_dev == NULL) {\r\ndev_err(&spi->dev, "Failed to allocate iio device\n");\r\nreturn -ENOMEM;\r\n}\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->chip_info = &ad5360_chip_info_tbl[type];\r\nst->spi = spi;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->info = &ad5360_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\nret = ad5360_alloc_channels(indio_dev);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to allocate channel spec: %d\n", ret);\r\ngoto error_free;\r\n}\r\nfor (i = 0; i < st->chip_info->num_vrefs; ++i)\r\nst->vref_reg[i].supply = ad5360_vref_name[i];\r\nret = regulator_bulk_get(&st->spi->dev, st->chip_info->num_vrefs,\r\nst->vref_reg);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to request vref regulators: %d\n", ret);\r\ngoto error_free_channels;\r\n}\r\nret = regulator_bulk_enable(st->chip_info->num_vrefs, st->vref_reg);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to enable vref regulators: %d\n", ret);\r\ngoto error_free_reg;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to register iio device: %d\n", ret);\r\ngoto error_disable_reg;\r\n}\r\nreturn 0;\r\nerror_disable_reg:\r\nregulator_bulk_disable(st->chip_info->num_vrefs, st->vref_reg);\r\nerror_free_reg:\r\nregulator_bulk_free(st->chip_info->num_vrefs, st->vref_reg);\r\nerror_free_channels:\r\nkfree(indio_dev->channels);\r\nerror_free:\r\niio_device_free(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int ad5360_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ad5360_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nkfree(indio_dev->channels);\r\nregulator_bulk_disable(st->chip_info->num_vrefs, st->vref_reg);\r\nregulator_bulk_free(st->chip_info->num_vrefs, st->vref_reg);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
