static inline struct tsi721_bdma_chan *to_tsi721_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct tsi721_bdma_chan, dchan);\r\n}\r\nstatic inline struct tsi721_device *to_tsi721(struct dma_device *ddev)\r\n{\r\nreturn container_of(ddev, struct rio_mport, dma)->priv;\r\n}\r\nstatic inline\r\nstruct tsi721_tx_desc *to_tsi721_desc(struct dma_async_tx_descriptor *txd)\r\n{\r\nreturn container_of(txd, struct tsi721_tx_desc, txd);\r\n}\r\nstatic inline\r\nstruct tsi721_tx_desc *tsi721_dma_first_active(\r\nstruct tsi721_bdma_chan *bdma_chan)\r\n{\r\nreturn list_first_entry(&bdma_chan->active_list,\r\nstruct tsi721_tx_desc, desc_node);\r\n}\r\nstatic int tsi721_bdma_ch_init(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nstruct tsi721_dma_desc *bd_ptr;\r\nstruct device *dev = bdma_chan->dchan.device->dev;\r\nu64 *sts_ptr;\r\ndma_addr_t bd_phys;\r\ndma_addr_t sts_phys;\r\nint sts_size;\r\nint bd_num = bdma_chan->bd_num;\r\ndev_dbg(dev, "Init Block DMA Engine, CH%d\n", bdma_chan->id);\r\nbd_ptr = dma_zalloc_coherent(dev,\r\nbd_num * sizeof(struct tsi721_dma_desc),\r\n&bd_phys, GFP_KERNEL);\r\nif (!bd_ptr)\r\nreturn -ENOMEM;\r\nbdma_chan->bd_phys = bd_phys;\r\nbdma_chan->bd_base = bd_ptr;\r\ndev_dbg(dev, "DMA descriptors @ %p (phys = %llx)\n",\r\nbd_ptr, (unsigned long long)bd_phys);\r\nsts_size = (bd_num >= TSI721_DMA_MINSTSSZ) ?\r\nbd_num : TSI721_DMA_MINSTSSZ;\r\nsts_size = roundup_pow_of_two(sts_size);\r\nsts_ptr = dma_zalloc_coherent(dev,\r\nsts_size * sizeof(struct tsi721_dma_sts),\r\n&sts_phys, GFP_KERNEL);\r\nif (!sts_ptr) {\r\ndma_free_coherent(dev,\r\nbd_num * sizeof(struct tsi721_dma_desc),\r\nbd_ptr, bd_phys);\r\nbdma_chan->bd_base = NULL;\r\nreturn -ENOMEM;\r\n}\r\nbdma_chan->sts_phys = sts_phys;\r\nbdma_chan->sts_base = sts_ptr;\r\nbdma_chan->sts_size = sts_size;\r\ndev_dbg(dev,\r\n"desc status FIFO @ %p (phys = %llx) size=0x%x\n",\r\nsts_ptr, (unsigned long long)sts_phys, sts_size);\r\nbd_ptr[bd_num - 1].type_id = cpu_to_le32(DTYPE3 << 29);\r\nbd_ptr[bd_num - 1].next_lo = cpu_to_le32((u64)bd_phys &\r\nTSI721_DMAC_DPTRL_MASK);\r\nbd_ptr[bd_num - 1].next_hi = cpu_to_le32((u64)bd_phys >> 32);\r\niowrite32(((u64)bd_phys >> 32),\r\nbdma_chan->regs + TSI721_DMAC_DPTRH);\r\niowrite32(((u64)bd_phys & TSI721_DMAC_DPTRL_MASK),\r\nbdma_chan->regs + TSI721_DMAC_DPTRL);\r\niowrite32(((u64)sts_phys >> 32),\r\nbdma_chan->regs + TSI721_DMAC_DSBH);\r\niowrite32(((u64)sts_phys & TSI721_DMAC_DSBL_MASK),\r\nbdma_chan->regs + TSI721_DMAC_DSBL);\r\niowrite32(TSI721_DMAC_DSSZ_SIZE(sts_size),\r\nbdma_chan->regs + TSI721_DMAC_DSSZ);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\niowrite32(TSI721_DMAC_CTL_INIT, bdma_chan->regs + TSI721_DMAC_CTL);\r\nioread32(bdma_chan->regs + TSI721_DMAC_CTL);\r\nbdma_chan->wr_count = bdma_chan->wr_count_next = 0;\r\nbdma_chan->sts_rdptr = 0;\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int tsi721_bdma_ch_free(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 ch_stat;\r\nif (bdma_chan->bd_base == NULL)\r\nreturn 0;\r\nch_stat = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\nif (ch_stat & TSI721_DMAC_STS_RUN)\r\nreturn -EFAULT;\r\niowrite32(TSI721_DMAC_CTL_INIT, bdma_chan->regs + TSI721_DMAC_CTL);\r\ndma_free_coherent(bdma_chan->dchan.device->dev,\r\nbdma_chan->bd_num * sizeof(struct tsi721_dma_desc),\r\nbdma_chan->bd_base, bdma_chan->bd_phys);\r\nbdma_chan->bd_base = NULL;\r\ndma_free_coherent(bdma_chan->dchan.device->dev,\r\nbdma_chan->sts_size * sizeof(struct tsi721_dma_sts),\r\nbdma_chan->sts_base, bdma_chan->sts_phys);\r\nbdma_chan->sts_base = NULL;\r\nreturn 0;\r\n}\r\nstatic void\r\ntsi721_bdma_interrupt_enable(struct tsi721_bdma_chan *bdma_chan, int enable)\r\n{\r\nif (enable) {\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INTE);\r\n} else {\r\niowrite32(0, bdma_chan->regs + TSI721_DMAC_INTE);\r\niowrite32(TSI721_DMAC_INT_ALL,\r\nbdma_chan->regs + TSI721_DMAC_INT);\r\n}\r\n}\r\nstatic bool tsi721_dma_is_idle(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 sts;\r\nsts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\nreturn ((sts & TSI721_DMAC_STS_RUN) == 0);\r\n}\r\nvoid tsi721_bdma_handler(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\niowrite32(0, bdma_chan->regs + TSI721_DMAC_INTE);\r\ntasklet_schedule(&bdma_chan->tasklet);\r\n}\r\nstatic irqreturn_t tsi721_bdma_msix(int irq, void *ptr)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = ptr;\r\ntsi721_bdma_handler(bdma_chan);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsi721_start_dma(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nif (!tsi721_dma_is_idle(bdma_chan)) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"BUG: Attempt to start non-idle channel\n");\r\nreturn;\r\n}\r\nif (bdma_chan->wr_count == bdma_chan->wr_count_next) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"BUG: Attempt to start DMA with no BDs ready\n");\r\nreturn;\r\n}\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"tx_chan: %p, chan: %d, regs: %p\n",\r\nbdma_chan, bdma_chan->dchan.chan_id, bdma_chan->regs);\r\niowrite32(bdma_chan->wr_count_next,\r\nbdma_chan->regs + TSI721_DMAC_DWRCNT);\r\nioread32(bdma_chan->regs + TSI721_DMAC_DWRCNT);\r\nbdma_chan->wr_count = bdma_chan->wr_count_next;\r\n}\r\nstatic void tsi721_desc_put(struct tsi721_bdma_chan *bdma_chan,\r\nstruct tsi721_tx_desc *desc)\r\n{\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"Put desc: %p into free list\n", desc);\r\nif (desc) {\r\nspin_lock_bh(&bdma_chan->lock);\r\nlist_splice_init(&desc->tx_list, &bdma_chan->free_list);\r\nlist_add(&desc->desc_node, &bdma_chan->free_list);\r\nbdma_chan->wr_count_next = bdma_chan->wr_count;\r\nspin_unlock_bh(&bdma_chan->lock);\r\n}\r\n}\r\nstatic\r\nstruct tsi721_tx_desc *tsi721_desc_get(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nstruct tsi721_tx_desc *tx_desc, *_tx_desc;\r\nstruct tsi721_tx_desc *ret = NULL;\r\nint i;\r\nspin_lock_bh(&bdma_chan->lock);\r\nlist_for_each_entry_safe(tx_desc, _tx_desc,\r\n&bdma_chan->free_list, desc_node) {\r\nif (async_tx_test_ack(&tx_desc->txd)) {\r\nlist_del(&tx_desc->desc_node);\r\nret = tx_desc;\r\nbreak;\r\n}\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"desc %p not ACKed\n", tx_desc);\r\n}\r\ni = bdma_chan->wr_count_next % bdma_chan->bd_num;\r\nif (i == bdma_chan->bd_num - 1) {\r\ni = 0;\r\nbdma_chan->wr_count_next++;\r\n}\r\nbdma_chan->wr_count_next++;\r\ntx_desc->txd.phys = bdma_chan->bd_phys +\r\ni * sizeof(struct tsi721_dma_desc);\r\ntx_desc->hw_desc = &((struct tsi721_dma_desc *)bdma_chan->bd_base)[i];\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn ret;\r\n}\r\nstatic int\r\ntsi721_fill_desc(struct tsi721_bdma_chan *bdma_chan,\r\nstruct tsi721_tx_desc *desc, struct scatterlist *sg,\r\nenum dma_rtype rtype, u32 sys_size)\r\n{\r\nstruct tsi721_dma_desc *bd_ptr = desc->hw_desc;\r\nu64 rio_addr;\r\nif (sg_dma_len(sg) > TSI721_DMAD_BCOUNT1 + 1) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"SG element is too large\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"desc: 0x%llx, addr: 0x%llx len: 0x%x\n",\r\n(u64)desc->txd.phys, (unsigned long long)sg_dma_address(sg),\r\nsg_dma_len(sg));\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"bd_ptr = %p did=%d raddr=0x%llx\n",\r\nbd_ptr, desc->destid, desc->rio_addr);\r\nbd_ptr->type_id = cpu_to_le32((DTYPE1 << 29) |\r\n(rtype << 19) | desc->destid);\r\nif (desc->interrupt)\r\nbd_ptr->type_id |= cpu_to_le32(TSI721_DMAD_IOF);\r\nbd_ptr->bcount = cpu_to_le32(((desc->rio_addr & 0x3) << 30) |\r\n(sys_size << 26) | sg_dma_len(sg));\r\nrio_addr = (desc->rio_addr >> 2) |\r\n((u64)(desc->rio_addr_u & 0x3) << 62);\r\nbd_ptr->raddr_lo = cpu_to_le32(rio_addr & 0xffffffff);\r\nbd_ptr->raddr_hi = cpu_to_le32(rio_addr >> 32);\r\nbd_ptr->t1.bufptr_lo = cpu_to_le32(\r\n(u64)sg_dma_address(sg) & 0xffffffff);\r\nbd_ptr->t1.bufptr_hi = cpu_to_le32((u64)sg_dma_address(sg) >> 32);\r\nbd_ptr->t1.s_dist = 0;\r\nbd_ptr->t1.s_size = 0;\r\nreturn 0;\r\n}\r\nstatic void tsi721_dma_chain_complete(struct tsi721_bdma_chan *bdma_chan,\r\nstruct tsi721_tx_desc *desc)\r\n{\r\nstruct dma_async_tx_descriptor *txd = &desc->txd;\r\ndma_async_tx_callback callback = txd->callback;\r\nvoid *param = txd->callback_param;\r\nlist_splice_init(&desc->tx_list, &bdma_chan->free_list);\r\nlist_move(&desc->desc_node, &bdma_chan->free_list);\r\nbdma_chan->completed_cookie = txd->cookie;\r\nif (callback)\r\ncallback(param);\r\n}\r\nstatic void tsi721_dma_complete_all(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nstruct tsi721_tx_desc *desc, *_d;\r\nLIST_HEAD(list);\r\nBUG_ON(!tsi721_dma_is_idle(bdma_chan));\r\nif (!list_empty(&bdma_chan->queue))\r\ntsi721_start_dma(bdma_chan);\r\nlist_splice_init(&bdma_chan->active_list, &list);\r\nlist_splice_init(&bdma_chan->queue, &bdma_chan->active_list);\r\nlist_for_each_entry_safe(desc, _d, &list, desc_node)\r\ntsi721_dma_chain_complete(bdma_chan, desc);\r\n}\r\nstatic void tsi721_clr_stat(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nu32 srd_ptr;\r\nu64 *sts_ptr;\r\nint i, j;\r\nsrd_ptr = bdma_chan->sts_rdptr;\r\nsts_ptr = bdma_chan->sts_base;\r\nj = srd_ptr * 8;\r\nwhile (sts_ptr[j]) {\r\nfor (i = 0; i < 8 && sts_ptr[j]; i++, j++)\r\nsts_ptr[j] = 0;\r\n++srd_ptr;\r\nsrd_ptr %= bdma_chan->sts_size;\r\nj = srd_ptr * 8;\r\n}\r\niowrite32(srd_ptr, bdma_chan->regs + TSI721_DMAC_DSRP);\r\nbdma_chan->sts_rdptr = srd_ptr;\r\n}\r\nstatic void tsi721_advance_work(struct tsi721_bdma_chan *bdma_chan)\r\n{\r\nif (list_empty(&bdma_chan->active_list) ||\r\nlist_is_singular(&bdma_chan->active_list)) {\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"%s: Active_list empty\n", __func__);\r\ntsi721_dma_complete_all(bdma_chan);\r\n} else {\r\ndev_dbg(bdma_chan->dchan.device->dev,\r\n"%s: Active_list NOT empty\n", __func__);\r\ntsi721_dma_chain_complete(bdma_chan,\r\ntsi721_dma_first_active(bdma_chan));\r\ntsi721_start_dma(bdma_chan);\r\n}\r\n}\r\nstatic void tsi721_dma_tasklet(unsigned long data)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = (struct tsi721_bdma_chan *)data;\r\nu32 dmac_int, dmac_sts;\r\ndmac_int = ioread32(bdma_chan->regs + TSI721_DMAC_INT);\r\ndev_dbg(bdma_chan->dchan.device->dev, "%s: DMAC%d_INT = 0x%x\n",\r\n__func__, bdma_chan->id, dmac_int);\r\niowrite32(dmac_int, bdma_chan->regs + TSI721_DMAC_INT);\r\nif (dmac_int & TSI721_DMAC_INT_ERR) {\r\ndmac_sts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"%s: DMA ERROR - DMAC%d_STS = 0x%x\n",\r\n__func__, bdma_chan->id, dmac_sts);\r\n}\r\nif (dmac_int & TSI721_DMAC_INT_STFULL) {\r\ndev_err(bdma_chan->dchan.device->dev,\r\n"%s: DMAC%d descriptor status FIFO is full\n",\r\n__func__, bdma_chan->id);\r\n}\r\nif (dmac_int & (TSI721_DMAC_INT_DONE | TSI721_DMAC_INT_IOFDONE)) {\r\ntsi721_clr_stat(bdma_chan);\r\nspin_lock(&bdma_chan->lock);\r\ntsi721_advance_work(bdma_chan);\r\nspin_unlock(&bdma_chan->lock);\r\n}\r\niowrite32(TSI721_DMAC_INT_ALL, bdma_chan->regs + TSI721_DMAC_INTE);\r\n}\r\nstatic dma_cookie_t tsi721_tx_submit(struct dma_async_tx_descriptor *txd)\r\n{\r\nstruct tsi721_tx_desc *desc = to_tsi721_desc(txd);\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(txd->chan);\r\ndma_cookie_t cookie;\r\nspin_lock_bh(&bdma_chan->lock);\r\ncookie = txd->chan->cookie;\r\nif (++cookie < 0)\r\ncookie = 1;\r\ntxd->chan->cookie = cookie;\r\ntxd->cookie = cookie;\r\nif (list_empty(&bdma_chan->active_list)) {\r\nlist_add_tail(&desc->desc_node, &bdma_chan->active_list);\r\ntsi721_start_dma(bdma_chan);\r\n} else {\r\nlist_add_tail(&desc->desc_node, &bdma_chan->queue);\r\n}\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn cookie;\r\n}\r\nstatic int tsi721_alloc_chan_resources(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\n#ifdef CONFIG_PCI_MSI\r\nstruct tsi721_device *priv = to_tsi721(dchan->device);\r\n#endif\r\nstruct tsi721_tx_desc *desc = NULL;\r\nLIST_HEAD(tmp_list);\r\nint i;\r\nint rc;\r\nif (bdma_chan->bd_base)\r\nreturn bdma_chan->bd_num - 1;\r\nif (tsi721_bdma_ch_init(bdma_chan)) {\r\ndev_err(dchan->device->dev, "Unable to initialize data DMA"\r\n" channel %d, aborting\n", bdma_chan->id);\r\nreturn -ENOMEM;\r\n}\r\ndesc = kcalloc((bdma_chan->bd_num - 1), sizeof(struct tsi721_tx_desc),\r\nGFP_KERNEL);\r\nif (!desc) {\r\ndev_err(dchan->device->dev,\r\n"Failed to allocate logical descriptors\n");\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nbdma_chan->tx_desc = desc;\r\nfor (i = 0; i < bdma_chan->bd_num - 1; i++) {\r\ndma_async_tx_descriptor_init(&desc[i].txd, dchan);\r\ndesc[i].txd.tx_submit = tsi721_tx_submit;\r\ndesc[i].txd.flags = DMA_CTRL_ACK;\r\nINIT_LIST_HEAD(&desc[i].tx_list);\r\nlist_add_tail(&desc[i].desc_node, &tmp_list);\r\n}\r\nspin_lock_bh(&bdma_chan->lock);\r\nlist_splice(&tmp_list, &bdma_chan->free_list);\r\nbdma_chan->completed_cookie = dchan->cookie = 1;\r\nspin_unlock_bh(&bdma_chan->lock);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nrc = request_irq(\r\npriv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector,\r\ntsi721_bdma_msix, 0,\r\npriv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].irq_name,\r\n(void *)bdma_chan);\r\nif (rc) {\r\ndev_dbg(dchan->device->dev,\r\n"Unable to allocate MSI-X interrupt for "\r\n"BDMA%d-DONE\n", bdma_chan->id);\r\ngoto err_out;\r\n}\r\nrc = request_irq(priv->msix[TSI721_VECT_DMA0_INT +\r\nbdma_chan->id].vector,\r\ntsi721_bdma_msix, 0,\r\npriv->msix[TSI721_VECT_DMA0_INT +\r\nbdma_chan->id].irq_name,\r\n(void *)bdma_chan);\r\nif (rc) {\r\ndev_dbg(dchan->device->dev,\r\n"Unable to allocate MSI-X interrupt for "\r\n"BDMA%d-INT\n", bdma_chan->id);\r\nfree_irq(\r\npriv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector,\r\n(void *)bdma_chan);\r\nrc = -EIO;\r\ngoto err_out;\r\n}\r\n}\r\n#endif\r\ntasklet_enable(&bdma_chan->tasklet);\r\ntsi721_bdma_interrupt_enable(bdma_chan, 1);\r\nreturn bdma_chan->bd_num - 1;\r\nerr_out:\r\nkfree(desc);\r\ntsi721_bdma_ch_free(bdma_chan);\r\nreturn rc;\r\n}\r\nstatic void tsi721_free_chan_resources(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\n#ifdef CONFIG_PCI_MSI\r\nstruct tsi721_device *priv = to_tsi721(dchan->device);\r\n#endif\r\nLIST_HEAD(list);\r\ndev_dbg(dchan->device->dev, "%s: Entry\n", __func__);\r\nif (bdma_chan->bd_base == NULL)\r\nreturn;\r\nBUG_ON(!list_empty(&bdma_chan->active_list));\r\nBUG_ON(!list_empty(&bdma_chan->queue));\r\ntasklet_disable(&bdma_chan->tasklet);\r\nspin_lock_bh(&bdma_chan->lock);\r\nlist_splice_init(&bdma_chan->free_list, &list);\r\nspin_unlock_bh(&bdma_chan->lock);\r\ntsi721_bdma_interrupt_enable(bdma_chan, 0);\r\n#ifdef CONFIG_PCI_MSI\r\nif (priv->flags & TSI721_USING_MSIX) {\r\nfree_irq(priv->msix[TSI721_VECT_DMA0_DONE +\r\nbdma_chan->id].vector, (void *)bdma_chan);\r\nfree_irq(priv->msix[TSI721_VECT_DMA0_INT +\r\nbdma_chan->id].vector, (void *)bdma_chan);\r\n}\r\n#endif\r\ntsi721_bdma_ch_free(bdma_chan);\r\nkfree(bdma_chan->tx_desc);\r\n}\r\nstatic\r\nenum dma_status tsi721_tx_status(struct dma_chan *dchan, dma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\ndma_cookie_t last_used;\r\ndma_cookie_t last_completed;\r\nint ret;\r\nspin_lock_bh(&bdma_chan->lock);\r\nlast_completed = bdma_chan->completed_cookie;\r\nlast_used = dchan->cookie;\r\nspin_unlock_bh(&bdma_chan->lock);\r\nret = dma_async_is_complete(cookie, last_completed, last_used);\r\ndma_set_tx_state(txstate, last_completed, last_used, 0);\r\ndev_dbg(dchan->device->dev,\r\n"%s: exit, ret: %d, last_completed: %d, last_used: %d\n",\r\n__func__, ret, last_completed, last_used);\r\nreturn ret;\r\n}\r\nstatic void tsi721_issue_pending(struct dma_chan *dchan)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\ndev_dbg(dchan->device->dev, "%s: Entry\n", __func__);\r\nif (tsi721_dma_is_idle(bdma_chan)) {\r\nspin_lock_bh(&bdma_chan->lock);\r\ntsi721_advance_work(bdma_chan);\r\nspin_unlock_bh(&bdma_chan->lock);\r\n} else\r\ndev_dbg(dchan->device->dev,\r\n"%s: DMA channel still busy\n", __func__);\r\n}\r\nstatic\r\nstruct dma_async_tx_descriptor *tsi721_prep_rio_sg(struct dma_chan *dchan,\r\nstruct scatterlist *sgl, unsigned int sg_len,\r\nenum dma_transfer_direction dir, unsigned long flags,\r\nvoid *tinfo)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nstruct tsi721_tx_desc *desc = NULL;\r\nstruct tsi721_tx_desc *first = NULL;\r\nstruct scatterlist *sg;\r\nstruct rio_dma_ext *rext = tinfo;\r\nu64 rio_addr = rext->rio_addr;\r\nunsigned int i;\r\nu32 sys_size = dma_to_mport(dchan->device)->sys_size;\r\nenum dma_rtype rtype;\r\nif (!sgl || !sg_len) {\r\ndev_err(dchan->device->dev, "%s: No SG list\n", __func__);\r\nreturn NULL;\r\n}\r\nif (dir == DMA_DEV_TO_MEM)\r\nrtype = NREAD;\r\nelse if (dir == DMA_MEM_TO_DEV) {\r\nswitch (rext->wr_type) {\r\ncase RDW_ALL_NWRITE:\r\nrtype = ALL_NWRITE;\r\nbreak;\r\ncase RDW_ALL_NWRITE_R:\r\nrtype = ALL_NWRITE_R;\r\nbreak;\r\ncase RDW_LAST_NWRITE_R:\r\ndefault:\r\nrtype = LAST_NWRITE_R;\r\nbreak;\r\n}\r\n} else {\r\ndev_err(dchan->device->dev,\r\n"%s: Unsupported DMA direction option\n", __func__);\r\nreturn NULL;\r\n}\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\nint err;\r\ndev_dbg(dchan->device->dev, "%s: sg #%d\n", __func__, i);\r\ndesc = tsi721_desc_get(bdma_chan);\r\nif (!desc) {\r\ndev_err(dchan->device->dev,\r\n"Not enough descriptors available\n");\r\ngoto err_desc_get;\r\n}\r\nif (sg_is_last(sg))\r\ndesc->interrupt = (flags & DMA_PREP_INTERRUPT) != 0;\r\nelse\r\ndesc->interrupt = false;\r\ndesc->destid = rext->destid;\r\ndesc->rio_addr = rio_addr;\r\ndesc->rio_addr_u = 0;\r\nerr = tsi721_fill_desc(bdma_chan, desc, sg, rtype, sys_size);\r\nif (err) {\r\ndev_err(dchan->device->dev,\r\n"Failed to build desc: %d\n", err);\r\ngoto err_desc_get;\r\n}\r\nrio_addr += sg_dma_len(sg);\r\nif (!first)\r\nfirst = desc;\r\nelse\r\nlist_add_tail(&desc->desc_node, &first->tx_list);\r\n}\r\nfirst->txd.cookie = -EBUSY;\r\ndesc->txd.flags = flags;\r\nreturn &first->txd;\r\nerr_desc_get:\r\ntsi721_desc_put(bdma_chan, first);\r\nreturn NULL;\r\n}\r\nstatic int tsi721_device_control(struct dma_chan *dchan, enum dma_ctrl_cmd cmd,\r\nunsigned long arg)\r\n{\r\nstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\r\nstruct tsi721_tx_desc *desc, *_d;\r\nLIST_HEAD(list);\r\ndev_dbg(dchan->device->dev, "%s: Entry\n", __func__);\r\nif (cmd != DMA_TERMINATE_ALL)\r\nreturn -ENXIO;\r\nspin_lock_bh(&bdma_chan->lock);\r\niowrite32(TSI721_DMAC_CTL_SUSP, bdma_chan->regs + TSI721_DMAC_CTL);\r\nlist_splice_init(&bdma_chan->active_list, &list);\r\nlist_splice_init(&bdma_chan->queue, &list);\r\nlist_for_each_entry_safe(desc, _d, &list, desc_node)\r\ntsi721_dma_chain_complete(bdma_chan, desc);\r\nspin_unlock_bh(&bdma_chan->lock);\r\nreturn 0;\r\n}\r\nint tsi721_register_dma(struct tsi721_device *priv)\r\n{\r\nint i;\r\nint nr_channels = TSI721_DMA_MAXCH;\r\nint err;\r\nstruct rio_mport *mport = priv->mport;\r\nmport->dma.dev = &priv->pdev->dev;\r\nmport->dma.chancnt = nr_channels;\r\nINIT_LIST_HEAD(&mport->dma.channels);\r\nfor (i = 0; i < nr_channels; i++) {\r\nstruct tsi721_bdma_chan *bdma_chan = &priv->bdma[i];\r\nif (i == TSI721_DMACH_MAINT)\r\ncontinue;\r\nbdma_chan->bd_num = 64;\r\nbdma_chan->regs = priv->regs + TSI721_DMAC_BASE(i);\r\nbdma_chan->dchan.device = &mport->dma;\r\nbdma_chan->dchan.cookie = 1;\r\nbdma_chan->dchan.chan_id = i;\r\nbdma_chan->id = i;\r\nspin_lock_init(&bdma_chan->lock);\r\nINIT_LIST_HEAD(&bdma_chan->active_list);\r\nINIT_LIST_HEAD(&bdma_chan->queue);\r\nINIT_LIST_HEAD(&bdma_chan->free_list);\r\ntasklet_init(&bdma_chan->tasklet, tsi721_dma_tasklet,\r\n(unsigned long)bdma_chan);\r\ntasklet_disable(&bdma_chan->tasklet);\r\nlist_add_tail(&bdma_chan->dchan.device_node,\r\n&mport->dma.channels);\r\n}\r\ndma_cap_zero(mport->dma.cap_mask);\r\ndma_cap_set(DMA_PRIVATE, mport->dma.cap_mask);\r\ndma_cap_set(DMA_SLAVE, mport->dma.cap_mask);\r\nmport->dma.device_alloc_chan_resources = tsi721_alloc_chan_resources;\r\nmport->dma.device_free_chan_resources = tsi721_free_chan_resources;\r\nmport->dma.device_tx_status = tsi721_tx_status;\r\nmport->dma.device_issue_pending = tsi721_issue_pending;\r\nmport->dma.device_prep_slave_sg = tsi721_prep_rio_sg;\r\nmport->dma.device_control = tsi721_device_control;\r\nerr = dma_async_device_register(&mport->dma);\r\nif (err)\r\ndev_err(&priv->pdev->dev, "Failed to register DMA device\n");\r\nreturn err;\r\n}
