static int wacom_get_report(struct usb_interface *intf, u8 type, u8 id,\r\nvoid *buf, size_t size, unsigned int retries)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nint retval;\r\ndo {\r\nretval = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nUSB_REQ_GET_REPORT,\r\nUSB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE,\r\n(type << 8) + id,\r\nintf->altsetting[0].desc.bInterfaceNumber,\r\nbuf, size, 100);\r\n} while ((retval == -ETIMEDOUT || retval == -EPIPE) && --retries);\r\nreturn retval;\r\n}\r\nstatic int wacom_set_report(struct usb_interface *intf, u8 type, u8 id,\r\nvoid *buf, size_t size, unsigned int retries)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nint retval;\r\ndo {\r\nretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nUSB_REQ_SET_REPORT,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n(type << 8) + id,\r\nintf->altsetting[0].desc.bInterfaceNumber,\r\nbuf, size, 1000);\r\n} while ((retval == -ETIMEDOUT || retval == -EPIPE) && --retries);\r\nreturn retval;\r\n}\r\nstatic void wacom_sys_irq(struct urb *urb)\r\n{\r\nstruct wacom *wacom = urb->context;\r\nstruct device *dev = &wacom->intf->dev;\r\nint retval;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n",\r\n__func__, urb->status);\r\ngoto exit;\r\n}\r\nwacom_wac_irq(&wacom->wacom_wac, urb->actual_length);\r\nexit:\r\nusb_mark_last_busy(wacom->usbdev);\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(dev, "%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic int wacom_open(struct input_dev *dev)\r\n{\r\nstruct wacom *wacom = input_get_drvdata(dev);\r\nint retval = 0;\r\nif (usb_autopm_get_interface(wacom->intf) < 0)\r\nreturn -EIO;\r\nmutex_lock(&wacom->lock);\r\nif (usb_submit_urb(wacom->irq, GFP_KERNEL)) {\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nwacom->open = true;\r\nwacom->intf->needs_remote_wakeup = 1;\r\nout:\r\nmutex_unlock(&wacom->lock);\r\nusb_autopm_put_interface(wacom->intf);\r\nreturn retval;\r\n}\r\nstatic void wacom_close(struct input_dev *dev)\r\n{\r\nstruct wacom *wacom = input_get_drvdata(dev);\r\nint autopm_error;\r\nautopm_error = usb_autopm_get_interface(wacom->intf);\r\nmutex_lock(&wacom->lock);\r\nusb_kill_urb(wacom->irq);\r\nwacom->open = false;\r\nwacom->intf->needs_remote_wakeup = 0;\r\nmutex_unlock(&wacom->lock);\r\nif (!autopm_error)\r\nusb_autopm_put_interface(wacom->intf);\r\n}\r\nstatic int wacom_calc_hid_res(int logical_extents, int physical_extents,\r\nunsigned char unit, unsigned char exponent)\r\n{\r\nint prev, unit_exponent;\r\nif (logical_extents <= 0 || physical_extents <= 0)\r\nreturn 0;\r\nunit_exponent = exponent;\r\nif (unit_exponent > 7)\r\nunit_exponent -= 16;\r\nif (unit == 0x11) {\r\nunit_exponent += 1;\r\n} else if (unit == 0x13) {\r\nprev = physical_extents;\r\nphysical_extents *= 254;\r\nif (physical_extents < prev)\r\nreturn 0;\r\nunit_exponent -= 1;\r\n} else {\r\nreturn 0;\r\n}\r\nfor (; unit_exponent < 0; unit_exponent++) {\r\nprev = logical_extents;\r\nlogical_extents *= 10;\r\nif (logical_extents < prev)\r\nreturn 0;\r\n}\r\nfor (; unit_exponent > 0; unit_exponent--) {\r\nprev = physical_extents;\r\nphysical_extents *= 10;\r\nif (physical_extents < prev)\r\nreturn 0;\r\n}\r\nreturn logical_extents / physical_extents;\r\n}\r\nstatic void wacom_fix_phy_from_hid(struct wacom_features *features)\r\n{\r\nint xres = wacom_calc_hid_res(features->x_max, features->x_phy,\r\nfeatures->unit, features->unitExpo);\r\nint yres = wacom_calc_hid_res(features->y_max, features->y_phy,\r\nfeatures->unit, features->unitExpo);\r\nif (xres > 0 && yres > 0) {\r\nfeatures->x_phy = (100 * features->x_max) / xres;\r\nfeatures->y_phy = (100 * features->y_max) / yres;\r\n}\r\n}\r\nstatic void wacom_set_phy_from_res(struct wacom_features *features)\r\n{\r\nfeatures->x_phy = (features->x_max * 100) / features->x_resolution;\r\nfeatures->y_phy = (features->y_max * 100) / features->y_resolution;\r\n}\r\nstatic int wacom_parse_logical_collection(unsigned char *report,\r\nstruct wacom_features *features)\r\n{\r\nint length = 0;\r\nif (features->type == BAMBOO_PT) {\r\nfeatures->pktlen = WACOM_PKGLEN_BBTOUCH3;\r\nfeatures->device_type = BTN_TOOL_FINGER;\r\nwacom_set_phy_from_res(features);\r\nfeatures->x_max = features->y_max =\r\nget_unaligned_le16(&report[10]);\r\nlength = 11;\r\n}\r\nreturn length;\r\n}\r\nstatic void wacom_retrieve_report_data(struct usb_interface *intf,\r\nstruct wacom_features *features)\r\n{\r\nint result = 0;\r\nunsigned char *rep_data;\r\nrep_data = kmalloc(2, GFP_KERNEL);\r\nif (rep_data) {\r\nrep_data[0] = 12;\r\nresult = wacom_get_report(intf, WAC_HID_FEATURE_REPORT,\r\nrep_data[0], rep_data, 2,\r\nWAC_MSG_RETRIES);\r\nif (result >= 0 && rep_data[1] > 2)\r\nfeatures->touch_max = rep_data[1];\r\nkfree(rep_data);\r\n}\r\n}\r\nstatic int wacom_parse_hid(struct usb_interface *intf,\r\nstruct hid_descriptor *hid_desc,\r\nstruct wacom_features *features)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nchar limit = 0;\r\nint result = 0;\r\nint i = 0, usage = WCM_UNDEFINED, finger = 0, pen = 0;\r\nunsigned char *report;\r\nreport = kzalloc(hid_desc->wDescriptorLength, GFP_KERNEL);\r\nif (!report)\r\nreturn -ENOMEM;\r\ndo {\r\nresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nUSB_REQ_GET_DESCRIPTOR,\r\nUSB_RECIP_INTERFACE | USB_DIR_IN,\r\nHID_DEVICET_REPORT << 8,\r\nintf->altsetting[0].desc.bInterfaceNumber,\r\nreport,\r\nhid_desc->wDescriptorLength,\r\n5000);\r\n} while (result < 0 && limit++ < WAC_MSG_RETRIES);\r\nif (result < 0)\r\ngoto out;\r\nfor (i = 0; i < hid_desc->wDescriptorLength; i++) {\r\nswitch (report[i]) {\r\ncase HID_USAGE_PAGE:\r\nswitch (report[i + 1]) {\r\ncase HID_USAGE_PAGE_DIGITIZER:\r\nusage = WCM_DIGITIZER;\r\ni++;\r\nbreak;\r\ncase HID_USAGE_PAGE_DESKTOP:\r\nusage = WCM_DESKTOP;\r\ni++;\r\nbreak;\r\n}\r\nbreak;\r\ncase HID_USAGE:\r\nswitch (report[i + 1]) {\r\ncase HID_USAGE_X:\r\nif (usage == WCM_DESKTOP) {\r\nif (finger) {\r\nfeatures->device_type = BTN_TOOL_FINGER;\r\nswitch (features->type) {\r\ncase TABLETPC2FG:\r\nfeatures->pktlen = WACOM_PKGLEN_TPC2FG;\r\nbreak;\r\ncase MTSCREEN:\r\ncase WACOM_24HDT:\r\nfeatures->pktlen = WACOM_PKGLEN_MTOUCH;\r\nbreak;\r\ncase MTTPC:\r\nfeatures->pktlen = WACOM_PKGLEN_MTTPC;\r\nbreak;\r\ncase BAMBOO_PT:\r\nfeatures->pktlen = WACOM_PKGLEN_BBTOUCH;\r\nbreak;\r\ndefault:\r\nfeatures->pktlen = WACOM_PKGLEN_GRAPHIRE;\r\nbreak;\r\n}\r\nswitch (features->type) {\r\ncase BAMBOO_PT:\r\nfeatures->x_phy =\r\nget_unaligned_le16(&report[i + 5]);\r\nfeatures->x_max =\r\nget_unaligned_le16(&report[i + 8]);\r\ni += 15;\r\nbreak;\r\ncase WACOM_24HDT:\r\nfeatures->x_max =\r\nget_unaligned_le16(&report[i + 3]);\r\nfeatures->x_phy =\r\nget_unaligned_le16(&report[i + 8]);\r\nfeatures->unit = report[i - 1];\r\nfeatures->unitExpo = report[i - 3];\r\ni += 12;\r\nbreak;\r\ndefault:\r\nfeatures->x_max =\r\nget_unaligned_le16(&report[i + 3]);\r\nfeatures->x_phy =\r\nget_unaligned_le16(&report[i + 6]);\r\nfeatures->unit = report[i + 9];\r\nfeatures->unitExpo = report[i + 11];\r\ni += 12;\r\nbreak;\r\n}\r\n} else if (pen) {\r\nif (features->type >= TABLETPC)\r\nfeatures->pktlen = WACOM_PKGLEN_GRAPHIRE;\r\nfeatures->device_type = BTN_TOOL_PEN;\r\nfeatures->x_max =\r\nget_unaligned_le16(&report[i + 3]);\r\ni += 4;\r\n}\r\n}\r\nbreak;\r\ncase HID_USAGE_Y:\r\nif (usage == WCM_DESKTOP) {\r\nif (finger) {\r\nswitch (features->type) {\r\ncase TABLETPC2FG:\r\ncase MTSCREEN:\r\ncase MTTPC:\r\nfeatures->y_max =\r\nget_unaligned_le16(&report[i + 3]);\r\nfeatures->y_phy =\r\nget_unaligned_le16(&report[i + 6]);\r\ni += 7;\r\nbreak;\r\ncase WACOM_24HDT:\r\nfeatures->y_max =\r\nget_unaligned_le16(&report[i + 3]);\r\nfeatures->y_phy =\r\nget_unaligned_le16(&report[i - 2]);\r\ni += 7;\r\nbreak;\r\ncase BAMBOO_PT:\r\nfeatures->y_phy =\r\nget_unaligned_le16(&report[i + 3]);\r\nfeatures->y_max =\r\nget_unaligned_le16(&report[i + 6]);\r\ni += 12;\r\nbreak;\r\ndefault:\r\nfeatures->y_max =\r\nfeatures->x_max;\r\nfeatures->y_phy =\r\nget_unaligned_le16(&report[i + 3]);\r\ni += 4;\r\nbreak;\r\n}\r\n} else if (pen) {\r\nfeatures->y_max =\r\nget_unaligned_le16(&report[i + 3]);\r\ni += 4;\r\n}\r\n}\r\nbreak;\r\ncase HID_USAGE_FINGER:\r\nfinger = 1;\r\ni++;\r\nbreak;\r\ncase HID_USAGE_STYLUS:\r\npen = 1;\r\ni++;\r\nbreak;\r\ncase HID_USAGE_CONTACTMAX:\r\nif (!features->touch_max)\r\nwacom_retrieve_report_data(intf, features);\r\ni++;\r\nbreak;\r\n}\r\nbreak;\r\ncase HID_COLLECTION_END:\r\nfinger = usage = 0;\r\nbreak;\r\ncase HID_COLLECTION:\r\ni++;\r\nswitch (report[i]) {\r\ncase HID_COLLECTION_LOGICAL:\r\ni += wacom_parse_logical_collection(&report[i],\r\nfeatures);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nout:\r\nresult = 0;\r\nkfree(report);\r\nreturn result;\r\n}\r\nstatic int wacom_set_device_mode(struct usb_interface *intf, int report_id, int length, int mode)\r\n{\r\nunsigned char *rep_data;\r\nint error = -ENOMEM, limit = 0;\r\nrep_data = kzalloc(length, GFP_KERNEL);\r\nif (!rep_data)\r\nreturn error;\r\ndo {\r\nrep_data[0] = report_id;\r\nrep_data[1] = mode;\r\nerror = wacom_set_report(intf, WAC_HID_FEATURE_REPORT,\r\nreport_id, rep_data, length, 1);\r\nif (error >= 0)\r\nerror = wacom_get_report(intf, WAC_HID_FEATURE_REPORT,\r\nreport_id, rep_data, length, 1);\r\n} while ((error < 0 || rep_data[1] != mode) && limit++ < WAC_MSG_RETRIES);\r\nkfree(rep_data);\r\nreturn error < 0 ? error : 0;\r\n}\r\nstatic int wacom_query_tablet_data(struct usb_interface *intf, struct wacom_features *features)\r\n{\r\nif (features->device_type == BTN_TOOL_FINGER) {\r\nif (features->type > TABLETPC) {\r\nreturn wacom_set_device_mode(intf, 3, 4, 4);\r\n}\r\nelse if (features->type == WACOM_24HDT) {\r\nreturn wacom_set_device_mode(intf, 18, 3, 2);\r\n}\r\n} else if (features->device_type == BTN_TOOL_PEN) {\r\nif (features->type <= BAMBOO_PT && features->type != WIRELESS) {\r\nreturn wacom_set_device_mode(intf, 2, 2, 2);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_retrieve_hid_descriptor(struct usb_interface *intf,\r\nstruct wacom_features *features)\r\n{\r\nint error = 0;\r\nstruct usb_host_interface *interface = intf->cur_altsetting;\r\nstruct hid_descriptor *hid_desc;\r\nfeatures->device_type = BTN_TOOL_PEN;\r\nfeatures->x_fuzz = 4;\r\nfeatures->y_fuzz = 4;\r\nfeatures->pressure_fuzz = 0;\r\nfeatures->distance_fuzz = 0;\r\nif (features->type == WIRELESS) {\r\nif (intf->cur_altsetting->desc.bInterfaceNumber == 0) {\r\nfeatures->device_type = 0;\r\n} else if (intf->cur_altsetting->desc.bInterfaceNumber == 2) {\r\nfeatures->device_type = BTN_TOOL_FINGER;\r\nfeatures->pktlen = WACOM_PKGLEN_BBTOUCH3;\r\n}\r\n}\r\nif (features->type < BAMBOO_PT) {\r\ngoto out;\r\n}\r\nerror = usb_get_extra_descriptor(interface, HID_DEVICET_HID, &hid_desc);\r\nif (error) {\r\nerror = usb_get_extra_descriptor(&interface->endpoint[0],\r\nHID_DEVICET_REPORT, &hid_desc);\r\nif (error) {\r\ndev_err(&intf->dev,\r\n"can not retrieve extra class descriptor\n");\r\ngoto out;\r\n}\r\n}\r\nerror = wacom_parse_hid(intf, hid_desc, features);\r\nif (error)\r\ngoto out;\r\nwacom_fix_phy_from_hid(features);\r\nout:\r\nreturn error;\r\n}\r\nstatic struct usb_device *wacom_get_sibling(struct usb_device *dev, int vendor, int product)\r\n{\r\nint port1;\r\nstruct usb_device *sibling;\r\nif (vendor == 0 && product == 0)\r\nreturn dev;\r\nif (dev->parent == NULL)\r\nreturn NULL;\r\nusb_hub_for_each_child(dev->parent, port1, sibling) {\r\nstruct usb_device_descriptor *d;\r\nif (sibling == NULL)\r\ncontinue;\r\nd = &sibling->descriptor;\r\nif (d->idVendor == vendor && d->idProduct == product)\r\nreturn sibling;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct wacom_usbdev_data *wacom_get_usbdev_data(struct usb_device *dev)\r\n{\r\nstruct wacom_usbdev_data *data;\r\nlist_for_each_entry(data, &wacom_udev_list, list) {\r\nif (data->dev == dev) {\r\nkref_get(&data->kref);\r\nreturn data;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int wacom_add_shared_data(struct wacom_wac *wacom,\r\nstruct usb_device *dev)\r\n{\r\nstruct wacom_usbdev_data *data;\r\nint retval = 0;\r\nmutex_lock(&wacom_udev_list_lock);\r\ndata = wacom_get_usbdev_data(dev);\r\nif (!data) {\r\ndata = kzalloc(sizeof(struct wacom_usbdev_data), GFP_KERNEL);\r\nif (!data) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nkref_init(&data->kref);\r\ndata->dev = dev;\r\nlist_add_tail(&data->list, &wacom_udev_list);\r\n}\r\nwacom->shared = &data->shared;\r\nout:\r\nmutex_unlock(&wacom_udev_list_lock);\r\nreturn retval;\r\n}\r\nstatic void wacom_release_shared_data(struct kref *kref)\r\n{\r\nstruct wacom_usbdev_data *data =\r\ncontainer_of(kref, struct wacom_usbdev_data, kref);\r\nmutex_lock(&wacom_udev_list_lock);\r\nlist_del(&data->list);\r\nmutex_unlock(&wacom_udev_list_lock);\r\nkfree(data);\r\n}\r\nstatic void wacom_remove_shared_data(struct wacom_wac *wacom)\r\n{\r\nstruct wacom_usbdev_data *data;\r\nif (wacom->shared) {\r\ndata = container_of(wacom->shared, struct wacom_usbdev_data, shared);\r\nkref_put(&data->kref, wacom_release_shared_data);\r\nwacom->shared = NULL;\r\n}\r\n}\r\nstatic int wacom_led_control(struct wacom *wacom)\r\n{\r\nunsigned char *buf;\r\nint retval;\r\nbuf = kzalloc(9, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (wacom->wacom_wac.features.type >= INTUOS5S &&\r\nwacom->wacom_wac.features.type <= INTUOS5L) {\r\nint ring_led = wacom->led.select[0] & 0x03;\r\nint ring_lum = (((wacom->led.llv & 0x60) >> 5) - 1) & 0x03;\r\nint crop_lum = 0;\r\nbuf[0] = WAC_CMD_LED_CONTROL;\r\nbuf[1] = (crop_lum << 4) | (ring_lum << 2) | (ring_led);\r\n}\r\nelse {\r\nint led = wacom->led.select[0] | 0x4;\r\nif (wacom->wacom_wac.features.type == WACOM_21UX2 ||\r\nwacom->wacom_wac.features.type == WACOM_24HD)\r\nled |= (wacom->led.select[1] << 4) | 0x40;\r\nbuf[0] = WAC_CMD_LED_CONTROL;\r\nbuf[1] = led;\r\nbuf[2] = wacom->led.llv;\r\nbuf[3] = wacom->led.hlv;\r\nbuf[4] = wacom->led.img_lum;\r\n}\r\nretval = wacom_set_report(wacom->intf, 0x03, WAC_CMD_LED_CONTROL,\r\nbuf, 9, WAC_CMD_RETRIES);\r\nkfree(buf);\r\nreturn retval;\r\n}\r\nstatic int wacom_led_putimage(struct wacom *wacom, int button_id, const void *img)\r\n{\r\nunsigned char *buf;\r\nint i, retval;\r\nbuf = kzalloc(259, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = WAC_CMD_ICON_START;\r\nbuf[1] = 1;\r\nretval = wacom_set_report(wacom->intf, 0x03, WAC_CMD_ICON_START,\r\nbuf, 2, WAC_CMD_RETRIES);\r\nif (retval < 0)\r\ngoto out;\r\nbuf[0] = WAC_CMD_ICON_XFER;\r\nbuf[1] = button_id & 0x07;\r\nfor (i = 0; i < 4; i++) {\r\nbuf[2] = i;\r\nmemcpy(buf + 3, img + i * 256, 256);\r\nretval = wacom_set_report(wacom->intf, 0x03, WAC_CMD_ICON_XFER,\r\nbuf, 259, WAC_CMD_RETRIES);\r\nif (retval < 0)\r\nbreak;\r\n}\r\nbuf[0] = WAC_CMD_ICON_START;\r\nbuf[1] = 0;\r\nwacom_set_report(wacom->intf, 0x03, WAC_CMD_ICON_START,\r\nbuf, 2, WAC_CMD_RETRIES);\r\nout:\r\nkfree(buf);\r\nreturn retval;\r\n}\r\nstatic ssize_t wacom_led_select_store(struct device *dev, int set_id,\r\nconst char *buf, size_t count)\r\n{\r\nstruct wacom *wacom = dev_get_drvdata(dev);\r\nunsigned int id;\r\nint err;\r\nerr = kstrtouint(buf, 10, &id);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&wacom->lock);\r\nwacom->led.select[set_id] = id & 0x3;\r\nerr = wacom_led_control(wacom);\r\nmutex_unlock(&wacom->lock);\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic ssize_t wacom_luminance_store(struct wacom *wacom, u8 *dest,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int value;\r\nint err;\r\nerr = kstrtouint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&wacom->lock);\r\n*dest = value & 0x7f;\r\nerr = wacom_led_control(wacom);\r\nmutex_unlock(&wacom->lock);\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic ssize_t wacom_button_image_store(struct device *dev, int button_id,\r\nconst char *buf, size_t count)\r\n{\r\nstruct wacom *wacom = dev_get_drvdata(dev);\r\nint err;\r\nif (count != 1024)\r\nreturn -EINVAL;\r\nmutex_lock(&wacom->lock);\r\nerr = wacom_led_putimage(wacom, button_id, buf);\r\nmutex_unlock(&wacom->lock);\r\nreturn err < 0 ? err : count;\r\n}\r\nstatic int wacom_initialize_leds(struct wacom *wacom)\r\n{\r\nint error;\r\nswitch (wacom->wacom_wac.features.type) {\r\ncase INTUOS4S:\r\ncase INTUOS4:\r\ncase INTUOS4L:\r\nwacom->led.select[0] = 0;\r\nwacom->led.select[1] = 0;\r\nwacom->led.llv = 10;\r\nwacom->led.hlv = 20;\r\nwacom->led.img_lum = 10;\r\nerror = sysfs_create_group(&wacom->intf->dev.kobj,\r\n&intuos4_led_attr_group);\r\nbreak;\r\ncase WACOM_24HD:\r\ncase WACOM_21UX2:\r\nwacom->led.select[0] = 0;\r\nwacom->led.select[1] = 0;\r\nwacom->led.llv = 0;\r\nwacom->led.hlv = 0;\r\nwacom->led.img_lum = 0;\r\nerror = sysfs_create_group(&wacom->intf->dev.kobj,\r\n&cintiq_led_attr_group);\r\nbreak;\r\ncase INTUOS5S:\r\ncase INTUOS5:\r\ncase INTUOS5L:\r\nwacom->led.select[0] = 0;\r\nwacom->led.select[1] = 0;\r\nwacom->led.llv = 32;\r\nwacom->led.hlv = 0;\r\nwacom->led.img_lum = 0;\r\nerror = sysfs_create_group(&wacom->intf->dev.kobj,\r\n&intuos5_led_attr_group);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (error) {\r\ndev_err(&wacom->intf->dev,\r\n"cannot create sysfs group err: %d\n", error);\r\nreturn error;\r\n}\r\nwacom_led_control(wacom);\r\nreturn 0;\r\n}\r\nstatic void wacom_destroy_leds(struct wacom *wacom)\r\n{\r\nswitch (wacom->wacom_wac.features.type) {\r\ncase INTUOS4S:\r\ncase INTUOS4:\r\ncase INTUOS4L:\r\nsysfs_remove_group(&wacom->intf->dev.kobj,\r\n&intuos4_led_attr_group);\r\nbreak;\r\ncase WACOM_24HD:\r\ncase WACOM_21UX2:\r\nsysfs_remove_group(&wacom->intf->dev.kobj,\r\n&cintiq_led_attr_group);\r\nbreak;\r\ncase INTUOS5S:\r\ncase INTUOS5:\r\ncase INTUOS5L:\r\nsysfs_remove_group(&wacom->intf->dev.kobj,\r\n&intuos5_led_attr_group);\r\nbreak;\r\n}\r\n}\r\nstatic int wacom_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct wacom *wacom = container_of(psy, struct wacom, battery);\r\nint ret = 0;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval =\r\nwacom->wacom_wac.battery_capacity * 100 / 31;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wacom_initialize_battery(struct wacom *wacom)\r\n{\r\nint error = 0;\r\nif (wacom->wacom_wac.features.quirks & WACOM_QUIRK_MONITOR) {\r\nwacom->battery.properties = wacom_battery_props;\r\nwacom->battery.num_properties = ARRAY_SIZE(wacom_battery_props);\r\nwacom->battery.get_property = wacom_battery_get_property;\r\nwacom->battery.name = "wacom_battery";\r\nwacom->battery.type = POWER_SUPPLY_TYPE_BATTERY;\r\nwacom->battery.use_for_apm = 0;\r\nerror = power_supply_register(&wacom->usbdev->dev,\r\n&wacom->battery);\r\nif (!error)\r\npower_supply_powers(&wacom->battery,\r\n&wacom->usbdev->dev);\r\n}\r\nreturn error;\r\n}\r\nstatic void wacom_destroy_battery(struct wacom *wacom)\r\n{\r\nif (wacom->wacom_wac.features.quirks & WACOM_QUIRK_MONITOR &&\r\nwacom->battery.dev) {\r\npower_supply_unregister(&wacom->battery);\r\nwacom->battery.dev = NULL;\r\n}\r\n}\r\nstatic int wacom_register_input(struct wacom *wacom)\r\n{\r\nstruct input_dev *input_dev;\r\nstruct usb_interface *intf = wacom->intf;\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct wacom_wac *wacom_wac = &(wacom->wacom_wac);\r\nint error;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\ninput_dev->name = wacom_wac->name;\r\ninput_dev->dev.parent = &intf->dev;\r\ninput_dev->open = wacom_open;\r\ninput_dev->close = wacom_close;\r\nusb_to_input_id(dev, &input_dev->id);\r\ninput_set_drvdata(input_dev, wacom);\r\nwacom_wac->input = input_dev;\r\nerror = wacom_setup_input_capabilities(input_dev, wacom_wac);\r\nif (error)\r\ngoto fail1;\r\nerror = input_register_device(input_dev);\r\nif (error)\r\ngoto fail2;\r\nreturn 0;\r\nfail2:\r\ninput_free_device(input_dev);\r\nwacom_wac->input = NULL;\r\nfail1:\r\nreturn error;\r\n}\r\nstatic void wacom_wireless_work(struct work_struct *work)\r\n{\r\nstruct wacom *wacom = container_of(work, struct wacom, work);\r\nstruct usb_device *usbdev = wacom->usbdev;\r\nstruct wacom_wac *wacom_wac = &wacom->wacom_wac;\r\nstruct wacom *wacom1, *wacom2;\r\nstruct wacom_wac *wacom_wac1, *wacom_wac2;\r\nint error;\r\nwacom_destroy_battery(wacom);\r\nwacom1 = usb_get_intfdata(usbdev->config->interface[1]);\r\nwacom_wac1 = &(wacom1->wacom_wac);\r\nif (wacom_wac1->input)\r\ninput_unregister_device(wacom_wac1->input);\r\nwacom_wac1->input = NULL;\r\nwacom2 = usb_get_intfdata(usbdev->config->interface[2]);\r\nwacom_wac2 = &(wacom2->wacom_wac);\r\nif (wacom_wac2->input)\r\ninput_unregister_device(wacom_wac2->input);\r\nwacom_wac2->input = NULL;\r\nif (wacom_wac->pid == 0) {\r\ndev_info(&wacom->intf->dev, "wireless tablet disconnected\n");\r\n} else {\r\nconst struct usb_device_id *id = wacom_ids;\r\ndev_info(&wacom->intf->dev,\r\n"wireless tablet connected with PID %x\n",\r\nwacom_wac->pid);\r\nwhile (id->match_flags) {\r\nif (id->idVendor == USB_VENDOR_ID_WACOM &&\r\nid->idProduct == wacom_wac->pid)\r\nbreak;\r\nid++;\r\n}\r\nif (!id->match_flags) {\r\ndev_info(&wacom->intf->dev,\r\n"ignoring unknown PID.\n");\r\nreturn;\r\n}\r\nwacom_wac1->features =\r\n*((struct wacom_features *)id->driver_info);\r\nwacom_wac1->features.device_type = BTN_TOOL_PEN;\r\nerror = wacom_register_input(wacom1);\r\nif (error)\r\ngoto fail1;\r\nwacom_wac2->features =\r\n*((struct wacom_features *)id->driver_info);\r\nwacom_wac2->features.pktlen = WACOM_PKGLEN_BBTOUCH3;\r\nwacom_wac2->features.device_type = BTN_TOOL_FINGER;\r\nwacom_set_phy_from_res(&wacom_wac2->features);\r\nwacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;\r\nerror = wacom_register_input(wacom2);\r\nif (error)\r\ngoto fail2;\r\nerror = wacom_initialize_battery(wacom);\r\nif (error)\r\ngoto fail3;\r\n}\r\nreturn;\r\nfail3:\r\ninput_unregister_device(wacom_wac2->input);\r\nwacom_wac2->input = NULL;\r\nfail2:\r\ninput_unregister_device(wacom_wac1->input);\r\nwacom_wac1->input = NULL;\r\nfail1:\r\nreturn;\r\n}\r\nstatic int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct wacom *wacom;\r\nstruct wacom_wac *wacom_wac;\r\nstruct wacom_features *features;\r\nint error;\r\nif (!id->driver_info)\r\nreturn -EINVAL;\r\nwacom = kzalloc(sizeof(struct wacom), GFP_KERNEL);\r\nif (!wacom)\r\nreturn -ENOMEM;\r\nwacom_wac = &wacom->wacom_wac;\r\nwacom_wac->features = *((struct wacom_features *)id->driver_info);\r\nfeatures = &wacom_wac->features;\r\nif (features->pktlen > WACOM_PKGLEN_MAX) {\r\nerror = -EINVAL;\r\ngoto fail1;\r\n}\r\nwacom_wac->data = usb_alloc_coherent(dev, WACOM_PKGLEN_MAX,\r\nGFP_KERNEL, &wacom->data_dma);\r\nif (!wacom_wac->data) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nwacom->irq = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!wacom->irq) {\r\nerror = -ENOMEM;\r\ngoto fail2;\r\n}\r\nwacom->usbdev = dev;\r\nwacom->intf = intf;\r\nmutex_init(&wacom->lock);\r\nINIT_WORK(&wacom->work, wacom_wireless_work);\r\nusb_make_path(dev, wacom->phys, sizeof(wacom->phys));\r\nstrlcat(wacom->phys, "/input0", sizeof(wacom->phys));\r\nendpoint = &intf->cur_altsetting->endpoint[0].desc;\r\nerror = wacom_retrieve_hid_descriptor(intf, features);\r\nif (error)\r\ngoto fail3;\r\nif (features->type >= INTUOS5S && features->type <= INTUOS5L) {\r\nif (endpoint->wMaxPacketSize == WACOM_PKGLEN_BBTOUCH3) {\r\nfeatures->device_type = BTN_TOOL_FINGER;\r\nfeatures->pktlen = WACOM_PKGLEN_BBTOUCH3;\r\nwacom_set_phy_from_res(features);\r\nfeatures->x_max = 4096;\r\nfeatures->y_max = 4096;\r\n} else {\r\nfeatures->device_type = BTN_TOOL_PEN;\r\n}\r\n}\r\nwacom_setup_device_quirks(features);\r\nstrlcpy(wacom_wac->name, features->name, sizeof(wacom_wac->name));\r\nif (features->quirks & WACOM_QUIRK_MULTI_INPUT) {\r\nstruct usb_device *other_dev;\r\nstrlcat(wacom_wac->name,\r\nfeatures->device_type == BTN_TOOL_PEN ?\r\n" Pen" : " Finger",\r\nsizeof(wacom_wac->name));\r\nother_dev = wacom_get_sibling(dev, features->oVid, features->oPid);\r\nif (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)\r\nother_dev = dev;\r\nerror = wacom_add_shared_data(wacom_wac, other_dev);\r\nif (error)\r\ngoto fail3;\r\n}\r\nusb_fill_int_urb(wacom->irq, dev,\r\nusb_rcvintpipe(dev, endpoint->bEndpointAddress),\r\nwacom_wac->data, features->pktlen,\r\nwacom_sys_irq, wacom, endpoint->bInterval);\r\nwacom->irq->transfer_dma = wacom->data_dma;\r\nwacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nerror = wacom_initialize_leds(wacom);\r\nif (error)\r\ngoto fail4;\r\nif (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {\r\nerror = wacom_register_input(wacom);\r\nif (error)\r\ngoto fail5;\r\n}\r\nwacom_query_tablet_data(intf, features);\r\nusb_set_intfdata(intf, wacom);\r\nif (features->quirks & WACOM_QUIRK_MONITOR) {\r\nif (usb_submit_urb(wacom->irq, GFP_KERNEL))\r\ngoto fail5;\r\n}\r\nreturn 0;\r\nfail5: wacom_destroy_leds(wacom);\r\nfail4: wacom_remove_shared_data(wacom_wac);\r\nfail3: usb_free_urb(wacom->irq);\r\nfail2: usb_free_coherent(dev, WACOM_PKGLEN_MAX, wacom_wac->data, wacom->data_dma);\r\nfail1: kfree(wacom);\r\nreturn error;\r\n}\r\nstatic void wacom_disconnect(struct usb_interface *intf)\r\n{\r\nstruct wacom *wacom = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nusb_kill_urb(wacom->irq);\r\ncancel_work_sync(&wacom->work);\r\nif (wacom->wacom_wac.input)\r\ninput_unregister_device(wacom->wacom_wac.input);\r\nwacom_destroy_battery(wacom);\r\nwacom_destroy_leds(wacom);\r\nusb_free_urb(wacom->irq);\r\nusb_free_coherent(interface_to_usbdev(intf), WACOM_PKGLEN_MAX,\r\nwacom->wacom_wac.data, wacom->data_dma);\r\nwacom_remove_shared_data(&wacom->wacom_wac);\r\nkfree(wacom);\r\n}\r\nstatic int wacom_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct wacom *wacom = usb_get_intfdata(intf);\r\nmutex_lock(&wacom->lock);\r\nusb_kill_urb(wacom->irq);\r\nmutex_unlock(&wacom->lock);\r\nreturn 0;\r\n}\r\nstatic int wacom_resume(struct usb_interface *intf)\r\n{\r\nstruct wacom *wacom = usb_get_intfdata(intf);\r\nstruct wacom_features *features = &wacom->wacom_wac.features;\r\nint rv = 0;\r\nmutex_lock(&wacom->lock);\r\nwacom_query_tablet_data(intf, features);\r\nwacom_led_control(wacom);\r\nif ((wacom->open || features->quirks & WACOM_QUIRK_MONITOR)\r\n&& usb_submit_urb(wacom->irq, GFP_NOIO) < 0)\r\nrv = -EIO;\r\nmutex_unlock(&wacom->lock);\r\nreturn rv;\r\n}\r\nstatic int wacom_reset_resume(struct usb_interface *intf)\r\n{\r\nreturn wacom_resume(intf);\r\n}
