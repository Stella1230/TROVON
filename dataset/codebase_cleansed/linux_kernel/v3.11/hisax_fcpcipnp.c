static unsigned char fcpci_read_isac(struct isac *isac, unsigned char offset)\r\n{\r\nstruct fritz_adapter *adapter = isac->priv;\r\nunsigned char idx = (offset > 0x2f) ?\r\nAVM_IDX_ISAC_REG_HIGH : AVM_IDX_ISAC_REG_LOW;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutb(idx, adapter->io + AVM_INDEX);\r\nval = inb(adapter->io + AVM_DATA + (offset & 0xf));\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nDBG(0x1000, " port %#x, value %#x",\r\noffset, val);\r\nreturn val;\r\n}\r\nstatic void fcpci_write_isac(struct isac *isac, unsigned char offset,\r\nunsigned char value)\r\n{\r\nstruct fritz_adapter *adapter = isac->priv;\r\nunsigned char idx = (offset > 0x2f) ?\r\nAVM_IDX_ISAC_REG_HIGH : AVM_IDX_ISAC_REG_LOW;\r\nunsigned long flags;\r\nDBG(0x1000, " port %#x, value %#x",\r\noffset, value);\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutb(idx, adapter->io + AVM_INDEX);\r\noutb(value, adapter->io + AVM_DATA + (offset & 0xf));\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nstatic void fcpci_read_isac_fifo(struct isac *isac, unsigned char *data,\r\nint size)\r\n{\r\nstruct fritz_adapter *adapter = isac->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutb(AVM_IDX_ISAC_FIFO, adapter->io + AVM_INDEX);\r\ninsb(adapter->io + AVM_DATA, data, size);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nstatic void fcpci_write_isac_fifo(struct isac *isac, unsigned char *data,\r\nint size)\r\n{\r\nstruct fritz_adapter *adapter = isac->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutb(AVM_IDX_ISAC_FIFO, adapter->io + AVM_INDEX);\r\noutsb(adapter->io + AVM_DATA, data, size);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nstatic u32 fcpci_read_hdlc_status(struct fritz_adapter *adapter, int nr)\r\n{\r\nu32 val;\r\nint idx = nr ? AVM_IDX_HDLC_2 : AVM_IDX_HDLC_1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutl(idx, adapter->io + AVM_INDEX);\r\nval = inl(adapter->io + AVM_DATA + HDLC_STATUS);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nreturn val;\r\n}\r\nstatic void __fcpci_write_ctrl(struct fritz_bcs *bcs, int which)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nint idx = bcs->channel ? AVM_IDX_HDLC_2 : AVM_IDX_HDLC_1;\r\nDBG(0x40, "hdlc %c wr%x ctrl %x",\r\n'A' + bcs->channel, which, bcs->ctrl.ctrl);\r\noutl(idx, adapter->io + AVM_INDEX);\r\noutl(bcs->ctrl.ctrl, adapter->io + AVM_DATA + HDLC_CTRL);\r\n}\r\nstatic void fcpci_write_ctrl(struct fritz_bcs *bcs, int which)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\n__fcpci_write_ctrl(bcs, which);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nstatic unsigned char fcpci2_read_isac(struct isac *isac, unsigned char offset)\r\n{\r\nstruct fritz_adapter *adapter = isac->priv;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutl(offset, adapter->io + AVM_ISACSX_INDEX);\r\nval = inl(adapter->io + AVM_ISACSX_DATA);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nDBG(0x1000, " port %#x, value %#x",\r\noffset, val);\r\nreturn val;\r\n}\r\nstatic void fcpci2_write_isac(struct isac *isac, unsigned char offset,\r\nunsigned char value)\r\n{\r\nstruct fritz_adapter *adapter = isac->priv;\r\nunsigned long flags;\r\nDBG(0x1000, " port %#x, value %#x",\r\noffset, value);\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutl(offset, adapter->io + AVM_ISACSX_INDEX);\r\noutl(value, adapter->io + AVM_ISACSX_DATA);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nstatic void fcpci2_read_isac_fifo(struct isac *isac, unsigned char *data,\r\nint size)\r\n{\r\nstruct fritz_adapter *adapter = isac->priv;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutl(0, adapter->io + AVM_ISACSX_INDEX);\r\nfor (i = 0; i < size; i++)\r\ndata[i] = inl(adapter->io + AVM_ISACSX_DATA);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nstatic void fcpci2_write_isac_fifo(struct isac *isac, unsigned char *data,\r\nint size)\r\n{\r\nstruct fritz_adapter *adapter = isac->priv;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutl(0, adapter->io + AVM_ISACSX_INDEX);\r\nfor (i = 0; i < size; i++)\r\noutl(data[i], adapter->io + AVM_ISACSX_DATA);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nstatic u32 fcpci2_read_hdlc_status(struct fritz_adapter *adapter, int nr)\r\n{\r\nint offset = nr ? AVM_HDLC_STATUS_2 : AVM_HDLC_STATUS_1;\r\nreturn inl(adapter->io + offset);\r\n}\r\nstatic void fcpci2_write_ctrl(struct fritz_bcs *bcs, int which)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nint offset = bcs->channel ? AVM_HDLC_STATUS_2 : AVM_HDLC_STATUS_1;\r\nDBG(0x40, "hdlc %c wr%x ctrl %x",\r\n'A' + bcs->channel, which, bcs->ctrl.ctrl);\r\noutl(bcs->ctrl.ctrl, adapter->io + offset);\r\n}\r\nstatic u32 fcpnp_read_hdlc_status(struct fritz_adapter *adapter, int nr)\r\n{\r\nunsigned char idx = nr ? AVM_IDX_HDLC_2 : AVM_IDX_HDLC_1;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\noutb(idx, adapter->io + AVM_INDEX);\r\nval = inb(adapter->io + AVM_DATA + HDLC_STATUS);\r\nif (val & HDLC_INT_RPR)\r\nval |= inb(adapter->io + AVM_DATA + HDLC_STATUS + 1) << 8;\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nreturn val;\r\n}\r\nstatic void __fcpnp_write_ctrl(struct fritz_bcs *bcs, int which)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nunsigned char idx = bcs->channel ? AVM_IDX_HDLC_2 : AVM_IDX_HDLC_1;\r\nDBG(0x40, "hdlc %c wr%x ctrl %x",\r\n'A' + bcs->channel, which, bcs->ctrl.ctrl);\r\noutb(idx, adapter->io + AVM_INDEX);\r\nif (which & 4)\r\noutb(bcs->ctrl.sr.mode,\r\nadapter->io + AVM_DATA + HDLC_STATUS + 2);\r\nif (which & 2)\r\noutb(bcs->ctrl.sr.xml,\r\nadapter->io + AVM_DATA + HDLC_STATUS + 1);\r\nif (which & 1)\r\noutb(bcs->ctrl.sr.cmd,\r\nadapter->io + AVM_DATA + HDLC_STATUS + 0);\r\n}\r\nstatic void fcpnp_write_ctrl(struct fritz_bcs *bcs, int which)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\n__fcpnp_write_ctrl(bcs, which);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\n}\r\nstatic inline void B_L1L2(struct fritz_bcs *bcs, int pr, void *arg)\r\n{\r\nstruct hisax_if *ifc = (struct hisax_if *) &bcs->b_if;\r\nDBG(2, "pr %#x", pr);\r\nifc->l1l2(ifc, pr, arg);\r\n}\r\nstatic void hdlc_fill_fifo(struct fritz_bcs *bcs)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nstruct sk_buff *skb = bcs->tx_skb;\r\nint count;\r\nunsigned long flags;\r\nunsigned char *p;\r\nDBG(0x40, "hdlc_fill_fifo");\r\nBUG_ON(skb->len == 0);\r\nbcs->ctrl.sr.cmd &= ~HDLC_CMD_XME;\r\nif (bcs->tx_skb->len > bcs->fifo_size) {\r\ncount = bcs->fifo_size;\r\n} else {\r\ncount = bcs->tx_skb->len;\r\nif (bcs->mode != L1_MODE_TRANS)\r\nbcs->ctrl.sr.cmd |= HDLC_CMD_XME;\r\n}\r\nDBG(0x40, "hdlc_fill_fifo %d/%d", count, bcs->tx_skb->len);\r\np = bcs->tx_skb->data;\r\nskb_pull(bcs->tx_skb, count);\r\nbcs->tx_cnt += count;\r\nbcs->ctrl.sr.xml = ((count == bcs->fifo_size) ? 0 : count);\r\nswitch (adapter->type) {\r\ncase AVM_FRITZ_PCI:\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\n__fcpci_write_ctrl(bcs, 3);\r\noutsl(adapter->io + AVM_DATA + HDLC_FIFO,\r\np, (count + 3) / 4);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nbreak;\r\ncase AVM_FRITZ_PCIV2:\r\nfcpci2_write_ctrl(bcs, 3);\r\noutsl(adapter->io +\r\n(bcs->channel ? AVM_HDLC_FIFO_2 : AVM_HDLC_FIFO_1),\r\np, (count + 3) / 4);\r\nbreak;\r\ncase AVM_FRITZ_PNP:\r\nspin_lock_irqsave(&adapter->hw_lock, flags);\r\n__fcpnp_write_ctrl(bcs, 3);\r\noutsb(adapter->io + AVM_DATA, p, count);\r\nspin_unlock_irqrestore(&adapter->hw_lock, flags);\r\nbreak;\r\n}\r\n}\r\nstatic inline void hdlc_empty_fifo(struct fritz_bcs *bcs, int count)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nunsigned char *p;\r\nunsigned char idx = bcs->channel ? AVM_IDX_HDLC_2 : AVM_IDX_HDLC_1;\r\nDBG(0x10, "hdlc_empty_fifo %d", count);\r\nif (bcs->rcvidx + count > HSCX_BUFMAX) {\r\nDBG(0x10, "hdlc_empty_fifo: incoming packet too large");\r\nreturn;\r\n}\r\np = bcs->rcvbuf + bcs->rcvidx;\r\nbcs->rcvidx += count;\r\nswitch (adapter->type) {\r\ncase AVM_FRITZ_PCI:\r\nspin_lock(&adapter->hw_lock);\r\noutl(idx, adapter->io + AVM_INDEX);\r\ninsl(adapter->io + AVM_DATA + HDLC_FIFO,\r\np, (count + 3) / 4);\r\nspin_unlock(&adapter->hw_lock);\r\nbreak;\r\ncase AVM_FRITZ_PCIV2:\r\ninsl(adapter->io +\r\n(bcs->channel ? AVM_HDLC_FIFO_2 : AVM_HDLC_FIFO_1),\r\np, (count + 3) / 4);\r\nbreak;\r\ncase AVM_FRITZ_PNP:\r\nspin_lock(&adapter->hw_lock);\r\noutb(idx, adapter->io + AVM_INDEX);\r\ninsb(adapter->io + AVM_DATA, p, count);\r\nspin_unlock(&adapter->hw_lock);\r\nbreak;\r\n}\r\n}\r\nstatic inline void hdlc_rpr_irq(struct fritz_bcs *bcs, u32 stat)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nstruct sk_buff *skb;\r\nint len;\r\nif (stat & HDLC_STAT_RDO) {\r\nDBG(0x10, "RDO");\r\nbcs->ctrl.sr.xml = 0;\r\nbcs->ctrl.sr.cmd |= HDLC_CMD_RRS;\r\nadapter->write_ctrl(bcs, 1);\r\nbcs->ctrl.sr.cmd &= ~HDLC_CMD_RRS;\r\nadapter->write_ctrl(bcs, 1);\r\nbcs->rcvidx = 0;\r\nreturn;\r\n}\r\nlen = (stat & HDLC_STAT_RML_MASK) >> 8;\r\nif (len == 0)\r\nlen = bcs->fifo_size;\r\nhdlc_empty_fifo(bcs, len);\r\nif ((stat & HDLC_STAT_RME) || (bcs->mode == L1_MODE_TRANS)) {\r\nif (((stat & HDLC_STAT_CRCVFRRAB) == HDLC_STAT_CRCVFR) ||\r\n(bcs->mode == L1_MODE_TRANS)) {\r\nskb = dev_alloc_skb(bcs->rcvidx);\r\nif (!skb) {\r\nprintk(KERN_WARNING "HDLC: receive out of memory\n");\r\n} else {\r\nmemcpy(skb_put(skb, bcs->rcvidx), bcs->rcvbuf,\r\nbcs->rcvidx);\r\nDBG_SKB(1, skb);\r\nB_L1L2(bcs, PH_DATA | INDICATION, skb);\r\n}\r\nbcs->rcvidx = 0;\r\n} else {\r\nDBG(0x10, "ch%d invalid frame %#x",\r\nbcs->channel, stat);\r\nbcs->rcvidx = 0;\r\n}\r\n}\r\n}\r\nstatic inline void hdlc_xdu_irq(struct fritz_bcs *bcs)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nbcs->ctrl.sr.xml = 0;\r\nbcs->ctrl.sr.cmd |= HDLC_CMD_XRS;\r\nadapter->write_ctrl(bcs, 1);\r\nbcs->ctrl.sr.cmd &= ~HDLC_CMD_XRS;\r\nif (!bcs->tx_skb) {\r\nDBG(0x10, "XDU without skb");\r\nadapter->write_ctrl(bcs, 1);\r\nreturn;\r\n}\r\nif (bcs->mode == L1_MODE_HDLC) {\r\nskb_push(bcs->tx_skb, bcs->tx_cnt);\r\nbcs->tx_cnt = 0;\r\n}\r\n}\r\nstatic inline void hdlc_xpr_irq(struct fritz_bcs *bcs)\r\n{\r\nstruct sk_buff *skb;\r\nskb = bcs->tx_skb;\r\nif (!skb)\r\nreturn;\r\nif (skb->len) {\r\nhdlc_fill_fifo(bcs);\r\nreturn;\r\n}\r\nbcs->tx_cnt = 0;\r\nbcs->tx_skb = NULL;\r\nB_L1L2(bcs, PH_DATA | CONFIRM, (void *)(unsigned long)skb->truesize);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nstatic void hdlc_irq_one(struct fritz_bcs *bcs, u32 stat)\r\n{\r\nDBG(0x10, "ch%d stat %#x", bcs->channel, stat);\r\nif (stat & HDLC_INT_RPR) {\r\nDBG(0x10, "RPR");\r\nhdlc_rpr_irq(bcs, stat);\r\n}\r\nif (stat & HDLC_INT_XDU) {\r\nDBG(0x10, "XDU");\r\nhdlc_xdu_irq(bcs);\r\nhdlc_xpr_irq(bcs);\r\nreturn;\r\n}\r\nif (stat & HDLC_INT_XPR) {\r\nDBG(0x10, "XPR");\r\nhdlc_xpr_irq(bcs);\r\n}\r\n}\r\nstatic inline void hdlc_irq(struct fritz_adapter *adapter)\r\n{\r\nint nr;\r\nu32 stat;\r\nfor (nr = 0; nr < 2; nr++) {\r\nstat = adapter->read_hdlc_status(adapter, nr);\r\nDBG(0x10, "HDLC %c stat %#x", 'A' + nr, stat);\r\nif (stat & HDLC_INT_MASK)\r\nhdlc_irq_one(&adapter->bcs[nr], stat);\r\n}\r\n}\r\nstatic void modehdlc(struct fritz_bcs *bcs, int mode)\r\n{\r\nstruct fritz_adapter *adapter = bcs->adapter;\r\nDBG(0x40, "hdlc %c mode %d --> %d",\r\n'A' + bcs->channel, bcs->mode, mode);\r\nif (bcs->mode == mode)\r\nreturn;\r\nbcs->fifo_size = 32;\r\nbcs->ctrl.ctrl = 0;\r\nbcs->ctrl.sr.cmd = HDLC_CMD_XRS | HDLC_CMD_RRS;\r\nswitch (mode) {\r\ncase L1_MODE_NULL:\r\nbcs->ctrl.sr.mode = HDLC_MODE_TRANS;\r\nadapter->write_ctrl(bcs, 5);\r\nbreak;\r\ncase L1_MODE_TRANS:\r\ncase L1_MODE_HDLC:\r\nbcs->rcvidx = 0;\r\nbcs->tx_cnt = 0;\r\nbcs->tx_skb = NULL;\r\nif (mode == L1_MODE_TRANS) {\r\nbcs->ctrl.sr.mode = HDLC_MODE_TRANS;\r\n} else {\r\nbcs->ctrl.sr.mode = HDLC_MODE_ITF_FLG;\r\n}\r\nadapter->write_ctrl(bcs, 5);\r\nbcs->ctrl.sr.cmd = HDLC_CMD_XRS;\r\nadapter->write_ctrl(bcs, 1);\r\nbcs->ctrl.sr.cmd = 0;\r\nbreak;\r\n}\r\nbcs->mode = mode;\r\n}\r\nstatic void fritz_b_l2l1(struct hisax_if *ifc, int pr, void *arg)\r\n{\r\nstruct fritz_bcs *bcs = ifc->priv;\r\nstruct sk_buff *skb = arg;\r\nint mode;\r\nDBG(0x10, "pr %#x", pr);\r\nswitch (pr) {\r\ncase PH_DATA | REQUEST:\r\nBUG_ON(bcs->tx_skb);\r\nbcs->tx_skb = skb;\r\nDBG_SKB(1, skb);\r\nhdlc_fill_fifo(bcs);\r\nbreak;\r\ncase PH_ACTIVATE | REQUEST:\r\nmode = (long) arg;\r\nDBG(4, "B%d,PH_ACTIVATE_REQUEST %d", bcs->channel + 1, mode);\r\nmodehdlc(bcs, mode);\r\nB_L1L2(bcs, PH_ACTIVATE | INDICATION, NULL);\r\nbreak;\r\ncase PH_DEACTIVATE | REQUEST:\r\nDBG(4, "B%d,PH_DEACTIVATE_REQUEST", bcs->channel + 1);\r\nmodehdlc(bcs, L1_MODE_NULL);\r\nB_L1L2(bcs, PH_DEACTIVATE | INDICATION, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t\r\nfcpci2_irq(int intno, void *dev)\r\n{\r\nstruct fritz_adapter *adapter = dev;\r\nunsigned char val;\r\nval = inb(adapter->io + AVM_STATUS0);\r\nif (!(val & AVM_STATUS0_IRQ_MASK))\r\nreturn IRQ_NONE;\r\nDBG(2, "STATUS0 %#x", val);\r\nif (val & AVM_STATUS0_IRQ_ISAC)\r\nisacsx_irq(&adapter->isac);\r\nif (val & AVM_STATUS0_IRQ_HDLC)\r\nhdlc_irq(adapter);\r\nif (val & AVM_STATUS0_IRQ_ISAC)\r\nisacsx_irq(&adapter->isac);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nfcpci_irq(int intno, void *dev)\r\n{\r\nstruct fritz_adapter *adapter = dev;\r\nunsigned char sval;\r\nsval = inb(adapter->io + 2);\r\nif ((sval & AVM_STATUS0_IRQ_MASK) == AVM_STATUS0_IRQ_MASK)\r\nreturn IRQ_NONE;\r\nDBG(2, "sval %#x", sval);\r\nif (!(sval & AVM_STATUS0_IRQ_ISAC))\r\nisac_irq(&adapter->isac);\r\nif (!(sval & AVM_STATUS0_IRQ_HDLC))\r\nhdlc_irq(adapter);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void fcpci2_init(struct fritz_adapter *adapter)\r\n{\r\noutb(AVM_STATUS0_RES_TIMER, adapter->io + AVM_STATUS0);\r\noutb(AVM_STATUS0_ENA_IRQ, adapter->io + AVM_STATUS0);\r\n}\r\nstatic inline void fcpci_init(struct fritz_adapter *adapter)\r\n{\r\noutb(AVM_STATUS0_DIS_TIMER | AVM_STATUS0_RES_TIMER |\r\nAVM_STATUS0_ENA_IRQ, adapter->io + AVM_STATUS0);\r\noutb(AVM_STATUS1_ENA_IOM | adapter->irq,\r\nadapter->io + AVM_STATUS1);\r\nmdelay(10);\r\n}\r\nstatic int fcpcipnp_setup(struct fritz_adapter *adapter)\r\n{\r\nu32 val = 0;\r\nint retval;\r\nDBG(1, "");\r\nisac_init(&adapter->isac);\r\nretval = -EBUSY;\r\nif (!request_region(adapter->io, 32, "fcpcipnp"))\r\ngoto err;\r\nswitch (adapter->type) {\r\ncase AVM_FRITZ_PCIV2:\r\ncase AVM_FRITZ_PCI:\r\nval = inl(adapter->io);\r\nbreak;\r\ncase AVM_FRITZ_PNP:\r\nval = inb(adapter->io);\r\nval |= inb(adapter->io + 1) << 8;\r\nbreak;\r\n}\r\nDBG(1, "stat %#x Class %X Rev %d",\r\nval, val & 0xff, (val >> 8) & 0xff);\r\nspin_lock_init(&adapter->hw_lock);\r\nadapter->isac.priv = adapter;\r\nswitch (adapter->type) {\r\ncase AVM_FRITZ_PCIV2:\r\nadapter->isac.read_isac = &fcpci2_read_isac;\r\nadapter->isac.write_isac = &fcpci2_write_isac;\r\nadapter->isac.read_isac_fifo = &fcpci2_read_isac_fifo;\r\nadapter->isac.write_isac_fifo = &fcpci2_write_isac_fifo;\r\nadapter->read_hdlc_status = &fcpci2_read_hdlc_status;\r\nadapter->write_ctrl = &fcpci2_write_ctrl;\r\nbreak;\r\ncase AVM_FRITZ_PCI:\r\nadapter->isac.read_isac = &fcpci_read_isac;\r\nadapter->isac.write_isac = &fcpci_write_isac;\r\nadapter->isac.read_isac_fifo = &fcpci_read_isac_fifo;\r\nadapter->isac.write_isac_fifo = &fcpci_write_isac_fifo;\r\nadapter->read_hdlc_status = &fcpci_read_hdlc_status;\r\nadapter->write_ctrl = &fcpci_write_ctrl;\r\nbreak;\r\ncase AVM_FRITZ_PNP:\r\nadapter->isac.read_isac = &fcpci_read_isac;\r\nadapter->isac.write_isac = &fcpci_write_isac;\r\nadapter->isac.read_isac_fifo = &fcpci_read_isac_fifo;\r\nadapter->isac.write_isac_fifo = &fcpci_write_isac_fifo;\r\nadapter->read_hdlc_status = &fcpnp_read_hdlc_status;\r\nadapter->write_ctrl = &fcpnp_write_ctrl;\r\nbreak;\r\n}\r\noutb(0, adapter->io + AVM_STATUS0);\r\nmdelay(10);\r\noutb(AVM_STATUS0_RESET, adapter->io + AVM_STATUS0);\r\nmdelay(10);\r\noutb(0, adapter->io + AVM_STATUS0);\r\nmdelay(10);\r\nswitch (adapter->type) {\r\ncase AVM_FRITZ_PCIV2:\r\nretval = request_irq(adapter->irq, fcpci2_irq, IRQF_SHARED,\r\n"fcpcipnp", adapter);\r\nbreak;\r\ncase AVM_FRITZ_PCI:\r\nretval = request_irq(adapter->irq, fcpci_irq, IRQF_SHARED,\r\n"fcpcipnp", adapter);\r\nbreak;\r\ncase AVM_FRITZ_PNP:\r\nretval = request_irq(adapter->irq, fcpci_irq, 0,\r\n"fcpcipnp", adapter);\r\nbreak;\r\n}\r\nif (retval)\r\ngoto err_region;\r\nswitch (adapter->type) {\r\ncase AVM_FRITZ_PCIV2:\r\nfcpci2_init(adapter);\r\nisacsx_setup(&adapter->isac);\r\nbreak;\r\ncase AVM_FRITZ_PCI:\r\ncase AVM_FRITZ_PNP:\r\nfcpci_init(adapter);\r\nisac_setup(&adapter->isac);\r\nbreak;\r\n}\r\nval = adapter->read_hdlc_status(adapter, 0);\r\nDBG(0x20, "HDLC A STA %x", val);\r\nval = adapter->read_hdlc_status(adapter, 1);\r\nDBG(0x20, "HDLC B STA %x", val);\r\nadapter->bcs[0].mode = -1;\r\nadapter->bcs[1].mode = -1;\r\nmodehdlc(&adapter->bcs[0], L1_MODE_NULL);\r\nmodehdlc(&adapter->bcs[1], L1_MODE_NULL);\r\nreturn 0;\r\nerr_region:\r\nrelease_region(adapter->io, 32);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic void fcpcipnp_release(struct fritz_adapter *adapter)\r\n{\r\nDBG(1, "");\r\noutb(0, adapter->io + AVM_STATUS0);\r\nfree_irq(adapter->irq, adapter);\r\nrelease_region(adapter->io, 32);\r\n}\r\nstatic struct fritz_adapter *new_adapter(void)\r\n{\r\nstruct fritz_adapter *adapter;\r\nstruct hisax_b_if *b_if[2];\r\nint i;\r\nadapter = kzalloc(sizeof(struct fritz_adapter), GFP_KERNEL);\r\nif (!adapter)\r\nreturn NULL;\r\nadapter->isac.hisax_d_if.owner = THIS_MODULE;\r\nadapter->isac.hisax_d_if.ifc.priv = &adapter->isac;\r\nadapter->isac.hisax_d_if.ifc.l2l1 = isac_d_l2l1;\r\nfor (i = 0; i < 2; i++) {\r\nadapter->bcs[i].adapter = adapter;\r\nadapter->bcs[i].channel = i;\r\nadapter->bcs[i].b_if.ifc.priv = &adapter->bcs[i];\r\nadapter->bcs[i].b_if.ifc.l2l1 = fritz_b_l2l1;\r\n}\r\nfor (i = 0; i < 2; i++)\r\nb_if[i] = &adapter->bcs[i].b_if;\r\nif (hisax_register(&adapter->isac.hisax_d_if, b_if, "fcpcipnp",\r\nprotocol) != 0) {\r\nkfree(adapter);\r\nadapter = NULL;\r\n}\r\nreturn adapter;\r\n}\r\nstatic void delete_adapter(struct fritz_adapter *adapter)\r\n{\r\nhisax_unregister(&adapter->isac.hisax_d_if);\r\nkfree(adapter);\r\n}\r\nstatic int fcpci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct fritz_adapter *adapter;\r\nint retval;\r\nretval = -ENOMEM;\r\nadapter = new_adapter();\r\nif (!adapter)\r\ngoto err;\r\npci_set_drvdata(pdev, adapter);\r\nif (pdev->device == PCI_DEVICE_ID_AVM_A1_V2)\r\nadapter->type = AVM_FRITZ_PCIV2;\r\nelse\r\nadapter->type = AVM_FRITZ_PCI;\r\nretval = pci_enable_device(pdev);\r\nif (retval)\r\ngoto err_free;\r\nadapter->io = pci_resource_start(pdev, 1);\r\nadapter->irq = pdev->irq;\r\nprintk(KERN_INFO "hisax_fcpcipnp: found adapter %s at %s\n",\r\n(char *) ent->driver_data, pci_name(pdev));\r\nretval = fcpcipnp_setup(adapter);\r\nif (retval)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\ndelete_adapter(adapter);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int fcpnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *dev_id)\r\n{\r\nstruct fritz_adapter *adapter;\r\nint retval;\r\nif (!pdev)\r\nreturn (-ENODEV);\r\nretval = -ENOMEM;\r\nadapter = new_adapter();\r\nif (!adapter)\r\ngoto err;\r\npnp_set_drvdata(pdev, adapter);\r\nadapter->type = AVM_FRITZ_PNP;\r\npnp_disable_dev(pdev);\r\nretval = pnp_activate_dev(pdev);\r\nif (retval < 0) {\r\nprintk(KERN_WARNING "%s: pnp_activate_dev(%s) ret(%d)\n", __func__,\r\n(char *)dev_id->driver_data, retval);\r\ngoto err_free;\r\n}\r\nadapter->io = pnp_port_start(pdev, 0);\r\nadapter->irq = pnp_irq(pdev, 0);\r\nprintk(KERN_INFO "hisax_fcpcipnp: found adapter %s at IO %#x irq %d\n",\r\n(char *) dev_id->driver_data, adapter->io, adapter->irq);\r\nretval = fcpcipnp_setup(adapter);\r\nif (retval)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\ndelete_adapter(adapter);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic void fcpnp_remove(struct pnp_dev *pdev)\r\n{\r\nstruct fritz_adapter *adapter = pnp_get_drvdata(pdev);\r\nif (adapter) {\r\nfcpcipnp_release(adapter);\r\ndelete_adapter(adapter);\r\n}\r\npnp_disable_dev(pdev);\r\n}\r\nstatic void fcpci_remove(struct pci_dev *pdev)\r\n{\r\nstruct fritz_adapter *adapter = pci_get_drvdata(pdev);\r\nfcpcipnp_release(adapter);\r\npci_disable_device(pdev);\r\ndelete_adapter(adapter);\r\n}\r\nstatic int __init hisax_fcpcipnp_init(void)\r\n{\r\nint retval;\r\nprintk(KERN_INFO "hisax_fcpcipnp: Fritz!Card PCI/PCIv2/PnP ISDN driver v0.0.1\n");\r\nretval = pci_register_driver(&fcpci_driver);\r\nif (retval)\r\nreturn retval;\r\n#ifdef CONFIG_PNP\r\nretval = pnp_register_driver(&fcpnp_driver);\r\nif (retval < 0) {\r\npci_unregister_driver(&fcpci_driver);\r\nreturn retval;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit hisax_fcpcipnp_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\npnp_unregister_driver(&fcpnp_driver);\r\n#endif\r\npci_unregister_driver(&fcpci_driver);\r\n}
