static void *s_vGetFreeContext(struct vnt_private *pDevice)\r\n{\r\nPUSB_SEND_CONTEXT pContext = NULL;\r\nPUSB_SEND_CONTEXT pReturnContext = NULL;\r\nint ii;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"GetFreeContext()\n");\r\nfor (ii = 0; ii < pDevice->cbTD; ii++) {\r\npContext = pDevice->apTD[ii];\r\nif (pContext->bBoolInUse == false) {\r\npContext->bBoolInUse = true;\r\npReturnContext = pContext;\r\nbreak;\r\n}\r\n}\r\nif ( ii == pDevice->cbTD ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"No Free Tx Context\n");\r\n}\r\nreturn (void *) pReturnContext;\r\n}\r\nstatic void s_vSaveTxPktInfo(struct vnt_private *pDevice, u8 byPktNum,\r\nu8 *pbyDestAddr, u16 wPktLength, u16 wFIFOCtl)\r\n{\r\nPSStatCounter pStatistic = &pDevice->scStatistic;\r\nif (is_broadcast_ether_addr(pbyDestAddr))\r\npStatistic->abyTxPktInfo[byPktNum].byBroadMultiUni = TX_PKT_BROAD;\r\nelse if (is_multicast_ether_addr(pbyDestAddr))\r\npStatistic->abyTxPktInfo[byPktNum].byBroadMultiUni = TX_PKT_MULTI;\r\nelse\r\npStatistic->abyTxPktInfo[byPktNum].byBroadMultiUni = TX_PKT_UNI;\r\npStatistic->abyTxPktInfo[byPktNum].wLength = wPktLength;\r\npStatistic->abyTxPktInfo[byPktNum].wFIFOCtl = wFIFOCtl;\r\nmemcpy(pStatistic->abyTxPktInfo[byPktNum].abyDestAddr,\r\npbyDestAddr,\r\nETH_ALEN);\r\n}\r\nstatic void s_vFillTxKey(struct vnt_private *pDevice, u8 *pbyBuf,\r\nu8 *pbyIVHead, PSKeyItem pTransmitKey, u8 *pbyHdrBuf,\r\nu16 wPayloadLen, u8 *pMICHDR)\r\n{\r\nu32 *pdwIV = (u32 *)pbyIVHead;\r\nu32 *pdwExtIV = (u32 *)((u8 *)pbyIVHead + 4);\r\nu16 wValue;\r\nstruct ieee80211_hdr *pMACHeader = (struct ieee80211_hdr *)pbyHdrBuf;\r\nu32 dwRevIVCounter;\r\nif (pTransmitKey == NULL)\r\nreturn;\r\ndwRevIVCounter = cpu_to_le32(pDevice->dwIVCounter);\r\n*pdwIV = pDevice->dwIVCounter;\r\npDevice->byKeyIndex = pTransmitKey->dwKeyIndex & 0xf;\r\nif (pTransmitKey->byCipherSuite == KEY_CTL_WEP) {\r\nif (pTransmitKey->uKeyLength == WLAN_WEP232_KEYLEN ){\r\nmemcpy(pDevice->abyPRNG, (u8 *)&(dwRevIVCounter), 3);\r\nmemcpy(pDevice->abyPRNG+3, pTransmitKey->abyKey, pTransmitKey->uKeyLength);\r\n} else {\r\nmemcpy(pbyBuf, (u8 *)&(dwRevIVCounter), 3);\r\nmemcpy(pbyBuf+3, pTransmitKey->abyKey, pTransmitKey->uKeyLength);\r\nif(pTransmitKey->uKeyLength == WLAN_WEP40_KEYLEN) {\r\nmemcpy(pbyBuf+8, (u8 *)&(dwRevIVCounter), 3);\r\nmemcpy(pbyBuf+11, pTransmitKey->abyKey, pTransmitKey->uKeyLength);\r\n}\r\nmemcpy(pDevice->abyPRNG, pbyBuf, 16);\r\n}\r\n*pdwIV &= WEP_IV_MASK;\r\n*pdwIV |= (u32)pDevice->byKeyIndex << 30;\r\n*pdwIV = cpu_to_le32(*pdwIV);\r\npDevice->dwIVCounter++;\r\nif (pDevice->dwIVCounter > WEP_IV_MASK) {\r\npDevice->dwIVCounter = 0;\r\n}\r\n} else if (pTransmitKey->byCipherSuite == KEY_CTL_TKIP) {\r\npTransmitKey->wTSC15_0++;\r\nif (pTransmitKey->wTSC15_0 == 0) {\r\npTransmitKey->dwTSC47_16++;\r\n}\r\nTKIPvMixKey(pTransmitKey->abyKey, pDevice->abyCurrentNetAddr,\r\npTransmitKey->wTSC15_0, pTransmitKey->dwTSC47_16, pDevice->abyPRNG);\r\nmemcpy(pbyBuf, pDevice->abyPRNG, 16);\r\nmemcpy(pdwIV, pDevice->abyPRNG, 3);\r\n*(pbyIVHead+3) = (u8)(((pDevice->byKeyIndex << 6) & 0xc0) | 0x20);\r\n*pdwExtIV = cpu_to_le32(pTransmitKey->dwTSC47_16);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"vFillTxKey()---- pdwExtIV: %x\n",\r\n*pdwExtIV);\r\n} else if (pTransmitKey->byCipherSuite == KEY_CTL_CCMP) {\r\npTransmitKey->wTSC15_0++;\r\nif (pTransmitKey->wTSC15_0 == 0) {\r\npTransmitKey->dwTSC47_16++;\r\n}\r\nmemcpy(pbyBuf, pTransmitKey->abyKey, 16);\r\n*pdwIV = 0;\r\n*(pbyIVHead+3) = (u8)(((pDevice->byKeyIndex << 6) & 0xc0) | 0x20);\r\n*pdwIV |= cpu_to_le16((u16)(pTransmitKey->wTSC15_0));\r\n*pdwExtIV = cpu_to_le32(pTransmitKey->dwTSC47_16);\r\n*pMICHDR = 0x59;\r\n*((u8 *)(pMICHDR+1)) = 0;\r\nmemcpy(pMICHDR+2, &(pMACHeader->addr2[0]), 6);\r\n*((u8 *)(pMICHDR+8)) = HIBYTE(HIWORD(pTransmitKey->dwTSC47_16));\r\n*((u8 *)(pMICHDR+9)) = LOBYTE(HIWORD(pTransmitKey->dwTSC47_16));\r\n*((u8 *)(pMICHDR+10)) = HIBYTE(LOWORD(pTransmitKey->dwTSC47_16));\r\n*((u8 *)(pMICHDR+11)) = LOBYTE(LOWORD(pTransmitKey->dwTSC47_16));\r\n*((u8 *)(pMICHDR+12)) = HIBYTE(pTransmitKey->wTSC15_0);\r\n*((u8 *)(pMICHDR+13)) = LOBYTE(pTransmitKey->wTSC15_0);\r\n*((u8 *)(pMICHDR+14)) = HIBYTE(wPayloadLen);\r\n*((u8 *)(pMICHDR+15)) = LOBYTE(wPayloadLen);\r\n*((u8 *)(pMICHDR+16)) = 0;\r\nif (pDevice->bLongHeader) {\r\n*((u8 *)(pMICHDR+17)) = 28;\r\n} else {\r\n*((u8 *)(pMICHDR+17)) = 22;\r\n}\r\nwValue = cpu_to_le16(pMACHeader->frame_control & 0xC78F);\r\nmemcpy(pMICHDR+18, (u8 *)&wValue, 2);\r\nmemcpy(pMICHDR+20, &(pMACHeader->addr1[0]), 6);\r\nmemcpy(pMICHDR+26, &(pMACHeader->addr2[0]), 6);\r\nmemcpy(pMICHDR+32, &(pMACHeader->addr3[0]), 6);\r\nwValue = pMACHeader->seq_ctrl;\r\nwValue &= 0x000F;\r\nwValue = cpu_to_le16(wValue);\r\nmemcpy(pMICHDR+38, (u8 *)&wValue, 2);\r\nif (pDevice->bLongHeader) {\r\nmemcpy(pMICHDR+40, &(pMACHeader->addr4[0]), 6);\r\n}\r\n}\r\n}\r\nstatic void s_vSWencryption(struct vnt_private *pDevice,\r\nPSKeyItem pTransmitKey, u8 *pbyPayloadHead, u16 wPayloadSize)\r\n{\r\nu32 cbICVlen = 4;\r\nu32 dwICV = 0xffffffff;\r\nu32 *pdwICV;\r\nif (pTransmitKey == NULL)\r\nreturn;\r\nif (pTransmitKey->byCipherSuite == KEY_CTL_WEP) {\r\ndwICV = CRCdwGetCrc32Ex(pbyPayloadHead, wPayloadSize, dwICV);\r\npdwICV = (u32 *)(pbyPayloadHead + wPayloadSize);\r\n*pdwICV = cpu_to_le32(~dwICV);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, pTransmitKey->uKeyLength + 3);\r\nrc4_encrypt(&pDevice->SBox, pbyPayloadHead, pbyPayloadHead, wPayloadSize+cbICVlen);\r\n} else if (pTransmitKey->byCipherSuite == KEY_CTL_TKIP) {\r\ndwICV = CRCdwGetCrc32Ex(pbyPayloadHead, wPayloadSize, dwICV);\r\npdwICV = (u32 *)(pbyPayloadHead + wPayloadSize);\r\n*pdwICV = cpu_to_le32(~dwICV);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);\r\nrc4_encrypt(&pDevice->SBox, pbyPayloadHead, pbyPayloadHead, wPayloadSize+cbICVlen);\r\n}\r\n}\r\nstatic u32 s_uGetTxRsvTime(struct vnt_private *pDevice, u8 byPktType,\r\nu32 cbFrameLength, u16 wRate, int bNeedAck)\r\n{\r\nu32 uDataTime, uAckTime;\r\nuDataTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, cbFrameLength, wRate);\r\nif (byPktType == PK_TYPE_11B) {\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, (u16)pDevice->byTopCCKBasicRate);\r\n} else {\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, (u16)pDevice->byTopOFDMBasicRate);\r\n}\r\nif (bNeedAck) {\r\nreturn (uDataTime + pDevice->uSIFS + uAckTime);\r\n}\r\nelse {\r\nreturn uDataTime;\r\n}\r\n}\r\nstatic u32 s_uGetRTSCTSRsvTime(struct vnt_private *pDevice,\r\nu8 byRTSRsvType, u8 byPktType, u32 cbFrameLength, u16 wCurrentRate)\r\n{\r\nu32 uRrvTime, uRTSTime, uCTSTime, uAckTime, uDataTime;\r\nuRrvTime = uRTSTime = uCTSTime = uAckTime = uDataTime = 0;\r\nuDataTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, cbFrameLength, wCurrentRate);\r\nif (byRTSRsvType == 0) {\r\nuRTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 20, pDevice->byTopCCKBasicRate);\r\nuCTSTime = uAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\n}\r\nelse if (byRTSRsvType == 1){\r\nuRTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 20, pDevice->byTopCCKBasicRate);\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\n}\r\nelse if (byRTSRsvType == 2) {\r\nuRTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 20, pDevice->byTopOFDMBasicRate);\r\nuCTSTime = uAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\n}\r\nelse if (byRTSRsvType == 3) {\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nuRrvTime = uCTSTime + uAckTime + uDataTime + 2*pDevice->uSIFS;\r\nreturn uRrvTime;\r\n}\r\nuRrvTime = uRTSTime + uCTSTime + uAckTime + uDataTime + 3*pDevice->uSIFS;\r\nreturn uRrvTime;\r\n}\r\nstatic u32 s_uGetDataDuration(struct vnt_private *pDevice, u8 byDurType,\r\nu32 cbFrameLength, u8 byPktType, u16 wRate, int bNeedAck,\r\nu32 uFragIdx, u32 cbLastFragmentSize, u32 uMACfragNum,\r\nu8 byFBOption)\r\n{\r\nint bLastFrag = 0;\r\nu32 uAckTime = 0, uNextPktTime = 0;\r\nif (uFragIdx == (uMACfragNum-1)) {\r\nbLastFrag = 1;\r\n}\r\nswitch (byDurType) {\r\ncase DATADUR_B:\r\nif (((uMACfragNum == 1)) || (bLastFrag == 1)) {\r\nif (bNeedAck) {\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\nreturn (pDevice->uSIFS + uAckTime);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nelse {\r\nif (uFragIdx == (uMACfragNum-2)) {\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbLastFragmentSize, wRate, bNeedAck);\r\n} else {\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wRate, bNeedAck);\r\n}\r\nif (bNeedAck) {\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\nreturn (pDevice->uSIFS + uAckTime + uNextPktTime);\r\n} else {\r\nreturn (pDevice->uSIFS + uNextPktTime);\r\n}\r\n}\r\nbreak;\r\ncase DATADUR_A:\r\nif (((uMACfragNum==1)) || (bLastFrag==1)) {\r\nif(bNeedAck){\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nreturn (pDevice->uSIFS + uAckTime);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nelse {\r\nif(uFragIdx == (uMACfragNum-2)){\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbLastFragmentSize, wRate, bNeedAck);\r\n} else {\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wRate, bNeedAck);\r\n}\r\nif(bNeedAck){\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nreturn (pDevice->uSIFS + uAckTime + uNextPktTime);\r\n} else {\r\nreturn (pDevice->uSIFS + uNextPktTime);\r\n}\r\n}\r\nbreak;\r\ncase DATADUR_A_F0:\r\nif (((uMACfragNum==1)) || (bLastFrag==1)) {\r\nif(bNeedAck){\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nreturn (pDevice->uSIFS + uAckTime);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nelse {\r\nif (byFBOption == AUTO_FB_0) {\r\nif (wRate < RATE_18M)\r\nwRate = RATE_18M;\r\nelse if (wRate > RATE_54M)\r\nwRate = RATE_54M;\r\nif(uFragIdx == (uMACfragNum-2)){\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbLastFragmentSize, wFB_Opt0[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n} else {\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt0[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n}\r\n} else {\r\nif (wRate < RATE_18M)\r\nwRate = RATE_18M;\r\nelse if (wRate > RATE_54M)\r\nwRate = RATE_54M;\r\nif(uFragIdx == (uMACfragNum-2)){\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbLastFragmentSize, wFB_Opt1[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n} else {\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt1[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n}\r\n}\r\nif(bNeedAck){\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nreturn (pDevice->uSIFS + uAckTime + uNextPktTime);\r\n} else {\r\nreturn (pDevice->uSIFS + uNextPktTime);\r\n}\r\n}\r\nbreak;\r\ncase DATADUR_A_F1:\r\nif (((uMACfragNum==1)) || (bLastFrag==1)) {\r\nif(bNeedAck){\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nreturn (pDevice->uSIFS + uAckTime);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nelse {\r\nif (byFBOption == AUTO_FB_0) {\r\nif (wRate < RATE_18M)\r\nwRate = RATE_18M;\r\nelse if (wRate > RATE_54M)\r\nwRate = RATE_54M;\r\nif(uFragIdx == (uMACfragNum-2)){\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbLastFragmentSize, wFB_Opt0[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n} else {\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt0[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n}\r\n} else {\r\nif (wRate < RATE_18M)\r\nwRate = RATE_18M;\r\nelse if (wRate > RATE_54M)\r\nwRate = RATE_54M;\r\nif(uFragIdx == (uMACfragNum-2)){\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbLastFragmentSize, wFB_Opt1[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n} else {\r\nuNextPktTime = s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt1[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n}\r\n}\r\nif(bNeedAck){\r\nuAckTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nreturn (pDevice->uSIFS + uAckTime + uNextPktTime);\r\n} else {\r\nreturn (pDevice->uSIFS + uNextPktTime);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nASSERT(false);\r\nreturn 0;\r\n}\r\nstatic u32 s_uGetRTSCTSDuration(struct vnt_private *pDevice, u8 byDurType,\r\nu32 cbFrameLength, u8 byPktType, u16 wRate, int bNeedAck,\r\nu8 byFBOption)\r\n{\r\nu32 uCTSTime = 0, uDurTime = 0;\r\nswitch (byDurType) {\r\ncase RTSDUR_BB:\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wRate, bNeedAck);\r\nbreak;\r\ncase RTSDUR_BA:\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wRate, bNeedAck);\r\nbreak;\r\ncase RTSDUR_AA:\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wRate, bNeedAck);\r\nbreak;\r\ncase CTSDUR_BA:\r\nuDurTime = pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wRate, bNeedAck);\r\nbreak;\r\ncase RTSDUR_BA_F0:\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\nif ((byFBOption == AUTO_FB_0) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt0[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n} else if ((byFBOption == AUTO_FB_1) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt1[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n}\r\nbreak;\r\ncase RTSDUR_AA_F0:\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nif ((byFBOption == AUTO_FB_0) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt0[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n} else if ((byFBOption == AUTO_FB_1) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt1[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n}\r\nbreak;\r\ncase RTSDUR_BA_F1:\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopCCKBasicRate);\r\nif ((byFBOption == AUTO_FB_0) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt0[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n} else if ((byFBOption == AUTO_FB_1) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt1[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n}\r\nbreak;\r\ncase RTSDUR_AA_F1:\r\nuCTSTime = BBuGetFrameTime(pDevice->byPreambleType, byPktType, 14, pDevice->byTopOFDMBasicRate);\r\nif ((byFBOption == AUTO_FB_0) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt0[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n} else if ((byFBOption == AUTO_FB_1) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = uCTSTime + 2*pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt1[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n}\r\nbreak;\r\ncase CTSDUR_BA_F0:\r\nif ((byFBOption == AUTO_FB_0) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt0[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n} else if ((byFBOption == AUTO_FB_1) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt1[FB_RATE0][wRate-RATE_18M], bNeedAck);\r\n}\r\nbreak;\r\ncase CTSDUR_BA_F1:\r\nif ((byFBOption == AUTO_FB_0) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt0[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n} else if ((byFBOption == AUTO_FB_1) && (wRate >= RATE_18M) && (wRate <=RATE_54M)) {\r\nuDurTime = pDevice->uSIFS + s_uGetTxRsvTime(pDevice, byPktType, cbFrameLength, wFB_Opt1[FB_RATE1][wRate-RATE_18M], bNeedAck);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn uDurTime;\r\n}\r\nstatic u32 s_uFillDataHead(struct vnt_private *pDevice,\r\nu8 byPktType, u16 wCurrentRate, void *pTxDataHead, u32 cbFrameLength,\r\nu32 uDMAIdx, int bNeedAck, u32 uFragIdx, u32 cbLastFragmentSize,\r\nu32 uMACfragNum, u8 byFBOption)\r\n{\r\nif (pTxDataHead == NULL) {\r\nreturn 0;\r\n}\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\nif ((uDMAIdx == TYPE_ATIMDMA) || (uDMAIdx == TYPE_BEACONDMA)) {\r\nPSTxDataHead_ab pBuf = (PSTxDataHead_ab) pTxDataHead;\r\nBBvCalculateParameter(pDevice, cbFrameLength, wCurrentRate, byPktType,\r\n(u16 *)&(pBuf->wTransmitLength), (u8 *)&(pBuf->byServiceField), (u8 *)&(pBuf->bySignalField)\r\n);\r\npBuf->wDuration = (u16)s_uGetDataDuration(pDevice, DATADUR_A, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx,\r\ncbLastFragmentSize, uMACfragNum,\r\nbyFBOption);\r\nif(uDMAIdx!=TYPE_ATIMDMA) {\r\npBuf->wTimeStampOff = wTimeStampOff[pDevice->byPreambleType%2][wCurrentRate%MAX_RATE];\r\n}\r\nreturn (pBuf->wDuration);\r\n}\r\nelse {\r\nif (byFBOption == AUTO_FB_NONE) {\r\nPSTxDataHead_g pBuf = (PSTxDataHead_g)pTxDataHead;\r\nBBvCalculateParameter(pDevice, cbFrameLength, wCurrentRate, byPktType,\r\n(u16 *)&(pBuf->wTransmitLength_a), (u8 *)&(pBuf->byServiceField_a), (u8 *)&(pBuf->bySignalField_a)\r\n);\r\nBBvCalculateParameter(pDevice, cbFrameLength, pDevice->byTopCCKBasicRate, PK_TYPE_11B,\r\n(u16 *)&(pBuf->wTransmitLength_b), (u8 *)&(pBuf->byServiceField_b), (u8 *)&(pBuf->bySignalField_b)\r\n);\r\npBuf->wDuration_a = (u16)s_uGetDataDuration(pDevice, DATADUR_A, cbFrameLength,\r\nbyPktType, wCurrentRate, bNeedAck, uFragIdx,\r\ncbLastFragmentSize, uMACfragNum,\r\nbyFBOption);\r\npBuf->wDuration_b = (u16)s_uGetDataDuration(pDevice, DATADUR_B, cbFrameLength,\r\nPK_TYPE_11B, pDevice->byTopCCKBasicRate,\r\nbNeedAck, uFragIdx, cbLastFragmentSize,\r\nuMACfragNum, byFBOption);\r\npBuf->wTimeStampOff_a = wTimeStampOff[pDevice->byPreambleType%2][wCurrentRate%MAX_RATE];\r\npBuf->wTimeStampOff_b = wTimeStampOff[pDevice->byPreambleType%2][pDevice->byTopCCKBasicRate%MAX_RATE];\r\nreturn (pBuf->wDuration_a);\r\n} else {\r\nPSTxDataHead_g_FB pBuf = (PSTxDataHead_g_FB)pTxDataHead;\r\nBBvCalculateParameter(pDevice, cbFrameLength, wCurrentRate, byPktType,\r\n(u16 *)&(pBuf->wTransmitLength_a), (u8 *)&(pBuf->byServiceField_a), (u8 *)&(pBuf->bySignalField_a)\r\n);\r\nBBvCalculateParameter(pDevice, cbFrameLength, pDevice->byTopCCKBasicRate, PK_TYPE_11B,\r\n(u16 *)&(pBuf->wTransmitLength_b), (u8 *)&(pBuf->byServiceField_b), (u8 *)&(pBuf->bySignalField_b)\r\n);\r\npBuf->wDuration_a = (u16)s_uGetDataDuration(pDevice, DATADUR_A, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx, cbLastFragmentSize, uMACfragNum, byFBOption);\r\npBuf->wDuration_b = (u16)s_uGetDataDuration(pDevice, DATADUR_B, cbFrameLength, PK_TYPE_11B,\r\npDevice->byTopCCKBasicRate, bNeedAck, uFragIdx, cbLastFragmentSize, uMACfragNum, byFBOption);\r\npBuf->wDuration_a_f0 = (u16)s_uGetDataDuration(pDevice, DATADUR_A_F0, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx, cbLastFragmentSize, uMACfragNum, byFBOption);\r\npBuf->wDuration_a_f1 = (u16)s_uGetDataDuration(pDevice, DATADUR_A_F1, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx, cbLastFragmentSize, uMACfragNum, byFBOption);\r\npBuf->wTimeStampOff_a = wTimeStampOff[pDevice->byPreambleType%2][wCurrentRate%MAX_RATE];\r\npBuf->wTimeStampOff_b = wTimeStampOff[pDevice->byPreambleType%2][pDevice->byTopCCKBasicRate%MAX_RATE];\r\nreturn (pBuf->wDuration_a);\r\n}\r\n}\r\n}\r\nelse if (byPktType == PK_TYPE_11A) {\r\nif ((byFBOption != AUTO_FB_NONE) && (uDMAIdx != TYPE_ATIMDMA) && (uDMAIdx != TYPE_BEACONDMA)) {\r\nPSTxDataHead_a_FB pBuf = (PSTxDataHead_a_FB)pTxDataHead;\r\nBBvCalculateParameter(pDevice, cbFrameLength, wCurrentRate, byPktType,\r\n(u16 *)&(pBuf->wTransmitLength), (u8 *)&(pBuf->byServiceField), (u8 *)&(pBuf->bySignalField)\r\n);\r\npBuf->wDuration = (u16)s_uGetDataDuration(pDevice, DATADUR_A, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx, cbLastFragmentSize, uMACfragNum, byFBOption);\r\npBuf->wDuration_f0 = (u16)s_uGetDataDuration(pDevice, DATADUR_A_F0, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx, cbLastFragmentSize, uMACfragNum, byFBOption);\r\npBuf->wDuration_f1 = (u16)s_uGetDataDuration(pDevice, DATADUR_A_F1, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx, cbLastFragmentSize, uMACfragNum, byFBOption);\r\nif(uDMAIdx!=TYPE_ATIMDMA) {\r\npBuf->wTimeStampOff = wTimeStampOff[pDevice->byPreambleType%2][wCurrentRate%MAX_RATE];\r\n}\r\nreturn (pBuf->wDuration);\r\n} else {\r\nPSTxDataHead_ab pBuf = (PSTxDataHead_ab)pTxDataHead;\r\nBBvCalculateParameter(pDevice, cbFrameLength, wCurrentRate, byPktType,\r\n(u16 *)&(pBuf->wTransmitLength), (u8 *)&(pBuf->byServiceField), (u8 *)&(pBuf->bySignalField)\r\n);\r\npBuf->wDuration = (u16)s_uGetDataDuration(pDevice, DATADUR_A, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx,\r\ncbLastFragmentSize, uMACfragNum,\r\nbyFBOption);\r\nif(uDMAIdx!=TYPE_ATIMDMA) {\r\npBuf->wTimeStampOff = wTimeStampOff[pDevice->byPreambleType%2][wCurrentRate%MAX_RATE];\r\n}\r\nreturn (pBuf->wDuration);\r\n}\r\n}\r\nelse if (byPktType == PK_TYPE_11B) {\r\nPSTxDataHead_ab pBuf = (PSTxDataHead_ab)pTxDataHead;\r\nBBvCalculateParameter(pDevice, cbFrameLength, wCurrentRate, byPktType,\r\n(u16 *)&(pBuf->wTransmitLength), (u8 *)&(pBuf->byServiceField), (u8 *)&(pBuf->bySignalField)\r\n);\r\npBuf->wDuration = (u16)s_uGetDataDuration(pDevice, DATADUR_B, cbFrameLength, byPktType,\r\nwCurrentRate, bNeedAck, uFragIdx,\r\ncbLastFragmentSize, uMACfragNum,\r\nbyFBOption);\r\nif (uDMAIdx != TYPE_ATIMDMA) {\r\npBuf->wTimeStampOff = wTimeStampOff[pDevice->byPreambleType%2][wCurrentRate%MAX_RATE];\r\n}\r\nreturn (pBuf->wDuration);\r\n}\r\nreturn 0;\r\n}\r\nstatic void s_vFillRTSHead(struct vnt_private *pDevice, u8 byPktType,\r\nvoid *pvRTS, u32 cbFrameLength, int bNeedAck, int bDisCRC,\r\nstruct ethhdr *psEthHeader, u16 wCurrentRate, u8 byFBOption)\r\n{\r\nu32 uRTSFrameLen = 20;\r\nu16 wLen = 0;\r\nif (pvRTS == NULL)\r\nreturn;\r\nif (bDisCRC) {\r\nuRTSFrameLen -= 4;\r\n}\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\nif (byFBOption == AUTO_FB_NONE) {\r\nPSRTS_g pBuf = (PSRTS_g)pvRTS;\r\nBBvCalculateParameter(pDevice, uRTSFrameLen, pDevice->byTopCCKBasicRate, PK_TYPE_11B,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField_b), (u8 *)&(pBuf->bySignalField_b)\r\n);\r\npBuf->wTransmitLength_b = cpu_to_le16(wLen);\r\nBBvCalculateParameter(pDevice, uRTSFrameLen, pDevice->byTopOFDMBasicRate, byPktType,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField_a), (u8 *)&(pBuf->bySignalField_a)\r\n);\r\npBuf->wTransmitLength_a = cpu_to_le16(wLen);\r\npBuf->wDuration_bb = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_BB, cbFrameLength, PK_TYPE_11B, pDevice->byTopCCKBasicRate, bNeedAck, byFBOption));\r\npBuf->wDuration_aa = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_AA, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wDuration_ba = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_BA, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->Data.wDurationID = pBuf->wDuration_aa;\r\npBuf->Data.wFrameControl = TYPE_CTL_RTS;\r\nif ((pDevice->eOPMode == OP_MODE_ADHOC) ||\r\n(pDevice->eOPMode == OP_MODE_AP)) {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(psEthHeader->h_dest[0]),\r\nETH_ALEN);\r\n}\r\nelse {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n}\r\nif (pDevice->eOPMode == OP_MODE_AP) {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n}\r\nelse {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(psEthHeader->h_source[0]),\r\nETH_ALEN);\r\n}\r\n}\r\nelse {\r\nPSRTS_g_FB pBuf = (PSRTS_g_FB)pvRTS;\r\nBBvCalculateParameter(pDevice, uRTSFrameLen, pDevice->byTopCCKBasicRate, PK_TYPE_11B,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField_b), (u8 *)&(pBuf->bySignalField_b)\r\n);\r\npBuf->wTransmitLength_b = cpu_to_le16(wLen);\r\nBBvCalculateParameter(pDevice, uRTSFrameLen, pDevice->byTopOFDMBasicRate, byPktType,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField_a), (u8 *)&(pBuf->bySignalField_a)\r\n);\r\npBuf->wTransmitLength_a = cpu_to_le16(wLen);\r\npBuf->wDuration_bb = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_BB, cbFrameLength, PK_TYPE_11B, pDevice->byTopCCKBasicRate, bNeedAck, byFBOption));\r\npBuf->wDuration_aa = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_AA, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wDuration_ba = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_BA, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wRTSDuration_ba_f0 = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_BA_F0, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wRTSDuration_aa_f0 = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_AA_F0, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wRTSDuration_ba_f1 = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_BA_F1, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wRTSDuration_aa_f1 = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_AA_F1, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->Data.wDurationID = pBuf->wDuration_aa;\r\npBuf->Data.wFrameControl = TYPE_CTL_RTS;\r\nif ((pDevice->eOPMode == OP_MODE_ADHOC) ||\r\n(pDevice->eOPMode == OP_MODE_AP)) {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(psEthHeader->h_dest[0]),\r\nETH_ALEN);\r\n}\r\nelse {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n}\r\nif (pDevice->eOPMode == OP_MODE_AP) {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n}\r\nelse {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(psEthHeader->h_source[0]),\r\nETH_ALEN);\r\n}\r\n}\r\n}\r\nelse if (byPktType == PK_TYPE_11A) {\r\nif (byFBOption == AUTO_FB_NONE) {\r\nPSRTS_ab pBuf = (PSRTS_ab)pvRTS;\r\nBBvCalculateParameter(pDevice, uRTSFrameLen, pDevice->byTopOFDMBasicRate, byPktType,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField), (u8 *)&(pBuf->bySignalField)\r\n);\r\npBuf->wTransmitLength = cpu_to_le16(wLen);\r\npBuf->wDuration = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_AA, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->Data.wDurationID = pBuf->wDuration;\r\npBuf->Data.wFrameControl = TYPE_CTL_RTS;\r\nif ((pDevice->eOPMode == OP_MODE_ADHOC) ||\r\n(pDevice->eOPMode == OP_MODE_AP)) {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(psEthHeader->h_dest[0]),\r\nETH_ALEN);\r\n} else {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n}\r\nif (pDevice->eOPMode == OP_MODE_AP) {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n} else {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(psEthHeader->h_source[0]),\r\nETH_ALEN);\r\n}\r\n}\r\nelse {\r\nPSRTS_a_FB pBuf = (PSRTS_a_FB)pvRTS;\r\nBBvCalculateParameter(pDevice, uRTSFrameLen, pDevice->byTopOFDMBasicRate, byPktType,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField), (u8 *)&(pBuf->bySignalField)\r\n);\r\npBuf->wTransmitLength = cpu_to_le16(wLen);\r\npBuf->wDuration = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_AA, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wRTSDuration_f0 = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_AA_F0, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wRTSDuration_f1 = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_AA_F1, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->Data.wDurationID = pBuf->wDuration;\r\npBuf->Data.wFrameControl = TYPE_CTL_RTS;\r\nif ((pDevice->eOPMode == OP_MODE_ADHOC) ||\r\n(pDevice->eOPMode == OP_MODE_AP)) {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(psEthHeader->h_dest[0]),\r\nETH_ALEN);\r\n} else {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n}\r\nif (pDevice->eOPMode == OP_MODE_AP) {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n} else {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(psEthHeader->h_source[0]),\r\nETH_ALEN);\r\n}\r\n}\r\n}\r\nelse if (byPktType == PK_TYPE_11B) {\r\nPSRTS_ab pBuf = (PSRTS_ab)pvRTS;\r\nBBvCalculateParameter(pDevice, uRTSFrameLen, pDevice->byTopCCKBasicRate, PK_TYPE_11B,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField), (u8 *)&(pBuf->bySignalField)\r\n);\r\npBuf->wTransmitLength = cpu_to_le16(wLen);\r\npBuf->wDuration = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, RTSDUR_BB, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->Data.wDurationID = pBuf->wDuration;\r\npBuf->Data.wFrameControl = TYPE_CTL_RTS;\r\nif ((pDevice->eOPMode == OP_MODE_ADHOC) ||\r\n(pDevice->eOPMode == OP_MODE_AP)) {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(psEthHeader->h_dest[0]),\r\nETH_ALEN);\r\n}\r\nelse {\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n}\r\nif (pDevice->eOPMode == OP_MODE_AP) {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n} else {\r\nmemcpy(&(pBuf->Data.abyTA[0]),\r\n&(psEthHeader->h_source[0]),\r\nETH_ALEN);\r\n}\r\n}\r\n}\r\nstatic void s_vFillCTSHead(struct vnt_private *pDevice, u32 uDMAIdx,\r\nu8 byPktType, void *pvCTS, u32 cbFrameLength, int bNeedAck,\r\nint bDisCRC, u16 wCurrentRate, u8 byFBOption)\r\n{\r\nu32 uCTSFrameLen = 14;\r\nu16 wLen = 0;\r\nif (pvCTS == NULL) {\r\nreturn;\r\n}\r\nif (bDisCRC) {\r\nuCTSFrameLen -= 4;\r\n}\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\nif (byFBOption != AUTO_FB_NONE && uDMAIdx != TYPE_ATIMDMA && uDMAIdx != TYPE_BEACONDMA) {\r\nPSCTS_FB pBuf = (PSCTS_FB)pvCTS;\r\nBBvCalculateParameter(pDevice, uCTSFrameLen, pDevice->byTopCCKBasicRate, PK_TYPE_11B,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField_b), (u8 *)&(pBuf->bySignalField_b)\r\n);\r\npBuf->wTransmitLength_b = cpu_to_le16(wLen);\r\npBuf->wDuration_ba = (u16)s_uGetRTSCTSDuration(pDevice, CTSDUR_BA, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption);\r\npBuf->wDuration_ba += pDevice->wCTSDuration;\r\npBuf->wDuration_ba = cpu_to_le16(pBuf->wDuration_ba);\r\npBuf->wCTSDuration_ba_f0 = (u16)s_uGetRTSCTSDuration(pDevice, CTSDUR_BA_F0, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption);\r\npBuf->wCTSDuration_ba_f0 += pDevice->wCTSDuration;\r\npBuf->wCTSDuration_ba_f0 = cpu_to_le16(pBuf->wCTSDuration_ba_f0);\r\npBuf->wCTSDuration_ba_f1 = (u16)s_uGetRTSCTSDuration(pDevice, CTSDUR_BA_F1, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption);\r\npBuf->wCTSDuration_ba_f1 += pDevice->wCTSDuration;\r\npBuf->wCTSDuration_ba_f1 = cpu_to_le16(pBuf->wCTSDuration_ba_f1);\r\npBuf->Data.wDurationID = pBuf->wDuration_ba;\r\npBuf->Data.wFrameControl = TYPE_CTL_CTS;\r\npBuf->Data.wReserved = 0x0000;\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(pDevice->abyCurrentNetAddr[0]),\r\nETH_ALEN);\r\n} else {\r\nPSCTS pBuf = (PSCTS)pvCTS;\r\nBBvCalculateParameter(pDevice, uCTSFrameLen, pDevice->byTopCCKBasicRate, PK_TYPE_11B,\r\n(u16 *)&(wLen), (u8 *)&(pBuf->byServiceField_b), (u8 *)&(pBuf->bySignalField_b)\r\n);\r\npBuf->wTransmitLength_b = cpu_to_le16(wLen);\r\npBuf->wDuration_ba = cpu_to_le16((u16)s_uGetRTSCTSDuration(pDevice, CTSDUR_BA, cbFrameLength, byPktType, wCurrentRate, bNeedAck, byFBOption));\r\npBuf->wDuration_ba += pDevice->wCTSDuration;\r\npBuf->wDuration_ba = cpu_to_le16(pBuf->wDuration_ba);\r\npBuf->Data.wDurationID = pBuf->wDuration_ba;\r\npBuf->Data.wFrameControl = TYPE_CTL_CTS;\r\npBuf->Data.wReserved = 0x0000;\r\nmemcpy(&(pBuf->Data.abyRA[0]),\r\n&(pDevice->abyCurrentNetAddr[0]),\r\nETH_ALEN);\r\n}\r\n}\r\n}\r\nstatic void s_vGenerateTxParameter(struct vnt_private *pDevice,\r\nu8 byPktType, u16 wCurrentRate, void *pTxBufHead, void *pvRrvTime,\r\nvoid *pvRTS, void *pvCTS, u32 cbFrameSize, int bNeedACK, u32 uDMAIdx,\r\nstruct ethhdr *psEthHeader)\r\n{\r\nu32 cbMACHdLen = WLAN_HDR_ADDR3_LEN;\r\nu16 wFifoCtl;\r\nint bDisCRC = false;\r\nu8 byFBOption = AUTO_FB_NONE;\r\nPSTxBufHead pFifoHead = (PSTxBufHead)pTxBufHead;\r\npFifoHead->wReserved = wCurrentRate;\r\nwFifoCtl = pFifoHead->wFIFOCtl;\r\nif (wFifoCtl & FIFOCTL_CRCDIS) {\r\nbDisCRC = true;\r\n}\r\nif (wFifoCtl & FIFOCTL_AUTO_FB_0) {\r\nbyFBOption = AUTO_FB_0;\r\n}\r\nelse if (wFifoCtl & FIFOCTL_AUTO_FB_1) {\r\nbyFBOption = AUTO_FB_1;\r\n}\r\nif (pDevice->bLongHeader)\r\ncbMACHdLen = WLAN_HDR_ADDR3_LEN + 6;\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\nif (pvRTS != NULL) {\r\nif (pvRrvTime) {\r\nPSRrvTime_gRTS pBuf = (PSRrvTime_gRTS)pvRrvTime;\r\npBuf->wRTSTxRrvTime_aa = cpu_to_le16((u16)s_uGetRTSCTSRsvTime(pDevice, 2, byPktType, cbFrameSize, wCurrentRate));\r\npBuf->wRTSTxRrvTime_ba = cpu_to_le16((u16)s_uGetRTSCTSRsvTime(pDevice, 1, byPktType, cbFrameSize, wCurrentRate));\r\npBuf->wRTSTxRrvTime_bb = cpu_to_le16((u16)s_uGetRTSCTSRsvTime(pDevice, 0, byPktType, cbFrameSize, wCurrentRate));\r\npBuf->wTxRrvTime_a = cpu_to_le16((u16) s_uGetTxRsvTime(pDevice, byPktType, cbFrameSize, wCurrentRate, bNeedACK));\r\npBuf->wTxRrvTime_b = cpu_to_le16((u16) s_uGetTxRsvTime(pDevice, PK_TYPE_11B, cbFrameSize, pDevice->byTopCCKBasicRate, bNeedACK));\r\n}\r\ns_vFillRTSHead(pDevice, byPktType, pvRTS, cbFrameSize, bNeedACK, bDisCRC, psEthHeader, wCurrentRate, byFBOption);\r\n}\r\nelse {\r\nif (pvRrvTime) {\r\nPSRrvTime_gCTS pBuf = (PSRrvTime_gCTS)pvRrvTime;\r\npBuf->wTxRrvTime_a = cpu_to_le16((u16)s_uGetTxRsvTime(pDevice, byPktType, cbFrameSize, wCurrentRate, bNeedACK));\r\npBuf->wTxRrvTime_b = cpu_to_le16((u16)s_uGetTxRsvTime(pDevice, PK_TYPE_11B, cbFrameSize, pDevice->byTopCCKBasicRate, bNeedACK));\r\npBuf->wCTSTxRrvTime_ba = cpu_to_le16((u16)s_uGetRTSCTSRsvTime(pDevice, 3, byPktType, cbFrameSize, wCurrentRate));\r\n}\r\ns_vFillCTSHead(pDevice, uDMAIdx, byPktType, pvCTS, cbFrameSize, bNeedACK, bDisCRC, wCurrentRate, byFBOption);\r\n}\r\n}\r\nelse if (byPktType == PK_TYPE_11A) {\r\nif (pvRTS != NULL) {\r\nif (pvRrvTime) {\r\nPSRrvTime_ab pBuf = (PSRrvTime_ab)pvRrvTime;\r\npBuf->wRTSTxRrvTime = cpu_to_le16((u16)s_uGetRTSCTSRsvTime(pDevice, 2, byPktType, cbFrameSize, wCurrentRate));\r\npBuf->wTxRrvTime = cpu_to_le16((u16)s_uGetTxRsvTime(pDevice, byPktType, cbFrameSize, wCurrentRate, bNeedACK));\r\n}\r\ns_vFillRTSHead(pDevice, byPktType, pvRTS, cbFrameSize, bNeedACK, bDisCRC, psEthHeader, wCurrentRate, byFBOption);\r\n}\r\nelse if (pvRTS == NULL) {\r\nif (pvRrvTime) {\r\nPSRrvTime_ab pBuf = (PSRrvTime_ab)pvRrvTime;\r\npBuf->wTxRrvTime = cpu_to_le16((u16)s_uGetTxRsvTime(pDevice, PK_TYPE_11A, cbFrameSize, wCurrentRate, bNeedACK));\r\n}\r\n}\r\n}\r\nelse if (byPktType == PK_TYPE_11B) {\r\nif ((pvRTS != NULL)) {\r\nif (pvRrvTime) {\r\nPSRrvTime_ab pBuf = (PSRrvTime_ab)pvRrvTime;\r\npBuf->wRTSTxRrvTime = cpu_to_le16((u16)s_uGetRTSCTSRsvTime(pDevice, 0, byPktType, cbFrameSize, wCurrentRate));\r\npBuf->wTxRrvTime = cpu_to_le16((u16)s_uGetTxRsvTime(pDevice, PK_TYPE_11B, cbFrameSize, wCurrentRate, bNeedACK));\r\n}\r\ns_vFillRTSHead(pDevice, byPktType, pvRTS, cbFrameSize, bNeedACK, bDisCRC, psEthHeader, wCurrentRate, byFBOption);\r\n}\r\nelse {\r\nif (pvRrvTime) {\r\nPSRrvTime_ab pBuf = (PSRrvTime_ab)pvRrvTime;\r\npBuf->wTxRrvTime = cpu_to_le16((u16)s_uGetTxRsvTime(pDevice, PK_TYPE_11B, cbFrameSize, wCurrentRate, bNeedACK));\r\n}\r\n}\r\n}\r\n}\r\nstatic int s_bPacketToWirelessUsb(struct vnt_private *pDevice, u8 byPktType,\r\nu8 *usbPacketBuf, int bNeedEncryption, u32 uSkbPacketLen, u32 uDMAIdx,\r\nstruct ethhdr *psEthHeader, u8 *pPacket, PSKeyItem pTransmitKey,\r\nu32 uNodeIndex, u16 wCurrentRate, u32 *pcbHeaderLen, u32 *pcbTotalLen)\r\n{\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nu32 cbFrameSize, cbFrameBodySize;\r\nPTX_BUFFER pTxBufHead;\r\nu32 cb802_1_H_len;\r\nu32 cbIVlen = 0, cbICVlen = 0, cbMIClen = 0, cbMACHdLen = 0;\r\nu32 cbFCSlen = 4, cbMICHDR = 0;\r\nint bNeedACK, bRTS;\r\nu8 *pbyType, *pbyMacHdr, *pbyIVHead, *pbyPayloadHead, *pbyTxBufferAddr;\r\nu8 abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};\r\nu8 abySNAP_Bridgetunnel[ETH_ALEN]\r\n= {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};\r\nu32 uDuration;\r\nu32 cbHeaderLength = 0, uPadding = 0;\r\nvoid *pvRrvTime;\r\nPSMICHDRHead pMICHDR;\r\nvoid *pvRTS;\r\nvoid *pvCTS;\r\nvoid *pvTxDataHd;\r\nu8 byFBOption = AUTO_FB_NONE, byFragType;\r\nu16 wTxBufSize;\r\nu32 dwMICKey0, dwMICKey1, dwMIC_Priority, dwCRC;\r\nu32 *pdwMIC_L, *pdwMIC_R;\r\nint bSoftWEP = false;\r\npvRrvTime = pMICHDR = pvRTS = pvCTS = pvTxDataHd = NULL;\r\nif (bNeedEncryption && pTransmitKey->pvKeyTable) {\r\nif (((PSKeyTable)pTransmitKey->pvKeyTable)->bSoftWEP == true)\r\nbSoftWEP = true;\r\n}\r\npTxBufHead = (PTX_BUFFER) usbPacketBuf;\r\nmemset(pTxBufHead, 0, sizeof(TX_BUFFER));\r\nif (ntohs(psEthHeader->h_proto) > ETH_DATA_LEN) {\r\nif (pDevice->dwDiagRefCount == 0) {\r\ncb802_1_H_len = 8;\r\n} else {\r\ncb802_1_H_len = 2;\r\n}\r\n} else {\r\ncb802_1_H_len = 0;\r\n}\r\ncbFrameBodySize = uSkbPacketLen - ETH_HLEN + cb802_1_H_len;\r\npTxBufHead->wFIFOCtl |= (u16)(byPktType<<8);\r\nif (pDevice->dwDiagRefCount != 0) {\r\nbNeedACK = false;\r\npTxBufHead->wFIFOCtl = pTxBufHead->wFIFOCtl & (~FIFOCTL_NEEDACK);\r\n} else {\r\nif ((pDevice->eOPMode == OP_MODE_ADHOC) ||\r\n(pDevice->eOPMode == OP_MODE_AP)) {\r\nif (is_multicast_ether_addr(psEthHeader->h_dest)) {\r\nbNeedACK = false;\r\npTxBufHead->wFIFOCtl =\r\npTxBufHead->wFIFOCtl & (~FIFOCTL_NEEDACK);\r\n} else {\r\nbNeedACK = true;\r\npTxBufHead->wFIFOCtl |= FIFOCTL_NEEDACK;\r\n}\r\n}\r\nelse {\r\nbNeedACK = true;\r\npTxBufHead->wFIFOCtl |= FIFOCTL_NEEDACK;\r\n}\r\n}\r\npTxBufHead->wTimeStamp = DEFAULT_MSDU_LIFETIME_RES_64us;\r\nif (pDevice->bLongHeader)\r\npTxBufHead->wFIFOCtl |= FIFOCTL_LHEAD;\r\nif (pDevice->bSoftwareGenCrcErr) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_CRCDIS;\r\n}\r\nif (pDevice->bLongHeader) {\r\ncbMACHdLen = WLAN_HDR_ADDR3_LEN + 6;\r\n} else {\r\ncbMACHdLen = WLAN_HDR_ADDR3_LEN;\r\n}\r\npTxBufHead->wFragCtl |= (u16)(cbMACHdLen << 10);\r\nif (pDevice->bGrpAckPolicy == true) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_GRPACK;\r\n}\r\nif (wCurrentRate >= RATE_18M) {\r\nif (pDevice->byAutoFBCtrl == AUTO_FB_0) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_AUTO_FB_0;\r\nbyFBOption = AUTO_FB_0;\r\n} else if (pDevice->byAutoFBCtrl == AUTO_FB_1) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_AUTO_FB_1;\r\nbyFBOption = AUTO_FB_1;\r\n}\r\n}\r\nif (bSoftWEP != true) {\r\nif ((bNeedEncryption) && (pTransmitKey != NULL)) {\r\nif (pTransmitKey->byCipherSuite == KEY_CTL_WEP) {\r\npTxBufHead->wFragCtl |= FRAGCTL_LEGACY;\r\n}\r\nif (pTransmitKey->byCipherSuite == KEY_CTL_TKIP) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Tx Set wFragCtl == FRAGCTL_TKIP\n");\r\npTxBufHead->wFragCtl |= FRAGCTL_TKIP;\r\n}\r\nelse if (pTransmitKey->byCipherSuite == KEY_CTL_CCMP) {\r\npTxBufHead->wFragCtl |= FRAGCTL_AES;\r\n}\r\n}\r\n}\r\nif ((bNeedEncryption) && (pTransmitKey != NULL)) {\r\nif (pTransmitKey->byCipherSuite == KEY_CTL_WEP) {\r\ncbIVlen = 4;\r\ncbICVlen = 4;\r\n}\r\nelse if (pTransmitKey->byCipherSuite == KEY_CTL_TKIP) {\r\ncbIVlen = 8;\r\ncbMIClen = 8;\r\ncbICVlen = 4;\r\n}\r\nif (pTransmitKey->byCipherSuite == KEY_CTL_CCMP) {\r\ncbIVlen = 8;\r\ncbICVlen = 8;\r\ncbMICHDR = sizeof(SMICHDRHead);\r\n}\r\nif (bSoftWEP == false) {\r\nuPadding = 4 - (cbMACHdLen%4);\r\nuPadding %= 4;\r\n}\r\n}\r\ncbFrameSize = cbMACHdLen + cbIVlen + (cbFrameBodySize + cbMIClen) + cbICVlen + cbFCSlen;\r\nif ( (bNeedACK == false) ||(cbFrameSize < pDevice->wRTSThreshold) ) {\r\nbRTS = false;\r\n} else {\r\nbRTS = true;\r\npTxBufHead->wFIFOCtl |= (FIFOCTL_RTS | FIFOCTL_LRETRY);\r\n}\r\npbyTxBufferAddr = (u8 *) &(pTxBufHead->adwTxKey[0]);\r\nwTxBufSize = sizeof(STxBufHead);\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\nif (byFBOption == AUTO_FB_NONE) {\r\nif (bRTS == true) {\r\npvRrvTime = (PSRrvTime_gRTS) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gRTS));\r\npvRTS = (PSRTS_g) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gRTS) + cbMICHDR);\r\npvCTS = NULL;\r\npvTxDataHd = (PSTxDataHead_g) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gRTS) + cbMICHDR + sizeof(SRTS_g));\r\ncbHeaderLength = wTxBufSize + sizeof(SRrvTime_gRTS) + cbMICHDR + sizeof(SRTS_g) + sizeof(STxDataHead_g);\r\n}\r\nelse {\r\npvRrvTime = (PSRrvTime_gCTS) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS));\r\npvRTS = NULL;\r\npvCTS = (PSCTS) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR);\r\npvTxDataHd = (PSTxDataHead_g) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR + sizeof(SCTS));\r\ncbHeaderLength = wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR + sizeof(SCTS) + sizeof(STxDataHead_g);\r\n}\r\n} else {\r\nif (bRTS == true) {\r\npvRrvTime = (PSRrvTime_gRTS) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gRTS));\r\npvRTS = (PSRTS_g_FB) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gRTS) + cbMICHDR);\r\npvCTS = NULL;\r\npvTxDataHd = (PSTxDataHead_g_FB) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gRTS) + cbMICHDR + sizeof(SRTS_g_FB));\r\ncbHeaderLength = wTxBufSize + sizeof(SRrvTime_gRTS) + cbMICHDR + sizeof(SRTS_g_FB) + sizeof(STxDataHead_g_FB);\r\n}\r\nelse if (bRTS == false) {\r\npvRrvTime = (PSRrvTime_gCTS) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS));\r\npvRTS = NULL;\r\npvCTS = (PSCTS_FB) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR);\r\npvTxDataHd = (PSTxDataHead_g_FB) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR + sizeof(SCTS_FB));\r\ncbHeaderLength = wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR + sizeof(SCTS_FB) + sizeof(STxDataHead_g_FB);\r\n}\r\n}\r\n}\r\nelse {\r\nif (byFBOption == AUTO_FB_NONE) {\r\nif (bRTS == true) {\r\npvRrvTime = (PSRrvTime_ab) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab));\r\npvRTS = (PSRTS_ab) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR);\r\npvCTS = NULL;\r\npvTxDataHd = (PSTxDataHead_ab) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR + sizeof(SRTS_ab));\r\ncbHeaderLength = wTxBufSize + sizeof(PSRrvTime_ab) + cbMICHDR + sizeof(SRTS_ab) + sizeof(STxDataHead_ab);\r\n}\r\nelse if (bRTS == false) {\r\npvRrvTime = (PSRrvTime_ab) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab));\r\npvRTS = NULL;\r\npvCTS = NULL;\r\npvTxDataHd = (PSTxDataHead_ab) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR);\r\ncbHeaderLength = wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR + sizeof(STxDataHead_ab);\r\n}\r\n} else {\r\nif (bRTS == true) {\r\npvRrvTime = (PSRrvTime_ab) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab));\r\npvRTS = (PSRTS_a_FB) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR);\r\npvCTS = NULL;\r\npvTxDataHd = (PSTxDataHead_a_FB) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR + sizeof(SRTS_a_FB));\r\ncbHeaderLength = wTxBufSize + sizeof(PSRrvTime_ab) + cbMICHDR + sizeof(SRTS_a_FB) + sizeof(STxDataHead_a_FB);\r\n}\r\nelse if (bRTS == false) {\r\npvRrvTime = (PSRrvTime_ab) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab));\r\npvRTS = NULL;\r\npvCTS = NULL;\r\npvTxDataHd = (PSTxDataHead_a_FB) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR);\r\ncbHeaderLength = wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR + sizeof(STxDataHead_a_FB);\r\n}\r\n}\r\n}\r\npbyMacHdr = (u8 *)(pbyTxBufferAddr + cbHeaderLength);\r\npbyIVHead = (u8 *)(pbyMacHdr + cbMACHdLen + uPadding);\r\npbyPayloadHead = (u8 *)(pbyMacHdr + cbMACHdLen + uPadding + cbIVlen);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"No Fragmentation...\n");\r\nbyFragType = FRAGCTL_NONFRAG;\r\ns_vGenerateTxParameter(pDevice, byPktType, wCurrentRate,\r\n(void *)pbyTxBufferAddr, pvRrvTime, pvRTS, pvCTS,\r\ncbFrameSize, bNeedACK, uDMAIdx, psEthHeader);\r\nuDuration = s_uFillDataHead(pDevice, byPktType, wCurrentRate, pvTxDataHd, cbFrameSize, uDMAIdx, bNeedACK,\r\n0, 0, 1, byFBOption);\r\ns_vGenerateMACHeader(pDevice, pbyMacHdr, (u16)uDuration, psEthHeader, bNeedEncryption,\r\nbyFragType, uDMAIdx, 0);\r\nif (bNeedEncryption == true) {\r\ns_vFillTxKey(pDevice, (u8 *)(pTxBufHead->adwTxKey), pbyIVHead, pTransmitKey,\r\npbyMacHdr, (u16)cbFrameBodySize, (u8 *)pMICHDR);\r\nif (pDevice->bEnableHostWEP) {\r\npMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16 = pTransmitKey->dwTSC47_16;\r\npMgmt->sNodeDBTable[uNodeIndex].wTSC15_0 = pTransmitKey->wTSC15_0;\r\n}\r\n}\r\nif (ntohs(psEthHeader->h_proto) > ETH_DATA_LEN) {\r\nif (pDevice->dwDiagRefCount == 0) {\r\nif ((psEthHeader->h_proto == cpu_to_be16(ETH_P_IPX)) ||\r\n(psEthHeader->h_proto == cpu_to_le16(0xF380))) {\r\nmemcpy((u8 *) (pbyPayloadHead),\r\nabySNAP_Bridgetunnel, 6);\r\n} else {\r\nmemcpy((u8 *) (pbyPayloadHead), &abySNAP_RFC1042[0], 6);\r\n}\r\npbyType = (u8 *) (pbyPayloadHead + 6);\r\nmemcpy(pbyType, &(psEthHeader->h_proto), sizeof(u16));\r\n} else {\r\nmemcpy((u8 *) (pbyPayloadHead), &(psEthHeader->h_proto), sizeof(u16));\r\n}\r\n}\r\nif (pPacket != NULL) {\r\nmemcpy((pbyPayloadHead + cb802_1_H_len),\r\n(pPacket + ETH_HLEN),\r\nuSkbPacketLen - ETH_HLEN\r\n);\r\n} else {\r\nmemcpy((pbyPayloadHead + cb802_1_H_len), ((u8 *)psEthHeader) + ETH_HLEN, uSkbPacketLen - ETH_HLEN);\r\n}\r\nASSERT(uLength == cbNdisBodySize);\r\nif ((bNeedEncryption == true) && (pTransmitKey != NULL) && (pTransmitKey->byCipherSuite == KEY_CTL_TKIP)) {\r\nif (pDevice->vnt_mgmt.eAuthenMode == WMAC_AUTH_WPANONE) {\r\ndwMICKey0 = *(u32 *)(&pTransmitKey->abyKey[16]);\r\ndwMICKey1 = *(u32 *)(&pTransmitKey->abyKey[20]);\r\n}\r\nelse if ((pTransmitKey->dwKeyIndex & AUTHENTICATOR_KEY) != 0) {\r\ndwMICKey0 = *(u32 *)(&pTransmitKey->abyKey[16]);\r\ndwMICKey1 = *(u32 *)(&pTransmitKey->abyKey[20]);\r\n}\r\nelse {\r\ndwMICKey0 = *(u32 *)(&pTransmitKey->abyKey[24]);\r\ndwMICKey1 = *(u32 *)(&pTransmitKey->abyKey[28]);\r\n}\r\nMIC_vInit(dwMICKey0, dwMICKey1);\r\nMIC_vAppend((u8 *)&(psEthHeader->h_dest[0]), 12);\r\ndwMIC_Priority = 0;\r\nMIC_vAppend((u8 *)&dwMIC_Priority, 4);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC KEY: %X, %X\n",\r\ndwMICKey0, dwMICKey1);\r\nMIC_vAppend(pbyPayloadHead, cbFrameBodySize);\r\npdwMIC_L = (u32 *)(pbyPayloadHead + cbFrameBodySize);\r\npdwMIC_R = (u32 *)(pbyPayloadHead + cbFrameBodySize + 4);\r\nMIC_vGetMIC(pdwMIC_L, pdwMIC_R);\r\nMIC_vUnInit();\r\nif (pDevice->bTxMICFail == true) {\r\n*pdwMIC_L = 0;\r\n*pdwMIC_R = 0;\r\npDevice->bTxMICFail = false;\r\n}\r\n}\r\nif (bSoftWEP == true) {\r\ns_vSWencryption(pDevice, pTransmitKey, (pbyPayloadHead), (u16)(cbFrameBodySize + cbMIClen));\r\n} else if ( ((pDevice->eEncryptionStatus == Ndis802_11Encryption1Enabled) && (bNeedEncryption == true)) ||\r\n((pDevice->eEncryptionStatus == Ndis802_11Encryption2Enabled) && (bNeedEncryption == true)) ||\r\n((pDevice->eEncryptionStatus == Ndis802_11Encryption3Enabled) && (bNeedEncryption == true)) ) {\r\ncbFrameSize -= cbICVlen;\r\n}\r\nif (pDevice->bSoftwareGenCrcErr == true) {\r\nunsigned int cbLen;\r\nu32 * pdwCRC;\r\ndwCRC = 0xFFFFFFFFL;\r\ncbLen = cbFrameSize - cbFCSlen;\r\ndwCRC = CRCdwGetCrc32Ex(pbyMacHdr, cbLen, dwCRC);\r\npdwCRC = (u32 *)(pbyMacHdr + cbLen);\r\n*pdwCRC = ~dwCRC;\r\n*pdwCRC -= 1;\r\n} else {\r\ncbFrameSize -= cbFCSlen;\r\n}\r\n*pcbHeaderLen = cbHeaderLength;\r\n*pcbTotalLen = cbHeaderLength + cbFrameSize ;\r\npTxBufHead->wFragCtl |= (u16)byFragType;\r\nreturn true;\r\n}\r\nstatic void s_vGenerateMACHeader(struct vnt_private *pDevice,\r\nu8 *pbyBufferAddr, u16 wDuration, struct ethhdr *psEthHeader,\r\nint bNeedEncrypt, u16 wFragType, u32 uDMAIdx, u32 uFragIdx)\r\n{\r\nstruct ieee80211_hdr *pMACHeader = (struct ieee80211_hdr *)pbyBufferAddr;\r\nmemset(pMACHeader, 0, (sizeof(struct ieee80211_hdr)));\r\nif (uDMAIdx == TYPE_ATIMDMA) {\r\npMACHeader->frame_control = TYPE_802_11_ATIM;\r\n} else {\r\npMACHeader->frame_control = TYPE_802_11_DATA;\r\n}\r\nif (pDevice->eOPMode == OP_MODE_AP) {\r\nmemcpy(&(pMACHeader->addr1[0]),\r\n&(psEthHeader->h_dest[0]),\r\nETH_ALEN);\r\nmemcpy(&(pMACHeader->addr2[0]), &(pDevice->abyBSSID[0]), ETH_ALEN);\r\nmemcpy(&(pMACHeader->addr3[0]),\r\n&(psEthHeader->h_source[0]),\r\nETH_ALEN);\r\npMACHeader->frame_control |= FC_FROMDS;\r\n} else {\r\nif (pDevice->eOPMode == OP_MODE_ADHOC) {\r\nmemcpy(&(pMACHeader->addr1[0]),\r\n&(psEthHeader->h_dest[0]),\r\nETH_ALEN);\r\nmemcpy(&(pMACHeader->addr2[0]),\r\n&(psEthHeader->h_source[0]),\r\nETH_ALEN);\r\nmemcpy(&(pMACHeader->addr3[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\n} else {\r\nmemcpy(&(pMACHeader->addr3[0]),\r\n&(psEthHeader->h_dest[0]),\r\nETH_ALEN);\r\nmemcpy(&(pMACHeader->addr2[0]),\r\n&(psEthHeader->h_source[0]),\r\nETH_ALEN);\r\nmemcpy(&(pMACHeader->addr1[0]),\r\n&(pDevice->abyBSSID[0]),\r\nETH_ALEN);\r\npMACHeader->frame_control |= FC_TODS;\r\n}\r\n}\r\nif (bNeedEncrypt)\r\npMACHeader->frame_control |= cpu_to_le16((u16)WLAN_SET_FC_ISWEP(1));\r\npMACHeader->duration_id = cpu_to_le16(wDuration);\r\nif (pDevice->bLongHeader) {\r\nPWLAN_80211HDR_A4 pMACA4Header = (PWLAN_80211HDR_A4) pbyBufferAddr;\r\npMACHeader->frame_control |= (FC_TODS | FC_FROMDS);\r\nmemcpy(pMACA4Header->abyAddr4, pDevice->abyBSSID, WLAN_ADDR_LEN);\r\n}\r\npMACHeader->seq_ctrl = cpu_to_le16(pDevice->wSeqCounter << 4);\r\npMACHeader->seq_ctrl |= cpu_to_le16((u16)uFragIdx);\r\nif ((wFragType == FRAGCTL_ENDFRAG) || (wFragType == FRAGCTL_NONFRAG)) {\r\npDevice->wSeqCounter++;\r\nif (pDevice->wSeqCounter > 0x0fff)\r\npDevice->wSeqCounter = 0;\r\n}\r\nif ((wFragType == FRAGCTL_STAFRAG) || (wFragType == FRAGCTL_MIDFRAG)) {\r\npMACHeader->frame_control |= FC_MOREFRAG;\r\n}\r\n}\r\nCMD_STATUS csMgmt_xmit(struct vnt_private *pDevice,\r\nstruct vnt_tx_mgmt *pPacket)\r\n{\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nPTX_BUFFER pTX_Buffer;\r\nPSTxBufHead pTxBufHead;\r\nPUSB_SEND_CONTEXT pContext;\r\nstruct ieee80211_hdr *pMACHeader;\r\nPSCTS pCTS;\r\nstruct ethhdr sEthHeader;\r\nu8 byPktType, *pbyTxBufferAddr;\r\nvoid *pvRTS, *pvTxDataHd, *pvRrvTime, *pMICHDR;\r\nu32 uDuration, cbReqCount, cbHeaderSize, cbFrameBodySize, cbFrameSize;\r\nint bNeedACK, bIsPSPOLL = false;\r\nu32 cbIVlen = 0, cbICVlen = 0, cbMIClen = 0, cbFCSlen = 4;\r\nu32 uPadding = 0;\r\nu16 wTxBufSize;\r\nu32 cbMacHdLen;\r\nu16 wCurrentRate = RATE_1M;\r\npContext = (PUSB_SEND_CONTEXT)s_vGetFreeContext(pDevice);\r\nif (NULL == pContext) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ManagementSend TX...NO CONTEXT!\n");\r\nreturn CMD_STATUS_RESOURCES;\r\n}\r\npTX_Buffer = (PTX_BUFFER) (&pContext->Data[0]);\r\npbyTxBufferAddr = (u8 *)&(pTX_Buffer->adwTxKey[0]);\r\ncbFrameBodySize = pPacket->cbPayloadLen;\r\npTxBufHead = (PSTxBufHead) pbyTxBufferAddr;\r\nwTxBufSize = sizeof(STxBufHead);\r\nmemset(pTxBufHead, 0, wTxBufSize);\r\nif (pDevice->byBBType == BB_TYPE_11A) {\r\nwCurrentRate = RATE_6M;\r\nbyPktType = PK_TYPE_11A;\r\n} else {\r\nwCurrentRate = RATE_1M;\r\nbyPktType = PK_TYPE_11B;\r\n}\r\nif (pMgmt->eScanState != WMAC_NO_SCANNING) {\r\nRFbSetPower(pDevice, wCurrentRate, pDevice->byCurrentCh);\r\n} else {\r\nRFbSetPower(pDevice, wCurrentRate, pMgmt->uCurrChannel);\r\n}\r\npDevice->wCurrentRate = wCurrentRate;\r\nif (byPktType == PK_TYPE_11A) {\r\npTxBufHead->wFIFOCtl = 0;\r\n}\r\nelse if (byPktType == PK_TYPE_11B) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_11B;\r\n}\r\nelse if (byPktType == PK_TYPE_11GB) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_11GB;\r\n}\r\nelse if (byPktType == PK_TYPE_11GA) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_11GA;\r\n}\r\npTxBufHead->wFIFOCtl |= FIFOCTL_TMOEN;\r\npTxBufHead->wTimeStamp = cpu_to_le16(DEFAULT_MGN_LIFETIME_RES_64us);\r\nif (is_multicast_ether_addr(pPacket->p80211Header->sA3.abyAddr1)) {\r\nbNeedACK = false;\r\n}\r\nelse {\r\nbNeedACK = true;\r\npTxBufHead->wFIFOCtl |= FIFOCTL_NEEDACK;\r\n};\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) ||\r\n(pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) ) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_LRETRY;\r\n}\r\npTxBufHead->wFIFOCtl |= (FIFOCTL_GENINT | FIFOCTL_ISDMA0);\r\nif ((pPacket->p80211Header->sA4.wFrameCtl & TYPE_SUBTYPE_MASK) == TYPE_CTL_PSPOLL) {\r\nbIsPSPOLL = true;\r\ncbMacHdLen = WLAN_HDR_ADDR2_LEN;\r\n} else {\r\ncbMacHdLen = WLAN_HDR_ADDR3_LEN;\r\n}\r\npTxBufHead->wFragCtl |= cpu_to_le16((u16)(cbMacHdLen << 10));\r\npDevice->bAES = false;\r\nif (WLAN_GET_FC_ISWEP(pPacket->p80211Header->sA4.wFrameCtl) != 0) {\r\nif (pDevice->eEncryptionStatus == Ndis802_11Encryption1Enabled) {\r\ncbIVlen = 4;\r\ncbICVlen = 4;\r\npTxBufHead->wFragCtl |= FRAGCTL_LEGACY;\r\n}\r\nelse if (pDevice->eEncryptionStatus == Ndis802_11Encryption2Enabled) {\r\ncbIVlen = 8;\r\ncbMIClen = 8;\r\ncbICVlen = 4;\r\npTxBufHead->wFragCtl |= FRAGCTL_TKIP;\r\n}\r\nelse if (pDevice->eEncryptionStatus == Ndis802_11Encryption3Enabled) {\r\ncbIVlen = 8;\r\ncbICVlen = 8;\r\npTxBufHead->wFragCtl |= FRAGCTL_AES;\r\npDevice->bAES = true;\r\n}\r\nuPadding = 4 - (cbMacHdLen%4);\r\nuPadding %= 4;\r\n}\r\ncbFrameSize = cbMacHdLen + cbFrameBodySize + cbIVlen + cbMIClen + cbICVlen + cbFCSlen;\r\nif (pDevice->bGrpAckPolicy == true) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_GRPACK;\r\n}\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\npvRrvTime = (PSRrvTime_gCTS) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = NULL;\r\npvRTS = NULL;\r\npCTS = (PSCTS) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS));\r\npvTxDataHd = (PSTxDataHead_g) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS) + sizeof(SCTS));\r\ncbHeaderSize = wTxBufSize + sizeof(SRrvTime_gCTS) + sizeof(SCTS) + sizeof(STxDataHead_g);\r\n}\r\nelse {\r\npvRrvTime = (PSRrvTime_ab) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = NULL;\r\npvRTS = NULL;\r\npCTS = NULL;\r\npvTxDataHd = (PSTxDataHead_ab) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab));\r\ncbHeaderSize = wTxBufSize + sizeof(SRrvTime_ab) + sizeof(STxDataHead_ab);\r\n}\r\nmemset((void *)(pbyTxBufferAddr + wTxBufSize), 0,\r\n(cbHeaderSize - wTxBufSize));\r\nmemcpy(&(sEthHeader.h_dest[0]),\r\n&(pPacket->p80211Header->sA3.abyAddr1[0]),\r\nETH_ALEN);\r\nmemcpy(&(sEthHeader.h_source[0]),\r\n&(pPacket->p80211Header->sA3.abyAddr2[0]),\r\nETH_ALEN);\r\npTxBufHead->wFragCtl |= (u16)FRAGCTL_NONFRAG;\r\ns_vGenerateTxParameter(pDevice, byPktType, wCurrentRate, pbyTxBufferAddr, pvRrvTime, pvRTS, pCTS,\r\ncbFrameSize, bNeedACK, TYPE_TXDMA0, &sEthHeader);\r\nuDuration = s_uFillDataHead(pDevice, byPktType, wCurrentRate, pvTxDataHd, cbFrameSize, TYPE_TXDMA0, bNeedACK,\r\n0, 0, 1, AUTO_FB_NONE);\r\npMACHeader = (struct ieee80211_hdr *) (pbyTxBufferAddr + cbHeaderSize);\r\ncbReqCount = cbHeaderSize + cbMacHdLen + uPadding + cbIVlen + cbFrameBodySize;\r\nif (WLAN_GET_FC_ISWEP(pPacket->p80211Header->sA4.wFrameCtl) != 0) {\r\nu8 * pbyIVHead;\r\nu8 * pbyPayloadHead;\r\nu8 * pbyBSSID;\r\nPSKeyItem pTransmitKey = NULL;\r\npbyIVHead = (u8 *)(pbyTxBufferAddr + cbHeaderSize + cbMacHdLen + uPadding);\r\npbyPayloadHead = (u8 *)(pbyTxBufferAddr + cbHeaderSize + cbMacHdLen + uPadding + cbIVlen);\r\ndo {\r\nif ((pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&\r\n(pDevice->bLinkPass == true)) {\r\npbyBSSID = pDevice->abyBSSID;\r\nif (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == false) {\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Get GTK.\n");\r\nbreak;\r\n}\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Get PTK.\n");\r\nbreak;\r\n}\r\n}\r\npbyBSSID = pDevice->abyBroadcastAddr;\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {\r\npTransmitKey = NULL;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"KEY is NULL. OP Mode[%d]\n", pDevice->eOPMode);\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Get GTK.\n");\r\n}\r\n} while(false);\r\ns_vFillTxKey(pDevice, (u8 *)(pTxBufHead->adwTxKey), pbyIVHead, pTransmitKey,\r\n(u8 *)pMACHeader, (u16)cbFrameBodySize, NULL);\r\nmemcpy(pMACHeader, pPacket->p80211Header, cbMacHdLen);\r\nmemcpy(pbyPayloadHead, ((u8 *)(pPacket->p80211Header) + cbMacHdLen),\r\ncbFrameBodySize);\r\n}\r\nelse {\r\nmemcpy(pMACHeader, pPacket->p80211Header, pPacket->cbMPDULen);\r\n}\r\npMACHeader->seq_ctrl = cpu_to_le16(pDevice->wSeqCounter << 4);\r\npDevice->wSeqCounter++ ;\r\nif (pDevice->wSeqCounter > 0x0fff)\r\npDevice->wSeqCounter = 0;\r\nif (bIsPSPOLL) {\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\n((PSTxDataHead_g)pvTxDataHd)->wDuration_a = cpu_to_le16(pPacket->p80211Header->sA2.wDurationID);\r\n((PSTxDataHead_g)pvTxDataHd)->wDuration_b = cpu_to_le16(pPacket->p80211Header->sA2.wDurationID);\r\n} else {\r\n((PSTxDataHead_ab)pvTxDataHd)->wDuration = cpu_to_le16(pPacket->p80211Header->sA2.wDurationID);\r\n}\r\n}\r\npTX_Buffer->wTxByteCount = cpu_to_le16((u16)(cbReqCount));\r\npTX_Buffer->byPKTNO = (u8) (((wCurrentRate<<4) &0x00F0) | ((pDevice->wSeqCounter - 1) & 0x000F));\r\npTX_Buffer->byType = 0x00;\r\npContext->pPacket = NULL;\r\npContext->Type = CONTEXT_MGMT_PACKET;\r\npContext->uBufLen = (u16)cbReqCount + 4;\r\nif (WLAN_GET_FC_TODS(pMACHeader->frame_control) == 0) {\r\ns_vSaveTxPktInfo(pDevice, (u8) (pTX_Buffer->byPKTNO & 0x0F), &(pMACHeader->addr1[0]), (u16)cbFrameSize, pTX_Buffer->wFIFOCtl);\r\n}\r\nelse {\r\ns_vSaveTxPktInfo(pDevice, (u8) (pTX_Buffer->byPKTNO & 0x0F), &(pMACHeader->addr3[0]), (u16)cbFrameSize, pTX_Buffer->wFIFOCtl);\r\n}\r\nPIPEnsSendBulkOut(pDevice,pContext);\r\nreturn CMD_STATUS_PENDING;\r\n}\r\nCMD_STATUS csBeacon_xmit(struct vnt_private *pDevice,\r\nstruct vnt_tx_mgmt *pPacket)\r\n{\r\nu32 cbFrameSize = pPacket->cbMPDULen + WLAN_FCS_LEN;\r\nu32 cbHeaderSize = 0;\r\nu16 wTxBufSize = sizeof(STxShortBufHead);\r\nPSTxShortBufHead pTxBufHead;\r\nstruct ieee80211_hdr *pMACHeader;\r\nPSTxDataHead_ab pTxDataHead;\r\nu16 wCurrentRate;\r\nu32 cbFrameBodySize;\r\nu32 cbReqCount;\r\nPBEACON_BUFFER pTX_Buffer;\r\nu8 *pbyTxBufferAddr;\r\nPUSB_SEND_CONTEXT pContext;\r\nCMD_STATUS status;\r\npContext = (PUSB_SEND_CONTEXT)s_vGetFreeContext(pDevice);\r\nif (NULL == pContext) {\r\nstatus = CMD_STATUS_RESOURCES;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ManagementSend TX...NO CONTEXT!\n");\r\nreturn status ;\r\n}\r\npTX_Buffer = (PBEACON_BUFFER) (&pContext->Data[0]);\r\npbyTxBufferAddr = (u8 *)&(pTX_Buffer->wFIFOCtl);\r\ncbFrameBodySize = pPacket->cbPayloadLen;\r\npTxBufHead = (PSTxShortBufHead) pbyTxBufferAddr;\r\nwTxBufSize = sizeof(STxShortBufHead);\r\nmemset(pTxBufHead, 0, wTxBufSize);\r\nif (pDevice->byBBType == BB_TYPE_11A) {\r\nwCurrentRate = RATE_6M;\r\npTxDataHead = (PSTxDataHead_ab) (pbyTxBufferAddr + wTxBufSize);\r\nBBvCalculateParameter(pDevice, cbFrameSize, wCurrentRate, PK_TYPE_11A,\r\n(u16 *)&(pTxDataHead->wTransmitLength), (u8 *)&(pTxDataHead->byServiceField), (u8 *)&(pTxDataHead->bySignalField)\r\n);\r\npTxDataHead->wDuration = cpu_to_le16((u16)s_uGetDataDuration(pDevice, DATADUR_A, cbFrameSize, PK_TYPE_11A,\r\nwCurrentRate, false, 0, 0, 1, AUTO_FB_NONE));\r\npTxDataHead->wTimeStampOff = wTimeStampOff[pDevice->byPreambleType%2][wCurrentRate%MAX_RATE];\r\ncbHeaderSize = wTxBufSize + sizeof(STxDataHead_ab);\r\n} else {\r\nwCurrentRate = RATE_1M;\r\npTxBufHead->wFIFOCtl |= FIFOCTL_11B;\r\npTxDataHead = (PSTxDataHead_ab) (pbyTxBufferAddr + wTxBufSize);\r\nBBvCalculateParameter(pDevice, cbFrameSize, wCurrentRate, PK_TYPE_11B,\r\n(u16 *)&(pTxDataHead->wTransmitLength), (u8 *)&(pTxDataHead->byServiceField), (u8 *)&(pTxDataHead->bySignalField)\r\n);\r\npTxDataHead->wDuration = cpu_to_le16((u16)s_uGetDataDuration(pDevice, DATADUR_B, cbFrameSize, PK_TYPE_11B,\r\nwCurrentRate, false, 0, 0, 1, AUTO_FB_NONE));\r\npTxDataHead->wTimeStampOff = wTimeStampOff[pDevice->byPreambleType%2][wCurrentRate%MAX_RATE];\r\ncbHeaderSize = wTxBufSize + sizeof(STxDataHead_ab);\r\n}\r\npMACHeader = (struct ieee80211_hdr *)(pbyTxBufferAddr + cbHeaderSize);\r\nmemcpy(pMACHeader, pPacket->p80211Header, pPacket->cbMPDULen);\r\npMACHeader->duration_id = 0;\r\npMACHeader->seq_ctrl = cpu_to_le16(pDevice->wSeqCounter << 4);\r\npDevice->wSeqCounter++ ;\r\nif (pDevice->wSeqCounter > 0x0fff)\r\npDevice->wSeqCounter = 0;\r\ncbReqCount = cbHeaderSize + WLAN_HDR_ADDR3_LEN + cbFrameBodySize;\r\npTX_Buffer->wTxByteCount = (u16)cbReqCount;\r\npTX_Buffer->byPKTNO = (u8) (((wCurrentRate<<4) &0x00F0) | ((pDevice->wSeqCounter - 1) & 0x000F));\r\npTX_Buffer->byType = 0x01;\r\npContext->pPacket = NULL;\r\npContext->Type = CONTEXT_MGMT_PACKET;\r\npContext->uBufLen = (u16)cbReqCount + 4;\r\nPIPEnsSendBulkOut(pDevice,pContext);\r\nreturn CMD_STATUS_PENDING;\r\n}\r\nvoid vDMA0_tx_80211(struct vnt_private *pDevice, struct sk_buff *skb)\r\n{\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nu8 byPktType;\r\nu8 *pbyTxBufferAddr;\r\nvoid *pvRTS, *pvCTS, *pvTxDataHd;\r\nu32 uDuration, cbReqCount;\r\nstruct ieee80211_hdr *pMACHeader;\r\nu32 cbHeaderSize, cbFrameBodySize;\r\nint bNeedACK, bIsPSPOLL = false;\r\nPSTxBufHead pTxBufHead;\r\nu32 cbFrameSize;\r\nu32 cbIVlen = 0, cbICVlen = 0, cbMIClen = 0, cbFCSlen = 4;\r\nu32 uPadding = 0;\r\nu32 cbMICHDR = 0, uLength = 0;\r\nu32 dwMICKey0, dwMICKey1;\r\nu32 dwMIC_Priority;\r\nu32 *pdwMIC_L, *pdwMIC_R;\r\nu16 wTxBufSize;\r\nu32 cbMacHdLen;\r\nstruct ethhdr sEthHeader;\r\nvoid *pvRrvTime, *pMICHDR;\r\nu32 wCurrentRate = RATE_1M;\r\nPUWLAN_80211HDR p80211Header;\r\nu32 uNodeIndex = 0;\r\nint bNodeExist = false;\r\nSKeyItem STempKey;\r\nPSKeyItem pTransmitKey = NULL;\r\nu8 *pbyIVHead, *pbyPayloadHead, *pbyMacHdr;\r\nu32 cbExtSuppRate = 0;\r\nPTX_BUFFER pTX_Buffer;\r\nPUSB_SEND_CONTEXT pContext;\r\npvRrvTime = pMICHDR = pvRTS = pvCTS = pvTxDataHd = NULL;\r\nif(skb->len <= WLAN_HDR_ADDR3_LEN) {\r\ncbFrameBodySize = 0;\r\n}\r\nelse {\r\ncbFrameBodySize = skb->len - WLAN_HDR_ADDR3_LEN;\r\n}\r\np80211Header = (PUWLAN_80211HDR)skb->data;\r\npContext = (PUSB_SEND_CONTEXT)s_vGetFreeContext(pDevice);\r\nif (NULL == pContext) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"DMA0 TX...NO CONTEXT!\n");\r\ndev_kfree_skb_irq(skb);\r\nreturn ;\r\n}\r\npTX_Buffer = (PTX_BUFFER)(&pContext->Data[0]);\r\npbyTxBufferAddr = (u8 *)(&pTX_Buffer->adwTxKey[0]);\r\npTxBufHead = (PSTxBufHead) pbyTxBufferAddr;\r\nwTxBufSize = sizeof(STxBufHead);\r\nmemset(pTxBufHead, 0, wTxBufSize);\r\nif (pDevice->byBBType == BB_TYPE_11A) {\r\nwCurrentRate = RATE_6M;\r\nbyPktType = PK_TYPE_11A;\r\n} else {\r\nwCurrentRate = RATE_1M;\r\nbyPktType = PK_TYPE_11B;\r\n}\r\nif (pMgmt->eScanState != WMAC_NO_SCANNING) {\r\nRFbSetPower(pDevice, wCurrentRate, pDevice->byCurrentCh);\r\n} else {\r\nRFbSetPower(pDevice, wCurrentRate, pMgmt->uCurrChannel);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"vDMA0_tx_80211: p80211Header->sA3.wFrameCtl = %x \n", p80211Header->sA3.wFrameCtl);\r\nif (byPktType == PK_TYPE_11A) {\r\npTxBufHead->wFIFOCtl = 0;\r\n}\r\nelse if (byPktType == PK_TYPE_11B) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_11B;\r\n}\r\nelse if (byPktType == PK_TYPE_11GB) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_11GB;\r\n}\r\nelse if (byPktType == PK_TYPE_11GA) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_11GA;\r\n}\r\npTxBufHead->wFIFOCtl |= FIFOCTL_TMOEN;\r\npTxBufHead->wTimeStamp = cpu_to_le16(DEFAULT_MGN_LIFETIME_RES_64us);\r\nif (is_multicast_ether_addr(p80211Header->sA3.abyAddr1)) {\r\nbNeedACK = false;\r\nif (pDevice->bEnableHostWEP) {\r\nuNodeIndex = 0;\r\nbNodeExist = true;\r\n}\r\n}\r\nelse {\r\nif (pDevice->bEnableHostWEP) {\r\nif (BSSbIsSTAInNodeDB(pDevice, (u8 *)(p80211Header->sA3.abyAddr1), &uNodeIndex))\r\nbNodeExist = true;\r\n}\r\nbNeedACK = true;\r\npTxBufHead->wFIFOCtl |= FIFOCTL_NEEDACK;\r\n};\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) ||\r\n(pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) ) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_LRETRY;\r\n}\r\npTxBufHead->wFIFOCtl |= (FIFOCTL_GENINT | FIFOCTL_ISDMA0);\r\nif ((p80211Header->sA4.wFrameCtl & TYPE_SUBTYPE_MASK) == TYPE_CTL_PSPOLL) {\r\nbIsPSPOLL = true;\r\ncbMacHdLen = WLAN_HDR_ADDR2_LEN;\r\n} else {\r\ncbMacHdLen = WLAN_HDR_ADDR3_LEN;\r\n}\r\nif (WLAN_GET_FC_FSTYPE(p80211Header->sA4.wFrameCtl) == WLAN_FSTYPE_ASSOCRESP) {\r\nif (((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrSuppRates)->len != 0) {\r\ncbExtSuppRate += ((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrSuppRates)->len + WLAN_IEHDR_LEN;\r\n}\r\nif (((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrExtSuppRates)->len != 0) {\r\ncbExtSuppRate += ((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrExtSuppRates)->len + WLAN_IEHDR_LEN;\r\n}\r\nif (cbExtSuppRate >0) {\r\ncbFrameBodySize = WLAN_ASSOCRESP_OFF_SUPP_RATES;\r\n}\r\n}\r\npTxBufHead->wFragCtl |= cpu_to_le16((u16)cbMacHdLen << 10);\r\npDevice->bAES = false;\r\nif (WLAN_GET_FC_ISWEP(p80211Header->sA4.wFrameCtl) != 0) {\r\nif (pDevice->eEncryptionStatus == Ndis802_11Encryption1Enabled) {\r\ncbIVlen = 4;\r\ncbICVlen = 4;\r\npTxBufHead->wFragCtl |= FRAGCTL_LEGACY;\r\n}\r\nelse if (pDevice->eEncryptionStatus == Ndis802_11Encryption2Enabled) {\r\ncbIVlen = 8;\r\ncbMIClen = 8;\r\ncbICVlen = 4;\r\npTxBufHead->wFragCtl |= FRAGCTL_TKIP;\r\n}\r\nelse if (pDevice->eEncryptionStatus == Ndis802_11Encryption3Enabled) {\r\ncbIVlen = 8;\r\ncbICVlen = 8;\r\ncbMICHDR = sizeof(SMICHDRHead);\r\npTxBufHead->wFragCtl |= FRAGCTL_AES;\r\npDevice->bAES = true;\r\n}\r\nuPadding = 4 - (cbMacHdLen%4);\r\nuPadding %= 4;\r\n}\r\ncbFrameSize = cbMacHdLen + cbFrameBodySize + cbIVlen + cbMIClen + cbICVlen + cbFCSlen + cbExtSuppRate;\r\nif (pDevice->bGrpAckPolicy == true) {\r\npTxBufHead->wFIFOCtl |= FIFOCTL_GRPACK;\r\n}\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\npvRrvTime = (PSRrvTime_gCTS) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS));\r\npvRTS = NULL;\r\npvCTS = (PSCTS) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR);\r\npvTxDataHd = (PSTxDataHead_g) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR + sizeof(SCTS));\r\ncbHeaderSize = wTxBufSize + sizeof(SRrvTime_gCTS) + cbMICHDR + sizeof(SCTS) + sizeof(STxDataHead_g);\r\n}\r\nelse {\r\npvRrvTime = (PSRrvTime_ab) (pbyTxBufferAddr + wTxBufSize);\r\npMICHDR = (PSMICHDRHead) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab));\r\npvRTS = NULL;\r\npvCTS = NULL;\r\npvTxDataHd = (PSTxDataHead_ab) (pbyTxBufferAddr + wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR);\r\ncbHeaderSize = wTxBufSize + sizeof(SRrvTime_ab) + cbMICHDR + sizeof(STxDataHead_ab);\r\n}\r\nmemset((void *)(pbyTxBufferAddr + wTxBufSize), 0,\r\n(cbHeaderSize - wTxBufSize));\r\nmemcpy(&(sEthHeader.h_dest[0]),\r\n&(p80211Header->sA3.abyAddr1[0]),\r\nETH_ALEN);\r\nmemcpy(&(sEthHeader.h_source[0]),\r\n&(p80211Header->sA3.abyAddr2[0]),\r\nETH_ALEN);\r\npTxBufHead->wFragCtl |= (u16)FRAGCTL_NONFRAG;\r\ns_vGenerateTxParameter(pDevice, byPktType, wCurrentRate, pbyTxBufferAddr, pvRrvTime, pvRTS, pvCTS,\r\ncbFrameSize, bNeedACK, TYPE_TXDMA0, &sEthHeader);\r\nuDuration = s_uFillDataHead(pDevice, byPktType, wCurrentRate, pvTxDataHd, cbFrameSize, TYPE_TXDMA0, bNeedACK,\r\n0, 0, 1, AUTO_FB_NONE);\r\npMACHeader = (struct ieee80211_hdr *) (pbyTxBufferAddr + cbHeaderSize);\r\ncbReqCount = cbHeaderSize + cbMacHdLen + uPadding + cbIVlen + (cbFrameBodySize + cbMIClen) + cbExtSuppRate;\r\npbyMacHdr = (u8 *)(pbyTxBufferAddr + cbHeaderSize);\r\npbyPayloadHead = (u8 *)(pbyMacHdr + cbMacHdLen + uPadding + cbIVlen);\r\npbyIVHead = (u8 *)(pbyMacHdr + cbMacHdLen + uPadding);\r\nmemcpy(pbyMacHdr, skb->data, cbMacHdLen);\r\npMACHeader->frame_control &= cpu_to_le16(0xfffc);\r\nmemcpy(pbyPayloadHead, (skb->data + cbMacHdLen), cbFrameBodySize);\r\nif (WLAN_GET_FC_FSTYPE(p80211Header->sA4.wFrameCtl) == WLAN_FSTYPE_ASSOCRESP) {\r\nif (cbExtSuppRate != 0) {\r\nif (((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrSuppRates)->len != 0)\r\nmemcpy((pbyPayloadHead + cbFrameBodySize),\r\npMgmt->abyCurrSuppRates,\r\n((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrSuppRates)->len + WLAN_IEHDR_LEN\r\n);\r\nif (((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrExtSuppRates)->len != 0)\r\nmemcpy((pbyPayloadHead + cbFrameBodySize) + ((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrSuppRates)->len + WLAN_IEHDR_LEN,\r\npMgmt->abyCurrExtSuppRates,\r\n((PWLAN_IE_SUPP_RATES)pMgmt->abyCurrExtSuppRates)->len + WLAN_IEHDR_LEN\r\n);\r\n}\r\n}\r\nif (WLAN_GET_FC_ISWEP(p80211Header->sA4.wFrameCtl) != 0) {\r\nif (pDevice->bEnableHostWEP) {\r\npTransmitKey = &STempKey;\r\npTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;\r\npTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;\r\npTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;\r\npTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;\r\npTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;\r\nmemcpy(pTransmitKey->abyKey,\r\n&pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],\r\npTransmitKey->uKeyLength\r\n);\r\n}\r\nif ((pTransmitKey != NULL) && (pTransmitKey->byCipherSuite == KEY_CTL_TKIP)) {\r\ndwMICKey0 = *(u32 *)(&pTransmitKey->abyKey[16]);\r\ndwMICKey1 = *(u32 *)(&pTransmitKey->abyKey[20]);\r\nMIC_vInit(dwMICKey0, dwMICKey1);\r\nMIC_vAppend((u8 *)&(sEthHeader.h_dest[0]), 12);\r\ndwMIC_Priority = 0;\r\nMIC_vAppend((u8 *)&dwMIC_Priority, 4);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"DMA0_tx_8021:MIC KEY:"\\r\n" %X, %X\n", dwMICKey0, dwMICKey1);\r\nuLength = cbHeaderSize + cbMacHdLen + uPadding + cbIVlen;\r\nMIC_vAppend((pbyTxBufferAddr + uLength), cbFrameBodySize);\r\npdwMIC_L = (u32 *)(pbyTxBufferAddr + uLength + cbFrameBodySize);\r\npdwMIC_R = (u32 *)(pbyTxBufferAddr + uLength + cbFrameBodySize + 4);\r\nMIC_vGetMIC(pdwMIC_L, pdwMIC_R);\r\nMIC_vUnInit();\r\nif (pDevice->bTxMICFail == true) {\r\n*pdwMIC_L = 0;\r\n*pdwMIC_R = 0;\r\npDevice->bTxMICFail = false;\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"uLength: %d, %d\n", uLength, cbFrameBodySize);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"cbReqCount:%d, %d, %d, %d\n", cbReqCount, cbHeaderSize, uPadding, cbIVlen);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC:%x, %x\n",\r\n*pdwMIC_L, *pdwMIC_R);\r\n}\r\ns_vFillTxKey(pDevice, (u8 *)(pTxBufHead->adwTxKey), pbyIVHead, pTransmitKey,\r\npbyMacHdr, (u16)cbFrameBodySize, (u8 *)pMICHDR);\r\nif (pDevice->bEnableHostWEP) {\r\npMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16 = pTransmitKey->dwTSC47_16;\r\npMgmt->sNodeDBTable[uNodeIndex].wTSC15_0 = pTransmitKey->wTSC15_0;\r\n}\r\nif ((pDevice->byLocalID <= REV_ID_VT3253_A1)) {\r\ns_vSWencryption(pDevice, pTransmitKey, pbyPayloadHead, (u16)(cbFrameBodySize + cbMIClen));\r\n}\r\n}\r\npMACHeader->seq_ctrl = cpu_to_le16(pDevice->wSeqCounter << 4);\r\npDevice->wSeqCounter++ ;\r\nif (pDevice->wSeqCounter > 0x0fff)\r\npDevice->wSeqCounter = 0;\r\nif (bIsPSPOLL) {\r\nif (byPktType == PK_TYPE_11GB || byPktType == PK_TYPE_11GA) {\r\n((PSTxDataHead_g)pvTxDataHd)->wDuration_a = cpu_to_le16(p80211Header->sA2.wDurationID);\r\n((PSTxDataHead_g)pvTxDataHd)->wDuration_b = cpu_to_le16(p80211Header->sA2.wDurationID);\r\n} else {\r\n((PSTxDataHead_ab)pvTxDataHd)->wDuration = cpu_to_le16(p80211Header->sA2.wDurationID);\r\n}\r\n}\r\npTX_Buffer->wTxByteCount = cpu_to_le16((u16)(cbReqCount));\r\npTX_Buffer->byPKTNO = (u8) (((wCurrentRate<<4) &0x00F0) | ((pDevice->wSeqCounter - 1) & 0x000F));\r\npTX_Buffer->byType = 0x00;\r\npContext->pPacket = skb;\r\npContext->Type = CONTEXT_MGMT_PACKET;\r\npContext->uBufLen = (u16)cbReqCount + 4;\r\nif (WLAN_GET_FC_TODS(pMACHeader->frame_control) == 0) {\r\ns_vSaveTxPktInfo(pDevice, (u8) (pTX_Buffer->byPKTNO & 0x0F), &(pMACHeader->addr1[0]), (u16)cbFrameSize, pTX_Buffer->wFIFOCtl);\r\n}\r\nelse {\r\ns_vSaveTxPktInfo(pDevice, (u8) (pTX_Buffer->byPKTNO & 0x0F), &(pMACHeader->addr3[0]), (u16)cbFrameSize, pTX_Buffer->wFIFOCtl);\r\n}\r\nPIPEnsSendBulkOut(pDevice,pContext);\r\nreturn ;\r\n}\r\nint nsDMA_tx_packet(struct vnt_private *pDevice,\r\nu32 uDMAIdx, struct sk_buff *skb)\r\n{\r\nstruct net_device_stats *pStats = &pDevice->stats;\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nu32 BytesToWrite = 0, uHeaderLen = 0;\r\nu32 uNodeIndex = 0;\r\nu8 byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};\r\nu16 wAID;\r\nu8 byPktType;\r\nint bNeedEncryption = false;\r\nPSKeyItem pTransmitKey = NULL;\r\nSKeyItem STempKey;\r\nint ii;\r\nint bTKIP_UseGTK = false;\r\nint bNeedDeAuth = false;\r\nu8 *pbyBSSID;\r\nint bNodeExist = false;\r\nPUSB_SEND_CONTEXT pContext;\r\nbool fConvertedPacket;\r\nPTX_BUFFER pTX_Buffer;\r\nu32 status;\r\nu16 wKeepRate = pDevice->wCurrentRate;\r\nint bTxeapol_key = false;\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif (pDevice->uAssocCount == 0) {\r\ndev_kfree_skb_irq(skb);\r\nreturn 0;\r\n}\r\nif (is_multicast_ether_addr((u8 *)(skb->data))) {\r\nuNodeIndex = 0;\r\nbNodeExist = true;\r\nif (pMgmt->sNodeDBTable[0].bPSEnable) {\r\nskb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skb);\r\npMgmt->sNodeDBTable[0].wEnQueueCnt++;\r\npMgmt->abyPSTxMap[0] |= byMask[0];\r\nreturn 0;\r\n}\r\nif (pDevice->byBBType != BB_TYPE_11A)\r\npDevice->wCurrentRate = RATE_2M;\r\nelse\r\npDevice->wCurrentRate = RATE_24M;\r\npDevice->byPreambleType = PREAMBLE_SHORT;\r\n}else {\r\nif (BSSbIsSTAInNodeDB(pDevice, (u8 *)(skb->data), &uNodeIndex)) {\r\nif (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {\r\nskb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);\r\npMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;\r\nwAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;\r\npMgmt->abyPSTxMap[wAID >> 3] |= byMask[wAID & 7];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set:pMgmt->abyPSTxMap[%d]= %d\n",\r\n(wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);\r\nreturn 0;\r\n}\r\npDevice->wCurrentRate = pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;\r\nif (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {\r\npDevice->byPreambleType = pDevice->byShortPreamble;\r\n}else {\r\npDevice->byPreambleType = PREAMBLE_LONG;\r\n}\r\nbNodeExist = true;\r\n}\r\n}\r\nif (bNodeExist == false) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Unknown STA not found in node DB \n");\r\ndev_kfree_skb_irq(skb);\r\nreturn 0;\r\n}\r\n}\r\npContext = (PUSB_SEND_CONTEXT)s_vGetFreeContext(pDevice);\r\nif (pContext == NULL) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG" pContext == NULL\n");\r\ndev_kfree_skb_irq(skb);\r\nreturn STATUS_RESOURCES;\r\n}\r\nmemcpy(pDevice->sTxEthHeader.h_dest, (u8 *)(skb->data), ETH_HLEN);\r\n{\r\nu8 Protocol_Version;\r\nu8 Packet_Type;\r\nu8 Descriptor_type;\r\nu16 Key_info;\r\nProtocol_Version = skb->data[ETH_HLEN];\r\nPacket_Type = skb->data[ETH_HLEN+1];\r\nDescriptor_type = skb->data[ETH_HLEN+1+1+2];\r\nKey_info = (skb->data[ETH_HLEN+1+1+2+1] << 8)|(skb->data[ETH_HLEN+1+1+2+2]);\r\nif (pDevice->sTxEthHeader.h_proto == cpu_to_be16(ETH_P_PAE)) {\r\nif (((Protocol_Version == 1) || (Protocol_Version == 2)) &&\r\n(Packet_Type == 3)) {\r\nbTxeapol_key = true;\r\nif(!(Key_info & BIT3) &&\r\n(Key_info & BIT8) && (Key_info & BIT9)) {\r\nif(Descriptor_type==254) {\r\npDevice->fWPA_Authened = true;\r\nPRINT_K("WPA ");\r\n}\r\nelse {\r\npDevice->fWPA_Authened = true;\r\nPRINT_K("WPA2(re-keying) ");\r\n}\r\nPRINT_K("Authentication completed!!\n");\r\n}\r\nelse if((Key_info & BIT3) && (Descriptor_type==2) &&\r\n(Key_info & BIT8) && (Key_info & BIT9)) {\r\npDevice->fWPA_Authened = true;\r\nPRINT_K("WPA2 Authentication completed!!\n");\r\n}\r\n}\r\n}\r\n}\r\nif (pDevice->bEncryptionEnable == true) {\r\nbNeedEncryption = true;\r\ndo {\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&\r\n(pMgmt->eCurrState == WMAC_STATE_ASSOC)) {\r\npbyBSSID = pDevice->abyBSSID;\r\nif (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == false) {\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {\r\nbTKIP_UseGTK = true;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");\r\nbreak;\r\n}\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get PTK.\n");\r\nbreak;\r\n}\r\n}else if (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {\r\npbyBSSID = pDevice->sTxEthHeader.h_dest;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS Serach Key: \n");\r\nfor (ii = 0; ii< 6; ii++)\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"%x \n", *(pbyBSSID+ii));\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"\n");\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == true)\r\nbreak;\r\n}\r\npbyBSSID = pDevice->abyBroadcastAddr;\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {\r\npTransmitKey = NULL;\r\nif (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS and KEY is NULL. [%d]\n", pMgmt->eCurrMode);\r\n}\r\nelse\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"NOT IBSS and KEY is NULL. [%d]\n", pMgmt->eCurrMode);\r\n} else {\r\nbTKIP_UseGTK = true;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");\r\n}\r\n} while(false);\r\n}\r\nif (pDevice->bEnableHostWEP) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"acdma0: STA index %d\n", uNodeIndex);\r\nif (pDevice->bEncryptionEnable == true) {\r\npTransmitKey = &STempKey;\r\npTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;\r\npTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;\r\npTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;\r\npTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;\r\npTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;\r\nmemcpy(pTransmitKey->abyKey,\r\n&pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],\r\npTransmitKey->uKeyLength\r\n);\r\n}\r\n}\r\nbyPktType = (u8)pDevice->byPacketType;\r\nif (pDevice->bFixRate) {\r\nif (pDevice->byBBType == BB_TYPE_11B) {\r\nif (pDevice->uConnectionRate >= RATE_11M) {\r\npDevice->wCurrentRate = RATE_11M;\r\n} else {\r\npDevice->wCurrentRate = (u16)pDevice->uConnectionRate;\r\n}\r\n} else {\r\nif ((pDevice->byBBType == BB_TYPE_11A) &&\r\n(pDevice->uConnectionRate <= RATE_6M)) {\r\npDevice->wCurrentRate = RATE_6M;\r\n} else {\r\nif (pDevice->uConnectionRate >= RATE_54M)\r\npDevice->wCurrentRate = RATE_54M;\r\nelse\r\npDevice->wCurrentRate = (u16)pDevice->uConnectionRate;\r\n}\r\n}\r\n}\r\nelse {\r\nif (pDevice->eOPMode == OP_MODE_ADHOC) {\r\nif (is_multicast_ether_addr(pDevice->sTxEthHeader.h_dest)) {\r\npDevice->wCurrentRate = pMgmt->sNodeDBTable[0].wTxDataRate;\r\npDevice->byPreambleType = pDevice->byShortPreamble;\r\n}\r\nelse {\r\nif (BSSbIsSTAInNodeDB(pDevice, &(pDevice->sTxEthHeader.h_dest[0]), &uNodeIndex)) {\r\npDevice->wCurrentRate = pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;\r\nif (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {\r\npDevice->byPreambleType = pDevice->byShortPreamble;\r\n}\r\nelse {\r\npDevice->byPreambleType = PREAMBLE_LONG;\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Found Node Index is [%d] Tx Data Rate:[%d]\n",uNodeIndex, pDevice->wCurrentRate);\r\n}\r\nelse {\r\nif (pDevice->byBBType != BB_TYPE_11A)\r\npDevice->wCurrentRate = RATE_2M;\r\nelse\r\npDevice->wCurrentRate = RATE_24M;\r\npDevice->byPreambleType = PREAMBLE_SHORT;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Not Found Node use highest basic Rate.....\n");\r\n}\r\n}\r\n}\r\nif (pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) {\r\npDevice->wCurrentRate = pMgmt->sNodeDBTable[0].wTxDataRate;\r\n}\r\n}\r\nif (pDevice->sTxEthHeader.h_proto == cpu_to_be16(ETH_P_PAE)) {\r\nif (pDevice->byBBType != BB_TYPE_11A) {\r\npDevice->wCurrentRate = RATE_1M;\r\npDevice->byACKRate = RATE_1M;\r\npDevice->byTopCCKBasicRate = RATE_1M;\r\npDevice->byTopOFDMBasicRate = RATE_6M;\r\n} else {\r\npDevice->wCurrentRate = RATE_6M;\r\npDevice->byACKRate = RATE_6M;\r\npDevice->byTopCCKBasicRate = RATE_1M;\r\npDevice->byTopOFDMBasicRate = RATE_6M;\r\n}\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG,\r\nKERN_INFO "dma_tx: pDevice->wCurrentRate = %d\n",\r\npDevice->wCurrentRate);\r\nif (wKeepRate != pDevice->wCurrentRate) {\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_SETPOWER, NULL);\r\n}\r\nif (pDevice->wCurrentRate <= RATE_11M) {\r\nbyPktType = PK_TYPE_11B;\r\n}\r\nif (bNeedEncryption == true) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.h_proto));\r\nif ((pDevice->sTxEthHeader.h_proto) == cpu_to_be16(ETH_P_PAE)) {\r\nbNeedEncryption = false;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Pkt Type=%04x\n", (pDevice->sTxEthHeader.h_proto));\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_ASSOC)) {\r\nif (pTransmitKey == NULL) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Don't Find TX KEY\n");\r\n}\r\nelse {\r\nif (bTKIP_UseGTK == true) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"error: KEY is GTK!!~~\n");\r\n}\r\nelse {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%X]\n",\r\npTransmitKey->dwKeyIndex);\r\nbNeedEncryption = true;\r\n}\r\n}\r\n}\r\nif (pDevice->bEnableHostWEP) {\r\nif ((uNodeIndex != 0) &&\r\n(pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%X]\n",\r\npTransmitKey->dwKeyIndex);\r\nbNeedEncryption = true;\r\n}\r\n}\r\n}\r\nelse {\r\nif (pTransmitKey == NULL) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"return no tx key\n");\r\npContext->bBoolInUse = false;\r\ndev_kfree_skb_irq(skb);\r\npStats->tx_dropped++;\r\nreturn STATUS_FAILURE;\r\n}\r\n}\r\n}\r\nfConvertedPacket = s_bPacketToWirelessUsb(pDevice, byPktType,\r\n(u8 *)(&pContext->Data[0]), bNeedEncryption,\r\nskb->len, uDMAIdx, &pDevice->sTxEthHeader,\r\n(u8 *)skb->data, pTransmitKey, uNodeIndex,\r\npDevice->wCurrentRate,\r\n&uHeaderLen, &BytesToWrite\r\n);\r\nif (fConvertedPacket == false) {\r\npContext->bBoolInUse = false;\r\ndev_kfree_skb_irq(skb);\r\nreturn STATUS_FAILURE;\r\n}\r\nif ( pDevice->bEnablePSMode == true ) {\r\nif ( !pDevice->bPSModeTxBurst ) {\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_MAC_DISPOWERSAVING,\r\nNULL);\r\npDevice->bPSModeTxBurst = true;\r\n}\r\n}\r\npTX_Buffer = (PTX_BUFFER)&(pContext->Data[0]);\r\npTX_Buffer->byPKTNO = (u8) (((pDevice->wCurrentRate<<4) &0x00F0) | ((pDevice->wSeqCounter - 1) & 0x000F));\r\npTX_Buffer->wTxByteCount = (u16)BytesToWrite;\r\npContext->pPacket = skb;\r\npContext->Type = CONTEXT_DATA_PACKET;\r\npContext->uBufLen = (u16)BytesToWrite + 4 ;\r\ns_vSaveTxPktInfo(pDevice, (u8) (pTX_Buffer->byPKTNO & 0x0F), &(pContext->sEthHeader.h_dest[0]), (u16) (BytesToWrite-uHeaderLen), pTX_Buffer->wFIFOCtl);\r\nstatus = PIPEnsSendBulkOut(pDevice,pContext);\r\nif (bNeedDeAuth == true) {\r\nu16 wReason = WLAN_MGMT_REASON_MIC_FAILURE;\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_DEAUTH, (u8 *) &wReason);\r\n}\r\nif(status!=STATUS_PENDING) {\r\npContext->bBoolInUse = false;\r\ndev_kfree_skb_irq(skb);\r\nreturn STATUS_FAILURE;\r\n}\r\nelse\r\nreturn 0;\r\n}\r\nint bRelayPacketSend(struct vnt_private *pDevice, u8 *pbySkbData, u32 uDataLen,\r\nu32 uNodeIndex)\r\n{\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nu32 BytesToWrite = 0, uHeaderLen = 0;\r\nu8 byPktType = PK_TYPE_11B;\r\nint bNeedEncryption = false;\r\nSKeyItem STempKey;\r\nPSKeyItem pTransmitKey = NULL;\r\nu8 *pbyBSSID;\r\nPUSB_SEND_CONTEXT pContext;\r\nu8 byPktTyp;\r\nint fConvertedPacket;\r\nPTX_BUFFER pTX_Buffer;\r\nu32 status;\r\nu16 wKeepRate = pDevice->wCurrentRate;\r\npContext = (PUSB_SEND_CONTEXT)s_vGetFreeContext(pDevice);\r\nif (NULL == pContext) {\r\nreturn false;\r\n}\r\nmemcpy(pDevice->sTxEthHeader.h_dest, (u8 *)pbySkbData, ETH_HLEN);\r\nif (pDevice->bEncryptionEnable == true) {\r\nbNeedEncryption = true;\r\npbyBSSID = pDevice->abyBroadcastAddr;\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {\r\npTransmitKey = NULL;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"KEY is NULL. [%d]\n", pMgmt->eCurrMode);\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");\r\n}\r\n}\r\nif (pDevice->bEnableHostWEP) {\r\nif (uNodeIndex < MAX_NODE_NUM + 1) {\r\npTransmitKey = &STempKey;\r\npTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;\r\npTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;\r\npTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;\r\npTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;\r\npTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;\r\nmemcpy(pTransmitKey->abyKey,\r\n&pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],\r\npTransmitKey->uKeyLength\r\n);\r\n}\r\n}\r\nif ( bNeedEncryption && (pTransmitKey == NULL) ) {\r\npContext->bBoolInUse = false;\r\nreturn false;\r\n}\r\nbyPktTyp = (u8)pDevice->byPacketType;\r\nif (pDevice->bFixRate) {\r\nif (pDevice->byBBType == BB_TYPE_11B) {\r\nif (pDevice->uConnectionRate >= RATE_11M) {\r\npDevice->wCurrentRate = RATE_11M;\r\n} else {\r\npDevice->wCurrentRate = (u16)pDevice->uConnectionRate;\r\n}\r\n} else {\r\nif ((pDevice->byBBType == BB_TYPE_11A) &&\r\n(pDevice->uConnectionRate <= RATE_6M)) {\r\npDevice->wCurrentRate = RATE_6M;\r\n} else {\r\nif (pDevice->uConnectionRate >= RATE_54M)\r\npDevice->wCurrentRate = RATE_54M;\r\nelse\r\npDevice->wCurrentRate = (u16)pDevice->uConnectionRate;\r\n}\r\n}\r\n}\r\nelse {\r\npDevice->wCurrentRate = pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;\r\n}\r\nif (wKeepRate != pDevice->wCurrentRate) {\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_SETPOWER, NULL);\r\n}\r\nif (pDevice->wCurrentRate <= RATE_11M)\r\nbyPktType = PK_TYPE_11B;\r\nBytesToWrite = uDataLen + ETH_FCS_LEN;\r\nfConvertedPacket = s_bPacketToWirelessUsb(pDevice, byPktType,\r\n(u8 *)(&pContext->Data[0]), bNeedEncryption,\r\nuDataLen, TYPE_AC0DMA, &pDevice->sTxEthHeader,\r\npbySkbData, pTransmitKey, uNodeIndex,\r\npDevice->wCurrentRate,\r\n&uHeaderLen, &BytesToWrite\r\n);\r\nif (fConvertedPacket == false) {\r\npContext->bBoolInUse = false;\r\nreturn false;\r\n}\r\npTX_Buffer = (PTX_BUFFER)&(pContext->Data[0]);\r\npTX_Buffer->byPKTNO = (u8) (((pDevice->wCurrentRate<<4) &0x00F0) | ((pDevice->wSeqCounter - 1) & 0x000F));\r\npTX_Buffer->wTxByteCount = (u16)BytesToWrite;\r\npContext->pPacket = NULL;\r\npContext->Type = CONTEXT_DATA_PACKET;\r\npContext->uBufLen = (u16)BytesToWrite + 4 ;\r\ns_vSaveTxPktInfo(pDevice, (u8) (pTX_Buffer->byPKTNO & 0x0F), &(pContext->sEthHeader.h_dest[0]), (u16) (BytesToWrite-uHeaderLen), pTX_Buffer->wFIFOCtl);\r\nstatus = PIPEnsSendBulkOut(pDevice,pContext);\r\nreturn true;\r\n}
