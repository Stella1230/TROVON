static int as3711_list_voltage_sd(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nif (selector >= rdev->desc->n_voltages)\r\nreturn -EINVAL;\r\nif (!selector)\r\nreturn 0;\r\nif (selector < 0x41)\r\nreturn 600000 + selector * 12500;\r\nif (selector < 0x71)\r\nreturn 1400000 + (selector - 0x40) * 25000;\r\nreturn 2600000 + (selector - 0x70) * 50000;\r\n}\r\nstatic int as3711_list_voltage_aldo(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nif (selector >= rdev->desc->n_voltages)\r\nreturn -EINVAL;\r\nif (selector < 0x10)\r\nreturn 1200000 + selector * 50000;\r\nreturn 1800000 + (selector - 0x10) * 100000;\r\n}\r\nstatic int as3711_list_voltage_dldo(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nif (selector >= rdev->desc->n_voltages ||\r\n(selector > 0x10 && selector < 0x20))\r\nreturn -EINVAL;\r\nif (selector < 0x11)\r\nreturn 900000 + selector * 50000;\r\nreturn 1750000 + (selector - 0x20) * 50000;\r\n}\r\nstatic int as3711_bound_check(struct regulator_dev *rdev,\r\nint *min_uV, int *max_uV)\r\n{\r\nstruct as3711_regulator *reg = rdev_get_drvdata(rdev);\r\nstruct as3711_regulator_info *info = reg->reg_info;\r\ndev_dbg(&rdev->dev, "%s(), %d, %d, %d\n", __func__,\r\n*min_uV, rdev->desc->min_uV, info->max_uV);\r\nif (*max_uV < *min_uV ||\r\n*min_uV > info->max_uV || rdev->desc->min_uV > *max_uV)\r\nreturn -EINVAL;\r\nif (rdev->desc->n_voltages == 1)\r\nreturn 0;\r\nif (*max_uV > info->max_uV)\r\n*max_uV = info->max_uV;\r\nif (*min_uV < rdev->desc->min_uV)\r\n*min_uV = rdev->desc->min_uV;\r\nreturn *min_uV;\r\n}\r\nstatic int as3711_sel_check(int min, int max, int bottom, int step)\r\n{\r\nint sel, voltage;\r\nsel = DIV_ROUND_UP(min - bottom, step);\r\nvoltage = sel * step + bottom;\r\npr_debug("%s(): select %d..%d in %d+N*%d: %d\n", __func__,\r\nmin, max, bottom, step, sel);\r\nif (voltage > max)\r\nreturn -EINVAL;\r\nreturn sel;\r\n}\r\nstatic int as3711_map_voltage_sd(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nint ret;\r\nret = as3711_bound_check(rdev, &min_uV, &max_uV);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (min_uV <= 1400000)\r\nreturn as3711_sel_check(min_uV, max_uV, 600000, 12500);\r\nif (min_uV <= 2600000)\r\nreturn as3711_sel_check(min_uV, max_uV, 1400000, 25000) + 0x40;\r\nreturn as3711_sel_check(min_uV, max_uV, 2600000, 50000) + 0x70;\r\n}\r\nstatic int as3711_set_mode_sd(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nunsigned int fast_bit = rdev->desc->enable_mask,\r\nlow_noise_bit = fast_bit << 4;\r\nu8 val;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = fast_bit | low_noise_bit;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = low_noise_bit;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(rdev->regmap, AS3711_SD_CONTROL_1,\r\nlow_noise_bit | fast_bit, val);\r\n}\r\nstatic unsigned int as3711_get_mode_sd(struct regulator_dev *rdev)\r\n{\r\nunsigned int fast_bit = rdev->desc->enable_mask,\r\nlow_noise_bit = fast_bit << 4, mask = fast_bit | low_noise_bit;\r\nunsigned int val;\r\nint ret = regmap_read(rdev->regmap, AS3711_SD_CONTROL_1, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((val & mask) == mask)\r\nreturn REGULATOR_MODE_FAST;\r\nif ((val & mask) == low_noise_bit)\r\nreturn REGULATOR_MODE_NORMAL;\r\nif (!(val & mask))\r\nreturn REGULATOR_MODE_IDLE;\r\nreturn -EINVAL;\r\n}\r\nstatic int as3711_map_voltage_aldo(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nint ret;\r\nret = as3711_bound_check(rdev, &min_uV, &max_uV);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (min_uV <= 1800000)\r\nreturn as3711_sel_check(min_uV, max_uV, 1200000, 50000);\r\nreturn as3711_sel_check(min_uV, max_uV, 1800000, 100000) + 0x10;\r\n}\r\nstatic int as3711_map_voltage_dldo(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nint ret;\r\nret = as3711_bound_check(rdev, &min_uV, &max_uV);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (min_uV <= 1700000)\r\nreturn as3711_sel_check(min_uV, max_uV, 900000, 50000);\r\nreturn as3711_sel_check(min_uV, max_uV, 1750000, 50000) + 0x20;\r\n}\r\nstatic int as3711_regulator_parse_dt(struct device *dev,\r\nstruct device_node **of_node, const int count)\r\n{\r\nstruct as3711_regulator_pdata *pdata = dev_get_platdata(dev);\r\nstruct device_node *regulators =\r\nof_find_node_by_name(dev->parent->of_node, "regulators");\r\nstruct of_regulator_match *match;\r\nint ret, i;\r\nif (!regulators) {\r\ndev_err(dev, "regulator node not found\n");\r\nreturn -ENODEV;\r\n}\r\nret = of_regulator_match(dev->parent, regulators,\r\nas3711_regulator_matches, count);\r\nof_node_put(regulators);\r\nif (ret < 0) {\r\ndev_err(dev, "Error parsing regulator init data: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0, match = as3711_regulator_matches; i < count; i++, match++)\r\nif (match->of_node) {\r\npdata->init_data[i] = match->init_data;\r\nof_node[i] = match->of_node;\r\n}\r\nreturn 0;\r\n}\r\nstatic int as3711_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct as3711_regulator_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nstruct as3711 *as3711 = dev_get_drvdata(pdev->dev.parent);\r\nstruct regulator_init_data *reg_data;\r\nstruct regulator_config config = {.dev = &pdev->dev,};\r\nstruct as3711_regulator *reg = NULL;\r\nstruct as3711_regulator *regs;\r\nstruct device_node *of_node[AS3711_REGULATOR_NUM] = {};\r\nstruct regulator_dev *rdev;\r\nstruct as3711_regulator_info *ri;\r\nint ret;\r\nint id;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data...\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdev->dev.parent->of_node) {\r\nret = as3711_regulator_parse_dt(&pdev->dev, of_node, AS3711_REGULATOR_NUM);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "DT parsing failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nregs = devm_kzalloc(&pdev->dev, AS3711_REGULATOR_NUM *\r\nsizeof(struct as3711_regulator), GFP_KERNEL);\r\nif (!regs) {\r\ndev_err(&pdev->dev, "Memory allocation failed exiting..\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (id = 0, ri = as3711_reg_info; id < AS3711_REGULATOR_NUM; ++id, ri++) {\r\nreg_data = pdata->init_data[id];\r\nif (!reg_data)\r\ncontinue;\r\nreg = &regs[id];\r\nreg->reg_info = ri;\r\nconfig.init_data = reg_data;\r\nconfig.driver_data = reg;\r\nconfig.regmap = as3711->regmap;\r\nconfig.of_node = of_node[id];\r\nrdev = regulator_register(&ri->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "Failed to register regulator %s\n",\r\nri->desc.name);\r\nret = PTR_ERR(rdev);\r\ngoto eregreg;\r\n}\r\nreg->rdev = rdev;\r\n}\r\nplatform_set_drvdata(pdev, regs);\r\nreturn 0;\r\neregreg:\r\nwhile (--id >= 0)\r\nregulator_unregister(regs[id].rdev);\r\nreturn ret;\r\n}\r\nstatic int as3711_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct as3711_regulator *regs = platform_get_drvdata(pdev);\r\nint id;\r\nfor (id = 0; id < AS3711_REGULATOR_NUM; ++id)\r\nregulator_unregister(regs[id].rdev);\r\nreturn 0;\r\n}\r\nstatic int __init as3711_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&as3711_regulator_driver);\r\n}\r\nstatic void __exit as3711_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&as3711_regulator_driver);\r\n}
