static bool output_set_by_user(void)\r\n{\r\nint j;\r\nfor (j = 0; j < PERF_TYPE_MAX; ++j) {\r\nif (output[j].user_set)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic const char *output_field2str(enum perf_output_field field)\r\n{\r\nint i, imax = ARRAY_SIZE(all_output_options);\r\nconst char *str = "";\r\nfor (i = 0; i < imax; ++i) {\r\nif (all_output_options[i].field == field) {\r\nstr = all_output_options[i].str;\r\nbreak;\r\n}\r\n}\r\nreturn str;\r\n}\r\nstatic int perf_evsel__check_stype(struct perf_evsel *evsel,\r\nu64 sample_type, const char *sample_msg,\r\nenum perf_output_field field)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nint type = attr->type;\r\nconst char *evname;\r\nif (attr->sample_type & sample_type)\r\nreturn 0;\r\nif (output[type].user_set) {\r\nevname = perf_evsel__name(evsel);\r\npr_err("Samples for '%s' event do not have %s attribute set. "\r\n"Cannot print '%s' field.\n",\r\nevname, sample_msg, output_field2str(field));\r\nreturn -1;\r\n}\r\noutput[type].fields &= ~field;\r\nevname = perf_evsel__name(evsel);\r\npr_debug("Samples for '%s' event do not have %s attribute set. "\r\n"Skipping '%s' field.\n",\r\nevname, sample_msg, output_field2str(field));\r\nreturn 0;\r\n}\r\nstatic int perf_evsel__check_attr(struct perf_evsel *evsel,\r\nstruct perf_session *session)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nif (PRINT_FIELD(TRACE) &&\r\n!perf_session__has_traces(session, "record -R"))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(IP)) {\r\nif (perf_evsel__check_stype(evsel, PERF_SAMPLE_IP, "IP",\r\nPERF_OUTPUT_IP))\r\nreturn -EINVAL;\r\nif (!no_callchain &&\r\n!(attr->sample_type & PERF_SAMPLE_CALLCHAIN))\r\nsymbol_conf.use_callchain = false;\r\n}\r\nif (PRINT_FIELD(ADDR) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_ADDR, "ADDR",\r\nPERF_OUTPUT_ADDR))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(SYM) && !PRINT_FIELD(IP) && !PRINT_FIELD(ADDR)) {\r\npr_err("Display of symbols requested but neither sample IP nor "\r\n"sample address\nis selected. Hence, no addresses to convert "\r\n"to symbols.\n");\r\nreturn -EINVAL;\r\n}\r\nif (PRINT_FIELD(SYMOFFSET) && !PRINT_FIELD(SYM)) {\r\npr_err("Display of offsets requested but symbol is not"\r\n"selected.\n");\r\nreturn -EINVAL;\r\n}\r\nif (PRINT_FIELD(DSO) && !PRINT_FIELD(IP) && !PRINT_FIELD(ADDR)) {\r\npr_err("Display of DSO requested but neither sample IP nor "\r\n"sample address\nis selected. Hence, no addresses to convert "\r\n"to DSO.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((PRINT_FIELD(PID) || PRINT_FIELD(TID)) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_TID, "TID",\r\nPERF_OUTPUT_TID|PERF_OUTPUT_PID))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(TIME) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_TIME, "TIME",\r\nPERF_OUTPUT_TIME))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(CPU) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_CPU, "CPU",\r\nPERF_OUTPUT_CPU))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int perf_session__check_output_opt(struct perf_session *session)\r\n{\r\nint j;\r\nstruct perf_evsel *evsel;\r\nfor (j = 0; j < PERF_TYPE_MAX; ++j) {\r\nevsel = perf_session__find_first_evtype(session, j);\r\nif (!evsel && output[j].user_set && !output[j].wildcard_set) {\r\npr_err("%s events do not exist. "\r\n"Remove corresponding -f option to proceed.\n",\r\nevent_type(j));\r\nreturn -1;\r\n}\r\nif (evsel && output[j].fields &&\r\nperf_evsel__check_attr(evsel, session))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void print_sample_start(struct perf_sample *sample,\r\nstruct thread *thread,\r\nstruct perf_evsel *evsel)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nconst char *evname = NULL;\r\nunsigned long secs;\r\nunsigned long usecs;\r\nunsigned long long nsecs;\r\nif (PRINT_FIELD(COMM)) {\r\nif (latency_format)\r\nprintf("%8.8s ", thread->comm);\r\nelse if (PRINT_FIELD(IP) && symbol_conf.use_callchain)\r\nprintf("%s ", thread->comm);\r\nelse\r\nprintf("%16s ", thread->comm);\r\n}\r\nif (PRINT_FIELD(PID) && PRINT_FIELD(TID))\r\nprintf("%5d/%-5d ", sample->pid, sample->tid);\r\nelse if (PRINT_FIELD(PID))\r\nprintf("%5d ", sample->pid);\r\nelse if (PRINT_FIELD(TID))\r\nprintf("%5d ", sample->tid);\r\nif (PRINT_FIELD(CPU)) {\r\nif (latency_format)\r\nprintf("%3d ", sample->cpu);\r\nelse\r\nprintf("[%03d] ", sample->cpu);\r\n}\r\nif (PRINT_FIELD(TIME)) {\r\nnsecs = sample->time;\r\nsecs = nsecs / NSECS_PER_SEC;\r\nnsecs -= secs * NSECS_PER_SEC;\r\nusecs = nsecs / NSECS_PER_USEC;\r\nprintf("%5lu.%06lu: ", secs, usecs);\r\n}\r\nif (PRINT_FIELD(EVNAME)) {\r\nevname = perf_evsel__name(evsel);\r\nprintf("%s: ", evname ? evname : "[unknown]");\r\n}\r\n}\r\nstatic bool is_bts_event(struct perf_event_attr *attr)\r\n{\r\nreturn ((attr->type == PERF_TYPE_HARDWARE) &&\r\n(attr->config & PERF_COUNT_HW_BRANCH_INSTRUCTIONS) &&\r\n(attr->sample_period == 1));\r\n}\r\nstatic bool sample_addr_correlates_sym(struct perf_event_attr *attr)\r\n{\r\nif ((attr->type == PERF_TYPE_SOFTWARE) &&\r\n((attr->config == PERF_COUNT_SW_PAGE_FAULTS) ||\r\n(attr->config == PERF_COUNT_SW_PAGE_FAULTS_MIN) ||\r\n(attr->config == PERF_COUNT_SW_PAGE_FAULTS_MAJ)))\r\nreturn true;\r\nif (is_bts_event(attr))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void print_sample_addr(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine,\r\nstruct thread *thread,\r\nstruct perf_event_attr *attr)\r\n{\r\nstruct addr_location al;\r\nu8 cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nprintf("%16" PRIx64, sample->addr);\r\nif (!sample_addr_correlates_sym(attr))\r\nreturn;\r\nthread__find_addr_map(thread, machine, cpumode, MAP__FUNCTION,\r\nsample->addr, &al);\r\nif (!al.map)\r\nthread__find_addr_map(thread, machine, cpumode, MAP__VARIABLE,\r\nsample->addr, &al);\r\nal.cpu = sample->cpu;\r\nal.sym = NULL;\r\nif (al.map)\r\nal.sym = map__find_symbol(al.map, al.addr, NULL);\r\nif (PRINT_FIELD(SYM)) {\r\nprintf(" ");\r\nif (PRINT_FIELD(SYMOFFSET))\r\nsymbol__fprintf_symname_offs(al.sym, &al, stdout);\r\nelse\r\nsymbol__fprintf_symname(al.sym, stdout);\r\n}\r\nif (PRINT_FIELD(DSO)) {\r\nprintf(" (");\r\nmap__fprintf_dsoname(al.map, stdout);\r\nprintf(")");\r\n}\r\n}\r\nstatic void print_sample_bts(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine,\r\nstruct thread *thread)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nif (PRINT_FIELD(IP)) {\r\nif (!symbol_conf.use_callchain)\r\nprintf(" ");\r\nelse\r\nprintf("\n");\r\nperf_evsel__print_ip(evsel, event, sample, machine,\r\nPRINT_FIELD(SYM), PRINT_FIELD(DSO),\r\nPRINT_FIELD(SYMOFFSET));\r\n}\r\nprintf(" => ");\r\nif (PRINT_FIELD(ADDR))\r\nprint_sample_addr(event, sample, machine, thread, attr);\r\nprintf("\n");\r\n}\r\nstatic void process_event(union perf_event *event, struct perf_sample *sample,\r\nstruct perf_evsel *evsel, struct machine *machine,\r\nstruct addr_location *al)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nstruct thread *thread = al->thread;\r\nif (output[attr->type].fields == 0)\r\nreturn;\r\nprint_sample_start(sample, thread, evsel);\r\nif (is_bts_event(attr)) {\r\nprint_sample_bts(event, sample, evsel, machine, thread);\r\nreturn;\r\n}\r\nif (PRINT_FIELD(TRACE))\r\nevent_format__print(evsel->tp_format, sample->cpu,\r\nsample->raw_data, sample->raw_size);\r\nif (PRINT_FIELD(ADDR))\r\nprint_sample_addr(event, sample, machine, thread, attr);\r\nif (PRINT_FIELD(IP)) {\r\nif (!symbol_conf.use_callchain)\r\nprintf(" ");\r\nelse\r\nprintf("\n");\r\nperf_evsel__print_ip(evsel, event, sample, machine,\r\nPRINT_FIELD(SYM), PRINT_FIELD(DSO),\r\nPRINT_FIELD(SYMOFFSET));\r\n}\r\nprintf("\n");\r\n}\r\nstatic int default_start_script(const char *script __maybe_unused,\r\nint argc __maybe_unused,\r\nconst char **argv __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int default_stop_script(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int default_generate_script(struct pevent *pevent __maybe_unused,\r\nconst char *outfile __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic void setup_scripting(void)\r\n{\r\nsetup_perl_scripting();\r\nsetup_python_scripting();\r\nscripting_ops = &default_scripting_ops;\r\n}\r\nstatic int cleanup_scripting(void)\r\n{\r\npr_debug("\nperf script stopped\n");\r\nreturn scripting_ops->stop_script();\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nstruct thread *thread = machine__findnew_thread(machine, event->ip.tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (debug_mode) {\r\nif (sample->time < last_timestamp) {\r\npr_err("Samples misordered, previous: %" PRIu64\r\n" this: %" PRIu64 "\n", last_timestamp,\r\nsample->time);\r\nnr_unordered++;\r\n}\r\nlast_timestamp = sample->time;\r\nreturn 0;\r\n}\r\nif (perf_event__preprocess_sample(event, machine, &al, sample, 0) < 0) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (al.filtered)\r\nreturn 0;\r\nif (cpu_list && !test_bit(sample->cpu, cpu_bitmap))\r\nreturn 0;\r\nscripting_ops->process_event(event, sample, evsel, machine, &al);\r\nevsel->hists.stats.total_period += sample->period;\r\nreturn 0;\r\n}\r\nstatic void sig_handler(int sig __maybe_unused)\r\n{\r\nsession_done = 1;\r\n}\r\nstatic int __cmd_script(struct perf_session *session)\r\n{\r\nint ret;\r\nsignal(SIGINT, sig_handler);\r\nret = perf_session__process_events(session, &perf_script);\r\nif (debug_mode)\r\npr_err("Misordered timestamps: %" PRIu64 "\n", nr_unordered);\r\nreturn ret;\r\n}\r\nstatic struct script_spec *script_spec__new(const char *spec,\r\nstruct scripting_ops *ops)\r\n{\r\nstruct script_spec *s = malloc(sizeof(*s) + strlen(spec) + 1);\r\nif (s != NULL) {\r\nstrcpy(s->spec, spec);\r\ns->ops = ops;\r\n}\r\nreturn s;\r\n}\r\nstatic void script_spec__add(struct script_spec *s)\r\n{\r\nlist_add_tail(&s->node, &script_specs);\r\n}\r\nstatic struct script_spec *script_spec__find(const char *spec)\r\n{\r\nstruct script_spec *s;\r\nlist_for_each_entry(s, &script_specs, node)\r\nif (strcasecmp(s->spec, spec) == 0)\r\nreturn s;\r\nreturn NULL;\r\n}\r\nstatic struct script_spec *script_spec__findnew(const char *spec,\r\nstruct scripting_ops *ops)\r\n{\r\nstruct script_spec *s = script_spec__find(spec);\r\nif (s)\r\nreturn s;\r\ns = script_spec__new(spec, ops);\r\nif (!s)\r\nreturn NULL;\r\nscript_spec__add(s);\r\nreturn s;\r\n}\r\nint script_spec_register(const char *spec, struct scripting_ops *ops)\r\n{\r\nstruct script_spec *s;\r\ns = script_spec__find(spec);\r\nif (s)\r\nreturn -1;\r\ns = script_spec__findnew(spec, ops);\r\nif (!s)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic struct scripting_ops *script_spec__lookup(const char *spec)\r\n{\r\nstruct script_spec *s = script_spec__find(spec);\r\nif (!s)\r\nreturn NULL;\r\nreturn s->ops;\r\n}\r\nstatic void list_available_languages(void)\r\n{\r\nstruct script_spec *s;\r\nfprintf(stderr, "\n");\r\nfprintf(stderr, "Scripting language extensions (used in "\r\n"perf script -s [spec:]script.[spec]):\n\n");\r\nlist_for_each_entry(s, &script_specs, node)\r\nfprintf(stderr, " %-42s [%s]\n", s->spec, s->ops->name);\r\nfprintf(stderr, "\n");\r\n}\r\nstatic int parse_scriptname(const struct option *opt __maybe_unused,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nchar spec[PATH_MAX];\r\nconst char *script, *ext;\r\nint len;\r\nif (strcmp(str, "lang") == 0) {\r\nlist_available_languages();\r\nexit(0);\r\n}\r\nscript = strchr(str, ':');\r\nif (script) {\r\nlen = script - str;\r\nif (len >= PATH_MAX) {\r\nfprintf(stderr, "invalid language specifier");\r\nreturn -1;\r\n}\r\nstrncpy(spec, str, len);\r\nspec[len] = '\0';\r\nscripting_ops = script_spec__lookup(spec);\r\nif (!scripting_ops) {\r\nfprintf(stderr, "invalid language specifier");\r\nreturn -1;\r\n}\r\nscript++;\r\n} else {\r\nscript = str;\r\next = strrchr(script, '.');\r\nif (!ext) {\r\nfprintf(stderr, "invalid script extension");\r\nreturn -1;\r\n}\r\nscripting_ops = script_spec__lookup(++ext);\r\nif (!scripting_ops) {\r\nfprintf(stderr, "invalid script extension");\r\nreturn -1;\r\n}\r\n}\r\nscript_name = strdup(script);\r\nreturn 0;\r\n}\r\nstatic int parse_output_fields(const struct option *opt __maybe_unused,\r\nconst char *arg, int unset __maybe_unused)\r\n{\r\nchar *tok;\r\nint i, imax = ARRAY_SIZE(all_output_options);\r\nint j;\r\nint rc = 0;\r\nchar *str = strdup(arg);\r\nint type = -1;\r\nif (!str)\r\nreturn -ENOMEM;\r\ntok = strchr(str, ':');\r\nif (tok) {\r\n*tok = '\0';\r\ntok++;\r\nif (!strcmp(str, "hw"))\r\ntype = PERF_TYPE_HARDWARE;\r\nelse if (!strcmp(str, "sw"))\r\ntype = PERF_TYPE_SOFTWARE;\r\nelse if (!strcmp(str, "trace"))\r\ntype = PERF_TYPE_TRACEPOINT;\r\nelse if (!strcmp(str, "raw"))\r\ntype = PERF_TYPE_RAW;\r\nelse {\r\nfprintf(stderr, "Invalid event type in field string.\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (output[type].user_set)\r\npr_warning("Overriding previous field request for %s events.\n",\r\nevent_type(type));\r\noutput[type].fields = 0;\r\noutput[type].user_set = true;\r\noutput[type].wildcard_set = false;\r\n} else {\r\ntok = str;\r\nif (strlen(str) == 0) {\r\nfprintf(stderr,\r\n"Cannot set fields to 'none' for all event types.\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (output_set_by_user())\r\npr_warning("Overriding previous field request for all events.\n");\r\nfor (j = 0; j < PERF_TYPE_MAX; ++j) {\r\noutput[j].fields = 0;\r\noutput[j].user_set = true;\r\noutput[j].wildcard_set = true;\r\n}\r\n}\r\ntok = strtok(tok, ",");\r\nwhile (tok) {\r\nfor (i = 0; i < imax; ++i) {\r\nif (strcmp(tok, all_output_options[i].str) == 0)\r\nbreak;\r\n}\r\nif (i == imax) {\r\nfprintf(stderr, "Invalid field requested.\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (type == -1) {\r\nfor (j = 0; j < PERF_TYPE_MAX; ++j) {\r\nif (output[j].invalid_fields & all_output_options[i].field) {\r\npr_warning("\'%s\' not valid for %s events. Ignoring.\n",\r\nall_output_options[i].str, event_type(j));\r\n} else\r\noutput[j].fields |= all_output_options[i].field;\r\n}\r\n} else {\r\nif (output[type].invalid_fields & all_output_options[i].field) {\r\nfprintf(stderr, "\'%s\' not valid for %s events.\n",\r\nall_output_options[i].str, event_type(type));\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\noutput[type].fields |= all_output_options[i].field;\r\n}\r\ntok = strtok(NULL, ",");\r\n}\r\nif (type >= 0) {\r\nif (output[type].fields == 0) {\r\npr_debug("No fields requested for %s type. "\r\n"Events will not be displayed.\n", event_type(type));\r\n}\r\n}\r\nout:\r\nfree(str);\r\nreturn rc;\r\n}\r\nstatic int is_directory(const char *base_path, const struct dirent *dent)\r\n{\r\nchar path[PATH_MAX];\r\nstruct stat st;\r\nsprintf(path, "%s/%s", base_path, dent->d_name);\r\nif (stat(path, &st))\r\nreturn 0;\r\nreturn S_ISDIR(st.st_mode);\r\n}\r\nstatic struct script_desc *script_desc__new(const char *name)\r\n{\r\nstruct script_desc *s = zalloc(sizeof(*s));\r\nif (s != NULL && name)\r\ns->name = strdup(name);\r\nreturn s;\r\n}\r\nstatic void script_desc__delete(struct script_desc *s)\r\n{\r\nfree(s->name);\r\nfree(s->half_liner);\r\nfree(s->args);\r\nfree(s);\r\n}\r\nstatic void script_desc__add(struct script_desc *s)\r\n{\r\nlist_add_tail(&s->node, &script_descs);\r\n}\r\nstatic struct script_desc *script_desc__find(const char *name)\r\n{\r\nstruct script_desc *s;\r\nlist_for_each_entry(s, &script_descs, node)\r\nif (strcasecmp(s->name, name) == 0)\r\nreturn s;\r\nreturn NULL;\r\n}\r\nstatic struct script_desc *script_desc__findnew(const char *name)\r\n{\r\nstruct script_desc *s = script_desc__find(name);\r\nif (s)\r\nreturn s;\r\ns = script_desc__new(name);\r\nif (!s)\r\ngoto out_delete_desc;\r\nscript_desc__add(s);\r\nreturn s;\r\nout_delete_desc:\r\nscript_desc__delete(s);\r\nreturn NULL;\r\n}\r\nstatic const char *ends_with(const char *str, const char *suffix)\r\n{\r\nsize_t suffix_len = strlen(suffix);\r\nconst char *p = str;\r\nif (strlen(str) > suffix_len) {\r\np = str + strlen(str) - suffix_len;\r\nif (!strncmp(p, suffix, suffix_len))\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int read_script_info(struct script_desc *desc, const char *filename)\r\n{\r\nchar line[BUFSIZ], *p;\r\nFILE *fp;\r\nfp = fopen(filename, "r");\r\nif (!fp)\r\nreturn -1;\r\nwhile (fgets(line, sizeof(line), fp)) {\r\np = ltrim(line);\r\nif (strlen(p) == 0)\r\ncontinue;\r\nif (*p != '#')\r\ncontinue;\r\np++;\r\nif (strlen(p) && *p == '!')\r\ncontinue;\r\np = ltrim(p);\r\nif (strlen(p) && p[strlen(p) - 1] == '\n')\r\np[strlen(p) - 1] = '\0';\r\nif (!strncmp(p, "description:", strlen("description:"))) {\r\np += strlen("description:");\r\ndesc->half_liner = strdup(ltrim(p));\r\ncontinue;\r\n}\r\nif (!strncmp(p, "args:", strlen("args:"))) {\r\np += strlen("args:");\r\ndesc->args = strdup(ltrim(p));\r\ncontinue;\r\n}\r\n}\r\nfclose(fp);\r\nreturn 0;\r\n}\r\nstatic char *get_script_root(struct dirent *script_dirent, const char *suffix)\r\n{\r\nchar *script_root, *str;\r\nscript_root = strdup(script_dirent->d_name);\r\nif (!script_root)\r\nreturn NULL;\r\nstr = (char *)ends_with(script_root, suffix);\r\nif (!str) {\r\nfree(script_root);\r\nreturn NULL;\r\n}\r\n*str = '\0';\r\nreturn script_root;\r\n}\r\nstatic int list_available_scripts(const struct option *opt __maybe_unused,\r\nconst char *s __maybe_unused,\r\nint unset __maybe_unused)\r\n{\r\nstruct dirent *script_next, *lang_next, script_dirent, lang_dirent;\r\nchar scripts_path[MAXPATHLEN];\r\nDIR *scripts_dir, *lang_dir;\r\nchar script_path[MAXPATHLEN];\r\nchar lang_path[MAXPATHLEN];\r\nstruct script_desc *desc;\r\nchar first_half[BUFSIZ];\r\nchar *script_root;\r\nsnprintf(scripts_path, MAXPATHLEN, "%s/scripts", perf_exec_path());\r\nscripts_dir = opendir(scripts_path);\r\nif (!scripts_dir)\r\nreturn -1;\r\nfor_each_lang(scripts_path, scripts_dir, lang_dirent, lang_next) {\r\nsnprintf(lang_path, MAXPATHLEN, "%s/%s/bin", scripts_path,\r\nlang_dirent.d_name);\r\nlang_dir = opendir(lang_path);\r\nif (!lang_dir)\r\ncontinue;\r\nfor_each_script(lang_path, lang_dir, script_dirent, script_next) {\r\nscript_root = get_script_root(&script_dirent, REPORT_SUFFIX);\r\nif (script_root) {\r\ndesc = script_desc__findnew(script_root);\r\nsnprintf(script_path, MAXPATHLEN, "%s/%s",\r\nlang_path, script_dirent.d_name);\r\nread_script_info(desc, script_path);\r\nfree(script_root);\r\n}\r\n}\r\n}\r\nfprintf(stdout, "List of available trace scripts:\n");\r\nlist_for_each_entry(desc, &script_descs, node) {\r\nsprintf(first_half, "%s %s", desc->name,\r\ndesc->args ? desc->args : "");\r\nfprintf(stdout, " %-36s %s\n", first_half,\r\ndesc->half_liner ? desc->half_liner : "");\r\n}\r\nexit(0);\r\n}\r\nstatic int check_ev_match(char *dir_name, char *scriptname,\r\nstruct perf_session *session)\r\n{\r\nchar filename[MAXPATHLEN], evname[128];\r\nchar line[BUFSIZ], *p;\r\nstruct perf_evsel *pos;\r\nint match, len;\r\nFILE *fp;\r\nsprintf(filename, "%s/bin/%s-record", dir_name, scriptname);\r\nfp = fopen(filename, "r");\r\nif (!fp)\r\nreturn -1;\r\nwhile (fgets(line, sizeof(line), fp)) {\r\np = ltrim(line);\r\nif (*p == '#')\r\ncontinue;\r\nwhile (strlen(p)) {\r\np = strstr(p, "-e");\r\nif (!p)\r\nbreak;\r\np += 2;\r\np = ltrim(p);\r\nlen = strcspn(p, " \t");\r\nif (!len)\r\nbreak;\r\nsnprintf(evname, len + 1, "%s", p);\r\nmatch = 0;\r\nlist_for_each_entry(pos,\r\n&session->evlist->entries, node) {\r\nif (!strcmp(perf_evsel__name(pos), evname)) {\r\nmatch = 1;\r\nbreak;\r\n}\r\n}\r\nif (!match) {\r\nfclose(fp);\r\nreturn -1;\r\n}\r\n}\r\n}\r\nfclose(fp);\r\nreturn 0;\r\n}\r\nint find_scripts(char **scripts_array, char **scripts_path_array)\r\n{\r\nstruct dirent *script_next, *lang_next, script_dirent, lang_dirent;\r\nchar scripts_path[MAXPATHLEN], lang_path[MAXPATHLEN];\r\nDIR *scripts_dir, *lang_dir;\r\nstruct perf_session *session;\r\nchar *temp;\r\nint i = 0;\r\nsession = perf_session__new(input_name, O_RDONLY, 0, false, NULL);\r\nif (!session)\r\nreturn -1;\r\nsnprintf(scripts_path, MAXPATHLEN, "%s/scripts", perf_exec_path());\r\nscripts_dir = opendir(scripts_path);\r\nif (!scripts_dir) {\r\nperf_session__delete(session);\r\nreturn -1;\r\n}\r\nfor_each_lang(scripts_path, scripts_dir, lang_dirent, lang_next) {\r\nsnprintf(lang_path, MAXPATHLEN, "%s/%s", scripts_path,\r\nlang_dirent.d_name);\r\n#ifdef NO_LIBPERL\r\nif (strstr(lang_path, "perl"))\r\ncontinue;\r\n#endif\r\n#ifdef NO_LIBPYTHON\r\nif (strstr(lang_path, "python"))\r\ncontinue;\r\n#endif\r\nlang_dir = opendir(lang_path);\r\nif (!lang_dir)\r\ncontinue;\r\nfor_each_script(lang_path, lang_dir, script_dirent, script_next) {\r\nif (strstr(script_dirent.d_name, "top."))\r\ncontinue;\r\nsprintf(scripts_path_array[i], "%s/%s", lang_path,\r\nscript_dirent.d_name);\r\ntemp = strchr(script_dirent.d_name, '.');\r\nsnprintf(scripts_array[i],\r\n(temp - script_dirent.d_name) + 1,\r\n"%s", script_dirent.d_name);\r\nif (check_ev_match(lang_path,\r\nscripts_array[i], session))\r\ncontinue;\r\ni++;\r\n}\r\nclosedir(lang_dir);\r\n}\r\nclosedir(scripts_dir);\r\nperf_session__delete(session);\r\nreturn i;\r\n}\r\nstatic char *get_script_path(const char *script_root, const char *suffix)\r\n{\r\nstruct dirent *script_next, *lang_next, script_dirent, lang_dirent;\r\nchar scripts_path[MAXPATHLEN];\r\nchar script_path[MAXPATHLEN];\r\nDIR *scripts_dir, *lang_dir;\r\nchar lang_path[MAXPATHLEN];\r\nchar *__script_root;\r\nsnprintf(scripts_path, MAXPATHLEN, "%s/scripts", perf_exec_path());\r\nscripts_dir = opendir(scripts_path);\r\nif (!scripts_dir)\r\nreturn NULL;\r\nfor_each_lang(scripts_path, scripts_dir, lang_dirent, lang_next) {\r\nsnprintf(lang_path, MAXPATHLEN, "%s/%s/bin", scripts_path,\r\nlang_dirent.d_name);\r\nlang_dir = opendir(lang_path);\r\nif (!lang_dir)\r\ncontinue;\r\nfor_each_script(lang_path, lang_dir, script_dirent, script_next) {\r\n__script_root = get_script_root(&script_dirent, suffix);\r\nif (__script_root && !strcmp(script_root, __script_root)) {\r\nfree(__script_root);\r\nclosedir(lang_dir);\r\nclosedir(scripts_dir);\r\nsnprintf(script_path, MAXPATHLEN, "%s/%s",\r\nlang_path, script_dirent.d_name);\r\nreturn strdup(script_path);\r\n}\r\nfree(__script_root);\r\n}\r\nclosedir(lang_dir);\r\n}\r\nclosedir(scripts_dir);\r\nreturn NULL;\r\n}\r\nstatic bool is_top_script(const char *script_path)\r\n{\r\nreturn ends_with(script_path, "top") == NULL ? false : true;\r\n}\r\nstatic int has_required_arg(char *script_path)\r\n{\r\nstruct script_desc *desc;\r\nint n_args = 0;\r\nchar *p;\r\ndesc = script_desc__new(NULL);\r\nif (read_script_info(desc, script_path))\r\ngoto out;\r\nif (!desc->args)\r\ngoto out;\r\nfor (p = desc->args; *p; p++)\r\nif (*p == '<')\r\nn_args++;\r\nout:\r\nscript_desc__delete(desc);\r\nreturn n_args;\r\n}\r\nstatic int have_cmd(int argc, const char **argv)\r\n{\r\nchar **__argv = malloc(sizeof(const char *) * argc);\r\nif (!__argv) {\r\npr_err("malloc failed\n");\r\nreturn -1;\r\n}\r\nmemcpy(__argv, argv, sizeof(const char *) * argc);\r\nargc = parse_options(argc, (const char **)__argv, record_options,\r\nNULL, PARSE_OPT_STOP_AT_NON_OPTION);\r\nfree(__argv);\r\nsystem_wide = (argc == 0);\r\nreturn 0;\r\n}\r\nint cmd_script(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nbool show_full_info = false;\r\nchar *rec_script_path = NULL;\r\nchar *rep_script_path = NULL;\r\nstruct perf_session *session;\r\nchar *script_path = NULL;\r\nconst char **__argv;\r\nint i, j, err;\r\nconst struct option options[] = {\r\nOPT_BOOLEAN('D', "dump-raw-trace", &dump_trace,\r\n"dump raw trace in ASCII"),\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show symbol address, etc)"),\r\nOPT_BOOLEAN('L', "Latency", &latency_format,\r\n"show latency attributes (irqs/preemption disabled, etc)"),\r\nOPT_CALLBACK_NOOPT('l', "list", NULL, NULL, "list available scripts",\r\nlist_available_scripts),\r\nOPT_CALLBACK('s', "script", NULL, "name",\r\n"script file name (lang:script name, script name, or *)",\r\nparse_scriptname),\r\nOPT_STRING('g', "gen-script", &generate_script_lang, "lang",\r\n"generate perf-script.xx script in specified language"),\r\nOPT_STRING('i', "input", &input_name, "file", "input file name"),\r\nOPT_BOOLEAN('d', "debug-mode", &debug_mode,\r\n"do various checks like samples ordering and lost events"),\r\nOPT_STRING('k', "vmlinux", &symbol_conf.vmlinux_name,\r\n"file", "vmlinux pathname"),\r\nOPT_STRING(0, "kallsyms", &symbol_conf.kallsyms_name,\r\n"file", "kallsyms pathname"),\r\nOPT_BOOLEAN('G', "hide-call-graph", &no_callchain,\r\n"When printing symbols do not display call chain"),\r\nOPT_STRING(0, "symfs", &symbol_conf.symfs, "directory",\r\n"Look for files with symbols relative to this directory"),\r\nOPT_CALLBACK('f', "fields", NULL, "str",\r\n"comma separated output fields prepend with 'type:'. "\r\n"Valid types: hw,sw,trace,raw. "\r\n"Fields: comm,tid,pid,time,cpu,event,trace,ip,sym,dso,"\r\n"addr,symoff", parse_output_fields),\r\nOPT_BOOLEAN('a', "all-cpus", &system_wide,\r\n"system-wide collection from all CPUs"),\r\nOPT_STRING('S', "symbols", &symbol_conf.sym_list_str, "symbol[,symbol...]",\r\n"only consider these symbols"),\r\nOPT_STRING('C', "cpu", &cpu_list, "cpu", "list of cpus to profile"),\r\nOPT_STRING('c', "comms", &symbol_conf.comm_list_str, "comm[,comm...]",\r\n"only display events for these comms"),\r\nOPT_BOOLEAN('I', "show-info", &show_full_info,\r\n"display extended information from perf.data file"),\r\nOPT_BOOLEAN('\0', "show-kernel-path", &symbol_conf.show_kernel_path,\r\n"Show the path of [kernel.kallsyms]"),\r\nOPT_END()\r\n};\r\nconst char * const script_usage[] = {\r\n"perf script [<options>]",\r\n"perf script [<options>] record <script> [<record-options>] <command>",\r\n"perf script [<options>] report <script> [script-args]",\r\n"perf script [<options>] <script> [<record-options>] <command>",\r\n"perf script [<options>] <top-script> [script-args]",\r\nNULL\r\n};\r\nsetup_scripting();\r\nargc = parse_options(argc, argv, options, script_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nif (argc > 1 && !strncmp(argv[0], "rec", strlen("rec"))) {\r\nrec_script_path = get_script_path(argv[1], RECORD_SUFFIX);\r\nif (!rec_script_path)\r\nreturn cmd_record(argc, argv, NULL);\r\n}\r\nif (argc > 1 && !strncmp(argv[0], "rep", strlen("rep"))) {\r\nrep_script_path = get_script_path(argv[1], REPORT_SUFFIX);\r\nif (!rep_script_path) {\r\nfprintf(stderr,\r\n"Please specify a valid report script"\r\n"(see 'perf script -l' for listing)\n");\r\nreturn -1;\r\n}\r\n}\r\nperf_set_argv_exec_path(perf_exec_path());\r\nif (argc && !script_name && !rec_script_path && !rep_script_path) {\r\nint live_pipe[2];\r\nint rep_args;\r\npid_t pid;\r\nrec_script_path = get_script_path(argv[0], RECORD_SUFFIX);\r\nrep_script_path = get_script_path(argv[0], REPORT_SUFFIX);\r\nif (!rec_script_path && !rep_script_path) {\r\nfprintf(stderr, " Couldn't find script %s\n\n See perf"\r\n" script -l for available scripts.\n", argv[0]);\r\nusage_with_options(script_usage, options);\r\n}\r\nif (is_top_script(argv[0])) {\r\nrep_args = argc - 1;\r\n} else {\r\nint rec_args;\r\nrep_args = has_required_arg(rep_script_path);\r\nrec_args = (argc - 1) - rep_args;\r\nif (rec_args < 0) {\r\nfprintf(stderr, " %s script requires options."\r\n"\n\n See perf script -l for available "\r\n"scripts and options.\n", argv[0]);\r\nusage_with_options(script_usage, options);\r\n}\r\n}\r\nif (pipe(live_pipe) < 0) {\r\nperror("failed to create pipe");\r\nreturn -1;\r\n}\r\npid = fork();\r\nif (pid < 0) {\r\nperror("failed to fork");\r\nreturn -1;\r\n}\r\nif (!pid) {\r\nj = 0;\r\ndup2(live_pipe[1], 1);\r\nclose(live_pipe[0]);\r\nif (is_top_script(argv[0])) {\r\nsystem_wide = true;\r\n} else if (!system_wide) {\r\nif (have_cmd(argc - rep_args, &argv[rep_args]) != 0) {\r\nerr = -1;\r\ngoto out;\r\n}\r\n}\r\n__argv = malloc((argc + 6) * sizeof(const char *));\r\nif (!__argv) {\r\npr_err("malloc failed\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n__argv[j++] = "/bin/sh";\r\n__argv[j++] = rec_script_path;\r\nif (system_wide)\r\n__argv[j++] = "-a";\r\n__argv[j++] = "-q";\r\n__argv[j++] = "-o";\r\n__argv[j++] = "-";\r\nfor (i = rep_args + 1; i < argc; i++)\r\n__argv[j++] = argv[i];\r\n__argv[j++] = NULL;\r\nexecvp("/bin/sh", (char **)__argv);\r\nfree(__argv);\r\nexit(-1);\r\n}\r\ndup2(live_pipe[0], 0);\r\nclose(live_pipe[1]);\r\n__argv = malloc((argc + 4) * sizeof(const char *));\r\nif (!__argv) {\r\npr_err("malloc failed\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nj = 0;\r\n__argv[j++] = "/bin/sh";\r\n__argv[j++] = rep_script_path;\r\nfor (i = 1; i < rep_args + 1; i++)\r\n__argv[j++] = argv[i];\r\n__argv[j++] = "-i";\r\n__argv[j++] = "-";\r\n__argv[j++] = NULL;\r\nexecvp("/bin/sh", (char **)__argv);\r\nfree(__argv);\r\nexit(-1);\r\n}\r\nif (rec_script_path)\r\nscript_path = rec_script_path;\r\nif (rep_script_path)\r\nscript_path = rep_script_path;\r\nif (script_path) {\r\nj = 0;\r\nif (!rec_script_path)\r\nsystem_wide = false;\r\nelse if (!system_wide) {\r\nif (have_cmd(argc - 1, &argv[1]) != 0) {\r\nerr = -1;\r\ngoto out;\r\n}\r\n}\r\n__argv = malloc((argc + 2) * sizeof(const char *));\r\nif (!__argv) {\r\npr_err("malloc failed\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n__argv[j++] = "/bin/sh";\r\n__argv[j++] = script_path;\r\nif (system_wide)\r\n__argv[j++] = "-a";\r\nfor (i = 2; i < argc; i++)\r\n__argv[j++] = argv[i];\r\n__argv[j++] = NULL;\r\nexecvp("/bin/sh", (char **)__argv);\r\nfree(__argv);\r\nexit(-1);\r\n}\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nif (!script_name)\r\nsetup_pager();\r\nsession = perf_session__new(input_name, O_RDONLY, 0, false,\r\n&perf_script);\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\nif (cpu_list) {\r\nif (perf_session__cpu_bitmap(session, cpu_list, cpu_bitmap))\r\nreturn -1;\r\n}\r\nif (!script_name && !generate_script_lang)\r\nperf_session__fprintf_info(session, stdout, show_full_info);\r\nif (!no_callchain)\r\nsymbol_conf.use_callchain = true;\r\nelse\r\nsymbol_conf.use_callchain = false;\r\nif (generate_script_lang) {\r\nstruct stat perf_stat;\r\nint input;\r\nif (output_set_by_user()) {\r\nfprintf(stderr,\r\n"custom fields not supported for generated scripts");\r\nreturn -1;\r\n}\r\ninput = open(session->filename, O_RDONLY);\r\nif (input < 0) {\r\nperror("failed to open file");\r\nreturn -1;\r\n}\r\nerr = fstat(input, &perf_stat);\r\nif (err < 0) {\r\nperror("failed to stat file");\r\nreturn -1;\r\n}\r\nif (!perf_stat.st_size) {\r\nfprintf(stderr, "zero-sized file, nothing to do!\n");\r\nreturn 0;\r\n}\r\nscripting_ops = script_spec__lookup(generate_script_lang);\r\nif (!scripting_ops) {\r\nfprintf(stderr, "invalid language specifier");\r\nreturn -1;\r\n}\r\nerr = scripting_ops->generate_script(session->pevent,\r\n"perf-script");\r\ngoto out;\r\n}\r\nif (script_name) {\r\nerr = scripting_ops->start_script(script_name, argc, argv);\r\nif (err)\r\ngoto out;\r\npr_debug("perf script started with script %s\n\n", script_name);\r\n}\r\nerr = perf_session__check_output_opt(session);\r\nif (err < 0)\r\ngoto out;\r\nerr = __cmd_script(session);\r\nperf_session__delete(session);\r\ncleanup_scripting();\r\nout:\r\nreturn err;\r\n}
