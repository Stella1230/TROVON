static int max1586_v3_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\r\nreturn max1586->v3_curr_sel;\r\n}\r\nstatic int max1586_v3_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = max1586->client;\r\nint ret;\r\nu8 v3_prog;\r\ndev_dbg(&client->dev, "changing voltage v3 to %dmv\n",\r\nregulator_list_voltage_linear(rdev, selector) / 1000);\r\nv3_prog = I2C_V3_SELECT | (u8) selector;\r\nret = i2c_smbus_write_byte(client, v3_prog);\r\nif (ret)\r\nreturn ret;\r\nmax1586->v3_curr_sel = selector;\r\nreturn 0;\r\n}\r\nstatic int max1586_v6_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\r\nreturn max1586->v6_curr_sel;\r\n}\r\nstatic int max1586_v6_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = max1586->client;\r\nu8 v6_prog;\r\nint ret;\r\ndev_dbg(&client->dev, "changing voltage v6 to %dmv\n",\r\nrdev->desc->volt_table[selector] / 1000);\r\nv6_prog = I2C_V6_SELECT | (u8) selector;\r\nret = i2c_smbus_write_byte(client, v6_prog);\r\nif (ret)\r\nreturn ret;\r\nmax1586->v6_curr_sel = selector;\r\nreturn 0;\r\n}\r\nstatic int max1586_pmic_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct regulator_dev **rdev;\r\nstruct max1586_platform_data *pdata = client->dev.platform_data;\r\nstruct regulator_config config = { };\r\nstruct max1586_data *max1586;\r\nint i, id, ret = -ENOMEM;\r\nmax1586 = devm_kzalloc(&client->dev, sizeof(struct max1586_data) +\r\nsizeof(struct regulator_dev *) * (MAX1586_V6 + 1),\r\nGFP_KERNEL);\r\nif (!max1586)\r\nreturn -ENOMEM;\r\nmax1586->client = client;\r\nif (!pdata->v3_gain)\r\nreturn -EINVAL;\r\nmax1586->min_uV = MAX1586_V3_MIN_UV / 1000 * pdata->v3_gain / 1000;\r\nmax1586->max_uV = MAX1586_V3_MAX_UV / 1000 * pdata->v3_gain / 1000;\r\nmax1586->v3_curr_sel = 24;\r\nmax1586->v6_curr_sel = 0;\r\nrdev = max1586->rdev;\r\nfor (i = 0; i < pdata->num_subdevs && i <= MAX1586_V6; i++) {\r\nid = pdata->subdevs[i].id;\r\nif (!pdata->subdevs[i].platform_data)\r\ncontinue;\r\nif (id < MAX1586_V3 || id > MAX1586_V6) {\r\ndev_err(&client->dev, "invalid regulator id %d\n", id);\r\ngoto err;\r\n}\r\nif (id == MAX1586_V3) {\r\nmax1586_reg[id].min_uV = max1586->min_uV;\r\nmax1586_reg[id].uV_step =\r\n(max1586->max_uV - max1586->min_uV) /\r\nMAX1586_V3_MAX_VSEL;\r\n}\r\nconfig.dev = &client->dev;\r\nconfig.init_data = pdata->subdevs[i].platform_data;\r\nconfig.driver_data = max1586;\r\nrdev[i] = regulator_register(&max1586_reg[id], &config);\r\nif (IS_ERR(rdev[i])) {\r\nret = PTR_ERR(rdev[i]);\r\ndev_err(&client->dev, "failed to register %s\n",\r\nmax1586_reg[id].name);\r\ngoto err;\r\n}\r\n}\r\ni2c_set_clientdata(client, max1586);\r\ndev_info(&client->dev, "Maxim 1586 regulator driver loaded\n");\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0)\r\nregulator_unregister(rdev[i]);\r\nreturn ret;\r\n}\r\nstatic int max1586_pmic_remove(struct i2c_client *client)\r\n{\r\nstruct max1586_data *max1586 = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i <= MAX1586_V6; i++)\r\nregulator_unregister(max1586->rdev[i]);\r\nreturn 0;\r\n}\r\nstatic int __init max1586_pmic_init(void)\r\n{\r\nreturn i2c_add_driver(&max1586_pmic_driver);\r\n}\r\nstatic void __exit max1586_pmic_exit(void)\r\n{\r\ni2c_del_driver(&max1586_pmic_driver);\r\n}
