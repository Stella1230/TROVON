static inline void rp2_decode_cap(const struct pci_device_id *id,\r\nint *ports, int *smpte)\r\n{\r\n*ports = id->driver_data >> 8;\r\n*smpte = id->driver_data & 0xff;\r\n}\r\nstatic int rp2_alloc_ports(int n_ports)\r\n{\r\nint ret = -ENOSPC;\r\nspin_lock(&rp2_minor_lock);\r\nif (rp2_minor_next + n_ports <= CONFIG_SERIAL_RP2_NR_UARTS) {\r\nret = rp2_minor_next;\r\nrp2_minor_next += n_ports;\r\n}\r\nspin_unlock(&rp2_minor_lock);\r\nreturn ret;\r\n}\r\nstatic inline struct rp2_uart_port *port_to_up(struct uart_port *port)\r\n{\r\nreturn container_of(port, struct rp2_uart_port, port);\r\n}\r\nstatic void rp2_rmw(struct rp2_uart_port *up, int reg,\r\nu32 clr_bits, u32 set_bits)\r\n{\r\nu32 tmp = readl(up->base + reg);\r\ntmp &= ~clr_bits;\r\ntmp |= set_bits;\r\nwritel(tmp, up->base + reg);\r\n}\r\nstatic void rp2_rmw_clr(struct rp2_uart_port *up, int reg, u32 val)\r\n{\r\nrp2_rmw(up, reg, val, 0);\r\n}\r\nstatic void rp2_rmw_set(struct rp2_uart_port *up, int reg, u32 val)\r\n{\r\nrp2_rmw(up, reg, 0, val);\r\n}\r\nstatic void rp2_mask_ch_irq(struct rp2_uart_port *up, int ch_num,\r\nint is_enabled)\r\n{\r\nunsigned long flags, irq_mask;\r\nspin_lock_irqsave(&up->card->card_lock, flags);\r\nirq_mask = readl(up->asic_base + RP2_CH_IRQ_MASK);\r\nif (is_enabled)\r\nirq_mask &= ~BIT(ch_num);\r\nelse\r\nirq_mask |= BIT(ch_num);\r\nwritel(irq_mask, up->asic_base + RP2_CH_IRQ_MASK);\r\nspin_unlock_irqrestore(&up->card->card_lock, flags);\r\n}\r\nstatic unsigned int rp2_uart_tx_empty(struct uart_port *port)\r\n{\r\nstruct rp2_uart_port *up = port_to_up(port);\r\nunsigned long tx_fifo_bytes, flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\ntx_fifo_bytes = readw(up->base + RP2_TX_FIFO_COUNT);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn tx_fifo_bytes ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int rp2_uart_get_mctrl(struct uart_port *port)\r\n{\r\nstruct rp2_uart_port *up = port_to_up(port);\r\nu32 status;\r\nstatus = readl(up->base + RP2_CHAN_STAT);\r\nreturn ((status & RP2_CHAN_STAT_DCD_m) ? TIOCM_CAR : 0) |\r\n((status & RP2_CHAN_STAT_DSR_m) ? TIOCM_DSR : 0) |\r\n((status & RP2_CHAN_STAT_CTS_m) ? TIOCM_CTS : 0) |\r\n((status & RP2_CHAN_STAT_RI_m) ? TIOCM_RI : 0);\r\n}\r\nstatic void rp2_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nrp2_rmw(port_to_up(port), RP2_TXRX_CTL,\r\nRP2_TXRX_CTL_DTR_m | RP2_TXRX_CTL_RTS_m | RP2_TXRX_CTL_LOOP_m,\r\n((mctrl & TIOCM_DTR) ? RP2_TXRX_CTL_DTR_m : 0) |\r\n((mctrl & TIOCM_RTS) ? RP2_TXRX_CTL_RTS_m : 0) |\r\n((mctrl & TIOCM_LOOP) ? RP2_TXRX_CTL_LOOP_m : 0));\r\n}\r\nstatic void rp2_uart_start_tx(struct uart_port *port)\r\n{\r\nrp2_rmw_set(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_TXIRQ_m);\r\n}\r\nstatic void rp2_uart_stop_tx(struct uart_port *port)\r\n{\r\nrp2_rmw_clr(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_TXIRQ_m);\r\n}\r\nstatic void rp2_uart_stop_rx(struct uart_port *port)\r\n{\r\nrp2_rmw_clr(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_RXIRQ_m);\r\n}\r\nstatic void rp2_uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nrp2_rmw(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_BREAK_m,\r\nbreak_state ? RP2_TXRX_CTL_BREAK_m : 0);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void rp2_uart_enable_ms(struct uart_port *port)\r\n{\r\nrp2_rmw_set(port_to_up(port), RP2_TXRX_CTL, RP2_TXRX_CTL_MSRIRQ_m);\r\n}\r\nstatic void __rp2_uart_set_termios(struct rp2_uart_port *up,\r\nunsigned long cfl,\r\nunsigned long ifl,\r\nunsigned int baud_div)\r\n{\r\nwritew(baud_div - 1, up->base + RP2_BAUD);\r\nrp2_rmw(up, RP2_UART_CTL,\r\nRP2_UART_CTL_STOPBITS_m | RP2_UART_CTL_DATABITS_m,\r\n((cfl & CSTOPB) ? RP2_UART_CTL_STOPBITS_m : 0) |\r\n(((cfl & CSIZE) == CS8) ? RP2_UART_CTL_DATABITS_8 : 0) |\r\n(((cfl & CSIZE) == CS7) ? RP2_UART_CTL_DATABITS_7 : 0) |\r\n(((cfl & CSIZE) == CS6) ? RP2_UART_CTL_DATABITS_6 : 0) |\r\n(((cfl & CSIZE) == CS5) ? RP2_UART_CTL_DATABITS_5 : 0));\r\nrp2_rmw(up, RP2_TXRX_CTL,\r\nRP2_TXRX_CTL_PARENB_m | RP2_TXRX_CTL_nPARODD_m |\r\nRP2_TXRX_CTL_CMSPAR_m | RP2_TXRX_CTL_DTRFLOW_m |\r\nRP2_TXRX_CTL_DSRFLOW_m | RP2_TXRX_CTL_RTSFLOW_m |\r\nRP2_TXRX_CTL_CTSFLOW_m,\r\n((cfl & PARENB) ? RP2_TXRX_CTL_PARENB_m : 0) |\r\n((cfl & PARODD) ? 0 : RP2_TXRX_CTL_nPARODD_m) |\r\n((cfl & CMSPAR) ? RP2_TXRX_CTL_CMSPAR_m : 0) |\r\n((cfl & CRTSCTS) ? (RP2_TXRX_CTL_RTSFLOW_m |\r\nRP2_TXRX_CTL_CTSFLOW_m) : 0));\r\nwriteb((ifl & IXON) ? RP2_TX_SWFLOW_ena : RP2_TX_SWFLOW_dis,\r\nup->ucode + RP2_TX_SWFLOW);\r\nwriteb((ifl & IXOFF) ? RP2_RX_SWFLOW_ena : RP2_RX_SWFLOW_dis,\r\nup->ucode + RP2_RX_SWFLOW);\r\n}\r\nstatic void rp2_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nstruct rp2_uart_port *up = port_to_up(port);\r\nunsigned long flags;\r\nunsigned int baud, baud_div;\r\nbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\r\nbaud_div = uart_get_divisor(port, baud);\r\nif (tty_termios_baud_rate(new))\r\ntty_termios_encode_baud_rate(new, baud, baud);\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->ignore_status_mask = (new->c_cflag & CREAD) ? 0 : RP2_DUMMY_READ;\r\n__rp2_uart_set_termios(up, new->c_cflag, new->c_iflag, baud_div);\r\nuart_update_timeout(port, new->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void rp2_rx_chars(struct rp2_uart_port *up)\r\n{\r\nu16 bytes = readw(up->base + RP2_RX_FIFO_COUNT);\r\nstruct tty_port *port = &up->port.state->port;\r\nfor (; bytes != 0; bytes--) {\r\nu32 byte = readw(up->base + RP2_DATA_BYTE) | RP2_DUMMY_READ;\r\nchar ch = byte & 0xff;\r\nif (likely(!(byte & RP2_DATA_BYTE_EXCEPTION_MASK))) {\r\nif (!uart_handle_sysrq_char(&up->port, ch))\r\nuart_insert_char(&up->port, byte, 0, ch,\r\nTTY_NORMAL);\r\n} else {\r\nchar flag = TTY_NORMAL;\r\nif (byte & RP2_DATA_BYTE_BREAK_m)\r\nflag = TTY_BREAK;\r\nelse if (byte & RP2_DATA_BYTE_ERR_FRAMING_m)\r\nflag = TTY_FRAME;\r\nelse if (byte & RP2_DATA_BYTE_ERR_PARITY_m)\r\nflag = TTY_PARITY;\r\nuart_insert_char(&up->port, byte,\r\nRP2_DATA_BYTE_ERR_OVERRUN_m, ch, flag);\r\n}\r\nup->port.icount.rx++;\r\n}\r\ntty_flip_buffer_push(port);\r\n}\r\nstatic void rp2_tx_chars(struct rp2_uart_port *up)\r\n{\r\nu16 max_tx = FIFO_SIZE - readw(up->base + RP2_TX_FIFO_COUNT);\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nif (uart_tx_stopped(&up->port)) {\r\nrp2_uart_stop_tx(&up->port);\r\nreturn;\r\n}\r\nfor (; max_tx != 0; max_tx--) {\r\nif (up->port.x_char) {\r\nwriteb(up->port.x_char, up->base + RP2_DATA_BYTE);\r\nup->port.x_char = 0;\r\nup->port.icount.tx++;\r\ncontinue;\r\n}\r\nif (uart_circ_empty(xmit)) {\r\nrp2_uart_stop_tx(&up->port);\r\nbreak;\r\n}\r\nwriteb(xmit->buf[xmit->tail], up->base + RP2_DATA_BYTE);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\n}\r\nstatic void rp2_ch_interrupt(struct rp2_uart_port *up)\r\n{\r\nu32 status;\r\nspin_lock(&up->port.lock);\r\nstatus = readl(up->base + RP2_CHAN_STAT);\r\nwritel(status, up->base + RP2_CHAN_STAT);\r\nif (status & RP2_CHAN_STAT_RXDATA_m)\r\nrp2_rx_chars(up);\r\nif (status & RP2_CHAN_STAT_TXEMPTY_m)\r\nrp2_tx_chars(up);\r\nif (status & RP2_CHAN_STAT_MS_CHANGED_MASK)\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\nspin_unlock(&up->port.lock);\r\n}\r\nstatic int rp2_asic_interrupt(struct rp2_card *card, unsigned int asic_id)\r\n{\r\nvoid __iomem *base = card->bar1 + RP2_ASIC_OFFSET(asic_id);\r\nint ch, handled = 0;\r\nunsigned long status = readl(base + RP2_CH_IRQ_STAT) &\r\n~readl(base + RP2_CH_IRQ_MASK);\r\nfor_each_set_bit(ch, &status, PORTS_PER_ASIC) {\r\nrp2_ch_interrupt(&card->ports[ch]);\r\nhandled++;\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t rp2_uart_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rp2_card *card = dev_id;\r\nint handled;\r\nhandled = rp2_asic_interrupt(card, 0);\r\nif (card->n_ports >= PORTS_PER_ASIC)\r\nhandled += rp2_asic_interrupt(card, 1);\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic inline void rp2_flush_fifos(struct rp2_uart_port *up)\r\n{\r\nrp2_rmw_set(up, RP2_UART_CTL,\r\nRP2_UART_CTL_FLUSH_RX_m | RP2_UART_CTL_FLUSH_TX_m);\r\nreadl(up->base + RP2_UART_CTL);\r\nudelay(10);\r\nrp2_rmw_clr(up, RP2_UART_CTL,\r\nRP2_UART_CTL_FLUSH_RX_m | RP2_UART_CTL_FLUSH_TX_m);\r\n}\r\nstatic int rp2_uart_startup(struct uart_port *port)\r\n{\r\nstruct rp2_uart_port *up = port_to_up(port);\r\nrp2_flush_fifos(up);\r\nrp2_rmw(up, RP2_TXRX_CTL, RP2_TXRX_CTL_MSRIRQ_m, RP2_TXRX_CTL_RXIRQ_m);\r\nrp2_rmw(up, RP2_TXRX_CTL, RP2_TXRX_CTL_RX_TRIG_m,\r\nRP2_TXRX_CTL_RX_TRIG_1);\r\nrp2_rmw(up, RP2_CHAN_STAT, 0, 0);\r\nrp2_mask_ch_irq(up, up->idx, 1);\r\nreturn 0;\r\n}\r\nstatic void rp2_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct rp2_uart_port *up = port_to_up(port);\r\nunsigned long flags;\r\nrp2_uart_break_ctl(port, 0);\r\nspin_lock_irqsave(&port->lock, flags);\r\nrp2_mask_ch_irq(up, up->idx, 0);\r\nrp2_rmw(up, RP2_CHAN_STAT, 0, 0);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *rp2_uart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_RP2) ? "RocketPort 2 UART" : NULL;\r\n}\r\nstatic void rp2_uart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int rp2_uart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void rp2_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_RP2;\r\n}\r\nstatic int rp2_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_RP2)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void rp2_reset_asic(struct rp2_card *card, unsigned int asic_id)\r\n{\r\nvoid __iomem *base = card->bar1 + RP2_ASIC_OFFSET(asic_id);\r\nu32 clk_cfg;\r\nwritew(1, base + RP2_GLOBAL_CMD);\r\nreadw(base + RP2_GLOBAL_CMD);\r\nmsleep(100);\r\nwritel(0, base + RP2_CLK_PRESCALER);\r\nclk_cfg = readw(base + RP2_ASIC_CFG);\r\nclk_cfg = (clk_cfg & ~BIT(8)) | BIT(9);\r\nwritew(clk_cfg, base + RP2_ASIC_CFG);\r\nwritel(ALL_PORTS_MASK, base + RP2_CH_IRQ_MASK);\r\nwritel(RP2_ASIC_IRQ_EN_m, base + RP2_ASIC_IRQ);\r\n}\r\nstatic void rp2_init_card(struct rp2_card *card)\r\n{\r\nwritel(4, card->bar0 + RP2_FPGA_CTL0);\r\nwritel(0, card->bar0 + RP2_FPGA_CTL1);\r\nrp2_reset_asic(card, 0);\r\nif (card->n_ports >= PORTS_PER_ASIC)\r\nrp2_reset_asic(card, 1);\r\nwritel(RP2_IRQ_MASK_EN_m, card->bar0 + RP2_IRQ_MASK);\r\n}\r\nstatic void rp2_init_port(struct rp2_uart_port *up, const struct firmware *fw)\r\n{\r\nint i;\r\nwritel(RP2_UART_CTL_RESET_CH_m, up->base + RP2_UART_CTL);\r\nreadl(up->base + RP2_UART_CTL);\r\nudelay(1);\r\nwritel(0, up->base + RP2_TXRX_CTL);\r\nwritel(0, up->base + RP2_UART_CTL);\r\nreadl(up->base + RP2_UART_CTL);\r\nudelay(1);\r\nrp2_flush_fifos(up);\r\nfor (i = 0; i < min_t(int, fw->size, RP2_UCODE_BYTES); i++)\r\nwriteb(fw->data[i], up->ucode + i);\r\n__rp2_uart_set_termios(up, CS8 | CREAD | CLOCAL, 0, DEFAULT_BAUD_DIV);\r\nrp2_uart_set_mctrl(&up->port, 0);\r\nwriteb(RP2_RX_FIFO_ena, up->ucode + RP2_RX_FIFO);\r\nrp2_rmw(up, RP2_UART_CTL, RP2_UART_CTL_MODE_m,\r\nRP2_UART_CTL_XMIT_EN_m | RP2_UART_CTL_MODE_rs232);\r\nrp2_rmw_set(up, RP2_TXRX_CTL,\r\nRP2_TXRX_CTL_TX_EN_m | RP2_TXRX_CTL_RX_EN_m);\r\n}\r\nstatic void rp2_remove_ports(struct rp2_card *card)\r\n{\r\nint i;\r\nfor (i = 0; i < card->initialized_ports; i++)\r\nuart_remove_one_port(&rp2_uart_driver, &card->ports[i].port);\r\ncard->initialized_ports = 0;\r\n}\r\nstatic void rp2_fw_cb(const struct firmware *fw, void *context)\r\n{\r\nstruct rp2_card *card = context;\r\nresource_size_t phys_base;\r\nint i, rc = -ENOENT;\r\nif (!fw) {\r\ndev_err(&card->pdev->dev, "cannot find '%s' firmware image\n",\r\nRP2_FW_NAME);\r\ngoto no_fw;\r\n}\r\nphys_base = pci_resource_start(card->pdev, 1);\r\nfor (i = 0; i < card->n_ports; i++) {\r\nstruct rp2_uart_port *rp = &card->ports[i];\r\nstruct uart_port *p;\r\nint j = (unsigned)i % PORTS_PER_ASIC;\r\nrp->asic_base = card->bar1;\r\nrp->base = card->bar1 + RP2_PORT_BASE + j*RP2_PORT_SPACING;\r\nrp->ucode = card->bar1 + RP2_UCODE_BASE + j*RP2_UCODE_SPACING;\r\nrp->card = card;\r\nrp->idx = j;\r\np = &rp->port;\r\np->line = card->minor_start + i;\r\np->dev = &card->pdev->dev;\r\np->type = PORT_RP2;\r\np->iotype = UPIO_MEM32;\r\np->uartclk = UART_CLOCK;\r\np->regshift = 2;\r\np->fifosize = FIFO_SIZE;\r\np->ops = &rp2_uart_ops;\r\np->irq = card->pdev->irq;\r\np->membase = rp->base;\r\np->mapbase = phys_base + RP2_PORT_BASE + j*RP2_PORT_SPACING;\r\nif (i >= PORTS_PER_ASIC) {\r\nrp->asic_base += RP2_ASIC_SPACING;\r\nrp->base += RP2_ASIC_SPACING;\r\nrp->ucode += RP2_ASIC_SPACING;\r\np->mapbase += RP2_ASIC_SPACING;\r\n}\r\nrp2_init_port(rp, fw);\r\nrc = uart_add_one_port(&rp2_uart_driver, p);\r\nif (rc) {\r\ndev_err(&card->pdev->dev,\r\n"error registering port %d: %d\n", i, rc);\r\nrp2_remove_ports(card);\r\nbreak;\r\n}\r\ncard->initialized_ports++;\r\n}\r\nrelease_firmware(fw);\r\nno_fw:\r\nif (rc)\r\ndev_warn(&card->pdev->dev, "driver initialization failed\n");\r\ncomplete(&card->fw_loaded);\r\n}\r\nstatic int rp2_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct rp2_card *card;\r\nstruct rp2_uart_port *ports;\r\nvoid __iomem * const *bars;\r\nint rc;\r\ncard = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);\r\nif (!card)\r\nreturn -ENOMEM;\r\npci_set_drvdata(pdev, card);\r\nspin_lock_init(&card->card_lock);\r\ninit_completion(&card->fw_loaded);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions_request_all(pdev, 0x03, DRV_NAME);\r\nif (rc)\r\nreturn rc;\r\nbars = pcim_iomap_table(pdev);\r\ncard->bar0 = bars[0];\r\ncard->bar1 = bars[1];\r\ncard->pdev = pdev;\r\nrp2_decode_cap(id, &card->n_ports, &card->smpte);\r\ndev_info(&pdev->dev, "found new card with %d ports\n", card->n_ports);\r\ncard->minor_start = rp2_alloc_ports(card->n_ports);\r\nif (card->minor_start < 0) {\r\ndev_err(&pdev->dev,\r\n"too many ports (try increasing CONFIG_SERIAL_RP2_NR_UARTS)\n");\r\nreturn -EINVAL;\r\n}\r\nrp2_init_card(card);\r\nports = devm_kzalloc(&pdev->dev, sizeof(*ports) * card->n_ports,\r\nGFP_KERNEL);\r\nif (!ports)\r\nreturn -ENOMEM;\r\ncard->ports = ports;\r\nrc = devm_request_irq(&pdev->dev, pdev->irq, rp2_uart_interrupt,\r\nIRQF_SHARED, DRV_NAME, card);\r\nif (rc)\r\nreturn rc;\r\nrc = request_firmware_nowait(THIS_MODULE, 1, RP2_FW_NAME, &pdev->dev,\r\nGFP_KERNEL, card, rp2_fw_cb);\r\nif (rc)\r\nreturn rc;\r\ndev_dbg(&pdev->dev, "waiting for firmware blob...\n");\r\nreturn 0;\r\n}\r\nstatic void rp2_remove(struct pci_dev *pdev)\r\n{\r\nstruct rp2_card *card = pci_get_drvdata(pdev);\r\nwait_for_completion(&card->fw_loaded);\r\nrp2_remove_ports(card);\r\n}\r\nstatic int __init rp2_uart_init(void)\r\n{\r\nint rc;\r\nrc = uart_register_driver(&rp2_uart_driver);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_register_driver(&rp2_pci_driver);\r\nif (rc) {\r\nuart_unregister_driver(&rp2_uart_driver);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit rp2_uart_exit(void)\r\n{\r\npci_unregister_driver(&rp2_pci_driver);\r\nuart_unregister_driver(&rp2_uart_driver);\r\n}
