void imx_udc_enable(struct imx_udc_struct *imx_usb)\r\n{\r\nint temp = __raw_readl(imx_usb->base + USB_CTRL);\r\n__raw_writel(temp | CTRL_FE_ENA | CTRL_AFE_ENA,\r\nimx_usb->base + USB_CTRL);\r\nimx_usb->gadget.speed = USB_SPEED_FULL;\r\n}\r\nvoid imx_udc_disable(struct imx_udc_struct *imx_usb)\r\n{\r\nint temp = __raw_readl(imx_usb->base + USB_CTRL);\r\n__raw_writel(temp & ~(CTRL_FE_ENA | CTRL_AFE_ENA),\r\nimx_usb->base + USB_CTRL);\r\nep0_chg_stat(__func__, imx_usb, EP0_IDLE);\r\nimx_usb->gadget.speed = USB_SPEED_UNKNOWN;\r\n}\r\nvoid imx_udc_reset(struct imx_udc_struct *imx_usb)\r\n{\r\nint temp = __raw_readl(imx_usb->base + USB_ENAB);\r\n__raw_writel(temp | ENAB_RST, imx_usb->base + USB_ENAB);\r\ndo {} while (__raw_readl(imx_usb->base + USB_ENAB) & ENAB_RST);\r\ndo {} while (!(__raw_readl(imx_usb->base + USB_DADR) & DADR_CFG));\r\n}\r\nvoid imx_udc_config(struct imx_udc_struct *imx_usb)\r\n{\r\nu8 ep_conf[5];\r\nu8 i, j, cfg;\r\nstruct imx_ep_struct *imx_ep;\r\ndo {} while (!(__raw_readl(imx_usb->base + USB_DADR) & DADR_CFG));\r\nfor (j = 0; j < 5; j++) {\r\ni = (j == 2 ? imx_usb->imx_ep[0].fifosize : 0x00);\r\n__raw_writeb(i, imx_usb->base + USB_DDAT);\r\ndo {} while (__raw_readl(imx_usb->base + USB_DADR) & DADR_BSY);\r\n}\r\nfor (cfg = 1; cfg < 3; cfg++) {\r\nfor (i = 1; i < IMX_USB_NB_EP; i++) {\r\nimx_ep = &imx_usb->imx_ep[i];\r\nep_conf[0] = (i << 4) | (cfg << 2);\r\nep_conf[1] = (imx_ep->bmAttributes << 3) |\r\n(EP_DIR(imx_ep) << 2);\r\nep_conf[2] = imx_ep->fifosize;\r\nep_conf[3] = 0xC0;\r\nep_conf[4] = i;\r\nD_INI(imx_usb->dev,\r\n"<%s> ep%d_conf[%d]:"\r\n"[%02x-%02x-%02x-%02x-%02x]\n",\r\n__func__, i, cfg,\r\nep_conf[0], ep_conf[1], ep_conf[2],\r\nep_conf[3], ep_conf[4]);\r\nfor (j = 0; j < 5; j++) {\r\n__raw_writeb(ep_conf[j],\r\nimx_usb->base + USB_DDAT);\r\ndo {} while (__raw_readl(imx_usb->base\r\n+ USB_DADR)\r\n& DADR_BSY);\r\n}\r\n}\r\n}\r\ndo {} while (__raw_readl(imx_usb->base + USB_DADR) & DADR_CFG);\r\n}\r\nvoid imx_udc_init_irq(struct imx_udc_struct *imx_usb)\r\n{\r\nint i;\r\n__raw_writel(0xFFFFFFFF, imx_usb->base + USB_MASK);\r\n__raw_writel(0xFFFFFFFF, imx_usb->base + USB_INTR);\r\nfor (i = 0; i < IMX_USB_NB_EP; i++) {\r\n__raw_writel(0x1FF, imx_usb->base + USB_EP_MASK(i));\r\n__raw_writel(0x1FF, imx_usb->base + USB_EP_INTR(i));\r\n}\r\n__raw_writel(INTR_MSOF | INTR_FRAME_MATCH, imx_usb->base + USB_MASK);\r\n__raw_writel(0x1FF & ~(EPINTR_DEVREQ | EPINTR_MDEVREQ | EPINTR_EOT\r\n| EPINTR_EOF | EPINTR_FIFO_EMPTY | EPINTR_FIFO_FULL),\r\nimx_usb->base + USB_EP_MASK(0));\r\n}\r\nvoid imx_udc_init_ep(struct imx_udc_struct *imx_usb)\r\n{\r\nint i, max, temp;\r\nstruct imx_ep_struct *imx_ep;\r\nfor (i = 0; i < IMX_USB_NB_EP; i++) {\r\nimx_ep = &imx_usb->imx_ep[i];\r\nswitch (imx_ep->fifosize) {\r\ncase 8:\r\nmax = 0;\r\nbreak;\r\ncase 16:\r\nmax = 1;\r\nbreak;\r\ncase 32:\r\nmax = 2;\r\nbreak;\r\ncase 64:\r\nmax = 3;\r\nbreak;\r\ndefault:\r\nmax = 1;\r\nbreak;\r\n}\r\ntemp = (EP_DIR(imx_ep) << 7) | (max << 5)\r\n| (imx_ep->bmAttributes << 3);\r\n__raw_writel(temp, imx_usb->base + USB_EP_STAT(i));\r\n__raw_writel(temp | EPSTAT_FLUSH,\r\nimx_usb->base + USB_EP_STAT(i));\r\nD_INI(imx_usb->dev, "<%s> ep%d_stat %08x\n", __func__, i,\r\n__raw_readl(imx_usb->base + USB_EP_STAT(i)));\r\n}\r\n}\r\nvoid imx_udc_init_fifo(struct imx_udc_struct *imx_usb)\r\n{\r\nint i, temp;\r\nstruct imx_ep_struct *imx_ep;\r\nfor (i = 0; i < IMX_USB_NB_EP; i++) {\r\nimx_ep = &imx_usb->imx_ep[i];\r\ntemp = EP_DIR(imx_ep) ? 0x0B000000 : 0x0F000000;\r\n__raw_writel(temp, imx_usb->base + USB_EP_FCTRL(i));\r\nD_INI(imx_usb->dev, "<%s> ep%d_fctrl %08x\n", __func__, i,\r\n__raw_readl(imx_usb->base + USB_EP_FCTRL(i)));\r\ntemp = (i ? imx_ep->fifosize / 2 : 0);\r\n__raw_writel(temp, imx_usb->base + USB_EP_FALRM(i));\r\nD_INI(imx_usb->dev, "<%s> ep%d_falrm %08x\n", __func__, i,\r\n__raw_readl(imx_usb->base + USB_EP_FALRM(i)));\r\n}\r\n}\r\nstatic void imx_udc_init(struct imx_udc_struct *imx_usb)\r\n{\r\nimx_udc_reset(imx_usb);\r\nimx_udc_config(imx_usb);\r\nimx_udc_init_irq(imx_usb);\r\nimx_udc_init_ep(imx_usb);\r\nimx_udc_init_fifo(imx_usb);\r\n}\r\nvoid imx_ep_irq_enable(struct imx_ep_struct *imx_ep)\r\n{\r\nint i = EP_NO(imx_ep);\r\n__raw_writel(0x1FF, imx_ep->imx_usb->base + USB_EP_MASK(i));\r\n__raw_writel(0x1FF, imx_ep->imx_usb->base + USB_EP_INTR(i));\r\n__raw_writel(0x1FF & ~(EPINTR_EOT | EPINTR_EOF),\r\nimx_ep->imx_usb->base + USB_EP_MASK(i));\r\n}\r\nvoid imx_ep_irq_disable(struct imx_ep_struct *imx_ep)\r\n{\r\nint i = EP_NO(imx_ep);\r\n__raw_writel(0x1FF, imx_ep->imx_usb->base + USB_EP_MASK(i));\r\n__raw_writel(0x1FF, imx_ep->imx_usb->base + USB_EP_INTR(i));\r\n}\r\nint imx_ep_empty(struct imx_ep_struct *imx_ep)\r\n{\r\nstruct imx_udc_struct *imx_usb = imx_ep->imx_usb;\r\nreturn __raw_readl(imx_usb->base + USB_EP_FSTAT(EP_NO(imx_ep)))\r\n& FSTAT_EMPTY;\r\n}\r\nunsigned imx_fifo_bcount(struct imx_ep_struct *imx_ep)\r\n{\r\nstruct imx_udc_struct *imx_usb = imx_ep->imx_usb;\r\nreturn (__raw_readl(imx_usb->base + USB_EP_STAT(EP_NO(imx_ep)))\r\n& EPSTAT_BCOUNT) >> 16;\r\n}\r\nvoid imx_flush(struct imx_ep_struct *imx_ep)\r\n{\r\nstruct imx_udc_struct *imx_usb = imx_ep->imx_usb;\r\nint temp = __raw_readl(imx_usb->base + USB_EP_STAT(EP_NO(imx_ep)));\r\n__raw_writel(temp | EPSTAT_FLUSH,\r\nimx_usb->base + USB_EP_STAT(EP_NO(imx_ep)));\r\n}\r\nvoid imx_ep_stall(struct imx_ep_struct *imx_ep)\r\n{\r\nstruct imx_udc_struct *imx_usb = imx_ep->imx_usb;\r\nint temp, i;\r\nD_ERR(imx_usb->dev,\r\n"<%s> Forced stall on %s\n", __func__, imx_ep->ep.name);\r\nimx_flush(imx_ep);\r\nif (!EP_NO(imx_ep)) {\r\ntemp = __raw_readl(imx_usb->base + USB_CTRL);\r\n__raw_writel(temp | CTRL_CMDOVER | CTRL_CMDERROR,\r\nimx_usb->base + USB_CTRL);\r\ndo { } while (__raw_readl(imx_usb->base + USB_CTRL)\r\n& CTRL_CMDOVER);\r\ntemp = __raw_readl(imx_usb->base + USB_CTRL);\r\n__raw_writel(temp & ~CTRL_CMDERROR, imx_usb->base + USB_CTRL);\r\n}\r\nelse {\r\ntemp = __raw_readl(imx_usb->base + USB_EP_STAT(EP_NO(imx_ep)));\r\n__raw_writel(temp | EPSTAT_STALL,\r\nimx_usb->base + USB_EP_STAT(EP_NO(imx_ep)));\r\nfor (i = 0; i < 100; i ++) {\r\ntemp = __raw_readl(imx_usb->base\r\n+ USB_EP_STAT(EP_NO(imx_ep)));\r\nif (!(temp & EPSTAT_STALL))\r\nbreak;\r\nudelay(20);\r\n}\r\nif (i == 100)\r\nD_ERR(imx_usb->dev, "<%s> Non finished stall on %s\n",\r\n__func__, imx_ep->ep.name);\r\n}\r\n}\r\nstatic int imx_udc_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct imx_udc_struct *imx_usb = container_of(_gadget,\r\nstruct imx_udc_struct, gadget);\r\nreturn __raw_readl(imx_usb->base + USB_FRAME) & 0x7FF;\r\n}\r\nstatic int imx_udc_wakeup(struct usb_gadget *_gadget)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ep_add_request(struct imx_ep_struct *imx_ep,\r\nstruct imx_request *req)\r\n{\r\nif (unlikely(!req))\r\nreturn;\r\nreq->in_use = 1;\r\nlist_add_tail(&req->queue, &imx_ep->queue);\r\n}\r\nstatic void ep_del_request(struct imx_ep_struct *imx_ep,\r\nstruct imx_request *req)\r\n{\r\nif (unlikely(!req))\r\nreturn;\r\nlist_del_init(&req->queue);\r\nreq->in_use = 0;\r\n}\r\nstatic void done(struct imx_ep_struct *imx_ep,\r\nstruct imx_request *req, int status)\r\n{\r\nep_del_request(imx_ep, req);\r\nif (likely(req->req.status == -EINPROGRESS))\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nif (status && status != -ESHUTDOWN)\r\nD_ERR(imx_ep->imx_usb->dev,\r\n"<%s> complete %s req %p stat %d len %u/%u\n", __func__,\r\nimx_ep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length);\r\nreq->req.complete(&imx_ep->ep, &req->req);\r\n}\r\nstatic void nuke(struct imx_ep_struct *imx_ep, int status)\r\n{\r\nstruct imx_request *req;\r\nwhile (!list_empty(&imx_ep->queue)) {\r\nreq = list_entry(imx_ep->queue.next, struct imx_request, queue);\r\ndone(imx_ep, req, status);\r\n}\r\n}\r\nstatic int read_packet(struct imx_ep_struct *imx_ep, struct imx_request *req)\r\n{\r\nu8 *buf;\r\nint bytes_ep, bufferspace, count, i;\r\nbytes_ep = imx_fifo_bcount(imx_ep);\r\nbufferspace = req->req.length - req->req.actual;\r\nbuf = req->req.buf + req->req.actual;\r\nprefetchw(buf);\r\nif (unlikely(imx_ep_empty(imx_ep)))\r\ncount = 0;\r\nelse\r\ncount = min(bytes_ep, bufferspace);\r\nfor (i = count; i > 0; i--)\r\n*buf++ = __raw_readb(imx_ep->imx_usb->base\r\n+ USB_EP_FDAT0(EP_NO(imx_ep)));\r\nreq->req.actual += count;\r\nreturn count;\r\n}\r\nstatic int write_packet(struct imx_ep_struct *imx_ep, struct imx_request *req)\r\n{\r\nu8 *buf;\r\nint length, count, temp;\r\nif (unlikely(__raw_readl(imx_ep->imx_usb->base +\r\nUSB_EP_STAT(EP_NO(imx_ep))) & EPSTAT_ZLPS)) {\r\nD_TRX(imx_ep->imx_usb->dev, "<%s> zlp still queued in EP %s\n",\r\n__func__, imx_ep->ep.name);\r\nreturn -1;\r\n}\r\nbuf = req->req.buf + req->req.actual;\r\nprefetch(buf);\r\nlength = min(req->req.length - req->req.actual, (u32)imx_ep->fifosize);\r\nif (imx_fifo_bcount(imx_ep) + length > imx_ep->fifosize) {\r\nD_TRX(imx_ep->imx_usb->dev, "<%s> packet overfill %s fifo\n",\r\n__func__, imx_ep->ep.name);\r\nreturn -1;\r\n}\r\nreq->req.actual += length;\r\ncount = length;\r\nif (!count && req->req.zero) {\r\ntemp = __raw_readl(imx_ep->imx_usb->base\r\n+ USB_EP_STAT(EP_NO(imx_ep)));\r\n__raw_writel(temp | EPSTAT_ZLPS, imx_ep->imx_usb->base\r\n+ USB_EP_STAT(EP_NO(imx_ep)));\r\nD_TRX(imx_ep->imx_usb->dev, "<%s> zero packet\n", __func__);\r\nreturn 0;\r\n}\r\nwhile (count--) {\r\nif (count == 0) {\r\ntemp = __raw_readl(imx_ep->imx_usb->base\r\n+ USB_EP_FCTRL(EP_NO(imx_ep)));\r\n__raw_writel(temp | FCTRL_WFR, imx_ep->imx_usb->base\r\n+ USB_EP_FCTRL(EP_NO(imx_ep)));\r\n}\r\n__raw_writeb(*buf++,\r\nimx_ep->imx_usb->base + USB_EP_FDAT0(EP_NO(imx_ep)));\r\n}\r\nreturn length;\r\n}\r\nstatic int read_fifo(struct imx_ep_struct *imx_ep, struct imx_request *req)\r\n{\r\nint bytes = 0,\r\ncount,\r\ncompleted = 0;\r\nwhile (__raw_readl(imx_ep->imx_usb->base + USB_EP_FSTAT(EP_NO(imx_ep)))\r\n& FSTAT_FR) {\r\ncount = read_packet(imx_ep, req);\r\nbytes += count;\r\ncompleted = (count != imx_ep->fifosize);\r\nif (completed || req->req.actual == req->req.length) {\r\ncompleted = 1;\r\nbreak;\r\n}\r\n}\r\nif (completed || !req->req.length) {\r\ndone(imx_ep, req, 0);\r\nD_REQ(imx_ep->imx_usb->dev, "<%s> %s req<%p> %s\n",\r\n__func__, imx_ep->ep.name, req,\r\ncompleted ? "completed" : "not completed");\r\nif (!EP_NO(imx_ep))\r\nep0_chg_stat(__func__, imx_ep->imx_usb, EP0_IDLE);\r\n}\r\nD_TRX(imx_ep->imx_usb->dev, "<%s> bytes read: %d\n", __func__, bytes);\r\nreturn completed;\r\n}\r\nstatic int write_fifo(struct imx_ep_struct *imx_ep, struct imx_request *req)\r\n{\r\nint bytes = 0,\r\ncount,\r\ncompleted = 0;\r\nwhile (!completed) {\r\ncount = write_packet(imx_ep, req);\r\nif (count < 0)\r\nbreak;\r\nbytes += count;\r\ncompleted = (count != imx_ep->fifosize);\r\nif (unlikely(completed)) {\r\ndone(imx_ep, req, 0);\r\nD_REQ(imx_ep->imx_usb->dev, "<%s> %s req<%p> %s\n",\r\n__func__, imx_ep->ep.name, req,\r\ncompleted ? "completed" : "not completed");\r\nif (!EP_NO(imx_ep))\r\nep0_chg_stat(__func__,\r\nimx_ep->imx_usb, EP0_IDLE);\r\n}\r\n}\r\nD_TRX(imx_ep->imx_usb->dev, "<%s> bytes sent: %d\n", __func__, bytes);\r\nreturn completed;\r\n}\r\nstatic int handle_ep(struct imx_ep_struct *imx_ep)\r\n{\r\nstruct imx_request *req;\r\nint completed = 0;\r\ndo {\r\nif (!list_empty(&imx_ep->queue))\r\nreq = list_entry(imx_ep->queue.next,\r\nstruct imx_request, queue);\r\nelse {\r\nD_REQ(imx_ep->imx_usb->dev, "<%s> no request on %s\n",\r\n__func__, imx_ep->ep.name);\r\nreturn 0;\r\n}\r\nif (EP_DIR(imx_ep))\r\ncompleted = write_fifo(imx_ep, req);\r\nelse\r\ncompleted = read_fifo(imx_ep, req);\r\ndump_ep_stat(__func__, imx_ep);\r\n} while (completed);\r\nreturn 0;\r\n}\r\nstatic int handle_ep0(struct imx_ep_struct *imx_ep)\r\n{\r\nstruct imx_request *req = NULL;\r\nint ret = 0;\r\nif (!list_empty(&imx_ep->queue)) {\r\nreq = list_entry(imx_ep->queue.next, struct imx_request, queue);\r\nswitch (imx_ep->imx_usb->ep0state) {\r\ncase EP0_IN_DATA_PHASE:\r\nwrite_fifo(imx_ep, req);\r\nbreak;\r\ncase EP0_OUT_DATA_PHASE:\r\nread_fifo(imx_ep, req);\r\nbreak;\r\ndefault:\r\nD_EP0(imx_ep->imx_usb->dev,\r\n"<%s> ep0 i/o, odd state %d\n",\r\n__func__, imx_ep->imx_usb->ep0state);\r\nep_del_request(imx_ep, req);\r\nret = -EL2HLT;\r\nbreak;\r\n}\r\n}\r\nelse\r\nD_ERR(imx_ep->imx_usb->dev, "<%s> no request on %s\n",\r\n__func__, imx_ep->ep.name);\r\nreturn ret;\r\n}\r\nstatic void handle_ep0_devreq(struct imx_udc_struct *imx_usb)\r\n{\r\nstruct imx_ep_struct *imx_ep = &imx_usb->imx_ep[0];\r\nunion {\r\nstruct usb_ctrlrequest r;\r\nu8 raw[8];\r\nu32 word[2];\r\n} u;\r\nint temp, i;\r\nnuke(imx_ep, -EPROTO);\r\nfor (i = 0; i < 2; i++) {\r\nif (imx_ep_empty(imx_ep)) {\r\nD_ERR(imx_usb->dev,\r\n"<%s> no setup packet received\n", __func__);\r\ngoto stall;\r\n}\r\nu.word[i] = __raw_readl(imx_usb->base\r\n+ USB_EP_FDAT(EP_NO(imx_ep)));\r\n}\r\ntemp = imx_ep_empty(imx_ep);\r\nwhile (!imx_ep_empty(imx_ep)) {\r\ni = __raw_readl(imx_usb->base + USB_EP_FDAT(EP_NO(imx_ep)));\r\nD_ERR(imx_usb->dev,\r\n"<%s> wrong to have extra bytes for setup : 0x%08x\n",\r\n__func__, i);\r\n}\r\nif (!temp)\r\ngoto stall;\r\nle16_to_cpus(&u.r.wValue);\r\nle16_to_cpus(&u.r.wIndex);\r\nle16_to_cpus(&u.r.wLength);\r\nD_REQ(imx_usb->dev, "<%s> SETUP %02x.%02x v%04x i%04x l%04x\n",\r\n__func__, u.r.bRequestType, u.r.bRequest,\r\nu.r.wValue, u.r.wIndex, u.r.wLength);\r\nif (imx_usb->set_config) {\r\ntemp = __raw_readl(imx_usb->base + USB_CTRL);\r\n__raw_writel(temp | CTRL_CMDOVER, imx_usb->base + USB_CTRL);\r\nD_ERR(imx_usb->dev,\r\n"<%s> set config req is pending, NACK the host\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (u.r.bRequestType & USB_DIR_IN)\r\nep0_chg_stat(__func__, imx_usb, EP0_IN_DATA_PHASE);\r\nelse\r\nep0_chg_stat(__func__, imx_usb, EP0_OUT_DATA_PHASE);\r\ni = imx_usb->driver->setup(&imx_usb->gadget, &u.r);\r\nif (i < 0) {\r\nD_ERR(imx_usb->dev, "<%s> device setup error %d\n",\r\n__func__, i);\r\ngoto stall;\r\n}\r\nreturn;\r\nstall:\r\nD_ERR(imx_usb->dev, "<%s> protocol STALL\n", __func__);\r\nimx_ep_stall(imx_ep);\r\nep0_chg_stat(__func__, imx_usb, EP0_STALL);\r\nreturn;\r\n}\r\nstatic int imx_ep_enable(struct usb_ep *usb_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct imx_ep_struct *imx_ep = container_of(usb_ep,\r\nstruct imx_ep_struct, ep);\r\nstruct imx_udc_struct *imx_usb = imx_ep->imx_usb;\r\nunsigned long flags;\r\nif (!usb_ep\r\n|| !desc\r\n|| !EP_NO(imx_ep)\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT\r\n|| imx_ep->bEndpointAddress != desc->bEndpointAddress) {\r\nD_ERR(imx_usb->dev,\r\n"<%s> bad ep or descriptor\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (imx_ep->bmAttributes != desc->bmAttributes) {\r\nD_ERR(imx_usb->dev,\r\n"<%s> %s type mismatch\n", __func__, usb_ep->name);\r\nreturn -EINVAL;\r\n}\r\nif (imx_ep->fifosize < usb_endpoint_maxp(desc)) {\r\nD_ERR(imx_usb->dev,\r\n"<%s> bad %s maxpacket\n", __func__, usb_ep->name);\r\nreturn -ERANGE;\r\n}\r\nif (!imx_usb->driver || imx_usb->gadget.speed == USB_SPEED_UNKNOWN) {\r\nD_ERR(imx_usb->dev, "<%s> bogus device state\n", __func__);\r\nreturn -ESHUTDOWN;\r\n}\r\nlocal_irq_save(flags);\r\nimx_ep->stopped = 0;\r\nimx_flush(imx_ep);\r\nimx_ep_irq_enable(imx_ep);\r\nlocal_irq_restore(flags);\r\nD_EPX(imx_usb->dev, "<%s> ENABLED %s\n", __func__, usb_ep->name);\r\nreturn 0;\r\n}\r\nstatic int imx_ep_disable(struct usb_ep *usb_ep)\r\n{\r\nstruct imx_ep_struct *imx_ep = container_of(usb_ep,\r\nstruct imx_ep_struct, ep);\r\nunsigned long flags;\r\nif (!usb_ep || !EP_NO(imx_ep) || !list_empty(&imx_ep->queue)) {\r\nD_ERR(imx_ep->imx_usb->dev, "<%s> %s can not be disabled\n",\r\n__func__, usb_ep ? imx_ep->ep.name : NULL);\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nimx_ep->stopped = 1;\r\nnuke(imx_ep, -ESHUTDOWN);\r\nimx_flush(imx_ep);\r\nimx_ep_irq_disable(imx_ep);\r\nlocal_irq_restore(flags);\r\nD_EPX(imx_ep->imx_usb->dev,\r\n"<%s> DISABLED %s\n", __func__, usb_ep->name);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *imx_ep_alloc_request\r\n(struct usb_ep *usb_ep, gfp_t gfp_flags)\r\n{\r\nstruct imx_request *req;\r\nif (!usb_ep)\r\nreturn NULL;\r\nreq = kzalloc(sizeof *req, gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreq->in_use = 0;\r\nreturn &req->req;\r\n}\r\nstatic void imx_ep_free_request\r\n(struct usb_ep *usb_ep, struct usb_request *usb_req)\r\n{\r\nstruct imx_request *req;\r\nreq = container_of(usb_req, struct imx_request, req);\r\nWARN_ON(!list_empty(&req->queue));\r\nkfree(req);\r\n}\r\nstatic int imx_ep_queue\r\n(struct usb_ep *usb_ep, struct usb_request *usb_req, gfp_t gfp_flags)\r\n{\r\nstruct imx_ep_struct *imx_ep;\r\nstruct imx_udc_struct *imx_usb;\r\nstruct imx_request *req;\r\nunsigned long flags;\r\nint ret = 0;\r\nimx_ep = container_of(usb_ep, struct imx_ep_struct, ep);\r\nimx_usb = imx_ep->imx_usb;\r\nreq = container_of(usb_req, struct imx_request, req);\r\nif (imx_usb->set_config && !EP_NO(imx_ep)) {\r\nimx_usb->set_config = 0;\r\nD_ERR(imx_usb->dev,\r\n"<%s> gadget reply set config\n", __func__);\r\nreturn 0;\r\n}\r\nif (unlikely(!usb_req || !req || !usb_req->complete || !usb_req->buf)) {\r\nD_ERR(imx_usb->dev, "<%s> bad params\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!usb_ep || !imx_ep)) {\r\nD_ERR(imx_usb->dev, "<%s> bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!imx_usb->driver || imx_usb->gadget.speed == USB_SPEED_UNKNOWN) {\r\nD_ERR(imx_usb->dev, "<%s> bogus device state\n", __func__);\r\nreturn -ESHUTDOWN;\r\n}\r\nD_REQ(imx_usb->dev, "<%s> ep%d %s request for [%d] bytes\n",\r\n__func__, EP_NO(imx_ep),\r\n((!EP_NO(imx_ep) && imx_ep->imx_usb->ep0state\r\n== EP0_IN_DATA_PHASE)\r\n|| (EP_NO(imx_ep) && EP_DIR(imx_ep)))\r\n? "IN" : "OUT", usb_req->length);\r\ndump_req(__func__, imx_ep, usb_req);\r\nif (imx_ep->stopped) {\r\nusb_req->status = -ESHUTDOWN;\r\nreturn -ESHUTDOWN;\r\n}\r\nif (req->in_use) {\r\nD_ERR(imx_usb->dev,\r\n"<%s> refusing to queue req %p (already queued)\n",\r\n__func__, req);\r\nreturn 0;\r\n}\r\nlocal_irq_save(flags);\r\nusb_req->status = -EINPROGRESS;\r\nusb_req->actual = 0;\r\nep_add_request(imx_ep, req);\r\nif (!EP_NO(imx_ep))\r\nret = handle_ep0(imx_ep);\r\nelse\r\nret = handle_ep(imx_ep);\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nstatic int imx_ep_dequeue(struct usb_ep *usb_ep, struct usb_request *usb_req)\r\n{\r\nstruct imx_ep_struct *imx_ep = container_of\r\n(usb_ep, struct imx_ep_struct, ep);\r\nstruct imx_request *req;\r\nunsigned long flags;\r\nif (unlikely(!usb_ep || !EP_NO(imx_ep))) {\r\nD_ERR(imx_ep->imx_usb->dev, "<%s> bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nlist_for_each_entry(req, &imx_ep->queue, queue) {\r\nif (&req->req == usb_req)\r\nbreak;\r\n}\r\nif (&req->req != usb_req) {\r\nlocal_irq_restore(flags);\r\nreturn -EINVAL;\r\n}\r\ndone(imx_ep, req, -ECONNRESET);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int imx_ep_set_halt(struct usb_ep *usb_ep, int value)\r\n{\r\nstruct imx_ep_struct *imx_ep = container_of\r\n(usb_ep, struct imx_ep_struct, ep);\r\nunsigned long flags;\r\nif (unlikely(!usb_ep || !EP_NO(imx_ep))) {\r\nD_ERR(imx_ep->imx_usb->dev, "<%s> bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nif ((imx_ep->bEndpointAddress & USB_DIR_IN)\r\n&& !list_empty(&imx_ep->queue)) {\r\nlocal_irq_restore(flags);\r\nreturn -EAGAIN;\r\n}\r\nimx_ep_stall(imx_ep);\r\nlocal_irq_restore(flags);\r\nD_EPX(imx_ep->imx_usb->dev, "<%s> %s halt\n", __func__, usb_ep->name);\r\nreturn 0;\r\n}\r\nstatic int imx_ep_fifo_status(struct usb_ep *usb_ep)\r\n{\r\nstruct imx_ep_struct *imx_ep = container_of\r\n(usb_ep, struct imx_ep_struct, ep);\r\nif (!usb_ep) {\r\nD_ERR(imx_ep->imx_usb->dev, "<%s> bad ep\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (imx_ep->imx_usb->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn 0;\r\nelse\r\nreturn imx_fifo_bcount(imx_ep);\r\n}\r\nstatic void imx_ep_fifo_flush(struct usb_ep *usb_ep)\r\n{\r\nstruct imx_ep_struct *imx_ep = container_of\r\n(usb_ep, struct imx_ep_struct, ep);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (!usb_ep || !EP_NO(imx_ep) || !list_empty(&imx_ep->queue)) {\r\nD_ERR(imx_ep->imx_usb->dev, "<%s> bad ep\n", __func__);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nimx_flush(imx_ep);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid ep0_chg_stat(const char *label,\r\nstruct imx_udc_struct *imx_usb, enum ep0_state stat)\r\n{\r\nD_EP0(imx_usb->dev, "<%s> from %15s to %15s\n",\r\nlabel, state_name[imx_usb->ep0state], state_name[stat]);\r\nif (imx_usb->ep0state == stat)\r\nreturn;\r\nimx_usb->ep0state = stat;\r\n}\r\nstatic void usb_init_data(struct imx_udc_struct *imx_usb)\r\n{\r\nstruct imx_ep_struct *imx_ep;\r\nu8 i;\r\nINIT_LIST_HEAD(&imx_usb->gadget.ep_list);\r\nINIT_LIST_HEAD(&imx_usb->gadget.ep0->ep_list);\r\nep0_chg_stat(__func__, imx_usb, EP0_IDLE);\r\nfor (i = 0; i < IMX_USB_NB_EP; i++) {\r\nimx_ep = &imx_usb->imx_ep[i];\r\nif (i) {\r\nlist_add_tail(&imx_ep->ep.ep_list,\r\n&imx_usb->gadget.ep_list);\r\nimx_ep->stopped = 1;\r\n} else\r\nimx_ep->stopped = 0;\r\nINIT_LIST_HEAD(&imx_ep->queue);\r\n}\r\n}\r\nstatic void udc_stop_activity(struct imx_udc_struct *imx_usb,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct imx_ep_struct *imx_ep;\r\nint i;\r\nif (imx_usb->gadget.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\nfor (i = 1; i < IMX_USB_NB_EP; i++) {\r\nimx_ep = &imx_usb->imx_ep[i];\r\nimx_flush(imx_ep);\r\nimx_ep->stopped = 1;\r\nimx_ep_irq_disable(imx_ep);\r\nnuke(imx_ep, -ESHUTDOWN);\r\n}\r\nimx_usb->cfg = 0;\r\nimx_usb->intf = 0;\r\nimx_usb->alt = 0;\r\nif (driver)\r\ndriver->disconnect(&imx_usb->gadget);\r\n}\r\nstatic void handle_config(unsigned long data)\r\n{\r\nstruct imx_udc_struct *imx_usb = (void *)data;\r\nstruct usb_ctrlrequest u;\r\nint temp, cfg, intf, alt;\r\nlocal_irq_disable();\r\ntemp = __raw_readl(imx_usb->base + USB_STAT);\r\ncfg = (temp & STAT_CFG) >> 5;\r\nintf = (temp & STAT_INTF) >> 3;\r\nalt = temp & STAT_ALTSET;\r\nD_REQ(imx_usb->dev,\r\n"<%s> orig config C=%d, I=%d, A=%d / "\r\n"req config C=%d, I=%d, A=%d\n",\r\n__func__, imx_usb->cfg, imx_usb->intf, imx_usb->alt,\r\ncfg, intf, alt);\r\nif (cfg == 1 || cfg == 2) {\r\nif (imx_usb->cfg != cfg) {\r\nu.bRequest = USB_REQ_SET_CONFIGURATION;\r\nu.bRequestType = USB_DIR_OUT |\r\nUSB_TYPE_STANDARD |\r\nUSB_RECIP_DEVICE;\r\nu.wValue = cfg;\r\nu.wIndex = 0;\r\nu.wLength = 0;\r\nimx_usb->cfg = cfg;\r\nimx_usb->driver->setup(&imx_usb->gadget, &u);\r\n}\r\nif (imx_usb->intf != intf || imx_usb->alt != alt) {\r\nu.bRequest = USB_REQ_SET_INTERFACE;\r\nu.bRequestType = USB_DIR_OUT |\r\nUSB_TYPE_STANDARD |\r\nUSB_RECIP_INTERFACE;\r\nu.wValue = alt;\r\nu.wIndex = intf;\r\nu.wLength = 0;\r\nimx_usb->intf = intf;\r\nimx_usb->alt = alt;\r\nimx_usb->driver->setup(&imx_usb->gadget, &u);\r\n}\r\n}\r\nimx_usb->set_config = 0;\r\nlocal_irq_enable();\r\n}\r\nstatic irqreturn_t imx_udc_irq(int irq, void *dev)\r\n{\r\nstruct imx_udc_struct *imx_usb = dev;\r\nint intr = __raw_readl(imx_usb->base + USB_INTR);\r\nint temp;\r\nif (intr & (INTR_WAKEUP | INTR_SUSPEND | INTR_RESUME | INTR_RESET_START\r\n| INTR_RESET_STOP | INTR_CFG_CHG)) {\r\ndump_intr(__func__, intr, imx_usb->dev);\r\ndump_usb_stat(__func__, imx_usb);\r\n}\r\nif (!imx_usb->driver)\r\ngoto end_irq;\r\nif (intr & INTR_SOF) {\r\nif (imx_usb->ep0state == EP0_IDLE) {\r\ntemp = __raw_readl(imx_usb->base + USB_CTRL);\r\n__raw_writel(temp | CTRL_CMDOVER,\r\nimx_usb->base + USB_CTRL);\r\n}\r\n}\r\nif (intr & INTR_CFG_CHG) {\r\n__raw_writel(INTR_CFG_CHG, imx_usb->base + USB_INTR);\r\nimx_usb->set_config = 1;\r\nmod_timer(&imx_usb->timer, jiffies + 5);\r\ngoto end_irq;\r\n}\r\nif (intr & INTR_WAKEUP) {\r\nif (imx_usb->gadget.speed == USB_SPEED_UNKNOWN\r\n&& imx_usb->driver && imx_usb->driver->resume)\r\nimx_usb->driver->resume(&imx_usb->gadget);\r\nimx_usb->set_config = 0;\r\ndel_timer(&imx_usb->timer);\r\nimx_usb->gadget.speed = USB_SPEED_FULL;\r\n}\r\nif (intr & INTR_SUSPEND) {\r\nif (imx_usb->gadget.speed != USB_SPEED_UNKNOWN\r\n&& imx_usb->driver && imx_usb->driver->suspend)\r\nimx_usb->driver->suspend(&imx_usb->gadget);\r\nimx_usb->set_config = 0;\r\ndel_timer(&imx_usb->timer);\r\nimx_usb->gadget.speed = USB_SPEED_UNKNOWN;\r\n}\r\nif (intr & INTR_RESET_START) {\r\n__raw_writel(intr, imx_usb->base + USB_INTR);\r\nudc_stop_activity(imx_usb, imx_usb->driver);\r\nimx_usb->set_config = 0;\r\ndel_timer(&imx_usb->timer);\r\nimx_usb->gadget.speed = USB_SPEED_UNKNOWN;\r\n}\r\nif (intr & INTR_RESET_STOP)\r\nimx_usb->gadget.speed = USB_SPEED_FULL;\r\nend_irq:\r\n__raw_writel(intr, imx_usb->base + USB_INTR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_udc_ctrl_irq(int irq, void *dev)\r\n{\r\nstruct imx_udc_struct *imx_usb = dev;\r\nstruct imx_ep_struct *imx_ep = &imx_usb->imx_ep[0];\r\nint intr = __raw_readl(imx_usb->base + USB_EP_INTR(0));\r\ndump_ep_intr(__func__, 0, intr, imx_usb->dev);\r\nif (!imx_usb->driver) {\r\n__raw_writel(intr, imx_usb->base + USB_EP_INTR(0));\r\nreturn IRQ_HANDLED;\r\n}\r\nif (intr & (EPINTR_DEVREQ | EPINTR_MDEVREQ))\r\nhandle_ep0_devreq(imx_usb);\r\nelse if (!list_empty(&imx_ep->queue))\r\nhandle_ep0(imx_ep);\r\n__raw_writel(intr, imx_usb->base + USB_EP_INTR(0));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_udc_bulk_irq(int irq, void *dev)\r\n{\r\nstruct imx_udc_struct *imx_usb = dev;\r\nstruct imx_ep_struct *imx_ep = &imx_usb->imx_ep[irq - MX1_INT_USBD0];\r\nint intr = __raw_readl(imx_usb->base + USB_EP_INTR(EP_NO(imx_ep)));\r\ndump_ep_intr(__func__, irq - MX1_INT_USBD0, intr, imx_usb->dev);\r\nif (!imx_usb->driver) {\r\n__raw_writel(intr, imx_usb->base + USB_EP_INTR(EP_NO(imx_ep)));\r\nreturn IRQ_HANDLED;\r\n}\r\nhandle_ep(imx_ep);\r\n__raw_writel(intr, imx_usb->base + USB_EP_INTR(EP_NO(imx_ep)));\r\nreturn IRQ_HANDLED;\r\n}\r\nirq_handler_t intr_handler(int i)\r\n{\r\nswitch (i) {\r\ncase 0:\r\nreturn imx_udc_ctrl_irq;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\nreturn imx_udc_bulk_irq;\r\ndefault:\r\nreturn imx_udc_irq;\r\n}\r\n}\r\nstatic int imx_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct imx_udc_struct *imx_usb;\r\nimx_usb = container_of(gadget, struct imx_udc_struct, gadget);\r\nimx_usb->driver = driver;\r\nD_INI(imx_usb->dev, "<%s> registered gadget driver '%s'\n",\r\n__func__, driver->driver.name);\r\nimx_udc_enable(imx_usb);\r\nreturn 0;\r\n}\r\nstatic int imx_udc_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct imx_udc_struct *imx_usb = container_of(gadget,\r\nstruct imx_udc_struct, gadget);\r\nudc_stop_activity(imx_usb, driver);\r\nimx_udc_disable(imx_usb);\r\ndel_timer(&imx_usb->timer);\r\nimx_usb->driver = NULL;\r\nD_INI(imx_usb->dev, "<%s> unregistered gadget driver '%s'\n",\r\n__func__, driver->driver.name);\r\nreturn 0;\r\n}\r\nstatic int __init imx_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct imx_udc_struct *imx_usb = &controller;\r\nstruct resource *res;\r\nstruct imxusb_platform_data *pdata;\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nint ret = 0;\r\nint i;\r\nresource_size_t res_size;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't get device resources\n");\r\nreturn -ENODEV;\r\n}\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "driver needs platform data\n");\r\nreturn -ENODEV;\r\n}\r\nres_size = resource_size(res);\r\nif (!request_mem_region(res->start, res_size, res->name)) {\r\ndev_err(&pdev->dev, "can't allocate %d bytes at %d address\n",\r\nres_size, res->start);\r\nreturn -ENOMEM;\r\n}\r\nif (pdata->init) {\r\nret = pdata->init(&pdev->dev);\r\nif (ret)\r\ngoto fail0;\r\n}\r\nbase = ioremap(res->start, res_size);\r\nif (!base) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -EIO;\r\ngoto fail1;\r\n}\r\nclk = clk_get(NULL, "usbd_clk");\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ndev_err(&pdev->dev, "can't get USB clock\n");\r\ngoto fail2;\r\n}\r\nclk_prepare_enable(clk);\r\nif (clk_get_rate(clk) != 48000000) {\r\nD_INI(&pdev->dev,\r\n"Bad USB clock (%d Hz), changing to 48000000 Hz\n",\r\n(int)clk_get_rate(clk));\r\nif (clk_set_rate(clk, 48000000)) {\r\ndev_err(&pdev->dev,\r\n"Unable to set correct USB clock (48MHz)\n");\r\nret = -EIO;\r\ngoto fail3;\r\n}\r\n}\r\nfor (i = 0; i < IMX_USB_NB_EP + 1; i++) {\r\nimx_usb->usbd_int[i] = platform_get_irq(pdev, i);\r\nif (imx_usb->usbd_int[i] < 0) {\r\ndev_err(&pdev->dev, "can't get irq number\n");\r\nret = -ENODEV;\r\ngoto fail3;\r\n}\r\n}\r\nfor (i = 0; i < IMX_USB_NB_EP + 1; i++) {\r\nret = request_irq(imx_usb->usbd_int[i], intr_handler(i),\r\n0, driver_name, imx_usb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't get irq %i, err %d\n",\r\nimx_usb->usbd_int[i], ret);\r\nfor (--i; i >= 0; i--)\r\nfree_irq(imx_usb->usbd_int[i], imx_usb);\r\ngoto fail3;\r\n}\r\n}\r\nimx_usb->res = res;\r\nimx_usb->base = base;\r\nimx_usb->clk = clk;\r\nimx_usb->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, imx_usb);\r\nusb_init_data(imx_usb);\r\nimx_udc_init(imx_usb);\r\ninit_timer(&imx_usb->timer);\r\nimx_usb->timer.function = handle_config;\r\nimx_usb->timer.data = (unsigned long)imx_usb;\r\nret = usb_add_gadget_udc(&pdev->dev, &imx_usb->gadget);\r\nif (ret)\r\ngoto fail4;\r\nreturn 0;\r\nfail4:\r\nfor (i = 0; i < IMX_USB_NB_EP + 1; i++)\r\nfree_irq(imx_usb->usbd_int[i], imx_usb);\r\nfail3:\r\nclk_put(clk);\r\nclk_disable_unprepare(clk);\r\nfail2:\r\niounmap(base);\r\nfail1:\r\nif (pdata->exit)\r\npdata->exit(&pdev->dev);\r\nfail0:\r\nrelease_mem_region(res->start, res_size);\r\nreturn ret;\r\n}\r\nstatic int __exit imx_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_udc_struct *imx_usb = platform_get_drvdata(pdev);\r\nstruct imxusb_platform_data *pdata = pdev->dev.platform_data;\r\nint i;\r\nusb_del_gadget_udc(&imx_usb->gadget);\r\nimx_udc_disable(imx_usb);\r\ndel_timer(&imx_usb->timer);\r\nfor (i = 0; i < IMX_USB_NB_EP + 1; i++)\r\nfree_irq(imx_usb->usbd_int[i], imx_usb);\r\nclk_put(imx_usb->clk);\r\nclk_disable_unprepare(imx_usb->clk);\r\niounmap(imx_usb->base);\r\nrelease_mem_region(imx_usb->res->start, resource_size(imx_usb->res));\r\nif (pdata->exit)\r\npdata->exit(&pdev->dev);\r\nreturn 0;\r\n}
