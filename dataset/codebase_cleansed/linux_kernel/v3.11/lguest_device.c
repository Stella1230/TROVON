static inline void *lguest_map(unsigned long phys_addr, unsigned long pages)\r\n{\r\nreturn (__force void *)ioremap_cache(phys_addr, PAGE_SIZE*pages);\r\n}\r\nstatic inline void lguest_unmap(void *addr)\r\n{\r\niounmap((__force void __iomem *)addr);\r\n}\r\nstatic struct lguest_vqconfig *lg_vq(const struct lguest_device_desc *desc)\r\n{\r\nreturn (void *)(desc + 1);\r\n}\r\nstatic u8 *lg_features(const struct lguest_device_desc *desc)\r\n{\r\nreturn (void *)(lg_vq(desc) + desc->num_vq);\r\n}\r\nstatic u8 *lg_config(const struct lguest_device_desc *desc)\r\n{\r\nreturn lg_features(desc) + desc->feature_len * 2;\r\n}\r\nstatic unsigned desc_size(const struct lguest_device_desc *desc)\r\n{\r\nreturn sizeof(*desc)\r\n+ desc->num_vq * sizeof(struct lguest_vqconfig)\r\n+ desc->feature_len * 2\r\n+ desc->config_len;\r\n}\r\nstatic u32 lg_get_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i;\r\nu32 features = 0;\r\nstruct lguest_device_desc *desc = to_lgdev(vdev)->desc;\r\nu8 *in_features = lg_features(desc);\r\nfor (i = 0; i < min(desc->feature_len * 8, 32); i++)\r\nif (in_features[i / 8] & (1 << (i % 8)))\r\nfeatures |= (1 << i);\r\nreturn features;\r\n}\r\nstatic void status_notify(struct virtio_device *vdev)\r\n{\r\nunsigned long offset = (void *)to_lgdev(vdev)->desc - lguest_devices;\r\nhcall(LHCALL_NOTIFY, (max_pfn << PAGE_SHIFT) + offset, 0, 0, 0);\r\n}\r\nstatic void lg_finalize_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i, bits;\r\nstruct lguest_device_desc *desc = to_lgdev(vdev)->desc;\r\nu8 *out_features = lg_features(desc) + desc->feature_len;\r\nvring_transport_features(vdev);\r\nmemset(out_features, 0, desc->feature_len);\r\nbits = min_t(unsigned, desc->feature_len, sizeof(vdev->features)) * 8;\r\nfor (i = 0; i < bits; i++) {\r\nif (test_bit(i, vdev->features))\r\nout_features[i / 8] |= (1 << (i % 8));\r\n}\r\nstatus_notify(vdev);\r\n}\r\nstatic void lg_get(struct virtio_device *vdev, unsigned int offset,\r\nvoid *buf, unsigned len)\r\n{\r\nstruct lguest_device_desc *desc = to_lgdev(vdev)->desc;\r\nBUG_ON(offset + len > desc->config_len);\r\nmemcpy(buf, lg_config(desc) + offset, len);\r\n}\r\nstatic void lg_set(struct virtio_device *vdev, unsigned int offset,\r\nconst void *buf, unsigned len)\r\n{\r\nstruct lguest_device_desc *desc = to_lgdev(vdev)->desc;\r\nBUG_ON(offset + len > desc->config_len);\r\nmemcpy(lg_config(desc) + offset, buf, len);\r\n}\r\nstatic u8 lg_get_status(struct virtio_device *vdev)\r\n{\r\nreturn to_lgdev(vdev)->desc->status;\r\n}\r\nstatic void lg_set_status(struct virtio_device *vdev, u8 status)\r\n{\r\nBUG_ON(!status);\r\nto_lgdev(vdev)->desc->status = status;\r\nif (status & VIRTIO_CONFIG_S_FAILED)\r\nstatus_notify(vdev);\r\n}\r\nstatic void lg_reset(struct virtio_device *vdev)\r\n{\r\nto_lgdev(vdev)->desc->status = 0;\r\nstatus_notify(vdev);\r\n}\r\nstatic void lg_notify(struct virtqueue *vq)\r\n{\r\nstruct lguest_vq_info *lvq = vq->priv;\r\nhcall(LHCALL_NOTIFY, lvq->config.pfn << PAGE_SHIFT, 0, 0, 0);\r\n}\r\nstatic struct virtqueue *lg_find_vq(struct virtio_device *vdev,\r\nunsigned index,\r\nvoid (*callback)(struct virtqueue *vq),\r\nconst char *name)\r\n{\r\nstruct lguest_device *ldev = to_lgdev(vdev);\r\nstruct lguest_vq_info *lvq;\r\nstruct virtqueue *vq;\r\nint err;\r\nif (!name)\r\nreturn NULL;\r\nif (index >= ldev->desc->num_vq)\r\nreturn ERR_PTR(-ENOENT);\r\nlvq = kmalloc(sizeof(*lvq), GFP_KERNEL);\r\nif (!lvq)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(&lvq->config, lg_vq(ldev->desc)+index, sizeof(lvq->config));\r\nprintk("Mapping virtqueue %i addr %lx\n", index,\r\n(unsigned long)lvq->config.pfn << PAGE_SHIFT);\r\nlvq->pages = lguest_map((unsigned long)lvq->config.pfn << PAGE_SHIFT,\r\nDIV_ROUND_UP(vring_size(lvq->config.num,\r\nLGUEST_VRING_ALIGN),\r\nPAGE_SIZE));\r\nif (!lvq->pages) {\r\nerr = -ENOMEM;\r\ngoto free_lvq;\r\n}\r\nvq = vring_new_virtqueue(index, lvq->config.num, LGUEST_VRING_ALIGN, vdev,\r\ntrue, lvq->pages, lg_notify, callback, name);\r\nif (!vq) {\r\nerr = -ENOMEM;\r\ngoto unmap;\r\n}\r\nerr = lguest_setup_irq(lvq->config.irq);\r\nif (err)\r\ngoto destroy_vring;\r\nerr = request_irq(lvq->config.irq, vring_interrupt, IRQF_SHARED,\r\ndev_name(&vdev->dev), vq);\r\nif (err)\r\ngoto free_desc;\r\nvq->priv = lvq;\r\nreturn vq;\r\nfree_desc:\r\nirq_free_desc(lvq->config.irq);\r\ndestroy_vring:\r\nvring_del_virtqueue(vq);\r\nunmap:\r\nlguest_unmap(lvq->pages);\r\nfree_lvq:\r\nkfree(lvq);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void lg_del_vq(struct virtqueue *vq)\r\n{\r\nstruct lguest_vq_info *lvq = vq->priv;\r\nfree_irq(lvq->config.irq, vq);\r\nvring_del_virtqueue(vq);\r\nlguest_unmap(lvq->pages);\r\nkfree(lvq);\r\n}\r\nstatic void lg_del_vqs(struct virtio_device *vdev)\r\n{\r\nstruct virtqueue *vq, *n;\r\nlist_for_each_entry_safe(vq, n, &vdev->vqs, list)\r\nlg_del_vq(vq);\r\n}\r\nstatic int lg_find_vqs(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[],\r\nvq_callback_t *callbacks[],\r\nconst char *names[])\r\n{\r\nstruct lguest_device *ldev = to_lgdev(vdev);\r\nint i;\r\nif (nvqs > ldev->desc->num_vq)\r\nreturn -ENOENT;\r\nfor (i = 0; i < nvqs; ++i) {\r\nvqs[i] = lg_find_vq(vdev, i, callbacks[i], names[i]);\r\nif (IS_ERR(vqs[i]))\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nlg_del_vqs(vdev);\r\nreturn PTR_ERR(vqs[i]);\r\n}\r\nstatic const char *lg_bus_name(struct virtio_device *vdev)\r\n{\r\nreturn "";\r\n}\r\nstatic void add_lguest_device(struct lguest_device_desc *d,\r\nunsigned int offset)\r\n{\r\nstruct lguest_device *ldev;\r\nldev = kzalloc(sizeof(*ldev), GFP_KERNEL);\r\nif (!ldev) {\r\nprintk(KERN_EMERG "Cannot allocate lguest dev %u type %u\n",\r\noffset, d->type);\r\nreturn;\r\n}\r\nldev->vdev.dev.parent = lguest_root;\r\nldev->vdev.id.device = d->type;\r\nldev->vdev.config = &lguest_config_ops;\r\nldev->desc = d;\r\nif (register_virtio_device(&ldev->vdev) != 0) {\r\nprintk(KERN_ERR "Failed to register lguest dev %u type %u\n",\r\noffset, d->type);\r\nkfree(ldev);\r\n}\r\n}\r\nstatic void scan_devices(void)\r\n{\r\nunsigned int i;\r\nstruct lguest_device_desc *d;\r\nfor (i = 0; i < PAGE_SIZE; i += desc_size(d)) {\r\nd = lguest_devices + i;\r\nif (d->type == 0)\r\nbreak;\r\nprintk("Device at %i has size %u\n", i, desc_size(d));\r\nadd_lguest_device(d, i);\r\n}\r\n}\r\nstatic int __init lguest_devices_init(void)\r\n{\r\nif (strcmp(pv_info.name, "lguest") != 0)\r\nreturn 0;\r\nlguest_root = root_device_register("lguest");\r\nif (IS_ERR(lguest_root))\r\npanic("Could not register lguest root");\r\nlguest_devices = lguest_map(max_pfn<<PAGE_SHIFT, 1);\r\nscan_devices();\r\nreturn 0;\r\n}
