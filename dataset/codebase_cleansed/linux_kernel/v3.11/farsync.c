static void\r\nfst_q_work_item(u64 * queue, int card_index)\r\n{\r\nunsigned long flags;\r\nu64 mask;\r\nspin_lock_irqsave(&fst_work_q_lock, flags);\r\nmask = (u64)1 << card_index;\r\n*queue |= mask;\r\nspin_unlock_irqrestore(&fst_work_q_lock, flags);\r\n}\r\nstatic void\r\nfst_process_tx_work_q(unsigned long work_q)\r\n{\r\nunsigned long flags;\r\nu64 work_txq;\r\nint i;\r\ndbg(DBG_TX, "fst_process_tx_work_q\n");\r\nspin_lock_irqsave(&fst_work_q_lock, flags);\r\nwork_txq = fst_work_txq;\r\nfst_work_txq = 0;\r\nspin_unlock_irqrestore(&fst_work_q_lock, flags);\r\nfor (i = 0; i < FST_MAX_CARDS; i++) {\r\nif (work_txq & 0x01) {\r\nif (fst_card_array[i] != NULL) {\r\ndbg(DBG_TX, "Calling tx bh for card %d\n", i);\r\ndo_bottom_half_tx(fst_card_array[i]);\r\n}\r\n}\r\nwork_txq = work_txq >> 1;\r\n}\r\n}\r\nstatic void\r\nfst_process_int_work_q(unsigned long work_q)\r\n{\r\nunsigned long flags;\r\nu64 work_intq;\r\nint i;\r\ndbg(DBG_INTR, "fst_process_int_work_q\n");\r\nspin_lock_irqsave(&fst_work_q_lock, flags);\r\nwork_intq = fst_work_intq;\r\nfst_work_intq = 0;\r\nspin_unlock_irqrestore(&fst_work_q_lock, flags);\r\nfor (i = 0; i < FST_MAX_CARDS; i++) {\r\nif (work_intq & 0x01) {\r\nif (fst_card_array[i] != NULL) {\r\ndbg(DBG_INTR,\r\n"Calling rx & tx bh for card %d\n", i);\r\ndo_bottom_half_rx(fst_card_array[i]);\r\ndo_bottom_half_tx(fst_card_array[i]);\r\n}\r\n}\r\nwork_intq = work_intq >> 1;\r\n}\r\n}\r\nstatic inline void\r\nfst_cpureset(struct fst_card_info *card)\r\n{\r\nunsigned char interrupt_line_register;\r\nunsigned long j = jiffies + 1;\r\nunsigned int regval;\r\nif (card->family == FST_FAMILY_TXU) {\r\nif (pci_read_config_byte\r\n(card->device, PCI_INTERRUPT_LINE, &interrupt_line_register)) {\r\ndbg(DBG_ASS,\r\n"Error in reading interrupt line register\n");\r\n}\r\noutw(0x440f, card->pci_conf + CNTRL_9054 + 2);\r\noutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\r\nj = jiffies + 1;\r\nwhile (jiffies < j)\r\n;\r\noutw(0x240f, card->pci_conf + CNTRL_9054 + 2);\r\nj = jiffies + 1;\r\nwhile (jiffies < j)\r\n;\r\noutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\r\nif (pci_write_config_byte\r\n(card->device, PCI_INTERRUPT_LINE, interrupt_line_register)) {\r\ndbg(DBG_ASS,\r\n"Error in writing interrupt line register\n");\r\n}\r\n} else {\r\nregval = inl(card->pci_conf + CNTRL_9052);\r\noutl(regval | 0x40000000, card->pci_conf + CNTRL_9052);\r\noutl(regval & ~0x40000000, card->pci_conf + CNTRL_9052);\r\n}\r\n}\r\nstatic inline void\r\nfst_cpurelease(struct fst_card_info *card)\r\n{\r\nif (card->family == FST_FAMILY_TXU) {\r\n(void) readb(card->mem);\r\noutw(0x040e, card->pci_conf + CNTRL_9054 + 2);\r\noutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\r\n} else {\r\n(void) readb(card->ctlmem);\r\n}\r\n}\r\nstatic inline void\r\nfst_clear_intr(struct fst_card_info *card)\r\n{\r\nif (card->family == FST_FAMILY_TXU) {\r\n(void) readb(card->ctlmem);\r\n} else {\r\noutw(0x0543, card->pci_conf + INTCSR_9052);\r\n}\r\n}\r\nstatic inline void\r\nfst_enable_intr(struct fst_card_info *card)\r\n{\r\nif (card->family == FST_FAMILY_TXU) {\r\noutl(0x0f0c0900, card->pci_conf + INTCSR_9054);\r\n} else {\r\noutw(0x0543, card->pci_conf + INTCSR_9052);\r\n}\r\n}\r\nstatic inline void\r\nfst_disable_intr(struct fst_card_info *card)\r\n{\r\nif (card->family == FST_FAMILY_TXU) {\r\noutl(0x00000000, card->pci_conf + INTCSR_9054);\r\n} else {\r\noutw(0x0000, card->pci_conf + INTCSR_9052);\r\n}\r\n}\r\nstatic void\r\nfst_process_rx_status(int rx_status, char *name)\r\n{\r\nswitch (rx_status) {\r\ncase NET_RX_SUCCESS:\r\n{\r\nbreak;\r\n}\r\ncase NET_RX_DROP:\r\n{\r\ndbg(DBG_ASS, "%s: Received packet dropped\n", name);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic inline void\r\nfst_init_dma(struct fst_card_info *card)\r\n{\r\nif (card->family == FST_FAMILY_TXU) {\r\npci_set_master(card->device);\r\noutl(0x00020441, card->pci_conf + DMAMODE0);\r\noutl(0x00020441, card->pci_conf + DMAMODE1);\r\noutl(0x0, card->pci_conf + DMATHR);\r\n}\r\n}\r\nstatic void\r\nfst_tx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,\r\nint len, int txpos)\r\n{\r\nstruct net_device *dev = port_to_dev(port);\r\ndbg(DBG_TX, "fst_tx_dma_complete\n");\r\nFST_WRB(card, txDescrRing[port->index][txpos].bits,\r\nDMA_OWN | TX_STP | TX_ENP);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += len;\r\ndev->trans_start = jiffies;\r\n}\r\nstatic __be16 farsync_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_HOST;\r\nreturn htons(ETH_P_CUST);\r\n}\r\nstatic void\r\nfst_rx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,\r\nint len, struct sk_buff *skb, int rxp)\r\n{\r\nstruct net_device *dev = port_to_dev(port);\r\nint pi;\r\nint rx_status;\r\ndbg(DBG_TX, "fst_rx_dma_complete\n");\r\npi = port->index;\r\nmemcpy(skb_put(skb, len), card->rx_dma_handle_host, len);\r\nFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\ndbg(DBG_RX, "Pushing the frame up the stack\n");\r\nif (port->mode == FST_RAW)\r\nskb->protocol = farsync_type_trans(skb, dev);\r\nelse\r\nskb->protocol = hdlc_type_trans(skb, dev);\r\nrx_status = netif_rx(skb);\r\nfst_process_rx_status(rx_status, port_to_dev(port)->name);\r\nif (rx_status == NET_RX_DROP)\r\ndev->stats.rx_dropped++;\r\n}\r\nstatic inline void\r\nfst_rx_dma(struct fst_card_info *card, dma_addr_t skb,\r\ndma_addr_t mem, int len)\r\n{\r\ndbg(DBG_RX, "In fst_rx_dma %lx %lx %d\n",\r\n(unsigned long) skb, (unsigned long) mem, len);\r\nif (card->dmarx_in_progress) {\r\ndbg(DBG_ASS, "In fst_rx_dma while dma in progress\n");\r\n}\r\noutl(skb, card->pci_conf + DMAPADR0);\r\noutl(mem, card->pci_conf + DMALADR0);\r\noutl(len, card->pci_conf + DMASIZ0);\r\noutl(0x00000000c, card->pci_conf + DMADPR0);\r\ncard->dmarx_in_progress = 1;\r\noutb(0x03, card->pci_conf + DMACSR0);\r\n}\r\nstatic inline void\r\nfst_tx_dma(struct fst_card_info *card, unsigned char *skb,\r\nunsigned char *mem, int len)\r\n{\r\ndbg(DBG_TX, "In fst_tx_dma %p %p %d\n", skb, mem, len);\r\nif (card->dmatx_in_progress) {\r\ndbg(DBG_ASS, "In fst_tx_dma while dma in progress\n");\r\n}\r\noutl((unsigned long) skb, card->pci_conf + DMAPADR1);\r\noutl((unsigned long) mem, card->pci_conf + DMALADR1);\r\noutl(len, card->pci_conf + DMASIZ1);\r\noutl(0x000000004, card->pci_conf + DMADPR1);\r\ncard->dmatx_in_progress = 1;\r\noutb(0x03, card->pci_conf + DMACSR1);\r\n}\r\nstatic void\r\nfst_issue_cmd(struct fst_port_info *port, unsigned short cmd)\r\n{\r\nstruct fst_card_info *card;\r\nunsigned short mbval;\r\nunsigned long flags;\r\nint safety;\r\ncard = port->card;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nmbval = FST_RDW(card, portMailbox[port->index][0]);\r\nsafety = 0;\r\nwhile (mbval > NAK) {\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nschedule_timeout_uninterruptible(1);\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nif (++safety > 2000) {\r\npr_err("Mailbox safety timeout\n");\r\nbreak;\r\n}\r\nmbval = FST_RDW(card, portMailbox[port->index][0]);\r\n}\r\nif (safety > 0) {\r\ndbg(DBG_CMD, "Mailbox clear after %d jiffies\n", safety);\r\n}\r\nif (mbval == NAK) {\r\ndbg(DBG_CMD, "issue_cmd: previous command was NAK'd\n");\r\n}\r\nFST_WRW(card, portMailbox[port->index][0], cmd);\r\nif (cmd == ABORTTX || cmd == STARTPORT) {\r\nport->txpos = 0;\r\nport->txipos = 0;\r\nport->start = 0;\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\nstatic inline void\r\nfst_op_raise(struct fst_port_info *port, unsigned int outputs)\r\n{\r\noutputs |= FST_RDL(port->card, v24OpSts[port->index]);\r\nFST_WRL(port->card, v24OpSts[port->index], outputs);\r\nif (port->run)\r\nfst_issue_cmd(port, SETV24O);\r\n}\r\nstatic inline void\r\nfst_op_lower(struct fst_port_info *port, unsigned int outputs)\r\n{\r\noutputs = ~outputs & FST_RDL(port->card, v24OpSts[port->index]);\r\nFST_WRL(port->card, v24OpSts[port->index], outputs);\r\nif (port->run)\r\nfst_issue_cmd(port, SETV24O);\r\n}\r\nstatic void\r\nfst_rx_config(struct fst_port_info *port)\r\n{\r\nint i;\r\nint pi;\r\nunsigned int offset;\r\nunsigned long flags;\r\nstruct fst_card_info *card;\r\npi = port->index;\r\ncard = port->card;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nfor (i = 0; i < NUM_RX_BUFFER; i++) {\r\noffset = BUF_OFFSET(rxBuffer[pi][i][0]);\r\nFST_WRW(card, rxDescrRing[pi][i].ladr, (u16) offset);\r\nFST_WRB(card, rxDescrRing[pi][i].hadr, (u8) (offset >> 16));\r\nFST_WRW(card, rxDescrRing[pi][i].bcnt, cnv_bcnt(LEN_RX_BUFFER));\r\nFST_WRW(card, rxDescrRing[pi][i].mcnt, LEN_RX_BUFFER);\r\nFST_WRB(card, rxDescrRing[pi][i].bits, DMA_OWN);\r\n}\r\nport->rxpos = 0;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\nstatic void\r\nfst_tx_config(struct fst_port_info *port)\r\n{\r\nint i;\r\nint pi;\r\nunsigned int offset;\r\nunsigned long flags;\r\nstruct fst_card_info *card;\r\npi = port->index;\r\ncard = port->card;\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nfor (i = 0; i < NUM_TX_BUFFER; i++) {\r\noffset = BUF_OFFSET(txBuffer[pi][i][0]);\r\nFST_WRW(card, txDescrRing[pi][i].ladr, (u16) offset);\r\nFST_WRB(card, txDescrRing[pi][i].hadr, (u8) (offset >> 16));\r\nFST_WRW(card, txDescrRing[pi][i].bcnt, 0);\r\nFST_WRB(card, txDescrRing[pi][i].bits, 0);\r\n}\r\nport->txpos = 0;\r\nport->txipos = 0;\r\nport->start = 0;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\nstatic void\r\nfst_intr_te1_alarm(struct fst_card_info *card, struct fst_port_info *port)\r\n{\r\nu8 los;\r\nu8 rra;\r\nu8 ais;\r\nlos = FST_RDB(card, suStatus.lossOfSignal);\r\nrra = FST_RDB(card, suStatus.receiveRemoteAlarm);\r\nais = FST_RDB(card, suStatus.alarmIndicationSignal);\r\nif (los) {\r\nif (netif_carrier_ok(port_to_dev(port))) {\r\ndbg(DBG_INTR, "Net carrier off\n");\r\nnetif_carrier_off(port_to_dev(port));\r\n}\r\n} else {\r\nif (!netif_carrier_ok(port_to_dev(port))) {\r\ndbg(DBG_INTR, "Net carrier on\n");\r\nnetif_carrier_on(port_to_dev(port));\r\n}\r\n}\r\nif (los)\r\ndbg(DBG_INTR, "Assert LOS Alarm\n");\r\nelse\r\ndbg(DBG_INTR, "De-assert LOS Alarm\n");\r\nif (rra)\r\ndbg(DBG_INTR, "Assert RRA Alarm\n");\r\nelse\r\ndbg(DBG_INTR, "De-assert RRA Alarm\n");\r\nif (ais)\r\ndbg(DBG_INTR, "Assert AIS Alarm\n");\r\nelse\r\ndbg(DBG_INTR, "De-assert AIS Alarm\n");\r\n}\r\nstatic void\r\nfst_intr_ctlchg(struct fst_card_info *card, struct fst_port_info *port)\r\n{\r\nint signals;\r\nsignals = FST_RDL(card, v24DebouncedSts[port->index]);\r\nif (signals & (((port->hwif == X21) || (port->hwif == X21D))\r\n? IPSTS_INDICATE : IPSTS_DCD)) {\r\nif (!netif_carrier_ok(port_to_dev(port))) {\r\ndbg(DBG_INTR, "DCD active\n");\r\nnetif_carrier_on(port_to_dev(port));\r\n}\r\n} else {\r\nif (netif_carrier_ok(port_to_dev(port))) {\r\ndbg(DBG_INTR, "DCD lost\n");\r\nnetif_carrier_off(port_to_dev(port));\r\n}\r\n}\r\n}\r\nstatic void\r\nfst_log_rx_error(struct fst_card_info *card, struct fst_port_info *port,\r\nunsigned char dmabits, int rxp, unsigned short len)\r\n{\r\nstruct net_device *dev = port_to_dev(port);\r\ndev->stats.rx_errors++;\r\nif (dmabits & RX_OFLO) {\r\ndev->stats.rx_fifo_errors++;\r\ndbg(DBG_ASS, "Rx fifo error on card %d port %d buffer %d\n",\r\ncard->card_no, port->index, rxp);\r\n}\r\nif (dmabits & RX_CRC) {\r\ndev->stats.rx_crc_errors++;\r\ndbg(DBG_ASS, "Rx crc error on card %d port %d\n",\r\ncard->card_no, port->index);\r\n}\r\nif (dmabits & RX_FRAM) {\r\ndev->stats.rx_frame_errors++;\r\ndbg(DBG_ASS, "Rx frame error on card %d port %d\n",\r\ncard->card_no, port->index);\r\n}\r\nif (dmabits == (RX_STP | RX_ENP)) {\r\ndev->stats.rx_length_errors++;\r\ndbg(DBG_ASS, "Rx length error (%d) on card %d port %d\n",\r\nlen, card->card_no, port->index);\r\n}\r\n}\r\nstatic void\r\nfst_recover_rx_error(struct fst_card_info *card, struct fst_port_info *port,\r\nunsigned char dmabits, int rxp, unsigned short len)\r\n{\r\nint i;\r\nint pi;\r\npi = port->index;\r\ni = 0;\r\nwhile ((dmabits & (DMA_OWN | RX_STP)) == 0) {\r\nFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\r\nrxp = (rxp+1) % NUM_RX_BUFFER;\r\nif (++i > NUM_RX_BUFFER) {\r\ndbg(DBG_ASS, "intr_rx: Discarding more bufs"\r\n" than we have\n");\r\nbreak;\r\n}\r\ndmabits = FST_RDB(card, rxDescrRing[pi][rxp].bits);\r\ndbg(DBG_ASS, "DMA Bits of next buffer was %x\n", dmabits);\r\n}\r\ndbg(DBG_ASS, "There were %d subsequent buffers in error\n", i);\r\nif (!(dmabits & DMA_OWN)) {\r\nFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\r\nrxp = (rxp+1) % NUM_RX_BUFFER;\r\n}\r\nport->rxpos = rxp;\r\nreturn;\r\n}\r\nstatic void\r\nfst_intr_rx(struct fst_card_info *card, struct fst_port_info *port)\r\n{\r\nunsigned char dmabits;\r\nint pi;\r\nint rxp;\r\nint rx_status;\r\nunsigned short len;\r\nstruct sk_buff *skb;\r\nstruct net_device *dev = port_to_dev(port);\r\npi = port->index;\r\nrxp = port->rxpos;\r\ndmabits = FST_RDB(card, rxDescrRing[pi][rxp].bits);\r\nif (dmabits & DMA_OWN) {\r\ndbg(DBG_RX | DBG_INTR, "intr_rx: No buffer port %d pos %d\n",\r\npi, rxp);\r\nreturn;\r\n}\r\nif (card->dmarx_in_progress) {\r\nreturn;\r\n}\r\nlen = FST_RDW(card, rxDescrRing[pi][rxp].mcnt);\r\nlen -= 2;\r\nif (len == 0) {\r\npr_err("Frame received with 0 length. Card %d Port %d\n",\r\ncard->card_no, port->index);\r\nFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\r\nrxp = (rxp+1) % NUM_RX_BUFFER;\r\nport->rxpos = rxp;\r\nreturn;\r\n}\r\ndbg(DBG_RX, "intr_rx: %d,%d: flags %x len %d\n", pi, rxp, dmabits, len);\r\nif (dmabits != (RX_STP | RX_ENP) || len > LEN_RX_BUFFER - 2) {\r\nfst_log_rx_error(card, port, dmabits, rxp, len);\r\nfst_recover_rx_error(card, port, dmabits, rxp, len);\r\nreturn;\r\n}\r\nif ((skb = dev_alloc_skb(len)) == NULL) {\r\ndbg(DBG_RX, "intr_rx: can't allocate buffer\n");\r\ndev->stats.rx_dropped++;\r\nFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\r\nrxp = (rxp+1) % NUM_RX_BUFFER;\r\nport->rxpos = rxp;\r\nreturn;\r\n}\r\nif ((len < FST_MIN_DMA_LEN) || (card->family == FST_FAMILY_TXP)) {\r\nmemcpy_fromio(skb_put(skb, len),\r\ncard->mem + BUF_OFFSET(rxBuffer[pi][rxp][0]),\r\nlen);\r\nFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\ndbg(DBG_RX, "Pushing frame up the stack\n");\r\nif (port->mode == FST_RAW)\r\nskb->protocol = farsync_type_trans(skb, dev);\r\nelse\r\nskb->protocol = hdlc_type_trans(skb, dev);\r\nrx_status = netif_rx(skb);\r\nfst_process_rx_status(rx_status, port_to_dev(port)->name);\r\nif (rx_status == NET_RX_DROP)\r\ndev->stats.rx_dropped++;\r\n} else {\r\ncard->dma_skb_rx = skb;\r\ncard->dma_port_rx = port;\r\ncard->dma_len_rx = len;\r\ncard->dma_rxpos = rxp;\r\nfst_rx_dma(card, card->rx_dma_handle_card,\r\nBUF_OFFSET(rxBuffer[pi][rxp][0]), len);\r\n}\r\nif (rxp != port->rxpos) {\r\ndbg(DBG_ASS, "About to increment rxpos by more than 1\n");\r\ndbg(DBG_ASS, "rxp = %d rxpos = %d\n", rxp, port->rxpos);\r\n}\r\nrxp = (rxp+1) % NUM_RX_BUFFER;\r\nport->rxpos = rxp;\r\n}\r\nstatic void\r\ndo_bottom_half_tx(struct fst_card_info *card)\r\n{\r\nstruct fst_port_info *port;\r\nint pi;\r\nint txq_length;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nstruct net_device *dev;\r\ndbg(DBG_TX, "do_bottom_half_tx\n");\r\nfor (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {\r\nif (!port->run)\r\ncontinue;\r\ndev = port_to_dev(port);\r\nwhile (!(FST_RDB(card, txDescrRing[pi][port->txpos].bits) &\r\nDMA_OWN) &&\r\n!(card->dmatx_in_progress)) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nif ((txq_length = port->txqe - port->txqs) < 0) {\r\ntxq_length = txq_length + FST_TXQ_DEPTH;\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nif (txq_length > 0) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nskb = port->txq[port->txqs];\r\nport->txqs++;\r\nif (port->txqs == FST_TXQ_DEPTH) {\r\nport->txqs = 0;\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nFST_WRW(card, txDescrRing[pi][port->txpos].bcnt,\r\ncnv_bcnt(skb->len));\r\nif ((skb->len < FST_MIN_DMA_LEN) ||\r\n(card->family == FST_FAMILY_TXP)) {\r\nmemcpy_toio(card->mem +\r\nBUF_OFFSET(txBuffer[pi]\r\n[port->\r\ntxpos][0]),\r\nskb->data, skb->len);\r\nFST_WRB(card,\r\ntxDescrRing[pi][port->txpos].\r\nbits,\r\nDMA_OWN | TX_STP | TX_ENP);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev->trans_start = jiffies;\r\n} else {\r\nmemcpy(card->tx_dma_handle_host,\r\nskb->data, skb->len);\r\ncard->dma_port_tx = port;\r\ncard->dma_len_tx = skb->len;\r\ncard->dma_txpos = port->txpos;\r\nfst_tx_dma(card,\r\n(char *) card->\r\ntx_dma_handle_card,\r\n(char *)\r\nBUF_OFFSET(txBuffer[pi]\r\n[port->txpos][0]),\r\nskb->len);\r\n}\r\nif (++port->txpos >= NUM_TX_BUFFER)\r\nport->txpos = 0;\r\nif (port->start) {\r\nif (txq_length < fst_txq_low) {\r\nnetif_wake_queue(port_to_dev\r\n(port));\r\nport->start = 0;\r\n}\r\n}\r\ndev_kfree_skb(skb);\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\ndo_bottom_half_rx(struct fst_card_info *card)\r\n{\r\nstruct fst_port_info *port;\r\nint pi;\r\nint rx_count = 0;\r\ndbg(DBG_RX, "do_bottom_half_rx\n");\r\nfor (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {\r\nif (!port->run)\r\ncontinue;\r\nwhile (!(FST_RDB(card, rxDescrRing[pi][port->rxpos].bits)\r\n& DMA_OWN) && !(card->dmarx_in_progress)) {\r\nif (rx_count > fst_max_reads) {\r\nfst_q_work_item(&fst_work_intq, card->card_no);\r\ntasklet_schedule(&fst_int_task);\r\nbreak;\r\n}\r\nfst_intr_rx(card, port);\r\nrx_count++;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t\r\nfst_intr(int dummy, void *dev_id)\r\n{\r\nstruct fst_card_info *card = dev_id;\r\nstruct fst_port_info *port;\r\nint rdidx;\r\nint wridx;\r\nint event;\r\nunsigned int dma_intcsr = 0;\r\nunsigned int do_card_interrupt;\r\nunsigned int int_retry_count;\r\ndbg(DBG_INTR, "intr: %d %p\n", card->irq, card);\r\nif (card->state != FST_RUNNING) {\r\npr_err("Interrupt received for card %d in a non running state (%d)\n",\r\ncard->card_no, card->state);\r\nfst_clear_intr(card);\r\nreturn IRQ_HANDLED;\r\n}\r\nfst_clear_intr(card);\r\ndo_card_interrupt = 0;\r\nif (FST_RDB(card, interruptHandshake) == 1) {\r\ndo_card_interrupt += FST_CARD_INT;\r\nFST_WRB(card, interruptHandshake, 0xEE);\r\n}\r\nif (card->family == FST_FAMILY_TXU) {\r\ndma_intcsr = inl(card->pci_conf + INTCSR_9054);\r\nif (dma_intcsr & 0x00200000) {\r\ndbg(DBG_RX, "DMA Rx xfer complete\n");\r\noutb(0x8, card->pci_conf + DMACSR0);\r\nfst_rx_dma_complete(card, card->dma_port_rx,\r\ncard->dma_len_rx, card->dma_skb_rx,\r\ncard->dma_rxpos);\r\ncard->dmarx_in_progress = 0;\r\ndo_card_interrupt += FST_RX_DMA_INT;\r\n}\r\nif (dma_intcsr & 0x00400000) {\r\ndbg(DBG_TX, "DMA Tx xfer complete\n");\r\noutb(0x8, card->pci_conf + DMACSR1);\r\nfst_tx_dma_complete(card, card->dma_port_tx,\r\ncard->dma_len_tx, card->dma_txpos);\r\ncard->dmatx_in_progress = 0;\r\ndo_card_interrupt += FST_TX_DMA_INT;\r\n}\r\n}\r\nint_retry_count = FST_RDL(card, interruptRetryCount);\r\nif (int_retry_count) {\r\ndbg(DBG_ASS, "Card %d int_retry_count is %d\n",\r\ncard->card_no, int_retry_count);\r\nFST_WRL(card, interruptRetryCount, 0);\r\n}\r\nif (!do_card_interrupt) {\r\nreturn IRQ_HANDLED;\r\n}\r\nfst_q_work_item(&fst_work_intq, card->card_no);\r\ntasklet_schedule(&fst_int_task);\r\nrdidx = FST_RDB(card, interruptEvent.rdindex) & 0x1f;\r\nwridx = FST_RDB(card, interruptEvent.wrindex) & 0x1f;\r\nwhile (rdidx != wridx) {\r\nevent = FST_RDB(card, interruptEvent.evntbuff[rdidx]);\r\nport = &card->ports[event & 0x03];\r\ndbg(DBG_INTR, "Processing Interrupt event: %x\n", event);\r\nswitch (event) {\r\ncase TE1_ALMA:\r\ndbg(DBG_INTR, "TE1 Alarm intr\n");\r\nif (port->run)\r\nfst_intr_te1_alarm(card, port);\r\nbreak;\r\ncase CTLA_CHG:\r\ncase CTLB_CHG:\r\ncase CTLC_CHG:\r\ncase CTLD_CHG:\r\nif (port->run)\r\nfst_intr_ctlchg(card, port);\r\nbreak;\r\ncase ABTA_SENT:\r\ncase ABTB_SENT:\r\ncase ABTC_SENT:\r\ncase ABTD_SENT:\r\ndbg(DBG_TX, "Abort complete port %d\n", port->index);\r\nbreak;\r\ncase TXA_UNDF:\r\ncase TXB_UNDF:\r\ncase TXC_UNDF:\r\ncase TXD_UNDF:\r\ndbg(DBG_TX, "Tx underflow port %d\n", port->index);\r\nport_to_dev(port)->stats.tx_errors++;\r\nport_to_dev(port)->stats.tx_fifo_errors++;\r\ndbg(DBG_ASS, "Tx underflow on card %d port %d\n",\r\ncard->card_no, port->index);\r\nbreak;\r\ncase INIT_CPLT:\r\ndbg(DBG_INIT, "Card init OK intr\n");\r\nbreak;\r\ncase INIT_FAIL:\r\ndbg(DBG_INIT, "Card init FAILED intr\n");\r\ncard->state = FST_IFAILED;\r\nbreak;\r\ndefault:\r\npr_err("intr: unknown card event %d. ignored\n", event);\r\nbreak;\r\n}\r\nif (++rdidx >= MAX_CIRBUFF)\r\nrdidx = 0;\r\n}\r\nFST_WRB(card, interruptEvent.rdindex, rdidx);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\ncheck_started_ok(struct fst_card_info *card)\r\n{\r\nint i;\r\nif (FST_RDW(card, smcVersion) != SMC_VERSION) {\r\npr_err("Bad shared memory version %d expected %d\n",\r\nFST_RDW(card, smcVersion), SMC_VERSION);\r\ncard->state = FST_BADVERSION;\r\nreturn;\r\n}\r\nif (FST_RDL(card, endOfSmcSignature) != END_SIG) {\r\npr_err("Missing shared memory signature\n");\r\ncard->state = FST_BADVERSION;\r\nreturn;\r\n}\r\nif ((i = FST_RDB(card, taskStatus)) == 0x01) {\r\ncard->state = FST_RUNNING;\r\n} else if (i == 0xFF) {\r\npr_err("Firmware initialisation failed. Card halted\n");\r\ncard->state = FST_HALTED;\r\nreturn;\r\n} else if (i != 0x00) {\r\npr_err("Unknown firmware status 0x%x\n", i);\r\ncard->state = FST_HALTED;\r\nreturn;\r\n}\r\nif (FST_RDL(card, numberOfPorts) != card->nports) {\r\npr_warn("Port count mismatch on card %d. Firmware thinks %d we say %d\n",\r\ncard->card_no,\r\nFST_RDL(card, numberOfPorts), card->nports);\r\n}\r\n}\r\nstatic int\r\nset_conf_from_info(struct fst_card_info *card, struct fst_port_info *port,\r\nstruct fstioc_info *info)\r\n{\r\nint err;\r\nunsigned char my_framing;\r\nerr = 0;\r\nif (info->valid & FSTVAL_PROTO) {\r\nif (info->proto == FST_RAW)\r\nport->mode = FST_RAW;\r\nelse\r\nport->mode = FST_GEN_HDLC;\r\n}\r\nif (info->valid & FSTVAL_CABLE)\r\nerr = -EINVAL;\r\nif (info->valid & FSTVAL_SPEED)\r\nerr = -EINVAL;\r\nif (info->valid & FSTVAL_PHASE)\r\nFST_WRB(card, portConfig[port->index].invertClock,\r\ninfo->invertClock);\r\nif (info->valid & FSTVAL_MODE)\r\nFST_WRW(card, cardMode, info->cardMode);\r\nif (info->valid & FSTVAL_TE1) {\r\nFST_WRL(card, suConfig.dataRate, info->lineSpeed);\r\nFST_WRB(card, suConfig.clocking, info->clockSource);\r\nmy_framing = FRAMING_E1;\r\nif (info->framing == E1)\r\nmy_framing = FRAMING_E1;\r\nif (info->framing == T1)\r\nmy_framing = FRAMING_T1;\r\nif (info->framing == J1)\r\nmy_framing = FRAMING_J1;\r\nFST_WRB(card, suConfig.framing, my_framing);\r\nFST_WRB(card, suConfig.structure, info->structure);\r\nFST_WRB(card, suConfig.interface, info->interface);\r\nFST_WRB(card, suConfig.coding, info->coding);\r\nFST_WRB(card, suConfig.lineBuildOut, info->lineBuildOut);\r\nFST_WRB(card, suConfig.equalizer, info->equalizer);\r\nFST_WRB(card, suConfig.transparentMode, info->transparentMode);\r\nFST_WRB(card, suConfig.loopMode, info->loopMode);\r\nFST_WRB(card, suConfig.range, info->range);\r\nFST_WRB(card, suConfig.txBufferMode, info->txBufferMode);\r\nFST_WRB(card, suConfig.rxBufferMode, info->rxBufferMode);\r\nFST_WRB(card, suConfig.startingSlot, info->startingSlot);\r\nFST_WRB(card, suConfig.losThreshold, info->losThreshold);\r\nif (info->idleCode)\r\nFST_WRB(card, suConfig.enableIdleCode, 1);\r\nelse\r\nFST_WRB(card, suConfig.enableIdleCode, 0);\r\nFST_WRB(card, suConfig.idleCode, info->idleCode);\r\n#if FST_DEBUG\r\nif (info->valid & FSTVAL_TE1) {\r\nprintk("Setting TE1 data\n");\r\nprintk("Line Speed = %d\n", info->lineSpeed);\r\nprintk("Start slot = %d\n", info->startingSlot);\r\nprintk("Clock source = %d\n", info->clockSource);\r\nprintk("Framing = %d\n", my_framing);\r\nprintk("Structure = %d\n", info->structure);\r\nprintk("interface = %d\n", info->interface);\r\nprintk("Coding = %d\n", info->coding);\r\nprintk("Line build out = %d\n", info->lineBuildOut);\r\nprintk("Equaliser = %d\n", info->equalizer);\r\nprintk("Transparent mode = %d\n",\r\ninfo->transparentMode);\r\nprintk("Loop mode = %d\n", info->loopMode);\r\nprintk("Range = %d\n", info->range);\r\nprintk("Tx Buffer mode = %d\n", info->txBufferMode);\r\nprintk("Rx Buffer mode = %d\n", info->rxBufferMode);\r\nprintk("LOS Threshold = %d\n", info->losThreshold);\r\nprintk("Idle Code = %d\n", info->idleCode);\r\n}\r\n#endif\r\n}\r\n#if FST_DEBUG\r\nif (info->valid & FSTVAL_DEBUG) {\r\nfst_debug_mask = info->debug;\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nstatic void\r\ngather_conf_info(struct fst_card_info *card, struct fst_port_info *port,\r\nstruct fstioc_info *info)\r\n{\r\nint i;\r\nmemset(info, 0, sizeof (struct fstioc_info));\r\ni = port->index;\r\ninfo->kernelVersion = LINUX_VERSION_CODE;\r\ninfo->nports = card->nports;\r\ninfo->type = card->type;\r\ninfo->state = card->state;\r\ninfo->proto = FST_GEN_HDLC;\r\ninfo->index = i;\r\n#if FST_DEBUG\r\ninfo->debug = fst_debug_mask;\r\n#endif\r\ninfo->valid = ((card->state == FST_RUNNING) ? FSTVAL_ALL : FSTVAL_CARD)\r\n#if FST_DEBUG\r\n| FSTVAL_DEBUG\r\n#endif\r\n;\r\ninfo->lineInterface = FST_RDW(card, portConfig[i].lineInterface);\r\ninfo->internalClock = FST_RDB(card, portConfig[i].internalClock);\r\ninfo->lineSpeed = FST_RDL(card, portConfig[i].lineSpeed);\r\ninfo->invertClock = FST_RDB(card, portConfig[i].invertClock);\r\ninfo->v24IpSts = FST_RDL(card, v24IpSts[i]);\r\ninfo->v24OpSts = FST_RDL(card, v24OpSts[i]);\r\ninfo->clockStatus = FST_RDW(card, clockStatus[i]);\r\ninfo->cableStatus = FST_RDW(card, cableStatus);\r\ninfo->cardMode = FST_RDW(card, cardMode);\r\ninfo->smcFirmwareVersion = FST_RDL(card, smcFirmwareVersion);\r\nif (card->family == FST_FAMILY_TXU) {\r\nif (port->index == 0) {\r\ninfo->cableStatus = info->cableStatus & 1;\r\n} else {\r\ninfo->cableStatus = info->cableStatus >> 1;\r\ninfo->cableStatus = info->cableStatus & 1;\r\n}\r\n}\r\nif (card->type == FST_TYPE_TE1) {\r\ninfo->lineSpeed = FST_RDL(card, suConfig.dataRate);\r\ninfo->clockSource = FST_RDB(card, suConfig.clocking);\r\ninfo->framing = FST_RDB(card, suConfig.framing);\r\ninfo->structure = FST_RDB(card, suConfig.structure);\r\ninfo->interface = FST_RDB(card, suConfig.interface);\r\ninfo->coding = FST_RDB(card, suConfig.coding);\r\ninfo->lineBuildOut = FST_RDB(card, suConfig.lineBuildOut);\r\ninfo->equalizer = FST_RDB(card, suConfig.equalizer);\r\ninfo->loopMode = FST_RDB(card, suConfig.loopMode);\r\ninfo->range = FST_RDB(card, suConfig.range);\r\ninfo->txBufferMode = FST_RDB(card, suConfig.txBufferMode);\r\ninfo->rxBufferMode = FST_RDB(card, suConfig.rxBufferMode);\r\ninfo->startingSlot = FST_RDB(card, suConfig.startingSlot);\r\ninfo->losThreshold = FST_RDB(card, suConfig.losThreshold);\r\nif (FST_RDB(card, suConfig.enableIdleCode))\r\ninfo->idleCode = FST_RDB(card, suConfig.idleCode);\r\nelse\r\ninfo->idleCode = 0;\r\ninfo->receiveBufferDelay =\r\nFST_RDL(card, suStatus.receiveBufferDelay);\r\ninfo->framingErrorCount =\r\nFST_RDL(card, suStatus.framingErrorCount);\r\ninfo->codeViolationCount =\r\nFST_RDL(card, suStatus.codeViolationCount);\r\ninfo->crcErrorCount = FST_RDL(card, suStatus.crcErrorCount);\r\ninfo->lineAttenuation = FST_RDL(card, suStatus.lineAttenuation);\r\ninfo->lossOfSignal = FST_RDB(card, suStatus.lossOfSignal);\r\ninfo->receiveRemoteAlarm =\r\nFST_RDB(card, suStatus.receiveRemoteAlarm);\r\ninfo->alarmIndicationSignal =\r\nFST_RDB(card, suStatus.alarmIndicationSignal);\r\n}\r\n}\r\nstatic int\r\nfst_set_iface(struct fst_card_info *card, struct fst_port_info *port,\r\nstruct ifreq *ifr)\r\n{\r\nsync_serial_settings sync;\r\nint i;\r\nif (ifr->ifr_settings.size != sizeof (sync)) {\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user\r\n(&sync, ifr->ifr_settings.ifs_ifsu.sync, sizeof (sync))) {\r\nreturn -EFAULT;\r\n}\r\nif (sync.loopback)\r\nreturn -EINVAL;\r\ni = port->index;\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_IFACE_V35:\r\nFST_WRW(card, portConfig[i].lineInterface, V35);\r\nport->hwif = V35;\r\nbreak;\r\ncase IF_IFACE_V24:\r\nFST_WRW(card, portConfig[i].lineInterface, V24);\r\nport->hwif = V24;\r\nbreak;\r\ncase IF_IFACE_X21:\r\nFST_WRW(card, portConfig[i].lineInterface, X21);\r\nport->hwif = X21;\r\nbreak;\r\ncase IF_IFACE_X21D:\r\nFST_WRW(card, portConfig[i].lineInterface, X21D);\r\nport->hwif = X21D;\r\nbreak;\r\ncase IF_IFACE_T1:\r\nFST_WRW(card, portConfig[i].lineInterface, T1);\r\nport->hwif = T1;\r\nbreak;\r\ncase IF_IFACE_E1:\r\nFST_WRW(card, portConfig[i].lineInterface, E1);\r\nport->hwif = E1;\r\nbreak;\r\ncase IF_IFACE_SYNC_SERIAL:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (sync.clock_type) {\r\ncase CLOCK_EXT:\r\nFST_WRB(card, portConfig[i].internalClock, EXTCLK);\r\nbreak;\r\ncase CLOCK_INT:\r\nFST_WRB(card, portConfig[i].internalClock, INTCLK);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nFST_WRL(card, portConfig[i].lineSpeed, sync.clock_rate);\r\nreturn 0;\r\n}\r\nstatic int\r\nfst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\r\nstruct ifreq *ifr)\r\n{\r\nsync_serial_settings sync;\r\nint i;\r\nswitch (port->hwif) {\r\ncase E1:\r\nifr->ifr_settings.type = IF_IFACE_E1;\r\nbreak;\r\ncase T1:\r\nifr->ifr_settings.type = IF_IFACE_T1;\r\nbreak;\r\ncase V35:\r\nifr->ifr_settings.type = IF_IFACE_V35;\r\nbreak;\r\ncase V24:\r\nifr->ifr_settings.type = IF_IFACE_V24;\r\nbreak;\r\ncase X21D:\r\nifr->ifr_settings.type = IF_IFACE_X21D;\r\nbreak;\r\ncase X21:\r\ndefault:\r\nifr->ifr_settings.type = IF_IFACE_X21;\r\nbreak;\r\n}\r\nif (ifr->ifr_settings.size == 0) {\r\nreturn 0;\r\n}\r\nif (ifr->ifr_settings.size < sizeof (sync)) {\r\nreturn -ENOMEM;\r\n}\r\ni = port->index;\r\nsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\r\nsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\r\nINTCLK ? CLOCK_INT : CLOCK_EXT;\r\nsync.loopback = 0;\r\nif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\r\nreturn -EFAULT;\r\n}\r\nifr->ifr_settings.size = sizeof (sync);\r\nreturn 0;\r\n}\r\nstatic int\r\nfst_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct fst_card_info *card;\r\nstruct fst_port_info *port;\r\nstruct fstioc_write wrthdr;\r\nstruct fstioc_info info;\r\nunsigned long flags;\r\nvoid *buf;\r\ndbg(DBG_IOCTL, "ioctl: %x, %p\n", cmd, ifr->ifr_data);\r\nport = dev_to_port(dev);\r\ncard = port->card;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase FSTCPURESET:\r\nfst_cpureset(card);\r\ncard->state = FST_RESET;\r\nreturn 0;\r\ncase FSTCPURELEASE:\r\nfst_cpurelease(card);\r\ncard->state = FST_STARTING;\r\nreturn 0;\r\ncase FSTWRITE:\r\nif (ifr->ifr_data == NULL) {\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&wrthdr, ifr->ifr_data,\r\nsizeof (struct fstioc_write))) {\r\nreturn -EFAULT;\r\n}\r\nif (wrthdr.size > FST_MEMSIZE || wrthdr.offset > FST_MEMSIZE ||\r\nwrthdr.size + wrthdr.offset > FST_MEMSIZE) {\r\nreturn -ENXIO;\r\n}\r\nbuf = memdup_user(ifr->ifr_data + sizeof(struct fstioc_write),\r\nwrthdr.size);\r\nif (IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nmemcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);\r\nkfree(buf);\r\nif (card->state == FST_RESET) {\r\ncard->state = FST_DOWNLOAD;\r\n}\r\nreturn 0;\r\ncase FSTGETCONF:\r\nif (card->state == FST_STARTING) {\r\ncheck_started_ok(card);\r\nif (card->state == FST_RUNNING) {\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nfst_enable_intr(card);\r\nFST_WRB(card, interruptHandshake, 0xEE);\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\n}\r\n}\r\nif (ifr->ifr_data == NULL) {\r\nreturn -EINVAL;\r\n}\r\ngather_conf_info(card, port, &info);\r\nif (copy_to_user(ifr->ifr_data, &info, sizeof (info))) {\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\ncase FSTSETCONF:\r\nif (card->state != FST_RUNNING) {\r\npr_err("Attempt to configure card %d in non-running state (%d)\n",\r\ncard->card_no, card->state);\r\nreturn -EIO;\r\n}\r\nif (copy_from_user(&info, ifr->ifr_data, sizeof (info))) {\r\nreturn -EFAULT;\r\n}\r\nreturn set_conf_from_info(card, port, &info);\r\ncase SIOCWANDEV:\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\nreturn fst_get_iface(card, port, ifr);\r\ncase IF_IFACE_SYNC_SERIAL:\r\ncase IF_IFACE_V35:\r\ncase IF_IFACE_V24:\r\ncase IF_IFACE_X21:\r\ncase IF_IFACE_X21D:\r\ncase IF_IFACE_T1:\r\ncase IF_IFACE_E1:\r\nreturn fst_set_iface(card, port, ifr);\r\ncase IF_PROTO_RAW:\r\nport->mode = FST_RAW;\r\nreturn 0;\r\ncase IF_GET_PROTO:\r\nif (port->mode == FST_RAW) {\r\nifr->ifr_settings.type = IF_PROTO_RAW;\r\nreturn 0;\r\n}\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\ndefault:\r\nport->mode = FST_GEN_HDLC;\r\ndbg(DBG_IOCTL, "Passing this type to hdlc %x\n",\r\nifr->ifr_settings.type);\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic void\r\nfst_openport(struct fst_port_info *port)\r\n{\r\nint signals;\r\nint txq_length;\r\nif (port->card->state == FST_RUNNING) {\r\nif (port->run) {\r\ndbg(DBG_OPEN, "open: found port already running\n");\r\nfst_issue_cmd(port, STOPPORT);\r\nport->run = 0;\r\n}\r\nfst_rx_config(port);\r\nfst_tx_config(port);\r\nfst_op_raise(port, OPSTS_RTS | OPSTS_DTR);\r\nfst_issue_cmd(port, STARTPORT);\r\nport->run = 1;\r\nsignals = FST_RDL(port->card, v24DebouncedSts[port->index]);\r\nif (signals & (((port->hwif == X21) || (port->hwif == X21D))\r\n? IPSTS_INDICATE : IPSTS_DCD))\r\nnetif_carrier_on(port_to_dev(port));\r\nelse\r\nnetif_carrier_off(port_to_dev(port));\r\ntxq_length = port->txqe - port->txqs;\r\nport->txqe = 0;\r\nport->txqs = 0;\r\n}\r\n}\r\nstatic void\r\nfst_closeport(struct fst_port_info *port)\r\n{\r\nif (port->card->state == FST_RUNNING) {\r\nif (port->run) {\r\nport->run = 0;\r\nfst_op_lower(port, OPSTS_RTS | OPSTS_DTR);\r\nfst_issue_cmd(port, STOPPORT);\r\n} else {\r\ndbg(DBG_OPEN, "close: port not running\n");\r\n}\r\n}\r\n}\r\nstatic int\r\nfst_open(struct net_device *dev)\r\n{\r\nint err;\r\nstruct fst_port_info *port;\r\nport = dev_to_port(dev);\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -EBUSY;\r\nif (port->mode != FST_RAW) {\r\nerr = hdlc_open(dev);\r\nif (err) {\r\nmodule_put(THIS_MODULE);\r\nreturn err;\r\n}\r\n}\r\nfst_openport(port);\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nfst_close(struct net_device *dev)\r\n{\r\nstruct fst_port_info *port;\r\nstruct fst_card_info *card;\r\nunsigned char tx_dma_done;\r\nunsigned char rx_dma_done;\r\nport = dev_to_port(dev);\r\ncard = port->card;\r\ntx_dma_done = inb(card->pci_conf + DMACSR1);\r\nrx_dma_done = inb(card->pci_conf + DMACSR0);\r\ndbg(DBG_OPEN,\r\n"Port Close: tx_dma_in_progress = %d (%x) rx_dma_in_progress = %d (%x)\n",\r\ncard->dmatx_in_progress, tx_dma_done, card->dmarx_in_progress,\r\nrx_dma_done);\r\nnetif_stop_queue(dev);\r\nfst_closeport(dev_to_port(dev));\r\nif (port->mode != FST_RAW) {\r\nhdlc_close(dev);\r\n}\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nstatic int\r\nfst_attach(struct net_device *dev, unsigned short encoding, unsigned short parity)\r\n{\r\nif (encoding != ENCODING_NRZ || parity != PARITY_CRC16_PR1_CCITT)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void\r\nfst_tx_timeout(struct net_device *dev)\r\n{\r\nstruct fst_port_info *port;\r\nstruct fst_card_info *card;\r\nport = dev_to_port(dev);\r\ncard = port->card;\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\ndbg(DBG_ASS, "Tx timeout card %d port %d\n",\r\ncard->card_no, port->index);\r\nfst_issue_cmd(port, ABORTTX);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\nport->start = 0;\r\n}\r\nstatic netdev_tx_t\r\nfst_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct fst_card_info *card;\r\nstruct fst_port_info *port;\r\nunsigned long flags;\r\nint txq_length;\r\nport = dev_to_port(dev);\r\ncard = port->card;\r\ndbg(DBG_TX, "fst_start_xmit: length = %d\n", skb->len);\r\nif (!netif_carrier_ok(dev)) {\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_carrier_errors++;\r\ndbg(DBG_ASS,\r\n"Tried to transmit but no carrier on card %d port %d\n",\r\ncard->card_no, port->index);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb->len > LEN_TX_BUFFER) {\r\ndbg(DBG_ASS, "Packet too large %d vs %d\n", skb->len,\r\nLEN_TX_BUFFER);\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nif ((txq_length = port->txqe - port->txqs) < 0) {\r\ntxq_length = txq_length + FST_TXQ_DEPTH;\r\n}\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nif (txq_length > fst_txq_high) {\r\nnetif_stop_queue(dev);\r\nport->start = 1;\r\n}\r\nif (txq_length == FST_TXQ_DEPTH - 1) {\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_errors++;\r\ndbg(DBG_ASS, "Tx queue overflow card %d port %d\n",\r\ncard->card_no, port->index);\r\nreturn NETDEV_TX_OK;\r\n}\r\nspin_lock_irqsave(&card->card_lock, flags);\r\nport->txq[port->txqe] = skb;\r\nport->txqe++;\r\nif (port->txqe == FST_TXQ_DEPTH)\r\nport->txqe = 0;\r\nspin_unlock_irqrestore(&card->card_lock, flags);\r\nfst_q_work_item(&fst_work_txq, card->card_no);\r\ntasklet_schedule(&fst_tx_task);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nfst_init_card(struct fst_card_info *card)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < card->nports; i++) {\r\nerr = register_hdlc_device(card->ports[i].dev);\r\nif (err < 0) {\r\nint j;\r\npr_err("Cannot register HDLC device for port %d (errno %d)\n",\r\ni, -err);\r\nfor (j = i; j < card->nports; j++) {\r\nfree_netdev(card->ports[j].dev);\r\ncard->ports[j].dev = NULL;\r\n}\r\ncard->nports = i;\r\nbreak;\r\n}\r\n}\r\npr_info("%s-%s: %s IRQ%d, %d ports\n",\r\nport_to_dev(&card->ports[0])->name,\r\nport_to_dev(&card->ports[card->nports - 1])->name,\r\ntype_strings[card->type], card->irq, card->nports);\r\n}\r\nstatic int\r\nfst_add_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstatic int no_of_cards_added = 0;\r\nstruct fst_card_info *card;\r\nint err = 0;\r\nint i;\r\nprintk_once(KERN_INFO\r\npr_fmt("FarSync WAN driver " FST_USER_VERSION\r\n" (c) 2001-2004 FarSite Communications Ltd.\n"));\r\n#if FST_DEBUG\r\ndbg(DBG_ASS, "The value of debug mask is %x\n", fst_debug_mask);\r\n#endif\r\nif (fst_excluded_cards != 0) {\r\nfor (i = 0; i < fst_excluded_cards; i++) {\r\nif ((pdev->devfn) >> 3 == fst_excluded_list[i]) {\r\npr_info("FarSync PCI device %d not assigned\n",\r\n(pdev->devfn) >> 3);\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\ncard = kzalloc(sizeof(struct fst_card_info), GFP_KERNEL);\r\nif (card == NULL)\r\nreturn -ENOMEM;\r\nif ((err = pci_enable_device(pdev)) != 0) {\r\npr_err("Failed to enable card. Err %d\n", -err);\r\nkfree(card);\r\nreturn err;\r\n}\r\nif ((err = pci_request_regions(pdev, "FarSync")) !=0) {\r\npr_err("Failed to allocate regions. Err %d\n", -err);\r\npci_disable_device(pdev);\r\nkfree(card);\r\nreturn err;\r\n}\r\ncard->pci_conf = pci_resource_start(pdev, 1);\r\ncard->phys_mem = pci_resource_start(pdev, 2);\r\ncard->phys_ctlmem = pci_resource_start(pdev, 3);\r\nif ((card->mem = ioremap(card->phys_mem, FST_MEMSIZE)) == NULL) {\r\npr_err("Physical memory remap failed\n");\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(card);\r\nreturn -ENODEV;\r\n}\r\nif ((card->ctlmem = ioremap(card->phys_ctlmem, 0x10)) == NULL) {\r\npr_err("Control memory remap failed\n");\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\niounmap(card->mem);\r\nkfree(card);\r\nreturn -ENODEV;\r\n}\r\ndbg(DBG_PCI, "kernel mem %p, ctlmem %p\n", card->mem, card->ctlmem);\r\nif (request_irq(pdev->irq, fst_intr, IRQF_SHARED, FST_DEV_NAME, card)) {\r\npr_err("Unable to register interrupt %d\n", card->irq);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\niounmap(card->ctlmem);\r\niounmap(card->mem);\r\nkfree(card);\r\nreturn -ENODEV;\r\n}\r\ncard->irq = pdev->irq;\r\ncard->type = ent->driver_data;\r\ncard->family = ((ent->driver_data == FST_TYPE_T2P) ||\r\n(ent->driver_data == FST_TYPE_T4P))\r\n? FST_FAMILY_TXP : FST_FAMILY_TXU;\r\nif ((ent->driver_data == FST_TYPE_T1U) ||\r\n(ent->driver_data == FST_TYPE_TE1))\r\ncard->nports = 1;\r\nelse\r\ncard->nports = ((ent->driver_data == FST_TYPE_T2P) ||\r\n(ent->driver_data == FST_TYPE_T2U)) ? 2 : 4;\r\ncard->state = FST_UNINIT;\r\nspin_lock_init ( &card->card_lock );\r\nfor ( i = 0 ; i < card->nports ; i++ ) {\r\nstruct net_device *dev = alloc_hdlcdev(&card->ports[i]);\r\nhdlc_device *hdlc;\r\nif (!dev) {\r\nwhile (i--)\r\nfree_netdev(card->ports[i].dev);\r\npr_err("FarSync: out of memory\n");\r\nfree_irq(card->irq, card);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\niounmap(card->ctlmem);\r\niounmap(card->mem);\r\nkfree(card);\r\nreturn -ENODEV;\r\n}\r\ncard->ports[i].dev = dev;\r\ncard->ports[i].card = card;\r\ncard->ports[i].index = i;\r\ncard->ports[i].run = 0;\r\nhdlc = dev_to_hdlc(dev);\r\ndev->mem_start = card->phys_mem\r\n+ BUF_OFFSET ( txBuffer[i][0][0]);\r\ndev->mem_end = card->phys_mem\r\n+ BUF_OFFSET ( txBuffer[i][NUM_TX_BUFFER][0]);\r\ndev->base_addr = card->pci_conf;\r\ndev->irq = card->irq;\r\ndev->netdev_ops = &fst_ops;\r\ndev->tx_queue_len = FST_TX_QUEUE_LEN;\r\ndev->watchdog_timeo = FST_TX_TIMEOUT;\r\nhdlc->attach = fst_attach;\r\nhdlc->xmit = fst_start_xmit;\r\n}\r\ncard->device = pdev;\r\ndbg(DBG_PCI, "type %d nports %d irq %d\n", card->type,\r\ncard->nports, card->irq);\r\ndbg(DBG_PCI, "conf %04x mem %08x ctlmem %08x\n",\r\ncard->pci_conf, card->phys_mem, card->phys_ctlmem);\r\nfst_cpureset(card);\r\ncard->state = FST_RESET;\r\nfst_init_dma(card);\r\npci_set_drvdata(pdev, card);\r\nfst_card_array[no_of_cards_added] = card;\r\ncard->card_no = no_of_cards_added++;\r\nfst_init_card(card);\r\nif (card->family == FST_FAMILY_TXU) {\r\ncard->rx_dma_handle_host =\r\npci_alloc_consistent(card->device, FST_MAX_MTU,\r\n&card->rx_dma_handle_card);\r\nif (card->rx_dma_handle_host == NULL) {\r\npr_err("Could not allocate rx dma buffer\n");\r\nfst_disable_intr(card);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\niounmap(card->ctlmem);\r\niounmap(card->mem);\r\nkfree(card);\r\nreturn -ENOMEM;\r\n}\r\ncard->tx_dma_handle_host =\r\npci_alloc_consistent(card->device, FST_MAX_MTU,\r\n&card->tx_dma_handle_card);\r\nif (card->tx_dma_handle_host == NULL) {\r\npr_err("Could not allocate tx dma buffer\n");\r\nfst_disable_intr(card);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\niounmap(card->ctlmem);\r\niounmap(card->mem);\r\nkfree(card);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfst_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct fst_card_info *card;\r\nint i;\r\ncard = pci_get_drvdata(pdev);\r\nfor (i = 0; i < card->nports; i++) {\r\nstruct net_device *dev = port_to_dev(&card->ports[i]);\r\nunregister_hdlc_device(dev);\r\n}\r\nfst_disable_intr(card);\r\nfree_irq(card->irq, card);\r\niounmap(card->ctlmem);\r\niounmap(card->mem);\r\npci_release_regions(pdev);\r\nif (card->family == FST_FAMILY_TXU) {\r\npci_free_consistent(card->device, FST_MAX_MTU,\r\ncard->rx_dma_handle_host,\r\ncard->rx_dma_handle_card);\r\npci_free_consistent(card->device, FST_MAX_MTU,\r\ncard->tx_dma_handle_host,\r\ncard->tx_dma_handle_card);\r\n}\r\nfst_card_array[card->card_no] = NULL;\r\n}\r\nstatic int __init\r\nfst_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < FST_MAX_CARDS; i++)\r\nfst_card_array[i] = NULL;\r\nspin_lock_init(&fst_work_q_lock);\r\nreturn pci_register_driver(&fst_driver);\r\n}\r\nstatic void __exit\r\nfst_cleanup_module(void)\r\n{\r\npr_info("FarSync WAN driver unloading\n");\r\npci_unregister_driver(&fst_driver);\r\n}
