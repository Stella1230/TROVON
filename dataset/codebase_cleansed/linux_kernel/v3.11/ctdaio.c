static int daio_master(struct rsc *rsc)\r\n{\r\nreturn rsc->conj = rsc->idx;\r\n}\r\nstatic int daio_index(const struct rsc *rsc)\r\n{\r\nreturn rsc->conj;\r\n}\r\nstatic int daio_out_next_conj(struct rsc *rsc)\r\n{\r\nreturn rsc->conj += 2;\r\n}\r\nstatic int daio_in_next_conj_20k1(struct rsc *rsc)\r\n{\r\nreturn rsc->conj += 0x200;\r\n}\r\nstatic int daio_in_next_conj_20k2(struct rsc *rsc)\r\n{\r\nreturn rsc->conj += 0x100;\r\n}\r\nstatic unsigned int daio_device_index(enum DAIOTYP type, struct hw *hw)\r\n{\r\nswitch (hw->chip_type) {\r\ncase ATC20K1:\r\nswitch (type) {\r\ncase SPDIFOO: return 0;\r\ncase SPDIFIO: return 0;\r\ncase SPDIFI1: return 1;\r\ncase LINEO1: return 4;\r\ncase LINEO2: return 7;\r\ncase LINEO3: return 5;\r\ncase LINEO4: return 6;\r\ncase LINEIM: return 7;\r\ndefault: return -EINVAL;\r\n}\r\ncase ATC20K2:\r\nswitch (type) {\r\ncase SPDIFOO: return 0;\r\ncase SPDIFIO: return 0;\r\ncase LINEO1: return 4;\r\ncase LINEO2: return 7;\r\ncase LINEO3: return 5;\r\ncase LINEO4: return 6;\r\ncase LINEIM: return 4;\r\ncase MIC: return 5;\r\ndefault: return -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int dao_spdif_get_spos(struct dao *dao, unsigned int *spos)\r\n{\r\n((struct hw *)dao->hw)->dao_get_spos(dao->ctrl_blk, spos);\r\nreturn 0;\r\n}\r\nstatic int dao_spdif_set_spos(struct dao *dao, unsigned int spos)\r\n{\r\n((struct hw *)dao->hw)->dao_set_spos(dao->ctrl_blk, spos);\r\nreturn 0;\r\n}\r\nstatic int dao_commit_write(struct dao *dao)\r\n{\r\n((struct hw *)dao->hw)->dao_commit_write(dao->hw,\r\ndaio_device_index(dao->daio.type, dao->hw), dao->ctrl_blk);\r\nreturn 0;\r\n}\r\nstatic int dao_set_left_input(struct dao *dao, struct rsc *input)\r\n{\r\nstruct imapper *entry;\r\nstruct daio *daio = &dao->daio;\r\nint i;\r\nentry = kzalloc((sizeof(*entry) * daio->rscl.msr), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\ndao->ops->clear_left_input(dao);\r\ninput->ops->master(input);\r\ndaio->rscl.ops->master(&daio->rscl);\r\nfor (i = 0; i < daio->rscl.msr; i++, entry++) {\r\nentry->slot = input->ops->output_slot(input);\r\nentry->user = entry->addr = daio->rscl.ops->index(&daio->rscl);\r\ndao->mgr->imap_add(dao->mgr, entry);\r\ndao->imappers[i] = entry;\r\ninput->ops->next_conj(input);\r\ndaio->rscl.ops->next_conj(&daio->rscl);\r\n}\r\ninput->ops->master(input);\r\ndaio->rscl.ops->master(&daio->rscl);\r\nreturn 0;\r\n}\r\nstatic int dao_set_right_input(struct dao *dao, struct rsc *input)\r\n{\r\nstruct imapper *entry;\r\nstruct daio *daio = &dao->daio;\r\nint i;\r\nentry = kzalloc((sizeof(*entry) * daio->rscr.msr), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\ndao->ops->clear_right_input(dao);\r\ninput->ops->master(input);\r\ndaio->rscr.ops->master(&daio->rscr);\r\nfor (i = 0; i < daio->rscr.msr; i++, entry++) {\r\nentry->slot = input->ops->output_slot(input);\r\nentry->user = entry->addr = daio->rscr.ops->index(&daio->rscr);\r\ndao->mgr->imap_add(dao->mgr, entry);\r\ndao->imappers[daio->rscl.msr + i] = entry;\r\ninput->ops->next_conj(input);\r\ndaio->rscr.ops->next_conj(&daio->rscr);\r\n}\r\ninput->ops->master(input);\r\ndaio->rscr.ops->master(&daio->rscr);\r\nreturn 0;\r\n}\r\nstatic int dao_clear_left_input(struct dao *dao)\r\n{\r\nstruct imapper *entry;\r\nstruct daio *daio = &dao->daio;\r\nint i;\r\nif (!dao->imappers[0])\r\nreturn 0;\r\nentry = dao->imappers[0];\r\ndao->mgr->imap_delete(dao->mgr, entry);\r\nfor (i = 1; i < daio->rscl.msr; i++) {\r\nentry = dao->imappers[i];\r\ndao->mgr->imap_delete(dao->mgr, entry);\r\ndao->imappers[i] = NULL;\r\n}\r\nkfree(dao->imappers[0]);\r\ndao->imappers[0] = NULL;\r\nreturn 0;\r\n}\r\nstatic int dao_clear_right_input(struct dao *dao)\r\n{\r\nstruct imapper *entry;\r\nstruct daio *daio = &dao->daio;\r\nint i;\r\nif (!dao->imappers[daio->rscl.msr])\r\nreturn 0;\r\nentry = dao->imappers[daio->rscl.msr];\r\ndao->mgr->imap_delete(dao->mgr, entry);\r\nfor (i = 1; i < daio->rscr.msr; i++) {\r\nentry = dao->imappers[daio->rscl.msr + i];\r\ndao->mgr->imap_delete(dao->mgr, entry);\r\ndao->imappers[daio->rscl.msr + i] = NULL;\r\n}\r\nkfree(dao->imappers[daio->rscl.msr]);\r\ndao->imappers[daio->rscl.msr] = NULL;\r\nreturn 0;\r\n}\r\nstatic int dai_set_srt_srcl(struct dai *dai, struct rsc *src)\r\n{\r\nsrc->ops->master(src);\r\n((struct hw *)dai->hw)->dai_srt_set_srcm(dai->ctrl_blk,\r\nsrc->ops->index(src));\r\nreturn 0;\r\n}\r\nstatic int dai_set_srt_srcr(struct dai *dai, struct rsc *src)\r\n{\r\nsrc->ops->master(src);\r\n((struct hw *)dai->hw)->dai_srt_set_srco(dai->ctrl_blk,\r\nsrc->ops->index(src));\r\nreturn 0;\r\n}\r\nstatic int dai_set_srt_msr(struct dai *dai, unsigned int msr)\r\n{\r\nunsigned int rsr;\r\nfor (rsr = 0; msr > 1; msr >>= 1)\r\nrsr++;\r\n((struct hw *)dai->hw)->dai_srt_set_rsr(dai->ctrl_blk, rsr);\r\nreturn 0;\r\n}\r\nstatic int dai_set_enb_src(struct dai *dai, unsigned int enb)\r\n{\r\n((struct hw *)dai->hw)->dai_srt_set_ec(dai->ctrl_blk, enb);\r\nreturn 0;\r\n}\r\nstatic int dai_set_enb_srt(struct dai *dai, unsigned int enb)\r\n{\r\n((struct hw *)dai->hw)->dai_srt_set_et(dai->ctrl_blk, enb);\r\nreturn 0;\r\n}\r\nstatic int dai_commit_write(struct dai *dai)\r\n{\r\n((struct hw *)dai->hw)->dai_commit_write(dai->hw,\r\ndaio_device_index(dai->daio.type, dai->hw), dai->ctrl_blk);\r\nreturn 0;\r\n}\r\nstatic int daio_rsc_init(struct daio *daio,\r\nconst struct daio_desc *desc,\r\nvoid *hw)\r\n{\r\nint err;\r\nunsigned int idx_l, idx_r;\r\nswitch (((struct hw *)hw)->chip_type) {\r\ncase ATC20K1:\r\nidx_l = idx_20k1[desc->type].left;\r\nidx_r = idx_20k1[desc->type].right;\r\nbreak;\r\ncase ATC20K2:\r\nidx_l = idx_20k2[desc->type].left;\r\nidx_r = idx_20k2[desc->type].right;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = rsc_init(&daio->rscl, idx_l, DAIO, desc->msr, hw);\r\nif (err)\r\nreturn err;\r\nerr = rsc_init(&daio->rscr, idx_r, DAIO, desc->msr, hw);\r\nif (err)\r\ngoto error1;\r\nif (desc->type <= DAIO_OUT_MAX) {\r\ndaio->rscl.ops = daio->rscr.ops = &daio_out_rsc_ops;\r\n} else {\r\nswitch (((struct hw *)hw)->chip_type) {\r\ncase ATC20K1:\r\ndaio->rscl.ops = daio->rscr.ops = &daio_in_rsc_ops_20k1;\r\nbreak;\r\ncase ATC20K2:\r\ndaio->rscl.ops = daio->rscr.ops = &daio_in_rsc_ops_20k2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ndaio->type = desc->type;\r\nreturn 0;\r\nerror1:\r\nrsc_uninit(&daio->rscl);\r\nreturn err;\r\n}\r\nstatic int daio_rsc_uninit(struct daio *daio)\r\n{\r\nrsc_uninit(&daio->rscl);\r\nrsc_uninit(&daio->rscr);\r\nreturn 0;\r\n}\r\nstatic int dao_rsc_init(struct dao *dao,\r\nconst struct daio_desc *desc,\r\nstruct daio_mgr *mgr)\r\n{\r\nstruct hw *hw = mgr->mgr.hw;\r\nunsigned int conf;\r\nint err;\r\nerr = daio_rsc_init(&dao->daio, desc, mgr->mgr.hw);\r\nif (err)\r\nreturn err;\r\ndao->imappers = kzalloc(sizeof(void *)*desc->msr*2, GFP_KERNEL);\r\nif (!dao->imappers) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\ndao->ops = &dao_ops;\r\ndao->mgr = mgr;\r\ndao->hw = hw;\r\nerr = hw->dao_get_ctrl_blk(&dao->ctrl_blk);\r\nif (err)\r\ngoto error2;\r\nhw->daio_mgr_dsb_dao(mgr->mgr.ctrl_blk,\r\ndaio_device_index(dao->daio.type, hw));\r\nhw->daio_mgr_commit_write(hw, mgr->mgr.ctrl_blk);\r\nconf = (desc->msr & 0x7) | (desc->passthru << 3);\r\nhw->daio_mgr_dao_init(mgr->mgr.ctrl_blk,\r\ndaio_device_index(dao->daio.type, hw), conf);\r\nhw->daio_mgr_enb_dao(mgr->mgr.ctrl_blk,\r\ndaio_device_index(dao->daio.type, hw));\r\nhw->daio_mgr_commit_write(hw, mgr->mgr.ctrl_blk);\r\nreturn 0;\r\nerror2:\r\nkfree(dao->imappers);\r\ndao->imappers = NULL;\r\nerror1:\r\ndaio_rsc_uninit(&dao->daio);\r\nreturn err;\r\n}\r\nstatic int dao_rsc_uninit(struct dao *dao)\r\n{\r\nif (dao->imappers) {\r\nif (dao->imappers[0])\r\ndao_clear_left_input(dao);\r\nif (dao->imappers[dao->daio.rscl.msr])\r\ndao_clear_right_input(dao);\r\nkfree(dao->imappers);\r\ndao->imappers = NULL;\r\n}\r\n((struct hw *)dao->hw)->dao_put_ctrl_blk(dao->ctrl_blk);\r\ndao->hw = dao->ctrl_blk = NULL;\r\ndaio_rsc_uninit(&dao->daio);\r\nreturn 0;\r\n}\r\nstatic int dao_rsc_reinit(struct dao *dao, const struct dao_desc *desc)\r\n{\r\nstruct daio_mgr *mgr = dao->mgr;\r\nstruct daio_desc dsc = {0};\r\ndsc.type = dao->daio.type;\r\ndsc.msr = desc->msr;\r\ndsc.passthru = desc->passthru;\r\ndao_rsc_uninit(dao);\r\nreturn dao_rsc_init(dao, &dsc, mgr);\r\n}\r\nstatic int dai_rsc_init(struct dai *dai,\r\nconst struct daio_desc *desc,\r\nstruct daio_mgr *mgr)\r\n{\r\nint err;\r\nstruct hw *hw = mgr->mgr.hw;\r\nunsigned int rsr, msr;\r\nerr = daio_rsc_init(&dai->daio, desc, mgr->mgr.hw);\r\nif (err)\r\nreturn err;\r\ndai->ops = &dai_ops;\r\ndai->hw = mgr->mgr.hw;\r\nerr = hw->dai_get_ctrl_blk(&dai->ctrl_blk);\r\nif (err)\r\ngoto error1;\r\nfor (rsr = 0, msr = desc->msr; msr > 1; msr >>= 1)\r\nrsr++;\r\nhw->dai_srt_set_rsr(dai->ctrl_blk, rsr);\r\nhw->dai_srt_set_drat(dai->ctrl_blk, 0);\r\nhw->dai_srt_set_ec(dai->ctrl_blk, 0);\r\nhw->dai_srt_set_et(dai->ctrl_blk, 0);\r\nhw->dai_commit_write(hw,\r\ndaio_device_index(dai->daio.type, dai->hw), dai->ctrl_blk);\r\nreturn 0;\r\nerror1:\r\ndaio_rsc_uninit(&dai->daio);\r\nreturn err;\r\n}\r\nstatic int dai_rsc_uninit(struct dai *dai)\r\n{\r\n((struct hw *)dai->hw)->dai_put_ctrl_blk(dai->ctrl_blk);\r\ndai->hw = dai->ctrl_blk = NULL;\r\ndaio_rsc_uninit(&dai->daio);\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_get_rsc(struct rsc_mgr *mgr, enum DAIOTYP type)\r\n{\r\nif (((struct daio_usage *)mgr->rscs)->data & (0x1 << type))\r\nreturn -ENOENT;\r\n((struct daio_usage *)mgr->rscs)->data |= (0x1 << type);\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_put_rsc(struct rsc_mgr *mgr, enum DAIOTYP type)\r\n{\r\n((struct daio_usage *)mgr->rscs)->data &= ~(0x1 << type);\r\nreturn 0;\r\n}\r\nstatic int get_daio_rsc(struct daio_mgr *mgr,\r\nconst struct daio_desc *desc,\r\nstruct daio **rdaio)\r\n{\r\nint err;\r\nstruct dai *dai = NULL;\r\nstruct dao *dao = NULL;\r\nunsigned long flags;\r\n*rdaio = NULL;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nerr = daio_mgr_get_rsc(&mgr->mgr, desc->type);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nif (err) {\r\nprintk(KERN_ERR "Can't meet DAIO resource request!\n");\r\nreturn err;\r\n}\r\nif (desc->type <= DAIO_OUT_MAX) {\r\ndao = kzalloc(sizeof(*dao), GFP_KERNEL);\r\nif (!dao) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nerr = dao_rsc_init(dao, desc, mgr);\r\nif (err)\r\ngoto error;\r\n*rdaio = &dao->daio;\r\n} else {\r\ndai = kzalloc(sizeof(*dai), GFP_KERNEL);\r\nif (!dai) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nerr = dai_rsc_init(dai, desc, mgr);\r\nif (err)\r\ngoto error;\r\n*rdaio = &dai->daio;\r\n}\r\nmgr->daio_enable(mgr, *rdaio);\r\nmgr->commit_write(mgr);\r\nreturn 0;\r\nerror:\r\nif (dao)\r\nkfree(dao);\r\nelse if (dai)\r\nkfree(dai);\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\ndaio_mgr_put_rsc(&mgr->mgr, desc->type);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nreturn err;\r\n}\r\nstatic int put_daio_rsc(struct daio_mgr *mgr, struct daio *daio)\r\n{\r\nunsigned long flags;\r\nmgr->daio_disable(mgr, daio);\r\nmgr->commit_write(mgr);\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\ndaio_mgr_put_rsc(&mgr->mgr, daio->type);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nif (daio->type <= DAIO_OUT_MAX) {\r\ndao_rsc_uninit(container_of(daio, struct dao, daio));\r\nkfree(container_of(daio, struct dao, daio));\r\n} else {\r\ndai_rsc_uninit(container_of(daio, struct dai, daio));\r\nkfree(container_of(daio, struct dai, daio));\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_enb_daio(struct daio_mgr *mgr, struct daio *daio)\r\n{\r\nstruct hw *hw = mgr->mgr.hw;\r\nif (DAIO_OUT_MAX >= daio->type) {\r\nhw->daio_mgr_enb_dao(mgr->mgr.ctrl_blk,\r\ndaio_device_index(daio->type, hw));\r\n} else {\r\nhw->daio_mgr_enb_dai(mgr->mgr.ctrl_blk,\r\ndaio_device_index(daio->type, hw));\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_dsb_daio(struct daio_mgr *mgr, struct daio *daio)\r\n{\r\nstruct hw *hw = mgr->mgr.hw;\r\nif (DAIO_OUT_MAX >= daio->type) {\r\nhw->daio_mgr_dsb_dao(mgr->mgr.ctrl_blk,\r\ndaio_device_index(daio->type, hw));\r\n} else {\r\nhw->daio_mgr_dsb_dai(mgr->mgr.ctrl_blk,\r\ndaio_device_index(daio->type, hw));\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_map_op(void *data, struct imapper *entry)\r\n{\r\nstruct rsc_mgr *mgr = &((struct daio_mgr *)data)->mgr;\r\nstruct hw *hw = mgr->hw;\r\nhw->daio_mgr_set_imaparc(mgr->ctrl_blk, entry->slot);\r\nhw->daio_mgr_set_imapnxt(mgr->ctrl_blk, entry->next);\r\nhw->daio_mgr_set_imapaddr(mgr->ctrl_blk, entry->addr);\r\nhw->daio_mgr_commit_write(mgr->hw, mgr->ctrl_blk);\r\nreturn 0;\r\n}\r\nstatic int daio_imap_add(struct daio_mgr *mgr, struct imapper *entry)\r\n{\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&mgr->imap_lock, flags);\r\nif (!entry->addr && mgr->init_imap_added) {\r\ninput_mapper_delete(&mgr->imappers, mgr->init_imap,\r\ndaio_map_op, mgr);\r\nmgr->init_imap_added = 0;\r\n}\r\nerr = input_mapper_add(&mgr->imappers, entry, daio_map_op, mgr);\r\nspin_unlock_irqrestore(&mgr->imap_lock, flags);\r\nreturn err;\r\n}\r\nstatic int daio_imap_delete(struct daio_mgr *mgr, struct imapper *entry)\r\n{\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&mgr->imap_lock, flags);\r\nerr = input_mapper_delete(&mgr->imappers, entry, daio_map_op, mgr);\r\nif (list_empty(&mgr->imappers)) {\r\ninput_mapper_add(&mgr->imappers, mgr->init_imap,\r\ndaio_map_op, mgr);\r\nmgr->init_imap_added = 1;\r\n}\r\nspin_unlock_irqrestore(&mgr->imap_lock, flags);\r\nreturn err;\r\n}\r\nstatic int daio_mgr_commit_write(struct daio_mgr *mgr)\r\n{\r\nstruct hw *hw = mgr->mgr.hw;\r\nhw->daio_mgr_commit_write(hw, mgr->mgr.ctrl_blk);\r\nreturn 0;\r\n}\r\nint daio_mgr_create(void *hw, struct daio_mgr **rdaio_mgr)\r\n{\r\nint err, i;\r\nstruct daio_mgr *daio_mgr;\r\nstruct imapper *entry;\r\n*rdaio_mgr = NULL;\r\ndaio_mgr = kzalloc(sizeof(*daio_mgr), GFP_KERNEL);\r\nif (!daio_mgr)\r\nreturn -ENOMEM;\r\nerr = rsc_mgr_init(&daio_mgr->mgr, DAIO, NUM_DAIOTYP, hw);\r\nif (err)\r\ngoto error1;\r\nspin_lock_init(&daio_mgr->mgr_lock);\r\nspin_lock_init(&daio_mgr->imap_lock);\r\nINIT_LIST_HEAD(&daio_mgr->imappers);\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nerr = -ENOMEM;\r\ngoto error2;\r\n}\r\nentry->slot = entry->addr = entry->next = entry->user = 0;\r\nlist_add(&entry->list, &daio_mgr->imappers);\r\ndaio_mgr->init_imap = entry;\r\ndaio_mgr->init_imap_added = 1;\r\ndaio_mgr->get_daio = get_daio_rsc;\r\ndaio_mgr->put_daio = put_daio_rsc;\r\ndaio_mgr->daio_enable = daio_mgr_enb_daio;\r\ndaio_mgr->daio_disable = daio_mgr_dsb_daio;\r\ndaio_mgr->imap_add = daio_imap_add;\r\ndaio_mgr->imap_delete = daio_imap_delete;\r\ndaio_mgr->commit_write = daio_mgr_commit_write;\r\nfor (i = 0; i < 8; i++) {\r\n((struct hw *)hw)->daio_mgr_dsb_dao(daio_mgr->mgr.ctrl_blk, i);\r\n((struct hw *)hw)->daio_mgr_dsb_dai(daio_mgr->mgr.ctrl_blk, i);\r\n}\r\n((struct hw *)hw)->daio_mgr_commit_write(hw, daio_mgr->mgr.ctrl_blk);\r\n*rdaio_mgr = daio_mgr;\r\nreturn 0;\r\nerror2:\r\nrsc_mgr_uninit(&daio_mgr->mgr);\r\nerror1:\r\nkfree(daio_mgr);\r\nreturn err;\r\n}\r\nint daio_mgr_destroy(struct daio_mgr *daio_mgr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&daio_mgr->imap_lock, flags);\r\nfree_input_mapper_list(&daio_mgr->imappers);\r\nspin_unlock_irqrestore(&daio_mgr->imap_lock, flags);\r\nrsc_mgr_uninit(&daio_mgr->mgr);\r\nkfree(daio_mgr);\r\nreturn 0;\r\n}
