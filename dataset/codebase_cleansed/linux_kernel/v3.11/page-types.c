static unsigned long pages2mb(unsigned long pages)\r\n{\r\nreturn (pages * page_size) >> 20;\r\n}\r\nstatic void fatal(const char *x, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, x);\r\nvfprintf(stderr, x, ap);\r\nva_end(ap);\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic int checked_open(const char *pathname, int flags)\r\n{\r\nint fd = open(pathname, flags);\r\nif (fd < 0) {\r\nperror(pathname);\r\nexit(EXIT_FAILURE);\r\n}\r\nreturn fd;\r\n}\r\nstatic unsigned long do_u64_read(int fd, char *name,\r\nuint64_t *buf,\r\nunsigned long index,\r\nunsigned long count)\r\n{\r\nlong bytes;\r\nif (index > ULONG_MAX / 8)\r\nfatal("index overflow: %lu\n", index);\r\nif (lseek(fd, index * 8, SEEK_SET) < 0) {\r\nperror(name);\r\nexit(EXIT_FAILURE);\r\n}\r\nbytes = read(fd, buf, count * 8);\r\nif (bytes < 0) {\r\nperror(name);\r\nexit(EXIT_FAILURE);\r\n}\r\nif (bytes % 8)\r\nfatal("partial read: %lu bytes\n", bytes);\r\nreturn bytes / 8;\r\n}\r\nstatic unsigned long kpageflags_read(uint64_t *buf,\r\nunsigned long index,\r\nunsigned long pages)\r\n{\r\nreturn do_u64_read(kpageflags_fd, PROC_KPAGEFLAGS, buf, index, pages);\r\n}\r\nstatic unsigned long pagemap_read(uint64_t *buf,\r\nunsigned long index,\r\nunsigned long pages)\r\n{\r\nreturn do_u64_read(pagemap_fd, "/proc/pid/pagemap", buf, index, pages);\r\n}\r\nstatic unsigned long pagemap_pfn(uint64_t val)\r\n{\r\nunsigned long pfn;\r\nif (val & PM_PRESENT)\r\npfn = PM_PFRAME(val);\r\nelse\r\npfn = 0;\r\nreturn pfn;\r\n}\r\nstatic char *page_flag_name(uint64_t flags)\r\n{\r\nstatic char buf[65];\r\nint present;\r\nsize_t i, j;\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(page_flag_names); i++) {\r\npresent = (flags >> i) & 1;\r\nif (!page_flag_names[i]) {\r\nif (present)\r\nfatal("unknown flag bit %d\n", i);\r\ncontinue;\r\n}\r\nbuf[j++] = present ? page_flag_names[i][0] : '_';\r\n}\r\nreturn buf;\r\n}\r\nstatic char *page_flag_longname(uint64_t flags)\r\n{\r\nstatic char buf[1024];\r\nsize_t i, n;\r\nfor (i = 0, n = 0; i < ARRAY_SIZE(page_flag_names); i++) {\r\nif (!page_flag_names[i])\r\ncontinue;\r\nif ((flags >> i) & 1)\r\nn += snprintf(buf + n, sizeof(buf) - n, "%s,",\r\npage_flag_names[i] + 2);\r\n}\r\nif (n)\r\nn--;\r\nbuf[n] = '\0';\r\nreturn buf;\r\n}\r\nstatic void show_page_range(unsigned long voffset,\r\nunsigned long offset, uint64_t flags)\r\n{\r\nstatic uint64_t flags0;\r\nstatic unsigned long voff;\r\nstatic unsigned long index;\r\nstatic unsigned long count;\r\nif (flags == flags0 && offset == index + count &&\r\n(!opt_pid || voffset == voff + count)) {\r\ncount++;\r\nreturn;\r\n}\r\nif (count) {\r\nif (opt_pid)\r\nprintf("%lx\t", voff);\r\nprintf("%lx\t%lx\t%s\n",\r\nindex, count, page_flag_name(flags0));\r\n}\r\nflags0 = flags;\r\nindex = offset;\r\nvoff = voffset;\r\ncount = 1;\r\n}\r\nstatic void show_page(unsigned long voffset,\r\nunsigned long offset, uint64_t flags)\r\n{\r\nif (opt_pid)\r\nprintf("%lx\t", voffset);\r\nprintf("%lx\t%s\n", offset, page_flag_name(flags));\r\n}\r\nstatic void show_summary(void)\r\n{\r\nsize_t i;\r\nprintf(" flags\tpage-count MB"\r\n" symbolic-flags\t\t\tlong-symbolic-flags\n");\r\nfor (i = 0; i < ARRAY_SIZE(nr_pages); i++) {\r\nif (nr_pages[i])\r\nprintf("0x%016llx\t%10lu %8lu %s\t%s\n",\r\n(unsigned long long)page_flags[i],\r\nnr_pages[i],\r\npages2mb(nr_pages[i]),\r\npage_flag_name(page_flags[i]),\r\npage_flag_longname(page_flags[i]));\r\n}\r\nprintf(" total\t%10lu %8lu\n",\r\ntotal_pages, pages2mb(total_pages));\r\n}\r\nstatic int bit_mask_ok(uint64_t flags)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_bit_filters; i++) {\r\nif (opt_bits[i] == KPF_ALL_BITS) {\r\nif ((flags & opt_mask[i]) == 0)\r\nreturn 0;\r\n} else {\r\nif ((flags & opt_mask[i]) != opt_bits[i])\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic uint64_t expand_overloaded_flags(uint64_t flags)\r\n{\r\nif (flags & BIT(SLAB)) {\r\nif (flags & BIT(PRIVATE))\r\nflags ^= BIT(PRIVATE) | BIT(SLOB_FREE);\r\nif (flags & BIT(ACTIVE))\r\nflags ^= BIT(ACTIVE) | BIT(SLUB_FROZEN);\r\nif (flags & BIT(ERROR))\r\nflags ^= BIT(ERROR) | BIT(SLUB_DEBUG);\r\n}\r\nif ((flags & (BIT(RECLAIM) | BIT(WRITEBACK))) == BIT(RECLAIM))\r\nflags ^= BIT(RECLAIM) | BIT(READAHEAD);\r\nreturn flags;\r\n}\r\nstatic uint64_t well_known_flags(uint64_t flags)\r\n{\r\nflags &= ~KPF_HACKERS_BITS;\r\nif ((flags & BITS_COMPOUND) && !(flags & BIT(HUGE)))\r\nflags &= ~BITS_COMPOUND;\r\nreturn flags;\r\n}\r\nstatic uint64_t kpageflags_flags(uint64_t flags)\r\n{\r\nflags = expand_overloaded_flags(flags);\r\nif (!opt_raw)\r\nflags = well_known_flags(flags);\r\nreturn flags;\r\n}\r\nstatic void prepare_hwpoison_fd(void)\r\n{\r\nchar buf[MAX_PATH + 1];\r\nhwpoison_debug_fs = debugfs_mount(NULL);\r\nif (!hwpoison_debug_fs) {\r\nperror("mount debugfs");\r\nexit(EXIT_FAILURE);\r\n}\r\nif (opt_hwpoison && !hwpoison_inject_fd) {\r\nsnprintf(buf, MAX_PATH, "%s/hwpoison/corrupt-pfn",\r\nhwpoison_debug_fs);\r\nhwpoison_inject_fd = checked_open(buf, O_WRONLY);\r\n}\r\nif (opt_unpoison && !hwpoison_forget_fd) {\r\nsnprintf(buf, MAX_PATH, "%s/hwpoison/unpoison-pfn",\r\nhwpoison_debug_fs);\r\nhwpoison_forget_fd = checked_open(buf, O_WRONLY);\r\n}\r\n}\r\nstatic int hwpoison_page(unsigned long offset)\r\n{\r\nchar buf[100];\r\nint len;\r\nlen = sprintf(buf, "0x%lx\n", offset);\r\nlen = write(hwpoison_inject_fd, buf, len);\r\nif (len < 0) {\r\nperror("hwpoison inject");\r\nreturn len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int unpoison_page(unsigned long offset)\r\n{\r\nchar buf[100];\r\nint len;\r\nlen = sprintf(buf, "0x%lx\n", offset);\r\nlen = write(hwpoison_forget_fd, buf, len);\r\nif (len < 0) {\r\nperror("hwpoison forget");\r\nreturn len;\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t hash_slot(uint64_t flags)\r\n{\r\nsize_t k = HASH_KEY(flags);\r\nsize_t i;\r\nif (flags == 0)\r\nreturn 0;\r\nfor (i = 1; i < ARRAY_SIZE(page_flags); i++, k++) {\r\nif (!k || k >= ARRAY_SIZE(page_flags))\r\nk = 1;\r\nif (page_flags[k] == 0) {\r\npage_flags[k] = flags;\r\nreturn k;\r\n}\r\nif (page_flags[k] == flags)\r\nreturn k;\r\n}\r\nfatal("hash table full: bump up HASH_SHIFT?\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic void add_page(unsigned long voffset,\r\nunsigned long offset, uint64_t flags)\r\n{\r\nflags = kpageflags_flags(flags);\r\nif (!bit_mask_ok(flags))\r\nreturn;\r\nif (opt_hwpoison)\r\nhwpoison_page(offset);\r\nif (opt_unpoison)\r\nunpoison_page(offset);\r\nif (opt_list == 1)\r\nshow_page_range(voffset, offset, flags);\r\nelse if (opt_list == 2)\r\nshow_page(voffset, offset, flags);\r\nnr_pages[hash_slot(flags)]++;\r\ntotal_pages++;\r\n}\r\nstatic void walk_pfn(unsigned long voffset,\r\nunsigned long index,\r\nunsigned long count)\r\n{\r\nuint64_t buf[KPAGEFLAGS_BATCH];\r\nunsigned long batch;\r\nunsigned long pages;\r\nunsigned long i;\r\nwhile (count) {\r\nbatch = min_t(unsigned long, count, KPAGEFLAGS_BATCH);\r\npages = kpageflags_read(buf, index, batch);\r\nif (pages == 0)\r\nbreak;\r\nfor (i = 0; i < pages; i++)\r\nadd_page(voffset + i, index + i, buf[i]);\r\nindex += pages;\r\ncount -= pages;\r\n}\r\n}\r\nstatic void walk_vma(unsigned long index, unsigned long count)\r\n{\r\nuint64_t buf[PAGEMAP_BATCH];\r\nunsigned long batch;\r\nunsigned long pages;\r\nunsigned long pfn;\r\nunsigned long i;\r\nwhile (count) {\r\nbatch = min_t(unsigned long, count, PAGEMAP_BATCH);\r\npages = pagemap_read(buf, index, batch);\r\nif (pages == 0)\r\nbreak;\r\nfor (i = 0; i < pages; i++) {\r\npfn = pagemap_pfn(buf[i]);\r\nif (pfn)\r\nwalk_pfn(index + i, pfn, 1);\r\n}\r\nindex += pages;\r\ncount -= pages;\r\n}\r\n}\r\nstatic void walk_task(unsigned long index, unsigned long count)\r\n{\r\nconst unsigned long end = index + count;\r\nunsigned long start;\r\nint i = 0;\r\nwhile (index < end) {\r\nwhile (pg_end[i] <= index)\r\nif (++i >= nr_vmas)\r\nreturn;\r\nif (pg_start[i] >= end)\r\nreturn;\r\nstart = max_t(unsigned long, pg_start[i], index);\r\nindex = min_t(unsigned long, pg_end[i], end);\r\nassert(start < index);\r\nwalk_vma(start, index - start);\r\n}\r\n}\r\nstatic void add_addr_range(unsigned long offset, unsigned long size)\r\n{\r\nif (nr_addr_ranges >= MAX_ADDR_RANGES)\r\nfatal("too many addr ranges\n");\r\nopt_offset[nr_addr_ranges] = offset;\r\nopt_size[nr_addr_ranges] = min_t(unsigned long, size, ULONG_MAX-offset);\r\nnr_addr_ranges++;\r\n}\r\nstatic void walk_addr_ranges(void)\r\n{\r\nint i;\r\nkpageflags_fd = checked_open(PROC_KPAGEFLAGS, O_RDONLY);\r\nif (!nr_addr_ranges)\r\nadd_addr_range(0, ULONG_MAX);\r\nfor (i = 0; i < nr_addr_ranges; i++)\r\nif (!opt_pid)\r\nwalk_pfn(0, opt_offset[i], opt_size[i]);\r\nelse\r\nwalk_task(opt_offset[i], opt_size[i]);\r\nclose(kpageflags_fd);\r\n}\r\nstatic const char *page_flag_type(uint64_t flag)\r\n{\r\nif (flag & KPF_HACKERS_BITS)\r\nreturn "(r)";\r\nif (flag & KPF_OVERLOADED_BITS)\r\nreturn "(o)";\r\nreturn " ";\r\n}\r\nstatic void usage(void)\r\n{\r\nsize_t i, j;\r\nprintf(\r\n"page-types [options]\n"\r\n" -r|--raw Raw mode, for kernel developers\n"\r\n" -d|--describe flags Describe flags\n"\r\n" -a|--addr addr-spec Walk a range of pages\n"\r\n" -b|--bits bits-spec Walk pages with specified bits\n"\r\n" -p|--pid pid Walk process address space\n"\r\n#if 0\r\n" -f|--file filename Walk file address space\n"\r\n#endif\r\n" -l|--list Show page details in ranges\n"\r\n" -L|--list-each Show page details one by one\n"\r\n" -N|--no-summary Don't show summary info\n"\r\n" -X|--hwpoison hwpoison pages\n"\r\n" -x|--unpoison unpoison pages\n"\r\n" -h|--help Show this usage message\n"\r\n"flags:\n"\r\n" 0x10 bitfield format, e.g.\n"\r\n" anon bit-name, e.g.\n"\r\n" 0x10,anon comma-separated list, e.g.\n"\r\n"addr-spec:\n"\r\n" N one page at offset N (unit: pages)\n"\r\n" N+M pages range from N to N+M-1\n"\r\n" N,M pages range from N to M-1\n"\r\n" N, pages range from N to end\n"\r\n" ,M pages range from 0 to M-1\n"\r\n"bits-spec:\n"\r\n" bit1,bit2 (flags & (bit1|bit2)) != 0\n"\r\n" bit1,bit2=bit1 (flags & (bit1|bit2)) == bit1\n"\r\n" bit1,~bit2 (flags & (bit1|bit2)) == bit1\n"\r\n" =bit1,bit2 flags == (bit1|bit2)\n"\r\n"bit-names:\n"\r\n);\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(page_flag_names); i++) {\r\nif (!page_flag_names[i])\r\ncontinue;\r\nprintf("%16s%s", page_flag_names[i] + 2,\r\npage_flag_type(1ULL << i));\r\nif (++j > 3) {\r\nj = 0;\r\nputchar('\n');\r\n}\r\n}\r\nprintf("\n "\r\n"(r) raw mode bits (o) overloaded bits\n");\r\n}\r\nstatic unsigned long long parse_number(const char *str)\r\n{\r\nunsigned long long n;\r\nn = strtoll(str, NULL, 0);\r\nif (n == 0 && str[0] != '0')\r\nfatal("invalid name or number: %s\n", str);\r\nreturn n;\r\n}\r\nstatic void parse_pid(const char *str)\r\n{\r\nFILE *file;\r\nchar buf[5000];\r\nopt_pid = parse_number(str);\r\nsprintf(buf, "/proc/%d/pagemap", opt_pid);\r\npagemap_fd = checked_open(buf, O_RDONLY);\r\nsprintf(buf, "/proc/%d/maps", opt_pid);\r\nfile = fopen(buf, "r");\r\nif (!file) {\r\nperror(buf);\r\nexit(EXIT_FAILURE);\r\n}\r\nwhile (fgets(buf, sizeof(buf), file) != NULL) {\r\nunsigned long vm_start;\r\nunsigned long vm_end;\r\nunsigned long long pgoff;\r\nint major, minor;\r\nchar r, w, x, s;\r\nunsigned long ino;\r\nint n;\r\nn = sscanf(buf, "%lx-%lx %c%c%c%c %llx %x:%x %lu",\r\n&vm_start,\r\n&vm_end,\r\n&r, &w, &x, &s,\r\n&pgoff,\r\n&major, &minor,\r\n&ino);\r\nif (n < 10) {\r\nfprintf(stderr, "unexpected line: %s\n", buf);\r\ncontinue;\r\n}\r\npg_start[nr_vmas] = vm_start / page_size;\r\npg_end[nr_vmas] = vm_end / page_size;\r\nif (++nr_vmas >= MAX_VMAS) {\r\nfprintf(stderr, "too many VMAs\n");\r\nbreak;\r\n}\r\n}\r\nfclose(file);\r\n}\r\nstatic void parse_file(const char *name)\r\n{\r\n}\r\nstatic void parse_addr_range(const char *optarg)\r\n{\r\nunsigned long offset;\r\nunsigned long size;\r\nchar *p;\r\np = strchr(optarg, ',');\r\nif (!p)\r\np = strchr(optarg, '+');\r\nif (p == optarg) {\r\noffset = 0;\r\nsize = parse_number(p + 1);\r\n} else if (p) {\r\noffset = parse_number(optarg);\r\nif (p[1] == '\0')\r\nsize = ULONG_MAX;\r\nelse {\r\nsize = parse_number(p + 1);\r\nif (*p == ',') {\r\nif (size < offset)\r\nfatal("invalid range: %lu,%lu\n",\r\noffset, size);\r\nsize -= offset;\r\n}\r\n}\r\n} else {\r\noffset = parse_number(optarg);\r\nsize = 1;\r\n}\r\nadd_addr_range(offset, size);\r\n}\r\nstatic void add_bits_filter(uint64_t mask, uint64_t bits)\r\n{\r\nif (nr_bit_filters >= MAX_BIT_FILTERS)\r\nfatal("too much bit filters\n");\r\nopt_mask[nr_bit_filters] = mask;\r\nopt_bits[nr_bit_filters] = bits;\r\nnr_bit_filters++;\r\n}\r\nstatic uint64_t parse_flag_name(const char *str, int len)\r\n{\r\nsize_t i;\r\nif (!*str || !len)\r\nreturn 0;\r\nif (len <= 8 && !strncmp(str, "compound", len))\r\nreturn BITS_COMPOUND;\r\nfor (i = 0; i < ARRAY_SIZE(page_flag_names); i++) {\r\nif (!page_flag_names[i])\r\ncontinue;\r\nif (!strncmp(str, page_flag_names[i] + 2, len))\r\nreturn 1ULL << i;\r\n}\r\nreturn parse_number(str);\r\n}\r\nstatic uint64_t parse_flag_names(const char *str, int all)\r\n{\r\nconst char *p = str;\r\nuint64_t flags = 0;\r\nwhile (1) {\r\nif (*p == ',' || *p == '=' || *p == '\0') {\r\nif ((*str != '~') || (*str == '~' && all && *++str))\r\nflags |= parse_flag_name(str, p - str);\r\nif (*p != ',')\r\nbreak;\r\nstr = p + 1;\r\n}\r\np++;\r\n}\r\nreturn flags;\r\n}\r\nstatic void parse_bits_mask(const char *optarg)\r\n{\r\nuint64_t mask;\r\nuint64_t bits;\r\nconst char *p;\r\np = strchr(optarg, '=');\r\nif (p == optarg) {\r\nmask = KPF_ALL_BITS;\r\nbits = parse_flag_names(p + 1, 0);\r\n} else if (p) {\r\nmask = parse_flag_names(optarg, 0);\r\nbits = parse_flag_names(p + 1, 0);\r\n} else if (strchr(optarg, '~')) {\r\nmask = parse_flag_names(optarg, 1);\r\nbits = parse_flag_names(optarg, 0);\r\n} else {\r\nmask = parse_flag_names(optarg, 0);\r\nbits = KPF_ALL_BITS;\r\n}\r\nadd_bits_filter(mask, bits);\r\n}\r\nstatic void describe_flags(const char *optarg)\r\n{\r\nuint64_t flags = parse_flag_names(optarg, 0);\r\nprintf("0x%016llx\t%s\t%s\n",\r\n(unsigned long long)flags,\r\npage_flag_name(flags),\r\npage_flag_longname(flags));\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint c;\r\npage_size = getpagesize();\r\nwhile ((c = getopt_long(argc, argv,\r\n"rp:f:a:b:d:lLNXxh", opts, NULL)) != -1) {\r\nswitch (c) {\r\ncase 'r':\r\nopt_raw = 1;\r\nbreak;\r\ncase 'p':\r\nparse_pid(optarg);\r\nbreak;\r\ncase 'f':\r\nparse_file(optarg);\r\nbreak;\r\ncase 'a':\r\nparse_addr_range(optarg);\r\nbreak;\r\ncase 'b':\r\nparse_bits_mask(optarg);\r\nbreak;\r\ncase 'd':\r\ndescribe_flags(optarg);\r\nexit(0);\r\ncase 'l':\r\nopt_list = 1;\r\nbreak;\r\ncase 'L':\r\nopt_list = 2;\r\nbreak;\r\ncase 'N':\r\nopt_no_summary = 1;\r\nbreak;\r\ncase 'X':\r\nopt_hwpoison = 1;\r\nprepare_hwpoison_fd();\r\nbreak;\r\ncase 'x':\r\nopt_unpoison = 1;\r\nprepare_hwpoison_fd();\r\nbreak;\r\ncase 'h':\r\nusage();\r\nexit(0);\r\ndefault:\r\nusage();\r\nexit(1);\r\n}\r\n}\r\nif (opt_list && opt_pid)\r\nprintf("voffset\t");\r\nif (opt_list == 1)\r\nprintf("offset\tlen\tflags\n");\r\nif (opt_list == 2)\r\nprintf("offset\tflags\n");\r\nwalk_addr_ranges();\r\nif (opt_list == 1)\r\nshow_page_range(0, 0, 0);\r\nif (opt_no_summary)\r\nreturn 0;\r\nif (opt_list)\r\nprintf("\n\n");\r\nshow_summary();\r\nreturn 0;\r\n}
