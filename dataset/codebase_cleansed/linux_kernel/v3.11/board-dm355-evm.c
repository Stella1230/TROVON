static void dm355evm_mmcsd_gpios(unsigned gpio)\r\n{\r\ngpio_request(gpio + 0, "mmc0_ro");\r\ngpio_request(gpio + 1, "mmc0_cd");\r\ngpio_request(gpio + 2, "mmc1_ro");\r\ngpio_request(gpio + 3, "mmc1_cd");\r\ndm355evm_mmc_gpios = gpio;\r\n}\r\nstatic void __init evm_init_i2c(void)\r\n{\r\ndavinci_init_i2c(&i2c_pdata);\r\ngpio_request(5, "dm355evm_msp");\r\ngpio_direction_input(5);\r\ndm355evm_i2c_info[0].irq = gpio_to_irq(5);\r\ni2c_register_board_info(1, dm355evm_i2c_info,\r\nARRAY_SIZE(dm355evm_i2c_info));\r\n}\r\nstatic void __init dm355_evm_map_io(void)\r\n{\r\ndm355_init();\r\n}\r\nstatic int dm355evm_mmc_get_cd(int module)\r\n{\r\nif (!gpio_is_valid(dm355evm_mmc_gpios))\r\nreturn -ENXIO;\r\nreturn !gpio_get_value_cansleep(dm355evm_mmc_gpios + 2 * module + 1);\r\n}\r\nstatic int dm355evm_mmc_get_ro(int module)\r\n{\r\nif (!gpio_is_valid(dm355evm_mmc_gpios))\r\nreturn -ENXIO;\r\nreturn gpio_get_value_cansleep(dm355evm_mmc_gpios + 2 * module + 0);\r\n}\r\nstatic __init void dm355_evm_init(void)\r\n{\r\nstruct clk *aemif;\r\ngpio_request(1, "dm9000");\r\ngpio_direction_input(1);\r\ndm355evm_dm9000_rsrc[2].start = gpio_to_irq(1);\r\naemif = clk_get(&dm355evm_dm9000.dev, "aemif");\r\nif (IS_ERR(aemif))\r\nWARN("%s: unable to get AEMIF clock\n", __func__);\r\nelse\r\nclk_prepare_enable(aemif);\r\nplatform_add_devices(davinci_evm_devices,\r\nARRAY_SIZE(davinci_evm_devices));\r\nevm_init_i2c();\r\ndavinci_serial_init(&uart_config);\r\ngpio_request(2, "usb_id_toggle");\r\ngpio_direction_output(2, USB_ID_VALUE);\r\ndavinci_setup_usb(1000, 8);\r\ndavinci_setup_mmc(0, &dm355evm_mmc_config);\r\ndavinci_setup_mmc(1, &dm355evm_mmc_config);\r\ndm355_init_video(&vpfe_cfg, &dm355evm_display_cfg);\r\ndm355_init_spi0(BIT(0), dm355_evm_spi_info,\r\nARRAY_SIZE(dm355_evm_spi_info));\r\ndm355_init_asp1(ASP1_TX_EVT_EN | ASP1_RX_EVT_EN, &dm355_evm_snd_data);\r\n}
