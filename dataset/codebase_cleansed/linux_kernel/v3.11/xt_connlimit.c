static inline unsigned int connlimit_iphash(__be32 addr)\r\n{\r\nreturn jhash_1word((__force __u32)addr, connlimit_rnd) & 0xFF;\r\n}\r\nstatic inline unsigned int\r\nconnlimit_iphash6(const union nf_inet_addr *addr,\r\nconst union nf_inet_addr *mask)\r\n{\r\nunion nf_inet_addr res;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(addr->ip6); ++i)\r\nres.ip6[i] = addr->ip6[i] & mask->ip6[i];\r\nreturn jhash2((u32 *)res.ip6, ARRAY_SIZE(res.ip6), connlimit_rnd) & 0xFF;\r\n}\r\nstatic inline bool already_closed(const struct nf_conn *conn)\r\n{\r\nif (nf_ct_protonum(conn) == IPPROTO_TCP)\r\nreturn conn->proto.tcp.state == TCP_CONNTRACK_TIME_WAIT ||\r\nconn->proto.tcp.state == TCP_CONNTRACK_CLOSE;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline unsigned int\r\nsame_source_net(const union nf_inet_addr *addr,\r\nconst union nf_inet_addr *mask,\r\nconst union nf_inet_addr *u3, u_int8_t family)\r\n{\r\nif (family == NFPROTO_IPV4) {\r\nreturn (addr->ip & mask->ip) == (u3->ip & mask->ip);\r\n} else {\r\nunion nf_inet_addr lh, rh;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(addr->ip6); ++i) {\r\nlh.ip6[i] = addr->ip6[i] & mask->ip6[i];\r\nrh.ip6[i] = u3->ip6[i] & mask->ip6[i];\r\n}\r\nreturn memcmp(&lh.ip6, &rh.ip6, sizeof(lh.ip6)) == 0;\r\n}\r\n}\r\nstatic int count_them(struct net *net,\r\nstruct xt_connlimit_data *data,\r\nconst struct nf_conntrack_tuple *tuple,\r\nconst union nf_inet_addr *addr,\r\nconst union nf_inet_addr *mask,\r\nu_int8_t family)\r\n{\r\nconst struct nf_conntrack_tuple_hash *found;\r\nstruct xt_connlimit_conn *conn;\r\nstruct hlist_node *n;\r\nstruct nf_conn *found_ct;\r\nstruct hlist_head *hash;\r\nbool addit = true;\r\nint matches = 0;\r\nif (family == NFPROTO_IPV6)\r\nhash = &data->iphash[connlimit_iphash6(addr, mask)];\r\nelse\r\nhash = &data->iphash[connlimit_iphash(addr->ip & mask->ip)];\r\nrcu_read_lock();\r\nhlist_for_each_entry_safe(conn, n, hash, node) {\r\nfound = nf_conntrack_find_get(net, NF_CT_DEFAULT_ZONE,\r\n&conn->tuple);\r\nfound_ct = NULL;\r\nif (found != NULL)\r\nfound_ct = nf_ct_tuplehash_to_ctrack(found);\r\nif (found_ct != NULL &&\r\nnf_ct_tuple_equal(&conn->tuple, tuple) &&\r\n!already_closed(found_ct))\r\naddit = false;\r\nif (found == NULL) {\r\nhlist_del(&conn->node);\r\nkfree(conn);\r\ncontinue;\r\n}\r\nif (already_closed(found_ct)) {\r\nnf_ct_put(found_ct);\r\nhlist_del(&conn->node);\r\nkfree(conn);\r\ncontinue;\r\n}\r\nif (same_source_net(addr, mask, &conn->addr, family))\r\n++matches;\r\nnf_ct_put(found_ct);\r\n}\r\nrcu_read_unlock();\r\nif (addit) {\r\nconn = kmalloc(sizeof(*conn), GFP_ATOMIC);\r\nif (conn == NULL)\r\nreturn -ENOMEM;\r\nconn->tuple = *tuple;\r\nconn->addr = *addr;\r\nhlist_add_head(&conn->node, hash);\r\n++matches;\r\n}\r\nreturn matches;\r\n}\r\nstatic bool\r\nconnlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct net *net = dev_net(par->in ? par->in : par->out);\r\nconst struct xt_connlimit_info *info = par->matchinfo;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_tuple tuple;\r\nconst struct nf_conntrack_tuple *tuple_ptr = &tuple;\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn *ct;\r\nint connections;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct != NULL)\r\ntuple_ptr = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nelse if (!nf_ct_get_tuplepr(skb, skb_network_offset(skb),\r\npar->family, &tuple))\r\ngoto hotdrop;\r\nif (par->family == NFPROTO_IPV6) {\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nmemcpy(&addr.ip6, (info->flags & XT_CONNLIMIT_DADDR) ?\r\n&iph->daddr : &iph->saddr, sizeof(addr.ip6));\r\n} else {\r\nconst struct iphdr *iph = ip_hdr(skb);\r\naddr.ip = (info->flags & XT_CONNLIMIT_DADDR) ?\r\niph->daddr : iph->saddr;\r\n}\r\nspin_lock_bh(&info->data->lock);\r\nconnections = count_them(net, info->data, tuple_ptr, &addr,\r\n&info->mask, par->family);\r\nspin_unlock_bh(&info->data->lock);\r\nif (connections < 0)\r\ngoto hotdrop;\r\nreturn (connections > info->limit) ^\r\n!!(info->flags & XT_CONNLIMIT_INVERT);\r\nhotdrop:\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nstatic int connlimit_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nstruct xt_connlimit_info *info = par->matchinfo;\r\nunsigned int i;\r\nint ret;\r\nif (unlikely(!connlimit_rnd)) {\r\nu_int32_t rand;\r\ndo {\r\nget_random_bytes(&rand, sizeof(rand));\r\n} while (!rand);\r\ncmpxchg(&connlimit_rnd, 0, rand);\r\n}\r\nret = nf_ct_l3proto_try_module_get(par->family);\r\nif (ret < 0) {\r\npr_info("cannot load conntrack support for "\r\n"address family %u\n", par->family);\r\nreturn ret;\r\n}\r\ninfo->data = kmalloc(sizeof(struct xt_connlimit_data), GFP_KERNEL);\r\nif (info->data == NULL) {\r\nnf_ct_l3proto_module_put(par->family);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&info->data->lock);\r\nfor (i = 0; i < ARRAY_SIZE(info->data->iphash); ++i)\r\nINIT_HLIST_HEAD(&info->data->iphash[i]);\r\nreturn 0;\r\n}\r\nstatic void connlimit_mt_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nconst struct xt_connlimit_info *info = par->matchinfo;\r\nstruct xt_connlimit_conn *conn;\r\nstruct hlist_node *n;\r\nstruct hlist_head *hash = info->data->iphash;\r\nunsigned int i;\r\nnf_ct_l3proto_module_put(par->family);\r\nfor (i = 0; i < ARRAY_SIZE(info->data->iphash); ++i) {\r\nhlist_for_each_entry_safe(conn, n, &hash[i], node) {\r\nhlist_del(&conn->node);\r\nkfree(conn);\r\n}\r\n}\r\nkfree(info->data);\r\n}\r\nstatic int __init connlimit_mt_init(void)\r\n{\r\nreturn xt_register_match(&connlimit_mt_reg);\r\n}\r\nstatic void __exit connlimit_mt_exit(void)\r\n{\r\nxt_unregister_match(&connlimit_mt_reg);\r\n}
