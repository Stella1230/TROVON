static int adc081c_read_raw(struct iio_dev *iio,\r\nstruct iio_chan_spec const *channel, int *value,\r\nint *shift, long mask)\r\n{\r\nstruct adc081c *adc = iio_priv(iio);\r\nint err;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nerr = i2c_smbus_read_word_swapped(adc->i2c, REG_CONV_RES);\r\nif (err < 0)\r\nreturn err;\r\n*value = (err >> 4) & 0xff;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nerr = regulator_get_voltage(adc->ref);\r\nif (err < 0)\r\nreturn err;\r\n*value = err / 1000;\r\n*shift = 8;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int adc081c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *iio;\r\nstruct adc081c *adc;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\niio = iio_device_alloc(sizeof(*adc));\r\nif (!iio)\r\nreturn -ENOMEM;\r\nadc = iio_priv(iio);\r\nadc->i2c = client;\r\nadc->ref = regulator_get(&client->dev, "vref");\r\nif (IS_ERR(adc->ref)) {\r\nerr = PTR_ERR(adc->ref);\r\ngoto iio_free;\r\n}\r\nerr = regulator_enable(adc->ref);\r\nif (err < 0)\r\ngoto regulator_put;\r\niio->dev.parent = &client->dev;\r\niio->name = dev_name(&client->dev);\r\niio->modes = INDIO_DIRECT_MODE;\r\niio->info = &adc081c_info;\r\niio->channels = &adc081c_channel;\r\niio->num_channels = 1;\r\nerr = iio_device_register(iio);\r\nif (err < 0)\r\ngoto regulator_disable;\r\ni2c_set_clientdata(client, iio);\r\nreturn 0;\r\nregulator_disable:\r\nregulator_disable(adc->ref);\r\nregulator_put:\r\nregulator_put(adc->ref);\r\niio_free:\r\niio_device_free(iio);\r\nreturn err;\r\n}\r\nstatic int adc081c_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *iio = i2c_get_clientdata(client);\r\nstruct adc081c *adc = iio_priv(iio);\r\niio_device_unregister(iio);\r\nregulator_disable(adc->ref);\r\nregulator_put(adc->ref);\r\niio_device_free(iio);\r\nreturn 0;\r\n}
