static __s32 uvc_ctrl_get_zoom(struct uvc_control_mapping *mapping,\r\n__u8 query, const __u8 *data)\r\n{\r\n__s8 zoom = (__s8)data[0];\r\nswitch (query) {\r\ncase UVC_GET_CUR:\r\nreturn (zoom == 0) ? 0 : (zoom > 0 ? data[2] : -data[2]);\r\ncase UVC_GET_MIN:\r\ncase UVC_GET_MAX:\r\ncase UVC_GET_RES:\r\ncase UVC_GET_DEF:\r\ndefault:\r\nreturn data[2];\r\n}\r\n}\r\nstatic void uvc_ctrl_set_zoom(struct uvc_control_mapping *mapping,\r\n__s32 value, __u8 *data)\r\n{\r\ndata[0] = value == 0 ? 0 : (value > 0) ? 1 : 0xff;\r\ndata[2] = min((int)abs(value), 0xff);\r\n}\r\nstatic inline __u8 *uvc_ctrl_data(struct uvc_control *ctrl, int id)\r\n{\r\nreturn ctrl->uvc_data + id * ctrl->info.size;\r\n}\r\nstatic inline int uvc_test_bit(const __u8 *data, int bit)\r\n{\r\nreturn (data[bit >> 3] >> (bit & 7)) & 1;\r\n}\r\nstatic inline void uvc_clear_bit(__u8 *data, int bit)\r\n{\r\ndata[bit >> 3] &= ~(1 << (bit & 7));\r\n}\r\nstatic __s32 uvc_get_le_value(struct uvc_control_mapping *mapping,\r\n__u8 query, const __u8 *data)\r\n{\r\nint bits = mapping->size;\r\nint offset = mapping->offset;\r\n__s32 value = 0;\r\n__u8 mask;\r\ndata += offset / 8;\r\noffset &= 7;\r\nmask = ((1LL << bits) - 1) << offset;\r\nfor (; bits > 0; data++) {\r\n__u8 byte = *data & mask;\r\nvalue |= offset > 0 ? (byte >> offset) : (byte << (-offset));\r\nbits -= 8 - (offset > 0 ? offset : 0);\r\noffset -= 8;\r\nmask = (1 << bits) - 1;\r\n}\r\nif (mapping->data_type == UVC_CTRL_DATA_TYPE_SIGNED)\r\nvalue |= -(value & (1 << (mapping->size - 1)));\r\nreturn value;\r\n}\r\nstatic void uvc_set_le_value(struct uvc_control_mapping *mapping,\r\n__s32 value, __u8 *data)\r\n{\r\nint bits = mapping->size;\r\nint offset = mapping->offset;\r\n__u8 mask;\r\nif (mapping->v4l2_type == V4L2_CTRL_TYPE_BUTTON)\r\nvalue = -1;\r\ndata += offset / 8;\r\noffset &= 7;\r\nfor (; bits > 0; data++) {\r\nmask = ((1LL << bits) - 1) << offset;\r\n*data = (*data & ~mask) | ((value << offset) & mask);\r\nvalue >>= offset ? offset : 8;\r\nbits -= 8 - offset;\r\noffset = 0;\r\n}\r\n}\r\nstatic int uvc_entity_match_guid(const struct uvc_entity *entity,\r\nconst __u8 guid[16])\r\n{\r\nswitch (UVC_ENTITY_TYPE(entity)) {\r\ncase UVC_ITT_CAMERA:\r\nreturn memcmp(uvc_camera_guid, guid, 16) == 0;\r\ncase UVC_ITT_MEDIA_TRANSPORT_INPUT:\r\nreturn memcmp(uvc_media_transport_input_guid, guid, 16) == 0;\r\ncase UVC_VC_PROCESSING_UNIT:\r\nreturn memcmp(uvc_processing_guid, guid, 16) == 0;\r\ncase UVC_VC_EXTENSION_UNIT:\r\nreturn memcmp(entity->extension.guidExtensionCode,\r\nguid, 16) == 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void __uvc_find_control(struct uvc_entity *entity, __u32 v4l2_id,\r\nstruct uvc_control_mapping **mapping, struct uvc_control **control,\r\nint next)\r\n{\r\nstruct uvc_control *ctrl;\r\nstruct uvc_control_mapping *map;\r\nunsigned int i;\r\nif (entity == NULL)\r\nreturn;\r\nfor (i = 0; i < entity->ncontrols; ++i) {\r\nctrl = &entity->controls[i];\r\nif (!ctrl->initialized)\r\ncontinue;\r\nlist_for_each_entry(map, &ctrl->info.mappings, list) {\r\nif ((map->id == v4l2_id) && !next) {\r\n*control = ctrl;\r\n*mapping = map;\r\nreturn;\r\n}\r\nif ((*mapping == NULL || (*mapping)->id > map->id) &&\r\n(map->id > v4l2_id) && next) {\r\n*control = ctrl;\r\n*mapping = map;\r\n}\r\n}\r\n}\r\n}\r\nstatic struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,\r\n__u32 v4l2_id, struct uvc_control_mapping **mapping)\r\n{\r\nstruct uvc_control *ctrl = NULL;\r\nstruct uvc_entity *entity;\r\nint next = v4l2_id & V4L2_CTRL_FLAG_NEXT_CTRL;\r\n*mapping = NULL;\r\nv4l2_id &= V4L2_CTRL_ID_MASK;\r\nlist_for_each_entry(entity, &chain->entities, chain) {\r\n__uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);\r\nif (ctrl && !next)\r\nreturn ctrl;\r\n}\r\nif (ctrl == NULL && !next)\r\nuvc_trace(UVC_TRACE_CONTROL, "Control 0x%08x not found.\n",\r\nv4l2_id);\r\nreturn ctrl;\r\n}\r\nstatic int uvc_ctrl_populate_cache(struct uvc_video_chain *chain,\r\nstruct uvc_control *ctrl)\r\n{\r\nint ret;\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_GET_DEF) {\r\nret = uvc_query_ctrl(chain->dev, UVC_GET_DEF, ctrl->entity->id,\r\nchain->dev->intfnum, ctrl->info.selector,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_DEF),\r\nctrl->info.size);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MIN) {\r\nret = uvc_query_ctrl(chain->dev, UVC_GET_MIN, ctrl->entity->id,\r\nchain->dev->intfnum, ctrl->info.selector,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN),\r\nctrl->info.size);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MAX) {\r\nret = uvc_query_ctrl(chain->dev, UVC_GET_MAX, ctrl->entity->id,\r\nchain->dev->intfnum, ctrl->info.selector,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX),\r\nctrl->info.size);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_GET_RES) {\r\nret = uvc_query_ctrl(chain->dev, UVC_GET_RES, ctrl->entity->id,\r\nchain->dev->intfnum, ctrl->info.selector,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES),\r\nctrl->info.size);\r\nif (ret < 0) {\r\nif (UVC_ENTITY_TYPE(ctrl->entity) !=\r\nUVC_VC_EXTENSION_UNIT)\r\nreturn ret;\r\nuvc_warn_once(chain->dev, UVC_WARN_XU_GET_RES,\r\n"UVC non compliance - GET_RES failed on "\r\n"an XU control. Enabling workaround.\n");\r\nmemset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES), 0,\r\nctrl->info.size);\r\n}\r\n}\r\nctrl->cached = 1;\r\nreturn 0;\r\n}\r\nstatic int __uvc_ctrl_get(struct uvc_video_chain *chain,\r\nstruct uvc_control *ctrl, struct uvc_control_mapping *mapping,\r\ns32 *value)\r\n{\r\nstruct uvc_menu_info *menu;\r\nunsigned int i;\r\nint ret;\r\nif ((ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR) == 0)\r\nreturn -EACCES;\r\nif (!ctrl->loaded) {\r\nret = uvc_query_ctrl(chain->dev, UVC_GET_CUR, ctrl->entity->id,\r\nchain->dev->intfnum, ctrl->info.selector,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\r\nctrl->info.size);\r\nif (ret < 0)\r\nreturn ret;\r\nctrl->loaded = 1;\r\n}\r\n*value = mapping->get(mapping, UVC_GET_CUR,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT));\r\nif (mapping->v4l2_type == V4L2_CTRL_TYPE_MENU) {\r\nmenu = mapping->menu_info;\r\nfor (i = 0; i < mapping->menu_count; ++i, ++menu) {\r\nif (menu->value == *value) {\r\n*value = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,\r\nstruct uvc_control *ctrl,\r\nstruct uvc_control_mapping *mapping,\r\nstruct v4l2_queryctrl *v4l2_ctrl)\r\n{\r\nstruct uvc_control_mapping *master_map = NULL;\r\nstruct uvc_control *master_ctrl = NULL;\r\nstruct uvc_menu_info *menu;\r\nunsigned int i;\r\nmemset(v4l2_ctrl, 0, sizeof *v4l2_ctrl);\r\nv4l2_ctrl->id = mapping->id;\r\nv4l2_ctrl->type = mapping->v4l2_type;\r\nstrlcpy(v4l2_ctrl->name, mapping->name, sizeof v4l2_ctrl->name);\r\nv4l2_ctrl->flags = 0;\r\nif (!(ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR))\r\nv4l2_ctrl->flags |= V4L2_CTRL_FLAG_WRITE_ONLY;\r\nif (!(ctrl->info.flags & UVC_CTRL_FLAG_SET_CUR))\r\nv4l2_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;\r\nif (mapping->master_id)\r\n__uvc_find_control(ctrl->entity, mapping->master_id,\r\n&master_map, &master_ctrl, 0);\r\nif (master_ctrl && (master_ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR)) {\r\ns32 val;\r\nint ret = __uvc_ctrl_get(chain, master_ctrl, master_map, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val != mapping->master_manual)\r\nv4l2_ctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;\r\n}\r\nif (!ctrl->cached) {\r\nint ret = uvc_ctrl_populate_cache(chain, ctrl);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_GET_DEF) {\r\nv4l2_ctrl->default_value = mapping->get(mapping, UVC_GET_DEF,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_DEF));\r\n}\r\nswitch (mapping->v4l2_type) {\r\ncase V4L2_CTRL_TYPE_MENU:\r\nv4l2_ctrl->minimum = 0;\r\nv4l2_ctrl->maximum = mapping->menu_count - 1;\r\nv4l2_ctrl->step = 1;\r\nmenu = mapping->menu_info;\r\nfor (i = 0; i < mapping->menu_count; ++i, ++menu) {\r\nif (menu->value == v4l2_ctrl->default_value) {\r\nv4l2_ctrl->default_value = i;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\nv4l2_ctrl->minimum = 0;\r\nv4l2_ctrl->maximum = 1;\r\nv4l2_ctrl->step = 1;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\nv4l2_ctrl->minimum = 0;\r\nv4l2_ctrl->maximum = 0;\r\nv4l2_ctrl->step = 0;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MIN)\r\nv4l2_ctrl->minimum = mapping->get(mapping, UVC_GET_MIN,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN));\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_GET_MAX)\r\nv4l2_ctrl->maximum = mapping->get(mapping, UVC_GET_MAX,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX));\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_GET_RES)\r\nv4l2_ctrl->step = mapping->get(mapping, UVC_GET_RES,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));\r\nreturn 0;\r\n}\r\nint uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,\r\nstruct v4l2_queryctrl *v4l2_ctrl)\r\n{\r\nstruct uvc_control *ctrl;\r\nstruct uvc_control_mapping *mapping;\r\nint ret;\r\nret = mutex_lock_interruptible(&chain->ctrl_mutex);\r\nif (ret < 0)\r\nreturn -ERESTARTSYS;\r\nctrl = uvc_find_control(chain, v4l2_ctrl->id, &mapping);\r\nif (ctrl == NULL) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = __uvc_query_v4l2_ctrl(chain, ctrl, mapping, v4l2_ctrl);\r\ndone:\r\nmutex_unlock(&chain->ctrl_mutex);\r\nreturn ret;\r\n}\r\nint uvc_query_v4l2_menu(struct uvc_video_chain *chain,\r\nstruct v4l2_querymenu *query_menu)\r\n{\r\nstruct uvc_menu_info *menu_info;\r\nstruct uvc_control_mapping *mapping;\r\nstruct uvc_control *ctrl;\r\nu32 index = query_menu->index;\r\nu32 id = query_menu->id;\r\nint ret;\r\nmemset(query_menu, 0, sizeof(*query_menu));\r\nquery_menu->id = id;\r\nquery_menu->index = index;\r\nret = mutex_lock_interruptible(&chain->ctrl_mutex);\r\nif (ret < 0)\r\nreturn -ERESTARTSYS;\r\nctrl = uvc_find_control(chain, query_menu->id, &mapping);\r\nif (ctrl == NULL || mapping->v4l2_type != V4L2_CTRL_TYPE_MENU) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (query_menu->index >= mapping->menu_count) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nmenu_info = &mapping->menu_info[query_menu->index];\r\nif (mapping->data_type == UVC_CTRL_DATA_TYPE_BITMASK &&\r\n(ctrl->info.flags & UVC_CTRL_FLAG_GET_RES)) {\r\ns32 bitmap;\r\nif (!ctrl->cached) {\r\nret = uvc_ctrl_populate_cache(chain, ctrl);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nbitmap = mapping->get(mapping, UVC_GET_RES,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));\r\nif (!(bitmap & menu_info->value)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n}\r\nstrlcpy(query_menu->name, menu_info->name, sizeof query_menu->name);\r\ndone:\r\nmutex_unlock(&chain->ctrl_mutex);\r\nreturn ret;\r\n}\r\nstatic void uvc_ctrl_fill_event(struct uvc_video_chain *chain,\r\nstruct v4l2_event *ev,\r\nstruct uvc_control *ctrl,\r\nstruct uvc_control_mapping *mapping,\r\ns32 value, u32 changes)\r\n{\r\nstruct v4l2_queryctrl v4l2_ctrl;\r\n__uvc_query_v4l2_ctrl(chain, ctrl, mapping, &v4l2_ctrl);\r\nmemset(ev->reserved, 0, sizeof(ev->reserved));\r\nev->type = V4L2_EVENT_CTRL;\r\nev->id = v4l2_ctrl.id;\r\nev->u.ctrl.value = value;\r\nev->u.ctrl.changes = changes;\r\nev->u.ctrl.type = v4l2_ctrl.type;\r\nev->u.ctrl.flags = v4l2_ctrl.flags;\r\nev->u.ctrl.minimum = v4l2_ctrl.minimum;\r\nev->u.ctrl.maximum = v4l2_ctrl.maximum;\r\nev->u.ctrl.step = v4l2_ctrl.step;\r\nev->u.ctrl.default_value = v4l2_ctrl.default_value;\r\n}\r\nstatic void uvc_ctrl_send_event(struct uvc_fh *handle,\r\nstruct uvc_control *ctrl, struct uvc_control_mapping *mapping,\r\ns32 value, u32 changes)\r\n{\r\nstruct v4l2_subscribed_event *sev;\r\nstruct v4l2_event ev;\r\nif (list_empty(&mapping->ev_subs))\r\nreturn;\r\nuvc_ctrl_fill_event(handle->chain, &ev, ctrl, mapping, value, changes);\r\nlist_for_each_entry(sev, &mapping->ev_subs, node) {\r\nif (sev->fh && (sev->fh != &handle->vfh ||\r\n(sev->flags & V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK) ||\r\n(changes & V4L2_EVENT_CTRL_CH_FLAGS)))\r\nv4l2_event_queue_fh(sev->fh, &ev);\r\n}\r\n}\r\nstatic void uvc_ctrl_send_slave_event(struct uvc_fh *handle,\r\nstruct uvc_control *master, u32 slave_id,\r\nconst struct v4l2_ext_control *xctrls, unsigned int xctrls_count)\r\n{\r\nstruct uvc_control_mapping *mapping = NULL;\r\nstruct uvc_control *ctrl = NULL;\r\nu32 changes = V4L2_EVENT_CTRL_CH_FLAGS;\r\nunsigned int i;\r\ns32 val = 0;\r\nfor (i = 0; i < xctrls_count; i++) {\r\nif (xctrls[i].id == slave_id)\r\nreturn;\r\n}\r\n__uvc_find_control(master->entity, slave_id, &mapping, &ctrl, 0);\r\nif (ctrl == NULL)\r\nreturn;\r\nif (__uvc_ctrl_get(handle->chain, ctrl, mapping, &val) == 0)\r\nchanges |= V4L2_EVENT_CTRL_CH_VALUE;\r\nuvc_ctrl_send_event(handle, ctrl, mapping, val, changes);\r\n}\r\nstatic void uvc_ctrl_send_events(struct uvc_fh *handle,\r\nconst struct v4l2_ext_control *xctrls, unsigned int xctrls_count)\r\n{\r\nstruct uvc_control_mapping *mapping;\r\nstruct uvc_control *ctrl;\r\nu32 changes = V4L2_EVENT_CTRL_CH_VALUE;\r\nunsigned int i;\r\nunsigned int j;\r\nfor (i = 0; i < xctrls_count; ++i) {\r\nctrl = uvc_find_control(handle->chain, xctrls[i].id, &mapping);\r\nfor (j = 0; j < ARRAY_SIZE(mapping->slave_ids); ++j) {\r\nif (!mapping->slave_ids[j])\r\nbreak;\r\nuvc_ctrl_send_slave_event(handle, ctrl,\r\nmapping->slave_ids[j],\r\nxctrls, xctrls_count);\r\n}\r\nif (mapping->master_id) {\r\nfor (j = 0; j < xctrls_count; j++) {\r\nif (xctrls[j].id == mapping->master_id) {\r\nchanges |= V4L2_EVENT_CTRL_CH_FLAGS;\r\nbreak;\r\n}\r\n}\r\n}\r\nuvc_ctrl_send_event(handle, ctrl, mapping, xctrls[i].value,\r\nchanges);\r\n}\r\n}\r\nstatic int uvc_ctrl_add_event(struct v4l2_subscribed_event *sev, unsigned elems)\r\n{\r\nstruct uvc_fh *handle = container_of(sev->fh, struct uvc_fh, vfh);\r\nstruct uvc_control_mapping *mapping;\r\nstruct uvc_control *ctrl;\r\nint ret;\r\nret = mutex_lock_interruptible(&handle->chain->ctrl_mutex);\r\nif (ret < 0)\r\nreturn -ERESTARTSYS;\r\nctrl = uvc_find_control(handle->chain, sev->id, &mapping);\r\nif (ctrl == NULL) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nlist_add_tail(&sev->node, &mapping->ev_subs);\r\nif (sev->flags & V4L2_EVENT_SUB_FL_SEND_INITIAL) {\r\nstruct v4l2_event ev;\r\nu32 changes = V4L2_EVENT_CTRL_CH_FLAGS;\r\ns32 val = 0;\r\nif (__uvc_ctrl_get(handle->chain, ctrl, mapping, &val) == 0)\r\nchanges |= V4L2_EVENT_CTRL_CH_VALUE;\r\nuvc_ctrl_fill_event(handle->chain, &ev, ctrl, mapping, val,\r\nchanges);\r\nsev->elems = elems;\r\nv4l2_event_queue_fh(sev->fh, &ev);\r\n}\r\ndone:\r\nmutex_unlock(&handle->chain->ctrl_mutex);\r\nreturn ret;\r\n}\r\nstatic void uvc_ctrl_del_event(struct v4l2_subscribed_event *sev)\r\n{\r\nstruct uvc_fh *handle = container_of(sev->fh, struct uvc_fh, vfh);\r\nmutex_lock(&handle->chain->ctrl_mutex);\r\nlist_del(&sev->node);\r\nmutex_unlock(&handle->chain->ctrl_mutex);\r\n}\r\nint uvc_ctrl_begin(struct uvc_video_chain *chain)\r\n{\r\nreturn mutex_lock_interruptible(&chain->ctrl_mutex) ? -ERESTARTSYS : 0;\r\n}\r\nstatic int uvc_ctrl_commit_entity(struct uvc_device *dev,\r\nstruct uvc_entity *entity, int rollback)\r\n{\r\nstruct uvc_control *ctrl;\r\nunsigned int i;\r\nint ret;\r\nif (entity == NULL)\r\nreturn 0;\r\nfor (i = 0; i < entity->ncontrols; ++i) {\r\nctrl = &entity->controls[i];\r\nif (!ctrl->initialized)\r\ncontinue;\r\nif (ctrl->info.flags & UVC_CTRL_FLAG_AUTO_UPDATE ||\r\n!(ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR))\r\nctrl->loaded = 0;\r\nif (!ctrl->dirty)\r\ncontinue;\r\nif (!rollback)\r\nret = uvc_query_ctrl(dev, UVC_SET_CUR, ctrl->entity->id,\r\ndev->intfnum, ctrl->info.selector,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\r\nctrl->info.size);\r\nelse\r\nret = 0;\r\nif (rollback || ret < 0)\r\nmemcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),\r\nctrl->info.size);\r\nctrl->dirty = 0;\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint __uvc_ctrl_commit(struct uvc_fh *handle, int rollback,\r\nconst struct v4l2_ext_control *xctrls,\r\nunsigned int xctrls_count)\r\n{\r\nstruct uvc_video_chain *chain = handle->chain;\r\nstruct uvc_entity *entity;\r\nint ret = 0;\r\nlist_for_each_entry(entity, &chain->entities, chain) {\r\nret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nif (!rollback)\r\nuvc_ctrl_send_events(handle, xctrls, xctrls_count);\r\ndone:\r\nmutex_unlock(&chain->ctrl_mutex);\r\nreturn ret;\r\n}\r\nint uvc_ctrl_get(struct uvc_video_chain *chain,\r\nstruct v4l2_ext_control *xctrl)\r\n{\r\nstruct uvc_control *ctrl;\r\nstruct uvc_control_mapping *mapping;\r\nctrl = uvc_find_control(chain, xctrl->id, &mapping);\r\nif (ctrl == NULL)\r\nreturn -EINVAL;\r\nreturn __uvc_ctrl_get(chain, ctrl, mapping, &xctrl->value);\r\n}\r\nint uvc_ctrl_set(struct uvc_video_chain *chain,\r\nstruct v4l2_ext_control *xctrl)\r\n{\r\nstruct uvc_control *ctrl;\r\nstruct uvc_control_mapping *mapping;\r\ns32 value;\r\nu32 step;\r\ns32 min;\r\ns32 max;\r\nint ret;\r\nctrl = uvc_find_control(chain, xctrl->id, &mapping);\r\nif (ctrl == NULL)\r\nreturn -EINVAL;\r\nif (!(ctrl->info.flags & UVC_CTRL_FLAG_SET_CUR))\r\nreturn -EACCES;\r\nswitch (mapping->v4l2_type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\nif (!ctrl->cached) {\r\nret = uvc_ctrl_populate_cache(chain, ctrl);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmin = mapping->get(mapping, UVC_GET_MIN,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN));\r\nmax = mapping->get(mapping, UVC_GET_MAX,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX));\r\nstep = mapping->get(mapping, UVC_GET_RES,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));\r\nif (step == 0)\r\nstep = 1;\r\nxctrl->value = min + ((u32)(xctrl->value - min) + step / 2)\r\n/ step * step;\r\nif (mapping->data_type == UVC_CTRL_DATA_TYPE_SIGNED)\r\nxctrl->value = clamp(xctrl->value, min, max);\r\nelse\r\nxctrl->value = clamp_t(u32, xctrl->value, min, max);\r\nvalue = xctrl->value;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\nxctrl->value = clamp(xctrl->value, 0, 1);\r\nvalue = xctrl->value;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_MENU:\r\nif (xctrl->value < 0 || xctrl->value >= mapping->menu_count)\r\nreturn -ERANGE;\r\nvalue = mapping->menu_info[xctrl->value].value;\r\nif (mapping->data_type == UVC_CTRL_DATA_TYPE_BITMASK &&\r\n(ctrl->info.flags & UVC_CTRL_FLAG_GET_RES)) {\r\nif (!ctrl->cached) {\r\nret = uvc_ctrl_populate_cache(chain, ctrl);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nstep = mapping->get(mapping, UVC_GET_RES,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));\r\nif (!(step & value))\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nvalue = xctrl->value;\r\nbreak;\r\n}\r\nif (!ctrl->loaded && (ctrl->info.size * 8) != mapping->size) {\r\nif ((ctrl->info.flags & UVC_CTRL_FLAG_GET_CUR) == 0) {\r\nmemset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\r\n0, ctrl->info.size);\r\n} else {\r\nret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,\r\nctrl->entity->id, chain->dev->intfnum,\r\nctrl->info.selector,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\r\nctrl->info.size);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nctrl->loaded = 1;\r\n}\r\nif (!ctrl->dirty) {\r\nmemcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),\r\nctrl->info.size);\r\n}\r\nmapping->set(mapping, value,\r\nuvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT));\r\nctrl->dirty = 1;\r\nctrl->modified = 1;\r\nreturn 0;\r\n}\r\nstatic void uvc_ctrl_fixup_xu_info(struct uvc_device *dev,\r\nconst struct uvc_control *ctrl, struct uvc_control_info *info)\r\n{\r\nstruct uvc_ctrl_fixup {\r\nstruct usb_device_id id;\r\nu8 entity;\r\nu8 selector;\r\nu8 flags;\r\n};\r\nstatic const struct uvc_ctrl_fixup fixups[] = {\r\n{ { USB_DEVICE(0x046d, 0x08c2) }, 9, 1,\r\nUVC_CTRL_FLAG_GET_MIN | UVC_CTRL_FLAG_GET_MAX |\r\nUVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_SET_CUR |\r\nUVC_CTRL_FLAG_AUTO_UPDATE },\r\n{ { USB_DEVICE(0x046d, 0x08cc) }, 9, 1,\r\nUVC_CTRL_FLAG_GET_MIN | UVC_CTRL_FLAG_GET_MAX |\r\nUVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_SET_CUR |\r\nUVC_CTRL_FLAG_AUTO_UPDATE },\r\n{ { USB_DEVICE(0x046d, 0x0994) }, 9, 1,\r\nUVC_CTRL_FLAG_GET_MIN | UVC_CTRL_FLAG_GET_MAX |\r\nUVC_CTRL_FLAG_GET_DEF | UVC_CTRL_FLAG_SET_CUR |\r\nUVC_CTRL_FLAG_AUTO_UPDATE },\r\n};\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(fixups); ++i) {\r\nif (!usb_match_one_id(dev->intf, &fixups[i].id))\r\ncontinue;\r\nif (fixups[i].entity == ctrl->entity->id &&\r\nfixups[i].selector == info->selector) {\r\ninfo->flags = fixups[i].flags;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int uvc_ctrl_fill_xu_info(struct uvc_device *dev,\r\nconst struct uvc_control *ctrl, struct uvc_control_info *info)\r\n{\r\nu8 *data;\r\nint ret;\r\ndata = kmalloc(2, GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(info->entity, ctrl->entity->extension.guidExtensionCode,\r\nsizeof(info->entity));\r\ninfo->index = ctrl->index;\r\ninfo->selector = ctrl->index + 1;\r\nret = uvc_query_ctrl(dev, UVC_GET_LEN, ctrl->entity->id, dev->intfnum,\r\ninfo->selector, data, 2);\r\nif (ret < 0) {\r\nuvc_trace(UVC_TRACE_CONTROL,\r\n"GET_LEN failed on control %pUl/%u (%d).\n",\r\ninfo->entity, info->selector, ret);\r\ngoto done;\r\n}\r\ninfo->size = le16_to_cpup((__le16 *)data);\r\nret = uvc_query_ctrl(dev, UVC_GET_INFO, ctrl->entity->id, dev->intfnum,\r\ninfo->selector, data, 1);\r\nif (ret < 0) {\r\nuvc_trace(UVC_TRACE_CONTROL,\r\n"GET_INFO failed on control %pUl/%u (%d).\n",\r\ninfo->entity, info->selector, ret);\r\ngoto done;\r\n}\r\ninfo->flags = UVC_CTRL_FLAG_GET_MIN | UVC_CTRL_FLAG_GET_MAX\r\n| UVC_CTRL_FLAG_GET_RES | UVC_CTRL_FLAG_GET_DEF\r\n| (data[0] & UVC_CONTROL_CAP_GET ?\r\nUVC_CTRL_FLAG_GET_CUR : 0)\r\n| (data[0] & UVC_CONTROL_CAP_SET ?\r\nUVC_CTRL_FLAG_SET_CUR : 0)\r\n| (data[0] & UVC_CONTROL_CAP_AUTOUPDATE ?\r\nUVC_CTRL_FLAG_AUTO_UPDATE : 0);\r\nuvc_ctrl_fixup_xu_info(dev, ctrl, info);\r\nuvc_trace(UVC_TRACE_CONTROL, "XU control %pUl/%u queried: len %u, "\r\n"flags { get %u set %u auto %u }.\n",\r\ninfo->entity, info->selector, info->size,\r\n(info->flags & UVC_CTRL_FLAG_GET_CUR) ? 1 : 0,\r\n(info->flags & UVC_CTRL_FLAG_SET_CUR) ? 1 : 0,\r\n(info->flags & UVC_CTRL_FLAG_AUTO_UPDATE) ? 1 : 0);\r\ndone:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int uvc_ctrl_init_xu_ctrl(struct uvc_device *dev,\r\nstruct uvc_control *ctrl)\r\n{\r\nstruct uvc_control_info info;\r\nint ret;\r\nif (ctrl->initialized)\r\nreturn 0;\r\nret = uvc_ctrl_fill_xu_info(dev, ctrl, &info);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uvc_ctrl_add_info(dev, ctrl, &info);\r\nif (ret < 0)\r\nuvc_trace(UVC_TRACE_CONTROL, "Failed to initialize control "\r\n"%pUl/%u on device %s entity %u\n", info.entity,\r\ninfo.selector, dev->udev->devpath, ctrl->entity->id);\r\nreturn ret;\r\n}\r\nint uvc_xu_ctrl_query(struct uvc_video_chain *chain,\r\nstruct uvc_xu_control_query *xqry)\r\n{\r\nstruct uvc_entity *entity;\r\nstruct uvc_control *ctrl;\r\nunsigned int i, found = 0;\r\n__u32 reqflags;\r\n__u16 size;\r\n__u8 *data = NULL;\r\nint ret;\r\nlist_for_each_entry(entity, &chain->entities, chain) {\r\nif (UVC_ENTITY_TYPE(entity) == UVC_VC_EXTENSION_UNIT &&\r\nentity->id == xqry->unit)\r\nbreak;\r\n}\r\nif (entity->id != xqry->unit) {\r\nuvc_trace(UVC_TRACE_CONTROL, "Extension unit %u not found.\n",\r\nxqry->unit);\r\nreturn -ENOENT;\r\n}\r\nfor (i = 0; i < entity->ncontrols; ++i) {\r\nctrl = &entity->controls[i];\r\nif (ctrl->index == xqry->selector - 1) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nuvc_trace(UVC_TRACE_CONTROL, "Control %pUl/%u not found.\n",\r\nentity->extension.guidExtensionCode, xqry->selector);\r\nreturn -ENOENT;\r\n}\r\nif (mutex_lock_interruptible(&chain->ctrl_mutex))\r\nreturn -ERESTARTSYS;\r\nret = uvc_ctrl_init_xu_ctrl(chain->dev, ctrl);\r\nif (ret < 0) {\r\nret = -ENOENT;\r\ngoto done;\r\n}\r\nreqflags = 0;\r\nsize = ctrl->info.size;\r\nswitch (xqry->query) {\r\ncase UVC_GET_CUR:\r\nreqflags = UVC_CTRL_FLAG_GET_CUR;\r\nbreak;\r\ncase UVC_GET_MIN:\r\nreqflags = UVC_CTRL_FLAG_GET_MIN;\r\nbreak;\r\ncase UVC_GET_MAX:\r\nreqflags = UVC_CTRL_FLAG_GET_MAX;\r\nbreak;\r\ncase UVC_GET_DEF:\r\nreqflags = UVC_CTRL_FLAG_GET_DEF;\r\nbreak;\r\ncase UVC_GET_RES:\r\nreqflags = UVC_CTRL_FLAG_GET_RES;\r\nbreak;\r\ncase UVC_SET_CUR:\r\nreqflags = UVC_CTRL_FLAG_SET_CUR;\r\nbreak;\r\ncase UVC_GET_LEN:\r\nsize = 2;\r\nbreak;\r\ncase UVC_GET_INFO:\r\nsize = 1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (size != xqry->size) {\r\nret = -ENOBUFS;\r\ngoto done;\r\n}\r\nif (reqflags && !(ctrl->info.flags & reqflags)) {\r\nret = -EBADRQC;\r\ngoto done;\r\n}\r\ndata = kmalloc(size, GFP_KERNEL);\r\nif (data == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nif (xqry->query == UVC_SET_CUR &&\r\ncopy_from_user(data, xqry->data, size)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nret = uvc_query_ctrl(chain->dev, xqry->query, xqry->unit,\r\nchain->dev->intfnum, xqry->selector, data, size);\r\nif (ret < 0)\r\ngoto done;\r\nif (xqry->query != UVC_SET_CUR &&\r\ncopy_to_user(xqry->data, data, size))\r\nret = -EFAULT;\r\ndone:\r\nkfree(data);\r\nmutex_unlock(&chain->ctrl_mutex);\r\nreturn ret;\r\n}\r\nint uvc_ctrl_resume_device(struct uvc_device *dev)\r\n{\r\nstruct uvc_control *ctrl;\r\nstruct uvc_entity *entity;\r\nunsigned int i;\r\nint ret;\r\nlist_for_each_entry(entity, &dev->entities, list) {\r\nfor (i = 0; i < entity->ncontrols; ++i) {\r\nctrl = &entity->controls[i];\r\nif (!ctrl->initialized || !ctrl->modified ||\r\n(ctrl->info.flags & UVC_CTRL_FLAG_RESTORE) == 0)\r\ncontinue;\r\nprintk(KERN_INFO "restoring control %pUl/%u/%u\n",\r\nctrl->info.entity, ctrl->info.index,\r\nctrl->info.selector);\r\nctrl->dirty = 1;\r\n}\r\nret = uvc_ctrl_commit_entity(dev, entity, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvc_ctrl_add_info(struct uvc_device *dev, struct uvc_control *ctrl,\r\nconst struct uvc_control_info *info)\r\n{\r\nint ret = 0;\r\nctrl->info = *info;\r\nINIT_LIST_HEAD(&ctrl->info.mappings);\r\nctrl->uvc_data = kzalloc(ctrl->info.size * UVC_CTRL_DATA_LAST + 1,\r\nGFP_KERNEL);\r\nif (ctrl->uvc_data == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nctrl->initialized = 1;\r\nuvc_trace(UVC_TRACE_CONTROL, "Added control %pUl/%u to device %s "\r\n"entity %u\n", ctrl->info.entity, ctrl->info.selector,\r\ndev->udev->devpath, ctrl->entity->id);\r\ndone:\r\nif (ret < 0)\r\nkfree(ctrl->uvc_data);\r\nreturn ret;\r\n}\r\nstatic int __uvc_ctrl_add_mapping(struct uvc_device *dev,\r\nstruct uvc_control *ctrl, const struct uvc_control_mapping *mapping)\r\n{\r\nstruct uvc_control_mapping *map;\r\nunsigned int size;\r\nmap = kmemdup(mapping, sizeof(*mapping), GFP_KERNEL);\r\nif (map == NULL)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&map->ev_subs);\r\nsize = sizeof(*mapping->menu_info) * mapping->menu_count;\r\nmap->menu_info = kmemdup(mapping->menu_info, size, GFP_KERNEL);\r\nif (map->menu_info == NULL) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nif (map->get == NULL)\r\nmap->get = uvc_get_le_value;\r\nif (map->set == NULL)\r\nmap->set = uvc_set_le_value;\r\nlist_add_tail(&map->list, &ctrl->info.mappings);\r\nuvc_trace(UVC_TRACE_CONTROL,\r\n"Adding mapping '%s' to control %pUl/%u.\n",\r\nmap->name, ctrl->info.entity, ctrl->info.selector);\r\nreturn 0;\r\n}\r\nint uvc_ctrl_add_mapping(struct uvc_video_chain *chain,\r\nconst struct uvc_control_mapping *mapping)\r\n{\r\nstruct uvc_device *dev = chain->dev;\r\nstruct uvc_control_mapping *map;\r\nstruct uvc_entity *entity;\r\nstruct uvc_control *ctrl;\r\nint found = 0;\r\nint ret;\r\nif (mapping->id & ~V4L2_CTRL_ID_MASK) {\r\nuvc_trace(UVC_TRACE_CONTROL, "Can't add mapping '%s', control "\r\n"id 0x%08x is invalid.\n", mapping->name,\r\nmapping->id);\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(entity, &chain->entities, chain) {\r\nunsigned int i;\r\nif (UVC_ENTITY_TYPE(entity) != UVC_VC_EXTENSION_UNIT ||\r\n!uvc_entity_match_guid(entity, mapping->entity))\r\ncontinue;\r\nfor (i = 0; i < entity->ncontrols; ++i) {\r\nctrl = &entity->controls[i];\r\nif (ctrl->index == mapping->selector - 1) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found)\r\nbreak;\r\n}\r\nif (!found)\r\nreturn -ENOENT;\r\nif (mutex_lock_interruptible(&chain->ctrl_mutex))\r\nreturn -ERESTARTSYS;\r\nret = uvc_ctrl_init_xu_ctrl(dev, ctrl);\r\nif (ret < 0) {\r\nret = -ENOENT;\r\ngoto done;\r\n}\r\nlist_for_each_entry(map, &ctrl->info.mappings, list) {\r\nif (mapping->id == map->id) {\r\nuvc_trace(UVC_TRACE_CONTROL, "Can't add mapping '%s', "\r\n"control id 0x%08x already exists.\n",\r\nmapping->name, mapping->id);\r\nret = -EEXIST;\r\ngoto done;\r\n}\r\n}\r\nif (atomic_inc_return(&dev->nmappings) > UVC_MAX_CONTROL_MAPPINGS) {\r\natomic_dec(&dev->nmappings);\r\nuvc_trace(UVC_TRACE_CONTROL, "Can't add mapping '%s', maximum "\r\n"mappings count (%u) exceeded.\n", mapping->name,\r\nUVC_MAX_CONTROL_MAPPINGS);\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nret = __uvc_ctrl_add_mapping(dev, ctrl, mapping);\r\nif (ret < 0)\r\natomic_dec(&dev->nmappings);\r\ndone:\r\nmutex_unlock(&chain->ctrl_mutex);\r\nreturn ret;\r\n}\r\nstatic void uvc_ctrl_prune_entity(struct uvc_device *dev,\r\nstruct uvc_entity *entity)\r\n{\r\nstruct uvc_ctrl_blacklist {\r\nstruct usb_device_id id;\r\nu8 index;\r\n};\r\nstatic const struct uvc_ctrl_blacklist processing_blacklist[] = {\r\n{ { USB_DEVICE(0x13d3, 0x509b) }, 9 },\r\n{ { USB_DEVICE(0x1c4f, 0x3000) }, 6 },\r\n{ { USB_DEVICE(0x5986, 0x0241) }, 2 },\r\n};\r\nstatic const struct uvc_ctrl_blacklist camera_blacklist[] = {\r\n{ { USB_DEVICE(0x06f8, 0x3005) }, 9 },\r\n};\r\nconst struct uvc_ctrl_blacklist *blacklist;\r\nunsigned int size;\r\nunsigned int count;\r\nunsigned int i;\r\nu8 *controls;\r\nswitch (UVC_ENTITY_TYPE(entity)) {\r\ncase UVC_VC_PROCESSING_UNIT:\r\nblacklist = processing_blacklist;\r\ncount = ARRAY_SIZE(processing_blacklist);\r\ncontrols = entity->processing.bmControls;\r\nsize = entity->processing.bControlSize;\r\nbreak;\r\ncase UVC_ITT_CAMERA:\r\nblacklist = camera_blacklist;\r\ncount = ARRAY_SIZE(camera_blacklist);\r\ncontrols = entity->camera.bmControls;\r\nsize = entity->camera.bControlSize;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nfor (i = 0; i < count; ++i) {\r\nif (!usb_match_one_id(dev->intf, &blacklist[i].id))\r\ncontinue;\r\nif (blacklist[i].index >= 8 * size ||\r\n!uvc_test_bit(controls, blacklist[i].index))\r\ncontinue;\r\nuvc_trace(UVC_TRACE_CONTROL, "%u/%u control is black listed, "\r\n"removing it.\n", entity->id, blacklist[i].index);\r\nuvc_clear_bit(controls, blacklist[i].index);\r\n}\r\n}\r\nstatic void uvc_ctrl_init_ctrl(struct uvc_device *dev, struct uvc_control *ctrl)\r\n{\r\nconst struct uvc_control_info *info = uvc_ctrls;\r\nconst struct uvc_control_info *iend = info + ARRAY_SIZE(uvc_ctrls);\r\nconst struct uvc_control_mapping *mapping = uvc_ctrl_mappings;\r\nconst struct uvc_control_mapping *mend =\r\nmapping + ARRAY_SIZE(uvc_ctrl_mappings);\r\nif (UVC_ENTITY_TYPE(ctrl->entity) == UVC_VC_EXTENSION_UNIT)\r\nreturn;\r\nfor (; info < iend; ++info) {\r\nif (uvc_entity_match_guid(ctrl->entity, info->entity) &&\r\nctrl->index == info->index) {\r\nuvc_ctrl_add_info(dev, ctrl, info);\r\nbreak;\r\n}\r\n}\r\nif (!ctrl->initialized)\r\nreturn;\r\nfor (; mapping < mend; ++mapping) {\r\nif (uvc_entity_match_guid(ctrl->entity, mapping->entity) &&\r\nctrl->info.selector == mapping->selector)\r\n__uvc_ctrl_add_mapping(dev, ctrl, mapping);\r\n}\r\n}\r\nint uvc_ctrl_init_device(struct uvc_device *dev)\r\n{\r\nstruct uvc_entity *entity;\r\nunsigned int i;\r\nlist_for_each_entry(entity, &dev->entities, list) {\r\nstruct uvc_control *ctrl;\r\nunsigned int bControlSize = 0, ncontrols;\r\n__u8 *bmControls = NULL;\r\nif (UVC_ENTITY_TYPE(entity) == UVC_VC_EXTENSION_UNIT) {\r\nbmControls = entity->extension.bmControls;\r\nbControlSize = entity->extension.bControlSize;\r\n} else if (UVC_ENTITY_TYPE(entity) == UVC_VC_PROCESSING_UNIT) {\r\nbmControls = entity->processing.bmControls;\r\nbControlSize = entity->processing.bControlSize;\r\n} else if (UVC_ENTITY_TYPE(entity) == UVC_ITT_CAMERA) {\r\nbmControls = entity->camera.bmControls;\r\nbControlSize = entity->camera.bControlSize;\r\n}\r\nuvc_ctrl_prune_entity(dev, entity);\r\nncontrols = memweight(bmControls, bControlSize);\r\nif (ncontrols == 0)\r\ncontinue;\r\nentity->controls = kcalloc(ncontrols, sizeof(*ctrl),\r\nGFP_KERNEL);\r\nif (entity->controls == NULL)\r\nreturn -ENOMEM;\r\nentity->ncontrols = ncontrols;\r\nctrl = entity->controls;\r\nfor (i = 0; i < bControlSize * 8; ++i) {\r\nif (uvc_test_bit(bmControls, i) == 0)\r\ncontinue;\r\nctrl->entity = entity;\r\nctrl->index = i;\r\nuvc_ctrl_init_ctrl(dev, ctrl);\r\nctrl++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void uvc_ctrl_cleanup_mappings(struct uvc_device *dev,\r\nstruct uvc_control *ctrl)\r\n{\r\nstruct uvc_control_mapping *mapping, *nm;\r\nlist_for_each_entry_safe(mapping, nm, &ctrl->info.mappings, list) {\r\nlist_del(&mapping->list);\r\nkfree(mapping->menu_info);\r\nkfree(mapping);\r\n}\r\n}\r\nvoid uvc_ctrl_cleanup_device(struct uvc_device *dev)\r\n{\r\nstruct uvc_entity *entity;\r\nunsigned int i;\r\nlist_for_each_entry(entity, &dev->entities, list) {\r\nfor (i = 0; i < entity->ncontrols; ++i) {\r\nstruct uvc_control *ctrl = &entity->controls[i];\r\nif (!ctrl->initialized)\r\ncontinue;\r\nuvc_ctrl_cleanup_mappings(dev, ctrl);\r\nkfree(ctrl->uvc_data);\r\n}\r\nkfree(entity->controls);\r\n}\r\n}
