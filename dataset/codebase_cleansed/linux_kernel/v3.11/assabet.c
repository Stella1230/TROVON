void ASSABET_BCR_frob(unsigned int mask, unsigned int val)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nBCR_value = (BCR_value & ~mask) | val;\r\nASSABET_BCR = BCR_value;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void assabet_ucb1x00_reset(enum ucb1x00_reset state)\r\n{\r\nif (state == UCB_RST_PROBE)\r\nASSABET_BCR_set(ASSABET_BCR_CODEC_RST);\r\n}\r\nstatic int assabet_irda_set_power(struct device *dev, unsigned int state)\r\n{\r\nstatic unsigned int bcr_state[4] = {\r\nASSABET_BCR_IRDA_MD0,\r\nASSABET_BCR_IRDA_MD1|ASSABET_BCR_IRDA_MD0,\r\nASSABET_BCR_IRDA_MD1,\r\n0\r\n};\r\nif (state < 4) {\r\nstate = bcr_state[state];\r\nASSABET_BCR_clear(state ^ (ASSABET_BCR_IRDA_MD1|\r\nASSABET_BCR_IRDA_MD0));\r\nASSABET_BCR_set(state);\r\n}\r\nreturn 0;\r\n}\r\nstatic void assabet_irda_set_speed(struct device *dev, unsigned int speed)\r\n{\r\nif (speed < 4000000)\r\nASSABET_BCR_clear(ASSABET_BCR_IRDA_FSEL);\r\nelse\r\nASSABET_BCR_set(ASSABET_BCR_IRDA_FSEL);\r\n}\r\nstatic void assabet_lcd_set_visual(u32 visual)\r\n{\r\nu_int is_true_color = visual == FB_VISUAL_TRUECOLOR;\r\nif (machine_is_assabet()) {\r\n#if 1\r\nif (is_true_color)\r\nASSABET_BCR_set(ASSABET_BCR_LCD_12RGB);\r\nelse\r\nASSABET_BCR_clear(ASSABET_BCR_LCD_12RGB);\r\n#else\r\nif (is_true_color)\r\nASSABET_BCR_clear(ASSABET_BCR_LCD_12RGB);\r\nelse\r\nASSABET_BCR_set(ASSABET_BCR_LCD_12RGB);\r\n#endif\r\n}\r\n}\r\nstatic void assabet_lcd_backlight_power(int on)\r\n{\r\nif (on)\r\nASSABET_BCR_set(ASSABET_BCR_LIGHT_ON);\r\nelse\r\nASSABET_BCR_clear(ASSABET_BCR_LIGHT_ON);\r\n}\r\nstatic void assabet_lcd_power(int on)\r\n{\r\nif (on) {\r\nASSABET_BCR_set(ASSABET_BCR_LCD_ON);\r\nudelay(500);\r\n} else\r\nASSABET_BCR_clear(ASSABET_BCR_LCD_ON);\r\n}\r\nstatic void assabet_pal_backlight_power(int on)\r\n{\r\nASSABET_BCR_clear(ASSABET_BCR_LIGHT_ON);\r\n}\r\nstatic void assabet_pal_power(int on)\r\n{\r\nASSABET_BCR_clear(ASSABET_BCR_LCD_ON);\r\n}\r\nstatic void __init assabet_init(void)\r\n{\r\nGPSR = GPIO_GPIO16;\r\nGPDR |= GPIO_GPIO16;\r\nGPCR = GPIO_SSP_TXD | GPIO_SSP_SCLK | GPIO_SSP_SFRM;\r\nGPDR |= GPIO_SSP_TXD | GPIO_SSP_SCLK | GPIO_SSP_SFRM;\r\nGPCR = GPIO_GPIO27;\r\nGPDR |= GPIO_GPIO27;\r\nPWER = PWER_GPIO0;\r\nPGSR = 0;\r\nPCFR = 0;\r\nPSDR = 0;\r\nPPDR |= PPC_TXD3 | PPC_TXD1;\r\nPPSR |= PPC_TXD3 | PPC_TXD1;\r\nsa11x0_ppc_configure_mcp();\r\nif (machine_has_neponset()) {\r\nASSABET_BCR = BCR_value = ASSABET_BCR_DB1111;\r\n#ifndef CONFIG_ASSABET_NEPONSET\r\nprintk( "Warning: Neponset detected but full support "\r\n"hasn't been configured in the kernel\n" );\r\n#else\r\nplatform_device_register_simple("neponset", 0,\r\nneponset_resources, ARRAY_SIZE(neponset_resources));\r\n#endif\r\n}\r\n#ifndef ASSABET_PAL_VIDEO\r\nsa11x0_register_lcd(&lq039q2ds54_info);\r\n#else\r\nsa11x0_register_lcd(&pal_video);\r\n#endif\r\nsa11x0_register_mtd(&assabet_flash_data, assabet_flash_resources,\r\nARRAY_SIZE(assabet_flash_resources));\r\nsa11x0_register_irda(&assabet_irda_data);\r\nsa11x0_register_mcp(&assabet_mcp_data);\r\n}\r\nstatic void __init map_sa1100_gpio_regs( void )\r\n{\r\nunsigned long phys = __PREG(GPLR) & PMD_MASK;\r\nunsigned long virt = (unsigned long)io_p2v(phys);\r\nint prot = PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_DOMAIN(DOMAIN_IO);\r\npmd_t *pmd;\r\npmd = pmd_offset(pud_offset(pgd_offset_k(virt), virt), virt);\r\n*pmd = __pmd(phys | prot);\r\nflush_pmd_entry(pmd);\r\n}\r\nstatic void __init get_assabet_scr(void)\r\n{\r\nunsigned long uninitialized_var(scr), i;\r\nGPDR |= 0x3fc;\r\nGPSR = 0x3fc;\r\nGPDR &= ~(0x3fc);\r\nfor(i = 100; i--; )\r\nscr = GPLR;\r\nGPDR |= 0x3fc;\r\nscr &= 0x3fc;\r\nSCR_value = scr;\r\n}\r\nstatic void __init\r\nfixup_assabet(struct tag *tags, char **cmdline, struct meminfo *mi)\r\n{\r\nmap_sa1100_gpio_regs();\r\nget_assabet_scr();\r\nif (machine_has_neponset())\r\nprintk("Neponset expansion board detected\n");\r\n}\r\nstatic void assabet_uart_pm(struct uart_port *port, u_int state, u_int oldstate)\r\n{\r\nif (port->mapbase == _Ser1UTCR0) {\r\nif (state)\r\nASSABET_BCR_clear(ASSABET_BCR_RS232EN |\r\nASSABET_BCR_COM_RTS |\r\nASSABET_BCR_COM_DTR);\r\nelse\r\nASSABET_BCR_set(ASSABET_BCR_RS232EN |\r\nASSABET_BCR_COM_RTS |\r\nASSABET_BCR_COM_DTR);\r\n}\r\n}\r\nstatic void assabet_set_mctrl(struct uart_port *port, u_int mctrl)\r\n{\r\nif (port->mapbase == _Ser1UTCR0) {\r\nu_int set = 0, clear = 0;\r\nif (mctrl & TIOCM_RTS)\r\nclear |= ASSABET_BCR_COM_RTS;\r\nelse\r\nset |= ASSABET_BCR_COM_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nclear |= ASSABET_BCR_COM_DTR;\r\nelse\r\nset |= ASSABET_BCR_COM_DTR;\r\nASSABET_BCR_clear(clear);\r\nASSABET_BCR_set(set);\r\n}\r\n}\r\nstatic u_int assabet_get_mctrl(struct uart_port *port)\r\n{\r\nu_int ret = 0;\r\nu_int bsr = ASSABET_BSR;\r\nbsr = ASSABET_BSR;\r\nif (port->mapbase == _Ser1UTCR0) {\r\nif (bsr & ASSABET_BSR_COM_DCD)\r\nret |= TIOCM_CD;\r\nif (bsr & ASSABET_BSR_COM_CTS)\r\nret |= TIOCM_CTS;\r\nif (bsr & ASSABET_BSR_COM_DSR)\r\nret |= TIOCM_DSR;\r\n} else if (port->mapbase == _Ser3UTCR0) {\r\nif (bsr & ASSABET_BSR_RAD_DCD)\r\nret |= TIOCM_CD;\r\nif (bsr & ASSABET_BSR_RAD_CTS)\r\nret |= TIOCM_CTS;\r\nif (bsr & ASSABET_BSR_RAD_DSR)\r\nret |= TIOCM_DSR;\r\nif (bsr & ASSABET_BSR_RAD_RI)\r\nret |= TIOCM_RI;\r\n} else {\r\nret = TIOCM_CD | TIOCM_CTS | TIOCM_DSR;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __init assabet_map_io(void)\r\n{\r\nsa1100_map_io();\r\niotable_init(assabet_io_desc, ARRAY_SIZE(assabet_io_desc));\r\nSer1SDCR0 |= SDCR0_SUS;\r\nif (!machine_has_neponset())\r\nsa1100_register_uart_fns(&assabet_port_fns);\r\nsa1100_register_uart(0, 1);\r\nsa1100_register_uart(2, 3);\r\n}\r\nstatic void assabet_led_set(struct led_classdev *cdev,\r\nenum led_brightness b)\r\n{\r\nstruct assabet_led *led = container_of(cdev,\r\nstruct assabet_led, cdev);\r\nif (b != LED_OFF)\r\nASSABET_BCR_clear(led->mask);\r\nelse\r\nASSABET_BCR_set(led->mask);\r\n}\r\nstatic enum led_brightness assabet_led_get(struct led_classdev *cdev)\r\n{\r\nstruct assabet_led *led = container_of(cdev,\r\nstruct assabet_led, cdev);\r\nreturn (ASSABET_BCR & led->mask) ? LED_OFF : LED_FULL;\r\n}\r\nstatic int __init assabet_leds_init(void)\r\n{\r\nint i;\r\nif (!machine_is_assabet())\r\nreturn -ENODEV;\r\nfor (i = 0; i < ARRAY_SIZE(assabet_leds); i++) {\r\nstruct assabet_led *led;\r\nled = kzalloc(sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nbreak;\r\nled->cdev.name = assabet_leds[i].name;\r\nled->cdev.brightness_set = assabet_led_set;\r\nled->cdev.brightness_get = assabet_led_get;\r\nled->cdev.default_trigger = assabet_leds[i].trigger;\r\nif (!i)\r\nled->mask = ASSABET_BCR_LED_RED;\r\nelse\r\nled->mask = ASSABET_BCR_LED_GREEN;\r\nif (led_classdev_register(NULL, &led->cdev) < 0) {\r\nkfree(led);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
