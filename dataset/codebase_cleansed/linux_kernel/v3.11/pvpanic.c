static void\r\npvpanic_send_event(unsigned int event)\r\n{\r\noutb(event, port);\r\n}\r\nstatic int\r\npvpanic_panic_notify(struct notifier_block *nb, unsigned long code,\r\nvoid *unused)\r\n{\r\npvpanic_send_event(PVPANIC_PANICKED);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic acpi_status\r\npvpanic_walk_resources(struct acpi_resource *res, void *context)\r\n{\r\nswitch (res->type) {\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_IO:\r\nport = res->data.io.minimum;\r\nreturn AE_OK;\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\n}\r\nstatic int pvpanic_add(struct acpi_device *device)\r\n{\r\nacpi_status status;\r\nu64 ret;\r\nstatus = acpi_evaluate_integer(device->handle, "_STA", NULL,\r\n&ret);\r\nif (ACPI_FAILURE(status) || (ret & 0x0B) != 0x0B)\r\nreturn -ENODEV;\r\nacpi_walk_resources(device->handle, METHOD_NAME__CRS,\r\npvpanic_walk_resources, NULL);\r\nif (!port)\r\nreturn -ENODEV;\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&pvpanic_panic_nb);\r\nreturn 0;\r\n}\r\nstatic int pvpanic_remove(struct acpi_device *device)\r\n{\r\natomic_notifier_chain_unregister(&panic_notifier_list,\r\n&pvpanic_panic_nb);\r\nreturn 0;\r\n}
