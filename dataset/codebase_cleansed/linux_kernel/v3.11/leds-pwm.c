static void __led_pwm_set(struct led_pwm_data *led_dat)\r\n{\r\nint new_duty = led_dat->duty;\r\npwm_config(led_dat->pwm, new_duty, led_dat->period);\r\nif (new_duty == 0)\r\npwm_disable(led_dat->pwm);\r\nelse\r\npwm_enable(led_dat->pwm);\r\n}\r\nstatic void led_pwm_work(struct work_struct *work)\r\n{\r\nstruct led_pwm_data *led_dat =\r\ncontainer_of(work, struct led_pwm_data, work);\r\n__led_pwm_set(led_dat);\r\n}\r\nstatic void led_pwm_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct led_pwm_data *led_dat =\r\ncontainer_of(led_cdev, struct led_pwm_data, cdev);\r\nunsigned int max = led_dat->cdev.max_brightness;\r\nunsigned int period = led_dat->period;\r\nled_dat->duty = brightness * period / max;\r\nif (led_dat->can_sleep)\r\nschedule_work(&led_dat->work);\r\nelse\r\n__led_pwm_set(led_dat);\r\n}\r\nstatic inline size_t sizeof_pwm_leds_priv(int num_leds)\r\n{\r\nreturn sizeof(struct led_pwm_priv) +\r\n(sizeof(struct led_pwm_data) * num_leds);\r\n}\r\nstatic struct led_pwm_priv *led_pwm_create_of(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *child;\r\nstruct led_pwm_priv *priv;\r\nint count, ret;\r\ncount = of_get_child_count(node);\r\nif (!count)\r\nreturn NULL;\r\npriv = devm_kzalloc(&pdev->dev, sizeof_pwm_leds_priv(count),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn NULL;\r\nfor_each_child_of_node(node, child) {\r\nstruct led_pwm_data *led_dat = &priv->leds[priv->num_leds];\r\nled_dat->cdev.name = of_get_property(child, "label",\r\nNULL) ? : child->name;\r\nled_dat->pwm = devm_of_pwm_get(&pdev->dev, child, NULL);\r\nif (IS_ERR(led_dat->pwm)) {\r\ndev_err(&pdev->dev, "unable to request PWM for %s\n",\r\nled_dat->cdev.name);\r\ngoto err;\r\n}\r\nled_dat->period = pwm_get_period(led_dat->pwm);\r\nled_dat->cdev.default_trigger = of_get_property(child,\r\n"linux,default-trigger", NULL);\r\nof_property_read_u32(child, "max-brightness",\r\n&led_dat->cdev.max_brightness);\r\nled_dat->cdev.brightness_set = led_pwm_set;\r\nled_dat->cdev.brightness = LED_OFF;\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled_dat->can_sleep = pwm_can_sleep(led_dat->pwm);\r\nif (led_dat->can_sleep)\r\nINIT_WORK(&led_dat->work, led_pwm_work);\r\nret = led_classdev_register(&pdev->dev, &led_dat->cdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register for %s\n",\r\nled_dat->cdev.name);\r\nof_node_put(child);\r\ngoto err;\r\n}\r\npriv->num_leds++;\r\n}\r\nreturn priv;\r\nerr:\r\nwhile (priv->num_leds--)\r\nled_classdev_unregister(&priv->leds[priv->num_leds].cdev);\r\nreturn NULL;\r\n}\r\nstatic int led_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct led_pwm_platform_data *pdata = pdev->dev.platform_data;\r\nstruct led_pwm_priv *priv;\r\nint i, ret = 0;\r\nif (pdata && pdata->num_leds) {\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof_pwm_leds_priv(pdata->num_leds),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nstruct led_pwm *cur_led = &pdata->leds[i];\r\nstruct led_pwm_data *led_dat = &priv->leds[i];\r\nled_dat->pwm = devm_pwm_get(&pdev->dev, cur_led->name);\r\nif (IS_ERR(led_dat->pwm)) {\r\nret = PTR_ERR(led_dat->pwm);\r\ndev_err(&pdev->dev,\r\n"unable to request PWM for %s\n",\r\ncur_led->name);\r\ngoto err;\r\n}\r\nled_dat->cdev.name = cur_led->name;\r\nled_dat->cdev.default_trigger = cur_led->default_trigger;\r\nled_dat->active_low = cur_led->active_low;\r\nled_dat->period = cur_led->pwm_period_ns;\r\nled_dat->cdev.brightness_set = led_pwm_set;\r\nled_dat->cdev.brightness = LED_OFF;\r\nled_dat->cdev.max_brightness = cur_led->max_brightness;\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled_dat->can_sleep = pwm_can_sleep(led_dat->pwm);\r\nif (led_dat->can_sleep)\r\nINIT_WORK(&led_dat->work, led_pwm_work);\r\nret = led_classdev_register(&pdev->dev, &led_dat->cdev);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\npriv->num_leds = pdata->num_leds;\r\n} else {\r\npriv = led_pwm_create_of(pdev);\r\nif (!priv)\r\nreturn -ENODEV;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\nerr:\r\nwhile (i--)\r\nled_classdev_unregister(&priv->leds[i].cdev);\r\nreturn ret;\r\n}\r\nstatic int led_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct led_pwm_priv *priv = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < priv->num_leds; i++) {\r\nled_classdev_unregister(&priv->leds[i].cdev);\r\nif (priv->leds[i].can_sleep)\r\ncancel_work_sync(&priv->leds[i].work);\r\n}\r\nreturn 0;\r\n}
