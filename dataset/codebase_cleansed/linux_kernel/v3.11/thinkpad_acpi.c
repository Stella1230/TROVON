static inline const char *str_supported(int is_supported) { return ""; }\r\nstatic void tpacpi_log_usertask(const char * const what)\r\n{\r\nprintk(KERN_DEBUG pr_fmt("%s: access by process with PID %d\n"),\r\nwhat, task_tgid_vnr(current));\r\n}\r\nstatic unsigned long __init tpacpi_check_quirks(\r\nconst struct tpacpi_quirk *qlist,\r\nunsigned int qlist_size)\r\n{\r\nwhile (qlist_size) {\r\nif ((qlist->vendor == thinkpad_id.vendor ||\r\nqlist->vendor == TPACPI_MATCH_ANY) &&\r\n(qlist->bios == thinkpad_id.bios_model ||\r\nqlist->bios == TPACPI_MATCH_ANY) &&\r\n(qlist->ec == thinkpad_id.ec_model ||\r\nqlist->ec == TPACPI_MATCH_ANY))\r\nreturn qlist->quirks;\r\nqlist_size--;\r\nqlist++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline bool __pure __init tpacpi_is_lenovo(void)\r\n{\r\nreturn thinkpad_id.vendor == PCI_VENDOR_ID_LENOVO;\r\n}\r\nstatic inline bool __pure __init tpacpi_is_ibm(void)\r\n{\r\nreturn thinkpad_id.vendor == PCI_VENDOR_ID_IBM;\r\n}\r\nstatic int acpi_evalf(acpi_handle handle,\r\nint *res, char *method, char *fmt, ...)\r\n{\r\nchar *fmt0 = fmt;\r\nstruct acpi_object_list params;\r\nunion acpi_object in_objs[TPACPI_MAX_ACPI_ARGS];\r\nstruct acpi_buffer result, *resultp;\r\nunion acpi_object out_obj;\r\nacpi_status status;\r\nva_list ap;\r\nchar res_type;\r\nint success;\r\nint quiet;\r\nif (!*fmt) {\r\npr_err("acpi_evalf() called with empty format\n");\r\nreturn 0;\r\n}\r\nif (*fmt == 'q') {\r\nquiet = 1;\r\nfmt++;\r\n} else\r\nquiet = 0;\r\nres_type = *(fmt++);\r\nparams.count = 0;\r\nparams.pointer = &in_objs[0];\r\nva_start(ap, fmt);\r\nwhile (*fmt) {\r\nchar c = *(fmt++);\r\nswitch (c) {\r\ncase 'd':\r\nin_objs[params.count].integer.value = va_arg(ap, int);\r\nin_objs[params.count++].type = ACPI_TYPE_INTEGER;\r\nbreak;\r\ndefault:\r\npr_err("acpi_evalf() called "\r\n"with invalid format character '%c'\n", c);\r\nva_end(ap);\r\nreturn 0;\r\n}\r\n}\r\nva_end(ap);\r\nif (res_type != 'v') {\r\nresult.length = sizeof(out_obj);\r\nresult.pointer = &out_obj;\r\nresultp = &result;\r\n} else\r\nresultp = NULL;\r\nstatus = acpi_evaluate_object(handle, method, &params, resultp);\r\nswitch (res_type) {\r\ncase 'd':\r\nsuccess = (status == AE_OK &&\r\nout_obj.type == ACPI_TYPE_INTEGER);\r\nif (success && res)\r\n*res = out_obj.integer.value;\r\nbreak;\r\ncase 'v':\r\nsuccess = status == AE_OK;\r\nbreak;\r\ndefault:\r\npr_err("acpi_evalf() called "\r\n"with invalid format character '%c'\n", res_type);\r\nreturn 0;\r\n}\r\nif (!success && !quiet)\r\npr_err("acpi_evalf(%s, %s, ...) failed: %s\n",\r\nmethod, fmt0, acpi_format_exception(status));\r\nreturn success;\r\n}\r\nstatic int acpi_ec_read(int i, u8 *p)\r\n{\r\nint v;\r\nif (ecrd_handle) {\r\nif (!acpi_evalf(ecrd_handle, &v, NULL, "dd", i))\r\nreturn 0;\r\n*p = v;\r\n} else {\r\nif (ec_read(i, p) < 0)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int acpi_ec_write(int i, u8 v)\r\n{\r\nif (ecwr_handle) {\r\nif (!acpi_evalf(ecwr_handle, NULL, NULL, "vdd", i, v))\r\nreturn 0;\r\n} else {\r\nif (ec_write(i, v) < 0)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int issue_thinkpad_cmos_command(int cmos_cmd)\r\n{\r\nif (!cmos_handle)\r\nreturn -ENXIO;\r\nif (!acpi_evalf(cmos_handle, NULL, NULL, "vd", cmos_cmd))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void __init drv_acpi_handle_init(const char *name,\r\nacpi_handle *handle, const acpi_handle parent,\r\nchar **paths, const int num_paths)\r\n{\r\nint i;\r\nacpi_status status;\r\nvdbg_printk(TPACPI_DBG_INIT, "trying to locate ACPI handle for %s\n",\r\nname);\r\nfor (i = 0; i < num_paths; i++) {\r\nstatus = acpi_get_handle(parent, paths[i], handle);\r\nif (ACPI_SUCCESS(status)) {\r\ndbg_printk(TPACPI_DBG_INIT,\r\n"Found ACPI handle %s for %s\n",\r\npaths[i], name);\r\nreturn;\r\n}\r\n}\r\nvdbg_printk(TPACPI_DBG_INIT, "ACPI handle for %s not found\n",\r\nname);\r\n*handle = NULL;\r\n}\r\nstatic acpi_status __init tpacpi_acpi_handle_locate_callback(acpi_handle handle,\r\nu32 level, void *context, void **return_value)\r\n{\r\n*(acpi_handle *)return_value = handle;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic void __init tpacpi_acpi_handle_locate(const char *name,\r\nconst char *hid,\r\nacpi_handle *handle)\r\n{\r\nacpi_status status;\r\nacpi_handle device_found;\r\nBUG_ON(!name || !hid || !handle);\r\nvdbg_printk(TPACPI_DBG_INIT,\r\n"trying to locate ACPI handle for %s, using HID %s\n",\r\nname, hid);\r\nmemset(&device_found, 0, sizeof(device_found));\r\nstatus = acpi_get_devices(hid, tpacpi_acpi_handle_locate_callback,\r\n(void *)name, &device_found);\r\n*handle = NULL;\r\nif (ACPI_SUCCESS(status)) {\r\n*handle = device_found;\r\ndbg_printk(TPACPI_DBG_INIT,\r\n"Found ACPI handle for %s\n", name);\r\n} else {\r\nvdbg_printk(TPACPI_DBG_INIT,\r\n"Could not locate an ACPI handle for %s: %s\n",\r\nname, acpi_format_exception(status));\r\n}\r\n}\r\nstatic void dispatch_acpi_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct ibm_struct *ibm = data;\r\nif (tpacpi_lifecycle != TPACPI_LIFE_RUNNING)\r\nreturn;\r\nif (!ibm || !ibm->acpi || !ibm->acpi->notify)\r\nreturn;\r\nibm->acpi->notify(ibm, event);\r\n}\r\nstatic int __init setup_acpi_notify(struct ibm_struct *ibm)\r\n{\r\nacpi_status status;\r\nint rc;\r\nBUG_ON(!ibm->acpi);\r\nif (!*ibm->acpi->handle)\r\nreturn 0;\r\nvdbg_printk(TPACPI_DBG_INIT,\r\n"setting up ACPI notify for %s\n", ibm->name);\r\nrc = acpi_bus_get_device(*ibm->acpi->handle, &ibm->acpi->device);\r\nif (rc < 0) {\r\npr_err("acpi_bus_get_device(%s) failed: %d\n", ibm->name, rc);\r\nreturn -ENODEV;\r\n}\r\nibm->acpi->device->driver_data = ibm;\r\nsprintf(acpi_device_class(ibm->acpi->device), "%s/%s",\r\nTPACPI_ACPI_EVENT_PREFIX,\r\nibm->name);\r\nstatus = acpi_install_notify_handler(*ibm->acpi->handle,\r\nibm->acpi->type, dispatch_acpi_notify, ibm);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_ALREADY_EXISTS) {\r\npr_notice("another device driver is already "\r\n"handling %s events\n", ibm->name);\r\n} else {\r\npr_err("acpi_install_notify_handler(%s) failed: %s\n",\r\nibm->name, acpi_format_exception(status));\r\n}\r\nreturn -ENODEV;\r\n}\r\nibm->flags.acpi_notify_installed = 1;\r\nreturn 0;\r\n}\r\nstatic int __init tpacpi_device_add(struct acpi_device *device)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init register_tpacpi_subdriver(struct ibm_struct *ibm)\r\n{\r\nint rc;\r\ndbg_printk(TPACPI_DBG_INIT,\r\n"registering %s as an ACPI driver\n", ibm->name);\r\nBUG_ON(!ibm->acpi);\r\nibm->acpi->driver = kzalloc(sizeof(struct acpi_driver), GFP_KERNEL);\r\nif (!ibm->acpi->driver) {\r\npr_err("failed to allocate memory for ibm->acpi->driver\n");\r\nreturn -ENOMEM;\r\n}\r\nsprintf(ibm->acpi->driver->name, "%s_%s", TPACPI_NAME, ibm->name);\r\nibm->acpi->driver->ids = ibm->acpi->hid;\r\nibm->acpi->driver->ops.add = &tpacpi_device_add;\r\nrc = acpi_bus_register_driver(ibm->acpi->driver);\r\nif (rc < 0) {\r\npr_err("acpi_bus_register_driver(%s) failed: %d\n",\r\nibm->name, rc);\r\nkfree(ibm->acpi->driver);\r\nibm->acpi->driver = NULL;\r\n} else if (!rc)\r\nibm->flags.acpi_driver_registered = 1;\r\nreturn rc;\r\n}\r\nstatic int dispatch_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct ibm_struct *ibm = m->private;\r\nif (!ibm || !ibm->read)\r\nreturn -EINVAL;\r\nreturn ibm->read(m);\r\n}\r\nstatic int dispatch_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dispatch_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t dispatch_proc_write(struct file *file,\r\nconst char __user *userbuf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct ibm_struct *ibm = PDE_DATA(file_inode(file));\r\nchar *kernbuf;\r\nint ret;\r\nif (!ibm || !ibm->write)\r\nreturn -EINVAL;\r\nif (count > PAGE_SIZE - 2)\r\nreturn -EINVAL;\r\nkernbuf = kmalloc(count + 2, GFP_KERNEL);\r\nif (!kernbuf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kernbuf, userbuf, count)) {\r\nkfree(kernbuf);\r\nreturn -EFAULT;\r\n}\r\nkernbuf[count] = 0;\r\nstrcat(kernbuf, ",");\r\nret = ibm->write(kernbuf);\r\nif (ret == 0)\r\nret = count;\r\nkfree(kernbuf);\r\nreturn ret;\r\n}\r\nstatic char *next_cmd(char **cmds)\r\n{\r\nchar *start = *cmds;\r\nchar *end;\r\nwhile ((end = strchr(start, ',')) && end == start)\r\nstart = end + 1;\r\nif (!end)\r\nreturn NULL;\r\n*end = 0;\r\n*cmds = end + 1;\r\nreturn start;\r\n}\r\nstatic int tpacpi_suspend_handler(struct device *dev)\r\n{\r\nstruct ibm_struct *ibm, *itmp;\r\nlist_for_each_entry_safe(ibm, itmp,\r\n&tpacpi_all_drivers,\r\nall_drivers) {\r\nif (ibm->suspend)\r\n(ibm->suspend)();\r\n}\r\nreturn 0;\r\n}\r\nstatic int tpacpi_resume_handler(struct device *dev)\r\n{\r\nstruct ibm_struct *ibm, *itmp;\r\nlist_for_each_entry_safe(ibm, itmp,\r\n&tpacpi_all_drivers,\r\nall_drivers) {\r\nif (ibm->resume)\r\n(ibm->resume)();\r\n}\r\nreturn 0;\r\n}\r\nstatic void tpacpi_shutdown_handler(struct platform_device *pdev)\r\n{\r\nstruct ibm_struct *ibm, *itmp;\r\nlist_for_each_entry_safe(ibm, itmp,\r\n&tpacpi_all_drivers,\r\nall_drivers) {\r\nif (ibm->shutdown)\r\n(ibm->shutdown)();\r\n}\r\n}\r\nstatic struct attribute_set *create_attr_set(unsigned int max_members,\r\nconst char *name)\r\n{\r\nstruct attribute_set_obj *sobj;\r\nif (max_members == 0)\r\nreturn NULL;\r\nsobj = kzalloc(sizeof(struct attribute_set_obj) +\r\nmax_members * sizeof(struct attribute *),\r\nGFP_KERNEL);\r\nif (!sobj)\r\nreturn NULL;\r\nsobj->s.max_members = max_members;\r\nsobj->s.group.attrs = &sobj->a;\r\nsobj->s.group.name = name;\r\nreturn &sobj->s;\r\n}\r\nstatic int add_to_attr_set(struct attribute_set *s, struct attribute *attr)\r\n{\r\nif (!s || !attr)\r\nreturn -EINVAL;\r\nif (s->members >= s->max_members)\r\nreturn -ENOMEM;\r\ns->group.attrs[s->members] = attr;\r\ns->members++;\r\nreturn 0;\r\n}\r\nstatic int add_many_to_attr_set(struct attribute_set *s,\r\nstruct attribute **attr,\r\nunsigned int count)\r\n{\r\nint i, res;\r\nfor (i = 0; i < count; i++) {\r\nres = add_to_attr_set(s, attr[i]);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic void delete_attr_set(struct attribute_set *s, struct kobject *kobj)\r\n{\r\nsysfs_remove_group(kobj, &s->group);\r\ndestroy_attr_set(s);\r\n}\r\nstatic int parse_strtoul(const char *buf,\r\nunsigned long max, unsigned long *value)\r\n{\r\nchar *endp;\r\n*value = simple_strtoul(skip_spaces(buf), &endp, 0);\r\nendp = skip_spaces(endp);\r\nif (*endp || *value > max)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void tpacpi_disable_brightness_delay(void)\r\n{\r\nif (acpi_evalf(hkey_handle, NULL, "PWMS", "qvd", 0))\r\npr_notice("ACPI backlight control delay disabled\n");\r\n}\r\nstatic void printk_deprecated_attribute(const char * const what,\r\nconst char * const details)\r\n{\r\ntpacpi_log_usertask("deprecated sysfs attribute");\r\npr_warn("WARNING: sysfs attribute %s is deprecated and "\r\n"will be removed. %s\n",\r\nwhat, details);\r\n}\r\nstatic int tpacpi_rfk_update_swstate(const struct tpacpi_rfk *tp_rfk)\r\n{\r\nint status;\r\nif (!tp_rfk)\r\nreturn -ENODEV;\r\nstatus = (tp_rfk->ops->get_status)();\r\nif (status < 0)\r\nreturn status;\r\nrfkill_set_sw_state(tp_rfk->rfkill,\r\n(status == TPACPI_RFK_RADIO_OFF));\r\nreturn status;\r\n}\r\nstatic void tpacpi_rfk_update_swstate_all(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < TPACPI_RFK_SW_MAX; i++)\r\ntpacpi_rfk_update_swstate(tpacpi_rfkill_switches[i]);\r\n}\r\nstatic void tpacpi_rfk_update_hwblock_state(bool blocked)\r\n{\r\nunsigned int i;\r\nstruct tpacpi_rfk *tp_rfk;\r\nfor (i = 0; i < TPACPI_RFK_SW_MAX; i++) {\r\ntp_rfk = tpacpi_rfkill_switches[i];\r\nif (tp_rfk) {\r\nif (rfkill_set_hw_state(tp_rfk->rfkill,\r\nblocked)) {\r\n}\r\n}\r\n}\r\n}\r\nstatic bool tpacpi_rfk_check_hwblock_state(void)\r\n{\r\nint res = hotkey_get_wlsw();\r\nint hw_blocked;\r\nif (res < 0)\r\nreturn false;\r\nhw_blocked = (res == TPACPI_RFK_RADIO_OFF);\r\ntpacpi_rfk_update_hwblock_state(hw_blocked);\r\nreturn hw_blocked;\r\n}\r\nstatic int tpacpi_rfk_hook_set_block(void *data, bool blocked)\r\n{\r\nstruct tpacpi_rfk *tp_rfk = data;\r\nint res;\r\ndbg_printk(TPACPI_DBG_RFKILL,\r\n"request to change radio state to %s\n",\r\nblocked ? "blocked" : "unblocked");\r\nres = (tp_rfk->ops->set_status)(blocked ?\r\nTPACPI_RFK_RADIO_OFF : TPACPI_RFK_RADIO_ON);\r\ntpacpi_rfk_update_swstate(tp_rfk);\r\nreturn (res < 0) ? res : 0;\r\n}\r\nstatic int __init tpacpi_new_rfkill(const enum tpacpi_rfk_id id,\r\nconst struct tpacpi_rfk_ops *tp_rfkops,\r\nconst enum rfkill_type rfktype,\r\nconst char *name,\r\nconst bool set_default)\r\n{\r\nstruct tpacpi_rfk *atp_rfk;\r\nint res;\r\nbool sw_state = false;\r\nbool hw_state;\r\nint sw_status;\r\nBUG_ON(id >= TPACPI_RFK_SW_MAX || tpacpi_rfkill_switches[id]);\r\natp_rfk = kzalloc(sizeof(struct tpacpi_rfk), GFP_KERNEL);\r\nif (atp_rfk)\r\natp_rfk->rfkill = rfkill_alloc(name,\r\n&tpacpi_pdev->dev,\r\nrfktype,\r\n&tpacpi_rfk_rfkill_ops,\r\natp_rfk);\r\nif (!atp_rfk || !atp_rfk->rfkill) {\r\npr_err("failed to allocate memory for rfkill class\n");\r\nkfree(atp_rfk);\r\nreturn -ENOMEM;\r\n}\r\natp_rfk->id = id;\r\natp_rfk->ops = tp_rfkops;\r\nsw_status = (tp_rfkops->get_status)();\r\nif (sw_status < 0) {\r\npr_err("failed to read initial state for %s, error %d\n",\r\nname, sw_status);\r\n} else {\r\nsw_state = (sw_status == TPACPI_RFK_RADIO_OFF);\r\nif (set_default) {\r\nrfkill_init_sw_state(atp_rfk->rfkill, sw_state);\r\n}\r\n}\r\nhw_state = tpacpi_rfk_check_hwblock_state();\r\nrfkill_set_hw_state(atp_rfk->rfkill, hw_state);\r\nres = rfkill_register(atp_rfk->rfkill);\r\nif (res < 0) {\r\npr_err("failed to register %s rfkill switch: %d\n", name, res);\r\nrfkill_destroy(atp_rfk->rfkill);\r\nkfree(atp_rfk);\r\nreturn res;\r\n}\r\ntpacpi_rfkill_switches[id] = atp_rfk;\r\npr_info("rfkill switch %s: radio is %sblocked\n",\r\nname, (sw_state || hw_state) ? "" : "un");\r\nreturn 0;\r\n}\r\nstatic void tpacpi_destroy_rfkill(const enum tpacpi_rfk_id id)\r\n{\r\nstruct tpacpi_rfk *tp_rfk;\r\nBUG_ON(id >= TPACPI_RFK_SW_MAX);\r\ntp_rfk = tpacpi_rfkill_switches[id];\r\nif (tp_rfk) {\r\nrfkill_unregister(tp_rfk->rfkill);\r\nrfkill_destroy(tp_rfk->rfkill);\r\ntpacpi_rfkill_switches[id] = NULL;\r\nkfree(tp_rfk);\r\n}\r\n}\r\nstatic void printk_deprecated_rfkill_attribute(const char * const what)\r\n{\r\nprintk_deprecated_attribute(what,\r\n"Please switch to generic rfkill before year 2010");\r\n}\r\nstatic ssize_t tpacpi_rfk_sysfs_enable_show(const enum tpacpi_rfk_id id,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint status;\r\nprintk_deprecated_rfkill_attribute(attr->attr.name);\r\nif (tpacpi_rfk_check_hwblock_state()) {\r\nstatus = TPACPI_RFK_RADIO_OFF;\r\n} else {\r\nstatus = tpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\n(status == TPACPI_RFK_RADIO_ON) ? 1 : 0);\r\n}\r\nstatic ssize_t tpacpi_rfk_sysfs_enable_store(const enum tpacpi_rfk_id id,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nint res;\r\nprintk_deprecated_rfkill_attribute(attr->attr.name);\r\nif (parse_strtoul(buf, 1, &t))\r\nreturn -EINVAL;\r\ntpacpi_disclose_usertask(attr->attr.name, "set to %ld\n", t);\r\nif (tpacpi_rfk_check_hwblock_state() && !!t)\r\nreturn -EPERM;\r\nres = tpacpi_rfkill_switches[id]->ops->set_status((!!t) ?\r\nTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF);\r\ntpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\r\nreturn (res < 0) ? res : count;\r\n}\r\nstatic int tpacpi_rfk_procfs_read(const enum tpacpi_rfk_id id, struct seq_file *m)\r\n{\r\nif (id >= TPACPI_RFK_SW_MAX)\r\nseq_printf(m, "status:\t\tnot supported\n");\r\nelse {\r\nint status;\r\nif (tpacpi_rfk_check_hwblock_state()) {\r\nstatus = TPACPI_RFK_RADIO_OFF;\r\n} else {\r\nstatus = tpacpi_rfk_update_swstate(\r\ntpacpi_rfkill_switches[id]);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nseq_printf(m, "status:\t\t%s\n",\r\n(status == TPACPI_RFK_RADIO_ON) ?\r\n"enabled" : "disabled");\r\nseq_printf(m, "commands:\tenable, disable\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int tpacpi_rfk_procfs_write(const enum tpacpi_rfk_id id, char *buf)\r\n{\r\nchar *cmd;\r\nint status = -1;\r\nint res = 0;\r\nif (id >= TPACPI_RFK_SW_MAX)\r\nreturn -ENODEV;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (strlencmp(cmd, "enable") == 0)\r\nstatus = TPACPI_RFK_RADIO_ON;\r\nelse if (strlencmp(cmd, "disable") == 0)\r\nstatus = TPACPI_RFK_RADIO_OFF;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (status != -1) {\r\ntpacpi_disclose_usertask("procfs", "attempt to %s %s\n",\r\n(status == TPACPI_RFK_RADIO_ON) ?\r\n"enable" : "disable",\r\ntpacpi_rfkill_names[id]);\r\nres = (tpacpi_rfkill_switches[id]->ops->set_status)(status);\r\ntpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\r\n}\r\nreturn res;\r\n}\r\nstatic ssize_t tpacpi_driver_interface_version_show(\r\nstruct device_driver *drv,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08x\n", TPACPI_SYSFS_VERSION);\r\n}\r\nstatic ssize_t tpacpi_driver_debug_show(struct device_driver *drv,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04x\n", dbg_level);\r\n}\r\nstatic ssize_t tpacpi_driver_debug_store(struct device_driver *drv,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nif (parse_strtoul(buf, 0xffff, &t))\r\nreturn -EINVAL;\r\ndbg_level = t;\r\nreturn count;\r\n}\r\nstatic ssize_t tpacpi_driver_version_show(struct device_driver *drv,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s v%s\n",\r\nTPACPI_DESC, TPACPI_VERSION);\r\n}\r\nstatic ssize_t tpacpi_driver_wlsw_emulstate_show(struct device_driver *drv,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", !!tpacpi_wlsw_emulstate);\r\n}\r\nstatic ssize_t tpacpi_driver_wlsw_emulstate_store(struct device_driver *drv,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nif (parse_strtoul(buf, 1, &t))\r\nreturn -EINVAL;\r\nif (tpacpi_wlsw_emulstate != !!t) {\r\ntpacpi_wlsw_emulstate = !!t;\r\ntpacpi_rfk_update_hwblock_state(!t);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t tpacpi_driver_bluetooth_emulstate_show(\r\nstruct device_driver *drv,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", !!tpacpi_bluetooth_emulstate);\r\n}\r\nstatic ssize_t tpacpi_driver_bluetooth_emulstate_store(\r\nstruct device_driver *drv,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nif (parse_strtoul(buf, 1, &t))\r\nreturn -EINVAL;\r\ntpacpi_bluetooth_emulstate = !!t;\r\nreturn count;\r\n}\r\nstatic ssize_t tpacpi_driver_wwan_emulstate_show(\r\nstruct device_driver *drv,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", !!tpacpi_wwan_emulstate);\r\n}\r\nstatic ssize_t tpacpi_driver_wwan_emulstate_store(\r\nstruct device_driver *drv,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nif (parse_strtoul(buf, 1, &t))\r\nreturn -EINVAL;\r\ntpacpi_wwan_emulstate = !!t;\r\nreturn count;\r\n}\r\nstatic ssize_t tpacpi_driver_uwb_emulstate_show(\r\nstruct device_driver *drv,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", !!tpacpi_uwb_emulstate);\r\n}\r\nstatic ssize_t tpacpi_driver_uwb_emulstate_store(\r\nstruct device_driver *drv,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nif (parse_strtoul(buf, 1, &t))\r\nreturn -EINVAL;\r\ntpacpi_uwb_emulstate = !!t;\r\nreturn count;\r\n}\r\nstatic int __init tpacpi_create_driver_attributes(struct device_driver *drv)\r\n{\r\nint i, res;\r\ni = 0;\r\nres = 0;\r\nwhile (!res && i < ARRAY_SIZE(tpacpi_driver_attributes)) {\r\nres = driver_create_file(drv, tpacpi_driver_attributes[i]);\r\ni++;\r\n}\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (!res && dbg_wlswemul)\r\nres = driver_create_file(drv, &driver_attr_wlsw_emulstate);\r\nif (!res && dbg_bluetoothemul)\r\nres = driver_create_file(drv, &driver_attr_bluetooth_emulstate);\r\nif (!res && dbg_wwanemul)\r\nres = driver_create_file(drv, &driver_attr_wwan_emulstate);\r\nif (!res && dbg_uwbemul)\r\nres = driver_create_file(drv, &driver_attr_uwb_emulstate);\r\n#endif\r\nreturn res;\r\n}\r\nstatic void tpacpi_remove_driver_attributes(struct device_driver *drv)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tpacpi_driver_attributes); i++)\r\ndriver_remove_file(drv, tpacpi_driver_attributes[i]);\r\n#ifdef THINKPAD_ACPI_DEBUGFACILITIES\r\ndriver_remove_file(drv, &driver_attr_wlsw_emulstate);\r\ndriver_remove_file(drv, &driver_attr_bluetooth_emulstate);\r\ndriver_remove_file(drv, &driver_attr_wwan_emulstate);\r\ndriver_remove_file(drv, &driver_attr_uwb_emulstate);\r\n#endif\r\n}\r\nstatic void __init tpacpi_check_outdated_fw(void)\r\n{\r\nunsigned long fwvers;\r\nu16 ec_version, bios_version;\r\nfwvers = tpacpi_check_quirks(tpacpi_bios_version_qtable,\r\nARRAY_SIZE(tpacpi_bios_version_qtable));\r\nif (!fwvers)\r\nreturn;\r\nbios_version = fwvers & 0xffffU;\r\nec_version = (fwvers >> 16) & 0xffffU;\r\nif ((bios_version > thinkpad_id.bios_release) ||\r\n(ec_version > thinkpad_id.ec_release &&\r\nec_version != TPACPI_MATCH_ANY)) {\r\npr_warn("WARNING: Outdated ThinkPad BIOS/EC firmware\n");\r\npr_warn("WARNING: This firmware may be missing critical bug "\r\n"fixes and/or important features\n");\r\n}\r\n}\r\nstatic bool __init tpacpi_is_fw_known(void)\r\n{\r\nreturn tpacpi_check_quirks(tpacpi_bios_version_qtable,\r\nARRAY_SIZE(tpacpi_bios_version_qtable)) != 0;\r\n}\r\nstatic int thinkpad_acpi_driver_read(struct seq_file *m)\r\n{\r\nseq_printf(m, "driver:\t\t%s\n", TPACPI_DESC);\r\nseq_printf(m, "version:\t%s\n", TPACPI_VERSION);\r\nreturn 0;\r\n}\r\nstatic int hotkey_get_wlsw(void)\r\n{\r\nint status;\r\nif (!tp_features.hotkey_wlsw)\r\nreturn -ENODEV;\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_wlswemul)\r\nreturn (tpacpi_wlsw_emulstate) ?\r\nTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\r\n#endif\r\nif (!acpi_evalf(hkey_handle, &status, "WLSW", "d"))\r\nreturn -EIO;\r\nreturn (status) ? TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\r\n}\r\nstatic int hotkey_get_tablet_mode(int *status)\r\n{\r\nint s;\r\nif (!acpi_evalf(hkey_handle, &s, "MHKG", "d"))\r\nreturn -EIO;\r\n*status = ((s & TP_HOTKEY_TABLET_MASK) != 0);\r\nreturn 0;\r\n}\r\nstatic int hotkey_mask_get(void)\r\n{\r\nif (tp_features.hotkey_mask) {\r\nu32 m = 0;\r\nif (!acpi_evalf(hkey_handle, &m, "DHKN", "d"))\r\nreturn -EIO;\r\nhotkey_acpi_mask = m;\r\n} else {\r\nhotkey_acpi_mask = hotkey_all_mask;\r\n}\r\nhotkey_user_mask &= (hotkey_acpi_mask | hotkey_source_mask);\r\nreturn 0;\r\n}\r\nvoid static hotkey_mask_warn_incomplete_mask(void)\r\n{\r\nconst u32 wantedmask = hotkey_driver_mask &\r\n~(hotkey_acpi_mask | hotkey_source_mask) &\r\n(hotkey_all_mask | TPACPI_HKEY_NVRAM_KNOWN_MASK);\r\nif (wantedmask)\r\npr_notice("required events 0x%08x not enabled!\n", wantedmask);\r\n}\r\nstatic int hotkey_mask_set(u32 mask)\r\n{\r\nint i;\r\nint rc = 0;\r\nconst u32 fwmask = mask & ~hotkey_source_mask;\r\nif (tp_features.hotkey_mask) {\r\nfor (i = 0; i < 32; i++) {\r\nif (!acpi_evalf(hkey_handle,\r\nNULL, "MHKM", "vdd", i + 1,\r\n!!(mask & (1 << i)))) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!hotkey_mask_get() && !rc && (fwmask & ~hotkey_acpi_mask)) {\r\npr_notice("asked for hotkey mask 0x%08x, but "\r\n"firmware forced it to 0x%08x\n",\r\nfwmask, hotkey_acpi_mask);\r\n}\r\nif (tpacpi_lifecycle != TPACPI_LIFE_EXITING)\r\nhotkey_mask_warn_incomplete_mask();\r\nreturn rc;\r\n}\r\nstatic int hotkey_user_mask_set(const u32 mask)\r\n{\r\nint rc;\r\nif (!tp_warned.hotkey_mask_ff &&\r\n(mask == 0xffff || mask == 0xffffff ||\r\nmask == 0xffffffff)) {\r\ntp_warned.hotkey_mask_ff = 1;\r\npr_notice("setting the hotkey mask to 0x%08x is likely "\r\n"not the best way to go about it\n", mask);\r\npr_notice("please consider using the driver defaults, "\r\n"and refer to up-to-date thinkpad-acpi "\r\n"documentation\n");\r\n}\r\nrc = hotkey_mask_set((mask | hotkey_driver_mask) & ~hotkey_source_mask);\r\nhotkey_user_mask = mask & (hotkey_acpi_mask | hotkey_source_mask);\r\nreturn rc;\r\n}\r\nstatic int tpacpi_hotkey_driver_mask_set(const u32 mask)\r\n{\r\nint rc;\r\nif (!tp_features.hotkey) {\r\nhotkey_driver_mask = mask;\r\nreturn 0;\r\n}\r\nmutex_lock(&hotkey_mutex);\r\nHOTKEY_CONFIG_CRITICAL_START\r\nhotkey_driver_mask = mask;\r\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\r\nhotkey_source_mask |= (mask & ~hotkey_all_mask);\r\n#endif\r\nHOTKEY_CONFIG_CRITICAL_END\r\nrc = hotkey_mask_set((hotkey_acpi_mask | hotkey_driver_mask) &\r\n~hotkey_source_mask);\r\nhotkey_poll_setup(true);\r\nmutex_unlock(&hotkey_mutex);\r\nreturn rc;\r\n}\r\nstatic int hotkey_status_get(int *status)\r\n{\r\nif (!acpi_evalf(hkey_handle, status, "DHKC", "d"))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int hotkey_status_set(bool enable)\r\n{\r\nif (!acpi_evalf(hkey_handle, NULL, "MHKC", "vd", enable ? 1 : 0))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void tpacpi_input_send_tabletsw(void)\r\n{\r\nint state;\r\nif (tp_features.hotkey_tablet &&\r\n!hotkey_get_tablet_mode(&state)) {\r\nmutex_lock(&tpacpi_inputdev_send_mutex);\r\ninput_report_switch(tpacpi_inputdev,\r\nSW_TABLET_MODE, !!state);\r\ninput_sync(tpacpi_inputdev);\r\nmutex_unlock(&tpacpi_inputdev_send_mutex);\r\n}\r\n}\r\nstatic void tpacpi_input_send_key(const unsigned int scancode)\r\n{\r\nconst unsigned int keycode = hotkey_keycode_map[scancode];\r\nif (keycode != KEY_RESERVED) {\r\nmutex_lock(&tpacpi_inputdev_send_mutex);\r\ninput_event(tpacpi_inputdev, EV_MSC, MSC_SCAN, scancode);\r\ninput_report_key(tpacpi_inputdev, keycode, 1);\r\ninput_sync(tpacpi_inputdev);\r\ninput_event(tpacpi_inputdev, EV_MSC, MSC_SCAN, scancode);\r\ninput_report_key(tpacpi_inputdev, keycode, 0);\r\ninput_sync(tpacpi_inputdev);\r\nmutex_unlock(&tpacpi_inputdev_send_mutex);\r\n}\r\n}\r\nstatic void tpacpi_input_send_key_masked(const unsigned int scancode)\r\n{\r\nhotkey_driver_event(scancode);\r\nif (hotkey_user_mask & (1 << scancode))\r\ntpacpi_input_send_key(scancode);\r\n}\r\nstatic void tpacpi_hotkey_send_key(unsigned int scancode)\r\n{\r\ntpacpi_input_send_key_masked(scancode);\r\nif (hotkey_report_mode < 2) {\r\nacpi_bus_generate_proc_event(ibm_hotkey_acpidriver.device,\r\n0x80, TP_HKEY_EV_HOTKEY_BASE + scancode);\r\n}\r\n}\r\nstatic void hotkey_read_nvram(struct tp_nvram_state *n, const u32 m)\r\n{\r\nu8 d;\r\nif (m & TP_NVRAM_HKEY_GROUP_HK2) {\r\nd = nvram_read_byte(TP_NVRAM_ADDR_HK2);\r\nn->thinkpad_toggle = !!(d & TP_NVRAM_MASK_HKT_THINKPAD);\r\nn->zoom_toggle = !!(d & TP_NVRAM_MASK_HKT_ZOOM);\r\nn->display_toggle = !!(d & TP_NVRAM_MASK_HKT_DISPLAY);\r\nn->hibernate_toggle = !!(d & TP_NVRAM_MASK_HKT_HIBERNATE);\r\n}\r\nif (m & TP_ACPI_HKEY_THNKLGHT_MASK) {\r\nd = nvram_read_byte(TP_NVRAM_ADDR_THINKLIGHT);\r\nn->thinklight_toggle = !!(d & TP_NVRAM_MASK_THINKLIGHT);\r\n}\r\nif (m & TP_ACPI_HKEY_DISPXPAND_MASK) {\r\nd = nvram_read_byte(TP_NVRAM_ADDR_VIDEO);\r\nn->displayexp_toggle =\r\n!!(d & TP_NVRAM_MASK_HKT_DISPEXPND);\r\n}\r\nif (m & TP_NVRAM_HKEY_GROUP_BRIGHTNESS) {\r\nd = nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS);\r\nn->brightness_level = (d & TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\r\n>> TP_NVRAM_POS_LEVEL_BRIGHTNESS;\r\nn->brightness_toggle =\r\n!!(d & TP_NVRAM_MASK_HKT_BRIGHTNESS);\r\n}\r\nif (m & TP_NVRAM_HKEY_GROUP_VOLUME) {\r\nd = nvram_read_byte(TP_NVRAM_ADDR_MIXER);\r\nn->volume_level = (d & TP_NVRAM_MASK_LEVEL_VOLUME)\r\n>> TP_NVRAM_POS_LEVEL_VOLUME;\r\nn->mute = !!(d & TP_NVRAM_MASK_MUTE);\r\nn->volume_toggle = !!(d & TP_NVRAM_MASK_HKT_VOLUME);\r\n}\r\n}\r\nvoid issue_volchange(const unsigned int oldvol,\r\nconst unsigned int newvol)\r\n{\r\nunsigned int i = oldvol;\r\nwhile (i > newvol) {\r\nTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEDOWN);\r\ni--;\r\n}\r\nwhile (i < newvol) {\r\nTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEUP);\r\ni++;\r\n}\r\n}\r\nvoid issue_brightnesschange(const unsigned int oldbrt,\r\nconst unsigned int newbrt)\r\n{\r\nunsigned int i = oldbrt;\r\nwhile (i > newbrt) {\r\nTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNEND);\r\ni--;\r\n}\r\nwhile (i < newbrt) {\r\nTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNHOME);\r\ni++;\r\n}\r\n}\r\nstatic int hotkey_kthread(void *data)\r\n{\r\nstruct tp_nvram_state s[2];\r\nu32 poll_mask, event_mask;\r\nunsigned int si, so;\r\nunsigned long t;\r\nunsigned int change_detector;\r\nunsigned int poll_freq;\r\nbool was_frozen;\r\nif (tpacpi_lifecycle == TPACPI_LIFE_EXITING)\r\ngoto exit;\r\nset_freezable();\r\nso = 0;\r\nsi = 1;\r\nt = 0;\r\nmutex_lock(&hotkey_thread_data_mutex);\r\nchange_detector = hotkey_config_change;\r\npoll_mask = hotkey_source_mask;\r\nevent_mask = hotkey_source_mask &\r\n(hotkey_driver_mask | hotkey_user_mask);\r\npoll_freq = hotkey_poll_freq;\r\nmutex_unlock(&hotkey_thread_data_mutex);\r\nhotkey_read_nvram(&s[so], poll_mask);\r\nwhile (!kthread_should_stop()) {\r\nif (t == 0) {\r\nif (likely(poll_freq))\r\nt = 1000/poll_freq;\r\nelse\r\nt = 100;\r\n}\r\nt = msleep_interruptible(t);\r\nif (unlikely(kthread_freezable_should_stop(&was_frozen)))\r\nbreak;\r\nif (t > 0 && !was_frozen)\r\ncontinue;\r\nmutex_lock(&hotkey_thread_data_mutex);\r\nif (was_frozen || hotkey_config_change != change_detector) {\r\nsi = so;\r\nt = 0;\r\nchange_detector = hotkey_config_change;\r\n}\r\npoll_mask = hotkey_source_mask;\r\nevent_mask = hotkey_source_mask &\r\n(hotkey_driver_mask | hotkey_user_mask);\r\npoll_freq = hotkey_poll_freq;\r\nmutex_unlock(&hotkey_thread_data_mutex);\r\nif (likely(poll_mask)) {\r\nhotkey_read_nvram(&s[si], poll_mask);\r\nif (likely(si != so)) {\r\nhotkey_compare_and_issue_event(&s[so], &s[si],\r\nevent_mask);\r\n}\r\n}\r\nso = si;\r\nsi ^= 1;\r\n}\r\nexit:\r\nreturn 0;\r\n}\r\nstatic void hotkey_poll_stop_sync(void)\r\n{\r\nif (tpacpi_hotkey_task) {\r\nkthread_stop(tpacpi_hotkey_task);\r\ntpacpi_hotkey_task = NULL;\r\n}\r\n}\r\nstatic void hotkey_poll_setup(const bool may_warn)\r\n{\r\nconst u32 poll_driver_mask = hotkey_driver_mask & hotkey_source_mask;\r\nconst u32 poll_user_mask = hotkey_user_mask & hotkey_source_mask;\r\nif (hotkey_poll_freq > 0 &&\r\n(poll_driver_mask ||\r\n(poll_user_mask && tpacpi_inputdev->users > 0))) {\r\nif (!tpacpi_hotkey_task) {\r\ntpacpi_hotkey_task = kthread_run(hotkey_kthread,\r\nNULL, TPACPI_NVRAM_KTHREAD_NAME);\r\nif (IS_ERR(tpacpi_hotkey_task)) {\r\ntpacpi_hotkey_task = NULL;\r\npr_err("could not create kernel thread "\r\n"for hotkey polling\n");\r\n}\r\n}\r\n} else {\r\nhotkey_poll_stop_sync();\r\nif (may_warn && (poll_driver_mask || poll_user_mask) &&\r\nhotkey_poll_freq == 0) {\r\npr_notice("hot keys 0x%08x and/or events 0x%08x "\r\n"require polling, which is currently "\r\n"disabled\n",\r\npoll_user_mask, poll_driver_mask);\r\n}\r\n}\r\n}\r\nstatic void hotkey_poll_setup_safe(const bool may_warn)\r\n{\r\nmutex_lock(&hotkey_mutex);\r\nhotkey_poll_setup(may_warn);\r\nmutex_unlock(&hotkey_mutex);\r\n}\r\nstatic void hotkey_poll_set_freq(unsigned int freq)\r\n{\r\nif (!freq)\r\nhotkey_poll_stop_sync();\r\nhotkey_poll_freq = freq;\r\n}\r\nstatic void hotkey_poll_setup(const bool __unused)\r\n{\r\n}\r\nstatic void hotkey_poll_setup_safe(const bool __unused)\r\n{\r\n}\r\nstatic int hotkey_inputdev_open(struct input_dev *dev)\r\n{\r\nswitch (tpacpi_lifecycle) {\r\ncase TPACPI_LIFE_INIT:\r\ncase TPACPI_LIFE_RUNNING:\r\nhotkey_poll_setup_safe(false);\r\nreturn 0;\r\ncase TPACPI_LIFE_EXITING:\r\nreturn -EBUSY;\r\n}\r\nBUG();\r\nreturn -EBUSY;\r\n}\r\nstatic void hotkey_inputdev_close(struct input_dev *dev)\r\n{\r\nif (tpacpi_lifecycle != TPACPI_LIFE_EXITING &&\r\n!(hotkey_source_mask & hotkey_driver_mask))\r\nhotkey_poll_setup_safe(false);\r\n}\r\nstatic ssize_t hotkey_enable_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint res, status;\r\nprintk_deprecated_attribute("hotkey_enable",\r\n"Hotkey reporting is always enabled");\r\nres = hotkey_status_get(&status);\r\nif (res)\r\nreturn res;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", status);\r\n}\r\nstatic ssize_t hotkey_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nprintk_deprecated_attribute("hotkey_enable",\r\n"Hotkeys can be disabled through hotkey_mask");\r\nif (parse_strtoul(buf, 1, &t))\r\nreturn -EINVAL;\r\nif (t == 0)\r\nreturn -EPERM;\r\nreturn count;\r\n}\r\nstatic ssize_t hotkey_mask_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08x\n", hotkey_user_mask);\r\n}\r\nstatic ssize_t hotkey_mask_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nint res;\r\nif (parse_strtoul(buf, 0xffffffffUL, &t))\r\nreturn -EINVAL;\r\nif (mutex_lock_killable(&hotkey_mutex))\r\nreturn -ERESTARTSYS;\r\nres = hotkey_user_mask_set(t);\r\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\r\nhotkey_poll_setup(true);\r\n#endif\r\nmutex_unlock(&hotkey_mutex);\r\ntpacpi_disclose_usertask("hotkey_mask", "set to 0x%08lx\n", t);\r\nreturn (res) ? res : count;\r\n}\r\nstatic ssize_t hotkey_bios_enabled_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t hotkey_bios_mask_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nprintk_deprecated_attribute("hotkey_bios_mask",\r\n"This attribute is useless.");\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08x\n", hotkey_orig_mask);\r\n}\r\nstatic ssize_t hotkey_all_mask_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08x\n",\r\nhotkey_all_mask | hotkey_source_mask);\r\n}\r\nstatic ssize_t hotkey_recommended_mask_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08x\n",\r\n(hotkey_all_mask | hotkey_source_mask)\r\n& ~hotkey_reserved_mask);\r\n}\r\nstatic ssize_t hotkey_source_mask_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08x\n", hotkey_source_mask);\r\n}\r\nstatic ssize_t hotkey_source_mask_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nu32 r_ev;\r\nint rc;\r\nif (parse_strtoul(buf, 0xffffffffUL, &t) ||\r\n((t & ~TPACPI_HKEY_NVRAM_KNOWN_MASK) != 0))\r\nreturn -EINVAL;\r\nif (mutex_lock_killable(&hotkey_mutex))\r\nreturn -ERESTARTSYS;\r\nHOTKEY_CONFIG_CRITICAL_START\r\nhotkey_source_mask = t;\r\nHOTKEY_CONFIG_CRITICAL_END\r\nrc = hotkey_mask_set((hotkey_user_mask | hotkey_driver_mask) &\r\n~hotkey_source_mask);\r\nhotkey_poll_setup(true);\r\nr_ev = hotkey_driver_mask & ~(hotkey_acpi_mask & hotkey_all_mask)\r\n& ~hotkey_source_mask & TPACPI_HKEY_NVRAM_KNOWN_MASK;\r\nmutex_unlock(&hotkey_mutex);\r\nif (rc < 0)\r\npr_err("hotkey_source_mask: "\r\n"failed to update the firmware event mask!\n");\r\nif (r_ev)\r\npr_notice("hotkey_source_mask: "\r\n"some important events were disabled: 0x%04x\n",\r\nr_ev);\r\ntpacpi_disclose_usertask("hotkey_source_mask", "set to 0x%08lx\n", t);\r\nreturn (rc < 0) ? rc : count;\r\n}\r\nstatic ssize_t hotkey_poll_freq_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", hotkey_poll_freq);\r\n}\r\nstatic ssize_t hotkey_poll_freq_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nif (parse_strtoul(buf, 25, &t))\r\nreturn -EINVAL;\r\nif (mutex_lock_killable(&hotkey_mutex))\r\nreturn -ERESTARTSYS;\r\nhotkey_poll_set_freq(t);\r\nhotkey_poll_setup(true);\r\nmutex_unlock(&hotkey_mutex);\r\ntpacpi_disclose_usertask("hotkey_poll_freq", "set to %lu\n", t);\r\nreturn count;\r\n}\r\nstatic ssize_t hotkey_radio_sw_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint res;\r\nres = hotkey_get_wlsw();\r\nif (res < 0)\r\nreturn res;\r\ntpacpi_rfk_update_hwblock_state((res == TPACPI_RFK_RADIO_OFF));\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\n(res == TPACPI_RFK_RADIO_OFF) ? 0 : 1);\r\n}\r\nstatic void hotkey_radio_sw_notify_change(void)\r\n{\r\nif (tp_features.hotkey_wlsw)\r\nsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\r\n"hotkey_radio_sw");\r\n}\r\nstatic ssize_t hotkey_tablet_mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint res, s;\r\nres = hotkey_get_tablet_mode(&s);\r\nif (res < 0)\r\nreturn res;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", !!s);\r\n}\r\nstatic void hotkey_tablet_mode_notify_change(void)\r\n{\r\nif (tp_features.hotkey_tablet)\r\nsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\r\n"hotkey_tablet_mode");\r\n}\r\nstatic ssize_t hotkey_report_mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\n(hotkey_report_mode != 0) ? hotkey_report_mode : 1);\r\n}\r\nstatic ssize_t hotkey_wakeup_reason_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", hotkey_wakeup_reason);\r\n}\r\nstatic void hotkey_wakeup_reason_notify_change(void)\r\n{\r\nsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\r\n"wakeup_reason");\r\n}\r\nstatic ssize_t hotkey_wakeup_hotunplug_complete_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", hotkey_autosleep_ack);\r\n}\r\nstatic void hotkey_wakeup_hotunplug_complete_notify_change(void)\r\n{\r\nsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\r\n"wakeup_hotunplug_complete");\r\n}\r\nstatic void tpacpi_send_radiosw_update(void)\r\n{\r\nint wlsw;\r\nwlsw = hotkey_get_wlsw();\r\nif (wlsw == TPACPI_RFK_RADIO_OFF)\r\ntpacpi_rfk_update_hwblock_state(true);\r\ntpacpi_rfk_update_swstate_all();\r\nif (wlsw == TPACPI_RFK_RADIO_ON)\r\ntpacpi_rfk_update_hwblock_state(false);\r\nif (!(wlsw < 0)) {\r\nmutex_lock(&tpacpi_inputdev_send_mutex);\r\ninput_report_switch(tpacpi_inputdev,\r\nSW_RFKILL_ALL, (wlsw > 0));\r\ninput_sync(tpacpi_inputdev);\r\nmutex_unlock(&tpacpi_inputdev_send_mutex);\r\n}\r\nhotkey_radio_sw_notify_change();\r\n}\r\nstatic void hotkey_exit(void)\r\n{\r\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\r\nmutex_lock(&hotkey_mutex);\r\nhotkey_poll_stop_sync();\r\nmutex_unlock(&hotkey_mutex);\r\n#endif\r\nif (hotkey_dev_attributes)\r\ndelete_attr_set(hotkey_dev_attributes, &tpacpi_pdev->dev.kobj);\r\ndbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_HKEY,\r\n"restoring original HKEY status and mask\n");\r\nif (((tp_features.hotkey_mask &&\r\nhotkey_mask_set(hotkey_orig_mask)) |\r\nhotkey_status_set(false)) != 0)\r\npr_err("failed to restore hot key mask "\r\n"to BIOS defaults\n");\r\n}\r\nstatic void __init hotkey_unmap(const unsigned int scancode)\r\n{\r\nif (hotkey_keycode_map[scancode] != KEY_RESERVED) {\r\nclear_bit(hotkey_keycode_map[scancode],\r\ntpacpi_inputdev->keybit);\r\nhotkey_keycode_map[scancode] = KEY_RESERVED;\r\n}\r\n}\r\nstatic int __init hotkey_init(struct ibm_init_struct *iibm)\r\n{\r\nenum keymap_index {\r\nTPACPI_KEYMAP_IBM_GENERIC = 0,\r\nTPACPI_KEYMAP_LENOVO_GENERIC,\r\n};\r\nstatic const tpacpi_keymap_t tpacpi_keymaps[] __initconst = {\r\n[TPACPI_KEYMAP_IBM_GENERIC] = {\r\nKEY_FN_F1, KEY_BATTERY, KEY_COFFEE, KEY_SLEEP,\r\nKEY_WLAN, KEY_FN_F6, KEY_SWITCHVIDEOMODE, KEY_FN_F8,\r\nKEY_FN_F9, KEY_FN_F10, KEY_FN_F11, KEY_SUSPEND,\r\nKEY_UNKNOWN,\r\nKEY_UNKNOWN,\r\nKEY_UNKNOWN,\r\nKEY_RESERVED,\r\nKEY_RESERVED,\r\nKEY_RESERVED,\r\nKEY_UNKNOWN,\r\nKEY_ZOOM,\r\nKEY_RESERVED,\r\nKEY_RESERVED,\r\nKEY_RESERVED,\r\nKEY_VENDOR,\r\nKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\r\nKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\r\n},\r\n[TPACPI_KEYMAP_LENOVO_GENERIC] = {\r\nKEY_FN_F1, KEY_COFFEE, KEY_BATTERY, KEY_SLEEP,\r\nKEY_WLAN, KEY_CAMERA, KEY_SWITCHVIDEOMODE, KEY_FN_F8,\r\nKEY_FN_F9, KEY_FN_F10, KEY_FN_F11, KEY_SUSPEND,\r\nKEY_UNKNOWN,\r\nKEY_UNKNOWN,\r\nKEY_UNKNOWN,\r\nKEY_BRIGHTNESSUP,\r\nKEY_BRIGHTNESSDOWN,\r\nKEY_RESERVED,\r\nKEY_UNKNOWN,\r\nKEY_ZOOM,\r\nKEY_RESERVED,\r\nKEY_RESERVED,\r\nKEY_RESERVED,\r\nKEY_VENDOR,\r\nKEY_UNKNOWN, KEY_UNKNOWN,\r\nKEY_MICMUTE,\r\nKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\r\nKEY_UNKNOWN,\r\n},\r\n};\r\nstatic const struct tpacpi_quirk tpacpi_keymap_qtable[] __initconst = {\r\n{\r\n.vendor = PCI_VENDOR_ID_IBM,\r\n.bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\r\n.quirks = TPACPI_KEYMAP_IBM_GENERIC,\r\n},\r\n{\r\n.vendor = PCI_VENDOR_ID_LENOVO,\r\n.bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\r\n.quirks = TPACPI_KEYMAP_LENOVO_GENERIC,\r\n},\r\n};\r\n#define TPACPI_HOTKEY_MAP_SIZE sizeof(tpacpi_keymap_t)\r\n#define TPACPI_HOTKEY_MAP_TYPESIZE sizeof(tpacpi_keymap_entry_t)\r\nint res, i;\r\nint status;\r\nint hkeyv;\r\nbool radiosw_state = false;\r\nbool tabletsw_state = false;\r\nunsigned long quirks;\r\nunsigned long keymap_id;\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"initializing hotkey subdriver\n");\r\nBUG_ON(!tpacpi_inputdev);\r\nBUG_ON(tpacpi_inputdev->open != NULL ||\r\ntpacpi_inputdev->close != NULL);\r\nTPACPI_ACPIHANDLE_INIT(hkey);\r\nmutex_init(&hotkey_mutex);\r\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\r\nmutex_init(&hotkey_thread_data_mutex);\r\n#endif\r\ntp_features.hotkey = hkey_handle != NULL;\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"hotkeys are %s\n",\r\nstr_supported(tp_features.hotkey));\r\nif (!tp_features.hotkey)\r\nreturn 1;\r\nquirks = tpacpi_check_quirks(tpacpi_hotkey_qtable,\r\nARRAY_SIZE(tpacpi_hotkey_qtable));\r\ntpacpi_disable_brightness_delay();\r\nhotkey_dev_attributes = create_attr_set(\r\nARRAY_SIZE(hotkey_attributes) + 2,\r\nNULL);\r\nif (!hotkey_dev_attributes)\r\nreturn -ENOMEM;\r\nres = add_many_to_attr_set(hotkey_dev_attributes,\r\nhotkey_attributes,\r\nARRAY_SIZE(hotkey_attributes));\r\nif (res)\r\ngoto err_exit;\r\nif (acpi_evalf(hkey_handle, &hkeyv, "MHKV", "qd")) {\r\nif ((hkeyv >> 8) != 1) {\r\npr_err("unknown version of the HKEY interface: 0x%x\n",\r\nhkeyv);\r\npr_err("please report this to %s\n", TPACPI_MAIL);\r\n} else {\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"firmware HKEY interface version: 0x%x\n",\r\nhkeyv);\r\nif (!acpi_evalf(hkey_handle, &hotkey_all_mask,\r\n"MHKA", "qd")) {\r\npr_err("missing MHKA handler, "\r\n"please report this to %s\n",\r\nTPACPI_MAIL);\r\nhotkey_all_mask = 0x080cU;\r\n} else {\r\ntp_features.hotkey_mask = 1;\r\n}\r\n}\r\n}\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"hotkey masks are %s\n",\r\nstr_supported(tp_features.hotkey_mask));\r\nif (!tp_features.hotkey_mask && !hotkey_all_mask &&\r\n(quirks & TPACPI_HK_Q_INIMASK))\r\nhotkey_all_mask = 0x080cU;\r\nif (tp_features.hotkey_mask) {\r\nres = hotkey_mask_get();\r\nif (res)\r\ngoto err_exit;\r\nhotkey_orig_mask = hotkey_acpi_mask;\r\n} else {\r\nhotkey_orig_mask = hotkey_all_mask;\r\nhotkey_acpi_mask = hotkey_all_mask;\r\n}\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_wlswemul) {\r\ntp_features.hotkey_wlsw = 1;\r\nradiosw_state = !!tpacpi_wlsw_emulstate;\r\npr_info("radio switch emulation enabled\n");\r\n} else\r\n#endif\r\nif (acpi_evalf(hkey_handle, &status, "WLSW", "qd")) {\r\ntp_features.hotkey_wlsw = 1;\r\nradiosw_state = !!status;\r\npr_info("radio switch found; radios are %s\n",\r\nenabled(status, 0));\r\n}\r\nif (tp_features.hotkey_wlsw)\r\nres = add_to_attr_set(hotkey_dev_attributes,\r\n&dev_attr_hotkey_radio_sw.attr);\r\nif (!res && acpi_evalf(hkey_handle, &status, "MHKG", "qd")) {\r\ntp_features.hotkey_tablet = 1;\r\ntabletsw_state = !!(status & TP_HOTKEY_TABLET_MASK);\r\npr_info("possible tablet mode switch found; "\r\n"ThinkPad in %s mode\n",\r\n(tabletsw_state) ? "tablet" : "laptop");\r\nres = add_to_attr_set(hotkey_dev_attributes,\r\n&dev_attr_hotkey_tablet_mode.attr);\r\n}\r\nif (!res)\r\nres = register_attr_set_with_sysfs(\r\nhotkey_dev_attributes,\r\n&tpacpi_pdev->dev.kobj);\r\nif (res)\r\ngoto err_exit;\r\nhotkey_keycode_map = kmalloc(TPACPI_HOTKEY_MAP_SIZE,\r\nGFP_KERNEL);\r\nif (!hotkey_keycode_map) {\r\npr_err("failed to allocate memory for key map\n");\r\nres = -ENOMEM;\r\ngoto err_exit;\r\n}\r\nkeymap_id = tpacpi_check_quirks(tpacpi_keymap_qtable,\r\nARRAY_SIZE(tpacpi_keymap_qtable));\r\nBUG_ON(keymap_id >= ARRAY_SIZE(tpacpi_keymaps));\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"using keymap number %lu\n", keymap_id);\r\nmemcpy(hotkey_keycode_map, &tpacpi_keymaps[keymap_id],\r\nTPACPI_HOTKEY_MAP_SIZE);\r\ninput_set_capability(tpacpi_inputdev, EV_MSC, MSC_SCAN);\r\ntpacpi_inputdev->keycodesize = TPACPI_HOTKEY_MAP_TYPESIZE;\r\ntpacpi_inputdev->keycodemax = TPACPI_HOTKEY_MAP_LEN;\r\ntpacpi_inputdev->keycode = hotkey_keycode_map;\r\nfor (i = 0; i < TPACPI_HOTKEY_MAP_LEN; i++) {\r\nif (hotkey_keycode_map[i] != KEY_RESERVED) {\r\ninput_set_capability(tpacpi_inputdev, EV_KEY,\r\nhotkey_keycode_map[i]);\r\n} else {\r\nif (i < sizeof(hotkey_reserved_mask)*8)\r\nhotkey_reserved_mask |= 1 << i;\r\n}\r\n}\r\nif (tp_features.hotkey_wlsw) {\r\ninput_set_capability(tpacpi_inputdev, EV_SW, SW_RFKILL_ALL);\r\ninput_report_switch(tpacpi_inputdev,\r\nSW_RFKILL_ALL, radiosw_state);\r\n}\r\nif (tp_features.hotkey_tablet) {\r\ninput_set_capability(tpacpi_inputdev, EV_SW, SW_TABLET_MODE);\r\ninput_report_switch(tpacpi_inputdev,\r\nSW_TABLET_MODE, tabletsw_state);\r\n}\r\nif (acpi_video_backlight_support()) {\r\npr_info("This ThinkPad has standard ACPI backlight "\r\n"brightness control, supported by the ACPI "\r\n"video driver\n");\r\npr_notice("Disabling thinkpad-acpi brightness events "\r\n"by default...\n");\r\nhotkey_reserved_mask |=\r\n(1 << TP_ACPI_HOTKEYSCAN_FNHOME)\r\n| (1 << TP_ACPI_HOTKEYSCAN_FNEND);\r\nhotkey_unmap(TP_ACPI_HOTKEYSCAN_FNHOME);\r\nhotkey_unmap(TP_ACPI_HOTKEYSCAN_FNEND);\r\n}\r\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\r\nhotkey_source_mask = TPACPI_HKEY_NVRAM_GOOD_MASK\r\n& ~hotkey_all_mask\r\n& ~hotkey_reserved_mask;\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"hotkey source mask 0x%08x, polling freq %u\n",\r\nhotkey_source_mask, hotkey_poll_freq);\r\n#endif\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"enabling firmware HKEY event interface...\n");\r\nres = hotkey_status_set(true);\r\nif (res) {\r\nhotkey_exit();\r\nreturn res;\r\n}\r\nres = hotkey_mask_set(((hotkey_all_mask & ~hotkey_reserved_mask)\r\n| hotkey_driver_mask)\r\n& ~hotkey_source_mask);\r\nif (res < 0 && res != -ENXIO) {\r\nhotkey_exit();\r\nreturn res;\r\n}\r\nhotkey_user_mask = (hotkey_acpi_mask | hotkey_source_mask)\r\n& ~hotkey_reserved_mask;\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"initial masks: user=0x%08x, fw=0x%08x, poll=0x%08x\n",\r\nhotkey_user_mask, hotkey_acpi_mask, hotkey_source_mask);\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\r\n"legacy ibm/hotkey event reporting over procfs %s\n",\r\n(hotkey_report_mode < 2) ?\r\n"enabled" : "disabled");\r\ntpacpi_inputdev->open = &hotkey_inputdev_open;\r\ntpacpi_inputdev->close = &hotkey_inputdev_close;\r\nhotkey_poll_setup_safe(true);\r\nreturn 0;\r\nerr_exit:\r\ndelete_attr_set(hotkey_dev_attributes, &tpacpi_pdev->dev.kobj);\r\nhotkey_dev_attributes = NULL;\r\nreturn (res < 0)? res : 1;\r\n}\r\nstatic bool hotkey_notify_hotkey(const u32 hkey,\r\nbool *send_acpi_ev,\r\nbool *ignore_acpi_ev)\r\n{\r\nunsigned int scancode = hkey & 0xfff;\r\n*send_acpi_ev = true;\r\n*ignore_acpi_ev = false;\r\nif (scancode > 0 && scancode <= TPACPI_HOTKEY_MAP_LEN) {\r\nscancode--;\r\nif (!(hotkey_source_mask & (1 << scancode))) {\r\ntpacpi_input_send_key_masked(scancode);\r\n*send_acpi_ev = false;\r\n} else {\r\n*ignore_acpi_ev = true;\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool hotkey_notify_wakeup(const u32 hkey,\r\nbool *send_acpi_ev,\r\nbool *ignore_acpi_ev)\r\n{\r\n*send_acpi_ev = true;\r\n*ignore_acpi_ev = false;\r\nswitch (hkey) {\r\ncase TP_HKEY_EV_WKUP_S3_UNDOCK:\r\ncase TP_HKEY_EV_WKUP_S4_UNDOCK:\r\nhotkey_wakeup_reason = TP_ACPI_WAKEUP_UNDOCK;\r\n*ignore_acpi_ev = true;\r\nbreak;\r\ncase TP_HKEY_EV_WKUP_S3_BAYEJ:\r\ncase TP_HKEY_EV_WKUP_S4_BAYEJ:\r\nhotkey_wakeup_reason = TP_ACPI_WAKEUP_BAYEJ;\r\n*ignore_acpi_ev = true;\r\nbreak;\r\ncase TP_HKEY_EV_WKUP_S3_BATLOW:\r\ncase TP_HKEY_EV_WKUP_S4_BATLOW:\r\npr_alert("EMERGENCY WAKEUP: battery almost empty\n");\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nif (hotkey_wakeup_reason != TP_ACPI_WAKEUP_NONE) {\r\npr_info("woke up due to a hot-unplug request...\n");\r\nhotkey_wakeup_reason_notify_change();\r\n}\r\nreturn true;\r\n}\r\nstatic bool hotkey_notify_dockevent(const u32 hkey,\r\nbool *send_acpi_ev,\r\nbool *ignore_acpi_ev)\r\n{\r\n*send_acpi_ev = true;\r\n*ignore_acpi_ev = false;\r\nswitch (hkey) {\r\ncase TP_HKEY_EV_UNDOCK_ACK:\r\nhotkey_autosleep_ack = 1;\r\npr_info("undocked\n");\r\nhotkey_wakeup_hotunplug_complete_notify_change();\r\nreturn true;\r\ncase TP_HKEY_EV_HOTPLUG_DOCK:\r\npr_info("docked into hotplug port replicator\n");\r\nreturn true;\r\ncase TP_HKEY_EV_HOTPLUG_UNDOCK:\r\npr_info("undocked from hotplug port replicator\n");\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool hotkey_notify_usrevent(const u32 hkey,\r\nbool *send_acpi_ev,\r\nbool *ignore_acpi_ev)\r\n{\r\n*send_acpi_ev = true;\r\n*ignore_acpi_ev = false;\r\nswitch (hkey) {\r\ncase TP_HKEY_EV_PEN_INSERTED:\r\ncase TP_HKEY_EV_PEN_REMOVED:\r\nreturn true;\r\ncase TP_HKEY_EV_TABLET_TABLET:\r\ncase TP_HKEY_EV_TABLET_NOTEBOOK:\r\ntpacpi_input_send_tabletsw();\r\nhotkey_tablet_mode_notify_change();\r\n*send_acpi_ev = false;\r\nreturn true;\r\ncase TP_HKEY_EV_LID_CLOSE:\r\ncase TP_HKEY_EV_LID_OPEN:\r\ncase TP_HKEY_EV_BRGHT_CHANGED:\r\n*ignore_acpi_ev = true;\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool hotkey_notify_6xxx(const u32 hkey,\r\nbool *send_acpi_ev,\r\nbool *ignore_acpi_ev)\r\n{\r\nbool known = true;\r\n*send_acpi_ev = true;\r\n*ignore_acpi_ev = false;\r\nswitch (hkey) {\r\ncase TP_HKEY_EV_THM_TABLE_CHANGED:\r\npr_info("EC reports that Thermal Table has changed\n");\r\nreturn true;\r\ncase TP_HKEY_EV_ALARM_BAT_HOT:\r\npr_crit("THERMAL ALARM: battery is too hot!\n");\r\nbreak;\r\ncase TP_HKEY_EV_ALARM_BAT_XHOT:\r\npr_alert("THERMAL EMERGENCY: battery is extremely hot!\n");\r\nbreak;\r\ncase TP_HKEY_EV_ALARM_SENSOR_HOT:\r\npr_crit("THERMAL ALARM: "\r\n"a sensor reports something is too hot!\n");\r\nbreak;\r\ncase TP_HKEY_EV_ALARM_SENSOR_XHOT:\r\npr_alert("THERMAL EMERGENCY: "\r\n"a sensor reports something is extremely hot!\n");\r\nbreak;\r\ncase TP_HKEY_EV_AC_CHANGED:\r\ncase TP_HKEY_EV_KEY_NUMLOCK:\r\ncase TP_HKEY_EV_KEY_FN:\r\n*send_acpi_ev = false;\r\n*ignore_acpi_ev = true;\r\nreturn true;\r\ndefault:\r\npr_warn("unknown possible thermal alarm or keyboard event received\n");\r\nknown = false;\r\n}\r\nthermal_dump_all_sensors();\r\nreturn known;\r\n}\r\nstatic void hotkey_notify(struct ibm_struct *ibm, u32 event)\r\n{\r\nu32 hkey;\r\nbool send_acpi_ev;\r\nbool ignore_acpi_ev;\r\nbool known_ev;\r\nif (event != 0x80) {\r\npr_err("unknown HKEY notification event %d\n", event);\r\nacpi_bus_generate_netlink_event(\r\nibm->acpi->device->pnp.device_class,\r\ndev_name(&ibm->acpi->device->dev),\r\nevent, 0);\r\nreturn;\r\n}\r\nwhile (1) {\r\nif (!acpi_evalf(hkey_handle, &hkey, "MHKP", "d")) {\r\npr_err("failed to retrieve HKEY event\n");\r\nreturn;\r\n}\r\nif (hkey == 0) {\r\nreturn;\r\n}\r\nsend_acpi_ev = true;\r\nignore_acpi_ev = false;\r\nswitch (hkey >> 12) {\r\ncase 1:\r\nknown_ev = hotkey_notify_hotkey(hkey, &send_acpi_ev,\r\n&ignore_acpi_ev);\r\nbreak;\r\ncase 2:\r\nknown_ev = hotkey_notify_wakeup(hkey, &send_acpi_ev,\r\n&ignore_acpi_ev);\r\nbreak;\r\ncase 3:\r\nswitch (hkey) {\r\ncase TP_HKEY_EV_BAYEJ_ACK:\r\nhotkey_autosleep_ack = 1;\r\npr_info("bay ejected\n");\r\nhotkey_wakeup_hotunplug_complete_notify_change();\r\nknown_ev = true;\r\nbreak;\r\ncase TP_HKEY_EV_OPTDRV_EJ:\r\nknown_ev = true;\r\nbreak;\r\ndefault:\r\nknown_ev = false;\r\n}\r\nbreak;\r\ncase 4:\r\nknown_ev = hotkey_notify_dockevent(hkey, &send_acpi_ev,\r\n&ignore_acpi_ev);\r\nbreak;\r\ncase 5:\r\nknown_ev = hotkey_notify_usrevent(hkey, &send_acpi_ev,\r\n&ignore_acpi_ev);\r\nbreak;\r\ncase 6:\r\nknown_ev = hotkey_notify_6xxx(hkey, &send_acpi_ev,\r\n&ignore_acpi_ev);\r\nbreak;\r\ncase 7:\r\nif (tp_features.hotkey_wlsw &&\r\nhkey == TP_HKEY_EV_RFKILL_CHANGED) {\r\ntpacpi_send_radiosw_update();\r\nsend_acpi_ev = 0;\r\nknown_ev = true;\r\nbreak;\r\n}\r\ndefault:\r\nknown_ev = false;\r\n}\r\nif (!known_ev) {\r\npr_notice("unhandled HKEY event 0x%04x\n", hkey);\r\npr_notice("please report the conditions when this "\r\n"event happened to %s\n", TPACPI_MAIL);\r\n}\r\nif (!ignore_acpi_ev &&\r\n(send_acpi_ev || hotkey_report_mode < 2)) {\r\nacpi_bus_generate_proc_event(ibm->acpi->device,\r\nevent, hkey);\r\n}\r\nif (!ignore_acpi_ev && send_acpi_ev) {\r\nacpi_bus_generate_netlink_event(\r\nibm->acpi->device->pnp.device_class,\r\ndev_name(&ibm->acpi->device->dev),\r\nevent, hkey);\r\n}\r\n}\r\n}\r\nstatic void hotkey_suspend(void)\r\n{\r\nhotkey_wakeup_reason = TP_ACPI_WAKEUP_NONE;\r\nhotkey_autosleep_ack = 0;\r\n}\r\nstatic void hotkey_resume(void)\r\n{\r\ntpacpi_disable_brightness_delay();\r\nif (hotkey_status_set(true) < 0 ||\r\nhotkey_mask_set(hotkey_acpi_mask) < 0)\r\npr_err("error while attempting to reset the event "\r\n"firmware interface\n");\r\ntpacpi_send_radiosw_update();\r\nhotkey_tablet_mode_notify_change();\r\nhotkey_wakeup_reason_notify_change();\r\nhotkey_wakeup_hotunplug_complete_notify_change();\r\nhotkey_poll_setup_safe(false);\r\n}\r\nstatic int hotkey_read(struct seq_file *m)\r\n{\r\nint res, status;\r\nif (!tp_features.hotkey) {\r\nseq_printf(m, "status:\t\tnot supported\n");\r\nreturn 0;\r\n}\r\nif (mutex_lock_killable(&hotkey_mutex))\r\nreturn -ERESTARTSYS;\r\nres = hotkey_status_get(&status);\r\nif (!res)\r\nres = hotkey_mask_get();\r\nmutex_unlock(&hotkey_mutex);\r\nif (res)\r\nreturn res;\r\nseq_printf(m, "status:\t\t%s\n", enabled(status, 0));\r\nif (hotkey_all_mask) {\r\nseq_printf(m, "mask:\t\t0x%08x\n", hotkey_user_mask);\r\nseq_printf(m, "commands:\tenable, disable, reset, <mask>\n");\r\n} else {\r\nseq_printf(m, "mask:\t\tnot supported\n");\r\nseq_printf(m, "commands:\tenable, disable, reset\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void hotkey_enabledisable_warn(bool enable)\r\n{\r\ntpacpi_log_usertask("procfs hotkey enable/disable");\r\nif (!WARN((tpacpi_lifecycle == TPACPI_LIFE_RUNNING || !enable),\r\npr_fmt("hotkey enable/disable functionality has been "\r\n"removed from the driver. "\r\n"Hotkeys are always enabled.\n")))\r\npr_err("Please remove the hotkey=enable module "\r\n"parameter, it is deprecated. "\r\n"Hotkeys are always enabled.\n");\r\n}\r\nstatic int hotkey_write(char *buf)\r\n{\r\nint res;\r\nu32 mask;\r\nchar *cmd;\r\nif (!tp_features.hotkey)\r\nreturn -ENODEV;\r\nif (mutex_lock_killable(&hotkey_mutex))\r\nreturn -ERESTARTSYS;\r\nmask = hotkey_user_mask;\r\nres = 0;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (strlencmp(cmd, "enable") == 0) {\r\nhotkey_enabledisable_warn(1);\r\n} else if (strlencmp(cmd, "disable") == 0) {\r\nhotkey_enabledisable_warn(0);\r\nres = -EPERM;\r\n} else if (strlencmp(cmd, "reset") == 0) {\r\nmask = (hotkey_all_mask | hotkey_source_mask)\r\n& ~hotkey_reserved_mask;\r\n} else if (sscanf(cmd, "0x%x", &mask) == 1) {\r\n} else if (sscanf(cmd, "%x", &mask) == 1) {\r\n} else {\r\nres = -EINVAL;\r\ngoto errexit;\r\n}\r\n}\r\nif (!res) {\r\ntpacpi_disclose_usertask("procfs hotkey",\r\n"set mask to 0x%08x\n", mask);\r\nres = hotkey_user_mask_set(mask);\r\n}\r\nerrexit:\r\nmutex_unlock(&hotkey_mutex);\r\nreturn res;\r\n}\r\nstatic int bluetooth_get_status(void)\r\n{\r\nint status;\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_bluetoothemul)\r\nreturn (tpacpi_bluetooth_emulstate) ?\r\nTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\r\n#endif\r\nif (!acpi_evalf(hkey_handle, &status, "GBDC", "d"))\r\nreturn -EIO;\r\nreturn ((status & TP_ACPI_BLUETOOTH_RADIOSSW) != 0) ?\r\nTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\r\n}\r\nstatic int bluetooth_set_status(enum tpacpi_rfkill_state state)\r\n{\r\nint status;\r\nvdbg_printk(TPACPI_DBG_RFKILL,\r\n"will attempt to %s bluetooth\n",\r\n(state == TPACPI_RFK_RADIO_ON) ? "enable" : "disable");\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_bluetoothemul) {\r\ntpacpi_bluetooth_emulstate = (state == TPACPI_RFK_RADIO_ON);\r\nreturn 0;\r\n}\r\n#endif\r\nif (state == TPACPI_RFK_RADIO_ON)\r\nstatus = TP_ACPI_BLUETOOTH_RADIOSSW\r\n| TP_ACPI_BLUETOOTH_RESUMECTRL;\r\nelse\r\nstatus = 0;\r\nif (!acpi_evalf(hkey_handle, NULL, "SBDC", "vd", status))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic ssize_t bluetooth_enable_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn tpacpi_rfk_sysfs_enable_show(TPACPI_RFK_BLUETOOTH_SW_ID,\r\nattr, buf);\r\n}\r\nstatic ssize_t bluetooth_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn tpacpi_rfk_sysfs_enable_store(TPACPI_RFK_BLUETOOTH_SW_ID,\r\nattr, buf, count);\r\n}\r\nstatic void bluetooth_shutdown(void)\r\n{\r\nif (!acpi_evalf(NULL, NULL, "\\BLTH", "vd",\r\nTP_ACPI_BLTH_SAVE_STATE))\r\npr_notice("failed to save bluetooth state to NVRAM\n");\r\nelse\r\nvdbg_printk(TPACPI_DBG_RFKILL,\r\n"bluetooth state saved to NVRAM\n");\r\n}\r\nstatic void bluetooth_exit(void)\r\n{\r\nsysfs_remove_group(&tpacpi_pdev->dev.kobj,\r\n&bluetooth_attr_group);\r\ntpacpi_destroy_rfkill(TPACPI_RFK_BLUETOOTH_SW_ID);\r\nbluetooth_shutdown();\r\n}\r\nstatic int __init bluetooth_init(struct ibm_init_struct *iibm)\r\n{\r\nint res;\r\nint status = 0;\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\r\n"initializing bluetooth subdriver\n");\r\nTPACPI_ACPIHANDLE_INIT(hkey);\r\ntp_features.bluetooth = hkey_handle &&\r\nacpi_evalf(hkey_handle, &status, "GBDC", "qd");\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\r\n"bluetooth is %s, status 0x%02x\n",\r\nstr_supported(tp_features.bluetooth),\r\nstatus);\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_bluetoothemul) {\r\ntp_features.bluetooth = 1;\r\npr_info("bluetooth switch emulation enabled\n");\r\n} else\r\n#endif\r\nif (tp_features.bluetooth &&\r\n!(status & TP_ACPI_BLUETOOTH_HWPRESENT)) {\r\ntp_features.bluetooth = 0;\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\r\n"bluetooth hardware not installed\n");\r\n}\r\nif (!tp_features.bluetooth)\r\nreturn 1;\r\nres = tpacpi_new_rfkill(TPACPI_RFK_BLUETOOTH_SW_ID,\r\n&bluetooth_tprfk_ops,\r\nRFKILL_TYPE_BLUETOOTH,\r\nTPACPI_RFK_BLUETOOTH_SW_NAME,\r\ntrue);\r\nif (res)\r\nreturn res;\r\nres = sysfs_create_group(&tpacpi_pdev->dev.kobj,\r\n&bluetooth_attr_group);\r\nif (res) {\r\ntpacpi_destroy_rfkill(TPACPI_RFK_BLUETOOTH_SW_ID);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bluetooth_read(struct seq_file *m)\r\n{\r\nreturn tpacpi_rfk_procfs_read(TPACPI_RFK_BLUETOOTH_SW_ID, m);\r\n}\r\nstatic int bluetooth_write(char *buf)\r\n{\r\nreturn tpacpi_rfk_procfs_write(TPACPI_RFK_BLUETOOTH_SW_ID, buf);\r\n}\r\nstatic int wan_get_status(void)\r\n{\r\nint status;\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_wwanemul)\r\nreturn (tpacpi_wwan_emulstate) ?\r\nTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\r\n#endif\r\nif (!acpi_evalf(hkey_handle, &status, "GWAN", "d"))\r\nreturn -EIO;\r\nreturn ((status & TP_ACPI_WANCARD_RADIOSSW) != 0) ?\r\nTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\r\n}\r\nstatic int wan_set_status(enum tpacpi_rfkill_state state)\r\n{\r\nint status;\r\nvdbg_printk(TPACPI_DBG_RFKILL,\r\n"will attempt to %s wwan\n",\r\n(state == TPACPI_RFK_RADIO_ON) ? "enable" : "disable");\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_wwanemul) {\r\ntpacpi_wwan_emulstate = (state == TPACPI_RFK_RADIO_ON);\r\nreturn 0;\r\n}\r\n#endif\r\nif (state == TPACPI_RFK_RADIO_ON)\r\nstatus = TP_ACPI_WANCARD_RADIOSSW\r\n| TP_ACPI_WANCARD_RESUMECTRL;\r\nelse\r\nstatus = 0;\r\nif (!acpi_evalf(hkey_handle, NULL, "SWAN", "vd", status))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic ssize_t wan_enable_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn tpacpi_rfk_sysfs_enable_show(TPACPI_RFK_WWAN_SW_ID,\r\nattr, buf);\r\n}\r\nstatic ssize_t wan_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn tpacpi_rfk_sysfs_enable_store(TPACPI_RFK_WWAN_SW_ID,\r\nattr, buf, count);\r\n}\r\nstatic void wan_shutdown(void)\r\n{\r\nif (!acpi_evalf(NULL, NULL, "\\WGSV", "vd",\r\nTP_ACPI_WGSV_SAVE_STATE))\r\npr_notice("failed to save WWAN state to NVRAM\n");\r\nelse\r\nvdbg_printk(TPACPI_DBG_RFKILL,\r\n"WWAN state saved to NVRAM\n");\r\n}\r\nstatic void wan_exit(void)\r\n{\r\nsysfs_remove_group(&tpacpi_pdev->dev.kobj,\r\n&wan_attr_group);\r\ntpacpi_destroy_rfkill(TPACPI_RFK_WWAN_SW_ID);\r\nwan_shutdown();\r\n}\r\nstatic int __init wan_init(struct ibm_init_struct *iibm)\r\n{\r\nint res;\r\nint status = 0;\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\r\n"initializing wan subdriver\n");\r\nTPACPI_ACPIHANDLE_INIT(hkey);\r\ntp_features.wan = hkey_handle &&\r\nacpi_evalf(hkey_handle, &status, "GWAN", "qd");\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\r\n"wan is %s, status 0x%02x\n",\r\nstr_supported(tp_features.wan),\r\nstatus);\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_wwanemul) {\r\ntp_features.wan = 1;\r\npr_info("wwan switch emulation enabled\n");\r\n} else\r\n#endif\r\nif (tp_features.wan &&\r\n!(status & TP_ACPI_WANCARD_HWPRESENT)) {\r\ntp_features.wan = 0;\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\r\n"wan hardware not installed\n");\r\n}\r\nif (!tp_features.wan)\r\nreturn 1;\r\nres = tpacpi_new_rfkill(TPACPI_RFK_WWAN_SW_ID,\r\n&wan_tprfk_ops,\r\nRFKILL_TYPE_WWAN,\r\nTPACPI_RFK_WWAN_SW_NAME,\r\ntrue);\r\nif (res)\r\nreturn res;\r\nres = sysfs_create_group(&tpacpi_pdev->dev.kobj,\r\n&wan_attr_group);\r\nif (res) {\r\ntpacpi_destroy_rfkill(TPACPI_RFK_WWAN_SW_ID);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wan_read(struct seq_file *m)\r\n{\r\nreturn tpacpi_rfk_procfs_read(TPACPI_RFK_WWAN_SW_ID, m);\r\n}\r\nstatic int wan_write(char *buf)\r\n{\r\nreturn tpacpi_rfk_procfs_write(TPACPI_RFK_WWAN_SW_ID, buf);\r\n}\r\nstatic int uwb_get_status(void)\r\n{\r\nint status;\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_uwbemul)\r\nreturn (tpacpi_uwb_emulstate) ?\r\nTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\r\n#endif\r\nif (!acpi_evalf(hkey_handle, &status, "GUWB", "d"))\r\nreturn -EIO;\r\nreturn ((status & TP_ACPI_UWB_RADIOSSW) != 0) ?\r\nTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\r\n}\r\nstatic int uwb_set_status(enum tpacpi_rfkill_state state)\r\n{\r\nint status;\r\nvdbg_printk(TPACPI_DBG_RFKILL,\r\n"will attempt to %s UWB\n",\r\n(state == TPACPI_RFK_RADIO_ON) ? "enable" : "disable");\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_uwbemul) {\r\ntpacpi_uwb_emulstate = (state == TPACPI_RFK_RADIO_ON);\r\nreturn 0;\r\n}\r\n#endif\r\nif (state == TPACPI_RFK_RADIO_ON)\r\nstatus = TP_ACPI_UWB_RADIOSSW;\r\nelse\r\nstatus = 0;\r\nif (!acpi_evalf(hkey_handle, NULL, "SUWB", "vd", status))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void uwb_exit(void)\r\n{\r\ntpacpi_destroy_rfkill(TPACPI_RFK_UWB_SW_ID);\r\n}\r\nstatic int __init uwb_init(struct ibm_init_struct *iibm)\r\n{\r\nint res;\r\nint status = 0;\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\r\n"initializing uwb subdriver\n");\r\nTPACPI_ACPIHANDLE_INIT(hkey);\r\ntp_features.uwb = hkey_handle &&\r\nacpi_evalf(hkey_handle, &status, "GUWB", "qd");\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\r\n"uwb is %s, status 0x%02x\n",\r\nstr_supported(tp_features.uwb),\r\nstatus);\r\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\r\nif (dbg_uwbemul) {\r\ntp_features.uwb = 1;\r\npr_info("uwb switch emulation enabled\n");\r\n} else\r\n#endif\r\nif (tp_features.uwb &&\r\n!(status & TP_ACPI_UWB_HWPRESENT)) {\r\ntp_features.uwb = 0;\r\ndbg_printk(TPACPI_DBG_INIT,\r\n"uwb hardware not installed\n");\r\n}\r\nif (!tp_features.uwb)\r\nreturn 1;\r\nres = tpacpi_new_rfkill(TPACPI_RFK_UWB_SW_ID,\r\n&uwb_tprfk_ops,\r\nRFKILL_TYPE_UWB,\r\nTPACPI_RFK_UWB_SW_NAME,\r\nfalse);\r\nreturn res;\r\n}\r\nstatic int __init video_init(struct ibm_init_struct *iibm)\r\n{\r\nint ivga;\r\nvdbg_printk(TPACPI_DBG_INIT, "initializing video subdriver\n");\r\nTPACPI_ACPIHANDLE_INIT(vid);\r\nif (tpacpi_is_ibm())\r\nTPACPI_ACPIHANDLE_INIT(vid2);\r\nif (vid2_handle && acpi_evalf(NULL, &ivga, "\\IVGA", "d") && ivga)\r\nvid_handle = vid2_handle;\r\nif (!vid_handle)\r\nvideo_supported = TPACPI_VIDEO_NONE;\r\nelse if (tpacpi_is_ibm() &&\r\nacpi_evalf(vid_handle, &video_orig_autosw, "SWIT", "qd"))\r\nvideo_supported = TPACPI_VIDEO_570;\r\nelse if (tpacpi_is_ibm() &&\r\nacpi_evalf(vid_handle, &video_orig_autosw, "^VADL", "qd"))\r\nvideo_supported = TPACPI_VIDEO_770;\r\nelse\r\nvideo_supported = TPACPI_VIDEO_NEW;\r\nvdbg_printk(TPACPI_DBG_INIT, "video is %s, mode %d\n",\r\nstr_supported(video_supported != TPACPI_VIDEO_NONE),\r\nvideo_supported);\r\nreturn (video_supported != TPACPI_VIDEO_NONE)? 0 : 1;\r\n}\r\nstatic void video_exit(void)\r\n{\r\ndbg_printk(TPACPI_DBG_EXIT,\r\n"restoring original video autoswitch mode\n");\r\nif (video_autosw_set(video_orig_autosw))\r\npr_err("error while trying to restore original "\r\n"video autoswitch mode\n");\r\n}\r\nstatic int video_outputsw_get(void)\r\n{\r\nint status = 0;\r\nint i;\r\nswitch (video_supported) {\r\ncase TPACPI_VIDEO_570:\r\nif (!acpi_evalf(NULL, &i, "\\_SB.PHS", "dd",\r\nTP_ACPI_VIDEO_570_PHSCMD))\r\nreturn -EIO;\r\nstatus = i & TP_ACPI_VIDEO_570_PHSMASK;\r\nbreak;\r\ncase TPACPI_VIDEO_770:\r\nif (!acpi_evalf(NULL, &i, "\\VCDL", "d"))\r\nreturn -EIO;\r\nif (i)\r\nstatus |= TP_ACPI_VIDEO_S_LCD;\r\nif (!acpi_evalf(NULL, &i, "\\VCDC", "d"))\r\nreturn -EIO;\r\nif (i)\r\nstatus |= TP_ACPI_VIDEO_S_CRT;\r\nbreak;\r\ncase TPACPI_VIDEO_NEW:\r\nif (!acpi_evalf(NULL, NULL, "\\VUPS", "vd", 1) ||\r\n!acpi_evalf(NULL, &i, "\\VCDC", "d"))\r\nreturn -EIO;\r\nif (i)\r\nstatus |= TP_ACPI_VIDEO_S_CRT;\r\nif (!acpi_evalf(NULL, NULL, "\\VUPS", "vd", 0) ||\r\n!acpi_evalf(NULL, &i, "\\VCDL", "d"))\r\nreturn -EIO;\r\nif (i)\r\nstatus |= TP_ACPI_VIDEO_S_LCD;\r\nif (!acpi_evalf(NULL, &i, "\\VCDD", "d"))\r\nreturn -EIO;\r\nif (i)\r\nstatus |= TP_ACPI_VIDEO_S_DVI;\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn status;\r\n}\r\nstatic int video_outputsw_set(int status)\r\n{\r\nint autosw;\r\nint res = 0;\r\nswitch (video_supported) {\r\ncase TPACPI_VIDEO_570:\r\nres = acpi_evalf(NULL, NULL,\r\n"\\_SB.PHS2", "vdd",\r\nTP_ACPI_VIDEO_570_PHS2CMD,\r\nstatus | TP_ACPI_VIDEO_570_PHS2SET);\r\nbreak;\r\ncase TPACPI_VIDEO_770:\r\nautosw = video_autosw_get();\r\nif (autosw < 0)\r\nreturn autosw;\r\nres = video_autosw_set(1);\r\nif (res)\r\nreturn res;\r\nres = acpi_evalf(vid_handle, NULL,\r\n"ASWT", "vdd", status * 0x100, 0);\r\nif (!autosw && video_autosw_set(autosw)) {\r\npr_err("video auto-switch left enabled due to error\n");\r\nreturn -EIO;\r\n}\r\nbreak;\r\ncase TPACPI_VIDEO_NEW:\r\nres = acpi_evalf(NULL, NULL, "\\VUPS", "vd", 0x80) &&\r\nacpi_evalf(NULL, NULL, "\\VSDS", "vdd", status, 1);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn (res)? 0 : -EIO;\r\n}\r\nstatic int video_autosw_get(void)\r\n{\r\nint autosw = 0;\r\nswitch (video_supported) {\r\ncase TPACPI_VIDEO_570:\r\nif (!acpi_evalf(vid_handle, &autosw, "SWIT", "d"))\r\nreturn -EIO;\r\nbreak;\r\ncase TPACPI_VIDEO_770:\r\ncase TPACPI_VIDEO_NEW:\r\nif (!acpi_evalf(vid_handle, &autosw, "^VDEE", "d"))\r\nreturn -EIO;\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn autosw & 1;\r\n}\r\nstatic int video_autosw_set(int enable)\r\n{\r\nif (!acpi_evalf(vid_handle, NULL, "_DOS", "vd", (enable)? 1 : 0))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int video_outputsw_cycle(void)\r\n{\r\nint autosw = video_autosw_get();\r\nint res;\r\nif (autosw < 0)\r\nreturn autosw;\r\nswitch (video_supported) {\r\ncase TPACPI_VIDEO_570:\r\nres = video_autosw_set(1);\r\nif (res)\r\nreturn res;\r\nres = acpi_evalf(ec_handle, NULL, "_Q16", "v");\r\nbreak;\r\ncase TPACPI_VIDEO_770:\r\ncase TPACPI_VIDEO_NEW:\r\nres = video_autosw_set(1);\r\nif (res)\r\nreturn res;\r\nres = acpi_evalf(vid_handle, NULL, "VSWT", "v");\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nif (!autosw && video_autosw_set(autosw)) {\r\npr_err("video auto-switch left enabled due to error\n");\r\nreturn -EIO;\r\n}\r\nreturn (res)? 0 : -EIO;\r\n}\r\nstatic int video_expand_toggle(void)\r\n{\r\nswitch (video_supported) {\r\ncase TPACPI_VIDEO_570:\r\nreturn acpi_evalf(ec_handle, NULL, "_Q17", "v")?\r\n0 : -EIO;\r\ncase TPACPI_VIDEO_770:\r\nreturn acpi_evalf(vid_handle, NULL, "VEXP", "v")?\r\n0 : -EIO;\r\ncase TPACPI_VIDEO_NEW:\r\nreturn acpi_evalf(NULL, NULL, "\\VEXP", "v")?\r\n0 : -EIO;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\n}\r\nstatic int video_read(struct seq_file *m)\r\n{\r\nint status, autosw;\r\nif (video_supported == TPACPI_VIDEO_NONE) {\r\nseq_printf(m, "status:\t\tnot supported\n");\r\nreturn 0;\r\n}\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nstatus = video_outputsw_get();\r\nif (status < 0)\r\nreturn status;\r\nautosw = video_autosw_get();\r\nif (autosw < 0)\r\nreturn autosw;\r\nseq_printf(m, "status:\t\tsupported\n");\r\nseq_printf(m, "lcd:\t\t%s\n", enabled(status, 0));\r\nseq_printf(m, "crt:\t\t%s\n", enabled(status, 1));\r\nif (video_supported == TPACPI_VIDEO_NEW)\r\nseq_printf(m, "dvi:\t\t%s\n", enabled(status, 3));\r\nseq_printf(m, "auto:\t\t%s\n", enabled(autosw, 0));\r\nseq_printf(m, "commands:\tlcd_enable, lcd_disable\n");\r\nseq_printf(m, "commands:\tcrt_enable, crt_disable\n");\r\nif (video_supported == TPACPI_VIDEO_NEW)\r\nseq_printf(m, "commands:\tdvi_enable, dvi_disable\n");\r\nseq_printf(m, "commands:\tauto_enable, auto_disable\n");\r\nseq_printf(m, "commands:\tvideo_switch, expand_toggle\n");\r\nreturn 0;\r\n}\r\nstatic int video_write(char *buf)\r\n{\r\nchar *cmd;\r\nint enable, disable, status;\r\nint res;\r\nif (video_supported == TPACPI_VIDEO_NONE)\r\nreturn -ENODEV;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nenable = 0;\r\ndisable = 0;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (strlencmp(cmd, "lcd_enable") == 0) {\r\nenable |= TP_ACPI_VIDEO_S_LCD;\r\n} else if (strlencmp(cmd, "lcd_disable") == 0) {\r\ndisable |= TP_ACPI_VIDEO_S_LCD;\r\n} else if (strlencmp(cmd, "crt_enable") == 0) {\r\nenable |= TP_ACPI_VIDEO_S_CRT;\r\n} else if (strlencmp(cmd, "crt_disable") == 0) {\r\ndisable |= TP_ACPI_VIDEO_S_CRT;\r\n} else if (video_supported == TPACPI_VIDEO_NEW &&\r\nstrlencmp(cmd, "dvi_enable") == 0) {\r\nenable |= TP_ACPI_VIDEO_S_DVI;\r\n} else if (video_supported == TPACPI_VIDEO_NEW &&\r\nstrlencmp(cmd, "dvi_disable") == 0) {\r\ndisable |= TP_ACPI_VIDEO_S_DVI;\r\n} else if (strlencmp(cmd, "auto_enable") == 0) {\r\nres = video_autosw_set(1);\r\nif (res)\r\nreturn res;\r\n} else if (strlencmp(cmd, "auto_disable") == 0) {\r\nres = video_autosw_set(0);\r\nif (res)\r\nreturn res;\r\n} else if (strlencmp(cmd, "video_switch") == 0) {\r\nres = video_outputsw_cycle();\r\nif (res)\r\nreturn res;\r\n} else if (strlencmp(cmd, "expand_toggle") == 0) {\r\nres = video_expand_toggle();\r\nif (res)\r\nreturn res;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nif (enable || disable) {\r\nstatus = video_outputsw_get();\r\nif (status < 0)\r\nreturn status;\r\nres = video_outputsw_set((status & ~disable) | enable);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int light_get_status(void)\r\n{\r\nint status = 0;\r\nif (tp_features.light_status) {\r\nif (!acpi_evalf(ec_handle, &status, "KBLT", "d"))\r\nreturn -EIO;\r\nreturn (!!status);\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic int light_set_status(int status)\r\n{\r\nint rc;\r\nif (tp_features.light) {\r\nif (cmos_handle) {\r\nrc = acpi_evalf(cmos_handle, NULL, NULL, "vd",\r\n(status)?\r\nTP_CMOS_THINKLIGHT_ON :\r\nTP_CMOS_THINKLIGHT_OFF);\r\n} else {\r\nrc = acpi_evalf(lght_handle, NULL, NULL, "vd",\r\n(status)? 1 : 0);\r\n}\r\nreturn (rc)? 0 : -EIO;\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic void light_set_status_worker(struct work_struct *work)\r\n{\r\nstruct tpacpi_led_classdev *data =\r\ncontainer_of(work, struct tpacpi_led_classdev, work);\r\nif (likely(tpacpi_lifecycle == TPACPI_LIFE_RUNNING))\r\nlight_set_status((data->new_state != TPACPI_LED_OFF));\r\n}\r\nstatic void light_sysfs_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct tpacpi_led_classdev *data =\r\ncontainer_of(led_cdev,\r\nstruct tpacpi_led_classdev,\r\nled_classdev);\r\ndata->new_state = (brightness != LED_OFF) ?\r\nTPACPI_LED_ON : TPACPI_LED_OFF;\r\nqueue_work(tpacpi_wq, &data->work);\r\n}\r\nstatic enum led_brightness light_sysfs_get(struct led_classdev *led_cdev)\r\n{\r\nreturn (light_get_status() == 1)? LED_FULL : LED_OFF;\r\n}\r\nstatic int __init light_init(struct ibm_init_struct *iibm)\r\n{\r\nint rc;\r\nvdbg_printk(TPACPI_DBG_INIT, "initializing light subdriver\n");\r\nif (tpacpi_is_ibm()) {\r\nTPACPI_ACPIHANDLE_INIT(ledb);\r\nTPACPI_ACPIHANDLE_INIT(lght);\r\n}\r\nTPACPI_ACPIHANDLE_INIT(cmos);\r\nINIT_WORK(&tpacpi_led_thinklight.work, light_set_status_worker);\r\ntp_features.light = (cmos_handle || lght_handle) && !ledb_handle;\r\nif (tp_features.light)\r\ntp_features.light_status =\r\nacpi_evalf(ec_handle, NULL, "KBLT", "qv");\r\nvdbg_printk(TPACPI_DBG_INIT, "light is %s, light status is %s\n",\r\nstr_supported(tp_features.light),\r\nstr_supported(tp_features.light_status));\r\nif (!tp_features.light)\r\nreturn 1;\r\nrc = led_classdev_register(&tpacpi_pdev->dev,\r\n&tpacpi_led_thinklight.led_classdev);\r\nif (rc < 0) {\r\ntp_features.light = 0;\r\ntp_features.light_status = 0;\r\n} else {\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic void light_exit(void)\r\n{\r\nled_classdev_unregister(&tpacpi_led_thinklight.led_classdev);\r\nflush_workqueue(tpacpi_wq);\r\n}\r\nstatic int light_read(struct seq_file *m)\r\n{\r\nint status;\r\nif (!tp_features.light) {\r\nseq_printf(m, "status:\t\tnot supported\n");\r\n} else if (!tp_features.light_status) {\r\nseq_printf(m, "status:\t\tunknown\n");\r\nseq_printf(m, "commands:\ton, off\n");\r\n} else {\r\nstatus = light_get_status();\r\nif (status < 0)\r\nreturn status;\r\nseq_printf(m, "status:\t\t%s\n", onoff(status, 0));\r\nseq_printf(m, "commands:\ton, off\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int light_write(char *buf)\r\n{\r\nchar *cmd;\r\nint newstatus = 0;\r\nif (!tp_features.light)\r\nreturn -ENODEV;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (strlencmp(cmd, "on") == 0) {\r\nnewstatus = 1;\r\n} else if (strlencmp(cmd, "off") == 0) {\r\nnewstatus = 0;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nreturn light_set_status(newstatus);\r\n}\r\nstatic ssize_t cmos_command_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long cmos_cmd;\r\nint res;\r\nif (parse_strtoul(buf, 21, &cmos_cmd))\r\nreturn -EINVAL;\r\nres = issue_thinkpad_cmos_command(cmos_cmd);\r\nreturn (res)? res : count;\r\n}\r\nstatic int __init cmos_init(struct ibm_init_struct *iibm)\r\n{\r\nint res;\r\nvdbg_printk(TPACPI_DBG_INIT,\r\n"initializing cmos commands subdriver\n");\r\nTPACPI_ACPIHANDLE_INIT(cmos);\r\nvdbg_printk(TPACPI_DBG_INIT, "cmos commands are %s\n",\r\nstr_supported(cmos_handle != NULL));\r\nres = device_create_file(&tpacpi_pdev->dev, &dev_attr_cmos_command);\r\nif (res)\r\nreturn res;\r\nreturn (cmos_handle)? 0 : 1;\r\n}\r\nstatic void cmos_exit(void)\r\n{\r\ndevice_remove_file(&tpacpi_pdev->dev, &dev_attr_cmos_command);\r\n}\r\nstatic int cmos_read(struct seq_file *m)\r\n{\r\nif (!cmos_handle)\r\nseq_printf(m, "status:\t\tnot supported\n");\r\nelse {\r\nseq_printf(m, "status:\t\tsupported\n");\r\nseq_printf(m, "commands:\t<cmd> (<cmd> is 0-21)\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int cmos_write(char *buf)\r\n{\r\nchar *cmd;\r\nint cmos_cmd, res;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (sscanf(cmd, "%u", &cmos_cmd) == 1 &&\r\ncmos_cmd >= 0 && cmos_cmd <= 21) {\r\n} else\r\nreturn -EINVAL;\r\nres = issue_thinkpad_cmos_command(cmos_cmd);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline bool tpacpi_is_led_restricted(const unsigned int led)\r\n{\r\n#ifdef CONFIG_THINKPAD_ACPI_UNSAFE_LEDS\r\nreturn false;\r\n#else\r\nreturn (1U & (TPACPI_SAFE_LEDS >> led)) == 0;\r\n#endif\r\n}\r\nstatic int led_get_status(const unsigned int led)\r\n{\r\nint status;\r\nenum led_status_t led_s;\r\nswitch (led_supported) {\r\ncase TPACPI_LED_570:\r\nif (!acpi_evalf(ec_handle,\r\n&status, "GLED", "dd", 1 << led))\r\nreturn -EIO;\r\nled_s = (status == 0)?\r\nTPACPI_LED_OFF :\r\n((status == 1)?\r\nTPACPI_LED_ON :\r\nTPACPI_LED_BLINK);\r\ntpacpi_led_state_cache[led] = led_s;\r\nreturn led_s;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\n}\r\nstatic int led_set_status(const unsigned int led,\r\nconst enum led_status_t ledstatus)\r\n{\r\nstatic const unsigned int led_sled_arg1[] = { 0, 1, 3 };\r\nstatic const unsigned int led_led_arg1[] = { 0, 0x80, 0xc0 };\r\nint rc = 0;\r\nswitch (led_supported) {\r\ncase TPACPI_LED_570:\r\nif (unlikely(led > 7))\r\nreturn -EINVAL;\r\nif (unlikely(tpacpi_is_led_restricted(led)))\r\nreturn -EPERM;\r\nif (!acpi_evalf(led_handle, NULL, NULL, "vdd",\r\n(1 << led), led_sled_arg1[ledstatus]))\r\nrc = -EIO;\r\nbreak;\r\ncase TPACPI_LED_OLD:\r\nif (unlikely(led > 7))\r\nreturn -EINVAL;\r\nif (unlikely(tpacpi_is_led_restricted(led)))\r\nreturn -EPERM;\r\nrc = ec_write(TPACPI_LED_EC_HLMS, (1 << led));\r\nif (rc >= 0)\r\nrc = ec_write(TPACPI_LED_EC_HLBL,\r\n(ledstatus == TPACPI_LED_BLINK) << led);\r\nif (rc >= 0)\r\nrc = ec_write(TPACPI_LED_EC_HLCL,\r\n(ledstatus != TPACPI_LED_OFF) << led);\r\nbreak;\r\ncase TPACPI_LED_NEW:\r\nif (unlikely(led >= TPACPI_LED_NUMLEDS))\r\nreturn -EINVAL;\r\nif (unlikely(tpacpi_is_led_restricted(led)))\r\nreturn -EPERM;\r\nif (!acpi_evalf(led_handle, NULL, NULL, "vdd",\r\nled, led_led_arg1[ledstatus]))\r\nrc = -EIO;\r\nbreak;\r\ndefault:\r\nrc = -ENXIO;\r\n}\r\nif (!rc)\r\ntpacpi_led_state_cache[led] = ledstatus;\r\nreturn rc;\r\n}\r\nstatic void led_set_status_worker(struct work_struct *work)\r\n{\r\nstruct tpacpi_led_classdev *data =\r\ncontainer_of(work, struct tpacpi_led_classdev, work);\r\nif (likely(tpacpi_lifecycle == TPACPI_LIFE_RUNNING))\r\nled_set_status(data->led, data->new_state);\r\n}\r\nstatic void led_sysfs_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct tpacpi_led_classdev *data = container_of(led_cdev,\r\nstruct tpacpi_led_classdev, led_classdev);\r\nif (brightness == LED_OFF)\r\ndata->new_state = TPACPI_LED_OFF;\r\nelse if (tpacpi_led_state_cache[data->led] != TPACPI_LED_BLINK)\r\ndata->new_state = TPACPI_LED_ON;\r\nelse\r\ndata->new_state = TPACPI_LED_BLINK;\r\nqueue_work(tpacpi_wq, &data->work);\r\n}\r\nstatic int led_sysfs_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on, unsigned long *delay_off)\r\n{\r\nstruct tpacpi_led_classdev *data = container_of(led_cdev,\r\nstruct tpacpi_led_classdev, led_classdev);\r\nif (*delay_on == 0 && *delay_off == 0) {\r\n*delay_on = 500;\r\n*delay_off = 500;\r\n} else if ((*delay_on != 500) || (*delay_off != 500))\r\nreturn -EINVAL;\r\ndata->new_state = TPACPI_LED_BLINK;\r\nqueue_work(tpacpi_wq, &data->work);\r\nreturn 0;\r\n}\r\nstatic enum led_brightness led_sysfs_get(struct led_classdev *led_cdev)\r\n{\r\nint rc;\r\nstruct tpacpi_led_classdev *data = container_of(led_cdev,\r\nstruct tpacpi_led_classdev, led_classdev);\r\nrc = led_get_status(data->led);\r\nif (rc == TPACPI_LED_OFF || rc < 0)\r\nrc = LED_OFF;\r\nelse\r\nrc = LED_FULL;\r\nreturn rc;\r\n}\r\nstatic void led_exit(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < TPACPI_LED_NUMLEDS; i++) {\r\nif (tpacpi_leds[i].led_classdev.name)\r\nled_classdev_unregister(&tpacpi_leds[i].led_classdev);\r\n}\r\nflush_workqueue(tpacpi_wq);\r\nkfree(tpacpi_leds);\r\n}\r\nstatic int __init tpacpi_init_led(unsigned int led)\r\n{\r\nint rc;\r\ntpacpi_leds[led].led = led;\r\nif (!tpacpi_led_names[led])\r\nreturn 0;\r\ntpacpi_leds[led].led_classdev.brightness_set = &led_sysfs_set;\r\ntpacpi_leds[led].led_classdev.blink_set = &led_sysfs_blink_set;\r\nif (led_supported == TPACPI_LED_570)\r\ntpacpi_leds[led].led_classdev.brightness_get =\r\n&led_sysfs_get;\r\ntpacpi_leds[led].led_classdev.name = tpacpi_led_names[led];\r\nINIT_WORK(&tpacpi_leds[led].work, led_set_status_worker);\r\nrc = led_classdev_register(&tpacpi_pdev->dev,\r\n&tpacpi_leds[led].led_classdev);\r\nif (rc < 0)\r\ntpacpi_leds[led].led_classdev.name = NULL;\r\nreturn rc;\r\n}\r\nstatic enum led_access_mode __init led_init_detect_mode(void)\r\n{\r\nacpi_status status;\r\nif (tpacpi_is_ibm()) {\r\nstatus = acpi_get_handle(ec_handle, "SLED", &led_handle);\r\nif (ACPI_SUCCESS(status))\r\nreturn TPACPI_LED_570;\r\nstatus = acpi_get_handle(ec_handle, "SYSL", &led_handle);\r\nif (ACPI_SUCCESS(status))\r\nreturn TPACPI_LED_OLD;\r\n}\r\nstatus = acpi_get_handle(ec_handle, "LED", &led_handle);\r\nif (ACPI_SUCCESS(status))\r\nreturn TPACPI_LED_NEW;\r\nled_handle = NULL;\r\nreturn TPACPI_LED_NONE;\r\n}\r\nstatic int __init led_init(struct ibm_init_struct *iibm)\r\n{\r\nunsigned int i;\r\nint rc;\r\nunsigned long useful_leds;\r\nvdbg_printk(TPACPI_DBG_INIT, "initializing LED subdriver\n");\r\nled_supported = led_init_detect_mode();\r\nvdbg_printk(TPACPI_DBG_INIT, "LED commands are %s, mode %d\n",\r\nstr_supported(led_supported), led_supported);\r\nif (led_supported == TPACPI_LED_NONE)\r\nreturn 1;\r\ntpacpi_leds = kzalloc(sizeof(*tpacpi_leds) * TPACPI_LED_NUMLEDS,\r\nGFP_KERNEL);\r\nif (!tpacpi_leds) {\r\npr_err("Out of memory for LED data\n");\r\nreturn -ENOMEM;\r\n}\r\nuseful_leds = tpacpi_check_quirks(led_useful_qtable,\r\nARRAY_SIZE(led_useful_qtable));\r\nfor (i = 0; i < TPACPI_LED_NUMLEDS; i++) {\r\nif (!tpacpi_is_led_restricted(i) &&\r\ntest_bit(i, &useful_leds)) {\r\nrc = tpacpi_init_led(i);\r\nif (rc < 0) {\r\nled_exit();\r\nreturn rc;\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_THINKPAD_ACPI_UNSAFE_LEDS\r\npr_notice("warning: userspace override of important "\r\n"firmware LEDs is enabled\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int led_read(struct seq_file *m)\r\n{\r\nif (!led_supported) {\r\nseq_printf(m, "status:\t\tnot supported\n");\r\nreturn 0;\r\n}\r\nseq_printf(m, "status:\t\tsupported\n");\r\nif (led_supported == TPACPI_LED_570) {\r\nint i, status;\r\nfor (i = 0; i < 8; i++) {\r\nstatus = led_get_status(i);\r\nif (status < 0)\r\nreturn -EIO;\r\nseq_printf(m, "%d:\t\t%s\n",\r\ni, str_led_status(status));\r\n}\r\n}\r\nseq_printf(m, "commands:\t"\r\n"<led> on, <led> off, <led> blink (<led> is 0-15)\n");\r\nreturn 0;\r\n}\r\nstatic int led_write(char *buf)\r\n{\r\nchar *cmd;\r\nint led, rc;\r\nenum led_status_t s;\r\nif (!led_supported)\r\nreturn -ENODEV;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (sscanf(cmd, "%d", &led) != 1 || led < 0 || led > 15)\r\nreturn -EINVAL;\r\nif (strstr(cmd, "off")) {\r\ns = TPACPI_LED_OFF;\r\n} else if (strstr(cmd, "on")) {\r\ns = TPACPI_LED_ON;\r\n} else if (strstr(cmd, "blink")) {\r\ns = TPACPI_LED_BLINK;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nrc = led_set_status(led, s);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init beep_init(struct ibm_init_struct *iibm)\r\n{\r\nunsigned long quirks;\r\nvdbg_printk(TPACPI_DBG_INIT, "initializing beep subdriver\n");\r\nTPACPI_ACPIHANDLE_INIT(beep);\r\nvdbg_printk(TPACPI_DBG_INIT, "beep is %s\n",\r\nstr_supported(beep_handle != NULL));\r\nquirks = tpacpi_check_quirks(beep_quirk_table,\r\nARRAY_SIZE(beep_quirk_table));\r\ntp_features.beep_needs_two_args = !!(quirks & TPACPI_BEEP_Q1);\r\nreturn (beep_handle)? 0 : 1;\r\n}\r\nstatic int beep_read(struct seq_file *m)\r\n{\r\nif (!beep_handle)\r\nseq_printf(m, "status:\t\tnot supported\n");\r\nelse {\r\nseq_printf(m, "status:\t\tsupported\n");\r\nseq_printf(m, "commands:\t<cmd> (<cmd> is 0-17)\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int beep_write(char *buf)\r\n{\r\nchar *cmd;\r\nint beep_cmd;\r\nif (!beep_handle)\r\nreturn -ENODEV;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (sscanf(cmd, "%u", &beep_cmd) == 1 &&\r\nbeep_cmd >= 0 && beep_cmd <= 17) {\r\n} else\r\nreturn -EINVAL;\r\nif (tp_features.beep_needs_two_args) {\r\nif (!acpi_evalf(beep_handle, NULL, NULL, "vdd",\r\nbeep_cmd, 0))\r\nreturn -EIO;\r\n} else {\r\nif (!acpi_evalf(beep_handle, NULL, NULL, "vd",\r\nbeep_cmd))\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int thermal_get_sensor(int idx, s32 *value)\r\n{\r\nint t;\r\ns8 tmp;\r\nchar tmpi[5];\r\nt = TP_EC_THERMAL_TMP0;\r\nswitch (thermal_read_mode) {\r\n#if TPACPI_MAX_THERMAL_SENSORS >= 16\r\ncase TPACPI_THERMAL_TPEC_16:\r\nif (idx >= 8 && idx <= 15) {\r\nt = TP_EC_THERMAL_TMP8;\r\nidx -= 8;\r\n}\r\n#endif\r\ncase TPACPI_THERMAL_TPEC_8:\r\nif (idx <= 7) {\r\nif (!acpi_ec_read(t + idx, &tmp))\r\nreturn -EIO;\r\n*value = tmp * 1000;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase TPACPI_THERMAL_ACPI_UPDT:\r\nif (idx <= 7) {\r\nsnprintf(tmpi, sizeof(tmpi), "TMP%c", '0' + idx);\r\nif (!acpi_evalf(ec_handle, NULL, "UPDT", "v"))\r\nreturn -EIO;\r\nif (!acpi_evalf(ec_handle, &t, tmpi, "d"))\r\nreturn -EIO;\r\n*value = (t - 2732) * 100;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase TPACPI_THERMAL_ACPI_TMP07:\r\nif (idx <= 7) {\r\nsnprintf(tmpi, sizeof(tmpi), "TMP%c", '0' + idx);\r\nif (!acpi_evalf(ec_handle, &t, tmpi, "d"))\r\nreturn -EIO;\r\nif (t > 127 || t < -127)\r\nt = TP_EC_THERMAL_TMP_NA;\r\n*value = t * 1000;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase TPACPI_THERMAL_NONE:\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int thermal_get_sensors(struct ibm_thermal_sensors_struct *s)\r\n{\r\nint res, i;\r\nint n;\r\nn = 8;\r\ni = 0;\r\nif (!s)\r\nreturn -EINVAL;\r\nif (thermal_read_mode == TPACPI_THERMAL_TPEC_16)\r\nn = 16;\r\nfor (i = 0 ; i < n; i++) {\r\nres = thermal_get_sensor(i, &s->temp[i]);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn n;\r\n}\r\nstatic void thermal_dump_all_sensors(void)\r\n{\r\nint n, i;\r\nstruct ibm_thermal_sensors_struct t;\r\nn = thermal_get_sensors(&t);\r\nif (n <= 0)\r\nreturn;\r\npr_notice("temperatures (Celsius):");\r\nfor (i = 0; i < n; i++) {\r\nif (t.temp[i] != TPACPI_THERMAL_SENSOR_NA)\r\npr_cont(" %d", (int)(t.temp[i] / 1000));\r\nelse\r\npr_cont(" N/A");\r\n}\r\npr_cont("\n");\r\n}\r\nstatic ssize_t thermal_temp_input_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr =\r\nto_sensor_dev_attr(attr);\r\nint idx = sensor_attr->index;\r\ns32 value;\r\nint res;\r\nres = thermal_get_sensor(idx, &value);\r\nif (res)\r\nreturn res;\r\nif (value == TPACPI_THERMAL_SENSOR_NA)\r\nreturn -ENXIO;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic int __init thermal_init(struct ibm_init_struct *iibm)\r\n{\r\nu8 t, ta1, ta2;\r\nint i;\r\nint acpi_tmp7;\r\nint res;\r\nvdbg_printk(TPACPI_DBG_INIT, "initializing thermal subdriver\n");\r\nacpi_tmp7 = acpi_evalf(ec_handle, NULL, "TMP7", "qv");\r\nif (thinkpad_id.ec_model) {\r\nta1 = ta2 = 0;\r\nfor (i = 0; i < 8; i++) {\r\nif (acpi_ec_read(TP_EC_THERMAL_TMP0 + i, &t)) {\r\nta1 |= t;\r\n} else {\r\nta1 = 0;\r\nbreak;\r\n}\r\nif (acpi_ec_read(TP_EC_THERMAL_TMP8 + i, &t)) {\r\nta2 |= t;\r\n} else {\r\nta1 = 0;\r\nbreak;\r\n}\r\n}\r\nif (ta1 == 0) {\r\nif (acpi_tmp7) {\r\npr_err("ThinkPad ACPI EC access misbehaving, "\r\n"falling back to ACPI TMPx access "\r\n"mode\n");\r\nthermal_read_mode = TPACPI_THERMAL_ACPI_TMP07;\r\n} else {\r\npr_err("ThinkPad ACPI EC access misbehaving, "\r\n"disabling thermal sensors access\n");\r\nthermal_read_mode = TPACPI_THERMAL_NONE;\r\n}\r\n} else {\r\nthermal_read_mode =\r\n(ta2 != 0) ?\r\nTPACPI_THERMAL_TPEC_16 : TPACPI_THERMAL_TPEC_8;\r\n}\r\n} else if (acpi_tmp7) {\r\nif (tpacpi_is_ibm() &&\r\nacpi_evalf(ec_handle, NULL, "UPDT", "qv")) {\r\nthermal_read_mode = TPACPI_THERMAL_ACPI_UPDT;\r\n} else {\r\nthermal_read_mode = TPACPI_THERMAL_ACPI_TMP07;\r\n}\r\n} else {\r\nthermal_read_mode = TPACPI_THERMAL_NONE;\r\n}\r\nvdbg_printk(TPACPI_DBG_INIT, "thermal is %s, mode %d\n",\r\nstr_supported(thermal_read_mode != TPACPI_THERMAL_NONE),\r\nthermal_read_mode);\r\nswitch (thermal_read_mode) {\r\ncase TPACPI_THERMAL_TPEC_16:\r\nres = sysfs_create_group(&tpacpi_sensors_pdev->dev.kobj,\r\n&thermal_temp_input16_group);\r\nif (res)\r\nreturn res;\r\nbreak;\r\ncase TPACPI_THERMAL_TPEC_8:\r\ncase TPACPI_THERMAL_ACPI_TMP07:\r\ncase TPACPI_THERMAL_ACPI_UPDT:\r\nres = sysfs_create_group(&tpacpi_sensors_pdev->dev.kobj,\r\n&thermal_temp_input8_group);\r\nif (res)\r\nreturn res;\r\nbreak;\r\ncase TPACPI_THERMAL_NONE:\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void thermal_exit(void)\r\n{\r\nswitch (thermal_read_mode) {\r\ncase TPACPI_THERMAL_TPEC_16:\r\nsysfs_remove_group(&tpacpi_sensors_pdev->dev.kobj,\r\n&thermal_temp_input16_group);\r\nbreak;\r\ncase TPACPI_THERMAL_TPEC_8:\r\ncase TPACPI_THERMAL_ACPI_TMP07:\r\ncase TPACPI_THERMAL_ACPI_UPDT:\r\nsysfs_remove_group(&tpacpi_sensors_pdev->dev.kobj,\r\n&thermal_temp_input8_group);\r\nbreak;\r\ncase TPACPI_THERMAL_NONE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int thermal_read(struct seq_file *m)\r\n{\r\nint n, i;\r\nstruct ibm_thermal_sensors_struct t;\r\nn = thermal_get_sensors(&t);\r\nif (unlikely(n < 0))\r\nreturn n;\r\nseq_printf(m, "temperatures:\t");\r\nif (n > 0) {\r\nfor (i = 0; i < (n - 1); i++)\r\nseq_printf(m, "%d ", t.temp[i] / 1000);\r\nseq_printf(m, "%d\n", t.temp[i] / 1000);\r\n} else\r\nseq_printf(m, "not supported\n");\r\nreturn 0;\r\n}\r\nstatic unsigned int tpacpi_brightness_nvram_get(void)\r\n{\r\nu8 lnvram;\r\nlnvram = (nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS)\r\n& TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\r\n>> TP_NVRAM_POS_LEVEL_BRIGHTNESS;\r\nlnvram &= bright_maxlvl;\r\nreturn lnvram;\r\n}\r\nstatic void tpacpi_brightness_checkpoint_nvram(void)\r\n{\r\nu8 lec = 0;\r\nu8 b_nvram;\r\nif (brightness_mode != TPACPI_BRGHT_MODE_ECNVRAM)\r\nreturn;\r\nvdbg_printk(TPACPI_DBG_BRGHT,\r\n"trying to checkpoint backlight level to NVRAM...\n");\r\nif (mutex_lock_killable(&brightness_mutex) < 0)\r\nreturn;\r\nif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\r\ngoto unlock;\r\nlec &= TP_EC_BACKLIGHT_LVLMSK;\r\nb_nvram = nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS);\r\nif (lec != ((b_nvram & TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\r\n>> TP_NVRAM_POS_LEVEL_BRIGHTNESS)) {\r\nb_nvram &= ~(TP_NVRAM_MASK_LEVEL_BRIGHTNESS <<\r\nTP_NVRAM_POS_LEVEL_BRIGHTNESS);\r\nb_nvram |= lec;\r\nnvram_write_byte(b_nvram, TP_NVRAM_ADDR_BRIGHTNESS);\r\ndbg_printk(TPACPI_DBG_BRGHT,\r\n"updated NVRAM backlight level to %u (0x%02x)\n",\r\n(unsigned int) lec, (unsigned int) b_nvram);\r\n} else\r\nvdbg_printk(TPACPI_DBG_BRGHT,\r\n"NVRAM backlight level already is %u (0x%02x)\n",\r\n(unsigned int) lec, (unsigned int) b_nvram);\r\nunlock:\r\nmutex_unlock(&brightness_mutex);\r\n}\r\nstatic int tpacpi_brightness_get_raw(int *status)\r\n{\r\nu8 lec = 0;\r\nswitch (brightness_mode) {\r\ncase TPACPI_BRGHT_MODE_UCMS_STEP:\r\n*status = tpacpi_brightness_nvram_get();\r\nreturn 0;\r\ncase TPACPI_BRGHT_MODE_EC:\r\ncase TPACPI_BRGHT_MODE_ECNVRAM:\r\nif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\r\nreturn -EIO;\r\n*status = lec;\r\nreturn 0;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\n}\r\nstatic int tpacpi_brightness_set_ec(unsigned int value)\r\n{\r\nu8 lec = 0;\r\nif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\r\nreturn -EIO;\r\nif (unlikely(!acpi_ec_write(TP_EC_BACKLIGHT,\r\n(lec & TP_EC_BACKLIGHT_CMDMSK) |\r\n(value & TP_EC_BACKLIGHT_LVLMSK))))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int tpacpi_brightness_set_ucmsstep(unsigned int value)\r\n{\r\nint cmos_cmd, inc;\r\nunsigned int current_value, i;\r\ncurrent_value = tpacpi_brightness_nvram_get();\r\nif (value == current_value)\r\nreturn 0;\r\ncmos_cmd = (value > current_value) ?\r\nTP_CMOS_BRIGHTNESS_UP :\r\nTP_CMOS_BRIGHTNESS_DOWN;\r\ninc = (value > current_value) ? 1 : -1;\r\nfor (i = current_value; i != value; i += inc)\r\nif (issue_thinkpad_cmos_command(cmos_cmd))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int brightness_set(unsigned int value)\r\n{\r\nint res;\r\nif (value > bright_maxlvl || value < 0)\r\nreturn -EINVAL;\r\nvdbg_printk(TPACPI_DBG_BRGHT,\r\n"set backlight level to %d\n", value);\r\nres = mutex_lock_killable(&brightness_mutex);\r\nif (res < 0)\r\nreturn res;\r\nswitch (brightness_mode) {\r\ncase TPACPI_BRGHT_MODE_EC:\r\ncase TPACPI_BRGHT_MODE_ECNVRAM:\r\nres = tpacpi_brightness_set_ec(value);\r\nbreak;\r\ncase TPACPI_BRGHT_MODE_UCMS_STEP:\r\nres = tpacpi_brightness_set_ucmsstep(value);\r\nbreak;\r\ndefault:\r\nres = -ENXIO;\r\n}\r\nmutex_unlock(&brightness_mutex);\r\nreturn res;\r\n}\r\nstatic int brightness_update_status(struct backlight_device *bd)\r\n{\r\nunsigned int level =\r\n(bd->props.fb_blank == FB_BLANK_UNBLANK &&\r\nbd->props.power == FB_BLANK_UNBLANK) ?\r\nbd->props.brightness : 0;\r\ndbg_printk(TPACPI_DBG_BRGHT,\r\n"backlight: attempt to set level to %d\n",\r\nlevel);\r\nreturn brightness_set(level);\r\n}\r\nstatic int brightness_get(struct backlight_device *bd)\r\n{\r\nint status, res;\r\nres = mutex_lock_killable(&brightness_mutex);\r\nif (res < 0)\r\nreturn 0;\r\nres = tpacpi_brightness_get_raw(&status);\r\nmutex_unlock(&brightness_mutex);\r\nif (res < 0)\r\nreturn 0;\r\nreturn status & TP_EC_BACKLIGHT_LVLMSK;\r\n}\r\nstatic void tpacpi_brightness_notify_change(void)\r\n{\r\nbacklight_force_update(ibm_backlight_device,\r\nBACKLIGHT_UPDATE_HOTKEY);\r\n}\r\nstatic int __init tpacpi_query_bcl_levels(acpi_handle handle)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nint rc;\r\nif (ACPI_SUCCESS(acpi_evaluate_object(handle, "_BCL", NULL, &buffer))) {\r\nobj = (union acpi_object *)buffer.pointer;\r\nif (!obj || (obj->type != ACPI_TYPE_PACKAGE)) {\r\npr_err("Unknown _BCL data, please report this to %s\n",\r\nTPACPI_MAIL);\r\nrc = 0;\r\n} else {\r\nrc = obj->package.count;\r\n}\r\n} else {\r\nreturn 0;\r\n}\r\nkfree(buffer.pointer);\r\nreturn rc;\r\n}\r\nstatic unsigned int __init tpacpi_check_std_acpi_brightness_support(void)\r\n{\r\nacpi_handle video_device;\r\nint bcl_levels = 0;\r\ntpacpi_acpi_handle_locate("video", ACPI_VIDEO_HID, &video_device);\r\nif (video_device)\r\nbcl_levels = tpacpi_query_bcl_levels(video_device);\r\ntp_features.bright_acpimode = (bcl_levels > 0);\r\nreturn (bcl_levels > 2) ? (bcl_levels - 2) : 0;\r\n}\r\nstatic void __init tpacpi_detect_brightness_capabilities(void)\r\n{\r\nunsigned int b;\r\nvdbg_printk(TPACPI_DBG_INIT,\r\n"detecting firmware brightness interface capabilities\n");\r\nb = tpacpi_check_std_acpi_brightness_support();\r\nswitch (b) {\r\ncase 16:\r\nbright_maxlvl = 15;\r\npr_info("detected a 16-level brightness capable ThinkPad\n");\r\nbreak;\r\ncase 8:\r\ncase 0:\r\nbright_maxlvl = 7;\r\npr_info("detected a 8-level brightness capable ThinkPad\n");\r\nbreak;\r\ndefault:\r\npr_err("Unsupported brightness interface, "\r\n"please contact %s\n", TPACPI_MAIL);\r\ntp_features.bright_unkfw = 1;\r\nbright_maxlvl = b - 1;\r\n}\r\n}\r\nstatic int __init brightness_init(struct ibm_init_struct *iibm)\r\n{\r\nstruct backlight_properties props;\r\nint b;\r\nunsigned long quirks;\r\nvdbg_printk(TPACPI_DBG_INIT, "initializing brightness subdriver\n");\r\nmutex_init(&brightness_mutex);\r\nquirks = tpacpi_check_quirks(brightness_quirk_table,\r\nARRAY_SIZE(brightness_quirk_table));\r\nif (tp_features.bright_unkfw)\r\nreturn 1;\r\nif (!brightness_enable) {\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\r\n"brightness support disabled by "\r\n"module parameter\n");\r\nreturn 1;\r\n}\r\nif (acpi_video_backlight_support()) {\r\nif (brightness_enable > 1) {\r\npr_info("Standard ACPI backlight interface "\r\n"available, not loading native one\n");\r\nreturn 1;\r\n} else if (brightness_enable == 1) {\r\npr_warn("Cannot enable backlight brightness support, "\r\n"ACPI is already handling it. Refer to the "\r\n"acpi_backlight kernel parameter.\n");\r\nreturn 1;\r\n}\r\n} else if (tp_features.bright_acpimode && brightness_enable > 1) {\r\npr_notice("Standard ACPI backlight interface not "\r\n"available, thinkpad_acpi native "\r\n"brightness control enabled\n");\r\n}\r\nif (brightness_mode > TPACPI_BRGHT_MODE_MAX)\r\nreturn -EINVAL;\r\nif (brightness_mode == TPACPI_BRGHT_MODE_AUTO ||\r\nbrightness_mode == TPACPI_BRGHT_MODE_MAX) {\r\nif (quirks & TPACPI_BRGHT_Q_EC)\r\nbrightness_mode = TPACPI_BRGHT_MODE_ECNVRAM;\r\nelse\r\nbrightness_mode = TPACPI_BRGHT_MODE_UCMS_STEP;\r\ndbg_printk(TPACPI_DBG_BRGHT,\r\n"driver auto-selected brightness_mode=%d\n",\r\nbrightness_mode);\r\n}\r\nif (!tpacpi_is_ibm() &&\r\n(brightness_mode == TPACPI_BRGHT_MODE_ECNVRAM ||\r\nbrightness_mode == TPACPI_BRGHT_MODE_EC))\r\nreturn -EINVAL;\r\nif (tpacpi_brightness_get_raw(&b) < 0)\r\nreturn 1;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = bright_maxlvl;\r\nprops.brightness = b & TP_EC_BACKLIGHT_LVLMSK;\r\nibm_backlight_device = backlight_device_register(TPACPI_BACKLIGHT_DEV_NAME,\r\nNULL, NULL,\r\n&ibm_backlight_data,\r\n&props);\r\nif (IS_ERR(ibm_backlight_device)) {\r\nint rc = PTR_ERR(ibm_backlight_device);\r\nibm_backlight_device = NULL;\r\npr_err("Could not register backlight device\n");\r\nreturn rc;\r\n}\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\r\n"brightness is supported\n");\r\nif (quirks & TPACPI_BRGHT_Q_ASK) {\r\npr_notice("brightness: will use unverified default: "\r\n"brightness_mode=%d\n", brightness_mode);\r\npr_notice("brightness: please report to %s whether it works well "\r\n"or not on your ThinkPad\n", TPACPI_MAIL);\r\n}\r\nbacklight_update_status(ibm_backlight_device);\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\r\n"brightness: registering brightness hotkeys "\r\n"as change notification\n");\r\ntpacpi_hotkey_driver_mask_set(hotkey_driver_mask\r\n| TP_ACPI_HKEY_BRGHTUP_MASK\r\n| TP_ACPI_HKEY_BRGHTDWN_MASK);\r\nreturn 0;\r\n}\r\nstatic void brightness_suspend(void)\r\n{\r\ntpacpi_brightness_checkpoint_nvram();\r\n}\r\nstatic void brightness_shutdown(void)\r\n{\r\ntpacpi_brightness_checkpoint_nvram();\r\n}\r\nstatic void brightness_exit(void)\r\n{\r\nif (ibm_backlight_device) {\r\nvdbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_BRGHT,\r\n"calling backlight_device_unregister()\n");\r\nbacklight_device_unregister(ibm_backlight_device);\r\n}\r\ntpacpi_brightness_checkpoint_nvram();\r\n}\r\nstatic int brightness_read(struct seq_file *m)\r\n{\r\nint level;\r\nlevel = brightness_get(NULL);\r\nif (level < 0) {\r\nseq_printf(m, "level:\t\tunreadable\n");\r\n} else {\r\nseq_printf(m, "level:\t\t%d\n", level);\r\nseq_printf(m, "commands:\tup, down\n");\r\nseq_printf(m, "commands:\tlevel <level> (<level> is 0-%d)\n",\r\nbright_maxlvl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int brightness_write(char *buf)\r\n{\r\nint level;\r\nint rc;\r\nchar *cmd;\r\nlevel = brightness_get(NULL);\r\nif (level < 0)\r\nreturn level;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (strlencmp(cmd, "up") == 0) {\r\nif (level < bright_maxlvl)\r\nlevel++;\r\n} else if (strlencmp(cmd, "down") == 0) {\r\nif (level > 0)\r\nlevel--;\r\n} else if (sscanf(cmd, "level %d", &level) == 1 &&\r\nlevel >= 0 && level <= bright_maxlvl) {\r\n} else\r\nreturn -EINVAL;\r\n}\r\ntpacpi_disclose_usertask("procfs brightness",\r\n"set level to %d\n", level);\r\nrc = brightness_set(level);\r\nif (!rc && ibm_backlight_device)\r\nbacklight_force_update(ibm_backlight_device,\r\nBACKLIGHT_UPDATE_SYSFS);\r\nreturn (rc == -EINTR)? -ERESTARTSYS : rc;\r\n}\r\nstatic void tpacpi_volume_checkpoint_nvram(void)\r\n{\r\nu8 lec = 0;\r\nu8 b_nvram;\r\nu8 ec_mask;\r\nif (volume_mode != TPACPI_VOL_MODE_ECNVRAM)\r\nreturn;\r\nif (!volume_control_allowed)\r\nreturn;\r\nvdbg_printk(TPACPI_DBG_MIXER,\r\n"trying to checkpoint mixer state to NVRAM...\n");\r\nif (tp_features.mixer_no_level_control)\r\nec_mask = TP_EC_AUDIO_MUTESW_MSK;\r\nelse\r\nec_mask = TP_EC_AUDIO_MUTESW_MSK | TP_EC_AUDIO_LVL_MSK;\r\nif (mutex_lock_killable(&volume_mutex) < 0)\r\nreturn;\r\nif (unlikely(!acpi_ec_read(TP_EC_AUDIO, &lec)))\r\ngoto unlock;\r\nlec &= ec_mask;\r\nb_nvram = nvram_read_byte(TP_NVRAM_ADDR_MIXER);\r\nif (lec != (b_nvram & ec_mask)) {\r\nb_nvram &= ~ec_mask;\r\nb_nvram |= lec;\r\nnvram_write_byte(b_nvram, TP_NVRAM_ADDR_MIXER);\r\ndbg_printk(TPACPI_DBG_MIXER,\r\n"updated NVRAM mixer status to 0x%02x (0x%02x)\n",\r\n(unsigned int) lec, (unsigned int) b_nvram);\r\n} else {\r\nvdbg_printk(TPACPI_DBG_MIXER,\r\n"NVRAM mixer status already is 0x%02x (0x%02x)\n",\r\n(unsigned int) lec, (unsigned int) b_nvram);\r\n}\r\nunlock:\r\nmutex_unlock(&volume_mutex);\r\n}\r\nstatic int volume_get_status_ec(u8 *status)\r\n{\r\nu8 s;\r\nif (!acpi_ec_read(TP_EC_AUDIO, &s))\r\nreturn -EIO;\r\n*status = s;\r\ndbg_printk(TPACPI_DBG_MIXER, "status 0x%02x\n", s);\r\nreturn 0;\r\n}\r\nstatic int volume_get_status(u8 *status)\r\n{\r\nreturn volume_get_status_ec(status);\r\n}\r\nstatic int volume_set_status_ec(const u8 status)\r\n{\r\nif (!acpi_ec_write(TP_EC_AUDIO, status))\r\nreturn -EIO;\r\ndbg_printk(TPACPI_DBG_MIXER, "set EC mixer to 0x%02x\n", status);\r\nreturn 0;\r\n}\r\nstatic int volume_set_status(const u8 status)\r\n{\r\nreturn volume_set_status_ec(status);\r\n}\r\nstatic int __volume_set_mute_ec(const bool mute)\r\n{\r\nint rc;\r\nu8 s, n;\r\nif (mutex_lock_killable(&volume_mutex) < 0)\r\nreturn -EINTR;\r\nrc = volume_get_status_ec(&s);\r\nif (rc)\r\ngoto unlock;\r\nn = (mute) ? s | TP_EC_AUDIO_MUTESW_MSK :\r\ns & ~TP_EC_AUDIO_MUTESW_MSK;\r\nif (n != s) {\r\nrc = volume_set_status_ec(n);\r\nif (!rc)\r\nrc = 1;\r\n}\r\nunlock:\r\nmutex_unlock(&volume_mutex);\r\nreturn rc;\r\n}\r\nstatic int volume_alsa_set_mute(const bool mute)\r\n{\r\ndbg_printk(TPACPI_DBG_MIXER, "ALSA: trying to %smute\n",\r\n(mute) ? "" : "un");\r\nreturn __volume_set_mute_ec(mute);\r\n}\r\nstatic int volume_set_mute(const bool mute)\r\n{\r\nint rc;\r\ndbg_printk(TPACPI_DBG_MIXER, "trying to %smute\n",\r\n(mute) ? "" : "un");\r\nrc = __volume_set_mute_ec(mute);\r\nreturn (rc < 0) ? rc : 0;\r\n}\r\nstatic int __volume_set_volume_ec(const u8 vol)\r\n{\r\nint rc;\r\nu8 s, n;\r\nif (vol > TP_EC_VOLUME_MAX)\r\nreturn -EINVAL;\r\nif (mutex_lock_killable(&volume_mutex) < 0)\r\nreturn -EINTR;\r\nrc = volume_get_status_ec(&s);\r\nif (rc)\r\ngoto unlock;\r\nn = (s & ~TP_EC_AUDIO_LVL_MSK) | vol;\r\nif (n != s) {\r\nrc = volume_set_status_ec(n);\r\nif (!rc)\r\nrc = 1;\r\n}\r\nunlock:\r\nmutex_unlock(&volume_mutex);\r\nreturn rc;\r\n}\r\nstatic int volume_alsa_set_volume(const u8 vol)\r\n{\r\ndbg_printk(TPACPI_DBG_MIXER,\r\n"ALSA: trying to set volume level to %hu\n", vol);\r\nreturn __volume_set_volume_ec(vol);\r\n}\r\nstatic void volume_alsa_notify_change(void)\r\n{\r\nstruct tpacpi_alsa_data *d;\r\nif (alsa_card && alsa_card->private_data) {\r\nd = alsa_card->private_data;\r\nif (d->ctl_mute_id)\r\nsnd_ctl_notify(alsa_card,\r\nSNDRV_CTL_EVENT_MASK_VALUE,\r\nd->ctl_mute_id);\r\nif (d->ctl_vol_id)\r\nsnd_ctl_notify(alsa_card,\r\nSNDRV_CTL_EVENT_MASK_VALUE,\r\nd->ctl_vol_id);\r\n}\r\n}\r\nstatic int volume_alsa_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = TP_EC_VOLUME_MAX;\r\nreturn 0;\r\n}\r\nstatic int volume_alsa_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu8 s;\r\nint rc;\r\nrc = volume_get_status(&s);\r\nif (rc < 0)\r\nreturn rc;\r\nucontrol->value.integer.value[0] = s & TP_EC_AUDIO_LVL_MSK;\r\nreturn 0;\r\n}\r\nstatic int volume_alsa_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\ntpacpi_disclose_usertask("ALSA", "set volume to %ld\n",\r\nucontrol->value.integer.value[0]);\r\nreturn volume_alsa_set_volume(ucontrol->value.integer.value[0]);\r\n}\r\nstatic int volume_alsa_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu8 s;\r\nint rc;\r\nrc = volume_get_status(&s);\r\nif (rc < 0)\r\nreturn rc;\r\nucontrol->value.integer.value[0] =\r\n(s & TP_EC_AUDIO_MUTESW_MSK) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int volume_alsa_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\ntpacpi_disclose_usertask("ALSA", "%smute\n",\r\nucontrol->value.integer.value[0] ?\r\n"un" : "");\r\nreturn volume_alsa_set_mute(!ucontrol->value.integer.value[0]);\r\n}\r\nstatic void volume_suspend(void)\r\n{\r\ntpacpi_volume_checkpoint_nvram();\r\n}\r\nstatic void volume_resume(void)\r\n{\r\nvolume_alsa_notify_change();\r\n}\r\nstatic void volume_shutdown(void)\r\n{\r\ntpacpi_volume_checkpoint_nvram();\r\n}\r\nstatic void volume_exit(void)\r\n{\r\nif (alsa_card) {\r\nsnd_card_free(alsa_card);\r\nalsa_card = NULL;\r\n}\r\ntpacpi_volume_checkpoint_nvram();\r\n}\r\nstatic int __init volume_create_alsa_mixer(void)\r\n{\r\nstruct snd_card *card;\r\nstruct tpacpi_alsa_data *data;\r\nstruct snd_kcontrol *ctl_vol;\r\nstruct snd_kcontrol *ctl_mute;\r\nint rc;\r\nrc = snd_card_create(alsa_index, alsa_id, THIS_MODULE,\r\nsizeof(struct tpacpi_alsa_data), &card);\r\nif (rc < 0 || !card) {\r\npr_err("Failed to create ALSA card structures: %d\n", rc);\r\nreturn 1;\r\n}\r\nBUG_ON(!card->private_data);\r\ndata = card->private_data;\r\ndata->card = card;\r\nstrlcpy(card->driver, TPACPI_ALSA_DRVNAME,\r\nsizeof(card->driver));\r\nstrlcpy(card->shortname, TPACPI_ALSA_SHRTNAME,\r\nsizeof(card->shortname));\r\nsnprintf(card->mixername, sizeof(card->mixername), "ThinkPad EC %s",\r\n(thinkpad_id.ec_version_str) ?\r\nthinkpad_id.ec_version_str : "(unknown)");\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s at EC reg 0x%02x, fw %s", card->shortname, TP_EC_AUDIO,\r\n(thinkpad_id.ec_version_str) ?\r\nthinkpad_id.ec_version_str : "unknown");\r\nif (volume_control_allowed) {\r\nvolume_alsa_control_vol.put = volume_alsa_vol_put;\r\nvolume_alsa_control_vol.access =\r\nSNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nvolume_alsa_control_mute.put = volume_alsa_mute_put;\r\nvolume_alsa_control_mute.access =\r\nSNDRV_CTL_ELEM_ACCESS_READWRITE;\r\n}\r\nif (!tp_features.mixer_no_level_control) {\r\nctl_vol = snd_ctl_new1(&volume_alsa_control_vol, NULL);\r\nrc = snd_ctl_add(card, ctl_vol);\r\nif (rc < 0) {\r\npr_err("Failed to create ALSA volume control: %d\n",\r\nrc);\r\ngoto err_exit;\r\n}\r\ndata->ctl_vol_id = &ctl_vol->id;\r\n}\r\nctl_mute = snd_ctl_new1(&volume_alsa_control_mute, NULL);\r\nrc = snd_ctl_add(card, ctl_mute);\r\nif (rc < 0) {\r\npr_err("Failed to create ALSA mute control: %d\n", rc);\r\ngoto err_exit;\r\n}\r\ndata->ctl_mute_id = &ctl_mute->id;\r\nsnd_card_set_dev(card, &tpacpi_pdev->dev);\r\nrc = snd_card_register(card);\r\nif (rc < 0) {\r\npr_err("Failed to register ALSA card: %d\n", rc);\r\ngoto err_exit;\r\n}\r\nalsa_card = card;\r\nreturn 0;\r\nerr_exit:\r\nsnd_card_free(card);\r\nreturn 1;\r\n}\r\nstatic int __init volume_init(struct ibm_init_struct *iibm)\r\n{\r\nunsigned long quirks;\r\nint rc;\r\nvdbg_printk(TPACPI_DBG_INIT, "initializing volume subdriver\n");\r\nmutex_init(&volume_mutex);\r\nif (volume_mode > TPACPI_VOL_MODE_MAX)\r\nreturn -EINVAL;\r\nif (volume_mode == TPACPI_VOL_MODE_UCMS_STEP) {\r\npr_err("UCMS step volume mode not implemented, "\r\n"please contact %s\n", TPACPI_MAIL);\r\nreturn 1;\r\n}\r\nif (volume_capabilities >= TPACPI_VOL_CAP_MAX)\r\nreturn -EINVAL;\r\nif (!alsa_enable) {\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\r\n"ALSA mixer disabled by parameter, "\r\n"not loading volume subdriver...\n");\r\nreturn 1;\r\n}\r\nquirks = tpacpi_check_quirks(volume_quirk_table,\r\nARRAY_SIZE(volume_quirk_table));\r\nswitch (volume_capabilities) {\r\ncase TPACPI_VOL_CAP_AUTO:\r\nif (quirks & TPACPI_VOL_Q_MUTEONLY)\r\ntp_features.mixer_no_level_control = 1;\r\nelse if (quirks & TPACPI_VOL_Q_LEVEL)\r\ntp_features.mixer_no_level_control = 0;\r\nelse\r\nreturn 1;\r\nbreak;\r\ncase TPACPI_VOL_CAP_VOLMUTE:\r\ntp_features.mixer_no_level_control = 0;\r\nbreak;\r\ncase TPACPI_VOL_CAP_MUTEONLY:\r\ntp_features.mixer_no_level_control = 1;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (volume_capabilities != TPACPI_VOL_CAP_AUTO)\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\r\n"using user-supplied volume_capabilities=%d\n",\r\nvolume_capabilities);\r\nif (volume_mode == TPACPI_VOL_MODE_AUTO ||\r\nvolume_mode == TPACPI_VOL_MODE_MAX) {\r\nvolume_mode = TPACPI_VOL_MODE_ECNVRAM;\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\r\n"driver auto-selected volume_mode=%d\n",\r\nvolume_mode);\r\n} else {\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\r\n"using user-supplied volume_mode=%d\n",\r\nvolume_mode);\r\n}\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\r\n"mute is supported, volume control is %s\n",\r\nstr_supported(!tp_features.mixer_no_level_control));\r\nrc = volume_create_alsa_mixer();\r\nif (rc) {\r\npr_err("Could not create the ALSA mixer interface\n");\r\nreturn rc;\r\n}\r\npr_info("Console audio control enabled, mode: %s\n",\r\n(volume_control_allowed) ?\r\n"override (read/write)" :\r\n"monitor (read only)");\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\r\n"registering volume hotkeys as change notification\n");\r\ntpacpi_hotkey_driver_mask_set(hotkey_driver_mask\r\n| TP_ACPI_HKEY_VOLUP_MASK\r\n| TP_ACPI_HKEY_VOLDWN_MASK\r\n| TP_ACPI_HKEY_MUTE_MASK);\r\nreturn 0;\r\n}\r\nstatic int volume_read(struct seq_file *m)\r\n{\r\nu8 status;\r\nif (volume_get_status(&status) < 0) {\r\nseq_printf(m, "level:\t\tunreadable\n");\r\n} else {\r\nif (tp_features.mixer_no_level_control)\r\nseq_printf(m, "level:\t\tunsupported\n");\r\nelse\r\nseq_printf(m, "level:\t\t%d\n",\r\nstatus & TP_EC_AUDIO_LVL_MSK);\r\nseq_printf(m, "mute:\t\t%s\n",\r\nonoff(status, TP_EC_AUDIO_MUTESW));\r\nif (volume_control_allowed) {\r\nseq_printf(m, "commands:\tunmute, mute\n");\r\nif (!tp_features.mixer_no_level_control) {\r\nseq_printf(m,\r\n"commands:\tup, down\n");\r\nseq_printf(m,\r\n"commands:\tlevel <level>"\r\n" (<level> is 0-%d)\n",\r\nTP_EC_VOLUME_MAX);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int volume_write(char *buf)\r\n{\r\nu8 s;\r\nu8 new_level, new_mute;\r\nint l;\r\nchar *cmd;\r\nint rc;\r\nif (!volume_control_allowed && tpacpi_lifecycle != TPACPI_LIFE_INIT) {\r\nif (unlikely(!tp_warned.volume_ctrl_forbidden)) {\r\ntp_warned.volume_ctrl_forbidden = 1;\r\npr_notice("Console audio control in monitor mode, "\r\n"changes are not allowed\n");\r\npr_notice("Use the volume_control=1 module parameter "\r\n"to enable volume control\n");\r\n}\r\nreturn -EPERM;\r\n}\r\nrc = volume_get_status(&s);\r\nif (rc < 0)\r\nreturn rc;\r\nnew_level = s & TP_EC_AUDIO_LVL_MSK;\r\nnew_mute = s & TP_EC_AUDIO_MUTESW_MSK;\r\nwhile ((cmd = next_cmd(&buf))) {\r\nif (!tp_features.mixer_no_level_control) {\r\nif (strlencmp(cmd, "up") == 0) {\r\nif (new_mute)\r\nnew_mute = 0;\r\nelse if (new_level < TP_EC_VOLUME_MAX)\r\nnew_level++;\r\ncontinue;\r\n} else if (strlencmp(cmd, "down") == 0) {\r\nif (new_mute)\r\nnew_mute = 0;\r\nelse if (new_level > 0)\r\nnew_level--;\r\ncontinue;\r\n} else if (sscanf(cmd, "level %u", &l) == 1 &&\r\nl >= 0 && l <= TP_EC_VOLUME_MAX) {\r\nnew_level = l;\r\ncontinue;\r\n}\r\n}\r\nif (strlencmp(cmd, "mute") == 0)\r\nnew_mute = TP_EC_AUDIO_MUTESW_MSK;\r\nelse if (strlencmp(cmd, "unmute") == 0)\r\nnew_mute = 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (tp_features.mixer_no_level_control) {\r\ntpacpi_disclose_usertask("procfs volume", "%smute\n",\r\nnew_mute ? "" : "un");\r\nrc = volume_set_mute(!!new_mute);\r\n} else {\r\ntpacpi_disclose_usertask("procfs volume",\r\n"%smute and set level to %d\n",\r\nnew_mute ? "" : "un", new_level);\r\nrc = volume_set_status(new_mute | new_level);\r\n}\r\nvolume_alsa_notify_change();\r\nreturn (rc == -EINTR) ? -ERESTARTSYS : rc;\r\n}\r\nstatic void inline volume_alsa_notify_change(void)\r\n{\r\n}\r\nstatic int __init volume_init(struct ibm_init_struct *iibm)\r\n{\r\npr_info("volume: disabled as there is no ALSA support in this kernel\n");\r\nreturn 1;\r\n}\r\nstatic void fan_quirk1_setup(void)\r\n{\r\nif (fan_control_initial_status == 0x07) {\r\npr_notice("fan_init: initial fan status is unknown, "\r\n"assuming it is in auto mode\n");\r\ntp_features.fan_ctrl_status_undef = 1;\r\n}\r\n}\r\nstatic void fan_quirk1_handle(u8 *fan_status)\r\n{\r\nif (unlikely(tp_features.fan_ctrl_status_undef)) {\r\nif (*fan_status != fan_control_initial_status) {\r\ntp_features.fan_ctrl_status_undef = 0;\r\n} else {\r\n*fan_status = TP_EC_FAN_AUTO;\r\n}\r\n}\r\n}\r\nstatic bool fan_select_fan1(void)\r\n{\r\nif (tp_features.second_fan) {\r\nu8 val;\r\nif (ec_read(fan_select_offset, &val) < 0)\r\nreturn false;\r\nval &= 0xFEU;\r\nif (ec_write(fan_select_offset, val) < 0)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool fan_select_fan2(void)\r\n{\r\nu8 val;\r\nif (!tp_features.second_fan)\r\nreturn false;\r\nif (ec_read(fan_select_offset, &val) < 0)\r\nreturn false;\r\nval |= 0x01U;\r\nif (ec_write(fan_select_offset, val) < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void fan_update_desired_level(u8 status)\r\n{\r\nif ((status &\r\n(TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) == 0) {\r\nif (status > 7)\r\nfan_control_desired_level = 7;\r\nelse\r\nfan_control_desired_level = status;\r\n}\r\n}\r\nstatic int fan_get_status(u8 *status)\r\n{\r\nu8 s;\r\nswitch (fan_status_access_mode) {\r\ncase TPACPI_FAN_RD_ACPI_GFAN: {\r\nint res;\r\nif (unlikely(!acpi_evalf(gfan_handle, &res, NULL, "d")))\r\nreturn -EIO;\r\nif (likely(status))\r\n*status = res & 0x07;\r\nbreak;\r\n}\r\ncase TPACPI_FAN_RD_TPEC:\r\nif (unlikely(!acpi_ec_read(fan_status_offset, &s)))\r\nreturn -EIO;\r\nif (likely(status)) {\r\n*status = s;\r\nfan_quirk1_handle(status);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fan_get_status_safe(u8 *status)\r\n{\r\nint rc;\r\nu8 s;\r\nif (mutex_lock_killable(&fan_mutex))\r\nreturn -ERESTARTSYS;\r\nrc = fan_get_status(&s);\r\nif (!rc)\r\nfan_update_desired_level(s);\r\nmutex_unlock(&fan_mutex);\r\nif (status)\r\n*status = s;\r\nreturn rc;\r\n}\r\nstatic int fan_get_speed(unsigned int *speed)\r\n{\r\nu8 hi, lo;\r\nswitch (fan_status_access_mode) {\r\ncase TPACPI_FAN_RD_TPEC:\r\nif (unlikely(!fan_select_fan1()))\r\nreturn -EIO;\r\nif (unlikely(!acpi_ec_read(fan_rpm_offset, &lo) ||\r\n!acpi_ec_read(fan_rpm_offset + 1, &hi)))\r\nreturn -EIO;\r\nif (likely(speed))\r\n*speed = (hi << 8) | lo;\r\nbreak;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fan2_get_speed(unsigned int *speed)\r\n{\r\nu8 hi, lo;\r\nbool rc;\r\nswitch (fan_status_access_mode) {\r\ncase TPACPI_FAN_RD_TPEC:\r\nif (unlikely(!fan_select_fan2()))\r\nreturn -EIO;\r\nrc = !acpi_ec_read(fan_rpm_offset, &lo) ||\r\n!acpi_ec_read(fan_rpm_offset + 1, &hi);\r\nfan_select_fan1();\r\nif (rc)\r\nreturn -EIO;\r\nif (likely(speed))\r\n*speed = (hi << 8) | lo;\r\nbreak;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fan_set_level(int level)\r\n{\r\nif (!fan_control_allowed)\r\nreturn -EPERM;\r\nswitch (fan_control_access_mode) {\r\ncase TPACPI_FAN_WR_ACPI_SFAN:\r\nif (level >= 0 && level <= 7) {\r\nif (!acpi_evalf(sfan_handle, NULL, NULL, "vd", level))\r\nreturn -EIO;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase TPACPI_FAN_WR_ACPI_FANS:\r\ncase TPACPI_FAN_WR_TPEC:\r\nif (!(level & TP_EC_FAN_AUTO) &&\r\n!(level & TP_EC_FAN_FULLSPEED) &&\r\n((level < 0) || (level > 7)))\r\nreturn -EINVAL;\r\nif (level & TP_EC_FAN_FULLSPEED)\r\nlevel |= 7;\r\nelse if (level & TP_EC_FAN_AUTO)\r\nlevel |= 4;\r\nif (!acpi_ec_write(fan_status_offset, level))\r\nreturn -EIO;\r\nelse\r\ntp_features.fan_ctrl_status_undef = 0;\r\nbreak;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\nvdbg_printk(TPACPI_DBG_FAN,\r\n"fan control: set fan control register to 0x%02x\n", level);\r\nreturn 0;\r\n}\r\nstatic int fan_set_level_safe(int level)\r\n{\r\nint rc;\r\nif (!fan_control_allowed)\r\nreturn -EPERM;\r\nif (mutex_lock_killable(&fan_mutex))\r\nreturn -ERESTARTSYS;\r\nif (level == TPACPI_FAN_LAST_LEVEL)\r\nlevel = fan_control_desired_level;\r\nrc = fan_set_level(level);\r\nif (!rc)\r\nfan_update_desired_level(level);\r\nmutex_unlock(&fan_mutex);\r\nreturn rc;\r\n}\r\nstatic int fan_set_enable(void)\r\n{\r\nu8 s;\r\nint rc;\r\nif (!fan_control_allowed)\r\nreturn -EPERM;\r\nif (mutex_lock_killable(&fan_mutex))\r\nreturn -ERESTARTSYS;\r\nswitch (fan_control_access_mode) {\r\ncase TPACPI_FAN_WR_ACPI_FANS:\r\ncase TPACPI_FAN_WR_TPEC:\r\nrc = fan_get_status(&s);\r\nif (rc < 0)\r\nbreak;\r\nif (s != 7) {\r\ns &= 0x07;\r\ns |= TP_EC_FAN_AUTO | 4;\r\n}\r\nif (!acpi_ec_write(fan_status_offset, s))\r\nrc = -EIO;\r\nelse {\r\ntp_features.fan_ctrl_status_undef = 0;\r\nrc = 0;\r\n}\r\nbreak;\r\ncase TPACPI_FAN_WR_ACPI_SFAN:\r\nrc = fan_get_status(&s);\r\nif (rc < 0)\r\nbreak;\r\ns &= 0x07;\r\ns |= 4;\r\nif (!acpi_evalf(sfan_handle, NULL, NULL, "vd", s))\r\nrc = -EIO;\r\nelse\r\nrc = 0;\r\nbreak;\r\ndefault:\r\nrc = -ENXIO;\r\n}\r\nmutex_unlock(&fan_mutex);\r\nif (!rc)\r\nvdbg_printk(TPACPI_DBG_FAN,\r\n"fan control: set fan control register to 0x%02x\n",\r\ns);\r\nreturn rc;\r\n}\r\nstatic int fan_set_disable(void)\r\n{\r\nint rc;\r\nif (!fan_control_allowed)\r\nreturn -EPERM;\r\nif (mutex_lock_killable(&fan_mutex))\r\nreturn -ERESTARTSYS;\r\nrc = 0;\r\nswitch (fan_control_access_mode) {\r\ncase TPACPI_FAN_WR_ACPI_FANS:\r\ncase TPACPI_FAN_WR_TPEC:\r\nif (!acpi_ec_write(fan_status_offset, 0x00))\r\nrc = -EIO;\r\nelse {\r\nfan_control_desired_level = 0;\r\ntp_features.fan_ctrl_status_undef = 0;\r\n}\r\nbreak;\r\ncase TPACPI_FAN_WR_ACPI_SFAN:\r\nif (!acpi_evalf(sfan_handle, NULL, NULL, "vd", 0x00))\r\nrc = -EIO;\r\nelse\r\nfan_control_desired_level = 0;\r\nbreak;\r\ndefault:\r\nrc = -ENXIO;\r\n}\r\nif (!rc)\r\nvdbg_printk(TPACPI_DBG_FAN,\r\n"fan control: set fan control register to 0\n");\r\nmutex_unlock(&fan_mutex);\r\nreturn rc;\r\n}\r\nstatic int fan_set_speed(int speed)\r\n{\r\nint rc;\r\nif (!fan_control_allowed)\r\nreturn -EPERM;\r\nif (mutex_lock_killable(&fan_mutex))\r\nreturn -ERESTARTSYS;\r\nrc = 0;\r\nswitch (fan_control_access_mode) {\r\ncase TPACPI_FAN_WR_ACPI_FANS:\r\nif (speed >= 0 && speed <= 65535) {\r\nif (!acpi_evalf(fans_handle, NULL, NULL, "vddd",\r\nspeed, speed, speed))\r\nrc = -EIO;\r\n} else\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\nrc = -ENXIO;\r\n}\r\nmutex_unlock(&fan_mutex);\r\nreturn rc;\r\n}\r\nstatic void fan_watchdog_reset(void)\r\n{\r\nif (fan_control_access_mode == TPACPI_FAN_WR_NONE)\r\nreturn;\r\nif (fan_watchdog_maxinterval > 0 &&\r\ntpacpi_lifecycle != TPACPI_LIFE_EXITING)\r\nmod_delayed_work(tpacpi_wq, &fan_watchdog_task,\r\nmsecs_to_jiffies(fan_watchdog_maxinterval * 1000));\r\nelse\r\ncancel_delayed_work(&fan_watchdog_task);\r\n}\r\nstatic void fan_watchdog_fire(struct work_struct *ignored)\r\n{\r\nint rc;\r\nif (tpacpi_lifecycle != TPACPI_LIFE_RUNNING)\r\nreturn;\r\npr_notice("fan watchdog: enabling fan\n");\r\nrc = fan_set_enable();\r\nif (rc < 0) {\r\npr_err("fan watchdog: error %d while enabling fan, "\r\n"will try again later...\n", -rc);\r\nfan_watchdog_reset();\r\n}\r\n}\r\nstatic ssize_t fan_pwm1_enable_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint res, mode;\r\nu8 status;\r\nres = fan_get_status_safe(&status);\r\nif (res)\r\nreturn res;\r\nif (status & TP_EC_FAN_FULLSPEED) {\r\nmode = 0;\r\n} else if (status & TP_EC_FAN_AUTO) {\r\nmode = 2;\r\n} else\r\nmode = 1;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", mode);\r\n}\r\nstatic ssize_t fan_pwm1_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nint res, level;\r\nif (parse_strtoul(buf, 2, &t))\r\nreturn -EINVAL;\r\ntpacpi_disclose_usertask("hwmon pwm1_enable",\r\n"set fan mode to %lu\n", t);\r\nswitch (t) {\r\ncase 0:\r\nlevel = TP_EC_FAN_FULLSPEED;\r\nbreak;\r\ncase 1:\r\nlevel = TPACPI_FAN_LAST_LEVEL;\r\nbreak;\r\ncase 2:\r\nlevel = TP_EC_FAN_AUTO;\r\nbreak;\r\ncase 3:\r\nreturn -ENOSYS;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nres = fan_set_level_safe(level);\r\nif (res == -ENXIO)\r\nreturn -EINVAL;\r\nelse if (res < 0)\r\nreturn res;\r\nfan_watchdog_reset();\r\nreturn count;\r\n}\r\nstatic ssize_t fan_pwm1_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint res;\r\nu8 status;\r\nres = fan_get_status_safe(&status);\r\nif (res)\r\nreturn res;\r\nif ((status &\r\n(TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) != 0)\r\nstatus = fan_control_desired_level;\r\nif (status > 7)\r\nstatus = 7;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", (status * 255) / 7);\r\n}\r\nstatic ssize_t fan_pwm1_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long s;\r\nint rc;\r\nu8 status, newlevel;\r\nif (parse_strtoul(buf, 255, &s))\r\nreturn -EINVAL;\r\ntpacpi_disclose_usertask("hwmon pwm1",\r\n"set fan speed to %lu\n", s);\r\nnewlevel = (s >> 5) & 0x07;\r\nif (mutex_lock_killable(&fan_mutex))\r\nreturn -ERESTARTSYS;\r\nrc = fan_get_status(&status);\r\nif (!rc && (status &\r\n(TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) == 0) {\r\nrc = fan_set_level(newlevel);\r\nif (rc == -ENXIO)\r\nrc = -EINVAL;\r\nelse if (!rc) {\r\nfan_update_desired_level(newlevel);\r\nfan_watchdog_reset();\r\n}\r\n}\r\nmutex_unlock(&fan_mutex);\r\nreturn (rc)? rc : count;\r\n}\r\nstatic ssize_t fan_fan1_input_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint res;\r\nunsigned int speed;\r\nres = fan_get_speed(&speed);\r\nif (res < 0)\r\nreturn res;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", speed);\r\n}\r\nstatic ssize_t fan_fan2_input_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint res;\r\nunsigned int speed;\r\nres = fan2_get_speed(&speed);\r\nif (res < 0)\r\nreturn res;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", speed);\r\n}\r\nstatic ssize_t fan_fan_watchdog_show(struct device_driver *drv,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", fan_watchdog_maxinterval);\r\n}\r\nstatic ssize_t fan_fan_watchdog_store(struct device_driver *drv,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long t;\r\nif (parse_strtoul(buf, 120, &t))\r\nreturn -EINVAL;\r\nif (!fan_control_allowed)\r\nreturn -EPERM;\r\nfan_watchdog_maxinterval = t;\r\nfan_watchdog_reset();\r\ntpacpi_disclose_usertask("fan_watchdog", "set to %lu\n", t);\r\nreturn count;\r\n}\r\nstatic int __init fan_init(struct ibm_init_struct *iibm)\r\n{\r\nint rc;\r\nunsigned long quirks;\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\r\n"initializing fan subdriver\n");\r\nmutex_init(&fan_mutex);\r\nfan_status_access_mode = TPACPI_FAN_NONE;\r\nfan_control_access_mode = TPACPI_FAN_WR_NONE;\r\nfan_control_commands = 0;\r\nfan_watchdog_maxinterval = 0;\r\ntp_features.fan_ctrl_status_undef = 0;\r\ntp_features.second_fan = 0;\r\nfan_control_desired_level = 7;\r\nif (tpacpi_is_ibm()) {\r\nTPACPI_ACPIHANDLE_INIT(fans);\r\nTPACPI_ACPIHANDLE_INIT(gfan);\r\nTPACPI_ACPIHANDLE_INIT(sfan);\r\n}\r\nquirks = tpacpi_check_quirks(fan_quirk_table,\r\nARRAY_SIZE(fan_quirk_table));\r\nif (gfan_handle) {\r\nfan_status_access_mode = TPACPI_FAN_RD_ACPI_GFAN;\r\n} else {\r\nif (likely(acpi_ec_read(fan_status_offset,\r\n&fan_control_initial_status))) {\r\nfan_status_access_mode = TPACPI_FAN_RD_TPEC;\r\nif (quirks & TPACPI_FAN_Q1)\r\nfan_quirk1_setup();\r\nif (quirks & TPACPI_FAN_2FAN) {\r\ntp_features.second_fan = 1;\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\r\n"secondary fan support enabled\n");\r\n}\r\n} else {\r\npr_err("ThinkPad ACPI EC access misbehaving, "\r\n"fan status and control unavailable\n");\r\nreturn 1;\r\n}\r\n}\r\nif (sfan_handle) {\r\nfan_control_access_mode = TPACPI_FAN_WR_ACPI_SFAN;\r\nfan_control_commands |=\r\nTPACPI_FAN_CMD_LEVEL | TPACPI_FAN_CMD_ENABLE;\r\n} else {\r\nif (!gfan_handle) {\r\nif (fans_handle) {\r\nfan_control_access_mode =\r\nTPACPI_FAN_WR_ACPI_FANS;\r\nfan_control_commands |=\r\nTPACPI_FAN_CMD_SPEED |\r\nTPACPI_FAN_CMD_LEVEL |\r\nTPACPI_FAN_CMD_ENABLE;\r\n} else {\r\nfan_control_access_mode = TPACPI_FAN_WR_TPEC;\r\nfan_control_commands |=\r\nTPACPI_FAN_CMD_LEVEL |\r\nTPACPI_FAN_CMD_ENABLE;\r\n}\r\n}\r\n}\r\nvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\r\n"fan is %s, modes %d, %d\n",\r\nstr_supported(fan_status_access_mode != TPACPI_FAN_NONE ||\r\nfan_control_access_mode != TPACPI_FAN_WR_NONE),\r\nfan_status_access_mode, fan_control_access_mode);\r\nif (!fan_control_allowed) {\r\nfan_control_access_mode = TPACPI_FAN_WR_NONE;\r\nfan_control_commands = 0;\r\ndbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\r\n"fan control features disabled by parameter\n");\r\n}\r\nif (fan_status_access_mode != TPACPI_FAN_NONE)\r\nfan_get_status_safe(NULL);\r\nif (fan_status_access_mode != TPACPI_FAN_NONE ||\r\nfan_control_access_mode != TPACPI_FAN_WR_NONE) {\r\nif (tp_features.second_fan) {\r\nfan_attributes[ARRAY_SIZE(fan_attributes)-2] =\r\n&dev_attr_fan_fan2_input.attr;\r\n}\r\nrc = sysfs_create_group(&tpacpi_sensors_pdev->dev.kobj,\r\n&fan_attr_group);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = driver_create_file(&tpacpi_hwmon_pdriver.driver,\r\n&driver_attr_fan_watchdog);\r\nif (rc < 0) {\r\nsysfs_remove_group(&tpacpi_sensors_pdev->dev.kobj,\r\n&fan_attr_group);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n} else\r\nreturn 1;\r\n}\r\nstatic void fan_exit(void)\r\n{\r\nvdbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_FAN,\r\n"cancelling any pending fan watchdog tasks\n");\r\nsysfs_remove_group(&tpacpi_sensors_pdev->dev.kobj, &fan_attr_group);\r\ndriver_remove_file(&tpacpi_hwmon_pdriver.driver,\r\n&driver_attr_fan_watchdog);\r\ncancel_delayed_work(&fan_watchdog_task);\r\nflush_workqueue(tpacpi_wq);\r\n}\r\nstatic void fan_suspend(void)\r\n{\r\nint rc;\r\nif (!fan_control_allowed)\r\nreturn;\r\nfan_control_resume_level = 0;\r\nrc = fan_get_status_safe(&fan_control_resume_level);\r\nif (rc < 0)\r\npr_notice("failed to read fan level for later "\r\n"restore during resume: %d\n", rc);\r\nif (tp_features.fan_ctrl_status_undef)\r\nfan_control_resume_level = 0;\r\n}\r\nstatic void fan_resume(void)\r\n{\r\nu8 current_level = 7;\r\nbool do_set = false;\r\nint rc;\r\ntp_features.fan_ctrl_status_undef = 0;\r\nif (!fan_control_allowed ||\r\n!fan_control_resume_level ||\r\n(fan_get_status_safe(&current_level) < 0))\r\nreturn;\r\nswitch (fan_control_access_mode) {\r\ncase TPACPI_FAN_WR_ACPI_SFAN:\r\ndo_set = (fan_control_resume_level > current_level);\r\nbreak;\r\ncase TPACPI_FAN_WR_ACPI_FANS:\r\ncase TPACPI_FAN_WR_TPEC:\r\nif (fan_control_resume_level != 7 &&\r\n!(fan_control_resume_level & TP_EC_FAN_FULLSPEED))\r\nreturn;\r\nelse\r\ndo_set = !(current_level & TP_EC_FAN_FULLSPEED) &&\r\n(current_level != fan_control_resume_level);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (do_set) {\r\npr_notice("restoring fan level to 0x%02x\n",\r\nfan_control_resume_level);\r\nrc = fan_set_level_safe(fan_control_resume_level);\r\nif (rc < 0)\r\npr_notice("failed to restore fan level: %d\n", rc);\r\n}\r\n}\r\nstatic int fan_read(struct seq_file *m)\r\n{\r\nint rc;\r\nu8 status;\r\nunsigned int speed = 0;\r\nswitch (fan_status_access_mode) {\r\ncase TPACPI_FAN_RD_ACPI_GFAN:\r\nrc = fan_get_status_safe(&status);\r\nif (rc < 0)\r\nreturn rc;\r\nseq_printf(m, "status:\t\t%s\n"\r\n"level:\t\t%d\n",\r\n(status != 0) ? "enabled" : "disabled", status);\r\nbreak;\r\ncase TPACPI_FAN_RD_TPEC:\r\nrc = fan_get_status_safe(&status);\r\nif (rc < 0)\r\nreturn rc;\r\nseq_printf(m, "status:\t\t%s\n",\r\n(status != 0) ? "enabled" : "disabled");\r\nrc = fan_get_speed(&speed);\r\nif (rc < 0)\r\nreturn rc;\r\nseq_printf(m, "speed:\t\t%d\n", speed);\r\nif (status & TP_EC_FAN_FULLSPEED)\r\nseq_printf(m, "level:\t\tdisengaged\n");\r\nelse if (status & TP_EC_FAN_AUTO)\r\nseq_printf(m, "level:\t\tauto\n");\r\nelse\r\nseq_printf(m, "level:\t\t%d\n", status);\r\nbreak;\r\ncase TPACPI_FAN_NONE:\r\ndefault:\r\nseq_printf(m, "status:\t\tnot supported\n");\r\n}\r\nif (fan_control_commands & TPACPI_FAN_CMD_LEVEL) {\r\nseq_printf(m, "commands:\tlevel <level>");\r\nswitch (fan_control_access_mode) {\r\ncase TPACPI_FAN_WR_ACPI_SFAN:\r\nseq_printf(m, " (<level> is 0-7)\n");\r\nbreak;\r\ndefault:\r\nseq_printf(m, " (<level> is 0-7, "\r\n"auto, disengaged, full-speed)\n");\r\nbreak;\r\n}\r\n}\r\nif (fan_control_commands & TPACPI_FAN_CMD_ENABLE)\r\nseq_printf(m, "commands:\tenable, disable\n"\r\n"commands:\twatchdog <timeout> (<timeout> "\r\n"is 0 (off), 1-120 (seconds))\n");\r\nif (fan_control_commands & TPACPI_FAN_CMD_SPEED)\r\nseq_printf(m, "commands:\tspeed <speed>"\r\n" (<speed> is 0-65535)\n");\r\nreturn 0;\r\n}\r\nstatic int fan_write_cmd_level(const char *cmd, int *rc)\r\n{\r\nint level;\r\nif (strlencmp(cmd, "level auto") == 0)\r\nlevel = TP_EC_FAN_AUTO;\r\nelse if ((strlencmp(cmd, "level disengaged") == 0) |\r\n(strlencmp(cmd, "level full-speed") == 0))\r\nlevel = TP_EC_FAN_FULLSPEED;\r\nelse if (sscanf(cmd, "level %d", &level) != 1)\r\nreturn 0;\r\n*rc = fan_set_level_safe(level);\r\nif (*rc == -ENXIO)\r\npr_err("level command accepted for unsupported access mode %d\n",\r\nfan_control_access_mode);\r\nelse if (!*rc)\r\ntpacpi_disclose_usertask("procfs fan",\r\n"set level to %d\n", level);\r\nreturn 1;\r\n}\r\nstatic int fan_write_cmd_enable(const char *cmd, int *rc)\r\n{\r\nif (strlencmp(cmd, "enable") != 0)\r\nreturn 0;\r\n*rc = fan_set_enable();\r\nif (*rc == -ENXIO)\r\npr_err("enable command accepted for unsupported access mode %d\n",\r\nfan_control_access_mode);\r\nelse if (!*rc)\r\ntpacpi_disclose_usertask("procfs fan", "enable\n");\r\nreturn 1;\r\n}\r\nstatic int fan_write_cmd_disable(const char *cmd, int *rc)\r\n{\r\nif (strlencmp(cmd, "disable") != 0)\r\nreturn 0;\r\n*rc = fan_set_disable();\r\nif (*rc == -ENXIO)\r\npr_err("disable command accepted for unsupported access mode %d\n",\r\nfan_control_access_mode);\r\nelse if (!*rc)\r\ntpacpi_disclose_usertask("procfs fan", "disable\n");\r\nreturn 1;\r\n}\r\nstatic int fan_write_cmd_speed(const char *cmd, int *rc)\r\n{\r\nint speed;\r\nif (sscanf(cmd, "speed %d", &speed) != 1)\r\nreturn 0;\r\n*rc = fan_set_speed(speed);\r\nif (*rc == -ENXIO)\r\npr_err("speed command accepted for unsupported access mode %d\n",\r\nfan_control_access_mode);\r\nelse if (!*rc)\r\ntpacpi_disclose_usertask("procfs fan",\r\n"set speed to %d\n", speed);\r\nreturn 1;\r\n}\r\nstatic int fan_write_cmd_watchdog(const char *cmd, int *rc)\r\n{\r\nint interval;\r\nif (sscanf(cmd, "watchdog %d", &interval) != 1)\r\nreturn 0;\r\nif (interval < 0 || interval > 120)\r\n*rc = -EINVAL;\r\nelse {\r\nfan_watchdog_maxinterval = interval;\r\ntpacpi_disclose_usertask("procfs fan",\r\n"set watchdog timer to %d\n",\r\ninterval);\r\n}\r\nreturn 1;\r\n}\r\nstatic int fan_write(char *buf)\r\n{\r\nchar *cmd;\r\nint rc = 0;\r\nwhile (!rc && (cmd = next_cmd(&buf))) {\r\nif (!((fan_control_commands & TPACPI_FAN_CMD_LEVEL) &&\r\nfan_write_cmd_level(cmd, &rc)) &&\r\n!((fan_control_commands & TPACPI_FAN_CMD_ENABLE) &&\r\n(fan_write_cmd_enable(cmd, &rc) ||\r\nfan_write_cmd_disable(cmd, &rc) ||\r\nfan_write_cmd_watchdog(cmd, &rc))) &&\r\n!((fan_control_commands & TPACPI_FAN_CMD_SPEED) &&\r\nfan_write_cmd_speed(cmd, &rc))\r\n)\r\nrc = -EINVAL;\r\nelse if (!rc)\r\nfan_watchdog_reset();\r\n}\r\nreturn rc;\r\n}\r\nstatic void tpacpi_driver_event(const unsigned int hkey_event)\r\n{\r\nif (ibm_backlight_device) {\r\nswitch (hkey_event) {\r\ncase TP_HKEY_EV_BRGHT_UP:\r\ncase TP_HKEY_EV_BRGHT_DOWN:\r\ntpacpi_brightness_notify_change();\r\n}\r\n}\r\nif (alsa_card) {\r\nswitch (hkey_event) {\r\ncase TP_HKEY_EV_VOL_UP:\r\ncase TP_HKEY_EV_VOL_DOWN:\r\ncase TP_HKEY_EV_VOL_MUTE:\r\nvolume_alsa_notify_change();\r\n}\r\n}\r\n}\r\nstatic void hotkey_driver_event(const unsigned int scancode)\r\n{\r\ntpacpi_driver_event(TP_HKEY_EV_HOTKEY_BASE + scancode);\r\n}\r\nstatic ssize_t thinkpad_acpi_pdev_name_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", TPACPI_NAME);\r\n}\r\nstatic const char * __init str_supported(int is_supported)\r\n{\r\nstatic char text_unsupported[] __initdata = "not supported";\r\nreturn (is_supported)? &text_unsupported[4] : &text_unsupported[0];\r\n}\r\nstatic void ibm_exit(struct ibm_struct *ibm)\r\n{\r\ndbg_printk(TPACPI_DBG_EXIT, "removing %s\n", ibm->name);\r\nlist_del_init(&ibm->all_drivers);\r\nif (ibm->flags.acpi_notify_installed) {\r\ndbg_printk(TPACPI_DBG_EXIT,\r\n"%s: acpi_remove_notify_handler\n", ibm->name);\r\nBUG_ON(!ibm->acpi);\r\nacpi_remove_notify_handler(*ibm->acpi->handle,\r\nibm->acpi->type,\r\ndispatch_acpi_notify);\r\nibm->flags.acpi_notify_installed = 0;\r\n}\r\nif (ibm->flags.proc_created) {\r\ndbg_printk(TPACPI_DBG_EXIT,\r\n"%s: remove_proc_entry\n", ibm->name);\r\nremove_proc_entry(ibm->name, proc_dir);\r\nibm->flags.proc_created = 0;\r\n}\r\nif (ibm->flags.acpi_driver_registered) {\r\ndbg_printk(TPACPI_DBG_EXIT,\r\n"%s: acpi_bus_unregister_driver\n", ibm->name);\r\nBUG_ON(!ibm->acpi);\r\nacpi_bus_unregister_driver(ibm->acpi->driver);\r\nkfree(ibm->acpi->driver);\r\nibm->acpi->driver = NULL;\r\nibm->flags.acpi_driver_registered = 0;\r\n}\r\nif (ibm->flags.init_called && ibm->exit) {\r\nibm->exit();\r\nibm->flags.init_called = 0;\r\n}\r\ndbg_printk(TPACPI_DBG_INIT, "finished removing %s\n", ibm->name);\r\n}\r\nstatic int __init ibm_init(struct ibm_init_struct *iibm)\r\n{\r\nint ret;\r\nstruct ibm_struct *ibm = iibm->data;\r\nstruct proc_dir_entry *entry;\r\nBUG_ON(ibm == NULL);\r\nINIT_LIST_HEAD(&ibm->all_drivers);\r\nif (ibm->flags.experimental && !experimental)\r\nreturn 0;\r\ndbg_printk(TPACPI_DBG_INIT,\r\n"probing for %s\n", ibm->name);\r\nif (iibm->init) {\r\nret = iibm->init(iibm);\r\nif (ret > 0)\r\nreturn 0;\r\nif (ret)\r\nreturn ret;\r\nibm->flags.init_called = 1;\r\n}\r\nif (ibm->acpi) {\r\nif (ibm->acpi->hid) {\r\nret = register_tpacpi_subdriver(ibm);\r\nif (ret)\r\ngoto err_out;\r\n}\r\nif (ibm->acpi->notify) {\r\nret = setup_acpi_notify(ibm);\r\nif (ret == -ENODEV) {\r\npr_notice("disabling subdriver %s\n",\r\nibm->name);\r\nret = 0;\r\ngoto err_out;\r\n}\r\nif (ret < 0)\r\ngoto err_out;\r\n}\r\n}\r\ndbg_printk(TPACPI_DBG_INIT,\r\n"%s installed\n", ibm->name);\r\nif (ibm->read) {\r\numode_t mode = iibm->base_procfs_mode;\r\nif (!mode)\r\nmode = S_IRUGO;\r\nif (ibm->write)\r\nmode |= S_IWUSR;\r\nentry = proc_create_data(ibm->name, mode, proc_dir,\r\n&dispatch_proc_fops, ibm);\r\nif (!entry) {\r\npr_err("unable to create proc entry %s\n", ibm->name);\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\nibm->flags.proc_created = 1;\r\n}\r\nlist_add_tail(&ibm->all_drivers, &tpacpi_all_drivers);\r\nreturn 0;\r\nerr_out:\r\ndbg_printk(TPACPI_DBG_INIT,\r\n"%s: at error exit path with result %d\n",\r\nibm->name, ret);\r\nibm_exit(ibm);\r\nreturn (ret < 0)? ret : 0;\r\n}\r\nstatic bool __pure __init tpacpi_is_fw_digit(const char c)\r\n{\r\nreturn (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z');\r\n}\r\nstatic bool __pure __init tpacpi_is_valid_fw_id(const char* const s,\r\nconst char t)\r\n{\r\nreturn s && strlen(s) >= 8 &&\r\ntpacpi_is_fw_digit(s[0]) &&\r\ntpacpi_is_fw_digit(s[1]) &&\r\ns[2] == t &&\r\n(s[3] == 'T' || s[3] == 'N') &&\r\ntpacpi_is_fw_digit(s[4]) &&\r\ntpacpi_is_fw_digit(s[5]);\r\n}\r\nstatic int __must_check __init get_thinkpad_model_data(\r\nstruct thinkpad_id_data *tp)\r\n{\r\nconst struct dmi_device *dev = NULL;\r\nchar ec_fw_string[18];\r\nchar const *s;\r\nif (!tp)\r\nreturn -EINVAL;\r\nmemset(tp, 0, sizeof(*tp));\r\nif (dmi_name_in_vendors("IBM"))\r\ntp->vendor = PCI_VENDOR_ID_IBM;\r\nelse if (dmi_name_in_vendors("LENOVO"))\r\ntp->vendor = PCI_VENDOR_ID_LENOVO;\r\nelse\r\nreturn 0;\r\ns = dmi_get_system_info(DMI_BIOS_VERSION);\r\ntp->bios_version_str = kstrdup(s, GFP_KERNEL);\r\nif (s && !tp->bios_version_str)\r\nreturn -ENOMEM;\r\nif (!(tpacpi_is_valid_fw_id(tp->bios_version_str, 'E') ||\r\ntpacpi_is_valid_fw_id(tp->bios_version_str, 'C')))\r\nreturn 0;\r\ntp->bios_model = tp->bios_version_str[0]\r\n| (tp->bios_version_str[1] << 8);\r\ntp->bios_release = (tp->bios_version_str[4] << 8)\r\n| tp->bios_version_str[5];\r\nwhile ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL, dev))) {\r\nif (sscanf(dev->name,\r\n"IBM ThinkPad Embedded Controller -[%17c",\r\nec_fw_string) == 1) {\r\nec_fw_string[sizeof(ec_fw_string) - 1] = 0;\r\nec_fw_string[strcspn(ec_fw_string, " ]")] = 0;\r\ntp->ec_version_str = kstrdup(ec_fw_string, GFP_KERNEL);\r\nif (!tp->ec_version_str)\r\nreturn -ENOMEM;\r\nif (tpacpi_is_valid_fw_id(ec_fw_string, 'H')) {\r\ntp->ec_model = ec_fw_string[0]\r\n| (ec_fw_string[1] << 8);\r\ntp->ec_release = (ec_fw_string[4] << 8)\r\n| ec_fw_string[5];\r\n} else {\r\npr_notice("ThinkPad firmware release %s "\r\n"doesn't match the known patterns\n",\r\nec_fw_string);\r\npr_notice("please report this to %s\n",\r\nTPACPI_MAIL);\r\n}\r\nbreak;\r\n}\r\n}\r\ns = dmi_get_system_info(DMI_PRODUCT_VERSION);\r\nif (s && !(strnicmp(s, "ThinkPad", 8) && strnicmp(s, "Lenovo", 6))) {\r\ntp->model_str = kstrdup(s, GFP_KERNEL);\r\nif (!tp->model_str)\r\nreturn -ENOMEM;\r\n} else {\r\ns = dmi_get_system_info(DMI_BIOS_VENDOR);\r\nif (s && !(strnicmp(s, "Lenovo", 6))) {\r\ntp->model_str = kstrdup(s, GFP_KERNEL);\r\nif (!tp->model_str)\r\nreturn -ENOMEM;\r\n}\r\n}\r\ns = dmi_get_system_info(DMI_PRODUCT_NAME);\r\ntp->nummodel_str = kstrdup(s, GFP_KERNEL);\r\nif (s && !tp->nummodel_str)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int __init probe_for_thinkpad(void)\r\n{\r\nint is_thinkpad;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nif (!tpacpi_is_ibm() && !tpacpi_is_lenovo())\r\nreturn -ENODEV;\r\nis_thinkpad = (thinkpad_id.model_str != NULL) ||\r\n(thinkpad_id.ec_model != 0) ||\r\ntpacpi_is_fw_known();\r\ntpacpi_acpi_handle_locate("ec", TPACPI_ACPI_EC_HID, &ec_handle);\r\nif (!ec_handle) {\r\nif (is_thinkpad)\r\npr_err("Not yet supported ThinkPad detected!\n");\r\nreturn -ENODEV;\r\n}\r\nif (!is_thinkpad && !force_load)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __init thinkpad_acpi_init_banner(void)\r\n{\r\npr_info("%s v%s\n", TPACPI_DESC, TPACPI_VERSION);\r\npr_info("%s\n", TPACPI_URL);\r\npr_info("ThinkPad BIOS %s, EC %s\n",\r\n(thinkpad_id.bios_version_str) ?\r\nthinkpad_id.bios_version_str : "unknown",\r\n(thinkpad_id.ec_version_str) ?\r\nthinkpad_id.ec_version_str : "unknown");\r\nBUG_ON(!thinkpad_id.vendor);\r\nif (thinkpad_id.model_str)\r\npr_info("%s %s, model %s\n",\r\n(thinkpad_id.vendor == PCI_VENDOR_ID_IBM) ?\r\n"IBM" : ((thinkpad_id.vendor ==\r\nPCI_VENDOR_ID_LENOVO) ?\r\n"Lenovo" : "Unknown vendor"),\r\nthinkpad_id.model_str,\r\n(thinkpad_id.nummodel_str) ?\r\nthinkpad_id.nummodel_str : "unknown");\r\n}\r\nstatic int __init set_ibm_param(const char *val, struct kernel_param *kp)\r\n{\r\nunsigned int i;\r\nstruct ibm_struct *ibm;\r\nif (!kp || !kp->name || !val)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(ibms_init); i++) {\r\nibm = ibms_init[i].data;\r\nWARN_ON(ibm == NULL);\r\nif (!ibm || !ibm->name)\r\ncontinue;\r\nif (strcmp(ibm->name, kp->name) == 0 && ibm->write) {\r\nif (strlen(val) > sizeof(ibms_init[i].param) - 2)\r\nreturn -ENOSPC;\r\nstrcpy(ibms_init[i].param, val);\r\nstrcat(ibms_init[i].param, ",");\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void thinkpad_acpi_module_exit(void)\r\n{\r\nstruct ibm_struct *ibm, *itmp;\r\ntpacpi_lifecycle = TPACPI_LIFE_EXITING;\r\nlist_for_each_entry_safe_reverse(ibm, itmp,\r\n&tpacpi_all_drivers,\r\nall_drivers) {\r\nibm_exit(ibm);\r\n}\r\ndbg_printk(TPACPI_DBG_INIT, "finished subdriver exit path...\n");\r\nif (tpacpi_inputdev) {\r\nif (tp_features.input_device_registered)\r\ninput_unregister_device(tpacpi_inputdev);\r\nelse\r\ninput_free_device(tpacpi_inputdev);\r\nkfree(hotkey_keycode_map);\r\n}\r\nif (tpacpi_hwmon)\r\nhwmon_device_unregister(tpacpi_hwmon);\r\nif (tp_features.sensors_pdev_attrs_registered)\r\ndevice_remove_file(&tpacpi_sensors_pdev->dev,\r\n&dev_attr_thinkpad_acpi_pdev_name);\r\nif (tpacpi_sensors_pdev)\r\nplatform_device_unregister(tpacpi_sensors_pdev);\r\nif (tpacpi_pdev)\r\nplatform_device_unregister(tpacpi_pdev);\r\nif (tp_features.sensors_pdrv_attrs_registered)\r\ntpacpi_remove_driver_attributes(&tpacpi_hwmon_pdriver.driver);\r\nif (tp_features.platform_drv_attrs_registered)\r\ntpacpi_remove_driver_attributes(&tpacpi_pdriver.driver);\r\nif (tp_features.sensors_pdrv_registered)\r\nplatform_driver_unregister(&tpacpi_hwmon_pdriver);\r\nif (tp_features.platform_drv_registered)\r\nplatform_driver_unregister(&tpacpi_pdriver);\r\nif (proc_dir)\r\nremove_proc_entry(TPACPI_PROC_DIR, acpi_root_dir);\r\nif (tpacpi_wq)\r\ndestroy_workqueue(tpacpi_wq);\r\nkfree(thinkpad_id.bios_version_str);\r\nkfree(thinkpad_id.ec_version_str);\r\nkfree(thinkpad_id.model_str);\r\nkfree(thinkpad_id.nummodel_str);\r\n}\r\nstatic int __init thinkpad_acpi_module_init(void)\r\n{\r\nint ret, i;\r\ntpacpi_lifecycle = TPACPI_LIFE_INIT;\r\nif (hotkey_report_mode > 2)\r\nreturn -EINVAL;\r\nret = get_thinkpad_model_data(&thinkpad_id);\r\nif (ret) {\r\npr_err("unable to get DMI data: %d\n", ret);\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\nret = probe_for_thinkpad();\r\nif (ret) {\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\nthinkpad_acpi_init_banner();\r\ntpacpi_check_outdated_fw();\r\nTPACPI_ACPIHANDLE_INIT(ecrd);\r\nTPACPI_ACPIHANDLE_INIT(ecwr);\r\ntpacpi_wq = create_singlethread_workqueue(TPACPI_WORKQUEUE_NAME);\r\nif (!tpacpi_wq) {\r\nthinkpad_acpi_module_exit();\r\nreturn -ENOMEM;\r\n}\r\nproc_dir = proc_mkdir(TPACPI_PROC_DIR, acpi_root_dir);\r\nif (!proc_dir) {\r\npr_err("unable to create proc dir " TPACPI_PROC_DIR "\n");\r\nthinkpad_acpi_module_exit();\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&tpacpi_pdriver);\r\nif (ret) {\r\npr_err("unable to register main platform driver\n");\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\ntp_features.platform_drv_registered = 1;\r\nret = platform_driver_register(&tpacpi_hwmon_pdriver);\r\nif (ret) {\r\npr_err("unable to register hwmon platform driver\n");\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\ntp_features.sensors_pdrv_registered = 1;\r\nret = tpacpi_create_driver_attributes(&tpacpi_pdriver.driver);\r\nif (!ret) {\r\ntp_features.platform_drv_attrs_registered = 1;\r\nret = tpacpi_create_driver_attributes(\r\n&tpacpi_hwmon_pdriver.driver);\r\n}\r\nif (ret) {\r\npr_err("unable to create sysfs driver attributes\n");\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\ntp_features.sensors_pdrv_attrs_registered = 1;\r\ntpacpi_pdev = platform_device_register_simple(TPACPI_DRVR_NAME, -1,\r\nNULL, 0);\r\nif (IS_ERR(tpacpi_pdev)) {\r\nret = PTR_ERR(tpacpi_pdev);\r\ntpacpi_pdev = NULL;\r\npr_err("unable to register platform device\n");\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\ntpacpi_sensors_pdev = platform_device_register_simple(\r\nTPACPI_HWMON_DRVR_NAME,\r\n-1, NULL, 0);\r\nif (IS_ERR(tpacpi_sensors_pdev)) {\r\nret = PTR_ERR(tpacpi_sensors_pdev);\r\ntpacpi_sensors_pdev = NULL;\r\npr_err("unable to register hwmon platform device\n");\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\nret = device_create_file(&tpacpi_sensors_pdev->dev,\r\n&dev_attr_thinkpad_acpi_pdev_name);\r\nif (ret) {\r\npr_err("unable to create sysfs hwmon device attributes\n");\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\ntp_features.sensors_pdev_attrs_registered = 1;\r\ntpacpi_hwmon = hwmon_device_register(&tpacpi_sensors_pdev->dev);\r\nif (IS_ERR(tpacpi_hwmon)) {\r\nret = PTR_ERR(tpacpi_hwmon);\r\ntpacpi_hwmon = NULL;\r\npr_err("unable to register hwmon device\n");\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\nmutex_init(&tpacpi_inputdev_send_mutex);\r\ntpacpi_inputdev = input_allocate_device();\r\nif (!tpacpi_inputdev) {\r\npr_err("unable to allocate input device\n");\r\nthinkpad_acpi_module_exit();\r\nreturn -ENOMEM;\r\n} else {\r\ntpacpi_inputdev->name = "ThinkPad Extra Buttons";\r\ntpacpi_inputdev->phys = TPACPI_DRVR_NAME "/input0";\r\ntpacpi_inputdev->id.bustype = BUS_HOST;\r\ntpacpi_inputdev->id.vendor = thinkpad_id.vendor;\r\ntpacpi_inputdev->id.product = TPACPI_HKEY_INPUT_PRODUCT;\r\ntpacpi_inputdev->id.version = TPACPI_HKEY_INPUT_VERSION;\r\ntpacpi_inputdev->dev.parent = &tpacpi_pdev->dev;\r\n}\r\ntpacpi_detect_brightness_capabilities();\r\nfor (i = 0; i < ARRAY_SIZE(ibms_init); i++) {\r\nret = ibm_init(&ibms_init[i]);\r\nif (ret >= 0 && *ibms_init[i].param)\r\nret = ibms_init[i].data->write(ibms_init[i].param);\r\nif (ret < 0) {\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n}\r\n}\r\ntpacpi_lifecycle = TPACPI_LIFE_RUNNING;\r\nret = input_register_device(tpacpi_inputdev);\r\nif (ret < 0) {\r\npr_err("unable to register input device\n");\r\nthinkpad_acpi_module_exit();\r\nreturn ret;\r\n} else {\r\ntp_features.input_device_registered = 1;\r\n}\r\nreturn 0;\r\n}
