struct device *omap_get_control_dev(void)\r\n{\r\nif (!control_usb)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn control_usb->dev;\r\n}\r\nvoid omap_control_usb3_phy_power(struct device *dev, bool on)\r\n{\r\nu32 val;\r\nunsigned long rate;\r\nstruct omap_control_usb *control_usb = dev_get_drvdata(dev);\r\nif (control_usb->type != OMAP_CTRL_DEV_TYPE2)\r\nreturn;\r\nrate = clk_get_rate(control_usb->sys_clk);\r\nrate = rate/1000000;\r\nval = readl(control_usb->phy_power);\r\nif (on) {\r\nval &= ~(OMAP_CTRL_USB_PWRCTL_CLK_CMD_MASK |\r\nOMAP_CTRL_USB_PWRCTL_CLK_FREQ_MASK);\r\nval |= OMAP_CTRL_USB3_PHY_TX_RX_POWERON <<\r\nOMAP_CTRL_USB_PWRCTL_CLK_CMD_SHIFT;\r\nval |= rate << OMAP_CTRL_USB_PWRCTL_CLK_FREQ_SHIFT;\r\n} else {\r\nval &= ~OMAP_CTRL_USB_PWRCTL_CLK_CMD_MASK;\r\nval |= OMAP_CTRL_USB3_PHY_TX_RX_POWEROFF <<\r\nOMAP_CTRL_USB_PWRCTL_CLK_CMD_SHIFT;\r\n}\r\nwritel(val, control_usb->phy_power);\r\n}\r\nvoid omap_control_usb_phy_power(struct device *dev, int on)\r\n{\r\nu32 val;\r\nstruct omap_control_usb *control_usb = dev_get_drvdata(dev);\r\nval = readl(control_usb->dev_conf);\r\nif (on)\r\nval &= ~OMAP_CTRL_DEV_PHY_PD;\r\nelse\r\nval |= OMAP_CTRL_DEV_PHY_PD;\r\nwritel(val, control_usb->dev_conf);\r\n}\r\nstatic void omap_control_usb_host_mode(struct omap_control_usb *ctrl_usb)\r\n{\r\nu32 val;\r\nval = readl(ctrl_usb->otghs_control);\r\nval &= ~(OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_SESSEND);\r\nval |= OMAP_CTRL_DEV_AVALID | OMAP_CTRL_DEV_VBUSVALID;\r\nwritel(val, ctrl_usb->otghs_control);\r\n}\r\nstatic void omap_control_usb_device_mode(struct omap_control_usb *ctrl_usb)\r\n{\r\nu32 val;\r\nval = readl(ctrl_usb->otghs_control);\r\nval &= ~OMAP_CTRL_DEV_SESSEND;\r\nval |= OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_AVALID |\r\nOMAP_CTRL_DEV_VBUSVALID;\r\nwritel(val, ctrl_usb->otghs_control);\r\n}\r\nstatic void omap_control_usb_set_sessionend(struct omap_control_usb *ctrl_usb)\r\n{\r\nu32 val;\r\nval = readl(ctrl_usb->otghs_control);\r\nval &= ~(OMAP_CTRL_DEV_AVALID | OMAP_CTRL_DEV_VBUSVALID);\r\nval |= OMAP_CTRL_DEV_IDDIG | OMAP_CTRL_DEV_SESSEND;\r\nwritel(val, ctrl_usb->otghs_control);\r\n}\r\nvoid omap_control_usb_set_mode(struct device *dev,\r\nenum omap_control_usb_mode mode)\r\n{\r\nstruct omap_control_usb *ctrl_usb;\r\nif (IS_ERR(dev) || control_usb->type != OMAP_CTRL_DEV_TYPE1)\r\nreturn;\r\nctrl_usb = dev_get_drvdata(dev);\r\nswitch (mode) {\r\ncase USB_MODE_HOST:\r\nomap_control_usb_host_mode(ctrl_usb);\r\nbreak;\r\ncase USB_MODE_DEVICE:\r\nomap_control_usb_device_mode(ctrl_usb);\r\nbreak;\r\ncase USB_MODE_DISCONNECT:\r\nomap_control_usb_set_sessionend(ctrl_usb);\r\nbreak;\r\ndefault:\r\ndev_vdbg(dev, "invalid omap control usb mode\n");\r\n}\r\n}\r\nstatic int omap_control_usb_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct omap_control_usb_platform_data *pdata = pdev->dev.platform_data;\r\ncontrol_usb = devm_kzalloc(&pdev->dev, sizeof(*control_usb),\r\nGFP_KERNEL);\r\nif (!control_usb) {\r\ndev_err(&pdev->dev, "unable to alloc memory for control usb\n");\r\nreturn -ENOMEM;\r\n}\r\nif (np) {\r\nof_property_read_u32(np, "ti,type", &control_usb->type);\r\n} else if (pdata) {\r\ncontrol_usb->type = pdata->type;\r\n} else {\r\ndev_err(&pdev->dev, "no pdata present\n");\r\nreturn -EINVAL;\r\n}\r\ncontrol_usb->dev = &pdev->dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"control_dev_conf");\r\ncontrol_usb->dev_conf = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(control_usb->dev_conf))\r\nreturn PTR_ERR(control_usb->dev_conf);\r\nif (control_usb->type == OMAP_CTRL_DEV_TYPE1) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"otghs_control");\r\ncontrol_usb->otghs_control = devm_ioremap_resource(\r\n&pdev->dev, res);\r\nif (IS_ERR(control_usb->otghs_control))\r\nreturn PTR_ERR(control_usb->otghs_control);\r\n}\r\nif (control_usb->type == OMAP_CTRL_DEV_TYPE2) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"phy_power_usb");\r\ncontrol_usb->phy_power = devm_ioremap_resource(\r\n&pdev->dev, res);\r\nif (IS_ERR(control_usb->phy_power))\r\nreturn PTR_ERR(control_usb->phy_power);\r\ncontrol_usb->sys_clk = devm_clk_get(control_usb->dev,\r\n"sys_clkin");\r\nif (IS_ERR(control_usb->sys_clk)) {\r\npr_err("%s: unable to get sys_clkin\n", __func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_set_drvdata(control_usb->dev, control_usb);\r\nreturn 0;\r\n}\r\nstatic int __init omap_control_usb_init(void)\r\n{\r\nreturn platform_driver_register(&omap_control_usb_driver);\r\n}\r\nstatic void __exit omap_control_usb_exit(void)\r\n{\r\nplatform_driver_unregister(&omap_control_usb_driver);\r\n}
