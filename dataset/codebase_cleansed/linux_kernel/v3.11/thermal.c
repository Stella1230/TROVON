static int acpi_thermal_get_temperature(struct acpi_thermal *tz)\r\n{\r\nacpi_status status = AE_OK;\r\nunsigned long long tmp;\r\nif (!tz)\r\nreturn -EINVAL;\r\ntz->last_temperature = tz->temperature;\r\nstatus = acpi_evaluate_integer(tz->device->handle, "_TMP", NULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\ntz->temperature = tmp;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Temperature is %lu dK\n",\r\ntz->temperature));\r\nreturn 0;\r\n}\r\nstatic int acpi_thermal_get_polling_frequency(struct acpi_thermal *tz)\r\n{\r\nacpi_status status = AE_OK;\r\nunsigned long long tmp;\r\nif (!tz)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(tz->device->handle, "_TZP", NULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\ntz->polling_frequency = tmp;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Polling frequency is %lu dS\n",\r\ntz->polling_frequency));\r\nreturn 0;\r\n}\r\nstatic int acpi_thermal_set_cooling_mode(struct acpi_thermal *tz, int mode)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\r\nstruct acpi_object_list arg_list = { 1, &arg0 };\r\nacpi_handle handle = NULL;\r\nif (!tz)\r\nreturn -EINVAL;\r\nstatus = acpi_get_handle(tz->device->handle, "_SCP", &handle);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "_SCP not present\n"));\r\nreturn -ENODEV;\r\n}\r\narg0.integer.value = mode;\r\nstatus = acpi_evaluate_object(handle, NULL, &arg_list, NULL);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int acpi_thermal_trips_update(struct acpi_thermal *tz, int flag)\r\n{\r\nacpi_status status = AE_OK;\r\nunsigned long long tmp;\r\nstruct acpi_handle_list devices;\r\nint valid = 0;\r\nint i;\r\nif (flag & ACPI_TRIPS_CRITICAL) {\r\nstatus = acpi_evaluate_integer(tz->device->handle,\r\n"_CRT", NULL, &tmp);\r\ntz->trips.critical.temperature = tmp;\r\nif (ACPI_FAILURE(status)) {\r\ntz->trips.critical.flags.valid = 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"No critical threshold\n"));\r\n} else if (tmp <= 2732) {\r\nprintk(KERN_WARNING FW_BUG "Invalid critical threshold "\r\n"(%llu)\n", tmp);\r\ntz->trips.critical.flags.valid = 0;\r\n} else {\r\ntz->trips.critical.flags.valid = 1;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Found critical threshold [%lu]\n",\r\ntz->trips.critical.temperature));\r\n}\r\nif (tz->trips.critical.flags.valid == 1) {\r\nif (crt == -1) {\r\ntz->trips.critical.flags.valid = 0;\r\n} else if (crt > 0) {\r\nunsigned long crt_k = CELSIUS_TO_KELVIN(crt);\r\nif (crt_k > tz->trips.critical.temperature)\r\nprintk(KERN_WARNING PREFIX\r\n"Critical threshold %d C\n", crt);\r\ntz->trips.critical.temperature = crt_k;\r\n}\r\n}\r\n}\r\nif (flag & ACPI_TRIPS_HOT) {\r\nstatus = acpi_evaluate_integer(tz->device->handle,\r\n"_HOT", NULL, &tmp);\r\nif (ACPI_FAILURE(status)) {\r\ntz->trips.hot.flags.valid = 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"No hot threshold\n"));\r\n} else {\r\ntz->trips.hot.temperature = tmp;\r\ntz->trips.hot.flags.valid = 1;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Found hot threshold [%lu]\n",\r\ntz->trips.critical.temperature));\r\n}\r\n}\r\nif (((flag & ACPI_TRIPS_PASSIVE) && tz->trips.passive.flags.valid) ||\r\n(flag == ACPI_TRIPS_INIT)) {\r\nvalid = tz->trips.passive.flags.valid;\r\nif (psv == -1) {\r\nstatus = AE_SUPPORT;\r\n} else if (psv > 0) {\r\ntmp = CELSIUS_TO_KELVIN(psv);\r\nstatus = AE_OK;\r\n} else {\r\nstatus = acpi_evaluate_integer(tz->device->handle,\r\n"_PSV", NULL, &tmp);\r\n}\r\nif (ACPI_FAILURE(status))\r\ntz->trips.passive.flags.valid = 0;\r\nelse {\r\ntz->trips.passive.temperature = tmp;\r\ntz->trips.passive.flags.valid = 1;\r\nif (flag == ACPI_TRIPS_INIT) {\r\nstatus = acpi_evaluate_integer(\r\ntz->device->handle, "_TC1",\r\nNULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\ntz->trips.passive.flags.valid = 0;\r\nelse\r\ntz->trips.passive.tc1 = tmp;\r\nstatus = acpi_evaluate_integer(\r\ntz->device->handle, "_TC2",\r\nNULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\ntz->trips.passive.flags.valid = 0;\r\nelse\r\ntz->trips.passive.tc2 = tmp;\r\nstatus = acpi_evaluate_integer(\r\ntz->device->handle, "_TSP",\r\nNULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\ntz->trips.passive.flags.valid = 0;\r\nelse\r\ntz->trips.passive.tsp = tmp;\r\n}\r\n}\r\n}\r\nif ((flag & ACPI_TRIPS_DEVICES) && tz->trips.passive.flags.valid) {\r\nmemset(&devices, 0, sizeof(struct acpi_handle_list));\r\nstatus = acpi_evaluate_reference(tz->device->handle, "_PSL",\r\nNULL, &devices);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_WARNING PREFIX\r\n"Invalid passive threshold\n");\r\ntz->trips.passive.flags.valid = 0;\r\n}\r\nelse\r\ntz->trips.passive.flags.valid = 1;\r\nif (memcmp(&tz->trips.passive.devices, &devices,\r\nsizeof(struct acpi_handle_list))) {\r\nmemcpy(&tz->trips.passive.devices, &devices,\r\nsizeof(struct acpi_handle_list));\r\nACPI_THERMAL_TRIPS_EXCEPTION(flag, "device");\r\n}\r\n}\r\nif ((flag & ACPI_TRIPS_PASSIVE) || (flag & ACPI_TRIPS_DEVICES)) {\r\nif (valid != tz->trips.passive.flags.valid)\r\nACPI_THERMAL_TRIPS_EXCEPTION(flag, "state");\r\n}\r\nfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\r\nchar name[5] = { '_', 'A', 'C', ('0' + i), '\0' };\r\nvalid = tz->trips.active[i].flags.valid;\r\nif (act == -1)\r\nbreak;\r\nif ((flag == ACPI_TRIPS_INIT) || ((flag & ACPI_TRIPS_ACTIVE) &&\r\ntz->trips.active[i].flags.valid)) {\r\nstatus = acpi_evaluate_integer(tz->device->handle,\r\nname, NULL, &tmp);\r\nif (ACPI_FAILURE(status)) {\r\ntz->trips.active[i].flags.valid = 0;\r\nif (i == 0)\r\nbreak;\r\nif (act <= 0)\r\nbreak;\r\nif (i == 1)\r\ntz->trips.active[0].temperature =\r\nCELSIUS_TO_KELVIN(act);\r\nelse\r\ntz->trips.active[i - 1].temperature =\r\n(tz->trips.active[i - 2].temperature <\r\nCELSIUS_TO_KELVIN(act) ?\r\ntz->trips.active[i - 2].temperature :\r\nCELSIUS_TO_KELVIN(act));\r\nbreak;\r\n} else {\r\ntz->trips.active[i].temperature = tmp;\r\ntz->trips.active[i].flags.valid = 1;\r\n}\r\n}\r\nname[2] = 'L';\r\nif ((flag & ACPI_TRIPS_DEVICES) && tz->trips.active[i].flags.valid ) {\r\nmemset(&devices, 0, sizeof(struct acpi_handle_list));\r\nstatus = acpi_evaluate_reference(tz->device->handle,\r\nname, NULL, &devices);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_WARNING PREFIX\r\n"Invalid active%d threshold\n", i);\r\ntz->trips.active[i].flags.valid = 0;\r\n}\r\nelse\r\ntz->trips.active[i].flags.valid = 1;\r\nif (memcmp(&tz->trips.active[i].devices, &devices,\r\nsizeof(struct acpi_handle_list))) {\r\nmemcpy(&tz->trips.active[i].devices, &devices,\r\nsizeof(struct acpi_handle_list));\r\nACPI_THERMAL_TRIPS_EXCEPTION(flag, "device");\r\n}\r\n}\r\nif ((flag & ACPI_TRIPS_ACTIVE) || (flag & ACPI_TRIPS_DEVICES))\r\nif (valid != tz->trips.active[i].flags.valid)\r\nACPI_THERMAL_TRIPS_EXCEPTION(flag, "state");\r\nif (!tz->trips.active[i].flags.valid)\r\nbreak;\r\n}\r\nif (flag & ACPI_TRIPS_DEVICES) {\r\nmemset(&devices, 0, sizeof(struct acpi_handle_list));\r\nstatus = acpi_evaluate_reference(tz->device->handle, "_TZD",\r\nNULL, &devices);\r\nif (memcmp(&tz->devices, &devices,\r\nsizeof(struct acpi_handle_list))) {\r\nmemcpy(&tz->devices, &devices,\r\nsizeof(struct acpi_handle_list));\r\nACPI_THERMAL_TRIPS_EXCEPTION(flag, "device");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_thermal_get_trip_points(struct acpi_thermal *tz)\r\n{\r\nint i, valid, ret = acpi_thermal_trips_update(tz, ACPI_TRIPS_INIT);\r\nif (ret)\r\nreturn ret;\r\nvalid = tz->trips.critical.flags.valid |\r\ntz->trips.hot.flags.valid |\r\ntz->trips.passive.flags.valid;\r\nfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++)\r\nvalid |= tz->trips.active[i].flags.valid;\r\nif (!valid) {\r\nprintk(KERN_WARNING FW_BUG "No valid trip found\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_thermal_check(void *data)\r\n{\r\nstruct acpi_thermal *tz = data;\r\nif (!tz->tz_enabled) {\r\npr_warn("thermal zone is disabled \n");\r\nreturn;\r\n}\r\nthermal_zone_device_update(tz->thermal_zone);\r\n}\r\nstatic int thermal_get_temp(struct thermal_zone_device *thermal,\r\nunsigned long *temp)\r\n{\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nint result;\r\nif (!tz)\r\nreturn -EINVAL;\r\nresult = acpi_thermal_get_temperature(tz);\r\nif (result)\r\nreturn result;\r\n*temp = KELVIN_TO_MILLICELSIUS(tz->temperature, tz->kelvin_offset);\r\nreturn 0;\r\n}\r\nstatic int thermal_get_mode(struct thermal_zone_device *thermal,\r\nenum thermal_device_mode *mode)\r\n{\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nif (!tz)\r\nreturn -EINVAL;\r\n*mode = tz->tz_enabled ? THERMAL_DEVICE_ENABLED :\r\nTHERMAL_DEVICE_DISABLED;\r\nreturn 0;\r\n}\r\nstatic int thermal_set_mode(struct thermal_zone_device *thermal,\r\nenum thermal_device_mode mode)\r\n{\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nint enable;\r\nif (!tz)\r\nreturn -EINVAL;\r\nif (mode == THERMAL_DEVICE_ENABLED)\r\nenable = 1;\r\nelse if (mode == THERMAL_DEVICE_DISABLED)\r\nenable = 0;\r\nelse\r\nreturn -EINVAL;\r\nif (enable != tz->tz_enabled) {\r\ntz->tz_enabled = enable;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"%s kernel ACPI thermal control\n",\r\ntz->tz_enabled ? "Enable" : "Disable"));\r\nacpi_thermal_check(tz);\r\n}\r\nreturn 0;\r\n}\r\nstatic int thermal_get_trip_type(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nint i;\r\nif (!tz || trip < 0)\r\nreturn -EINVAL;\r\nif (tz->trips.critical.flags.valid) {\r\nif (!trip) {\r\n*type = THERMAL_TRIP_CRITICAL;\r\nreturn 0;\r\n}\r\ntrip--;\r\n}\r\nif (tz->trips.hot.flags.valid) {\r\nif (!trip) {\r\n*type = THERMAL_TRIP_HOT;\r\nreturn 0;\r\n}\r\ntrip--;\r\n}\r\nif (tz->trips.passive.flags.valid) {\r\nif (!trip) {\r\n*type = THERMAL_TRIP_PASSIVE;\r\nreturn 0;\r\n}\r\ntrip--;\r\n}\r\nfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&\r\ntz->trips.active[i].flags.valid; i++) {\r\nif (!trip) {\r\n*type = THERMAL_TRIP_ACTIVE;\r\nreturn 0;\r\n}\r\ntrip--;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int thermal_get_trip_temp(struct thermal_zone_device *thermal,\r\nint trip, unsigned long *temp)\r\n{\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nint i;\r\nif (!tz || trip < 0)\r\nreturn -EINVAL;\r\nif (tz->trips.critical.flags.valid) {\r\nif (!trip) {\r\n*temp = KELVIN_TO_MILLICELSIUS(\r\ntz->trips.critical.temperature,\r\ntz->kelvin_offset);\r\nreturn 0;\r\n}\r\ntrip--;\r\n}\r\nif (tz->trips.hot.flags.valid) {\r\nif (!trip) {\r\n*temp = KELVIN_TO_MILLICELSIUS(\r\ntz->trips.hot.temperature,\r\ntz->kelvin_offset);\r\nreturn 0;\r\n}\r\ntrip--;\r\n}\r\nif (tz->trips.passive.flags.valid) {\r\nif (!trip) {\r\n*temp = KELVIN_TO_MILLICELSIUS(\r\ntz->trips.passive.temperature,\r\ntz->kelvin_offset);\r\nreturn 0;\r\n}\r\ntrip--;\r\n}\r\nfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&\r\ntz->trips.active[i].flags.valid; i++) {\r\nif (!trip) {\r\n*temp = KELVIN_TO_MILLICELSIUS(\r\ntz->trips.active[i].temperature,\r\ntz->kelvin_offset);\r\nreturn 0;\r\n}\r\ntrip--;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int thermal_get_crit_temp(struct thermal_zone_device *thermal,\r\nunsigned long *temperature) {\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nif (tz->trips.critical.flags.valid) {\r\n*temperature = KELVIN_TO_MILLICELSIUS(\r\ntz->trips.critical.temperature,\r\ntz->kelvin_offset);\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic int thermal_get_trend(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trend *trend)\r\n{\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nenum thermal_trip_type type;\r\nint i;\r\nif (thermal_get_trip_type(thermal, trip, &type))\r\nreturn -EINVAL;\r\nif (type == THERMAL_TRIP_ACTIVE) {\r\nunsigned long trip_temp;\r\nunsigned long temp = KELVIN_TO_MILLICELSIUS(tz->temperature,\r\ntz->kelvin_offset);\r\nif (thermal_get_trip_temp(thermal, trip, &trip_temp))\r\nreturn -EINVAL;\r\nif (temp > trip_temp) {\r\n*trend = THERMAL_TREND_RAISING;\r\nreturn 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\ni = (tz->trips.passive.tc1 * (tz->temperature - tz->last_temperature))\r\n+ (tz->trips.passive.tc2\r\n* (tz->temperature - tz->trips.passive.temperature));\r\nif (i > 0)\r\n*trend = THERMAL_TREND_RAISING;\r\nelse if (i < 0)\r\n*trend = THERMAL_TREND_DROPPING;\r\nelse\r\n*trend = THERMAL_TREND_STABLE;\r\nreturn 0;\r\n}\r\nstatic int thermal_notify(struct thermal_zone_device *thermal, int trip,\r\nenum thermal_trip_type trip_type)\r\n{\r\nu8 type = 0;\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nif (trip_type == THERMAL_TRIP_CRITICAL)\r\ntype = ACPI_THERMAL_NOTIFY_CRITICAL;\r\nelse if (trip_type == THERMAL_TRIP_HOT)\r\ntype = ACPI_THERMAL_NOTIFY_HOT;\r\nelse\r\nreturn 0;\r\nacpi_bus_generate_proc_event(tz->device, type, 1);\r\nacpi_bus_generate_netlink_event(tz->device->pnp.device_class,\r\ndev_name(&tz->device->dev), type, 1);\r\nif (trip_type == THERMAL_TRIP_CRITICAL && nocrt)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int acpi_thermal_cooling_device_cb(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev,\r\nbool bind)\r\n{\r\nstruct acpi_device *device = cdev->devdata;\r\nstruct acpi_thermal *tz = thermal->devdata;\r\nstruct acpi_device *dev;\r\nacpi_status status;\r\nacpi_handle handle;\r\nint i;\r\nint j;\r\nint trip = -1;\r\nint result = 0;\r\nif (tz->trips.critical.flags.valid)\r\ntrip++;\r\nif (tz->trips.hot.flags.valid)\r\ntrip++;\r\nif (tz->trips.passive.flags.valid) {\r\ntrip++;\r\nfor (i = 0; i < tz->trips.passive.devices.count;\r\ni++) {\r\nhandle = tz->trips.passive.devices.handles[i];\r\nstatus = acpi_bus_get_device(handle, &dev);\r\nif (ACPI_FAILURE(status) || dev != device)\r\ncontinue;\r\nif (bind)\r\nresult =\r\nthermal_zone_bind_cooling_device\r\n(thermal, trip, cdev,\r\nTHERMAL_NO_LIMIT, THERMAL_NO_LIMIT);\r\nelse\r\nresult =\r\nthermal_zone_unbind_cooling_device\r\n(thermal, trip, cdev);\r\nif (result)\r\ngoto failed;\r\n}\r\n}\r\nfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\r\nif (!tz->trips.active[i].flags.valid)\r\nbreak;\r\ntrip++;\r\nfor (j = 0;\r\nj < tz->trips.active[i].devices.count;\r\nj++) {\r\nhandle = tz->trips.active[i].devices.handles[j];\r\nstatus = acpi_bus_get_device(handle, &dev);\r\nif (ACPI_FAILURE(status) || dev != device)\r\ncontinue;\r\nif (bind)\r\nresult = thermal_zone_bind_cooling_device\r\n(thermal, trip, cdev,\r\nTHERMAL_NO_LIMIT, THERMAL_NO_LIMIT);\r\nelse\r\nresult = thermal_zone_unbind_cooling_device\r\n(thermal, trip, cdev);\r\nif (result)\r\ngoto failed;\r\n}\r\n}\r\nfor (i = 0; i < tz->devices.count; i++) {\r\nhandle = tz->devices.handles[i];\r\nstatus = acpi_bus_get_device(handle, &dev);\r\nif (ACPI_SUCCESS(status) && (dev == device)) {\r\nif (bind)\r\nresult = thermal_zone_bind_cooling_device\r\n(thermal, -1, cdev,\r\nTHERMAL_NO_LIMIT,\r\nTHERMAL_NO_LIMIT);\r\nelse\r\nresult = thermal_zone_unbind_cooling_device\r\n(thermal, -1, cdev);\r\nif (result)\r\ngoto failed;\r\n}\r\n}\r\nfailed:\r\nreturn result;\r\n}\r\nstatic int\r\nacpi_thermal_bind_cooling_device(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nreturn acpi_thermal_cooling_device_cb(thermal, cdev, true);\r\n}\r\nstatic int\r\nacpi_thermal_unbind_cooling_device(struct thermal_zone_device *thermal,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nreturn acpi_thermal_cooling_device_cb(thermal, cdev, false);\r\n}\r\nstatic int acpi_thermal_register_thermal_zone(struct acpi_thermal *tz)\r\n{\r\nint trips = 0;\r\nint result;\r\nacpi_status status;\r\nint i;\r\nif (tz->trips.critical.flags.valid)\r\ntrips++;\r\nif (tz->trips.hot.flags.valid)\r\ntrips++;\r\nif (tz->trips.passive.flags.valid)\r\ntrips++;\r\nfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE &&\r\ntz->trips.active[i].flags.valid; i++, trips++);\r\nif (tz->trips.passive.flags.valid)\r\ntz->thermal_zone =\r\nthermal_zone_device_register("acpitz", trips, 0, tz,\r\n&acpi_thermal_zone_ops, NULL,\r\ntz->trips.passive.tsp*100,\r\ntz->polling_frequency*100);\r\nelse\r\ntz->thermal_zone =\r\nthermal_zone_device_register("acpitz", trips, 0, tz,\r\n&acpi_thermal_zone_ops, NULL,\r\n0, tz->polling_frequency*100);\r\nif (IS_ERR(tz->thermal_zone))\r\nreturn -ENODEV;\r\nresult = sysfs_create_link(&tz->device->dev.kobj,\r\n&tz->thermal_zone->device.kobj, "thermal_zone");\r\nif (result)\r\nreturn result;\r\nresult = sysfs_create_link(&tz->thermal_zone->device.kobj,\r\n&tz->device->dev.kobj, "device");\r\nif (result)\r\nreturn result;\r\nstatus = acpi_attach_data(tz->device->handle,\r\nacpi_bus_private_data_handler,\r\ntz->thermal_zone);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR PREFIX\r\n"Error attaching device data\n");\r\nreturn -ENODEV;\r\n}\r\ntz->tz_enabled = 1;\r\ndev_info(&tz->device->dev, "registered as thermal_zone%d\n",\r\ntz->thermal_zone->id);\r\nreturn 0;\r\n}\r\nstatic void acpi_thermal_unregister_thermal_zone(struct acpi_thermal *tz)\r\n{\r\nsysfs_remove_link(&tz->device->dev.kobj, "thermal_zone");\r\nsysfs_remove_link(&tz->thermal_zone->device.kobj, "device");\r\nthermal_zone_device_unregister(tz->thermal_zone);\r\ntz->thermal_zone = NULL;\r\nacpi_detach_data(tz->device->handle, acpi_bus_private_data_handler);\r\n}\r\nstatic void acpi_thermal_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_thermal *tz = acpi_driver_data(device);\r\nif (!tz)\r\nreturn;\r\nswitch (event) {\r\ncase ACPI_THERMAL_NOTIFY_TEMPERATURE:\r\nacpi_thermal_check(tz);\r\nbreak;\r\ncase ACPI_THERMAL_NOTIFY_THRESHOLDS:\r\nacpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_THRESHOLDS);\r\nacpi_thermal_check(tz);\r\nacpi_bus_generate_proc_event(device, event, 0);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event, 0);\r\nbreak;\r\ncase ACPI_THERMAL_NOTIFY_DEVICES:\r\nacpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_DEVICES);\r\nacpi_thermal_check(tz);\r\nacpi_bus_generate_proc_event(device, event, 0);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event, 0);\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\n}\r\nstatic void acpi_thermal_aml_dependency_fix(struct acpi_thermal *tz)\r\n{\r\nacpi_handle handle = tz->device->handle;\r\nunsigned long long value;\r\nint i;\r\nacpi_evaluate_integer(handle, "_CRT", NULL, &value);\r\nacpi_evaluate_integer(handle, "_HOT", NULL, &value);\r\nacpi_evaluate_integer(handle, "_PSV", NULL, &value);\r\nfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\r\nchar name[5] = { '_', 'A', 'C', ('0' + i), '\0' };\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(handle, name, NULL, &value);\r\nif (status == AE_NOT_FOUND)\r\nbreak;\r\n}\r\nacpi_evaluate_integer(handle, "_TMP", NULL, &value);\r\n}\r\nstatic int acpi_thermal_get_info(struct acpi_thermal *tz)\r\n{\r\nint result = 0;\r\nif (!tz)\r\nreturn -EINVAL;\r\nacpi_thermal_aml_dependency_fix(tz);\r\nresult = acpi_thermal_get_trip_points(tz);\r\nif (result)\r\nreturn result;\r\nresult = acpi_thermal_get_temperature(tz);\r\nif (result)\r\nreturn result;\r\nresult = acpi_thermal_set_cooling_mode(tz, ACPI_THERMAL_MODE_ACTIVE);\r\nif (!result)\r\ntz->flags.cooling_mode = 1;\r\nif (tzp)\r\ntz->polling_frequency = tzp;\r\nelse\r\nacpi_thermal_get_polling_frequency(tz);\r\nreturn 0;\r\n}\r\nstatic void acpi_thermal_guess_offset(struct acpi_thermal *tz)\r\n{\r\nif (tz->trips.critical.flags.valid &&\r\n(tz->trips.critical.temperature % 5) == 1)\r\ntz->kelvin_offset = 2731;\r\nelse\r\ntz->kelvin_offset = 2732;\r\n}\r\nstatic int acpi_thermal_add(struct acpi_device *device)\r\n{\r\nint result = 0;\r\nstruct acpi_thermal *tz = NULL;\r\nif (!device)\r\nreturn -EINVAL;\r\ntz = kzalloc(sizeof(struct acpi_thermal), GFP_KERNEL);\r\nif (!tz)\r\nreturn -ENOMEM;\r\ntz->device = device;\r\nstrcpy(tz->name, device->pnp.bus_id);\r\nstrcpy(acpi_device_name(device), ACPI_THERMAL_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_THERMAL_CLASS);\r\ndevice->driver_data = tz;\r\nmutex_init(&tz->lock);\r\nresult = acpi_thermal_get_info(tz);\r\nif (result)\r\ngoto free_memory;\r\nacpi_thermal_guess_offset(tz);\r\nresult = acpi_thermal_register_thermal_zone(tz);\r\nif (result)\r\ngoto free_memory;\r\nprintk(KERN_INFO PREFIX "%s [%s] (%ld C)\n",\r\nacpi_device_name(device), acpi_device_bid(device),\r\nKELVIN_TO_CELSIUS(tz->temperature));\r\ngoto end;\r\nfree_memory:\r\nkfree(tz);\r\nend:\r\nreturn result;\r\n}\r\nstatic int acpi_thermal_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_thermal *tz = NULL;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\ntz = acpi_driver_data(device);\r\nacpi_thermal_unregister_thermal_zone(tz);\r\nmutex_destroy(&tz->lock);\r\nkfree(tz);\r\nreturn 0;\r\n}\r\nstatic int acpi_thermal_resume(struct device *dev)\r\n{\r\nstruct acpi_thermal *tz;\r\nint i, j, power_state, result;\r\nif (!dev)\r\nreturn -EINVAL;\r\ntz = acpi_driver_data(to_acpi_device(dev));\r\nif (!tz)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ACPI_THERMAL_MAX_ACTIVE; i++) {\r\nif (!(&tz->trips.active[i]))\r\nbreak;\r\nif (!tz->trips.active[i].flags.valid)\r\nbreak;\r\ntz->trips.active[i].flags.enabled = 1;\r\nfor (j = 0; j < tz->trips.active[i].devices.count; j++) {\r\nresult = acpi_bus_update_power(\r\ntz->trips.active[i].devices.handles[j],\r\n&power_state);\r\nif (result || (power_state != ACPI_STATE_D0)) {\r\ntz->trips.active[i].flags.enabled = 0;\r\nbreak;\r\n}\r\n}\r\ntz->state.active |= tz->trips.active[i].flags.enabled;\r\n}\r\nacpi_thermal_check(tz);\r\nreturn AE_OK;\r\n}\r\nstatic int thermal_act(const struct dmi_system_id *d) {\r\nif (act == 0) {\r\nprintk(KERN_NOTICE "ACPI: %s detected: "\r\n"disabling all active thermal trip points\n", d->ident);\r\nact = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int thermal_nocrt(const struct dmi_system_id *d) {\r\nprintk(KERN_NOTICE "ACPI: %s detected: "\r\n"disabling all critical thermal trip point actions.\n", d->ident);\r\nnocrt = 1;\r\nreturn 0;\r\n}\r\nstatic int thermal_tzp(const struct dmi_system_id *d) {\r\nif (tzp == 0) {\r\nprintk(KERN_NOTICE "ACPI: %s detected: "\r\n"enabling thermal zone polling\n", d->ident);\r\ntzp = 300;\r\n}\r\nreturn 0;\r\n}\r\nstatic int thermal_psv(const struct dmi_system_id *d) {\r\nif (psv == 0) {\r\nprintk(KERN_NOTICE "ACPI: %s detected: "\r\n"disabling all passive thermal trip points\n", d->ident);\r\npsv = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init acpi_thermal_init(void)\r\n{\r\nint result = 0;\r\ndmi_check_system(thermal_dmi_table);\r\nif (off) {\r\nprintk(KERN_NOTICE "ACPI: thermal control disabled\n");\r\nreturn -ENODEV;\r\n}\r\nresult = acpi_bus_register_driver(&acpi_thermal_driver);\r\nif (result < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __exit acpi_thermal_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_thermal_driver);\r\nreturn;\r\n}
