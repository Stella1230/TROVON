static inline u32 smsc9420_reg_read(struct smsc9420_pdata *pd, u32 offset)\r\n{\r\nreturn ioread32(pd->ioaddr + offset);\r\n}\r\nstatic inline void\r\nsmsc9420_reg_write(struct smsc9420_pdata *pd, u32 offset, u32 value)\r\n{\r\niowrite32(value, pd->ioaddr + offset);\r\n}\r\nstatic inline void smsc9420_pci_flush_write(struct smsc9420_pdata *pd)\r\n{\r\nsmsc9420_reg_read(pd, ID_REV);\r\n}\r\nstatic int smsc9420_mii_read(struct mii_bus *bus, int phyaddr, int regidx)\r\n{\r\nstruct smsc9420_pdata *pd = (struct smsc9420_pdata *)bus->priv;\r\nunsigned long flags;\r\nu32 addr;\r\nint i, reg = -EIO;\r\nspin_lock_irqsave(&pd->phy_lock, flags);\r\nif ((smsc9420_reg_read(pd, MII_ACCESS) & MII_ACCESS_MII_BUSY_)) {\r\nsmsc_warn(DRV, "MII is busy???");\r\ngoto out;\r\n}\r\naddr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6) |\r\nMII_ACCESS_MII_READ_;\r\nsmsc9420_reg_write(pd, MII_ACCESS, addr);\r\nfor (i = 0; i < 5; i++) {\r\nif (!(smsc9420_reg_read(pd, MII_ACCESS) &\r\nMII_ACCESS_MII_BUSY_)) {\r\nreg = (u16)smsc9420_reg_read(pd, MII_DATA);\r\ngoto out;\r\n}\r\nudelay(10);\r\n}\r\nsmsc_warn(DRV, "MII busy timeout!");\r\nout:\r\nspin_unlock_irqrestore(&pd->phy_lock, flags);\r\nreturn reg;\r\n}\r\nstatic int smsc9420_mii_write(struct mii_bus *bus, int phyaddr, int regidx,\r\nu16 val)\r\n{\r\nstruct smsc9420_pdata *pd = (struct smsc9420_pdata *)bus->priv;\r\nunsigned long flags;\r\nu32 addr;\r\nint i, reg = -EIO;\r\nspin_lock_irqsave(&pd->phy_lock, flags);\r\nif ((smsc9420_reg_read(pd, MII_ACCESS) & MII_ACCESS_MII_BUSY_)) {\r\nsmsc_warn(DRV, "MII is busy???");\r\ngoto out;\r\n}\r\nsmsc9420_reg_write(pd, MII_DATA, (u32)val);\r\naddr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6) |\r\nMII_ACCESS_MII_WRITE_;\r\nsmsc9420_reg_write(pd, MII_ACCESS, addr);\r\nfor (i = 0; i < 5; i++) {\r\nif (!(smsc9420_reg_read(pd, MII_ACCESS) &\r\nMII_ACCESS_MII_BUSY_)) {\r\nreg = 0;\r\ngoto out;\r\n}\r\nudelay(10);\r\n}\r\nsmsc_warn(DRV, "MII busy timeout!");\r\nout:\r\nspin_unlock_irqrestore(&pd->phy_lock, flags);\r\nreturn reg;\r\n}\r\nstatic u32 smsc9420_hash(u8 addr[ETH_ALEN])\r\n{\r\nreturn (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;\r\n}\r\nstatic int smsc9420_eeprom_reload(struct smsc9420_pdata *pd)\r\n{\r\nint timeout = 100000;\r\nBUG_ON(!pd);\r\nif (smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_) {\r\nsmsc_dbg(DRV, "smsc9420_eeprom_reload: Eeprom busy");\r\nreturn -EIO;\r\n}\r\nsmsc9420_reg_write(pd, E2P_CMD,\r\n(E2P_CMD_EPC_BUSY_ | E2P_CMD_EPC_CMD_RELOAD_));\r\ndo {\r\nudelay(10);\r\nif (!(smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_))\r\nreturn 0;\r\n} while (timeout--);\r\nsmsc_warn(DRV, "smsc9420_eeprom_reload: Eeprom timed out");\r\nreturn -EIO;\r\n}\r\nstatic int smsc9420_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nif (!netif_running(dev) || !pd->phy_dev)\r\nreturn -EINVAL;\r\nreturn phy_mii_ioctl(pd->phy_dev, ifr, cmd);\r\n}\r\nstatic int smsc9420_ethtool_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nif (!pd->phy_dev)\r\nreturn -ENODEV;\r\ncmd->maxtxpkt = 1;\r\ncmd->maxrxpkt = 1;\r\nreturn phy_ethtool_gset(pd->phy_dev, cmd);\r\n}\r\nstatic int smsc9420_ethtool_set_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nif (!pd->phy_dev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(pd->phy_dev, cmd);\r\n}\r\nstatic void smsc9420_ethtool_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(netdev);\r\nstrlcpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->bus_info, pci_name(pd->pdev),\r\nsizeof(drvinfo->bus_info));\r\nstrlcpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));\r\n}\r\nstatic u32 smsc9420_ethtool_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(netdev);\r\nreturn pd->msg_enable;\r\n}\r\nstatic void smsc9420_ethtool_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(netdev);\r\npd->msg_enable = data;\r\n}\r\nstatic int smsc9420_ethtool_nway_reset(struct net_device *netdev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(netdev);\r\nif (!pd->phy_dev)\r\nreturn -ENODEV;\r\nreturn phy_start_aneg(pd->phy_dev);\r\n}\r\nstatic int smsc9420_ethtool_getregslen(struct net_device *dev)\r\n{\r\nreturn 0x100 + (32 * sizeof(u32));\r\n}\r\nstatic void\r\nsmsc9420_ethtool_getregs(struct net_device *dev, struct ethtool_regs *regs,\r\nvoid *buf)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nstruct phy_device *phy_dev = pd->phy_dev;\r\nunsigned int i, j = 0;\r\nu32 *data = buf;\r\nregs->version = smsc9420_reg_read(pd, ID_REV);\r\nfor (i = 0; i < 0x100; i += (sizeof(u32)))\r\ndata[j++] = smsc9420_reg_read(pd, i);\r\nif (!phy_dev)\r\nreturn;\r\nfor (i = 0; i <= 31; i++)\r\ndata[j++] = smsc9420_mii_read(phy_dev->bus, phy_dev->addr, i);\r\n}\r\nstatic void smsc9420_eeprom_enable_access(struct smsc9420_pdata *pd)\r\n{\r\nunsigned int temp = smsc9420_reg_read(pd, GPIO_CFG);\r\ntemp &= ~GPIO_CFG_EEPR_EN_;\r\nsmsc9420_reg_write(pd, GPIO_CFG, temp);\r\nmsleep(1);\r\n}\r\nstatic int smsc9420_eeprom_send_cmd(struct smsc9420_pdata *pd, u32 op)\r\n{\r\nint timeout = 100;\r\nu32 e2cmd;\r\nsmsc_dbg(HW, "op 0x%08x", op);\r\nif (smsc9420_reg_read(pd, E2P_CMD) & E2P_CMD_EPC_BUSY_) {\r\nsmsc_warn(HW, "Busy at start");\r\nreturn -EBUSY;\r\n}\r\ne2cmd = op | E2P_CMD_EPC_BUSY_;\r\nsmsc9420_reg_write(pd, E2P_CMD, e2cmd);\r\ndo {\r\nmsleep(1);\r\ne2cmd = smsc9420_reg_read(pd, E2P_CMD);\r\n} while ((e2cmd & E2P_CMD_EPC_BUSY_) && (--timeout));\r\nif (!timeout) {\r\nsmsc_info(HW, "TIMED OUT");\r\nreturn -EAGAIN;\r\n}\r\nif (e2cmd & E2P_CMD_EPC_TIMEOUT_) {\r\nsmsc_info(HW, "Error occurred during eeprom operation");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc9420_eeprom_read_location(struct smsc9420_pdata *pd,\r\nu8 address, u8 *data)\r\n{\r\nu32 op = E2P_CMD_EPC_CMD_READ_ | address;\r\nint ret;\r\nsmsc_dbg(HW, "address 0x%x", address);\r\nret = smsc9420_eeprom_send_cmd(pd, op);\r\nif (!ret)\r\ndata[address] = smsc9420_reg_read(pd, E2P_DATA);\r\nreturn ret;\r\n}\r\nstatic int smsc9420_eeprom_write_location(struct smsc9420_pdata *pd,\r\nu8 address, u8 data)\r\n{\r\nu32 op = E2P_CMD_EPC_CMD_ERASE_ | address;\r\nint ret;\r\nsmsc_dbg(HW, "address 0x%x, data 0x%x", address, data);\r\nret = smsc9420_eeprom_send_cmd(pd, op);\r\nif (!ret) {\r\nop = E2P_CMD_EPC_CMD_WRITE_ | address;\r\nsmsc9420_reg_write(pd, E2P_DATA, (u32)data);\r\nret = smsc9420_eeprom_send_cmd(pd, op);\r\n}\r\nreturn ret;\r\n}\r\nstatic int smsc9420_ethtool_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn SMSC9420_EEPROM_SIZE;\r\n}\r\nstatic int smsc9420_ethtool_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nu8 eeprom_data[SMSC9420_EEPROM_SIZE];\r\nint len, i;\r\nsmsc9420_eeprom_enable_access(pd);\r\nlen = min(eeprom->len, SMSC9420_EEPROM_SIZE);\r\nfor (i = 0; i < len; i++) {\r\nint ret = smsc9420_eeprom_read_location(pd, i, eeprom_data);\r\nif (ret < 0) {\r\neeprom->len = 0;\r\nreturn ret;\r\n}\r\n}\r\nmemcpy(data, &eeprom_data[eeprom->offset], len);\r\neeprom->magic = SMSC9420_EEPROM_MAGIC;\r\neeprom->len = len;\r\nreturn 0;\r\n}\r\nstatic int smsc9420_ethtool_set_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nint ret;\r\nif (eeprom->magic != SMSC9420_EEPROM_MAGIC)\r\nreturn -EINVAL;\r\nsmsc9420_eeprom_enable_access(pd);\r\nsmsc9420_eeprom_send_cmd(pd, E2P_CMD_EPC_CMD_EWEN_);\r\nret = smsc9420_eeprom_write_location(pd, eeprom->offset, *data);\r\nsmsc9420_eeprom_send_cmd(pd, E2P_CMD_EPC_CMD_EWDS_);\r\neeprom->len = 1;\r\nreturn ret;\r\n}\r\nstatic void smsc9420_set_mac_address(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nu8 *dev_addr = dev->dev_addr;\r\nu32 mac_high16 = (dev_addr[5] << 8) | dev_addr[4];\r\nu32 mac_low32 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\r\n(dev_addr[1] << 8) | dev_addr[0];\r\nsmsc9420_reg_write(pd, ADDRH, mac_high16);\r\nsmsc9420_reg_write(pd, ADDRL, mac_low32);\r\n}\r\nstatic void smsc9420_check_mac_address(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nif (is_valid_ether_addr(dev->dev_addr)) {\r\nsmsc9420_set_mac_address(dev);\r\nsmsc_dbg(PROBE, "MAC Address is specified by configuration");\r\n} else {\r\nu32 mac_high16 = smsc9420_reg_read(pd, ADDRH);\r\nu32 mac_low32 = smsc9420_reg_read(pd, ADDRL);\r\ndev->dev_addr[0] = (u8)(mac_low32);\r\ndev->dev_addr[1] = (u8)(mac_low32 >> 8);\r\ndev->dev_addr[2] = (u8)(mac_low32 >> 16);\r\ndev->dev_addr[3] = (u8)(mac_low32 >> 24);\r\ndev->dev_addr[4] = (u8)(mac_high16);\r\ndev->dev_addr[5] = (u8)(mac_high16 >> 8);\r\nif (is_valid_ether_addr(dev->dev_addr)) {\r\nsmsc_dbg(PROBE, "Mac Address is read from EEPROM");\r\n} else {\r\neth_hw_addr_random(dev);\r\nsmsc9420_set_mac_address(dev);\r\nsmsc_dbg(PROBE, "MAC Address is set to random");\r\n}\r\n}\r\n}\r\nstatic void smsc9420_stop_tx(struct smsc9420_pdata *pd)\r\n{\r\nu32 dmac_control, mac_cr, dma_intr_ena;\r\nint timeout = 1000;\r\ndmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);\r\ndmac_control &= (~DMAC_CONTROL_ST_);\r\nsmsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);\r\nwhile (--timeout) {\r\nif (smsc9420_reg_read(pd, DMAC_STATUS) & DMAC_STS_TS_)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!timeout)\r\nsmsc_warn(IFDOWN, "TX DMAC failed to stop");\r\nsmsc9420_reg_write(pd, DMAC_STATUS, DMAC_STS_TXPS_);\r\ndma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\r\ndma_intr_ena &= ~(DMAC_INTR_ENA_TX_);\r\nsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\r\nsmsc9420_pci_flush_write(pd);\r\nmac_cr = smsc9420_reg_read(pd, MAC_CR) & (~MAC_CR_TXEN_);\r\nsmsc9420_reg_write(pd, MAC_CR, mac_cr);\r\nsmsc9420_pci_flush_write(pd);\r\n}\r\nstatic void smsc9420_free_tx_ring(struct smsc9420_pdata *pd)\r\n{\r\nint i;\r\nBUG_ON(!pd->tx_ring);\r\nif (!pd->tx_buffers)\r\nreturn;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = pd->tx_buffers[i].skb;\r\nif (skb) {\r\nBUG_ON(!pd->tx_buffers[i].mapping);\r\npci_unmap_single(pd->pdev, pd->tx_buffers[i].mapping,\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb_any(skb);\r\n}\r\npd->tx_ring[i].status = 0;\r\npd->tx_ring[i].length = 0;\r\npd->tx_ring[i].buffer1 = 0;\r\npd->tx_ring[i].buffer2 = 0;\r\n}\r\nwmb();\r\nkfree(pd->tx_buffers);\r\npd->tx_buffers = NULL;\r\npd->tx_ring_head = 0;\r\npd->tx_ring_tail = 0;\r\n}\r\nstatic void smsc9420_free_rx_ring(struct smsc9420_pdata *pd)\r\n{\r\nint i;\r\nBUG_ON(!pd->rx_ring);\r\nif (!pd->rx_buffers)\r\nreturn;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nif (pd->rx_buffers[i].skb)\r\ndev_kfree_skb_any(pd->rx_buffers[i].skb);\r\nif (pd->rx_buffers[i].mapping)\r\npci_unmap_single(pd->pdev, pd->rx_buffers[i].mapping,\r\nPKT_BUF_SZ, PCI_DMA_FROMDEVICE);\r\npd->rx_ring[i].status = 0;\r\npd->rx_ring[i].length = 0;\r\npd->rx_ring[i].buffer1 = 0;\r\npd->rx_ring[i].buffer2 = 0;\r\n}\r\nwmb();\r\nkfree(pd->rx_buffers);\r\npd->rx_buffers = NULL;\r\npd->rx_ring_head = 0;\r\npd->rx_ring_tail = 0;\r\n}\r\nstatic void smsc9420_stop_rx(struct smsc9420_pdata *pd)\r\n{\r\nint timeout = 1000;\r\nu32 mac_cr, dmac_control, dma_intr_ena;\r\ndma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\r\ndma_intr_ena &= (~DMAC_INTR_ENA_RX_);\r\nsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\r\nsmsc9420_pci_flush_write(pd);\r\nmac_cr = smsc9420_reg_read(pd, MAC_CR) & (~MAC_CR_RXEN_);\r\nsmsc9420_reg_write(pd, MAC_CR, mac_cr);\r\nsmsc9420_pci_flush_write(pd);\r\ndmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);\r\ndmac_control &= (~DMAC_CONTROL_SR_);\r\nsmsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);\r\nsmsc9420_pci_flush_write(pd);\r\nwhile (--timeout) {\r\nif (smsc9420_reg_read(pd, DMAC_STATUS) & DMAC_STS_RS_)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!timeout)\r\nsmsc_warn(IFDOWN, "RX DMAC did not stop! timeout.");\r\nsmsc9420_reg_write(pd, DMAC_STATUS, DMAC_STS_RXPS_);\r\n}\r\nstatic irqreturn_t smsc9420_isr(int irq, void *dev_id)\r\n{\r\nstruct smsc9420_pdata *pd = dev_id;\r\nu32 int_cfg, int_sts, int_ctl;\r\nirqreturn_t ret = IRQ_NONE;\r\nulong flags;\r\nBUG_ON(!pd);\r\nBUG_ON(!pd->ioaddr);\r\nint_cfg = smsc9420_reg_read(pd, INT_CFG);\r\nif ((int_cfg & (INT_CFG_IRQ_EN_ | INT_CFG_IRQ_INT_)) !=\r\n(INT_CFG_IRQ_EN_ | INT_CFG_IRQ_INT_))\r\nreturn IRQ_NONE;\r\nint_sts = smsc9420_reg_read(pd, INT_STAT);\r\nif (likely(INT_STAT_DMAC_INT_ & int_sts)) {\r\nu32 status = smsc9420_reg_read(pd, DMAC_STATUS);\r\nu32 ints_to_clear = 0;\r\nif (status & DMAC_STS_TX_) {\r\nints_to_clear |= (DMAC_STS_TX_ | DMAC_STS_NIS_);\r\nnetif_wake_queue(pd->dev);\r\n}\r\nif (status & DMAC_STS_RX_) {\r\nu32 dma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\r\ndma_intr_ena &= (~DMAC_INTR_ENA_RX_);\r\nsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\r\nsmsc9420_pci_flush_write(pd);\r\nints_to_clear |= (DMAC_STS_RX_ | DMAC_STS_NIS_);\r\nnapi_schedule(&pd->napi);\r\n}\r\nif (ints_to_clear)\r\nsmsc9420_reg_write(pd, DMAC_STATUS, ints_to_clear);\r\nret = IRQ_HANDLED;\r\n}\r\nif (unlikely(INT_STAT_SW_INT_ & int_sts)) {\r\nspin_lock_irqsave(&pd->int_lock, flags);\r\nint_ctl = smsc9420_reg_read(pd, INT_CTL);\r\nint_ctl &= (~INT_CTL_SW_INT_EN_);\r\nsmsc9420_reg_write(pd, INT_CTL, int_ctl);\r\nspin_unlock_irqrestore(&pd->int_lock, flags);\r\nsmsc9420_reg_write(pd, INT_STAT, INT_STAT_SW_INT_);\r\npd->software_irq_signal = true;\r\nsmp_wmb();\r\nret = IRQ_HANDLED;\r\n}\r\nsmsc9420_pci_flush_write(pd);\r\nreturn ret;\r\n}\r\nstatic void smsc9420_poll_controller(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nconst int irq = pd->pdev->irq;\r\ndisable_irq(irq);\r\nsmsc9420_isr(0, dev);\r\nenable_irq(irq);\r\n}\r\nstatic void smsc9420_dmac_soft_reset(struct smsc9420_pdata *pd)\r\n{\r\nsmsc9420_reg_write(pd, BUS_MODE, BUS_MODE_SWR_);\r\nsmsc9420_reg_read(pd, BUS_MODE);\r\nudelay(2);\r\nif (smsc9420_reg_read(pd, BUS_MODE) & BUS_MODE_SWR_)\r\nsmsc_warn(DRV, "Software reset not cleared");\r\n}\r\nstatic int smsc9420_stop(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nu32 int_cfg;\r\nulong flags;\r\nBUG_ON(!pd);\r\nBUG_ON(!pd->phy_dev);\r\nspin_lock_irqsave(&pd->int_lock, flags);\r\nint_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);\r\nsmsc9420_reg_write(pd, INT_CFG, int_cfg);\r\nspin_unlock_irqrestore(&pd->int_lock, flags);\r\nnetif_tx_disable(dev);\r\nnapi_disable(&pd->napi);\r\nsmsc9420_stop_tx(pd);\r\nsmsc9420_free_tx_ring(pd);\r\nsmsc9420_stop_rx(pd);\r\nsmsc9420_free_rx_ring(pd);\r\nfree_irq(pd->pdev->irq, pd);\r\nsmsc9420_dmac_soft_reset(pd);\r\nphy_stop(pd->phy_dev);\r\nphy_disconnect(pd->phy_dev);\r\npd->phy_dev = NULL;\r\nmdiobus_unregister(pd->mii_bus);\r\nmdiobus_free(pd->mii_bus);\r\nreturn 0;\r\n}\r\nstatic void smsc9420_rx_count_stats(struct net_device *dev, u32 desc_status)\r\n{\r\nif (unlikely(desc_status & RDES0_ERROR_SUMMARY_)) {\r\ndev->stats.rx_errors++;\r\nif (desc_status & RDES0_DESCRIPTOR_ERROR_)\r\ndev->stats.rx_over_errors++;\r\nelse if (desc_status & (RDES0_FRAME_TOO_LONG_ |\r\nRDES0_RUNT_FRAME_ | RDES0_COLLISION_SEEN_))\r\ndev->stats.rx_frame_errors++;\r\nelse if (desc_status & RDES0_CRC_ERROR_)\r\ndev->stats.rx_crc_errors++;\r\n}\r\nif (unlikely(desc_status & RDES0_LENGTH_ERROR_))\r\ndev->stats.rx_length_errors++;\r\nif (unlikely(!((desc_status & RDES0_LAST_DESCRIPTOR_) &&\r\n(desc_status & RDES0_FIRST_DESCRIPTOR_))))\r\ndev->stats.rx_length_errors++;\r\nif (desc_status & RDES0_MULTICAST_FRAME_)\r\ndev->stats.multicast++;\r\n}\r\nstatic void smsc9420_rx_handoff(struct smsc9420_pdata *pd, const int index,\r\nconst u32 status)\r\n{\r\nstruct net_device *dev = pd->dev;\r\nstruct sk_buff *skb;\r\nu16 packet_length = (status & RDES0_FRAME_LENGTH_MASK_)\r\n>> RDES0_FRAME_LENGTH_SHFT_;\r\npacket_length -= 4;\r\nif (pd->rx_csum)\r\npacket_length -= 2;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += packet_length;\r\npci_unmap_single(pd->pdev, pd->rx_buffers[index].mapping,\r\nPKT_BUF_SZ, PCI_DMA_FROMDEVICE);\r\npd->rx_buffers[index].mapping = 0;\r\nskb = pd->rx_buffers[index].skb;\r\npd->rx_buffers[index].skb = NULL;\r\nif (pd->rx_csum) {\r\nu16 hw_csum = get_unaligned_le16(skb_tail_pointer(skb) +\r\nNET_IP_ALIGN + packet_length + 4);\r\nput_unaligned_le16(hw_csum, &skb->csum);\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\n}\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nskb_put(skb, packet_length);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int smsc9420_alloc_rx_buffer(struct smsc9420_pdata *pd, int index)\r\n{\r\nstruct sk_buff *skb = netdev_alloc_skb(pd->dev, PKT_BUF_SZ);\r\ndma_addr_t mapping;\r\nBUG_ON(pd->rx_buffers[index].skb);\r\nBUG_ON(pd->rx_buffers[index].mapping);\r\nif (unlikely(!skb))\r\nreturn -ENOMEM;\r\nmapping = pci_map_single(pd->pdev, skb_tail_pointer(skb),\r\nPKT_BUF_SZ, PCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(pd->pdev, mapping)) {\r\ndev_kfree_skb_any(skb);\r\nsmsc_warn(RX_ERR, "pci_map_single failed!");\r\nreturn -ENOMEM;\r\n}\r\npd->rx_buffers[index].skb = skb;\r\npd->rx_buffers[index].mapping = mapping;\r\npd->rx_ring[index].buffer1 = mapping + NET_IP_ALIGN;\r\npd->rx_ring[index].status = RDES0_OWN_;\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic void smsc9420_alloc_new_rx_buffers(struct smsc9420_pdata *pd)\r\n{\r\nwhile (pd->rx_ring_tail != pd->rx_ring_head) {\r\nif (smsc9420_alloc_rx_buffer(pd, pd->rx_ring_tail))\r\nbreak;\r\npd->rx_ring_tail = (pd->rx_ring_tail + 1) % RX_RING_SIZE;\r\n}\r\n}\r\nstatic int smsc9420_rx_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct smsc9420_pdata *pd =\r\ncontainer_of(napi, struct smsc9420_pdata, napi);\r\nstruct net_device *dev = pd->dev;\r\nu32 drop_frame_cnt, dma_intr_ena, status;\r\nint work_done;\r\nfor (work_done = 0; work_done < budget; work_done++) {\r\nrmb();\r\nstatus = pd->rx_ring[pd->rx_ring_head].status;\r\nif (status & RDES0_OWN_)\r\nbreak;\r\nsmsc9420_rx_count_stats(dev, status);\r\nsmsc9420_rx_handoff(pd, pd->rx_ring_head, status);\r\npd->rx_ring_head = (pd->rx_ring_head + 1) % RX_RING_SIZE;\r\nsmsc9420_alloc_new_rx_buffers(pd);\r\n}\r\ndrop_frame_cnt = smsc9420_reg_read(pd, MISS_FRAME_CNTR);\r\ndev->stats.rx_dropped +=\r\n(drop_frame_cnt & 0xFFFF) + ((drop_frame_cnt >> 17) & 0x3FF);\r\nsmsc9420_reg_write(pd, RX_POLL_DEMAND, 1);\r\nsmsc9420_pci_flush_write(pd);\r\nif (work_done < budget) {\r\nnapi_complete(&pd->napi);\r\ndma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\r\ndma_intr_ena |= (DMAC_INTR_ENA_RX_ | DMAC_INTR_ENA_NIS_);\r\nsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\r\nsmsc9420_pci_flush_write(pd);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void\r\nsmsc9420_tx_update_stats(struct net_device *dev, u32 status, u32 length)\r\n{\r\nif (unlikely(status & TDES0_ERROR_SUMMARY_)) {\r\ndev->stats.tx_errors++;\r\nif (status & (TDES0_EXCESSIVE_DEFERRAL_ |\r\nTDES0_EXCESSIVE_COLLISIONS_))\r\ndev->stats.tx_aborted_errors++;\r\nif (status & (TDES0_LOSS_OF_CARRIER_ | TDES0_NO_CARRIER_))\r\ndev->stats.tx_carrier_errors++;\r\n} else {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += (length & 0x7FF);\r\n}\r\nif (unlikely(status & TDES0_EXCESSIVE_COLLISIONS_)) {\r\ndev->stats.collisions += 16;\r\n} else {\r\ndev->stats.collisions +=\r\n(status & TDES0_COLLISION_COUNT_MASK_) >>\r\nTDES0_COLLISION_COUNT_SHFT_;\r\n}\r\nif (unlikely(status & TDES0_HEARTBEAT_FAIL_))\r\ndev->stats.tx_heartbeat_errors++;\r\n}\r\nstatic void smsc9420_complete_tx(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nwhile (pd->tx_ring_tail != pd->tx_ring_head) {\r\nint index = pd->tx_ring_tail;\r\nu32 status, length;\r\nrmb();\r\nstatus = pd->tx_ring[index].status;\r\nlength = pd->tx_ring[index].length;\r\nif (unlikely(TDES0_OWN_ & status))\r\nbreak;\r\nsmsc9420_tx_update_stats(dev, status, length);\r\nBUG_ON(!pd->tx_buffers[index].skb);\r\nBUG_ON(!pd->tx_buffers[index].mapping);\r\npci_unmap_single(pd->pdev, pd->tx_buffers[index].mapping,\r\npd->tx_buffers[index].skb->len, PCI_DMA_TODEVICE);\r\npd->tx_buffers[index].mapping = 0;\r\ndev_kfree_skb_any(pd->tx_buffers[index].skb);\r\npd->tx_buffers[index].skb = NULL;\r\npd->tx_ring[index].buffer1 = 0;\r\nwmb();\r\npd->tx_ring_tail = (pd->tx_ring_tail + 1) % TX_RING_SIZE;\r\n}\r\n}\r\nstatic netdev_tx_t smsc9420_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\ndma_addr_t mapping;\r\nint index = pd->tx_ring_head;\r\nu32 tmp_desc1;\r\nbool about_to_take_last_desc =\r\n(((pd->tx_ring_head + 2) % TX_RING_SIZE) == pd->tx_ring_tail);\r\nsmsc9420_complete_tx(dev);\r\nrmb();\r\nBUG_ON(pd->tx_ring[index].status & TDES0_OWN_);\r\nBUG_ON(pd->tx_buffers[index].skb);\r\nBUG_ON(pd->tx_buffers[index].mapping);\r\nmapping = pci_map_single(pd->pdev, skb->data,\r\nskb->len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(pd->pdev, mapping)) {\r\nsmsc_warn(TX_ERR, "pci_map_single failed, dropping packet");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\npd->tx_buffers[index].skb = skb;\r\npd->tx_buffers[index].mapping = mapping;\r\ntmp_desc1 = (TDES1_LS_ | ((u32)skb->len & 0x7FF));\r\nif (unlikely(about_to_take_last_desc)) {\r\ntmp_desc1 |= TDES1_IC_;\r\nnetif_stop_queue(pd->dev);\r\n}\r\nif (unlikely(index == (TX_RING_SIZE - 1)))\r\ntmp_desc1 |= TDES1_TER_;\r\npd->tx_ring[index].buffer1 = mapping;\r\npd->tx_ring[index].length = tmp_desc1;\r\nwmb();\r\npd->tx_ring_head = (pd->tx_ring_head + 1) % TX_RING_SIZE;\r\npd->tx_ring[index].status = TDES0_OWN_;\r\nwmb();\r\nskb_tx_timestamp(skb);\r\nsmsc9420_reg_write(pd, TX_POLL_DEMAND, 1);\r\nsmsc9420_pci_flush_write(pd);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *smsc9420_get_stats(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nu32 counter = smsc9420_reg_read(pd, MISS_FRAME_CNTR);\r\ndev->stats.rx_dropped +=\r\n(counter & 0x0000FFFF) + ((counter >> 17) & 0x000003FF);\r\nreturn &dev->stats;\r\n}\r\nstatic void smsc9420_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nu32 mac_cr = smsc9420_reg_read(pd, MAC_CR);\r\nif (dev->flags & IFF_PROMISC) {\r\nsmsc_dbg(HW, "Promiscuous Mode Enabled");\r\nmac_cr |= MAC_CR_PRMS_;\r\nmac_cr &= (~MAC_CR_MCPAS_);\r\nmac_cr &= (~MAC_CR_HPFILT_);\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\nsmsc_dbg(HW, "Receive all Multicast Enabled");\r\nmac_cr &= (~MAC_CR_PRMS_);\r\nmac_cr |= MAC_CR_MCPAS_;\r\nmac_cr &= (~MAC_CR_HPFILT_);\r\n} else if (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nu32 hash_lo = 0, hash_hi = 0;\r\nsmsc_dbg(HW, "Multicast filter enabled");\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu32 bit_num = smsc9420_hash(ha->addr);\r\nu32 mask = 1 << (bit_num & 0x1F);\r\nif (bit_num & 0x20)\r\nhash_hi |= mask;\r\nelse\r\nhash_lo |= mask;\r\n}\r\nsmsc9420_reg_write(pd, HASHH, hash_hi);\r\nsmsc9420_reg_write(pd, HASHL, hash_lo);\r\nmac_cr &= (~MAC_CR_PRMS_);\r\nmac_cr &= (~MAC_CR_MCPAS_);\r\nmac_cr |= MAC_CR_HPFILT_;\r\n} else {\r\nsmsc_dbg(HW, "Receive own packets only.");\r\nsmsc9420_reg_write(pd, HASHH, 0);\r\nsmsc9420_reg_write(pd, HASHL, 0);\r\nmac_cr &= (~MAC_CR_PRMS_);\r\nmac_cr &= (~MAC_CR_MCPAS_);\r\nmac_cr &= (~MAC_CR_HPFILT_);\r\n}\r\nsmsc9420_reg_write(pd, MAC_CR, mac_cr);\r\nsmsc9420_pci_flush_write(pd);\r\n}\r\nstatic void smsc9420_phy_update_flowcontrol(struct smsc9420_pdata *pd)\r\n{\r\nstruct phy_device *phy_dev = pd->phy_dev;\r\nu32 flow;\r\nif (phy_dev->duplex == DUPLEX_FULL) {\r\nu16 lcladv = phy_read(phy_dev, MII_ADVERTISE);\r\nu16 rmtadv = phy_read(phy_dev, MII_LPA);\r\nu8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\r\nif (cap & FLOW_CTRL_RX)\r\nflow = 0xFFFF0002;\r\nelse\r\nflow = 0;\r\nsmsc_info(LINK, "rx pause %s, tx pause %s",\r\n(cap & FLOW_CTRL_RX ? "enabled" : "disabled"),\r\n(cap & FLOW_CTRL_TX ? "enabled" : "disabled"));\r\n} else {\r\nsmsc_info(LINK, "half duplex");\r\nflow = 0;\r\n}\r\nsmsc9420_reg_write(pd, FLOW, flow);\r\n}\r\nstatic void smsc9420_phy_adjust_link(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nstruct phy_device *phy_dev = pd->phy_dev;\r\nint carrier;\r\nif (phy_dev->duplex != pd->last_duplex) {\r\nu32 mac_cr = smsc9420_reg_read(pd, MAC_CR);\r\nif (phy_dev->duplex) {\r\nsmsc_dbg(LINK, "full duplex mode");\r\nmac_cr |= MAC_CR_FDPX_;\r\n} else {\r\nsmsc_dbg(LINK, "half duplex mode");\r\nmac_cr &= ~MAC_CR_FDPX_;\r\n}\r\nsmsc9420_reg_write(pd, MAC_CR, mac_cr);\r\nsmsc9420_phy_update_flowcontrol(pd);\r\npd->last_duplex = phy_dev->duplex;\r\n}\r\ncarrier = netif_carrier_ok(dev);\r\nif (carrier != pd->last_carrier) {\r\nif (carrier)\r\nsmsc_dbg(LINK, "carrier OK");\r\nelse\r\nsmsc_dbg(LINK, "no carrier");\r\npd->last_carrier = carrier;\r\n}\r\n}\r\nstatic int smsc9420_mii_probe(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nstruct phy_device *phydev = NULL;\r\nBUG_ON(pd->phy_dev);\r\nif (!pd->mii_bus->phy_map[1]) {\r\npr_err("%s: no PHY found at address 1\n", dev->name);\r\nreturn -ENODEV;\r\n}\r\nphydev = pd->mii_bus->phy_map[1];\r\nsmsc_info(PROBE, "PHY addr %d, phy_id 0x%08X", phydev->addr,\r\nphydev->phy_id);\r\nphydev = phy_connect(dev, dev_name(&phydev->dev),\r\nsmsc9420_phy_adjust_link, PHY_INTERFACE_MODE_MII);\r\nif (IS_ERR(phydev)) {\r\npr_err("%s: Could not attach to PHY\n", dev->name);\r\nreturn PTR_ERR(phydev);\r\n}\r\npr_info("%s: attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",\r\ndev->name, phydev->drv->name, dev_name(&phydev->dev), phydev->irq);\r\nphydev->supported &= (PHY_BASIC_FEATURES | SUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nphydev->advertising = phydev->supported;\r\npd->phy_dev = phydev;\r\npd->last_duplex = -1;\r\npd->last_carrier = -1;\r\nreturn 0;\r\n}\r\nstatic int smsc9420_mii_init(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nint err = -ENXIO, i;\r\npd->mii_bus = mdiobus_alloc();\r\nif (!pd->mii_bus) {\r\nerr = -ENOMEM;\r\ngoto err_out_1;\r\n}\r\npd->mii_bus->name = DRV_MDIONAME;\r\nsnprintf(pd->mii_bus->id, MII_BUS_ID_SIZE, "%x",\r\n(pd->pdev->bus->number << 8) | pd->pdev->devfn);\r\npd->mii_bus->priv = pd;\r\npd->mii_bus->read = smsc9420_mii_read;\r\npd->mii_bus->write = smsc9420_mii_write;\r\npd->mii_bus->irq = pd->phy_irq;\r\nfor (i = 0; i < PHY_MAX_ADDR; ++i)\r\npd->mii_bus->irq[i] = PHY_POLL;\r\npd->mii_bus->phy_mask = ~(1 << 1);\r\nif (mdiobus_register(pd->mii_bus)) {\r\nsmsc_warn(PROBE, "Error registering mii bus");\r\ngoto err_out_free_bus_2;\r\n}\r\nif (smsc9420_mii_probe(dev) < 0) {\r\nsmsc_warn(PROBE, "Error probing mii bus");\r\ngoto err_out_unregister_bus_3;\r\n}\r\nreturn 0;\r\nerr_out_unregister_bus_3:\r\nmdiobus_unregister(pd->mii_bus);\r\nerr_out_free_bus_2:\r\nmdiobus_free(pd->mii_bus);\r\nerr_out_1:\r\nreturn err;\r\n}\r\nstatic int smsc9420_alloc_tx_ring(struct smsc9420_pdata *pd)\r\n{\r\nint i;\r\nBUG_ON(!pd->tx_ring);\r\npd->tx_buffers = kmalloc_array(TX_RING_SIZE,\r\nsizeof(struct smsc9420_ring_info),\r\nGFP_KERNEL);\r\nif (!pd->tx_buffers)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\npd->tx_buffers[i].skb = NULL;\r\npd->tx_buffers[i].mapping = 0;\r\npd->tx_ring[i].status = 0;\r\npd->tx_ring[i].length = 0;\r\npd->tx_ring[i].buffer1 = 0;\r\npd->tx_ring[i].buffer2 = 0;\r\n}\r\npd->tx_ring[TX_RING_SIZE - 1].length = TDES1_TER_;\r\nwmb();\r\npd->tx_ring_head = 0;\r\npd->tx_ring_tail = 0;\r\nsmsc9420_reg_write(pd, TX_BASE_ADDR, pd->tx_dma_addr);\r\nsmsc9420_pci_flush_write(pd);\r\nreturn 0;\r\n}\r\nstatic int smsc9420_alloc_rx_ring(struct smsc9420_pdata *pd)\r\n{\r\nint i;\r\nBUG_ON(!pd->rx_ring);\r\npd->rx_buffers = kmalloc((sizeof(struct smsc9420_ring_info) *\r\nRX_RING_SIZE), GFP_KERNEL);\r\nif (pd->rx_buffers == NULL) {\r\nsmsc_warn(IFUP, "Failed to allocated rx_buffers");\r\ngoto out;\r\n}\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\npd->rx_ring[i].status = 0;\r\npd->rx_ring[i].length = PKT_BUF_SZ;\r\npd->rx_ring[i].buffer2 = 0;\r\npd->rx_buffers[i].skb = NULL;\r\npd->rx_buffers[i].mapping = 0;\r\n}\r\npd->rx_ring[RX_RING_SIZE - 1].length = (PKT_BUF_SZ | RDES1_RER_);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nif (smsc9420_alloc_rx_buffer(pd, i)) {\r\nsmsc_warn(IFUP, "failed to allocate rx skb %d", i);\r\ngoto out_free_rx_skbs;\r\n}\r\n}\r\npd->rx_ring_head = 0;\r\npd->rx_ring_tail = 0;\r\nsmsc9420_reg_write(pd, VLAN1, ETH_P_8021Q);\r\nsmsc_dbg(IFUP, "VLAN1 = 0x%08x", smsc9420_reg_read(pd, VLAN1));\r\nif (pd->rx_csum) {\r\nu32 coe = smsc9420_reg_read(pd, COE_CR) | RX_COE_EN;\r\nsmsc9420_reg_write(pd, COE_CR, coe);\r\nsmsc_dbg(IFUP, "COE_CR = 0x%08x", coe);\r\n}\r\nsmsc9420_reg_write(pd, RX_BASE_ADDR, pd->rx_dma_addr);\r\nsmsc9420_pci_flush_write(pd);\r\nreturn 0;\r\nout_free_rx_skbs:\r\nsmsc9420_free_rx_ring(pd);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nstatic int smsc9420_open(struct net_device *dev)\r\n{\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nu32 bus_mode, mac_cr, dmac_control, int_cfg, dma_intr_ena, int_ctl;\r\nconst int irq = pd->pdev->irq;\r\nunsigned long flags;\r\nint result = 0, timeout;\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nsmsc_warn(IFUP, "dev_addr is not a valid MAC address");\r\nresult = -EADDRNOTAVAIL;\r\ngoto out_0;\r\n}\r\nnetif_carrier_off(dev);\r\nspin_lock_irqsave(&pd->int_lock, flags);\r\nint_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);\r\nsmsc9420_reg_write(pd, INT_CFG, int_cfg);\r\nsmsc9420_reg_write(pd, INT_CTL, 0);\r\nspin_unlock_irqrestore(&pd->int_lock, flags);\r\nsmsc9420_reg_write(pd, DMAC_INTR_ENA, 0);\r\nsmsc9420_reg_write(pd, INT_STAT, 0xFFFFFFFF);\r\nsmsc9420_pci_flush_write(pd);\r\nresult = request_irq(irq, smsc9420_isr, IRQF_SHARED | IRQF_DISABLED,\r\nDRV_NAME, pd);\r\nif (result) {\r\nsmsc_warn(IFUP, "Unable to use IRQ = %d", irq);\r\nresult = -ENODEV;\r\ngoto out_0;\r\n}\r\nsmsc9420_dmac_soft_reset(pd);\r\nsmsc9420_reg_write(pd, MAC_CR, 0);\r\nsmsc9420_set_mac_address(dev);\r\nsmsc9420_reg_write(pd, GPIO_CFG,\r\n(GPIO_CFG_LED_3_ | GPIO_CFG_LED_2_ | GPIO_CFG_LED_1_));\r\nbus_mode = BUS_MODE_DMA_BURST_LENGTH_16;\r\n#ifdef __BIG_ENDIAN\r\nbus_mode |= BUS_MODE_DBO_;\r\n#endif\r\nsmsc9420_reg_write(pd, BUS_MODE, bus_mode);\r\nsmsc9420_pci_flush_write(pd);\r\nsmsc9420_reg_write(pd, BUS_CFG, BUS_CFG_RXTXWEIGHT_4_1);\r\nsmsc9420_reg_write(pd, DMAC_CONTROL,\r\n(DMAC_CONTROL_SF_ | DMAC_CONTROL_OSF_));\r\nsmsc9420_pci_flush_write(pd);\r\nsmsc_dbg(IFUP, "Testing ISR using IRQ %d", irq);\r\npd->software_irq_signal = false;\r\nspin_lock_irqsave(&pd->int_lock, flags);\r\nint_cfg = smsc9420_reg_read(pd, INT_CFG) | INT_CFG_IRQ_EN_;\r\nint_cfg &= ~(INT_CFG_INT_DEAS_MASK);\r\nint_cfg |= (INT_DEAS_TIME & INT_CFG_INT_DEAS_MASK);\r\nsmsc9420_reg_write(pd, INT_CFG, int_cfg);\r\nint_ctl = smsc9420_reg_read(pd, INT_CTL) | INT_CTL_SW_INT_EN_;\r\nsmsc9420_reg_write(pd, INT_CTL, int_ctl);\r\nspin_unlock_irqrestore(&pd->int_lock, flags);\r\nsmsc9420_pci_flush_write(pd);\r\ntimeout = 1000;\r\nwhile (timeout--) {\r\nif (pd->software_irq_signal)\r\nbreak;\r\nmsleep(1);\r\n}\r\nspin_lock_irqsave(&pd->int_lock, flags);\r\nint_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);\r\nsmsc9420_reg_write(pd, INT_CFG, int_cfg);\r\nspin_unlock_irqrestore(&pd->int_lock, flags);\r\nif (!pd->software_irq_signal) {\r\nsmsc_warn(IFUP, "ISR failed signaling test");\r\nresult = -ENODEV;\r\ngoto out_free_irq_1;\r\n}\r\nsmsc_dbg(IFUP, "ISR passed test using IRQ %d", irq);\r\nresult = smsc9420_alloc_tx_ring(pd);\r\nif (result) {\r\nsmsc_warn(IFUP, "Failed to Initialize tx dma ring");\r\nresult = -ENOMEM;\r\ngoto out_free_irq_1;\r\n}\r\nresult = smsc9420_alloc_rx_ring(pd);\r\nif (result) {\r\nsmsc_warn(IFUP, "Failed to Initialize rx dma ring");\r\nresult = -ENOMEM;\r\ngoto out_free_tx_ring_2;\r\n}\r\nresult = smsc9420_mii_init(dev);\r\nif (result) {\r\nsmsc_warn(IFUP, "Failed to initialize Phy");\r\nresult = -ENODEV;\r\ngoto out_free_rx_ring_3;\r\n}\r\nphy_start(pd->phy_dev);\r\nnapi_enable(&pd->napi);\r\nmac_cr = smsc9420_reg_read(pd, MAC_CR) | MAC_CR_TXEN_ | MAC_CR_RXEN_;\r\nsmsc9420_reg_write(pd, MAC_CR, mac_cr);\r\ndmac_control = smsc9420_reg_read(pd, DMAC_CONTROL);\r\ndmac_control |= DMAC_CONTROL_ST_ | DMAC_CONTROL_SR_;\r\nsmsc9420_reg_write(pd, DMAC_CONTROL, dmac_control);\r\nsmsc9420_pci_flush_write(pd);\r\ndma_intr_ena = smsc9420_reg_read(pd, DMAC_INTR_ENA);\r\ndma_intr_ena |=\r\n(DMAC_INTR_ENA_TX_ | DMAC_INTR_ENA_RX_ | DMAC_INTR_ENA_NIS_);\r\nsmsc9420_reg_write(pd, DMAC_INTR_ENA, dma_intr_ena);\r\nsmsc9420_pci_flush_write(pd);\r\nnetif_wake_queue(dev);\r\nsmsc9420_reg_write(pd, RX_POLL_DEMAND, 1);\r\nspin_lock_irqsave(&pd->int_lock, flags);\r\nint_cfg = smsc9420_reg_read(pd, INT_CFG) | INT_CFG_IRQ_EN_;\r\nsmsc9420_reg_write(pd, INT_CFG, int_cfg);\r\nspin_unlock_irqrestore(&pd->int_lock, flags);\r\nreturn 0;\r\nout_free_rx_ring_3:\r\nsmsc9420_free_rx_ring(pd);\r\nout_free_tx_ring_2:\r\nsmsc9420_free_tx_ring(pd);\r\nout_free_irq_1:\r\nfree_irq(irq, pd);\r\nout_0:\r\nreturn result;\r\n}\r\nstatic int smsc9420_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nu32 int_cfg;\r\nulong flags;\r\nspin_lock_irqsave(&pd->int_lock, flags);\r\nint_cfg = smsc9420_reg_read(pd, INT_CFG) & (~INT_CFG_IRQ_EN_);\r\nsmsc9420_reg_write(pd, INT_CFG, int_cfg);\r\nspin_unlock_irqrestore(&pd->int_lock, flags);\r\nif (netif_running(dev)) {\r\nnetif_tx_disable(dev);\r\nsmsc9420_stop_tx(pd);\r\nsmsc9420_free_tx_ring(pd);\r\nnapi_disable(&pd->napi);\r\nsmsc9420_stop_rx(pd);\r\nsmsc9420_free_rx_ring(pd);\r\nfree_irq(pd->pdev->irq, pd);\r\nnetif_device_detach(dev);\r\n}\r\npci_save_state(pdev);\r\npci_enable_wake(pdev, pci_choose_state(pdev, state), 0);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int smsc9420_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct smsc9420_pdata *pd = netdev_priv(dev);\r\nint err;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\npci_set_master(pdev);\r\nerr = pci_enable_wake(pdev, 0, 0);\r\nif (err)\r\nsmsc_warn(IFUP, "pci_enable_wake failed: %d", err);\r\nif (netif_running(dev)) {\r\nerr = smsc9420_open(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nsmsc9420_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct net_device *dev;\r\nstruct smsc9420_pdata *pd;\r\nvoid __iomem *virt_addr;\r\nint result = 0;\r\nu32 id_rev;\r\nprintk(KERN_INFO DRV_DESCRIPTION " version " DRV_VERSION "\n");\r\nresult = pci_enable_device(pdev);\r\nif (unlikely(result)) {\r\nprintk(KERN_ERR "Cannot enable smsc9420\n");\r\ngoto out_0;\r\n}\r\npci_set_master(pdev);\r\ndev = alloc_etherdev(sizeof(*pd));\r\nif (!dev)\r\ngoto out_disable_pci_device_1;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nif (!(pci_resource_flags(pdev, SMSC_BAR) & IORESOURCE_MEM)) {\r\nprintk(KERN_ERR "Cannot find PCI device base address\n");\r\ngoto out_free_netdev_2;\r\n}\r\nif ((pci_request_regions(pdev, DRV_NAME))) {\r\nprintk(KERN_ERR "Cannot obtain PCI resources, aborting.\n");\r\ngoto out_free_netdev_2;\r\n}\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_ERR "No usable DMA configuration, aborting.\n");\r\ngoto out_free_regions_3;\r\n}\r\nvirt_addr = ioremap(pci_resource_start(pdev, SMSC_BAR),\r\npci_resource_len(pdev, SMSC_BAR));\r\nif (!virt_addr) {\r\nprintk(KERN_ERR "Cannot map device registers, aborting.\n");\r\ngoto out_free_regions_3;\r\n}\r\nvirt_addr += LAN9420_CPSR_ENDIAN_OFFSET;\r\npd = netdev_priv(dev);\r\npd->rx_ring = pci_alloc_consistent(pdev,\r\nsizeof(struct smsc9420_dma_desc) * RX_RING_SIZE +\r\nsizeof(struct smsc9420_dma_desc) * TX_RING_SIZE,\r\n&pd->rx_dma_addr);\r\nif (!pd->rx_ring)\r\ngoto out_free_io_4;\r\npd->tx_ring = (pd->rx_ring + RX_RING_SIZE);\r\npd->tx_dma_addr = pd->rx_dma_addr +\r\nsizeof(struct smsc9420_dma_desc) * RX_RING_SIZE;\r\npd->pdev = pdev;\r\npd->dev = dev;\r\npd->ioaddr = virt_addr;\r\npd->msg_enable = smsc_debug;\r\npd->rx_csum = true;\r\nsmsc_dbg(PROBE, "lan_base=0x%08lx", (ulong)virt_addr);\r\nid_rev = smsc9420_reg_read(pd, ID_REV);\r\nswitch (id_rev & 0xFFFF0000) {\r\ncase 0x94200000:\r\nsmsc_info(PROBE, "LAN9420 identified, ID_REV=0x%08X", id_rev);\r\nbreak;\r\ndefault:\r\nsmsc_warn(PROBE, "LAN9420 NOT identified");\r\nsmsc_warn(PROBE, "ID_REV=0x%08X", id_rev);\r\ngoto out_free_dmadesc_5;\r\n}\r\nsmsc9420_dmac_soft_reset(pd);\r\nsmsc9420_eeprom_reload(pd);\r\nsmsc9420_check_mac_address(dev);\r\ndev->netdev_ops = &smsc9420_netdev_ops;\r\ndev->ethtool_ops = &smsc9420_ethtool_ops;\r\nnetif_napi_add(dev, &pd->napi, smsc9420_rx_poll, NAPI_WEIGHT);\r\nresult = register_netdev(dev);\r\nif (result) {\r\nsmsc_warn(PROBE, "error %i registering device", result);\r\ngoto out_free_dmadesc_5;\r\n}\r\npci_set_drvdata(pdev, dev);\r\nspin_lock_init(&pd->int_lock);\r\nspin_lock_init(&pd->phy_lock);\r\ndev_info(&dev->dev, "MAC Address: %pM\n", dev->dev_addr);\r\nreturn 0;\r\nout_free_dmadesc_5:\r\npci_free_consistent(pdev, sizeof(struct smsc9420_dma_desc) *\r\n(RX_RING_SIZE + TX_RING_SIZE), pd->rx_ring, pd->rx_dma_addr);\r\nout_free_io_4:\r\niounmap(virt_addr - LAN9420_CPSR_ENDIAN_OFFSET);\r\nout_free_regions_3:\r\npci_release_regions(pdev);\r\nout_free_netdev_2:\r\nfree_netdev(dev);\r\nout_disable_pci_device_1:\r\npci_disable_device(pdev);\r\nout_0:\r\nreturn -ENODEV;\r\n}\r\nstatic void smsc9420_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct smsc9420_pdata *pd;\r\ndev = pci_get_drvdata(pdev);\r\nif (!dev)\r\nreturn;\r\npci_set_drvdata(pdev, NULL);\r\npd = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nBUG_ON(pd->tx_buffers);\r\nBUG_ON(pd->rx_buffers);\r\nBUG_ON(!pd->tx_ring);\r\nBUG_ON(!pd->rx_ring);\r\npci_free_consistent(pdev, sizeof(struct smsc9420_dma_desc) *\r\n(RX_RING_SIZE + TX_RING_SIZE), pd->rx_ring, pd->rx_dma_addr);\r\niounmap(pd->ioaddr - LAN9420_CPSR_ENDIAN_OFFSET);\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init smsc9420_init_module(void)\r\n{\r\nsmsc_debug = netif_msg_init(debug, SMSC_MSG_DEFAULT);\r\nreturn pci_register_driver(&smsc9420_driver);\r\n}\r\nstatic void __exit smsc9420_exit_module(void)\r\n{\r\npci_unregister_driver(&smsc9420_driver);\r\n}
