static int max3110_write_then_read(struct uart_max3110 *max,\r\nconst void *txbuf, void *rxbuf, unsigned len, int always_fast)\r\n{\r\nstruct spi_device *spi = max->spi;\r\nstruct spi_message message;\r\nstruct spi_transfer x;\r\nint ret;\r\nspi_message_init(&message);\r\nmemset(&x, 0, sizeof x);\r\nx.len = len;\r\nx.tx_buf = txbuf;\r\nx.rx_buf = rxbuf;\r\nspi_message_add_tail(&x, &message);\r\nif (always_fast)\r\nx.speed_hz = spi->max_speed_hz;\r\nelse if (max->baud)\r\nx.speed_hz = max->baud;\r\nret = spi_sync(spi, &message);\r\nreturn ret;\r\n}\r\nstatic int max3110_out(struct uart_max3110 *max, const u16 out)\r\n{\r\nvoid *buf;\r\nu16 *obuf, *ibuf;\r\nint ret;\r\nbuf = kzalloc(8, GFP_KERNEL | GFP_DMA);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nobuf = buf;\r\nibuf = buf + 4;\r\n*obuf = out;\r\nret = max3110_write_then_read(max, obuf, ibuf, 2, 1);\r\nif (ret) {\r\npr_warning(PR_FMT "%s(): get err msg %d when sending 0x%x\n",\r\n__func__, ret, out);\r\ngoto exit;\r\n}\r\nreceive_chars(max, ibuf, 1);\r\nexit:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int max3110_read_multi(struct uart_max3110 *max)\r\n{\r\nvoid *buf;\r\nu16 *obuf, *ibuf;\r\nint ret, blen;\r\nblen = M3110_RX_FIFO_DEPTH * sizeof(u16);\r\nbuf = kzalloc(blen * 2, GFP_KERNEL | GFP_DMA);\r\nif (!buf) {\r\npr_warning(PR_FMT "%s(): fail to alloc dma buffer\n", __func__);\r\nreturn 0;\r\n}\r\nobuf = buf;\r\nibuf = buf + blen;\r\nif (max3110_write_then_read(max, obuf, ibuf, blen, 1)) {\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nret = receive_chars(max, ibuf, M3110_RX_FIFO_DEPTH);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void serial_m3110_con_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_max3110 *max =\r\ncontainer_of(port, struct uart_max3110, port);\r\nstruct circ_buf *xmit = &max->con_xmit;\r\nif (uart_circ_chars_free(xmit)) {\r\nxmit->buf[xmit->head] = (char)ch;\r\nxmit->head = (xmit->head + 1) & (PAGE_SIZE - 1);\r\n}\r\n}\r\nstatic void serial_m3110_con_write(struct console *co,\r\nconst char *s, unsigned int count)\r\n{\r\nif (!pmax)\r\nreturn;\r\nuart_console_write(&pmax->port, s, count, serial_m3110_con_putchar);\r\nif (!test_and_set_bit(CON_TX_NEEDED, &pmax->uart_flags))\r\nwake_up(&pmax->wq);\r\n}\r\nstatic int __init\r\nserial_m3110_con_setup(struct console *co, char *options)\r\n{\r\nstruct uart_max3110 *max = pmax;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\npr_info(PR_FMT "setting up console\n");\r\nif (co->index == -1)\r\nco->index = 0;\r\nif (!max) {\r\npr_err(PR_FMT "pmax is NULL, return");\r\nreturn -ENODEV;\r\n}\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&max->port, co, baud, parity, bits, flow);\r\n}\r\nstatic struct tty_driver *serial_m3110_con_device(struct console *co,\r\nint *index)\r\n{\r\nstruct uart_driver *p = co->data;\r\n*index = co->index;\r\nreturn p->tty_driver;\r\n}\r\nstatic unsigned int serial_m3110_tx_empty(struct uart_port *port)\r\n{\r\nreturn 1;\r\n}\r\nstatic void serial_m3110_stop_tx(struct uart_port *port)\r\n{\r\nreturn;\r\n}\r\nstatic void serial_m3110_stop_rx(struct uart_port *port)\r\n{\r\nreturn;\r\n}\r\nstatic void send_circ_buf(struct uart_max3110 *max,\r\nstruct circ_buf *xmit)\r\n{\r\nvoid *buf;\r\nu16 *obuf, *ibuf;\r\nint i, len, blen, dma_size, left, ret = 0;\r\ndma_size = WORDS_PER_XFER * sizeof(u16) * 2;\r\nbuf = kzalloc(dma_size, GFP_KERNEL | GFP_DMA);\r\nif (!buf)\r\nreturn;\r\nobuf = buf;\r\nibuf = buf + dma_size/2;\r\nwhile (!uart_circ_empty(xmit)) {\r\nleft = uart_circ_chars_pending(xmit);\r\nwhile (left) {\r\nlen = min(left, WORDS_PER_XFER);\r\nblen = len * sizeof(u16);\r\nmemset(ibuf, 0, blen);\r\nfor (i = 0; i < len; i++) {\r\nobuf[i] = (u8)xmit->buf[xmit->tail] | WD_TAG;\r\nxmit->tail = (xmit->tail + 1) &\r\n(UART_XMIT_SIZE - 1);\r\n}\r\nret = max3110_write_then_read(max, obuf, ibuf, blen, 0);\r\nif (ret)\r\npr_warning(PR_FMT "%s(): get err msg %d\n",\r\n__func__, ret);\r\nreceive_chars(max, ibuf, len);\r\nmax->port.icount.tx += len;\r\nleft -= len;\r\n}\r\n}\r\nkfree(buf);\r\n}\r\nstatic void transmit_char(struct uart_max3110 *max)\r\n{\r\nstruct uart_port *port = &max->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nreturn;\r\nsend_circ_buf(max, xmit);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nserial_m3110_stop_tx(port);\r\n}\r\nstatic void serial_m3110_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_max3110 *max =\r\ncontainer_of(port, struct uart_max3110, port);\r\nif (!test_and_set_bit(UART_TX_NEEDED, &max->uart_flags))\r\nwake_up(&max->wq);\r\n}\r\nstatic int\r\nreceive_chars(struct uart_max3110 *max, unsigned short *str, int len)\r\n{\r\nstruct uart_port *port = &max->port;\r\nstruct tty_port *tport;\r\nchar buf[M3110_RX_FIFO_DEPTH];\r\nint r, w, usable;\r\nif (!port->state)\r\nreturn 0;\r\ntport = &port->state->port;\r\nfor (r = 0, w = 0; r < len; r++) {\r\nif (str[r] & MAX3110_BREAK &&\r\nuart_handle_break(port))\r\ncontinue;\r\nif (str[r] & MAX3110_READ_DATA_AVAILABLE) {\r\nif (uart_handle_sysrq_char(port, str[r] & 0xff))\r\ncontinue;\r\nbuf[w++] = str[r] & 0xff;\r\n}\r\n}\r\nif (!w)\r\nreturn 0;\r\nfor (r = 0; w; r += usable, w -= usable) {\r\nusable = tty_buffer_request_room(tport, w);\r\nif (usable) {\r\ntty_insert_flip_string(tport, buf + r, usable);\r\nport->icount.rx += usable;\r\n}\r\n}\r\ntty_flip_buffer_push(tport);\r\nreturn r;\r\n}\r\nstatic void max3110_con_receive(struct uart_max3110 *max)\r\n{\r\nint loop = 1, num;\r\ndo {\r\nnum = max3110_read_multi(max);\r\nif (num) {\r\nloop = 5;\r\n}\r\n} while (--loop);\r\n}\r\nstatic int max3110_main_thread(void *_max)\r\n{\r\nstruct uart_max3110 *max = _max;\r\nwait_queue_head_t *wq = &max->wq;\r\nint ret = 0;\r\nstruct circ_buf *xmit = &max->con_xmit;\r\npr_info(PR_FMT "start main thread\n");\r\ndo {\r\nwait_event_interruptible(*wq,\r\nmax->uart_flags || kthread_should_stop());\r\nmutex_lock(&max->thread_mutex);\r\nif (test_and_clear_bit(BIT_IRQ_PENDING, &max->uart_flags))\r\nmax3110_con_receive(max);\r\nif (test_and_clear_bit(CON_TX_NEEDED, &max->uart_flags))\r\nsend_circ_buf(max, xmit);\r\nif (test_and_clear_bit(UART_TX_NEEDED, &max->uart_flags))\r\ntransmit_char(max);\r\nmutex_unlock(&max->thread_mutex);\r\n} while (!kthread_should_stop());\r\nreturn ret;\r\n}\r\nstatic irqreturn_t serial_m3110_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_max3110 *max = dev_id;\r\nif (!test_and_set_bit(BIT_IRQ_PENDING, &max->uart_flags))\r\nwake_up(&max->wq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max3110_read_thread(void *_max)\r\n{\r\nstruct uart_max3110 *max = _max;\r\npr_info(PR_FMT "start read thread\n");\r\ndo {\r\nif (mutex_trylock(&max->thread_mutex)) {\r\nmax3110_con_receive(max);\r\nmutex_unlock(&max->thread_mutex);\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ / 20);\r\n} while (!kthread_should_stop());\r\nreturn 0;\r\n}\r\nstatic int serial_m3110_startup(struct uart_port *port)\r\n{\r\nstruct uart_max3110 *max =\r\ncontainer_of(port, struct uart_max3110, port);\r\nu16 config = 0;\r\nint ret = 0;\r\nif (port->line != 0) {\r\npr_err(PR_FMT "uart port startup failed\n");\r\nreturn -1;\r\n}\r\nconfig = WC_TAG | WC_FIFO_ENABLE\r\n| WC_1_STOPBITS\r\n| WC_8BIT_WORD\r\n| WC_BAUD_DR2;\r\nport->state->port.low_latency = 1;\r\nif (max->irq) {\r\nmax->read_thread = NULL;\r\nret = request_irq(max->irq, serial_m3110_irq,\r\nIRQ_TYPE_EDGE_FALLING, "max3110", max);\r\nif (ret) {\r\nmax->irq = 0;\r\npr_err(PR_FMT "unable to allocate IRQ, polling\n");\r\n} else {\r\nconfig |= WC_RXA_IRQ_ENABLE;\r\n}\r\n}\r\nif (max->irq == 0) {\r\nmax->read_thread =\r\nkthread_run(max3110_read_thread, max, "max3110_read");\r\nif (IS_ERR(max->read_thread)) {\r\nret = PTR_ERR(max->read_thread);\r\nmax->read_thread = NULL;\r\npr_err(PR_FMT "Can't create read thread!\n");\r\nreturn ret;\r\n}\r\n}\r\nret = max3110_out(max, config);\r\nif (ret) {\r\nif (max->irq)\r\nfree_irq(max->irq, max);\r\nif (max->read_thread)\r\nkthread_stop(max->read_thread);\r\nmax->read_thread = NULL;\r\nreturn ret;\r\n}\r\nmax->cur_conf = config;\r\nreturn 0;\r\n}\r\nstatic void serial_m3110_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_max3110 *max =\r\ncontainer_of(port, struct uart_max3110, port);\r\nu16 config;\r\nif (max->read_thread) {\r\nkthread_stop(max->read_thread);\r\nmax->read_thread = NULL;\r\n}\r\nif (max->irq)\r\nfree_irq(max->irq, max);\r\nconfig = WC_TAG | WC_SW_SHDI;\r\nmax3110_out(max, config);\r\n}\r\nstatic void serial_m3110_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int serial_m3110_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void serial_m3110_config_port(struct uart_port *port, int flags)\r\n{\r\nport->type = PORT_MAX3100;\r\n}\r\nstatic int\r\nserial_m3110_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic const char *serial_m3110_type(struct uart_port *port)\r\n{\r\nstruct uart_max3110 *max =\r\ncontainer_of(port, struct uart_max3110, port);\r\nreturn max->name;\r\n}\r\nstatic void\r\nserial_m3110_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_max3110 *max =\r\ncontainer_of(port, struct uart_max3110, port);\r\nunsigned char cval;\r\nunsigned int baud, parity = 0;\r\nint clk_div = -1;\r\nu16 new_conf = max->cur_conf;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS7:\r\ncval = UART_LCR_WLEN7;\r\nnew_conf |= WC_7BIT_WORD;\r\nbreak;\r\ndefault:\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\ncase CS8:\r\ncval = UART_LCR_WLEN8;\r\nnew_conf |= WC_8BIT_WORD;\r\nbreak;\r\n}\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 230400);\r\nswitch (baud) {\r\ncase 300:\r\nclk_div = WC_BAUD_DR384;\r\nbreak;\r\ncase 600:\r\nclk_div = WC_BAUD_DR192;\r\nbreak;\r\ncase 1200:\r\nclk_div = WC_BAUD_DR96;\r\nbreak;\r\ncase 2400:\r\nclk_div = WC_BAUD_DR48;\r\nbreak;\r\ncase 4800:\r\nclk_div = WC_BAUD_DR24;\r\nbreak;\r\ncase 9600:\r\nclk_div = WC_BAUD_DR12;\r\nbreak;\r\ncase 19200:\r\nclk_div = WC_BAUD_DR6;\r\nbreak;\r\ncase 38400:\r\nclk_div = WC_BAUD_DR3;\r\nbreak;\r\ncase 57600:\r\nclk_div = WC_BAUD_DR2;\r\nbreak;\r\ncase 115200:\r\nclk_div = WC_BAUD_DR1;\r\nbreak;\r\ncase 230400:\r\nif (max->clock & MAX3110_HIGH_CLK)\r\nbreak;\r\ndefault:\r\nbaud = max->baud;\r\nclk_div = max->cur_conf & WC_BAUD_DIV_MASK;\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\n}\r\nif (max->clock & MAX3110_HIGH_CLK) {\r\nclk_div += 1;\r\nif (baud == 300) {\r\nbaud = 600;\r\nclk_div = WC_BAUD_DR384;\r\n}\r\nif (baud == 230400)\r\nclk_div = WC_BAUD_DR1;\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\n}\r\nnew_conf = (new_conf & ~WC_BAUD_DIV_MASK) | clk_div;\r\nif (unlikely(termios->c_cflag & CMSPAR))\r\ntermios->c_cflag &= ~CMSPAR;\r\nif (termios->c_cflag & CSTOPB)\r\nnew_conf |= WC_2_STOPBITS;\r\nelse\r\nnew_conf &= ~WC_2_STOPBITS;\r\nif (termios->c_cflag & PARENB) {\r\nnew_conf |= WC_PARITY_ENABLE;\r\nparity |= UART_LCR_PARITY;\r\n} else\r\nnew_conf &= ~WC_PARITY_ENABLE;\r\nif (!(termios->c_cflag & PARODD))\r\nparity |= UART_LCR_EPAR;\r\nmax->parity = parity;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nnew_conf |= WC_TAG;\r\nif (new_conf != max->cur_conf) {\r\nif (!max3110_out(max, new_conf)) {\r\nmax->cur_conf = new_conf;\r\nmax->baud = baud;\r\n}\r\n}\r\n}\r\nstatic unsigned int serial_m3110_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR | TIOCM_DSR;\r\n}\r\nstatic void serial_m3110_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void serial_m3110_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic void serial_m3110_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\n}\r\nstatic void serial_m3110_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic int serial_m3110_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct uart_max3110 *max = spi_get_drvdata(spi);\r\ndisable_irq(max->irq);\r\nuart_suspend_port(&serial_m3110_reg, &max->port);\r\nmax3110_out(max, max->cur_conf | WC_SW_SHDI);\r\nreturn 0;\r\n}\r\nstatic int serial_m3110_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct uart_max3110 *max = spi_get_drvdata(spi);\r\nmax3110_out(max, max->cur_conf);\r\nuart_resume_port(&serial_m3110_reg, &max->port);\r\nenable_irq(max->irq);\r\nreturn 0;\r\n}\r\nstatic int serial_m3110_probe(struct spi_device *spi)\r\n{\r\nstruct uart_max3110 *max;\r\nvoid *buffer;\r\nu16 res;\r\nint ret = 0;\r\nmax = kzalloc(sizeof(*max), GFP_KERNEL);\r\nif (!max)\r\nreturn -ENOMEM;\r\nspi->bits_per_word = 16;\r\nmax->clock = MAX3110_HIGH_CLK;\r\nspi_setup(spi);\r\nmax->port.type = PORT_MAX3100;\r\nmax->port.fifosize = 2;\r\nmax->port.ops = &serial_m3110_ops;\r\nmax->port.line = 0;\r\nmax->port.dev = &spi->dev;\r\nmax->port.uartclk = 115200;\r\nmax->spi = spi;\r\nstrcpy(max->name, spi->modalias);\r\nmax->irq = (u16)spi->irq;\r\nmutex_init(&max->thread_mutex);\r\nmax->word_7bits = 0;\r\nmax->parity = 0;\r\nmax->baud = 0;\r\nmax->cur_conf = 0;\r\nmax->uart_flags = 0;\r\nres = RC_TAG;\r\nret = max3110_write_then_read(max, (u8 *)&res, (u8 *)&res, 2, 0);\r\nif (ret < 0 || res == 0 || res == 0xffff) {\r\ndev_dbg(&spi->dev, "MAX3111 deemed not present (conf reg %04x)",\r\nres);\r\nret = -ENODEV;\r\ngoto err_get_page;\r\n}\r\nbuffer = (void *)__get_free_page(GFP_KERNEL);\r\nif (!buffer) {\r\nret = -ENOMEM;\r\ngoto err_get_page;\r\n}\r\nmax->con_xmit.buf = buffer;\r\nmax->con_xmit.head = 0;\r\nmax->con_xmit.tail = 0;\r\ninit_waitqueue_head(&max->wq);\r\nmax->main_thread = kthread_run(max3110_main_thread,\r\nmax, "max3110_main");\r\nif (IS_ERR(max->main_thread)) {\r\nret = PTR_ERR(max->main_thread);\r\ngoto err_kthread;\r\n}\r\nspi_set_drvdata(spi, max);\r\npmax = max;\r\nmax->port.membase = (void *)0xff110000;\r\nuart_add_one_port(&serial_m3110_reg, &max->port);\r\nreturn 0;\r\nerr_kthread:\r\nfree_page((unsigned long)buffer);\r\nerr_get_page:\r\nkfree(max);\r\nreturn ret;\r\n}\r\nstatic int serial_m3110_remove(struct spi_device *dev)\r\n{\r\nstruct uart_max3110 *max = spi_get_drvdata(dev);\r\nif (!max)\r\nreturn 0;\r\nuart_remove_one_port(&serial_m3110_reg, &max->port);\r\nfree_page((unsigned long)max->con_xmit.buf);\r\nif (max->main_thread)\r\nkthread_stop(max->main_thread);\r\nkfree(max);\r\nreturn 0;\r\n}\r\nstatic int __init serial_m3110_init(void)\r\n{\r\nint ret = 0;\r\nret = uart_register_driver(&serial_m3110_reg);\r\nif (ret)\r\nreturn ret;\r\nret = spi_register_driver(&uart_max3110_driver);\r\nif (ret)\r\nuart_unregister_driver(&serial_m3110_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit serial_m3110_exit(void)\r\n{\r\nspi_unregister_driver(&uart_max3110_driver);\r\nuart_unregister_driver(&serial_m3110_reg);\r\n}
