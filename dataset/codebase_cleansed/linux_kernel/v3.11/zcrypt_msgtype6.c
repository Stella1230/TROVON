static int ICAMEX_msg_to_type6MEX_msgX(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {'C', 'A',},\r\n.function_code = {'P', 'K'},\r\n};\r\nstatic struct function_and_rules_block static_pke_fnr = {\r\n.function_code = {'P', 'K'},\r\n.ulen = 10,\r\n.only_rule = {'M', 'R', 'P', ' ', ' ', ' ', ' ', ' '}\r\n};\r\nstatic struct function_and_rules_block static_pke_fnr_MCL2 = {\r\n.function_code = {'P', 'K'},\r\n.ulen = 10,\r\n.only_rule = {'Z', 'E', 'R', 'O', '-', 'P', 'A', 'D'}\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\nstruct function_and_rules_block fr;\r\nunsigned short length;\r\nchar text[0];\r\n} __packed * msg = ap_msg->message;\r\nint size;\r\nmsg->length = mex->inputdatalength + 2;\r\nif (copy_from_user(msg->text, mex->inputdata, mex->inputdatalength))\r\nreturn -EFAULT;\r\nsize = zcrypt_type6_mex_key_en(mex, msg->text+mex->inputdatalength, 1);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + mex->inputdatalength;\r\nmsg->hdr = static_type6_hdrX;\r\nmsg->hdr.ToCardLen1 = size - sizeof(msg->hdr);\r\nmsg->hdr.FromCardLen1 = PCIXCC_MAX_ICA_RESPONSE_SIZE - sizeof(msg->hdr);\r\nmsg->cprbx = static_cprbx;\r\nmsg->cprbx.domain = AP_QID_QUEUE(zdev->ap_dev->qid);\r\nmsg->cprbx.rpl_msgbl = msg->hdr.FromCardLen1;\r\nmsg->fr = (zdev->user_space_type == ZCRYPT_PCIXCC_MCL2) ?\r\nstatic_pke_fnr_MCL2 : static_pke_fnr;\r\nmsg->cprbx.req_parml = size - sizeof(msg->hdr) - sizeof(msg->cprbx);\r\nap_msg->length = size;\r\nreturn 0;\r\n}\r\nstatic int ICACRT_msg_to_type6CRT_msgX(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {'C', 'A',},\r\n.function_code = {'P', 'D'},\r\n};\r\nstatic struct function_and_rules_block static_pkd_fnr = {\r\n.function_code = {'P', 'D'},\r\n.ulen = 10,\r\n.only_rule = {'Z', 'E', 'R', 'O', '-', 'P', 'A', 'D'}\r\n};\r\nstatic struct function_and_rules_block static_pkd_fnr_MCL2 = {\r\n.function_code = {'P', 'D'},\r\n.ulen = 10,\r\n.only_rule = {'P', 'K', 'C', 'S', '-', '1', '.', '2'}\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\nstruct function_and_rules_block fr;\r\nunsigned short length;\r\nchar text[0];\r\n} __packed * msg = ap_msg->message;\r\nint size;\r\nmsg->length = crt->inputdatalength + 2;\r\nif (copy_from_user(msg->text, crt->inputdata, crt->inputdatalength))\r\nreturn -EFAULT;\r\nsize = zcrypt_type6_crt_key(crt, msg->text + crt->inputdatalength, 1);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + crt->inputdatalength;\r\nmsg->hdr = static_type6_hdrX;\r\nmsg->hdr.ToCardLen1 = size - sizeof(msg->hdr);\r\nmsg->hdr.FromCardLen1 = PCIXCC_MAX_ICA_RESPONSE_SIZE - sizeof(msg->hdr);\r\nmsg->cprbx = static_cprbx;\r\nmsg->cprbx.domain = AP_QID_QUEUE(zdev->ap_dev->qid);\r\nmsg->cprbx.req_parml = msg->cprbx.rpl_msgbl =\r\nsize - sizeof(msg->hdr) - sizeof(msg->cprbx);\r\nmsg->fr = (zdev->user_space_type == ZCRYPT_PCIXCC_MCL2) ?\r\nstatic_pkd_fnr_MCL2 : static_pkd_fnr;\r\nap_msg->length = size;\r\nreturn 0;\r\n}\r\nstatic int XCRB_msg_to_type6CPRB_msgX(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\n} __packed * msg = ap_msg->message;\r\nint rcblen = CEIL4(xcRB->request_control_blk_length);\r\nint replylen;\r\nchar *req_data = ap_msg->message + sizeof(struct type6_hdr) + rcblen;\r\nchar *function_code;\r\nap_msg->length = sizeof(struct type6_hdr) +\r\nCEIL4(xcRB->request_control_blk_length) +\r\nxcRB->request_data_length;\r\nif (ap_msg->length > MSGTYPE06_MAX_MSG_SIZE)\r\nreturn -EINVAL;\r\nreplylen = sizeof(struct type86_fmt2_msg) +\r\nCEIL4(xcRB->reply_control_blk_length) +\r\nxcRB->reply_data_length;\r\nif (replylen > MSGTYPE06_MAX_MSG_SIZE)\r\nreturn -EINVAL;\r\nmsg->hdr = static_type6_hdrX;\r\nmemcpy(msg->hdr.agent_id , &(xcRB->agent_ID), sizeof(xcRB->agent_ID));\r\nmsg->hdr.ToCardLen1 = xcRB->request_control_blk_length;\r\nif (xcRB->request_data_length) {\r\nmsg->hdr.offset2 = msg->hdr.offset1 + rcblen;\r\nmsg->hdr.ToCardLen2 = xcRB->request_data_length;\r\n}\r\nmsg->hdr.FromCardLen1 = xcRB->reply_control_blk_length;\r\nmsg->hdr.FromCardLen2 = xcRB->reply_data_length;\r\nif (copy_from_user(&(msg->cprbx), xcRB->request_control_blk_addr,\r\nxcRB->request_control_blk_length))\r\nreturn -EFAULT;\r\nif (msg->cprbx.cprb_len + sizeof(msg->hdr.function_code) >\r\nxcRB->request_control_blk_length)\r\nreturn -EINVAL;\r\nfunction_code = ((unsigned char *)&msg->cprbx) + msg->cprbx.cprb_len;\r\nmemcpy(msg->hdr.function_code, function_code,\r\nsizeof(msg->hdr.function_code));\r\nif (memcmp(function_code, "US", 2) == 0)\r\nap_msg->special = 1;\r\nelse\r\nap_msg->special = 0;\r\nif (xcRB->request_data_length &&\r\ncopy_from_user(req_data, xcRB->request_data_address,\r\nxcRB->request_data_length))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_ica(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstatic unsigned char static_pad[] = {\r\n0x00, 0x02,\r\n0x1B, 0x7B, 0x5D, 0xB5, 0x75, 0x01, 0x3D, 0xFD,\r\n0x8D, 0xD1, 0xC7, 0x03, 0x2D, 0x09, 0x23, 0x57,\r\n0x89, 0x49, 0xB9, 0x3F, 0xBB, 0x99, 0x41, 0x5B,\r\n0x75, 0x21, 0x7B, 0x9D, 0x3B, 0x6B, 0x51, 0x39,\r\n0xBB, 0x0D, 0x35, 0xB9, 0x89, 0x0F, 0x93, 0xA5,\r\n0x0B, 0x47, 0xF1, 0xD3, 0xBB, 0xCB, 0xF1, 0x9D,\r\n0x23, 0x73, 0x71, 0xFF, 0xF3, 0xF5, 0x45, 0xFB,\r\n0x61, 0x29, 0x23, 0xFD, 0xF1, 0x29, 0x3F, 0x7F,\r\n0x17, 0xB7, 0x1B, 0xA9, 0x19, 0xBD, 0x57, 0xA9,\r\n0xD7, 0x95, 0xA3, 0xCB, 0xED, 0x1D, 0xDB, 0x45,\r\n0x7D, 0x11, 0xD1, 0x51, 0x1B, 0xED, 0x71, 0xE9,\r\n0xB1, 0xD1, 0xAB, 0xAB, 0x21, 0x2B, 0x1B, 0x9F,\r\n0x3B, 0x9F, 0xF7, 0xF7, 0xBD, 0x63, 0xEB, 0xAD,\r\n0xDF, 0xB3, 0x6F, 0x5B, 0xDB, 0x8D, 0xA9, 0x5D,\r\n0xE3, 0x7D, 0x77, 0x49, 0x47, 0xF5, 0xA7, 0xFD,\r\n0xAB, 0x2F, 0x27, 0x35, 0x77, 0xD3, 0x49, 0xC9,\r\n0x09, 0xEB, 0xB1, 0xF9, 0xBF, 0x4B, 0xCB, 0x2B,\r\n0xEB, 0xEB, 0x05, 0xFF, 0x7D, 0xC7, 0x91, 0x8B,\r\n0x09, 0x83, 0xB9, 0xB9, 0x69, 0x33, 0x39, 0x6B,\r\n0x79, 0x75, 0x19, 0xBF, 0xBB, 0x07, 0x1D, 0xBD,\r\n0x29, 0xBF, 0x39, 0x95, 0x93, 0x1D, 0x35, 0xC7,\r\n0xC9, 0x4D, 0xE5, 0x97, 0x0B, 0x43, 0x9B, 0xF1,\r\n0x16, 0x93, 0x03, 0x1F, 0xA5, 0xFB, 0xDB, 0xF3,\r\n0x27, 0x4F, 0x27, 0x61, 0x05, 0x1F, 0xB9, 0x23,\r\n0x2F, 0xC3, 0x81, 0xA9, 0x23, 0x71, 0x55, 0x55,\r\n0xEB, 0xED, 0x41, 0xE5, 0xF3, 0x11, 0xF1, 0x43,\r\n0x69, 0x03, 0xBD, 0x0B, 0x37, 0x0F, 0x51, 0x8F,\r\n0x0B, 0xB5, 0x89, 0x5B, 0x67, 0xA9, 0xD9, 0x4F,\r\n0x01, 0xF9, 0x21, 0x77, 0x37, 0x73, 0x79, 0xC5,\r\n0x7F, 0x51, 0xC1, 0xCF, 0x97, 0xA1, 0x75, 0xAD,\r\n0x35, 0x9D, 0xD3, 0xD3, 0xA7, 0x9D, 0x5D, 0x41,\r\n0x6F, 0x65, 0x1B, 0xCF, 0xA9, 0x87, 0x91, 0x09\r\n};\r\nstruct type86x_reply *msg = reply->message;\r\nunsigned short service_rc, service_rs;\r\nunsigned int reply_len, pad_len;\r\nchar *data;\r\nservice_rc = msg->cprbx.ccp_rtcode;\r\nif (unlikely(service_rc != 0)) {\r\nservice_rs = msg->cprbx.ccp_rscode;\r\nif (service_rc == 8 && service_rs == 66)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 65)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 770)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 783) {\r\nzdev->min_mod_size = PCIXCC_MIN_MOD_SIZE_OLD;\r\nreturn -EAGAIN;\r\n}\r\nif (service_rc == 12 && service_rs == 769)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 72)\r\nreturn -EINVAL;\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\ndata = msg->text;\r\nreply_len = msg->length - 2;\r\nif (reply_len > outputdatalength)\r\nreturn -EINVAL;\r\npad_len = outputdatalength - reply_len;\r\nif (pad_len > 0) {\r\nif (pad_len < 10)\r\nreturn -EINVAL;\r\nif (copy_to_user(outputdata, static_pad, pad_len - 1))\r\nreturn -EFAULT;\r\nif (put_user(0, outputdata + pad_len - 1))\r\nreturn -EFAULT;\r\n}\r\nif (copy_to_user(outputdata + pad_len, data, reply_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_xcrb(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstruct type86_fmt2_msg *msg = reply->message;\r\nchar *data = reply->message;\r\nif (copy_to_user(xcRB->reply_control_blk_addr,\r\ndata + msg->fmt2.offset1, msg->fmt2.count1))\r\nreturn -EFAULT;\r\nxcRB->reply_control_blk_length = msg->fmt2.count1;\r\nif (msg->fmt2.count2)\r\nif (copy_to_user(xcRB->reply_data_addr,\r\ndata + msg->fmt2.offset2, msg->fmt2.count2))\r\nreturn -EFAULT;\r\nxcRB->reply_data_length = msg->fmt2.count2;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_rng(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar *buffer)\r\n{\r\nstruct {\r\nstruct type86_hdr hdr;\r\nstruct type86_fmt2_ext fmt2;\r\nstruct CPRBX cprbx;\r\n} __packed * msg = reply->message;\r\nchar *data = reply->message;\r\nif (msg->cprbx.ccp_rtcode != 0 || msg->cprbx.ccp_rscode != 0)\r\nreturn -EINVAL;\r\nmemcpy(buffer, data + msg->fmt2.offset2, msg->fmt2.count2);\r\nreturn msg->fmt2.count2;\r\n}\r\nstatic int convert_response_ica(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (((unsigned char *) reply->message)[1]) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn convert_error(zdev, reply);\r\ncase TYPE86_RSP_CODE:\r\nif (msg->cprbx.ccp_rtcode &&\r\n(msg->cprbx.ccp_rscode == 0x14f) &&\r\n(outputdatalength > 256)) {\r\nif (zdev->max_exp_bit_length <= 17) {\r\nzdev->max_exp_bit_length = 17;\r\nreturn -EAGAIN;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nif (msg->hdr.reply_code)\r\nreturn convert_error(zdev, reply);\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_ica(zdev, reply,\r\noutputdata, outputdatalength);\r\ndefault:\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int convert_response_xcrb(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (((unsigned char *) reply->message)[1]) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nxcRB->status = 0x0008044DL;\r\nreturn convert_error(zdev, reply);\r\ncase TYPE86_RSP_CODE:\r\nif (msg->hdr.reply_code) {\r\nmemcpy(&(xcRB->status), msg->fmt2.apfs, sizeof(u32));\r\nreturn convert_error(zdev, reply);\r\n}\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_xcrb(zdev, reply, xcRB);\r\ndefault:\r\nxcRB->status = 0x0008044DL;\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int convert_response_rng(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar *data)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (msg->hdr.type) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn -EINVAL;\r\ncase TYPE86_RSP_CODE:\r\nif (msg->hdr.reply_code)\r\nreturn -EINVAL;\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_rng(zdev, reply, data);\r\ndefault:\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic void zcrypt_msgtype6_receive(struct ap_device *ap_dev,\r\nstruct ap_message *msg,\r\nstruct ap_message *reply)\r\n{\r\nstatic struct error_hdr error_reply = {\r\n.type = TYPE82_RSP_CODE,\r\n.reply_code = REP82_ERROR_MACHINE_FAILURE,\r\n};\r\nstruct response_type *resp_type =\r\n(struct response_type *) msg->private;\r\nstruct type86x_reply *t86r;\r\nint length;\r\nif (IS_ERR(reply)) {\r\nmemcpy(msg->message, &error_reply, sizeof(error_reply));\r\ngoto out;\r\n}\r\nt86r = reply->message;\r\nif (t86r->hdr.type == TYPE86_RSP_CODE &&\r\nt86r->cprbx.cprb_ver_id == 0x02) {\r\nswitch (resp_type->type) {\r\ncase PCIXCC_RESPONSE_TYPE_ICA:\r\nlength = sizeof(struct type86x_reply)\r\n+ t86r->length - 2;\r\nlength = min(PCIXCC_MAX_ICA_RESPONSE_SIZE, length);\r\nmemcpy(msg->message, reply->message, length);\r\nbreak;\r\ncase PCIXCC_RESPONSE_TYPE_XCRB:\r\nlength = t86r->fmt2.offset2 + t86r->fmt2.count2;\r\nlength = min(MSGTYPE06_MAX_MSG_SIZE, length);\r\nmemcpy(msg->message, reply->message, length);\r\nbreak;\r\ndefault:\r\nmemcpy(msg->message, &error_reply,\r\nsizeof(error_reply));\r\n}\r\n} else\r\nmemcpy(msg->message, reply->message, sizeof(error_reply));\r\nout:\r\ncomplete(&(resp_type->work));\r\n}\r\nstatic long zcrypt_msgtype6_modexpo(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_ICA,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_msgtype6_receive;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrc = ICAMEX_msg_to_type6MEX_msgX(zdev, &ap_msg, mex);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0)\r\nrc = convert_response_ica(zdev, &ap_msg, mex->outputdata,\r\nmex->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_msgtype6_modexpo_crt(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_ICA,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_msgtype6_receive;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrc = ICACRT_msg_to_type6CRT_msgX(zdev, &ap_msg, crt);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0)\r\nrc = convert_response_ica(zdev, &ap_msg, crt->outputdata,\r\ncrt->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_msgtype6_send_cprb(struct zcrypt_device *zdev,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_XCRB,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = kmalloc(MSGTYPE06_MAX_MSG_SIZE, GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_msgtype6_receive;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrc = XCRB_msg_to_type6CPRB_msgX(zdev, &ap_msg, xcRB);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0)\r\nrc = convert_response_xcrb(zdev, &ap_msg, xcRB);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nkzfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_msgtype6_rng(struct zcrypt_device *zdev,\r\nchar *buffer)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_XCRB,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = kmalloc(MSGTYPE06_MAX_MSG_SIZE, GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_msgtype6_receive;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrng_type6CPRB_msgX(zdev->ap_dev, &ap_msg, ZCRYPT_RNG_BUFFER_SIZE);\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0)\r\nrc = convert_response_rng(zdev, &ap_msg, buffer);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nkfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nint __init zcrypt_msgtype6_init(void)\r\n{\r\nzcrypt_msgtype_register(&zcrypt_msgtype6_norng_ops);\r\nzcrypt_msgtype_register(&zcrypt_msgtype6_ops);\r\nreturn 0;\r\n}\r\nvoid __exit zcrypt_msgtype6_exit(void)\r\n{\r\nzcrypt_msgtype_unregister(&zcrypt_msgtype6_norng_ops);\r\nzcrypt_msgtype_unregister(&zcrypt_msgtype6_ops);\r\n}
