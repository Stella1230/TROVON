static ssize_t iscsi_boot_show_attribute(struct kobject *kobj,\r\nstruct attribute *attr, char *buf)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj =\r\ncontainer_of(kobj, struct iscsi_boot_kobj, kobj);\r\nstruct iscsi_boot_attr *boot_attr =\r\ncontainer_of(attr, struct iscsi_boot_attr, attr);\r\nssize_t ret = -EIO;\r\nchar *str = buf;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (boot_kobj->show)\r\nret = boot_kobj->show(boot_kobj->data, boot_attr->type, str);\r\nreturn ret;\r\n}\r\nstatic void iscsi_boot_kobj_release(struct kobject *kobj)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj =\r\ncontainer_of(kobj, struct iscsi_boot_kobj, kobj);\r\nif (boot_kobj->release)\r\nboot_kobj->release(boot_kobj->data);\r\nkfree(boot_kobj);\r\n}\r\nstatic umode_t iscsi_boot_tgt_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj =\r\ncontainer_of(kobj, struct iscsi_boot_kobj, kobj);\r\nif (attr == &iscsi_boot_attr_tgt_index.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_INDEX);\r\nelse if (attr == &iscsi_boot_attr_tgt_flags.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_FLAGS);\r\nelse if (attr == &iscsi_boot_attr_tgt_ip.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_IP_ADDR);\r\nelse if (attr == &iscsi_boot_attr_tgt_port.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_PORT);\r\nelse if (attr == &iscsi_boot_attr_tgt_lun.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_LUN);\r\nelse if (attr == &iscsi_boot_attr_tgt_chap.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_CHAP_TYPE);\r\nelse if (attr == &iscsi_boot_attr_tgt_nic.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_NIC_ASSOC);\r\nelse if (attr == &iscsi_boot_attr_tgt_name.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_NAME);\r\nelse if (attr == &iscsi_boot_attr_tgt_chap_name.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_CHAP_NAME);\r\nelse if (attr == &iscsi_boot_attr_tgt_chap_secret.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_CHAP_SECRET);\r\nelse if (attr == &iscsi_boot_attr_tgt_chap_rev_name.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_REV_CHAP_NAME);\r\nelse if (attr == &iscsi_boot_attr_tgt_chap_rev_secret.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_TGT_REV_CHAP_SECRET);\r\nreturn 0;\r\n}\r\nstatic umode_t iscsi_boot_eth_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj =\r\ncontainer_of(kobj, struct iscsi_boot_kobj, kobj);\r\nif (attr == &iscsi_boot_attr_eth_index.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_INDEX);\r\nelse if (attr == &iscsi_boot_attr_eth_flags.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_FLAGS);\r\nelse if (attr == &iscsi_boot_attr_eth_ip.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_IP_ADDR);\r\nelse if (attr == &iscsi_boot_attr_eth_subnet.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_SUBNET_MASK);\r\nelse if (attr == &iscsi_boot_attr_eth_origin.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_ORIGIN);\r\nelse if (attr == &iscsi_boot_attr_eth_gateway.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_GATEWAY);\r\nelse if (attr == &iscsi_boot_attr_eth_primary_dns.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_PRIMARY_DNS);\r\nelse if (attr == &iscsi_boot_attr_eth_secondary_dns.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_SECONDARY_DNS);\r\nelse if (attr == &iscsi_boot_attr_eth_dhcp.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_DHCP);\r\nelse if (attr == &iscsi_boot_attr_eth_vlan.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_VLAN);\r\nelse if (attr == &iscsi_boot_attr_eth_mac.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_MAC);\r\nelse if (attr == &iscsi_boot_attr_eth_hostname.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_ETH_HOSTNAME);\r\nreturn 0;\r\n}\r\nstatic umode_t iscsi_boot_ini_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj =\r\ncontainer_of(kobj, struct iscsi_boot_kobj, kobj);\r\nif (attr == &iscsi_boot_attr_ini_index.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_INI_INDEX);\r\nif (attr == &iscsi_boot_attr_ini_flags.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_INI_FLAGS);\r\nif (attr == &iscsi_boot_attr_ini_isns.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_INI_ISNS_SERVER);\r\nif (attr == &iscsi_boot_attr_ini_slp.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_INI_SLP_SERVER);\r\nif (attr == &iscsi_boot_attr_ini_primary_radius.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_INI_PRI_RADIUS_SERVER);\r\nif (attr == &iscsi_boot_attr_ini_secondary_radius.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_INI_SEC_RADIUS_SERVER);\r\nif (attr == &iscsi_boot_attr_ini_name.attr)\r\nreturn boot_kobj->is_visible(boot_kobj->data,\r\nISCSI_BOOT_INI_INITIATOR_NAME);\r\nreturn 0;\r\n}\r\nstatic struct iscsi_boot_kobj *\r\niscsi_boot_create_kobj(struct iscsi_boot_kset *boot_kset,\r\nstruct attribute_group *attr_group,\r\nconst char *name, int index, void *data,\r\nssize_t (*show) (void *data, int type, char *buf),\r\numode_t (*is_visible) (void *data, int type),\r\nvoid (*release) (void *data))\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj;\r\nboot_kobj = kzalloc(sizeof(*boot_kobj), GFP_KERNEL);\r\nif (!boot_kobj)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&boot_kobj->list);\r\nboot_kobj->kobj.kset = boot_kset->kset;\r\nif (kobject_init_and_add(&boot_kobj->kobj, &iscsi_boot_ktype,\r\nNULL, name, index)) {\r\nkfree(boot_kobj);\r\nreturn NULL;\r\n}\r\nboot_kobj->data = data;\r\nboot_kobj->show = show;\r\nboot_kobj->is_visible = is_visible;\r\nboot_kobj->release = release;\r\nif (sysfs_create_group(&boot_kobj->kobj, attr_group)) {\r\nboot_kobj->release = NULL;\r\nkobject_put(&boot_kobj->kobj);\r\nreturn NULL;\r\n}\r\nboot_kobj->attr_group = attr_group;\r\nkobject_uevent(&boot_kobj->kobj, KOBJ_ADD);\r\nlist_add_tail(&boot_kobj->list, &boot_kset->kobj_list);\r\nreturn boot_kobj;\r\n}\r\nstatic void iscsi_boot_remove_kobj(struct iscsi_boot_kobj *boot_kobj)\r\n{\r\nlist_del(&boot_kobj->list);\r\nsysfs_remove_group(&boot_kobj->kobj, boot_kobj->attr_group);\r\nkobject_put(&boot_kobj->kobj);\r\n}\r\nstruct iscsi_boot_kobj *\r\niscsi_boot_create_target(struct iscsi_boot_kset *boot_kset, int index,\r\nvoid *data,\r\nssize_t (*show) (void *data, int type, char *buf),\r\numode_t (*is_visible) (void *data, int type),\r\nvoid (*release) (void *data))\r\n{\r\nreturn iscsi_boot_create_kobj(boot_kset, &iscsi_boot_target_attr_group,\r\n"target%d", index, data, show, is_visible,\r\nrelease);\r\n}\r\nstruct iscsi_boot_kobj *\r\niscsi_boot_create_initiator(struct iscsi_boot_kset *boot_kset, int index,\r\nvoid *data,\r\nssize_t (*show) (void *data, int type, char *buf),\r\numode_t (*is_visible) (void *data, int type),\r\nvoid (*release) (void *data))\r\n{\r\nreturn iscsi_boot_create_kobj(boot_kset,\r\n&iscsi_boot_initiator_attr_group,\r\n"initiator", index, data, show,\r\nis_visible, release);\r\n}\r\nstruct iscsi_boot_kobj *\r\niscsi_boot_create_ethernet(struct iscsi_boot_kset *boot_kset, int index,\r\nvoid *data,\r\nssize_t (*show) (void *data, int type, char *buf),\r\numode_t (*is_visible) (void *data, int type),\r\nvoid (*release) (void *data))\r\n{\r\nreturn iscsi_boot_create_kobj(boot_kset,\r\n&iscsi_boot_ethernet_attr_group,\r\n"ethernet%d", index, data, show,\r\nis_visible, release);\r\n}\r\nstruct iscsi_boot_kset *iscsi_boot_create_kset(const char *set_name)\r\n{\r\nstruct iscsi_boot_kset *boot_kset;\r\nboot_kset = kzalloc(sizeof(*boot_kset), GFP_KERNEL);\r\nif (!boot_kset)\r\nreturn NULL;\r\nboot_kset->kset = kset_create_and_add(set_name, NULL, firmware_kobj);\r\nif (!boot_kset->kset) {\r\nkfree(boot_kset);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&boot_kset->kobj_list);\r\nreturn boot_kset;\r\n}\r\nstruct iscsi_boot_kset *iscsi_boot_create_host_kset(unsigned int hostno)\r\n{\r\nstruct iscsi_boot_kset *boot_kset;\r\nchar *set_name;\r\nset_name = kasprintf(GFP_KERNEL, "iscsi_boot%u", hostno);\r\nif (!set_name)\r\nreturn NULL;\r\nboot_kset = iscsi_boot_create_kset(set_name);\r\nkfree(set_name);\r\nreturn boot_kset;\r\n}\r\nvoid iscsi_boot_destroy_kset(struct iscsi_boot_kset *boot_kset)\r\n{\r\nstruct iscsi_boot_kobj *boot_kobj, *tmp_kobj;\r\nif (!boot_kset)\r\nreturn;\r\nlist_for_each_entry_safe(boot_kobj, tmp_kobj,\r\n&boot_kset->kobj_list, list)\r\niscsi_boot_remove_kobj(boot_kobj);\r\nkset_unregister(boot_kset->kset);\r\n}
