static int mpu3050_xyz_read_reg(struct i2c_client *client,\r\nu8 *buffer, int length)\r\n{\r\nchar cmd = MPU3050_XOUT_H;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &cmd,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = length,\r\n.buf = buffer,\r\n},\r\n};\r\nreturn i2c_transfer(client->adapter, msg, 2);\r\n}\r\nstatic void mpu3050_read_xyz(struct i2c_client *client,\r\nstruct axis_data *coords)\r\n{\r\nu16 buffer[3];\r\nmpu3050_xyz_read_reg(client, (u8 *)buffer, 6);\r\ncoords->x = be16_to_cpu(buffer[0]);\r\ncoords->y = be16_to_cpu(buffer[1]);\r\ncoords->z = be16_to_cpu(buffer[2]);\r\ndev_dbg(&client->dev, "%s: x %d, y %d, z %d\n", __func__,\r\ncoords->x, coords->y, coords->z);\r\n}\r\nstatic void mpu3050_set_power_mode(struct i2c_client *client, u8 val)\r\n{\r\nu8 value;\r\nvalue = i2c_smbus_read_byte_data(client, MPU3050_PWR_MGM);\r\nvalue = (value & ~MPU3050_PWR_MGM_MASK) |\r\n(((val << MPU3050_PWR_MGM_POS) & MPU3050_PWR_MGM_MASK) ^\r\nMPU3050_PWR_MGM_MASK);\r\ni2c_smbus_write_byte_data(client, MPU3050_PWR_MGM, value);\r\n}\r\nstatic int mpu3050_input_open(struct input_dev *input)\r\n{\r\nstruct mpu3050_sensor *sensor = input_get_drvdata(input);\r\nint error;\r\npm_runtime_get(sensor->dev);\r\nerror = i2c_smbus_write_byte_data(sensor->client, MPU3050_INT_CFG,\r\nMPU3050_LATCH_INT_EN |\r\nMPU3050_RAW_RDY_EN |\r\nMPU3050_MPU_RDY_EN);\r\nif (error < 0) {\r\npm_runtime_put(sensor->dev);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpu3050_input_close(struct input_dev *input)\r\n{\r\nstruct mpu3050_sensor *sensor = input_get_drvdata(input);\r\npm_runtime_put(sensor->dev);\r\n}\r\nstatic irqreturn_t mpu3050_interrupt_thread(int irq, void *data)\r\n{\r\nstruct mpu3050_sensor *sensor = data;\r\nstruct axis_data axis;\r\nmpu3050_read_xyz(sensor->client, &axis);\r\ninput_report_abs(sensor->idev, ABS_X, axis.x);\r\ninput_report_abs(sensor->idev, ABS_Y, axis.y);\r\ninput_report_abs(sensor->idev, ABS_Z, axis.z);\r\ninput_sync(sensor->idev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpu3050_hw_init(struct mpu3050_sensor *sensor)\r\n{\r\nstruct i2c_client *client = sensor->client;\r\nint ret;\r\nu8 reg;\r\nret = i2c_smbus_write_byte_data(client, MPU3050_PWR_MGM,\r\nMPU3050_PWR_MGM_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(client, MPU3050_PWR_MGM);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~MPU3050_PWR_MGM_CLKSEL;\r\nret |= MPU3050_PWR_MGM_PLL_Z;\r\nret = i2c_smbus_write_byte_data(client, MPU3050_PWR_MGM, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, MPU3050_SMPLRT_DIV,\r\nMPU3050_DEFAULT_POLL_INTERVAL - 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreg = MPU3050_DEFAULT_FS_RANGE;\r\nreg |= MPU3050_DLPF_CFG_42HZ << 3;\r\nreg |= MPU3050_EXT_SYNC_NONE << 5;\r\nret = i2c_smbus_write_byte_data(client, MPU3050_DLPF_FS_SYNC, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mpu3050_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mpu3050_sensor *sensor;\r\nstruct input_dev *idev;\r\nint ret;\r\nint error;\r\nsensor = kzalloc(sizeof(struct mpu3050_sensor), GFP_KERNEL);\r\nidev = input_allocate_device();\r\nif (!sensor || !idev) {\r\ndev_err(&client->dev, "failed to allocate driver data\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nsensor->client = client;\r\nsensor->dev = &client->dev;\r\nsensor->idev = idev;\r\nmpu3050_set_power_mode(client, 1);\r\nmsleep(10);\r\nret = i2c_smbus_read_byte_data(client, MPU3050_CHIP_ID_REG);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to detect device\n");\r\nerror = -ENXIO;\r\ngoto err_free_mem;\r\n}\r\nif (ret != MPU3050_CHIP_ID) {\r\ndev_err(&client->dev, "unsupported chip id\n");\r\nerror = -ENXIO;\r\ngoto err_free_mem;\r\n}\r\nidev->name = "MPU3050";\r\nidev->id.bustype = BUS_I2C;\r\nidev->dev.parent = &client->dev;\r\nidev->open = mpu3050_input_open;\r\nidev->close = mpu3050_input_close;\r\n__set_bit(EV_ABS, idev->evbit);\r\ninput_set_abs_params(idev, ABS_X,\r\nMPU3050_MIN_VALUE, MPU3050_MAX_VALUE, 0, 0);\r\ninput_set_abs_params(idev, ABS_Y,\r\nMPU3050_MIN_VALUE, MPU3050_MAX_VALUE, 0, 0);\r\ninput_set_abs_params(idev, ABS_Z,\r\nMPU3050_MIN_VALUE, MPU3050_MAX_VALUE, 0, 0);\r\ninput_set_drvdata(idev, sensor);\r\npm_runtime_set_active(&client->dev);\r\nerror = mpu3050_hw_init(sensor);\r\nif (error)\r\ngoto err_pm_set_suspended;\r\nerror = request_threaded_irq(client->irq,\r\nNULL, mpu3050_interrupt_thread,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"mpu3050", sensor);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"can't get IRQ %d, error %d\n", client->irq, error);\r\ngoto err_pm_set_suspended;\r\n}\r\nerror = input_register_device(idev);\r\nif (error) {\r\ndev_err(&client->dev, "failed to register input device\n");\r\ngoto err_free_irq;\r\n}\r\npm_runtime_enable(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev, MPU3050_AUTO_DELAY);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, sensor);\r\nerr_pm_set_suspended:\r\npm_runtime_set_suspended(&client->dev);\r\nerr_free_mem:\r\ninput_free_device(idev);\r\nkfree(sensor);\r\nreturn error;\r\n}\r\nstatic int mpu3050_remove(struct i2c_client *client)\r\n{\r\nstruct mpu3050_sensor *sensor = i2c_get_clientdata(client);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\nfree_irq(client->irq, sensor);\r\ninput_unregister_device(sensor->idev);\r\nkfree(sensor);\r\nreturn 0;\r\n}\r\nstatic int mpu3050_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nmpu3050_set_power_mode(client, 0);\r\nreturn 0;\r\n}\r\nstatic int mpu3050_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nmpu3050_set_power_mode(client, 1);\r\nmsleep(100);\r\nreturn 0;\r\n}
