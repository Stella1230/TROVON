static inline const struct pci_device_id *\r\nmatch_one_device(const struct pci_device_id *id, const struct pci_dev *dev)\r\n{\r\nif ((id->vendor == PCI_ANY_ID || id->vendor == dev->vendor) &&\r\n(id->device == PCI_ANY_ID || id->device == dev->device) &&\r\n(id->subvendor == PCI_ANY_ID ||\r\nid->subvendor == dev->subsystem_vendor) &&\r\n(id->subdevice == PCI_ANY_ID ||\r\nid->subdevice == dev->subsystem_device) &&\r\n!((id->class ^ dev->class) & id->class_mask))\r\nreturn id;\r\nreturn NULL;\r\n}\r\nstatic struct xen_pcibk_config_quirk *xen_pcibk_find_quirk(struct pci_dev *dev)\r\n{\r\nstruct xen_pcibk_config_quirk *tmp_quirk;\r\nlist_for_each_entry(tmp_quirk, &xen_pcibk_quirks, quirks_list)\r\nif (match_one_device(&tmp_quirk->devid, dev) != NULL)\r\ngoto out;\r\ntmp_quirk = NULL;\r\nprintk(KERN_DEBUG DRV_NAME\r\n": quirk didn't match any device known\n");\r\nout:\r\nreturn tmp_quirk;\r\n}\r\nstatic inline void register_quirk(struct xen_pcibk_config_quirk *quirk)\r\n{\r\nlist_add_tail(&quirk->quirks_list, &xen_pcibk_quirks);\r\n}\r\nint xen_pcibk_field_is_dup(struct pci_dev *dev, unsigned int reg)\r\n{\r\nint ret = 0;\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\nstruct config_field_entry *cfg_entry;\r\nlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\r\nif (OFFSET(cfg_entry) == reg) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint xen_pcibk_config_quirks_add_field(struct pci_dev *dev, struct config_field\r\n*field)\r\n{\r\nint err = 0;\r\nswitch (field->size) {\r\ncase 1:\r\nfield->u.b.read = xen_pcibk_read_config_byte;\r\nfield->u.b.write = xen_pcibk_write_config_byte;\r\nbreak;\r\ncase 2:\r\nfield->u.w.read = xen_pcibk_read_config_word;\r\nfield->u.w.write = xen_pcibk_write_config_word;\r\nbreak;\r\ncase 4:\r\nfield->u.dw.read = xen_pcibk_read_config_dword;\r\nfield->u.dw.write = xen_pcibk_write_config_dword;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nxen_pcibk_config_add_field(dev, field);\r\nout:\r\nreturn err;\r\n}\r\nint xen_pcibk_config_quirks_init(struct pci_dev *dev)\r\n{\r\nstruct xen_pcibk_config_quirk *quirk;\r\nint ret = 0;\r\nquirk = kzalloc(sizeof(*quirk), GFP_ATOMIC);\r\nif (!quirk) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nquirk->devid.vendor = dev->vendor;\r\nquirk->devid.device = dev->device;\r\nquirk->devid.subvendor = dev->subsystem_vendor;\r\nquirk->devid.subdevice = dev->subsystem_device;\r\nquirk->devid.class = 0;\r\nquirk->devid.class_mask = 0;\r\nquirk->devid.driver_data = 0UL;\r\nquirk->pdev = dev;\r\nregister_quirk(quirk);\r\nout:\r\nreturn ret;\r\n}\r\nvoid xen_pcibk_config_field_free(struct config_field *field)\r\n{\r\nkfree(field);\r\n}\r\nint xen_pcibk_config_quirk_release(struct pci_dev *dev)\r\n{\r\nstruct xen_pcibk_config_quirk *quirk;\r\nint ret = 0;\r\nquirk = xen_pcibk_find_quirk(dev);\r\nif (!quirk) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nlist_del(&quirk->quirks_list);\r\nkfree(quirk);\r\nout:\r\nreturn ret;\r\n}
