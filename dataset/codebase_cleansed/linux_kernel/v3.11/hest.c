static int hest_esrc_len(struct acpi_hest_header *hest_hdr)\r\n{\r\nu16 hest_type = hest_hdr->type;\r\nint len;\r\nif (hest_type >= ACPI_HEST_TYPE_RESERVED)\r\nreturn 0;\r\nlen = hest_esrc_len_tab[hest_type];\r\nif (hest_type == ACPI_HEST_TYPE_IA32_CORRECTED_CHECK) {\r\nstruct acpi_hest_ia_corrected *cmc;\r\ncmc = (struct acpi_hest_ia_corrected *)hest_hdr;\r\nlen = sizeof(*cmc) + cmc->num_hardware_banks *\r\nsizeof(struct acpi_hest_ia_error_bank);\r\n} else if (hest_type == ACPI_HEST_TYPE_IA32_CHECK) {\r\nstruct acpi_hest_ia_machine_check *mc;\r\nmc = (struct acpi_hest_ia_machine_check *)hest_hdr;\r\nlen = sizeof(*mc) + mc->num_hardware_banks *\r\nsizeof(struct acpi_hest_ia_error_bank);\r\n}\r\nBUG_ON(len == -1);\r\nreturn len;\r\n}\r\nint apei_hest_parse(apei_hest_func_t func, void *data)\r\n{\r\nstruct acpi_hest_header *hest_hdr;\r\nint i, rc, len;\r\nif (hest_disable || !hest_tab)\r\nreturn -EINVAL;\r\nhest_hdr = (struct acpi_hest_header *)(hest_tab + 1);\r\nfor (i = 0; i < hest_tab->error_source_count; i++) {\r\nlen = hest_esrc_len(hest_hdr);\r\nif (!len) {\r\npr_warning(FW_WARN HEST_PFX\r\n"Unknown or unused hardware error source "\r\n"type: %d for hardware error source: %d.\n",\r\nhest_hdr->type, hest_hdr->source_id);\r\nreturn -EINVAL;\r\n}\r\nif ((void *)hest_hdr + len >\r\n(void *)hest_tab + hest_tab->header.length) {\r\npr_warning(FW_BUG HEST_PFX\r\n"Table contents overflow for hardware error source: %d.\n",\r\nhest_hdr->source_id);\r\nreturn -EINVAL;\r\n}\r\nrc = func(hest_hdr, data);\r\nif (rc)\r\nreturn rc;\r\nhest_hdr = (void *)hest_hdr + len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init hest_parse_ghes_count(struct acpi_hest_header *hest_hdr, void *data)\r\n{\r\nint *count = data;\r\nif (hest_hdr->type == ACPI_HEST_TYPE_GENERIC_ERROR)\r\n(*count)++;\r\nreturn 0;\r\n}\r\nstatic int __init hest_parse_ghes(struct acpi_hest_header *hest_hdr, void *data)\r\n{\r\nstruct platform_device *ghes_dev;\r\nstruct ghes_arr *ghes_arr = data;\r\nint rc, i;\r\nif (hest_hdr->type != ACPI_HEST_TYPE_GENERIC_ERROR)\r\nreturn 0;\r\nif (!((struct acpi_hest_generic *)hest_hdr)->enabled)\r\nreturn 0;\r\nfor (i = 0; i < ghes_arr->count; i++) {\r\nstruct acpi_hest_header *hdr;\r\nghes_dev = ghes_arr->ghes_devs[i];\r\nhdr = *(struct acpi_hest_header **)ghes_dev->dev.platform_data;\r\nif (hdr->source_id == hest_hdr->source_id) {\r\npr_warning(FW_WARN HEST_PFX "Duplicated hardware error source ID: %d.\n",\r\nhdr->source_id);\r\nreturn -EIO;\r\n}\r\n}\r\nghes_dev = platform_device_alloc("GHES", hest_hdr->source_id);\r\nif (!ghes_dev)\r\nreturn -ENOMEM;\r\nrc = platform_device_add_data(ghes_dev, &hest_hdr, sizeof(void *));\r\nif (rc)\r\ngoto err;\r\nrc = platform_device_add(ghes_dev);\r\nif (rc)\r\ngoto err;\r\nghes_arr->ghes_devs[ghes_arr->count++] = ghes_dev;\r\nreturn 0;\r\nerr:\r\nplatform_device_put(ghes_dev);\r\nreturn rc;\r\n}\r\nstatic int __init hest_ghes_dev_register(unsigned int ghes_count)\r\n{\r\nint rc, i;\r\nstruct ghes_arr ghes_arr;\r\nghes_arr.count = 0;\r\nghes_arr.ghes_devs = kmalloc(sizeof(void *) * ghes_count, GFP_KERNEL);\r\nif (!ghes_arr.ghes_devs)\r\nreturn -ENOMEM;\r\nrc = apei_hest_parse(hest_parse_ghes, &ghes_arr);\r\nif (rc)\r\ngoto err;\r\nout:\r\nkfree(ghes_arr.ghes_devs);\r\nreturn rc;\r\nerr:\r\nfor (i = 0; i < ghes_arr.count; i++)\r\nplatform_device_unregister(ghes_arr.ghes_devs[i]);\r\ngoto out;\r\n}\r\nstatic int __init setup_hest_disable(char *str)\r\n{\r\nhest_disable = 1;\r\nreturn 0;\r\n}\r\nvoid __init acpi_hest_init(void)\r\n{\r\nacpi_status status;\r\nint rc = -ENODEV;\r\nunsigned int ghes_count = 0;\r\nif (hest_disable) {\r\npr_info(HEST_PFX "Table parsing disabled.\n");\r\nreturn;\r\n}\r\nstatus = acpi_get_table(ACPI_SIG_HEST, 0,\r\n(struct acpi_table_header **)&hest_tab);\r\nif (status == AE_NOT_FOUND)\r\ngoto err;\r\nelse if (ACPI_FAILURE(status)) {\r\nconst char *msg = acpi_format_exception(status);\r\npr_err(HEST_PFX "Failed to get table, %s\n", msg);\r\nrc = -EINVAL;\r\ngoto err;\r\n}\r\nif (!ghes_disable) {\r\nrc = apei_hest_parse(hest_parse_ghes_count, &ghes_count);\r\nif (rc)\r\ngoto err;\r\nrc = hest_ghes_dev_register(ghes_count);\r\nif (rc)\r\ngoto err;\r\n}\r\npr_info(HEST_PFX "Table parsing has been initialized.\n");\r\nreturn;\r\nerr:\r\nhest_disable = 1;\r\n}
