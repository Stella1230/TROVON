static int perf_evsel__add_sample(struct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nstruct addr_location *al,\r\nstruct perf_annotate *ann)\r\n{\r\nstruct hist_entry *he;\r\nint ret;\r\nif (ann->sym_hist_filter != NULL &&\r\n(al->sym == NULL ||\r\nstrcmp(ann->sym_hist_filter, al->sym->name) != 0)) {\r\nif (al->sym != NULL) {\r\nrb_erase(&al->sym->rb_node,\r\n&al->map->dso->symbols[al->map->type]);\r\nsymbol__delete(al->sym);\r\n}\r\nreturn 0;\r\n}\r\nhe = __hists__add_entry(&evsel->hists, al, NULL, 1, 1);\r\nif (he == NULL)\r\nreturn -ENOMEM;\r\nret = 0;\r\nif (he->ms.sym != NULL) {\r\nstruct annotation *notes = symbol__annotation(he->ms.sym);\r\nif (notes->src == NULL && symbol__alloc_hist(he->ms.sym) < 0)\r\nreturn -ENOMEM;\r\nret = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);\r\n}\r\nevsel->hists.stats.total_period += sample->period;\r\nhists__inc_nr_events(&evsel->hists, PERF_RECORD_SAMPLE);\r\nreturn ret;\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct perf_annotate *ann = container_of(tool, struct perf_annotate, tool);\r\nstruct addr_location al;\r\nif (perf_event__preprocess_sample(event, machine, &al, sample,\r\nsymbol__annotate_init) < 0) {\r\npr_warning("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (ann->cpu_list && !test_bit(sample->cpu, ann->cpu_bitmap))\r\nreturn 0;\r\nif (!al.filtered && perf_evsel__add_sample(evsel, sample, &al, ann)) {\r\npr_warning("problem incrementing symbol count, "\r\n"skipping event\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hist_entry__tty_annotate(struct hist_entry *he,\r\nstruct perf_evsel *evsel,\r\nstruct perf_annotate *ann)\r\n{\r\nreturn symbol__tty_annotate(he->ms.sym, he->ms.map, evsel,\r\nann->print_line, ann->full_paths, 0, 0);\r\n}\r\nstatic void hists__find_annotations(struct hists *self,\r\nstruct perf_evsel *evsel,\r\nstruct perf_annotate *ann)\r\n{\r\nstruct rb_node *nd = rb_first(&self->entries), *next;\r\nint key = K_RIGHT;\r\nwhile (nd) {\r\nstruct hist_entry *he = rb_entry(nd, struct hist_entry, rb_node);\r\nstruct annotation *notes;\r\nif (he->ms.sym == NULL || he->ms.map->dso->annotate_warned)\r\ngoto find_next;\r\nnotes = symbol__annotation(he->ms.sym);\r\nif (notes->src == NULL) {\r\nfind_next:\r\nif (key == K_LEFT)\r\nnd = rb_prev(nd);\r\nelse\r\nnd = rb_next(nd);\r\ncontinue;\r\n}\r\nif (use_browser == 2) {\r\nint ret;\r\nret = hist_entry__gtk_annotate(he, evsel, NULL);\r\nif (!ret || !ann->skip_missing)\r\nreturn;\r\nnd = rb_next(nd);\r\n} else if (use_browser == 1) {\r\nkey = hist_entry__tui_annotate(he, evsel, NULL);\r\nswitch (key) {\r\ncase -1:\r\nif (!ann->skip_missing)\r\nreturn;\r\ncase K_RIGHT:\r\nnext = rb_next(nd);\r\nbreak;\r\ncase K_LEFT:\r\nnext = rb_prev(nd);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (next != NULL)\r\nnd = next;\r\n} else {\r\nhist_entry__tty_annotate(he, evsel, ann);\r\nnd = rb_next(nd);\r\nfree(notes->src);\r\nnotes->src = NULL;\r\n}\r\n}\r\n}\r\nstatic int __cmd_annotate(struct perf_annotate *ann)\r\n{\r\nint ret;\r\nstruct perf_session *session;\r\nstruct perf_evsel *pos;\r\nu64 total_nr_samples;\r\nsession = perf_session__new(input_name, O_RDONLY,\r\nann->force, false, &ann->tool);\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\nif (ann->cpu_list) {\r\nret = perf_session__cpu_bitmap(session, ann->cpu_list,\r\nann->cpu_bitmap);\r\nif (ret)\r\ngoto out_delete;\r\n}\r\nif (!objdump_path) {\r\nret = perf_session_env__lookup_objdump(&session->header.env);\r\nif (ret)\r\ngoto out_delete;\r\n}\r\nret = perf_session__process_events(session, &ann->tool);\r\nif (ret)\r\ngoto out_delete;\r\nif (dump_trace) {\r\nperf_session__fprintf_nr_events(session, stdout);\r\ngoto out_delete;\r\n}\r\nif (verbose > 3)\r\nperf_session__fprintf(session, stdout);\r\nif (verbose > 2)\r\nperf_session__fprintf_dsos(session, stdout);\r\ntotal_nr_samples = 0;\r\nlist_for_each_entry(pos, &session->evlist->entries, node) {\r\nstruct hists *hists = &pos->hists;\r\nu32 nr_samples = hists->stats.nr_events[PERF_RECORD_SAMPLE];\r\nif (nr_samples > 0) {\r\ntotal_nr_samples += nr_samples;\r\nhists__collapse_resort(hists);\r\nhists__output_resort(hists);\r\nif (symbol_conf.event_group &&\r\n!perf_evsel__is_group_leader(pos))\r\ncontinue;\r\nhists__find_annotations(hists, pos, ann);\r\n}\r\n}\r\nif (total_nr_samples == 0) {\r\nui__error("The %s file has no samples!\n", session->filename);\r\ngoto out_delete;\r\n}\r\nif (use_browser == 2)\r\nperf_gtk__show_annotations();\r\nout_delete:\r\nreturn ret;\r\n}\r\nint cmd_annotate(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nstruct perf_annotate annotate = {\r\n.tool = {\r\n.sample = process_sample_event,\r\n.mmap = perf_event__process_mmap,\r\n.comm = perf_event__process_comm,\r\n.exit = perf_event__process_exit,\r\n.fork = perf_event__process_fork,\r\n.ordered_samples = true,\r\n.ordering_requires_timestamps = true,\r\n},\r\n};\r\nconst struct option options[] = {\r\nOPT_STRING('i', "input", &input_name, "file",\r\n"input file name"),\r\nOPT_STRING('d', "dsos", &symbol_conf.dso_list_str, "dso[,dso...]",\r\n"only consider symbols in these dsos"),\r\nOPT_STRING('s', "symbol", &annotate.sym_hist_filter, "symbol",\r\n"symbol to annotate"),\r\nOPT_BOOLEAN('f', "force", &annotate.force, "don't complain, do it"),\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show symbol address, etc)"),\r\nOPT_BOOLEAN('D', "dump-raw-trace", &dump_trace,\r\n"dump raw trace in ASCII"),\r\nOPT_BOOLEAN(0, "gtk", &annotate.use_gtk, "Use the GTK interface"),\r\nOPT_BOOLEAN(0, "tui", &annotate.use_tui, "Use the TUI interface"),\r\nOPT_BOOLEAN(0, "stdio", &annotate.use_stdio, "Use the stdio interface"),\r\nOPT_STRING('k', "vmlinux", &symbol_conf.vmlinux_name,\r\n"file", "vmlinux pathname"),\r\nOPT_BOOLEAN('m', "modules", &symbol_conf.use_modules,\r\n"load module symbols - WARNING: use only with -k and LIVE kernel"),\r\nOPT_BOOLEAN('l', "print-line", &annotate.print_line,\r\n"print matching source lines (may be slow)"),\r\nOPT_BOOLEAN('P', "full-paths", &annotate.full_paths,\r\n"Don't shorten the displayed pathnames"),\r\nOPT_BOOLEAN(0, "skip-missing", &annotate.skip_missing,\r\n"Skip symbols that cannot be annotated"),\r\nOPT_STRING('C', "cpu", &annotate.cpu_list, "cpu", "list of cpus to profile"),\r\nOPT_STRING(0, "symfs", &symbol_conf.symfs, "directory",\r\n"Look for files with symbols relative to this directory"),\r\nOPT_BOOLEAN(0, "source", &symbol_conf.annotate_src,\r\n"Interleave source code with assembly code (default)"),\r\nOPT_BOOLEAN(0, "asm-raw", &symbol_conf.annotate_asm_raw,\r\n"Display raw encoding of assembly instructions (default)"),\r\nOPT_STRING('M', "disassembler-style", &disassembler_style, "disassembler style",\r\n"Specify disassembler style (e.g. -M intel for intel syntax)"),\r\nOPT_STRING(0, "objdump", &objdump_path, "path",\r\n"objdump binary to use for disassembly and annotations"),\r\nOPT_BOOLEAN(0, "group", &symbol_conf.event_group,\r\n"Show event group information together"),\r\nOPT_END()\r\n};\r\nargc = parse_options(argc, argv, options, annotate_usage, 0);\r\nif (annotate.use_stdio)\r\nuse_browser = 0;\r\nelse if (annotate.use_tui)\r\nuse_browser = 1;\r\nelse if (annotate.use_gtk)\r\nuse_browser = 2;\r\nsetup_browser(true);\r\nsymbol_conf.priv_size = sizeof(struct annotation);\r\nsymbol_conf.try_vmlinux_path = true;\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nif (setup_sorting() < 0)\r\nusage_with_options(annotate_usage, options);\r\nif (argc) {\r\nif (argc > 1)\r\nusage_with_options(annotate_usage, options);\r\nannotate.sym_hist_filter = argv[0];\r\n}\r\nreturn __cmd_annotate(&annotate);\r\n}
