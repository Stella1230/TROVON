STATIC int\r\nxfs_attr_name_to_xname(\r\nstruct xfs_name *xname,\r\nconst unsigned char *aname)\r\n{\r\nif (!aname)\r\nreturn EINVAL;\r\nxname->name = aname;\r\nxname->len = strlen((char *)aname);\r\nif (xname->len >= MAXNAMELEN)\r\nreturn EFAULT;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_inode_hasattr(\r\nstruct xfs_inode *ip)\r\n{\r\nif (!XFS_IFORK_Q(ip) ||\r\n(ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\r\nip->i_d.di_anextents == 0))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nSTATIC int\r\nxfs_attr_get_int(\r\nstruct xfs_inode *ip,\r\nstruct xfs_name *name,\r\nunsigned char *value,\r\nint *valuelenp,\r\nint flags)\r\n{\r\nxfs_da_args_t args;\r\nint error;\r\nif (!xfs_inode_hasattr(ip))\r\nreturn ENOATTR;\r\nmemset((char *)&args, 0, sizeof(args));\r\nargs.name = name->name;\r\nargs.namelen = name->len;\r\nargs.value = value;\r\nargs.valuelen = *valuelenp;\r\nargs.flags = flags;\r\nargs.hashval = xfs_da_hashname(args.name, args.namelen);\r\nargs.dp = ip;\r\nargs.whichfork = XFS_ATTR_FORK;\r\nif (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\r\nerror = xfs_attr_shortform_getvalue(&args);\r\n} else if (xfs_bmap_one_block(ip, XFS_ATTR_FORK)) {\r\nerror = xfs_attr_leaf_get(&args);\r\n} else {\r\nerror = xfs_attr_node_get(&args);\r\n}\r\n*valuelenp = args.valuelen;\r\nif (error == EEXIST)\r\nerror = 0;\r\nreturn(error);\r\n}\r\nint\r\nxfs_attr_get(\r\nxfs_inode_t *ip,\r\nconst unsigned char *name,\r\nunsigned char *value,\r\nint *valuelenp,\r\nint flags)\r\n{\r\nint error;\r\nstruct xfs_name xname;\r\nXFS_STATS_INC(xs_attr_get);\r\nif (XFS_FORCED_SHUTDOWN(ip->i_mount))\r\nreturn(EIO);\r\nerror = xfs_attr_name_to_xname(&xname, name);\r\nif (error)\r\nreturn error;\r\nxfs_ilock(ip, XFS_ILOCK_SHARED);\r\nerror = xfs_attr_get_int(ip, &xname, value, valuelenp, flags);\r\nxfs_iunlock(ip, XFS_ILOCK_SHARED);\r\nreturn(error);\r\n}\r\nSTATIC int\r\nxfs_attr_calc_size(\r\nstruct xfs_inode *ip,\r\nint namelen,\r\nint valuelen,\r\nint *local)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nint size;\r\nint nblks;\r\nsize = xfs_attr_leaf_newentsize(namelen, valuelen,\r\nmp->m_sb.sb_blocksize, local);\r\nnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\r\nif (*local) {\r\nif (size > (mp->m_sb.sb_blocksize >> 1)) {\r\nnblks *= 2;\r\n}\r\n} else {\r\nuint dblocks = XFS_B_TO_FSB(mp, valuelen);\r\nnblks += dblocks;\r\nnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\r\n}\r\nreturn nblks;\r\n}\r\nSTATIC int\r\nxfs_attr_set_int(\r\nstruct xfs_inode *dp,\r\nstruct xfs_name *name,\r\nunsigned char *value,\r\nint valuelen,\r\nint flags)\r\n{\r\nxfs_da_args_t args;\r\nxfs_fsblock_t firstblock;\r\nxfs_bmap_free_t flist;\r\nint error, err2, committed;\r\nxfs_mount_t *mp = dp->i_mount;\r\nint rsvd = (flags & ATTR_ROOT) != 0;\r\nint local;\r\nerror = xfs_qm_dqattach(dp, 0);\r\nif (error)\r\nreturn error;\r\nif (XFS_IFORK_Q(dp) == 0) {\r\nint sf_size = sizeof(xfs_attr_sf_hdr_t) +\r\nXFS_ATTR_SF_ENTSIZE_BYNAME(name->len, valuelen);\r\nif ((error = xfs_bmap_add_attrfork(dp, sf_size, rsvd)))\r\nreturn(error);\r\n}\r\nmemset((char *)&args, 0, sizeof(args));\r\nargs.name = name->name;\r\nargs.namelen = name->len;\r\nargs.value = value;\r\nargs.valuelen = valuelen;\r\nargs.flags = flags;\r\nargs.hashval = xfs_da_hashname(args.name, args.namelen);\r\nargs.dp = dp;\r\nargs.firstblock = &firstblock;\r\nargs.flist = &flist;\r\nargs.whichfork = XFS_ATTR_FORK;\r\nargs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\r\nargs.total = xfs_attr_calc_size(dp, name->len, valuelen, &local);\r\nargs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\r\nif (rsvd)\r\nargs.trans->t_flags |= XFS_TRANS_RESERVE;\r\nerror = xfs_trans_reserve(args.trans, args.total,\r\nXFS_ATTRSETM_LOG_RES(mp) +\r\nXFS_ATTRSETRT_LOG_RES(mp) * args.total,\r\n0, XFS_TRANS_PERM_LOG_RES,\r\nXFS_ATTRSET_LOG_COUNT);\r\nif (error) {\r\nxfs_trans_cancel(args.trans, 0);\r\nreturn(error);\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL);\r\nerror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\r\nrsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\r\nXFS_QMOPT_RES_REGBLKS);\r\nif (error) {\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nxfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\r\nreturn (error);\r\n}\r\nxfs_trans_ijoin(args.trans, dp, 0);\r\nif ((dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) ||\r\n((dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) &&\r\n(dp->i_d.di_anextents == 0))) {\r\nif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\r\nxfs_attr_shortform_create(&args);\r\nerror = xfs_attr_shortform_addname(&args);\r\nif (error != ENOSPC) {\r\nASSERT(args.trans != NULL);\r\nif (mp->m_flags & XFS_MOUNT_WSYNC) {\r\nxfs_trans_set_sync(args.trans);\r\n}\r\nif (!error && (flags & ATTR_KERNOTIME) == 0) {\r\nxfs_trans_ichgtime(args.trans, dp,\r\nXFS_ICHGTIME_CHG);\r\n}\r\nerr2 = xfs_trans_commit(args.trans,\r\nXFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn(error == 0 ? err2 : error);\r\n}\r\nxfs_bmap_init(args.flist, args.firstblock);\r\nerror = xfs_attr_shortform_to_leaf(&args);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args.trans, args.flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs.trans = NULL;\r\nxfs_bmap_cancel(&flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args.trans, dp, 0);\r\nerror = xfs_trans_roll(&args.trans, dp);\r\nif (error)\r\ngoto out;\r\n}\r\nif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\r\nerror = xfs_attr_leaf_addname(&args);\r\n} else {\r\nerror = xfs_attr_node_addname(&args);\r\n}\r\nif (error) {\r\ngoto out;\r\n}\r\nif (mp->m_flags & XFS_MOUNT_WSYNC) {\r\nxfs_trans_set_sync(args.trans);\r\n}\r\nif ((flags & ATTR_KERNOTIME) == 0)\r\nxfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\r\nerror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn(error);\r\nout:\r\nif (args.trans)\r\nxfs_trans_cancel(args.trans,\r\nXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn(error);\r\n}\r\nint\r\nxfs_attr_set(\r\nxfs_inode_t *dp,\r\nconst unsigned char *name,\r\nunsigned char *value,\r\nint valuelen,\r\nint flags)\r\n{\r\nint error;\r\nstruct xfs_name xname;\r\nXFS_STATS_INC(xs_attr_set);\r\nif (XFS_FORCED_SHUTDOWN(dp->i_mount))\r\nreturn (EIO);\r\nerror = xfs_attr_name_to_xname(&xname, name);\r\nif (error)\r\nreturn error;\r\nreturn xfs_attr_set_int(dp, &xname, value, valuelen, flags);\r\n}\r\nSTATIC int\r\nxfs_attr_remove_int(xfs_inode_t *dp, struct xfs_name *name, int flags)\r\n{\r\nxfs_da_args_t args;\r\nxfs_fsblock_t firstblock;\r\nxfs_bmap_free_t flist;\r\nint error;\r\nxfs_mount_t *mp = dp->i_mount;\r\nmemset((char *)&args, 0, sizeof(args));\r\nargs.name = name->name;\r\nargs.namelen = name->len;\r\nargs.flags = flags;\r\nargs.hashval = xfs_da_hashname(args.name, args.namelen);\r\nargs.dp = dp;\r\nargs.firstblock = &firstblock;\r\nargs.flist = &flist;\r\nargs.total = 0;\r\nargs.whichfork = XFS_ATTR_FORK;\r\nargs.op_flags = XFS_DA_OP_OKNOENT;\r\nerror = xfs_qm_dqattach(dp, 0);\r\nif (error)\r\nreturn error;\r\nargs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\r\nif (flags & ATTR_ROOT)\r\nargs.trans->t_flags |= XFS_TRANS_RESERVE;\r\nif ((error = xfs_trans_reserve(args.trans,\r\nXFS_ATTRRM_SPACE_RES(mp),\r\nXFS_ATTRRM_LOG_RES(mp),\r\n0, XFS_TRANS_PERM_LOG_RES,\r\nXFS_ATTRRM_LOG_COUNT))) {\r\nxfs_trans_cancel(args.trans, 0);\r\nreturn(error);\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(args.trans, dp, 0);\r\nif (!xfs_inode_hasattr(dp)) {\r\nerror = XFS_ERROR(ENOATTR);\r\ngoto out;\r\n}\r\nif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\r\nASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\r\nerror = xfs_attr_shortform_remove(&args);\r\nif (error) {\r\ngoto out;\r\n}\r\n} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\r\nerror = xfs_attr_leaf_removename(&args);\r\n} else {\r\nerror = xfs_attr_node_removename(&args);\r\n}\r\nif (error) {\r\ngoto out;\r\n}\r\nif (mp->m_flags & XFS_MOUNT_WSYNC) {\r\nxfs_trans_set_sync(args.trans);\r\n}\r\nif ((flags & ATTR_KERNOTIME) == 0)\r\nxfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\r\nerror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn(error);\r\nout:\r\nif (args.trans)\r\nxfs_trans_cancel(args.trans,\r\nXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn(error);\r\n}\r\nint\r\nxfs_attr_remove(\r\nxfs_inode_t *dp,\r\nconst unsigned char *name,\r\nint flags)\r\n{\r\nint error;\r\nstruct xfs_name xname;\r\nXFS_STATS_INC(xs_attr_remove);\r\nif (XFS_FORCED_SHUTDOWN(dp->i_mount))\r\nreturn (EIO);\r\nerror = xfs_attr_name_to_xname(&xname, name);\r\nif (error)\r\nreturn error;\r\nxfs_ilock(dp, XFS_ILOCK_SHARED);\r\nif (!xfs_inode_hasattr(dp)) {\r\nxfs_iunlock(dp, XFS_ILOCK_SHARED);\r\nreturn XFS_ERROR(ENOATTR);\r\n}\r\nxfs_iunlock(dp, XFS_ILOCK_SHARED);\r\nreturn xfs_attr_remove_int(dp, &xname, flags);\r\n}\r\nint\r\nxfs_attr_list_int(xfs_attr_list_context_t *context)\r\n{\r\nint error;\r\nxfs_inode_t *dp = context->dp;\r\nXFS_STATS_INC(xs_attr_list);\r\nif (XFS_FORCED_SHUTDOWN(dp->i_mount))\r\nreturn EIO;\r\nxfs_ilock(dp, XFS_ILOCK_SHARED);\r\nif (!xfs_inode_hasattr(dp)) {\r\nerror = 0;\r\n} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\r\nerror = xfs_attr_shortform_list(context);\r\n} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\r\nerror = xfs_attr_leaf_list(context);\r\n} else {\r\nerror = xfs_attr_node_list(context);\r\n}\r\nxfs_iunlock(dp, XFS_ILOCK_SHARED);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attr_put_listent(\r\nxfs_attr_list_context_t *context,\r\nint flags,\r\nunsigned char *name,\r\nint namelen,\r\nint valuelen,\r\nunsigned char *value)\r\n{\r\nstruct attrlist *alist = (struct attrlist *)context->alist;\r\nattrlist_ent_t *aep;\r\nint arraytop;\r\nASSERT(!(context->flags & ATTR_KERNOVAL));\r\nASSERT(context->count >= 0);\r\nASSERT(context->count < (ATTR_MAX_VALUELEN/8));\r\nASSERT(context->firstu >= sizeof(*alist));\r\nASSERT(context->firstu <= context->bufsize);\r\nif (((context->flags & ATTR_SECURE) == 0) !=\r\n((flags & XFS_ATTR_SECURE) == 0))\r\nreturn 0;\r\nif (((context->flags & ATTR_ROOT) == 0) !=\r\n((flags & XFS_ATTR_ROOT) == 0))\r\nreturn 0;\r\narraytop = sizeof(*alist) +\r\ncontext->count * sizeof(alist->al_offset[0]);\r\ncontext->firstu -= ATTR_ENTSIZE(namelen);\r\nif (context->firstu < arraytop) {\r\ntrace_xfs_attr_list_full(context);\r\nalist->al_more = 1;\r\ncontext->seen_enough = 1;\r\nreturn 1;\r\n}\r\naep = (attrlist_ent_t *)&context->alist[context->firstu];\r\naep->a_valuelen = valuelen;\r\nmemcpy(aep->a_name, name, namelen);\r\naep->a_name[namelen] = 0;\r\nalist->al_offset[context->count++] = context->firstu;\r\nalist->al_count = context->count;\r\ntrace_xfs_attr_list_add(context);\r\nreturn 0;\r\n}\r\nint\r\nxfs_attr_list(\r\nxfs_inode_t *dp,\r\nchar *buffer,\r\nint bufsize,\r\nint flags,\r\nattrlist_cursor_kern_t *cursor)\r\n{\r\nxfs_attr_list_context_t context;\r\nstruct attrlist *alist;\r\nint error;\r\nif (cursor->pad1 || cursor->pad2)\r\nreturn(XFS_ERROR(EINVAL));\r\nif ((cursor->initted == 0) &&\r\n(cursor->hashval || cursor->blkno || cursor->offset))\r\nreturn XFS_ERROR(EINVAL);\r\nif (((long)buffer) & (sizeof(int)-1))\r\nreturn XFS_ERROR(EFAULT);\r\nif (flags & ATTR_KERNOVAL)\r\nbufsize = 0;\r\nmemset(&context, 0, sizeof(context));\r\ncontext.dp = dp;\r\ncontext.cursor = cursor;\r\ncontext.resynch = 1;\r\ncontext.flags = flags;\r\ncontext.alist = buffer;\r\ncontext.bufsize = (bufsize & ~(sizeof(int)-1));\r\ncontext.firstu = context.bufsize;\r\ncontext.put_listent = xfs_attr_put_listent;\r\nalist = (struct attrlist *)context.alist;\r\nalist->al_count = 0;\r\nalist->al_more = 0;\r\nalist->al_offset[0] = context.bufsize;\r\nerror = xfs_attr_list_int(&context);\r\nASSERT(error >= 0);\r\nreturn error;\r\n}\r\nint\r\nxfs_attr_inactive(xfs_inode_t *dp)\r\n{\r\nxfs_trans_t *trans;\r\nxfs_mount_t *mp;\r\nint error;\r\nmp = dp->i_mount;\r\nASSERT(! XFS_NOT_DQATTACHED(mp, dp));\r\nxfs_ilock(dp, XFS_ILOCK_SHARED);\r\nif (!xfs_inode_hasattr(dp) ||\r\ndp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\r\nxfs_iunlock(dp, XFS_ILOCK_SHARED);\r\nreturn 0;\r\n}\r\nxfs_iunlock(dp, XFS_ILOCK_SHARED);\r\ntrans = xfs_trans_alloc(mp, XFS_TRANS_ATTRINVAL);\r\nif ((error = xfs_trans_reserve(trans, 0, XFS_ATTRINVAL_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES,\r\nXFS_ATTRINVAL_LOG_COUNT))) {\r\nxfs_trans_cancel(trans, 0);\r\nreturn(error);\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(trans, dp, 0);\r\nif (!xfs_inode_hasattr(dp) ||\r\ndp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\r\nerror = 0;\r\ngoto out;\r\n}\r\nerror = xfs_attr3_root_inactive(&trans, dp);\r\nif (error)\r\ngoto out;\r\nerror = xfs_itruncate_extents(&trans, dp, XFS_ATTR_FORK, 0);\r\nif (error)\r\ngoto out;\r\nerror = xfs_trans_commit(trans, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn(error);\r\nout:\r\nxfs_trans_cancel(trans, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn(error);\r\n}\r\nSTATIC int\r\nxfs_attr_shortform_addname(xfs_da_args_t *args)\r\n{\r\nint newsize, forkoff, retval;\r\ntrace_xfs_attr_sf_addname(args);\r\nretval = xfs_attr_shortform_lookup(args);\r\nif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\r\nreturn(retval);\r\n} else if (retval == EEXIST) {\r\nif (args->flags & ATTR_CREATE)\r\nreturn(retval);\r\nretval = xfs_attr_shortform_remove(args);\r\nASSERT(retval == 0);\r\n}\r\nif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\r\nargs->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\r\nreturn(XFS_ERROR(ENOSPC));\r\nnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\r\nnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\r\nforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\r\nif (!forkoff)\r\nreturn(XFS_ERROR(ENOSPC));\r\nxfs_attr_shortform_add(args, forkoff);\r\nreturn(0);\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_addname(xfs_da_args_t *args)\r\n{\r\nxfs_inode_t *dp;\r\nstruct xfs_buf *bp;\r\nint retval, error, committed, forkoff;\r\ntrace_xfs_attr_leaf_addname(args);\r\ndp = args->dp;\r\nargs->blkno = 0;\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\nretval = xfs_attr3_leaf_lookup_int(bp, args);\r\nif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\r\nxfs_trans_brelse(args->trans, bp);\r\nreturn retval;\r\n} else if (retval == EEXIST) {\r\nif (args->flags & ATTR_CREATE) {\r\nxfs_trans_brelse(args->trans, bp);\r\nreturn retval;\r\n}\r\ntrace_xfs_attr_leaf_replace(args);\r\nargs->op_flags |= XFS_DA_OP_RENAME;\r\nargs->blkno2 = args->blkno;\r\nargs->index2 = args->index;\r\nargs->rmtblkno2 = args->rmtblkno;\r\nargs->rmtblkcnt2 = args->rmtblkcnt;\r\n}\r\nretval = xfs_attr3_leaf_add(bp, args);\r\nif (retval == ENOSPC) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_node(args);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\nreturn(error);\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\nreturn (error);\r\nerror = xfs_attr_node_addname(args);\r\nreturn(error);\r\n}\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\nreturn (error);\r\nif (args->rmtblkno > 0) {\r\nerror = xfs_attr_rmtval_set(args);\r\nif (error)\r\nreturn(error);\r\n}\r\nif (args->op_flags & XFS_DA_OP_RENAME) {\r\nerror = xfs_attr3_leaf_flipflags(args);\r\nif (error)\r\nreturn(error);\r\nargs->index = args->index2;\r\nargs->blkno = args->blkno2;\r\nargs->rmtblkno = args->rmtblkno2;\r\nargs->rmtblkcnt = args->rmtblkcnt2;\r\nif (args->rmtblkno) {\r\nerror = xfs_attr_rmtval_remove(args);\r\nif (error)\r\nreturn(error);\r\n}\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\r\n-1, &bp);\r\nif (error)\r\nreturn error;\r\nxfs_attr3_leaf_remove(bp, args);\r\nif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans,\r\nargs->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\nreturn(error);\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n}\r\nerror = xfs_trans_roll(&args->trans, dp);\r\n} else if (args->rmtblkno > 0) {\r\nerror = xfs_attr3_leaf_clearflag(args);\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_removename(xfs_da_args_t *args)\r\n{\r\nxfs_inode_t *dp;\r\nstruct xfs_buf *bp;\r\nint error, committed, forkoff;\r\ntrace_xfs_attr_leaf_removename(args);\r\ndp = args->dp;\r\nargs->blkno = 0;\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_attr3_leaf_lookup_int(bp, args);\r\nif (error == ENOATTR) {\r\nxfs_trans_brelse(args->trans, bp);\r\nreturn error;\r\n}\r\nxfs_attr3_leaf_remove(bp, args);\r\nif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\nreturn error;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_get(xfs_da_args_t *args)\r\n{\r\nstruct xfs_buf *bp;\r\nint error;\r\ntrace_xfs_attr_leaf_get(args);\r\nargs->blkno = 0;\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_attr3_leaf_lookup_int(bp, args);\r\nif (error != EEXIST) {\r\nxfs_trans_brelse(args->trans, bp);\r\nreturn error;\r\n}\r\nerror = xfs_attr3_leaf_getvalue(bp, args);\r\nxfs_trans_brelse(args->trans, bp);\r\nif (!error && (args->rmtblkno > 0) && !(args->flags & ATTR_KERNOVAL)) {\r\nerror = xfs_attr_rmtval_get(args);\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_list(xfs_attr_list_context_t *context)\r\n{\r\nint error;\r\nstruct xfs_buf *bp;\r\ntrace_xfs_attr_leaf_list(context);\r\ncontext->cursor->blkno = 0;\r\nerror = xfs_attr3_leaf_read(NULL, context->dp, 0, -1, &bp);\r\nif (error)\r\nreturn XFS_ERROR(error);\r\nerror = xfs_attr3_leaf_list_int(bp, context);\r\nxfs_trans_brelse(NULL, bp);\r\nreturn XFS_ERROR(error);\r\n}\r\nSTATIC int\r\nxfs_attr_node_addname(xfs_da_args_t *args)\r\n{\r\nxfs_da_state_t *state;\r\nxfs_da_state_blk_t *blk;\r\nxfs_inode_t *dp;\r\nxfs_mount_t *mp;\r\nint committed, retval, error;\r\ntrace_xfs_attr_node_addname(args);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\nrestart:\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = mp;\r\nstate->blocksize = state->mp->m_sb.sb_blocksize;\r\nstate->node_ents = state->mp->m_attr_node_ents;\r\nerror = xfs_da3_node_lookup_int(state, &retval);\r\nif (error)\r\ngoto out;\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\r\ngoto out;\r\n} else if (retval == EEXIST) {\r\nif (args->flags & ATTR_CREATE)\r\ngoto out;\r\ntrace_xfs_attr_node_replace(args);\r\nargs->op_flags |= XFS_DA_OP_RENAME;\r\nargs->blkno2 = args->blkno;\r\nargs->index2 = args->index;\r\nargs->rmtblkno2 = args->rmtblkno;\r\nargs->rmtblkcnt2 = args->rmtblkcnt;\r\nargs->rmtblkno = 0;\r\nargs->rmtblkcnt = 0;\r\n}\r\nretval = xfs_attr3_leaf_add(blk->bp, state->args);\r\nif (retval == ENOSPC) {\r\nif (state->path.active == 1) {\r\nxfs_da_state_free(state);\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_node(args);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans,\r\nargs->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\ngoto out;\r\ngoto restart;\r\n}\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_da3_split(state);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n} else {\r\nxfs_da3_fixhashpath(state, &state->path);\r\n}\r\nxfs_da_state_free(state);\r\nstate = NULL;\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\ngoto out;\r\nif (args->rmtblkno > 0) {\r\nerror = xfs_attr_rmtval_set(args);\r\nif (error)\r\nreturn(error);\r\n}\r\nif (args->op_flags & XFS_DA_OP_RENAME) {\r\nerror = xfs_attr3_leaf_flipflags(args);\r\nif (error)\r\ngoto out;\r\nargs->index = args->index2;\r\nargs->blkno = args->blkno2;\r\nargs->rmtblkno = args->rmtblkno2;\r\nargs->rmtblkcnt = args->rmtblkcnt2;\r\nif (args->rmtblkno) {\r\nerror = xfs_attr_rmtval_remove(args);\r\nif (error)\r\nreturn(error);\r\n}\r\nargs->flags |= XFS_ATTR_INCOMPLETE;\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = mp;\r\nstate->blocksize = state->mp->m_sb.sb_blocksize;\r\nstate->node_ents = state->mp->m_attr_node_ents;\r\nstate->inleaf = 0;\r\nerror = xfs_da3_node_lookup_int(state, &retval);\r\nif (error)\r\ngoto out;\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nerror = xfs_attr3_leaf_remove(blk->bp, args);\r\nxfs_da3_fixhashpath(state, &state->path);\r\nif (retval && (state->path.active > 1)) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_da3_join(state);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans,\r\nargs->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n}\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\ngoto out;\r\n} else if (args->rmtblkno > 0) {\r\nerror = xfs_attr3_leaf_clearflag(args);\r\nif (error)\r\ngoto out;\r\n}\r\nretval = error = 0;\r\nout:\r\nif (state)\r\nxfs_da_state_free(state);\r\nif (error)\r\nreturn(error);\r\nreturn(retval);\r\n}\r\nSTATIC int\r\nxfs_attr_node_removename(xfs_da_args_t *args)\r\n{\r\nxfs_da_state_t *state;\r\nxfs_da_state_blk_t *blk;\r\nxfs_inode_t *dp;\r\nstruct xfs_buf *bp;\r\nint retval, error, committed, forkoff;\r\ntrace_xfs_attr_node_removename(args);\r\ndp = args->dp;\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = dp->i_mount;\r\nstate->blocksize = state->mp->m_sb.sb_blocksize;\r\nstate->node_ents = state->mp->m_attr_node_ents;\r\nerror = xfs_da3_node_lookup_int(state, &retval);\r\nif (error || (retval != EEXIST)) {\r\nif (error == 0)\r\nerror = retval;\r\ngoto out;\r\n}\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->bp != NULL);\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nif (args->rmtblkno > 0) {\r\nerror = xfs_attr_fillstate(state);\r\nif (error)\r\ngoto out;\r\nerror = xfs_attr3_leaf_setflag(args);\r\nif (error)\r\ngoto out;\r\nerror = xfs_attr_rmtval_remove(args);\r\nif (error)\r\ngoto out;\r\nerror = xfs_attr_refillstate(state);\r\nif (error)\r\ngoto out;\r\n}\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nretval = xfs_attr3_leaf_remove(blk->bp, args);\r\nxfs_da3_fixhashpath(state, &state->path);\r\nif (retval && (state->path.active > 1)) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_da3_join(state);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\ngoto out;\r\n}\r\nif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\r\nASSERT(state->path.active == 1);\r\nASSERT(state->path.blk[0].bp);\r\nstate->path.blk[0].bp = NULL;\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, 0, -1, &bp);\r\nif (error)\r\ngoto out;\r\nif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans,\r\nargs->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n} else\r\nxfs_trans_brelse(args->trans, bp);\r\n}\r\nerror = 0;\r\nout:\r\nxfs_da_state_free(state);\r\nreturn(error);\r\n}\r\nSTATIC int\r\nxfs_attr_fillstate(xfs_da_state_t *state)\r\n{\r\nxfs_da_state_path_t *path;\r\nxfs_da_state_blk_t *blk;\r\nint level;\r\ntrace_xfs_attr_fillstate(state->args);\r\npath = &state->path;\r\nASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\r\nfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\r\nif (blk->bp) {\r\nblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\r\nblk->bp = NULL;\r\n} else {\r\nblk->disk_blkno = 0;\r\n}\r\n}\r\npath = &state->altpath;\r\nASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\r\nfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\r\nif (blk->bp) {\r\nblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\r\nblk->bp = NULL;\r\n} else {\r\nblk->disk_blkno = 0;\r\n}\r\n}\r\nreturn(0);\r\n}\r\nSTATIC int\r\nxfs_attr_refillstate(xfs_da_state_t *state)\r\n{\r\nxfs_da_state_path_t *path;\r\nxfs_da_state_blk_t *blk;\r\nint level, error;\r\ntrace_xfs_attr_refillstate(state->args);\r\npath = &state->path;\r\nASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\r\nfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\r\nif (blk->disk_blkno) {\r\nerror = xfs_da3_node_read(state->args->trans,\r\nstate->args->dp,\r\nblk->blkno, blk->disk_blkno,\r\n&blk->bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\n} else {\r\nblk->bp = NULL;\r\n}\r\n}\r\npath = &state->altpath;\r\nASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\r\nfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\r\nif (blk->disk_blkno) {\r\nerror = xfs_da3_node_read(state->args->trans,\r\nstate->args->dp,\r\nblk->blkno, blk->disk_blkno,\r\n&blk->bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\n} else {\r\nblk->bp = NULL;\r\n}\r\n}\r\nreturn(0);\r\n}\r\nSTATIC int\r\nxfs_attr_node_get(xfs_da_args_t *args)\r\n{\r\nxfs_da_state_t *state;\r\nxfs_da_state_blk_t *blk;\r\nint error, retval;\r\nint i;\r\ntrace_xfs_attr_node_get(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_sb.sb_blocksize;\r\nstate->node_ents = state->mp->m_attr_node_ents;\r\nerror = xfs_da3_node_lookup_int(state, &retval);\r\nif (error) {\r\nretval = error;\r\n} else if (retval == EEXIST) {\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->bp != NULL);\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nretval = xfs_attr3_leaf_getvalue(blk->bp, args);\r\nif (!retval && (args->rmtblkno > 0)\r\n&& !(args->flags & ATTR_KERNOVAL)) {\r\nretval = xfs_attr_rmtval_get(args);\r\n}\r\n}\r\nfor (i = 0; i < state->path.active; i++) {\r\nxfs_trans_brelse(args->trans, state->path.blk[i].bp);\r\nstate->path.blk[i].bp = NULL;\r\n}\r\nxfs_da_state_free(state);\r\nreturn(retval);\r\n}\r\nSTATIC int\r\nxfs_attr_node_list(xfs_attr_list_context_t *context)\r\n{\r\nattrlist_cursor_kern_t *cursor;\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_da_intnode_t *node;\r\nstruct xfs_attr3_icleaf_hdr leafhdr;\r\nstruct xfs_da3_icnode_hdr nodehdr;\r\nstruct xfs_da_node_entry *btree;\r\nint error, i;\r\nstruct xfs_buf *bp;\r\ntrace_xfs_attr_node_list(context);\r\ncursor = context->cursor;\r\ncursor->initted = 1;\r\nbp = NULL;\r\nif (cursor->blkno > 0) {\r\nerror = xfs_da3_node_read(NULL, context->dp, cursor->blkno, -1,\r\n&bp, XFS_ATTR_FORK);\r\nif ((error != 0) && (error != EFSCORRUPTED))\r\nreturn(error);\r\nif (bp) {\r\nstruct xfs_attr_leaf_entry *entries;\r\nnode = bp->b_addr;\r\nswitch (be16_to_cpu(node->hdr.info.magic)) {\r\ncase XFS_DA_NODE_MAGIC:\r\ncase XFS_DA3_NODE_MAGIC:\r\ntrace_xfs_attr_list_wrong_blk(context);\r\nxfs_trans_brelse(NULL, bp);\r\nbp = NULL;\r\nbreak;\r\ncase XFS_ATTR_LEAF_MAGIC:\r\ncase XFS_ATTR3_LEAF_MAGIC:\r\nleaf = bp->b_addr;\r\nxfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nentries = xfs_attr3_leaf_entryp(leaf);\r\nif (cursor->hashval > be32_to_cpu(\r\nentries[leafhdr.count - 1].hashval)) {\r\ntrace_xfs_attr_list_wrong_blk(context);\r\nxfs_trans_brelse(NULL, bp);\r\nbp = NULL;\r\n} else if (cursor->hashval <= be32_to_cpu(\r\nentries[0].hashval)) {\r\ntrace_xfs_attr_list_wrong_blk(context);\r\nxfs_trans_brelse(NULL, bp);\r\nbp = NULL;\r\n}\r\nbreak;\r\ndefault:\r\ntrace_xfs_attr_list_wrong_blk(context);\r\nxfs_trans_brelse(NULL, bp);\r\nbp = NULL;\r\n}\r\n}\r\n}\r\nif (bp == NULL) {\r\ncursor->blkno = 0;\r\nfor (;;) {\r\n__uint16_t magic;\r\nerror = xfs_da3_node_read(NULL, context->dp,\r\ncursor->blkno, -1, &bp,\r\nXFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\nnode = bp->b_addr;\r\nmagic = be16_to_cpu(node->hdr.info.magic);\r\nif (magic == XFS_ATTR_LEAF_MAGIC ||\r\nmagic == XFS_ATTR3_LEAF_MAGIC)\r\nbreak;\r\nif (magic != XFS_DA_NODE_MAGIC &&\r\nmagic != XFS_DA3_NODE_MAGIC) {\r\nXFS_CORRUPTION_ERROR("xfs_attr_node_list(3)",\r\nXFS_ERRLEVEL_LOW,\r\ncontext->dp->i_mount,\r\nnode);\r\nxfs_trans_brelse(NULL, bp);\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\nxfs_da3_node_hdr_from_disk(&nodehdr, node);\r\nbtree = xfs_da3_node_tree_p(node);\r\nfor (i = 0; i < nodehdr.count; btree++, i++) {\r\nif (cursor->hashval\r\n<= be32_to_cpu(btree->hashval)) {\r\ncursor->blkno = be32_to_cpu(btree->before);\r\ntrace_xfs_attr_list_node_descend(context,\r\nbtree);\r\nbreak;\r\n}\r\n}\r\nif (i == nodehdr.count) {\r\nxfs_trans_brelse(NULL, bp);\r\nreturn 0;\r\n}\r\nxfs_trans_brelse(NULL, bp);\r\n}\r\n}\r\nASSERT(bp != NULL);\r\nfor (;;) {\r\nleaf = bp->b_addr;\r\nerror = xfs_attr3_leaf_list_int(bp, context);\r\nif (error) {\r\nxfs_trans_brelse(NULL, bp);\r\nreturn error;\r\n}\r\nxfs_attr3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nif (context->seen_enough || leafhdr.forw == 0)\r\nbreak;\r\ncursor->blkno = leafhdr.forw;\r\nxfs_trans_brelse(NULL, bp);\r\nerror = xfs_attr3_leaf_read(NULL, context->dp, cursor->blkno, -1,\r\n&bp);\r\nif (error)\r\nreturn error;\r\n}\r\nxfs_trans_brelse(NULL, bp);\r\nreturn 0;\r\n}
