const struct iio_chan_spec\r\n*iio_find_channel_from_si(struct iio_dev *indio_dev, int si)\r\n{\r\nint i;\r\nfor (i = 0; i < indio_dev->num_channels; i++)\r\nif (indio_dev->channels[i].scan_index == si)\r\nreturn &indio_dev->channels[i];\r\nreturn NULL;\r\n}\r\nssize_t iio_read_const_attr(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", to_iio_const_attr(attr)->string);\r\n}\r\nstatic int __init iio_init(void)\r\n{\r\nint ret;\r\nret = bus_register(&iio_bus_type);\r\nif (ret < 0) {\r\nprintk(KERN_ERR\r\n"%s could not register bus type\n",\r\n__FILE__);\r\ngoto error_nothing;\r\n}\r\nret = alloc_chrdev_region(&iio_devt, 0, IIO_DEV_MAX, "iio");\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: failed to allocate char dev region\n",\r\n__FILE__);\r\ngoto error_unregister_bus_type;\r\n}\r\niio_debugfs_dentry = debugfs_create_dir("iio", NULL);\r\nreturn 0;\r\nerror_unregister_bus_type:\r\nbus_unregister(&iio_bus_type);\r\nerror_nothing:\r\nreturn ret;\r\n}\r\nstatic void __exit iio_exit(void)\r\n{\r\nif (iio_devt)\r\nunregister_chrdev_region(iio_devt, IIO_DEV_MAX);\r\nbus_unregister(&iio_bus_type);\r\ndebugfs_remove(iio_debugfs_dentry);\r\n}\r\nstatic ssize_t iio_debugfs_read_reg(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iio_dev *indio_dev = file->private_data;\r\nchar buf[20];\r\nunsigned val = 0;\r\nssize_t len;\r\nint ret;\r\nret = indio_dev->info->debugfs_reg_access(indio_dev,\r\nindio_dev->cached_reg_addr,\r\n0, &val);\r\nif (ret)\r\ndev_err(indio_dev->dev.parent, "%s: read failed\n", __func__);\r\nlen = snprintf(buf, sizeof(buf), "0x%X\n", val);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t iio_debugfs_write_reg(struct file *file,\r\nconst char __user *userbuf, size_t count, loff_t *ppos)\r\n{\r\nstruct iio_dev *indio_dev = file->private_data;\r\nunsigned reg, val;\r\nchar buf[80];\r\nint ret;\r\ncount = min_t(size_t, count, (sizeof(buf)-1));\r\nif (copy_from_user(buf, userbuf, count))\r\nreturn -EFAULT;\r\nbuf[count] = 0;\r\nret = sscanf(buf, "%i %i", &reg, &val);\r\nswitch (ret) {\r\ncase 1:\r\nindio_dev->cached_reg_addr = reg;\r\nbreak;\r\ncase 2:\r\nindio_dev->cached_reg_addr = reg;\r\nret = indio_dev->info->debugfs_reg_access(indio_dev, reg,\r\nval, NULL);\r\nif (ret) {\r\ndev_err(indio_dev->dev.parent, "%s: write failed\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic void iio_device_unregister_debugfs(struct iio_dev *indio_dev)\r\n{\r\ndebugfs_remove_recursive(indio_dev->debugfs_dentry);\r\n}\r\nstatic int iio_device_register_debugfs(struct iio_dev *indio_dev)\r\n{\r\nstruct dentry *d;\r\nif (indio_dev->info->debugfs_reg_access == NULL)\r\nreturn 0;\r\nif (!iio_debugfs_dentry)\r\nreturn 0;\r\nindio_dev->debugfs_dentry =\r\ndebugfs_create_dir(dev_name(&indio_dev->dev),\r\niio_debugfs_dentry);\r\nif (indio_dev->debugfs_dentry == NULL) {\r\ndev_warn(indio_dev->dev.parent,\r\n"Failed to create debugfs directory\n");\r\nreturn -EFAULT;\r\n}\r\nd = debugfs_create_file("direct_reg_access", 0644,\r\nindio_dev->debugfs_dentry,\r\nindio_dev, &iio_debugfs_reg_fops);\r\nif (!d) {\r\niio_device_unregister_debugfs(indio_dev);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iio_device_register_debugfs(struct iio_dev *indio_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void iio_device_unregister_debugfs(struct iio_dev *indio_dev)\r\n{\r\n}\r\nstatic ssize_t iio_read_channel_ext_info(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nconst struct iio_chan_spec_ext_info *ext_info;\r\next_info = &this_attr->c->ext_info[this_attr->address];\r\nreturn ext_info->read(indio_dev, ext_info->private, this_attr->c, buf);\r\n}\r\nstatic ssize_t iio_write_channel_ext_info(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nconst struct iio_chan_spec_ext_info *ext_info;\r\next_info = &this_attr->c->ext_info[this_attr->address];\r\nreturn ext_info->write(indio_dev, ext_info->private,\r\nthis_attr->c, buf, len);\r\n}\r\nssize_t iio_enum_available_read(struct iio_dev *indio_dev,\r\nuintptr_t priv, const struct iio_chan_spec *chan, char *buf)\r\n{\r\nconst struct iio_enum *e = (const struct iio_enum *)priv;\r\nunsigned int i;\r\nsize_t len = 0;\r\nif (!e->num_items)\r\nreturn 0;\r\nfor (i = 0; i < e->num_items; ++i)\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%s ", e->items[i]);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nssize_t iio_enum_read(struct iio_dev *indio_dev,\r\nuintptr_t priv, const struct iio_chan_spec *chan, char *buf)\r\n{\r\nconst struct iio_enum *e = (const struct iio_enum *)priv;\r\nint i;\r\nif (!e->get)\r\nreturn -EINVAL;\r\ni = e->get(indio_dev, chan);\r\nif (i < 0)\r\nreturn i;\r\nelse if (i >= e->num_items)\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%s\n", e->items[i]);\r\n}\r\nssize_t iio_enum_write(struct iio_dev *indio_dev,\r\nuintptr_t priv, const struct iio_chan_spec *chan, const char *buf,\r\nsize_t len)\r\n{\r\nconst struct iio_enum *e = (const struct iio_enum *)priv;\r\nunsigned int i;\r\nint ret;\r\nif (!e->set)\r\nreturn -EINVAL;\r\nfor (i = 0; i < e->num_items; i++) {\r\nif (sysfs_streq(buf, e->items[i]))\r\nbreak;\r\n}\r\nif (i == e->num_items)\r\nreturn -EINVAL;\r\nret = e->set(indio_dev, chan, i);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t iio_read_channel_info(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nunsigned long long tmp;\r\nint val, val2;\r\nbool scale_db = false;\r\nint ret = indio_dev->info->read_raw(indio_dev, this_attr->c,\r\n&val, &val2, this_attr->address);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (ret) {\r\ncase IIO_VAL_INT:\r\nreturn sprintf(buf, "%d\n", val);\r\ncase IIO_VAL_INT_PLUS_MICRO_DB:\r\nscale_db = true;\r\ncase IIO_VAL_INT_PLUS_MICRO:\r\nif (val2 < 0)\r\nreturn sprintf(buf, "-%d.%06u%s\n", val, -val2,\r\nscale_db ? " dB" : "");\r\nelse\r\nreturn sprintf(buf, "%d.%06u%s\n", val, val2,\r\nscale_db ? " dB" : "");\r\ncase IIO_VAL_INT_PLUS_NANO:\r\nif (val2 < 0)\r\nreturn sprintf(buf, "-%d.%09u\n", val, -val2);\r\nelse\r\nreturn sprintf(buf, "%d.%09u\n", val, val2);\r\ncase IIO_VAL_FRACTIONAL:\r\ntmp = div_s64((s64)val * 1000000000LL, val2);\r\nval2 = do_div(tmp, 1000000000LL);\r\nval = tmp;\r\nreturn sprintf(buf, "%d.%09u\n", val, val2);\r\ncase IIO_VAL_FRACTIONAL_LOG2:\r\ntmp = (s64)val * 1000000000LL >> val2;\r\nval2 = do_div(tmp, 1000000000LL);\r\nval = tmp;\r\nreturn sprintf(buf, "%d.%09u\n", val, val2);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint iio_str_to_fixpoint(const char *str, int fract_mult,\r\nint *integer, int *fract)\r\n{\r\nint i = 0, f = 0;\r\nbool integer_part = true, negative = false;\r\nif (str[0] == '-') {\r\nnegative = true;\r\nstr++;\r\n} else if (str[0] == '+') {\r\nstr++;\r\n}\r\nwhile (*str) {\r\nif ('0' <= *str && *str <= '9') {\r\nif (integer_part) {\r\ni = i * 10 + *str - '0';\r\n} else {\r\nf += fract_mult * (*str - '0');\r\nfract_mult /= 10;\r\n}\r\n} else if (*str == '\n') {\r\nif (*(str + 1) == '\0')\r\nbreak;\r\nelse\r\nreturn -EINVAL;\r\n} else if (*str == '.' && integer_part) {\r\ninteger_part = false;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nstr++;\r\n}\r\nif (negative) {\r\nif (i)\r\ni = -i;\r\nelse\r\nf = -f;\r\n}\r\n*integer = i;\r\n*fract = f;\r\nreturn 0;\r\n}\r\nstatic ssize_t iio_write_channel_info(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret, fract_mult = 100000;\r\nint integer, fract;\r\nif (!indio_dev->info->write_raw)\r\nreturn -EINVAL;\r\nif (indio_dev->info->write_raw_get_fmt)\r\nswitch (indio_dev->info->write_raw_get_fmt(indio_dev,\r\nthis_attr->c, this_attr->address)) {\r\ncase IIO_VAL_INT_PLUS_MICRO:\r\nfract_mult = 100000;\r\nbreak;\r\ncase IIO_VAL_INT_PLUS_NANO:\r\nfract_mult = 100000000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = iio_str_to_fixpoint(buf, fract_mult, &integer, &fract);\r\nif (ret)\r\nreturn ret;\r\nret = indio_dev->info->write_raw(indio_dev, this_attr->c,\r\ninteger, fract, this_attr->address);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic\r\nint __iio_device_attr_init(struct device_attribute *dev_attr,\r\nconst char *postfix,\r\nstruct iio_chan_spec const *chan,\r\nssize_t (*readfunc)(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf),\r\nssize_t (*writefunc)(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len),\r\nbool generic)\r\n{\r\nint ret;\r\nchar *name_format, *full_postfix;\r\nsysfs_attr_init(&dev_attr->attr);\r\nif (chan->modified && !generic) {\r\nif (chan->extend_name)\r\nfull_postfix = kasprintf(GFP_KERNEL, "%s_%s_%s",\r\niio_modifier_names[chan\r\n->channel2],\r\nchan->extend_name,\r\npostfix);\r\nelse\r\nfull_postfix = kasprintf(GFP_KERNEL, "%s_%s",\r\niio_modifier_names[chan\r\n->channel2],\r\npostfix);\r\n} else {\r\nif (chan->extend_name == NULL)\r\nfull_postfix = kstrdup(postfix, GFP_KERNEL);\r\nelse\r\nfull_postfix = kasprintf(GFP_KERNEL,\r\n"%s_%s",\r\nchan->extend_name,\r\npostfix);\r\n}\r\nif (full_postfix == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nif (chan->differential) {\r\nif (generic)\r\nname_format\r\n= kasprintf(GFP_KERNEL, "%s_%s-%s_%s",\r\niio_direction[chan->output],\r\niio_chan_type_name_spec[chan->type],\r\niio_chan_type_name_spec[chan->type],\r\nfull_postfix);\r\nelse if (chan->indexed)\r\nname_format\r\n= kasprintf(GFP_KERNEL, "%s_%s%d-%s%d_%s",\r\niio_direction[chan->output],\r\niio_chan_type_name_spec[chan->type],\r\nchan->channel,\r\niio_chan_type_name_spec[chan->type],\r\nchan->channel2,\r\nfull_postfix);\r\nelse {\r\nWARN_ON("Differential channels must be indexed\n");\r\nret = -EINVAL;\r\ngoto error_free_full_postfix;\r\n}\r\n} else {\r\nif (generic)\r\nname_format\r\n= kasprintf(GFP_KERNEL, "%s_%s_%s",\r\niio_direction[chan->output],\r\niio_chan_type_name_spec[chan->type],\r\nfull_postfix);\r\nelse if (chan->indexed)\r\nname_format\r\n= kasprintf(GFP_KERNEL, "%s_%s%d_%s",\r\niio_direction[chan->output],\r\niio_chan_type_name_spec[chan->type],\r\nchan->channel,\r\nfull_postfix);\r\nelse\r\nname_format\r\n= kasprintf(GFP_KERNEL, "%s_%s_%s",\r\niio_direction[chan->output],\r\niio_chan_type_name_spec[chan->type],\r\nfull_postfix);\r\n}\r\nif (name_format == NULL) {\r\nret = -ENOMEM;\r\ngoto error_free_full_postfix;\r\n}\r\ndev_attr->attr.name = kasprintf(GFP_KERNEL,\r\nname_format,\r\nchan->channel,\r\nchan->channel2);\r\nif (dev_attr->attr.name == NULL) {\r\nret = -ENOMEM;\r\ngoto error_free_name_format;\r\n}\r\nif (readfunc) {\r\ndev_attr->attr.mode |= S_IRUGO;\r\ndev_attr->show = readfunc;\r\n}\r\nif (writefunc) {\r\ndev_attr->attr.mode |= S_IWUSR;\r\ndev_attr->store = writefunc;\r\n}\r\nkfree(name_format);\r\nkfree(full_postfix);\r\nreturn 0;\r\nerror_free_name_format:\r\nkfree(name_format);\r\nerror_free_full_postfix:\r\nkfree(full_postfix);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic void __iio_device_attr_deinit(struct device_attribute *dev_attr)\r\n{\r\nkfree(dev_attr->attr.name);\r\n}\r\nint __iio_add_chan_devattr(const char *postfix,\r\nstruct iio_chan_spec const *chan,\r\nssize_t (*readfunc)(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf),\r\nssize_t (*writefunc)(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len),\r\nu64 mask,\r\nbool generic,\r\nstruct device *dev,\r\nstruct list_head *attr_list)\r\n{\r\nint ret;\r\nstruct iio_dev_attr *iio_attr, *t;\r\niio_attr = kzalloc(sizeof *iio_attr, GFP_KERNEL);\r\nif (iio_attr == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nret = __iio_device_attr_init(&iio_attr->dev_attr,\r\npostfix, chan,\r\nreadfunc, writefunc, generic);\r\nif (ret)\r\ngoto error_iio_dev_attr_free;\r\niio_attr->c = chan;\r\niio_attr->address = mask;\r\nlist_for_each_entry(t, attr_list, l)\r\nif (strcmp(t->dev_attr.attr.name,\r\niio_attr->dev_attr.attr.name) == 0) {\r\nif (!generic)\r\ndev_err(dev, "tried to double register : %s\n",\r\nt->dev_attr.attr.name);\r\nret = -EBUSY;\r\ngoto error_device_attr_deinit;\r\n}\r\nlist_add(&iio_attr->l, attr_list);\r\nreturn 0;\r\nerror_device_attr_deinit:\r\n__iio_device_attr_deinit(&iio_attr->dev_attr);\r\nerror_iio_dev_attr_free:\r\nkfree(iio_attr);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int iio_device_add_channel_sysfs(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nint ret, attrcount = 0;\r\nint i;\r\nconst struct iio_chan_spec_ext_info *ext_info;\r\nif (chan->channel < 0)\r\nreturn 0;\r\nfor_each_set_bit(i, &chan->info_mask_separate, sizeof(long)*8) {\r\nret = __iio_add_chan_devattr(iio_chan_info_postfix[i],\r\nchan,\r\n&iio_read_channel_info,\r\n&iio_write_channel_info,\r\ni,\r\n0,\r\n&indio_dev->dev,\r\n&indio_dev->channel_attr_list);\r\nif (ret < 0)\r\ngoto error_ret;\r\nattrcount++;\r\n}\r\nfor_each_set_bit(i, &chan->info_mask_shared_by_type, sizeof(long)*8) {\r\nret = __iio_add_chan_devattr(iio_chan_info_postfix[i],\r\nchan,\r\n&iio_read_channel_info,\r\n&iio_write_channel_info,\r\ni,\r\n1,\r\n&indio_dev->dev,\r\n&indio_dev->channel_attr_list);\r\nif (ret == -EBUSY) {\r\nret = 0;\r\ncontinue;\r\n} else if (ret < 0) {\r\ngoto error_ret;\r\n}\r\nattrcount++;\r\n}\r\nif (chan->ext_info) {\r\nunsigned int i = 0;\r\nfor (ext_info = chan->ext_info; ext_info->name; ext_info++) {\r\nret = __iio_add_chan_devattr(ext_info->name,\r\nchan,\r\next_info->read ?\r\n&iio_read_channel_ext_info : NULL,\r\next_info->write ?\r\n&iio_write_channel_ext_info : NULL,\r\ni,\r\next_info->shared,\r\n&indio_dev->dev,\r\n&indio_dev->channel_attr_list);\r\ni++;\r\nif (ret == -EBUSY && ext_info->shared)\r\ncontinue;\r\nif (ret)\r\ngoto error_ret;\r\nattrcount++;\r\n}\r\n}\r\nret = attrcount;\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic void iio_device_remove_and_free_read_attr(struct iio_dev *indio_dev,\r\nstruct iio_dev_attr *p)\r\n{\r\nkfree(p->dev_attr.attr.name);\r\nkfree(p);\r\n}\r\nstatic ssize_t iio_show_dev_name(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nreturn sprintf(buf, "%s\n", indio_dev->name);\r\n}\r\nstatic int iio_device_register_sysfs(struct iio_dev *indio_dev)\r\n{\r\nint i, ret = 0, attrcount, attrn, attrcount_orig = 0;\r\nstruct iio_dev_attr *p, *n;\r\nstruct attribute **attr;\r\nif (indio_dev->info->attrs) {\r\nattr = indio_dev->info->attrs->attrs;\r\nwhile (*attr++ != NULL)\r\nattrcount_orig++;\r\n}\r\nattrcount = attrcount_orig;\r\nif (indio_dev->channels)\r\nfor (i = 0; i < indio_dev->num_channels; i++) {\r\nret = iio_device_add_channel_sysfs(indio_dev,\r\n&indio_dev\r\n->channels[i]);\r\nif (ret < 0)\r\ngoto error_clear_attrs;\r\nattrcount += ret;\r\n}\r\nif (indio_dev->name)\r\nattrcount++;\r\nindio_dev->chan_attr_group.attrs = kcalloc(attrcount + 1,\r\nsizeof(indio_dev->chan_attr_group.attrs[0]),\r\nGFP_KERNEL);\r\nif (indio_dev->chan_attr_group.attrs == NULL) {\r\nret = -ENOMEM;\r\ngoto error_clear_attrs;\r\n}\r\nif (indio_dev->info->attrs)\r\nmemcpy(indio_dev->chan_attr_group.attrs,\r\nindio_dev->info->attrs->attrs,\r\nsizeof(indio_dev->chan_attr_group.attrs[0])\r\n*attrcount_orig);\r\nattrn = attrcount_orig;\r\nlist_for_each_entry(p, &indio_dev->channel_attr_list, l)\r\nindio_dev->chan_attr_group.attrs[attrn++] = &p->dev_attr.attr;\r\nif (indio_dev->name)\r\nindio_dev->chan_attr_group.attrs[attrn++] = &dev_attr_name.attr;\r\nindio_dev->groups[indio_dev->groupcounter++] =\r\n&indio_dev->chan_attr_group;\r\nreturn 0;\r\nerror_clear_attrs:\r\nlist_for_each_entry_safe(p, n,\r\n&indio_dev->channel_attr_list, l) {\r\nlist_del(&p->l);\r\niio_device_remove_and_free_read_attr(indio_dev, p);\r\n}\r\nreturn ret;\r\n}\r\nstatic void iio_device_unregister_sysfs(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_dev_attr *p, *n;\r\nlist_for_each_entry_safe(p, n, &indio_dev->channel_attr_list, l) {\r\nlist_del(&p->l);\r\niio_device_remove_and_free_read_attr(indio_dev, p);\r\n}\r\nkfree(indio_dev->chan_attr_group.attrs);\r\n}\r\nstatic void iio_dev_release(struct device *device)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(device);\r\nif (indio_dev->chrdev.dev)\r\ncdev_del(&indio_dev->chrdev);\r\nif (indio_dev->modes & INDIO_BUFFER_TRIGGERED)\r\niio_device_unregister_trigger_consumer(indio_dev);\r\niio_device_unregister_eventset(indio_dev);\r\niio_device_unregister_sysfs(indio_dev);\r\niio_device_unregister_debugfs(indio_dev);\r\nida_simple_remove(&iio_ida, indio_dev->id);\r\nkfree(indio_dev);\r\n}\r\nstruct iio_dev *iio_device_alloc(int sizeof_priv)\r\n{\r\nstruct iio_dev *dev;\r\nsize_t alloc_size;\r\nalloc_size = sizeof(struct iio_dev);\r\nif (sizeof_priv) {\r\nalloc_size = ALIGN(alloc_size, IIO_ALIGN);\r\nalloc_size += sizeof_priv;\r\n}\r\nalloc_size += IIO_ALIGN - 1;\r\ndev = kzalloc(alloc_size, GFP_KERNEL);\r\nif (dev) {\r\ndev->dev.groups = dev->groups;\r\ndev->dev.type = &iio_device_type;\r\ndev->dev.bus = &iio_bus_type;\r\ndevice_initialize(&dev->dev);\r\ndev_set_drvdata(&dev->dev, (void *)dev);\r\nmutex_init(&dev->mlock);\r\nmutex_init(&dev->info_exist_lock);\r\nINIT_LIST_HEAD(&dev->channel_attr_list);\r\ndev->id = ida_simple_get(&iio_ida, 0, 0, GFP_KERNEL);\r\nif (dev->id < 0) {\r\nprintk(KERN_ERR "Failed to get id\n");\r\nkfree(dev);\r\nreturn NULL;\r\n}\r\ndev_set_name(&dev->dev, "iio:device%d", dev->id);\r\nINIT_LIST_HEAD(&dev->buffer_list);\r\n}\r\nreturn dev;\r\n}\r\nvoid iio_device_free(struct iio_dev *dev)\r\n{\r\nif (dev)\r\nput_device(&dev->dev);\r\n}\r\nstatic int iio_chrdev_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct iio_dev *indio_dev = container_of(inode->i_cdev,\r\nstruct iio_dev, chrdev);\r\nif (test_and_set_bit(IIO_BUSY_BIT_POS, &indio_dev->flags))\r\nreturn -EBUSY;\r\nfilp->private_data = indio_dev;\r\nreturn 0;\r\n}\r\nstatic int iio_chrdev_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct iio_dev *indio_dev = container_of(inode->i_cdev,\r\nstruct iio_dev, chrdev);\r\nclear_bit(IIO_BUSY_BIT_POS, &indio_dev->flags);\r\nreturn 0;\r\n}\r\nstatic long iio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct iio_dev *indio_dev = filp->private_data;\r\nint __user *ip = (int __user *)arg;\r\nint fd;\r\nif (cmd == IIO_GET_EVENT_FD_IOCTL) {\r\nfd = iio_event_getfd(indio_dev);\r\nif (copy_to_user(ip, &fd, sizeof(fd)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint iio_device_register(struct iio_dev *indio_dev)\r\n{\r\nint ret;\r\nif (!indio_dev->dev.of_node && indio_dev->dev.parent)\r\nindio_dev->dev.of_node = indio_dev->dev.parent->of_node;\r\nindio_dev->dev.devt = MKDEV(MAJOR(iio_devt), indio_dev->id);\r\nret = iio_device_register_debugfs(indio_dev);\r\nif (ret) {\r\ndev_err(indio_dev->dev.parent,\r\n"Failed to register debugfs interfaces\n");\r\ngoto error_ret;\r\n}\r\nret = iio_device_register_sysfs(indio_dev);\r\nif (ret) {\r\ndev_err(indio_dev->dev.parent,\r\n"Failed to register sysfs interfaces\n");\r\ngoto error_unreg_debugfs;\r\n}\r\nret = iio_device_register_eventset(indio_dev);\r\nif (ret) {\r\ndev_err(indio_dev->dev.parent,\r\n"Failed to register event set\n");\r\ngoto error_free_sysfs;\r\n}\r\nif (indio_dev->modes & INDIO_BUFFER_TRIGGERED)\r\niio_device_register_trigger_consumer(indio_dev);\r\nif ((indio_dev->modes & INDIO_ALL_BUFFER_MODES) &&\r\nindio_dev->setup_ops == NULL)\r\nindio_dev->setup_ops = &noop_ring_setup_ops;\r\nret = device_add(&indio_dev->dev);\r\nif (ret < 0)\r\ngoto error_unreg_eventset;\r\ncdev_init(&indio_dev->chrdev, &iio_buffer_fileops);\r\nindio_dev->chrdev.owner = indio_dev->info->driver_module;\r\nret = cdev_add(&indio_dev->chrdev, indio_dev->dev.devt, 1);\r\nif (ret < 0)\r\ngoto error_del_device;\r\nreturn 0;\r\nerror_del_device:\r\ndevice_del(&indio_dev->dev);\r\nerror_unreg_eventset:\r\niio_device_unregister_eventset(indio_dev);\r\nerror_free_sysfs:\r\niio_device_unregister_sysfs(indio_dev);\r\nerror_unreg_debugfs:\r\niio_device_unregister_debugfs(indio_dev);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nvoid iio_device_unregister(struct iio_dev *indio_dev)\r\n{\r\nmutex_lock(&indio_dev->info_exist_lock);\r\nindio_dev->info = NULL;\r\nmutex_unlock(&indio_dev->info_exist_lock);\r\ndevice_del(&indio_dev->dev);\r\n}
