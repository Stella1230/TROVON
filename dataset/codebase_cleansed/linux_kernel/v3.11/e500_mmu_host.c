static inline unsigned int tlb1_max_shadow_size(void)\r\n{\r\nreturn host_tlb_params[1].entries - tlbcam_index - 1;\r\n}\r\nstatic inline u32 e500_shadow_mas3_attrib(u32 mas3, int usermode)\r\n{\r\nmas3 &= MAS3_ATTRIB_MASK;\r\n#ifndef CONFIG_KVM_BOOKE_HV\r\nif (!usermode) {\r\nmas3 &= ~E500_TLB_USER_PERM_MASK;\r\nmas3 |= (mas3 & E500_TLB_SUPER_PERM_MASK) << 1;\r\n}\r\nmas3 |= E500_TLB_SUPER_PERM_MASK;\r\n#endif\r\nreturn mas3;\r\n}\r\nstatic inline u32 e500_shadow_mas2_attrib(u32 mas2, int usermode)\r\n{\r\n#ifdef CONFIG_SMP\r\nreturn (mas2 & MAS2_ATTRIB_MASK) | MAS2_M;\r\n#else\r\nreturn mas2 & MAS2_ATTRIB_MASK;\r\n#endif\r\n}\r\nstatic inline void __write_host_tlbe(struct kvm_book3e_206_tlb_entry *stlbe,\r\nuint32_t mas0)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nmtspr(SPRN_MAS0, mas0);\r\nmtspr(SPRN_MAS1, stlbe->mas1);\r\nmtspr(SPRN_MAS2, (unsigned long)stlbe->mas2);\r\nmtspr(SPRN_MAS3, (u32)stlbe->mas7_3);\r\nmtspr(SPRN_MAS7, (u32)(stlbe->mas7_3 >> 32));\r\n#ifdef CONFIG_KVM_BOOKE_HV\r\nmtspr(SPRN_MAS8, stlbe->mas8);\r\n#endif\r\nasm volatile("isync; tlbwe" : : : "memory");\r\n#ifdef CONFIG_KVM_BOOKE_HV\r\nmtspr(SPRN_MAS8, 0);\r\nisync();\r\n#endif\r\nlocal_irq_restore(flags);\r\ntrace_kvm_booke206_stlb_write(mas0, stlbe->mas8, stlbe->mas1,\r\nstlbe->mas2, stlbe->mas7_3);\r\n}\r\nstatic u32 get_host_mas0(unsigned long eaddr)\r\n{\r\nunsigned long flags;\r\nu32 mas0;\r\nlocal_irq_save(flags);\r\nmtspr(SPRN_MAS6, 0);\r\nasm volatile("tlbsx 0, %0" : : "b" (eaddr & ~CONFIG_PAGE_OFFSET));\r\nmas0 = mfspr(SPRN_MAS0);\r\nlocal_irq_restore(flags);\r\nreturn mas0;\r\n}\r\nstatic inline void write_host_tlbe(struct kvmppc_vcpu_e500 *vcpu_e500,\r\nint tlbsel, int sesel, struct kvm_book3e_206_tlb_entry *stlbe)\r\n{\r\nu32 mas0;\r\nif (tlbsel == 0) {\r\nmas0 = get_host_mas0(stlbe->mas2);\r\n__write_host_tlbe(stlbe, mas0);\r\n} else {\r\n__write_host_tlbe(stlbe,\r\nMAS0_TLBSEL(1) |\r\nMAS0_ESEL(to_htlb1_esel(sesel)));\r\n}\r\n}\r\nstatic void write_stlbe(struct kvmppc_vcpu_e500 *vcpu_e500,\r\nstruct kvm_book3e_206_tlb_entry *gtlbe,\r\nstruct kvm_book3e_206_tlb_entry *stlbe,\r\nint stlbsel, int sesel)\r\n{\r\nint stid;\r\npreempt_disable();\r\nstid = kvmppc_e500_get_tlb_stid(&vcpu_e500->vcpu, gtlbe);\r\nstlbe->mas1 |= MAS1_TID(stid);\r\nwrite_host_tlbe(vcpu_e500, stlbsel, sesel, stlbe);\r\npreempt_enable();\r\n}\r\nvoid kvmppc_map_magic(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500 = to_e500(vcpu);\r\nstruct kvm_book3e_206_tlb_entry magic;\r\nulong shared_page = ((ulong)vcpu->arch.shared) & PAGE_MASK;\r\nunsigned int stid;\r\npfn_t pfn;\r\npfn = (pfn_t)virt_to_phys((void *)shared_page) >> PAGE_SHIFT;\r\nget_page(pfn_to_page(pfn));\r\npreempt_disable();\r\nstid = kvmppc_e500_get_sid(vcpu_e500, 0, 0, 0, 0);\r\nmagic.mas1 = MAS1_VALID | MAS1_TS | MAS1_TID(stid) |\r\nMAS1_TSIZE(BOOK3E_PAGESZ_4K);\r\nmagic.mas2 = vcpu->arch.magic_page_ea | MAS2_M;\r\nmagic.mas7_3 = ((u64)pfn << PAGE_SHIFT) |\r\nMAS3_SW | MAS3_SR | MAS3_UW | MAS3_UR;\r\nmagic.mas8 = 0;\r\n__write_host_tlbe(&magic, MAS0_TLBSEL(1) | MAS0_ESEL(tlbcam_index));\r\npreempt_enable();\r\n}\r\nvoid inval_gtlbe_on_host(struct kvmppc_vcpu_e500 *vcpu_e500, int tlbsel,\r\nint esel)\r\n{\r\nstruct kvm_book3e_206_tlb_entry *gtlbe =\r\nget_entry(vcpu_e500, tlbsel, esel);\r\nstruct tlbe_ref *ref = &vcpu_e500->gtlb_priv[tlbsel][esel].ref;\r\nif (!(ref->flags & E500_TLB_VALID)) {\r\nWARN(ref->flags & (E500_TLB_BITMAP | E500_TLB_TLB0),\r\n"%s: flags %x\n", __func__, ref->flags);\r\nWARN_ON(tlbsel == 1 && vcpu_e500->g2h_tlb1_map[esel]);\r\n}\r\nif (tlbsel == 1 && ref->flags & E500_TLB_BITMAP) {\r\nu64 tmp = vcpu_e500->g2h_tlb1_map[esel];\r\nint hw_tlb_indx;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nwhile (tmp) {\r\nhw_tlb_indx = __ilog2_u64(tmp & -tmp);\r\nmtspr(SPRN_MAS0,\r\nMAS0_TLBSEL(1) |\r\nMAS0_ESEL(to_htlb1_esel(hw_tlb_indx)));\r\nmtspr(SPRN_MAS1, 0);\r\nasm volatile("tlbwe");\r\nvcpu_e500->h2g_tlb1_rmap[hw_tlb_indx] = 0;\r\ntmp &= tmp - 1;\r\n}\r\nmb();\r\nvcpu_e500->g2h_tlb1_map[esel] = 0;\r\nref->flags &= ~(E500_TLB_BITMAP | E500_TLB_VALID);\r\nlocal_irq_restore(flags);\r\n}\r\nif (tlbsel == 1 && ref->flags & E500_TLB_TLB0) {\r\nkvmppc_e500_tlbil_all(vcpu_e500);\r\nref->flags &= ~(E500_TLB_TLB0 | E500_TLB_VALID);\r\n}\r\nif (!(ref->flags & E500_TLB_VALID))\r\nreturn;\r\nkvmppc_e500_tlbil_one(vcpu_e500, gtlbe);\r\nref->flags &= ~E500_TLB_VALID;\r\n}\r\nstatic inline int tlbe_is_writable(struct kvm_book3e_206_tlb_entry *tlbe)\r\n{\r\nreturn tlbe->mas7_3 & (MAS3_SW|MAS3_UW);\r\n}\r\nstatic inline void kvmppc_e500_ref_setup(struct tlbe_ref *ref,\r\nstruct kvm_book3e_206_tlb_entry *gtlbe,\r\npfn_t pfn)\r\n{\r\nref->pfn = pfn;\r\nref->flags |= E500_TLB_VALID;\r\nif (tlbe_is_writable(gtlbe))\r\nkvm_set_pfn_dirty(pfn);\r\n}\r\nstatic inline void kvmppc_e500_ref_release(struct tlbe_ref *ref)\r\n{\r\nif (ref->flags & E500_TLB_VALID) {\r\ntrace_kvm_booke206_ref_release(ref->pfn, ref->flags);\r\nref->flags = 0;\r\n}\r\n}\r\nstatic void clear_tlb1_bitmap(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nif (vcpu_e500->g2h_tlb1_map)\r\nmemset(vcpu_e500->g2h_tlb1_map, 0,\r\nsizeof(u64) * vcpu_e500->gtlb_params[1].entries);\r\nif (vcpu_e500->h2g_tlb1_rmap)\r\nmemset(vcpu_e500->h2g_tlb1_rmap, 0,\r\nsizeof(unsigned int) * host_tlb_params[1].entries);\r\n}\r\nstatic void clear_tlb_privs(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nint tlbsel;\r\nint i;\r\nfor (tlbsel = 0; tlbsel <= 1; tlbsel++) {\r\nfor (i = 0; i < vcpu_e500->gtlb_params[tlbsel].entries; i++) {\r\nstruct tlbe_ref *ref =\r\n&vcpu_e500->gtlb_priv[tlbsel][i].ref;\r\nkvmppc_e500_ref_release(ref);\r\n}\r\n}\r\n}\r\nvoid kvmppc_core_flush_tlb(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500 = to_e500(vcpu);\r\nkvmppc_e500_tlbil_all(vcpu_e500);\r\nclear_tlb_privs(vcpu_e500);\r\nclear_tlb1_bitmap(vcpu_e500);\r\n}\r\nstatic void kvmppc_e500_setup_stlbe(\r\nstruct kvm_vcpu *vcpu,\r\nstruct kvm_book3e_206_tlb_entry *gtlbe,\r\nint tsize, struct tlbe_ref *ref, u64 gvaddr,\r\nstruct kvm_book3e_206_tlb_entry *stlbe)\r\n{\r\npfn_t pfn = ref->pfn;\r\nu32 pr = vcpu->arch.shared->msr & MSR_PR;\r\nBUG_ON(!(ref->flags & E500_TLB_VALID));\r\nstlbe->mas1 = MAS1_TSIZE(tsize) | get_tlb_sts(gtlbe) | MAS1_VALID;\r\nstlbe->mas2 = (gvaddr & MAS2_EPN) |\r\ne500_shadow_mas2_attrib(gtlbe->mas2, pr);\r\nstlbe->mas7_3 = ((u64)pfn << PAGE_SHIFT) |\r\ne500_shadow_mas3_attrib(gtlbe->mas7_3, pr);\r\n#ifdef CONFIG_KVM_BOOKE_HV\r\nstlbe->mas8 = MAS8_TGS | vcpu->kvm->arch.lpid;\r\n#endif\r\n}\r\nstatic inline int kvmppc_e500_shadow_map(struct kvmppc_vcpu_e500 *vcpu_e500,\r\nu64 gvaddr, gfn_t gfn, struct kvm_book3e_206_tlb_entry *gtlbe,\r\nint tlbsel, struct kvm_book3e_206_tlb_entry *stlbe,\r\nstruct tlbe_ref *ref)\r\n{\r\nstruct kvm_memory_slot *slot;\r\nunsigned long pfn = 0;\r\nunsigned long hva;\r\nint pfnmap = 0;\r\nint tsize = BOOK3E_PAGESZ_4K;\r\nslot = gfn_to_memslot(vcpu_e500->vcpu.kvm, gfn);\r\nhva = gfn_to_hva_memslot(slot, gfn);\r\nif (tlbsel == 1) {\r\nstruct vm_area_struct *vma;\r\ndown_read(&current->mm->mmap_sem);\r\nvma = find_vma(current->mm, hva);\r\nif (vma && hva >= vma->vm_start &&\r\n(vma->vm_flags & VM_PFNMAP)) {\r\nunsigned long start, end;\r\nunsigned long slot_start, slot_end;\r\npfnmap = 1;\r\nstart = vma->vm_pgoff;\r\nend = start +\r\n((vma->vm_end - vma->vm_start) >> PAGE_SHIFT);\r\npfn = start + ((hva - vma->vm_start) >> PAGE_SHIFT);\r\nslot_start = pfn - (gfn - slot->base_gfn);\r\nslot_end = slot_start + slot->npages;\r\nif (start < slot_start)\r\nstart = slot_start;\r\nif (end > slot_end)\r\nend = slot_end;\r\ntsize = (gtlbe->mas1 & MAS1_TSIZE_MASK) >>\r\nMAS1_TSIZE_SHIFT;\r\ntsize = max(BOOK3E_PAGESZ_4K, tsize & ~1);\r\nfor (; tsize > BOOK3E_PAGESZ_4K; tsize -= 2) {\r\nunsigned long gfn_start, gfn_end, tsize_pages;\r\ntsize_pages = 1 << (tsize - 2);\r\ngfn_start = gfn & ~(tsize_pages - 1);\r\ngfn_end = gfn_start + tsize_pages;\r\nif (gfn_start + pfn - gfn < start)\r\ncontinue;\r\nif (gfn_end + pfn - gfn > end)\r\ncontinue;\r\nif ((gfn & (tsize_pages - 1)) !=\r\n(pfn & (tsize_pages - 1)))\r\ncontinue;\r\ngvaddr &= ~((tsize_pages << PAGE_SHIFT) - 1);\r\npfn &= ~(tsize_pages - 1);\r\nbreak;\r\n}\r\n} else if (vma && hva >= vma->vm_start &&\r\n(vma->vm_flags & VM_HUGETLB)) {\r\nunsigned long psize = vma_kernel_pagesize(vma);\r\ntsize = (gtlbe->mas1 & MAS1_TSIZE_MASK) >>\r\nMAS1_TSIZE_SHIFT;\r\ntsize = min(__ilog2(psize) - 10, tsize);\r\ntsize = max(BOOK3E_PAGESZ_4K, tsize & ~1);\r\n}\r\nup_read(&current->mm->mmap_sem);\r\n}\r\nif (likely(!pfnmap)) {\r\nunsigned long tsize_pages = 1 << (tsize + 10 - PAGE_SHIFT);\r\npfn = gfn_to_pfn_memslot(slot, gfn);\r\nif (is_error_noslot_pfn(pfn)) {\r\nprintk(KERN_ERR "Couldn't get real page for gfn %lx!\n",\r\n(long)gfn);\r\nreturn -EINVAL;\r\n}\r\npfn &= ~(tsize_pages - 1);\r\ngvaddr &= ~((tsize_pages << PAGE_SHIFT) - 1);\r\n}\r\nkvmppc_e500_ref_setup(ref, gtlbe, pfn);\r\nkvmppc_e500_setup_stlbe(&vcpu_e500->vcpu, gtlbe, tsize,\r\nref, gvaddr, stlbe);\r\nkvmppc_mmu_flush_icache(pfn);\r\nkvm_release_pfn_clean(pfn);\r\nreturn 0;\r\n}\r\nstatic int kvmppc_e500_tlb0_map(struct kvmppc_vcpu_e500 *vcpu_e500, int esel,\r\nstruct kvm_book3e_206_tlb_entry *stlbe)\r\n{\r\nstruct kvm_book3e_206_tlb_entry *gtlbe;\r\nstruct tlbe_ref *ref;\r\nint stlbsel = 0;\r\nint sesel = 0;\r\nint r;\r\ngtlbe = get_entry(vcpu_e500, 0, esel);\r\nref = &vcpu_e500->gtlb_priv[0][esel].ref;\r\nr = kvmppc_e500_shadow_map(vcpu_e500, get_tlb_eaddr(gtlbe),\r\nget_tlb_raddr(gtlbe) >> PAGE_SHIFT,\r\ngtlbe, 0, stlbe, ref);\r\nif (r)\r\nreturn r;\r\nwrite_stlbe(vcpu_e500, gtlbe, stlbe, stlbsel, sesel);\r\nreturn 0;\r\n}\r\nstatic int kvmppc_e500_tlb1_map_tlb1(struct kvmppc_vcpu_e500 *vcpu_e500,\r\nstruct tlbe_ref *ref,\r\nint esel)\r\n{\r\nunsigned int sesel = vcpu_e500->host_tlb1_nv++;\r\nif (unlikely(vcpu_e500->host_tlb1_nv >= tlb1_max_shadow_size()))\r\nvcpu_e500->host_tlb1_nv = 0;\r\nif (vcpu_e500->h2g_tlb1_rmap[sesel]) {\r\nunsigned int idx = vcpu_e500->h2g_tlb1_rmap[sesel] - 1;\r\nvcpu_e500->g2h_tlb1_map[idx] &= ~(1ULL << sesel);\r\n}\r\nvcpu_e500->gtlb_priv[1][esel].ref.flags |= E500_TLB_BITMAP;\r\nvcpu_e500->g2h_tlb1_map[esel] |= (u64)1 << sesel;\r\nvcpu_e500->h2g_tlb1_rmap[sesel] = esel + 1;\r\nWARN_ON(!(ref->flags & E500_TLB_VALID));\r\nreturn sesel;\r\n}\r\nstatic int kvmppc_e500_tlb1_map(struct kvmppc_vcpu_e500 *vcpu_e500,\r\nu64 gvaddr, gfn_t gfn, struct kvm_book3e_206_tlb_entry *gtlbe,\r\nstruct kvm_book3e_206_tlb_entry *stlbe, int esel)\r\n{\r\nstruct tlbe_ref *ref = &vcpu_e500->gtlb_priv[1][esel].ref;\r\nint sesel;\r\nint r;\r\nr = kvmppc_e500_shadow_map(vcpu_e500, gvaddr, gfn, gtlbe, 1, stlbe,\r\nref);\r\nif (r)\r\nreturn r;\r\nif (get_tlb_tsize(stlbe) == BOOK3E_PAGESZ_4K) {\r\nvcpu_e500->gtlb_priv[1][esel].ref.flags |= E500_TLB_TLB0;\r\nwrite_stlbe(vcpu_e500, gtlbe, stlbe, 0, 0);\r\nreturn 0;\r\n}\r\nsesel = kvmppc_e500_tlb1_map_tlb1(vcpu_e500, ref, esel);\r\nwrite_stlbe(vcpu_e500, gtlbe, stlbe, 1, sesel);\r\nreturn 0;\r\n}\r\nvoid kvmppc_mmu_map(struct kvm_vcpu *vcpu, u64 eaddr, gpa_t gpaddr,\r\nunsigned int index)\r\n{\r\nstruct kvmppc_vcpu_e500 *vcpu_e500 = to_e500(vcpu);\r\nstruct tlbe_priv *priv;\r\nstruct kvm_book3e_206_tlb_entry *gtlbe, stlbe;\r\nint tlbsel = tlbsel_of(index);\r\nint esel = esel_of(index);\r\ngtlbe = get_entry(vcpu_e500, tlbsel, esel);\r\nswitch (tlbsel) {\r\ncase 0:\r\npriv = &vcpu_e500->gtlb_priv[tlbsel][esel];\r\nif (!(priv->ref.flags & E500_TLB_VALID)) {\r\nkvmppc_e500_tlb0_map(vcpu_e500, esel, &stlbe);\r\n} else {\r\nkvmppc_e500_setup_stlbe(vcpu, gtlbe, BOOK3E_PAGESZ_4K,\r\n&priv->ref, eaddr, &stlbe);\r\nwrite_stlbe(vcpu_e500, gtlbe, &stlbe, 0, 0);\r\n}\r\nbreak;\r\ncase 1: {\r\ngfn_t gfn = gpaddr >> PAGE_SHIFT;\r\nkvmppc_e500_tlb1_map(vcpu_e500, eaddr, gfn, gtlbe, &stlbe,\r\nesel);\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nint kvm_unmap_hva(struct kvm *kvm, unsigned long hva)\r\n{\r\ntrace_kvm_unmap_hva(hva);\r\nkvm_flush_remote_tlbs(kvm);\r\nreturn 0;\r\n}\r\nint kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end)\r\n{\r\nkvm_unmap_hva(kvm, start);\r\nreturn 0;\r\n}\r\nint kvm_age_hva(struct kvm *kvm, unsigned long hva)\r\n{\r\nreturn 0;\r\n}\r\nint kvm_test_age_hva(struct kvm *kvm, unsigned long hva)\r\n{\r\nreturn 0;\r\n}\r\nvoid kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)\r\n{\r\nkvm_unmap_hva(kvm, hva);\r\n}\r\nint e500_mmu_host_init(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nhost_tlb_params[0].entries = mfspr(SPRN_TLB0CFG) & TLBnCFG_N_ENTRY;\r\nhost_tlb_params[1].entries = mfspr(SPRN_TLB1CFG) & TLBnCFG_N_ENTRY;\r\nif (host_tlb_params[0].entries == 0 ||\r\nhost_tlb_params[1].entries == 0) {\r\npr_err("%s: need to know host tlb size\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nhost_tlb_params[0].ways = (mfspr(SPRN_TLB0CFG) & TLBnCFG_ASSOC) >>\r\nTLBnCFG_ASSOC_SHIFT;\r\nhost_tlb_params[1].ways = host_tlb_params[1].entries;\r\nif (!is_power_of_2(host_tlb_params[0].entries) ||\r\n!is_power_of_2(host_tlb_params[0].ways) ||\r\nhost_tlb_params[0].entries < host_tlb_params[0].ways ||\r\nhost_tlb_params[0].ways == 0) {\r\npr_err("%s: bad tlb0 host config: %u entries %u ways\n",\r\n__func__, host_tlb_params[0].entries,\r\nhost_tlb_params[0].ways);\r\nreturn -ENODEV;\r\n}\r\nhost_tlb_params[0].sets =\r\nhost_tlb_params[0].entries / host_tlb_params[0].ways;\r\nhost_tlb_params[1].sets = 1;\r\nvcpu_e500->h2g_tlb1_rmap = kzalloc(sizeof(unsigned int) *\r\nhost_tlb_params[1].entries,\r\nGFP_KERNEL);\r\nif (!vcpu_e500->h2g_tlb1_rmap)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid e500_mmu_host_uninit(struct kvmppc_vcpu_e500 *vcpu_e500)\r\n{\r\nkfree(vcpu_e500->h2g_tlb1_rmap);\r\n}
