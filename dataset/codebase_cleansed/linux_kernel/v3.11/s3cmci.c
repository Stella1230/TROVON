static void dbg_dumpregs(struct s3cmci_host *host, char *prefix)\r\n{\r\nu32 con, pre, cmdarg, cmdcon, cmdsta, r0, r1, r2, r3, timer, bsize;\r\nu32 datcon, datcnt, datsta, fsta, imask;\r\ncon = readl(host->base + S3C2410_SDICON);\r\npre = readl(host->base + S3C2410_SDIPRE);\r\ncmdarg = readl(host->base + S3C2410_SDICMDARG);\r\ncmdcon = readl(host->base + S3C2410_SDICMDCON);\r\ncmdsta = readl(host->base + S3C2410_SDICMDSTAT);\r\nr0 = readl(host->base + S3C2410_SDIRSP0);\r\nr1 = readl(host->base + S3C2410_SDIRSP1);\r\nr2 = readl(host->base + S3C2410_SDIRSP2);\r\nr3 = readl(host->base + S3C2410_SDIRSP3);\r\ntimer = readl(host->base + S3C2410_SDITIMER);\r\nbsize = readl(host->base + S3C2410_SDIBSIZE);\r\ndatcon = readl(host->base + S3C2410_SDIDCON);\r\ndatcnt = readl(host->base + S3C2410_SDIDCNT);\r\ndatsta = readl(host->base + S3C2410_SDIDSTA);\r\nfsta = readl(host->base + S3C2410_SDIFSTA);\r\nimask = readl(host->base + host->sdiimsk);\r\ndbg(host, dbg_debug, "%s CON:[%08x] PRE:[%08x] TMR:[%08x]\n",\r\nprefix, con, pre, timer);\r\ndbg(host, dbg_debug, "%s CCON:[%08x] CARG:[%08x] CSTA:[%08x]\n",\r\nprefix, cmdcon, cmdarg, cmdsta);\r\ndbg(host, dbg_debug, "%s DCON:[%08x] FSTA:[%08x]"\r\n" DSTA:[%08x] DCNT:[%08x]\n",\r\nprefix, datcon, fsta, datsta, datcnt);\r\ndbg(host, dbg_debug, "%s R0:[%08x] R1:[%08x]"\r\n" R2:[%08x] R3:[%08x]\n",\r\nprefix, r0, r1, r2, r3);\r\n}\r\nstatic void prepare_dbgmsg(struct s3cmci_host *host, struct mmc_command *cmd,\r\nint stop)\r\n{\r\nsnprintf(host->dbgmsg_cmd, 300,\r\n"#%u%s op:%i arg:0x%08x flags:0x08%x retries:%u",\r\nhost->ccnt, (stop ? " (STOP)" : ""),\r\ncmd->opcode, cmd->arg, cmd->flags, cmd->retries);\r\nif (cmd->data) {\r\nsnprintf(host->dbgmsg_dat, 300,\r\n"#%u bsize:%u blocks:%u bytes:%u",\r\nhost->dcnt, cmd->data->blksz,\r\ncmd->data->blocks,\r\ncmd->data->blocks * cmd->data->blksz);\r\n} else {\r\nhost->dbgmsg_dat[0] = '\0';\r\n}\r\n}\r\nstatic void dbg_dumpcmd(struct s3cmci_host *host, struct mmc_command *cmd,\r\nint fail)\r\n{\r\nunsigned int dbglvl = fail ? dbg_fail : dbg_debug;\r\nif (!cmd)\r\nreturn;\r\nif (cmd->error == 0) {\r\ndbg(host, dbglvl, "CMD[OK] %s R0:0x%08x\n",\r\nhost->dbgmsg_cmd, cmd->resp[0]);\r\n} else {\r\ndbg(host, dbglvl, "CMD[ERR %i] %s Status:%s\n",\r\ncmd->error, host->dbgmsg_cmd, host->status);\r\n}\r\nif (!cmd->data)\r\nreturn;\r\nif (cmd->data->error == 0) {\r\ndbg(host, dbglvl, "DAT[OK] %s\n", host->dbgmsg_dat);\r\n} else {\r\ndbg(host, dbglvl, "DAT[ERR %i] %s DCNT:0x%08x\n",\r\ncmd->data->error, host->dbgmsg_dat,\r\nreadl(host->base + S3C2410_SDIDCNT));\r\n}\r\n}\r\nstatic void dbg_dumpcmd(struct s3cmci_host *host,\r\nstruct mmc_command *cmd, int fail) { }\r\nstatic void prepare_dbgmsg(struct s3cmci_host *host, struct mmc_command *cmd,\r\nint stop) { }\r\nstatic void dbg_dumpregs(struct s3cmci_host *host, char *prefix) { }\r\nstatic inline bool s3cmci_host_usedma(struct s3cmci_host *host)\r\n{\r\n#ifdef CONFIG_MMC_S3C_PIO\r\nreturn false;\r\n#elif defined(CONFIG_MMC_S3C_DMA)\r\nreturn true;\r\n#else\r\nreturn host->dodma;\r\n#endif\r\n}\r\nstatic inline bool s3cmci_host_canpio(void)\r\n{\r\n#ifdef CONFIG_MMC_S3C_PIO\r\nreturn true;\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nstatic inline u32 enable_imask(struct s3cmci_host *host, u32 imask)\r\n{\r\nu32 newmask;\r\nnewmask = readl(host->base + host->sdiimsk);\r\nnewmask |= imask;\r\nwritel(newmask, host->base + host->sdiimsk);\r\nreturn newmask;\r\n}\r\nstatic inline u32 disable_imask(struct s3cmci_host *host, u32 imask)\r\n{\r\nu32 newmask;\r\nnewmask = readl(host->base + host->sdiimsk);\r\nnewmask &= ~imask;\r\nwritel(newmask, host->base + host->sdiimsk);\r\nreturn newmask;\r\n}\r\nstatic inline void clear_imask(struct s3cmci_host *host)\r\n{\r\nu32 mask = readl(host->base + host->sdiimsk);\r\nmask &= S3C2410_SDIIMSK_SDIOIRQ;\r\nwritel(mask, host->base + host->sdiimsk);\r\n}\r\nstatic void s3cmci_check_sdio_irq(struct s3cmci_host *host)\r\n{\r\nif (host->sdio_irqen) {\r\nif (gpio_get_value(S3C2410_GPE(8)) == 0) {\r\npr_debug("%s: signalling irq\n", __func__);\r\nmmc_signal_sdio_irq(host->mmc);\r\n}\r\n}\r\n}\r\nstatic inline int get_data_buffer(struct s3cmci_host *host,\r\nu32 *bytes, u32 **pointer)\r\n{\r\nstruct scatterlist *sg;\r\nif (host->pio_active == XFER_NONE)\r\nreturn -EINVAL;\r\nif ((!host->mrq) || (!host->mrq->data))\r\nreturn -EINVAL;\r\nif (host->pio_sgptr >= host->mrq->data->sg_len) {\r\ndbg(host, dbg_debug, "no more buffers (%i/%i)\n",\r\nhost->pio_sgptr, host->mrq->data->sg_len);\r\nreturn -EBUSY;\r\n}\r\nsg = &host->mrq->data->sg[host->pio_sgptr];\r\n*bytes = sg->length;\r\n*pointer = sg_virt(sg);\r\nhost->pio_sgptr++;\r\ndbg(host, dbg_sg, "new buffer (%i/%i)\n",\r\nhost->pio_sgptr, host->mrq->data->sg_len);\r\nreturn 0;\r\n}\r\nstatic inline u32 fifo_count(struct s3cmci_host *host)\r\n{\r\nu32 fifostat = readl(host->base + S3C2410_SDIFSTA);\r\nfifostat &= S3C2410_SDIFSTA_COUNTMASK;\r\nreturn fifostat;\r\n}\r\nstatic inline u32 fifo_free(struct s3cmci_host *host)\r\n{\r\nu32 fifostat = readl(host->base + S3C2410_SDIFSTA);\r\nfifostat &= S3C2410_SDIFSTA_COUNTMASK;\r\nreturn 63 - fifostat;\r\n}\r\nstatic void s3cmci_enable_irq(struct s3cmci_host *host, bool more)\r\n{\r\nunsigned long flags;\r\nbool enable = false;\r\nlocal_irq_save(flags);\r\nhost->irq_enabled = more;\r\nhost->irq_disabled = false;\r\nenable = more | host->sdio_irqen;\r\nif (host->irq_state != enable) {\r\nhost->irq_state = enable;\r\nif (enable)\r\nenable_irq(host->irq);\r\nelse\r\ndisable_irq(host->irq);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void s3cmci_disable_irq(struct s3cmci_host *host, bool transfer)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nhost->irq_disabled = transfer;\r\nif (transfer && host->irq_state) {\r\nhost->irq_state = false;\r\ndisable_irq(host->irq);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void do_pio_read(struct s3cmci_host *host)\r\n{\r\nint res;\r\nu32 fifo;\r\nu32 *ptr;\r\nu32 fifo_words;\r\nvoid __iomem *from_ptr;\r\nwritel(host->prescaler, host->base + S3C2410_SDIPRE);\r\nfrom_ptr = host->base + host->sdidata;\r\nwhile ((fifo = fifo_count(host))) {\r\nif (!host->pio_bytes) {\r\nres = get_data_buffer(host, &host->pio_bytes,\r\n&host->pio_ptr);\r\nif (res) {\r\nhost->pio_active = XFER_NONE;\r\nhost->complete_what = COMPLETION_FINALIZE;\r\ndbg(host, dbg_pio, "pio_read(): "\r\n"complete (no more data).\n");\r\nreturn;\r\n}\r\ndbg(host, dbg_pio,\r\n"pio_read(): new target: [%i]@[%p]\n",\r\nhost->pio_bytes, host->pio_ptr);\r\n}\r\ndbg(host, dbg_pio,\r\n"pio_read(): fifo:[%02i] buffer:[%03i] dcnt:[%08X]\n",\r\nfifo, host->pio_bytes,\r\nreadl(host->base + S3C2410_SDIDCNT));\r\nif (fifo >= host->pio_bytes)\r\nfifo = host->pio_bytes;\r\nelse\r\nfifo -= fifo & 3;\r\nhost->pio_bytes -= fifo;\r\nhost->pio_count += fifo;\r\nfifo_words = fifo >> 2;\r\nptr = host->pio_ptr;\r\nwhile (fifo_words--)\r\n*ptr++ = readl(from_ptr);\r\nhost->pio_ptr = ptr;\r\nif (fifo & 3) {\r\nu32 n = fifo & 3;\r\nu32 data = readl(from_ptr);\r\nu8 *p = (u8 *)host->pio_ptr;\r\nwhile (n--) {\r\n*p++ = data;\r\ndata >>= 8;\r\n}\r\n}\r\n}\r\nif (!host->pio_bytes) {\r\nres = get_data_buffer(host, &host->pio_bytes, &host->pio_ptr);\r\nif (res) {\r\ndbg(host, dbg_pio,\r\n"pio_read(): complete (no more buffers).\n");\r\nhost->pio_active = XFER_NONE;\r\nhost->complete_what = COMPLETION_FINALIZE;\r\nreturn;\r\n}\r\n}\r\nenable_imask(host,\r\nS3C2410_SDIIMSK_RXFIFOHALF | S3C2410_SDIIMSK_RXFIFOLAST);\r\n}\r\nstatic void do_pio_write(struct s3cmci_host *host)\r\n{\r\nvoid __iomem *to_ptr;\r\nint res;\r\nu32 fifo;\r\nu32 *ptr;\r\nto_ptr = host->base + host->sdidata;\r\nwhile ((fifo = fifo_free(host)) > 3) {\r\nif (!host->pio_bytes) {\r\nres = get_data_buffer(host, &host->pio_bytes,\r\n&host->pio_ptr);\r\nif (res) {\r\ndbg(host, dbg_pio,\r\n"pio_write(): complete (no more data).\n");\r\nhost->pio_active = XFER_NONE;\r\nreturn;\r\n}\r\ndbg(host, dbg_pio,\r\n"pio_write(): new source: [%i]@[%p]\n",\r\nhost->pio_bytes, host->pio_ptr);\r\n}\r\nif (fifo >= host->pio_bytes)\r\nfifo = host->pio_bytes;\r\nelse\r\nfifo -= fifo & 3;\r\nhost->pio_bytes -= fifo;\r\nhost->pio_count += fifo;\r\nfifo = (fifo + 3) >> 2;\r\nptr = host->pio_ptr;\r\nwhile (fifo--)\r\nwritel(*ptr++, to_ptr);\r\nhost->pio_ptr = ptr;\r\n}\r\nenable_imask(host, S3C2410_SDIIMSK_TXFIFOHALF);\r\n}\r\nstatic void pio_tasklet(unsigned long data)\r\n{\r\nstruct s3cmci_host *host = (struct s3cmci_host *) data;\r\ns3cmci_disable_irq(host, true);\r\nif (host->pio_active == XFER_WRITE)\r\ndo_pio_write(host);\r\nif (host->pio_active == XFER_READ)\r\ndo_pio_read(host);\r\nif (host->complete_what == COMPLETION_FINALIZE) {\r\nclear_imask(host);\r\nif (host->pio_active != XFER_NONE) {\r\ndbg(host, dbg_err, "unfinished %s "\r\n"- pio_count:[%u] pio_bytes:[%u]\n",\r\n(host->pio_active == XFER_READ) ? "read" : "write",\r\nhost->pio_count, host->pio_bytes);\r\nif (host->mrq->data)\r\nhost->mrq->data->error = -EINVAL;\r\n}\r\ns3cmci_enable_irq(host, false);\r\nfinalize_request(host);\r\n} else\r\ns3cmci_enable_irq(host, true);\r\n}\r\nstatic irqreturn_t s3cmci_irq(int irq, void *dev_id)\r\n{\r\nstruct s3cmci_host *host = dev_id;\r\nstruct mmc_command *cmd;\r\nu32 mci_csta, mci_dsta, mci_fsta, mci_dcnt, mci_imsk;\r\nu32 mci_cclear = 0, mci_dclear;\r\nunsigned long iflags;\r\nmci_dsta = readl(host->base + S3C2410_SDIDSTA);\r\nmci_imsk = readl(host->base + host->sdiimsk);\r\nif (mci_dsta & S3C2410_SDIDSTA_SDIOIRQDETECT) {\r\nif (mci_imsk & S3C2410_SDIIMSK_SDIOIRQ) {\r\nmci_dclear = S3C2410_SDIDSTA_SDIOIRQDETECT;\r\nwritel(mci_dclear, host->base + S3C2410_SDIDSTA);\r\nmmc_signal_sdio_irq(host->mmc);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nspin_lock_irqsave(&host->complete_lock, iflags);\r\nmci_csta = readl(host->base + S3C2410_SDICMDSTAT);\r\nmci_dcnt = readl(host->base + S3C2410_SDIDCNT);\r\nmci_fsta = readl(host->base + S3C2410_SDIFSTA);\r\nmci_dclear = 0;\r\nif ((host->complete_what == COMPLETION_NONE) ||\r\n(host->complete_what == COMPLETION_FINALIZE)) {\r\nhost->status = "nothing to complete";\r\nclear_imask(host);\r\ngoto irq_out;\r\n}\r\nif (!host->mrq) {\r\nhost->status = "no active mrq";\r\nclear_imask(host);\r\ngoto irq_out;\r\n}\r\ncmd = host->cmd_is_stop ? host->mrq->stop : host->mrq->cmd;\r\nif (!cmd) {\r\nhost->status = "no active cmd";\r\nclear_imask(host);\r\ngoto irq_out;\r\n}\r\nif (!s3cmci_host_usedma(host)) {\r\nif ((host->pio_active == XFER_WRITE) &&\r\n(mci_fsta & S3C2410_SDIFSTA_TFDET)) {\r\ndisable_imask(host, S3C2410_SDIIMSK_TXFIFOHALF);\r\ntasklet_schedule(&host->pio_tasklet);\r\nhost->status = "pio tx";\r\n}\r\nif ((host->pio_active == XFER_READ) &&\r\n(mci_fsta & S3C2410_SDIFSTA_RFDET)) {\r\ndisable_imask(host,\r\nS3C2410_SDIIMSK_RXFIFOHALF |\r\nS3C2410_SDIIMSK_RXFIFOLAST);\r\ntasklet_schedule(&host->pio_tasklet);\r\nhost->status = "pio rx";\r\n}\r\n}\r\nif (mci_csta & S3C2410_SDICMDSTAT_CMDTIMEOUT) {\r\ndbg(host, dbg_err, "CMDSTAT: error CMDTIMEOUT\n");\r\ncmd->error = -ETIMEDOUT;\r\nhost->status = "error: command timeout";\r\ngoto fail_transfer;\r\n}\r\nif (mci_csta & S3C2410_SDICMDSTAT_CMDSENT) {\r\nif (host->complete_what == COMPLETION_CMDSENT) {\r\nhost->status = "ok: command sent";\r\ngoto close_transfer;\r\n}\r\nmci_cclear |= S3C2410_SDICMDSTAT_CMDSENT;\r\n}\r\nif (mci_csta & S3C2410_SDICMDSTAT_CRCFAIL) {\r\nif (cmd->flags & MMC_RSP_CRC) {\r\nif (host->mrq->cmd->flags & MMC_RSP_136) {\r\ndbg(host, dbg_irq,\r\n"fixup: ignore CRC fail with long rsp\n");\r\n} else {\r\n}\r\n}\r\nmci_cclear |= S3C2410_SDICMDSTAT_CRCFAIL;\r\n}\r\nif (mci_csta & S3C2410_SDICMDSTAT_RSPFIN) {\r\nif (host->complete_what == COMPLETION_RSPFIN) {\r\nhost->status = "ok: command response received";\r\ngoto close_transfer;\r\n}\r\nif (host->complete_what == COMPLETION_XFERFINISH_RSPFIN)\r\nhost->complete_what = COMPLETION_XFERFINISH;\r\nmci_cclear |= S3C2410_SDICMDSTAT_RSPFIN;\r\n}\r\nif (!cmd->data)\r\ngoto clear_status_bits;\r\nif (host->is2440) {\r\nif (mci_fsta & S3C2440_SDIFSTA_FIFOFAIL) {\r\ndbg(host, dbg_err, "FIFO failure\n");\r\nhost->mrq->data->error = -EILSEQ;\r\nhost->status = "error: 2440 fifo failure";\r\ngoto fail_transfer;\r\n}\r\n} else {\r\nif (mci_dsta & S3C2410_SDIDSTA_FIFOFAIL) {\r\ndbg(host, dbg_err, "FIFO failure\n");\r\ncmd->data->error = -EILSEQ;\r\nhost->status = "error: fifo failure";\r\ngoto fail_transfer;\r\n}\r\n}\r\nif (mci_dsta & S3C2410_SDIDSTA_RXCRCFAIL) {\r\ndbg(host, dbg_err, "bad data crc (outgoing)\n");\r\ncmd->data->error = -EILSEQ;\r\nhost->status = "error: bad data crc (outgoing)";\r\ngoto fail_transfer;\r\n}\r\nif (mci_dsta & S3C2410_SDIDSTA_CRCFAIL) {\r\ndbg(host, dbg_err, "bad data crc (incoming)\n");\r\ncmd->data->error = -EILSEQ;\r\nhost->status = "error: bad data crc (incoming)";\r\ngoto fail_transfer;\r\n}\r\nif (mci_dsta & S3C2410_SDIDSTA_DATATIMEOUT) {\r\ndbg(host, dbg_err, "data timeout\n");\r\ncmd->data->error = -ETIMEDOUT;\r\nhost->status = "error: data timeout";\r\ngoto fail_transfer;\r\n}\r\nif (mci_dsta & S3C2410_SDIDSTA_XFERFINISH) {\r\nif (host->complete_what == COMPLETION_XFERFINISH) {\r\nhost->status = "ok: data transfer completed";\r\ngoto close_transfer;\r\n}\r\nif (host->complete_what == COMPLETION_XFERFINISH_RSPFIN)\r\nhost->complete_what = COMPLETION_RSPFIN;\r\nmci_dclear |= S3C2410_SDIDSTA_XFERFINISH;\r\n}\r\nclear_status_bits:\r\nwritel(mci_cclear, host->base + S3C2410_SDICMDSTAT);\r\nwritel(mci_dclear, host->base + S3C2410_SDIDSTA);\r\ngoto irq_out;\r\nfail_transfer:\r\nhost->pio_active = XFER_NONE;\r\nclose_transfer:\r\nhost->complete_what = COMPLETION_FINALIZE;\r\nclear_imask(host);\r\ntasklet_schedule(&host->pio_tasklet);\r\ngoto irq_out;\r\nirq_out:\r\ndbg(host, dbg_irq,\r\n"csta:0x%08x dsta:0x%08x fsta:0x%08x dcnt:0x%08x status:%s.\n",\r\nmci_csta, mci_dsta, mci_fsta, mci_dcnt, host->status);\r\nspin_unlock_irqrestore(&host->complete_lock, iflags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t s3cmci_irq_cd(int irq, void *dev_id)\r\n{\r\nstruct s3cmci_host *host = (struct s3cmci_host *)dev_id;\r\ndbg(host, dbg_irq, "card detect\n");\r\nmmc_detect_change(host->mmc, msecs_to_jiffies(500));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void s3cmci_dma_done_callback(struct s3c2410_dma_chan *dma_ch,\r\nvoid *buf_id, int size,\r\nenum s3c2410_dma_buffresult result)\r\n{\r\nstruct s3cmci_host *host = buf_id;\r\nunsigned long iflags;\r\nu32 mci_csta, mci_dsta, mci_fsta, mci_dcnt;\r\nmci_csta = readl(host->base + S3C2410_SDICMDSTAT);\r\nmci_dsta = readl(host->base + S3C2410_SDIDSTA);\r\nmci_fsta = readl(host->base + S3C2410_SDIFSTA);\r\nmci_dcnt = readl(host->base + S3C2410_SDIDCNT);\r\nBUG_ON(!host->mrq);\r\nBUG_ON(!host->mrq->data);\r\nBUG_ON(!host->dmatogo);\r\nspin_lock_irqsave(&host->complete_lock, iflags);\r\nif (result != S3C2410_RES_OK) {\r\ndbg(host, dbg_fail, "DMA FAILED: csta=0x%08x dsta=0x%08x "\r\n"fsta=0x%08x dcnt:0x%08x result:0x%08x toGo:%u\n",\r\nmci_csta, mci_dsta, mci_fsta,\r\nmci_dcnt, result, host->dmatogo);\r\ngoto fail_request;\r\n}\r\nhost->dmatogo--;\r\nif (host->dmatogo) {\r\ndbg(host, dbg_dma, "DMA DONE Size:%i DSTA:[%08x] "\r\n"DCNT:[%08x] toGo:%u\n",\r\nsize, mci_dsta, mci_dcnt, host->dmatogo);\r\ngoto out;\r\n}\r\ndbg(host, dbg_dma, "DMA FINISHED Size:%i DSTA:%08x DCNT:%08x\n",\r\nsize, mci_dsta, mci_dcnt);\r\nhost->dma_complete = 1;\r\nhost->complete_what = COMPLETION_FINALIZE;\r\nout:\r\ntasklet_schedule(&host->pio_tasklet);\r\nspin_unlock_irqrestore(&host->complete_lock, iflags);\r\nreturn;\r\nfail_request:\r\nhost->mrq->data->error = -EINVAL;\r\nhost->complete_what = COMPLETION_FINALIZE;\r\nclear_imask(host);\r\ngoto out;\r\n}\r\nstatic void finalize_request(struct s3cmci_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_command *cmd;\r\nint debug_as_failure = 0;\r\nif (host->complete_what != COMPLETION_FINALIZE)\r\nreturn;\r\nif (!mrq)\r\nreturn;\r\ncmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;\r\nif (cmd->data && (cmd->error == 0) &&\r\n(cmd->data->error == 0)) {\r\nif (s3cmci_host_usedma(host) && (!host->dma_complete)) {\r\ndbg(host, dbg_dma, "DMA Missing (%d)!\n",\r\nhost->dma_complete);\r\nreturn;\r\n}\r\n}\r\ncmd->resp[0] = readl(host->base + S3C2410_SDIRSP0);\r\ncmd->resp[1] = readl(host->base + S3C2410_SDIRSP1);\r\ncmd->resp[2] = readl(host->base + S3C2410_SDIRSP2);\r\ncmd->resp[3] = readl(host->base + S3C2410_SDIRSP3);\r\nwritel(host->prescaler, host->base + S3C2410_SDIPRE);\r\nif (cmd->error)\r\ndebug_as_failure = 1;\r\nif (cmd->data && cmd->data->error)\r\ndebug_as_failure = 1;\r\ndbg_dumpcmd(host, cmd, debug_as_failure);\r\nwritel(0, host->base + S3C2410_SDICMDARG);\r\nwritel(S3C2410_SDIDCON_STOP, host->base + S3C2410_SDIDCON);\r\nwritel(0, host->base + S3C2410_SDICMDCON);\r\nclear_imask(host);\r\nif (cmd->data && cmd->error)\r\ncmd->data->error = cmd->error;\r\nif (cmd->data && cmd->data->stop && (!host->cmd_is_stop)) {\r\nhost->cmd_is_stop = 1;\r\ns3cmci_send_request(host->mmc);\r\nreturn;\r\n}\r\nif (!mrq->data)\r\ngoto request_done;\r\nif (mrq->data->error == 0) {\r\nmrq->data->bytes_xfered =\r\n(mrq->data->blocks * mrq->data->blksz);\r\n} else {\r\nmrq->data->bytes_xfered = 0;\r\n}\r\nif (mrq->data->error != 0) {\r\nif (s3cmci_host_usedma(host))\r\ns3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);\r\nif (host->is2440) {\r\nwritel(S3C2440_SDIFSTA_FIFORESET |\r\nS3C2440_SDIFSTA_FIFOFAIL,\r\nhost->base + S3C2410_SDIFSTA);\r\n} else {\r\nu32 mci_con;\r\nmci_con = readl(host->base + S3C2410_SDICON);\r\nmci_con |= S3C2410_SDICON_FIFORESET;\r\nwritel(mci_con, host->base + S3C2410_SDICON);\r\n}\r\n}\r\nrequest_done:\r\nhost->complete_what = COMPLETION_NONE;\r\nhost->mrq = NULL;\r\ns3cmci_check_sdio_irq(host);\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic void s3cmci_dma_setup(struct s3cmci_host *host,\r\nenum dma_data_direction source)\r\n{\r\nstatic enum dma_data_direction last_source = -1;\r\nstatic int setup_ok;\r\nif (last_source == source)\r\nreturn;\r\nlast_source = source;\r\ns3c2410_dma_devconfig(host->dma, source,\r\nhost->mem->start + host->sdidata);\r\nif (!setup_ok) {\r\ns3c2410_dma_config(host->dma, 4);\r\ns3c2410_dma_set_buffdone_fn(host->dma,\r\ns3cmci_dma_done_callback);\r\ns3c2410_dma_setflags(host->dma, S3C2410_DMAF_AUTOSTART);\r\nsetup_ok = 1;\r\n}\r\n}\r\nstatic void s3cmci_send_command(struct s3cmci_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nu32 ccon, imsk;\r\nimsk = S3C2410_SDIIMSK_CRCSTATUS | S3C2410_SDIIMSK_CMDTIMEOUT |\r\nS3C2410_SDIIMSK_RESPONSEND | S3C2410_SDIIMSK_CMDSENT |\r\nS3C2410_SDIIMSK_RESPONSECRC;\r\nenable_imask(host, imsk);\r\nif (cmd->data)\r\nhost->complete_what = COMPLETION_XFERFINISH_RSPFIN;\r\nelse if (cmd->flags & MMC_RSP_PRESENT)\r\nhost->complete_what = COMPLETION_RSPFIN;\r\nelse\r\nhost->complete_what = COMPLETION_CMDSENT;\r\nwritel(cmd->arg, host->base + S3C2410_SDICMDARG);\r\nccon = cmd->opcode & S3C2410_SDICMDCON_INDEX;\r\nccon |= S3C2410_SDICMDCON_SENDERHOST | S3C2410_SDICMDCON_CMDSTART;\r\nif (cmd->flags & MMC_RSP_PRESENT)\r\nccon |= S3C2410_SDICMDCON_WAITRSP;\r\nif (cmd->flags & MMC_RSP_136)\r\nccon |= S3C2410_SDICMDCON_LONGRSP;\r\nwritel(ccon, host->base + S3C2410_SDICMDCON);\r\n}\r\nstatic int s3cmci_setup_data(struct s3cmci_host *host, struct mmc_data *data)\r\n{\r\nu32 dcon, imsk, stoptries = 3;\r\nif (!data) {\r\nwritel(0, host->base + S3C2410_SDIDCON);\r\nreturn 0;\r\n}\r\nif ((data->blksz & 3) != 0) {\r\nif (data->blocks > 1) {\r\npr_warning("%s: can't do non-word sized block transfers (blksz %d)\n", __func__, data->blksz);\r\nreturn -EINVAL;\r\n}\r\n}\r\nwhile (readl(host->base + S3C2410_SDIDSTA) &\r\n(S3C2410_SDIDSTA_TXDATAON | S3C2410_SDIDSTA_RXDATAON)) {\r\ndbg(host, dbg_err,\r\n"mci_setup_data() transfer stillin progress.\n");\r\nwritel(S3C2410_SDIDCON_STOP, host->base + S3C2410_SDIDCON);\r\ns3cmci_reset(host);\r\nif ((stoptries--) == 0) {\r\ndbg_dumpregs(host, "DRF");\r\nreturn -EINVAL;\r\n}\r\n}\r\ndcon = data->blocks & S3C2410_SDIDCON_BLKNUM_MASK;\r\nif (s3cmci_host_usedma(host))\r\ndcon |= S3C2410_SDIDCON_DMAEN;\r\nif (host->bus_width == MMC_BUS_WIDTH_4)\r\ndcon |= S3C2410_SDIDCON_WIDEBUS;\r\nif (!(data->flags & MMC_DATA_STREAM))\r\ndcon |= S3C2410_SDIDCON_BLOCKMODE;\r\nif (data->flags & MMC_DATA_WRITE) {\r\ndcon |= S3C2410_SDIDCON_TXAFTERRESP;\r\ndcon |= S3C2410_SDIDCON_XFER_TXSTART;\r\n}\r\nif (data->flags & MMC_DATA_READ) {\r\ndcon |= S3C2410_SDIDCON_RXAFTERCMD;\r\ndcon |= S3C2410_SDIDCON_XFER_RXSTART;\r\n}\r\nif (host->is2440) {\r\ndcon |= S3C2440_SDIDCON_DS_WORD;\r\ndcon |= S3C2440_SDIDCON_DATSTART;\r\n}\r\nwritel(dcon, host->base + S3C2410_SDIDCON);\r\nwritel(data->blksz, host->base + S3C2410_SDIBSIZE);\r\nimsk = S3C2410_SDIIMSK_FIFOFAIL | S3C2410_SDIIMSK_DATACRC |\r\nS3C2410_SDIIMSK_DATATIMEOUT | S3C2410_SDIIMSK_DATAFINISH;\r\nenable_imask(host, imsk);\r\nif (host->is2440) {\r\nwritel(0x007FFFFF, host->base + S3C2410_SDITIMER);\r\n} else {\r\nwritel(0x0000FFFF, host->base + S3C2410_SDITIMER);\r\nif (data->flags & MMC_DATA_READ)\r\nwritel(0xFF, host->base + S3C2410_SDIPRE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3cmci_prepare_pio(struct s3cmci_host *host, struct mmc_data *data)\r\n{\r\nint rw = (data->flags & MMC_DATA_WRITE) ? 1 : 0;\r\nBUG_ON((data->flags & BOTH_DIR) == BOTH_DIR);\r\nhost->pio_sgptr = 0;\r\nhost->pio_bytes = 0;\r\nhost->pio_count = 0;\r\nhost->pio_active = rw ? XFER_WRITE : XFER_READ;\r\nif (rw) {\r\ndo_pio_write(host);\r\nenable_imask(host, S3C2410_SDIIMSK_TXFIFOHALF);\r\n} else {\r\nenable_imask(host, S3C2410_SDIIMSK_RXFIFOHALF\r\n| S3C2410_SDIIMSK_RXFIFOLAST);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3cmci_prepare_dma(struct s3cmci_host *host, struct mmc_data *data)\r\n{\r\nint dma_len, i;\r\nint rw = data->flags & MMC_DATA_WRITE;\r\nBUG_ON((data->flags & BOTH_DIR) == BOTH_DIR);\r\ns3cmci_dma_setup(host, rw ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\ns3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);\r\ndma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\nrw ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nif (dma_len == 0)\r\nreturn -ENOMEM;\r\nhost->dma_complete = 0;\r\nhost->dmatogo = dma_len;\r\nfor (i = 0; i < dma_len; i++) {\r\nint res;\r\ndbg(host, dbg_dma, "enqueue %i: %08x@%u\n", i,\r\nsg_dma_address(&data->sg[i]),\r\nsg_dma_len(&data->sg[i]));\r\nres = s3c2410_dma_enqueue(host->dma, host,\r\nsg_dma_address(&data->sg[i]),\r\nsg_dma_len(&data->sg[i]));\r\nif (res) {\r\ns3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);\r\nreturn -EBUSY;\r\n}\r\n}\r\ns3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_START);\r\nreturn 0;\r\n}\r\nstatic void s3cmci_send_request(struct mmc_host *mmc)\r\n{\r\nstruct s3cmci_host *host = mmc_priv(mmc);\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_command *cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;\r\nhost->ccnt++;\r\nprepare_dbgmsg(host, cmd, host->cmd_is_stop);\r\nwritel(0xFFFFFFFF, host->base + S3C2410_SDICMDSTAT);\r\nwritel(0xFFFFFFFF, host->base + S3C2410_SDIDSTA);\r\nwritel(0xFFFFFFFF, host->base + S3C2410_SDIFSTA);\r\nif (cmd->data) {\r\nint res = s3cmci_setup_data(host, cmd->data);\r\nhost->dcnt++;\r\nif (res) {\r\ndbg(host, dbg_err, "setup data error %d\n", res);\r\ncmd->error = res;\r\ncmd->data->error = res;\r\nmmc_request_done(mmc, mrq);\r\nreturn;\r\n}\r\nif (s3cmci_host_usedma(host))\r\nres = s3cmci_prepare_dma(host, cmd->data);\r\nelse\r\nres = s3cmci_prepare_pio(host, cmd->data);\r\nif (res) {\r\ndbg(host, dbg_err, "data prepare error %d\n", res);\r\ncmd->error = res;\r\ncmd->data->error = res;\r\nmmc_request_done(mmc, mrq);\r\nreturn;\r\n}\r\n}\r\ns3cmci_send_command(host, cmd);\r\ns3cmci_enable_irq(host, true);\r\n}\r\nstatic int s3cmci_card_present(struct mmc_host *mmc)\r\n{\r\nstruct s3cmci_host *host = mmc_priv(mmc);\r\nstruct s3c24xx_mci_pdata *pdata = host->pdata;\r\nint ret;\r\nif (pdata->no_detect)\r\nreturn -ENOSYS;\r\nret = gpio_get_value(pdata->gpio_detect) ? 0 : 1;\r\nreturn ret ^ pdata->detect_invert;\r\n}\r\nstatic void s3cmci_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct s3cmci_host *host = mmc_priv(mmc);\r\nhost->status = "mmc request";\r\nhost->cmd_is_stop = 0;\r\nhost->mrq = mrq;\r\nif (s3cmci_card_present(mmc) == 0) {\r\ndbg(host, dbg_err, "%s: no medium present\n", __func__);\r\nhost->mrq->cmd->error = -ENOMEDIUM;\r\nmmc_request_done(mmc, mrq);\r\n} else\r\ns3cmci_send_request(mmc);\r\n}\r\nstatic void s3cmci_set_clk(struct s3cmci_host *host, struct mmc_ios *ios)\r\n{\r\nu32 mci_psc;\r\nfor (mci_psc = 0; mci_psc < 255; mci_psc++) {\r\nhost->real_rate = host->clk_rate / (host->clk_div*(mci_psc+1));\r\nif (host->real_rate <= ios->clock)\r\nbreak;\r\n}\r\nif (mci_psc > 255)\r\nmci_psc = 255;\r\nhost->prescaler = mci_psc;\r\nwritel(host->prescaler, host->base + S3C2410_SDIPRE);\r\nif (ios->clock == 0)\r\nhost->real_rate = 0;\r\n}\r\nstatic void s3cmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct s3cmci_host *host = mmc_priv(mmc);\r\nu32 mci_con;\r\nmci_con = readl(host->base + S3C2410_SDICON);\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_ON:\r\ncase MMC_POWER_UP:\r\ns3c_gpio_cfgall_range(S3C2410_GPE(5), 6, S3C_GPIO_SFN(2),\r\nS3C_GPIO_PULL_NONE);\r\nif (host->pdata->set_power)\r\nhost->pdata->set_power(ios->power_mode, ios->vdd);\r\nif (!host->is2440)\r\nmci_con |= S3C2410_SDICON_FIFORESET;\r\nbreak;\r\ncase MMC_POWER_OFF:\r\ndefault:\r\ngpio_direction_output(S3C2410_GPE(5), 0);\r\nif (host->is2440)\r\nmci_con |= S3C2440_SDICON_SDRESET;\r\nif (host->pdata->set_power)\r\nhost->pdata->set_power(ios->power_mode, ios->vdd);\r\nbreak;\r\n}\r\ns3cmci_set_clk(host, ios);\r\nif (ios->clock)\r\nmci_con |= S3C2410_SDICON_CLOCKTYPE;\r\nelse\r\nmci_con &= ~S3C2410_SDICON_CLOCKTYPE;\r\nwritel(mci_con, host->base + S3C2410_SDICON);\r\nif ((ios->power_mode == MMC_POWER_ON) ||\r\n(ios->power_mode == MMC_POWER_UP)) {\r\ndbg(host, dbg_conf, "running at %lukHz (requested: %ukHz).\n",\r\nhost->real_rate/1000, ios->clock/1000);\r\n} else {\r\ndbg(host, dbg_conf, "powered down.\n");\r\n}\r\nhost->bus_width = ios->bus_width;\r\n}\r\nstatic void s3cmci_reset(struct s3cmci_host *host)\r\n{\r\nu32 con = readl(host->base + S3C2410_SDICON);\r\ncon |= S3C2440_SDICON_SDRESET;\r\nwritel(con, host->base + S3C2410_SDICON);\r\n}\r\nstatic int s3cmci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct s3cmci_host *host = mmc_priv(mmc);\r\nstruct s3c24xx_mci_pdata *pdata = host->pdata;\r\nint ret;\r\nif (pdata->no_wprotect)\r\nreturn 0;\r\nret = gpio_get_value(pdata->gpio_wprotect) ? 1 : 0;\r\nret ^= pdata->wprotect_invert;\r\nreturn ret;\r\n}\r\nstatic void s3cmci_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct s3cmci_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nu32 con;\r\nlocal_irq_save(flags);\r\ncon = readl(host->base + S3C2410_SDICON);\r\nhost->sdio_irqen = enable;\r\nif (enable == host->sdio_irqen)\r\ngoto same_state;\r\nif (enable) {\r\ncon |= S3C2410_SDICON_SDIOIRQ;\r\nenable_imask(host, S3C2410_SDIIMSK_SDIOIRQ);\r\nif (!host->irq_state && !host->irq_disabled) {\r\nhost->irq_state = true;\r\nenable_irq(host->irq);\r\n}\r\n} else {\r\ndisable_imask(host, S3C2410_SDIIMSK_SDIOIRQ);\r\ncon &= ~S3C2410_SDICON_SDIOIRQ;\r\nif (!host->irq_enabled && host->irq_state) {\r\ndisable_irq_nosync(host->irq);\r\nhost->irq_state = false;\r\n}\r\n}\r\nwritel(con, host->base + S3C2410_SDICON);\r\nsame_state:\r\nlocal_irq_restore(flags);\r\ns3cmci_check_sdio_irq(host);\r\n}\r\nstatic int s3cmci_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct s3cmci_host *host;\r\nstruct mmc_host *mmc;\r\nunsigned long newclk;\r\nunsigned long flags;\r\nhost = container_of(nb, struct s3cmci_host, freq_transition);\r\nnewclk = clk_get_rate(host->clk);\r\nmmc = host->mmc;\r\nif ((val == CPUFREQ_PRECHANGE && newclk > host->clk_rate) ||\r\n(val == CPUFREQ_POSTCHANGE && newclk < host->clk_rate)) {\r\nspin_lock_irqsave(&mmc->lock, flags);\r\nhost->clk_rate = newclk;\r\nif (mmc->ios.power_mode != MMC_POWER_OFF &&\r\nmmc->ios.clock != 0)\r\ns3cmci_set_clk(host, &mmc->ios);\r\nspin_unlock_irqrestore(&mmc->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int s3cmci_cpufreq_register(struct s3cmci_host *host)\r\n{\r\nhost->freq_transition.notifier_call = s3cmci_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&host->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void s3cmci_cpufreq_deregister(struct s3cmci_host *host)\r\n{\r\ncpufreq_unregister_notifier(&host->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int s3cmci_cpufreq_register(struct s3cmci_host *host)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void s3cmci_cpufreq_deregister(struct s3cmci_host *host)\r\n{\r\n}\r\nstatic int s3cmci_state_show(struct seq_file *seq, void *v)\r\n{\r\nstruct s3cmci_host *host = seq->private;\r\nseq_printf(seq, "Register base = 0x%08x\n", (u32)host->base);\r\nseq_printf(seq, "Clock rate = %ld\n", host->clk_rate);\r\nseq_printf(seq, "Prescale = %d\n", host->prescaler);\r\nseq_printf(seq, "is2440 = %d\n", host->is2440);\r\nseq_printf(seq, "IRQ = %d\n", host->irq);\r\nseq_printf(seq, "IRQ enabled = %d\n", host->irq_enabled);\r\nseq_printf(seq, "IRQ disabled = %d\n", host->irq_disabled);\r\nseq_printf(seq, "IRQ state = %d\n", host->irq_state);\r\nseq_printf(seq, "CD IRQ = %d\n", host->irq_cd);\r\nseq_printf(seq, "Do DMA = %d\n", s3cmci_host_usedma(host));\r\nseq_printf(seq, "SDIIMSK at %d\n", host->sdiimsk);\r\nseq_printf(seq, "SDIDATA at %d\n", host->sdidata);\r\nreturn 0;\r\n}\r\nstatic int s3cmci_state_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, s3cmci_state_show, inode->i_private);\r\n}\r\nstatic int s3cmci_regs_show(struct seq_file *seq, void *v)\r\n{\r\nstruct s3cmci_host *host = seq->private;\r\nstruct s3cmci_reg *rptr = debug_regs;\r\nfor (; rptr->name; rptr++)\r\nseq_printf(seq, "SDI%s\t=0x%08x\n", rptr->name,\r\nreadl(host->base + rptr->addr));\r\nseq_printf(seq, "SDIIMSK\t=0x%08x\n", readl(host->base + host->sdiimsk));\r\nreturn 0;\r\n}\r\nstatic int s3cmci_regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, s3cmci_regs_show, inode->i_private);\r\n}\r\nstatic void s3cmci_debugfs_attach(struct s3cmci_host *host)\r\n{\r\nstruct device *dev = &host->pdev->dev;\r\nhost->debug_root = debugfs_create_dir(dev_name(dev), NULL);\r\nif (IS_ERR(host->debug_root)) {\r\ndev_err(dev, "failed to create debugfs root\n");\r\nreturn;\r\n}\r\nhost->debug_state = debugfs_create_file("state", 0444,\r\nhost->debug_root, host,\r\n&s3cmci_fops_state);\r\nif (IS_ERR(host->debug_state))\r\ndev_err(dev, "failed to create debug state file\n");\r\nhost->debug_regs = debugfs_create_file("regs", 0444,\r\nhost->debug_root, host,\r\n&s3cmci_fops_regs);\r\nif (IS_ERR(host->debug_regs))\r\ndev_err(dev, "failed to create debug regs file\n");\r\n}\r\nstatic void s3cmci_debugfs_remove(struct s3cmci_host *host)\r\n{\r\ndebugfs_remove(host->debug_regs);\r\ndebugfs_remove(host->debug_state);\r\ndebugfs_remove(host->debug_root);\r\n}\r\nstatic inline void s3cmci_debugfs_attach(struct s3cmci_host *host) { }\r\nstatic inline void s3cmci_debugfs_remove(struct s3cmci_host *host) { }\r\nstatic int s3cmci_probe(struct platform_device *pdev)\r\n{\r\nstruct s3cmci_host *host;\r\nstruct mmc_host *mmc;\r\nint ret;\r\nint is2440;\r\nint i;\r\nis2440 = platform_get_device_id(pdev)->driver_data;\r\nmmc = mmc_alloc_host(sizeof(struct s3cmci_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto probe_out;\r\n}\r\nfor (i = S3C2410_GPE(5); i <= S3C2410_GPE(10); i++) {\r\nret = gpio_request(i, dev_name(&pdev->dev));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get gpio %d\n", i);\r\nfor (i--; i >= S3C2410_GPE(5); i--)\r\ngpio_free(i);\r\ngoto probe_free_host;\r\n}\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->pdev = pdev;\r\nhost->is2440 = is2440;\r\nhost->pdata = pdev->dev.platform_data;\r\nif (!host->pdata) {\r\npdev->dev.platform_data = &s3cmci_def_pdata;\r\nhost->pdata = &s3cmci_def_pdata;\r\n}\r\nspin_lock_init(&host->complete_lock);\r\ntasklet_init(&host->pio_tasklet, pio_tasklet, (unsigned long) host);\r\nif (is2440) {\r\nhost->sdiimsk = S3C2440_SDIIMSK;\r\nhost->sdidata = S3C2440_SDIDATA;\r\nhost->clk_div = 1;\r\n} else {\r\nhost->sdiimsk = S3C2410_SDIIMSK;\r\nhost->sdidata = S3C2410_SDIDATA;\r\nhost->clk_div = 2;\r\n}\r\nhost->complete_what = COMPLETION_NONE;\r\nhost->pio_active = XFER_NONE;\r\n#ifdef CONFIG_MMC_S3C_PIODMA\r\nhost->dodma = host->pdata->use_dma;\r\n#endif\r\nhost->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!host->mem) {\r\ndev_err(&pdev->dev,\r\n"failed to get io memory region resource.\n");\r\nret = -ENOENT;\r\ngoto probe_free_gpio;\r\n}\r\nhost->mem = request_mem_region(host->mem->start,\r\nresource_size(host->mem), pdev->name);\r\nif (!host->mem) {\r\ndev_err(&pdev->dev, "failed to request io memory region.\n");\r\nret = -ENOENT;\r\ngoto probe_free_gpio;\r\n}\r\nhost->base = ioremap(host->mem->start, resource_size(host->mem));\r\nif (!host->base) {\r\ndev_err(&pdev->dev, "failed to ioremap() io memory region.\n");\r\nret = -EINVAL;\r\ngoto probe_free_mem_region;\r\n}\r\nhost->irq = platform_get_irq(pdev, 0);\r\nif (host->irq == 0) {\r\ndev_err(&pdev->dev, "failed to get interrupt resource.\n");\r\nret = -EINVAL;\r\ngoto probe_iounmap;\r\n}\r\nif (request_irq(host->irq, s3cmci_irq, 0, DRIVER_NAME, host)) {\r\ndev_err(&pdev->dev, "failed to request mci interrupt.\n");\r\nret = -ENOENT;\r\ngoto probe_iounmap;\r\n}\r\ndisable_irq(host->irq);\r\nhost->irq_state = false;\r\nif (!host->pdata->no_detect) {\r\nret = gpio_request(host->pdata->gpio_detect, "s3cmci detect");\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get detect gpio\n");\r\ngoto probe_free_irq;\r\n}\r\nhost->irq_cd = gpio_to_irq(host->pdata->gpio_detect);\r\nif (host->irq_cd >= 0) {\r\nif (request_irq(host->irq_cd, s3cmci_irq_cd,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING,\r\nDRIVER_NAME, host)) {\r\ndev_err(&pdev->dev,\r\n"can't get card detect irq.\n");\r\nret = -ENOENT;\r\ngoto probe_free_gpio_cd;\r\n}\r\n} else {\r\ndev_warn(&pdev->dev,\r\n"host detect has no irq available\n");\r\ngpio_direction_input(host->pdata->gpio_detect);\r\n}\r\n} else\r\nhost->irq_cd = -1;\r\nif (!host->pdata->no_wprotect) {\r\nret = gpio_request(host->pdata->gpio_wprotect, "s3cmci wp");\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get writeprotect\n");\r\ngoto probe_free_irq_cd;\r\n}\r\ngpio_direction_input(host->pdata->gpio_wprotect);\r\n}\r\nif (s3cmci_host_usedma(host)) {\r\nhost->dma = s3c2410_dma_request(DMACH_SDI, &s3cmci_dma_client,\r\nhost);\r\nif (host->dma < 0) {\r\ndev_err(&pdev->dev, "cannot get DMA channel.\n");\r\nif (!s3cmci_host_canpio()) {\r\nret = -EBUSY;\r\ngoto probe_free_gpio_wp;\r\n} else {\r\ndev_warn(&pdev->dev, "falling back to PIO.\n");\r\nhost->dodma = 0;\r\n}\r\n}\r\n}\r\nhost->clk = clk_get(&pdev->dev, "sdi");\r\nif (IS_ERR(host->clk)) {\r\ndev_err(&pdev->dev, "failed to find clock source.\n");\r\nret = PTR_ERR(host->clk);\r\nhost->clk = NULL;\r\ngoto probe_free_dma;\r\n}\r\nret = clk_enable(host->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable clock source.\n");\r\ngoto clk_free;\r\n}\r\nhost->clk_rate = clk_get_rate(host->clk);\r\nmmc->ops = &s3cmci_ops;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\n#ifdef CONFIG_MMC_S3C_HW_SDIO_IRQ\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\r\n#else\r\nmmc->caps = MMC_CAP_4_BIT_DATA;\r\n#endif\r\nmmc->f_min = host->clk_rate / (host->clk_div * 256);\r\nmmc->f_max = host->clk_rate / host->clk_div;\r\nif (host->pdata->ocr_avail)\r\nmmc->ocr_avail = host->pdata->ocr_avail;\r\nmmc->max_blk_count = 4095;\r\nmmc->max_blk_size = 4095;\r\nmmc->max_req_size = 4095 * 512;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nmmc->max_segs = 128;\r\ndbg(host, dbg_debug,\r\n"probe: mode:%s mapped mci_base:%p irq:%u irq_cd:%u dma:%u.\n",\r\n(host->is2440?"2440":""),\r\nhost->base, host->irq, host->irq_cd, host->dma);\r\nret = s3cmci_cpufreq_register(host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register cpufreq\n");\r\ngoto free_dmabuf;\r\n}\r\nret = mmc_add_host(mmc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add mmc host.\n");\r\ngoto free_cpufreq;\r\n}\r\ns3cmci_debugfs_attach(host);\r\nplatform_set_drvdata(pdev, mmc);\r\ndev_info(&pdev->dev, "%s - using %s, %s SDIO IRQ\n", mmc_hostname(mmc),\r\ns3cmci_host_usedma(host) ? "dma" : "pio",\r\nmmc->caps & MMC_CAP_SDIO_IRQ ? "hw" : "sw");\r\nreturn 0;\r\nfree_cpufreq:\r\ns3cmci_cpufreq_deregister(host);\r\nfree_dmabuf:\r\nclk_disable(host->clk);\r\nclk_free:\r\nclk_put(host->clk);\r\nprobe_free_dma:\r\nif (s3cmci_host_usedma(host))\r\ns3c2410_dma_free(host->dma, &s3cmci_dma_client);\r\nprobe_free_gpio_wp:\r\nif (!host->pdata->no_wprotect)\r\ngpio_free(host->pdata->gpio_wprotect);\r\nprobe_free_gpio_cd:\r\nif (!host->pdata->no_detect)\r\ngpio_free(host->pdata->gpio_detect);\r\nprobe_free_irq_cd:\r\nif (host->irq_cd >= 0)\r\nfree_irq(host->irq_cd, host);\r\nprobe_free_irq:\r\nfree_irq(host->irq, host);\r\nprobe_iounmap:\r\niounmap(host->base);\r\nprobe_free_mem_region:\r\nrelease_mem_region(host->mem->start, resource_size(host->mem));\r\nprobe_free_gpio:\r\nfor (i = S3C2410_GPE(5); i <= S3C2410_GPE(10); i++)\r\ngpio_free(i);\r\nprobe_free_host:\r\nmmc_free_host(mmc);\r\nprobe_out:\r\nreturn ret;\r\n}\r\nstatic void s3cmci_shutdown(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct s3cmci_host *host = mmc_priv(mmc);\r\nif (host->irq_cd >= 0)\r\nfree_irq(host->irq_cd, host);\r\ns3cmci_debugfs_remove(host);\r\ns3cmci_cpufreq_deregister(host);\r\nmmc_remove_host(mmc);\r\nclk_disable(host->clk);\r\n}\r\nstatic int s3cmci_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct s3cmci_host *host = mmc_priv(mmc);\r\nstruct s3c24xx_mci_pdata *pd = host->pdata;\r\nint i;\r\ns3cmci_shutdown(pdev);\r\nclk_put(host->clk);\r\ntasklet_disable(&host->pio_tasklet);\r\nif (s3cmci_host_usedma(host))\r\ns3c2410_dma_free(host->dma, &s3cmci_dma_client);\r\nfree_irq(host->irq, host);\r\nif (!pd->no_wprotect)\r\ngpio_free(pd->gpio_wprotect);\r\nif (!pd->no_detect)\r\ngpio_free(pd->gpio_detect);\r\nfor (i = S3C2410_GPE(5); i <= S3C2410_GPE(10); i++)\r\ngpio_free(i);\r\niounmap(host->base);\r\nrelease_mem_region(host->mem->start, resource_size(host->mem));\r\nmmc_free_host(mmc);\r\nreturn 0;\r\n}\r\nstatic int s3cmci_suspend(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(to_platform_device(dev));\r\nreturn mmc_suspend_host(mmc);\r\n}\r\nstatic int s3cmci_resume(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(to_platform_device(dev));\r\nreturn mmc_resume_host(mmc);\r\n}
