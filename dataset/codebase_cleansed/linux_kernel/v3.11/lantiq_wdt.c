static void\r\nltq_wdt_enable(void)\r\n{\r\nunsigned long int timeout = ltq_wdt_timeout *\r\n(ltq_io_region_clk_rate / LTQ_WDT_DIVIDER) + 0x1000;\r\nif (timeout > LTQ_MAX_TIMEOUT)\r\ntimeout = LTQ_MAX_TIMEOUT;\r\nltq_w32(LTQ_WDT_PW1, ltq_wdt_membase + LTQ_WDT_CR);\r\nltq_w32(LTQ_WDT_SR_EN | LTQ_WDT_SR_PWD | LTQ_WDT_SR_CLKDIV |\r\nLTQ_WDT_PW2 | timeout, ltq_wdt_membase + LTQ_WDT_CR);\r\n}\r\nstatic void\r\nltq_wdt_disable(void)\r\n{\r\nltq_w32(LTQ_WDT_PW1, ltq_wdt_membase + LTQ_WDT_CR);\r\nltq_w32(LTQ_WDT_PW2, ltq_wdt_membase + LTQ_WDT_CR);\r\n}\r\nstatic ssize_t\r\nltq_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nltq_wdt_ok_to_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nltq_wdt_ok_to_close = 1;\r\nelse\r\nltq_wdt_ok_to_close = 0;\r\n}\r\n}\r\nltq_wdt_enable();\r\n}\r\nreturn len;\r\n}\r\nstatic long\r\nltq_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret = -ENOTTY;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nret = copy_to_user((struct watchdog_info __user *)arg, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(ltq_wdt_bootstatus, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nret = put_user(0, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nret = get_user(ltq_wdt_timeout, (int __user *)arg);\r\nif (!ret)\r\nltq_wdt_enable();\r\ncase WDIOC_GETTIMEOUT:\r\nret = put_user(ltq_wdt_timeout, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nltq_wdt_enable();\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nltq_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &ltq_wdt_in_use))\r\nreturn -EBUSY;\r\nltq_wdt_in_use = 1;\r\nltq_wdt_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int\r\nltq_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (ltq_wdt_ok_to_close)\r\nltq_wdt_disable();\r\nelse\r\npr_err("watchdog closed without warning\n");\r\nltq_wdt_ok_to_close = 0;\r\nclear_bit(0, &ltq_wdt_in_use);\r\nreturn 0;\r\n}\r\nstatic int\r\nltq_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct clk *clk;\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot obtain I/O memory region");\r\nreturn -ENOENT;\r\n}\r\nltq_wdt_membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ltq_wdt_membase))\r\nreturn PTR_ERR(ltq_wdt_membase);\r\nclk = clk_get_io();\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\nreturn -ENOENT;\r\n}\r\nltq_io_region_clk_rate = clk_get_rate(clk);\r\nclk_put(clk);\r\nif (ltq_reset_cause() == LTQ_RST_CAUSE_WDTRST)\r\nltq_wdt_bootstatus = WDIOF_CARDRESET;\r\ndev_info(&pdev->dev, "Init done\n");\r\nreturn misc_register(&ltq_wdt_miscdev);\r\n}\r\nstatic int\r\nltq_wdt_remove(struct platform_device *pdev)\r\n{\r\nmisc_deregister(&ltq_wdt_miscdev);\r\nreturn 0;\r\n}
