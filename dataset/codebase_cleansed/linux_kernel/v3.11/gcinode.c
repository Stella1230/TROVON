int nilfs_gccache_submit_read_data(struct inode *inode, sector_t blkoff,\r\nsector_t pbn, __u64 vbn,\r\nstruct buffer_head **out_bh)\r\n{\r\nstruct buffer_head *bh;\r\nint err;\r\nbh = nilfs_grab_buffer(inode, inode->i_mapping, blkoff, 0);\r\nif (unlikely(!bh))\r\nreturn -ENOMEM;\r\nif (buffer_uptodate(bh))\r\ngoto out;\r\nif (pbn == 0) {\r\nstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\r\nerr = nilfs_dat_translate(nilfs->ns_dat, vbn, &pbn);\r\nif (unlikely(err)) {\r\nbrelse(bh);\r\ngoto failed;\r\n}\r\n}\r\nlock_buffer(bh);\r\nif (buffer_uptodate(bh)) {\r\nunlock_buffer(bh);\r\ngoto out;\r\n}\r\nif (!buffer_mapped(bh)) {\r\nbh->b_bdev = inode->i_sb->s_bdev;\r\nset_buffer_mapped(bh);\r\n}\r\nbh->b_blocknr = pbn;\r\nbh->b_end_io = end_buffer_read_sync;\r\nget_bh(bh);\r\nsubmit_bh(READ, bh);\r\nif (vbn)\r\nbh->b_blocknr = vbn;\r\nout:\r\nerr = 0;\r\n*out_bh = bh;\r\nfailed:\r\nunlock_page(bh->b_page);\r\npage_cache_release(bh->b_page);\r\nreturn err;\r\n}\r\nint nilfs_gccache_submit_read_node(struct inode *inode, sector_t pbn,\r\n__u64 vbn, struct buffer_head **out_bh)\r\n{\r\nint ret;\r\nret = nilfs_btnode_submit_block(&NILFS_I(inode)->i_btnode_cache,\r\nvbn ? : pbn, pbn, READ, out_bh, &pbn);\r\nif (ret == -EEXIST)\r\nret = 0;\r\nreturn ret;\r\n}\r\nint nilfs_gccache_wait_and_mark_dirty(struct buffer_head *bh)\r\n{\r\nwait_on_buffer(bh);\r\nif (!buffer_uptodate(bh))\r\nreturn -EIO;\r\nif (buffer_dirty(bh))\r\nreturn -EEXIST;\r\nif (buffer_nilfs_node(bh) && nilfs_btree_broken_node_block(bh)) {\r\nclear_buffer_uptodate(bh);\r\nreturn -EIO;\r\n}\r\nmark_buffer_dirty(bh);\r\nreturn 0;\r\n}\r\nint nilfs_init_gcinode(struct inode *inode)\r\n{\r\nstruct nilfs_inode_info *ii = NILFS_I(inode);\r\ninode->i_mode = S_IFREG;\r\nmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\r\ninode->i_mapping->a_ops = &empty_aops;\r\ninode->i_mapping->backing_dev_info = inode->i_sb->s_bdi;\r\nii->i_flags = 0;\r\nnilfs_bmap_init_gc(ii->i_bmap);\r\nreturn 0;\r\n}\r\nvoid nilfs_remove_all_gcinodes(struct the_nilfs *nilfs)\r\n{\r\nstruct list_head *head = &nilfs->ns_gc_inodes;\r\nstruct nilfs_inode_info *ii;\r\nwhile (!list_empty(head)) {\r\nii = list_first_entry(head, struct nilfs_inode_info, i_dirty);\r\nlist_del_init(&ii->i_dirty);\r\ntruncate_inode_pages(&ii->vfs_inode.i_data, 0);\r\nnilfs_btnode_cache_clear(&ii->i_btnode_cache);\r\niput(&ii->vfs_inode);\r\n}\r\n}
