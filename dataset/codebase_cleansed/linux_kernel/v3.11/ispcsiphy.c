static void csiphy_routing_cfg_3630(struct isp_csiphy *phy,\r\nenum isp_interface_type iface,\r\nbool ccp2_strobe)\r\n{\r\nu32 reg = isp_reg_readl(\r\nphy->isp, OMAP3_ISP_IOMEM_3630_CONTROL_CAMERA_PHY_CTRL, 0);\r\nu32 shift, mode;\r\nswitch (iface) {\r\ndefault:\r\ncase ISP_INTERFACE_CCP2B_PHY1:\r\nreg &= ~OMAP3630_CONTROL_CAMERA_PHY_CTRL_CSI1_RX_SEL_PHY2;\r\nshift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY1_SHIFT;\r\nbreak;\r\ncase ISP_INTERFACE_CSI2C_PHY1:\r\nshift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY1_SHIFT;\r\nmode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_DPHY;\r\nbreak;\r\ncase ISP_INTERFACE_CCP2B_PHY2:\r\nreg |= OMAP3630_CONTROL_CAMERA_PHY_CTRL_CSI1_RX_SEL_PHY2;\r\nshift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY2_SHIFT;\r\nbreak;\r\ncase ISP_INTERFACE_CSI2A_PHY2:\r\nshift = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_PHY2_SHIFT;\r\nmode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_DPHY;\r\nbreak;\r\n}\r\nif (iface == ISP_INTERFACE_CCP2B_PHY1 ||\r\niface == ISP_INTERFACE_CCP2B_PHY2) {\r\nif (ccp2_strobe)\r\nmode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_CCP2_DATA_STROBE;\r\nelse\r\nmode = OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_CCP2_DATA_CLOCK;\r\n}\r\nreg &= ~(OMAP3630_CONTROL_CAMERA_PHY_CTRL_CAMMODE_MASK << shift);\r\nreg |= mode << shift;\r\nisp_reg_writel(phy->isp, reg,\r\nOMAP3_ISP_IOMEM_3630_CONTROL_CAMERA_PHY_CTRL, 0);\r\n}\r\nstatic void csiphy_routing_cfg_3430(struct isp_csiphy *phy, u32 iface, bool on,\r\nbool ccp2_strobe)\r\n{\r\nu32 csirxfe = OMAP343X_CONTROL_CSIRXFE_PWRDNZ\r\n| OMAP343X_CONTROL_CSIRXFE_RESET;\r\nif (iface != ISP_INTERFACE_CCP2B_PHY1)\r\nreturn;\r\nif (!on) {\r\nisp_reg_writel(phy->isp, 0,\r\nOMAP3_ISP_IOMEM_343X_CONTROL_CSIRXFE, 0);\r\nreturn;\r\n}\r\nif (ccp2_strobe)\r\ncsirxfe |= OMAP343X_CONTROL_CSIRXFE_SELFORM;\r\nisp_reg_writel(phy->isp, csirxfe,\r\nOMAP3_ISP_IOMEM_343X_CONTROL_CSIRXFE, 0);\r\n}\r\nstatic void csiphy_routing_cfg(struct isp_csiphy *phy,\r\nenum isp_interface_type iface, bool on,\r\nbool ccp2_strobe)\r\n{\r\nif (phy->isp->mmio_base[OMAP3_ISP_IOMEM_3630_CONTROL_CAMERA_PHY_CTRL]\r\n&& on)\r\nreturn csiphy_routing_cfg_3630(phy, iface, ccp2_strobe);\r\nif (phy->isp->mmio_base[OMAP3_ISP_IOMEM_343X_CONTROL_CSIRXFE])\r\nreturn csiphy_routing_cfg_3430(phy, iface, on, ccp2_strobe);\r\n}\r\nstatic void csiphy_power_autoswitch_enable(struct isp_csiphy *phy, bool enable)\r\n{\r\nisp_reg_clr_set(phy->isp, phy->cfg_regs, ISPCSI2_PHY_CFG,\r\nISPCSI2_PHY_CFG_PWR_AUTO,\r\nenable ? ISPCSI2_PHY_CFG_PWR_AUTO : 0);\r\n}\r\nstatic int csiphy_set_power(struct isp_csiphy *phy, u32 power)\r\n{\r\nu32 reg;\r\nu8 retry_count;\r\nisp_reg_clr_set(phy->isp, phy->cfg_regs, ISPCSI2_PHY_CFG,\r\nISPCSI2_PHY_CFG_PWR_CMD_MASK, power);\r\nretry_count = 0;\r\ndo {\r\nudelay(50);\r\nreg = isp_reg_readl(phy->isp, phy->cfg_regs, ISPCSI2_PHY_CFG) &\r\nISPCSI2_PHY_CFG_PWR_STATUS_MASK;\r\nif (reg != power >> 2)\r\nretry_count++;\r\n} while ((reg != power >> 2) && (retry_count < 100));\r\nif (retry_count == 100) {\r\ndev_err(phy->isp->dev, "CSI2 CIO set power failed!\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap3isp_csiphy_config(struct isp_csiphy *phy)\r\n{\r\nstruct isp_csi2_device *csi2 = phy->csi2;\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&csi2->subdev.entity);\r\nstruct isp_v4l2_subdevs_group *subdevs = pipe->external->host_priv;\r\nstruct isp_csiphy_lanes_cfg *lanes;\r\nint csi2_ddrclk_khz;\r\nunsigned int used_lanes = 0;\r\nunsigned int i;\r\nu32 reg;\r\nif (subdevs->interface == ISP_INTERFACE_CCP2B_PHY1\r\n|| subdevs->interface == ISP_INTERFACE_CCP2B_PHY2)\r\nlanes = &subdevs->bus.ccp2.lanecfg;\r\nelse\r\nlanes = &subdevs->bus.csi2.lanecfg;\r\nfor (i = 0; i < phy->num_data_lanes; i++) {\r\nif (lanes->data[i].pol > 1 || lanes->data[i].pos > 3)\r\nreturn -EINVAL;\r\nif (used_lanes & (1 << lanes->data[i].pos))\r\nreturn -EINVAL;\r\nused_lanes |= 1 << lanes->data[i].pos;\r\n}\r\nif (lanes->clk.pol > 1 || lanes->clk.pos > 3)\r\nreturn -EINVAL;\r\nif (lanes->clk.pos == 0 || used_lanes & (1 << lanes->clk.pos))\r\nreturn -EINVAL;\r\ncsiphy_routing_cfg(phy, subdevs->interface, true,\r\nsubdevs->bus.ccp2.phy_layer);\r\ncsi2_ddrclk_khz = pipe->external_rate / 1000\r\n/ (2 * hweight32(used_lanes)) * pipe->external_width;\r\nreg = isp_reg_readl(csi2->isp, phy->phy_regs, ISPCSIPHY_REG0);\r\nreg &= ~(ISPCSIPHY_REG0_THS_TERM_MASK |\r\nISPCSIPHY_REG0_THS_SETTLE_MASK);\r\nreg |= (DIV_ROUND_UP(25 * csi2_ddrclk_khz, 2000000) - 1)\r\n<< ISPCSIPHY_REG0_THS_TERM_SHIFT;\r\nreg |= (DIV_ROUND_UP(90 * csi2_ddrclk_khz, 1000000) + 3)\r\n<< ISPCSIPHY_REG0_THS_SETTLE_SHIFT;\r\nisp_reg_writel(csi2->isp, reg, phy->phy_regs, ISPCSIPHY_REG0);\r\nreg = isp_reg_readl(csi2->isp, phy->phy_regs, ISPCSIPHY_REG1);\r\nreg &= ~(ISPCSIPHY_REG1_TCLK_TERM_MASK |\r\nISPCSIPHY_REG1_TCLK_MISS_MASK |\r\nISPCSIPHY_REG1_TCLK_SETTLE_MASK);\r\nreg |= TCLK_TERM << ISPCSIPHY_REG1_TCLK_TERM_SHIFT;\r\nreg |= TCLK_MISS << ISPCSIPHY_REG1_TCLK_MISS_SHIFT;\r\nreg |= TCLK_SETTLE << ISPCSIPHY_REG1_TCLK_SETTLE_SHIFT;\r\nisp_reg_writel(csi2->isp, reg, phy->phy_regs, ISPCSIPHY_REG1);\r\nreg = isp_reg_readl(csi2->isp, phy->cfg_regs, ISPCSI2_PHY_CFG);\r\nfor (i = 0; i < phy->num_data_lanes; i++) {\r\nreg &= ~(ISPCSI2_PHY_CFG_DATA_POL_MASK(i + 1) |\r\nISPCSI2_PHY_CFG_DATA_POSITION_MASK(i + 1));\r\nreg |= (lanes->data[i].pol <<\r\nISPCSI2_PHY_CFG_DATA_POL_SHIFT(i + 1));\r\nreg |= (lanes->data[i].pos <<\r\nISPCSI2_PHY_CFG_DATA_POSITION_SHIFT(i + 1));\r\n}\r\nreg &= ~(ISPCSI2_PHY_CFG_CLOCK_POL_MASK |\r\nISPCSI2_PHY_CFG_CLOCK_POSITION_MASK);\r\nreg |= lanes->clk.pol << ISPCSI2_PHY_CFG_CLOCK_POL_SHIFT;\r\nreg |= lanes->clk.pos << ISPCSI2_PHY_CFG_CLOCK_POSITION_SHIFT;\r\nisp_reg_writel(csi2->isp, reg, phy->cfg_regs, ISPCSI2_PHY_CFG);\r\nreturn 0;\r\n}\r\nint omap3isp_csiphy_acquire(struct isp_csiphy *phy)\r\n{\r\nint rval;\r\nif (phy->vdd == NULL) {\r\ndev_err(phy->isp->dev, "Power regulator for CSI PHY not "\r\n"available\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&phy->mutex);\r\nrval = regulator_enable(phy->vdd);\r\nif (rval < 0)\r\ngoto done;\r\nrval = omap3isp_csi2_reset(phy->csi2);\r\nif (rval < 0)\r\ngoto done;\r\nrval = omap3isp_csiphy_config(phy);\r\nif (rval < 0)\r\ngoto done;\r\nrval = csiphy_set_power(phy, ISPCSI2_PHY_CFG_PWR_CMD_ON);\r\nif (rval) {\r\nregulator_disable(phy->vdd);\r\ngoto done;\r\n}\r\ncsiphy_power_autoswitch_enable(phy, true);\r\nphy->phy_in_use = 1;\r\ndone:\r\nmutex_unlock(&phy->mutex);\r\nreturn rval;\r\n}\r\nvoid omap3isp_csiphy_release(struct isp_csiphy *phy)\r\n{\r\nmutex_lock(&phy->mutex);\r\nif (phy->phy_in_use) {\r\nstruct isp_csi2_device *csi2 = phy->csi2;\r\nstruct isp_pipeline *pipe =\r\nto_isp_pipeline(&csi2->subdev.entity);\r\nstruct isp_v4l2_subdevs_group *subdevs =\r\npipe->external->host_priv;\r\ncsiphy_routing_cfg(phy, subdevs->interface, false,\r\nsubdevs->bus.ccp2.phy_layer);\r\ncsiphy_power_autoswitch_enable(phy, false);\r\ncsiphy_set_power(phy, ISPCSI2_PHY_CFG_PWR_CMD_OFF);\r\nregulator_disable(phy->vdd);\r\nphy->phy_in_use = 0;\r\n}\r\nmutex_unlock(&phy->mutex);\r\n}\r\nint omap3isp_csiphy_init(struct isp_device *isp)\r\n{\r\nstruct isp_csiphy *phy1 = &isp->isp_csiphy1;\r\nstruct isp_csiphy *phy2 = &isp->isp_csiphy2;\r\nphy2->isp = isp;\r\nphy2->csi2 = &isp->isp_csi2a;\r\nphy2->num_data_lanes = ISP_CSIPHY2_NUM_DATA_LANES;\r\nphy2->cfg_regs = OMAP3_ISP_IOMEM_CSI2A_REGS1;\r\nphy2->phy_regs = OMAP3_ISP_IOMEM_CSIPHY2;\r\nmutex_init(&phy2->mutex);\r\nif (isp->revision == ISP_REVISION_15_0) {\r\nphy1->isp = isp;\r\nphy1->csi2 = &isp->isp_csi2c;\r\nphy1->num_data_lanes = ISP_CSIPHY1_NUM_DATA_LANES;\r\nphy1->cfg_regs = OMAP3_ISP_IOMEM_CSI2C_REGS1;\r\nphy1->phy_regs = OMAP3_ISP_IOMEM_CSIPHY1;\r\nmutex_init(&phy1->mutex);\r\n}\r\nreturn 0;\r\n}
