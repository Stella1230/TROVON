static bool tcp_metric_locked(struct tcp_metrics_block *tm,\r\nenum tcp_metric_index idx)\r\n{\r\nreturn tm->tcpm_lock & (1 << idx);\r\n}\r\nstatic u32 tcp_metric_get(struct tcp_metrics_block *tm,\r\nenum tcp_metric_index idx)\r\n{\r\nreturn tm->tcpm_vals[idx];\r\n}\r\nstatic u32 tcp_metric_get_jiffies(struct tcp_metrics_block *tm,\r\nenum tcp_metric_index idx)\r\n{\r\nreturn msecs_to_jiffies(tm->tcpm_vals[idx]);\r\n}\r\nstatic void tcp_metric_set(struct tcp_metrics_block *tm,\r\nenum tcp_metric_index idx,\r\nu32 val)\r\n{\r\ntm->tcpm_vals[idx] = val;\r\n}\r\nstatic void tcp_metric_set_msecs(struct tcp_metrics_block *tm,\r\nenum tcp_metric_index idx,\r\nu32 val)\r\n{\r\ntm->tcpm_vals[idx] = jiffies_to_msecs(val);\r\n}\r\nstatic bool addr_same(const struct inetpeer_addr *a,\r\nconst struct inetpeer_addr *b)\r\n{\r\nconst struct in6_addr *a6, *b6;\r\nif (a->family != b->family)\r\nreturn false;\r\nif (a->family == AF_INET)\r\nreturn a->addr.a4 == b->addr.a4;\r\na6 = (const struct in6_addr *) &a->addr.a6[0];\r\nb6 = (const struct in6_addr *) &b->addr.a6[0];\r\nreturn ipv6_addr_equal(a6, b6);\r\n}\r\nstatic void tcpm_suck_dst(struct tcp_metrics_block *tm, struct dst_entry *dst,\r\nbool fastopen_clear)\r\n{\r\nu32 val;\r\ntm->tcpm_stamp = jiffies;\r\nval = 0;\r\nif (dst_metric_locked(dst, RTAX_RTT))\r\nval |= 1 << TCP_METRIC_RTT;\r\nif (dst_metric_locked(dst, RTAX_RTTVAR))\r\nval |= 1 << TCP_METRIC_RTTVAR;\r\nif (dst_metric_locked(dst, RTAX_SSTHRESH))\r\nval |= 1 << TCP_METRIC_SSTHRESH;\r\nif (dst_metric_locked(dst, RTAX_CWND))\r\nval |= 1 << TCP_METRIC_CWND;\r\nif (dst_metric_locked(dst, RTAX_REORDERING))\r\nval |= 1 << TCP_METRIC_REORDERING;\r\ntm->tcpm_lock = val;\r\ntm->tcpm_vals[TCP_METRIC_RTT] = dst_metric_raw(dst, RTAX_RTT);\r\ntm->tcpm_vals[TCP_METRIC_RTTVAR] = dst_metric_raw(dst, RTAX_RTTVAR);\r\ntm->tcpm_vals[TCP_METRIC_SSTHRESH] = dst_metric_raw(dst, RTAX_SSTHRESH);\r\ntm->tcpm_vals[TCP_METRIC_CWND] = dst_metric_raw(dst, RTAX_CWND);\r\ntm->tcpm_vals[TCP_METRIC_REORDERING] = dst_metric_raw(dst, RTAX_REORDERING);\r\ntm->tcpm_ts = 0;\r\ntm->tcpm_ts_stamp = 0;\r\nif (fastopen_clear) {\r\ntm->tcpm_fastopen.mss = 0;\r\ntm->tcpm_fastopen.syn_loss = 0;\r\ntm->tcpm_fastopen.cookie.len = 0;\r\n}\r\n}\r\nstatic struct tcp_metrics_block *tcpm_new(struct dst_entry *dst,\r\nstruct inetpeer_addr *addr,\r\nunsigned int hash,\r\nbool reclaim)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nstruct net *net;\r\nspin_lock_bh(&tcp_metrics_lock);\r\nnet = dev_net(dst->dev);\r\nif (unlikely(reclaim)) {\r\nstruct tcp_metrics_block *oldest;\r\noldest = rcu_dereference(net->ipv4.tcp_metrics_hash[hash].chain);\r\nfor (tm = rcu_dereference(oldest->tcpm_next); tm;\r\ntm = rcu_dereference(tm->tcpm_next)) {\r\nif (time_before(tm->tcpm_stamp, oldest->tcpm_stamp))\r\noldest = tm;\r\n}\r\ntm = oldest;\r\n} else {\r\ntm = kmalloc(sizeof(*tm), GFP_ATOMIC);\r\nif (!tm)\r\ngoto out_unlock;\r\n}\r\ntm->tcpm_addr = *addr;\r\ntcpm_suck_dst(tm, dst, true);\r\nif (likely(!reclaim)) {\r\ntm->tcpm_next = net->ipv4.tcp_metrics_hash[hash].chain;\r\nrcu_assign_pointer(net->ipv4.tcp_metrics_hash[hash].chain, tm);\r\n}\r\nout_unlock:\r\nspin_unlock_bh(&tcp_metrics_lock);\r\nreturn tm;\r\n}\r\nstatic void tcpm_check_stamp(struct tcp_metrics_block *tm, struct dst_entry *dst)\r\n{\r\nif (tm && unlikely(time_after(jiffies, tm->tcpm_stamp + TCP_METRICS_TIMEOUT)))\r\ntcpm_suck_dst(tm, dst, false);\r\n}\r\nstatic struct tcp_metrics_block *tcp_get_encode(struct tcp_metrics_block *tm, int depth)\r\n{\r\nif (tm)\r\nreturn tm;\r\nif (depth > TCP_METRICS_RECLAIM_DEPTH)\r\nreturn TCP_METRICS_RECLAIM_PTR;\r\nreturn NULL;\r\n}\r\nstatic struct tcp_metrics_block *__tcp_get_metrics(const struct inetpeer_addr *addr,\r\nstruct net *net, unsigned int hash)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nint depth = 0;\r\nfor (tm = rcu_dereference(net->ipv4.tcp_metrics_hash[hash].chain); tm;\r\ntm = rcu_dereference(tm->tcpm_next)) {\r\nif (addr_same(&tm->tcpm_addr, addr))\r\nbreak;\r\ndepth++;\r\n}\r\nreturn tcp_get_encode(tm, depth);\r\n}\r\nstatic struct tcp_metrics_block *__tcp_get_metrics_req(struct request_sock *req,\r\nstruct dst_entry *dst)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nstruct inetpeer_addr addr;\r\nunsigned int hash;\r\nstruct net *net;\r\naddr.family = req->rsk_ops->family;\r\nswitch (addr.family) {\r\ncase AF_INET:\r\naddr.addr.a4 = inet_rsk(req)->rmt_addr;\r\nhash = (__force unsigned int) addr.addr.a4;\r\nbreak;\r\ncase AF_INET6:\r\n*(struct in6_addr *)addr.addr.a6 = inet6_rsk(req)->rmt_addr;\r\nhash = ipv6_addr_hash(&inet6_rsk(req)->rmt_addr);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nnet = dev_net(dst->dev);\r\nhash = hash_32(hash, net->ipv4.tcp_metrics_hash_log);\r\nfor (tm = rcu_dereference(net->ipv4.tcp_metrics_hash[hash].chain); tm;\r\ntm = rcu_dereference(tm->tcpm_next)) {\r\nif (addr_same(&tm->tcpm_addr, &addr))\r\nbreak;\r\n}\r\ntcpm_check_stamp(tm, dst);\r\nreturn tm;\r\n}\r\nstatic struct tcp_metrics_block *__tcp_get_metrics_tw(struct inet_timewait_sock *tw)\r\n{\r\nstruct inet6_timewait_sock *tw6;\r\nstruct tcp_metrics_block *tm;\r\nstruct inetpeer_addr addr;\r\nunsigned int hash;\r\nstruct net *net;\r\naddr.family = tw->tw_family;\r\nswitch (addr.family) {\r\ncase AF_INET:\r\naddr.addr.a4 = tw->tw_daddr;\r\nhash = (__force unsigned int) addr.addr.a4;\r\nbreak;\r\ncase AF_INET6:\r\ntw6 = inet6_twsk((struct sock *)tw);\r\n*(struct in6_addr *)addr.addr.a6 = tw6->tw_v6_daddr;\r\nhash = ipv6_addr_hash(&tw6->tw_v6_daddr);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nnet = twsk_net(tw);\r\nhash = hash_32(hash, net->ipv4.tcp_metrics_hash_log);\r\nfor (tm = rcu_dereference(net->ipv4.tcp_metrics_hash[hash].chain); tm;\r\ntm = rcu_dereference(tm->tcpm_next)) {\r\nif (addr_same(&tm->tcpm_addr, &addr))\r\nbreak;\r\n}\r\nreturn tm;\r\n}\r\nstatic struct tcp_metrics_block *tcp_get_metrics(struct sock *sk,\r\nstruct dst_entry *dst,\r\nbool create)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nstruct inetpeer_addr addr;\r\nunsigned int hash;\r\nstruct net *net;\r\nbool reclaim;\r\naddr.family = sk->sk_family;\r\nswitch (addr.family) {\r\ncase AF_INET:\r\naddr.addr.a4 = inet_sk(sk)->inet_daddr;\r\nhash = (__force unsigned int) addr.addr.a4;\r\nbreak;\r\ncase AF_INET6:\r\n*(struct in6_addr *)addr.addr.a6 = inet6_sk(sk)->daddr;\r\nhash = ipv6_addr_hash(&inet6_sk(sk)->daddr);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nnet = dev_net(dst->dev);\r\nhash = hash_32(hash, net->ipv4.tcp_metrics_hash_log);\r\ntm = __tcp_get_metrics(&addr, net, hash);\r\nreclaim = false;\r\nif (tm == TCP_METRICS_RECLAIM_PTR) {\r\nreclaim = true;\r\ntm = NULL;\r\n}\r\nif (!tm && create)\r\ntm = tcpm_new(dst, &addr, hash, reclaim);\r\nelse\r\ntcpm_check_stamp(tm, dst);\r\nreturn tm;\r\n}\r\nvoid tcp_update_metrics(struct sock *sk)\r\n{\r\nconst struct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct dst_entry *dst = __sk_dst_get(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nstruct tcp_metrics_block *tm;\r\nunsigned long rtt;\r\nu32 val;\r\nint m;\r\nif (sysctl_tcp_nometrics_save || !dst)\r\nreturn;\r\nif (dst->flags & DST_HOST)\r\ndst_confirm(dst);\r\nrcu_read_lock();\r\nif (icsk->icsk_backoff || !tp->srtt) {\r\ntm = tcp_get_metrics(sk, dst, false);\r\nif (tm && !tcp_metric_locked(tm, TCP_METRIC_RTT))\r\ntcp_metric_set(tm, TCP_METRIC_RTT, 0);\r\ngoto out_unlock;\r\n} else\r\ntm = tcp_get_metrics(sk, dst, true);\r\nif (!tm)\r\ngoto out_unlock;\r\nrtt = tcp_metric_get_jiffies(tm, TCP_METRIC_RTT);\r\nm = rtt - tp->srtt;\r\nif (!tcp_metric_locked(tm, TCP_METRIC_RTT)) {\r\nif (m <= 0)\r\nrtt = tp->srtt;\r\nelse\r\nrtt -= (m >> 3);\r\ntcp_metric_set_msecs(tm, TCP_METRIC_RTT, rtt);\r\n}\r\nif (!tcp_metric_locked(tm, TCP_METRIC_RTTVAR)) {\r\nunsigned long var;\r\nif (m < 0)\r\nm = -m;\r\nm >>= 1;\r\nif (m < tp->mdev)\r\nm = tp->mdev;\r\nvar = tcp_metric_get_jiffies(tm, TCP_METRIC_RTTVAR);\r\nif (m >= var)\r\nvar = m;\r\nelse\r\nvar -= (var - m) >> 2;\r\ntcp_metric_set_msecs(tm, TCP_METRIC_RTTVAR, var);\r\n}\r\nif (tcp_in_initial_slowstart(tp)) {\r\nif (!tcp_metric_locked(tm, TCP_METRIC_SSTHRESH)) {\r\nval = tcp_metric_get(tm, TCP_METRIC_SSTHRESH);\r\nif (val && (tp->snd_cwnd >> 1) > val)\r\ntcp_metric_set(tm, TCP_METRIC_SSTHRESH,\r\ntp->snd_cwnd >> 1);\r\n}\r\nif (!tcp_metric_locked(tm, TCP_METRIC_CWND)) {\r\nval = tcp_metric_get(tm, TCP_METRIC_CWND);\r\nif (tp->snd_cwnd > val)\r\ntcp_metric_set(tm, TCP_METRIC_CWND,\r\ntp->snd_cwnd);\r\n}\r\n} else if (tp->snd_cwnd > tp->snd_ssthresh &&\r\nicsk->icsk_ca_state == TCP_CA_Open) {\r\nif (!tcp_metric_locked(tm, TCP_METRIC_SSTHRESH))\r\ntcp_metric_set(tm, TCP_METRIC_SSTHRESH,\r\nmax(tp->snd_cwnd >> 1, tp->snd_ssthresh));\r\nif (!tcp_metric_locked(tm, TCP_METRIC_CWND)) {\r\nval = tcp_metric_get(tm, TCP_METRIC_CWND);\r\ntcp_metric_set(tm, TCP_METRIC_CWND, (val + tp->snd_cwnd) >> 1);\r\n}\r\n} else {\r\nif (!tcp_metric_locked(tm, TCP_METRIC_CWND)) {\r\nval = tcp_metric_get(tm, TCP_METRIC_CWND);\r\ntcp_metric_set(tm, TCP_METRIC_CWND,\r\n(val + tp->snd_ssthresh) >> 1);\r\n}\r\nif (!tcp_metric_locked(tm, TCP_METRIC_SSTHRESH)) {\r\nval = tcp_metric_get(tm, TCP_METRIC_SSTHRESH);\r\nif (val && tp->snd_ssthresh > val)\r\ntcp_metric_set(tm, TCP_METRIC_SSTHRESH,\r\ntp->snd_ssthresh);\r\n}\r\nif (!tcp_metric_locked(tm, TCP_METRIC_REORDERING)) {\r\nval = tcp_metric_get(tm, TCP_METRIC_REORDERING);\r\nif (val < tp->reordering &&\r\ntp->reordering != sysctl_tcp_reordering)\r\ntcp_metric_set(tm, TCP_METRIC_REORDERING,\r\ntp->reordering);\r\n}\r\n}\r\ntm->tcpm_stamp = jiffies;\r\nout_unlock:\r\nrcu_read_unlock();\r\n}\r\nvoid tcp_init_metrics(struct sock *sk)\r\n{\r\nstruct dst_entry *dst = __sk_dst_get(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nstruct tcp_metrics_block *tm;\r\nu32 val;\r\nif (dst == NULL)\r\ngoto reset;\r\ndst_confirm(dst);\r\nrcu_read_lock();\r\ntm = tcp_get_metrics(sk, dst, true);\r\nif (!tm) {\r\nrcu_read_unlock();\r\ngoto reset;\r\n}\r\nif (tcp_metric_locked(tm, TCP_METRIC_CWND))\r\ntp->snd_cwnd_clamp = tcp_metric_get(tm, TCP_METRIC_CWND);\r\nval = tcp_metric_get(tm, TCP_METRIC_SSTHRESH);\r\nif (val) {\r\ntp->snd_ssthresh = val;\r\nif (tp->snd_ssthresh > tp->snd_cwnd_clamp)\r\ntp->snd_ssthresh = tp->snd_cwnd_clamp;\r\n} else {\r\ntp->snd_ssthresh = TCP_INFINITE_SSTHRESH;\r\n}\r\nval = tcp_metric_get(tm, TCP_METRIC_REORDERING);\r\nif (val && tp->reordering != val) {\r\ntcp_disable_fack(tp);\r\ntcp_disable_early_retrans(tp);\r\ntp->reordering = val;\r\n}\r\nval = tcp_metric_get(tm, TCP_METRIC_RTT);\r\nif (val == 0 || tp->srtt == 0) {\r\nrcu_read_unlock();\r\ngoto reset;\r\n}\r\nval = msecs_to_jiffies(val);\r\nif (val > tp->srtt) {\r\ntp->srtt = val;\r\ntp->rtt_seq = tp->snd_nxt;\r\n}\r\nval = tcp_metric_get_jiffies(tm, TCP_METRIC_RTTVAR);\r\nif (val > tp->mdev) {\r\ntp->mdev = val;\r\ntp->mdev_max = tp->rttvar = max(tp->mdev, tcp_rto_min(sk));\r\n}\r\nrcu_read_unlock();\r\ntcp_set_rto(sk);\r\nreset:\r\nif (tp->srtt == 0) {\r\ntp->mdev = tp->mdev_max = tp->rttvar = TCP_TIMEOUT_FALLBACK;\r\ninet_csk(sk)->icsk_rto = TCP_TIMEOUT_FALLBACK;\r\n}\r\nif (tp->total_retrans > 1)\r\ntp->snd_cwnd = 1;\r\nelse\r\ntp->snd_cwnd = tcp_init_cwnd(tp, dst);\r\ntp->snd_cwnd_stamp = tcp_time_stamp;\r\n}\r\nbool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst, bool paws_check)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nbool ret;\r\nif (!dst)\r\nreturn false;\r\nrcu_read_lock();\r\ntm = __tcp_get_metrics_req(req, dst);\r\nif (paws_check) {\r\nif (tm &&\r\n(u32)get_seconds() - tm->tcpm_ts_stamp < TCP_PAWS_MSL &&\r\n(s32)(tm->tcpm_ts - req->ts_recent) > TCP_PAWS_WINDOW)\r\nret = false;\r\nelse\r\nret = true;\r\n} else {\r\nif (tm && tcp_metric_get(tm, TCP_METRIC_RTT) && tm->tcpm_ts_stamp)\r\nret = true;\r\nelse\r\nret = false;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nvoid tcp_fetch_timewait_stamp(struct sock *sk, struct dst_entry *dst)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nrcu_read_lock();\r\ntm = tcp_get_metrics(sk, dst, true);\r\nif (tm) {\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nif ((u32)get_seconds() - tm->tcpm_ts_stamp <= TCP_PAWS_MSL) {\r\ntp->rx_opt.ts_recent_stamp = tm->tcpm_ts_stamp;\r\ntp->rx_opt.ts_recent = tm->tcpm_ts;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nbool tcp_remember_stamp(struct sock *sk)\r\n{\r\nstruct dst_entry *dst = __sk_dst_get(sk);\r\nbool ret = false;\r\nif (dst) {\r\nstruct tcp_metrics_block *tm;\r\nrcu_read_lock();\r\ntm = tcp_get_metrics(sk, dst, true);\r\nif (tm) {\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nif ((s32)(tm->tcpm_ts - tp->rx_opt.ts_recent) <= 0 ||\r\n((u32)get_seconds() - tm->tcpm_ts_stamp > TCP_PAWS_MSL &&\r\ntm->tcpm_ts_stamp <= (u32)tp->rx_opt.ts_recent_stamp)) {\r\ntm->tcpm_ts_stamp = (u32)tp->rx_opt.ts_recent_stamp;\r\ntm->tcpm_ts = tp->rx_opt.ts_recent;\r\n}\r\nret = true;\r\n}\r\nrcu_read_unlock();\r\n}\r\nreturn ret;\r\n}\r\nbool tcp_tw_remember_stamp(struct inet_timewait_sock *tw)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nbool ret = false;\r\nrcu_read_lock();\r\ntm = __tcp_get_metrics_tw(tw);\r\nif (tm) {\r\nconst struct tcp_timewait_sock *tcptw;\r\nstruct sock *sk = (struct sock *) tw;\r\ntcptw = tcp_twsk(sk);\r\nif ((s32)(tm->tcpm_ts - tcptw->tw_ts_recent) <= 0 ||\r\n((u32)get_seconds() - tm->tcpm_ts_stamp > TCP_PAWS_MSL &&\r\ntm->tcpm_ts_stamp <= (u32)tcptw->tw_ts_recent_stamp)) {\r\ntm->tcpm_ts_stamp = (u32)tcptw->tw_ts_recent_stamp;\r\ntm->tcpm_ts = tcptw->tw_ts_recent;\r\n}\r\nret = true;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nvoid tcp_fastopen_cache_get(struct sock *sk, u16 *mss,\r\nstruct tcp_fastopen_cookie *cookie,\r\nint *syn_loss, unsigned long *last_syn_loss)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nrcu_read_lock();\r\ntm = tcp_get_metrics(sk, __sk_dst_get(sk), false);\r\nif (tm) {\r\nstruct tcp_fastopen_metrics *tfom = &tm->tcpm_fastopen;\r\nunsigned int seq;\r\ndo {\r\nseq = read_seqbegin(&fastopen_seqlock);\r\nif (tfom->mss)\r\n*mss = tfom->mss;\r\n*cookie = tfom->cookie;\r\n*syn_loss = tfom->syn_loss;\r\n*last_syn_loss = *syn_loss ? tfom->last_syn_loss : 0;\r\n} while (read_seqretry(&fastopen_seqlock, seq));\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid tcp_fastopen_cache_set(struct sock *sk, u16 mss,\r\nstruct tcp_fastopen_cookie *cookie, bool syn_lost)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nrcu_read_lock();\r\ntm = tcp_get_metrics(sk, __sk_dst_get(sk), true);\r\nif (tm) {\r\nstruct tcp_fastopen_metrics *tfom = &tm->tcpm_fastopen;\r\nwrite_seqlock_bh(&fastopen_seqlock);\r\ntfom->mss = mss;\r\nif (cookie->len > 0)\r\ntfom->cookie = *cookie;\r\nif (syn_lost) {\r\n++tfom->syn_loss;\r\ntfom->last_syn_loss = jiffies;\r\n} else\r\ntfom->syn_loss = 0;\r\nwrite_sequnlock_bh(&fastopen_seqlock);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int tcp_metrics_fill_info(struct sk_buff *msg,\r\nstruct tcp_metrics_block *tm)\r\n{\r\nstruct nlattr *nest;\r\nint i;\r\nswitch (tm->tcpm_addr.family) {\r\ncase AF_INET:\r\nif (nla_put_be32(msg, TCP_METRICS_ATTR_ADDR_IPV4,\r\ntm->tcpm_addr.addr.a4) < 0)\r\ngoto nla_put_failure;\r\nbreak;\r\ncase AF_INET6:\r\nif (nla_put(msg, TCP_METRICS_ATTR_ADDR_IPV6, 16,\r\ntm->tcpm_addr.addr.a6) < 0)\r\ngoto nla_put_failure;\r\nbreak;\r\ndefault:\r\nreturn -EAFNOSUPPORT;\r\n}\r\nif (nla_put_msecs(msg, TCP_METRICS_ATTR_AGE,\r\njiffies - tm->tcpm_stamp) < 0)\r\ngoto nla_put_failure;\r\nif (tm->tcpm_ts_stamp) {\r\nif (nla_put_s32(msg, TCP_METRICS_ATTR_TW_TS_STAMP,\r\n(s32) (get_seconds() - tm->tcpm_ts_stamp)) < 0)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, TCP_METRICS_ATTR_TW_TSVAL,\r\ntm->tcpm_ts) < 0)\r\ngoto nla_put_failure;\r\n}\r\n{\r\nint n = 0;\r\nnest = nla_nest_start(msg, TCP_METRICS_ATTR_VALS);\r\nif (!nest)\r\ngoto nla_put_failure;\r\nfor (i = 0; i < TCP_METRIC_MAX + 1; i++) {\r\nif (!tm->tcpm_vals[i])\r\ncontinue;\r\nif (nla_put_u32(msg, i + 1, tm->tcpm_vals[i]) < 0)\r\ngoto nla_put_failure;\r\nn++;\r\n}\r\nif (n)\r\nnla_nest_end(msg, nest);\r\nelse\r\nnla_nest_cancel(msg, nest);\r\n}\r\n{\r\nstruct tcp_fastopen_metrics tfom_copy[1], *tfom;\r\nunsigned int seq;\r\ndo {\r\nseq = read_seqbegin(&fastopen_seqlock);\r\ntfom_copy[0] = tm->tcpm_fastopen;\r\n} while (read_seqretry(&fastopen_seqlock, seq));\r\ntfom = tfom_copy;\r\nif (tfom->mss &&\r\nnla_put_u16(msg, TCP_METRICS_ATTR_FOPEN_MSS,\r\ntfom->mss) < 0)\r\ngoto nla_put_failure;\r\nif (tfom->syn_loss &&\r\n(nla_put_u16(msg, TCP_METRICS_ATTR_FOPEN_SYN_DROPS,\r\ntfom->syn_loss) < 0 ||\r\nnla_put_msecs(msg, TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS,\r\njiffies - tfom->last_syn_loss) < 0))\r\ngoto nla_put_failure;\r\nif (tfom->cookie.len > 0 &&\r\nnla_put(msg, TCP_METRICS_ATTR_FOPEN_COOKIE,\r\ntfom->cookie.len, tfom->cookie.val) < 0)\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int tcp_metrics_dump_info(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct tcp_metrics_block *tm)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\n&tcp_metrics_nl_family, NLM_F_MULTI,\r\nTCP_METRICS_CMD_GET);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nif (tcp_metrics_fill_info(skb, tm) < 0)\r\ngoto nla_put_failure;\r\nreturn genlmsg_end(skb, hdr);\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int tcp_metrics_nl_dump(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nunsigned int max_rows = 1U << net->ipv4.tcp_metrics_hash_log;\r\nunsigned int row, s_row = cb->args[0];\r\nint s_col = cb->args[1], col = s_col;\r\nfor (row = s_row; row < max_rows; row++, s_col = 0) {\r\nstruct tcp_metrics_block *tm;\r\nstruct tcpm_hash_bucket *hb = net->ipv4.tcp_metrics_hash + row;\r\nrcu_read_lock();\r\nfor (col = 0, tm = rcu_dereference(hb->chain); tm;\r\ntm = rcu_dereference(tm->tcpm_next), col++) {\r\nif (col < s_col)\r\ncontinue;\r\nif (tcp_metrics_dump_info(skb, cb, tm) < 0) {\r\nrcu_read_unlock();\r\ngoto done;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\ndone:\r\ncb->args[0] = row;\r\ncb->args[1] = col;\r\nreturn skb->len;\r\n}\r\nstatic int parse_nl_addr(struct genl_info *info, struct inetpeer_addr *addr,\r\nunsigned int *hash, int optional)\r\n{\r\nstruct nlattr *a;\r\na = info->attrs[TCP_METRICS_ATTR_ADDR_IPV4];\r\nif (a) {\r\naddr->family = AF_INET;\r\naddr->addr.a4 = nla_get_be32(a);\r\n*hash = (__force unsigned int) addr->addr.a4;\r\nreturn 0;\r\n}\r\na = info->attrs[TCP_METRICS_ATTR_ADDR_IPV6];\r\nif (a) {\r\nif (nla_len(a) != sizeof(struct in6_addr))\r\nreturn -EINVAL;\r\naddr->family = AF_INET6;\r\nmemcpy(addr->addr.a6, nla_data(a), sizeof(addr->addr.a6));\r\n*hash = ipv6_addr_hash((struct in6_addr *) addr->addr.a6);\r\nreturn 0;\r\n}\r\nreturn optional ? 1 : -EAFNOSUPPORT;\r\n}\r\nstatic int tcp_metrics_nl_cmd_get(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct tcp_metrics_block *tm;\r\nstruct inetpeer_addr addr;\r\nunsigned int hash;\r\nstruct sk_buff *msg;\r\nstruct net *net = genl_info_net(info);\r\nvoid *reply;\r\nint ret;\r\nret = parse_nl_addr(info, &addr, &hash, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nreply = genlmsg_put_reply(msg, info, &tcp_metrics_nl_family, 0,\r\ninfo->genlhdr->cmd);\r\nif (!reply)\r\ngoto nla_put_failure;\r\nhash = hash_32(hash, net->ipv4.tcp_metrics_hash_log);\r\nret = -ESRCH;\r\nrcu_read_lock();\r\nfor (tm = rcu_dereference(net->ipv4.tcp_metrics_hash[hash].chain); tm;\r\ntm = rcu_dereference(tm->tcpm_next)) {\r\nif (addr_same(&tm->tcpm_addr, &addr)) {\r\nret = tcp_metrics_fill_info(msg, tm);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (ret < 0)\r\ngoto out_free;\r\ngenlmsg_end(msg, reply);\r\nreturn genlmsg_reply(msg, info);\r\nnla_put_failure:\r\nret = -EMSGSIZE;\r\nout_free:\r\nnlmsg_free(msg);\r\nreturn ret;\r\n}\r\nstatic int tcp_metrics_flush_all(struct net *net)\r\n{\r\nunsigned int max_rows = 1U << net->ipv4.tcp_metrics_hash_log;\r\nstruct tcpm_hash_bucket *hb = net->ipv4.tcp_metrics_hash;\r\nstruct tcp_metrics_block *tm;\r\nunsigned int row;\r\nfor (row = 0; row < max_rows; row++, hb++) {\r\nspin_lock_bh(&tcp_metrics_lock);\r\ntm = deref_locked_genl(hb->chain);\r\nif (tm)\r\nhb->chain = NULL;\r\nspin_unlock_bh(&tcp_metrics_lock);\r\nwhile (tm) {\r\nstruct tcp_metrics_block *next;\r\nnext = deref_genl(tm->tcpm_next);\r\nkfree_rcu(tm, rcu_head);\r\ntm = next;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcp_metrics_nl_cmd_del(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct tcpm_hash_bucket *hb;\r\nstruct tcp_metrics_block *tm;\r\nstruct tcp_metrics_block __rcu **pp;\r\nstruct inetpeer_addr addr;\r\nunsigned int hash;\r\nstruct net *net = genl_info_net(info);\r\nint ret;\r\nret = parse_nl_addr(info, &addr, &hash, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret > 0)\r\nreturn tcp_metrics_flush_all(net);\r\nhash = hash_32(hash, net->ipv4.tcp_metrics_hash_log);\r\nhb = net->ipv4.tcp_metrics_hash + hash;\r\npp = &hb->chain;\r\nspin_lock_bh(&tcp_metrics_lock);\r\nfor (tm = deref_locked_genl(*pp); tm;\r\npp = &tm->tcpm_next, tm = deref_locked_genl(*pp)) {\r\nif (addr_same(&tm->tcpm_addr, &addr)) {\r\n*pp = tm->tcpm_next;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&tcp_metrics_lock);\r\nif (!tm)\r\nreturn -ESRCH;\r\nkfree_rcu(tm, rcu_head);\r\nreturn 0;\r\n}\r\nstatic int __init set_tcpmhash_entries(char *str)\r\n{\r\nssize_t ret;\r\nif (!str)\r\nreturn 0;\r\nret = kstrtouint(str, 0, &tcpmhash_entries);\r\nif (ret)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int __net_init tcp_net_metrics_init(struct net *net)\r\n{\r\nsize_t size;\r\nunsigned int slots;\r\nslots = tcpmhash_entries;\r\nif (!slots) {\r\nif (totalram_pages >= 128 * 1024)\r\nslots = 16 * 1024;\r\nelse\r\nslots = 8 * 1024;\r\n}\r\nnet->ipv4.tcp_metrics_hash_log = order_base_2(slots);\r\nsize = sizeof(struct tcpm_hash_bucket) << net->ipv4.tcp_metrics_hash_log;\r\nnet->ipv4.tcp_metrics_hash = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\r\nif (!net->ipv4.tcp_metrics_hash)\r\nnet->ipv4.tcp_metrics_hash = vzalloc(size);\r\nif (!net->ipv4.tcp_metrics_hash)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit tcp_net_metrics_exit(struct net *net)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < (1U << net->ipv4.tcp_metrics_hash_log) ; i++) {\r\nstruct tcp_metrics_block *tm, *next;\r\ntm = rcu_dereference_protected(net->ipv4.tcp_metrics_hash[i].chain, 1);\r\nwhile (tm) {\r\nnext = rcu_dereference_protected(tm->tcpm_next, 1);\r\nkfree(tm);\r\ntm = next;\r\n}\r\n}\r\nif (is_vmalloc_addr(net->ipv4.tcp_metrics_hash))\r\nvfree(net->ipv4.tcp_metrics_hash);\r\nelse\r\nkfree(net->ipv4.tcp_metrics_hash);\r\n}\r\nvoid __init tcp_metrics_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&tcp_net_metrics_ops);\r\nif (ret < 0)\r\ngoto cleanup;\r\nret = genl_register_family_with_ops(&tcp_metrics_nl_family,\r\ntcp_metrics_nl_ops,\r\nARRAY_SIZE(tcp_metrics_nl_ops));\r\nif (ret < 0)\r\ngoto cleanup_subsys;\r\nreturn;\r\ncleanup_subsys:\r\nunregister_pernet_subsys(&tcp_net_metrics_ops);\r\ncleanup:\r\nreturn;\r\n}
