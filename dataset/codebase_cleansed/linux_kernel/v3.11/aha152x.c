static inline void\r\nCMD_INC_RESID(struct scsi_cmnd *cmd, int inc)\r\n{\r\nscsi_set_resid(cmd, scsi_get_resid(cmd) + inc);\r\n}\r\nstatic inline void append_SC(Scsi_Cmnd **SC, Scsi_Cmnd *new_SC)\r\n{\r\nScsi_Cmnd *end;\r\nSCNEXT(new_SC) = NULL;\r\nif (!*SC)\r\n*SC = new_SC;\r\nelse {\r\nfor (end = *SC; SCNEXT(end); end = SCNEXT(end))\r\n;\r\nSCNEXT(end) = new_SC;\r\n}\r\n}\r\nstatic inline Scsi_Cmnd *remove_first_SC(Scsi_Cmnd ** SC)\r\n{\r\nScsi_Cmnd *ptr;\r\nptr = *SC;\r\nif (ptr) {\r\n*SC = SCNEXT(*SC);\r\nSCNEXT(ptr)=NULL;\r\n}\r\nreturn ptr;\r\n}\r\nstatic inline Scsi_Cmnd *remove_lun_SC(Scsi_Cmnd ** SC, int target, int lun)\r\n{\r\nScsi_Cmnd *ptr, *prev;\r\nfor (ptr = *SC, prev = NULL;\r\nptr && ((ptr->device->id != target) || (ptr->device->lun != lun));\r\nprev = ptr, ptr = SCNEXT(ptr))\r\n;\r\nif (ptr) {\r\nif (prev)\r\nSCNEXT(prev) = SCNEXT(ptr);\r\nelse\r\n*SC = SCNEXT(ptr);\r\nSCNEXT(ptr)=NULL;\r\n}\r\nreturn ptr;\r\n}\r\nstatic inline Scsi_Cmnd *remove_SC(Scsi_Cmnd **SC, Scsi_Cmnd *SCp)\r\n{\r\nScsi_Cmnd *ptr, *prev;\r\nfor (ptr = *SC, prev = NULL;\r\nptr && SCp!=ptr;\r\nprev = ptr, ptr = SCNEXT(ptr))\r\n;\r\nif (ptr) {\r\nif (prev)\r\nSCNEXT(prev) = SCNEXT(ptr);\r\nelse\r\n*SC = SCNEXT(ptr);\r\nSCNEXT(ptr)=NULL;\r\n}\r\nreturn ptr;\r\n}\r\nstatic irqreturn_t swintr(int irqno, void *dev_id)\r\n{\r\nstruct Scsi_Host *shpnt = dev_id;\r\nHOSTDATA(shpnt)->swint++;\r\nSETPORT(DMACNTRL0, INTEN);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct Scsi_Host *aha152x_probe_one(struct aha152x_setup *setup)\r\n{\r\nstruct Scsi_Host *shpnt;\r\nshpnt = scsi_host_alloc(&aha152x_driver_template, sizeof(struct aha152x_hostdata));\r\nif (!shpnt) {\r\nprintk(KERN_ERR "aha152x: scsi_host_alloc failed\n");\r\nreturn NULL;\r\n}\r\nmemset(HOSTDATA(shpnt), 0, sizeof *HOSTDATA(shpnt));\r\nINIT_LIST_HEAD(&HOSTDATA(shpnt)->host_list);\r\nlist_add_tail(&HOSTDATA(shpnt)->host_list, &aha152x_host_list);\r\nshpnt->io_port = setup->io_port;\r\nshpnt->n_io_port = IO_RANGE;\r\nshpnt->irq = setup->irq;\r\nif (!setup->tc1550) {\r\nHOSTIOPORT0 = setup->io_port;\r\nHOSTIOPORT1 = setup->io_port;\r\n} else {\r\nHOSTIOPORT0 = setup->io_port+0x10;\r\nHOSTIOPORT1 = setup->io_port-0x10;\r\n}\r\nspin_lock_init(&QLOCK);\r\nRECONNECT = setup->reconnect;\r\nSYNCHRONOUS = setup->synchronous;\r\nPARITY = setup->parity;\r\nDELAY = setup->delay;\r\nEXT_TRANS = setup->ext_trans;\r\n#if defined(AHA152X_DEBUG)\r\nHOSTDATA(shpnt)->debug = setup->debug;\r\n#endif\r\nSETPORT(SCSIID, setup->scsiid << 4);\r\nshpnt->this_id = setup->scsiid;\r\nif (setup->reconnect)\r\nshpnt->can_queue = AHA152X_MAXQUEUE;\r\nprintk("aha152x: resetting bus...\n");\r\nSETPORT(SCSISEQ, SCSIRSTO);\r\nmdelay(256);\r\nSETPORT(SCSISEQ, 0);\r\nmdelay(DELAY);\r\nreset_ports(shpnt);\r\nprintk(KERN_INFO\r\n"aha152x%d%s: "\r\n"vital data: rev=%x, "\r\n"io=0x%03lx (0x%03lx/0x%03lx), "\r\n"irq=%d, "\r\n"scsiid=%d, "\r\n"reconnect=%s, "\r\n"parity=%s, "\r\n"synchronous=%s, "\r\n"delay=%d, "\r\n"extended translation=%s\n",\r\nshpnt->host_no, setup->tc1550 ? " (tc1550 mode)" : "",\r\nGETPORT(REV) & 0x7,\r\nshpnt->io_port, HOSTIOPORT0, HOSTIOPORT1,\r\nshpnt->irq,\r\nshpnt->this_id,\r\nRECONNECT ? "enabled" : "disabled",\r\nPARITY ? "enabled" : "disabled",\r\nSYNCHRONOUS ? "enabled" : "disabled",\r\nDELAY,\r\nEXT_TRANS ? "enabled" : "disabled");\r\nSETPORT(SIMODE0, 0);\r\nSETPORT(SIMODE1, 0);\r\nif( request_irq(shpnt->irq, swintr, IRQF_DISABLED|IRQF_SHARED, "aha152x", shpnt) ) {\r\nprintk(KERN_ERR "aha152x%d: irq %d busy.\n", shpnt->host_no, shpnt->irq);\r\ngoto out_host_put;\r\n}\r\nHOSTDATA(shpnt)->swint = 0;\r\nprintk(KERN_INFO "aha152x%d: trying software interrupt, ", shpnt->host_no);\r\nmb();\r\nSETPORT(DMACNTRL0, SWINT|INTEN);\r\nmdelay(1000);\r\nfree_irq(shpnt->irq, shpnt);\r\nif (!HOSTDATA(shpnt)->swint) {\r\nif (TESTHI(DMASTAT, INTSTAT)) {\r\nprintk("lost.\n");\r\n} else {\r\nprintk("failed.\n");\r\n}\r\nSETPORT(DMACNTRL0, INTEN);\r\nprintk(KERN_ERR "aha152x%d: irq %d possibly wrong. "\r\n"Please verify.\n", shpnt->host_no, shpnt->irq);\r\ngoto out_host_put;\r\n}\r\nprintk("ok.\n");\r\nSETPORT(SSTAT0, 0x7f);\r\nSETPORT(SSTAT1, 0xef);\r\nif ( request_irq(shpnt->irq, intr, IRQF_DISABLED|IRQF_SHARED, "aha152x", shpnt) ) {\r\nprintk(KERN_ERR "aha152x%d: failed to reassign irq %d.\n", shpnt->host_no, shpnt->irq);\r\ngoto out_host_put;\r\n}\r\nif( scsi_add_host(shpnt, NULL) ) {\r\nfree_irq(shpnt->irq, shpnt);\r\nprintk(KERN_ERR "aha152x%d: failed to add host.\n", shpnt->host_no);\r\ngoto out_host_put;\r\n}\r\nscsi_scan_host(shpnt);\r\nreturn shpnt;\r\nout_host_put:\r\nlist_del(&HOSTDATA(shpnt)->host_list);\r\nscsi_host_put(shpnt);\r\nreturn NULL;\r\n}\r\nvoid aha152x_release(struct Scsi_Host *shpnt)\r\n{\r\nif (!shpnt)\r\nreturn;\r\nscsi_remove_host(shpnt);\r\nif (shpnt->irq)\r\nfree_irq(shpnt->irq, shpnt);\r\n#if !defined(PCMCIA)\r\nif (shpnt->io_port)\r\nrelease_region(shpnt->io_port, IO_RANGE);\r\n#endif\r\n#ifdef __ISAPNP__\r\nif (HOSTDATA(shpnt)->pnpdev)\r\npnp_device_detach(HOSTDATA(shpnt)->pnpdev);\r\n#endif\r\nlist_del(&HOSTDATA(shpnt)->host_list);\r\nscsi_host_put(shpnt);\r\n}\r\nstatic int setup_expected_interrupts(struct Scsi_Host *shpnt)\r\n{\r\nif(CURRENT_SC) {\r\nCURRENT_SC->SCp.phase |= 1 << 16;\r\nif(CURRENT_SC->SCp.phase & selecting) {\r\nDPRINTK(debug_intr, DEBUG_LEAD "expecting: (seldo) (seltimo) (seldi)\n", CMDINFO(CURRENT_SC));\r\nSETPORT(SSTAT1, SELTO);\r\nSETPORT(SIMODE0, ENSELDO | (DISCONNECTED_SC ? ENSELDI : 0));\r\nSETPORT(SIMODE1, ENSELTIMO);\r\n} else {\r\nDPRINTK(debug_intr, DEBUG_LEAD "expecting: (phase change) (busfree) %s\n", CMDINFO(CURRENT_SC), CURRENT_SC->SCp.phase & spiordy ? "(spiordy)" : "");\r\nSETPORT(SIMODE0, (CURRENT_SC->SCp.phase & spiordy) ? ENSPIORDY : 0);\r\nSETPORT(SIMODE1, ENPHASEMIS | ENSCSIRST | ENSCSIPERR | ENBUSFREE);\r\n}\r\n} else if(STATE==seldi) {\r\nDPRINTK(debug_intr, DEBUG_LEAD "expecting: (phase change) (identify)\n", CMDINFO(CURRENT_SC));\r\nSETPORT(SIMODE0, 0);\r\nSETPORT(SIMODE1, ENPHASEMIS | ENSCSIRST | ENSCSIPERR | ENBUSFREE);\r\n} else {\r\nDPRINTK(debug_intr, DEBUG_LEAD "expecting: %s %s\n",\r\nCMDINFO(CURRENT_SC),\r\nDISCONNECTED_SC ? "(reselection)" : "",\r\nISSUE_SC ? "(busfree)" : "");\r\nSETPORT(SIMODE0, DISCONNECTED_SC ? ENSELDI : 0);\r\nSETPORT(SIMODE1, ENSCSIRST | ( (ISSUE_SC||DONE_SC) ? ENBUSFREE : 0));\r\n}\r\nif(!HOSTDATA(shpnt)->in_intr)\r\nSETBITS(DMACNTRL0, INTEN);\r\nreturn TESTHI(DMASTAT, INTSTAT);\r\n}\r\nstatic int aha152x_internal_queue(Scsi_Cmnd *SCpnt, struct completion *complete,\r\nint phase, void (*done)(Scsi_Cmnd *))\r\n{\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nunsigned long flags;\r\n#if defined(AHA152X_DEBUG)\r\nif (HOSTDATA(shpnt)->debug & debug_queue) {\r\nprintk(INFO_LEAD "queue: %p; cmd_len=%d pieces=%d size=%u cmnd=",\r\nCMDINFO(SCpnt), SCpnt, SCpnt->cmd_len,\r\nscsi_sg_count(SCpnt), scsi_bufflen(SCpnt));\r\n__scsi_print_command(SCpnt->cmnd);\r\n}\r\n#endif\r\nSCpnt->scsi_done = done;\r\nSCpnt->SCp.phase = not_issued | phase;\r\nSCpnt->SCp.Status = 0x1;\r\nSCpnt->SCp.Message = 0;\r\nSCpnt->SCp.have_data_in = 0;\r\nSCpnt->SCp.sent_command = 0;\r\nif(SCpnt->SCp.phase & (resetting|check_condition)) {\r\nif (!SCpnt->host_scribble || SCSEM(SCpnt) || SCNEXT(SCpnt)) {\r\nprintk(ERR_LEAD "cannot reuse command\n", CMDINFO(SCpnt));\r\nreturn FAILED;\r\n}\r\n} else {\r\nSCpnt->host_scribble = kmalloc(sizeof(struct aha152x_scdata), GFP_ATOMIC);\r\nif(!SCpnt->host_scribble) {\r\nprintk(ERR_LEAD "allocation failed\n", CMDINFO(SCpnt));\r\nreturn FAILED;\r\n}\r\n}\r\nSCNEXT(SCpnt) = NULL;\r\nSCSEM(SCpnt) = complete;\r\nif ((phase & resetting) || !scsi_sglist(SCpnt)) {\r\nSCpnt->SCp.ptr = NULL;\r\nSCpnt->SCp.this_residual = 0;\r\nscsi_set_resid(SCpnt, 0);\r\nSCpnt->SCp.buffer = NULL;\r\nSCpnt->SCp.buffers_residual = 0;\r\n} else {\r\nscsi_set_resid(SCpnt, scsi_bufflen(SCpnt));\r\nSCpnt->SCp.buffer = scsi_sglist(SCpnt);\r\nSCpnt->SCp.ptr = SG_ADDRESS(SCpnt->SCp.buffer);\r\nSCpnt->SCp.this_residual = SCpnt->SCp.buffer->length;\r\nSCpnt->SCp.buffers_residual = scsi_sg_count(SCpnt) - 1;\r\n}\r\nDO_LOCK(flags);\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->total_commands++;\r\n#endif\r\nHOSTDATA(shpnt)->commands++;\r\nif (HOSTDATA(shpnt)->commands==1)\r\nSETPORT(PORTA, 1);\r\nappend_SC(&ISSUE_SC, SCpnt);\r\nif(!HOSTDATA(shpnt)->in_intr)\r\nsetup_expected_interrupts(shpnt);\r\nDO_UNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic int aha152x_queue_lck(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))\r\n{\r\n#if 0\r\nif(*SCpnt->cmnd == REQUEST_SENSE) {\r\nSCpnt->result = 0;\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\n#endif\r\nreturn aha152x_internal_queue(SCpnt, NULL, 0, done);\r\n}\r\nint aha152x_abort(Scsi_Cmnd *SCpnt)\r\n{\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nScsi_Cmnd *ptr;\r\nunsigned long flags;\r\n#if defined(AHA152X_DEBUG)\r\nif(HOSTDATA(shpnt)->debug & debug_eh) {\r\nprintk(DEBUG_LEAD "abort(%p)", CMDINFO(SCpnt), SCpnt);\r\nshow_queues(shpnt);\r\n}\r\n#endif\r\nDO_LOCK(flags);\r\nptr=remove_SC(&ISSUE_SC, SCpnt);\r\nif(ptr) {\r\nDPRINTK(debug_eh, DEBUG_LEAD "not yet issued - SUCCESS\n", CMDINFO(SCpnt));\r\nHOSTDATA(shpnt)->commands--;\r\nif (!HOSTDATA(shpnt)->commands)\r\nSETPORT(PORTA, 0);\r\nDO_UNLOCK(flags);\r\nkfree(SCpnt->host_scribble);\r\nSCpnt->host_scribble=NULL;\r\nreturn SUCCESS;\r\n}\r\nDO_UNLOCK(flags);\r\nprintk(ERR_LEAD "cannot abort running or disconnected command\n", CMDINFO(SCpnt));\r\nreturn FAILED;\r\n}\r\nstatic int aha152x_device_reset(Scsi_Cmnd * SCpnt)\r\n{\r\nstruct Scsi_Host *shpnt = SCpnt->device->host;\r\nDECLARE_COMPLETION(done);\r\nint ret, issued, disconnected;\r\nunsigned char old_cmd_len = SCpnt->cmd_len;\r\nunsigned long flags;\r\nunsigned long timeleft;\r\n#if defined(AHA152X_DEBUG)\r\nif(HOSTDATA(shpnt)->debug & debug_eh) {\r\nprintk(INFO_LEAD "aha152x_device_reset(%p)", CMDINFO(SCpnt), SCpnt);\r\nshow_queues(shpnt);\r\n}\r\n#endif\r\nif(CURRENT_SC==SCpnt) {\r\nprintk(ERR_LEAD "cannot reset current device\n", CMDINFO(SCpnt));\r\nreturn FAILED;\r\n}\r\nDO_LOCK(flags);\r\nissued = remove_SC(&ISSUE_SC, SCpnt) == NULL;\r\ndisconnected = issued && remove_SC(&DISCONNECTED_SC, SCpnt);\r\nDO_UNLOCK(flags);\r\nSCpnt->cmd_len = 0;\r\naha152x_internal_queue(SCpnt, &done, resetting, reset_done);\r\ntimeleft = wait_for_completion_timeout(&done, 100*HZ);\r\nif (!timeleft) {\r\nDO_LOCK(flags);\r\nremove_SC(&ISSUE_SC, SCpnt);\r\nDO_UNLOCK(flags);\r\n}\r\nSCpnt->cmd_len = old_cmd_len;\r\nDO_LOCK(flags);\r\nif(SCpnt->SCp.phase & resetted) {\r\nHOSTDATA(shpnt)->commands--;\r\nif (!HOSTDATA(shpnt)->commands)\r\nSETPORT(PORTA, 0);\r\nkfree(SCpnt->host_scribble);\r\nSCpnt->host_scribble=NULL;\r\nret = SUCCESS;\r\n} else {\r\nif(!issued) {\r\nappend_SC(&ISSUE_SC, SCpnt);\r\n} else if(disconnected) {\r\nappend_SC(&DISCONNECTED_SC, SCpnt);\r\n}\r\nret = FAILED;\r\n}\r\nDO_UNLOCK(flags);\r\nreturn ret;\r\n}\r\nstatic void free_hard_reset_SCs(struct Scsi_Host *shpnt, Scsi_Cmnd **SCs)\r\n{\r\nScsi_Cmnd *ptr;\r\nptr=*SCs;\r\nwhile(ptr) {\r\nScsi_Cmnd *next;\r\nif(SCDATA(ptr)) {\r\nnext = SCNEXT(ptr);\r\n} else {\r\nprintk(DEBUG_LEAD "queue corrupted at %p\n", CMDINFO(ptr), ptr);\r\nnext = NULL;\r\n}\r\nif (!ptr->device->soft_reset) {\r\nDPRINTK(debug_eh, DEBUG_LEAD "disconnected command %p removed\n", CMDINFO(ptr), ptr);\r\nremove_SC(SCs, ptr);\r\nHOSTDATA(shpnt)->commands--;\r\nkfree(ptr->host_scribble);\r\nptr->host_scribble=NULL;\r\n}\r\nptr = next;\r\n}\r\n}\r\nstatic int aha152x_bus_reset_host(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long flags;\r\nDO_LOCK(flags);\r\n#if defined(AHA152X_DEBUG)\r\nif(HOSTDATA(shpnt)->debug & debug_eh) {\r\nprintk(KERN_DEBUG "scsi%d: bus reset", shpnt->host_no);\r\nshow_queues(shpnt);\r\n}\r\n#endif\r\nfree_hard_reset_SCs(shpnt, &ISSUE_SC);\r\nfree_hard_reset_SCs(shpnt, &DISCONNECTED_SC);\r\nDPRINTK(debug_eh, KERN_DEBUG "scsi%d: resetting bus\n", shpnt->host_no);\r\nSETPORT(SCSISEQ, SCSIRSTO);\r\nmdelay(256);\r\nSETPORT(SCSISEQ, 0);\r\nmdelay(DELAY);\r\nDPRINTK(debug_eh, KERN_DEBUG "scsi%d: bus resetted\n", shpnt->host_no);\r\nsetup_expected_interrupts(shpnt);\r\nif(HOSTDATA(shpnt)->commands==0)\r\nSETPORT(PORTA, 0);\r\nDO_UNLOCK(flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int aha152x_bus_reset(Scsi_Cmnd *SCpnt)\r\n{\r\nreturn aha152x_bus_reset_host(SCpnt->device->host);\r\n}\r\nstatic void reset_ports(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long flags;\r\nSETPORT(DMACNTRL0, RSTFIFO);\r\nSETPORT(SCSISEQ, 0);\r\nSETPORT(SXFRCTL1, 0);\r\nSETPORT(SCSISIG, 0);\r\nSETRATE(0);\r\nSETPORT(SSTAT0, 0x7f);\r\nSETPORT(SSTAT1, 0xef);\r\nSETPORT(SSTAT4, SYNCERR | FWERR | FRERR);\r\nSETPORT(DMACNTRL0, 0);\r\nSETPORT(DMACNTRL1, 0);\r\nSETPORT(BRSTCNTRL, 0xf1);\r\nSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1);\r\nDO_LOCK(flags);\r\nsetup_expected_interrupts(shpnt);\r\nDO_UNLOCK(flags);\r\n}\r\nint aha152x_host_reset_host(struct Scsi_Host *shpnt)\r\n{\r\nDPRINTK(debug_eh, KERN_DEBUG "scsi%d: host reset\n", shpnt->host_no);\r\naha152x_bus_reset_host(shpnt);\r\nDPRINTK(debug_eh, KERN_DEBUG "scsi%d: resetting ports\n", shpnt->host_no);\r\nreset_ports(shpnt);\r\nreturn SUCCESS;\r\n}\r\nstatic int aha152x_host_reset(Scsi_Cmnd *SCpnt)\r\n{\r\nreturn aha152x_host_reset_host(SCpnt->device->host);\r\n}\r\nstatic int aha152x_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int *info_array)\r\n{\r\nstruct Scsi_Host *shpnt = sdev->host;\r\ninfo_array[0] = 64;\r\ninfo_array[1] = 32;\r\ninfo_array[2] = (unsigned long)capacity / (64 * 32);\r\nif (info_array[2] >= 1024) {\r\nint info[3];\r\nif (scsicam_bios_param(bdev, capacity, info) < 0 ||\r\n!((info[0] == 64 && info[1] == 32) || (info[0] == 255 && info[1] == 63))) {\r\nif (EXT_TRANS) {\r\nprintk(KERN_NOTICE\r\n"aha152x: unable to verify geometry for disk with >1GB.\n"\r\n" using extended translation.\n");\r\ninfo_array[0] = 255;\r\ninfo_array[1] = 63;\r\ninfo_array[2] = (unsigned long)capacity / (255 * 63);\r\n} else {\r\nprintk(KERN_NOTICE\r\n"aha152x: unable to verify geometry for disk with >1GB.\n"\r\n" Using default translation. Please verify yourself.\n"\r\n" Perhaps you need to enable extended translation in the driver.\n"\r\n" See Documentation/scsi/aha152x.txt for details.\n");\r\n}\r\n} else {\r\ninfo_array[0] = info[0];\r\ninfo_array[1] = info[1];\r\ninfo_array[2] = info[2];\r\nif (info[0] == 255 && !EXT_TRANS) {\r\nprintk(KERN_NOTICE\r\n"aha152x: current partition table is using extended translation.\n"\r\n" using it also, although it's not explicitly enabled.\n");\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void done(struct Scsi_Host *shpnt, int error)\r\n{\r\nif (CURRENT_SC) {\r\nif(DONE_SC)\r\nprintk(ERR_LEAD "there's already a completed command %p - will cause abort\n", CMDINFO(CURRENT_SC), DONE_SC);\r\nDONE_SC = CURRENT_SC;\r\nCURRENT_SC = NULL;\r\nDONE_SC->result = error;\r\n} else\r\nprintk(KERN_ERR "aha152x: done() called outside of command\n");\r\n}\r\nstatic void run(struct work_struct *work)\r\n{\r\nstruct aha152x_hostdata *hd;\r\nlist_for_each_entry(hd, &aha152x_host_list, host_list) {\r\nstruct Scsi_Host *shost = container_of((void *)hd, struct Scsi_Host, hostdata);\r\nis_complete(shost);\r\n}\r\n}\r\nstatic irqreturn_t intr(int irqno, void *dev_id)\r\n{\r\nstruct Scsi_Host *shpnt = dev_id;\r\nunsigned long flags;\r\nunsigned char rev, dmacntrl0;\r\nrev = GETPORT(REV);\r\ndmacntrl0 = GETPORT(DMACNTRL0);\r\nif ((rev == 0xFF) && (dmacntrl0 == 0xFF))\r\nreturn IRQ_NONE;\r\nif( TESTLO(DMASTAT, INTSTAT) )\r\nreturn IRQ_NONE;\r\nCLRBITS(DMACNTRL0, INTEN);\r\nDO_LOCK(flags);\r\nif( HOSTDATA(shpnt)->service==0 ) {\r\nHOSTDATA(shpnt)->service=1;\r\nINIT_WORK(&aha152x_tq, run);\r\nschedule_work(&aha152x_tq);\r\n}\r\nDO_UNLOCK(flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void busfree_run(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long flags;\r\n#if defined(AHA152X_STAT)\r\nint action=0;\r\n#endif\r\nSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1);\r\nSETPORT(SSTAT1, CLRBUSFREE);\r\nif(CURRENT_SC) {\r\n#if defined(AHA152X_STAT)\r\naction++;\r\n#endif\r\nCURRENT_SC->SCp.phase &= ~syncneg;\r\nif(CURRENT_SC->SCp.phase & completed) {\r\ndone(shpnt, (CURRENT_SC->SCp.Status & 0xff) | ((CURRENT_SC->SCp.Message & 0xff) << 8) | (DID_OK << 16));\r\n} else if(CURRENT_SC->SCp.phase & aborted) {\r\nDPRINTK(debug_eh, DEBUG_LEAD "ABORT sent\n", CMDINFO(CURRENT_SC));\r\ndone(shpnt, (CURRENT_SC->SCp.Status & 0xff) | ((CURRENT_SC->SCp.Message & 0xff) << 8) | (DID_ABORT << 16));\r\n} else if(CURRENT_SC->SCp.phase & resetted) {\r\nDPRINTK(debug_eh, DEBUG_LEAD "BUS DEVICE RESET sent\n", CMDINFO(CURRENT_SC));\r\ndone(shpnt, (CURRENT_SC->SCp.Status & 0xff) | ((CURRENT_SC->SCp.Message & 0xff) << 8) | (DID_RESET << 16));\r\n} else if(CURRENT_SC->SCp.phase & disconnected) {\r\nDPRINTK(debug_selection, DEBUG_LEAD "target disconnected at %d/%d\n",\r\nCMDINFO(CURRENT_SC),\r\nscsi_get_resid(CURRENT_SC),\r\nscsi_bufflen(CURRENT_SC));\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->disconnections++;\r\n#endif\r\nappend_SC(&DISCONNECTED_SC, CURRENT_SC);\r\nCURRENT_SC->SCp.phase |= 1 << 16;\r\nCURRENT_SC = NULL;\r\n} else {\r\ndone(shpnt, DID_ERROR << 16);\r\n}\r\n#if defined(AHA152X_STAT)\r\n} else {\r\nHOSTDATA(shpnt)->busfree_without_old_command++;\r\n#endif\r\n}\r\nDO_LOCK(flags);\r\nif(DONE_SC) {\r\n#if defined(AHA152X_STAT)\r\naction++;\r\n#endif\r\nif(DONE_SC->SCp.phase & check_condition) {\r\nstruct scsi_cmnd *cmd = HOSTDATA(shpnt)->done_SC;\r\nstruct aha152x_scdata *sc = SCDATA(cmd);\r\n#if 0\r\nif(HOSTDATA(shpnt)->debug & debug_eh) {\r\nprintk(ERR_LEAD "received sense: ", CMDINFO(DONE_SC));\r\nscsi_print_sense("bh", DONE_SC);\r\n}\r\n#endif\r\nscsi_eh_restore_cmnd(cmd, &sc->ses);\r\ncmd->SCp.Status = SAM_STAT_CHECK_CONDITION;\r\nHOSTDATA(shpnt)->commands--;\r\nif (!HOSTDATA(shpnt)->commands)\r\nSETPORT(PORTA, 0);\r\n} else if(DONE_SC->SCp.Status==SAM_STAT_CHECK_CONDITION) {\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->busfree_with_check_condition++;\r\n#endif\r\n#if 0\r\nDPRINTK(debug_eh, ERR_LEAD "CHECK CONDITION found\n", CMDINFO(DONE_SC));\r\n#endif\r\nif(!(DONE_SC->SCp.phase & not_issued)) {\r\nstruct aha152x_scdata *sc;\r\nScsi_Cmnd *ptr = DONE_SC;\r\nDONE_SC=NULL;\r\n#if 0\r\nDPRINTK(debug_eh, ERR_LEAD "requesting sense\n", CMDINFO(ptr));\r\n#endif\r\nsc = SCDATA(ptr);\r\nBUG_ON(!sc);\r\nscsi_eh_prep_cmnd(ptr, &sc->ses, NULL, 0, ~0);\r\nDO_UNLOCK(flags);\r\naha152x_internal_queue(ptr, NULL, check_condition, ptr->scsi_done);\r\nDO_LOCK(flags);\r\n#if 0\r\n} else {\r\nDPRINTK(debug_eh, ERR_LEAD "command not issued - CHECK CONDITION ignored\n", CMDINFO(DONE_SC));\r\n#endif\r\n}\r\n}\r\nif(DONE_SC && DONE_SC->scsi_done) {\r\n#if defined(AHA152X_DEBUG)\r\nint hostno=DONE_SC->device->host->host_no;\r\nint id=DONE_SC->device->id & 0xf;\r\nint lun=DONE_SC->device->lun & 0x7;\r\n#endif\r\nScsi_Cmnd *ptr = DONE_SC;\r\nDONE_SC=NULL;\r\nHOSTDATA(shpnt)->commands--;\r\nif (!HOSTDATA(shpnt)->commands)\r\nSETPORT(PORTA, 0);\r\nif(ptr->scsi_done != reset_done) {\r\nkfree(ptr->host_scribble);\r\nptr->host_scribble=NULL;\r\n}\r\nDO_UNLOCK(flags);\r\nDPRINTK(debug_done, DEBUG_LEAD "calling scsi_done(%p)\n", hostno, id, lun, ptr);\r\nptr->scsi_done(ptr);\r\nDPRINTK(debug_done, DEBUG_LEAD "scsi_done(%p) returned\n", hostno, id, lun, ptr);\r\nDO_LOCK(flags);\r\n}\r\nDONE_SC=NULL;\r\n#if defined(AHA152X_STAT)\r\n} else {\r\nHOSTDATA(shpnt)->busfree_without_done_command++;\r\n#endif\r\n}\r\nif(ISSUE_SC)\r\nCURRENT_SC = remove_first_SC(&ISSUE_SC);\r\nDO_UNLOCK(flags);\r\nif(CURRENT_SC) {\r\n#if defined(AHA152X_STAT)\r\naction++;\r\n#endif\r\nCURRENT_SC->SCp.phase |= selecting;\r\nDPRINTK(debug_selection, DEBUG_LEAD "selecting target\n", CMDINFO(CURRENT_SC));\r\nSETPORT(SSTAT1, SELTO);\r\nSETPORT(SCSIID, (shpnt->this_id << OID_) | CURRENT_SC->device->id);\r\nSETPORT(SXFRCTL1, (PARITY ? ENSPCHK : 0 ) | ENSTIMER);\r\nSETPORT(SCSISEQ, ENSELO | ENAUTOATNO | (DISCONNECTED_SC ? ENRESELI : 0));\r\n} else {\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->busfree_without_new_command++;\r\n#endif\r\nSETPORT(SCSISEQ, DISCONNECTED_SC ? ENRESELI : 0);\r\n}\r\n#if defined(AHA152X_STAT)\r\nif(!action)\r\nHOSTDATA(shpnt)->busfree_without_any_action++;\r\n#endif\r\n}\r\nstatic void seldo_run(struct Scsi_Host *shpnt)\r\n{\r\nSETPORT(SCSISIG, 0);\r\nSETPORT(SSTAT1, CLRBUSFREE);\r\nSETPORT(SSTAT1, CLRPHASECHG);\r\nCURRENT_SC->SCp.phase &= ~(selecting|not_issued);\r\nSETPORT(SCSISEQ, 0);\r\nif (TESTLO(SSTAT0, SELDO)) {\r\nprintk(ERR_LEAD "aha152x: passing bus free condition\n", CMDINFO(CURRENT_SC));\r\ndone(shpnt, DID_NO_CONNECT << 16);\r\nreturn;\r\n}\r\nSETPORT(SSTAT0, CLRSELDO);\r\nADDMSGO(IDENTIFY(RECONNECT, CURRENT_SC->device->lun));\r\nif (CURRENT_SC->SCp.phase & aborting) {\r\nADDMSGO(ABORT);\r\n} else if (CURRENT_SC->SCp.phase & resetting) {\r\nADDMSGO(BUS_DEVICE_RESET);\r\n} else if (SYNCNEG==0 && SYNCHRONOUS) {\r\nCURRENT_SC->SCp.phase |= syncneg;\r\nMSGOLEN += spi_populate_sync_msg(&MSGO(MSGOLEN), 50, 8);\r\nSYNCNEG=1;\r\n}\r\nSETRATE(SYNCRATE);\r\n}\r\nstatic void selto_run(struct Scsi_Host *shpnt)\r\n{\r\nSETPORT(SCSISEQ, 0);\r\nSETPORT(SSTAT1, CLRSELTIMO);\r\nDPRINTK(debug_selection, DEBUG_LEAD "selection timeout\n", CMDINFO(CURRENT_SC));\r\nif(!CURRENT_SC) {\r\nDPRINTK(debug_selection, DEBUG_LEAD "!CURRENT_SC\n", CMDINFO(CURRENT_SC));\r\nreturn;\r\n}\r\nCURRENT_SC->SCp.phase &= ~selecting;\r\nif (CURRENT_SC->SCp.phase & aborted) {\r\nDPRINTK(debug_selection, DEBUG_LEAD "aborted\n", CMDINFO(CURRENT_SC));\r\ndone(shpnt, DID_ABORT << 16);\r\n} else if (TESTLO(SSTAT0, SELINGO)) {\r\nDPRINTK(debug_selection, DEBUG_LEAD "arbitration not won\n", CMDINFO(CURRENT_SC));\r\ndone(shpnt, DID_BUS_BUSY << 16);\r\n} else {\r\nDPRINTK(debug_selection, DEBUG_LEAD "selection failed\n", CMDINFO(CURRENT_SC));\r\ndone(shpnt, DID_NO_CONNECT << 16);\r\n}\r\n}\r\nstatic void seldi_run(struct Scsi_Host *shpnt)\r\n{\r\nint selid;\r\nint target;\r\nunsigned long flags;\r\nSETPORT(SCSISIG, 0);\r\nSETPORT(SSTAT0, CLRSELDI);\r\nSETPORT(SSTAT1, CLRBUSFREE);\r\nSETPORT(SSTAT1, CLRPHASECHG);\r\nif(CURRENT_SC) {\r\nif(!(CURRENT_SC->SCp.phase & not_issued))\r\nprintk(ERR_LEAD "command should not have been issued yet\n", CMDINFO(CURRENT_SC));\r\nDPRINTK(debug_selection, ERR_LEAD "command requeued - reselection\n", CMDINFO(CURRENT_SC));\r\nDO_LOCK(flags);\r\nappend_SC(&ISSUE_SC, CURRENT_SC);\r\nDO_UNLOCK(flags);\r\nCURRENT_SC = NULL;\r\n}\r\nif(!DISCONNECTED_SC) {\r\nDPRINTK(debug_selection, DEBUG_LEAD "unexpected SELDI ", CMDINFO(CURRENT_SC));\r\nreturn;\r\n}\r\nRECONN_TARGET=-1;\r\nselid = GETPORT(SELID) & ~(1 << shpnt->this_id);\r\nif (selid==0) {\r\nprintk("aha152x%d: target id unknown (%02x)\n", HOSTNO, selid);\r\nreturn;\r\n}\r\nfor(target=7; !(selid & (1 << target)); target--)\r\n;\r\nif(selid & ~(1 << target)) {\r\nprintk("aha152x%d: multiple targets reconnected (%02x)\n",\r\nHOSTNO, selid);\r\n}\r\nSETPORT(SCSIID, (shpnt->this_id << OID_) | target);\r\nSETPORT(SCSISEQ, 0);\r\nSETRATE(HOSTDATA(shpnt)->syncrate[target]);\r\nRECONN_TARGET=target;\r\nDPRINTK(debug_selection, DEBUG_LEAD "target %d reselected (%02x).\n", CMDINFO(CURRENT_SC), target, selid);\r\n}\r\nstatic void msgi_run(struct Scsi_Host *shpnt)\r\n{\r\nfor(;;) {\r\nint sstat1 = GETPORT(SSTAT1);\r\nif(sstat1 & (PHASECHG|PHASEMIS|BUSFREE) || !(sstat1 & REQINIT))\r\nreturn;\r\nif(TESTLO(SSTAT0,SPIORDY)) {\r\nDPRINTK(debug_msgi, DEBUG_LEAD "!SPIORDY\n", CMDINFO(CURRENT_SC));\r\nreturn;\r\n}\r\nADDMSGI(GETPORT(SCSIDAT));\r\n#if defined(AHA152X_DEBUG)\r\nif (HOSTDATA(shpnt)->debug & debug_msgi) {\r\nprintk(INFO_LEAD "inbound message %02x ", CMDINFO(CURRENT_SC), MSGI(0));\r\nspi_print_msg(&MSGI(0));\r\nprintk("\n");\r\n}\r\n#endif\r\nif(!CURRENT_SC) {\r\nif(LASTSTATE!=seldi) {\r\nprintk(KERN_ERR "aha152x%d: message in w/o current command not after reselection\n", HOSTNO);\r\n}\r\nif(!(MSGI(0) & IDENTIFY_BASE)) {\r\nprintk(KERN_ERR "aha152x%d: target didn't identify after reselection\n", HOSTNO);\r\ncontinue;\r\n}\r\nCURRENT_SC = remove_lun_SC(&DISCONNECTED_SC, RECONN_TARGET, MSGI(0) & 0x3f);\r\nif (!CURRENT_SC) {\r\nshow_queues(shpnt);\r\nprintk(KERN_ERR "aha152x%d: no disconnected command for target %d/%d\n", HOSTNO, RECONN_TARGET, MSGI(0) & 0x3f);\r\ncontinue;\r\n}\r\nDPRINTK(debug_msgi, DEBUG_LEAD "target reconnected\n", CMDINFO(CURRENT_SC));\r\nCURRENT_SC->SCp.Message = MSGI(0);\r\nCURRENT_SC->SCp.phase &= ~disconnected;\r\nMSGILEN=0;\r\ncontinue;\r\n}\r\nCURRENT_SC->SCp.Message = MSGI(0);\r\nswitch (MSGI(0)) {\r\ncase DISCONNECT:\r\nif (!RECONNECT)\r\nprintk(WARN_LEAD "target was not allowed to disconnect\n", CMDINFO(CURRENT_SC));\r\nCURRENT_SC->SCp.phase |= disconnected;\r\nbreak;\r\ncase COMMAND_COMPLETE:\r\nif(CURRENT_SC->SCp.phase & completed)\r\nDPRINTK(debug_msgi, DEBUG_LEAD "again COMMAND COMPLETE\n", CMDINFO(CURRENT_SC));\r\nCURRENT_SC->SCp.phase |= completed;\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nif (SYNCNEG==1) {\r\nprintk(INFO_LEAD "Synchronous Data Transfer Request was rejected\n", CMDINFO(CURRENT_SC));\r\nSYNCNEG=2;\r\n} else\r\nprintk(INFO_LEAD "inbound message (MESSAGE REJECT)\n", CMDINFO(CURRENT_SC));\r\nbreak;\r\ncase SAVE_POINTERS:\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nif(MSGILEN<2 || MSGILEN<MSGI(1)+2) {\r\ncontinue;\r\n}\r\nswitch (MSGI(2)) {\r\ncase EXTENDED_SDTR:\r\n{\r\nlong ticks;\r\nif (MSGI(1) != 3) {\r\nprintk(ERR_LEAD "SDTR message length!=3\n", CMDINFO(CURRENT_SC));\r\nbreak;\r\n}\r\nif (!HOSTDATA(shpnt)->synchronous)\r\nbreak;\r\nprintk(INFO_LEAD, CMDINFO(CURRENT_SC));\r\nspi_print_msg(&MSGI(0));\r\nprintk("\n");\r\nticks = (MSGI(3) * 4 + 49) / 50;\r\nif (syncneg) {\r\nif (ticks > 9 || MSGI(4) < 1 || MSGI(4) > 8) {\r\nADDMSGO(MESSAGE_REJECT);\r\nprintk(INFO_LEAD "received Synchronous Data Transfer Request invalid - rejected\n", CMDINFO(CURRENT_SC));\r\nbreak;\r\n}\r\nSYNCRATE |= ((ticks - 2) << 4) + MSGI(4);\r\n} else if (ticks <= 9 && MSGI(4) >= 1) {\r\nADDMSGO(EXTENDED_MESSAGE);\r\nADDMSGO(3);\r\nADDMSGO(EXTENDED_SDTR);\r\nif (ticks < 4) {\r\nticks = 4;\r\nADDMSGO(50);\r\n} else\r\nADDMSGO(MSGI(3));\r\nif (MSGI(4) > 8)\r\nMSGI(4) = 8;\r\nADDMSGO(MSGI(4));\r\nSYNCRATE |= ((ticks - 2) << 4) + MSGI(4);\r\n} else {\r\nprintk(INFO_LEAD "Synchronous Data Transfer Request too slow - Rejecting\n", CMDINFO(CURRENT_SC));\r\nADDMSGO(MESSAGE_REJECT);\r\n}\r\nSYNCNEG=2;\r\nSETRATE(SYNCRATE);\r\n}\r\nbreak;\r\ncase BUS_DEVICE_RESET:\r\n{\r\nint i;\r\nfor(i=0; i<8; i++) {\r\nHOSTDATA(shpnt)->syncrate[i]=0;\r\nHOSTDATA(shpnt)->syncneg[i]=0;\r\n}\r\n}\r\nbreak;\r\ncase EXTENDED_MODIFY_DATA_POINTER:\r\ncase EXTENDED_EXTENDED_IDENTIFY:\r\ncase EXTENDED_WDTR:\r\ndefault:\r\nADDMSGO(MESSAGE_REJECT);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nMSGILEN=0;\r\n}\r\n}\r\nstatic void msgi_end(struct Scsi_Host *shpnt)\r\n{\r\nif(MSGILEN>0)\r\nprintk(WARN_LEAD "target left before message completed (%d)\n", CMDINFO(CURRENT_SC), MSGILEN);\r\nif (MSGOLEN > 0 && !(GETPORT(SSTAT1) & BUSFREE)) {\r\nDPRINTK(debug_msgi, DEBUG_LEAD "msgo pending\n", CMDINFO(CURRENT_SC));\r\nSETPORT(SCSISIG, P_MSGI | SIG_ATNO);\r\n}\r\n}\r\nstatic void msgo_init(struct Scsi_Host *shpnt)\r\n{\r\nif(MSGOLEN==0) {\r\nif((CURRENT_SC->SCp.phase & syncneg) && SYNCNEG==2 && SYNCRATE==0) {\r\nADDMSGO(IDENTIFY(RECONNECT, CURRENT_SC->device->lun));\r\n} else {\r\nprintk(INFO_LEAD "unexpected MESSAGE OUT phase; rejecting\n", CMDINFO(CURRENT_SC));\r\nADDMSGO(MESSAGE_REJECT);\r\n}\r\n}\r\n#if defined(AHA152X_DEBUG)\r\nif(HOSTDATA(shpnt)->debug & debug_msgo) {\r\nint i;\r\nprintk(DEBUG_LEAD "messages( ", CMDINFO(CURRENT_SC));\r\nfor (i=0; i<MSGOLEN; i+=spi_print_msg(&MSGO(i)), printk(" "))\r\n;\r\nprintk(")\n");\r\n}\r\n#endif\r\n}\r\nstatic void msgo_run(struct Scsi_Host *shpnt)\r\n{\r\nif(MSGO_I==MSGOLEN)\r\nDPRINTK(debug_msgo, DEBUG_LEAD "messages all sent (%d/%d)\n", CMDINFO(CURRENT_SC), MSGO_I, MSGOLEN);\r\nwhile(MSGO_I<MSGOLEN) {\r\nDPRINTK(debug_msgo, DEBUG_LEAD "message byte %02x (%d/%d)\n", CMDINFO(CURRENT_SC), MSGO(MSGO_I), MSGO_I, MSGOLEN);\r\nif(TESTLO(SSTAT0, SPIORDY)) {\r\nDPRINTK(debug_msgo, DEBUG_LEAD "!SPIORDY\n", CMDINFO(CURRENT_SC));\r\nreturn;\r\n}\r\nif (MSGO_I==MSGOLEN-1) {\r\nSETPORT(SSTAT1, CLRATNO);\r\n}\r\nif (MSGO(MSGO_I) & IDENTIFY_BASE)\r\nCURRENT_SC->SCp.phase |= identified;\r\nif (MSGO(MSGO_I)==ABORT)\r\nCURRENT_SC->SCp.phase |= aborted;\r\nif (MSGO(MSGO_I)==BUS_DEVICE_RESET)\r\nCURRENT_SC->SCp.phase |= resetted;\r\nSETPORT(SCSIDAT, MSGO(MSGO_I++));\r\n}\r\n}\r\nstatic void msgo_end(struct Scsi_Host *shpnt)\r\n{\r\nif(MSGO_I<MSGOLEN) {\r\nprintk(ERR_LEAD "message sent incompletely (%d/%d)\n", CMDINFO(CURRENT_SC), MSGO_I, MSGOLEN);\r\nif(SYNCNEG==1) {\r\nprintk(INFO_LEAD "Synchronous Data Transfer Request was rejected\n", CMDINFO(CURRENT_SC));\r\nSYNCNEG=2;\r\n}\r\n}\r\nMSGO_I = 0;\r\nMSGOLEN = 0;\r\n}\r\nstatic void cmd_init(struct Scsi_Host *shpnt)\r\n{\r\nif (CURRENT_SC->SCp.sent_command) {\r\nprintk(ERR_LEAD "command already sent\n", CMDINFO(CURRENT_SC));\r\ndone(shpnt, DID_ERROR << 16);\r\nreturn;\r\n}\r\n#if defined(AHA152X_DEBUG)\r\nif (HOSTDATA(shpnt)->debug & debug_cmd) {\r\nprintk(DEBUG_LEAD "cmd_init: ", CMDINFO(CURRENT_SC));\r\n__scsi_print_command(CURRENT_SC->cmnd);\r\n}\r\n#endif\r\nCMD_I=0;\r\n}\r\nstatic void cmd_run(struct Scsi_Host *shpnt)\r\n{\r\nif(CMD_I==CURRENT_SC->cmd_len) {\r\nDPRINTK(debug_cmd, DEBUG_LEAD "command already completely sent (%d/%d)", CMDINFO(CURRENT_SC), CMD_I, CURRENT_SC->cmd_len);\r\ndisp_ports(shpnt);\r\n}\r\nwhile(CMD_I<CURRENT_SC->cmd_len) {\r\nDPRINTK(debug_cmd, DEBUG_LEAD "command byte %02x (%d/%d)\n", CMDINFO(CURRENT_SC), CURRENT_SC->cmnd[CMD_I], CMD_I, CURRENT_SC->cmd_len);\r\nif(TESTLO(SSTAT0, SPIORDY)) {\r\nDPRINTK(debug_cmd, DEBUG_LEAD "!SPIORDY\n", CMDINFO(CURRENT_SC));\r\nreturn;\r\n}\r\nSETPORT(SCSIDAT, CURRENT_SC->cmnd[CMD_I++]);\r\n}\r\n}\r\nstatic void cmd_end(struct Scsi_Host *shpnt)\r\n{\r\nif(CMD_I<CURRENT_SC->cmd_len)\r\nprintk(ERR_LEAD "command sent incompletely (%d/%d)\n", CMDINFO(CURRENT_SC), CMD_I, CURRENT_SC->cmd_len);\r\nelse\r\nCURRENT_SC->SCp.sent_command++;\r\n}\r\nstatic void status_run(struct Scsi_Host *shpnt)\r\n{\r\nif(TESTLO(SSTAT0,SPIORDY)) {\r\nDPRINTK(debug_status, DEBUG_LEAD "!SPIORDY\n", CMDINFO(CURRENT_SC));\r\nreturn;\r\n}\r\nCURRENT_SC->SCp.Status = GETPORT(SCSIDAT);\r\n#if defined(AHA152X_DEBUG)\r\nif (HOSTDATA(shpnt)->debug & debug_status) {\r\nprintk(DEBUG_LEAD "inbound status %02x ", CMDINFO(CURRENT_SC), CURRENT_SC->SCp.Status);\r\nscsi_print_status(CURRENT_SC->SCp.Status);\r\nprintk("\n");\r\n}\r\n#endif\r\n}\r\nstatic void datai_init(struct Scsi_Host *shpnt)\r\n{\r\nSETPORT(DMACNTRL0, RSTFIFO);\r\nSETPORT(DMACNTRL0, RSTFIFO|ENDMA);\r\nSETPORT(SXFRCTL0, CH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1|SCSIEN|DMAEN);\r\nSETPORT(SIMODE0, 0);\r\nSETPORT(SIMODE1, ENSCSIPERR | ENSCSIRST | ENPHASEMIS | ENBUSFREE);\r\nDATA_LEN=0;\r\nDPRINTK(debug_datai,\r\nDEBUG_LEAD "datai_init: request_bufflen=%d resid=%d\n",\r\nCMDINFO(CURRENT_SC), scsi_bufflen(CURRENT_SC),\r\nscsi_get_resid(CURRENT_SC));\r\n}\r\nstatic void datai_run(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long the_time;\r\nint fifodata, data_count;\r\nwhile(TESTLO(DMASTAT, INTSTAT) || TESTLO(DMASTAT, DFIFOEMP) || TESTLO(SSTAT2, SEMPTY)) {\r\nthe_time=jiffies + 100*HZ;\r\nwhile(TESTLO(DMASTAT, DFIFOFULL|INTSTAT) && time_before(jiffies,the_time))\r\nbarrier();\r\nif(TESTLO(DMASTAT, DFIFOFULL|INTSTAT)) {\r\nprintk(ERR_LEAD "datai timeout", CMDINFO(CURRENT_SC));\r\ndisp_ports(shpnt);\r\nbreak;\r\n}\r\nif(TESTHI(DMASTAT, DFIFOFULL)) {\r\nfifodata = 128;\r\n} else {\r\nthe_time=jiffies + 100*HZ;\r\nwhile(TESTLO(SSTAT2, SEMPTY) && time_before(jiffies,the_time))\r\nbarrier();\r\nif(TESTLO(SSTAT2, SEMPTY)) {\r\nprintk(ERR_LEAD "datai sempty timeout", CMDINFO(CURRENT_SC));\r\ndisp_ports(shpnt);\r\nbreak;\r\n}\r\nfifodata = GETPORT(FIFOSTAT);\r\n}\r\nif(CURRENT_SC->SCp.this_residual>0) {\r\nwhile(fifodata>0 && CURRENT_SC->SCp.this_residual>0) {\r\ndata_count = fifodata>CURRENT_SC->SCp.this_residual ?\r\nCURRENT_SC->SCp.this_residual :\r\nfifodata;\r\nfifodata -= data_count;\r\nif(data_count & 1) {\r\nDPRINTK(debug_datai, DEBUG_LEAD "8bit\n", CMDINFO(CURRENT_SC));\r\nSETPORT(DMACNTRL0, ENDMA|_8BIT);\r\n*CURRENT_SC->SCp.ptr++ = GETPORT(DATAPORT);\r\nCURRENT_SC->SCp.this_residual--;\r\nDATA_LEN++;\r\nSETPORT(DMACNTRL0, ENDMA);\r\n}\r\nif(data_count > 1) {\r\nDPRINTK(debug_datai, DEBUG_LEAD "16bit(%d)\n", CMDINFO(CURRENT_SC), data_count);\r\ndata_count >>= 1;\r\ninsw(DATAPORT, CURRENT_SC->SCp.ptr, data_count);\r\nCURRENT_SC->SCp.ptr += 2 * data_count;\r\nCURRENT_SC->SCp.this_residual -= 2 * data_count;\r\nDATA_LEN += 2 * data_count;\r\n}\r\nif(CURRENT_SC->SCp.this_residual==0 && CURRENT_SC->SCp.buffers_residual>0) {\r\nCURRENT_SC->SCp.buffers_residual--;\r\nCURRENT_SC->SCp.buffer++;\r\nCURRENT_SC->SCp.ptr = SG_ADDRESS(CURRENT_SC->SCp.buffer);\r\nCURRENT_SC->SCp.this_residual = CURRENT_SC->SCp.buffer->length;\r\n}\r\n}\r\n} else if(fifodata>0) {\r\nprintk(ERR_LEAD "no buffers left for %d(%d) bytes (data overrun!?)\n", CMDINFO(CURRENT_SC), fifodata, GETPORT(FIFOSTAT));\r\nSETPORT(DMACNTRL0, ENDMA|_8BIT);\r\nwhile(fifodata>0) {\r\nint data;\r\ndata=GETPORT(DATAPORT);\r\nDPRINTK(debug_datai, DEBUG_LEAD "data=%02x\n", CMDINFO(CURRENT_SC), data);\r\nfifodata--;\r\nDATA_LEN++;\r\n}\r\nSETPORT(DMACNTRL0, ENDMA|_8BIT);\r\n}\r\n}\r\nif(TESTLO(DMASTAT, INTSTAT) ||\r\nTESTLO(DMASTAT, DFIFOEMP) ||\r\nTESTLO(SSTAT2, SEMPTY) ||\r\nGETPORT(FIFOSTAT)>0) {\r\nprintk(ERR_LEAD "fifos should be empty and phase should have changed\n", CMDINFO(CURRENT_SC));\r\ndisp_ports(shpnt);\r\n}\r\nif(DATA_LEN!=GETSTCNT()) {\r\nprintk(ERR_LEAD\r\n"manual transfer count differs from automatic (count=%d;stcnt=%d;diff=%d;fifostat=%d)",\r\nCMDINFO(CURRENT_SC), DATA_LEN, GETSTCNT(), GETSTCNT()-DATA_LEN, GETPORT(FIFOSTAT));\r\ndisp_ports(shpnt);\r\nmdelay(10000);\r\n}\r\n}\r\nstatic void datai_end(struct Scsi_Host *shpnt)\r\n{\r\nCMD_INC_RESID(CURRENT_SC, -GETSTCNT());\r\nDPRINTK(debug_datai,\r\nDEBUG_LEAD "datai_end: request_bufflen=%d resid=%d stcnt=%d\n",\r\nCMDINFO(CURRENT_SC), scsi_bufflen(CURRENT_SC),\r\nscsi_get_resid(CURRENT_SC), GETSTCNT());\r\nSETPORT(SXFRCTL0, CH1|CLRSTCNT);\r\nSETPORT(DMACNTRL0, 0);\r\n}\r\nstatic void datao_init(struct Scsi_Host *shpnt)\r\n{\r\nSETPORT(DMACNTRL0, WRITE_READ | RSTFIFO);\r\nSETPORT(DMACNTRL0, WRITE_READ | ENDMA);\r\nSETPORT(SXFRCTL0, CH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1|SCSIEN|DMAEN);\r\nSETPORT(SIMODE0, 0);\r\nSETPORT(SIMODE1, ENSCSIPERR | ENSCSIRST | ENPHASEMIS | ENBUSFREE );\r\nDATA_LEN = scsi_get_resid(CURRENT_SC);\r\nDPRINTK(debug_datao,\r\nDEBUG_LEAD "datao_init: request_bufflen=%d; resid=%d\n",\r\nCMDINFO(CURRENT_SC), scsi_bufflen(CURRENT_SC),\r\nscsi_get_resid(CURRENT_SC));\r\n}\r\nstatic void datao_run(struct Scsi_Host *shpnt)\r\n{\r\nunsigned long the_time;\r\nint data_count;\r\nwhile(TESTLO(DMASTAT, INTSTAT) && CURRENT_SC->SCp.this_residual>0) {\r\ndata_count = 128;\r\nif(data_count > CURRENT_SC->SCp.this_residual)\r\ndata_count=CURRENT_SC->SCp.this_residual;\r\nif(TESTLO(DMASTAT, DFIFOEMP)) {\r\nprintk(ERR_LEAD "datao fifo not empty (%d)", CMDINFO(CURRENT_SC), GETPORT(FIFOSTAT));\r\ndisp_ports(shpnt);\r\nbreak;\r\n}\r\nif(data_count & 1) {\r\nSETPORT(DMACNTRL0,WRITE_READ|ENDMA|_8BIT);\r\nSETPORT(DATAPORT, *CURRENT_SC->SCp.ptr++);\r\nCURRENT_SC->SCp.this_residual--;\r\nCMD_INC_RESID(CURRENT_SC, -1);\r\nSETPORT(DMACNTRL0,WRITE_READ|ENDMA);\r\n}\r\nif(data_count > 1) {\r\ndata_count >>= 1;\r\noutsw(DATAPORT, CURRENT_SC->SCp.ptr, data_count);\r\nCURRENT_SC->SCp.ptr += 2 * data_count;\r\nCURRENT_SC->SCp.this_residual -= 2 * data_count;\r\nCMD_INC_RESID(CURRENT_SC, -2 * data_count);\r\n}\r\nif(CURRENT_SC->SCp.this_residual==0 && CURRENT_SC->SCp.buffers_residual>0) {\r\nCURRENT_SC->SCp.buffers_residual--;\r\nCURRENT_SC->SCp.buffer++;\r\nCURRENT_SC->SCp.ptr = SG_ADDRESS(CURRENT_SC->SCp.buffer);\r\nCURRENT_SC->SCp.this_residual = CURRENT_SC->SCp.buffer->length;\r\n}\r\nthe_time=jiffies + 100*HZ;\r\nwhile(TESTLO(DMASTAT, DFIFOEMP|INTSTAT) && time_before(jiffies,the_time))\r\nbarrier();\r\nif(TESTLO(DMASTAT, DFIFOEMP|INTSTAT)) {\r\nprintk(ERR_LEAD "dataout timeout", CMDINFO(CURRENT_SC));\r\ndisp_ports(shpnt);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void datao_end(struct Scsi_Host *shpnt)\r\n{\r\nif(TESTLO(DMASTAT, DFIFOEMP)) {\r\nint data_count = (DATA_LEN - scsi_get_resid(CURRENT_SC)) -\r\nGETSTCNT();\r\nDPRINTK(debug_datao, DEBUG_LEAD "datao: %d bytes to resend (%d written, %d transferred)\n",\r\nCMDINFO(CURRENT_SC),\r\ndata_count,\r\nDATA_LEN - scsi_get_resid(CURRENT_SC),\r\nGETSTCNT());\r\nCMD_INC_RESID(CURRENT_SC, data_count);\r\ndata_count -= CURRENT_SC->SCp.ptr -\r\nSG_ADDRESS(CURRENT_SC->SCp.buffer);\r\nwhile(data_count>0) {\r\nCURRENT_SC->SCp.buffer--;\r\nCURRENT_SC->SCp.buffers_residual++;\r\ndata_count -= CURRENT_SC->SCp.buffer->length;\r\n}\r\nCURRENT_SC->SCp.ptr = SG_ADDRESS(CURRENT_SC->SCp.buffer) -\r\ndata_count;\r\nCURRENT_SC->SCp.this_residual = CURRENT_SC->SCp.buffer->length +\r\ndata_count;\r\n}\r\nDPRINTK(debug_datao, DEBUG_LEAD "datao_end: request_bufflen=%d; resid=%d; stcnt=%d\n",\r\nCMDINFO(CURRENT_SC),\r\nscsi_bufflen(CURRENT_SC),\r\nscsi_get_resid(CURRENT_SC),\r\nGETSTCNT());\r\nSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\r\nSETPORT(SXFRCTL0, CH1);\r\nSETPORT(DMACNTRL0, 0);\r\n}\r\nstatic int update_state(struct Scsi_Host *shpnt)\r\n{\r\nint dataphase=0;\r\nunsigned int stat0 = GETPORT(SSTAT0);\r\nunsigned int stat1 = GETPORT(SSTAT1);\r\nPREVSTATE = STATE;\r\nSTATE=unknown;\r\nif(stat1 & SCSIRSTI) {\r\nSTATE=rsti;\r\nSETPORT(SCSISEQ,0);\r\nSETPORT(SSTAT1,SCSIRSTI);\r\n} else if(stat0 & SELDI && PREVSTATE==busfree) {\r\nSTATE=seldi;\r\n} else if(stat0 & SELDO && CURRENT_SC && (CURRENT_SC->SCp.phase & selecting)) {\r\nSTATE=seldo;\r\n} else if(stat1 & SELTO) {\r\nSTATE=selto;\r\n} else if(stat1 & BUSFREE) {\r\nSTATE=busfree;\r\nSETPORT(SSTAT1,BUSFREE);\r\n} else if(stat1 & SCSIPERR) {\r\nSTATE=parerr;\r\nSETPORT(SSTAT1,SCSIPERR);\r\n} else if(stat1 & REQINIT) {\r\nswitch(GETPORT(SCSISIG) & P_MASK) {\r\ncase P_MSGI: STATE=msgi; break;\r\ncase P_MSGO: STATE=msgo; break;\r\ncase P_DATAO: STATE=datao; break;\r\ncase P_DATAI: STATE=datai; break;\r\ncase P_STATUS: STATE=status; break;\r\ncase P_CMD: STATE=cmd; break;\r\n}\r\ndataphase=1;\r\n}\r\nif((stat0 & SELDI) && STATE!=seldi && !dataphase) {\r\nprintk(INFO_LEAD "reselection missed?", CMDINFO(CURRENT_SC));\r\ndisp_ports(shpnt);\r\n}\r\nif(STATE!=PREVSTATE) {\r\nLASTSTATE=PREVSTATE;\r\n}\r\nreturn dataphase;\r\n}\r\nstatic void parerr_run(struct Scsi_Host *shpnt)\r\n{\r\nprintk(ERR_LEAD "parity error\n", CMDINFO(CURRENT_SC));\r\ndone(shpnt, DID_PARITY << 16);\r\n}\r\nstatic void rsti_run(struct Scsi_Host *shpnt)\r\n{\r\nScsi_Cmnd *ptr;\r\nprintk(KERN_NOTICE "aha152x%d: scsi reset in\n", HOSTNO);\r\nptr=DISCONNECTED_SC;\r\nwhile(ptr) {\r\nScsi_Cmnd *next = SCNEXT(ptr);\r\nif (!ptr->device->soft_reset) {\r\nremove_SC(&DISCONNECTED_SC, ptr);\r\nkfree(ptr->host_scribble);\r\nptr->host_scribble=NULL;\r\nptr->result = DID_RESET << 16;\r\nptr->scsi_done(ptr);\r\n}\r\nptr = next;\r\n}\r\nif(CURRENT_SC && !CURRENT_SC->device->soft_reset)\r\ndone(shpnt, DID_RESET << 16 );\r\n}\r\nstatic void is_complete(struct Scsi_Host *shpnt)\r\n{\r\nint dataphase;\r\nunsigned long flags;\r\nint pending;\r\nif(!shpnt)\r\nreturn;\r\nDO_LOCK(flags);\r\nif( HOSTDATA(shpnt)->service==0 ) {\r\nDO_UNLOCK(flags);\r\nreturn;\r\n}\r\nHOSTDATA(shpnt)->service = 0;\r\nif(HOSTDATA(shpnt)->in_intr) {\r\nDO_UNLOCK(flags);\r\naha152x_error(shpnt, "bottom-half already running!?");\r\n}\r\nHOSTDATA(shpnt)->in_intr++;\r\ndo {\r\nunsigned long start = jiffies;\r\nDO_UNLOCK(flags);\r\ndataphase=update_state(shpnt);\r\nDPRINTK(debug_phases, LEAD "start %s %s(%s)\n", CMDINFO(CURRENT_SC), states[STATE].name, states[PREVSTATE].name, states[LASTSTATE].name);\r\nif(PREVSTATE!=STATE && states[PREVSTATE].end)\r\nstates[PREVSTATE].end(shpnt);\r\nif(states[PREVSTATE].spio && !states[STATE].spio) {\r\nSETPORT(SXFRCTL0, CH1);\r\nSETPORT(DMACNTRL0, 0);\r\nif(CURRENT_SC)\r\nCURRENT_SC->SCp.phase &= ~spiordy;\r\n}\r\nif(dataphase) {\r\nSETPORT(SSTAT0, REQINIT);\r\nSETPORT(SCSISIG, GETPORT(SCSISIG) & P_MASK);\r\nSETPORT(SSTAT1, PHASECHG);\r\n}\r\nif(!states[PREVSTATE].spio && states[STATE].spio) {\r\nSETPORT(DMACNTRL0, 0);\r\nSETPORT(SXFRCTL0, CH1|SPIOEN);\r\nif(CURRENT_SC)\r\nCURRENT_SC->SCp.phase |= spiordy;\r\n}\r\nif(PREVSTATE!=STATE && states[STATE].init)\r\nstates[STATE].init(shpnt);\r\nif(states[STATE].run)\r\nstates[STATE].run(shpnt);\r\nelse\r\nprintk(ERR_LEAD "unexpected state (%x)\n", CMDINFO(CURRENT_SC), STATE);\r\nDO_LOCK(flags);\r\npending=setup_expected_interrupts(shpnt);\r\n#if defined(AHA152X_STAT)\r\nHOSTDATA(shpnt)->count[STATE]++;\r\nif(PREVSTATE!=STATE)\r\nHOSTDATA(shpnt)->count_trans[STATE]++;\r\nHOSTDATA(shpnt)->time[STATE] += jiffies-start;\r\n#endif\r\nDPRINTK(debug_phases, LEAD "end %s %s(%s)\n", CMDINFO(CURRENT_SC), states[STATE].name, states[PREVSTATE].name, states[LASTSTATE].name);\r\n} while(pending);\r\nHOSTDATA(shpnt)->in_intr--;\r\nSETBITS(DMACNTRL0, INTEN);\r\nDO_UNLOCK(flags);\r\n}\r\nstatic void aha152x_error(struct Scsi_Host *shpnt, char *msg)\r\n{\r\nprintk(KERN_EMERG "\naha152x%d: %s\n", HOSTNO, msg);\r\nshow_queues(shpnt);\r\npanic("aha152x panic\n");\r\n}\r\nstatic void disp_ports(struct Scsi_Host *shpnt)\r\n{\r\n#if defined(AHA152X_DEBUG)\r\nint s;\r\nprintk("\n%s: %s(%s) ",\r\nCURRENT_SC ? "busy" : "waiting",\r\nstates[STATE].name,\r\nstates[PREVSTATE].name);\r\ns = GETPORT(SCSISEQ);\r\nprintk("SCSISEQ( ");\r\nif (s & TEMODEO)\r\nprintk("TARGET MODE ");\r\nif (s & ENSELO)\r\nprintk("SELO ");\r\nif (s & ENSELI)\r\nprintk("SELI ");\r\nif (s & ENRESELI)\r\nprintk("RESELI ");\r\nif (s & ENAUTOATNO)\r\nprintk("AUTOATNO ");\r\nif (s & ENAUTOATNI)\r\nprintk("AUTOATNI ");\r\nif (s & ENAUTOATNP)\r\nprintk("AUTOATNP ");\r\nif (s & SCSIRSTO)\r\nprintk("SCSIRSTO ");\r\nprintk(");");\r\nprintk(" SCSISIG(");\r\ns = GETPORT(SCSISIG);\r\nswitch (s & P_MASK) {\r\ncase P_DATAO:\r\nprintk("DATA OUT");\r\nbreak;\r\ncase P_DATAI:\r\nprintk("DATA IN");\r\nbreak;\r\ncase P_CMD:\r\nprintk("COMMAND");\r\nbreak;\r\ncase P_STATUS:\r\nprintk("STATUS");\r\nbreak;\r\ncase P_MSGO:\r\nprintk("MESSAGE OUT");\r\nbreak;\r\ncase P_MSGI:\r\nprintk("MESSAGE IN");\r\nbreak;\r\ndefault:\r\nprintk("*invalid*");\r\nbreak;\r\n}\r\nprintk("); ");\r\nprintk("INTSTAT (%s); ", TESTHI(DMASTAT, INTSTAT) ? "hi" : "lo");\r\nprintk("SSTAT( ");\r\ns = GETPORT(SSTAT0);\r\nif (s & TARGET)\r\nprintk("TARGET ");\r\nif (s & SELDO)\r\nprintk("SELDO ");\r\nif (s & SELDI)\r\nprintk("SELDI ");\r\nif (s & SELINGO)\r\nprintk("SELINGO ");\r\nif (s & SWRAP)\r\nprintk("SWRAP ");\r\nif (s & SDONE)\r\nprintk("SDONE ");\r\nif (s & SPIORDY)\r\nprintk("SPIORDY ");\r\nif (s & DMADONE)\r\nprintk("DMADONE ");\r\ns = GETPORT(SSTAT1);\r\nif (s & SELTO)\r\nprintk("SELTO ");\r\nif (s & ATNTARG)\r\nprintk("ATNTARG ");\r\nif (s & SCSIRSTI)\r\nprintk("SCSIRSTI ");\r\nif (s & PHASEMIS)\r\nprintk("PHASEMIS ");\r\nif (s & BUSFREE)\r\nprintk("BUSFREE ");\r\nif (s & SCSIPERR)\r\nprintk("SCSIPERR ");\r\nif (s & PHASECHG)\r\nprintk("PHASECHG ");\r\nif (s & REQINIT)\r\nprintk("REQINIT ");\r\nprintk("); ");\r\nprintk("SSTAT( ");\r\ns = GETPORT(SSTAT0) & GETPORT(SIMODE0);\r\nif (s & TARGET)\r\nprintk("TARGET ");\r\nif (s & SELDO)\r\nprintk("SELDO ");\r\nif (s & SELDI)\r\nprintk("SELDI ");\r\nif (s & SELINGO)\r\nprintk("SELINGO ");\r\nif (s & SWRAP)\r\nprintk("SWRAP ");\r\nif (s & SDONE)\r\nprintk("SDONE ");\r\nif (s & SPIORDY)\r\nprintk("SPIORDY ");\r\nif (s & DMADONE)\r\nprintk("DMADONE ");\r\ns = GETPORT(SSTAT1) & GETPORT(SIMODE1);\r\nif (s & SELTO)\r\nprintk("SELTO ");\r\nif (s & ATNTARG)\r\nprintk("ATNTARG ");\r\nif (s & SCSIRSTI)\r\nprintk("SCSIRSTI ");\r\nif (s & PHASEMIS)\r\nprintk("PHASEMIS ");\r\nif (s & BUSFREE)\r\nprintk("BUSFREE ");\r\nif (s & SCSIPERR)\r\nprintk("SCSIPERR ");\r\nif (s & PHASECHG)\r\nprintk("PHASECHG ");\r\nif (s & REQINIT)\r\nprintk("REQINIT ");\r\nprintk("); ");\r\nprintk("SXFRCTL0( ");\r\ns = GETPORT(SXFRCTL0);\r\nif (s & SCSIEN)\r\nprintk("SCSIEN ");\r\nif (s & DMAEN)\r\nprintk("DMAEN ");\r\nif (s & CH1)\r\nprintk("CH1 ");\r\nif (s & CLRSTCNT)\r\nprintk("CLRSTCNT ");\r\nif (s & SPIOEN)\r\nprintk("SPIOEN ");\r\nif (s & CLRCH1)\r\nprintk("CLRCH1 ");\r\nprintk("); ");\r\nprintk("SIGNAL( ");\r\ns = GETPORT(SCSISIG);\r\nif (s & SIG_ATNI)\r\nprintk("ATNI ");\r\nif (s & SIG_SELI)\r\nprintk("SELI ");\r\nif (s & SIG_BSYI)\r\nprintk("BSYI ");\r\nif (s & SIG_REQI)\r\nprintk("REQI ");\r\nif (s & SIG_ACKI)\r\nprintk("ACKI ");\r\nprintk("); ");\r\nprintk("SELID (%02x), ", GETPORT(SELID));\r\nprintk("STCNT (%d), ", GETSTCNT());\r\nprintk("SSTAT2( ");\r\ns = GETPORT(SSTAT2);\r\nif (s & SOFFSET)\r\nprintk("SOFFSET ");\r\nif (s & SEMPTY)\r\nprintk("SEMPTY ");\r\nif (s & SFULL)\r\nprintk("SFULL ");\r\nprintk("); SFCNT (%d); ", s & (SFULL | SFCNT));\r\ns = GETPORT(SSTAT3);\r\nprintk("SCSICNT (%d), OFFCNT(%d), ", (s & 0xf0) >> 4, s & 0x0f);\r\nprintk("SSTAT4( ");\r\ns = GETPORT(SSTAT4);\r\nif (s & SYNCERR)\r\nprintk("SYNCERR ");\r\nif (s & FWERR)\r\nprintk("FWERR ");\r\nif (s & FRERR)\r\nprintk("FRERR ");\r\nprintk("); ");\r\nprintk("DMACNTRL0( ");\r\ns = GETPORT(DMACNTRL0);\r\nprintk("%s ", s & _8BIT ? "8BIT" : "16BIT");\r\nprintk("%s ", s & DMA ? "DMA" : "PIO");\r\nprintk("%s ", s & WRITE_READ ? "WRITE" : "READ");\r\nif (s & ENDMA)\r\nprintk("ENDMA ");\r\nif (s & INTEN)\r\nprintk("INTEN ");\r\nif (s & RSTFIFO)\r\nprintk("RSTFIFO ");\r\nif (s & SWINT)\r\nprintk("SWINT ");\r\nprintk("); ");\r\nprintk("DMASTAT( ");\r\ns = GETPORT(DMASTAT);\r\nif (s & ATDONE)\r\nprintk("ATDONE ");\r\nif (s & WORDRDY)\r\nprintk("WORDRDY ");\r\nif (s & DFIFOFULL)\r\nprintk("DFIFOFULL ");\r\nif (s & DFIFOEMP)\r\nprintk("DFIFOEMP ");\r\nprintk(")\n");\r\n#endif\r\n}\r\nstatic void disp_enintr(struct Scsi_Host *shpnt)\r\n{\r\nint s;\r\nprintk(KERN_DEBUG "enabled interrupts ( ");\r\ns = GETPORT(SIMODE0);\r\nif (s & ENSELDO)\r\nprintk("ENSELDO ");\r\nif (s & ENSELDI)\r\nprintk("ENSELDI ");\r\nif (s & ENSELINGO)\r\nprintk("ENSELINGO ");\r\nif (s & ENSWRAP)\r\nprintk("ENSWRAP ");\r\nif (s & ENSDONE)\r\nprintk("ENSDONE ");\r\nif (s & ENSPIORDY)\r\nprintk("ENSPIORDY ");\r\nif (s & ENDMADONE)\r\nprintk("ENDMADONE ");\r\ns = GETPORT(SIMODE1);\r\nif (s & ENSELTIMO)\r\nprintk("ENSELTIMO ");\r\nif (s & ENATNTARG)\r\nprintk("ENATNTARG ");\r\nif (s & ENPHASEMIS)\r\nprintk("ENPHASEMIS ");\r\nif (s & ENBUSFREE)\r\nprintk("ENBUSFREE ");\r\nif (s & ENSCSIPERR)\r\nprintk("ENSCSIPERR ");\r\nif (s & ENPHASECHG)\r\nprintk("ENPHASECHG ");\r\nif (s & ENREQINIT)\r\nprintk("ENREQINIT ");\r\nprintk(")\n");\r\n}\r\nstatic void show_command(Scsi_Cmnd *ptr)\r\n{\r\nscmd_printk(KERN_DEBUG, ptr, "%p: cmnd=(", ptr);\r\n__scsi_print_command(ptr->cmnd);\r\nprintk(KERN_DEBUG "); request_bufflen=%d; resid=%d; phase |",\r\nscsi_bufflen(ptr), scsi_get_resid(ptr));\r\nif (ptr->SCp.phase & not_issued)\r\nprintk("not issued|");\r\nif (ptr->SCp.phase & selecting)\r\nprintk("selecting|");\r\nif (ptr->SCp.phase & identified)\r\nprintk("identified|");\r\nif (ptr->SCp.phase & disconnected)\r\nprintk("disconnected|");\r\nif (ptr->SCp.phase & completed)\r\nprintk("completed|");\r\nif (ptr->SCp.phase & spiordy)\r\nprintk("spiordy|");\r\nif (ptr->SCp.phase & syncneg)\r\nprintk("syncneg|");\r\nif (ptr->SCp.phase & aborted)\r\nprintk("aborted|");\r\nif (ptr->SCp.phase & resetted)\r\nprintk("resetted|");\r\nif( SCDATA(ptr) ) {\r\nprintk("; next=0x%p\n", SCNEXT(ptr));\r\n} else {\r\nprintk("; next=(host scribble NULL)\n");\r\n}\r\n}\r\nstatic void show_queues(struct Scsi_Host *shpnt)\r\n{\r\nScsi_Cmnd *ptr;\r\nunsigned long flags;\r\nDO_LOCK(flags);\r\nprintk(KERN_DEBUG "\nqueue status:\nissue_SC:\n");\r\nfor (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr))\r\nshow_command(ptr);\r\nDO_UNLOCK(flags);\r\nprintk(KERN_DEBUG "current_SC:\n");\r\nif (CURRENT_SC)\r\nshow_command(CURRENT_SC);\r\nelse\r\nprintk(KERN_DEBUG "none\n");\r\nprintk(KERN_DEBUG "disconnected_SC:\n");\r\nfor (ptr = DISCONNECTED_SC; ptr; ptr = SCDATA(ptr) ? SCNEXT(ptr) : NULL)\r\nshow_command(ptr);\r\ndisp_ports(shpnt);\r\ndisp_enintr(shpnt);\r\n}\r\nstatic void get_command(struct seq_file *m, Scsi_Cmnd * ptr)\r\n{\r\nint i;\r\nSPRINTF("%p: target=%d; lun=%d; cmnd=( ",\r\nptr, ptr->device->id, ptr->device->lun);\r\nfor (i = 0; i < COMMAND_SIZE(ptr->cmnd[0]); i++)\r\nSPRINTF("0x%02x ", ptr->cmnd[i]);\r\nSPRINTF("); resid=%d; residual=%d; buffers=%d; phase |",\r\nscsi_get_resid(ptr), ptr->SCp.this_residual,\r\nptr->SCp.buffers_residual);\r\nif (ptr->SCp.phase & not_issued)\r\nSPRINTF("not issued|");\r\nif (ptr->SCp.phase & selecting)\r\nSPRINTF("selecting|");\r\nif (ptr->SCp.phase & disconnected)\r\nSPRINTF("disconnected|");\r\nif (ptr->SCp.phase & aborted)\r\nSPRINTF("aborted|");\r\nif (ptr->SCp.phase & identified)\r\nSPRINTF("identified|");\r\nif (ptr->SCp.phase & completed)\r\nSPRINTF("completed|");\r\nif (ptr->SCp.phase & spiordy)\r\nSPRINTF("spiordy|");\r\nif (ptr->SCp.phase & syncneg)\r\nSPRINTF("syncneg|");\r\nSPRINTF("; next=0x%p\n", SCNEXT(ptr));\r\n}\r\nstatic void get_ports(struct seq_file *m, struct Scsi_Host *shpnt)\r\n{\r\nint s;\r\nSPRINTF("\n%s: %s(%s) ", CURRENT_SC ? "on bus" : "waiting", states[STATE].name, states[PREVSTATE].name);\r\ns = GETPORT(SCSISEQ);\r\nSPRINTF("SCSISEQ( ");\r\nif (s & TEMODEO)\r\nSPRINTF("TARGET MODE ");\r\nif (s & ENSELO)\r\nSPRINTF("SELO ");\r\nif (s & ENSELI)\r\nSPRINTF("SELI ");\r\nif (s & ENRESELI)\r\nSPRINTF("RESELI ");\r\nif (s & ENAUTOATNO)\r\nSPRINTF("AUTOATNO ");\r\nif (s & ENAUTOATNI)\r\nSPRINTF("AUTOATNI ");\r\nif (s & ENAUTOATNP)\r\nSPRINTF("AUTOATNP ");\r\nif (s & SCSIRSTO)\r\nSPRINTF("SCSIRSTO ");\r\nSPRINTF(");");\r\nSPRINTF(" SCSISIG(");\r\ns = GETPORT(SCSISIG);\r\nswitch (s & P_MASK) {\r\ncase P_DATAO:\r\nSPRINTF("DATA OUT");\r\nbreak;\r\ncase P_DATAI:\r\nSPRINTF("DATA IN");\r\nbreak;\r\ncase P_CMD:\r\nSPRINTF("COMMAND");\r\nbreak;\r\ncase P_STATUS:\r\nSPRINTF("STATUS");\r\nbreak;\r\ncase P_MSGO:\r\nSPRINTF("MESSAGE OUT");\r\nbreak;\r\ncase P_MSGI:\r\nSPRINTF("MESSAGE IN");\r\nbreak;\r\ndefault:\r\nSPRINTF("*invalid*");\r\nbreak;\r\n}\r\nSPRINTF("); ");\r\nSPRINTF("INTSTAT (%s); ", TESTHI(DMASTAT, INTSTAT) ? "hi" : "lo");\r\nSPRINTF("SSTAT( ");\r\ns = GETPORT(SSTAT0);\r\nif (s & TARGET)\r\nSPRINTF("TARGET ");\r\nif (s & SELDO)\r\nSPRINTF("SELDO ");\r\nif (s & SELDI)\r\nSPRINTF("SELDI ");\r\nif (s & SELINGO)\r\nSPRINTF("SELINGO ");\r\nif (s & SWRAP)\r\nSPRINTF("SWRAP ");\r\nif (s & SDONE)\r\nSPRINTF("SDONE ");\r\nif (s & SPIORDY)\r\nSPRINTF("SPIORDY ");\r\nif (s & DMADONE)\r\nSPRINTF("DMADONE ");\r\ns = GETPORT(SSTAT1);\r\nif (s & SELTO)\r\nSPRINTF("SELTO ");\r\nif (s & ATNTARG)\r\nSPRINTF("ATNTARG ");\r\nif (s & SCSIRSTI)\r\nSPRINTF("SCSIRSTI ");\r\nif (s & PHASEMIS)\r\nSPRINTF("PHASEMIS ");\r\nif (s & BUSFREE)\r\nSPRINTF("BUSFREE ");\r\nif (s & SCSIPERR)\r\nSPRINTF("SCSIPERR ");\r\nif (s & PHASECHG)\r\nSPRINTF("PHASECHG ");\r\nif (s & REQINIT)\r\nSPRINTF("REQINIT ");\r\nSPRINTF("); ");\r\nSPRINTF("SSTAT( ");\r\ns = GETPORT(SSTAT0) & GETPORT(SIMODE0);\r\nif (s & TARGET)\r\nSPRINTF("TARGET ");\r\nif (s & SELDO)\r\nSPRINTF("SELDO ");\r\nif (s & SELDI)\r\nSPRINTF("SELDI ");\r\nif (s & SELINGO)\r\nSPRINTF("SELINGO ");\r\nif (s & SWRAP)\r\nSPRINTF("SWRAP ");\r\nif (s & SDONE)\r\nSPRINTF("SDONE ");\r\nif (s & SPIORDY)\r\nSPRINTF("SPIORDY ");\r\nif (s & DMADONE)\r\nSPRINTF("DMADONE ");\r\ns = GETPORT(SSTAT1) & GETPORT(SIMODE1);\r\nif (s & SELTO)\r\nSPRINTF("SELTO ");\r\nif (s & ATNTARG)\r\nSPRINTF("ATNTARG ");\r\nif (s & SCSIRSTI)\r\nSPRINTF("SCSIRSTI ");\r\nif (s & PHASEMIS)\r\nSPRINTF("PHASEMIS ");\r\nif (s & BUSFREE)\r\nSPRINTF("BUSFREE ");\r\nif (s & SCSIPERR)\r\nSPRINTF("SCSIPERR ");\r\nif (s & PHASECHG)\r\nSPRINTF("PHASECHG ");\r\nif (s & REQINIT)\r\nSPRINTF("REQINIT ");\r\nSPRINTF("); ");\r\nSPRINTF("SXFRCTL0( ");\r\ns = GETPORT(SXFRCTL0);\r\nif (s & SCSIEN)\r\nSPRINTF("SCSIEN ");\r\nif (s & DMAEN)\r\nSPRINTF("DMAEN ");\r\nif (s & CH1)\r\nSPRINTF("CH1 ");\r\nif (s & CLRSTCNT)\r\nSPRINTF("CLRSTCNT ");\r\nif (s & SPIOEN)\r\nSPRINTF("SPIOEN ");\r\nif (s & CLRCH1)\r\nSPRINTF("CLRCH1 ");\r\nSPRINTF("); ");\r\nSPRINTF("SIGNAL( ");\r\ns = GETPORT(SCSISIG);\r\nif (s & SIG_ATNI)\r\nSPRINTF("ATNI ");\r\nif (s & SIG_SELI)\r\nSPRINTF("SELI ");\r\nif (s & SIG_BSYI)\r\nSPRINTF("BSYI ");\r\nif (s & SIG_REQI)\r\nSPRINTF("REQI ");\r\nif (s & SIG_ACKI)\r\nSPRINTF("ACKI ");\r\nSPRINTF("); ");\r\nSPRINTF("SELID(%02x), ", GETPORT(SELID));\r\nSPRINTF("STCNT(%d), ", GETSTCNT());\r\nSPRINTF("SSTAT2( ");\r\ns = GETPORT(SSTAT2);\r\nif (s & SOFFSET)\r\nSPRINTF("SOFFSET ");\r\nif (s & SEMPTY)\r\nSPRINTF("SEMPTY ");\r\nif (s & SFULL)\r\nSPRINTF("SFULL ");\r\nSPRINTF("); SFCNT (%d); ", s & (SFULL | SFCNT));\r\ns = GETPORT(SSTAT3);\r\nSPRINTF("SCSICNT (%d), OFFCNT(%d), ", (s & 0xf0) >> 4, s & 0x0f);\r\nSPRINTF("SSTAT4( ");\r\ns = GETPORT(SSTAT4);\r\nif (s & SYNCERR)\r\nSPRINTF("SYNCERR ");\r\nif (s & FWERR)\r\nSPRINTF("FWERR ");\r\nif (s & FRERR)\r\nSPRINTF("FRERR ");\r\nSPRINTF("); ");\r\nSPRINTF("DMACNTRL0( ");\r\ns = GETPORT(DMACNTRL0);\r\nSPRINTF("%s ", s & _8BIT ? "8BIT" : "16BIT");\r\nSPRINTF("%s ", s & DMA ? "DMA" : "PIO");\r\nSPRINTF("%s ", s & WRITE_READ ? "WRITE" : "READ");\r\nif (s & ENDMA)\r\nSPRINTF("ENDMA ");\r\nif (s & INTEN)\r\nSPRINTF("INTEN ");\r\nif (s & RSTFIFO)\r\nSPRINTF("RSTFIFO ");\r\nif (s & SWINT)\r\nSPRINTF("SWINT ");\r\nSPRINTF("); ");\r\nSPRINTF("DMASTAT( ");\r\ns = GETPORT(DMASTAT);\r\nif (s & ATDONE)\r\nSPRINTF("ATDONE ");\r\nif (s & WORDRDY)\r\nSPRINTF("WORDRDY ");\r\nif (s & DFIFOFULL)\r\nSPRINTF("DFIFOFULL ");\r\nif (s & DFIFOEMP)\r\nSPRINTF("DFIFOEMP ");\r\nSPRINTF(")\n");\r\nSPRINTF("enabled interrupts( ");\r\ns = GETPORT(SIMODE0);\r\nif (s & ENSELDO)\r\nSPRINTF("ENSELDO ");\r\nif (s & ENSELDI)\r\nSPRINTF("ENSELDI ");\r\nif (s & ENSELINGO)\r\nSPRINTF("ENSELINGO ");\r\nif (s & ENSWRAP)\r\nSPRINTF("ENSWRAP ");\r\nif (s & ENSDONE)\r\nSPRINTF("ENSDONE ");\r\nif (s & ENSPIORDY)\r\nSPRINTF("ENSPIORDY ");\r\nif (s & ENDMADONE)\r\nSPRINTF("ENDMADONE ");\r\ns = GETPORT(SIMODE1);\r\nif (s & ENSELTIMO)\r\nSPRINTF("ENSELTIMO ");\r\nif (s & ENATNTARG)\r\nSPRINTF("ENATNTARG ");\r\nif (s & ENPHASEMIS)\r\nSPRINTF("ENPHASEMIS ");\r\nif (s & ENBUSFREE)\r\nSPRINTF("ENBUSFREE ");\r\nif (s & ENSCSIPERR)\r\nSPRINTF("ENSCSIPERR ");\r\nif (s & ENPHASECHG)\r\nSPRINTF("ENPHASECHG ");\r\nif (s & ENREQINIT)\r\nSPRINTF("ENREQINIT ");\r\nSPRINTF(")\n");\r\n}\r\nstatic int aha152x_set_info(struct Scsi_Host *shpnt, char *buffer, int length)\r\n{\r\nif(!shpnt || !buffer || length<8 || strncmp("aha152x ", buffer, 8)!=0)\r\nreturn -EINVAL;\r\n#if defined(AHA152X_DEBUG)\r\nif(length>14 && strncmp("debug ", buffer+8, 6)==0) {\r\nint debug = HOSTDATA(shpnt)->debug;\r\nHOSTDATA(shpnt)->debug = simple_strtoul(buffer+14, NULL, 0);\r\nprintk(KERN_INFO "aha152x%d: debugging options set to 0x%04x (were 0x%04x)\n", HOSTNO, HOSTDATA(shpnt)->debug, debug);\r\n} else\r\n#endif\r\n#if defined(AHA152X_STAT)\r\nif(length>13 && strncmp("reset", buffer+8, 5)==0) {\r\nint i;\r\nHOSTDATA(shpnt)->total_commands=0;\r\nHOSTDATA(shpnt)->disconnections=0;\r\nHOSTDATA(shpnt)->busfree_without_any_action=0;\r\nHOSTDATA(shpnt)->busfree_without_old_command=0;\r\nHOSTDATA(shpnt)->busfree_without_new_command=0;\r\nHOSTDATA(shpnt)->busfree_without_done_command=0;\r\nHOSTDATA(shpnt)->busfree_with_check_condition=0;\r\nfor (i = idle; i<maxstate; i++) {\r\nHOSTDATA(shpnt)->count[i]=0;\r\nHOSTDATA(shpnt)->count_trans[i]=0;\r\nHOSTDATA(shpnt)->time[i]=0;\r\n}\r\nprintk(KERN_INFO "aha152x%d: stats reseted.\n", HOSTNO);\r\n} else\r\n#endif\r\n{\r\nreturn -EINVAL;\r\n}\r\nreturn length;\r\n}\r\nstatic int aha152x_show_info(struct seq_file *m, struct Scsi_Host *shpnt)\r\n{\r\nint i;\r\nScsi_Cmnd *ptr;\r\nunsigned long flags;\r\nSPRINTF(AHA152X_REVID "\n");\r\nSPRINTF("ioports 0x%04lx to 0x%04lx\n",\r\nshpnt->io_port, shpnt->io_port + shpnt->n_io_port - 1);\r\nSPRINTF("interrupt 0x%02x\n", shpnt->irq);\r\nSPRINTF("disconnection/reconnection %s\n",\r\nRECONNECT ? "enabled" : "disabled");\r\nSPRINTF("parity checking %s\n",\r\nPARITY ? "enabled" : "disabled");\r\nSPRINTF("synchronous transfers %s\n",\r\nSYNCHRONOUS ? "enabled" : "disabled");\r\nSPRINTF("%d commands currently queued\n", HOSTDATA(shpnt)->commands);\r\nif(SYNCHRONOUS) {\r\nSPRINTF("synchronously operating targets (tick=50 ns):\n");\r\nfor (i = 0; i < 8; i++)\r\nif (HOSTDATA(shpnt)->syncrate[i] & 0x7f)\r\nSPRINTF("target %d: period %dT/%dns; req/ack offset %d\n",\r\ni,\r\n(((HOSTDATA(shpnt)->syncrate[i] & 0x70) >> 4) + 2),\r\n(((HOSTDATA(shpnt)->syncrate[i] & 0x70) >> 4) + 2) * 50,\r\nHOSTDATA(shpnt)->syncrate[i] & 0x0f);\r\n}\r\n#if defined(AHA152X_DEBUG)\r\n#define PDEBUG(flags,txt) \\r\nif(HOSTDATA(shpnt)->debug & flags) SPRINTF("(%s) ", txt);\r\nSPRINTF("enabled debugging options: ");\r\nPDEBUG(debug_procinfo, "procinfo");\r\nPDEBUG(debug_queue, "queue");\r\nPDEBUG(debug_intr, "interrupt");\r\nPDEBUG(debug_selection, "selection");\r\nPDEBUG(debug_msgo, "message out");\r\nPDEBUG(debug_msgi, "message in");\r\nPDEBUG(debug_status, "status");\r\nPDEBUG(debug_cmd, "command");\r\nPDEBUG(debug_datai, "data in");\r\nPDEBUG(debug_datao, "data out");\r\nPDEBUG(debug_eh, "eh");\r\nPDEBUG(debug_locking, "locks");\r\nPDEBUG(debug_phases, "phases");\r\nSPRINTF("\n");\r\n#endif\r\nSPRINTF("\nqueue status:\n");\r\nDO_LOCK(flags);\r\nif (ISSUE_SC) {\r\nSPRINTF("not yet issued commands:\n");\r\nfor (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr))\r\nget_command(m, ptr);\r\n} else\r\nSPRINTF("no not yet issued commands\n");\r\nDO_UNLOCK(flags);\r\nif (CURRENT_SC) {\r\nSPRINTF("current command:\n");\r\nget_command(m, CURRENT_SC);\r\n} else\r\nSPRINTF("no current command\n");\r\nif (DISCONNECTED_SC) {\r\nSPRINTF("disconnected commands:\n");\r\nfor (ptr = DISCONNECTED_SC; ptr; ptr = SCNEXT(ptr))\r\nget_command(m, ptr);\r\n} else\r\nSPRINTF("no disconnected commands\n");\r\nget_ports(m, shpnt);\r\n#if defined(AHA152X_STAT)\r\nSPRINTF("statistics:\n"\r\n"total commands: %d\n"\r\n"disconnections: %d\n"\r\n"busfree with check condition: %d\n"\r\n"busfree without old command: %d\n"\r\n"busfree without new command: %d\n"\r\n"busfree without done command: %d\n"\r\n"busfree without any action: %d\n"\r\n"state "\r\n"transitions "\r\n"count "\r\n"time\n",\r\nHOSTDATA(shpnt)->total_commands,\r\nHOSTDATA(shpnt)->disconnections,\r\nHOSTDATA(shpnt)->busfree_with_check_condition,\r\nHOSTDATA(shpnt)->busfree_without_old_command,\r\nHOSTDATA(shpnt)->busfree_without_new_command,\r\nHOSTDATA(shpnt)->busfree_without_done_command,\r\nHOSTDATA(shpnt)->busfree_without_any_action);\r\nfor(i=0; i<maxstate; i++) {\r\nSPRINTF("%-10s %-12d %-12d %-12ld\n",\r\nstates[i].name,\r\nHOSTDATA(shpnt)->count_trans[i],\r\nHOSTDATA(shpnt)->count[i],\r\nHOSTDATA(shpnt)->time[i]);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int aha152x_adjust_queue(struct scsi_device *device)\r\n{\r\nblk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);\r\nreturn 0;\r\n}\r\nstatic int aha152x_porttest(int io_port)\r\n{\r\nint i;\r\nSETPORT(io_port + O_DMACNTRL1, 0);\r\nfor (i = 0; i < 16; i++)\r\nSETPORT(io_port + O_STACK, i);\r\nSETPORT(io_port + O_DMACNTRL1, 0);\r\nfor (i = 0; i < 16 && GETPORT(io_port + O_STACK) == i; i++)\r\n;\r\nreturn (i == 16);\r\n}\r\nstatic int tc1550_porttest(int io_port)\r\n{\r\nint i;\r\nSETPORT(io_port + O_TC_DMACNTRL1, 0);\r\nfor (i = 0; i < 16; i++)\r\nSETPORT(io_port + O_STACK, i);\r\nSETPORT(io_port + O_TC_DMACNTRL1, 0);\r\nfor (i = 0; i < 16 && GETPORT(io_port + O_TC_STACK) == i; i++)\r\n;\r\nreturn (i == 16);\r\n}\r\nstatic int checksetup(struct aha152x_setup *setup)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ports) && (setup->io_port != ports[i]); i++)\r\n;\r\nif (i == ARRAY_SIZE(ports))\r\nreturn 0;\r\nif (!request_region(setup->io_port, IO_RANGE, "aha152x")) {\r\nprintk(KERN_ERR "aha152x: io port 0x%x busy.\n", setup->io_port);\r\nreturn 0;\r\n}\r\nif( aha152x_porttest(setup->io_port) ) {\r\nsetup->tc1550=0;\r\n} else if( tc1550_porttest(setup->io_port) ) {\r\nsetup->tc1550=1;\r\n} else {\r\nrelease_region(setup->io_port, IO_RANGE);\r\nreturn 0;\r\n}\r\nrelease_region(setup->io_port, IO_RANGE);\r\nif ((setup->irq < IRQ_MIN) || (setup->irq > IRQ_MAX))\r\nreturn 0;\r\nif ((setup->scsiid < 0) || (setup->scsiid > 7))\r\nreturn 0;\r\nif ((setup->reconnect < 0) || (setup->reconnect > 1))\r\nreturn 0;\r\nif ((setup->parity < 0) || (setup->parity > 1))\r\nreturn 0;\r\nif ((setup->synchronous < 0) || (setup->synchronous > 1))\r\nreturn 0;\r\nif ((setup->ext_trans < 0) || (setup->ext_trans > 1))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int __init aha152x_init(void)\r\n{\r\nint i, j, ok;\r\n#if defined(AUTOCONF)\r\naha152x_config conf;\r\n#endif\r\n#ifdef __ISAPNP__\r\nstruct pnp_dev *dev=NULL, *pnpdev[2] = {NULL, NULL};\r\n#endif\r\nif ( setup_count ) {\r\nprintk(KERN_INFO "aha152x: processing commandline: ");\r\nfor (i = 0; i<setup_count; i++) {\r\nif (!checksetup(&setup[i])) {\r\nprintk(KERN_ERR "\naha152x: %s\n", setup[i].conf);\r\nprintk(KERN_ERR "aha152x: invalid line\n");\r\n}\r\n}\r\nprintk("ok\n");\r\n}\r\n#if defined(SETUP0)\r\nif (setup_count < ARRAY_SIZE(setup)) {\r\nstruct aha152x_setup override = SETUP0;\r\nif (setup_count == 0 || (override.io_port != setup[0].io_port)) {\r\nif (!checksetup(&override)) {\r\nprintk(KERN_ERR "\naha152x: invalid override SETUP0={0x%x,%d,%d,%d,%d,%d,%d,%d}\n",\r\noverride.io_port,\r\noverride.irq,\r\noverride.scsiid,\r\noverride.reconnect,\r\noverride.parity,\r\noverride.synchronous,\r\noverride.delay,\r\noverride.ext_trans);\r\n} else\r\nsetup[setup_count++] = override;\r\n}\r\n}\r\n#endif\r\n#if defined(SETUP1)\r\nif (setup_count < ARRAY_SIZE(setup)) {\r\nstruct aha152x_setup override = SETUP1;\r\nif (setup_count == 0 || (override.io_port != setup[0].io_port)) {\r\nif (!checksetup(&override)) {\r\nprintk(KERN_ERR "\naha152x: invalid override SETUP1={0x%x,%d,%d,%d,%d,%d,%d,%d}\n",\r\noverride.io_port,\r\noverride.irq,\r\noverride.scsiid,\r\noverride.reconnect,\r\noverride.parity,\r\noverride.synchronous,\r\noverride.delay,\r\noverride.ext_trans);\r\n} else\r\nsetup[setup_count++] = override;\r\n}\r\n}\r\n#endif\r\n#if defined(MODULE)\r\nif (setup_count<ARRAY_SIZE(setup) && (aha152x[0]!=0 || io[0]!=0 || irq[0]!=0)) {\r\nif(aha152x[0]!=0) {\r\nsetup[setup_count].conf = "";\r\nsetup[setup_count].io_port = aha152x[0];\r\nsetup[setup_count].irq = aha152x[1];\r\nsetup[setup_count].scsiid = aha152x[2];\r\nsetup[setup_count].reconnect = aha152x[3];\r\nsetup[setup_count].parity = aha152x[4];\r\nsetup[setup_count].synchronous = aha152x[5];\r\nsetup[setup_count].delay = aha152x[6];\r\nsetup[setup_count].ext_trans = aha152x[7];\r\n#if defined(AHA152X_DEBUG)\r\nsetup[setup_count].debug = aha152x[8];\r\n#endif\r\n} else if(io[0]!=0 || irq[0]!=0) {\r\nif(io[0]!=0) setup[setup_count].io_port = io[0];\r\nif(irq[0]!=0) setup[setup_count].irq = irq[0];\r\nsetup[setup_count].scsiid = scsiid[0];\r\nsetup[setup_count].reconnect = reconnect[0];\r\nsetup[setup_count].parity = parity[0];\r\nsetup[setup_count].synchronous = sync[0];\r\nsetup[setup_count].delay = delay[0];\r\nsetup[setup_count].ext_trans = exttrans[0];\r\n#if defined(AHA152X_DEBUG)\r\nsetup[setup_count].debug = debug[0];\r\n#endif\r\n}\r\nif (checksetup(&setup[setup_count]))\r\nsetup_count++;\r\nelse\r\nprintk(KERN_ERR "aha152x: invalid module params io=0x%x, irq=%d,scsiid=%d,reconnect=%d,parity=%d,sync=%d,delay=%d,exttrans=%d\n",\r\nsetup[setup_count].io_port,\r\nsetup[setup_count].irq,\r\nsetup[setup_count].scsiid,\r\nsetup[setup_count].reconnect,\r\nsetup[setup_count].parity,\r\nsetup[setup_count].synchronous,\r\nsetup[setup_count].delay,\r\nsetup[setup_count].ext_trans);\r\n}\r\nif (setup_count<ARRAY_SIZE(setup) && (aha152x1[0]!=0 || io[1]!=0 || irq[1]!=0)) {\r\nif(aha152x1[0]!=0) {\r\nsetup[setup_count].conf = "";\r\nsetup[setup_count].io_port = aha152x1[0];\r\nsetup[setup_count].irq = aha152x1[1];\r\nsetup[setup_count].scsiid = aha152x1[2];\r\nsetup[setup_count].reconnect = aha152x1[3];\r\nsetup[setup_count].parity = aha152x1[4];\r\nsetup[setup_count].synchronous = aha152x1[5];\r\nsetup[setup_count].delay = aha152x1[6];\r\nsetup[setup_count].ext_trans = aha152x1[7];\r\n#if defined(AHA152X_DEBUG)\r\nsetup[setup_count].debug = aha152x1[8];\r\n#endif\r\n} else if(io[1]!=0 || irq[1]!=0) {\r\nif(io[1]!=0) setup[setup_count].io_port = io[1];\r\nif(irq[1]!=0) setup[setup_count].irq = irq[1];\r\nsetup[setup_count].scsiid = scsiid[1];\r\nsetup[setup_count].reconnect = reconnect[1];\r\nsetup[setup_count].parity = parity[1];\r\nsetup[setup_count].synchronous = sync[1];\r\nsetup[setup_count].delay = delay[1];\r\nsetup[setup_count].ext_trans = exttrans[1];\r\n#if defined(AHA152X_DEBUG)\r\nsetup[setup_count].debug = debug[1];\r\n#endif\r\n}\r\nif (checksetup(&setup[setup_count]))\r\nsetup_count++;\r\nelse\r\nprintk(KERN_ERR "aha152x: invalid module params io=0x%x, irq=%d,scsiid=%d,reconnect=%d,parity=%d,sync=%d,delay=%d,exttrans=%d\n",\r\nsetup[setup_count].io_port,\r\nsetup[setup_count].irq,\r\nsetup[setup_count].scsiid,\r\nsetup[setup_count].reconnect,\r\nsetup[setup_count].parity,\r\nsetup[setup_count].synchronous,\r\nsetup[setup_count].delay,\r\nsetup[setup_count].ext_trans);\r\n}\r\n#endif\r\n#ifdef __ISAPNP__\r\nfor(i=0; setup_count<ARRAY_SIZE(setup) && id_table[i].vendor; i++) {\r\nwhile ( setup_count<ARRAY_SIZE(setup) &&\r\n(dev=pnp_find_dev(NULL, id_table[i].vendor, id_table[i].function, dev)) ) {\r\nif (pnp_device_attach(dev) < 0)\r\ncontinue;\r\nif (pnp_activate_dev(dev) < 0) {\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nif (!pnp_port_valid(dev, 0)) {\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nif (setup_count==1 && pnp_port_start(dev, 0)==setup[0].io_port) {\r\npnp_device_detach(dev);\r\ncontinue;\r\n}\r\nsetup[setup_count].io_port = pnp_port_start(dev, 0);\r\nsetup[setup_count].irq = pnp_irq(dev, 0);\r\nsetup[setup_count].scsiid = 7;\r\nsetup[setup_count].reconnect = 1;\r\nsetup[setup_count].parity = 1;\r\nsetup[setup_count].synchronous = 1;\r\nsetup[setup_count].delay = DELAY_DEFAULT;\r\nsetup[setup_count].ext_trans = 0;\r\n#if defined(AHA152X_DEBUG)\r\nsetup[setup_count].debug = DEBUG_DEFAULT;\r\n#endif\r\n#if defined(__ISAPNP__)\r\npnpdev[setup_count] = dev;\r\n#endif\r\nprintk (KERN_INFO\r\n"aha152x: found ISAPnP adapter at io=0x%03x, irq=%d\n",\r\nsetup[setup_count].io_port, setup[setup_count].irq);\r\nsetup_count++;\r\n}\r\n}\r\n#endif\r\n#if defined(AUTOCONF)\r\nif (setup_count<ARRAY_SIZE(setup)) {\r\n#if !defined(SKIP_BIOSTEST)\r\nok = 0;\r\nfor (i = 0; i < ARRAY_SIZE(addresses) && !ok; i++) {\r\nvoid __iomem *p = ioremap(addresses[i], 0x4000);\r\nif (!p)\r\ncontinue;\r\nfor (j = 0; j<ARRAY_SIZE(signatures) && !ok; j++)\r\nok = check_signature(p + signatures[j].sig_offset,\r\nsignatures[j].signature, signatures[j].sig_length);\r\niounmap(p);\r\n}\r\nif (!ok && setup_count == 0)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "aha152x: BIOS test: passed, ");\r\n#else\r\nprintk(KERN_INFO "aha152x: ");\r\n#endif\r\nok = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ports) && setup_count < 2; i++) {\r\nif ((setup_count == 1) && (setup[0].io_port == ports[i]))\r\ncontinue;\r\nif (!request_region(ports[i], IO_RANGE, "aha152x")) {\r\nprintk(KERN_ERR "aha152x: io port 0x%x busy.\n", ports[i]);\r\ncontinue;\r\n}\r\nif (aha152x_porttest(ports[i])) {\r\nsetup[setup_count].tc1550 = 0;\r\nconf.cf_port =\r\n(GETPORT(ports[i] + O_PORTA) << 8) + GETPORT(ports[i] + O_PORTB);\r\n} else if (tc1550_porttest(ports[i])) {\r\nsetup[setup_count].tc1550 = 1;\r\nconf.cf_port =\r\n(GETPORT(ports[i] + O_TC_PORTA) << 8) + GETPORT(ports[i] + O_TC_PORTB);\r\n} else {\r\nrelease_region(ports[i], IO_RANGE);\r\ncontinue;\r\n}\r\nrelease_region(ports[i], IO_RANGE);\r\nok++;\r\nsetup[setup_count].io_port = ports[i];\r\nsetup[setup_count].irq = IRQ_MIN + conf.cf_irq;\r\nsetup[setup_count].scsiid = conf.cf_id;\r\nsetup[setup_count].reconnect = conf.cf_tardisc;\r\nsetup[setup_count].parity = !conf.cf_parity;\r\nsetup[setup_count].synchronous = conf.cf_syncneg;\r\nsetup[setup_count].delay = DELAY_DEFAULT;\r\nsetup[setup_count].ext_trans = 0;\r\n#if defined(AHA152X_DEBUG)\r\nsetup[setup_count].debug = DEBUG_DEFAULT;\r\n#endif\r\nsetup_count++;\r\n}\r\nif (ok)\r\nprintk("auto configuration: ok, ");\r\n}\r\n#endif\r\nprintk("%d controller(s) configured\n", setup_count);\r\nfor (i=0; i<setup_count; i++) {\r\nif ( request_region(setup[i].io_port, IO_RANGE, "aha152x") ) {\r\nstruct Scsi_Host *shpnt = aha152x_probe_one(&setup[i]);\r\nif( !shpnt ) {\r\nrelease_region(setup[i].io_port, IO_RANGE);\r\n#if defined(__ISAPNP__)\r\n} else if( pnpdev[i] ) {\r\nHOSTDATA(shpnt)->pnpdev=pnpdev[i];\r\npnpdev[i]=NULL;\r\n#endif\r\n}\r\n} else {\r\nprintk(KERN_ERR "aha152x: io port 0x%x busy.\n", setup[i].io_port);\r\n}\r\n#if defined(__ISAPNP__)\r\nif( pnpdev[i] )\r\npnp_device_detach(pnpdev[i]);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit aha152x_exit(void)\r\n{\r\nstruct aha152x_hostdata *hd, *tmp;\r\nlist_for_each_entry_safe(hd, tmp, &aha152x_host_list, host_list) {\r\nstruct Scsi_Host *shost = container_of((void *)hd, struct Scsi_Host, hostdata);\r\naha152x_release(shost);\r\n}\r\n}\r\nstatic int __init aha152x_setup(char *str)\r\n{\r\n#if defined(AHA152X_DEBUG)\r\nint ints[11];\r\n#else\r\nint ints[10];\r\n#endif\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\nif(setup_count>=ARRAY_SIZE(setup)) {\r\nprintk(KERN_ERR "aha152x: you can only configure up to two controllers\n");\r\nreturn 1;\r\n}\r\nsetup[setup_count].conf = str;\r\nsetup[setup_count].io_port = ints[0] >= 1 ? ints[1] : 0x340;\r\nsetup[setup_count].irq = ints[0] >= 2 ? ints[2] : 11;\r\nsetup[setup_count].scsiid = ints[0] >= 3 ? ints[3] : 7;\r\nsetup[setup_count].reconnect = ints[0] >= 4 ? ints[4] : 1;\r\nsetup[setup_count].parity = ints[0] >= 5 ? ints[5] : 1;\r\nsetup[setup_count].synchronous = ints[0] >= 6 ? ints[6] : 1;\r\nsetup[setup_count].delay = ints[0] >= 7 ? ints[7] : DELAY_DEFAULT;\r\nsetup[setup_count].ext_trans = ints[0] >= 8 ? ints[8] : 0;\r\n#if defined(AHA152X_DEBUG)\r\nsetup[setup_count].debug = ints[0] >= 9 ? ints[9] : DEBUG_DEFAULT;\r\nif (ints[0] > 9) {\r\nprintk(KERN_NOTICE "aha152x: usage: aha152x=<IOBASE>[,<IRQ>[,<SCSI ID>"\r\n"[,<RECONNECT>[,<PARITY>[,<SYNCHRONOUS>[,<DELAY>[,<EXT_TRANS>[,<DEBUG>]]]]]]]]\n");\r\n#else\r\nif (ints[0] > 8) {\r\nprintk(KERN_NOTICE "aha152x: usage: aha152x=<IOBASE>[,<IRQ>[,<SCSI ID>"\r\n"[,<RECONNECT>[,<PARITY>[,<SYNCHRONOUS>[,<DELAY>[,<EXT_TRANS>]]]]]]]\n");\r\n#endif\r\n} else {\r\nsetup_count++;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\n__setup("aha152x=", aha152x_setup);
