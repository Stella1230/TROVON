static void arc_ps2_check_rx(struct arc_ps2_data *arc_ps2,\r\nstruct arc_ps2_port *port)\r\n{\r\nunsigned int timeout = 1000;\r\nunsigned int flag, status;\r\nunsigned char data;\r\ndo {\r\nstatus = ioread32(port->status_addr);\r\nif (!(status & PS2_STAT_RX_VAL))\r\nreturn;\r\ndata = ioread32(port->data_addr) & 0xff;\r\nflag = 0;\r\narc_ps2->total_int++;\r\nif (status & PS2_STAT_RX_FRM_ERR) {\r\narc_ps2->frame_error++;\r\nflag |= SERIO_PARITY;\r\n} else if (status & PS2_STAT_RX_BUF_OVER) {\r\narc_ps2->buf_overflow++;\r\nflag |= SERIO_FRAME;\r\n}\r\nserio_interrupt(port->io, data, flag);\r\n} while (--timeout);\r\ndev_err(&port->io->dev, "PS/2 hardware stuck\n");\r\n}\r\nstatic irqreturn_t arc_ps2_interrupt(int irq, void *dev)\r\n{\r\nstruct arc_ps2_data *arc_ps2 = dev;\r\nint i;\r\nfor (i = 0; i < ARC_PS2_PORTS; i++)\r\narc_ps2_check_rx(arc_ps2, &arc_ps2->port[i]);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int arc_ps2_write(struct serio *io, unsigned char val)\r\n{\r\nunsigned status;\r\nstruct arc_ps2_port *port = io->port_data;\r\nint timeout = STAT_TIMEOUT;\r\ndo {\r\nstatus = ioread32(port->status_addr);\r\ncpu_relax();\r\nif (status & PS2_STAT_TX_ISNOT_FUL) {\r\niowrite32(val & 0xff, port->data_addr);\r\nreturn 0;\r\n}\r\n} while (--timeout);\r\ndev_err(&io->dev, "write timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int arc_ps2_open(struct serio *io)\r\n{\r\nstruct arc_ps2_port *port = io->port_data;\r\niowrite32(PS2_STAT_RX_INT_EN, port->status_addr);\r\nreturn 0;\r\n}\r\nstatic void arc_ps2_close(struct serio *io)\r\n{\r\nstruct arc_ps2_port *port = io->port_data;\r\niowrite32(ioread32(port->status_addr) & ~PS2_STAT_RX_INT_EN,\r\nport->status_addr);\r\n}\r\nstatic void __iomem *arc_ps2_calc_addr(struct arc_ps2_data *arc_ps2,\r\nint index, bool status)\r\n{\r\nvoid __iomem *addr;\r\naddr = arc_ps2->addr + 4 + 4 * index;\r\nif (status)\r\naddr += ARC_PS2_PORTS * 4;\r\nreturn addr;\r\n}\r\nstatic void arc_ps2_inhibit_ports(struct arc_ps2_data *arc_ps2)\r\n{\r\nvoid __iomem *addr;\r\nu32 val;\r\nint i;\r\nfor (i = 0; i < ARC_PS2_PORTS; i++) {\r\naddr = arc_ps2_calc_addr(arc_ps2, i, true);\r\nval = ioread32(addr);\r\nval &= ~(PS2_STAT_RX_INT_EN | PS2_STAT_TX_INT_EN);\r\niowrite32(val, addr);\r\n}\r\n}\r\nstatic int arc_ps2_create_port(struct platform_device *pdev,\r\nstruct arc_ps2_data *arc_ps2,\r\nint index)\r\n{\r\nstruct arc_ps2_port *port = &arc_ps2->port[index];\r\nstruct serio *io;\r\nio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!io)\r\nreturn -ENOMEM;\r\nio->id.type = SERIO_8042;\r\nio->write = arc_ps2_write;\r\nio->open = arc_ps2_open;\r\nio->close = arc_ps2_close;\r\nsnprintf(io->name, sizeof(io->name), "ARC PS/2 port%d", index);\r\nsnprintf(io->phys, sizeof(io->phys), "arc/serio%d", index);\r\nio->port_data = port;\r\nport->io = io;\r\nport->data_addr = arc_ps2_calc_addr(arc_ps2, index, false);\r\nport->status_addr = arc_ps2_calc_addr(arc_ps2, index, true);\r\ndev_dbg(&pdev->dev, "port%d is allocated (data = 0x%p, status = 0x%p)\n",\r\nindex, port->data_addr, port->status_addr);\r\nserio_register_port(port->io);\r\nreturn 0;\r\n}\r\nstatic int arc_ps2_probe(struct platform_device *pdev)\r\n{\r\nstruct arc_ps2_data *arc_ps2;\r\nstruct resource *res;\r\nint irq;\r\nint error, id, i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no IO memory defined\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq_byname(pdev, "arc_ps2_irq");\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ defined\n");\r\nreturn -EINVAL;\r\n}\r\narc_ps2 = devm_kzalloc(&pdev->dev, sizeof(struct arc_ps2_data),\r\nGFP_KERNEL);\r\nif (!arc_ps2) {\r\ndev_err(&pdev->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\narc_ps2->addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(arc_ps2->addr))\r\nreturn PTR_ERR(arc_ps2->addr);\r\ndev_info(&pdev->dev, "irq = %d, address = 0x%p, ports = %i\n",\r\nirq, arc_ps2->addr, ARC_PS2_PORTS);\r\nid = ioread32(arc_ps2->addr);\r\nif (id != ARC_ARC_PS2_ID) {\r\ndev_err(&pdev->dev, "device id does not match\n");\r\nreturn -ENXIO;\r\n}\r\narc_ps2_inhibit_ports(arc_ps2);\r\nerror = devm_request_irq(&pdev->dev, irq, arc_ps2_interrupt,\r\n0, "arc_ps2", arc_ps2);\r\nif (error) {\r\ndev_err(&pdev->dev, "Could not allocate IRQ\n");\r\nreturn error;\r\n}\r\nfor (i = 0; i < ARC_PS2_PORTS; i++) {\r\nerror = arc_ps2_create_port(pdev, arc_ps2, i);\r\nif (error) {\r\nwhile (--i >= 0)\r\nserio_unregister_port(arc_ps2->port[i].io);\r\nreturn error;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, arc_ps2);\r\nreturn 0;\r\n}\r\nstatic int arc_ps2_remove(struct platform_device *pdev)\r\n{\r\nstruct arc_ps2_data *arc_ps2 = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < ARC_PS2_PORTS; i++)\r\nserio_unregister_port(arc_ps2->port[i].io);\r\ndev_dbg(&pdev->dev, "interrupt count = %i\n", arc_ps2->total_int);\r\ndev_dbg(&pdev->dev, "frame error count = %i\n", arc_ps2->frame_error);\r\ndev_dbg(&pdev->dev, "buffer overflow count = %i\n",\r\narc_ps2->buf_overflow);\r\nreturn 0;\r\n}
