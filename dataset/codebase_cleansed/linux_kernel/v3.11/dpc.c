static void s_vProcessRxMACHeader(struct vnt_private *pDevice,\r\nu8 *pbyRxBufferAddr, u32 cbPacketSize, int bIsWEP, int bExtIV,\r\nu32 *pcbHeadSize)\r\n{\r\nu8 *pbyRxBuffer;\r\nu32 cbHeaderSize = 0;\r\nu16 *pwType;\r\nstruct ieee80211_hdr *pMACHeader;\r\nint ii;\r\npMACHeader = (struct ieee80211_hdr *) (pbyRxBufferAddr + cbHeaderSize);\r\ns_vGetDASA((u8 *)pMACHeader, &cbHeaderSize, &pDevice->sRxEthHeader);\r\nif (bIsWEP) {\r\nif (bExtIV) {\r\ncbHeaderSize += (WLAN_HDR_ADDR3_LEN + 8);\r\n} else {\r\ncbHeaderSize += (WLAN_HDR_ADDR3_LEN + 4);\r\n}\r\n}\r\nelse {\r\ncbHeaderSize += WLAN_HDR_ADDR3_LEN;\r\n};\r\npbyRxBuffer = (u8 *) (pbyRxBufferAddr + cbHeaderSize);\r\nif (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_Bridgetunnel[0])) {\r\ncbHeaderSize += 6;\r\n} else if (!compare_ether_addr(pbyRxBuffer, &pDevice->abySNAP_RFC1042[0])) {\r\ncbHeaderSize += 6;\r\npwType = (u16 *) (pbyRxBufferAddr + cbHeaderSize);\r\nif ((*pwType == cpu_to_be16(ETH_P_IPX)) ||\r\n(*pwType == cpu_to_le16(0xF380))) {\r\ncbHeaderSize -= 8;\r\npwType = (u16 *) (pbyRxBufferAddr + cbHeaderSize);\r\nif (bIsWEP) {\r\nif (bExtIV) {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);\r\n} else {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);\r\n}\r\n}\r\nelse {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);\r\n}\r\n}\r\n}\r\nelse {\r\ncbHeaderSize -= 2;\r\npwType = (u16 *) (pbyRxBufferAddr + cbHeaderSize);\r\nif (bIsWEP) {\r\nif (bExtIV) {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 8);\r\n} else {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN - 4);\r\n}\r\n}\r\nelse {\r\n*pwType = htons(cbPacketSize - WLAN_HDR_ADDR3_LEN);\r\n}\r\n}\r\ncbHeaderSize -= (ETH_ALEN * 2);\r\npbyRxBuffer = (u8 *) (pbyRxBufferAddr + cbHeaderSize);\r\nfor (ii = 0; ii < ETH_ALEN; ii++)\r\n*pbyRxBuffer++ = pDevice->sRxEthHeader.h_dest[ii];\r\nfor (ii = 0; ii < ETH_ALEN; ii++)\r\n*pbyRxBuffer++ = pDevice->sRxEthHeader.h_source[ii];\r\n*pcbHeadSize = cbHeaderSize;\r\n}\r\nstatic u8 s_byGetRateIdx(u8 byRate)\r\n{\r\nu8 byRateIdx;\r\nfor (byRateIdx = 0; byRateIdx <MAX_RATE ; byRateIdx++) {\r\nif (acbyRxRate[byRateIdx%MAX_RATE] == byRate)\r\nreturn byRateIdx;\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nvoid\r\ns_vGetDASA (\r\nu8 * pbyRxBufferAddr,\r\nunsigned int *pcbHeaderSize,\r\nstruct ethhdr *psEthHeader\r\n)\r\n{\r\nunsigned int cbHeaderSize = 0;\r\nstruct ieee80211_hdr *pMACHeader;\r\nint ii;\r\npMACHeader = (struct ieee80211_hdr *) (pbyRxBufferAddr + cbHeaderSize);\r\nif ((pMACHeader->frame_control & FC_TODS) == 0) {\r\nif (pMACHeader->frame_control & FC_FROMDS) {\r\nfor (ii = 0; ii < ETH_ALEN; ii++) {\r\npsEthHeader->h_dest[ii] =\r\npMACHeader->addr1[ii];\r\npsEthHeader->h_source[ii] =\r\npMACHeader->addr3[ii];\r\n}\r\n} else {\r\nfor (ii = 0; ii < ETH_ALEN; ii++) {\r\npsEthHeader->h_dest[ii] =\r\npMACHeader->addr1[ii];\r\npsEthHeader->h_source[ii] =\r\npMACHeader->addr2[ii];\r\n}\r\n}\r\n} else {\r\nif (pMACHeader->frame_control & FC_FROMDS) {\r\nfor (ii = 0; ii < ETH_ALEN; ii++) {\r\npsEthHeader->h_dest[ii] =\r\npMACHeader->addr3[ii];\r\npsEthHeader->h_source[ii] =\r\npMACHeader->addr4[ii];\r\ncbHeaderSize += 6;\r\n}\r\n} else {\r\nfor (ii = 0; ii < ETH_ALEN; ii++) {\r\npsEthHeader->h_dest[ii] =\r\npMACHeader->addr3[ii];\r\npsEthHeader->h_source[ii] =\r\npMACHeader->addr2[ii];\r\n}\r\n}\r\n};\r\n*pcbHeaderSize = cbHeaderSize;\r\n}\r\nint RXbBulkInProcessData(struct vnt_private *pDevice, PRCB pRCB,\r\nunsigned long BytesToIndicate)\r\n{\r\nstruct net_device_stats *pStats = &pDevice->stats;\r\nstruct sk_buff *skb;\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nstruct vnt_rx_mgmt *pRxPacket = &pMgmt->sRxPacket;\r\nstruct ieee80211_hdr *p802_11Header;\r\nu8 *pbyRsr, *pbyNewRsr, *pbyRSSI, *pbyFrame;\r\nu64 *pqwTSFTime;\r\nu32 bDeFragRx = false;\r\nu32 cbHeaderOffset, cbIVOffset;\r\nu32 FrameSize;\r\nu16 wEtherType = 0;\r\ns32 iSANodeIndex = -1, iDANodeIndex = -1;\r\nint ii;\r\nu8 *pbyRxSts, *pbyRxRate, *pbySQ, *pby3SQ;\r\nu32 cbHeaderSize;\r\nPSKeyItem pKey = NULL;\r\nu16 wRxTSC15_0 = 0;\r\nu32 dwRxTSC47_16 = 0;\r\nSKeyItem STempKey;\r\nint bIsWEP = false; int bExtIV = false;\r\nu32 dwWbkStatus;\r\nPRCB pRCBIndicate = pRCB;\r\nu8 *pbyDAddress;\r\nu16 *pwPLCP_Length;\r\nu8 abyVaildRate[MAX_RATE]\r\n= {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};\r\nu16 wPLCPwithPadding;\r\nstruct ieee80211_hdr *pMACHeader;\r\nint bRxeapol_key = false;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---------- RXbBulkInProcessData---\n");\r\nskb = pRCB->skb;\r\ndwWbkStatus = *((u32 *)(skb->data));\r\nFrameSize = dwWbkStatus >> 16;\r\nFrameSize += 4;\r\nif (BytesToIndicate != FrameSize) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"------- WRONG Length 1\n");\r\nreturn false;\r\n}\r\nif ((BytesToIndicate > 2372) || (BytesToIndicate <= 40)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---------- WRONG Length 2\n");\r\nreturn false;\r\n}\r\npbyDAddress = (u8 *)(skb->data);\r\npbyRxSts = pbyDAddress+4;\r\npbyRxRate = pbyDAddress+5;\r\npwPLCP_Length = (u16 *) (pbyDAddress + 6);\r\nif ( ((BytesToIndicate - (*pwPLCP_Length)) > 27) ||\r\n((BytesToIndicate - (*pwPLCP_Length)) < 24) ||\r\n(BytesToIndicate < (*pwPLCP_Length)) ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Wrong PLCP Length %x\n", (int) *pwPLCP_Length);\r\nASSERT(0);\r\nreturn false;\r\n}\r\nfor ( ii=RATE_1M;ii<MAX_RATE;ii++) {\r\nif ( *pbyRxRate == abyVaildRate[ii] ) {\r\nbreak;\r\n}\r\n}\r\nif ( ii==MAX_RATE ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Wrong RxRate %x\n",(int) *pbyRxRate);\r\nreturn false;\r\n}\r\nwPLCPwithPadding = ( (*pwPLCP_Length / 4) + ( (*pwPLCP_Length % 4) ? 1:0 ) ) *4;\r\npqwTSFTime = (u64 *)(pbyDAddress + 8 + wPLCPwithPadding);\r\nif(pDevice->byBBType == BB_TYPE_11G) {\r\npby3SQ = pbyDAddress + 8 + wPLCPwithPadding + 12;\r\npbySQ = pby3SQ;\r\n}\r\nelse {\r\npbySQ = pbyDAddress + 8 + wPLCPwithPadding + 8;\r\npby3SQ = pbySQ;\r\n}\r\npbyNewRsr = pbyDAddress + 8 + wPLCPwithPadding + 9;\r\npbyRSSI = pbyDAddress + 8 + wPLCPwithPadding + 10;\r\npbyRsr = pbyDAddress + 8 + wPLCPwithPadding + 11;\r\nFrameSize = *pwPLCP_Length;\r\npbyFrame = pbyDAddress + 8;\r\nSTAvUpdateRDStatCounter(&pDevice->scStatistic,\r\n*pbyRsr,\r\n*pbyNewRsr,\r\n*pbyRxSts,\r\n*pbyRxRate,\r\npbyFrame,\r\nFrameSize\r\n);\r\npMACHeader = (struct ieee80211_hdr *) pbyFrame;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_STANDBY) ||\r\n(pMgmt->eCurrMode == WMAC_MODE_ESS_STA)) {\r\nif (pMgmt->sNodeDBTable[0].bActive) {\r\nif (!compare_ether_addr(pMgmt->abyCurrBSSID, pMACHeader->addr2)) {\r\nif (pMgmt->sNodeDBTable[0].uInActiveCount != 0)\r\npMgmt->sNodeDBTable[0].uInActiveCount = 0;\r\n}\r\n}\r\n}\r\nif (!is_multicast_ether_addr(pMACHeader->addr1)) {\r\nif (WCTLbIsDuplicate(&(pDevice->sDupRxCache), (struct ieee80211_hdr *) pbyFrame)) {\r\npDevice->s802_11Counter.FrameDuplicateCount++;\r\nreturn false;\r\n}\r\nif (compare_ether_addr(pDevice->abyCurrentNetAddr,\r\npMACHeader->addr1)) {\r\nreturn false;\r\n}\r\n}\r\ns_vGetDASA(pbyFrame, &cbHeaderSize, &pDevice->sRxEthHeader);\r\nif (!compare_ether_addr((u8 *)&(pDevice->sRxEthHeader.h_source[0]),\r\npDevice->abyCurrentNetAddr))\r\nreturn false;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) || (pMgmt->eCurrMode == WMAC_MODE_IBSS_STA)) {\r\nif (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {\r\np802_11Header = (struct ieee80211_hdr *) (pbyFrame);\r\nif (BSSbIsSTAInNodeDB(pDevice, (u8 *)(p802_11Header->addr2), &iSANodeIndex)) {\r\npMgmt->sNodeDBTable[iSANodeIndex].ulLastRxJiffer = jiffies;\r\npMgmt->sNodeDBTable[iSANodeIndex].uInActiveCount = 0;\r\n}\r\n}\r\n}\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif (s_bAPModeRxCtl(pDevice, pbyFrame, iSANodeIndex) == true) {\r\nreturn false;\r\n}\r\n}\r\nif (IS_FC_WEP(pbyFrame)) {\r\nbool bRxDecryOK = false;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"rx WEP pkt\n");\r\nbIsWEP = true;\r\nif ((pDevice->bEnableHostWEP) && (iSANodeIndex >= 0)) {\r\npKey = &STempKey;\r\npKey->byCipherSuite = pMgmt->sNodeDBTable[iSANodeIndex].byCipherSuite;\r\npKey->dwKeyIndex = pMgmt->sNodeDBTable[iSANodeIndex].dwKeyIndex;\r\npKey->uKeyLength = pMgmt->sNodeDBTable[iSANodeIndex].uWepKeyLength;\r\npKey->dwTSC47_16 = pMgmt->sNodeDBTable[iSANodeIndex].dwTSC47_16;\r\npKey->wTSC15_0 = pMgmt->sNodeDBTable[iSANodeIndex].wTSC15_0;\r\nmemcpy(pKey->abyKey,\r\n&pMgmt->sNodeDBTable[iSANodeIndex].abyWepKey[0],\r\npKey->uKeyLength\r\n);\r\nbRxDecryOK = s_bHostWepRxEncryption(pDevice,\r\npbyFrame,\r\nFrameSize,\r\npbyRsr,\r\npMgmt->sNodeDBTable[iSANodeIndex].bOnFly,\r\npKey,\r\npbyNewRsr,\r\n&bExtIV,\r\n&wRxTSC15_0,\r\n&dwRxTSC47_16);\r\n} else {\r\nbRxDecryOK = s_bHandleRxEncryption(pDevice,\r\npbyFrame,\r\nFrameSize,\r\npbyRsr,\r\npbyNewRsr,\r\n&pKey,\r\n&bExtIV,\r\n&wRxTSC15_0,\r\n&dwRxTSC47_16);\r\n}\r\nif (bRxDecryOK) {\r\nif ((*pbyNewRsr & NEWRSR_DECRYPTOK) == 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV Fail\n");\r\nif ( (pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {\r\nif ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {\r\npDevice->s802_11Counter.TKIPICVErrors++;\r\n} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP)) {\r\npDevice->s802_11Counter.CCMPDecryptErrors++;\r\n} else if ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_WEP)) {\r\n}\r\n}\r\nreturn false;\r\n}\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"WEP Func Fail\n");\r\nreturn false;\r\n}\r\nif ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_CCMP))\r\nFrameSize -= 8;\r\nelse\r\nFrameSize -= 4;\r\n}\r\nFrameSize -= ETH_FCS_LEN;\r\nif ( !(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) &&\r\n(IS_FRAGMENT_PKT((pbyFrame)))\r\n) {\r\nbDeFragRx = WCTLbHandleFragment(pDevice, (struct ieee80211_hdr *) (pbyFrame), FrameSize, bIsWEP, bExtIV);\r\npDevice->s802_11Counter.ReceivedFragmentCount++;\r\nif (bDeFragRx) {\r\nskb = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].skb;\r\nFrameSize = pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx].cbFrameLength;\r\npbyFrame = skb->data + 8;\r\n}\r\nelse {\r\nreturn false;\r\n}\r\n}\r\nif ((IS_TYPE_DATA((pbyFrame))) == false) {\r\nif (IS_TYPE_MGMT((pbyFrame))) {\r\nu8 * pbyData1;\r\nu8 * pbyData2;\r\npRxPacket = &(pRCB->sMngPacket);\r\npRxPacket->p80211Header = (PUWLAN_80211HDR)(pbyFrame);\r\npRxPacket->cbMPDULen = FrameSize;\r\npRxPacket->uRSSI = *pbyRSSI;\r\npRxPacket->bySQ = *pbySQ;\r\npRxPacket->qwLocalTSF = cpu_to_le64(*pqwTSFTime);\r\nif (bIsWEP) {\r\npbyData1 = WLAN_HDR_A3_DATA_PTR(pbyFrame);\r\npbyData2 = WLAN_HDR_A3_DATA_PTR(pbyFrame) + 4;\r\nfor (ii = 0; ii < (FrameSize - 4); ii++) {\r\n*pbyData1 = *pbyData2;\r\npbyData1++;\r\npbyData2++;\r\n}\r\n}\r\npRxPacket->byRxRate = s_byGetRateIdx(*pbyRxRate);\r\nif ( *pbyRxSts == 0 ) {\r\nif ( (WLAN_GET_FC_FSTYPE((pRxPacket->p80211Header->sA3.wFrameCtl)) == WLAN_FSTYPE_BEACON) ||\r\n(WLAN_GET_FC_FSTYPE((pRxPacket->p80211Header->sA3.wFrameCtl)) == WLAN_FSTYPE_PROBERESP) ) {\r\nreturn false;\r\n}\r\n}\r\npRxPacket->byRxChannel = (*pbyRxSts) >> 2;\r\nif (pDevice->bEnableHostapd) {\r\nskb->dev = pDevice->apdev;\r\nskb->data += 8;\r\nskb->tail += 8;\r\nskb_put(skb, FrameSize);\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\nreturn true;\r\n}\r\nEnqueueRCB(pDevice->FirstRecvMngList, pDevice->LastRecvMngList, pRCBIndicate);\r\npDevice->NumRecvMngList++;\r\nif ( bDeFragRx == false) {\r\npRCB->Ref++;\r\n}\r\nif (pDevice->bIsRxMngWorkItemQueued == false) {\r\npDevice->bIsRxMngWorkItemQueued = true;\r\ntasklet_schedule(&pDevice->RxMngWorkItem);\r\n}\r\n}\r\nelse {\r\n};\r\nreturn false;\r\n}\r\nelse {\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif ( !(*pbyRsr & RSR_BSSIDOK)) {\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\nreturn false;\r\n}\r\n}\r\nelse {\r\nif ((pDevice->bLinkPass == false) ||\r\n!(*pbyRsr & RSR_BSSIDOK)) {\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\nreturn false;\r\n}\r\n{\r\nu8 Protocol_Version;\r\nu8 Packet_Type;\r\nu8 Descriptor_type;\r\nu16 Key_info;\r\nif (bIsWEP)\r\ncbIVOffset = 8;\r\nelse\r\ncbIVOffset = 0;\r\nwEtherType = (skb->data[cbIVOffset + 8 + 24 + 6] << 8) |\r\nskb->data[cbIVOffset + 8 + 24 + 6 + 1];\r\nProtocol_Version = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1];\r\nPacket_Type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1];\r\nif (wEtherType == ETH_P_PAE) {\r\nif(((Protocol_Version==1) ||(Protocol_Version==2)) &&\r\n(Packet_Type==3)) {\r\nbRxeapol_key = true;\r\nDescriptor_type = skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1+1+2];\r\nKey_info = (skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1+1+2+1]<<8) |skb->data[cbIVOffset + 8 + 24 + 6 + 1 +1+1+1+2+2] ;\r\nif(Descriptor_type==2) {\r\n}\r\nelse if(Descriptor_type==254) {\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (pDevice->bEnablePSMode) {\r\nif (IS_FC_MOREDATA((pbyFrame))) {\r\nif (*pbyRsr & RSR_ADDROK) {\r\n}\r\n}\r\nelse {\r\nif (pMgmt->bInTIMWake == true) {\r\npMgmt->bInTIMWake = false;\r\n}\r\n}\r\n}\r\nif (pDevice->bDiversityEnable && (FrameSize>50) &&\r\n(pDevice->eOPMode == OP_MODE_INFRASTRUCTURE) &&\r\n(pDevice->bLinkPass == true)) {\r\nBBvAntennaDiversity(pDevice, s_byGetRateIdx(*pbyRxRate), 0);\r\n}\r\npDevice->uCurrRSSI = *pbyRSSI;\r\npDevice->byCurrSQ = *pbySQ;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) && (pDevice->bEnable8021x == true)){\r\nu8 abyMacHdr[24];\r\nif (bIsWEP)\r\ncbIVOffset = 8;\r\nelse\r\ncbIVOffset = 0;\r\nwEtherType = (skb->data[cbIVOffset + 8 + 24 + 6] << 8) |\r\nskb->data[cbIVOffset + 8 + 24 + 6 + 1];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"wEtherType = %04x \n", wEtherType);\r\nif (wEtherType == ETH_P_PAE) {\r\nskb->dev = pDevice->apdev;\r\nif (bIsWEP == true) {\r\nmemcpy(&abyMacHdr[0], (skb->data + 8), 24);\r\nmemcpy((skb->data + 8 + cbIVOffset), &abyMacHdr[0], 24);\r\n}\r\nskb->data += (cbIVOffset + 8);\r\nskb->tail += (cbIVOffset + 8);\r\nskb_put(skb, FrameSize);\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\nreturn true;\r\n}\r\nif (!(pMgmt->sNodeDBTable[iSANodeIndex].dwFlags & WLAN_STA_AUTHORIZED))\r\nreturn false;\r\n}\r\nif ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {\r\nif (bIsWEP) {\r\nFrameSize -= 8;\r\n}\r\n}\r\nif ((pKey != NULL) && (pKey->byCipherSuite == KEY_CTL_TKIP)) {\r\nif (bIsWEP) {\r\nu32 * pdwMIC_L;\r\nu32 * pdwMIC_R;\r\nu32 dwMIC_Priority;\r\nu32 dwMICKey0 = 0, dwMICKey1 = 0;\r\nu32 dwLocalMIC_L = 0;\r\nu32 dwLocalMIC_R = 0;\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\ndwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[24]));\r\ndwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[28]));\r\n}\r\nelse {\r\nif (pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) {\r\ndwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[16]));\r\ndwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[20]));\r\n} else if ((pKey->dwKeyIndex & BIT28) == 0) {\r\ndwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[16]));\r\ndwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[20]));\r\n} else {\r\ndwMICKey0 = cpu_to_le32(*(u32 *)(&pKey->abyKey[24]));\r\ndwMICKey1 = cpu_to_le32(*(u32 *)(&pKey->abyKey[28]));\r\n}\r\n}\r\nMIC_vInit(dwMICKey0, dwMICKey1);\r\nMIC_vAppend((u8 *)&(pDevice->sRxEthHeader.h_dest[0]), 12);\r\ndwMIC_Priority = 0;\r\nMIC_vAppend((u8 *)&dwMIC_Priority, 4);\r\nMIC_vAppend((u8 *)(skb->data + 8 + WLAN_HDR_ADDR3_LEN + 8),\r\nFrameSize - WLAN_HDR_ADDR3_LEN - 8);\r\nMIC_vGetMIC(&dwLocalMIC_L, &dwLocalMIC_R);\r\nMIC_vUnInit();\r\npdwMIC_L = (u32 *)(skb->data + 8 + FrameSize);\r\npdwMIC_R = (u32 *)(skb->data + 8 + FrameSize + 4);\r\nif ((cpu_to_le32(*pdwMIC_L) != dwLocalMIC_L) || (cpu_to_le32(*pdwMIC_R) != dwLocalMIC_R) ||\r\n(pDevice->bRxMICFail == true)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC comparison is fail!\n");\r\npDevice->bRxMICFail = false;\r\npDevice->s802_11Counter.TKIPLocalMICFailures++;\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\n{\r\nunion iwreq_data wrqu;\r\nstruct iw_michaelmicfailure ev;\r\nint keyidx = pbyFrame[cbHeaderSize+3] >> 6;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.flags = keyidx & IW_MICFAILURE_KEY_ID;\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&\r\n(pMgmt->eCurrState == WMAC_STATE_ASSOC) &&\r\n(*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) {\r\nev.flags |= IW_MICFAILURE_PAIRWISE;\r\n} else {\r\nev.flags |= IW_MICFAILURE_GROUP;\r\n}\r\nev.src_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(ev.src_addr.sa_data, pMACHeader->addr2, ETH_ALEN);\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwrqu.data.length = sizeof(ev);\r\nPRINT_K("wireless_send_event--->IWEVMICHAELMICFAILURE\n");\r\nwireless_send_event(pDevice->dev, IWEVMICHAELMICFAILURE, &wrqu, (char *)&ev);\r\n}\r\nreturn false;\r\n}\r\n}\r\n}\r\nif ((pKey != NULL) && ((pKey->byCipherSuite == KEY_CTL_TKIP) ||\r\n(pKey->byCipherSuite == KEY_CTL_CCMP))) {\r\nif (bIsWEP) {\r\nu16 wLocalTSC15_0 = 0;\r\nu32 dwLocalTSC47_16 = 0;\r\nunsigned long long RSC = 0;\r\nRSC = *((unsigned long long *) &(pKey->KeyRSC));\r\nwLocalTSC15_0 = (u16) RSC;\r\ndwLocalTSC47_16 = (u32) (RSC>>16);\r\nRSC = dwRxTSC47_16;\r\nRSC <<= 16;\r\nRSC += wRxTSC15_0;\r\nmemcpy(&(pKey->KeyRSC), &RSC, sizeof(u64));\r\nif (pDevice->vnt_mgmt.eCurrMode == WMAC_MODE_ESS_STA &&\r\npDevice->vnt_mgmt.eCurrState == WMAC_STATE_ASSOC) {\r\nif ( (wRxTSC15_0 < wLocalTSC15_0) &&\r\n(dwRxTSC47_16 <= dwLocalTSC47_16) &&\r\n!((dwRxTSC47_16 == 0) && (dwLocalTSC47_16 == 0xFFFFFFFF))) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC is illegal~~!\n ");\r\nif (pKey->byCipherSuite == KEY_CTL_TKIP)\r\npDevice->s802_11Counter.TKIPReplays++;\r\nelse\r\npDevice->s802_11Counter.CCMPReplays++;\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\nreturn false;\r\n}\r\n}\r\n}\r\n}\r\ns_vProcessRxMACHeader(pDevice, (u8 *)(skb->data+8), FrameSize, bIsWEP, bExtIV, &cbHeaderOffset);\r\nFrameSize -= cbHeaderOffset;\r\ncbHeaderOffset += 8;\r\nif (FrameSize < 12)\r\nreturn false;\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif (s_bAPModeRxData(pDevice,\r\nskb,\r\nFrameSize,\r\ncbHeaderOffset,\r\niSANodeIndex,\r\niDANodeIndex\r\n) == false) {\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\nreturn false;\r\n}\r\n}\r\nskb->data += cbHeaderOffset;\r\nskb->tail += cbHeaderOffset;\r\nskb_put(skb, FrameSize);\r\nskb->protocol=eth_type_trans(skb, skb->dev);\r\nskb->ip_summed=CHECKSUM_NONE;\r\npStats->rx_bytes +=skb->len;\r\npStats->rx_packets++;\r\nnetif_rx(skb);\r\nif (bDeFragRx) {\r\nif (!device_alloc_frag_buf(pDevice, &pDevice->sRxDFCB[pDevice->uCurrentDFCBIdx])) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc more frag bufs\n",\r\npDevice->dev->name);\r\n}\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int s_bAPModeRxCtl(struct vnt_private *pDevice, u8 *pbyFrame,\r\ns32 iSANodeIndex)\r\n{\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nstruct ieee80211_hdr *p802_11Header;\r\nCMD_STATUS Status;\r\nif (IS_CTL_PSPOLL(pbyFrame) || !IS_TYPE_CONTROL(pbyFrame)) {\r\np802_11Header = (struct ieee80211_hdr *) (pbyFrame);\r\nif (!IS_TYPE_MGMT(pbyFrame)) {\r\nif (iSANodeIndex > 0) {\r\nif (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_AUTH) {\r\nvMgrDeAuthenBeginSta(pDevice,\r\npMgmt,\r\n(u8 *)(p802_11Header->addr2),\r\n(WLAN_MGMT_REASON_CLASS2_NONAUTH),\r\n&Status\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 1\n");\r\nreturn true;\r\n}\r\nif (pMgmt->sNodeDBTable[iSANodeIndex].eNodeState < NODE_ASSOC) {\r\nvMgrDisassocBeginSta(pDevice,\r\npMgmt,\r\n(u8 *)(p802_11Header->addr2),\r\n(WLAN_MGMT_REASON_CLASS3_NONASSOC),\r\n&Status\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDisassocBeginSta 2\n");\r\nreturn true;\r\n}\r\nif (pMgmt->sNodeDBTable[iSANodeIndex].bPSEnable) {\r\nif (IS_CTL_PSPOLL(pbyFrame)) {\r\npMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_RX_PSPOLL,\r\nNULL);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 1\n");\r\n}\r\nelse {\r\nif (!IS_FC_POWERMGT(pbyFrame)) {\r\npMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;\r\npMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_RX_PSPOLL,\r\nNULL);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 2\n");\r\n}\r\n}\r\n}\r\nelse {\r\nif (IS_FC_POWERMGT(pbyFrame)) {\r\npMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = true;\r\npMgmt->sNodeDBTable[0].bPSEnable = true;\r\n}\r\nelse {\r\nif (pMgmt->sNodeDBTable[iSANodeIndex].wEnQueueCnt > 0) {\r\npMgmt->sNodeDBTable[iSANodeIndex].bPSEnable = false;\r\npMgmt->sNodeDBTable[iSANodeIndex].bRxPSPoll = true;\r\nbScheduleCommand((void *) pDevice,\r\nWLAN_CMD_RX_PSPOLL,\r\nNULL);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: WLAN_CMD_RX_PSPOLL 3\n");\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nvMgrDeAuthenBeginSta(pDevice,\r\npMgmt,\r\n(u8 *)(p802_11Header->addr2),\r\n(WLAN_MGMT_REASON_CLASS2_NONAUTH),\r\n&Status\r\n);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: send vMgrDeAuthenBeginSta 3\n");\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "BSSID:%pM\n",\r\np802_11Header->addr3);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR2:%pM\n",\r\np802_11Header->addr2);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "ADDR1:%pM\n",\r\np802_11Header->addr1);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dpc: frame_control= %x\n", p802_11Header->frame_control);\r\nreturn true;\r\n}\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int s_bHandleRxEncryption(struct vnt_private *pDevice, u8 *pbyFrame,\r\nu32 FrameSize, u8 *pbyRsr, u8 *pbyNewRsr, PSKeyItem *pKeyOut,\r\ns32 *pbExtIV, u16 *pwRxTSC15_0, u32 *pdwRxTSC47_16)\r\n{\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nu32 PayloadLen = FrameSize;\r\nu8 *pbyIV;\r\nu8 byKeyIdx;\r\nPSKeyItem pKey = NULL;\r\nu8 byDecMode = KEY_CTL_WEP;\r\n*pwRxTSC15_0 = 0;\r\n*pdwRxTSC47_16 = 0;\r\npbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;\r\nif ( WLAN_GET_FC_TODS(*(u16 *)pbyFrame) &&\r\nWLAN_GET_FC_FROMDS(*(u16 *)pbyFrame) ) {\r\npbyIV += 6;\r\nPayloadLen -= 6;\r\n}\r\nbyKeyIdx = (*(pbyIV+3) & 0xc0);\r\nbyKeyIdx >>= 6;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);\r\nif ((pMgmt->eAuthenMode == WMAC_AUTH_WPA) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPAPSK) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPANONE) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPA2) ||\r\n(pMgmt->eAuthenMode == WMAC_AUTH_WPA2PSK)) {\r\nif (((*pbyRsr & (RSR_ADDRBROAD | RSR_ADDRMULTI)) == 0) &&\r\n(pMgmt->byCSSPK != KEY_CTL_NONE)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt\n");\r\nif (KeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, 0xFFFFFFFF, &pKey) == true) {\r\nif (pMgmt->byCSSPK == KEY_CTL_TKIP)\r\nbyDecMode = KEY_CTL_TKIP;\r\nelse if (pMgmt->byCSSPK == KEY_CTL_CCMP)\r\nbyDecMode = KEY_CTL_CCMP;\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"unicast pkt: %d, %p\n", byDecMode, pKey);\r\n} else {\r\nKeybGetKey(&(pDevice->sKey), pDevice->abyBSSID, byKeyIdx, &pKey);\r\nif (pMgmt->byCSSGK == KEY_CTL_TKIP)\r\nbyDecMode = KEY_CTL_TKIP;\r\nelse if (pMgmt->byCSSGK == KEY_CTL_CCMP)\r\nbyDecMode = KEY_CTL_CCMP;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"group pkt: %d, %d, %p\n", byKeyIdx, byDecMode, pKey);\r\n}\r\n}\r\nif (pKey == NULL) {\r\nKeybGetKey(&(pDevice->sKey), pDevice->abyBroadcastAddr, byKeyIdx, &pKey);\r\nif (pMgmt->byCSSGK == KEY_CTL_TKIP)\r\nbyDecMode = KEY_CTL_TKIP;\r\nelse if (pMgmt->byCSSGK == KEY_CTL_CCMP)\r\nbyDecMode = KEY_CTL_CCMP;\r\n}\r\n*pKeyOut = pKey;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pMgmt->byCSSPK, pMgmt->byCSSGK, byDecMode);\r\nif (pKey == NULL) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey == NULL\n");\r\nif (byDecMode == KEY_CTL_WEP) {\r\n} else if (pDevice->bLinkPass == true) {\r\n}\r\nreturn false;\r\n}\r\nif (byDecMode != pKey->byCipherSuite) {\r\nif (byDecMode == KEY_CTL_WEP) {\r\n} else if (pDevice->bLinkPass == true) {\r\n}\r\n*pKeyOut = NULL;\r\nreturn false;\r\n}\r\nif (byDecMode == KEY_CTL_WEP) {\r\nif ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||\r\n(((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true)) {\r\nPayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4);\r\nmemcpy(pDevice->abyPRNG, pbyIV, 3);\r\nmemcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);\r\nrc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);\r\nif (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\n}\r\n}\r\n} else if ((byDecMode == KEY_CTL_TKIP) ||\r\n(byDecMode == KEY_CTL_CCMP)) {\r\nPayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4);\r\n*pdwRxTSC47_16 = cpu_to_le32(*(u32 *)(pbyIV + 4));\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %x\n", *pdwRxTSC47_16);\r\nif (byDecMode == KEY_CTL_TKIP) {\r\n*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));\r\n} else {\r\n*pwRxTSC15_0 = cpu_to_le16(*(u16 *)pbyIV);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);\r\nif ((byDecMode == KEY_CTL_TKIP) &&\r\n(pDevice->byLocalID <= REV_ID_VT3253_A1)) {\r\nstruct ieee80211_hdr *pMACHeader = (struct ieee80211_hdr *) (pbyFrame);\r\nTKIPvMixKey(pKey->abyKey, pMACHeader->addr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);\r\nrc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);\r\nif (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);\r\n}\r\n}\r\n}\r\nif ((*(pbyIV+3) & 0x20) != 0)\r\n*pbExtIV = true;\r\nreturn true;\r\n}\r\nstatic int s_bHostWepRxEncryption(struct vnt_private *pDevice, u8 *pbyFrame,\r\nu32 FrameSize, u8 *pbyRsr, int bOnFly, PSKeyItem pKey, u8 *pbyNewRsr,\r\ns32 *pbExtIV, u16 *pwRxTSC15_0, u32 *pdwRxTSC47_16)\r\n{\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nstruct ieee80211_hdr *pMACHeader;\r\nu32 PayloadLen = FrameSize;\r\nu8 *pbyIV;\r\nu8 byKeyIdx;\r\nu8 byDecMode = KEY_CTL_WEP;\r\n*pwRxTSC15_0 = 0;\r\n*pdwRxTSC47_16 = 0;\r\npbyIV = pbyFrame + WLAN_HDR_ADDR3_LEN;\r\nif ( WLAN_GET_FC_TODS(*(u16 *)pbyFrame) &&\r\nWLAN_GET_FC_FROMDS(*(u16 *)pbyFrame) ) {\r\npbyIV += 6;\r\nPayloadLen -= 6;\r\n}\r\nbyKeyIdx = (*(pbyIV+3) & 0xc0);\r\nbyKeyIdx >>= 6;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"\nKeyIdx: %d\n", byKeyIdx);\r\nif (pMgmt->byCSSGK == KEY_CTL_TKIP)\r\nbyDecMode = KEY_CTL_TKIP;\r\nelse if (pMgmt->byCSSGK == KEY_CTL_CCMP)\r\nbyDecMode = KEY_CTL_CCMP;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"AES:%d %d %d\n", pMgmt->byCSSPK, pMgmt->byCSSGK, byDecMode);\r\nif (byDecMode != pKey->byCipherSuite) {\r\nif (byDecMode == KEY_CTL_WEP) {\r\n} else if (pDevice->bLinkPass == true) {\r\n}\r\nreturn false;\r\n}\r\nif (byDecMode == KEY_CTL_WEP) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"byDecMode == KEY_CTL_WEP\n");\r\nif ((pDevice->byLocalID <= REV_ID_VT3253_A1) ||\r\n(((PSKeyTable)(pKey->pvKeyTable))->bSoftWEP == true) ||\r\n(bOnFly == false)) {\r\nPayloadLen -= (WLAN_HDR_ADDR3_LEN + 4 + 4);\r\nmemcpy(pDevice->abyPRNG, pbyIV, 3);\r\nmemcpy(pDevice->abyPRNG + 3, pKey->abyKey, pKey->uKeyLength);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, pKey->uKeyLength + 3);\r\nrc4_encrypt(&pDevice->SBox, pbyIV+4, pbyIV+4, PayloadLen);\r\nif (ETHbIsBufferCrc32Ok(pbyIV+4, PayloadLen)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\n}\r\n}\r\n} else if ((byDecMode == KEY_CTL_TKIP) ||\r\n(byDecMode == KEY_CTL_CCMP)) {\r\nPayloadLen -= (WLAN_HDR_ADDR3_LEN + 8 + 4);\r\n*pdwRxTSC47_16 = cpu_to_le32(*(u32 *)(pbyIV + 4));\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %x\n", *pdwRxTSC47_16);\r\nif (byDecMode == KEY_CTL_TKIP) {\r\n*pwRxTSC15_0 = cpu_to_le16(MAKEWORD(*(pbyIV+2), *pbyIV));\r\n} else {\r\n*pwRxTSC15_0 = cpu_to_le16(*(u16 *)pbyIV);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"TSC0_15: %x\n", *pwRxTSC15_0);\r\nif (byDecMode == KEY_CTL_TKIP) {\r\nif ((pDevice->byLocalID <= REV_ID_VT3253_A1) || (bOnFly == false)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_TKIP \n");\r\npMACHeader = (struct ieee80211_hdr *) (pbyFrame);\r\nTKIPvMixKey(pKey->abyKey, pMACHeader->addr2, *pwRxTSC15_0, *pdwRxTSC47_16, pDevice->abyPRNG);\r\nrc4_init(&pDevice->SBox, pDevice->abyPRNG, TKIP_KEY_LEN);\r\nrc4_encrypt(&pDevice->SBox, pbyIV+8, pbyIV+8, PayloadLen);\r\nif (ETHbIsBufferCrc32Ok(pbyIV+8, PayloadLen)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV OK!\n");\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ICV FAIL!!!\n");\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"PayloadLen = %d\n", PayloadLen);\r\n}\r\n}\r\n}\r\nif (byDecMode == KEY_CTL_CCMP) {\r\nif (bOnFly == false) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"soft KEY_CTL_CCMP\n");\r\nif (AESbGenCCMP(pKey->abyKey, pbyFrame, FrameSize)) {\r\n*pbyNewRsr |= NEWRSR_DECRYPTOK;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC compare OK!\n");\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"CCMP MIC fail!\n");\r\n}\r\n}\r\n}\r\n}\r\nif ((*(pbyIV+3) & 0x20) != 0)\r\n*pbExtIV = true;\r\nreturn true;\r\n}\r\nstatic int s_bAPModeRxData(struct vnt_private *pDevice, struct sk_buff *skb,\r\nu32 FrameSize, u32 cbHeaderOffset, s32 iSANodeIndex, s32 iDANodeIndex)\r\n{\r\nstruct sk_buff *skbcpy;\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nint bRelayAndForward = false;\r\nint bRelayOnly = false;\r\nu8 byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};\r\nu16 wAID;\r\nif (FrameSize > CB_MAX_BUF_SIZE)\r\nreturn false;\r\nif (is_multicast_ether_addr((u8 *)(skb->data+cbHeaderOffset))) {\r\nif (pMgmt->sNodeDBTable[0].bPSEnable) {\r\nskbcpy = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (skbcpy == NULL) {\r\nDBG_PRT(MSG_LEVEL_NOTICE, KERN_INFO "relay multicast no skb available \n");\r\n}\r\nelse {\r\nskbcpy->dev = pDevice->dev;\r\nskbcpy->len = FrameSize;\r\nmemcpy(skbcpy->data, skb->data+cbHeaderOffset, FrameSize);\r\nskb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skbcpy);\r\npMgmt->sNodeDBTable[0].wEnQueueCnt++;\r\npMgmt->abyPSTxMap[0] |= byMask[0];\r\n}\r\n}\r\nelse {\r\nbRelayAndForward = true;\r\n}\r\n}\r\nelse {\r\nif (BSSbIsSTAInNodeDB(pDevice, (u8 *)(skb->data+cbHeaderOffset), &iDANodeIndex)) {\r\nif (pMgmt->sNodeDBTable[iDANodeIndex].eNodeState >= NODE_ASSOC) {\r\nif (pMgmt->sNodeDBTable[iDANodeIndex].bPSEnable) {\r\nskb->data += cbHeaderOffset;\r\nskb->tail += cbHeaderOffset;\r\nskb_put(skb, FrameSize);\r\nskb_queue_tail(&pMgmt->sNodeDBTable[iDANodeIndex].sTxPSQueue, skb);\r\npMgmt->sNodeDBTable[iDANodeIndex].wEnQueueCnt++;\r\nwAID = pMgmt->sNodeDBTable[iDANodeIndex].wAID;\r\npMgmt->abyPSTxMap[wAID >> 3] |= byMask[wAID & 7];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "relay: index= %d, pMgmt->abyPSTxMap[%d]= %d\n",\r\niDANodeIndex, (wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);\r\nreturn true;\r\n}\r\nelse {\r\nbRelayOnly = true;\r\n}\r\n}\r\n}\r\n}\r\nif (bRelayOnly || bRelayAndForward) {\r\nif (bRelayAndForward)\r\niDANodeIndex = 0;\r\nif ((pDevice->uAssocCount > 1) && (iDANodeIndex >= 0)) {\r\nbRelayPacketSend(pDevice, (u8 *) (skb->data + cbHeaderOffset),\r\nFrameSize, (unsigned int) iDANodeIndex);\r\n}\r\nif (bRelayOnly)\r\nreturn false;\r\n}\r\nif (pDevice->uAssocCount == 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid RXvWorkItem(struct vnt_private *pDevice)\r\n{\r\nint ntStatus;\r\nPRCB pRCB = NULL;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->Rx Polling Thread\n");\r\nspin_lock_irq(&pDevice->lock);\r\nwhile ((pDevice->Flags & fMP_POST_READS) &&\r\nMP_IS_READY(pDevice) &&\r\n(pDevice->NumRecvFreeList != 0) ) {\r\npRCB = pDevice->FirstRecvFreeList;\r\npDevice->NumRecvFreeList--;\r\nASSERT(pRCB);\r\nDequeueRCB(pDevice->FirstRecvFreeList, pDevice->LastRecvFreeList);\r\nntStatus = PIPEnsBulkInUsbRead(pDevice, pRCB);\r\n}\r\npDevice->bIsRxWorkItemQueued = false;\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\nvoid RXvFreeRCB(PRCB pRCB, int bReAllocSkb)\r\n{\r\nstruct vnt_private *pDevice = pRCB->pDevice;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->RXvFreeRCB\n");\r\nASSERT(!pRCB->Ref);\r\nASSERT(pRCB->pDevice);\r\nif (bReAllocSkb == false) {\r\nkfree_skb(pRCB->skb);\r\nbReAllocSkb = true;\r\n}\r\nif (bReAllocSkb == true) {\r\npRCB->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (pRCB->skb == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to re-alloc rx skb\n");\r\n}else {\r\npRCB->skb->dev = pDevice->dev;\r\n}\r\n}\r\nEnqueueRCB(pDevice->FirstRecvFreeList, pDevice->LastRecvFreeList, pRCB);\r\npDevice->NumRecvFreeList++;\r\nif ((pDevice->Flags & fMP_POST_READS) && MP_IS_READY(pDevice) &&\r\n(pDevice->bIsRxWorkItemQueued == false) ) {\r\npDevice->bIsRxWorkItemQueued = true;\r\ntasklet_schedule(&pDevice->ReadWorkItem);\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"<----RXFreeRCB %d %d\n",pDevice->NumRecvFreeList, pDevice->NumRecvMngList);\r\n}\r\nvoid RXvMngWorkItem(struct vnt_private *pDevice)\r\n{\r\nPRCB pRCB = NULL;\r\nstruct vnt_rx_mgmt *pRxPacket;\r\nint bReAllocSkb = false;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"---->Rx Mng Thread\n");\r\nspin_lock_irq(&pDevice->lock);\r\nwhile (pDevice->NumRecvMngList!=0)\r\n{\r\npRCB = pDevice->FirstRecvMngList;\r\npDevice->NumRecvMngList--;\r\nDequeueRCB(pDevice->FirstRecvMngList, pDevice->LastRecvMngList);\r\nif(!pRCB){\r\nbreak;\r\n}\r\nASSERT(pRCB);\r\npRxPacket = &(pRCB->sMngPacket);\r\nvMgrRxManagePacket(pDevice, &pDevice->vnt_mgmt, pRxPacket);\r\npRCB->Ref--;\r\nif(pRCB->Ref == 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"RxvFreeMng %d %d\n",pDevice->NumRecvFreeList, pDevice->NumRecvMngList);\r\nRXvFreeRCB(pRCB, bReAllocSkb);\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Rx Mng Only we have the right to free RCB\n");\r\n}\r\n}\r\npDevice->bIsRxMngWorkItemQueued = false;\r\nspin_unlock_irq(&pDevice->lock);\r\n}
