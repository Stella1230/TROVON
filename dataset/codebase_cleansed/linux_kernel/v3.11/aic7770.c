struct aic7770_identity *\r\naic7770_find_device(uint32_t id)\r\n{\r\nstruct aic7770_identity *entry;\r\nint i;\r\nfor (i = 0; i < ahc_num_aic7770_devs; i++) {\r\nentry = &aic7770_ident_table[i];\r\nif (entry->full_id == (id & entry->id_mask))\r\nreturn (entry);\r\n}\r\nreturn (NULL);\r\n}\r\nint\r\naic7770_config(struct ahc_softc *ahc, struct aic7770_identity *entry, u_int io)\r\n{\r\nint error;\r\nint have_seeprom;\r\nu_int hostconf;\r\nu_int irq;\r\nu_int intdef;\r\nerror = entry->setup(ahc);\r\nhave_seeprom = 0;\r\nif (error != 0)\r\nreturn (error);\r\nerror = aic7770_map_registers(ahc, io);\r\nif (error != 0)\r\nreturn (error);\r\nahc_intr_enable(ahc, FALSE);\r\nahc->description = entry->name;\r\nerror = ahc_softc_init(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nahc->bus_chip_init = aic7770_chip_init;\r\nerror = ahc_reset(ahc, FALSE);\r\nif (error != 0)\r\nreturn (error);\r\nintdef = ahc_inb(ahc, INTDEF);\r\nirq = intdef & VECTOR;\r\nswitch (irq) {\r\ncase 9:\r\ncase 10:\r\ncase 11:\r\ncase 12:\r\ncase 14:\r\ncase 15:\r\nbreak;\r\ndefault:\r\nprintk("aic7770_config: invalid irq setting %d\n", intdef);\r\nreturn (ENXIO);\r\n}\r\nif ((intdef & EDGE_TRIG) != 0)\r\nahc->flags |= AHC_EDGE_INTERRUPT;\r\nswitch (ahc->chip & (AHC_EISA|AHC_VL)) {\r\ncase AHC_EISA:\r\n{\r\nu_int biosctrl;\r\nu_int scsiconf;\r\nu_int scsiconf1;\r\nbiosctrl = ahc_inb(ahc, HA_274_BIOSCTRL);\r\nscsiconf = ahc_inb(ahc, SCSICONF);\r\nscsiconf1 = ahc_inb(ahc, SCSICONF + 1);\r\nif ((biosctrl & CHANNEL_B_PRIMARY) != 0)\r\nahc->flags |= 1;\r\nif ((biosctrl & BIOSMODE) == BIOSDISABLED) {\r\nahc->flags |= AHC_USEDEFAULTS;\r\n} else {\r\nif ((ahc->features & AHC_WIDE) != 0) {\r\nahc->our_id = scsiconf1 & HWSCSIID;\r\nif (scsiconf & TERM_ENB)\r\nahc->flags |= AHC_TERM_ENB_A;\r\n} else {\r\nahc->our_id = scsiconf & HSCSIID;\r\nahc->our_id_b = scsiconf1 & HSCSIID;\r\nif (scsiconf & TERM_ENB)\r\nahc->flags |= AHC_TERM_ENB_A;\r\nif (scsiconf1 & TERM_ENB)\r\nahc->flags |= AHC_TERM_ENB_B;\r\n}\r\n}\r\nif ((ahc_inb(ahc, HA_274_BIOSGLOBAL) & HA_274_EXTENDED_TRANS))\r\nahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B;\r\nbreak;\r\n}\r\ncase AHC_VL:\r\n{\r\nhave_seeprom = aha2840_load_seeprom(ahc);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nif (have_seeprom == 0) {\r\nkfree(ahc->seep_config);\r\nahc->seep_config = NULL;\r\n}\r\nahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~AUTOFLUSHDIS);\r\nhostconf = ahc_inb(ahc, HOSTCONF);\r\nahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);\r\nahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);\r\nahc->bus_softc.aic7770_softc.busspd = hostconf & DFTHRSH;\r\nahc->bus_softc.aic7770_softc.bustime = (hostconf << 2) & BOFF;\r\nerror = ahc_init(ahc);\r\nif (error != 0)\r\nreturn (error);\r\nerror = aic7770_map_int(ahc, irq);\r\nif (error != 0)\r\nreturn (error);\r\nahc->init_level++;\r\nahc_outb(ahc, BCTL, ENABLE);\r\nreturn (0);\r\n}\r\nstatic int\r\naic7770_chip_init(struct ahc_softc *ahc)\r\n{\r\nahc_outb(ahc, BUSSPD, ahc->bus_softc.aic7770_softc.busspd);\r\nahc_outb(ahc, BUSTIME, ahc->bus_softc.aic7770_softc.bustime);\r\nahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~AUTOFLUSHDIS);\r\nahc_outb(ahc, BCTL, ENABLE);\r\nreturn (ahc_chip_init(ahc));\r\n}\r\nstatic int\r\naha2840_load_seeprom(struct ahc_softc *ahc)\r\n{\r\nstruct seeprom_descriptor sd;\r\nstruct seeprom_config *sc;\r\nint have_seeprom;\r\nuint8_t scsi_conf;\r\nsd.sd_ahc = ahc;\r\nsd.sd_control_offset = SEECTL_2840;\r\nsd.sd_status_offset = STATUS_2840;\r\nsd.sd_dataout_offset = STATUS_2840;\r\nsd.sd_chip = C46;\r\nsd.sd_MS = 0;\r\nsd.sd_RDY = EEPROM_TF;\r\nsd.sd_CS = CS_2840;\r\nsd.sd_CK = CK_2840;\r\nsd.sd_DO = DO_2840;\r\nsd.sd_DI = DI_2840;\r\nsc = ahc->seep_config;\r\nif (bootverbose)\r\nprintk("%s: Reading SEEPROM...", ahc_name(ahc));\r\nhave_seeprom = ahc_read_seeprom(&sd, (uint16_t *)sc,\r\n0, sizeof(*sc)/2);\r\nif (have_seeprom) {\r\nif (ahc_verify_cksum(sc) == 0) {\r\nif(bootverbose)\r\nprintk ("checksum error\n");\r\nhave_seeprom = 0;\r\n} else if (bootverbose) {\r\nprintk("done.\n");\r\n}\r\n}\r\nif (!have_seeprom) {\r\nif (bootverbose)\r\nprintk("%s: No SEEPROM available\n", ahc_name(ahc));\r\nahc->flags |= AHC_USEDEFAULTS;\r\n} else {\r\nint i;\r\nint max_targ;\r\nuint16_t discenable;\r\nmax_targ = (ahc->features & AHC_WIDE) != 0 ? 16 : 8;\r\ndiscenable = 0;\r\nfor (i = 0; i < max_targ; i++){\r\nuint8_t target_settings;\r\ntarget_settings = (sc->device_flags[i] & CFXFER) << 4;\r\nif (sc->device_flags[i] & CFSYNCH)\r\ntarget_settings |= SOFS;\r\nif (sc->device_flags[i] & CFWIDEB)\r\ntarget_settings |= WIDEXFER;\r\nif (sc->device_flags[i] & CFDISC)\r\ndiscenable |= (0x01 << i);\r\nahc_outb(ahc, TARG_SCSIRATE + i, target_settings);\r\n}\r\nahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));\r\nahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));\r\nahc->our_id = sc->brtime_id & CFSCSIID;\r\nscsi_conf = (ahc->our_id & 0x7);\r\nif (sc->adapter_control & CFSPARITY)\r\nscsi_conf |= ENSPCHK;\r\nif (sc->adapter_control & CFRESETB)\r\nscsi_conf |= RESET_SCSI;\r\nif (sc->bios_control & CF284XEXTEND)\r\nahc->flags |= AHC_EXTENDED_TRANS_A;\r\nahc_outb(ahc, SCSICONF, scsi_conf);\r\nif (sc->adapter_control & CF284XSTERM)\r\nahc->flags |= AHC_TERM_ENB_A;\r\n}\r\nreturn (have_seeprom);\r\n}\r\nstatic int\r\nahc_aic7770_VL_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7770_setup(ahc);\r\nahc->chip |= AHC_VL;\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_aic7770_EISA_setup(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = ahc_aic7770_setup(ahc);\r\nahc->chip |= AHC_EISA;\r\nreturn (error);\r\n}\r\nstatic int\r\nahc_aic7770_setup(struct ahc_softc *ahc)\r\n{\r\nahc->channel = 'A';\r\nahc->channel_b = 'B';\r\nahc->chip = AHC_AIC7770;\r\nahc->features = AHC_AIC7770_FE;\r\nahc->bugs |= AHC_TMODE_WIDEODD_BUG;\r\nahc->flags |= AHC_PAGESCBS;\r\nahc->instruction_ram_size = 448;\r\nreturn (0);\r\n}
