struct pcmcia_socket *pcmcia_get_socket(struct pcmcia_socket *skt)\r\n{\r\nstruct device *dev = get_device(&skt->dev);\r\nif (!dev)\r\nreturn NULL;\r\nreturn dev_get_drvdata(dev);\r\n}\r\nvoid pcmcia_put_socket(struct pcmcia_socket *skt)\r\n{\r\nput_device(&skt->dev);\r\n}\r\nstatic void pcmcia_release_socket(struct device *dev)\r\n{\r\nstruct pcmcia_socket *socket = dev_get_drvdata(dev);\r\ncomplete(&socket->socket_released);\r\n}\r\nint pcmcia_register_socket(struct pcmcia_socket *socket)\r\n{\r\nstruct task_struct *tsk;\r\nint ret;\r\nif (!socket || !socket->ops || !socket->dev.parent || !socket->resource_ops)\r\nreturn -EINVAL;\r\ndev_dbg(&socket->dev, "pcmcia_register_socket(0x%p)\n", socket->ops);\r\ndown_write(&pcmcia_socket_list_rwsem);\r\nif (list_empty(&pcmcia_socket_list))\r\nsocket->sock = 0;\r\nelse {\r\nunsigned int found, i = 1;\r\nstruct pcmcia_socket *tmp;\r\ndo {\r\nfound = 1;\r\nlist_for_each_entry(tmp, &pcmcia_socket_list, socket_list) {\r\nif (tmp->sock == i)\r\nfound = 0;\r\n}\r\ni++;\r\n} while (!found);\r\nsocket->sock = i - 1;\r\n}\r\nlist_add_tail(&socket->socket_list, &pcmcia_socket_list);\r\nup_write(&pcmcia_socket_list_rwsem);\r\n#ifndef CONFIG_CARDBUS\r\nsocket->features &= ~SS_CAP_CARDBUS;\r\n#endif\r\ndev_set_drvdata(&socket->dev, socket);\r\nsocket->dev.class = &pcmcia_socket_class;\r\ndev_set_name(&socket->dev, "pcmcia_socket%u", socket->sock);\r\nsocket->cis_mem.flags = 0;\r\nsocket->cis_mem.speed = cis_speed;\r\nINIT_LIST_HEAD(&socket->cis_cache);\r\ninit_completion(&socket->socket_released);\r\ninit_completion(&socket->thread_done);\r\nmutex_init(&socket->skt_mutex);\r\nmutex_init(&socket->ops_mutex);\r\nspin_lock_init(&socket->thread_lock);\r\nif (socket->resource_ops->init) {\r\nmutex_lock(&socket->ops_mutex);\r\nret = socket->resource_ops->init(socket);\r\nmutex_unlock(&socket->ops_mutex);\r\nif (ret)\r\ngoto err;\r\n}\r\ntsk = kthread_run(pccardd, socket, "pccardd");\r\nif (IS_ERR(tsk)) {\r\nret = PTR_ERR(tsk);\r\ngoto err;\r\n}\r\nwait_for_completion(&socket->thread_done);\r\nif (!socket->thread) {\r\ndev_printk(KERN_WARNING, &socket->dev,\r\n"PCMCIA: warning: socket thread did not start\n");\r\nreturn -EIO;\r\n}\r\npcmcia_parse_events(socket, SS_DETECT);\r\nrequest_module_nowait("pcmcia");\r\nreturn 0;\r\nerr:\r\ndown_write(&pcmcia_socket_list_rwsem);\r\nlist_del(&socket->socket_list);\r\nup_write(&pcmcia_socket_list_rwsem);\r\nreturn ret;\r\n}\r\nvoid pcmcia_unregister_socket(struct pcmcia_socket *socket)\r\n{\r\nif (!socket)\r\nreturn;\r\ndev_dbg(&socket->dev, "pcmcia_unregister_socket(0x%p)\n", socket->ops);\r\nif (socket->thread)\r\nkthread_stop(socket->thread);\r\ndown_write(&pcmcia_socket_list_rwsem);\r\nlist_del(&socket->socket_list);\r\nup_write(&pcmcia_socket_list_rwsem);\r\nif (socket->resource_ops->exit) {\r\nmutex_lock(&socket->ops_mutex);\r\nsocket->resource_ops->exit(socket);\r\nmutex_unlock(&socket->ops_mutex);\r\n}\r\nwait_for_completion(&socket->socket_released);\r\n}\r\nstruct pcmcia_socket *pcmcia_get_socket_by_nr(unsigned int nr)\r\n{\r\nstruct pcmcia_socket *s;\r\ndown_read(&pcmcia_socket_list_rwsem);\r\nlist_for_each_entry(s, &pcmcia_socket_list, socket_list)\r\nif (s->sock == nr) {\r\nup_read(&pcmcia_socket_list_rwsem);\r\nreturn s;\r\n}\r\nup_read(&pcmcia_socket_list_rwsem);\r\nreturn NULL;\r\n}\r\nstatic int socket_reset(struct pcmcia_socket *skt)\r\n{\r\nint status, i;\r\ndev_dbg(&skt->dev, "reset\n");\r\nskt->socket.flags |= SS_OUTPUT_ENA | SS_RESET;\r\nskt->ops->set_socket(skt, &skt->socket);\r\nudelay((long)reset_time);\r\nskt->socket.flags &= ~SS_RESET;\r\nskt->ops->set_socket(skt, &skt->socket);\r\nmsleep(unreset_delay * 10);\r\nfor (i = 0; i < unreset_limit; i++) {\r\nskt->ops->get_status(skt, &status);\r\nif (!(status & SS_DETECT))\r\nreturn -ENODEV;\r\nif (status & SS_READY)\r\nreturn 0;\r\nmsleep(unreset_check * 10);\r\n}\r\ndev_printk(KERN_ERR, &skt->dev, "time out after reset.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void socket_shutdown(struct pcmcia_socket *s)\r\n{\r\nint status;\r\ndev_dbg(&s->dev, "shutdown\n");\r\nif (s->callback)\r\ns->callback->remove(s);\r\nmutex_lock(&s->ops_mutex);\r\ns->state &= SOCKET_INUSE | SOCKET_PRESENT;\r\nmsleep(shutdown_delay * 10);\r\ns->state &= SOCKET_INUSE;\r\ns->socket = dead_socket;\r\ns->ops->init(s);\r\ns->ops->set_socket(s, &s->socket);\r\ns->lock_count = 0;\r\nkfree(s->fake_cis);\r\ns->fake_cis = NULL;\r\ns->functions = 0;\r\nmutex_unlock(&s->ops_mutex);\r\n#ifdef CONFIG_CARDBUS\r\ncb_free(s);\r\n#endif\r\nmsleep(100);\r\ns->ops->get_status(s, &status);\r\nif (status & SS_POWERON) {\r\ndev_printk(KERN_ERR, &s->dev,\r\n"*** DANGER *** unable to remove socket power\n");\r\n}\r\ns->state &= ~SOCKET_INUSE;\r\n}\r\nstatic int socket_setup(struct pcmcia_socket *skt, int initial_delay)\r\n{\r\nint status, i;\r\ndev_dbg(&skt->dev, "setup\n");\r\nskt->ops->get_status(skt, &status);\r\nif (!(status & SS_DETECT))\r\nreturn -ENODEV;\r\nmsleep(initial_delay * 10);\r\nfor (i = 0; i < 100; i++) {\r\nskt->ops->get_status(skt, &status);\r\nif (!(status & SS_DETECT))\r\nreturn -ENODEV;\r\nif (!(status & SS_PENDING))\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (status & SS_PENDING) {\r\ndev_printk(KERN_ERR, &skt->dev,\r\n"voltage interrogation timed out.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (status & SS_CARDBUS) {\r\nif (!(skt->features & SS_CAP_CARDBUS)) {\r\ndev_printk(KERN_ERR, &skt->dev,\r\n"cardbus cards are not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nskt->state |= SOCKET_CARDBUS;\r\n} else\r\nskt->state &= ~SOCKET_CARDBUS;\r\nif (status & SS_3VCARD)\r\nskt->socket.Vcc = skt->socket.Vpp = 33;\r\nelse if (!(status & SS_XVCARD))\r\nskt->socket.Vcc = skt->socket.Vpp = 50;\r\nelse {\r\ndev_printk(KERN_ERR, &skt->dev, "unsupported voltage key.\n");\r\nreturn -EIO;\r\n}\r\nif (skt->power_hook)\r\nskt->power_hook(skt, HOOK_POWER_PRE);\r\nskt->socket.flags = 0;\r\nskt->ops->set_socket(skt, &skt->socket);\r\nmsleep(vcc_settle * 10);\r\nskt->ops->get_status(skt, &status);\r\nif (!(status & SS_POWERON)) {\r\ndev_printk(KERN_ERR, &skt->dev, "unable to apply power.\n");\r\nreturn -EIO;\r\n}\r\nstatus = socket_reset(skt);\r\nif (skt->power_hook)\r\nskt->power_hook(skt, HOOK_POWER_POST);\r\nreturn status;\r\n}\r\nstatic int socket_insert(struct pcmcia_socket *skt)\r\n{\r\nint ret;\r\ndev_dbg(&skt->dev, "insert\n");\r\nmutex_lock(&skt->ops_mutex);\r\nif (skt->state & SOCKET_INUSE) {\r\nmutex_unlock(&skt->ops_mutex);\r\nreturn -EINVAL;\r\n}\r\nskt->state |= SOCKET_INUSE;\r\nret = socket_setup(skt, setup_delay);\r\nif (ret == 0) {\r\nskt->state |= SOCKET_PRESENT;\r\ndev_printk(KERN_NOTICE, &skt->dev,\r\n"pccard: %s card inserted into slot %d\n",\r\n(skt->state & SOCKET_CARDBUS) ? "CardBus" : "PCMCIA",\r\nskt->sock);\r\n#ifdef CONFIG_CARDBUS\r\nif (skt->state & SOCKET_CARDBUS) {\r\ncb_alloc(skt);\r\nskt->state |= SOCKET_CARDBUS_CONFIG;\r\n}\r\n#endif\r\ndev_dbg(&skt->dev, "insert done\n");\r\nmutex_unlock(&skt->ops_mutex);\r\nif (!(skt->state & SOCKET_CARDBUS) && (skt->callback))\r\nskt->callback->add(skt);\r\n} else {\r\nmutex_unlock(&skt->ops_mutex);\r\nsocket_shutdown(skt);\r\n}\r\nreturn ret;\r\n}\r\nstatic int socket_suspend(struct pcmcia_socket *skt)\r\n{\r\nif (skt->state & SOCKET_SUSPEND)\r\nreturn -EBUSY;\r\nmutex_lock(&skt->ops_mutex);\r\nskt->suspended_state = skt->state;\r\nskt->socket = dead_socket;\r\nskt->ops->set_socket(skt, &skt->socket);\r\nif (skt->ops->suspend)\r\nskt->ops->suspend(skt);\r\nskt->state |= SOCKET_SUSPEND;\r\nmutex_unlock(&skt->ops_mutex);\r\nreturn 0;\r\n}\r\nstatic int socket_early_resume(struct pcmcia_socket *skt)\r\n{\r\nmutex_lock(&skt->ops_mutex);\r\nskt->socket = dead_socket;\r\nskt->ops->init(skt);\r\nskt->ops->set_socket(skt, &skt->socket);\r\nif (skt->state & SOCKET_PRESENT)\r\nskt->resume_status = socket_setup(skt, resume_delay);\r\nmutex_unlock(&skt->ops_mutex);\r\nreturn 0;\r\n}\r\nstatic int socket_late_resume(struct pcmcia_socket *skt)\r\n{\r\nint ret = 0;\r\nmutex_lock(&skt->ops_mutex);\r\nskt->state &= ~SOCKET_SUSPEND;\r\nmutex_unlock(&skt->ops_mutex);\r\nif (!(skt->state & SOCKET_PRESENT)) {\r\nret = socket_insert(skt);\r\nif (ret == -ENODEV)\r\nret = 0;\r\nreturn ret;\r\n}\r\nif (skt->resume_status) {\r\nsocket_shutdown(skt);\r\nreturn 0;\r\n}\r\nif (skt->suspended_state != skt->state) {\r\ndev_dbg(&skt->dev,\r\n"suspend state 0x%x != resume state 0x%x\n",\r\nskt->suspended_state, skt->state);\r\nsocket_shutdown(skt);\r\nreturn socket_insert(skt);\r\n}\r\nif (!(skt->state & SOCKET_CARDBUS) && (skt->callback))\r\nret = skt->callback->early_resume(skt);\r\nreturn ret;\r\n}\r\nstatic int socket_complete_resume(struct pcmcia_socket *skt)\r\n{\r\nint ret = 0;\r\n#ifdef CONFIG_CARDBUS\r\nif (skt->state & SOCKET_CARDBUS) {\r\ncb_free(skt);\r\nret = cb_alloc(skt);\r\nif (ret)\r\ncb_free(skt);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int socket_resume(struct pcmcia_socket *skt)\r\n{\r\nint err;\r\nif (!(skt->state & SOCKET_SUSPEND))\r\nreturn -EBUSY;\r\nsocket_early_resume(skt);\r\nerr = socket_late_resume(skt);\r\nif (!err)\r\nerr = socket_complete_resume(skt);\r\nreturn err;\r\n}\r\nstatic void socket_remove(struct pcmcia_socket *skt)\r\n{\r\ndev_printk(KERN_NOTICE, &skt->dev,\r\n"pccard: card ejected from slot %d\n", skt->sock);\r\nsocket_shutdown(skt);\r\n}\r\nstatic void socket_detect_change(struct pcmcia_socket *skt)\r\n{\r\nif (!(skt->state & SOCKET_SUSPEND)) {\r\nint status;\r\nif (!(skt->state & SOCKET_PRESENT))\r\nmsleep(20);\r\nskt->ops->get_status(skt, &status);\r\nif ((skt->state & SOCKET_PRESENT) &&\r\n!(status & SS_DETECT))\r\nsocket_remove(skt);\r\nif (!(skt->state & SOCKET_PRESENT) &&\r\n(status & SS_DETECT))\r\nsocket_insert(skt);\r\n}\r\n}\r\nstatic int pccardd(void *__skt)\r\n{\r\nstruct pcmcia_socket *skt = __skt;\r\nint ret;\r\nskt->thread = current;\r\nskt->socket = dead_socket;\r\nskt->ops->init(skt);\r\nskt->ops->set_socket(skt, &skt->socket);\r\nret = device_register(&skt->dev);\r\nif (ret) {\r\ndev_printk(KERN_WARNING, &skt->dev,\r\n"PCMCIA: unable to register socket\n");\r\nskt->thread = NULL;\r\ncomplete(&skt->thread_done);\r\nreturn 0;\r\n}\r\nret = pccard_sysfs_add_socket(&skt->dev);\r\nif (ret)\r\ndev_warn(&skt->dev, "err %d adding socket attributes\n", ret);\r\ncomplete(&skt->thread_done);\r\nmsleep(250);\r\nset_freezable();\r\nfor (;;) {\r\nunsigned long flags;\r\nunsigned int events;\r\nunsigned int sysfs_events;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock_irqsave(&skt->thread_lock, flags);\r\nevents = skt->thread_events;\r\nskt->thread_events = 0;\r\nsysfs_events = skt->sysfs_events;\r\nskt->sysfs_events = 0;\r\nspin_unlock_irqrestore(&skt->thread_lock, flags);\r\nmutex_lock(&skt->skt_mutex);\r\nif (events & SS_DETECT)\r\nsocket_detect_change(skt);\r\nif (sysfs_events) {\r\nif (sysfs_events & PCMCIA_UEVENT_EJECT)\r\nsocket_remove(skt);\r\nif (sysfs_events & PCMCIA_UEVENT_INSERT)\r\nsocket_insert(skt);\r\nif ((sysfs_events & PCMCIA_UEVENT_SUSPEND) &&\r\n!(skt->state & SOCKET_CARDBUS)) {\r\nif (skt->callback)\r\nret = skt->callback->suspend(skt);\r\nelse\r\nret = 0;\r\nif (!ret) {\r\nsocket_suspend(skt);\r\nmsleep(100);\r\n}\r\n}\r\nif ((sysfs_events & PCMCIA_UEVENT_RESUME) &&\r\n!(skt->state & SOCKET_CARDBUS)) {\r\nret = socket_resume(skt);\r\nif (!ret && skt->callback)\r\nskt->callback->resume(skt);\r\n}\r\nif ((sysfs_events & PCMCIA_UEVENT_REQUERY) &&\r\n!(skt->state & SOCKET_CARDBUS)) {\r\nif (!ret && skt->callback)\r\nskt->callback->requery(skt);\r\n}\r\n}\r\nmutex_unlock(&skt->skt_mutex);\r\nif (events || sysfs_events)\r\ncontinue;\r\nif (kthread_should_stop())\r\nbreak;\r\nschedule();\r\ntry_to_freeze();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nif (skt->state & SOCKET_PRESENT) {\r\nmutex_lock(&skt->skt_mutex);\r\nsocket_remove(skt);\r\nmutex_unlock(&skt->skt_mutex);\r\n}\r\npccard_sysfs_remove_socket(&skt->dev);\r\ndevice_unregister(&skt->dev);\r\nreturn 0;\r\n}\r\nvoid pcmcia_parse_events(struct pcmcia_socket *s, u_int events)\r\n{\r\nunsigned long flags;\r\ndev_dbg(&s->dev, "parse_events: events %08x\n", events);\r\nif (s->thread) {\r\nspin_lock_irqsave(&s->thread_lock, flags);\r\ns->thread_events |= events;\r\nspin_unlock_irqrestore(&s->thread_lock, flags);\r\nwake_up_process(s->thread);\r\n}\r\n}\r\nvoid pcmcia_parse_uevents(struct pcmcia_socket *s, u_int events)\r\n{\r\nunsigned long flags;\r\ndev_dbg(&s->dev, "parse_uevents: events %08x\n", events);\r\nif (s->thread) {\r\nspin_lock_irqsave(&s->thread_lock, flags);\r\ns->sysfs_events |= events;\r\nspin_unlock_irqrestore(&s->thread_lock, flags);\r\nwake_up_process(s->thread);\r\n}\r\n}\r\nint pccard_register_pcmcia(struct pcmcia_socket *s, struct pcmcia_callback *c)\r\n{\r\nint ret = 0;\r\nmutex_lock(&s->skt_mutex);\r\nif (c) {\r\nif (s->callback) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\ns->callback = c;\r\nif ((s->state & (SOCKET_PRESENT|SOCKET_CARDBUS)) == SOCKET_PRESENT)\r\ns->callback->add(s);\r\n} else\r\ns->callback = NULL;\r\nerr:\r\nmutex_unlock(&s->skt_mutex);\r\nreturn ret;\r\n}\r\nint pcmcia_reset_card(struct pcmcia_socket *skt)\r\n{\r\nint ret;\r\ndev_dbg(&skt->dev, "resetting socket\n");\r\nmutex_lock(&skt->skt_mutex);\r\ndo {\r\nif (!(skt->state & SOCKET_PRESENT)) {\r\ndev_dbg(&skt->dev, "can't reset, not present\n");\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nif (skt->state & SOCKET_SUSPEND) {\r\ndev_dbg(&skt->dev, "can't reset, suspended\n");\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nif (skt->state & SOCKET_CARDBUS) {\r\ndev_dbg(&skt->dev, "can't reset, is cardbus\n");\r\nret = -EPERM;\r\nbreak;\r\n}\r\nif (skt->callback)\r\nskt->callback->suspend(skt);\r\nmutex_lock(&skt->ops_mutex);\r\nret = socket_reset(skt);\r\nmutex_unlock(&skt->ops_mutex);\r\nif ((ret == 0) && (skt->callback))\r\nskt->callback->resume(skt);\r\nret = 0;\r\n} while (0);\r\nmutex_unlock(&skt->skt_mutex);\r\nreturn ret;\r\n}\r\nstatic int pcmcia_socket_uevent(struct device *dev,\r\nstruct kobj_uevent_env *env)\r\n{\r\nstruct pcmcia_socket *s = container_of(dev, struct pcmcia_socket, dev);\r\nif (add_uevent_var(env, "SOCKET_NO=%u", s->sock))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void pcmcia_release_socket_class(struct class *data)\r\n{\r\ncomplete(&pcmcia_unload);\r\n}\r\nstatic int __pcmcia_pm_op(struct device *dev,\r\nint (*callback) (struct pcmcia_socket *skt))\r\n{\r\nstruct pcmcia_socket *s = container_of(dev, struct pcmcia_socket, dev);\r\nint ret;\r\nmutex_lock(&s->skt_mutex);\r\nret = callback(s);\r\nmutex_unlock(&s->skt_mutex);\r\nreturn ret;\r\n}\r\nstatic int pcmcia_socket_dev_suspend_noirq(struct device *dev)\r\n{\r\nreturn __pcmcia_pm_op(dev, socket_suspend);\r\n}\r\nstatic int pcmcia_socket_dev_resume_noirq(struct device *dev)\r\n{\r\nreturn __pcmcia_pm_op(dev, socket_early_resume);\r\n}\r\nstatic int __used pcmcia_socket_dev_resume(struct device *dev)\r\n{\r\nreturn __pcmcia_pm_op(dev, socket_late_resume);\r\n}\r\nstatic void __used pcmcia_socket_dev_complete(struct device *dev)\r\n{\r\nWARN(__pcmcia_pm_op(dev, socket_complete_resume),\r\n"failed to complete resume");\r\n}\r\nstatic int __init init_pcmcia_cs(void)\r\n{\r\ninit_completion(&pcmcia_unload);\r\nreturn class_register(&pcmcia_socket_class);\r\n}\r\nstatic void __exit exit_pcmcia_cs(void)\r\n{\r\nclass_unregister(&pcmcia_socket_class);\r\nwait_for_completion(&pcmcia_unload);\r\n}
