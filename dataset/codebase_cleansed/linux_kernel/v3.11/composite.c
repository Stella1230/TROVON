static struct usb_gadget_strings **get_containers_gs(\r\nstruct usb_gadget_string_container *uc)\r\n{\r\nreturn (struct usb_gadget_strings **)uc->stash;\r\n}\r\nstatic struct usb_descriptor_header**\r\nnext_ep_desc(struct usb_descriptor_header **t)\r\n{\r\nfor (; *t; t++) {\r\nif ((*t)->bDescriptorType == USB_DT_ENDPOINT)\r\nreturn t;\r\n}\r\nreturn NULL;\r\n}\r\nint config_ep_by_speed(struct usb_gadget *g,\r\nstruct usb_function *f,\r\nstruct usb_ep *_ep)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(g);\r\nstruct usb_endpoint_descriptor *chosen_desc = NULL;\r\nstruct usb_descriptor_header **speed_desc = NULL;\r\nstruct usb_ss_ep_comp_descriptor *comp_desc = NULL;\r\nint want_comp_desc = 0;\r\nstruct usb_descriptor_header **d_spd;\r\nif (!g || !f || !_ep)\r\nreturn -EIO;\r\nswitch (g->speed) {\r\ncase USB_SPEED_SUPER:\r\nif (gadget_is_superspeed(g)) {\r\nspeed_desc = f->ss_descriptors;\r\nwant_comp_desc = 1;\r\nbreak;\r\n}\r\ncase USB_SPEED_HIGH:\r\nif (gadget_is_dualspeed(g)) {\r\nspeed_desc = f->hs_descriptors;\r\nbreak;\r\n}\r\ndefault:\r\nspeed_desc = f->fs_descriptors;\r\n}\r\nfor_each_ep_desc(speed_desc, d_spd) {\r\nchosen_desc = (struct usb_endpoint_descriptor *)*d_spd;\r\nif (chosen_desc->bEndpointAddress == _ep->address)\r\ngoto ep_found;\r\n}\r\nreturn -EIO;\r\nep_found:\r\n_ep->maxpacket = usb_endpoint_maxp(chosen_desc);\r\n_ep->desc = chosen_desc;\r\n_ep->comp_desc = NULL;\r\n_ep->maxburst = 0;\r\n_ep->mult = 0;\r\nif (!want_comp_desc)\r\nreturn 0;\r\ncomp_desc = (struct usb_ss_ep_comp_descriptor *)*(++d_spd);\r\nif (!comp_desc ||\r\n(comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))\r\nreturn -EIO;\r\n_ep->comp_desc = comp_desc;\r\nif (g->speed == USB_SPEED_SUPER) {\r\nswitch (usb_endpoint_type(_ep->desc)) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\n_ep->mult = comp_desc->bmAttributes & 0x3;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncase USB_ENDPOINT_XFER_INT:\r\n_ep->maxburst = comp_desc->bMaxBurst + 1;\r\nbreak;\r\ndefault:\r\nif (comp_desc->bMaxBurst != 0)\r\nERROR(cdev, "ep0 bMaxBurst must be 0\n");\r\n_ep->maxburst = 1;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint usb_add_function(struct usb_configuration *config,\r\nstruct usb_function *function)\r\n{\r\nint value = -EINVAL;\r\nDBG(config->cdev, "adding '%s'/%p to config '%s'/%p\n",\r\nfunction->name, function,\r\nconfig->label, config);\r\nif (!function->set_alt || !function->disable)\r\ngoto done;\r\nfunction->config = config;\r\nlist_add_tail(&function->list, &config->functions);\r\nif (function->bind) {\r\nvalue = function->bind(config, function);\r\nif (value < 0) {\r\nlist_del(&function->list);\r\nfunction->config = NULL;\r\n}\r\n} else\r\nvalue = 0;\r\nif (!config->fullspeed && function->fs_descriptors)\r\nconfig->fullspeed = true;\r\nif (!config->highspeed && function->hs_descriptors)\r\nconfig->highspeed = true;\r\nif (!config->superspeed && function->ss_descriptors)\r\nconfig->superspeed = true;\r\ndone:\r\nif (value)\r\nDBG(config->cdev, "adding '%s'/%p --> %d\n",\r\nfunction->name, function, value);\r\nreturn value;\r\n}\r\nvoid usb_remove_function(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nif (f->disable)\r\nf->disable(f);\r\nbitmap_zero(f->endpoints, 32);\r\nlist_del(&f->list);\r\nif (f->unbind)\r\nf->unbind(c, f);\r\n}\r\nint usb_function_deactivate(struct usb_function *function)\r\n{\r\nstruct usb_composite_dev *cdev = function->config->cdev;\r\nunsigned long flags;\r\nint status = 0;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->deactivations == 0)\r\nstatus = usb_gadget_disconnect(cdev->gadget);\r\nif (status == 0)\r\ncdev->deactivations++;\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nreturn status;\r\n}\r\nint usb_function_activate(struct usb_function *function)\r\n{\r\nstruct usb_composite_dev *cdev = function->config->cdev;\r\nunsigned long flags;\r\nint status = 0;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (WARN_ON(cdev->deactivations == 0))\r\nstatus = -EINVAL;\r\nelse {\r\ncdev->deactivations--;\r\nif (cdev->deactivations == 0)\r\nstatus = usb_gadget_connect(cdev->gadget);\r\n}\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nreturn status;\r\n}\r\nint usb_interface_id(struct usb_configuration *config,\r\nstruct usb_function *function)\r\n{\r\nunsigned id = config->next_interface_id;\r\nif (id < MAX_CONFIG_INTERFACES) {\r\nconfig->interface[id] = function;\r\nconfig->next_interface_id = id + 1;\r\nreturn id;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic u8 encode_bMaxPower(enum usb_device_speed speed,\r\nstruct usb_configuration *c)\r\n{\r\nunsigned val;\r\nif (c->MaxPower)\r\nval = c->MaxPower;\r\nelse\r\nval = CONFIG_USB_GADGET_VBUS_DRAW;\r\nif (!val)\r\nreturn 0;\r\nswitch (speed) {\r\ncase USB_SPEED_SUPER:\r\nreturn DIV_ROUND_UP(val, 8);\r\ndefault:\r\nreturn DIV_ROUND_UP(val, 2);\r\n};\r\n}\r\nstatic int config_buf(struct usb_configuration *config,\r\nenum usb_device_speed speed, void *buf, u8 type)\r\n{\r\nstruct usb_config_descriptor *c = buf;\r\nvoid *next = buf + USB_DT_CONFIG_SIZE;\r\nint len;\r\nstruct usb_function *f;\r\nint status;\r\nlen = USB_COMP_EP0_BUFSIZ - USB_DT_CONFIG_SIZE;\r\nc = buf;\r\nc->bLength = USB_DT_CONFIG_SIZE;\r\nc->bDescriptorType = type;\r\nc->bNumInterfaces = config->next_interface_id;\r\nc->bConfigurationValue = config->bConfigurationValue;\r\nc->iConfiguration = config->iConfiguration;\r\nc->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;\r\nc->bMaxPower = encode_bMaxPower(speed, config);\r\nif (config->descriptors) {\r\nstatus = usb_descriptor_fillbuf(next, len,\r\nconfig->descriptors);\r\nif (status < 0)\r\nreturn status;\r\nlen -= status;\r\nnext += status;\r\n}\r\nlist_for_each_entry(f, &config->functions, list) {\r\nstruct usb_descriptor_header **descriptors;\r\nswitch (speed) {\r\ncase USB_SPEED_SUPER:\r\ndescriptors = f->ss_descriptors;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ndescriptors = f->hs_descriptors;\r\nbreak;\r\ndefault:\r\ndescriptors = f->fs_descriptors;\r\n}\r\nif (!descriptors)\r\ncontinue;\r\nstatus = usb_descriptor_fillbuf(next, len,\r\n(const struct usb_descriptor_header **) descriptors);\r\nif (status < 0)\r\nreturn status;\r\nlen -= status;\r\nnext += status;\r\n}\r\nlen = next - buf;\r\nc->wTotalLength = cpu_to_le16(len);\r\nreturn len;\r\n}\r\nstatic int config_desc(struct usb_composite_dev *cdev, unsigned w_value)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct usb_configuration *c;\r\nu8 type = w_value >> 8;\r\nenum usb_device_speed speed = USB_SPEED_UNKNOWN;\r\nif (gadget->speed == USB_SPEED_SUPER)\r\nspeed = gadget->speed;\r\nelse if (gadget_is_dualspeed(gadget)) {\r\nint hs = 0;\r\nif (gadget->speed == USB_SPEED_HIGH)\r\nhs = 1;\r\nif (type == USB_DT_OTHER_SPEED_CONFIG)\r\nhs = !hs;\r\nif (hs)\r\nspeed = USB_SPEED_HIGH;\r\n}\r\nw_value &= 0xff;\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nswitch (speed) {\r\ncase USB_SPEED_SUPER:\r\nif (!c->superspeed)\r\ncontinue;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nif (!c->highspeed)\r\ncontinue;\r\nbreak;\r\ndefault:\r\nif (!c->fullspeed)\r\ncontinue;\r\n}\r\nif (w_value == 0)\r\nreturn config_buf(c, speed, cdev->req->buf, type);\r\nw_value--;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int count_configs(struct usb_composite_dev *cdev, unsigned type)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct usb_configuration *c;\r\nunsigned count = 0;\r\nint hs = 0;\r\nint ss = 0;\r\nif (gadget_is_dualspeed(gadget)) {\r\nif (gadget->speed == USB_SPEED_HIGH)\r\nhs = 1;\r\nif (gadget->speed == USB_SPEED_SUPER)\r\nss = 1;\r\nif (type == USB_DT_DEVICE_QUALIFIER)\r\nhs = !hs;\r\n}\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (ss) {\r\nif (!c->superspeed)\r\ncontinue;\r\n} else if (hs) {\r\nif (!c->highspeed)\r\ncontinue;\r\n} else {\r\nif (!c->fullspeed)\r\ncontinue;\r\n}\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic int bos_desc(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_ext_cap_descriptor *usb_ext;\r\nstruct usb_ss_cap_descriptor *ss_cap;\r\nstruct usb_dcd_config_params dcd_config_params;\r\nstruct usb_bos_descriptor *bos = cdev->req->buf;\r\nbos->bLength = USB_DT_BOS_SIZE;\r\nbos->bDescriptorType = USB_DT_BOS;\r\nbos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);\r\nbos->bNumDeviceCaps = 0;\r\nusb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\r\nbos->bNumDeviceCaps++;\r\nle16_add_cpu(&bos->wTotalLength, USB_DT_USB_EXT_CAP_SIZE);\r\nusb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;\r\nusb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\r\nusb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;\r\nusb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);\r\nss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\r\nbos->bNumDeviceCaps++;\r\nle16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);\r\nss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;\r\nss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\r\nss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;\r\nss_cap->bmAttributes = 0;\r\nss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |\r\nUSB_FULL_SPEED_OPERATION |\r\nUSB_HIGH_SPEED_OPERATION |\r\nUSB_5GBPS_OPERATION);\r\nss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;\r\nif (cdev->gadget->ops->get_config_params)\r\ncdev->gadget->ops->get_config_params(&dcd_config_params);\r\nelse {\r\ndcd_config_params.bU1devExitLat = USB_DEFAULT_U1_DEV_EXIT_LAT;\r\ndcd_config_params.bU2DevExitLat =\r\ncpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);\r\n}\r\nss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;\r\nss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;\r\nreturn le16_to_cpu(bos->wTotalLength);\r\n}\r\nstatic void device_qual(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_qualifier_descriptor *qual = cdev->req->buf;\r\nqual->bLength = sizeof(*qual);\r\nqual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;\r\nqual->bcdUSB = cdev->desc.bcdUSB;\r\nqual->bDeviceClass = cdev->desc.bDeviceClass;\r\nqual->bDeviceSubClass = cdev->desc.bDeviceSubClass;\r\nqual->bDeviceProtocol = cdev->desc.bDeviceProtocol;\r\nqual->bMaxPacketSize0 = cdev->gadget->ep0->maxpacket;\r\nqual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);\r\nqual->bRESERVED = 0;\r\n}\r\nstatic void reset_config(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_function *f;\r\nDBG(cdev, "reset config\n");\r\nlist_for_each_entry(f, &cdev->config->functions, list) {\r\nif (f->disable)\r\nf->disable(f);\r\nbitmap_zero(f->endpoints, 32);\r\n}\r\ncdev->config = NULL;\r\n}\r\nstatic int set_config(struct usb_composite_dev *cdev,\r\nconst struct usb_ctrlrequest *ctrl, unsigned number)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct usb_configuration *c = NULL;\r\nint result = -EINVAL;\r\nunsigned power = gadget_is_otg(gadget) ? 8 : 100;\r\nint tmp;\r\nif (number) {\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (c->bConfigurationValue == number) {\r\nif (cdev->config)\r\nreset_config(cdev);\r\nresult = 0;\r\nbreak;\r\n}\r\n}\r\nif (result < 0)\r\ngoto done;\r\n} else {\r\nif (cdev->config)\r\nreset_config(cdev);\r\nresult = 0;\r\n}\r\nINFO(cdev, "%s config #%d: %s\n",\r\nusb_speed_string(gadget->speed),\r\nnumber, c ? c->label : "unconfigured");\r\nif (!c)\r\ngoto done;\r\ncdev->config = c;\r\nfor (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {\r\nstruct usb_function *f = c->interface[tmp];\r\nstruct usb_descriptor_header **descriptors;\r\nif (!f)\r\nbreak;\r\nswitch (gadget->speed) {\r\ncase USB_SPEED_SUPER:\r\ndescriptors = f->ss_descriptors;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ndescriptors = f->hs_descriptors;\r\nbreak;\r\ndefault:\r\ndescriptors = f->fs_descriptors;\r\n}\r\nfor (; *descriptors; ++descriptors) {\r\nstruct usb_endpoint_descriptor *ep;\r\nint addr;\r\nif ((*descriptors)->bDescriptorType != USB_DT_ENDPOINT)\r\ncontinue;\r\nep = (struct usb_endpoint_descriptor *)*descriptors;\r\naddr = ((ep->bEndpointAddress & 0x80) >> 3)\r\n| (ep->bEndpointAddress & 0x0f);\r\nset_bit(addr, f->endpoints);\r\n}\r\nresult = f->set_alt(f, tmp, 0);\r\nif (result < 0) {\r\nDBG(cdev, "interface %d (%s/%p) alt 0 --> %d\n",\r\ntmp, f->name, f, result);\r\nreset_config(cdev);\r\ngoto done;\r\n}\r\nif (result == USB_GADGET_DELAYED_STATUS) {\r\nDBG(cdev,\r\n"%s: interface %d (%s) requested delayed status\n",\r\n__func__, tmp, f->name);\r\ncdev->delayed_status++;\r\nDBG(cdev, "delayed_status count %d\n",\r\ncdev->delayed_status);\r\n}\r\n}\r\npower = c->MaxPower ? c->MaxPower : CONFIG_USB_GADGET_VBUS_DRAW;\r\ndone:\r\nusb_gadget_vbus_draw(gadget, power);\r\nif (result >= 0 && cdev->delayed_status)\r\nresult = USB_GADGET_DELAYED_STATUS;\r\nreturn result;\r\n}\r\nint usb_add_config_only(struct usb_composite_dev *cdev,\r\nstruct usb_configuration *config)\r\n{\r\nstruct usb_configuration *c;\r\nif (!config->bConfigurationValue)\r\nreturn -EINVAL;\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (c->bConfigurationValue == config->bConfigurationValue)\r\nreturn -EBUSY;\r\n}\r\nconfig->cdev = cdev;\r\nlist_add_tail(&config->list, &cdev->configs);\r\nINIT_LIST_HEAD(&config->functions);\r\nconfig->next_interface_id = 0;\r\nmemset(config->interface, 0, sizeof(config->interface));\r\nreturn 0;\r\n}\r\nint usb_add_config(struct usb_composite_dev *cdev,\r\nstruct usb_configuration *config,\r\nint (*bind)(struct usb_configuration *))\r\n{\r\nint status = -EINVAL;\r\nif (!bind)\r\ngoto done;\r\nDBG(cdev, "adding config #%u '%s'/%p\n",\r\nconfig->bConfigurationValue,\r\nconfig->label, config);\r\nstatus = usb_add_config_only(cdev, config);\r\nif (status)\r\ngoto done;\r\nstatus = bind(config);\r\nif (status < 0) {\r\nwhile (!list_empty(&config->functions)) {\r\nstruct usb_function *f;\r\nf = list_first_entry(&config->functions,\r\nstruct usb_function, list);\r\nlist_del(&f->list);\r\nif (f->unbind) {\r\nDBG(cdev, "unbind function '%s'/%p\n",\r\nf->name, f);\r\nf->unbind(config, f);\r\n}\r\n}\r\nlist_del(&config->list);\r\nconfig->cdev = NULL;\r\n} else {\r\nunsigned i;\r\nDBG(cdev, "cfg %d/%p speeds:%s%s%s\n",\r\nconfig->bConfigurationValue, config,\r\nconfig->superspeed ? " super" : "",\r\nconfig->highspeed ? " high" : "",\r\nconfig->fullspeed\r\n? (gadget_is_dualspeed(cdev->gadget)\r\n? " full"\r\n: " full/low")\r\n: "");\r\nfor (i = 0; i < MAX_CONFIG_INTERFACES; i++) {\r\nstruct usb_function *f = config->interface[i];\r\nif (!f)\r\ncontinue;\r\nDBG(cdev, " interface %d = %s/%p\n",\r\ni, f->name, f);\r\n}\r\n}\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\ndone:\r\nif (status)\r\nDBG(cdev, "added config '%s'/%u --> %d\n", config->label,\r\nconfig->bConfigurationValue, status);\r\nreturn status;\r\n}\r\nstatic void remove_config(struct usb_composite_dev *cdev,\r\nstruct usb_configuration *config)\r\n{\r\nwhile (!list_empty(&config->functions)) {\r\nstruct usb_function *f;\r\nf = list_first_entry(&config->functions,\r\nstruct usb_function, list);\r\nlist_del(&f->list);\r\nif (f->unbind) {\r\nDBG(cdev, "unbind function '%s'/%p\n", f->name, f);\r\nf->unbind(config, f);\r\n}\r\n}\r\nlist_del(&config->list);\r\nif (config->unbind) {\r\nDBG(cdev, "unbind config '%s'/%p\n", config->label, config);\r\nconfig->unbind(config);\r\n}\r\n}\r\nvoid usb_remove_config(struct usb_composite_dev *cdev,\r\nstruct usb_configuration *config)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->config == config)\r\nreset_config(cdev);\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nremove_config(cdev, config);\r\n}\r\nstatic void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)\r\n{\r\nconst struct usb_gadget_strings *s;\r\n__le16 language;\r\n__le16 *tmp;\r\nwhile (*sp) {\r\ns = *sp;\r\nlanguage = cpu_to_le16(s->language);\r\nfor (tmp = buf; *tmp && tmp < &buf[126]; tmp++) {\r\nif (*tmp == language)\r\ngoto repeat;\r\n}\r\n*tmp++ = language;\r\nrepeat:\r\nsp++;\r\n}\r\n}\r\nstatic int lookup_string(\r\nstruct usb_gadget_strings **sp,\r\nvoid *buf,\r\nu16 language,\r\nint id\r\n)\r\n{\r\nstruct usb_gadget_strings *s;\r\nint value;\r\nwhile (*sp) {\r\ns = *sp++;\r\nif (s->language != language)\r\ncontinue;\r\nvalue = usb_gadget_get_string(s, id, buf);\r\nif (value > 0)\r\nreturn value;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int get_string(struct usb_composite_dev *cdev,\r\nvoid *buf, u16 language, int id)\r\n{\r\nstruct usb_composite_driver *composite = cdev->driver;\r\nstruct usb_gadget_string_container *uc;\r\nstruct usb_configuration *c;\r\nstruct usb_function *f;\r\nint len;\r\nif (id == 0) {\r\nstruct usb_string_descriptor *s = buf;\r\nstruct usb_gadget_strings **sp;\r\nmemset(s, 0, 256);\r\ns->bDescriptorType = USB_DT_STRING;\r\nsp = composite->strings;\r\nif (sp)\r\ncollect_langs(sp, s->wData);\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nsp = c->strings;\r\nif (sp)\r\ncollect_langs(sp, s->wData);\r\nlist_for_each_entry(f, &c->functions, list) {\r\nsp = f->strings;\r\nif (sp)\r\ncollect_langs(sp, s->wData);\r\n}\r\n}\r\nlist_for_each_entry(uc, &cdev->gstrings, list) {\r\nstruct usb_gadget_strings **sp;\r\nsp = get_containers_gs(uc);\r\ncollect_langs(sp, s->wData);\r\n}\r\nfor (len = 0; len <= 126 && s->wData[len]; len++)\r\ncontinue;\r\nif (!len)\r\nreturn -EINVAL;\r\ns->bLength = 2 * (len + 1);\r\nreturn s->bLength;\r\n}\r\nlist_for_each_entry(uc, &cdev->gstrings, list) {\r\nstruct usb_gadget_strings **sp;\r\nsp = get_containers_gs(uc);\r\nlen = lookup_string(sp, buf, language, id);\r\nif (len > 0)\r\nreturn len;\r\n}\r\nif (composite->strings) {\r\nlen = lookup_string(composite->strings, buf, language, id);\r\nif (len > 0)\r\nreturn len;\r\n}\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (c->strings) {\r\nlen = lookup_string(c->strings, buf, language, id);\r\nif (len > 0)\r\nreturn len;\r\n}\r\nlist_for_each_entry(f, &c->functions, list) {\r\nif (!f->strings)\r\ncontinue;\r\nlen = lookup_string(f->strings, buf, language, id);\r\nif (len > 0)\r\nreturn len;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint usb_string_id(struct usb_composite_dev *cdev)\r\n{\r\nif (cdev->next_string_id < 254) {\r\ncdev->next_string_id++;\r\nreturn cdev->next_string_id;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)\r\n{\r\nint next = cdev->next_string_id;\r\nfor (; str->s; ++str) {\r\nif (unlikely(next >= 254))\r\nreturn -ENODEV;\r\nstr->id = ++next;\r\n}\r\ncdev->next_string_id = next;\r\nreturn 0;\r\n}\r\nstatic struct usb_gadget_string_container *copy_gadget_strings(\r\nstruct usb_gadget_strings **sp, unsigned n_gstrings,\r\nunsigned n_strings)\r\n{\r\nstruct usb_gadget_string_container *uc;\r\nstruct usb_gadget_strings **gs_array;\r\nstruct usb_gadget_strings *gs;\r\nstruct usb_string *s;\r\nunsigned mem;\r\nunsigned n_gs;\r\nunsigned n_s;\r\nvoid *stash;\r\nmem = sizeof(*uc);\r\nmem += sizeof(void *) * (n_gstrings + 1);\r\nmem += sizeof(struct usb_gadget_strings) * n_gstrings;\r\nmem += sizeof(struct usb_string) * (n_strings + 1) * (n_gstrings);\r\nuc = kmalloc(mem, GFP_KERNEL);\r\nif (!uc)\r\nreturn ERR_PTR(-ENOMEM);\r\ngs_array = get_containers_gs(uc);\r\nstash = uc->stash;\r\nstash += sizeof(void *) * (n_gstrings + 1);\r\nfor (n_gs = 0; n_gs < n_gstrings; n_gs++) {\r\nstruct usb_string *org_s;\r\ngs_array[n_gs] = stash;\r\ngs = gs_array[n_gs];\r\nstash += sizeof(struct usb_gadget_strings);\r\ngs->language = sp[n_gs]->language;\r\ngs->strings = stash;\r\norg_s = sp[n_gs]->strings;\r\nfor (n_s = 0; n_s < n_strings; n_s++) {\r\ns = stash;\r\nstash += sizeof(struct usb_string);\r\nif (org_s->s)\r\ns->s = org_s->s;\r\nelse\r\ns->s = "";\r\norg_s++;\r\n}\r\ns = stash;\r\ns->s = NULL;\r\nstash += sizeof(struct usb_string);\r\n}\r\ngs_array[n_gs] = NULL;\r\nreturn uc;\r\n}\r\nstruct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,\r\nstruct usb_gadget_strings **sp, unsigned n_strings)\r\n{\r\nstruct usb_gadget_string_container *uc;\r\nstruct usb_gadget_strings **n_gs;\r\nunsigned n_gstrings = 0;\r\nunsigned i;\r\nint ret;\r\nfor (i = 0; sp[i]; i++)\r\nn_gstrings++;\r\nif (!n_gstrings)\r\nreturn ERR_PTR(-EINVAL);\r\nuc = copy_gadget_strings(sp, n_gstrings, n_strings);\r\nif (IS_ERR(uc))\r\nreturn ERR_PTR(PTR_ERR(uc));\r\nn_gs = get_containers_gs(uc);\r\nret = usb_string_ids_tab(cdev, n_gs[0]->strings);\r\nif (ret)\r\ngoto err;\r\nfor (i = 1; i < n_gstrings; i++) {\r\nstruct usb_string *m_s;\r\nstruct usb_string *s;\r\nunsigned n;\r\nm_s = n_gs[0]->strings;\r\ns = n_gs[i]->strings;\r\nfor (n = 0; n < n_strings; n++) {\r\ns->id = m_s->id;\r\ns++;\r\nm_s++;\r\n}\r\n}\r\nlist_add_tail(&uc->list, &cdev->gstrings);\r\nreturn n_gs[0]->strings;\r\nerr:\r\nkfree(uc);\r\nreturn ERR_PTR(ret);\r\n}\r\nint usb_string_ids_n(struct usb_composite_dev *c, unsigned n)\r\n{\r\nunsigned next = c->next_string_id;\r\nif (unlikely(n > 254 || (unsigned)next + n > 254))\r\nreturn -ENODEV;\r\nc->next_string_id += n;\r\nreturn next + 1;\r\n}\r\nstatic void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nif (req->status || req->actual != req->length)\r\nDBG((struct usb_composite_dev *) ep->driver_data,\r\n"setup complete --> %d, %d/%d\n",\r\nreq->status, req->actual, req->length);\r\n}\r\nint\r\ncomposite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nint status = 0;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu8 intf = w_index & 0xFF;\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nstruct usb_function *f = NULL;\r\nu8 endp;\r\nreq->zero = 0;\r\nreq->complete = composite_setup_complete;\r\nreq->length = 0;\r\ngadget->ep0->driver_data = cdev;\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_GET_DESCRIPTOR:\r\nif (ctrl->bRequestType != USB_DIR_IN)\r\ngoto unknown;\r\nswitch (w_value >> 8) {\r\ncase USB_DT_DEVICE:\r\ncdev->desc.bNumConfigurations =\r\ncount_configs(cdev, USB_DT_DEVICE);\r\ncdev->desc.bMaxPacketSize0 =\r\ncdev->gadget->ep0->maxpacket;\r\nif (gadget_is_superspeed(gadget)) {\r\nif (gadget->speed >= USB_SPEED_SUPER) {\r\ncdev->desc.bcdUSB = cpu_to_le16(0x0300);\r\ncdev->desc.bMaxPacketSize0 = 9;\r\n} else {\r\ncdev->desc.bcdUSB = cpu_to_le16(0x0210);\r\n}\r\n}\r\nvalue = min(w_length, (u16) sizeof cdev->desc);\r\nmemcpy(req->buf, &cdev->desc, value);\r\nbreak;\r\ncase USB_DT_DEVICE_QUALIFIER:\r\nif (!gadget_is_dualspeed(gadget) ||\r\ngadget->speed >= USB_SPEED_SUPER)\r\nbreak;\r\ndevice_qual(cdev);\r\nvalue = min_t(int, w_length,\r\nsizeof(struct usb_qualifier_descriptor));\r\nbreak;\r\ncase USB_DT_OTHER_SPEED_CONFIG:\r\nif (!gadget_is_dualspeed(gadget) ||\r\ngadget->speed >= USB_SPEED_SUPER)\r\nbreak;\r\ncase USB_DT_CONFIG:\r\nvalue = config_desc(cdev, w_value);\r\nif (value >= 0)\r\nvalue = min(w_length, (u16) value);\r\nbreak;\r\ncase USB_DT_STRING:\r\nvalue = get_string(cdev, req->buf,\r\nw_index, w_value & 0xff);\r\nif (value >= 0)\r\nvalue = min(w_length, (u16) value);\r\nbreak;\r\ncase USB_DT_BOS:\r\nif (gadget_is_superspeed(gadget)) {\r\nvalue = bos_desc(cdev);\r\nvalue = min(w_length, (u16) value);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\nif (ctrl->bRequestType != 0)\r\ngoto unknown;\r\nif (gadget_is_otg(gadget)) {\r\nif (gadget->a_hnp_support)\r\nDBG(cdev, "HNP available\n");\r\nelse if (gadget->a_alt_hnp_support)\r\nDBG(cdev, "HNP on another port\n");\r\nelse\r\nVDBG(cdev, "HNP inactive\n");\r\n}\r\nspin_lock(&cdev->lock);\r\nvalue = set_config(cdev, ctrl, w_value);\r\nspin_unlock(&cdev->lock);\r\nbreak;\r\ncase USB_REQ_GET_CONFIGURATION:\r\nif (ctrl->bRequestType != USB_DIR_IN)\r\ngoto unknown;\r\nif (cdev->config)\r\n*(u8 *)req->buf = cdev->config->bConfigurationValue;\r\nelse\r\n*(u8 *)req->buf = 0;\r\nvalue = min(w_length, (u16) 1);\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\nif (ctrl->bRequestType != USB_RECIP_INTERFACE)\r\ngoto unknown;\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nif (!f)\r\nbreak;\r\nif (w_value && !f->set_alt)\r\nbreak;\r\nvalue = f->set_alt(f, w_index, w_value);\r\nif (value == USB_GADGET_DELAYED_STATUS) {\r\nDBG(cdev,\r\n"%s: interface %d (%s) requested delayed status\n",\r\n__func__, intf, f->name);\r\ncdev->delayed_status++;\r\nDBG(cdev, "delayed_status count %d\n",\r\ncdev->delayed_status);\r\n}\r\nbreak;\r\ncase USB_REQ_GET_INTERFACE:\r\nif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\r\ngoto unknown;\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nif (!f)\r\nbreak;\r\nvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\r\nif (value < 0)\r\nbreak;\r\n*((u8 *)req->buf) = value;\r\nvalue = min(w_length, (u16) 1);\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nif (!gadget_is_superspeed(gadget))\r\ngoto unknown;\r\nif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\r\ngoto unknown;\r\nvalue = 2;\r\nput_unaligned_le16(0, req->buf);\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nif (!f)\r\nbreak;\r\nstatus = f->get_status ? f->get_status(f) : 0;\r\nif (status < 0)\r\nbreak;\r\nput_unaligned_le16(status & 0x0000ffff, req->buf);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\nif (!gadget_is_superspeed(gadget))\r\ngoto unknown;\r\nif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\r\ngoto unknown;\r\nswitch (w_value) {\r\ncase USB_INTRF_FUNC_SUSPEND:\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nif (!f)\r\nbreak;\r\nvalue = 0;\r\nif (f->func_suspend)\r\nvalue = f->func_suspend(f, w_index >> 8);\r\nif (value < 0) {\r\nERROR(cdev,\r\n"func_suspend() returned error %d\n",\r\nvalue);\r\nvalue = 0;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nunknown:\r\nVDBG(cdev,\r\n"non-core control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_INTERFACE:\r\nif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\r\nbreak;\r\nf = cdev->config->interface[intf];\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\r\nlist_for_each_entry(f, &cdev->config->functions, list) {\r\nif (test_bit(endp, f->endpoints))\r\nbreak;\r\n}\r\nif (&f->list == &cdev->config->functions)\r\nf = NULL;\r\nbreak;\r\n}\r\nif (f && f->setup)\r\nvalue = f->setup(f, ctrl);\r\nelse {\r\nstruct usb_configuration *c;\r\nc = cdev->config;\r\nif (c && c->setup)\r\nvalue = c->setup(c, ctrl);\r\n}\r\ngoto done;\r\n}\r\nif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\r\nreq->length = value;\r\nreq->zero = value < w_length;\r\nvalue = usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0) {\r\nDBG(cdev, "ep_queue --> %d\n", value);\r\nreq->status = 0;\r\ncomposite_setup_complete(gadget->ep0, req);\r\n}\r\n} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\r\nWARN(cdev,\r\n"%s: Delayed status not supported for w_length != 0",\r\n__func__);\r\n}\r\ndone:\r\nreturn value;\r\n}\r\nvoid composite_disconnect(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->config)\r\nreset_config(cdev);\r\nif (cdev->driver->disconnect)\r\ncdev->driver->disconnect(cdev);\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\n}\r\nstatic ssize_t composite_show_suspended(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_gadget *gadget = dev_to_usb_gadget(dev);\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nreturn sprintf(buf, "%d\n", cdev->suspended);\r\n}\r\nstatic void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nWARN_ON(cdev->config);\r\nwhile (!list_empty(&cdev->configs)) {\r\nstruct usb_configuration *c;\r\nc = list_first_entry(&cdev->configs,\r\nstruct usb_configuration, list);\r\nremove_config(cdev, c);\r\n}\r\nif (cdev->driver->unbind && unbind_driver)\r\ncdev->driver->unbind(cdev);\r\ncomposite_dev_cleanup(cdev);\r\nkfree(cdev->def_manufacturer);\r\nkfree(cdev);\r\nset_gadget_data(gadget, NULL);\r\n}\r\nstatic void composite_unbind(struct usb_gadget *gadget)\r\n{\r\n__composite_unbind(gadget, true);\r\n}\r\nstatic void update_unchanged_dev_desc(struct usb_device_descriptor *new,\r\nconst struct usb_device_descriptor *old)\r\n{\r\n__le16 idVendor;\r\n__le16 idProduct;\r\n__le16 bcdDevice;\r\nu8 iSerialNumber;\r\nu8 iManufacturer;\r\nu8 iProduct;\r\nidVendor = new->idVendor;\r\nidProduct = new->idProduct;\r\nbcdDevice = new->bcdDevice;\r\niSerialNumber = new->iSerialNumber;\r\niManufacturer = new->iManufacturer;\r\niProduct = new->iProduct;\r\n*new = *old;\r\nif (idVendor)\r\nnew->idVendor = idVendor;\r\nif (idProduct)\r\nnew->idProduct = idProduct;\r\nif (bcdDevice)\r\nnew->bcdDevice = bcdDevice;\r\nelse\r\nnew->bcdDevice = cpu_to_le16(get_default_bcdDevice());\r\nif (iSerialNumber)\r\nnew->iSerialNumber = iSerialNumber;\r\nif (iManufacturer)\r\nnew->iManufacturer = iManufacturer;\r\nif (iProduct)\r\nnew->iProduct = iProduct;\r\n}\r\nint composite_dev_prepare(struct usb_composite_driver *composite,\r\nstruct usb_composite_dev *cdev)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nint ret = -ENOMEM;\r\ncdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);\r\nif (!cdev->req)\r\nreturn -ENOMEM;\r\ncdev->req->buf = kmalloc(USB_COMP_EP0_BUFSIZ, GFP_KERNEL);\r\nif (!cdev->req->buf)\r\ngoto fail;\r\nret = device_create_file(&gadget->dev, &dev_attr_suspended);\r\nif (ret)\r\ngoto fail_dev;\r\ncdev->req->complete = composite_setup_complete;\r\ngadget->ep0->driver_data = cdev;\r\ncdev->driver = composite;\r\nif (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW)\r\nusb_gadget_set_selfpowered(gadget);\r\nusb_ep_autoconfig_reset(gadget);\r\nreturn 0;\r\nfail_dev:\r\nkfree(cdev->req->buf);\r\nfail:\r\nusb_ep_free_request(gadget->ep0, cdev->req);\r\ncdev->req = NULL;\r\nreturn ret;\r\n}\r\nvoid composite_dev_cleanup(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_gadget_string_container *uc, *tmp;\r\nlist_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {\r\nlist_del(&uc->list);\r\nkfree(uc);\r\n}\r\nif (cdev->req) {\r\nkfree(cdev->req->buf);\r\nusb_ep_free_request(cdev->gadget->ep0, cdev->req);\r\n}\r\ncdev->next_string_id = 0;\r\ndevice_remove_file(&cdev->gadget->dev, &dev_attr_suspended);\r\n}\r\nstatic int composite_bind(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *gdriver)\r\n{\r\nstruct usb_composite_dev *cdev;\r\nstruct usb_composite_driver *composite = to_cdriver(gdriver);\r\nint status = -ENOMEM;\r\ncdev = kzalloc(sizeof *cdev, GFP_KERNEL);\r\nif (!cdev)\r\nreturn status;\r\nspin_lock_init(&cdev->lock);\r\ncdev->gadget = gadget;\r\nset_gadget_data(gadget, cdev);\r\nINIT_LIST_HEAD(&cdev->configs);\r\nINIT_LIST_HEAD(&cdev->gstrings);\r\nstatus = composite_dev_prepare(composite, cdev);\r\nif (status)\r\ngoto fail;\r\nstatus = composite->bind(cdev);\r\nif (status < 0)\r\ngoto fail;\r\nupdate_unchanged_dev_desc(&cdev->desc, composite->dev);\r\nif (composite->needs_serial && !cdev->desc.iSerialNumber)\r\nWARNING(cdev, "userspace failed to provide iSerialNumber\n");\r\nINFO(cdev, "%s ready\n", composite->name);\r\nreturn 0;\r\nfail:\r\n__composite_unbind(gadget, false);\r\nreturn status;\r\n}\r\nstatic void\r\ncomposite_suspend(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nstruct usb_function *f;\r\nDBG(cdev, "suspend\n");\r\nif (cdev->config) {\r\nlist_for_each_entry(f, &cdev->config->functions, list) {\r\nif (f->suspend)\r\nf->suspend(f);\r\n}\r\n}\r\nif (cdev->driver->suspend)\r\ncdev->driver->suspend(cdev);\r\ncdev->suspended = 1;\r\nusb_gadget_vbus_draw(gadget, 2);\r\n}\r\nstatic void\r\ncomposite_resume(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nstruct usb_function *f;\r\nu8 maxpower;\r\nDBG(cdev, "resume\n");\r\nif (cdev->driver->resume)\r\ncdev->driver->resume(cdev);\r\nif (cdev->config) {\r\nlist_for_each_entry(f, &cdev->config->functions, list) {\r\nif (f->resume)\r\nf->resume(f);\r\n}\r\nmaxpower = cdev->config->MaxPower;\r\nusb_gadget_vbus_draw(gadget, maxpower ?\r\nmaxpower : CONFIG_USB_GADGET_VBUS_DRAW);\r\n}\r\ncdev->suspended = 0;\r\n}\r\nint usb_composite_probe(struct usb_composite_driver *driver)\r\n{\r\nstruct usb_gadget_driver *gadget_driver;\r\nif (!driver || !driver->dev || !driver->bind)\r\nreturn -EINVAL;\r\nif (!driver->name)\r\ndriver->name = "composite";\r\ndriver->gadget_driver = composite_driver_template;\r\ngadget_driver = &driver->gadget_driver;\r\ngadget_driver->function = (char *) driver->name;\r\ngadget_driver->driver.name = driver->name;\r\ngadget_driver->max_speed = driver->max_speed;\r\nreturn usb_gadget_probe_driver(gadget_driver);\r\n}\r\nvoid usb_composite_unregister(struct usb_composite_driver *driver)\r\n{\r\nusb_gadget_unregister_driver(&driver->gadget_driver);\r\n}\r\nvoid usb_composite_setup_continue(struct usb_composite_dev *cdev)\r\n{\r\nint value;\r\nstruct usb_request *req = cdev->req;\r\nunsigned long flags;\r\nDBG(cdev, "%s\n", __func__);\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->delayed_status == 0) {\r\nWARN(cdev, "%s: Unexpected call\n", __func__);\r\n} else if (--cdev->delayed_status == 0) {\r\nDBG(cdev, "%s: Completing delayed status\n", __func__);\r\nreq->length = 0;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0) {\r\nDBG(cdev, "ep_queue --> %d\n", value);\r\nreq->status = 0;\r\ncomposite_setup_complete(cdev->gadget->ep0, req);\r\n}\r\n}\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\n}\r\nstatic char *composite_default_mfr(struct usb_gadget *gadget)\r\n{\r\nchar *mfr;\r\nint len;\r\nlen = snprintf(NULL, 0, "%s %s with %s", init_utsname()->sysname,\r\ninit_utsname()->release, gadget->name);\r\nlen++;\r\nmfr = kmalloc(len, GFP_KERNEL);\r\nif (!mfr)\r\nreturn NULL;\r\nsnprintf(mfr, len, "%s %s with %s", init_utsname()->sysname,\r\ninit_utsname()->release, gadget->name);\r\nreturn mfr;\r\n}\r\nvoid usb_composite_overwrite_options(struct usb_composite_dev *cdev,\r\nstruct usb_composite_overwrite *covr)\r\n{\r\nstruct usb_device_descriptor *desc = &cdev->desc;\r\nstruct usb_gadget_strings *gstr = cdev->driver->strings[0];\r\nstruct usb_string *dev_str = gstr->strings;\r\nif (covr->idVendor)\r\ndesc->idVendor = cpu_to_le16(covr->idVendor);\r\nif (covr->idProduct)\r\ndesc->idProduct = cpu_to_le16(covr->idProduct);\r\nif (covr->bcdDevice)\r\ndesc->bcdDevice = cpu_to_le16(covr->bcdDevice);\r\nif (covr->serial_number) {\r\ndesc->iSerialNumber = dev_str[USB_GADGET_SERIAL_IDX].id;\r\ndev_str[USB_GADGET_SERIAL_IDX].s = covr->serial_number;\r\n}\r\nif (covr->manufacturer) {\r\ndesc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;\r\ndev_str[USB_GADGET_MANUFACTURER_IDX].s = covr->manufacturer;\r\n} else if (!strlen(dev_str[USB_GADGET_MANUFACTURER_IDX].s)) {\r\ndesc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;\r\ncdev->def_manufacturer = composite_default_mfr(cdev->gadget);\r\ndev_str[USB_GADGET_MANUFACTURER_IDX].s = cdev->def_manufacturer;\r\n}\r\nif (covr->product) {\r\ndesc->iProduct = dev_str[USB_GADGET_PRODUCT_IDX].id;\r\ndev_str[USB_GADGET_PRODUCT_IDX].s = covr->product;\r\n}\r\n}
