void machine_shutdown(void)\r\n{\r\n#ifdef CONFIG_FA_DUMP\r\nfadump_cleanup();\r\n#endif\r\nif (ppc_md.machine_shutdown)\r\nppc_md.machine_shutdown();\r\n}\r\nvoid machine_restart(char *cmd)\r\n{\r\nmachine_shutdown();\r\nif (ppc_md.restart)\r\nppc_md.restart(cmd);\r\n#ifdef CONFIG_SMP\r\nsmp_send_stop();\r\n#endif\r\nprintk(KERN_EMERG "System Halted, OK to turn off power\n");\r\nlocal_irq_disable();\r\nwhile (1) ;\r\n}\r\nvoid machine_power_off(void)\r\n{\r\nmachine_shutdown();\r\nif (ppc_md.power_off)\r\nppc_md.power_off();\r\n#ifdef CONFIG_SMP\r\nsmp_send_stop();\r\n#endif\r\nprintk(KERN_EMERG "System Halted, OK to turn off power\n");\r\nlocal_irq_disable();\r\nwhile (1) ;\r\n}\r\nvoid machine_halt(void)\r\n{\r\nmachine_shutdown();\r\nif (ppc_md.halt)\r\nppc_md.halt();\r\n#ifdef CONFIG_SMP\r\nsmp_send_stop();\r\n#endif\r\nprintk(KERN_EMERG "System Halted, OK to turn off power\n");\r\nlocal_irq_disable();\r\nwhile (1) ;\r\n}\r\nstatic void show_cpuinfo_summary(struct seq_file *m)\r\n{\r\nstruct device_node *root;\r\nconst char *model = NULL;\r\n#if defined(CONFIG_SMP) && defined(CONFIG_PPC32)\r\nunsigned long bogosum = 0;\r\nint i;\r\nfor_each_online_cpu(i)\r\nbogosum += loops_per_jiffy;\r\nseq_printf(m, "total bogomips\t: %lu.%02lu\n",\r\nbogosum/(500000/HZ), bogosum/(5000/HZ) % 100);\r\n#endif\r\nseq_printf(m, "timebase\t: %lu\n", ppc_tb_freq);\r\nif (ppc_md.name)\r\nseq_printf(m, "platform\t: %s\n", ppc_md.name);\r\nroot = of_find_node_by_path("/");\r\nif (root)\r\nmodel = of_get_property(root, "model", NULL);\r\nif (model)\r\nseq_printf(m, "model\t\t: %s\n", model);\r\nof_node_put(root);\r\nif (ppc_md.show_cpuinfo != NULL)\r\nppc_md.show_cpuinfo(m);\r\n#ifdef CONFIG_PPC32\r\nseq_printf(m, "Memory\t\t: %d MB\n",\r\n(unsigned int)(total_memory / (1024 * 1024)));\r\n#endif\r\n}\r\nstatic int show_cpuinfo(struct seq_file *m, void *v)\r\n{\r\nunsigned long cpu_id = (unsigned long)v - 1;\r\nunsigned int pvr;\r\nunsigned short maj;\r\nunsigned short min;\r\npreempt_disable();\r\nif (!cpu_online(cpu_id)) {\r\npreempt_enable();\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_SMP\r\npvr = per_cpu(cpu_pvr, cpu_id);\r\n#else\r\npvr = mfspr(SPRN_PVR);\r\n#endif\r\nmaj = (pvr >> 8) & 0xFF;\r\nmin = pvr & 0xFF;\r\nseq_printf(m, "processor\t: %lu\n", cpu_id);\r\nseq_printf(m, "cpu\t\t: ");\r\nif (cur_cpu_spec->pvr_mask)\r\nseq_printf(m, "%s", cur_cpu_spec->cpu_name);\r\nelse\r\nseq_printf(m, "unknown (%08x)", pvr);\r\n#ifdef CONFIG_ALTIVEC\r\nif (cpu_has_feature(CPU_FTR_ALTIVEC))\r\nseq_printf(m, ", altivec supported");\r\n#endif\r\nseq_printf(m, "\n");\r\n#ifdef CONFIG_TAU\r\nif (cur_cpu_spec->cpu_features & CPU_FTR_TAU) {\r\n#ifdef CONFIG_TAU_AVERAGE\r\nseq_printf(m, "temperature \t: %u C (uncalibrated)\n",\r\ncpu_temp(cpu_id));\r\n#else\r\nu32 temp;\r\ntemp = cpu_temp_both(cpu_id);\r\nseq_printf(m, "temperature \t: %u-%u C (uncalibrated)\n",\r\ntemp & 0xff, temp >> 16);\r\n#endif\r\n}\r\n#endif\r\nif (ppc_proc_freq)\r\nseq_printf(m, "clock\t\t: %lu.%06luMHz\n",\r\nppc_proc_freq / 1000000, ppc_proc_freq % 1000000);\r\nif (ppc_md.show_percpuinfo != NULL)\r\nppc_md.show_percpuinfo(m, cpu_id);\r\nif (PVR_VER(pvr) & 0x8000) {\r\nswitch (PVR_VER(pvr)) {\r\ncase 0x8000:\r\ncase 0x8001:\r\ncase 0x8002:\r\ncase 0x8003:\r\ncase 0x8004:\r\ncase 0x800c:\r\nmaj = ((pvr >> 8) & 0xF);\r\nmin = PVR_MIN(pvr);\r\nbreak;\r\ndefault:\r\nmaj = PVR_MAJ(pvr);\r\nmin = PVR_MIN(pvr);\r\nbreak;\r\n}\r\n} else {\r\nswitch (PVR_VER(pvr)) {\r\ncase 0x0020:\r\nmaj = PVR_MAJ(pvr) + 1;\r\nmin = PVR_MIN(pvr);\r\nbreak;\r\ncase 0x1008:\r\nmaj = ((pvr >> 8) & 0xFF) - 1;\r\nmin = pvr & 0xFF;\r\nbreak;\r\ndefault:\r\nmaj = (pvr >> 8) & 0xFF;\r\nmin = pvr & 0xFF;\r\nbreak;\r\n}\r\n}\r\nseq_printf(m, "revision\t: %hd.%hd (pvr %04x %04x)\n",\r\nmaj, min, PVR_VER(pvr), PVR_REV(pvr));\r\n#ifdef CONFIG_PPC32\r\nseq_printf(m, "bogomips\t: %lu.%02lu\n",\r\nloops_per_jiffy / (500000/HZ),\r\n(loops_per_jiffy / (5000/HZ)) % 100);\r\n#endif\r\n#ifdef CONFIG_SMP\r\nseq_printf(m, "\n");\r\n#endif\r\npreempt_enable();\r\nif (cpumask_next(cpu_id, cpu_online_mask) >= nr_cpu_ids)\r\nshow_cpuinfo_summary(m);\r\nreturn 0;\r\n}\r\nstatic void *c_start(struct seq_file *m, loff_t *pos)\r\n{\r\nif (*pos == 0)\r\n*pos = cpumask_first(cpu_online_mask);\r\nelse\r\n*pos = cpumask_next(*pos - 1, cpu_online_mask);\r\nif ((*pos) < nr_cpu_ids)\r\nreturn (void *)(unsigned long)(*pos + 1);\r\nreturn NULL;\r\n}\r\nstatic void *c_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn c_start(m, pos);\r\n}\r\nstatic void c_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nvoid __init check_for_initrd(void)\r\n{\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nDBG(" -> check_for_initrd() initrd_start=0x%lx initrd_end=0x%lx\n",\r\ninitrd_start, initrd_end);\r\nif (is_kernel_addr(initrd_start) && is_kernel_addr(initrd_end) &&\r\ninitrd_end > initrd_start)\r\nROOT_DEV = Root_RAM0;\r\nelse\r\ninitrd_start = initrd_end = 0;\r\nif (initrd_start)\r\nprintk("Found initrd at 0x%lx:0x%lx\n", initrd_start, initrd_end);\r\nDBG(" <- check_for_initrd()\n");\r\n#endif\r\n}\r\nstatic void __init cpu_init_thread_core_maps(int tpc)\r\n{\r\nint i;\r\nthreads_per_core = tpc;\r\ncpumask_clear(&threads_core_mask);\r\nthreads_shift = ilog2(tpc);\r\nBUG_ON(tpc != (1 << threads_shift));\r\nfor (i = 0; i < tpc; i++)\r\ncpumask_set_cpu(i, &threads_core_mask);\r\nprintk(KERN_INFO "CPU maps initialized for %d thread%s per core\n",\r\ntpc, tpc > 1 ? "s" : "");\r\nprintk(KERN_DEBUG " (thread shift is %d)\n", threads_shift);\r\n}\r\nvoid __init smp_setup_cpu_maps(void)\r\n{\r\nstruct device_node *dn = NULL;\r\nint cpu = 0;\r\nint nthreads = 1;\r\nDBG("smp_setup_cpu_maps()\n");\r\nwhile ((dn = of_find_node_by_type(dn, "cpu")) && cpu < nr_cpu_ids) {\r\nconst int *intserv;\r\nint j, len;\r\nDBG(" * %s...\n", dn->full_name);\r\nintserv = of_get_property(dn, "ibm,ppc-interrupt-server#s",\r\n&len);\r\nif (intserv) {\r\nnthreads = len / sizeof(int);\r\nDBG(" ibm,ppc-interrupt-server#s -> %d threads\n",\r\nnthreads);\r\n} else {\r\nDBG(" no ibm,ppc-interrupt-server#s -> 1 thread\n");\r\nintserv = of_get_property(dn, "reg", NULL);\r\nif (!intserv)\r\nintserv = &cpu;\r\n}\r\nfor (j = 0; j < nthreads && cpu < nr_cpu_ids; j++) {\r\nDBG(" thread %d -> cpu %d (hard id %d)\n",\r\nj, cpu, intserv[j]);\r\nset_cpu_present(cpu, true);\r\nset_hard_smp_processor_id(cpu, intserv[j]);\r\nset_cpu_possible(cpu, true);\r\ncpu++;\r\n}\r\n}\r\nif (!cpu_has_feature(CPU_FTR_SMT)) {\r\nDBG(" SMT disabled ! nthreads forced to 1\n");\r\nnthreads = 1;\r\n}\r\n#ifdef CONFIG_PPC64\r\nif (machine_is(pseries) && firmware_has_feature(FW_FEATURE_LPAR) &&\r\n(dn = of_find_node_by_path("/rtas"))) {\r\nint num_addr_cell, num_size_cell, maxcpus;\r\nconst unsigned int *ireg;\r\nnum_addr_cell = of_n_addr_cells(dn);\r\nnum_size_cell = of_n_size_cells(dn);\r\nireg = of_get_property(dn, "ibm,lrdr-capacity", NULL);\r\nif (!ireg)\r\ngoto out;\r\nmaxcpus = ireg[num_addr_cell + num_size_cell];\r\nif (cpu_has_feature(CPU_FTR_SMT))\r\nmaxcpus *= nthreads;\r\nif (maxcpus > nr_cpu_ids) {\r\nprintk(KERN_WARNING\r\n"Partition configured for %d cpus, "\r\n"operating system maximum is %d.\n",\r\nmaxcpus, nr_cpu_ids);\r\nmaxcpus = nr_cpu_ids;\r\n} else\r\nprintk(KERN_INFO "Partition configured for %d cpus.\n",\r\nmaxcpus);\r\nfor (cpu = 0; cpu < maxcpus; cpu++)\r\nset_cpu_possible(cpu, true);\r\nout:\r\nof_node_put(dn);\r\n}\r\nvdso_data->processorCount = num_present_cpus();\r\n#endif\r\ncpu_init_thread_core_maps(nthreads);\r\nsetup_nr_cpu_ids();\r\nfree_unused_pacas();\r\n}\r\nstatic __init int add_pcspkr(void)\r\n{\r\nstruct device_node *np;\r\nstruct platform_device *pd;\r\nint ret;\r\nnp = of_find_compatible_node(NULL, NULL, "pnpPNP,100");\r\nof_node_put(np);\r\nif (!np)\r\nreturn -ENODEV;\r\npd = platform_device_alloc("pcspkr", -1);\r\nif (!pd)\r\nreturn -ENOMEM;\r\nret = platform_device_add(pd);\r\nif (ret)\r\nplatform_device_put(pd);\r\nreturn ret;\r\n}\r\nvoid probe_machine(void)\r\n{\r\nextern struct machdep_calls __machine_desc_start;\r\nextern struct machdep_calls __machine_desc_end;\r\nDBG("Probing machine type ...\n");\r\nfor (machine_id = &__machine_desc_start;\r\nmachine_id < &__machine_desc_end;\r\nmachine_id++) {\r\nDBG(" %s ...", machine_id->name);\r\nmemcpy(&ppc_md, machine_id, sizeof(struct machdep_calls));\r\nif (ppc_md.probe()) {\r\nDBG(" match !\n");\r\nbreak;\r\n}\r\nDBG("\n");\r\n}\r\nif (machine_id >= &__machine_desc_end) {\r\nDBG("No suitable machine found !\n");\r\nfor (;;);\r\n}\r\nprintk(KERN_INFO "Using %s machine description\n", ppc_md.name);\r\n}\r\nint check_legacy_ioport(unsigned long base_port)\r\n{\r\nstruct device_node *parent, *np = NULL;\r\nint ret = -ENODEV;\r\nswitch(base_port) {\r\ncase I8042_DATA_REG:\r\nif (!(np = of_find_compatible_node(NULL, NULL, "pnpPNP,303")))\r\nnp = of_find_compatible_node(NULL, NULL, "pnpPNP,f03");\r\nif (np) {\r\nparent = of_get_parent(np);\r\nof_i8042_kbd_irq = irq_of_parse_and_map(parent, 0);\r\nif (!of_i8042_kbd_irq)\r\nof_i8042_kbd_irq = 1;\r\nof_i8042_aux_irq = irq_of_parse_and_map(parent, 1);\r\nif (!of_i8042_aux_irq)\r\nof_i8042_aux_irq = 12;\r\nof_node_put(np);\r\nnp = parent;\r\nbreak;\r\n}\r\nnp = of_find_node_by_type(NULL, "8042");\r\nif (!np)\r\nnp = of_find_node_by_name(NULL, "8042");\r\nif (np) {\r\nof_i8042_kbd_irq = 1;\r\nof_i8042_aux_irq = 12;\r\n}\r\nbreak;\r\ncase FDC_BASE:\r\nnp = of_find_node_by_type(NULL, "fdc");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!np)\r\nreturn ret;\r\nparent = of_get_parent(np);\r\nif (parent) {\r\nif (strcmp(parent->type, "isa") == 0)\r\nret = 0;\r\nof_node_put(parent);\r\n}\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic int ppc_panic_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\ncrash_fadump(NULL, ptr);\r\nppc_md.panic(ptr);\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid __init setup_panic(void)\r\n{\r\natomic_notifier_chain_register(&panic_notifier_list, &ppc_panic_block);\r\n}\r\nstatic int __init check_cache_coherency(void)\r\n{\r\nstruct device_node *np;\r\nconst void *prop;\r\nint devtree_coherency;\r\nnp = of_find_node_by_path("/");\r\nprop = of_get_property(np, "coherency-off", NULL);\r\nof_node_put(np);\r\ndevtree_coherency = prop ? 0 : 1;\r\nif (devtree_coherency != KERNEL_COHERENCY) {\r\nprintk(KERN_ERR\r\n"kernel coherency:%s != device tree_coherency:%s\n",\r\nKERNEL_COHERENCY ? "on" : "off",\r\ndevtree_coherency ? "on" : "off");\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int powerpc_debugfs_init(void)\r\n{\r\npowerpc_debugfs_root = debugfs_create_dir("powerpc", NULL);\r\nreturn powerpc_debugfs_root == NULL;\r\n}\r\nnotrace int __init early_parse_wdt(char *p)\r\n{\r\nif (p && strncmp(p, "0", 1) != 0)\r\nbooke_wdt_enabled = 1;\r\nreturn 0;\r\n}\r\nint __init early_parse_wdt_period(char *p)\r\n{\r\nunsigned long ret;\r\nif (p) {\r\nif (!kstrtol(p, 0, &ret))\r\nbooke_wdt_period = ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid ppc_printk_progress(char *s, unsigned short hex)\r\n{\r\npr_info("%s\n", s);\r\n}\r\nvoid arch_setup_pdev_archdata(struct platform_device *pdev)\r\n{\r\npdev->archdata.dma_mask = DMA_BIT_MASK(32);\r\npdev->dev.dma_mask = &pdev->archdata.dma_mask;\r\nset_dma_ops(&pdev->dev, &dma_direct_ops);\r\n}
