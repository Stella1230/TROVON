static int as5011_i2c_write(struct i2c_client *client,\r\nuint8_t aregaddr,\r\nuint8_t avalue)\r\n{\r\nuint8_t data[2] = { aregaddr, avalue };\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = I2C_M_IGNORE_NAK,\r\n.len = 2,\r\n.buf = (uint8_t *)data\r\n};\r\nint error;\r\nerror = i2c_transfer(client->adapter, &msg, 1);\r\nreturn error < 0 ? error : 0;\r\n}\r\nstatic int as5011_i2c_read(struct i2c_client *client,\r\nuint8_t aregaddr, signed char *value)\r\n{\r\nuint8_t data[2] = { aregaddr };\r\nstruct i2c_msg msg_set[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_REV_DIR_ADDR,\r\n.len = 1,\r\n.buf = (uint8_t *)data\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD | I2C_M_NOSTART,\r\n.len = 1,\r\n.buf = (uint8_t *)data\r\n}\r\n};\r\nint error;\r\nerror = i2c_transfer(client->adapter, msg_set, 2);\r\nif (error < 0)\r\nreturn error;\r\n*value = data[0] & 0x80 ? -1 * (1 + ~data[0]) : data[0];\r\nreturn 0;\r\n}\r\nstatic irqreturn_t as5011_button_interrupt(int irq, void *dev_id)\r\n{\r\nstruct as5011_device *as5011 = dev_id;\r\nint val = gpio_get_value_cansleep(as5011->button_gpio);\r\ninput_report_key(as5011->input_dev, BTN_JOYSTICK, !val);\r\ninput_sync(as5011->input_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t as5011_axis_interrupt(int irq, void *dev_id)\r\n{\r\nstruct as5011_device *as5011 = dev_id;\r\nint error;\r\nsigned char x, y;\r\nerror = as5011_i2c_read(as5011->i2c_client, AS5011_X_RES_INT, &x);\r\nif (error < 0)\r\ngoto out;\r\nerror = as5011_i2c_read(as5011->i2c_client, AS5011_Y_RES_INT, &y);\r\nif (error < 0)\r\ngoto out;\r\ninput_report_abs(as5011->input_dev, ABS_X, x);\r\ninput_report_abs(as5011->input_dev, ABS_Y, y);\r\ninput_sync(as5011->input_dev);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int as5011_configure_chip(struct as5011_device *as5011,\r\nconst struct as5011_platform_data *plat_dat)\r\n{\r\nstruct i2c_client *client = as5011->i2c_client;\r\nint error;\r\nsigned char value;\r\nerror = as5011_i2c_write(client, AS5011_CTRL1,\r\nAS5011_CTRL1_SOFT_RST);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Soft reset failed\n");\r\nreturn error;\r\n}\r\nmdelay(10);\r\nerror = as5011_i2c_write(client, AS5011_CTRL1,\r\nAS5011_CTRL1_LP_PULSED |\r\nAS5011_CTRL1_LP_ACTIVE |\r\nAS5011_CTRL1_INT_ACT_EN);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Power config failed\n");\r\nreturn error;\r\n}\r\nerror = as5011_i2c_write(client, AS5011_CTRL2,\r\nAS5011_CTRL2_INV_SPINNING);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Can't invert spinning\n");\r\nreturn error;\r\n}\r\nerror = as5011_i2c_write(client, AS5011_XP, plat_dat->xp);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Can't write threshold\n");\r\nreturn error;\r\n}\r\nerror = as5011_i2c_write(client, AS5011_XN, plat_dat->xn);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Can't write threshold\n");\r\nreturn error;\r\n}\r\nerror = as5011_i2c_write(client, AS5011_YP, plat_dat->yp);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Can't write threshold\n");\r\nreturn error;\r\n}\r\nerror = as5011_i2c_write(client, AS5011_YN, plat_dat->yn);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Can't write threshold\n");\r\nreturn error;\r\n}\r\nerror = as5011_i2c_read(client, AS5011_X_RES_INT, &value);\r\nif (error < 0) {\r\ndev_err(&client->dev, "Can't read i2c X resolution value\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int as5011_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct as5011_platform_data *plat_data;\r\nstruct as5011_device *as5011;\r\nstruct input_dev *input_dev;\r\nint irq;\r\nint error;\r\nplat_data = client->dev.platform_data;\r\nif (!plat_data)\r\nreturn -EINVAL;\r\nif (!plat_data->axis_irq) {\r\ndev_err(&client->dev, "No axis IRQ?\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_NOSTART |\r\nI2C_FUNC_PROTOCOL_MANGLING)) {\r\ndev_err(&client->dev,\r\n"need i2c bus that supports protocol mangling\n");\r\nreturn -ENODEV;\r\n}\r\nas5011 = kmalloc(sizeof(struct as5011_device), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!as5011 || !input_dev) {\r\ndev_err(&client->dev,\r\n"Can't allocate memory for device structure\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nas5011->i2c_client = client;\r\nas5011->input_dev = input_dev;\r\nas5011->button_gpio = plat_data->button_gpio;\r\nas5011->axis_irq = plat_data->axis_irq;\r\ninput_dev->name = "Austria Microsystem as5011 joystick";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(BTN_JOYSTICK, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X,\r\nAS5011_MIN_AXIS, AS5011_MAX_AXIS, AS5011_FUZZ, AS5011_FLAT);\r\ninput_set_abs_params(as5011->input_dev, ABS_Y,\r\nAS5011_MIN_AXIS, AS5011_MAX_AXIS, AS5011_FUZZ, AS5011_FLAT);\r\nerror = gpio_request(as5011->button_gpio, "AS5011 button");\r\nif (error < 0) {\r\ndev_err(&client->dev, "Failed to request button gpio\n");\r\ngoto err_free_mem;\r\n}\r\nirq = gpio_to_irq(as5011->button_gpio);\r\nif (irq < 0) {\r\ndev_err(&client->dev,\r\n"Failed to get irq number for button gpio\n");\r\ngoto err_free_button_gpio;\r\n}\r\nas5011->button_irq = irq;\r\nerror = request_threaded_irq(as5011->button_irq,\r\nNULL, as5011_button_interrupt,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"as5011_button", as5011);\r\nif (error < 0) {\r\ndev_err(&client->dev,\r\n"Can't allocate button irq %d\n", as5011->button_irq);\r\ngoto err_free_button_gpio;\r\n}\r\nerror = as5011_configure_chip(as5011, plat_data);\r\nif (error)\r\ngoto err_free_button_irq;\r\nerror = request_threaded_irq(as5011->axis_irq, NULL,\r\nas5011_axis_interrupt,\r\nplat_data->axis_irqflags | IRQF_ONESHOT,\r\n"as5011_joystick", as5011);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Can't allocate axis irq %d\n", plat_data->axis_irq);\r\ngoto err_free_button_irq;\r\n}\r\nerror = input_register_device(as5011->input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register input device\n");\r\ngoto err_free_axis_irq;\r\n}\r\ni2c_set_clientdata(client, as5011);\r\nreturn 0;\r\nerr_free_axis_irq:\r\nfree_irq(as5011->axis_irq, as5011);\r\nerr_free_button_irq:\r\nfree_irq(as5011->button_irq, as5011);\r\nerr_free_button_gpio:\r\ngpio_free(as5011->button_gpio);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(as5011);\r\nreturn error;\r\n}\r\nstatic int as5011_remove(struct i2c_client *client)\r\n{\r\nstruct as5011_device *as5011 = i2c_get_clientdata(client);\r\nfree_irq(as5011->axis_irq, as5011);\r\nfree_irq(as5011->button_irq, as5011);\r\ngpio_free(as5011->button_gpio);\r\ninput_unregister_device(as5011->input_dev);\r\nkfree(as5011);\r\nreturn 0;\r\n}
