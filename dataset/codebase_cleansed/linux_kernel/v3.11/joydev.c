static int joydev_correct(int value, struct js_corr *corr)\r\n{\r\nswitch (corr->type) {\r\ncase JS_CORR_NONE:\r\nbreak;\r\ncase JS_CORR_BROKEN:\r\nvalue = value > corr->coef[0] ? (value < corr->coef[1] ? 0 :\r\n((corr->coef[3] * (value - corr->coef[1])) >> 14)) :\r\n((corr->coef[2] * (value - corr->coef[0])) >> 14);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn value < -32767 ? -32767 : (value > 32767 ? 32767 : value);\r\n}\r\nstatic void joydev_pass_event(struct joydev_client *client,\r\nstruct js_event *event)\r\n{\r\nstruct joydev *joydev = client->joydev;\r\nspin_lock(&client->buffer_lock);\r\nclient->buffer[client->head] = *event;\r\nif (client->startup == joydev->nabs + joydev->nkey) {\r\nclient->head++;\r\nclient->head &= JOYDEV_BUFFER_SIZE - 1;\r\nif (client->tail == client->head)\r\nclient->startup = 0;\r\n}\r\nspin_unlock(&client->buffer_lock);\r\nkill_fasync(&client->fasync, SIGIO, POLL_IN);\r\n}\r\nstatic void joydev_event(struct input_handle *handle,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct joydev *joydev = handle->private;\r\nstruct joydev_client *client;\r\nstruct js_event event;\r\nswitch (type) {\r\ncase EV_KEY:\r\nif (code < BTN_MISC || value == 2)\r\nreturn;\r\nevent.type = JS_EVENT_BUTTON;\r\nevent.number = joydev->keymap[code - BTN_MISC];\r\nevent.value = value;\r\nbreak;\r\ncase EV_ABS:\r\nevent.type = JS_EVENT_AXIS;\r\nevent.number = joydev->absmap[code];\r\nevent.value = joydev_correct(value,\r\n&joydev->corr[event.number]);\r\nif (event.value == joydev->abs[event.number])\r\nreturn;\r\njoydev->abs[event.number] = event.value;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nevent.time = jiffies_to_msecs(jiffies);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(client, &joydev->client_list, node)\r\njoydev_pass_event(client, &event);\r\nrcu_read_unlock();\r\nwake_up_interruptible(&joydev->wait);\r\n}\r\nstatic int joydev_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct joydev_client *client = file->private_data;\r\nreturn fasync_helper(fd, file, on, &client->fasync);\r\n}\r\nstatic void joydev_free(struct device *dev)\r\n{\r\nstruct joydev *joydev = container_of(dev, struct joydev, dev);\r\ninput_put_device(joydev->handle.dev);\r\nkfree(joydev);\r\n}\r\nstatic void joydev_attach_client(struct joydev *joydev,\r\nstruct joydev_client *client)\r\n{\r\nspin_lock(&joydev->client_lock);\r\nlist_add_tail_rcu(&client->node, &joydev->client_list);\r\nspin_unlock(&joydev->client_lock);\r\n}\r\nstatic void joydev_detach_client(struct joydev *joydev,\r\nstruct joydev_client *client)\r\n{\r\nspin_lock(&joydev->client_lock);\r\nlist_del_rcu(&client->node);\r\nspin_unlock(&joydev->client_lock);\r\nsynchronize_rcu();\r\n}\r\nstatic int joydev_open_device(struct joydev *joydev)\r\n{\r\nint retval;\r\nretval = mutex_lock_interruptible(&joydev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!joydev->exist)\r\nretval = -ENODEV;\r\nelse if (!joydev->open++) {\r\nretval = input_open_device(&joydev->handle);\r\nif (retval)\r\njoydev->open--;\r\n}\r\nmutex_unlock(&joydev->mutex);\r\nreturn retval;\r\n}\r\nstatic void joydev_close_device(struct joydev *joydev)\r\n{\r\nmutex_lock(&joydev->mutex);\r\nif (joydev->exist && !--joydev->open)\r\ninput_close_device(&joydev->handle);\r\nmutex_unlock(&joydev->mutex);\r\n}\r\nstatic void joydev_hangup(struct joydev *joydev)\r\n{\r\nstruct joydev_client *client;\r\nspin_lock(&joydev->client_lock);\r\nlist_for_each_entry(client, &joydev->client_list, node)\r\nkill_fasync(&client->fasync, SIGIO, POLL_HUP);\r\nspin_unlock(&joydev->client_lock);\r\nwake_up_interruptible(&joydev->wait);\r\n}\r\nstatic int joydev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct joydev_client *client = file->private_data;\r\nstruct joydev *joydev = client->joydev;\r\njoydev_detach_client(joydev, client);\r\nkfree(client);\r\njoydev_close_device(joydev);\r\nreturn 0;\r\n}\r\nstatic int joydev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct joydev *joydev =\r\ncontainer_of(inode->i_cdev, struct joydev, cdev);\r\nstruct joydev_client *client;\r\nint error;\r\nclient = kzalloc(sizeof(struct joydev_client), GFP_KERNEL);\r\nif (!client)\r\nreturn -ENOMEM;\r\nspin_lock_init(&client->buffer_lock);\r\nclient->joydev = joydev;\r\njoydev_attach_client(joydev, client);\r\nerror = joydev_open_device(joydev);\r\nif (error)\r\ngoto err_free_client;\r\nfile->private_data = client;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\nerr_free_client:\r\njoydev_detach_client(joydev, client);\r\nkfree(client);\r\nreturn error;\r\n}\r\nstatic int joydev_generate_startup_event(struct joydev_client *client,\r\nstruct input_dev *input,\r\nstruct js_event *event)\r\n{\r\nstruct joydev *joydev = client->joydev;\r\nint have_event;\r\nspin_lock_irq(&client->buffer_lock);\r\nhave_event = client->startup < joydev->nabs + joydev->nkey;\r\nif (have_event) {\r\nevent->time = jiffies_to_msecs(jiffies);\r\nif (client->startup < joydev->nkey) {\r\nevent->type = JS_EVENT_BUTTON | JS_EVENT_INIT;\r\nevent->number = client->startup;\r\nevent->value = !!test_bit(joydev->keypam[event->number],\r\ninput->key);\r\n} else {\r\nevent->type = JS_EVENT_AXIS | JS_EVENT_INIT;\r\nevent->number = client->startup - joydev->nkey;\r\nevent->value = joydev->abs[event->number];\r\n}\r\nclient->startup++;\r\n}\r\nspin_unlock_irq(&client->buffer_lock);\r\nreturn have_event;\r\n}\r\nstatic int joydev_fetch_next_event(struct joydev_client *client,\r\nstruct js_event *event)\r\n{\r\nint have_event;\r\nspin_lock_irq(&client->buffer_lock);\r\nhave_event = client->head != client->tail;\r\nif (have_event) {\r\n*event = client->buffer[client->tail++];\r\nclient->tail &= JOYDEV_BUFFER_SIZE - 1;\r\n}\r\nspin_unlock_irq(&client->buffer_lock);\r\nreturn have_event;\r\n}\r\nstatic ssize_t joydev_0x_read(struct joydev_client *client,\r\nstruct input_dev *input,\r\nchar __user *buf)\r\n{\r\nstruct joydev *joydev = client->joydev;\r\nstruct JS_DATA_TYPE data;\r\nint i;\r\nspin_lock_irq(&input->event_lock);\r\nfor (data.buttons = i = 0; i < 32 && i < joydev->nkey; i++)\r\ndata.buttons |=\r\ntest_bit(joydev->keypam[i], input->key) ? (1 << i) : 0;\r\ndata.x = (joydev->abs[0] / 256 + 128) >> joydev->glue.JS_CORR.x;\r\ndata.y = (joydev->abs[1] / 256 + 128) >> joydev->glue.JS_CORR.y;\r\nspin_lock(&client->buffer_lock);\r\nclient->startup = 0;\r\nclient->tail = client->head;\r\nspin_unlock(&client->buffer_lock);\r\nspin_unlock_irq(&input->event_lock);\r\nif (copy_to_user(buf, &data, sizeof(struct JS_DATA_TYPE)))\r\nreturn -EFAULT;\r\nreturn sizeof(struct JS_DATA_TYPE);\r\n}\r\nstatic inline int joydev_data_pending(struct joydev_client *client)\r\n{\r\nstruct joydev *joydev = client->joydev;\r\nreturn client->startup < joydev->nabs + joydev->nkey ||\r\nclient->head != client->tail;\r\n}\r\nstatic ssize_t joydev_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct joydev_client *client = file->private_data;\r\nstruct joydev *joydev = client->joydev;\r\nstruct input_dev *input = joydev->handle.dev;\r\nstruct js_event event;\r\nint retval;\r\nif (!joydev->exist)\r\nreturn -ENODEV;\r\nif (count < sizeof(struct js_event))\r\nreturn -EINVAL;\r\nif (count == sizeof(struct JS_DATA_TYPE))\r\nreturn joydev_0x_read(client, input, buf);\r\nif (!joydev_data_pending(client) && (file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nretval = wait_event_interruptible(joydev->wait,\r\n!joydev->exist || joydev_data_pending(client));\r\nif (retval)\r\nreturn retval;\r\nif (!joydev->exist)\r\nreturn -ENODEV;\r\nwhile (retval + sizeof(struct js_event) <= count &&\r\njoydev_generate_startup_event(client, input, &event)) {\r\nif (copy_to_user(buf + retval, &event, sizeof(struct js_event)))\r\nreturn -EFAULT;\r\nretval += sizeof(struct js_event);\r\n}\r\nwhile (retval + sizeof(struct js_event) <= count &&\r\njoydev_fetch_next_event(client, &event)) {\r\nif (copy_to_user(buf + retval, &event, sizeof(struct js_event)))\r\nreturn -EFAULT;\r\nretval += sizeof(struct js_event);\r\n}\r\nreturn retval;\r\n}\r\nstatic unsigned int joydev_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct joydev_client *client = file->private_data;\r\nstruct joydev *joydev = client->joydev;\r\npoll_wait(file, &joydev->wait, wait);\r\nreturn (joydev_data_pending(client) ? (POLLIN | POLLRDNORM) : 0) |\r\n(joydev->exist ? 0 : (POLLHUP | POLLERR));\r\n}\r\nstatic int joydev_handle_JSIOCSAXMAP(struct joydev *joydev,\r\nvoid __user *argp, size_t len)\r\n{\r\n__u8 *abspam;\r\nint i;\r\nint retval = 0;\r\nlen = min(len, sizeof(joydev->abspam));\r\nabspam = kmalloc(len, GFP_KERNEL);\r\nif (!abspam)\r\nreturn -ENOMEM;\r\nif (copy_from_user(abspam, argp, len)) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nfor (i = 0; i < joydev->nabs; i++) {\r\nif (abspam[i] > ABS_MAX) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nmemcpy(joydev->abspam, abspam, len);\r\nfor (i = 0; i < joydev->nabs; i++)\r\njoydev->absmap[joydev->abspam[i]] = i;\r\nout:\r\nkfree(abspam);\r\nreturn retval;\r\n}\r\nstatic int joydev_handle_JSIOCSBTNMAP(struct joydev *joydev,\r\nvoid __user *argp, size_t len)\r\n{\r\n__u16 *keypam;\r\nint i;\r\nint retval = 0;\r\nlen = min(len, sizeof(joydev->keypam));\r\nkeypam = kmalloc(len, GFP_KERNEL);\r\nif (!keypam)\r\nreturn -ENOMEM;\r\nif (copy_from_user(keypam, argp, len)) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nfor (i = 0; i < joydev->nkey; i++) {\r\nif (keypam[i] > KEY_MAX || keypam[i] < BTN_MISC) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nmemcpy(joydev->keypam, keypam, len);\r\nfor (i = 0; i < joydev->nkey; i++)\r\njoydev->keymap[keypam[i] - BTN_MISC] = i;\r\nout:\r\nkfree(keypam);\r\nreturn retval;\r\n}\r\nstatic int joydev_ioctl_common(struct joydev *joydev,\r\nunsigned int cmd, void __user *argp)\r\n{\r\nstruct input_dev *dev = joydev->handle.dev;\r\nsize_t len;\r\nint i;\r\nconst char *name;\r\nswitch (cmd) {\r\ncase JS_SET_CAL:\r\nreturn copy_from_user(&joydev->glue.JS_CORR, argp,\r\nsizeof(joydev->glue.JS_CORR)) ? -EFAULT : 0;\r\ncase JS_GET_CAL:\r\nreturn copy_to_user(argp, &joydev->glue.JS_CORR,\r\nsizeof(joydev->glue.JS_CORR)) ? -EFAULT : 0;\r\ncase JS_SET_TIMEOUT:\r\nreturn get_user(joydev->glue.JS_TIMEOUT, (s32 __user *) argp);\r\ncase JS_GET_TIMEOUT:\r\nreturn put_user(joydev->glue.JS_TIMEOUT, (s32 __user *) argp);\r\ncase JSIOCGVERSION:\r\nreturn put_user(JS_VERSION, (__u32 __user *) argp);\r\ncase JSIOCGAXES:\r\nreturn put_user(joydev->nabs, (__u8 __user *) argp);\r\ncase JSIOCGBUTTONS:\r\nreturn put_user(joydev->nkey, (__u8 __user *) argp);\r\ncase JSIOCSCORR:\r\nif (copy_from_user(joydev->corr, argp,\r\nsizeof(joydev->corr[0]) * joydev->nabs))\r\nreturn -EFAULT;\r\nfor (i = 0; i < joydev->nabs; i++) {\r\nint val = input_abs_get_val(dev, joydev->abspam[i]);\r\njoydev->abs[i] = joydev_correct(val, &joydev->corr[i]);\r\n}\r\nreturn 0;\r\ncase JSIOCGCORR:\r\nreturn copy_to_user(argp, joydev->corr,\r\nsizeof(joydev->corr[0]) * joydev->nabs) ? -EFAULT : 0;\r\n}\r\nswitch (cmd & ~IOCSIZE_MASK) {\r\ncase (JSIOCSAXMAP & ~IOCSIZE_MASK):\r\nreturn joydev_handle_JSIOCSAXMAP(joydev, argp, _IOC_SIZE(cmd));\r\ncase (JSIOCGAXMAP & ~IOCSIZE_MASK):\r\nlen = min_t(size_t, _IOC_SIZE(cmd), sizeof(joydev->abspam));\r\nreturn copy_to_user(argp, joydev->abspam, len) ? -EFAULT : len;\r\ncase (JSIOCSBTNMAP & ~IOCSIZE_MASK):\r\nreturn joydev_handle_JSIOCSBTNMAP(joydev, argp, _IOC_SIZE(cmd));\r\ncase (JSIOCGBTNMAP & ~IOCSIZE_MASK):\r\nlen = min_t(size_t, _IOC_SIZE(cmd), sizeof(joydev->keypam));\r\nreturn copy_to_user(argp, joydev->keypam, len) ? -EFAULT : len;\r\ncase JSIOCGNAME(0):\r\nname = dev->name;\r\nif (!name)\r\nreturn 0;\r\nlen = min_t(size_t, _IOC_SIZE(cmd), strlen(name) + 1);\r\nreturn copy_to_user(argp, name, len) ? -EFAULT : len;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long joydev_compat_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct joydev_client *client = file->private_data;\r\nstruct joydev *joydev = client->joydev;\r\nvoid __user *argp = (void __user *)arg;\r\ns32 tmp32;\r\nstruct JS_DATA_SAVE_TYPE_32 ds32;\r\nint retval;\r\nretval = mutex_lock_interruptible(&joydev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!joydev->exist) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase JS_SET_TIMELIMIT:\r\nretval = get_user(tmp32, (s32 __user *) arg);\r\nif (retval == 0)\r\njoydev->glue.JS_TIMELIMIT = tmp32;\r\nbreak;\r\ncase JS_GET_TIMELIMIT:\r\ntmp32 = joydev->glue.JS_TIMELIMIT;\r\nretval = put_user(tmp32, (s32 __user *) arg);\r\nbreak;\r\ncase JS_SET_ALL:\r\nretval = copy_from_user(&ds32, argp,\r\nsizeof(ds32)) ? -EFAULT : 0;\r\nif (retval == 0) {\r\njoydev->glue.JS_TIMEOUT = ds32.JS_TIMEOUT;\r\njoydev->glue.BUSY = ds32.BUSY;\r\njoydev->glue.JS_EXPIRETIME = ds32.JS_EXPIRETIME;\r\njoydev->glue.JS_TIMELIMIT = ds32.JS_TIMELIMIT;\r\njoydev->glue.JS_SAVE = ds32.JS_SAVE;\r\njoydev->glue.JS_CORR = ds32.JS_CORR;\r\n}\r\nbreak;\r\ncase JS_GET_ALL:\r\nds32.JS_TIMEOUT = joydev->glue.JS_TIMEOUT;\r\nds32.BUSY = joydev->glue.BUSY;\r\nds32.JS_EXPIRETIME = joydev->glue.JS_EXPIRETIME;\r\nds32.JS_TIMELIMIT = joydev->glue.JS_TIMELIMIT;\r\nds32.JS_SAVE = joydev->glue.JS_SAVE;\r\nds32.JS_CORR = joydev->glue.JS_CORR;\r\nretval = copy_to_user(argp, &ds32, sizeof(ds32)) ? -EFAULT : 0;\r\nbreak;\r\ndefault:\r\nretval = joydev_ioctl_common(joydev, cmd, argp);\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&joydev->mutex);\r\nreturn retval;\r\n}\r\nstatic long joydev_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct joydev_client *client = file->private_data;\r\nstruct joydev *joydev = client->joydev;\r\nvoid __user *argp = (void __user *)arg;\r\nint retval;\r\nretval = mutex_lock_interruptible(&joydev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!joydev->exist) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase JS_SET_TIMELIMIT:\r\nretval = get_user(joydev->glue.JS_TIMELIMIT,\r\n(long __user *) arg);\r\nbreak;\r\ncase JS_GET_TIMELIMIT:\r\nretval = put_user(joydev->glue.JS_TIMELIMIT,\r\n(long __user *) arg);\r\nbreak;\r\ncase JS_SET_ALL:\r\nretval = copy_from_user(&joydev->glue, argp,\r\nsizeof(joydev->glue)) ? -EFAULT : 0;\r\nbreak;\r\ncase JS_GET_ALL:\r\nretval = copy_to_user(argp, &joydev->glue,\r\nsizeof(joydev->glue)) ? -EFAULT : 0;\r\nbreak;\r\ndefault:\r\nretval = joydev_ioctl_common(joydev, cmd, argp);\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&joydev->mutex);\r\nreturn retval;\r\n}\r\nstatic void joydev_mark_dead(struct joydev *joydev)\r\n{\r\nmutex_lock(&joydev->mutex);\r\njoydev->exist = false;\r\nmutex_unlock(&joydev->mutex);\r\n}\r\nstatic void joydev_cleanup(struct joydev *joydev)\r\n{\r\nstruct input_handle *handle = &joydev->handle;\r\njoydev_mark_dead(joydev);\r\njoydev_hangup(joydev);\r\ncdev_del(&joydev->cdev);\r\nif (joydev->open)\r\ninput_close_device(handle);\r\n}\r\nstatic bool joydev_match(struct input_handler *handler, struct input_dev *dev)\r\n{\r\nif (test_bit(EV_KEY, dev->evbit) && test_bit(BTN_TOUCH, dev->keybit))\r\nreturn false;\r\nif (test_bit(EV_KEY, dev->evbit) && test_bit(BTN_DIGI, dev->keybit))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int joydev_connect(struct input_handler *handler, struct input_dev *dev,\r\nconst struct input_device_id *id)\r\n{\r\nstruct joydev *joydev;\r\nint i, j, t, minor, dev_no;\r\nint error;\r\nminor = input_get_new_minor(JOYDEV_MINOR_BASE, JOYDEV_MINORS, true);\r\nif (minor < 0) {\r\nerror = minor;\r\npr_err("failed to reserve new minor: %d\n", error);\r\nreturn error;\r\n}\r\njoydev = kzalloc(sizeof(struct joydev), GFP_KERNEL);\r\nif (!joydev) {\r\nerror = -ENOMEM;\r\ngoto err_free_minor;\r\n}\r\nINIT_LIST_HEAD(&joydev->client_list);\r\nspin_lock_init(&joydev->client_lock);\r\nmutex_init(&joydev->mutex);\r\ninit_waitqueue_head(&joydev->wait);\r\njoydev->exist = true;\r\ndev_no = minor;\r\nif (dev_no < JOYDEV_MINOR_BASE + JOYDEV_MINORS)\r\ndev_no -= JOYDEV_MINOR_BASE;\r\ndev_set_name(&joydev->dev, "js%d", dev_no);\r\njoydev->handle.dev = input_get_device(dev);\r\njoydev->handle.name = dev_name(&joydev->dev);\r\njoydev->handle.handler = handler;\r\njoydev->handle.private = joydev;\r\nfor (i = 0; i < ABS_CNT; i++)\r\nif (test_bit(i, dev->absbit)) {\r\njoydev->absmap[i] = joydev->nabs;\r\njoydev->abspam[joydev->nabs] = i;\r\njoydev->nabs++;\r\n}\r\nfor (i = BTN_JOYSTICK - BTN_MISC; i < KEY_MAX - BTN_MISC + 1; i++)\r\nif (test_bit(i + BTN_MISC, dev->keybit)) {\r\njoydev->keymap[i] = joydev->nkey;\r\njoydev->keypam[joydev->nkey] = i + BTN_MISC;\r\njoydev->nkey++;\r\n}\r\nfor (i = 0; i < BTN_JOYSTICK - BTN_MISC; i++)\r\nif (test_bit(i + BTN_MISC, dev->keybit)) {\r\njoydev->keymap[i] = joydev->nkey;\r\njoydev->keypam[joydev->nkey] = i + BTN_MISC;\r\njoydev->nkey++;\r\n}\r\nfor (i = 0; i < joydev->nabs; i++) {\r\nj = joydev->abspam[i];\r\nif (input_abs_get_max(dev, j) == input_abs_get_min(dev, j)) {\r\njoydev->corr[i].type = JS_CORR_NONE;\r\njoydev->abs[i] = input_abs_get_val(dev, j);\r\ncontinue;\r\n}\r\njoydev->corr[i].type = JS_CORR_BROKEN;\r\njoydev->corr[i].prec = input_abs_get_fuzz(dev, j);\r\nt = (input_abs_get_max(dev, j) + input_abs_get_min(dev, j)) / 2;\r\njoydev->corr[i].coef[0] = t - input_abs_get_flat(dev, j);\r\njoydev->corr[i].coef[1] = t + input_abs_get_flat(dev, j);\r\nt = (input_abs_get_max(dev, j) - input_abs_get_min(dev, j)) / 2\r\n- 2 * input_abs_get_flat(dev, j);\r\nif (t) {\r\njoydev->corr[i].coef[2] = (1 << 29) / t;\r\njoydev->corr[i].coef[3] = (1 << 29) / t;\r\njoydev->abs[i] =\r\njoydev_correct(input_abs_get_val(dev, j),\r\njoydev->corr + i);\r\n}\r\n}\r\njoydev->dev.devt = MKDEV(INPUT_MAJOR, minor);\r\njoydev->dev.class = &input_class;\r\njoydev->dev.parent = &dev->dev;\r\njoydev->dev.release = joydev_free;\r\ndevice_initialize(&joydev->dev);\r\nerror = input_register_handle(&joydev->handle);\r\nif (error)\r\ngoto err_free_joydev;\r\ncdev_init(&joydev->cdev, &joydev_fops);\r\njoydev->cdev.kobj.parent = &joydev->dev.kobj;\r\nerror = cdev_add(&joydev->cdev, joydev->dev.devt, 1);\r\nif (error)\r\ngoto err_unregister_handle;\r\nerror = device_add(&joydev->dev);\r\nif (error)\r\ngoto err_cleanup_joydev;\r\nreturn 0;\r\nerr_cleanup_joydev:\r\njoydev_cleanup(joydev);\r\nerr_unregister_handle:\r\ninput_unregister_handle(&joydev->handle);\r\nerr_free_joydev:\r\nput_device(&joydev->dev);\r\nerr_free_minor:\r\ninput_free_minor(minor);\r\nreturn error;\r\n}\r\nstatic void joydev_disconnect(struct input_handle *handle)\r\n{\r\nstruct joydev *joydev = handle->private;\r\ndevice_del(&joydev->dev);\r\njoydev_cleanup(joydev);\r\ninput_free_minor(MINOR(joydev->dev.devt));\r\ninput_unregister_handle(handle);\r\nput_device(&joydev->dev);\r\n}\r\nstatic int __init joydev_init(void)\r\n{\r\nreturn input_register_handler(&joydev_handler);\r\n}\r\nstatic void __exit joydev_exit(void)\r\n{\r\ninput_unregister_handler(&joydev_handler);\r\n}
