void ocfs2_dentry_attach_gen(struct dentry *dentry)\r\n{\r\nunsigned long gen =\r\nOCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;\r\nBUG_ON(dentry->d_inode);\r\ndentry->d_fsdata = (void *)gen;\r\n}\r\nstatic int ocfs2_dentry_revalidate(struct dentry *dentry, unsigned int flags)\r\n{\r\nstruct inode *inode;\r\nint ret = 0;\r\nstruct ocfs2_super *osb;\r\nif (flags & LOOKUP_RCU)\r\nreturn -ECHILD;\r\ninode = dentry->d_inode;\r\nosb = OCFS2_SB(dentry->d_sb);\r\ntrace_ocfs2_dentry_revalidate(dentry, dentry->d_name.len,\r\ndentry->d_name.name);\r\nif (inode == NULL) {\r\nunsigned long gen = (unsigned long) dentry->d_fsdata;\r\nunsigned long pgen =\r\nOCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;\r\ntrace_ocfs2_dentry_revalidate_negative(dentry->d_name.len,\r\ndentry->d_name.name,\r\npgen, gen);\r\nif (gen != pgen)\r\ngoto bail;\r\ngoto valid;\r\n}\r\nBUG_ON(!osb);\r\nif (inode == osb->root_inode || is_bad_inode(inode))\r\ngoto bail;\r\nspin_lock(&OCFS2_I(inode)->ip_lock);\r\nif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\r\nspin_unlock(&OCFS2_I(inode)->ip_lock);\r\ntrace_ocfs2_dentry_revalidate_delete(\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\ngoto bail;\r\n}\r\nspin_unlock(&OCFS2_I(inode)->ip_lock);\r\nif (inode->i_nlink == 0) {\r\ntrace_ocfs2_dentry_revalidate_orphaned(\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno,\r\nS_ISDIR(inode->i_mode));\r\ngoto bail;\r\n}\r\nif (!dentry->d_fsdata) {\r\ntrace_ocfs2_dentry_revalidate_nofsdata(\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\ngoto bail;\r\n}\r\nvalid:\r\nret = 1;\r\nbail:\r\ntrace_ocfs2_dentry_revalidate_ret(ret);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_match_dentry(struct dentry *dentry,\r\nu64 parent_blkno,\r\nint skip_unhashed)\r\n{\r\nstruct inode *parent;\r\nif (!dentry->d_fsdata)\r\nreturn 0;\r\nif (!dentry->d_parent)\r\nreturn 0;\r\nif (skip_unhashed && d_unhashed(dentry))\r\nreturn 0;\r\nparent = dentry->d_parent->d_inode;\r\nif (!parent)\r\nreturn 0;\r\nif (OCFS2_I(parent)->ip_blkno != parent_blkno)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstruct dentry *ocfs2_find_local_alias(struct inode *inode,\r\nu64 parent_blkno,\r\nint skip_unhashed)\r\n{\r\nstruct dentry *dentry;\r\nspin_lock(&inode->i_lock);\r\nhlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {\r\nspin_lock(&dentry->d_lock);\r\nif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\r\ntrace_ocfs2_find_local_alias(dentry->d_name.len,\r\ndentry->d_name.name);\r\ndget_dlock(dentry);\r\nspin_unlock(&dentry->d_lock);\r\nspin_unlock(&inode->i_lock);\r\nreturn dentry;\r\n}\r\nspin_unlock(&dentry->d_lock);\r\n}\r\nspin_unlock(&inode->i_lock);\r\nreturn NULL;\r\n}\r\nint ocfs2_dentry_attach_lock(struct dentry *dentry,\r\nstruct inode *inode,\r\nu64 parent_blkno)\r\n{\r\nint ret;\r\nstruct dentry *alias;\r\nstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\r\ntrace_ocfs2_dentry_attach_lock(dentry->d_name.len, dentry->d_name.name,\r\n(unsigned long long)parent_blkno, dl);\r\nif (!inode)\r\nreturn 0;\r\nif (!dentry->d_inode && dentry->d_fsdata) {\r\ndentry->d_fsdata = dl = NULL;\r\n}\r\nif (dl) {\r\nmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\r\n" \"%.*s\": old parent: %llu, new: %llu\n",\r\ndentry->d_name.len, dentry->d_name.name,\r\n(unsigned long long)parent_blkno,\r\n(unsigned long long)dl->dl_parent_blkno);\r\nreturn 0;\r\n}\r\nalias = ocfs2_find_local_alias(inode, parent_blkno, 0);\r\nif (alias) {\r\ndl = alias->d_fsdata;\r\nmlog_bug_on_msg(!dl, "parent %llu, ino %llu\n",\r\n(unsigned long long)parent_blkno,\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\nmlog_bug_on_msg(dl->dl_parent_blkno != parent_blkno,\r\n" \"%.*s\": old parent: %llu, new: %llu\n",\r\ndentry->d_name.len, dentry->d_name.name,\r\n(unsigned long long)parent_blkno,\r\n(unsigned long long)dl->dl_parent_blkno);\r\ntrace_ocfs2_dentry_attach_lock_found(dl->dl_lockres.l_name,\r\n(unsigned long long)parent_blkno,\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\ngoto out_attach;\r\n}\r\ndl = kmalloc(sizeof(*dl), GFP_NOFS);\r\nif (!dl) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\ndl->dl_count = 0;\r\ndl->dl_inode = igrab(inode);\r\ndl->dl_parent_blkno = parent_blkno;\r\nocfs2_dentry_lock_res_init(dl, parent_blkno, inode);\r\nout_attach:\r\nspin_lock(&dentry_attach_lock);\r\ndentry->d_fsdata = dl;\r\ndl->dl_count++;\r\nspin_unlock(&dentry_attach_lock);\r\nret = ocfs2_dentry_lock(dentry, 0);\r\nif (!ret)\r\nocfs2_dentry_unlock(dentry, 0);\r\nelse\r\nmlog_errno(ret);\r\nif (ret < 0 && !alias) {\r\nocfs2_lock_res_free(&dl->dl_lockres);\r\nBUG_ON(dl->dl_count != 1);\r\nspin_lock(&dentry_attach_lock);\r\ndentry->d_fsdata = NULL;\r\nspin_unlock(&dentry_attach_lock);\r\nkfree(dl);\r\niput(inode);\r\n}\r\ndput(alias);\r\nreturn ret;\r\n}\r\nstatic void __ocfs2_drop_dl_inodes(struct ocfs2_super *osb, int drop_count)\r\n{\r\nstruct ocfs2_dentry_lock *dl;\r\nspin_lock(&dentry_list_lock);\r\nwhile (osb->dentry_lock_list && (drop_count < 0 || drop_count--)) {\r\ndl = osb->dentry_lock_list;\r\nosb->dentry_lock_list = dl->dl_next;\r\nspin_unlock(&dentry_list_lock);\r\niput(dl->dl_inode);\r\nkfree(dl);\r\nspin_lock(&dentry_list_lock);\r\n}\r\nspin_unlock(&dentry_list_lock);\r\n}\r\nvoid ocfs2_drop_dl_inodes(struct work_struct *work)\r\n{\r\nstruct ocfs2_super *osb = container_of(work, struct ocfs2_super,\r\ndentry_lock_work);\r\n__ocfs2_drop_dl_inodes(osb, DL_INODE_DROP_COUNT);\r\nspin_lock(&dentry_list_lock);\r\nif (osb->dentry_lock_list &&\r\n!ocfs2_test_osb_flag(osb, OCFS2_OSB_DROP_DENTRY_LOCK_IMMED))\r\nqueue_work(ocfs2_wq, &osb->dentry_lock_work);\r\nspin_unlock(&dentry_list_lock);\r\n}\r\nvoid ocfs2_drop_all_dl_inodes(struct ocfs2_super *osb)\r\n{\r\n__ocfs2_drop_dl_inodes(osb, -1);\r\n}\r\nstatic void ocfs2_drop_dentry_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_dentry_lock *dl)\r\n{\r\nocfs2_simple_drop_lockres(osb, &dl->dl_lockres);\r\nocfs2_lock_res_free(&dl->dl_lockres);\r\nspin_lock(&dentry_list_lock);\r\nif (!osb->dentry_lock_list &&\r\n!ocfs2_test_osb_flag(osb, OCFS2_OSB_DROP_DENTRY_LOCK_IMMED))\r\nqueue_work(ocfs2_wq, &osb->dentry_lock_work);\r\ndl->dl_next = osb->dentry_lock_list;\r\nosb->dentry_lock_list = dl;\r\nspin_unlock(&dentry_list_lock);\r\n}\r\nvoid ocfs2_dentry_lock_put(struct ocfs2_super *osb,\r\nstruct ocfs2_dentry_lock *dl)\r\n{\r\nint unlock;\r\nBUG_ON(dl->dl_count == 0);\r\nspin_lock(&dentry_attach_lock);\r\ndl->dl_count--;\r\nunlock = !dl->dl_count;\r\nspin_unlock(&dentry_attach_lock);\r\nif (unlock)\r\nocfs2_drop_dentry_lock(osb, dl);\r\n}\r\nstatic void ocfs2_dentry_iput(struct dentry *dentry, struct inode *inode)\r\n{\r\nstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\r\nif (!dl) {\r\nif (!(dentry->d_flags & DCACHE_DISCONNECTED) &&\r\n!d_unhashed(dentry)) {\r\nunsigned long long ino = 0ULL;\r\nif (inode)\r\nino = (unsigned long long)OCFS2_I(inode)->ip_blkno;\r\nmlog(ML_ERROR, "Dentry is missing cluster lock. "\r\n"inode: %llu, d_flags: 0x%x, d_name: %.*s\n",\r\nino, dentry->d_flags, dentry->d_name.len,\r\ndentry->d_name.name);\r\n}\r\ngoto out;\r\n}\r\nmlog_bug_on_msg(dl->dl_count == 0, "dentry: %.*s, count: %u\n",\r\ndentry->d_name.len, dentry->d_name.name,\r\ndl->dl_count);\r\nocfs2_dentry_lock_put(OCFS2_SB(dentry->d_sb), dl);\r\nout:\r\niput(inode);\r\n}\r\nvoid ocfs2_dentry_move(struct dentry *dentry, struct dentry *target,\r\nstruct inode *old_dir, struct inode *new_dir)\r\n{\r\nint ret;\r\nstruct ocfs2_super *osb = OCFS2_SB(old_dir->i_sb);\r\nstruct inode *inode = dentry->d_inode;\r\nif (old_dir == new_dir)\r\ngoto out_move;\r\nocfs2_dentry_lock_put(osb, dentry->d_fsdata);\r\ndentry->d_fsdata = NULL;\r\nret = ocfs2_dentry_attach_lock(dentry, inode, OCFS2_I(new_dir)->ip_blkno);\r\nif (ret)\r\nmlog_errno(ret);\r\nout_move:\r\nd_move(dentry, target);\r\n}
