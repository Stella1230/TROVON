static inline bool is_fpc_off(uint32_t fpc)\r\n{\r\nreturn ((fpc & (FP_TG_CONTROL_ON | FP_TG_CONTROL_OFF)) ==\r\nFP_TG_CONTROL_OFF);\r\n}\r\nint nv04_dfp_get_bound_head(struct drm_device *dev, struct dcb_output *dcbent)\r\n{\r\nint ramdac = (dcbent->or & DCB_OUTPUT_C) >> 2;\r\nNVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_CONTROL,\r\nNV_PRAMDAC_FP_TMDS_CONTROL_WRITE_DISABLE | 0x4);\r\nreturn ((NVReadRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_DATA) & 0x8) >> 3) ^ ramdac;\r\n}\r\nvoid nv04_dfp_bind_head(struct drm_device *dev, struct dcb_output *dcbent,\r\nint head, bool dl)\r\n{\r\nint ramdac = (dcbent->or & DCB_OUTPUT_C) >> 2;\r\nuint8_t tmds04 = 0x80;\r\nif (head != ramdac)\r\ntmds04 = 0x88;\r\nif (dcbent->type == DCB_OUTPUT_LVDS)\r\ntmds04 |= 0x01;\r\nnv_write_tmds(dev, dcbent->or, 0, 0x04, tmds04);\r\nif (dl)\r\nnv_write_tmds(dev, dcbent->or, 1, 0x04, tmds04 ^ 0x08);\r\n}\r\nvoid nv04_dfp_disable(struct drm_device *dev, int head)\r\n{\r\nstruct nv04_crtc_reg *crtcstate = nv04_display(dev)->mode_reg.crtc_reg;\r\nif (NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL) &\r\nFP_TG_CONTROL_ON) {\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL,\r\nFP_TG_CONTROL_OFF);\r\nmsleep(50);\r\n}\r\ncrtcstate[head].fp_control = FP_TG_CONTROL_OFF;\r\ncrtcstate[head].CRTC[NV_CIO_CRE_LCD__INDEX] &=\r\n~NV_CIO_CRE_LCD_ROUTE_MASK;\r\n}\r\nvoid nv04_dfp_update_fp_control(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_crtc *crtc;\r\nstruct nouveau_crtc *nv_crtc;\r\nuint32_t *fpc;\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nnv_crtc = nouveau_crtc(encoder->crtc);\r\nfpc = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index].fp_control;\r\nif (is_fpc_off(*fpc)) {\r\n*fpc = nv_crtc->dpms_saved_fp_control;\r\n}\r\nnv_crtc->fp_users |= 1 << nouveau_encoder(encoder)->dcb->index;\r\nNVWriteRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_FP_TG_CONTROL, *fpc);\r\n} else {\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nnv_crtc = nouveau_crtc(crtc);\r\nfpc = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index].fp_control;\r\nnv_crtc->fp_users &= ~(1 << nouveau_encoder(encoder)->dcb->index);\r\nif (!is_fpc_off(*fpc) && !nv_crtc->fp_users) {\r\nnv_crtc->dpms_saved_fp_control = *fpc;\r\n*fpc &= ~FP_TG_CONTROL_ON;\r\n*fpc |= FP_TG_CONTROL_OFF;\r\nNVWriteRAMDAC(dev, nv_crtc->index,\r\nNV_PRAMDAC_FP_TG_CONTROL, *fpc);\r\n}\r\n}\r\n}\r\n}\r\nstatic struct drm_encoder *get_tmds_slave(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\r\nstruct drm_encoder *slave;\r\nif (dcb->type != DCB_OUTPUT_TMDS || dcb->location == DCB_LOC_ON_CHIP)\r\nreturn NULL;\r\nlist_for_each_entry(slave, &dev->mode_config.encoder_list, head) {\r\nstruct dcb_output *slave_dcb = nouveau_encoder(slave)->dcb;\r\nif (slave_dcb->type == DCB_OUTPUT_TMDS && get_slave_funcs(slave) &&\r\nslave_dcb->tmdsconf.slave_addr == dcb->tmdsconf.slave_addr)\r\nreturn slave;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool nv04_dfp_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_connector *nv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nif (!nv_connector->native_mode ||\r\nnv_connector->scaling_mode == DRM_MODE_SCALE_NONE ||\r\nmode->hdisplay > nv_connector->native_mode->hdisplay ||\r\nmode->vdisplay > nv_connector->native_mode->vdisplay) {\r\nnv_encoder->mode = *adjusted_mode;\r\n} else {\r\nnv_encoder->mode = *nv_connector->native_mode;\r\nadjusted_mode->clock = nv_connector->native_mode->clock;\r\n}\r\nreturn true;\r\n}\r\nstatic void nv04_dfp_prepare_sel_clk(struct drm_device *dev,\r\nstruct nouveau_encoder *nv_encoder, int head)\r\n{\r\nstruct nv04_mode_state *state = &nv04_display(dev)->mode_reg;\r\nuint32_t bits1618 = nv_encoder->dcb->or & DCB_OUTPUT_A ? 0x10000 : 0x40000;\r\nif (nv_encoder->dcb->location != DCB_LOC_ON_CHIP)\r\nreturn;\r\nif (head)\r\nstate->sel_clk |= bits1618;\r\nelse\r\nstate->sel_clk &= ~bits1618;\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS && nv04_display(dev)->saved_reg.sel_clk & 0xf0) {\r\nint shift = (nv04_display(dev)->saved_reg.sel_clk & 0x50) ? 0 : 1;\r\nstate->sel_clk &= ~0xf0;\r\nstate->sel_clk |= (head ? 0x40 : 0x10) << shift;\r\n}\r\n}\r\nstatic void nv04_dfp_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_encoder_helper_funcs *helper = encoder->helper_private;\r\nstruct drm_device *dev = encoder->dev;\r\nint head = nouveau_crtc(encoder->crtc)->index;\r\nstruct nv04_crtc_reg *crtcstate = nv04_display(dev)->mode_reg.crtc_reg;\r\nuint8_t *cr_lcd = &crtcstate[head].CRTC[NV_CIO_CRE_LCD__INDEX];\r\nuint8_t *cr_lcd_oth = &crtcstate[head ^ 1].CRTC[NV_CIO_CRE_LCD__INDEX];\r\nhelper->dpms(encoder, DRM_MODE_DPMS_OFF);\r\nnv04_dfp_prepare_sel_clk(dev, nv_encoder, head);\r\n*cr_lcd = (*cr_lcd & ~NV_CIO_CRE_LCD_ROUTE_MASK) | 0x3;\r\nif (nv_two_heads(dev)) {\r\nif (nv_encoder->dcb->location == DCB_LOC_ON_CHIP)\r\n*cr_lcd |= head ? 0x0 : 0x8;\r\nelse {\r\n*cr_lcd |= (nv_encoder->dcb->or << 4) & 0x30;\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS)\r\n*cr_lcd |= 0x30;\r\nif ((*cr_lcd & 0x30) == (*cr_lcd_oth & 0x30)) {\r\n*cr_lcd_oth &= ~0x30;\r\nNVWriteVgaCrtc(dev, head ^ 1,\r\nNV_CIO_CRE_LCD__INDEX,\r\n*cr_lcd_oth);\r\n}\r\n}\r\n}\r\n}\r\nstatic void nv04_dfp_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\r\nstruct nv04_crtc_reg *savep = &nv04_display(dev)->saved_reg.crtc_reg[nv_crtc->index];\r\nstruct nouveau_connector *nv_connector = nouveau_crtc_connector_get(nv_crtc);\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_display_mode *output_mode = &nv_encoder->mode;\r\nstruct drm_connector *connector = &nv_connector->base;\r\nuint32_t mode_ratio, panel_ratio;\r\nNV_DEBUG(drm, "Output mode on CRTC %d:\n", nv_crtc->index);\r\ndrm_mode_debug_printmodeline(output_mode);\r\nregp->fp_horiz_regs[FP_DISPLAY_END] = output_mode->hdisplay - 1;\r\nregp->fp_horiz_regs[FP_TOTAL] = output_mode->htotal - 1;\r\nif (!nv_gf4_disp_arch(dev) ||\r\n(output_mode->hsync_start - output_mode->hdisplay) >=\r\ndrm->vbios.digital_min_front_porch)\r\nregp->fp_horiz_regs[FP_CRTC] = output_mode->hdisplay;\r\nelse\r\nregp->fp_horiz_regs[FP_CRTC] = output_mode->hsync_start - drm->vbios.digital_min_front_porch - 1;\r\nregp->fp_horiz_regs[FP_SYNC_START] = output_mode->hsync_start - 1;\r\nregp->fp_horiz_regs[FP_SYNC_END] = output_mode->hsync_end - 1;\r\nregp->fp_horiz_regs[FP_VALID_START] = output_mode->hskew;\r\nregp->fp_horiz_regs[FP_VALID_END] = output_mode->hdisplay - 1;\r\nregp->fp_vert_regs[FP_DISPLAY_END] = output_mode->vdisplay - 1;\r\nregp->fp_vert_regs[FP_TOTAL] = output_mode->vtotal - 1;\r\nregp->fp_vert_regs[FP_CRTC] = output_mode->vtotal - 5 - 1;\r\nregp->fp_vert_regs[FP_SYNC_START] = output_mode->vsync_start - 1;\r\nregp->fp_vert_regs[FP_SYNC_END] = output_mode->vsync_end - 1;\r\nregp->fp_vert_regs[FP_VALID_START] = 0;\r\nregp->fp_vert_regs[FP_VALID_END] = output_mode->vdisplay - 1;\r\nregp->fp_control = NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS |\r\n(savep->fp_control & (1 << 26 | NV_PRAMDAC_FP_TG_CONTROL_READ_PROG));\r\nif (output_mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS;\r\nif (output_mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS;\r\nif (nv_connector->scaling_mode == DRM_MODE_SCALE_NONE ||\r\nnv_connector->scaling_mode == DRM_MODE_SCALE_CENTER)\r\nregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_MODE_CENTER;\r\nelse if (adjusted_mode->hdisplay == output_mode->hdisplay &&\r\nadjusted_mode->vdisplay == output_mode->vdisplay)\r\nregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_MODE_NATIVE;\r\nelse\r\nregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_MODE_SCALE;\r\nif (nv_rd32(device, NV_PEXTDEV_BOOT_0) & NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_12BIT)\r\nregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_WIDTH_12;\r\nif (nv_encoder->dcb->location != DCB_LOC_ON_CHIP &&\r\noutput_mode->clock > 165000)\r\nregp->fp_control |= (2 << 24);\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS) {\r\nbool duallink = false, dummy;\r\nif (nv_connector->edid &&\r\nnv_connector->type == DCB_CONNECTOR_LVDS_SPWG) {\r\nduallink = (((u8 *)nv_connector->edid)[121] == 2);\r\n} else {\r\nnouveau_bios_parse_lvds_table(dev, output_mode->clock,\r\n&duallink, &dummy);\r\n}\r\nif (duallink)\r\nregp->fp_control |= (8 << 28);\r\n} else\r\nif (output_mode->clock > 165000)\r\nregp->fp_control |= (8 << 28);\r\nregp->fp_debug_0 = NV_PRAMDAC_FP_DEBUG_0_YWEIGHT_ROUND |\r\nNV_PRAMDAC_FP_DEBUG_0_XWEIGHT_ROUND |\r\nNV_PRAMDAC_FP_DEBUG_0_YINTERP_BILINEAR |\r\nNV_PRAMDAC_FP_DEBUG_0_XINTERP_BILINEAR |\r\nNV_RAMDAC_FP_DEBUG_0_TMDS_ENABLED |\r\nNV_PRAMDAC_FP_DEBUG_0_YSCALE_ENABLE |\r\nNV_PRAMDAC_FP_DEBUG_0_XSCALE_ENABLE;\r\nregp->fp_debug_1 = 0;\r\nregp->fp_debug_2 = 0;\r\nmode_ratio = (1 << 12) * adjusted_mode->hdisplay / adjusted_mode->vdisplay;\r\npanel_ratio = (1 << 12) * output_mode->hdisplay / output_mode->vdisplay;\r\nif (nv_connector->scaling_mode == DRM_MODE_SCALE_ASPECT &&\r\nmode_ratio != panel_ratio) {\r\nuint32_t diff, scale;\r\nbool divide_by_2 = nv_gf4_disp_arch(dev);\r\nif (mode_ratio < panel_ratio) {\r\nscale = (1 << 12) * adjusted_mode->vdisplay / output_mode->vdisplay;\r\nregp->fp_debug_1 = NV_PRAMDAC_FP_DEBUG_1_XSCALE_TESTMODE_ENABLE |\r\nXLATE(scale, divide_by_2, NV_PRAMDAC_FP_DEBUG_1_XSCALE_VALUE);\r\ndiff = output_mode->hdisplay -\r\noutput_mode->vdisplay * mode_ratio / (1 << 12);\r\nregp->fp_horiz_regs[FP_VALID_START] += diff / 2;\r\nregp->fp_horiz_regs[FP_VALID_END] -= diff / 2;\r\n}\r\nif (mode_ratio > panel_ratio) {\r\nscale = (1 << 12) * adjusted_mode->hdisplay / output_mode->hdisplay;\r\nregp->fp_debug_1 = NV_PRAMDAC_FP_DEBUG_1_YSCALE_TESTMODE_ENABLE |\r\nXLATE(scale, divide_by_2, NV_PRAMDAC_FP_DEBUG_1_YSCALE_VALUE);\r\ndiff = output_mode->vdisplay -\r\n(1 << 12) * output_mode->hdisplay / mode_ratio;\r\nregp->fp_vert_regs[FP_VALID_START] += diff / 2;\r\nregp->fp_vert_regs[FP_VALID_END] -= diff / 2;\r\n}\r\n}\r\nif ((nv_connector->dithering_mode == DITHERING_MODE_ON) ||\r\n(nv_connector->dithering_mode == DITHERING_MODE_AUTO &&\r\nencoder->crtc->fb->depth > connector->display_info.bpc * 3)) {\r\nif (nv_device(drm->device)->chipset == 0x11)\r\nregp->dither = savep->dither | 0x00010000;\r\nelse {\r\nint i;\r\nregp->dither = savep->dither | 0x00000001;\r\nfor (i = 0; i < 3; i++) {\r\nregp->dither_regs[i] = 0xe4e4e4e4;\r\nregp->dither_regs[i + 3] = 0x44444444;\r\n}\r\n}\r\n} else {\r\nif (nv_device(drm->device)->chipset != 0x11) {\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nregp->dither_regs[i] = savep->dither_regs[i];\r\nregp->dither_regs[i + 3] = savep->dither_regs[i + 3];\r\n}\r\n}\r\nregp->dither = savep->dither;\r\n}\r\nregp->fp_margin_color = 0;\r\n}\r\nstatic void nv04_dfp_commit(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct drm_encoder_helper_funcs *helper = encoder->helper_private;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct dcb_output *dcbe = nv_encoder->dcb;\r\nint head = nouveau_crtc(encoder->crtc)->index;\r\nstruct drm_encoder *slave_encoder;\r\nif (dcbe->type == DCB_OUTPUT_TMDS)\r\nrun_tmds_table(dev, dcbe, head, nv_encoder->mode.clock);\r\nelse if (dcbe->type == DCB_OUTPUT_LVDS)\r\ncall_lvds_script(dev, dcbe, head, LVDS_RESET, nv_encoder->mode.clock);\r\nnv04_display(dev)->mode_reg.crtc_reg[head].fp_control =\r\nNVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL);\r\nif (nv_device(drm->device)->chipset < 0x44)\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + nv04_dac_output_offset(encoder), 0xf0000000);\r\nelse\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + nv04_dac_output_offset(encoder), 0x00100000);\r\nslave_encoder = get_tmds_slave(encoder);\r\nif (slave_encoder)\r\nget_slave_funcs(slave_encoder)->mode_set(\r\nslave_encoder, &nv_encoder->mode, &nv_encoder->mode);\r\nhelper->dpms(encoder, DRM_MODE_DPMS_ON);\r\nNV_DEBUG(drm, "Output %s is running on CRTC %d using output %c\n",\r\ndrm_get_connector_name(&nouveau_encoder_connector_get(nv_encoder)->base),\r\nnv_crtc->index, '@' + ffs(nv_encoder->dcb->or));\r\n}\r\nstatic void nv04_dfp_update_backlight(struct drm_encoder *encoder, int mode)\r\n{\r\n#ifdef __powerpc__\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nif (dev->pci_device == 0x0174 || dev->pci_device == 0x0179 ||\r\ndev->pci_device == 0x0189 || dev->pci_device == 0x0329) {\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nnv_mask(device, NV_PBUS_DEBUG_DUALHEAD_CTL, 0, 1 << 31);\r\nnv_mask(device, NV_PCRTC_GPIO_EXT, 3, 1);\r\n} else {\r\nnv_mask(device, NV_PBUS_DEBUG_DUALHEAD_CTL, 1 << 31, 0);\r\nnv_mask(device, NV_PCRTC_GPIO_EXT, 3, 0);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic inline bool is_powersaving_dpms(int mode)\r\n{\r\nreturn mode != DRM_MODE_DPMS_ON && mode != NV_DPMS_CLEARED;\r\n}\r\nstatic void nv04_lvds_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nbool was_powersaving = is_powersaving_dpms(nv_encoder->last_dpms);\r\nif (nv_encoder->last_dpms == mode)\r\nreturn;\r\nnv_encoder->last_dpms = mode;\r\nNV_DEBUG(drm, "Setting dpms mode %d on lvds encoder (output %d)\n",\r\nmode, nv_encoder->dcb->index);\r\nif (was_powersaving && is_powersaving_dpms(mode))\r\nreturn;\r\nif (nv_encoder->dcb->lvdsconf.use_power_scripts) {\r\nint head = crtc ? nouveau_crtc(crtc)->index :\r\nnv04_dfp_get_bound_head(dev, nv_encoder->dcb);\r\nif (mode == DRM_MODE_DPMS_ON) {\r\ncall_lvds_script(dev, nv_encoder->dcb, head,\r\nLVDS_PANEL_ON, nv_encoder->mode.clock);\r\n} else\r\ncall_lvds_script(dev, nv_encoder->dcb, head,\r\nLVDS_PANEL_OFF, 0);\r\n}\r\nnv04_dfp_update_backlight(encoder, mode);\r\nnv04_dfp_update_fp_control(encoder, mode);\r\nif (mode == DRM_MODE_DPMS_ON)\r\nnv04_dfp_prepare_sel_clk(dev, nv_encoder, nouveau_crtc(crtc)->index);\r\nelse {\r\nnv04_display(dev)->mode_reg.sel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK);\r\nnv04_display(dev)->mode_reg.sel_clk &= ~0xf0;\r\n}\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, nv04_display(dev)->mode_reg.sel_clk);\r\n}\r\nstatic void nv04_tmds_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nif (nv_encoder->last_dpms == mode)\r\nreturn;\r\nnv_encoder->last_dpms = mode;\r\nNV_DEBUG(drm, "Setting dpms mode %d on tmds encoder (output %d)\n",\r\nmode, nv_encoder->dcb->index);\r\nnv04_dfp_update_backlight(encoder, mode);\r\nnv04_dfp_update_fp_control(encoder, mode);\r\n}\r\nstatic void nv04_dfp_save(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nif (nv_two_heads(dev))\r\nnv_encoder->restore.head =\r\nnv04_dfp_get_bound_head(dev, nv_encoder->dcb);\r\n}\r\nstatic void nv04_dfp_restore(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nint head = nv_encoder->restore.head;\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS) {\r\nstruct nouveau_connector *connector =\r\nnouveau_encoder_connector_get(nv_encoder);\r\nif (connector && connector->native_mode)\r\ncall_lvds_script(dev, nv_encoder->dcb, head,\r\nLVDS_PANEL_ON,\r\nconnector->native_mode->clock);\r\n} else if (nv_encoder->dcb->type == DCB_OUTPUT_TMDS) {\r\nint clock = nouveau_hw_pllvals_to_clk\r\n(&nv04_display(dev)->saved_reg.crtc_reg[head].pllvals);\r\nrun_tmds_table(dev, nv_encoder->dcb, head, clock);\r\n}\r\nnv_encoder->last_dpms = NV_DPMS_CLEARED;\r\n}\r\nstatic void nv04_dfp_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nif (get_slave_funcs(encoder))\r\nget_slave_funcs(encoder)->destroy(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(nv_encoder);\r\n}\r\nstatic void nv04_tmds_slave_init(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_i2c *i2c = nouveau_i2c(drm->device);\r\nstruct nouveau_i2c_port *port = i2c->find(i2c, 2);\r\nstruct i2c_board_info info[] = {\r\n{\r\n.type = "sil164",\r\n.addr = (dcb->tmdsconf.slave_addr == 0x7 ? 0x3a : 0x38),\r\n.platform_data = &(struct sil164_encoder_params) {\r\nSIL164_INPUT_EDGE_RISING\r\n}\r\n},\r\n{ }\r\n};\r\nint type;\r\nif (!nv_gf4_disp_arch(dev) || !port ||\r\nget_tmds_slave(encoder))\r\nreturn;\r\ntype = i2c->identify(i2c, 2, "TMDS transmitter", info, NULL);\r\nif (type < 0)\r\nreturn;\r\ndrm_i2c_encoder_init(dev, to_encoder_slave(encoder),\r\n&port->adapter, &info[type]);\r\n}\r\nint\r\nnv04_dfp_create(struct drm_connector *connector, struct dcb_output *entry)\r\n{\r\nconst struct drm_encoder_helper_funcs *helper;\r\nstruct nouveau_encoder *nv_encoder = NULL;\r\nstruct drm_encoder *encoder;\r\nint type;\r\nswitch (entry->type) {\r\ncase DCB_OUTPUT_TMDS:\r\ntype = DRM_MODE_ENCODER_TMDS;\r\nhelper = &nv04_tmds_helper_funcs;\r\nbreak;\r\ncase DCB_OUTPUT_LVDS:\r\ntype = DRM_MODE_ENCODER_LVDS;\r\nhelper = &nv04_lvds_helper_funcs;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\r\nif (!nv_encoder)\r\nreturn -ENOMEM;\r\nencoder = to_drm_encoder(nv_encoder);\r\nnv_encoder->dcb = entry;\r\nnv_encoder->or = ffs(entry->or) - 1;\r\ndrm_encoder_init(connector->dev, encoder, &nv04_dfp_funcs, type);\r\ndrm_encoder_helper_add(encoder, helper);\r\nencoder->possible_crtcs = entry->heads;\r\nencoder->possible_clones = 0;\r\nif (entry->type == DCB_OUTPUT_TMDS &&\r\nentry->location != DCB_LOC_ON_CHIP)\r\nnv04_tmds_slave_init(encoder);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}
