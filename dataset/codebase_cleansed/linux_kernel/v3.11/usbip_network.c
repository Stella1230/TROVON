void usbip_net_pack_uint32_t(int pack, uint32_t *num)\r\n{\r\nuint32_t i;\r\nif (pack)\r\ni = htonl(*num);\r\nelse\r\ni = ntohl(*num);\r\n*num = i;\r\n}\r\nvoid usbip_net_pack_uint16_t(int pack, uint16_t *num)\r\n{\r\nuint16_t i;\r\nif (pack)\r\ni = htons(*num);\r\nelse\r\ni = ntohs(*num);\r\n*num = i;\r\n}\r\nvoid usbip_net_pack_usb_device(int pack, struct usbip_usb_device *udev)\r\n{\r\nusbip_net_pack_uint32_t(pack, &udev->busnum);\r\nusbip_net_pack_uint32_t(pack, &udev->devnum);\r\nusbip_net_pack_uint32_t(pack, &udev->speed);\r\nusbip_net_pack_uint16_t(pack, &udev->idVendor);\r\nusbip_net_pack_uint16_t(pack, &udev->idProduct);\r\nusbip_net_pack_uint16_t(pack, &udev->bcdDevice);\r\n}\r\nstatic ssize_t usbip_net_xmit(int sockfd, void *buff, size_t bufflen,\r\nint sending)\r\n{\r\nssize_t nbytes;\r\nssize_t total = 0;\r\nif (!bufflen)\r\nreturn 0;\r\ndo {\r\nif (sending)\r\nnbytes = send(sockfd, buff, bufflen, 0);\r\nelse\r\nnbytes = recv(sockfd, buff, bufflen, MSG_WAITALL);\r\nif (nbytes <= 0)\r\nreturn -1;\r\nbuff = (void *)((intptr_t) buff + nbytes);\r\nbufflen -= nbytes;\r\ntotal += nbytes;\r\n} while (bufflen > 0);\r\nreturn total;\r\n}\r\nssize_t usbip_net_recv(int sockfd, void *buff, size_t bufflen)\r\n{\r\nreturn usbip_net_xmit(sockfd, buff, bufflen, 0);\r\n}\r\nssize_t usbip_net_send(int sockfd, void *buff, size_t bufflen)\r\n{\r\nreturn usbip_net_xmit(sockfd, buff, bufflen, 1);\r\n}\r\nint usbip_net_send_op_common(int sockfd, uint32_t code, uint32_t status)\r\n{\r\nstruct op_common op_common;\r\nint rc;\r\nmemset(&op_common, 0, sizeof(op_common));\r\nop_common.version = USBIP_VERSION;\r\nop_common.code = code;\r\nop_common.status = status;\r\nPACK_OP_COMMON(1, &op_common);\r\nrc = usbip_net_send(sockfd, &op_common, sizeof(op_common));\r\nif (rc < 0) {\r\ndbg("usbip_net_send failed: %d", rc);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint usbip_net_recv_op_common(int sockfd, uint16_t *code)\r\n{\r\nstruct op_common op_common;\r\nint rc;\r\nmemset(&op_common, 0, sizeof(op_common));\r\nrc = usbip_net_recv(sockfd, &op_common, sizeof(op_common));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv failed: %d", rc);\r\ngoto err;\r\n}\r\nPACK_OP_COMMON(0, &op_common);\r\nif (op_common.version != USBIP_VERSION) {\r\ndbg("version mismatch: %d %d", op_common.version,\r\nUSBIP_VERSION);\r\ngoto err;\r\n}\r\nswitch (*code) {\r\ncase OP_UNSPEC:\r\nbreak;\r\ndefault:\r\nif (op_common.code != *code) {\r\ndbg("unexpected pdu %#0x for %#0x", op_common.code,\r\n*code);\r\ngoto err;\r\n}\r\n}\r\nif (op_common.status != ST_OK) {\r\ndbg("request failed at peer: %d", op_common.status);\r\ngoto err;\r\n}\r\n*code = op_common.code;\r\nreturn 0;\r\nerr:\r\nreturn -1;\r\n}\r\nint usbip_net_set_reuseaddr(int sockfd)\r\n{\r\nconst int val = 1;\r\nint ret;\r\nret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));\r\nif (ret < 0)\r\ndbg("setsockopt: SO_REUSEADDR");\r\nreturn ret;\r\n}\r\nint usbip_net_set_nodelay(int sockfd)\r\n{\r\nconst int val = 1;\r\nint ret;\r\nret = setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val));\r\nif (ret < 0)\r\ndbg("setsockopt: TCP_NODELAY");\r\nreturn ret;\r\n}\r\nint usbip_net_set_keepalive(int sockfd)\r\n{\r\nconst int val = 1;\r\nint ret;\r\nret = setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val));\r\nif (ret < 0)\r\ndbg("setsockopt: SO_KEEPALIVE");\r\nreturn ret;\r\n}\r\nint usbip_net_tcp_connect(char *hostname, char *service)\r\n{\r\nstruct addrinfo hints, *res, *rp;\r\nint sockfd;\r\nint ret;\r\nmemset(&hints, 0, sizeof(hints));\r\nhints.ai_family = AF_UNSPEC;\r\nhints.ai_socktype = SOCK_STREAM;\r\nret = getaddrinfo(hostname, service, &hints, &res);\r\nif (ret < 0) {\r\ndbg("getaddrinfo: %s service %s: %s", hostname, service,\r\ngai_strerror(ret));\r\nreturn ret;\r\n}\r\nfor (rp = res; rp; rp = rp->ai_next) {\r\nsockfd = socket(rp->ai_family, rp->ai_socktype,\r\nrp->ai_protocol);\r\nif (sockfd < 0)\r\ncontinue;\r\nusbip_net_set_nodelay(sockfd);\r\nusbip_net_set_keepalive(sockfd);\r\nif (connect(sockfd, rp->ai_addr, rp->ai_addrlen) == 0)\r\nbreak;\r\nclose(sockfd);\r\n}\r\nfreeaddrinfo(res);\r\nif (!rp)\r\nreturn EAI_SYSTEM;\r\nreturn sockfd;\r\n}
