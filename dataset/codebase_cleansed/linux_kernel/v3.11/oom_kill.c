static bool has_intersects_mems_allowed(struct task_struct *tsk,\r\nconst nodemask_t *mask)\r\n{\r\nstruct task_struct *start = tsk;\r\ndo {\r\nif (mask) {\r\nif (mempolicy_nodemask_intersects(tsk, mask))\r\nreturn true;\r\n} else {\r\nif (cpuset_mems_allowed_intersects(current, tsk))\r\nreturn true;\r\n}\r\n} while_each_thread(start, tsk);\r\nbool has_intersects_mems_allowed(struct task_struct *tsk,\r\nconst nodemask_t *mask)\r\n{\r\nreturn true;\r\n}\r\nstruct task_struct *find_lock_task_mm(struct task_struct *p)\r\n{\r\nstruct task_struct *t = p;\r\ndo {\r\ntask_lock(t);\r\nif (likely(t->mm))\r\nreturn t;\r\ntask_unlock(t);\r\n} while_each_thread(p, t);\r\nbool oom_unkillable_task(struct task_struct *p,\r\nconst struct mem_cgroup *memcg, const nodemask_t *nodemask)\r\n{\r\nif (is_global_init(p))\r\nreturn true;\r\nif (p->flags & PF_KTHREAD)\r\nreturn true;\r\nif (memcg && !task_in_mem_cgroup(p, memcg))\r\nreturn true;\r\nif (!has_intersects_mems_allowed(p, nodemask))\r\nreturn true;\r\nreturn false;\r\n}\r\nunsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,\r\nconst nodemask_t *nodemask, unsigned long totalpages)\r\n{\r\nlong points;\r\nlong adj;\r\nif (oom_unkillable_task(p, memcg, nodemask))\r\nreturn 0;\r\np = find_lock_task_mm(p);\r\nif (!p)\r\nreturn 0;\r\nadj = (long)p->signal->oom_score_adj;\r\nif (adj == OOM_SCORE_ADJ_MIN) {\r\ntask_unlock(p);\r\nreturn 0;\r\n}\r\npoints = get_mm_rss(p->mm) + p->mm->nr_ptes +\r\nget_mm_counter(p->mm, MM_SWAPENTS);\r\ntask_unlock(p);\r\nif (has_capability_noaudit(p, CAP_SYS_ADMIN))\r\nadj -= 30;\r\nadj *= totalpages / 1000;\r\npoints += adj;\r\nreturn points > 0 ? points : 1;\r\n}\r\nstatic enum oom_constraint constrained_alloc(struct zonelist *zonelist,\r\ngfp_t gfp_mask, nodemask_t *nodemask,\r\nunsigned long *totalpages)\r\n{\r\nstruct zone *zone;\r\nstruct zoneref *z;\r\nenum zone_type high_zoneidx = gfp_zone(gfp_mask);\r\nbool cpuset_limited = false;\r\nint nid;\r\n*totalpages = totalram_pages + total_swap_pages;\r\nif (!zonelist)\r\nreturn CONSTRAINT_NONE;\r\nif (gfp_mask & __GFP_THISNODE)\r\nreturn CONSTRAINT_NONE;\r\nif (nodemask && !nodes_subset(node_states[N_MEMORY], *nodemask)) {\r\n*totalpages = total_swap_pages;\r\nfor_each_node_mask(nid, *nodemask)\r\n*totalpages += node_spanned_pages(nid);\r\nreturn CONSTRAINT_MEMORY_POLICY;\r\n}\r\nfor_each_zone_zonelist_nodemask(zone, z, zonelist,\r\nhigh_zoneidx, nodemask)\r\nif (!cpuset_zone_allowed_softwall(zone, gfp_mask))\r\ncpuset_limited = true;\r\nif (cpuset_limited) {\r\n*totalpages = total_swap_pages;\r\nfor_each_node_mask(nid, cpuset_current_mems_allowed)\r\n*totalpages += node_spanned_pages(nid);\r\nreturn CONSTRAINT_CPUSET;\r\n}\r\nreturn CONSTRAINT_NONE;\r\n}\r\nstatic enum oom_constraint constrained_alloc(struct zonelist *zonelist,\r\ngfp_t gfp_mask, nodemask_t *nodemask,\r\nunsigned long *totalpages)\r\n{\r\n*totalpages = totalram_pages + total_swap_pages;\r\nreturn CONSTRAINT_NONE;\r\n}\r\nenum oom_scan_t oom_scan_process_thread(struct task_struct *task,\r\nunsigned long totalpages, const nodemask_t *nodemask,\r\nbool force_kill)\r\n{\r\nif (task->exit_state)\r\nreturn OOM_SCAN_CONTINUE;\r\nif (oom_unkillable_task(task, NULL, nodemask))\r\nreturn OOM_SCAN_CONTINUE;\r\nif (test_tsk_thread_flag(task, TIF_MEMDIE)) {\r\nif (unlikely(frozen(task)))\r\n__thaw_task(task);\r\nif (!force_kill)\r\nreturn OOM_SCAN_ABORT;\r\n}\r\nif (!task->mm)\r\nreturn OOM_SCAN_CONTINUE;\r\nif (oom_task_origin(task))\r\nreturn OOM_SCAN_SELECT;\r\nif (task->flags & PF_EXITING && !force_kill) {\r\nif (!(task->group_leader->ptrace & PT_TRACE_EXIT))\r\nreturn OOM_SCAN_ABORT;\r\n}\r\nreturn OOM_SCAN_OK;\r\n}\r\nstatic struct task_struct *select_bad_process(unsigned int *ppoints,\r\nunsigned long totalpages, const nodemask_t *nodemask,\r\nbool force_kill)\r\n{\r\nstruct task_struct *g, *p;\r\nstruct task_struct *chosen = NULL;\r\nunsigned long chosen_points = 0;\r\nrcu_read_lock();\r\ndo_each_thread(g, p) {\r\nunsigned int points;\r\nswitch (oom_scan_process_thread(p, totalpages, nodemask,\r\nforce_kill)) {\r\ncase OOM_SCAN_SELECT:\r\nchosen = p;\r\nchosen_points = ULONG_MAX;\r\ncase OOM_SCAN_CONTINUE:\r\ncontinue;\r\ncase OOM_SCAN_ABORT:\r\nrcu_read_unlock();\r\nreturn ERR_PTR(-1UL);\r\ncase OOM_SCAN_OK:\r\nbreak;\r\n};\r\npoints = oom_badness(p, NULL, nodemask, totalpages);\r\nif (points > chosen_points) {\r\nchosen = p;\r\nchosen_points = points;\r\n}\r\n} while_each_thread(g, p);\r\nif (chosen)\r\nget_task_struct(chosen);\r\nrcu_read_unlock();\r\n*ppoints = chosen_points * 1000 / totalpages;\r\nreturn chosen;\r\n}\r\nstatic void dump_tasks(const struct mem_cgroup *memcg, const nodemask_t *nodemask)\r\n{\r\nstruct task_struct *p;\r\nstruct task_struct *task;\r\npr_info("[ pid ] uid tgid total_vm rss nr_ptes swapents oom_score_adj name\n");\r\nrcu_read_lock();\r\nfor_each_process(p) {\r\nif (oom_unkillable_task(p, memcg, nodemask))\r\ncontinue;\r\ntask = find_lock_task_mm(p);\r\nif (!task) {\r\ncontinue;\r\n}\r\npr_info("[%5d] %5d %5d %8lu %8lu %7lu %8lu %5hd %s\n",\r\ntask->pid, from_kuid(&init_user_ns, task_uid(task)),\r\ntask->tgid, task->mm->total_vm, get_mm_rss(task->mm),\r\ntask->mm->nr_ptes,\r\nget_mm_counter(task->mm, MM_SWAPENTS),\r\ntask->signal->oom_score_adj, task->comm);\r\ntask_unlock(task);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void dump_header(struct task_struct *p, gfp_t gfp_mask, int order,\r\nstruct mem_cgroup *memcg, const nodemask_t *nodemask)\r\n{\r\ntask_lock(current);\r\npr_warning("%s invoked oom-killer: gfp_mask=0x%x, order=%d, "\r\n"oom_score_adj=%hd\n",\r\ncurrent->comm, gfp_mask, order,\r\ncurrent->signal->oom_score_adj);\r\ncpuset_print_task_mems_allowed(current);\r\ntask_unlock(current);\r\ndump_stack();\r\nif (memcg)\r\nmem_cgroup_print_oom_info(memcg, p);\r\nelse\r\nshow_mem(SHOW_MEM_FILTER_NODES);\r\nif (sysctl_oom_dump_tasks)\r\ndump_tasks(memcg, nodemask);\r\n}\r\nvoid oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,\r\nunsigned int points, unsigned long totalpages,\r\nstruct mem_cgroup *memcg, nodemask_t *nodemask,\r\nconst char *message)\r\n{\r\nstruct task_struct *victim = p;\r\nstruct task_struct *child;\r\nstruct task_struct *t = p;\r\nstruct mm_struct *mm;\r\nunsigned int victim_points = 0;\r\nstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,\r\nDEFAULT_RATELIMIT_BURST);\r\nif (p->flags & PF_EXITING) {\r\nset_tsk_thread_flag(p, TIF_MEMDIE);\r\nput_task_struct(p);\r\nreturn;\r\n}\r\nif (__ratelimit(&oom_rs))\r\ndump_header(p, gfp_mask, order, memcg, nodemask);\r\ntask_lock(p);\r\npr_err("%s: Kill process %d (%s) score %d or sacrifice child\n",\r\nmessage, task_pid_nr(p), p->comm, points);\r\ntask_unlock(p);\r\nread_lock(&tasklist_lock);\r\ndo {\r\nlist_for_each_entry(child, &t->children, sibling) {\r\nunsigned int child_points;\r\nif (child->mm == p->mm)\r\ncontinue;\r\nchild_points = oom_badness(child, memcg, nodemask,\r\ntotalpages);\r\nif (child_points > victim_points) {\r\nput_task_struct(victim);\r\nvictim = child;\r\nvictim_points = child_points;\r\nget_task_struct(victim);\r\n}\r\n}\r\n} while_each_thread(p, t);\r\nint register_oom_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&oom_notify_list, nb);\r\n}\r\nint unregister_oom_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&oom_notify_list, nb);\r\n}\r\nint try_set_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)\r\n{\r\nstruct zoneref *z;\r\nstruct zone *zone;\r\nint ret = 1;\r\nspin_lock(&zone_scan_lock);\r\nfor_each_zone_zonelist(zone, z, zonelist, gfp_zone(gfp_mask)) {\r\nif (zone_is_oom_locked(zone)) {\r\nret = 0;\r\ngoto out;\r\n}\r\n}\r\nfor_each_zone_zonelist(zone, z, zonelist, gfp_zone(gfp_mask)) {\r\nzone_set_flag(zone, ZONE_OOM_LOCKED);\r\n}\r\nout:\r\nspin_unlock(&zone_scan_lock);\r\nreturn ret;\r\n}\r\nvoid clear_zonelist_oom(struct zonelist *zonelist, gfp_t gfp_mask)\r\n{\r\nstruct zoneref *z;\r\nstruct zone *zone;\r\nspin_lock(&zone_scan_lock);\r\nfor_each_zone_zonelist(zone, z, zonelist, gfp_zone(gfp_mask)) {\r\nzone_clear_flag(zone, ZONE_OOM_LOCKED);\r\n}\r\nspin_unlock(&zone_scan_lock);\r\n}\r\nvoid out_of_memory(struct zonelist *zonelist, gfp_t gfp_mask,\r\nint order, nodemask_t *nodemask, bool force_kill)\r\n{\r\nconst nodemask_t *mpol_mask;\r\nstruct task_struct *p;\r\nunsigned long totalpages;\r\nunsigned long freed = 0;\r\nunsigned int uninitialized_var(points);\r\nenum oom_constraint constraint = CONSTRAINT_NONE;\r\nint killed = 0;\r\nblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\r\nif (freed > 0)\r\nreturn;\r\nif (fatal_signal_pending(current) || current->flags & PF_EXITING) {\r\nset_thread_flag(TIF_MEMDIE);\r\nreturn;\r\n}\r\nconstraint = constrained_alloc(zonelist, gfp_mask, nodemask,\r\n&totalpages);\r\nmpol_mask = (constraint == CONSTRAINT_MEMORY_POLICY) ? nodemask : NULL;\r\ncheck_panic_on_oom(constraint, gfp_mask, order, mpol_mask);\r\nif (sysctl_oom_kill_allocating_task && current->mm &&\r\n!oom_unkillable_task(current, NULL, nodemask) &&\r\ncurrent->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\r\nget_task_struct(current);\r\noom_kill_process(current, gfp_mask, order, 0, totalpages, NULL,\r\nnodemask,\r\n"Out of memory (oom_kill_allocating_task)");\r\ngoto out;\r\n}\r\np = select_bad_process(&points, totalpages, mpol_mask, force_kill);\r\nif (!p) {\r\ndump_header(NULL, gfp_mask, order, NULL, mpol_mask);\r\npanic("Out of memory and no killable processes...\n");\r\n}\r\nif (PTR_ERR(p) != -1UL) {\r\noom_kill_process(p, gfp_mask, order, points, totalpages, NULL,\r\nnodemask, "Out of memory");\r\nkilled = 1;\r\n}\r\nout:\r\nif (killed)\r\nschedule_timeout_killable(1);\r\n}\r\nvoid pagefault_out_of_memory(void)\r\n{\r\nstruct zonelist *zonelist = node_zonelist(first_online_node,\r\nGFP_KERNEL);\r\nif (try_set_zonelist_oom(zonelist, GFP_KERNEL)) {\r\nout_of_memory(NULL, 0, 0, NULL, false);\r\nclear_zonelist_oom(zonelist, GFP_KERNEL);\r\n}\r\n}
