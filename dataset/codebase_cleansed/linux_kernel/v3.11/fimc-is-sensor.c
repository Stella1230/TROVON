static const struct v4l2_mbus_framefmt *find_sensor_format(\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fimc_is_sensor_formats); i++)\r\nif (mf->code == fimc_is_sensor_formats[i].code)\r\nreturn &fimc_is_sensor_formats[i];\r\nreturn &fimc_is_sensor_formats[0];\r\n}\r\nstatic int fimc_is_sensor_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(fimc_is_sensor_formats))\r\nreturn -EINVAL;\r\ncode->code = fimc_is_sensor_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic void fimc_is_sensor_try_format(struct fimc_is_sensor *sensor,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nconst struct sensor_drv_data *dd = sensor->drvdata;\r\nconst struct v4l2_mbus_framefmt *fmt;\r\nfmt = find_sensor_format(mf);\r\nmf->code = fmt->code;\r\nv4l_bound_align_image(&mf->width, 16 + 8, dd->width, 0,\r\n&mf->height, 12 + 8, dd->height, 0, 0);\r\n}\r\nstatic struct v4l2_mbus_framefmt *__fimc_is_sensor_get_format(\r\nstruct fimc_is_sensor *sensor, struct v4l2_subdev_fh *fh,\r\nu32 pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn fh ? v4l2_subdev_get_try_format(fh, pad) : NULL;\r\nreturn &sensor->format;\r\n}\r\nstatic int fimc_is_sensor_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct fimc_is_sensor *sensor = sd_to_fimc_is_sensor(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nfimc_is_sensor_try_format(sensor, &fmt->format);\r\nmf = __fimc_is_sensor_get_format(sensor, fh, fmt->pad, fmt->which);\r\nif (mf) {\r\nmutex_lock(&sensor->lock);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\n*mf = fmt->format;\r\nmutex_unlock(&sensor->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_is_sensor_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct fimc_is_sensor *sensor = sd_to_fimc_is_sensor(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = __fimc_is_sensor_get_format(sensor, fh, fmt->pad, fmt->which);\r\nmutex_lock(&sensor->lock);\r\nfmt->format = *mf;\r\nmutex_unlock(&sensor->lock);\r\nreturn 0;\r\n}\r\nstatic int fimc_is_sensor_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *format = v4l2_subdev_get_try_format(fh, 0);\r\n*format = fimc_is_sensor_formats[0];\r\nformat->width = FIMC_IS_SENSOR_DEF_PIX_WIDTH;\r\nformat->height = FIMC_IS_SENSOR_DEF_PIX_HEIGHT;\r\nreturn 0;\r\n}\r\nstatic int fimc_is_sensor_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct fimc_is_sensor *sensor = sd_to_fimc_is_sensor(sd);\r\nint gpio = sensor->gpio_reset;\r\nint ret;\r\nif (on) {\r\nret = pm_runtime_get(sensor->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regulator_bulk_enable(SENSOR_NUM_SUPPLIES,\r\nsensor->supplies);\r\nif (ret < 0) {\r\npm_runtime_put(sensor->dev);\r\nreturn ret;\r\n}\r\nif (gpio_is_valid(gpio)) {\r\ngpio_set_value(gpio, 1);\r\nusleep_range(600, 800);\r\ngpio_set_value(gpio, 0);\r\nusleep_range(10000, 11000);\r\ngpio_set_value(gpio, 1);\r\n}\r\nmsleep(20);\r\n} else {\r\nif (gpio_is_valid(gpio))\r\ngpio_set_value(gpio, 0);\r\nret = regulator_bulk_disable(SENSOR_NUM_SUPPLIES,\r\nsensor->supplies);\r\nif (!ret)\r\npm_runtime_put(sensor->dev);\r\n}\r\npr_info("%s:%d: on: %d, ret: %d\n", __func__, __LINE__, on, ret);\r\nreturn ret;\r\n}\r\nstatic int fimc_is_sensor_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct fimc_is_sensor *sensor;\r\nconst struct of_device_id *of_id;\r\nstruct v4l2_subdev *sd;\r\nint gpio, i, ret;\r\nsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\r\nif (!sensor)\r\nreturn -ENOMEM;\r\nmutex_init(&sensor->lock);\r\nsensor->gpio_reset = -EINVAL;\r\ngpio = of_get_gpio_flags(dev->of_node, 0, NULL);\r\nif (gpio_is_valid(gpio)) {\r\nret = devm_gpio_request_one(dev, gpio, GPIOF_OUT_INIT_LOW,\r\nDRIVER_NAME);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nsensor->gpio_reset = gpio;\r\nfor (i = 0; i < SENSOR_NUM_SUPPLIES; i++)\r\nsensor->supplies[i].supply = sensor_supply_names[i];\r\nret = devm_regulator_bulk_get(&client->dev, SENSOR_NUM_SUPPLIES,\r\nsensor->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\nof_id = of_match_node(fimc_is_sensor_of_match, dev->of_node);\r\nif (!of_id)\r\nreturn -ENODEV;\r\nsensor->drvdata = of_id->data;\r\nsensor->dev = dev;\r\nsd = &sensor->subdev;\r\nv4l2_i2c_subdev_init(sd, client, &fimc_is_sensor_subdev_ops);\r\nsnprintf(sd->name, sizeof(sd->name), sensor->drvdata->subdev_name);\r\nsensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsensor->format.code = fimc_is_sensor_formats[0].code;\r\nsensor->format.width = FIMC_IS_SENSOR_DEF_PIX_WIDTH;\r\nsensor->format.height = FIMC_IS_SENSOR_DEF_PIX_HEIGHT;\r\nsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&sd->entity, 1, &sensor->pad, 0);\r\nif (ret < 0)\r\nreturn ret;\r\npm_runtime_no_callbacks(dev);\r\npm_runtime_enable(dev);\r\nreturn ret;\r\n}\r\nstatic int fimc_is_sensor_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn 0;\r\n}\r\nint fimc_is_register_sensor_driver(void)\r\n{\r\nreturn i2c_add_driver(&fimc_is_sensor_driver);\r\n}\r\nvoid fimc_is_unregister_sensor_driver(void)\r\n{\r\ni2c_del_driver(&fimc_is_sensor_driver);\r\n}
