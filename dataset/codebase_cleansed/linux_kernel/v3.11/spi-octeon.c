static void octeon_spi_wait_ready(struct octeon_spi *p)\r\n{\r\nunion cvmx_mpi_sts mpi_sts;\r\nunsigned int loops = 0;\r\ndo {\r\nif (loops++)\r\n__delay(500);\r\nmpi_sts.u64 = cvmx_read_csr(p->register_base + OCTEON_SPI_STS);\r\n} while (mpi_sts.s.busy);\r\n}\r\nstatic int octeon_spi_do_transfer(struct octeon_spi *p,\r\nstruct spi_message *msg,\r\nstruct spi_transfer *xfer,\r\nbool last_xfer)\r\n{\r\nunion cvmx_mpi_cfg mpi_cfg;\r\nunion cvmx_mpi_tx mpi_tx;\r\nunsigned int clkdiv;\r\nunsigned int speed_hz;\r\nint mode;\r\nbool cpha, cpol;\r\nint bits_per_word;\r\nconst u8 *tx_buf;\r\nu8 *rx_buf;\r\nint len;\r\nint i;\r\nstruct octeon_spi_setup *msg_setup = spi_get_ctldata(msg->spi);\r\nspeed_hz = msg_setup->max_speed_hz;\r\nmode = msg_setup->mode;\r\ncpha = mode & SPI_CPHA;\r\ncpol = mode & SPI_CPOL;\r\nbits_per_word = msg_setup->bits_per_word;\r\nif (xfer->speed_hz)\r\nspeed_hz = xfer->speed_hz;\r\nif (xfer->bits_per_word)\r\nbits_per_word = xfer->bits_per_word;\r\nif (speed_hz > OCTEON_SPI_MAX_CLOCK_HZ)\r\nspeed_hz = OCTEON_SPI_MAX_CLOCK_HZ;\r\nclkdiv = octeon_get_io_clock_rate() / (2 * speed_hz);\r\nmpi_cfg.u64 = 0;\r\nmpi_cfg.s.clkdiv = clkdiv;\r\nmpi_cfg.s.cshi = (mode & SPI_CS_HIGH) ? 1 : 0;\r\nmpi_cfg.s.lsbfirst = (mode & SPI_LSB_FIRST) ? 1 : 0;\r\nmpi_cfg.s.wireor = (mode & SPI_3WIRE) ? 1 : 0;\r\nmpi_cfg.s.idlelo = cpha != cpol;\r\nmpi_cfg.s.cslate = cpha ? 1 : 0;\r\nmpi_cfg.s.enable = 1;\r\nif (msg_setup->chip_select < 4)\r\np->cs_enax |= 1ull << (12 + msg_setup->chip_select);\r\nmpi_cfg.u64 |= p->cs_enax;\r\nif (mpi_cfg.u64 != p->last_cfg) {\r\np->last_cfg = mpi_cfg.u64;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_CFG, mpi_cfg.u64);\r\n}\r\ntx_buf = xfer->tx_buf;\r\nrx_buf = xfer->rx_buf;\r\nlen = xfer->len;\r\nwhile (len > OCTEON_SPI_MAX_BYTES) {\r\nfor (i = 0; i < OCTEON_SPI_MAX_BYTES; i++) {\r\nu8 d;\r\nif (tx_buf)\r\nd = *tx_buf++;\r\nelse\r\nd = 0;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i), d);\r\n}\r\nmpi_tx.u64 = 0;\r\nmpi_tx.s.csid = msg_setup->chip_select;\r\nmpi_tx.s.leavecs = 1;\r\nmpi_tx.s.txnum = tx_buf ? OCTEON_SPI_MAX_BYTES : 0;\r\nmpi_tx.s.totnum = OCTEON_SPI_MAX_BYTES;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_TX, mpi_tx.u64);\r\nocteon_spi_wait_ready(p);\r\nif (rx_buf)\r\nfor (i = 0; i < OCTEON_SPI_MAX_BYTES; i++) {\r\nu64 v = cvmx_read_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i));\r\n*rx_buf++ = (u8)v;\r\n}\r\nlen -= OCTEON_SPI_MAX_BYTES;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nu8 d;\r\nif (tx_buf)\r\nd = *tx_buf++;\r\nelse\r\nd = 0;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i), d);\r\n}\r\nmpi_tx.u64 = 0;\r\nmpi_tx.s.csid = msg_setup->chip_select;\r\nif (last_xfer)\r\nmpi_tx.s.leavecs = xfer->cs_change;\r\nelse\r\nmpi_tx.s.leavecs = !xfer->cs_change;\r\nmpi_tx.s.txnum = tx_buf ? len : 0;\r\nmpi_tx.s.totnum = len;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_TX, mpi_tx.u64);\r\nocteon_spi_wait_ready(p);\r\nif (rx_buf)\r\nfor (i = 0; i < len; i++) {\r\nu64 v = cvmx_read_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i));\r\n*rx_buf++ = (u8)v;\r\n}\r\nif (xfer->delay_usecs)\r\nudelay(xfer->delay_usecs);\r\nreturn xfer->len;\r\n}\r\nstatic int octeon_spi_validate_bpw(struct spi_device *spi, u32 speed)\r\n{\r\nswitch (speed) {\r\ncase 8:\r\nbreak;\r\ndefault:\r\ndev_err(&spi->dev, "Error: %d bits per word not supported\n",\r\nspeed);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct octeon_spi *p = spi_master_get_devdata(master);\r\nunsigned int total_len = 0;\r\nint status = 0;\r\nstruct spi_transfer *xfer;\r\nif (spi_get_ctldata(msg->spi) == NULL) {\r\nstatus = -EINVAL;\r\ngoto err;\r\n}\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nif (xfer->bits_per_word) {\r\nstatus = octeon_spi_validate_bpw(msg->spi,\r\nxfer->bits_per_word);\r\nif (status)\r\ngoto err;\r\n}\r\n}\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nbool last_xfer = &xfer->transfer_list == msg->transfers.prev;\r\nint r = octeon_spi_do_transfer(p, msg, xfer, last_xfer);\r\nif (r < 0) {\r\nstatus = r;\r\ngoto err;\r\n}\r\ntotal_len += r;\r\n}\r\nerr:\r\nmsg->status = status;\r\nmsg->actual_length = total_len;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic struct octeon_spi_setup *octeon_spi_new_setup(struct spi_device *spi)\r\n{\r\nstruct octeon_spi_setup *setup = kzalloc(sizeof(*setup), GFP_KERNEL);\r\nif (!setup)\r\nreturn NULL;\r\nsetup->max_speed_hz = spi->max_speed_hz;\r\nsetup->chip_select = spi->chip_select;\r\nsetup->mode = spi->mode;\r\nsetup->bits_per_word = spi->bits_per_word;\r\nreturn setup;\r\n}\r\nstatic int octeon_spi_setup(struct spi_device *spi)\r\n{\r\nint r;\r\nstruct octeon_spi_setup *new_setup;\r\nstruct octeon_spi_setup *old_setup = spi_get_ctldata(spi);\r\nr = octeon_spi_validate_bpw(spi, spi->bits_per_word);\r\nif (r)\r\nreturn r;\r\nnew_setup = octeon_spi_new_setup(spi);\r\nif (!new_setup)\r\nreturn -ENOMEM;\r\nspi_set_ctldata(spi, new_setup);\r\nkfree(old_setup);\r\nreturn 0;\r\n}\r\nstatic void octeon_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct octeon_spi_setup *old_setup = spi_get_ctldata(spi);\r\nspi_set_ctldata(spi, NULL);\r\nkfree(old_setup);\r\n}\r\nstatic int octeon_spi_nop_transfer_hardware(struct spi_master *master)\r\n{\r\nreturn 0;\r\n}\r\nstatic int octeon_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_mem;\r\nstruct spi_master *master;\r\nstruct octeon_spi *p;\r\nint err = -ENOENT;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct octeon_spi));\r\nif (!master)\r\nreturn -ENOMEM;\r\np = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, p);\r\np->my_master = master;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res_mem == NULL) {\r\ndev_err(&pdev->dev, "found no memory resource\n");\r\nerr = -ENXIO;\r\ngoto fail;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev, res_mem->start,\r\nresource_size(res_mem), res_mem->name)) {\r\ndev_err(&pdev->dev, "request_mem_region failed\n");\r\ngoto fail;\r\n}\r\np->register_base = (u64)devm_ioremap(&pdev->dev, res_mem->start,\r\nresource_size(res_mem));\r\nmaster->bus_num = -1;\r\nmaster->num_chipselect = 4;\r\nmaster->mode_bits = SPI_CPHA |\r\nSPI_CPOL |\r\nSPI_CS_HIGH |\r\nSPI_LSB_FIRST |\r\nSPI_3WIRE;\r\nmaster->setup = octeon_spi_setup;\r\nmaster->cleanup = octeon_spi_cleanup;\r\nmaster->prepare_transfer_hardware = octeon_spi_nop_transfer_hardware;\r\nmaster->transfer_one_message = octeon_spi_transfer_one_message;\r\nmaster->unprepare_transfer_hardware = octeon_spi_nop_transfer_hardware;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nerr = spi_register_master(master);\r\nif (err) {\r\ndev_err(&pdev->dev, "register master failed: %d\n", err);\r\ngoto fail;\r\n}\r\ndev_info(&pdev->dev, "OCTEON SPI bus driver\n");\r\nreturn 0;\r\nfail:\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nstatic int octeon_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct octeon_spi *p = platform_get_drvdata(pdev);\r\nu64 register_base = p->register_base;\r\nspi_unregister_master(p->my_master);\r\ncvmx_write_csr(register_base + OCTEON_SPI_CFG, 0);\r\nreturn 0;\r\n}
