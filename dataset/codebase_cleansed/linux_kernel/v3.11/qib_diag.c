static struct qib_diag_client *get_client(struct qib_devdata *dd)\r\n{\r\nstruct qib_diag_client *dc;\r\ndc = client_pool;\r\nif (dc)\r\nclient_pool = dc->next;\r\nelse\r\ndc = kmalloc(sizeof *dc, GFP_KERNEL);\r\nif (dc) {\r\ndc->next = NULL;\r\ndc->dd = dd;\r\ndc->pid = current->pid;\r\ndc->state = OPENED;\r\n}\r\nreturn dc;\r\n}\r\nstatic void return_client(struct qib_diag_client *dc)\r\n{\r\nstruct qib_devdata *dd = dc->dd;\r\nstruct qib_diag_client *tdc, *rdc;\r\nrdc = NULL;\r\nif (dc == dd->diag_client) {\r\ndd->diag_client = dc->next;\r\nrdc = dc;\r\n} else {\r\ntdc = dc->dd->diag_client;\r\nwhile (tdc) {\r\nif (dc == tdc->next) {\r\ntdc->next = dc->next;\r\nrdc = dc;\r\nbreak;\r\n}\r\ntdc = tdc->next;\r\n}\r\n}\r\nif (rdc) {\r\nrdc->state = UNUSED;\r\nrdc->dd = NULL;\r\nrdc->pid = 0;\r\nrdc->next = client_pool;\r\nclient_pool = rdc;\r\n}\r\n}\r\nint qib_diag_add(struct qib_devdata *dd)\r\n{\r\nchar name[16];\r\nint ret = 0;\r\nif (atomic_inc_return(&diagpkt_count) == 1) {\r\nret = qib_cdev_init(QIB_DIAGPKT_MINOR, "ipath_diagpkt",\r\n&diagpkt_file_ops, &diagpkt_cdev,\r\n&diagpkt_device);\r\nif (ret)\r\ngoto done;\r\n}\r\nsnprintf(name, sizeof(name), "ipath_diag%d", dd->unit);\r\nret = qib_cdev_init(QIB_DIAG_MINOR_BASE + dd->unit, name,\r\n&diag_file_ops, &dd->diag_cdev,\r\n&dd->diag_device);\r\ndone:\r\nreturn ret;\r\n}\r\nvoid qib_diag_remove(struct qib_devdata *dd)\r\n{\r\nstruct qib_diag_client *dc;\r\nif (atomic_dec_and_test(&diagpkt_count))\r\nqib_cdev_cleanup(&diagpkt_cdev, &diagpkt_device);\r\nqib_cdev_cleanup(&dd->diag_cdev, &dd->diag_device);\r\nwhile (dd->diag_client)\r\nreturn_client(dd->diag_client);\r\nwhile (client_pool) {\r\ndc = client_pool;\r\nclient_pool = dc->next;\r\nkfree(dc);\r\n}\r\nqib_unregister_observers(dd);\r\n}\r\nstatic u32 __iomem *qib_remap_ioaddr32(struct qib_devdata *dd, u32 offset,\r\nu32 *cntp)\r\n{\r\nu32 kreglen;\r\nu32 snd_bottom, snd_lim = 0;\r\nu32 __iomem *krb32 = (u32 __iomem *)dd->kregbase;\r\nu32 __iomem *map = NULL;\r\nu32 cnt = 0;\r\nu32 tot4k, offs4k;\r\nkreglen = (dd->kregend - dd->kregbase) * sizeof(u64);\r\nif (offset < kreglen) {\r\nmap = krb32 + (offset / sizeof(u32));\r\ncnt = kreglen - offset;\r\ngoto mapped;\r\n}\r\nif (dd->userbase) {\r\nu32 ulim = (dd->cfgctxts * dd->ureg_align) + dd->uregbase;\r\nif (!dd->piovl15base)\r\nsnd_lim = dd->uregbase;\r\nkrb32 = (u32 __iomem *)dd->userbase;\r\nif (offset >= dd->uregbase && offset < ulim) {\r\nmap = krb32 + (offset - dd->uregbase) / sizeof(u32);\r\ncnt = ulim - offset;\r\ngoto mapped;\r\n}\r\n}\r\nsnd_bottom = dd->pio2k_bufbase;\r\nif (snd_lim == 0) {\r\nu32 tot2k = dd->piobcnt2k * ALIGN(dd->piosize2k, dd->palign);\r\nsnd_lim = snd_bottom + tot2k;\r\n}\r\ntot4k = dd->piobcnt4k * dd->align4k;\r\noffs4k = dd->piobufbase >> 32;\r\nif (dd->piobcnt4k) {\r\nif (snd_bottom > offs4k)\r\nsnd_bottom = offs4k;\r\nelse {\r\nif (!dd->userbase || dd->piovl15base)\r\nsnd_lim = offs4k + tot4k;\r\n}\r\n}\r\nif (offset >= snd_bottom && offset < snd_lim) {\r\noffset -= snd_bottom;\r\nmap = (u32 __iomem *)dd->piobase + (offset / sizeof(u32));\r\ncnt = snd_lim - offset;\r\n}\r\nif (!map && offs4k && dd->piovl15base) {\r\nsnd_lim = offs4k + tot4k + 2 * dd->align4k;\r\nif (offset >= (offs4k + tot4k) && offset < snd_lim) {\r\nmap = (u32 __iomem *)dd->piovl15base +\r\n((offset - (offs4k + tot4k)) / sizeof(u32));\r\ncnt = snd_lim - offset;\r\n}\r\n}\r\nmapped:\r\nif (cntp)\r\n*cntp = cnt;\r\nreturn map;\r\n}\r\nstatic int qib_read_umem64(struct qib_devdata *dd, void __user *uaddr,\r\nu32 regoffs, size_t count)\r\n{\r\nconst u64 __iomem *reg_addr;\r\nconst u64 __iomem *reg_end;\r\nu32 limit;\r\nint ret;\r\nreg_addr = (const u64 __iomem *)qib_remap_ioaddr32(dd, regoffs, &limit);\r\nif (reg_addr == NULL || limit == 0 || !(dd->flags & QIB_PRESENT)) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (count >= limit)\r\ncount = limit;\r\nreg_end = reg_addr + (count / sizeof(u64));\r\nwhile (reg_addr < reg_end) {\r\nu64 data = readq(reg_addr);\r\nif (copy_to_user(uaddr, &data, sizeof(u64))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nreg_addr++;\r\nuaddr += sizeof(u64);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int qib_write_umem64(struct qib_devdata *dd, u32 regoffs,\r\nconst void __user *uaddr, size_t count)\r\n{\r\nu64 __iomem *reg_addr;\r\nconst u64 __iomem *reg_end;\r\nu32 limit;\r\nint ret;\r\nreg_addr = (u64 __iomem *)qib_remap_ioaddr32(dd, regoffs, &limit);\r\nif (reg_addr == NULL || limit == 0 || !(dd->flags & QIB_PRESENT)) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (count >= limit)\r\ncount = limit;\r\nreg_end = reg_addr + (count / sizeof(u64));\r\nwhile (reg_addr < reg_end) {\r\nu64 data;\r\nif (copy_from_user(&data, uaddr, sizeof(data))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nwriteq(data, reg_addr);\r\nreg_addr++;\r\nuaddr += sizeof(u64);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int qib_read_umem32(struct qib_devdata *dd, void __user *uaddr,\r\nu32 regoffs, size_t count)\r\n{\r\nconst u32 __iomem *reg_addr;\r\nconst u32 __iomem *reg_end;\r\nu32 limit;\r\nint ret;\r\nreg_addr = qib_remap_ioaddr32(dd, regoffs, &limit);\r\nif (reg_addr == NULL || limit == 0 || !(dd->flags & QIB_PRESENT)) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (count >= limit)\r\ncount = limit;\r\nreg_end = reg_addr + (count / sizeof(u32));\r\nwhile (reg_addr < reg_end) {\r\nu32 data = readl(reg_addr);\r\nif (copy_to_user(uaddr, &data, sizeof(data))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nreg_addr++;\r\nuaddr += sizeof(u32);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int qib_write_umem32(struct qib_devdata *dd, u32 regoffs,\r\nconst void __user *uaddr, size_t count)\r\n{\r\nu32 __iomem *reg_addr;\r\nconst u32 __iomem *reg_end;\r\nu32 limit;\r\nint ret;\r\nreg_addr = qib_remap_ioaddr32(dd, regoffs, &limit);\r\nif (reg_addr == NULL || limit == 0 || !(dd->flags & QIB_PRESENT)) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (count >= limit)\r\ncount = limit;\r\nreg_end = reg_addr + (count / sizeof(u32));\r\nwhile (reg_addr < reg_end) {\r\nu32 data;\r\nif (copy_from_user(&data, uaddr, sizeof(data))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nwritel(data, reg_addr);\r\nreg_addr++;\r\nuaddr += sizeof(u32);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int qib_diag_open(struct inode *in, struct file *fp)\r\n{\r\nint unit = iminor(in) - QIB_DIAG_MINOR_BASE;\r\nstruct qib_devdata *dd;\r\nstruct qib_diag_client *dc;\r\nint ret;\r\nmutex_lock(&qib_mutex);\r\ndd = qib_lookup(unit);\r\nif (dd == NULL || !(dd->flags & QIB_PRESENT) ||\r\n!dd->kregbase) {\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\ndc = get_client(dd);\r\nif (!dc) {\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\ndc->next = dd->diag_client;\r\ndd->diag_client = dc;\r\nfp->private_data = dc;\r\nret = 0;\r\nbail:\r\nmutex_unlock(&qib_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t qib_diagpkt_write(struct file *fp,\r\nconst char __user *data,\r\nsize_t count, loff_t *off)\r\n{\r\nu32 __iomem *piobuf;\r\nu32 plen, clen, pbufn;\r\nstruct qib_diag_xpkt dp;\r\nu32 *tmpbuf = NULL;\r\nstruct qib_devdata *dd;\r\nstruct qib_pportdata *ppd;\r\nssize_t ret = 0;\r\nif (count != sizeof(dp)) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (copy_from_user(&dp, data, sizeof(dp))) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\ndd = qib_lookup(dp.unit);\r\nif (!dd || !(dd->flags & QIB_PRESENT) || !dd->kregbase) {\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nif (!(dd->flags & QIB_INITTED)) {\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nif (dp.version != _DIAG_XPKT_VERS) {\r\nqib_dev_err(dd, "Invalid version %u for diagpkt_write\n",\r\ndp.version);\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (dp.len & 3) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (!dp.port || dp.port > dd->num_pports) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nppd = &dd->pport[dp.port - 1];\r\nplen = sizeof(u32) + dp.len;\r\nclen = dp.len >> 2;\r\nif ((plen + 4) > ppd->ibmaxlen) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\ntmpbuf = vmalloc(plen);\r\nif (!tmpbuf) {\r\nqib_devinfo(dd->pcidev,\r\n"Unable to allocate tmp buffer, failing\n");\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\nif (copy_from_user(tmpbuf,\r\n(const void __user *) (unsigned long) dp.data,\r\ndp.len)) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nplen >>= 2;\r\nif (dp.pbc_wd == 0)\r\ndp.pbc_wd = plen;\r\npiobuf = dd->f_getsendbuf(ppd, dp.pbc_wd, &pbufn);\r\nif (!piobuf) {\r\nret = -EBUSY;\r\ngoto bail;\r\n}\r\ndd->f_sendctrl(dd->pport, QIB_SENDCTRL_DISARM_BUF(pbufn));\r\ndd->f_txchk_change(dd, pbufn, 1, TXCHK_CHG_TYPE_DIS1, NULL);\r\nwriteq(dp.pbc_wd, piobuf);\r\nif (dd->flags & QIB_PIO_FLUSH_WC) {\r\nqib_flush_wc();\r\nqib_pio_copy(piobuf + 2, tmpbuf, clen - 1);\r\nqib_flush_wc();\r\n__raw_writel(tmpbuf[clen - 1], piobuf + clen + 1);\r\n} else\r\nqib_pio_copy(piobuf + 2, tmpbuf, clen);\r\nif (dd->flags & QIB_USE_SPCL_TRIG) {\r\nu32 spcl_off = (pbufn >= dd->piobcnt2k) ? 2047 : 1023;\r\nqib_flush_wc();\r\n__raw_writel(0xaebecede, piobuf + spcl_off);\r\n}\r\nqib_flush_wc();\r\nqib_sendbuf_done(dd, pbufn);\r\ndd->f_txchk_change(dd, pbufn, 1, TXCHK_CHG_TYPE_ENAB1, NULL);\r\nret = sizeof(dp);\r\nbail:\r\nvfree(tmpbuf);\r\nreturn ret;\r\n}\r\nstatic int qib_diag_release(struct inode *in, struct file *fp)\r\n{\r\nmutex_lock(&qib_mutex);\r\nreturn_client(fp->private_data);\r\nfp->private_data = NULL;\r\nmutex_unlock(&qib_mutex);\r\nreturn 0;\r\n}\r\nint qib_register_observer(struct qib_devdata *dd,\r\nconst struct diag_observer *op)\r\n{\r\nstruct diag_observer_list_elt *olp;\r\nint ret = -EINVAL;\r\nif (!dd || !op)\r\ngoto bail;\r\nret = -ENOMEM;\r\nolp = vmalloc(sizeof *olp);\r\nif (!olp) {\r\npr_err("vmalloc for observer failed\n");\r\ngoto bail;\r\n}\r\nif (olp) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\r\nolp->op = op;\r\nolp->next = dd->diag_observer_list;\r\ndd->diag_observer_list = olp;\r\nspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\r\nret = 0;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void qib_unregister_observers(struct qib_devdata *dd)\r\n{\r\nstruct diag_observer_list_elt *olp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\r\nolp = dd->diag_observer_list;\r\nwhile (olp) {\r\ndd->diag_observer_list = olp->next;\r\nspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\r\nvfree(olp);\r\nspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\r\nolp = dd->diag_observer_list;\r\n}\r\nspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\r\n}\r\nstatic const struct diag_observer *diag_get_observer(struct qib_devdata *dd,\r\nu32 addr)\r\n{\r\nstruct diag_observer_list_elt *olp;\r\nconst struct diag_observer *op = NULL;\r\nolp = dd->diag_observer_list;\r\nwhile (olp) {\r\nop = olp->op;\r\nif (addr >= op->bottom && addr <= op->top)\r\nbreak;\r\nolp = olp->next;\r\n}\r\nif (!olp)\r\nop = NULL;\r\nreturn op;\r\n}\r\nstatic ssize_t qib_diag_read(struct file *fp, char __user *data,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct qib_diag_client *dc = fp->private_data;\r\nstruct qib_devdata *dd = dc->dd;\r\nvoid __iomem *kreg_base;\r\nssize_t ret;\r\nif (dc->pid != current->pid) {\r\nret = -EPERM;\r\ngoto bail;\r\n}\r\nkreg_base = dd->kregbase;\r\nif (count == 0)\r\nret = 0;\r\nelse if ((count % 4) || (*off % 4))\r\nret = -EINVAL;\r\nelse if (dc->state < READY && (*off || count != 8))\r\nret = -EINVAL;\r\nelse {\r\nunsigned long flags;\r\nu64 data64 = 0;\r\nint use_32;\r\nconst struct diag_observer *op;\r\nuse_32 = (count % 8) || (*off % 8);\r\nret = -1;\r\nspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\r\nop = diag_get_observer(dd, *off);\r\nif (op) {\r\nu32 offset = *off;\r\nret = op->hook(dd, op, offset, &data64, 0, use_32);\r\n}\r\nspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\r\nif (!op) {\r\nif (use_32)\r\nret = qib_read_umem32(dd, data, (u32) *off,\r\ncount);\r\nelse\r\nret = qib_read_umem64(dd, data, (u32) *off,\r\ncount);\r\n} else if (ret == count) {\r\nret = copy_to_user(data, &data64, use_32 ?\r\nsizeof(u32) : sizeof(u64));\r\nif (ret)\r\nret = -EFAULT;\r\n}\r\n}\r\nif (ret >= 0) {\r\n*off += count;\r\nret = count;\r\nif (dc->state == OPENED)\r\ndc->state = INIT;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t qib_diag_write(struct file *fp, const char __user *data,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct qib_diag_client *dc = fp->private_data;\r\nstruct qib_devdata *dd = dc->dd;\r\nvoid __iomem *kreg_base;\r\nssize_t ret;\r\nif (dc->pid != current->pid) {\r\nret = -EPERM;\r\ngoto bail;\r\n}\r\nkreg_base = dd->kregbase;\r\nif (count == 0)\r\nret = 0;\r\nelse if ((count % 4) || (*off % 4))\r\nret = -EINVAL;\r\nelse if (dc->state < READY &&\r\n((*off || count != 8) || dc->state != INIT))\r\nret = -EINVAL;\r\nelse {\r\nunsigned long flags;\r\nconst struct diag_observer *op = NULL;\r\nint use_32 = (count % 8) || (*off % 8);\r\nif (count == 4 || count == 8) {\r\nu64 data64;\r\nu32 offset = *off;\r\nret = copy_from_user(&data64, data, count);\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto bail;\r\n}\r\nspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\r\nop = diag_get_observer(dd, *off);\r\nif (op)\r\nret = op->hook(dd, op, offset, &data64, ~0Ull,\r\nuse_32);\r\nspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\r\n}\r\nif (!op) {\r\nif (use_32)\r\nret = qib_write_umem32(dd, (u32) *off, data,\r\ncount);\r\nelse\r\nret = qib_write_umem64(dd, (u32) *off, data,\r\ncount);\r\n}\r\n}\r\nif (ret >= 0) {\r\n*off += count;\r\nret = count;\r\nif (dc->state == INIT)\r\ndc->state = READY;\r\n}\r\nbail:\r\nreturn ret;\r\n}
