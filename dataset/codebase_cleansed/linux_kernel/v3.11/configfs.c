int check_user_usb_string(const char *name,\r\nstruct usb_gadget_strings *stringtab_dev)\r\n{\r\nunsigned primary_lang;\r\nunsigned sub_lang;\r\nu16 num;\r\nint ret;\r\nret = kstrtou16(name, 0, &num);\r\nif (ret)\r\nreturn ret;\r\nprimary_lang = num & 0x3ff;\r\nsub_lang = num >> 10;\r\nswitch (primary_lang) {\r\ncase 0:\r\ncase 0x62 ... 0xfe:\r\ncase 0x100 ... 0x3ff:\r\nreturn -EINVAL;\r\n}\r\nif (!sub_lang)\r\nreturn -EINVAL;\r\nstringtab_dev->language = num;\r\nreturn 0;\r\n}\r\nstatic int usb_string_copy(const char *s, char **s_copy)\r\n{\r\nint ret;\r\nchar *str;\r\nchar *copy = *s_copy;\r\nret = strlen(s);\r\nif (ret > 126)\r\nreturn -EOVERFLOW;\r\nstr = kstrdup(s, GFP_KERNEL);\r\nif (!str)\r\nreturn -ENOMEM;\r\nif (str[ret - 1] == '\n')\r\nstr[ret - 1] = '\0';\r\nkfree(copy);\r\n*s_copy = str;\r\nreturn 0;\r\n}\r\nstatic ssize_t is_valid_bcd(u16 bcd_val)\r\n{\r\nif ((bcd_val & 0xf) > 9)\r\nreturn -EINVAL;\r\nif (((bcd_val >> 4) & 0xf) > 9)\r\nreturn -EINVAL;\r\nif (((bcd_val >> 8) & 0xf) > 9)\r\nreturn -EINVAL;\r\nif (((bcd_val >> 12) & 0xf) > 9)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t gadget_dev_desc_bcdDevice_store(struct gadget_info *gi,\r\nconst char *page, size_t len)\r\n{\r\nu16 bcdDevice;\r\nint ret;\r\nret = kstrtou16(page, 0, &bcdDevice);\r\nif (ret)\r\nreturn ret;\r\nret = is_valid_bcd(bcdDevice);\r\nif (ret)\r\nreturn ret;\r\ngi->cdev.desc.bcdDevice = cpu_to_le16(bcdDevice);\r\nreturn len;\r\n}\r\nstatic ssize_t gadget_dev_desc_bcdUSB_store(struct gadget_info *gi,\r\nconst char *page, size_t len)\r\n{\r\nu16 bcdUSB;\r\nint ret;\r\nret = kstrtou16(page, 0, &bcdUSB);\r\nif (ret)\r\nreturn ret;\r\nret = is_valid_bcd(bcdUSB);\r\nif (ret)\r\nreturn ret;\r\ngi->cdev.desc.bcdUSB = cpu_to_le16(bcdUSB);\r\nreturn len;\r\n}\r\nstatic ssize_t gadget_dev_desc_UDC_show(struct gadget_info *gi, char *page)\r\n{\r\nreturn sprintf(page, "%s\n", gi->udc_name ?: "");\r\n}\r\nstatic int unregister_gadget(struct gadget_info *gi)\r\n{\r\nint ret;\r\nif (!gi->udc_name)\r\nreturn -ENODEV;\r\nret = usb_gadget_unregister_driver(&gi->composite.gadget_driver);\r\nif (ret)\r\nreturn ret;\r\nkfree(gi->udc_name);\r\ngi->udc_name = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t gadget_dev_desc_UDC_store(struct gadget_info *gi,\r\nconst char *page, size_t len)\r\n{\r\nchar *name;\r\nint ret;\r\nname = kstrdup(page, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nif (name[len - 1] == '\n')\r\nname[len - 1] = '\0';\r\nmutex_lock(&gi->lock);\r\nif (!strlen(name)) {\r\nret = unregister_gadget(gi);\r\nif (ret)\r\ngoto err;\r\n} else {\r\nif (gi->udc_name) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nret = udc_attach_driver(name, &gi->composite.gadget_driver);\r\nif (ret)\r\ngoto err;\r\ngi->udc_name = name;\r\n}\r\nmutex_unlock(&gi->lock);\r\nreturn len;\r\nerr:\r\nkfree(name);\r\nmutex_unlock(&gi->lock);\r\nreturn ret;\r\n}\r\nstatic inline struct gadget_info *to_gadget_info(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct gadget_info, group);\r\n}\r\nstatic inline struct gadget_strings *to_gadget_strings(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct gadget_strings,\r\ngroup);\r\n}\r\nstatic inline struct gadget_config_name *to_gadget_config_name(\r\nstruct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct gadget_config_name,\r\ngroup);\r\n}\r\nstatic inline struct config_usb_cfg *to_config_usb_cfg(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct config_usb_cfg,\r\ngroup);\r\n}\r\nstatic inline struct usb_function_instance *to_usb_function_instance(\r\nstruct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item),\r\nstruct usb_function_instance, group);\r\n}\r\nstatic void gadget_info_attr_release(struct config_item *item)\r\n{\r\nstruct gadget_info *gi = to_gadget_info(item);\r\nWARN_ON(!list_empty(&gi->cdev.configs));\r\nWARN_ON(!list_empty(&gi->string_list));\r\nWARN_ON(!list_empty(&gi->available_func));\r\nkfree(gi->composite.gadget_driver.function);\r\nkfree(gi);\r\n}\r\nstatic void gadget_config_attr_release(struct config_item *item)\r\n{\r\nstruct config_usb_cfg *cfg = to_config_usb_cfg(item);\r\nWARN_ON(!list_empty(&cfg->c.functions));\r\nlist_del(&cfg->c.list);\r\nkfree(cfg->c.label);\r\nkfree(cfg);\r\n}\r\nstatic int config_usb_cfg_link(\r\nstruct config_item *usb_cfg_ci,\r\nstruct config_item *usb_func_ci)\r\n{\r\nstruct config_usb_cfg *cfg = to_config_usb_cfg(usb_cfg_ci);\r\nstruct usb_composite_dev *cdev = cfg->c.cdev;\r\nstruct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);\r\nstruct config_group *group = to_config_group(usb_func_ci);\r\nstruct usb_function_instance *fi = container_of(group,\r\nstruct usb_function_instance, group);\r\nstruct usb_function_instance *a_fi;\r\nstruct usb_function *f;\r\nint ret;\r\nmutex_lock(&gi->lock);\r\nlist_for_each_entry(a_fi, &gi->available_func, cfs_list) {\r\nif (a_fi == fi)\r\nbreak;\r\n}\r\nif (a_fi != fi) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(f, &cfg->func_list, list) {\r\nif (f->fi == fi) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nf = usb_get_function(fi);\r\nif (IS_ERR(f)) {\r\nret = PTR_ERR(f);\r\ngoto out;\r\n}\r\nlist_add_tail(&f->list, &cfg->func_list);\r\nret = 0;\r\nout:\r\nmutex_unlock(&gi->lock);\r\nreturn ret;\r\n}\r\nstatic int config_usb_cfg_unlink(\r\nstruct config_item *usb_cfg_ci,\r\nstruct config_item *usb_func_ci)\r\n{\r\nstruct config_usb_cfg *cfg = to_config_usb_cfg(usb_cfg_ci);\r\nstruct usb_composite_dev *cdev = cfg->c.cdev;\r\nstruct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);\r\nstruct config_group *group = to_config_group(usb_func_ci);\r\nstruct usb_function_instance *fi = container_of(group,\r\nstruct usb_function_instance, group);\r\nstruct usb_function *f;\r\nmutex_lock(&gi->lock);\r\nif (gi->udc_name)\r\nunregister_gadget(gi);\r\nWARN_ON(gi->udc_name);\r\nlist_for_each_entry(f, &cfg->func_list, list) {\r\nif (f->fi == fi) {\r\nlist_del(&f->list);\r\nusb_put_function(f);\r\nmutex_unlock(&gi->lock);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&gi->lock);\r\nWARN(1, "Unable to locate function to unbind\n");\r\nreturn 0;\r\n}\r\nstatic ssize_t gadget_config_desc_MaxPower_show(struct config_usb_cfg *cfg,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%u\n", cfg->c.MaxPower);\r\n}\r\nstatic ssize_t gadget_config_desc_MaxPower_store(struct config_usb_cfg *cfg,\r\nconst char *page, size_t len)\r\n{\r\nu16 val;\r\nint ret;\r\nret = kstrtou16(page, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (DIV_ROUND_UP(val, 8) > 0xff)\r\nreturn -ERANGE;\r\ncfg->c.MaxPower = val;\r\nreturn len;\r\n}\r\nstatic ssize_t gadget_config_desc_bmAttributes_show(struct config_usb_cfg *cfg,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "0x%02x\n", cfg->c.bmAttributes);\r\n}\r\nstatic ssize_t gadget_config_desc_bmAttributes_store(struct config_usb_cfg *cfg,\r\nconst char *page, size_t len)\r\n{\r\nu8 val;\r\nint ret;\r\nret = kstrtou8(page, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (!(val & USB_CONFIG_ATT_ONE))\r\nreturn -EINVAL;\r\nif (val & ~(USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER |\r\nUSB_CONFIG_ATT_WAKEUP))\r\nreturn -EINVAL;\r\ncfg->c.bmAttributes = val;\r\nreturn len;\r\n}\r\nstatic void composite_init_dev(struct usb_composite_dev *cdev)\r\n{\r\nspin_lock_init(&cdev->lock);\r\nINIT_LIST_HEAD(&cdev->configs);\r\nINIT_LIST_HEAD(&cdev->gstrings);\r\n}\r\nstatic struct config_group *function_make(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct gadget_info *gi;\r\nstruct usb_function_instance *fi;\r\nchar buf[MAX_NAME_LEN];\r\nchar *func_name;\r\nchar *instance_name;\r\nint ret;\r\nret = snprintf(buf, MAX_NAME_LEN, "%s", name);\r\nif (ret >= MAX_NAME_LEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nfunc_name = buf;\r\ninstance_name = strchr(func_name, '.');\r\nif (!instance_name) {\r\npr_err("Unable to locate . in FUNC.INSTANCE\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n*instance_name = '\0';\r\ninstance_name++;\r\nfi = usb_get_function_instance(func_name);\r\nif (IS_ERR(fi))\r\nreturn ERR_PTR(PTR_ERR(fi));\r\nret = config_item_set_name(&fi->group.cg_item, name);\r\nif (ret) {\r\nusb_put_function_instance(fi);\r\nreturn ERR_PTR(ret);\r\n}\r\ngi = container_of(group, struct gadget_info, functions_group);\r\nmutex_lock(&gi->lock);\r\nlist_add_tail(&fi->cfs_list, &gi->available_func);\r\nmutex_unlock(&gi->lock);\r\nreturn &fi->group;\r\n}\r\nstatic void function_drop(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct usb_function_instance *fi = to_usb_function_instance(item);\r\nstruct gadget_info *gi;\r\ngi = container_of(group, struct gadget_info, functions_group);\r\nmutex_lock(&gi->lock);\r\nlist_del(&fi->cfs_list);\r\nmutex_unlock(&gi->lock);\r\nconfig_item_put(item);\r\n}\r\nstatic void gadget_config_name_attr_release(struct config_item *item)\r\n{\r\nstruct gadget_config_name *cn = to_gadget_config_name(item);\r\nkfree(cn->configuration);\r\nlist_del(&cn->list);\r\nkfree(cn);\r\n}\r\nstatic struct config_group *config_desc_make(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct gadget_info *gi;\r\nstruct config_usb_cfg *cfg;\r\nchar buf[MAX_NAME_LEN];\r\nchar *num_str;\r\nu8 num;\r\nint ret;\r\ngi = container_of(group, struct gadget_info, configs_group);\r\nret = snprintf(buf, MAX_NAME_LEN, "%s", name);\r\nif (ret >= MAX_NAME_LEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nnum_str = strchr(buf, '.');\r\nif (!num_str) {\r\npr_err("Unable to locate . in name.bConfigurationValue\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n*num_str = '\0';\r\nnum_str++;\r\nif (!strlen(buf))\r\nreturn ERR_PTR(-EINVAL);\r\nret = kstrtou8(num_str, 0, &num);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ncfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\r\nif (!cfg)\r\nreturn ERR_PTR(-ENOMEM);\r\ncfg->c.label = kstrdup(buf, GFP_KERNEL);\r\nif (!cfg->c.label) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ncfg->c.bConfigurationValue = num;\r\ncfg->c.MaxPower = CONFIG_USB_GADGET_VBUS_DRAW;\r\ncfg->c.bmAttributes = USB_CONFIG_ATT_ONE;\r\nINIT_LIST_HEAD(&cfg->string_list);\r\nINIT_LIST_HEAD(&cfg->func_list);\r\ncfg->group.default_groups = cfg->default_groups;\r\ncfg->default_groups[0] = &cfg->strings_group;\r\nconfig_group_init_type_name(&cfg->group, name,\r\n&gadget_config_type);\r\nconfig_group_init_type_name(&cfg->strings_group, "strings",\r\n&gadget_config_name_strings_type);\r\nret = usb_add_config_only(&gi->cdev, &cfg->c);\r\nif (ret)\r\ngoto err;\r\nreturn &cfg->group;\r\nerr:\r\nkfree(cfg->c.label);\r\nkfree(cfg);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void config_desc_drop(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nconfig_item_put(item);\r\n}\r\nstatic void gadget_strings_attr_release(struct config_item *item)\r\n{\r\nstruct gadget_strings *gs = to_gadget_strings(item);\r\nkfree(gs->manufacturer);\r\nkfree(gs->product);\r\nkfree(gs->serialnumber);\r\nlist_del(&gs->list);\r\nkfree(gs);\r\n}\r\nstatic int configfs_do_nothing(struct usb_composite_dev *cdev)\r\n{\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nstatic void purge_configs_funcs(struct gadget_info *gi)\r\n{\r\nstruct usb_configuration *c;\r\nlist_for_each_entry(c, &gi->cdev.configs, list) {\r\nstruct usb_function *f, *tmp;\r\nstruct config_usb_cfg *cfg;\r\ncfg = container_of(c, struct config_usb_cfg, c);\r\nlist_for_each_entry_safe(f, tmp, &c->functions, list) {\r\nlist_move_tail(&f->list, &cfg->func_list);\r\nif (f->unbind) {\r\ndev_err(&gi->cdev.gadget->dev, "unbind function"\r\n" '%s'/%p\n", f->name, f);\r\nf->unbind(c, f);\r\n}\r\n}\r\nc->next_interface_id = 0;\r\nc->superspeed = 0;\r\nc->highspeed = 0;\r\nc->fullspeed = 0;\r\n}\r\n}\r\nstatic int configfs_composite_bind(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *gdriver)\r\n{\r\nstruct usb_composite_driver *composite = to_cdriver(gdriver);\r\nstruct gadget_info *gi = container_of(composite,\r\nstruct gadget_info, composite);\r\nstruct usb_composite_dev *cdev = &gi->cdev;\r\nstruct usb_configuration *c;\r\nstruct usb_string *s;\r\nunsigned i;\r\nint ret;\r\ncdev->gadget = gadget;\r\nset_gadget_data(gadget, cdev);\r\nret = composite_dev_prepare(composite, cdev);\r\nif (ret)\r\nreturn ret;\r\nret = -EINVAL;\r\nif (list_empty(&gi->cdev.configs)) {\r\npr_err("Need atleast one configuration in %s.\n",\r\ngi->composite.name);\r\ngoto err_comp_cleanup;\r\n}\r\nlist_for_each_entry(c, &gi->cdev.configs, list) {\r\nstruct config_usb_cfg *cfg;\r\ncfg = container_of(c, struct config_usb_cfg, c);\r\nif (list_empty(&cfg->func_list)) {\r\npr_err("Config %s/%d of %s needs atleast one function.\n",\r\nc->label, c->bConfigurationValue,\r\ngi->composite.name);\r\ngoto err_comp_cleanup;\r\n}\r\n}\r\nif (!list_empty(&gi->string_list)) {\r\nstruct gadget_strings *gs;\r\ni = 0;\r\nlist_for_each_entry(gs, &gi->string_list, list) {\r\ngi->gstrings[i] = &gs->stringtab_dev;\r\ngs->stringtab_dev.strings = gs->strings;\r\ngs->strings[USB_GADGET_MANUFACTURER_IDX].s =\r\ngs->manufacturer;\r\ngs->strings[USB_GADGET_PRODUCT_IDX].s = gs->product;\r\ngs->strings[USB_GADGET_SERIAL_IDX].s = gs->serialnumber;\r\ni++;\r\n}\r\ngi->gstrings[i] = NULL;\r\ns = usb_gstrings_attach(&gi->cdev, gi->gstrings,\r\nUSB_GADGET_FIRST_AVAIL_IDX);\r\nif (IS_ERR(s)) {\r\nret = PTR_ERR(s);\r\ngoto err_comp_cleanup;\r\n}\r\ngi->cdev.desc.iManufacturer = s[USB_GADGET_MANUFACTURER_IDX].id;\r\ngi->cdev.desc.iProduct = s[USB_GADGET_PRODUCT_IDX].id;\r\ngi->cdev.desc.iSerialNumber = s[USB_GADGET_SERIAL_IDX].id;\r\n}\r\nlist_for_each_entry(c, &gi->cdev.configs, list) {\r\nstruct config_usb_cfg *cfg;\r\nstruct usb_function *f;\r\nstruct usb_function *tmp;\r\nstruct gadget_config_name *cn;\r\ncfg = container_of(c, struct config_usb_cfg, c);\r\nif (!list_empty(&cfg->string_list)) {\r\ni = 0;\r\nlist_for_each_entry(cn, &cfg->string_list, list) {\r\ncfg->gstrings[i] = &cn->stringtab_dev;\r\ncn->stringtab_dev.strings = &cn->strings;\r\ncn->strings.s = cn->configuration;\r\ni++;\r\n}\r\ncfg->gstrings[i] = NULL;\r\ns = usb_gstrings_attach(&gi->cdev, cfg->gstrings, 1);\r\nif (IS_ERR(s)) {\r\nret = PTR_ERR(s);\r\ngoto err_comp_cleanup;\r\n}\r\nc->iConfiguration = s[0].id;\r\n}\r\nlist_for_each_entry_safe(f, tmp, &cfg->func_list, list) {\r\nlist_del(&f->list);\r\nret = usb_add_function(c, f);\r\nif (ret)\r\ngoto err_purge_funcs;\r\n}\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\n}\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\nreturn 0;\r\nerr_purge_funcs:\r\npurge_configs_funcs(gi);\r\nerr_comp_cleanup:\r\ncomposite_dev_cleanup(cdev);\r\nreturn ret;\r\n}\r\nstatic void configfs_composite_unbind(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev;\r\nstruct gadget_info *gi;\r\ncdev = get_gadget_data(gadget);\r\ngi = container_of(cdev, struct gadget_info, cdev);\r\npurge_configs_funcs(gi);\r\ncomposite_dev_cleanup(cdev);\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\ncdev->gadget = NULL;\r\nset_gadget_data(gadget, NULL);\r\n}\r\nstatic struct config_group *gadgets_make(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct gadget_info *gi;\r\ngi = kzalloc(sizeof(*gi), GFP_KERNEL);\r\nif (!gi)\r\nreturn ERR_PTR(-ENOMEM);\r\ngi->group.default_groups = gi->default_groups;\r\ngi->group.default_groups[0] = &gi->functions_group;\r\ngi->group.default_groups[1] = &gi->configs_group;\r\ngi->group.default_groups[2] = &gi->strings_group;\r\nconfig_group_init_type_name(&gi->functions_group, "functions",\r\n&functions_type);\r\nconfig_group_init_type_name(&gi->configs_group, "configs",\r\n&config_desc_type);\r\nconfig_group_init_type_name(&gi->strings_group, "strings",\r\n&gadget_strings_strings_type);\r\ngi->composite.bind = configfs_do_nothing;\r\ngi->composite.unbind = configfs_do_nothing;\r\ngi->composite.suspend = NULL;\r\ngi->composite.resume = NULL;\r\ngi->composite.max_speed = USB_SPEED_SUPER;\r\nmutex_init(&gi->lock);\r\nINIT_LIST_HEAD(&gi->string_list);\r\nINIT_LIST_HEAD(&gi->available_func);\r\ncomposite_init_dev(&gi->cdev);\r\ngi->cdev.desc.bLength = USB_DT_DEVICE_SIZE;\r\ngi->cdev.desc.bDescriptorType = USB_DT_DEVICE;\r\ngi->cdev.desc.bcdDevice = cpu_to_le16(get_default_bcdDevice());\r\ngi->composite.gadget_driver = configfs_driver_template;\r\ngi->composite.gadget_driver.function = kstrdup(name, GFP_KERNEL);\r\ngi->composite.name = gi->composite.gadget_driver.function;\r\nif (!gi->composite.gadget_driver.function)\r\ngoto err;\r\n#ifdef CONFIG_USB_OTG\r\ngi->otg.bLength = sizeof(struct usb_otg_descriptor);\r\ngi->otg.bDescriptorType = USB_DT_OTG;\r\ngi->otg.bmAttributes = USB_OTG_SRP | USB_OTG_HNP;\r\n#endif\r\nconfig_group_init_type_name(&gi->group, name,\r\n&gadget_root_type);\r\nreturn &gi->group;\r\nerr:\r\nkfree(gi);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void gadgets_drop(struct config_group *group, struct config_item *item)\r\n{\r\nconfig_item_put(item);\r\n}\r\nstatic int __init gadget_cfs_init(void)\r\n{\r\nint ret;\r\nconfig_group_init(&gadget_subsys.su_group);\r\nret = configfs_register_subsystem(&gadget_subsys);\r\nreturn ret;\r\n}\r\nstatic void __exit gadget_cfs_exit(void)\r\n{\r\nconfigfs_unregister_subsystem(&gadget_subsys);\r\n}
