static unsigned int mangle_packet(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int matchoff, unsigned int matchlen,\r\nconst char *buffer, unsigned int buflen)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct tcphdr *th;\r\nunsigned int baseoff;\r\nif (nf_ct_protonum(ct) == IPPROTO_TCP) {\r\nth = (struct tcphdr *)(skb->data + protoff);\r\nbaseoff = protoff + th->doff * 4;\r\nmatchoff += dataoff - baseoff;\r\nif (!__nf_nat_mangle_tcp_packet(skb, ct, ctinfo,\r\nprotoff, matchoff, matchlen,\r\nbuffer, buflen, false))\r\nreturn 0;\r\n} else {\r\nbaseoff = protoff + sizeof(struct udphdr);\r\nmatchoff += dataoff - baseoff;\r\nif (!nf_nat_mangle_udp_packet(skb, ct, ctinfo,\r\nprotoff, matchoff, matchlen,\r\nbuffer, buflen))\r\nreturn 0;\r\n}\r\n*dptr = skb->data + dataoff;\r\n*datalen += buflen - matchlen;\r\nreturn 1;\r\n}\r\nstatic int sip_sprintf_addr(const struct nf_conn *ct, char *buffer,\r\nconst union nf_inet_addr *addr, bool delim)\r\n{\r\nif (nf_ct_l3num(ct) == NFPROTO_IPV4)\r\nreturn sprintf(buffer, "%pI4", &addr->ip);\r\nelse {\r\nif (delim)\r\nreturn sprintf(buffer, "[%pI6c]", &addr->ip6);\r\nelse\r\nreturn sprintf(buffer, "%pI6c", &addr->ip6);\r\n}\r\n}\r\nstatic int sip_sprintf_addr_port(const struct nf_conn *ct, char *buffer,\r\nconst union nf_inet_addr *addr, u16 port)\r\n{\r\nif (nf_ct_l3num(ct) == NFPROTO_IPV4)\r\nreturn sprintf(buffer, "%pI4:%u", &addr->ip, port);\r\nelse\r\nreturn sprintf(buffer, "[%pI6c]:%u", &addr->ip6, port);\r\n}\r\nstatic int map_addr(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int matchoff, unsigned int matchlen,\r\nunion nf_inet_addr *addr, __be16 port)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nchar buffer[INET6_ADDRSTRLEN + sizeof("[]:nnnnn")];\r\nunsigned int buflen;\r\nunion nf_inet_addr newaddr;\r\n__be16 newport;\r\nif (nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3, addr) &&\r\nct->tuplehash[dir].tuple.src.u.udp.port == port) {\r\nnewaddr = ct->tuplehash[!dir].tuple.dst.u3;\r\nnewport = ct->tuplehash[!dir].tuple.dst.u.udp.port;\r\n} else if (nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.dst.u3, addr) &&\r\nct->tuplehash[dir].tuple.dst.u.udp.port == port) {\r\nnewaddr = ct->tuplehash[!dir].tuple.src.u3;\r\nnewport = ct_sip_info->forced_dport ? :\r\nct->tuplehash[!dir].tuple.src.u.udp.port;\r\n} else\r\nreturn 1;\r\nif (nf_inet_addr_cmp(&newaddr, addr) && newport == port)\r\nreturn 1;\r\nbuflen = sip_sprintf_addr_port(ct, buffer, &newaddr, ntohs(newport));\r\nreturn mangle_packet(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen, buffer, buflen);\r\n}\r\nstatic int map_sip_addr(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nenum sip_header_types type)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nunsigned int matchlen, matchoff;\r\nunion nf_inet_addr addr;\r\n__be16 port;\r\nif (ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen, type, NULL,\r\n&matchoff, &matchlen, &addr, &port) <= 0)\r\nreturn 1;\r\nreturn map_addr(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen, &addr, port);\r\n}\r\nstatic unsigned int nf_nat_sip(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nunsigned int coff, matchoff, matchlen;\r\nenum sip_header_types hdr;\r\nunion nf_inet_addr addr;\r\n__be16 port;\r\nint request, in_header;\r\nif (strnicmp(*dptr, "SIP/2.0", strlen("SIP/2.0")) != 0) {\r\nif (ct_sip_parse_request(ct, *dptr, *datalen,\r\n&matchoff, &matchlen,\r\n&addr, &port) > 0 &&\r\n!map_addr(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen, &addr, port)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle SIP message");\r\nreturn NF_DROP;\r\n}\r\nrequest = 1;\r\n} else\r\nrequest = 0;\r\nif (nf_ct_protonum(ct) == IPPROTO_TCP)\r\nhdr = SIP_HDR_VIA_TCP;\r\nelse\r\nhdr = SIP_HDR_VIA_UDP;\r\nif (ct_sip_parse_header_uri(ct, *dptr, NULL, *datalen,\r\nhdr, NULL, &matchoff, &matchlen,\r\n&addr, &port) > 0) {\r\nunsigned int olen, matchend, poff, plen, buflen, n;\r\nchar buffer[INET6_ADDRSTRLEN + sizeof("[]:nnnnn")];\r\nif (request) {\r\nif (!nf_inet_addr_cmp(&addr,\r\n&ct->tuplehash[dir].tuple.src.u3) ||\r\nport != ct->tuplehash[dir].tuple.src.u.udp.port)\r\ngoto next;\r\n} else {\r\nif (!nf_inet_addr_cmp(&addr,\r\n&ct->tuplehash[dir].tuple.dst.u3) ||\r\nport != ct->tuplehash[dir].tuple.dst.u.udp.port)\r\ngoto next;\r\n}\r\nolen = *datalen;\r\nif (!map_addr(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen, &addr, port)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle Via header");\r\nreturn NF_DROP;\r\n}\r\nmatchend = matchoff + matchlen + *datalen - olen;\r\nif (ct_sip_parse_address_param(ct, *dptr, matchend, *datalen,\r\n"maddr=", &poff, &plen,\r\n&addr, true) > 0 &&\r\nnf_inet_addr_cmp(&addr, &ct->tuplehash[dir].tuple.src.u3) &&\r\n!nf_inet_addr_cmp(&addr, &ct->tuplehash[!dir].tuple.dst.u3)) {\r\nbuflen = sip_sprintf_addr(ct, buffer,\r\n&ct->tuplehash[!dir].tuple.dst.u3,\r\ntrue);\r\nif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\r\npoff, plen, buffer, buflen)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle maddr");\r\nreturn NF_DROP;\r\n}\r\n}\r\nif (ct_sip_parse_address_param(ct, *dptr, matchend, *datalen,\r\n"received=", &poff, &plen,\r\n&addr, false) > 0 &&\r\nnf_inet_addr_cmp(&addr, &ct->tuplehash[dir].tuple.dst.u3) &&\r\n!nf_inet_addr_cmp(&addr, &ct->tuplehash[!dir].tuple.src.u3)) {\r\nbuflen = sip_sprintf_addr(ct, buffer,\r\n&ct->tuplehash[!dir].tuple.src.u3,\r\nfalse);\r\nif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\r\npoff, plen, buffer, buflen)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle received");\r\nreturn NF_DROP;\r\n}\r\n}\r\nif (ct_sip_parse_numerical_param(ct, *dptr, matchend, *datalen,\r\n"rport=", &poff, &plen,\r\n&n) > 0 &&\r\nhtons(n) == ct->tuplehash[dir].tuple.dst.u.udp.port &&\r\nhtons(n) != ct->tuplehash[!dir].tuple.src.u.udp.port) {\r\n__be16 p = ct->tuplehash[!dir].tuple.src.u.udp.port;\r\nbuflen = sprintf(buffer, "%u", ntohs(p));\r\nif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\r\npoff, plen, buffer, buflen)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle rport");\r\nreturn NF_DROP;\r\n}\r\n}\r\n}\r\nnext:\r\ncoff = 0;\r\nin_header = 0;\r\nwhile (ct_sip_parse_header_uri(ct, *dptr, &coff, *datalen,\r\nSIP_HDR_CONTACT, &in_header,\r\n&matchoff, &matchlen,\r\n&addr, &port) > 0) {\r\nif (!map_addr(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen,\r\n&addr, port)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle contact");\r\nreturn NF_DROP;\r\n}\r\n}\r\nif (!map_sip_addr(skb, protoff, dataoff, dptr, datalen, SIP_HDR_FROM) ||\r\n!map_sip_addr(skb, protoff, dataoff, dptr, datalen, SIP_HDR_TO)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle SIP from/to");\r\nreturn NF_DROP;\r\n}\r\nif (dir == IP_CT_DIR_REPLY && ct_sip_info->forced_dport) {\r\nstruct udphdr *uh;\r\nif (!skb_make_writable(skb, skb->len)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle packet");\r\nreturn NF_DROP;\r\n}\r\nuh = (void *)skb->data + protoff;\r\nuh->dest = ct_sip_info->forced_dport;\r\nif (!nf_nat_mangle_udp_packet(skb, ct, ctinfo, protoff,\r\n0, 0, NULL, 0)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle packet");\r\nreturn NF_DROP;\r\n}\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic void nf_nat_sip_seq_adjust(struct sk_buff *skb, unsigned int protoff,\r\ns16 off)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nconst struct tcphdr *th;\r\nif (nf_ct_protonum(ct) != IPPROTO_TCP || off == 0)\r\nreturn;\r\nth = (struct tcphdr *)(skb->data + protoff);\r\nnf_nat_set_seq_adjust(ct, ctinfo, th->seq, off);\r\n}\r\nstatic void nf_nat_sip_expected(struct nf_conn *ct,\r\nstruct nf_conntrack_expect *exp)\r\n{\r\nstruct nf_nat_range range;\r\nBUG_ON(ct->status & IPS_NAT_DONE_MASK);\r\nrange.flags = (NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED);\r\nrange.min_proto = range.max_proto = exp->saved_proto;\r\nrange.min_addr = range.max_addr = exp->saved_addr;\r\nnf_nat_setup_info(ct, &range, NF_NAT_MANIP_DST);\r\nif (nf_inet_addr_cmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3,\r\n&ct->master->tuplehash[exp->dir].tuple.src.u3)) {\r\nrange.flags = NF_NAT_RANGE_MAP_IPS;\r\nrange.min_addr = range.max_addr\r\n= ct->master->tuplehash[!exp->dir].tuple.dst.u3;\r\nnf_nat_setup_info(ct, &range, NF_NAT_MANIP_SRC);\r\n}\r\n}\r\nstatic unsigned int nf_nat_sip_expect(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nstruct nf_conntrack_expect *exp,\r\nunsigned int matchoff,\r\nunsigned int matchlen)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nstruct nf_ct_sip_master *ct_sip_info = nfct_help_data(ct);\r\nunion nf_inet_addr newaddr;\r\nu_int16_t port;\r\n__be16 srcport;\r\nchar buffer[INET6_ADDRSTRLEN + sizeof("[]:nnnnn")];\r\nunsigned int buflen;\r\nif (nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3))\r\nnewaddr = exp->tuple.dst.u3;\r\nelse\r\nnewaddr = ct->tuplehash[!dir].tuple.dst.u3;\r\nsrcport = ct_sip_info->forced_dport ? :\r\nct->tuplehash[dir].tuple.src.u.udp.port;\r\nif (exp->tuple.dst.u.udp.port == srcport)\r\nport = ntohs(ct->tuplehash[!dir].tuple.dst.u.udp.port);\r\nelse\r\nport = ntohs(exp->tuple.dst.u.udp.port);\r\nexp->saved_addr = exp->tuple.dst.u3;\r\nexp->tuple.dst.u3 = newaddr;\r\nexp->saved_proto.udp.port = exp->tuple.dst.u.udp.port;\r\nexp->dir = !dir;\r\nexp->expectfn = nf_nat_sip_expected;\r\nfor (; port != 0; port++) {\r\nint ret;\r\nexp->tuple.dst.u.udp.port = htons(port);\r\nret = nf_ct_expect_related(exp);\r\nif (ret == 0)\r\nbreak;\r\nelse if (ret != -EBUSY) {\r\nport = 0;\r\nbreak;\r\n}\r\n}\r\nif (port == 0) {\r\nnf_ct_helper_log(skb, ct, "all ports in use for SIP");\r\nreturn NF_DROP;\r\n}\r\nif (!nf_inet_addr_cmp(&exp->tuple.dst.u3, &exp->saved_addr) ||\r\nexp->tuple.dst.u.udp.port != exp->saved_proto.udp.port) {\r\nbuflen = sip_sprintf_addr_port(ct, buffer, &newaddr, port);\r\nif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen, buffer, buflen)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle packet");\r\ngoto err;\r\n}\r\n}\r\nreturn NF_ACCEPT;\r\nerr:\r\nnf_ct_unexpect_related(exp);\r\nreturn NF_DROP;\r\n}\r\nstatic int mangle_content_len(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nunsigned int matchoff, matchlen;\r\nchar buffer[sizeof("65536")];\r\nint buflen, c_len;\r\nif (ct_sip_get_sdp_header(ct, *dptr, 0, *datalen,\r\nSDP_HDR_VERSION, SDP_HDR_UNSPEC,\r\n&matchoff, &matchlen) <= 0)\r\nreturn 0;\r\nc_len = *datalen - matchoff + strlen("v=");\r\nif (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_CONTENT_LENGTH,\r\n&matchoff, &matchlen) <= 0)\r\nreturn 0;\r\nbuflen = sprintf(buffer, "%u", c_len);\r\nreturn mangle_packet(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen, buffer, buflen);\r\n}\r\nstatic int mangle_sdp_packet(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int sdpoff,\r\nenum sdp_header_types type,\r\nenum sdp_header_types term,\r\nchar *buffer, int buflen)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nunsigned int matchlen, matchoff;\r\nif (ct_sip_get_sdp_header(ct, *dptr, sdpoff, *datalen, type, term,\r\n&matchoff, &matchlen) <= 0)\r\nreturn -ENOENT;\r\nreturn mangle_packet(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen, buffer, buflen) ? 0 : -EINVAL;\r\n}\r\nstatic unsigned int nf_nat_sdp_addr(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int sdpoff,\r\nenum sdp_header_types type,\r\nenum sdp_header_types term,\r\nconst union nf_inet_addr *addr)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nchar buffer[INET6_ADDRSTRLEN];\r\nunsigned int buflen;\r\nbuflen = sip_sprintf_addr(ct, buffer, addr, false);\r\nif (mangle_sdp_packet(skb, protoff, dataoff, dptr, datalen,\r\nsdpoff, type, term, buffer, buflen))\r\nreturn 0;\r\nreturn mangle_content_len(skb, protoff, dataoff, dptr, datalen);\r\n}\r\nstatic unsigned int nf_nat_sdp_port(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int matchoff,\r\nunsigned int matchlen,\r\nu_int16_t port)\r\n{\r\nchar buffer[sizeof("nnnnn")];\r\nunsigned int buflen;\r\nbuflen = sprintf(buffer, "%u", port);\r\nif (!mangle_packet(skb, protoff, dataoff, dptr, datalen,\r\nmatchoff, matchlen, buffer, buflen))\r\nreturn 0;\r\nreturn mangle_content_len(skb, protoff, dataoff, dptr, datalen);\r\n}\r\nstatic unsigned int nf_nat_sdp_session(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nunsigned int sdpoff,\r\nconst union nf_inet_addr *addr)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nchar buffer[INET6_ADDRSTRLEN];\r\nunsigned int buflen;\r\nbuflen = sip_sprintf_addr(ct, buffer, addr, false);\r\nif (mangle_sdp_packet(skb, protoff, dataoff, dptr, datalen, sdpoff,\r\nSDP_HDR_OWNER, SDP_HDR_MEDIA, buffer, buflen))\r\nreturn 0;\r\nswitch (mangle_sdp_packet(skb, protoff, dataoff, dptr, datalen, sdpoff,\r\nSDP_HDR_CONNECTION, SDP_HDR_MEDIA,\r\nbuffer, buflen)) {\r\ncase 0:\r\ncase -ENOENT:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn mangle_content_len(skb, protoff, dataoff, dptr, datalen);\r\n}\r\nstatic unsigned int nf_nat_sdp_media(struct sk_buff *skb, unsigned int protoff,\r\nunsigned int dataoff,\r\nconst char **dptr, unsigned int *datalen,\r\nstruct nf_conntrack_expect *rtp_exp,\r\nstruct nf_conntrack_expect *rtcp_exp,\r\nunsigned int mediaoff,\r\nunsigned int medialen,\r\nunion nf_inet_addr *rtp_addr)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nu_int16_t port;\r\nif (nf_inet_addr_cmp(&ct->tuplehash[dir].tuple.src.u3,\r\n&ct->tuplehash[!dir].tuple.dst.u3))\r\n*rtp_addr = rtp_exp->tuple.dst.u3;\r\nelse\r\n*rtp_addr = ct->tuplehash[!dir].tuple.dst.u3;\r\nrtp_exp->saved_addr = rtp_exp->tuple.dst.u3;\r\nrtp_exp->tuple.dst.u3 = *rtp_addr;\r\nrtp_exp->saved_proto.udp.port = rtp_exp->tuple.dst.u.udp.port;\r\nrtp_exp->dir = !dir;\r\nrtp_exp->expectfn = nf_nat_sip_expected;\r\nrtcp_exp->saved_addr = rtcp_exp->tuple.dst.u3;\r\nrtcp_exp->tuple.dst.u3 = *rtp_addr;\r\nrtcp_exp->saved_proto.udp.port = rtcp_exp->tuple.dst.u.udp.port;\r\nrtcp_exp->dir = !dir;\r\nrtcp_exp->expectfn = nf_nat_sip_expected;\r\nfor (port = ntohs(rtp_exp->tuple.dst.u.udp.port);\r\nport != 0; port += 2) {\r\nint ret;\r\nrtp_exp->tuple.dst.u.udp.port = htons(port);\r\nret = nf_ct_expect_related(rtp_exp);\r\nif (ret == -EBUSY)\r\ncontinue;\r\nelse if (ret < 0) {\r\nport = 0;\r\nbreak;\r\n}\r\nrtcp_exp->tuple.dst.u.udp.port = htons(port + 1);\r\nret = nf_ct_expect_related(rtcp_exp);\r\nif (ret == 0)\r\nbreak;\r\nelse if (ret == -EBUSY) {\r\nnf_ct_unexpect_related(rtp_exp);\r\ncontinue;\r\n} else if (ret < 0) {\r\nnf_ct_unexpect_related(rtp_exp);\r\nport = 0;\r\nbreak;\r\n}\r\n}\r\nif (port == 0) {\r\nnf_ct_helper_log(skb, ct, "all ports in use for SDP media");\r\ngoto err1;\r\n}\r\nif (rtp_exp->tuple.dst.u.udp.port != rtp_exp->saved_proto.udp.port &&\r\n!nf_nat_sdp_port(skb, protoff, dataoff, dptr, datalen,\r\nmediaoff, medialen, port)) {\r\nnf_ct_helper_log(skb, ct, "cannot mangle SDP message");\r\ngoto err2;\r\n}\r\nreturn NF_ACCEPT;\r\nerr2:\r\nnf_ct_unexpect_related(rtp_exp);\r\nnf_ct_unexpect_related(rtcp_exp);\r\nerr1:\r\nreturn NF_DROP;\r\n}\r\nstatic void __exit nf_nat_sip_fini(void)\r\n{\r\nRCU_INIT_POINTER(nf_nat_sip_hook, NULL);\r\nRCU_INIT_POINTER(nf_nat_sip_seq_adjust_hook, NULL);\r\nRCU_INIT_POINTER(nf_nat_sip_expect_hook, NULL);\r\nRCU_INIT_POINTER(nf_nat_sdp_addr_hook, NULL);\r\nRCU_INIT_POINTER(nf_nat_sdp_port_hook, NULL);\r\nRCU_INIT_POINTER(nf_nat_sdp_session_hook, NULL);\r\nRCU_INIT_POINTER(nf_nat_sdp_media_hook, NULL);\r\nnf_ct_helper_expectfn_unregister(&sip_nat);\r\nsynchronize_rcu();\r\n}\r\nstatic int __init nf_nat_sip_init(void)\r\n{\r\nBUG_ON(nf_nat_sip_hook != NULL);\r\nBUG_ON(nf_nat_sip_seq_adjust_hook != NULL);\r\nBUG_ON(nf_nat_sip_expect_hook != NULL);\r\nBUG_ON(nf_nat_sdp_addr_hook != NULL);\r\nBUG_ON(nf_nat_sdp_port_hook != NULL);\r\nBUG_ON(nf_nat_sdp_session_hook != NULL);\r\nBUG_ON(nf_nat_sdp_media_hook != NULL);\r\nRCU_INIT_POINTER(nf_nat_sip_hook, nf_nat_sip);\r\nRCU_INIT_POINTER(nf_nat_sip_seq_adjust_hook, nf_nat_sip_seq_adjust);\r\nRCU_INIT_POINTER(nf_nat_sip_expect_hook, nf_nat_sip_expect);\r\nRCU_INIT_POINTER(nf_nat_sdp_addr_hook, nf_nat_sdp_addr);\r\nRCU_INIT_POINTER(nf_nat_sdp_port_hook, nf_nat_sdp_port);\r\nRCU_INIT_POINTER(nf_nat_sdp_session_hook, nf_nat_sdp_session);\r\nRCU_INIT_POINTER(nf_nat_sdp_media_hook, nf_nat_sdp_media);\r\nnf_ct_helper_expectfn_register(&sip_nat);\r\nreturn 0;\r\n}
