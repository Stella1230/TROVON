static void *bond_info_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n__acquires(&bond->lock\r\nstatic void *bond_info_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct bonding *bond = seq->private;\r\nstruct slave *slave = v;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn bond->first_slave;\r\nslave = slave->next;\r\nreturn (slave == bond->first_slave) ? NULL : slave;\r\n}\r\nstatic void bond_info_seq_stop(struct seq_file *seq, void *v)\r\n__releases(&bond->lock\r\nstatic void bond_info_show_master(struct seq_file *seq)\r\n{\r\nstruct bonding *bond = seq->private;\r\nstruct slave *curr;\r\nint i;\r\nread_lock(&bond->curr_slave_lock);\r\ncurr = bond->curr_active_slave;\r\nread_unlock(&bond->curr_slave_lock);\r\nseq_printf(seq, "Bonding Mode: %s",\r\nbond_mode_name(bond->params.mode));\r\nif (bond->params.mode == BOND_MODE_ACTIVEBACKUP &&\r\nbond->params.fail_over_mac)\r\nseq_printf(seq, " (fail_over_mac %s)",\r\nfail_over_mac_tbl[bond->params.fail_over_mac].modename);\r\nseq_printf(seq, "\n");\r\nif (bond->params.mode == BOND_MODE_XOR ||\r\nbond->params.mode == BOND_MODE_8023AD) {\r\nseq_printf(seq, "Transmit Hash Policy: %s (%d)\n",\r\nxmit_hashtype_tbl[bond->params.xmit_policy].modename,\r\nbond->params.xmit_policy);\r\n}\r\nif (USES_PRIMARY(bond->params.mode)) {\r\nseq_printf(seq, "Primary Slave: %s",\r\n(bond->primary_slave) ?\r\nbond->primary_slave->dev->name : "None");\r\nif (bond->primary_slave)\r\nseq_printf(seq, " (primary_reselect %s)",\r\npri_reselect_tbl[bond->params.primary_reselect].modename);\r\nseq_printf(seq, "\nCurrently Active Slave: %s\n",\r\n(curr) ? curr->dev->name : "None");\r\n}\r\nseq_printf(seq, "MII Status: %s\n", netif_carrier_ok(bond->dev) ?\r\n"up" : "down");\r\nseq_printf(seq, "MII Polling Interval (ms): %d\n", bond->params.miimon);\r\nseq_printf(seq, "Up Delay (ms): %d\n",\r\nbond->params.updelay * bond->params.miimon);\r\nseq_printf(seq, "Down Delay (ms): %d\n",\r\nbond->params.downdelay * bond->params.miimon);\r\nif (bond->params.arp_interval > 0) {\r\nint printed = 0;\r\nseq_printf(seq, "ARP Polling Interval (ms): %d\n",\r\nbond->params.arp_interval);\r\nseq_printf(seq, "ARP IP target/s (n.n.n.n form):");\r\nfor (i = 0; (i < BOND_MAX_ARP_TARGETS); i++) {\r\nif (!bond->params.arp_targets[i])\r\nbreak;\r\nif (printed)\r\nseq_printf(seq, ",");\r\nseq_printf(seq, " %pI4", &bond->params.arp_targets[i]);\r\nprinted = 1;\r\n}\r\nseq_printf(seq, "\n");\r\n}\r\nif (bond->params.mode == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\nseq_puts(seq, "\n802.3ad info\n");\r\nseq_printf(seq, "LACP rate: %s\n",\r\n(bond->params.lacp_fast) ? "fast" : "slow");\r\nseq_printf(seq, "Min links: %d\n", bond->params.min_links);\r\nseq_printf(seq, "Aggregator selection policy (ad_select): %s\n",\r\nad_select_tbl[bond->params.ad_select].modename);\r\nif (__bond_3ad_get_active_agg_info(bond, &ad_info)) {\r\nseq_printf(seq, "bond %s has no active aggregator\n",\r\nbond->dev->name);\r\n} else {\r\nseq_printf(seq, "Active Aggregator Info:\n");\r\nseq_printf(seq, "\tAggregator ID: %d\n",\r\nad_info.aggregator_id);\r\nseq_printf(seq, "\tNumber of ports: %d\n",\r\nad_info.ports);\r\nseq_printf(seq, "\tActor Key: %d\n",\r\nad_info.actor_key);\r\nseq_printf(seq, "\tPartner Key: %d\n",\r\nad_info.partner_key);\r\nseq_printf(seq, "\tPartner Mac Address: %pM\n",\r\nad_info.partner_system);\r\n}\r\n}\r\n}\r\nstatic const char *bond_slave_link_status(s8 link)\r\n{\r\nstatic const char * const status[] = {\r\n[BOND_LINK_UP] = "up",\r\n[BOND_LINK_FAIL] = "going down",\r\n[BOND_LINK_DOWN] = "down",\r\n[BOND_LINK_BACK] = "going back",\r\n};\r\nreturn status[link];\r\n}\r\nstatic void bond_info_show_slave(struct seq_file *seq,\r\nconst struct slave *slave)\r\n{\r\nstruct bonding *bond = seq->private;\r\nseq_printf(seq, "\nSlave Interface: %s\n", slave->dev->name);\r\nseq_printf(seq, "MII Status: %s\n", bond_slave_link_status(slave->link));\r\nif (slave->speed == SPEED_UNKNOWN)\r\nseq_printf(seq, "Speed: %s\n", "Unknown");\r\nelse\r\nseq_printf(seq, "Speed: %d Mbps\n", slave->speed);\r\nif (slave->duplex == DUPLEX_UNKNOWN)\r\nseq_printf(seq, "Duplex: %s\n", "Unknown");\r\nelse\r\nseq_printf(seq, "Duplex: %s\n", slave->duplex ? "full" : "half");\r\nseq_printf(seq, "Link Failure Count: %u\n",\r\nslave->link_failure_count);\r\nseq_printf(seq, "Permanent HW addr: %pM\n", slave->perm_hwaddr);\r\nif (bond->params.mode == BOND_MODE_8023AD) {\r\nconst struct aggregator *agg\r\n= SLAVE_AD_INFO(slave).port.aggregator;\r\nif (agg)\r\nseq_printf(seq, "Aggregator ID: %d\n",\r\nagg->aggregator_identifier);\r\nelse\r\nseq_puts(seq, "Aggregator ID: N/A\n");\r\n}\r\nseq_printf(seq, "Slave queue ID: %d\n", slave->queue_id);\r\n}\r\nstatic int bond_info_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq, "%s\n", bond_version);\r\nbond_info_show_master(seq);\r\n} else\r\nbond_info_show_slave(seq, v);\r\nreturn 0;\r\n}\r\nstatic int bond_info_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint res;\r\nres = seq_open(file, &bond_info_seq_ops);\r\nif (!res) {\r\nseq = file->private_data;\r\nseq->private = PDE_DATA(inode);\r\n}\r\nreturn res;\r\n}\r\nvoid bond_create_proc_entry(struct bonding *bond)\r\n{\r\nstruct net_device *bond_dev = bond->dev;\r\nstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\r\nif (bn->proc_dir) {\r\nbond->proc_entry = proc_create_data(bond_dev->name,\r\nS_IRUGO, bn->proc_dir,\r\n&bond_info_fops, bond);\r\nif (bond->proc_entry == NULL)\r\npr_warning("Warning: Cannot create /proc/net/%s/%s\n",\r\nDRV_NAME, bond_dev->name);\r\nelse\r\nmemcpy(bond->proc_file_name, bond_dev->name, IFNAMSIZ);\r\n}\r\n}\r\nvoid bond_remove_proc_entry(struct bonding *bond)\r\n{\r\nstruct net_device *bond_dev = bond->dev;\r\nstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\r\nif (bn->proc_dir && bond->proc_entry) {\r\nremove_proc_entry(bond->proc_file_name, bn->proc_dir);\r\nmemset(bond->proc_file_name, 0, IFNAMSIZ);\r\nbond->proc_entry = NULL;\r\n}\r\n}\r\nvoid __net_init bond_create_proc_dir(struct bond_net *bn)\r\n{\r\nif (!bn->proc_dir) {\r\nbn->proc_dir = proc_mkdir(DRV_NAME, bn->net->proc_net);\r\nif (!bn->proc_dir)\r\npr_warning("Warning: cannot create /proc/net/%s\n",\r\nDRV_NAME);\r\n}\r\n}\r\nvoid __net_exit bond_destroy_proc_dir(struct bond_net *bn)\r\n{\r\nif (bn->proc_dir) {\r\nremove_proc_entry(DRV_NAME, bn->net->proc_net);\r\nbn->proc_dir = NULL;\r\n}\r\n}
