void down(struct semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->lock, flags);\r\nif (likely(sem->count > 0))\r\nsem->count--;\r\nelse\r\n__down(sem);\r\nraw_spin_unlock_irqrestore(&sem->lock, flags);\r\n}\r\nint down_interruptible(struct semaphore *sem)\r\n{\r\nunsigned long flags;\r\nint result = 0;\r\nraw_spin_lock_irqsave(&sem->lock, flags);\r\nif (likely(sem->count > 0))\r\nsem->count--;\r\nelse\r\nresult = __down_interruptible(sem);\r\nraw_spin_unlock_irqrestore(&sem->lock, flags);\r\nreturn result;\r\n}\r\nint down_killable(struct semaphore *sem)\r\n{\r\nunsigned long flags;\r\nint result = 0;\r\nraw_spin_lock_irqsave(&sem->lock, flags);\r\nif (likely(sem->count > 0))\r\nsem->count--;\r\nelse\r\nresult = __down_killable(sem);\r\nraw_spin_unlock_irqrestore(&sem->lock, flags);\r\nreturn result;\r\n}\r\nint down_trylock(struct semaphore *sem)\r\n{\r\nunsigned long flags;\r\nint count;\r\nraw_spin_lock_irqsave(&sem->lock, flags);\r\ncount = sem->count - 1;\r\nif (likely(count >= 0))\r\nsem->count = count;\r\nraw_spin_unlock_irqrestore(&sem->lock, flags);\r\nreturn (count < 0);\r\n}\r\nint down_timeout(struct semaphore *sem, long jiffies)\r\n{\r\nunsigned long flags;\r\nint result = 0;\r\nraw_spin_lock_irqsave(&sem->lock, flags);\r\nif (likely(sem->count > 0))\r\nsem->count--;\r\nelse\r\nresult = __down_timeout(sem, jiffies);\r\nraw_spin_unlock_irqrestore(&sem->lock, flags);\r\nreturn result;\r\n}\r\nvoid up(struct semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->lock, flags);\r\nif (likely(list_empty(&sem->wait_list)))\r\nsem->count++;\r\nelse\r\n__up(sem);\r\nraw_spin_unlock_irqrestore(&sem->lock, flags);\r\n}\r\nstatic inline int __sched __down_common(struct semaphore *sem, long state,\r\nlong timeout)\r\n{\r\nstruct task_struct *task = current;\r\nstruct semaphore_waiter waiter;\r\nlist_add_tail(&waiter.list, &sem->wait_list);\r\nwaiter.task = task;\r\nwaiter.up = false;\r\nfor (;;) {\r\nif (signal_pending_state(state, task))\r\ngoto interrupted;\r\nif (unlikely(timeout <= 0))\r\ngoto timed_out;\r\n__set_task_state(task, state);\r\nraw_spin_unlock_irq(&sem->lock);\r\ntimeout = schedule_timeout(timeout);\r\nraw_spin_lock_irq(&sem->lock);\r\nif (waiter.up)\r\nreturn 0;\r\n}\r\ntimed_out:\r\nlist_del(&waiter.list);\r\nreturn -ETIME;\r\ninterrupted:\r\nlist_del(&waiter.list);\r\nreturn -EINTR;\r\n}\r\nstatic noinline void __sched __down(struct semaphore *sem)\r\n{\r\n__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\r\n}\r\nstatic noinline int __sched __down_interruptible(struct semaphore *sem)\r\n{\r\nreturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\r\n}\r\nstatic noinline int __sched __down_killable(struct semaphore *sem)\r\n{\r\nreturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);\r\n}\r\nstatic noinline int __sched __down_timeout(struct semaphore *sem, long jiffies)\r\n{\r\nreturn __down_common(sem, TASK_UNINTERRUPTIBLE, jiffies);\r\n}\r\nstatic noinline void __sched __up(struct semaphore *sem)\r\n{\r\nstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,\r\nstruct semaphore_waiter, list);\r\nlist_del(&waiter->list);\r\nwaiter->up = true;\r\nwake_up_process(waiter->task);\r\n}
