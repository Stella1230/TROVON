static void\r\nwbcir_set_bits(unsigned long addr, u8 bits, u8 mask)\r\n{\r\nu8 val;\r\nval = inb(addr);\r\nval = ((val & ~mask) | (bits & mask));\r\noutb(val, addr);\r\n}\r\nstatic inline void\r\nwbcir_select_bank(struct wbcir_data *data, enum wbcir_bank bank)\r\n{\r\noutb(bank, data->sbase + WBCIR_REG_SP3_BSR);\r\n}\r\nstatic inline void\r\nwbcir_set_irqmask(struct wbcir_data *data, u8 irqmask)\r\n{\r\nif (data->irqmask == irqmask)\r\nreturn;\r\nwbcir_select_bank(data, WBCIR_BANK_0);\r\noutb(irqmask, data->sbase + WBCIR_REG_SP3_IER);\r\ndata->irqmask = irqmask;\r\n}\r\nstatic enum led_brightness\r\nwbcir_led_brightness_get(struct led_classdev *led_cdev)\r\n{\r\nstruct wbcir_data *data = container_of(led_cdev,\r\nstruct wbcir_data,\r\nled);\r\nif (inb(data->ebase + WBCIR_REG_ECEIR_CTS) & WBCIR_LED_ENABLE)\r\nreturn LED_FULL;\r\nelse\r\nreturn LED_OFF;\r\n}\r\nstatic void\r\nwbcir_led_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct wbcir_data *data = container_of(led_cdev,\r\nstruct wbcir_data,\r\nled);\r\nwbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CTS,\r\nbrightness == LED_OFF ? 0x00 : WBCIR_LED_ENABLE,\r\nWBCIR_LED_ENABLE);\r\n}\r\nstatic u8\r\nwbcir_to_rc6cells(u8 val)\r\n{\r\nu8 coded = 0x00;\r\nint i;\r\nval &= 0x0F;\r\nfor (i = 0; i < 4; i++) {\r\nif (val & 0x01)\r\ncoded |= 0x02 << (i * 2);\r\nelse\r\ncoded |= 0x01 << (i * 2);\r\nval >>= 1;\r\n}\r\nreturn coded;\r\n}\r\nstatic void\r\nwbcir_carrier_report(struct wbcir_data *data)\r\n{\r\nunsigned counter = inb(data->ebase + WBCIR_REG_ECEIR_CNT_LO) |\r\ninb(data->ebase + WBCIR_REG_ECEIR_CNT_HI) << 8;\r\nif (counter > 0 && counter < 0xffff) {\r\nDEFINE_IR_RAW_EVENT(ev);\r\nev.carrier_report = 1;\r\nev.carrier = DIV_ROUND_CLOSEST(counter * 1000000u,\r\ndata->pulse_duration);\r\nir_raw_event_store(data->dev, &ev);\r\n}\r\ndata->pulse_duration = 0;\r\nwbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CCTL, WBCIR_CNTR_R,\r\nWBCIR_CNTR_EN | WBCIR_CNTR_R);\r\nwbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CCTL, WBCIR_CNTR_EN,\r\nWBCIR_CNTR_EN | WBCIR_CNTR_R);\r\n}\r\nstatic void\r\nwbcir_idle_rx(struct rc_dev *dev, bool idle)\r\n{\r\nstruct wbcir_data *data = dev->priv;\r\nif (!idle && data->rxstate == WBCIR_RXSTATE_INACTIVE) {\r\ndata->rxstate = WBCIR_RXSTATE_ACTIVE;\r\nled_trigger_event(data->rxtrigger, LED_FULL);\r\n}\r\nif (idle && data->rxstate != WBCIR_RXSTATE_INACTIVE) {\r\ndata->rxstate = WBCIR_RXSTATE_INACTIVE;\r\nled_trigger_event(data->rxtrigger, LED_OFF);\r\nif (data->carrier_report_enabled)\r\nwbcir_carrier_report(data);\r\noutb(WBCIR_RX_DISABLE, data->sbase + WBCIR_REG_SP3_ASCR);\r\n}\r\n}\r\nstatic void\r\nwbcir_irq_rx(struct wbcir_data *data, struct pnp_dev *device)\r\n{\r\nu8 irdata;\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nunsigned duration;\r\nwhile (inb(data->sbase + WBCIR_REG_SP3_LSR) & WBCIR_RX_AVAIL) {\r\nirdata = inb(data->sbase + WBCIR_REG_SP3_RXDATA);\r\nif (data->rxstate == WBCIR_RXSTATE_ERROR)\r\ncontinue;\r\nduration = ((irdata & 0x7F) + 1) *\r\n(data->carrier_report_enabled ? 2 : 10);\r\nrawir.pulse = irdata & 0x80 ? false : true;\r\nrawir.duration = US_TO_NS(duration);\r\nif (rawir.pulse)\r\ndata->pulse_duration += duration;\r\nir_raw_event_store_with_filter(data->dev, &rawir);\r\n}\r\nir_raw_event_handle(data->dev);\r\n}\r\nstatic void\r\nwbcir_irq_tx(struct wbcir_data *data)\r\n{\r\nunsigned int space;\r\nunsigned int used;\r\nu8 bytes[16];\r\nu8 byte;\r\nif (!data->txbuf)\r\nreturn;\r\nswitch (data->txstate) {\r\ncase WBCIR_TXSTATE_INACTIVE:\r\nspace = 16;\r\nled_trigger_event(data->txtrigger, LED_FULL);\r\nbreak;\r\ncase WBCIR_TXSTATE_ACTIVE:\r\nspace = 13;\r\nbreak;\r\ncase WBCIR_TXSTATE_ERROR:\r\nspace = 0;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nfor (used = 0; used < space && data->txoff != data->txlen; used++) {\r\nif (data->txbuf[data->txoff] == 0) {\r\ndata->txoff++;\r\ncontinue;\r\n}\r\nbyte = min((u32)0x80, data->txbuf[data->txoff]);\r\ndata->txbuf[data->txoff] -= byte;\r\nbyte--;\r\nbyte |= (data->txoff % 2 ? 0x80 : 0x00);\r\nbytes[used] = byte;\r\n}\r\nwhile (data->txbuf[data->txoff] == 0 && data->txoff != data->txlen)\r\ndata->txoff++;\r\nif (used == 0) {\r\nif (data->txstate == WBCIR_TXSTATE_ERROR)\r\noutb(WBCIR_TX_UNDERRUN, data->sbase + WBCIR_REG_SP3_ASCR);\r\nwbcir_set_irqmask(data, WBCIR_IRQ_RX | WBCIR_IRQ_ERR);\r\nled_trigger_event(data->txtrigger, LED_OFF);\r\nkfree(data->txbuf);\r\ndata->txbuf = NULL;\r\ndata->txstate = WBCIR_TXSTATE_INACTIVE;\r\n} else if (data->txoff == data->txlen) {\r\noutsb(data->sbase + WBCIR_REG_SP3_TXDATA, bytes, used - 1);\r\noutb(WBCIR_TX_EOT, data->sbase + WBCIR_REG_SP3_ASCR);\r\noutb(bytes[used - 1], data->sbase + WBCIR_REG_SP3_TXDATA);\r\nwbcir_set_irqmask(data, WBCIR_IRQ_RX | WBCIR_IRQ_ERR |\r\nWBCIR_IRQ_TX_EMPTY);\r\n} else {\r\noutsb(data->sbase + WBCIR_REG_SP3_RXDATA, bytes, used);\r\nif (data->txstate == WBCIR_TXSTATE_INACTIVE) {\r\nwbcir_set_irqmask(data, WBCIR_IRQ_RX | WBCIR_IRQ_ERR |\r\nWBCIR_IRQ_TX_LOW);\r\ndata->txstate = WBCIR_TXSTATE_ACTIVE;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t\r\nwbcir_irq_handler(int irqno, void *cookie)\r\n{\r\nstruct pnp_dev *device = cookie;\r\nstruct wbcir_data *data = pnp_get_drvdata(device);\r\nunsigned long flags;\r\nu8 status;\r\nspin_lock_irqsave(&data->spinlock, flags);\r\nwbcir_select_bank(data, WBCIR_BANK_0);\r\nstatus = inb(data->sbase + WBCIR_REG_SP3_EIR);\r\nstatus &= data->irqmask;\r\nif (!status) {\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (status & WBCIR_IRQ_ERR) {\r\nif (inb(data->sbase + WBCIR_REG_SP3_LSR) & WBCIR_RX_OVERRUN) {\r\ndata->rxstate = WBCIR_RXSTATE_ERROR;\r\nir_raw_event_reset(data->dev);\r\n}\r\nif (inb(data->sbase + WBCIR_REG_SP3_ASCR) & WBCIR_TX_UNDERRUN)\r\ndata->txstate = WBCIR_TXSTATE_ERROR;\r\n}\r\nif (status & WBCIR_IRQ_RX)\r\nwbcir_irq_rx(data, device);\r\nif (status & (WBCIR_IRQ_TX_LOW | WBCIR_IRQ_TX_EMPTY))\r\nwbcir_irq_tx(data);\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nwbcir_set_carrier_report(struct rc_dev *dev, int enable)\r\n{\r\nstruct wbcir_data *data = dev->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&data->spinlock, flags);\r\nif (data->carrier_report_enabled == enable) {\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn 0;\r\n}\r\ndata->pulse_duration = 0;\r\nwbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CCTL, WBCIR_CNTR_R,\r\nWBCIR_CNTR_EN | WBCIR_CNTR_R);\r\nif (enable && data->dev->idle)\r\nwbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CCTL,\r\nWBCIR_CNTR_EN, WBCIR_CNTR_EN | WBCIR_CNTR_R);\r\nwbcir_select_bank(data, WBCIR_BANK_2);\r\ndata->dev->rx_resolution = US_TO_NS(enable ? 2 : 10);\r\noutb(enable ? 0x03 : 0x0f, data->sbase + WBCIR_REG_SP3_BGDL);\r\noutb(0x00, data->sbase + WBCIR_REG_SP3_BGDH);\r\nwbcir_select_bank(data, WBCIR_BANK_7);\r\nwbcir_set_bits(data->sbase + WBCIR_REG_SP3_RCCFG,\r\nenable ? WBCIR_RX_T_OV : 0, WBCIR_RX_T_OV);\r\ndata->carrier_report_enabled = enable;\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nwbcir_txcarrier(struct rc_dev *dev, u32 carrier)\r\n{\r\nstruct wbcir_data *data = dev->priv;\r\nunsigned long flags;\r\nu8 val;\r\nu32 freq;\r\nfreq = DIV_ROUND_CLOSEST(carrier, 1000);\r\nif (freq < 30 || freq > 60)\r\nreturn -EINVAL;\r\nswitch (freq) {\r\ncase 58:\r\ncase 59:\r\ncase 60:\r\nval = freq - 58;\r\nfreq *= 1000;\r\nbreak;\r\ncase 57:\r\nval = freq - 27;\r\nfreq = 56900;\r\nbreak;\r\ndefault:\r\nval = freq - 27;\r\nfreq *= 1000;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&data->spinlock, flags);\r\nif (data->txstate != WBCIR_TXSTATE_INACTIVE) {\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn -EBUSY;\r\n}\r\nif (data->txcarrier != freq) {\r\nwbcir_select_bank(data, WBCIR_BANK_7);\r\nwbcir_set_bits(data->sbase + WBCIR_REG_SP3_IRTXMC, val, 0x1F);\r\ndata->txcarrier = freq;\r\n}\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nwbcir_txmask(struct rc_dev *dev, u32 mask)\r\n{\r\nstruct wbcir_data *data = dev->priv;\r\nunsigned long flags;\r\nu8 val;\r\nswitch (mask) {\r\ncase 0x1:\r\nval = 0x0;\r\nbreak;\r\ncase 0x2:\r\nval = 0x1;\r\nbreak;\r\ncase 0x4:\r\nval = 0x2;\r\nbreak;\r\ncase 0x8:\r\nval = 0x3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&data->spinlock, flags);\r\nif (data->txstate != WBCIR_TXSTATE_INACTIVE) {\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn -EBUSY;\r\n}\r\nif (data->txmask != mask) {\r\nwbcir_set_bits(data->ebase + WBCIR_REG_ECEIR_CTS, val, 0x0c);\r\ndata->txmask = mask;\r\n}\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nwbcir_tx(struct rc_dev *dev, unsigned *b, unsigned count)\r\n{\r\nstruct wbcir_data *data = dev->priv;\r\nunsigned *buf;\r\nunsigned i;\r\nunsigned long flags;\r\nbuf = kmalloc(count * sizeof(*b), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < count; i++)\r\nbuf[i] = DIV_ROUND_CLOSEST(b[i], 10);\r\nspin_lock_irqsave(&data->spinlock, flags);\r\nif (data->txstate != WBCIR_TXSTATE_INACTIVE) {\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nkfree(buf);\r\nreturn -EBUSY;\r\n}\r\ndata->txbuf = buf;\r\ndata->txlen = count;\r\ndata->txoff = 0;\r\nwbcir_irq_tx(data);\r\nspin_unlock_irqrestore(&data->spinlock, flags);\r\nreturn count;\r\n}\r\nstatic void\r\nwbcir_shutdown(struct pnp_dev *device)\r\n{\r\nstruct device *dev = &device->dev;\r\nstruct wbcir_data *data = pnp_get_drvdata(device);\r\nbool do_wake = true;\r\nu8 match[11];\r\nu8 mask[11];\r\nu8 rc6_csl = 0;\r\nint i;\r\nmemset(match, 0, sizeof(match));\r\nmemset(mask, 0, sizeof(mask));\r\nif (wake_sc == INVALID_SCANCODE || !device_may_wakeup(dev)) {\r\ndo_wake = false;\r\ngoto finish;\r\n}\r\nswitch (protocol) {\r\ncase IR_PROTOCOL_RC5:\r\nif (wake_sc > 0xFFF) {\r\ndo_wake = false;\r\ndev_err(dev, "RC5 - Invalid wake scancode\n");\r\nbreak;\r\n}\r\nmask[0] = 0xFF;\r\nmask[1] = 0x17;\r\nmatch[0] = (wake_sc & 0x003F);\r\nmatch[0] |= (wake_sc & 0x0180) >> 1;\r\nmatch[1] = (wake_sc & 0x0E00) >> 9;\r\nif (!(wake_sc & 0x0040))\r\nmatch[1] |= 0x10;\r\nbreak;\r\ncase IR_PROTOCOL_NEC:\r\nif (wake_sc > 0xFFFFFF) {\r\ndo_wake = false;\r\ndev_err(dev, "NEC - Invalid wake scancode\n");\r\nbreak;\r\n}\r\nmask[0] = mask[1] = mask[2] = mask[3] = 0xFF;\r\nmatch[1] = bitrev8((wake_sc & 0xFF));\r\nmatch[0] = ~match[1];\r\nmatch[3] = bitrev8((wake_sc & 0xFF00) >> 8);\r\nif (wake_sc > 0xFFFF)\r\nmatch[2] = bitrev8((wake_sc & 0xFF0000) >> 16);\r\nelse\r\nmatch[2] = ~match[3];\r\nbreak;\r\ncase IR_PROTOCOL_RC6:\r\nif (wake_rc6mode == 0) {\r\nif (wake_sc > 0xFFFF) {\r\ndo_wake = false;\r\ndev_err(dev, "RC6 - Invalid wake scancode\n");\r\nbreak;\r\n}\r\nmatch[0] = wbcir_to_rc6cells(wake_sc >> 0);\r\nmask[0] = 0xFF;\r\nmatch[1] = wbcir_to_rc6cells(wake_sc >> 4);\r\nmask[1] = 0xFF;\r\nmatch[2] = wbcir_to_rc6cells(wake_sc >> 8);\r\nmask[2] = 0xFF;\r\nmatch[3] = wbcir_to_rc6cells(wake_sc >> 12);\r\nmask[3] = 0xFF;\r\nmatch[4] = 0x50;\r\nmask[4] = 0xF0;\r\nmatch[5] = 0x09;\r\nmask[5] = 0x0F;\r\nrc6_csl = 44;\r\n} else if (wake_rc6mode == 6) {\r\ni = 0;\r\nmatch[i] = wbcir_to_rc6cells(wake_sc >> 0);\r\nmask[i++] = 0xFF;\r\nmatch[i] = wbcir_to_rc6cells(wake_sc >> 4);\r\nmask[i++] = 0xFF;\r\nmatch[i] = wbcir_to_rc6cells(wake_sc >> 8);\r\nmask[i++] = 0xFF;\r\nmatch[i] = wbcir_to_rc6cells(wake_sc >> 12);\r\nmask[i++] = 0x3F;\r\nmatch[i] = wbcir_to_rc6cells(wake_sc >> 16);\r\nmask[i++] = 0xFF;\r\nmatch[i] = wbcir_to_rc6cells(wake_sc >> 20);\r\nmask[i++] = 0xFF;\r\nif (wake_sc & 0x80000000) {\r\nmatch[i] = wbcir_to_rc6cells(wake_sc >> 24);\r\nmask[i++] = 0xFF;\r\nmatch[i] = wbcir_to_rc6cells(wake_sc >> 28);\r\nmask[i++] = 0xFF;\r\nrc6_csl = 76;\r\n} else if (wake_sc <= 0x007FFFFF) {\r\nrc6_csl = 60;\r\n} else {\r\ndo_wake = false;\r\ndev_err(dev, "RC6 - Invalid wake scancode\n");\r\nbreak;\r\n}\r\nmatch[i] = 0x93;\r\nmask[i++] = 0xFF;\r\nmatch[i] = 0x0A;\r\nmask[i++] = 0x0F;\r\n} else {\r\ndo_wake = false;\r\ndev_err(dev, "RC6 - Invalid wake mode\n");\r\n}\r\nbreak;\r\ndefault:\r\ndo_wake = false;\r\nbreak;\r\n}\r\nfinish:\r\nif (do_wake) {\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_INDEX,\r\nWBCIR_REGSEL_COMPARE | WBCIR_REG_ADDR0,\r\n0x3F);\r\noutsb(data->wbase + WBCIR_REG_WCEIR_DATA, match, 11);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_INDEX,\r\nWBCIR_REGSEL_MASK | WBCIR_REG_ADDR0,\r\n0x3F);\r\noutsb(data->wbase + WBCIR_REG_WCEIR_DATA, mask, 11);\r\noutb(rc6_csl, data->wbase + WBCIR_REG_WCEIR_CSL);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_STS, 0x17, 0x17);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_EV_EN, 0x01, 0x07);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CTL, 0x01, 0x01);\r\n} else {\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_EV_EN, 0x00, 0x07);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CTL, 0x00, 0x01);\r\n}\r\nwbcir_set_irqmask(data, WBCIR_IRQ_NONE);\r\ndisable_irq(data->irq);\r\nled_trigger_event(data->rxtrigger, LED_OFF);\r\nled_trigger_event(data->txtrigger, LED_OFF);\r\n}\r\nstatic int\r\nwbcir_suspend(struct pnp_dev *device, pm_message_t state)\r\n{\r\nwbcir_shutdown(device);\r\nreturn 0;\r\n}\r\nstatic void\r\nwbcir_init_hw(struct wbcir_data *data)\r\n{\r\nu8 tmp;\r\nwbcir_set_irqmask(data, WBCIR_IRQ_NONE);\r\ntmp = protocol << 4;\r\nif (invert)\r\ntmp |= 0x08;\r\noutb(tmp, data->wbase + WBCIR_REG_WCEIR_CTL);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_STS, 0x17, 0x17);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_EV_EN, 0x00, 0x07);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CFG1, 0x4A, 0x7F);\r\nif (invert)\r\noutb(WBCIR_IRTX_INV, data->ebase + WBCIR_REG_ECEIR_CCTL);\r\nelse\r\noutb(0x00, data->ebase + WBCIR_REG_ECEIR_CCTL);\r\noutb(0x10, data->ebase + WBCIR_REG_ECEIR_CTS);\r\ndata->txmask = 0x1;\r\nwbcir_select_bank(data, WBCIR_BANK_2);\r\noutb(WBCIR_EXT_ENABLE, data->sbase + WBCIR_REG_SP3_EXCR1);\r\noutb(0x30, data->sbase + WBCIR_REG_SP3_EXCR2);\r\noutb(0x0f, data->sbase + WBCIR_REG_SP3_BGDL);\r\noutb(0x00, data->sbase + WBCIR_REG_SP3_BGDH);\r\nwbcir_select_bank(data, WBCIR_BANK_0);\r\noutb(0xC0, data->sbase + WBCIR_REG_SP3_MCR);\r\ninb(data->sbase + WBCIR_REG_SP3_LSR);\r\ninb(data->sbase + WBCIR_REG_SP3_MSR);\r\nwbcir_select_bank(data, WBCIR_BANK_7);\r\noutb(0x90, data->sbase + WBCIR_REG_SP3_RCCFG);\r\nwbcir_select_bank(data, WBCIR_BANK_4);\r\noutb(0x00, data->sbase + WBCIR_REG_SP3_IRCR1);\r\nwbcir_select_bank(data, WBCIR_BANK_5);\r\noutb(txandrx ? 0x03 : 0x02, data->sbase + WBCIR_REG_SP3_IRCR2);\r\nwbcir_select_bank(data, WBCIR_BANK_6);\r\noutb(0x20, data->sbase + WBCIR_REG_SP3_IRCR3);\r\nwbcir_select_bank(data, WBCIR_BANK_7);\r\noutb(0xF2, data->sbase + WBCIR_REG_SP3_IRRXDC);\r\noutb(0x69, data->sbase + WBCIR_REG_SP3_IRTXMC);\r\ndata->txcarrier = 36000;\r\nif (invert)\r\noutb(0x10, data->sbase + WBCIR_REG_SP3_IRCFG4);\r\nelse\r\noutb(0x00, data->sbase + WBCIR_REG_SP3_IRCFG4);\r\nwbcir_select_bank(data, WBCIR_BANK_0);\r\noutb(0x97, data->sbase + WBCIR_REG_SP3_FCR);\r\noutb(0xE0, data->sbase + WBCIR_REG_SP3_ASCR);\r\ndata->rxstate = WBCIR_RXSTATE_INACTIVE;\r\nir_raw_event_reset(data->dev);\r\nir_raw_event_set_idle(data->dev, true);\r\nif (data->txstate == WBCIR_TXSTATE_ACTIVE) {\r\nkfree(data->txbuf);\r\ndata->txbuf = NULL;\r\ndata->txstate = WBCIR_TXSTATE_INACTIVE;\r\n}\r\nwbcir_set_irqmask(data, WBCIR_IRQ_RX | WBCIR_IRQ_ERR);\r\n}\r\nstatic int\r\nwbcir_resume(struct pnp_dev *device)\r\n{\r\nstruct wbcir_data *data = pnp_get_drvdata(device);\r\nwbcir_init_hw(data);\r\nenable_irq(data->irq);\r\nreturn 0;\r\n}\r\nstatic int\r\nwbcir_probe(struct pnp_dev *device, const struct pnp_device_id *dev_id)\r\n{\r\nstruct device *dev = &device->dev;\r\nstruct wbcir_data *data;\r\nint err;\r\nif (!(pnp_port_len(device, 0) == EHFUNC_IOMEM_LEN &&\r\npnp_port_len(device, 1) == WAKEUP_IOMEM_LEN &&\r\npnp_port_len(device, 2) == SP_IOMEM_LEN)) {\r\ndev_err(dev, "Invalid resources\n");\r\nreturn -ENODEV;\r\n}\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\npnp_set_drvdata(device, data);\r\nspin_lock_init(&data->spinlock);\r\ndata->ebase = pnp_port_start(device, 0);\r\ndata->wbase = pnp_port_start(device, 1);\r\ndata->sbase = pnp_port_start(device, 2);\r\ndata->irq = pnp_irq(device, 0);\r\nif (data->wbase == 0 || data->ebase == 0 ||\r\ndata->sbase == 0 || data->irq == 0) {\r\nerr = -ENODEV;\r\ndev_err(dev, "Invalid resources\n");\r\ngoto exit_free_data;\r\n}\r\ndev_dbg(&device->dev, "Found device "\r\n"(w: 0x%lX, e: 0x%lX, s: 0x%lX, i: %u)\n",\r\ndata->wbase, data->ebase, data->sbase, data->irq);\r\nled_trigger_register_simple("cir-tx", &data->txtrigger);\r\nif (!data->txtrigger) {\r\nerr = -ENOMEM;\r\ngoto exit_free_data;\r\n}\r\nled_trigger_register_simple("cir-rx", &data->rxtrigger);\r\nif (!data->rxtrigger) {\r\nerr = -ENOMEM;\r\ngoto exit_unregister_txtrigger;\r\n}\r\ndata->led.name = "cir::activity";\r\ndata->led.default_trigger = "cir-rx";\r\ndata->led.brightness_set = wbcir_led_brightness_set;\r\ndata->led.brightness_get = wbcir_led_brightness_get;\r\nerr = led_classdev_register(&device->dev, &data->led);\r\nif (err)\r\ngoto exit_unregister_rxtrigger;\r\ndata->dev = rc_allocate_device();\r\nif (!data->dev) {\r\nerr = -ENOMEM;\r\ngoto exit_unregister_led;\r\n}\r\ndata->dev->driver_type = RC_DRIVER_IR_RAW;\r\ndata->dev->driver_name = DRVNAME;\r\ndata->dev->input_name = WBCIR_NAME;\r\ndata->dev->input_phys = "wbcir/cir0";\r\ndata->dev->input_id.bustype = BUS_HOST;\r\ndata->dev->input_id.vendor = PCI_VENDOR_ID_WINBOND;\r\ndata->dev->input_id.product = WBCIR_ID_FAMILY;\r\ndata->dev->input_id.version = WBCIR_ID_CHIP;\r\ndata->dev->map_name = RC_MAP_RC6_MCE;\r\ndata->dev->s_idle = wbcir_idle_rx;\r\ndata->dev->s_carrier_report = wbcir_set_carrier_report;\r\ndata->dev->s_tx_mask = wbcir_txmask;\r\ndata->dev->s_tx_carrier = wbcir_txcarrier;\r\ndata->dev->tx_ir = wbcir_tx;\r\ndata->dev->priv = data;\r\ndata->dev->dev.parent = &device->dev;\r\ndata->dev->timeout = MS_TO_NS(100);\r\ndata->dev->rx_resolution = US_TO_NS(2);\r\ndata->dev->allowed_protos = RC_BIT_ALL;\r\nerr = rc_register_device(data->dev);\r\nif (err)\r\ngoto exit_free_rc;\r\nif (!request_region(data->wbase, WAKEUP_IOMEM_LEN, DRVNAME)) {\r\ndev_err(dev, "Region 0x%lx-0x%lx already in use!\n",\r\ndata->wbase, data->wbase + WAKEUP_IOMEM_LEN - 1);\r\nerr = -EBUSY;\r\ngoto exit_unregister_device;\r\n}\r\nif (!request_region(data->ebase, EHFUNC_IOMEM_LEN, DRVNAME)) {\r\ndev_err(dev, "Region 0x%lx-0x%lx already in use!\n",\r\ndata->ebase, data->ebase + EHFUNC_IOMEM_LEN - 1);\r\nerr = -EBUSY;\r\ngoto exit_release_wbase;\r\n}\r\nif (!request_region(data->sbase, SP_IOMEM_LEN, DRVNAME)) {\r\ndev_err(dev, "Region 0x%lx-0x%lx already in use!\n",\r\ndata->sbase, data->sbase + SP_IOMEM_LEN - 1);\r\nerr = -EBUSY;\r\ngoto exit_release_ebase;\r\n}\r\nerr = request_irq(data->irq, wbcir_irq_handler,\r\nIRQF_DISABLED, DRVNAME, device);\r\nif (err) {\r\ndev_err(dev, "Failed to claim IRQ %u\n", data->irq);\r\nerr = -EBUSY;\r\ngoto exit_release_sbase;\r\n}\r\ndevice_init_wakeup(&device->dev, 1);\r\nwbcir_init_hw(data);\r\nreturn 0;\r\nexit_release_sbase:\r\nrelease_region(data->sbase, SP_IOMEM_LEN);\r\nexit_release_ebase:\r\nrelease_region(data->ebase, EHFUNC_IOMEM_LEN);\r\nexit_release_wbase:\r\nrelease_region(data->wbase, WAKEUP_IOMEM_LEN);\r\nexit_unregister_device:\r\nrc_unregister_device(data->dev);\r\ndata->dev = NULL;\r\nexit_free_rc:\r\nrc_free_device(data->dev);\r\nexit_unregister_led:\r\nled_classdev_unregister(&data->led);\r\nexit_unregister_rxtrigger:\r\nled_trigger_unregister_simple(data->rxtrigger);\r\nexit_unregister_txtrigger:\r\nled_trigger_unregister_simple(data->txtrigger);\r\nexit_free_data:\r\nkfree(data);\r\npnp_set_drvdata(device, NULL);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void\r\nwbcir_remove(struct pnp_dev *device)\r\n{\r\nstruct wbcir_data *data = pnp_get_drvdata(device);\r\nwbcir_set_irqmask(data, WBCIR_IRQ_NONE);\r\nfree_irq(data->irq, device);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_STS, 0x17, 0x17);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_CTL, 0x00, 0x01);\r\nwbcir_set_bits(data->wbase + WBCIR_REG_WCEIR_EV_EN, 0x00, 0x07);\r\nrc_unregister_device(data->dev);\r\nled_trigger_unregister_simple(data->rxtrigger);\r\nled_trigger_unregister_simple(data->txtrigger);\r\nled_classdev_unregister(&data->led);\r\nwbcir_led_brightness_set(&data->led, LED_OFF);\r\nrelease_region(data->wbase, WAKEUP_IOMEM_LEN);\r\nrelease_region(data->ebase, EHFUNC_IOMEM_LEN);\r\nrelease_region(data->sbase, SP_IOMEM_LEN);\r\nkfree(data);\r\npnp_set_drvdata(device, NULL);\r\n}\r\nstatic int __init\r\nwbcir_init(void)\r\n{\r\nint ret;\r\nswitch (protocol) {\r\ncase IR_PROTOCOL_RC5:\r\ncase IR_PROTOCOL_NEC:\r\ncase IR_PROTOCOL_RC6:\r\nbreak;\r\ndefault:\r\npr_err("Invalid power-on protocol\n");\r\n}\r\nret = pnp_register_driver(&wbcir_driver);\r\nif (ret)\r\npr_err("Unable to register driver\n");\r\nreturn ret;\r\n}\r\nstatic void __exit\r\nwbcir_exit(void)\r\n{\r\npnp_unregister_driver(&wbcir_driver);\r\n}
