static inline int queue_free(struct timestamp_event_queue *q)\r\n{\r\nreturn PTP_MAX_TIMESTAMPS - queue_cnt(q) - 1;\r\n}\r\nstatic void enqueue_external_timestamp(struct timestamp_event_queue *queue,\r\nstruct ptp_clock_event *src)\r\n{\r\nstruct ptp_extts_event *dst;\r\nunsigned long flags;\r\ns64 seconds;\r\nu32 remainder;\r\nseconds = div_u64_rem(src->timestamp, 1000000000, &remainder);\r\nspin_lock_irqsave(&queue->lock, flags);\r\ndst = &queue->buf[queue->tail];\r\ndst->index = src->index;\r\ndst->t.sec = seconds;\r\ndst->t.nsec = remainder;\r\nif (!queue_free(queue))\r\nqueue->head = (queue->head + 1) % PTP_MAX_TIMESTAMPS;\r\nqueue->tail = (queue->tail + 1) % PTP_MAX_TIMESTAMPS;\r\nspin_unlock_irqrestore(&queue->lock, flags);\r\n}\r\nstatic s32 scaled_ppm_to_ppb(long ppm)\r\n{\r\ns64 ppb = 1 + ppm;\r\nppb *= 125;\r\nppb >>= 13;\r\nreturn (s32) ppb;\r\n}\r\nstatic int ptp_clock_getres(struct posix_clock *pc, struct timespec *tp)\r\n{\r\ntp->tv_sec = 0;\r\ntp->tv_nsec = 1;\r\nreturn 0;\r\n}\r\nstatic int ptp_clock_settime(struct posix_clock *pc, const struct timespec *tp)\r\n{\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\nreturn ptp->info->settime(ptp->info, tp);\r\n}\r\nstatic int ptp_clock_gettime(struct posix_clock *pc, struct timespec *tp)\r\n{\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\nreturn ptp->info->gettime(ptp->info, tp);\r\n}\r\nstatic int ptp_clock_adjtime(struct posix_clock *pc, struct timex *tx)\r\n{\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\nstruct ptp_clock_info *ops;\r\nint err = -EOPNOTSUPP;\r\nops = ptp->info;\r\nif (tx->modes & ADJ_SETOFFSET) {\r\nstruct timespec ts;\r\nktime_t kt;\r\ns64 delta;\r\nts.tv_sec = tx->time.tv_sec;\r\nts.tv_nsec = tx->time.tv_usec;\r\nif (!(tx->modes & ADJ_NANO))\r\nts.tv_nsec *= 1000;\r\nif ((unsigned long) ts.tv_nsec >= NSEC_PER_SEC)\r\nreturn -EINVAL;\r\nkt = timespec_to_ktime(ts);\r\ndelta = ktime_to_ns(kt);\r\nerr = ops->adjtime(ops, delta);\r\n} else if (tx->modes & ADJ_FREQUENCY) {\r\nerr = ops->adjfreq(ops, scaled_ppm_to_ppb(tx->freq));\r\nptp->dialed_frequency = tx->freq;\r\n} else if (tx->modes == 0) {\r\ntx->freq = ptp->dialed_frequency;\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic void delete_ptp_clock(struct posix_clock *pc)\r\n{\r\nstruct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);\r\nmutex_destroy(&ptp->tsevq_mux);\r\nida_simple_remove(&ptp_clocks_map, ptp->index);\r\nkfree(ptp);\r\n}\r\nstruct ptp_clock *ptp_clock_register(struct ptp_clock_info *info,\r\nstruct device *parent)\r\n{\r\nstruct ptp_clock *ptp;\r\nint err = 0, index, major = MAJOR(ptp_devt);\r\nif (info->n_alarm > PTP_MAX_ALARMS)\r\nreturn ERR_PTR(-EINVAL);\r\nerr = -ENOMEM;\r\nptp = kzalloc(sizeof(struct ptp_clock), GFP_KERNEL);\r\nif (ptp == NULL)\r\ngoto no_memory;\r\nindex = ida_simple_get(&ptp_clocks_map, 0, MINORMASK + 1, GFP_KERNEL);\r\nif (index < 0) {\r\nerr = index;\r\ngoto no_slot;\r\n}\r\nptp->clock.ops = ptp_clock_ops;\r\nptp->clock.release = delete_ptp_clock;\r\nptp->info = info;\r\nptp->devid = MKDEV(major, index);\r\nptp->index = index;\r\nspin_lock_init(&ptp->tsevq.lock);\r\nmutex_init(&ptp->tsevq_mux);\r\ninit_waitqueue_head(&ptp->tsev_wq);\r\nptp->dev = device_create(ptp_class, parent, ptp->devid, ptp,\r\n"ptp%d", ptp->index);\r\nif (IS_ERR(ptp->dev))\r\ngoto no_device;\r\ndev_set_drvdata(ptp->dev, ptp);\r\nerr = ptp_populate_sysfs(ptp);\r\nif (err)\r\ngoto no_sysfs;\r\nif (info->pps) {\r\nstruct pps_source_info pps;\r\nmemset(&pps, 0, sizeof(pps));\r\nsnprintf(pps.name, PPS_MAX_NAME_LEN, "ptp%d", index);\r\npps.mode = PTP_PPS_MODE;\r\npps.owner = info->owner;\r\nptp->pps_source = pps_register_source(&pps, PTP_PPS_DEFAULTS);\r\nif (!ptp->pps_source) {\r\npr_err("failed to register pps source\n");\r\ngoto no_pps;\r\n}\r\n}\r\nerr = posix_clock_register(&ptp->clock, ptp->devid);\r\nif (err) {\r\npr_err("failed to create posix clock\n");\r\ngoto no_clock;\r\n}\r\nreturn ptp;\r\nno_clock:\r\nif (ptp->pps_source)\r\npps_unregister_source(ptp->pps_source);\r\nno_pps:\r\nptp_cleanup_sysfs(ptp);\r\nno_sysfs:\r\ndevice_destroy(ptp_class, ptp->devid);\r\nno_device:\r\nmutex_destroy(&ptp->tsevq_mux);\r\nno_slot:\r\nkfree(ptp);\r\nno_memory:\r\nreturn ERR_PTR(err);\r\n}\r\nint ptp_clock_unregister(struct ptp_clock *ptp)\r\n{\r\nptp->defunct = 1;\r\nwake_up_interruptible(&ptp->tsev_wq);\r\nif (ptp->pps_source)\r\npps_unregister_source(ptp->pps_source);\r\nptp_cleanup_sysfs(ptp);\r\ndevice_destroy(ptp_class, ptp->devid);\r\nposix_clock_unregister(&ptp->clock);\r\nreturn 0;\r\n}\r\nvoid ptp_clock_event(struct ptp_clock *ptp, struct ptp_clock_event *event)\r\n{\r\nstruct pps_event_time evt;\r\nswitch (event->type) {\r\ncase PTP_CLOCK_ALARM:\r\nbreak;\r\ncase PTP_CLOCK_EXTTS:\r\nenqueue_external_timestamp(&ptp->tsevq, event);\r\nwake_up_interruptible(&ptp->tsev_wq);\r\nbreak;\r\ncase PTP_CLOCK_PPS:\r\npps_get_ts(&evt);\r\npps_event(ptp->pps_source, &evt, PTP_PPS_EVENT, NULL);\r\nbreak;\r\ncase PTP_CLOCK_PPSUSR:\r\npps_event(ptp->pps_source, &event->pps_times,\r\nPTP_PPS_EVENT, NULL);\r\nbreak;\r\n}\r\n}\r\nint ptp_clock_index(struct ptp_clock *ptp)\r\n{\r\nreturn ptp->index;\r\n}\r\nstatic void __exit ptp_exit(void)\r\n{\r\nclass_destroy(ptp_class);\r\nunregister_chrdev_region(ptp_devt, MINORMASK + 1);\r\nida_destroy(&ptp_clocks_map);\r\n}\r\nstatic int __init ptp_init(void)\r\n{\r\nint err;\r\nptp_class = class_create(THIS_MODULE, "ptp");\r\nif (IS_ERR(ptp_class)) {\r\npr_err("ptp: failed to allocate class\n");\r\nreturn PTR_ERR(ptp_class);\r\n}\r\nerr = alloc_chrdev_region(&ptp_devt, 0, MINORMASK + 1, "ptp");\r\nif (err < 0) {\r\npr_err("ptp: failed to allocate device region\n");\r\ngoto no_region;\r\n}\r\nptp_class->dev_attrs = ptp_dev_attrs;\r\npr_info("PTP clock support registered\n");\r\nreturn 0;\r\nno_region:\r\nclass_destroy(ptp_class);\r\nreturn err;\r\n}
