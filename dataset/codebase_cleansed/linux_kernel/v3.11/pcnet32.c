static u16 pcnet32_wio_read_csr(unsigned long addr, int index)\r\n{\r\noutw(index, addr + PCNET32_WIO_RAP);\r\nreturn inw(addr + PCNET32_WIO_RDP);\r\n}\r\nstatic void pcnet32_wio_write_csr(unsigned long addr, int index, u16 val)\r\n{\r\noutw(index, addr + PCNET32_WIO_RAP);\r\noutw(val, addr + PCNET32_WIO_RDP);\r\n}\r\nstatic u16 pcnet32_wio_read_bcr(unsigned long addr, int index)\r\n{\r\noutw(index, addr + PCNET32_WIO_RAP);\r\nreturn inw(addr + PCNET32_WIO_BDP);\r\n}\r\nstatic void pcnet32_wio_write_bcr(unsigned long addr, int index, u16 val)\r\n{\r\noutw(index, addr + PCNET32_WIO_RAP);\r\noutw(val, addr + PCNET32_WIO_BDP);\r\n}\r\nstatic u16 pcnet32_wio_read_rap(unsigned long addr)\r\n{\r\nreturn inw(addr + PCNET32_WIO_RAP);\r\n}\r\nstatic void pcnet32_wio_write_rap(unsigned long addr, u16 val)\r\n{\r\noutw(val, addr + PCNET32_WIO_RAP);\r\n}\r\nstatic void pcnet32_wio_reset(unsigned long addr)\r\n{\r\ninw(addr + PCNET32_WIO_RESET);\r\n}\r\nstatic int pcnet32_wio_check(unsigned long addr)\r\n{\r\noutw(88, addr + PCNET32_WIO_RAP);\r\nreturn inw(addr + PCNET32_WIO_RAP) == 88;\r\n}\r\nstatic u16 pcnet32_dwio_read_csr(unsigned long addr, int index)\r\n{\r\noutl(index, addr + PCNET32_DWIO_RAP);\r\nreturn inl(addr + PCNET32_DWIO_RDP) & 0xffff;\r\n}\r\nstatic void pcnet32_dwio_write_csr(unsigned long addr, int index, u16 val)\r\n{\r\noutl(index, addr + PCNET32_DWIO_RAP);\r\noutl(val, addr + PCNET32_DWIO_RDP);\r\n}\r\nstatic u16 pcnet32_dwio_read_bcr(unsigned long addr, int index)\r\n{\r\noutl(index, addr + PCNET32_DWIO_RAP);\r\nreturn inl(addr + PCNET32_DWIO_BDP) & 0xffff;\r\n}\r\nstatic void pcnet32_dwio_write_bcr(unsigned long addr, int index, u16 val)\r\n{\r\noutl(index, addr + PCNET32_DWIO_RAP);\r\noutl(val, addr + PCNET32_DWIO_BDP);\r\n}\r\nstatic u16 pcnet32_dwio_read_rap(unsigned long addr)\r\n{\r\nreturn inl(addr + PCNET32_DWIO_RAP) & 0xffff;\r\n}\r\nstatic void pcnet32_dwio_write_rap(unsigned long addr, u16 val)\r\n{\r\noutl(val, addr + PCNET32_DWIO_RAP);\r\n}\r\nstatic void pcnet32_dwio_reset(unsigned long addr)\r\n{\r\ninl(addr + PCNET32_DWIO_RESET);\r\n}\r\nstatic int pcnet32_dwio_check(unsigned long addr)\r\n{\r\noutl(88, addr + PCNET32_DWIO_RAP);\r\nreturn (inl(addr + PCNET32_DWIO_RAP) & 0xffff) == 88;\r\n}\r\nstatic void pcnet32_netif_stop(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\ndev->trans_start = jiffies;\r\nnapi_disable(&lp->napi);\r\nnetif_tx_disable(dev);\r\n}\r\nstatic void pcnet32_netif_start(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nulong ioaddr = dev->base_addr;\r\nu16 val;\r\nnetif_wake_queue(dev);\r\nval = lp->a->read_csr(ioaddr, CSR3);\r\nval &= 0x00ff;\r\nlp->a->write_csr(ioaddr, CSR3, val);\r\nnapi_enable(&lp->napi);\r\n}\r\nstatic void pcnet32_realloc_tx_ring(struct net_device *dev,\r\nstruct pcnet32_private *lp,\r\nunsigned int size)\r\n{\r\ndma_addr_t new_ring_dma_addr;\r\ndma_addr_t *new_dma_addr_list;\r\nstruct pcnet32_tx_head *new_tx_ring;\r\nstruct sk_buff **new_skb_list;\r\npcnet32_purge_tx_ring(dev);\r\nnew_tx_ring = pci_alloc_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_tx_head) *\r\n(1 << size),\r\n&new_ring_dma_addr);\r\nif (new_tx_ring == NULL) {\r\nnetif_err(lp, drv, dev, "Consistent memory allocation failed\n");\r\nreturn;\r\n}\r\nmemset(new_tx_ring, 0, sizeof(struct pcnet32_tx_head) * (1 << size));\r\nnew_dma_addr_list = kcalloc(1 << size, sizeof(dma_addr_t),\r\nGFP_ATOMIC);\r\nif (!new_dma_addr_list)\r\ngoto free_new_tx_ring;\r\nnew_skb_list = kcalloc(1 << size, sizeof(struct sk_buff *),\r\nGFP_ATOMIC);\r\nif (!new_skb_list)\r\ngoto free_new_lists;\r\nkfree(lp->tx_skbuff);\r\nkfree(lp->tx_dma_addr);\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_tx_head) *\r\nlp->tx_ring_size, lp->tx_ring,\r\nlp->tx_ring_dma_addr);\r\nlp->tx_ring_size = (1 << size);\r\nlp->tx_mod_mask = lp->tx_ring_size - 1;\r\nlp->tx_len_bits = (size << 12);\r\nlp->tx_ring = new_tx_ring;\r\nlp->tx_ring_dma_addr = new_ring_dma_addr;\r\nlp->tx_dma_addr = new_dma_addr_list;\r\nlp->tx_skbuff = new_skb_list;\r\nreturn;\r\nfree_new_lists:\r\nkfree(new_dma_addr_list);\r\nfree_new_tx_ring:\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_tx_head) *\r\n(1 << size),\r\nnew_tx_ring,\r\nnew_ring_dma_addr);\r\n}\r\nstatic void pcnet32_realloc_rx_ring(struct net_device *dev,\r\nstruct pcnet32_private *lp,\r\nunsigned int size)\r\n{\r\ndma_addr_t new_ring_dma_addr;\r\ndma_addr_t *new_dma_addr_list;\r\nstruct pcnet32_rx_head *new_rx_ring;\r\nstruct sk_buff **new_skb_list;\r\nint new, overlap;\r\nnew_rx_ring = pci_alloc_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_rx_head) *\r\n(1 << size),\r\n&new_ring_dma_addr);\r\nif (new_rx_ring == NULL) {\r\nnetif_err(lp, drv, dev, "Consistent memory allocation failed\n");\r\nreturn;\r\n}\r\nmemset(new_rx_ring, 0, sizeof(struct pcnet32_rx_head) * (1 << size));\r\nnew_dma_addr_list = kcalloc(1 << size, sizeof(dma_addr_t), GFP_ATOMIC);\r\nif (!new_dma_addr_list)\r\ngoto free_new_rx_ring;\r\nnew_skb_list = kcalloc(1 << size, sizeof(struct sk_buff *),\r\nGFP_ATOMIC);\r\nif (!new_skb_list)\r\ngoto free_new_lists;\r\noverlap = min(size, lp->rx_ring_size);\r\nfor (new = 0; new < overlap; new++) {\r\nnew_rx_ring[new] = lp->rx_ring[new];\r\nnew_dma_addr_list[new] = lp->rx_dma_addr[new];\r\nnew_skb_list[new] = lp->rx_skbuff[new];\r\n}\r\nfor (; new < size; new++) {\r\nstruct sk_buff *rx_skbuff;\r\nnew_skb_list[new] = netdev_alloc_skb(dev, PKT_BUF_SKB);\r\nrx_skbuff = new_skb_list[new];\r\nif (!rx_skbuff) {\r\nnetif_err(lp, drv, dev, "%s netdev_alloc_skb failed\n",\r\n__func__);\r\ngoto free_all_new;\r\n}\r\nskb_reserve(rx_skbuff, NET_IP_ALIGN);\r\nnew_dma_addr_list[new] =\r\npci_map_single(lp->pci_dev, rx_skbuff->data,\r\nPKT_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\nnew_rx_ring[new].base = cpu_to_le32(new_dma_addr_list[new]);\r\nnew_rx_ring[new].buf_length = cpu_to_le16(NEG_BUF_SIZE);\r\nnew_rx_ring[new].status = cpu_to_le16(0x8000);\r\n}\r\nfor (; new < lp->rx_ring_size; new++) {\r\nif (lp->rx_skbuff[new]) {\r\npci_unmap_single(lp->pci_dev, lp->rx_dma_addr[new],\r\nPKT_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(lp->rx_skbuff[new]);\r\n}\r\n}\r\nkfree(lp->rx_skbuff);\r\nkfree(lp->rx_dma_addr);\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_rx_head) *\r\nlp->rx_ring_size, lp->rx_ring,\r\nlp->rx_ring_dma_addr);\r\nlp->rx_ring_size = (1 << size);\r\nlp->rx_mod_mask = lp->rx_ring_size - 1;\r\nlp->rx_len_bits = (size << 4);\r\nlp->rx_ring = new_rx_ring;\r\nlp->rx_ring_dma_addr = new_ring_dma_addr;\r\nlp->rx_dma_addr = new_dma_addr_list;\r\nlp->rx_skbuff = new_skb_list;\r\nreturn;\r\nfree_all_new:\r\nwhile (--new >= lp->rx_ring_size) {\r\nif (new_skb_list[new]) {\r\npci_unmap_single(lp->pci_dev, new_dma_addr_list[new],\r\nPKT_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(new_skb_list[new]);\r\n}\r\n}\r\nkfree(new_skb_list);\r\nfree_new_lists:\r\nkfree(new_dma_addr_list);\r\nfree_new_rx_ring:\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_rx_head) *\r\n(1 << size),\r\nnew_rx_ring,\r\nnew_ring_dma_addr);\r\n}\r\nstatic void pcnet32_purge_rx_ring(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < lp->rx_ring_size; i++) {\r\nlp->rx_ring[i].status = 0;\r\nwmb();\r\nif (lp->rx_skbuff[i]) {\r\npci_unmap_single(lp->pci_dev, lp->rx_dma_addr[i],\r\nPKT_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb_any(lp->rx_skbuff[i]);\r\n}\r\nlp->rx_skbuff[i] = NULL;\r\nlp->rx_dma_addr[i] = 0;\r\n}\r\n}\r\nstatic void pcnet32_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\npcnet32_interrupt(0, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int pcnet32_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nint r = -EOPNOTSUPP;\r\nif (lp->mii) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nmii_ethtool_gset(&lp->mii_if, cmd);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nr = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic int pcnet32_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nint r = -EOPNOTSUPP;\r\nif (lp->mii) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nr = mii_ethtool_sset(&lp->mii_if, cmd);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nreturn r;\r\n}\r\nstatic void pcnet32_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nif (lp->pci_dev)\r\nstrlcpy(info->bus_info, pci_name(lp->pci_dev),\r\nsizeof(info->bus_info));\r\nelse\r\nsnprintf(info->bus_info, sizeof(info->bus_info),\r\n"VLB 0x%lx", dev->base_addr);\r\n}\r\nstatic u32 pcnet32_get_link(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (lp->mii) {\r\nr = mii_link_ok(&lp->mii_if);\r\n} else if (lp->chip_version >= PCNET32_79C970A) {\r\nulong ioaddr = dev->base_addr;\r\nr = (lp->a->read_bcr(ioaddr, 4) != 0xc0);\r\n} else {\r\nr = 1;\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn r;\r\n}\r\nstatic u32 pcnet32_get_msglevel(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nreturn lp->msg_enable;\r\n}\r\nstatic void pcnet32_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nlp->msg_enable = value;\r\n}\r\nstatic int pcnet32_nway_reset(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nint r = -EOPNOTSUPP;\r\nif (lp->mii) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nr = mii_nway_restart(&lp->mii_if);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nreturn r;\r\n}\r\nstatic void pcnet32_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nering->tx_max_pending = TX_MAX_RING_SIZE;\r\nering->tx_pending = lp->tx_ring_size;\r\nering->rx_max_pending = RX_MAX_RING_SIZE;\r\nering->rx_pending = lp->rx_ring_size;\r\n}\r\nstatic int pcnet32_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nunsigned int size;\r\nulong ioaddr = dev->base_addr;\r\nint i;\r\nif (ering->rx_mini_pending || ering->rx_jumbo_pending)\r\nreturn -EINVAL;\r\nif (netif_running(dev))\r\npcnet32_netif_stop(dev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\r\nsize = min(ering->tx_pending, (unsigned int)TX_MAX_RING_SIZE);\r\nfor (i = 2; i <= PCNET32_LOG_MAX_TX_BUFFERS; i++) {\r\nif (size <= (1 << i))\r\nbreak;\r\n}\r\nif ((1 << i) != lp->tx_ring_size)\r\npcnet32_realloc_tx_ring(dev, lp, i);\r\nsize = min(ering->rx_pending, (unsigned int)RX_MAX_RING_SIZE);\r\nfor (i = 2; i <= PCNET32_LOG_MAX_RX_BUFFERS; i++) {\r\nif (size <= (1 << i))\r\nbreak;\r\n}\r\nif ((1 << i) != lp->rx_ring_size)\r\npcnet32_realloc_rx_ring(dev, lp, i);\r\nlp->napi.weight = lp->rx_ring_size / 2;\r\nif (netif_running(dev)) {\r\npcnet32_netif_start(dev);\r\npcnet32_restart(dev, CSR0_NORMAL);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nnetif_info(lp, drv, dev, "Ring Param Settings: RX: %d, TX: %d\n",\r\nlp->rx_ring_size, lp->tx_ring_size);\r\nreturn 0;\r\n}\r\nstatic void pcnet32_get_strings(struct net_device *dev, u32 stringset,\r\nu8 *data)\r\n{\r\nmemcpy(data, pcnet32_gstrings_test, sizeof(pcnet32_gstrings_test));\r\n}\r\nstatic int pcnet32_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn PCNET32_TEST_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void pcnet32_ethtool_test(struct net_device *dev,\r\nstruct ethtool_test *test, u64 * data)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint rc;\r\nif (test->flags == ETH_TEST_FL_OFFLINE) {\r\nrc = pcnet32_loopback_test(dev, data);\r\nif (rc) {\r\nnetif_printk(lp, hw, KERN_DEBUG, dev,\r\n"Loopback test failed\n");\r\ntest->flags |= ETH_TEST_FL_FAILED;\r\n} else\r\nnetif_printk(lp, hw, KERN_DEBUG, dev,\r\n"Loopback test passed\n");\r\n} else\r\nnetif_printk(lp, hw, KERN_DEBUG, dev,\r\n"No tests to run (specify 'Offline' on ethtool)\n");\r\n}\r\nstatic int pcnet32_loopback_test(struct net_device *dev, uint64_t * data1)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nconst struct pcnet32_access *a = lp->a;\r\nulong ioaddr = dev->base_addr;\r\nstruct sk_buff *skb;\r\nint x, i;\r\nint numbuffs = 4;\r\nu16 status = 0x8300;\r\n__le16 teststatus;\r\nint rc;\r\nint size;\r\nunsigned char *packet;\r\nstatic const int data_len = 60;\r\nunsigned long flags;\r\nunsigned long ticks;\r\nrc = 1;\r\nif (netif_running(dev))\r\npcnet32_netif_stop(dev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\r\nnumbuffs = min(numbuffs, (int)min(lp->rx_ring_size, lp->tx_ring_size));\r\nlp->a->reset(ioaddr);\r\nlp->a->write_csr(ioaddr, CSR4, 0x0915);\r\nlp->a->write_bcr(ioaddr, 20, 2);\r\npcnet32_restart(dev, 0x0000);\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\r\nsize = data_len + 15;\r\nfor (x = 0; x < numbuffs; x++) {\r\nskb = netdev_alloc_skb(dev, size);\r\nif (!skb) {\r\nnetif_printk(lp, hw, KERN_DEBUG, dev,\r\n"Cannot allocate skb at line: %d!\n",\r\n__LINE__);\r\ngoto clean_up;\r\n}\r\npacket = skb->data;\r\nskb_put(skb, size);\r\nlp->tx_skbuff[x] = skb;\r\nlp->tx_ring[x].length = cpu_to_le16(-skb->len);\r\nlp->tx_ring[x].misc = 0;\r\nfor (i = 0; i < 6; i++)\r\n*packet++ = dev->dev_addr[i];\r\nfor (i = 0; i < 6; i++)\r\n*packet++ = dev->dev_addr[i];\r\n*packet++ = 0x08;\r\n*packet++ = 0x06;\r\n*packet++ = x;\r\nfor (i = 0; i < data_len; i++)\r\n*packet++ = i;\r\nlp->tx_dma_addr[x] =\r\npci_map_single(lp->pci_dev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nlp->tx_ring[x].base = cpu_to_le32(lp->tx_dma_addr[x]);\r\nwmb();\r\nlp->tx_ring[x].status = cpu_to_le16(status);\r\n}\r\nx = a->read_bcr(ioaddr, 32);\r\na->write_bcr(ioaddr, 32, x | 0x0002);\r\nx = a->read_csr(ioaddr, CSR15) & 0xfffc;\r\nlp->a->write_csr(ioaddr, CSR15, x | 0x0044);\r\nteststatus = cpu_to_le16(0x8000);\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_START);\r\nfor (x = 0; x < numbuffs; x++) {\r\nticks = 0;\r\nrmb();\r\nwhile ((lp->rx_ring[x].status & teststatus) && (ticks < 200)) {\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nmsleep(1);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nrmb();\r\nticks++;\r\n}\r\nif (ticks == 200) {\r\nnetif_err(lp, hw, dev, "Desc %d failed to reset!\n", x);\r\nbreak;\r\n}\r\n}\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\r\nwmb();\r\nif (netif_msg_hw(lp) && netif_msg_pktdata(lp)) {\r\nnetdev_printk(KERN_DEBUG, dev, "RX loopback packets:\n");\r\nfor (x = 0; x < numbuffs; x++) {\r\nnetdev_printk(KERN_DEBUG, dev, "Packet %d: ", x);\r\nskb = lp->rx_skbuff[x];\r\nfor (i = 0; i < size; i++)\r\npr_cont(" %02x", *(skb->data + i));\r\npr_cont("\n");\r\n}\r\n}\r\nx = 0;\r\nrc = 0;\r\nwhile (x < numbuffs && !rc) {\r\nskb = lp->rx_skbuff[x];\r\npacket = lp->tx_skbuff[x]->data;\r\nfor (i = 0; i < size; i++) {\r\nif (*(skb->data + i) != packet[i]) {\r\nnetif_printk(lp, hw, KERN_DEBUG, dev,\r\n"Error in compare! %2x - %02x %02x\n",\r\ni, *(skb->data + i), packet[i]);\r\nrc = 1;\r\nbreak;\r\n}\r\n}\r\nx++;\r\n}\r\nclean_up:\r\n*data1 = rc;\r\npcnet32_purge_tx_ring(dev);\r\nx = a->read_csr(ioaddr, CSR15);\r\na->write_csr(ioaddr, CSR15, (x & ~0x0044));\r\nx = a->read_bcr(ioaddr, 32);\r\na->write_bcr(ioaddr, 32, (x & ~0x0002));\r\nif (netif_running(dev)) {\r\npcnet32_netif_start(dev);\r\npcnet32_restart(dev, CSR0_NORMAL);\r\n} else {\r\npcnet32_purge_rx_ring(dev);\r\nlp->a->write_bcr(ioaddr, 20, 4);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int pcnet32_set_phys_id(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nconst struct pcnet32_access *a = lp->a;\r\nulong ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nint i;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nspin_lock_irqsave(&lp->lock, flags);\r\nfor (i = 4; i < 8; i++)\r\nlp->save_regs[i - 4] = a->read_bcr(ioaddr, i);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn 2;\r\ncase ETHTOOL_ID_ON:\r\ncase ETHTOOL_ID_OFF:\r\nspin_lock_irqsave(&lp->lock, flags);\r\nfor (i = 4; i < 8; i++)\r\na->write_bcr(ioaddr, i, a->read_bcr(ioaddr, i) ^ 0x4000);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nspin_lock_irqsave(&lp->lock, flags);\r\nfor (i = 4; i < 8; i++)\r\na->write_bcr(ioaddr, i, lp->save_regs[i - 4]);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcnet32_suspend(struct net_device *dev, unsigned long *flags,\r\nint can_sleep)\r\n{\r\nint csr5;\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nconst struct pcnet32_access *a = lp->a;\r\nulong ioaddr = dev->base_addr;\r\nint ticks;\r\nif (lp->chip_version < PCNET32_79C970A)\r\nreturn 0;\r\ncsr5 = a->read_csr(ioaddr, CSR5);\r\na->write_csr(ioaddr, CSR5, csr5 | CSR5_SUSPEND);\r\nticks = 0;\r\nwhile (!(a->read_csr(ioaddr, CSR5) & CSR5_SUSPEND)) {\r\nspin_unlock_irqrestore(&lp->lock, *flags);\r\nif (can_sleep)\r\nmsleep(1);\r\nelse\r\nmdelay(1);\r\nspin_lock_irqsave(&lp->lock, *flags);\r\nticks++;\r\nif (ticks > 200) {\r\nnetif_printk(lp, hw, KERN_DEBUG, dev,\r\n"Error getting into suspend!\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void pcnet32_rx_entry(struct net_device *dev,\r\nstruct pcnet32_private *lp,\r\nstruct pcnet32_rx_head *rxp,\r\nint entry)\r\n{\r\nint status = (short)le16_to_cpu(rxp->status) >> 8;\r\nint rx_in_place = 0;\r\nstruct sk_buff *skb;\r\nshort pkt_len;\r\nif (status != 0x03) {\r\nif (status & 0x01)\r\ndev->stats.rx_errors++;\r\nif (status & 0x20)\r\ndev->stats.rx_frame_errors++;\r\nif (status & 0x10)\r\ndev->stats.rx_over_errors++;\r\nif (status & 0x08)\r\ndev->stats.rx_crc_errors++;\r\nif (status & 0x04)\r\ndev->stats.rx_fifo_errors++;\r\nreturn;\r\n}\r\npkt_len = (le32_to_cpu(rxp->msg_length) & 0xfff) - 4;\r\nif (unlikely(pkt_len > PKT_BUF_SIZE)) {\r\nnetif_err(lp, drv, dev, "Impossible packet size %d!\n",\r\npkt_len);\r\ndev->stats.rx_errors++;\r\nreturn;\r\n}\r\nif (pkt_len < 60) {\r\nnetif_err(lp, rx_err, dev, "Runt packet!\n");\r\ndev->stats.rx_errors++;\r\nreturn;\r\n}\r\nif (pkt_len > rx_copybreak) {\r\nstruct sk_buff *newskb;\r\nnewskb = netdev_alloc_skb(dev, PKT_BUF_SKB);\r\nif (newskb) {\r\nskb_reserve(newskb, NET_IP_ALIGN);\r\nskb = lp->rx_skbuff[entry];\r\npci_unmap_single(lp->pci_dev,\r\nlp->rx_dma_addr[entry],\r\nPKT_BUF_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nskb_put(skb, pkt_len);\r\nlp->rx_skbuff[entry] = newskb;\r\nlp->rx_dma_addr[entry] =\r\npci_map_single(lp->pci_dev,\r\nnewskb->data,\r\nPKT_BUF_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nrxp->base = cpu_to_le32(lp->rx_dma_addr[entry]);\r\nrx_in_place = 1;\r\n} else\r\nskb = NULL;\r\n} else\r\nskb = netdev_alloc_skb(dev, pkt_len + NET_IP_ALIGN);\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nif (!rx_in_place) {\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nskb_put(skb, pkt_len);\r\npci_dma_sync_single_for_cpu(lp->pci_dev,\r\nlp->rx_dma_addr[entry],\r\npkt_len,\r\nPCI_DMA_FROMDEVICE);\r\nskb_copy_to_linear_data(skb,\r\n(unsigned char *)(lp->rx_skbuff[entry]->data),\r\npkt_len);\r\npci_dma_sync_single_for_device(lp->pci_dev,\r\nlp->rx_dma_addr[entry],\r\npkt_len,\r\nPCI_DMA_FROMDEVICE);\r\n}\r\ndev->stats.rx_bytes += skb->len;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nstatic int pcnet32_rx(struct net_device *dev, int budget)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint entry = lp->cur_rx & lp->rx_mod_mask;\r\nstruct pcnet32_rx_head *rxp = &lp->rx_ring[entry];\r\nint npackets = 0;\r\nwhile (npackets < budget && (short)le16_to_cpu(rxp->status) >= 0) {\r\npcnet32_rx_entry(dev, lp, rxp, entry);\r\nnpackets += 1;\r\nrxp->buf_length = cpu_to_le16(NEG_BUF_SIZE);\r\nwmb();\r\nrxp->status = cpu_to_le16(0x8000);\r\nentry = (++lp->cur_rx) & lp->rx_mod_mask;\r\nrxp = &lp->rx_ring[entry];\r\n}\r\nreturn npackets;\r\n}\r\nstatic int pcnet32_tx(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned int dirty_tx = lp->dirty_tx;\r\nint delta;\r\nint must_restart = 0;\r\nwhile (dirty_tx != lp->cur_tx) {\r\nint entry = dirty_tx & lp->tx_mod_mask;\r\nint status = (short)le16_to_cpu(lp->tx_ring[entry].status);\r\nif (status < 0)\r\nbreak;\r\nlp->tx_ring[entry].base = 0;\r\nif (status & 0x4000) {\r\nint err_status = le32_to_cpu(lp->tx_ring[entry].misc);\r\ndev->stats.tx_errors++;\r\nnetif_err(lp, tx_err, dev,\r\n"Tx error status=%04x err_status=%08x\n",\r\nstatus, err_status);\r\nif (err_status & 0x04000000)\r\ndev->stats.tx_aborted_errors++;\r\nif (err_status & 0x08000000)\r\ndev->stats.tx_carrier_errors++;\r\nif (err_status & 0x10000000)\r\ndev->stats.tx_window_errors++;\r\n#ifndef DO_DXSUFLO\r\nif (err_status & 0x40000000) {\r\ndev->stats.tx_fifo_errors++;\r\nnetif_err(lp, tx_err, dev, "Tx FIFO error!\n");\r\nmust_restart = 1;\r\n}\r\n#else\r\nif (err_status & 0x40000000) {\r\ndev->stats.tx_fifo_errors++;\r\nif (!lp->dxsuflo) {\r\nnetif_err(lp, tx_err, dev, "Tx FIFO error!\n");\r\nmust_restart = 1;\r\n}\r\n}\r\n#endif\r\n} else {\r\nif (status & 0x1800)\r\ndev->stats.collisions++;\r\ndev->stats.tx_packets++;\r\n}\r\nif (lp->tx_skbuff[entry]) {\r\npci_unmap_single(lp->pci_dev,\r\nlp->tx_dma_addr[entry],\r\nlp->tx_skbuff[entry]->\r\nlen, PCI_DMA_TODEVICE);\r\ndev_kfree_skb_any(lp->tx_skbuff[entry]);\r\nlp->tx_skbuff[entry] = NULL;\r\nlp->tx_dma_addr[entry] = 0;\r\n}\r\ndirty_tx++;\r\n}\r\ndelta = (lp->cur_tx - dirty_tx) & (lp->tx_mod_mask + lp->tx_ring_size);\r\nif (delta > lp->tx_ring_size) {\r\nnetif_err(lp, drv, dev, "out-of-sync dirty pointer, %d vs. %d, full=%d\n",\r\ndirty_tx, lp->cur_tx, lp->tx_full);\r\ndirty_tx += lp->tx_ring_size;\r\ndelta -= lp->tx_ring_size;\r\n}\r\nif (lp->tx_full &&\r\nnetif_queue_stopped(dev) &&\r\ndelta < lp->tx_ring_size - 2) {\r\nlp->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\nlp->dirty_tx = dirty_tx;\r\nreturn must_restart;\r\n}\r\nstatic int pcnet32_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct pcnet32_private *lp = container_of(napi, struct pcnet32_private, napi);\r\nstruct net_device *dev = lp->dev;\r\nunsigned long ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nint work_done;\r\nu16 val;\r\nwork_done = pcnet32_rx(dev, budget);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (pcnet32_tx(dev)) {\r\nlp->a->reset(ioaddr);\r\nlp->a->write_csr(ioaddr, CSR4, 0x0915);\r\npcnet32_restart(dev, CSR0_START);\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (work_done < budget) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\n__napi_complete(napi);\r\nval = lp->a->read_csr(ioaddr, CSR3);\r\nval &= 0x00ff;\r\nlp->a->write_csr(ioaddr, CSR3, val);\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_INTEN);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nreturn work_done;\r\n}\r\nstatic int pcnet32_get_regs_len(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint j = lp->phycount * PCNET32_REGS_PER_PHY;\r\nreturn (PCNET32_NUM_REGS + j) * sizeof(u16);\r\n}\r\nstatic void pcnet32_get_regs(struct net_device *dev, struct ethtool_regs *regs,\r\nvoid *ptr)\r\n{\r\nint i, csr0;\r\nu16 *buff = ptr;\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nconst struct pcnet32_access *a = lp->a;\r\nulong ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ncsr0 = a->read_csr(ioaddr, CSR0);\r\nif (!(csr0 & CSR0_STOP))\r\npcnet32_suspend(dev, &flags, 1);\r\nfor (i = 0; i < 16; i += 2)\r\n*buff++ = inw(ioaddr + i);\r\nfor (i = 0; i < 90; i++)\r\n*buff++ = a->read_csr(ioaddr, i);\r\n*buff++ = a->read_csr(ioaddr, 112);\r\n*buff++ = a->read_csr(ioaddr, 114);\r\nfor (i = 0; i < 30; i++)\r\n*buff++ = a->read_bcr(ioaddr, i);\r\n*buff++ = 0;\r\nfor (i = 31; i < 36; i++)\r\n*buff++ = a->read_bcr(ioaddr, i);\r\nif (lp->mii) {\r\nint j;\r\nfor (j = 0; j < PCNET32_MAX_PHYS; j++) {\r\nif (lp->phymask & (1 << j)) {\r\nfor (i = 0; i < PCNET32_REGS_PER_PHY; i++) {\r\nlp->a->write_bcr(ioaddr, 33,\r\n(j << 5) | i);\r\n*buff++ = lp->a->read_bcr(ioaddr, 34);\r\n}\r\n}\r\n}\r\n}\r\nif (!(csr0 & CSR0_STOP)) {\r\nint csr5;\r\ncsr5 = a->read_csr(ioaddr, CSR5);\r\na->write_csr(ioaddr, CSR5, csr5 & (~CSR5_SUSPEND));\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic void pcnet32_probe_vlbus(unsigned int *pcnet32_portlist)\r\n{\r\nunsigned int *port, ioaddr;\r\nfor (port = pcnet32_portlist; (ioaddr = *port); port++) {\r\nif (request_region\r\n(ioaddr, PCNET32_TOTAL_SIZE, "pcnet32_probe_vlbus")) {\r\nif ((inb(ioaddr + 14) == 0x57) &&\r\n(inb(ioaddr + 15) == 0x57)) {\r\npcnet32_probe1(ioaddr, 0, NULL);\r\n} else {\r\nrelease_region(ioaddr, PCNET32_TOTAL_SIZE);\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\npcnet32_probe_pci(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned long ioaddr;\r\nint err;\r\nerr = pci_enable_device(pdev);\r\nif (err < 0) {\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_err("failed to enable device -- err=%d\n", err);\r\nreturn err;\r\n}\r\npci_set_master(pdev);\r\nioaddr = pci_resource_start(pdev, 0);\r\nif (!ioaddr) {\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_err("card has no PCI IO resources, aborting\n");\r\nreturn -ENODEV;\r\n}\r\nif (!pci_dma_supported(pdev, PCNET32_DMA_MASK)) {\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_err("architecture does not support 32bit PCI busmaster DMA\n");\r\nreturn -ENODEV;\r\n}\r\nif (!request_region(ioaddr, PCNET32_TOTAL_SIZE, "pcnet32_probe_pci")) {\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_err("io address range already allocated\n");\r\nreturn -EBUSY;\r\n}\r\nerr = pcnet32_probe1(ioaddr, 1, pdev);\r\nif (err < 0)\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic int\r\npcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)\r\n{\r\nstruct pcnet32_private *lp;\r\nint i, media;\r\nint fdx, mii, fset, dxsuflo;\r\nint chip_version;\r\nchar *chipname;\r\nstruct net_device *dev;\r\nconst struct pcnet32_access *a = NULL;\r\nu8 promaddr[6];\r\nint ret = -ENODEV;\r\npcnet32_wio_reset(ioaddr);\r\nif (pcnet32_wio_read_csr(ioaddr, 0) == 4 && pcnet32_wio_check(ioaddr)) {\r\na = &pcnet32_wio;\r\n} else {\r\npcnet32_dwio_reset(ioaddr);\r\nif (pcnet32_dwio_read_csr(ioaddr, 0) == 4 &&\r\npcnet32_dwio_check(ioaddr)) {\r\na = &pcnet32_dwio;\r\n} else {\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_err("No access methods\n");\r\ngoto err_release_region;\r\n}\r\n}\r\nchip_version =\r\na->read_csr(ioaddr, 88) | (a->read_csr(ioaddr, 89) << 16);\r\nif ((pcnet32_debug & NETIF_MSG_PROBE) && (pcnet32_debug & NETIF_MSG_HW))\r\npr_info(" PCnet chip version is %#x\n", chip_version);\r\nif ((chip_version & 0xfff) != 0x003) {\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_info("Unsupported chip version\n");\r\ngoto err_release_region;\r\n}\r\nfdx = mii = fset = dxsuflo = 0;\r\nchip_version = (chip_version >> 12) & 0xffff;\r\nswitch (chip_version) {\r\ncase 0x2420:\r\nchipname = "PCnet/PCI 79C970";\r\nbreak;\r\ncase 0x2430:\r\nif (shared)\r\nchipname = "PCnet/PCI 79C970";\r\nelse\r\nchipname = "PCnet/32 79C965";\r\nbreak;\r\ncase 0x2621:\r\nchipname = "PCnet/PCI II 79C970A";\r\nfdx = 1;\r\nbreak;\r\ncase 0x2623:\r\nchipname = "PCnet/FAST 79C971";\r\nfdx = 1;\r\nmii = 1;\r\nfset = 1;\r\nbreak;\r\ncase 0x2624:\r\nchipname = "PCnet/FAST+ 79C972";\r\nfdx = 1;\r\nmii = 1;\r\nfset = 1;\r\nbreak;\r\ncase 0x2625:\r\nchipname = "PCnet/FAST III 79C973";\r\nfdx = 1;\r\nmii = 1;\r\nbreak;\r\ncase 0x2626:\r\nchipname = "PCnet/Home 79C978";\r\nfdx = 1;\r\nmedia = a->read_bcr(ioaddr, 49);\r\nmedia &= ~3;\r\nif (cards_found < MAX_UNITS && homepna[cards_found])\r\nmedia |= 1;\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\nprintk(KERN_DEBUG PFX "media set to %sMbit mode\n",\r\n(media & 1) ? "1" : "10");\r\na->write_bcr(ioaddr, 49, media);\r\nbreak;\r\ncase 0x2627:\r\nchipname = "PCnet/FAST III 79C975";\r\nfdx = 1;\r\nmii = 1;\r\nbreak;\r\ncase 0x2628:\r\nchipname = "PCnet/PRO 79C976";\r\nfdx = 1;\r\nmii = 1;\r\nbreak;\r\ndefault:\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_info("PCnet version %#x, no PCnet32 chip\n",\r\nchip_version);\r\ngoto err_release_region;\r\n}\r\nif (fset) {\r\na->write_bcr(ioaddr, 18, (a->read_bcr(ioaddr, 18) | 0x0860));\r\na->write_csr(ioaddr, 80,\r\n(a->read_csr(ioaddr, 80) & 0x0C00) | 0x0c00);\r\ndxsuflo = 1;\r\n}\r\ndev = alloc_etherdev(sizeof(*lp));\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err_release_region;\r\n}\r\nif (pdev)\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_info("%s at %#3lx,", chipname, ioaddr);\r\nfor (i = 0; i < 3; i++) {\r\nunsigned int val;\r\nval = a->read_csr(ioaddr, i + 12) & 0x0ffff;\r\ndev->dev_addr[2 * i] = val & 0x0ff;\r\ndev->dev_addr[2 * i + 1] = (val >> 8) & 0x0ff;\r\n}\r\nfor (i = 0; i < 6; i++)\r\npromaddr[i] = inb(ioaddr + i);\r\nif (memcmp(promaddr, dev->dev_addr, 6) ||\r\n!is_valid_ether_addr(dev->dev_addr)) {\r\nif (is_valid_ether_addr(promaddr)) {\r\nif (pcnet32_debug & NETIF_MSG_PROBE) {\r\npr_cont(" warning: CSR address invalid,\n");\r\npr_info(" using instead PROM address of");\r\n}\r\nmemcpy(dev->dev_addr, promaddr, 6);\r\n}\r\n}\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\nmemset(dev->dev_addr, 0, ETH_ALEN);\r\nif (pcnet32_debug & NETIF_MSG_PROBE) {\r\npr_cont(" %pM", dev->dev_addr);\r\nif (((chip_version + 1) & 0xfffe) == 0x2624) {\r\ni = a->read_csr(ioaddr, 80) & 0x0C00;\r\npr_info(" tx_start_pt(0x%04x):", i);\r\nswitch (i >> 10) {\r\ncase 0:\r\npr_cont(" 20 bytes,");\r\nbreak;\r\ncase 1:\r\npr_cont(" 64 bytes,");\r\nbreak;\r\ncase 2:\r\npr_cont(" 128 bytes,");\r\nbreak;\r\ncase 3:\r\npr_cont("~220 bytes,");\r\nbreak;\r\n}\r\ni = a->read_bcr(ioaddr, 18);\r\npr_cont(" BCR18(%x):", i & 0xffff);\r\nif (i & (1 << 5))\r\npr_cont("BurstWrEn ");\r\nif (i & (1 << 6))\r\npr_cont("BurstRdEn ");\r\nif (i & (1 << 7))\r\npr_cont("DWordIO ");\r\nif (i & (1 << 11))\r\npr_cont("NoUFlow ");\r\ni = a->read_bcr(ioaddr, 25);\r\npr_info(" SRAMSIZE=0x%04x,", i << 8);\r\ni = a->read_bcr(ioaddr, 26);\r\npr_cont(" SRAM_BND=0x%04x,", i << 8);\r\ni = a->read_bcr(ioaddr, 27);\r\nif (i & (1 << 14))\r\npr_cont("LowLatRx");\r\n}\r\n}\r\ndev->base_addr = ioaddr;\r\nlp = netdev_priv(dev);\r\nlp->init_block = pci_alloc_consistent(pdev, sizeof(*lp->init_block),\r\n&lp->init_dma_addr);\r\nif (!lp->init_block) {\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_err("Consistent memory allocation failed\n");\r\nret = -ENOMEM;\r\ngoto err_free_netdev;\r\n}\r\nlp->pci_dev = pdev;\r\nlp->dev = dev;\r\nspin_lock_init(&lp->lock);\r\nlp->name = chipname;\r\nlp->shared_irq = shared;\r\nlp->tx_ring_size = TX_RING_SIZE;\r\nlp->rx_ring_size = RX_RING_SIZE;\r\nlp->tx_mod_mask = lp->tx_ring_size - 1;\r\nlp->rx_mod_mask = lp->rx_ring_size - 1;\r\nlp->tx_len_bits = (PCNET32_LOG_TX_BUFFERS << 12);\r\nlp->rx_len_bits = (PCNET32_LOG_RX_BUFFERS << 4);\r\nlp->mii_if.full_duplex = fdx;\r\nlp->mii_if.phy_id_mask = 0x1f;\r\nlp->mii_if.reg_num_mask = 0x1f;\r\nlp->dxsuflo = dxsuflo;\r\nlp->mii = mii;\r\nlp->chip_version = chip_version;\r\nlp->msg_enable = pcnet32_debug;\r\nif ((cards_found >= MAX_UNITS) ||\r\n(options[cards_found] >= sizeof(options_mapping)))\r\nlp->options = PCNET32_PORT_ASEL;\r\nelse\r\nlp->options = options_mapping[options[cards_found]];\r\nlp->mii_if.dev = dev;\r\nlp->mii_if.mdio_read = mdio_read;\r\nlp->mii_if.mdio_write = mdio_write;\r\nlp->napi.weight = lp->rx_ring_size / 2;\r\nnetif_napi_add(dev, &lp->napi, pcnet32_poll, lp->rx_ring_size / 2);\r\nif (fdx && !(lp->options & PCNET32_PORT_ASEL) &&\r\n((cards_found >= MAX_UNITS) || full_duplex[cards_found]))\r\nlp->options |= PCNET32_PORT_FD;\r\nlp->a = a;\r\nif (pcnet32_alloc_ring(dev, pci_name(lp->pci_dev))) {\r\nret = -ENOMEM;\r\ngoto err_free_ring;\r\n}\r\nif (dev->dev_addr[0] == 0x00 && dev->dev_addr[1] == 0xe0 &&\r\ndev->dev_addr[2] == 0x75)\r\nlp->options = PCNET32_PORT_FD | PCNET32_PORT_GPSI;\r\nlp->init_block->mode = cpu_to_le16(0x0003);\r\nlp->init_block->tlen_rlen =\r\ncpu_to_le16(lp->tx_len_bits | lp->rx_len_bits);\r\nfor (i = 0; i < 6; i++)\r\nlp->init_block->phys_addr[i] = dev->dev_addr[i];\r\nlp->init_block->filter[0] = 0x00000000;\r\nlp->init_block->filter[1] = 0x00000000;\r\nlp->init_block->rx_ring = cpu_to_le32(lp->rx_ring_dma_addr);\r\nlp->init_block->tx_ring = cpu_to_le32(lp->tx_ring_dma_addr);\r\na->write_bcr(ioaddr, 20, 2);\r\na->write_csr(ioaddr, 1, (lp->init_dma_addr & 0xffff));\r\na->write_csr(ioaddr, 2, (lp->init_dma_addr >> 16));\r\nif (pdev) {\r\ndev->irq = pdev->irq;\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_cont(" assigned IRQ %d\n", dev->irq);\r\n} else {\r\nunsigned long irq_mask = probe_irq_on();\r\na->write_csr(ioaddr, CSR0, CSR0_INTEN | CSR0_INIT);\r\nmdelay(1);\r\ndev->irq = probe_irq_off(irq_mask);\r\nif (!dev->irq) {\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_cont(", failed to detect IRQ line\n");\r\nret = -ENODEV;\r\ngoto err_free_ring;\r\n}\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_cont(", probed IRQ %d\n", dev->irq);\r\n}\r\nif (lp->mii) {\r\nlp->mii_if.phy_id = ((lp->a->read_bcr(ioaddr, 33)) >> 5) & 0x1f;\r\nfor (i = 0; i < PCNET32_MAX_PHYS; i++) {\r\nunsigned short id1, id2;\r\nid1 = mdio_read(dev, i, MII_PHYSID1);\r\nif (id1 == 0xffff)\r\ncontinue;\r\nid2 = mdio_read(dev, i, MII_PHYSID2);\r\nif (id2 == 0xffff)\r\ncontinue;\r\nif (i == 31 && ((chip_version + 1) & 0xfffe) == 0x2624)\r\ncontinue;\r\nlp->phycount++;\r\nlp->phymask |= (1 << i);\r\nlp->mii_if.phy_id = i;\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_info("Found PHY %04x:%04x at address %d\n",\r\nid1, id2, i);\r\n}\r\nlp->a->write_bcr(ioaddr, 33, (lp->mii_if.phy_id) << 5);\r\nif (lp->phycount > 1)\r\nlp->options |= PCNET32_PORT_MII;\r\n}\r\ninit_timer(&lp->watchdog_timer);\r\nlp->watchdog_timer.data = (unsigned long)dev;\r\nlp->watchdog_timer.function = (void *)&pcnet32_watchdog;\r\ndev->netdev_ops = &pcnet32_netdev_ops;\r\ndev->ethtool_ops = &pcnet32_ethtool_ops;\r\ndev->watchdog_timeo = (5 * HZ);\r\nif (register_netdev(dev))\r\ngoto err_free_ring;\r\nif (pdev) {\r\npci_set_drvdata(pdev, dev);\r\n} else {\r\nlp->next = pcnet32_dev;\r\npcnet32_dev = dev;\r\n}\r\nif (pcnet32_debug & NETIF_MSG_PROBE)\r\npr_info("%s: registered as %s\n", dev->name, lp->name);\r\ncards_found++;\r\na->write_bcr(ioaddr, 2, a->read_bcr(ioaddr, 2) | 0x1000);\r\nreturn 0;\r\nerr_free_ring:\r\npcnet32_free_ring(dev);\r\npci_free_consistent(lp->pci_dev, sizeof(*lp->init_block),\r\nlp->init_block, lp->init_dma_addr);\r\nerr_free_netdev:\r\nfree_netdev(dev);\r\nerr_release_region:\r\nrelease_region(ioaddr, PCNET32_TOTAL_SIZE);\r\nreturn ret;\r\n}\r\nstatic int pcnet32_alloc_ring(struct net_device *dev, const char *name)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nlp->tx_ring = pci_alloc_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_tx_head) *\r\nlp->tx_ring_size,\r\n&lp->tx_ring_dma_addr);\r\nif (lp->tx_ring == NULL) {\r\nnetif_err(lp, drv, dev, "Consistent memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nlp->rx_ring = pci_alloc_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_rx_head) *\r\nlp->rx_ring_size,\r\n&lp->rx_ring_dma_addr);\r\nif (lp->rx_ring == NULL) {\r\nnetif_err(lp, drv, dev, "Consistent memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nlp->tx_dma_addr = kcalloc(lp->tx_ring_size, sizeof(dma_addr_t),\r\nGFP_ATOMIC);\r\nif (!lp->tx_dma_addr)\r\nreturn -ENOMEM;\r\nlp->rx_dma_addr = kcalloc(lp->rx_ring_size, sizeof(dma_addr_t),\r\nGFP_ATOMIC);\r\nif (!lp->rx_dma_addr)\r\nreturn -ENOMEM;\r\nlp->tx_skbuff = kcalloc(lp->tx_ring_size, sizeof(struct sk_buff *),\r\nGFP_ATOMIC);\r\nif (!lp->tx_skbuff)\r\nreturn -ENOMEM;\r\nlp->rx_skbuff = kcalloc(lp->rx_ring_size, sizeof(struct sk_buff *),\r\nGFP_ATOMIC);\r\nif (!lp->rx_skbuff)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void pcnet32_free_ring(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nkfree(lp->tx_skbuff);\r\nlp->tx_skbuff = NULL;\r\nkfree(lp->rx_skbuff);\r\nlp->rx_skbuff = NULL;\r\nkfree(lp->tx_dma_addr);\r\nlp->tx_dma_addr = NULL;\r\nkfree(lp->rx_dma_addr);\r\nlp->rx_dma_addr = NULL;\r\nif (lp->tx_ring) {\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_tx_head) *\r\nlp->tx_ring_size, lp->tx_ring,\r\nlp->tx_ring_dma_addr);\r\nlp->tx_ring = NULL;\r\n}\r\nif (lp->rx_ring) {\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct pcnet32_rx_head) *\r\nlp->rx_ring_size, lp->rx_ring,\r\nlp->rx_ring_dma_addr);\r\nlp->rx_ring = NULL;\r\n}\r\n}\r\nstatic int pcnet32_open(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nstruct pci_dev *pdev = lp->pci_dev;\r\nunsigned long ioaddr = dev->base_addr;\r\nu16 val;\r\nint i;\r\nint rc;\r\nunsigned long flags;\r\nif (request_irq(dev->irq, pcnet32_interrupt,\r\nlp->shared_irq ? IRQF_SHARED : 0, dev->name,\r\n(void *)dev)) {\r\nreturn -EAGAIN;\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nrc = -EINVAL;\r\ngoto err_free_irq;\r\n}\r\nlp->a->reset(ioaddr);\r\nlp->a->write_bcr(ioaddr, 20, 2);\r\nnetif_printk(lp, ifup, KERN_DEBUG, dev,\r\n"%s() irq %d tx/rx rings %#x/%#x init %#x\n",\r\n__func__, dev->irq, (u32) (lp->tx_ring_dma_addr),\r\n(u32) (lp->rx_ring_dma_addr),\r\n(u32) (lp->init_dma_addr));\r\nval = lp->a->read_bcr(ioaddr, 2) & ~2;\r\nif (lp->options & PCNET32_PORT_ASEL)\r\nval |= 2;\r\nlp->a->write_bcr(ioaddr, 2, val);\r\nif (lp->mii_if.full_duplex) {\r\nval = lp->a->read_bcr(ioaddr, 9) & ~3;\r\nif (lp->options & PCNET32_PORT_FD) {\r\nval |= 1;\r\nif (lp->options == (PCNET32_PORT_FD | PCNET32_PORT_AUI))\r\nval |= 2;\r\n} else if (lp->options & PCNET32_PORT_ASEL) {\r\nif (lp->chip_version == 0x2627)\r\nval |= 3;\r\n}\r\nlp->a->write_bcr(ioaddr, 9, val);\r\n}\r\nval = lp->a->read_csr(ioaddr, 124) & ~0x10;\r\nif ((lp->options & PCNET32_PORT_PORTSEL) == PCNET32_PORT_GPSI)\r\nval |= 0x10;\r\nlp->a->write_csr(ioaddr, 124, val);\r\nif (pdev && pdev->subsystem_vendor == PCI_VENDOR_ID_AT &&\r\n(pdev->subsystem_device == PCI_SUBDEVICE_ID_AT_2700FX ||\r\npdev->subsystem_device == PCI_SUBDEVICE_ID_AT_2701FX)) {\r\nif (lp->options & PCNET32_PORT_ASEL) {\r\nlp->options = PCNET32_PORT_FD | PCNET32_PORT_100;\r\nnetif_printk(lp, link, KERN_DEBUG, dev,\r\n"Setting 100Mb-Full Duplex\n");\r\n}\r\n}\r\nif (lp->phycount < 2) {\r\nif (lp->mii && !(lp->options & PCNET32_PORT_ASEL)) {\r\nlp->a->write_bcr(ioaddr, 32,\r\nlp->a->read_bcr(ioaddr, 32) | 0x0080);\r\nval = lp->a->read_bcr(ioaddr, 32) & ~0xb8;\r\nif (lp->options & PCNET32_PORT_FD)\r\nval |= 0x10;\r\nif (lp->options & PCNET32_PORT_100)\r\nval |= 0x08;\r\nlp->a->write_bcr(ioaddr, 32, val);\r\n} else {\r\nif (lp->options & PCNET32_PORT_ASEL) {\r\nlp->a->write_bcr(ioaddr, 32,\r\nlp->a->read_bcr(ioaddr,\r\n32) | 0x0080);\r\nval = lp->a->read_bcr(ioaddr, 32) & ~0x98;\r\nval |= 0x20;\r\nlp->a->write_bcr(ioaddr, 32, val);\r\n}\r\n}\r\n} else {\r\nint first_phy = -1;\r\nu16 bmcr;\r\nu32 bcr9;\r\nstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\r\nval = lp->a->read_bcr(ioaddr, 2);\r\nlp->a->write_bcr(ioaddr, 2, val & ~2);\r\nval = lp->a->read_bcr(ioaddr, 32);\r\nlp->a->write_bcr(ioaddr, 32, val & ~(1 << 7));\r\nif (!(lp->options & PCNET32_PORT_ASEL)) {\r\necmd.port = PORT_MII;\r\necmd.transceiver = XCVR_INTERNAL;\r\necmd.autoneg = AUTONEG_DISABLE;\r\nethtool_cmd_speed_set(&ecmd,\r\n(lp->options & PCNET32_PORT_100) ?\r\nSPEED_100 : SPEED_10);\r\nbcr9 = lp->a->read_bcr(ioaddr, 9);\r\nif (lp->options & PCNET32_PORT_FD) {\r\necmd.duplex = DUPLEX_FULL;\r\nbcr9 |= (1 << 0);\r\n} else {\r\necmd.duplex = DUPLEX_HALF;\r\nbcr9 |= ~(1 << 0);\r\n}\r\nlp->a->write_bcr(ioaddr, 9, bcr9);\r\n}\r\nfor (i = 0; i < PCNET32_MAX_PHYS; i++) {\r\nif (lp->phymask & (1 << i)) {\r\nbmcr = mdio_read(dev, i, MII_BMCR);\r\nif (first_phy == -1) {\r\nfirst_phy = i;\r\nmdio_write(dev, i, MII_BMCR,\r\nbmcr & ~BMCR_ISOLATE);\r\n} else {\r\nmdio_write(dev, i, MII_BMCR,\r\nbmcr | BMCR_ISOLATE);\r\n}\r\nlp->mii_if.phy_id = i;\r\necmd.phy_address = i;\r\nif (lp->options & PCNET32_PORT_ASEL) {\r\nmii_ethtool_gset(&lp->mii_if, &ecmd);\r\necmd.autoneg = AUTONEG_ENABLE;\r\n}\r\nmii_ethtool_sset(&lp->mii_if, &ecmd);\r\n}\r\n}\r\nlp->mii_if.phy_id = first_phy;\r\nnetif_info(lp, link, dev, "Using PHY number %d\n", first_phy);\r\n}\r\n#ifdef DO_DXSUFLO\r\nif (lp->dxsuflo) {\r\nval = lp->a->read_csr(ioaddr, CSR3);\r\nval |= 0x40;\r\nlp->a->write_csr(ioaddr, CSR3, val);\r\n}\r\n#endif\r\nlp->init_block->mode =\r\ncpu_to_le16((lp->options & PCNET32_PORT_PORTSEL) << 7);\r\npcnet32_load_multicast(dev);\r\nif (pcnet32_init_ring(dev)) {\r\nrc = -ENOMEM;\r\ngoto err_free_ring;\r\n}\r\nnapi_enable(&lp->napi);\r\nlp->a->write_csr(ioaddr, 1, (lp->init_dma_addr & 0xffff));\r\nlp->a->write_csr(ioaddr, 2, (lp->init_dma_addr >> 16));\r\nlp->a->write_csr(ioaddr, CSR4, 0x0915);\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_INIT);\r\nnetif_start_queue(dev);\r\nif (lp->chip_version >= PCNET32_79C970A) {\r\npcnet32_check_media(dev, 1);\r\nmod_timer(&lp->watchdog_timer, PCNET32_WATCHDOG_TIMEOUT);\r\n}\r\ni = 0;\r\nwhile (i++ < 100)\r\nif (lp->a->read_csr(ioaddr, CSR0) & CSR0_IDON)\r\nbreak;\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_NORMAL);\r\nnetif_printk(lp, ifup, KERN_DEBUG, dev,\r\n"pcnet32 open after %d ticks, init block %#x csr0 %4.4x\n",\r\ni,\r\n(u32) (lp->init_dma_addr),\r\nlp->a->read_csr(ioaddr, CSR0));\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn 0;\r\nerr_free_ring:\r\npcnet32_purge_rx_ring(dev);\r\nlp->a->write_bcr(ioaddr, 20, 4);\r\nerr_free_irq:\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nfree_irq(dev->irq, dev);\r\nreturn rc;\r\n}\r\nstatic void pcnet32_purge_tx_ring(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < lp->tx_ring_size; i++) {\r\nlp->tx_ring[i].status = 0;\r\nwmb();\r\nif (lp->tx_skbuff[i]) {\r\npci_unmap_single(lp->pci_dev, lp->tx_dma_addr[i],\r\nlp->tx_skbuff[i]->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_any(lp->tx_skbuff[i]);\r\n}\r\nlp->tx_skbuff[i] = NULL;\r\nlp->tx_dma_addr[i] = 0;\r\n}\r\n}\r\nstatic int pcnet32_init_ring(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint i;\r\nlp->tx_full = 0;\r\nlp->cur_rx = lp->cur_tx = 0;\r\nlp->dirty_rx = lp->dirty_tx = 0;\r\nfor (i = 0; i < lp->rx_ring_size; i++) {\r\nstruct sk_buff *rx_skbuff = lp->rx_skbuff[i];\r\nif (rx_skbuff == NULL) {\r\nlp->rx_skbuff[i] = netdev_alloc_skb(dev, PKT_BUF_SKB);\r\nrx_skbuff = lp->rx_skbuff[i];\r\nif (!rx_skbuff) {\r\nnetif_err(lp, drv, dev, "%s netdev_alloc_skb failed\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nskb_reserve(rx_skbuff, NET_IP_ALIGN);\r\n}\r\nrmb();\r\nif (lp->rx_dma_addr[i] == 0)\r\nlp->rx_dma_addr[i] =\r\npci_map_single(lp->pci_dev, rx_skbuff->data,\r\nPKT_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\nlp->rx_ring[i].base = cpu_to_le32(lp->rx_dma_addr[i]);\r\nlp->rx_ring[i].buf_length = cpu_to_le16(NEG_BUF_SIZE);\r\nwmb();\r\nlp->rx_ring[i].status = cpu_to_le16(0x8000);\r\n}\r\nfor (i = 0; i < lp->tx_ring_size; i++) {\r\nlp->tx_ring[i].status = 0;\r\nwmb();\r\nlp->tx_ring[i].base = 0;\r\nlp->tx_dma_addr[i] = 0;\r\n}\r\nlp->init_block->tlen_rlen =\r\ncpu_to_le16(lp->tx_len_bits | lp->rx_len_bits);\r\nfor (i = 0; i < 6; i++)\r\nlp->init_block->phys_addr[i] = dev->dev_addr[i];\r\nlp->init_block->rx_ring = cpu_to_le32(lp->rx_ring_dma_addr);\r\nlp->init_block->tx_ring = cpu_to_le32(lp->tx_ring_dma_addr);\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic void pcnet32_restart(struct net_device *dev, unsigned int csr0_bits)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long ioaddr = dev->base_addr;\r\nint i;\r\nfor (i = 0; i < 100; i++)\r\nif (lp->a->read_csr(ioaddr, CSR0) & CSR0_STOP)\r\nbreak;\r\nif (i >= 100)\r\nnetif_err(lp, drv, dev, "%s timed out waiting for stop\n",\r\n__func__);\r\npcnet32_purge_tx_ring(dev);\r\nif (pcnet32_init_ring(dev))\r\nreturn;\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_INIT);\r\ni = 0;\r\nwhile (i++ < 1000)\r\nif (lp->a->read_csr(ioaddr, CSR0) & CSR0_IDON)\r\nbreak;\r\nlp->a->write_csr(ioaddr, CSR0, csr0_bits);\r\n}\r\nstatic void pcnet32_tx_timeout(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long ioaddr = dev->base_addr, flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (pcnet32_debug & NETIF_MSG_DRV)\r\npr_err("%s: transmit timed out, status %4.4x, resetting\n",\r\ndev->name, lp->a->read_csr(ioaddr, CSR0));\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\r\ndev->stats.tx_errors++;\r\nif (netif_msg_tx_err(lp)) {\r\nint i;\r\nprintk(KERN_DEBUG\r\n" Ring data dump: dirty_tx %d cur_tx %d%s cur_rx %d.",\r\nlp->dirty_tx, lp->cur_tx, lp->tx_full ? " (full)" : "",\r\nlp->cur_rx);\r\nfor (i = 0; i < lp->rx_ring_size; i++)\r\nprintk("%s %08x %04x %08x %04x", i & 1 ? "" : "\n ",\r\nle32_to_cpu(lp->rx_ring[i].base),\r\n(-le16_to_cpu(lp->rx_ring[i].buf_length)) &\r\n0xffff, le32_to_cpu(lp->rx_ring[i].msg_length),\r\nle16_to_cpu(lp->rx_ring[i].status));\r\nfor (i = 0; i < lp->tx_ring_size; i++)\r\nprintk("%s %08x %04x %08x %04x", i & 1 ? "" : "\n ",\r\nle32_to_cpu(lp->tx_ring[i].base),\r\n(-le16_to_cpu(lp->tx_ring[i].length)) & 0xffff,\r\nle32_to_cpu(lp->tx_ring[i].misc),\r\nle16_to_cpu(lp->tx_ring[i].status));\r\nprintk("\n");\r\n}\r\npcnet32_restart(dev, CSR0_NORMAL);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic netdev_tx_t pcnet32_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long ioaddr = dev->base_addr;\r\nu16 status;\r\nint entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nnetif_printk(lp, tx_queued, KERN_DEBUG, dev,\r\n"%s() called, csr0 %4.4x\n",\r\n__func__, lp->a->read_csr(ioaddr, CSR0));\r\nstatus = 0x8300;\r\nentry = lp->cur_tx & lp->tx_mod_mask;\r\nlp->tx_ring[entry].length = cpu_to_le16(-skb->len);\r\nlp->tx_ring[entry].misc = 0x00000000;\r\nlp->tx_skbuff[entry] = skb;\r\nlp->tx_dma_addr[entry] =\r\npci_map_single(lp->pci_dev, skb->data, skb->len, PCI_DMA_TODEVICE);\r\nlp->tx_ring[entry].base = cpu_to_le32(lp->tx_dma_addr[entry]);\r\nwmb();\r\nlp->tx_ring[entry].status = cpu_to_le16(status);\r\nlp->cur_tx++;\r\ndev->stats.tx_bytes += skb->len;\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_INTEN | CSR0_TXPOLL);\r\nif (lp->tx_ring[(entry + 1) & lp->tx_mod_mask].base != 0) {\r\nlp->tx_full = 1;\r\nnetif_stop_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\npcnet32_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct pcnet32_private *lp;\r\nunsigned long ioaddr;\r\nu16 csr0;\r\nint boguscnt = max_interrupt_work;\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nspin_lock(&lp->lock);\r\ncsr0 = lp->a->read_csr(ioaddr, CSR0);\r\nwhile ((csr0 & 0x8f00) && --boguscnt >= 0) {\r\nif (csr0 == 0xffff)\r\nbreak;\r\nlp->a->write_csr(ioaddr, CSR0, csr0 & ~0x004f);\r\nnetif_printk(lp, intr, KERN_DEBUG, dev,\r\n"interrupt csr0=%#2.2x new csr=%#2.2x\n",\r\ncsr0, lp->a->read_csr(ioaddr, CSR0));\r\nif (csr0 & 0x4000)\r\ndev->stats.tx_errors++;\r\nif (csr0 & 0x1000) {\r\ndev->stats.rx_errors++;\r\n}\r\nif (csr0 & 0x0800) {\r\nnetif_err(lp, drv, dev, "Bus master arbitration failure, status %4.4x\n",\r\ncsr0);\r\n}\r\nif (napi_schedule_prep(&lp->napi)) {\r\nu16 val;\r\nval = lp->a->read_csr(ioaddr, CSR3);\r\nval |= 0x5f00;\r\nlp->a->write_csr(ioaddr, CSR3, val);\r\n__napi_schedule(&lp->napi);\r\nbreak;\r\n}\r\ncsr0 = lp->a->read_csr(ioaddr, CSR0);\r\n}\r\nnetif_printk(lp, intr, KERN_DEBUG, dev,\r\n"exiting interrupt, csr0=%#4.4x\n",\r\nlp->a->read_csr(ioaddr, CSR0));\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcnet32_close(struct net_device *dev)\r\n{\r\nunsigned long ioaddr = dev->base_addr;\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\ndel_timer_sync(&lp->watchdog_timer);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&lp->napi);\r\nspin_lock_irqsave(&lp->lock, flags);\r\ndev->stats.rx_missed_errors = lp->a->read_csr(ioaddr, 112);\r\nnetif_printk(lp, ifdown, KERN_DEBUG, dev,\r\n"Shutting down ethercard, status was %2.2x\n",\r\nlp->a->read_csr(ioaddr, CSR0));\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\r\nlp->a->write_bcr(ioaddr, 20, 4);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nfree_irq(dev->irq, dev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\npcnet32_purge_rx_ring(dev);\r\npcnet32_purge_tx_ring(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *pcnet32_get_stats(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ndev->stats.rx_missed_errors = lp->a->read_csr(ioaddr, 112);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void pcnet32_load_multicast(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nvolatile struct pcnet32_init_block *ib = lp->init_block;\r\nvolatile __le16 *mcast_table = (__le16 *)ib->filter;\r\nstruct netdev_hw_addr *ha;\r\nunsigned long ioaddr = dev->base_addr;\r\nint i;\r\nu32 crc;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nib->filter[0] = cpu_to_le32(~0U);\r\nib->filter[1] = cpu_to_le32(~0U);\r\nlp->a->write_csr(ioaddr, PCNET32_MC_FILTER, 0xffff);\r\nlp->a->write_csr(ioaddr, PCNET32_MC_FILTER+1, 0xffff);\r\nlp->a->write_csr(ioaddr, PCNET32_MC_FILTER+2, 0xffff);\r\nlp->a->write_csr(ioaddr, PCNET32_MC_FILTER+3, 0xffff);\r\nreturn;\r\n}\r\nib->filter[0] = 0;\r\nib->filter[1] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc = crc >> 26;\r\nmcast_table[crc >> 4] |= cpu_to_le16(1 << (crc & 0xf));\r\n}\r\nfor (i = 0; i < 4; i++)\r\nlp->a->write_csr(ioaddr, PCNET32_MC_FILTER + i,\r\nle16_to_cpu(mcast_table[i]));\r\n}\r\nstatic void pcnet32_set_multicast_list(struct net_device *dev)\r\n{\r\nunsigned long ioaddr = dev->base_addr, flags;\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint csr15, suspended;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nsuspended = pcnet32_suspend(dev, &flags, 0);\r\ncsr15 = lp->a->read_csr(ioaddr, CSR15);\r\nif (dev->flags & IFF_PROMISC) {\r\nnetif_info(lp, hw, dev, "Promiscuous mode enabled\n");\r\nlp->init_block->mode =\r\ncpu_to_le16(0x8000 | (lp->options & PCNET32_PORT_PORTSEL) <<\r\n7);\r\nlp->a->write_csr(ioaddr, CSR15, csr15 | 0x8000);\r\n} else {\r\nlp->init_block->mode =\r\ncpu_to_le16((lp->options & PCNET32_PORT_PORTSEL) << 7);\r\nlp->a->write_csr(ioaddr, CSR15, csr15 & 0x7fff);\r\npcnet32_load_multicast(dev);\r\n}\r\nif (suspended) {\r\nint csr5;\r\ncsr5 = lp->a->read_csr(ioaddr, CSR5);\r\nlp->a->write_csr(ioaddr, CSR5, csr5 & (~CSR5_SUSPEND));\r\n} else {\r\nlp->a->write_csr(ioaddr, CSR0, CSR0_STOP);\r\npcnet32_restart(dev, CSR0_NORMAL);\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int reg_num)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long ioaddr = dev->base_addr;\r\nu16 val_out;\r\nif (!lp->mii)\r\nreturn 0;\r\nlp->a->write_bcr(ioaddr, 33, ((phy_id & 0x1f) << 5) | (reg_num & 0x1f));\r\nval_out = lp->a->read_bcr(ioaddr, 34);\r\nreturn val_out;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int reg_num, int val)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long ioaddr = dev->base_addr;\r\nif (!lp->mii)\r\nreturn;\r\nlp->a->write_bcr(ioaddr, 33, ((phy_id & 0x1f) << 5) | (reg_num & 0x1f));\r\nlp->a->write_bcr(ioaddr, 34, val);\r\n}\r\nstatic int pcnet32_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint rc;\r\nunsigned long flags;\r\nif (lp->mii) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nrc = generic_mii_ioctl(&lp->mii_if, if_mii(rq), cmd, NULL);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n} else {\r\nrc = -EOPNOTSUPP;\r\n}\r\nreturn rc;\r\n}\r\nstatic int pcnet32_check_otherphy(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nstruct mii_if_info mii = lp->mii_if;\r\nu16 bmcr;\r\nint i;\r\nfor (i = 0; i < PCNET32_MAX_PHYS; i++) {\r\nif (i == lp->mii_if.phy_id)\r\ncontinue;\r\nif (lp->phymask & (1 << i)) {\r\nmii.phy_id = i;\r\nif (mii_link_ok(&mii)) {\r\nnetif_info(lp, link, dev, "Using PHY number %d\n",\r\ni);\r\nbmcr =\r\nmdio_read(dev, lp->mii_if.phy_id, MII_BMCR);\r\nmdio_write(dev, lp->mii_if.phy_id, MII_BMCR,\r\nbmcr | BMCR_ISOLATE);\r\nbmcr = mdio_read(dev, i, MII_BMCR);\r\nmdio_write(dev, i, MII_BMCR,\r\nbmcr & ~BMCR_ISOLATE);\r\nlp->mii_if.phy_id = i;\r\nreturn 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcnet32_check_media(struct net_device *dev, int verbose)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nint curr_link;\r\nint prev_link = netif_carrier_ok(dev) ? 1 : 0;\r\nu32 bcr9;\r\nif (lp->mii) {\r\ncurr_link = mii_link_ok(&lp->mii_if);\r\n} else {\r\nulong ioaddr = dev->base_addr;\r\ncurr_link = (lp->a->read_bcr(ioaddr, 4) != 0xc0);\r\n}\r\nif (!curr_link) {\r\nif (prev_link || verbose) {\r\nnetif_carrier_off(dev);\r\nnetif_info(lp, link, dev, "link down\n");\r\n}\r\nif (lp->phycount > 1) {\r\ncurr_link = pcnet32_check_otherphy(dev);\r\nprev_link = 0;\r\n}\r\n} else if (verbose || !prev_link) {\r\nnetif_carrier_on(dev);\r\nif (lp->mii) {\r\nif (netif_msg_link(lp)) {\r\nstruct ethtool_cmd ecmd = {\r\n.cmd = ETHTOOL_GSET };\r\nmii_ethtool_gset(&lp->mii_if, &ecmd);\r\nnetdev_info(dev, "link up, %uMbps, %s-duplex\n",\r\nethtool_cmd_speed(&ecmd),\r\n(ecmd.duplex == DUPLEX_FULL)\r\n? "full" : "half");\r\n}\r\nbcr9 = lp->a->read_bcr(dev->base_addr, 9);\r\nif ((bcr9 & (1 << 0)) != lp->mii_if.full_duplex) {\r\nif (lp->mii_if.full_duplex)\r\nbcr9 |= (1 << 0);\r\nelse\r\nbcr9 &= ~(1 << 0);\r\nlp->a->write_bcr(dev->base_addr, 9, bcr9);\r\n}\r\n} else {\r\nnetif_info(lp, link, dev, "link up\n");\r\n}\r\n}\r\n}\r\nstatic void pcnet32_watchdog(struct net_device *dev)\r\n{\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\npcnet32_check_media(dev, 0);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nmod_timer(&lp->watchdog_timer, round_jiffies(PCNET32_WATCHDOG_TIMEOUT));\r\n}\r\nstatic int pcnet32_pm_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (netif_running(dev)) {\r\nnetif_device_detach(dev);\r\npcnet32_close(dev);\r\n}\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int pcnet32_pm_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif (netif_running(dev)) {\r\npcnet32_open(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcnet32_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev) {\r\nstruct pcnet32_private *lp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\npcnet32_free_ring(dev);\r\nrelease_region(dev->base_addr, PCNET32_TOTAL_SIZE);\r\npci_free_consistent(lp->pci_dev, sizeof(*lp->init_block),\r\nlp->init_block, lp->init_dma_addr);\r\nfree_netdev(dev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\n}\r\nstatic int __init pcnet32_init_module(void)\r\n{\r\npr_info("%s", version);\r\npcnet32_debug = netif_msg_init(debug, PCNET32_MSG_DEFAULT);\r\nif ((tx_start_pt >= 0) && (tx_start_pt <= 3))\r\ntx_start = tx_start_pt;\r\nif (!pci_register_driver(&pcnet32_driver))\r\npcnet32_have_pci = 1;\r\nif (pcnet32vlb)\r\npcnet32_probe_vlbus(pcnet32_portlist);\r\nif (cards_found && (pcnet32_debug & NETIF_MSG_PROBE))\r\npr_info("%d cards_found\n", cards_found);\r\nreturn (pcnet32_have_pci + cards_found) ? 0 : -ENODEV;\r\n}\r\nstatic void __exit pcnet32_cleanup_module(void)\r\n{\r\nstruct net_device *next_dev;\r\nwhile (pcnet32_dev) {\r\nstruct pcnet32_private *lp = netdev_priv(pcnet32_dev);\r\nnext_dev = lp->next;\r\nunregister_netdev(pcnet32_dev);\r\npcnet32_free_ring(pcnet32_dev);\r\nrelease_region(pcnet32_dev->base_addr, PCNET32_TOTAL_SIZE);\r\npci_free_consistent(lp->pci_dev, sizeof(*lp->init_block),\r\nlp->init_block, lp->init_dma_addr);\r\nfree_netdev(pcnet32_dev);\r\npcnet32_dev = next_dev;\r\n}\r\nif (pcnet32_have_pci)\r\npci_unregister_driver(&pcnet32_driver);\r\n}
