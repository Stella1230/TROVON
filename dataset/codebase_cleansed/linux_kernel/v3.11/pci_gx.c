resource_size_t pcibios_align_resource(void *data, const struct resource *res,\r\nresource_size_t size, resource_size_t align)\r\n{\r\nreturn res->start;\r\n}\r\nstatic int tile_irq_cpu(int irq)\r\n{\r\nunsigned int count;\r\nint i = 0;\r\nint cpu;\r\ncount = cpumask_weight(&intr_cpus_map);\r\nif (unlikely(count == 0)) {\r\npr_warning("intr_cpus_map empty, interrupts will be"\r\n" delievered to dataplane tiles\n");\r\nreturn irq % (smp_height * smp_width);\r\n}\r\ncount = irq % count;\r\nfor_each_cpu(cpu, &intr_cpus_map) {\r\nif (i++ == count)\r\nbreak;\r\n}\r\nreturn cpu;\r\n}\r\nstatic int tile_pcie_open(int trio_index)\r\n{\r\ngxio_trio_context_t *context = &trio_contexts[trio_index];\r\nint ret;\r\nret = gxio_trio_init(context, trio_index);\r\nif (ret < 0)\r\nreturn ret;\r\nret = gxio_trio_alloc_asids(context, 1, 0, 0);\r\nif (ret < 0) {\r\npr_err("PCI: ASID alloc failure on TRIO %d, give up\n",\r\ntrio_index);\r\ngoto asid_alloc_failure;\r\n}\r\ncontext->asid = ret;\r\n#ifdef USE_SHARED_PCIE_CONFIG_REGION\r\nret = gxio_trio_alloc_pio_regions(context, 1, 0, 0);\r\nif (ret < 0) {\r\npr_err("PCI: CFG PIO alloc failure on TRIO %d, give up\n",\r\ntrio_index);\r\ngoto pio_alloc_failure;\r\n}\r\ncontext->pio_cfg_index = ret;\r\nret = gxio_trio_init_pio_region_aux(context, context->pio_cfg_index,\r\n0, 0, HV_TRIO_PIO_FLAG_CONFIG_SPACE);\r\nif (ret < 0) {\r\npr_err("PCI: CFG PIO init failure on TRIO %d, give up\n",\r\ntrio_index);\r\ngoto pio_alloc_failure;\r\n}\r\n#endif\r\nreturn ret;\r\nasid_alloc_failure:\r\n#ifdef USE_SHARED_PCIE_CONFIG_REGION\r\npio_alloc_failure:\r\n#endif\r\nhv_dev_close(context->fd);\r\nreturn ret;\r\n}\r\nstatic void\r\ntilegx_legacy_irq_ack(struct irq_data *d)\r\n{\r\n__insn_mtspr(SPR_IPI_EVENT_RESET_K, 1UL << d->irq);\r\n}\r\nstatic void\r\ntilegx_legacy_irq_mask(struct irq_data *d)\r\n{\r\n__insn_mtspr(SPR_IPI_MASK_SET_K, 1UL << d->irq);\r\n}\r\nstatic void\r\ntilegx_legacy_irq_unmask(struct irq_data *d)\r\n{\r\n__insn_mtspr(SPR_IPI_MASK_RESET_K, 1UL << d->irq);\r\n}\r\nstatic void\r\ntrio_handle_level_irq(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct pci_controller *controller = irq_desc_get_handler_data(desc);\r\ngxio_trio_context_t *trio_context = controller->trio;\r\nuint64_t intx = (uint64_t)irq_desc_get_chip_data(desc);\r\nint mac = controller->mac;\r\nunsigned int reg_offset;\r\nuint64_t level_mask;\r\nhandle_level_irq(irq, desc);\r\nreg_offset = (TRIO_PCIE_INTFC_MAC_INT_STS <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_INTERFACE <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\nlevel_mask = TRIO_PCIE_INTFC_MAC_INT_STS__INT_LEVEL_MASK << intx;\r\n__gxio_mmio_write(trio_context->mmio_base_mac + reg_offset, level_mask);\r\n}\r\nstatic int tile_init_irqs(struct pci_controller *controller)\r\n{\r\nint i;\r\nint j;\r\nint irq;\r\nint result;\r\ncpumask_copy(&intr_cpus_map, cpu_online_mask);\r\nfor (i = 0; i < 4; i++) {\r\ngxio_trio_context_t *context = controller->trio;\r\nint cpu;\r\nirq = create_irq();\r\nif (irq < 0) {\r\npr_err("PCI: no free irq vectors, failed for %d\n", i);\r\ngoto free_irqs;\r\n}\r\ncontroller->irq_intx_table[i] = irq;\r\ncpu = tile_irq_cpu(irq);\r\nresult = gxio_trio_config_legacy_intr(context, cpu_x(cpu),\r\ncpu_y(cpu), KERNEL_PL,\r\nirq, controller->mac, i);\r\nif (result < 0) {\r\npr_err("PCI: MAC intx config failed for %d\n", i);\r\ngoto free_irqs;\r\n}\r\nirq_set_chip_and_handler(irq, &tilegx_legacy_irq_chip,\r\ntrio_handle_level_irq);\r\nirq_set_chip_data(irq, (void *)(uint64_t)i);\r\nirq_set_handler_data(irq, controller);\r\n}\r\nreturn 0;\r\nfree_irqs:\r\nfor (j = 0; j < i; j++)\r\ndestroy_irq(controller->irq_intx_table[j]);\r\nreturn -1;\r\n}\r\nint __init tile_pci_init(void)\r\n{\r\nint num_trio_shims = 0;\r\nint ctl_index = 0;\r\nint i, j;\r\nif (!pci_probe) {\r\npr_info("PCI: disabled by boot argument\n");\r\nreturn 0;\r\n}\r\npr_info("PCI: Searching for controllers...\n");\r\nfor (i = 0; i < TILEGX_NUM_TRIO; i++) {\r\nint ret;\r\nret = tile_pcie_open(i);\r\nif (ret < 0)\r\ncontinue;\r\nnum_trio_shims++;\r\n}\r\nif (num_trio_shims == 0 || sim_is_simulator())\r\nreturn 0;\r\nfor (i = 0; i < TILEGX_NUM_TRIO; i++) {\r\ngxio_trio_context_t *context = &trio_contexts[i];\r\nint ret;\r\nif (context->fd < 0)\r\ncontinue;\r\nret = hv_dev_pread(context->fd, 0,\r\n(HV_VirtAddr)&pcie_ports[i][0],\r\nsizeof(struct pcie_port_property) * TILEGX_TRIO_PCIES,\r\nGXIO_TRIO_OP_GET_PORT_PROPERTY);\r\nif (ret < 0) {\r\npr_err("PCI: PCIE_GET_PORT_PROPERTY failure, error %d,"\r\n" on TRIO %d\n", ret, i);\r\ncontinue;\r\n}\r\nfor (j = 0; j < TILEGX_TRIO_PCIES; j++) {\r\nif (pcie_ports[i][j].allow_rc) {\r\npcie_rc[i][j] = 1;\r\nnum_rc_controllers++;\r\n}\r\nelse if (pcie_ports[i][j].allow_ep) {\r\nnum_ep_controllers++;\r\n}\r\n}\r\n}\r\nif (num_rc_controllers == 0)\r\nreturn 0;\r\nfor (i = 0; i < TILEGX_NUM_TRIO; i++) {\r\nfor (j = 0; j < TILEGX_TRIO_PCIES; j++) {\r\nif (pcie_rc[i][j]) {\r\npci_controllers[ctl_index].trio =\r\n&trio_contexts[i];\r\npci_controllers[ctl_index].mac = j;\r\npci_controllers[ctl_index].trio_index = i;\r\nctl_index++;\r\nif (ctl_index == num_rc_controllers)\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nfor (i = 0; i < num_rc_controllers; i++) {\r\nstruct pci_controller *controller = &pci_controllers[i];\r\ncontroller->index = i;\r\ncontroller->ops = &tile_cfg_ops;\r\ncontroller->mem_offset = TILE_PCI_MEM_START +\r\n(i * TILE_PCI_BAR_WINDOW_TOP);\r\ncontroller->mem_space.start = controller->mem_offset +\r\nTILE_PCI_BAR_WINDOW_TOP - TILE_PCI_BAR_WINDOW_SIZE;\r\ncontroller->mem_space.end = controller->mem_offset +\r\nTILE_PCI_BAR_WINDOW_TOP - 1;\r\ncontroller->mem_space.flags = IORESOURCE_MEM;\r\nsnprintf(controller->mem_space_name,\r\nsizeof(controller->mem_space_name),\r\n"PCI mem domain %d", i);\r\ncontroller->mem_space.name = controller->mem_space_name;\r\n}\r\nreturn num_rc_controllers;\r\n}\r\nstatic int tile_map_irq(const struct pci_dev *dev, u8 device, u8 pin)\r\n{\r\nstruct pci_controller *controller =\r\n(struct pci_controller *)dev->sysdata;\r\nreturn controller->irq_intx_table[pin - 1];\r\n}\r\nstatic void fixup_read_and_payload_sizes(struct pci_controller *controller)\r\n{\r\ngxio_trio_context_t *trio_context = controller->trio;\r\nstruct pci_bus *root_bus = controller->root_bus;\r\nTRIO_PCIE_RC_DEVICE_CONTROL_t dev_control;\r\nTRIO_PCIE_RC_DEVICE_CAP_t rc_dev_cap;\r\nunsigned int reg_offset;\r\nstruct pci_bus *child;\r\nint mac;\r\nint err;\r\nmac = controller->mac;\r\nreg_offset =\r\n(TRIO_PCIE_RC_DEVICE_CONTROL <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_STANDARD <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\ndev_control.word = __gxio_mmio_read32(trio_context->mmio_base_mac +\r\nreg_offset);\r\ndev_control.max_read_req_sz = 5;\r\n__gxio_mmio_write32(trio_context->mmio_base_mac + reg_offset,\r\ndev_control.word);\r\nreg_offset =\r\n(TRIO_PCIE_RC_DEVICE_CAP <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_STANDARD <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\nrc_dev_cap.word = __gxio_mmio_read32(trio_context->mmio_base_mac +\r\nreg_offset);\r\nrc_dev_cap.mps_sup = 1;\r\n__gxio_mmio_write32(trio_context->mmio_base_mac + reg_offset,\r\nrc_dev_cap.word);\r\nlist_for_each_entry(child, &root_bus->children, node) {\r\nstruct pci_dev *self = child->self;\r\nif (!self)\r\ncontinue;\r\npcie_bus_configure_settings(child, self->pcie_mpss);\r\n}\r\nreg_offset =\r\n(TRIO_PCIE_RC_DEVICE_CONTROL <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_STANDARD <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\ndev_control.word = __gxio_mmio_read32(trio_context->mmio_base_mac +\r\nreg_offset);\r\nerr = gxio_trio_set_mps_mrs(trio_context,\r\ndev_control.max_payload_size,\r\ndev_control.max_read_req_sz,\r\nmac);\r\nif (err < 0) {\r\npr_err("PCI: PCIE_CONFIGURE_MAC_MPS_MRS failure, "\r\n"MAC %d on TRIO %d\n",\r\nmac, controller->trio_index);\r\n}\r\n}\r\nstatic int setup_pcie_rc_delay(char *str)\r\n{\r\nunsigned long delay = 0;\r\nunsigned long trio_index;\r\nunsigned long mac;\r\nif (str == NULL || !isdigit(*str))\r\nreturn -EINVAL;\r\ntrio_index = simple_strtoul(str, (char **)&str, 10);\r\nif (trio_index >= TILEGX_NUM_TRIO)\r\nreturn -EINVAL;\r\nif (*str != ',')\r\nreturn -EINVAL;\r\nstr++;\r\nif (!isdigit(*str))\r\nreturn -EINVAL;\r\nmac = simple_strtoul(str, (char **)&str, 10);\r\nif (mac >= TILEGX_TRIO_PCIES)\r\nreturn -EINVAL;\r\nif (*str != '\0') {\r\nif (*str != ',')\r\nreturn -EINVAL;\r\nstr++;\r\nif (!isdigit(*str))\r\nreturn -EINVAL;\r\ndelay = simple_strtoul(str, (char **)&str, 10);\r\nif (delay > MAX_RC_DELAY)\r\nreturn -EINVAL;\r\n}\r\nrc_delay[trio_index][mac] = delay ? : DEFAULT_RC_DELAY;\r\npr_info("Delaying PCIe RC link training for %u sec"\r\n" on MAC %lu on TRIO %lu\n", rc_delay[trio_index][mac],\r\nmac, trio_index);\r\nreturn 0;\r\n}\r\nint __init pcibios_init(void)\r\n{\r\nresource_size_t offset;\r\nLIST_HEAD(resources);\r\nint next_busno;\r\nint i;\r\ntile_pci_init();\r\nif (num_rc_controllers == 0 && num_ep_controllers == 0)\r\nreturn 0;\r\nfor (i = 0; i < TILEGX_NUM_TRIO; i++) {\r\ngxio_trio_context_t *context = &trio_contexts[i];\r\nif (context->fd < 0)\r\ncontinue;\r\noffset = 0;\r\ncontext->mmio_base_mac =\r\niorpc_ioremap(context->fd, offset,\r\nHV_TRIO_CONFIG_IOREMAP_SIZE);\r\nif (context->mmio_base_mac == NULL) {\r\npr_err("PCI: MAC map failure on TRIO %d\n", i);\r\nhv_dev_close(context->fd);\r\ncontext->fd = -1;\r\ncontinue;\r\n}\r\n}\r\nmsleep(250);\r\nfor (next_busno = 0, i = 0; i < num_rc_controllers; i++) {\r\nstruct pci_controller *controller = &pci_controllers[i];\r\ngxio_trio_context_t *trio_context = controller->trio;\r\nTRIO_PCIE_INTFC_PORT_CONFIG_t port_config;\r\nTRIO_PCIE_INTFC_PORT_STATUS_t port_status;\r\nTRIO_PCIE_INTFC_TX_FIFO_CTL_t tx_fifo_ctl;\r\nstruct pci_bus *bus;\r\nunsigned int reg_offset;\r\nunsigned int class_code_revision;\r\nint trio_index;\r\nint mac;\r\nint ret;\r\nif (trio_context->fd < 0)\r\ncontinue;\r\ntrio_index = controller->trio_index;\r\nmac = controller->mac;\r\nreg_offset =\r\n(TRIO_PCIE_INTFC_PORT_CONFIG <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_INTERFACE <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\nport_config.word =\r\n__gxio_mmio_read(trio_context->mmio_base_mac +\r\nreg_offset);\r\nif ((port_config.strap_state !=\r\nTRIO_PCIE_INTFC_PORT_CONFIG__STRAP_STATE_VAL_AUTO_CONFIG_RC) &&\r\n(port_config.strap_state !=\r\nTRIO_PCIE_INTFC_PORT_CONFIG__STRAP_STATE_VAL_AUTO_CONFIG_RC_G1)) {\r\nif (port_config.strap_state ==\r\nTRIO_PCIE_INTFC_PORT_CONFIG__STRAP_STATE_VAL_AUTO_CONFIG_ENDPOINT ||\r\nport_config.strap_state ==\r\nTRIO_PCIE_INTFC_PORT_CONFIG__STRAP_STATE_VAL_AUTO_CONFIG_ENDPOINT_G1)\r\npcie_ports[trio_index][mac].allow_ep = 1;\r\ncontinue;\r\n}\r\nif (rc_delay[trio_index][mac])\r\nmsleep(rc_delay[trio_index][mac] * 1000);\r\nret = gxio_trio_force_rc_link_up(trio_context, mac);\r\nif (ret < 0)\r\npr_err("PCI: PCIE_FORCE_LINK_UP failure, "\r\n"MAC %d on TRIO %d\n", mac, trio_index);\r\npr_info("PCI: Found PCI controller #%d on TRIO %d MAC %d\n", i,\r\ntrio_index, controller->mac);\r\nmsleep(1000);\r\nreg_offset =\r\n(TRIO_PCIE_INTFC_PORT_STATUS <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_INTERFACE <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\nport_status.word =\r\n__gxio_mmio_read(trio_context->mmio_base_mac +\r\nreg_offset);\r\nif (!port_status.dl_up) {\r\npr_err("PCI: link is down, MAC %d on TRIO %d\n",\r\nmac, trio_index);\r\ncontinue;\r\n}\r\nreg_offset =\r\n(TRIO_PCIE_INTFC_TX_FIFO_CTL <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_INTERFACE <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\ntx_fifo_ctl.word =\r\n__gxio_mmio_read(trio_context->mmio_base_mac +\r\nreg_offset);\r\ntx_fifo_ctl.min_p_credits = 0;\r\n__gxio_mmio_write(trio_context->mmio_base_mac + reg_offset,\r\ntx_fifo_ctl.word);\r\nreg_offset =\r\n(TRIO_PCIE_RC_DEVICE_ID_VEN_ID <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_STANDARD <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\n__gxio_mmio_write32(trio_context->mmio_base_mac + reg_offset,\r\n(TILERA_GX36_RC_DEV_ID <<\r\nTRIO_PCIE_RC_DEVICE_ID_VEN_ID__DEV_ID_SHIFT) |\r\nTILERA_VENDOR_ID);\r\nreg_offset =\r\n(TRIO_PCIE_RC_REVISION_ID <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_STANDARD <<\r\nTRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(mac << TRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\nclass_code_revision =\r\n__gxio_mmio_read32(trio_context->mmio_base_mac +\r\nreg_offset);\r\nclass_code_revision = (class_code_revision & 0xff ) |\r\n(PCI_CLASS_BRIDGE_PCI << 16);\r\n__gxio_mmio_write32(trio_context->mmio_base_mac +\r\nreg_offset, class_code_revision);\r\n#ifdef USE_SHARED_PCIE_CONFIG_REGION\r\noffset = HV_TRIO_PIO_OFFSET(trio_context->pio_cfg_index) |\r\n(((unsigned long long)mac) <<\r\nTRIO_TILE_PIO_REGION_SETUP_CFG_ADDR__MAC_SHIFT);\r\n#else\r\nret = gxio_trio_alloc_pio_regions(trio_context, 1, 0, 0);\r\nif (ret < 0) {\r\npr_err("PCI: PCI CFG PIO alloc failure for mac %d "\r\n"on TRIO %d, give up\n", mac, trio_index);\r\ncontinue;\r\n}\r\ntrio_context->pio_cfg_index[mac] = ret;\r\nret = gxio_trio_init_pio_region_aux(trio_context,\r\ntrio_context->pio_cfg_index[mac],\r\nmac, 0, HV_TRIO_PIO_FLAG_CONFIG_SPACE);\r\nif (ret < 0) {\r\npr_err("PCI: PCI CFG PIO init failure for mac %d "\r\n"on TRIO %d, give up\n", mac, trio_index);\r\ncontinue;\r\n}\r\noffset = HV_TRIO_PIO_OFFSET(trio_context->pio_cfg_index[mac]) |\r\n(((unsigned long long)mac) <<\r\nTRIO_TILE_PIO_REGION_SETUP_CFG_ADDR__MAC_SHIFT);\r\n#endif\r\ntrio_context->mmio_base_pio_cfg[mac] =\r\niorpc_ioremap(trio_context->fd, offset,\r\n(1 << TRIO_TILE_PIO_REGION_SETUP_CFG_ADDR__MAC_SHIFT));\r\nif (trio_context->mmio_base_pio_cfg[mac] == NULL) {\r\npr_err("PCI: PIO map failure for mac %d on TRIO %d\n",\r\nmac, trio_index);\r\ncontinue;\r\n}\r\nif (tile_init_irqs(controller)) {\r\npr_err("PCI: IRQs init failure for mac %d on TRIO %d\n",\r\nmac, trio_index);\r\ncontinue;\r\n}\r\npci_add_resource_offset(&resources, &controller->mem_space,\r\ncontroller->mem_offset);\r\ncontroller->first_busno = next_busno;\r\nbus = pci_scan_root_bus(NULL, next_busno, controller->ops,\r\ncontroller, &resources);\r\ncontroller->root_bus = bus;\r\nnext_busno = bus->busn_res.end + 1;\r\n}\r\npci_fixup_irqs(pci_common_swizzle, tile_map_irq);\r\npci_assign_unassigned_resources();\r\nfor (i = 0; i < num_rc_controllers; i++) {\r\nstruct pci_controller *controller = &pci_controllers[i];\r\ngxio_trio_context_t *trio_context = controller->trio;\r\nstruct pci_bus *root_bus = pci_controllers[i].root_bus;\r\nstruct pci_bus *next_bus;\r\nuint32_t bus_address_hi;\r\nstruct pci_dev *dev;\r\nint ret;\r\nint j;\r\nif (root_bus == NULL)\r\ncontinue;\r\nfixup_read_and_payload_sizes(controller);\r\nlist_for_each_entry(dev, &root_bus->devices, bus_list) {\r\nif ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI &&\r\n(PCI_SLOT(dev->devfn) == 0)) {\r\nnext_bus = dev->subordinate;\r\npci_controllers[i].mem_resources[0] =\r\n*next_bus->resource[0];\r\npci_controllers[i].mem_resources[1] =\r\n*next_bus->resource[1];\r\npci_controllers[i].mem_resources[2] =\r\n*next_bus->resource[2];\r\nbreak;\r\n}\r\n}\r\nif (pci_controllers[i].mem_resources[1].flags & IORESOURCE_MEM)\r\nbus_address_hi =\r\npci_controllers[i].mem_resources[1].start >> 32;\r\nelse if (pci_controllers[i].mem_resources[2].flags & IORESOURCE_PREFETCH)\r\nbus_address_hi =\r\npci_controllers[i].mem_resources[2].start >> 32;\r\nelse {\r\npr_err("PCI: no memory resources on TRIO %d mac %d\n",\r\ncontroller->trio_index, controller->mac);\r\ncontinue;\r\n}\r\nret = gxio_trio_alloc_pio_regions(trio_context, 1, 0, 0);\r\nif (ret < 0) {\r\npr_err("PCI: MEM PIO alloc failure on TRIO %d mac %d, "\r\n"give up\n", controller->trio_index,\r\ncontroller->mac);\r\ncontinue;\r\n}\r\ncontroller->pio_mem_index = ret;\r\nret = gxio_trio_init_pio_region_aux(trio_context,\r\ncontroller->pio_mem_index,\r\ncontroller->mac,\r\n0,\r\n0);\r\nif (ret < 0) {\r\npr_err("PCI: MEM PIO init failure on TRIO %d mac %d, "\r\n"give up\n", controller->trio_index,\r\ncontroller->mac);\r\ncontinue;\r\n}\r\nfor_each_online_node(j) {\r\nunsigned long start_pfn = node_start_pfn[j];\r\nunsigned long end_pfn = node_end_pfn[j];\r\nunsigned long nr_pages = end_pfn - start_pfn;\r\nret = gxio_trio_alloc_memory_maps(trio_context, 1, 0,\r\n0);\r\nif (ret < 0) {\r\npr_err("PCI: Mem-Map alloc failure on TRIO %d "\r\n"mac %d for MC %d, give up\n",\r\ncontroller->trio_index,\r\ncontroller->mac, j);\r\ngoto alloc_mem_map_failed;\r\n}\r\ncontroller->mem_maps[j] = ret;\r\nret = gxio_trio_init_memory_map_mmu_aux(trio_context,\r\ncontroller->mem_maps[j],\r\nstart_pfn << PAGE_SHIFT,\r\nnr_pages << PAGE_SHIFT,\r\ntrio_context->asid,\r\ncontroller->mac,\r\n(start_pfn << PAGE_SHIFT) +\r\nTILE_PCI_MEM_MAP_BASE_OFFSET,\r\nj,\r\nGXIO_TRIO_ORDER_MODE_UNORDERED);\r\nif (ret < 0) {\r\npr_err("PCI: Mem-Map init failure on TRIO %d "\r\n"mac %d for MC %d, give up\n",\r\ncontroller->trio_index,\r\ncontroller->mac, j);\r\ngoto alloc_mem_map_failed;\r\n}\r\ncontinue;\r\nalloc_mem_map_failed:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\n}\r\nchar *pcibios_setup(char *str)\r\n{\r\nif (!strcmp(str, "off")) {\r\npci_probe = 0;\r\nreturn NULL;\r\n}\r\nreturn str;\r\n}\r\nint pcibios_enable_device(struct pci_dev *dev, int mask)\r\n{\r\nreturn pci_enable_resources(dev, mask);\r\n}\r\nstatic void pcibios_fixup_final(struct pci_dev *pdev)\r\n{\r\nset_dma_ops(&pdev->dev, gx_pci_dma_map_ops);\r\nset_dma_offset(&pdev->dev, TILE_PCI_MEM_MAP_BASE_OFFSET);\r\npdev->dev.archdata.max_direct_dma_addr =\r\nTILE_PCI_MAX_DIRECT_DMA_ADDRESS;\r\n}\r\nvoid __iomem *ioremap(resource_size_t phys_addr, unsigned long size)\r\n{\r\nstruct pci_controller *controller = NULL;\r\nresource_size_t bar_start;\r\nresource_size_t bar_end;\r\nresource_size_t offset;\r\nresource_size_t start;\r\nresource_size_t end;\r\nint trio_fd;\r\nint i, j;\r\nstart = phys_addr;\r\nend = phys_addr + size - 1;\r\nfor (i = 0; i < num_rc_controllers; i++) {\r\nif (pci_controllers[i].root_bus == NULL)\r\ncontinue;\r\nfor (j = 1; j < 3; j++) {\r\nbar_start =\r\npci_controllers[i].mem_resources[j].start;\r\nbar_end =\r\npci_controllers[i].mem_resources[j].end;\r\nif ((start >= bar_start) && (end <= bar_end)) {\r\ncontroller = &pci_controllers[i];\r\ngoto got_it;\r\n}\r\n}\r\n}\r\nif (controller == NULL)\r\nreturn NULL;\r\ngot_it:\r\ntrio_fd = controller->trio->fd;\r\nstart = phys_addr - controller->mem_offset;\r\noffset = HV_TRIO_PIO_OFFSET(controller->pio_mem_index) + start;\r\nreturn iorpc_ioremap(trio_fd, offset, size) +\r\n(phys_addr & (PAGE_SIZE - 1));\r\n}\r\nvoid pci_iounmap(struct pci_dev *dev, void __iomem *addr)\r\n{\r\niounmap(addr);\r\n}\r\nstatic int tile_cfg_read(struct pci_bus *bus, unsigned int devfn, int offset,\r\nint size, u32 *val)\r\n{\r\nstruct pci_controller *controller = bus->sysdata;\r\ngxio_trio_context_t *trio_context = controller->trio;\r\nint busnum = bus->number & 0xff;\r\nint device = PCI_SLOT(devfn);\r\nint function = PCI_FUNC(devfn);\r\nint config_type = 1;\r\nTRIO_TILE_PIO_REGION_SETUP_CFG_ADDR_t cfg_addr;\r\nvoid *mmio_addr;\r\nif (pci_is_root_bus(bus)) {\r\nif (device == 0) {\r\nunsigned int reg_offset;\r\nreg_offset = ((offset & 0xFFF) <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_PROTECTED\r\n<< TRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(controller->mac <<\r\nTRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\nmmio_addr = trio_context->mmio_base_mac + reg_offset;\r\ngoto valid_device;\r\n} else {\r\ngoto invalid_device;\r\n}\r\n}\r\nif (busnum == (controller->first_busno + 1)) {\r\nif (device != 0)\r\ngoto invalid_device;\r\nconfig_type = 0;\r\n}\r\ncfg_addr.word = 0;\r\ncfg_addr.reg_addr = (offset & 0xFFF);\r\ncfg_addr.fn = function;\r\ncfg_addr.dev = device;\r\ncfg_addr.bus = busnum;\r\ncfg_addr.type = config_type;\r\nmmio_addr = trio_context->mmio_base_pio_cfg[controller->mac] +\r\ncfg_addr.word;\r\nvalid_device:\r\nswitch (size) {\r\ncase 4:\r\n*val = __gxio_mmio_read32(mmio_addr);\r\nbreak;\r\ncase 2:\r\n*val = __gxio_mmio_read16(mmio_addr);\r\nbreak;\r\ncase 1:\r\n*val = __gxio_mmio_read8(mmio_addr);\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\nTRACE_CFG_RD(size, *val, busnum, device, function, offset);\r\nreturn 0;\r\ninvalid_device:\r\nswitch (size) {\r\ncase 4:\r\n*val = 0xFFFFFFFF;\r\nbreak;\r\ncase 2:\r\n*val = 0xFFFF;\r\nbreak;\r\ncase 1:\r\n*val = 0xFF;\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tile_cfg_write(struct pci_bus *bus, unsigned int devfn, int offset,\r\nint size, u32 val)\r\n{\r\nstruct pci_controller *controller = bus->sysdata;\r\ngxio_trio_context_t *trio_context = controller->trio;\r\nint busnum = bus->number & 0xff;\r\nint device = PCI_SLOT(devfn);\r\nint function = PCI_FUNC(devfn);\r\nint config_type = 1;\r\nTRIO_TILE_PIO_REGION_SETUP_CFG_ADDR_t cfg_addr;\r\nvoid *mmio_addr;\r\nu32 val_32 = (u32)val;\r\nu16 val_16 = (u16)val;\r\nu8 val_8 = (u8)val;\r\nif (pci_is_root_bus(bus)) {\r\nif (device == 0) {\r\nunsigned int reg_offset;\r\nreg_offset = ((offset & 0xFFF) <<\r\nTRIO_CFG_REGION_ADDR__REG_SHIFT) |\r\n(TRIO_CFG_REGION_ADDR__INTFC_VAL_MAC_PROTECTED\r\n<< TRIO_CFG_REGION_ADDR__INTFC_SHIFT ) |\r\n(controller->mac <<\r\nTRIO_CFG_REGION_ADDR__MAC_SEL_SHIFT);\r\nmmio_addr = trio_context->mmio_base_mac + reg_offset;\r\ngoto valid_device;\r\n} else {\r\ngoto invalid_device;\r\n}\r\n}\r\nif (busnum == (controller->first_busno + 1)) {\r\nif (device != 0)\r\ngoto invalid_device;\r\nconfig_type = 0;\r\n}\r\ncfg_addr.word = 0;\r\ncfg_addr.reg_addr = (offset & 0xFFF);\r\ncfg_addr.fn = function;\r\ncfg_addr.dev = device;\r\ncfg_addr.bus = busnum;\r\ncfg_addr.type = config_type;\r\nmmio_addr = trio_context->mmio_base_pio_cfg[controller->mac] +\r\ncfg_addr.word;\r\nvalid_device:\r\nswitch (size) {\r\ncase 4:\r\n__gxio_mmio_write32(mmio_addr, val_32);\r\nTRACE_CFG_WR(size, val_32, busnum, device, function, offset);\r\nbreak;\r\ncase 2:\r\n__gxio_mmio_write16(mmio_addr, val_16);\r\nTRACE_CFG_WR(size, val_16, busnum, device, function, offset);\r\nbreak;\r\ncase 1:\r\n__gxio_mmio_write8(mmio_addr, val_8);\r\nTRACE_CFG_WR(size, val_8, busnum, device, function, offset);\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\ninvalid_device:\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\ntilegx_msi_startup(struct irq_data *d)\r\n{\r\nif (d->msi_desc)\r\nunmask_msi_irq(d);\r\nreturn 0;\r\n}\r\nstatic void\r\ntilegx_msi_ack(struct irq_data *d)\r\n{\r\n__insn_mtspr(SPR_IPI_EVENT_RESET_K, 1UL << d->irq);\r\n}\r\nstatic void\r\ntilegx_msi_mask(struct irq_data *d)\r\n{\r\nmask_msi_irq(d);\r\n__insn_mtspr(SPR_IPI_MASK_SET_K, 1UL << d->irq);\r\n}\r\nstatic void\r\ntilegx_msi_unmask(struct irq_data *d)\r\n{\r\n__insn_mtspr(SPR_IPI_MASK_RESET_K, 1UL << d->irq);\r\nunmask_msi_irq(d);\r\n}\r\nint arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)\r\n{\r\nstruct pci_controller *controller;\r\ngxio_trio_context_t *trio_context;\r\nstruct msi_msg msg;\r\nint default_irq;\r\nuint64_t mem_map_base;\r\nuint64_t mem_map_limit;\r\nu64 msi_addr;\r\nint mem_map;\r\nint cpu;\r\nint irq;\r\nint ret;\r\nirq = create_irq();\r\nif (irq < 0)\r\nreturn irq;\r\nif (desc->msi_attrib.is_64 == 0) {\r\ndev_printk(KERN_INFO, &pdev->dev,\r\n"64-bit MSI message address not supported, "\r\n"falling back to legacy interrupts.\n");\r\nret = -ENOMEM;\r\ngoto is_64_failure;\r\n}\r\ndefault_irq = desc->msi_attrib.default_irq;\r\ncontroller = irq_get_handler_data(default_irq);\r\nBUG_ON(!controller);\r\ntrio_context = controller->trio;\r\nmem_map = gxio_trio_alloc_memory_maps(trio_context, 1, 0, 0);\r\nif (mem_map < 0) {\r\ndev_printk(KERN_INFO, &pdev->dev,\r\n"%s Mem-Map alloc failure. "\r\n"Failed to initialize MSI interrupts. "\r\n"Falling back to legacy interrupts.\n",\r\ndesc->msi_attrib.is_msix ? "MSI-X" : "MSI");\r\nret = -ENOMEM;\r\ngoto msi_mem_map_alloc_failure;\r\n}\r\ncpu = tile_irq_cpu(irq);\r\nmem_map_base = MEM_MAP_INTR_REGIONS_BASE +\r\nmem_map * MEM_MAP_INTR_REGION_SIZE;\r\nmem_map_limit = mem_map_base + MEM_MAP_INTR_REGION_SIZE - 1;\r\nret = gxio_trio_config_msi_intr(trio_context, cpu_x(cpu), cpu_y(cpu),\r\nKERNEL_PL, irq, controller->mac,\r\nmem_map, mem_map_base, mem_map_limit,\r\ntrio_context->asid);\r\nif (ret < 0) {\r\ndev_printk(KERN_INFO, &pdev->dev, "HV MSI config failed.\n");\r\ngoto hv_msi_config_failure;\r\n}\r\nirq_set_msi_desc(irq, desc);\r\nmsi_addr = mem_map_base + TRIO_MAP_MEM_REG_INT3 - TRIO_MAP_MEM_REG_INT0;\r\nmsg.address_hi = msi_addr >> 32;\r\nmsg.address_lo = msi_addr & 0xffffffff;\r\nmsg.data = mem_map;\r\nwrite_msi_msg(irq, &msg);\r\nirq_set_chip_and_handler(irq, &tilegx_msi_chip, handle_level_irq);\r\nirq_set_handler_data(irq, controller);\r\nreturn 0;\r\nhv_msi_config_failure:\r\nmsi_mem_map_alloc_failure:\r\nis_64_failure:\r\ndestroy_irq(irq);\r\nreturn ret;\r\n}\r\nvoid arch_teardown_msi_irq(unsigned int irq)\r\n{\r\ndestroy_irq(irq);\r\n}
