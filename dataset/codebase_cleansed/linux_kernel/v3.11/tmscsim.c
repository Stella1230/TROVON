static void inline dc390_start_segment(struct dc390_srb* pSRB)\r\n{\r\nstruct scatterlist *psgl = pSRB->pSegmentList;\r\npSRB->SGBusAddr = sg_dma_address(psgl);\r\npSRB->SGToBeXferLen = sg_dma_len(psgl);\r\n}\r\nstatic unsigned long inline dc390_advance_segment(struct dc390_srb* pSRB, u32 residue)\r\n{\r\nunsigned long xfer = pSRB->SGToBeXferLen - residue;\r\npSRB->SGBusAddr += xfer;\r\npSRB->TotalXferredLen += xfer;\r\npSRB->SGToBeXferLen = residue;\r\nreturn xfer;\r\n}\r\nstatic struct dc390_dcb __inline__ *dc390_findDCB ( struct dc390_acb* pACB, u8 id, u8 lun)\r\n{\r\nstruct dc390_dcb* pDCB = pACB->pLinkDCB; if (!pDCB) return NULL;\r\nwhile (pDCB->TargetID != id || pDCB->TargetLUN != lun)\r\n{\r\npDCB = pDCB->pNextDCB;\r\nif (pDCB == pACB->pLinkDCB)\r\nreturn NULL;\r\n}\r\nDCBDEBUG1( printk (KERN_DEBUG "DCB %p (%02x,%02x) found.\n", \\r\npDCB, pDCB->TargetID, pDCB->TargetLUN));\r\nreturn pDCB;\r\n}\r\nstatic __inline__ void dc390_Free_insert (struct dc390_acb* pACB, struct dc390_srb* pSRB)\r\n{\r\nDEBUG0(printk ("DC390: Free SRB %p\n", pSRB));\r\npSRB->pNextSRB = pACB->pFreeSRB;\r\npACB->pFreeSRB = pSRB;\r\n}\r\nstatic __inline__ void dc390_Going_append (struct dc390_dcb* pDCB, struct dc390_srb* pSRB)\r\n{\r\npDCB->GoingSRBCnt++;\r\nDEBUG0(printk("DC390: Append SRB %p to Going\n", pSRB));\r\nif( pDCB->pGoingSRB )\r\npDCB->pGoingLast->pNextSRB = pSRB;\r\nelse\r\npDCB->pGoingSRB = pSRB;\r\npDCB->pGoingLast = pSRB;\r\npSRB->pNextSRB = NULL;\r\n}\r\nstatic __inline__ void dc390_Going_remove (struct dc390_dcb* pDCB, struct dc390_srb* pSRB)\r\n{\r\nDEBUG0(printk("DC390: Remove SRB %p from Going\n", pSRB));\r\nif (pSRB == pDCB->pGoingSRB)\r\npDCB->pGoingSRB = pSRB->pNextSRB;\r\nelse\r\n{\r\nstruct dc390_srb* psrb = pDCB->pGoingSRB;\r\nwhile (psrb && psrb->pNextSRB != pSRB)\r\npsrb = psrb->pNextSRB;\r\nif (!psrb)\r\n{ printk (KERN_ERR "DC390: Remove non-ex. SRB %p from Going!\n", pSRB); return; }\r\npsrb->pNextSRB = pSRB->pNextSRB;\r\nif (pSRB == pDCB->pGoingLast)\r\npDCB->pGoingLast = psrb;\r\n}\r\npDCB->GoingSRBCnt--;\r\n}\r\nstatic struct scatterlist* dc390_sg_build_single(struct scatterlist *sg, void *addr, unsigned int length)\r\n{\r\nsg_init_one(sg, addr, length);\r\nreturn sg;\r\n}\r\nstatic int dc390_pci_map (struct dc390_srb* pSRB)\r\n{\r\nint error = 0;\r\nstruct scsi_cmnd *pcmd = pSRB->pcmd;\r\nstruct pci_dev *pdev = pSRB->pSRBDCB->pDCBACB->pdev;\r\ndc390_cmd_scp_t* cmdp = ((dc390_cmd_scp_t*)(&pcmd->SCp));\r\nif (pSRB->SRBFlag & AUTO_REQSENSE) {\r\npSRB->pSegmentList = dc390_sg_build_single(&pSRB->Segmentx, pcmd->sense_buffer, SCSI_SENSE_BUFFERSIZE);\r\npSRB->SGcount = pci_map_sg(pdev, pSRB->pSegmentList, 1,\r\nDMA_FROM_DEVICE);\r\ncmdp->saved_dma_handle = sg_dma_address(pSRB->pSegmentList);\r\nif (pSRB->SGcount != 1)\r\nerror = 1;\r\nDEBUG1(printk("%s(): Mapped sense buffer %p at %x\n", __func__, pcmd->sense_buffer, cmdp->saved_dma_handle));\r\n} else if (scsi_sg_count(pcmd)) {\r\nint nseg;\r\nnseg = scsi_dma_map(pcmd);\r\npSRB->pSegmentList = scsi_sglist(pcmd);\r\npSRB->SGcount = nseg;\r\nif (nseg < 0)\r\nerror = 1;\r\nDEBUG1(printk("%s(): Mapped SG %p with %d (%d) elements\n",\\r\n__func__, scsi_sglist(pcmd), nseg, scsi_sg_count(pcmd)));\r\n} else\r\npSRB->SGcount = 0;\r\nreturn error;\r\n}\r\nstatic void dc390_pci_unmap (struct dc390_srb* pSRB)\r\n{\r\nstruct scsi_cmnd *pcmd = pSRB->pcmd;\r\nstruct pci_dev *pdev = pSRB->pSRBDCB->pDCBACB->pdev;\r\nDEBUG1(dc390_cmd_scp_t* cmdp = ((dc390_cmd_scp_t*)(&pcmd->SCp)));\r\nif (pSRB->SRBFlag) {\r\npci_unmap_sg(pdev, &pSRB->Segmentx, 1, DMA_FROM_DEVICE);\r\nDEBUG1(printk("%s(): Unmapped sense buffer at %x\n", __func__, cmdp->saved_dma_handle));\r\n} else {\r\nscsi_dma_unmap(pcmd);\r\nDEBUG1(printk("%s(): Unmapped SG at %p with %d elements\n",\r\n__func__, scsi_sglist(pcmd), scsi_sg_count(pcmd)));\r\n}\r\n}\r\nstatic void __inline__\r\ndc390_freetag (struct dc390_dcb* pDCB, struct dc390_srb* pSRB)\r\n{\r\nif (pSRB->TagNumber != SCSI_NO_TAG) {\r\npDCB->TagMask &= ~(1 << pSRB->TagNumber);\r\npSRB->TagNumber = SCSI_NO_TAG;\r\n}\r\n}\r\nstatic int\r\ndc390_StartSCSI( struct dc390_acb* pACB, struct dc390_dcb* pDCB, struct dc390_srb* pSRB )\r\n{\r\nstruct scsi_cmnd *scmd = pSRB->pcmd;\r\nstruct scsi_device *sdev = scmd->device;\r\nu8 cmd, disc_allowed, try_sync_nego;\r\nchar tag[2];\r\npSRB->ScsiPhase = SCSI_NOP0;\r\nif (pACB->Connected)\r\n{\r\nprintk (KERN_WARNING "DC390: Can't select when connected! (%08x,%02x)\n",\r\npSRB->SRBState, pSRB->SRBFlag);\r\npSRB->SRBState = SRB_READY;\r\npACB->SelConn++;\r\nreturn 1;\r\n}\r\nif (time_before (jiffies, pACB->pScsiHost->last_reset))\r\n{\r\nDEBUG0(printk ("DC390: We were just reset and don't accept commands yet!\n"));\r\nreturn 1;\r\n}\r\ndc390_pci_map(pSRB);\r\nDC390_write8 (Scsi_Dest_ID, pDCB->TargetID);\r\nDC390_write8 (Sync_Period, pDCB->SyncPeriod);\r\nDC390_write8 (Sync_Offset, pDCB->SyncOffset);\r\nDC390_write8 (CtrlReg1, pDCB->CtrlR1);\r\nDC390_write8 (CtrlReg3, pDCB->CtrlR3);\r\nDC390_write8 (CtrlReg4, pDCB->CtrlR4);\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\nDEBUG1(printk (KERN_INFO "DC390: Start SCSI command: %02x (Sync:%02x)\n",\\r\nscmd->cmnd[0], pDCB->SyncMode));\r\nif (! (pSRB->SRBFlag & AUTO_REQSENSE))\r\ndisc_allowed = pDCB->DevMode & EN_DISCONNECT_;\r\nelse\r\ndisc_allowed = 0;\r\nif ((pDCB->SyncMode & SYNC_ENABLE) && pDCB->TargetLUN == 0 && sdev->sdtr &&\r\n(((scmd->cmnd[0] == REQUEST_SENSE || (pSRB->SRBFlag & AUTO_REQSENSE)) &&\r\n!(pDCB->SyncMode & SYNC_NEGO_DONE)) || scmd->cmnd[0] == INQUIRY))\r\ntry_sync_nego = 1;\r\nelse\r\ntry_sync_nego = 0;\r\npSRB->MsgCnt = 0;\r\ncmd = SEL_W_ATN;\r\nDC390_write8 (ScsiFifo, IDENTIFY(disc_allowed, pDCB->TargetLUN));\r\nif ((pDCB->SyncMode & EN_TAG_QUEUEING) && disc_allowed && scsi_populate_tag_msg(scmd, tag)) {\r\nDC390_write8(ScsiFifo, tag[0]);\r\npDCB->TagMask |= 1 << tag[1];\r\npSRB->TagNumber = tag[1];\r\nDC390_write8(ScsiFifo, tag[1]);\r\nDEBUG1(printk(KERN_INFO "DC390: Select w/DisCn for SRB %p, block tag %02x\n", pSRB, tag[1]));\r\ncmd = SEL_W_ATN3;\r\n} else {\r\nDEBUG1(printk(KERN_INFO "DC390: Select w%s/DisCn for SRB %p, No TagQ\n", disc_allowed ? "" : "o", pSRB));\r\n}\r\npSRB->SRBState = SRB_START_;\r\nif (try_sync_nego)\r\n{\r\nu8 Sync_Off = pDCB->SyncOffset;\r\nDEBUG0(printk (KERN_INFO "DC390: NEW Sync Nego code triggered (%i %i)\n", pDCB->TargetID, pDCB->TargetLUN));\r\npSRB->MsgOutBuf[0] = EXTENDED_MESSAGE;\r\npSRB->MsgOutBuf[1] = 3;\r\npSRB->MsgOutBuf[2] = EXTENDED_SDTR;\r\npSRB->MsgOutBuf[3] = pDCB->NegoPeriod;\r\nif (!(Sync_Off & 0x0f)) Sync_Off = SYNC_NEGO_OFFSET;\r\npSRB->MsgOutBuf[4] = Sync_Off;\r\npSRB->MsgCnt = 5;\r\npSRB->SRBState |= DO_SYNC_NEGO;\r\ncmd = SEL_W_ATN_STOP;\r\n}\r\nif (cmd != SEL_W_ATN_STOP)\r\n{\r\nif( pSRB->SRBFlag & AUTO_REQSENSE )\r\n{\r\nDC390_write8 (ScsiFifo, REQUEST_SENSE);\r\nDC390_write8 (ScsiFifo, pDCB->TargetLUN << 5);\r\nDC390_write8 (ScsiFifo, 0);\r\nDC390_write8 (ScsiFifo, 0);\r\nDC390_write8 (ScsiFifo, SCSI_SENSE_BUFFERSIZE);\r\nDC390_write8 (ScsiFifo, 0);\r\nDEBUG1(printk (KERN_DEBUG "DC390: AutoReqSense !\n"));\r\n}\r\nelse\r\n{\r\nu8 *ptr; u8 i;\r\nptr = (u8 *)scmd->cmnd;\r\nfor (i = 0; i < scmd->cmd_len; i++)\r\nDC390_write8 (ScsiFifo, *(ptr++));\r\n}\r\n}\r\nDEBUG0(if (pACB->pActiveDCB) \\r\nprintk (KERN_WARNING "DC390: ActiveDCB != 0\n"));\r\nDEBUG0(if (pDCB->pActiveSRB) \\r\nprintk (KERN_WARNING "DC390: ActiveSRB != 0\n"));\r\nif (DC390_read8 (Scsi_Status) & INTERRUPT)\r\n{\r\ndc390_freetag (pDCB, pSRB);\r\nDEBUG0(printk ("DC390: Interrupt during Start SCSI (target %02i-%02i)\n",\r\nscmd->device->id, scmd->device->lun));\r\npSRB->SRBState = SRB_READY;\r\npACB->SelLost++;\r\nreturn 1;\r\n}\r\nDC390_write8 (ScsiCmd, cmd);\r\npACB->pActiveDCB = pDCB;\r\npDCB->pActiveSRB = pSRB;\r\npACB->Connected = 1;\r\npSRB->ScsiPhase = SCSI_NOP1;\r\nreturn 0;\r\n}\r\nstatic void __inline__\r\ndc390_InvalidCmd(struct dc390_acb* pACB)\r\n{\r\nif (pACB->pActiveDCB->pActiveSRB->SRBState & (SRB_START_ | SRB_MSGOUT))\r\nDC390_write8(ScsiCmd, CLEAR_FIFO_CMD);\r\n}\r\nstatic irqreturn_t __inline__\r\nDC390_Interrupt(void *dev_id)\r\n{\r\nstruct dc390_acb *pACB = dev_id;\r\nstruct dc390_dcb *pDCB;\r\nstruct dc390_srb *pSRB;\r\nu8 sstatus=0;\r\nu8 phase;\r\nvoid (*stateV)( struct dc390_acb*, struct dc390_srb*, u8 *);\r\nu8 istate, istatus;\r\nsstatus = DC390_read8 (Scsi_Status);\r\nif( !(sstatus & INTERRUPT) )\r\nreturn IRQ_NONE;\r\nDEBUG1(printk (KERN_DEBUG "sstatus=%02x,", sstatus));\r\nspin_lock_irq(pACB->pScsiHost->host_lock);\r\nistate = DC390_read8 (Intern_State);\r\nistatus = DC390_read8 (INT_Status);\r\nDEBUG1(printk (KERN_INFO "Istatus(Res,Inv,Dis,Serv,Succ,ReS,SelA,Sel)=%02x,",istatus));\r\ndc390_laststatus &= ~0x00ffffff;\r\ndc390_laststatus |= sstatus<<16 | istate<<8 | istatus;\r\nif (sstatus & ILLEGAL_OP_ERR)\r\n{\r\nprintk ("DC390: Illegal Operation detected (%08x)!\n", dc390_laststatus);\r\ndc390_dumpinfo (pACB, pACB->pActiveDCB, pACB->pActiveDCB->pActiveSRB);\r\n}\r\nelse if (istatus & INVALID_CMD)\r\n{\r\nprintk ("DC390: Invalid Command detected (%08x)!\n", dc390_laststatus);\r\ndc390_InvalidCmd( pACB );\r\ngoto unlock;\r\n}\r\nif (istatus & SCSI_RESET)\r\n{\r\ndc390_ScsiRstDetect( pACB );\r\ngoto unlock;\r\n}\r\nif (istatus & DISCONNECTED)\r\n{\r\ndc390_Disconnect( pACB );\r\ngoto unlock;\r\n}\r\nif (istatus & RESELECTED)\r\n{\r\ndc390_Reselect( pACB );\r\ngoto unlock;\r\n}\r\nelse if (istatus & (SELECTED | SEL_ATTENTION))\r\n{\r\nprintk (KERN_ERR "DC390: Target mode not supported!\n");\r\ngoto unlock;\r\n}\r\nif (istatus & (SUCCESSFUL_OP|SERVICE_REQUEST) )\r\n{\r\npDCB = pACB->pActiveDCB;\r\nif (!pDCB)\r\n{\r\nprintk (KERN_ERR "DC390: Suc. op/ Serv. req: pActiveDCB = 0!\n");\r\ngoto unlock;\r\n}\r\npSRB = pDCB->pActiveSRB;\r\nif( pDCB->DCBFlag & ABORT_DEV_ )\r\ndc390_EnableMsgOut_Abort (pACB, pSRB);\r\nphase = pSRB->ScsiPhase;\r\nDEBUG1(printk (KERN_INFO "DC390: [%i]%s(0) (%02x)\n", phase, dc390_p0_str[phase], sstatus));\r\nstateV = (void *) dc390_phase0[phase];\r\n( *stateV )( pACB, pSRB, &sstatus );\r\npSRB->ScsiPhase = sstatus & 7;\r\nphase = (u8) sstatus & 7;\r\nDEBUG1(printk (KERN_INFO "DC390: [%i]%s(1) (%02x)\n", phase, dc390_p1_str[phase], sstatus));\r\nstateV = (void *) dc390_phase1[phase];\r\n( *stateV )( pACB, pSRB, &sstatus );\r\n}\r\nunlock:\r\nspin_unlock_irq(pACB->pScsiHost->host_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t do_DC390_Interrupt(int irq, void *dev_id)\r\n{\r\nirqreturn_t ret;\r\nDEBUG1(printk (KERN_INFO "DC390: Irq (%i) caught: ", irq));\r\nret = DC390_Interrupt(dev_id);\r\nDEBUG1(printk (".. IRQ returned\n"));\r\nreturn ret;\r\n}\r\nstatic void\r\ndc390_DataOut_0(struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\nu8 sstatus;\r\nu32 ResidCnt;\r\nu8 dstate = 0;\r\nsstatus = *psstatus;\r\nif( !(pSRB->SRBState & SRB_XFERPAD) )\r\n{\r\nif( sstatus & (PARITY_ERR | ILLEGAL_OP_ERR) )\r\npSRB->SRBStatus |= PARITY_ERROR;\r\nif( sstatus & COUNT_2_ZERO )\r\n{\r\nunsigned long timeout = jiffies + HZ;\r\nif (pSRB->SGToBeXferLen)\r\nwhile (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {\r\nspin_unlock_irq(pACB->pScsiHost->host_lock);\r\nudelay(50);\r\nspin_lock_irq(pACB->pScsiHost->host_lock);\r\n}\r\nif (!time_before(jiffies, timeout))\r\nprintk (KERN_CRIT "DC390: Deadlock in DataOut_0: DMA aborted unfinished: %06x bytes remain!!\n",\r\nDC390_read32 (DMA_Wk_ByteCntr));\r\ndc390_laststatus &= ~0xff000000;\r\ndc390_laststatus |= dstate << 24;\r\npSRB->TotalXferredLen += pSRB->SGToBeXferLen;\r\npSRB->SGIndex++;\r\nif( pSRB->SGIndex < pSRB->SGcount )\r\n{\r\npSRB->pSegmentList++;\r\ndc390_start_segment(pSRB);\r\n}\r\nelse\r\npSRB->SGToBeXferLen = 0;\r\n}\r\nelse\r\n{\r\nResidCnt = ((u32) DC390_read8 (Current_Fifo) & 0x1f) +\r\n(((u32) DC390_read8 (CtcReg_High) << 16) |\r\n((u32) DC390_read8 (CtcReg_Mid) << 8) |\r\n(u32) DC390_read8 (CtcReg_Low));\r\ndc390_advance_segment(pSRB, ResidCnt);\r\n}\r\n}\r\nif ((*psstatus & 7) != SCSI_DATA_OUT)\r\n{\r\nDC390_write8 (DMA_Cmd, WRITE_DIRECTION+DMA_IDLE_CMD);\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\n}\r\n}\r\nstatic void\r\ndc390_DataIn_0(struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\nu8 sstatus, residual, bval;\r\nu32 ResidCnt, i;\r\nunsigned long xferCnt;\r\nsstatus = *psstatus;\r\nif( !(pSRB->SRBState & SRB_XFERPAD) )\r\n{\r\nif( sstatus & (PARITY_ERR | ILLEGAL_OP_ERR))\r\npSRB->SRBStatus |= PARITY_ERROR;\r\nif( sstatus & COUNT_2_ZERO )\r\n{\r\nint dstate = 0;\r\nunsigned long timeout = jiffies + HZ;\r\nif (pSRB->SGToBeXferLen)\r\nwhile (time_before(jiffies, timeout) && !((dstate = DC390_read8 (DMA_Status)) & DMA_XFER_DONE)) {\r\nspin_unlock_irq(pACB->pScsiHost->host_lock);\r\nudelay(50);\r\nspin_lock_irq(pACB->pScsiHost->host_lock);\r\n}\r\nif (!time_before(jiffies, timeout)) {\r\nprintk (KERN_CRIT "DC390: Deadlock in DataIn_0: DMA aborted unfinished: %06x bytes remain!!\n",\r\nDC390_read32 (DMA_Wk_ByteCntr));\r\nprintk (KERN_CRIT "DC390: DataIn_0: DMA State: %i\n", dstate);\r\n}\r\ndc390_laststatus &= ~0xff000000;\r\ndc390_laststatus |= dstate << 24;\r\nDEBUG1(ResidCnt = ((unsigned long) DC390_read8 (CtcReg_High) << 16) \\r\n+ ((unsigned long) DC390_read8 (CtcReg_Mid) << 8) \\r\n+ ((unsigned long) DC390_read8 (CtcReg_Low)));\r\nDEBUG1(printk (KERN_DEBUG "Count_2_Zero (ResidCnt=%u,ToBeXfer=%lu),", ResidCnt, pSRB->SGToBeXferLen));\r\nDC390_write8 (DMA_Cmd, READ_DIRECTION+DMA_IDLE_CMD);\r\npSRB->TotalXferredLen += pSRB->SGToBeXferLen;\r\npSRB->SGIndex++;\r\nif( pSRB->SGIndex < pSRB->SGcount )\r\n{\r\npSRB->pSegmentList++;\r\ndc390_start_segment(pSRB);\r\n}\r\nelse\r\npSRB->SGToBeXferLen = 0;\r\n}\r\nelse\r\n{\r\nresidual = 0;\r\nbval = DC390_read8 (Current_Fifo);\r\nwhile( bval & 0x1f )\r\n{\r\nDEBUG1(printk (KERN_DEBUG "Check for residuals,"));\r\nif( (bval & 0x1f) == 1 )\r\n{\r\nfor(i=0; i < 0x100; i++)\r\n{\r\nbval = DC390_read8 (Current_Fifo);\r\nif( !(bval & 0x1f) )\r\ngoto din_1;\r\nelse if( i == 0x0ff )\r\n{\r\nresidual = 1;\r\ngoto din_1;\r\n}\r\n}\r\n}\r\nelse\r\nbval = DC390_read8 (Current_Fifo);\r\n}\r\ndin_1:\r\nDC390_write8 (DMA_Cmd, READ_DIRECTION+DMA_BLAST_CMD);\r\nfor (i = 0xa000; i; i--)\r\n{\r\nbval = DC390_read8 (DMA_Status);\r\nif (bval & BLAST_COMPLETE)\r\nbreak;\r\n}\r\nif (!i) printk (KERN_ERR "DC390: DMA Blast aborted unfinished!\n");\r\ndc390_laststatus &= ~0xff000000;\r\ndc390_laststatus |= bval << 24;\r\nDEBUG1(printk (KERN_DEBUG "Blast: Read %i times DMA_Status %02x", 0xa000-i, bval));\r\nResidCnt = (((u32) DC390_read8 (CtcReg_High) << 16) |\r\n((u32) DC390_read8 (CtcReg_Mid) << 8)) |\r\n(u32) DC390_read8 (CtcReg_Low);\r\nxferCnt = dc390_advance_segment(pSRB, ResidCnt);\r\nif (residual) {\r\nsize_t count = 1;\r\nsize_t offset = pSRB->SGBusAddr - sg_dma_address(pSRB->pSegmentList);\r\nunsigned long flags;\r\nu8 *ptr;\r\nbval = DC390_read8 (ScsiFifo);\r\nlocal_irq_save(flags);\r\nptr = scsi_kmap_atomic_sg(pSRB->pSegmentList, pSRB->SGcount, &offset, &count);\r\nif (likely(ptr)) {\r\n*(ptr + offset) = bval;\r\nscsi_kunmap_atomic_sg(ptr);\r\n}\r\nlocal_irq_restore(flags);\r\nWARN_ON(!ptr);\r\nxferCnt += dc390_advance_segment(pSRB, pSRB->SGToBeXferLen - 1);\r\n}\r\nDEBUG1(printk (KERN_DEBUG "Xfered: %lu, Total: %lu, Remaining: %lu\n", xferCnt,\\r\npSRB->TotalXferredLen, pSRB->SGToBeXferLen));\r\n}\r\n}\r\nif ((*psstatus & 7) != SCSI_DATA_IN)\r\n{\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\nDC390_write8 (DMA_Cmd, READ_DIRECTION+DMA_IDLE_CMD);\r\n}\r\n}\r\nstatic void\r\ndc390_Command_0( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\n}\r\nstatic void\r\ndc390_Status_0( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\npSRB->TargetStatus = DC390_read8 (ScsiFifo);\r\npSRB->EndMessage = DC390_read8 (ScsiFifo);\r\n*psstatus = SCSI_NOP0;\r\npSRB->SRBState = SRB_COMPLETED;\r\nDC390_write8 (ScsiCmd, MSG_ACCEPTED_CMD);\r\n}\r\nstatic void\r\ndc390_MsgOut_0( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\nif( pSRB->SRBState & (SRB_UNEXPECT_RESEL+SRB_ABORT_SENT) )\r\n*psstatus = SCSI_NOP0;\r\n}\r\nstatic void __inline__\r\ndc390_reprog (struct dc390_acb* pACB, struct dc390_dcb* pDCB)\r\n{\r\nDC390_write8 (Sync_Period, pDCB->SyncPeriod);\r\nDC390_write8 (Sync_Offset, pDCB->SyncOffset);\r\nDC390_write8 (CtrlReg3, pDCB->CtrlR3);\r\nDC390_write8 (CtrlReg4, pDCB->CtrlR4);\r\ndc390_SetXferRate (pACB, pDCB);\r\n}\r\nstatic void\r\ndc390_printMsg (u8 *MsgBuf, u8 len)\r\n{\r\nint i;\r\nprintk (" %02x", MsgBuf[0]);\r\nfor (i = 1; i < len; i++)\r\nprintk (" %02x", MsgBuf[i]);\r\nprintk ("\n");\r\n}\r\nstatic void __inline__\r\ndc390_MsgIn_reject (struct dc390_acb* pACB, struct dc390_srb* pSRB)\r\n{\r\npSRB->MsgOutBuf[0] = MESSAGE_REJECT;\r\npSRB->MsgCnt = 1;\r\nDC390_ENABLE_MSGOUT;\r\nDEBUG0 (printk (KERN_INFO "DC390: Reject message\n"));\r\n}\r\nstatic void\r\ndc390_EnableMsgOut_Abort ( struct dc390_acb* pACB, struct dc390_srb* pSRB )\r\n{\r\npSRB->MsgOutBuf[0] = ABORT;\r\npSRB->MsgCnt = 1; DC390_ENABLE_MSGOUT;\r\npSRB->pSRBDCB->DCBFlag &= ~ABORT_DEV_;\r\n}\r\nstatic struct dc390_srb*\r\ndc390_MsgIn_QTag (struct dc390_acb* pACB, struct dc390_dcb* pDCB, s8 tag)\r\n{\r\nstruct dc390_srb* pSRB = pDCB->pGoingSRB;\r\nif (pSRB)\r\n{\r\nstruct scsi_cmnd *scmd = scsi_find_tag(pSRB->pcmd->device, tag);\r\npSRB = (struct dc390_srb *)scmd->host_scribble;\r\nif (pDCB->DCBFlag & ABORT_DEV_)\r\n{\r\npSRB->SRBState = SRB_ABORT_SENT;\r\ndc390_EnableMsgOut_Abort( pACB, pSRB );\r\n}\r\nif (!(pSRB->SRBState & SRB_DISCONNECT))\r\ngoto mingx0;\r\npDCB->pActiveSRB = pSRB;\r\npSRB->SRBState = SRB_DATA_XFER;\r\n}\r\nelse\r\n{\r\nmingx0:\r\npSRB = pACB->pTmpSRB;\r\npSRB->SRBState = SRB_UNEXPECT_RESEL;\r\npDCB->pActiveSRB = pSRB;\r\npSRB->MsgOutBuf[0] = ABORT_TAG;\r\npSRB->MsgCnt = 1; DC390_ENABLE_MSGOUT;\r\n}\r\nreturn pSRB;\r\n}\r\nstatic void\r\ndc390_MsgIn_set_async (struct dc390_acb* pACB, struct dc390_srb* pSRB)\r\n{\r\nstruct dc390_dcb* pDCB = pSRB->pSRBDCB;\r\nif (!(pSRB->SRBState & DO_SYNC_NEGO))\r\nprintk (KERN_INFO "DC390: Target %i initiates Non-Sync?\n", pDCB->TargetID);\r\npSRB->SRBState &= ~DO_SYNC_NEGO;\r\npDCB->SyncMode &= ~(SYNC_ENABLE+SYNC_NEGO_DONE);\r\npDCB->SyncPeriod = 0;\r\npDCB->SyncOffset = 0;\r\npDCB->CtrlR3 = FAST_CLK;\r\npDCB->CtrlR4 &= 0x3f;\r\npDCB->CtrlR4 |= pACB->glitch_cfg;\r\ndc390_reprog (pACB, pDCB);\r\n}\r\nstatic void\r\ndc390_MsgIn_set_sync (struct dc390_acb* pACB, struct dc390_srb* pSRB)\r\n{\r\nu8 bval;\r\nu16 wval, wval1;\r\nstruct dc390_dcb* pDCB = pSRB->pSRBDCB;\r\nu8 oldsyncperiod = pDCB->SyncPeriod;\r\nu8 oldsyncoffset = pDCB->SyncOffset;\r\nif (!(pSRB->SRBState & DO_SYNC_NEGO))\r\n{\r\nprintk (KERN_INFO "DC390: Target %i initiates Sync: %ins %i ... answer ...\n",\r\npDCB->TargetID, pSRB->MsgInBuf[3]<<2, pSRB->MsgInBuf[4]);\r\nif (pSRB->MsgInBuf[4] > 15)\r\n{\r\nprintk (KERN_INFO "DC390: Lower Sync Offset to 15\n");\r\npSRB->MsgInBuf[4] = 15;\r\n}\r\nif (pSRB->MsgInBuf[3] < pDCB->NegoPeriod)\r\n{\r\nprintk (KERN_INFO "DC390: Set sync nego period to %ins\n", pDCB->NegoPeriod << 2);\r\npSRB->MsgInBuf[3] = pDCB->NegoPeriod;\r\n}\r\nmemcpy (pSRB->MsgOutBuf, pSRB->MsgInBuf, 5);\r\npSRB->MsgCnt = 5;\r\nDC390_ENABLE_MSGOUT;\r\n}\r\npSRB->SRBState &= ~DO_SYNC_NEGO;\r\npDCB->SyncMode |= SYNC_ENABLE+SYNC_NEGO_DONE;\r\npDCB->SyncOffset &= 0x0f0;\r\npDCB->SyncOffset |= pSRB->MsgInBuf[4];\r\npDCB->NegoPeriod = pSRB->MsgInBuf[3];\r\nwval = (u16) pSRB->MsgInBuf[3];\r\nwval = wval << 2; wval -= 3; wval1 = wval / 25;\r\nif( (wval1 * 25) != wval) wval1++;\r\nbval = FAST_CLK+FAST_SCSI;\r\npDCB->CtrlR4 &= 0x3f;\r\nif (pACB->glitch_cfg != NS_TO_GLITCH(0))\r\npDCB->CtrlR4 |= NS_TO_GLITCH(((GLITCH_TO_NS(pACB->glitch_cfg)) - 1));\r\nelse\r\npDCB->CtrlR4 |= NS_TO_GLITCH(0);\r\nif (wval1 < 4) pDCB->CtrlR4 |= NS_TO_GLITCH(0);\r\nif (wval1 >= 8)\r\n{\r\nwval1--;\r\nbval = FAST_CLK;\r\npDCB->CtrlR4 |= pACB->glitch_cfg;\r\n}\r\npDCB->CtrlR3 = bval;\r\npDCB->SyncPeriod = (u8)wval1;\r\nif ((oldsyncperiod != wval1 || oldsyncoffset != pDCB->SyncOffset) && pDCB->TargetLUN == 0)\r\n{\r\nif (! (bval & FAST_SCSI)) wval1++;\r\nprintk (KERN_INFO "DC390: Target %i: Sync transfer %i.%1i MHz, Offset %i\n", pDCB->TargetID,\r\n40/wval1, ((40%wval1)*10+wval1/2)/wval1, pDCB->SyncOffset & 0x0f);\r\n}\r\ndc390_reprog (pACB, pDCB);\r\n}\r\nstatic void\r\ndc390_restore_ptr (struct dc390_acb* pACB, struct dc390_srb* pSRB)\r\n{\r\nstruct scsi_cmnd *pcmd = pSRB->pcmd;\r\nstruct scatterlist *psgl;\r\npSRB->TotalXferredLen = 0;\r\npSRB->SGIndex = 0;\r\nif (scsi_sg_count(pcmd)) {\r\nsize_t saved;\r\npSRB->pSegmentList = scsi_sglist(pcmd);\r\npsgl = pSRB->pSegmentList;\r\nwhile (pSRB->TotalXferredLen + (unsigned long) sg_dma_len(psgl) < pSRB->Saved_Ptr)\r\n{\r\npSRB->TotalXferredLen += (unsigned long) sg_dma_len(psgl);\r\npSRB->SGIndex++;\r\nif( pSRB->SGIndex < pSRB->SGcount )\r\n{\r\npSRB->pSegmentList++;\r\ndc390_start_segment(pSRB);\r\n}\r\nelse\r\npSRB->SGToBeXferLen = 0;\r\n}\r\nsaved = pSRB->Saved_Ptr - pSRB->TotalXferredLen;\r\npSRB->SGToBeXferLen -= saved;\r\npSRB->SGBusAddr += saved;\r\nprintk (KERN_INFO "DC390: Pointer restored. Segment %i, Total %li, Bus %08lx\n",\r\npSRB->SGIndex, pSRB->Saved_Ptr, pSRB->SGBusAddr);\r\n} else {\r\npSRB->SGcount = 0;\r\nprintk (KERN_INFO "DC390: RESTORE_PTR message for Transfer without Scatter-Gather ??\n");\r\n}\r\npSRB->TotalXferredLen = pSRB->Saved_Ptr;\r\n}\r\nstatic u8 __inline__\r\ndc390_MsgIn_complete (u8 *msgbuf, u32 len)\r\n{\r\nif (*msgbuf == EXTENDED_MESSAGE)\r\n{\r\nif (len < 2) return 0;\r\nif (len < msgbuf[1] + 2) return 0;\r\n}\r\nelse if (*msgbuf >= 0x20 && *msgbuf <= 0x2f)\r\nif (len < 2) return 0;\r\nreturn 1;\r\n}\r\nstatic void\r\ndc390_MsgIn_0( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\nstruct dc390_dcb* pDCB = pACB->pActiveDCB;\r\npSRB->MsgInBuf[pACB->MsgLen++] = DC390_read8 (ScsiFifo);\r\nif (dc390_MsgIn_complete (pSRB->MsgInBuf, pACB->MsgLen))\r\n{\r\nDEBUG0 (printk (KERN_INFO "DC390: MsgIn:"); dc390_printMsg (pSRB->MsgInBuf, pACB->MsgLen));\r\nswitch (pSRB->MsgInBuf[0])\r\n{\r\ncase DISCONNECT:\r\npSRB->SRBState = SRB_DISCONNECT; break;\r\ncase SIMPLE_QUEUE_TAG:\r\ncase HEAD_OF_QUEUE_TAG:\r\ncase ORDERED_QUEUE_TAG:\r\npSRB = dc390_MsgIn_QTag (pACB, pDCB, pSRB->MsgInBuf[1]);\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nDC390_write8 (ScsiCmd, RESET_ATN_CMD);\r\npDCB->NegoPeriod = 50;\r\nif( pSRB->SRBState & DO_SYNC_NEGO)\r\ndc390_MsgIn_set_async (pACB, pSRB);\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nif (pSRB->MsgInBuf[1] != 3 || pSRB->MsgInBuf[2] != EXTENDED_SDTR)\r\ndc390_MsgIn_reject (pACB, pSRB);\r\nelse\r\n{\r\nif (pSRB->MsgInBuf[3] == 0 || pSRB->MsgInBuf[4] == 0)\r\ndc390_MsgIn_set_async (pACB, pSRB);\r\nelse\r\ndc390_MsgIn_set_sync (pACB, pSRB);\r\n}\r\ncase COMMAND_COMPLETE: break;\r\ncase SAVE_POINTERS:\r\npSRB->Saved_Ptr = pSRB->TotalXferredLen;\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nDEBUG0(printk ("DC390: RESTORE POINTER message received ... try to handle\n"));\r\ndc390_restore_ptr (pACB, pSRB);\r\nbreak;\r\ndefault: dc390_MsgIn_reject (pACB, pSRB);\r\n}\r\npSRB->SRBState &= ~SRB_MSGIN;\r\npACB->MsgLen = 0;\r\n}\r\n*psstatus = SCSI_NOP0;\r\nDC390_write8 (ScsiCmd, MSG_ACCEPTED_CMD);\r\n}\r\nstatic void\r\ndc390_DataIO_Comm( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 ioDir)\r\n{\r\nunsigned long lval;\r\nstruct dc390_dcb* pDCB = pACB->pActiveDCB;\r\nif (pSRB == pACB->pTmpSRB)\r\n{\r\nif (pDCB)\r\nprintk(KERN_ERR "DC390: pSRB == pTmpSRB! (TagQ Error?) (%02i-%i)\n", pDCB->TargetID, pDCB->TargetLUN);\r\nelse\r\nprintk(KERN_ERR "DC390: pSRB == pTmpSRB! (TagQ Error?) (DCB 0!)\n");\r\nif (pDCB && pACB->scan_devices && pDCB->GoingSRBCnt == 1) {\r\npSRB = pDCB->pGoingSRB;\r\npDCB->pActiveSRB = pSRB;\r\n} else {\r\npSRB->pSRBDCB = pDCB;\r\ndc390_EnableMsgOut_Abort(pACB, pSRB);\r\nif (pDCB)\r\npDCB->DCBFlag |= ABORT_DEV;\r\nreturn;\r\n}\r\n}\r\nif( pSRB->SGIndex < pSRB->SGcount )\r\n{\r\nDC390_write8 (DMA_Cmd, DMA_IDLE_CMD | ioDir);\r\nif( !pSRB->SGToBeXferLen )\r\n{\r\ndc390_start_segment(pSRB);\r\nDEBUG1(printk (KERN_DEBUG " DC390: Next SG segment."));\r\n}\r\nlval = pSRB->SGToBeXferLen;\r\nDEBUG1(printk (KERN_DEBUG " DC390: Start transfer: %li bytes (address %08lx)\n", lval, pSRB->SGBusAddr));\r\nDC390_write8 (CtcReg_Low, (u8) lval);\r\nlval >>= 8;\r\nDC390_write8 (CtcReg_Mid, (u8) lval);\r\nlval >>= 8;\r\nDC390_write8 (CtcReg_High, (u8) lval);\r\nDC390_write32 (DMA_XferCnt, pSRB->SGToBeXferLen);\r\nDC390_write32 (DMA_XferAddr, pSRB->SGBusAddr);\r\npSRB->SRBState = SRB_DATA_XFER;\r\nDC390_write8 (ScsiCmd, DMA_COMMAND+INFO_XFER_CMD);\r\nDC390_write8 (DMA_Cmd, DMA_START_CMD | ioDir);\r\n}\r\nelse\r\n{\r\nif( pSRB->SGcount )\r\n{\r\npSRB->AdaptStatus = H_OVER_UNDER_RUN;\r\npSRB->SRBStatus |= OVER_RUN;\r\nDEBUG0(printk (KERN_WARNING " DC390: Overrun -"));\r\n}\r\nDEBUG0(printk (KERN_WARNING " Clear transfer pad \n"));\r\nDC390_write8 (CtcReg_Low, 0);\r\nDC390_write8 (CtcReg_Mid, 0);\r\nDC390_write8 (CtcReg_High, 0);\r\npSRB->SRBState |= SRB_XFERPAD;\r\nDC390_write8 (ScsiCmd, DMA_COMMAND+XFER_PAD_BYTE);\r\n}\r\n}\r\nstatic void\r\ndc390_DataOutPhase( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\ndc390_DataIO_Comm (pACB, pSRB, WRITE_DIRECTION);\r\n}\r\nstatic void\r\ndc390_DataInPhase( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\ndc390_DataIO_Comm (pACB, pSRB, READ_DIRECTION);\r\n}\r\nstatic void\r\ndc390_CommandPhase( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\nstruct dc390_dcb* pDCB;\r\nu8 i, cnt;\r\nu8 *ptr;\r\nDC390_write8 (ScsiCmd, RESET_ATN_CMD);\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\nif( !(pSRB->SRBFlag & AUTO_REQSENSE) )\r\n{\r\ncnt = (u8) pSRB->pcmd->cmd_len;\r\nptr = (u8 *) pSRB->pcmd->cmnd;\r\nfor(i=0; i < cnt; i++)\r\nDC390_write8 (ScsiFifo, *(ptr++));\r\n}\r\nelse\r\n{\r\nDC390_write8 (ScsiFifo, REQUEST_SENSE);\r\npDCB = pACB->pActiveDCB;\r\nDC390_write8 (ScsiFifo, pDCB->TargetLUN << 5);\r\nDC390_write8 (ScsiFifo, 0);\r\nDC390_write8 (ScsiFifo, 0);\r\nDC390_write8 (ScsiFifo, SCSI_SENSE_BUFFERSIZE);\r\nDC390_write8 (ScsiFifo, 0);\r\nDEBUG0(printk(KERN_DEBUG "DC390: AutoReqSense (CmndPhase)!\n"));\r\n}\r\npSRB->SRBState = SRB_COMMAND;\r\nDC390_write8 (ScsiCmd, INFO_XFER_CMD);\r\n}\r\nstatic void\r\ndc390_StatusPhase( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\npSRB->SRBState = SRB_STATUS;\r\nDC390_write8 (ScsiCmd, INITIATOR_CMD_CMPLTE);\r\n}\r\nstatic void\r\ndc390_MsgOutPhase( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\nu8 bval, i, cnt;\r\nu8 *ptr;\r\nstruct dc390_dcb* pDCB;\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\npDCB = pACB->pActiveDCB;\r\nif( !(pSRB->SRBState & SRB_MSGOUT) )\r\n{\r\ncnt = pSRB->MsgCnt;\r\nif( cnt )\r\n{\r\nptr = (u8 *) pSRB->MsgOutBuf;\r\nfor(i=0; i < cnt; i++)\r\nDC390_write8 (ScsiFifo, *(ptr++));\r\npSRB->MsgCnt = 0;\r\nif( (pDCB->DCBFlag & ABORT_DEV_) &&\r\n(pSRB->MsgOutBuf[0] == ABORT) )\r\npSRB->SRBState = SRB_ABORT_SENT;\r\n}\r\nelse\r\n{\r\nbval = ABORT;\r\nif( (pSRB->pcmd->cmnd[0] == INQUIRY ) ||\r\n(pSRB->pcmd->cmnd[0] == REQUEST_SENSE) ||\r\n(pSRB->SRBFlag & AUTO_REQSENSE) )\r\n{\r\nif( pDCB->SyncMode & SYNC_ENABLE )\r\ngoto mop1;\r\n}\r\nDC390_write8 (ScsiFifo, bval);\r\n}\r\nDC390_write8 (ScsiCmd, INFO_XFER_CMD);\r\n}\r\nelse\r\n{\r\nmop1:\r\nprintk (KERN_ERR "DC390: OLD Sync Nego code triggered! (%i %i)\n", pDCB->TargetID, pDCB->TargetLUN);\r\nDC390_write8 (ScsiFifo, EXTENDED_MESSAGE);\r\nDC390_write8 (ScsiFifo, 3);\r\nDC390_write8 (ScsiFifo, EXTENDED_SDTR);\r\nDC390_write8 (ScsiFifo, pDCB->NegoPeriod);\r\nif (pDCB->SyncOffset & 0x0f)\r\nDC390_write8 (ScsiFifo, pDCB->SyncOffset);\r\nelse\r\nDC390_write8 (ScsiFifo, SYNC_NEGO_OFFSET);\r\npSRB->SRBState |= DO_SYNC_NEGO;\r\nDC390_write8 (ScsiCmd, INFO_XFER_CMD);\r\n}\r\n}\r\nstatic void\r\ndc390_MsgInPhase( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\nif( !(pSRB->SRBState & SRB_MSGIN) )\r\n{\r\npSRB->SRBState &= ~SRB_DISCONNECT;\r\npSRB->SRBState |= SRB_MSGIN;\r\n}\r\nDC390_write8 (ScsiCmd, INFO_XFER_CMD);\r\n}\r\nstatic void\r\ndc390_Nop_0( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\n}\r\nstatic void\r\ndc390_Nop_1( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)\r\n{\r\n}\r\nstatic void\r\ndc390_SetXferRate( struct dc390_acb* pACB, struct dc390_dcb* pDCB )\r\n{\r\nu8 bval, i, cnt;\r\nstruct dc390_dcb* ptr;\r\nif( !(pDCB->TargetLUN) )\r\n{\r\nif( !pACB->scan_devices )\r\n{\r\nptr = pACB->pLinkDCB;\r\ncnt = pACB->DCBCnt;\r\nbval = pDCB->TargetID;\r\nfor(i=0; i<cnt; i++)\r\n{\r\nif( ptr->TargetID == bval )\r\n{\r\nptr->SyncPeriod = pDCB->SyncPeriod;\r\nptr->SyncOffset = pDCB->SyncOffset;\r\nptr->CtrlR3 = pDCB->CtrlR3;\r\nptr->CtrlR4 = pDCB->CtrlR4;\r\nptr->SyncMode = pDCB->SyncMode;\r\n}\r\nptr = ptr->pNextDCB;\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void\r\ndc390_Disconnect( struct dc390_acb* pACB )\r\n{\r\nstruct dc390_dcb *pDCB;\r\nstruct dc390_srb *pSRB, *psrb;\r\nu8 i, cnt;\r\nDEBUG0(printk(KERN_INFO "DISC,"));\r\nif (!pACB->Connected) printk(KERN_ERR "DC390: Disconnect not-connected bus?\n");\r\npACB->Connected = 0;\r\npDCB = pACB->pActiveDCB;\r\nif (!pDCB)\r\n{\r\nDEBUG0(printk(KERN_ERR "ACB:%p->ActiveDCB:%p IOPort:%04x IRQ:%02x !\n",\\r\npACB, pDCB, pACB->IOPortBase, pACB->IRQLevel));\r\nmdelay(400);\r\nDC390_read8 (INT_Status);\r\nDC390_write8 (ScsiCmd, EN_SEL_RESEL);\r\nreturn;\r\n}\r\nDC390_write8 (ScsiCmd, EN_SEL_RESEL);\r\npSRB = pDCB->pActiveSRB;\r\npACB->pActiveDCB = NULL;\r\npSRB->ScsiPhase = SCSI_NOP0;\r\nif( pSRB->SRBState & SRB_UNEXPECT_RESEL )\r\npSRB->SRBState = 0;\r\nelse if( pSRB->SRBState & SRB_ABORT_SENT )\r\n{\r\npDCB->TagMask = 0;\r\npDCB->DCBFlag = 0;\r\ncnt = pDCB->GoingSRBCnt;\r\npDCB->GoingSRBCnt = 0;\r\npSRB = pDCB->pGoingSRB;\r\nfor( i=0; i < cnt; i++)\r\n{\r\npsrb = pSRB->pNextSRB;\r\ndc390_Free_insert (pACB, pSRB);\r\npSRB = psrb;\r\n}\r\npDCB->pGoingSRB = NULL;\r\n}\r\nelse\r\n{\r\nif( (pSRB->SRBState & (SRB_START_+SRB_MSGOUT)) ||\r\n!(pSRB->SRBState & (SRB_DISCONNECT+SRB_COMPLETED)) )\r\n{\r\npSRB->AdaptStatus = H_SEL_TIMEOUT;\r\npSRB->TargetStatus = 0;\r\ngoto disc1;\r\n}\r\nelse if (!(pSRB->SRBState & SRB_DISCONNECT) && (pSRB->SRBState & SRB_COMPLETED))\r\n{\r\ndisc1:\r\ndc390_freetag (pDCB, pSRB);\r\npDCB->pActiveSRB = NULL;\r\npSRB->SRBState = SRB_FREE;\r\ndc390_SRBdone( pACB, pDCB, pSRB);\r\n}\r\n}\r\npACB->MsgLen = 0;\r\n}\r\nstatic void\r\ndc390_Reselect( struct dc390_acb* pACB )\r\n{\r\nstruct dc390_dcb* pDCB;\r\nstruct dc390_srb* pSRB;\r\nu8 id, lun;\r\nDEBUG0(printk(KERN_INFO "RSEL,"));\r\npACB->Connected = 1;\r\npDCB = pACB->pActiveDCB;\r\nif( pDCB )\r\n{\r\nDEBUG0(printk ("DC390: (ActiveDCB != 0: Arb. lost but resel. won)!\n"));\r\npSRB = pDCB->pActiveSRB;\r\nif( !( pACB->scan_devices ) )\r\n{\r\nstruct scsi_cmnd *pcmd = pSRB->pcmd;\r\nscsi_set_resid(pcmd, scsi_bufflen(pcmd));\r\nSET_RES_DID(pcmd->result, DID_SOFT_ERROR);\r\ndc390_Going_remove(pDCB, pSRB);\r\ndc390_Free_insert(pACB, pSRB);\r\npcmd->scsi_done (pcmd);\r\nDEBUG0(printk(KERN_DEBUG"DC390: Return SRB %p to free\n", pSRB));\r\n}\r\n}\r\nlun = DC390_read8 (ScsiFifo);\r\nDEBUG0(printk ("Dev %02x,", lun));\r\nif (!(lun & (1 << pACB->pScsiHost->this_id)))\r\nprintk (KERN_ERR "DC390: Reselection must select host adapter: %02x!\n", lun);\r\nelse\r\nlun ^= 1 << pACB->pScsiHost->this_id;\r\nid = 0; while (lun >>= 1) id++;\r\nlun = DC390_read8 (ScsiFifo);\r\nif (!(lun & IDENTIFY_BASE)) printk (KERN_ERR "DC390: Resel: Expect identify message!\n");\r\nlun &= 7;\r\nDEBUG0(printk ("(%02i-%i),", id, lun));\r\npDCB = dc390_findDCB (pACB, id, lun);\r\nif (!pDCB)\r\n{\r\nprintk (KERN_ERR "DC390: Reselect from non existing device (%02i-%i)\n",\r\nid, lun);\r\nreturn;\r\n}\r\npACB->pActiveDCB = pDCB;\r\nif( pDCB->SyncMode & EN_TAG_QUEUEING )\r\n{\r\npSRB = pACB->pTmpSRB;\r\npDCB->pActiveSRB = pSRB;\r\n}\r\nelse\r\n{\r\npSRB = pDCB->pActiveSRB;\r\nif( !pSRB || !(pSRB->SRBState & SRB_DISCONNECT) )\r\n{\r\npSRB= pACB->pTmpSRB;\r\npSRB->SRBState = SRB_UNEXPECT_RESEL;\r\nprintk (KERN_ERR "DC390: Reselect without outstanding cmnd (%02i-%i)\n",\r\nid, lun);\r\npDCB->pActiveSRB = pSRB;\r\ndc390_EnableMsgOut_Abort ( pACB, pSRB );\r\n}\r\nelse\r\n{\r\nif( pDCB->DCBFlag & ABORT_DEV_ )\r\n{\r\npSRB->SRBState = SRB_ABORT_SENT;\r\nprintk (KERN_INFO "DC390: Reselect: Abort (%02i-%i)\n",\r\nid, lun);\r\ndc390_EnableMsgOut_Abort( pACB, pSRB );\r\n}\r\nelse\r\npSRB->SRBState = SRB_DATA_XFER;\r\n}\r\n}\r\nDEBUG1(printk (KERN_DEBUG "Resel SRB(%p): TagNum (%02x)\n", pSRB, pSRB->TagNumber));\r\npSRB->ScsiPhase = SCSI_NOP0;\r\nDC390_write8 (Scsi_Dest_ID, pDCB->TargetID);\r\nDC390_write8 (Sync_Period, pDCB->SyncPeriod);\r\nDC390_write8 (Sync_Offset, pDCB->SyncOffset);\r\nDC390_write8 (CtrlReg1, pDCB->CtrlR1);\r\nDC390_write8 (CtrlReg3, pDCB->CtrlR3);\r\nDC390_write8 (CtrlReg4, pDCB->CtrlR4);\r\nDC390_write8 (ScsiCmd, MSG_ACCEPTED_CMD);\r\n}\r\nstatic int __inline__\r\ndc390_RequestSense(struct dc390_acb* pACB, struct dc390_dcb* pDCB, struct dc390_srb* pSRB)\r\n{\r\nstruct scsi_cmnd *pcmd;\r\npcmd = pSRB->pcmd;\r\nREMOVABLEDEBUG(printk(KERN_INFO "DC390: RequestSense(Cmd %02x, Id %02x, LUN %02x)\n",\\r\npcmd->cmnd[0], pDCB->TargetID, pDCB->TargetLUN));\r\npSRB->SRBFlag |= AUTO_REQSENSE;\r\npSRB->SavedTotXLen = pSRB->TotalXferredLen;\r\npSRB->AdaptStatus = 0;\r\npSRB->TargetStatus = 0;\r\npSRB->SGIndex = 0;\r\npSRB->TotalXferredLen = 0;\r\npSRB->SGToBeXferLen = 0;\r\nreturn dc390_StartSCSI(pACB, pDCB, pSRB);\r\n}\r\nstatic void\r\ndc390_SRBdone( struct dc390_acb* pACB, struct dc390_dcb* pDCB, struct dc390_srb* pSRB )\r\n{\r\nu8 status;\r\nstruct scsi_cmnd *pcmd;\r\npcmd = pSRB->pcmd;\r\ndc390_pci_unmap(pSRB);\r\nstatus = pSRB->TargetStatus;\r\nDEBUG0(printk (" SRBdone (%02x,%08x), SRB %p\n", status, pcmd->result, pSRB));\r\nif(pSRB->SRBFlag & AUTO_REQSENSE)\r\n{\r\npSRB->SRBFlag &= ~AUTO_REQSENSE;\r\npSRB->AdaptStatus = 0;\r\npSRB->TargetStatus = SAM_STAT_CHECK_CONDITION;\r\nif (status == SAM_STAT_CHECK_CONDITION)\r\npcmd->result = MK_RES_LNX(0, DID_BAD_TARGET, 0, 0);\r\nelse\r\n{\r\nif( pSRB->pcmd->cmnd[0] == TEST_UNIT_READY )\r\n{\r\npcmd->result = MK_RES_LNX(DRIVER_SENSE, DID_OK, 0, SAM_STAT_CHECK_CONDITION);\r\nREMOVABLEDEBUG(printk(KERN_INFO "Cmd=%02x, Result=%08x, XferL=%08x\n",pSRB->pcmd->cmnd[0],\\r\n(u32) pcmd->result, (u32) pSRB->TotalXferredLen));\r\n} else {\r\nSET_RES_DRV(pcmd->result, DRIVER_SENSE);\r\nDEBUG0 (printk ("DC390: RETRY (%02x), target %02i-%02i\n", pcmd->cmnd[0], pcmd->device->id, pcmd->device->lun));\r\npSRB->TotalXferredLen = 0;\r\nSET_RES_DID(pcmd->result, DID_SOFT_ERROR);\r\n}\r\n}\r\ngoto cmd_done;\r\n}\r\nif( status )\r\n{\r\nif (status == SAM_STAT_CHECK_CONDITION)\r\n{\r\nif (dc390_RequestSense(pACB, pDCB, pSRB)) {\r\nSET_RES_DID(pcmd->result, DID_ERROR);\r\ngoto cmd_done;\r\n}\r\nreturn;\r\n}\r\nelse if (status == SAM_STAT_TASK_SET_FULL)\r\n{\r\nscsi_track_queue_full(pcmd->device, pDCB->GoingSRBCnt - 1);\r\nDEBUG0 (printk ("DC390: RETRY (%02x), target %02i-%02i\n", pcmd->cmnd[0], pcmd->device->id, pcmd->device->lun));\r\npSRB->TotalXferredLen = 0;\r\nSET_RES_DID(pcmd->result, DID_SOFT_ERROR);\r\n}\r\nelse if (status == SAM_STAT_BUSY &&\r\n(pcmd->cmnd[0] == TEST_UNIT_READY || pcmd->cmnd[0] == INQUIRY) &&\r\npACB->scan_devices)\r\n{\r\npSRB->AdaptStatus = 0;\r\npSRB->TargetStatus = status;\r\npcmd->result = MK_RES(0,0,pSRB->EndMessage,0);\r\n}\r\nelse\r\n{\r\npSRB->TotalXferredLen = 0;\r\nSET_RES_DID(pcmd->result, DID_SOFT_ERROR);\r\ngoto cmd_done;\r\n}\r\n}\r\nelse\r\n{\r\nstatus = pSRB->AdaptStatus;\r\nif (status == H_OVER_UNDER_RUN)\r\n{\r\npSRB->TargetStatus = 0;\r\nSET_RES_DID(pcmd->result,DID_OK);\r\nSET_RES_MSG(pcmd->result,pSRB->EndMessage);\r\n}\r\nelse if (status == H_SEL_TIMEOUT)\r\n{\r\npcmd->result = MK_RES(0, DID_NO_CONNECT, 0, 0);\r\n}\r\nelse if( pSRB->SRBStatus & PARITY_ERROR)\r\n{\r\nSET_RES_DID(pcmd->result,DID_PARITY);\r\nSET_RES_MSG(pcmd->result,pSRB->EndMessage);\r\n}\r\nelse\r\n{\r\npSRB->AdaptStatus = 0;\r\npSRB->TargetStatus = 0;\r\nSET_RES_DID(pcmd->result,DID_OK);\r\n}\r\n}\r\ncmd_done:\r\nscsi_set_resid(pcmd, scsi_bufflen(pcmd) - pSRB->TotalXferredLen);\r\ndc390_Going_remove (pDCB, pSRB);\r\ndc390_Free_insert (pACB, pSRB);\r\nDEBUG0(printk (KERN_DEBUG "DC390: SRBdone: done\n"));\r\npcmd->scsi_done (pcmd);\r\nreturn;\r\n}\r\nstatic void\r\ndc390_DoingSRB_Done(struct dc390_acb* pACB, struct scsi_cmnd *cmd)\r\n{\r\nstruct dc390_dcb *pDCB, *pdcb;\r\nstruct dc390_srb *psrb, *psrb2;\r\nint i;\r\nstruct scsi_cmnd *pcmd;\r\npDCB = pACB->pLinkDCB;\r\npdcb = pDCB;\r\nif (! pdcb) return;\r\ndo\r\n{\r\npsrb = pdcb->pGoingSRB;\r\nfor (i = 0; i < pdcb->GoingSRBCnt; i++)\r\n{\r\npsrb2 = psrb->pNextSRB;\r\npcmd = psrb->pcmd;\r\ndc390_Free_insert (pACB, psrb);\r\npsrb = psrb2;\r\n}\r\npdcb->GoingSRBCnt = 0;\r\npdcb->pGoingSRB = NULL;\r\npdcb->TagMask = 0;\r\npdcb = pdcb->pNextDCB;\r\n} while( pdcb != pDCB );\r\n}\r\nstatic void\r\ndc390_ResetSCSIBus( struct dc390_acb* pACB )\r\n{\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\nDC390_write8 (DMA_Cmd, DMA_IDLE_CMD);\r\nDC390_write8 (ScsiCmd, RST_SCSI_BUS_CMD);\r\npACB->Connected = 0;\r\nreturn;\r\n}\r\nstatic void\r\ndc390_ScsiRstDetect( struct dc390_acb* pACB )\r\n{\r\nprintk ("DC390: Rst_Detect: laststat = %08x\n", dc390_laststatus);\r\nDC390_write8 (DMA_Cmd, DMA_IDLE_CMD);\r\nudelay (1000);\r\nDC390_write8 (ScsiCmd, CLEAR_FIFO_CMD);\r\npACB->pScsiHost->last_reset = jiffies + 5*HZ/2\r\n+ HZ * dc390_eepromBuf[pACB->AdapterIndex][EE_DELAY];\r\npACB->Connected = 0;\r\nif( pACB->ACBFlag & RESET_DEV )\r\npACB->ACBFlag |= RESET_DONE;\r\nelse\r\n{\r\npACB->ACBFlag |= RESET_DETECT;\r\ndc390_ResetDevParam( pACB );\r\ndc390_DoingSRB_Done( pACB, NULL);\r\npACB->pActiveDCB = NULL;\r\npACB->ACBFlag = 0;\r\n}\r\nreturn;\r\n}\r\nstatic int DC390_queuecommand_lck(struct scsi_cmnd *cmd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct dc390_acb *acb = (struct dc390_acb *)sdev->host->hostdata;\r\nstruct dc390_dcb *dcb = sdev->hostdata;\r\nstruct dc390_srb *srb;\r\nif (sdev->queue_depth <= dcb->GoingSRBCnt)\r\ngoto device_busy;\r\nif (acb->pActiveDCB)\r\ngoto host_busy;\r\nif (acb->ACBFlag & (RESET_DETECT|RESET_DONE|RESET_DEV))\r\ngoto host_busy;\r\nsrb = acb->pFreeSRB;\r\nif (unlikely(srb == NULL))\r\ngoto host_busy;\r\ncmd->scsi_done = done;\r\ncmd->result = 0;\r\nacb->Cmds++;\r\nacb->pFreeSRB = srb->pNextSRB;\r\nsrb->pNextSRB = NULL;\r\nsrb->pSRBDCB = dcb;\r\nsrb->pcmd = cmd;\r\ncmd->host_scribble = (char *)srb;\r\nsrb->SGIndex = 0;\r\nsrb->AdaptStatus = 0;\r\nsrb->TargetStatus = 0;\r\nsrb->MsgCnt = 0;\r\nsrb->SRBStatus = 0;\r\nsrb->SRBFlag = 0;\r\nsrb->SRBState = 0;\r\nsrb->TotalXferredLen = 0;\r\nsrb->SGBusAddr = 0;\r\nsrb->SGToBeXferLen = 0;\r\nsrb->ScsiPhase = 0;\r\nsrb->EndMessage = 0;\r\nsrb->TagNumber = SCSI_NO_TAG;\r\nif (dc390_StartSCSI(acb, dcb, srb)) {\r\ndc390_Free_insert(acb, srb);\r\ngoto host_busy;\r\n}\r\ndc390_Going_append(dcb, srb);\r\nreturn 0;\r\nhost_busy:\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\ndevice_busy:\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nint DC390_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct dc390_acb *pACB = (struct dc390_acb*) cmd->device->host->hostdata;\r\nstruct dc390_dcb *pDCB = (struct dc390_dcb*) cmd->device->hostdata;\r\nscmd_printk(KERN_WARNING, cmd, "DC390: Abort command\n");\r\ndc390_dumpinfo(pACB, pDCB, NULL);\r\npDCB->DCBFlag |= ABORT_DEV_;\r\nprintk(KERN_INFO "DC390: Aborted.\n");\r\nreturn FAILED;\r\n}\r\nstatic void dc390_ResetDevParam( struct dc390_acb* pACB )\r\n{\r\nstruct dc390_dcb *pDCB, *pdcb;\r\npDCB = pACB->pLinkDCB;\r\nif (! pDCB) return;\r\npdcb = pDCB;\r\ndo\r\n{\r\npDCB->SyncMode &= ~SYNC_NEGO_DONE;\r\npDCB->SyncPeriod = 0;\r\npDCB->SyncOffset = 0;\r\npDCB->TagMask = 0;\r\npDCB->CtrlR3 = FAST_CLK;\r\npDCB->CtrlR4 &= NEGATE_REQACKDATA | CTRL4_RESERVED | NEGATE_REQACK;\r\npDCB->CtrlR4 |= pACB->glitch_cfg;\r\npDCB = pDCB->pNextDCB;\r\n}\r\nwhile( pdcb != pDCB );\r\npACB->ACBFlag &= ~(RESET_DEV | RESET_DONE | RESET_DETECT);\r\n}\r\nstatic int DC390_bus_reset (struct scsi_cmnd *cmd)\r\n{\r\nstruct dc390_acb* pACB = (struct dc390_acb*) cmd->device->host->hostdata;\r\nu8 bval;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nbval = DC390_read8(CtrlReg1) | DIS_INT_ON_SCSI_RST;\r\nDC390_write8(CtrlReg1, bval);\r\npACB->ACBFlag |= RESET_DEV;\r\ndc390_ResetSCSIBus(pACB);\r\ndc390_ResetDevParam(pACB);\r\nmdelay(1);\r\npACB->pScsiHost->last_reset = jiffies + 3*HZ/2\r\n+ HZ * dc390_eepromBuf[pACB->AdapterIndex][EE_DELAY];\r\nDC390_write8(ScsiCmd, CLEAR_FIFO_CMD);\r\nDC390_read8(INT_Status);\r\ndc390_DoingSRB_Done(pACB, cmd);\r\npACB->pActiveDCB = NULL;\r\npACB->ACBFlag = 0;\r\nbval = DC390_read8(CtrlReg1) & ~DIS_INT_ON_SCSI_RST;\r\nDC390_write8(CtrlReg1, bval);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int dc390_slave_alloc(struct scsi_device *scsi_device)\r\n{\r\nstruct dc390_acb *pACB = (struct dc390_acb*) scsi_device->host->hostdata;\r\nstruct dc390_dcb *pDCB, *pDCB2 = NULL;\r\nuint id = scsi_device->id;\r\nuint lun = scsi_device->lun;\r\npDCB = kzalloc(sizeof(struct dc390_dcb), GFP_KERNEL);\r\nif (!pDCB)\r\nreturn -ENOMEM;\r\nif (!pACB->DCBCnt++) {\r\npACB->pLinkDCB = pDCB;\r\npACB->pDCBRunRobin = pDCB;\r\n} else {\r\npACB->pLastDCB->pNextDCB = pDCB;\r\n}\r\npDCB->pNextDCB = pACB->pLinkDCB;\r\npACB->pLastDCB = pDCB;\r\npDCB->pDCBACB = pACB;\r\npDCB->TargetID = id;\r\npDCB->TargetLUN = lun;\r\nif (lun && (pDCB2 = dc390_findDCB(pACB, id, 0))) {\r\npDCB->DevMode = pDCB2->DevMode;\r\npDCB->SyncMode = pDCB2->SyncMode & SYNC_NEGO_DONE;\r\npDCB->SyncPeriod = pDCB2->SyncPeriod;\r\npDCB->SyncOffset = pDCB2->SyncOffset;\r\npDCB->NegoPeriod = pDCB2->NegoPeriod;\r\npDCB->CtrlR3 = pDCB2->CtrlR3;\r\npDCB->CtrlR4 = pDCB2->CtrlR4;\r\n} else {\r\nu8 index = pACB->AdapterIndex;\r\nPEEprom prom = (PEEprom) &dc390_eepromBuf[index][id << 2];\r\npDCB->DevMode = prom->EE_MODE1;\r\npDCB->NegoPeriod =\r\n(dc390_clock_period1[prom->EE_SPEED] * 25) >> 2;\r\npDCB->CtrlR3 = FAST_CLK;\r\npDCB->CtrlR4 = pACB->glitch_cfg | CTRL4_RESERVED;\r\nif (dc390_eepromBuf[index][EE_MODE2] & ACTIVE_NEGATION)\r\npDCB->CtrlR4 |= NEGATE_REQACKDATA | NEGATE_REQACK;\r\n}\r\nif (pDCB->DevMode & SYNC_NEGO_)\r\npDCB->SyncMode |= SYNC_ENABLE;\r\nelse {\r\npDCB->SyncMode = 0;\r\npDCB->SyncOffset &= ~0x0f;\r\n}\r\npDCB->CtrlR1 = pACB->pScsiHost->this_id;\r\nif (pDCB->DevMode & PARITY_CHK_)\r\npDCB->CtrlR1 |= PARITY_ERR_REPO;\r\npACB->scan_devices = 1;\r\nscsi_device->hostdata = pDCB;\r\nreturn 0;\r\n}\r\nstatic void dc390_slave_destroy(struct scsi_device *scsi_device)\r\n{\r\nstruct dc390_acb* pACB = (struct dc390_acb*) scsi_device->host->hostdata;\r\nstruct dc390_dcb* pDCB = (struct dc390_dcb*) scsi_device->hostdata;\r\nstruct dc390_dcb* pPrevDCB = pACB->pLinkDCB;\r\npACB->scan_devices = 0;\r\nBUG_ON(pDCB->GoingSRBCnt > 1);\r\nif (pDCB == pACB->pLinkDCB) {\r\nif (pACB->pLastDCB == pDCB) {\r\npDCB->pNextDCB = NULL;\r\npACB->pLastDCB = NULL;\r\n}\r\npACB->pLinkDCB = pDCB->pNextDCB;\r\n} else {\r\nwhile (pPrevDCB->pNextDCB != pDCB)\r\npPrevDCB = pPrevDCB->pNextDCB;\r\npPrevDCB->pNextDCB = pDCB->pNextDCB;\r\nif (pDCB == pACB->pLastDCB)\r\npACB->pLastDCB = pPrevDCB;\r\n}\r\nif (pDCB == pACB->pActiveDCB)\r\npACB->pActiveDCB = NULL;\r\nif (pDCB == pACB->pLinkDCB)\r\npACB->pLinkDCB = pDCB->pNextDCB;\r\nif (pDCB == pACB->pDCBRunRobin)\r\npACB->pDCBRunRobin = pDCB->pNextDCB;\r\nkfree(pDCB);\r\npACB->DCBCnt--;\r\n}\r\nstatic int dc390_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct dc390_acb *acb = (struct dc390_acb *)sdev->host->hostdata;\r\nstruct dc390_dcb *dcb = (struct dc390_dcb *)sdev->hostdata;\r\nacb->scan_devices = 0;\r\nif (sdev->tagged_supported && (dcb->DevMode & TAG_QUEUEING_)) {\r\ndcb->SyncMode |= EN_TAG_QUEUEING;\r\nscsi_activate_tcq(sdev, acb->TagMaxNum);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dc390_eeprom_prepare_read(struct pci_dev *pdev, u8 cmd)\r\n{\r\nu8 carryFlag = 1, j = 0x80, bval;\r\nint i;\r\nfor (i = 0; i < 9; i++) {\r\nif (carryFlag) {\r\npci_write_config_byte(pdev, 0x80, 0x40);\r\nbval = 0xc0;\r\n} else\r\nbval = 0x80;\r\nudelay(160);\r\npci_write_config_byte(pdev, 0x80, bval);\r\nudelay(160);\r\npci_write_config_byte(pdev, 0x80, 0);\r\nudelay(160);\r\ncarryFlag = (cmd & j) ? 1 : 0;\r\nj >>= 1;\r\n}\r\n}\r\nstatic u16 dc390_eeprom_get_data(struct pci_dev *pdev)\r\n{\r\nint i;\r\nu16 wval = 0;\r\nu8 bval;\r\nfor (i = 0; i < 16; i++) {\r\nwval <<= 1;\r\npci_write_config_byte(pdev, 0x80, 0x80);\r\nudelay(160);\r\npci_write_config_byte(pdev, 0x80, 0x40);\r\nudelay(160);\r\npci_read_config_byte(pdev, 0x00, &bval);\r\nif (bval == 0x22)\r\nwval |= 1;\r\n}\r\nreturn wval;\r\n}\r\nstatic void dc390_read_eeprom(struct pci_dev *pdev, u16 *ptr)\r\n{\r\nu8 cmd = EEPROM_READ, i;\r\nfor (i = 0; i < 0x40; i++) {\r\npci_write_config_byte(pdev, 0xc0, 0);\r\nudelay(160);\r\ndc390_eeprom_prepare_read(pdev, cmd++);\r\n*ptr++ = dc390_eeprom_get_data(pdev);\r\npci_write_config_byte(pdev, 0x80, 0);\r\npci_write_config_byte(pdev, 0x80, 0);\r\nudelay(160);\r\n}\r\n}\r\nstatic void dc390_eeprom_override(u8 index)\r\n{\r\nu8 *ptr = (u8 *) dc390_eepromBuf[index], id;\r\nif (tmscsim[0] != -2)\r\nptr[EE_ADAPT_SCSI_ID] = (u8)tmscsim[0];\r\nif (tmscsim[3] != -2)\r\nptr[EE_MODE2] = (u8)tmscsim[3];\r\nif (tmscsim[5] != -2)\r\nptr[EE_DELAY] = tmscsim[5];\r\nif (tmscsim[4] != -2)\r\nptr[EE_TAG_CMD_NUM] = (u8)tmscsim[4];\r\nfor (id = 0; id < MAX_SCSI_ID; id++) {\r\nif (tmscsim[2] != -2)\r\nptr[id << 2] = (u8)tmscsim[2];\r\nif (tmscsim[1] != -2)\r\nptr[(id << 2) + 1] = (u8)tmscsim[1];\r\n}\r\n}\r\nstatic void dc390_fill_with_defaults (void)\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++) {\r\nif (tmscsim[i] < 0 || tmscsim[i] > 255)\r\ntmscsim[i] = tmscsim_def[i];\r\n}\r\nif (tmscsim[0] > 7)\r\ntmscsim[0] = 7;\r\nif (tmscsim[1] > 7)\r\ntmscsim[1] = 4;\r\nif (tmscsim[4] > 5)\r\ntmscsim[4] = 4;\r\nif (tmscsim[5] > 180)\r\ntmscsim[5] = 180;\r\n}\r\nstatic void dc390_check_eeprom(struct pci_dev *pdev, u8 index)\r\n{\r\nu8 interpd[] = {1, 3, 5, 10, 16, 30, 60, 120};\r\nu8 EEbuf[128];\r\nu16 *ptr = (u16 *)EEbuf, wval = 0;\r\nint i;\r\ndc390_read_eeprom(pdev, ptr);\r\nmemcpy(dc390_eepromBuf[index], EEbuf, EE_ADAPT_SCSI_ID);\r\nmemcpy(&dc390_eepromBuf[index][EE_ADAPT_SCSI_ID],\r\n&EEbuf[REAL_EE_ADAPT_SCSI_ID], EE_LEN - EE_ADAPT_SCSI_ID);\r\ndc390_eepromBuf[index][EE_DELAY] = interpd[dc390_eepromBuf[index][EE_DELAY]];\r\nfor (i = 0; i < 0x40; i++, ptr++)\r\nwval += *ptr;\r\nif (wval != 0x1234) {\r\nint speed;\r\nprintk(KERN_INFO "DC390_init: No EEPROM found! Trying default settings ...\n");\r\ndc390_fill_with_defaults();\r\nspeed = dc390_clock_speed[tmscsim[1]];\r\nprintk(KERN_INFO "DC390: Used defaults: AdaptID=%i, SpeedIdx=%i (%i.%i MHz), "\r\n"DevMode=0x%02x, AdaptMode=0x%02x, TaggedCmnds=%i (%i), DelayReset=%is\n",\r\ntmscsim[0], tmscsim[1], speed / 10, speed % 10,\r\n(u8)tmscsim[2], (u8)tmscsim[3], tmscsim[4], 2 << (tmscsim[4]), tmscsim[5]);\r\n}\r\n}\r\nstatic void dc390_init_hw(struct dc390_acb *pACB, u8 index)\r\n{\r\nstruct Scsi_Host *shost = pACB->pScsiHost;\r\nu8 dstate;\r\nDC390_write8(CtrlReg1, DIS_INT_ON_SCSI_RST | shost->this_id);\r\nif (pACB->Gmode2 & RST_SCSI_BUS) {\r\ndc390_ResetSCSIBus(pACB);\r\nudelay(1000);\r\nshost->last_reset = jiffies + HZ/2 +\r\nHZ * dc390_eepromBuf[pACB->AdapterIndex][EE_DELAY];\r\n}\r\npACB->ACBFlag = 0;\r\nDC390_read8(INT_Status);\r\nDC390_write8(Scsi_TimeOut, SEL_TIMEOUT);\r\nDC390_write8(Clk_Factor, CLK_FREQ_40MHZ);\r\nDC390_write8(ScsiCmd, NOP_CMD);\r\nDC390_write8(CtrlReg2, EN_FEATURE+EN_SCSI2_CMD);\r\nDC390_write8(CtrlReg3, FAST_CLK);\r\nDC390_write8(CtrlReg4, pACB->glitch_cfg |\r\n(dc390_eepromBuf[index][EE_MODE2] & ACTIVE_NEGATION) ?\r\nNEGATE_REQACKDATA : 0);\r\nDC390_write8(CtcReg_High, 0);\r\nDC390_write8(DMA_Cmd, DMA_IDLE_CMD);\r\nDC390_write8(ScsiCmd, CLEAR_FIFO_CMD);\r\nDC390_write32(DMA_ScsiBusCtrl, EN_INT_ON_PCI_ABORT);\r\ndstate = DC390_read8(DMA_Status);\r\nDC390_write8(DMA_Status, dstate);\r\n}\r\nstatic int dc390_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct dc390_acb *pACB;\r\nstruct Scsi_Host *shost;\r\nunsigned long io_port;\r\nint error = -ENODEV, i;\r\nif (pci_enable_device(pdev))\r\ngoto out;\r\npci_set_master(pdev);\r\nerror = -ENOMEM;\r\nif (disable_clustering)\r\ndriver_template.use_clustering = DISABLE_CLUSTERING;\r\nshost = scsi_host_alloc(&driver_template, sizeof(struct dc390_acb));\r\nif (!shost)\r\ngoto out_disable_device;\r\npACB = (struct dc390_acb *)shost->hostdata;\r\nmemset(pACB, 0, sizeof(struct dc390_acb));\r\ndc390_check_eeprom(pdev, dc390_adapterCnt);\r\ndc390_eeprom_override(dc390_adapterCnt);\r\nio_port = pci_resource_start(pdev, 0);\r\nshost->this_id = dc390_eepromBuf[dc390_adapterCnt][EE_ADAPT_SCSI_ID];\r\nshost->io_port = io_port;\r\nshost->n_io_port = 0x80;\r\nshost->irq = pdev->irq;\r\nshost->base = io_port;\r\nshost->unique_id = io_port;\r\nshost->last_reset = jiffies;\r\npACB->pScsiHost = shost;\r\npACB->IOPortBase = (u16) io_port;\r\npACB->IRQLevel = pdev->irq;\r\nshost->max_id = 8;\r\nif (shost->max_id - 1 ==\r\ndc390_eepromBuf[dc390_adapterCnt][EE_ADAPT_SCSI_ID])\r\nshost->max_id--;\r\nif (dc390_eepromBuf[dc390_adapterCnt][EE_MODE2] & LUN_CHECK)\r\nshost->max_lun = 8;\r\nelse\r\nshost->max_lun = 1;\r\npACB->pFreeSRB = pACB->SRB_array;\r\npACB->SRBCount = MAX_SRB_CNT;\r\npACB->AdapterIndex = dc390_adapterCnt;\r\npACB->TagMaxNum =\r\n2 << dc390_eepromBuf[dc390_adapterCnt][EE_TAG_CMD_NUM];\r\npACB->Gmode2 = dc390_eepromBuf[dc390_adapterCnt][EE_MODE2];\r\nfor (i = 0; i < pACB->SRBCount-1; i++)\r\npACB->SRB_array[i].pNextSRB = &pACB->SRB_array[i+1];\r\npACB->SRB_array[pACB->SRBCount-1].pNextSRB = NULL;\r\npACB->pTmpSRB = &pACB->TmpSRB;\r\npACB->sel_timeout = SEL_TIMEOUT;\r\npACB->glitch_cfg = EATER_25NS;\r\npACB->pdev = pdev;\r\nif (!request_region(io_port, shost->n_io_port, "tmscsim")) {\r\nprintk(KERN_ERR "DC390: register IO ports error!\n");\r\ngoto out_host_put;\r\n}\r\nDC390_read8_(INT_Status, io_port);\r\nif (request_irq(pdev->irq, do_DC390_Interrupt, IRQF_SHARED,\r\n"tmscsim", pACB)) {\r\nprintk(KERN_ERR "DC390: register IRQ error!\n");\r\ngoto out_release_region;\r\n}\r\ndc390_init_hw(pACB, dc390_adapterCnt);\r\ndc390_adapterCnt++;\r\npci_set_drvdata(pdev, shost);\r\nerror = scsi_add_host(shost, &pdev->dev);\r\nif (error)\r\ngoto out_free_irq;\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nout_free_irq:\r\nfree_irq(pdev->irq, pACB);\r\nout_release_region:\r\nrelease_region(io_port, shost->n_io_port);\r\nout_host_put:\r\nscsi_host_put(shost);\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nout:\r\nreturn error;\r\n}\r\nstatic void dc390_remove_one(struct pci_dev *dev)\r\n{\r\nstruct Scsi_Host *scsi_host = pci_get_drvdata(dev);\r\nunsigned long iflags;\r\nstruct dc390_acb* pACB = (struct dc390_acb*) scsi_host->hostdata;\r\nu8 bval;\r\nscsi_remove_host(scsi_host);\r\nspin_lock_irqsave(scsi_host->host_lock, iflags);\r\npACB->ACBFlag = RESET_DEV;\r\nbval = DC390_read8(CtrlReg1) | DIS_INT_ON_SCSI_RST;\r\nDC390_write8 (CtrlReg1, bval);\r\nif (pACB->Gmode2 & RST_SCSI_BUS)\r\ndc390_ResetSCSIBus(pACB);\r\nspin_unlock_irqrestore(scsi_host->host_lock, iflags);\r\nfree_irq(scsi_host->irq, pACB);\r\nrelease_region(scsi_host->io_port, scsi_host->n_io_port);\r\npci_disable_device(dev);\r\nscsi_host_put(scsi_host);\r\npci_set_drvdata(dev, NULL);\r\n}\r\nstatic int __init dc390_module_init(void)\r\n{\r\nif (!disable_clustering) {\r\nprintk(KERN_INFO "DC390: clustering now enabled by default. If you get problems load\n");\r\nprintk(KERN_INFO " with \"disable_clustering=1\" and report to maintainers\n");\r\n}\r\nif (tmscsim[0] == -1 || tmscsim[0] > 15) {\r\ntmscsim[0] = 7;\r\ntmscsim[1] = 4;\r\ntmscsim[2] = PARITY_CHK_ | TAG_QUEUEING_;\r\ntmscsim[3] = MORE2_DRV | GREATER_1G | RST_SCSI_BUS | ACTIVE_NEGATION;\r\ntmscsim[4] = 2;\r\ntmscsim[5] = 10;\r\nprintk (KERN_INFO "DC390: Using safe settings.\n");\r\n}\r\nreturn pci_register_driver(&dc390_driver);\r\n}\r\nstatic void __exit dc390_module_exit(void)\r\n{\r\npci_unregister_driver(&dc390_driver);\r\n}\r\nstatic int __init dc390_setup (char *str)\r\n{\r\nint ints[8],i, im;\r\nget_options(str, ARRAY_SIZE(ints), ints);\r\nim = ints[0];\r\nif (im > 6) {\r\nprintk (KERN_NOTICE "DC390: ignore extra params!\n");\r\nim = 6;\r\n}\r\nfor (i = 0; i < im; i++)\r\ntmscsim[i] = ints[i+1];\r\nreturn 1;\r\n}
