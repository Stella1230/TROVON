void svga_wcrt_multi(void __iomem *regbase, const struct vga_regset *regset, u32 value)\r\n{\r\nu8 regval, bitval, bitnum;\r\nwhile (regset->regnum != VGA_REGSET_END_VAL) {\r\nregval = vga_rcrt(regbase, regset->regnum);\r\nbitnum = regset->lowbit;\r\nwhile (bitnum <= regset->highbit) {\r\nbitval = 1 << bitnum;\r\nregval = regval & ~bitval;\r\nif (value & 1) regval = regval | bitval;\r\nbitnum ++;\r\nvalue = value >> 1;\r\n}\r\nvga_wcrt(regbase, regset->regnum, regval);\r\nregset ++;\r\n}\r\n}\r\nvoid svga_wseq_multi(void __iomem *regbase, const struct vga_regset *regset, u32 value)\r\n{\r\nu8 regval, bitval, bitnum;\r\nwhile (regset->regnum != VGA_REGSET_END_VAL) {\r\nregval = vga_rseq(regbase, regset->regnum);\r\nbitnum = regset->lowbit;\r\nwhile (bitnum <= regset->highbit) {\r\nbitval = 1 << bitnum;\r\nregval = regval & ~bitval;\r\nif (value & 1) regval = regval | bitval;\r\nbitnum ++;\r\nvalue = value >> 1;\r\n}\r\nvga_wseq(regbase, regset->regnum, regval);\r\nregset ++;\r\n}\r\n}\r\nstatic unsigned int svga_regset_size(const struct vga_regset *regset)\r\n{\r\nu8 count = 0;\r\nwhile (regset->regnum != VGA_REGSET_END_VAL) {\r\ncount += regset->highbit - regset->lowbit + 1;\r\nregset ++;\r\n}\r\nreturn 1 << count;\r\n}\r\nvoid svga_set_default_gfx_regs(void __iomem *regbase)\r\n{\r\nvga_wgfx(regbase, VGA_GFX_SR_VALUE, 0x00);\r\nvga_wgfx(regbase, VGA_GFX_SR_ENABLE, 0x00);\r\nvga_wgfx(regbase, VGA_GFX_COMPARE_VALUE, 0x00);\r\nvga_wgfx(regbase, VGA_GFX_DATA_ROTATE, 0x00);\r\nvga_wgfx(regbase, VGA_GFX_PLANE_READ, 0x00);\r\nvga_wgfx(regbase, VGA_GFX_MODE, 0x00);\r\nvga_wgfx(regbase, VGA_GFX_MISC, 0x05);\r\nvga_wgfx(regbase, VGA_GFX_COMPARE_MASK, 0x0F);\r\nvga_wgfx(regbase, VGA_GFX_BIT_MASK, 0xFF);\r\n}\r\nvoid svga_set_default_atc_regs(void __iomem *regbase)\r\n{\r\nu8 count;\r\nvga_r(regbase, 0x3DA);\r\nvga_w(regbase, VGA_ATT_W, 0x00);\r\nfor (count = 0; count <= 0xF; count ++)\r\nsvga_wattr(regbase, count, count);\r\nsvga_wattr(regbase, VGA_ATC_MODE, 0x01);\r\nsvga_wattr(regbase, VGA_ATC_OVERSCAN, 0x00);\r\nsvga_wattr(regbase, VGA_ATC_PLANE_ENABLE, 0x0F);\r\nsvga_wattr(regbase, VGA_ATC_PEL, 0x00);\r\nsvga_wattr(regbase, VGA_ATC_COLOR_PAGE, 0x00);\r\nvga_r(regbase, 0x3DA);\r\nvga_w(regbase, VGA_ATT_W, 0x20);\r\n}\r\nvoid svga_set_default_seq_regs(void __iomem *regbase)\r\n{\r\nvga_wseq(regbase, VGA_SEQ_CLOCK_MODE, VGA_SR01_CHAR_CLK_8DOTS);\r\nvga_wseq(regbase, VGA_SEQ_PLANE_WRITE, VGA_SR02_ALL_PLANES);\r\nvga_wseq(regbase, VGA_SEQ_CHARACTER_MAP, 0x00);\r\nvga_wseq(regbase, VGA_SEQ_MEMORY_MODE, VGA_SR04_EXT_MEM | VGA_SR04_SEQ_MODE);\r\n}\r\nvoid svga_set_default_crt_regs(void __iomem *regbase)\r\n{\r\nsvga_wcrt_mask(regbase, 0x03, 0x80, 0x80);\r\nvga_wcrt(regbase, VGA_CRTC_PRESET_ROW, 0);\r\nsvga_wcrt_mask(regbase, VGA_CRTC_MAX_SCAN, 0, 0x1F);\r\nvga_wcrt(regbase, VGA_CRTC_UNDERLINE, 0);\r\nvga_wcrt(regbase, VGA_CRTC_MODE, 0xE3);\r\n}\r\nvoid svga_set_textmode_vga_regs(void __iomem *regbase)\r\n{\r\nvga_wseq(regbase, VGA_SEQ_MEMORY_MODE, VGA_SR04_EXT_MEM);\r\nvga_wseq(regbase, VGA_SEQ_PLANE_WRITE, 0x03);\r\nvga_wcrt(regbase, VGA_CRTC_MAX_SCAN, 0x0f);\r\nvga_wcrt(regbase, VGA_CRTC_UNDERLINE, 0x1f);\r\nsvga_wcrt_mask(regbase, VGA_CRTC_MODE, 0x23, 0x7f);\r\nvga_wcrt(regbase, VGA_CRTC_CURSOR_START, 0x0d);\r\nvga_wcrt(regbase, VGA_CRTC_CURSOR_END, 0x0e);\r\nvga_wcrt(regbase, VGA_CRTC_CURSOR_HI, 0x00);\r\nvga_wcrt(regbase, VGA_CRTC_CURSOR_LO, 0x00);\r\nvga_wgfx(regbase, VGA_GFX_MODE, 0x10);\r\nvga_wgfx(regbase, VGA_GFX_MISC, 0x0E);\r\nvga_wgfx(regbase, VGA_GFX_COMPARE_MASK, 0x00);\r\nvga_r(regbase, 0x3DA);\r\nvga_w(regbase, VGA_ATT_W, 0x00);\r\nsvga_wattr(regbase, 0x10, 0x0C);\r\nsvga_wattr(regbase, 0x13, 0x08);\r\nvga_r(regbase, 0x3DA);\r\nvga_w(regbase, VGA_ATT_W, 0x20);\r\n}\r\nvoid svga_settile(struct fb_info *info, struct fb_tilemap *map)\r\n{\r\nconst u8 *font = map->data;\r\nu8 __iomem *fb = (u8 __iomem *)info->screen_base;\r\nint i, c;\r\nif ((map->width != 8) || (map->height != 16) ||\r\n(map->depth != 1) || (map->length != 256)) {\r\nprintk(KERN_ERR "fb%d: unsupported font parameters: width %d, height %d, depth %d, length %d\n",\r\ninfo->node, map->width, map->height, map->depth, map->length);\r\nreturn;\r\n}\r\nfb += 2;\r\nfor (c = 0; c < map->length; c++) {\r\nfor (i = 0; i < map->height; i++) {\r\nfb_writeb(font[i], fb + i * 4);\r\n}\r\nfb += 128;\r\nfont += map->height;\r\n}\r\n}\r\nvoid svga_tilecopy(struct fb_info *info, struct fb_tilearea *area)\r\n{\r\nint dx, dy;\r\nint colstride = 1 << (info->fix.type_aux & FB_AUX_TEXT_SVGA_MASK);\r\nint rowstride = colstride * (info->var.xres_virtual / 8);\r\nu16 __iomem *fb = (u16 __iomem *) info->screen_base;\r\nu16 __iomem *src, *dst;\r\nif ((area->sy > area->dy) ||\r\n((area->sy == area->dy) && (area->sx > area->dx))) {\r\nsrc = fb + area->sx * colstride + area->sy * rowstride;\r\ndst = fb + area->dx * colstride + area->dy * rowstride;\r\n} else {\r\nsrc = fb + (area->sx + area->width - 1) * colstride\r\n+ (area->sy + area->height - 1) * rowstride;\r\ndst = fb + (area->dx + area->width - 1) * colstride\r\n+ (area->dy + area->height - 1) * rowstride;\r\ncolstride = -colstride;\r\nrowstride = -rowstride;\r\n}\r\nfor (dy = 0; dy < area->height; dy++) {\r\nu16 __iomem *src2 = src;\r\nu16 __iomem *dst2 = dst;\r\nfor (dx = 0; dx < area->width; dx++) {\r\nfb_writew(fb_readw(src2), dst2);\r\nsrc2 += colstride;\r\ndst2 += colstride;\r\n}\r\nsrc += rowstride;\r\ndst += rowstride;\r\n}\r\n}\r\nvoid svga_tilefill(struct fb_info *info, struct fb_tilerect *rect)\r\n{\r\nint dx, dy;\r\nint colstride = 2 << (info->fix.type_aux & FB_AUX_TEXT_SVGA_MASK);\r\nint rowstride = colstride * (info->var.xres_virtual / 8);\r\nint attr = (0x0F & rect->bg) << 4 | (0x0F & rect->fg);\r\nu8 __iomem *fb = (u8 __iomem *)info->screen_base;\r\nfb += rect->sx * colstride + rect->sy * rowstride;\r\nfor (dy = 0; dy < rect->height; dy++) {\r\nu8 __iomem *fb2 = fb;\r\nfor (dx = 0; dx < rect->width; dx++) {\r\nfb_writeb(rect->index, fb2);\r\nfb_writeb(attr, fb2 + 1);\r\nfb2 += colstride;\r\n}\r\nfb += rowstride;\r\n}\r\n}\r\nvoid svga_tileblit(struct fb_info *info, struct fb_tileblit *blit)\r\n{\r\nint dx, dy, i;\r\nint colstride = 2 << (info->fix.type_aux & FB_AUX_TEXT_SVGA_MASK);\r\nint rowstride = colstride * (info->var.xres_virtual / 8);\r\nint attr = (0x0F & blit->bg) << 4 | (0x0F & blit->fg);\r\nu8 __iomem *fb = (u8 __iomem *)info->screen_base;\r\nfb += blit->sx * colstride + blit->sy * rowstride;\r\ni=0;\r\nfor (dy=0; dy < blit->height; dy ++) {\r\nu8 __iomem *fb2 = fb;\r\nfor (dx = 0; dx < blit->width; dx ++) {\r\nfb_writeb(blit->indices[i], fb2);\r\nfb_writeb(attr, fb2 + 1);\r\nfb2 += colstride;\r\ni ++;\r\nif (i == blit->length) return;\r\n}\r\nfb += rowstride;\r\n}\r\n}\r\nvoid svga_tilecursor(void __iomem *regbase, struct fb_info *info, struct fb_tilecursor *cursor)\r\n{\r\nu8 cs = 0x0d;\r\nu8 ce = 0x0e;\r\nu16 pos = cursor->sx + (info->var.xoffset / 8)\r\n+ (cursor->sy + (info->var.yoffset / 16))\r\n* (info->var.xres_virtual / 8);\r\nif (! cursor -> mode)\r\nreturn;\r\nsvga_wcrt_mask(regbase, 0x0A, 0x20, 0x20);\r\nif (cursor -> shape == FB_TILE_CURSOR_NONE)\r\nreturn;\r\nswitch (cursor -> shape) {\r\ncase FB_TILE_CURSOR_UNDERLINE:\r\ncs = 0x0d;\r\nbreak;\r\ncase FB_TILE_CURSOR_LOWER_THIRD:\r\ncs = 0x09;\r\nbreak;\r\ncase FB_TILE_CURSOR_LOWER_HALF:\r\ncs = 0x07;\r\nbreak;\r\ncase FB_TILE_CURSOR_TWO_THIRDS:\r\ncs = 0x05;\r\nbreak;\r\ncase FB_TILE_CURSOR_BLOCK:\r\ncs = 0x01;\r\nbreak;\r\n}\r\nvga_wcrt(regbase, 0x0E, pos >> 8);\r\nvga_wcrt(regbase, 0x0F, pos & 0xFF);\r\nvga_wcrt(regbase, 0x0B, ce);\r\nvga_wcrt(regbase, 0x0A, cs);\r\n}\r\nint svga_get_tilemax(struct fb_info *info)\r\n{\r\nreturn 256;\r\n}\r\nvoid svga_get_caps(struct fb_info *info, struct fb_blit_caps *caps,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nif (var->bits_per_pixel == 0) {\r\ncaps->x = 1 << (8 - 1);\r\ncaps->y = 1 << (16 - 1);\r\ncaps->len = 256;\r\n} else {\r\ncaps->x = (var->bits_per_pixel == 4) ? 1 << (8 - 1) : ~(u32)0;\r\ncaps->y = ~(u32)0;\r\ncaps->len = ~(u32)0;\r\n}\r\n}\r\nstatic inline u32 abs_diff(u32 a, u32 b)\r\n{\r\nreturn (a > b) ? (a - b) : (b - a);\r\n}\r\nint svga_compute_pll(const struct svga_pll *pll, u32 f_wanted, u16 *m, u16 *n, u16 *r, int node)\r\n{\r\nu16 am, an, ar;\r\nu32 f_vco, f_current, delta_current, delta_best;\r\npr_debug("fb%d: ideal frequency: %d kHz\n", node, (unsigned int) f_wanted);\r\nar = pll->r_max;\r\nf_vco = f_wanted << ar;\r\nif ((f_vco >> ar) != f_wanted)\r\nreturn -EINVAL;\r\nwhile ((ar > pll->r_min) && (f_vco > pll->f_vco_max)) {\r\nar--;\r\nf_vco = f_vco >> 1;\r\n}\r\nif ((f_vco < pll->f_vco_min) || (f_vco > pll->f_vco_max))\r\nreturn -EINVAL;\r\ndelta_best = 0xFFFFFFFF;\r\n*m = 0;\r\n*n = 0;\r\n*r = ar;\r\nam = pll->m_min;\r\nan = pll->n_min;\r\nwhile ((am <= pll->m_max) && (an <= pll->n_max)) {\r\nf_current = (pll->f_base * am) / an;\r\ndelta_current = abs_diff (f_current, f_vco);\r\nif (delta_current < delta_best) {\r\ndelta_best = delta_current;\r\n*m = am;\r\n*n = an;\r\n}\r\nif (f_current <= f_vco) {\r\nam ++;\r\n} else {\r\nan ++;\r\n}\r\n}\r\nf_current = (pll->f_base * *m) / *n;\r\npr_debug("fb%d: found frequency: %d kHz (VCO %d kHz)\n", node, (int) (f_current >> ar), (int) f_current);\r\npr_debug("fb%d: m = %d n = %d r = %d\n", node, (unsigned int) *m, (unsigned int) *n, (unsigned int) *r);\r\nreturn 0;\r\n}\r\nint svga_check_timings(const struct svga_timing_regs *tm, struct fb_var_screeninfo *var, int node)\r\n{\r\nu32 value;\r\nvar->xres = (var->xres+7)&~7;\r\nvar->left_margin = (var->left_margin+7)&~7;\r\nvar->right_margin = (var->right_margin+7)&~7;\r\nvar->hsync_len = (var->hsync_len+7)&~7;\r\nvalue = var->xres + var->left_margin + var->right_margin + var->hsync_len;\r\nif (((value / 8) - 5) >= svga_regset_size (tm->h_total_regs))\r\nreturn -EINVAL;\r\nvalue = var->xres;\r\nif (((value / 8) - 1) >= svga_regset_size (tm->h_display_regs))\r\nreturn -EINVAL;\r\nif (((value / 8) - 1) >= svga_regset_size (tm->h_blank_start_regs))\r\nreturn -EINVAL;\r\nvalue = var->xres + var->right_margin;\r\nif (((value / 8) - 1) >= svga_regset_size (tm->h_sync_start_regs))\r\nreturn -EINVAL;\r\nvalue = var->left_margin + var->right_margin + var->hsync_len;\r\nif ((value == 0) || ((value / 8) >= svga_regset_size (tm->h_blank_end_regs)))\r\nreturn -EINVAL;\r\nvalue = var->hsync_len;\r\nif ((value == 0) || ((value / 8) >= svga_regset_size (tm->h_sync_end_regs)))\r\nreturn -EINVAL;\r\nvalue = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;\r\nif ((value - 1) >= svga_regset_size(tm->v_total_regs))\r\nreturn -EINVAL;\r\nvalue = var->yres;\r\nif ((value - 1) >= svga_regset_size(tm->v_display_regs))\r\nreturn -EINVAL;\r\nif ((value - 1) >= svga_regset_size(tm->v_blank_start_regs))\r\nreturn -EINVAL;\r\nvalue = var->yres + var->lower_margin;\r\nif ((value - 1) >= svga_regset_size(tm->v_sync_start_regs))\r\nreturn -EINVAL;\r\nvalue = var->upper_margin + var->lower_margin + var->vsync_len;\r\nif ((value == 0) || (value >= svga_regset_size (tm->v_blank_end_regs)))\r\nreturn -EINVAL;\r\nvalue = var->vsync_len;\r\nif ((value == 0) || (value >= svga_regset_size (tm->v_sync_end_regs)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid svga_set_timings(void __iomem *regbase, const struct svga_timing_regs *tm,\r\nstruct fb_var_screeninfo *var,\r\nu32 hmul, u32 hdiv, u32 vmul, u32 vdiv, u32 hborder, int node)\r\n{\r\nu8 regval;\r\nu32 value;\r\nvalue = var->xres + var->left_margin + var->right_margin + var->hsync_len;\r\nvalue = (value * hmul) / hdiv;\r\npr_debug("fb%d: horizontal total : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->h_total_regs, (value / 8) - 5);\r\nvalue = var->xres;\r\nvalue = (value * hmul) / hdiv;\r\npr_debug("fb%d: horizontal display : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->h_display_regs, (value / 8) - 1);\r\nvalue = var->xres;\r\nvalue = (value * hmul) / hdiv;\r\npr_debug("fb%d: horizontal blank start: %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->h_blank_start_regs, (value / 8) - 1 + hborder);\r\nvalue = var->xres + var->left_margin + var->right_margin + var->hsync_len;\r\nvalue = (value * hmul) / hdiv;\r\npr_debug("fb%d: horizontal blank end : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->h_blank_end_regs, (value / 8) - 1 - hborder);\r\nvalue = var->xres + var->right_margin;\r\nvalue = (value * hmul) / hdiv;\r\npr_debug("fb%d: horizontal sync start : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->h_sync_start_regs, (value / 8));\r\nvalue = var->xres + var->right_margin + var->hsync_len;\r\nvalue = (value * hmul) / hdiv;\r\npr_debug("fb%d: horizontal sync end : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->h_sync_end_regs, (value / 8));\r\nvalue = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;\r\nvalue = (value * vmul) / vdiv;\r\npr_debug("fb%d: vertical total : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->v_total_regs, value - 2);\r\nvalue = var->yres;\r\nvalue = (value * vmul) / vdiv;\r\npr_debug("fb%d: vertical display : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->v_display_regs, value - 1);\r\nvalue = var->yres;\r\nvalue = (value * vmul) / vdiv;\r\npr_debug("fb%d: vertical blank start : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->v_blank_start_regs, value);\r\nvalue = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;\r\nvalue = (value * vmul) / vdiv;\r\npr_debug("fb%d: vertical blank end : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->v_blank_end_regs, value - 2);\r\nvalue = var->yres + var->lower_margin;\r\nvalue = (value * vmul) / vdiv;\r\npr_debug("fb%d: vertical sync start : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->v_sync_start_regs, value);\r\nvalue = var->yres + var->lower_margin + var->vsync_len;\r\nvalue = (value * vmul) / vdiv;\r\npr_debug("fb%d: vertical sync end : %d\n", node, value);\r\nsvga_wcrt_multi(regbase, tm->v_sync_end_regs, value);\r\nregval = vga_r(regbase, VGA_MIS_R);\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT) {\r\npr_debug("fb%d: positive horizontal sync\n", node);\r\nregval = regval & ~0x80;\r\n} else {\r\npr_debug("fb%d: negative horizontal sync\n", node);\r\nregval = regval | 0x80;\r\n}\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT) {\r\npr_debug("fb%d: positive vertical sync\n", node);\r\nregval = regval & ~0x40;\r\n} else {\r\npr_debug("fb%d: negative vertical sync\n\n", node);\r\nregval = regval | 0x40;\r\n}\r\nvga_w(regbase, VGA_MIS_W, regval);\r\n}\r\nstatic inline int match_format(const struct svga_fb_format *frm,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nint i = 0;\r\nint stored = -EINVAL;\r\nwhile (frm->bits_per_pixel != SVGA_FORMAT_END_VAL)\r\n{\r\nif ((var->bits_per_pixel == frm->bits_per_pixel) &&\r\n(var->red.length <= frm->red.length) &&\r\n(var->green.length <= frm->green.length) &&\r\n(var->blue.length <= frm->blue.length) &&\r\n(var->transp.length <= frm->transp.length) &&\r\n(var->nonstd == frm->nonstd))\r\nreturn i;\r\nif (var->bits_per_pixel == frm->bits_per_pixel)\r\nstored = i;\r\ni++;\r\nfrm++;\r\n}\r\nreturn stored;\r\n}\r\nint svga_match_format(const struct svga_fb_format *frm,\r\nstruct fb_var_screeninfo *var,\r\nstruct fb_fix_screeninfo *fix)\r\n{\r\nint i = match_format(frm, var);\r\nif (i >= 0) {\r\nvar->bits_per_pixel = frm[i].bits_per_pixel;\r\nvar->red = frm[i].red;\r\nvar->green = frm[i].green;\r\nvar->blue = frm[i].blue;\r\nvar->transp = frm[i].transp;\r\nvar->nonstd = frm[i].nonstd;\r\nif (fix != NULL) {\r\nfix->type = frm[i].type;\r\nfix->type_aux = frm[i].type_aux;\r\nfix->visual = frm[i].visual;\r\nfix->xpanstep = frm[i].xpanstep;\r\n}\r\n}\r\nreturn i;\r\n}
