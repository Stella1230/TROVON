static void lprintk(char *buf)\r\n{\r\nchar *p;\r\nwhile (buf) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = 0;\r\nprintk(KERN_DEBUG "%s\n", buf);\r\nbuf = p;\r\nif (buf)\r\nbuf++;\r\n}\r\n}\r\nstatic int uhci_show_td(struct uhci_hcd *uhci, struct uhci_td *td, char *buf,\r\nint len, int space)\r\n{\r\nchar *out = buf;\r\nchar *spid;\r\nu32 status, token;\r\nstatus = td_status(uhci, td);\r\nout += sprintf(out, "%*s[%p] link (%08x) ", space, "", td,\r\nhc32_to_cpu(uhci, td->link));\r\nout += sprintf(out, "e%d %s%s%s%s%s%s%s%s%s%sLength=%x ",\r\n((status >> 27) & 3),\r\n(status & TD_CTRL_SPD) ? "SPD " : "",\r\n(status & TD_CTRL_LS) ? "LS " : "",\r\n(status & TD_CTRL_IOC) ? "IOC " : "",\r\n(status & TD_CTRL_ACTIVE) ? "Active " : "",\r\n(status & TD_CTRL_STALLED) ? "Stalled " : "",\r\n(status & TD_CTRL_DBUFERR) ? "DataBufErr " : "",\r\n(status & TD_CTRL_BABBLE) ? "Babble " : "",\r\n(status & TD_CTRL_NAK) ? "NAK " : "",\r\n(status & TD_CTRL_CRCTIMEO) ? "CRC/Timeo " : "",\r\n(status & TD_CTRL_BITSTUFF) ? "BitStuff " : "",\r\nstatus & 0x7ff);\r\nif (out - buf > len)\r\ngoto done;\r\ntoken = td_token(uhci, td);\r\nswitch (uhci_packetid(token)) {\r\ncase USB_PID_SETUP:\r\nspid = "SETUP";\r\nbreak;\r\ncase USB_PID_OUT:\r\nspid = "OUT";\r\nbreak;\r\ncase USB_PID_IN:\r\nspid = "IN";\r\nbreak;\r\ndefault:\r\nspid = "?";\r\nbreak;\r\n}\r\nout += sprintf(out, "MaxLen=%x DT%d EndPt=%x Dev=%x, PID=%x(%s) ",\r\ntoken >> 21,\r\n((token >> 19) & 1),\r\n(token >> 15) & 15,\r\n(token >> 8) & 127,\r\n(token & 0xff),\r\nspid);\r\nout += sprintf(out, "(buf=%08x)\n", hc32_to_cpu(uhci, td->buffer));\r\ndone:\r\nif (out - buf > len)\r\nout += sprintf(out, " ...\n");\r\nreturn out - buf;\r\n}\r\nstatic int uhci_show_urbp(struct uhci_hcd *uhci, struct urb_priv *urbp,\r\nchar *buf, int len, int space)\r\n{\r\nchar *out = buf;\r\nstruct uhci_td *td;\r\nint i, nactive, ninactive;\r\nchar *ptype;\r\nout += sprintf(out, "urb_priv [%p] ", urbp);\r\nout += sprintf(out, "urb [%p] ", urbp->urb);\r\nout += sprintf(out, "qh [%p] ", urbp->qh);\r\nout += sprintf(out, "Dev=%d ", usb_pipedevice(urbp->urb->pipe));\r\nout += sprintf(out, "EP=%x(%s) ", usb_pipeendpoint(urbp->urb->pipe),\r\n(usb_pipein(urbp->urb->pipe) ? "IN" : "OUT"));\r\nif (out - buf > len)\r\ngoto done;\r\nswitch (usb_pipetype(urbp->urb->pipe)) {\r\ncase PIPE_ISOCHRONOUS: ptype = "ISO"; break;\r\ncase PIPE_INTERRUPT: ptype = "INT"; break;\r\ncase PIPE_BULK: ptype = "BLK"; break;\r\ndefault:\r\ncase PIPE_CONTROL: ptype = "CTL"; break;\r\n}\r\nout += sprintf(out, "%s%s", ptype, (urbp->fsbr ? " FSBR" : ""));\r\nout += sprintf(out, " Actlen=%d%s", urbp->urb->actual_length,\r\n(urbp->qh->type == USB_ENDPOINT_XFER_CONTROL ?\r\n"-8" : ""));\r\nif (urbp->urb->unlinked)\r\nout += sprintf(out, " Unlinked=%d", urbp->urb->unlinked);\r\nout += sprintf(out, "\n");\r\nif (out - buf > len)\r\ngoto done;\r\ni = nactive = ninactive = 0;\r\nlist_for_each_entry(td, &urbp->td_list, list) {\r\nif (urbp->qh->type != USB_ENDPOINT_XFER_ISOC &&\r\n(++i <= 10 || debug > 2)) {\r\nout += sprintf(out, "%*s%d: ", space + 2, "", i);\r\nout += uhci_show_td(uhci, td, out,\r\nlen - (out - buf), 0);\r\nif (out - buf > len)\r\ngoto tail;\r\n} else {\r\nif (td_status(uhci, td) & TD_CTRL_ACTIVE)\r\n++nactive;\r\nelse\r\n++ninactive;\r\n}\r\n}\r\nif (nactive + ninactive > 0)\r\nout += sprintf(out,\r\n"%*s[skipped %d inactive and %d active TDs]\n",\r\nspace, "", ninactive, nactive);\r\ndone:\r\nif (out - buf > len)\r\nout += sprintf(out, " ...\n");\r\ntail:\r\nreturn out - buf;\r\n}\r\nstatic int uhci_show_qh(struct uhci_hcd *uhci,\r\nstruct uhci_qh *qh, char *buf, int len, int space)\r\n{\r\nchar *out = buf;\r\nint i, nurbs;\r\n__hc32 element = qh_element(qh);\r\nchar *qtype;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_ISOC: qtype = "ISO"; break;\r\ncase USB_ENDPOINT_XFER_INT: qtype = "INT"; break;\r\ncase USB_ENDPOINT_XFER_BULK: qtype = "BLK"; break;\r\ncase USB_ENDPOINT_XFER_CONTROL: qtype = "CTL"; break;\r\ndefault: qtype = "Skel" ; break;\r\n}\r\nout += sprintf(out, "%*s[%p] %s QH link (%08x) element (%08x)\n",\r\nspace, "", qh, qtype,\r\nhc32_to_cpu(uhci, qh->link),\r\nhc32_to_cpu(uhci, element));\r\nif (qh->type == USB_ENDPOINT_XFER_ISOC)\r\nout += sprintf(out,\r\n"%*s period %d phase %d load %d us, frame %x desc [%p]\n",\r\nspace, "", qh->period, qh->phase, qh->load,\r\nqh->iso_frame, qh->iso_packet_desc);\r\nelse if (qh->type == USB_ENDPOINT_XFER_INT)\r\nout += sprintf(out, "%*s period %d phase %d load %d us\n",\r\nspace, "", qh->period, qh->phase, qh->load);\r\nif (out - buf > len)\r\ngoto done;\r\nif (element & UHCI_PTR_QH(uhci))\r\nout += sprintf(out, "%*s Element points to QH (bug?)\n", space, "");\r\nif (element & UHCI_PTR_DEPTH(uhci))\r\nout += sprintf(out, "%*s Depth traverse\n", space, "");\r\nif (element & cpu_to_hc32(uhci, 8))\r\nout += sprintf(out, "%*s Bit 3 set (bug?)\n", space, "");\r\nif (!(element & ~(UHCI_PTR_QH(uhci) | UHCI_PTR_DEPTH(uhci))))\r\nout += sprintf(out, "%*s Element is NULL (bug?)\n", space, "");\r\nif (out - buf > len)\r\ngoto done;\r\nif (list_empty(&qh->queue)) {\r\nout += sprintf(out, "%*s queue is empty\n", space, "");\r\nif (qh == uhci->skel_async_qh) {\r\nout += uhci_show_td(uhci, uhci->term_td, out,\r\nlen - (out - buf), 0);\r\nif (out - buf > len)\r\ngoto tail;\r\n}\r\n} else {\r\nstruct urb_priv *urbp = list_entry(qh->queue.next,\r\nstruct urb_priv, node);\r\nstruct uhci_td *td = list_entry(urbp->td_list.next,\r\nstruct uhci_td, list);\r\nif (element != LINK_TO_TD(uhci, td))\r\nout += sprintf(out, "%*s Element != First TD\n",\r\nspace, "");\r\ni = nurbs = 0;\r\nlist_for_each_entry(urbp, &qh->queue, node) {\r\nif (++i <= 10) {\r\nout += uhci_show_urbp(uhci, urbp, out,\r\nlen - (out - buf), space + 2);\r\nif (out - buf > len)\r\ngoto tail;\r\n}\r\nelse\r\n++nurbs;\r\n}\r\nif (nurbs > 0)\r\nout += sprintf(out, "%*s Skipped %d URBs\n",\r\nspace, "", nurbs);\r\n}\r\nif (out - buf > len)\r\ngoto done;\r\nif (qh->dummy_td) {\r\nout += sprintf(out, "%*s Dummy TD\n", space, "");\r\nout += uhci_show_td(uhci, qh->dummy_td, out,\r\nlen - (out - buf), 0);\r\nif (out - buf > len)\r\ngoto tail;\r\n}\r\ndone:\r\nif (out - buf > len)\r\nout += sprintf(out, " ...\n");\r\ntail:\r\nreturn out - buf;\r\n}\r\nstatic int uhci_show_sc(int port, unsigned short status, char *buf)\r\n{\r\nreturn sprintf(buf, " stat%d = %04x %s%s%s%s%s%s%s%s%s%s\n",\r\nport,\r\nstatus,\r\n(status & USBPORTSC_SUSP) ? " Suspend" : "",\r\n(status & USBPORTSC_OCC) ? " OverCurrentChange" : "",\r\n(status & USBPORTSC_OC) ? " OverCurrent" : "",\r\n(status & USBPORTSC_PR) ? " Reset" : "",\r\n(status & USBPORTSC_LSDA) ? " LowSpeed" : "",\r\n(status & USBPORTSC_RD) ? " ResumeDetect" : "",\r\n(status & USBPORTSC_PEC) ? " EnableChange" : "",\r\n(status & USBPORTSC_PE) ? " Enabled" : "",\r\n(status & USBPORTSC_CSC) ? " ConnectChange" : "",\r\n(status & USBPORTSC_CCS) ? " Connected" : "");\r\n}\r\nstatic int uhci_show_root_hub_state(struct uhci_hcd *uhci, char *buf)\r\n{\r\nchar *rh_state;\r\nswitch (uhci->rh_state) {\r\ncase UHCI_RH_RESET:\r\nrh_state = "reset"; break;\r\ncase UHCI_RH_SUSPENDED:\r\nrh_state = "suspended"; break;\r\ncase UHCI_RH_AUTO_STOPPED:\r\nrh_state = "auto-stopped"; break;\r\ncase UHCI_RH_RESUMING:\r\nrh_state = "resuming"; break;\r\ncase UHCI_RH_SUSPENDING:\r\nrh_state = "suspending"; break;\r\ncase UHCI_RH_RUNNING:\r\nrh_state = "running"; break;\r\ncase UHCI_RH_RUNNING_NODEVS:\r\nrh_state = "running, no devs"; break;\r\ndefault:\r\nrh_state = "?"; break;\r\n}\r\nreturn sprintf(buf, "Root-hub state: %s FSBR: %d\n",\r\nrh_state, uhci->fsbr_is_on);\r\n}\r\nstatic int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)\r\n{\r\nchar *out = buf;\r\nunsigned short usbcmd, usbstat, usbint, usbfrnum;\r\nunsigned int flbaseadd;\r\nunsigned char sof;\r\nunsigned short portsc1, portsc2;\r\nusbcmd = uhci_readw(uhci, 0);\r\nusbstat = uhci_readw(uhci, 2);\r\nusbint = uhci_readw(uhci, 4);\r\nusbfrnum = uhci_readw(uhci, 6);\r\nflbaseadd = uhci_readl(uhci, 8);\r\nsof = uhci_readb(uhci, 12);\r\nportsc1 = uhci_readw(uhci, 16);\r\nportsc2 = uhci_readw(uhci, 18);\r\nout += sprintf(out, " usbcmd = %04x %s%s%s%s%s%s%s%s\n",\r\nusbcmd,\r\n(usbcmd & USBCMD_MAXP) ? "Maxp64 " : "Maxp32 ",\r\n(usbcmd & USBCMD_CF) ? "CF " : "",\r\n(usbcmd & USBCMD_SWDBG) ? "SWDBG " : "",\r\n(usbcmd & USBCMD_FGR) ? "FGR " : "",\r\n(usbcmd & USBCMD_EGSM) ? "EGSM " : "",\r\n(usbcmd & USBCMD_GRESET) ? "GRESET " : "",\r\n(usbcmd & USBCMD_HCRESET) ? "HCRESET " : "",\r\n(usbcmd & USBCMD_RS) ? "RS " : "");\r\nif (out - buf > len)\r\ngoto done;\r\nout += sprintf(out, " usbstat = %04x %s%s%s%s%s%s\n",\r\nusbstat,\r\n(usbstat & USBSTS_HCH) ? "HCHalted " : "",\r\n(usbstat & USBSTS_HCPE) ? "HostControllerProcessError " : "",\r\n(usbstat & USBSTS_HSE) ? "HostSystemError " : "",\r\n(usbstat & USBSTS_RD) ? "ResumeDetect " : "",\r\n(usbstat & USBSTS_ERROR) ? "USBError " : "",\r\n(usbstat & USBSTS_USBINT) ? "USBINT " : "");\r\nif (out - buf > len)\r\ngoto done;\r\nout += sprintf(out, " usbint = %04x\n", usbint);\r\nout += sprintf(out, " usbfrnum = (%d)%03x\n", (usbfrnum >> 10) & 1,\r\n0xfff & (4*(unsigned int)usbfrnum));\r\nout += sprintf(out, " flbaseadd = %08x\n", flbaseadd);\r\nout += sprintf(out, " sof = %02x\n", sof);\r\nif (out - buf > len)\r\ngoto done;\r\nout += uhci_show_sc(1, portsc1, out);\r\nif (out - buf > len)\r\ngoto done;\r\nout += uhci_show_sc(2, portsc2, out);\r\nif (out - buf > len)\r\ngoto done;\r\nout += sprintf(out,\r\n"Most recent frame: %x (%d) Last ISO frame: %x (%d)\n",\r\nuhci->frame_number, uhci->frame_number & 1023,\r\nuhci->last_iso_frame, uhci->last_iso_frame & 1023);\r\ndone:\r\nif (out - buf > len)\r\nout += sprintf(out, " ...\n");\r\nreturn out - buf;\r\n}\r\nstatic int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)\r\n{\r\nchar *out = buf;\r\nint i, j;\r\nstruct uhci_qh *qh;\r\nstruct uhci_td *td;\r\nstruct list_head *tmp, *head;\r\nint nframes, nerrs;\r\n__hc32 link;\r\n__hc32 fsbr_link;\r\nstatic const char * const qh_names[] = {\r\n"unlink", "iso", "int128", "int64", "int32", "int16",\r\n"int8", "int4", "int2", "async", "term"\r\n};\r\nout += uhci_show_root_hub_state(uhci, out);\r\nif (out - buf > len)\r\ngoto done;\r\nout += sprintf(out, "HC status\n");\r\nout += uhci_show_status(uhci, out, len - (out - buf));\r\nif (out - buf > len)\r\ngoto tail;\r\nout += sprintf(out, "Periodic load table\n");\r\nfor (i = 0; i < MAX_PHASE; ++i) {\r\nout += sprintf(out, "\t%d", uhci->load[i]);\r\nif (i % 8 == 7)\r\n*out++ = '\n';\r\n}\r\nout += sprintf(out, "Total: %d, #INT: %d, #ISO: %d\n",\r\nuhci->total_load,\r\nuhci_to_hcd(uhci)->self.bandwidth_int_reqs,\r\nuhci_to_hcd(uhci)->self.bandwidth_isoc_reqs);\r\nif (debug <= 1)\r\ngoto tail;\r\nout += sprintf(out, "Frame List\n");\r\nnframes = 10;\r\nnerrs = 0;\r\nfor (i = 0; i < UHCI_NUMFRAMES; ++i) {\r\n__hc32 qh_dma;\r\nif (out - buf > len)\r\ngoto done;\r\nj = 0;\r\ntd = uhci->frame_cpu[i];\r\nlink = uhci->frame[i];\r\nif (!td)\r\ngoto check_link;\r\nif (nframes > 0) {\r\nout += sprintf(out, "- Frame %d -> (%08x)\n",\r\ni, hc32_to_cpu(uhci, link));\r\nj = 1;\r\n}\r\nhead = &td->fl_list;\r\ntmp = head;\r\ndo {\r\ntd = list_entry(tmp, struct uhci_td, fl_list);\r\ntmp = tmp->next;\r\nif (link != LINK_TO_TD(uhci, td)) {\r\nif (nframes > 0) {\r\nout += sprintf(out,\r\n" link does not match list entry!\n");\r\nif (out - buf > len)\r\ngoto done;\r\n} else\r\n++nerrs;\r\n}\r\nif (nframes > 0) {\r\nout += uhci_show_td(uhci, td, out,\r\nlen - (out - buf), 4);\r\nif (out - buf > len)\r\ngoto tail;\r\n}\r\nlink = td->link;\r\n} while (tmp != head);\r\ncheck_link:\r\nqh_dma = uhci_frame_skel_link(uhci, i);\r\nif (link != qh_dma) {\r\nif (nframes > 0) {\r\nif (!j) {\r\nout += sprintf(out,\r\n"- Frame %d -> (%08x)\n",\r\ni, hc32_to_cpu(uhci, link));\r\nj = 1;\r\n}\r\nout += sprintf(out,\r\n" link does not match QH (%08x)!\n",\r\nhc32_to_cpu(uhci, qh_dma));\r\nif (out - buf > len)\r\ngoto done;\r\n} else\r\n++nerrs;\r\n}\r\nnframes -= j;\r\n}\r\nif (nerrs > 0)\r\nout += sprintf(out, "Skipped %d bad links\n", nerrs);\r\nout += sprintf(out, "Skeleton QHs\n");\r\nif (out - buf > len)\r\ngoto done;\r\nfsbr_link = 0;\r\nfor (i = 0; i < UHCI_NUM_SKELQH; ++i) {\r\nint cnt = 0;\r\nqh = uhci->skelqh[i];\r\nout += sprintf(out, "- skel_%s_qh\n", qh_names[i]);\r\nout += uhci_show_qh(uhci, qh, out, len - (out - buf), 4);\r\nif (out - buf > len)\r\ngoto tail;\r\nif (i == SKEL_TERM) {\r\nif (qh_element(qh) != LINK_TO_TD(uhci, uhci->term_td)) {\r\nout += sprintf(out,\r\n" skel_term_qh element is not set to term_td!\n");\r\nif (out - buf > len)\r\ngoto done;\r\n}\r\nlink = fsbr_link;\r\nif (!link)\r\nlink = LINK_TO_QH(uhci, uhci->skel_term_qh);\r\ngoto check_qh_link;\r\n}\r\nhead = &qh->node;\r\ntmp = head->next;\r\nwhile (tmp != head) {\r\nqh = list_entry(tmp, struct uhci_qh, node);\r\ntmp = tmp->next;\r\nif (++cnt <= 10) {\r\nout += uhci_show_qh(uhci, qh, out,\r\nlen - (out - buf), 4);\r\nif (out - buf > len)\r\ngoto tail;\r\n}\r\nif (!fsbr_link && qh->skel >= SKEL_FSBR)\r\nfsbr_link = LINK_TO_QH(uhci, qh);\r\n}\r\nif ((cnt -= 10) > 0)\r\nout += sprintf(out, " Skipped %d QHs\n", cnt);\r\nlink = UHCI_PTR_TERM(uhci);\r\nif (i <= SKEL_ISO)\r\n;\r\nelse if (i < SKEL_ASYNC)\r\nlink = LINK_TO_QH(uhci, uhci->skel_async_qh);\r\nelse if (!uhci->fsbr_is_on)\r\n;\r\nelse\r\nlink = LINK_TO_QH(uhci, uhci->skel_term_qh);\r\ncheck_qh_link:\r\nif (qh->link != link)\r\nout += sprintf(out,\r\n" last QH not linked to next skeleton!\n");\r\nif (out - buf > len)\r\ngoto done;\r\n}\r\ndone:\r\nif (out - buf > len)\r\nout += sprintf(out, " ...\n");\r\ntail:\r\nreturn out - buf;\r\n}\r\nstatic int uhci_debug_open(struct inode *inode, struct file *file)\r\n{\r\nstruct uhci_hcd *uhci = inode->i_private;\r\nstruct uhci_debug *up;\r\nunsigned long flags;\r\nup = kmalloc(sizeof(*up), GFP_KERNEL);\r\nif (!up)\r\nreturn -ENOMEM;\r\nup->data = kmalloc(MAX_OUTPUT, GFP_KERNEL);\r\nif (!up->data) {\r\nkfree(up);\r\nreturn -ENOMEM;\r\n}\r\nup->size = 0;\r\nspin_lock_irqsave(&uhci->lock, flags);\r\nif (uhci->is_initialized)\r\nup->size = uhci_sprint_schedule(uhci, up->data,\r\nMAX_OUTPUT - EXTRA_SPACE);\r\nspin_unlock_irqrestore(&uhci->lock, flags);\r\nfile->private_data = up;\r\nreturn 0;\r\n}\r\nstatic loff_t uhci_debug_lseek(struct file *file, loff_t off, int whence)\r\n{\r\nstruct uhci_debug *up;\r\nloff_t new = -1;\r\nup = file->private_data;\r\nswitch (whence) {\r\ncase 0:\r\nnew = off;\r\nbreak;\r\ncase 1:\r\nnew = file->f_pos + off;\r\nbreak;\r\n}\r\nif (new < 0 || new > up->size)\r\nreturn -EINVAL;\r\nreturn (file->f_pos = new);\r\n}\r\nstatic ssize_t uhci_debug_read(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct uhci_debug *up = file->private_data;\r\nreturn simple_read_from_buffer(buf, nbytes, ppos, up->data, up->size);\r\n}\r\nstatic int uhci_debug_release(struct inode *inode, struct file *file)\r\n{\r\nstruct uhci_debug *up = file->private_data;\r\nkfree(up->data);\r\nkfree(up);\r\nreturn 0;\r\n}\r\nstatic inline void lprintk(char *buf)\r\n{}\r\nstatic inline int uhci_show_qh(struct uhci_hcd *uhci,\r\nstruct uhci_qh *qh, char *buf, int len, int space)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int uhci_sprint_schedule(struct uhci_hcd *uhci,\r\nchar *buf, int len)\r\n{\r\nreturn 0;\r\n}
