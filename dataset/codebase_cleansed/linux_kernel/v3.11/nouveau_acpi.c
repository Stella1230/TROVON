bool nouveau_is_optimus(void) {\r\nreturn nouveau_dsm_priv.optimus_detected;\r\n}\r\nbool nouveau_is_v1_dsm(void) {\r\nreturn nouveau_dsm_priv.dsm_detected;\r\n}\r\nstatic int nouveau_optimus_dsm(acpi_handle handle, int func, int arg, uint32_t *result)\r\n{\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_object_list input;\r\nunion acpi_object params[4];\r\nunion acpi_object *obj;\r\nint i, err;\r\nchar args_buff[4];\r\ninput.count = 4;\r\ninput.pointer = params;\r\nparams[0].type = ACPI_TYPE_BUFFER;\r\nparams[0].buffer.length = sizeof(nouveau_op_dsm_muid);\r\nparams[0].buffer.pointer = (char *)nouveau_op_dsm_muid;\r\nparams[1].type = ACPI_TYPE_INTEGER;\r\nparams[1].integer.value = 0x00000100;\r\nparams[2].type = ACPI_TYPE_INTEGER;\r\nparams[2].integer.value = func;\r\nparams[3].type = ACPI_TYPE_BUFFER;\r\nparams[3].buffer.length = 4;\r\nfor (i = 0; i < 4; i++)\r\nargs_buff[i] = (arg >> i * 8) & 0xFF;\r\nparams[3].buffer.pointer = args_buff;\r\nerr = acpi_evaluate_object(handle, "_DSM", &input, &output);\r\nif (err) {\r\nprintk(KERN_INFO "failed to evaluate _DSM: %d\n", err);\r\nreturn err;\r\n}\r\nobj = (union acpi_object *)output.pointer;\r\nif (obj->type == ACPI_TYPE_INTEGER)\r\nif (obj->integer.value == 0x80000002) {\r\nreturn -ENODEV;\r\n}\r\nif (obj->type == ACPI_TYPE_BUFFER) {\r\nif (obj->buffer.length == 4 && result) {\r\n*result = 0;\r\n*result |= obj->buffer.pointer[0];\r\n*result |= (obj->buffer.pointer[1] << 8);\r\n*result |= (obj->buffer.pointer[2] << 16);\r\n*result |= (obj->buffer.pointer[3] << 24);\r\n}\r\n}\r\nkfree(output.pointer);\r\nreturn 0;\r\n}\r\nstatic int nouveau_dsm(acpi_handle handle, int func, int arg, uint32_t *result)\r\n{\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_object_list input;\r\nunion acpi_object params[4];\r\nunion acpi_object *obj;\r\nint err;\r\ninput.count = 4;\r\ninput.pointer = params;\r\nparams[0].type = ACPI_TYPE_BUFFER;\r\nparams[0].buffer.length = sizeof(nouveau_dsm_muid);\r\nparams[0].buffer.pointer = (char *)nouveau_dsm_muid;\r\nparams[1].type = ACPI_TYPE_INTEGER;\r\nparams[1].integer.value = 0x00000102;\r\nparams[2].type = ACPI_TYPE_INTEGER;\r\nparams[2].integer.value = func;\r\nparams[3].type = ACPI_TYPE_INTEGER;\r\nparams[3].integer.value = arg;\r\nerr = acpi_evaluate_object(handle, "_DSM", &input, &output);\r\nif (err) {\r\nprintk(KERN_INFO "failed to evaluate _DSM: %d\n", err);\r\nreturn err;\r\n}\r\nobj = (union acpi_object *)output.pointer;\r\nif (obj->type == ACPI_TYPE_INTEGER)\r\nif (obj->integer.value == 0x80000002)\r\nreturn -ENODEV;\r\nif (obj->type == ACPI_TYPE_BUFFER) {\r\nif (obj->buffer.length == 4 && result) {\r\n*result = 0;\r\n*result |= obj->buffer.pointer[0];\r\n*result |= (obj->buffer.pointer[1] << 8);\r\n*result |= (obj->buffer.pointer[2] << 16);\r\n*result |= (obj->buffer.pointer[3] << 24);\r\n}\r\n}\r\nkfree(output.pointer);\r\nreturn 0;\r\n}\r\nstatic int nouveau_test_dsm(acpi_handle test_handle,\r\nint (*dsm_func)(acpi_handle, int, int, uint32_t *),\r\nint sfnc)\r\n{\r\nu32 result = 0;\r\nif (dsm_func(test_handle, 0, 0, &result))\r\nreturn 0;\r\nreturn result & 1 && result & (1 << sfnc);\r\n}\r\nstatic int nouveau_dsm_switch_mux(acpi_handle handle, int mux_id)\r\n{\r\nmxm_wmi_call_mxmx(mux_id == NOUVEAU_DSM_LED_STAMINA ? MXM_MXDS_ADAPTER_IGD : MXM_MXDS_ADAPTER_0);\r\nmxm_wmi_call_mxds(mux_id == NOUVEAU_DSM_LED_STAMINA ? MXM_MXDS_ADAPTER_IGD : MXM_MXDS_ADAPTER_0);\r\nreturn nouveau_dsm(handle, NOUVEAU_DSM_LED, mux_id, NULL);\r\n}\r\nstatic int nouveau_dsm_set_discrete_state(acpi_handle handle, enum vga_switcheroo_state state)\r\n{\r\nint arg;\r\nif (state == VGA_SWITCHEROO_ON)\r\narg = NOUVEAU_DSM_POWER_SPEED;\r\nelse\r\narg = NOUVEAU_DSM_POWER_STAMINA;\r\nnouveau_dsm(handle, NOUVEAU_DSM_POWER, arg, NULL);\r\nreturn 0;\r\n}\r\nstatic int nouveau_dsm_switchto(enum vga_switcheroo_client_id id)\r\n{\r\nif (!nouveau_dsm_priv.dsm_detected)\r\nreturn 0;\r\nif (id == VGA_SWITCHEROO_IGD)\r\nreturn nouveau_dsm_switch_mux(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_LED_STAMINA);\r\nelse\r\nreturn nouveau_dsm_switch_mux(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_LED_SPEED);\r\n}\r\nstatic int nouveau_dsm_power_state(enum vga_switcheroo_client_id id,\r\nenum vga_switcheroo_state state)\r\n{\r\nif (id == VGA_SWITCHEROO_IGD)\r\nreturn 0;\r\nif (!nouveau_dsm_priv.dsm_detected)\r\nreturn 0;\r\nreturn nouveau_dsm_set_discrete_state(nouveau_dsm_priv.dhandle, state);\r\n}\r\nstatic int nouveau_dsm_get_client_id(struct pci_dev *pdev)\r\n{\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL)\r\nreturn VGA_SWITCHEROO_IGD;\r\nif (pdev->bus->number == 0)\r\nreturn VGA_SWITCHEROO_IGD;\r\nreturn VGA_SWITCHEROO_DIS;\r\n}\r\nstatic int nouveau_dsm_pci_probe(struct pci_dev *pdev)\r\n{\r\nacpi_handle dhandle, nvidia_handle;\r\nacpi_status status;\r\nint retval = 0;\r\ndhandle = DEVICE_ACPI_HANDLE(&pdev->dev);\r\nif (!dhandle)\r\nreturn false;\r\nstatus = acpi_get_handle(dhandle, "_DSM", &nvidia_handle);\r\nif (ACPI_FAILURE(status)) {\r\nreturn false;\r\n}\r\nif (nouveau_test_dsm(dhandle, nouveau_dsm, NOUVEAU_DSM_POWER))\r\nretval |= NOUVEAU_DSM_HAS_MUX;\r\nif (nouveau_test_dsm(dhandle, nouveau_optimus_dsm,\r\nNOUVEAU_DSM_OPTIMUS_FN))\r\nretval |= NOUVEAU_DSM_HAS_OPT;\r\nif (retval)\r\nnouveau_dsm_priv.dhandle = dhandle;\r\nreturn retval;\r\n}\r\nstatic bool nouveau_dsm_detect(void)\r\n{\r\nchar acpi_method_name[255] = { 0 };\r\nstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\r\nstruct pci_dev *pdev = NULL;\r\nint has_dsm = 0;\r\nint has_optimus = 0;\r\nint vga_count = 0;\r\nbool guid_valid;\r\nint retval;\r\nbool ret = false;\r\nguid_valid = mxm_wmi_supported();\r\nif (guid_valid)\r\nprintk("MXM: GUID detected in BIOS\n");\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\r\nvga_count++;\r\nretval = nouveau_dsm_pci_probe(pdev);\r\nif (retval & NOUVEAU_DSM_HAS_MUX)\r\nhas_dsm |= 1;\r\nif (retval & NOUVEAU_DSM_HAS_OPT)\r\nhas_optimus = 1;\r\n}\r\nif (has_optimus == 1) {\r\nacpi_get_name(nouveau_dsm_priv.dhandle, ACPI_FULL_PATHNAME,\r\n&buffer);\r\nprintk(KERN_INFO "VGA switcheroo: detected Optimus DSM method %s handle\n",\r\nacpi_method_name);\r\nnouveau_dsm_priv.optimus_detected = true;\r\nret = true;\r\n} else if (vga_count == 2 && has_dsm && guid_valid) {\r\nacpi_get_name(nouveau_dsm_priv.dhandle, ACPI_FULL_PATHNAME,\r\n&buffer);\r\nprintk(KERN_INFO "VGA switcheroo: detected DSM switching method %s handle\n",\r\nacpi_method_name);\r\nnouveau_dsm_priv.dsm_detected = true;\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nvoid nouveau_register_dsm_handler(void)\r\n{\r\nbool r;\r\nr = nouveau_dsm_detect();\r\nif (!r)\r\nreturn;\r\nvga_switcheroo_register_handler(&nouveau_dsm_handler);\r\n}\r\nvoid nouveau_switcheroo_optimus_dsm(void)\r\n{\r\nu32 result = 0;\r\nif (!nouveau_dsm_priv.optimus_detected)\r\nreturn;\r\nnouveau_optimus_dsm(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_OPTIMUS_FN,\r\nNOUVEAU_DSM_OPTIMUS_ARGS, &result);\r\n}\r\nvoid nouveau_unregister_dsm_handler(void)\r\n{\r\nif (nouveau_dsm_priv.optimus_detected || nouveau_dsm_priv.dsm_detected)\r\nvga_switcheroo_unregister_handler();\r\n}\r\nstatic int nouveau_rom_call(acpi_handle rom_handle, uint8_t *bios,\r\nint offset, int len)\r\n{\r\nacpi_status status;\r\nunion acpi_object rom_arg_elements[2], *obj;\r\nstruct acpi_object_list rom_arg;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};\r\nrom_arg.count = 2;\r\nrom_arg.pointer = &rom_arg_elements[0];\r\nrom_arg_elements[0].type = ACPI_TYPE_INTEGER;\r\nrom_arg_elements[0].integer.value = offset;\r\nrom_arg_elements[1].type = ACPI_TYPE_INTEGER;\r\nrom_arg_elements[1].integer.value = len;\r\nstatus = acpi_evaluate_object(rom_handle, NULL, &rom_arg, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_INFO "failed to evaluate ROM got %s\n", acpi_format_exception(status));\r\nreturn -ENODEV;\r\n}\r\nobj = (union acpi_object *)buffer.pointer;\r\nmemcpy(bios+offset, obj->buffer.pointer, len);\r\nkfree(buffer.pointer);\r\nreturn len;\r\n}\r\nbool nouveau_acpi_rom_supported(struct pci_dev *pdev)\r\n{\r\nacpi_status status;\r\nacpi_handle dhandle, rom_handle;\r\nif (!nouveau_dsm_priv.dsm_detected && !nouveau_dsm_priv.optimus_detected)\r\nreturn false;\r\ndhandle = DEVICE_ACPI_HANDLE(&pdev->dev);\r\nif (!dhandle)\r\nreturn false;\r\nstatus = acpi_get_handle(dhandle, "_ROM", &rom_handle);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nnouveau_dsm_priv.rom_handle = rom_handle;\r\nreturn true;\r\n}\r\nint nouveau_acpi_get_bios_chunk(uint8_t *bios, int offset, int len)\r\n{\r\nreturn nouveau_rom_call(nouveau_dsm_priv.rom_handle, bios, offset, len);\r\n}\r\nvoid *\r\nnouveau_acpi_edid(struct drm_device *dev, struct drm_connector *connector)\r\n{\r\nstruct acpi_device *acpidev;\r\nacpi_handle handle;\r\nint type, ret;\r\nvoid *edid;\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\ncase DRM_MODE_CONNECTOR_eDP:\r\ntype = ACPI_VIDEO_DISPLAY_LCD;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nhandle = DEVICE_ACPI_HANDLE(&dev->pdev->dev);\r\nif (!handle)\r\nreturn NULL;\r\nret = acpi_bus_get_device(handle, &acpidev);\r\nif (ret)\r\nreturn NULL;\r\nret = acpi_video_get_edid(acpidev, type, -1, &edid);\r\nif (ret < 0)\r\nreturn NULL;\r\nreturn kmemdup(edid, EDID_LENGTH, GFP_KERNEL);\r\n}
