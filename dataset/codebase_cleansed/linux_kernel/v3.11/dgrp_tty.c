static int calc_baud_rate(struct un_struct *un)\r\n{\r\nint i;\r\nint brate;\r\nstruct baud_rates {\r\nunsigned int rate;\r\nunsigned int cflag;\r\n};\r\nstatic struct baud_rates baud_rates[] = {\r\n{ 921600, B921600 },\r\n{ 460800, B460800 },\r\n{ 230400, B230400 },\r\n{ 115200, B115200 },\r\n{ 57600, B57600 },\r\n{ 38400, B38400 },\r\n{ 19200, B19200 },\r\n{ 9600, B9600 },\r\n{ 4800, B4800 },\r\n{ 2400, B2400 },\r\n{ 1200, B1200 },\r\n{ 600, B600 },\r\n{ 300, B300 },\r\n{ 200, B200 },\r\n{ 150, B150 },\r\n{ 134, B134 },\r\n{ 110, B110 },\r\n{ 75, B75 },\r\n{ 50, B50 },\r\n{ 0, B9600 }\r\n};\r\nbrate = C_BAUD(un->un_tty);\r\nfor (i = 0; baud_rates[i].rate; i++) {\r\nif (baud_rates[i].cflag == brate)\r\nbreak;\r\n}\r\nreturn baud_rates[i].rate;\r\n}\r\nstatic int calc_fastbaud_rate(struct un_struct *un, struct ktermios *uts)\r\n{\r\nint i;\r\nint brate;\r\nulong bauds[2][16] = {\r\n{\r\n0, 57600, 76800, 115200,\r\n131657, 153600, 230400, 460800,\r\n921600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 },\r\n{\r\n0, 57600, 115200, 230400,\r\n460800, 150, 200, 921600,\r\n600, 1200, 1800, 2400,\r\n4800, 9600, 19200, 38400 }\r\n};\r\nbrate = C_BAUD(un->un_tty) & 0xff;\r\ni = (uts->c_cflag & CBAUDEX) ? 1 : 0;\r\nif ((i >= 0) && (i < 2) && (brate >= 0) && (brate < 16))\r\nbrate = bauds[i][brate];\r\nelse\r\nbrate = 0;\r\nreturn brate;\r\n}\r\nstatic void drp_param(struct ch_struct *ch)\r\n{\r\nstruct nd_struct *nd;\r\nstruct un_struct *un;\r\nint brate;\r\nint mflow;\r\nint xflag;\r\nint iflag;\r\nstruct ktermios *tts, *pts, *uts;\r\nnd = ch->ch_nd;\r\nif (ch->ch_tun.un_open_count) {\r\nun = &ch->ch_tun;\r\ntts = &ch->ch_tun.un_tty->termios;\r\nif (ch->ch_pun.un_open_count) {\r\npts = &ch->ch_pun.un_tty->termios;\r\npts->c_cflag ^=\r\n(pts->c_cflag ^ tts->c_cflag) &\r\n(CBAUD | CSIZE | CSTOPB | CREAD | PARENB |\r\nPARODD | HUPCL | CLOCAL);\r\npts->c_iflag ^=\r\n(pts->c_iflag ^ tts->c_iflag) &\r\n(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK |\r\nISTRIP | IXON | IXANY | IXOFF);\r\npts->c_cc[VSTART] = tts->c_cc[VSTART];\r\npts->c_cc[VSTOP] = tts->c_cc[VSTOP];\r\n}\r\n} else if (ch->ch_pun.un_open_count == 0) {\r\npr_warn("%s - ch_pun.un_open_count shouldn't be 0\n",\r\n__func__);\r\nreturn;\r\n} else {\r\nun = &ch->ch_pun;\r\n}\r\nuts = &un->un_tty->termios;\r\nif ((ch->ch_digi.digi_flags & DIGI_COOK) != 0 &&\r\n(ch->ch_tun.un_open_count != 0) &&\r\n!((un->un_tty)->ldisc->ops->flags & LDISC_FLAG_DEFINED) &&\r\n!(L_XCASE(un->un_tty))) {\r\nch->ch_flag |= CH_FAST_WRITE;\r\n} else {\r\nch->ch_flag &= ~CH_FAST_WRITE;\r\n}\r\nif ((ch->ch_flag & CH_FAST_WRITE) &&\r\nO_OPOST(un->un_tty) != 0) {\r\nint oflag = tty_to_ch_flags(un->un_tty, 'o');\r\nch->ch_ocook |= oflag & (OF_OLCUC |\r\nOF_ONLCR |\r\nOF_OCRNL |\r\nOF_ONLRET |\r\nOF_TABDLY);\r\noflag = ch_to_tty_flags(ch->ch_ocook, 'o');\r\nuts->c_oflag &= ~oflag;\r\n} else {\r\nint oflag = ch_to_tty_flags(ch->ch_ocook, 'o');\r\nuts->c_oflag |= oflag;\r\nch->ch_ocook = 0;\r\n}\r\nch->ch_oflag = ch->ch_ocook;\r\nch->ch_flag &= ~CH_FAST_READ;\r\nif (C_BAUD(un->un_tty) == B0) {\r\nif (!(ch->ch_flag & CH_BAUD0)) {\r\nch->ch_tout = ch->ch_tin;\r\nch->ch_rout = ch->ch_rin;\r\nch->ch_break_time = 0;\r\nch->ch_send |= RR_TX_FLUSH | RR_RX_FLUSH;\r\nch->ch_mout &= ~(DM_DTR | DM_RTS);\r\nch->ch_flag |= CH_BAUD0;\r\n}\r\n} else if (ch->ch_custom_speed) {\r\nch->ch_brate = PORTSERVER_DIVIDEND / ch->ch_custom_speed ;\r\nif (ch->ch_flag & CH_BAUD0) {\r\nch->ch_mout |= DM_DTR | DM_RTS;\r\nch->ch_flag &= ~CH_BAUD0;\r\n}\r\n} else {\r\nif (!(ch->ch_digi.digi_flags & DIGI_FAST))\r\nbrate = calc_baud_rate(un);\r\nelse\r\nbrate = calc_fastbaud_rate(un, uts);\r\nif (brate == 0)\r\nbrate = 9600;\r\nch->ch_brate = PORTSERVER_DIVIDEND / brate;\r\nif (ch->ch_flag & CH_BAUD0) {\r\nch->ch_mout |= DM_DTR | DM_RTS;\r\nch->ch_flag &= ~CH_BAUD0;\r\n}\r\n}\r\nch->ch_cflag = tty_to_ch_flags(un->un_tty, 'c');\r\niflag = (int) tty_to_ch_flags(un->un_tty, 'i');\r\nif (START_CHAR(un->un_tty) == _POSIX_VDISABLE ||\r\nSTOP_CHAR(un->un_tty) == _POSIX_VDISABLE) {\r\niflag &= ~(IF_IXON | IF_IXANY | IF_IXOFF);\r\n}\r\nch->ch_iflag = iflag;\r\nif (uts->c_cc[VSTART] != _POSIX_VDISABLE)\r\nch->ch_xon = uts->c_cc[VSTART];\r\nif (uts->c_cc[VSTOP] != _POSIX_VDISABLE)\r\nch->ch_xoff = uts->c_cc[VSTOP];\r\nch->ch_lnext = (uts->c_cc[VLNEXT] == _POSIX_VDISABLE ? 0 :\r\nuts->c_cc[VLNEXT]);\r\nif ((uts->c_cc[VSTART] == _POSIX_VDISABLE) ||\r\n(uts->c_cc[VSTOP] == _POSIX_VDISABLE))\r\nch->ch_iflag &= ~(IF_IXOFF | IF_IXON);\r\nxflag = 0;\r\nif (ch->ch_digi.digi_flags & DIGI_AIXON)\r\nxflag = XF_XIXON;\r\nif ((ch->ch_xxon == _POSIX_VDISABLE) ||\r\n(ch->ch_xxoff == _POSIX_VDISABLE))\r\nxflag &= ~XF_XIXON;\r\nch->ch_xflag = xflag;\r\nif (C_CLOCAL(un->un_tty))\r\nch->ch_flag |= CH_CLOCAL;\r\nelse\r\nch->ch_flag &= ~CH_CLOCAL;\r\ndgrp_carrier(ch);\r\nmflow = 0;\r\nif (C_CRTSCTS(un->un_tty))\r\nmflow |= (DM_RTS | DM_CTS);\r\nif (ch->ch_digi.digi_flags & RTSPACE)\r\nmflow |= DM_RTS;\r\nif (ch->ch_digi.digi_flags & DTRPACE)\r\nmflow |= DM_DTR;\r\nif (ch->ch_digi.digi_flags & CTSPACE)\r\nmflow |= DM_CTS;\r\nif (ch->ch_digi.digi_flags & DSRPACE)\r\nmflow |= DM_DSR;\r\nif (ch->ch_digi.digi_flags & DCDPACE)\r\nmflow |= DM_CD;\r\nif (ch->ch_digi.digi_flags & DIGI_RTS_TOGGLE)\r\nmflow |= DM_RTS_TOGGLE;\r\nch->ch_mflow = mflow;\r\nch->ch_flag |= CH_PARAM;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nif (waitqueue_active(&ch->ch_flag_wait))\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\nstatic void wake_up_drp_sleep_timer(unsigned long ptr)\r\n{\r\nstruct ch_struct *ch = (struct ch_struct *) ptr;\r\nif (ch)\r\nwake_up(&ch->ch_sleep);\r\n}\r\nstatic void drp_my_sleep(struct ch_struct *ch)\r\n{\r\nstruct timer_list drp_wakeup_timer;\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&ch->ch_sleep, &wait);\r\ncurrent->state = TASK_UNINTERRUPTIBLE;\r\ninit_timer(&drp_wakeup_timer);\r\ndrp_wakeup_timer.function = wake_up_drp_sleep_timer;\r\ndrp_wakeup_timer.data = (unsigned long) ch;\r\ndrp_wakeup_timer.expires = jiffies + (1 * HZ);\r\nadd_timer(&drp_wakeup_timer);\r\nschedule();\r\ndel_timer(&drp_wakeup_timer);\r\nremove_wait_queue(&ch->ch_sleep, &wait);\r\n}\r\nstatic int dgrp_tty_open(struct tty_struct *tty, struct file *file)\r\n{\r\nint retval = 0;\r\nstruct nd_struct *nd;\r\nstruct ch_struct *ch;\r\nstruct un_struct *un;\r\nint port;\r\nint delay_error;\r\nint otype;\r\nint unf;\r\nint wait_carrier;\r\nint category;\r\nint counts_were_incremented = 0;\r\nulong lock_flags;\r\nDECLARE_WAITQUEUE(wait, current);\r\nnd = nd_struct_get(MAJOR(tty_devnum(tty)));\r\nport = PORT_NUM(MINOR(tty_devnum(tty)));\r\ncategory = OPEN_CATEGORY(MINOR(tty_devnum(tty)));\r\nif (!nd)\r\nreturn -ENODEV;\r\nif (port >= CHAN_MAX)\r\nreturn -ENODEV;\r\nch = nd->nd_chan + port;\r\nun = IS_PRINT(MINOR(tty_devnum(tty))) ? &ch->ch_pun : &ch->ch_tun;\r\nun->un_tty = tty;\r\ntty->driver_data = un;\r\nif (tty_hung_up_p(file)) {\r\nretval = ((un->un_flag & UN_HUP_NOTIFY) ?\r\n-EAGAIN : -ERESTARTSYS);\r\ngoto done;\r\n}\r\nretval = wait_event_interruptible(un->un_close_wait,\r\n((un->un_flag & UN_CLOSING) == 0));\r\nif (retval)\r\ngoto done;\r\nretval = wait_event_interruptible(ch->ch_flag_wait,\r\n((ch->ch_flag & CH_PORT_GONE) == 0));\r\nif (retval)\r\ngoto done;\r\nif (tty->driver->subtype == SERIAL_TYPE_CALLOUT) {\r\nif (un->un_flag & UN_NORMAL_ACTIVE) {\r\nretval = -EBUSY;\r\ngoto done;\r\n} else {\r\nun->un_flag |= UN_CALLOUT_ACTIVE;\r\n}\r\n}\r\nspin_lock_irqsave(&nd->nd_lock, lock_flags);\r\nnd->nd_tx_work = 1;\r\nfor (;;) {\r\nwait_carrier = 0;\r\nif (test_bit(TTY_IO_ERROR, &tty->flags)) {\r\nif (un->un_flag & UN_CALLOUT_ACTIVE)\r\nretval = -EBUSY;\r\nelse\r\nun->un_flag |= UN_NORMAL_ACTIVE;\r\ngoto unlock;\r\n}\r\nif (file->f_flags & O_NONBLOCK) {\r\notype = OTYPE_IMMEDIATE;\r\ndelay_error = -EAGAIN;\r\n} else if (!OPEN_WAIT_AVAIL(category) ||\r\n(file->f_flags & O_NDELAY) != 0) {\r\notype = OTYPE_IMMEDIATE;\r\ndelay_error = -EBUSY;\r\n} else if (!OPEN_WAIT_CARRIER(category) ||\r\n((ch->ch_digi.digi_flags & DIGI_FORCEDCD) != 0) ||\r\nC_CLOCAL(tty)) {\r\notype = OTYPE_PERSISTENT;\r\ndelay_error = 0;\r\n} else {\r\notype = OTYPE_INCOMING;\r\ndelay_error = 0;\r\n}\r\nif (port >= nd->nd_chan_count) {\r\nif (otype == OTYPE_IMMEDIATE) {\r\nretval = (nd->nd_state == NS_READY) ?\r\n-ENXIO : -EAGAIN;\r\ngoto unlock;\r\n}\r\n}\r\nelse if (ch->ch_open_count == 0) {\r\nif (ch->ch_open_error != 0 && otype == ch->ch_otype) {\r\nretval = (ch->ch_open_error <= 2) ?\r\ndelay_error : -ENXIO ;\r\ngoto unlock;\r\n}\r\nif (nd->nd_state != NS_READY &&\r\notype == OTYPE_IMMEDIATE) {\r\nretval = -EAGAIN;\r\ngoto unlock;\r\n}\r\nif (ch->ch_state == CS_READY && ch->ch_otype == otype)\r\nbreak;\r\n}\r\nelse if ((ch->ch_category == category) ||\r\nIS_PRINT(MINOR(tty_devnum(tty)))) {\r\nunf = ch->ch_tun.un_flag | ch->ch_pun.un_flag;\r\nif ((file->f_flags & O_EXCL) || (unf & UN_EXCL)) {\r\nretval = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (ch->ch_flag & CH_HANGUP) {\r\nretval = -ENXIO;\r\ngoto unlock;\r\n}\r\nif (ch->ch_state == CS_READY &&\r\n(otype != OTYPE_INCOMING ||\r\nch->ch_flag & CH_VIRT_CD))\r\nbreak;\r\nwait_carrier = 1;\r\n}\r\nelse {\r\nif (otype == OTYPE_IMMEDIATE) {\r\nretval = delay_error;\r\ngoto unlock;\r\n}\r\n}\r\nch->ch_wait_count[otype]++;\r\nif (wait_carrier)\r\nch->ch_wait_carrier++;\r\nadd_wait_queue(&ch->ch_flag_wait, &wait);\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nspin_unlock_irqrestore(&nd->nd_lock, lock_flags);\r\nschedule();\r\nremove_wait_queue(&ch->ch_flag_wait, &wait);\r\nspin_lock_irqsave(&nd->nd_lock, lock_flags);\r\ncurrent->state = TASK_RUNNING;\r\nch->ch_wait_count[otype]--;\r\nif (wait_carrier)\r\nch->ch_wait_carrier--;\r\nnd->nd_tx_work = 1;\r\nif (signal_pending(current)) {\r\nretval = -EINTR;\r\ngoto unlock;\r\n}\r\n}\r\ncounts_were_incremented = 1;\r\nun->un_open_count++;\r\nch->ch_open_count++;\r\nif (ch->ch_open_count == 1) {\r\nch->ch_flag = 0;\r\nch->ch_inwait = 0;\r\nch->ch_category = category;\r\nch->ch_pscan_state = 0;\r\nch->ch_send = RR_TX_START | RR_RX_START;\r\nif (C_CLOCAL(tty) ||\r\nch->ch_s_mlast & DM_CD ||\r\nch->ch_digi.digi_flags & DIGI_FORCEDCD)\r\nch->ch_flag |= CH_VIRT_CD;\r\nelse if (OPEN_FORCES_CARRIER(category))\r\nch->ch_flag |= CH_VIRT_CD;\r\n}\r\nif (un->un_open_count == 1) {\r\nun->un_flag &= ~UN_DIGI_MASK;\r\nif (file->f_flags & O_EXCL)\r\nun->un_flag |= UN_EXCL;\r\ndrp_param(ch);\r\n}\r\nun->un_flag |= UN_INITIALIZED;\r\nretval = 0;\r\nunlock:\r\nspin_unlock_irqrestore(&nd->nd_lock, lock_flags);\r\ndone:\r\nif (!counts_were_incremented) {\r\nun->un_open_count++;\r\nch->ch_open_count++;\r\n}\r\nif (retval)\r\ndev_err(tty->dev, "tty open bad return (%i)\n", retval);\r\nreturn retval;\r\n}\r\nstatic void dgrp_tty_close(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct ch_struct *ch;\r\nstruct un_struct *un;\r\nstruct nd_struct *nd;\r\nint tpos;\r\nint port;\r\nint err = 0;\r\nint s = 0;\r\nulong waketime;\r\nulong lock_flags;\r\nint sent_printer_offstr = 0;\r\nport = PORT_NUM(MINOR(tty_devnum(tty)));\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nnd = ch->ch_nd;\r\nif (!nd)\r\nreturn;\r\nspin_lock_irqsave(&nd->nd_lock, lock_flags);\r\nif (un->un_open_count != 1)\r\ngoto unlock;\r\nun->un_flag |= UN_CLOSING;\r\ntty->closing = 1;\r\nif (ch->ch_open_count == 1) {\r\nif (IS_PRINT(MINOR(tty_devnum(tty))) &&\r\n(((ch->ch_tout - ch->ch_tin - 1) & TBUF_MASK) <\r\nch->ch_digi.digi_offlen))\r\nch->ch_tin = ch->ch_tout;\r\nif ((ch->ch_flag & CH_PRON) != 0) {\r\ndrp_wmove(ch, 0, ch->ch_digi.digi_offstr,\r\nch->ch_digi.digi_offlen);\r\nch->ch_flag &= ~CH_PRON;\r\nsent_printer_offstr = 1;\r\n}\r\n}\r\ntpos = ch->ch_s_tpos;\r\nwaketime = jiffies + 15 * HZ;\r\nfor (;;) {\r\nif (port >= nd->nd_chan_count) {\r\nerr = 1;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = 1;\r\nbreak;\r\n}\r\nif (ch->ch_state == CS_IDLE)\r\nbreak;\r\nnd->nd_tx_work = 1;\r\nif ((un->un_tty)->ops->chars_in_buffer ?\r\n((un->un_tty)->ops->chars_in_buffer)(un->un_tty) == 0 : 1) {\r\nif (ch->ch_open_count != un->un_open_count)\r\nbreak;\r\nif (ch->ch_tin == ch->ch_tout &&\r\nch->ch_s_tin == ch->ch_s_tpos &&\r\n(ch->ch_send & RR_TX_BREAK) == 0) {\r\nbreak;\r\n}\r\n}\r\nif ((file->f_flags & (O_NDELAY | O_NONBLOCK)) ||\r\n((long)(jiffies - waketime) >= 0 &&\r\n(ch->ch_digi.digi_flags & DIGI_PRINTER) == 0)) {\r\nif (!sent_printer_offstr)\r\ndgrp_tty_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nbreak;\r\n}\r\nch->ch_flag |= CH_DRAIN;\r\nspin_unlock_irqrestore(&nd->nd_lock, lock_flags);\r\nschedule_timeout_interruptible(1);\r\ns = signal_pending(current);\r\nspin_lock_irqsave(&nd->nd_lock, lock_flags);\r\nif (s) {\r\nif (sent_printer_offstr) {\r\nspin_unlock_irqrestore(&nd->nd_lock,\r\nlock_flags);\r\ndrp_my_sleep(ch);\r\nspin_lock_irqsave(&nd->nd_lock, lock_flags);\r\n} else {\r\nerr = 1;\r\nbreak;\r\n}\r\n}\r\nif (ch->ch_s_tpos != tpos) {\r\ntpos = ch->ch_s_tpos;\r\nwaketime = jiffies + 15 * HZ;\r\n}\r\n}\r\nif (!IS_PRINT(MINOR(tty_devnum(tty))))\r\nch->ch_rout = ch->ch_rin;\r\nif ((err != 1) && (ch->ch_state != CS_IDLE)) {\r\nspin_unlock_irqrestore(&nd->nd_lock, lock_flags);\r\ns = wait_event_interruptible(ch->ch_flag_wait,\r\n((ch->ch_flag & (CH_WAITING_SYNC | CH_PARAM)) == 0));\r\nspin_lock_irqsave(&nd->nd_lock, lock_flags);\r\n}\r\nif (ch->ch_open_count == 1) {\r\nch->ch_flag = 0;\r\nch->ch_category = 0;\r\nch->ch_send = 0;\r\nch->ch_expect = 0;\r\nch->ch_tout = ch->ch_tin;\r\nif (ch->ch_state == CS_READY)\r\nch->ch_state = CS_SEND_CLOSE;\r\n}\r\nif (ch->ch_state != CS_IDLE) {\r\nch->ch_flag |= CH_PARAM;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\nnd->nd_tx_work = 1;\r\nnd->nd_tx_ready = 1;\r\nunlock:\r\ntty->closing = 0;\r\nif (ch->ch_open_count <= 0)\r\ndev_info(tty->dev,\r\n"%s - unexpected value for ch->ch_open_count: %i\n",\r\n__func__, ch->ch_open_count);\r\nelse\r\nch->ch_open_count--;\r\nif (un->un_open_count <= 0)\r\ndev_info(tty->dev,\r\n"%s - unexpected value for un->un_open_count: %i\n",\r\n__func__, un->un_open_count);\r\nelse\r\nun->un_open_count--;\r\nun->un_flag &= ~(UN_NORMAL_ACTIVE | UN_CALLOUT_ACTIVE | UN_CLOSING);\r\nif (waitqueue_active(&un->un_close_wait))\r\nwake_up_interruptible(&un->un_close_wait);\r\nspin_unlock_irqrestore(&nd->nd_lock, lock_flags);\r\nreturn;\r\n}\r\nstatic void drp_wmove(struct ch_struct *ch, int from_user, void *buf, int count)\r\n{\r\nint n;\r\nint ret = 0;\r\nch->ch_nd->nd_tx_work = 1;\r\nn = TBUF_MAX - ch->ch_tin;\r\nif (count >= n) {\r\nif (from_user)\r\nret = copy_from_user(ch->ch_tbuf + ch->ch_tin,\r\n(void __user *) buf, n);\r\nelse\r\nmemcpy(ch->ch_tbuf + ch->ch_tin, buf, n);\r\nbuf = (char *) buf + n;\r\ncount -= n;\r\nch->ch_tin = 0;\r\n}\r\nif (from_user)\r\nret = copy_from_user(ch->ch_tbuf + ch->ch_tin,\r\n(void __user *) buf, count);\r\nelse\r\nmemcpy(ch->ch_tbuf + ch->ch_tin, buf, count);\r\nch->ch_tin += count;\r\n}\r\nstatic int dgrp_calculate_txprint_bounds(struct ch_struct *ch, int space,\r\nint *un_flag)\r\n{\r\nclock_t tt;\r\nclock_t mt;\r\nunsigned short tmax = 0;\r\nif (ch->ch_tun.un_open_count != 0 &&\r\nch->ch_tun.un_tty->ops->chars_in_buffer &&\r\n((ch->ch_tun.un_tty->ops->chars_in_buffer)(ch->ch_tun.un_tty) != 0)) {\r\n*un_flag = UN_PWAIT;\r\nreturn 0;\r\n}\r\nspace -= ch->ch_digi.digi_offlen;\r\nif (space <= 0) {\r\n*un_flag = UN_EMPTY;\r\nreturn 0;\r\n}\r\ntt = jiffies - ch->ch_cpstime;\r\nmt = HZ * ch->ch_digi.digi_bufsize / ch->ch_digi.digi_maxcps;\r\nif ((clock_t)(tt + HZ) > (clock_t)(mt + HZ)) {\r\ntmax = ch->ch_digi.digi_bufsize;\r\nch->ch_cpstime = jiffies - mt;\r\n} else {\r\ntmax = ch->ch_digi.digi_maxcps * tt / HZ;\r\n}\r\nif (tmax < space) {\r\n*un_flag = UN_TIME;\r\nspace = tmax;\r\n}\r\ntmax = (ch->ch_digi.digi_maxchar -\r\n((ch->ch_tin - ch->ch_tout) & TBUF_MASK) -\r\n((ch->ch_s_tin - ch->ch_s_tpos) & 0xffff));\r\nif (space > tmax) {\r\n*un_flag = UN_EMPTY;\r\nspace = tmax;\r\n}\r\nif (space <= 0)\r\n*un_flag |= UN_EMPTY;\r\nreturn space;\r\n}\r\nstatic int dgrp_tty_write(struct tty_struct *tty,\r\nconst unsigned char *buf,\r\nint count)\r\n{\r\nstruct nd_struct *nd;\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nint space;\r\nint n;\r\nint t;\r\nint sendcount;\r\nint un_flag;\r\nulong lock_flags;\r\nif (tty == NULL)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn 0;\r\nnd = ch->ch_nd;\r\nif (!nd)\r\nreturn 0;\r\nif (ch->ch_state != CS_READY)\r\nreturn 0;\r\nspin_lock_irqsave(&dgrp_poll_data.poll_lock, lock_flags);\r\nif ((un->un_flag & (UN_EMPTY | UN_LOW | UN_TIME | UN_PWAIT)) != 0) {\r\ncount = 0;\r\ngoto out;\r\n}\r\nif (nd->nd_dpa_debug && nd->nd_dpa_flag & DPA_WAIT_SPACE &&\r\nnd->nd_dpa_port == MINOR(tty_devnum(ch->ch_tun.un_tty))) {\r\ncount = 0;\r\ngoto out;\r\n}\r\nsendcount = 0;\r\nspace = (ch->ch_tout - ch->ch_tin - 1) & TBUF_MASK;\r\nun_flag = UN_LOW;\r\nif (IS_PRINT(MINOR(tty_devnum(tty)))) {\r\nclock_t tt;\r\nclock_t mt;\r\nunsigned short tmax = 0;\r\nif (ch->ch_tun.un_open_count != 0 &&\r\n((ch->ch_tun.un_tty->ops->chars_in_buffer)(ch->ch_tun.un_tty) != 0)) {\r\nun->un_flag |= UN_PWAIT;\r\ncount = 0;\r\ngoto out;\r\n}\r\nspace -= ch->ch_digi.digi_offlen;\r\nif ((ch->ch_flag & CH_PRON) == 0) {\r\nspace -= ch->ch_digi.digi_onlen;\r\nif (space < 0) {\r\nun->un_flag |= UN_EMPTY;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\ncount = 0;\r\ngoto out;\r\n}\r\ndrp_wmove(ch, 0, ch->ch_digi.digi_onstr,\r\nch->ch_digi.digi_onlen);\r\nch->ch_flag |= CH_PRON;\r\n}\r\ntt = jiffies - ch->ch_cpstime;\r\nmt = HZ * ch->ch_digi.digi_bufsize / ch->ch_digi.digi_maxcps;\r\nif ((clock_t)(tt + HZ) > (clock_t)(mt + HZ)) {\r\ntmax = ch->ch_digi.digi_bufsize;\r\nch->ch_cpstime = jiffies - mt;\r\n} else {\r\ntmax = ch->ch_digi.digi_maxcps * tt / HZ;\r\n}\r\nif (tmax < space) {\r\nspace = tmax;\r\nun_flag = UN_TIME;\r\n}\r\ntmax = (ch->ch_digi.digi_maxchar -\r\n((ch->ch_tin - ch->ch_tout) & TBUF_MASK) -\r\n((ch->ch_s_tin - ch->ch_s_tpos) & 0xffff));\r\nif (space > tmax) {\r\nspace = tmax;\r\nun_flag = UN_EMPTY;\r\n}\r\n}\r\nelse {\r\nif ((ch->ch_flag & CH_PRON) != 0) {\r\nspace -= ch->ch_digi.digi_offlen;\r\ndrp_wmove(ch, 0, ch->ch_digi.digi_offstr,\r\nch->ch_digi.digi_offlen);\r\nch->ch_flag &= ~CH_PRON;\r\n}\r\n}\r\nif (space <= 0) {\r\nun->un_flag |= UN_EMPTY;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\ncount = 0;\r\ngoto out;\r\n}\r\ncount = min(count, space);\r\nif (count > 0) {\r\nun->un_tbusy++;\r\nt = TBUF_MAX - ch->ch_tin;\r\nn = count;\r\nif (n >= t) {\r\nmemcpy(ch->ch_tbuf + ch->ch_tin, buf, t);\r\nif (nd->nd_dpa_debug && nd->nd_dpa_port == PORT_NUM(MINOR(tty_devnum(un->un_tty))))\r\ndgrp_dpa_data(nd, 0, (char *) buf, t);\r\nbuf += t;\r\nn -= t;\r\nch->ch_tin = 0;\r\nsendcount += n;\r\n}\r\nmemcpy(ch->ch_tbuf + ch->ch_tin, buf, n);\r\nif (nd->nd_dpa_debug && nd->nd_dpa_port == PORT_NUM(MINOR(tty_devnum(un->un_tty))))\r\ndgrp_dpa_data(nd, 0, (char *) buf, n);\r\nbuf += n;\r\nch->ch_tin += n;\r\nsendcount += n;\r\nun->un_tbusy--;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nif (ch->ch_edelay != DGRP_RTIME) {\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\nwake_up_interruptible(&nd->nd_tx_waitq);\r\n}\r\n}\r\nch->ch_txcount += count;\r\nif (IS_PRINT(MINOR(tty_devnum(tty)))) {\r\nif (sendcount > 0) {\r\nint cc = HZ * sendcount + ch->ch_cpsrem;\r\nch->ch_cpstime += cc / ch->ch_digi.digi_maxcps;\r\nch->ch_cpsrem = cc % ch->ch_digi.digi_maxcps;\r\n}\r\nif ((un_flag & UN_TIME) != 0) {\r\nch->ch_waketime = (ch->ch_cpstime +\r\n(ch->ch_digi.digi_maxchar * HZ /\r\nch->ch_digi.digi_maxcps));\r\n}\r\n}\r\nif ((ch->ch_pun.un_flag & UN_PWAIT) != 0)\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nout:\r\nspin_unlock_irqrestore(&dgrp_poll_data.poll_lock, lock_flags);\r\nreturn count;\r\n}\r\nstatic int dgrp_tty_put_char(struct tty_struct *tty, unsigned char new_char)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nulong lock_flags;\r\nint space;\r\nint retval = 0;\r\nif (tty == NULL)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn 0;\r\nif (ch->ch_state != CS_READY)\r\nreturn 0;\r\nspin_lock_irqsave(&dgrp_poll_data.poll_lock, lock_flags);\r\nspace = (ch->ch_tout - ch->ch_tin - 1) & TBUF_MASK;\r\nun->un_tbusy++;\r\nif (IS_PRINT(MINOR(tty_devnum(tty))) && (ch->ch_flag & CH_PRON) == 0) {\r\nif (space < ch->ch_digi.digi_onlen) {\r\nun->un_tbusy--;\r\ngoto out;\r\n}\r\nspace -= ch->ch_digi.digi_onlen;\r\ndrp_wmove(ch, 0, ch->ch_digi.digi_onstr,\r\nch->ch_digi.digi_onlen);\r\nch->ch_flag |= CH_PRON;\r\n}\r\nif (!IS_PRINT(MINOR(tty_devnum(tty))) &&\r\n((ch->ch_flag & CH_PRON) != 0)) {\r\nif (space < ch->ch_digi.digi_offlen) {\r\nun->un_tbusy--;\r\ngoto out;\r\n}\r\nspace -= ch->ch_digi.digi_offlen;\r\ndrp_wmove(ch, 0, ch->ch_digi.digi_offstr,\r\nch->ch_digi.digi_offlen);\r\nch->ch_flag &= ~CH_PRON;\r\n}\r\nif (!space) {\r\nun->un_tbusy--;\r\ngoto out;\r\n}\r\nch->ch_tbuf[ch->ch_tin] = new_char;\r\nch->ch_tin = (1 + ch->ch_tin) & TBUF_MASK;\r\nif (IS_PRINT(MINOR(tty_devnum(tty)))) {\r\nint cc = HZ + ch->ch_cpsrem;\r\nch->ch_cpstime += cc / ch->ch_digi.digi_maxcps;\r\nch->ch_cpsrem = cc % ch->ch_digi.digi_maxcps;\r\nch->ch_waketime = (ch->ch_cpstime +\r\n(ch->ch_digi.digi_maxchar * HZ /\r\nch->ch_digi.digi_maxcps));\r\n}\r\nun->un_tbusy--;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nretval = 1;\r\nout:\r\nspin_unlock_irqrestore(&dgrp_poll_data.poll_lock, lock_flags);\r\nreturn retval;\r\n}\r\nstatic void dgrp_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nch->ch_tout = ch->ch_tin;\r\nch->ch_send |= RR_TX_FLUSH;\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\nif (waitqueue_active(&tty->write_wait))\r\nwake_up_interruptible(&tty->write_wait);\r\ntty_wakeup(tty);\r\n}\r\nstatic int dgrp_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nint count;\r\nif (!tty)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn 0;\r\ncount = (ch->ch_tout - ch->ch_tin - 1) & TBUF_MASK;\r\nif (IS_PRINT(MINOR(tty_devnum(tty)))) {\r\nint un_flag = 0;\r\ncount = dgrp_calculate_txprint_bounds(ch, count, &un_flag);\r\nif (count <= 0)\r\ncount = 0;\r\nch->ch_pun.un_flag |= un_flag;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\n}\r\nreturn count;\r\n}\r\nstatic int dgrp_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nint count;\r\nint count1;\r\nif (!tty)\r\nreturn 0;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn 0;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn 0;\r\ncount1 = count = (ch->ch_tin - ch->ch_tout) & TBUF_MASK;\r\ncount += (ch->ch_s_tin - ch->ch_s_tpos) & 0xffff;\r\ncount += un->un_tbusy;\r\nreturn count;\r\n}\r\nstatic tcflag_t ch_to_tty_flags(ushort ch_flag, char flagtype)\r\n{\r\ntcflag_t retval = 0;\r\nswitch (flagtype) {\r\ncase 'i':\r\nretval = ((ch_flag & IF_IGNBRK) ? IGNBRK : 0)\r\n| ((ch_flag & IF_BRKINT) ? BRKINT : 0)\r\n| ((ch_flag & IF_IGNPAR) ? IGNPAR : 0)\r\n| ((ch_flag & IF_PARMRK) ? PARMRK : 0)\r\n| ((ch_flag & IF_INPCK) ? INPCK : 0)\r\n| ((ch_flag & IF_ISTRIP) ? ISTRIP : 0)\r\n| ((ch_flag & IF_IXON) ? IXON : 0)\r\n| ((ch_flag & IF_IXANY) ? IXANY : 0)\r\n| ((ch_flag & IF_IXOFF) ? IXOFF : 0);\r\nbreak;\r\ncase 'o':\r\nretval = ((ch_flag & OF_OLCUC) ? OLCUC : 0)\r\n| ((ch_flag & OF_ONLCR) ? ONLCR : 0)\r\n| ((ch_flag & OF_OCRNL) ? OCRNL : 0)\r\n| ((ch_flag & OF_ONOCR) ? ONOCR : 0)\r\n| ((ch_flag & OF_ONLRET) ? ONLRET : 0)\r\n| ((ch_flag & OF_TABDLY) ? TABDLY : 0);\r\nbreak;\r\ncase 'c':\r\nretval = ((ch_flag & CF_CSTOPB) ? CSTOPB : 0)\r\n| ((ch_flag & CF_CREAD) ? CREAD : 0)\r\n| ((ch_flag & CF_PARENB) ? PARENB : 0)\r\n| ((ch_flag & CF_PARODD) ? PARODD : 0)\r\n| ((ch_flag & CF_HUPCL) ? HUPCL : 0);\r\nswitch (ch_flag & CF_CSIZE) {\r\ncase CF_CS5:\r\nretval |= CS5;\r\nbreak;\r\ncase CF_CS6:\r\nretval |= CS6;\r\nbreak;\r\ncase CF_CS7:\r\nretval |= CS7;\r\nbreak;\r\ncase CF_CS8:\r\nretval |= CS8;\r\nbreak;\r\ndefault:\r\nretval |= CS8;\r\nbreak;\r\n}\r\nbreak;\r\ncase 'x':\r\nbreak;\r\ncase 'l':\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic ushort tty_to_ch_flags(struct tty_struct *tty, char flagtype)\r\n{\r\nushort retval = 0;\r\ntcflag_t tflag = 0;\r\nswitch (flagtype) {\r\ncase 'i':\r\ntflag = tty->termios.c_iflag;\r\nretval = (I_IGNBRK(tty) ? IF_IGNBRK : 0)\r\n| (I_BRKINT(tty) ? IF_BRKINT : 0)\r\n| (I_IGNPAR(tty) ? IF_IGNPAR : 0)\r\n| (I_PARMRK(tty) ? IF_PARMRK : 0)\r\n| (I_INPCK(tty) ? IF_INPCK : 0)\r\n| (I_ISTRIP(tty) ? IF_ISTRIP : 0)\r\n| (I_IXON(tty) ? IF_IXON : 0)\r\n| (I_IXANY(tty) ? IF_IXANY : 0)\r\n| (I_IXOFF(tty) ? IF_IXOFF : 0);\r\nbreak;\r\ncase 'o':\r\ntflag = tty->termios.c_oflag;\r\nif (!O_OPOST(tty))\r\nretval = 0;\r\nelse\r\nretval = (O_OLCUC(tty) ? OF_OLCUC : 0)\r\n| (O_ONLCR(tty) ? OF_ONLCR : 0)\r\n| (O_OCRNL(tty) ? OF_OCRNL : 0)\r\n| (O_ONOCR(tty) ? OF_ONOCR : 0)\r\n| (O_ONLRET(tty) ? OF_ONLRET : 0)\r\n| (O_TABDLY(tty) ? OF_TABDLY : 0);\r\nbreak;\r\ncase 'c':\r\ntflag = tty->termios.c_cflag;\r\nretval = (C_CSTOPB(tty) ? CF_CSTOPB : 0)\r\n| (C_CREAD(tty) ? CF_CREAD : 0)\r\n| (C_PARENB(tty) ? CF_PARENB : 0)\r\n| (C_PARODD(tty) ? CF_PARODD : 0)\r\n| (C_HUPCL(tty) ? CF_HUPCL : 0);\r\nswitch (C_CSIZE(tty)) {\r\ncase CS8:\r\nretval |= CF_CS8;\r\nbreak;\r\ncase CS7:\r\nretval |= CF_CS7;\r\nbreak;\r\ncase CS6:\r\nretval |= CF_CS6;\r\nbreak;\r\ncase CS5:\r\nretval |= CF_CS5;\r\nbreak;\r\ndefault:\r\nretval |= CF_CS8;\r\nbreak;\r\n}\r\nbreak;\r\ncase 'x':\r\nbreak;\r\ncase 'l':\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic int dgrp_tty_send_break(struct tty_struct *tty, int msec)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nint ret = -EIO;\r\nif (!tty)\r\nreturn ret;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn ret;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn ret;\r\ndgrp_send_break(ch, msec);\r\nreturn 0;\r\n}\r\nstatic int dgrp_send_break(struct ch_struct *ch, int msec)\r\n{\r\nulong x;\r\nwait_event_interruptible(ch->ch_flag_wait,\r\n((ch->ch_flag & CH_TX_BREAK) == 0));\r\nch->ch_break_time += max(msec, 250);\r\nch->ch_send |= RR_TX_BREAK;\r\nch->ch_flag |= CH_TX_BREAK;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nx = (msec * HZ) / 1000;\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\nreturn 0;\r\n}\r\nstatic int dgrp_tty_tiocmget(struct tty_struct *tty)\r\n{\r\nunsigned int mlast;\r\nstruct un_struct *un = tty->driver_data;\r\nstruct ch_struct *ch;\r\nif (!un)\r\nreturn -ENODEV;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -ENODEV;\r\nmlast = ((ch->ch_s_mlast & ~(DM_RTS | DM_DTR)) |\r\n(ch->ch_mout & (DM_RTS | DM_DTR)));\r\nmlast = ((mlast & DM_RTS) ? TIOCM_RTS : 0)\r\n| ((mlast & DM_DTR) ? TIOCM_DTR : 0)\r\n| ((mlast & DM_CD) ? TIOCM_CAR : 0)\r\n| ((mlast & DM_RI) ? TIOCM_RNG : 0)\r\n| ((mlast & DM_DSR) ? TIOCM_DSR : 0)\r\n| ((mlast & DM_CTS) ? TIOCM_CTS : 0);\r\nreturn mlast;\r\n}\r\nstatic int dgrp_tty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nulong lock_flags;\r\nstruct un_struct *un = tty->driver_data;\r\nstruct ch_struct *ch;\r\nif (!un)\r\nreturn -ENODEV;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -ENODEV;\r\nif (set & TIOCM_RTS)\r\nch->ch_mout |= DM_RTS;\r\nif (set & TIOCM_DTR)\r\nch->ch_mout |= DM_DTR;\r\nif (clear & TIOCM_RTS)\r\nch->ch_mout &= ~(DM_RTS);\r\nif (clear & TIOCM_DTR)\r\nch->ch_mout &= ~(DM_DTR);\r\nspin_lock_irqsave(&(ch->ch_nd)->nd_lock, lock_flags);\r\nch->ch_flag |= CH_PARAM;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\nspin_unlock_irqrestore(&(ch->ch_nd)->nd_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic int get_modem_info(struct ch_struct *ch, unsigned int *value)\r\n{\r\nunsigned int mlast;\r\nmlast = ((ch->ch_s_mlast & ~(DM_RTS | DM_DTR)) |\r\n(ch->ch_mout & (DM_RTS | DM_DTR)));\r\nmlast = ((mlast & DM_RTS) ? TIOCM_RTS : 0)\r\n| ((mlast & DM_DTR) ? TIOCM_DTR : 0)\r\n| ((mlast & DM_CD) ? TIOCM_CAR : 0)\r\n| ((mlast & DM_RI) ? TIOCM_RNG : 0)\r\n| ((mlast & DM_DSR) ? TIOCM_DSR : 0)\r\n| ((mlast & DM_CTS) ? TIOCM_CTS : 0);\r\nreturn put_user(mlast, (unsigned int __user *) value);\r\n}\r\nstatic int set_modem_info(struct ch_struct *ch, unsigned int command,\r\nunsigned int *value)\r\n{\r\nint error;\r\nunsigned int arg;\r\nint mval = 0;\r\nulong lock_flags;\r\nerror = access_ok(VERIFY_READ, (void __user *) value, sizeof(int));\r\nif (error == 0)\r\nreturn -EFAULT;\r\nif (get_user(arg, (unsigned int __user *) value))\r\nreturn -EFAULT;\r\nmval |= ((arg & TIOCM_RTS) ? DM_RTS : 0)\r\n| ((arg & TIOCM_DTR) ? DM_DTR : 0);\r\nswitch (command) {\r\ncase TIOCMBIS:\r\nch->ch_mout |= mval;\r\nbreak;\r\ncase TIOCMBIC:\r\nch->ch_mout &= ~mval;\r\nbreak;\r\ncase TIOCMSET:\r\nch->ch_mout = mval;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&(ch->ch_nd)->nd_lock, lock_flags);\r\nch->ch_flag |= CH_PARAM;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\nspin_unlock_irqrestore(&(ch->ch_nd)->nd_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic void dgrp_set_custom_speed(struct ch_struct *ch, int newrate)\r\n{\r\nint testdiv;\r\nint testrate_high;\r\nint testrate_low;\r\nint deltahigh, deltalow;\r\nif (newrate < 0)\r\nnewrate = 0;\r\nif (newrate && newrate < ((PORTSERVER_DIVIDEND / 0xFFFF) + 1))\r\nnewrate = ((PORTSERVER_DIVIDEND / 0xFFFF) + 1);\r\nif (newrate && newrate > PORTSERVER_DIVIDEND)\r\nnewrate = PORTSERVER_DIVIDEND;\r\nwhile (newrate > 0) {\r\ntestdiv = PORTSERVER_DIVIDEND / newrate;\r\ntestrate_high = PORTSERVER_DIVIDEND / testdiv;\r\ntestrate_low = PORTSERVER_DIVIDEND / (testdiv + 1);\r\nif (testrate_high == newrate)\r\nbreak;\r\ndeltahigh = testrate_high - newrate;\r\ndeltalow = newrate - testrate_low;\r\nif (deltahigh < deltalow)\r\nnewrate = testrate_high;\r\nelse\r\nnewrate = testrate_low;\r\nbreak;\r\n}\r\nch->ch_custom_speed = newrate;\r\ndrp_param(ch);\r\nreturn;\r\n}\r\nstatic int dgrp_tty_digiseta(struct tty_struct *tty,\r\nstruct digi_struct *new_info)\r\n{\r\nstruct un_struct *un = tty->driver_data;\r\nstruct ch_struct *ch;\r\nif (!un)\r\nreturn -ENODEV;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -ENODEV;\r\nif (copy_from_user(&ch->ch_digi, (void __user *) new_info,\r\nsizeof(struct digi_struct)))\r\nreturn -EFAULT;\r\nif ((ch->ch_digi.digi_flags & RTSPACE) ||\r\n(ch->ch_digi.digi_flags & CTSPACE))\r\ntty->termios.c_cflag |= CRTSCTS;\r\nelse\r\ntty->termios.c_cflag &= ~CRTSCTS;\r\nif (ch->ch_digi.digi_maxcps < 1)\r\nch->ch_digi.digi_maxcps = 1;\r\nif (ch->ch_digi.digi_maxcps > 10000)\r\nch->ch_digi.digi_maxcps = 10000;\r\nif (ch->ch_digi.digi_bufsize < 10)\r\nch->ch_digi.digi_bufsize = 10;\r\nif (ch->ch_digi.digi_maxchar < 1)\r\nch->ch_digi.digi_maxchar = 1;\r\nif (ch->ch_digi.digi_maxchar > ch->ch_digi.digi_bufsize)\r\nch->ch_digi.digi_maxchar = ch->ch_digi.digi_bufsize;\r\nif (ch->ch_digi.digi_onlen > DIGI_PLEN)\r\nch->ch_digi.digi_onlen = DIGI_PLEN;\r\nif (ch->ch_digi.digi_offlen > DIGI_PLEN)\r\nch->ch_digi.digi_offlen = DIGI_PLEN;\r\ndrp_param(ch);\r\nreturn 0;\r\n}\r\nstatic int dgrp_tty_digigetedelay(struct tty_struct *tty, int *retinfo)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nint tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn -EFAULT;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -ENODEV;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -ENODEV;\r\ntmp = ch->ch_edelay;\r\nif (copy_to_user((void __user *) retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int dgrp_tty_digisetedelay(struct tty_struct *tty, int *new_info)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nint new_digi;\r\nif (!tty || tty->magic != TTY_MAGIC)\r\nreturn -EFAULT;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -ENODEV;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -ENODEV;\r\nif (copy_from_user(&new_digi, (void __user *)new_info, sizeof(int)))\r\nreturn -EFAULT;\r\nch->ch_edelay = new_digi;\r\ndrp_param(ch);\r\nreturn 0;\r\n}\r\nstatic int dgrp_tty_ioctl(struct tty_struct *tty, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nint rc;\r\nstruct digiflow_struct dflow;\r\nif (!tty)\r\nreturn -ENODEV;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn -ENODEV;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase TCSBRK:\r\nrc = tty_check_change(tty);\r\nif (rc)\r\nreturn rc;\r\ntty_wait_until_sent(tty, 0);\r\nif (!arg)\r\nrc = dgrp_send_break(ch, 250);\r\nif (dgrp_tty_chars_in_buffer(tty) != 0)\r\nreturn -EINTR;\r\nreturn 0;\r\ncase TCSBRKP:\r\nrc = tty_check_change(tty);\r\nif (rc)\r\nreturn rc;\r\ntty_wait_until_sent(tty, 0);\r\nrc = dgrp_send_break(ch, arg ? arg*250 : 250);\r\nif (dgrp_tty_chars_in_buffer(tty) != 0)\r\nreturn -EINTR;\r\nreturn 0;\r\ncase TIOCSBRK:\r\nrc = tty_check_change(tty);\r\nif (rc)\r\nreturn rc;\r\ntty_wait_until_sent(tty, 0);\r\nrc = dgrp_send_break(ch, 250);\r\nif (dgrp_tty_chars_in_buffer(tty) != 0)\r\nreturn -EINTR;\r\nreturn 0;\r\ncase TIOCCBRK:\r\nreturn 0;\r\ncase TIOCMGET:\r\nrc = access_ok(VERIFY_WRITE, (void __user *) arg,\r\nsizeof(unsigned int));\r\nif (rc == 0)\r\nreturn -EFAULT;\r\nreturn get_modem_info(ch, (unsigned int *) arg);\r\ncase TIOCMBIS:\r\ncase TIOCMBIC:\r\ncase TIOCMSET:\r\nreturn set_modem_info(ch, cmd, (unsigned int *) arg);\r\ncase TCFLSH:\r\nrc = tty_check_change(tty);\r\nif (rc)\r\nreturn rc;\r\nswitch (arg) {\r\ncase TCIFLUSH:\r\ncase TCIOFLUSH:\r\nif (!IS_PRINT(MINOR(tty_devnum(tty)))) {\r\nch->ch_rout = ch->ch_rin;\r\nch->ch_send |= RR_RX_FLUSH;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\n}\r\nif (arg == TCIFLUSH)\r\nbreak;\r\ncase TCOFLUSH:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n#ifdef TIOCGETP\r\ncase TIOCGETP:\r\n#endif\r\ncase TCGETS:\r\ncase TCGETA:\r\nreturn -ENOIOCTLCMD;\r\ncase TCSETAW:\r\ncase TCSETAF:\r\ncase TCSETSF:\r\ncase TCSETSW:\r\nif (!IS_PRINT(MINOR(tty_devnum(tty))) ||\r\n!ch->ch_tun.un_open_count) {\r\nrc = tty_check_change(tty);\r\nif (rc)\r\nreturn rc;\r\n}\r\ntty_wait_until_sent(tty, 0);\r\nif ((cmd == TCSETSF) || (cmd == TCSETAF)) {\r\nch->ch_send |= RR_RX_FLUSH;\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\nch->ch_rout = ch->ch_rin;\r\n}\r\nreturn -ENOIOCTLCMD;\r\ncase TCXONC:\r\nrc = tty_check_change(tty);\r\nif (rc)\r\nreturn rc;\r\nswitch (arg) {\r\ncase TCOON:\r\ndgrp_tty_start(tty);\r\nreturn 0;\r\ncase TCOOFF:\r\ndgrp_tty_stop(tty);\r\nreturn 0;\r\ncase TCION:\r\ndgrp_tty_input_start(tty);\r\nreturn 0;\r\ncase TCIOFF:\r\ndgrp_tty_input_stop(tty);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase DIGI_GETA:\r\nif (copy_to_user((struct digi_struct __user *) arg,\r\n&ch->ch_digi, sizeof(struct digi_struct)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase DIGI_SETAW:\r\ncase DIGI_SETAF:\r\ntty_wait_until_sent(tty, 0);\r\nif (cmd == DIGI_SETAF) {\r\nch->ch_send |= RR_RX_FLUSH;\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\nch->ch_rout = ch->ch_rin;\r\n}\r\ncase DIGI_SETA:\r\nreturn dgrp_tty_digiseta(tty, (struct digi_struct *) arg);\r\ncase DIGI_SEDELAY:\r\nreturn dgrp_tty_digisetedelay(tty, (int *) arg);\r\ncase DIGI_GEDELAY:\r\nreturn dgrp_tty_digigetedelay(tty, (int *) arg);\r\ncase DIGI_GETFLOW:\r\ncase DIGI_GETAFLOW:\r\nif (cmd == (DIGI_GETFLOW)) {\r\ndflow.startc = tty->termios.c_cc[VSTART];\r\ndflow.stopc = tty->termios.c_cc[VSTOP];\r\n} else {\r\ndflow.startc = ch->ch_xxon;\r\ndflow.stopc = ch->ch_xxoff;\r\n}\r\nif (copy_to_user((char __user *)arg, &dflow, sizeof(dflow)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase DIGI_SETFLOW:\r\ncase DIGI_SETAFLOW:\r\nif (copy_from_user(&dflow, (char __user *)arg, sizeof(dflow)))\r\nreturn -EFAULT;\r\nif (cmd == (DIGI_SETFLOW)) {\r\ntty->termios.c_cc[VSTART] = dflow.startc;\r\ntty->termios.c_cc[VSTOP] = dflow.stopc;\r\n} else {\r\nch->ch_xxon = dflow.startc;\r\nch->ch_xxoff = dflow.stopc;\r\n}\r\nbreak;\r\ncase DIGI_GETCUSTOMBAUD:\r\nif (put_user(ch->ch_custom_speed, (unsigned int __user *) arg))\r\nreturn -EFAULT;\r\nbreak;\r\ncase DIGI_SETCUSTOMBAUD:\r\n{\r\nint new_rate;\r\nif (get_user(new_rate, (unsigned int __user *) arg))\r\nreturn -EFAULT;\r\ndgrp_set_custom_speed(ch, new_rate);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dgrp_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\nstruct ktermios *ts;\r\nstruct ch_struct *ch;\r\nstruct un_struct *un;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nts = &tty->termios;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\ndrp_param(ch);\r\nif (!(old->c_cflag & CLOCAL) && C_CLOCAL(tty))\r\nwake_up_interruptible(&un->un_open_wait);\r\n}\r\nstatic void dgrp_tty_throttle(struct tty_struct *tty)\r\n{\r\nstruct ch_struct *ch;\r\nif (!tty)\r\nreturn;\r\nch = ((struct un_struct *) tty->driver_data)->un_ch;\r\nif (!ch)\r\nreturn;\r\nch->ch_flag |= CH_RXSTOP;\r\n}\r\nstatic void dgrp_tty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct ch_struct *ch;\r\nif (!tty)\r\nreturn;\r\nch = ((struct un_struct *) tty->driver_data)->un_ch;\r\nif (!ch)\r\nreturn;\r\nch->ch_flag &= ~CH_RXSTOP;\r\n}\r\nstatic void dgrp_tty_stop(struct tty_struct *tty)\r\n{\r\nstruct ch_struct *ch;\r\nif (!tty)\r\nreturn;\r\nch = ((struct un_struct *) tty->driver_data)->un_ch;\r\nif (!ch)\r\nreturn;\r\nch->ch_send |= RR_TX_STOP;\r\nch->ch_send &= ~RR_TX_START;\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\nif (waitqueue_active(&(ch->ch_nd)->nd_tx_waitq))\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\n}\r\nstatic void dgrp_tty_start(struct tty_struct *tty)\r\n{\r\nstruct ch_struct *ch;\r\nif (!tty)\r\nreturn;\r\nch = ((struct un_struct *) tty->driver_data)->un_ch;\r\nif (!ch)\r\nreturn;\r\nch->ch_send |= RR_TX_START;\r\nch->ch_send &= ~RR_TX_STOP;\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nif (waitqueue_active(&(ch->ch_nd)->nd_tx_waitq))\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\n}\r\nstatic void dgrp_tty_input_stop(struct tty_struct *tty)\r\n{\r\nstruct ch_struct *ch;\r\nif (!tty)\r\nreturn;\r\nch = ((struct un_struct *) tty->driver_data)->un_ch;\r\nif (!ch)\r\nreturn;\r\nch->ch_send |= RR_RX_STOP;\r\nch->ch_send &= ~RR_RX_START;\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\nif (waitqueue_active(&(ch->ch_nd)->nd_tx_waitq))\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\n}\r\nstatic void dgrp_tty_send_xchar(struct tty_struct *tty, char c)\r\n{\r\nstruct un_struct *un;\r\nstruct ch_struct *ch;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nif (c == STOP_CHAR(tty))\r\nch->ch_send |= RR_RX_STOP;\r\nelse if (c == START_CHAR(tty))\r\nch->ch_send |= RR_RX_START;\r\nch->ch_nd->nd_tx_ready = 1;\r\nch->ch_nd->nd_tx_work = 1;\r\nreturn;\r\n}\r\nstatic void dgrp_tty_input_start(struct tty_struct *tty)\r\n{\r\nstruct ch_struct *ch;\r\nif (!tty)\r\nreturn;\r\nch = ((struct un_struct *) tty->driver_data)->un_ch;\r\nif (!ch)\r\nreturn;\r\nch->ch_send |= RR_RX_START;\r\nch->ch_send &= ~RR_RX_STOP;\r\n(ch->ch_nd)->nd_tx_ready = 1;\r\n(ch->ch_nd)->nd_tx_work = 1;\r\nif (waitqueue_active(&(ch->ch_nd)->nd_tx_waitq))\r\nwake_up_interruptible(&(ch->ch_nd)->nd_tx_waitq);\r\n}\r\nstatic void dgrp_tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct ch_struct *ch;\r\nstruct nd_struct *nd;\r\nstruct un_struct *un;\r\nif (!tty)\r\nreturn;\r\nun = tty->driver_data;\r\nif (!un)\r\nreturn;\r\nch = un->un_ch;\r\nif (!ch)\r\nreturn;\r\nnd = ch->ch_nd;\r\nif (C_HUPCL(tty)) {\r\nch->ch_mout &= ~DM_DTR;\r\nch->ch_nd->nd_tx_ready = 1;\r\nch->ch_nd->nd_tx_work = 1;\r\nif (waitqueue_active(&ch->ch_flag_wait))\r\nwake_up_interruptible(&ch->ch_flag_wait);\r\n}\r\n}\r\nvoid\r\ndgrp_tty_uninit(struct nd_struct *nd)\r\n{\r\nunsigned int i;\r\nchar id[3];\r\nID_TO_CHAR(nd->nd_ID, id);\r\nif (nd->nd_ttdriver_flags & SERIAL_TTDRV_REG) {\r\ntty_unregister_driver(nd->nd_serial_ttdriver);\r\nkfree(nd->nd_serial_ttdriver->ttys);\r\nnd->nd_serial_ttdriver->ttys = NULL;\r\nput_tty_driver(nd->nd_serial_ttdriver);\r\nnd->nd_ttdriver_flags &= ~SERIAL_TTDRV_REG;\r\n}\r\nif (nd->nd_ttdriver_flags & CALLOUT_TTDRV_REG) {\r\ntty_unregister_driver(nd->nd_callout_ttdriver);\r\nkfree(nd->nd_callout_ttdriver->ttys);\r\nnd->nd_callout_ttdriver->ttys = NULL;\r\nput_tty_driver(nd->nd_callout_ttdriver);\r\nnd->nd_ttdriver_flags &= ~CALLOUT_TTDRV_REG;\r\n}\r\nif (nd->nd_ttdriver_flags & XPRINT_TTDRV_REG) {\r\ntty_unregister_driver(nd->nd_xprint_ttdriver);\r\nkfree(nd->nd_xprint_ttdriver->ttys);\r\nnd->nd_xprint_ttdriver->ttys = NULL;\r\nput_tty_driver(nd->nd_xprint_ttdriver);\r\nnd->nd_ttdriver_flags &= ~XPRINT_TTDRV_REG;\r\n}\r\nfor (i = 0; i < CHAN_MAX; i++)\r\ntty_port_destroy(&nd->nd_chan[i].port);\r\n}\r\nint\r\ndgrp_tty_init(struct nd_struct *nd)\r\n{\r\nchar id[3];\r\nint rc;\r\nint i;\r\nID_TO_CHAR(nd->nd_ID, id);\r\nnd->nd_serial_ttdriver = alloc_tty_driver(CHAN_MAX);\r\nif (!nd->nd_serial_ttdriver)\r\nreturn -ENOMEM;\r\nsprintf(nd->nd_serial_name, "tty_dgrp_%s_", id);\r\nnd->nd_serial_ttdriver->owner = THIS_MODULE;\r\nnd->nd_serial_ttdriver->name = nd->nd_serial_name;\r\nnd->nd_serial_ttdriver->name_base = 0;\r\nnd->nd_serial_ttdriver->major = 0;\r\nnd->nd_serial_ttdriver->minor_start = 0;\r\nnd->nd_serial_ttdriver->type = TTY_DRIVER_TYPE_SERIAL;\r\nnd->nd_serial_ttdriver->subtype = SERIAL_TYPE_NORMAL;\r\nnd->nd_serial_ttdriver->init_termios = DefaultTermios;\r\nnd->nd_serial_ttdriver->driver_name = "dgrp";\r\nnd->nd_serial_ttdriver->flags = (TTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV |\r\nTTY_DRIVER_HARDWARE_BREAK);\r\nnd->nd_serial_ttdriver->ttys =\r\nkzalloc(CHAN_MAX * sizeof(struct tty_struct *), GFP_KERNEL);\r\nif (!nd->nd_serial_ttdriver->ttys)\r\nreturn -ENOMEM;\r\ntty_set_operations(nd->nd_serial_ttdriver, &dgrp_tty_ops);\r\nif (!(nd->nd_ttdriver_flags & SERIAL_TTDRV_REG)) {\r\nrc = tty_register_driver(nd->nd_serial_ttdriver);\r\nif (rc < 0) {\r\nif (rc == -EBUSY) {\r\nint i;\r\nint max_majors = 1U << (32 - MINORBITS);\r\nfor (i = 256; i < max_majors; i++) {\r\nnd->nd_serial_ttdriver->major = i;\r\nrc = tty_register_driver(nd->nd_serial_ttdriver);\r\nif (rc >= 0)\r\nbreak;\r\n}\r\nif (i == max_majors)\r\nreturn rc;\r\n} else {\r\nreturn rc;\r\n}\r\n}\r\nnd->nd_ttdriver_flags |= SERIAL_TTDRV_REG;\r\n}\r\nnd->nd_callout_ttdriver = alloc_tty_driver(CHAN_MAX);\r\nif (!nd->nd_callout_ttdriver)\r\nreturn -ENOMEM;\r\nsprintf(nd->nd_callout_name, "cu_dgrp_%s_", id);\r\nnd->nd_callout_ttdriver->owner = THIS_MODULE;\r\nnd->nd_callout_ttdriver->name = nd->nd_callout_name;\r\nnd->nd_callout_ttdriver->name_base = 0;\r\nnd->nd_callout_ttdriver->major = nd->nd_serial_ttdriver->major;\r\nnd->nd_callout_ttdriver->minor_start = 0x40;\r\nnd->nd_callout_ttdriver->type = TTY_DRIVER_TYPE_SERIAL;\r\nnd->nd_callout_ttdriver->subtype = SERIAL_TYPE_CALLOUT;\r\nnd->nd_callout_ttdriver->init_termios = DefaultTermios;\r\nnd->nd_callout_ttdriver->driver_name = "dgrp";\r\nnd->nd_callout_ttdriver->flags = (TTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV |\r\nTTY_DRIVER_HARDWARE_BREAK);\r\nnd->nd_callout_ttdriver->ttys =\r\nkzalloc(CHAN_MAX * sizeof(struct tty_struct *), GFP_KERNEL);\r\nif (!nd->nd_callout_ttdriver->ttys)\r\nreturn -ENOMEM;\r\ntty_set_operations(nd->nd_callout_ttdriver, &dgrp_tty_ops);\r\nif (dgrp_register_cudevices) {\r\nif (!(nd->nd_ttdriver_flags & CALLOUT_TTDRV_REG)) {\r\nrc = tty_register_driver(nd->nd_callout_ttdriver);\r\nif (rc < 0)\r\nreturn rc;\r\nnd->nd_ttdriver_flags |= CALLOUT_TTDRV_REG;\r\n}\r\n}\r\nnd->nd_xprint_ttdriver = alloc_tty_driver(CHAN_MAX);\r\nif (!nd->nd_xprint_ttdriver)\r\nreturn -ENOMEM;\r\nsprintf(nd->nd_xprint_name, "pr_dgrp_%s_", id);\r\nnd->nd_xprint_ttdriver->owner = THIS_MODULE;\r\nnd->nd_xprint_ttdriver->name = nd->nd_xprint_name;\r\nnd->nd_xprint_ttdriver->name_base = 0;\r\nnd->nd_xprint_ttdriver->major = nd->nd_serial_ttdriver->major;\r\nnd->nd_xprint_ttdriver->minor_start = 0x80;\r\nnd->nd_xprint_ttdriver->type = TTY_DRIVER_TYPE_SERIAL;\r\nnd->nd_xprint_ttdriver->subtype = SERIAL_TYPE_XPRINT;\r\nnd->nd_xprint_ttdriver->init_termios = DefaultTermios;\r\nnd->nd_xprint_ttdriver->driver_name = "dgrp";\r\nnd->nd_xprint_ttdriver->flags = (TTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV |\r\nTTY_DRIVER_HARDWARE_BREAK);\r\nnd->nd_xprint_ttdriver->ttys =\r\nkzalloc(CHAN_MAX * sizeof(struct tty_struct *), GFP_KERNEL);\r\nif (!nd->nd_xprint_ttdriver->ttys)\r\nreturn -ENOMEM;\r\ntty_set_operations(nd->nd_xprint_ttdriver, &dgrp_tty_ops);\r\nif (dgrp_register_prdevices) {\r\nif (!(nd->nd_ttdriver_flags & XPRINT_TTDRV_REG)) {\r\nrc = tty_register_driver(nd->nd_xprint_ttdriver);\r\nif (rc < 0)\r\nreturn rc;\r\nnd->nd_ttdriver_flags |= XPRINT_TTDRV_REG;\r\n}\r\n}\r\nfor (i = 0; i < CHAN_MAX; i++) {\r\nstruct ch_struct *ch = nd->nd_chan + i;\r\nch->ch_nd = nd;\r\nch->ch_digi = digi_init;\r\nch->ch_edelay = 100;\r\nch->ch_custom_speed = 0;\r\nch->ch_portnum = i;\r\nch->ch_tun.un_ch = ch;\r\nch->ch_pun.un_ch = ch;\r\nch->ch_tun.un_type = SERIAL_TYPE_NORMAL;\r\nch->ch_pun.un_type = SERIAL_TYPE_XPRINT;\r\ninit_waitqueue_head(&(ch->ch_flag_wait));\r\ninit_waitqueue_head(&(ch->ch_sleep));\r\ninit_waitqueue_head(&(ch->ch_tun.un_open_wait));\r\ninit_waitqueue_head(&(ch->ch_tun.un_close_wait));\r\ninit_waitqueue_head(&(ch->ch_pun.un_open_wait));\r\ninit_waitqueue_head(&(ch->ch_pun.un_close_wait));\r\ntty_port_init(&ch->port);\r\n}\r\nreturn 0;\r\n}
