static int whcrc_cmd(struct uwb_rc *uwb_rc,\r\nconst struct uwb_rccb *cmd, size_t cmd_size)\r\n{\r\nint result = 0;\r\nstruct whcrc *whcrc = uwb_rc->priv;\r\nstruct device *dev = &whcrc->umc_dev->dev;\r\nu32 urccmd;\r\nif (cmd_size >= 4096)\r\nreturn -EINVAL;\r\nif (le_readl(whcrc->rc_base + URCSTS) & URCSTS_HALTED) {\r\ndev_err(dev, "requesting reset of halted radio controller\n");\r\nuwb_rc_reset_all(uwb_rc);\r\nreturn -EIO;\r\n}\r\nresult = wait_event_timeout(whcrc->cmd_wq,\r\n!(le_readl(whcrc->rc_base + URCCMD) & URCCMD_ACTIVE), HZ/2);\r\nif (result == 0) {\r\ndev_err(dev, "device is not ready to execute commands\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmemmove(whcrc->cmd_buf, cmd, cmd_size);\r\nle_writeq(whcrc->cmd_dma_buf, whcrc->rc_base + URCCMDADDR);\r\nspin_lock(&whcrc->irq_lock);\r\nurccmd = le_readl(whcrc->rc_base + URCCMD);\r\nurccmd &= ~(URCCMD_EARV | URCCMD_SIZE_MASK);\r\nle_writel(urccmd | URCCMD_ACTIVE | URCCMD_IWR | cmd_size,\r\nwhcrc->rc_base + URCCMD);\r\nspin_unlock(&whcrc->irq_lock);\r\nreturn 0;\r\n}\r\nstatic int whcrc_reset(struct uwb_rc *rc)\r\n{\r\nstruct whcrc *whcrc = rc->priv;\r\nreturn umc_controller_reset(whcrc->umc_dev);\r\n}\r\nstatic\r\nvoid whcrc_enable_events(struct whcrc *whcrc)\r\n{\r\nu32 urccmd;\r\nle_writeq(whcrc->evt_dma_buf, whcrc->rc_base + URCEVTADDR);\r\nspin_lock(&whcrc->irq_lock);\r\nurccmd = le_readl(whcrc->rc_base + URCCMD) & ~URCCMD_ACTIVE;\r\nle_writel(urccmd | URCCMD_EARV, whcrc->rc_base + URCCMD);\r\nspin_unlock(&whcrc->irq_lock);\r\n}\r\nstatic void whcrc_event_work(struct work_struct *work)\r\n{\r\nstruct whcrc *whcrc = container_of(work, struct whcrc, event_work);\r\nsize_t size;\r\nu64 urcevtaddr;\r\nurcevtaddr = le_readq(whcrc->rc_base + URCEVTADDR);\r\nsize = urcevtaddr & URCEVTADDR_OFFSET_MASK;\r\nuwb_rc_neh_grok(whcrc->uwb_rc, whcrc->evt_buf, size);\r\nwhcrc_enable_events(whcrc);\r\n}\r\nstatic\r\nirqreturn_t whcrc_irq_cb(int irq, void *_whcrc)\r\n{\r\nstruct whcrc *whcrc = _whcrc;\r\nstruct device *dev = &whcrc->umc_dev->dev;\r\nu32 urcsts;\r\nurcsts = le_readl(whcrc->rc_base + URCSTS);\r\nif (!(urcsts & URCSTS_INT_MASK))\r\nreturn IRQ_NONE;\r\nle_writel(urcsts & URCSTS_INT_MASK, whcrc->rc_base + URCSTS);\r\nif (urcsts & URCSTS_HSE) {\r\ndev_err(dev, "host system error -- hardware halted\n");\r\ngoto out;\r\n}\r\nif (urcsts & URCSTS_ER)\r\nschedule_work(&whcrc->event_work);\r\nif (urcsts & URCSTS_RCI)\r\nwake_up_all(&whcrc->cmd_wq);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic\r\nint whcrc_setup_rc_umc(struct whcrc *whcrc)\r\n{\r\nint result = 0;\r\nstruct device *dev = &whcrc->umc_dev->dev;\r\nstruct umc_dev *umc_dev = whcrc->umc_dev;\r\nwhcrc->area = umc_dev->resource.start;\r\nwhcrc->rc_len = resource_size(&umc_dev->resource);\r\nresult = -EBUSY;\r\nif (request_mem_region(whcrc->area, whcrc->rc_len, KBUILD_MODNAME) == NULL) {\r\ndev_err(dev, "can't request URC region (%zu bytes @ 0x%lx): %d\n",\r\nwhcrc->rc_len, whcrc->area, result);\r\ngoto error_request_region;\r\n}\r\nwhcrc->rc_base = ioremap_nocache(whcrc->area, whcrc->rc_len);\r\nif (whcrc->rc_base == NULL) {\r\ndev_err(dev, "can't ioremap registers (%zu bytes @ 0x%lx): %d\n",\r\nwhcrc->rc_len, whcrc->area, result);\r\ngoto error_ioremap_nocache;\r\n}\r\nresult = request_irq(umc_dev->irq, whcrc_irq_cb, IRQF_SHARED,\r\nKBUILD_MODNAME, whcrc);\r\nif (result < 0) {\r\ndev_err(dev, "can't allocate IRQ %d: %d\n",\r\numc_dev->irq, result);\r\ngoto error_request_irq;\r\n}\r\nresult = -ENOMEM;\r\nwhcrc->cmd_buf = dma_alloc_coherent(&umc_dev->dev, PAGE_SIZE,\r\n&whcrc->cmd_dma_buf, GFP_KERNEL);\r\nif (whcrc->cmd_buf == NULL) {\r\ndev_err(dev, "Can't allocate cmd transfer buffer\n");\r\ngoto error_cmd_buffer;\r\n}\r\nwhcrc->evt_buf = dma_alloc_coherent(&umc_dev->dev, PAGE_SIZE,\r\n&whcrc->evt_dma_buf, GFP_KERNEL);\r\nif (whcrc->evt_buf == NULL) {\r\ndev_err(dev, "Can't allocate evt transfer buffer\n");\r\ngoto error_evt_buffer;\r\n}\r\nreturn 0;\r\nerror_evt_buffer:\r\ndma_free_coherent(&umc_dev->dev, PAGE_SIZE, whcrc->cmd_buf,\r\nwhcrc->cmd_dma_buf);\r\nerror_cmd_buffer:\r\nfree_irq(umc_dev->irq, whcrc);\r\nerror_request_irq:\r\niounmap(whcrc->rc_base);\r\nerror_ioremap_nocache:\r\nrelease_mem_region(whcrc->area, whcrc->rc_len);\r\nerror_request_region:\r\nreturn result;\r\n}\r\nstatic\r\nvoid whcrc_release_rc_umc(struct whcrc *whcrc)\r\n{\r\nstruct umc_dev *umc_dev = whcrc->umc_dev;\r\ndma_free_coherent(&umc_dev->dev, PAGE_SIZE, whcrc->evt_buf,\r\nwhcrc->evt_dma_buf);\r\ndma_free_coherent(&umc_dev->dev, PAGE_SIZE, whcrc->cmd_buf,\r\nwhcrc->cmd_dma_buf);\r\nfree_irq(umc_dev->irq, whcrc);\r\niounmap(whcrc->rc_base);\r\nrelease_mem_region(whcrc->area, whcrc->rc_len);\r\n}\r\nstatic int whcrc_start_rc(struct uwb_rc *rc)\r\n{\r\nstruct whcrc *whcrc = rc->priv;\r\nstruct device *dev = &whcrc->umc_dev->dev;\r\nle_writel(URCCMD_RESET, whcrc->rc_base + URCCMD);\r\nif (whci_wait_for(dev, whcrc->rc_base + URCCMD, URCCMD_RESET, 0,\r\n5000, "hardware reset") < 0)\r\nreturn -EBUSY;\r\nle_writel(0, whcrc->rc_base + URCINTR);\r\nle_writel(URCCMD_RS, whcrc->rc_base + URCCMD);\r\nif (whci_wait_for(dev, whcrc->rc_base + URCSTS, URCSTS_HALTED, 0,\r\n5000, "radio controller start") < 0)\r\nreturn -ETIMEDOUT;\r\nwhcrc_enable_events(whcrc);\r\nle_writel(URCINTR_EN_ALL, whcrc->rc_base + URCINTR);\r\nreturn 0;\r\n}\r\nstatic\r\nvoid whcrc_stop_rc(struct uwb_rc *rc)\r\n{\r\nstruct whcrc *whcrc = rc->priv;\r\nstruct umc_dev *umc_dev = whcrc->umc_dev;\r\nle_writel(0, whcrc->rc_base + URCINTR);\r\ncancel_work_sync(&whcrc->event_work);\r\nle_writel(0, whcrc->rc_base + URCCMD);\r\nwhci_wait_for(&umc_dev->dev, whcrc->rc_base + URCSTS,\r\nURCSTS_HALTED, URCSTS_HALTED, 100, "radio controller stop");\r\n}\r\nstatic void whcrc_init(struct whcrc *whcrc)\r\n{\r\nspin_lock_init(&whcrc->irq_lock);\r\ninit_waitqueue_head(&whcrc->cmd_wq);\r\nINIT_WORK(&whcrc->event_work, whcrc_event_work);\r\n}\r\nstatic\r\nint whcrc_probe(struct umc_dev *umc_dev)\r\n{\r\nint result;\r\nstruct uwb_rc *uwb_rc;\r\nstruct whcrc *whcrc;\r\nstruct device *dev = &umc_dev->dev;\r\nresult = -ENOMEM;\r\nuwb_rc = uwb_rc_alloc();\r\nif (uwb_rc == NULL) {\r\ndev_err(dev, "unable to allocate RC instance\n");\r\ngoto error_rc_alloc;\r\n}\r\nwhcrc = kzalloc(sizeof(*whcrc), GFP_KERNEL);\r\nif (whcrc == NULL) {\r\ndev_err(dev, "unable to allocate WHC-RC instance\n");\r\ngoto error_alloc;\r\n}\r\nwhcrc_init(whcrc);\r\nwhcrc->umc_dev = umc_dev;\r\nresult = whcrc_setup_rc_umc(whcrc);\r\nif (result < 0) {\r\ndev_err(dev, "Can't setup RC UMC interface: %d\n", result);\r\ngoto error_setup_rc_umc;\r\n}\r\nwhcrc->uwb_rc = uwb_rc;\r\nuwb_rc->owner = THIS_MODULE;\r\nuwb_rc->cmd = whcrc_cmd;\r\nuwb_rc->reset = whcrc_reset;\r\nuwb_rc->start = whcrc_start_rc;\r\nuwb_rc->stop = whcrc_stop_rc;\r\nresult = uwb_rc_add(uwb_rc, dev, whcrc);\r\nif (result < 0)\r\ngoto error_rc_add;\r\numc_set_drvdata(umc_dev, whcrc);\r\nreturn 0;\r\nerror_rc_add:\r\nwhcrc_release_rc_umc(whcrc);\r\nerror_setup_rc_umc:\r\nkfree(whcrc);\r\nerror_alloc:\r\nuwb_rc_put(uwb_rc);\r\nerror_rc_alloc:\r\nreturn result;\r\n}\r\nstatic void whcrc_remove(struct umc_dev *umc_dev)\r\n{\r\nstruct whcrc *whcrc = umc_get_drvdata(umc_dev);\r\nstruct uwb_rc *uwb_rc = whcrc->uwb_rc;\r\numc_set_drvdata(umc_dev, NULL);\r\nuwb_rc_rm(uwb_rc);\r\nwhcrc_release_rc_umc(whcrc);\r\nkfree(whcrc);\r\nuwb_rc_put(uwb_rc);\r\n}\r\nstatic int whcrc_pre_reset(struct umc_dev *umc)\r\n{\r\nstruct whcrc *whcrc = umc_get_drvdata(umc);\r\nstruct uwb_rc *uwb_rc = whcrc->uwb_rc;\r\nuwb_rc_pre_reset(uwb_rc);\r\nreturn 0;\r\n}\r\nstatic int whcrc_post_reset(struct umc_dev *umc)\r\n{\r\nstruct whcrc *whcrc = umc_get_drvdata(umc);\r\nstruct uwb_rc *uwb_rc = whcrc->uwb_rc;\r\nreturn uwb_rc_post_reset(uwb_rc);\r\n}\r\nstatic int __init whcrc_driver_init(void)\r\n{\r\nreturn umc_driver_register(&whcrc_driver);\r\n}\r\nstatic void __exit whcrc_driver_exit(void)\r\n{\r\numc_driver_unregister(&whcrc_driver);\r\n}
