static void mcp251x_clean(struct net_device *net)\r\n{\r\nstruct mcp251x_priv *priv = netdev_priv(net);\r\nif (priv->tx_skb || priv->tx_len)\r\nnet->stats.tx_errors++;\r\nif (priv->tx_skb)\r\ndev_kfree_skb(priv->tx_skb);\r\nif (priv->tx_len)\r\ncan_free_echo_skb(priv->net, 0);\r\npriv->tx_skb = NULL;\r\npriv->tx_len = 0;\r\n}\r\nstatic int mcp251x_spi_trans(struct spi_device *spi, int len)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nstruct spi_transfer t = {\r\n.tx_buf = priv->spi_tx_buf,\r\n.rx_buf = priv->spi_rx_buf,\r\n.len = len,\r\n.cs_change = 0,\r\n};\r\nstruct spi_message m;\r\nint ret;\r\nspi_message_init(&m);\r\nif (mcp251x_enable_dma) {\r\nt.tx_dma = priv->spi_tx_dma;\r\nt.rx_dma = priv->spi_rx_dma;\r\nm.is_dma_mapped = 1;\r\n}\r\nspi_message_add_tail(&t, &m);\r\nret = spi_sync(spi, &m);\r\nif (ret)\r\ndev_err(&spi->dev, "spi transfer failed: ret = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic u8 mcp251x_read_reg(struct spi_device *spi, uint8_t reg)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nu8 val = 0;\r\npriv->spi_tx_buf[0] = INSTRUCTION_READ;\r\npriv->spi_tx_buf[1] = reg;\r\nmcp251x_spi_trans(spi, 3);\r\nval = priv->spi_rx_buf[2];\r\nreturn val;\r\n}\r\nstatic void mcp251x_read_2regs(struct spi_device *spi, uint8_t reg,\r\nuint8_t *v1, uint8_t *v2)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\npriv->spi_tx_buf[0] = INSTRUCTION_READ;\r\npriv->spi_tx_buf[1] = reg;\r\nmcp251x_spi_trans(spi, 4);\r\n*v1 = priv->spi_rx_buf[2];\r\n*v2 = priv->spi_rx_buf[3];\r\n}\r\nstatic void mcp251x_write_reg(struct spi_device *spi, u8 reg, uint8_t val)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\npriv->spi_tx_buf[0] = INSTRUCTION_WRITE;\r\npriv->spi_tx_buf[1] = reg;\r\npriv->spi_tx_buf[2] = val;\r\nmcp251x_spi_trans(spi, 3);\r\n}\r\nstatic void mcp251x_write_bits(struct spi_device *spi, u8 reg,\r\nu8 mask, uint8_t val)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\npriv->spi_tx_buf[0] = INSTRUCTION_BIT_MODIFY;\r\npriv->spi_tx_buf[1] = reg;\r\npriv->spi_tx_buf[2] = mask;\r\npriv->spi_tx_buf[3] = val;\r\nmcp251x_spi_trans(spi, 4);\r\n}\r\nstatic void mcp251x_hw_tx_frame(struct spi_device *spi, u8 *buf,\r\nint len, int tx_buf_idx)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nif (mcp251x_is_2510(spi)) {\r\nint i;\r\nfor (i = 1; i < TXBDAT_OFF + len; i++)\r\nmcp251x_write_reg(spi, TXBCTRL(tx_buf_idx) + i,\r\nbuf[i]);\r\n} else {\r\nmemcpy(priv->spi_tx_buf, buf, TXBDAT_OFF + len);\r\nmcp251x_spi_trans(spi, TXBDAT_OFF + len);\r\n}\r\n}\r\nstatic void mcp251x_hw_tx(struct spi_device *spi, struct can_frame *frame,\r\nint tx_buf_idx)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nu32 sid, eid, exide, rtr;\r\nu8 buf[SPI_TRANSFER_BUF_LEN];\r\nexide = (frame->can_id & CAN_EFF_FLAG) ? 1 : 0;\r\nif (exide)\r\nsid = (frame->can_id & CAN_EFF_MASK) >> 18;\r\nelse\r\nsid = frame->can_id & CAN_SFF_MASK;\r\neid = frame->can_id & CAN_EFF_MASK;\r\nrtr = (frame->can_id & CAN_RTR_FLAG) ? 1 : 0;\r\nbuf[TXBCTRL_OFF] = INSTRUCTION_LOAD_TXB(tx_buf_idx);\r\nbuf[TXBSIDH_OFF] = sid >> SIDH_SHIFT;\r\nbuf[TXBSIDL_OFF] = ((sid & SIDL_SID_MASK) << SIDL_SID_SHIFT) |\r\n(exide << SIDL_EXIDE_SHIFT) |\r\n((eid >> SIDL_EID_SHIFT) & SIDL_EID_MASK);\r\nbuf[TXBEID8_OFF] = GET_BYTE(eid, 1);\r\nbuf[TXBEID0_OFF] = GET_BYTE(eid, 0);\r\nbuf[TXBDLC_OFF] = (rtr << DLC_RTR_SHIFT) | frame->can_dlc;\r\nmemcpy(buf + TXBDAT_OFF, frame->data, frame->can_dlc);\r\nmcp251x_hw_tx_frame(spi, buf, frame->can_dlc, tx_buf_idx);\r\npriv->spi_tx_buf[0] = INSTRUCTION_RTS(1 << tx_buf_idx);\r\nmcp251x_spi_trans(priv->spi, 1);\r\n}\r\nstatic void mcp251x_hw_rx_frame(struct spi_device *spi, u8 *buf,\r\nint buf_idx)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nif (mcp251x_is_2510(spi)) {\r\nint i, len;\r\nfor (i = 1; i < RXBDAT_OFF; i++)\r\nbuf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);\r\nlen = get_can_dlc(buf[RXBDLC_OFF] & RXBDLC_LEN_MASK);\r\nfor (; i < (RXBDAT_OFF + len); i++)\r\nbuf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);\r\n} else {\r\npriv->spi_tx_buf[RXBCTRL_OFF] = INSTRUCTION_READ_RXB(buf_idx);\r\nmcp251x_spi_trans(spi, SPI_TRANSFER_BUF_LEN);\r\nmemcpy(buf, priv->spi_rx_buf, SPI_TRANSFER_BUF_LEN);\r\n}\r\n}\r\nstatic void mcp251x_hw_rx(struct spi_device *spi, int buf_idx)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nu8 buf[SPI_TRANSFER_BUF_LEN];\r\nskb = alloc_can_skb(priv->net, &frame);\r\nif (!skb) {\r\ndev_err(&spi->dev, "cannot allocate RX skb\n");\r\npriv->net->stats.rx_dropped++;\r\nreturn;\r\n}\r\nmcp251x_hw_rx_frame(spi, buf, buf_idx);\r\nif (buf[RXBSIDL_OFF] & RXBSIDL_IDE) {\r\nframe->can_id = CAN_EFF_FLAG;\r\nframe->can_id |=\r\nSET_BYTE(buf[RXBSIDL_OFF] & RXBSIDL_EID, 2) |\r\nSET_BYTE(buf[RXBEID8_OFF], 1) |\r\nSET_BYTE(buf[RXBEID0_OFF], 0) |\r\n(((buf[RXBSIDH_OFF] << RXBSIDH_SHIFT) |\r\n(buf[RXBSIDL_OFF] >> RXBSIDL_SHIFT)) << 18);\r\nif (buf[RXBDLC_OFF] & RXBDLC_RTR)\r\nframe->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nframe->can_id =\r\n(buf[RXBSIDH_OFF] << RXBSIDH_SHIFT) |\r\n(buf[RXBSIDL_OFF] >> RXBSIDL_SHIFT);\r\nif (buf[RXBSIDL_OFF] & RXBSIDL_SRR)\r\nframe->can_id |= CAN_RTR_FLAG;\r\n}\r\nframe->can_dlc = get_can_dlc(buf[RXBDLC_OFF] & RXBDLC_LEN_MASK);\r\nmemcpy(frame->data, buf + RXBDAT_OFF, frame->can_dlc);\r\npriv->net->stats.rx_packets++;\r\npriv->net->stats.rx_bytes += frame->can_dlc;\r\ncan_led_event(priv->net, CAN_LED_EVENT_RX);\r\nnetif_rx_ni(skb);\r\n}\r\nstatic void mcp251x_hw_sleep(struct spi_device *spi)\r\n{\r\nmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_SLEEP);\r\n}\r\nstatic netdev_tx_t mcp251x_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\nstruct mcp251x_priv *priv = netdev_priv(net);\r\nstruct spi_device *spi = priv->spi;\r\nif (priv->tx_skb || priv->tx_len) {\r\ndev_warn(&spi->dev, "hard_xmit called while tx busy\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (can_dropped_invalid_skb(net, skb))\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(net);\r\npriv->tx_skb = skb;\r\nqueue_work(priv->wq, &priv->tx_work);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int mcp251x_do_set_mode(struct net_device *net, enum can_mode mode)\r\n{\r\nstruct mcp251x_priv *priv = netdev_priv(net);\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nmcp251x_clean(net);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\npriv->restart_tx = 1;\r\nif (priv->can.restart_ms == 0)\r\npriv->after_suspend = AFTER_SUSPEND_RESTART;\r\nqueue_work(priv->wq, &priv->restart_work);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcp251x_set_normal_mode(struct spi_device *spi)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nunsigned long timeout;\r\nmcp251x_write_reg(spi, CANINTE,\r\nCANINTE_ERRIE | CANINTE_TX2IE | CANINTE_TX1IE |\r\nCANINTE_TX0IE | CANINTE_RX1IE | CANINTE_RX0IE);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\r\nmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LOOPBACK);\r\n} else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {\r\nmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LISTEN_ONLY);\r\n} else {\r\nmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_NORMAL);\r\ntimeout = jiffies + HZ;\r\nwhile (mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) {\r\nschedule();\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&spi->dev, "MCP251x didn't"\r\n" enter in normal mode\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int mcp251x_do_set_bittiming(struct net_device *net)\r\n{\r\nstruct mcp251x_priv *priv = netdev_priv(net);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nstruct spi_device *spi = priv->spi;\r\nmcp251x_write_reg(spi, CNF1, ((bt->sjw - 1) << CNF1_SJW_SHIFT) |\r\n(bt->brp - 1));\r\nmcp251x_write_reg(spi, CNF2, CNF2_BTLMODE |\r\n(priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES ?\r\nCNF2_SAM : 0) |\r\n((bt->phase_seg1 - 1) << CNF2_PS1_SHIFT) |\r\n(bt->prop_seg - 1));\r\nmcp251x_write_bits(spi, CNF3, CNF3_PHSEG2_MASK,\r\n(bt->phase_seg2 - 1));\r\ndev_info(&spi->dev, "CNF: 0x%02x 0x%02x 0x%02x\n",\r\nmcp251x_read_reg(spi, CNF1),\r\nmcp251x_read_reg(spi, CNF2),\r\nmcp251x_read_reg(spi, CNF3));\r\nreturn 0;\r\n}\r\nstatic int mcp251x_setup(struct net_device *net, struct mcp251x_priv *priv,\r\nstruct spi_device *spi)\r\n{\r\nmcp251x_do_set_bittiming(net);\r\nmcp251x_write_reg(spi, RXBCTRL(0),\r\nRXBCTRL_BUKT | RXBCTRL_RXM0 | RXBCTRL_RXM1);\r\nmcp251x_write_reg(spi, RXBCTRL(1),\r\nRXBCTRL_RXM0 | RXBCTRL_RXM1);\r\nreturn 0;\r\n}\r\nstatic int mcp251x_hw_reset(struct spi_device *spi)\r\n{\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nint ret;\r\nunsigned long timeout;\r\npriv->spi_tx_buf[0] = INSTRUCTION_RESET;\r\nret = spi_write(spi, priv->spi_tx_buf, 1);\r\nif (ret) {\r\ndev_err(&spi->dev, "reset failed: ret = %d\n", ret);\r\nreturn -EIO;\r\n}\r\ntimeout = jiffies + HZ;\r\nmdelay(10);\r\nwhile ((mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK)\r\n!= CANCTRL_REQOP_CONF) {\r\nschedule();\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&spi->dev, "MCP251x didn't"\r\n" enter in conf mode after reset\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcp251x_hw_probe(struct spi_device *spi)\r\n{\r\nint st1, st2;\r\nmcp251x_hw_reset(spi);\r\nst1 = mcp251x_read_reg(spi, CANSTAT) & 0xEE;\r\nst2 = mcp251x_read_reg(spi, CANCTRL) & 0x17;\r\ndev_dbg(&spi->dev, "CANSTAT 0x%02x CANCTRL 0x%02x\n", st1, st2);\r\nreturn (st1 == 0x80 && st2 == 0x07) ? 1 : 0;\r\n}\r\nstatic void mcp251x_open_clean(struct net_device *net)\r\n{\r\nstruct mcp251x_priv *priv = netdev_priv(net);\r\nstruct spi_device *spi = priv->spi;\r\nstruct mcp251x_platform_data *pdata = spi->dev.platform_data;\r\nfree_irq(spi->irq, priv);\r\nmcp251x_hw_sleep(spi);\r\nif (pdata->transceiver_enable)\r\npdata->transceiver_enable(0);\r\nclose_candev(net);\r\n}\r\nstatic int mcp251x_stop(struct net_device *net)\r\n{\r\nstruct mcp251x_priv *priv = netdev_priv(net);\r\nstruct spi_device *spi = priv->spi;\r\nstruct mcp251x_platform_data *pdata = spi->dev.platform_data;\r\nclose_candev(net);\r\npriv->force_quit = 1;\r\nfree_irq(spi->irq, priv);\r\ndestroy_workqueue(priv->wq);\r\npriv->wq = NULL;\r\nmutex_lock(&priv->mcp_lock);\r\nmcp251x_write_reg(spi, CANINTE, 0x00);\r\nmcp251x_write_reg(spi, CANINTF, 0x00);\r\nmcp251x_write_reg(spi, TXBCTRL(0), 0);\r\nmcp251x_clean(net);\r\nmcp251x_hw_sleep(spi);\r\nif (pdata->transceiver_enable)\r\npdata->transceiver_enable(0);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nmutex_unlock(&priv->mcp_lock);\r\ncan_led_event(net, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic void mcp251x_error_skb(struct net_device *net, int can_id, int data1)\r\n{\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nskb = alloc_can_err_skb(net, &frame);\r\nif (skb) {\r\nframe->can_id |= can_id;\r\nframe->data[1] = data1;\r\nnetif_rx_ni(skb);\r\n} else {\r\nnetdev_err(net, "cannot allocate error skb\n");\r\n}\r\n}\r\nstatic void mcp251x_tx_work_handler(struct work_struct *ws)\r\n{\r\nstruct mcp251x_priv *priv = container_of(ws, struct mcp251x_priv,\r\ntx_work);\r\nstruct spi_device *spi = priv->spi;\r\nstruct net_device *net = priv->net;\r\nstruct can_frame *frame;\r\nmutex_lock(&priv->mcp_lock);\r\nif (priv->tx_skb) {\r\nif (priv->can.state == CAN_STATE_BUS_OFF) {\r\nmcp251x_clean(net);\r\n} else {\r\nframe = (struct can_frame *)priv->tx_skb->data;\r\nif (frame->can_dlc > CAN_FRAME_MAX_DATA_LEN)\r\nframe->can_dlc = CAN_FRAME_MAX_DATA_LEN;\r\nmcp251x_hw_tx(spi, frame, 0);\r\npriv->tx_len = 1 + frame->can_dlc;\r\ncan_put_echo_skb(priv->tx_skb, net, 0);\r\npriv->tx_skb = NULL;\r\n}\r\n}\r\nmutex_unlock(&priv->mcp_lock);\r\n}\r\nstatic void mcp251x_restart_work_handler(struct work_struct *ws)\r\n{\r\nstruct mcp251x_priv *priv = container_of(ws, struct mcp251x_priv,\r\nrestart_work);\r\nstruct spi_device *spi = priv->spi;\r\nstruct net_device *net = priv->net;\r\nmutex_lock(&priv->mcp_lock);\r\nif (priv->after_suspend) {\r\nmdelay(10);\r\nmcp251x_hw_reset(spi);\r\nmcp251x_setup(net, priv, spi);\r\nif (priv->after_suspend & AFTER_SUSPEND_RESTART) {\r\nmcp251x_set_normal_mode(spi);\r\n} else if (priv->after_suspend & AFTER_SUSPEND_UP) {\r\nnetif_device_attach(net);\r\nmcp251x_clean(net);\r\nmcp251x_set_normal_mode(spi);\r\nnetif_wake_queue(net);\r\n} else {\r\nmcp251x_hw_sleep(spi);\r\n}\r\npriv->after_suspend = 0;\r\npriv->force_quit = 0;\r\n}\r\nif (priv->restart_tx) {\r\npriv->restart_tx = 0;\r\nmcp251x_write_reg(spi, TXBCTRL(0), 0);\r\nmcp251x_clean(net);\r\nnetif_wake_queue(net);\r\nmcp251x_error_skb(net, CAN_ERR_RESTARTED, 0);\r\n}\r\nmutex_unlock(&priv->mcp_lock);\r\n}\r\nstatic irqreturn_t mcp251x_can_ist(int irq, void *dev_id)\r\n{\r\nstruct mcp251x_priv *priv = dev_id;\r\nstruct spi_device *spi = priv->spi;\r\nstruct net_device *net = priv->net;\r\nmutex_lock(&priv->mcp_lock);\r\nwhile (!priv->force_quit) {\r\nenum can_state new_state;\r\nu8 intf, eflag;\r\nu8 clear_intf = 0;\r\nint can_id = 0, data1 = 0;\r\nmcp251x_read_2regs(spi, CANINTF, &intf, &eflag);\r\nintf &= CANINTF_RX | CANINTF_TX | CANINTF_ERR;\r\nif (intf & CANINTF_RX0IF) {\r\nmcp251x_hw_rx(spi, 0);\r\nif (mcp251x_is_2510(spi))\r\nmcp251x_write_bits(spi, CANINTF, CANINTF_RX0IF, 0x00);\r\n}\r\nif (intf & CANINTF_RX1IF) {\r\nmcp251x_hw_rx(spi, 1);\r\nif (mcp251x_is_2510(spi))\r\nclear_intf |= CANINTF_RX1IF;\r\n}\r\nif (intf & (CANINTF_ERR | CANINTF_TX))\r\nclear_intf |= intf & (CANINTF_ERR | CANINTF_TX);\r\nif (clear_intf)\r\nmcp251x_write_bits(spi, CANINTF, clear_intf, 0x00);\r\nif (eflag)\r\nmcp251x_write_bits(spi, EFLG, eflag, 0x00);\r\nif (eflag & EFLG_TXBO) {\r\nnew_state = CAN_STATE_BUS_OFF;\r\ncan_id |= CAN_ERR_BUSOFF;\r\n} else if (eflag & EFLG_TXEP) {\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\ncan_id |= CAN_ERR_CRTL;\r\ndata1 |= CAN_ERR_CRTL_TX_PASSIVE;\r\n} else if (eflag & EFLG_RXEP) {\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\ncan_id |= CAN_ERR_CRTL;\r\ndata1 |= CAN_ERR_CRTL_RX_PASSIVE;\r\n} else if (eflag & EFLG_TXWAR) {\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\ncan_id |= CAN_ERR_CRTL;\r\ndata1 |= CAN_ERR_CRTL_TX_WARNING;\r\n} else if (eflag & EFLG_RXWAR) {\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\ncan_id |= CAN_ERR_CRTL;\r\ndata1 |= CAN_ERR_CRTL_RX_WARNING;\r\n} else {\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nswitch (priv->can.state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\nif (new_state >= CAN_STATE_ERROR_WARNING &&\r\nnew_state <= CAN_STATE_BUS_OFF)\r\npriv->can.can_stats.error_warning++;\r\ncase CAN_STATE_ERROR_WARNING:\r\nif (new_state >= CAN_STATE_ERROR_PASSIVE &&\r\nnew_state <= CAN_STATE_BUS_OFF)\r\npriv->can.can_stats.error_passive++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npriv->can.state = new_state;\r\nif (intf & CANINTF_ERRIF) {\r\nif (eflag & (EFLG_RX0OVR | EFLG_RX1OVR)) {\r\nif (eflag & EFLG_RX0OVR) {\r\nnet->stats.rx_over_errors++;\r\nnet->stats.rx_errors++;\r\n}\r\nif (eflag & EFLG_RX1OVR) {\r\nnet->stats.rx_over_errors++;\r\nnet->stats.rx_errors++;\r\n}\r\ncan_id |= CAN_ERR_CRTL;\r\ndata1 |= CAN_ERR_CRTL_RX_OVERFLOW;\r\n}\r\nmcp251x_error_skb(net, can_id, data1);\r\n}\r\nif (priv->can.state == CAN_STATE_BUS_OFF) {\r\nif (priv->can.restart_ms == 0) {\r\npriv->force_quit = 1;\r\ncan_bus_off(net);\r\nmcp251x_hw_sleep(spi);\r\nbreak;\r\n}\r\n}\r\nif (intf == 0)\r\nbreak;\r\nif (intf & CANINTF_TX) {\r\nnet->stats.tx_packets++;\r\nnet->stats.tx_bytes += priv->tx_len - 1;\r\ncan_led_event(net, CAN_LED_EVENT_TX);\r\nif (priv->tx_len) {\r\ncan_get_echo_skb(net, 0);\r\npriv->tx_len = 0;\r\n}\r\nnetif_wake_queue(net);\r\n}\r\n}\r\nmutex_unlock(&priv->mcp_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mcp251x_open(struct net_device *net)\r\n{\r\nstruct mcp251x_priv *priv = netdev_priv(net);\r\nstruct spi_device *spi = priv->spi;\r\nstruct mcp251x_platform_data *pdata = spi->dev.platform_data;\r\nunsigned long flags;\r\nint ret;\r\nret = open_candev(net);\r\nif (ret) {\r\ndev_err(&spi->dev, "unable to set initial baudrate!\n");\r\nreturn ret;\r\n}\r\nmutex_lock(&priv->mcp_lock);\r\nif (pdata->transceiver_enable)\r\npdata->transceiver_enable(1);\r\npriv->force_quit = 0;\r\npriv->tx_skb = NULL;\r\npriv->tx_len = 0;\r\nflags = IRQF_ONESHOT;\r\nif (pdata->irq_flags)\r\nflags |= pdata->irq_flags;\r\nelse\r\nflags |= IRQF_TRIGGER_FALLING;\r\nret = request_threaded_irq(spi->irq, NULL, mcp251x_can_ist,\r\nflags, DEVICE_NAME, priv);\r\nif (ret) {\r\ndev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);\r\nif (pdata->transceiver_enable)\r\npdata->transceiver_enable(0);\r\nclose_candev(net);\r\ngoto open_unlock;\r\n}\r\npriv->wq = create_freezable_workqueue("mcp251x_wq");\r\nINIT_WORK(&priv->tx_work, mcp251x_tx_work_handler);\r\nINIT_WORK(&priv->restart_work, mcp251x_restart_work_handler);\r\nret = mcp251x_hw_reset(spi);\r\nif (ret) {\r\nmcp251x_open_clean(net);\r\ngoto open_unlock;\r\n}\r\nret = mcp251x_setup(net, priv, spi);\r\nif (ret) {\r\nmcp251x_open_clean(net);\r\ngoto open_unlock;\r\n}\r\nret = mcp251x_set_normal_mode(spi);\r\nif (ret) {\r\nmcp251x_open_clean(net);\r\ngoto open_unlock;\r\n}\r\ncan_led_event(net, CAN_LED_EVENT_OPEN);\r\nnetif_wake_queue(net);\r\nopen_unlock:\r\nmutex_unlock(&priv->mcp_lock);\r\nreturn ret;\r\n}\r\nstatic int mcp251x_can_probe(struct spi_device *spi)\r\n{\r\nstruct net_device *net;\r\nstruct mcp251x_priv *priv;\r\nstruct mcp251x_platform_data *pdata = spi->dev.platform_data;\r\nint ret = -ENODEV;\r\nif (!pdata)\r\ngoto error_out;\r\nnet = alloc_candev(sizeof(struct mcp251x_priv), TX_ECHO_SKB_MAX);\r\nif (!net) {\r\nret = -ENOMEM;\r\ngoto error_alloc;\r\n}\r\nnet->netdev_ops = &mcp251x_netdev_ops;\r\nnet->flags |= IFF_ECHO;\r\npriv = netdev_priv(net);\r\npriv->can.bittiming_const = &mcp251x_bittiming_const;\r\npriv->can.do_set_mode = mcp251x_do_set_mode;\r\npriv->can.clock.freq = pdata->oscillator_frequency / 2;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |\r\nCAN_CTRLMODE_LOOPBACK | CAN_CTRLMODE_LISTENONLY;\r\npriv->model = spi_get_device_id(spi)->driver_data;\r\npriv->net = net;\r\nspi_set_drvdata(spi, priv);\r\npriv->spi = spi;\r\nmutex_init(&priv->mcp_lock);\r\nif (mcp251x_enable_dma) {\r\nspi->dev.coherent_dma_mask = ~0;\r\npriv->spi_tx_buf = dma_alloc_coherent(&spi->dev,\r\nPAGE_SIZE,\r\n&priv->spi_tx_dma,\r\nGFP_DMA);\r\nif (priv->spi_tx_buf) {\r\npriv->spi_rx_buf = (priv->spi_tx_buf + (PAGE_SIZE / 2));\r\npriv->spi_rx_dma = (dma_addr_t)(priv->spi_tx_dma +\r\n(PAGE_SIZE / 2));\r\n} else {\r\nmcp251x_enable_dma = 0;\r\n}\r\n}\r\nif (!mcp251x_enable_dma) {\r\npriv->spi_tx_buf = kmalloc(SPI_TRANSFER_BUF_LEN, GFP_KERNEL);\r\nif (!priv->spi_tx_buf) {\r\nret = -ENOMEM;\r\ngoto error_tx_buf;\r\n}\r\npriv->spi_rx_buf = kmalloc(SPI_TRANSFER_BUF_LEN, GFP_KERNEL);\r\nif (!priv->spi_rx_buf) {\r\nret = -ENOMEM;\r\ngoto error_rx_buf;\r\n}\r\n}\r\nif (pdata->power_enable)\r\npdata->power_enable(1);\r\nif (pdata->board_specific_setup)\r\npdata->board_specific_setup(spi);\r\nSET_NETDEV_DEV(net, &spi->dev);\r\nspi->mode = SPI_MODE_0;\r\nspi->bits_per_word = 8;\r\nspi_setup(spi);\r\nif (!mcp251x_hw_probe(spi)) {\r\ndev_info(&spi->dev, "Probe failed\n");\r\ngoto error_probe;\r\n}\r\nmcp251x_hw_sleep(spi);\r\nif (pdata->transceiver_enable)\r\npdata->transceiver_enable(0);\r\nret = register_candev(net);\r\nif (ret)\r\ngoto error_probe;\r\ndevm_can_led_init(net);\r\ndev_info(&spi->dev, "probed\n");\r\nreturn ret;\r\nerror_probe:\r\nif (!mcp251x_enable_dma)\r\nkfree(priv->spi_rx_buf);\r\nerror_rx_buf:\r\nif (!mcp251x_enable_dma)\r\nkfree(priv->spi_tx_buf);\r\nerror_tx_buf:\r\nfree_candev(net);\r\nif (mcp251x_enable_dma)\r\ndma_free_coherent(&spi->dev, PAGE_SIZE,\r\npriv->spi_tx_buf, priv->spi_tx_dma);\r\nerror_alloc:\r\nif (pdata->power_enable)\r\npdata->power_enable(0);\r\ndev_err(&spi->dev, "probe failed\n");\r\nerror_out:\r\nreturn ret;\r\n}\r\nstatic int mcp251x_can_remove(struct spi_device *spi)\r\n{\r\nstruct mcp251x_platform_data *pdata = spi->dev.platform_data;\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nstruct net_device *net = priv->net;\r\nunregister_candev(net);\r\nfree_candev(net);\r\nif (mcp251x_enable_dma) {\r\ndma_free_coherent(&spi->dev, PAGE_SIZE,\r\npriv->spi_tx_buf, priv->spi_tx_dma);\r\n} else {\r\nkfree(priv->spi_tx_buf);\r\nkfree(priv->spi_rx_buf);\r\n}\r\nif (pdata->power_enable)\r\npdata->power_enable(0);\r\nreturn 0;\r\n}\r\nstatic int mcp251x_can_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct mcp251x_platform_data *pdata = spi->dev.platform_data;\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nstruct net_device *net = priv->net;\r\npriv->force_quit = 1;\r\ndisable_irq(spi->irq);\r\nif (netif_running(net)) {\r\nnetif_device_detach(net);\r\nmcp251x_hw_sleep(spi);\r\nif (pdata->transceiver_enable)\r\npdata->transceiver_enable(0);\r\npriv->after_suspend = AFTER_SUSPEND_UP;\r\n} else {\r\npriv->after_suspend = AFTER_SUSPEND_DOWN;\r\n}\r\nif (pdata->power_enable) {\r\npdata->power_enable(0);\r\npriv->after_suspend |= AFTER_SUSPEND_POWER;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcp251x_can_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct mcp251x_platform_data *pdata = spi->dev.platform_data;\r\nstruct mcp251x_priv *priv = spi_get_drvdata(spi);\r\nif (priv->after_suspend & AFTER_SUSPEND_POWER) {\r\npdata->power_enable(1);\r\nqueue_work(priv->wq, &priv->restart_work);\r\n} else {\r\nif (priv->after_suspend & AFTER_SUSPEND_UP) {\r\nif (pdata->transceiver_enable)\r\npdata->transceiver_enable(1);\r\nqueue_work(priv->wq, &priv->restart_work);\r\n} else {\r\npriv->after_suspend = 0;\r\n}\r\n}\r\npriv->force_quit = 0;\r\nenable_irq(spi->irq);\r\nreturn 0;\r\n}
