static void\r\ncec_write(struct drm_encoder *encoder, uint16_t addr, uint8_t val)\r\n{\r\nstruct i2c_client *client = to_tda998x_priv(encoder)->cec;\r\nuint8_t buf[] = {addr, val};\r\nint ret;\r\nret = i2c_master_send(client, buf, ARRAY_SIZE(buf));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error %d writing to cec:0x%x\n", ret, addr);\r\n}\r\nstatic uint8_t\r\ncec_read(struct drm_encoder *encoder, uint8_t addr)\r\n{\r\nstruct i2c_client *client = to_tda998x_priv(encoder)->cec;\r\nuint8_t val;\r\nint ret;\r\nret = i2c_master_send(client, &addr, sizeof(addr));\r\nif (ret < 0)\r\ngoto fail;\r\nret = i2c_master_recv(client, &val, sizeof(val));\r\nif (ret < 0)\r\ngoto fail;\r\nreturn val;\r\nfail:\r\ndev_err(&client->dev, "Error %d reading from cec:0x%x\n", ret, addr);\r\nreturn 0;\r\n}\r\nstatic void\r\nset_page(struct drm_encoder *encoder, uint16_t reg)\r\n{\r\nstruct tda998x_priv *priv = to_tda998x_priv(encoder);\r\nif (REG2PAGE(reg) != priv->current_page) {\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nuint8_t buf[] = {\r\nREG_CURPAGE, REG2PAGE(reg)\r\n};\r\nint ret = i2c_master_send(client, buf, sizeof(buf));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error %d writing to REG_CURPAGE\n", ret);\r\npriv->current_page = REG2PAGE(reg);\r\n}\r\n}\r\nstatic int\r\nreg_read_range(struct drm_encoder *encoder, uint16_t reg, char *buf, int cnt)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nuint8_t addr = REG2ADDR(reg);\r\nint ret;\r\nset_page(encoder, reg);\r\nret = i2c_master_send(client, &addr, sizeof(addr));\r\nif (ret < 0)\r\ngoto fail;\r\nret = i2c_master_recv(client, buf, cnt);\r\nif (ret < 0)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\ndev_err(&client->dev, "Error %d reading from 0x%x\n", ret, reg);\r\nreturn ret;\r\n}\r\nstatic uint8_t\r\nreg_read(struct drm_encoder *encoder, uint16_t reg)\r\n{\r\nuint8_t val = 0;\r\nreg_read_range(encoder, reg, &val, sizeof(val));\r\nreturn val;\r\n}\r\nstatic void\r\nreg_write(struct drm_encoder *encoder, uint16_t reg, uint8_t val)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nuint8_t buf[] = {REG2ADDR(reg), val};\r\nint ret;\r\nset_page(encoder, reg);\r\nret = i2c_master_send(client, buf, ARRAY_SIZE(buf));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error %d writing to 0x%x\n", ret, reg);\r\n}\r\nstatic void\r\nreg_write16(struct drm_encoder *encoder, uint16_t reg, uint16_t val)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nuint8_t buf[] = {REG2ADDR(reg), val >> 8, val};\r\nint ret;\r\nset_page(encoder, reg);\r\nret = i2c_master_send(client, buf, ARRAY_SIZE(buf));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Error %d writing to 0x%x\n", ret, reg);\r\n}\r\nstatic void\r\nreg_set(struct drm_encoder *encoder, uint16_t reg, uint8_t val)\r\n{\r\nreg_write(encoder, reg, reg_read(encoder, reg) | val);\r\n}\r\nstatic void\r\nreg_clear(struct drm_encoder *encoder, uint16_t reg, uint8_t val)\r\n{\r\nreg_write(encoder, reg, reg_read(encoder, reg) & ~val);\r\n}\r\nstatic void\r\ntda998x_reset(struct drm_encoder *encoder)\r\n{\r\nreg_set(encoder, REG_SOFTRESET, SOFTRESET_AUDIO | SOFTRESET_I2C_MASTER);\r\nmsleep(50);\r\nreg_clear(encoder, REG_SOFTRESET, SOFTRESET_AUDIO | SOFTRESET_I2C_MASTER);\r\nmsleep(50);\r\nreg_set(encoder, REG_MAIN_CNTRL0, MAIN_CNTRL0_SR);\r\nreg_clear(encoder, REG_MAIN_CNTRL0, MAIN_CNTRL0_SR);\r\nreg_write(encoder, REG_PLL_SERIAL_1, 0x00);\r\nreg_write(encoder, REG_PLL_SERIAL_2, PLL_SERIAL_2_SRL_NOSC(1));\r\nreg_write(encoder, REG_PLL_SERIAL_3, 0x00);\r\nreg_write(encoder, REG_SERIALIZER, 0x00);\r\nreg_write(encoder, REG_BUFFER_OUT, 0x00);\r\nreg_write(encoder, REG_PLL_SCG1, 0x00);\r\nreg_write(encoder, REG_AUDIO_DIV, 0x03);\r\nreg_write(encoder, REG_SEL_CLK, SEL_CLK_SEL_CLK1 | SEL_CLK_ENA_SC_CLK);\r\nreg_write(encoder, REG_PLL_SCGN1, 0xfa);\r\nreg_write(encoder, REG_PLL_SCGN2, 0x00);\r\nreg_write(encoder, REG_PLL_SCGR1, 0x5b);\r\nreg_write(encoder, REG_PLL_SCGR2, 0x00);\r\nreg_write(encoder, REG_PLL_SCG2, 0x10);\r\n}\r\nstatic void\r\ntda998x_encoder_set_config(struct drm_encoder *encoder, void *params)\r\n{\r\n}\r\nstatic void\r\ntda998x_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct tda998x_priv *priv = to_tda998x_priv(encoder);\r\nif (mode != DRM_MODE_DPMS_ON)\r\nmode = DRM_MODE_DPMS_OFF;\r\nif (mode == priv->dpms)\r\nreturn;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nreg_write(encoder, REG_ENA_AP, 0xff);\r\nreg_write(encoder, REG_ENA_VP_0, 0xff);\r\nreg_write(encoder, REG_ENA_VP_1, 0xff);\r\nreg_write(encoder, REG_ENA_VP_2, 0xff);\r\nreg_write(encoder, REG_VIP_CNTRL_0,\r\nVIP_CNTRL_0_SWAP_A(2) | VIP_CNTRL_0_SWAP_B(3));\r\nreg_write(encoder, REG_VIP_CNTRL_1,\r\nVIP_CNTRL_1_SWAP_C(0) | VIP_CNTRL_1_SWAP_D(1));\r\nreg_write(encoder, REG_VIP_CNTRL_2,\r\nVIP_CNTRL_2_SWAP_E(4) | VIP_CNTRL_2_SWAP_F(5));\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nreg_write(encoder, REG_ENA_AP, 0x00);\r\nreg_write(encoder, REG_ENA_VP_0, 0x00);\r\nreg_write(encoder, REG_ENA_VP_1, 0x00);\r\nreg_write(encoder, REG_ENA_VP_2, 0x00);\r\nbreak;\r\n}\r\npriv->dpms = mode;\r\n}\r\nstatic void\r\ntda998x_encoder_save(struct drm_encoder *encoder)\r\n{\r\nDBG("");\r\n}\r\nstatic void\r\ntda998x_encoder_restore(struct drm_encoder *encoder)\r\n{\r\nDBG("");\r\n}\r\nstatic bool\r\ntda998x_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int\r\ntda998x_encoder_mode_valid(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic void\r\ntda998x_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct tda998x_priv *priv = to_tda998x_priv(encoder);\r\nuint16_t hs_start, hs_end, line_start, line_end;\r\nuint16_t vwin_start, vwin_end, de_start, de_end;\r\nuint16_t ref_pix, ref_line, pix_start2;\r\nuint8_t reg, div, rep;\r\nhs_start = mode->hsync_start - mode->hdisplay;\r\nhs_end = mode->hsync_end - mode->hdisplay;\r\nline_start = 1;\r\nline_end = 1 + mode->vsync_end - mode->vsync_start;\r\nvwin_start = mode->vtotal - mode->vsync_start;\r\nvwin_end = vwin_start + mode->vdisplay;\r\nde_start = mode->htotal - mode->hdisplay;\r\nde_end = mode->htotal;\r\npix_start2 = 0;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\npix_start2 = (mode->htotal / 2) + hs_start;\r\nref_line = 2;\r\nref_pix = 3 + hs_start;\r\ndiv = 148500 / mode->clock;\r\nDBG("clock=%d, div=%u", mode->clock, div);\r\nDBG("hs_start=%u, hs_end=%u, line_start=%u, line_end=%u",\r\nhs_start, hs_end, line_start, line_end);\r\nDBG("vwin_start=%u, vwin_end=%u, de_start=%u, de_end=%u",\r\nvwin_start, vwin_end, de_start, de_end);\r\nDBG("ref_line=%u, ref_pix=%u, pix_start2=%u",\r\nref_line, ref_pix, pix_start2);\r\nreg_set(encoder, REG_AIP_CNTRL_0, AIP_CNTRL_0_RST_FIFO);\r\nreg_set(encoder, REG_TBG_CNTRL_1, TBG_CNTRL_1_DWIN_DIS);\r\nreg_clear(encoder, REG_TX33, TX33_HDMI);\r\nreg_write(encoder, REG_ENC_CNTRL, ENC_CNTRL_CTL_CODE(0));\r\nreg_write(encoder, REG_HVF_CNTRL_0, HVF_CNTRL_0_PREFIL(0) |\r\nHVF_CNTRL_0_INTPOL(0));\r\nreg_write(encoder, REG_VIP_CNTRL_5, VIP_CNTRL_5_SP_CNT(0));\r\nreg_write(encoder, REG_VIP_CNTRL_4, VIP_CNTRL_4_BLANKIT(0) |\r\nVIP_CNTRL_4_BLC(0));\r\nreg_clear(encoder, REG_PLL_SERIAL_3, PLL_SERIAL_3_SRL_CCIR);\r\nreg_clear(encoder, REG_PLL_SERIAL_1, PLL_SERIAL_1_SRL_MAN_IZ);\r\nreg_clear(encoder, REG_PLL_SERIAL_3, PLL_SERIAL_3_SRL_DE);\r\nreg_write(encoder, REG_SERIALIZER, 0);\r\nreg_write(encoder, REG_HVF_CNTRL_1, HVF_CNTRL_1_VQR(0));\r\nrep = 0;\r\nreg_write(encoder, REG_RPT_CNTRL, 0);\r\nreg_write(encoder, REG_SEL_CLK, SEL_CLK_SEL_VRF_CLK(0) |\r\nSEL_CLK_SEL_CLK1 | SEL_CLK_ENA_SC_CLK);\r\nreg_write(encoder, REG_PLL_SERIAL_2, PLL_SERIAL_2_SRL_NOSC(div) |\r\nPLL_SERIAL_2_SRL_PR(rep));\r\nreg_write16(encoder, REG_VS_PIX_STRT_2_MSB, pix_start2);\r\nreg_write16(encoder, REG_VS_PIX_END_2_MSB, pix_start2);\r\nreg_set(encoder, REG_MAT_CONTRL, MAT_CONTRL_MAT_BP);\r\nreg_write(encoder, REG_ANA_GENERAL, 0x09);\r\nreg_clear(encoder, REG_TBG_CNTRL_0, TBG_CNTRL_0_SYNC_MTHD);\r\nreg_write(encoder, REG_VIP_CNTRL_3, 0);\r\nreg_set(encoder, REG_VIP_CNTRL_3, VIP_CNTRL_3_SYNC_HS);\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nreg_set(encoder, REG_VIP_CNTRL_3, VIP_CNTRL_3_V_TGL);\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nreg_set(encoder, REG_VIP_CNTRL_3, VIP_CNTRL_3_H_TGL);\r\nreg_write(encoder, REG_VIDFORMAT, 0x00);\r\nreg_write16(encoder, REG_NPIX_MSB, mode->hdisplay - 1);\r\nreg_write16(encoder, REG_NLINE_MSB, mode->vdisplay - 1);\r\nreg_write16(encoder, REG_VS_LINE_STRT_1_MSB, line_start);\r\nreg_write16(encoder, REG_VS_LINE_END_1_MSB, line_end);\r\nreg_write16(encoder, REG_VS_PIX_STRT_1_MSB, hs_start);\r\nreg_write16(encoder, REG_VS_PIX_END_1_MSB, hs_start);\r\nreg_write16(encoder, REG_HS_PIX_START_MSB, hs_start);\r\nreg_write16(encoder, REG_HS_PIX_STOP_MSB, hs_end);\r\nreg_write16(encoder, REG_VWIN_START_1_MSB, vwin_start);\r\nreg_write16(encoder, REG_VWIN_END_1_MSB, vwin_end);\r\nreg_write16(encoder, REG_DE_START_MSB, de_start);\r\nreg_write16(encoder, REG_DE_STOP_MSB, de_end);\r\nif (priv->rev == TDA19988) {\r\nreg_write(encoder, REG_ENABLE_SPACE, 0x01);\r\n}\r\nreg_write16(encoder, REG_REFPIX_MSB, ref_pix);\r\nreg_write16(encoder, REG_REFLINE_MSB, ref_line);\r\nreg = TBG_CNTRL_1_VHX_EXT_DE |\r\nTBG_CNTRL_1_VHX_EXT_HS |\r\nTBG_CNTRL_1_VHX_EXT_VS |\r\nTBG_CNTRL_1_DWIN_DIS |\r\nTBG_CNTRL_1_VH_TGL_2;\r\nif (mode->flags & (DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC))\r\nreg |= TBG_CNTRL_1_VH_TGL_0;\r\nreg_set(encoder, REG_TBG_CNTRL_1, reg);\r\nreg_clear(encoder, REG_TBG_CNTRL_0, TBG_CNTRL_0_SYNC_ONCE);\r\n}\r\nstatic enum drm_connector_status\r\ntda998x_encoder_detect(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nuint8_t val = cec_read(encoder, REG_CEC_RXSHPDLEV);\r\nreturn (val & CEC_RXSHPDLEV_HPD) ? connector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nstatic int\r\nread_edid_block(struct drm_encoder *encoder, uint8_t *buf, int blk)\r\n{\r\nuint8_t offset, segptr;\r\nint ret, i;\r\nreg_set(encoder, REG_INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);\r\noffset = (blk & 1) ? 128 : 0;\r\nsegptr = blk / 2;\r\nreg_write(encoder, REG_DDC_ADDR, 0xa0);\r\nreg_write(encoder, REG_DDC_OFFS, offset);\r\nreg_write(encoder, REG_DDC_SEGM_ADDR, 0x60);\r\nreg_write(encoder, REG_DDC_SEGM, segptr);\r\nreg_write(encoder, REG_EDID_CTRL, 0x1);\r\nreg_write(encoder, REG_EDID_CTRL, 0x0);\r\nfor (i = 100; i > 0; i--) {\r\nuint8_t val = reg_read(encoder, REG_INT_FLAGS_2);\r\nif (val & INT_FLAGS_2_EDID_BLK_RD)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (i == 0)\r\nreturn -ETIMEDOUT;\r\nret = reg_read_range(encoder, REG_EDID_DATA_0, buf, EDID_LENGTH);\r\nif (ret != EDID_LENGTH) {\r\ndev_err(encoder->dev->dev, "failed to read edid block %d: %d",\r\nblk, ret);\r\nreturn ret;\r\n}\r\nreg_clear(encoder, REG_INT_FLAGS_2, INT_FLAGS_2_EDID_BLK_RD);\r\nreturn 0;\r\n}\r\nstatic uint8_t *\r\ndo_get_edid(struct drm_encoder *encoder)\r\n{\r\nint j = 0, valid_extensions = 0;\r\nuint8_t *block, *new;\r\nbool print_bad_edid = drm_debug & DRM_UT_KMS;\r\nif ((block = kmalloc(EDID_LENGTH, GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nif (read_edid_block(encoder, block, 0))\r\ngoto fail;\r\nif (!drm_edid_block_valid(block, 0, print_bad_edid))\r\ngoto fail;\r\nif (block[0x7e] == 0)\r\nreturn block;\r\nnew = krealloc(block, (block[0x7e] + 1) * EDID_LENGTH, GFP_KERNEL);\r\nif (!new)\r\ngoto fail;\r\nblock = new;\r\nfor (j = 1; j <= block[0x7e]; j++) {\r\nuint8_t *ext_block = block + (valid_extensions + 1) * EDID_LENGTH;\r\nif (read_edid_block(encoder, ext_block, j))\r\ngoto fail;\r\nif (!drm_edid_block_valid(ext_block, j, print_bad_edid))\r\ngoto fail;\r\nvalid_extensions++;\r\n}\r\nif (valid_extensions != block[0x7e]) {\r\nblock[EDID_LENGTH-1] += block[0x7e] - valid_extensions;\r\nblock[0x7e] = valid_extensions;\r\nnew = krealloc(block, (valid_extensions + 1) * EDID_LENGTH, GFP_KERNEL);\r\nif (!new)\r\ngoto fail;\r\nblock = new;\r\n}\r\nreturn block;\r\nfail:\r\ndev_warn(encoder->dev->dev, "failed to read EDID\n");\r\nkfree(block);\r\nreturn NULL;\r\n}\r\nstatic int\r\ntda998x_encoder_get_modes(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct edid *edid = (struct edid *)do_get_edid(encoder);\r\nint n = 0;\r\nif (edid) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nn = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nreturn n;\r\n}\r\nstatic int\r\ntda998x_encoder_create_resources(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nDBG("");\r\nreturn 0;\r\n}\r\nstatic int\r\ntda998x_encoder_set_property(struct drm_encoder *encoder,\r\nstruct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nDBG("");\r\nreturn 0;\r\n}\r\nstatic void\r\ntda998x_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct tda998x_priv *priv = to_tda998x_priv(encoder);\r\ndrm_i2c_encoder_destroy(encoder);\r\nkfree(priv);\r\n}\r\nstatic int\r\ntda998x_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\ntda998x_remove(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\ntda998x_encoder_init(struct i2c_client *client,\r\nstruct drm_device *dev,\r\nstruct drm_encoder_slave *encoder_slave)\r\n{\r\nstruct drm_encoder *encoder = &encoder_slave->base;\r\nstruct tda998x_priv *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->current_page = 0;\r\npriv->cec = i2c_new_dummy(client->adapter, 0x34);\r\npriv->dpms = DRM_MODE_DPMS_OFF;\r\nencoder_slave->slave_priv = priv;\r\nencoder_slave->slave_funcs = &tda998x_encoder_funcs;\r\ncec_write(encoder, REG_CEC_ENAMODS,\r\nCEC_ENAMODS_EN_RXSENS | CEC_ENAMODS_EN_HDMI);\r\ntda998x_reset(encoder);\r\npriv->rev = reg_read(encoder, REG_VERSION_LSB) |\r\nreg_read(encoder, REG_VERSION_MSB) << 8;\r\npriv->rev &= ~0x30;\r\nswitch (priv->rev) {\r\ncase TDA9989N2: dev_info(dev->dev, "found TDA9989 n2"); break;\r\ncase TDA19989: dev_info(dev->dev, "found TDA19989"); break;\r\ncase TDA19989N2: dev_info(dev->dev, "found TDA19989 n2"); break;\r\ncase TDA19988: dev_info(dev->dev, "found TDA19988"); break;\r\ndefault:\r\nDBG("found unsupported device: %04x", priv->rev);\r\ngoto fail;\r\n}\r\nreg_write(encoder, REG_DDC_DISABLE, 0x00);\r\nreg_write(encoder, REG_TX3, 39);\r\nif (priv->rev == TDA19989)\r\nreg_set(encoder, REG_I2C_MASTER, I2C_MASTER_DIS_MM);\r\ncec_write(encoder, REG_CEC_FRO_IM_CLK_CTRL,\r\nCEC_FRO_IM_CLK_CTRL_GHOST_DIS | CEC_FRO_IM_CLK_CTRL_IMCLK_SEL);\r\nreturn 0;\r\nfail:\r\nif (priv->cec)\r\ni2c_unregister_device(priv->cec);\r\nkfree(priv);\r\nencoder_slave->slave_priv = NULL;\r\nencoder_slave->slave_funcs = NULL;\r\nreturn -ENXIO;\r\n}\r\nstatic int __init\r\ntda998x_init(void)\r\n{\r\nDBG("");\r\nreturn drm_i2c_encoder_register(THIS_MODULE, &tda998x_driver);\r\n}\r\nstatic void __exit\r\ntda998x_exit(void)\r\n{\r\nDBG("");\r\ndrm_i2c_encoder_unregister(&tda998x_driver);\r\n}
