static int show_fdinfo(struct seq_file *m, struct file *f,\r\nint (*show)(struct seq_file *m, struct fsnotify_mark *mark))\r\n{\r\nstruct fsnotify_group *group = f->private_data;\r\nstruct fsnotify_mark *mark;\r\nint ret = 0;\r\nmutex_lock(&group->mark_mutex);\r\nlist_for_each_entry(mark, &group->marks_list, g_list) {\r\nret = show(m, mark);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(&group->mark_mutex);\r\nreturn ret;\r\n}\r\nstatic int show_mark_fhandle(struct seq_file *m, struct inode *inode)\r\n{\r\nstruct {\r\nstruct file_handle handle;\r\nu8 pad[64];\r\n} f;\r\nint size, ret, i;\r\nf.handle.handle_bytes = sizeof(f.pad);\r\nsize = f.handle.handle_bytes >> 2;\r\nret = exportfs_encode_inode_fh(inode, (struct fid *)f.handle.f_handle, &size, 0);\r\nif ((ret == 255) || (ret == -ENOSPC)) {\r\nWARN_ONCE(1, "Can't encode file handler for inotify: %d\n", ret);\r\nreturn 0;\r\n}\r\nf.handle.handle_type = ret;\r\nf.handle.handle_bytes = size * sizeof(u32);\r\nret = seq_printf(m, "fhandle-bytes:%x fhandle-type:%x f_handle:",\r\nf.handle.handle_bytes, f.handle.handle_type);\r\nfor (i = 0; i < f.handle.handle_bytes; i++)\r\nret |= seq_printf(m, "%02x", (int)f.handle.f_handle[i]);\r\nreturn ret;\r\n}\r\nstatic int show_mark_fhandle(struct seq_file *m, struct inode *inode)\r\n{\r\nreturn 0;\r\n}\r\nstatic int inotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\r\n{\r\nstruct inotify_inode_mark *inode_mark;\r\nstruct inode *inode;\r\nint ret = 0;\r\nif (!(mark->flags & (FSNOTIFY_MARK_FLAG_ALIVE | FSNOTIFY_MARK_FLAG_INODE)))\r\nreturn 0;\r\ninode_mark = container_of(mark, struct inotify_inode_mark, fsn_mark);\r\ninode = igrab(mark->i.inode);\r\nif (inode) {\r\nret = seq_printf(m, "inotify wd:%x ino:%lx sdev:%x "\r\n"mask:%x ignored_mask:%x ",\r\ninode_mark->wd, inode->i_ino,\r\ninode->i_sb->s_dev,\r\nmark->mask, mark->ignored_mask);\r\nret |= show_mark_fhandle(m, inode);\r\nret |= seq_putc(m, '\n');\r\niput(inode);\r\n}\r\nreturn ret;\r\n}\r\nint inotify_show_fdinfo(struct seq_file *m, struct file *f)\r\n{\r\nreturn show_fdinfo(m, f, inotify_fdinfo);\r\n}\r\nstatic int fanotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\r\n{\r\nunsigned int mflags = 0;\r\nstruct inode *inode;\r\nint ret = 0;\r\nif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE))\r\nreturn 0;\r\nif (mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)\r\nmflags |= FAN_MARK_IGNORED_SURV_MODIFY;\r\nif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\r\ninode = igrab(mark->i.inode);\r\nif (!inode)\r\ngoto out;\r\nret = seq_printf(m, "fanotify ino:%lx sdev:%x "\r\n"mflags:%x mask:%x ignored_mask:%x ",\r\ninode->i_ino, inode->i_sb->s_dev,\r\nmflags, mark->mask, mark->ignored_mask);\r\nret |= show_mark_fhandle(m, inode);\r\nret |= seq_putc(m, '\n');\r\niput(inode);\r\n} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT) {\r\nstruct mount *mnt = real_mount(mark->m.mnt);\r\nret = seq_printf(m, "fanotify mnt_id:%x mflags:%x mask:%x "\r\n"ignored_mask:%x\n", mnt->mnt_id, mflags,\r\nmark->mask, mark->ignored_mask);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint fanotify_show_fdinfo(struct seq_file *m, struct file *f)\r\n{\r\nstruct fsnotify_group *group = f->private_data;\r\nunsigned int flags = 0;\r\nswitch (group->priority) {\r\ncase FS_PRIO_0:\r\nflags |= FAN_CLASS_NOTIF;\r\nbreak;\r\ncase FS_PRIO_1:\r\nflags |= FAN_CLASS_CONTENT;\r\nbreak;\r\ncase FS_PRIO_2:\r\nflags |= FAN_CLASS_PRE_CONTENT;\r\nbreak;\r\n}\r\nif (group->max_events == UINT_MAX)\r\nflags |= FAN_UNLIMITED_QUEUE;\r\nif (group->fanotify_data.max_marks == UINT_MAX)\r\nflags |= FAN_UNLIMITED_MARKS;\r\nseq_printf(m, "fanotify flags:%x event-flags:%x\n",\r\nflags, group->fanotify_data.f_flags);\r\nreturn show_fdinfo(m, f, fanotify_fdinfo);\r\n}
