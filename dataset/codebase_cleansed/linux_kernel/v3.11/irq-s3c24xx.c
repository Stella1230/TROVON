static void s3c_irq_mask(struct irq_data *data)\r\n{\r\nstruct s3c_irq_data *irq_data = irq_data_get_irq_chip_data(data);\r\nstruct s3c_irq_intc *intc = irq_data->intc;\r\nstruct s3c_irq_intc *parent_intc = intc->parent;\r\nstruct s3c_irq_data *parent_data;\r\nunsigned long mask;\r\nunsigned int irqno;\r\nmask = __raw_readl(intc->reg_mask);\r\nmask |= (1UL << irq_data->offset);\r\n__raw_writel(mask, intc->reg_mask);\r\nif (parent_intc) {\r\nparent_data = &parent_intc->irqs[irq_data->parent_irq];\r\nif ((mask & parent_data->sub_bits) == parent_data->sub_bits) {\r\nirqno = irq_find_mapping(parent_intc->domain,\r\nirq_data->parent_irq);\r\ns3c_irq_mask(irq_get_irq_data(irqno));\r\n}\r\n}\r\n}\r\nstatic void s3c_irq_unmask(struct irq_data *data)\r\n{\r\nstruct s3c_irq_data *irq_data = irq_data_get_irq_chip_data(data);\r\nstruct s3c_irq_intc *intc = irq_data->intc;\r\nstruct s3c_irq_intc *parent_intc = intc->parent;\r\nunsigned long mask;\r\nunsigned int irqno;\r\nmask = __raw_readl(intc->reg_mask);\r\nmask &= ~(1UL << irq_data->offset);\r\n__raw_writel(mask, intc->reg_mask);\r\nif (parent_intc) {\r\nirqno = irq_find_mapping(parent_intc->domain,\r\nirq_data->parent_irq);\r\ns3c_irq_unmask(irq_get_irq_data(irqno));\r\n}\r\n}\r\nstatic inline void s3c_irq_ack(struct irq_data *data)\r\n{\r\nstruct s3c_irq_data *irq_data = irq_data_get_irq_chip_data(data);\r\nstruct s3c_irq_intc *intc = irq_data->intc;\r\nunsigned long bitval = 1UL << irq_data->offset;\r\n__raw_writel(bitval, intc->reg_pending);\r\nif (intc->reg_intpnd)\r\n__raw_writel(bitval, intc->reg_intpnd);\r\n}\r\nstatic int s3c_irq_type(struct irq_data *data, unsigned int type)\r\n{\r\nswitch (type) {\r\ncase IRQ_TYPE_NONE:\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nirq_set_handler(data->irq, handle_edge_irq);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nirq_set_handler(data->irq, handle_level_irq);\r\nbreak;\r\ndefault:\r\npr_err("No such irq type %d", type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c_irqext_type_set(void __iomem *gpcon_reg,\r\nvoid __iomem *extint_reg,\r\nunsigned long gpcon_offset,\r\nunsigned long extint_offset,\r\nunsigned int type)\r\n{\r\nunsigned long newvalue = 0, value;\r\nvalue = __raw_readl(gpcon_reg);\r\nvalue = (value & ~(3 << gpcon_offset)) | (0x02 << gpcon_offset);\r\n__raw_writel(value, gpcon_reg);\r\nswitch (type)\r\n{\r\ncase IRQ_TYPE_NONE:\r\npr_warn("No edge setting!\n");\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nnewvalue = S3C2410_EXTINT_RISEEDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nnewvalue = S3C2410_EXTINT_FALLEDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nnewvalue = S3C2410_EXTINT_BOTHEDGE;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nnewvalue = S3C2410_EXTINT_LOWLEV;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nnewvalue = S3C2410_EXTINT_HILEV;\r\nbreak;\r\ndefault:\r\npr_err("No such irq type %d", type);\r\nreturn -EINVAL;\r\n}\r\nvalue = __raw_readl(extint_reg);\r\nvalue = (value & ~(7 << extint_offset)) | (newvalue << extint_offset);\r\n__raw_writel(value, extint_reg);\r\nreturn 0;\r\n}\r\nstatic int s3c_irqext_type(struct irq_data *data, unsigned int type)\r\n{\r\nvoid __iomem *extint_reg;\r\nvoid __iomem *gpcon_reg;\r\nunsigned long gpcon_offset, extint_offset;\r\nif ((data->hwirq >= 4) && (data->hwirq <= 7)) {\r\ngpcon_reg = S3C2410_GPFCON;\r\nextint_reg = S3C24XX_EXTINT0;\r\ngpcon_offset = (data->hwirq) * 2;\r\nextint_offset = (data->hwirq) * 4;\r\n} else if ((data->hwirq >= 8) && (data->hwirq <= 15)) {\r\ngpcon_reg = S3C2410_GPGCON;\r\nextint_reg = S3C24XX_EXTINT1;\r\ngpcon_offset = (data->hwirq - 8) * 2;\r\nextint_offset = (data->hwirq - 8) * 4;\r\n} else if ((data->hwirq >= 16) && (data->hwirq <= 23)) {\r\ngpcon_reg = S3C2410_GPGCON;\r\nextint_reg = S3C24XX_EXTINT2;\r\ngpcon_offset = (data->hwirq - 8) * 2;\r\nextint_offset = (data->hwirq - 16) * 4;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn s3c_irqext_type_set(gpcon_reg, extint_reg, gpcon_offset,\r\nextint_offset, type);\r\n}\r\nstatic int s3c_irqext0_type(struct irq_data *data, unsigned int type)\r\n{\r\nvoid __iomem *extint_reg;\r\nvoid __iomem *gpcon_reg;\r\nunsigned long gpcon_offset, extint_offset;\r\nif ((data->hwirq >= 0) && (data->hwirq <= 3)) {\r\ngpcon_reg = S3C2410_GPFCON;\r\nextint_reg = S3C24XX_EXTINT0;\r\ngpcon_offset = (data->hwirq) * 2;\r\nextint_offset = (data->hwirq) * 4;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn s3c_irqext_type_set(gpcon_reg, extint_reg, gpcon_offset,\r\nextint_offset, type);\r\n}\r\nstatic void s3c_irq_demux(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct s3c_irq_data *irq_data = irq_desc_get_chip_data(desc);\r\nstruct s3c_irq_intc *intc = irq_data->intc;\r\nstruct s3c_irq_intc *sub_intc = irq_data->sub_intc;\r\nunsigned long src;\r\nunsigned long msk;\r\nunsigned int n;\r\nunsigned int offset;\r\noffset = (intc->domain->of_node) ? 32 : 0;\r\nchained_irq_enter(chip, desc);\r\nsrc = __raw_readl(sub_intc->reg_pending);\r\nmsk = __raw_readl(sub_intc->reg_mask);\r\nsrc &= ~msk;\r\nsrc &= irq_data->sub_bits;\r\nwhile (src) {\r\nn = __ffs(src);\r\nsrc &= ~(1 << n);\r\nirq = irq_find_mapping(sub_intc->domain, offset + n);\r\ngeneric_handle_irq(irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic inline int s3c24xx_handle_intc(struct s3c_irq_intc *intc,\r\nstruct pt_regs *regs, int intc_offset)\r\n{\r\nint pnd;\r\nint offset;\r\nint irq;\r\npnd = __raw_readl(intc->reg_intpnd);\r\nif (!pnd)\r\nreturn false;\r\nif (!intc->domain->of_node)\r\nintc_offset = 0;\r\noffset = __raw_readl(intc->reg_intpnd + 4);\r\nif (!(pnd & (1 << offset)))\r\noffset = __ffs(pnd);\r\nirq = irq_find_mapping(intc->domain, intc_offset + offset);\r\nhandle_IRQ(irq, regs);\r\nreturn true;\r\n}\r\nasmlinkage void __exception_irq_entry s3c24xx_handle_irq(struct pt_regs *regs)\r\n{\r\ndo {\r\nif (likely(s3c_intc[0]))\r\nif (s3c24xx_handle_intc(s3c_intc[0], regs, 0))\r\ncontinue;\r\nif (s3c_intc[2])\r\nif (s3c24xx_handle_intc(s3c_intc[2], regs, 64))\r\ncontinue;\r\nbreak;\r\n} while (1);\r\n}\r\nint s3c24xx_set_fiq(unsigned int irq, bool on)\r\n{\r\nu32 intmod;\r\nunsigned offs;\r\nif (on) {\r\noffs = irq - FIQ_START;\r\nif (offs > 31)\r\nreturn -EINVAL;\r\nintmod = 1 << offs;\r\n} else {\r\nintmod = 0;\r\n}\r\n__raw_writel(intmod, S3C2410_INTMOD);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct s3c_irq_intc *intc = h->host_data;\r\nstruct s3c_irq_data *irq_data = &intc->irqs[hw];\r\nstruct s3c_irq_intc *parent_intc;\r\nstruct s3c_irq_data *parent_irq_data;\r\nunsigned int irqno;\r\nirq_data->intc = intc;\r\nirq_data->offset = hw;\r\nparent_intc = intc->parent;\r\nswitch (irq_data->type) {\r\ncase S3C_IRQTYPE_NONE:\r\nreturn 0;\r\ncase S3C_IRQTYPE_EINT:\r\nif (parent_intc && (!soc_is_s3c2412() || hw >= 4))\r\nirq_set_chip_and_handler(virq, &s3c_irqext_chip,\r\nhandle_edge_irq);\r\nelse\r\nirq_set_chip_and_handler(virq, &s3c_irq_eint0t4,\r\nhandle_edge_irq);\r\nbreak;\r\ncase S3C_IRQTYPE_EDGE:\r\nif (parent_intc || intc->reg_pending == S3C2416_SRCPND2)\r\nirq_set_chip_and_handler(virq, &s3c_irq_level_chip,\r\nhandle_edge_irq);\r\nelse\r\nirq_set_chip_and_handler(virq, &s3c_irq_chip,\r\nhandle_edge_irq);\r\nbreak;\r\ncase S3C_IRQTYPE_LEVEL:\r\nif (parent_intc)\r\nirq_set_chip_and_handler(virq, &s3c_irq_level_chip,\r\nhandle_level_irq);\r\nelse\r\nirq_set_chip_and_handler(virq, &s3c_irq_chip,\r\nhandle_level_irq);\r\nbreak;\r\ndefault:\r\npr_err("irq-s3c24xx: unsupported irqtype %d\n", irq_data->type);\r\nreturn -EINVAL;\r\n}\r\nirq_set_chip_data(virq, irq_data);\r\nset_irq_flags(virq, IRQF_VALID);\r\nif (parent_intc && irq_data->type != S3C_IRQTYPE_NONE) {\r\nif (irq_data->parent_irq > 31) {\r\npr_err("irq-s3c24xx: parent irq %lu is out of range\n",\r\nirq_data->parent_irq);\r\ngoto err;\r\n}\r\nparent_irq_data = &parent_intc->irqs[irq_data->parent_irq];\r\nparent_irq_data->sub_intc = intc;\r\nparent_irq_data->sub_bits |= (1UL << hw);\r\nirqno = irq_find_mapping(parent_intc->domain,\r\nirq_data->parent_irq);\r\nif (!irqno) {\r\npr_err("irq-s3c24xx: could not find mapping for parent irq %lu\n",\r\nirq_data->parent_irq);\r\ngoto err;\r\n}\r\nirq_set_chained_handler(irqno, s3c_irq_demux);\r\n}\r\nreturn 0;\r\nerr:\r\nset_irq_flags(virq, 0);\r\nreturn -EINVAL;\r\n}\r\nstatic void s3c24xx_clear_intc(struct s3c_irq_intc *intc)\r\n{\r\nvoid __iomem *reg_source;\r\nunsigned long pend;\r\nunsigned long last;\r\nint i;\r\nreg_source = intc->reg_intpnd ? intc->reg_intpnd : intc->reg_pending;\r\nlast = 0;\r\nfor (i = 0; i < 4; i++) {\r\npend = __raw_readl(reg_source);\r\nif (pend == 0 || pend == last)\r\nbreak;\r\n__raw_writel(pend, intc->reg_pending);\r\nif (intc->reg_intpnd)\r\n__raw_writel(pend, intc->reg_intpnd);\r\npr_info("irq: clearing pending status %08x\n", (int)pend);\r\nlast = pend;\r\n}\r\n}\r\nstatic struct s3c_irq_intc * __init s3c24xx_init_intc(struct device_node *np,\r\nstruct s3c_irq_data *irq_data,\r\nstruct s3c_irq_intc *parent,\r\nunsigned long address)\r\n{\r\nstruct s3c_irq_intc *intc;\r\nvoid __iomem *base = (void *)0xf6000000;\r\nint irq_num;\r\nint irq_start;\r\nint ret;\r\nintc = kzalloc(sizeof(struct s3c_irq_intc), GFP_KERNEL);\r\nif (!intc)\r\nreturn ERR_PTR(-ENOMEM);\r\nintc->irqs = irq_data;\r\nif (parent)\r\nintc->parent = parent;\r\nswitch (address) {\r\ncase 0x4a000000:\r\npr_debug("irq: found main intc\n");\r\nintc->reg_pending = base;\r\nintc->reg_mask = base + 0x08;\r\nintc->reg_intpnd = base + 0x10;\r\nirq_num = 32;\r\nirq_start = S3C2410_IRQ(0);\r\nbreak;\r\ncase 0x4a000018:\r\npr_debug("irq: found subintc\n");\r\nintc->reg_pending = base + 0x18;\r\nintc->reg_mask = base + 0x1c;\r\nirq_num = 29;\r\nirq_start = S3C2410_IRQSUB(0);\r\nbreak;\r\ncase 0x4a000040:\r\npr_debug("irq: found intc2\n");\r\nintc->reg_pending = base + 0x40;\r\nintc->reg_mask = base + 0x48;\r\nintc->reg_intpnd = base + 0x50;\r\nirq_num = 8;\r\nirq_start = S3C2416_IRQ(0);\r\nbreak;\r\ncase 0x560000a4:\r\npr_debug("irq: found eintc\n");\r\nbase = (void *)0xfd000000;\r\nintc->reg_mask = base + 0xa4;\r\nintc->reg_pending = base + 0xa8;\r\nirq_num = 24;\r\nirq_start = S3C2410_IRQ(32);\r\nbreak;\r\ndefault:\r\npr_err("irq: unsupported controller address\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ns3c24xx_clear_intc(intc);\r\nintc->domain = irq_domain_add_legacy(np, irq_num, irq_start,\r\n0, &s3c24xx_irq_ops,\r\nintc);\r\nif (!intc->domain) {\r\npr_err("irq: could not create irq-domain\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nset_handle_irq(s3c24xx_handle_irq);\r\nreturn intc;\r\nerr:\r\nkfree(intc);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid __init s3c2410_init_irq(void)\r\n{\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(FIQ_START);\r\n#endif\r\ns3c_intc[0] = s3c24xx_init_intc(NULL, &init_s3c2410base[0], NULL,\r\n0x4a000000);\r\nif (IS_ERR(s3c_intc[0])) {\r\npr_err("irq: could not create main interrupt controller\n");\r\nreturn;\r\n}\r\ns3c_intc[1] = s3c24xx_init_intc(NULL, &init_s3c2410subint[0],\r\ns3c_intc[0], 0x4a000018);\r\ns3c24xx_init_intc(NULL, &init_eint[0], s3c_intc[0], 0x560000a4);\r\n}\r\nvoid __init s3c2412_init_irq(void)\r\n{\r\npr_info("S3C2412: IRQ Support\n");\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(FIQ_START);\r\n#endif\r\ns3c_intc[0] = s3c24xx_init_intc(NULL, &init_s3c2412base[0], NULL,\r\n0x4a000000);\r\nif (IS_ERR(s3c_intc[0])) {\r\npr_err("irq: could not create main interrupt controller\n");\r\nreturn;\r\n}\r\ns3c24xx_init_intc(NULL, &init_s3c2412eint[0], s3c_intc[0], 0x560000a4);\r\ns3c_intc[1] = s3c24xx_init_intc(NULL, &init_s3c2412subint[0],\r\ns3c_intc[0], 0x4a000018);\r\n}\r\nvoid __init s3c2416_init_irq(void)\r\n{\r\npr_info("S3C2416: IRQ Support\n");\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(FIQ_START);\r\n#endif\r\ns3c_intc[0] = s3c24xx_init_intc(NULL, &init_s3c2416base[0], NULL,\r\n0x4a000000);\r\nif (IS_ERR(s3c_intc[0])) {\r\npr_err("irq: could not create main interrupt controller\n");\r\nreturn;\r\n}\r\ns3c24xx_init_intc(NULL, &init_eint[0], s3c_intc[0], 0x560000a4);\r\ns3c_intc[1] = s3c24xx_init_intc(NULL, &init_s3c2416subint[0],\r\ns3c_intc[0], 0x4a000018);\r\ns3c_intc[2] = s3c24xx_init_intc(NULL, &init_s3c2416_second[0],\r\nNULL, 0x4a000040);\r\n}\r\nvoid __init s3c2440_init_irq(void)\r\n{\r\npr_info("S3C2440: IRQ Support\n");\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(FIQ_START);\r\n#endif\r\ns3c_intc[0] = s3c24xx_init_intc(NULL, &init_s3c2440base[0], NULL,\r\n0x4a000000);\r\nif (IS_ERR(s3c_intc[0])) {\r\npr_err("irq: could not create main interrupt controller\n");\r\nreturn;\r\n}\r\ns3c24xx_init_intc(NULL, &init_eint[0], s3c_intc[0], 0x560000a4);\r\ns3c_intc[1] = s3c24xx_init_intc(NULL, &init_s3c2440subint[0],\r\ns3c_intc[0], 0x4a000018);\r\n}\r\nvoid __init s3c2442_init_irq(void)\r\n{\r\npr_info("S3C2442: IRQ Support\n");\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(FIQ_START);\r\n#endif\r\ns3c_intc[0] = s3c24xx_init_intc(NULL, &init_s3c2442base[0], NULL,\r\n0x4a000000);\r\nif (IS_ERR(s3c_intc[0])) {\r\npr_err("irq: could not create main interrupt controller\n");\r\nreturn;\r\n}\r\ns3c24xx_init_intc(NULL, &init_eint[0], s3c_intc[0], 0x560000a4);\r\ns3c_intc[1] = s3c24xx_init_intc(NULL, &init_s3c2442subint[0],\r\ns3c_intc[0], 0x4a000018);\r\n}\r\nvoid __init s3c2443_init_irq(void)\r\n{\r\npr_info("S3C2443: IRQ Support\n");\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(FIQ_START);\r\n#endif\r\ns3c_intc[0] = s3c24xx_init_intc(NULL, &init_s3c2443base[0], NULL,\r\n0x4a000000);\r\nif (IS_ERR(s3c_intc[0])) {\r\npr_err("irq: could not create main interrupt controller\n");\r\nreturn;\r\n}\r\ns3c24xx_init_intc(NULL, &init_eint[0], s3c_intc[0], 0x560000a4);\r\ns3c_intc[1] = s3c24xx_init_intc(NULL, &init_s3c2443subint[0],\r\ns3c_intc[0], 0x4a000018);\r\n}\r\nstatic int s3c24xx_irq_map_of(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nunsigned int ctrl_num = hw / 32;\r\nunsigned int intc_hw = hw % 32;\r\nstruct s3c_irq_intc *intc = s3c_intc[ctrl_num];\r\nstruct s3c_irq_intc *parent_intc = intc->parent;\r\nstruct s3c_irq_data *irq_data = &intc->irqs[intc_hw];\r\nirq_data->intc = intc;\r\nirq_data->offset = intc_hw;\r\nif (!parent_intc)\r\nirq_set_chip_and_handler(virq, &s3c_irq_chip, handle_edge_irq);\r\nelse\r\nirq_set_chip_and_handler(virq, &s3c_irq_level_chip,\r\nhandle_edge_irq);\r\nirq_set_chip_data(virq, irq_data);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_irq_xlate_of(struct irq_domain *d, struct device_node *n,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_type)\r\n{\r\nstruct s3c_irq_intc *intc;\r\nstruct s3c_irq_intc *parent_intc;\r\nstruct s3c_irq_data *irq_data;\r\nstruct s3c_irq_data *parent_irq_data;\r\nint irqno;\r\nif (WARN_ON(intsize < 4))\r\nreturn -EINVAL;\r\nif (intspec[0] > 2 || !s3c_intc[intspec[0]]) {\r\npr_err("controller number %d invalid\n", intspec[0]);\r\nreturn -EINVAL;\r\n}\r\nintc = s3c_intc[intspec[0]];\r\n*out_hwirq = intspec[0] * 32 + intspec[2];\r\n*out_type = intspec[3] & IRQ_TYPE_SENSE_MASK;\r\nparent_intc = intc->parent;\r\nif (parent_intc) {\r\nirq_data = &intc->irqs[intspec[2]];\r\nirq_data->parent_irq = intspec[1];\r\nparent_irq_data = &parent_intc->irqs[irq_data->parent_irq];\r\nparent_irq_data->sub_intc = intc;\r\nparent_irq_data->sub_bits |= (1UL << intspec[2]);\r\nirqno = irq_create_mapping(parent_intc->domain, intspec[1]);\r\nif (irqno < 0) {\r\npr_err("irq: could not map parent interrupt\n");\r\nreturn irqno;\r\n}\r\nirq_set_chained_handler(irqno, s3c_irq_demux);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init s3c_init_intc_of(struct device_node *np,\r\nstruct device_node *interrupt_parent,\r\nstruct s3c24xx_irq_of_ctrl *s3c_ctrl, int num_ctrl)\r\n{\r\nstruct s3c_irq_intc *intc;\r\nstruct s3c24xx_irq_of_ctrl *ctrl;\r\nstruct irq_domain *domain;\r\nvoid __iomem *reg_base;\r\nint i;\r\nreg_base = of_iomap(np, 0);\r\nif (!reg_base) {\r\npr_err("irq-s3c24xx: could not map irq registers\n");\r\nreturn -EINVAL;\r\n}\r\ndomain = irq_domain_add_linear(np, num_ctrl * 32,\r\n&s3c24xx_irq_ops_of, NULL);\r\nif (!domain) {\r\npr_err("irq: could not create irq-domain\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_ctrl; i++) {\r\nctrl = &s3c_ctrl[i];\r\npr_debug("irq: found controller %s\n", ctrl->name);\r\nintc = kzalloc(sizeof(struct s3c_irq_intc), GFP_KERNEL);\r\nif (!intc)\r\nreturn -ENOMEM;\r\nintc->domain = domain;\r\nintc->irqs = kzalloc(sizeof(struct s3c_irq_data) * 32,\r\nGFP_KERNEL);\r\nif (!intc->irqs) {\r\nkfree(intc);\r\nreturn -ENOMEM;\r\n}\r\nif (ctrl->parent) {\r\nintc->reg_pending = reg_base + ctrl->offset;\r\nintc->reg_mask = reg_base + ctrl->offset + 0x4;\r\nif (*(ctrl->parent)) {\r\nintc->parent = *(ctrl->parent);\r\n} else {\r\npr_warn("irq: parent of %s missing\n",\r\nctrl->name);\r\nkfree(intc->irqs);\r\nkfree(intc);\r\ncontinue;\r\n}\r\n} else {\r\nintc->reg_pending = reg_base + ctrl->offset;\r\nintc->reg_mask = reg_base + ctrl->offset + 0x08;\r\nintc->reg_intpnd = reg_base + ctrl->offset + 0x10;\r\n}\r\ns3c24xx_clear_intc(intc);\r\ns3c_intc[i] = intc;\r\n}\r\nset_handle_irq(s3c24xx_handle_irq);\r\nreturn 0;\r\n}\r\nint __init s3c2410_init_intc_of(struct device_node *np,\r\nstruct device_node *interrupt_parent,\r\nstruct s3c24xx_irq_of_ctrl *ctrl, int num_ctrl)\r\n{\r\nreturn s3c_init_intc_of(np, interrupt_parent,\r\ns3c2410_ctrl, ARRAY_SIZE(s3c2410_ctrl));\r\n}\r\nint __init s3c2416_init_intc_of(struct device_node *np,\r\nstruct device_node *interrupt_parent,\r\nstruct s3c24xx_irq_of_ctrl *ctrl, int num_ctrl)\r\n{\r\nreturn s3c_init_intc_of(np, interrupt_parent,\r\ns3c2416_ctrl, ARRAY_SIZE(s3c2416_ctrl));\r\n}
