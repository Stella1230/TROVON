static int __init default_measure_policy_setup(char *str)\r\n{\r\nima_use_tcb = 1;\r\nreturn 1;\r\n}\r\nstatic int __init default_appraise_policy_setup(char *str)\r\n{\r\nima_use_appraise_tcb = 1;\r\nreturn 1;\r\n}\r\nstatic void ima_lsm_update_rules(void)\r\n{\r\nstruct ima_rule_entry *entry, *tmp;\r\nint result;\r\nint i;\r\nmutex_lock(&ima_rules_mutex);\r\nlist_for_each_entry_safe(entry, tmp, &ima_policy_rules, list) {\r\nfor (i = 0; i < MAX_LSM_RULES; i++) {\r\nif (!entry->lsm[i].rule)\r\ncontinue;\r\nresult = security_filter_rule_init(entry->lsm[i].type,\r\nAudit_equal,\r\nentry->lsm[i].args_p,\r\n&entry->lsm[i].rule);\r\nBUG_ON(!entry->lsm[i].rule);\r\n}\r\n}\r\nmutex_unlock(&ima_rules_mutex);\r\n}\r\nstatic bool ima_match_rules(struct ima_rule_entry *rule,\r\nstruct inode *inode, enum ima_hooks func, int mask)\r\n{\r\nstruct task_struct *tsk = current;\r\nconst struct cred *cred = current_cred();\r\nint i;\r\nif ((rule->flags & IMA_FUNC) && rule->func != func)\r\nreturn false;\r\nif ((rule->flags & IMA_MASK) && rule->mask != mask)\r\nreturn false;\r\nif ((rule->flags & IMA_FSMAGIC)\r\n&& rule->fsmagic != inode->i_sb->s_magic)\r\nreturn false;\r\nif ((rule->flags & IMA_FSUUID) &&\r\nmemcmp(rule->fsuuid, inode->i_sb->s_uuid, sizeof(rule->fsuuid)))\r\nreturn false;\r\nif ((rule->flags & IMA_UID) && !uid_eq(rule->uid, cred->uid))\r\nreturn false;\r\nif ((rule->flags & IMA_FOWNER) && !uid_eq(rule->fowner, inode->i_uid))\r\nreturn false;\r\nfor (i = 0; i < MAX_LSM_RULES; i++) {\r\nint rc = 0;\r\nu32 osid, sid;\r\nint retried = 0;\r\nif (!rule->lsm[i].rule)\r\ncontinue;\r\nretry:\r\nswitch (i) {\r\ncase LSM_OBJ_USER:\r\ncase LSM_OBJ_ROLE:\r\ncase LSM_OBJ_TYPE:\r\nsecurity_inode_getsecid(inode, &osid);\r\nrc = security_filter_rule_match(osid,\r\nrule->lsm[i].type,\r\nAudit_equal,\r\nrule->lsm[i].rule,\r\nNULL);\r\nbreak;\r\ncase LSM_SUBJ_USER:\r\ncase LSM_SUBJ_ROLE:\r\ncase LSM_SUBJ_TYPE:\r\nsecurity_task_getsecid(tsk, &sid);\r\nrc = security_filter_rule_match(sid,\r\nrule->lsm[i].type,\r\nAudit_equal,\r\nrule->lsm[i].rule,\r\nNULL);\r\ndefault:\r\nbreak;\r\n}\r\nif ((rc < 0) && (!retried)) {\r\nretried = 1;\r\nima_lsm_update_rules();\r\ngoto retry;\r\n}\r\nif (!rc)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int get_subaction(struct ima_rule_entry *rule, int func)\r\n{\r\nif (!(rule->flags & IMA_FUNC))\r\nreturn IMA_FILE_APPRAISE;\r\nswitch(func) {\r\ncase MMAP_CHECK:\r\nreturn IMA_MMAP_APPRAISE;\r\ncase BPRM_CHECK:\r\nreturn IMA_BPRM_APPRAISE;\r\ncase MODULE_CHECK:\r\nreturn IMA_MODULE_APPRAISE;\r\ncase FILE_CHECK:\r\ndefault:\r\nreturn IMA_FILE_APPRAISE;\r\n}\r\n}\r\nint ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,\r\nint flags)\r\n{\r\nstruct ima_rule_entry *entry;\r\nint action = 0, actmask = flags | (flags << 1);\r\nlist_for_each_entry(entry, ima_rules, list) {\r\nif (!(entry->action & actmask))\r\ncontinue;\r\nif (!ima_match_rules(entry, inode, func, mask))\r\ncontinue;\r\naction |= entry->flags & IMA_ACTION_FLAGS;\r\naction |= entry->action & IMA_DO_MASK;\r\nif (entry->action & IMA_APPRAISE)\r\naction |= get_subaction(entry, func);\r\nif (entry->action & IMA_DO_MASK)\r\nactmask &= ~(entry->action | entry->action << 1);\r\nelse\r\nactmask &= ~(entry->action | entry->action >> 1);\r\nif (!actmask)\r\nbreak;\r\n}\r\nreturn action;\r\n}\r\nvoid __init ima_init_policy(void)\r\n{\r\nint i, measure_entries, appraise_entries;\r\nmeasure_entries = ima_use_tcb ? ARRAY_SIZE(default_rules) : 0;\r\nappraise_entries = ima_use_appraise_tcb ?\r\nARRAY_SIZE(default_appraise_rules) : 0;\r\nfor (i = 0; i < measure_entries + appraise_entries; i++) {\r\nif (i < measure_entries)\r\nlist_add_tail(&default_rules[i].list,\r\n&ima_default_rules);\r\nelse {\r\nint j = i - measure_entries;\r\nlist_add_tail(&default_appraise_rules[j].list,\r\n&ima_default_rules);\r\n}\r\n}\r\nima_rules = &ima_default_rules;\r\n}\r\nvoid ima_update_policy(void)\r\n{\r\nconst char *op = "policy_update";\r\nconst char *cause = "already exists";\r\nint result = 1;\r\nint audit_info = 0;\r\nif (ima_rules == &ima_default_rules) {\r\nima_rules = &ima_policy_rules;\r\ncause = "complete";\r\nresult = 0;\r\n}\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, cause, result, audit_info);\r\n}\r\nstatic int ima_lsm_rule_init(struct ima_rule_entry *entry,\r\nsubstring_t *args, int lsm_rule, int audit_type)\r\n{\r\nint result;\r\nif (entry->lsm[lsm_rule].rule)\r\nreturn -EINVAL;\r\nentry->lsm[lsm_rule].args_p = match_strdup(args);\r\nif (!entry->lsm[lsm_rule].args_p)\r\nreturn -ENOMEM;\r\nentry->lsm[lsm_rule].type = audit_type;\r\nresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\r\nAudit_equal,\r\nentry->lsm[lsm_rule].args_p,\r\n&entry->lsm[lsm_rule].rule);\r\nif (!entry->lsm[lsm_rule].rule) {\r\nkfree(entry->lsm[lsm_rule].args_p);\r\nreturn -EINVAL;\r\n}\r\nreturn result;\r\n}\r\nstatic void ima_log_string(struct audit_buffer *ab, char *key, char *value)\r\n{\r\naudit_log_format(ab, "%s=", key);\r\naudit_log_untrustedstring(ab, value);\r\naudit_log_format(ab, " ");\r\n}\r\nstatic int ima_parse_rule(char *rule, struct ima_rule_entry *entry)\r\n{\r\nstruct audit_buffer *ab;\r\nchar *p;\r\nint result = 0;\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\r\nentry->uid = INVALID_UID;\r\nentry->fowner = INVALID_UID;\r\nentry->action = UNKNOWN;\r\nwhile ((p = strsep(&rule, " \t")) != NULL) {\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint token;\r\nunsigned long lnum;\r\nif (result < 0)\r\nbreak;\r\nif ((*p == '\0') || (*p == ' ') || (*p == '\t'))\r\ncontinue;\r\ntoken = match_token(p, policy_tokens, args);\r\nswitch (token) {\r\ncase Opt_measure:\r\nima_log_string(ab, "action", "measure");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = MEASURE;\r\nbreak;\r\ncase Opt_dont_measure:\r\nima_log_string(ab, "action", "dont_measure");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = DONT_MEASURE;\r\nbreak;\r\ncase Opt_appraise:\r\nima_log_string(ab, "action", "appraise");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = APPRAISE;\r\nbreak;\r\ncase Opt_dont_appraise:\r\nima_log_string(ab, "action", "dont_appraise");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = DONT_APPRAISE;\r\nbreak;\r\ncase Opt_audit:\r\nima_log_string(ab, "action", "audit");\r\nif (entry->action != UNKNOWN)\r\nresult = -EINVAL;\r\nentry->action = AUDIT;\r\nbreak;\r\ncase Opt_func:\r\nima_log_string(ab, "func", args[0].from);\r\nif (entry->func)\r\nresult = -EINVAL;\r\nif (strcmp(args[0].from, "FILE_CHECK") == 0)\r\nentry->func = FILE_CHECK;\r\nelse if (strcmp(args[0].from, "PATH_CHECK") == 0)\r\nentry->func = FILE_CHECK;\r\nelse if (strcmp(args[0].from, "MODULE_CHECK") == 0)\r\nentry->func = MODULE_CHECK;\r\nelse if ((strcmp(args[0].from, "FILE_MMAP") == 0)\r\n|| (strcmp(args[0].from, "MMAP_CHECK") == 0))\r\nentry->func = MMAP_CHECK;\r\nelse if (strcmp(args[0].from, "BPRM_CHECK") == 0)\r\nentry->func = BPRM_CHECK;\r\nelse\r\nresult = -EINVAL;\r\nif (!result)\r\nentry->flags |= IMA_FUNC;\r\nbreak;\r\ncase Opt_mask:\r\nima_log_string(ab, "mask", args[0].from);\r\nif (entry->mask)\r\nresult = -EINVAL;\r\nif ((strcmp(args[0].from, "MAY_EXEC")) == 0)\r\nentry->mask = MAY_EXEC;\r\nelse if (strcmp(args[0].from, "MAY_WRITE") == 0)\r\nentry->mask = MAY_WRITE;\r\nelse if (strcmp(args[0].from, "MAY_READ") == 0)\r\nentry->mask = MAY_READ;\r\nelse if (strcmp(args[0].from, "MAY_APPEND") == 0)\r\nentry->mask = MAY_APPEND;\r\nelse\r\nresult = -EINVAL;\r\nif (!result)\r\nentry->flags |= IMA_MASK;\r\nbreak;\r\ncase Opt_fsmagic:\r\nima_log_string(ab, "fsmagic", args[0].from);\r\nif (entry->fsmagic) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = strict_strtoul(args[0].from, 16,\r\n&entry->fsmagic);\r\nif (!result)\r\nentry->flags |= IMA_FSMAGIC;\r\nbreak;\r\ncase Opt_fsuuid:\r\nima_log_string(ab, "fsuuid", args[0].from);\r\nif (memchr_inv(entry->fsuuid, 0x00,\r\nsizeof(entry->fsuuid))) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = blk_part_pack_uuid(args[0].from,\r\nentry->fsuuid);\r\nif (!result)\r\nentry->flags |= IMA_FSUUID;\r\nbreak;\r\ncase Opt_uid:\r\nima_log_string(ab, "uid", args[0].from);\r\nif (uid_valid(entry->uid)) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = strict_strtoul(args[0].from, 10, &lnum);\r\nif (!result) {\r\nentry->uid = make_kuid(current_user_ns(), (uid_t)lnum);\r\nif (!uid_valid(entry->uid) || (((uid_t)lnum) != lnum))\r\nresult = -EINVAL;\r\nelse\r\nentry->flags |= IMA_UID;\r\n}\r\nbreak;\r\ncase Opt_fowner:\r\nima_log_string(ab, "fowner", args[0].from);\r\nif (uid_valid(entry->fowner)) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nresult = strict_strtoul(args[0].from, 10, &lnum);\r\nif (!result) {\r\nentry->fowner = make_kuid(current_user_ns(), (uid_t)lnum);\r\nif (!uid_valid(entry->fowner) || (((uid_t)lnum) != lnum))\r\nresult = -EINVAL;\r\nelse\r\nentry->flags |= IMA_FOWNER;\r\n}\r\nbreak;\r\ncase Opt_obj_user:\r\nima_log_string(ab, "obj_user", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_OBJ_USER,\r\nAUDIT_OBJ_USER);\r\nbreak;\r\ncase Opt_obj_role:\r\nima_log_string(ab, "obj_role", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_OBJ_ROLE,\r\nAUDIT_OBJ_ROLE);\r\nbreak;\r\ncase Opt_obj_type:\r\nima_log_string(ab, "obj_type", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_OBJ_TYPE,\r\nAUDIT_OBJ_TYPE);\r\nbreak;\r\ncase Opt_subj_user:\r\nima_log_string(ab, "subj_user", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_SUBJ_USER,\r\nAUDIT_SUBJ_USER);\r\nbreak;\r\ncase Opt_subj_role:\r\nima_log_string(ab, "subj_role", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_SUBJ_ROLE,\r\nAUDIT_SUBJ_ROLE);\r\nbreak;\r\ncase Opt_subj_type:\r\nima_log_string(ab, "subj_type", args[0].from);\r\nresult = ima_lsm_rule_init(entry, args,\r\nLSM_SUBJ_TYPE,\r\nAUDIT_SUBJ_TYPE);\r\nbreak;\r\ncase Opt_appraise_type:\r\nif (entry->action != APPRAISE) {\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nima_log_string(ab, "appraise_type", args[0].from);\r\nif ((strcmp(args[0].from, "imasig")) == 0)\r\nentry->flags |= IMA_DIGSIG_REQUIRED;\r\nelse\r\nresult = -EINVAL;\r\nbreak;\r\ncase Opt_err:\r\nima_log_string(ab, "UNKNOWN", p);\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (!result && (entry->action == UNKNOWN))\r\nresult = -EINVAL;\r\nelse if (entry->func == MODULE_CHECK)\r\nima_appraise |= IMA_APPRAISE_MODULES;\r\naudit_log_format(ab, "res=%d", !result);\r\naudit_log_end(ab);\r\nreturn result;\r\n}\r\nssize_t ima_parse_add_rule(char *rule)\r\n{\r\nconst char *op = "update_policy";\r\nchar *p;\r\nstruct ima_rule_entry *entry;\r\nssize_t result, len;\r\nint audit_info = 0;\r\nif (ima_rules != &ima_default_rules) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, "already exists",\r\n-EACCES, audit_info);\r\nreturn -EACCES;\r\n}\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, "-ENOMEM", -ENOMEM, audit_info);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&entry->list);\r\np = strsep(&rule, "\n");\r\nlen = strlen(p) + 1;\r\nif (*p == '#') {\r\nkfree(entry);\r\nreturn len;\r\n}\r\nresult = ima_parse_rule(p, entry);\r\nif (result) {\r\nkfree(entry);\r\nintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\r\nNULL, op, "invalid policy", result,\r\naudit_info);\r\nreturn result;\r\n}\r\nmutex_lock(&ima_rules_mutex);\r\nlist_add_tail(&entry->list, &ima_policy_rules);\r\nmutex_unlock(&ima_rules_mutex);\r\nreturn len;\r\n}\r\nvoid ima_delete_rules(void)\r\n{\r\nstruct ima_rule_entry *entry, *tmp;\r\nint i;\r\nmutex_lock(&ima_rules_mutex);\r\nlist_for_each_entry_safe(entry, tmp, &ima_policy_rules, list) {\r\nfor (i = 0; i < MAX_LSM_RULES; i++)\r\nkfree(entry->lsm[i].args_p);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&ima_rules_mutex);\r\n}
