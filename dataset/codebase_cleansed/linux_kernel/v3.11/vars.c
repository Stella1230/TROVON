static bool\r\nvalidate_device_path(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nstruct efi_generic_dev_path *node;\r\nint offset = 0;\r\nnode = (struct efi_generic_dev_path *)buffer;\r\nif (len < sizeof(*node))\r\nreturn false;\r\nwhile (offset <= len - sizeof(*node) &&\r\nnode->length >= sizeof(*node) &&\r\nnode->length <= len - offset) {\r\noffset += node->length;\r\nif ((node->type == EFI_DEV_END_PATH ||\r\nnode->type == EFI_DEV_END_PATH2) &&\r\nnode->sub_type == EFI_DEV_END_ENTIRE)\r\nreturn true;\r\nnode = (struct efi_generic_dev_path *)(buffer + offset);\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nvalidate_boot_order(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nif ((len % 2) != 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nvalidate_load_option(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nu16 filepathlength;\r\nint i, desclength = 0, namelen;\r\nnamelen = ucs2_strnlen(var->VariableName, sizeof(var->VariableName));\r\nfor (i = match; i < match+4; i++) {\r\nif (var->VariableName[i] > 127 ||\r\nhex_to_bin(var->VariableName[i] & 0xff) < 0)\r\nreturn true;\r\n}\r\nif (namelen > match + 4)\r\nreturn false;\r\nif (len < 8)\r\nreturn false;\r\nfilepathlength = buffer[4] | buffer[5] << 8;\r\ndesclength = ucs2_strsize((efi_char16_t *)(buffer + 6), len - 6) + 2;\r\nif (!desclength)\r\nreturn false;\r\nif ((desclength + filepathlength + 6) > len)\r\nreturn false;\r\nreturn validate_device_path(var, match, buffer + desclength + 6,\r\nfilepathlength);\r\n}\r\nstatic bool\r\nvalidate_uint16(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nif (len != 2)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nvalidate_ascii_string(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nif (buffer[i] > 127)\r\nreturn false;\r\nif (buffer[i] == 0)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool\r\nefivar_validate(struct efi_variable *var, u8 *data, unsigned long len)\r\n{\r\nint i;\r\nu16 *unicode_name = var->VariableName;\r\nfor (i = 0; variable_validate[i].validate != NULL; i++) {\r\nconst char *name = variable_validate[i].name;\r\nint match;\r\nfor (match = 0; ; match++) {\r\nchar c = name[match];\r\nu16 u = unicode_name[match];\r\nif (u > 127)\r\nreturn true;\r\nif (c == '*')\r\nreturn variable_validate[i].validate(var,\r\nmatch, data, len);\r\nif (c != u)\r\nbreak;\r\nif (!c)\r\nreturn variable_validate[i].validate(var,\r\nmatch, data, len);\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic efi_status_t\r\ncheck_var_size(u32 attributes, unsigned long size)\r\n{\r\nconst struct efivar_operations *fops = __efivars->ops;\r\nif (!fops->query_variable_store)\r\nreturn EFI_UNSUPPORTED;\r\nreturn fops->query_variable_store(attributes, size);\r\n}\r\nstatic int efi_status_to_err(efi_status_t status)\r\n{\r\nint err;\r\nswitch (status) {\r\ncase EFI_SUCCESS:\r\nerr = 0;\r\nbreak;\r\ncase EFI_INVALID_PARAMETER:\r\nerr = -EINVAL;\r\nbreak;\r\ncase EFI_OUT_OF_RESOURCES:\r\nerr = -ENOSPC;\r\nbreak;\r\ncase EFI_DEVICE_ERROR:\r\nerr = -EIO;\r\nbreak;\r\ncase EFI_WRITE_PROTECTED:\r\nerr = -EROFS;\r\nbreak;\r\ncase EFI_SECURITY_VIOLATION:\r\nerr = -EACCES;\r\nbreak;\r\ncase EFI_NOT_FOUND:\r\nerr = -ENOENT;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic bool variable_is_present(efi_char16_t *variable_name, efi_guid_t *vendor,\r\nstruct list_head *head)\r\n{\r\nstruct efivar_entry *entry, *n;\r\nunsigned long strsize1, strsize2;\r\nbool found = false;\r\nstrsize1 = ucs2_strsize(variable_name, 1024);\r\nlist_for_each_entry_safe(entry, n, head, list) {\r\nstrsize2 = ucs2_strsize(entry->var.VariableName, 1024);\r\nif (strsize1 == strsize2 &&\r\n!memcmp(variable_name, &(entry->var.VariableName),\r\nstrsize2) &&\r\n!efi_guidcmp(entry->var.VendorGuid,\r\n*vendor)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic unsigned long var_name_strnsize(efi_char16_t *variable_name,\r\nunsigned long variable_name_size)\r\n{\r\nunsigned long len;\r\nefi_char16_t c;\r\nfor (len = 2; len <= variable_name_size; len += sizeof(c)) {\r\nc = variable_name[(len / sizeof(c)) - 1];\r\nif (!c)\r\nbreak;\r\n}\r\nreturn min(len, variable_name_size);\r\n}\r\nstatic void dup_variable_bug(efi_char16_t *s16, efi_guid_t *vendor_guid,\r\nunsigned long len16)\r\n{\r\nsize_t i, len8 = len16 / sizeof(efi_char16_t);\r\nchar *s8;\r\nefivar_wq_enabled = false;\r\ns8 = kzalloc(len8, GFP_KERNEL);\r\nif (!s8)\r\nreturn;\r\nfor (i = 0; i < len8; i++)\r\ns8[i] = s16[i];\r\nprintk(KERN_WARNING "efivars: duplicate variable: %s-%pUl\n",\r\ns8, vendor_guid);\r\nkfree(s8);\r\n}\r\nint efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),\r\nvoid *data, bool atomic, bool duplicates,\r\nstruct list_head *head)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nunsigned long variable_name_size = 1024;\r\nefi_char16_t *variable_name;\r\nefi_status_t status;\r\nefi_guid_t vendor_guid;\r\nint err = 0;\r\nvariable_name = kzalloc(variable_name_size, GFP_KERNEL);\r\nif (!variable_name) {\r\nprintk(KERN_ERR "efivars: Memory allocation failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irq(&__efivars->lock);\r\ndo {\r\nvariable_name_size = 1024;\r\nstatus = ops->get_next_variable(&variable_name_size,\r\nvariable_name,\r\n&vendor_guid);\r\nswitch (status) {\r\ncase EFI_SUCCESS:\r\nif (!atomic)\r\nspin_unlock_irq(&__efivars->lock);\r\nvariable_name_size = var_name_strnsize(variable_name,\r\nvariable_name_size);\r\nif (duplicates &&\r\nvariable_is_present(variable_name, &vendor_guid, head)) {\r\ndup_variable_bug(variable_name, &vendor_guid,\r\nvariable_name_size);\r\nif (!atomic)\r\nspin_lock_irq(&__efivars->lock);\r\nstatus = EFI_NOT_FOUND;\r\nbreak;\r\n}\r\nerr = func(variable_name, vendor_guid, variable_name_size, data);\r\nif (err)\r\nstatus = EFI_NOT_FOUND;\r\nif (!atomic)\r\nspin_lock_irq(&__efivars->lock);\r\nbreak;\r\ncase EFI_NOT_FOUND:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "efivars: get_next_variable: status=%lx\n",\r\nstatus);\r\nstatus = EFI_NOT_FOUND;\r\nbreak;\r\n}\r\n} while (status != EFI_NOT_FOUND);\r\nspin_unlock_irq(&__efivars->lock);\r\nkfree(variable_name);\r\nreturn err;\r\n}\r\nvoid efivar_entry_add(struct efivar_entry *entry, struct list_head *head)\r\n{\r\nspin_lock_irq(&__efivars->lock);\r\nlist_add(&entry->list, head);\r\nspin_unlock_irq(&__efivars->lock);\r\n}\r\nvoid efivar_entry_remove(struct efivar_entry *entry)\r\n{\r\nspin_lock_irq(&__efivars->lock);\r\nlist_del(&entry->list);\r\nspin_unlock_irq(&__efivars->lock);\r\n}\r\nstatic void efivar_entry_list_del_unlock(struct efivar_entry *entry)\r\n{\r\nWARN_ON(!spin_is_locked(&__efivars->lock));\r\nlist_del(&entry->list);\r\nspin_unlock_irq(&__efivars->lock);\r\n}\r\nint __efivar_entry_delete(struct efivar_entry *entry)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nefi_status_t status;\r\nWARN_ON(!spin_is_locked(&__efivars->lock));\r\nstatus = ops->set_variable(entry->var.VariableName,\r\n&entry->var.VendorGuid,\r\n0, 0, NULL);\r\nreturn efi_status_to_err(status);\r\n}\r\nint efivar_entry_delete(struct efivar_entry *entry)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nefi_status_t status;\r\nspin_lock_irq(&__efivars->lock);\r\nstatus = ops->set_variable(entry->var.VariableName,\r\n&entry->var.VendorGuid,\r\n0, 0, NULL);\r\nif (!(status == EFI_SUCCESS || status == EFI_NOT_FOUND)) {\r\nspin_unlock_irq(&__efivars->lock);\r\nreturn efi_status_to_err(status);\r\n}\r\nefivar_entry_list_del_unlock(entry);\r\nreturn 0;\r\n}\r\nint efivar_entry_set(struct efivar_entry *entry, u32 attributes,\r\nunsigned long size, void *data, struct list_head *head)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nefi_status_t status;\r\nefi_char16_t *name = entry->var.VariableName;\r\nefi_guid_t vendor = entry->var.VendorGuid;\r\nspin_lock_irq(&__efivars->lock);\r\nif (head && efivar_entry_find(name, vendor, head, false)) {\r\nspin_unlock_irq(&__efivars->lock);\r\nreturn -EEXIST;\r\n}\r\nstatus = check_var_size(attributes, size + ucs2_strsize(name, 1024));\r\nif (status == EFI_SUCCESS || status == EFI_UNSUPPORTED)\r\nstatus = ops->set_variable(name, &vendor,\r\nattributes, size, data);\r\nspin_unlock_irq(&__efivars->lock);\r\nreturn efi_status_to_err(status);\r\n}\r\nint efivar_entry_set_safe(efi_char16_t *name, efi_guid_t vendor, u32 attributes,\r\nbool block, unsigned long size, void *data)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nunsigned long flags;\r\nefi_status_t status;\r\nif (!ops->query_variable_store)\r\nreturn -ENOSYS;\r\nif (!block) {\r\nif (!spin_trylock_irqsave(&__efivars->lock, flags))\r\nreturn -EBUSY;\r\n} else {\r\nspin_lock_irqsave(&__efivars->lock, flags);\r\n}\r\nstatus = check_var_size(attributes, size + ucs2_strsize(name, 1024));\r\nif (status != EFI_SUCCESS) {\r\nspin_unlock_irqrestore(&__efivars->lock, flags);\r\nreturn -ENOSPC;\r\n}\r\nstatus = ops->set_variable(name, &vendor, attributes, size, data);\r\nspin_unlock_irqrestore(&__efivars->lock, flags);\r\nreturn efi_status_to_err(status);\r\n}\r\nstruct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,\r\nstruct list_head *head, bool remove)\r\n{\r\nstruct efivar_entry *entry, *n;\r\nint strsize1, strsize2;\r\nbool found = false;\r\nWARN_ON(!spin_is_locked(&__efivars->lock));\r\nlist_for_each_entry_safe(entry, n, head, list) {\r\nstrsize1 = ucs2_strsize(name, 1024);\r\nstrsize2 = ucs2_strsize(entry->var.VariableName, 1024);\r\nif (strsize1 == strsize2 &&\r\n!memcmp(name, &(entry->var.VariableName), strsize1) &&\r\n!efi_guidcmp(guid, entry->var.VendorGuid)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn NULL;\r\nif (remove)\r\nlist_del(&entry->list);\r\nreturn entry;\r\n}\r\nint efivar_entry_size(struct efivar_entry *entry, unsigned long *size)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nefi_status_t status;\r\n*size = 0;\r\nspin_lock_irq(&__efivars->lock);\r\nstatus = ops->get_variable(entry->var.VariableName,\r\n&entry->var.VendorGuid, NULL, size, NULL);\r\nspin_unlock_irq(&__efivars->lock);\r\nif (status != EFI_BUFFER_TOO_SMALL)\r\nreturn efi_status_to_err(status);\r\nreturn 0;\r\n}\r\nint __efivar_entry_get(struct efivar_entry *entry, u32 *attributes,\r\nunsigned long *size, void *data)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nefi_status_t status;\r\nWARN_ON(!spin_is_locked(&__efivars->lock));\r\nstatus = ops->get_variable(entry->var.VariableName,\r\n&entry->var.VendorGuid,\r\nattributes, size, data);\r\nreturn efi_status_to_err(status);\r\n}\r\nint efivar_entry_get(struct efivar_entry *entry, u32 *attributes,\r\nunsigned long *size, void *data)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nefi_status_t status;\r\nspin_lock_irq(&__efivars->lock);\r\nstatus = ops->get_variable(entry->var.VariableName,\r\n&entry->var.VendorGuid,\r\nattributes, size, data);\r\nspin_unlock_irq(&__efivars->lock);\r\nreturn efi_status_to_err(status);\r\n}\r\nint efivar_entry_set_get_size(struct efivar_entry *entry, u32 attributes,\r\nunsigned long *size, void *data, bool *set)\r\n{\r\nconst struct efivar_operations *ops = __efivars->ops;\r\nefi_char16_t *name = entry->var.VariableName;\r\nefi_guid_t *vendor = &entry->var.VendorGuid;\r\nefi_status_t status;\r\nint err;\r\n*set = false;\r\nif (efivar_validate(&entry->var, data, *size) == false)\r\nreturn -EINVAL;\r\nspin_lock_irq(&__efivars->lock);\r\nstatus = check_var_size(attributes, *size + ucs2_strsize(name, 1024));\r\nif (status != EFI_SUCCESS) {\r\nif (status != EFI_UNSUPPORTED) {\r\nerr = efi_status_to_err(status);\r\ngoto out;\r\n}\r\nif (*size > 65536) {\r\nerr = -ENOSPC;\r\ngoto out;\r\n}\r\n}\r\nstatus = ops->set_variable(name, vendor, attributes, *size, data);\r\nif (status != EFI_SUCCESS) {\r\nerr = efi_status_to_err(status);\r\ngoto out;\r\n}\r\n*set = true;\r\n*size = 0;\r\nstatus = ops->get_variable(entry->var.VariableName,\r\n&entry->var.VendorGuid,\r\nNULL, size, NULL);\r\nif (status == EFI_NOT_FOUND)\r\nefivar_entry_list_del_unlock(entry);\r\nelse\r\nspin_unlock_irq(&__efivars->lock);\r\nif (status && status != EFI_BUFFER_TOO_SMALL)\r\nreturn efi_status_to_err(status);\r\nreturn 0;\r\nout:\r\nspin_unlock_irq(&__efivars->lock);\r\nreturn err;\r\n}\r\nvoid efivar_entry_iter_begin(void)\r\n{\r\nspin_lock_irq(&__efivars->lock);\r\n}\r\nvoid efivar_entry_iter_end(void)\r\n{\r\nspin_unlock_irq(&__efivars->lock);\r\n}\r\nint __efivar_entry_iter(int (*func)(struct efivar_entry *, void *),\r\nstruct list_head *head, void *data,\r\nstruct efivar_entry **prev)\r\n{\r\nstruct efivar_entry *entry, *n;\r\nint err = 0;\r\nif (!prev || !*prev) {\r\nlist_for_each_entry_safe(entry, n, head, list) {\r\nerr = func(entry, data);\r\nif (err)\r\nbreak;\r\n}\r\nif (prev)\r\n*prev = entry;\r\nreturn err;\r\n}\r\nlist_for_each_entry_safe_continue((*prev), n, head, list) {\r\nerr = func(*prev, data);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint efivar_entry_iter(int (*func)(struct efivar_entry *, void *),\r\nstruct list_head *head, void *data)\r\n{\r\nint err = 0;\r\nefivar_entry_iter_begin();\r\nerr = __efivar_entry_iter(func, head, data, NULL);\r\nefivar_entry_iter_end();\r\nreturn err;\r\n}\r\nstruct kobject *efivars_kobject(void)\r\n{\r\nif (!__efivars)\r\nreturn NULL;\r\nreturn __efivars->kobject;\r\n}\r\nvoid efivar_run_worker(void)\r\n{\r\nif (efivar_wq_enabled)\r\nschedule_work(&efivar_work);\r\n}\r\nint efivars_register(struct efivars *efivars,\r\nconst struct efivar_operations *ops,\r\nstruct kobject *kobject)\r\n{\r\nspin_lock_init(&efivars->lock);\r\nefivars->ops = ops;\r\nefivars->kobject = kobject;\r\n__efivars = efivars;\r\nreturn 0;\r\n}\r\nint efivars_unregister(struct efivars *efivars)\r\n{\r\nint rv;\r\nif (!__efivars) {\r\nprintk(KERN_ERR "efivars not registered\n");\r\nrv = -EINVAL;\r\ngoto out;\r\n}\r\nif (__efivars != efivars) {\r\nrv = -EINVAL;\r\ngoto out;\r\n}\r\n__efivars = NULL;\r\nrv = 0;\r\nout:\r\nreturn rv;\r\n}
