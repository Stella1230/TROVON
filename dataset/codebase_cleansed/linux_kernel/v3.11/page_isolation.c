int set_migratetype_isolate(struct page *page, bool skip_hwpoisoned_pages)\r\n{\r\nstruct zone *zone;\r\nunsigned long flags, pfn;\r\nstruct memory_isolate_notify arg;\r\nint notifier_ret;\r\nint ret = -EBUSY;\r\nzone = page_zone(page);\r\nspin_lock_irqsave(&zone->lock, flags);\r\npfn = page_to_pfn(page);\r\narg.start_pfn = pfn;\r\narg.nr_pages = pageblock_nr_pages;\r\narg.pages_found = 0;\r\nnotifier_ret = memory_isolate_notify(MEM_ISOLATE_COUNT, &arg);\r\nnotifier_ret = notifier_to_errno(notifier_ret);\r\nif (notifier_ret)\r\ngoto out;\r\nif (!has_unmovable_pages(zone, page, arg.pages_found,\r\nskip_hwpoisoned_pages))\r\nret = 0;\r\nout:\r\nif (!ret) {\r\nunsigned long nr_pages;\r\nint migratetype = get_pageblock_migratetype(page);\r\nset_pageblock_migratetype(page, MIGRATE_ISOLATE);\r\nnr_pages = move_freepages_block(zone, page, MIGRATE_ISOLATE);\r\n__mod_zone_freepage_state(zone, -nr_pages, migratetype);\r\n}\r\nspin_unlock_irqrestore(&zone->lock, flags);\r\nif (!ret)\r\ndrain_all_pages();\r\nreturn ret;\r\n}\r\nvoid unset_migratetype_isolate(struct page *page, unsigned migratetype)\r\n{\r\nstruct zone *zone;\r\nunsigned long flags, nr_pages;\r\nzone = page_zone(page);\r\nspin_lock_irqsave(&zone->lock, flags);\r\nif (get_pageblock_migratetype(page) != MIGRATE_ISOLATE)\r\ngoto out;\r\nnr_pages = move_freepages_block(zone, page, migratetype);\r\n__mod_zone_freepage_state(zone, nr_pages, migratetype);\r\nset_pageblock_migratetype(page, migratetype);\r\nout:\r\nspin_unlock_irqrestore(&zone->lock, flags);\r\n}\r\nstatic inline struct page *\r\n__first_valid_page(unsigned long pfn, unsigned long nr_pages)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_pages; i++)\r\nif (pfn_valid_within(pfn + i))\r\nbreak;\r\nif (unlikely(i == nr_pages))\r\nreturn NULL;\r\nreturn pfn_to_page(pfn + i);\r\n}\r\nint start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\r\nunsigned migratetype, bool skip_hwpoisoned_pages)\r\n{\r\nunsigned long pfn;\r\nunsigned long undo_pfn;\r\nstruct page *page;\r\nBUG_ON((start_pfn) & (pageblock_nr_pages - 1));\r\nBUG_ON((end_pfn) & (pageblock_nr_pages - 1));\r\nfor (pfn = start_pfn;\r\npfn < end_pfn;\r\npfn += pageblock_nr_pages) {\r\npage = __first_valid_page(pfn, pageblock_nr_pages);\r\nif (page &&\r\nset_migratetype_isolate(page, skip_hwpoisoned_pages)) {\r\nundo_pfn = pfn;\r\ngoto undo;\r\n}\r\n}\r\nreturn 0;\r\nundo:\r\nfor (pfn = start_pfn;\r\npfn < undo_pfn;\r\npfn += pageblock_nr_pages)\r\nunset_migratetype_isolate(pfn_to_page(pfn), migratetype);\r\nreturn -EBUSY;\r\n}\r\nint undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\r\nunsigned migratetype)\r\n{\r\nunsigned long pfn;\r\nstruct page *page;\r\nBUG_ON((start_pfn) & (pageblock_nr_pages - 1));\r\nBUG_ON((end_pfn) & (pageblock_nr_pages - 1));\r\nfor (pfn = start_pfn;\r\npfn < end_pfn;\r\npfn += pageblock_nr_pages) {\r\npage = __first_valid_page(pfn, pageblock_nr_pages);\r\nif (!page || get_pageblock_migratetype(page) != MIGRATE_ISOLATE)\r\ncontinue;\r\nunset_migratetype_isolate(page, migratetype);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n__test_page_isolated_in_pageblock(unsigned long pfn, unsigned long end_pfn,\r\nbool skip_hwpoisoned_pages)\r\n{\r\nstruct page *page;\r\nwhile (pfn < end_pfn) {\r\nif (!pfn_valid_within(pfn)) {\r\npfn++;\r\ncontinue;\r\n}\r\npage = pfn_to_page(pfn);\r\nif (PageBuddy(page)) {\r\nif (get_freepage_migratetype(page) != MIGRATE_ISOLATE) {\r\nstruct page *end_page;\r\nend_page = page + (1 << page_order(page)) - 1;\r\nmove_freepages(page_zone(page), page, end_page,\r\nMIGRATE_ISOLATE);\r\n}\r\npfn += 1 << page_order(page);\r\n}\r\nelse if (page_count(page) == 0 &&\r\nget_freepage_migratetype(page) == MIGRATE_ISOLATE)\r\npfn += 1;\r\nelse if (skip_hwpoisoned_pages && PageHWPoison(page)) {\r\npfn++;\r\ncontinue;\r\n}\r\nelse\r\nbreak;\r\n}\r\nif (pfn < end_pfn)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,\r\nbool skip_hwpoisoned_pages)\r\n{\r\nunsigned long pfn, flags;\r\nstruct page *page;\r\nstruct zone *zone;\r\nint ret;\r\nfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\r\npage = __first_valid_page(pfn, pageblock_nr_pages);\r\nif (page && get_pageblock_migratetype(page) != MIGRATE_ISOLATE)\r\nbreak;\r\n}\r\npage = __first_valid_page(start_pfn, end_pfn - start_pfn);\r\nif ((pfn < end_pfn) || !page)\r\nreturn -EBUSY;\r\nzone = page_zone(page);\r\nspin_lock_irqsave(&zone->lock, flags);\r\nret = __test_page_isolated_in_pageblock(start_pfn, end_pfn,\r\nskip_hwpoisoned_pages);\r\nspin_unlock_irqrestore(&zone->lock, flags);\r\nreturn ret ? 0 : -EBUSY;\r\n}\r\nstruct page *alloc_migrate_target(struct page *page, unsigned long private,\r\nint **resultp)\r\n{\r\ngfp_t gfp_mask = GFP_USER | __GFP_MOVABLE;\r\nif (PageHighMem(page))\r\ngfp_mask |= __GFP_HIGHMEM;\r\nreturn alloc_page(gfp_mask);\r\n}
