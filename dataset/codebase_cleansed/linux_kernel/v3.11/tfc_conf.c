static ssize_t ft_parse_wwn(const char *name, u64 *wwn, int strict)\r\n{\r\nconst char *cp;\r\nchar c;\r\nu32 byte = 0;\r\nu32 pos = 0;\r\nu32 err;\r\nint val;\r\n*wwn = 0;\r\nfor (cp = name; cp < &name[FT_NAMELEN - 1]; cp++) {\r\nc = *cp;\r\nif (c == '\n' && cp[1] == '\0')\r\ncontinue;\r\nif (strict && pos++ == 2 && byte++ < 7) {\r\npos = 0;\r\nif (c == ':')\r\ncontinue;\r\nerr = 1;\r\ngoto fail;\r\n}\r\nif (c == '\0') {\r\nerr = 2;\r\nif (strict && byte != 8)\r\ngoto fail;\r\nreturn cp - name;\r\n}\r\nerr = 3;\r\nval = hex_to_bin(c);\r\nif (val < 0 || (strict && isupper(c)))\r\ngoto fail;\r\n*wwn = (*wwn << 4) | val;\r\n}\r\nerr = 4;\r\nfail:\r\npr_debug("err %u len %zu pos %u byte %u\n",\r\nerr, cp - name, pos, byte);\r\nreturn -1;\r\n}\r\nssize_t ft_format_wwn(char *buf, size_t len, u64 wwn)\r\n{\r\nu8 b[8];\r\nput_unaligned_be64(wwn, b);\r\nreturn snprintf(buf, len,\r\n"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x",\r\nb[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\r\n}\r\nstatic ssize_t ft_wwn_show(void *arg, char *buf)\r\n{\r\nu64 *wwn = arg;\r\nssize_t len;\r\nlen = ft_format_wwn(buf, PAGE_SIZE - 2, *wwn);\r\nbuf[len++] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t ft_wwn_store(void *arg, const char *buf, size_t len)\r\n{\r\nssize_t ret;\r\nu64 wwn;\r\nret = ft_parse_wwn(buf, &wwn, 0);\r\nif (ret > 0)\r\n*(u64 *)arg = wwn;\r\nreturn ret;\r\n}\r\nstatic ssize_t ft_nacl_show_port_name(\r\nstruct se_node_acl *se_nacl,\r\nchar *page)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_nacl,\r\nstruct ft_node_acl, se_node_acl);\r\nreturn ft_wwn_show(&acl->node_auth.port_name, page);\r\n}\r\nstatic ssize_t ft_nacl_store_port_name(\r\nstruct se_node_acl *se_nacl,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_nacl,\r\nstruct ft_node_acl, se_node_acl);\r\nreturn ft_wwn_store(&acl->node_auth.port_name, page, count);\r\n}\r\nstatic ssize_t ft_nacl_show_node_name(\r\nstruct se_node_acl *se_nacl,\r\nchar *page)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_nacl,\r\nstruct ft_node_acl, se_node_acl);\r\nreturn ft_wwn_show(&acl->node_auth.node_name, page);\r\n}\r\nstatic ssize_t ft_nacl_store_node_name(\r\nstruct se_node_acl *se_nacl,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_nacl,\r\nstruct ft_node_acl, se_node_acl);\r\nreturn ft_wwn_store(&acl->node_auth.node_name, page, count);\r\n}\r\nstatic struct se_node_acl *ft_add_acl(\r\nstruct se_portal_group *se_tpg,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct ft_node_acl *acl;\r\nstruct ft_tpg *tpg;\r\nu64 wwpn;\r\nu32 q_depth;\r\npr_debug("add acl %s\n", name);\r\ntpg = container_of(se_tpg, struct ft_tpg, se_tpg);\r\nif (ft_parse_wwn(name, &wwpn, 1) < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nacl = kzalloc(sizeof(struct ft_node_acl), GFP_KERNEL);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nacl->node_auth.port_name = wwpn;\r\nq_depth = 32;\r\nreturn core_tpg_add_initiator_node_acl(&tpg->se_tpg,\r\n&acl->se_node_acl, name, q_depth);\r\n}\r\nstatic void ft_del_acl(struct se_node_acl *se_acl)\r\n{\r\nstruct se_portal_group *se_tpg = se_acl->se_tpg;\r\nstruct ft_tpg *tpg;\r\nstruct ft_node_acl *acl = container_of(se_acl,\r\nstruct ft_node_acl, se_node_acl);\r\npr_debug("del acl %s\n",\r\nconfig_item_name(&se_acl->acl_group.cg_item));\r\ntpg = container_of(se_tpg, struct ft_tpg, se_tpg);\r\npr_debug("del acl %p se_acl %p tpg %p se_tpg %p\n",\r\nacl, se_acl, tpg, &tpg->se_tpg);\r\ncore_tpg_del_initiator_node_acl(&tpg->se_tpg, se_acl, 1);\r\nkfree(acl);\r\n}\r\nstruct ft_node_acl *ft_acl_get(struct ft_tpg *tpg, struct fc_rport_priv *rdata)\r\n{\r\nstruct ft_node_acl *found = NULL;\r\nstruct ft_node_acl *acl;\r\nstruct se_portal_group *se_tpg = &tpg->se_tpg;\r\nstruct se_node_acl *se_acl;\r\nspin_lock_irq(&se_tpg->acl_node_lock);\r\nlist_for_each_entry(se_acl, &se_tpg->acl_node_list, acl_list) {\r\nacl = container_of(se_acl, struct ft_node_acl, se_node_acl);\r\npr_debug("acl %p port_name %llx\n",\r\nacl, (unsigned long long)acl->node_auth.port_name);\r\nif (acl->node_auth.port_name == rdata->ids.port_name ||\r\nacl->node_auth.node_name == rdata->ids.node_name) {\r\npr_debug("acl %p port_name %llx matched\n", acl,\r\n(unsigned long long)rdata->ids.port_name);\r\nfound = acl;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(&se_tpg->acl_node_lock);\r\nreturn found;\r\n}\r\nstruct se_node_acl *ft_tpg_alloc_fabric_acl(struct se_portal_group *se_tpg)\r\n{\r\nstruct ft_node_acl *acl;\r\nacl = kzalloc(sizeof(*acl), GFP_KERNEL);\r\nif (!acl) {\r\npr_err("Unable to allocate struct ft_node_acl\n");\r\nreturn NULL;\r\n}\r\npr_debug("acl %p\n", acl);\r\nreturn &acl->se_node_acl;\r\n}\r\nstatic void ft_tpg_release_fabric_acl(struct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_acl)\r\n{\r\nstruct ft_node_acl *acl = container_of(se_acl,\r\nstruct ft_node_acl, se_node_acl);\r\npr_debug("acl %p\n", acl);\r\nkfree(acl);\r\n}\r\nstatic struct se_portal_group *ft_add_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct ft_lport_acl *lacl;\r\nstruct ft_tpg *tpg;\r\nstruct workqueue_struct *wq;\r\nunsigned long index;\r\nint ret;\r\npr_debug("tcm_fc: add tpg %s\n", name);\r\nif (strstr(name, "tpgt_") != name)\r\nreturn NULL;\r\nif (strict_strtoul(name + 5, 10, &index) || index > UINT_MAX)\r\nreturn NULL;\r\nlacl = container_of(wwn, struct ft_lport_acl, fc_lport_wwn);\r\ntpg = kzalloc(sizeof(*tpg), GFP_KERNEL);\r\nif (!tpg)\r\nreturn NULL;\r\ntpg->index = index;\r\ntpg->lport_acl = lacl;\r\nINIT_LIST_HEAD(&tpg->lun_list);\r\nwq = alloc_workqueue("tcm_fc", 0, 1);\r\nif (!wq) {\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\nret = core_tpg_register(&ft_configfs->tf_ops, wwn, &tpg->se_tpg,\r\ntpg, TRANSPORT_TPG_TYPE_NORMAL);\r\nif (ret < 0) {\r\ndestroy_workqueue(wq);\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\ntpg->workqueue = wq;\r\nmutex_lock(&ft_lport_lock);\r\nlist_add_tail(&tpg->list, &lacl->tpg_list);\r\nmutex_unlock(&ft_lport_lock);\r\nreturn &tpg->se_tpg;\r\n}\r\nstatic void ft_del_tpg(struct se_portal_group *se_tpg)\r\n{\r\nstruct ft_tpg *tpg = container_of(se_tpg, struct ft_tpg, se_tpg);\r\npr_debug("del tpg %s\n",\r\nconfig_item_name(&tpg->se_tpg.tpg_group.cg_item));\r\ndestroy_workqueue(tpg->workqueue);\r\nsynchronize_rcu();\r\nmutex_lock(&ft_lport_lock);\r\nlist_del(&tpg->list);\r\nif (tpg->tport) {\r\ntpg->tport->tpg = NULL;\r\ntpg->tport = NULL;\r\n}\r\nmutex_unlock(&ft_lport_lock);\r\ncore_tpg_deregister(se_tpg);\r\nkfree(tpg);\r\n}\r\nstruct ft_tpg *ft_lport_find_tpg(struct fc_lport *lport)\r\n{\r\nstruct ft_lport_acl *lacl;\r\nstruct ft_tpg *tpg;\r\nlist_for_each_entry(lacl, &ft_lport_list, list) {\r\nif (lacl->wwpn == lport->wwpn) {\r\nlist_for_each_entry(tpg, &lacl->tpg_list, list)\r\nreturn tpg;\r\nreturn NULL;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct se_wwn *ft_add_lport(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct ft_lport_acl *lacl;\r\nstruct ft_lport_acl *old_lacl;\r\nu64 wwpn;\r\npr_debug("add lport %s\n", name);\r\nif (ft_parse_wwn(name, &wwpn, 1) < 0)\r\nreturn NULL;\r\nlacl = kzalloc(sizeof(*lacl), GFP_KERNEL);\r\nif (!lacl)\r\nreturn NULL;\r\nlacl->wwpn = wwpn;\r\nINIT_LIST_HEAD(&lacl->tpg_list);\r\nmutex_lock(&ft_lport_lock);\r\nlist_for_each_entry(old_lacl, &ft_lport_list, list) {\r\nif (old_lacl->wwpn == wwpn) {\r\nmutex_unlock(&ft_lport_lock);\r\nkfree(lacl);\r\nreturn NULL;\r\n}\r\n}\r\nlist_add_tail(&lacl->list, &ft_lport_list);\r\nft_format_wwn(lacl->name, sizeof(lacl->name), wwpn);\r\nmutex_unlock(&ft_lport_lock);\r\nreturn &lacl->fc_lport_wwn;\r\n}\r\nstatic void ft_del_lport(struct se_wwn *wwn)\r\n{\r\nstruct ft_lport_acl *lacl = container_of(wwn,\r\nstruct ft_lport_acl, fc_lport_wwn);\r\npr_debug("del lport %s\n", lacl->name);\r\nmutex_lock(&ft_lport_lock);\r\nlist_del(&lacl->list);\r\nmutex_unlock(&ft_lport_lock);\r\nkfree(lacl);\r\n}\r\nstatic ssize_t ft_wwn_show_attr_version(\r\nstruct target_fabric_configfs *tf,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "TCM FC " FT_VERSION " on %s/%s on "\r\n""UTS_RELEASE"\n", utsname()->sysname, utsname()->machine);\r\n}\r\nstatic char *ft_get_fabric_name(void)\r\n{\r\nreturn "fc";\r\n}\r\nstatic char *ft_get_fabric_wwn(struct se_portal_group *se_tpg)\r\n{\r\nstruct ft_tpg *tpg = se_tpg->se_tpg_fabric_ptr;\r\nreturn tpg->lport_acl->name;\r\n}\r\nstatic u16 ft_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nstruct ft_tpg *tpg = se_tpg->se_tpg_fabric_ptr;\r\nreturn tpg->index;\r\n}\r\nstatic u32 ft_get_default_depth(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int ft_check_false(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ft_set_default_node_attr(struct se_node_acl *se_nacl)\r\n{\r\n}\r\nstatic u32 ft_tpg_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nstruct ft_tpg *tpg = se_tpg->se_tpg_fabric_ptr;\r\nreturn tpg->index;\r\n}\r\nint ft_register_configfs(void)\r\n{\r\nstruct target_fabric_configfs *fabric;\r\nint ret;\r\nfabric = target_fabric_configfs_init(THIS_MODULE, "fc");\r\nif (IS_ERR(fabric)) {\r\npr_err("%s: target_fabric_configfs_init() failed!\n",\r\n__func__);\r\nreturn PTR_ERR(fabric);\r\n}\r\nfabric->tf_ops = ft_fabric_ops;\r\nTF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = ft_wwn_attrs;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_nacl_base_cit.ct_attrs =\r\nft_nacl_base_attrs;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = NULL;\r\nTF_CIT_TMPL(fabric)->tfc_tpg_nacl_param_cit.ct_attrs = NULL;\r\nret = target_fabric_configfs_register(fabric);\r\nif (ret < 0) {\r\npr_debug("target_fabric_configfs_register() for"\r\n" FC Target failed!\n");\r\ntarget_fabric_configfs_free(fabric);\r\nreturn -1;\r\n}\r\nft_configfs = fabric;\r\nreturn 0;\r\n}\r\nvoid ft_deregister_configfs(void)\r\n{\r\nif (!ft_configfs)\r\nreturn;\r\ntarget_fabric_configfs_deregister(ft_configfs);\r\nft_configfs = NULL;\r\n}\r\nstatic int __init ft_init(void)\r\n{\r\nif (ft_register_configfs())\r\nreturn -1;\r\nif (fc_fc4_register_provider(FC_TYPE_FCP, &ft_prov)) {\r\nft_deregister_configfs();\r\nreturn -1;\r\n}\r\nblocking_notifier_chain_register(&fc_lport_notifier_head, &ft_notifier);\r\nfc_lport_iterate(ft_lport_add, NULL);\r\nreturn 0;\r\n}\r\nstatic void __exit ft_exit(void)\r\n{\r\nblocking_notifier_chain_unregister(&fc_lport_notifier_head,\r\n&ft_notifier);\r\nfc_fc4_deregister_provider(FC_TYPE_FCP, &ft_prov);\r\nfc_lport_iterate(ft_lport_del, NULL);\r\nft_deregister_configfs();\r\nsynchronize_rcu();\r\n}
