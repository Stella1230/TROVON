static int dtl1_write(unsigned int iobase, int fifo_size, __u8 *buf, int len)\r\n{\r\nint actual = 0;\r\nif (!(inb(iobase + UART_LSR) & UART_LSR_THRE))\r\nreturn 0;\r\nwhile ((fifo_size-- > 0) && (actual < len)) {\r\noutb(buf[actual], iobase + UART_TX);\r\nactual++;\r\n}\r\nreturn actual;\r\n}\r\nstatic void dtl1_write_wakeup(dtl1_info_t *info)\r\n{\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\nif (test_bit(XMIT_WAITING, &(info->tx_state))) {\r\nset_bit(XMIT_WAKEUP, &(info->tx_state));\r\nreturn;\r\n}\r\nif (test_and_set_bit(XMIT_SENDING, &(info->tx_state))) {\r\nset_bit(XMIT_WAKEUP, &(info->tx_state));\r\nreturn;\r\n}\r\ndo {\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nregister struct sk_buff *skb;\r\nint len;\r\nclear_bit(XMIT_WAKEUP, &(info->tx_state));\r\nif (!pcmcia_dev_present(info->p_dev))\r\nreturn;\r\nif (!(skb = skb_dequeue(&(info->txq))))\r\nbreak;\r\nlen = dtl1_write(iobase, 32, skb->data, skb->len);\r\nif (len == skb->len) {\r\nset_bit(XMIT_WAITING, &(info->tx_state));\r\nkfree_skb(skb);\r\n} else {\r\nskb_pull(skb, len);\r\nskb_queue_head(&(info->txq), skb);\r\n}\r\ninfo->hdev->stat.byte_tx += len;\r\n} while (test_bit(XMIT_WAKEUP, &(info->tx_state)));\r\nclear_bit(XMIT_SENDING, &(info->tx_state));\r\n}\r\nstatic void dtl1_control(dtl1_info_t *info, struct sk_buff *skb)\r\n{\r\nu8 flowmask = *(u8 *)skb->data;\r\nint i;\r\nprintk(KERN_INFO "Bluetooth: Nokia control data =");\r\nfor (i = 0; i < skb->len; i++) {\r\nprintk(" %02x", skb->data[i]);\r\n}\r\nprintk("\n");\r\nif (((info->flowmask & 0x07) == 0) && ((flowmask & 0x07) != 0)) {\r\nclear_bit(XMIT_WAITING, &(info->tx_state));\r\ndtl1_write_wakeup(info);\r\n}\r\ninfo->flowmask = flowmask;\r\nkfree_skb(skb);\r\n}\r\nstatic void dtl1_receive(dtl1_info_t *info)\r\n{\r\nunsigned int iobase;\r\nnsh_t *nsh;\r\nint boguscount = 0;\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\niobase = info->p_dev->resource[0]->start;\r\ndo {\r\ninfo->hdev->stat.byte_rx++;\r\nif (info->rx_skb == NULL)\r\nif (!(info->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {\r\nBT_ERR("Can't allocate mem for new packet");\r\ninfo->rx_state = RECV_WAIT_NSH;\r\ninfo->rx_count = NSHL;\r\nreturn;\r\n}\r\n*skb_put(info->rx_skb, 1) = inb(iobase + UART_RX);\r\nnsh = (nsh_t *)info->rx_skb->data;\r\ninfo->rx_count--;\r\nif (info->rx_count == 0) {\r\nswitch (info->rx_state) {\r\ncase RECV_WAIT_NSH:\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = nsh->len + (nsh->len & 0x0001);\r\nbreak;\r\ncase RECV_WAIT_DATA:\r\nbt_cb(info->rx_skb)->pkt_type = nsh->type;\r\nif (nsh->len & 0x0001) {\r\ninfo->rx_skb->tail--;\r\ninfo->rx_skb->len--;\r\n}\r\nskb_pull(info->rx_skb, NSHL);\r\nswitch (bt_cb(info->rx_skb)->pkt_type) {\r\ncase 0x80:\r\ndtl1_control(info, info->rx_skb);\r\nbreak;\r\ncase 0x82:\r\ncase 0x83:\r\ncase 0x84:\r\ninfo->rx_skb->dev = (void *) info->hdev;\r\nbt_cb(info->rx_skb)->pkt_type &= 0x0f;\r\nhci_recv_frame(info->rx_skb);\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown HCI packet with type 0x%02x received", bt_cb(info->rx_skb)->pkt_type);\r\nkfree_skb(info->rx_skb);\r\nbreak;\r\n}\r\ninfo->rx_state = RECV_WAIT_NSH;\r\ninfo->rx_count = NSHL;\r\ninfo->rx_skb = NULL;\r\nbreak;\r\n}\r\n}\r\nif (boguscount++ > 32)\r\nbreak;\r\n} while (inb(iobase + UART_LSR) & UART_LSR_DR);\r\n}\r\nstatic irqreturn_t dtl1_interrupt(int irq, void *dev_inst)\r\n{\r\ndtl1_info_t *info = dev_inst;\r\nunsigned int iobase;\r\nunsigned char msr;\r\nint boguscount = 0;\r\nint iir, lsr;\r\nirqreturn_t r = IRQ_NONE;\r\nif (!info || !info->hdev)\r\nreturn IRQ_NONE;\r\niobase = info->p_dev->resource[0]->start;\r\nspin_lock(&(info->lock));\r\niir = inb(iobase + UART_IIR) & UART_IIR_ID;\r\nwhile (iir) {\r\nr = IRQ_HANDLED;\r\nlsr = inb(iobase + UART_LSR);\r\nswitch (iir) {\r\ncase UART_IIR_RLSI:\r\nBT_ERR("RLSI");\r\nbreak;\r\ncase UART_IIR_RDI:\r\ndtl1_receive(info);\r\nbreak;\r\ncase UART_IIR_THRI:\r\nif (lsr & UART_LSR_THRE) {\r\ndtl1_write_wakeup(info);\r\n}\r\nbreak;\r\ndefault:\r\nBT_ERR("Unhandled IIR=%#x", iir);\r\nbreak;\r\n}\r\nif (boguscount++ > 100)\r\nbreak;\r\niir = inb(iobase + UART_IIR) & UART_IIR_ID;\r\n}\r\nmsr = inb(iobase + UART_MSR);\r\nif (info->ri_latch ^ (msr & UART_MSR_RI)) {\r\ninfo->ri_latch = msr & UART_MSR_RI;\r\nclear_bit(XMIT_WAITING, &(info->tx_state));\r\ndtl1_write_wakeup(info);\r\nr = IRQ_HANDLED;\r\n}\r\nspin_unlock(&(info->lock));\r\nreturn r;\r\n}\r\nstatic int dtl1_hci_open(struct hci_dev *hdev)\r\n{\r\nset_bit(HCI_RUNNING, &(hdev->flags));\r\nreturn 0;\r\n}\r\nstatic int dtl1_hci_flush(struct hci_dev *hdev)\r\n{\r\ndtl1_info_t *info = hci_get_drvdata(hdev);\r\nskb_queue_purge(&(info->txq));\r\nreturn 0;\r\n}\r\nstatic int dtl1_hci_close(struct hci_dev *hdev)\r\n{\r\nif (!test_and_clear_bit(HCI_RUNNING, &(hdev->flags)))\r\nreturn 0;\r\ndtl1_hci_flush(hdev);\r\nreturn 0;\r\n}\r\nstatic int dtl1_hci_send_frame(struct sk_buff *skb)\r\n{\r\ndtl1_info_t *info;\r\nstruct hci_dev *hdev = (struct hci_dev *)(skb->dev);\r\nstruct sk_buff *s;\r\nnsh_t nsh;\r\nif (!hdev) {\r\nBT_ERR("Frame for unknown HCI device (hdev=NULL)");\r\nreturn -ENODEV;\r\n}\r\ninfo = hci_get_drvdata(hdev);\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nnsh.type = 0x81;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nnsh.type = 0x82;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nnsh.type = 0x83;\r\nbreak;\r\ndefault:\r\nreturn -EILSEQ;\r\n};\r\nnsh.zero = 0;\r\nnsh.len = skb->len;\r\ns = bt_skb_alloc(NSHL + skb->len + 1, GFP_ATOMIC);\r\nif (!s)\r\nreturn -ENOMEM;\r\nskb_reserve(s, NSHL);\r\nskb_copy_from_linear_data(skb, skb_put(s, skb->len), skb->len);\r\nif (skb->len & 0x0001)\r\n*skb_put(s, 1) = 0;\r\nmemcpy(skb_push(s, NSHL), &nsh, NSHL);\r\nskb_queue_tail(&(info->txq), s);\r\ndtl1_write_wakeup(info);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int dtl1_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int dtl1_open(dtl1_info_t *info)\r\n{\r\nunsigned long flags;\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nstruct hci_dev *hdev;\r\nspin_lock_init(&(info->lock));\r\nskb_queue_head_init(&(info->txq));\r\ninfo->rx_state = RECV_WAIT_NSH;\r\ninfo->rx_count = NSHL;\r\ninfo->rx_skb = NULL;\r\nset_bit(XMIT_WAITING, &(info->tx_state));\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can't allocate HCI device");\r\nreturn -ENOMEM;\r\n}\r\ninfo->hdev = hdev;\r\nhdev->bus = HCI_PCCARD;\r\nhci_set_drvdata(hdev, info);\r\nSET_HCIDEV_DEV(hdev, &info->p_dev->dev);\r\nhdev->open = dtl1_hci_open;\r\nhdev->close = dtl1_hci_close;\r\nhdev->flush = dtl1_hci_flush;\r\nhdev->send = dtl1_hci_send_frame;\r\nhdev->ioctl = dtl1_hci_ioctl;\r\nspin_lock_irqsave(&(info->lock), flags);\r\noutb(0, iobase + UART_MCR);\r\noutb(0, iobase + UART_IER);\r\noutb(UART_LCR_WLEN8, iobase + UART_LCR);\r\noutb((UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2), iobase + UART_MCR);\r\ninfo->ri_latch = inb(info->p_dev->resource[0]->start + UART_MSR)\r\n& UART_MSR_RI;\r\noutb(UART_IER_RLSI | UART_IER_RDI | UART_IER_THRI, iobase + UART_IER);\r\nspin_unlock_irqrestore(&(info->lock), flags);\r\nmsleep(2000);\r\nif (hci_register_dev(hdev) < 0) {\r\nBT_ERR("Can't register HCI device");\r\ninfo->hdev = NULL;\r\nhci_free_dev(hdev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dtl1_close(dtl1_info_t *info)\r\n{\r\nunsigned long flags;\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nstruct hci_dev *hdev = info->hdev;\r\nif (!hdev)\r\nreturn -ENODEV;\r\ndtl1_hci_close(hdev);\r\nspin_lock_irqsave(&(info->lock), flags);\r\noutb(0, iobase + UART_MCR);\r\noutb(0, iobase + UART_IER);\r\nspin_unlock_irqrestore(&(info->lock), flags);\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\nreturn 0;\r\n}\r\nstatic int dtl1_probe(struct pcmcia_device *link)\r\n{\r\ndtl1_info_t *info;\r\ninfo = devm_kzalloc(&link->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nreturn dtl1_config(link);\r\n}\r\nstatic void dtl1_detach(struct pcmcia_device *link)\r\n{\r\ndtl1_info_t *info = link->priv;\r\ndtl1_close(info);\r\npcmcia_disable_device(link);\r\n}\r\nstatic int dtl1_confcheck(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nif ((p_dev->resource[1]->end) || (p_dev->resource[1]->end < 8))\r\nreturn -ENODEV;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int dtl1_config(struct pcmcia_device *link)\r\n{\r\ndtl1_info_t *info = link->priv;\r\nint ret;\r\nlink->resource[0]->end = 8;\r\nret = pcmcia_loop_config(link, dtl1_confcheck, NULL);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_request_irq(link, dtl1_interrupt);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\nret = dtl1_open(info);\r\nif (ret)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\ndtl1_detach(link);\r\nreturn ret;\r\n}
