static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)\r\n{\r\nedac_dbg(3, "\tedac_dev = %p dev_idx=%d\n",\r\nedac_dev, edac_dev->dev_idx);\r\nedac_dbg(4, "\tedac_dev->edac_check = %p\n", edac_dev->edac_check);\r\nedac_dbg(3, "\tdev = %p\n", edac_dev->dev);\r\nedac_dbg(3, "\tmod_name:ctl_name = %s:%s\n",\r\nedac_dev->mod_name, edac_dev->ctl_name);\r\nedac_dbg(3, "\tpvt_info = %p\n\n", edac_dev->pvt_info);\r\n}\r\nstruct edac_device_ctl_info *edac_device_alloc_ctl_info(\r\nunsigned sz_private,\r\nchar *edac_device_name, unsigned nr_instances,\r\nchar *edac_block_name, unsigned nr_blocks,\r\nunsigned offset_value,\r\nstruct edac_dev_sysfs_block_attribute *attrib_spec, unsigned nr_attrib,\r\nint device_index)\r\n{\r\nstruct edac_device_ctl_info *dev_ctl;\r\nstruct edac_device_instance *dev_inst, *inst;\r\nstruct edac_device_block *dev_blk, *blk_p, *blk;\r\nstruct edac_dev_sysfs_block_attribute *dev_attrib, *attrib_p, *attrib;\r\nunsigned total_size;\r\nunsigned count;\r\nunsigned instance, block, attr;\r\nvoid *pvt, *p;\r\nint err;\r\nedac_dbg(4, "instances=%d blocks=%d\n", nr_instances, nr_blocks);\r\np = NULL;\r\ndev_ctl = edac_align_ptr(&p, sizeof(*dev_ctl), 1);\r\ndev_inst = edac_align_ptr(&p, sizeof(*dev_inst), nr_instances);\r\ncount = nr_instances * nr_blocks;\r\ndev_blk = edac_align_ptr(&p, sizeof(*dev_blk), count);\r\nif (nr_attrib > 0)\r\ncount *= nr_attrib;\r\ndev_attrib = edac_align_ptr(&p, sizeof(*dev_attrib), count);\r\npvt = edac_align_ptr(&p, sz_private, 1);\r\ntotal_size = ((unsigned long)pvt) + sz_private;\r\ndev_ctl = kzalloc(total_size, GFP_KERNEL);\r\nif (dev_ctl == NULL)\r\nreturn NULL;\r\ndev_inst = (struct edac_device_instance *)\r\n(((char *)dev_ctl) + ((unsigned long)dev_inst));\r\ndev_blk = (struct edac_device_block *)\r\n(((char *)dev_ctl) + ((unsigned long)dev_blk));\r\ndev_attrib = (struct edac_dev_sysfs_block_attribute *)\r\n(((char *)dev_ctl) + ((unsigned long)dev_attrib));\r\npvt = sz_private ? (((char *)dev_ctl) + ((unsigned long)pvt)) : NULL;\r\ndev_ctl->dev_idx = device_index;\r\ndev_ctl->nr_instances = nr_instances;\r\ndev_ctl->instances = dev_inst;\r\ndev_ctl->pvt_info = pvt;\r\ndev_ctl->log_ce = 1;\r\ndev_ctl->log_ue = 1;\r\nsnprintf(dev_ctl->name,sizeof(dev_ctl->name),"%s",edac_device_name);\r\nedac_dbg(4, "edac_dev=%p next after end=%p\n",\r\ndev_ctl, pvt + sz_private);\r\nfor (instance = 0; instance < nr_instances; instance++) {\r\ninst = &dev_inst[instance];\r\ninst->ctl = dev_ctl;\r\ninst->nr_blocks = nr_blocks;\r\nblk_p = &dev_blk[instance * nr_blocks];\r\ninst->blocks = blk_p;\r\nsnprintf(inst->name, sizeof(inst->name),\r\n"%s%u", edac_device_name, instance);\r\nfor (block = 0; block < nr_blocks; block++) {\r\nblk = &blk_p[block];\r\nblk->instance = inst;\r\nsnprintf(blk->name, sizeof(blk->name),\r\n"%s%d", edac_block_name, block+offset_value);\r\nedac_dbg(4, "instance=%d inst_p=%p block=#%d block_p=%p name='%s'\n",\r\ninstance, inst, block, blk, blk->name);\r\nif ((nr_attrib == 0) || (attrib_spec == NULL))\r\ncontinue;\r\nblk->nr_attribs = nr_attrib;\r\nattrib_p = &dev_attrib[block*nr_instances*nr_attrib];\r\nblk->block_attributes = attrib_p;\r\nedac_dbg(4, "THIS BLOCK_ATTRIB=%p\n",\r\nblk->block_attributes);\r\nfor (attr = 0; attr < nr_attrib; attr++) {\r\nattrib = &attrib_p[attr];\r\nattrib->attr = attrib_spec[attr].attr;\r\nattrib->show = attrib_spec[attr].show;\r\nattrib->store = attrib_spec[attr].store;\r\nattrib->block = blk;\r\nedac_dbg(4, "alloc-attrib=%p attrib_name='%s' attrib-spec=%p spec-name=%s\n",\r\nattrib, attrib->attr.name,\r\n&attrib_spec[attr],\r\nattrib_spec[attr].attr.name\r\n);\r\n}\r\n}\r\n}\r\ndev_ctl->op_state = OP_ALLOC;\r\nerr = edac_device_register_sysfs_main_kobj(dev_ctl);\r\nif (err) {\r\nkfree(dev_ctl);\r\nreturn NULL;\r\n}\r\nreturn dev_ctl;\r\n}\r\nvoid edac_device_free_ctl_info(struct edac_device_ctl_info *ctl_info)\r\n{\r\nedac_device_unregister_sysfs_main_kobj(ctl_info);\r\n}\r\nstatic struct edac_device_ctl_info *find_edac_device_by_dev(struct device *dev)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nstruct list_head *item;\r\nedac_dbg(0, "\n");\r\nlist_for_each(item, &edac_device_list) {\r\nedac_dev = list_entry(item, struct edac_device_ctl_info, link);\r\nif (edac_dev->dev == dev)\r\nreturn edac_dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct list_head *item, *insert_before;\r\nstruct edac_device_ctl_info *rover;\r\ninsert_before = &edac_device_list;\r\nrover = find_edac_device_by_dev(edac_dev->dev);\r\nif (unlikely(rover != NULL))\r\ngoto fail0;\r\nlist_for_each(item, &edac_device_list) {\r\nrover = list_entry(item, struct edac_device_ctl_info, link);\r\nif (rover->dev_idx >= edac_dev->dev_idx) {\r\nif (unlikely(rover->dev_idx == edac_dev->dev_idx))\r\ngoto fail1;\r\ninsert_before = item;\r\nbreak;\r\n}\r\n}\r\nlist_add_tail_rcu(&edac_dev->link, insert_before);\r\nreturn 0;\r\nfail0:\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"%s (%s) %s %s already assigned %d\n",\r\ndev_name(rover->dev), edac_dev_name(rover),\r\nrover->mod_name, rover->ctl_name, rover->dev_idx);\r\nreturn 1;\r\nfail1:\r\nedac_printk(KERN_WARNING, EDAC_MC,\r\n"bug in low-level driver: attempt to assign\n"\r\n" duplicate dev_idx %d in %s()\n", rover->dev_idx,\r\n__func__);\r\nreturn 1;\r\n}\r\nstatic void del_edac_device_from_global_list(struct edac_device_ctl_info\r\n*edac_device)\r\n{\r\nlist_del_rcu(&edac_device->link);\r\nsynchronize_rcu();\r\nINIT_LIST_HEAD(&edac_device->link);\r\n}\r\nstatic void edac_device_workq_function(struct work_struct *work_req)\r\n{\r\nstruct delayed_work *d_work = to_delayed_work(work_req);\r\nstruct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);\r\nmutex_lock(&device_ctls_mutex);\r\nif (edac_dev->op_state == OP_OFFLINE) {\r\nmutex_unlock(&device_ctls_mutex);\r\nreturn;\r\n}\r\nif ((edac_dev->op_state == OP_RUNNING_POLL) &&\r\n(edac_dev->edac_check != NULL)) {\r\nedac_dev->edac_check(edac_dev);\r\n}\r\nmutex_unlock(&device_ctls_mutex);\r\nif (edac_dev->poll_msec == 1000)\r\nqueue_delayed_work(edac_workqueue, &edac_dev->work,\r\nround_jiffies_relative(edac_dev->delay));\r\nelse\r\nqueue_delayed_work(edac_workqueue, &edac_dev->work,\r\nedac_dev->delay);\r\n}\r\nvoid edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,\r\nunsigned msec)\r\n{\r\nedac_dbg(0, "\n");\r\nedac_dev->poll_msec = msec;\r\nedac_dev->delay = msecs_to_jiffies(msec);\r\nINIT_DELAYED_WORK(&edac_dev->work, edac_device_workq_function);\r\nif (edac_dev->poll_msec == 1000)\r\nqueue_delayed_work(edac_workqueue, &edac_dev->work,\r\nround_jiffies_relative(edac_dev->delay));\r\nelse\r\nqueue_delayed_work(edac_workqueue, &edac_dev->work,\r\nedac_dev->delay);\r\n}\r\nvoid edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)\r\n{\r\nint status;\r\nstatus = cancel_delayed_work(&edac_dev->work);\r\nif (status == 0) {\r\nflush_workqueue(edac_workqueue);\r\n}\r\n}\r\nvoid edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,\r\nunsigned long value)\r\n{\r\nedac_device_workq_teardown(edac_dev);\r\nmutex_lock(&device_ctls_mutex);\r\nedac_device_workq_setup(edac_dev, value);\r\nmutex_unlock(&device_ctls_mutex);\r\n}\r\nint edac_device_alloc_index(void)\r\n{\r\nstatic atomic_t device_indexes = ATOMIC_INIT(0);\r\nreturn atomic_inc_return(&device_indexes) - 1;\r\n}\r\nint edac_device_add_device(struct edac_device_ctl_info *edac_dev)\r\n{\r\nedac_dbg(0, "\n");\r\n#ifdef CONFIG_EDAC_DEBUG\r\nif (edac_debug_level >= 3)\r\nedac_device_dump_device(edac_dev);\r\n#endif\r\nmutex_lock(&device_ctls_mutex);\r\nif (add_edac_dev_to_global_list(edac_dev))\r\ngoto fail0;\r\nedac_dev->start_time = jiffies;\r\nif (edac_device_create_sysfs(edac_dev)) {\r\nedac_device_printk(edac_dev, KERN_WARNING,\r\n"failed to create sysfs device\n");\r\ngoto fail1;\r\n}\r\nif (edac_dev->edac_check != NULL) {\r\nedac_dev->op_state = OP_RUNNING_POLL;\r\nedac_device_workq_setup(edac_dev, 1000);\r\n} else {\r\nedac_dev->op_state = OP_RUNNING_INTERRUPT;\r\n}\r\nedac_device_printk(edac_dev, KERN_INFO,\r\n"Giving out device to module '%s' controller "\r\n"'%s': DEV '%s' (%s)\n",\r\nedac_dev->mod_name,\r\nedac_dev->ctl_name,\r\nedac_dev_name(edac_dev),\r\nedac_op_state_to_string(edac_dev->op_state));\r\nmutex_unlock(&device_ctls_mutex);\r\nreturn 0;\r\nfail1:\r\ndel_edac_device_from_global_list(edac_dev);\r\nfail0:\r\nmutex_unlock(&device_ctls_mutex);\r\nreturn 1;\r\n}\r\nstruct edac_device_ctl_info *edac_device_del_device(struct device *dev)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nedac_dbg(0, "\n");\r\nmutex_lock(&device_ctls_mutex);\r\nedac_dev = find_edac_device_by_dev(dev);\r\nif (edac_dev == NULL) {\r\nmutex_unlock(&device_ctls_mutex);\r\nreturn NULL;\r\n}\r\nedac_dev->op_state = OP_OFFLINE;\r\ndel_edac_device_from_global_list(edac_dev);\r\nmutex_unlock(&device_ctls_mutex);\r\nedac_device_workq_teardown(edac_dev);\r\nedac_device_remove_sysfs(edac_dev);\r\nedac_printk(KERN_INFO, EDAC_MC,\r\n"Removed device %d for %s %s: DEV %s\n",\r\nedac_dev->dev_idx,\r\nedac_dev->mod_name, edac_dev->ctl_name, edac_dev_name(edac_dev));\r\nreturn edac_dev;\r\n}\r\nstatic inline int edac_device_get_log_ce(struct edac_device_ctl_info *edac_dev)\r\n{\r\nreturn edac_dev->log_ce;\r\n}\r\nstatic inline int edac_device_get_log_ue(struct edac_device_ctl_info *edac_dev)\r\n{\r\nreturn edac_dev->log_ue;\r\n}\r\nstatic inline int edac_device_get_panic_on_ue(struct edac_device_ctl_info\r\n*edac_dev)\r\n{\r\nreturn edac_dev->panic_on_ue;\r\n}\r\nvoid edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,\r\nint inst_nr, int block_nr, const char *msg)\r\n{\r\nstruct edac_device_instance *instance;\r\nstruct edac_device_block *block = NULL;\r\nif ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {\r\nedac_device_printk(edac_dev, KERN_ERR,\r\n"INTERNAL ERROR: 'instance' out of range "\r\n"(%d >= %d)\n", inst_nr,\r\nedac_dev->nr_instances);\r\nreturn;\r\n}\r\ninstance = edac_dev->instances + inst_nr;\r\nif ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {\r\nedac_device_printk(edac_dev, KERN_ERR,\r\n"INTERNAL ERROR: instance %d 'block' "\r\n"out of range (%d >= %d)\n",\r\ninst_nr, block_nr,\r\ninstance->nr_blocks);\r\nreturn;\r\n}\r\nif (instance->nr_blocks > 0) {\r\nblock = instance->blocks + block_nr;\r\nblock->counters.ce_count++;\r\n}\r\ninstance->counters.ce_count++;\r\nedac_dev->counters.ce_count++;\r\nif (edac_device_get_log_ce(edac_dev))\r\nedac_device_printk(edac_dev, KERN_WARNING,\r\n"CE: %s instance: %s block: %s '%s'\n",\r\nedac_dev->ctl_name, instance->name,\r\nblock ? block->name : "N/A", msg);\r\n}\r\nvoid edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,\r\nint inst_nr, int block_nr, const char *msg)\r\n{\r\nstruct edac_device_instance *instance;\r\nstruct edac_device_block *block = NULL;\r\nif ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {\r\nedac_device_printk(edac_dev, KERN_ERR,\r\n"INTERNAL ERROR: 'instance' out of range "\r\n"(%d >= %d)\n", inst_nr,\r\nedac_dev->nr_instances);\r\nreturn;\r\n}\r\ninstance = edac_dev->instances + inst_nr;\r\nif ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {\r\nedac_device_printk(edac_dev, KERN_ERR,\r\n"INTERNAL ERROR: instance %d 'block' "\r\n"out of range (%d >= %d)\n",\r\ninst_nr, block_nr,\r\ninstance->nr_blocks);\r\nreturn;\r\n}\r\nif (instance->nr_blocks > 0) {\r\nblock = instance->blocks + block_nr;\r\nblock->counters.ue_count++;\r\n}\r\ninstance->counters.ue_count++;\r\nedac_dev->counters.ue_count++;\r\nif (edac_device_get_log_ue(edac_dev))\r\nedac_device_printk(edac_dev, KERN_EMERG,\r\n"UE: %s instance: %s block: %s '%s'\n",\r\nedac_dev->ctl_name, instance->name,\r\nblock ? block->name : "N/A", msg);\r\nif (edac_device_get_panic_on_ue(edac_dev))\r\npanic("EDAC %s: UE instance: %s block %s '%s'\n",\r\nedac_dev->ctl_name, instance->name,\r\nblock ? block->name : "N/A", msg);\r\n}
