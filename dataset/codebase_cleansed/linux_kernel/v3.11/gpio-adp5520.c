static int adp5520_gpio_get_value(struct gpio_chip *chip, unsigned off)\r\n{\r\nstruct adp5520_gpio *dev;\r\nuint8_t reg_val;\r\ndev = container_of(chip, struct adp5520_gpio, gpio_chip);\r\nif (test_bit(off, &dev->output))\r\nadp5520_read(dev->master, ADP5520_GPIO_OUT, &reg_val);\r\nelse\r\nadp5520_read(dev->master, ADP5520_GPIO_IN, &reg_val);\r\nreturn !!(reg_val & dev->lut[off]);\r\n}\r\nstatic void adp5520_gpio_set_value(struct gpio_chip *chip,\r\nunsigned off, int val)\r\n{\r\nstruct adp5520_gpio *dev;\r\ndev = container_of(chip, struct adp5520_gpio, gpio_chip);\r\nif (val)\r\nadp5520_set_bits(dev->master, ADP5520_GPIO_OUT, dev->lut[off]);\r\nelse\r\nadp5520_clr_bits(dev->master, ADP5520_GPIO_OUT, dev->lut[off]);\r\n}\r\nstatic int adp5520_gpio_direction_input(struct gpio_chip *chip, unsigned off)\r\n{\r\nstruct adp5520_gpio *dev;\r\ndev = container_of(chip, struct adp5520_gpio, gpio_chip);\r\nclear_bit(off, &dev->output);\r\nreturn adp5520_clr_bits(dev->master, ADP5520_GPIO_CFG_2,\r\ndev->lut[off]);\r\n}\r\nstatic int adp5520_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned off, int val)\r\n{\r\nstruct adp5520_gpio *dev;\r\nint ret = 0;\r\ndev = container_of(chip, struct adp5520_gpio, gpio_chip);\r\nset_bit(off, &dev->output);\r\nif (val)\r\nret |= adp5520_set_bits(dev->master, ADP5520_GPIO_OUT,\r\ndev->lut[off]);\r\nelse\r\nret |= adp5520_clr_bits(dev->master, ADP5520_GPIO_OUT,\r\ndev->lut[off]);\r\nret |= adp5520_set_bits(dev->master, ADP5520_GPIO_CFG_2,\r\ndev->lut[off]);\r\nreturn ret;\r\n}\r\nstatic int adp5520_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct adp5520_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nstruct adp5520_gpio *dev;\r\nstruct gpio_chip *gc;\r\nint ret, i, gpios;\r\nunsigned char ctl_mask = 0;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdev->id != ID_ADP5520) {\r\ndev_err(&pdev->dev, "only ADP5520 supports GPIO\n");\r\nreturn -ENODEV;\r\n}\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&pdev->dev, "failed to alloc memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->master = pdev->dev.parent;\r\nfor (gpios = 0, i = 0; i < ADP5520_MAXGPIOS; i++)\r\nif (pdata->gpio_en_mask & (1 << i))\r\ndev->lut[gpios++] = 1 << i;\r\nif (gpios < 1) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ngc = &dev->gpio_chip;\r\ngc->direction_input = adp5520_gpio_direction_input;\r\ngc->direction_output = adp5520_gpio_direction_output;\r\ngc->get = adp5520_gpio_get_value;\r\ngc->set = adp5520_gpio_set_value;\r\ngc->can_sleep = 1;\r\ngc->base = pdata->gpio_start;\r\ngc->ngpio = gpios;\r\ngc->label = pdev->name;\r\ngc->owner = THIS_MODULE;\r\nret = adp5520_clr_bits(dev->master, ADP5520_GPIO_CFG_1,\r\npdata->gpio_en_mask);\r\nif (pdata->gpio_en_mask & ADP5520_GPIO_C3)\r\nctl_mask |= ADP5520_C3_MODE;\r\nif (pdata->gpio_en_mask & ADP5520_GPIO_R3)\r\nctl_mask |= ADP5520_R3_MODE;\r\nif (ctl_mask)\r\nret = adp5520_set_bits(dev->master, ADP5520_LED_CONTROL,\r\nctl_mask);\r\nret |= adp5520_set_bits(dev->master, ADP5520_GPIO_PULLUP,\r\npdata->gpio_pullup_mask);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to write\n");\r\ngoto err;\r\n}\r\nret = gpiochip_add(&dev->gpio_chip);\r\nif (ret)\r\ngoto err;\r\nplatform_set_drvdata(pdev, dev);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int adp5520_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct adp5520_gpio *dev;\r\nint ret;\r\ndev = platform_get_drvdata(pdev);\r\nret = gpiochip_remove(&dev->gpio_chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s failed, %d\n",\r\n"gpiochip_remove()", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
