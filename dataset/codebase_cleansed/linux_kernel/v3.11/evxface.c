acpi_status\r\nacpi_install_notify_handler(acpi_handle device,\r\nu32 handler_type,\r\nacpi_notify_handler handler, void *context)\r\n{\r\nstruct acpi_namespace_node *node =\r\nACPI_CAST_PTR(struct acpi_namespace_node, device);\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *handler_obj;\r\nacpi_status status;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(acpi_install_notify_handler);\r\nif ((!device) || (!handler) || (!handler_type) ||\r\n(handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (device == ACPI_ROOT_OBJECT) {\r\nfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\r\nif (handler_type & (i + 1)) {\r\nif (acpi_gbl_global_notify[i].handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto unlock_and_exit;\r\n}\r\nacpi_gbl_global_notify[i].handler = handler;\r\nacpi_gbl_global_notify[i].context = context;\r\n}\r\n}\r\ngoto unlock_and_exit;\r\n}\r\nif (!acpi_ev_is_notify_object(node)) {\r\nstatus = AE_TYPE;\r\ngoto unlock_and_exit;\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nobj_desc = acpi_ut_create_internal_object(node->type);\r\nif (!obj_desc) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ns_attach_object(device, obj_desc, node->type);\r\nacpi_ut_remove_reference(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\n}\r\nfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\r\nif (handler_type & (i + 1)) {\r\nhandler_obj = obj_desc->common_notify.notify_list[i];\r\nwhile (handler_obj) {\r\nif (handler_obj->notify.handler == handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto unlock_and_exit;\r\n}\r\nhandler_obj = handler_obj->notify.next[i];\r\n}\r\n}\r\n}\r\nhandler_obj = acpi_ut_create_internal_object(ACPI_TYPE_LOCAL_NOTIFY);\r\nif (!handler_obj) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nhandler_obj->notify.node = node;\r\nhandler_obj->notify.handler_type = handler_type;\r\nhandler_obj->notify.handler = handler;\r\nhandler_obj->notify.context = context;\r\nfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\r\nif (handler_type & (i + 1)) {\r\nhandler_obj->notify.next[i] =\r\nobj_desc->common_notify.notify_list[i];\r\nobj_desc->common_notify.notify_list[i] = handler_obj;\r\n}\r\n}\r\nif (handler_type == ACPI_ALL_NOTIFY) {\r\nacpi_ut_add_reference(handler_obj);\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_remove_notify_handler(acpi_handle device,\r\nu32 handler_type, acpi_notify_handler handler)\r\n{\r\nstruct acpi_namespace_node *node =\r\nACPI_CAST_PTR(struct acpi_namespace_node, device);\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *handler_obj;\r\nunion acpi_operand_object *previous_handler_obj;\r\nacpi_status status;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(acpi_remove_notify_handler);\r\nif ((!device) || (!handler) || (!handler_type) ||\r\n(handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nacpi_os_wait_events_complete();\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (device == ACPI_ROOT_OBJECT) {\r\nfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\r\nif (handler_type & (i + 1)) {\r\nif (!acpi_gbl_global_notify[i].handler ||\r\n(acpi_gbl_global_notify[i].handler !=\r\nhandler)) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Removing global notify handler\n"));\r\nacpi_gbl_global_notify[i].handler = NULL;\r\nacpi_gbl_global_notify[i].context = NULL;\r\n}\r\n}\r\ngoto unlock_and_exit;\r\n}\r\nif (!acpi_ev_is_notify_object(node)) {\r\nstatus = AE_TYPE;\r\ngoto unlock_and_exit;\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\r\nif (handler_type & (i + 1)) {\r\nhandler_obj = obj_desc->common_notify.notify_list[i];\r\nprevious_handler_obj = NULL;\r\nwhile (handler_obj &&\r\n(handler_obj->notify.handler != handler)) {\r\nprevious_handler_obj = handler_obj;\r\nhandler_obj = handler_obj->notify.next[i];\r\n}\r\nif (!handler_obj) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nif (previous_handler_obj) {\r\nprevious_handler_obj->notify.next[i] =\r\nhandler_obj->notify.next[i];\r\n} else {\r\nobj_desc->common_notify.notify_list[i] =\r\nhandler_obj->notify.next[i];\r\n}\r\nacpi_ut_remove_reference(handler_obj);\r\n}\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_install_exception_handler(acpi_exception_handler handler)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_exception_handler);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_exception_handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_exception_handler = handler;\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_install_global_event_handler(acpi_gbl_event_handler handler, void *context)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_global_event_handler);\r\nif (!handler) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_global_event_handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_global_event_handler = handler;\r\nacpi_gbl_global_event_handler_context = context;\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_install_fixed_event_handler(u32 event,\r\nacpi_event_handler handler, void *context)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_fixed_event_handler);\r\nif (event > ACPI_EVENT_MAX) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_fixed_event_handlers[event].handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_fixed_event_handlers[event].handler = handler;\r\nacpi_gbl_fixed_event_handlers[event].context = context;\r\nstatus = acpi_clear_event(event);\r\nif (ACPI_SUCCESS(status))\r\nstatus = acpi_enable_event(event, 0);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO,\r\n"Could not enable fixed event - %s (%u)",\r\nacpi_ut_get_event_name(event), event));\r\nacpi_gbl_fixed_event_handlers[event].handler = NULL;\r\nacpi_gbl_fixed_event_handlers[event].context = NULL;\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Enabled fixed event %s (%X), Handler=%p\n",\r\nacpi_ut_get_event_name(event), event,\r\nhandler));\r\n}\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_remove_fixed_event_handler(u32 event, acpi_event_handler handler)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(acpi_remove_fixed_event_handler);\r\nif (event > ACPI_EVENT_MAX) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_disable_event(event, 0);\r\nacpi_gbl_fixed_event_handlers[event].handler = NULL;\r\nacpi_gbl_fixed_event_handlers[event].context = NULL;\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO,\r\n"Could not disable fixed event - %s (%u)",\r\nacpi_ut_get_event_name(event), event));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Disabled fixed event - %s (%X)\n",\r\nacpi_ut_get_event_name(event), event));\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_install_gpe_handler(acpi_handle gpe_device,\r\nu32 gpe_number,\r\nu32 type, acpi_gpe_handler address, void *context)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nstruct acpi_gpe_handler_info *handler;\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_install_gpe_handler);\r\nif ((!address) || (type & ~ACPI_GPE_XRUPT_TYPE_MASK)) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nhandler = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_handler_info));\r\nif (!handler) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto free_and_exit;\r\n}\r\nif ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==\r\nACPI_GPE_DISPATCH_HANDLER) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto free_and_exit;\r\n}\r\nhandler->address = address;\r\nhandler->context = context;\r\nhandler->method_node = gpe_event_info->dispatch.method_node;\r\nhandler->original_flags = (u8)(gpe_event_info->flags &\r\n(ACPI_GPE_XRUPT_TYPE_MASK |\r\nACPI_GPE_DISPATCH_MASK));\r\nif ((handler->original_flags & ACPI_GPE_DISPATCH_METHOD)\r\n&& gpe_event_info->runtime_count) {\r\nhandler->originally_enabled = 1;\r\n(void)acpi_ev_remove_gpe_reference(gpe_event_info);\r\n}\r\ngpe_event_info->dispatch.handler = handler;\r\ngpe_event_info->flags &=\r\n~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);\r\ngpe_event_info->flags |= (u8) (type | ACPI_GPE_DISPATCH_HANDLER);\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\nfree_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nACPI_FREE(handler);\r\ngoto unlock_and_exit;\r\n}\r\nacpi_status\r\nacpi_remove_gpe_handler(acpi_handle gpe_device,\r\nu32 gpe_number, acpi_gpe_handler address)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nstruct acpi_gpe_handler_info *handler;\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_remove_gpe_handler);\r\nif (!address) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nacpi_os_wait_events_complete();\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) !=\r\nACPI_GPE_DISPATCH_HANDLER) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nif (gpe_event_info->dispatch.handler->address != address) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nhandler = gpe_event_info->dispatch.handler;\r\ngpe_event_info->dispatch.method_node = handler->method_node;\r\ngpe_event_info->flags &=\r\n~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);\r\ngpe_event_info->flags |= handler->original_flags;\r\nif ((handler->original_flags & ACPI_GPE_DISPATCH_METHOD) &&\r\nhandler->originally_enabled) {\r\n(void)acpi_ev_add_gpe_reference(gpe_event_info);\r\n}\r\nACPI_FREE(handler);\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_acquire_global_lock(u16 timeout, u32 * handle)\r\n{\r\nacpi_status status;\r\nif (!handle) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nacpi_ex_enter_interpreter();\r\nstatus = acpi_ex_acquire_mutex_object(timeout,\r\nacpi_gbl_global_lock_mutex,\r\nacpi_os_get_thread_id());\r\nif (ACPI_SUCCESS(status)) {\r\n*handle = acpi_gbl_global_lock_handle;\r\n}\r\nacpi_ex_exit_interpreter();\r\nreturn (status);\r\n}\r\nacpi_status acpi_release_global_lock(u32 handle)\r\n{\r\nacpi_status status;\r\nif (!handle || (handle != acpi_gbl_global_lock_handle)) {\r\nreturn (AE_NOT_ACQUIRED);\r\n}\r\nstatus = acpi_ex_release_mutex_object(acpi_gbl_global_lock_mutex);\r\nreturn (status);\r\n}
