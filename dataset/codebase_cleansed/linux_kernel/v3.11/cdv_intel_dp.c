static bool is_edp(struct psb_intel_encoder *encoder)\r\n{\r\nreturn encoder->type == INTEL_OUTPUT_EDP;\r\n}\r\nstatic int\r\ncdv_intel_dp_max_lane_count(struct psb_intel_encoder *encoder)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nint max_lane_count = 4;\r\nif (intel_dp->dpcd[DP_DPCD_REV] >= 0x11) {\r\nmax_lane_count = intel_dp->dpcd[DP_MAX_LANE_COUNT] & 0x1f;\r\nswitch (max_lane_count) {\r\ncase 1: case 2: case 4:\r\nbreak;\r\ndefault:\r\nmax_lane_count = 4;\r\n}\r\n}\r\nreturn max_lane_count;\r\n}\r\nstatic int\r\ncdv_intel_dp_max_link_bw(struct psb_intel_encoder *encoder)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nint max_link_bw = intel_dp->dpcd[DP_MAX_LINK_RATE];\r\nswitch (max_link_bw) {\r\ncase DP_LINK_BW_1_62:\r\ncase DP_LINK_BW_2_7:\r\nbreak;\r\ndefault:\r\nmax_link_bw = DP_LINK_BW_1_62;\r\nbreak;\r\n}\r\nreturn max_link_bw;\r\n}\r\nstatic int\r\ncdv_intel_dp_link_clock(uint8_t link_bw)\r\n{\r\nif (link_bw == DP_LINK_BW_2_7)\r\nreturn 270000;\r\nelse\r\nreturn 162000;\r\n}\r\nstatic int\r\ncdv_intel_dp_link_required(int pixel_clock, int bpp)\r\n{\r\nreturn (pixel_clock * bpp + 7) / 8;\r\n}\r\nstatic int\r\ncdv_intel_dp_max_data_rate(int max_link_clock, int max_lanes)\r\n{\r\nreturn (max_link_clock * max_lanes * 19) / 20;\r\n}\r\nstatic void cdv_intel_edp_panel_vdd_on(struct psb_intel_encoder *intel_encoder)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\r\nu32 pp;\r\nif (intel_dp->panel_on) {\r\nDRM_DEBUG_KMS("Skip VDD on because of panel on\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("\n");\r\npp = REG_READ(PP_CONTROL);\r\npp |= EDP_FORCE_VDD;\r\nREG_WRITE(PP_CONTROL, pp);\r\nREG_READ(PP_CONTROL);\r\nmsleep(intel_dp->panel_power_up_delay);\r\n}\r\nstatic void cdv_intel_edp_panel_vdd_off(struct psb_intel_encoder *intel_encoder)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nu32 pp;\r\nDRM_DEBUG_KMS("\n");\r\npp = REG_READ(PP_CONTROL);\r\npp &= ~EDP_FORCE_VDD;\r\nREG_WRITE(PP_CONTROL, pp);\r\nREG_READ(PP_CONTROL);\r\n}\r\nstatic bool cdv_intel_edp_panel_on(struct psb_intel_encoder *intel_encoder)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\r\nu32 pp, idle_on_mask = PP_ON | PP_SEQUENCE_NONE;\r\nif (intel_dp->panel_on)\r\nreturn true;\r\nDRM_DEBUG_KMS("\n");\r\npp = REG_READ(PP_CONTROL);\r\npp &= ~PANEL_UNLOCK_MASK;\r\npp |= (PANEL_UNLOCK_REGS | POWER_TARGET_ON);\r\nREG_WRITE(PP_CONTROL, pp);\r\nREG_READ(PP_CONTROL);\r\nif (wait_for(((REG_READ(PP_STATUS) & idle_on_mask) == idle_on_mask), 1000)) {\r\nDRM_DEBUG_KMS("Error in Powering up eDP panel, status %x\n", REG_READ(PP_STATUS));\r\nintel_dp->panel_on = false;\r\n} else\r\nintel_dp->panel_on = true;\r\nmsleep(intel_dp->panel_power_up_delay);\r\nreturn false;\r\n}\r\nstatic void cdv_intel_edp_panel_off (struct psb_intel_encoder *intel_encoder)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nu32 pp, idle_off_mask = PP_ON ;\r\nstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\r\nDRM_DEBUG_KMS("\n");\r\npp = REG_READ(PP_CONTROL);\r\nif ((pp & POWER_TARGET_ON) == 0)\r\nreturn;\r\nintel_dp->panel_on = false;\r\npp &= ~PANEL_UNLOCK_MASK;\r\npp &= ~POWER_TARGET_ON;\r\npp &= ~EDP_FORCE_VDD;\r\npp &= ~EDP_BLC_ENABLE;\r\nREG_WRITE(PP_CONTROL, pp);\r\nREG_READ(PP_CONTROL);\r\nDRM_DEBUG_KMS("PP_STATUS %x\n", REG_READ(PP_STATUS));\r\nif (wait_for((REG_READ(PP_STATUS) & idle_off_mask) == 0, 1000)) {\r\nDRM_DEBUG_KMS("Error in turning off Panel\n");\r\n}\r\nmsleep(intel_dp->panel_power_cycle_delay);\r\nDRM_DEBUG_KMS("Over\n");\r\n}\r\nstatic void cdv_intel_edp_backlight_on (struct psb_intel_encoder *intel_encoder)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nu32 pp;\r\nDRM_DEBUG_KMS("\n");\r\nmsleep(300);\r\npp = REG_READ(PP_CONTROL);\r\npp |= EDP_BLC_ENABLE;\r\nREG_WRITE(PP_CONTROL, pp);\r\ngma_backlight_enable(dev);\r\n}\r\nstatic void cdv_intel_edp_backlight_off (struct psb_intel_encoder *intel_encoder)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\r\nu32 pp;\r\nDRM_DEBUG_KMS("\n");\r\ngma_backlight_disable(dev);\r\nmsleep(10);\r\npp = REG_READ(PP_CONTROL);\r\npp &= ~EDP_BLC_ENABLE;\r\nREG_WRITE(PP_CONTROL, pp);\r\nmsleep(intel_dp->backlight_off_delay);\r\n}\r\nstatic int\r\ncdv_intel_dp_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct psb_intel_encoder *encoder = psb_intel_attached_encoder(connector);\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nint max_link_clock = cdv_intel_dp_link_clock(cdv_intel_dp_max_link_bw(encoder));\r\nint max_lanes = cdv_intel_dp_max_lane_count(encoder);\r\nstruct drm_psb_private *dev_priv = connector->dev->dev_private;\r\nif (is_edp(encoder) && intel_dp->panel_fixed_mode) {\r\nif (mode->hdisplay > intel_dp->panel_fixed_mode->hdisplay)\r\nreturn MODE_PANEL;\r\nif (mode->vdisplay > intel_dp->panel_fixed_mode->vdisplay)\r\nreturn MODE_PANEL;\r\n}\r\nif (!is_edp(encoder) &&\r\n(cdv_intel_dp_link_required(mode->clock, dev_priv->edp.bpp)\r\n> cdv_intel_dp_max_data_rate(max_link_clock, max_lanes)))\r\nreturn MODE_CLOCK_HIGH;\r\nif (is_edp(encoder)) {\r\nif (cdv_intel_dp_link_required(mode->clock, 24)\r\n> cdv_intel_dp_max_data_rate(max_link_clock, max_lanes))\r\nreturn MODE_CLOCK_HIGH;\r\n}\r\nif (mode->clock < 10000)\r\nreturn MODE_CLOCK_LOW;\r\nreturn MODE_OK;\r\n}\r\nstatic uint32_t\r\npack_aux(uint8_t *src, int src_bytes)\r\n{\r\nint i;\r\nuint32_t v = 0;\r\nif (src_bytes > 4)\r\nsrc_bytes = 4;\r\nfor (i = 0; i < src_bytes; i++)\r\nv |= ((uint32_t) src[i]) << ((3-i) * 8);\r\nreturn v;\r\n}\r\nstatic void\r\nunpack_aux(uint32_t src, uint8_t *dst, int dst_bytes)\r\n{\r\nint i;\r\nif (dst_bytes > 4)\r\ndst_bytes = 4;\r\nfor (i = 0; i < dst_bytes; i++)\r\ndst[i] = src >> ((3-i) * 8);\r\n}\r\nstatic int\r\ncdv_intel_dp_aux_ch(struct psb_intel_encoder *encoder,\r\nuint8_t *send, int send_bytes,\r\nuint8_t *recv, int recv_size)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nuint32_t output_reg = intel_dp->output_reg;\r\nstruct drm_device *dev = encoder->base.dev;\r\nuint32_t ch_ctl = output_reg + 0x10;\r\nuint32_t ch_data = ch_ctl + 4;\r\nint i;\r\nint recv_bytes;\r\nuint32_t status;\r\nuint32_t aux_clock_divider;\r\nint try, precharge;\r\naux_clock_divider = 200 / 2;\r\nprecharge = 4;\r\nif (is_edp(encoder))\r\nprecharge = 10;\r\nif (REG_READ(ch_ctl) & DP_AUX_CH_CTL_SEND_BUSY) {\r\nDRM_ERROR("dp_aux_ch not started status 0x%08x\n",\r\nREG_READ(ch_ctl));\r\nreturn -EBUSY;\r\n}\r\nfor (try = 0; try < 5; try++) {\r\nfor (i = 0; i < send_bytes; i += 4)\r\nREG_WRITE(ch_data + i,\r\npack_aux(send + i, send_bytes - i));\r\nREG_WRITE(ch_ctl,\r\nDP_AUX_CH_CTL_SEND_BUSY |\r\nDP_AUX_CH_CTL_TIME_OUT_400us |\r\n(send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |\r\n(precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |\r\n(aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT) |\r\nDP_AUX_CH_CTL_DONE |\r\nDP_AUX_CH_CTL_TIME_OUT_ERROR |\r\nDP_AUX_CH_CTL_RECEIVE_ERROR);\r\nfor (;;) {\r\nstatus = REG_READ(ch_ctl);\r\nif ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)\r\nbreak;\r\nudelay(100);\r\n}\r\nREG_WRITE(ch_ctl,\r\nstatus |\r\nDP_AUX_CH_CTL_DONE |\r\nDP_AUX_CH_CTL_TIME_OUT_ERROR |\r\nDP_AUX_CH_CTL_RECEIVE_ERROR);\r\nif (status & DP_AUX_CH_CTL_DONE)\r\nbreak;\r\n}\r\nif ((status & DP_AUX_CH_CTL_DONE) == 0) {\r\nDRM_ERROR("dp_aux_ch not done status 0x%08x\n", status);\r\nreturn -EBUSY;\r\n}\r\nif (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {\r\nDRM_ERROR("dp_aux_ch receive error status 0x%08x\n", status);\r\nreturn -EIO;\r\n}\r\nif (status & DP_AUX_CH_CTL_TIME_OUT_ERROR) {\r\nDRM_DEBUG_KMS("dp_aux_ch timeout status 0x%08x\n", status);\r\nreturn -ETIMEDOUT;\r\n}\r\nrecv_bytes = ((status & DP_AUX_CH_CTL_MESSAGE_SIZE_MASK) >>\r\nDP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT);\r\nif (recv_bytes > recv_size)\r\nrecv_bytes = recv_size;\r\nfor (i = 0; i < recv_bytes; i += 4)\r\nunpack_aux(REG_READ(ch_data + i),\r\nrecv + i, recv_bytes - i);\r\nreturn recv_bytes;\r\n}\r\nstatic int\r\ncdv_intel_dp_aux_native_write(struct psb_intel_encoder *encoder,\r\nuint16_t address, uint8_t *send, int send_bytes)\r\n{\r\nint ret;\r\nuint8_t msg[20];\r\nint msg_bytes;\r\nuint8_t ack;\r\nif (send_bytes > 16)\r\nreturn -1;\r\nmsg[0] = AUX_NATIVE_WRITE << 4;\r\nmsg[1] = address >> 8;\r\nmsg[2] = address & 0xff;\r\nmsg[3] = send_bytes - 1;\r\nmemcpy(&msg[4], send, send_bytes);\r\nmsg_bytes = send_bytes + 4;\r\nfor (;;) {\r\nret = cdv_intel_dp_aux_ch(encoder, msg, msg_bytes, &ack, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_ACK)\r\nbreak;\r\nelse if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_DEFER)\r\nudelay(100);\r\nelse\r\nreturn -EIO;\r\n}\r\nreturn send_bytes;\r\n}\r\nstatic int\r\ncdv_intel_dp_aux_native_write_1(struct psb_intel_encoder *encoder,\r\nuint16_t address, uint8_t byte)\r\n{\r\nreturn cdv_intel_dp_aux_native_write(encoder, address, &byte, 1);\r\n}\r\nstatic int\r\ncdv_intel_dp_aux_native_read(struct psb_intel_encoder *encoder,\r\nuint16_t address, uint8_t *recv, int recv_bytes)\r\n{\r\nuint8_t msg[4];\r\nint msg_bytes;\r\nuint8_t reply[20];\r\nint reply_bytes;\r\nuint8_t ack;\r\nint ret;\r\nmsg[0] = AUX_NATIVE_READ << 4;\r\nmsg[1] = address >> 8;\r\nmsg[2] = address & 0xff;\r\nmsg[3] = recv_bytes - 1;\r\nmsg_bytes = 4;\r\nreply_bytes = recv_bytes + 1;\r\nfor (;;) {\r\nret = cdv_intel_dp_aux_ch(encoder, msg, msg_bytes,\r\nreply, reply_bytes);\r\nif (ret == 0)\r\nreturn -EPROTO;\r\nif (ret < 0)\r\nreturn ret;\r\nack = reply[0];\r\nif ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_ACK) {\r\nmemcpy(recv, reply + 1, ret - 1);\r\nreturn ret - 1;\r\n}\r\nelse if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_DEFER)\r\nudelay(100);\r\nelse\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int\r\ncdv_intel_dp_i2c_aux_ch(struct i2c_adapter *adapter, int mode,\r\nuint8_t write_byte, uint8_t *read_byte)\r\n{\r\nstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\r\nstruct cdv_intel_dp *intel_dp = container_of(adapter,\r\nstruct cdv_intel_dp,\r\nadapter);\r\nstruct psb_intel_encoder *encoder = intel_dp->encoder;\r\nuint16_t address = algo_data->address;\r\nuint8_t msg[5];\r\nuint8_t reply[2];\r\nunsigned retry;\r\nint msg_bytes;\r\nint reply_bytes;\r\nint ret;\r\nif (mode & MODE_I2C_READ)\r\nmsg[0] = AUX_I2C_READ << 4;\r\nelse\r\nmsg[0] = AUX_I2C_WRITE << 4;\r\nif (!(mode & MODE_I2C_STOP))\r\nmsg[0] |= AUX_I2C_MOT << 4;\r\nmsg[1] = address >> 8;\r\nmsg[2] = address;\r\nswitch (mode) {\r\ncase MODE_I2C_WRITE:\r\nmsg[3] = 0;\r\nmsg[4] = write_byte;\r\nmsg_bytes = 5;\r\nreply_bytes = 1;\r\nbreak;\r\ncase MODE_I2C_READ:\r\nmsg[3] = 0;\r\nmsg_bytes = 4;\r\nreply_bytes = 2;\r\nbreak;\r\ndefault:\r\nmsg_bytes = 3;\r\nreply_bytes = 1;\r\nbreak;\r\n}\r\nfor (retry = 0; retry < 5; retry++) {\r\nret = cdv_intel_dp_aux_ch(encoder,\r\nmsg, msg_bytes,\r\nreply, reply_bytes);\r\nif (ret < 0) {\r\nDRM_DEBUG_KMS("aux_ch failed %d\n", ret);\r\nreturn ret;\r\n}\r\nswitch (reply[0] & AUX_NATIVE_REPLY_MASK) {\r\ncase AUX_NATIVE_REPLY_ACK:\r\nbreak;\r\ncase AUX_NATIVE_REPLY_NACK:\r\nDRM_DEBUG_KMS("aux_ch native nack\n");\r\nreturn -EREMOTEIO;\r\ncase AUX_NATIVE_REPLY_DEFER:\r\nudelay(100);\r\ncontinue;\r\ndefault:\r\nDRM_ERROR("aux_ch invalid native reply 0x%02x\n",\r\nreply[0]);\r\nreturn -EREMOTEIO;\r\n}\r\nswitch (reply[0] & AUX_I2C_REPLY_MASK) {\r\ncase AUX_I2C_REPLY_ACK:\r\nif (mode == MODE_I2C_READ) {\r\n*read_byte = reply[1];\r\n}\r\nreturn reply_bytes - 1;\r\ncase AUX_I2C_REPLY_NACK:\r\nDRM_DEBUG_KMS("aux_i2c nack\n");\r\nreturn -EREMOTEIO;\r\ncase AUX_I2C_REPLY_DEFER:\r\nDRM_DEBUG_KMS("aux_i2c defer\n");\r\nudelay(100);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("aux_i2c invalid reply 0x%02x\n", reply[0]);\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nDRM_ERROR("too many retries, giving up\n");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int\r\ncdv_intel_dp_i2c_init(struct psb_intel_connector *connector, struct psb_intel_encoder *encoder, const char *name)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nint ret;\r\nDRM_DEBUG_KMS("i2c_init %s\n", name);\r\nintel_dp->algo.running = false;\r\nintel_dp->algo.address = 0;\r\nintel_dp->algo.aux_ch = cdv_intel_dp_i2c_aux_ch;\r\nmemset(&intel_dp->adapter, '\0', sizeof (intel_dp->adapter));\r\nintel_dp->adapter.owner = THIS_MODULE;\r\nintel_dp->adapter.class = I2C_CLASS_DDC;\r\nstrncpy (intel_dp->adapter.name, name, sizeof(intel_dp->adapter.name) - 1);\r\nintel_dp->adapter.name[sizeof(intel_dp->adapter.name) - 1] = '\0';\r\nintel_dp->adapter.algo_data = &intel_dp->algo;\r\nintel_dp->adapter.dev.parent = &connector->base.kdev;\r\nif (is_edp(encoder))\r\ncdv_intel_edp_panel_vdd_on(encoder);\r\nret = i2c_dp_aux_add_bus(&intel_dp->adapter);\r\nif (is_edp(encoder))\r\ncdv_intel_edp_panel_vdd_off(encoder);\r\nreturn ret;\r\n}\r\nvoid cdv_intel_fixed_panel_mode(struct drm_display_mode *fixed_mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nadjusted_mode->hdisplay = fixed_mode->hdisplay;\r\nadjusted_mode->hsync_start = fixed_mode->hsync_start;\r\nadjusted_mode->hsync_end = fixed_mode->hsync_end;\r\nadjusted_mode->htotal = fixed_mode->htotal;\r\nadjusted_mode->vdisplay = fixed_mode->vdisplay;\r\nadjusted_mode->vsync_start = fixed_mode->vsync_start;\r\nadjusted_mode->vsync_end = fixed_mode->vsync_end;\r\nadjusted_mode->vtotal = fixed_mode->vtotal;\r\nadjusted_mode->clock = fixed_mode->clock;\r\ndrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\r\n}\r\nstatic bool\r\ncdv_intel_dp_mode_fixup(struct drm_encoder *encoder, const struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_psb_private *dev_priv = encoder->dev->dev_private;\r\nstruct psb_intel_encoder *intel_encoder = to_psb_intel_encoder(encoder);\r\nstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\r\nint lane_count, clock;\r\nint max_lane_count = cdv_intel_dp_max_lane_count(intel_encoder);\r\nint max_clock = cdv_intel_dp_max_link_bw(intel_encoder) == DP_LINK_BW_2_7 ? 1 : 0;\r\nstatic int bws[2] = { DP_LINK_BW_1_62, DP_LINK_BW_2_7 };\r\nint refclock = mode->clock;\r\nint bpp = 24;\r\nif (is_edp(intel_encoder) && intel_dp->panel_fixed_mode) {\r\ncdv_intel_fixed_panel_mode(intel_dp->panel_fixed_mode, adjusted_mode);\r\nrefclock = intel_dp->panel_fixed_mode->clock;\r\nbpp = dev_priv->edp.bpp;\r\n}\r\nfor (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {\r\nfor (clock = max_clock; clock >= 0; clock--) {\r\nint link_avail = cdv_intel_dp_max_data_rate(cdv_intel_dp_link_clock(bws[clock]), lane_count);\r\nif (cdv_intel_dp_link_required(refclock, bpp) <= link_avail) {\r\nintel_dp->link_bw = bws[clock];\r\nintel_dp->lane_count = lane_count;\r\nadjusted_mode->clock = cdv_intel_dp_link_clock(intel_dp->link_bw);\r\nDRM_DEBUG_KMS("Display port link bw %02x lane "\r\n"count %d clock %d\n",\r\nintel_dp->link_bw, intel_dp->lane_count,\r\nadjusted_mode->clock);\r\nreturn true;\r\n}\r\n}\r\n}\r\nif (is_edp(intel_encoder)) {\r\nintel_dp->lane_count = max_lane_count;\r\nintel_dp->link_bw = bws[max_clock];\r\nadjusted_mode->clock = cdv_intel_dp_link_clock(intel_dp->link_bw);\r\nDRM_DEBUG_KMS("Force picking display port link bw %02x lane "\r\n"count %d clock %d\n",\r\nintel_dp->link_bw, intel_dp->lane_count,\r\nadjusted_mode->clock);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\ncdv_intel_reduce_ratio(uint32_t *num, uint32_t *den)\r\n{\r\nuint64_t value, m;\r\nm = *num;\r\nvalue = m * (0x800000);\r\nm = do_div(value, *den);\r\n*num = value;\r\n*den = 0x800000;\r\n}\r\nstatic void\r\ncdv_intel_dp_compute_m_n(int bpp,\r\nint nlanes,\r\nint pixel_clock,\r\nint link_clock,\r\nstruct cdv_intel_dp_m_n *m_n)\r\n{\r\nm_n->tu = 64;\r\nm_n->gmch_m = (pixel_clock * bpp + 7) >> 3;\r\nm_n->gmch_n = link_clock * nlanes;\r\ncdv_intel_reduce_ratio(&m_n->gmch_m, &m_n->gmch_n);\r\nm_n->link_m = pixel_clock;\r\nm_n->link_n = link_clock;\r\ncdv_intel_reduce_ratio(&m_n->link_m, &m_n->link_n);\r\n}\r\nvoid\r\ncdv_intel_dp_set_m_n(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_encoder *encoder;\r\nstruct psb_intel_crtc *intel_crtc = to_psb_intel_crtc(crtc);\r\nint lane_count = 4, bpp = 24;\r\nstruct cdv_intel_dp_m_n m_n;\r\nint pipe = intel_crtc->pipe;\r\nlist_for_each_entry(encoder, &mode_config->encoder_list, head) {\r\nstruct psb_intel_encoder *intel_encoder;\r\nstruct cdv_intel_dp *intel_dp;\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nintel_encoder = to_psb_intel_encoder(encoder);\r\nintel_dp = intel_encoder->dev_priv;\r\nif (intel_encoder->type == INTEL_OUTPUT_DISPLAYPORT) {\r\nlane_count = intel_dp->lane_count;\r\nbreak;\r\n} else if (is_edp(intel_encoder)) {\r\nlane_count = intel_dp->lane_count;\r\nbpp = dev_priv->edp.bpp;\r\nbreak;\r\n}\r\n}\r\ncdv_intel_dp_compute_m_n(bpp, lane_count,\r\nmode->clock, adjusted_mode->clock, &m_n);\r\n{\r\nREG_WRITE(PIPE_GMCH_DATA_M(pipe),\r\n((m_n.tu - 1) << PIPE_GMCH_DATA_M_TU_SIZE_SHIFT) |\r\nm_n.gmch_m);\r\nREG_WRITE(PIPE_GMCH_DATA_N(pipe), m_n.gmch_n);\r\nREG_WRITE(PIPE_DP_LINK_M(pipe), m_n.link_m);\r\nREG_WRITE(PIPE_DP_LINK_N(pipe), m_n.link_n);\r\n}\r\n}\r\nstatic void\r\ncdv_intel_dp_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct psb_intel_encoder *intel_encoder = to_psb_intel_encoder(encoder);\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct psb_intel_crtc *intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\r\nstruct drm_device *dev = encoder->dev;\r\nintel_dp->DP = DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;\r\nintel_dp->DP |= intel_dp->color_range;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nintel_dp->DP |= DP_SYNC_HS_HIGH;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nintel_dp->DP |= DP_SYNC_VS_HIGH;\r\nintel_dp->DP |= DP_LINK_TRAIN_OFF;\r\nswitch (intel_dp->lane_count) {\r\ncase 1:\r\nintel_dp->DP |= DP_PORT_WIDTH_1;\r\nbreak;\r\ncase 2:\r\nintel_dp->DP |= DP_PORT_WIDTH_2;\r\nbreak;\r\ncase 4:\r\nintel_dp->DP |= DP_PORT_WIDTH_4;\r\nbreak;\r\n}\r\nif (intel_dp->has_audio)\r\nintel_dp->DP |= DP_AUDIO_OUTPUT_ENABLE;\r\nmemset(intel_dp->link_configuration, 0, DP_LINK_CONFIGURATION_SIZE);\r\nintel_dp->link_configuration[0] = intel_dp->link_bw;\r\nintel_dp->link_configuration[1] = intel_dp->lane_count;\r\nif (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&\r\n(intel_dp->dpcd[DP_MAX_LANE_COUNT] & DP_ENHANCED_FRAME_CAP)) {\r\nintel_dp->link_configuration[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\r\nintel_dp->DP |= DP_ENHANCED_FRAMING;\r\n}\r\nif (intel_crtc->pipe == 1)\r\nintel_dp->DP |= DP_PIPEB_SELECT;\r\nREG_WRITE(intel_dp->output_reg, (intel_dp->DP | DP_PORT_EN));\r\nDRM_DEBUG_KMS("DP expected reg is %x\n", intel_dp->DP);\r\nif (is_edp(intel_encoder)) {\r\nuint32_t pfit_control;\r\ncdv_intel_edp_panel_on(intel_encoder);\r\nif (mode->hdisplay != adjusted_mode->hdisplay ||\r\nmode->vdisplay != adjusted_mode->vdisplay)\r\npfit_control = PFIT_ENABLE;\r\nelse\r\npfit_control = 0;\r\npfit_control |= intel_crtc->pipe << PFIT_PIPE_SHIFT;\r\nREG_WRITE(PFIT_CONTROL, pfit_control);\r\n}\r\n}\r\nstatic void cdv_intel_dp_sink_dpms(struct psb_intel_encoder *encoder, int mode)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nint ret, i;\r\nif (intel_dp->dpcd[DP_DPCD_REV] < 0x11)\r\nreturn;\r\nif (mode != DRM_MODE_DPMS_ON) {\r\nret = cdv_intel_dp_aux_native_write_1(encoder, DP_SET_POWER,\r\nDP_SET_POWER_D3);\r\nif (ret != 1)\r\nDRM_DEBUG_DRIVER("failed to write sink power state\n");\r\n} else {\r\nfor (i = 0; i < 3; i++) {\r\nret = cdv_intel_dp_aux_native_write_1(encoder,\r\nDP_SET_POWER,\r\nDP_SET_POWER_D0);\r\nif (ret == 1)\r\nbreak;\r\nudelay(1000);\r\n}\r\n}\r\n}\r\nstatic void cdv_intel_dp_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct psb_intel_encoder *intel_encoder = to_psb_intel_encoder(encoder);\r\nint edp = is_edp(intel_encoder);\r\nif (edp) {\r\ncdv_intel_edp_backlight_off(intel_encoder);\r\ncdv_intel_edp_panel_off(intel_encoder);\r\ncdv_intel_edp_panel_vdd_on(intel_encoder);\r\n}\r\ncdv_intel_dp_sink_dpms(intel_encoder, DRM_MODE_DPMS_ON);\r\ncdv_intel_dp_link_down(intel_encoder);\r\nif (edp)\r\ncdv_intel_edp_panel_vdd_off(intel_encoder);\r\n}\r\nstatic void cdv_intel_dp_commit(struct drm_encoder *encoder)\r\n{\r\nstruct psb_intel_encoder *intel_encoder = to_psb_intel_encoder(encoder);\r\nint edp = is_edp(intel_encoder);\r\nif (edp)\r\ncdv_intel_edp_panel_on(intel_encoder);\r\ncdv_intel_dp_start_link_train(intel_encoder);\r\ncdv_intel_dp_complete_link_train(intel_encoder);\r\nif (edp)\r\ncdv_intel_edp_backlight_on(intel_encoder);\r\n}\r\nstatic void\r\ncdv_intel_dp_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct psb_intel_encoder *intel_encoder = to_psb_intel_encoder(encoder);\r\nstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\r\nstruct drm_device *dev = encoder->dev;\r\nuint32_t dp_reg = REG_READ(intel_dp->output_reg);\r\nint edp = is_edp(intel_encoder);\r\nif (mode != DRM_MODE_DPMS_ON) {\r\nif (edp) {\r\ncdv_intel_edp_backlight_off(intel_encoder);\r\ncdv_intel_edp_panel_vdd_on(intel_encoder);\r\n}\r\ncdv_intel_dp_sink_dpms(intel_encoder, mode);\r\ncdv_intel_dp_link_down(intel_encoder);\r\nif (edp) {\r\ncdv_intel_edp_panel_vdd_off(intel_encoder);\r\ncdv_intel_edp_panel_off(intel_encoder);\r\n}\r\n} else {\r\nif (edp)\r\ncdv_intel_edp_panel_on(intel_encoder);\r\ncdv_intel_dp_sink_dpms(intel_encoder, mode);\r\nif (!(dp_reg & DP_PORT_EN)) {\r\ncdv_intel_dp_start_link_train(intel_encoder);\r\ncdv_intel_dp_complete_link_train(intel_encoder);\r\n}\r\nif (edp)\r\ncdv_intel_edp_backlight_on(intel_encoder);\r\n}\r\n}\r\nstatic bool\r\ncdv_intel_dp_aux_native_read_retry(struct psb_intel_encoder *encoder, uint16_t address,\r\nuint8_t *recv, int recv_bytes)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < 3; i++) {\r\nret = cdv_intel_dp_aux_native_read(encoder, address, recv,\r\nrecv_bytes);\r\nif (ret == recv_bytes)\r\nreturn true;\r\nudelay(1000);\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\ncdv_intel_dp_get_link_status(struct psb_intel_encoder *encoder)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nreturn cdv_intel_dp_aux_native_read_retry(encoder,\r\nDP_LANE0_1_STATUS,\r\nintel_dp->link_status,\r\nDP_LINK_STATUS_SIZE);\r\n}\r\nstatic uint8_t\r\ncdv_intel_dp_link_status(uint8_t link_status[DP_LINK_STATUS_SIZE],\r\nint r)\r\n{\r\nreturn link_status[r - DP_LANE0_1_STATUS];\r\n}\r\nstatic uint8_t\r\ncdv_intel_get_adjust_request_voltage(uint8_t link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\r\nint s = ((lane & 1) ?\r\nDP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT :\r\nDP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT);\r\nuint8_t l = cdv_intel_dp_link_status(link_status, i);\r\nreturn ((l >> s) & 3) << DP_TRAIN_VOLTAGE_SWING_SHIFT;\r\n}\r\nstatic uint8_t\r\ncdv_intel_get_adjust_request_pre_emphasis(uint8_t link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\r\nint s = ((lane & 1) ?\r\nDP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT :\r\nDP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT);\r\nuint8_t l = cdv_intel_dp_link_status(link_status, i);\r\nreturn ((l >> s) & 3) << DP_TRAIN_PRE_EMPHASIS_SHIFT;\r\n}\r\nstatic void\r\ncdv_intel_get_adjust_train(struct psb_intel_encoder *encoder)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nuint8_t v = 0;\r\nuint8_t p = 0;\r\nint lane;\r\nfor (lane = 0; lane < intel_dp->lane_count; lane++) {\r\nuint8_t this_v = cdv_intel_get_adjust_request_voltage(intel_dp->link_status, lane);\r\nuint8_t this_p = cdv_intel_get_adjust_request_pre_emphasis(intel_dp->link_status, lane);\r\nif (this_v > v)\r\nv = this_v;\r\nif (this_p > p)\r\np = this_p;\r\n}\r\nif (v >= CDV_DP_VOLTAGE_MAX)\r\nv = CDV_DP_VOLTAGE_MAX | DP_TRAIN_MAX_SWING_REACHED;\r\nif (p == DP_TRAIN_PRE_EMPHASIS_MASK)\r\np |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\r\nfor (lane = 0; lane < 4; lane++)\r\nintel_dp->train_set[lane] = v | p;\r\n}\r\nstatic uint8_t\r\ncdv_intel_get_lane_status(uint8_t link_status[DP_LINK_STATUS_SIZE],\r\nint lane)\r\n{\r\nint i = DP_LANE0_1_STATUS + (lane >> 1);\r\nint s = (lane & 1) * 4;\r\nuint8_t l = cdv_intel_dp_link_status(link_status, i);\r\nreturn (l >> s) & 0xf;\r\n}\r\nstatic bool\r\ncdv_intel_clock_recovery_ok(uint8_t link_status[DP_LINK_STATUS_SIZE], int lane_count)\r\n{\r\nint lane;\r\nuint8_t lane_status;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nlane_status = cdv_intel_get_lane_status(link_status, lane);\r\nif ((lane_status & DP_LANE_CR_DONE) == 0)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\ncdv_intel_channel_eq_ok(struct psb_intel_encoder *encoder)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nuint8_t lane_align;\r\nuint8_t lane_status;\r\nint lane;\r\nlane_align = cdv_intel_dp_link_status(intel_dp->link_status,\r\nDP_LANE_ALIGN_STATUS_UPDATED);\r\nif ((lane_align & DP_INTERLANE_ALIGN_DONE) == 0)\r\nreturn false;\r\nfor (lane = 0; lane < intel_dp->lane_count; lane++) {\r\nlane_status = cdv_intel_get_lane_status(intel_dp->link_status, lane);\r\nif ((lane_status & CHANNEL_EQ_BITS) != CHANNEL_EQ_BITS)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\ncdv_intel_dp_set_link_train(struct psb_intel_encoder *encoder,\r\nuint32_t dp_reg_value,\r\nuint8_t dp_train_pat)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nint ret;\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nREG_WRITE(intel_dp->output_reg, dp_reg_value);\r\nREG_READ(intel_dp->output_reg);\r\nret = cdv_intel_dp_aux_native_write_1(encoder,\r\nDP_TRAINING_PATTERN_SET,\r\ndp_train_pat);\r\nif (ret != 1) {\r\nDRM_DEBUG_KMS("Failure in setting link pattern %x\n",\r\ndp_train_pat);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\ncdv_intel_dplink_set_level(struct psb_intel_encoder *encoder,\r\nuint8_t dp_train_pat)\r\n{\r\nint ret;\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nret = cdv_intel_dp_aux_native_write(encoder,\r\nDP_TRAINING_LANE0_SET,\r\nintel_dp->train_set,\r\nintel_dp->lane_count);\r\nif (ret != intel_dp->lane_count) {\r\nDRM_DEBUG_KMS("Failure in setting level %d, lane_cnt= %d\n",\r\nintel_dp->train_set[0], intel_dp->lane_count);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\ncdv_intel_dp_set_vswing_premph(struct psb_intel_encoder *encoder, uint8_t signal_level)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nstruct ddi_regoff *ddi_reg;\r\nint vswing, premph, index;\r\nif (intel_dp->output_reg == DP_B)\r\nddi_reg = &ddi_DP_train_table[0];\r\nelse\r\nddi_reg = &ddi_DP_train_table[1];\r\nvswing = (signal_level & DP_TRAIN_VOLTAGE_SWING_MASK);\r\npremph = ((signal_level & DP_TRAIN_PRE_EMPHASIS_MASK)) >>\r\nDP_TRAIN_PRE_EMPHASIS_SHIFT;\r\nif (vswing + premph > 3)\r\nreturn;\r\n#ifdef CDV_FAST_LINK_TRAIN\r\nreturn;\r\n#endif\r\nDRM_DEBUG_KMS("Test2\n");\r\ncdv_sb_reset(dev);\r\ncdv_sb_write(dev, ddi_reg->VSwing5, 0x0505313A);\r\ncdv_sb_write(dev, ddi_reg->VSwing1, 0x43406055);\r\nindex = (vswing + premph) * 2;\r\nif (premph == 1 && vswing == 1) {\r\ncdv_sb_write(dev, ddi_reg->VSwing2, 0x055738954);\r\n} else\r\ncdv_sb_write(dev, ddi_reg->VSwing2, dp_vswing_premph_table[index]);\r\nif ((vswing + premph) == DP_TRAIN_VOLTAGE_SWING_1200)\r\ncdv_sb_write(dev, ddi_reg->VSwing3, 0x70802040);\r\nelse\r\ncdv_sb_write(dev, ddi_reg->VSwing3, 0x40802040);\r\ncdv_sb_write(dev, ddi_reg->VSwing1, 0xc3406055);\r\ncdv_sb_write(dev, ddi_reg->PreEmph1, 0x1f030040);\r\nindex = 2 * premph + 1;\r\ncdv_sb_write(dev, ddi_reg->PreEmph2, dp_vswing_premph_table[index]);\r\nreturn;\r\n}\r\nstatic void\r\ncdv_intel_dp_start_link_train(struct psb_intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nint i;\r\nuint8_t voltage;\r\nbool clock_recovery = false;\r\nint tries;\r\nu32 reg;\r\nuint32_t DP = intel_dp->DP;\r\nDP |= DP_PORT_EN;\r\nDP &= ~DP_LINK_TRAIN_MASK;\r\nreg = DP;\r\nreg |= DP_LINK_TRAIN_PAT_1;\r\nREG_WRITE(intel_dp->output_reg, reg);\r\nREG_READ(intel_dp->output_reg);\r\npsb_intel_wait_for_vblank(dev);\r\nDRM_DEBUG_KMS("Link config\n");\r\ncdv_intel_dp_aux_native_write(encoder, DP_LINK_BW_SET,\r\nintel_dp->link_configuration,\r\n2);\r\nmemset(intel_dp->train_set, 0, 4);\r\nvoltage = 0;\r\ntries = 0;\r\nclock_recovery = false;\r\nDRM_DEBUG_KMS("Start train\n");\r\nreg = DP | DP_LINK_TRAIN_PAT_1;\r\nfor (;;) {\r\nDRM_DEBUG_KMS("DP Link Train Set %x, Link_config %x, %x\n",\r\nintel_dp->train_set[0],\r\nintel_dp->link_configuration[0],\r\nintel_dp->link_configuration[1]);\r\nif (!cdv_intel_dp_set_link_train(encoder, reg, DP_TRAINING_PATTERN_1)) {\r\nDRM_DEBUG_KMS("Failure in aux-transfer setting pattern 1\n");\r\n}\r\ncdv_intel_dp_set_vswing_premph(encoder, intel_dp->train_set[0]);\r\ncdv_intel_dplink_set_level(encoder, DP_TRAINING_PATTERN_1);\r\nudelay(200);\r\nif (!cdv_intel_dp_get_link_status(encoder))\r\nbreak;\r\nDRM_DEBUG_KMS("DP Link status %x, %x, %x, %x, %x, %x\n",\r\nintel_dp->link_status[0], intel_dp->link_status[1], intel_dp->link_status[2],\r\nintel_dp->link_status[3], intel_dp->link_status[4], intel_dp->link_status[5]);\r\nif (cdv_intel_clock_recovery_ok(intel_dp->link_status, intel_dp->lane_count)) {\r\nDRM_DEBUG_KMS("PT1 train is done\n");\r\nclock_recovery = true;\r\nbreak;\r\n}\r\nfor (i = 0; i < intel_dp->lane_count; i++)\r\nif ((intel_dp->train_set[i] & DP_TRAIN_MAX_SWING_REACHED) == 0)\r\nbreak;\r\nif (i == intel_dp->lane_count)\r\nbreak;\r\nif ((intel_dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK) == voltage) {\r\n++tries;\r\nif (tries == 5)\r\nbreak;\r\n} else\r\ntries = 0;\r\nvoltage = intel_dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\r\ncdv_intel_get_adjust_train(encoder);\r\n}\r\nif (!clock_recovery) {\r\nDRM_DEBUG_KMS("failure in DP patter 1 training, train set %x\n", intel_dp->train_set[0]);\r\n}\r\nintel_dp->DP = DP;\r\n}\r\nstatic void\r\ncdv_intel_dp_complete_link_train(struct psb_intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nbool channel_eq = false;\r\nint tries, cr_tries;\r\nu32 reg;\r\nuint32_t DP = intel_dp->DP;\r\ntries = 0;\r\ncr_tries = 0;\r\nchannel_eq = false;\r\nDRM_DEBUG_KMS("\n");\r\nreg = DP | DP_LINK_TRAIN_PAT_2;\r\nfor (;;) {\r\nDRM_DEBUG_KMS("DP Link Train Set %x, Link_config %x, %x\n",\r\nintel_dp->train_set[0],\r\nintel_dp->link_configuration[0],\r\nintel_dp->link_configuration[1]);\r\nif (!cdv_intel_dp_set_link_train(encoder, reg,\r\nDP_TRAINING_PATTERN_2)) {\r\nDRM_DEBUG_KMS("Failure in aux-transfer setting pattern 2\n");\r\n}\r\nif (cr_tries > 5) {\r\nDRM_ERROR("failed to train DP, aborting\n");\r\ncdv_intel_dp_link_down(encoder);\r\nbreak;\r\n}\r\ncdv_intel_dp_set_vswing_premph(encoder, intel_dp->train_set[0]);\r\ncdv_intel_dplink_set_level(encoder, DP_TRAINING_PATTERN_2);\r\nudelay(1000);\r\nif (!cdv_intel_dp_get_link_status(encoder))\r\nbreak;\r\nDRM_DEBUG_KMS("DP Link status %x, %x, %x, %x, %x, %x\n",\r\nintel_dp->link_status[0], intel_dp->link_status[1], intel_dp->link_status[2],\r\nintel_dp->link_status[3], intel_dp->link_status[4], intel_dp->link_status[5]);\r\nif (!cdv_intel_clock_recovery_ok(intel_dp->link_status, intel_dp->lane_count)) {\r\ncdv_intel_dp_start_link_train(encoder);\r\ncr_tries++;\r\ncontinue;\r\n}\r\nif (cdv_intel_channel_eq_ok(encoder)) {\r\nDRM_DEBUG_KMS("PT2 train is done\n");\r\nchannel_eq = true;\r\nbreak;\r\n}\r\nif (tries > 5) {\r\ncdv_intel_dp_link_down(encoder);\r\ncdv_intel_dp_start_link_train(encoder);\r\ntries = 0;\r\ncr_tries++;\r\ncontinue;\r\n}\r\ncdv_intel_get_adjust_train(encoder);\r\n++tries;\r\n}\r\nreg = DP | DP_LINK_TRAIN_OFF;\r\nREG_WRITE(intel_dp->output_reg, reg);\r\nREG_READ(intel_dp->output_reg);\r\ncdv_intel_dp_aux_native_write_1(encoder,\r\nDP_TRAINING_PATTERN_SET, DP_TRAINING_PATTERN_DISABLE);\r\n}\r\nstatic void\r\ncdv_intel_dp_link_down(struct psb_intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nuint32_t DP = intel_dp->DP;\r\nif ((REG_READ(intel_dp->output_reg) & DP_PORT_EN) == 0)\r\nreturn;\r\nDRM_DEBUG_KMS("\n");\r\n{\r\nDP &= ~DP_LINK_TRAIN_MASK;\r\nREG_WRITE(intel_dp->output_reg, DP | DP_LINK_TRAIN_PAT_IDLE);\r\n}\r\nREG_READ(intel_dp->output_reg);\r\nmsleep(17);\r\nREG_WRITE(intel_dp->output_reg, DP & ~DP_PORT_EN);\r\nREG_READ(intel_dp->output_reg);\r\n}\r\nstatic enum drm_connector_status\r\ncdv_dp_detect(struct psb_intel_encoder *encoder)\r\n{\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nenum drm_connector_status status;\r\nstatus = connector_status_disconnected;\r\nif (cdv_intel_dp_aux_native_read(encoder, 0x000, intel_dp->dpcd,\r\nsizeof (intel_dp->dpcd)) == sizeof (intel_dp->dpcd))\r\n{\r\nif (intel_dp->dpcd[DP_DPCD_REV] != 0)\r\nstatus = connector_status_connected;\r\n}\r\nif (status == connector_status_connected)\r\nDRM_DEBUG_KMS("DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\n",\r\nintel_dp->dpcd[0], intel_dp->dpcd[1],\r\nintel_dp->dpcd[2], intel_dp->dpcd[3]);\r\nreturn status;\r\n}\r\nstatic enum drm_connector_status\r\ncdv_intel_dp_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct psb_intel_encoder *encoder = psb_intel_attached_encoder(connector);\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nenum drm_connector_status status;\r\nstruct edid *edid = NULL;\r\nint edp = is_edp(encoder);\r\nintel_dp->has_audio = false;\r\nif (edp)\r\ncdv_intel_edp_panel_vdd_on(encoder);\r\nstatus = cdv_dp_detect(encoder);\r\nif (status != connector_status_connected) {\r\nif (edp)\r\ncdv_intel_edp_panel_vdd_off(encoder);\r\nreturn status;\r\n}\r\nif (intel_dp->force_audio) {\r\nintel_dp->has_audio = intel_dp->force_audio > 0;\r\n} else {\r\nedid = drm_get_edid(connector, &intel_dp->adapter);\r\nif (edid) {\r\nintel_dp->has_audio = drm_detect_monitor_audio(edid);\r\nkfree(edid);\r\n}\r\n}\r\nif (edp)\r\ncdv_intel_edp_panel_vdd_off(encoder);\r\nreturn connector_status_connected;\r\n}\r\nstatic int cdv_intel_dp_get_modes(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_encoder *intel_encoder = psb_intel_attached_encoder(connector);\r\nstruct cdv_intel_dp *intel_dp = intel_encoder->dev_priv;\r\nstruct edid *edid = NULL;\r\nint ret = 0;\r\nint edp = is_edp(intel_encoder);\r\nedid = drm_get_edid(connector, &intel_dp->adapter);\r\nif (edid) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nif (is_edp(intel_encoder)) {\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\ncdv_intel_edp_panel_vdd_off(intel_encoder);\r\nif (ret) {\r\nif (edp && !intel_dp->panel_fixed_mode) {\r\nstruct drm_display_mode *newmode;\r\nlist_for_each_entry(newmode, &connector->probed_modes,\r\nhead) {\r\nif (newmode->type & DRM_MODE_TYPE_PREFERRED) {\r\nintel_dp->panel_fixed_mode =\r\ndrm_mode_duplicate(dev, newmode);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nif (!intel_dp->panel_fixed_mode && dev_priv->lfp_lvds_vbt_mode) {\r\nintel_dp->panel_fixed_mode =\r\ndrm_mode_duplicate(dev, dev_priv->lfp_lvds_vbt_mode);\r\nif (intel_dp->panel_fixed_mode) {\r\nintel_dp->panel_fixed_mode->type |=\r\nDRM_MODE_TYPE_PREFERRED;\r\n}\r\n}\r\nif (intel_dp->panel_fixed_mode != NULL) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(dev, intel_dp->panel_fixed_mode);\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic bool\r\ncdv_intel_dp_detect_audio(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_encoder *encoder = psb_intel_attached_encoder(connector);\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nstruct edid *edid;\r\nbool has_audio = false;\r\nint edp = is_edp(encoder);\r\nif (edp)\r\ncdv_intel_edp_panel_vdd_on(encoder);\r\nedid = drm_get_edid(connector, &intel_dp->adapter);\r\nif (edid) {\r\nhas_audio = drm_detect_monitor_audio(edid);\r\nkfree(edid);\r\n}\r\nif (edp)\r\ncdv_intel_edp_panel_vdd_off(encoder);\r\nreturn has_audio;\r\n}\r\nstatic int\r\ncdv_intel_dp_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_psb_private *dev_priv = connector->dev->dev_private;\r\nstruct psb_intel_encoder *encoder = psb_intel_attached_encoder(connector);\r\nstruct cdv_intel_dp *intel_dp = encoder->dev_priv;\r\nint ret;\r\nret = drm_object_property_set_value(&connector->base, property, val);\r\nif (ret)\r\nreturn ret;\r\nif (property == dev_priv->force_audio_property) {\r\nint i = val;\r\nbool has_audio;\r\nif (i == intel_dp->force_audio)\r\nreturn 0;\r\nintel_dp->force_audio = i;\r\nif (i == 0)\r\nhas_audio = cdv_intel_dp_detect_audio(connector);\r\nelse\r\nhas_audio = i > 0;\r\nif (has_audio == intel_dp->has_audio)\r\nreturn 0;\r\nintel_dp->has_audio = has_audio;\r\ngoto done;\r\n}\r\nif (property == dev_priv->broadcast_rgb_property) {\r\nif (val == !!intel_dp->color_range)\r\nreturn 0;\r\nintel_dp->color_range = val ? DP_COLOR_RANGE_16_235 : 0;\r\ngoto done;\r\n}\r\nreturn -EINVAL;\r\ndone:\r\nif (encoder->base.crtc) {\r\nstruct drm_crtc *crtc = encoder->base.crtc;\r\ndrm_crtc_helper_set_mode(crtc, &crtc->mode,\r\ncrtc->x, crtc->y,\r\ncrtc->fb);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncdv_intel_dp_destroy(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_encoder *psb_intel_encoder =\r\npsb_intel_attached_encoder(connector);\r\nstruct cdv_intel_dp *intel_dp = psb_intel_encoder->dev_priv;\r\nif (is_edp(psb_intel_encoder)) {\r\nif (intel_dp->panel_fixed_mode) {\r\nkfree(intel_dp->panel_fixed_mode);\r\nintel_dp->panel_fixed_mode = NULL;\r\n}\r\n}\r\ni2c_del_adapter(&intel_dp->adapter);\r\ndrm_sysfs_connector_remove(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic void cdv_intel_dp_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic void cdv_intel_dp_add_properties(struct drm_connector *connector)\r\n{\r\ncdv_intel_attach_force_audio_property(connector);\r\ncdv_intel_attach_broadcast_rgb_property(connector);\r\n}\r\nstatic bool cdv_intel_dpc_is_edp(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct child_device_config *p_child;\r\nint i;\r\nif (!dev_priv->child_dev_num)\r\nreturn false;\r\nfor (i = 0; i < dev_priv->child_dev_num; i++) {\r\np_child = dev_priv->child_dev + i;\r\nif (p_child->dvo_port == PORT_IDPC &&\r\np_child->device_type == DEVICE_TYPE_eDP)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void cdv_disable_intel_clock_gating(struct drm_device *dev)\r\n{\r\nu32 reg_value;\r\nreg_value = REG_READ(DSPCLK_GATE_D);\r\nreg_value |= (DPUNIT_PIPEB_GATE_DISABLE |\r\nDPUNIT_PIPEA_GATE_DISABLE |\r\nDPCUNIT_CLOCK_GATE_DISABLE |\r\nDPLSUNIT_CLOCK_GATE_DISABLE |\r\nDPOUNIT_CLOCK_GATE_DISABLE |\r\nDPIOUNIT_CLOCK_GATE_DISABLE);\r\nREG_WRITE(DSPCLK_GATE_D, reg_value);\r\nudelay(500);\r\n}\r\nvoid\r\ncdv_intel_dp_init(struct drm_device *dev, struct psb_intel_mode_device *mode_dev, int output_reg)\r\n{\r\nstruct psb_intel_encoder *psb_intel_encoder;\r\nstruct psb_intel_connector *psb_intel_connector;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct cdv_intel_dp *intel_dp;\r\nconst char *name = NULL;\r\nint type = DRM_MODE_CONNECTOR_DisplayPort;\r\npsb_intel_encoder = kzalloc(sizeof(struct psb_intel_encoder), GFP_KERNEL);\r\nif (!psb_intel_encoder)\r\nreturn;\r\npsb_intel_connector = kzalloc(sizeof(struct psb_intel_connector), GFP_KERNEL);\r\nif (!psb_intel_connector)\r\ngoto err_connector;\r\nintel_dp = kzalloc(sizeof(struct cdv_intel_dp), GFP_KERNEL);\r\nif (!intel_dp)\r\ngoto err_priv;\r\nif ((output_reg == DP_C) && cdv_intel_dpc_is_edp(dev))\r\ntype = DRM_MODE_CONNECTOR_eDP;\r\nconnector = &psb_intel_connector->base;\r\nencoder = &psb_intel_encoder->base;\r\ndrm_connector_init(dev, connector, &cdv_intel_dp_connector_funcs, type);\r\ndrm_encoder_init(dev, encoder, &cdv_intel_dp_enc_funcs, DRM_MODE_ENCODER_TMDS);\r\npsb_intel_connector_attach_encoder(psb_intel_connector, psb_intel_encoder);\r\nif (type == DRM_MODE_CONNECTOR_DisplayPort)\r\npsb_intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;\r\nelse\r\npsb_intel_encoder->type = INTEL_OUTPUT_EDP;\r\npsb_intel_encoder->dev_priv=intel_dp;\r\nintel_dp->encoder = psb_intel_encoder;\r\nintel_dp->output_reg = output_reg;\r\ndrm_encoder_helper_add(encoder, &cdv_intel_dp_helper_funcs);\r\ndrm_connector_helper_add(connector, &cdv_intel_dp_connector_helper_funcs);\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\ndrm_sysfs_connector_add(connector);\r\nswitch (output_reg) {\r\ncase DP_B:\r\nname = "DPDDC-B";\r\npsb_intel_encoder->ddi_select = (DP_MASK | DDI0_SELECT);\r\nbreak;\r\ncase DP_C:\r\nname = "DPDDC-C";\r\npsb_intel_encoder->ddi_select = (DP_MASK | DDI1_SELECT);\r\nbreak;\r\n}\r\ncdv_disable_intel_clock_gating(dev);\r\ncdv_intel_dp_i2c_init(psb_intel_connector, psb_intel_encoder, name);\r\ncdv_intel_dp_add_properties(connector);\r\nif (is_edp(psb_intel_encoder)) {\r\nint ret;\r\nstruct edp_power_seq cur;\r\nu32 pp_on, pp_off, pp_div;\r\nu32 pwm_ctrl;\r\npp_on = REG_READ(PP_CONTROL);\r\npp_on &= ~PANEL_UNLOCK_MASK;\r\npp_on |= PANEL_UNLOCK_REGS;\r\nREG_WRITE(PP_CONTROL, pp_on);\r\npwm_ctrl = REG_READ(BLC_PWM_CTL2);\r\npwm_ctrl |= PWM_PIPE_B;\r\nREG_WRITE(BLC_PWM_CTL2, pwm_ctrl);\r\npp_on = REG_READ(PP_ON_DELAYS);\r\npp_off = REG_READ(PP_OFF_DELAYS);\r\npp_div = REG_READ(PP_DIVISOR);\r\ncur.t1_t3 = (pp_on & PANEL_POWER_UP_DELAY_MASK) >>\r\nPANEL_POWER_UP_DELAY_SHIFT;\r\ncur.t8 = (pp_on & PANEL_LIGHT_ON_DELAY_MASK) >>\r\nPANEL_LIGHT_ON_DELAY_SHIFT;\r\ncur.t9 = (pp_off & PANEL_LIGHT_OFF_DELAY_MASK) >>\r\nPANEL_LIGHT_OFF_DELAY_SHIFT;\r\ncur.t10 = (pp_off & PANEL_POWER_DOWN_DELAY_MASK) >>\r\nPANEL_POWER_DOWN_DELAY_SHIFT;\r\ncur.t11_t12 = ((pp_div & PANEL_POWER_CYCLE_DELAY_MASK) >>\r\nPANEL_POWER_CYCLE_DELAY_SHIFT);\r\nDRM_DEBUG_KMS("cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",\r\ncur.t1_t3, cur.t8, cur.t9, cur.t10, cur.t11_t12);\r\nintel_dp->panel_power_up_delay = cur.t1_t3 / 10;\r\nintel_dp->backlight_on_delay = cur.t8 / 10;\r\nintel_dp->backlight_off_delay = cur.t9 / 10;\r\nintel_dp->panel_power_down_delay = cur.t10 / 10;\r\nintel_dp->panel_power_cycle_delay = (cur.t11_t12 - 1) * 100;\r\nDRM_DEBUG_KMS("panel power up delay %d, power down delay %d, power cycle delay %d\n",\r\nintel_dp->panel_power_up_delay, intel_dp->panel_power_down_delay,\r\nintel_dp->panel_power_cycle_delay);\r\nDRM_DEBUG_KMS("backlight on delay %d, off delay %d\n",\r\nintel_dp->backlight_on_delay, intel_dp->backlight_off_delay);\r\ncdv_intel_edp_panel_vdd_on(psb_intel_encoder);\r\nret = cdv_intel_dp_aux_native_read(psb_intel_encoder, DP_DPCD_REV,\r\nintel_dp->dpcd,\r\nsizeof(intel_dp->dpcd));\r\ncdv_intel_edp_panel_vdd_off(psb_intel_encoder);\r\nif (ret == 0) {\r\nDRM_INFO("failed to retrieve link info, disabling eDP\n");\r\ncdv_intel_dp_encoder_destroy(encoder);\r\ncdv_intel_dp_destroy(connector);\r\ngoto err_priv;\r\n} else {\r\nDRM_DEBUG_KMS("DPCD: Rev=%x LN_Rate=%x LN_CNT=%x LN_DOWNSP=%x\n",\r\nintel_dp->dpcd[0], intel_dp->dpcd[1],\r\nintel_dp->dpcd[2], intel_dp->dpcd[3]);\r\n}\r\n}\r\nreturn;\r\nerr_priv:\r\nkfree(psb_intel_connector);\r\nerr_connector:\r\nkfree(psb_intel_encoder);\r\n}
