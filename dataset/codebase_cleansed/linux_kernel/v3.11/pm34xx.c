static void omap3_core_save_context(void)\r\n{\r\nomap3_ctrl_save_padconf();\r\nomap_ctrl_writel(omap_ctrl_readl(OMAP343X_PADCONF_ETK_D14),\r\nOMAP343X_CONTROL_MEM_WKUP + 0x2a0);\r\nomap_intc_save_context();\r\nomap3_gpmc_save_context();\r\nomap3_control_save_context();\r\nomap_dma_global_context_save();\r\n}\r\nstatic void omap3_core_restore_context(void)\r\n{\r\nomap3_control_restore_context();\r\nomap3_gpmc_restore_context();\r\nomap_intc_restore_context();\r\nomap_dma_global_context_restore();\r\n}\r\nstatic void omap3_save_secure_ram_context(void)\r\n{\r\nu32 ret;\r\nint mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);\r\nif (omap_type() != OMAP2_DEVICE_TYPE_GP) {\r\npwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);\r\nret = _omap_save_secure_sram((u32 *)\r\n__pa(omap3_secure_ram_storage));\r\npwrdm_set_next_pwrst(mpu_pwrdm, mpu_next_state);\r\nif (ret) {\r\npr_err("save_secure_sram() returns %08x\n", ret);\r\nwhile (1)\r\n;\r\n}\r\n}\r\n}\r\nstatic int prcm_clear_mod_irqs(s16 module, u8 regs, u32 ignore_bits)\r\n{\r\nu32 wkst, fclk, iclk, clken;\r\nu16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;\r\nu16 fclk_off = (regs == 3) ? OMAP3430ES2_CM_FCLKEN3 : CM_FCLKEN1;\r\nu16 iclk_off = (regs == 3) ? CM_ICLKEN3 : CM_ICLKEN1;\r\nu16 grpsel_off = (regs == 3) ?\r\nOMAP3430ES2_PM_MPUGRPSEL3 : OMAP3430_PM_MPUGRPSEL;\r\nint c = 0;\r\nwkst = omap2_prm_read_mod_reg(module, wkst_off);\r\nwkst &= omap2_prm_read_mod_reg(module, grpsel_off);\r\nwkst &= ~ignore_bits;\r\nif (wkst) {\r\niclk = omap2_cm_read_mod_reg(module, iclk_off);\r\nfclk = omap2_cm_read_mod_reg(module, fclk_off);\r\nwhile (wkst) {\r\nclken = wkst;\r\nomap2_cm_set_mod_reg_bits(clken, module, iclk_off);\r\nif (module == OMAP3430ES2_USBHOST_MOD)\r\nclken |= 1 << OMAP3430ES2_EN_USBHOST2_SHIFT;\r\nomap2_cm_set_mod_reg_bits(clken, module, fclk_off);\r\nomap2_prm_write_mod_reg(wkst, module, wkst_off);\r\nwkst = omap2_prm_read_mod_reg(module, wkst_off);\r\nwkst &= ~ignore_bits;\r\nc++;\r\n}\r\nomap2_cm_write_mod_reg(iclk, module, iclk_off);\r\nomap2_cm_write_mod_reg(fclk, module, fclk_off);\r\n}\r\nreturn c;\r\n}\r\nstatic irqreturn_t _prcm_int_handle_io(int irq, void *unused)\r\n{\r\nint c;\r\nc = prcm_clear_mod_irqs(WKUP_MOD, 1,\r\n~(OMAP3430_ST_IO_MASK | OMAP3430_ST_IO_CHAIN_MASK));\r\nreturn c ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic irqreturn_t _prcm_int_handle_wakeup(int irq, void *unused)\r\n{\r\nint c;\r\nc = prcm_clear_mod_irqs(WKUP_MOD, 1,\r\nOMAP3430_ST_IO_MASK | OMAP3430_ST_IO_CHAIN_MASK);\r\nc += prcm_clear_mod_irqs(CORE_MOD, 1, 0);\r\nc += prcm_clear_mod_irqs(OMAP3430_PER_MOD, 1, 0);\r\nif (omap_rev() > OMAP3430_REV_ES1_0) {\r\nc += prcm_clear_mod_irqs(CORE_MOD, 3, 0);\r\nc += prcm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1, 0);\r\n}\r\nreturn c ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void omap34xx_save_context(u32 *save)\r\n{\r\nu32 val;\r\nasm("mrc p15, 0, %0, c1, c0, 1" : "=r" (val));\r\n*save++ = 1;\r\n*save++ = val;\r\nasm("mrc p15, 1, %0, c9, c0, 2" : "=r" (val));\r\n*save++ = 1;\r\n*save++ = val;\r\n}\r\nstatic int omap34xx_do_sram_idle(unsigned long save_state)\r\n{\r\nomap34xx_cpu_suspend(save_state);\r\nreturn 0;\r\n}\r\nvoid omap_sram_idle(void)\r\n{\r\nint save_state = 0;\r\nint mpu_next_state = PWRDM_POWER_ON;\r\nint per_next_state = PWRDM_POWER_ON;\r\nint core_next_state = PWRDM_POWER_ON;\r\nint per_going_off;\r\nint core_prev_state;\r\nu32 sdrc_pwr = 0;\r\nmpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);\r\nswitch (mpu_next_state) {\r\ncase PWRDM_POWER_ON:\r\ncase PWRDM_POWER_RET:\r\nsave_state = 0;\r\nbreak;\r\ncase PWRDM_POWER_OFF:\r\nsave_state = 3;\r\nbreak;\r\ndefault:\r\npr_err("Invalid mpu state in sram_idle\n");\r\nreturn;\r\n}\r\nif (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)\r\npwrdm_set_next_pwrst(neon_pwrdm, mpu_next_state);\r\nper_next_state = pwrdm_read_next_pwrst(per_pwrdm);\r\ncore_next_state = pwrdm_read_next_pwrst(core_pwrdm);\r\npwrdm_pre_transition(NULL);\r\nif (per_next_state < PWRDM_POWER_ON) {\r\nper_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;\r\nomap2_gpio_prepare_for_idle(per_going_off);\r\n}\r\nif (core_next_state < PWRDM_POWER_ON) {\r\nif (core_next_state == PWRDM_POWER_OFF) {\r\nomap3_core_save_context();\r\nomap3_cm_save_context();\r\n}\r\n}\r\nomap3_intc_prepare_idle();\r\nif (cpu_is_omap3430() && omap_rev() >= OMAP3430_REV_ES3_0 &&\r\n(omap_type() == OMAP2_DEVICE_TYPE_EMU ||\r\nomap_type() == OMAP2_DEVICE_TYPE_SEC) &&\r\ncore_next_state == PWRDM_POWER_OFF)\r\nsdrc_pwr = sdrc_read_reg(SDRC_POWER);\r\nif (save_state)\r\nomap34xx_save_context(omap3_arm_context);\r\nif (save_state == 1 || save_state == 3)\r\ncpu_suspend(save_state, omap34xx_do_sram_idle);\r\nelse\r\nomap34xx_do_sram_idle(save_state);\r\nif (cpu_is_omap3430() && omap_rev() >= OMAP3430_REV_ES3_0 &&\r\n(omap_type() == OMAP2_DEVICE_TYPE_EMU ||\r\nomap_type() == OMAP2_DEVICE_TYPE_SEC) &&\r\ncore_next_state == PWRDM_POWER_OFF)\r\nsdrc_write_reg(sdrc_pwr, SDRC_POWER);\r\nif (core_next_state < PWRDM_POWER_ON) {\r\ncore_prev_state = pwrdm_read_prev_pwrst(core_pwrdm);\r\nif (core_prev_state == PWRDM_POWER_OFF) {\r\nomap3_core_restore_context();\r\nomap3_cm_restore_context();\r\nomap3_sram_restore_context();\r\nomap2_sms_restore_context();\r\n}\r\nif (core_next_state == PWRDM_POWER_OFF)\r\nomap2_prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF_MASK,\r\nOMAP3430_GR_MOD,\r\nOMAP3_PRM_VOLTCTRL_OFFSET);\r\n}\r\nomap3_intc_resume_idle();\r\npwrdm_post_transition(NULL);\r\nif (per_next_state < PWRDM_POWER_ON)\r\nomap2_gpio_resume_after_idle();\r\n}\r\nstatic void omap3_pm_idle(void)\r\n{\r\nif (omap_irq_pending())\r\nreturn;\r\ntrace_cpu_idle(1, smp_processor_id());\r\nomap_sram_idle();\r\ntrace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());\r\n}\r\nstatic int omap3_pm_suspend(void)\r\n{\r\nstruct power_state *pwrst;\r\nint state, ret = 0;\r\nlist_for_each_entry(pwrst, &pwrst_list, node)\r\npwrst->saved_state = pwrdm_read_next_pwrst(pwrst->pwrdm);\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nif (omap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state))\r\ngoto restore;\r\nif (pwrdm_clear_all_prev_pwrst(pwrst->pwrdm))\r\ngoto restore;\r\n}\r\nomap3_intc_suspend();\r\nomap_sram_idle();\r\nrestore:\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nstate = pwrdm_read_prev_pwrst(pwrst->pwrdm);\r\nif (state > pwrst->next_state) {\r\npr_info("Powerdomain (%s) didn't enter target state %d\n",\r\npwrst->pwrdm->name, pwrst->next_state);\r\nret = -1;\r\n}\r\nomap_set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);\r\n}\r\nif (ret)\r\npr_err("Could not enter target state in pm_suspend\n");\r\nelse\r\npr_info("Successfully put all powerdomains to target state\n");\r\nreturn ret;\r\n}\r\nstatic void __init omap3_iva_idle(void)\r\n{\r\nomap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);\r\nif (!(omap2_cm_read_mod_reg(OMAP3430_IVA2_MOD, OMAP3430_CM_CLKSTST) &\r\nOMAP3430_CLKACTIVITY_IVA2_MASK))\r\nreturn;\r\nomap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |\r\nOMAP3430_RST2_IVA2_MASK |\r\nOMAP3430_RST3_IVA2_MASK,\r\nOMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);\r\nomap2_cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2_MASK,\r\nOMAP3430_IVA2_MOD, CM_FCLKEN);\r\nomap_ctrl_writel(OMAP3_IVA2_BOOTMOD_IDLE,\r\nOMAP343X_CONTROL_IVA2_BOOTMOD);\r\nomap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);\r\nomap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);\r\nomap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |\r\nOMAP3430_RST2_IVA2_MASK |\r\nOMAP3430_RST3_IVA2_MASK,\r\nOMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);\r\n}\r\nstatic void __init omap3_d2d_idle(void)\r\n{\r\nu16 mask, padconf;\r\nmask = (1 << 4) | (1 << 3);\r\npadconf = omap_ctrl_readw(OMAP3_PADCONF_SAD2D_MSTANDBY);\r\npadconf |= mask;\r\nomap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_MSTANDBY);\r\npadconf = omap_ctrl_readw(OMAP3_PADCONF_SAD2D_IDLEACK);\r\npadconf |= mask;\r\nomap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_IDLEACK);\r\nomap2_prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON_MASK |\r\nOMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST_MASK,\r\nCORE_MOD, OMAP2_RM_RSTCTRL);\r\nomap2_prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);\r\n}\r\nstatic void __init prcm_setup_regs(void)\r\n{\r\nu32 omap3630_en_uart4_mask = cpu_is_omap3630() ?\r\nOMAP3630_EN_UART4_MASK : 0;\r\nu32 omap3630_grpsel_uart4_mask = cpu_is_omap3630() ?\r\nOMAP3630_GRPSEL_UART4_MASK : 0;\r\nomap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);\r\nomap2_prm_rmw_mod_reg_bits(OMAP_AUTOEXTCLKMODE_MASK,\r\n1 << OMAP_AUTOEXTCLKMODE_SHIFT,\r\nOMAP3430_GR_MOD,\r\nOMAP3_PRM_CLKSRC_CTRL_OFFSET);\r\nomap2_prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1_MASK |\r\nOMAP3430_EN_GPT1_MASK | OMAP3430_EN_GPT12_MASK,\r\nWKUP_MOD, PM_WKEN);\r\nomap2_prm_write_mod_reg(OMAP3430_GRPSEL_GPIO1_MASK |\r\nOMAP3430_GRPSEL_GPT1_MASK |\r\nOMAP3430_GRPSEL_GPT12_MASK,\r\nWKUP_MOD, OMAP3430_PM_MPUGRPSEL);\r\nomap2_prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS_MASK,\r\nOMAP3430_DSS_MOD, PM_WKEN);\r\nomap2_prm_write_mod_reg(omap3630_en_uart4_mask |\r\nOMAP3430_EN_GPIO2_MASK | OMAP3430_EN_GPIO3_MASK |\r\nOMAP3430_EN_GPIO4_MASK | OMAP3430_EN_GPIO5_MASK |\r\nOMAP3430_EN_GPIO6_MASK | OMAP3430_EN_UART3_MASK |\r\nOMAP3430_EN_MCBSP2_MASK | OMAP3430_EN_MCBSP3_MASK |\r\nOMAP3430_EN_MCBSP4_MASK,\r\nOMAP3430_PER_MOD, PM_WKEN);\r\nomap2_prm_write_mod_reg(omap3630_grpsel_uart4_mask |\r\nOMAP3430_GRPSEL_GPIO2_MASK |\r\nOMAP3430_GRPSEL_GPIO3_MASK |\r\nOMAP3430_GRPSEL_GPIO4_MASK |\r\nOMAP3430_GRPSEL_GPIO5_MASK |\r\nOMAP3430_GRPSEL_GPIO6_MASK |\r\nOMAP3430_GRPSEL_UART3_MASK |\r\nOMAP3430_GRPSEL_MCBSP2_MASK |\r\nOMAP3430_GRPSEL_MCBSP3_MASK |\r\nOMAP3430_GRPSEL_MCBSP4_MASK,\r\nOMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);\r\nif (omap3_has_iva()) {\r\nomap2_prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);\r\nomap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);\r\nomap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);\r\nomap2_prm_write_mod_reg(0, OMAP3430_PER_MOD,\r\nOMAP3430_PM_IVAGRPSEL);\r\n}\r\nomap2_prm_write_mod_reg(0xffffffff, MPU_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, OMAP2_RM_RSTST);\r\nomap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);\r\nomap3_iva_idle();\r\nomap3_d2d_idle();\r\n}\r\nvoid omap3_pm_off_mode_enable(int enable)\r\n{\r\nstruct power_state *pwrst;\r\nu32 state;\r\nif (enable)\r\nstate = PWRDM_POWER_OFF;\r\nelse\r\nstate = PWRDM_POWER_RET;\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nif (IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583) &&\r\npwrst->pwrdm == core_pwrdm &&\r\nstate == PWRDM_POWER_OFF) {\r\npwrst->next_state = PWRDM_POWER_RET;\r\npr_warn("%s: Core OFF disabled due to errata i583\n",\r\n__func__);\r\n} else {\r\npwrst->next_state = state;\r\n}\r\nomap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);\r\n}\r\n}\r\nint omap3_pm_get_suspend_state(struct powerdomain *pwrdm)\r\n{\r\nstruct power_state *pwrst;\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nif (pwrst->pwrdm == pwrdm)\r\nreturn pwrst->next_state;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint omap3_pm_set_suspend_state(struct powerdomain *pwrdm, int state)\r\n{\r\nstruct power_state *pwrst;\r\nlist_for_each_entry(pwrst, &pwrst_list, node) {\r\nif (pwrst->pwrdm == pwrdm) {\r\npwrst->next_state = state;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)\r\n{\r\nstruct power_state *pwrst;\r\nif (!pwrdm->pwrsts)\r\nreturn 0;\r\npwrst = kmalloc(sizeof(struct power_state), GFP_ATOMIC);\r\nif (!pwrst)\r\nreturn -ENOMEM;\r\npwrst->pwrdm = pwrdm;\r\npwrst->next_state = PWRDM_POWER_RET;\r\nlist_add(&pwrst->node, &pwrst_list);\r\nif (pwrdm_has_hdwr_sar(pwrdm))\r\npwrdm_enable_hdwr_sar(pwrdm);\r\nreturn omap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);\r\n}\r\nvoid omap_push_sram_idle(void)\r\n{\r\nomap3_do_wfi_sram = omap_sram_push(omap3_do_wfi, omap3_do_wfi_sz);\r\nif (omap_type() != OMAP2_DEVICE_TYPE_GP)\r\n_omap_save_secure_sram = omap_sram_push(save_secure_ram_context,\r\nsave_secure_ram_context_sz);\r\n}\r\nstatic void __init pm_errata_configure(void)\r\n{\r\nif (cpu_is_omap3630()) {\r\npm34xx_errata |= PM_RTA_ERRATUM_i608;\r\nenable_omap3630_toggle_l2_on_restore();\r\nif (omap_rev() < OMAP3630_REV_ES1_2)\r\npm34xx_errata |= (PM_SDRC_WAKEUP_ERRATUM_i583 |\r\nPM_PER_MEMORIES_ERRATUM_i582);\r\n} else if (cpu_is_omap34xx()) {\r\npm34xx_errata |= PM_PER_MEMORIES_ERRATUM_i582;\r\n}\r\n}\r\nint __init omap3_pm_init(void)\r\n{\r\nstruct power_state *pwrst, *tmp;\r\nstruct clockdomain *neon_clkdm, *mpu_clkdm, *per_clkdm, *wkup_clkdm;\r\nint ret;\r\nif (!omap3_has_io_chain_ctrl())\r\npr_warning("PM: no software I/O chain control; some wakeups may be lost\n");\r\npm_errata_configure();\r\nprcm_setup_regs();\r\nret = request_irq(omap_prcm_event_to_irq("wkup"),\r\n_prcm_int_handle_wakeup, IRQF_NO_SUSPEND, "pm_wkup", NULL);\r\nif (ret) {\r\npr_err("pm: Failed to request pm_wkup irq\n");\r\ngoto err1;\r\n}\r\nret = request_irq(omap_prcm_event_to_irq("io"),\r\n_prcm_int_handle_io, IRQF_SHARED | IRQF_NO_SUSPEND, "pm_io",\r\nomap3_pm_init);\r\nenable_irq(omap_prcm_event_to_irq("io"));\r\nif (ret) {\r\npr_err("pm: Failed to request pm_io irq\n");\r\ngoto err2;\r\n}\r\nret = pwrdm_for_each(pwrdms_setup, NULL);\r\nif (ret) {\r\npr_err("Failed to setup powerdomains\n");\r\ngoto err3;\r\n}\r\n(void) clkdm_for_each(omap_pm_clkdms_setup, NULL);\r\nmpu_pwrdm = pwrdm_lookup("mpu_pwrdm");\r\nif (mpu_pwrdm == NULL) {\r\npr_err("Failed to get mpu_pwrdm\n");\r\nret = -EINVAL;\r\ngoto err3;\r\n}\r\nneon_pwrdm = pwrdm_lookup("neon_pwrdm");\r\nper_pwrdm = pwrdm_lookup("per_pwrdm");\r\ncore_pwrdm = pwrdm_lookup("core_pwrdm");\r\nneon_clkdm = clkdm_lookup("neon_clkdm");\r\nmpu_clkdm = clkdm_lookup("mpu_clkdm");\r\nper_clkdm = clkdm_lookup("per_clkdm");\r\nwkup_clkdm = clkdm_lookup("wkup_clkdm");\r\n#ifdef CONFIG_SUSPEND\r\nomap_pm_suspend = omap3_pm_suspend;\r\n#endif\r\narm_pm_idle = omap3_pm_idle;\r\nomap3_idle_init();\r\nif (IS_PM34XX_ERRATUM(PM_RTA_ERRATUM_i608))\r\nomap3630_ctrl_disable_rta();\r\nif (IS_PM34XX_ERRATUM(PM_PER_MEMORIES_ERRATUM_i582))\r\nclkdm_add_wkdep(per_clkdm, wkup_clkdm);\r\nclkdm_add_wkdep(neon_clkdm, mpu_clkdm);\r\nif (omap_type() != OMAP2_DEVICE_TYPE_GP) {\r\nomap3_secure_ram_storage =\r\nkmalloc(0x803F, GFP_KERNEL);\r\nif (!omap3_secure_ram_storage)\r\npr_err("Memory allocation failed when allocating for secure sram context\n");\r\nlocal_irq_disable();\r\nomap_dma_global_context_save();\r\nomap3_save_secure_ram_context();\r\nomap_dma_global_context_restore();\r\nlocal_irq_enable();\r\n}\r\nomap3_save_scratchpad_contents();\r\nreturn ret;\r\nerr3:\r\nlist_for_each_entry_safe(pwrst, tmp, &pwrst_list, node) {\r\nlist_del(&pwrst->node);\r\nkfree(pwrst);\r\n}\r\nfree_irq(omap_prcm_event_to_irq("io"), omap3_pm_init);\r\nerr2:\r\nfree_irq(omap_prcm_event_to_irq("wkup"), NULL);\r\nerr1:\r\nreturn ret;\r\n}
