static inline struct s2255_dev *to_s2255_dev(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn container_of(v4l2_dev, struct s2255_dev, v4l2_dev);\r\n}\r\nstatic int norm_maxw(struct s2255_channel *channel)\r\n{\r\nreturn (channel->std & V4L2_STD_525_60) ?\r\nLINE_SZ_4CIFS_NTSC : LINE_SZ_4CIFS_PAL;\r\n}\r\nstatic int norm_maxh(struct s2255_channel *channel)\r\n{\r\nreturn (channel->std & V4L2_STD_525_60) ?\r\n(NUM_LINES_1CIFS_NTSC * 2) : (NUM_LINES_1CIFS_PAL * 2);\r\n}\r\nstatic int norm_minw(struct s2255_channel *channel)\r\n{\r\nreturn (channel->std & V4L2_STD_525_60) ?\r\nLINE_SZ_1CIFS_NTSC : LINE_SZ_1CIFS_PAL;\r\n}\r\nstatic int norm_minh(struct s2255_channel *channel)\r\n{\r\nreturn (channel->std & V4L2_STD_525_60) ?\r\n(NUM_LINES_1CIFS_NTSC) : (NUM_LINES_1CIFS_PAL);\r\n}\r\nstatic void planar422p_to_yuv_packed(const unsigned char *in,\r\nunsigned char *out,\r\nint width, int height,\r\nint fmt)\r\n{\r\nunsigned char *pY;\r\nunsigned char *pCb;\r\nunsigned char *pCr;\r\nunsigned long size = height * width;\r\nunsigned int i;\r\npY = (unsigned char *)in;\r\npCr = (unsigned char *)in + height * width;\r\npCb = (unsigned char *)in + height * width + (height * width / 2);\r\nfor (i = 0; i < size * 2; i += 4) {\r\nout[i] = (fmt == V4L2_PIX_FMT_YUYV) ? *pY++ : *pCr++;\r\nout[i + 1] = (fmt == V4L2_PIX_FMT_YUYV) ? *pCr++ : *pY++;\r\nout[i + 2] = (fmt == V4L2_PIX_FMT_YUYV) ? *pY++ : *pCb++;\r\nout[i + 3] = (fmt == V4L2_PIX_FMT_YUYV) ? *pCb++ : *pY++;\r\n}\r\nreturn;\r\n}\r\nstatic void s2255_reset_dsppower(struct s2255_dev *dev)\r\n{\r\ns2255_vendor_req(dev, 0x40, 0x0000, 0x0001, NULL, 0, 1);\r\nmsleep(10);\r\ns2255_vendor_req(dev, 0x50, 0x0000, 0x0000, NULL, 0, 1);\r\nmsleep(600);\r\ns2255_vendor_req(dev, 0x10, 0x0000, 0x0000, NULL, 0, 1);\r\nreturn;\r\n}\r\nstatic void s2255_timer(unsigned long user_data)\r\n{\r\nstruct s2255_fw *data = (struct s2255_fw *)user_data;\r\ndprintk(100, "%s\n", __func__);\r\nif (usb_submit_urb(data->fw_urb, GFP_ATOMIC) < 0) {\r\nprintk(KERN_ERR "s2255: can't submit urb\n");\r\natomic_set(&data->fw_state, S2255_FW_FAILED);\r\nwake_up(&data->wait_fw);\r\nreturn;\r\n}\r\n}\r\nstatic void s2255_fwchunk_complete(struct urb *urb)\r\n{\r\nstruct s2255_fw *data = urb->context;\r\nstruct usb_device *udev = urb->dev;\r\nint len;\r\ndprintk(100, "%s: udev %p urb %p", __func__, udev, urb);\r\nif (urb->status) {\r\ndev_err(&udev->dev, "URB failed with status %d\n", urb->status);\r\natomic_set(&data->fw_state, S2255_FW_FAILED);\r\nwake_up(&data->wait_fw);\r\nreturn;\r\n}\r\nif (data->fw_urb == NULL) {\r\ns2255_dev_err(&udev->dev, "disconnected\n");\r\natomic_set(&data->fw_state, S2255_FW_FAILED);\r\nwake_up(&data->wait_fw);\r\nreturn;\r\n}\r\n#define CHUNK_SIZE 512\r\nif (data->fw_loaded < data->fw_size) {\r\nlen = (data->fw_loaded + CHUNK_SIZE) > data->fw_size ?\r\ndata->fw_size % CHUNK_SIZE : CHUNK_SIZE;\r\nif (len < CHUNK_SIZE)\r\nmemset(data->pfw_data, 0, CHUNK_SIZE);\r\ndprintk(100, "completed len %d, loaded %d \n", len,\r\ndata->fw_loaded);\r\nmemcpy(data->pfw_data,\r\n(char *) data->fw->data + data->fw_loaded, len);\r\nusb_fill_bulk_urb(data->fw_urb, udev, usb_sndbulkpipe(udev, 2),\r\ndata->pfw_data, CHUNK_SIZE,\r\ns2255_fwchunk_complete, data);\r\nif (usb_submit_urb(data->fw_urb, GFP_ATOMIC) < 0) {\r\ndev_err(&udev->dev, "failed submit URB\n");\r\natomic_set(&data->fw_state, S2255_FW_FAILED);\r\nwake_up(&data->wait_fw);\r\nreturn;\r\n}\r\ndata->fw_loaded += len;\r\n} else {\r\natomic_set(&data->fw_state, S2255_FW_LOADED_DSPWAIT);\r\ndprintk(100, "%s: firmware upload complete\n", __func__);\r\n}\r\nreturn;\r\n}\r\nstatic int s2255_got_frame(struct s2255_channel *channel, int jpgsize)\r\n{\r\nstruct s2255_dmaqueue *dma_q = &channel->vidq;\r\nstruct s2255_buffer *buf;\r\nstruct s2255_dev *dev = to_s2255_dev(channel->vdev.v4l2_dev);\r\nunsigned long flags = 0;\r\nint rc = 0;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (list_empty(&dma_q->active)) {\r\ndprintk(1, "No active queue to serve\n");\r\nrc = -1;\r\ngoto unlock;\r\n}\r\nbuf = list_entry(dma_q->active.next,\r\nstruct s2255_buffer, vb.queue);\r\nlist_del(&buf->vb.queue);\r\nv4l2_get_timestamp(&buf->vb.ts);\r\ns2255_fillbuff(channel, buf, jpgsize);\r\nwake_up(&buf->vb.done);\r\ndprintk(2, "%s: [buf/i] [%p/%d]\n", __func__, buf, buf->vb.i);\r\nunlock:\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn rc;\r\n}\r\nstatic const struct s2255_fmt *format_by_fourcc(int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++) {\r\nif (-1 == formats[i].fourcc)\r\ncontinue;\r\nif (!jpeg_enable && ((formats[i].fourcc == V4L2_PIX_FMT_JPEG) ||\r\n(formats[i].fourcc == V4L2_PIX_FMT_MJPEG)))\r\ncontinue;\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats + i;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void s2255_fillbuff(struct s2255_channel *channel,\r\nstruct s2255_buffer *buf, int jpgsize)\r\n{\r\nint pos = 0;\r\nconst char *tmpbuf;\r\nchar *vbuf = videobuf_to_vmalloc(&buf->vb);\r\nunsigned long last_frame;\r\nif (!vbuf)\r\nreturn;\r\nlast_frame = channel->last_frame;\r\nif (last_frame != -1) {\r\ntmpbuf =\r\n(const char *)channel->buffer.frame[last_frame].lpvbits;\r\nswitch (buf->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\nplanar422p_to_yuv_packed((const unsigned char *)tmpbuf,\r\nvbuf, buf->vb.width,\r\nbuf->vb.height,\r\nbuf->fmt->fourcc);\r\nbreak;\r\ncase V4L2_PIX_FMT_GREY:\r\nmemcpy(vbuf, tmpbuf, buf->vb.width * buf->vb.height);\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\ncase V4L2_PIX_FMT_MJPEG:\r\nbuf->vb.size = jpgsize;\r\nmemcpy(vbuf, tmpbuf, buf->vb.size);\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\nmemcpy(vbuf, tmpbuf,\r\nbuf->vb.width * buf->vb.height * 2);\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "s2255: unknown format?\n");\r\n}\r\nchannel->last_frame = -1;\r\n} else {\r\nprintk(KERN_ERR "s2255: =======no frame\n");\r\nreturn;\r\n}\r\ndprintk(2, "s2255fill at : Buffer 0x%08lx size= %d\n",\r\n(unsigned long)vbuf, pos);\r\nbuf->vb.field_count = channel->frame_count * 2;\r\nv4l2_get_timestamp(&buf->vb.ts);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\n}\r\nstatic int buffer_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct s2255_fh *fh = vq->priv_data;\r\nstruct s2255_channel *channel = fh->channel;\r\n*size = channel->width * channel->height * (channel->fmt->depth >> 3);\r\nif (0 == *count)\r\n*count = S2255_DEF_BUFS;\r\nif (*size * *count > vid_limit * 1024 * 1024)\r\n*count = (vid_limit * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct s2255_buffer *buf)\r\n{\r\ndprintk(4, "%s\n", __func__);\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct s2255_fh *fh = vq->priv_data;\r\nstruct s2255_channel *channel = fh->channel;\r\nstruct s2255_buffer *buf = container_of(vb, struct s2255_buffer, vb);\r\nint rc;\r\nint w = channel->width;\r\nint h = channel->height;\r\ndprintk(4, "%s, field=%d\n", __func__, field);\r\nif (channel->fmt == NULL)\r\nreturn -EINVAL;\r\nif ((w < norm_minw(channel)) ||\r\n(w > norm_maxw(channel)) ||\r\n(h < norm_minh(channel)) ||\r\n(h > norm_maxh(channel))) {\r\ndprintk(4, "invalid buffer prepare\n");\r\nreturn -EINVAL;\r\n}\r\nbuf->vb.size = w * h * (channel->fmt->depth >> 3);\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size) {\r\ndprintk(4, "invalid buffer prepare\n");\r\nreturn -EINVAL;\r\n}\r\nbuf->fmt = channel->fmt;\r\nbuf->vb.width = w;\r\nbuf->vb.height = h;\r\nbuf->vb.field = field;\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct s2255_buffer *buf = container_of(vb, struct s2255_buffer, vb);\r\nstruct s2255_fh *fh = vq->priv_data;\r\nstruct s2255_channel *channel = fh->channel;\r\nstruct s2255_dmaqueue *vidq = &channel->vidq;\r\ndprintk(1, "%s\n", __func__);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct s2255_buffer *buf = container_of(vb, struct s2255_buffer, vb);\r\nstruct s2255_fh *fh = vq->priv_data;\r\ndprintk(4, "%s %d\n", __func__, fh->channel->idx);\r\nfree_buffer(vq, buf);\r\n}\r\nstatic int res_get(struct s2255_fh *fh)\r\n{\r\nstruct s2255_channel *channel = fh->channel;\r\nif (channel->resources)\r\nreturn 0;\r\nchannel->resources = 1;\r\nfh->resources = 1;\r\ndprintk(1, "s2255: res: get\n");\r\nreturn 1;\r\n}\r\nstatic int res_locked(struct s2255_fh *fh)\r\n{\r\nreturn fh->channel->resources;\r\n}\r\nstatic int res_check(struct s2255_fh *fh)\r\n{\r\nreturn fh->resources;\r\n}\r\nstatic void res_free(struct s2255_fh *fh)\r\n{\r\nstruct s2255_channel *channel = fh->channel;\r\nchannel->resources = 0;\r\nfh->resources = 0;\r\ndprintk(1, "res: put\n");\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct s2255_fh *fh = file->private_data;\r\nstruct s2255_dev *dev = fh->dev;\r\nstrlcpy(cap->driver, "s2255", sizeof(cap->driver));\r\nstrlcpy(cap->card, "s2255", sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nint index = f->index;\r\nif (index >= ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nif (!jpeg_enable && ((formats[index].fourcc == V4L2_PIX_FMT_JPEG) ||\r\n(formats[index].fourcc == V4L2_PIX_FMT_MJPEG)))\r\nreturn -EINVAL;\r\ndprintk(4, "name %s\n", formats[index].name);\r\nstrlcpy(f->description, formats[index].name, sizeof(f->description));\r\nf->pixelformat = formats[index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_channel *channel = fh->channel;\r\nint is_ntsc = channel->std & V4L2_STD_525_60;\r\nf->fmt.pix.width = channel->width;\r\nf->fmt.pix.height = channel->height;\r\nif (f->fmt.pix.height >=\r\n(is_ntsc ? NUM_LINES_1CIFS_NTSC : NUM_LINES_1CIFS_PAL) * 2)\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nelse\r\nf->fmt.pix.field = V4L2_FIELD_TOP;\r\nf->fmt.pix.pixelformat = channel->fmt->fourcc;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * (channel->fmt->depth >> 3);\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nconst struct s2255_fmt *fmt;\r\nenum v4l2_field field;\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_channel *channel = fh->channel;\r\nint is_ntsc = channel->std & V4L2_STD_525_60;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\ndprintk(50, "%s NTSC: %d suggested width: %d, height: %d\n",\r\n__func__, is_ntsc, f->fmt.pix.width, f->fmt.pix.height);\r\nif (is_ntsc) {\r\nif (f->fmt.pix.height >= NUM_LINES_1CIFS_NTSC * 2) {\r\nf->fmt.pix.height = NUM_LINES_1CIFS_NTSC * 2;\r\nfield = V4L2_FIELD_INTERLACED;\r\n} else {\r\nf->fmt.pix.height = NUM_LINES_1CIFS_NTSC;\r\nfield = V4L2_FIELD_TOP;\r\n}\r\nif (f->fmt.pix.width >= LINE_SZ_4CIFS_NTSC)\r\nf->fmt.pix.width = LINE_SZ_4CIFS_NTSC;\r\nelse if (f->fmt.pix.width >= LINE_SZ_2CIFS_NTSC)\r\nf->fmt.pix.width = LINE_SZ_2CIFS_NTSC;\r\nelse if (f->fmt.pix.width >= LINE_SZ_1CIFS_NTSC)\r\nf->fmt.pix.width = LINE_SZ_1CIFS_NTSC;\r\nelse\r\nf->fmt.pix.width = LINE_SZ_1CIFS_NTSC;\r\n} else {\r\nif (f->fmt.pix.height >= NUM_LINES_1CIFS_PAL * 2) {\r\nf->fmt.pix.height = NUM_LINES_1CIFS_PAL * 2;\r\nfield = V4L2_FIELD_INTERLACED;\r\n} else {\r\nf->fmt.pix.height = NUM_LINES_1CIFS_PAL;\r\nfield = V4L2_FIELD_TOP;\r\n}\r\nif (f->fmt.pix.width >= LINE_SZ_4CIFS_PAL)\r\nf->fmt.pix.width = LINE_SZ_4CIFS_PAL;\r\nelse if (f->fmt.pix.width >= LINE_SZ_2CIFS_PAL)\r\nf->fmt.pix.width = LINE_SZ_2CIFS_PAL;\r\nelse if (f->fmt.pix.width >= LINE_SZ_1CIFS_PAL)\r\nf->fmt.pix.width = LINE_SZ_1CIFS_PAL;\r\nelse\r\nf->fmt.pix.width = LINE_SZ_1CIFS_PAL;\r\n}\r\nf->fmt.pix.field = field;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\ndprintk(50, "%s: set width %d height %d field %d\n", __func__,\r\nf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_channel *channel = fh->channel;\r\nconst struct s2255_fmt *fmt;\r\nstruct videobuf_queue *q = &fh->vb_vidq;\r\nstruct s2255_mode mode;\r\nint ret;\r\nret = vidioc_try_fmt_vid_cap(file, fh, f);\r\nif (ret < 0)\r\nreturn ret;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&q->vb_lock);\r\nif (videobuf_queue_is_busy(&fh->vb_vidq)) {\r\ndprintk(1, "queue busy\n");\r\nret = -EBUSY;\r\ngoto out_s_fmt;\r\n}\r\nif (res_locked(fh)) {\r\ndprintk(1, "%s: channel busy\n", __func__);\r\nret = -EBUSY;\r\ngoto out_s_fmt;\r\n}\r\nmode = channel->mode;\r\nchannel->fmt = fmt;\r\nchannel->width = f->fmt.pix.width;\r\nchannel->height = f->fmt.pix.height;\r\nfh->vb_vidq.field = f->fmt.pix.field;\r\nfh->type = f->type;\r\nif (channel->width > norm_minw(channel)) {\r\nif (channel->height > norm_minh(channel)) {\r\nif (channel->cap_parm.capturemode &\r\nV4L2_MODE_HIGHQUALITY)\r\nmode.scale = SCALE_4CIFSI;\r\nelse\r\nmode.scale = SCALE_4CIFS;\r\n} else\r\nmode.scale = SCALE_2CIFS;\r\n} else {\r\nmode.scale = SCALE_1CIFS;\r\n}\r\nswitch (channel->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_GREY:\r\nmode.color &= ~MASK_COLOR;\r\nmode.color |= COLOR_Y8;\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\ncase V4L2_PIX_FMT_MJPEG:\r\nmode.color &= ~MASK_COLOR;\r\nmode.color |= COLOR_JPG;\r\nmode.color |= (channel->jpegqual << 8);\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\nmode.color &= ~MASK_COLOR;\r\nmode.color |= COLOR_YUVPL;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\ndefault:\r\nmode.color &= ~MASK_COLOR;\r\nmode.color |= COLOR_YUVPK;\r\nbreak;\r\n}\r\nif ((mode.color & MASK_COLOR) != (channel->mode.color & MASK_COLOR))\r\nmode.restart = 1;\r\nelse if (mode.scale != channel->mode.scale)\r\nmode.restart = 1;\r\nelse if (mode.format != channel->mode.format)\r\nmode.restart = 1;\r\nchannel->mode = mode;\r\n(void) s2255_set_mode(channel, &mode);\r\nret = 0;\r\nout_s_fmt:\r\nmutex_unlock(&q->vb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nint rc;\r\nstruct s2255_fh *fh = priv;\r\nrc = videobuf_reqbufs(&fh->vb_vidq, p);\r\nreturn rc;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct s2255_fh *fh = priv;\r\nrc = videobuf_querybuf(&fh->vb_vidq, p);\r\nreturn rc;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct s2255_fh *fh = priv;\r\nrc = videobuf_qbuf(&fh->vb_vidq, p);\r\nreturn rc;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct s2255_fh *fh = priv;\r\nrc = videobuf_dqbuf(&fh->vb_vidq, p, file->f_flags & O_NONBLOCK);\r\nreturn rc;\r\n}\r\nstatic int s2255_write_config(struct usb_device *udev, unsigned char *pbuf,\r\nint size)\r\n{\r\nint pipe;\r\nint done;\r\nlong retval = -1;\r\nif (udev) {\r\npipe = usb_sndbulkpipe(udev, S2255_CONFIG_EP);\r\nretval = usb_bulk_msg(udev, pipe, pbuf, size, &done, 500);\r\n}\r\nreturn retval;\r\n}\r\nstatic u32 get_transfer_size(struct s2255_mode *mode)\r\n{\r\nint linesPerFrame = LINE_SZ_DEF;\r\nint pixelsPerLine = NUM_LINES_DEF;\r\nu32 outImageSize;\r\nu32 usbInSize;\r\nunsigned int mask_mult;\r\nif (mode == NULL)\r\nreturn 0;\r\nif (mode->format == FORMAT_NTSC) {\r\nswitch (mode->scale) {\r\ncase SCALE_4CIFS:\r\ncase SCALE_4CIFSI:\r\nlinesPerFrame = NUM_LINES_4CIFS_NTSC * 2;\r\npixelsPerLine = LINE_SZ_4CIFS_NTSC;\r\nbreak;\r\ncase SCALE_2CIFS:\r\nlinesPerFrame = NUM_LINES_2CIFS_NTSC;\r\npixelsPerLine = LINE_SZ_2CIFS_NTSC;\r\nbreak;\r\ncase SCALE_1CIFS:\r\nlinesPerFrame = NUM_LINES_1CIFS_NTSC;\r\npixelsPerLine = LINE_SZ_1CIFS_NTSC;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if (mode->format == FORMAT_PAL) {\r\nswitch (mode->scale) {\r\ncase SCALE_4CIFS:\r\ncase SCALE_4CIFSI:\r\nlinesPerFrame = NUM_LINES_4CIFS_PAL * 2;\r\npixelsPerLine = LINE_SZ_4CIFS_PAL;\r\nbreak;\r\ncase SCALE_2CIFS:\r\nlinesPerFrame = NUM_LINES_2CIFS_PAL;\r\npixelsPerLine = LINE_SZ_2CIFS_PAL;\r\nbreak;\r\ncase SCALE_1CIFS:\r\nlinesPerFrame = NUM_LINES_1CIFS_PAL;\r\npixelsPerLine = LINE_SZ_1CIFS_PAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\noutImageSize = linesPerFrame * pixelsPerLine;\r\nif ((mode->color & MASK_COLOR) != COLOR_Y8) {\r\noutImageSize *= 2;\r\n}\r\nusbInSize = outImageSize + PREFIX_SIZE;\r\nmask_mult = 0xffffffffUL - DEF_USB_BLOCK + 1;\r\nif (usbInSize & ~mask_mult)\r\nusbInSize = (usbInSize & mask_mult) + (DEF_USB_BLOCK);\r\nreturn usbInSize;\r\n}\r\nstatic void s2255_print_cfg(struct s2255_dev *sdev, struct s2255_mode *mode)\r\n{\r\nstruct device *dev = &sdev->udev->dev;\r\ndev_info(dev, "------------------------------------------------\n");\r\ndev_info(dev, "format: %d\nscale %d\n", mode->format, mode->scale);\r\ndev_info(dev, "fdec: %d\ncolor %d\n", mode->fdec, mode->color);\r\ndev_info(dev, "bright: 0x%x\n", mode->bright);\r\ndev_info(dev, "------------------------------------------------\n");\r\n}\r\nstatic int s2255_set_mode(struct s2255_channel *channel,\r\nstruct s2255_mode *mode)\r\n{\r\nint res;\r\n__le32 *buffer;\r\nunsigned long chn_rev;\r\nstruct s2255_dev *dev = to_s2255_dev(channel->vdev.v4l2_dev);\r\nint i;\r\nchn_rev = G_chnmap[channel->idx];\r\ndprintk(3, "%s channel: %d\n", __func__, channel->idx);\r\nif ((mode->color & MASK_COLOR) == COLOR_JPG) {\r\nmode->color &= ~MASK_COLOR;\r\nmode->color |= COLOR_JPG;\r\nmode->color &= ~MASK_JPG_QUALITY;\r\nmode->color |= (channel->jpegqual << 8);\r\n}\r\nchannel->mode = *mode;\r\nchannel->req_image_size = get_transfer_size(mode);\r\ndprintk(1, "%s: reqsize %ld\n", __func__, channel->req_image_size);\r\nbuffer = kzalloc(512, GFP_KERNEL);\r\nif (buffer == NULL) {\r\ndev_err(&dev->udev->dev, "out of mem\n");\r\nreturn -ENOMEM;\r\n}\r\nbuffer[0] = IN_DATA_TOKEN;\r\nbuffer[1] = (__le32) cpu_to_le32(chn_rev);\r\nbuffer[2] = CMD_SET_MODE;\r\nfor (i = 0; i < sizeof(struct s2255_mode) / sizeof(u32); i++)\r\nbuffer[3 + i] = cpu_to_le32(((u32 *)&channel->mode)[i]);\r\nchannel->setmode_ready = 0;\r\nres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\r\nif (debug)\r\ns2255_print_cfg(dev, mode);\r\nkfree(buffer);\r\nif (mode->restart) {\r\nwait_event_timeout(channel->wait_setmode,\r\n(channel->setmode_ready != 0),\r\nmsecs_to_jiffies(S2255_SETMODE_TIMEOUT));\r\nif (channel->setmode_ready != 1) {\r\nprintk(KERN_DEBUG "s2255: no set mode response\n");\r\nres = -EFAULT;\r\n}\r\n}\r\nchannel->mode.restart = 0;\r\ndprintk(1, "%s chn %d, result: %d\n", __func__, channel->idx, res);\r\nreturn res;\r\n}\r\nstatic int s2255_cmd_status(struct s2255_channel *channel, u32 *pstatus)\r\n{\r\nint res;\r\n__le32 *buffer;\r\nu32 chn_rev;\r\nstruct s2255_dev *dev = to_s2255_dev(channel->vdev.v4l2_dev);\r\nchn_rev = G_chnmap[channel->idx];\r\ndprintk(4, "%s chan %d\n", __func__, channel->idx);\r\nbuffer = kzalloc(512, GFP_KERNEL);\r\nif (buffer == NULL) {\r\ndev_err(&dev->udev->dev, "out of mem\n");\r\nreturn -ENOMEM;\r\n}\r\nbuffer[0] = IN_DATA_TOKEN;\r\nbuffer[1] = (__le32) cpu_to_le32(chn_rev);\r\nbuffer[2] = CMD_STATUS;\r\n*pstatus = 0;\r\nchannel->vidstatus_ready = 0;\r\nres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\r\nkfree(buffer);\r\nwait_event_timeout(channel->wait_vidstatus,\r\n(channel->vidstatus_ready != 0),\r\nmsecs_to_jiffies(S2255_VIDSTATUS_TIMEOUT));\r\nif (channel->vidstatus_ready != 1) {\r\nprintk(KERN_DEBUG "s2255: no vidstatus response\n");\r\nres = -EFAULT;\r\n}\r\n*pstatus = channel->vidstatus;\r\ndprintk(4, "%s, vid status %d\n", __func__, *pstatus);\r\nreturn res;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nint res;\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_dev *dev = fh->dev;\r\nstruct s2255_channel *channel = fh->channel;\r\nint j;\r\ndprintk(4, "%s\n", __func__);\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ndev_err(&dev->udev->dev, "invalid fh type0\n");\r\nreturn -EINVAL;\r\n}\r\nif (i != fh->type) {\r\ndev_err(&dev->udev->dev, "invalid fh type1\n");\r\nreturn -EINVAL;\r\n}\r\nif (!res_get(fh)) {\r\ns2255_dev_err(&dev->udev->dev, "stream busy\n");\r\nreturn -EBUSY;\r\n}\r\nchannel->last_frame = -1;\r\nchannel->bad_payload = 0;\r\nchannel->cur_frame = 0;\r\nchannel->frame_count = 0;\r\nfor (j = 0; j < SYS_FRAMES; j++) {\r\nchannel->buffer.frame[j].ulState = S2255_READ_IDLE;\r\nchannel->buffer.frame[j].cur_size = 0;\r\n}\r\nres = videobuf_streamon(&fh->vb_vidq);\r\nif (res == 0) {\r\ns2255_start_acquire(channel);\r\nchannel->b_acquire = 1;\r\n} else\r\nres_free(fh);\r\nreturn res;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct s2255_fh *fh = priv;\r\ndprintk(4, "%s\n, channel: %d", __func__, fh->channel->idx);\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nprintk(KERN_ERR "invalid fh type0\n");\r\nreturn -EINVAL;\r\n}\r\nif (i != fh->type) {\r\nprintk(KERN_ERR "invalid type i\n");\r\nreturn -EINVAL;\r\n}\r\ns2255_stop_acquire(fh->channel);\r\nvideobuf_streamoff(&fh->vb_vidq);\r\nres_free(fh);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_mode mode;\r\nstruct videobuf_queue *q = &fh->vb_vidq;\r\nstruct s2255_channel *channel = fh->channel;\r\nint ret = 0;\r\nmutex_lock(&q->vb_lock);\r\nif (videobuf_queue_is_busy(q)) {\r\ndprintk(1, "queue busy\n");\r\nret = -EBUSY;\r\ngoto out_s_std;\r\n}\r\nif (res_locked(fh)) {\r\ndprintk(1, "can't change standard after started\n");\r\nret = -EBUSY;\r\ngoto out_s_std;\r\n}\r\nmode = fh->channel->mode;\r\nif (i & V4L2_STD_525_60) {\r\ndprintk(4, "%s 60 Hz\n", __func__);\r\nif (mode.format != FORMAT_NTSC) {\r\nmode.restart = 1;\r\nmode.format = FORMAT_NTSC;\r\nmode.fdec = FDEC_1;\r\nchannel->width = LINE_SZ_4CIFS_NTSC;\r\nchannel->height = NUM_LINES_4CIFS_NTSC * 2;\r\n}\r\n} else if (i & V4L2_STD_625_50) {\r\ndprintk(4, "%s 50 Hz\n", __func__);\r\nif (mode.format != FORMAT_PAL) {\r\nmode.restart = 1;\r\nmode.format = FORMAT_PAL;\r\nmode.fdec = FDEC_1;\r\nchannel->width = LINE_SZ_4CIFS_PAL;\r\nchannel->height = NUM_LINES_4CIFS_PAL * 2;\r\n}\r\n} else {\r\nret = -EINVAL;\r\ngoto out_s_std;\r\n}\r\nfh->channel->std = i;\r\nif (mode.restart)\r\ns2255_set_mode(fh->channel, &mode);\r\nout_s_std:\r\nmutex_unlock(&q->vb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *i)\r\n{\r\nstruct s2255_fh *fh = priv;\r\n*i = fh->channel->std;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_dev *dev = fh->dev;\r\nstruct s2255_channel *channel = fh->channel;\r\nu32 status = 0;\r\nif (inp->index != 0)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = S2255_NORMS;\r\ninp->status = 0;\r\nif (dev->dsp_fw_ver >= S2255_MIN_DSP_STATUS) {\r\nint rc;\r\nrc = s2255_cmd_status(fh->channel, &status);\r\ndprintk(4, "s2255_cmd_status rc: %d status %x\n", rc, status);\r\nif (rc == 0)\r\ninp->status = (status & 0x01) ? 0\r\n: V4L2_IN_ST_NO_SIGNAL;\r\n}\r\nswitch (dev->pid) {\r\ncase 0x2255:\r\ndefault:\r\nstrlcpy(inp->name, "Composite", sizeof(inp->name));\r\nbreak;\r\ncase 0x2257:\r\nstrlcpy(inp->name, (channel->idx < 2) ? "Composite" : "S-Video",\r\nsizeof(inp->name));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int s2255_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s2255_channel *channel =\r\ncontainer_of(ctrl->handler, struct s2255_channel, hdl);\r\nstruct s2255_mode mode;\r\nmode = channel->mode;\r\ndprintk(4, "%s\n", __func__);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nmode.bright = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nmode.contrast = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nmode.hue = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nmode.saturation = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_S2255_COLORFILTER:\r\nmode.color &= ~MASK_INPUT_TYPE;\r\nmode.color |= !ctrl->val << 16;\r\nbreak;\r\ncase V4L2_CID_JPEG_COMPRESSION_QUALITY:\r\nchannel->jpegqual = ctrl->val;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmode.restart = 0;\r\ns2255_set_mode(channel, &mode);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_jpegcomp(struct file *file, void *priv,\r\nstruct v4l2_jpegcompression *jc)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_channel *channel = fh->channel;\r\nmemset(jc, 0, sizeof(*jc));\r\njc->quality = channel->jpegqual;\r\ndprintk(2, "%s: quality %d\n", __func__, jc->quality);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_jpegcomp(struct file *file, void *priv,\r\nconst struct v4l2_jpegcompression *jc)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_channel *channel = fh->channel;\r\nif (jc->quality < 0 || jc->quality > 100)\r\nreturn -EINVAL;\r\nv4l2_ctrl_s_ctrl(channel->jpegqual_ctrl, jc->quality);\r\ndprintk(2, "%s: quality %d\n", __func__, jc->quality);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct s2255_fh *fh = priv;\r\n__u32 def_num, def_dem;\r\nstruct s2255_channel *channel = fh->channel;\r\nif (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nsp->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\r\nsp->parm.capture.capturemode = channel->cap_parm.capturemode;\r\ndef_num = (channel->mode.format == FORMAT_NTSC) ? 1001 : 1000;\r\ndef_dem = (channel->mode.format == FORMAT_NTSC) ? 30000 : 25000;\r\nsp->parm.capture.timeperframe.denominator = def_dem;\r\nswitch (channel->mode.fdec) {\r\ndefault:\r\ncase FDEC_1:\r\nsp->parm.capture.timeperframe.numerator = def_num;\r\nbreak;\r\ncase FDEC_2:\r\nsp->parm.capture.timeperframe.numerator = def_num * 2;\r\nbreak;\r\ncase FDEC_3:\r\nsp->parm.capture.timeperframe.numerator = def_num * 3;\r\nbreak;\r\ncase FDEC_5:\r\nsp->parm.capture.timeperframe.numerator = def_num * 5;\r\nbreak;\r\n}\r\ndprintk(4, "%s capture mode, %d timeperframe %d/%d\n", __func__,\r\nsp->parm.capture.capturemode,\r\nsp->parm.capture.timeperframe.numerator,\r\nsp->parm.capture.timeperframe.denominator);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_channel *channel = fh->channel;\r\nstruct s2255_mode mode;\r\nint fdec = FDEC_1;\r\n__u32 def_num, def_dem;\r\nif (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmode = channel->mode;\r\nif (channel->cap_parm.capturemode\r\n!= sp->parm.capture.capturemode && res_locked(fh))\r\nreturn -EBUSY;\r\ndef_num = (mode.format == FORMAT_NTSC) ? 1001 : 1000;\r\ndef_dem = (mode.format == FORMAT_NTSC) ? 30000 : 25000;\r\nif (def_dem != sp->parm.capture.timeperframe.denominator)\r\nsp->parm.capture.timeperframe.numerator = def_num;\r\nelse if (sp->parm.capture.timeperframe.numerator <= def_num)\r\nsp->parm.capture.timeperframe.numerator = def_num;\r\nelse if (sp->parm.capture.timeperframe.numerator <= (def_num * 2)) {\r\nsp->parm.capture.timeperframe.numerator = def_num * 2;\r\nfdec = FDEC_2;\r\n} else if (sp->parm.capture.timeperframe.numerator <= (def_num * 3)) {\r\nsp->parm.capture.timeperframe.numerator = def_num * 3;\r\nfdec = FDEC_3;\r\n} else {\r\nsp->parm.capture.timeperframe.numerator = def_num * 5;\r\nfdec = FDEC_5;\r\n}\r\nmode.fdec = fdec;\r\nsp->parm.capture.timeperframe.denominator = def_dem;\r\ns2255_set_mode(channel, &mode);\r\ndprintk(4, "%s capture mode, %d timeperframe %d/%d, fdec %d\n",\r\n__func__,\r\nsp->parm.capture.capturemode,\r\nsp->parm.capture.timeperframe.numerator,\r\nsp->parm.capture.timeperframe.denominator, fdec);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fe)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_channel *channel = fh->channel;\r\nint is_ntsc = channel->std & V4L2_STD_525_60;\r\nconst struct s2255_fmt *fmt;\r\nif (fe->index >= NUM_SIZE_ENUMS)\r\nreturn -EINVAL;\r\nfmt = format_by_fourcc(fe->pixel_format);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nfe->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfe->discrete = is_ntsc ? ntsc_sizes[fe->index] : pal_sizes[fe->index];\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_frameintervals(struct file *file, void *priv,\r\nstruct v4l2_frmivalenum *fe)\r\n{\r\nstruct s2255_fh *fh = priv;\r\nstruct s2255_channel *channel = fh->channel;\r\nconst struct s2255_fmt *fmt;\r\nconst struct v4l2_frmsize_discrete *sizes;\r\nint is_ntsc = channel->std & V4L2_STD_525_60;\r\n#define NUM_FRAME_ENUMS 4\r\nint frm_dec[NUM_FRAME_ENUMS] = {1, 2, 3, 5};\r\nint i;\r\nif (fe->index >= NUM_FRAME_ENUMS)\r\nreturn -EINVAL;\r\nfmt = format_by_fourcc(fe->pixel_format);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nsizes = is_ntsc ? ntsc_sizes : pal_sizes;\r\nfor (i = 0; i < NUM_SIZE_ENUMS; i++, sizes++)\r\nif (fe->width == sizes->width &&\r\nfe->height == sizes->height)\r\nbreak;\r\nif (i == NUM_SIZE_ENUMS)\r\nreturn -EINVAL;\r\nfe->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nfe->discrete.denominator = is_ntsc ? 30000 : 25000;\r\nfe->discrete.numerator = (is_ntsc ? 1001 : 1000) * frm_dec[fe->index];\r\ndprintk(4, "%s discrete %d/%d\n", __func__, fe->discrete.numerator,\r\nfe->discrete.denominator);\r\nreturn 0;\r\n}\r\nstatic int __s2255_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct s2255_channel *channel = video_drvdata(file);\r\nstruct s2255_dev *dev = to_s2255_dev(vdev->v4l2_dev);\r\nstruct s2255_fh *fh;\r\nenum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nint state;\r\ndprintk(1, "s2255: open called (dev=%s)\n",\r\nvideo_device_node_name(vdev));\r\nstate = atomic_read(&dev->fw_data->fw_state);\r\nswitch (state) {\r\ncase S2255_FW_DISCONNECTING:\r\nreturn -ENODEV;\r\ncase S2255_FW_FAILED:\r\ns2255_dev_err(&dev->udev->dev,\r\n"firmware load failed. retrying.\n");\r\ns2255_fwload_start(dev, 1);\r\nwait_event_timeout(dev->fw_data->wait_fw,\r\n((atomic_read(&dev->fw_data->fw_state)\r\n== S2255_FW_SUCCESS) ||\r\n(atomic_read(&dev->fw_data->fw_state)\r\n== S2255_FW_DISCONNECTING)),\r\nmsecs_to_jiffies(S2255_LOAD_TIMEOUT));\r\nstate = atomic_read(&dev->fw_data->fw_state);\r\nbreak;\r\ncase S2255_FW_NOTLOADED:\r\ncase S2255_FW_LOADED_DSPWAIT:\r\nprintk(KERN_INFO "%s waiting for firmware load\n", __func__);\r\nwait_event_timeout(dev->fw_data->wait_fw,\r\n((atomic_read(&dev->fw_data->fw_state)\r\n== S2255_FW_SUCCESS) ||\r\n(atomic_read(&dev->fw_data->fw_state)\r\n== S2255_FW_DISCONNECTING)),\r\nmsecs_to_jiffies(S2255_LOAD_TIMEOUT));\r\nstate = atomic_read(&dev->fw_data->fw_state);\r\nbreak;\r\ncase S2255_FW_SUCCESS:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (state) {\r\ncase S2255_FW_SUCCESS:\r\nbreak;\r\ncase S2255_FW_FAILED:\r\nprintk(KERN_INFO "2255 firmware load failed.\n");\r\nreturn -ENODEV;\r\ncase S2255_FW_DISCONNECTING:\r\nprintk(KERN_INFO "%s: disconnecting\n", __func__);\r\nreturn -ENODEV;\r\ncase S2255_FW_LOADED_DSPWAIT:\r\ncase S2255_FW_NOTLOADED:\r\nprintk(KERN_INFO "%s: firmware not loaded yet"\r\n"please try again later\n",\r\n__func__);\r\natomic_set(&dev->fw_data->fw_state,\r\nS2255_FW_FAILED);\r\nreturn -EAGAIN;\r\ndefault:\r\nprintk(KERN_INFO "%s: unknown state\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (NULL == fh)\r\nreturn -ENOMEM;\r\nv4l2_fh_init(&fh->fh, vdev);\r\nv4l2_fh_add(&fh->fh);\r\nfile->private_data = &fh->fh;\r\nfh->dev = dev;\r\nfh->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nfh->channel = channel;\r\nif (!channel->configured) {\r\nchannel->fmt = &formats[0];\r\ns2255_set_mode(channel, &channel->mode);\r\nchannel->configured = 1;\r\n}\r\ndprintk(1, "%s: dev=%s type=%s\n", __func__,\r\nvideo_device_node_name(vdev), v4l2_type_names[type]);\r\ndprintk(2, "%s: fh=0x%08lx, dev=0x%08lx, vidq=0x%08lx\n", __func__,\r\n(unsigned long)fh, (unsigned long)dev,\r\n(unsigned long)&channel->vidq);\r\ndprintk(4, "%s: list_empty active=%d\n", __func__,\r\nlist_empty(&channel->vidq.active));\r\nvideobuf_queue_vmalloc_init(&fh->vb_vidq, &s2255_video_qops,\r\nNULL, &dev->slock,\r\nfh->type,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct s2255_buffer),\r\nfh, vdev->lock);\r\nreturn 0;\r\n}\r\nstatic int s2255_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nint ret;\r\nif (mutex_lock_interruptible(vdev->lock))\r\nreturn -ERESTARTSYS;\r\nret = __s2255_open(file);\r\nmutex_unlock(vdev->lock);\r\nreturn ret;\r\n}\r\nstatic unsigned int s2255_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct s2255_fh *fh = file->private_data;\r\nstruct s2255_dev *dev = fh->dev;\r\nint rc = v4l2_ctrl_poll(file, wait);\r\ndprintk(100, "%s\n", __func__);\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)\r\nreturn POLLERR;\r\nmutex_lock(&dev->lock);\r\nrc |= videobuf_poll_stream(file, &fh->vb_vidq, wait);\r\nmutex_unlock(&dev->lock);\r\nreturn rc;\r\n}\r\nstatic void s2255_destroy(struct s2255_dev *dev)\r\n{\r\ns2255_board_shutdown(dev);\r\ndel_timer(&dev->timer);\r\nif (dev->fw_data->fw_urb) {\r\nusb_kill_urb(dev->fw_data->fw_urb);\r\nusb_free_urb(dev->fw_data->fw_urb);\r\ndev->fw_data->fw_urb = NULL;\r\n}\r\nrelease_firmware(dev->fw_data->fw);\r\nkfree(dev->fw_data->pfw_data);\r\nkfree(dev->fw_data);\r\ns2255_reset_dsppower(dev);\r\nmutex_destroy(&dev->lock);\r\nusb_put_dev(dev->udev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\ndprintk(1, "%s", __func__);\r\nkfree(dev);\r\n}\r\nstatic int s2255_release(struct file *file)\r\n{\r\nstruct s2255_fh *fh = file->private_data;\r\nstruct s2255_dev *dev = fh->dev;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct s2255_channel *channel = fh->channel;\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->lock);\r\nif (res_check(fh)) {\r\nif (channel->b_acquire)\r\ns2255_stop_acquire(fh->channel);\r\nvideobuf_streamoff(&fh->vb_vidq);\r\nres_free(fh);\r\n}\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\nmutex_unlock(&dev->lock);\r\ndprintk(1, "%s (dev=%s)\n", __func__, video_device_node_name(vdev));\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int s2255_mmap_v4l(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct s2255_fh *fh = file->private_data;\r\nstruct s2255_dev *dev;\r\nint ret;\r\nif (!fh)\r\nreturn -ENODEV;\r\ndev = fh->dev;\r\ndprintk(4, "%s, vma=0x%08lx\n", __func__, (unsigned long)vma);\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nret = videobuf_mmap_mapper(&fh->vb_vidq, vma);\r\nmutex_unlock(&dev->lock);\r\ndprintk(4, "%s vma start=0x%08lx, size=%ld, ret=%d\n", __func__,\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end - (unsigned long)vma->vm_start, ret);\r\nreturn ret;\r\n}\r\nstatic void s2255_video_device_release(struct video_device *vdev)\r\n{\r\nstruct s2255_dev *dev = to_s2255_dev(vdev->v4l2_dev);\r\nstruct s2255_channel *channel =\r\ncontainer_of(vdev, struct s2255_channel, vdev);\r\nv4l2_ctrl_handler_free(&channel->hdl);\r\ndprintk(4, "%s, chnls: %d\n", __func__,\r\natomic_read(&dev->num_channels));\r\nif (atomic_dec_and_test(&dev->num_channels))\r\ns2255_destroy(dev);\r\nreturn;\r\n}\r\nstatic int s2255_probe_v4l(struct s2255_dev *dev)\r\n{\r\nint ret;\r\nint i;\r\nint cur_nr = video_nr;\r\nstruct s2255_channel *channel;\r\nret = v4l2_device_register(&dev->interface->dev, &dev->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\nchannel = &dev->channel[i];\r\nINIT_LIST_HEAD(&channel->vidq.active);\r\nv4l2_ctrl_handler_init(&channel->hdl, 6);\r\nv4l2_ctrl_new_std(&channel->hdl, &s2255_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -127, 127, 1, DEF_BRIGHT);\r\nv4l2_ctrl_new_std(&channel->hdl, &s2255_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, DEF_CONTRAST);\r\nv4l2_ctrl_new_std(&channel->hdl, &s2255_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, DEF_SATURATION);\r\nv4l2_ctrl_new_std(&channel->hdl, &s2255_ctrl_ops,\r\nV4L2_CID_HUE, 0, 255, 1, DEF_HUE);\r\nchannel->jpegqual_ctrl = v4l2_ctrl_new_std(&channel->hdl,\r\n&s2255_ctrl_ops,\r\nV4L2_CID_JPEG_COMPRESSION_QUALITY,\r\n0, 100, 1, S2255_DEF_JPEG_QUAL);\r\nif (dev->dsp_fw_ver >= S2255_MIN_DSP_COLORFILTER &&\r\n(dev->pid != 0x2257 || channel->idx <= 1))\r\nv4l2_ctrl_new_custom(&channel->hdl, &color_filter_ctrl, NULL);\r\nif (channel->hdl.error) {\r\nret = channel->hdl.error;\r\nv4l2_ctrl_handler_free(&channel->hdl);\r\ndev_err(&dev->udev->dev, "couldn't register control\n");\r\nbreak;\r\n}\r\nchannel->vidq.dev = dev;\r\nchannel->vdev = template;\r\nchannel->vdev.ctrl_handler = &channel->hdl;\r\nchannel->vdev.lock = &dev->lock;\r\nchannel->vdev.v4l2_dev = &dev->v4l2_dev;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &channel->vdev.flags);\r\nvideo_set_drvdata(&channel->vdev, channel);\r\nif (video_nr == -1)\r\nret = video_register_device(&channel->vdev,\r\nVFL_TYPE_GRABBER,\r\nvideo_nr);\r\nelse\r\nret = video_register_device(&channel->vdev,\r\nVFL_TYPE_GRABBER,\r\ncur_nr + i);\r\nif (ret) {\r\ndev_err(&dev->udev->dev,\r\n"failed to register video device!\n");\r\nbreak;\r\n}\r\natomic_inc(&dev->num_channels);\r\nv4l2_info(&dev->v4l2_dev, "V4L2 device registered as %s\n",\r\nvideo_device_node_name(&channel->vdev));\r\n}\r\nprintk(KERN_INFO "Sensoray 2255 V4L driver Revision: %s\n",\r\nS2255_VERSION);\r\nif (atomic_read(&dev->num_channels) == 0) {\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn ret;\r\n}\r\nif (atomic_read(&dev->num_channels) != MAX_CHANNELS)\r\nprintk(KERN_WARNING "s2255: Not all channels available.\n");\r\nreturn 0;\r\n}\r\nstatic int save_frame(struct s2255_dev *dev, struct s2255_pipeinfo *pipe_info)\r\n{\r\nchar *pdest;\r\nu32 offset = 0;\r\nint bframe = 0;\r\nchar *psrc;\r\nunsigned long copy_size;\r\nunsigned long size;\r\ns32 idx = -1;\r\nstruct s2255_framei *frm;\r\nunsigned char *pdata;\r\nstruct s2255_channel *channel;\r\ndprintk(100, "buffer to user\n");\r\nchannel = &dev->channel[dev->cc];\r\nidx = channel->cur_frame;\r\nfrm = &channel->buffer.frame[idx];\r\nif (frm->ulState == S2255_READ_IDLE) {\r\nint jj;\r\nunsigned int cc;\r\n__le32 *pdword;\r\nint payload;\r\npdata = (unsigned char *)pipe_info->transfer_buffer;\r\npdword = (__le32 *)pdata;\r\nfor (jj = 0; jj < (pipe_info->cur_transfer_size - 12); jj++) {\r\nswitch (*pdword) {\r\ncase S2255_MARKER_FRAME:\r\ndprintk(4, "found frame marker at offset:"\r\n" %d [%x %x]\n", jj, pdata[0],\r\npdata[1]);\r\noffset = jj + PREFIX_SIZE;\r\nbframe = 1;\r\ncc = le32_to_cpu(pdword[1]);\r\nif (cc >= MAX_CHANNELS) {\r\nprintk(KERN_ERR\r\n"bad channel\n");\r\nreturn -EINVAL;\r\n}\r\ndev->cc = G_chnmap[cc];\r\nchannel = &dev->channel[dev->cc];\r\npayload = le32_to_cpu(pdword[3]);\r\nif (payload > channel->req_image_size) {\r\nchannel->bad_payload++;\r\nreturn -EINVAL;\r\n}\r\nchannel->pkt_size = payload;\r\nchannel->jpg_size = le32_to_cpu(pdword[4]);\r\nbreak;\r\ncase S2255_MARKER_RESPONSE:\r\npdata += DEF_USB_BLOCK;\r\njj += DEF_USB_BLOCK;\r\nif (le32_to_cpu(pdword[1]) >= MAX_CHANNELS)\r\nbreak;\r\ncc = G_chnmap[le32_to_cpu(pdword[1])];\r\nif (cc >= MAX_CHANNELS)\r\nbreak;\r\nchannel = &dev->channel[cc];\r\nswitch (pdword[2]) {\r\ncase S2255_RESPONSE_SETMODE:\r\nchannel->setmode_ready = 1;\r\nwake_up(&channel->wait_setmode);\r\ndprintk(5, "setmode ready %d\n", cc);\r\nbreak;\r\ncase S2255_RESPONSE_FW:\r\ndev->chn_ready |= (1 << cc);\r\nif ((dev->chn_ready & 0x0f) != 0x0f)\r\nbreak;\r\nprintk(KERN_INFO "s2255: fw loaded\n");\r\natomic_set(&dev->fw_data->fw_state,\r\nS2255_FW_SUCCESS);\r\nwake_up(&dev->fw_data->wait_fw);\r\nbreak;\r\ncase S2255_RESPONSE_STATUS:\r\nchannel->vidstatus = le32_to_cpu(pdword[3]);\r\nchannel->vidstatus_ready = 1;\r\nwake_up(&channel->wait_vidstatus);\r\ndprintk(5, "got vidstatus %x chan %d\n",\r\nle32_to_cpu(pdword[3]), cc);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "s2255 unknown resp\n");\r\n}\r\ndefault:\r\npdata++;\r\nbreak;\r\n}\r\nif (bframe)\r\nbreak;\r\n}\r\nif (!bframe)\r\nreturn -EINVAL;\r\n}\r\nchannel = &dev->channel[dev->cc];\r\nidx = channel->cur_frame;\r\nfrm = &channel->buffer.frame[idx];\r\nif (!channel->b_acquire) {\r\nfrm->ulState = S2255_READ_IDLE;\r\nreturn -EINVAL;\r\n}\r\nif (frm->ulState == S2255_READ_IDLE) {\r\nfrm->ulState = S2255_READ_FRAME;\r\nfrm->cur_size = 0;\r\n}\r\npsrc = (u8 *)pipe_info->transfer_buffer + offset;\r\nif (frm->lpvbits == NULL) {\r\ndprintk(1, "s2255 frame buffer == NULL.%p %p %d %d",\r\nfrm, dev, dev->cc, idx);\r\nreturn -ENOMEM;\r\n}\r\npdest = frm->lpvbits + frm->cur_size;\r\ncopy_size = (pipe_info->cur_transfer_size - offset);\r\nsize = channel->pkt_size - PREFIX_SIZE;\r\nif ((copy_size + frm->cur_size) < channel->req_image_size)\r\nmemcpy(pdest, psrc, copy_size);\r\nfrm->cur_size += copy_size;\r\ndprintk(4, "cur_size size %lu size %lu \n", frm->cur_size, size);\r\nif (frm->cur_size >= size) {\r\ndprintk(2, "****************[%d]Buffer[%d]full*************\n",\r\ndev->cc, idx);\r\nchannel->last_frame = channel->cur_frame;\r\nchannel->cur_frame++;\r\nif ((channel->cur_frame == SYS_FRAMES) ||\r\n(channel->cur_frame == channel->buffer.dwFrames))\r\nchannel->cur_frame = 0;\r\nif (channel->b_acquire)\r\ns2255_got_frame(channel, channel->jpg_size);\r\nchannel->frame_count++;\r\nfrm->ulState = S2255_READ_IDLE;\r\nfrm->cur_size = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s2255_read_video_callback(struct s2255_dev *dev,\r\nstruct s2255_pipeinfo *pipe_info)\r\n{\r\nint res;\r\ndprintk(50, "callback read video \n");\r\nif (dev->cc >= MAX_CHANNELS) {\r\ndev->cc = 0;\r\ndev_err(&dev->udev->dev, "invalid channel\n");\r\nreturn;\r\n}\r\nres = save_frame(dev, pipe_info);\r\nif (res != 0)\r\ndprintk(4, "s2255: read callback failed\n");\r\ndprintk(50, "callback read video done\n");\r\nreturn;\r\n}\r\nstatic long s2255_vendor_req(struct s2255_dev *dev, unsigned char Request,\r\nu16 Index, u16 Value, void *TransferBuffer,\r\ns32 TransferBufferLength, int bOut)\r\n{\r\nint r;\r\nif (!bOut) {\r\nr = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\r\nRequest,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE |\r\nUSB_DIR_IN,\r\nValue, Index, TransferBuffer,\r\nTransferBufferLength, HZ * 5);\r\n} else {\r\nr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\nRequest, USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nValue, Index, TransferBuffer,\r\nTransferBufferLength, HZ * 5);\r\n}\r\nreturn r;\r\n}\r\nstatic int s2255_get_fx2fw(struct s2255_dev *dev)\r\n{\r\nint fw;\r\nint ret;\r\nunsigned char transBuffer[64];\r\nret = s2255_vendor_req(dev, S2255_VR_FW, 0, 0, transBuffer, 2,\r\nS2255_VR_IN);\r\nif (ret < 0)\r\ndprintk(2, "get fw error: %x\n", ret);\r\nfw = transBuffer[0] + (transBuffer[1] << 8);\r\ndprintk(2, "Get FW %x %x\n", transBuffer[0], transBuffer[1]);\r\nreturn fw;\r\n}\r\nstatic int s2255_create_sys_buffers(struct s2255_channel *channel)\r\n{\r\nunsigned long i;\r\nunsigned long reqsize;\r\ndprintk(1, "create sys buffers\n");\r\nchannel->buffer.dwFrames = SYS_FRAMES;\r\nreqsize = SYS_FRAMES_MAXSIZE;\r\nif (reqsize > SYS_FRAMES_MAXSIZE)\r\nreqsize = SYS_FRAMES_MAXSIZE;\r\nfor (i = 0; i < SYS_FRAMES; i++) {\r\nchannel->buffer.frame[i].lpvbits = vmalloc(reqsize);\r\ndprintk(1, "valloc %p chan %d, idx %lu, pdata %p\n",\r\n&channel->buffer.frame[i], channel->idx, i,\r\nchannel->buffer.frame[i].lpvbits);\r\nchannel->buffer.frame[i].size = reqsize;\r\nif (channel->buffer.frame[i].lpvbits == NULL) {\r\nprintk(KERN_INFO "out of memory. using less frames\n");\r\nchannel->buffer.dwFrames = i;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < SYS_FRAMES; i++) {\r\nchannel->buffer.frame[i].ulState = 0;\r\nchannel->buffer.frame[i].cur_size = 0;\r\n}\r\nchannel->cur_frame = 0;\r\nchannel->last_frame = -1;\r\nreturn 0;\r\n}\r\nstatic int s2255_release_sys_buffers(struct s2255_channel *channel)\r\n{\r\nunsigned long i;\r\ndprintk(1, "release sys buffers\n");\r\nfor (i = 0; i < SYS_FRAMES; i++) {\r\nif (channel->buffer.frame[i].lpvbits) {\r\ndprintk(1, "vfree %p\n",\r\nchannel->buffer.frame[i].lpvbits);\r\nvfree(channel->buffer.frame[i].lpvbits);\r\n}\r\nchannel->buffer.frame[i].lpvbits = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2255_board_init(struct s2255_dev *dev)\r\n{\r\nstruct s2255_mode mode_def = DEF_MODEI_NTSC_CONT;\r\nint fw_ver;\r\nint j;\r\nstruct s2255_pipeinfo *pipe = &dev->pipe;\r\ndprintk(4, "board init: %p", dev);\r\nmemset(pipe, 0, sizeof(*pipe));\r\npipe->dev = dev;\r\npipe->cur_transfer_size = S2255_USB_XFER_SIZE;\r\npipe->max_transfer_size = S2255_USB_XFER_SIZE;\r\npipe->transfer_buffer = kzalloc(pipe->max_transfer_size,\r\nGFP_KERNEL);\r\nif (pipe->transfer_buffer == NULL) {\r\ndprintk(1, "out of memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nfw_ver = s2255_get_fx2fw(dev);\r\nprintk(KERN_INFO "s2255: usb firmware version %d.%d\n",\r\n(fw_ver >> 8) & 0xff,\r\nfw_ver & 0xff);\r\nif (fw_ver < S2255_CUR_USB_FWVER)\r\nprintk(KERN_INFO "s2255: newer USB firmware available\n");\r\nfor (j = 0; j < MAX_CHANNELS; j++) {\r\nstruct s2255_channel *channel = &dev->channel[j];\r\nchannel->b_acquire = 0;\r\nchannel->mode = mode_def;\r\nif (dev->pid == 0x2257 && j > 1)\r\nchannel->mode.color |= (1 << 16);\r\nchannel->jpegqual = S2255_DEF_JPEG_QUAL;\r\nchannel->width = LINE_SZ_4CIFS_NTSC;\r\nchannel->height = NUM_LINES_4CIFS_NTSC * 2;\r\nchannel->std = V4L2_STD_NTSC_M;\r\nchannel->fmt = &formats[0];\r\nchannel->mode.restart = 1;\r\nchannel->req_image_size = get_transfer_size(&mode_def);\r\nchannel->frame_count = 0;\r\ns2255_create_sys_buffers(channel);\r\n}\r\ns2255_start_readpipe(dev);\r\ndprintk(1, "%s: success\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s2255_board_shutdown(struct s2255_dev *dev)\r\n{\r\nu32 i;\r\ndprintk(1, "%s: dev: %p", __func__, dev);\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\nif (dev->channel[i].b_acquire)\r\ns2255_stop_acquire(&dev->channel[i]);\r\n}\r\ns2255_stop_readpipe(dev);\r\nfor (i = 0; i < MAX_CHANNELS; i++)\r\ns2255_release_sys_buffers(&dev->channel[i]);\r\nkfree(dev->pipe.transfer_buffer);\r\nreturn 0;\r\n}\r\nstatic void read_pipe_completion(struct urb *purb)\r\n{\r\nstruct s2255_pipeinfo *pipe_info;\r\nstruct s2255_dev *dev;\r\nint status;\r\nint pipe;\r\npipe_info = purb->context;\r\ndprintk(100, "%s: urb:%p, status %d\n", __func__, purb,\r\npurb->status);\r\nif (pipe_info == NULL) {\r\ndev_err(&purb->dev->dev, "no context!\n");\r\nreturn;\r\n}\r\ndev = pipe_info->dev;\r\nif (dev == NULL) {\r\ndev_err(&purb->dev->dev, "no context!\n");\r\nreturn;\r\n}\r\nstatus = purb->status;\r\nif (status == -ESHUTDOWN) {\r\ndprintk(2, "%s: err shutdown\n", __func__);\r\npipe_info->err_count++;\r\nreturn;\r\n}\r\nif (pipe_info->state == 0) {\r\ndprintk(2, "%s: exiting USB pipe", __func__);\r\nreturn;\r\n}\r\nif (status == 0)\r\ns2255_read_video_callback(dev, pipe_info);\r\nelse {\r\npipe_info->err_count++;\r\ndprintk(1, "%s: failed URB %d\n", __func__, status);\r\n}\r\npipe = usb_rcvbulkpipe(dev->udev, dev->read_endpoint);\r\nusb_fill_bulk_urb(pipe_info->stream_urb, dev->udev,\r\npipe,\r\npipe_info->transfer_buffer,\r\npipe_info->cur_transfer_size,\r\nread_pipe_completion, pipe_info);\r\nif (pipe_info->state != 0) {\r\nif (usb_submit_urb(pipe_info->stream_urb, GFP_ATOMIC)) {\r\ndev_err(&dev->udev->dev, "error submitting urb\n");\r\n}\r\n} else {\r\ndprintk(2, "%s :complete state 0\n", __func__);\r\n}\r\nreturn;\r\n}\r\nstatic int s2255_start_readpipe(struct s2255_dev *dev)\r\n{\r\nint pipe;\r\nint retval;\r\nstruct s2255_pipeinfo *pipe_info = &dev->pipe;\r\npipe = usb_rcvbulkpipe(dev->udev, dev->read_endpoint);\r\ndprintk(2, "%s: IN %d\n", __func__, dev->read_endpoint);\r\npipe_info->state = 1;\r\npipe_info->err_count = 0;\r\npipe_info->stream_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pipe_info->stream_urb) {\r\ndev_err(&dev->udev->dev,\r\n"ReadStream: Unable to alloc URB\n");\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(pipe_info->stream_urb, dev->udev,\r\npipe,\r\npipe_info->transfer_buffer,\r\npipe_info->cur_transfer_size,\r\nread_pipe_completion, pipe_info);\r\nretval = usb_submit_urb(pipe_info->stream_urb, GFP_KERNEL);\r\nif (retval) {\r\nprintk(KERN_ERR "s2255: start read pipe failed\n");\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2255_start_acquire(struct s2255_channel *channel)\r\n{\r\nunsigned char *buffer;\r\nint res;\r\nunsigned long chn_rev;\r\nint j;\r\nstruct s2255_dev *dev = to_s2255_dev(channel->vdev.v4l2_dev);\r\nchn_rev = G_chnmap[channel->idx];\r\nbuffer = kzalloc(512, GFP_KERNEL);\r\nif (buffer == NULL) {\r\ndev_err(&dev->udev->dev, "out of mem\n");\r\nreturn -ENOMEM;\r\n}\r\nchannel->last_frame = -1;\r\nchannel->bad_payload = 0;\r\nchannel->cur_frame = 0;\r\nfor (j = 0; j < SYS_FRAMES; j++) {\r\nchannel->buffer.frame[j].ulState = 0;\r\nchannel->buffer.frame[j].cur_size = 0;\r\n}\r\n*(__le32 *) buffer = IN_DATA_TOKEN;\r\n*((__le32 *) buffer + 1) = (__le32) cpu_to_le32(chn_rev);\r\n*((__le32 *) buffer + 2) = CMD_START;\r\nres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\r\nif (res != 0)\r\ndev_err(&dev->udev->dev, "CMD_START error\n");\r\ndprintk(2, "start acquire exit[%d] %d \n", channel->idx, res);\r\nkfree(buffer);\r\nreturn 0;\r\n}\r\nstatic int s2255_stop_acquire(struct s2255_channel *channel)\r\n{\r\nunsigned char *buffer;\r\nint res;\r\nunsigned long chn_rev;\r\nstruct s2255_dev *dev = to_s2255_dev(channel->vdev.v4l2_dev);\r\nchn_rev = G_chnmap[channel->idx];\r\nbuffer = kzalloc(512, GFP_KERNEL);\r\nif (buffer == NULL) {\r\ndev_err(&dev->udev->dev, "out of mem\n");\r\nreturn -ENOMEM;\r\n}\r\n*(__le32 *) buffer = IN_DATA_TOKEN;\r\n*((__le32 *) buffer + 1) = (__le32) cpu_to_le32(chn_rev);\r\n*((__le32 *) buffer + 2) = CMD_STOP;\r\nres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\r\nif (res != 0)\r\ndev_err(&dev->udev->dev, "CMD_STOP error\n");\r\nkfree(buffer);\r\nchannel->b_acquire = 0;\r\ndprintk(4, "%s: chn %d, res %d\n", __func__, channel->idx, res);\r\nreturn res;\r\n}\r\nstatic void s2255_stop_readpipe(struct s2255_dev *dev)\r\n{\r\nstruct s2255_pipeinfo *pipe = &dev->pipe;\r\npipe->state = 0;\r\nif (pipe->stream_urb) {\r\nusb_kill_urb(pipe->stream_urb);\r\nusb_free_urb(pipe->stream_urb);\r\npipe->stream_urb = NULL;\r\n}\r\ndprintk(4, "%s", __func__);\r\nreturn;\r\n}\r\nstatic void s2255_fwload_start(struct s2255_dev *dev, int reset)\r\n{\r\nif (reset)\r\ns2255_reset_dsppower(dev);\r\ndev->fw_data->fw_size = dev->fw_data->fw->size;\r\natomic_set(&dev->fw_data->fw_state, S2255_FW_NOTLOADED);\r\nmemcpy(dev->fw_data->pfw_data,\r\ndev->fw_data->fw->data, CHUNK_SIZE);\r\ndev->fw_data->fw_loaded = CHUNK_SIZE;\r\nusb_fill_bulk_urb(dev->fw_data->fw_urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev, 2),\r\ndev->fw_data->pfw_data,\r\nCHUNK_SIZE, s2255_fwchunk_complete,\r\ndev->fw_data);\r\nmod_timer(&dev->timer, jiffies + HZ);\r\n}\r\nstatic int s2255_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct s2255_dev *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\nint retval = -ENOMEM;\r\n__le32 *pdata;\r\nint fw_size;\r\ndprintk(2, "%s\n", __func__);\r\ndev = kzalloc(sizeof(struct s2255_dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ns2255_dev_err(&interface->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\natomic_set(&dev->num_channels, 0);\r\ndev->pid = le16_to_cpu(id->idProduct);\r\ndev->fw_data = kzalloc(sizeof(struct s2255_fw), GFP_KERNEL);\r\nif (!dev->fw_data)\r\ngoto errorFWDATA1;\r\nmutex_init(&dev->lock);\r\ndev->udev = usb_get_dev(interface_to_usbdev(interface));\r\nif (dev->udev == NULL) {\r\ndev_err(&interface->dev, "null usb device\n");\r\nretval = -ENODEV;\r\ngoto errorUDEV;\r\n}\r\ndprintk(1, "dev: %p, udev %p interface %p\n", dev,\r\ndev->udev, interface);\r\ndev->interface = interface;\r\niface_desc = interface->cur_altsetting;\r\ndprintk(1, "num endpoints %d\n", iface_desc->desc.bNumEndpoints);\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!dev->read_endpoint && usb_endpoint_is_bulk_in(endpoint)) {\r\ndev->read_endpoint = endpoint->bEndpointAddress;\r\n}\r\n}\r\nif (!dev->read_endpoint) {\r\ndev_err(&interface->dev, "Could not find bulk-in endpoint\n");\r\ngoto errorEP;\r\n}\r\ninit_timer(&dev->timer);\r\ndev->timer.function = s2255_timer;\r\ndev->timer.data = (unsigned long)dev->fw_data;\r\ninit_waitqueue_head(&dev->fw_data->wait_fw);\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\nstruct s2255_channel *channel = &dev->channel[i];\r\ndev->channel[i].idx = i;\r\ninit_waitqueue_head(&channel->wait_setmode);\r\ninit_waitqueue_head(&channel->wait_vidstatus);\r\n}\r\ndev->fw_data->fw_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->fw_data->fw_urb) {\r\ndev_err(&interface->dev, "out of memory!\n");\r\ngoto errorFWURB;\r\n}\r\ndev->fw_data->pfw_data = kzalloc(CHUNK_SIZE, GFP_KERNEL);\r\nif (!dev->fw_data->pfw_data) {\r\ndev_err(&interface->dev, "out of memory!\n");\r\ngoto errorFWDATA2;\r\n}\r\nif (request_firmware(&dev->fw_data->fw,\r\nFIRMWARE_FILE_NAME, &dev->udev->dev)) {\r\nprintk(KERN_ERR "sensoray 2255 failed to get firmware\n");\r\ngoto errorREQFW;\r\n}\r\nfw_size = dev->fw_data->fw->size;\r\npdata = (__le32 *) &dev->fw_data->fw->data[fw_size - 8];\r\nif (*pdata != S2255_FW_MARKER) {\r\nprintk(KERN_INFO "Firmware invalid.\n");\r\nretval = -ENODEV;\r\ngoto errorFWMARKER;\r\n} else {\r\n__le32 *pRel;\r\npRel = (__le32 *) &dev->fw_data->fw->data[fw_size - 4];\r\nprintk(KERN_INFO "s2255 dsp fw version %x\n", le32_to_cpu(*pRel));\r\ndev->dsp_fw_ver = le32_to_cpu(*pRel);\r\nif (dev->dsp_fw_ver < S2255_CUR_DSP_FWVER)\r\nprintk(KERN_INFO "s2255: f2255usb.bin out of date.\n");\r\nif (dev->pid == 0x2257 &&\r\ndev->dsp_fw_ver < S2255_MIN_DSP_COLORFILTER)\r\nprintk(KERN_WARNING "s2255: 2257 requires firmware %d"\r\n" or above.\n", S2255_MIN_DSP_COLORFILTER);\r\n}\r\nusb_reset_device(dev->udev);\r\nretval = s2255_board_init(dev);\r\nif (retval)\r\ngoto errorBOARDINIT;\r\nspin_lock_init(&dev->slock);\r\ns2255_fwload_start(dev, 0);\r\nretval = s2255_probe_v4l(dev);\r\nif (retval)\r\ngoto errorBOARDINIT;\r\ndev_info(&interface->dev, "Sensoray 2255 detected\n");\r\nreturn 0;\r\nerrorBOARDINIT:\r\ns2255_board_shutdown(dev);\r\nerrorFWMARKER:\r\nrelease_firmware(dev->fw_data->fw);\r\nerrorREQFW:\r\nkfree(dev->fw_data->pfw_data);\r\nerrorFWDATA2:\r\nusb_free_urb(dev->fw_data->fw_urb);\r\nerrorFWURB:\r\ndel_timer(&dev->timer);\r\nerrorEP:\r\nusb_put_dev(dev->udev);\r\nerrorUDEV:\r\nkfree(dev->fw_data);\r\nmutex_destroy(&dev->lock);\r\nerrorFWDATA1:\r\nkfree(dev);\r\nprintk(KERN_WARNING "Sensoray 2255 driver load failed: 0x%x\n", retval);\r\nreturn retval;\r\n}\r\nstatic void s2255_disconnect(struct usb_interface *interface)\r\n{\r\nstruct s2255_dev *dev = to_s2255_dev(usb_get_intfdata(interface));\r\nint i;\r\nint channels = atomic_read(&dev->num_channels);\r\nmutex_lock(&dev->lock);\r\nv4l2_device_disconnect(&dev->v4l2_dev);\r\nmutex_unlock(&dev->lock);\r\natomic_inc(&dev->num_channels);\r\nfor (i = 0; i < channels; i++)\r\nvideo_unregister_device(&dev->channel[i].vdev);\r\natomic_set(&dev->fw_data->fw_state, S2255_FW_DISCONNECTING);\r\nwake_up(&dev->fw_data->wait_fw);\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\ndev->channel[i].setmode_ready = 1;\r\nwake_up(&dev->channel[i].wait_setmode);\r\ndev->channel[i].vidstatus_ready = 1;\r\nwake_up(&dev->channel[i].wait_vidstatus);\r\n}\r\nif (atomic_dec_and_test(&dev->num_channels))\r\ns2255_destroy(dev);\r\ndev_info(&interface->dev, "%s\n", __func__);\r\n}
