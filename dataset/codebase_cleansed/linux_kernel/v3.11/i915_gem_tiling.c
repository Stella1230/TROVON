void\r\ni915_gem_detect_bit_6_swizzle(struct drm_device *dev)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nuint32_t swizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;\r\nuint32_t swizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;\r\nif (IS_VALLEYVIEW(dev)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n} else if (INTEL_INFO(dev)->gen >= 6) {\r\nuint32_t dimm_c0, dimm_c1;\r\ndimm_c0 = I915_READ(MAD_DIMM_C0);\r\ndimm_c1 = I915_READ(MAD_DIMM_C1);\r\ndimm_c0 &= MAD_DIMM_A_SIZE_MASK | MAD_DIMM_B_SIZE_MASK;\r\ndimm_c1 &= MAD_DIMM_A_SIZE_MASK | MAD_DIMM_B_SIZE_MASK;\r\nif (dimm_c0 == dimm_c1) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n} else {\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n}\r\n} else if (IS_GEN5(dev)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n} else if (IS_GEN2(dev)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n} else if (IS_MOBILE(dev) || (IS_GEN3(dev) && !IS_G33(dev))) {\r\nuint32_t dcc;\r\ndcc = I915_READ(DCC);\r\nswitch (dcc & DCC_ADDRESSING_MODE_MASK) {\r\ncase DCC_ADDRESSING_MODE_SINGLE_CHANNEL:\r\ncase DCC_ADDRESSING_MODE_DUAL_CHANNEL_ASYMMETRIC:\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\nbreak;\r\ncase DCC_ADDRESSING_MODE_DUAL_CHANNEL_INTERLEAVED:\r\nif (dcc & DCC_CHANNEL_XOR_DISABLE) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n} else if ((dcc & DCC_CHANNEL_XOR_BIT_17) == 0) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10_11;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9_11;\r\n} else {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10_17;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9_17;\r\n}\r\nbreak;\r\n}\r\nif (dcc == 0xffffffff) {\r\nDRM_ERROR("Couldn't read from MCHBAR. "\r\n"Disabling tiling.\n");\r\nswizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;\r\nswizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;\r\n}\r\n} else {\r\nif (I915_READ16(C0DRB3) != I915_READ16(C1DRB3)) {\r\nswizzle_x = I915_BIT_6_SWIZZLE_NONE;\r\nswizzle_y = I915_BIT_6_SWIZZLE_NONE;\r\n} else {\r\nswizzle_x = I915_BIT_6_SWIZZLE_9_10;\r\nswizzle_y = I915_BIT_6_SWIZZLE_9;\r\n}\r\n}\r\ndev_priv->mm.bit_6_swizzle_x = swizzle_x;\r\ndev_priv->mm.bit_6_swizzle_y = swizzle_y;\r\n}\r\nstatic bool\r\ni915_tiling_ok(struct drm_device *dev, int stride, int size, int tiling_mode)\r\n{\r\nint tile_width;\r\nif (tiling_mode == I915_TILING_NONE)\r\nreturn true;\r\nif (IS_GEN2(dev) ||\r\n(tiling_mode == I915_TILING_Y && HAS_128_BYTE_Y_TILING(dev)))\r\ntile_width = 128;\r\nelse\r\ntile_width = 512;\r\nif (INTEL_INFO(dev)->gen >= 7) {\r\nif (stride / 128 > GEN7_FENCE_MAX_PITCH_VAL)\r\nreturn false;\r\n} else if (INTEL_INFO(dev)->gen >= 4) {\r\nif (stride / 128 > I965_FENCE_MAX_PITCH_VAL)\r\nreturn false;\r\n} else {\r\nif (stride > 8192)\r\nreturn false;\r\nif (IS_GEN3(dev)) {\r\nif (size > I830_FENCE_MAX_SIZE_VAL << 20)\r\nreturn false;\r\n} else {\r\nif (size > I830_FENCE_MAX_SIZE_VAL << 19)\r\nreturn false;\r\n}\r\n}\r\nif (stride < tile_width)\r\nreturn false;\r\nif (INTEL_INFO(dev)->gen >= 4) {\r\nif (stride & (tile_width - 1))\r\nreturn false;\r\nreturn true;\r\n}\r\nif (stride & (stride - 1))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\ni915_gem_object_fence_ok(struct drm_i915_gem_object *obj, int tiling_mode)\r\n{\r\nu32 size;\r\nif (tiling_mode == I915_TILING_NONE)\r\nreturn true;\r\nif (INTEL_INFO(obj->base.dev)->gen >= 4)\r\nreturn true;\r\nif (INTEL_INFO(obj->base.dev)->gen == 3) {\r\nif (obj->gtt_offset & ~I915_FENCE_START_MASK)\r\nreturn false;\r\n} else {\r\nif (obj->gtt_offset & ~I830_FENCE_START_MASK)\r\nreturn false;\r\n}\r\nsize = i915_gem_get_gtt_size(obj->base.dev, obj->base.size, tiling_mode);\r\nif (obj->gtt_space->size != size)\r\nreturn false;\r\nif (obj->gtt_offset & (size - 1))\r\nreturn false;\r\nreturn true;\r\n}\r\nint\r\ni915_gem_set_tiling(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_i915_gem_set_tiling *args = data;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct drm_i915_gem_object *obj;\r\nint ret = 0;\r\nobj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));\r\nif (&obj->base == NULL)\r\nreturn -ENOENT;\r\nif (!i915_tiling_ok(dev,\r\nargs->stride, obj->base.size, args->tiling_mode)) {\r\ndrm_gem_object_unreference_unlocked(&obj->base);\r\nreturn -EINVAL;\r\n}\r\nif (obj->pin_count) {\r\ndrm_gem_object_unreference_unlocked(&obj->base);\r\nreturn -EBUSY;\r\n}\r\nif (args->tiling_mode == I915_TILING_NONE) {\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\r\nargs->stride = 0;\r\n} else {\r\nif (args->tiling_mode == I915_TILING_X)\r\nargs->swizzle_mode = dev_priv->mm.bit_6_swizzle_x;\r\nelse\r\nargs->swizzle_mode = dev_priv->mm.bit_6_swizzle_y;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_17)\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_9;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_9_10;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_UNKNOWN) {\r\nargs->tiling_mode = I915_TILING_NONE;\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\r\nargs->stride = 0;\r\n}\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nif (args->tiling_mode != obj->tiling_mode ||\r\nargs->stride != obj->stride) {\r\nobj->map_and_fenceable =\r\nobj->gtt_space == NULL ||\r\n(obj->gtt_offset + obj->base.size <= dev_priv->gtt.mappable_end &&\r\ni915_gem_object_fence_ok(obj, args->tiling_mode));\r\nif (!obj->map_and_fenceable) {\r\nu32 unfenced_alignment =\r\ni915_gem_get_gtt_alignment(dev, obj->base.size,\r\nargs->tiling_mode,\r\nfalse);\r\nif (obj->gtt_offset & (unfenced_alignment - 1))\r\nret = i915_gem_object_unbind(obj);\r\n}\r\nif (ret == 0) {\r\nobj->fence_dirty =\r\nobj->fenced_gpu_access ||\r\nobj->fence_reg != I915_FENCE_REG_NONE;\r\nobj->tiling_mode = args->tiling_mode;\r\nobj->stride = args->stride;\r\ni915_gem_release_mmap(obj);\r\n}\r\n}\r\nargs->stride = obj->stride;\r\nargs->tiling_mode = obj->tiling_mode;\r\nif (i915_gem_object_needs_bit17_swizzle(obj)) {\r\nif (obj->bit_17 == NULL) {\r\nobj->bit_17 = kmalloc(BITS_TO_LONGS(obj->base.size >> PAGE_SHIFT) *\r\nsizeof(long), GFP_KERNEL);\r\n}\r\n} else {\r\nkfree(obj->bit_17);\r\nobj->bit_17 = NULL;\r\n}\r\ndrm_gem_object_unreference(&obj->base);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nint\r\ni915_gem_get_tiling(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_i915_gem_get_tiling *args = data;\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct drm_i915_gem_object *obj;\r\nobj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));\r\nif (&obj->base == NULL)\r\nreturn -ENOENT;\r\nmutex_lock(&dev->struct_mutex);\r\nargs->tiling_mode = obj->tiling_mode;\r\nswitch (obj->tiling_mode) {\r\ncase I915_TILING_X:\r\nargs->swizzle_mode = dev_priv->mm.bit_6_swizzle_x;\r\nbreak;\r\ncase I915_TILING_Y:\r\nargs->swizzle_mode = dev_priv->mm.bit_6_swizzle_y;\r\nbreak;\r\ncase I915_TILING_NONE:\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_NONE;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown tiling mode\n");\r\n}\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_17)\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_9;\r\nif (args->swizzle_mode == I915_BIT_6_SWIZZLE_9_10_17)\r\nargs->swizzle_mode = I915_BIT_6_SWIZZLE_9_10;\r\ndrm_gem_object_unreference(&obj->base);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nstatic void\r\ni915_gem_swizzle_page(struct page *page)\r\n{\r\nchar temp[64];\r\nchar *vaddr;\r\nint i;\r\nvaddr = kmap(page);\r\nfor (i = 0; i < PAGE_SIZE; i += 128) {\r\nmemcpy(temp, &vaddr[i], 64);\r\nmemcpy(&vaddr[i], &vaddr[i + 64], 64);\r\nmemcpy(&vaddr[i + 64], temp, 64);\r\n}\r\nkunmap(page);\r\n}\r\nvoid\r\ni915_gem_object_do_bit_17_swizzle(struct drm_i915_gem_object *obj)\r\n{\r\nstruct sg_page_iter sg_iter;\r\nint i;\r\nif (obj->bit_17 == NULL)\r\nreturn;\r\ni = 0;\r\nfor_each_sg_page(obj->pages->sgl, &sg_iter, obj->pages->nents, 0) {\r\nstruct page *page = sg_page_iter_page(&sg_iter);\r\nchar new_bit_17 = page_to_phys(page) >> 17;\r\nif ((new_bit_17 & 0x1) !=\r\n(test_bit(i, obj->bit_17) != 0)) {\r\ni915_gem_swizzle_page(page);\r\nset_page_dirty(page);\r\n}\r\ni++;\r\n}\r\n}\r\nvoid\r\ni915_gem_object_save_bit_17_swizzle(struct drm_i915_gem_object *obj)\r\n{\r\nstruct sg_page_iter sg_iter;\r\nint page_count = obj->base.size >> PAGE_SHIFT;\r\nint i;\r\nif (obj->bit_17 == NULL) {\r\nobj->bit_17 = kmalloc(BITS_TO_LONGS(page_count) *\r\nsizeof(long), GFP_KERNEL);\r\nif (obj->bit_17 == NULL) {\r\nDRM_ERROR("Failed to allocate memory for bit 17 "\r\n"record\n");\r\nreturn;\r\n}\r\n}\r\ni = 0;\r\nfor_each_sg_page(obj->pages->sgl, &sg_iter, obj->pages->nents, 0) {\r\nif (page_to_phys(sg_page_iter_page(&sg_iter)) & (1 << 17))\r\n__set_bit(i, obj->bit_17);\r\nelse\r\n__clear_bit(i, obj->bit_17);\r\ni++;\r\n}\r\n}
