void nfnl_lock(__u8 subsys_id)\r\n{\r\nmutex_lock(&table[subsys_id].mutex);\r\n}\r\nvoid nfnl_unlock(__u8 subsys_id)\r\n{\r\nmutex_unlock(&table[subsys_id].mutex);\r\n}\r\nint nfnetlink_subsys_register(const struct nfnetlink_subsystem *n)\r\n{\r\nnfnl_lock(n->subsys_id);\r\nif (table[n->subsys_id].subsys) {\r\nnfnl_unlock(n->subsys_id);\r\nreturn -EBUSY;\r\n}\r\nrcu_assign_pointer(table[n->subsys_id].subsys, n);\r\nnfnl_unlock(n->subsys_id);\r\nreturn 0;\r\n}\r\nint nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n)\r\n{\r\nnfnl_lock(n->subsys_id);\r\ntable[n->subsys_id].subsys = NULL;\r\nnfnl_unlock(n->subsys_id);\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nstatic inline const struct nfnetlink_subsystem *nfnetlink_get_subsys(u_int16_t type)\r\n{\r\nu_int8_t subsys_id = NFNL_SUBSYS_ID(type);\r\nif (subsys_id >= NFNL_SUBSYS_COUNT)\r\nreturn NULL;\r\nreturn rcu_dereference(table[subsys_id].subsys);\r\n}\r\nstatic inline const struct nfnl_callback *\r\nnfnetlink_find_client(u_int16_t type, const struct nfnetlink_subsystem *ss)\r\n{\r\nu_int8_t cb_id = NFNL_MSG_TYPE(type);\r\nif (cb_id >= ss->cb_count)\r\nreturn NULL;\r\nreturn &ss->cb[cb_id];\r\n}\r\nint nfnetlink_has_listeners(struct net *net, unsigned int group)\r\n{\r\nreturn netlink_has_listeners(net->nfnl, group);\r\n}\r\nstruct sk_buff *nfnetlink_alloc_skb(struct net *net, unsigned int size,\r\nu32 dst_portid, gfp_t gfp_mask)\r\n{\r\nreturn netlink_alloc_skb(net->nfnl, size, dst_portid, gfp_mask);\r\n}\r\nint nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,\r\nunsigned int group, int echo, gfp_t flags)\r\n{\r\nreturn nlmsg_notify(net->nfnl, skb, portid, group, echo, flags);\r\n}\r\nint nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error)\r\n{\r\nreturn netlink_set_err(net->nfnl, portid, group, error);\r\n}\r\nint nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid,\r\nint flags)\r\n{\r\nreturn netlink_unicast(net->nfnl, skb, portid, flags);\r\n}\r\nstatic int nfnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nconst struct nfnl_callback *nc;\r\nconst struct nfnetlink_subsystem *ss;\r\nint type, err;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (nlmsg_len(nlh) < sizeof(struct nfgenmsg))\r\nreturn 0;\r\ntype = nlh->nlmsg_type;\r\nreplay:\r\nrcu_read_lock();\r\nss = nfnetlink_get_subsys(type);\r\nif (!ss) {\r\n#ifdef CONFIG_MODULES\r\nrcu_read_unlock();\r\nrequest_module("nfnetlink-subsys-%d", NFNL_SUBSYS_ID(type));\r\nrcu_read_lock();\r\nss = nfnetlink_get_subsys(type);\r\nif (!ss)\r\n#endif\r\n{\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\n}\r\nnc = nfnetlink_find_client(type, ss);\r\nif (!nc) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\n{\r\nint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\r\nu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\r\nstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\r\nstruct nlattr *attr = (void *)nlh + min_len;\r\nint attrlen = nlh->nlmsg_len - min_len;\r\n__u8 subsys_id = NFNL_SUBSYS_ID(type);\r\nerr = nla_parse(cda, ss->cb[cb_id].attr_count,\r\nattr, attrlen, ss->cb[cb_id].policy);\r\nif (err < 0) {\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nif (nc->call_rcu) {\r\nerr = nc->call_rcu(net->nfnl, skb, nlh,\r\n(const struct nlattr **)cda);\r\nrcu_read_unlock();\r\n} else {\r\nrcu_read_unlock();\r\nnfnl_lock(subsys_id);\r\nif (rcu_dereference_protected(table[subsys_id].subsys,\r\nlockdep_is_held(&table[subsys_id].mutex)) != ss ||\r\nnfnetlink_find_client(type, ss) != nc)\r\nerr = -EAGAIN;\r\nelse if (nc->call)\r\nerr = nc->call(net->nfnl, skb, nlh,\r\n(const struct nlattr **)cda);\r\nelse\r\nerr = -EINVAL;\r\nnfnl_unlock(subsys_id);\r\n}\r\nif (err == -EAGAIN)\r\ngoto replay;\r\nreturn err;\r\n}\r\n}\r\nstatic void nfnetlink_rcv(struct sk_buff *skb)\r\n{\r\nnetlink_rcv_skb(skb, &nfnetlink_rcv_msg);\r\n}\r\nstatic void nfnetlink_bind(int group)\r\n{\r\nconst struct nfnetlink_subsystem *ss;\r\nint type = nfnl_group2type[group];\r\nrcu_read_lock();\r\nss = nfnetlink_get_subsys(type);\r\nif (!ss) {\r\nrcu_read_unlock();\r\nrequest_module("nfnetlink-subsys-%d", type);\r\nreturn;\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int __net_init nfnetlink_net_init(struct net *net)\r\n{\r\nstruct sock *nfnl;\r\nstruct netlink_kernel_cfg cfg = {\r\n.groups = NFNLGRP_MAX,\r\n.input = nfnetlink_rcv,\r\n#ifdef CONFIG_MODULES\r\n.bind = nfnetlink_bind,\r\n#endif\r\n};\r\nnfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);\r\nif (!nfnl)\r\nreturn -ENOMEM;\r\nnet->nfnl_stash = nfnl;\r\nrcu_assign_pointer(net->nfnl, nfnl);\r\nreturn 0;\r\n}\r\nstatic void __net_exit nfnetlink_net_exit_batch(struct list_head *net_exit_list)\r\n{\r\nstruct net *net;\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nRCU_INIT_POINTER(net->nfnl, NULL);\r\nsynchronize_net();\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nnetlink_kernel_release(net->nfnl_stash);\r\n}\r\nstatic int __init nfnetlink_init(void)\r\n{\r\nint i;\r\nfor (i=0; i<NFNL_SUBSYS_COUNT; i++)\r\nmutex_init(&table[i].mutex);\r\npr_info("Netfilter messages via NETLINK v%s.\n", nfversion);\r\nreturn register_pernet_subsys(&nfnetlink_net_ops);\r\n}\r\nstatic void __exit nfnetlink_exit(void)\r\n{\r\npr_info("Removing netfilter NETLINK layer.\n");\r\nunregister_pernet_subsys(&nfnetlink_net_ops);\r\n}
