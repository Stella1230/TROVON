static struct ffs_function *ffs_func_from_usb(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct ffs_function, function);\r\n}\r\nstatic void ffs_ep0_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct ffs_data *ffs = req->context;\r\ncomplete_all(&ffs->ep0req_completion);\r\n}\r\nstatic int __ffs_ep0_queue_wait(struct ffs_data *ffs, char *data, size_t len)\r\n{\r\nstruct usb_request *req = ffs->ep0req;\r\nint ret;\r\nreq->zero = len < le16_to_cpu(ffs->ev.setup.wLength);\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nreq->buf = data;\r\nreq->length = len;\r\nif (req->buf == NULL)\r\nreq->buf = (void *)0xDEADBABE;\r\nINIT_COMPLETION(ffs->ep0req_completion);\r\nret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nret = wait_for_completion_interruptible(&ffs->ep0req_completion);\r\nif (unlikely(ret)) {\r\nusb_ep_dequeue(ffs->gadget->ep0, req);\r\nreturn -EINTR;\r\n}\r\nffs->setup_state = FFS_NO_SETUP;\r\nreturn ffs->ep0req_status;\r\n}\r\nstatic int __ffs_ep0_stall(struct ffs_data *ffs)\r\n{\r\nif (ffs->ev.can_stall) {\r\npr_vdebug("ep0 stall\n");\r\nusb_ep_set_halt(ffs->gadget->ep0);\r\nffs->setup_state = FFS_NO_SETUP;\r\nreturn -EL2HLT;\r\n} else {\r\npr_debug("bogus ep0 stall!\n");\r\nreturn -ESRCH;\r\n}\r\n}\r\nstatic ssize_t ffs_ep0_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *ptr)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nssize_t ret;\r\nchar *data;\r\nENTER();\r\nif (FFS_SETUP_STATE(ffs) == FFS_SETUP_CANCELED)\r\nreturn -EIDRM;\r\nret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nswitch (ffs->state) {\r\ncase FFS_READ_DESCRIPTORS:\r\ncase FFS_READ_STRINGS:\r\nif (unlikely(len < 16)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndata = ffs_prepare_buffer(buf, len);\r\nif (IS_ERR(data)) {\r\nret = PTR_ERR(data);\r\nbreak;\r\n}\r\nif (ffs->state == FFS_READ_DESCRIPTORS) {\r\npr_info("read descriptors\n");\r\nret = __ffs_data_got_descs(ffs, data, len);\r\nif (unlikely(ret < 0))\r\nbreak;\r\nffs->state = FFS_READ_STRINGS;\r\nret = len;\r\n} else {\r\npr_info("read strings\n");\r\nret = __ffs_data_got_strings(ffs, data, len);\r\nif (unlikely(ret < 0))\r\nbreak;\r\nret = ffs_epfiles_create(ffs);\r\nif (unlikely(ret)) {\r\nffs->state = FFS_CLOSING;\r\nbreak;\r\n}\r\nffs->state = FFS_ACTIVE;\r\nmutex_unlock(&ffs->mutex);\r\nret = functionfs_ready_callback(ffs);\r\nif (unlikely(ret < 0)) {\r\nffs->state = FFS_CLOSING;\r\nreturn ret;\r\n}\r\nset_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags);\r\nreturn len;\r\n}\r\nbreak;\r\ncase FFS_ACTIVE:\r\ndata = NULL;\r\nspin_lock_irq(&ffs->ev.waitq.lock);\r\nswitch (FFS_SETUP_STATE(ffs)) {\r\ncase FFS_SETUP_CANCELED:\r\nret = -EIDRM;\r\ngoto done_spin;\r\ncase FFS_NO_SETUP:\r\nret = -ESRCH;\r\ngoto done_spin;\r\ncase FFS_SETUP_PENDING:\r\nbreak;\r\n}\r\nif (!(ffs->ev.setup.bRequestType & USB_DIR_IN)) {\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nret = __ffs_ep0_stall(ffs);\r\nbreak;\r\n}\r\nlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\ndata = ffs_prepare_buffer(buf, len);\r\nif (IS_ERR(data)) {\r\nret = PTR_ERR(data);\r\nbreak;\r\n}\r\nspin_lock_irq(&ffs->ev.waitq.lock);\r\nif (FFS_SETUP_STATE(ffs) == FFS_SETUP_CANCELED) {\r\nret = -EIDRM;\r\ndone_spin:\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\n} else {\r\nret = __ffs_ep0_queue_wait(ffs, data, len);\r\n}\r\nkfree(data);\r\nbreak;\r\ndefault:\r\nret = -EBADFD;\r\nbreak;\r\n}\r\nmutex_unlock(&ffs->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t __ffs_ep0_read_events(struct ffs_data *ffs, char __user *buf,\r\nsize_t n)\r\n{\r\nstruct usb_functionfs_event events[n];\r\nunsigned i = 0;\r\nmemset(events, 0, sizeof events);\r\ndo {\r\nevents[i].type = ffs->ev.types[i];\r\nif (events[i].type == FUNCTIONFS_SETUP) {\r\nevents[i].u.setup = ffs->ev.setup;\r\nffs->setup_state = FFS_SETUP_PENDING;\r\n}\r\n} while (++i < n);\r\nif (n < ffs->ev.count) {\r\nffs->ev.count -= n;\r\nmemmove(ffs->ev.types, ffs->ev.types + n,\r\nffs->ev.count * sizeof *ffs->ev.types);\r\n} else {\r\nffs->ev.count = 0;\r\n}\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nmutex_unlock(&ffs->mutex);\r\nreturn unlikely(__copy_to_user(buf, events, sizeof events))\r\n? -EFAULT : sizeof events;\r\n}\r\nstatic ssize_t ffs_ep0_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *ptr)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nchar *data = NULL;\r\nsize_t n;\r\nint ret;\r\nENTER();\r\nif (FFS_SETUP_STATE(ffs) == FFS_SETUP_CANCELED)\r\nreturn -EIDRM;\r\nret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nif (ffs->state != FFS_ACTIVE) {\r\nret = -EBADFD;\r\ngoto done_mutex;\r\n}\r\nspin_lock_irq(&ffs->ev.waitq.lock);\r\nswitch (FFS_SETUP_STATE(ffs)) {\r\ncase FFS_SETUP_CANCELED:\r\nret = -EIDRM;\r\nbreak;\r\ncase FFS_NO_SETUP:\r\nn = len / sizeof(struct usb_functionfs_event);\r\nif (unlikely(!n)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif ((file->f_flags & O_NONBLOCK) && !ffs->ev.count) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (wait_event_interruptible_exclusive_locked_irq(ffs->ev.waitq,\r\nffs->ev.count)) {\r\nret = -EINTR;\r\nbreak;\r\n}\r\nreturn __ffs_ep0_read_events(ffs, buf,\r\nmin(n, (size_t)ffs->ev.count));\r\ncase FFS_SETUP_PENDING:\r\nif (ffs->ev.setup.bRequestType & USB_DIR_IN) {\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nret = __ffs_ep0_stall(ffs);\r\ngoto done_mutex;\r\n}\r\nlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\nif (likely(len)) {\r\ndata = kmalloc(len, GFP_KERNEL);\r\nif (unlikely(!data)) {\r\nret = -ENOMEM;\r\ngoto done_mutex;\r\n}\r\n}\r\nspin_lock_irq(&ffs->ev.waitq.lock);\r\nif (FFS_SETUP_STATE(ffs) == FFS_SETUP_CANCELED) {\r\nret = -EIDRM;\r\nbreak;\r\n}\r\nret = __ffs_ep0_queue_wait(ffs, data, len);\r\nif (likely(ret > 0) && unlikely(__copy_to_user(buf, data, len)))\r\nret = -EFAULT;\r\ngoto done_mutex;\r\ndefault:\r\nret = -EBADFD;\r\nbreak;\r\n}\r\nspin_unlock_irq(&ffs->ev.waitq.lock);\r\ndone_mutex:\r\nmutex_unlock(&ffs->mutex);\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int ffs_ep0_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ffs_data *ffs = inode->i_private;\r\nENTER();\r\nif (unlikely(ffs->state == FFS_CLOSING))\r\nreturn -EBUSY;\r\nfile->private_data = ffs;\r\nffs_data_opened(ffs);\r\nreturn 0;\r\n}\r\nstatic int ffs_ep0_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nENTER();\r\nffs_data_closed(ffs);\r\nreturn 0;\r\n}\r\nstatic long ffs_ep0_ioctl(struct file *file, unsigned code, unsigned long value)\r\n{\r\nstruct ffs_data *ffs = file->private_data;\r\nstruct usb_gadget *gadget = ffs->gadget;\r\nlong ret;\r\nENTER();\r\nif (code == FUNCTIONFS_INTERFACE_REVMAP) {\r\nstruct ffs_function *func = ffs->func;\r\nret = func ? ffs_func_revmap_intf(func, value) : -ENODEV;\r\n} else if (gadget && gadget->ops->ioctl) {\r\nret = gadget->ops->ioctl(gadget, code, value);\r\n} else {\r\nret = -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ffs_epfile_io_complete(struct usb_ep *_ep, struct usb_request *req)\r\n{\r\nENTER();\r\nif (likely(req->context)) {\r\nstruct ffs_ep *ep = _ep->driver_data;\r\nep->status = req->status ? req->status : req->actual;\r\ncomplete(req->context);\r\n}\r\n}\r\nstatic ssize_t ffs_epfile_io(struct file *file,\r\nchar __user *buf, size_t len, int read)\r\n{\r\nstruct ffs_epfile *epfile = file->private_data;\r\nstruct ffs_ep *ep;\r\nchar *data = NULL;\r\nssize_t ret;\r\nint halt;\r\ngoto first_try;\r\ndo {\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nmutex_unlock(&epfile->mutex);\r\nfirst_try:\r\nif (WARN_ON(epfile->ffs->state != FFS_ACTIVE)) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nep = epfile->ep;\r\nif (!ep) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\ngoto error;\r\n}\r\nif (wait_event_interruptible(epfile->wait,\r\n(ep = epfile->ep))) {\r\nret = -EINTR;\r\ngoto error;\r\n}\r\n}\r\nhalt = !read == !epfile->in;\r\nif (halt && epfile->isoc) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (!halt && !data) {\r\ndata = kzalloc(len, GFP_KERNEL);\r\nif (unlikely(!data))\r\nreturn -ENOMEM;\r\nif (!read &&\r\nunlikely(__copy_from_user(data, buf, len))) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nret = ffs_mutex_lock(&epfile->mutex,\r\nfile->f_flags & O_NONBLOCK);\r\nif (unlikely(ret))\r\ngoto error;\r\nspin_lock_irq(&epfile->ffs->eps_lock);\r\n} while (unlikely(epfile->ep != ep));\r\nif (unlikely(halt)) {\r\nif (likely(epfile->ep == ep) && !WARN_ON(!ep->ep))\r\nusb_ep_set_halt(ep->ep);\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nret = -EBADMSG;\r\n} else {\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nstruct usb_request *req = ep->req;\r\nreq->context = &done;\r\nreq->complete = ffs_epfile_io_complete;\r\nreq->buf = data;\r\nreq->length = len;\r\nret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nif (unlikely(ret < 0)) {\r\n} else if (unlikely(wait_for_completion_interruptible(&done))) {\r\nret = -EINTR;\r\nusb_ep_dequeue(ep->ep, req);\r\n} else {\r\nret = ep->status;\r\nif (read && ret > 0 &&\r\nunlikely(copy_to_user(buf, data, ret)))\r\nret = -EFAULT;\r\n}\r\n}\r\nmutex_unlock(&epfile->mutex);\r\nerror:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nffs_epfile_write(struct file *file, const char __user *buf, size_t len,\r\nloff_t *ptr)\r\n{\r\nENTER();\r\nreturn ffs_epfile_io(file, (char __user *)buf, len, 0);\r\n}\r\nstatic ssize_t\r\nffs_epfile_read(struct file *file, char __user *buf, size_t len, loff_t *ptr)\r\n{\r\nENTER();\r\nreturn ffs_epfile_io(file, buf, len, 1);\r\n}\r\nstatic int\r\nffs_epfile_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ffs_epfile *epfile = inode->i_private;\r\nENTER();\r\nif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\r\nreturn -ENODEV;\r\nfile->private_data = epfile;\r\nffs_data_opened(epfile->ffs);\r\nreturn 0;\r\n}\r\nstatic int\r\nffs_epfile_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ffs_epfile *epfile = inode->i_private;\r\nENTER();\r\nffs_data_closed(epfile->ffs);\r\nreturn 0;\r\n}\r\nstatic long ffs_epfile_ioctl(struct file *file, unsigned code,\r\nunsigned long value)\r\n{\r\nstruct ffs_epfile *epfile = file->private_data;\r\nint ret;\r\nENTER();\r\nif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\r\nreturn -ENODEV;\r\nspin_lock_irq(&epfile->ffs->eps_lock);\r\nif (likely(epfile->ep)) {\r\nswitch (code) {\r\ncase FUNCTIONFS_FIFO_STATUS:\r\nret = usb_ep_fifo_status(epfile->ep->ep);\r\nbreak;\r\ncase FUNCTIONFS_FIFO_FLUSH:\r\nusb_ep_fifo_flush(epfile->ep->ep);\r\nret = 0;\r\nbreak;\r\ncase FUNCTIONFS_CLEAR_HALT:\r\nret = usb_ep_clear_halt(epfile->ep->ep);\r\nbreak;\r\ncase FUNCTIONFS_ENDPOINT_REVMAP:\r\nret = epfile->ep->num;\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\n}\r\n} else {\r\nret = -ENODEV;\r\n}\r\nspin_unlock_irq(&epfile->ffs->eps_lock);\r\nreturn ret;\r\n}\r\nstatic struct inode *__must_check\r\nffs_sb_make_inode(struct super_block *sb, void *data,\r\nconst struct file_operations *fops,\r\nconst struct inode_operations *iops,\r\nstruct ffs_file_perms *perms)\r\n{\r\nstruct inode *inode;\r\nENTER();\r\ninode = new_inode(sb);\r\nif (likely(inode)) {\r\nstruct timespec current_time = CURRENT_TIME;\r\ninode->i_ino = get_next_ino();\r\ninode->i_mode = perms->mode;\r\ninode->i_uid = perms->uid;\r\ninode->i_gid = perms->gid;\r\ninode->i_atime = current_time;\r\ninode->i_mtime = current_time;\r\ninode->i_ctime = current_time;\r\ninode->i_private = data;\r\nif (fops)\r\ninode->i_fop = fops;\r\nif (iops)\r\ninode->i_op = iops;\r\n}\r\nreturn inode;\r\n}\r\nstatic struct inode *ffs_sb_create_file(struct super_block *sb,\r\nconst char *name, void *data,\r\nconst struct file_operations *fops,\r\nstruct dentry **dentry_p)\r\n{\r\nstruct ffs_data *ffs = sb->s_fs_info;\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nENTER();\r\ndentry = d_alloc_name(sb->s_root, name);\r\nif (unlikely(!dentry))\r\nreturn NULL;\r\ninode = ffs_sb_make_inode(sb, data, fops, NULL, &ffs->file_perms);\r\nif (unlikely(!inode)) {\r\ndput(dentry);\r\nreturn NULL;\r\n}\r\nd_add(dentry, inode);\r\nif (dentry_p)\r\n*dentry_p = dentry;\r\nreturn inode;\r\n}\r\nstatic int ffs_sb_fill(struct super_block *sb, void *_data, int silent)\r\n{\r\nstruct ffs_sb_fill_data *data = _data;\r\nstruct inode *inode;\r\nstruct ffs_data *ffs;\r\nENTER();\r\nffs = ffs_data_new();\r\nif (unlikely(!ffs))\r\ngoto Enomem;\r\nffs->sb = sb;\r\nffs->dev_name = kstrdup(data->dev_name, GFP_KERNEL);\r\nif (unlikely(!ffs->dev_name))\r\ngoto Enomem;\r\nffs->file_perms = data->perms;\r\nffs->private_data = data->private_data;\r\ndata->ffs_data = ffs;\r\nsb->s_fs_info = ffs;\r\nsb->s_blocksize = PAGE_CACHE_SIZE;\r\nsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\r\nsb->s_magic = FUNCTIONFS_MAGIC;\r\nsb->s_op = &ffs_sb_operations;\r\nsb->s_time_gran = 1;\r\ndata->perms.mode = data->root_mode;\r\ninode = ffs_sb_make_inode(sb, NULL,\r\n&simple_dir_operations,\r\n&simple_dir_inode_operations,\r\n&data->perms);\r\nsb->s_root = d_make_root(inode);\r\nif (unlikely(!sb->s_root))\r\ngoto Enomem;\r\nif (unlikely(!ffs_sb_create_file(sb, "ep0", ffs,\r\n&ffs_ep0_operations, NULL)))\r\ngoto Enomem;\r\nreturn 0;\r\nEnomem:\r\nreturn -ENOMEM;\r\n}\r\nstatic int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts)\r\n{\r\nENTER();\r\nif (!opts || !*opts)\r\nreturn 0;\r\nfor (;;) {\r\nunsigned long value;\r\nchar *eq, *comma;\r\ncomma = strchr(opts, ',');\r\nif (comma)\r\n*comma = 0;\r\neq = strchr(opts, '=');\r\nif (unlikely(!eq)) {\r\npr_err("'=' missing in %s\n", opts);\r\nreturn -EINVAL;\r\n}\r\n*eq = 0;\r\nif (kstrtoul(eq + 1, 0, &value)) {\r\npr_err("%s: invalid value: %s\n", opts, eq + 1);\r\nreturn -EINVAL;\r\n}\r\nswitch (eq - opts) {\r\ncase 5:\r\nif (!memcmp(opts, "rmode", 5))\r\ndata->root_mode = (value & 0555) | S_IFDIR;\r\nelse if (!memcmp(opts, "fmode", 5))\r\ndata->perms.mode = (value & 0666) | S_IFREG;\r\nelse\r\ngoto invalid;\r\nbreak;\r\ncase 4:\r\nif (!memcmp(opts, "mode", 4)) {\r\ndata->root_mode = (value & 0555) | S_IFDIR;\r\ndata->perms.mode = (value & 0666) | S_IFREG;\r\n} else {\r\ngoto invalid;\r\n}\r\nbreak;\r\ncase 3:\r\nif (!memcmp(opts, "uid", 3)) {\r\ndata->perms.uid = make_kuid(current_user_ns(), value);\r\nif (!uid_valid(data->perms.uid)) {\r\npr_err("%s: unmapped value: %lu\n", opts, value);\r\nreturn -EINVAL;\r\n}\r\n} else if (!memcmp(opts, "gid", 3)) {\r\ndata->perms.gid = make_kgid(current_user_ns(), value);\r\nif (!gid_valid(data->perms.gid)) {\r\npr_err("%s: unmapped value: %lu\n", opts, value);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ngoto invalid;\r\n}\r\nbreak;\r\ndefault:\r\ninvalid:\r\npr_err("%s: invalid option\n", opts);\r\nreturn -EINVAL;\r\n}\r\nif (!comma)\r\nbreak;\r\nopts = comma + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dentry *\r\nffs_fs_mount(struct file_system_type *t, int flags,\r\nconst char *dev_name, void *opts)\r\n{\r\nstruct ffs_sb_fill_data data = {\r\n.perms = {\r\n.mode = S_IFREG | 0600,\r\n.uid = GLOBAL_ROOT_UID,\r\n.gid = GLOBAL_ROOT_GID,\r\n},\r\n.root_mode = S_IFDIR | 0500,\r\n};\r\nstruct dentry *rv;\r\nint ret;\r\nvoid *ffs_dev;\r\nENTER();\r\nret = ffs_fs_parse_opts(&data, opts);\r\nif (unlikely(ret < 0))\r\nreturn ERR_PTR(ret);\r\nffs_dev = functionfs_acquire_dev_callback(dev_name);\r\nif (IS_ERR(ffs_dev))\r\nreturn ffs_dev;\r\ndata.dev_name = dev_name;\r\ndata.private_data = ffs_dev;\r\nrv = mount_nodev(t, flags, &data, ffs_sb_fill);\r\nif (IS_ERR(rv))\r\nfunctionfs_release_dev_callback(data.ffs_data);\r\nreturn rv;\r\n}\r\nstatic void\r\nffs_fs_kill_sb(struct super_block *sb)\r\n{\r\nENTER();\r\nkill_litter_super(sb);\r\nif (sb->s_fs_info) {\r\nfunctionfs_release_dev_callback(sb->s_fs_info);\r\nffs_data_put(sb->s_fs_info);\r\n}\r\n}\r\nstatic int functionfs_init(void)\r\n{\r\nint ret;\r\nENTER();\r\nret = register_filesystem(&ffs_fs_type);\r\nif (likely(!ret))\r\npr_info("file system registered\n");\r\nelse\r\npr_err("failed registering file system (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic void functionfs_cleanup(void)\r\n{\r\nENTER();\r\npr_info("unloading\n");\r\nunregister_filesystem(&ffs_fs_type);\r\n}\r\nstatic void ffs_data_get(struct ffs_data *ffs)\r\n{\r\nENTER();\r\natomic_inc(&ffs->ref);\r\n}\r\nstatic void ffs_data_opened(struct ffs_data *ffs)\r\n{\r\nENTER();\r\natomic_inc(&ffs->ref);\r\natomic_inc(&ffs->opened);\r\n}\r\nstatic void ffs_data_put(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nif (unlikely(atomic_dec_and_test(&ffs->ref))) {\r\npr_info("%s(): freeing\n", __func__);\r\nffs_data_clear(ffs);\r\nBUG_ON(waitqueue_active(&ffs->ev.waitq) ||\r\nwaitqueue_active(&ffs->ep0req_completion.wait));\r\nkfree(ffs->dev_name);\r\nkfree(ffs);\r\n}\r\n}\r\nstatic void ffs_data_closed(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nif (atomic_dec_and_test(&ffs->opened)) {\r\nffs->state = FFS_CLOSING;\r\nffs_data_reset(ffs);\r\n}\r\nffs_data_put(ffs);\r\n}\r\nstatic struct ffs_data *ffs_data_new(void)\r\n{\r\nstruct ffs_data *ffs = kzalloc(sizeof *ffs, GFP_KERNEL);\r\nif (unlikely(!ffs))\r\nreturn 0;\r\nENTER();\r\natomic_set(&ffs->ref, 1);\r\natomic_set(&ffs->opened, 0);\r\nffs->state = FFS_READ_DESCRIPTORS;\r\nmutex_init(&ffs->mutex);\r\nspin_lock_init(&ffs->eps_lock);\r\ninit_waitqueue_head(&ffs->ev.waitq);\r\ninit_completion(&ffs->ep0req_completion);\r\nffs->ev.can_stall = 1;\r\nreturn ffs;\r\n}\r\nstatic void ffs_data_clear(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nif (test_and_clear_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags))\r\nfunctionfs_closed_callback(ffs);\r\nBUG_ON(ffs->gadget);\r\nif (ffs->epfiles)\r\nffs_epfiles_destroy(ffs->epfiles, ffs->eps_count);\r\nkfree(ffs->raw_descs);\r\nkfree(ffs->raw_strings);\r\nkfree(ffs->stringtabs);\r\n}\r\nstatic void ffs_data_reset(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nffs_data_clear(ffs);\r\nffs->epfiles = NULL;\r\nffs->raw_descs = NULL;\r\nffs->raw_strings = NULL;\r\nffs->stringtabs = NULL;\r\nffs->raw_descs_length = 0;\r\nffs->raw_fs_descs_length = 0;\r\nffs->fs_descs_count = 0;\r\nffs->hs_descs_count = 0;\r\nffs->strings_count = 0;\r\nffs->interfaces_count = 0;\r\nffs->eps_count = 0;\r\nffs->ev.count = 0;\r\nffs->state = FFS_READ_DESCRIPTORS;\r\nffs->setup_state = FFS_NO_SETUP;\r\nffs->flags = 0;\r\n}\r\nstatic int functionfs_bind(struct ffs_data *ffs, struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_gadget_strings **lang;\r\nint first_id;\r\nENTER();\r\nif (WARN_ON(ffs->state != FFS_ACTIVE\r\n|| test_and_set_bit(FFS_FL_BOUND, &ffs->flags)))\r\nreturn -EBADFD;\r\nfirst_id = usb_string_ids_n(cdev, ffs->strings_count);\r\nif (unlikely(first_id < 0))\r\nreturn first_id;\r\nffs->ep0req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);\r\nif (unlikely(!ffs->ep0req))\r\nreturn -ENOMEM;\r\nffs->ep0req->complete = ffs_ep0_complete;\r\nffs->ep0req->context = ffs;\r\nlang = ffs->stringtabs;\r\nfor (lang = ffs->stringtabs; *lang; ++lang) {\r\nstruct usb_string *str = (*lang)->strings;\r\nint id = first_id;\r\nfor (; str->s; ++id, ++str)\r\nstr->id = id;\r\n}\r\nffs->gadget = cdev->gadget;\r\nffs_data_get(ffs);\r\nreturn 0;\r\n}\r\nstatic void functionfs_unbind(struct ffs_data *ffs)\r\n{\r\nENTER();\r\nif (!WARN_ON(!ffs->gadget)) {\r\nusb_ep_free_request(ffs->gadget->ep0, ffs->ep0req);\r\nffs->ep0req = NULL;\r\nffs->gadget = NULL;\r\nffs_data_put(ffs);\r\nclear_bit(FFS_FL_BOUND, &ffs->flags);\r\n}\r\n}\r\nstatic int ffs_epfiles_create(struct ffs_data *ffs)\r\n{\r\nstruct ffs_epfile *epfile, *epfiles;\r\nunsigned i, count;\r\nENTER();\r\ncount = ffs->eps_count;\r\nepfiles = kcalloc(count, sizeof(*epfiles), GFP_KERNEL);\r\nif (!epfiles)\r\nreturn -ENOMEM;\r\nepfile = epfiles;\r\nfor (i = 1; i <= count; ++i, ++epfile) {\r\nepfile->ffs = ffs;\r\nmutex_init(&epfile->mutex);\r\ninit_waitqueue_head(&epfile->wait);\r\nsprintf(epfiles->name, "ep%u", i);\r\nif (!unlikely(ffs_sb_create_file(ffs->sb, epfiles->name, epfile,\r\n&ffs_epfile_operations,\r\n&epfile->dentry))) {\r\nffs_epfiles_destroy(epfiles, i - 1);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nffs->epfiles = epfiles;\r\nreturn 0;\r\n}\r\nstatic void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count)\r\n{\r\nstruct ffs_epfile *epfile = epfiles;\r\nENTER();\r\nfor (; count; --count, ++epfile) {\r\nBUG_ON(mutex_is_locked(&epfile->mutex) ||\r\nwaitqueue_active(&epfile->wait));\r\nif (epfile->dentry) {\r\nd_delete(epfile->dentry);\r\ndput(epfile->dentry);\r\nepfile->dentry = NULL;\r\n}\r\n}\r\nkfree(epfiles);\r\n}\r\nstatic int functionfs_bind_config(struct usb_composite_dev *cdev,\r\nstruct usb_configuration *c,\r\nstruct ffs_data *ffs)\r\n{\r\nstruct ffs_function *func;\r\nint ret;\r\nENTER();\r\nfunc = kzalloc(sizeof *func, GFP_KERNEL);\r\nif (unlikely(!func))\r\nreturn -ENOMEM;\r\nfunc->function.name = "Function FS Gadget";\r\nfunc->function.strings = ffs->stringtabs;\r\nfunc->function.bind = ffs_func_bind;\r\nfunc->function.unbind = ffs_func_unbind;\r\nfunc->function.set_alt = ffs_func_set_alt;\r\nfunc->function.disable = ffs_func_disable;\r\nfunc->function.setup = ffs_func_setup;\r\nfunc->function.suspend = ffs_func_suspend;\r\nfunc->function.resume = ffs_func_resume;\r\nfunc->conf = c;\r\nfunc->gadget = cdev->gadget;\r\nfunc->ffs = ffs;\r\nffs_data_get(ffs);\r\nret = usb_add_function(c, &func->function);\r\nif (unlikely(ret))\r\nffs_func_free(func);\r\nreturn ret;\r\n}\r\nstatic void ffs_func_free(struct ffs_function *func)\r\n{\r\nstruct ffs_ep *ep = func->eps;\r\nunsigned count = func->ffs->eps_count;\r\nunsigned long flags;\r\nENTER();\r\nspin_lock_irqsave(&func->ffs->eps_lock, flags);\r\ndo {\r\nif (ep->ep && ep->req)\r\nusb_ep_free_request(ep->ep, ep->req);\r\nep->req = NULL;\r\n++ep;\r\n} while (--count);\r\nspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\r\nffs_data_put(func->ffs);\r\nkfree(func->eps);\r\nkfree(func);\r\n}\r\nstatic void ffs_func_eps_disable(struct ffs_function *func)\r\n{\r\nstruct ffs_ep *ep = func->eps;\r\nstruct ffs_epfile *epfile = func->ffs->epfiles;\r\nunsigned count = func->ffs->eps_count;\r\nunsigned long flags;\r\nspin_lock_irqsave(&func->ffs->eps_lock, flags);\r\ndo {\r\nif (likely(ep->ep))\r\nusb_ep_disable(ep->ep);\r\nepfile->ep = NULL;\r\n++ep;\r\n++epfile;\r\n} while (--count);\r\nspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\r\n}\r\nstatic int ffs_func_eps_enable(struct ffs_function *func)\r\n{\r\nstruct ffs_data *ffs = func->ffs;\r\nstruct ffs_ep *ep = func->eps;\r\nstruct ffs_epfile *epfile = ffs->epfiles;\r\nunsigned count = ffs->eps_count;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&func->ffs->eps_lock, flags);\r\ndo {\r\nstruct usb_endpoint_descriptor *ds;\r\nds = ep->descs[ep->descs[1] ? 1 : 0];\r\nep->ep->driver_data = ep;\r\nep->ep->desc = ds;\r\nret = usb_ep_enable(ep->ep);\r\nif (likely(!ret)) {\r\nepfile->ep = ep;\r\nepfile->in = usb_endpoint_dir_in(ds);\r\nepfile->isoc = usb_endpoint_xfer_isoc(ds);\r\n} else {\r\nbreak;\r\n}\r\nwake_up(&epfile->wait);\r\n++ep;\r\n++epfile;\r\n} while (--count);\r\nspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int __must_check ffs_do_desc(char *data, unsigned len,\r\nffs_entity_callback entity, void *priv)\r\n{\r\nstruct usb_descriptor_header *_ds = (void *)data;\r\nu8 length;\r\nint ret;\r\nENTER();\r\nif (len < 2) {\r\npr_vdebug("descriptor too short\n");\r\nreturn -EINVAL;\r\n}\r\nlength = _ds->bLength;\r\nif (len < length) {\r\npr_vdebug("descriptor longer then available data\n");\r\nreturn -EINVAL;\r\n}\r\n#define __entity_check_INTERFACE(val) 1\r\n#define __entity_check_STRING(val) (val)\r\n#define __entity_check_ENDPOINT(val) ((val) & USB_ENDPOINT_NUMBER_MASK)\r\n#define __entity(type, val) do { \\r\npr_vdebug("entity " #type "(%02x)\n", (val)); \\r\nif (unlikely(!__entity_check_ ##type(val))) { \\r\npr_vdebug("invalid entity's value\n"); \\r\nreturn -EINVAL; \\r\n} \\r\nret = entity(FFS_ ##type, &val, _ds, priv); \\r\nif (unlikely(ret < 0)) { \\r\npr_debug("entity " #type "(%02x); ret = %d\n", \\r\n(val), ret); \\r\nreturn ret; \\r\n} \\r\n} while (0)\r\nswitch (_ds->bDescriptorType) {\r\ncase USB_DT_DEVICE:\r\ncase USB_DT_CONFIG:\r\ncase USB_DT_STRING:\r\ncase USB_DT_DEVICE_QUALIFIER:\r\npr_vdebug("descriptor reserved for gadget: %d\n",\r\n_ds->bDescriptorType);\r\nreturn -EINVAL;\r\ncase USB_DT_INTERFACE: {\r\nstruct usb_interface_descriptor *ds = (void *)_ds;\r\npr_vdebug("interface descriptor\n");\r\nif (length != sizeof *ds)\r\ngoto inv_length;\r\n__entity(INTERFACE, ds->bInterfaceNumber);\r\nif (ds->iInterface)\r\n__entity(STRING, ds->iInterface);\r\n}\r\nbreak;\r\ncase USB_DT_ENDPOINT: {\r\nstruct usb_endpoint_descriptor *ds = (void *)_ds;\r\npr_vdebug("endpoint descriptor\n");\r\nif (length != USB_DT_ENDPOINT_SIZE &&\r\nlength != USB_DT_ENDPOINT_AUDIO_SIZE)\r\ngoto inv_length;\r\n__entity(ENDPOINT, ds->bEndpointAddress);\r\n}\r\nbreak;\r\ncase HID_DT_HID:\r\npr_vdebug("hid descriptor\n");\r\nif (length != sizeof(struct hid_descriptor))\r\ngoto inv_length;\r\nbreak;\r\ncase USB_DT_OTG:\r\nif (length != sizeof(struct usb_otg_descriptor))\r\ngoto inv_length;\r\nbreak;\r\ncase USB_DT_INTERFACE_ASSOCIATION: {\r\nstruct usb_interface_assoc_descriptor *ds = (void *)_ds;\r\npr_vdebug("interface association descriptor\n");\r\nif (length != sizeof *ds)\r\ngoto inv_length;\r\nif (ds->iFunction)\r\n__entity(STRING, ds->iFunction);\r\n}\r\nbreak;\r\ncase USB_DT_OTHER_SPEED_CONFIG:\r\ncase USB_DT_INTERFACE_POWER:\r\ncase USB_DT_DEBUG:\r\ncase USB_DT_SECURITY:\r\ncase USB_DT_CS_RADIO_CONTROL:\r\npr_vdebug("unimplemented descriptor: %d\n", _ds->bDescriptorType);\r\nreturn -EINVAL;\r\ndefault:\r\npr_vdebug("unknown descriptor: %d\n", _ds->bDescriptorType);\r\nreturn -EINVAL;\r\ninv_length:\r\npr_vdebug("invalid length: %d (descriptor %d)\n",\r\n_ds->bLength, _ds->bDescriptorType);\r\nreturn -EINVAL;\r\n}\r\n#undef __entity\r\n#undef __entity_check_DESCRIPTOR\r\n#undef __entity_check_INTERFACE\r\n#undef __entity_check_STRING\r\n#undef __entity_check_ENDPOINT\r\nreturn length;\r\n}\r\nstatic int __must_check ffs_do_descs(unsigned count, char *data, unsigned len,\r\nffs_entity_callback entity, void *priv)\r\n{\r\nconst unsigned _len = len;\r\nunsigned long num = 0;\r\nENTER();\r\nfor (;;) {\r\nint ret;\r\nif (num == count)\r\ndata = NULL;\r\nret = entity(FFS_DESCRIPTOR, (u8 *)num, (void *)data, priv);\r\nif (unlikely(ret < 0)) {\r\npr_debug("entity DESCRIPTOR(%02lx); ret = %d\n",\r\nnum, ret);\r\nreturn ret;\r\n}\r\nif (!data)\r\nreturn _len - len;\r\nret = ffs_do_desc(data, len, entity, priv);\r\nif (unlikely(ret < 0)) {\r\npr_debug("%s returns %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nlen -= ret;\r\ndata += ret;\r\n++num;\r\n}\r\n}\r\nstatic int __ffs_data_do_entity(enum ffs_entity_type type,\r\nu8 *valuep, struct usb_descriptor_header *desc,\r\nvoid *priv)\r\n{\r\nstruct ffs_data *ffs = priv;\r\nENTER();\r\nswitch (type) {\r\ncase FFS_DESCRIPTOR:\r\nbreak;\r\ncase FFS_INTERFACE:\r\nif (*valuep >= ffs->interfaces_count)\r\nffs->interfaces_count = *valuep + 1;\r\nbreak;\r\ncase FFS_STRING:\r\nif (*valuep > ffs->strings_count)\r\nffs->strings_count = *valuep;\r\nbreak;\r\ncase FFS_ENDPOINT:\r\nif ((*valuep & USB_ENDPOINT_NUMBER_MASK) > ffs->eps_count)\r\nffs->eps_count = (*valuep & USB_ENDPOINT_NUMBER_MASK);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __ffs_data_got_descs(struct ffs_data *ffs,\r\nchar *const _data, size_t len)\r\n{\r\nunsigned fs_count, hs_count;\r\nint fs_len, ret = -EINVAL;\r\nchar *data = _data;\r\nENTER();\r\nif (unlikely(get_unaligned_le32(data) != FUNCTIONFS_DESCRIPTORS_MAGIC ||\r\nget_unaligned_le32(data + 4) != len))\r\ngoto error;\r\nfs_count = get_unaligned_le32(data + 8);\r\nhs_count = get_unaligned_le32(data + 12);\r\nif (!fs_count && !hs_count)\r\ngoto einval;\r\ndata += 16;\r\nlen -= 16;\r\nif (likely(fs_count)) {\r\nfs_len = ffs_do_descs(fs_count, data, len,\r\n__ffs_data_do_entity, ffs);\r\nif (unlikely(fs_len < 0)) {\r\nret = fs_len;\r\ngoto error;\r\n}\r\ndata += fs_len;\r\nlen -= fs_len;\r\n} else {\r\nfs_len = 0;\r\n}\r\nif (likely(hs_count)) {\r\nret = ffs_do_descs(hs_count, data, len,\r\n__ffs_data_do_entity, ffs);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\n} else {\r\nret = 0;\r\n}\r\nif (unlikely(len != ret))\r\ngoto einval;\r\nffs->raw_fs_descs_length = fs_len;\r\nffs->raw_descs_length = fs_len + ret;\r\nffs->raw_descs = _data;\r\nffs->fs_descs_count = fs_count;\r\nffs->hs_descs_count = hs_count;\r\nreturn 0;\r\neinval:\r\nret = -EINVAL;\r\nerror:\r\nkfree(_data);\r\nreturn ret;\r\n}\r\nstatic int __ffs_data_got_strings(struct ffs_data *ffs,\r\nchar *const _data, size_t len)\r\n{\r\nu32 str_count, needed_count, lang_count;\r\nstruct usb_gadget_strings **stringtabs, *t;\r\nstruct usb_string *strings, *s;\r\nconst char *data = _data;\r\nENTER();\r\nif (unlikely(get_unaligned_le32(data) != FUNCTIONFS_STRINGS_MAGIC ||\r\nget_unaligned_le32(data + 4) != len))\r\ngoto error;\r\nstr_count = get_unaligned_le32(data + 8);\r\nlang_count = get_unaligned_le32(data + 12);\r\nif (unlikely(!str_count != !lang_count))\r\ngoto error;\r\nneeded_count = ffs->strings_count;\r\nif (unlikely(str_count < needed_count))\r\ngoto error;\r\nif (!needed_count) {\r\nkfree(_data);\r\nreturn 0;\r\n}\r\n{\r\nstruct {\r\nstruct usb_gadget_strings *stringtabs[lang_count + 1];\r\nstruct usb_gadget_strings stringtab[lang_count];\r\nstruct usb_string strings[lang_count*(needed_count+1)];\r\n} *d;\r\nunsigned i = 0;\r\nd = kmalloc(sizeof *d, GFP_KERNEL);\r\nif (unlikely(!d)) {\r\nkfree(_data);\r\nreturn -ENOMEM;\r\n}\r\nstringtabs = d->stringtabs;\r\nt = d->stringtab;\r\ni = lang_count;\r\ndo {\r\n*stringtabs++ = t++;\r\n} while (--i);\r\n*stringtabs = NULL;\r\nstringtabs = d->stringtabs;\r\nt = d->stringtab;\r\ns = d->strings;\r\nstrings = s;\r\n}\r\ndata += 16;\r\nlen -= 16;\r\ndo {\r\nunsigned needed = needed_count;\r\nif (unlikely(len < 3))\r\ngoto error_free;\r\nt->language = get_unaligned_le16(data);\r\nt->strings = s;\r\n++t;\r\ndata += 2;\r\nlen -= 2;\r\ndo {\r\nsize_t length = strnlen(data, len);\r\nif (unlikely(length == len))\r\ngoto error_free;\r\nif (likely(needed)) {\r\ns->s = data;\r\n--needed;\r\n++s;\r\n}\r\ndata += length + 1;\r\nlen -= length + 1;\r\n} while (--str_count);\r\ns->id = 0;\r\ns->s = NULL;\r\n++s;\r\n} while (--lang_count);\r\nif (unlikely(len))\r\ngoto error_free;\r\nffs->stringtabs = stringtabs;\r\nffs->raw_strings = _data;\r\nreturn 0;\r\nerror_free:\r\nkfree(stringtabs);\r\nerror:\r\nkfree(_data);\r\nreturn -EINVAL;\r\n}\r\nstatic void __ffs_event_add(struct ffs_data *ffs,\r\nenum usb_functionfs_event_type type)\r\n{\r\nenum usb_functionfs_event_type rem_type1, rem_type2 = type;\r\nint neg = 0;\r\nif (ffs->setup_state == FFS_SETUP_PENDING)\r\nffs->setup_state = FFS_SETUP_CANCELED;\r\nswitch (type) {\r\ncase FUNCTIONFS_RESUME:\r\nrem_type2 = FUNCTIONFS_SUSPEND;\r\ncase FUNCTIONFS_SUSPEND:\r\ncase FUNCTIONFS_SETUP:\r\nrem_type1 = type;\r\nbreak;\r\ncase FUNCTIONFS_BIND:\r\ncase FUNCTIONFS_UNBIND:\r\ncase FUNCTIONFS_DISABLE:\r\ncase FUNCTIONFS_ENABLE:\r\nrem_type1 = FUNCTIONFS_SUSPEND;\r\nrem_type2 = FUNCTIONFS_RESUME;\r\nneg = 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n{\r\nu8 *ev = ffs->ev.types, *out = ev;\r\nunsigned n = ffs->ev.count;\r\nfor (; n; --n, ++ev)\r\nif ((*ev == rem_type1 || *ev == rem_type2) == neg)\r\n*out++ = *ev;\r\nelse\r\npr_vdebug("purging event %d\n", *ev);\r\nffs->ev.count = out - ffs->ev.types;\r\n}\r\npr_vdebug("adding event %d\n", type);\r\nffs->ev.types[ffs->ev.count++] = type;\r\nwake_up_locked(&ffs->ev.waitq);\r\n}\r\nstatic void ffs_event_add(struct ffs_data *ffs,\r\nenum usb_functionfs_event_type type)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\r\n__ffs_event_add(ffs, type);\r\nspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\r\n}\r\nstatic int __ffs_func_bind_do_descs(enum ffs_entity_type type, u8 *valuep,\r\nstruct usb_descriptor_header *desc,\r\nvoid *priv)\r\n{\r\nstruct usb_endpoint_descriptor *ds = (void *)desc;\r\nstruct ffs_function *func = priv;\r\nstruct ffs_ep *ffs_ep;\r\nconst int isHS = func->function.hs_descriptors != NULL;\r\nunsigned idx;\r\nif (type != FFS_DESCRIPTOR)\r\nreturn 0;\r\nif (isHS)\r\nfunc->function.hs_descriptors[(long)valuep] = desc;\r\nelse\r\nfunc->function.fs_descriptors[(long)valuep] = desc;\r\nif (!desc || desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn 0;\r\nidx = (ds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) - 1;\r\nffs_ep = func->eps + idx;\r\nif (unlikely(ffs_ep->descs[isHS])) {\r\npr_vdebug("two %sspeed descriptors for EP %d\n",\r\nisHS ? "high" : "full",\r\nds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\r\nreturn -EINVAL;\r\n}\r\nffs_ep->descs[isHS] = ds;\r\nffs_dump_mem(": Original ep desc", ds, ds->bLength);\r\nif (ffs_ep->ep) {\r\nds->bEndpointAddress = ffs_ep->descs[0]->bEndpointAddress;\r\nif (!ds->wMaxPacketSize)\r\nds->wMaxPacketSize = ffs_ep->descs[0]->wMaxPacketSize;\r\n} else {\r\nstruct usb_request *req;\r\nstruct usb_ep *ep;\r\npr_vdebug("autoconfig\n");\r\nep = usb_ep_autoconfig(func->gadget, ds);\r\nif (unlikely(!ep))\r\nreturn -ENOTSUPP;\r\nep->driver_data = func->eps + idx;\r\nreq = usb_ep_alloc_request(ep, GFP_KERNEL);\r\nif (unlikely(!req))\r\nreturn -ENOMEM;\r\nffs_ep->ep = ep;\r\nffs_ep->req = req;\r\nfunc->eps_revmap[ds->bEndpointAddress &\r\nUSB_ENDPOINT_NUMBER_MASK] = idx + 1;\r\n}\r\nffs_dump_mem(": Rewritten ep desc", ds, ds->bLength);\r\nreturn 0;\r\n}\r\nstatic int __ffs_func_bind_do_nums(enum ffs_entity_type type, u8 *valuep,\r\nstruct usb_descriptor_header *desc,\r\nvoid *priv)\r\n{\r\nstruct ffs_function *func = priv;\r\nunsigned idx;\r\nu8 newValue;\r\nswitch (type) {\r\ndefault:\r\ncase FFS_DESCRIPTOR:\r\nreturn 0;\r\ncase FFS_INTERFACE:\r\nidx = *valuep;\r\nif (func->interfaces_nums[idx] < 0) {\r\nint id = usb_interface_id(func->conf, &func->function);\r\nif (unlikely(id < 0))\r\nreturn id;\r\nfunc->interfaces_nums[idx] = id;\r\n}\r\nnewValue = func->interfaces_nums[idx];\r\nbreak;\r\ncase FFS_STRING:\r\nnewValue = func->ffs->stringtabs[0]->strings[*valuep - 1].id;\r\nbreak;\r\ncase FFS_ENDPOINT:\r\nif (desc->bDescriptorType == USB_DT_ENDPOINT)\r\nreturn 0;\r\nidx = (*valuep & USB_ENDPOINT_NUMBER_MASK) - 1;\r\nif (unlikely(!func->eps[idx].ep))\r\nreturn -EINVAL;\r\n{\r\nstruct usb_endpoint_descriptor **descs;\r\ndescs = func->eps[idx].descs;\r\nnewValue = descs[descs[0] ? 0 : 1]->bEndpointAddress;\r\n}\r\nbreak;\r\n}\r\npr_vdebug("%02x -> %02x\n", *valuep, newValue);\r\n*valuep = newValue;\r\nreturn 0;\r\n}\r\nstatic int ffs_func_bind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct ffs_data *ffs = func->ffs;\r\nconst int full = !!func->ffs->fs_descs_count;\r\nconst int high = gadget_is_dualspeed(func->gadget) &&\r\nfunc->ffs->hs_descs_count;\r\nint ret;\r\nstruct {\r\nstruct ffs_ep eps[ffs->eps_count];\r\nstruct usb_descriptor_header\r\n*fs_descs[full ? ffs->fs_descs_count + 1 : 0];\r\nstruct usb_descriptor_header\r\n*hs_descs[high ? ffs->hs_descs_count + 1 : 0];\r\nshort inums[ffs->interfaces_count];\r\nchar raw_descs[high ? ffs->raw_descs_length\r\n: ffs->raw_fs_descs_length];\r\n} *data;\r\nENTER();\r\nif (unlikely(!(full | high)))\r\nreturn -ENOTSUPP;\r\ndata = kmalloc(sizeof *data, GFP_KERNEL);\r\nif (unlikely(!data))\r\nreturn -ENOMEM;\r\nmemset(data->eps, 0, sizeof data->eps);\r\nmemcpy(data->raw_descs, ffs->raw_descs + 16, sizeof data->raw_descs);\r\nmemset(data->inums, 0xff, sizeof data->inums);\r\nfor (ret = ffs->eps_count; ret; --ret)\r\ndata->eps[ret].num = -1;\r\nfunc->eps = data->eps;\r\nfunc->interfaces_nums = data->inums;\r\nif (likely(full)) {\r\nfunc->function.fs_descriptors = data->fs_descs;\r\nret = ffs_do_descs(ffs->fs_descs_count,\r\ndata->raw_descs,\r\nsizeof data->raw_descs,\r\n__ffs_func_bind_do_descs, func);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\n} else {\r\nret = 0;\r\n}\r\nif (likely(high)) {\r\nfunc->function.hs_descriptors = data->hs_descs;\r\nret = ffs_do_descs(ffs->hs_descs_count,\r\ndata->raw_descs + ret,\r\n(sizeof data->raw_descs) - ret,\r\n__ffs_func_bind_do_descs, func);\r\n}\r\nret = ffs_do_descs(ffs->fs_descs_count +\r\n(high ? ffs->hs_descs_count : 0),\r\ndata->raw_descs, sizeof data->raw_descs,\r\n__ffs_func_bind_do_nums, func);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\nffs_event_add(ffs, FUNCTIONFS_BIND);\r\nreturn 0;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void ffs_func_unbind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct ffs_data *ffs = func->ffs;\r\nENTER();\r\nif (ffs->func == func) {\r\nffs_func_eps_disable(func);\r\nffs->func = NULL;\r\n}\r\nffs_event_add(ffs, FUNCTIONFS_UNBIND);\r\nffs_func_free(func);\r\n}\r\nstatic int ffs_func_set_alt(struct usb_function *f,\r\nunsigned interface, unsigned alt)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct ffs_data *ffs = func->ffs;\r\nint ret = 0, intf;\r\nif (alt != (unsigned)-1) {\r\nintf = ffs_func_revmap_intf(func, interface);\r\nif (unlikely(intf < 0))\r\nreturn intf;\r\n}\r\nif (ffs->func)\r\nffs_func_eps_disable(ffs->func);\r\nif (ffs->state != FFS_ACTIVE)\r\nreturn -ENODEV;\r\nif (alt == (unsigned)-1) {\r\nffs->func = NULL;\r\nffs_event_add(ffs, FUNCTIONFS_DISABLE);\r\nreturn 0;\r\n}\r\nffs->func = func;\r\nret = ffs_func_eps_enable(func);\r\nif (likely(ret >= 0))\r\nffs_event_add(ffs, FUNCTIONFS_ENABLE);\r\nreturn ret;\r\n}\r\nstatic void ffs_func_disable(struct usb_function *f)\r\n{\r\nffs_func_set_alt(f, 0, (unsigned)-1);\r\n}\r\nstatic int ffs_func_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *creq)\r\n{\r\nstruct ffs_function *func = ffs_func_from_usb(f);\r\nstruct ffs_data *ffs = func->ffs;\r\nunsigned long flags;\r\nint ret;\r\nENTER();\r\npr_vdebug("creq->bRequestType = %02x\n", creq->bRequestType);\r\npr_vdebug("creq->bRequest = %02x\n", creq->bRequest);\r\npr_vdebug("creq->wValue = %04x\n", le16_to_cpu(creq->wValue));\r\npr_vdebug("creq->wIndex = %04x\n", le16_to_cpu(creq->wIndex));\r\npr_vdebug("creq->wLength = %04x\n", le16_to_cpu(creq->wLength));\r\nif (ffs->state != FFS_ACTIVE)\r\nreturn -ENODEV;\r\nswitch (creq->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_INTERFACE:\r\nret = ffs_func_revmap_intf(func, le16_to_cpu(creq->wIndex));\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nret = ffs_func_revmap_ep(func, le16_to_cpu(creq->wIndex));\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\r\nffs->ev.setup = *creq;\r\nffs->ev.setup.wIndex = cpu_to_le16(ret);\r\n__ffs_event_add(ffs, FUNCTIONFS_SETUP);\r\nspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ffs_func_suspend(struct usb_function *f)\r\n{\r\nENTER();\r\nffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_SUSPEND);\r\n}\r\nstatic void ffs_func_resume(struct usb_function *f)\r\n{\r\nENTER();\r\nffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_RESUME);\r\n}\r\nstatic int ffs_func_revmap_ep(struct ffs_function *func, u8 num)\r\n{\r\nnum = func->eps_revmap[num & USB_ENDPOINT_NUMBER_MASK];\r\nreturn num ? num : -EDOM;\r\n}\r\nstatic int ffs_func_revmap_intf(struct ffs_function *func, u8 intf)\r\n{\r\nshort *nums = func->interfaces_nums;\r\nunsigned count = func->ffs->interfaces_count;\r\nfor (; count; --count, ++nums) {\r\nif (*nums >= 0 && *nums == intf)\r\nreturn nums - func->interfaces_nums;\r\n}\r\nreturn -EDOM;\r\n}\r\nstatic int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)\r\n{\r\nreturn nonblock\r\n? likely(mutex_trylock(mutex)) ? 0 : -EAGAIN\r\n: mutex_lock_interruptible(mutex);\r\n}\r\nstatic char *ffs_prepare_buffer(const char __user *buf, size_t len)\r\n{\r\nchar *data;\r\nif (unlikely(!len))\r\nreturn NULL;\r\ndata = kmalloc(len, GFP_KERNEL);\r\nif (unlikely(!data))\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unlikely(__copy_from_user(data, buf, len))) {\r\nkfree(data);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\npr_vdebug("Buffer from user space:\n");\r\nffs_dump_mem("", data, len);\r\nreturn data;\r\n}
