static inline struct clksrc_clk *to_clksrc(struct clk *clk)\r\n{\r\nreturn container_of(clk, struct clksrc_clk, clk);\r\n}\r\nstatic inline u32 bit_mask(u32 shift, u32 nr_bits)\r\n{\r\nu32 mask = 0xffffffff >> (32 - nr_bits);\r\nreturn mask << shift;\r\n}\r\nstatic unsigned long s3c_getrate_clksrc(struct clk *clk)\r\n{\r\nstruct clksrc_clk *sclk = to_clksrc(clk);\r\nunsigned long rate = clk_get_rate(clk->parent);\r\nu32 clkdiv = __raw_readl(sclk->reg_div.reg);\r\nu32 mask = bit_mask(sclk->reg_div.shift, sclk->reg_div.size);\r\nclkdiv &= mask;\r\nclkdiv >>= sclk->reg_div.shift;\r\nclkdiv++;\r\nrate /= clkdiv;\r\nreturn rate;\r\n}\r\nstatic int s3c_setrate_clksrc(struct clk *clk, unsigned long rate)\r\n{\r\nstruct clksrc_clk *sclk = to_clksrc(clk);\r\nvoid __iomem *reg = sclk->reg_div.reg;\r\nunsigned int div;\r\nu32 mask = bit_mask(sclk->reg_div.shift, sclk->reg_div.size);\r\nu32 val;\r\nrate = clk_round_rate(clk, rate);\r\ndiv = clk_get_rate(clk->parent) / rate;\r\nif (div > (1 << sclk->reg_div.size))\r\nreturn -EINVAL;\r\nval = __raw_readl(reg);\r\nval &= ~mask;\r\nval |= (div - 1) << sclk->reg_div.shift;\r\n__raw_writel(val, reg);\r\nreturn 0;\r\n}\r\nstatic int s3c_setparent_clksrc(struct clk *clk, struct clk *parent)\r\n{\r\nstruct clksrc_clk *sclk = to_clksrc(clk);\r\nstruct clksrc_sources *srcs = sclk->sources;\r\nu32 clksrc = __raw_readl(sclk->reg_src.reg);\r\nu32 mask = bit_mask(sclk->reg_src.shift, sclk->reg_src.size);\r\nint src_nr = -1;\r\nint ptr;\r\nfor (ptr = 0; ptr < srcs->nr_sources; ptr++)\r\nif (srcs->sources[ptr] == parent) {\r\nsrc_nr = ptr;\r\nbreak;\r\n}\r\nif (src_nr >= 0) {\r\nclk->parent = parent;\r\nclksrc &= ~mask;\r\nclksrc |= src_nr << sclk->reg_src.shift;\r\n__raw_writel(clksrc, sclk->reg_src.reg);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned long s3c_roundrate_clksrc(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nstruct clksrc_clk *sclk = to_clksrc(clk);\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nint max_div = 1 << sclk->reg_div.size;\r\nint div;\r\nif (rate >= parent_rate)\r\nrate = parent_rate;\r\nelse {\r\ndiv = parent_rate / rate;\r\nif (parent_rate % rate)\r\ndiv++;\r\nif (div == 0)\r\ndiv = 1;\r\nif (div > max_div)\r\ndiv = max_div;\r\nrate = parent_rate / div;\r\n}\r\nreturn rate;\r\n}\r\nvoid __init_or_cpufreq s3c_set_clksrc(struct clksrc_clk *clk, bool announce)\r\n{\r\nstruct clksrc_sources *srcs = clk->sources;\r\nu32 mask = bit_mask(clk->reg_src.shift, clk->reg_src.size);\r\nu32 clksrc;\r\nif (!clk->reg_src.reg) {\r\nif (!clk->clk.parent)\r\nprintk(KERN_ERR "%s: no parent clock specified\n",\r\nclk->clk.name);\r\nreturn;\r\n}\r\nclksrc = __raw_readl(clk->reg_src.reg);\r\nclksrc &= mask;\r\nclksrc >>= clk->reg_src.shift;\r\nif (clksrc > srcs->nr_sources || !srcs->sources[clksrc]) {\r\nprintk(KERN_ERR "%s: bad source %d\n",\r\nclk->clk.name, clksrc);\r\nreturn;\r\n}\r\nclk->clk.parent = srcs->sources[clksrc];\r\nif (announce)\r\nprintk(KERN_INFO "%s: source is %s (%d), rate is %ld\n",\r\nclk->clk.name, clk->clk.parent->name, clksrc,\r\nclk_get_rate(&clk->clk));\r\n}\r\nvoid __init s3c_register_clksrc(struct clksrc_clk *clksrc, int size)\r\n{\r\nint ret;\r\nfor (; size > 0; size--, clksrc++) {\r\nif (!clksrc->reg_div.reg && !clksrc->reg_src.reg)\r\nprintk(KERN_ERR "%s: clock %s has no registers set\n",\r\n__func__, clksrc->clk.name);\r\nif (!clksrc->clk.ops) {\r\nif (!clksrc->reg_div.reg)\r\nclksrc->clk.ops = &clksrc_ops_nodiv;\r\nelse if (!clksrc->reg_src.reg)\r\nclksrc->clk.ops = &clksrc_ops_nosrc;\r\nelse\r\nclksrc->clk.ops = &clksrc_ops;\r\n}\r\ns3c_set_clksrc(clksrc, false);\r\nret = s3c24xx_register_clock(&clksrc->clk);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: failed to register %s (%d)\n",\r\n__func__, clksrc->clk.name, ret);\r\n}\r\n}\r\n}
