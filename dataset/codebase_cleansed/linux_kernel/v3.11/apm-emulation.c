static void __apm_get_power_status(struct apm_power_info *info)\r\n{\r\n}\r\nstatic inline int queue_empty(struct apm_queue *q)\r\n{\r\nreturn q->event_head == q->event_tail;\r\n}\r\nstatic inline apm_event_t queue_get_event(struct apm_queue *q)\r\n{\r\nq->event_tail = (q->event_tail + 1) % APM_MAX_EVENTS;\r\nreturn q->events[q->event_tail];\r\n}\r\nstatic void queue_add_event(struct apm_queue *q, apm_event_t event)\r\n{\r\nq->event_head = (q->event_head + 1) % APM_MAX_EVENTS;\r\nif (q->event_head == q->event_tail) {\r\nstatic int notified;\r\nif (notified++ == 0)\r\nprintk(KERN_ERR "apm: an event queue overflowed\n");\r\nq->event_tail = (q->event_tail + 1) % APM_MAX_EVENTS;\r\n}\r\nq->events[q->event_head] = event;\r\n}\r\nstatic void queue_event(apm_event_t event)\r\n{\r\nstruct apm_user *as;\r\ndown_read(&user_list_lock);\r\nlist_for_each_entry(as, &apm_user_list, list) {\r\nif (as->reader)\r\nqueue_add_event(&as->queue, event);\r\n}\r\nup_read(&user_list_lock);\r\nwake_up_interruptible(&apm_waitqueue);\r\n}\r\nstatic ssize_t apm_read(struct file *fp, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct apm_user *as = fp->private_data;\r\napm_event_t event;\r\nint i = count, ret = 0;\r\nif (count < sizeof(apm_event_t))\r\nreturn -EINVAL;\r\nif (queue_empty(&as->queue) && fp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nwait_event_interruptible(apm_waitqueue, !queue_empty(&as->queue));\r\nwhile ((i >= sizeof(event)) && !queue_empty(&as->queue)) {\r\nevent = queue_get_event(&as->queue);\r\nret = -EFAULT;\r\nif (copy_to_user(buf, &event, sizeof(event)))\r\nbreak;\r\nmutex_lock(&state_lock);\r\nif (as->suspend_state == SUSPEND_PENDING &&\r\n(event == APM_SYS_SUSPEND || event == APM_USER_SUSPEND))\r\nas->suspend_state = SUSPEND_READ;\r\nmutex_unlock(&state_lock);\r\nbuf += sizeof(event);\r\ni -= sizeof(event);\r\n}\r\nif (i < count)\r\nret = count - i;\r\nreturn ret;\r\n}\r\nstatic unsigned int apm_poll(struct file *fp, poll_table * wait)\r\n{\r\nstruct apm_user *as = fp->private_data;\r\npoll_wait(fp, &apm_waitqueue, wait);\r\nreturn queue_empty(&as->queue) ? 0 : POLLIN | POLLRDNORM;\r\n}\r\nstatic long\r\napm_ioctl(struct file *filp, u_int cmd, u_long arg)\r\n{\r\nstruct apm_user *as = filp->private_data;\r\nint err = -EINVAL;\r\nif (!as->suser || !as->writer)\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase APM_IOC_SUSPEND:\r\nmutex_lock(&state_lock);\r\nas->suspend_result = -EINTR;\r\nswitch (as->suspend_state) {\r\ncase SUSPEND_READ:\r\nas->suspend_state = SUSPEND_ACKED;\r\natomic_dec(&suspend_acks_pending);\r\nmutex_unlock(&state_lock);\r\nwake_up(&apm_suspend_waitqueue);\r\nwhile (wait_event_freezable(apm_suspend_waitqueue,\r\nas->suspend_state != SUSPEND_ACKED))\r\nmsleep(10);\r\nbreak;\r\ncase SUSPEND_ACKTO:\r\nas->suspend_result = -ETIMEDOUT;\r\nmutex_unlock(&state_lock);\r\nbreak;\r\ndefault:\r\nas->suspend_state = SUSPEND_WAIT;\r\nmutex_unlock(&state_lock);\r\nas->suspend_result = pm_suspend(PM_SUSPEND_MEM);\r\n}\r\nmutex_lock(&state_lock);\r\nerr = as->suspend_result;\r\nas->suspend_state = SUSPEND_NONE;\r\nmutex_unlock(&state_lock);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int apm_release(struct inode * inode, struct file * filp)\r\n{\r\nstruct apm_user *as = filp->private_data;\r\nfilp->private_data = NULL;\r\ndown_write(&user_list_lock);\r\nlist_del(&as->list);\r\nup_write(&user_list_lock);\r\nmutex_lock(&state_lock);\r\nif (as->suspend_state == SUSPEND_PENDING ||\r\nas->suspend_state == SUSPEND_READ)\r\natomic_dec(&suspend_acks_pending);\r\nmutex_unlock(&state_lock);\r\nwake_up(&apm_suspend_waitqueue);\r\nkfree(as);\r\nreturn 0;\r\n}\r\nstatic int apm_open(struct inode * inode, struct file * filp)\r\n{\r\nstruct apm_user *as;\r\nas = kzalloc(sizeof(*as), GFP_KERNEL);\r\nif (as) {\r\nas->suser = capable(CAP_SYS_ADMIN);\r\nas->writer = (filp->f_mode & FMODE_WRITE) == FMODE_WRITE;\r\nas->reader = (filp->f_mode & FMODE_READ) == FMODE_READ;\r\ndown_write(&user_list_lock);\r\nlist_add(&as->list, &apm_user_list);\r\nup_write(&user_list_lock);\r\nfilp->private_data = as;\r\n}\r\nreturn as ? 0 : -ENOMEM;\r\n}\r\nstatic int proc_apm_show(struct seq_file *m, void *v)\r\n{\r\nstruct apm_power_info info;\r\nchar *units;\r\ninfo.ac_line_status = 0xff;\r\ninfo.battery_status = 0xff;\r\ninfo.battery_flag = 0xff;\r\ninfo.battery_life = -1;\r\ninfo.time = -1;\r\ninfo.units = -1;\r\nif (apm_get_power_status)\r\napm_get_power_status(&info);\r\nswitch (info.units) {\r\ndefault: units = "?"; break;\r\ncase 0: units = "min"; break;\r\ncase 1: units = "sec"; break;\r\n}\r\nseq_printf(m, "%s 1.2 0x%02x 0x%02x 0x%02x 0x%02x %d%% %d %s\n",\r\ndriver_version, APM_32_BIT_SUPPORT,\r\ninfo.ac_line_status, info.battery_status,\r\ninfo.battery_flag, info.battery_life,\r\ninfo.time, units);\r\nreturn 0;\r\n}\r\nstatic int proc_apm_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_apm_show, NULL);\r\n}\r\nstatic int kapmd(void *arg)\r\n{\r\ndo {\r\napm_event_t event;\r\nwait_event_interruptible(kapmd_wait,\r\n!queue_empty(&kapmd_queue) || kthread_should_stop());\r\nif (kthread_should_stop())\r\nbreak;\r\nspin_lock_irq(&kapmd_queue_lock);\r\nevent = 0;\r\nif (!queue_empty(&kapmd_queue))\r\nevent = queue_get_event(&kapmd_queue);\r\nspin_unlock_irq(&kapmd_queue_lock);\r\nswitch (event) {\r\ncase 0:\r\nbreak;\r\ncase APM_LOW_BATTERY:\r\ncase APM_POWER_STATUS_CHANGE:\r\nqueue_event(event);\r\nbreak;\r\ncase APM_USER_SUSPEND:\r\ncase APM_SYS_SUSPEND:\r\npm_suspend(PM_SUSPEND_MEM);\r\nbreak;\r\ncase APM_CRITICAL_SUSPEND:\r\natomic_inc(&userspace_notification_inhibit);\r\npm_suspend(PM_SUSPEND_MEM);\r\natomic_dec(&userspace_notification_inhibit);\r\nbreak;\r\n}\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int apm_suspend_notifier(struct notifier_block *nb,\r\nunsigned long event,\r\nvoid *dummy)\r\n{\r\nstruct apm_user *as;\r\nint err;\r\nif (atomic_read(&userspace_notification_inhibit))\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase PM_SUSPEND_PREPARE:\r\nmutex_lock(&state_lock);\r\ndown_read(&user_list_lock);\r\nlist_for_each_entry(as, &apm_user_list, list) {\r\nif (as->suspend_state != SUSPEND_WAIT && as->reader &&\r\nas->writer && as->suser) {\r\nas->suspend_state = SUSPEND_PENDING;\r\natomic_inc(&suspend_acks_pending);\r\nqueue_add_event(&as->queue, APM_USER_SUSPEND);\r\n}\r\n}\r\nup_read(&user_list_lock);\r\nmutex_unlock(&state_lock);\r\nwake_up_interruptible(&apm_waitqueue);\r\nerr = wait_event_interruptible_timeout(\r\napm_suspend_waitqueue,\r\natomic_read(&suspend_acks_pending) == 0,\r\n5*HZ);\r\nif (err == 0) {\r\nmutex_lock(&state_lock);\r\ndown_read(&user_list_lock);\r\nlist_for_each_entry(as, &apm_user_list, list) {\r\nif (as->suspend_state == SUSPEND_PENDING ||\r\nas->suspend_state == SUSPEND_READ) {\r\nas->suspend_state = SUSPEND_ACKTO;\r\natomic_dec(&suspend_acks_pending);\r\n}\r\n}\r\nup_read(&user_list_lock);\r\nmutex_unlock(&state_lock);\r\n}\r\nif (err >= 0)\r\nreturn NOTIFY_OK;\r\nreturn notifier_from_errno(err);\r\ncase PM_POST_SUSPEND:\r\nqueue_event(APM_NORMAL_RESUME);\r\nmutex_lock(&state_lock);\r\ndown_read(&user_list_lock);\r\nlist_for_each_entry(as, &apm_user_list, list) {\r\nif (as->suspend_state == SUSPEND_ACKED) {\r\nas->suspend_result = 0;\r\nas->suspend_state = SUSPEND_DONE;\r\n}\r\n}\r\nup_read(&user_list_lock);\r\nmutex_unlock(&state_lock);\r\nwake_up(&apm_suspend_waitqueue);\r\nreturn NOTIFY_OK;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic int __init apm_init(void)\r\n{\r\nint ret;\r\nif (apm_disabled) {\r\nprintk(KERN_NOTICE "apm: disabled on user request.\n");\r\nreturn -ENODEV;\r\n}\r\nkapmd_tsk = kthread_create(kapmd, NULL, "kapmd");\r\nif (IS_ERR(kapmd_tsk)) {\r\nret = PTR_ERR(kapmd_tsk);\r\nkapmd_tsk = NULL;\r\ngoto out;\r\n}\r\nwake_up_process(kapmd_tsk);\r\n#ifdef CONFIG_PROC_FS\r\nproc_create("apm", 0, NULL, &apm_proc_fops);\r\n#endif\r\nret = misc_register(&apm_device);\r\nif (ret)\r\ngoto out_stop;\r\nret = register_pm_notifier(&apm_notif_block);\r\nif (ret)\r\ngoto out_unregister;\r\nreturn 0;\r\nout_unregister:\r\nmisc_deregister(&apm_device);\r\nout_stop:\r\nremove_proc_entry("apm", NULL);\r\nkthread_stop(kapmd_tsk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit apm_exit(void)\r\n{\r\nunregister_pm_notifier(&apm_notif_block);\r\nmisc_deregister(&apm_device);\r\nremove_proc_entry("apm", NULL);\r\nkthread_stop(kapmd_tsk);\r\n}\r\nstatic int __init apm_setup(char *str)\r\n{\r\nwhile ((str != NULL) && (*str != '\0')) {\r\nif (strncmp(str, "off", 3) == 0)\r\napm_disabled = 1;\r\nif (strncmp(str, "on", 2) == 0)\r\napm_disabled = 0;\r\nstr = strchr(str, ',');\r\nif (str != NULL)\r\nstr += strspn(str, ", \t");\r\n}\r\nreturn 1;\r\n}\r\nvoid apm_queue_event(apm_event_t event)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&kapmd_queue_lock, flags);\r\nqueue_add_event(&kapmd_queue, event);\r\nspin_unlock_irqrestore(&kapmd_queue_lock, flags);\r\nwake_up_interruptible(&kapmd_wait);\r\n}
