static int cpu_has_dma(void)\r\n{\r\nreturn cpu_is_at91sam9rl() || cpu_is_at91sam9g45();\r\n}\r\nstatic void atmel_nand_enable(struct atmel_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->board.enable_pin))\r\ngpio_set_value(host->board.enable_pin, 0);\r\n}\r\nstatic void atmel_nand_disable(struct atmel_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->board.enable_pin))\r\ngpio_set_value(host->board.enable_pin, 1);\r\n}\r\nstatic void atmel_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif (ctrl & NAND_NCE)\r\natmel_nand_enable(host);\r\nelse\r\natmel_nand_disable(host);\r\n}\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, host->io_base + (1 << host->board.cle));\r\nelse\r\nwriteb(cmd, host->io_base + (1 << host->board.ale));\r\n}\r\nstatic int atmel_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nreturn gpio_get_value(host->board.rdy_pin) ^\r\n!!host->board.rdy_pin_active_low;\r\n}\r\nstatic void atmel_read_buf8(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_readsb(nand_chip->IO_ADDR_R, buf, len);\r\n}\r\nstatic void atmel_read_buf16(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_readsw(nand_chip->IO_ADDR_R, buf, len / 2);\r\n}\r\nstatic void atmel_write_buf8(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_writesb(nand_chip->IO_ADDR_W, buf, len);\r\n}\r\nstatic void atmel_write_buf16(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_writesw(nand_chip->IO_ADDR_W, buf, len / 2);\r\n}\r\nstatic void dma_complete_func(void *completion)\r\n{\r\ncomplete(completion);\r\n}\r\nstatic int atmel_nand_dma_op(struct mtd_info *mtd, void *buf, int len,\r\nint is_read)\r\n{\r\nstruct dma_device *dma_dev;\r\nenum dma_ctrl_flags flags;\r\ndma_addr_t dma_src_addr, dma_dst_addr, phys_addr;\r\nstruct dma_async_tx_descriptor *tx = NULL;\r\ndma_cookie_t cookie;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nvoid *p = buf;\r\nint err = -EIO;\r\nenum dma_data_direction dir = is_read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nif (buf >= high_memory)\r\ngoto err_buf;\r\ndma_dev = host->dma_chan->device;\r\nflags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_SRC_UNMAP |\r\nDMA_COMPL_SKIP_DEST_UNMAP;\r\nphys_addr = dma_map_single(dma_dev->dev, p, len, dir);\r\nif (dma_mapping_error(dma_dev->dev, phys_addr)) {\r\ndev_err(host->dev, "Failed to dma_map_single\n");\r\ngoto err_buf;\r\n}\r\nif (is_read) {\r\ndma_src_addr = host->io_phys;\r\ndma_dst_addr = phys_addr;\r\n} else {\r\ndma_src_addr = phys_addr;\r\ndma_dst_addr = host->io_phys;\r\n}\r\ntx = dma_dev->device_prep_dma_memcpy(host->dma_chan, dma_dst_addr,\r\ndma_src_addr, len, flags);\r\nif (!tx) {\r\ndev_err(host->dev, "Failed to prepare DMA memcpy\n");\r\ngoto err_dma;\r\n}\r\ninit_completion(&host->comp);\r\ntx->callback = dma_complete_func;\r\ntx->callback_param = &host->comp;\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\ndev_err(host->dev, "Failed to do DMA tx_submit\n");\r\ngoto err_dma;\r\n}\r\ndma_async_issue_pending(host->dma_chan);\r\nwait_for_completion(&host->comp);\r\nerr = 0;\r\nerr_dma:\r\ndma_unmap_single(dma_dev->dev, phys_addr, len, dir);\r\nerr_buf:\r\nif (err != 0)\r\ndev_warn(host->dev, "Fall back to CPU I/O\n");\r\nreturn err;\r\n}\r\nstatic void atmel_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nif (use_dma && len > mtd->oobsize)\r\nif (atmel_nand_dma_op(mtd, buf, len, 1) == 0)\r\nreturn;\r\nif (host->board.bus_width_16)\r\natmel_read_buf16(mtd, buf, len);\r\nelse\r\natmel_read_buf8(mtd, buf, len);\r\n}\r\nstatic void atmel_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nif (use_dma && len > mtd->oobsize)\r\nif (atmel_nand_dma_op(mtd, (void *)buf, len, 0) == 0)\r\nreturn;\r\nif (host->board.bus_width_16)\r\natmel_write_buf16(mtd, buf, len);\r\nelse\r\natmel_write_buf8(mtd, buf, len);\r\n}\r\nstatic int pmecc_get_ecc_bytes(int cap, int sector_size)\r\n{\r\nint m = 12 + sector_size / 512;\r\nreturn (m * cap + 7) / 8;\r\n}\r\nstatic void pmecc_config_ecc_layout(struct nand_ecclayout *layout,\r\nint oobsize, int ecc_len)\r\n{\r\nint i;\r\nlayout->eccbytes = ecc_len;\r\nfor (i = 0; i < ecc_len; i++)\r\nlayout->eccpos[i] = oobsize - ecc_len + i;\r\nlayout->oobfree[0].offset = 2;\r\nlayout->oobfree[0].length =\r\noobsize - ecc_len - layout->oobfree[0].offset;\r\n}\r\nstatic void __iomem *pmecc_get_alpha_to(struct atmel_nand_host *host)\r\n{\r\nint table_size;\r\ntable_size = host->pmecc_sector_size == 512 ?\r\nPMECC_LOOKUP_TABLE_SIZE_512 : PMECC_LOOKUP_TABLE_SIZE_1024;\r\nreturn host->pmecc_rom_base + host->pmecc_lookup_table_offset +\r\ntable_size * sizeof(int16_t);\r\n}\r\nstatic void pmecc_data_free(struct atmel_nand_host *host)\r\n{\r\nkfree(host->pmecc_partial_syn);\r\nkfree(host->pmecc_si);\r\nkfree(host->pmecc_lmu);\r\nkfree(host->pmecc_smu);\r\nkfree(host->pmecc_mu);\r\nkfree(host->pmecc_dmu);\r\nkfree(host->pmecc_delta);\r\n}\r\nstatic int pmecc_data_alloc(struct atmel_nand_host *host)\r\n{\r\nconst int cap = host->pmecc_corr_cap;\r\nhost->pmecc_partial_syn = kzalloc((2 * cap + 1) * sizeof(int16_t),\r\nGFP_KERNEL);\r\nhost->pmecc_si = kzalloc((2 * cap + 1) * sizeof(int16_t), GFP_KERNEL);\r\nhost->pmecc_lmu = kzalloc((cap + 1) * sizeof(int16_t), GFP_KERNEL);\r\nhost->pmecc_smu = kzalloc((cap + 2) * (2 * cap + 1) * sizeof(int16_t),\r\nGFP_KERNEL);\r\nhost->pmecc_mu = kzalloc((cap + 1) * sizeof(int), GFP_KERNEL);\r\nhost->pmecc_dmu = kzalloc((cap + 1) * sizeof(int), GFP_KERNEL);\r\nhost->pmecc_delta = kzalloc((cap + 1) * sizeof(int), GFP_KERNEL);\r\nif (host->pmecc_partial_syn &&\r\nhost->pmecc_si &&\r\nhost->pmecc_lmu &&\r\nhost->pmecc_smu &&\r\nhost->pmecc_mu &&\r\nhost->pmecc_dmu &&\r\nhost->pmecc_delta)\r\nreturn 0;\r\npmecc_data_free(host);\r\nreturn -ENOMEM;\r\n}\r\nstatic void pmecc_gen_syndrome(struct mtd_info *mtd, int sector)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint i;\r\nuint32_t value;\r\nfor (i = 0; i < host->pmecc_corr_cap; i++) {\r\nvalue = pmecc_readl_rem_relaxed(host->ecc, sector, i / 2);\r\nif (i & 1)\r\nvalue >>= 16;\r\nvalue &= 0xffff;\r\nhost->pmecc_partial_syn[(2 * i) + 1] = (int16_t)value;\r\n}\r\n}\r\nstatic void pmecc_substitute(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint16_t __iomem *alpha_to = host->pmecc_alpha_to;\r\nint16_t __iomem *index_of = host->pmecc_index_of;\r\nint16_t *partial_syn = host->pmecc_partial_syn;\r\nconst int cap = host->pmecc_corr_cap;\r\nint16_t *si;\r\nint i, j;\r\nsi = host->pmecc_si;\r\nmemset(&si[1], 0, sizeof(int16_t) * (2 * cap - 1));\r\nfor (i = 1; i < 2 * cap; i += 2) {\r\nfor (j = 0; j < host->pmecc_degree; j++) {\r\nif (partial_syn[i] & ((unsigned short)0x1 << j))\r\nsi[i] = readw_relaxed(alpha_to + i * j) ^ si[i];\r\n}\r\n}\r\nfor (i = 2, j = 1; j <= cap; i = ++j << 1) {\r\nif (si[j] == 0) {\r\nsi[i] = 0;\r\n} else {\r\nint16_t tmp;\r\ntmp = readw_relaxed(index_of + si[j]);\r\ntmp = (tmp * 2) % host->pmecc_cw_len;\r\nsi[i] = readw_relaxed(alpha_to + tmp);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void pmecc_get_sigma(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint16_t *lmu = host->pmecc_lmu;\r\nint16_t *si = host->pmecc_si;\r\nint *mu = host->pmecc_mu;\r\nint *dmu = host->pmecc_dmu;\r\nint *delta = host->pmecc_delta;\r\nint cw_len = host->pmecc_cw_len;\r\nconst int16_t cap = host->pmecc_corr_cap;\r\nconst int num = 2 * cap + 1;\r\nint16_t __iomem *index_of = host->pmecc_index_of;\r\nint16_t __iomem *alpha_to = host->pmecc_alpha_to;\r\nint i, j, k;\r\nuint32_t dmu_0_count, tmp;\r\nint16_t *smu = host->pmecc_smu;\r\nint ro;\r\nint largest;\r\nint diff;\r\ndmu_0_count = 0;\r\nmu[0] = -1;\r\nmemset(smu, 0, sizeof(int16_t) * num);\r\nsmu[0] = 1;\r\ndmu[0] = 1;\r\nlmu[0] = 0;\r\ndelta[0] = (mu[0] * 2 - lmu[0]) >> 1;\r\nmu[1] = 0;\r\nmemset(&smu[num], 0, sizeof(int16_t) * num);\r\nsmu[num] = 1;\r\ndmu[1] = si[1];\r\nlmu[1] = 0;\r\ndelta[1] = (mu[1] * 2 - lmu[1]) >> 1;\r\nmemset(&smu[(cap + 1) * num], 0, sizeof(int16_t) * num);\r\nfor (i = 1; i <= cap; i++) {\r\nmu[i + 1] = i << 1;\r\nif (dmu[i] == 0) {\r\ndmu_0_count++;\r\ntmp = ((cap - (lmu[i] >> 1) - 1) / 2);\r\nif ((cap - (lmu[i] >> 1) - 1) & 0x1)\r\ntmp += 2;\r\nelse\r\ntmp += 1;\r\nif (dmu_0_count == tmp) {\r\nfor (j = 0; j <= (lmu[i] >> 1) + 1; j++)\r\nsmu[(cap + 1) * num + j] =\r\nsmu[i * num + j];\r\nlmu[cap + 1] = lmu[i];\r\nreturn;\r\n}\r\nfor (j = 0; j <= lmu[i] >> 1; j++)\r\nsmu[(i + 1) * num + j] = smu[i * num + j];\r\nlmu[i + 1] = lmu[i];\r\n} else {\r\nro = 0;\r\nlargest = -1;\r\nfor (j = 0; j < i; j++) {\r\nif ((dmu[j]) && (delta[j] > largest)) {\r\nlargest = delta[j];\r\nro = j;\r\n}\r\n}\r\ndiff = (mu[i] - mu[ro]);\r\nif ((lmu[i] >> 1) > ((lmu[ro] >> 1) + diff))\r\nlmu[i + 1] = lmu[i];\r\nelse\r\nlmu[i + 1] = ((lmu[ro] >> 1) + diff) * 2;\r\nfor (k = 0; k < num; k++)\r\nsmu[(i + 1) * num + k] = 0;\r\nfor (k = 0; k <= lmu[ro] >> 1; k++) {\r\nint16_t a, b, c;\r\nif (!(smu[ro * num + k] && dmu[i]))\r\ncontinue;\r\na = readw_relaxed(index_of + dmu[i]);\r\nb = readw_relaxed(index_of + dmu[ro]);\r\nc = readw_relaxed(index_of + smu[ro * num + k]);\r\ntmp = a + (cw_len - b) + c;\r\na = readw_relaxed(alpha_to + tmp % cw_len);\r\nsmu[(i + 1) * num + (k + diff)] = a;\r\n}\r\nfor (k = 0; k <= lmu[i] >> 1; k++)\r\nsmu[(i + 1) * num + k] ^= smu[i * num + k];\r\n}\r\ndelta[i + 1] = (mu[i + 1] * 2 - lmu[i + 1]) >> 1;\r\nif (i >= cap)\r\ncontinue;\r\nfor (k = 0; k <= (lmu[i + 1] >> 1); k++) {\r\ntmp = 2 * (i - 1);\r\nif (k == 0) {\r\ndmu[i + 1] = si[tmp + 3];\r\n} else if (smu[(i + 1) * num + k] && si[tmp + 3 - k]) {\r\nint16_t a, b, c;\r\na = readw_relaxed(index_of +\r\nsmu[(i + 1) * num + k]);\r\nb = si[2 * (i - 1) + 3 - k];\r\nc = readw_relaxed(index_of + b);\r\ntmp = a + c;\r\ntmp %= cw_len;\r\ndmu[i + 1] = readw_relaxed(alpha_to + tmp) ^\r\ndmu[i + 1];\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int pmecc_err_location(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nunsigned long end_time;\r\nconst int cap = host->pmecc_corr_cap;\r\nconst int num = 2 * cap + 1;\r\nint sector_size = host->pmecc_sector_size;\r\nint err_nbr = 0;\r\nint roots_nbr;\r\nint i;\r\nuint32_t val;\r\nint16_t *smu = host->pmecc_smu;\r\npmerrloc_writel(host->pmerrloc_base, ELDIS, PMERRLOC_DISABLE);\r\nfor (i = 0; i <= host->pmecc_lmu[cap + 1] >> 1; i++) {\r\npmerrloc_writel_sigma_relaxed(host->pmerrloc_base, i,\r\nsmu[(cap + 1) * num + i]);\r\nerr_nbr++;\r\n}\r\nval = (err_nbr - 1) << 16;\r\nif (sector_size == 1024)\r\nval |= 1;\r\npmerrloc_writel(host->pmerrloc_base, ELCFG, val);\r\npmerrloc_writel(host->pmerrloc_base, ELEN,\r\nsector_size * 8 + host->pmecc_degree * cap);\r\nend_time = jiffies + msecs_to_jiffies(PMECC_MAX_TIMEOUT_MS);\r\nwhile (!(pmerrloc_readl_relaxed(host->pmerrloc_base, ELISR)\r\n& PMERRLOC_CALC_DONE)) {\r\nif (unlikely(time_after(jiffies, end_time))) {\r\ndev_err(host->dev, "PMECC: Timeout to calculate error location.\n");\r\nreturn -1;\r\n}\r\ncpu_relax();\r\n}\r\nroots_nbr = (pmerrloc_readl_relaxed(host->pmerrloc_base, ELISR)\r\n& PMERRLOC_ERR_NUM_MASK) >> 8;\r\nif (roots_nbr == host->pmecc_lmu[cap + 1] >> 1)\r\nreturn err_nbr - 1;\r\nreturn -1;\r\n}\r\nstatic void pmecc_correct_data(struct mtd_info *mtd, uint8_t *buf, uint8_t *ecc,\r\nint sector_num, int extra_bytes, int err_nbr)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint i = 0;\r\nint byte_pos, bit_pos, sector_size, pos;\r\nuint32_t tmp;\r\nuint8_t err_byte;\r\nsector_size = host->pmecc_sector_size;\r\nwhile (err_nbr) {\r\ntmp = pmerrloc_readl_el_relaxed(host->pmerrloc_base, i) - 1;\r\nbyte_pos = tmp / 8;\r\nbit_pos = tmp % 8;\r\nif (byte_pos >= (sector_size + extra_bytes))\r\nBUG();\r\nif (byte_pos < sector_size) {\r\nerr_byte = *(buf + byte_pos);\r\n*(buf + byte_pos) ^= (1 << bit_pos);\r\npos = sector_num * host->pmecc_sector_size + byte_pos;\r\ndev_info(host->dev, "Bit flip in data area, byte_pos: %d, bit_pos: %d, 0x%02x -> 0x%02x\n",\r\npos, bit_pos, err_byte, *(buf + byte_pos));\r\n} else {\r\ntmp = sector_num * host->pmecc_bytes_per_sector\r\n+ (byte_pos - sector_size);\r\nerr_byte = ecc[tmp];\r\necc[tmp] ^= (1 << bit_pos);\r\npos = tmp + nand_chip->ecc.layout->eccpos[0];\r\ndev_info(host->dev, "Bit flip in OOB, oob_byte_pos: %d, bit_pos: %d, 0x%02x -> 0x%02x\n",\r\npos, bit_pos, err_byte, ecc[tmp]);\r\n}\r\ni++;\r\nerr_nbr--;\r\n}\r\nreturn;\r\n}\r\nstatic int pmecc_correction(struct mtd_info *mtd, u32 pmecc_stat, uint8_t *buf,\r\nu8 *ecc)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint i, err_nbr, eccbytes;\r\nuint8_t *buf_pos;\r\nint total_err = 0;\r\neccbytes = nand_chip->ecc.bytes;\r\nfor (i = 0; i < eccbytes; i++)\r\nif (ecc[i] != 0xff)\r\ngoto normal_check;\r\nreturn 0;\r\nnormal_check:\r\nfor (i = 0; i < host->pmecc_sector_number; i++) {\r\nerr_nbr = 0;\r\nif (pmecc_stat & 0x1) {\r\nbuf_pos = buf + i * host->pmecc_sector_size;\r\npmecc_gen_syndrome(mtd, i);\r\npmecc_substitute(mtd);\r\npmecc_get_sigma(mtd);\r\nerr_nbr = pmecc_err_location(mtd);\r\nif (err_nbr == -1) {\r\ndev_err(host->dev, "PMECC: Too many errors\n");\r\nmtd->ecc_stats.failed++;\r\nreturn -EIO;\r\n} else {\r\npmecc_correct_data(mtd, buf_pos, ecc, i,\r\nhost->pmecc_bytes_per_sector, err_nbr);\r\nmtd->ecc_stats.corrected += err_nbr;\r\ntotal_err += err_nbr;\r\n}\r\n}\r\npmecc_stat >>= 1;\r\n}\r\nreturn total_err;\r\n}\r\nstatic int atmel_nand_pmecc_read_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf, int oob_required, int page)\r\n{\r\nstruct atmel_nand_host *host = chip->priv;\r\nint eccsize = chip->ecc.size;\r\nuint8_t *oob = chip->oob_poi;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint32_t stat;\r\nunsigned long end_time;\r\nint bitflips = 0;\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_RST);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\npmecc_writel(host->ecc, CFG, (pmecc_readl_relaxed(host->ecc, CFG)\r\n& ~PMECC_CFG_WRITE_OP) | PMECC_CFG_AUTO_ENABLE);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_ENABLE);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DATA);\r\nchip->read_buf(mtd, buf, eccsize);\r\nchip->read_buf(mtd, oob, mtd->oobsize);\r\nend_time = jiffies + msecs_to_jiffies(PMECC_MAX_TIMEOUT_MS);\r\nwhile ((pmecc_readl_relaxed(host->ecc, SR) & PMECC_SR_BUSY)) {\r\nif (unlikely(time_after(jiffies, end_time))) {\r\ndev_err(host->dev, "PMECC: Timeout to get error status.\n");\r\nreturn -EIO;\r\n}\r\ncpu_relax();\r\n}\r\nstat = pmecc_readl_relaxed(host->ecc, ISR);\r\nif (stat != 0) {\r\nbitflips = pmecc_correction(mtd, stat, buf, &oob[eccpos[0]]);\r\nif (bitflips < 0)\r\nreturn 0;\r\n}\r\nreturn bitflips;\r\n}\r\nstatic int atmel_nand_pmecc_write_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf, int oob_required)\r\n{\r\nstruct atmel_nand_host *host = chip->priv;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nint i, j;\r\nunsigned long end_time;\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_RST);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\npmecc_writel(host->ecc, CFG, (pmecc_readl_relaxed(host->ecc, CFG) |\r\nPMECC_CFG_WRITE_OP) & ~PMECC_CFG_AUTO_ENABLE);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_ENABLE);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DATA);\r\nchip->write_buf(mtd, (u8 *)buf, mtd->writesize);\r\nend_time = jiffies + msecs_to_jiffies(PMECC_MAX_TIMEOUT_MS);\r\nwhile ((pmecc_readl_relaxed(host->ecc, SR) & PMECC_SR_BUSY)) {\r\nif (unlikely(time_after(jiffies, end_time))) {\r\ndev_err(host->dev, "PMECC: Timeout to get ECC value.\n");\r\nreturn -EIO;\r\n}\r\ncpu_relax();\r\n}\r\nfor (i = 0; i < host->pmecc_sector_number; i++) {\r\nfor (j = 0; j < host->pmecc_bytes_per_sector; j++) {\r\nint pos;\r\npos = i * host->pmecc_bytes_per_sector + j;\r\nchip->oob_poi[eccpos[pos]] =\r\npmecc_readb_ecc_relaxed(host->ecc, i, j);\r\n}\r\n}\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic void atmel_pmecc_core_init(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nuint32_t val = 0;\r\nstruct nand_ecclayout *ecc_layout;\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_RST);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\nswitch (host->pmecc_corr_cap) {\r\ncase 2:\r\nval = PMECC_CFG_BCH_ERR2;\r\nbreak;\r\ncase 4:\r\nval = PMECC_CFG_BCH_ERR4;\r\nbreak;\r\ncase 8:\r\nval = PMECC_CFG_BCH_ERR8;\r\nbreak;\r\ncase 12:\r\nval = PMECC_CFG_BCH_ERR12;\r\nbreak;\r\ncase 24:\r\nval = PMECC_CFG_BCH_ERR24;\r\nbreak;\r\n}\r\nif (host->pmecc_sector_size == 512)\r\nval |= PMECC_CFG_SECTOR512;\r\nelse if (host->pmecc_sector_size == 1024)\r\nval |= PMECC_CFG_SECTOR1024;\r\nswitch (host->pmecc_sector_number) {\r\ncase 1:\r\nval |= PMECC_CFG_PAGE_1SECTOR;\r\nbreak;\r\ncase 2:\r\nval |= PMECC_CFG_PAGE_2SECTORS;\r\nbreak;\r\ncase 4:\r\nval |= PMECC_CFG_PAGE_4SECTORS;\r\nbreak;\r\ncase 8:\r\nval |= PMECC_CFG_PAGE_8SECTORS;\r\nbreak;\r\n}\r\nval |= (PMECC_CFG_READ_OP | PMECC_CFG_SPARE_DISABLE\r\n| PMECC_CFG_AUTO_DISABLE);\r\npmecc_writel(host->ecc, CFG, val);\r\necc_layout = nand_chip->ecc.layout;\r\npmecc_writel(host->ecc, SAREA, mtd->oobsize - 1);\r\npmecc_writel(host->ecc, SADDR, ecc_layout->eccpos[0]);\r\npmecc_writel(host->ecc, EADDR,\r\necc_layout->eccpos[ecc_layout->eccbytes - 1]);\r\npmecc_writel(host->ecc, CLK, 2);\r\npmecc_writel(host->ecc, IDR, 0xff);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_ENABLE);\r\n}\r\nstatic int get_onfi_ecc_param(struct nand_chip *chip,\r\nint *ecc_bits, int *sector_size)\r\n{\r\n*ecc_bits = *sector_size = 0;\r\nif (chip->onfi_params.ecc_bits == 0xff)\r\nreturn -1;\r\n*ecc_bits = chip->onfi_params.ecc_bits;\r\n*sector_size = 512;\r\nreturn 0;\r\n}\r\nstatic int pmecc_choose_ecc(struct atmel_nand_host *host,\r\nint *cap, int *sector_size)\r\n{\r\n*cap = *sector_size = 0;\r\nif (host->nand_chip.onfi_version) {\r\nif (!get_onfi_ecc_param(&host->nand_chip, cap, sector_size))\r\ndev_info(host->dev, "ONFI params, minimum required ECC: %d bits in %d bytes\n",\r\n*cap, *sector_size);\r\nelse\r\ndev_info(host->dev, "NAND chip ECC reqirement is in Extended ONFI parameter, we don't support yet.\n");\r\n} else {\r\ndev_info(host->dev, "NAND chip is not ONFI compliant, assume ecc_bits is 2 in 512 bytes");\r\n}\r\nif (*cap == 0 && *sector_size == 0) {\r\n*cap = 2;\r\n*sector_size = 512;\r\n}\r\nif (host->pmecc_corr_cap == 0) {\r\nif (*cap <= 2)\r\nhost->pmecc_corr_cap = 2;\r\nelse if (*cap <= 4)\r\nhost->pmecc_corr_cap = 4;\r\nelse if (*cap < 8)\r\nhost->pmecc_corr_cap = 8;\r\nelse if (*cap < 12)\r\nhost->pmecc_corr_cap = 12;\r\nelse if (*cap < 24)\r\nhost->pmecc_corr_cap = 24;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (host->pmecc_sector_size == 0) {\r\nif (*sector_size >= 1024)\r\nhost->pmecc_sector_size = 1024;\r\nelse if (*sector_size >= 512)\r\nhost->pmecc_sector_size = 512;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init atmel_pmecc_nand_init_params(struct platform_device *pdev,\r\nstruct atmel_nand_host *host)\r\n{\r\nstruct mtd_info *mtd = &host->mtd;\r\nstruct nand_chip *nand_chip = &host->nand_chip;\r\nstruct resource *regs, *regs_pmerr, *regs_rom;\r\nint cap, sector_size, err_no;\r\nerr_no = pmecc_choose_ecc(host, &cap, &sector_size);\r\nif (err_no) {\r\ndev_err(host->dev, "The NAND flash's ECC requirement are not support!");\r\nreturn err_no;\r\n}\r\nif (cap != host->pmecc_corr_cap ||\r\nsector_size != host->pmecc_sector_size)\r\ndev_info(host->dev, "WARNING: Be Caution! Using different PMECC parameters from Nand ONFI ECC reqirement.\n");\r\ncap = host->pmecc_corr_cap;\r\nsector_size = host->pmecc_sector_size;\r\nhost->pmecc_lookup_table_offset = (sector_size == 512) ?\r\nhost->pmecc_lookup_table_offset_512 :\r\nhost->pmecc_lookup_table_offset_1024;\r\ndev_info(host->dev, "Initialize PMECC params, cap: %d, sector: %d\n",\r\ncap, sector_size);\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!regs) {\r\ndev_warn(host->dev,\r\n"Can't get I/O resource regs for PMECC controller, rolling back on software ECC\n");\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nreturn 0;\r\n}\r\nhost->ecc = ioremap(regs->start, resource_size(regs));\r\nif (host->ecc == NULL) {\r\ndev_err(host->dev, "ioremap failed\n");\r\nerr_no = -EIO;\r\ngoto err_pmecc_ioremap;\r\n}\r\nregs_pmerr = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nregs_rom = platform_get_resource(pdev, IORESOURCE_MEM, 3);\r\nif (regs_pmerr && regs_rom) {\r\nhost->pmerrloc_base = ioremap(regs_pmerr->start,\r\nresource_size(regs_pmerr));\r\nhost->pmecc_rom_base = ioremap(regs_rom->start,\r\nresource_size(regs_rom));\r\n}\r\nif (!host->pmerrloc_base || !host->pmecc_rom_base) {\r\ndev_err(host->dev,\r\n"Can not get I/O resource for PMECC ERRLOC controller or ROM!\n");\r\nerr_no = -EIO;\r\ngoto err_pmloc_ioremap;\r\n}\r\nnand_chip->ecc.size = mtd->writesize;\r\nswitch (mtd->writesize) {\r\ncase 2048:\r\nhost->pmecc_degree = PMECC_GF_DIMENSION_13;\r\nhost->pmecc_cw_len = (1 << host->pmecc_degree) - 1;\r\nhost->pmecc_sector_number = mtd->writesize / sector_size;\r\nhost->pmecc_bytes_per_sector = pmecc_get_ecc_bytes(\r\ncap, sector_size);\r\nhost->pmecc_alpha_to = pmecc_get_alpha_to(host);\r\nhost->pmecc_index_of = host->pmecc_rom_base +\r\nhost->pmecc_lookup_table_offset;\r\nnand_chip->ecc.steps = 1;\r\nnand_chip->ecc.strength = cap;\r\nnand_chip->ecc.bytes = host->pmecc_bytes_per_sector *\r\nhost->pmecc_sector_number;\r\nif (nand_chip->ecc.bytes > mtd->oobsize - 2) {\r\ndev_err(host->dev, "No room for ECC bytes\n");\r\nerr_no = -EINVAL;\r\ngoto err_no_ecc_room;\r\n}\r\npmecc_config_ecc_layout(&atmel_pmecc_oobinfo,\r\nmtd->oobsize,\r\nnand_chip->ecc.bytes);\r\nnand_chip->ecc.layout = &atmel_pmecc_oobinfo;\r\nbreak;\r\ncase 512:\r\ncase 1024:\r\ncase 4096:\r\ndev_warn(host->dev,\r\n"Unsupported page size for PMECC, use Software ECC\n");\r\ndefault:\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nreturn 0;\r\n}\r\nerr_no = pmecc_data_alloc(host);\r\nif (err_no) {\r\ndev_err(host->dev,\r\n"Cannot allocate memory for PMECC computation!\n");\r\ngoto err_pmecc_data_alloc;\r\n}\r\nnand_chip->ecc.read_page = atmel_nand_pmecc_read_page;\r\nnand_chip->ecc.write_page = atmel_nand_pmecc_write_page;\r\natmel_pmecc_core_init(mtd);\r\nreturn 0;\r\nerr_pmecc_data_alloc:\r\nerr_no_ecc_room:\r\nerr_pmloc_ioremap:\r\niounmap(host->ecc);\r\nif (host->pmerrloc_base)\r\niounmap(host->pmerrloc_base);\r\nif (host->pmecc_rom_base)\r\niounmap(host->pmecc_rom_base);\r\nerr_pmecc_ioremap:\r\nreturn err_no;\r\n}\r\nstatic int atmel_nand_calculate(struct mtd_info *mtd,\r\nconst u_char *dat, unsigned char *ecc_code)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nunsigned int ecc_value;\r\necc_value = ecc_readl(host->ecc, PR);\r\necc_code[0] = ecc_value & 0xFF;\r\necc_code[1] = (ecc_value >> 8) & 0xFF;\r\necc_value = ecc_readl(host->ecc, NPR) & ATMEL_ECC_NPARITY;\r\necc_code[2] = ecc_value & 0xFF;\r\necc_code[3] = (ecc_value >> 8) & 0xFF;\r\nreturn 0;\r\n}\r\nstatic int atmel_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *p = buf;\r\nuint8_t *oob = chip->oob_poi;\r\nuint8_t *ecc_pos;\r\nint stat;\r\nunsigned int max_bitflips = 0;\r\nif (cpu_is_at32ap7000()) {\r\nstruct atmel_nand_host *host = chip->priv;\r\necc_writel(host->ecc, CR, ATMEL_ECC_RST);\r\n}\r\nchip->read_buf(mtd, p, eccsize);\r\nif (eccpos[0] != 0) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT,\r\nmtd->writesize + eccpos[0], -1);\r\n}\r\necc_pos = oob + eccpos[0];\r\nchip->read_buf(mtd, ecc_pos, eccbytes);\r\nstat = chip->ecc.correct(mtd, p, oob, NULL);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);\r\nchip->read_buf(mtd, oob, mtd->oobsize);\r\nreturn max_bitflips;\r\n}\r\nstatic int atmel_nand_correct(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *isnull)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nunsigned int ecc_status;\r\nunsigned int ecc_word, ecc_bit;\r\necc_status = ecc_readl(host->ecc, SR);\r\nif (likely(!(ecc_status & ATMEL_ECC_RECERR)))\r\nreturn 0;\r\necc_bit = ecc_readl(host->ecc, PR) & ATMEL_ECC_BITADDR;\r\necc_word = ecc_readl(host->ecc, PR) & ATMEL_ECC_WORDADDR;\r\necc_word >>= 4;\r\nif (ecc_status & ATMEL_ECC_MULERR) {\r\nif ((ecc_bit == ATMEL_ECC_BITADDR)\r\n&& (ecc_word == (ATMEL_ECC_WORDADDR >> 4))) {\r\nreturn 0;\r\n}\r\ndev_dbg(host->dev, "atmel_nand : multiple errors detected."\r\n" Unable to correct.\n");\r\nreturn -EIO;\r\n}\r\nif (ecc_status & ATMEL_ECC_ECCERR) {\r\ndev_dbg(host->dev, "atmel_nand : one bit error on ECC code."\r\n" Nothing to correct\n");\r\nreturn 0;\r\n}\r\ndev_dbg(host->dev, "atmel_nand : one bit error on data."\r\n" (word offset in the page :"\r\n" 0x%x bit offset : 0x%x)\n",\r\necc_word, ecc_bit);\r\nif (nand_chip->options & NAND_BUSWIDTH_16) {\r\n((unsigned short *) dat)[ecc_word] ^= (1 << ecc_bit);\r\n} else {\r\ndat[ecc_word] ^= (1 << ecc_bit);\r\n}\r\ndev_dbg(host->dev, "atmel_nand : error corrected\n");\r\nreturn 1;\r\n}\r\nstatic void atmel_nand_hwctl(struct mtd_info *mtd, int mode)\r\n{\r\nif (cpu_is_at32ap7000()) {\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\necc_writel(host->ecc, CR, ATMEL_ECC_RST);\r\n}\r\n}\r\nstatic int atmel_of_init_port(struct atmel_nand_host *host,\r\nstruct device_node *np)\r\n{\r\nu32 val;\r\nu32 offset[2];\r\nint ecc_mode;\r\nstruct atmel_nand_data *board = &host->board;\r\nenum of_gpio_flags flags;\r\nif (of_property_read_u32(np, "atmel,nand-addr-offset", &val) == 0) {\r\nif (val >= 32) {\r\ndev_err(host->dev, "invalid addr-offset %u\n", val);\r\nreturn -EINVAL;\r\n}\r\nboard->ale = val;\r\n}\r\nif (of_property_read_u32(np, "atmel,nand-cmd-offset", &val) == 0) {\r\nif (val >= 32) {\r\ndev_err(host->dev, "invalid cmd-offset %u\n", val);\r\nreturn -EINVAL;\r\n}\r\nboard->cle = val;\r\n}\r\necc_mode = of_get_nand_ecc_mode(np);\r\nboard->ecc_mode = ecc_mode < 0 ? NAND_ECC_SOFT : ecc_mode;\r\nboard->on_flash_bbt = of_get_nand_on_flash_bbt(np);\r\nif (of_get_nand_bus_width(np) == 16)\r\nboard->bus_width_16 = 1;\r\nboard->rdy_pin = of_get_gpio_flags(np, 0, &flags);\r\nboard->rdy_pin_active_low = (flags == OF_GPIO_ACTIVE_LOW);\r\nboard->enable_pin = of_get_gpio(np, 1);\r\nboard->det_pin = of_get_gpio(np, 2);\r\nhost->has_pmecc = of_property_read_bool(np, "atmel,has-pmecc");\r\nif (!(board->ecc_mode == NAND_ECC_HW) || !host->has_pmecc)\r\nreturn 0;\r\nif (of_property_read_u32(np, "atmel,pmecc-cap", &val) == 0) {\r\nif ((val != 2) && (val != 4) && (val != 8) && (val != 12) &&\r\n(val != 24)) {\r\ndev_err(host->dev,\r\n"Unsupported PMECC correction capability: %d; should be 2, 4, 8, 12 or 24\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nhost->pmecc_corr_cap = (u8)val;\r\n}\r\nif (of_property_read_u32(np, "atmel,pmecc-sector-size", &val) == 0) {\r\nif ((val != 512) && (val != 1024)) {\r\ndev_err(host->dev,\r\n"Unsupported PMECC sector size: %d; should be 512 or 1024 bytes\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nhost->pmecc_sector_size = (u16)val;\r\n}\r\nif (of_property_read_u32_array(np, "atmel,pmecc-lookup-table-offset",\r\noffset, 2) != 0) {\r\ndev_err(host->dev, "Cannot get PMECC lookup table offset\n");\r\nreturn -EINVAL;\r\n}\r\nif (!offset[0] && !offset[1]) {\r\ndev_err(host->dev, "Invalid PMECC lookup table offset\n");\r\nreturn -EINVAL;\r\n}\r\nhost->pmecc_lookup_table_offset_512 = offset[0];\r\nhost->pmecc_lookup_table_offset_1024 = offset[1];\r\nreturn 0;\r\n}\r\nstatic int atmel_of_init_port(struct atmel_nand_host *host,\r\nstruct device_node *np)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int __init atmel_hw_nand_init_params(struct platform_device *pdev,\r\nstruct atmel_nand_host *host)\r\n{\r\nstruct mtd_info *mtd = &host->mtd;\r\nstruct nand_chip *nand_chip = &host->nand_chip;\r\nstruct resource *regs;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!regs) {\r\ndev_err(host->dev,\r\n"Can't get I/O resource regs, use software ECC\n");\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nreturn 0;\r\n}\r\nhost->ecc = ioremap(regs->start, resource_size(regs));\r\nif (host->ecc == NULL) {\r\ndev_err(host->dev, "ioremap failed\n");\r\nreturn -EIO;\r\n}\r\nnand_chip->ecc.size = mtd->writesize;\r\nswitch (mtd->writesize) {\r\ncase 512:\r\nnand_chip->ecc.layout = &atmel_oobinfo_small;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_528);\r\nbreak;\r\ncase 1024:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_1056);\r\nbreak;\r\ncase 2048:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_2112);\r\nbreak;\r\ncase 4096:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_4224);\r\nbreak;\r\ndefault:\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nreturn 0;\r\n}\r\nnand_chip->ecc.calculate = atmel_nand_calculate;\r\nnand_chip->ecc.correct = atmel_nand_correct;\r\nnand_chip->ecc.hwctl = atmel_nand_hwctl;\r\nnand_chip->ecc.read_page = atmel_nand_read_page;\r\nnand_chip->ecc.bytes = 4;\r\nnand_chip->ecc.strength = 1;\r\nreturn 0;\r\n}\r\nstatic int __init atmel_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_nand_host *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand_chip;\r\nstruct resource *mem;\r\nstruct mtd_part_parser_data ppdata = {};\r\nint res;\r\nstruct pinctrl *pinctrl;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\nprintk(KERN_ERR "atmel_nand: can't get I/O resource mem\n");\r\nreturn -ENXIO;\r\n}\r\nhost = kzalloc(sizeof(struct atmel_nand_host), GFP_KERNEL);\r\nif (!host) {\r\nprintk(KERN_ERR "atmel_nand: failed to allocate device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nhost->io_phys = (dma_addr_t)mem->start;\r\nhost->io_base = ioremap(mem->start, resource_size(mem));\r\nif (host->io_base == NULL) {\r\nprintk(KERN_ERR "atmel_nand: ioremap failed\n");\r\nres = -EIO;\r\ngoto err_nand_ioremap;\r\n}\r\nmtd = &host->mtd;\r\nnand_chip = &host->nand_chip;\r\nhost->dev = &pdev->dev;\r\nif (pdev->dev.of_node) {\r\nres = atmel_of_init_port(host, pdev->dev.of_node);\r\nif (res)\r\ngoto err_ecc_ioremap;\r\n} else {\r\nmemcpy(&host->board, pdev->dev.platform_data,\r\nsizeof(struct atmel_nand_data));\r\n}\r\nnand_chip->priv = host;\r\nmtd->priv = nand_chip;\r\nmtd->owner = THIS_MODULE;\r\nnand_chip->IO_ADDR_R = host->io_base;\r\nnand_chip->IO_ADDR_W = host->io_base;\r\nnand_chip->cmd_ctrl = atmel_nand_cmd_ctrl;\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl)) {\r\ndev_err(host->dev, "Failed to request pinctrl\n");\r\nres = PTR_ERR(pinctrl);\r\ngoto err_ecc_ioremap;\r\n}\r\nif (gpio_is_valid(host->board.rdy_pin)) {\r\nres = gpio_request(host->board.rdy_pin, "nand_rdy");\r\nif (res < 0) {\r\ndev_err(&pdev->dev,\r\n"can't request rdy gpio %d\n",\r\nhost->board.rdy_pin);\r\ngoto err_ecc_ioremap;\r\n}\r\nres = gpio_direction_input(host->board.rdy_pin);\r\nif (res < 0) {\r\ndev_err(&pdev->dev,\r\n"can't request input direction rdy gpio %d\n",\r\nhost->board.rdy_pin);\r\ngoto err_ecc_ioremap;\r\n}\r\nnand_chip->dev_ready = atmel_nand_device_ready;\r\n}\r\nif (gpio_is_valid(host->board.enable_pin)) {\r\nres = gpio_request(host->board.enable_pin, "nand_enable");\r\nif (res < 0) {\r\ndev_err(&pdev->dev,\r\n"can't request enable gpio %d\n",\r\nhost->board.enable_pin);\r\ngoto err_ecc_ioremap;\r\n}\r\nres = gpio_direction_output(host->board.enable_pin, 1);\r\nif (res < 0) {\r\ndev_err(&pdev->dev,\r\n"can't request output direction enable gpio %d\n",\r\nhost->board.enable_pin);\r\ngoto err_ecc_ioremap;\r\n}\r\n}\r\nnand_chip->ecc.mode = host->board.ecc_mode;\r\nnand_chip->chip_delay = 20;\r\nif (host->board.bus_width_16)\r\nnand_chip->options |= NAND_BUSWIDTH_16;\r\nnand_chip->read_buf = atmel_read_buf;\r\nnand_chip->write_buf = atmel_write_buf;\r\nplatform_set_drvdata(pdev, host);\r\natmel_nand_enable(host);\r\nif (gpio_is_valid(host->board.det_pin)) {\r\nres = gpio_request(host->board.det_pin, "nand_det");\r\nif (res < 0) {\r\ndev_err(&pdev->dev,\r\n"can't request det gpio %d\n",\r\nhost->board.det_pin);\r\ngoto err_no_card;\r\n}\r\nres = gpio_direction_input(host->board.det_pin);\r\nif (res < 0) {\r\ndev_err(&pdev->dev,\r\n"can't request input direction det gpio %d\n",\r\nhost->board.det_pin);\r\ngoto err_no_card;\r\n}\r\nif (gpio_get_value(host->board.det_pin)) {\r\nprintk(KERN_INFO "No SmartMedia card inserted.\n");\r\nres = -ENXIO;\r\ngoto err_no_card;\r\n}\r\n}\r\nif (host->board.on_flash_bbt || on_flash_bbt) {\r\nprintk(KERN_INFO "atmel_nand: Use On Flash BBT\n");\r\nnand_chip->bbt_options |= NAND_BBT_USE_FLASH;\r\n}\r\nif (!cpu_has_dma())\r\nuse_dma = 0;\r\nif (use_dma) {\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\nhost->dma_chan = dma_request_channel(mask, NULL, NULL);\r\nif (!host->dma_chan) {\r\ndev_err(host->dev, "Failed to request DMA channel\n");\r\nuse_dma = 0;\r\n}\r\n}\r\nif (use_dma)\r\ndev_info(host->dev, "Using %s for DMA transfers.\n",\r\ndma_chan_name(host->dma_chan));\r\nelse\r\ndev_info(host->dev, "No DMA support for NAND access.\n");\r\nif (nand_scan_ident(mtd, 1, NULL)) {\r\nres = -ENXIO;\r\ngoto err_scan_ident;\r\n}\r\nif (nand_chip->ecc.mode == NAND_ECC_HW) {\r\nif (host->has_pmecc)\r\nres = atmel_pmecc_nand_init_params(pdev, host);\r\nelse\r\nres = atmel_hw_nand_init_params(pdev, host);\r\nif (res != 0)\r\ngoto err_hw_ecc;\r\n}\r\nif (nand_scan_tail(mtd)) {\r\nres = -ENXIO;\r\ngoto err_scan_tail;\r\n}\r\nmtd->name = "atmel_nand";\r\nppdata.of_node = pdev->dev.of_node;\r\nres = mtd_device_parse_register(mtd, NULL, &ppdata,\r\nhost->board.parts, host->board.num_parts);\r\nif (!res)\r\nreturn res;\r\nerr_scan_tail:\r\nif (host->has_pmecc && host->nand_chip.ecc.mode == NAND_ECC_HW) {\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\npmecc_data_free(host);\r\n}\r\nif (host->ecc)\r\niounmap(host->ecc);\r\nif (host->pmerrloc_base)\r\niounmap(host->pmerrloc_base);\r\nif (host->pmecc_rom_base)\r\niounmap(host->pmecc_rom_base);\r\nerr_hw_ecc:\r\nerr_scan_ident:\r\nerr_no_card:\r\natmel_nand_disable(host);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (host->dma_chan)\r\ndma_release_channel(host->dma_chan);\r\nerr_ecc_ioremap:\r\niounmap(host->io_base);\r\nerr_nand_ioremap:\r\nkfree(host);\r\nreturn res;\r\n}\r\nstatic int __exit atmel_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_nand_host *host = platform_get_drvdata(pdev);\r\nstruct mtd_info *mtd = &host->mtd;\r\nnand_release(mtd);\r\natmel_nand_disable(host);\r\nif (host->has_pmecc && host->nand_chip.ecc.mode == NAND_ECC_HW) {\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\npmerrloc_writel(host->pmerrloc_base, ELDIS,\r\nPMERRLOC_DISABLE);\r\npmecc_data_free(host);\r\n}\r\nif (gpio_is_valid(host->board.det_pin))\r\ngpio_free(host->board.det_pin);\r\nif (gpio_is_valid(host->board.enable_pin))\r\ngpio_free(host->board.enable_pin);\r\nif (gpio_is_valid(host->board.rdy_pin))\r\ngpio_free(host->board.rdy_pin);\r\nif (host->ecc)\r\niounmap(host->ecc);\r\nif (host->pmecc_rom_base)\r\niounmap(host->pmecc_rom_base);\r\nif (host->pmerrloc_base)\r\niounmap(host->pmerrloc_base);\r\nif (host->dma_chan)\r\ndma_release_channel(host->dma_chan);\r\niounmap(host->io_base);\r\nkfree(host);\r\nreturn 0;\r\n}
