static inline struct ds2780_device_info *\r\nto_ds2780_device_info(struct power_supply *psy)\r\n{\r\nreturn container_of(psy, struct ds2780_device_info, bat);\r\n}\r\nstatic inline struct power_supply *to_power_supply(struct device *dev)\r\n{\r\nreturn dev_get_drvdata(dev);\r\n}\r\nstatic inline int ds2780_battery_io(struct ds2780_device_info *dev_info,\r\nchar *buf, int addr, size_t count, int io)\r\n{\r\nreturn w1_ds2780_io(dev_info->w1_dev, buf, addr, count, io);\r\n}\r\nstatic inline int ds2780_read8(struct ds2780_device_info *dev_info, u8 *val,\r\nint addr)\r\n{\r\nreturn ds2780_battery_io(dev_info, val, addr, sizeof(u8), 0);\r\n}\r\nstatic int ds2780_read16(struct ds2780_device_info *dev_info, s16 *val,\r\nint addr)\r\n{\r\nint ret;\r\nu8 raw[2];\r\nret = ds2780_battery_io(dev_info, raw, addr, sizeof(raw), 0);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (raw[0] << 8) | raw[1];\r\nreturn 0;\r\n}\r\nstatic inline int ds2780_read_block(struct ds2780_device_info *dev_info,\r\nu8 *val, int addr, size_t count)\r\n{\r\nreturn ds2780_battery_io(dev_info, val, addr, count, 0);\r\n}\r\nstatic inline int ds2780_write(struct ds2780_device_info *dev_info, u8 *val,\r\nint addr, size_t count)\r\n{\r\nreturn ds2780_battery_io(dev_info, val, addr, count, 1);\r\n}\r\nstatic inline int ds2780_store_eeprom(struct device *dev, int addr)\r\n{\r\nreturn w1_ds2780_eeprom_cmd(dev, addr, W1_DS2780_COPY_DATA);\r\n}\r\nstatic inline int ds2780_recall_eeprom(struct device *dev, int addr)\r\n{\r\nreturn w1_ds2780_eeprom_cmd(dev, addr, W1_DS2780_RECALL_DATA);\r\n}\r\nstatic int ds2780_save_eeprom(struct ds2780_device_info *dev_info, int reg)\r\n{\r\nint ret;\r\nret = ds2780_store_eeprom(dev_info->w1_dev, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ds2780_recall_eeprom(dev_info->w1_dev, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ds2780_set_sense_register(struct ds2780_device_info *dev_info,\r\nu8 conductance)\r\n{\r\nint ret;\r\nret = ds2780_write(dev_info, &conductance,\r\nDS2780_RSNSP_REG, sizeof(u8));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ds2780_save_eeprom(dev_info, DS2780_RSNSP_REG);\r\n}\r\nstatic int ds2780_get_rsgain_register(struct ds2780_device_info *dev_info,\r\nu16 *rsgain)\r\n{\r\nreturn ds2780_read16(dev_info, rsgain, DS2780_RSGAIN_MSB_REG);\r\n}\r\nstatic int ds2780_set_rsgain_register(struct ds2780_device_info *dev_info,\r\nu16 rsgain)\r\n{\r\nint ret;\r\nu8 raw[] = {rsgain >> 8, rsgain & 0xFF};\r\nret = ds2780_write(dev_info, raw,\r\nDS2780_RSGAIN_MSB_REG, sizeof(raw));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ds2780_save_eeprom(dev_info, DS2780_RSGAIN_MSB_REG);\r\n}\r\nstatic int ds2780_get_voltage(struct ds2780_device_info *dev_info,\r\nint *voltage_uV)\r\n{\r\nint ret;\r\ns16 voltage_raw;\r\nret = ds2780_read16(dev_info, &voltage_raw,\r\nDS2780_VOLT_MSB_REG);\r\nif (ret < 0)\r\nreturn ret;\r\n*voltage_uV = (voltage_raw / 32) * 4880;\r\nreturn 0;\r\n}\r\nstatic int ds2780_get_temperature(struct ds2780_device_info *dev_info,\r\nint *temperature)\r\n{\r\nint ret;\r\ns16 temperature_raw;\r\nret = ds2780_read16(dev_info, &temperature_raw,\r\nDS2780_TEMP_MSB_REG);\r\nif (ret < 0)\r\nreturn ret;\r\n*temperature = ((temperature_raw / 32) * 125) / 100;\r\nreturn 0;\r\n}\r\nstatic int ds2780_get_current(struct ds2780_device_info *dev_info,\r\nenum current_types type, int *current_uA)\r\n{\r\nint ret, sense_res;\r\ns16 current_raw;\r\nu8 sense_res_raw, reg_msb;\r\nret = ds2780_read8(dev_info, &sense_res_raw, DS2780_RSNSP_REG);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sense_res_raw == 0) {\r\ndev_err(dev_info->dev, "sense resistor value is 0\n");\r\nreturn -EINVAL;\r\n}\r\nsense_res = 1000 / sense_res_raw;\r\nif (type == CURRENT_NOW)\r\nreg_msb = DS2780_CURRENT_MSB_REG;\r\nelse if (type == CURRENT_AVG)\r\nreg_msb = DS2780_IAVG_MSB_REG;\r\nelse\r\nreturn -EINVAL;\r\nret = ds2780_read16(dev_info, &current_raw, reg_msb);\r\nif (ret < 0)\r\nreturn ret;\r\n*current_uA = current_raw * (DS2780_CURRENT_UNITS / sense_res);\r\nreturn 0;\r\n}\r\nstatic int ds2780_get_accumulated_current(struct ds2780_device_info *dev_info,\r\nint *accumulated_current)\r\n{\r\nint ret, sense_res;\r\ns16 current_raw;\r\nu8 sense_res_raw;\r\nret = ds2780_read8(dev_info, &sense_res_raw, DS2780_RSNSP_REG);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sense_res_raw == 0) {\r\ndev_err(dev_info->dev, "sense resistor value is 0\n");\r\nreturn -ENXIO;\r\n}\r\nsense_res = 1000 / sense_res_raw;\r\nret = ds2780_read16(dev_info, &current_raw, DS2780_ACR_MSB_REG);\r\nif (ret < 0)\r\nreturn ret;\r\n*accumulated_current = current_raw * (DS2780_CHARGE_UNITS / sense_res);\r\nreturn 0;\r\n}\r\nstatic int ds2780_get_capacity(struct ds2780_device_info *dev_info,\r\nint *capacity)\r\n{\r\nint ret;\r\nu8 raw;\r\nret = ds2780_read8(dev_info, &raw, DS2780_RARC_REG);\r\nif (ret < 0)\r\nreturn ret;\r\n*capacity = raw;\r\nreturn raw;\r\n}\r\nstatic int ds2780_get_status(struct ds2780_device_info *dev_info, int *status)\r\n{\r\nint ret, current_uA, capacity;\r\nret = ds2780_get_current(dev_info, CURRENT_NOW, &current_uA);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ds2780_get_capacity(dev_info, &capacity);\r\nif (ret < 0)\r\nreturn ret;\r\nif (capacity == 100)\r\n*status = POWER_SUPPLY_STATUS_FULL;\r\nelse if (current_uA == 0)\r\n*status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (current_uA < 0)\r\n*status = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\n*status = POWER_SUPPLY_STATUS_CHARGING;\r\nreturn 0;\r\n}\r\nstatic int ds2780_get_charge_now(struct ds2780_device_info *dev_info,\r\nint *charge_now)\r\n{\r\nint ret;\r\nu16 charge_raw;\r\nret = ds2780_read16(dev_info, &charge_raw, DS2780_RAAC_MSB_REG);\r\nif (ret < 0)\r\nreturn ret;\r\n*charge_now = charge_raw * 1600;\r\nreturn 0;\r\n}\r\nstatic int ds2780_get_control_register(struct ds2780_device_info *dev_info,\r\nu8 *control_reg)\r\n{\r\nreturn ds2780_read8(dev_info, control_reg, DS2780_CONTROL_REG);\r\n}\r\nstatic int ds2780_set_control_register(struct ds2780_device_info *dev_info,\r\nu8 control_reg)\r\n{\r\nint ret;\r\nret = ds2780_write(dev_info, &control_reg,\r\nDS2780_CONTROL_REG, sizeof(u8));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ds2780_save_eeprom(dev_info, DS2780_CONTROL_REG);\r\n}\r\nstatic int ds2780_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret = 0;\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = ds2780_get_voltage(dev_info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nret = ds2780_get_temperature(dev_info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = model;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = manufacturer;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = ds2780_get_current(dev_info, CURRENT_NOW, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nret = ds2780_get_current(dev_info, CURRENT_AVG, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nret = ds2780_get_status(dev_info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = ds2780_get_capacity(dev_info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_COUNTER:\r\nret = ds2780_get_accumulated_current(dev_info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nret = ds2780_get_charge_now(dev_info, &val->intval);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t ds2780_get_pmod_enabled(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 control_reg;\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nret = ds2780_get_control_register(dev_info, &control_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n",\r\n!!(control_reg & DS2780_CONTROL_REG_PMOD));\r\n}\r\nstatic ssize_t ds2780_set_pmod_enabled(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint ret;\r\nu8 control_reg, new_setting;\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nret = ds2780_get_control_register(dev_info, &control_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kstrtou8(buf, 0, &new_setting);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((new_setting != 0) && (new_setting != 1)) {\r\ndev_err(dev_info->dev, "Invalid pmod setting (0 or 1)\n");\r\nreturn -EINVAL;\r\n}\r\nif (new_setting)\r\ncontrol_reg |= DS2780_CONTROL_REG_PMOD;\r\nelse\r\ncontrol_reg &= ~DS2780_CONTROL_REG_PMOD;\r\nret = ds2780_set_control_register(dev_info, control_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t ds2780_get_sense_resistor_value(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 sense_resistor;\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nret = ds2780_read8(dev_info, &sense_resistor, DS2780_RSNSP_REG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sprintf(buf, "%d\n", sense_resistor);\r\nreturn ret;\r\n}\r\nstatic ssize_t ds2780_set_sense_resistor_value(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint ret;\r\nu8 new_setting;\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nret = kstrtou8(buf, 0, &new_setting);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ds2780_set_sense_register(dev_info, new_setting);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t ds2780_get_rsgain_setting(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu16 rsgain;\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nret = ds2780_get_rsgain_register(dev_info, &rsgain);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", rsgain);\r\n}\r\nstatic ssize_t ds2780_set_rsgain_setting(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint ret;\r\nu16 new_setting;\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nret = kstrtou16(buf, 0, &new_setting);\r\nif (ret < 0)\r\nreturn ret;\r\nif (new_setting > 1999) {\r\ndev_err(dev_info->dev, "Invalid rsgain setting (0 - 1999)\n");\r\nreturn -EINVAL;\r\n}\r\nret = ds2780_set_rsgain_register(dev_info, new_setting);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t ds2780_get_pio_pin(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 sfr;\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nret = ds2780_read8(dev_info, &sfr, DS2780_SFR_REG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sprintf(buf, "%d\n", sfr & DS2780_SFR_REG_PIOSC);\r\nreturn ret;\r\n}\r\nstatic ssize_t ds2780_set_pio_pin(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint ret;\r\nu8 new_setting;\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nret = kstrtou8(buf, 0, &new_setting);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((new_setting != 0) && (new_setting != 1)) {\r\ndev_err(dev_info->dev, "Invalid pio_pin setting (0 or 1)\n");\r\nreturn -EINVAL;\r\n}\r\nret = ds2780_write(dev_info, &new_setting,\r\nDS2780_SFR_REG, sizeof(u8));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t ds2780_read_param_eeprom_bin(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\ncount = min_t(loff_t, count,\r\nDS2780_EEPROM_BLOCK1_END -\r\nDS2780_EEPROM_BLOCK1_START + 1 - off);\r\nreturn ds2780_read_block(dev_info, buf,\r\nDS2780_EEPROM_BLOCK1_START + off, count);\r\n}\r\nstatic ssize_t ds2780_write_param_eeprom_bin(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nint ret;\r\ncount = min_t(loff_t, count,\r\nDS2780_EEPROM_BLOCK1_END -\r\nDS2780_EEPROM_BLOCK1_START + 1 - off);\r\nret = ds2780_write(dev_info, buf,\r\nDS2780_EEPROM_BLOCK1_START + off, count);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ds2780_save_eeprom(dev_info, DS2780_EEPROM_BLOCK1_START);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t ds2780_read_user_eeprom_bin(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\ncount = min_t(loff_t, count,\r\nDS2780_EEPROM_BLOCK0_END -\r\nDS2780_EEPROM_BLOCK0_START + 1 - off);\r\nreturn ds2780_read_block(dev_info, buf,\r\nDS2780_EEPROM_BLOCK0_START + off, count);\r\n}\r\nstatic ssize_t ds2780_write_user_eeprom_bin(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct power_supply *psy = to_power_supply(dev);\r\nstruct ds2780_device_info *dev_info = to_ds2780_device_info(psy);\r\nint ret;\r\ncount = min_t(loff_t, count,\r\nDS2780_EEPROM_BLOCK0_END -\r\nDS2780_EEPROM_BLOCK0_START + 1 - off);\r\nret = ds2780_write(dev_info, buf,\r\nDS2780_EEPROM_BLOCK0_START + off, count);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ds2780_save_eeprom(dev_info, DS2780_EEPROM_BLOCK0_START);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int ds2780_battery_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct ds2780_device_info *dev_info;\r\ndev_info = devm_kzalloc(&pdev->dev, sizeof(*dev_info), GFP_KERNEL);\r\nif (!dev_info) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nplatform_set_drvdata(pdev, dev_info);\r\ndev_info->dev = &pdev->dev;\r\ndev_info->w1_dev = pdev->dev.parent;\r\ndev_info->bat.name = dev_name(&pdev->dev);\r\ndev_info->bat.type = POWER_SUPPLY_TYPE_BATTERY;\r\ndev_info->bat.properties = ds2780_battery_props;\r\ndev_info->bat.num_properties = ARRAY_SIZE(ds2780_battery_props);\r\ndev_info->bat.get_property = ds2780_battery_get_property;\r\nret = power_supply_register(&pdev->dev, &dev_info->bat);\r\nif (ret) {\r\ndev_err(dev_info->dev, "failed to register battery\n");\r\ngoto fail;\r\n}\r\nret = sysfs_create_group(&dev_info->bat.dev->kobj, &ds2780_attr_group);\r\nif (ret) {\r\ndev_err(dev_info->dev, "failed to create sysfs group\n");\r\ngoto fail_unregister;\r\n}\r\nret = sysfs_create_bin_file(&dev_info->bat.dev->kobj,\r\n&ds2780_param_eeprom_bin_attr);\r\nif (ret) {\r\ndev_err(dev_info->dev,\r\n"failed to create param eeprom bin file");\r\ngoto fail_remove_group;\r\n}\r\nret = sysfs_create_bin_file(&dev_info->bat.dev->kobj,\r\n&ds2780_user_eeprom_bin_attr);\r\nif (ret) {\r\ndev_err(dev_info->dev,\r\n"failed to create user eeprom bin file");\r\ngoto fail_remove_bin_file;\r\n}\r\nreturn 0;\r\nfail_remove_bin_file:\r\nsysfs_remove_bin_file(&dev_info->bat.dev->kobj,\r\n&ds2780_param_eeprom_bin_attr);\r\nfail_remove_group:\r\nsysfs_remove_group(&dev_info->bat.dev->kobj, &ds2780_attr_group);\r\nfail_unregister:\r\npower_supply_unregister(&dev_info->bat);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int ds2780_battery_remove(struct platform_device *pdev)\r\n{\r\nstruct ds2780_device_info *dev_info = platform_get_drvdata(pdev);\r\nsysfs_remove_group(&dev_info->bat.dev->kobj, &ds2780_attr_group);\r\npower_supply_unregister(&dev_info->bat);\r\nreturn 0;\r\n}
