static int synaptics_rmi4_set_page(struct synaptics_rmi4_data *pdata,\r\nunsigned int address)\r\n{\r\nunsigned char txbuf[PAGE_LEN];\r\nint retval;\r\nunsigned int page;\r\nstruct i2c_client *i2c = pdata->i2c_client;\r\npage = ((address >> 8) & MASK_8BIT);\r\nif (page != pdata->current_page) {\r\ntxbuf[0] = MASK_8BIT;\r\ntxbuf[1] = page;\r\nretval = i2c_master_send(i2c, txbuf, PAGE_LEN);\r\nif (retval != PAGE_LEN)\r\ndev_err(&i2c->dev, "%s:failed:%d\n", __func__, retval);\r\nelse\r\npdata->current_page = page;\r\n} else\r\nretval = PAGE_LEN;\r\nreturn retval;\r\n}\r\nstatic int synaptics_rmi4_i2c_block_read(struct synaptics_rmi4_data *pdata,\r\nunsigned short address,\r\nunsigned char *valp, int size)\r\n{\r\nint retval = 0;\r\nint retry_count = 0;\r\nint index;\r\nstruct i2c_client *i2c = pdata->i2c_client;\r\nmutex_lock(&(pdata->rmi4_page_mutex));\r\nretval = synaptics_rmi4_set_page(pdata, address);\r\nif (retval != PAGE_LEN)\r\ngoto exit;\r\nindex = address & MASK_8BIT;\r\nretry:\r\nretval = i2c_smbus_read_i2c_block_data(i2c, index, size, valp);\r\nif (retval != size) {\r\nif (++retry_count == MAX_RETRY_COUNT)\r\ndev_err(&i2c->dev,\r\n"%s:address 0x%04x size %d failed:%d\n",\r\n__func__, address, size, retval);\r\nelse {\r\nsynaptics_rmi4_set_page(pdata, address);\r\ngoto retry;\r\n}\r\n}\r\nexit:\r\nmutex_unlock(&(pdata->rmi4_page_mutex));\r\nreturn retval;\r\n}\r\nstatic int synaptics_rmi4_i2c_byte_write(struct synaptics_rmi4_data *pdata,\r\nunsigned short address,\r\nunsigned char data)\r\n{\r\nunsigned char txbuf[2];\r\nint retval = 0;\r\nstruct i2c_client *i2c = pdata->i2c_client;\r\nmutex_lock(&(pdata->rmi4_page_mutex));\r\nretval = synaptics_rmi4_set_page(pdata, address);\r\nif (retval != PAGE_LEN)\r\ngoto exit;\r\ntxbuf[0] = address & MASK_8BIT;\r\ntxbuf[1] = data;\r\nretval = i2c_master_send(pdata->i2c_client, txbuf, 2);\r\nif (retval != 2) {\r\ndev_err(&i2c->dev, "%s:failed:%d\n", __func__, retval);\r\nretval = -EIO;\r\n} else\r\nretval = 1;\r\nexit:\r\nmutex_unlock(&(pdata->rmi4_page_mutex));\r\nreturn retval;\r\n}\r\nstatic int synpatics_rmi4_touchpad_report(struct synaptics_rmi4_data *pdata,\r\nstruct synaptics_rmi4_fn *rfi)\r\n{\r\nint touch_count = 0;\r\nint finger;\r\nint finger_registers;\r\nint reg;\r\nint finger_shift;\r\nint finger_status;\r\nint retval;\r\nint x, y;\r\nint wx, wy;\r\nunsigned short data_base_addr;\r\nunsigned short data_offset;\r\nunsigned char data_reg_blk_size;\r\nunsigned char values[2];\r\nunsigned char data[DATA_LEN];\r\nunsigned char fingers_supported = pdata->fingers_supported;\r\nstruct i2c_client *client = pdata->i2c_client;\r\nstruct input_dev *input_dev = pdata->input_dev;\r\nfinger_registers = (fingers_supported + 3)/4;\r\ndata_base_addr = rfi->fn_desc.data_base_addr;\r\nretval = synaptics_rmi4_i2c_block_read(pdata, data_base_addr, values,\r\nfinger_registers);\r\nif (retval != finger_registers) {\r\ndev_err(&client->dev, "%s:read status registers failed\n",\r\n__func__);\r\nreturn 0;\r\n}\r\ndata_reg_blk_size = rfi->size_of_data_register_block;\r\nfor (finger = 0; finger < fingers_supported; finger++) {\r\nreg = finger/4;\r\nfinger_shift = (finger % 4) * 2;\r\nfinger_status = (values[reg] >> finger_shift) & 3;\r\ninput_mt_slot(input_dev, finger);\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER,\r\nfinger_status != 0);\r\nif (finger_status) {\r\ndata_offset = data_base_addr +\r\n((finger * data_reg_blk_size) +\r\nfinger_registers);\r\nretval = synaptics_rmi4_i2c_block_read(pdata,\r\ndata_offset, data,\r\ndata_reg_blk_size);\r\nif (retval != data_reg_blk_size) {\r\ndev_err(&client->dev, "%s:read data failed\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nx = (data[0] << 4) | (data[2] & MASK_4BIT);\r\ny = (data[1] << 4) | ((data[2] >> 4) & MASK_4BIT);\r\nwy = (data[3] >> 4) & MASK_4BIT;\r\nwx = (data[3] & MASK_4BIT);\r\nif (pdata->board->x_flip)\r\nx = pdata->sensor_max_x - x;\r\nif (pdata->board->y_flip)\r\ny = pdata->sensor_max_y - y;\r\ninput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR,\r\nmax(wx, wy));\r\ninput_report_abs(input_dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\r\ntouch_count++;\r\n}\r\n}\r\ninput_mt_sync_frame(input_dev);\r\ninput_sync(input_dev);\r\nreturn touch_count;\r\n}\r\nstatic int synaptics_rmi4_report_device(struct synaptics_rmi4_data *pdata,\r\nstruct synaptics_rmi4_fn *rfi)\r\n{\r\nint touch = 0;\r\nstruct i2c_client *client = pdata->i2c_client;\r\nstatic int num_error_reports;\r\nif (rfi->fn_number != SYNAPTICS_RMI4_TOUCHPAD_FUNC_NUM) {\r\nnum_error_reports++;\r\nif (num_error_reports < MAX_ERROR_REPORT)\r\ndev_err(&client->dev, "%s:report not supported\n",\r\n__func__);\r\n} else\r\ntouch = synpatics_rmi4_touchpad_report(pdata, rfi);\r\nreturn touch;\r\n}\r\nstatic int synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *pdata)\r\n{\r\nunsigned char intr_status[4];\r\nint touch = 0;\r\nunsigned int retval;\r\nstruct synaptics_rmi4_fn *rfi;\r\nstruct synaptics_rmi4_device_info *rmi;\r\nstruct i2c_client *client = pdata->i2c_client;\r\nretval = synaptics_rmi4_i2c_block_read(pdata,\r\npdata->fn01_data_base_addr + 1,\r\nintr_status,\r\npdata->number_of_interrupt_register);\r\nif (retval != pdata->number_of_interrupt_register) {\r\ndev_err(&client->dev,\r\n"could not read interrupt status registers\n");\r\nreturn 0;\r\n}\r\nrmi = &(pdata->rmi4_mod_info);\r\nlist_for_each_entry(rfi, &rmi->support_fn_list, link) {\r\nif (rfi->num_of_data_sources) {\r\nif (intr_status[rfi->index_to_intr_reg] &\r\nrfi->intr_mask)\r\ntouch = synaptics_rmi4_report_device(pdata,\r\nrfi);\r\n}\r\n}\r\nreturn touch;\r\n}\r\nstatic irqreturn_t synaptics_rmi4_irq(int irq, void *data)\r\n{\r\nstruct synaptics_rmi4_data *pdata = data;\r\nint touch_count;\r\ndo {\r\ntouch_count = synaptics_rmi4_sensor_report(pdata);\r\nif (touch_count)\r\nwait_event_timeout(pdata->wait, pdata->touch_stopped,\r\nmsecs_to_jiffies(1));\r\nelse\r\nbreak;\r\n} while (!pdata->touch_stopped);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int synpatics_rmi4_touchpad_detect(struct synaptics_rmi4_data *pdata,\r\nstruct synaptics_rmi4_fn *rfi,\r\nstruct synaptics_rmi4_fn_desc *fd,\r\nunsigned int interruptcount)\r\n{\r\nunsigned char queries[QUERY_LEN];\r\nunsigned short intr_offset;\r\nunsigned char abs_data_size;\r\nunsigned char abs_data_blk_size;\r\nunsigned char egr_0, egr_1;\r\nunsigned int all_data_blk_size;\r\nint has_pinch, has_flick, has_tap;\r\nint has_tapandhold, has_doubletap;\r\nint has_earlytap, has_press;\r\nint has_palmdetect, has_rotate;\r\nint has_rel;\r\nint i;\r\nint retval;\r\nstruct i2c_client *client = pdata->i2c_client;\r\nrfi->fn_desc.query_base_addr = fd->query_base_addr;\r\nrfi->fn_desc.data_base_addr = fd->data_base_addr;\r\nrfi->fn_desc.intr_src_count = fd->intr_src_count;\r\nrfi->fn_desc.fn_number = fd->fn_number;\r\nrfi->fn_number = fd->fn_number;\r\nrfi->num_of_data_sources = fd->intr_src_count;\r\nrfi->fn_desc.ctrl_base_addr = fd->ctrl_base_addr;\r\nrfi->fn_desc.cmd_base_addr = fd->cmd_base_addr;\r\nretval = synaptics_rmi4_i2c_block_read(pdata, fd->query_base_addr,\r\nqueries,\r\nsizeof(queries));\r\nif (retval != sizeof(queries)) {\r\ndev_err(&client->dev, "%s:read function query registers\n",\r\n__func__);\r\nreturn retval;\r\n}\r\nif ((queries[1] & MASK_3BIT) <= 4)\r\nrfi->num_of_data_points = (queries[1] & MASK_3BIT) + 1;\r\nelse {\r\nif ((queries[1] & MASK_3BIT) == 5)\r\nrfi->num_of_data_points = 10;\r\n}\r\npdata->fingers_supported = rfi->num_of_data_points;\r\nrfi->index_to_intr_reg = (interruptcount + 7)/8;\r\nif (rfi->index_to_intr_reg != 0)\r\nrfi->index_to_intr_reg -= 1;\r\nintr_offset = interruptcount % 8;\r\nrfi->intr_mask = 0;\r\nfor (i = intr_offset;\r\ni < ((fd->intr_src_count & MASK_3BIT) + intr_offset); i++)\r\nrfi->intr_mask |= 1 << i;\r\nabs_data_size = queries[5] & MASK_2BIT;\r\nabs_data_blk_size = 3 + (2 * (abs_data_size == 0 ? 1 : 0));\r\nrfi->size_of_data_register_block = abs_data_blk_size;\r\negr_0 = queries[7];\r\negr_1 = queries[8];\r\nhas_pinch = egr_0 & HAS_PINCH;\r\nhas_flick = egr_0 & HAS_FLICK;\r\nhas_tap = egr_0 & HAS_TAP;\r\nhas_earlytap = egr_0 & HAS_EARLYTAP;\r\nhas_press = egr_0 & HAS_PRESS;\r\nhas_rotate = egr_1 & HAS_ROTATE;\r\nhas_rel = queries[1] & HAS_RELEASE;\r\nhas_tapandhold = egr_0 & HAS_TAPANDHOLD;\r\nhas_doubletap = egr_0 & HAS_DOUBLETAP;\r\nhas_palmdetect = egr_1 & HAS_PALMDETECT;\r\nall_data_blk_size =\r\n((rfi->num_of_data_points + 3) / 4) +\r\n(abs_data_blk_size * rfi->num_of_data_points) +\r\n2 * has_rel +\r\n!!(egr_0) +\r\n(egr_0 || egr_1) +\r\n!!(has_pinch | has_flick) +\r\n2 * !!(has_flick);\r\nreturn retval;\r\n}\r\nstatic int synaptics_rmi4_touchpad_config(struct synaptics_rmi4_data *pdata,\r\nstruct synaptics_rmi4_fn *rfi)\r\n{\r\nunsigned char data[BUF_LEN];\r\nint retval = 0;\r\nstruct i2c_client *client = pdata->i2c_client;\r\nretval = synaptics_rmi4_i2c_block_read(pdata,\r\nrfi->fn_desc.query_base_addr,\r\ndata, QUERY_LEN);\r\nif (retval != QUERY_LEN)\r\ndev_err(&client->dev, "%s:read query registers failed\n",\r\n__func__);\r\nelse {\r\nretval = synaptics_rmi4_i2c_block_read(pdata,\r\nrfi->fn_desc.ctrl_base_addr,\r\ndata, DATA_BUF_LEN);\r\nif (retval != DATA_BUF_LEN) {\r\ndev_err(&client->dev,\r\n"%s:read control registers failed\n",\r\n__func__);\r\nreturn retval;\r\n}\r\npdata->sensor_max_x = ((data[6] & MASK_8BIT) << 0) |\r\n((data[7] & MASK_4BIT) << 8);\r\npdata->sensor_max_y = ((data[8] & MASK_5BIT) << 0) |\r\n((data[9] & MASK_4BIT) << 8);\r\n}\r\nreturn retval;\r\n}\r\nstatic int synaptics_rmi4_i2c_query_device(struct synaptics_rmi4_data *pdata)\r\n{\r\nint i;\r\nint retval;\r\nunsigned char std_queries[STD_QUERY_LEN];\r\nunsigned char intr_count = 0;\r\nint data_sources = 0;\r\nunsigned int ctrl_offset;\r\nstruct synaptics_rmi4_fn *rfi;\r\nstruct synaptics_rmi4_fn_desc rmi_fd;\r\nstruct synaptics_rmi4_device_info *rmi;\r\nstruct i2c_client *client = pdata->i2c_client;\r\nINIT_LIST_HEAD(&pdata->rmi4_mod_info.support_fn_list);\r\nfor (i = PDT_START_SCAN_LOCATION; i > PDT_END_SCAN_LOCATION;\r\ni -= PDT_ENTRY_SIZE) {\r\nretval = synaptics_rmi4_i2c_block_read(pdata, i,\r\n(unsigned char *)&rmi_fd,\r\nsizeof(rmi_fd));\r\nif (retval != sizeof(rmi_fd)) {\r\ndev_err(&client->dev, "%s: read error\n", __func__);\r\nreturn -EIO;\r\n}\r\nrfi = NULL;\r\nif (rmi_fd.fn_number) {\r\nswitch (rmi_fd.fn_number & MASK_8BIT) {\r\ncase SYNAPTICS_RMI4_DEVICE_CONTROL_FUNC_NUM:\r\npdata->fn01_query_base_addr =\r\nrmi_fd.query_base_addr;\r\npdata->fn01_ctrl_base_addr =\r\nrmi_fd.ctrl_base_addr;\r\npdata->fn01_data_base_addr =\r\nrmi_fd.data_base_addr;\r\nbreak;\r\ncase SYNAPTICS_RMI4_TOUCHPAD_FUNC_NUM:\r\nif (rmi_fd.intr_src_count) {\r\nrfi = kmalloc(sizeof(*rfi),\r\nGFP_KERNEL);\r\nif (!rfi)\r\nreturn -ENOMEM;\r\nretval = synpatics_rmi4_touchpad_detect\r\n(pdata, rfi,\r\n&rmi_fd,\r\nintr_count);\r\nif (retval < 0) {\r\nkfree(rfi);\r\nreturn retval;\r\n}\r\n}\r\nbreak;\r\n}\r\nintr_count += (rmi_fd.intr_src_count & MASK_3BIT);\r\nif (rfi && rmi_fd.intr_src_count) {\r\nmutex_lock(&(pdata->fn_list_mutex));\r\nlist_add_tail(&rfi->link,\r\n&pdata->rmi4_mod_info.support_fn_list);\r\nmutex_unlock(&(pdata->fn_list_mutex));\r\n}\r\n} else {\r\ndev_dbg(&client->dev,\r\n"%s:end of PDT\n", __func__);\r\nbreak;\r\n}\r\n}\r\npdata->number_of_interrupt_register = (intr_count + 7) / 8;\r\nretval = synaptics_rmi4_i2c_block_read(pdata,\r\npdata->fn01_query_base_addr,\r\nstd_queries,\r\nsizeof(std_queries));\r\nif (retval != sizeof(std_queries)) {\r\ndev_err(&client->dev, "%s:Failed reading queries\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\npdata->rmi4_mod_info.version_major = 4;\r\npdata->rmi4_mod_info.version_minor = 0;\r\npdata->rmi4_mod_info.manufacturer_id = std_queries[0];\r\npdata->rmi4_mod_info.product_props = std_queries[1];\r\npdata->rmi4_mod_info.product_info[0] = std_queries[2];\r\npdata->rmi4_mod_info.product_info[1] = std_queries[3];\r\npdata->rmi4_mod_info.date_code[0] = std_queries[4] & MASK_5BIT;\r\npdata->rmi4_mod_info.date_code[1] = std_queries[5] & MASK_4BIT;\r\npdata->rmi4_mod_info.date_code[2] = std_queries[6] & MASK_5BIT;\r\npdata->rmi4_mod_info.tester_id = ((std_queries[7] & MASK_7BIT) << 8) |\r\n(std_queries[8] & MASK_7BIT);\r\npdata->rmi4_mod_info.serial_number =\r\n((std_queries[9] & MASK_7BIT) << 8) |\r\n(std_queries[10] & MASK_7BIT);\r\nmemcpy(pdata->rmi4_mod_info.product_id_string, &std_queries[11], 10);\r\nif (pdata->rmi4_mod_info.manufacturer_id != 1)\r\ndev_err(&client->dev, "%s: non-Synaptics mfg id:%d\n",\r\n__func__, pdata->rmi4_mod_info.manufacturer_id);\r\nlist_for_each_entry(rfi, &pdata->rmi4_mod_info.support_fn_list, link)\r\ndata_sources += rfi->num_of_data_sources;\r\nif (data_sources) {\r\nrmi = &(pdata->rmi4_mod_info);\r\nlist_for_each_entry(rfi, &rmi->support_fn_list, link) {\r\nif (rfi->num_of_data_sources) {\r\nif (rfi->fn_number ==\r\nSYNAPTICS_RMI4_TOUCHPAD_FUNC_NUM) {\r\nretval = synaptics_rmi4_touchpad_config\r\n(pdata, rfi);\r\nif (retval < 0)\r\nreturn retval;\r\n} else\r\ndev_err(&client->dev,\r\n"%s:fn_number not supported\n",\r\n__func__);\r\nctrl_offset = pdata->fn01_ctrl_base_addr + 1 +\r\nrfi->index_to_intr_reg;\r\nretval = synaptics_rmi4_i2c_byte_write(pdata,\r\nctrl_offset,\r\nrfi->intr_mask);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int synaptics_rmi4_probe\r\n(struct i2c_client *client, const struct i2c_device_id *dev_id)\r\n{\r\nint retval;\r\nunsigned char intr_status[4];\r\nstruct synaptics_rmi4_data *rmi4_data;\r\nconst struct synaptics_rmi4_platform_data *platformdata =\r\nclient->dev.platform_data;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "i2c smbus byte data not supported\n");\r\nreturn -EIO;\r\n}\r\nif (!platformdata)\r\nplatformdata = &synaptics_rmi4_platformdata;\r\nrmi4_data = kcalloc(2, sizeof(struct synaptics_rmi4_data),\r\nGFP_KERNEL);\r\nif (!rmi4_data)\r\nreturn -ENOMEM;\r\nrmi4_data->input_dev = input_allocate_device();\r\nif (rmi4_data->input_dev == NULL) {\r\ndev_err(&client->dev, "%s:input device alloc failed\n",\r\n__func__);\r\nretval = -ENOMEM;\r\ngoto err_input;\r\n}\r\nrmi4_data->regulator = regulator_get(&client->dev, "vdd");\r\nif (IS_ERR(rmi4_data->regulator)) {\r\ndev_err(&client->dev, "%s:get regulator failed\n",\r\n__func__);\r\nretval = PTR_ERR(rmi4_data->regulator);\r\ngoto err_get_regulator;\r\n}\r\nretval = regulator_enable(rmi4_data->regulator);\r\nif (retval < 0) {\r\ndev_err(&client->dev, "%s:regulator enable failed\n",\r\n__func__);\r\ngoto err_regulator_enable;\r\n}\r\ninit_waitqueue_head(&rmi4_data->wait);\r\nrmi4_data->i2c_client = client;\r\nrmi4_data->current_page = MASK_16BIT;\r\nrmi4_data->board = platformdata;\r\nrmi4_data->touch_stopped = false;\r\nmutex_init(&(rmi4_data->fn_list_mutex));\r\nmutex_init(&(rmi4_data->rmi4_page_mutex));\r\nretval = synaptics_rmi4_i2c_query_device(rmi4_data);\r\nif (retval) {\r\ndev_err(&client->dev, "%s: rmi4 query device failed\n",\r\n__func__);\r\ngoto err_query_dev;\r\n}\r\ni2c_set_clientdata(client, rmi4_data);\r\nrmi4_data->input_dev->name = DRIVER_NAME;\r\nrmi4_data->input_dev->phys = "Synaptics_Clearpad";\r\nrmi4_data->input_dev->id.bustype = BUS_I2C;\r\nrmi4_data->input_dev->dev.parent = &client->dev;\r\ninput_set_drvdata(rmi4_data->input_dev, rmi4_data);\r\nset_bit(EV_SYN, rmi4_data->input_dev->evbit);\r\nset_bit(EV_KEY, rmi4_data->input_dev->evbit);\r\nset_bit(EV_ABS, rmi4_data->input_dev->evbit);\r\ninput_set_abs_params(rmi4_data->input_dev, ABS_MT_POSITION_X, 0,\r\nrmi4_data->sensor_max_x, 0, 0);\r\ninput_set_abs_params(rmi4_data->input_dev, ABS_MT_POSITION_Y, 0,\r\nrmi4_data->sensor_max_y, 0, 0);\r\ninput_set_abs_params(rmi4_data->input_dev, ABS_MT_TOUCH_MAJOR, 0,\r\nMAX_TOUCH_MAJOR, 0, 0);\r\ninput_mt_init_slots(rmi4_data->input_dev,\r\nrmi4_data->fingers_supported, 0);\r\nsynaptics_rmi4_i2c_block_read(rmi4_data,\r\nrmi4_data->fn01_data_base_addr + 1, intr_status,\r\nrmi4_data->number_of_interrupt_register);\r\nretval = request_threaded_irq(client->irq, NULL,\r\nsynaptics_rmi4_irq,\r\nplatformdata->irq_type,\r\nDRIVER_NAME, rmi4_data);\r\nif (retval) {\r\ndev_err(&client->dev, "%s:Unable to get attn irq %d\n",\r\n__func__, client->irq);\r\ngoto err_query_dev;\r\n}\r\nretval = input_register_device(rmi4_data->input_dev);\r\nif (retval) {\r\ndev_err(&client->dev, "%s:input register failed\n", __func__);\r\ngoto err_free_irq;\r\n}\r\nreturn retval;\r\nerr_free_irq:\r\nfree_irq(client->irq, rmi4_data);\r\nerr_query_dev:\r\nregulator_disable(rmi4_data->regulator);\r\nerr_regulator_enable:\r\nregulator_put(rmi4_data->regulator);\r\nerr_get_regulator:\r\ninput_free_device(rmi4_data->input_dev);\r\nrmi4_data->input_dev = NULL;\r\nerr_input:\r\nkfree(rmi4_data);\r\nreturn retval;\r\n}\r\nstatic int synaptics_rmi4_remove(struct i2c_client *client)\r\n{\r\nstruct synaptics_rmi4_data *rmi4_data = i2c_get_clientdata(client);\r\nrmi4_data->touch_stopped = true;\r\nwake_up(&rmi4_data->wait);\r\nfree_irq(client->irq, rmi4_data);\r\ninput_unregister_device(rmi4_data->input_dev);\r\nregulator_disable(rmi4_data->regulator);\r\nregulator_put(rmi4_data->regulator);\r\nkfree(rmi4_data);\r\nreturn 0;\r\n}\r\nstatic int synaptics_rmi4_suspend(struct device *dev)\r\n{\r\nint retval;\r\nunsigned char intr_status;\r\nstruct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);\r\nrmi4_data->touch_stopped = true;\r\ndisable_irq(rmi4_data->i2c_client->irq);\r\nretval = synaptics_rmi4_i2c_block_read(rmi4_data,\r\nrmi4_data->fn01_data_base_addr + 1,\r\n&intr_status,\r\nrmi4_data->number_of_interrupt_register);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = synaptics_rmi4_i2c_byte_write(rmi4_data,\r\nrmi4_data->fn01_ctrl_base_addr + 1,\r\n(intr_status & ~TOUCHPAD_CTRL_INTR));\r\nif (retval < 0)\r\nreturn retval;\r\nregulator_disable(rmi4_data->regulator);\r\nreturn 0;\r\n}\r\nstatic int synaptics_rmi4_resume(struct device *dev)\r\n{\r\nint retval;\r\nunsigned char intr_status;\r\nstruct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);\r\nretval = regulator_enable(rmi4_data->regulator);\r\nif (retval) {\r\ndev_err(dev, "Regulator enable failed (%d)\n", retval);\r\nreturn retval;\r\n}\r\nenable_irq(rmi4_data->i2c_client->irq);\r\nrmi4_data->touch_stopped = false;\r\nretval = synaptics_rmi4_i2c_block_read(rmi4_data,\r\nrmi4_data->fn01_data_base_addr + 1,\r\n&intr_status,\r\nrmi4_data->number_of_interrupt_register);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = synaptics_rmi4_i2c_byte_write(rmi4_data,\r\nrmi4_data->fn01_ctrl_base_addr + 1,\r\n(intr_status | TOUCHPAD_CTRL_INTR));\r\nif (retval < 0)\r\nreturn retval;\r\nreturn 0;\r\n}
