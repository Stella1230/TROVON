static int pca954x_reg_write(struct i2c_adapter *adap,\r\nstruct i2c_client *client, u8 val)\r\n{\r\nint ret = -ENODEV;\r\nif (adap->algo->master_xfer) {\r\nstruct i2c_msg msg;\r\nchar buf[1];\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 1;\r\nbuf[0] = val;\r\nmsg.buf = buf;\r\nret = adap->algo->master_xfer(adap, &msg, 1);\r\n} else {\r\nunion i2c_smbus_data data;\r\nret = adap->algo->smbus_xfer(adap, client->addr,\r\nclient->flags,\r\nI2C_SMBUS_WRITE,\r\nval, I2C_SMBUS_BYTE, &data);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pca954x_select_chan(struct i2c_adapter *adap,\r\nvoid *client, u32 chan)\r\n{\r\nstruct pca954x *data = i2c_get_clientdata(client);\r\nconst struct chip_desc *chip = &chips[data->type];\r\nu8 regval;\r\nint ret = 0;\r\nif (chip->muxtype == pca954x_ismux)\r\nregval = chan | chip->enable;\r\nelse\r\nregval = 1 << chan;\r\nif (data->last_chan != regval) {\r\nret = pca954x_reg_write(adap, client, regval);\r\ndata->last_chan = regval;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pca954x_deselect_mux(struct i2c_adapter *adap,\r\nvoid *client, u32 chan)\r\n{\r\nstruct pca954x *data = i2c_get_clientdata(client);\r\ndata->last_chan = 0;\r\nreturn pca954x_reg_write(adap, client, data->last_chan);\r\n}\r\nstatic int pca954x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);\r\nstruct pca954x_platform_data *pdata = client->dev.platform_data;\r\nint num, force, class;\r\nstruct pca954x *data;\r\nint ret = -ENODEV;\r\nif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE))\r\ngoto err;\r\ndata = kzalloc(sizeof(struct pca954x), GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ni2c_set_clientdata(client, data);\r\nif (i2c_smbus_write_byte(client, 0) < 0) {\r\ndev_warn(&client->dev, "probe failed\n");\r\ngoto exit_free;\r\n}\r\ndata->type = id->driver_data;\r\ndata->last_chan = 0;\r\nfor (num = 0; num < chips[data->type].nchans; num++) {\r\nforce = 0;\r\nclass = 0;\r\nif (pdata) {\r\nif (num < pdata->num_modes) {\r\nforce = pdata->modes[num].adap_id;\r\nclass = pdata->modes[num].class;\r\n} else\r\nbreak;\r\n}\r\ndata->virt_adaps[num] =\r\ni2c_add_mux_adapter(adap, &client->dev, client,\r\nforce, num, class, pca954x_select_chan,\r\n(pdata && pdata->modes[num].deselect_on_exit)\r\n? pca954x_deselect_mux : NULL);\r\nif (data->virt_adaps[num] == NULL) {\r\nret = -ENODEV;\r\ndev_err(&client->dev,\r\n"failed to register multiplexed adapter"\r\n" %d as bus %d\n", num, force);\r\ngoto virt_reg_failed;\r\n}\r\n}\r\ndev_info(&client->dev,\r\n"registered %d multiplexed busses for I2C %s %s\n",\r\nnum, chips[data->type].muxtype == pca954x_ismux\r\n? "mux" : "switch", client->name);\r\nreturn 0;\r\nvirt_reg_failed:\r\nfor (num--; num >= 0; num--)\r\ni2c_del_mux_adapter(data->virt_adaps[num]);\r\nexit_free:\r\nkfree(data);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int pca954x_remove(struct i2c_client *client)\r\n{\r\nstruct pca954x *data = i2c_get_clientdata(client);\r\nconst struct chip_desc *chip = &chips[data->type];\r\nint i;\r\nfor (i = 0; i < chip->nchans; ++i)\r\nif (data->virt_adaps[i]) {\r\ni2c_del_mux_adapter(data->virt_adaps[i]);\r\ndata->virt_adaps[i] = NULL;\r\n}\r\nkfree(data);\r\nreturn 0;\r\n}
