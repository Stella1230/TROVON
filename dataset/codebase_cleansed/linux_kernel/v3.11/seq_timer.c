static void snd_seq_timer_set_tick_resolution(struct snd_seq_timer *tmr)\r\n{\r\nif (tmr->tempo < 1000000)\r\ntmr->tick.resolution = (tmr->tempo * 1000) / tmr->ppq;\r\nelse {\r\nunsigned int s;\r\ns = tmr->tempo % tmr->ppq;\r\ns = (s * 1000) / tmr->ppq;\r\ntmr->tick.resolution = (tmr->tempo / tmr->ppq) * 1000;\r\ntmr->tick.resolution += s;\r\n}\r\nif (tmr->tick.resolution <= 0)\r\ntmr->tick.resolution = 1;\r\nsnd_seq_timer_update_tick(&tmr->tick, 0);\r\n}\r\nstruct snd_seq_timer *snd_seq_timer_new(void)\r\n{\r\nstruct snd_seq_timer *tmr;\r\ntmr = kzalloc(sizeof(*tmr), GFP_KERNEL);\r\nif (tmr == NULL) {\r\nsnd_printd("malloc failed for snd_seq_timer_new() \n");\r\nreturn NULL;\r\n}\r\nspin_lock_init(&tmr->lock);\r\nsnd_seq_timer_defaults(tmr);\r\nsnd_seq_timer_reset(tmr);\r\nreturn tmr;\r\n}\r\nvoid snd_seq_timer_delete(struct snd_seq_timer **tmr)\r\n{\r\nstruct snd_seq_timer *t = *tmr;\r\n*tmr = NULL;\r\nif (t == NULL) {\r\nsnd_printd("oops: snd_seq_timer_delete() called with NULL timer\n");\r\nreturn;\r\n}\r\nt->running = 0;\r\nsnd_seq_timer_stop(t);\r\nsnd_seq_timer_reset(t);\r\nkfree(t);\r\n}\r\nvoid snd_seq_timer_defaults(struct snd_seq_timer * tmr)\r\n{\r\ntmr->ppq = 96;\r\ntmr->tempo = 500000;\r\nsnd_seq_timer_set_tick_resolution(tmr);\r\ntmr->running = 0;\r\ntmr->type = SNDRV_SEQ_TIMER_ALSA;\r\ntmr->alsa_id.dev_class = seq_default_timer_class;\r\ntmr->alsa_id.dev_sclass = seq_default_timer_sclass;\r\ntmr->alsa_id.card = seq_default_timer_card;\r\ntmr->alsa_id.device = seq_default_timer_device;\r\ntmr->alsa_id.subdevice = seq_default_timer_subdevice;\r\ntmr->preferred_resolution = seq_default_timer_resolution;\r\ntmr->skew = tmr->skew_base = SKEW_BASE;\r\n}\r\nvoid snd_seq_timer_reset(struct snd_seq_timer * tmr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tmr->lock, flags);\r\ntmr->cur_time.tv_sec = 0;\r\ntmr->cur_time.tv_nsec = 0;\r\ntmr->tick.cur_tick = 0;\r\ntmr->tick.fraction = 0;\r\nspin_unlock_irqrestore(&tmr->lock, flags);\r\n}\r\nstatic void snd_seq_timer_interrupt(struct snd_timer_instance *timeri,\r\nunsigned long resolution,\r\nunsigned long ticks)\r\n{\r\nunsigned long flags;\r\nstruct snd_seq_queue *q = timeri->callback_data;\r\nstruct snd_seq_timer *tmr;\r\nif (q == NULL)\r\nreturn;\r\ntmr = q->timer;\r\nif (tmr == NULL)\r\nreturn;\r\nif (!tmr->running)\r\nreturn;\r\nresolution *= ticks;\r\nif (tmr->skew != tmr->skew_base) {\r\nresolution = (resolution >> 16) * tmr->skew +\r\n(((resolution & 0xffff) * tmr->skew) >> 16);\r\n}\r\nspin_lock_irqsave(&tmr->lock, flags);\r\nsnd_seq_inc_time_nsec(&tmr->cur_time, resolution);\r\nsnd_seq_timer_update_tick(&tmr->tick, resolution);\r\ndo_gettimeofday(&tmr->last_update);\r\nspin_unlock_irqrestore(&tmr->lock, flags);\r\nsnd_seq_check_queue(q, 1, 0);\r\n}\r\nint snd_seq_timer_set_tempo(struct snd_seq_timer * tmr, int tempo)\r\n{\r\nunsigned long flags;\r\nif (snd_BUG_ON(!tmr))\r\nreturn -EINVAL;\r\nif (tempo <= 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&tmr->lock, flags);\r\nif ((unsigned int)tempo != tmr->tempo) {\r\ntmr->tempo = tempo;\r\nsnd_seq_timer_set_tick_resolution(tmr);\r\n}\r\nspin_unlock_irqrestore(&tmr->lock, flags);\r\nreturn 0;\r\n}\r\nint snd_seq_timer_set_ppq(struct snd_seq_timer * tmr, int ppq)\r\n{\r\nunsigned long flags;\r\nif (snd_BUG_ON(!tmr))\r\nreturn -EINVAL;\r\nif (ppq <= 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&tmr->lock, flags);\r\nif (tmr->running && (ppq != tmr->ppq)) {\r\nspin_unlock_irqrestore(&tmr->lock, flags);\r\nsnd_printd("seq: cannot change ppq of a running timer\n");\r\nreturn -EBUSY;\r\n}\r\ntmr->ppq = ppq;\r\nsnd_seq_timer_set_tick_resolution(tmr);\r\nspin_unlock_irqrestore(&tmr->lock, flags);\r\nreturn 0;\r\n}\r\nint snd_seq_timer_set_position_tick(struct snd_seq_timer *tmr,\r\nsnd_seq_tick_time_t position)\r\n{\r\nunsigned long flags;\r\nif (snd_BUG_ON(!tmr))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&tmr->lock, flags);\r\ntmr->tick.cur_tick = position;\r\ntmr->tick.fraction = 0;\r\nspin_unlock_irqrestore(&tmr->lock, flags);\r\nreturn 0;\r\n}\r\nint snd_seq_timer_set_position_time(struct snd_seq_timer *tmr,\r\nsnd_seq_real_time_t position)\r\n{\r\nunsigned long flags;\r\nif (snd_BUG_ON(!tmr))\r\nreturn -EINVAL;\r\nsnd_seq_sanity_real_time(&position);\r\nspin_lock_irqsave(&tmr->lock, flags);\r\ntmr->cur_time = position;\r\nspin_unlock_irqrestore(&tmr->lock, flags);\r\nreturn 0;\r\n}\r\nint snd_seq_timer_set_skew(struct snd_seq_timer *tmr, unsigned int skew,\r\nunsigned int base)\r\n{\r\nunsigned long flags;\r\nif (snd_BUG_ON(!tmr))\r\nreturn -EINVAL;\r\nif (base != SKEW_BASE) {\r\nsnd_printd("invalid skew base 0x%x\n", base);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&tmr->lock, flags);\r\ntmr->skew = skew;\r\nspin_unlock_irqrestore(&tmr->lock, flags);\r\nreturn 0;\r\n}\r\nint snd_seq_timer_open(struct snd_seq_queue *q)\r\n{\r\nstruct snd_timer_instance *t;\r\nstruct snd_seq_timer *tmr;\r\nchar str[32];\r\nint err;\r\ntmr = q->timer;\r\nif (snd_BUG_ON(!tmr))\r\nreturn -EINVAL;\r\nif (tmr->timeri)\r\nreturn -EBUSY;\r\nsprintf(str, "sequencer queue %i", q->queue);\r\nif (tmr->type != SNDRV_SEQ_TIMER_ALSA)\r\nreturn -EINVAL;\r\nif (tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\r\ntmr->alsa_id.dev_sclass = SNDRV_TIMER_SCLASS_SEQUENCER;\r\nerr = snd_timer_open(&t, str, &tmr->alsa_id, q->queue);\r\nif (err < 0 && tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_SLAVE) {\r\nif (tmr->alsa_id.dev_class != SNDRV_TIMER_CLASS_GLOBAL ||\r\ntmr->alsa_id.device != SNDRV_TIMER_GLOBAL_SYSTEM) {\r\nstruct snd_timer_id tid;\r\nmemset(&tid, 0, sizeof(tid));\r\ntid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\r\ntid.dev_sclass = SNDRV_TIMER_SCLASS_SEQUENCER;\r\ntid.card = -1;\r\ntid.device = SNDRV_TIMER_GLOBAL_SYSTEM;\r\nerr = snd_timer_open(&t, str, &tid, q->queue);\r\n}\r\n}\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "seq fatal error: cannot create timer (%i)\n", err);\r\nreturn err;\r\n}\r\nt->callback = snd_seq_timer_interrupt;\r\nt->callback_data = q;\r\nt->flags |= SNDRV_TIMER_IFLG_AUTO;\r\ntmr->timeri = t;\r\nreturn 0;\r\n}\r\nint snd_seq_timer_close(struct snd_seq_queue *q)\r\n{\r\nstruct snd_seq_timer *tmr;\r\ntmr = q->timer;\r\nif (snd_BUG_ON(!tmr))\r\nreturn -EINVAL;\r\nif (tmr->timeri) {\r\nsnd_timer_stop(tmr->timeri);\r\nsnd_timer_close(tmr->timeri);\r\ntmr->timeri = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint snd_seq_timer_stop(struct snd_seq_timer * tmr)\r\n{\r\nif (! tmr->timeri)\r\nreturn -EINVAL;\r\nif (!tmr->running)\r\nreturn 0;\r\ntmr->running = 0;\r\nsnd_timer_pause(tmr->timeri);\r\nreturn 0;\r\n}\r\nstatic int initialize_timer(struct snd_seq_timer *tmr)\r\n{\r\nstruct snd_timer *t;\r\nunsigned long freq;\r\nt = tmr->timeri->timer;\r\nif (snd_BUG_ON(!t))\r\nreturn -EINVAL;\r\nfreq = tmr->preferred_resolution;\r\nif (!freq)\r\nfreq = DEFAULT_FREQUENCY;\r\nelse if (freq < MIN_FREQUENCY)\r\nfreq = MIN_FREQUENCY;\r\nelse if (freq > MAX_FREQUENCY)\r\nfreq = MAX_FREQUENCY;\r\ntmr->ticks = 1;\r\nif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE)) {\r\nunsigned long r = t->hw.resolution;\r\nif (! r && t->hw.c_resolution)\r\nr = t->hw.c_resolution(t);\r\nif (r) {\r\ntmr->ticks = (unsigned int)(1000000000uL / (r * freq));\r\nif (! tmr->ticks)\r\ntmr->ticks = 1;\r\n}\r\n}\r\ntmr->initialized = 1;\r\nreturn 0;\r\n}\r\nint snd_seq_timer_start(struct snd_seq_timer * tmr)\r\n{\r\nif (! tmr->timeri)\r\nreturn -EINVAL;\r\nif (tmr->running)\r\nsnd_seq_timer_stop(tmr);\r\nsnd_seq_timer_reset(tmr);\r\nif (initialize_timer(tmr) < 0)\r\nreturn -EINVAL;\r\nsnd_timer_start(tmr->timeri, tmr->ticks);\r\ntmr->running = 1;\r\ndo_gettimeofday(&tmr->last_update);\r\nreturn 0;\r\n}\r\nint snd_seq_timer_continue(struct snd_seq_timer * tmr)\r\n{\r\nif (! tmr->timeri)\r\nreturn -EINVAL;\r\nif (tmr->running)\r\nreturn -EBUSY;\r\nif (! tmr->initialized) {\r\nsnd_seq_timer_reset(tmr);\r\nif (initialize_timer(tmr) < 0)\r\nreturn -EINVAL;\r\n}\r\nsnd_timer_start(tmr->timeri, tmr->ticks);\r\ntmr->running = 1;\r\ndo_gettimeofday(&tmr->last_update);\r\nreturn 0;\r\n}\r\nsnd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr)\r\n{\r\nsnd_seq_real_time_t cur_time;\r\ncur_time = tmr->cur_time;\r\nif (tmr->running) {\r\nstruct timeval tm;\r\nint usec;\r\ndo_gettimeofday(&tm);\r\nusec = (int)(tm.tv_usec - tmr->last_update.tv_usec);\r\nif (usec < 0) {\r\ncur_time.tv_nsec += (1000000 + usec) * 1000;\r\ncur_time.tv_sec += tm.tv_sec - tmr->last_update.tv_sec - 1;\r\n} else {\r\ncur_time.tv_nsec += usec * 1000;\r\ncur_time.tv_sec += tm.tv_sec - tmr->last_update.tv_sec;\r\n}\r\nsnd_seq_sanity_real_time(&cur_time);\r\n}\r\nreturn cur_time;\r\n}\r\nsnd_seq_tick_time_t snd_seq_timer_get_cur_tick(struct snd_seq_timer *tmr)\r\n{\r\nreturn tmr->tick.cur_tick;\r\n}\r\nvoid snd_seq_info_timer_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nint idx;\r\nstruct snd_seq_queue *q;\r\nstruct snd_seq_timer *tmr;\r\nstruct snd_timer_instance *ti;\r\nunsigned long resolution;\r\nfor (idx = 0; idx < SNDRV_SEQ_MAX_QUEUES; idx++) {\r\nq = queueptr(idx);\r\nif (q == NULL)\r\ncontinue;\r\nif ((tmr = q->timer) == NULL ||\r\n(ti = tmr->timeri) == NULL) {\r\nqueuefree(q);\r\ncontinue;\r\n}\r\nsnd_iprintf(buffer, "Timer for queue %i : %s\n", q->queue, ti->timer->name);\r\nresolution = snd_timer_resolution(ti) * tmr->ticks;\r\nsnd_iprintf(buffer, " Period time : %lu.%09lu\n", resolution / 1000000000, resolution % 1000000000);\r\nsnd_iprintf(buffer, " Skew : %u / %u\n", tmr->skew, tmr->skew_base);\r\nqueuefree(q);\r\n}\r\n}
