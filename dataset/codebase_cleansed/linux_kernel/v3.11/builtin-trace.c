static int syscall_fmt__cmp(const void *name, const void *fmtp)\r\n{\r\nconst struct syscall_fmt *fmt = fmtp;\r\nreturn strcmp(name, fmt->name);\r\n}\r\nstatic struct syscall_fmt *syscall_fmt__find(const char *name)\r\n{\r\nconst int nmemb = ARRAY_SIZE(syscall_fmts);\r\nreturn bsearch(name, syscall_fmts, nmemb, sizeof(struct syscall_fmt), syscall_fmt__cmp);\r\n}\r\nstatic size_t fprintf_duration(unsigned long t, FILE *fp)\r\n{\r\ndouble duration = (double)t / NSEC_PER_MSEC;\r\nsize_t printed = fprintf(fp, "(");\r\nif (duration >= 1.0)\r\nprinted += color_fprintf(fp, PERF_COLOR_RED, "%6.3f ms", duration);\r\nelse if (duration >= 0.01)\r\nprinted += color_fprintf(fp, PERF_COLOR_YELLOW, "%6.3f ms", duration);\r\nelse\r\nprinted += color_fprintf(fp, PERF_COLOR_NORMAL, "%6.3f ms", duration);\r\nreturn printed + fprintf(stdout, "): ");\r\n}\r\nstatic struct thread_trace *thread_trace__new(void)\r\n{\r\nreturn zalloc(sizeof(struct thread_trace));\r\n}\r\nstatic struct thread_trace *thread__trace(struct thread *thread)\r\n{\r\nstruct thread_trace *ttrace;\r\nif (thread == NULL)\r\ngoto fail;\r\nif (thread->priv == NULL)\r\nthread->priv = thread_trace__new();\r\nif (thread->priv == NULL)\r\ngoto fail;\r\nttrace = thread->priv;\r\n++ttrace->nr_events;\r\nreturn ttrace;\r\nfail:\r\ncolor_fprintf(stdout, PERF_COLOR_RED,\r\n"WARNING: not enough memory, dropping samples!\n");\r\nreturn NULL;\r\n}\r\nstatic bool trace__filter_duration(struct trace *trace, double t)\r\n{\r\nreturn t < (trace->duration_filter * NSEC_PER_MSEC);\r\n}\r\nstatic size_t trace__fprintf_tstamp(struct trace *trace, u64 tstamp, FILE *fp)\r\n{\r\ndouble ts = (double)(tstamp - trace->base_time) / NSEC_PER_MSEC;\r\nreturn fprintf(fp, "%10.3f ", ts);\r\n}\r\nstatic void sig_handler(int sig __maybe_unused)\r\n{\r\ndone = true;\r\n}\r\nstatic size_t trace__fprintf_entry_head(struct trace *trace, struct thread *thread,\r\nu64 duration, u64 tstamp, FILE *fp)\r\n{\r\nsize_t printed = trace__fprintf_tstamp(trace, tstamp, fp);\r\nprinted += fprintf_duration(duration, fp);\r\nif (trace->multiple_threads)\r\nprinted += fprintf(fp, "%d ", thread->pid);\r\nreturn printed;\r\n}\r\nstatic int trace__process_event(struct machine *machine, union perf_event *event)\r\n{\r\nint ret = 0;\r\nswitch (event->header.type) {\r\ncase PERF_RECORD_LOST:\r\ncolor_fprintf(stdout, PERF_COLOR_RED,\r\n"LOST %" PRIu64 " events!\n", event->lost.lost);\r\nret = machine__process_lost_event(machine, event);\r\ndefault:\r\nret = machine__process_event(machine, event);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int trace__tool_process(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nreturn trace__process_event(machine, event);\r\n}\r\nstatic int trace__symbols_init(struct trace *trace, struct perf_evlist *evlist)\r\n{\r\nint err = symbol__init();\r\nif (err)\r\nreturn err;\r\nmachine__init(&trace->host, "", HOST_KERNEL_ID);\r\nmachine__create_kernel_maps(&trace->host);\r\nif (perf_target__has_task(&trace->opts.target)) {\r\nerr = perf_event__synthesize_thread_map(NULL, evlist->threads,\r\ntrace__tool_process,\r\n&trace->host);\r\n} else {\r\nerr = perf_event__synthesize_threads(NULL, trace__tool_process,\r\n&trace->host);\r\n}\r\nif (err)\r\nsymbol__exit();\r\nreturn err;\r\n}\r\nstatic int trace__read_syscall_info(struct trace *trace, int id)\r\n{\r\nchar tp_name[128];\r\nstruct syscall *sc;\r\nconst char *name = audit_syscall_to_name(id, trace->audit_machine);\r\nif (name == NULL)\r\nreturn -1;\r\nif (id > trace->syscalls.max) {\r\nstruct syscall *nsyscalls = realloc(trace->syscalls.table, (id + 1) * sizeof(*sc));\r\nif (nsyscalls == NULL)\r\nreturn -1;\r\nif (trace->syscalls.max != -1) {\r\nmemset(nsyscalls + trace->syscalls.max + 1, 0,\r\n(id - trace->syscalls.max) * sizeof(*sc));\r\n} else {\r\nmemset(nsyscalls, 0, (id + 1) * sizeof(*sc));\r\n}\r\ntrace->syscalls.table = nsyscalls;\r\ntrace->syscalls.max = id;\r\n}\r\nsc = trace->syscalls.table + id;\r\nsc->name = name;\r\nsc->fmt = syscall_fmt__find(sc->name);\r\nsnprintf(tp_name, sizeof(tp_name), "sys_enter_%s", sc->name);\r\nsc->tp_format = event_format__new("syscalls", tp_name);\r\nif (sc->tp_format == NULL && sc->fmt && sc->fmt->alias) {\r\nsnprintf(tp_name, sizeof(tp_name), "sys_enter_%s", sc->fmt->alias);\r\nsc->tp_format = event_format__new("syscalls", tp_name);\r\n}\r\nreturn sc->tp_format != NULL ? 0 : -1;\r\n}\r\nstatic size_t syscall__scnprintf_args(struct syscall *sc, char *bf, size_t size,\r\nunsigned long *args)\r\n{\r\nint i = 0;\r\nsize_t printed = 0;\r\nif (sc->tp_format != NULL) {\r\nstruct format_field *field;\r\nfor (field = sc->tp_format->format.fields->next; field; field = field->next) {\r\nprinted += scnprintf(bf + printed, size - printed,\r\n"%s%s: %ld", printed ? ", " : "",\r\nfield->name, args[i++]);\r\n}\r\n} else {\r\nwhile (i < 6) {\r\nprinted += scnprintf(bf + printed, size - printed,\r\n"%sarg%d: %ld",\r\nprinted ? ", " : "", i, args[i]);\r\n++i;\r\n}\r\n}\r\nreturn printed;\r\n}\r\nstatic struct syscall *trace__syscall_info(struct trace *trace,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nint id = perf_evsel__intval(evsel, sample, "id");\r\nif (id < 0) {\r\nprintf("Invalid syscall %d id, skipping...\n", id);\r\nreturn NULL;\r\n}\r\nif ((id > trace->syscalls.max || trace->syscalls.table[id].name == NULL) &&\r\ntrace__read_syscall_info(trace, id))\r\ngoto out_cant_read;\r\nif ((id > trace->syscalls.max || trace->syscalls.table[id].name == NULL))\r\ngoto out_cant_read;\r\nreturn &trace->syscalls.table[id];\r\nout_cant_read:\r\nprintf("Problems reading syscall %d", id);\r\nif (id <= trace->syscalls.max && trace->syscalls.table[id].name != NULL)\r\nprintf("(%s)", trace->syscalls.table[id].name);\r\nputs(" information");\r\nreturn NULL;\r\n}\r\nstatic int trace__sys_enter(struct trace *trace, struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nchar *msg;\r\nvoid *args;\r\nsize_t printed = 0;\r\nstruct thread *thread = machine__findnew_thread(&trace->host, sample->tid);\r\nstruct syscall *sc = trace__syscall_info(trace, evsel, sample);\r\nstruct thread_trace *ttrace = thread__trace(thread);\r\nif (ttrace == NULL || sc == NULL)\r\nreturn -1;\r\nargs = perf_evsel__rawptr(evsel, sample, "args");\r\nif (args == NULL) {\r\nprintf("Problems reading syscall arguments\n");\r\nreturn -1;\r\n}\r\nttrace = thread->priv;\r\nif (ttrace->entry_str == NULL) {\r\nttrace->entry_str = malloc(1024);\r\nif (!ttrace->entry_str)\r\nreturn -1;\r\n}\r\nttrace->entry_time = sample->time;\r\nmsg = ttrace->entry_str;\r\nprinted += scnprintf(msg + printed, 1024 - printed, "%s(", sc->name);\r\nprinted += syscall__scnprintf_args(sc, msg + printed, 1024 - printed, args);\r\nif (!strcmp(sc->name, "exit_group") || !strcmp(sc->name, "exit")) {\r\nif (!trace->duration_filter) {\r\ntrace__fprintf_entry_head(trace, thread, 1, sample->time, stdout);\r\nprintf("%-70s\n", ttrace->entry_str);\r\n}\r\n} else\r\nttrace->entry_pending = true;\r\nreturn 0;\r\n}\r\nstatic int trace__sys_exit(struct trace *trace, struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nint ret;\r\nu64 duration = 0;\r\nstruct thread *thread = machine__findnew_thread(&trace->host, sample->tid);\r\nstruct thread_trace *ttrace = thread__trace(thread);\r\nstruct syscall *sc = trace__syscall_info(trace, evsel, sample);\r\nif (ttrace == NULL || sc == NULL)\r\nreturn -1;\r\nret = perf_evsel__intval(evsel, sample, "ret");\r\nttrace = thread->priv;\r\nttrace->exit_time = sample->time;\r\nif (ttrace->entry_time) {\r\nduration = sample->time - ttrace->entry_time;\r\nif (trace__filter_duration(trace, duration))\r\ngoto out;\r\n} else if (trace->duration_filter)\r\ngoto out;\r\ntrace__fprintf_entry_head(trace, thread, duration, sample->time, stdout);\r\nif (ttrace->entry_pending) {\r\nprintf("%-70s", ttrace->entry_str);\r\n} else {\r\nprintf(" ... [");\r\ncolor_fprintf(stdout, PERF_COLOR_YELLOW, "continued");\r\nprintf("]: %s()", sc->name);\r\n}\r\nif (ret < 0 && sc->fmt && sc->fmt->errmsg) {\r\nchar bf[256];\r\nconst char *emsg = strerror_r(-ret, bf, sizeof(bf)),\r\n*e = audit_errno_to_name(-ret);\r\nprintf(") = -1 %s %s", e, emsg);\r\n} else if (ret == 0 && sc->fmt && sc->fmt->timeout)\r\nprintf(") = 0 Timeout");\r\nelse\r\nprintf(") = %d", ret);\r\nputchar('\n');\r\nout:\r\nttrace->entry_pending = false;\r\nreturn 0;\r\n}\r\nstatic int trace__sched_stat_runtime(struct trace *trace, struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nu64 runtime = perf_evsel__intval(evsel, sample, "runtime");\r\ndouble runtime_ms = (double)runtime / NSEC_PER_MSEC;\r\nstruct thread *thread = machine__findnew_thread(&trace->host, sample->tid);\r\nstruct thread_trace *ttrace = thread__trace(thread);\r\nif (ttrace == NULL)\r\ngoto out_dump;\r\nttrace->runtime_ms += runtime_ms;\r\ntrace->runtime_ms += runtime_ms;\r\nreturn 0;\r\nout_dump:\r\nprintf("%s: comm=%s,pid=%u,runtime=%" PRIu64 ",vruntime=%" PRIu64 ")\n",\r\nevsel->name,\r\nperf_evsel__strval(evsel, sample, "comm"),\r\n(pid_t)perf_evsel__intval(evsel, sample, "pid"),\r\nruntime,\r\nperf_evsel__intval(evsel, sample, "vruntime"));\r\nreturn 0;\r\n}\r\nstatic int trace__run(struct trace *trace, int argc, const char **argv)\r\n{\r\nstruct perf_evlist *evlist = perf_evlist__new();\r\nstruct perf_evsel *evsel;\r\nint err = -1, i;\r\nunsigned long before;\r\nconst bool forks = argc > 0;\r\nif (evlist == NULL) {\r\nprintf("Not enough memory to run!\n");\r\ngoto out;\r\n}\r\nif (perf_evlist__add_newtp(evlist, "raw_syscalls", "sys_enter", trace__sys_enter) ||\r\nperf_evlist__add_newtp(evlist, "raw_syscalls", "sys_exit", trace__sys_exit)) {\r\nprintf("Couldn't read the raw_syscalls tracepoints information!\n");\r\ngoto out_delete_evlist;\r\n}\r\nif (trace->sched &&\r\nperf_evlist__add_newtp(evlist, "sched", "sched_stat_runtime",\r\ntrace__sched_stat_runtime)) {\r\nprintf("Couldn't read the sched_stat_runtime tracepoint information!\n");\r\ngoto out_delete_evlist;\r\n}\r\nerr = perf_evlist__create_maps(evlist, &trace->opts.target);\r\nif (err < 0) {\r\nprintf("Problems parsing the target to trace, check your options!\n");\r\ngoto out_delete_evlist;\r\n}\r\nerr = trace__symbols_init(trace, evlist);\r\nif (err < 0) {\r\nprintf("Problems initializing symbol libraries!\n");\r\ngoto out_delete_maps;\r\n}\r\nperf_evlist__config(evlist, &trace->opts);\r\nsignal(SIGCHLD, sig_handler);\r\nsignal(SIGINT, sig_handler);\r\nif (forks) {\r\nerr = perf_evlist__prepare_workload(evlist, &trace->opts.target,\r\nargv, false, false);\r\nif (err < 0) {\r\nprintf("Couldn't run the workload!\n");\r\ngoto out_delete_maps;\r\n}\r\n}\r\nerr = perf_evlist__open(evlist);\r\nif (err < 0) {\r\nprintf("Couldn't create the events: %s\n", strerror(errno));\r\ngoto out_delete_maps;\r\n}\r\nerr = perf_evlist__mmap(evlist, UINT_MAX, false);\r\nif (err < 0) {\r\nprintf("Couldn't mmap the events: %s\n", strerror(errno));\r\ngoto out_close_evlist;\r\n}\r\nperf_evlist__enable(evlist);\r\nif (forks)\r\nperf_evlist__start_workload(evlist);\r\ntrace->multiple_threads = evlist->threads->map[0] == -1 || evlist->threads->nr > 1;\r\nagain:\r\nbefore = trace->nr_events;\r\nfor (i = 0; i < evlist->nr_mmaps; i++) {\r\nunion perf_event *event;\r\nwhile ((event = perf_evlist__mmap_read(evlist, i)) != NULL) {\r\nconst u32 type = event->header.type;\r\ntracepoint_handler handler;\r\nstruct perf_sample sample;\r\n++trace->nr_events;\r\nerr = perf_evlist__parse_sample(evlist, event, &sample);\r\nif (err) {\r\nprintf("Can't parse sample, err = %d, skipping...\n", err);\r\ncontinue;\r\n}\r\nif (trace->base_time == 0)\r\ntrace->base_time = sample.time;\r\nif (type != PERF_RECORD_SAMPLE) {\r\ntrace__process_event(&trace->host, event);\r\ncontinue;\r\n}\r\nevsel = perf_evlist__id2evsel(evlist, sample.id);\r\nif (evsel == NULL) {\r\nprintf("Unknown tp ID %" PRIu64 ", skipping...\n", sample.id);\r\ncontinue;\r\n}\r\nif (sample.raw_data == NULL) {\r\nprintf("%s sample with no payload for tid: %d, cpu %d, raw_size=%d, skipping...\n",\r\nperf_evsel__name(evsel), sample.tid,\r\nsample.cpu, sample.raw_size);\r\ncontinue;\r\n}\r\nhandler = evsel->handler.func;\r\nhandler(trace, evsel, &sample);\r\n}\r\n}\r\nif (trace->nr_events == before) {\r\nif (done)\r\ngoto out_unmap_evlist;\r\npoll(evlist->pollfd, evlist->nr_fds, -1);\r\n}\r\nif (done)\r\nperf_evlist__disable(evlist);\r\ngoto again;\r\nout_unmap_evlist:\r\nperf_evlist__munmap(evlist);\r\nout_close_evlist:\r\nperf_evlist__close(evlist);\r\nout_delete_maps:\r\nperf_evlist__delete_maps(evlist);\r\nout_delete_evlist:\r\nperf_evlist__delete(evlist);\r\nout:\r\nreturn err;\r\n}\r\nstatic size_t trace__fprintf_threads_header(FILE *fp)\r\n{\r\nsize_t printed;\r\nprinted = fprintf(fp, "\n _____________________________________________________________________\n");\r\nprinted += fprintf(fp," __) Summary of events (__\n\n");\r\nprinted += fprintf(fp," [ task - pid ] [ events ] [ ratio ] [ runtime ]\n");\r\nprinted += fprintf(fp," _____________________________________________________________________\n\n");\r\nreturn printed;\r\n}\r\nstatic size_t trace__fprintf_thread_summary(struct trace *trace, FILE *fp)\r\n{\r\nsize_t printed = trace__fprintf_threads_header(fp);\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&trace->host.threads); nd; nd = rb_next(nd)) {\r\nstruct thread *thread = rb_entry(nd, struct thread, rb_node);\r\nstruct thread_trace *ttrace = thread->priv;\r\nconst char *color;\r\ndouble ratio;\r\nif (ttrace == NULL)\r\ncontinue;\r\nratio = (double)ttrace->nr_events / trace->nr_events * 100.0;\r\ncolor = PERF_COLOR_NORMAL;\r\nif (ratio > 50.0)\r\ncolor = PERF_COLOR_RED;\r\nelse if (ratio > 25.0)\r\ncolor = PERF_COLOR_GREEN;\r\nelse if (ratio > 5.0)\r\ncolor = PERF_COLOR_YELLOW;\r\nprinted += color_fprintf(fp, color, "%20s", thread->comm);\r\nprinted += fprintf(fp, " - %-5d :%11lu [", thread->pid, ttrace->nr_events);\r\nprinted += color_fprintf(fp, color, "%5.1f%%", ratio);\r\nprinted += fprintf(fp, " ] %10.3f ms\n", ttrace->runtime_ms);\r\n}\r\nreturn printed;\r\n}\r\nstatic int trace__set_duration(const struct option *opt, const char *str,\r\nint unset __maybe_unused)\r\n{\r\nstruct trace *trace = opt->value;\r\ntrace->duration_filter = atof(str);\r\nreturn 0;\r\n}\r\nint cmd_trace(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nconst char * const trace_usage[] = {\r\n"perf trace [<options>] [<command>]",\r\n"perf trace [<options>] -- <command> [<options>]",\r\nNULL\r\n};\r\nstruct trace trace = {\r\n.audit_machine = audit_detect_machine(),\r\n.syscalls = {\r\n. max = -1,\r\n},\r\n.opts = {\r\n.target = {\r\n.uid = UINT_MAX,\r\n.uses_mmap = true,\r\n},\r\n.user_freq = UINT_MAX,\r\n.user_interval = ULLONG_MAX,\r\n.no_delay = true,\r\n.mmap_pages = 1024,\r\n},\r\n};\r\nconst struct option trace_options[] = {\r\nOPT_STRING('p', "pid", &trace.opts.target.pid, "pid",\r\n"trace events on existing process id"),\r\nOPT_STRING(0, "tid", &trace.opts.target.tid, "tid",\r\n"trace events on existing thread id"),\r\nOPT_BOOLEAN(0, "all-cpus", &trace.opts.target.system_wide,\r\n"system-wide collection from all CPUs"),\r\nOPT_STRING(0, "cpu", &trace.opts.target.cpu_list, "cpu",\r\n"list of cpus to monitor"),\r\nOPT_BOOLEAN(0, "no-inherit", &trace.opts.no_inherit,\r\n"child tasks do not inherit counters"),\r\nOPT_UINTEGER(0, "mmap-pages", &trace.opts.mmap_pages,\r\n"number of mmap data pages"),\r\nOPT_STRING(0, "uid", &trace.opts.target.uid_str, "user",\r\n"user to profile"),\r\nOPT_CALLBACK(0, "duration", &trace, "float",\r\n"show only events with duration > N.M ms",\r\ntrace__set_duration),\r\nOPT_BOOLEAN(0, "sched", &trace.sched, "show blocking scheduler events"),\r\nOPT_END()\r\n};\r\nint err;\r\nchar bf[BUFSIZ];\r\nargc = parse_options(argc, argv, trace_options, trace_usage, 0);\r\nerr = perf_target__validate(&trace.opts.target);\r\nif (err) {\r\nperf_target__strerror(&trace.opts.target, err, bf, sizeof(bf));\r\nprintf("%s", bf);\r\nreturn err;\r\n}\r\nerr = perf_target__parse_uid(&trace.opts.target);\r\nif (err) {\r\nperf_target__strerror(&trace.opts.target, err, bf, sizeof(bf));\r\nprintf("%s", bf);\r\nreturn err;\r\n}\r\nif (!argc && perf_target__none(&trace.opts.target))\r\ntrace.opts.target.system_wide = true;\r\nerr = trace__run(&trace, argc, argv);\r\nif (trace.sched && !err)\r\ntrace__fprintf_thread_summary(&trace, stdout);\r\nreturn err;\r\n}
