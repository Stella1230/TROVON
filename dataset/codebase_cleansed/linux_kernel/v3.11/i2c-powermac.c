static s32 i2c_powermac_smbus_xfer( struct i2c_adapter* adap,\r\nu16 addr,\r\nunsigned short flags,\r\nchar read_write,\r\nu8 command,\r\nint size,\r\nunion i2c_smbus_data* data)\r\n{\r\nstruct pmac_i2c_bus *bus = i2c_get_adapdata(adap);\r\nint rc = 0;\r\nint read = (read_write == I2C_SMBUS_READ);\r\nint addrdir = (addr << 1) | read;\r\nint mode, subsize, len;\r\nu32 subaddr;\r\nu8 *buf;\r\nu8 local[2];\r\nif (size == I2C_SMBUS_QUICK || size == I2C_SMBUS_BYTE) {\r\nmode = pmac_i2c_mode_std;\r\nsubsize = 0;\r\nsubaddr = 0;\r\n} else {\r\nmode = read ? pmac_i2c_mode_combined : pmac_i2c_mode_stdsub;\r\nsubsize = 1;\r\nsubaddr = command;\r\n}\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nbuf = NULL;\r\nlen = 0;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\nbuf = &data->byte;\r\nlen = 1;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nif (!read) {\r\nlocal[0] = data->word & 0xff;\r\nlocal[1] = (data->word >> 8) & 0xff;\r\n}\r\nbuf = local;\r\nlen = 2;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nbuf = data->block;\r\nlen = data->block[0] + 1;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nbuf = &data->block[1];\r\nlen = data->block[0];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrc = pmac_i2c_open(bus, 0);\r\nif (rc) {\r\ndev_err(&adap->dev, "Failed to open I2C, err %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = pmac_i2c_setmode(bus, mode);\r\nif (rc) {\r\ndev_err(&adap->dev, "Failed to set I2C mode %d, err %d\n",\r\nmode, rc);\r\ngoto bail;\r\n}\r\nrc = pmac_i2c_xfer(bus, addrdir, subsize, subaddr, buf, len);\r\nif (rc) {\r\nif (rc == -ENXIO)\r\ndev_dbg(&adap->dev,\r\n"I2C transfer at 0x%02x failed, size %d, "\r\n"err %d\n", addrdir >> 1, size, rc);\r\nelse\r\ndev_err(&adap->dev,\r\n"I2C transfer at 0x%02x failed, size %d, "\r\n"err %d\n", addrdir >> 1, size, rc);\r\ngoto bail;\r\n}\r\nif (size == I2C_SMBUS_WORD_DATA && read) {\r\ndata->word = ((u16)local[1]) << 8;\r\ndata->word |= local[0];\r\n}\r\nbail:\r\npmac_i2c_close(bus);\r\nreturn rc;\r\n}\r\nstatic int i2c_powermac_master_xfer( struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct pmac_i2c_bus *bus = i2c_get_adapdata(adap);\r\nint rc = 0;\r\nint read;\r\nint addrdir;\r\nif (num != 1) {\r\ndev_err(&adap->dev,\r\n"Multi-message I2C transactions not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (msgs->flags & I2C_M_TEN)\r\nreturn -EINVAL;\r\nread = (msgs->flags & I2C_M_RD) != 0;\r\naddrdir = (msgs->addr << 1) | read;\r\nrc = pmac_i2c_open(bus, 0);\r\nif (rc) {\r\ndev_err(&adap->dev, "Failed to open I2C, err %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = pmac_i2c_setmode(bus, pmac_i2c_mode_std);\r\nif (rc) {\r\ndev_err(&adap->dev, "Failed to set I2C mode %d, err %d\n",\r\npmac_i2c_mode_std, rc);\r\ngoto bail;\r\n}\r\nrc = pmac_i2c_xfer(bus, addrdir, 0, 0, msgs->buf, msgs->len);\r\nif (rc < 0) {\r\nif (rc == -ENXIO)\r\ndev_dbg(&adap->dev, "I2C %s 0x%02x failed, err %d\n",\r\naddrdir & 1 ? "read from" : "write to",\r\naddrdir >> 1, rc);\r\nelse\r\ndev_err(&adap->dev, "I2C %s 0x%02x failed, err %d\n",\r\naddrdir & 1 ? "read from" : "write to",\r\naddrdir >> 1, rc);\r\n}\r\nbail:\r\npmac_i2c_close(bus);\r\nreturn rc < 0 ? rc : 1;\r\n}\r\nstatic u32 i2c_powermac_func(struct i2c_adapter * adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_I2C;\r\n}\r\nstatic int i2c_powermac_remove(struct platform_device *dev)\r\n{\r\nstruct i2c_adapter *adapter = platform_get_drvdata(dev);\r\ni2c_del_adapter(adapter);\r\nmemset(adapter, 0, sizeof(*adapter));\r\nreturn 0;\r\n}\r\nstatic u32 i2c_powermac_get_addr(struct i2c_adapter *adap,\r\nstruct pmac_i2c_bus *bus,\r\nstruct device_node *node)\r\n{\r\nconst __be32 *prop;\r\nint len;\r\nprop = of_get_property(node, "reg", &len);\r\nif (prop && (len >= sizeof(int)))\r\nreturn (be32_to_cpup(prop) & 0xff) >> 1;\r\nprop = of_get_property(node, "i2c-address", &len);\r\nif (prop && (len >= sizeof(int)))\r\nreturn (be32_to_cpup(prop) & 0xff) >> 1;\r\nif (!strcmp(node->name, "cereal"))\r\nreturn 0x60;\r\nelse if (!strcmp(node->name, "deq"))\r\nreturn 0x34;\r\ndev_warn(&adap->dev, "No i2c address for %s\n", node->full_name);\r\nreturn 0xffffffff;\r\n}\r\nstatic void i2c_powermac_create_one(struct i2c_adapter *adap,\r\nconst char *type,\r\nu32 addr)\r\n{\r\nstruct i2c_board_info info = {};\r\nstruct i2c_client *newdev;\r\nstrncpy(info.type, type, sizeof(info.type));\r\ninfo.addr = addr;\r\nnewdev = i2c_new_device(adap, &info);\r\nif (!newdev)\r\ndev_err(&adap->dev,\r\n"i2c-powermac: Failure to register missing %s\n",\r\ntype);\r\n}\r\nstatic void i2c_powermac_add_missing(struct i2c_adapter *adap,\r\nstruct pmac_i2c_bus *bus,\r\nbool found_onyx)\r\n{\r\nstruct device_node *busnode = pmac_i2c_get_bus_node(bus);\r\nint rc;\r\n#define ONYX_REG_CONTROL 67\r\nif (of_device_is_compatible(busnode, "k2-i2c") && !found_onyx) {\r\nunion i2c_smbus_data data;\r\nrc = i2c_smbus_xfer(adap, 0x46, 0, I2C_SMBUS_READ,\r\nONYX_REG_CONTROL, I2C_SMBUS_BYTE_DATA,\r\n&data);\r\nif (rc >= 0)\r\ni2c_powermac_create_one(adap, "MAC,pcm3052", 0x46);\r\nrc = i2c_smbus_xfer(adap, 0x47, 0, I2C_SMBUS_READ,\r\nONYX_REG_CONTROL, I2C_SMBUS_BYTE_DATA,\r\n&data);\r\nif (rc >= 0)\r\ni2c_powermac_create_one(adap, "MAC,pcm3052", 0x47);\r\n}\r\n}\r\nstatic bool i2c_powermac_get_type(struct i2c_adapter *adap,\r\nstruct device_node *node,\r\nu32 addr, char *type, int type_size)\r\n{\r\nchar tmp[16];\r\nif (of_modalias_node(node, tmp, sizeof(tmp)) >= 0) {\r\nsnprintf(type, type_size, "MAC,%s", tmp);\r\nreturn true;\r\n}\r\nif (!strcmp(node->name, "deq")) {\r\nif (addr == 0x34) {\r\nsnprintf(type, type_size, "MAC,tas3001");\r\nreturn true;\r\n} else if (addr == 0x35) {\r\nsnprintf(type, type_size, "MAC,tas3004");\r\nreturn true;\r\n}\r\n}\r\ndev_err(&adap->dev, "i2c-powermac: modalias failure"\r\n" on %s\n", node->full_name);\r\nreturn false;\r\n}\r\nstatic void i2c_powermac_register_devices(struct i2c_adapter *adap,\r\nstruct pmac_i2c_bus *bus)\r\n{\r\nstruct i2c_client *newdev;\r\nstruct device_node *node;\r\nbool found_onyx = 0;\r\nif (!strcmp(adap->dev.of_node->name, "via-pmu"))\r\nreturn;\r\nfor_each_child_of_node(adap->dev.of_node, node) {\r\nstruct i2c_board_info info = {};\r\nu32 addr;\r\naddr = i2c_powermac_get_addr(adap, bus, node);\r\nif (addr == 0xffffffff)\r\ncontinue;\r\nif (!pmac_i2c_match_adapter(node, adap))\r\ncontinue;\r\ndev_dbg(&adap->dev, "i2c-powermac: register %s\n",\r\nnode->full_name);\r\nif (of_device_is_compatible(node, "pcm3052"))\r\nfound_onyx = true;\r\nif (!i2c_powermac_get_type(adap, node, addr,\r\ninfo.type, sizeof(info.type))) {\r\ncontinue;\r\n}\r\ninfo.addr = addr;\r\ninfo.irq = irq_of_parse_and_map(node, 0);\r\ninfo.of_node = of_node_get(node);\r\nnewdev = i2c_new_device(adap, &info);\r\nif (!newdev) {\r\ndev_err(&adap->dev, "i2c-powermac: Failure to register"\r\n" %s\n", node->full_name);\r\nof_node_put(node);\r\ncontinue;\r\n}\r\n}\r\ni2c_powermac_add_missing(adap, bus, found_onyx);\r\n}\r\nstatic int i2c_powermac_probe(struct platform_device *dev)\r\n{\r\nstruct pmac_i2c_bus *bus = dev->dev.platform_data;\r\nstruct device_node *parent = NULL;\r\nstruct i2c_adapter *adapter;\r\nconst char *basename;\r\nint rc;\r\nif (bus == NULL)\r\nreturn -EINVAL;\r\nadapter = pmac_i2c_get_adapter(bus);\r\nswitch(pmac_i2c_get_type(bus)) {\r\ncase pmac_i2c_bus_keywest:\r\nparent = of_get_parent(pmac_i2c_get_controller(bus));\r\nif (parent == NULL)\r\nreturn -EINVAL;\r\nbasename = parent->name;\r\nbreak;\r\ncase pmac_i2c_bus_pmu:\r\nbasename = "pmu";\r\nbreak;\r\ncase pmac_i2c_bus_smu:\r\nbasename = "smu";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnprintf(adapter->name, sizeof(adapter->name), "%s %d", basename,\r\npmac_i2c_get_channel(bus));\r\nof_node_put(parent);\r\nplatform_set_drvdata(dev, adapter);\r\nadapter->algo = &i2c_powermac_algorithm;\r\ni2c_set_adapdata(adapter, bus);\r\nadapter->dev.parent = &dev->dev;\r\nadapter->dev.of_node = dev->dev.of_node;\r\nrc = i2c_add_adapter(adapter);\r\nif (rc) {\r\nprintk(KERN_ERR "i2c-powermac: Adapter %s registration "\r\n"failed\n", adapter->name);\r\nmemset(adapter, 0, sizeof(*adapter));\r\n}\r\nprintk(KERN_INFO "PowerMac i2c bus %s registered\n", adapter->name);\r\ni2c_powermac_register_devices(adapter, bus);\r\nreturn rc;\r\n}
