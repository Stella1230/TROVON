static irqreturn_t bch_irq(int irq, void *cookie)\r\n{\r\nstruct gpmi_nand_data *this = cookie;\r\ngpmi_clear_bch(this);\r\ncomplete(&this->bch_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int get_ecc_strength(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nstruct mtd_info *mtd = &this->mtd;\r\nint ecc_strength;\r\necc_strength = ((mtd->oobsize - geo->metadata_size) * 8)\r\n/ (geo->gf_len * geo->ecc_chunk_count);\r\nreturn round_down(ecc_strength, 2);\r\n}\r\nstatic inline bool gpmi_check_ecc(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nif (GPMI_IS_MX23(this) || GPMI_IS_MX28(this)) {\r\nif (geo->gf_len == 14)\r\nreturn false;\r\nif (geo->ecc_strength > MXS_ECC_STRENGTH_MAX)\r\nreturn false;\r\n} else if (GPMI_IS_MX6Q(this)) {\r\nif (geo->ecc_strength > MX6_ECC_STRENGTH_MAX)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint common_nfc_set_geometry(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nstruct mtd_info *mtd = &this->mtd;\r\nunsigned int metadata_size;\r\nunsigned int status_size;\r\nunsigned int block_mark_bit_offset;\r\ngeo->metadata_size = 10;\r\ngeo->gf_len = 13;\r\ngeo->ecc_chunk_size = 512;\r\nwhile (geo->ecc_chunk_size < mtd->oobsize) {\r\ngeo->ecc_chunk_size *= 2;\r\ngeo->gf_len = 14;\r\n}\r\ngeo->ecc_chunk_count = mtd->writesize / geo->ecc_chunk_size;\r\ngeo->ecc_strength = get_ecc_strength(this);\r\nif (!gpmi_check_ecc(this)) {\r\ndev_err(this->dev,\r\n"We can not support this nand chip."\r\n" Its required ecc strength(%d) is beyond our"\r\n" capability(%d).\n", geo->ecc_strength,\r\n(GPMI_IS_MX6Q(this) ? MX6_ECC_STRENGTH_MAX\r\n: MXS_ECC_STRENGTH_MAX));\r\nreturn -EINVAL;\r\n}\r\ngeo->page_size = mtd->writesize + mtd->oobsize;\r\ngeo->payload_size = mtd->writesize;\r\nmetadata_size = ALIGN(geo->metadata_size, 4);\r\nstatus_size = ALIGN(geo->ecc_chunk_count, 4);\r\ngeo->auxiliary_size = metadata_size + status_size;\r\ngeo->auxiliary_status_offset = metadata_size;\r\nif (!this->swap_block_mark)\r\nreturn 0;\r\nblock_mark_bit_offset = mtd->writesize * 8 -\r\n(geo->ecc_strength * geo->gf_len * (geo->ecc_chunk_count - 1)\r\n+ geo->metadata_size * 8);\r\ngeo->block_mark_byte_offset = block_mark_bit_offset / 8;\r\ngeo->block_mark_bit_offset = block_mark_bit_offset % 8;\r\nreturn 0;\r\n}\r\nstruct dma_chan *get_dma_chan(struct gpmi_nand_data *this)\r\n{\r\nint chipnr = this->current_chip;\r\nreturn this->dma_chans[chipnr];\r\n}\r\nvoid prepare_data_dma(struct gpmi_nand_data *this, enum dma_data_direction dr)\r\n{\r\nstruct scatterlist *sgl = &this->data_sgl;\r\nint ret;\r\nthis->direct_dma_map_ok = true;\r\nsg_init_one(sgl, this->upper_buf, this->upper_len);\r\nret = dma_map_sg(this->dev, sgl, 1, dr);\r\nif (ret == 0) {\r\nsg_init_one(sgl, this->data_buffer_dma, PAGE_SIZE);\r\nif (dr == DMA_TO_DEVICE)\r\nmemcpy(this->data_buffer_dma, this->upper_buf,\r\nthis->upper_len);\r\nret = dma_map_sg(this->dev, sgl, 1, dr);\r\nif (ret == 0)\r\npr_err("DMA mapping failed.\n");\r\nthis->direct_dma_map_ok = false;\r\n}\r\n}\r\nstatic void dma_irq_callback(void *param)\r\n{\r\nstruct gpmi_nand_data *this = param;\r\nstruct completion *dma_c = &this->dma_done;\r\ncomplete(dma_c);\r\nswitch (this->dma_type) {\r\ncase DMA_FOR_COMMAND:\r\ndma_unmap_sg(this->dev, &this->cmd_sgl, 1, DMA_TO_DEVICE);\r\nbreak;\r\ncase DMA_FOR_READ_DATA:\r\ndma_unmap_sg(this->dev, &this->data_sgl, 1, DMA_FROM_DEVICE);\r\nif (this->direct_dma_map_ok == false)\r\nmemcpy(this->upper_buf, this->data_buffer_dma,\r\nthis->upper_len);\r\nbreak;\r\ncase DMA_FOR_WRITE_DATA:\r\ndma_unmap_sg(this->dev, &this->data_sgl, 1, DMA_TO_DEVICE);\r\nbreak;\r\ncase DMA_FOR_READ_ECC_PAGE:\r\ncase DMA_FOR_WRITE_ECC_PAGE:\r\nbreak;\r\ndefault:\r\npr_err("in wrong DMA operation.\n");\r\n}\r\n}\r\nint start_dma_without_bch_irq(struct gpmi_nand_data *this,\r\nstruct dma_async_tx_descriptor *desc)\r\n{\r\nstruct completion *dma_c = &this->dma_done;\r\nint err;\r\ninit_completion(dma_c);\r\ndesc->callback = dma_irq_callback;\r\ndesc->callback_param = this;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(get_dma_chan(this));\r\nerr = wait_for_completion_timeout(dma_c, msecs_to_jiffies(1000));\r\nif (!err) {\r\npr_err("DMA timeout, last DMA :%d\n", this->last_dma_type);\r\ngpmi_dump_info(this);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint start_dma_with_bch_irq(struct gpmi_nand_data *this,\r\nstruct dma_async_tx_descriptor *desc)\r\n{\r\nstruct completion *bch_c = &this->bch_done;\r\nint err;\r\ninit_completion(bch_c);\r\nstart_dma_without_bch_irq(this, desc);\r\nerr = wait_for_completion_timeout(bch_c, msecs_to_jiffies(1000));\r\nif (!err) {\r\npr_err("BCH timeout, last DMA :%d\n", this->last_dma_type);\r\ngpmi_dump_info(this);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acquire_register_block(struct gpmi_nand_data *this,\r\nconst char *res_name)\r\n{\r\nstruct platform_device *pdev = this->pdev;\r\nstruct resources *res = &this->resources;\r\nstruct resource *r;\r\nvoid __iomem *p;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);\r\nif (!r) {\r\npr_err("Can't get resource for %s\n", res_name);\r\nreturn -ENXIO;\r\n}\r\np = ioremap(r->start, resource_size(r));\r\nif (!p) {\r\npr_err("Can't remap %s\n", res_name);\r\nreturn -ENOMEM;\r\n}\r\nif (!strcmp(res_name, GPMI_NAND_GPMI_REGS_ADDR_RES_NAME))\r\nres->gpmi_regs = p;\r\nelse if (!strcmp(res_name, GPMI_NAND_BCH_REGS_ADDR_RES_NAME))\r\nres->bch_regs = p;\r\nelse\r\npr_err("unknown resource name : %s\n", res_name);\r\nreturn 0;\r\n}\r\nstatic void release_register_block(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *res = &this->resources;\r\nif (res->gpmi_regs)\r\niounmap(res->gpmi_regs);\r\nif (res->bch_regs)\r\niounmap(res->bch_regs);\r\nres->gpmi_regs = NULL;\r\nres->bch_regs = NULL;\r\n}\r\nstatic int acquire_bch_irq(struct gpmi_nand_data *this, irq_handler_t irq_h)\r\n{\r\nstruct platform_device *pdev = this->pdev;\r\nstruct resources *res = &this->resources;\r\nconst char *res_name = GPMI_NAND_BCH_INTERRUPT_RES_NAME;\r\nstruct resource *r;\r\nint err;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, res_name);\r\nif (!r) {\r\npr_err("Can't get resource for %s\n", res_name);\r\nreturn -ENXIO;\r\n}\r\nerr = request_irq(r->start, irq_h, 0, res_name, this);\r\nif (err) {\r\npr_err("Can't own %s\n", res_name);\r\nreturn err;\r\n}\r\nres->bch_low_interrupt = r->start;\r\nres->bch_high_interrupt = r->end;\r\nreturn 0;\r\n}\r\nstatic void release_bch_irq(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *res = &this->resources;\r\nint i = res->bch_low_interrupt;\r\nfor (; i <= res->bch_high_interrupt; i++)\r\nfree_irq(i, this);\r\n}\r\nstatic void release_dma_channels(struct gpmi_nand_data *this)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < DMA_CHANS; i++)\r\nif (this->dma_chans[i]) {\r\ndma_release_channel(this->dma_chans[i]);\r\nthis->dma_chans[i] = NULL;\r\n}\r\n}\r\nstatic int acquire_dma_channels(struct gpmi_nand_data *this)\r\n{\r\nstruct platform_device *pdev = this->pdev;\r\nstruct dma_chan *dma_chan;\r\ndma_chan = dma_request_slave_channel(&pdev->dev, "rx-tx");\r\nif (!dma_chan) {\r\npr_err("Failed to request DMA channel.\n");\r\ngoto acquire_err;\r\n}\r\nthis->dma_chans[0] = dma_chan;\r\nreturn 0;\r\nacquire_err:\r\nrelease_dma_channels(this);\r\nreturn -EINVAL;\r\n}\r\nstatic void gpmi_put_clks(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *r = &this->resources;\r\nstruct clk *clk;\r\nint i;\r\nfor (i = 0; i < GPMI_CLK_MAX; i++) {\r\nclk = r->clock[i];\r\nif (clk) {\r\nclk_put(clk);\r\nr->clock[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int gpmi_get_clks(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *r = &this->resources;\r\nchar **extra_clks = NULL;\r\nstruct clk *clk;\r\nint i;\r\nr->clock[0] = clk_get(this->dev, "gpmi_io");\r\nif (IS_ERR(r->clock[0]))\r\ngoto err_clock;\r\nif (GPMI_IS_MX6Q(this))\r\nextra_clks = extra_clks_for_mx6q;\r\nif (!extra_clks)\r\nreturn 0;\r\nfor (i = 1; i < GPMI_CLK_MAX; i++) {\r\nif (extra_clks[i - 1] == NULL)\r\nbreak;\r\nclk = clk_get(this->dev, extra_clks[i - 1]);\r\nif (IS_ERR(clk))\r\ngoto err_clock;\r\nr->clock[i] = clk;\r\n}\r\nif (GPMI_IS_MX6Q(this))\r\nclk_set_rate(r->clock[0], 22000000);\r\nreturn 0;\r\nerr_clock:\r\ndev_dbg(this->dev, "failed in finding the clocks.\n");\r\ngpmi_put_clks(this);\r\nreturn -ENOMEM;\r\n}\r\nstatic int acquire_resources(struct gpmi_nand_data *this)\r\n{\r\nstruct pinctrl *pinctrl;\r\nint ret;\r\nret = acquire_register_block(this, GPMI_NAND_GPMI_REGS_ADDR_RES_NAME);\r\nif (ret)\r\ngoto exit_regs;\r\nret = acquire_register_block(this, GPMI_NAND_BCH_REGS_ADDR_RES_NAME);\r\nif (ret)\r\ngoto exit_regs;\r\nret = acquire_bch_irq(this, bch_irq);\r\nif (ret)\r\ngoto exit_regs;\r\nret = acquire_dma_channels(this);\r\nif (ret)\r\ngoto exit_dma_channels;\r\npinctrl = devm_pinctrl_get_select_default(&this->pdev->dev);\r\nif (IS_ERR(pinctrl)) {\r\nret = PTR_ERR(pinctrl);\r\ngoto exit_pin;\r\n}\r\nret = gpmi_get_clks(this);\r\nif (ret)\r\ngoto exit_clock;\r\nreturn 0;\r\nexit_clock:\r\nexit_pin:\r\nrelease_dma_channels(this);\r\nexit_dma_channels:\r\nrelease_bch_irq(this);\r\nexit_regs:\r\nrelease_register_block(this);\r\nreturn ret;\r\n}\r\nstatic void release_resources(struct gpmi_nand_data *this)\r\n{\r\ngpmi_put_clks(this);\r\nrelease_register_block(this);\r\nrelease_bch_irq(this);\r\nrelease_dma_channels(this);\r\n}\r\nstatic int init_hardware(struct gpmi_nand_data *this)\r\n{\r\nint ret;\r\nstruct nand_timing safe_timing = {\r\n.data_setup_in_ns = 80,\r\n.data_hold_in_ns = 60,\r\n.address_setup_in_ns = 25,\r\n.gpmi_sample_delay_in_ns = 6,\r\n.tREA_in_ns = -1,\r\n.tRLOH_in_ns = -1,\r\n.tRHOH_in_ns = -1,\r\n};\r\nret = gpmi_init(this);\r\nif (ret)\r\nreturn ret;\r\nthis->timing = safe_timing;\r\nreturn 0;\r\n}\r\nstatic int read_page_prepare(struct gpmi_nand_data *this,\r\nvoid *destination, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nvoid **use_virt, dma_addr_t *use_phys)\r\n{\r\nstruct device *dev = this->dev;\r\nif (virt_addr_valid(destination)) {\r\ndma_addr_t dest_phys;\r\ndest_phys = dma_map_single(dev, destination,\r\nlength, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, dest_phys)) {\r\nif (alt_size < length) {\r\npr_err("%s, Alternate buffer is too small\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\ngoto map_failed;\r\n}\r\n*use_virt = destination;\r\n*use_phys = dest_phys;\r\nthis->direct_dma_map_ok = true;\r\nreturn 0;\r\n}\r\nmap_failed:\r\n*use_virt = alt_virt;\r\n*use_phys = alt_phys;\r\nthis->direct_dma_map_ok = false;\r\nreturn 0;\r\n}\r\nstatic inline void read_page_end(struct gpmi_nand_data *this,\r\nvoid *destination, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nvoid *used_virt, dma_addr_t used_phys)\r\n{\r\nif (this->direct_dma_map_ok)\r\ndma_unmap_single(this->dev, used_phys, length, DMA_FROM_DEVICE);\r\n}\r\nstatic inline void read_page_swap_end(struct gpmi_nand_data *this,\r\nvoid *destination, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nvoid *used_virt, dma_addr_t used_phys)\r\n{\r\nif (!this->direct_dma_map_ok)\r\nmemcpy(destination, alt_virt, length);\r\n}\r\nstatic int send_page_prepare(struct gpmi_nand_data *this,\r\nconst void *source, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nconst void **use_virt, dma_addr_t *use_phys)\r\n{\r\nstruct device *dev = this->dev;\r\nif (virt_addr_valid(source)) {\r\ndma_addr_t source_phys;\r\nsource_phys = dma_map_single(dev, (void *)source, length,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, source_phys)) {\r\nif (alt_size < length) {\r\npr_err("%s, Alternate buffer is too small\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\ngoto map_failed;\r\n}\r\n*use_virt = source;\r\n*use_phys = source_phys;\r\nreturn 0;\r\n}\r\nmap_failed:\r\nmemcpy(alt_virt, source, length);\r\n*use_virt = alt_virt;\r\n*use_phys = alt_phys;\r\nreturn 0;\r\n}\r\nstatic void send_page_end(struct gpmi_nand_data *this,\r\nconst void *source, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nconst void *used_virt, dma_addr_t used_phys)\r\n{\r\nstruct device *dev = this->dev;\r\nif (used_virt == source)\r\ndma_unmap_single(dev, used_phys, length, DMA_TO_DEVICE);\r\n}\r\nstatic void gpmi_free_dma_buffer(struct gpmi_nand_data *this)\r\n{\r\nstruct device *dev = this->dev;\r\nif (this->page_buffer_virt && virt_addr_valid(this->page_buffer_virt))\r\ndma_free_coherent(dev, this->page_buffer_size,\r\nthis->page_buffer_virt,\r\nthis->page_buffer_phys);\r\nkfree(this->cmd_buffer);\r\nkfree(this->data_buffer_dma);\r\nthis->cmd_buffer = NULL;\r\nthis->data_buffer_dma = NULL;\r\nthis->page_buffer_virt = NULL;\r\nthis->page_buffer_size = 0;\r\n}\r\nstatic int gpmi_alloc_dma_buffer(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nstruct device *dev = this->dev;\r\nthis->cmd_buffer = kzalloc(PAGE_SIZE, GFP_DMA | GFP_KERNEL);\r\nif (this->cmd_buffer == NULL)\r\ngoto error_alloc;\r\nthis->data_buffer_dma = kzalloc(PAGE_SIZE, GFP_DMA | GFP_KERNEL);\r\nif (this->data_buffer_dma == NULL)\r\ngoto error_alloc;\r\nthis->page_buffer_size = geo->payload_size + geo->auxiliary_size;\r\nthis->page_buffer_virt = dma_alloc_coherent(dev, this->page_buffer_size,\r\n&this->page_buffer_phys, GFP_DMA);\r\nif (!this->page_buffer_virt)\r\ngoto error_alloc;\r\nthis->payload_virt = this->page_buffer_virt;\r\nthis->payload_phys = this->page_buffer_phys;\r\nthis->auxiliary_virt = this->payload_virt + geo->payload_size;\r\nthis->auxiliary_phys = this->payload_phys + geo->payload_size;\r\nreturn 0;\r\nerror_alloc:\r\ngpmi_free_dma_buffer(this);\r\npr_err("Error allocating DMA buffers!\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic void gpmi_cmd_ctrl(struct mtd_info *mtd, int data, unsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct gpmi_nand_data *this = chip->priv;\r\nint ret;\r\nif ((ctrl & (NAND_ALE | NAND_CLE))) {\r\nif (data != NAND_CMD_NONE)\r\nthis->cmd_buffer[this->command_length++] = data;\r\nreturn;\r\n}\r\nif (!this->command_length)\r\nreturn;\r\nret = gpmi_send_command(this);\r\nif (ret)\r\npr_err("Chip: %u, Error %d\n", this->current_chip, ret);\r\nthis->command_length = 0;\r\n}\r\nstatic int gpmi_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct gpmi_nand_data *this = chip->priv;\r\nreturn gpmi_is_ready(this, this->current_chip);\r\n}\r\nstatic void gpmi_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct gpmi_nand_data *this = chip->priv;\r\nif ((this->current_chip < 0) && (chipnr >= 0))\r\ngpmi_begin(this);\r\nelse if ((this->current_chip >= 0) && (chipnr < 0))\r\ngpmi_end(this);\r\nthis->current_chip = chipnr;\r\n}\r\nstatic void gpmi_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct gpmi_nand_data *this = chip->priv;\r\npr_debug("len is %d\n", len);\r\nthis->upper_buf = buf;\r\nthis->upper_len = len;\r\ngpmi_read_data(this);\r\n}\r\nstatic void gpmi_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct gpmi_nand_data *this = chip->priv;\r\npr_debug("len is %d\n", len);\r\nthis->upper_buf = (uint8_t *)buf;\r\nthis->upper_len = len;\r\ngpmi_send_data(this);\r\n}\r\nstatic uint8_t gpmi_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct gpmi_nand_data *this = chip->priv;\r\nuint8_t *buf = this->data_buffer_dma;\r\ngpmi_read_buf(mtd, buf, 1);\r\nreturn buf[0];\r\n}\r\nstatic void block_mark_swapping(struct gpmi_nand_data *this,\r\nvoid *payload, void *auxiliary)\r\n{\r\nstruct bch_geometry *nfc_geo = &this->bch_geometry;\r\nunsigned char *p;\r\nunsigned char *a;\r\nunsigned int bit;\r\nunsigned char mask;\r\nunsigned char from_data;\r\nunsigned char from_oob;\r\nif (!this->swap_block_mark)\r\nreturn;\r\nbit = nfc_geo->block_mark_bit_offset;\r\np = payload + nfc_geo->block_mark_byte_offset;\r\na = auxiliary;\r\nfrom_data = (p[0] >> bit) | (p[1] << (8 - bit));\r\nfrom_oob = a[0];\r\na[0] = from_data;\r\nmask = (0x1 << bit) - 1;\r\np[0] = (p[0] & mask) | (from_oob << bit);\r\nmask = ~0 << bit;\r\np[1] = (p[1] & mask) | (from_oob >> (8 - bit));\r\n}\r\nstatic int gpmi_ecc_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nstruct gpmi_nand_data *this = chip->priv;\r\nstruct bch_geometry *nfc_geo = &this->bch_geometry;\r\nvoid *payload_virt;\r\ndma_addr_t payload_phys;\r\nvoid *auxiliary_virt;\r\ndma_addr_t auxiliary_phys;\r\nunsigned int i;\r\nunsigned char *status;\r\nunsigned int max_bitflips = 0;\r\nint ret;\r\npr_debug("page number is : %d\n", page);\r\nret = read_page_prepare(this, buf, mtd->writesize,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\n&payload_virt, &payload_phys);\r\nif (ret) {\r\npr_err("Inadequate DMA buffer\n");\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nauxiliary_virt = this->auxiliary_virt;\r\nauxiliary_phys = this->auxiliary_phys;\r\nret = gpmi_read_page(this, payload_phys, auxiliary_phys);\r\nread_page_end(this, buf, mtd->writesize,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\npayload_virt, payload_phys);\r\nif (ret) {\r\npr_err("Error in ECC-based read: %d\n", ret);\r\nreturn ret;\r\n}\r\nblock_mark_swapping(this, payload_virt, auxiliary_virt);\r\nstatus = auxiliary_virt + nfc_geo->auxiliary_status_offset;\r\nfor (i = 0; i < nfc_geo->ecc_chunk_count; i++, status++) {\r\nif ((*status == STATUS_GOOD) || (*status == STATUS_ERASED))\r\ncontinue;\r\nif (*status == STATUS_UNCORRECTABLE) {\r\nmtd->ecc_stats.failed++;\r\ncontinue;\r\n}\r\nmtd->ecc_stats.corrected += *status;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, *status);\r\n}\r\nif (oob_required) {\r\nmemset(chip->oob_poi, ~0, mtd->oobsize);\r\nchip->oob_poi[0] = ((uint8_t *) auxiliary_virt)[0];\r\n}\r\nread_page_swap_end(this, buf, mtd->writesize,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\npayload_virt, payload_phys);\r\nreturn max_bitflips;\r\n}\r\nstatic int gpmi_ecc_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nstruct gpmi_nand_data *this = chip->priv;\r\nstruct bch_geometry *nfc_geo = &this->bch_geometry;\r\nconst void *payload_virt;\r\ndma_addr_t payload_phys;\r\nconst void *auxiliary_virt;\r\ndma_addr_t auxiliary_phys;\r\nint ret;\r\npr_debug("ecc write page.\n");\r\nif (this->swap_block_mark) {\r\nmemcpy(this->payload_virt, buf, mtd->writesize);\r\npayload_virt = this->payload_virt;\r\npayload_phys = this->payload_phys;\r\nmemcpy(this->auxiliary_virt, chip->oob_poi,\r\nnfc_geo->auxiliary_size);\r\nauxiliary_virt = this->auxiliary_virt;\r\nauxiliary_phys = this->auxiliary_phys;\r\nblock_mark_swapping(this,\r\n(void *) payload_virt, (void *) auxiliary_virt);\r\n} else {\r\nret = send_page_prepare(this,\r\nbuf, mtd->writesize,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\n&payload_virt, &payload_phys);\r\nif (ret) {\r\npr_err("Inadequate payload DMA buffer\n");\r\nreturn 0;\r\n}\r\nret = send_page_prepare(this,\r\nchip->oob_poi, mtd->oobsize,\r\nthis->auxiliary_virt, this->auxiliary_phys,\r\nnfc_geo->auxiliary_size,\r\n&auxiliary_virt, &auxiliary_phys);\r\nif (ret) {\r\npr_err("Inadequate auxiliary DMA buffer\n");\r\ngoto exit_auxiliary;\r\n}\r\n}\r\nret = gpmi_send_page(this, payload_phys, auxiliary_phys);\r\nif (ret)\r\npr_err("Error in ECC-based write: %d\n", ret);\r\nif (!this->swap_block_mark) {\r\nsend_page_end(this, chip->oob_poi, mtd->oobsize,\r\nthis->auxiliary_virt, this->auxiliary_phys,\r\nnfc_geo->auxiliary_size,\r\nauxiliary_virt, auxiliary_phys);\r\nexit_auxiliary:\r\nsend_page_end(this, buf, mtd->writesize,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\npayload_virt, payload_phys);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpmi_ecc_read_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nstruct gpmi_nand_data *this = chip->priv;\r\npr_debug("page number is %d\n", page);\r\nmemset(chip->oob_poi, ~0, mtd->oobsize);\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, mtd->writesize, page);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (!this->swap_block_mark) {\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nchip->oob_poi[0] = chip->read_byte(mtd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngpmi_ecc_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic int gpmi_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct gpmi_nand_data *this = chip->priv;\r\nint block, ret = 0;\r\nuint8_t *block_mark;\r\nint column, page, status, chipnr;\r\nblock = (int)(ofs >> chip->bbt_erase_shift);\r\nif (chip->bbt)\r\nchip->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);\r\nif (chip->bbt_options & NAND_BBT_USE_FLASH)\r\nret = nand_update_bbt(mtd, ofs);\r\nelse {\r\nchipnr = (int)(ofs >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\ncolumn = this->swap_block_mark ? mtd->writesize : 0;\r\nblock_mark = this->data_buffer_dma;\r\nblock_mark[0] = 0;\r\npage = (int)(ofs >> chip->page_shift);\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, column, page);\r\nchip->write_buf(mtd, block_mark, 1);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL)\r\nret = -EIO;\r\nchip->select_chip(mtd, -1);\r\n}\r\nif (!ret)\r\nmtd->ecc_stats.badblocks++;\r\nreturn ret;\r\n}\r\nstatic int nand_boot_set_geometry(struct gpmi_nand_data *this)\r\n{\r\nstruct boot_rom_geometry *geometry = &this->rom_geometry;\r\ngeometry->stride_size_in_pages = 64;\r\ngeometry->search_area_stride_exponent = 2;\r\nreturn 0;\r\n}\r\nstatic int mx23_check_transcription_stamp(struct gpmi_nand_data *this)\r\n{\r\nstruct boot_rom_geometry *rom_geo = &this->rom_geometry;\r\nstruct device *dev = this->dev;\r\nstruct mtd_info *mtd = &this->mtd;\r\nstruct nand_chip *chip = &this->nand;\r\nunsigned int search_area_size_in_strides;\r\nunsigned int stride;\r\nunsigned int page;\r\nuint8_t *buffer = chip->buffers->databuf;\r\nint saved_chip_number;\r\nint found_an_ncb_fingerprint = false;\r\nsearch_area_size_in_strides = 1 << rom_geo->search_area_stride_exponent;\r\nsaved_chip_number = this->current_chip;\r\nchip->select_chip(mtd, 0);\r\ndev_dbg(dev, "Scanning for an NCB fingerprint...\n");\r\nfor (stride = 0; stride < search_area_size_in_strides; stride++) {\r\npage = stride * rom_geo->stride_size_in_pages;\r\ndev_dbg(dev, "Looking for a fingerprint in page 0x%x\n", page);\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 12, page);\r\nchip->read_buf(mtd, buffer, strlen(fingerprint));\r\nif (!memcmp(buffer, fingerprint, strlen(fingerprint))) {\r\nfound_an_ncb_fingerprint = true;\r\nbreak;\r\n}\r\n}\r\nchip->select_chip(mtd, saved_chip_number);\r\nif (found_an_ncb_fingerprint)\r\ndev_dbg(dev, "\tFound a fingerprint\n");\r\nelse\r\ndev_dbg(dev, "\tNo fingerprint found\n");\r\nreturn found_an_ncb_fingerprint;\r\n}\r\nstatic int mx23_write_transcription_stamp(struct gpmi_nand_data *this)\r\n{\r\nstruct device *dev = this->dev;\r\nstruct boot_rom_geometry *rom_geo = &this->rom_geometry;\r\nstruct mtd_info *mtd = &this->mtd;\r\nstruct nand_chip *chip = &this->nand;\r\nunsigned int block_size_in_pages;\r\nunsigned int search_area_size_in_strides;\r\nunsigned int search_area_size_in_pages;\r\nunsigned int search_area_size_in_blocks;\r\nunsigned int block;\r\nunsigned int stride;\r\nunsigned int page;\r\nuint8_t *buffer = chip->buffers->databuf;\r\nint saved_chip_number;\r\nint status;\r\nblock_size_in_pages = mtd->erasesize / mtd->writesize;\r\nsearch_area_size_in_strides = 1 << rom_geo->search_area_stride_exponent;\r\nsearch_area_size_in_pages = search_area_size_in_strides *\r\nrom_geo->stride_size_in_pages;\r\nsearch_area_size_in_blocks =\r\n(search_area_size_in_pages + (block_size_in_pages - 1)) /\r\nblock_size_in_pages;\r\ndev_dbg(dev, "Search Area Geometry :\n");\r\ndev_dbg(dev, "\tin Blocks : %u\n", search_area_size_in_blocks);\r\ndev_dbg(dev, "\tin Strides: %u\n", search_area_size_in_strides);\r\ndev_dbg(dev, "\tin Pages : %u\n", search_area_size_in_pages);\r\nsaved_chip_number = this->current_chip;\r\nchip->select_chip(mtd, 0);\r\ndev_dbg(dev, "Erasing the search area...\n");\r\nfor (block = 0; block < search_area_size_in_blocks; block++) {\r\npage = block * block_size_in_pages;\r\ndev_dbg(dev, "\tErasing block 0x%x\n", block);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL)\r\ndev_err(dev, "[%s] Erase failed.\n", __func__);\r\n}\r\nmemset(buffer, ~0, mtd->writesize);\r\nmemset(chip->oob_poi, ~0, mtd->oobsize);\r\nmemcpy(buffer + 12, fingerprint, strlen(fingerprint));\r\ndev_dbg(dev, "Writing NCB fingerprints...\n");\r\nfor (stride = 0; stride < search_area_size_in_strides; stride++) {\r\npage = stride * rom_geo->stride_size_in_pages;\r\ndev_dbg(dev, "Writing an NCB fingerprint in page 0x%x\n", page);\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);\r\nchip->ecc.write_page_raw(mtd, chip, buffer, 0);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL)\r\ndev_err(dev, "[%s] Write failed.\n", __func__);\r\n}\r\nchip->select_chip(mtd, saved_chip_number);\r\nreturn 0;\r\n}\r\nstatic int mx23_boot_init(struct gpmi_nand_data *this)\r\n{\r\nstruct device *dev = this->dev;\r\nstruct nand_chip *chip = &this->nand;\r\nstruct mtd_info *mtd = &this->mtd;\r\nunsigned int block_count;\r\nunsigned int block;\r\nint chipnr;\r\nint page;\r\nloff_t byte;\r\nuint8_t block_mark;\r\nint ret = 0;\r\nif (mx23_check_transcription_stamp(this))\r\nreturn 0;\r\ndev_dbg(dev, "Transcribing bad block marks...\n");\r\nblock_count = chip->chipsize >> chip->phys_erase_shift;\r\nfor (block = 0; block < block_count; block++) {\r\nchipnr = block >> (chip->chip_shift - chip->phys_erase_shift);\r\npage = block << (chip->phys_erase_shift - chip->page_shift);\r\nbyte = block << chip->phys_erase_shift;\r\nchip->select_chip(mtd, chipnr);\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, mtd->writesize, page);\r\nblock_mark = chip->read_byte(mtd);\r\nchip->select_chip(mtd, -1);\r\nif (block_mark != 0xff) {\r\ndev_dbg(dev, "Transcribing mark in block %u\n", block);\r\nret = chip->block_markbad(mtd, byte);\r\nif (ret)\r\ndev_err(dev, "Failed to mark block bad with "\r\n"ret %d\n", ret);\r\n}\r\n}\r\nmx23_write_transcription_stamp(this);\r\nreturn 0;\r\n}\r\nstatic int nand_boot_init(struct gpmi_nand_data *this)\r\n{\r\nnand_boot_set_geometry(this);\r\nif (GPMI_IS_MX23(this))\r\nreturn mx23_boot_init(this);\r\nreturn 0;\r\n}\r\nstatic int gpmi_set_geometry(struct gpmi_nand_data *this)\r\n{\r\nint ret;\r\ngpmi_free_dma_buffer(this);\r\nret = bch_set_geometry(this);\r\nif (ret) {\r\npr_err("Error setting BCH geometry : %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn gpmi_alloc_dma_buffer(this);\r\n}\r\nstatic int gpmi_pre_bbt_scan(struct gpmi_nand_data *this)\r\n{\r\nint ret;\r\nif (GPMI_IS_MX23(this))\r\nthis->swap_block_mark = false;\r\nelse\r\nthis->swap_block_mark = true;\r\nret = gpmi_set_geometry(this);\r\nif (ret)\r\nreturn ret;\r\nthis->nand.ecc.strength = this->bch_geometry.ecc_strength;\r\nthis->mtd.ecc_strength = this->bch_geometry.ecc_strength;\r\nthis->mtd.bitflip_threshold = this->bch_geometry.ecc_strength;\r\nreturn nand_boot_init(this);\r\n}\r\nstatic int gpmi_scan_bbt(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct gpmi_nand_data *this = chip->priv;\r\nint ret;\r\nret = gpmi_pre_bbt_scan(this);\r\nif (ret)\r\nreturn ret;\r\ngpmi_extra_init(this);\r\nreturn nand_default_bbt(mtd);\r\n}\r\nstatic void gpmi_nfc_exit(struct gpmi_nand_data *this)\r\n{\r\nnand_release(&this->mtd);\r\ngpmi_free_dma_buffer(this);\r\n}\r\nstatic int gpmi_nfc_init(struct gpmi_nand_data *this)\r\n{\r\nstruct mtd_info *mtd = &this->mtd;\r\nstruct nand_chip *chip = &this->nand;\r\nstruct mtd_part_parser_data ppdata = {};\r\nint ret;\r\nthis->current_chip = -1;\r\nmtd->priv = chip;\r\nmtd->name = "gpmi-nand";\r\nmtd->owner = THIS_MODULE;\r\nchip->priv = this;\r\nchip->select_chip = gpmi_select_chip;\r\nchip->cmd_ctrl = gpmi_cmd_ctrl;\r\nchip->dev_ready = gpmi_dev_ready;\r\nchip->read_byte = gpmi_read_byte;\r\nchip->read_buf = gpmi_read_buf;\r\nchip->write_buf = gpmi_write_buf;\r\nchip->ecc.read_page = gpmi_ecc_read_page;\r\nchip->ecc.write_page = gpmi_ecc_write_page;\r\nchip->ecc.read_oob = gpmi_ecc_read_oob;\r\nchip->ecc.write_oob = gpmi_ecc_write_oob;\r\nchip->scan_bbt = gpmi_scan_bbt;\r\nchip->badblock_pattern = &gpmi_bbt_descr;\r\nchip->block_markbad = gpmi_block_markbad;\r\nchip->options |= NAND_NO_SUBPAGE_WRITE;\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.size = 1;\r\nchip->ecc.strength = 8;\r\nchip->ecc.layout = &gpmi_hw_ecclayout;\r\nif (of_get_nand_on_flash_bbt(this->dev->of_node))\r\nchip->bbt_options |= NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;\r\nthis->bch_geometry.payload_size = 1024;\r\nthis->bch_geometry.auxiliary_size = 128;\r\nret = gpmi_alloc_dma_buffer(this);\r\nif (ret)\r\ngoto err_out;\r\nret = nand_scan(mtd, 1);\r\nif (ret) {\r\npr_err("Chip scan failed\n");\r\ngoto err_out;\r\n}\r\nppdata.of_node = this->pdev->dev.of_node;\r\nret = mtd_device_parse_register(mtd, NULL, &ppdata, NULL, 0);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\ngpmi_nfc_exit(this);\r\nreturn ret;\r\n}\r\nstatic int gpmi_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct gpmi_nand_data *this;\r\nconst struct of_device_id *of_id;\r\nint ret;\r\nof_id = of_match_device(gpmi_nand_id_table, &pdev->dev);\r\nif (of_id) {\r\npdev->id_entry = of_id->data;\r\n} else {\r\npr_err("Failed to find the right device id.\n");\r\nreturn -ENOMEM;\r\n}\r\nthis = kzalloc(sizeof(*this), GFP_KERNEL);\r\nif (!this) {\r\npr_err("Failed to allocate per-device memory\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, this);\r\nthis->pdev = pdev;\r\nthis->dev = &pdev->dev;\r\nret = acquire_resources(this);\r\nif (ret)\r\ngoto exit_acquire_resources;\r\nret = init_hardware(this);\r\nif (ret)\r\ngoto exit_nfc_init;\r\nret = gpmi_nfc_init(this);\r\nif (ret)\r\ngoto exit_nfc_init;\r\ndev_info(this->dev, "driver registered.\n");\r\nreturn 0;\r\nexit_nfc_init:\r\nrelease_resources(this);\r\nexit_acquire_resources:\r\nplatform_set_drvdata(pdev, NULL);\r\ndev_err(this->dev, "driver registration failed: %d\n", ret);\r\nkfree(this);\r\nreturn ret;\r\n}\r\nstatic int gpmi_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct gpmi_nand_data *this = platform_get_drvdata(pdev);\r\ngpmi_nfc_exit(this);\r\nrelease_resources(this);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(this);\r\nreturn 0;\r\n}
