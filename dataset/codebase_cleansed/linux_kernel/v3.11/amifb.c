static int ami_decode_var(struct fb_var_screeninfo *var, struct amifb_par *par,\r\nconst struct fb_info *info)\r\n{\r\nu_short clk_shift, line_shift;\r\nu_long maxfetchstop, fstrt, fsize, fconst, xres_n, yres_n;\r\nu_int htotal, vtotal;\r\nfor (clk_shift = TAG_SHRES; clk_shift <= TAG_LORES; clk_shift++)\r\nif (var->pixclock <= pixclock[clk_shift])\r\nbreak;\r\nif (clk_shift > TAG_LORES) {\r\nDPRINTK("pixclock too high\n");\r\nreturn -EINVAL;\r\n}\r\npar->clk_shift = clk_shift;\r\nif ((par->xres = var->xres) < 64)\r\npar->xres = 64;\r\nif ((par->yres = var->yres) < 64)\r\npar->yres = 64;\r\nif ((par->vxres = var->xres_virtual) < par->xres)\r\npar->vxres = par->xres;\r\nif ((par->vyres = var->yres_virtual) < par->yres)\r\npar->vyres = par->yres;\r\npar->bpp = var->bits_per_pixel;\r\nif (!var->nonstd) {\r\nif (par->bpp < 1)\r\npar->bpp = 1;\r\nif (par->bpp > maxdepth[clk_shift]) {\r\nif (round_down_bpp && maxdepth[clk_shift])\r\npar->bpp = maxdepth[clk_shift];\r\nelse {\r\nDPRINTK("invalid bpp\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n} else if (var->nonstd == FB_NONSTD_HAM) {\r\nif (par->bpp < 6)\r\npar->bpp = 6;\r\nif (par->bpp != 6) {\r\nif (par->bpp < 8)\r\npar->bpp = 8;\r\nif (par->bpp != 8 || !IS_AGA) {\r\nDPRINTK("invalid bpp for ham mode\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n} else {\r\nDPRINTK("unknown nonstd mode\n");\r\nreturn -EINVAL;\r\n}\r\npar->vmode = var->vmode | FB_VMODE_SMOOTH_XPAN;\r\nswitch (par->vmode & FB_VMODE_MASK) {\r\ncase FB_VMODE_INTERLACED:\r\nline_shift = 0;\r\nbreak;\r\ncase FB_VMODE_NONINTERLACED:\r\nline_shift = 1;\r\nbreak;\r\ncase FB_VMODE_DOUBLE:\r\nif (!IS_AGA) {\r\nDPRINTK("double mode only possible with aga\n");\r\nreturn -EINVAL;\r\n}\r\nline_shift = 2;\r\nbreak;\r\ndefault:\r\nDPRINTK("unknown video mode\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\npar->line_shift = line_shift;\r\nxres_n = par->xres << clk_shift;\r\nyres_n = par->yres << line_shift;\r\npar->htotal = down8((var->left_margin + par->xres + var->right_margin +\r\nvar->hsync_len) << clk_shift);\r\npar->vtotal =\r\ndown2(((var->upper_margin + par->yres + var->lower_margin +\r\nvar->vsync_len) << line_shift) + 1);\r\nif (IS_AGA)\r\npar->bplcon3 = sprpixmode[clk_shift];\r\nelse\r\npar->bplcon3 = 0;\r\nif (var->sync & FB_SYNC_BROADCAST) {\r\npar->diwstop_h = par->htotal -\r\n((var->right_margin - var->hsync_len) << clk_shift);\r\nif (IS_AGA)\r\npar->diwstop_h += mod4(var->hsync_len);\r\nelse\r\npar->diwstop_h = down4(par->diwstop_h);\r\npar->diwstrt_h = par->diwstop_h - xres_n;\r\npar->diwstop_v = par->vtotal -\r\n((var->lower_margin - var->vsync_len) << line_shift);\r\npar->diwstrt_v = par->diwstop_v - yres_n;\r\nif (par->diwstop_h >= par->htotal + 8) {\r\nDPRINTK("invalid diwstop_h\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->diwstop_v > par->vtotal) {\r\nDPRINTK("invalid diwstop_v\n");\r\nreturn -EINVAL;\r\n}\r\nif (!IS_OCS) {\r\npar->hsstrt = 160;\r\npar->hsstop = 320;\r\npar->vsstrt = 30;\r\npar->vsstop = 34;\r\n} else {\r\npar->hsstrt = 0;\r\npar->hsstop = 0;\r\npar->vsstrt = 0;\r\npar->vsstop = 0;\r\n}\r\nif (par->vtotal > (PAL_VTOTAL + NTSC_VTOTAL) / 2) {\r\nif (par->htotal != PAL_HTOTAL) {\r\nDPRINTK("htotal invalid for pal\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->diwstrt_h < PAL_DIWSTRT_H) {\r\nDPRINTK("diwstrt_h too low for pal\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->diwstrt_v < PAL_DIWSTRT_V) {\r\nDPRINTK("diwstrt_v too low for pal\n");\r\nreturn -EINVAL;\r\n}\r\nhtotal = PAL_HTOTAL>>clk_shift;\r\nvtotal = PAL_VTOTAL>>1;\r\nif (!IS_OCS) {\r\npar->beamcon0 = BMC0_PAL;\r\npar->bplcon3 |= BPC3_BRDRBLNK;\r\n} else if (AMIGAHW_PRESENT(AGNUS_HR_PAL) ||\r\nAMIGAHW_PRESENT(AGNUS_HR_NTSC)) {\r\npar->beamcon0 = BMC0_PAL;\r\npar->hsstop = 1;\r\n} else if (amiga_vblank != 50) {\r\nDPRINTK("pal not supported by this chipset\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (par->htotal != NTSC_HTOTAL) {\r\nDPRINTK("htotal invalid for ntsc\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->diwstrt_h < NTSC_DIWSTRT_H) {\r\nDPRINTK("diwstrt_h too low for ntsc\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->diwstrt_v < NTSC_DIWSTRT_V) {\r\nDPRINTK("diwstrt_v too low for ntsc\n");\r\nreturn -EINVAL;\r\n}\r\nhtotal = NTSC_HTOTAL>>clk_shift;\r\nvtotal = NTSC_VTOTAL>>1;\r\nif (!IS_OCS) {\r\npar->beamcon0 = 0;\r\npar->bplcon3 |= BPC3_BRDRBLNK;\r\n} else if (AMIGAHW_PRESENT(AGNUS_HR_PAL) ||\r\nAMIGAHW_PRESENT(AGNUS_HR_NTSC)) {\r\npar->beamcon0 = 0;\r\npar->hsstop = 1;\r\n} else if (amiga_vblank != 60) {\r\nDPRINTK("ntsc not supported by this chipset\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (IS_OCS) {\r\nif (par->diwstrt_h >= 1024 || par->diwstop_h < 1024 ||\r\npar->diwstrt_v >= 512 || par->diwstop_v < 256) {\r\nDPRINTK("invalid position for display on ocs\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n} else if (!IS_OCS) {\r\npar->hsstrt = var->right_margin << clk_shift;\r\npar->hsstop = (var->right_margin + var->hsync_len) << clk_shift;\r\npar->diwstop_h = par->htotal - mod8(par->hsstrt) + 8 - (1 << clk_shift);\r\nif (!IS_AGA)\r\npar->diwstop_h = down4(par->diwstop_h) - 16;\r\npar->diwstrt_h = par->diwstop_h - xres_n;\r\npar->hbstop = par->diwstrt_h + 4;\r\npar->hbstrt = par->diwstop_h + 4;\r\nif (par->hbstrt >= par->htotal + 8)\r\npar->hbstrt -= par->htotal;\r\npar->hcenter = par->hsstrt + (par->htotal >> 1);\r\npar->vsstrt = var->lower_margin << line_shift;\r\npar->vsstop = (var->lower_margin + var->vsync_len) << line_shift;\r\npar->diwstop_v = par->vtotal;\r\nif ((par->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\r\npar->diwstop_v -= 2;\r\npar->diwstrt_v = par->diwstop_v - yres_n;\r\npar->vbstop = par->diwstrt_v - 2;\r\npar->vbstrt = par->diwstop_v - 2;\r\nif (par->vtotal > 2048) {\r\nDPRINTK("vtotal too high\n");\r\nreturn -EINVAL;\r\n}\r\nif (par->htotal > 2048) {\r\nDPRINTK("htotal too high\n");\r\nreturn -EINVAL;\r\n}\r\npar->bplcon3 |= BPC3_EXTBLKEN;\r\npar->beamcon0 = BMC0_HARDDIS | BMC0_VARVBEN | BMC0_LOLDIS |\r\nBMC0_VARVSYEN | BMC0_VARHSYEN | BMC0_VARBEAMEN |\r\nBMC0_PAL | BMC0_VARCSYEN;\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT)\r\npar->beamcon0 |= BMC0_HSYTRUE;\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT)\r\npar->beamcon0 |= BMC0_VSYTRUE;\r\nif (var->sync & FB_SYNC_COMP_HIGH_ACT)\r\npar->beamcon0 |= BMC0_CSYTRUE;\r\nhtotal = par->htotal>>clk_shift;\r\nvtotal = par->vtotal>>1;\r\n} else {\r\nDPRINTK("only broadcast modes possible for ocs\n");\r\nreturn -EINVAL;\r\n}\r\nfconst = 16 << maxfmode << clk_shift;\r\nfsize = ((maxfmode + clk_shift <= 1) ? fconst : 64);\r\nfstrt = downx(fconst, par->diwstrt_h - 4) - fsize;\r\nif (fstrt < min_fstrt) {\r\nDPRINTK("fetch start too low\n");\r\nreturn -EINVAL;\r\n}\r\nfstrt = downx(fconst, par->diwstrt_h - fconst + (1 << clk_shift) - 4) -\r\nfsize;\r\nif (fstrt < min_fstrt)\r\npar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\r\nmaxfetchstop = down16(par->htotal - 80);\r\nfstrt = downx(fconst, par->diwstrt_h - 4) - 64 - fconst;\r\nfsize = upx(fconst, xres_n +\r\nmodx(fconst, downx(1 << clk_shift, par->diwstrt_h - 4)));\r\nif (fstrt + fsize > maxfetchstop)\r\npar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\r\nfsize = upx(fconst, xres_n);\r\nif (fstrt + fsize > maxfetchstop) {\r\nDPRINTK("fetch stop too high\n");\r\nreturn -EINVAL;\r\n}\r\nif (maxfmode + clk_shift <= 1) {\r\nfsize = up64(xres_n + fconst - 1);\r\nif (min_fstrt + fsize - 64 > maxfetchstop)\r\npar->vmode &= ~FB_VMODE_SMOOTH_XPAN;\r\nfsize = up64(xres_n);\r\nif (min_fstrt + fsize - 64 > maxfetchstop) {\r\nDPRINTK("fetch size too high\n");\r\nreturn -EINVAL;\r\n}\r\nfsize -= 64;\r\n} else\r\nfsize -= fconst;\r\nif (par->htotal - fsize - 64 < par->bpp * 64)\r\npar->vmode &= ~FB_VMODE_YWRAP;\r\nif (amifb_ilbm) {\r\npar->next_plane = div8(upx(16 << maxfmode, par->vxres));\r\npar->next_line = par->bpp * par->next_plane;\r\nif (par->next_line * par->vyres > info->fix.smem_len) {\r\nDPRINTK("too few video mem\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\npar->next_line = div8(upx(16 << maxfmode, par->vxres));\r\npar->next_plane = par->vyres * par->next_line;\r\nif (par->next_plane * par->bpp > info->fix.smem_len) {\r\nDPRINTK("too few video mem\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\npar->bplcon0 = BPC0_COLOR | bplpixmode[clk_shift];\r\nif (!IS_OCS)\r\npar->bplcon0 |= BPC0_ECSENA;\r\nif (par->bpp == 8)\r\npar->bplcon0 |= BPC0_BPU3;\r\nelse\r\npar->bplcon0 |= par->bpp << 12;\r\nif (var->nonstd == FB_NONSTD_HAM)\r\npar->bplcon0 |= BPC0_HAM;\r\nif (var->sync & FB_SYNC_EXT)\r\npar->bplcon0 |= BPC0_ERSY;\r\nif (IS_AGA)\r\npar->fmode = bplfetchmode[maxfmode];\r\nswitch (par->vmode & FB_VMODE_MASK) {\r\ncase FB_VMODE_INTERLACED:\r\npar->bplcon0 |= BPC0_LACE;\r\nbreak;\r\ncase FB_VMODE_DOUBLE:\r\nif (IS_AGA)\r\npar->fmode |= FMODE_SSCAN2 | FMODE_BSCAN2;\r\nbreak;\r\n}\r\nif (!((par->vmode ^ var->vmode) & FB_VMODE_YWRAP)) {\r\npar->xoffset = var->xoffset;\r\npar->yoffset = var->yoffset;\r\nif (par->vmode & FB_VMODE_YWRAP) {\r\nif (par->xoffset || par->yoffset < 0 ||\r\npar->yoffset >= par->vyres)\r\npar->xoffset = par->yoffset = 0;\r\n} else {\r\nif (par->xoffset < 0 ||\r\npar->xoffset > upx(16 << maxfmode, par->vxres - par->xres) ||\r\npar->yoffset < 0 || par->yoffset > par->vyres - par->yres)\r\npar->xoffset = par->yoffset = 0;\r\n}\r\n} else\r\npar->xoffset = par->yoffset = 0;\r\npar->crsr.crsr_x = par->crsr.crsr_y = 0;\r\npar->crsr.spot_x = par->crsr.spot_y = 0;\r\npar->crsr.height = par->crsr.width = 0;\r\nreturn 0;\r\n}\r\nstatic void ami_encode_var(struct fb_var_screeninfo *var,\r\nstruct amifb_par *par)\r\n{\r\nu_short clk_shift, line_shift;\r\nmemset(var, 0, sizeof(struct fb_var_screeninfo));\r\nclk_shift = par->clk_shift;\r\nline_shift = par->line_shift;\r\nvar->xres = par->xres;\r\nvar->yres = par->yres;\r\nvar->xres_virtual = par->vxres;\r\nvar->yres_virtual = par->vyres;\r\nvar->xoffset = par->xoffset;\r\nvar->yoffset = par->yoffset;\r\nvar->bits_per_pixel = par->bpp;\r\nvar->grayscale = 0;\r\nvar->red.offset = 0;\r\nvar->red.msb_right = 0;\r\nvar->red.length = par->bpp;\r\nif (par->bplcon0 & BPC0_HAM)\r\nvar->red.length -= 2;\r\nvar->blue = var->green = var->red;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nif (par->bplcon0 & BPC0_HAM)\r\nvar->nonstd = FB_NONSTD_HAM;\r\nelse\r\nvar->nonstd = 0;\r\nvar->activate = 0;\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->pixclock = pixclock[clk_shift];\r\nif (IS_AGA && par->fmode & FMODE_BSCAN2)\r\nvar->vmode = FB_VMODE_DOUBLE;\r\nelse if (par->bplcon0 & BPC0_LACE)\r\nvar->vmode = FB_VMODE_INTERLACED;\r\nelse\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nif (!IS_OCS && par->beamcon0 & BMC0_VARBEAMEN) {\r\nvar->hsync_len = (par->hsstop - par->hsstrt)>>clk_shift;\r\nvar->right_margin = par->hsstrt>>clk_shift;\r\nvar->left_margin = (par->htotal>>clk_shift) - var->xres - var->right_margin - var->hsync_len;\r\nvar->vsync_len = (par->vsstop - par->vsstrt)>>line_shift;\r\nvar->lower_margin = par->vsstrt>>line_shift;\r\nvar->upper_margin = (par->vtotal>>line_shift) - var->yres - var->lower_margin - var->vsync_len;\r\nvar->sync = 0;\r\nif (par->beamcon0 & BMC0_HSYTRUE)\r\nvar->sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (par->beamcon0 & BMC0_VSYTRUE)\r\nvar->sync |= FB_SYNC_VERT_HIGH_ACT;\r\nif (par->beamcon0 & BMC0_CSYTRUE)\r\nvar->sync |= FB_SYNC_COMP_HIGH_ACT;\r\n} else {\r\nvar->sync = FB_SYNC_BROADCAST;\r\nvar->hsync_len = (152>>clk_shift) + mod4(par->diwstop_h);\r\nvar->right_margin = ((par->htotal - down4(par->diwstop_h))>>clk_shift) + var->hsync_len;\r\nvar->left_margin = (par->htotal>>clk_shift) - var->xres - var->right_margin - var->hsync_len;\r\nvar->vsync_len = 4>>line_shift;\r\nvar->lower_margin = ((par->vtotal - par->diwstop_v)>>line_shift) + var->vsync_len;\r\nvar->upper_margin = (((par->vtotal - 2)>>line_shift) + 1) - var->yres -\r\nvar->lower_margin - var->vsync_len;\r\n}\r\nif (par->bplcon0 & BPC0_ERSY)\r\nvar->sync |= FB_SYNC_EXT;\r\nif (par->vmode & FB_VMODE_YWRAP)\r\nvar->vmode |= FB_VMODE_YWRAP;\r\n}\r\nstatic void ami_update_par(struct fb_info *info)\r\n{\r\nstruct amifb_par *par = info->par;\r\nshort clk_shift, vshift, fstrt, fsize, fstop, fconst, shift, move, mod;\r\nclk_shift = par->clk_shift;\r\nif (!(par->vmode & FB_VMODE_SMOOTH_XPAN))\r\npar->xoffset = upx(16 << maxfmode, par->xoffset);\r\nfconst = 16 << maxfmode << clk_shift;\r\nvshift = modx(16 << maxfmode, par->xoffset);\r\nfstrt = par->diwstrt_h - (vshift << clk_shift) - 4;\r\nfsize = (par->xres + vshift) << clk_shift;\r\nshift = modx(fconst, fstrt);\r\nmove = downx(2 << maxfmode, div8(par->xoffset));\r\nif (maxfmode + clk_shift > 1) {\r\nfstrt = downx(fconst, fstrt) - 64;\r\nfsize = upx(fconst, fsize);\r\nfstop = fstrt + fsize - fconst;\r\n} else {\r\nmod = fstrt = downx(fconst, fstrt) - fconst;\r\nfstop = fstrt + upx(fconst, fsize) - 64;\r\nfsize = up64(fsize);\r\nfstrt = fstop - fsize + 64;\r\nif (fstrt < min_fstrt) {\r\nfstop += min_fstrt - fstrt;\r\nfstrt = min_fstrt;\r\n}\r\nmove = move - div8((mod - fstrt)>>clk_shift);\r\n}\r\nmod = par->next_line - div8(fsize>>clk_shift);\r\npar->ddfstrt = fstrt;\r\npar->ddfstop = fstop;\r\npar->bplcon1 = hscroll2hw(shift);\r\npar->bpl2mod = mod;\r\nif (par->bplcon0 & BPC0_LACE)\r\npar->bpl2mod += par->next_line;\r\nif (IS_AGA && (par->fmode & FMODE_BSCAN2))\r\npar->bpl1mod = -div8(fsize>>clk_shift);\r\nelse\r\npar->bpl1mod = par->bpl2mod;\r\nif (par->yoffset) {\r\npar->bplpt0 = info->fix.smem_start +\r\npar->next_line * par->yoffset + move;\r\nif (par->vmode & FB_VMODE_YWRAP) {\r\nif (par->yoffset > par->vyres - par->yres) {\r\npar->bplpt0wrap = info->fix.smem_start + move;\r\nif (par->bplcon0 & BPC0_LACE &&\r\nmod2(par->diwstrt_v + par->vyres -\r\npar->yoffset))\r\npar->bplpt0wrap += par->next_line;\r\n}\r\n}\r\n} else\r\npar->bplpt0 = info->fix.smem_start + move;\r\nif (par->bplcon0 & BPC0_LACE && mod2(par->diwstrt_v))\r\npar->bplpt0 += par->next_line;\r\n}\r\nstatic void ami_pan_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct amifb_par *par = info->par;\r\npar->xoffset = var->xoffset;\r\npar->yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\npar->vmode |= FB_VMODE_YWRAP;\r\nelse\r\npar->vmode &= ~FB_VMODE_YWRAP;\r\ndo_vmode_pan = 0;\r\nami_update_par(info);\r\ndo_vmode_pan = 1;\r\n}\r\nstatic void ami_update_display(const struct amifb_par *par)\r\n{\r\ncustom.bplcon1 = par->bplcon1;\r\ncustom.bpl1mod = par->bpl1mod;\r\ncustom.bpl2mod = par->bpl2mod;\r\ncustom.ddfstrt = ddfstrt2hw(par->ddfstrt);\r\ncustom.ddfstop = ddfstop2hw(par->ddfstop);\r\n}\r\nstatic void ami_init_display(const struct amifb_par *par)\r\n{\r\nint i;\r\ncustom.bplcon0 = par->bplcon0 & ~BPC0_LACE;\r\ncustom.bplcon2 = (IS_OCS ? 0 : BPC2_KILLEHB) | BPC2_PF2P2 | BPC2_PF1P2;\r\nif (!IS_OCS) {\r\ncustom.bplcon3 = par->bplcon3;\r\nif (IS_AGA)\r\ncustom.bplcon4 = BPC4_ESPRM4 | BPC4_OSPRM4;\r\nif (par->beamcon0 & BMC0_VARBEAMEN) {\r\ncustom.htotal = htotal2hw(par->htotal);\r\ncustom.hbstrt = hbstrt2hw(par->hbstrt);\r\ncustom.hbstop = hbstop2hw(par->hbstop);\r\ncustom.hsstrt = hsstrt2hw(par->hsstrt);\r\ncustom.hsstop = hsstop2hw(par->hsstop);\r\ncustom.hcenter = hcenter2hw(par->hcenter);\r\ncustom.vtotal = vtotal2hw(par->vtotal);\r\ncustom.vbstrt = vbstrt2hw(par->vbstrt);\r\ncustom.vbstop = vbstop2hw(par->vbstop);\r\ncustom.vsstrt = vsstrt2hw(par->vsstrt);\r\ncustom.vsstop = vsstop2hw(par->vsstop);\r\n}\r\n}\r\nif (!IS_OCS || par->hsstop)\r\ncustom.beamcon0 = par->beamcon0;\r\nif (IS_AGA)\r\ncustom.fmode = par->fmode;\r\namiga_audio_min_period = div16(par->htotal);\r\nis_lace = par->bplcon0 & BPC0_LACE ? 1 : 0;\r\n#if 1\r\nif (is_lace) {\r\ni = custom.vposr >> 15;\r\n} else {\r\ncustom.vposw = custom.vposr | 0x8000;\r\ni = 1;\r\n}\r\n#else\r\ni = 1;\r\ncustom.vposw = custom.vposr | 0x8000;\r\n#endif\r\ncustom.cop2lc = (u_short *)ZTWO_PADDR(copdisplay.list[currentcop][i]);\r\n}\r\nstatic void ami_do_blank(const struct amifb_par *par)\r\n{\r\n#if defined(CONFIG_FB_AMIGA_AGA)\r\nu_short bplcon3 = par->bplcon3;\r\n#endif\r\nu_char red, green, blue;\r\nif (do_blank > 0) {\r\ncustom.dmacon = DMAF_RASTER | DMAF_SPRITE;\r\nred = green = blue = 0;\r\nif (!IS_OCS && do_blank > 1) {\r\nswitch (do_blank) {\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncustom.hsstrt = hsstrt2hw(par->hsstrt);\r\ncustom.hsstop = hsstop2hw(par->hsstop);\r\ncustom.vsstrt = vsstrt2hw(par->vtotal + 4);\r\ncustom.vsstop = vsstop2hw(par->vtotal + 4);\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncustom.hsstrt = hsstrt2hw(par->htotal + 16);\r\ncustom.hsstop = hsstop2hw(par->htotal + 16);\r\ncustom.vsstrt = vsstrt2hw(par->vsstrt);\r\ncustom.vsstop = vsstrt2hw(par->vsstop);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\ncustom.hsstrt = hsstrt2hw(par->htotal + 16);\r\ncustom.hsstop = hsstop2hw(par->htotal + 16);\r\ncustom.vsstrt = vsstrt2hw(par->vtotal + 4);\r\ncustom.vsstop = vsstop2hw(par->vtotal + 4);\r\nbreak;\r\n}\r\nif (!(par->beamcon0 & BMC0_VARBEAMEN)) {\r\ncustom.htotal = htotal2hw(par->htotal);\r\ncustom.vtotal = vtotal2hw(par->vtotal);\r\ncustom.beamcon0 = BMC0_HARDDIS | BMC0_VARBEAMEN |\r\nBMC0_VARVSYEN | BMC0_VARHSYEN | BMC0_VARCSYEN;\r\n}\r\n}\r\n} else {\r\ncustom.dmacon = DMAF_SETCLR | DMAF_RASTER | DMAF_SPRITE;\r\nred = red0;\r\ngreen = green0;\r\nblue = blue0;\r\nif (!IS_OCS) {\r\ncustom.hsstrt = hsstrt2hw(par->hsstrt);\r\ncustom.hsstop = hsstop2hw(par->hsstop);\r\ncustom.vsstrt = vsstrt2hw(par->vsstrt);\r\ncustom.vsstop = vsstop2hw(par->vsstop);\r\ncustom.beamcon0 = par->beamcon0;\r\n}\r\n}\r\n#if defined(CONFIG_FB_AMIGA_AGA)\r\nif (IS_AGA) {\r\ncustom.bplcon3 = bplcon3;\r\ncustom.color[0] = rgb2hw8_high(red, green, blue);\r\ncustom.bplcon3 = bplcon3 | BPC3_LOCT;\r\ncustom.color[0] = rgb2hw8_low(red, green, blue);\r\ncustom.bplcon3 = bplcon3;\r\n} else\r\n#endif\r\n#if defined(CONFIG_FB_AMIGA_ECS)\r\nif (par->bplcon0 & BPC0_SHRES) {\r\nu_short color, mask;\r\nint i;\r\nmask = 0x3333;\r\ncolor = rgb2hw2(red, green, blue);\r\nfor (i = 12; i >= 0; i -= 4)\r\ncustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\r\nmask <<= 2; color >>= 2;\r\nfor (i = 3; i >= 0; i--)\r\ncustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\r\n} else\r\n#endif\r\ncustom.color[0] = rgb2hw4(red, green, blue);\r\nis_blanked = do_blank > 0 ? do_blank : 0;\r\n}\r\nstatic int ami_get_fix_cursorinfo(struct fb_fix_cursorinfo *fix,\r\nconst struct amifb_par *par)\r\n{\r\nfix->crsr_width = fix->crsr_xsize = par->crsr.width;\r\nfix->crsr_height = fix->crsr_ysize = par->crsr.height;\r\nfix->crsr_color1 = 17;\r\nfix->crsr_color2 = 18;\r\nreturn 0;\r\n}\r\nstatic int ami_get_var_cursorinfo(struct fb_var_cursorinfo *var,\r\nu_char __user *data,\r\nconst struct amifb_par *par)\r\n{\r\nregister u_short *lspr, *sspr;\r\n#ifdef __mc68000__\r\nregister u_long datawords asm ("d2");\r\n#else\r\nregister u_long datawords;\r\n#endif\r\nregister short delta;\r\nregister u_char color;\r\nshort height, width, bits, words;\r\nint size, alloc;\r\nsize = par->crsr.height * par->crsr.width;\r\nalloc = var->height * var->width;\r\nvar->height = par->crsr.height;\r\nvar->width = par->crsr.width;\r\nvar->xspot = par->crsr.spot_x;\r\nvar->yspot = par->crsr.spot_y;\r\nif (size > var->height * var->width)\r\nreturn -ENAMETOOLONG;\r\nif (!access_ok(VERIFY_WRITE, data, size))\r\nreturn -EFAULT;\r\ndelta = 1 << par->crsr.fmode;\r\nlspr = lofsprite + (delta << 1);\r\nif (par->bplcon0 & BPC0_LACE)\r\nsspr = shfsprite + (delta << 1);\r\nelse\r\nsspr = NULL;\r\nfor (height = (short)var->height - 1; height >= 0; height--) {\r\nbits = 0; words = delta; datawords = 0;\r\nfor (width = (short)var->width - 1; width >= 0; width--) {\r\nif (bits == 0) {\r\nbits = 16; --words;\r\n#ifdef __mc68000__\r\nasm volatile ("movew %1@(%3:w:2),%0 ; swap %0 ; movew %1@+,%0"\r\n: "=d" (datawords), "=a" (lspr) : "1" (lspr), "d" (delta));\r\n#else\r\ndatawords = (*(lspr + delta) << 16) | (*lspr++);\r\n#endif\r\n}\r\n--bits;\r\n#ifdef __mc68000__\r\nasm volatile (\r\n"clrb %0 ; swap %1 ; lslw #1,%1 ; roxlb #1,%0 ; "\r\n"swap %1 ; lslw #1,%1 ; roxlb #1,%0"\r\n: "=d" (color), "=d" (datawords) : "1" (datawords));\r\n#else\r\ncolor = (((datawords >> 30) & 2)\r\n| ((datawords >> 15) & 1));\r\ndatawords <<= 1;\r\n#endif\r\nput_user(color, data++);\r\n}\r\nif (bits > 0) {\r\n--words; ++lspr;\r\n}\r\nwhile (--words >= 0)\r\n++lspr;\r\n#ifdef __mc68000__\r\nasm volatile ("lea %0@(%4:w:2),%0 ; tstl %1 ; jeq 1f ; exg %0,%1\n1:"\r\n: "=a" (lspr), "=a" (sspr) : "0" (lspr), "1" (sspr), "d" (delta));\r\n#else\r\nlspr += delta;\r\nif (sspr) {\r\nu_short *tmp = lspr;\r\nlspr = sspr;\r\nsspr = tmp;\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int ami_set_var_cursorinfo(struct fb_var_cursorinfo *var,\r\nu_char __user *data, struct amifb_par *par)\r\n{\r\nregister u_short *lspr, *sspr;\r\n#ifdef __mc68000__\r\nregister u_long datawords asm ("d2");\r\n#else\r\nregister u_long datawords;\r\n#endif\r\nregister short delta;\r\nu_short fmode;\r\nshort height, width, bits, words;\r\nif (!var->width)\r\nreturn -EINVAL;\r\nelse if (var->width <= 16)\r\nfmode = TAG_FMODE_1;\r\nelse if (var->width <= 32)\r\nfmode = TAG_FMODE_2;\r\nelse if (var->width <= 64)\r\nfmode = TAG_FMODE_4;\r\nelse\r\nreturn -EINVAL;\r\nif (fmode > maxfmode)\r\nreturn -EINVAL;\r\nif (!var->height)\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_READ, data, var->width * var->height))\r\nreturn -EFAULT;\r\ndelta = 1 << fmode;\r\nlofsprite = shfsprite = (u_short *)spritememory;\r\nlspr = lofsprite + (delta << 1);\r\nif (par->bplcon0 & BPC0_LACE) {\r\nif (((var->height + 4) << fmode << 2) > SPRITEMEMSIZE)\r\nreturn -EINVAL;\r\nmemset(lspr, 0, (var->height + 4) << fmode << 2);\r\nshfsprite += ((var->height + 5)&-2) << fmode;\r\nsspr = shfsprite + (delta << 1);\r\n} else {\r\nif (((var->height + 2) << fmode << 2) > SPRITEMEMSIZE)\r\nreturn -EINVAL;\r\nmemset(lspr, 0, (var->height + 2) << fmode << 2);\r\nsspr = NULL;\r\n}\r\nfor (height = (short)var->height - 1; height >= 0; height--) {\r\nbits = 16; words = delta; datawords = 0;\r\nfor (width = (short)var->width - 1; width >= 0; width--) {\r\nunsigned long tdata = 0;\r\nget_user(tdata, data);\r\ndata++;\r\n#ifdef __mc68000__\r\nasm volatile (\r\n"lsrb #1,%2 ; roxlw #1,%0 ; swap %0 ; "\r\n"lsrb #1,%2 ; roxlw #1,%0 ; swap %0"\r\n: "=d" (datawords)\r\n: "0" (datawords), "d" (tdata));\r\n#else\r\ndatawords = ((datawords << 1) & 0xfffefffe);\r\ndatawords |= tdata & 1;\r\ndatawords |= (tdata & 2) << (16 - 1);\r\n#endif\r\nif (--bits == 0) {\r\nbits = 16; --words;\r\n#ifdef __mc68000__\r\nasm volatile ("swap %2 ; movew %2,%0@(%3:w:2) ; swap %2 ; movew %2,%0@+"\r\n: "=a" (lspr) : "0" (lspr), "d" (datawords), "d" (delta));\r\n#else\r\n*(lspr + delta) = (u_short) (datawords >> 16);\r\n*lspr++ = (u_short) (datawords & 0xffff);\r\n#endif\r\n}\r\n}\r\nif (bits < 16) {\r\n--words;\r\n#ifdef __mc68000__\r\nasm volatile (\r\n"swap %2 ; lslw %4,%2 ; movew %2,%0@(%3:w:2) ; "\r\n"swap %2 ; lslw %4,%2 ; movew %2,%0@+"\r\n: "=a" (lspr) : "0" (lspr), "d" (datawords), "d" (delta), "d" (bits));\r\n#else\r\n*(lspr + delta) = (u_short) (datawords >> (16 + bits));\r\n*lspr++ = (u_short) ((datawords & 0x0000ffff) >> bits);\r\n#endif\r\n}\r\nwhile (--words >= 0) {\r\n#ifdef __mc68000__\r\nasm volatile ("moveql #0,%%d0 ; movew %%d0,%0@(%2:w:2) ; movew %%d0,%0@+"\r\n: "=a" (lspr) : "0" (lspr), "d" (delta) : "d0");\r\n#else\r\n*(lspr + delta) = 0;\r\n*lspr++ = 0;\r\n#endif\r\n}\r\n#ifdef __mc68000__\r\nasm volatile ("lea %0@(%4:w:2),%0 ; tstl %1 ; jeq 1f ; exg %0,%1\n1:"\r\n: "=a" (lspr), "=a" (sspr) : "0" (lspr), "1" (sspr), "d" (delta));\r\n#else\r\nlspr += delta;\r\nif (sspr) {\r\nu_short *tmp = lspr;\r\nlspr = sspr;\r\nsspr = tmp;\r\n}\r\n#endif\r\n}\r\npar->crsr.height = var->height;\r\npar->crsr.width = var->width;\r\npar->crsr.spot_x = var->xspot;\r\npar->crsr.spot_y = var->yspot;\r\npar->crsr.fmode = fmode;\r\nif (IS_AGA) {\r\npar->fmode &= ~(FMODE_SPAGEM | FMODE_SPR32);\r\npar->fmode |= sprfetchmode[fmode];\r\ncustom.fmode = par->fmode;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ami_get_cursorstate(struct fb_cursorstate *state,\r\nconst struct amifb_par *par)\r\n{\r\nstate->xoffset = par->crsr.crsr_x;\r\nstate->yoffset = par->crsr.crsr_y;\r\nstate->mode = cursormode;\r\nreturn 0;\r\n}\r\nstatic int ami_set_cursorstate(struct fb_cursorstate *state,\r\nstruct amifb_par *par)\r\n{\r\npar->crsr.crsr_x = state->xoffset;\r\npar->crsr.crsr_y = state->yoffset;\r\nif ((cursormode = state->mode) == FB_CURSOR_OFF)\r\ncursorstate = -1;\r\ndo_cursor = 1;\r\nreturn 0;\r\n}\r\nstatic void ami_set_sprite(const struct amifb_par *par)\r\n{\r\ncopins *copl, *cops;\r\nu_short hs, vs, ve;\r\nu_long pl, ps, pt;\r\nshort mx, my;\r\ncops = copdisplay.list[currentcop][0];\r\ncopl = copdisplay.list[currentcop][1];\r\nps = pl = ZTWO_PADDR(dummysprite);\r\nmx = par->crsr.crsr_x - par->crsr.spot_x;\r\nmy = par->crsr.crsr_y - par->crsr.spot_y;\r\nif (!(par->vmode & FB_VMODE_YWRAP)) {\r\nmx -= par->xoffset;\r\nmy -= par->yoffset;\r\n}\r\nif (!is_blanked && cursorstate > 0 && par->crsr.height > 0 &&\r\nmx > -(short)par->crsr.width && mx < par->xres &&\r\nmy > -(short)par->crsr.height && my < par->yres) {\r\npl = ZTWO_PADDR(lofsprite);\r\nhs = par->diwstrt_h + (mx << par->clk_shift) - 4;\r\nvs = par->diwstrt_v + (my << par->line_shift);\r\nve = vs + (par->crsr.height << par->line_shift);\r\nif (par->bplcon0 & BPC0_LACE) {\r\nps = ZTWO_PADDR(shfsprite);\r\nlofsprite[0] = spr2hw_pos(vs, hs);\r\nshfsprite[0] = spr2hw_pos(vs + 1, hs);\r\nif (mod2(vs)) {\r\nlofsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs, hs, ve);\r\nshfsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs + 1, hs, ve + 1);\r\npt = pl; pl = ps; ps = pt;\r\n} else {\r\nlofsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs, hs, ve + 1);\r\nshfsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs + 1, hs, ve);\r\n}\r\n} else {\r\nlofsprite[0] = spr2hw_pos(vs, hs) | (IS_AGA && (par->fmode & FMODE_BSCAN2) ? 0x80 : 0);\r\nlofsprite[1 << par->crsr.fmode] = spr2hw_ctl(vs, hs, ve);\r\n}\r\n}\r\ncopl[cop_spr0ptrh].w[1] = highw(pl);\r\ncopl[cop_spr0ptrl].w[1] = loww(pl);\r\nif (par->bplcon0 & BPC0_LACE) {\r\ncops[cop_spr0ptrh].w[1] = highw(ps);\r\ncops[cop_spr0ptrl].w[1] = loww(ps);\r\n}\r\n}\r\nstatic void __init ami_init_copper(void)\r\n{\r\ncopins *cop = copdisplay.init;\r\nu_long p;\r\nint i;\r\nif (!IS_OCS) {\r\n(cop++)->l = CMOVE(BPC0_COLOR | BPC0_SHRES | BPC0_ECSENA, bplcon0);\r\n(cop++)->l = CMOVE(0x0181, diwstrt);\r\n(cop++)->l = CMOVE(0x0281, diwstop);\r\n(cop++)->l = CMOVE(0x0000, diwhigh);\r\n} else\r\n(cop++)->l = CMOVE(BPC0_COLOR, bplcon0);\r\np = ZTWO_PADDR(dummysprite);\r\nfor (i = 0; i < 8; i++) {\r\n(cop++)->l = CMOVE(0, spr[i].pos);\r\n(cop++)->l = CMOVE(highw(p), sprpt[i]);\r\n(cop++)->l = CMOVE2(loww(p), sprpt[i]);\r\n}\r\n(cop++)->l = CMOVE(IF_SETCLR | IF_COPER, intreq);\r\ncopdisplay.wait = cop;\r\n(cop++)->l = CEND;\r\n(cop++)->l = CMOVE(0, copjmp2);\r\ncop->l = CEND;\r\ncustom.cop1lc = (u_short *)ZTWO_PADDR(copdisplay.init);\r\ncustom.copjmp1 = 0;\r\n}\r\nstatic void ami_reinit_copper(const struct amifb_par *par)\r\n{\r\ncopdisplay.init[cip_bplcon0].w[1] = ~(BPC0_BPU3 | BPC0_BPU2 | BPC0_BPU1 | BPC0_BPU0) & par->bplcon0;\r\ncopdisplay.wait->l = CWAIT(32, par->diwstrt_v - 4);\r\n}\r\nstatic void ami_rebuild_copper(const struct amifb_par *par)\r\n{\r\ncopins *copl, *cops;\r\nu_short line, h_end1, h_end2;\r\nshort i;\r\nu_long p;\r\nif (IS_AGA && maxfmode + par->clk_shift == 0)\r\nh_end1 = par->diwstrt_h - 64;\r\nelse\r\nh_end1 = par->htotal - 32;\r\nh_end2 = par->ddfstop + 64;\r\nami_set_sprite(par);\r\ncopl = copdisplay.rebuild[1];\r\np = par->bplpt0;\r\nif (par->vmode & FB_VMODE_YWRAP) {\r\nif ((par->vyres - par->yoffset) != 1 || !mod2(par->diwstrt_v)) {\r\nif (par->yoffset > par->vyres - par->yres) {\r\nfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\r\n(copl++)->l = CMOVE(highw(p), bplpt[i]);\r\n(copl++)->l = CMOVE2(loww(p), bplpt[i]);\r\n}\r\nline = par->diwstrt_v + ((par->vyres - par->yoffset) << par->line_shift) - 1;\r\nwhile (line >= 512) {\r\n(copl++)->l = CWAIT(h_end1, 510);\r\nline -= 512;\r\n}\r\nif (line >= 510 && IS_AGA && maxfmode + par->clk_shift == 0)\r\n(copl++)->l = CWAIT(h_end1, line);\r\nelse\r\n(copl++)->l = CWAIT(h_end2, line);\r\np = par->bplpt0wrap;\r\n}\r\n} else\r\np = par->bplpt0wrap;\r\n}\r\nfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\r\n(copl++)->l = CMOVE(highw(p), bplpt[i]);\r\n(copl++)->l = CMOVE2(loww(p), bplpt[i]);\r\n}\r\ncopl->l = CEND;\r\nif (par->bplcon0 & BPC0_LACE) {\r\ncops = copdisplay.rebuild[0];\r\np = par->bplpt0;\r\nif (mod2(par->diwstrt_v))\r\np -= par->next_line;\r\nelse\r\np += par->next_line;\r\nif (par->vmode & FB_VMODE_YWRAP) {\r\nif ((par->vyres - par->yoffset) != 1 || mod2(par->diwstrt_v)) {\r\nif (par->yoffset > par->vyres - par->yres + 1) {\r\nfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\r\n(cops++)->l = CMOVE(highw(p), bplpt[i]);\r\n(cops++)->l = CMOVE2(loww(p), bplpt[i]);\r\n}\r\nline = par->diwstrt_v + ((par->vyres - par->yoffset) << par->line_shift) - 2;\r\nwhile (line >= 512) {\r\n(cops++)->l = CWAIT(h_end1, 510);\r\nline -= 512;\r\n}\r\nif (line > 510 && IS_AGA && maxfmode + par->clk_shift == 0)\r\n(cops++)->l = CWAIT(h_end1, line);\r\nelse\r\n(cops++)->l = CWAIT(h_end2, line);\r\np = par->bplpt0wrap;\r\nif (mod2(par->diwstrt_v + par->vyres -\r\npar->yoffset))\r\np -= par->next_line;\r\nelse\r\np += par->next_line;\r\n}\r\n} else\r\np = par->bplpt0wrap - par->next_line;\r\n}\r\nfor (i = 0; i < (short)par->bpp; i++, p += par->next_plane) {\r\n(cops++)->l = CMOVE(highw(p), bplpt[i]);\r\n(cops++)->l = CMOVE2(loww(p), bplpt[i]);\r\n}\r\ncops->l = CEND;\r\n}\r\n}\r\nstatic void ami_build_copper(struct fb_info *info)\r\n{\r\nstruct amifb_par *par = info->par;\r\ncopins *copl, *cops;\r\nu_long p;\r\ncurrentcop = 1 - currentcop;\r\ncopl = copdisplay.list[currentcop][1];\r\n(copl++)->l = CWAIT(0, 10);\r\n(copl++)->l = CMOVE(par->bplcon0, bplcon0);\r\n(copl++)->l = CMOVE(0, sprpt[0]);\r\n(copl++)->l = CMOVE2(0, sprpt[0]);\r\nif (par->bplcon0 & BPC0_LACE) {\r\ncops = copdisplay.list[currentcop][0];\r\n(cops++)->l = CWAIT(0, 10);\r\n(cops++)->l = CMOVE(par->bplcon0, bplcon0);\r\n(cops++)->l = CMOVE(0, sprpt[0]);\r\n(cops++)->l = CMOVE2(0, sprpt[0]);\r\n(copl++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v + 1), diwstrt);\r\n(copl++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v + 1), diwstop);\r\n(cops++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v), diwstrt);\r\n(cops++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v), diwstop);\r\nif (!IS_OCS) {\r\n(copl++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v + 1,\r\npar->diwstop_h, par->diwstop_v + 1), diwhigh);\r\n(cops++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v,\r\npar->diwstop_h, par->diwstop_v), diwhigh);\r\n#if 0\r\nif (par->beamcon0 & BMC0_VARBEAMEN) {\r\n(copl++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\r\n(copl++)->l = CMOVE(vbstrt2hw(par->vbstrt + 1), vbstrt);\r\n(copl++)->l = CMOVE(vbstop2hw(par->vbstop + 1), vbstop);\r\n(cops++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\r\n(cops++)->l = CMOVE(vbstrt2hw(par->vbstrt), vbstrt);\r\n(cops++)->l = CMOVE(vbstop2hw(par->vbstop), vbstop);\r\n}\r\n#endif\r\n}\r\np = ZTWO_PADDR(copdisplay.list[currentcop][0]);\r\n(copl++)->l = CMOVE(highw(p), cop2lc);\r\n(copl++)->l = CMOVE2(loww(p), cop2lc);\r\np = ZTWO_PADDR(copdisplay.list[currentcop][1]);\r\n(cops++)->l = CMOVE(highw(p), cop2lc);\r\n(cops++)->l = CMOVE2(loww(p), cop2lc);\r\ncopdisplay.rebuild[0] = cops;\r\n} else {\r\n(copl++)->l = CMOVE(diwstrt2hw(par->diwstrt_h, par->diwstrt_v), diwstrt);\r\n(copl++)->l = CMOVE(diwstop2hw(par->diwstop_h, par->diwstop_v), diwstop);\r\nif (!IS_OCS) {\r\n(copl++)->l = CMOVE(diwhigh2hw(par->diwstrt_h, par->diwstrt_v,\r\npar->diwstop_h, par->diwstop_v), diwhigh);\r\n#if 0\r\nif (par->beamcon0 & BMC0_VARBEAMEN) {\r\n(copl++)->l = CMOVE(vtotal2hw(par->vtotal), vtotal);\r\n(copl++)->l = CMOVE(vbstrt2hw(par->vbstrt), vbstrt);\r\n(copl++)->l = CMOVE(vbstop2hw(par->vbstop), vbstop);\r\n}\r\n#endif\r\n}\r\n}\r\ncopdisplay.rebuild[1] = copl;\r\nami_update_par(info);\r\nami_rebuild_copper(info->par);\r\n}\r\nstatic void __init amifb_setup_mcap(char *spec)\r\n{\r\nchar *p;\r\nint vmin, vmax, hmin, hmax;\r\nif (!(p = strsep(&spec, ";")) || !*p)\r\nreturn;\r\nvmin = simple_strtoul(p, NULL, 10);\r\nif (vmin <= 0)\r\nreturn;\r\nif (!(p = strsep(&spec, ";")) || !*p)\r\nreturn;\r\nvmax = simple_strtoul(p, NULL, 10);\r\nif (vmax <= 0 || vmax <= vmin)\r\nreturn;\r\nif (!(p = strsep(&spec, ";")) || !*p)\r\nreturn;\r\nhmin = 1000 * simple_strtoul(p, NULL, 10);\r\nif (hmin <= 0)\r\nreturn;\r\nif (!(p = strsep(&spec, "")) || !*p)\r\nreturn;\r\nhmax = 1000 * simple_strtoul(p, NULL, 10);\r\nif (hmax <= 0 || hmax <= hmin)\r\nreturn;\r\namifb_hfmin = hmin;\r\namifb_hfmax = hmax;\r\namifb_vfmin = vmin;\r\namifb_vfmax = vmax;\r\n}\r\nstatic int __init amifb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strcmp(this_opt, "inverse")) {\r\nfb_invert_cmaps();\r\n} else if (!strcmp(this_opt, "ilbm"))\r\namifb_ilbm = 1;\r\nelse if (!strncmp(this_opt, "monitorcap:", 11))\r\namifb_setup_mcap(this_opt + 11);\r\nelse if (!strncmp(this_opt, "fstart:", 7))\r\nmin_fstrt = simple_strtoul(this_opt + 7, NULL, 0);\r\nelse\r\nmode_option = this_opt;\r\n}\r\nif (min_fstrt < 48)\r\nmin_fstrt = 48;\r\nreturn 0;\r\n}\r\nstatic int amifb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint err;\r\nstruct amifb_par par;\r\nerr = ami_decode_var(var, &par, info);\r\nif (err)\r\nreturn err;\r\nami_encode_var(var, &par);\r\nreturn 0;\r\n}\r\nstatic int amifb_set_par(struct fb_info *info)\r\n{\r\nstruct amifb_par *par = info->par;\r\nint error;\r\ndo_vmode_pan = 0;\r\ndo_vmode_full = 0;\r\nerror = ami_decode_var(&info->var, par, info);\r\nif (error)\r\nreturn error;\r\nami_build_copper(info);\r\ndo_vmode_full = 1;\r\nif (par->bpp == 1) {\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\n} else if (amifb_ilbm) {\r\ninfo->fix.type = FB_TYPE_INTERLEAVED_PLANES;\r\ninfo->fix.type_aux = par->next_line;\r\n} else {\r\ninfo->fix.type = FB_TYPE_PLANES;\r\ninfo->fix.type_aux = 0;\r\n}\r\ninfo->fix.line_length = div8(upx(16 << maxfmode, par->vxres));\r\nif (par->vmode & FB_VMODE_YWRAP) {\r\ninfo->fix.ywrapstep = 1;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YWRAP |\r\nFBINFO_READS_FAST;\r\n} else {\r\ninfo->fix.ywrapstep = 0;\r\nif (par->vmode & FB_VMODE_SMOOTH_XPAN)\r\ninfo->fix.xpanstep = 1;\r\nelse\r\ninfo->fix.xpanstep = 16 << maxfmode;\r\ninfo->fix.ypanstep = 1;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amifb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nconst struct amifb_par *par = info->par;\r\nif (IS_AGA) {\r\nif (regno > 255)\r\nreturn 1;\r\n} else if (par->bplcon0 & BPC0_SHRES) {\r\nif (regno > 3)\r\nreturn 1;\r\n} else {\r\nif (regno > 31)\r\nreturn 1;\r\n}\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nif (!regno) {\r\nred0 = red;\r\ngreen0 = green;\r\nblue0 = blue;\r\n}\r\nif (regno || !is_blanked) {\r\n#if defined(CONFIG_FB_AMIGA_AGA)\r\nif (IS_AGA) {\r\nu_short bplcon3 = par->bplcon3;\r\nVBlankOff();\r\ncustom.bplcon3 = bplcon3 | (regno << 8 & 0xe000);\r\ncustom.color[regno & 31] = rgb2hw8_high(red, green,\r\nblue);\r\ncustom.bplcon3 = bplcon3 | (regno << 8 & 0xe000) |\r\nBPC3_LOCT;\r\ncustom.color[regno & 31] = rgb2hw8_low(red, green,\r\nblue);\r\ncustom.bplcon3 = bplcon3;\r\nVBlankOn();\r\n} else\r\n#endif\r\n#if defined(CONFIG_FB_AMIGA_ECS)\r\nif (par->bplcon0 & BPC0_SHRES) {\r\nu_short color, mask;\r\nint i;\r\nmask = 0x3333;\r\ncolor = rgb2hw2(red, green, blue);\r\nVBlankOff();\r\nfor (i = regno + 12; i >= (int)regno; i -= 4)\r\ncustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\r\nmask <<= 2; color >>= 2;\r\nregno = down16(regno) + mul4(mod4(regno));\r\nfor (i = regno + 3; i >= (int)regno; i--)\r\ncustom.color[i] = ecs_palette[i] = (ecs_palette[i] & mask) | color;\r\nVBlankOn();\r\n} else\r\n#endif\r\ncustom.color[regno] = rgb2hw4(red, green, blue);\r\n}\r\nreturn 0;\r\n}\r\nstatic int amifb_blank(int blank, struct fb_info *info)\r\n{\r\ndo_blank = blank ? blank : -1;\r\nreturn 0;\r\n}\r\nstatic int amifb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (var->yoffset < 0 ||\r\nvar->yoffset >= info->var.yres_virtual || var->xoffset)\r\nreturn -EINVAL;\r\n} else {\r\nif (var->xoffset + info->var.xres >\r\nupx(16 << maxfmode, info->var.xres_virtual) ||\r\nvar->yoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\n}\r\nami_pan_var(var, info);\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nreturn 0;\r\n}\r\nstatic inline unsigned long comp(unsigned long a, unsigned long b,\r\nunsigned long mask)\r\n{\r\nreturn ((a ^ b) & mask) ^ b;\r\n}\r\nstatic inline unsigned long xor(unsigned long a, unsigned long b,\r\nunsigned long mask)\r\n{\r\nreturn (a & mask) ^ b;\r\n}\r\nstatic void bitcpy(unsigned long *dst, int dst_idx, const unsigned long *src,\r\nint src_idx, u32 n)\r\n{\r\nunsigned long first, last;\r\nint shift = dst_idx - src_idx, left, right;\r\nunsigned long d0, d1;\r\nint m;\r\nif (!n)\r\nreturn;\r\nshift = dst_idx - src_idx;\r\nfirst = ~0UL >> dst_idx;\r\nlast = ~(~0UL >> ((dst_idx + n) % BITS_PER_LONG));\r\nif (!shift) {\r\nif (dst_idx + n <= BITS_PER_LONG) {\r\nif (last)\r\nfirst &= last;\r\n*dst = comp(*src, *dst, first);\r\n} else {\r\nif (first) {\r\n*dst = comp(*src, *dst, first);\r\ndst++;\r\nsrc++;\r\nn -= BITS_PER_LONG - dst_idx;\r\n}\r\nn /= BITS_PER_LONG;\r\nwhile (n >= 8) {\r\n*dst++ = *src++;\r\n*dst++ = *src++;\r\n*dst++ = *src++;\r\n*dst++ = *src++;\r\n*dst++ = *src++;\r\n*dst++ = *src++;\r\n*dst++ = *src++;\r\n*dst++ = *src++;\r\nn -= 8;\r\n}\r\nwhile (n--)\r\n*dst++ = *src++;\r\nif (last)\r\n*dst = comp(*src, *dst, last);\r\n}\r\n} else {\r\nright = shift & (BITS_PER_LONG - 1);\r\nleft = -shift & (BITS_PER_LONG - 1);\r\nif (dst_idx + n <= BITS_PER_LONG) {\r\nif (last)\r\nfirst &= last;\r\nif (shift > 0) {\r\n*dst = comp(*src >> right, *dst, first);\r\n} else if (src_idx + n <= BITS_PER_LONG) {\r\n*dst = comp(*src << left, *dst, first);\r\n} else {\r\nd0 = *src++;\r\nd1 = *src;\r\n*dst = comp(d0 << left | d1 >> right, *dst,\r\nfirst);\r\n}\r\n} else {\r\nd0 = *src++;\r\nif (shift > 0) {\r\n*dst = comp(d0 >> right, *dst, first);\r\ndst++;\r\nn -= BITS_PER_LONG - dst_idx;\r\n} else {\r\nd1 = *src++;\r\n*dst = comp(d0 << left | d1 >> right, *dst,\r\nfirst);\r\nd0 = d1;\r\ndst++;\r\nn -= BITS_PER_LONG - dst_idx;\r\n}\r\nm = n % BITS_PER_LONG;\r\nn /= BITS_PER_LONG;\r\nwhile (n >= 4) {\r\nd1 = *src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\nd1 = *src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\nd1 = *src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\nd1 = *src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\nn -= 4;\r\n}\r\nwhile (n--) {\r\nd1 = *src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\n}\r\nif (last) {\r\nif (m <= right) {\r\n*dst = comp(d0 << left, *dst, last);\r\n} else {\r\nd1 = *src;\r\n*dst = comp(d0 << left | d1 >> right,\r\n*dst, last);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void bitcpy_rev(unsigned long *dst, int dst_idx,\r\nconst unsigned long *src, int src_idx, u32 n)\r\n{\r\nunsigned long first, last;\r\nint shift = dst_idx - src_idx, left, right;\r\nunsigned long d0, d1;\r\nint m;\r\nif (!n)\r\nreturn;\r\ndst += (n - 1) / BITS_PER_LONG;\r\nsrc += (n - 1) / BITS_PER_LONG;\r\nif ((n - 1) % BITS_PER_LONG) {\r\ndst_idx += (n - 1) % BITS_PER_LONG;\r\ndst += dst_idx >> SHIFT_PER_LONG;\r\ndst_idx &= BITS_PER_LONG - 1;\r\nsrc_idx += (n - 1) % BITS_PER_LONG;\r\nsrc += src_idx >> SHIFT_PER_LONG;\r\nsrc_idx &= BITS_PER_LONG - 1;\r\n}\r\nshift = dst_idx - src_idx;\r\nfirst = ~0UL << (BITS_PER_LONG - 1 - dst_idx);\r\nlast = ~(~0UL << (BITS_PER_LONG - 1 - ((dst_idx - n) % BITS_PER_LONG)));\r\nif (!shift) {\r\nif ((unsigned long)dst_idx + 1 >= n) {\r\nif (last)\r\nfirst &= last;\r\n*dst = comp(*src, *dst, first);\r\n} else {\r\nif (first) {\r\n*dst = comp(*src, *dst, first);\r\ndst--;\r\nsrc--;\r\nn -= dst_idx + 1;\r\n}\r\nn /= BITS_PER_LONG;\r\nwhile (n >= 8) {\r\n*dst-- = *src--;\r\n*dst-- = *src--;\r\n*dst-- = *src--;\r\n*dst-- = *src--;\r\n*dst-- = *src--;\r\n*dst-- = *src--;\r\n*dst-- = *src--;\r\n*dst-- = *src--;\r\nn -= 8;\r\n}\r\nwhile (n--)\r\n*dst-- = *src--;\r\nif (last)\r\n*dst = comp(*src, *dst, last);\r\n}\r\n} else {\r\nright = shift & (BITS_PER_LONG - 1);\r\nleft = -shift & (BITS_PER_LONG - 1);\r\nif ((unsigned long)dst_idx + 1 >= n) {\r\nif (last)\r\nfirst &= last;\r\nif (shift < 0) {\r\n*dst = comp(*src << left, *dst, first);\r\n} else if (1 + (unsigned long)src_idx >= n) {\r\n*dst = comp(*src >> right, *dst, first);\r\n} else {\r\nd0 = *src--;\r\nd1 = *src;\r\n*dst = comp(d0 >> right | d1 << left, *dst,\r\nfirst);\r\n}\r\n} else {\r\nd0 = *src--;\r\nif (shift < 0) {\r\n*dst = comp(d0 << left, *dst, first);\r\ndst--;\r\nn -= dst_idx + 1;\r\n} else {\r\nd1 = *src--;\r\n*dst = comp(d0 >> right | d1 << left, *dst,\r\nfirst);\r\nd0 = d1;\r\ndst--;\r\nn -= dst_idx + 1;\r\n}\r\nm = n % BITS_PER_LONG;\r\nn /= BITS_PER_LONG;\r\nwhile (n >= 4) {\r\nd1 = *src--;\r\n*dst-- = d0 >> right | d1 << left;\r\nd0 = d1;\r\nd1 = *src--;\r\n*dst-- = d0 >> right | d1 << left;\r\nd0 = d1;\r\nd1 = *src--;\r\n*dst-- = d0 >> right | d1 << left;\r\nd0 = d1;\r\nd1 = *src--;\r\n*dst-- = d0 >> right | d1 << left;\r\nd0 = d1;\r\nn -= 4;\r\n}\r\nwhile (n--) {\r\nd1 = *src--;\r\n*dst-- = d0 >> right | d1 << left;\r\nd0 = d1;\r\n}\r\nif (last) {\r\nif (m <= left) {\r\n*dst = comp(d0 >> right, *dst, last);\r\n} else {\r\nd1 = *src;\r\n*dst = comp(d0 >> right | d1 << left,\r\n*dst, last);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void bitcpy_not(unsigned long *dst, int dst_idx,\r\nconst unsigned long *src, int src_idx, u32 n)\r\n{\r\nunsigned long first, last;\r\nint shift = dst_idx - src_idx, left, right;\r\nunsigned long d0, d1;\r\nint m;\r\nif (!n)\r\nreturn;\r\nshift = dst_idx - src_idx;\r\nfirst = ~0UL >> dst_idx;\r\nlast = ~(~0UL >> ((dst_idx + n) % BITS_PER_LONG));\r\nif (!shift) {\r\nif (dst_idx + n <= BITS_PER_LONG) {\r\nif (last)\r\nfirst &= last;\r\n*dst = comp(~*src, *dst, first);\r\n} else {\r\nif (first) {\r\n*dst = comp(~*src, *dst, first);\r\ndst++;\r\nsrc++;\r\nn -= BITS_PER_LONG - dst_idx;\r\n}\r\nn /= BITS_PER_LONG;\r\nwhile (n >= 8) {\r\n*dst++ = ~*src++;\r\n*dst++ = ~*src++;\r\n*dst++ = ~*src++;\r\n*dst++ = ~*src++;\r\n*dst++ = ~*src++;\r\n*dst++ = ~*src++;\r\n*dst++ = ~*src++;\r\n*dst++ = ~*src++;\r\nn -= 8;\r\n}\r\nwhile (n--)\r\n*dst++ = ~*src++;\r\nif (last)\r\n*dst = comp(~*src, *dst, last);\r\n}\r\n} else {\r\nright = shift & (BITS_PER_LONG - 1);\r\nleft = -shift & (BITS_PER_LONG - 1);\r\nif (dst_idx + n <= BITS_PER_LONG) {\r\nif (last)\r\nfirst &= last;\r\nif (shift > 0) {\r\n*dst = comp(~*src >> right, *dst, first);\r\n} else if (src_idx + n <= BITS_PER_LONG) {\r\n*dst = comp(~*src << left, *dst, first);\r\n} else {\r\nd0 = ~*src++;\r\nd1 = ~*src;\r\n*dst = comp(d0 << left | d1 >> right, *dst,\r\nfirst);\r\n}\r\n} else {\r\nd0 = ~*src++;\r\nif (shift > 0) {\r\n*dst = comp(d0 >> right, *dst, first);\r\ndst++;\r\nn -= BITS_PER_LONG - dst_idx;\r\n} else {\r\nd1 = ~*src++;\r\n*dst = comp(d0 << left | d1 >> right, *dst,\r\nfirst);\r\nd0 = d1;\r\ndst++;\r\nn -= BITS_PER_LONG - dst_idx;\r\n}\r\nm = n % BITS_PER_LONG;\r\nn /= BITS_PER_LONG;\r\nwhile (n >= 4) {\r\nd1 = ~*src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\nd1 = ~*src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\nd1 = ~*src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\nd1 = ~*src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\nn -= 4;\r\n}\r\nwhile (n--) {\r\nd1 = ~*src++;\r\n*dst++ = d0 << left | d1 >> right;\r\nd0 = d1;\r\n}\r\nif (last) {\r\nif (m <= right) {\r\n*dst = comp(d0 << left, *dst, last);\r\n} else {\r\nd1 = ~*src;\r\n*dst = comp(d0 << left | d1 >> right,\r\n*dst, last);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void bitfill32(unsigned long *dst, int dst_idx, u32 pat, u32 n)\r\n{\r\nunsigned long val = pat;\r\nunsigned long first, last;\r\nif (!n)\r\nreturn;\r\n#if BITS_PER_LONG == 64\r\nval |= val << 32;\r\n#endif\r\nfirst = ~0UL >> dst_idx;\r\nlast = ~(~0UL >> ((dst_idx + n) % BITS_PER_LONG));\r\nif (dst_idx + n <= BITS_PER_LONG) {\r\nif (last)\r\nfirst &= last;\r\n*dst = comp(val, *dst, first);\r\n} else {\r\nif (first) {\r\n*dst = comp(val, *dst, first);\r\ndst++;\r\nn -= BITS_PER_LONG - dst_idx;\r\n}\r\nn /= BITS_PER_LONG;\r\nwhile (n >= 8) {\r\n*dst++ = val;\r\n*dst++ = val;\r\n*dst++ = val;\r\n*dst++ = val;\r\n*dst++ = val;\r\n*dst++ = val;\r\n*dst++ = val;\r\n*dst++ = val;\r\nn -= 8;\r\n}\r\nwhile (n--)\r\n*dst++ = val;\r\nif (last)\r\n*dst = comp(val, *dst, last);\r\n}\r\n}\r\nstatic void bitxor32(unsigned long *dst, int dst_idx, u32 pat, u32 n)\r\n{\r\nunsigned long val = pat;\r\nunsigned long first, last;\r\nif (!n)\r\nreturn;\r\n#if BITS_PER_LONG == 64\r\nval |= val << 32;\r\n#endif\r\nfirst = ~0UL >> dst_idx;\r\nlast = ~(~0UL >> ((dst_idx + n) % BITS_PER_LONG));\r\nif (dst_idx + n <= BITS_PER_LONG) {\r\nif (last)\r\nfirst &= last;\r\n*dst = xor(val, *dst, first);\r\n} else {\r\nif (first) {\r\n*dst = xor(val, *dst, first);\r\ndst++;\r\nn -= BITS_PER_LONG - dst_idx;\r\n}\r\nn /= BITS_PER_LONG;\r\nwhile (n >= 4) {\r\n*dst++ ^= val;\r\n*dst++ ^= val;\r\n*dst++ ^= val;\r\n*dst++ ^= val;\r\nn -= 4;\r\n}\r\nwhile (n--)\r\n*dst++ ^= val;\r\nif (last)\r\n*dst = xor(val, *dst, last);\r\n}\r\n}\r\nstatic inline void fill_one_line(int bpp, unsigned long next_plane,\r\nunsigned long *dst, int dst_idx, u32 n,\r\nu32 color)\r\n{\r\nwhile (1) {\r\ndst += dst_idx >> SHIFT_PER_LONG;\r\ndst_idx &= (BITS_PER_LONG - 1);\r\nbitfill32(dst, dst_idx, color & 1 ? ~0 : 0, n);\r\nif (!--bpp)\r\nbreak;\r\ncolor >>= 1;\r\ndst_idx += next_plane * 8;\r\n}\r\n}\r\nstatic inline void xor_one_line(int bpp, unsigned long next_plane,\r\nunsigned long *dst, int dst_idx, u32 n,\r\nu32 color)\r\n{\r\nwhile (color) {\r\ndst += dst_idx >> SHIFT_PER_LONG;\r\ndst_idx &= (BITS_PER_LONG - 1);\r\nbitxor32(dst, dst_idx, color & 1 ? ~0 : 0, n);\r\nif (!--bpp)\r\nbreak;\r\ncolor >>= 1;\r\ndst_idx += next_plane * 8;\r\n}\r\n}\r\nstatic void amifb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct amifb_par *par = info->par;\r\nint dst_idx, x2, y2;\r\nunsigned long *dst;\r\nu32 width, height;\r\nif (!rect->width || !rect->height)\r\nreturn;\r\nx2 = rect->dx + rect->width;\r\ny2 = rect->dy + rect->height;\r\nx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\r\ny2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\r\nwidth = x2 - rect->dx;\r\nheight = y2 - rect->dy;\r\ndst = (unsigned long *)\r\n((unsigned long)info->screen_base & ~(BYTES_PER_LONG - 1));\r\ndst_idx = ((unsigned long)info->screen_base & (BYTES_PER_LONG - 1)) * 8;\r\ndst_idx += rect->dy * par->next_line * 8 + rect->dx;\r\nwhile (height--) {\r\nswitch (rect->rop) {\r\ncase ROP_COPY:\r\nfill_one_line(info->var.bits_per_pixel,\r\npar->next_plane, dst, dst_idx, width,\r\nrect->color);\r\nbreak;\r\ncase ROP_XOR:\r\nxor_one_line(info->var.bits_per_pixel, par->next_plane,\r\ndst, dst_idx, width, rect->color);\r\nbreak;\r\n}\r\ndst_idx += par->next_line * 8;\r\n}\r\n}\r\nstatic inline void copy_one_line(int bpp, unsigned long next_plane,\r\nunsigned long *dst, int dst_idx,\r\nunsigned long *src, int src_idx, u32 n)\r\n{\r\nwhile (1) {\r\ndst += dst_idx >> SHIFT_PER_LONG;\r\ndst_idx &= (BITS_PER_LONG - 1);\r\nsrc += src_idx >> SHIFT_PER_LONG;\r\nsrc_idx &= (BITS_PER_LONG - 1);\r\nbitcpy(dst, dst_idx, src, src_idx, n);\r\nif (!--bpp)\r\nbreak;\r\ndst_idx += next_plane * 8;\r\nsrc_idx += next_plane * 8;\r\n}\r\n}\r\nstatic inline void copy_one_line_rev(int bpp, unsigned long next_plane,\r\nunsigned long *dst, int dst_idx,\r\nunsigned long *src, int src_idx, u32 n)\r\n{\r\nwhile (1) {\r\ndst += dst_idx >> SHIFT_PER_LONG;\r\ndst_idx &= (BITS_PER_LONG - 1);\r\nsrc += src_idx >> SHIFT_PER_LONG;\r\nsrc_idx &= (BITS_PER_LONG - 1);\r\nbitcpy_rev(dst, dst_idx, src, src_idx, n);\r\nif (!--bpp)\r\nbreak;\r\ndst_idx += next_plane * 8;\r\nsrc_idx += next_plane * 8;\r\n}\r\n}\r\nstatic void amifb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct amifb_par *par = info->par;\r\nint x2, y2;\r\nu32 dx, dy, sx, sy, width, height;\r\nunsigned long *dst, *src;\r\nint dst_idx, src_idx;\r\nint rev_copy = 0;\r\nx2 = area->dx + area->width;\r\ny2 = area->dy + area->height;\r\ndx = area->dx > 0 ? area->dx : 0;\r\ndy = area->dy > 0 ? area->dy : 0;\r\nx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\r\ny2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\r\nwidth = x2 - dx;\r\nheight = y2 - dy;\r\nif (area->sx + dx < area->dx || area->sy + dy < area->dy)\r\nreturn;\r\nsx = area->sx + (dx - area->dx);\r\nsy = area->sy + (dy - area->dy);\r\nif (sx + width > info->var.xres_virtual ||\r\nsy + height > info->var.yres_virtual)\r\nreturn;\r\nif (dy > sy || (dy == sy && dx > sx)) {\r\ndy += height;\r\nsy += height;\r\nrev_copy = 1;\r\n}\r\ndst = (unsigned long *)\r\n((unsigned long)info->screen_base & ~(BYTES_PER_LONG - 1));\r\nsrc = dst;\r\ndst_idx = ((unsigned long)info->screen_base & (BYTES_PER_LONG - 1)) * 8;\r\nsrc_idx = dst_idx;\r\ndst_idx += dy * par->next_line * 8 + dx;\r\nsrc_idx += sy * par->next_line * 8 + sx;\r\nif (rev_copy) {\r\nwhile (height--) {\r\ndst_idx -= par->next_line * 8;\r\nsrc_idx -= par->next_line * 8;\r\ncopy_one_line_rev(info->var.bits_per_pixel,\r\npar->next_plane, dst, dst_idx, src,\r\nsrc_idx, width);\r\n}\r\n} else {\r\nwhile (height--) {\r\ncopy_one_line(info->var.bits_per_pixel,\r\npar->next_plane, dst, dst_idx, src,\r\nsrc_idx, width);\r\ndst_idx += par->next_line * 8;\r\nsrc_idx += par->next_line * 8;\r\n}\r\n}\r\n}\r\nstatic inline void expand_one_line(int bpp, unsigned long next_plane,\r\nunsigned long *dst, int dst_idx, u32 n,\r\nconst u8 *data, u32 bgcolor, u32 fgcolor)\r\n{\r\nconst unsigned long *src;\r\nint src_idx;\r\nwhile (1) {\r\ndst += dst_idx >> SHIFT_PER_LONG;\r\ndst_idx &= (BITS_PER_LONG - 1);\r\nif ((bgcolor ^ fgcolor) & 1) {\r\nsrc = (unsigned long *)\r\n((unsigned long)data & ~(BYTES_PER_LONG - 1));\r\nsrc_idx = ((unsigned long)data & (BYTES_PER_LONG - 1)) * 8;\r\nif (fgcolor & 1)\r\nbitcpy(dst, dst_idx, src, src_idx, n);\r\nelse\r\nbitcpy_not(dst, dst_idx, src, src_idx, n);\r\n} else\r\nbitfill32(dst, dst_idx, fgcolor & 1 ? ~0 : 0, n);\r\nif (!--bpp)\r\nbreak;\r\nbgcolor >>= 1;\r\nfgcolor >>= 1;\r\ndst_idx += next_plane * 8;\r\n}\r\n}\r\nstatic void amifb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct amifb_par *par = info->par;\r\nint x2, y2;\r\nunsigned long *dst;\r\nint dst_idx;\r\nconst char *src;\r\nu32 dx, dy, width, height, pitch;\r\nx2 = image->dx + image->width;\r\ny2 = image->dy + image->height;\r\ndx = image->dx;\r\ndy = image->dy;\r\nx2 = x2 < info->var.xres_virtual ? x2 : info->var.xres_virtual;\r\ny2 = y2 < info->var.yres_virtual ? y2 : info->var.yres_virtual;\r\nwidth = x2 - dx;\r\nheight = y2 - dy;\r\nif (image->depth == 1) {\r\ndst = (unsigned long *)\r\n((unsigned long)info->screen_base & ~(BYTES_PER_LONG - 1));\r\ndst_idx = ((unsigned long)info->screen_base & (BYTES_PER_LONG - 1)) * 8;\r\ndst_idx += dy * par->next_line * 8 + dx;\r\nsrc = image->data;\r\npitch = (image->width + 7) / 8;\r\nwhile (height--) {\r\nexpand_one_line(info->var.bits_per_pixel,\r\npar->next_plane, dst, dst_idx, width,\r\nsrc, image->bg_color,\r\nimage->fg_color);\r\ndst_idx += par->next_line * 8;\r\nsrc += pitch;\r\n}\r\n} else {\r\nc2p_planar(info->screen_base, image->data, dx, dy, width,\r\nheight, par->next_line, par->next_plane,\r\nimage->width, info->var.bits_per_pixel);\r\n}\r\n}\r\nstatic int amifb_ioctl(struct fb_info *info,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nunion {\r\nstruct fb_fix_cursorinfo fix;\r\nstruct fb_var_cursorinfo var;\r\nstruct fb_cursorstate state;\r\n} crsr;\r\nvoid __user *argp = (void __user *)arg;\r\nint i;\r\nswitch (cmd) {\r\ncase FBIOGET_FCURSORINFO:\r\ni = ami_get_fix_cursorinfo(&crsr.fix, info->par);\r\nif (i)\r\nreturn i;\r\nreturn copy_to_user(argp, &crsr.fix,\r\nsizeof(crsr.fix)) ? -EFAULT : 0;\r\ncase FBIOGET_VCURSORINFO:\r\ni = ami_get_var_cursorinfo(&crsr.var,\r\n((struct fb_var_cursorinfo __user *)arg)->data,\r\ninfo->par);\r\nif (i)\r\nreturn i;\r\nreturn copy_to_user(argp, &crsr.var,\r\nsizeof(crsr.var)) ? -EFAULT : 0;\r\ncase FBIOPUT_VCURSORINFO:\r\nif (copy_from_user(&crsr.var, argp, sizeof(crsr.var)))\r\nreturn -EFAULT;\r\nreturn ami_set_var_cursorinfo(&crsr.var,\r\n((struct fb_var_cursorinfo __user *)arg)->data,\r\ninfo->par);\r\ncase FBIOGET_CURSORSTATE:\r\ni = ami_get_cursorstate(&crsr.state, info->par);\r\nif (i)\r\nreturn i;\r\nreturn copy_to_user(argp, &crsr.state,\r\nsizeof(crsr.state)) ? -EFAULT : 0;\r\ncase FBIOPUT_CURSORSTATE:\r\nif (copy_from_user(&crsr.state, argp, sizeof(crsr.state)))\r\nreturn -EFAULT;\r\nreturn ami_set_cursorstate(&crsr.state, info->par);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int flash_cursor(void)\r\n{\r\nstatic int cursorcount = 1;\r\nif (cursormode == FB_CURSOR_FLASH) {\r\nif (!--cursorcount) {\r\ncursorstate = -cursorstate;\r\ncursorcount = cursorrate;\r\nif (!is_blanked)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t amifb_interrupt(int irq, void *dev_id)\r\n{\r\nstruct amifb_par *par = dev_id;\r\nif (do_vmode_pan || do_vmode_full)\r\nami_update_display(par);\r\nif (do_vmode_full)\r\nami_init_display(par);\r\nif (do_vmode_pan) {\r\nflash_cursor();\r\nami_rebuild_copper(par);\r\ndo_cursor = do_vmode_pan = 0;\r\n} else if (do_cursor) {\r\nflash_cursor();\r\nami_set_sprite(par);\r\ndo_cursor = 0;\r\n} else {\r\nif (flash_cursor())\r\nami_set_sprite(par);\r\n}\r\nif (do_blank) {\r\nami_do_blank(par);\r\ndo_blank = 0;\r\n}\r\nif (do_vmode_full) {\r\nami_reinit_copper(par);\r\ndo_vmode_full = 0;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline u_long __init chipalloc(u_long size)\r\n{\r\naligned_chipptr = amiga_chip_alloc(size, "amifb [RAM]");\r\nif (!aligned_chipptr) {\r\npr_err("amifb: No Chip RAM for frame buffer");\r\nreturn 0;\r\n}\r\nmemset(aligned_chipptr, 0, size);\r\nreturn (u_long)aligned_chipptr;\r\n}\r\nstatic inline void chipfree(void)\r\n{\r\nif (aligned_chipptr)\r\namiga_chip_free(aligned_chipptr);\r\n}\r\nstatic int __init amifb_probe(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info;\r\nint tag, i, err = 0;\r\nu_long chipptr;\r\nu_int defmode;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("amifb", &option)) {\r\namifb_video_off();\r\nreturn -ENODEV;\r\n}\r\namifb_setup(option);\r\n#endif\r\ncustom.dmacon = DMAF_ALL | DMAF_MASTER;\r\ninfo = framebuffer_alloc(sizeof(struct amifb_par), &pdev->dev);\r\nif (!info) {\r\ndev_err(&pdev->dev, "framebuffer_alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(info->fix.id, "Amiga ");\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.accel = FB_ACCEL_AMIGABLITT;\r\nswitch (amiga_chipset) {\r\n#ifdef CONFIG_FB_AMIGA_OCS\r\ncase CS_OCS:\r\nstrcat(info->fix.id, "OCS");\r\ndefault_chipset:\r\nchipset = TAG_OCS;\r\nmaxdepth[TAG_SHRES] = 0;\r\nmaxdepth[TAG_HIRES] = 4;\r\nmaxdepth[TAG_LORES] = 6;\r\nmaxfmode = TAG_FMODE_1;\r\ndefmode = amiga_vblank == 50 ? DEFMODE_PAL : DEFMODE_NTSC;\r\ninfo->fix.smem_len = VIDEOMEMSIZE_OCS;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_FB_AMIGA_ECS\r\ncase CS_ECS:\r\nstrcat(info->fix.id, "ECS");\r\nchipset = TAG_ECS;\r\nmaxdepth[TAG_SHRES] = 2;\r\nmaxdepth[TAG_HIRES] = 4;\r\nmaxdepth[TAG_LORES] = 6;\r\nmaxfmode = TAG_FMODE_1;\r\nif (AMIGAHW_PRESENT(AMBER_FF))\r\ndefmode = amiga_vblank == 50 ? DEFMODE_AMBER_PAL\r\n: DEFMODE_AMBER_NTSC;\r\nelse\r\ndefmode = amiga_vblank == 50 ? DEFMODE_PAL\r\n: DEFMODE_NTSC;\r\nif (amiga_chip_avail() - CHIPRAM_SAFETY_LIMIT >\r\nVIDEOMEMSIZE_ECS_2M)\r\ninfo->fix.smem_len = VIDEOMEMSIZE_ECS_2M;\r\nelse\r\ninfo->fix.smem_len = VIDEOMEMSIZE_ECS_1M;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_FB_AMIGA_AGA\r\ncase CS_AGA:\r\nstrcat(info->fix.id, "AGA");\r\nchipset = TAG_AGA;\r\nmaxdepth[TAG_SHRES] = 8;\r\nmaxdepth[TAG_HIRES] = 8;\r\nmaxdepth[TAG_LORES] = 8;\r\nmaxfmode = TAG_FMODE_4;\r\ndefmode = DEFMODE_AGA;\r\nif (amiga_chip_avail() - CHIPRAM_SAFETY_LIMIT >\r\nVIDEOMEMSIZE_AGA_2M)\r\ninfo->fix.smem_len = VIDEOMEMSIZE_AGA_2M;\r\nelse\r\ninfo->fix.smem_len = VIDEOMEMSIZE_AGA_1M;\r\nbreak;\r\n#endif\r\ndefault:\r\n#ifdef CONFIG_FB_AMIGA_OCS\r\nprintk("Unknown graphics chipset, defaulting to OCS\n");\r\nstrcat(info->fix.id, "Unknown");\r\ngoto default_chipset;\r\n#else\r\nerr = -ENODEV;\r\ngoto release;\r\n#endif\r\nbreak;\r\n}\r\n{\r\nu_long tmp = DIVUL(200000000000ULL, amiga_eclock);\r\npixclock[TAG_SHRES] = (tmp + 4) / 8;\r\npixclock[TAG_HIRES] = (tmp + 2) / 4;\r\npixclock[TAG_LORES] = (tmp + 1) / 2;\r\n}\r\nfor (i = 0; i < NUM_TOTAL_MODES; i++) {\r\nstruct fb_videomode *mode = &ami_modedb[i];\r\ntag = mode->pixclock;\r\nif (tag == TAG_SHRES || tag == TAG_HIRES || tag == TAG_LORES) {\r\nmode->pixclock = pixclock[tag];\r\n}\r\n}\r\nif (amifb_hfmin) {\r\ninfo->monspecs.hfmin = amifb_hfmin;\r\ninfo->monspecs.hfmax = amifb_hfmax;\r\ninfo->monspecs.vfmin = amifb_vfmin;\r\ninfo->monspecs.vfmax = amifb_vfmax;\r\n} else {\r\ninfo->monspecs.hfmin = 15000;\r\ninfo->monspecs.hfmax = 38000;\r\ninfo->monspecs.vfmin = 49;\r\ninfo->monspecs.vfmax = 90;\r\n}\r\ninfo->fbops = &amifb_ops;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->device = &pdev->dev;\r\nif (!fb_find_mode(&info->var, info, mode_option, ami_modedb,\r\nNUM_TOTAL_MODES, &ami_modedb[defmode], 4)) {\r\nerr = -EINVAL;\r\ngoto release;\r\n}\r\nfb_videomode_to_modelist(ami_modedb, NUM_TOTAL_MODES,\r\n&info->modelist);\r\nround_down_bpp = 0;\r\nchipptr = chipalloc(info->fix.smem_len + SPRITEMEMSIZE +\r\nDUMMYSPRITEMEMSIZE + COPINITSIZE +\r\n4 * COPLISTSIZE);\r\nif (!chipptr) {\r\nerr = -ENOMEM;\r\ngoto release;\r\n}\r\nassignchunk(videomemory, u_long, chipptr, info->fix.smem_len);\r\nassignchunk(spritememory, u_long, chipptr, SPRITEMEMSIZE);\r\nassignchunk(dummysprite, u_short *, chipptr, DUMMYSPRITEMEMSIZE);\r\nassignchunk(copdisplay.init, copins *, chipptr, COPINITSIZE);\r\nassignchunk(copdisplay.list[0][0], copins *, chipptr, COPLISTSIZE);\r\nassignchunk(copdisplay.list[0][1], copins *, chipptr, COPLISTSIZE);\r\nassignchunk(copdisplay.list[1][0], copins *, chipptr, COPLISTSIZE);\r\nassignchunk(copdisplay.list[1][1], copins *, chipptr, COPLISTSIZE);\r\ninfo->fix.smem_start = (u_long)ZTWO_PADDR(videomemory);\r\nvideomemory = (u_long)ioremap_writethrough(info->fix.smem_start,\r\ninfo->fix.smem_len);\r\nif (!videomemory) {\r\ndev_warn(&pdev->dev,\r\n"Unable to map videomem cached writethrough\n");\r\ninfo->screen_base = (char *)ZTWO_VADDR(info->fix.smem_start);\r\n} else\r\ninfo->screen_base = (char *)videomemory;\r\nmemset(dummysprite, 0, DUMMYSPRITEMEMSIZE);\r\nami_init_copper();\r\ncustom.dmacon = DMAF_SETCLR | DMAF_MASTER | DMAF_RASTER | DMAF_COPPER |\r\nDMAF_BLITTER | DMAF_SPRITE;\r\nerr = request_irq(IRQ_AMIGA_COPPER, amifb_interrupt, 0,\r\n"fb vertb handler", info->par);\r\nif (err)\r\ngoto disable_dma;\r\nerr = fb_alloc_cmap(&info->cmap, 1 << info->var.bits_per_pixel, 0);\r\nif (err)\r\ngoto free_irq;\r\ndev_set_drvdata(&pdev->dev, info);\r\nerr = register_framebuffer(info);\r\nif (err)\r\ngoto unset_drvdata;\r\nprintk("fb%d: %s frame buffer device, using %dK of video memory\n",\r\ninfo->node, info->fix.id, info->fix.smem_len>>10);\r\nreturn 0;\r\nunset_drvdata:\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nfb_dealloc_cmap(&info->cmap);\r\nfree_irq:\r\nfree_irq(IRQ_AMIGA_COPPER, info->par);\r\ndisable_dma:\r\ncustom.dmacon = DMAF_ALL | DMAF_MASTER;\r\nif (videomemory)\r\niounmap((void *)videomemory);\r\nchipfree();\r\nrelease:\r\nframebuffer_release(info);\r\nreturn err;\r\n}\r\nstatic int __exit amifb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&pdev->dev);\r\nunregister_framebuffer(info);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nfb_dealloc_cmap(&info->cmap);\r\nfree_irq(IRQ_AMIGA_COPPER, info->par);\r\ncustom.dmacon = DMAF_ALL | DMAF_MASTER;\r\nif (videomemory)\r\niounmap((void *)videomemory);\r\nchipfree();\r\nframebuffer_release(info);\r\namifb_video_off();\r\nreturn 0;\r\n}
