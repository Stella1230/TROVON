static inline uint64_t\r\nahd_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)\r\n{\r\nuint64_t id;\r\nid = subvendor\r\n| (subdevice << 16)\r\n| ((uint64_t)vendor << 32)\r\n| ((uint64_t)device << 48);\r\nreturn (id);\r\n}\r\nconst struct ahd_pci_identity *\r\nahd_find_pci_device(ahd_dev_softc_t pci)\r\n{\r\nuint64_t full_id;\r\nuint16_t device;\r\nuint16_t vendor;\r\nuint16_t subdevice;\r\nuint16_t subvendor;\r\nconst struct ahd_pci_identity *entry;\r\nu_int i;\r\nvendor = ahd_pci_read_config(pci, PCIR_DEVVENDOR, 2);\r\ndevice = ahd_pci_read_config(pci, PCIR_DEVICE, 2);\r\nsubvendor = ahd_pci_read_config(pci, PCIR_SUBVEND_0, 2);\r\nsubdevice = ahd_pci_read_config(pci, PCIR_SUBDEV_0, 2);\r\nfull_id = ahd_compose_id(device,\r\nvendor,\r\nsubdevice,\r\nsubvendor);\r\nfull_id &= ID_ALL_IROC_MASK;\r\nfor (i = 0; i < ahd_num_pci_devs; i++) {\r\nentry = &ahd_pci_ident_table[i];\r\nif (entry->full_id == (full_id & entry->id_mask)) {\r\nif (entry->name == NULL)\r\nreturn (NULL);\r\nreturn (entry);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nint\r\nahd_pci_config(struct ahd_softc *ahd, const struct ahd_pci_identity *entry)\r\n{\r\nstruct scb_data *shared_scb_data;\r\nu_int command;\r\nuint32_t devconfig;\r\nuint16_t subvendor;\r\nint error;\r\nshared_scb_data = NULL;\r\nahd->description = entry->name;\r\nsubvendor = ahd_pci_read_config(ahd->dev_softc,\r\nPCIR_SUBVEND_0, 2);\r\nif (subvendor == SUBID_HP)\r\nahd->flags |= AHD_HP_BOARD;\r\nerror = entry->setup(ahd);\r\nif (error != 0)\r\nreturn (error);\r\ndevconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, 4);\r\nif ((devconfig & PCIXINITPAT) == PCIXINIT_PCI33_66) {\r\nahd->chip |= AHD_PCI;\r\nahd->bugs &= ~AHD_PCIX_BUG_MASK;\r\n} else {\r\nahd->chip |= AHD_PCIX;\r\n}\r\nahd->bus_description = pci_bus_modes[PCI_BUS_MODES_INDEX(devconfig)];\r\nahd_power_state_change(ahd, AHD_POWER_STATE_D0);\r\nerror = ahd_pci_map_registers(ahd);\r\nif (error != 0)\r\nreturn (error);\r\nif ((ahd->flags & (AHD_39BIT_ADDRESSING|AHD_64BIT_ADDRESSING)) != 0) {\r\nif (bootverbose)\r\nprintk("%s: Enabling 39Bit Addressing\n",\r\nahd_name(ahd));\r\ndevconfig = ahd_pci_read_config(ahd->dev_softc,\r\nDEVCONFIG, 4);\r\ndevconfig |= DACEN;\r\nahd_pci_write_config(ahd->dev_softc, DEVCONFIG,\r\ndevconfig, 4);\r\n}\r\ncommand = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 2);\r\ncommand |= PCIM_CMD_BUSMASTEREN;\r\nahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, 2);\r\nerror = ahd_softc_init(ahd);\r\nif (error != 0)\r\nreturn (error);\r\nahd->bus_intr = ahd_pci_intr;\r\nerror = ahd_reset(ahd, FALSE);\r\nif (error != 0)\r\nreturn (ENXIO);\r\nahd->pci_cachesize =\r\nahd_pci_read_config(ahd->dev_softc, CSIZE_LATTIME,\r\n1) & CACHESIZE;\r\nahd->pci_cachesize *= 4;\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nerror = ahd_check_extport(ahd);\r\nif (error != 0)\r\nreturn (error);\r\nerror = ahd_init(ahd);\r\nif (error != 0)\r\nreturn (error);\r\nahd->init_level++;\r\nreturn ahd_pci_map_int(ahd);\r\n}\r\nvoid\r\nahd_pci_suspend(struct ahd_softc *ahd)\r\n{\r\nahd->suspend_state.pci_state.devconfig =\r\nahd_pci_read_config(ahd->dev_softc, DEVCONFIG, 4);\r\nahd->suspend_state.pci_state.command =\r\nahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 1);\r\nahd->suspend_state.pci_state.csize_lattime =\r\nahd_pci_read_config(ahd->dev_softc, CSIZE_LATTIME, 1);\r\n}\r\nvoid\r\nahd_pci_resume(struct ahd_softc *ahd)\r\n{\r\nahd_pci_write_config(ahd->dev_softc, DEVCONFIG,\r\nahd->suspend_state.pci_state.devconfig, 4);\r\nahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\r\nahd->suspend_state.pci_state.command, 1);\r\nahd_pci_write_config(ahd->dev_softc, CSIZE_LATTIME,\r\nahd->suspend_state.pci_state.csize_lattime, 1);\r\n}\r\nint\r\nahd_pci_test_register_access(struct ahd_softc *ahd)\r\n{\r\nuint32_t cmd;\r\nu_int targpcistat;\r\nu_int pci_status1;\r\nint error;\r\nuint8_t hcntrl;\r\nerror = EIO;\r\ncmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 2);\r\nahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,\r\ncmd & ~PCIM_CMD_SERRESPEN, 2);\r\nhcntrl = ahd_inb(ahd, HCNTRL);\r\nif (hcntrl == 0xFF)\r\ngoto fail;\r\nhcntrl &= ~CHIPRST;\r\nahd_outb(ahd, HCNTRL, hcntrl|PAUSE);\r\nwhile (ahd_is_paused(ahd) == 0)\r\n;\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\ntargpcistat = ahd_inb(ahd, TARGPCISTAT);\r\nahd_outb(ahd, TARGPCISTAT, targpcistat);\r\npci_status1 = ahd_pci_read_config(ahd->dev_softc,\r\nPCIR_STATUS + 1, 1);\r\nahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,\r\npci_status1, 1);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nahd_outb(ahd, CLRINT, CLRPCIINT);\r\nahd_outb(ahd, SEQCTL0, PERRORDIS);\r\nahd_outl(ahd, SRAM_BASE, 0x5aa555aa);\r\nif (ahd_inl(ahd, SRAM_BASE) != 0x5aa555aa)\r\ngoto fail;\r\nif ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\ntargpcistat = ahd_inb(ahd, TARGPCISTAT);\r\nif ((targpcistat & STA) != 0)\r\ngoto fail;\r\n}\r\nerror = 0;\r\nfail:\r\nif ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\ntargpcistat = ahd_inb(ahd, TARGPCISTAT);\r\nahd_outb(ahd, TARGPCISTAT, targpcistat);\r\npci_status1 = ahd_pci_read_config(ahd->dev_softc,\r\nPCIR_STATUS + 1, 1);\r\nahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,\r\npci_status1, 1);\r\nahd_outb(ahd, CLRINT, CLRPCIINT);\r\n}\r\nahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS);\r\nahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, cmd, 2);\r\nreturn (error);\r\n}\r\nstatic int\r\nahd_check_extport(struct ahd_softc *ahd)\r\n{\r\nstruct vpd_config vpd;\r\nstruct seeprom_config *sc;\r\nu_int adapter_control;\r\nint have_seeprom;\r\nint error;\r\nsc = ahd->seep_config;\r\nhave_seeprom = ahd_acquire_seeprom(ahd);\r\nif (have_seeprom) {\r\nu_int start_addr;\r\nif (bootverbose)\r\nprintk("%s: Reading VPD from SEEPROM...",\r\nahd_name(ahd));\r\nstart_addr = ((2 * sizeof(*sc))\r\n+ (sizeof(vpd) * (ahd->channel - 'A'))) / 2;\r\nerror = ahd_read_seeprom(ahd, (uint16_t *)&vpd,\r\nstart_addr, sizeof(vpd)/2,\r\nTRUE);\r\nif (error == 0)\r\nerror = ahd_parse_vpddata(ahd, &vpd);\r\nif (bootverbose)\r\nprintk("%s: VPD parsing %s\n",\r\nahd_name(ahd),\r\nerror == 0 ? "successful" : "failed");\r\nif (bootverbose)\r\nprintk("%s: Reading SEEPROM...", ahd_name(ahd));\r\nstart_addr = (sizeof(*sc) / 2) * (ahd->channel - 'A');\r\nerror = ahd_read_seeprom(ahd, (uint16_t *)sc,\r\nstart_addr, sizeof(*sc)/2,\r\nFALSE);\r\nif (error != 0) {\r\nprintk("Unable to read SEEPROM\n");\r\nhave_seeprom = 0;\r\n} else {\r\nhave_seeprom = ahd_verify_cksum(sc);\r\nif (bootverbose) {\r\nif (have_seeprom == 0)\r\nprintk ("checksum error\n");\r\nelse\r\nprintk ("done.\n");\r\n}\r\n}\r\nahd_release_seeprom(ahd);\r\n}\r\nif (!have_seeprom) {\r\nu_int nvram_scb;\r\nahd_set_scbptr(ahd, 0xFF);\r\nnvram_scb = ahd_inb_scbram(ahd, SCB_BASE + NVRAM_SCB_OFFSET);\r\nif (nvram_scb != 0xFF\r\n&& ((ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 1) == 'D'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 3) == 'T')\r\n|| (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'B'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 1) == 'I'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 2) == 'O'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 3) == 'S')\r\n|| (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 1) == 'S'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'\r\n&& ahd_inb_scbram(ahd, SCB_BASE + 3) == 'I'))) {\r\nuint16_t *sc_data;\r\nint i;\r\nahd_set_scbptr(ahd, nvram_scb);\r\nsc_data = (uint16_t *)sc;\r\nfor (i = 0; i < 64; i += 2)\r\n*sc_data++ = ahd_inw_scbram(ahd, SCB_BASE+i);\r\nhave_seeprom = ahd_verify_cksum(sc);\r\nif (have_seeprom)\r\nahd->flags |= AHD_SCB_CONFIG_USED;\r\n}\r\n}\r\n#ifdef AHD_DEBUG\r\nif (have_seeprom != 0\r\n&& (ahd_debug & AHD_DUMP_SEEPROM) != 0) {\r\nuint16_t *sc_data;\r\nint i;\r\nprintk("%s: Seeprom Contents:", ahd_name(ahd));\r\nsc_data = (uint16_t *)sc;\r\nfor (i = 0; i < (sizeof(*sc)); i += 2)\r\nprintk("\n\t0x%.4x", sc_data[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\nif (!have_seeprom) {\r\nif (bootverbose)\r\nprintk("%s: No SEEPROM available.\n", ahd_name(ahd));\r\nahd->flags |= AHD_USEDEFAULTS;\r\nerror = ahd_default_config(ahd);\r\nadapter_control = CFAUTOTERM|CFSEAUTOTERM;\r\nkfree(ahd->seep_config);\r\nahd->seep_config = NULL;\r\n} else {\r\nerror = ahd_parse_cfgdata(ahd, sc);\r\nadapter_control = sc->adapter_control;\r\n}\r\nif (error != 0)\r\nreturn (error);\r\nahd_configure_termination(ahd, adapter_control);\r\nreturn (0);\r\n}\r\nstatic void\r\nahd_configure_termination(struct ahd_softc *ahd, u_int adapter_control)\r\n{\r\nint error;\r\nu_int sxfrctl1;\r\nuint8_t termctl;\r\nuint32_t devconfig;\r\ndevconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, 4);\r\ndevconfig &= ~STPWLEVEL;\r\nif ((ahd->flags & AHD_STPWLEVEL_A) != 0)\r\ndevconfig |= STPWLEVEL;\r\nif (bootverbose)\r\nprintk("%s: STPWLEVEL is %s\n",\r\nahd_name(ahd), (devconfig & STPWLEVEL) ? "on" : "off");\r\nahd_pci_write_config(ahd->dev_softc, DEVCONFIG, devconfig, 4);\r\nif ((ahd->flags & AHD_CURRENT_SENSING) != 0) {\r\n(void)ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);\r\n}\r\nerror = ahd_read_flexport(ahd, FLXADDR_TERMCTL, &termctl);\r\nif ((adapter_control & CFAUTOTERM) == 0) {\r\nif (bootverbose)\r\nprintk("%s: Manual Primary Termination\n",\r\nahd_name(ahd));\r\ntermctl &= ~(FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH);\r\nif ((adapter_control & CFSTERM) != 0)\r\ntermctl |= FLX_TERMCTL_ENPRILOW;\r\nif ((adapter_control & CFWSTERM) != 0)\r\ntermctl |= FLX_TERMCTL_ENPRIHIGH;\r\n} else if (error != 0) {\r\nprintk("%s: Primary Auto-Term Sensing failed! "\r\n"Using Defaults.\n", ahd_name(ahd));\r\ntermctl = FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH;\r\n}\r\nif ((adapter_control & CFSEAUTOTERM) == 0) {\r\nif (bootverbose)\r\nprintk("%s: Manual Secondary Termination\n",\r\nahd_name(ahd));\r\ntermctl &= ~(FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH);\r\nif ((adapter_control & CFSELOWTERM) != 0)\r\ntermctl |= FLX_TERMCTL_ENSECLOW;\r\nif ((adapter_control & CFSEHIGHTERM) != 0)\r\ntermctl |= FLX_TERMCTL_ENSECHIGH;\r\n} else if (error != 0) {\r\nprintk("%s: Secondary Auto-Term Sensing failed! "\r\n"Using Defaults.\n", ahd_name(ahd));\r\ntermctl |= FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH;\r\n}\r\nsxfrctl1 = ahd_inb(ahd, SXFRCTL1) & ~STPWEN;\r\nahd->flags &= ~AHD_TERM_ENB_A;\r\nif ((termctl & FLX_TERMCTL_ENPRILOW) != 0) {\r\nahd->flags |= AHD_TERM_ENB_A;\r\nsxfrctl1 |= STPWEN;\r\n}\r\nahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);\r\nahd_outb(ahd, SXFRCTL1, sxfrctl1);\r\nerror = ahd_write_flexport(ahd, FLXADDR_TERMCTL, termctl);\r\nif (error != 0) {\r\nprintk("%s: Unable to set termination settings!\n",\r\nahd_name(ahd));\r\n} else if (bootverbose) {\r\nprintk("%s: Primary High byte termination %sabled\n",\r\nahd_name(ahd),\r\n(termctl & FLX_TERMCTL_ENPRIHIGH) ? "En" : "Dis");\r\nprintk("%s: Primary Low byte termination %sabled\n",\r\nahd_name(ahd),\r\n(termctl & FLX_TERMCTL_ENPRILOW) ? "En" : "Dis");\r\nprintk("%s: Secondary High byte termination %sabled\n",\r\nahd_name(ahd),\r\n(termctl & FLX_TERMCTL_ENSECHIGH) ? "En" : "Dis");\r\nprintk("%s: Secondary Low byte termination %sabled\n",\r\nahd_name(ahd),\r\n(termctl & FLX_TERMCTL_ENSECLOW) ? "En" : "Dis");\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nahd_pci_intr(struct ahd_softc *ahd)\r\n{\r\nuint8_t pci_status[8];\r\nahd_mode_state saved_modes;\r\nu_int pci_status1;\r\nu_int intstat;\r\nu_int i;\r\nu_int reg;\r\nintstat = ahd_inb(ahd, INTSTAT);\r\nif ((intstat & SPLTINT) != 0)\r\nahd_pci_split_intr(ahd, intstat);\r\nif ((intstat & PCIINT) == 0)\r\nreturn;\r\nprintk("%s: PCI error Interrupt\n", ahd_name(ahd));\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_dump_card_state(ahd);\r\nahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);\r\nfor (i = 0, reg = DF0PCISTAT; i < 8; i++, reg++) {\r\nif (i == 5)\r\ncontinue;\r\npci_status[i] = ahd_inb(ahd, reg);\r\nahd_outb(ahd, reg, pci_status[i]);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nu_int bit;\r\nif (i == 5)\r\ncontinue;\r\nfor (bit = 0; bit < 8; bit++) {\r\nif ((pci_status[i] & (0x1 << bit)) != 0) {\r\nstatic const char *s;\r\ns = pci_status_strings[bit];\r\nif (i == 7 && bit == 3)\r\ns = "%s: Signaled Target Abort\n";\r\nprintk(s, ahd_name(ahd), pci_status_source[i]);\r\n}\r\n}\r\n}\r\npci_status1 = ahd_pci_read_config(ahd->dev_softc,\r\nPCIR_STATUS + 1, 1);\r\nahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,\r\npci_status1, 1);\r\nahd_restore_modes(ahd, saved_modes);\r\nahd_outb(ahd, CLRINT, CLRPCIINT);\r\nahd_unpause(ahd);\r\n}\r\nstatic void\r\nahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat)\r\n{\r\nuint8_t split_status[4];\r\nuint8_t split_status1[4];\r\nuint8_t sg_split_status[2];\r\nuint8_t sg_split_status1[2];\r\nahd_mode_state saved_modes;\r\nu_int i;\r\nuint16_t pcix_status;\r\npcix_status = ahd_pci_read_config(ahd->dev_softc, PCIXR_STATUS,\r\n2);\r\nprintk("%s: PCI Split Interrupt - PCI-X status = 0x%x\n",\r\nahd_name(ahd), pcix_status);\r\nsaved_modes = ahd_save_modes(ahd);\r\nfor (i = 0; i < 4; i++) {\r\nahd_set_modes(ahd, i, i);\r\nsplit_status[i] = ahd_inb(ahd, DCHSPLTSTAT0);\r\nsplit_status1[i] = ahd_inb(ahd, DCHSPLTSTAT1);\r\nahd_outb(ahd, DCHSPLTSTAT0, split_status[i]);\r\nahd_outb(ahd, DCHSPLTSTAT1, split_status1[i]);\r\nif (i > 1)\r\ncontinue;\r\nsg_split_status[i] = ahd_inb(ahd, SGSPLTSTAT0);\r\nsg_split_status1[i] = ahd_inb(ahd, SGSPLTSTAT1);\r\nahd_outb(ahd, SGSPLTSTAT0, sg_split_status[i]);\r\nahd_outb(ahd, SGSPLTSTAT1, sg_split_status1[i]);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nu_int bit;\r\nfor (bit = 0; bit < 8; bit++) {\r\nif ((split_status[i] & (0x1 << bit)) != 0) {\r\nstatic const char *s;\r\ns = split_status_strings[bit];\r\nprintk(s, ahd_name(ahd),\r\nsplit_status_source[i]);\r\n}\r\nif (i > 1)\r\ncontinue;\r\nif ((sg_split_status[i] & (0x1 << bit)) != 0) {\r\nstatic const char *s;\r\ns = split_status_strings[bit];\r\nprintk(s, ahd_name(ahd), "SG");\r\n}\r\n}\r\n}\r\nahd_pci_write_config(ahd->dev_softc, PCIXR_STATUS,\r\npcix_status, 2);\r\nahd_outb(ahd, CLRINT, CLRSPLTINT);\r\nahd_restore_modes(ahd, saved_modes);\r\n}\r\nstatic int\r\nahd_aic7901_setup(struct ahd_softc *ahd)\r\n{\r\nahd->chip = AHD_AIC7901;\r\nahd->features = AHD_AIC7901_FE;\r\nreturn (ahd_aic790X_setup(ahd));\r\n}\r\nstatic int\r\nahd_aic7901A_setup(struct ahd_softc *ahd)\r\n{\r\nahd->chip = AHD_AIC7901A;\r\nahd->features = AHD_AIC7901A_FE;\r\nreturn (ahd_aic790X_setup(ahd));\r\n}\r\nstatic int\r\nahd_aic7902_setup(struct ahd_softc *ahd)\r\n{\r\nahd->chip = AHD_AIC7902;\r\nahd->features = AHD_AIC7902_FE;\r\nreturn (ahd_aic790X_setup(ahd));\r\n}\r\nstatic int\r\nahd_aic790X_setup(struct ahd_softc *ahd)\r\n{\r\nahd_dev_softc_t pci;\r\nu_int rev;\r\npci = ahd->dev_softc;\r\nrev = ahd_pci_read_config(pci, PCIR_REVID, 1);\r\nif (rev < ID_AIC7902_PCI_REV_A4) {\r\nprintk("%s: Unable to attach to unsupported chip revision %d\n",\r\nahd_name(ahd), rev);\r\nahd_pci_write_config(pci, PCIR_COMMAND, 0, 2);\r\nreturn (ENXIO);\r\n}\r\nahd->channel = ahd_get_pci_function(pci) + 'A';\r\nif (rev < ID_AIC7902_PCI_REV_B0) {\r\nahd->bugs |= AHD_SENT_SCB_UPDATE_BUG|AHD_ABORT_LQI_BUG\r\n| AHD_PKT_BITBUCKET_BUG|AHD_LONG_SETIMO_BUG\r\n| AHD_NLQICRC_DELAYED_BUG|AHD_SCSIRST_BUG\r\n| AHD_LQO_ATNO_BUG|AHD_AUTOFLUSH_BUG\r\n| AHD_CLRLQO_AUTOCLR_BUG|AHD_PCIX_MMAPIO_BUG\r\n| AHD_PCIX_CHIPRST_BUG|AHD_PCIX_SCBRAM_RD_BUG\r\n| AHD_PKTIZED_STATUS_BUG|AHD_PKT_LUN_BUG\r\n| AHD_MDFF_WSCBPTR_BUG|AHD_REG_SLOW_SETTLE_BUG\r\n| AHD_SET_MODE_BUG|AHD_BUSFREEREV_BUG\r\n| AHD_NONPACKFIFO_BUG|AHD_PACED_NEGTABLE_BUG\r\n| AHD_FAINT_LED_BUG;\r\nAHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);\r\nif ((ahd->flags & AHD_HP_BOARD) == 0)\r\nAHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVA);\r\n} else {\r\nextern uint32_t aic79xx_slowcrc;\r\nu_int devconfig1;\r\nahd->features |= AHD_RTI|AHD_NEW_IOCELL_OPTS\r\n| AHD_NEW_DFCNTRL_OPTS|AHD_FAST_CDB_DELIVERY\r\n| AHD_BUSFREEREV_BUG;\r\nahd->bugs |= AHD_LQOOVERRUN_BUG|AHD_EARLY_REQ_BUG;\r\nif (aic79xx_slowcrc)\r\nahd->features |= AHD_AIC79XXB_SLOWCRC;\r\nif ((ahd->features & AHD_MULTI_FUNC) != 0)\r\nahd->bugs |= AHD_INTCOLLISION_BUG|AHD_ABORT_LQI_BUG;\r\nAHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);\r\nAHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVB);\r\nAHD_SET_AMPLITUDE(ahd, AHD_AMPLITUDE_DEF);\r\ndevconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, 1);\r\nahd_pci_write_config(pci, DEVCONFIG1,\r\ndevconfig1|PREQDIS, 1);\r\ndevconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, 1);\r\n}\r\nreturn (0);\r\n}
