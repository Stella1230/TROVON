u64 cper_next_record_id(void)\r\n{\r\nstatic atomic64_t seq;\r\nif (!atomic64_read(&seq))\r\natomic64_set(&seq, ((u64)get_seconds()) << 32);\r\nreturn atomic64_inc_return(&seq);\r\n}\r\nstatic const char *cper_severity_str(unsigned int severity)\r\n{\r\nreturn severity < ARRAY_SIZE(cper_severity_strs) ?\r\ncper_severity_strs[severity] : "unknown";\r\n}\r\nvoid cper_print_bits(const char *pfx, unsigned int bits,\r\nconst char *strs[], unsigned int strs_size)\r\n{\r\nint i, len = 0;\r\nconst char *str;\r\nchar buf[84];\r\nfor (i = 0; i < strs_size; i++) {\r\nif (!(bits & (1U << i)))\r\ncontinue;\r\nstr = strs[i];\r\nif (!str)\r\ncontinue;\r\nif (len && len + strlen(str) + 2 > 80) {\r\nprintk("%s\n", buf);\r\nlen = 0;\r\n}\r\nif (!len)\r\nlen = snprintf(buf, sizeof(buf), "%s%s", pfx, str);\r\nelse\r\nlen += snprintf(buf+len, sizeof(buf)-len, ", %s", str);\r\n}\r\nif (len)\r\nprintk("%s\n", buf);\r\n}\r\nstatic void cper_print_proc_generic(const char *pfx,\r\nconst struct cper_sec_proc_generic *proc)\r\n{\r\nif (proc->validation_bits & CPER_PROC_VALID_TYPE)\r\nprintk("%s""processor_type: %d, %s\n", pfx, proc->proc_type,\r\nproc->proc_type < ARRAY_SIZE(cper_proc_type_strs) ?\r\ncper_proc_type_strs[proc->proc_type] : "unknown");\r\nif (proc->validation_bits & CPER_PROC_VALID_ISA)\r\nprintk("%s""processor_isa: %d, %s\n", pfx, proc->proc_isa,\r\nproc->proc_isa < ARRAY_SIZE(cper_proc_isa_strs) ?\r\ncper_proc_isa_strs[proc->proc_isa] : "unknown");\r\nif (proc->validation_bits & CPER_PROC_VALID_ERROR_TYPE) {\r\nprintk("%s""error_type: 0x%02x\n", pfx, proc->proc_error_type);\r\ncper_print_bits(pfx, proc->proc_error_type,\r\ncper_proc_error_type_strs,\r\nARRAY_SIZE(cper_proc_error_type_strs));\r\n}\r\nif (proc->validation_bits & CPER_PROC_VALID_OPERATION)\r\nprintk("%s""operation: %d, %s\n", pfx, proc->operation,\r\nproc->operation < ARRAY_SIZE(cper_proc_op_strs) ?\r\ncper_proc_op_strs[proc->operation] : "unknown");\r\nif (proc->validation_bits & CPER_PROC_VALID_FLAGS) {\r\nprintk("%s""flags: 0x%02x\n", pfx, proc->flags);\r\ncper_print_bits(pfx, proc->flags, cper_proc_flag_strs,\r\nARRAY_SIZE(cper_proc_flag_strs));\r\n}\r\nif (proc->validation_bits & CPER_PROC_VALID_LEVEL)\r\nprintk("%s""level: %d\n", pfx, proc->level);\r\nif (proc->validation_bits & CPER_PROC_VALID_VERSION)\r\nprintk("%s""version_info: 0x%016llx\n", pfx, proc->cpu_version);\r\nif (proc->validation_bits & CPER_PROC_VALID_ID)\r\nprintk("%s""processor_id: 0x%016llx\n", pfx, proc->proc_id);\r\nif (proc->validation_bits & CPER_PROC_VALID_TARGET_ADDRESS)\r\nprintk("%s""target_address: 0x%016llx\n",\r\npfx, proc->target_addr);\r\nif (proc->validation_bits & CPER_PROC_VALID_REQUESTOR_ID)\r\nprintk("%s""requestor_id: 0x%016llx\n",\r\npfx, proc->requestor_id);\r\nif (proc->validation_bits & CPER_PROC_VALID_RESPONDER_ID)\r\nprintk("%s""responder_id: 0x%016llx\n",\r\npfx, proc->responder_id);\r\nif (proc->validation_bits & CPER_PROC_VALID_IP)\r\nprintk("%s""IP: 0x%016llx\n", pfx, proc->ip);\r\n}\r\nstatic const char *cper_mem_err_type_strs[] = {\r\n"unknown",\r\n"no error",\r\n"single-bit ECC",\r\n"multi-bit ECC",\r\n"single-symbol chipkill ECC",\r\n"multi-symbol chipkill ECC",\r\n"master abort",\r\n"target abort",\r\n"parity error",\r\n"watchdog timeout",\r\n"invalid address",\r\n"mirror Broken",\r\n"memory sparing",\r\n"scrub corrected error",\r\n"scrub uncorrected error",\r\n};\r\nstatic void cper_print_mem(const char *pfx, const struct cper_sec_mem_err *mem)\r\n{\r\nif (mem->validation_bits & CPER_MEM_VALID_ERROR_STATUS)\r\nprintk("%s""error_status: 0x%016llx\n", pfx, mem->error_status);\r\nif (mem->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS)\r\nprintk("%s""physical_address: 0x%016llx\n",\r\npfx, mem->physical_addr);\r\nif (mem->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS_MASK)\r\nprintk("%s""physical_address_mask: 0x%016llx\n",\r\npfx, mem->physical_addr_mask);\r\nif (mem->validation_bits & CPER_MEM_VALID_NODE)\r\nprintk("%s""node: %d\n", pfx, mem->node);\r\nif (mem->validation_bits & CPER_MEM_VALID_CARD)\r\nprintk("%s""card: %d\n", pfx, mem->card);\r\nif (mem->validation_bits & CPER_MEM_VALID_MODULE)\r\nprintk("%s""module: %d\n", pfx, mem->module);\r\nif (mem->validation_bits & CPER_MEM_VALID_BANK)\r\nprintk("%s""bank: %d\n", pfx, mem->bank);\r\nif (mem->validation_bits & CPER_MEM_VALID_DEVICE)\r\nprintk("%s""device: %d\n", pfx, mem->device);\r\nif (mem->validation_bits & CPER_MEM_VALID_ROW)\r\nprintk("%s""row: %d\n", pfx, mem->row);\r\nif (mem->validation_bits & CPER_MEM_VALID_COLUMN)\r\nprintk("%s""column: %d\n", pfx, mem->column);\r\nif (mem->validation_bits & CPER_MEM_VALID_BIT_POSITION)\r\nprintk("%s""bit_position: %d\n", pfx, mem->bit_pos);\r\nif (mem->validation_bits & CPER_MEM_VALID_REQUESTOR_ID)\r\nprintk("%s""requestor_id: 0x%016llx\n", pfx, mem->requestor_id);\r\nif (mem->validation_bits & CPER_MEM_VALID_RESPONDER_ID)\r\nprintk("%s""responder_id: 0x%016llx\n", pfx, mem->responder_id);\r\nif (mem->validation_bits & CPER_MEM_VALID_TARGET_ID)\r\nprintk("%s""target_id: 0x%016llx\n", pfx, mem->target_id);\r\nif (mem->validation_bits & CPER_MEM_VALID_ERROR_TYPE) {\r\nu8 etype = mem->error_type;\r\nprintk("%s""error_type: %d, %s\n", pfx, etype,\r\netype < ARRAY_SIZE(cper_mem_err_type_strs) ?\r\ncper_mem_err_type_strs[etype] : "unknown");\r\n}\r\n}\r\nstatic const char *cper_pcie_port_type_strs[] = {\r\n"PCIe end point",\r\n"legacy PCI end point",\r\n"unknown",\r\n"unknown",\r\n"root port",\r\n"upstream switch port",\r\n"downstream switch port",\r\n"PCIe to PCI/PCI-X bridge",\r\n"PCI/PCI-X to PCIe bridge",\r\n"root complex integrated endpoint device",\r\n"root complex event collector",\r\n};\r\nstatic void cper_print_pcie(const char *pfx, const struct cper_sec_pcie *pcie,\r\nconst struct acpi_hest_generic_data *gdata)\r\n{\r\nif (pcie->validation_bits & CPER_PCIE_VALID_PORT_TYPE)\r\nprintk("%s""port_type: %d, %s\n", pfx, pcie->port_type,\r\npcie->port_type < ARRAY_SIZE(cper_pcie_port_type_strs) ?\r\ncper_pcie_port_type_strs[pcie->port_type] : "unknown");\r\nif (pcie->validation_bits & CPER_PCIE_VALID_VERSION)\r\nprintk("%s""version: %d.%d\n", pfx,\r\npcie->version.major, pcie->version.minor);\r\nif (pcie->validation_bits & CPER_PCIE_VALID_COMMAND_STATUS)\r\nprintk("%s""command: 0x%04x, status: 0x%04x\n", pfx,\r\npcie->command, pcie->status);\r\nif (pcie->validation_bits & CPER_PCIE_VALID_DEVICE_ID) {\r\nconst __u8 *p;\r\nprintk("%s""device_id: %04x:%02x:%02x.%x\n", pfx,\r\npcie->device_id.segment, pcie->device_id.bus,\r\npcie->device_id.device, pcie->device_id.function);\r\nprintk("%s""slot: %d\n", pfx,\r\npcie->device_id.slot >> CPER_PCIE_SLOT_SHIFT);\r\nprintk("%s""secondary_bus: 0x%02x\n", pfx,\r\npcie->device_id.secondary_bus);\r\nprintk("%s""vendor_id: 0x%04x, device_id: 0x%04x\n", pfx,\r\npcie->device_id.vendor_id, pcie->device_id.device_id);\r\np = pcie->device_id.class_code;\r\nprintk("%s""class_code: %02x%02x%02x\n", pfx, p[0], p[1], p[2]);\r\n}\r\nif (pcie->validation_bits & CPER_PCIE_VALID_SERIAL_NUMBER)\r\nprintk("%s""serial number: 0x%04x, 0x%04x\n", pfx,\r\npcie->serial_number.lower, pcie->serial_number.upper);\r\nif (pcie->validation_bits & CPER_PCIE_VALID_BRIDGE_CONTROL_STATUS)\r\nprintk(\r\n"%s""bridge: secondary_status: 0x%04x, control: 0x%04x\n",\r\npfx, pcie->bridge.secondary_status, pcie->bridge.control);\r\n}\r\nstatic const char *apei_estatus_section_flag_strs[] = {\r\n"primary",\r\n"containment warning",\r\n"reset",\r\n"threshold exceeded",\r\n"resource not accessible",\r\n"latent error",\r\n};\r\nstatic void apei_estatus_print_section(\r\nconst char *pfx, const struct acpi_hest_generic_data *gdata, int sec_no)\r\n{\r\nuuid_le *sec_type = (uuid_le *)gdata->section_type;\r\n__u16 severity;\r\nseverity = gdata->error_severity;\r\nprintk("%s""section: %d, severity: %d, %s\n", pfx, sec_no, severity,\r\ncper_severity_str(severity));\r\nprintk("%s""flags: 0x%02x\n", pfx, gdata->flags);\r\ncper_print_bits(pfx, gdata->flags, apei_estatus_section_flag_strs,\r\nARRAY_SIZE(apei_estatus_section_flag_strs));\r\nif (gdata->validation_bits & CPER_SEC_VALID_FRU_ID)\r\nprintk("%s""fru_id: %pUl\n", pfx, (uuid_le *)gdata->fru_id);\r\nif (gdata->validation_bits & CPER_SEC_VALID_FRU_TEXT)\r\nprintk("%s""fru_text: %.20s\n", pfx, gdata->fru_text);\r\nif (!uuid_le_cmp(*sec_type, CPER_SEC_PROC_GENERIC)) {\r\nstruct cper_sec_proc_generic *proc_err = (void *)(gdata + 1);\r\nprintk("%s""section_type: general processor error\n", pfx);\r\nif (gdata->error_data_length >= sizeof(*proc_err))\r\ncper_print_proc_generic(pfx, proc_err);\r\nelse\r\ngoto err_section_too_small;\r\n} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PLATFORM_MEM)) {\r\nstruct cper_sec_mem_err *mem_err = (void *)(gdata + 1);\r\nprintk("%s""section_type: memory error\n", pfx);\r\nif (gdata->error_data_length >= sizeof(*mem_err))\r\ncper_print_mem(pfx, mem_err);\r\nelse\r\ngoto err_section_too_small;\r\n} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PCIE)) {\r\nstruct cper_sec_pcie *pcie = (void *)(gdata + 1);\r\nprintk("%s""section_type: PCIe error\n", pfx);\r\nif (gdata->error_data_length >= sizeof(*pcie))\r\ncper_print_pcie(pfx, pcie, gdata);\r\nelse\r\ngoto err_section_too_small;\r\n} else\r\nprintk("%s""section type: unknown, %pUl\n", pfx, sec_type);\r\nreturn;\r\nerr_section_too_small:\r\npr_err(FW_WARN "error section length is too small\n");\r\n}\r\nvoid apei_estatus_print(const char *pfx,\r\nconst struct acpi_hest_generic_status *estatus)\r\n{\r\nstruct acpi_hest_generic_data *gdata;\r\nunsigned int data_len, gedata_len;\r\nint sec_no = 0;\r\n__u16 severity;\r\nprintk("%s""APEI generic hardware error status\n", pfx);\r\nseverity = estatus->error_severity;\r\nprintk("%s""severity: %d, %s\n"
