static int cpu0_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy, freq_table);\r\n}\r\nstatic unsigned int cpu0_get_speed(unsigned int cpu)\r\n{\r\nreturn clk_get_rate(cpu_clk) / 1000;\r\n}\r\nstatic int cpu0_set_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq, unsigned int relation)\r\n{\r\nstruct cpufreq_freqs freqs;\r\nstruct opp *opp;\r\nunsigned long volt = 0, volt_old = 0, tol = 0;\r\nlong freq_Hz, freq_exact;\r\nunsigned int index;\r\nint ret;\r\nret = cpufreq_frequency_table_target(policy, freq_table, target_freq,\r\nrelation, &index);\r\nif (ret) {\r\npr_err("failed to match target freqency %d: %d\n",\r\ntarget_freq, ret);\r\nreturn ret;\r\n}\r\nfreq_Hz = clk_round_rate(cpu_clk, freq_table[index].frequency * 1000);\r\nif (freq_Hz < 0)\r\nfreq_Hz = freq_table[index].frequency * 1000;\r\nfreq_exact = freq_Hz;\r\nfreqs.new = freq_Hz / 1000;\r\nfreqs.old = clk_get_rate(cpu_clk) / 1000;\r\nif (freqs.old == freqs.new)\r\nreturn 0;\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);\r\nif (cpu_reg) {\r\nrcu_read_lock();\r\nopp = opp_find_freq_ceil(cpu_dev, &freq_Hz);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\npr_err("failed to find OPP for %ld\n", freq_Hz);\r\nfreqs.new = freqs.old;\r\nret = PTR_ERR(opp);\r\ngoto post_notify;\r\n}\r\nvolt = opp_get_voltage(opp);\r\nrcu_read_unlock();\r\ntol = volt * voltage_tolerance / 100;\r\nvolt_old = regulator_get_voltage(cpu_reg);\r\n}\r\npr_debug("%u MHz, %ld mV --> %u MHz, %ld mV\n",\r\nfreqs.old / 1000, volt_old ? volt_old / 1000 : -1,\r\nfreqs.new / 1000, volt ? volt / 1000 : -1);\r\nif (cpu_reg && freqs.new > freqs.old) {\r\nret = regulator_set_voltage_tol(cpu_reg, volt, tol);\r\nif (ret) {\r\npr_err("failed to scale voltage up: %d\n", ret);\r\nfreqs.new = freqs.old;\r\ngoto post_notify;\r\n}\r\n}\r\nret = clk_set_rate(cpu_clk, freq_exact);\r\nif (ret) {\r\npr_err("failed to set clock rate: %d\n", ret);\r\nif (cpu_reg)\r\nregulator_set_voltage_tol(cpu_reg, volt_old, tol);\r\nfreqs.new = freqs.old;\r\ngoto post_notify;\r\n}\r\nif (cpu_reg && freqs.new < freqs.old) {\r\nret = regulator_set_voltage_tol(cpu_reg, volt, tol);\r\nif (ret) {\r\npr_err("failed to scale voltage down: %d\n", ret);\r\nclk_set_rate(cpu_clk, freqs.old * 1000);\r\nfreqs.new = freqs.old;\r\n}\r\n}\r\npost_notify:\r\ncpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);\r\nreturn ret;\r\n}\r\nstatic int cpu0_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nint ret;\r\nret = cpufreq_frequency_table_cpuinfo(policy, freq_table);\r\nif (ret) {\r\npr_err("invalid frequency table: %d\n", ret);\r\nreturn ret;\r\n}\r\npolicy->cpuinfo.transition_latency = transition_latency;\r\npolicy->cur = clk_get_rate(cpu_clk) / 1000;\r\ncpumask_setall(policy->cpus);\r\ncpufreq_frequency_table_get_attr(freq_table, policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int cpu0_cpufreq_exit(struct cpufreq_policy *policy)\r\n{\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int cpu0_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np, *parent;\r\nint ret;\r\nparent = of_find_node_by_path("/cpus");\r\nif (!parent) {\r\npr_err("failed to find OF /cpus\n");\r\nreturn -ENOENT;\r\n}\r\nfor_each_child_of_node(parent, np) {\r\nif (of_get_property(np, "operating-points", NULL))\r\nbreak;\r\n}\r\nif (!np) {\r\npr_err("failed to find cpu0 node\n");\r\nret = -ENOENT;\r\ngoto out_put_parent;\r\n}\r\ncpu_dev = &pdev->dev;\r\ncpu_dev->of_node = np;\r\ncpu_reg = devm_regulator_get(cpu_dev, "cpu0");\r\nif (IS_ERR(cpu_reg)) {\r\nif (PTR_ERR(cpu_reg) == -EPROBE_DEFER) {\r\ndev_err(cpu_dev, "cpu0 regulator not ready, retry\n");\r\nret = -EPROBE_DEFER;\r\ngoto out_put_node;\r\n}\r\npr_warn("failed to get cpu0 regulator: %ld\n",\r\nPTR_ERR(cpu_reg));\r\ncpu_reg = NULL;\r\n}\r\ncpu_clk = devm_clk_get(cpu_dev, NULL);\r\nif (IS_ERR(cpu_clk)) {\r\nret = PTR_ERR(cpu_clk);\r\npr_err("failed to get cpu0 clock: %d\n", ret);\r\ngoto out_put_node;\r\n}\r\nret = of_init_opp_table(cpu_dev);\r\nif (ret) {\r\npr_err("failed to init OPP table: %d\n", ret);\r\ngoto out_put_node;\r\n}\r\nret = opp_init_cpufreq_table(cpu_dev, &freq_table);\r\nif (ret) {\r\npr_err("failed to init cpufreq table: %d\n", ret);\r\ngoto out_put_node;\r\n}\r\nof_property_read_u32(np, "voltage-tolerance", &voltage_tolerance);\r\nif (of_property_read_u32(np, "clock-latency", &transition_latency))\r\ntransition_latency = CPUFREQ_ETERNAL;\r\nif (cpu_reg) {\r\nstruct opp *opp;\r\nunsigned long min_uV, max_uV;\r\nint i;\r\nfor (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++)\r\n;\r\nrcu_read_lock();\r\nopp = opp_find_freq_exact(cpu_dev,\r\nfreq_table[0].frequency * 1000, true);\r\nmin_uV = opp_get_voltage(opp);\r\nopp = opp_find_freq_exact(cpu_dev,\r\nfreq_table[i-1].frequency * 1000, true);\r\nmax_uV = opp_get_voltage(opp);\r\nrcu_read_unlock();\r\nret = regulator_set_voltage_time(cpu_reg, min_uV, max_uV);\r\nif (ret > 0)\r\ntransition_latency += ret * 1000;\r\n}\r\nret = cpufreq_register_driver(&cpu0_cpufreq_driver);\r\nif (ret) {\r\npr_err("failed register driver: %d\n", ret);\r\ngoto out_free_table;\r\n}\r\nof_node_put(np);\r\nof_node_put(parent);\r\nreturn 0;\r\nout_free_table:\r\nopp_free_cpufreq_table(cpu_dev, &freq_table);\r\nout_put_node:\r\nof_node_put(np);\r\nout_put_parent:\r\nof_node_put(parent);\r\nreturn ret;\r\n}\r\nstatic int cpu0_cpufreq_remove(struct platform_device *pdev)\r\n{\r\ncpufreq_unregister_driver(&cpu0_cpufreq_driver);\r\nopp_free_cpufreq_table(cpu_dev, &freq_table);\r\nreturn 0;\r\n}
