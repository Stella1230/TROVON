static int amd_create_page_map(struct amd_page_map *page_map)\r\n{\r\nint i;\r\npage_map->real = (unsigned long *) __get_free_page(GFP_KERNEL);\r\nif (page_map->real == NULL)\r\nreturn -ENOMEM;\r\nset_memory_uc((unsigned long)page_map->real, 1);\r\npage_map->remapped = page_map->real;\r\nfor (i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++) {\r\nwritel(agp_bridge->scratch_page, page_map->remapped+i);\r\nreadl(page_map->remapped+i);\r\n}\r\nreturn 0;\r\n}\r\nstatic void amd_free_page_map(struct amd_page_map *page_map)\r\n{\r\nset_memory_wb((unsigned long)page_map->real, 1);\r\nfree_page((unsigned long) page_map->real);\r\n}\r\nstatic void amd_free_gatt_pages(void)\r\n{\r\nint i;\r\nstruct amd_page_map **tables;\r\nstruct amd_page_map *entry;\r\ntables = amd_irongate_private.gatt_pages;\r\nfor (i = 0; i < amd_irongate_private.num_tables; i++) {\r\nentry = tables[i];\r\nif (entry != NULL) {\r\nif (entry->real != NULL)\r\namd_free_page_map(entry);\r\nkfree(entry);\r\n}\r\n}\r\nkfree(tables);\r\namd_irongate_private.gatt_pages = NULL;\r\n}\r\nstatic int amd_create_gatt_pages(int nr_tables)\r\n{\r\nstruct amd_page_map **tables;\r\nstruct amd_page_map *entry;\r\nint retval = 0;\r\nint i;\r\ntables = kzalloc((nr_tables + 1) * sizeof(struct amd_page_map *),GFP_KERNEL);\r\nif (tables == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nr_tables; i++) {\r\nentry = kzalloc(sizeof(struct amd_page_map), GFP_KERNEL);\r\ntables[i] = entry;\r\nif (entry == NULL) {\r\nretval = -ENOMEM;\r\nbreak;\r\n}\r\nretval = amd_create_page_map(entry);\r\nif (retval != 0)\r\nbreak;\r\n}\r\namd_irongate_private.num_tables = i;\r\namd_irongate_private.gatt_pages = tables;\r\nif (retval != 0)\r\namd_free_gatt_pages();\r\nreturn retval;\r\n}\r\nstatic int amd_create_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct aper_size_info_lvl2 *value;\r\nstruct amd_page_map page_dir;\r\nunsigned long __iomem *cur_gatt;\r\nunsigned long addr;\r\nint retval;\r\nu32 temp;\r\nint i;\r\nvalue = A_SIZE_LVL2(agp_bridge->current_size);\r\nretval = amd_create_page_map(&page_dir);\r\nif (retval != 0)\r\nreturn retval;\r\nretval = amd_create_gatt_pages(value->num_entries / 1024);\r\nif (retval != 0) {\r\namd_free_page_map(&page_dir);\r\nreturn retval;\r\n}\r\nagp_bridge->gatt_table_real = (u32 *)page_dir.real;\r\nagp_bridge->gatt_table = (u32 __iomem *)page_dir.remapped;\r\nagp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);\r\npci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);\r\naddr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\nagp_bridge->gart_bus_addr = addr;\r\nfor (i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {\r\nwritel(virt_to_phys(amd_irongate_private.gatt_pages[i]->real) | 1,\r\npage_dir.remapped+GET_PAGE_DIR_OFF(addr));\r\nreadl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));\r\n}\r\nfor (i = 0; i < value->num_entries; i++) {\r\naddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = GET_GATT(addr);\r\nwritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\r\nreadl(cur_gatt+GET_GATT_OFF(addr));\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd_free_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct amd_page_map page_dir;\r\npage_dir.real = (unsigned long *)agp_bridge->gatt_table_real;\r\npage_dir.remapped = (unsigned long __iomem *)agp_bridge->gatt_table;\r\namd_free_gatt_pages();\r\namd_free_page_map(&page_dir);\r\nreturn 0;\r\n}\r\nstatic int amd_irongate_fetch_size(void)\r\n{\r\nint i;\r\nu32 temp;\r\nstruct aper_size_info_lvl2 *values;\r\npci_read_config_dword(agp_bridge->dev, AMD_APSIZE, &temp);\r\ntemp = (temp & 0x0000000e);\r\nvalues = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (temp == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd_irongate_configure(void)\r\n{\r\nstruct aper_size_info_lvl2 *current_size;\r\nu32 temp;\r\nu16 enable_reg;\r\ncurrent_size = A_SIZE_LVL2(agp_bridge->current_size);\r\nif (!amd_irongate_private.registers) {\r\npci_read_config_dword(agp_bridge->dev, AMD_MMBASE, &temp);\r\ntemp = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\namd_irongate_private.registers = (volatile u8 __iomem *) ioremap(temp, 4096);\r\nif (!amd_irongate_private.registers)\r\nreturn -ENOMEM;\r\n}\r\nwritel(agp_bridge->gatt_bus_addr, amd_irongate_private.registers+AMD_ATTBASE);\r\nreadl(amd_irongate_private.registers+AMD_ATTBASE);\r\npci_write_config_byte(agp_bridge->dev, AMD_MODECNTL, 0x80);\r\npci_write_config_byte(agp_bridge->dev, AMD_MODECNTL2, 0x00);\r\nenable_reg = readw(amd_irongate_private.registers+AMD_GARTENABLE);\r\nenable_reg = (enable_reg | 0x0004);\r\nwritew(enable_reg, amd_irongate_private.registers+AMD_GARTENABLE);\r\nreadw(amd_irongate_private.registers+AMD_GARTENABLE);\r\npci_read_config_dword(agp_bridge->dev, AMD_APSIZE, &temp);\r\ntemp = (((temp & ~(0x0000000e)) | current_size->size_value) | 1);\r\npci_write_config_dword(agp_bridge->dev, AMD_APSIZE, temp);\r\nwritel(1, amd_irongate_private.registers+AMD_TLBFLUSH);\r\nreadl(amd_irongate_private.registers+AMD_TLBFLUSH);\r\nreturn 0;\r\n}\r\nstatic void amd_irongate_cleanup(void)\r\n{\r\nstruct aper_size_info_lvl2 *previous_size;\r\nu32 temp;\r\nu16 enable_reg;\r\nprevious_size = A_SIZE_LVL2(agp_bridge->previous_size);\r\nenable_reg = readw(amd_irongate_private.registers+AMD_GARTENABLE);\r\nenable_reg = (enable_reg & ~(0x0004));\r\nwritew(enable_reg, amd_irongate_private.registers+AMD_GARTENABLE);\r\nreadw(amd_irongate_private.registers+AMD_GARTENABLE);\r\npci_read_config_dword(agp_bridge->dev, AMD_APSIZE, &temp);\r\ntemp = ((temp & ~(0x0000000f)) | previous_size->size_value);\r\npci_write_config_dword(agp_bridge->dev, AMD_APSIZE, temp);\r\niounmap((void __iomem *) amd_irongate_private.registers);\r\n}\r\nstatic void amd_irongate_tlbflush(struct agp_memory *temp)\r\n{\r\nwritel(1, amd_irongate_private.registers+AMD_TLBFLUSH);\r\nreadl(amd_irongate_private.registers+AMD_TLBFLUSH);\r\n}\r\nstatic int amd_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nint i, j, num_entries;\r\nunsigned long __iomem *cur_gatt;\r\nunsigned long addr;\r\nnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\r\nif (type != mem->type ||\r\nagp_bridge->driver->agp_type_to_mask_type(agp_bridge, type))\r\nreturn -EINVAL;\r\nif ((pg_start + mem->page_count) > num_entries)\r\nreturn -EINVAL;\r\nj = pg_start;\r\nwhile (j < (pg_start + mem->page_count)) {\r\naddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = GET_GATT(addr);\r\nif (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))\r\nreturn -EBUSY;\r\nj++;\r\n}\r\nif (!mem->is_flushed) {\r\nglobal_cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\r\naddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = GET_GATT(addr);\r\nwritel(agp_generic_mask_memory(agp_bridge,\r\npage_to_phys(mem->pages[i]),\r\nmem->type),\r\ncur_gatt+GET_GATT_OFF(addr));\r\nreadl(cur_gatt+GET_GATT_OFF(addr));\r\n}\r\namd_irongate_tlbflush(mem);\r\nreturn 0;\r\n}\r\nstatic int amd_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nint i;\r\nunsigned long __iomem *cur_gatt;\r\nunsigned long addr;\r\nif (type != mem->type ||\r\nagp_bridge->driver->agp_type_to_mask_type(agp_bridge, type))\r\nreturn -EINVAL;\r\nfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\r\naddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = GET_GATT(addr);\r\nwritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\r\nreadl(cur_gatt+GET_GATT_OFF(addr));\r\n}\r\namd_irongate_tlbflush(mem);\r\nreturn 0;\r\n}\r\nstatic int agp_amdk7_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nu8 cap_ptr;\r\nint j;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\nj = ent - agp_amdk7_pci_table;\r\ndev_info(&pdev->dev, "AMD %s chipset\n",\r\namd_agp_device_ids[j].chipset_name);\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->driver = &amd_irongate_driver;\r\nbridge->dev_private_data = &amd_irongate_private,\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\nif (agp_bridge->dev->device == PCI_DEVICE_ID_AMD_FE_GATE_7006) {\r\nstruct pci_dev *gfxcard=NULL;\r\ncap_ptr = 0;\r\nwhile (!cap_ptr) {\r\ngfxcard = pci_get_class(PCI_CLASS_DISPLAY_VGA<<8, gfxcard);\r\nif (!gfxcard) {\r\ndev_info(&pdev->dev, "no AGP VGA controller\n");\r\nreturn -ENODEV;\r\n}\r\ncap_ptr = pci_find_capability(gfxcard, PCI_CAP_ID_AGP);\r\n}\r\nif (gfxcard->vendor == PCI_VENDOR_ID_NVIDIA) {\r\nagp_bridge->flags |= AGP_ERRATA_1X;\r\ndev_info(&pdev->dev, "AMD 751 chipset with NVidia GeForce; forcing 1X due to errata\n");\r\n}\r\npci_dev_put(gfxcard);\r\n}\r\nif (agp_bridge->dev->device == PCI_DEVICE_ID_AMD_FE_GATE_700E) {\r\nif (pdev->revision == 0x10 || pdev->revision == 0x11) {\r\nagp_bridge->flags = AGP_ERRATA_FASTWRITES;\r\nagp_bridge->flags |= AGP_ERRATA_SBA;\r\nagp_bridge->flags |= AGP_ERRATA_1X;\r\ndev_info(&pdev->dev, "AMD 761 chipset with errata; disabling AGP fast writes & SBA and forcing to 1X\n");\r\n}\r\n}\r\npci_read_config_dword(pdev,\r\nbridge->capndx+PCI_AGP_STATUS,\r\n&bridge->mode);\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void agp_amdk7_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int agp_amdk7_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int agp_amdk7_resume(struct pci_dev *pdev)\r\n{\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nreturn amd_irongate_driver.configure();\r\n}\r\nstatic int __init agp_amdk7_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_amdk7_pci_driver);\r\n}\r\nstatic void __exit agp_amdk7_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_amdk7_pci_driver);\r\n}
