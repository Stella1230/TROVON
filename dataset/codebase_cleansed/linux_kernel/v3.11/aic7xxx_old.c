static unsigned char\r\naic_inb(struct aic7xxx_host *p, long port)\r\n{\r\n#ifdef MMAPIO\r\nunsigned char x;\r\nif(p->maddr)\r\n{\r\nx = readb(p->maddr + port);\r\n}\r\nelse\r\n{\r\nx = inb(p->base + port);\r\n}\r\nreturn(x);\r\n#else\r\nreturn(inb(p->base + port));\r\n#endif\r\n}\r\nstatic void\r\naic_outb(struct aic7xxx_host *p, unsigned char val, long port)\r\n{\r\n#ifdef MMAPIO\r\nif(p->maddr)\r\n{\r\nwriteb(val, p->maddr + port);\r\nmb();\r\nreadb(p->maddr + HCNTRL);\r\n}\r\nelse\r\n{\r\noutb(val, p->base + port);\r\nmb();\r\n}\r\n#else\r\noutb(val, p->base + port);\r\nmb();\r\n#endif\r\n}\r\nstatic int\r\naic7xxx_setup(char *s)\r\n{\r\nint i, n;\r\nchar *p;\r\nchar *end;\r\nstatic struct {\r\nconst char *name;\r\nunsigned int *flag;\r\n} options[] = {\r\n{ "extended", &aic7xxx_extended },\r\n{ "no_reset", &aic7xxx_no_reset },\r\n{ "irq_trigger", &aic7xxx_irq_trigger },\r\n{ "verbose", &aic7xxx_verbose },\r\n{ "reverse_scan",&aic7xxx_reverse_scan },\r\n{ "override_term", &aic7xxx_override_term },\r\n{ "stpwlev", &aic7xxx_stpwlev },\r\n{ "no_probe", &aic7xxx_no_probe },\r\n{ "panic_on_abort", &aic7xxx_panic_on_abort },\r\n{ "pci_parity", &aic7xxx_pci_parity },\r\n{ "dump_card", &aic7xxx_dump_card },\r\n{ "dump_sequencer", &aic7xxx_dump_sequencer },\r\n{ "default_queue_depth", &aic7xxx_default_queue_depth },\r\n{ "scbram", &aic7xxx_scbram },\r\n{ "seltime", &aic7xxx_seltime },\r\n{ "tag_info", NULL }\r\n};\r\nend = strchr(s, '\0');\r\nwhile ((p = strsep(&s, ",.")) != NULL)\r\n{\r\nfor (i = 0; i < ARRAY_SIZE(options); i++)\r\n{\r\nn = strlen(options[i].name);\r\nif (!strncmp(options[i].name, p, n))\r\n{\r\nif (!strncmp(p, "tag_info", n))\r\n{\r\nif (p[n] == ':')\r\n{\r\nchar *base;\r\nchar *tok, *tok_end, *tok_end2;\r\nchar tok_list[] = { '.', ',', '{', '}', '\0' };\r\nint i, instance = -1, device = -1;\r\nunsigned char done = FALSE;\r\nbase = p;\r\ntok = base + n + 1;\r\ntok_end = strchr(tok, '\0');\r\nif (tok_end < end)\r\n*tok_end = ',';\r\nwhile(!done)\r\n{\r\nswitch(*tok)\r\n{\r\ncase '{':\r\nif (instance == -1)\r\ninstance = 0;\r\nelse if (device == -1)\r\ndevice = 0;\r\ntok++;\r\nbreak;\r\ncase '}':\r\nif (device != -1)\r\ndevice = -1;\r\nelse if (instance != -1)\r\ninstance = -1;\r\ntok++;\r\nbreak;\r\ncase ',':\r\ncase '.':\r\nif (instance == -1)\r\ndone = TRUE;\r\nelse if (device >= 0)\r\ndevice++;\r\nelse if (instance >= 0)\r\ninstance++;\r\nif ( (device >= MAX_TARGETS) ||\r\n(instance >= ARRAY_SIZE(aic7xxx_tag_info)) )\r\ndone = TRUE;\r\ntok++;\r\nif (!done)\r\n{\r\nbase = tok;\r\n}\r\nbreak;\r\ncase '\0':\r\ndone = TRUE;\r\nbreak;\r\ndefault:\r\ndone = TRUE;\r\ntok_end = strchr(tok, '\0');\r\nfor(i=0; tok_list[i]; i++)\r\n{\r\ntok_end2 = strchr(tok, tok_list[i]);\r\nif ( (tok_end2) && (tok_end2 < tok_end) )\r\n{\r\ntok_end = tok_end2;\r\ndone = FALSE;\r\n}\r\n}\r\nif ( (instance >= 0) && (device >= 0) &&\r\n(instance < ARRAY_SIZE(aic7xxx_tag_info)) &&\r\n(device < MAX_TARGETS) )\r\naic7xxx_tag_info[instance].tag_commands[device] =\r\nsimple_strtoul(tok, NULL, 0) & 0xff;\r\ntok = tok_end;\r\nbreak;\r\n}\r\n}\r\nwhile((p != base) && (p != NULL))\r\np = strsep(&s, ",.");\r\n}\r\n}\r\nelse if (p[n] == ':')\r\n{\r\n*(options[i].flag) = simple_strtoul(p + n + 1, NULL, 0);\r\nif(!strncmp(p, "seltime", n))\r\n{\r\n*(options[i].flag) = (*(options[i].flag) % 4) << 3;\r\n}\r\n}\r\nelse if (!strncmp(p, "verbose", n))\r\n{\r\n*(options[i].flag) = 0xff29;\r\n}\r\nelse\r\n{\r\n*(options[i].flag) = ~(*(options[i].flag));\r\nif(!strncmp(p, "seltime", n))\r\n{\r\n*(options[i].flag) = (*(options[i].flag) % 4) << 3;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\npause_sequencer(struct aic7xxx_host *p)\r\n{\r\naic_outb(p, p->pause, HCNTRL);\r\nwhile ((aic_inb(p, HCNTRL) & PAUSE) == 0)\r\n{\r\n;\r\n}\r\nif(p->features & AHC_ULTRA2)\r\n{\r\naic_inb(p, CCSCBCTL);\r\n}\r\n}\r\nstatic void\r\nunpause_sequencer(struct aic7xxx_host *p, int unpause_always)\r\n{\r\nif (unpause_always ||\r\n( !(aic_inb(p, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) &&\r\n!(p->flags & AHC_HANDLING_REQINITS) ) )\r\n{\r\naic_outb(p, p->unpause, HCNTRL);\r\n}\r\n}\r\nstatic void\r\nrestart_sequencer(struct aic7xxx_host *p)\r\n{\r\naic_outb(p, 0, SEQADDR0);\r\naic_outb(p, 0, SEQADDR1);\r\naic_outb(p, FASTMODE, SEQCTL);\r\n}\r\nstatic int\r\naic7xxx_check_patch(struct aic7xxx_host *p,\r\nstruct sequencer_patch **start_patch, int start_instr, int *skip_addr)\r\n{\r\nstruct sequencer_patch *cur_patch;\r\nstruct sequencer_patch *last_patch;\r\nint num_patches;\r\nnum_patches = ARRAY_SIZE(sequencer_patches);\r\nlast_patch = &sequencer_patches[num_patches];\r\ncur_patch = *start_patch;\r\nwhile ((cur_patch < last_patch) && (start_instr == cur_patch->begin))\r\n{\r\nif (cur_patch->patch_func(p) == 0)\r\n{\r\n*skip_addr = start_instr + cur_patch->skip_instr;\r\ncur_patch += cur_patch->skip_patch;\r\n}\r\nelse\r\n{\r\ncur_patch++;\r\n}\r\n}\r\n*start_patch = cur_patch;\r\nif (start_instr < *skip_addr)\r\nreturn (0);\r\nreturn(1);\r\n}\r\nstatic void\r\naic7xxx_download_instr(struct aic7xxx_host *p, int instrptr,\r\nunsigned char *dconsts)\r\n{\r\nunion ins_formats instr;\r\nstruct ins_format1 *fmt1_ins;\r\nstruct ins_format3 *fmt3_ins;\r\nunsigned char opcode;\r\ninstr = *(union ins_formats*) &seqprog[instrptr * 4];\r\ninstr.integer = le32_to_cpu(instr.integer);\r\nfmt1_ins = &instr.format1;\r\nfmt3_ins = NULL;\r\nopcode = instr.format1.opcode;\r\nswitch (opcode)\r\n{\r\ncase AIC_OP_JMP:\r\ncase AIC_OP_JC:\r\ncase AIC_OP_JNC:\r\ncase AIC_OP_CALL:\r\ncase AIC_OP_JNE:\r\ncase AIC_OP_JNZ:\r\ncase AIC_OP_JE:\r\ncase AIC_OP_JZ:\r\n{\r\nstruct sequencer_patch *cur_patch;\r\nint address_offset;\r\nunsigned int address;\r\nint skip_addr;\r\nint i;\r\nfmt3_ins = &instr.format3;\r\naddress_offset = 0;\r\naddress = fmt3_ins->address;\r\ncur_patch = sequencer_patches;\r\nskip_addr = 0;\r\nfor (i = 0; i < address;)\r\n{\r\naic7xxx_check_patch(p, &cur_patch, i, &skip_addr);\r\nif (skip_addr > i)\r\n{\r\nint end_addr;\r\nend_addr = min_t(int, address, skip_addr);\r\naddress_offset += end_addr - i;\r\ni = skip_addr;\r\n}\r\nelse\r\n{\r\ni++;\r\n}\r\n}\r\naddress -= address_offset;\r\nfmt3_ins->address = address;\r\n}\r\ncase AIC_OP_OR:\r\ncase AIC_OP_AND:\r\ncase AIC_OP_XOR:\r\ncase AIC_OP_ADD:\r\ncase AIC_OP_ADC:\r\ncase AIC_OP_BMOV:\r\nif (fmt1_ins->parity != 0)\r\n{\r\nfmt1_ins->immediate = dconsts[fmt1_ins->immediate];\r\n}\r\nfmt1_ins->parity = 0;\r\ncase AIC_OP_ROL:\r\nif ((p->features & AHC_ULTRA2) != 0)\r\n{\r\nint i, count;\r\nfor ( i=0, count=0; i < 31; i++)\r\n{\r\nunsigned int mask;\r\nmask = 0x01 << i;\r\nif ((instr.integer & mask) != 0)\r\ncount++;\r\n}\r\nif (!(count & 0x01))\r\ninstr.format1.parity = 1;\r\n}\r\nelse\r\n{\r\nif (fmt3_ins != NULL)\r\n{\r\ninstr.integer = fmt3_ins->immediate |\r\n(fmt3_ins->source << 8) |\r\n(fmt3_ins->address << 16) |\r\n(fmt3_ins->opcode << 25);\r\n}\r\nelse\r\n{\r\ninstr.integer = fmt1_ins->immediate |\r\n(fmt1_ins->source << 8) |\r\n(fmt1_ins->destination << 16) |\r\n(fmt1_ins->ret << 24) |\r\n(fmt1_ins->opcode << 25);\r\n}\r\n}\r\naic_outb(p, (instr.integer & 0xff), SEQRAM);\r\naic_outb(p, ((instr.integer >> 8) & 0xff), SEQRAM);\r\naic_outb(p, ((instr.integer >> 16) & 0xff), SEQRAM);\r\naic_outb(p, ((instr.integer >> 24) & 0xff), SEQRAM);\r\nudelay(10);\r\nbreak;\r\ndefault:\r\npanic("aic7xxx: Unknown opcode encountered in sequencer program.");\r\nbreak;\r\n}\r\n}\r\nstatic void\r\naic7xxx_loadseq(struct aic7xxx_host *p)\r\n{\r\nstruct sequencer_patch *cur_patch;\r\nint i;\r\nint downloaded;\r\nint skip_addr;\r\nunsigned char download_consts[4] = {0, 0, 0, 0};\r\nif (aic7xxx_verbose & VERBOSE_PROBE)\r\n{\r\nprintk(KERN_INFO "(scsi%d) Downloading sequencer code...", p->host_no);\r\n}\r\n#if 0\r\ndownload_consts[TMODE_NUMCMDS] = p->num_targetcmds;\r\n#endif\r\ndownload_consts[TMODE_NUMCMDS] = 0;\r\ncur_patch = &sequencer_patches[0];\r\ndownloaded = 0;\r\nskip_addr = 0;\r\naic_outb(p, PERRORDIS|LOADRAM|FAILDIS|FASTMODE, SEQCTL);\r\naic_outb(p, 0, SEQADDR0);\r\naic_outb(p, 0, SEQADDR1);\r\nfor (i = 0; i < sizeof(seqprog) / 4; i++)\r\n{\r\nif (aic7xxx_check_patch(p, &cur_patch, i, &skip_addr) == 0)\r\n{\r\ncontinue;\r\n}\r\naic7xxx_download_instr(p, i, &download_consts[0]);\r\ndownloaded++;\r\n}\r\naic_outb(p, 0, SEQADDR0);\r\naic_outb(p, 0, SEQADDR1);\r\naic_outb(p, FASTMODE | FAILDIS, SEQCTL);\r\nunpause_sequencer(p, TRUE);\r\nmdelay(1);\r\npause_sequencer(p);\r\naic_outb(p, FASTMODE, SEQCTL);\r\nif (aic7xxx_verbose & VERBOSE_PROBE)\r\n{\r\nprintk(" %d instructions downloaded\n", downloaded);\r\n}\r\nif (aic7xxx_dump_sequencer)\r\naic7xxx_print_sequencer(p, downloaded);\r\n}\r\nstatic void\r\naic7xxx_print_sequencer(struct aic7xxx_host *p, int downloaded)\r\n{\r\nint i, k, temp;\r\naic_outb(p, PERRORDIS|LOADRAM|FAILDIS|FASTMODE, SEQCTL);\r\naic_outb(p, 0, SEQADDR0);\r\naic_outb(p, 0, SEQADDR1);\r\nk = 0;\r\nfor (i=0; i < downloaded; i++)\r\n{\r\nif ( k == 0 )\r\nprintk("%03x: ", i);\r\ntemp = aic_inb(p, SEQRAM);\r\ntemp |= (aic_inb(p, SEQRAM) << 8);\r\ntemp |= (aic_inb(p, SEQRAM) << 16);\r\ntemp |= (aic_inb(p, SEQRAM) << 24);\r\nprintk("%08x", temp);\r\nif ( ++k == 8 )\r\n{\r\nprintk("\n");\r\nk = 0;\r\n}\r\nelse\r\nprintk(" ");\r\n}\r\naic_outb(p, 0, SEQADDR0);\r\naic_outb(p, 0, SEQADDR1);\r\naic_outb(p, FASTMODE | FAILDIS, SEQCTL);\r\nunpause_sequencer(p, TRUE);\r\nmdelay(1);\r\npause_sequencer(p);\r\naic_outb(p, FASTMODE, SEQCTL);\r\nprintk("\n");\r\n}\r\nstatic const char *\r\naic7xxx_info(struct Scsi_Host *dooh)\r\n{\r\nstatic char buffer[256];\r\nchar *bp;\r\nstruct aic7xxx_host *p;\r\nbp = &buffer[0];\r\np = (struct aic7xxx_host *)dooh->hostdata;\r\nmemset(bp, 0, sizeof(buffer));\r\nstrcpy(bp, "Adaptec AHA274x/284x/294x (EISA/VLB/PCI-Fast SCSI) ");\r\nstrcat(bp, AIC7XXX_C_VERSION);\r\nstrcat(bp, "/");\r\nstrcat(bp, AIC7XXX_H_VERSION);\r\nstrcat(bp, "\n");\r\nstrcat(bp, " <");\r\nstrcat(bp, board_names[p->board_name_index]);\r\nstrcat(bp, ">");\r\nreturn(bp);\r\n}\r\nstatic struct aic7xxx_syncrate *\r\naic7xxx_find_syncrate(struct aic7xxx_host *p, unsigned int *period,\r\nunsigned int maxsync, unsigned char *options)\r\n{\r\nstruct aic7xxx_syncrate *syncrate;\r\nint done = FALSE;\r\nswitch(*options)\r\n{\r\ncase MSG_EXT_PPR_OPTION_DT_CRC:\r\ncase MSG_EXT_PPR_OPTION_DT_UNITS:\r\nif(!(p->features & AHC_ULTRA3))\r\n{\r\n*options = 0;\r\nmaxsync = max_t(unsigned int, maxsync, AHC_SYNCRATE_ULTRA2);\r\n}\r\nbreak;\r\ncase MSG_EXT_PPR_OPTION_DT_CRC_QUICK:\r\ncase MSG_EXT_PPR_OPTION_DT_UNITS_QUICK:\r\nif(!(p->features & AHC_ULTRA3))\r\n{\r\n*options = 0;\r\nmaxsync = max_t(unsigned int, maxsync, AHC_SYNCRATE_ULTRA2);\r\n}\r\nelse\r\n{\r\nswitch(*options)\r\n{\r\ncase MSG_EXT_PPR_OPTION_DT_CRC_QUICK:\r\n*options = MSG_EXT_PPR_OPTION_DT_CRC;\r\nbreak;\r\ncase MSG_EXT_PPR_OPTION_DT_UNITS_QUICK:\r\n*options = MSG_EXT_PPR_OPTION_DT_UNITS;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\n*options = 0;\r\nmaxsync = max_t(unsigned int, maxsync, AHC_SYNCRATE_ULTRA2);\r\nbreak;\r\n}\r\nsyncrate = &aic7xxx_syncrates[maxsync];\r\nwhile ( (syncrate->rate[0] != NULL) &&\r\n(!(p->features & AHC_ULTRA2) || syncrate->sxfr_ultra2) )\r\n{\r\nif (*period <= syncrate->period)\r\n{\r\nswitch(*options)\r\n{\r\ncase MSG_EXT_PPR_OPTION_DT_CRC:\r\ncase MSG_EXT_PPR_OPTION_DT_UNITS:\r\nif(!(syncrate->sxfr_ultra2 & AHC_SYNCRATE_CRC))\r\n{\r\ndone = TRUE;\r\n*options = 0;\r\n*period = syncrate->period;\r\n}\r\nelse\r\n{\r\ndone = TRUE;\r\nif(syncrate == &aic7xxx_syncrates[maxsync])\r\n{\r\n*period = syncrate->period;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nif(!(syncrate->sxfr_ultra2 & AHC_SYNCRATE_CRC))\r\n{\r\ndone = TRUE;\r\nif(syncrate == &aic7xxx_syncrates[maxsync])\r\n{\r\n*period = syncrate->period;\r\n}\r\n}\r\nbreak;\r\n}\r\nif(done)\r\n{\r\nbreak;\r\n}\r\n}\r\nsyncrate++;\r\n}\r\nif ( (*period == 0) || (syncrate->rate[0] == NULL) ||\r\n((p->features & AHC_ULTRA2) && (syncrate->sxfr_ultra2 == 0)) )\r\n{\r\n*options = 0;\r\n*period = 255;\r\nsyncrate = NULL;\r\n}\r\nreturn (syncrate);\r\n}\r\nstatic unsigned int\r\naic7xxx_find_period(struct aic7xxx_host *p, unsigned int scsirate,\r\nunsigned int maxsync)\r\n{\r\nstruct aic7xxx_syncrate *syncrate;\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nscsirate &= SXFR_ULTRA2;\r\n}\r\nelse\r\n{\r\nscsirate &= SXFR;\r\n}\r\nsyncrate = &aic7xxx_syncrates[maxsync];\r\nwhile (syncrate->rate[0] != NULL)\r\n{\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nif (syncrate->sxfr_ultra2 == 0)\r\nbreak;\r\nelse if (scsirate == syncrate->sxfr_ultra2)\r\nreturn (syncrate->period);\r\nelse if (scsirate == (syncrate->sxfr_ultra2 & ~AHC_SYNCRATE_CRC))\r\nreturn (syncrate->period);\r\n}\r\nelse if (scsirate == (syncrate->sxfr & ~ULTRA_SXFR))\r\n{\r\nreturn (syncrate->period);\r\n}\r\nsyncrate++;\r\n}\r\nreturn (0);\r\n}\r\nstatic void\r\naic7xxx_validate_offset(struct aic7xxx_host *p,\r\nstruct aic7xxx_syncrate *syncrate, unsigned int *offset, int wide)\r\n{\r\nunsigned int maxoffset;\r\nif (syncrate == NULL)\r\n{\r\nmaxoffset = 0;\r\n}\r\nelse if (p->features & AHC_ULTRA2)\r\n{\r\nmaxoffset = MAX_OFFSET_ULTRA2;\r\n}\r\nelse\r\n{\r\nif (wide)\r\nmaxoffset = MAX_OFFSET_16BIT;\r\nelse\r\nmaxoffset = MAX_OFFSET_8BIT;\r\n}\r\n*offset = min(*offset, maxoffset);\r\n}\r\nstatic void\r\naic7xxx_set_syncrate(struct aic7xxx_host *p, struct aic7xxx_syncrate *syncrate,\r\nint target, int channel, unsigned int period, unsigned int offset,\r\nunsigned char options, unsigned int type, struct aic_dev_data *aic_dev)\r\n{\r\nunsigned char tindex;\r\nunsigned short target_mask;\r\nunsigned char lun, old_options;\r\nunsigned int old_period, old_offset;\r\ntindex = target | (channel << 3);\r\ntarget_mask = 0x01 << tindex;\r\nlun = aic_inb(p, SCB_TCL) & 0x07;\r\nif (syncrate == NULL)\r\n{\r\nperiod = 0;\r\noffset = 0;\r\n}\r\nold_period = aic_dev->cur.period;\r\nold_offset = aic_dev->cur.offset;\r\nold_options = aic_dev->cur.options;\r\nif (type & AHC_TRANS_CUR)\r\n{\r\nunsigned int scsirate;\r\nscsirate = aic_inb(p, TARG_SCSIRATE + tindex);\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nscsirate &= ~SXFR_ULTRA2;\r\nif (syncrate != NULL)\r\n{\r\nswitch(options)\r\n{\r\ncase MSG_EXT_PPR_OPTION_DT_UNITS:\r\nscsirate |= (syncrate->sxfr_ultra2 & ~AHC_SYNCRATE_CRC);\r\nbreak;\r\ndefault:\r\nscsirate |= syncrate->sxfr_ultra2;\r\nbreak;\r\n}\r\n}\r\nif (type & AHC_TRANS_ACTIVE)\r\n{\r\naic_outb(p, offset, SCSIOFFSET);\r\n}\r\naic_outb(p, offset, TARG_OFFSET + tindex);\r\n}\r\nelse\r\n{\r\nscsirate &= ~(SXFR|SOFS);\r\np->ultraenb &= ~target_mask;\r\nif (syncrate != NULL)\r\n{\r\nif (syncrate->sxfr & ULTRA_SXFR)\r\n{\r\np->ultraenb |= target_mask;\r\n}\r\nscsirate |= (syncrate->sxfr & SXFR);\r\nscsirate |= (offset & SOFS);\r\n}\r\nif (type & AHC_TRANS_ACTIVE)\r\n{\r\nunsigned char sxfrctl0;\r\nsxfrctl0 = aic_inb(p, SXFRCTL0);\r\nsxfrctl0 &= ~FAST20;\r\nif (p->ultraenb & target_mask)\r\nsxfrctl0 |= FAST20;\r\naic_outb(p, sxfrctl0, SXFRCTL0);\r\n}\r\naic_outb(p, p->ultraenb & 0xff, ULTRA_ENB);\r\naic_outb(p, (p->ultraenb >> 8) & 0xff, ULTRA_ENB + 1 );\r\n}\r\nif (type & AHC_TRANS_ACTIVE)\r\n{\r\naic_outb(p, scsirate, SCSIRATE);\r\n}\r\naic_outb(p, scsirate, TARG_SCSIRATE + tindex);\r\naic_dev->cur.period = period;\r\naic_dev->cur.offset = offset;\r\naic_dev->cur.options = options;\r\nif ( !(type & AHC_TRANS_QUITE) &&\r\n(aic7xxx_verbose & VERBOSE_NEGOTIATION) &&\r\n(aic_dev->flags & DEVICE_PRINT_DTR) )\r\n{\r\nif (offset)\r\n{\r\nint rate_mod = (scsirate & WIDEXFER) ? 1 : 0;\r\nprintk(INFO_LEAD "Synchronous at %s Mbyte/sec, "\r\n"offset %d.\n", p->host_no, channel, target, lun,\r\nsyncrate->rate[rate_mod], offset);\r\n}\r\nelse\r\n{\r\nprintk(INFO_LEAD "Using asynchronous transfers.\n",\r\np->host_no, channel, target, lun);\r\n}\r\naic_dev->flags &= ~DEVICE_PRINT_DTR;\r\n}\r\n}\r\nif (type & AHC_TRANS_GOAL)\r\n{\r\naic_dev->goal.period = period;\r\naic_dev->goal.offset = offset;\r\naic_dev->goal.options = options;\r\n}\r\nif (type & AHC_TRANS_USER)\r\n{\r\np->user[tindex].period = period;\r\np->user[tindex].offset = offset;\r\np->user[tindex].options = options;\r\n}\r\n}\r\nstatic void\r\naic7xxx_set_width(struct aic7xxx_host *p, int target, int channel, int lun,\r\nunsigned int width, unsigned int type, struct aic_dev_data *aic_dev)\r\n{\r\nunsigned char tindex;\r\nunsigned short target_mask;\r\nunsigned int old_width;\r\ntindex = target | (channel << 3);\r\ntarget_mask = 1 << tindex;\r\nold_width = aic_dev->cur.width;\r\nif (type & AHC_TRANS_CUR)\r\n{\r\nunsigned char scsirate;\r\nscsirate = aic_inb(p, TARG_SCSIRATE + tindex);\r\nscsirate &= ~WIDEXFER;\r\nif (width == MSG_EXT_WDTR_BUS_16_BIT)\r\nscsirate |= WIDEXFER;\r\naic_outb(p, scsirate, TARG_SCSIRATE + tindex);\r\nif (type & AHC_TRANS_ACTIVE)\r\naic_outb(p, scsirate, SCSIRATE);\r\naic_dev->cur.width = width;\r\nif ( !(type & AHC_TRANS_QUITE) &&\r\n(aic7xxx_verbose & VERBOSE_NEGOTIATION2) &&\r\n(aic_dev->flags & DEVICE_PRINT_DTR) )\r\n{\r\nprintk(INFO_LEAD "Using %s transfers\n", p->host_no, channel, target,\r\nlun, (scsirate & WIDEXFER) ? "Wide(16bit)" : "Narrow(8bit)" );\r\n}\r\n}\r\nif (type & AHC_TRANS_GOAL)\r\naic_dev->goal.width = width;\r\nif (type & AHC_TRANS_USER)\r\np->user[tindex].width = width;\r\nif (aic_dev->goal.offset)\r\n{\r\nif (p->features & AHC_ULTRA2)\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_ULTRA2;\r\n}\r\nelse if (width == MSG_EXT_WDTR_BUS_16_BIT)\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_16BIT;\r\n}\r\nelse\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_8BIT;\r\n}\r\n}\r\n}\r\nstatic void\r\nscbq_init(volatile scb_queue_type *queue)\r\n{\r\nqueue->head = NULL;\r\nqueue->tail = NULL;\r\n}\r\nstatic inline void\r\nscbq_insert_head(volatile scb_queue_type *queue, struct aic7xxx_scb *scb)\r\n{\r\nscb->q_next = queue->head;\r\nqueue->head = scb;\r\nif (queue->tail == NULL)\r\nqueue->tail = queue->head;\r\n}\r\nstatic inline struct aic7xxx_scb *\r\nscbq_remove_head(volatile scb_queue_type *queue)\r\n{\r\nstruct aic7xxx_scb * scbp;\r\nscbp = queue->head;\r\nif (queue->head != NULL)\r\nqueue->head = queue->head->q_next;\r\nif (queue->head == NULL)\r\nqueue->tail = NULL;\r\nreturn(scbp);\r\n}\r\nstatic inline void\r\nscbq_remove(volatile scb_queue_type *queue, struct aic7xxx_scb *scb)\r\n{\r\nif (queue->head == scb)\r\n{\r\nscbq_remove_head(queue);\r\n}\r\nelse\r\n{\r\nstruct aic7xxx_scb *curscb = queue->head;\r\nwhile ((curscb != NULL) && (curscb->q_next != scb))\r\n{\r\ncurscb = curscb->q_next;\r\n}\r\nif (curscb != NULL)\r\n{\r\ncurscb->q_next = scb->q_next;\r\nif (scb->q_next == NULL)\r\n{\r\nqueue->tail = curscb;\r\n}\r\n}\r\n}\r\n}\r\nstatic inline void\r\nscbq_insert_tail(volatile scb_queue_type *queue, struct aic7xxx_scb *scb)\r\n{\r\nscb->q_next = NULL;\r\nif (queue->tail != NULL)\r\nqueue->tail->q_next = scb;\r\nqueue->tail = scb;\r\nif (queue->head == NULL)\r\nqueue->head = queue->tail;\r\n}\r\nstatic int\r\naic7xxx_match_scb(struct aic7xxx_host *p, struct aic7xxx_scb *scb,\r\nint target, int channel, int lun, unsigned char tag)\r\n{\r\nint targ = (scb->hscb->target_channel_lun >> 4) & 0x0F;\r\nint chan = (scb->hscb->target_channel_lun >> 3) & 0x01;\r\nint slun = scb->hscb->target_channel_lun & 0x07;\r\nint match;\r\nmatch = ((chan == channel) || (channel == ALL_CHANNELS));\r\nif (match != 0)\r\nmatch = ((targ == target) || (target == ALL_TARGETS));\r\nif (match != 0)\r\nmatch = ((lun == slun) || (lun == ALL_LUNS));\r\nif (match != 0)\r\nmatch = ((tag == scb->hscb->tag) || (tag == SCB_LIST_NULL));\r\nreturn (match);\r\n}\r\nstatic void\r\naic7xxx_add_curscb_to_free_list(struct aic7xxx_host *p)\r\n{\r\naic_outb(p, SCB_LIST_NULL, SCB_TAG);\r\naic_outb(p, 0, SCB_CONTROL);\r\naic_outb(p, aic_inb(p, FREE_SCBH), SCB_NEXT);\r\naic_outb(p, aic_inb(p, SCBPTR), FREE_SCBH);\r\n}\r\nstatic unsigned char\r\naic7xxx_rem_scb_from_disc_list(struct aic7xxx_host *p, unsigned char scbptr,\r\nunsigned char prev)\r\n{\r\nunsigned char next;\r\naic_outb(p, scbptr, SCBPTR);\r\nnext = aic_inb(p, SCB_NEXT);\r\naic7xxx_add_curscb_to_free_list(p);\r\nif (prev != SCB_LIST_NULL)\r\n{\r\naic_outb(p, prev, SCBPTR);\r\naic_outb(p, next, SCB_NEXT);\r\n}\r\nelse\r\n{\r\naic_outb(p, next, DISCONNECTED_SCBH);\r\n}\r\nreturn next;\r\n}\r\nstatic inline void\r\naic7xxx_busy_target(struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\np->untagged_scbs[scb->hscb->target_channel_lun] = scb->hscb->tag;\r\n}\r\nstatic inline unsigned char\r\naic7xxx_index_busy_target(struct aic7xxx_host *p, unsigned char tcl,\r\nint unbusy)\r\n{\r\nunsigned char busy_scbid;\r\nbusy_scbid = p->untagged_scbs[tcl];\r\nif (unbusy)\r\n{\r\np->untagged_scbs[tcl] = SCB_LIST_NULL;\r\n}\r\nreturn (busy_scbid);\r\n}\r\nstatic unsigned char\r\naic7xxx_find_scb(struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\nunsigned char saved_scbptr;\r\nunsigned char curindex;\r\nsaved_scbptr = aic_inb(p, SCBPTR);\r\ncurindex = 0;\r\nfor (curindex = 0; curindex < p->scb_data->maxhscbs; curindex++)\r\n{\r\naic_outb(p, curindex, SCBPTR);\r\nif (aic_inb(p, SCB_TAG) == scb->hscb->tag)\r\n{\r\nbreak;\r\n}\r\n}\r\naic_outb(p, saved_scbptr, SCBPTR);\r\nif (curindex >= p->scb_data->maxhscbs)\r\n{\r\ncurindex = SCB_LIST_NULL;\r\n}\r\nreturn (curindex);\r\n}\r\nstatic int\r\naic7xxx_allocate_scb(struct aic7xxx_host *p)\r\n{\r\nstruct aic7xxx_scb *scbp = NULL;\r\nint scb_size = (sizeof (struct hw_scatterlist) * AIC7XXX_MAX_SG) + 12 + 6;\r\nint i;\r\nint step = PAGE_SIZE / 1024;\r\nunsigned long scb_count = 0;\r\nstruct hw_scatterlist *hsgp;\r\nstruct aic7xxx_scb *scb_ap;\r\nstruct aic7xxx_scb_dma *scb_dma;\r\nunsigned char *bufs;\r\nif (p->scb_data->numscbs < p->scb_data->maxscbs)\r\n{\r\nfor ( i=step;; i *= 2 )\r\n{\r\nif ( (scb_size * (i-1)) >= ( (PAGE_SIZE * (i/step)) - 64 ) )\r\n{\r\ni /= 2;\r\nbreak;\r\n}\r\n}\r\nscb_count = min( (i-1), p->scb_data->maxscbs - p->scb_data->numscbs);\r\nscb_ap = kmalloc(sizeof (struct aic7xxx_scb) * scb_count\r\n+ sizeof(struct aic7xxx_scb_dma), GFP_ATOMIC);\r\nif (scb_ap == NULL)\r\nreturn(0);\r\nscb_dma = (struct aic7xxx_scb_dma *)&scb_ap[scb_count];\r\nhsgp = (struct hw_scatterlist *)\r\npci_alloc_consistent(p->pdev, scb_size * scb_count,\r\n&scb_dma->dma_address);\r\nif (hsgp == NULL)\r\n{\r\nkfree(scb_ap);\r\nreturn(0);\r\n}\r\nbufs = (unsigned char *)&hsgp[scb_count * AIC7XXX_MAX_SG];\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose > 0xffff)\r\n{\r\nif (p->scb_data->numscbs == 0)\r\nprintk(INFO_LEAD "Allocating initial %ld SCB structures.\n",\r\np->host_no, -1, -1, -1, scb_count);\r\nelse\r\nprintk(INFO_LEAD "Allocating %ld additional SCB structures.\n",\r\np->host_no, -1, -1, -1, scb_count);\r\n}\r\n#endif\r\nmemset(scb_ap, 0, sizeof (struct aic7xxx_scb) * scb_count);\r\nscb_dma->dma_offset = (unsigned long)scb_dma->dma_address\r\n- (unsigned long)hsgp;\r\nscb_dma->dma_len = scb_size * scb_count;\r\nfor (i=0; i < scb_count; i++)\r\n{\r\nscbp = &scb_ap[i];\r\nscbp->hscb = &p->scb_data->hscbs[p->scb_data->numscbs];\r\nscbp->sg_list = &hsgp[i * AIC7XXX_MAX_SG];\r\nscbp->sense_cmd = bufs;\r\nscbp->cmnd = bufs + 6;\r\nbufs += 12 + 6;\r\nscbp->scb_dma = scb_dma;\r\nmemset(scbp->hscb, 0, sizeof(struct aic7xxx_hwscb));\r\nscbp->hscb->tag = p->scb_data->numscbs;\r\np->scb_data->scb_array[p->scb_data->numscbs++] = scbp;\r\nscbq_insert_tail(&p->scb_data->free_scbs, scbp);\r\n}\r\nscbp->kmalloc_ptr = scb_ap;\r\n}\r\nreturn(scb_count);\r\n}\r\nstatic void\r\naic7xxx_queue_cmd_complete(struct aic7xxx_host *p, struct scsi_cmnd *cmd)\r\n{\r\naic7xxx_position(cmd) = SCB_LIST_NULL;\r\ncmd->host_scribble = (char *)p->completeq.head;\r\np->completeq.head = cmd;\r\n}\r\nstatic void aic7xxx_done_cmds_complete(struct aic7xxx_host *p)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nwhile (p->completeq.head != NULL) {\r\ncmd = p->completeq.head;\r\np->completeq.head = (struct scsi_cmnd *) cmd->host_scribble;\r\ncmd->host_scribble = NULL;\r\ncmd->scsi_done(cmd);\r\n}\r\n}\r\nstatic void\r\naic7xxx_free_scb(struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\nscb->flags = SCB_FREE;\r\nscb->cmd = NULL;\r\nscb->sg_count = 0;\r\nscb->sg_length = 0;\r\nscb->tag_action = 0;\r\nscb->hscb->control = 0;\r\nscb->hscb->target_status = 0;\r\nscb->hscb->target_channel_lun = SCB_LIST_NULL;\r\nscbq_insert_head(&p->scb_data->free_scbs, scb);\r\n}\r\nstatic void\r\naic7xxx_done(struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\nstruct scsi_cmnd *cmd = scb->cmd;\r\nstruct aic_dev_data *aic_dev = cmd->device->hostdata;\r\nint tindex = TARGET_INDEX(cmd);\r\nstruct aic7xxx_scb *scbp;\r\nunsigned char queue_depth;\r\nscsi_dma_unmap(cmd);\r\nif (scb->flags & SCB_SENSE)\r\n{\r\npci_unmap_single(p->pdev,\r\nle32_to_cpu(scb->sg_list[0].address),\r\nSCSI_SENSE_BUFFERSIZE,\r\nPCI_DMA_FROMDEVICE);\r\n}\r\nif (scb->flags & SCB_RECOVERY_SCB)\r\n{\r\np->flags &= ~AHC_ABORT_PENDING;\r\n}\r\nif (scb->flags & (SCB_RESET|SCB_ABORT))\r\n{\r\ncmd->result |= (DID_RESET << 16);\r\n}\r\nif ((scb->flags & SCB_MSGOUT_BITS) != 0)\r\n{\r\nunsigned short mask;\r\nint message_error = FALSE;\r\nmask = 0x01 << tindex;\r\nif ((scb->flags & SCB_SENSE) &&\r\n((scb->cmd->sense_buffer[12] == 0x43) ||\r\n(scb->cmd->sense_buffer[12] == 0x49)))\r\n{\r\nmessage_error = TRUE;\r\n}\r\nif (scb->flags & SCB_MSGOUT_WDTR)\r\n{\r\nif (message_error)\r\n{\r\nif ( (aic7xxx_verbose & VERBOSE_NEGOTIATION2) &&\r\n(aic_dev->flags & DEVICE_PRINT_DTR) )\r\n{\r\nprintk(INFO_LEAD "Device failed to complete Wide Negotiation "\r\n"processing and\n", p->host_no, CTL_OF_SCB(scb));\r\nprintk(INFO_LEAD "returned a sense error code for invalid message, "\r\n"disabling future\n", p->host_no, CTL_OF_SCB(scb));\r\nprintk(INFO_LEAD "Wide negotiation to this device.\n", p->host_no,\r\nCTL_OF_SCB(scb));\r\n}\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 0;\r\n}\r\n}\r\nif (scb->flags & SCB_MSGOUT_SDTR)\r\n{\r\nif (message_error)\r\n{\r\nif ( (aic7xxx_verbose & VERBOSE_NEGOTIATION2) &&\r\n(aic_dev->flags & DEVICE_PRINT_DTR) )\r\n{\r\nprintk(INFO_LEAD "Device failed to complete Sync Negotiation "\r\n"processing and\n", p->host_no, CTL_OF_SCB(scb));\r\nprintk(INFO_LEAD "returned a sense error code for invalid message, "\r\n"disabling future\n", p->host_no, CTL_OF_SCB(scb));\r\nprintk(INFO_LEAD "Sync negotiation to this device.\n", p->host_no,\r\nCTL_OF_SCB(scb));\r\naic_dev->flags &= ~DEVICE_PRINT_DTR;\r\n}\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 0;\r\n}\r\n}\r\nif (scb->flags & SCB_MSGOUT_PPR)\r\n{\r\nif(message_error)\r\n{\r\nif ( (aic7xxx_verbose & VERBOSE_NEGOTIATION2) &&\r\n(aic_dev->flags & DEVICE_PRINT_DTR) )\r\n{\r\nprintk(INFO_LEAD "Device failed to complete Parallel Protocol "\r\n"Request processing and\n", p->host_no, CTL_OF_SCB(scb));\r\nprintk(INFO_LEAD "returned a sense error code for invalid message, "\r\n"disabling future\n", p->host_no, CTL_OF_SCB(scb));\r\nprintk(INFO_LEAD "Parallel Protocol Request negotiation to this "\r\n"device.\n", p->host_no, CTL_OF_SCB(scb));\r\n}\r\naic_dev->needppr = aic_dev->needppr_copy = 0;\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 1;\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 1;\r\n}\r\n}\r\n}\r\nqueue_depth = aic_dev->temp_q_depth;\r\nif (queue_depth >= aic_dev->active_cmds)\r\n{\r\nscbp = scbq_remove_head(&aic_dev->delayed_scbs);\r\nif (scbp)\r\n{\r\nif (queue_depth == 1)\r\n{\r\nscbq_insert_head(&p->waiting_scbs, scbp);\r\n}\r\nelse\r\n{\r\nscbq_insert_tail(&p->waiting_scbs, scbp);\r\n}\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose > 0xffff)\r\nprintk(INFO_LEAD "Moving SCB from delayed to waiting queue.\n",\r\np->host_no, CTL_OF_SCB(scbp));\r\n#endif\r\nif (queue_depth > aic_dev->active_cmds)\r\n{\r\nscbp = scbq_remove_head(&aic_dev->delayed_scbs);\r\nif (scbp)\r\nscbq_insert_tail(&p->waiting_scbs, scbp);\r\n}\r\n}\r\n}\r\nif (!(scb->tag_action))\r\n{\r\naic7xxx_index_busy_target(p, scb->hscb->target_channel_lun,\r\nTRUE);\r\nif (cmd->device->simple_tags)\r\n{\r\naic_dev->temp_q_depth = aic_dev->max_q_depth;\r\n}\r\n}\r\nif(scb->flags & SCB_DTR_SCB)\r\n{\r\naic_dev->dtr_pending = 0;\r\n}\r\naic_dev->active_cmds--;\r\np->activescbs--;\r\nif ((scb->sg_length >= 512) && (((cmd->result >> 16) & 0xf) == DID_OK))\r\n{\r\nlong *ptr;\r\nint x, i;\r\nif (rq_data_dir(cmd->request) == WRITE)\r\n{\r\naic_dev->w_total++;\r\nptr = aic_dev->w_bins;\r\n}\r\nelse\r\n{\r\naic_dev->r_total++;\r\nptr = aic_dev->r_bins;\r\n}\r\nx = scb->sg_length;\r\nx >>= 10;\r\nfor(i=0; i<6; i++)\r\n{\r\nx >>= 2;\r\nif(!x) {\r\nptr[i]++;\r\nbreak;\r\n}\r\n}\r\nif(i == 6 && x)\r\nptr[5]++;\r\n}\r\naic7xxx_free_scb(p, scb);\r\naic7xxx_queue_cmd_complete(p, cmd);\r\n}\r\nstatic void\r\naic7xxx_run_done_queue(struct aic7xxx_host *p, int complete)\r\n{\r\nstruct aic7xxx_scb *scb;\r\nint i, found = 0;\r\nfor (i = 0; i < p->scb_data->numscbs; i++)\r\n{\r\nscb = p->scb_data->scb_array[i];\r\nif (scb->flags & SCB_QUEUED_FOR_DONE)\r\n{\r\nif (scb->flags & SCB_QUEUE_FULL)\r\n{\r\nscb->cmd->result = QUEUE_FULL << 1;\r\n}\r\nelse\r\n{\r\nif (aic7xxx_verbose & (VERBOSE_ABORT_PROCESS | VERBOSE_RESET_PROCESS))\r\nprintk(INFO_LEAD "Aborting scb %d\n",\r\np->host_no, CTL_OF_SCB(scb), scb->hscb->tag);\r\nscb->hscb->residual_SG_segment_count = 0;\r\nscb->hscb->residual_data_count[0] = 0;\r\nscb->hscb->residual_data_count[1] = 0;\r\nscb->hscb->residual_data_count[2] = 0;\r\n}\r\nfound++;\r\naic7xxx_done(p, scb);\r\n}\r\n}\r\nif (aic7xxx_verbose & (VERBOSE_ABORT_RETURN | VERBOSE_RESET_RETURN))\r\n{\r\nprintk(INFO_LEAD "%d commands found and queued for "\r\n"completion.\n", p->host_no, -1, -1, -1, found);\r\n}\r\nif (complete)\r\n{\r\naic7xxx_done_cmds_complete(p);\r\n}\r\n}\r\nstatic unsigned char\r\naic7xxx_abort_waiting_scb(struct aic7xxx_host *p, struct aic7xxx_scb *scb,\r\nunsigned char scbpos, unsigned char prev)\r\n{\r\nunsigned char curscb, next;\r\ncurscb = aic_inb(p, SCBPTR);\r\naic_outb(p, scbpos, SCBPTR);\r\nnext = aic_inb(p, SCB_NEXT);\r\naic7xxx_add_curscb_to_free_list(p);\r\nif (prev == SCB_LIST_NULL)\r\n{\r\naic_outb(p, next, WAITING_SCBH);\r\n}\r\nelse\r\n{\r\naic_outb(p, prev, SCBPTR);\r\naic_outb(p, next, SCB_NEXT);\r\n}\r\naic_outb(p, curscb, SCBPTR);\r\nreturn (next);\r\n}\r\nstatic int\r\naic7xxx_search_qinfifo(struct aic7xxx_host *p, int target, int channel,\r\nint lun, unsigned char tag, int flags, int requeue,\r\nvolatile scb_queue_type *queue)\r\n{\r\nint found;\r\nunsigned char qinpos, qintail;\r\nstruct aic7xxx_scb *scbp;\r\nfound = 0;\r\nqinpos = aic_inb(p, QINPOS);\r\nqintail = p->qinfifonext;\r\np->qinfifonext = qinpos;\r\nwhile (qinpos != qintail)\r\n{\r\nscbp = p->scb_data->scb_array[p->qinfifo[qinpos++]];\r\nif (aic7xxx_match_scb(p, scbp, target, channel, lun, tag))\r\n{\r\nif (requeue && (queue != NULL))\r\n{\r\nif (scbp->flags & SCB_WAITINGQ)\r\n{\r\nscbq_remove(queue, scbp);\r\nscbq_remove(&p->waiting_scbs, scbp);\r\nscbq_remove(&AIC_DEV(scbp->cmd)->delayed_scbs, scbp);\r\nAIC_DEV(scbp->cmd)->active_cmds++;\r\np->activescbs++;\r\n}\r\nscbq_insert_tail(queue, scbp);\r\nAIC_DEV(scbp->cmd)->active_cmds--;\r\np->activescbs--;\r\nscbp->flags |= SCB_WAITINGQ;\r\nif ( !(scbp->tag_action & TAG_ENB) )\r\n{\r\naic7xxx_index_busy_target(p, scbp->hscb->target_channel_lun,\r\nTRUE);\r\n}\r\n}\r\nelse if (requeue)\r\n{\r\np->qinfifo[p->qinfifonext++] = scbp->hscb->tag;\r\n}\r\nelse\r\n{\r\nscbp->flags = flags | (scbp->flags & SCB_RECOVERY_SCB);\r\nif (aic7xxx_index_busy_target(p, scbp->hscb->target_channel_lun,\r\nFALSE) == scbp->hscb->tag)\r\n{\r\naic7xxx_index_busy_target(p, scbp->hscb->target_channel_lun,\r\nTRUE);\r\n}\r\n}\r\nfound++;\r\n}\r\nelse\r\n{\r\np->qinfifo[p->qinfifonext++] = scbp->hscb->tag;\r\n}\r\n}\r\nqinpos = p->qinfifonext;\r\nwhile(qinpos != qintail)\r\n{\r\np->qinfifo[qinpos++] = SCB_LIST_NULL;\r\n}\r\nif (p->features & AHC_QUEUE_REGS)\r\naic_outb(p, p->qinfifonext, HNSCB_QOFF);\r\nelse\r\naic_outb(p, p->qinfifonext, KERNEL_QINPOS);\r\nreturn (found);\r\n}\r\nstatic int\r\naic7xxx_scb_on_qoutfifo(struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\nint i=0;\r\nwhile(p->qoutfifo[(p->qoutfifonext + i) & 0xff ] != SCB_LIST_NULL)\r\n{\r\nif(p->qoutfifo[(p->qoutfifonext + i) & 0xff ] == scb->hscb->tag)\r\nreturn TRUE;\r\nelse\r\ni++;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\naic7xxx_reset_device(struct aic7xxx_host *p, int target, int channel,\r\nint lun, unsigned char tag)\r\n{\r\nstruct aic7xxx_scb *scbp, *prev_scbp;\r\nstruct scsi_device *sd;\r\nunsigned char active_scb, tcl, scb_tag;\r\nint i = 0, init_lists = FALSE;\r\nstruct aic_dev_data *aic_dev;\r\nactive_scb = aic_inb(p, SCBPTR);\r\nscb_tag = aic_inb(p, SCB_TAG);\r\nif (aic7xxx_verbose & (VERBOSE_RESET_PROCESS | VERBOSE_ABORT_PROCESS))\r\n{\r\nprintk(INFO_LEAD "Reset device, hardware_scb %d,\n",\r\np->host_no, channel, target, lun, active_scb);\r\nprintk(INFO_LEAD "Current scb %d, SEQADDR 0x%x, LASTPHASE "\r\n"0x%x\n",\r\np->host_no, channel, target, lun, scb_tag,\r\naic_inb(p, SEQADDR0) | (aic_inb(p, SEQADDR1) << 8),\r\naic_inb(p, LASTPHASE));\r\nprintk(INFO_LEAD "SG_CACHEPTR 0x%x, SG_COUNT %d, SCSISIGI 0x%x\n",\r\np->host_no, channel, target, lun,\r\n(p->features & AHC_ULTRA2) ? aic_inb(p, SG_CACHEPTR) : 0,\r\naic_inb(p, SG_COUNT), aic_inb(p, SCSISIGI));\r\nprintk(INFO_LEAD "SSTAT0 0x%x, SSTAT1 0x%x, SSTAT2 0x%x\n",\r\np->host_no, channel, target, lun, aic_inb(p, SSTAT0),\r\naic_inb(p, SSTAT1), aic_inb(p, SSTAT2));\r\n}\r\nlist_for_each_entry(aic_dev, &p->aic_devs, list)\r\n{\r\nif (aic7xxx_verbose & (VERBOSE_RESET_PROCESS | VERBOSE_ABORT_PROCESS))\r\nprintk(INFO_LEAD "processing aic_dev %p\n", p->host_no, channel, target,\r\nlun, aic_dev);\r\nsd = aic_dev->SDptr;\r\nif((target != ALL_TARGETS && target != sd->id) ||\r\n(channel != ALL_CHANNELS && channel != sd->channel))\r\ncontinue;\r\nif (aic7xxx_verbose & (VERBOSE_ABORT_PROCESS | VERBOSE_RESET_PROCESS))\r\nprintk(INFO_LEAD "Cleaning up status information "\r\n"and delayed_scbs.\n", p->host_no, sd->channel, sd->id, sd->lun);\r\naic_dev->flags &= ~BUS_DEVICE_RESET_PENDING;\r\nif ( tag == SCB_LIST_NULL )\r\n{\r\naic_dev->dtr_pending = 0;\r\naic_dev->needppr = aic_dev->needppr_copy;\r\naic_dev->needsdtr = aic_dev->needsdtr_copy;\r\naic_dev->needwdtr = aic_dev->needwdtr_copy;\r\naic_dev->flags = DEVICE_PRINT_DTR;\r\naic_dev->temp_q_depth = aic_dev->max_q_depth;\r\n}\r\ntcl = (sd->id << 4) | (sd->channel << 3) | sd->lun;\r\nif ( (aic7xxx_index_busy_target(p, tcl, FALSE) == tag) ||\r\n(tag == SCB_LIST_NULL) )\r\naic7xxx_index_busy_target(p, tcl, TRUE);\r\nprev_scbp = NULL;\r\nscbp = aic_dev->delayed_scbs.head;\r\nwhile (scbp != NULL)\r\n{\r\nprev_scbp = scbp;\r\nscbp = scbp->q_next;\r\nif (aic7xxx_match_scb(p, prev_scbp, target, channel, lun, tag))\r\n{\r\nscbq_remove(&aic_dev->delayed_scbs, prev_scbp);\r\nif (prev_scbp->flags & SCB_WAITINGQ)\r\n{\r\naic_dev->active_cmds++;\r\np->activescbs++;\r\n}\r\nprev_scbp->flags &= ~(SCB_ACTIVE | SCB_WAITINGQ);\r\nprev_scbp->flags |= SCB_RESET | SCB_QUEUED_FOR_DONE;\r\n}\r\n}\r\n}\r\nif (aic7xxx_verbose & (VERBOSE_ABORT_PROCESS | VERBOSE_RESET_PROCESS))\r\nprintk(INFO_LEAD "Cleaning QINFIFO.\n", p->host_no, channel, target, lun );\r\naic7xxx_search_qinfifo(p, target, channel, lun, tag,\r\nSCB_RESET | SCB_QUEUED_FOR_DONE, FALSE, NULL);\r\nif (aic7xxx_verbose & (VERBOSE_ABORT_PROCESS | VERBOSE_RESET_PROCESS))\r\nprintk(INFO_LEAD "Cleaning waiting_scbs.\n", p->host_no, channel,\r\ntarget, lun );\r\n{\r\nstruct aic7xxx_scb *scbp, *prev_scbp;\r\nprev_scbp = NULL;\r\nscbp = p->waiting_scbs.head;\r\nwhile (scbp != NULL)\r\n{\r\nprev_scbp = scbp;\r\nscbp = scbp->q_next;\r\nif (aic7xxx_match_scb(p, prev_scbp, target, channel, lun, tag))\r\n{\r\nscbq_remove(&p->waiting_scbs, prev_scbp);\r\nif (prev_scbp->flags & SCB_WAITINGQ)\r\n{\r\nAIC_DEV(prev_scbp->cmd)->active_cmds++;\r\np->activescbs++;\r\n}\r\nprev_scbp->flags &= ~(SCB_ACTIVE | SCB_WAITINGQ);\r\nprev_scbp->flags |= SCB_RESET | SCB_QUEUED_FOR_DONE;\r\n}\r\n}\r\n}\r\nif (aic7xxx_verbose & (VERBOSE_ABORT_PROCESS | VERBOSE_RESET_PROCESS))\r\nprintk(INFO_LEAD "Cleaning waiting for selection "\r\n"list.\n", p->host_no, channel, target, lun);\r\n{\r\nunsigned char next, prev, scb_index;\r\nnext = aic_inb(p, WAITING_SCBH);\r\nprev = SCB_LIST_NULL;\r\nwhile (next != SCB_LIST_NULL)\r\n{\r\naic_outb(p, next, SCBPTR);\r\nscb_index = aic_inb(p, SCB_TAG);\r\nif (scb_index >= p->scb_data->numscbs)\r\n{\r\nprintk(WARN_LEAD "Waiting List inconsistency; SCB index=%d, "\r\n"numscbs=%d\n", p->host_no, channel, target, lun, scb_index,\r\np->scb_data->numscbs);\r\nnext = aic_inb(p, SCB_NEXT);\r\naic7xxx_add_curscb_to_free_list(p);\r\n}\r\nelse\r\n{\r\nscbp = p->scb_data->scb_array[scb_index];\r\nif (aic7xxx_match_scb(p, scbp, target, channel, lun, tag))\r\n{\r\nnext = aic7xxx_abort_waiting_scb(p, scbp, next, prev);\r\nif (scbp->flags & SCB_WAITINGQ)\r\n{\r\nAIC_DEV(scbp->cmd)->active_cmds++;\r\np->activescbs++;\r\n}\r\nscbp->flags &= ~(SCB_ACTIVE | SCB_WAITINGQ);\r\nscbp->flags |= SCB_RESET | SCB_QUEUED_FOR_DONE;\r\nif (prev == SCB_LIST_NULL)\r\n{\r\naic_outb(p, aic_inb(p, SCSISEQ) & ~ENSELO, SCSISEQ);\r\naic_outb(p, CLRSELTIMEO, CLRSINT1);\r\n}\r\n}\r\nelse\r\n{\r\nprev = next;\r\nnext = aic_inb(p, SCB_NEXT);\r\n}\r\n}\r\n}\r\n}\r\nif (aic7xxx_verbose & (VERBOSE_ABORT_PROCESS | VERBOSE_RESET_PROCESS))\r\nprintk(INFO_LEAD "Cleaning disconnected scbs "\r\n"list.\n", p->host_no, channel, target, lun);\r\nif (p->flags & AHC_PAGESCBS)\r\n{\r\nunsigned char next, prev, scb_index;\r\nnext = aic_inb(p, DISCONNECTED_SCBH);\r\nprev = SCB_LIST_NULL;\r\nwhile (next != SCB_LIST_NULL)\r\n{\r\naic_outb(p, next, SCBPTR);\r\nscb_index = aic_inb(p, SCB_TAG);\r\nif (scb_index > p->scb_data->numscbs)\r\n{\r\nprintk(WARN_LEAD "Disconnected List inconsistency; SCB index=%d, "\r\n"numscbs=%d\n", p->host_no, channel, target, lun, scb_index,\r\np->scb_data->numscbs);\r\nnext = aic7xxx_rem_scb_from_disc_list(p, next, prev);\r\n}\r\nelse\r\n{\r\nscbp = p->scb_data->scb_array[scb_index];\r\nif (aic7xxx_match_scb(p, scbp, target, channel, lun, tag))\r\n{\r\nnext = aic7xxx_rem_scb_from_disc_list(p, next, prev);\r\nif (scbp->flags & SCB_WAITINGQ)\r\n{\r\nAIC_DEV(scbp->cmd)->active_cmds++;\r\np->activescbs++;\r\n}\r\nscbp->flags &= ~(SCB_ACTIVE | SCB_WAITINGQ);\r\nscbp->flags |= SCB_RESET | SCB_QUEUED_FOR_DONE;\r\nscbp->hscb->control = 0;\r\n}\r\nelse\r\n{\r\nprev = next;\r\nnext = aic_inb(p, SCB_NEXT);\r\n}\r\n}\r\n}\r\n}\r\nif (p->flags & AHC_PAGESCBS)\r\n{\r\nunsigned char next;\r\nnext = aic_inb(p, FREE_SCBH);\r\nwhile (next != SCB_LIST_NULL)\r\n{\r\naic_outb(p, next, SCBPTR);\r\nif (aic_inb(p, SCB_TAG) < p->scb_data->numscbs)\r\n{\r\nprintk(WARN_LEAD "Free list inconsistency!.\n", p->host_no, channel,\r\ntarget, lun);\r\ninit_lists = TRUE;\r\nnext = SCB_LIST_NULL;\r\n}\r\nelse\r\n{\r\naic_outb(p, SCB_LIST_NULL, SCB_TAG);\r\naic_outb(p, 0, SCB_CONTROL);\r\nnext = aic_inb(p, SCB_NEXT);\r\n}\r\n}\r\n}\r\nif (init_lists)\r\n{\r\naic_outb(p, SCB_LIST_NULL, FREE_SCBH);\r\naic_outb(p, SCB_LIST_NULL, WAITING_SCBH);\r\naic_outb(p, SCB_LIST_NULL, DISCONNECTED_SCBH);\r\n}\r\nfor (i = p->scb_data->maxhscbs - 1; i >= 0; i--)\r\n{\r\nunsigned char scbid;\r\naic_outb(p, i, SCBPTR);\r\nif (init_lists)\r\n{\r\naic_outb(p, SCB_LIST_NULL, SCB_TAG);\r\naic_outb(p, SCB_LIST_NULL, SCB_NEXT);\r\naic_outb(p, 0, SCB_CONTROL);\r\naic7xxx_add_curscb_to_free_list(p);\r\n}\r\nelse\r\n{\r\nscbid = aic_inb(p, SCB_TAG);\r\nif (scbid < p->scb_data->numscbs)\r\n{\r\nscbp = p->scb_data->scb_array[scbid];\r\nif (aic7xxx_match_scb(p, scbp, target, channel, lun, tag))\r\n{\r\naic_outb(p, 0, SCB_CONTROL);\r\naic_outb(p, SCB_LIST_NULL, SCB_TAG);\r\naic7xxx_add_curscb_to_free_list(p);\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i < p->scb_data->numscbs; i++)\r\n{\r\nscbp = p->scb_data->scb_array[i];\r\nif ((scbp->flags & SCB_ACTIVE) &&\r\naic7xxx_match_scb(p, scbp, target, channel, lun, tag) &&\r\n!aic7xxx_scb_on_qoutfifo(p, scbp))\r\n{\r\nif (scbp->flags & SCB_WAITINGQ)\r\n{\r\nscbq_remove(&p->waiting_scbs, scbp);\r\nscbq_remove(&AIC_DEV(scbp->cmd)->delayed_scbs, scbp);\r\nAIC_DEV(scbp->cmd)->active_cmds++;\r\np->activescbs++;\r\n}\r\nscbp->flags |= SCB_RESET | SCB_QUEUED_FOR_DONE;\r\nscbp->flags &= ~(SCB_ACTIVE | SCB_WAITINGQ);\r\n}\r\n}\r\naic_outb(p, active_scb, SCBPTR);\r\n}\r\nstatic void\r\naic7xxx_clear_intstat(struct aic7xxx_host *p)\r\n{\r\naic_outb(p, CLRSELDO | CLRSELDI | CLRSELINGO, CLRSINT0);\r\naic_outb(p, CLRSELTIMEO | CLRATNO | CLRSCSIRSTI | CLRBUSFREE | CLRSCSIPERR |\r\nCLRPHASECHG | CLRREQINIT, CLRSINT1);\r\naic_outb(p, CLRSCSIINT | CLRSEQINT | CLRBRKADRINT | CLRPARERR, CLRINT);\r\n}\r\nstatic void\r\naic7xxx_reset_current_bus(struct aic7xxx_host *p)\r\n{\r\naic_outb(p, aic_inb(p, SIMODE1) & ~ENSCSIRST, SIMODE1);\r\naic_outb(p, aic_inb(p, SCSISEQ) | SCSIRSTO, SCSISEQ);\r\nwhile ( (aic_inb(p, SCSISEQ) & SCSIRSTO) == 0)\r\nmdelay(5);\r\nif (p->features & AHC_ULTRA2)\r\nmdelay(250);\r\nelse\r\nmdelay(50);\r\naic_outb(p, 0, SCSISEQ);\r\nmdelay(10);\r\naic7xxx_clear_intstat(p);\r\naic_outb(p, aic_inb(p, SIMODE1) | ENSCSIRST, SIMODE1);\r\n}\r\nstatic void\r\naic7xxx_reset_channel(struct aic7xxx_host *p, int channel, int initiate_reset)\r\n{\r\nunsigned long offset_min, offset_max;\r\nunsigned char sblkctl;\r\nint cur_channel;\r\nif (aic7xxx_verbose & VERBOSE_RESET_PROCESS)\r\nprintk(INFO_LEAD "Reset channel called, %s initiate reset.\n",\r\np->host_no, channel, -1, -1, (initiate_reset==TRUE) ? "will" : "won't" );\r\nif (channel == 1)\r\n{\r\noffset_min = 8;\r\noffset_max = 16;\r\n}\r\nelse\r\n{\r\nif (p->features & AHC_TWIN)\r\n{\r\noffset_min = 0;\r\noffset_max = 8;\r\n}\r\nelse\r\n{\r\noffset_min = 0;\r\nif (p->features & AHC_WIDE)\r\n{\r\noffset_max = 16;\r\n}\r\nelse\r\n{\r\noffset_max = 8;\r\n}\r\n}\r\n}\r\nwhile (offset_min < offset_max)\r\n{\r\naic_outb(p, 0, TARG_SCSIRATE + offset_min);\r\nif (p->features & AHC_ULTRA2)\r\n{\r\naic_outb(p, 0, TARG_OFFSET + offset_min);\r\n}\r\noffset_min++;\r\n}\r\nsblkctl = aic_inb(p, SBLKCTL);\r\nif ( (p->chip & AHC_CHIPID_MASK) == AHC_AIC7770 )\r\ncur_channel = (sblkctl & SELBUSB) >> 3;\r\nelse\r\ncur_channel = 0;\r\nif ( (cur_channel != channel) && (p->features & AHC_TWIN) )\r\n{\r\nif (aic7xxx_verbose & VERBOSE_RESET_PROCESS)\r\nprintk(INFO_LEAD "Stealthily resetting idle channel.\n", p->host_no,\r\nchannel, -1, -1);\r\naic_outb(p, sblkctl ^ SELBUSB, SBLKCTL);\r\naic_outb(p, aic_inb(p, SIMODE1) & ~ENBUSFREE, SIMODE1);\r\nif (initiate_reset)\r\n{\r\naic7xxx_reset_current_bus(p);\r\n}\r\naic_outb(p, aic_inb(p, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP), SCSISEQ);\r\naic7xxx_clear_intstat(p);\r\naic_outb(p, sblkctl, SBLKCTL);\r\n}\r\nelse\r\n{\r\nif (aic7xxx_verbose & VERBOSE_RESET_PROCESS)\r\nprintk(INFO_LEAD "Resetting currently active channel.\n", p->host_no,\r\nchannel, -1, -1);\r\naic_outb(p, aic_inb(p, SIMODE1) & ~(ENBUSFREE|ENREQINIT),\r\nSIMODE1);\r\np->flags &= ~AHC_HANDLING_REQINITS;\r\np->msg_type = MSG_TYPE_NONE;\r\np->msg_len = 0;\r\nif (initiate_reset)\r\n{\r\naic7xxx_reset_current_bus(p);\r\n}\r\naic_outb(p, aic_inb(p, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP), SCSISEQ);\r\naic7xxx_clear_intstat(p);\r\n}\r\nif (aic7xxx_verbose & VERBOSE_RESET_RETURN)\r\nprintk(INFO_LEAD "Channel reset\n", p->host_no, channel, -1, -1);\r\naic7xxx_reset_device(p, ALL_TARGETS, channel, ALL_LUNS, SCB_LIST_NULL);\r\nif ( !(p->features & AHC_TWIN) )\r\n{\r\nrestart_sequencer(p);\r\n}\r\nreturn;\r\n}\r\nstatic void\r\naic7xxx_run_waiting_queues(struct aic7xxx_host *p)\r\n{\r\nstruct aic7xxx_scb *scb;\r\nstruct aic_dev_data *aic_dev;\r\nint sent;\r\nif (p->waiting_scbs.head == NULL)\r\nreturn;\r\nsent = 0;\r\nwhile ((scb = scbq_remove_head(&p->waiting_scbs)) != NULL)\r\n{\r\naic_dev = scb->cmd->device->hostdata;\r\nif ( !scb->tag_action )\r\n{\r\naic_dev->temp_q_depth = 1;\r\n}\r\nif ( aic_dev->active_cmds >= aic_dev->temp_q_depth)\r\n{\r\nscbq_insert_tail(&aic_dev->delayed_scbs, scb);\r\n}\r\nelse\r\n{\r\nscb->flags &= ~SCB_WAITINGQ;\r\naic_dev->active_cmds++;\r\np->activescbs++;\r\nif ( !(scb->tag_action) )\r\n{\r\naic7xxx_busy_target(p, scb);\r\n}\r\np->qinfifo[p->qinfifonext++] = scb->hscb->tag;\r\nsent++;\r\n}\r\n}\r\nif (sent)\r\n{\r\nif (p->features & AHC_QUEUE_REGS)\r\naic_outb(p, p->qinfifonext, HNSCB_QOFF);\r\nelse\r\n{\r\npause_sequencer(p);\r\naic_outb(p, p->qinfifonext, KERNEL_QINPOS);\r\nunpause_sequencer(p, FALSE);\r\n}\r\nif (p->activescbs > p->max_activescbs)\r\np->max_activescbs = p->activescbs;\r\n}\r\n}\r\nstatic void\r\naic7xxx_pci_intr(struct aic7xxx_host *p)\r\n{\r\nunsigned char status1;\r\npci_read_config_byte(p->pdev, PCI_STATUS + 1, &status1);\r\nif ( (status1 & DPE) && (aic7xxx_verbose & VERBOSE_MINOR_ERROR) )\r\nprintk(WARN_LEAD "Data Parity Error during PCI address or PCI write"\r\n"phase.\n", p->host_no, -1, -1, -1);\r\nif ( (status1 & SSE) && (aic7xxx_verbose & VERBOSE_MINOR_ERROR) )\r\nprintk(WARN_LEAD "Signal System Error Detected\n", p->host_no,\r\n-1, -1, -1);\r\nif ( (status1 & RMA) && (aic7xxx_verbose & VERBOSE_MINOR_ERROR) )\r\nprintk(WARN_LEAD "Received a PCI Master Abort\n", p->host_no,\r\n-1, -1, -1);\r\nif ( (status1 & RTA) && (aic7xxx_verbose & VERBOSE_MINOR_ERROR) )\r\nprintk(WARN_LEAD "Received a PCI Target Abort\n", p->host_no,\r\n-1, -1, -1);\r\nif ( (status1 & STA) && (aic7xxx_verbose & VERBOSE_MINOR_ERROR) )\r\nprintk(WARN_LEAD "Signaled a PCI Target Abort\n", p->host_no,\r\n-1, -1, -1);\r\nif ( (status1 & DPR) && (aic7xxx_verbose & VERBOSE_MINOR_ERROR) )\r\nprintk(WARN_LEAD "Data Parity Error has been reported via PCI pin "\r\n"PERR#\n", p->host_no, -1, -1, -1);\r\npci_write_config_byte(p->pdev, PCI_STATUS + 1, status1);\r\nif (status1 & (DPR|RMA|RTA))\r\naic_outb(p, CLRPARERR, CLRINT);\r\nif ( (aic7xxx_panic_on_abort) && (p->spurious_int > 500) )\r\naic7xxx_panic_abort(p, NULL);\r\n}\r\nstatic void\r\naic7xxx_construct_ppr(struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\np->msg_buf[p->msg_index++] = MSG_EXTENDED;\r\np->msg_buf[p->msg_index++] = MSG_EXT_PPR_LEN;\r\np->msg_buf[p->msg_index++] = MSG_EXT_PPR;\r\np->msg_buf[p->msg_index++] = AIC_DEV(scb->cmd)->goal.period;\r\np->msg_buf[p->msg_index++] = 0;\r\np->msg_buf[p->msg_index++] = AIC_DEV(scb->cmd)->goal.offset;\r\np->msg_buf[p->msg_index++] = AIC_DEV(scb->cmd)->goal.width;\r\np->msg_buf[p->msg_index++] = AIC_DEV(scb->cmd)->goal.options;\r\np->msg_len += 8;\r\n}\r\nstatic void\r\naic7xxx_construct_sdtr(struct aic7xxx_host *p, unsigned char period,\r\nunsigned char offset)\r\n{\r\np->msg_buf[p->msg_index++] = MSG_EXTENDED;\r\np->msg_buf[p->msg_index++] = MSG_EXT_SDTR_LEN;\r\np->msg_buf[p->msg_index++] = MSG_EXT_SDTR;\r\np->msg_buf[p->msg_index++] = period;\r\np->msg_buf[p->msg_index++] = offset;\r\np->msg_len += 5;\r\n}\r\nstatic void\r\naic7xxx_construct_wdtr(struct aic7xxx_host *p, unsigned char bus_width)\r\n{\r\np->msg_buf[p->msg_index++] = MSG_EXTENDED;\r\np->msg_buf[p->msg_index++] = MSG_EXT_WDTR_LEN;\r\np->msg_buf[p->msg_index++] = MSG_EXT_WDTR;\r\np->msg_buf[p->msg_index++] = bus_width;\r\np->msg_len += 4;\r\n}\r\nstatic void\r\naic7xxx_calculate_residual (struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\nstruct aic7xxx_hwscb *hscb;\r\nstruct scsi_cmnd *cmd;\r\nint actual, i;\r\ncmd = scb->cmd;\r\nhscb = scb->hscb;\r\nif (((scb->hscb->control & DISCONNECTED) == 0) &&\r\n(scb->flags & SCB_SENSE) == 0)\r\n{\r\nactual = scb->sg_length;\r\nfor (i=1; i < hscb->residual_SG_segment_count; i++)\r\n{\r\nactual -= scb->sg_list[scb->sg_count - i].length;\r\n}\r\nactual -= (hscb->residual_data_count[2] << 16) |\r\n(hscb->residual_data_count[1] << 8) |\r\nhscb->residual_data_count[0];\r\nif (actual < cmd->underflow)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_MINOR_ERROR)\r\n{\r\nprintk(INFO_LEAD "Underflow - Wanted %u, %s %u, residual SG "\r\n"count %d.\n", p->host_no, CTL_OF_SCB(scb), cmd->underflow,\r\n(rq_data_dir(cmd->request) == WRITE) ? "wrote" : "read", actual,\r\nhscb->residual_SG_segment_count);\r\nprintk(INFO_LEAD "status 0x%x.\n", p->host_no, CTL_OF_SCB(scb),\r\nhscb->target_status);\r\n}\r\nscsi_set_resid(cmd, scb->sg_length - actual);\r\naic7xxx_status(cmd) = hscb->target_status;\r\n}\r\n}\r\nhscb->residual_data_count[2] = 0;\r\nhscb->residual_data_count[1] = 0;\r\nhscb->residual_data_count[0] = 0;\r\nhscb->residual_SG_segment_count = 0;\r\n}\r\nstatic void\r\naic7xxx_handle_device_reset(struct aic7xxx_host *p, int target, int channel)\r\n{\r\nunsigned char tindex = target;\r\ntindex |= ((channel & 0x01) << 3);\r\naic_outb(p, 0, TARG_SCSIRATE + tindex);\r\nif (p->features & AHC_ULTRA2)\r\naic_outb(p, 0, TARG_OFFSET + tindex);\r\naic7xxx_reset_device(p, target, channel, ALL_LUNS, SCB_LIST_NULL);\r\nif (aic7xxx_verbose & VERBOSE_RESET_PROCESS)\r\nprintk(INFO_LEAD "Bus Device Reset delivered.\n", p->host_no, channel,\r\ntarget, -1);\r\naic7xxx_run_done_queue(p, TRUE);\r\n}\r\nstatic void\r\naic7xxx_handle_seqint(struct aic7xxx_host *p, unsigned char intstat)\r\n{\r\nstruct aic7xxx_scb *scb;\r\nstruct aic_dev_data *aic_dev;\r\nunsigned short target_mask;\r\nunsigned char target, lun, tindex;\r\nunsigned char queue_flag = FALSE;\r\nchar channel;\r\nint result;\r\ntarget = ((aic_inb(p, SAVED_TCL) >> 4) & 0x0f);\r\nif ( (p->chip & AHC_CHIPID_MASK) == AHC_AIC7770 )\r\nchannel = (aic_inb(p, SBLKCTL) & SELBUSB) >> 3;\r\nelse\r\nchannel = 0;\r\ntindex = target + (channel << 3);\r\nlun = aic_inb(p, SAVED_TCL) & 0x07;\r\ntarget_mask = (0x01 << tindex);\r\naic_outb(p, CLRSEQINT, CLRINT);\r\nswitch (intstat & SEQINT_MASK)\r\n{\r\ncase NO_MATCH:\r\n{\r\naic_outb(p, aic_inb(p, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP),\r\nSCSISEQ);\r\nprintk(WARN_LEAD "No active SCB for reconnecting target - Issuing "\r\n"BUS DEVICE RESET.\n", p->host_no, channel, target, lun);\r\nprintk(WARN_LEAD " SAVED_TCL=0x%x, ARG_1=0x%x, SEQADDR=0x%x\n",\r\np->host_no, channel, target, lun,\r\naic_inb(p, SAVED_TCL), aic_inb(p, ARG_1),\r\n(aic_inb(p, SEQADDR1) << 8) | aic_inb(p, SEQADDR0));\r\nif (aic7xxx_panic_on_abort)\r\naic7xxx_panic_abort(p, NULL);\r\n}\r\nbreak;\r\ncase SEND_REJECT:\r\n{\r\nif (aic7xxx_verbose & VERBOSE_MINOR_ERROR)\r\nprintk(INFO_LEAD "Rejecting unknown message (0x%x) received from "\r\n"target, SEQ_FLAGS=0x%x\n", p->host_no, channel, target, lun,\r\naic_inb(p, ACCUM), aic_inb(p, SEQ_FLAGS));\r\n}\r\nbreak;\r\ncase NO_IDENT:\r\n{\r\nif (aic7xxx_verbose & (VERBOSE_SEQINT | VERBOSE_RESET_MID))\r\nprintk(INFO_LEAD "Target did not send an IDENTIFY message; "\r\n"LASTPHASE 0x%x, SAVED_TCL 0x%x\n", p->host_no, channel, target,\r\nlun, aic_inb(p, LASTPHASE), aic_inb(p, SAVED_TCL));\r\naic7xxx_reset_channel(p, channel, TRUE);\r\naic7xxx_run_done_queue(p, TRUE);\r\n}\r\nbreak;\r\ncase BAD_PHASE:\r\nif (aic_inb(p, LASTPHASE) == P_BUSFREE)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_SEQINT)\r\nprintk(INFO_LEAD "Missed busfree.\n", p->host_no, channel,\r\ntarget, lun);\r\nrestart_sequencer(p);\r\n}\r\nelse\r\n{\r\nif (aic7xxx_verbose & VERBOSE_SEQINT)\r\nprintk(INFO_LEAD "Unknown scsi bus phase, continuing\n", p->host_no,\r\nchannel, target, lun);\r\n}\r\nbreak;\r\ncase EXTENDED_MSG:\r\n{\r\np->msg_type = MSG_TYPE_INITIATOR_MSGIN;\r\np->msg_len = 0;\r\np->msg_index = 0;\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose > 0xffff)\r\nprintk(INFO_LEAD "Enabling REQINITs for MSG_IN\n", p->host_no,\r\nchannel, target, lun);\r\n#endif\r\np->flags |= AHC_HANDLING_REQINITS;\r\naic_outb(p, aic_inb(p, SIMODE1) | ENREQINIT, SIMODE1);\r\nreturn;\r\n}\r\ncase REJECT_MSG:\r\n{\r\nunsigned char scb_index;\r\nunsigned char last_msg;\r\nscb_index = aic_inb(p, SCB_TAG);\r\nscb = p->scb_data->scb_array[scb_index];\r\naic_dev = AIC_DEV(scb->cmd);\r\nlast_msg = aic_inb(p, LAST_MSG);\r\nif ( (last_msg == MSG_IDENTIFYFLAG) &&\r\n(scb->tag_action) &&\r\n!(scb->flags & SCB_MSGOUT_BITS) )\r\n{\r\nif (scb->tag_action == MSG_ORDERED_Q_TAG)\r\n{\r\nscsi_adjust_queue_depth(scb->cmd->device, MSG_SIMPLE_TAG,\r\nscb->cmd->device->queue_depth);\r\nscb->tag_action = MSG_SIMPLE_Q_TAG;\r\nscb->hscb->control &= ~SCB_TAG_TYPE;\r\nscb->hscb->control |= MSG_SIMPLE_Q_TAG;\r\naic_outb(p, scb->hscb->control, SCB_CONTROL);\r\naic_outb(p, MSG_IDENTIFYFLAG, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGI) | ATNO, SCSISIGO);\r\n}\r\nelse if (scb->tag_action == MSG_SIMPLE_Q_TAG)\r\n{\r\nunsigned char i;\r\nstruct aic7xxx_scb *scbp;\r\nint old_verbose;\r\nscsi_adjust_queue_depth(scb->cmd->device, 0 ,\r\np->host->cmd_per_lun);\r\naic_dev->max_q_depth = aic_dev->temp_q_depth = 1;\r\nscb->tag_action = 0;\r\nscb->hscb->control &= ~(TAG_ENB | SCB_TAG_TYPE);\r\naic_outb(p, scb->hscb->control, SCB_CONTROL);\r\nold_verbose = aic7xxx_verbose;\r\naic7xxx_verbose &= ~(VERBOSE_RESET|VERBOSE_ABORT);\r\nfor (i=0; i < p->scb_data->numscbs; i++)\r\n{\r\nscbp = p->scb_data->scb_array[i];\r\nif ((scbp->flags & SCB_ACTIVE) && (scbp != scb))\r\n{\r\nif (aic7xxx_match_scb(p, scbp, target, channel, lun, i))\r\n{\r\naic7xxx_reset_device(p, target, channel, lun, i);\r\n}\r\n}\r\n}\r\naic7xxx_run_done_queue(p, TRUE);\r\naic7xxx_verbose = old_verbose;\r\naic7xxx_busy_target(p, scb);\r\nprintk(INFO_LEAD "Device is refusing tagged commands, using "\r\n"untagged I/O.\n", p->host_no, channel, target, lun);\r\naic_outb(p, MSG_IDENTIFYFLAG, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGI) | ATNO, SCSISIGO);\r\n}\r\n}\r\nelse if (scb->flags & SCB_MSGOUT_PPR)\r\n{\r\naic_dev->needppr = aic_dev->needppr_copy = 0;\r\naic7xxx_set_width(p, target, channel, lun, MSG_EXT_WDTR_BUS_8_BIT,\r\n(AHC_TRANS_ACTIVE|AHC_TRANS_CUR|AHC_TRANS_QUITE), aic_dev);\r\naic7xxx_set_syncrate(p, NULL, target, channel, 0, 0, 0,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_CUR|AHC_TRANS_QUITE,\r\naic_dev);\r\naic_dev->goal.options = aic_dev->dtr_pending = 0;\r\nscb->flags &= ~SCB_MSGOUT_BITS;\r\nif(aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Device is rejecting PPR messages, falling "\r\n"back.\n", p->host_no, channel, target, lun);\r\n}\r\nif ( aic_dev->goal.width )\r\n{\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 1;\r\naic_dev->dtr_pending = 1;\r\nscb->flags |= SCB_MSGOUT_WDTR;\r\n}\r\nif ( aic_dev->goal.offset )\r\n{\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 1;\r\nif( !aic_dev->dtr_pending )\r\n{\r\naic_dev->dtr_pending = 1;\r\nscb->flags |= SCB_MSGOUT_SDTR;\r\n}\r\n}\r\nif ( aic_dev->dtr_pending )\r\n{\r\naic_outb(p, HOST_MSG, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGI) | ATNO, SCSISIGO);\r\n}\r\n}\r\nelse if (scb->flags & SCB_MSGOUT_WDTR)\r\n{\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 0;\r\nscb->flags &= ~SCB_MSGOUT_BITS;\r\naic7xxx_set_width(p, target, channel, lun, MSG_EXT_WDTR_BUS_8_BIT,\r\n(AHC_TRANS_ACTIVE|AHC_TRANS_GOAL|AHC_TRANS_CUR), aic_dev);\r\naic7xxx_set_syncrate(p, NULL, target, channel, 0, 0, 0,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_CUR|AHC_TRANS_QUITE,\r\naic_dev);\r\nif(aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Device is rejecting WDTR messages, using "\r\n"narrow transfers.\n", p->host_no, channel, target, lun);\r\n}\r\naic_dev->needsdtr = aic_dev->needsdtr_copy;\r\n}\r\nelse if (scb->flags & SCB_MSGOUT_SDTR)\r\n{\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 0;\r\nscb->flags &= ~SCB_MSGOUT_BITS;\r\naic7xxx_set_syncrate(p, NULL, target, channel, 0, 0, 0,\r\n(AHC_TRANS_CUR|AHC_TRANS_ACTIVE|AHC_TRANS_GOAL), aic_dev);\r\nif(aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Device is rejecting SDTR messages, using "\r\n"async transfers.\n", p->host_no, channel, target, lun);\r\n}\r\n}\r\nelse if (aic7xxx_verbose & VERBOSE_SEQINT)\r\n{\r\nprintk(INFO_LEAD "Received MESSAGE_REJECT for unknown cause. "\r\n"Ignoring.\n", p->host_no, channel, target, lun);\r\n}\r\n}\r\nbreak;\r\ncase BAD_STATUS:\r\n{\r\nunsigned char scb_index;\r\nstruct aic7xxx_hwscb *hscb;\r\nstruct scsi_cmnd *cmd;\r\naic_outb(p, 0, RETURN_1);\r\nscb_index = aic_inb(p, SCB_TAG);\r\nif (scb_index > p->scb_data->numscbs)\r\n{\r\nprintk(WARN_LEAD "Invalid SCB during SEQINT 0x%02x, SCB_TAG %d.\n",\r\np->host_no, channel, target, lun, intstat, scb_index);\r\nbreak;\r\n}\r\nscb = p->scb_data->scb_array[scb_index];\r\nhscb = scb->hscb;\r\nif (!(scb->flags & SCB_ACTIVE) || (scb->cmd == NULL))\r\n{\r\nprintk(WARN_LEAD "Invalid SCB during SEQINT 0x%x, scb %d, flags 0x%x,"\r\n" cmd 0x%lx.\n", p->host_no, channel, target, lun, intstat,\r\nscb_index, scb->flags, (unsigned long) scb->cmd);\r\n}\r\nelse\r\n{\r\ncmd = scb->cmd;\r\naic_dev = AIC_DEV(scb->cmd);\r\nhscb->target_status = aic_inb(p, SCB_TARGET_STATUS);\r\naic7xxx_status(cmd) = hscb->target_status;\r\ncmd->result = hscb->target_status;\r\nswitch (status_byte(hscb->target_status))\r\n{\r\ncase GOOD:\r\nif (aic7xxx_verbose & VERBOSE_SEQINT)\r\nprintk(INFO_LEAD "Interrupted for status of GOOD???\n",\r\np->host_no, CTL_OF_SCB(scb));\r\nbreak;\r\ncase COMMAND_TERMINATED:\r\ncase CHECK_CONDITION:\r\nif ( !(scb->flags & SCB_SENSE) )\r\n{\r\nmemcpy(scb->sense_cmd, &generic_sense[0],\r\nsizeof(generic_sense));\r\nscb->sense_cmd[1] = (cmd->device->lun << 5);\r\nscb->sense_cmd[4] = SCSI_SENSE_BUFFERSIZE;\r\nscb->sg_list[0].length =\r\ncpu_to_le32(SCSI_SENSE_BUFFERSIZE);\r\nscb->sg_list[0].address =\r\ncpu_to_le32(pci_map_single(p->pdev, cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE,\r\nPCI_DMA_FROMDEVICE));\r\nhscb->control = 0;\r\nhscb->target_status = 0;\r\nhscb->SG_list_pointer =\r\ncpu_to_le32(SCB_DMA_ADDR(scb, scb->sg_list));\r\nhscb->SCSI_cmd_pointer =\r\ncpu_to_le32(SCB_DMA_ADDR(scb, scb->sense_cmd));\r\nhscb->data_count = scb->sg_list[0].length;\r\nhscb->data_pointer = scb->sg_list[0].address;\r\nhscb->SCSI_cmd_length = COMMAND_SIZE(scb->sense_cmd[0]);\r\nhscb->residual_SG_segment_count = 0;\r\nhscb->residual_data_count[0] = 0;\r\nhscb->residual_data_count[1] = 0;\r\nhscb->residual_data_count[2] = 0;\r\nscb->sg_count = hscb->SG_segment_count = 1;\r\nscb->sg_length = SCSI_SENSE_BUFFERSIZE;\r\nscb->tag_action = 0;\r\nscb->flags |= SCB_SENSE;\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nif (scb->flags & SCB_MSGOUT_BITS)\r\nprintk(INFO_LEAD "Requesting SENSE with %s\n", p->host_no,\r\nCTL_OF_SCB(scb), (scb->flags & SCB_MSGOUT_SDTR) ?\r\n"SDTR" : "WDTR");\r\nelse\r\nprintk(INFO_LEAD "Requesting SENSE, no MSG\n", p->host_no,\r\nCTL_OF_SCB(scb));\r\n}\r\n#endif\r\naic7xxx_busy_target(p, scb);\r\naic_outb(p, SEND_SENSE, RETURN_1);\r\naic7xxx_error(cmd) = DID_OK;\r\nbreak;\r\n}\r\nprintk(INFO_LEAD "CHECK_CONDITION on REQUEST_SENSE, returning "\r\n"an error.\n", p->host_no, CTL_OF_SCB(scb));\r\naic7xxx_error(cmd) = DID_ERROR;\r\nscb->flags &= ~SCB_SENSE;\r\nbreak;\r\ncase QUEUE_FULL:\r\nqueue_flag = TRUE;\r\ncase BUSY:\r\n{\r\nstruct aic7xxx_scb *next_scbp, *prev_scbp;\r\nunsigned char active_hscb, next_hscb, prev_hscb, scb_index;\r\nnext_scbp = p->waiting_scbs.head;\r\nwhile ( next_scbp != NULL )\r\n{\r\nprev_scbp = next_scbp;\r\nnext_scbp = next_scbp->q_next;\r\nif ( aic7xxx_match_scb(p, prev_scbp, target, channel, lun,\r\nSCB_LIST_NULL) )\r\n{\r\nscbq_remove(&p->waiting_scbs, prev_scbp);\r\nscb->flags = SCB_QUEUED_FOR_DONE | SCB_QUEUE_FULL;\r\np->activescbs++;\r\naic_dev->active_cmds++;\r\n}\r\n}\r\naic7xxx_search_qinfifo(p, target, channel, lun,\r\nSCB_LIST_NULL, SCB_QUEUED_FOR_DONE | SCB_QUEUE_FULL,\r\nFALSE, NULL);\r\nnext_scbp = NULL;\r\nactive_hscb = aic_inb(p, SCBPTR);\r\nprev_hscb = next_hscb = scb_index = SCB_LIST_NULL;\r\nnext_hscb = aic_inb(p, WAITING_SCBH);\r\nwhile (next_hscb != SCB_LIST_NULL)\r\n{\r\naic_outb(p, next_hscb, SCBPTR);\r\nscb_index = aic_inb(p, SCB_TAG);\r\nif (scb_index < p->scb_data->numscbs)\r\n{\r\nnext_scbp = p->scb_data->scb_array[scb_index];\r\nif (aic7xxx_match_scb(p, next_scbp, target, channel, lun,\r\nSCB_LIST_NULL) )\r\n{\r\nnext_scbp->flags = SCB_QUEUED_FOR_DONE | SCB_QUEUE_FULL;\r\nnext_hscb = aic_inb(p, SCB_NEXT);\r\naic_outb(p, 0, SCB_CONTROL);\r\naic_outb(p, SCB_LIST_NULL, SCB_TAG);\r\naic7xxx_add_curscb_to_free_list(p);\r\nif (prev_hscb == SCB_LIST_NULL)\r\n{\r\naic_outb(p, aic_inb(p, SCSISEQ) & ~ENSELO, SCSISEQ);\r\naic_outb(p, CLRSELTIMEO, CLRSINT1);\r\naic_outb(p, next_hscb, WAITING_SCBH);\r\n}\r\nelse\r\n{\r\naic_outb(p, prev_hscb, SCBPTR);\r\naic_outb(p, next_hscb, SCB_NEXT);\r\n}\r\n}\r\nelse\r\n{\r\nprev_hscb = next_hscb;\r\nnext_hscb = aic_inb(p, SCB_NEXT);\r\n}\r\n}\r\n}\r\naic_outb(p, active_hscb, SCBPTR);\r\naic7xxx_run_done_queue(p, FALSE);\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif( (aic7xxx_verbose & VERBOSE_MINOR_ERROR) ||\r\n(aic7xxx_verbose > 0xffff) )\r\n{\r\nif (queue_flag)\r\nprintk(INFO_LEAD "Queue full received; queue depth %d, "\r\n"active %d\n", p->host_no, CTL_OF_SCB(scb),\r\naic_dev->max_q_depth, aic_dev->active_cmds);\r\nelse\r\nprintk(INFO_LEAD "Target busy\n", p->host_no, CTL_OF_SCB(scb));\r\n}\r\n#endif\r\nif (queue_flag)\r\n{\r\nint diff;\r\nresult = scsi_track_queue_full(cmd->device,\r\naic_dev->active_cmds);\r\nif ( result < 0 )\r\n{\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\nprintk(INFO_LEAD "Tagged Command Queueing disabled.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\ndiff = aic_dev->max_q_depth - p->host->cmd_per_lun;\r\naic_dev->temp_q_depth = 1;\r\naic_dev->max_q_depth = 1;\r\n}\r\nelse if ( result > 0 )\r\n{\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\nprintk(INFO_LEAD "Queue depth reduced to %d\n", p->host_no,\r\nCTL_OF_SCB(scb), result);\r\ndiff = aic_dev->max_q_depth - result;\r\naic_dev->max_q_depth = result;\r\nif(aic_dev->temp_q_depth > result)\r\naic_dev->temp_q_depth = result;\r\n}\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nif (aic7xxx_verbose & VERBOSE_SEQINT)\r\nprintk(INFO_LEAD "Unexpected target status 0x%x.\n", p->host_no,\r\nCTL_OF_SCB(scb), scb->hscb->target_status);\r\nif (!aic7xxx_error(cmd))\r\n{\r\naic7xxx_error(cmd) = DID_RETRY_COMMAND;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase AWAITING_MSG:\r\n{\r\nunsigned char scb_index, msg_out;\r\nscb_index = aic_inb(p, SCB_TAG);\r\nmsg_out = aic_inb(p, MSG_OUT);\r\nscb = p->scb_data->scb_array[scb_index];\r\naic_dev = AIC_DEV(scb->cmd);\r\np->msg_index = p->msg_len = 0;\r\nif ( !(scb->flags & SCB_DEVICE_RESET) &&\r\n(msg_out == MSG_IDENTIFYFLAG) &&\r\n(scb->hscb->control & TAG_ENB) )\r\n{\r\np->msg_buf[p->msg_index++] = scb->tag_action;\r\np->msg_buf[p->msg_index++] = scb->hscb->tag;\r\np->msg_len += 2;\r\n}\r\nif (scb->flags & SCB_DEVICE_RESET)\r\n{\r\np->msg_buf[p->msg_index++] = MSG_BUS_DEV_RESET;\r\np->msg_len++;\r\nif (aic7xxx_verbose & VERBOSE_RESET_PROCESS)\r\nprintk(INFO_LEAD "Bus device reset mailed.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n}\r\nelse if (scb->flags & SCB_ABORT)\r\n{\r\nif (scb->tag_action)\r\n{\r\np->msg_buf[p->msg_index++] = MSG_ABORT_TAG;\r\n}\r\nelse\r\n{\r\np->msg_buf[p->msg_index++] = MSG_ABORT;\r\n}\r\np->msg_len++;\r\nif (aic7xxx_verbose & VERBOSE_ABORT_PROCESS)\r\nprintk(INFO_LEAD "Abort message mailed.\n", p->host_no,\r\nCTL_OF_SCB(scb));\r\n}\r\nelse if (scb->flags & SCB_MSGOUT_PPR)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Sending PPR (%d/%d/%d/%d) message.\n",\r\np->host_no, CTL_OF_SCB(scb),\r\naic_dev->goal.period,\r\naic_dev->goal.offset,\r\naic_dev->goal.width,\r\naic_dev->goal.options);\r\n}\r\naic7xxx_construct_ppr(p, scb);\r\n}\r\nelse if (scb->flags & SCB_MSGOUT_WDTR)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Sending WDTR message.\n", p->host_no,\r\nCTL_OF_SCB(scb));\r\n}\r\naic7xxx_construct_wdtr(p, aic_dev->goal.width);\r\n}\r\nelse if (scb->flags & SCB_MSGOUT_SDTR)\r\n{\r\nunsigned int max_sync, period;\r\nunsigned char options = 0;\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nif ( (aic_inb(p, SBLKCTL) & ENAB40) &&\r\n!(aic_inb(p, SSTAT2) & EXP_ACTIVE) )\r\n{\r\nmax_sync = AHC_SYNCRATE_ULTRA2;\r\n}\r\nelse\r\n{\r\nmax_sync = AHC_SYNCRATE_ULTRA;\r\n}\r\n}\r\nelse if (p->features & AHC_ULTRA)\r\n{\r\nmax_sync = AHC_SYNCRATE_ULTRA;\r\n}\r\nelse\r\n{\r\nmax_sync = AHC_SYNCRATE_FAST;\r\n}\r\nperiod = aic_dev->goal.period;\r\naic7xxx_find_syncrate(p, &period, max_sync, &options);\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Sending SDTR %d/%d message.\n", p->host_no,\r\nCTL_OF_SCB(scb), period,\r\naic_dev->goal.offset);\r\n}\r\naic7xxx_construct_sdtr(p, period, aic_dev->goal.offset);\r\n}\r\nelse\r\n{\r\npanic("aic7xxx: AWAITING_MSG for an SCB that does "\r\n"not have a waiting message.\n");\r\n}\r\nscb->flags |= SCB_MSGOUT_SENT;\r\np->msg_index = 0;\r\np->msg_type = MSG_TYPE_INITIATOR_MSGOUT;\r\np->flags |= AHC_HANDLING_REQINITS;\r\naic_outb(p, aic_inb(p, SIMODE1) | ENREQINIT, SIMODE1);\r\nreturn;\r\n}\r\nbreak;\r\ncase DATA_OVERRUN:\r\n{\r\nunsigned char scb_index = aic_inb(p, SCB_TAG);\r\nunsigned char lastphase = aic_inb(p, LASTPHASE);\r\nunsigned int i;\r\nscb = (p->scb_data->scb_array[scb_index]);\r\nif ( !(scb->flags & SCB_SENSE) )\r\n{\r\nprintk(WARN_LEAD "Data overrun detected in %s phase, tag %d;\n",\r\np->host_no, CTL_OF_SCB(scb),\r\n(lastphase == P_DATAIN) ? "Data-In" : "Data-Out", scb->hscb->tag);\r\nprintk(KERN_WARNING " %s seen Data Phase. Length=%d, NumSGs=%d.\n",\r\n(aic_inb(p, SEQ_FLAGS) & DPHASE) ? "Have" : "Haven't",\r\nscb->sg_length, scb->sg_count);\r\nprintk(KERN_WARNING " Raw SCSI Command: 0x");\r\nfor (i = 0; i < scb->hscb->SCSI_cmd_length; i++)\r\n{\r\nprintk("%02x ", scb->cmd->cmnd[i]);\r\n}\r\nprintk("\n");\r\nif(aic7xxx_verbose > 0xffff)\r\n{\r\nfor (i = 0; i < scb->sg_count; i++)\r\n{\r\nprintk(KERN_WARNING " sg[%d] - Addr 0x%x : Length %d\n",\r\ni,\r\nle32_to_cpu(scb->sg_list[i].address),\r\nle32_to_cpu(scb->sg_list[i].length) );\r\n}\r\n}\r\naic7xxx_error(scb->cmd) = DID_ERROR;\r\n}\r\nelse\r\nprintk(INFO_LEAD "Data Overrun during SEND_SENSE operation.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n}\r\nbreak;\r\ncase WIDE_RESIDUE:\r\n{\r\nunsigned char resid_sgcnt, index;\r\nunsigned char scb_index = aic_inb(p, SCB_TAG);\r\nunsigned int cur_addr, resid_dcnt;\r\nunsigned int native_addr, native_length, sg_addr;\r\nint i;\r\nif(scb_index > p->scb_data->numscbs)\r\n{\r\nprintk(WARN_LEAD "invalid scb_index during WIDE_RESIDUE.\n",\r\np->host_no, -1, -1, -1);\r\nbreak;\r\n}\r\nscb = p->scb_data->scb_array[scb_index];\r\nif(!(scb->flags & SCB_ACTIVE) || (scb->cmd == NULL))\r\n{\r\nprintk(WARN_LEAD "invalid scb during WIDE_RESIDUE flags:0x%x "\r\n"scb->cmd:0x%lx\n", p->host_no, CTL_OF_SCB(scb),\r\nscb->flags, (unsigned long)scb->cmd);\r\nbreak;\r\n}\r\nif(aic7xxx_verbose & VERBOSE_MINOR_ERROR)\r\nprintk(INFO_LEAD "Got WIDE_RESIDUE message, patching up data "\r\n"pointer.\n", p->host_no, CTL_OF_SCB(scb));\r\ncur_addr = aic_inb(p, SHADDR) | (aic_inb(p, SHADDR + 1) << 8) |\r\n(aic_inb(p, SHADDR + 2) << 16) | (aic_inb(p, SHADDR + 3) << 24);\r\nsg_addr = aic_inb(p, SG_COUNT + 1) | (aic_inb(p, SG_COUNT + 2) << 8) |\r\n(aic_inb(p, SG_COUNT + 3) << 16) | (aic_inb(p, SG_COUNT + 4) << 24);\r\nresid_sgcnt = aic_inb(p, SCB_RESID_SGCNT);\r\nresid_dcnt = aic_inb(p, SCB_RESID_DCNT) |\r\n(aic_inb(p, SCB_RESID_DCNT + 1) << 8) |\r\n(aic_inb(p, SCB_RESID_DCNT + 2) << 16);\r\nindex = scb->sg_count - ((resid_sgcnt) ? resid_sgcnt : 1);\r\nnative_addr = le32_to_cpu(scb->sg_list[index].address);\r\nnative_length = le32_to_cpu(scb->sg_list[index].length);\r\nif(resid_dcnt == native_length)\r\n{\r\nif(index == 0)\r\n{\r\nbreak;\r\n}\r\nresid_dcnt = 1;\r\nresid_sgcnt += 1;\r\nnative_addr = le32_to_cpu(scb->sg_list[index - 1].address);\r\nnative_length = le32_to_cpu(scb->sg_list[index - 1].length);\r\ncur_addr = native_addr + (native_length - 1);\r\nsg_addr -= sizeof(struct hw_scatterlist);\r\n}\r\nelse\r\n{\r\nresid_dcnt += 1;\r\ncur_addr -= 1;\r\n}\r\naic_outb(p, resid_sgcnt, SG_COUNT);\r\naic_outb(p, resid_sgcnt, SCB_RESID_SGCNT);\r\naic_outb(p, sg_addr & 0xff, SG_COUNT + 1);\r\naic_outb(p, (sg_addr >> 8) & 0xff, SG_COUNT + 2);\r\naic_outb(p, (sg_addr >> 16) & 0xff, SG_COUNT + 3);\r\naic_outb(p, (sg_addr >> 24) & 0xff, SG_COUNT + 4);\r\naic_outb(p, resid_dcnt & 0xff, SCB_RESID_DCNT);\r\naic_outb(p, (resid_dcnt >> 8) & 0xff, SCB_RESID_DCNT + 1);\r\naic_outb(p, (resid_dcnt >> 16) & 0xff, SCB_RESID_DCNT + 2);\r\nif(p->features & AHC_ULTRA2)\r\n{\r\naic_outb(p, resid_dcnt & 0xff, HCNT);\r\naic_outb(p, (resid_dcnt >> 8) & 0xff, HCNT + 1);\r\naic_outb(p, (resid_dcnt >> 16) & 0xff, HCNT + 2);\r\naic_outb(p, cur_addr & 0xff, HADDR);\r\naic_outb(p, (cur_addr >> 8) & 0xff, HADDR + 1);\r\naic_outb(p, (cur_addr >> 16) & 0xff, HADDR + 2);\r\naic_outb(p, (cur_addr >> 24) & 0xff, HADDR + 3);\r\naic_outb(p, aic_inb(p, DMAPARAMS) | PRELOADEN, DFCNTRL);\r\nudelay(1);\r\naic_outb(p, aic_inb(p, DMAPARAMS) & ~(SCSIEN|HDMAEN), DFCNTRL);\r\ni=0;\r\nwhile(((aic_inb(p, DFCNTRL) & (SCSIEN|HDMAEN)) != 0) && (i++ < 1000))\r\n{\r\nudelay(1);\r\n}\r\n}\r\nelse\r\n{\r\naic_outb(p, cur_addr & 0xff, SHADDR);\r\naic_outb(p, (cur_addr >> 8) & 0xff, SHADDR + 1);\r\naic_outb(p, (cur_addr >> 16) & 0xff, SHADDR + 2);\r\naic_outb(p, (cur_addr >> 24) & 0xff, SHADDR + 3);\r\n}\r\n}\r\nbreak;\r\ncase SEQ_SG_FIXUP:\r\n{\r\nunsigned char scb_index, tmp;\r\nint sg_addr, sg_length;\r\nscb_index = aic_inb(p, SCB_TAG);\r\nif(scb_index > p->scb_data->numscbs)\r\n{\r\nprintk(WARN_LEAD "invalid scb_index during SEQ_SG_FIXUP.\n",\r\np->host_no, -1, -1, -1);\r\nprintk(INFO_LEAD "SCSISIGI 0x%x, SEQADDR 0x%x, SSTAT0 0x%x, SSTAT1 "\r\n"0x%x\n", p->host_no, -1, -1, -1,\r\naic_inb(p, SCSISIGI),\r\naic_inb(p, SEQADDR0) | (aic_inb(p, SEQADDR1) << 8),\r\naic_inb(p, SSTAT0), aic_inb(p, SSTAT1));\r\nprintk(INFO_LEAD "SG_CACHEPTR 0x%x, SSTAT2 0x%x, STCNT 0x%x\n",\r\np->host_no, -1, -1, -1, aic_inb(p, SG_CACHEPTR),\r\naic_inb(p, SSTAT2), aic_inb(p, STCNT + 2) << 16 |\r\naic_inb(p, STCNT + 1) << 8 | aic_inb(p, STCNT));\r\nbreak;\r\n}\r\nscb = p->scb_data->scb_array[scb_index];\r\nif(!(scb->flags & SCB_ACTIVE) || (scb->cmd == NULL))\r\n{\r\nprintk(WARN_LEAD "invalid scb during SEQ_SG_FIXUP flags:0x%x "\r\n"scb->cmd:0x%p\n", p->host_no, CTL_OF_SCB(scb),\r\nscb->flags, scb->cmd);\r\nprintk(INFO_LEAD "SCSISIGI 0x%x, SEQADDR 0x%x, SSTAT0 0x%x, SSTAT1 "\r\n"0x%x\n", p->host_no, CTL_OF_SCB(scb),\r\naic_inb(p, SCSISIGI),\r\naic_inb(p, SEQADDR0) | (aic_inb(p, SEQADDR1) << 8),\r\naic_inb(p, SSTAT0), aic_inb(p, SSTAT1));\r\nprintk(INFO_LEAD "SG_CACHEPTR 0x%x, SSTAT2 0x%x, STCNT 0x%x\n",\r\np->host_no, CTL_OF_SCB(scb), aic_inb(p, SG_CACHEPTR),\r\naic_inb(p, SSTAT2), aic_inb(p, STCNT + 2) << 16 |\r\naic_inb(p, STCNT + 1) << 8 | aic_inb(p, STCNT));\r\nbreak;\r\n}\r\nif(aic7xxx_verbose & VERBOSE_MINOR_ERROR)\r\nprintk(INFO_LEAD "Fixing up SG address for sequencer.\n", p->host_no,\r\nCTL_OF_SCB(scb));\r\ntmp = aic_inb(p, SG_NEXT);\r\ntmp += SG_SIZEOF;\r\naic_outb(p, tmp, SG_NEXT);\r\nif( tmp < SG_SIZEOF )\r\naic_outb(p, aic_inb(p, SG_NEXT + 1) + 1, SG_NEXT + 1);\r\ntmp = aic_inb(p, SG_COUNT) - 1;\r\naic_outb(p, tmp, SG_COUNT);\r\nsg_addr = le32_to_cpu(scb->sg_list[scb->sg_count - tmp].address);\r\nsg_length = le32_to_cpu(scb->sg_list[scb->sg_count - tmp].length);\r\naic_outb(p, sg_addr & 0xff, HADDR);\r\naic_outb(p, (sg_addr >> 8) & 0xff, HADDR + 1);\r\naic_outb(p, (sg_addr >> 16) & 0xff, HADDR + 2);\r\naic_outb(p, (sg_addr >> 24) & 0xff, HADDR + 3);\r\naic_outb(p, sg_length & 0xff, HCNT);\r\naic_outb(p, (sg_length >> 8) & 0xff, HCNT + 1);\r\naic_outb(p, (sg_length >> 16) & 0xff, HCNT + 2);\r\naic_outb(p, (tmp << 2) | ((tmp == 1) ? LAST_SEG : 0), SG_CACHEPTR);\r\naic_outb(p, aic_inb(p, DMAPARAMS), DFCNTRL);\r\nwhile(aic_inb(p, SSTAT0) & SDONE) udelay(1);\r\nwhile(aic_inb(p, DFCNTRL) & (HDMAEN|SCSIEN)) aic_outb(p, 0, DFCNTRL);\r\n}\r\nbreak;\r\n#ifdef AIC7XXX_NOT_YET\r\ncase TRACEPOINT2:\r\n{\r\nprintk(INFO_LEAD "Tracepoint #2 reached.\n", p->host_no,\r\nchannel, target, lun);\r\n}\r\nbreak;\r\ncase MSG_BUFFER_BUSY:\r\nprintk("aic7xxx: Message buffer busy.\n");\r\nbreak;\r\ncase MSGIN_PHASEMIS:\r\nprintk("aic7xxx: Message-in phasemis.\n");\r\nbreak;\r\n#endif\r\ndefault:\r\nprintk(WARN_LEAD "Unknown SEQINT, INTSTAT 0x%x, SCSISIGI 0x%x.\n",\r\np->host_no, channel, target, lun, intstat,\r\naic_inb(p, SCSISIGI));\r\nbreak;\r\n}\r\nunpause_sequencer(p, TRUE);\r\n}\r\nstatic int\r\naic7xxx_parse_msg(struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\nint reject, reply, done;\r\nunsigned char target_scsirate, tindex;\r\nunsigned short target_mask;\r\nunsigned char target, channel, lun;\r\nunsigned char bus_width, new_bus_width;\r\nunsigned char trans_options, new_trans_options;\r\nunsigned int period, new_period, offset, new_offset, maxsync;\r\nstruct aic7xxx_syncrate *syncrate;\r\nstruct aic_dev_data *aic_dev;\r\ntarget = scb->cmd->device->id;\r\nchannel = scb->cmd->device->channel;\r\nlun = scb->cmd->device->lun;\r\nreply = reject = done = FALSE;\r\ntindex = TARGET_INDEX(scb->cmd);\r\naic_dev = AIC_DEV(scb->cmd);\r\ntarget_scsirate = aic_inb(p, TARG_SCSIRATE + tindex);\r\ntarget_mask = (0x01 << tindex);\r\nif (p->msg_buf[0] != MSG_EXTENDED)\r\n{\r\nreject = TRUE;\r\n}\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nif ( (aic_inb(p, SBLKCTL) & ENAB40) &&\r\n!(aic_inb(p, SSTAT2) & EXP_ACTIVE) )\r\n{\r\nif (p->features & AHC_ULTRA3)\r\nmaxsync = AHC_SYNCRATE_ULTRA3;\r\nelse\r\nmaxsync = AHC_SYNCRATE_ULTRA2;\r\n}\r\nelse\r\n{\r\nmaxsync = AHC_SYNCRATE_ULTRA;\r\n}\r\n}\r\nelse if (p->features & AHC_ULTRA)\r\n{\r\nmaxsync = AHC_SYNCRATE_ULTRA;\r\n}\r\nelse\r\n{\r\nmaxsync = AHC_SYNCRATE_FAST;\r\n}\r\nif ( !reject && (p->msg_len > 2) )\r\n{\r\nswitch(p->msg_buf[2])\r\n{\r\ncase MSG_EXT_SDTR:\r\n{\r\nif (p->msg_buf[1] != MSG_EXT_SDTR_LEN)\r\n{\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (p->msg_len < (MSG_EXT_SDTR_LEN + 2))\r\n{\r\nbreak;\r\n}\r\nperiod = new_period = p->msg_buf[3];\r\noffset = new_offset = p->msg_buf[4];\r\ntrans_options = new_trans_options = 0;\r\nbus_width = new_bus_width = target_scsirate & WIDEXFER;\r\nif(maxsync == AHC_SYNCRATE_ULTRA3)\r\nmaxsync = AHC_SYNCRATE_ULTRA2;\r\nif ( (scb->flags & (SCB_MSGOUT_SENT|SCB_MSGOUT_SDTR)) !=\r\n(SCB_MSGOUT_SENT|SCB_MSGOUT_SDTR) )\r\n{\r\nif (!(aic_dev->flags & DEVICE_DTR_SCANNED))\r\n{\r\naic_dev->goal.width = MSG_EXT_WDTR_BUS_8_BIT;\r\naic_dev->goal.options = 0;\r\nif(p->user[tindex].offset)\r\n{\r\naic_dev->needsdtr_copy = 1;\r\naic_dev->goal.period = max_t(unsigned char, 10,p->user[tindex].period);\r\nif(p->features & AHC_ULTRA2)\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_ULTRA2;\r\n}\r\nelse\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_8BIT;\r\n}\r\n}\r\nelse\r\n{\r\naic_dev->needsdtr_copy = 0;\r\naic_dev->goal.period = 255;\r\naic_dev->goal.offset = 0;\r\n}\r\naic_dev->flags |= DEVICE_DTR_SCANNED | DEVICE_PRINT_DTR;\r\n}\r\nelse if (aic_dev->needsdtr_copy == 0)\r\n{\r\nreject = TRUE;\r\nbreak;\r\n}\r\nreply = TRUE;\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Received pre-emptive SDTR message from "\r\n"target.\n", p->host_no, CTL_OF_SCB(scb));\r\n}\r\nnew_period = max_t(unsigned int, period, aic_dev->goal.period);\r\nnew_offset = min_t(unsigned int, offset, aic_dev->goal.offset);\r\n}\r\nsyncrate = aic7xxx_find_syncrate(p, &new_period, maxsync,\r\n&trans_options);\r\naic7xxx_validate_offset(p, syncrate, &new_offset, bus_width);\r\nif ((new_offset == 0) && (new_offset != offset))\r\n{\r\naic_dev->needsdtr_copy = 0;\r\nreply = TRUE;\r\n}\r\nif(reply)\r\n{\r\naic7xxx_set_syncrate(p, syncrate, target, channel, new_period,\r\nnew_offset, trans_options,\r\nAHC_TRANS_GOAL|AHC_TRANS_ACTIVE|AHC_TRANS_CUR,\r\naic_dev);\r\nscb->flags &= ~SCB_MSGOUT_BITS;\r\nscb->flags |= SCB_MSGOUT_SDTR;\r\naic_outb(p, HOST_MSG, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGO) | ATNO, SCSISIGO);\r\n}\r\nelse\r\n{\r\naic7xxx_set_syncrate(p, syncrate, target, channel, new_period,\r\nnew_offset, trans_options,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_CUR, aic_dev);\r\naic_dev->needsdtr = 0;\r\n}\r\ndone = TRUE;\r\nbreak;\r\n}\r\ncase MSG_EXT_WDTR:\r\n{\r\nif (p->msg_buf[1] != MSG_EXT_WDTR_LEN)\r\n{\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (p->msg_len < (MSG_EXT_WDTR_LEN + 2))\r\n{\r\nbreak;\r\n}\r\nbus_width = new_bus_width = p->msg_buf[3];\r\nif ( (scb->flags & (SCB_MSGOUT_SENT|SCB_MSGOUT_WDTR)) ==\r\n(SCB_MSGOUT_SENT|SCB_MSGOUT_WDTR) )\r\n{\r\nswitch(bus_width)\r\n{\r\ndefault:\r\n{\r\nreject = TRUE;\r\nif ( (aic7xxx_verbose & VERBOSE_NEGOTIATION2) &&\r\n((aic_dev->flags & DEVICE_PRINT_DTR) ||\r\n(aic7xxx_verbose > 0xffff)) )\r\n{\r\nprintk(INFO_LEAD "Requesting %d bit transfers, rejecting.\n",\r\np->host_no, CTL_OF_SCB(scb), 8 * (0x01 << bus_width));\r\n}\r\n}\r\ncase MSG_EXT_WDTR_BUS_8_BIT:\r\n{\r\naic_dev->goal.width = MSG_EXT_WDTR_BUS_8_BIT;\r\naic_dev->needwdtr_copy &= ~target_mask;\r\nbreak;\r\n}\r\ncase MSG_EXT_WDTR_BUS_16_BIT:\r\n{\r\nbreak;\r\n}\r\n}\r\naic_dev->needwdtr = 0;\r\naic7xxx_set_width(p, target, channel, lun, new_bus_width,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_CUR, aic_dev);\r\n}\r\nelse\r\n{\r\nif ( !(aic_dev->flags & DEVICE_DTR_SCANNED) )\r\n{\r\nif( (p->features & AHC_WIDE) && p->user[tindex].width )\r\n{\r\naic_dev->goal.width = MSG_EXT_WDTR_BUS_16_BIT;\r\naic_dev->needwdtr_copy = 1;\r\n}\r\naic_dev->goal.options = 0;\r\nif(p->user[tindex].offset)\r\n{\r\naic_dev->needsdtr_copy = 1;\r\naic_dev->goal.period = max_t(unsigned char, 10, p->user[tindex].period);\r\nif(p->features & AHC_ULTRA2)\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_ULTRA2;\r\n}\r\nelse if( aic_dev->goal.width )\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_16BIT;\r\n}\r\nelse\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_8BIT;\r\n}\r\n} else {\r\naic_dev->needsdtr_copy = 0;\r\naic_dev->goal.period = 255;\r\naic_dev->goal.offset = 0;\r\n}\r\naic_dev->flags |= DEVICE_DTR_SCANNED | DEVICE_PRINT_DTR;\r\n}\r\nelse if (aic_dev->needwdtr_copy == 0)\r\n{\r\nreject = TRUE;\r\nbreak;\r\n}\r\nreply = TRUE;\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Received pre-emptive WDTR message from "\r\n"target.\n", p->host_no, CTL_OF_SCB(scb));\r\n}\r\nswitch(bus_width)\r\n{\r\ncase MSG_EXT_WDTR_BUS_16_BIT:\r\n{\r\nif ( (p->features & AHC_WIDE) &&\r\n(aic_dev->goal.width == MSG_EXT_WDTR_BUS_16_BIT) )\r\n{\r\nnew_bus_width = MSG_EXT_WDTR_BUS_16_BIT;\r\nbreak;\r\n}\r\n}\r\ndefault:\r\ncase MSG_EXT_WDTR_BUS_8_BIT:\r\n{\r\naic_dev->needwdtr_copy = 0;\r\nnew_bus_width = MSG_EXT_WDTR_BUS_8_BIT;\r\nbreak;\r\n}\r\n}\r\nscb->flags &= ~SCB_MSGOUT_BITS;\r\nscb->flags |= SCB_MSGOUT_WDTR;\r\naic_dev->needwdtr = 0;\r\nif(aic_dev->dtr_pending == 0)\r\n{\r\naic_dev->dtr_pending = 1;\r\nscb->flags |= SCB_DTR_SCB;\r\n}\r\naic_outb(p, HOST_MSG, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGO) | ATNO, SCSISIGO);\r\naic7xxx_set_width(p, target, channel, lun, new_bus_width,\r\nAHC_TRANS_GOAL|AHC_TRANS_ACTIVE|AHC_TRANS_CUR,\r\naic_dev);\r\n}\r\naic7xxx_set_syncrate(p, NULL, target, channel, 0, 0, 0,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_CUR|AHC_TRANS_QUITE,\r\naic_dev);\r\naic_dev->needsdtr = aic_dev->needsdtr_copy;\r\ndone = TRUE;\r\nbreak;\r\n}\r\ncase MSG_EXT_PPR:\r\n{\r\nif (p->msg_buf[1] != MSG_EXT_PPR_LEN)\r\n{\r\nreject = TRUE;\r\nbreak;\r\n}\r\nif (p->msg_len < (MSG_EXT_PPR_LEN + 2))\r\n{\r\nbreak;\r\n}\r\nperiod = new_period = p->msg_buf[3];\r\noffset = new_offset = p->msg_buf[5];\r\nbus_width = new_bus_width = p->msg_buf[6];\r\ntrans_options = new_trans_options = p->msg_buf[7] & 0xf;\r\nif(aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Parsing PPR message (%d/%d/%d/%d)\n",\r\np->host_no, CTL_OF_SCB(scb), period, offset, bus_width,\r\ntrans_options);\r\n}\r\nif ( (scb->flags & (SCB_MSGOUT_SENT|SCB_MSGOUT_PPR)) !=\r\n(SCB_MSGOUT_SENT|SCB_MSGOUT_PPR) )\r\n{\r\nif (!(aic_dev->flags & DEVICE_DTR_SCANNED))\r\n{\r\naic_dev->needppr = aic_dev->needppr_copy = 1;\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 0;\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 0;\r\naic_dev->flags |= DEVICE_SCSI_3;\r\naic_dev->goal.width = p->user[tindex].width;\r\nif(p->user[tindex].offset)\r\n{\r\naic_dev->goal.period = p->user[tindex].period;\r\naic_dev->goal.options = p->user[tindex].options;\r\nif(p->features & AHC_ULTRA2)\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_ULTRA2;\r\n}\r\nelse if( aic_dev->goal.width &&\r\n(bus_width == MSG_EXT_WDTR_BUS_16_BIT) &&\r\np->features & AHC_WIDE )\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_16BIT;\r\n}\r\nelse\r\n{\r\naic_dev->goal.offset = MAX_OFFSET_8BIT;\r\n}\r\n}\r\nelse\r\n{\r\naic_dev->goal.period = 255;\r\naic_dev->goal.offset = 0;\r\naic_dev->goal.options = 0;\r\n}\r\naic_dev->flags |= DEVICE_DTR_SCANNED | DEVICE_PRINT_DTR;\r\n}\r\nelse if (aic_dev->needppr_copy == 0)\r\n{\r\nreject = TRUE;\r\nbreak;\r\n}\r\nreply = TRUE;\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Received pre-emptive PPR message from "\r\n"target.\n", p->host_no, CTL_OF_SCB(scb));\r\n}\r\n}\r\nswitch(bus_width)\r\n{\r\ncase MSG_EXT_WDTR_BUS_16_BIT:\r\n{\r\nif ( (aic_dev->goal.width == MSG_EXT_WDTR_BUS_16_BIT) &&\r\np->features & AHC_WIDE)\r\n{\r\nbreak;\r\n}\r\n}\r\ndefault:\r\n{\r\nif ( (aic7xxx_verbose & VERBOSE_NEGOTIATION2) &&\r\n((aic_dev->flags & DEVICE_PRINT_DTR) ||\r\n(aic7xxx_verbose > 0xffff)) )\r\n{\r\nreply = TRUE;\r\nprintk(INFO_LEAD "Requesting %d bit transfers, rejecting.\n",\r\np->host_no, CTL_OF_SCB(scb), 8 * (0x01 << bus_width));\r\n}\r\n}\r\ncase MSG_EXT_WDTR_BUS_8_BIT:\r\n{\r\nnew_trans_options = 0;\r\nnew_bus_width = MSG_EXT_WDTR_BUS_8_BIT;\r\nbreak;\r\n}\r\n}\r\nif(reply)\r\n{\r\naic7xxx_set_width(p, target, channel, lun, new_bus_width,\r\nAHC_TRANS_GOAL|AHC_TRANS_ACTIVE|AHC_TRANS_CUR,\r\naic_dev);\r\nsyncrate = aic7xxx_find_syncrate(p, &new_period, maxsync,\r\n&new_trans_options);\r\naic7xxx_validate_offset(p, syncrate, &new_offset, new_bus_width);\r\naic7xxx_set_syncrate(p, syncrate, target, channel, new_period,\r\nnew_offset, new_trans_options,\r\nAHC_TRANS_GOAL|AHC_TRANS_ACTIVE|AHC_TRANS_CUR,\r\naic_dev);\r\n}\r\nelse\r\n{\r\naic7xxx_set_width(p, target, channel, lun, new_bus_width,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_CUR, aic_dev);\r\nsyncrate = aic7xxx_find_syncrate(p, &new_period, maxsync,\r\n&new_trans_options);\r\naic7xxx_validate_offset(p, syncrate, &new_offset, new_bus_width);\r\naic7xxx_set_syncrate(p, syncrate, target, channel, new_period,\r\nnew_offset, new_trans_options,\r\nAHC_TRANS_ACTIVE|AHC_TRANS_CUR, aic_dev);\r\n}\r\nif(new_trans_options == 0)\r\n{\r\naic_dev->needppr = aic_dev->needppr_copy = 0;\r\nif(new_offset)\r\n{\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 1;\r\n}\r\nif (new_bus_width)\r\n{\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 1;\r\n}\r\n}\r\nif((new_offset == 0) && (offset != 0))\r\n{\r\nreply = TRUE;\r\n}\r\nif(reply)\r\n{\r\nscb->flags &= ~SCB_MSGOUT_BITS;\r\nscb->flags |= SCB_MSGOUT_PPR;\r\naic_outb(p, HOST_MSG, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGO) | ATNO, SCSISIGO);\r\n}\r\nelse\r\n{\r\naic_dev->needppr = 0;\r\n}\r\ndone = TRUE;\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nreject = TRUE;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!reply && reject)\r\n{\r\naic_outb(p, MSG_MESSAGE_REJECT, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGO) | ATNO, SCSISIGO);\r\ndone = TRUE;\r\n}\r\nreturn(done);\r\n}\r\nstatic void\r\naic7xxx_handle_reqinit(struct aic7xxx_host *p, struct aic7xxx_scb *scb)\r\n{\r\nunsigned char lastbyte;\r\nunsigned char phasemis;\r\nint done = FALSE;\r\nswitch(p->msg_type)\r\n{\r\ncase MSG_TYPE_INITIATOR_MSGOUT:\r\n{\r\nif (p->msg_len == 0)\r\npanic("aic7xxx: REQINIT with no active message!\n");\r\nlastbyte = (p->msg_index == (p->msg_len - 1));\r\nphasemis = ( aic_inb(p, SCSISIGI) & PHASE_MASK) != P_MESGOUT;\r\nif (lastbyte || phasemis)\r\n{\r\np->msg_len = 0;\r\np->msg_type = MSG_TYPE_NONE;\r\naic_outb(p, aic_inb(p, SIMODE1) & ~ENREQINIT, SIMODE1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\np->flags &= ~AHC_HANDLING_REQINITS;\r\nif (phasemis == 0)\r\n{\r\naic_outb(p, p->msg_buf[p->msg_index], SINDEX);\r\naic_outb(p, 0, RETURN_1);\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose > 0xffff)\r\nprintk(INFO_LEAD "Completed sending of REQINIT message.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n#endif\r\n}\r\nelse\r\n{\r\naic_outb(p, MSGOUT_PHASEMIS, RETURN_1);\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose > 0xffff)\r\nprintk(INFO_LEAD "PHASEMIS while sending REQINIT message.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n#endif\r\n}\r\nunpause_sequencer(p, TRUE);\r\n}\r\nelse\r\n{\r\naic_outb(p, CLRREQINIT, CLRSINT1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\naic_outb(p, p->msg_buf[p->msg_index++], SCSIDATL);\r\n}\r\nbreak;\r\n}\r\ncase MSG_TYPE_INITIATOR_MSGIN:\r\n{\r\nphasemis = ( aic_inb(p, SCSISIGI) & PHASE_MASK ) != P_MESGIN;\r\nif (phasemis == 0)\r\n{\r\np->msg_len++;\r\np->msg_buf[p->msg_index] = aic_inb(p, SCSIBUSL);\r\ndone = aic7xxx_parse_msg(p, scb);\r\naic_outb(p, CLRREQINIT, CLRSINT1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\naic_inb(p, SCSIDATL);\r\np->msg_index++;\r\n}\r\nif (phasemis || done)\r\n{\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose > 0xffff)\r\n{\r\nif (phasemis)\r\nprintk(INFO_LEAD "PHASEMIS while receiving REQINIT message.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\nelse\r\nprintk(INFO_LEAD "Completed receipt of REQINIT message.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n}\r\n#endif\r\np->msg_len = 0;\r\np->msg_type = MSG_TYPE_NONE;\r\naic_outb(p, aic_inb(p, SIMODE1) & ~ENREQINIT, SIMODE1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\np->flags &= ~AHC_HANDLING_REQINITS;\r\nunpause_sequencer(p, TRUE);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\n{\r\npanic("aic7xxx: Unknown REQINIT message type.\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\naic7xxx_handle_scsiint(struct aic7xxx_host *p, unsigned char intstat)\r\n{\r\nunsigned char scb_index;\r\nunsigned char status;\r\nstruct aic7xxx_scb *scb;\r\nstruct aic_dev_data *aic_dev;\r\nscb_index = aic_inb(p, SCB_TAG);\r\nstatus = aic_inb(p, SSTAT1);\r\nif (scb_index < p->scb_data->numscbs)\r\n{\r\nscb = p->scb_data->scb_array[scb_index];\r\nif ((scb->flags & SCB_ACTIVE) == 0)\r\n{\r\nscb = NULL;\r\n}\r\n}\r\nelse\r\n{\r\nscb = NULL;\r\n}\r\nif ((status & SCSIRSTI) != 0)\r\n{\r\nint channel;\r\nif ( (p->chip & AHC_CHIPID_MASK) == AHC_AIC7770 )\r\nchannel = (aic_inb(p, SBLKCTL) & SELBUSB) >> 3;\r\nelse\r\nchannel = 0;\r\nif (aic7xxx_verbose & VERBOSE_RESET)\r\nprintk(WARN_LEAD "Someone else reset the channel!!\n",\r\np->host_no, channel, -1, -1);\r\nif (aic7xxx_panic_on_abort)\r\naic7xxx_panic_abort(p, NULL);\r\naic7xxx_reset_channel(p, channel, FALSE);\r\naic7xxx_run_done_queue(p, TRUE);\r\nscb = NULL;\r\n}\r\nelse if ( ((status & BUSFREE) != 0) && ((status & SELTO) == 0) )\r\n{\r\nunsigned char lastphase = aic_inb(p, LASTPHASE);\r\nunsigned char saved_tcl = aic_inb(p, SAVED_TCL);\r\nunsigned char target = (saved_tcl >> 4) & 0x0F;\r\nint channel;\r\nint printerror = TRUE;\r\nif ( (p->chip & AHC_CHIPID_MASK) == AHC_AIC7770 )\r\nchannel = (aic_inb(p, SBLKCTL) & SELBUSB) >> 3;\r\nelse\r\nchannel = 0;\r\naic_outb(p, aic_inb(p, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP),\r\nSCSISEQ);\r\nif (lastphase == P_MESGOUT)\r\n{\r\nunsigned char message;\r\nmessage = aic_inb(p, SINDEX);\r\nif ((message == MSG_ABORT) || (message == MSG_ABORT_TAG))\r\n{\r\nif (aic7xxx_verbose & VERBOSE_ABORT_PROCESS)\r\nprintk(INFO_LEAD "SCB %d abort delivered.\n", p->host_no,\r\nCTL_OF_SCB(scb), scb->hscb->tag);\r\naic7xxx_reset_device(p, target, channel, ALL_LUNS,\r\n(message == MSG_ABORT) ? SCB_LIST_NULL : scb->hscb->tag );\r\naic7xxx_run_done_queue(p, TRUE);\r\nscb = NULL;\r\nprinterror = 0;\r\n}\r\nelse if (message == MSG_BUS_DEV_RESET)\r\n{\r\naic7xxx_handle_device_reset(p, target, channel);\r\nscb = NULL;\r\nprinterror = 0;\r\n}\r\n}\r\nif ( (scb != NULL) && (scb->flags & SCB_DTR_SCB) )\r\n{\r\nprinterror = 0;\r\naic7xxx_reset_device(p, target, channel, ALL_LUNS, scb->hscb->tag);\r\naic7xxx_run_done_queue(p, TRUE);\r\nscb = NULL;\r\n}\r\nif (printerror != 0)\r\n{\r\nif (scb != NULL)\r\n{\r\nunsigned char tag;\r\nif ((scb->hscb->control & TAG_ENB) != 0)\r\n{\r\ntag = scb->hscb->tag;\r\n}\r\nelse\r\n{\r\ntag = SCB_LIST_NULL;\r\n}\r\naic7xxx_reset_device(p, target, channel, ALL_LUNS, tag);\r\naic7xxx_run_done_queue(p, TRUE);\r\n}\r\nelse\r\n{\r\naic7xxx_reset_device(p, target, channel, ALL_LUNS, SCB_LIST_NULL);\r\naic7xxx_run_done_queue(p, TRUE);\r\n}\r\nprintk(INFO_LEAD "Unexpected busfree, LASTPHASE = 0x%x, "\r\n"SEQADDR = 0x%x\n", p->host_no, channel, target, -1, lastphase,\r\n(aic_inb(p, SEQADDR1) << 8) | aic_inb(p, SEQADDR0));\r\nscb = NULL;\r\n}\r\naic_outb(p, MSG_NOOP, MSG_OUT);\r\naic_outb(p, aic_inb(p, SIMODE1) & ~(ENBUSFREE|ENREQINIT),\r\nSIMODE1);\r\np->flags &= ~AHC_HANDLING_REQINITS;\r\naic_outb(p, CLRBUSFREE, CLRSINT1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\nrestart_sequencer(p);\r\nunpause_sequencer(p, TRUE);\r\n}\r\nelse if ((status & SELTO) != 0)\r\n{\r\nunsigned char scbptr;\r\nunsigned char nextscb;\r\nstruct scsi_cmnd *cmd;\r\nscbptr = aic_inb(p, WAITING_SCBH);\r\nif (scbptr > p->scb_data->maxhscbs)\r\n{\r\nprintk(INFO_LEAD "Invalid WAITING_SCBH value %d, improvising.\n",\r\np->host_no, -1, -1, -1, scbptr);\r\nif (p->scb_data->maxhscbs > 4)\r\nscbptr &= (p->scb_data->maxhscbs - 1);\r\nelse\r\nscbptr &= 0x03;\r\n}\r\naic_outb(p, scbptr, SCBPTR);\r\nscb_index = aic_inb(p, SCB_TAG);\r\nscb = NULL;\r\nif (scb_index < p->scb_data->numscbs)\r\n{\r\nscb = p->scb_data->scb_array[scb_index];\r\nif ((scb->flags & SCB_ACTIVE) == 0)\r\n{\r\nscb = NULL;\r\n}\r\n}\r\nif (scb == NULL)\r\n{\r\nprintk(WARN_LEAD "Referenced SCB %d not valid during SELTO.\n",\r\np->host_no, -1, -1, -1, scb_index);\r\nprintk(KERN_WARNING " SCSISEQ = 0x%x SEQADDR = 0x%x SSTAT0 = 0x%x "\r\n"SSTAT1 = 0x%x\n", aic_inb(p, SCSISEQ),\r\naic_inb(p, SEQADDR0) | (aic_inb(p, SEQADDR1) << 8),\r\naic_inb(p, SSTAT0), aic_inb(p, SSTAT1));\r\nif (aic7xxx_panic_on_abort)\r\naic7xxx_panic_abort(p, NULL);\r\n}\r\nelse\r\n{\r\ncmd = scb->cmd;\r\ncmd->result = (DID_TIME_OUT << 16);\r\naic_outb(p, 0, SCB_CONTROL);\r\naic_outb(p, MSG_NOOP, MSG_OUT);\r\nnextscb = aic_inb(p, SCB_NEXT);\r\naic_outb(p, nextscb, WAITING_SCBH);\r\naic7xxx_add_curscb_to_free_list(p);\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose > 0xffff)\r\nprintk(INFO_LEAD "Selection Timeout.\n", p->host_no, CTL_OF_SCB(scb));\r\n#endif\r\nif (scb->flags & SCB_QUEUED_ABORT)\r\n{\r\ncmd->result = 0;\r\nscb = NULL;\r\n}\r\n}\r\naic_outb(p, aic_inb(p, SCSISEQ) & ~ENSELO, SCSISEQ);\r\nif( (p->chip & ~AHC_CHIPID_MASK) == AHC_PCI )\r\naic_outb(p, 0, SCSIBUSL);\r\nudelay(301);\r\naic_outb(p, CLRSELINGO, CLRSINT0);\r\naic_outb(p, aic_inb(p, SIMODE1) & ~(ENREQINIT|ENBUSFREE), SIMODE1);\r\np->flags &= ~AHC_HANDLING_REQINITS;\r\naic_outb(p, CLRSELTIMEO | CLRBUSFREE, CLRSINT1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\nrestart_sequencer(p);\r\nunpause_sequencer(p, TRUE);\r\n}\r\nelse if (scb == NULL)\r\n{\r\nprintk(WARN_LEAD "aic7xxx_isr - referenced scb not valid "\r\n"during scsiint 0x%x scb(%d)\n"\r\n" SIMODE0 0x%x, SIMODE1 0x%x, SSTAT0 0x%x, SEQADDR 0x%x\n",\r\np->host_no, -1, -1, -1, status, scb_index, aic_inb(p, SIMODE0),\r\naic_inb(p, SIMODE1), aic_inb(p, SSTAT0),\r\n(aic_inb(p, SEQADDR1) << 8) | aic_inb(p, SEQADDR0));\r\naic_outb(p, status, CLRSINT1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\nunpause_sequencer(p, TRUE);\r\nscb = NULL;\r\n}\r\nelse if (status & SCSIPERR)\r\n{\r\nchar *phase;\r\nstruct scsi_cmnd *cmd;\r\nunsigned char mesg_out = MSG_NOOP;\r\nunsigned char lastphase = aic_inb(p, LASTPHASE);\r\nunsigned char sstat2 = aic_inb(p, SSTAT2);\r\ncmd = scb->cmd;\r\nswitch (lastphase)\r\n{\r\ncase P_DATAOUT:\r\nphase = "Data-Out";\r\nbreak;\r\ncase P_DATAIN:\r\nphase = "Data-In";\r\nmesg_out = MSG_INITIATOR_DET_ERR;\r\nbreak;\r\ncase P_COMMAND:\r\nphase = "Command";\r\nbreak;\r\ncase P_MESGOUT:\r\nphase = "Message-Out";\r\nbreak;\r\ncase P_STATUS:\r\nphase = "Status";\r\nmesg_out = MSG_INITIATOR_DET_ERR;\r\nbreak;\r\ncase P_MESGIN:\r\nphase = "Message-In";\r\nmesg_out = MSG_PARITY_ERROR;\r\nbreak;\r\ndefault:\r\nphase = "unknown";\r\nbreak;\r\n}\r\nif( (p->features & AHC_ULTRA3) &&\r\n(aic_inb(p, SCSIRATE) & AHC_SYNCRATE_CRC) &&\r\n(lastphase == P_DATAIN) )\r\n{\r\nprintk(WARN_LEAD "CRC error during %s phase.\n",\r\np->host_no, CTL_OF_SCB(scb), phase);\r\nif(sstat2 & CRCVALERR)\r\n{\r\nprintk(WARN_LEAD " CRC error in intermediate CRC packet.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n}\r\nif(sstat2 & CRCENDERR)\r\n{\r\nprintk(WARN_LEAD " CRC error in ending CRC packet.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n}\r\nif(sstat2 & CRCREQERR)\r\n{\r\nprintk(WARN_LEAD " Target incorrectly requested a CRC packet.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n}\r\nif(sstat2 & DUAL_EDGE_ERROR)\r\n{\r\nprintk(WARN_LEAD " Dual Edge transmission error.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\n}\r\n}\r\nelse if( (lastphase == P_MESGOUT) &&\r\n(scb->flags & SCB_MSGOUT_PPR) )\r\n{\r\naic_dev = AIC_DEV(scb->cmd);\r\naic_dev->needppr = aic_dev->needppr_copy = 0;\r\naic7xxx_set_width(p, scb->cmd->device->id, scb->cmd->device->channel, scb->cmd->device->lun,\r\nMSG_EXT_WDTR_BUS_8_BIT,\r\n(AHC_TRANS_ACTIVE|AHC_TRANS_CUR|AHC_TRANS_QUITE),\r\naic_dev);\r\naic7xxx_set_syncrate(p, NULL, scb->cmd->device->id, scb->cmd->device->channel, 0, 0,\r\n0, AHC_TRANS_ACTIVE|AHC_TRANS_CUR|AHC_TRANS_QUITE,\r\naic_dev);\r\naic_dev->goal.options = 0;\r\nscb->flags &= ~SCB_MSGOUT_BITS;\r\nif(aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "parity error during PPR message, reverting "\r\n"to WDTR/SDTR\n", p->host_no, CTL_OF_SCB(scb));\r\n}\r\nif ( aic_dev->goal.width )\r\n{\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 1;\r\n}\r\nif ( aic_dev->goal.offset )\r\n{\r\nif( aic_dev->goal.period <= 9 )\r\n{\r\naic_dev->goal.period = 10;\r\n}\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 1;\r\n}\r\nscb = NULL;\r\n}\r\nif (mesg_out != MSG_NOOP)\r\n{\r\naic_outb(p, mesg_out, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGI) | ATNO, SCSISIGO);\r\nscb = NULL;\r\n}\r\naic_outb(p, CLRSCSIPERR, CLRSINT1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\nunpause_sequencer(p, TRUE);\r\n}\r\nelse if ( (status & REQINIT) &&\r\n(p->flags & AHC_HANDLING_REQINITS) )\r\n{\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic7xxx_verbose > 0xffff)\r\nprintk(INFO_LEAD "Handling REQINIT, SSTAT1=0x%x.\n", p->host_no,\r\nCTL_OF_SCB(scb), aic_inb(p, SSTAT1));\r\n#endif\r\naic7xxx_handle_reqinit(p, scb);\r\nreturn;\r\n}\r\nelse\r\n{\r\nif (aic7xxx_verbose & VERBOSE_SCSIINT)\r\nprintk(INFO_LEAD "Unknown SCSIINT status, SSTAT1(0x%x).\n",\r\np->host_no, -1, -1, -1, status);\r\naic_outb(p, status, CLRSINT1);\r\naic_outb(p, CLRSCSIINT, CLRINT);\r\nunpause_sequencer(p, TRUE);\r\nscb = NULL;\r\n}\r\nif (scb != NULL)\r\n{\r\naic7xxx_done(p, scb);\r\n}\r\n}\r\nstatic void\r\naic7xxx_check_scbs(struct aic7xxx_host *p, char *buffer)\r\n{\r\nunsigned char saved_scbptr, free_scbh, dis_scbh, wait_scbh, temp;\r\nint i, bogus, lost;\r\nstatic unsigned char scb_status[AIC7XXX_MAXSCB];\r\n#define SCB_NO_LIST 0\r\n#define SCB_FREE_LIST 1\r\n#define SCB_WAITING_LIST 2\r\n#define SCB_DISCONNECTED_LIST 4\r\n#define SCB_CURRENTLY_ACTIVE 8\r\nbogus = FALSE;\r\nmemset(&scb_status[0], 0, sizeof(scb_status));\r\npause_sequencer(p);\r\nsaved_scbptr = aic_inb(p, SCBPTR);\r\nif (saved_scbptr >= p->scb_data->maxhscbs)\r\n{\r\nprintk("Bogus SCBPTR %d\n", saved_scbptr);\r\nbogus = TRUE;\r\n}\r\nscb_status[saved_scbptr] = SCB_CURRENTLY_ACTIVE;\r\nfree_scbh = aic_inb(p, FREE_SCBH);\r\nif ( (free_scbh != SCB_LIST_NULL) &&\r\n(free_scbh >= p->scb_data->maxhscbs) )\r\n{\r\nprintk("Bogus FREE_SCBH %d\n", free_scbh);\r\nbogus = TRUE;\r\n}\r\nelse\r\n{\r\ntemp = free_scbh;\r\nwhile( (temp != SCB_LIST_NULL) && (temp < p->scb_data->maxhscbs) )\r\n{\r\nif(scb_status[temp] & 0x07)\r\n{\r\nprintk("HSCB %d on multiple lists, status 0x%02x", temp,\r\nscb_status[temp] | SCB_FREE_LIST);\r\nbogus = TRUE;\r\n}\r\nscb_status[temp] |= SCB_FREE_LIST;\r\naic_outb(p, temp, SCBPTR);\r\ntemp = aic_inb(p, SCB_NEXT);\r\n}\r\n}\r\ndis_scbh = aic_inb(p, DISCONNECTED_SCBH);\r\nif ( (dis_scbh != SCB_LIST_NULL) &&\r\n(dis_scbh >= p->scb_data->maxhscbs) )\r\n{\r\nprintk("Bogus DISCONNECTED_SCBH %d\n", dis_scbh);\r\nbogus = TRUE;\r\n}\r\nelse\r\n{\r\ntemp = dis_scbh;\r\nwhile( (temp != SCB_LIST_NULL) && (temp < p->scb_data->maxhscbs) )\r\n{\r\nif(scb_status[temp] & 0x07)\r\n{\r\nprintk("HSCB %d on multiple lists, status 0x%02x", temp,\r\nscb_status[temp] | SCB_DISCONNECTED_LIST);\r\nbogus = TRUE;\r\n}\r\nscb_status[temp] |= SCB_DISCONNECTED_LIST;\r\naic_outb(p, temp, SCBPTR);\r\ntemp = aic_inb(p, SCB_NEXT);\r\n}\r\n}\r\nwait_scbh = aic_inb(p, WAITING_SCBH);\r\nif ( (wait_scbh != SCB_LIST_NULL) &&\r\n(wait_scbh >= p->scb_data->maxhscbs) )\r\n{\r\nprintk("Bogus WAITING_SCBH %d\n", wait_scbh);\r\nbogus = TRUE;\r\n}\r\nelse\r\n{\r\ntemp = wait_scbh;\r\nwhile( (temp != SCB_LIST_NULL) && (temp < p->scb_data->maxhscbs) )\r\n{\r\nif(scb_status[temp] & 0x07)\r\n{\r\nprintk("HSCB %d on multiple lists, status 0x%02x", temp,\r\nscb_status[temp] | SCB_WAITING_LIST);\r\nbogus = TRUE;\r\n}\r\nscb_status[temp] |= SCB_WAITING_LIST;\r\naic_outb(p, temp, SCBPTR);\r\ntemp = aic_inb(p, SCB_NEXT);\r\n}\r\n}\r\nlost=0;\r\nfor(i=0; i < p->scb_data->maxhscbs; i++)\r\n{\r\naic_outb(p, i, SCBPTR);\r\ntemp = aic_inb(p, SCB_NEXT);\r\nif ( ((temp != SCB_LIST_NULL) &&\r\n(temp >= p->scb_data->maxhscbs)) )\r\n{\r\nprintk("HSCB %d bad, SCB_NEXT invalid(%d).\n", i, temp);\r\nbogus = TRUE;\r\n}\r\nif ( temp == i )\r\n{\r\nprintk("HSCB %d bad, SCB_NEXT points to self.\n", i);\r\nbogus = TRUE;\r\n}\r\nif (scb_status[i] == 0)\r\nlost++;\r\nif (lost > 1)\r\n{\r\nprintk("Too many lost scbs.\n");\r\nbogus=TRUE;\r\n}\r\n}\r\naic_outb(p, saved_scbptr, SCBPTR);\r\nunpause_sequencer(p, FALSE);\r\nif (bogus)\r\n{\r\nprintk("Bogus parameters found in card SCB array structures.\n");\r\nprintk("%s\n", buffer);\r\naic7xxx_panic_abort(p, NULL);\r\n}\r\nreturn;\r\n}\r\nstatic void\r\naic7xxx_handle_command_completion_intr(struct aic7xxx_host *p)\r\n{\r\nstruct aic7xxx_scb *scb = NULL;\r\nstruct aic_dev_data *aic_dev;\r\nstruct scsi_cmnd *cmd;\r\nunsigned char scb_index, tindex;\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif( (p->isr_count < 16) && (aic7xxx_verbose > 0xffff) )\r\nprintk(INFO_LEAD "Command Complete Int.\n", p->host_no, -1, -1, -1);\r\n#endif\r\naic_outb(p, CLRCMDINT, CLRINT);\r\naic_inb(p, INTSTAT);\r\nwhile (p->qoutfifo[p->qoutfifonext] != SCB_LIST_NULL)\r\n{\r\nscb_index = p->qoutfifo[p->qoutfifonext];\r\np->qoutfifo[p->qoutfifonext++] = SCB_LIST_NULL;\r\nif ( scb_index >= p->scb_data->numscbs )\r\n{\r\nprintk(WARN_LEAD "CMDCMPLT with invalid SCB index %d\n", p->host_no,\r\n-1, -1, -1, scb_index);\r\ncontinue;\r\n}\r\nscb = p->scb_data->scb_array[scb_index];\r\nif (!(scb->flags & SCB_ACTIVE) || (scb->cmd == NULL))\r\n{\r\nprintk(WARN_LEAD "CMDCMPLT without command for SCB %d, SCB flags "\r\n"0x%x, cmd 0x%lx\n", p->host_no, -1, -1, -1, scb_index, scb->flags,\r\n(unsigned long) scb->cmd);\r\ncontinue;\r\n}\r\ntindex = TARGET_INDEX(scb->cmd);\r\naic_dev = AIC_DEV(scb->cmd);\r\nif (scb->flags & SCB_QUEUED_ABORT)\r\n{\r\npause_sequencer(p);\r\nif ( ((aic_inb(p, LASTPHASE) & PHASE_MASK) != P_BUSFREE) &&\r\n(aic_inb(p, SCB_TAG) == scb->hscb->tag) )\r\n{\r\nunpause_sequencer(p, FALSE);\r\ncontinue;\r\n}\r\naic7xxx_reset_device(p, scb->cmd->device->id, scb->cmd->device->channel,\r\nscb->cmd->device->lun, scb->hscb->tag);\r\nscb->flags &= ~(SCB_QUEUED_FOR_DONE | SCB_RESET | SCB_ABORT |\r\nSCB_QUEUED_ABORT);\r\nunpause_sequencer(p, FALSE);\r\n}\r\nelse if (scb->flags & SCB_ABORT)\r\n{\r\nscb->flags &= ~(SCB_ABORT|SCB_RESET);\r\n}\r\nelse if (scb->flags & SCB_SENSE)\r\n{\r\nchar *buffer = &scb->cmd->sense_buffer[0];\r\nif (buffer[12] == 0x47 || buffer[12] == 0x54)\r\n{\r\naic_dev->needppr = aic_dev->needppr_copy;\r\naic_dev->needsdtr = aic_dev->needsdtr_copy;\r\naic_dev->needwdtr = aic_dev->needwdtr_copy;\r\n}\r\n}\r\ncmd = scb->cmd;\r\nif (scb->hscb->residual_SG_segment_count != 0)\r\n{\r\naic7xxx_calculate_residual(p, scb);\r\n}\r\ncmd->result |= (aic7xxx_error(cmd) << 16);\r\naic7xxx_done(p, scb);\r\n}\r\n}\r\nstatic void\r\naic7xxx_isr(void *dev_id)\r\n{\r\nstruct aic7xxx_host *p;\r\nunsigned char intstat;\r\np = dev_id;\r\nif (!((intstat = aic_inb(p, INTSTAT)) & INT_PEND))\r\n{\r\n#ifdef CONFIG_PCI\r\nif ( (p->chip & AHC_PCI) && (p->spurious_int > 500) &&\r\n!(p->flags & AHC_HANDLING_REQINITS) )\r\n{\r\nif ( aic_inb(p, ERROR) & PCIERRSTAT )\r\n{\r\naic7xxx_pci_intr(p);\r\n}\r\np->spurious_int = 0;\r\n}\r\nelse if ( !(p->flags & AHC_HANDLING_REQINITS) )\r\n{\r\np->spurious_int++;\r\n}\r\n#endif\r\nreturn;\r\n}\r\np->spurious_int = 0;\r\np->isr_count++;\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif ( (p->isr_count < 16) && (aic7xxx_verbose > 0xffff) &&\r\n(aic7xxx_panic_on_abort) && (p->flags & AHC_PAGESCBS) )\r\naic7xxx_check_scbs(p, "Bogus settings at start of interrupt.");\r\n#endif\r\nif (intstat & CMDCMPLT)\r\n{\r\naic7xxx_handle_command_completion_intr(p);\r\n}\r\nif (intstat & BRKADRINT)\r\n{\r\nint i;\r\nunsigned char errno = aic_inb(p, ERROR);\r\nprintk(KERN_ERR "(scsi%d) BRKADRINT error(0x%x):\n", p->host_no, errno);\r\nfor (i = 0; i < ARRAY_SIZE(hard_error); i++)\r\n{\r\nif (errno & hard_error[i].errno)\r\n{\r\nprintk(KERN_ERR " %s\n", hard_error[i].errmesg);\r\n}\r\n}\r\nprintk(KERN_ERR "(scsi%d) SEQADDR=0x%x\n", p->host_no,\r\n(((aic_inb(p, SEQADDR1) << 8) & 0x100) | aic_inb(p, SEQADDR0)));\r\nif (aic7xxx_panic_on_abort)\r\naic7xxx_panic_abort(p, NULL);\r\n#ifdef CONFIG_PCI\r\nif (errno & PCIERRSTAT)\r\naic7xxx_pci_intr(p);\r\n#endif\r\nif (errno & (SQPARERR | ILLOPCODE | ILLSADDR))\r\n{\r\npanic("aic7xxx: unrecoverable BRKADRINT.\n");\r\n}\r\nif (errno & ILLHADDR)\r\n{\r\nprintk(KERN_ERR "(scsi%d) BUG! Driver accessed chip without first "\r\n"pausing controller!\n", p->host_no);\r\n}\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (errno & DPARERR)\r\n{\r\nif (aic_inb(p, DMAPARAMS) & DIRECTION)\r\nprintk("(scsi%d) while DMAing SCB from host to card.\n", p->host_no);\r\nelse\r\nprintk("(scsi%d) while DMAing SCB from card to host.\n", p->host_no);\r\n}\r\n#endif\r\naic_outb(p, CLRPARERR | CLRBRKADRINT, CLRINT);\r\nunpause_sequencer(p, FALSE);\r\n}\r\nif (intstat & SEQINT)\r\n{\r\nif(p->features & AHC_ULTRA2)\r\n{\r\naic_inb(p, CCSCBCTL);\r\n}\r\naic7xxx_handle_seqint(p, intstat);\r\n}\r\nif (intstat & SCSIINT)\r\n{\r\naic7xxx_handle_scsiint(p, intstat);\r\n}\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif ( (p->isr_count < 16) && (aic7xxx_verbose > 0xffff) &&\r\n(aic7xxx_panic_on_abort) && (p->flags & AHC_PAGESCBS) )\r\naic7xxx_check_scbs(p, "Bogus settings at end of interrupt.");\r\n#endif\r\n}\r\nstatic irqreturn_t\r\ndo_aic7xxx_isr(int irq, void *dev_id)\r\n{\r\nunsigned long cpu_flags;\r\nstruct aic7xxx_host *p;\r\np = dev_id;\r\nif(!p)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(p->host->host_lock, cpu_flags);\r\np->flags |= AHC_IN_ISR;\r\ndo\r\n{\r\naic7xxx_isr(dev_id);\r\n} while ( (aic_inb(p, INTSTAT) & INT_PEND) );\r\naic7xxx_done_cmds_complete(p);\r\naic7xxx_run_waiting_queues(p);\r\np->flags &= ~AHC_IN_ISR;\r\nspin_unlock_irqrestore(p->host->host_lock, cpu_flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\naic7xxx_init_transinfo(struct aic7xxx_host *p, struct aic_dev_data *aic_dev)\r\n{\r\nstruct scsi_device *sdpnt = aic_dev->SDptr;\r\nunsigned char tindex;\r\ntindex = sdpnt->id | (sdpnt->channel << 3);\r\nif (!(aic_dev->flags & DEVICE_DTR_SCANNED))\r\n{\r\naic_dev->flags |= DEVICE_DTR_SCANNED;\r\nif ( sdpnt->wdtr && (p->features & AHC_WIDE) )\r\n{\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 1;\r\naic_dev->goal.width = p->user[tindex].width;\r\n}\r\nelse\r\n{\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 0;\r\npause_sequencer(p);\r\naic7xxx_set_width(p, sdpnt->id, sdpnt->channel, sdpnt->lun,\r\nMSG_EXT_WDTR_BUS_8_BIT, (AHC_TRANS_ACTIVE |\r\nAHC_TRANS_GOAL |\r\nAHC_TRANS_CUR), aic_dev );\r\nunpause_sequencer(p, FALSE);\r\n}\r\nif ( sdpnt->sdtr && p->user[tindex].offset )\r\n{\r\naic_dev->goal.period = p->user[tindex].period;\r\naic_dev->goal.options = p->user[tindex].options;\r\nif (p->features & AHC_ULTRA2)\r\naic_dev->goal.offset = MAX_OFFSET_ULTRA2;\r\nelse if (aic_dev->goal.width == MSG_EXT_WDTR_BUS_16_BIT)\r\naic_dev->goal.offset = MAX_OFFSET_16BIT;\r\nelse\r\naic_dev->goal.offset = MAX_OFFSET_8BIT;\r\nif ( sdpnt->ppr && p->user[tindex].period <= 9 &&\r\np->user[tindex].options )\r\n{\r\naic_dev->needppr = aic_dev->needppr_copy = 1;\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 0;\r\naic_dev->needwdtr = aic_dev->needwdtr_copy = 0;\r\naic_dev->flags |= DEVICE_SCSI_3;\r\n}\r\nelse\r\n{\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 1;\r\naic_dev->goal.period = max_t(unsigned char, 10, aic_dev->goal.period);\r\naic_dev->goal.options = 0;\r\n}\r\n}\r\nelse\r\n{\r\naic_dev->needsdtr = aic_dev->needsdtr_copy = 0;\r\naic_dev->goal.period = 255;\r\naic_dev->goal.offset = 0;\r\naic_dev->goal.options = 0;\r\n}\r\naic_dev->flags |= DEVICE_PRINT_DTR;\r\n}\r\n}\r\nstatic int\r\naic7xxx_slave_alloc(struct scsi_device *SDptr)\r\n{\r\nstruct aic7xxx_host *p = (struct aic7xxx_host *)SDptr->host->hostdata;\r\nstruct aic_dev_data *aic_dev;\r\naic_dev = kmalloc(sizeof(struct aic_dev_data), GFP_KERNEL);\r\nif(!aic_dev)\r\nreturn 1;\r\nif (!(p->flags & AHC_A_SCANNED) && (SDptr->channel == 0))\r\n{\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(INFO_LEAD "Scanning channel for devices.\n",\r\np->host_no, 0, -1, -1);\r\np->flags |= AHC_A_SCANNED;\r\n}\r\nelse\r\n{\r\nif (!(p->flags & AHC_B_SCANNED) && (SDptr->channel == 1))\r\n{\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(INFO_LEAD "Scanning channel for devices.\n",\r\np->host_no, 1, -1, -1);\r\np->flags |= AHC_B_SCANNED;\r\n}\r\n}\r\nmemset(aic_dev, 0, sizeof(struct aic_dev_data));\r\nSDptr->hostdata = aic_dev;\r\naic_dev->SDptr = SDptr;\r\naic_dev->max_q_depth = 1;\r\naic_dev->temp_q_depth = 1;\r\nscbq_init(&aic_dev->delayed_scbs);\r\nINIT_LIST_HEAD(&aic_dev->list);\r\nlist_add_tail(&aic_dev->list, &p->aic_devs);\r\nreturn 0;\r\n}\r\nstatic void\r\naic7xxx_device_queue_depth(struct aic7xxx_host *p, struct scsi_device *device)\r\n{\r\nint tag_enabled = FALSE;\r\nstruct aic_dev_data *aic_dev = device->hostdata;\r\nunsigned char tindex;\r\ntindex = device->id | (device->channel << 3);\r\nif (device->simple_tags)\r\nreturn;\r\nif (device->tagged_supported)\r\n{\r\ntag_enabled = TRUE;\r\nif (!(p->discenable & (1 << tindex)))\r\n{\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\nprintk(INFO_LEAD "Disconnection disabled, unable to "\r\n"enable tagged queueing.\n",\r\np->host_no, device->channel, device->id, device->lun);\r\ntag_enabled = FALSE;\r\n}\r\nelse\r\n{\r\nif (p->instance >= ARRAY_SIZE(aic7xxx_tag_info))\r\n{\r\nstatic int print_warning = TRUE;\r\nif(print_warning)\r\n{\r\nprintk(KERN_INFO "aic7xxx: WARNING, insufficient tag_info instances for"\r\n" installed controllers.\n");\r\nprintk(KERN_INFO "aic7xxx: Please update the aic7xxx_tag_info array in"\r\n" the aic7xxx.c source file.\n");\r\nprint_warning = FALSE;\r\n}\r\naic_dev->max_q_depth = aic_dev->temp_q_depth =\r\naic7xxx_default_queue_depth;\r\n}\r\nelse\r\n{\r\nif (aic7xxx_tag_info[p->instance].tag_commands[tindex] == 255)\r\n{\r\ntag_enabled = FALSE;\r\n}\r\nelse if (aic7xxx_tag_info[p->instance].tag_commands[tindex] == 0)\r\n{\r\naic_dev->max_q_depth = aic_dev->temp_q_depth =\r\naic7xxx_default_queue_depth;\r\n}\r\nelse\r\n{\r\naic_dev->max_q_depth = aic_dev->temp_q_depth =\r\naic7xxx_tag_info[p->instance].tag_commands[tindex];\r\n}\r\n}\r\n}\r\n}\r\nif (tag_enabled)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Tagged queuing enabled, queue depth %d.\n",\r\np->host_no, device->channel, device->id,\r\ndevice->lun, aic_dev->max_q_depth);\r\n}\r\nscsi_adjust_queue_depth(device, MSG_ORDERED_TAG, aic_dev->max_q_depth);\r\n}\r\nelse\r\n{\r\nif (aic7xxx_verbose & VERBOSE_NEGOTIATION2)\r\n{\r\nprintk(INFO_LEAD "Tagged queuing disabled, queue depth %d.\n",\r\np->host_no, device->channel, device->id,\r\ndevice->lun, device->host->cmd_per_lun);\r\n}\r\nscsi_adjust_queue_depth(device, 0, device->host->cmd_per_lun);\r\n}\r\nreturn;\r\n}\r\nstatic void\r\naic7xxx_slave_destroy(struct scsi_device *SDptr)\r\n{\r\nstruct aic_dev_data *aic_dev = SDptr->hostdata;\r\nlist_del(&aic_dev->list);\r\nSDptr->hostdata = NULL;\r\nkfree(aic_dev);\r\nreturn;\r\n}\r\nstatic int\r\naic7xxx_slave_configure(struct scsi_device *SDptr)\r\n{\r\nstruct aic7xxx_host *p = (struct aic7xxx_host *) SDptr->host->hostdata;\r\nstruct aic_dev_data *aic_dev;\r\nint scbnum;\r\naic_dev = (struct aic_dev_data *)SDptr->hostdata;\r\naic7xxx_init_transinfo(p, aic_dev);\r\naic7xxx_device_queue_depth(p, SDptr);\r\nif(list_empty(&aic_dev->list))\r\nlist_add_tail(&aic_dev->list, &p->aic_devs);\r\nscbnum = 0;\r\nlist_for_each_entry(aic_dev, &p->aic_devs, list) {\r\nscbnum += aic_dev->max_q_depth;\r\n}\r\nwhile (scbnum > p->scb_data->numscbs)\r\n{\r\nif ( aic7xxx_allocate_scb(p) == 0 )\r\nbreak;\r\n}\r\nreturn(0);\r\n}\r\nstatic int\r\naic7xxx_probe(int slot, int base, ahc_flag_type *flags)\r\n{\r\nint i;\r\nunsigned char buf[4];\r\nstatic struct {\r\nint n;\r\nunsigned char signature[sizeof(buf)];\r\nahc_chip type;\r\nint bios_disabled;\r\n} AIC7xxx[] = {\r\n{ 4, { 0x04, 0x90, 0x77, 0x70 },\r\nAHC_AIC7770|AHC_EISA, FALSE },\r\n{ 4, { 0x04, 0x90, 0x77, 0x71 },\r\nAHC_AIC7770|AHC_EISA, FALSE },\r\n{ 4, { 0x04, 0x90, 0x77, 0x56 },\r\nAHC_AIC7770|AHC_VL, FALSE },\r\n{ 4, { 0x04, 0x90, 0x77, 0x57 },\r\nAHC_AIC7770|AHC_VL, TRUE }\r\n};\r\nfor (i = 0; i < sizeof(buf); i++)\r\n{\r\noutb(0x80 + i, base);\r\nbuf[i] = inb(base + i);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(AIC7xxx); i++)\r\n{\r\nif (!memcmp(buf, AIC7xxx[i].signature, AIC7xxx[i].n))\r\n{\r\nif (inb(base + 4) & 1)\r\n{\r\nif (AIC7xxx[i].bios_disabled)\r\n{\r\n*flags |= AHC_USEDEFAULTS;\r\n}\r\nelse\r\n{\r\n*flags |= AHC_BIOS_ENABLED;\r\n}\r\nreturn (i);\r\n}\r\nprintk("aic7xxx: <Adaptec 7770 SCSI Host Adapter> "\r\n"disabled at slot %d, ignored.\n", slot);\r\n}\r\n}\r\nreturn (-1);\r\n}\r\nstatic int\r\nread_284x_seeprom(struct aic7xxx_host *p, struct seeprom_config *sc)\r\n{\r\nint i = 0, k = 0;\r\nunsigned char temp;\r\nunsigned short checksum = 0;\r\nunsigned short *seeprom = (unsigned short *) sc;\r\nstruct seeprom_cmd {\r\nunsigned char len;\r\nunsigned char bits[3];\r\n};\r\nstruct seeprom_cmd seeprom_read = {3, {1, 1, 0}};\r\n#define CLOCK_PULSE(p) \\r\nwhile ((aic_inb(p, STATUS_2840) & EEPROM_TF) == 0) \\r\n{ \\r\n; \\r\n} \\r\n(void) aic_inb(p, SEECTL_2840);\r\nfor (k = 0; k < (sizeof(*sc) / 2); k++)\r\n{\r\naic_outb(p, CK_2840 | CS_2840, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\nfor (i = 0; i < seeprom_read.len; i++)\r\n{\r\ntemp = CS_2840 | seeprom_read.bits[i];\r\naic_outb(p, temp, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\ntemp = temp ^ CK_2840;\r\naic_outb(p, temp, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\n}\r\nfor (i = 5; i >= 0; i--)\r\n{\r\ntemp = k;\r\ntemp = (temp >> i) & 1;\r\ntemp = CS_2840 | temp;\r\naic_outb(p, temp, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\ntemp = temp ^ CK_2840;\r\naic_outb(p, temp, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\n}\r\nfor (i = 0; i <= 16; i++)\r\n{\r\ntemp = CS_2840;\r\naic_outb(p, temp, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\ntemp = temp ^ CK_2840;\r\nseeprom[k] = (seeprom[k] << 1) | (aic_inb(p, STATUS_2840) & DI_2840);\r\naic_outb(p, temp, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\n}\r\nif (k < (sizeof(*sc) / 2) - 1)\r\n{\r\nchecksum = checksum + seeprom[k];\r\n}\r\naic_outb(p, 0, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\naic_outb(p, CK_2840, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\naic_outb(p, 0, SEECTL_2840);\r\nCLOCK_PULSE(p);\r\n}\r\n#if 0\r\nprintk("Computed checksum 0x%x, checksum read 0x%x\n", checksum, sc->checksum);\r\nprintk("Serial EEPROM:");\r\nfor (k = 0; k < (sizeof(*sc) / 2); k++)\r\n{\r\nif (((k % 8) == 0) && (k != 0))\r\n{\r\nprintk("\n ");\r\n}\r\nprintk(" 0x%x", seeprom[k]);\r\n}\r\nprintk("\n");\r\n#endif\r\nif (checksum != sc->checksum)\r\n{\r\nprintk("aic7xxx: SEEPROM checksum error, ignoring SEEPROM settings.\n");\r\nreturn (0);\r\n}\r\nreturn (1);\r\n#undef CLOCK_PULSE\r\n}\r\nstatic int\r\nacquire_seeprom(struct aic7xxx_host *p)\r\n{\r\naic_outb(p, SEEMS, SEECTL);\r\nCLOCK_PULSE(p);\r\nif ((aic_inb(p, SEECTL) & SEERDY) == 0)\r\n{\r\naic_outb(p, 0, SEECTL);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nrelease_seeprom(struct aic7xxx_host *p)\r\n{\r\nCLOCK_PULSE(p);\r\naic_outb(p, 0, SEECTL);\r\n}\r\nstatic int\r\nread_seeprom(struct aic7xxx_host *p, int offset,\r\nunsigned short *scarray, unsigned int len, seeprom_chip_type chip)\r\n{\r\nint i = 0, k;\r\nunsigned char temp;\r\nunsigned short checksum = 0;\r\nstruct seeprom_cmd {\r\nunsigned char len;\r\nunsigned char bits[3];\r\n};\r\nstruct seeprom_cmd seeprom_read = {3, {1, 1, 0}};\r\nif (acquire_seeprom(p) == 0)\r\n{\r\nreturn (0);\r\n}\r\nfor (k = 0; k < len; k++)\r\n{\r\naic_outb(p, SEEMS | SEECK | SEECS, SEECTL);\r\nCLOCK_PULSE(p);\r\nfor (i = 0; i < seeprom_read.len; i++)\r\n{\r\ntemp = SEEMS | SEECS | (seeprom_read.bits[i] << 1);\r\naic_outb(p, temp, SEECTL);\r\nCLOCK_PULSE(p);\r\ntemp = temp ^ SEECK;\r\naic_outb(p, temp, SEECTL);\r\nCLOCK_PULSE(p);\r\n}\r\nfor (i = ((int) chip - 1); i >= 0; i--)\r\n{\r\ntemp = k + offset;\r\ntemp = (temp >> i) & 1;\r\ntemp = SEEMS | SEECS | (temp << 1);\r\naic_outb(p, temp, SEECTL);\r\nCLOCK_PULSE(p);\r\ntemp = temp ^ SEECK;\r\naic_outb(p, temp, SEECTL);\r\nCLOCK_PULSE(p);\r\n}\r\nfor (i = 0; i <= 16; i++)\r\n{\r\ntemp = SEEMS | SEECS;\r\naic_outb(p, temp, SEECTL);\r\nCLOCK_PULSE(p);\r\ntemp = temp ^ SEECK;\r\nscarray[k] = (scarray[k] << 1) | (aic_inb(p, SEECTL) & SEEDI);\r\naic_outb(p, temp, SEECTL);\r\nCLOCK_PULSE(p);\r\n}\r\nif (k < (len - 1))\r\n{\r\nchecksum = checksum + scarray[k];\r\n}\r\naic_outb(p, SEEMS, SEECTL);\r\nCLOCK_PULSE(p);\r\naic_outb(p, SEEMS | SEECK, SEECTL);\r\nCLOCK_PULSE(p);\r\naic_outb(p, SEEMS, SEECTL);\r\nCLOCK_PULSE(p);\r\n}\r\nrelease_seeprom(p);\r\n#if 0\r\nprintk("Computed checksum 0x%x, checksum read 0x%x\n",\r\nchecksum, scarray[len - 1]);\r\nprintk("Serial EEPROM:");\r\nfor (k = 0; k < len; k++)\r\n{\r\nif (((k % 8) == 0) && (k != 0))\r\n{\r\nprintk("\n ");\r\n}\r\nprintk(" 0x%x", scarray[k]);\r\n}\r\nprintk("\n");\r\n#endif\r\nif ( (checksum != scarray[len - 1]) || (checksum == 0) )\r\n{\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic unsigned char\r\nread_brdctl(struct aic7xxx_host *p)\r\n{\r\nunsigned char brdctl, value;\r\nCLOCK_PULSE(p);\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nbrdctl = BRDRW_ULTRA2;\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\nvalue = aic_inb(p, BRDCTL);\r\nCLOCK_PULSE(p);\r\nreturn(value);\r\n}\r\nbrdctl = BRDRW;\r\nif ( !((p->chip & AHC_CHIPID_MASK) == AHC_AIC7895) ||\r\n(p->flags & AHC_CHNLB) )\r\n{\r\nbrdctl |= BRDCS;\r\n}\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\nvalue = aic_inb(p, BRDCTL);\r\nCLOCK_PULSE(p);\r\naic_outb(p, 0, BRDCTL);\r\nCLOCK_PULSE(p);\r\nreturn (value);\r\n}\r\nstatic void\r\nwrite_brdctl(struct aic7xxx_host *p, unsigned char value)\r\n{\r\nunsigned char brdctl;\r\nCLOCK_PULSE(p);\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nbrdctl = value;\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\nbrdctl |= BRDSTB_ULTRA2;\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\nbrdctl &= ~BRDSTB_ULTRA2;\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\nread_brdctl(p);\r\nCLOCK_PULSE(p);\r\n}\r\nelse\r\n{\r\nbrdctl = BRDSTB;\r\nif ( !((p->chip & AHC_CHIPID_MASK) == AHC_AIC7895) ||\r\n(p->flags & AHC_CHNLB) )\r\n{\r\nbrdctl |= BRDCS;\r\n}\r\nbrdctl = BRDSTB | BRDCS;\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\nbrdctl |= value;\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\nbrdctl &= ~BRDSTB;\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\nbrdctl &= ~BRDCS;\r\naic_outb(p, brdctl, BRDCTL);\r\nCLOCK_PULSE(p);\r\n}\r\n}\r\nstatic void\r\naic785x_cable_detect(struct aic7xxx_host *p, int *int_50,\r\nint *ext_present, int *eeprom)\r\n{\r\nunsigned char brdctl;\r\naic_outb(p, BRDRW | BRDCS, BRDCTL);\r\nCLOCK_PULSE(p);\r\naic_outb(p, 0, BRDCTL);\r\nCLOCK_PULSE(p);\r\nbrdctl = aic_inb(p, BRDCTL);\r\nCLOCK_PULSE(p);\r\n*int_50 = !(brdctl & BRDDAT5);\r\n*ext_present = !(brdctl & BRDDAT6);\r\n*eeprom = (aic_inb(p, SPIOCAP) & EEPROM);\r\n}\r\nstatic void\r\naic2940_uwpro_wide_cable_detect(struct aic7xxx_host *p, int *int_68,\r\nint *ext_68, int *eeprom)\r\n{\r\nunsigned char brdctl;\r\nwrite_brdctl(p, 0);\r\nbrdctl = read_brdctl(p);\r\n*int_68 = !(brdctl & BRDDAT7);\r\nwrite_brdctl(p, BRDDAT5);\r\nbrdctl = read_brdctl(p);\r\n*ext_68 = !(brdctl & BRDDAT6);\r\n*eeprom = !(brdctl & BRDDAT7);\r\n}\r\nstatic void\r\naic787x_cable_detect(struct aic7xxx_host *p, int *int_50, int *int_68,\r\nint *ext_present, int *eeprom)\r\n{\r\nunsigned char brdctl;\r\nwrite_brdctl(p, 0);\r\nbrdctl = read_brdctl(p);\r\n*int_50 = !(brdctl & BRDDAT6);\r\n*int_68 = !(brdctl & BRDDAT7);\r\nwrite_brdctl(p, BRDDAT5);\r\nbrdctl = read_brdctl(p);\r\n*ext_present = !(brdctl & BRDDAT6);\r\n*eeprom = !(brdctl & BRDDAT7);\r\n}\r\nstatic void\r\naic7xxx_ultra2_term_detect(struct aic7xxx_host *p, int *enableSE_low,\r\nint *enableSE_high, int *enableLVD_low,\r\nint *enableLVD_high, int *eprom_present)\r\n{\r\nunsigned char brdctl;\r\nbrdctl = read_brdctl(p);\r\n*eprom_present = (brdctl & BRDDAT7);\r\n*enableSE_high = (brdctl & BRDDAT6);\r\n*enableSE_low = (brdctl & BRDDAT5);\r\n*enableLVD_high = (brdctl & BRDDAT4);\r\n*enableLVD_low = (brdctl & BRDDAT3);\r\n}\r\nstatic void\r\nconfigure_termination(struct aic7xxx_host *p)\r\n{\r\nint internal50_present = 0;\r\nint internal68_present = 0;\r\nint external_present = 0;\r\nint eprom_present = 0;\r\nint enableSE_low = 0;\r\nint enableSE_high = 0;\r\nint enableLVD_low = 0;\r\nint enableLVD_high = 0;\r\nunsigned char brddat = 0;\r\nunsigned char max_target = 0;\r\nunsigned char sxfrctl1 = aic_inb(p, SXFRCTL1);\r\nif (acquire_seeprom(p))\r\n{\r\nif (p->features & (AHC_WIDE|AHC_TWIN))\r\nmax_target = 16;\r\nelse\r\nmax_target = 8;\r\naic_outb(p, SEEMS | SEECS, SEECTL);\r\nsxfrctl1 &= ~STPWEN;\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nif (aic7xxx_override_term == -1)\r\n{\r\naic7xxx_ultra2_term_detect(p, &enableSE_low, &enableSE_high,\r\n&enableLVD_low, &enableLVD_high,\r\n&eprom_present);\r\n}\r\nif (!(p->adapter_control & CFSEAUTOTERM))\r\n{\r\nenableSE_low = (p->adapter_control & CFSTERM);\r\nenableSE_high = (p->adapter_control & CFWSTERM);\r\n}\r\nif (!(p->adapter_control & CFAUTOTERM))\r\n{\r\nenableLVD_low = enableLVD_high = (p->adapter_control & CFLVDSTERM);\r\n}\r\nif (enableLVD_low != 0)\r\n{\r\nsxfrctl1 |= STPWEN;\r\np->flags |= AHC_TERM_ENB_LVD;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) LVD/Primary Low byte termination "\r\n"Enabled\n", p->host_no);\r\n}\r\nif (enableLVD_high != 0)\r\n{\r\nbrddat |= BRDDAT4;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) LVD/Primary High byte termination "\r\n"Enabled\n", p->host_no);\r\n}\r\nif (enableSE_low != 0)\r\n{\r\nbrddat |= BRDDAT5;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) Secondary Low byte termination "\r\n"Enabled\n", p->host_no);\r\n}\r\nif (enableSE_high != 0)\r\n{\r\nbrddat |= BRDDAT6;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) Secondary High byte termination "\r\n"Enabled\n", p->host_no);\r\n}\r\n}\r\nelse if (p->features & AHC_NEW_AUTOTERM)\r\n{\r\nsxfrctl1 |= STPWEN;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) Narrow channel termination Enabled\n",\r\np->host_no);\r\nif (p->adapter_control & CFAUTOTERM)\r\n{\r\naic2940_uwpro_wide_cable_detect(p, &internal68_present,\r\n&external_present,\r\n&eprom_present);\r\nprintk(KERN_INFO "(scsi%d) Cables present (Int-50 %s, Int-68 %s, "\r\n"Ext-68 %s)\n", p->host_no,\r\n"Don't Care",\r\ninternal68_present ? "YES" : "NO",\r\nexternal_present ? "YES" : "NO");\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) EEPROM %s present.\n", p->host_no,\r\neprom_present ? "is" : "is not");\r\nif (internal68_present && external_present)\r\n{\r\nbrddat = 0;\r\np->flags &= ~AHC_TERM_ENB_SE_HIGH;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) Wide channel termination Disabled\n",\r\np->host_no);\r\n}\r\nelse\r\n{\r\nbrddat = BRDDAT6;\r\np->flags |= AHC_TERM_ENB_SE_HIGH;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) Wide channel termination Enabled\n",\r\np->host_no);\r\n}\r\n}\r\nelse\r\n{\r\nif (p->adapter_control & CFWSTERM)\r\n{\r\nbrddat = BRDDAT6;\r\np->flags |= AHC_TERM_ENB_SE_HIGH;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) Wide channel termination Enabled\n",\r\np->host_no);\r\n}\r\nelse\r\n{\r\nbrddat = 0;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif (p->adapter_control & CFAUTOTERM)\r\n{\r\nif (p->flags & AHC_MOTHERBOARD)\r\n{\r\nprintk(KERN_INFO "(scsi%d) Warning - detected auto-termination\n",\r\np->host_no);\r\nprintk(KERN_INFO "(scsi%d) Please verify driver detected settings "\r\n"are correct.\n", p->host_no);\r\nprintk(KERN_INFO "(scsi%d) If not, then please properly set the "\r\n"device termination\n", p->host_no);\r\nprintk(KERN_INFO "(scsi%d) in the Adaptec SCSI BIOS by hitting "\r\n"CTRL-A when prompted\n", p->host_no);\r\nprintk(KERN_INFO "(scsi%d) during machine bootup.\n", p->host_no);\r\n}\r\nif ( (p->chip & AHC_CHIPID_MASK) >= AHC_AIC7870 )\r\n{\r\naic787x_cable_detect(p, &internal50_present, &internal68_present,\r\n&external_present, &eprom_present);\r\n}\r\nelse\r\n{\r\naic785x_cable_detect(p, &internal50_present, &external_present,\r\n&eprom_present);\r\n}\r\nif (max_target <= 8)\r\ninternal68_present = 0;\r\nif (max_target > 8)\r\n{\r\nprintk(KERN_INFO "(scsi%d) Cables present (Int-50 %s, Int-68 %s, "\r\n"Ext-68 %s)\n", p->host_no,\r\ninternal50_present ? "YES" : "NO",\r\ninternal68_present ? "YES" : "NO",\r\nexternal_present ? "YES" : "NO");\r\n}\r\nelse\r\n{\r\nprintk(KERN_INFO "(scsi%d) Cables present (Int-50 %s, Ext-50 %s)\n",\r\np->host_no,\r\ninternal50_present ? "YES" : "NO",\r\nexternal_present ? "YES" : "NO");\r\n}\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) EEPROM %s present.\n", p->host_no,\r\neprom_present ? "is" : "is not");\r\nif (internal50_present && internal68_present && external_present)\r\n{\r\nprintk(KERN_INFO "(scsi%d) Illegal cable configuration!! Only two\n",\r\np->host_no);\r\nprintk(KERN_INFO "(scsi%d) connectors on the SCSI controller may be "\r\n"in use at a time!\n", p->host_no);\r\ninternal50_present = external_present = 0;\r\nenableSE_high = enableSE_low = 1;\r\n}\r\nif ((max_target > 8) &&\r\n((external_present == 0) || (internal68_present == 0)) )\r\n{\r\nbrddat |= BRDDAT6;\r\np->flags |= AHC_TERM_ENB_SE_HIGH;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) SE High byte termination Enabled\n",\r\np->host_no);\r\n}\r\nif ( ((internal50_present ? 1 : 0) +\r\n(internal68_present ? 1 : 0) +\r\n(external_present ? 1 : 0)) <= 1 )\r\n{\r\nsxfrctl1 |= STPWEN;\r\np->flags |= AHC_TERM_ENB_SE_LOW;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) SE Low byte termination Enabled\n",\r\np->host_no);\r\n}\r\n}\r\nelse\r\n{\r\nif (p->adapter_control & CFSTERM)\r\n{\r\nsxfrctl1 |= STPWEN;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) SE Low byte termination Enabled\n",\r\np->host_no);\r\n}\r\nif (p->adapter_control & CFWSTERM)\r\n{\r\nbrddat |= BRDDAT6;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) SE High byte termination Enabled\n",\r\np->host_no);\r\n}\r\n}\r\n}\r\naic_outb(p, sxfrctl1, SXFRCTL1);\r\nwrite_brdctl(p, brddat);\r\nrelease_seeprom(p);\r\n}\r\n}\r\nstatic void\r\ndetect_maxscb(struct aic7xxx_host *p)\r\n{\r\nint i;\r\nif (p->scb_data->maxhscbs == 0)\r\n{\r\naic_outb(p, 0, FREE_SCBH);\r\nfor (i = 0; i < AIC7XXX_MAXSCB; i++)\r\n{\r\naic_outb(p, i, SCBPTR);\r\naic_outb(p, i, SCB_CONTROL);\r\nif (aic_inb(p, SCB_CONTROL) != i)\r\nbreak;\r\naic_outb(p, 0, SCBPTR);\r\nif (aic_inb(p, SCB_CONTROL) != 0)\r\nbreak;\r\naic_outb(p, i, SCBPTR);\r\naic_outb(p, 0, SCB_CONTROL);\r\naic_outb(p, i + 1, SCB_NEXT);\r\naic_outb(p, SCB_LIST_NULL, SCB_TAG);\r\naic_outb(p, SCB_LIST_NULL, SCB_BUSYTARGETS);\r\naic_outb(p, SCB_LIST_NULL, SCB_BUSYTARGETS+1);\r\naic_outb(p, SCB_LIST_NULL, SCB_BUSYTARGETS+2);\r\naic_outb(p, SCB_LIST_NULL, SCB_BUSYTARGETS+3);\r\n}\r\naic_outb(p, i - 1, SCBPTR);\r\naic_outb(p, SCB_LIST_NULL, SCB_NEXT);\r\naic_outb(p, 0, SCBPTR);\r\naic_outb(p, 0, SCB_CONTROL);\r\np->scb_data->maxhscbs = i;\r\nif ( i == AIC7XXX_MAXSCB )\r\np->flags &= ~AHC_PAGESCBS;\r\n}\r\n}\r\nstatic int\r\naic7xxx_register(struct scsi_host_template *template, struct aic7xxx_host *p,\r\nint reset_delay)\r\n{\r\nint i, result;\r\nint max_targets;\r\nint found = 1;\r\nunsigned char term, scsi_conf;\r\nstruct Scsi_Host *host;\r\nhost = p->host;\r\np->scb_data->maxscbs = AIC7XXX_MAXSCB;\r\nhost->can_queue = AIC7XXX_MAXSCB;\r\nhost->cmd_per_lun = 3;\r\nhost->sg_tablesize = AIC7XXX_MAX_SG;\r\nhost->this_id = p->scsi_id;\r\nhost->io_port = p->base;\r\nhost->n_io_port = 0xFF;\r\nhost->base = p->mbase;\r\nhost->irq = p->irq;\r\nif (p->features & AHC_WIDE)\r\n{\r\nhost->max_id = 16;\r\n}\r\nif (p->features & AHC_TWIN)\r\n{\r\nhost->max_channel = 1;\r\n}\r\np->host = host;\r\np->host_no = host->host_no;\r\nhost->unique_id = p->instance;\r\np->isr_count = 0;\r\np->next = NULL;\r\np->completeq.head = NULL;\r\np->completeq.tail = NULL;\r\nscbq_init(&p->scb_data->free_scbs);\r\nscbq_init(&p->waiting_scbs);\r\nINIT_LIST_HEAD(&p->aic_devs);\r\np->qinfifonext = 0;\r\np->qoutfifonext = 0;\r\nprintk(KERN_INFO "(scsi%d) <%s> found at ", p->host_no,\r\nboard_names[p->board_name_index]);\r\nswitch(p->chip)\r\n{\r\ncase (AHC_AIC7770|AHC_EISA):\r\nprintk("EISA slot %d\n", p->pci_device_fn);\r\nbreak;\r\ncase (AHC_AIC7770|AHC_VL):\r\nprintk("VLB slot %d\n", p->pci_device_fn);\r\nbreak;\r\ndefault:\r\nprintk("PCI %d/%d/%d\n", p->pci_bus, PCI_SLOT(p->pci_device_fn),\r\nPCI_FUNC(p->pci_device_fn));\r\nbreak;\r\n}\r\nif (p->features & AHC_TWIN)\r\n{\r\nprintk(KERN_INFO "(scsi%d) Twin Channel, A SCSI ID %d, B SCSI ID %d, ",\r\np->host_no, p->scsi_id, p->scsi_id_b);\r\n}\r\nelse\r\n{\r\nchar *channel;\r\nchannel = "";\r\nif ((p->flags & AHC_MULTI_CHANNEL) != 0)\r\n{\r\nchannel = " A";\r\nif ( (p->flags & (AHC_CHNLB|AHC_CHNLC)) != 0 )\r\n{\r\nchannel = (p->flags & AHC_CHNLB) ? " B" : " C";\r\n}\r\n}\r\nif (p->features & AHC_WIDE)\r\n{\r\nprintk(KERN_INFO "(scsi%d) Wide ", p->host_no);\r\n}\r\nelse\r\n{\r\nprintk(KERN_INFO "(scsi%d) Narrow ", p->host_no);\r\n}\r\nprintk("Channel%s, SCSI ID=%d, ", channel, p->scsi_id);\r\n}\r\naic_outb(p, 0, SEQ_FLAGS);\r\ndetect_maxscb(p);\r\nprintk("%d/%d SCBs\n", p->scb_data->maxhscbs, p->scb_data->maxscbs);\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk(KERN_INFO "(scsi%d) BIOS %sabled, IO Port 0x%lx, IRQ %d\n",\r\np->host_no, (p->flags & AHC_BIOS_ENABLED) ? "en" : "dis",\r\np->base, p->irq);\r\nprintk(KERN_INFO "(scsi%d) IO Memory at 0x%lx, MMAP Memory at %p\n",\r\np->host_no, p->mbase, p->maddr);\r\n}\r\n#ifdef CONFIG_PCI\r\nif (aic7xxx_stpwlev != -1)\r\n{\r\nif ( (p->chip & ~AHC_CHIPID_MASK) == AHC_PCI)\r\n{\r\nunsigned char devconfig;\r\npci_read_config_byte(p->pdev, DEVCONFIG, &devconfig);\r\nif ( (aic7xxx_stpwlev >> p->instance) & 0x01 )\r\n{\r\ndevconfig |= STPWLEVEL;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk("(scsi%d) Force setting STPWLEVEL bit\n", p->host_no);\r\n}\r\nelse\r\n{\r\ndevconfig &= ~STPWLEVEL;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk("(scsi%d) Force clearing STPWLEVEL bit\n", p->host_no);\r\n}\r\npci_write_config_byte(p->pdev, DEVCONFIG, devconfig);\r\n}\r\n}\r\n#endif\r\nif (aic7xxx_override_term != -1)\r\n{\r\nif ( (p->chip & ~AHC_CHIPID_MASK) == AHC_PCI)\r\n{\r\nunsigned char term_override;\r\nterm_override = ( (aic7xxx_override_term >> (p->instance * 4)) & 0x0f);\r\np->adapter_control &=\r\n~(CFSTERM|CFWSTERM|CFLVDSTERM|CFAUTOTERM|CFSEAUTOTERM);\r\nif ( (p->features & AHC_ULTRA2) && (term_override & 0x0c) )\r\n{\r\np->adapter_control |= CFLVDSTERM;\r\n}\r\nif (term_override & 0x02)\r\n{\r\np->adapter_control |= CFWSTERM;\r\n}\r\nif (term_override & 0x01)\r\n{\r\np->adapter_control |= CFSTERM;\r\n}\r\n}\r\n}\r\nif ( (p->flags & AHC_SEEPROM_FOUND) || (aic7xxx_override_term != -1) )\r\n{\r\nif (p->features & AHC_SPIOCAP)\r\n{\r\nif ( aic_inb(p, SPIOCAP) & SSPIOCPS )\r\nconfigure_termination(p);\r\n}\r\nelse if ((p->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)\r\n{\r\nconfigure_termination(p);\r\n}\r\n}\r\nif (p->features & AHC_TWIN)\r\n{\r\naic_outb(p, aic_inb(p, SBLKCTL) | SELBUSB, SBLKCTL);\r\nif ((p->flags & AHC_SEEPROM_FOUND) || (aic7xxx_override_term != -1))\r\nterm = (aic_inb(p, SXFRCTL1) & STPWEN);\r\nelse\r\nterm = ((p->flags & AHC_TERM_ENB_B) ? STPWEN : 0);\r\naic_outb(p, p->scsi_id_b, SCSIID);\r\nscsi_conf = aic_inb(p, SCSICONF + 1);\r\naic_outb(p, DFON | SPIOEN, SXFRCTL0);\r\naic_outb(p, (scsi_conf & ENSPCHK) | aic7xxx_seltime | term |\r\nENSTIMER | ACTNEGEN, SXFRCTL1);\r\naic_outb(p, 0, SIMODE0);\r\naic_outb(p, ENSELTIMO | ENSCSIRST | ENSCSIPERR, SIMODE1);\r\naic_outb(p, 0, SCSIRATE);\r\naic_outb(p, aic_inb(p, SBLKCTL) & ~SELBUSB, SBLKCTL);\r\n}\r\nif (p->features & AHC_ULTRA2)\r\n{\r\naic_outb(p, p->scsi_id, SCSIID_ULTRA2);\r\n}\r\nelse\r\n{\r\naic_outb(p, p->scsi_id, SCSIID);\r\n}\r\nif ((p->flags & AHC_SEEPROM_FOUND) || (aic7xxx_override_term != -1))\r\nterm = (aic_inb(p, SXFRCTL1) & STPWEN);\r\nelse\r\nterm = ((p->flags & (AHC_TERM_ENB_A|AHC_TERM_ENB_LVD)) ? STPWEN : 0);\r\nscsi_conf = aic_inb(p, SCSICONF);\r\naic_outb(p, DFON | SPIOEN, SXFRCTL0);\r\naic_outb(p, (scsi_conf & ENSPCHK) | aic7xxx_seltime | term |\r\nENSTIMER | ACTNEGEN, SXFRCTL1);\r\naic_outb(p, 0, SIMODE0);\r\nif(p->flags & AHC_NO_STPWEN)\r\naic_outb(p, ENSELTIMO | ENSCSIPERR, SIMODE1);\r\nelse\r\naic_outb(p, ENSELTIMO | ENSCSIRST | ENSCSIPERR, SIMODE1);\r\naic_outb(p, 0, SCSIRATE);\r\nif ( p->features & AHC_ULTRA2)\r\naic_outb(p, 0, SCSIOFFSET);\r\nif ((p->features & (AHC_TWIN|AHC_WIDE)) == 0)\r\n{\r\nmax_targets = 8;\r\n}\r\nelse\r\n{\r\nmax_targets = 16;\r\n}\r\nif (!(aic7xxx_no_reset))\r\n{\r\naic_outb(p, 0, ULTRA_ENB);\r\naic_outb(p, 0, ULTRA_ENB + 1);\r\np->ultraenb = 0;\r\n}\r\n{\r\nsize_t array_size;\r\nunsigned int hscb_physaddr;\r\narray_size = p->scb_data->maxscbs * sizeof(struct aic7xxx_hwscb);\r\nif (p->scb_data->hscbs == NULL)\r\n{\r\np->scb_data->hscbs = pci_alloc_consistent(p->pdev, array_size,\r\n&p->scb_data->hscbs_dma);\r\np->scb_data->hscb_kmalloc_ptr = NULL;\r\np->scb_data->hscbs_dma_len = array_size;\r\n}\r\nif (p->scb_data->hscbs == NULL)\r\n{\r\nprintk("(scsi%d) Unable to allocate hardware SCB array; "\r\n"failing detection.\n", p->host_no);\r\naic_outb(p, 0, SIMODE1);\r\np->irq = 0;\r\nreturn(0);\r\n}\r\nhscb_physaddr = p->scb_data->hscbs_dma;\r\naic_outb(p, hscb_physaddr & 0xFF, HSCB_ADDR);\r\naic_outb(p, (hscb_physaddr >> 8) & 0xFF, HSCB_ADDR + 1);\r\naic_outb(p, (hscb_physaddr >> 16) & 0xFF, HSCB_ADDR + 2);\r\naic_outb(p, (hscb_physaddr >> 24) & 0xFF, HSCB_ADDR + 3);\r\np->untagged_scbs = pci_alloc_consistent(p->pdev, 3*256, &p->fifo_dma);\r\nif (p->untagged_scbs == NULL)\r\n{\r\nprintk("(scsi%d) Unable to allocate hardware FIFO arrays; "\r\n"failing detection.\n", p->host_no);\r\np->irq = 0;\r\nreturn(0);\r\n}\r\np->qoutfifo = p->untagged_scbs + 256;\r\np->qinfifo = p->qoutfifo + 256;\r\nfor (i = 0; i < 256; i++)\r\n{\r\np->untagged_scbs[i] = SCB_LIST_NULL;\r\np->qinfifo[i] = SCB_LIST_NULL;\r\np->qoutfifo[i] = SCB_LIST_NULL;\r\n}\r\nhscb_physaddr = p->fifo_dma;\r\naic_outb(p, hscb_physaddr & 0xFF, SCBID_ADDR);\r\naic_outb(p, (hscb_physaddr >> 8) & 0xFF, SCBID_ADDR + 1);\r\naic_outb(p, (hscb_physaddr >> 16) & 0xFF, SCBID_ADDR + 2);\r\naic_outb(p, (hscb_physaddr >> 24) & 0xFF, SCBID_ADDR + 3);\r\n}\r\naic_outb(p, 0, QINPOS);\r\naic_outb(p, 0, KERNEL_QINPOS);\r\naic_outb(p, 0, QOUTPOS);\r\nif(p->features & AHC_QUEUE_REGS)\r\n{\r\naic_outb(p, SCB_QSIZE_256, QOFF_CTLSTA);\r\naic_outb(p, 0, SDSCB_QOFF);\r\naic_outb(p, 0, SNSCB_QOFF);\r\naic_outb(p, 0, HNSCB_QOFF);\r\n}\r\naic_outb(p, SCB_LIST_NULL, WAITING_SCBH);\r\naic_outb(p, SCB_LIST_NULL, DISCONNECTED_SCBH);\r\naic_outb(p, MSG_NOOP, MSG_OUT);\r\naic_outb(p, MSG_NOOP, LAST_MSG);\r\naic_outb(p, 0, TMODE_CMDADDR);\r\naic_outb(p, 0, TMODE_CMDADDR + 1);\r\naic_outb(p, 0, TMODE_CMDADDR + 2);\r\naic_outb(p, 0, TMODE_CMDADDR + 3);\r\naic_outb(p, 0, TMODE_CMDADDR_NEXT);\r\np->next = first_aic7xxx;\r\nfirst_aic7xxx = p;\r\naic7xxx_allocate_scb(p);\r\naic7xxx_loadseq(p);\r\naic_outb(p, aic_inb(p, SBLKCTL) & ~AUTOFLUSHDIS, SBLKCTL);\r\nif ( (p->chip & AHC_CHIPID_MASK) == AHC_AIC7770 )\r\n{\r\naic_outb(p, ENABLE, BCTL);\r\n}\r\nif ( !(aic7xxx_no_reset) )\r\n{\r\nif (p->features & AHC_TWIN)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk(KERN_INFO "(scsi%d) Resetting channel B\n", p->host_no);\r\naic_outb(p, aic_inb(p, SBLKCTL) | SELBUSB, SBLKCTL);\r\naic7xxx_reset_current_bus(p);\r\naic_outb(p, aic_inb(p, SBLKCTL) & ~SELBUSB, SBLKCTL);\r\n}\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nchar *channel = "";\r\nif (p->flags & AHC_MULTI_CHANNEL)\r\n{\r\nchannel = " A";\r\nif (p->flags & (AHC_CHNLB|AHC_CHNLC))\r\nchannel = (p->flags & AHC_CHNLB) ? " B" : " C";\r\n}\r\nprintk(KERN_INFO "(scsi%d) Resetting channel%s\n", p->host_no, channel);\r\n}\r\naic7xxx_reset_current_bus(p);\r\n}\r\nelse\r\n{\r\nif (!reset_delay)\r\n{\r\nprintk(KERN_INFO "(scsi%d) Not resetting SCSI bus. Note: Don't use "\r\n"the no_reset\n", p->host_no);\r\nprintk(KERN_INFO "(scsi%d) option unless you have a verifiable need "\r\n"for it.\n", p->host_no);\r\n}\r\n}\r\nif (!(p->chip & AHC_PCI))\r\n{\r\nresult = (request_irq(p->irq, do_aic7xxx_isr, 0, "aic7xxx", p));\r\n}\r\nelse\r\n{\r\nresult = (request_irq(p->irq, do_aic7xxx_isr, IRQF_SHARED,\r\n"aic7xxx", p));\r\nif (result < 0)\r\n{\r\nresult = (request_irq(p->irq, do_aic7xxx_isr, IRQF_DISABLED | IRQF_SHARED,\r\n"aic7xxx", p));\r\n}\r\n}\r\nif (result < 0)\r\n{\r\nprintk(KERN_WARNING "(scsi%d) Couldn't register IRQ %d, ignoring "\r\n"controller.\n", p->host_no, p->irq);\r\naic_outb(p, 0, SIMODE1);\r\np->irq = 0;\r\nreturn (0);\r\n}\r\nif(aic_inb(p, INTSTAT) & INT_PEND)\r\nprintk(INFO_LEAD "spurious interrupt during configuration, cleared.\n",\r\np->host_no, -1, -1 , -1);\r\naic7xxx_clear_intstat(p);\r\nunpause_sequencer(p, TRUE);\r\nreturn (found);\r\n}\r\nstatic int\r\naic7xxx_chip_reset(struct aic7xxx_host *p)\r\n{\r\nunsigned char sblkctl;\r\nint wait;\r\naic_outb(p, PAUSE | CHIPRST, HCNTRL);\r\nwait = 1000;\r\nwhile (--wait && !(aic_inb(p, HCNTRL) & CHIPRSTACK))\r\n{\r\nudelay(1);\r\n}\r\npause_sequencer(p);\r\nsblkctl = aic_inb(p, SBLKCTL) & (SELBUSB|SELWIDE);\r\nif (p->chip & AHC_PCI)\r\nsblkctl &= ~SELBUSB;\r\nswitch( sblkctl )\r\n{\r\ncase 0:\r\nbreak;\r\ncase 2:\r\np->features |= AHC_WIDE;\r\nbreak;\r\ncase 8:\r\np->features |= AHC_TWIN;\r\np->flags |= AHC_MULTI_CHANNEL;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "aic7xxx: Unsupported adapter type %d, ignoring.\n",\r\naic_inb(p, SBLKCTL) & 0x0a);\r\nreturn(-1);\r\n}\r\nreturn(0);\r\n}\r\nstatic struct aic7xxx_host *\r\naic7xxx_alloc(struct scsi_host_template *sht, struct aic7xxx_host *temp)\r\n{\r\nstruct aic7xxx_host *p = NULL;\r\nstruct Scsi_Host *host;\r\nhost = scsi_register(sht, sizeof(struct aic7xxx_host));\r\nif (host != NULL)\r\n{\r\np = (struct aic7xxx_host *) host->hostdata;\r\nmemset(p, 0, sizeof(struct aic7xxx_host));\r\n*p = *temp;\r\np->host = host;\r\np->scb_data = kzalloc(sizeof(scb_data_type), GFP_ATOMIC);\r\nif (p->scb_data)\r\n{\r\nscbq_init (&p->scb_data->free_scbs);\r\n}\r\nelse\r\n{\r\nrelease_region(p->base, MAXREG - MINREG);\r\nscsi_unregister(host);\r\nreturn(NULL);\r\n}\r\np->host_no = host->host_no;\r\n}\r\nreturn (p);\r\n}\r\nstatic void\r\naic7xxx_free(struct aic7xxx_host *p)\r\n{\r\nint i;\r\nif (p->scb_data != NULL)\r\n{\r\nstruct aic7xxx_scb_dma *scb_dma = NULL;\r\nif (p->scb_data->hscbs != NULL)\r\n{\r\npci_free_consistent(p->pdev, p->scb_data->hscbs_dma_len,\r\np->scb_data->hscbs, p->scb_data->hscbs_dma);\r\np->scb_data->hscbs = p->scb_data->hscb_kmalloc_ptr = NULL;\r\n}\r\nfor (i = 0; i < p->scb_data->numscbs; i++)\r\n{\r\nif (p->scb_data->scb_array[i]->scb_dma != scb_dma)\r\n{\r\nscb_dma = p->scb_data->scb_array[i]->scb_dma;\r\npci_free_consistent(p->pdev, scb_dma->dma_len,\r\n(void *)((unsigned long)scb_dma->dma_address\r\n- scb_dma->dma_offset),\r\nscb_dma->dma_address);\r\n}\r\nkfree(p->scb_data->scb_array[i]->kmalloc_ptr);\r\np->scb_data->scb_array[i] = NULL;\r\n}\r\nkfree(p->scb_data);\r\n}\r\npci_free_consistent(p->pdev, 3*256, (void *)p->untagged_scbs, p->fifo_dma);\r\n}\r\nstatic void\r\naic7xxx_load_seeprom(struct aic7xxx_host *p, unsigned char *sxfrctl1)\r\n{\r\nint have_seeprom = 0;\r\nint i, max_targets, mask;\r\nunsigned char scsirate, scsi_conf;\r\nunsigned short scarray[128];\r\nstruct seeprom_config *sc = (struct seeprom_config *) scarray;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk(KERN_INFO "aic7xxx: Loading serial EEPROM...");\r\n}\r\nswitch (p->chip)\r\n{\r\ncase (AHC_AIC7770|AHC_EISA):\r\nif (aic_inb(p, SCSICONF) & TERM_ENB)\r\np->flags |= AHC_TERM_ENB_A;\r\nif ( (p->features & AHC_TWIN) && (aic_inb(p, SCSICONF + 1) & TERM_ENB) )\r\np->flags |= AHC_TERM_ENB_B;\r\nbreak;\r\ncase (AHC_AIC7770|AHC_VL):\r\nhave_seeprom = read_284x_seeprom(p, (struct seeprom_config *) scarray);\r\nbreak;\r\ndefault:\r\nhave_seeprom = read_seeprom(p, (p->flags & (AHC_CHNLB|AHC_CHNLC)),\r\nscarray, p->sc_size, p->sc_type);\r\nif (!have_seeprom)\r\n{\r\nif(p->sc_type == C46)\r\nhave_seeprom = read_seeprom(p, (p->flags & (AHC_CHNLB|AHC_CHNLC)),\r\nscarray, p->sc_size, C56_66);\r\nelse\r\nhave_seeprom = read_seeprom(p, (p->flags & (AHC_CHNLB|AHC_CHNLC)),\r\nscarray, p->sc_size, C46);\r\n}\r\nif (!have_seeprom)\r\n{\r\np->sc_size = 128;\r\nhave_seeprom = read_seeprom(p, 4*(p->flags & (AHC_CHNLB|AHC_CHNLC)),\r\nscarray, p->sc_size, p->sc_type);\r\nif (!have_seeprom)\r\n{\r\nif(p->sc_type == C46)\r\nhave_seeprom = read_seeprom(p, 4*(p->flags & (AHC_CHNLB|AHC_CHNLC)),\r\nscarray, p->sc_size, C56_66);\r\nelse\r\nhave_seeprom = read_seeprom(p, 4*(p->flags & (AHC_CHNLB|AHC_CHNLC)),\r\nscarray, p->sc_size, C46);\r\n}\r\n}\r\nbreak;\r\n}\r\nif (!have_seeprom)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk("\naic7xxx: No SEEPROM available.\n");\r\n}\r\np->flags |= AHC_NEWEEPROM_FMT;\r\nif (aic_inb(p, SCSISEQ) == 0)\r\n{\r\np->flags |= AHC_USEDEFAULTS;\r\np->flags &= ~AHC_BIOS_ENABLED;\r\np->scsi_id = p->scsi_id_b = 7;\r\n*sxfrctl1 |= STPWEN;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk("aic7xxx: Using default values.\n");\r\n}\r\n}\r\nelse if (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk("aic7xxx: Using leftover BIOS values.\n");\r\n}\r\nif ( ((p->chip & ~AHC_CHIPID_MASK) == AHC_PCI) && (*sxfrctl1 & STPWEN) )\r\n{\r\np->flags |= AHC_TERM_ENB_SE_LOW | AHC_TERM_ENB_SE_HIGH;\r\nsc->adapter_control &= ~CFAUTOTERM;\r\nsc->adapter_control |= CFSTERM | CFWSTERM | CFLVDSTERM;\r\n}\r\nif (aic7xxx_extended)\r\np->flags |= (AHC_EXTEND_TRANS_A | AHC_EXTEND_TRANS_B);\r\nelse\r\np->flags &= ~(AHC_EXTEND_TRANS_A | AHC_EXTEND_TRANS_B);\r\n}\r\nelse\r\n{\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk("done\n");\r\n}\r\np->flags |= AHC_SEEPROM_FOUND;\r\n*sxfrctl1 = 0;\r\np->scsi_id = (sc->brtime_id & CFSCSIID);\r\nif ((p->chip & AHC_CHIPID_MASK) == AHC_AIC7770)\r\n{\r\nif (sc->bios_control & CF284XEXTEND)\r\np->flags |= AHC_EXTEND_TRANS_A;\r\nif (sc->adapter_control & CF284XSTERM)\r\n{\r\n*sxfrctl1 |= STPWEN;\r\np->flags |= AHC_TERM_ENB_SE_LOW | AHC_TERM_ENB_SE_HIGH;\r\n}\r\n}\r\nelse\r\n{\r\nif (sc->bios_control & CFEXTEND)\r\np->flags |= AHC_EXTEND_TRANS_A;\r\nif (sc->bios_control & CFBIOSEN)\r\np->flags |= AHC_BIOS_ENABLED;\r\nelse\r\np->flags &= ~AHC_BIOS_ENABLED;\r\nif (sc->adapter_control & CFSTERM)\r\n{\r\n*sxfrctl1 |= STPWEN;\r\np->flags |= AHC_TERM_ENB_SE_LOW | AHC_TERM_ENB_SE_HIGH;\r\n}\r\n}\r\nmemcpy(&p->sc, sc, sizeof(struct seeprom_config));\r\n}\r\np->discenable = 0;\r\nmax_targets = ((p->features & (AHC_TWIN | AHC_WIDE)) ? 16 : 8);\r\nif (have_seeprom)\r\n{\r\nfor (i = 0; i < max_targets; i++)\r\n{\r\nif( ((p->features & AHC_ULTRA) &&\r\n!(sc->adapter_control & CFULTRAEN) &&\r\n(sc->device_flags[i] & CFSYNCHISULTRA)) ||\r\n(sc->device_flags[i] & CFNEWULTRAFORMAT) )\r\n{\r\np->flags |= AHC_NEWEEPROM_FMT;\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < max_targets; i++)\r\n{\r\nmask = (0x01 << i);\r\nif (!have_seeprom)\r\n{\r\nif (aic_inb(p, SCSISEQ) != 0)\r\n{\r\np->discenable =\r\n~(aic_inb(p, DISC_DSB) | (aic_inb(p, DISC_DSB + 1) << 8) );\r\np->ultraenb =\r\n(aic_inb(p, ULTRA_ENB) | (aic_inb(p, ULTRA_ENB + 1) << 8) );\r\nsc->device_flags[i] = (p->discenable & mask) ? CFDISC : 0;\r\nif (aic_inb(p, TARG_SCSIRATE + i) & WIDEXFER)\r\nsc->device_flags[i] |= CFWIDEB;\r\nif (p->features & AHC_ULTRA2)\r\n{\r\nif (aic_inb(p, TARG_OFFSET + i))\r\n{\r\nsc->device_flags[i] |= CFSYNCH;\r\nsc->device_flags[i] |= (aic_inb(p, TARG_SCSIRATE + i) & 0x07);\r\nif ( (aic_inb(p, TARG_SCSIRATE + i) & 0x18) == 0x18 )\r\nsc->device_flags[i] |= CFSYNCHISULTRA;\r\n}\r\n}\r\nelse\r\n{\r\nif (aic_inb(p, TARG_SCSIRATE + i) & ~WIDEXFER)\r\n{\r\nsc->device_flags[i] |= CFSYNCH;\r\nif (p->features & AHC_ULTRA)\r\nsc->device_flags[i] |= ((p->ultraenb & mask) ?\r\nCFSYNCHISULTRA : 0);\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nsc->device_flags[i] = CFDISC;\r\nif (p->features & AHC_WIDE)\r\nsc->device_flags[i] |= CFWIDEB;\r\nif (p->features & AHC_ULTRA3)\r\nsc->device_flags[i] |= 2;\r\nelse if (p->features & AHC_ULTRA2)\r\nsc->device_flags[i] |= 3;\r\nelse if (p->features & AHC_ULTRA)\r\nsc->device_flags[i] |= CFSYNCHISULTRA;\r\nsc->device_flags[i] |= CFSYNCH;\r\naic_outb(p, 0, TARG_SCSIRATE + i);\r\nif (p->features & AHC_ULTRA2)\r\naic_outb(p, 0, TARG_OFFSET + i);\r\n}\r\n}\r\nif (sc->device_flags[i] & CFDISC)\r\n{\r\np->discenable |= mask;\r\n}\r\nif (p->flags & AHC_NEWEEPROM_FMT)\r\n{\r\nif ( !(p->features & AHC_ULTRA2) )\r\n{\r\nif ( (sc->device_flags[i] & CFNEWULTRAFORMAT) &&\r\n((sc->device_flags[i] & CFXFER) == 0x03) )\r\n{\r\nsc->device_flags[i] &= ~CFXFER;\r\nsc->device_flags[i] |= CFSYNCHISULTRA;\r\n}\r\nif (sc->device_flags[i] & CFSYNCHISULTRA)\r\n{\r\np->ultraenb |= mask;\r\n}\r\n}\r\nelse if ( !(sc->device_flags[i] & CFNEWULTRAFORMAT) &&\r\n(p->features & AHC_ULTRA2) &&\r\n(sc->device_flags[i] & CFSYNCHISULTRA) )\r\n{\r\np->ultraenb |= mask;\r\n}\r\n}\r\nelse if (sc->adapter_control & CFULTRAEN)\r\n{\r\np->ultraenb |= mask;\r\n}\r\nif ( (sc->device_flags[i] & CFSYNCH) == 0)\r\n{\r\nsc->device_flags[i] &= ~CFXFER;\r\np->ultraenb &= ~mask;\r\np->user[i].offset = 0;\r\np->user[i].period = 0;\r\np->user[i].options = 0;\r\n}\r\nelse\r\n{\r\nif (p->features & AHC_ULTRA3)\r\n{\r\np->user[i].offset = MAX_OFFSET_ULTRA2;\r\nif( (sc->device_flags[i] & CFXFER) < 0x03 )\r\n{\r\nscsirate = (sc->device_flags[i] & CFXFER);\r\np->user[i].options = MSG_EXT_PPR_OPTION_DT_CRC;\r\n}\r\nelse\r\n{\r\nscsirate = (sc->device_flags[i] & CFXFER) |\r\n((p->ultraenb & mask) ? 0x18 : 0x10);\r\np->user[i].options = 0;\r\n}\r\np->user[i].period = aic7xxx_find_period(p, scsirate,\r\nAHC_SYNCRATE_ULTRA3);\r\n}\r\nelse if (p->features & AHC_ULTRA2)\r\n{\r\np->user[i].offset = MAX_OFFSET_ULTRA2;\r\nscsirate = (sc->device_flags[i] & CFXFER) |\r\n((p->ultraenb & mask) ? 0x18 : 0x10);\r\np->user[i].options = 0;\r\np->user[i].period = aic7xxx_find_period(p, scsirate,\r\nAHC_SYNCRATE_ULTRA2);\r\n}\r\nelse\r\n{\r\nscsirate = (sc->device_flags[i] & CFXFER) << 4;\r\np->user[i].options = 0;\r\np->user[i].offset = MAX_OFFSET_8BIT;\r\nif (p->features & AHC_ULTRA)\r\n{\r\nshort ultraenb;\r\nultraenb = aic_inb(p, ULTRA_ENB) |\r\n(aic_inb(p, ULTRA_ENB + 1) << 8);\r\np->user[i].period = aic7xxx_find_period(p, scsirate,\r\n(p->ultraenb & mask) ?\r\nAHC_SYNCRATE_ULTRA :\r\nAHC_SYNCRATE_FAST);\r\n}\r\nelse\r\np->user[i].period = aic7xxx_find_period(p, scsirate,\r\nAHC_SYNCRATE_FAST);\r\n}\r\n}\r\nif ( (sc->device_flags[i] & CFWIDEB) && (p->features & AHC_WIDE) )\r\n{\r\np->user[i].width = MSG_EXT_WDTR_BUS_16_BIT;\r\n}\r\nelse\r\n{\r\np->user[i].width = MSG_EXT_WDTR_BUS_8_BIT;\r\n}\r\n}\r\naic_outb(p, ~(p->discenable & 0xFF), DISC_DSB);\r\naic_outb(p, ~((p->discenable >> 8) & 0xFF), DISC_DSB + 1);\r\nif (p->features & AHC_ULTRA)\r\np->ultraenb = aic_inb(p, ULTRA_ENB) | (aic_inb(p, ULTRA_ENB + 1) << 8);\r\nscsi_conf = (p->scsi_id & HSCSIID);\r\nif(have_seeprom)\r\n{\r\np->adapter_control = sc->adapter_control;\r\np->bios_control = sc->bios_control;\r\nswitch (p->chip & AHC_CHIPID_MASK)\r\n{\r\ncase AHC_AIC7895:\r\ncase AHC_AIC7896:\r\ncase AHC_AIC7899:\r\nif (p->adapter_control & CFBPRIMARY)\r\np->flags |= AHC_CHANNEL_B_PRIMARY;\r\ndefault:\r\nbreak;\r\n}\r\nif (sc->adapter_control & CFSPARITY)\r\nscsi_conf |= ENSPCHK;\r\n}\r\nelse\r\n{\r\nscsi_conf |= ENSPCHK | RESET_SCSI;\r\n}\r\nif ( (p->chip & ~AHC_CHIPID_MASK) == AHC_PCI )\r\n{\r\naic_outb(p, scsi_conf, SCSICONF);\r\naic_outb(p, p->scsi_id, SCSICONF + 1);\r\n}\r\n}\r\nstatic void\r\naic7xxx_configure_bugs(struct aic7xxx_host *p)\r\n{\r\nunsigned short tmp_word;\r\nswitch(p->chip & AHC_CHIPID_MASK)\r\n{\r\ncase AHC_AIC7860:\r\np->bugs |= AHC_BUG_PCI_2_1_RETRY;\r\ncase AHC_AIC7850:\r\ncase AHC_AIC7870:\r\np->bugs |= AHC_BUG_TMODE_WIDEODD | AHC_BUG_CACHETHEN | AHC_BUG_PCI_MWI;\r\nbreak;\r\ncase AHC_AIC7880:\r\np->bugs |= AHC_BUG_TMODE_WIDEODD | AHC_BUG_PCI_2_1_RETRY |\r\nAHC_BUG_CACHETHEN | AHC_BUG_PCI_MWI;\r\nbreak;\r\ncase AHC_AIC7890:\r\np->bugs |= AHC_BUG_AUTOFLUSH | AHC_BUG_CACHETHEN;\r\nbreak;\r\ncase AHC_AIC7892:\r\np->bugs |= AHC_BUG_SCBCHAN_UPLOAD;\r\nbreak;\r\ncase AHC_AIC7895:\r\np->bugs |= AHC_BUG_TMODE_WIDEODD | AHC_BUG_PCI_2_1_RETRY |\r\nAHC_BUG_CACHETHEN | AHC_BUG_PCI_MWI;\r\nbreak;\r\ncase AHC_AIC7896:\r\np->bugs |= AHC_BUG_CACHETHEN_DIS;\r\nbreak;\r\ncase AHC_AIC7899:\r\np->bugs |= AHC_BUG_SCBCHAN_UPLOAD;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npci_read_config_word(p->pdev, PCI_COMMAND, &tmp_word);\r\nif(p->bugs & AHC_BUG_PCI_MWI)\r\n{\r\ntmp_word &= ~PCI_COMMAND_INVALIDATE;\r\n}\r\nelse\r\n{\r\ntmp_word |= PCI_COMMAND_INVALIDATE;\r\n}\r\npci_write_config_word(p->pdev, PCI_COMMAND, tmp_word);\r\nif(p->bugs & AHC_BUG_CACHETHEN)\r\n{\r\naic_outb(p, aic_inb(p, DSCOMMAND0) & ~CACHETHEN, DSCOMMAND0);\r\n}\r\nelse if (p->bugs & AHC_BUG_CACHETHEN_DIS)\r\n{\r\naic_outb(p, aic_inb(p, DSCOMMAND0) | CACHETHEN, DSCOMMAND0);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\naic7xxx_detect(struct scsi_host_template *template)\r\n{\r\nstruct aic7xxx_host *temp_p = NULL;\r\nstruct aic7xxx_host *current_p = NULL;\r\nstruct aic7xxx_host *list_p = NULL;\r\nint found = 0;\r\n#if defined(__i386__) || defined(__alpha__)\r\nahc_flag_type flags = 0;\r\nint type;\r\n#endif\r\nunsigned char sxfrctl1;\r\n#if defined(__i386__) || defined(__alpha__)\r\nunsigned char hcntrl, hostconf;\r\nunsigned int slot, base;\r\n#endif\r\n#ifdef MODULE\r\nif(aic7xxx)\r\naic7xxx_setup(aic7xxx);\r\n#endif\r\ntemplate->proc_name = "aic7xxx";\r\ntemplate->sg_tablesize = AIC7XXX_MAX_SG;\r\n#ifdef CONFIG_PCI\r\n{\r\nstatic struct\r\n{\r\nunsigned short vendor_id;\r\nunsigned short device_id;\r\nahc_chip chip;\r\nahc_flag_type flags;\r\nahc_feature features;\r\nint board_name_index;\r\nunsigned short seeprom_size;\r\nunsigned short seeprom_type;\r\n} const aic_pdevs[] = {\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7810, AHC_NONE,\r\nAHC_FNONE, AHC_FENONE, 1,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7850, AHC_AIC7850,\r\nAHC_PAGESCBS, AHC_AIC7850_FE, 5,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7855, AHC_AIC7850,\r\nAHC_PAGESCBS, AHC_AIC7850_FE, 6,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7821, AHC_AIC7860,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7860_FE, 7,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_3860, AHC_AIC7860,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7860_FE, 7,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_38602, AHC_AIC7860,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7860_FE, 7,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_38602, AHC_AIC7860,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7860_FE, 7,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7860, AHC_AIC7860,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MOTHERBOARD,\r\nAHC_AIC7860_FE, 7,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7861, AHC_AIC7860,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7860_FE, 8,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7870, AHC_AIC7870,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED | AHC_MOTHERBOARD,\r\nAHC_AIC7870_FE, 9,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7871, AHC_AIC7870,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED, AHC_AIC7870_FE, 10,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7872, AHC_AIC7870,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7870_FE, 11,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7873, AHC_AIC7870,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7870_FE, 12,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7874, AHC_AIC7870,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED, AHC_AIC7870_FE, 13,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7880, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED | AHC_MOTHERBOARD,\r\nAHC_AIC7880_FE, 14,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7881, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED, AHC_AIC7880_FE, 15,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7882, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7880_FE, 16,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7883, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7880_FE, 17,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7884, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED, AHC_AIC7880_FE, 18,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7885, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED, AHC_AIC7880_FE, 18,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7886, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED, AHC_AIC7880_FE, 18,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7887, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED, AHC_AIC7880_FE | AHC_NEW_AUTOTERM, 19,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7888, AHC_AIC7880,\r\nAHC_PAGESCBS | AHC_BIOS_ENABLED, AHC_AIC7880_FE, 18,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_7895, AHC_AIC7895,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7895_FE, 20,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7890, AHC_AIC7890,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7890_FE, 21,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7890B, AHC_AIC7890,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7890_FE, 21,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_2930U2, AHC_AIC7890,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7890_FE, 22,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_2940U2, AHC_AIC7890,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7890_FE, 23,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7896, AHC_AIC7896,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7896_FE, 24,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_3940U2, AHC_AIC7896,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7896_FE, 25,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_3950U2D, AHC_AIC7896,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7896_FE, 26,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC, PCI_DEVICE_ID_ADAPTEC_1480A, AHC_AIC7860,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_NO_STPWEN,\r\nAHC_AIC7860_FE, 27,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7892A, AHC_AIC7892,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7892_FE, 28,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7892B, AHC_AIC7892,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7892_FE, 28,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7892D, AHC_AIC7892,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7892_FE, 28,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7892P, AHC_AIC7892,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED,\r\nAHC_AIC7892_FE, 28,\r\n32, C46 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7899A, AHC_AIC7899,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7899_FE, 29,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7899B, AHC_AIC7899,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7899_FE, 29,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7899D, AHC_AIC7899,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7899_FE, 29,\r\n32, C56_66 },\r\n{PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_7899P, AHC_AIC7899,\r\nAHC_PAGESCBS | AHC_NEWEEPROM_FMT | AHC_BIOS_ENABLED | AHC_MULTI_CHANNEL,\r\nAHC_AIC7899_FE, 29,\r\n32, C56_66 },\r\n};\r\nunsigned short command;\r\nunsigned int devconfig, i, oldverbose;\r\nstruct pci_dev *pdev = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(aic_pdevs); i++)\r\n{\r\npdev = NULL;\r\nwhile ((pdev = pci_get_device(aic_pdevs[i].vendor_id,\r\naic_pdevs[i].device_id,\r\npdev))) {\r\nif (pci_enable_device(pdev))\r\ncontinue;\r\nif ( i == 0 )\r\n{\r\nif (aic7xxx_verbose & (VERBOSE_PROBE|VERBOSE_PROBE2))\r\n{\r\nprintk(KERN_INFO "aic7xxx: The 7810 RAID controller is not "\r\n"supported by\n");\r\nprintk(KERN_INFO " this driver, we are ignoring it.\n");\r\n}\r\n}\r\nelse if ( (temp_p = kzalloc(sizeof(struct aic7xxx_host),\r\nGFP_ATOMIC)) != NULL )\r\n{\r\ntemp_p->chip = aic_pdevs[i].chip | AHC_PCI;\r\ntemp_p->flags = aic_pdevs[i].flags;\r\ntemp_p->features = aic_pdevs[i].features;\r\ntemp_p->board_name_index = aic_pdevs[i].board_name_index;\r\ntemp_p->sc_size = aic_pdevs[i].seeprom_size;\r\ntemp_p->sc_type = aic_pdevs[i].seeprom_type;\r\ntemp_p->irq = pdev->irq;\r\ntemp_p->pdev = pdev;\r\ntemp_p->pci_bus = pdev->bus->number;\r\ntemp_p->pci_device_fn = pdev->devfn;\r\ntemp_p->base = pci_resource_start(pdev, 0);\r\ntemp_p->mbase = pci_resource_start(pdev, 1);\r\ncurrent_p = list_p;\r\nwhile(current_p && temp_p)\r\n{\r\nif ( ((current_p->pci_bus == temp_p->pci_bus) &&\r\n(current_p->pci_device_fn == temp_p->pci_device_fn)) ||\r\n(temp_p->base && (current_p->base == temp_p->base)) ||\r\n(temp_p->mbase && (current_p->mbase == temp_p->mbase)) )\r\n{\r\nkfree(temp_p);\r\ntemp_p = NULL;\r\ncontinue;\r\n}\r\ncurrent_p = current_p->next;\r\n}\r\nif(pci_request_regions(temp_p->pdev, "aic7xxx"))\r\n{\r\nprintk("aic7xxx: <%s> at PCI %d/%d/%d\n",\r\nboard_names[aic_pdevs[i].board_name_index],\r\ntemp_p->pci_bus,\r\nPCI_SLOT(temp_p->pci_device_fn),\r\nPCI_FUNC(temp_p->pci_device_fn));\r\nprintk("aic7xxx: I/O ports already in use, ignoring.\n");\r\nkfree(temp_p);\r\ncontinue;\r\n}\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk("aic7xxx: <%s> at PCI %d/%d\n",\r\nboard_names[aic_pdevs[i].board_name_index],\r\nPCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn));\r\npci_read_config_word(pdev, PCI_COMMAND, &command);\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk("aic7xxx: Initial PCI_COMMAND value was 0x%x\n",\r\n(int)command);\r\n}\r\n#ifdef AIC7XXX_STRICT_PCI_SETUP\r\ncommand |= PCI_COMMAND_SERR | PCI_COMMAND_PARITY |\r\nPCI_COMMAND_MASTER | PCI_COMMAND_MEMORY | PCI_COMMAND_IO;\r\n#else\r\ncommand |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY | PCI_COMMAND_IO;\r\n#endif\r\ncommand &= ~PCI_COMMAND_INVALIDATE;\r\nif (aic7xxx_pci_parity == 0)\r\ncommand &= ~(PCI_COMMAND_SERR | PCI_COMMAND_PARITY);\r\npci_write_config_word(pdev, PCI_COMMAND, command);\r\n#ifdef AIC7XXX_STRICT_PCI_SETUP\r\npci_read_config_dword(pdev, DEVCONFIG, &devconfig);\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk("aic7xxx: Initial DEVCONFIG value was 0x%x\n", devconfig);\r\n}\r\ndevconfig |= 0x80000040;\r\npci_write_config_dword(pdev, DEVCONFIG, devconfig);\r\n#endif\r\ntemp_p->unpause = INTEN;\r\ntemp_p->pause = temp_p->unpause | PAUSE;\r\nif ( ((temp_p->base == 0) &&\r\n(temp_p->mbase == 0)) ||\r\n(temp_p->irq == 0) )\r\n{\r\nprintk("aic7xxx: <%s> at PCI %d/%d/%d\n",\r\nboard_names[aic_pdevs[i].board_name_index],\r\ntemp_p->pci_bus,\r\nPCI_SLOT(temp_p->pci_device_fn),\r\nPCI_FUNC(temp_p->pci_device_fn));\r\nprintk("aic7xxx: Controller disabled by BIOS, ignoring.\n");\r\ngoto skip_pci_controller;\r\n}\r\n#ifdef MMAPIO\r\nif ( !(temp_p->base) || !(temp_p->flags & AHC_MULTI_CHANNEL) ||\r\n((temp_p->chip != (AHC_AIC7870 | AHC_PCI)) &&\r\n(temp_p->chip != (AHC_AIC7880 | AHC_PCI))) )\r\n{\r\ntemp_p->maddr = ioremap_nocache(temp_p->mbase, 256);\r\nif(temp_p->maddr)\r\n{\r\nif(aic_inb(temp_p, HCNTRL) == 0xff)\r\n{\r\nprintk(KERN_INFO "aic7xxx: <%s> at PCI %d/%d/%d\n",\r\nboard_names[aic_pdevs[i].board_name_index],\r\ntemp_p->pci_bus,\r\nPCI_SLOT(temp_p->pci_device_fn),\r\nPCI_FUNC(temp_p->pci_device_fn));\r\nprintk(KERN_INFO "aic7xxx: MMAPed I/O failed, reverting to "\r\n"Programmed I/O.\n");\r\niounmap(temp_p->maddr);\r\ntemp_p->maddr = NULL;\r\nif(temp_p->base == 0)\r\n{\r\nprintk("aic7xxx: <%s> at PCI %d/%d/%d\n",\r\nboard_names[aic_pdevs[i].board_name_index],\r\ntemp_p->pci_bus,\r\nPCI_SLOT(temp_p->pci_device_fn),\r\nPCI_FUNC(temp_p->pci_device_fn));\r\nprintk("aic7xxx: Controller disabled by BIOS, ignoring.\n");\r\ngoto skip_pci_controller;\r\n}\r\n}\r\n}\r\n}\r\n#endif\r\npause_sequencer(temp_p);\r\noldverbose = aic7xxx_verbose;\r\naic7xxx_verbose = 0;\r\naic7xxx_pci_intr(temp_p);\r\naic7xxx_verbose = oldverbose;\r\ntemp_p->bios_address = 0;\r\nif (temp_p->features & AHC_ULTRA2)\r\ntemp_p->scsi_id = aic_inb(temp_p, SCSIID_ULTRA2) & OID;\r\nelse\r\ntemp_p->scsi_id = aic_inb(temp_p, SCSIID) & OID;\r\nsxfrctl1 = aic_inb(temp_p, SXFRCTL1);\r\nif (aic7xxx_chip_reset(temp_p) == -1)\r\n{\r\ngoto skip_pci_controller;\r\n}\r\naic_outb(temp_p, sxfrctl1, SXFRCTL1);\r\npci_write_config_dword(temp_p->pdev, DEVCONFIG, devconfig);\r\nsxfrctl1 &= STPWEN;\r\nswitch (temp_p->chip & AHC_CHIPID_MASK)\r\n{\r\ncase AHC_AIC7870:\r\ncase AHC_AIC7880:\r\nif(temp_p->flags & AHC_MULTI_CHANNEL)\r\n{\r\nswitch(PCI_SLOT(temp_p->pci_device_fn))\r\n{\r\ncase 5:\r\ntemp_p->flags |= AHC_CHNLB;\r\nbreak;\r\ncase 8:\r\ntemp_p->flags |= AHC_CHNLB;\r\nbreak;\r\ncase 12:\r\ntemp_p->flags |= AHC_CHNLC;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase AHC_AIC7895:\r\ncase AHC_AIC7896:\r\ncase AHC_AIC7899:\r\nif (PCI_FUNC(pdev->devfn) != 0)\r\n{\r\ntemp_p->flags |= AHC_CHNLB;\r\n}\r\nif ((temp_p->chip & AHC_CHIPID_MASK) == AHC_AIC7895)\r\n{\r\npci_read_config_dword(pdev, DEVCONFIG, &devconfig);\r\ndevconfig |= SCBSIZE32;\r\npci_write_config_dword(pdev, DEVCONFIG, devconfig);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (temp_p->chip & AHC_CHIPID_MASK)\r\n{\r\ncase AHC_AIC7892:\r\ncase AHC_AIC7899:\r\naic_outb(temp_p, 0, SCAMCTL);\r\naic_outb(temp_p, aic_inb(temp_p, SFUNCT) | ALT_MODE, SFUNCT);\r\naic_outb(temp_p, AUTO_MSGOUT_DE | DIS_MSGIN_DUALEDGE, OPTIONMODE);\r\naic_outb(temp_p, 0x00, 0x0b);\r\naic_outb(temp_p, 0x10, 0x0a);\r\naic_outb(temp_p, aic_inb(temp_p, SFUNCT) & ~ALT_MODE, SFUNCT);\r\naic_outb(temp_p, CRCVALCHKEN | CRCENDCHKEN | CRCREQCHKEN |\r\nTARGCRCENDEN | TARGCRCCNTEN,\r\nCRCCONTROL1);\r\naic_outb(temp_p, ((aic_inb(temp_p, DSCOMMAND0) | USCBSIZE32 |\r\nMPARCKEN | CIOPARCKEN | CACHETHEN) &\r\n~DPARCKEN), DSCOMMAND0);\r\naic7xxx_load_seeprom(temp_p, &sxfrctl1);\r\nbreak;\r\ncase AHC_AIC7890:\r\ncase AHC_AIC7896:\r\naic_outb(temp_p, 0, SCAMCTL);\r\naic_outb(temp_p, (aic_inb(temp_p, DSCOMMAND0) |\r\nCACHETHEN | MPARCKEN | USCBSIZE32 |\r\nCIOPARCKEN) & ~DPARCKEN, DSCOMMAND0);\r\naic7xxx_load_seeprom(temp_p, &sxfrctl1);\r\nbreak;\r\ncase AHC_AIC7850:\r\ncase AHC_AIC7860:\r\naic_outb(temp_p, (aic_inb(temp_p, DSCOMMAND0) |\r\nCACHETHEN | MPARCKEN) & ~DPARCKEN,\r\nDSCOMMAND0);\r\ndefault:\r\naic7xxx_load_seeprom(temp_p, &sxfrctl1);\r\nbreak;\r\ncase AHC_AIC7880:\r\npci_read_config_dword(pdev, DEVCONFIG, &devconfig);\r\nif ((devconfig & 0xff) >= 1)\r\n{\r\naic_outb(temp_p, (aic_inb(temp_p, DSCOMMAND0) |\r\nCACHETHEN | MPARCKEN) & ~DPARCKEN,\r\nDSCOMMAND0);\r\n}\r\naic7xxx_load_seeprom(temp_p, &sxfrctl1);\r\nbreak;\r\n}\r\nswitch(temp_p->chip & AHC_CHIPID_MASK)\r\n{\r\ncase AHC_AIC7895:\r\ncase AHC_AIC7896:\r\ncase AHC_AIC7899:\r\ncurrent_p = list_p;\r\nwhile(current_p != NULL)\r\n{\r\nif ( (current_p->pci_bus == temp_p->pci_bus) &&\r\n(PCI_SLOT(current_p->pci_device_fn) ==\r\nPCI_SLOT(temp_p->pci_device_fn)) )\r\n{\r\nif ( PCI_FUNC(current_p->pci_device_fn) == 0 )\r\n{\r\ntemp_p->flags |=\r\n(current_p->flags & AHC_CHANNEL_B_PRIMARY);\r\ntemp_p->flags &= ~(AHC_BIOS_ENABLED|AHC_USEDEFAULTS);\r\ntemp_p->flags |=\r\n(current_p->flags & (AHC_BIOS_ENABLED|AHC_USEDEFAULTS));\r\n}\r\nelse\r\n{\r\ncurrent_p->flags |=\r\n(temp_p->flags & AHC_CHANNEL_B_PRIMARY);\r\ncurrent_p->flags &= ~(AHC_BIOS_ENABLED|AHC_USEDEFAULTS);\r\ncurrent_p->flags |=\r\n(temp_p->flags & (AHC_BIOS_ENABLED|AHC_USEDEFAULTS));\r\n}\r\n}\r\ncurrent_p = current_p->next;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch(temp_p->chip & AHC_CHIPID_MASK)\r\n{\r\ndefault:\r\nbreak;\r\ncase AHC_AIC7895:\r\ncase AHC_AIC7896:\r\ncase AHC_AIC7899:\r\npci_read_config_dword(pdev, DEVCONFIG, &devconfig);\r\nif (temp_p->features & AHC_ULTRA2)\r\n{\r\nif ( (aic_inb(temp_p, DSCOMMAND0) & RAMPSM_ULTRA2) &&\r\n(aic7xxx_scbram) )\r\n{\r\naic_outb(temp_p,\r\naic_inb(temp_p, DSCOMMAND0) & ~SCBRAMSEL_ULTRA2,\r\nDSCOMMAND0);\r\ntemp_p->flags |= AHC_EXTERNAL_SRAM;\r\ndevconfig |= EXTSCBPEN;\r\n}\r\nelse if (aic_inb(temp_p, DSCOMMAND0) & RAMPSM_ULTRA2)\r\n{\r\nprintk(KERN_INFO "aic7xxx: <%s> at PCI %d/%d/%d\n",\r\nboard_names[aic_pdevs[i].board_name_index],\r\ntemp_p->pci_bus,\r\nPCI_SLOT(temp_p->pci_device_fn),\r\nPCI_FUNC(temp_p->pci_device_fn));\r\nprintk("aic7xxx: external SCB RAM detected, "\r\n"but not enabled\n");\r\n}\r\n}\r\nelse\r\n{\r\nif ((devconfig & RAMPSM) && (aic7xxx_scbram))\r\n{\r\ndevconfig &= ~SCBRAMSEL;\r\ndevconfig |= EXTSCBPEN;\r\ntemp_p->flags |= AHC_EXTERNAL_SRAM;\r\n}\r\nelse if (devconfig & RAMPSM)\r\n{\r\nprintk(KERN_INFO "aic7xxx: <%s> at PCI %d/%d/%d\n",\r\nboard_names[aic_pdevs[i].board_name_index],\r\ntemp_p->pci_bus,\r\nPCI_SLOT(temp_p->pci_device_fn),\r\nPCI_FUNC(temp_p->pci_device_fn));\r\nprintk("aic7xxx: external SCB RAM detected, "\r\n"but not enabled\n");\r\n}\r\n}\r\npci_write_config_dword(pdev, DEVCONFIG, devconfig);\r\nif ( (temp_p->flags & AHC_EXTERNAL_SRAM) &&\r\n(temp_p->flags & AHC_CHNLB) )\r\naic_outb(temp_p, 1, CCSCBBADDR);\r\nbreak;\r\n}\r\naic_outb(temp_p,\r\n(aic_inb(temp_p, SBLKCTL) & ~(DIAGLEDEN | DIAGLEDON)),\r\nSBLKCTL);\r\nif (temp_p->features & AHC_ULTRA2)\r\n{\r\naic_outb(temp_p, RD_DFTHRSH_MAX | WR_DFTHRSH_MAX, DFF_THRSH);\r\n}\r\nelse\r\n{\r\naic_outb(temp_p, DFTHRSH_100, DSPCISTATUS);\r\n}\r\naic7xxx_configure_bugs(temp_p);\r\npci_dev_get(temp_p->pdev);\r\nif ( list_p == NULL )\r\n{\r\nlist_p = current_p = temp_p;\r\n}\r\nelse\r\n{\r\ncurrent_p = list_p;\r\nwhile(current_p->next != NULL)\r\ncurrent_p = current_p->next;\r\ncurrent_p->next = temp_p;\r\n}\r\ntemp_p->next = NULL;\r\nfound++;\r\ncontinue;\r\nskip_pci_controller:\r\n#ifdef CONFIG_PCI\r\npci_release_regions(temp_p->pdev);\r\n#endif\r\nkfree(temp_p);\r\n}\r\nelse\r\n{\r\nprintk("aic7xxx: Found <%s>\n",\r\nboard_names[aic_pdevs[i].board_name_index]);\r\nprintk(KERN_INFO "aic7xxx: Unable to allocate device memory, "\r\n"skipping.\n");\r\n}\r\n}\r\n}\r\n}\r\n#endif\r\n#if defined(__i386__) || defined(__alpha__)\r\nslot = MINSLOT;\r\nwhile ( (slot <= MAXSLOT) &&\r\n!(aic7xxx_no_probe) )\r\n{\r\nbase = SLOTBASE(slot) + MINREG;\r\nif (!request_region(base, MAXREG - MINREG, "aic7xxx"))\r\n{\r\nslot++;\r\ncontinue;\r\n}\r\nflags = 0;\r\ntype = aic7xxx_probe(slot, base + AHC_HID0, &flags);\r\nif (type == -1)\r\n{\r\nrelease_region(base, MAXREG - MINREG);\r\nslot++;\r\ncontinue;\r\n}\r\ntemp_p = kmalloc(sizeof(struct aic7xxx_host), GFP_ATOMIC);\r\nif (temp_p == NULL)\r\n{\r\nprintk(KERN_WARNING "aic7xxx: Unable to allocate device space.\n");\r\nrelease_region(base, MAXREG - MINREG);\r\nslot++;\r\ncontinue;\r\n}\r\nif (aic7xxx_irq_trigger == 1)\r\nhcntrl = IRQMS;\r\nelse if (aic7xxx_irq_trigger == 0)\r\nhcntrl = 0;\r\nelse\r\nhcntrl = inb(base + HCNTRL) & IRQMS;\r\nmemset(temp_p, 0, sizeof(struct aic7xxx_host));\r\ntemp_p->unpause = hcntrl | INTEN;\r\ntemp_p->pause = hcntrl | PAUSE | INTEN;\r\ntemp_p->base = base;\r\ntemp_p->mbase = 0;\r\ntemp_p->maddr = NULL;\r\ntemp_p->pci_bus = 0;\r\ntemp_p->pci_device_fn = slot;\r\naic_outb(temp_p, hcntrl | PAUSE, HCNTRL);\r\nwhile( (aic_inb(temp_p, HCNTRL) & PAUSE) == 0 ) ;\r\nif (aic7xxx_chip_reset(temp_p) == -1)\r\ntemp_p->irq = 0;\r\nelse\r\ntemp_p->irq = aic_inb(temp_p, INTDEF) & 0x0F;\r\ntemp_p->flags |= AHC_PAGESCBS;\r\nswitch (temp_p->irq)\r\n{\r\ncase 9:\r\ncase 10:\r\ncase 11:\r\ncase 12:\r\ncase 14:\r\ncase 15:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "aic7xxx: Host adapter uses unsupported IRQ "\r\n"level %d, ignoring.\n", temp_p->irq);\r\nkfree(temp_p);\r\nrelease_region(base, MAXREG - MINREG);\r\nslot++;\r\ncontinue;\r\n}\r\nif (list_p == NULL)\r\n{\r\nlist_p = current_p = temp_p;\r\n}\r\nelse\r\n{\r\ncurrent_p = list_p;\r\nwhile (current_p->next != NULL)\r\ncurrent_p = current_p->next;\r\ncurrent_p->next = temp_p;\r\n}\r\nswitch (type)\r\n{\r\ncase 0:\r\ntemp_p->board_name_index = 2;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk("aic7xxx: <%s> at EISA %d\n",\r\nboard_names[2], slot);\r\ncase 1:\r\n{\r\ntemp_p->chip = AHC_AIC7770 | AHC_EISA;\r\ntemp_p->features |= AHC_AIC7770_FE;\r\ntemp_p->bios_control = aic_inb(temp_p, HA_274_BIOSCTRL);\r\nif (temp_p->board_name_index == 0)\r\n{\r\ntemp_p->board_name_index = 3;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk("aic7xxx: <%s> at EISA %d\n",\r\nboard_names[3], slot);\r\n}\r\nif (temp_p->bios_control & CHANNEL_B_PRIMARY)\r\n{\r\ntemp_p->flags |= AHC_CHANNEL_B_PRIMARY;\r\n}\r\nif ((temp_p->bios_control & BIOSMODE) == BIOSDISABLED)\r\n{\r\ntemp_p->flags &= ~AHC_BIOS_ENABLED;\r\n}\r\nelse\r\n{\r\ntemp_p->flags &= ~AHC_USEDEFAULTS;\r\ntemp_p->flags |= AHC_BIOS_ENABLED;\r\nif ( (temp_p->bios_control & 0x20) == 0 )\r\n{\r\ntemp_p->bios_address = 0xcc000;\r\ntemp_p->bios_address += (0x4000 * (temp_p->bios_control & 0x07));\r\n}\r\nelse\r\n{\r\ntemp_p->bios_address = 0xd0000;\r\ntemp_p->bios_address += (0x8000 * (temp_p->bios_control & 0x06));\r\n}\r\n}\r\ntemp_p->adapter_control = aic_inb(temp_p, SCSICONF) << 8;\r\ntemp_p->adapter_control |= aic_inb(temp_p, SCSICONF + 1);\r\nif (temp_p->features & AHC_WIDE)\r\n{\r\ntemp_p->scsi_id = temp_p->adapter_control & HWSCSIID;\r\ntemp_p->scsi_id_b = temp_p->scsi_id;\r\n}\r\nelse\r\n{\r\ntemp_p->scsi_id = (temp_p->adapter_control >> 8) & HSCSIID;\r\ntemp_p->scsi_id_b = temp_p->adapter_control & HSCSIID;\r\n}\r\naic7xxx_load_seeprom(temp_p, &sxfrctl1);\r\nbreak;\r\n}\r\ncase 2:\r\ncase 3:\r\ntemp_p->chip = AHC_AIC7770 | AHC_VL;\r\ntemp_p->features |= AHC_AIC7770_FE;\r\nif (type == 2)\r\ntemp_p->flags |= AHC_BIOS_ENABLED;\r\nelse\r\ntemp_p->flags &= ~AHC_BIOS_ENABLED;\r\nif (aic_inb(temp_p, SCSICONF) & TERM_ENB)\r\nsxfrctl1 = STPWEN;\r\naic7xxx_load_seeprom(temp_p, &sxfrctl1);\r\ntemp_p->board_name_index = 4;\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\nprintk("aic7xxx: <%s> at VLB %d\n",\r\nboard_names[2], slot);\r\nswitch( aic_inb(temp_p, STATUS_2840) & BIOS_SEL )\r\n{\r\ncase 0x00:\r\ntemp_p->bios_address = 0xe0000;\r\nbreak;\r\ncase 0x20:\r\ntemp_p->bios_address = 0xc8000;\r\nbreak;\r\ncase 0x40:\r\ntemp_p->bios_address = 0xd0000;\r\nbreak;\r\ncase 0x60:\r\ntemp_p->bios_address = 0xd8000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (aic7xxx_verbose & VERBOSE_PROBE2)\r\n{\r\nprintk(KERN_INFO "aic7xxx: BIOS %sabled, IO Port 0x%lx, IRQ %d (%s)\n",\r\n(temp_p->flags & AHC_USEDEFAULTS) ? "dis" : "en", temp_p->base,\r\ntemp_p->irq,\r\n(temp_p->pause & IRQMS) ? "level sensitive" : "edge triggered");\r\nprintk(KERN_INFO "aic7xxx: Extended translation %sabled.\n",\r\n(temp_p->flags & AHC_EXTEND_TRANS_A) ? "en" : "dis");\r\n}\r\ntemp_p->bugs |= AHC_BUG_TMODE_WIDEODD;\r\nhostconf = aic_inb(temp_p, HOSTCONF);\r\naic_outb(temp_p, hostconf & DFTHRSH, BUSSPD);\r\naic_outb(temp_p, (hostconf << 2) & BOFF, BUSTIME);\r\nslot++;\r\nfound++;\r\n}\r\n#endif\r\n{\r\nstruct aic7xxx_host *sort_list[4] = { NULL, NULL, NULL, NULL };\r\nstruct aic7xxx_host *vlb, *pci;\r\nstruct aic7xxx_host *prev_p;\r\nstruct aic7xxx_host *p;\r\nunsigned char left;\r\nprev_p = vlb = pci = NULL;\r\ntemp_p = list_p;\r\nwhile (temp_p != NULL)\r\n{\r\nswitch(temp_p->chip & ~AHC_CHIPID_MASK)\r\n{\r\ncase AHC_EISA:\r\ncase AHC_VL:\r\n{\r\np = temp_p;\r\nif (p->flags & AHC_BIOS_ENABLED)\r\nvlb = sort_list[0];\r\nelse\r\nvlb = sort_list[2];\r\nif (vlb == NULL)\r\n{\r\nvlb = temp_p;\r\ntemp_p = temp_p->next;\r\nvlb->next = NULL;\r\n}\r\nelse\r\n{\r\ncurrent_p = vlb;\r\nprev_p = NULL;\r\nwhile ( (current_p != NULL) &&\r\n(current_p->bios_address < temp_p->bios_address))\r\n{\r\nprev_p = current_p;\r\ncurrent_p = current_p->next;\r\n}\r\nif (prev_p != NULL)\r\n{\r\nprev_p->next = temp_p;\r\ntemp_p = temp_p->next;\r\nprev_p->next->next = current_p;\r\n}\r\nelse\r\n{\r\nvlb = temp_p;\r\ntemp_p = temp_p->next;\r\nvlb->next = current_p;\r\n}\r\n}\r\nif (p->flags & AHC_BIOS_ENABLED)\r\nsort_list[0] = vlb;\r\nelse\r\nsort_list[2] = vlb;\r\nbreak;\r\n}\r\ndefault:\r\n{\r\np = temp_p;\r\nif (p->flags & AHC_BIOS_ENABLED)\r\npci = sort_list[1];\r\nelse\r\npci = sort_list[3];\r\nif (pci == NULL)\r\n{\r\npci = temp_p;\r\ntemp_p = temp_p->next;\r\npci->next = NULL;\r\n}\r\nelse\r\n{\r\ncurrent_p = pci;\r\nprev_p = NULL;\r\nif (!aic7xxx_reverse_scan)\r\n{\r\nwhile ( (current_p != NULL) &&\r\n( (PCI_SLOT(current_p->pci_device_fn) |\r\n(current_p->pci_bus << 8)) <\r\n(PCI_SLOT(temp_p->pci_device_fn) |\r\n(temp_p->pci_bus << 8)) ) )\r\n{\r\nprev_p = current_p;\r\ncurrent_p = current_p->next;\r\n}\r\n}\r\nelse\r\n{\r\nwhile ( (current_p != NULL) &&\r\n( (PCI_SLOT(current_p->pci_device_fn) |\r\n(current_p->pci_bus << 8)) >\r\n(PCI_SLOT(temp_p->pci_device_fn) |\r\n(temp_p->pci_bus << 8)) ) )\r\n{\r\nprev_p = current_p;\r\ncurrent_p = current_p->next;\r\n}\r\n}\r\nif ( (current_p) && (temp_p->flags & AHC_MULTI_CHANNEL) &&\r\n(temp_p->pci_bus == current_p->pci_bus) &&\r\n(PCI_SLOT(temp_p->pci_device_fn) ==\r\nPCI_SLOT(current_p->pci_device_fn)) )\r\n{\r\nif (temp_p->flags & AHC_CHNLB)\r\n{\r\nif ( !(temp_p->flags & AHC_CHANNEL_B_PRIMARY) )\r\n{\r\nprev_p = current_p;\r\ncurrent_p = current_p->next;\r\n}\r\n}\r\nelse\r\n{\r\nif (temp_p->flags & AHC_CHANNEL_B_PRIMARY)\r\n{\r\nprev_p = current_p;\r\ncurrent_p = current_p->next;\r\n}\r\n}\r\n}\r\nif (prev_p != NULL)\r\n{\r\nprev_p->next = temp_p;\r\ntemp_p = temp_p->next;\r\nprev_p->next->next = current_p;\r\n}\r\nelse\r\n{\r\npci = temp_p;\r\ntemp_p = temp_p->next;\r\npci->next = current_p;\r\n}\r\n}\r\nif (p->flags & AHC_BIOS_ENABLED)\r\nsort_list[1] = pci;\r\nelse\r\nsort_list[3] = pci;\r\nbreak;\r\n}\r\n}\r\n}\r\n{\r\nint i;\r\nleft = found;\r\nfor (i=0; i<ARRAY_SIZE(sort_list); i++)\r\n{\r\ntemp_p = sort_list[i];\r\nwhile(temp_p != NULL)\r\n{\r\ntemplate->name = board_names[temp_p->board_name_index];\r\np = aic7xxx_alloc(template, temp_p);\r\nif (p != NULL)\r\n{\r\np->instance = found - left;\r\nif (aic7xxx_register(template, p, (--left)) == 0)\r\n{\r\nfound--;\r\naic7xxx_release(p->host);\r\nscsi_unregister(p->host);\r\n}\r\nelse if (aic7xxx_dump_card)\r\n{\r\npause_sequencer(p);\r\naic7xxx_print_card(p);\r\naic7xxx_print_scratch_ram(p);\r\nunpause_sequencer(p, TRUE);\r\n}\r\n}\r\ncurrent_p = temp_p;\r\ntemp_p = (struct aic7xxx_host *)temp_p->next;\r\nkfree(current_p);\r\n}\r\n}\r\n}\r\n}\r\nreturn (found);\r\n}\r\nstatic void aic7xxx_buildscb(struct aic7xxx_host *p, struct scsi_cmnd *cmd,\r\nstruct aic7xxx_scb *scb)\r\n{\r\nunsigned short mask;\r\nstruct aic7xxx_hwscb *hscb;\r\nstruct aic_dev_data *aic_dev = cmd->device->hostdata;\r\nstruct scsi_device *sdptr = cmd->device;\r\nunsigned char tindex = TARGET_INDEX(cmd);\r\nint use_sg;\r\nmask = (0x01 << tindex);\r\nhscb = scb->hscb;\r\nhscb->control = 0;\r\nscb->tag_action = 0;\r\nif (p->discenable & mask)\r\n{\r\nhscb->control |= DISCENB;\r\nif (cmd->cmnd[0] != TEST_UNIT_READY && sdptr->simple_tags)\r\n{\r\nhscb->control |= MSG_SIMPLE_Q_TAG;\r\nscb->tag_action = MSG_SIMPLE_Q_TAG;\r\n}\r\n}\r\nif ( !(aic_dev->dtr_pending) &&\r\n(aic_dev->needppr || aic_dev->needwdtr || aic_dev->needsdtr) &&\r\n(aic_dev->flags & DEVICE_DTR_SCANNED) )\r\n{\r\naic_dev->dtr_pending = 1;\r\nscb->tag_action = 0;\r\nhscb->control &= DISCENB;\r\nhscb->control |= MK_MESSAGE;\r\nif(aic_dev->needppr)\r\n{\r\nscb->flags |= SCB_MSGOUT_PPR;\r\n}\r\nelse if(aic_dev->needwdtr)\r\n{\r\nscb->flags |= SCB_MSGOUT_WDTR;\r\n}\r\nelse if(aic_dev->needsdtr)\r\n{\r\nscb->flags |= SCB_MSGOUT_SDTR;\r\n}\r\nscb->flags |= SCB_DTR_SCB;\r\n}\r\nhscb->target_channel_lun = ((cmd->device->id << 4) & 0xF0) |\r\n((cmd->device->channel & 0x01) << 3) | (cmd->device->lun & 0x07);\r\nhscb->SCSI_cmd_length = cmd->cmd_len;\r\nmemcpy(scb->cmnd, cmd->cmnd, cmd->cmd_len);\r\nhscb->SCSI_cmd_pointer = cpu_to_le32(SCB_DMA_ADDR(scb, scb->cmnd));\r\nuse_sg = scsi_dma_map(cmd);\r\nBUG_ON(use_sg < 0);\r\nif (use_sg) {\r\nstruct scatterlist *sg;\r\nint i;\r\nscb->sg_length = 0;\r\nscsi_for_each_sg(cmd, sg, use_sg, i) {\r\nunsigned int len = sg_dma_len(sg);\r\nscb->sg_list[i].address = cpu_to_le32(sg_dma_address(sg));\r\nscb->sg_list[i].length = cpu_to_le32(len);\r\nscb->sg_length += len;\r\n}\r\nhscb->data_pointer = scb->sg_list[0].address;\r\nhscb->data_count = scb->sg_list[0].length;\r\nscb->sg_count = i;\r\nhscb->SG_segment_count = i;\r\nhscb->SG_list_pointer = cpu_to_le32(SCB_DMA_ADDR(scb, &scb->sg_list[1]));\r\n} else {\r\nscb->sg_count = 0;\r\nscb->sg_length = 0;\r\nhscb->SG_segment_count = 0;\r\nhscb->SG_list_pointer = 0;\r\nhscb->data_count = 0;\r\nhscb->data_pointer = 0;\r\n}\r\n}\r\nstatic int aic7xxx_queue_lck(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))\r\n{\r\nstruct aic7xxx_host *p;\r\nstruct aic7xxx_scb *scb;\r\nstruct aic_dev_data *aic_dev;\r\np = (struct aic7xxx_host *) cmd->device->host->hostdata;\r\naic_dev = cmd->device->hostdata;\r\n#ifdef AIC7XXX_VERBOSE_DEBUGGING\r\nif (aic_dev->active_cmds > aic_dev->max_q_depth)\r\n{\r\nprintk(WARN_LEAD "Commands queued exceeds queue "\r\n"depth, active=%d\n",\r\np->host_no, CTL_OF_CMD(cmd),\r\naic_dev->active_cmds);\r\n}\r\n#endif\r\nscb = scbq_remove_head(&p->scb_data->free_scbs);\r\nif (scb == NULL)\r\n{\r\naic7xxx_allocate_scb(p);\r\nscb = scbq_remove_head(&p->scb_data->free_scbs);\r\nif(scb == NULL)\r\n{\r\nprintk(WARN_LEAD "Couldn't get a free SCB.\n", p->host_no,\r\nCTL_OF_CMD(cmd));\r\nreturn 1;\r\n}\r\n}\r\nscb->cmd = cmd;\r\naic7xxx_position(cmd) = scb->hscb->tag;\r\ncmd->scsi_done = fn;\r\ncmd->result = DID_OK;\r\naic7xxx_error(cmd) = DID_OK;\r\naic7xxx_status(cmd) = 0;\r\ncmd->host_scribble = NULL;\r\naic7xxx_buildscb(p, cmd, scb);\r\nscb->flags |= SCB_ACTIVE | SCB_WAITINGQ;\r\nscbq_insert_tail(&p->waiting_scbs, scb);\r\naic7xxx_run_waiting_queues(p);\r\nreturn (0);\r\n}\r\nint aic7xxx_bus_device_reset(struct scsi_cmnd *cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = __aic7xxx_bus_device_reset(cmd);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic void aic7xxx_panic_abort(struct aic7xxx_host *p, struct scsi_cmnd *cmd)\r\n{\r\nprintk("aic7xxx driver version %s\n", AIC7XXX_C_VERSION);\r\nprintk("Controller type:\n %s\n", board_names[p->board_name_index]);\r\nprintk("p->flags=0x%lx, p->chip=0x%x, p->features=0x%x, "\r\n"sequencer %s paused\n",\r\np->flags, p->chip, p->features,\r\n(aic_inb(p, HCNTRL) & PAUSE) ? "is" : "isn't" );\r\npause_sequencer(p);\r\ndisable_irq(p->irq);\r\naic7xxx_print_card(p);\r\naic7xxx_print_scratch_ram(p);\r\nspin_unlock_irq(p->host->host_lock);\r\nfor(;;) barrier();\r\n}\r\nstatic int __aic7xxx_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct aic7xxx_scb *scb = NULL;\r\nstruct aic7xxx_host *p;\r\nint found=0, disconnected;\r\nunsigned char saved_hscbptr, hscbptr, scb_control;\r\nstruct aic_dev_data *aic_dev;\r\nif(cmd == NULL)\r\n{\r\nprintk(KERN_ERR "aic7xxx_abort: called with NULL cmd!\n");\r\nreturn FAILED;\r\n}\r\np = (struct aic7xxx_host *)cmd->device->host->hostdata;\r\naic_dev = AIC_DEV(cmd);\r\nif(aic7xxx_position(cmd) < p->scb_data->numscbs)\r\nscb = (p->scb_data->scb_array[aic7xxx_position(cmd)]);\r\nelse\r\nreturn FAILED;\r\naic7xxx_isr(p);\r\naic7xxx_done_cmds_complete(p);\r\nif(!(scb->flags & SCB_ACTIVE))\r\nreturn FAILED;\r\npause_sequencer(p);\r\nif (aic7xxx_panic_on_abort)\r\naic7xxx_panic_abort(p, cmd);\r\nif (aic7xxx_verbose & VERBOSE_ABORT)\r\n{\r\nprintk(INFO_LEAD "Aborting scb %d, flags 0x%x, SEQADDR 0x%x, LASTPHASE "\r\n"0x%x\n",\r\np->host_no, CTL_OF_SCB(scb), scb->hscb->tag, scb->flags,\r\naic_inb(p, SEQADDR0) | (aic_inb(p, SEQADDR1) << 8),\r\naic_inb(p, LASTPHASE));\r\nprintk(INFO_LEAD "SG_CACHEPTR 0x%x, SG_COUNT %d, SCSISIGI 0x%x\n",\r\np->host_no, CTL_OF_SCB(scb), (p->features & AHC_ULTRA2) ?\r\naic_inb(p, SG_CACHEPTR) : 0, aic_inb(p, SG_COUNT),\r\naic_inb(p, SCSISIGI));\r\nprintk(INFO_LEAD "SSTAT0 0x%x, SSTAT1 0x%x, SSTAT2 0x%x\n",\r\np->host_no, CTL_OF_SCB(scb), aic_inb(p, SSTAT0),\r\naic_inb(p, SSTAT1), aic_inb(p, SSTAT2));\r\n}\r\nif (scb->flags & SCB_WAITINGQ)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_ABORT_PROCESS)\r\nprintk(INFO_LEAD "SCB found on waiting list and "\r\n"aborted.\n", p->host_no, CTL_OF_SCB(scb));\r\nscbq_remove(&p->waiting_scbs, scb);\r\nscbq_remove(&aic_dev->delayed_scbs, scb);\r\naic_dev->active_cmds++;\r\np->activescbs++;\r\nscb->flags &= ~(SCB_WAITINGQ | SCB_ACTIVE);\r\nscb->flags |= SCB_ABORT | SCB_QUEUED_FOR_DONE;\r\ngoto success;\r\n}\r\nif ( ((found = aic7xxx_search_qinfifo(p, cmd->device->id, cmd->device->channel,\r\ncmd->device->lun, scb->hscb->tag, SCB_ABORT | SCB_QUEUED_FOR_DONE,\r\nFALSE, NULL)) != 0) &&\r\n(aic7xxx_verbose & VERBOSE_ABORT_PROCESS))\r\n{\r\nprintk(INFO_LEAD "SCB found in QINFIFO and aborted.\n", p->host_no,\r\nCTL_OF_SCB(scb));\r\ngoto success;\r\n}\r\nsaved_hscbptr = aic_inb(p, SCBPTR);\r\nif ((hscbptr = aic7xxx_find_scb(p, scb)) != SCB_LIST_NULL)\r\n{\r\naic_outb(p, hscbptr, SCBPTR);\r\nscb_control = aic_inb(p, SCB_CONTROL);\r\ndisconnected = scb_control & DISCONNECTED;\r\nif(!disconnected && aic_inb(p, LASTPHASE) == P_BUSFREE) {\r\nif (aic7xxx_verbose & VERBOSE_ABORT_PROCESS)\r\nprintk(INFO_LEAD "SCB found on hardware waiting"\r\n" list and aborted.\n", p->host_no, CTL_OF_SCB(scb));\r\nif (aic_inb(p, WAITING_SCBH) == hscbptr && aic_inb(p, SCB_NEXT) ==\r\nSCB_LIST_NULL)\r\n{\r\naic_outb(p, aic_inb(p, SCSISEQ) & ~ENSELO, SCSISEQ);\r\naic_outb(p, CLRSELTIMEO, CLRSINT1);\r\naic_outb(p, SCB_LIST_NULL, WAITING_SCBH);\r\n}\r\nelse\r\n{\r\nunsigned char prev, next;\r\nprev = SCB_LIST_NULL;\r\nnext = aic_inb(p, WAITING_SCBH);\r\nwhile(next != SCB_LIST_NULL)\r\n{\r\naic_outb(p, next, SCBPTR);\r\nif (next == hscbptr)\r\n{\r\nnext = aic_inb(p, SCB_NEXT);\r\nif (prev != SCB_LIST_NULL)\r\n{\r\naic_outb(p, prev, SCBPTR);\r\naic_outb(p, next, SCB_NEXT);\r\n}\r\nelse\r\naic_outb(p, next, WAITING_SCBH);\r\naic_outb(p, hscbptr, SCBPTR);\r\nnext = SCB_LIST_NULL;\r\n}\r\nelse\r\n{\r\nprev = next;\r\nnext = aic_inb(p, SCB_NEXT);\r\n}\r\n}\r\n}\r\naic_outb(p, SCB_LIST_NULL, SCB_TAG);\r\naic_outb(p, 0, SCB_CONTROL);\r\naic7xxx_add_curscb_to_free_list(p);\r\nscb->flags = SCB_ABORT | SCB_QUEUED_FOR_DONE;\r\ngoto success;\r\n}\r\nelse if (!disconnected)\r\n{\r\nif((aic_inb(p, LASTPHASE) == P_MESGIN) ||\r\n(aic_inb(p, LASTPHASE) == P_MESGOUT))\r\n{\r\nprintk(INFO_LEAD "message buffer busy, unable to abort.\n",\r\np->host_no, CTL_OF_SCB(scb));\r\nunpause_sequencer(p, FALSE);\r\nreturn FAILED;\r\n}\r\n}\r\naic_outb(p, scb_control | MK_MESSAGE, SCB_CONTROL);\r\nif(!disconnected)\r\n{\r\naic_outb(p, HOST_MSG, MSG_OUT);\r\naic_outb(p, aic_inb(p, SCSISIGI) | ATNO, SCSISIGO);\r\n}\r\naic_outb(p, saved_hscbptr, SCBPTR);\r\n}\r\nelse\r\n{\r\ndisconnected = 1;\r\n}\r\np->flags |= AHC_ABORT_PENDING;\r\nscb->flags |= SCB_QUEUED_ABORT | SCB_ABORT | SCB_RECOVERY_SCB;\r\nscb->hscb->control |= MK_MESSAGE;\r\nif(disconnected)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_ABORT_PROCESS)\r\nprintk(INFO_LEAD "SCB disconnected. Queueing Abort"\r\n" SCB.\n", p->host_no, CTL_OF_SCB(scb));\r\np->qinfifo[p->qinfifonext++] = scb->hscb->tag;\r\nif (p->features & AHC_QUEUE_REGS)\r\naic_outb(p, p->qinfifonext, HNSCB_QOFF);\r\nelse\r\naic_outb(p, p->qinfifonext, KERNEL_QINPOS);\r\n}\r\nunpause_sequencer(p, FALSE);\r\nspin_unlock_irq(p->host->host_lock);\r\nmsleep(1000/4);\r\nspin_lock_irq(p->host->host_lock);\r\nif (p->flags & AHC_ABORT_PENDING)\r\n{\r\nif (aic7xxx_verbose & VERBOSE_ABORT_RETURN)\r\nprintk(INFO_LEAD "Abort never delivered, returning FAILED\n", p->host_no,\r\nCTL_OF_CMD(cmd));\r\np->flags &= ~AHC_ABORT_PENDING;\r\nreturn FAILED;\r\n}\r\nif (aic7xxx_verbose & VERBOSE_ABORT_RETURN)\r\nprintk(INFO_LEAD "Abort successful.\n", p->host_no, CTL_OF_CMD(cmd));\r\nreturn SUCCESS;\r\nsuccess:\r\nif (aic7xxx_verbose & VERBOSE_ABORT_RETURN)\r\nprintk(INFO_LEAD "Abort successful.\n", p->host_no, CTL_OF_CMD(cmd));\r\naic7xxx_run_done_queue(p, TRUE);\r\nunpause_sequencer(p, FALSE);\r\nreturn SUCCESS;\r\n}\r\nstatic int aic7xxx_abort(struct scsi_cmnd *cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = __aic7xxx_abort(cmd);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int aic7xxx_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct aic7xxx_scb *scb;\r\nstruct aic7xxx_host *p;\r\nstruct aic_dev_data *aic_dev;\r\np = (struct aic7xxx_host *) cmd->device->host->hostdata;\r\nspin_lock_irq(p->host->host_lock);\r\naic_dev = AIC_DEV(cmd);\r\nif(aic7xxx_position(cmd) < p->scb_data->numscbs)\r\n{\r\nscb = (p->scb_data->scb_array[aic7xxx_position(cmd)]);\r\nif (scb->cmd != cmd)\r\nscb = NULL;\r\n}\r\nelse\r\n{\r\nscb = NULL;\r\n}\r\nif (aic7xxx_panic_on_abort)\r\naic7xxx_panic_abort(p, cmd);\r\npause_sequencer(p);\r\nwhile((aic_inb(p, INTSTAT) & INT_PEND) && !(p->flags & AHC_IN_ISR))\r\n{\r\naic7xxx_isr(p);\r\npause_sequencer(p);\r\n}\r\naic7xxx_done_cmds_complete(p);\r\nif(scb && (scb->cmd == NULL))\r\n{\r\nunpause_sequencer(p, FALSE);\r\nspin_unlock_irq(p->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\naic7xxx_reset_channel(p, cmd->device->channel, TRUE);\r\nif (p->features & AHC_TWIN)\r\n{\r\naic7xxx_reset_channel(p, cmd->device->channel ^ 0x01, TRUE);\r\nrestart_sequencer(p);\r\n}\r\naic_outb(p, aic_inb(p, SIMODE1) & ~(ENREQINIT|ENBUSFREE), SIMODE1);\r\naic7xxx_clear_intstat(p);\r\np->flags &= ~AHC_HANDLING_REQINITS;\r\np->msg_type = MSG_TYPE_NONE;\r\np->msg_index = 0;\r\np->msg_len = 0;\r\naic7xxx_run_done_queue(p, TRUE);\r\nunpause_sequencer(p, FALSE);\r\nspin_unlock_irq(p->host->host_lock);\r\nssleep(2);\r\nreturn SUCCESS;\r\n}\r\nstatic int\r\naic7xxx_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nsector_t heads, sectors, cylinders;\r\nint ret;\r\nstruct aic7xxx_host *p;\r\nunsigned char *buf;\r\np = (struct aic7xxx_host *) sdev->host->hostdata;\r\nbuf = scsi_bios_ptable(bdev);\r\nif ( buf )\r\n{\r\nret = scsi_partsize(buf, capacity, &geom[2], &geom[0], &geom[1]);\r\nkfree(buf);\r\nif ( ret != -1 )\r\nreturn(ret);\r\n}\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = capacity >> 11;\r\nif ((p->flags & AHC_EXTEND_TRANS_A) && (cylinders > 1024))\r\n{\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = capacity >> 14;\r\nif(capacity > (65535 * heads * sectors))\r\ncylinders = 65535;\r\nelse\r\ncylinders = ((unsigned int)capacity) / (unsigned int)(heads * sectors);\r\n}\r\ngeom[0] = (int)heads;\r\ngeom[1] = (int)sectors;\r\ngeom[2] = (int)cylinders;\r\nreturn (0);\r\n}\r\nstatic int\r\naic7xxx_release(struct Scsi_Host *host)\r\n{\r\nstruct aic7xxx_host *p = (struct aic7xxx_host *) host->hostdata;\r\nstruct aic7xxx_host *next, *prev;\r\nif(p->irq)\r\nfree_irq(p->irq, p);\r\n#ifdef MMAPIO\r\nif(p->maddr)\r\n{\r\niounmap(p->maddr);\r\n}\r\n#endif\r\nif(!p->pdev)\r\nrelease_region(p->base, MAXREG - MINREG);\r\n#ifdef CONFIG_PCI\r\nelse {\r\npci_release_regions(p->pdev);\r\npci_dev_put(p->pdev);\r\n}\r\n#endif\r\nprev = NULL;\r\nnext = first_aic7xxx;\r\nwhile(next != NULL)\r\n{\r\nif(next == p)\r\n{\r\nif(prev == NULL)\r\nfirst_aic7xxx = next->next;\r\nelse\r\nprev->next = next->next;\r\n}\r\nelse\r\n{\r\nprev = next;\r\n}\r\nnext = next->next;\r\n}\r\naic7xxx_free(p);\r\nreturn(0);\r\n}\r\nstatic void\r\naic7xxx_print_card(struct aic7xxx_host *p)\r\n{\r\nint i, j, k, chip;\r\nstatic struct register_ranges {\r\nint num_ranges;\r\nint range_val[32];\r\n} cards_ds[] = {\r\n{ 0, {0,} },\r\n{10, {0x00, 0x05, 0x08, 0x11, 0x18, 0x19, 0x1f, 0x1f, 0x60, 0x60,\r\n0x62, 0x66, 0x80, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9b, 0x9f} },\r\n{ 9, {0x00, 0x05, 0x08, 0x11, 0x18, 0x1f, 0x60, 0x60, 0x62, 0x66,\r\n0x80, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9f} },\r\n{ 9, {0x00, 0x05, 0x08, 0x11, 0x18, 0x1f, 0x60, 0x60, 0x62, 0x66,\r\n0x80, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9f} },\r\n{10, {0x00, 0x05, 0x08, 0x11, 0x18, 0x19, 0x1c, 0x1f, 0x60, 0x60,\r\n0x62, 0x66, 0x80, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9f} },\r\n{10, {0x00, 0x05, 0x08, 0x11, 0x18, 0x1a, 0x1c, 0x1f, 0x60, 0x60,\r\n0x62, 0x66, 0x80, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9f} },\r\n{16, {0x00, 0x05, 0x08, 0x11, 0x18, 0x1f, 0x60, 0x60, 0x62, 0x66,\r\n0x84, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9a, 0x9f, 0x9f,\r\n0xe0, 0xf1, 0xf4, 0xf4, 0xf6, 0xf6, 0xf8, 0xf8, 0xfa, 0xfc,\r\n0xfe, 0xff} },\r\n{12, {0x00, 0x05, 0x08, 0x11, 0x18, 0x19, 0x1b, 0x1f, 0x60, 0x60,\r\n0x62, 0x66, 0x80, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9a,\r\n0x9f, 0x9f, 0xe0, 0xf1} },\r\n{16, {0x00, 0x05, 0x08, 0x11, 0x18, 0x1f, 0x60, 0x60, 0x62, 0x66,\r\n0x84, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9a, 0x9f, 0x9f,\r\n0xe0, 0xf1, 0xf4, 0xf4, 0xf6, 0xf6, 0xf8, 0xf8, 0xfa, 0xfc,\r\n0xfe, 0xff} },\r\n{12, {0x00, 0x05, 0x08, 0x11, 0x18, 0x1f, 0x60, 0x60, 0x62, 0x66,\r\n0x84, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9a, 0x9c, 0x9f,\r\n0xe0, 0xf1, 0xf4, 0xfc} },\r\n{12, {0x00, 0x05, 0x08, 0x11, 0x18, 0x1f, 0x60, 0x60, 0x62, 0x66,\r\n0x84, 0x8e, 0x90, 0x95, 0x97, 0x97, 0x9a, 0x9a, 0x9c, 0x9f,\r\n0xe0, 0xf1, 0xf4, 0xfc} },\r\n};\r\nchip = p->chip & AHC_CHIPID_MASK;\r\nprintk("%s at ",\r\nboard_names[p->board_name_index]);\r\nswitch(p->chip & ~AHC_CHIPID_MASK)\r\n{\r\ncase AHC_VL:\r\nprintk("VLB Slot %d.\n", p->pci_device_fn);\r\nbreak;\r\ncase AHC_EISA:\r\nprintk("EISA Slot %d.\n", p->pci_device_fn);\r\nbreak;\r\ncase AHC_PCI:\r\ndefault:\r\nprintk("PCI %d/%d/%d.\n", p->pci_bus, PCI_SLOT(p->pci_device_fn),\r\nPCI_FUNC(p->pci_device_fn));\r\nbreak;\r\n}\r\nprintk("Card Dump:\n");\r\nk = 0;\r\nfor(i=0; i<cards_ds[chip].num_ranges; i++)\r\n{\r\nfor(j = cards_ds[chip].range_val[ i * 2 ];\r\nj <= cards_ds[chip].range_val[ i * 2 + 1 ] ;\r\nj++)\r\n{\r\nprintk("%02x:%02x ", j, aic_inb(p, j));\r\nif(++k == 13)\r\n{\r\nprintk("\n");\r\nk=0;\r\n}\r\n}\r\n}\r\nif(k != 0)\r\nprintk("\n");\r\nif(p->features & AHC_QUEUE_REGS)\r\n{\r\naic_outb(p, 0, SDSCB_QOFF);\r\naic_outb(p, 0, SNSCB_QOFF);\r\naic_outb(p, 0, HNSCB_QOFF);\r\n}\r\n}\r\nstatic void\r\naic7xxx_print_scratch_ram(struct aic7xxx_host *p)\r\n{\r\nint i, k;\r\nk = 0;\r\nprintk("Scratch RAM:\n");\r\nfor(i = SRAM_BASE; i < SEQCTL; i++)\r\n{\r\nprintk("%02x:%02x ", i, aic_inb(p, i));\r\nif(++k == 13)\r\n{\r\nprintk("\n");\r\nk=0;\r\n}\r\n}\r\nif (p->features & AHC_MORE_SRAM)\r\n{\r\nfor(i = TARG_OFFSET; i < 0x80; i++)\r\n{\r\nprintk("%02x:%02x ", i, aic_inb(p, i));\r\nif(++k == 13)\r\n{\r\nprintk("\n");\r\nk=0;\r\n}\r\n}\r\n}\r\nprintk("\n");\r\n}
