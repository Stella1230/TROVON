static int twl6030_irq_pm_notifier(struct notifier_block *notifier,\r\nunsigned long pm_event, void *unused)\r\n{\r\nint chained_wakeups;\r\nswitch (pm_event) {\r\ncase PM_SUSPEND_PREPARE:\r\nchained_wakeups = atomic_read(&twl6030_wakeirqs);\r\nif (chained_wakeups && !twl_irq_wake_enabled) {\r\nif (enable_irq_wake(twl_irq))\r\npr_err("twl6030 IRQ wake enable failed\n");\r\nelse\r\ntwl_irq_wake_enabled = true;\r\n} else if (!chained_wakeups && twl_irq_wake_enabled) {\r\ndisable_irq_wake(twl_irq);\r\ntwl_irq_wake_enabled = false;\r\n}\r\ndisable_irq(twl_irq);\r\nbreak;\r\ncase PM_POST_SUSPEND:\r\nenable_irq(twl_irq);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int twl6030_irq_thread(void *data)\r\n{\r\nlong irq = (long)data;\r\nstatic unsigned i2c_errors;\r\nstatic const unsigned max_i2c_errors = 100;\r\nint ret;\r\nwhile (!kthread_should_stop()) {\r\nint i;\r\nunion {\r\nu8 bytes[4];\r\nu32 int_sts;\r\n} sts;\r\nwait_for_completion_interruptible(&irq_event);\r\nret = twl_i2c_read(TWL_MODULE_PIH, sts.bytes,\r\nREG_INT_STS_A, 3);\r\nif (ret) {\r\npr_warning("twl6030: I2C error %d reading PIH ISR\n",\r\nret);\r\nif (++i2c_errors >= max_i2c_errors) {\r\nprintk(KERN_ERR "Maximum I2C error count"\r\n" exceeded. Terminating %s.\n",\r\n__func__);\r\nbreak;\r\n}\r\ncomplete(&irq_event);\r\ncontinue;\r\n}\r\nsts.bytes[3] = 0;\r\nif (sts.bytes[2] & 0x10)\r\nsts.bytes[2] |= 0x08;\r\nfor (i = 0; sts.int_sts; sts.int_sts >>= 1, i++) {\r\nlocal_irq_disable();\r\nif (sts.int_sts & 0x1) {\r\nint module_irq = twl6030_irq_base +\r\ntwl6030_interrupt_mapping[i];\r\ngeneric_handle_irq(module_irq);\r\n}\r\nlocal_irq_enable();\r\n}\r\nret = twl_i2c_write_u8(TWL_MODULE_PIH, 0x00, REG_INT_STS_A);\r\nif (ret)\r\npr_warning("twl6030: I2C error in clearing PIH ISR\n");\r\nenable_irq(irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t handle_twl6030_pih(int irq, void *devid)\r\n{\r\ndisable_irq_nosync(irq);\r\ncomplete(devid);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void activate_irq(int irq)\r\n{\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nstatic int twl6030_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nif (on)\r\natomic_inc(&twl6030_wakeirqs);\r\nelse\r\natomic_dec(&twl6030_wakeirqs);\r\nreturn 0;\r\n}\r\nint twl6030_interrupt_unmask(u8 bit_mask, u8 offset)\r\n{\r\nint ret;\r\nu8 unmask_value;\r\nret = twl_i2c_read_u8(TWL_MODULE_PIH, &unmask_value,\r\nREG_INT_STS_A + offset);\r\nunmask_value &= (~(bit_mask));\r\nret |= twl_i2c_write_u8(TWL_MODULE_PIH, unmask_value,\r\nREG_INT_STS_A + offset);\r\nreturn ret;\r\n}\r\nint twl6030_interrupt_mask(u8 bit_mask, u8 offset)\r\n{\r\nint ret;\r\nu8 mask_value;\r\nret = twl_i2c_read_u8(TWL_MODULE_PIH, &mask_value,\r\nREG_INT_STS_A + offset);\r\nmask_value |= (bit_mask);\r\nret |= twl_i2c_write_u8(TWL_MODULE_PIH, mask_value,\r\nREG_INT_STS_A + offset);\r\nreturn ret;\r\n}\r\nint twl6030_mmc_card_detect_config(void)\r\n{\r\nint ret;\r\nu8 reg_val = 0;\r\ntwl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,\r\nREG_INT_MSK_LINE_B);\r\ntwl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,\r\nREG_INT_MSK_STS_B);\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val, TWL6030_MMCCTRL);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to read MMCCTRL, error %d\n", ret);\r\nreturn ret;\r\n}\r\nreg_val &= ~VMMC_AUTO_OFF;\r\nreg_val |= SW_FC;\r\nret = twl_i2c_write_u8(TWL6030_MODULE_ID0, reg_val, TWL6030_MMCCTRL);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to write MMCCTRL, error %d\n", ret);\r\nreturn ret;\r\n}\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val,\r\nTWL6030_CFG_INPUT_PUPD3);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to read CFG_INPUT_PUPD3, error %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreg_val &= ~(MMC_PU | MMC_PD);\r\nret = twl_i2c_write_u8(TWL6030_MODULE_ID0, reg_val,\r\nTWL6030_CFG_INPUT_PUPD3);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to write CFG_INPUT_PUPD3, error %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn twl6030_irq_base + MMCDETECT_INTR_OFFSET;\r\n}\r\nint twl6030_mmc_card_detect(struct device *dev, int slot)\r\n{\r\nint ret = -EIO;\r\nu8 read_reg = 0;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (pdev->id) {\r\npr_err("Unknown MMC controller %d in %s\n", pdev->id, __func__);\r\nreturn ret;\r\n}\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &read_reg,\r\nTWL6030_MMCCTRL);\r\nif (ret >= 0)\r\nret = read_reg & STS_MMC;\r\nreturn ret;\r\n}\r\nint twl6030_init_irq(struct device *dev, int irq_num)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nint nr_irqs, irq_base, irq_end;\r\nstruct task_struct *task;\r\nstatic struct irq_chip twl6030_irq_chip;\r\nint status = 0;\r\nint i;\r\nu8 mask[3];\r\nnr_irqs = TWL6030_NR_IRQS;\r\nirq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);\r\nif (IS_ERR_VALUE(irq_base)) {\r\ndev_err(dev, "Fail to allocate IRQ descs\n");\r\nreturn irq_base;\r\n}\r\nirq_domain_add_legacy(node, nr_irqs, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nirq_end = irq_base + nr_irqs;\r\nmask[0] = 0xFF;\r\nmask[1] = 0xFF;\r\nmask[2] = 0xFF;\r\ntwl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_MSK_LINE_A, 3);\r\ntwl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_MSK_STS_A, 3);\r\ntwl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_STS_A, 3);\r\ntwl6030_irq_base = irq_base;\r\ntwl6030_irq_chip = dummy_irq_chip;\r\ntwl6030_irq_chip.name = "twl6030";\r\ntwl6030_irq_chip.irq_set_type = NULL;\r\ntwl6030_irq_chip.irq_set_wake = twl6030_irq_set_wake;\r\nfor (i = irq_base; i < irq_end; i++) {\r\nirq_set_chip_and_handler(i, &twl6030_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_chip_data(i, (void *)irq_num);\r\nactivate_irq(i);\r\n}\r\ndev_info(dev, "PIH (irq %d) chaining IRQs %d..%d\n",\r\nirq_num, irq_base, irq_end);\r\ninit_completion(&irq_event);\r\nstatus = request_irq(irq_num, handle_twl6030_pih, 0, "TWL6030-PIH",\r\n&irq_event);\r\nif (status < 0) {\r\ndev_err(dev, "could not claim irq %d: %d\n", irq_num, status);\r\ngoto fail_irq;\r\n}\r\ntask = kthread_run(twl6030_irq_thread, (void *)irq_num, "twl6030-irq");\r\nif (IS_ERR(task)) {\r\ndev_err(dev, "could not create irq %d thread!\n", irq_num);\r\nstatus = PTR_ERR(task);\r\ngoto fail_kthread;\r\n}\r\ntwl_irq = irq_num;\r\nregister_pm_notifier(&twl6030_irq_pm_notifier_block);\r\nreturn irq_base;\r\nfail_kthread:\r\nfree_irq(irq_num, &irq_event);\r\nfail_irq:\r\nfor (i = irq_base; i < irq_end; i++)\r\nirq_set_chip_and_handler(i, NULL, NULL);\r\nreturn status;\r\n}\r\nint twl6030_exit_irq(void)\r\n{\r\nunregister_pm_notifier(&twl6030_irq_pm_notifier_block);\r\nif (twl6030_irq_base) {\r\npr_err("twl6030: can't yet clean up IRQs?\n");\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}
