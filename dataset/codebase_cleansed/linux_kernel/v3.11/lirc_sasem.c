static void delete_context(struct sasem_context *context)\r\n{\r\nusb_free_urb(context->tx_urb);\r\nusb_free_urb(context->rx_urb);\r\nlirc_buffer_free(context->driver->rbuf);\r\nkfree(context->driver->rbuf);\r\nkfree(context->driver);\r\nkfree(context);\r\nif (debug)\r\npr_info("%s: context deleted\n", __func__);\r\n}\r\nstatic void deregister_from_lirc(struct sasem_context *context)\r\n{\r\nint retval;\r\nint minor = context->driver->minor;\r\nretval = lirc_unregister_driver(minor);\r\nif (retval)\r\npr_err("%s: unable to deregister from lirc (%d)\n",\r\n__func__, retval);\r\nelse\r\npr_info("Deregistered Sasem driver (minor:%d)\n", minor);\r\n}\r\nstatic int vfd_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_interface *interface;\r\nstruct sasem_context *context = NULL;\r\nint subminor;\r\nint retval = 0;\r\nmutex_lock(&disconnect_lock);\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&sasem_driver, subminor);\r\nif (!interface) {\r\npr_err("%s: could not find interface for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\ncontext = usb_get_intfdata(interface);\r\nif (!context) {\r\ndev_err(&interface->dev,\r\n"%s: no context found for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\nif (context->vfd_isopen) {\r\ndev_err(&interface->dev,\r\n"%s: VFD port is already open", __func__);\r\nretval = -EBUSY;\r\n} else {\r\ncontext->vfd_isopen = 1;\r\nfile->private_data = context;\r\ndev_info(&interface->dev, "VFD port opened\n");\r\n}\r\nmutex_unlock(&context->ctx_lock);\r\nexit:\r\nmutex_unlock(&disconnect_lock);\r\nreturn retval;\r\n}\r\nstatic long vfd_ioctl(struct file *file, unsigned cmd, unsigned long arg)\r\n{\r\nstruct sasem_context *context = NULL;\r\ncontext = (struct sasem_context *) file->private_data;\r\nif (!context) {\r\npr_err("%s: no context for device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\nswitch (cmd) {\r\ncase IOCTL_LCD_CONTRAST:\r\nif (arg > 1000)\r\narg = 1000;\r\ncontext->vfd_contrast = (unsigned int)arg;\r\nbreak;\r\ndefault:\r\npr_info("Unknown IOCTL command\n");\r\nmutex_unlock(&context->ctx_lock);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nmutex_unlock(&context->ctx_lock);\r\nreturn 0;\r\n}\r\nstatic int vfd_close(struct inode *inode, struct file *file)\r\n{\r\nstruct sasem_context *context = NULL;\r\nint retval = 0;\r\ncontext = (struct sasem_context *) file->private_data;\r\nif (!context) {\r\npr_err("%s: no context for device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\nif (!context->vfd_isopen) {\r\ndev_err(&context->dev->dev, "%s: VFD is not open\n", __func__);\r\nretval = -EIO;\r\n} else {\r\ncontext->vfd_isopen = 0;\r\ndev_info(&context->dev->dev, "VFD port closed\n");\r\nif (!context->dev_present && !context->ir_isopen) {\r\nmutex_unlock(&context->ctx_lock);\r\ndelete_context(context);\r\nreturn retval;\r\n}\r\n}\r\nmutex_unlock(&context->ctx_lock);\r\nreturn retval;\r\n}\r\nstatic int send_packet(struct sasem_context *context)\r\n{\r\nunsigned int pipe;\r\nint interval = 0;\r\nint retval = 0;\r\npipe = usb_sndintpipe(context->dev,\r\ncontext->tx_endpoint->bEndpointAddress);\r\ninterval = context->tx_endpoint->bInterval;\r\nusb_fill_int_urb(context->tx_urb, context->dev, pipe,\r\ncontext->usb_tx_buf, sizeof(context->usb_tx_buf),\r\nusb_tx_callback, context, interval);\r\ncontext->tx_urb->actual_length = 0;\r\ninit_completion(&context->tx.finished);\r\natomic_set(&(context->tx.busy), 1);\r\nretval = usb_submit_urb(context->tx_urb, GFP_KERNEL);\r\nif (retval) {\r\natomic_set(&(context->tx.busy), 0);\r\ndev_err(&context->dev->dev, "%s: error submitting urb (%d)\n",\r\n__func__, retval);\r\n} else {\r\nmutex_unlock(&context->ctx_lock);\r\nwait_for_completion(&context->tx.finished);\r\nmutex_lock(&context->ctx_lock);\r\nretval = context->tx.status;\r\nif (retval)\r\ndev_err(&context->dev->dev,\r\n"%s: packet tx failed (%d)\n",\r\n__func__, retval);\r\n}\r\nreturn retval;\r\n}\r\nstatic ssize_t vfd_write(struct file *file, const char *buf,\r\nsize_t n_bytes, loff_t *pos)\r\n{\r\nint i;\r\nint retval = 0;\r\nstruct sasem_context *context;\r\nint *data_buf = NULL;\r\ncontext = (struct sasem_context *) file->private_data;\r\nif (!context) {\r\npr_err("%s: no context for device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\nif (!context->dev_present) {\r\npr_err("%s: no Sasem device present\n", __func__);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (n_bytes <= 0 || n_bytes > SASEM_DATA_BUF_SZ) {\r\ndev_err(&context->dev->dev, "%s: invalid payload size\n",\r\n__func__);\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\ndata_buf = memdup_user(buf, n_bytes);\r\nif (IS_ERR(data_buf)) {\r\nretval = PTR_ERR(data_buf);\r\ngoto exit;\r\n}\r\nmemcpy(context->tx.data_buf, data_buf, n_bytes);\r\nfor (i = n_bytes; i < SASEM_DATA_BUF_SZ; ++i)\r\ncontext->tx.data_buf[i] = ' ';\r\nfor (i = 0; i < 9; i++) {\r\nswitch (i) {\r\ncase 0:\r\nmemcpy(context->usb_tx_buf, "\x07\0\0\0\0\0\0\0", 8);\r\ncontext->usb_tx_buf[1] = (context->vfd_contrast) ?\r\n(0x2B - (context->vfd_contrast - 1) / 250)\r\n: 0x2B;\r\nbreak;\r\ncase 1:\r\nmemcpy(context->usb_tx_buf, "\x09\x01\0\0\0\0\0\0", 8);\r\nbreak;\r\ncase 2:\r\nmemcpy(context->usb_tx_buf, "\x0b\x01\0\0\0\0\0\0", 8);\r\nbreak;\r\ncase 3:\r\nmemcpy(context->usb_tx_buf, context->tx.data_buf, 8);\r\nbreak;\r\ncase 4:\r\nmemcpy(context->usb_tx_buf,\r\ncontext->tx.data_buf + 8, 8);\r\nbreak;\r\ncase 5:\r\nmemcpy(context->usb_tx_buf, "\x09\x01\0\0\0\0\0\0", 8);\r\nbreak;\r\ncase 6:\r\nmemcpy(context->usb_tx_buf, "\x0b\x02\0\0\0\0\0\0", 8);\r\nbreak;\r\ncase 7:\r\nmemcpy(context->usb_tx_buf,\r\ncontext->tx.data_buf + 16, 8);\r\nbreak;\r\ncase 8:\r\nmemcpy(context->usb_tx_buf,\r\ncontext->tx.data_buf + 24, 8);\r\nbreak;\r\n}\r\nretval = send_packet(context);\r\nif (retval) {\r\ndev_err(&context->dev->dev,\r\n"%s: send packet failed for packet #%d\n",\r\n__func__, i);\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nmutex_unlock(&context->ctx_lock);\r\nkfree(data_buf);\r\nreturn (!retval) ? n_bytes : retval;\r\n}\r\nstatic void usb_tx_callback(struct urb *urb)\r\n{\r\nstruct sasem_context *context;\r\nif (!urb)\r\nreturn;\r\ncontext = (struct sasem_context *) urb->context;\r\nif (!context)\r\nreturn;\r\ncontext->tx.status = urb->status;\r\natomic_set(&context->tx.busy, 0);\r\ncomplete(&context->tx.finished);\r\nreturn;\r\n}\r\nstatic int ir_open(void *data)\r\n{\r\nint retval = 0;\r\nstruct sasem_context *context;\r\nmutex_lock(&disconnect_lock);\r\ncontext = (struct sasem_context *) data;\r\nmutex_lock(&context->ctx_lock);\r\nif (context->ir_isopen) {\r\ndev_err(&context->dev->dev, "%s: IR port is already open\n",\r\n__func__);\r\nretval = -EBUSY;\r\ngoto exit;\r\n}\r\nusb_fill_int_urb(context->rx_urb, context->dev,\r\nusb_rcvintpipe(context->dev,\r\ncontext->rx_endpoint->bEndpointAddress),\r\ncontext->usb_rx_buf, sizeof(context->usb_rx_buf),\r\nusb_rx_callback, context, context->rx_endpoint->bInterval);\r\nretval = usb_submit_urb(context->rx_urb, GFP_KERNEL);\r\nif (retval)\r\ndev_err(&context->dev->dev,\r\n"%s: usb_submit_urb failed for ir_open (%d)\n",\r\n__func__, retval);\r\nelse {\r\ncontext->ir_isopen = 1;\r\ndev_info(&context->dev->dev, "IR port opened\n");\r\n}\r\nexit:\r\nmutex_unlock(&context->ctx_lock);\r\nmutex_unlock(&disconnect_lock);\r\nreturn retval;\r\n}\r\nstatic void ir_close(void *data)\r\n{\r\nstruct sasem_context *context;\r\ncontext = (struct sasem_context *)data;\r\nif (!context) {\r\npr_err("%s: no context for device\n", __func__);\r\nreturn;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\nusb_kill_urb(context->rx_urb);\r\ncontext->ir_isopen = 0;\r\npr_info("IR port closed\n");\r\nif (!context->dev_present) {\r\nderegister_from_lirc(context);\r\nif (!context->vfd_isopen) {\r\nmutex_unlock(&context->ctx_lock);\r\ndelete_context(context);\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&context->ctx_lock);\r\nreturn;\r\n}\r\nstatic void incoming_packet(struct sasem_context *context,\r\nstruct urb *urb)\r\n{\r\nint len = urb->actual_length;\r\nunsigned char *buf = urb->transfer_buffer;\r\nlong ms;\r\nstruct timeval tv;\r\nint i;\r\nif (len != 8) {\r\ndev_warn(&context->dev->dev,\r\n"%s: invalid incoming packet size (%d)\n",\r\n__func__, len);\r\nreturn;\r\n}\r\nif (debug) {\r\nprintk(KERN_INFO "Incoming data: ");\r\nfor (i = 0; i < 8; ++i)\r\nprintk(KERN_CONT "%02x ", buf[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\ndo_gettimeofday(&tv);\r\nms = (tv.tv_sec - context->presstime.tv_sec) * 1000 +\r\n(tv.tv_usec - context->presstime.tv_usec) / 1000;\r\nif (memcmp(buf, "\x08\0\0\0\0\0\0\0", 8) == 0) {\r\nif ((ms < 250) && (context->codesaved != 0)) {\r\nmemcpy(buf, &context->lastcode, 8);\r\ncontext->presstime.tv_sec = tv.tv_sec;\r\ncontext->presstime.tv_usec = tv.tv_usec;\r\n}\r\n} else {\r\nmemcpy(&context->lastcode, buf, 8);\r\ncontext->codesaved = 1;\r\ncontext->presstime.tv_sec = tv.tv_sec;\r\ncontext->presstime.tv_usec = tv.tv_usec;\r\n}\r\nlirc_buffer_write(context->driver->rbuf, buf);\r\nwake_up(&context->driver->rbuf->wait_poll);\r\n}\r\nstatic void usb_rx_callback(struct urb *urb)\r\n{\r\nstruct sasem_context *context;\r\nif (!urb)\r\nreturn;\r\ncontext = (struct sasem_context *) urb->context;\r\nif (!context)\r\nreturn;\r\nswitch (urb->status) {\r\ncase -ENOENT:\r\nreturn;\r\ncase 0:\r\nif (context->ir_isopen)\r\nincoming_packet(context, urb);\r\nbreak;\r\ndefault:\r\ndev_warn(&urb->dev->dev, "%s: status (%d): ignored",\r\n__func__, urb->status);\r\nbreak;\r\n}\r\nusb_submit_urb(context->rx_urb, GFP_ATOMIC);\r\nreturn;\r\n}\r\nstatic int sasem_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = NULL;\r\nstruct usb_host_interface *iface_desc = NULL;\r\nstruct usb_endpoint_descriptor *rx_endpoint = NULL;\r\nstruct usb_endpoint_descriptor *tx_endpoint = NULL;\r\nstruct urb *rx_urb = NULL;\r\nstruct urb *tx_urb = NULL;\r\nstruct lirc_driver *driver = NULL;\r\nstruct lirc_buffer *rbuf = NULL;\r\nint lirc_minor = 0;\r\nint num_endpoints;\r\nint retval = 0;\r\nint vfd_ep_found;\r\nint ir_ep_found;\r\nint alloc_status;\r\nstruct sasem_context *context = NULL;\r\nint i;\r\ndev_info(&interface->dev, "%s: found Sasem device\n", __func__);\r\ndev = usb_get_dev(interface_to_usbdev(interface));\r\niface_desc = interface->cur_altsetting;\r\nnum_endpoints = iface_desc->desc.bNumEndpoints;\r\nir_ep_found = 0;\r\nvfd_ep_found = 0;\r\nfor (i = 0; i < num_endpoints && !(ir_ep_found && vfd_ep_found); ++i) {\r\nstruct usb_endpoint_descriptor *ep;\r\nint ep_dir;\r\nint ep_type;\r\nep = &iface_desc->endpoint [i].desc;\r\nep_dir = ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\r\nep_type = ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nif (!ir_ep_found &&\r\nep_dir == USB_DIR_IN &&\r\nep_type == USB_ENDPOINT_XFER_INT) {\r\nrx_endpoint = ep;\r\nir_ep_found = 1;\r\nif (debug)\r\ndev_info(&interface->dev,\r\n"%s: found IR endpoint\n", __func__);\r\n} else if (!vfd_ep_found &&\r\nep_dir == USB_DIR_OUT &&\r\nep_type == USB_ENDPOINT_XFER_INT) {\r\ntx_endpoint = ep;\r\nvfd_ep_found = 1;\r\nif (debug)\r\ndev_info(&interface->dev,\r\n"%s: found VFD endpoint\n", __func__);\r\n}\r\n}\r\nif (!ir_ep_found) {\r\ndev_err(&interface->dev,\r\n"%s: no valid input (IR) endpoint found.\n", __func__);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (!vfd_ep_found)\r\ndev_info(&interface->dev,\r\n"%s: no valid output (VFD) endpoint found.\n",\r\n__func__);\r\nalloc_status = 0;\r\ncontext = kzalloc(sizeof(struct sasem_context), GFP_KERNEL);\r\nif (!context) {\r\nalloc_status = 1;\r\ngoto alloc_status_switch;\r\n}\r\ndriver = kzalloc(sizeof(struct lirc_driver), GFP_KERNEL);\r\nif (!driver) {\r\nalloc_status = 2;\r\ngoto alloc_status_switch;\r\n}\r\nrbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);\r\nif (!rbuf) {\r\nalloc_status = 3;\r\ngoto alloc_status_switch;\r\n}\r\nif (lirc_buffer_init(rbuf, BUF_CHUNK_SIZE, BUF_SIZE)) {\r\ndev_err(&interface->dev,\r\n"%s: lirc_buffer_init failed\n", __func__);\r\nalloc_status = 4;\r\ngoto alloc_status_switch;\r\n}\r\nrx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rx_urb) {\r\ndev_err(&interface->dev,\r\n"%s: usb_alloc_urb failed for IR urb\n", __func__);\r\nalloc_status = 5;\r\ngoto alloc_status_switch;\r\n}\r\nif (vfd_ep_found) {\r\ntx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!tx_urb) {\r\ndev_err(&interface->dev,\r\n"%s: usb_alloc_urb failed for VFD urb",\r\n__func__);\r\nalloc_status = 6;\r\ngoto alloc_status_switch;\r\n}\r\n}\r\nmutex_init(&context->ctx_lock);\r\nstrcpy(driver->name, MOD_NAME);\r\ndriver->minor = -1;\r\ndriver->code_length = 64;\r\ndriver->sample_rate = 0;\r\ndriver->features = LIRC_CAN_REC_LIRCCODE;\r\ndriver->data = context;\r\ndriver->rbuf = rbuf;\r\ndriver->set_use_inc = ir_open;\r\ndriver->set_use_dec = ir_close;\r\ndriver->dev = &interface->dev;\r\ndriver->owner = THIS_MODULE;\r\nmutex_lock(&context->ctx_lock);\r\nlirc_minor = lirc_register_driver(driver);\r\nif (lirc_minor < 0) {\r\ndev_err(&interface->dev,\r\n"%s: lirc_register_driver failed\n", __func__);\r\nalloc_status = 7;\r\nretval = lirc_minor;\r\ngoto unlock;\r\n} else\r\ndev_info(&interface->dev,\r\n"%s: Registered Sasem driver (minor:%d)\n",\r\n__func__, lirc_minor);\r\ndriver->minor = lirc_minor;\r\ncontext->dev = dev;\r\ncontext->dev_present = 1;\r\ncontext->rx_endpoint = rx_endpoint;\r\ncontext->rx_urb = rx_urb;\r\nif (vfd_ep_found) {\r\ncontext->tx_endpoint = tx_endpoint;\r\ncontext->tx_urb = tx_urb;\r\ncontext->vfd_contrast = 1000;\r\n}\r\ncontext->driver = driver;\r\nusb_set_intfdata(interface, context);\r\nif (vfd_ep_found) {\r\nif (debug)\r\ndev_info(&interface->dev,\r\n"Registering VFD with sysfs\n");\r\nif (usb_register_dev(interface, &sasem_class))\r\ndev_info(&interface->dev,\r\n"%s: could not get a minor number for VFD\n",\r\n__func__);\r\n}\r\ndev_info(&interface->dev,\r\n"%s: Sasem device on usb<%d:%d> initialized\n",\r\n__func__, dev->bus->busnum, dev->devnum);\r\nunlock:\r\nmutex_unlock(&context->ctx_lock);\r\nalloc_status_switch:\r\nswitch (alloc_status) {\r\ncase 7:\r\nif (vfd_ep_found)\r\nusb_free_urb(tx_urb);\r\ncase 6:\r\nusb_free_urb(rx_urb);\r\ncase 5:\r\nlirc_buffer_free(rbuf);\r\ncase 4:\r\nkfree(rbuf);\r\ncase 3:\r\nkfree(driver);\r\ncase 2:\r\nkfree(context);\r\ncontext = NULL;\r\ncase 1:\r\nif (retval == 0)\r\nretval = -ENOMEM;\r\n}\r\nexit:\r\nreturn retval;\r\n}\r\nstatic void sasem_disconnect(struct usb_interface *interface)\r\n{\r\nstruct sasem_context *context;\r\nmutex_lock(&disconnect_lock);\r\ncontext = usb_get_intfdata(interface);\r\nmutex_lock(&context->ctx_lock);\r\ndev_info(&interface->dev, "%s: Sasem device disconnected\n",\r\n__func__);\r\nusb_set_intfdata(interface, NULL);\r\ncontext->dev_present = 0;\r\nusb_kill_urb(context->rx_urb);\r\nif (atomic_read(&context->tx.busy)) {\r\nusb_kill_urb(context->tx_urb);\r\nwait_for_completion(&context->tx.finished);\r\n}\r\nif (!context->ir_isopen)\r\nderegister_from_lirc(context);\r\nusb_deregister_dev(interface, &sasem_class);\r\nmutex_unlock(&context->ctx_lock);\r\nif (!context->ir_isopen && !context->vfd_isopen)\r\ndelete_context(context);\r\nmutex_unlock(&disconnect_lock);\r\n}
