static void spidev_complete(void *arg)\r\n{\r\ncomplete(arg);\r\n}\r\nstatic ssize_t\r\nspidev_sync(struct spidev_data *spidev, struct spi_message *message)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nint status;\r\nmessage->complete = spidev_complete;\r\nmessage->context = &done;\r\nspin_lock_irq(&spidev->spi_lock);\r\nif (spidev->spi == NULL)\r\nstatus = -ESHUTDOWN;\r\nelse\r\nstatus = spi_async(spidev->spi, message);\r\nspin_unlock_irq(&spidev->spi_lock);\r\nif (status == 0) {\r\nwait_for_completion(&done);\r\nstatus = message->status;\r\nif (status == 0)\r\nstatus = message->actual_length;\r\n}\r\nreturn status;\r\n}\r\nstatic inline ssize_t\r\nspidev_sync_write(struct spidev_data *spidev, size_t len)\r\n{\r\nstruct spi_transfer t = {\r\n.tx_buf = spidev->buffer,\r\n.len = len,\r\n};\r\nstruct spi_message m;\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nreturn spidev_sync(spidev, &m);\r\n}\r\nstatic inline ssize_t\r\nspidev_sync_read(struct spidev_data *spidev, size_t len)\r\n{\r\nstruct spi_transfer t = {\r\n.rx_buf = spidev->buffer,\r\n.len = len,\r\n};\r\nstruct spi_message m;\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nreturn spidev_sync(spidev, &m);\r\n}\r\nstatic ssize_t\r\nspidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)\r\n{\r\nstruct spidev_data *spidev;\r\nssize_t status = 0;\r\nif (count > bufsiz)\r\nreturn -EMSGSIZE;\r\nspidev = filp->private_data;\r\nmutex_lock(&spidev->buf_lock);\r\nstatus = spidev_sync_read(spidev, count);\r\nif (status > 0) {\r\nunsigned long missing;\r\nmissing = copy_to_user(buf, spidev->buffer, status);\r\nif (missing == status)\r\nstatus = -EFAULT;\r\nelse\r\nstatus = status - missing;\r\n}\r\nmutex_unlock(&spidev->buf_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t\r\nspidev_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nstruct spidev_data *spidev;\r\nssize_t status = 0;\r\nunsigned long missing;\r\nif (count > bufsiz)\r\nreturn -EMSGSIZE;\r\nspidev = filp->private_data;\r\nmutex_lock(&spidev->buf_lock);\r\nmissing = copy_from_user(spidev->buffer, buf, count);\r\nif (missing == 0) {\r\nstatus = spidev_sync_write(spidev, count);\r\n} else\r\nstatus = -EFAULT;\r\nmutex_unlock(&spidev->buf_lock);\r\nreturn status;\r\n}\r\nstatic int spidev_message(struct spidev_data *spidev,\r\nstruct spi_ioc_transfer *u_xfers, unsigned n_xfers)\r\n{\r\nstruct spi_message msg;\r\nstruct spi_transfer *k_xfers;\r\nstruct spi_transfer *k_tmp;\r\nstruct spi_ioc_transfer *u_tmp;\r\nunsigned n, total;\r\nu8 *buf;\r\nint status = -EFAULT;\r\nspi_message_init(&msg);\r\nk_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);\r\nif (k_xfers == NULL)\r\nreturn -ENOMEM;\r\nbuf = spidev->buffer;\r\ntotal = 0;\r\nfor (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;\r\nn;\r\nn--, k_tmp++, u_tmp++) {\r\nk_tmp->len = u_tmp->len;\r\ntotal += k_tmp->len;\r\nif (total > bufsiz) {\r\nstatus = -EMSGSIZE;\r\ngoto done;\r\n}\r\nif (u_tmp->rx_buf) {\r\nk_tmp->rx_buf = buf;\r\nif (!access_ok(VERIFY_WRITE, (u8 __user *)\r\n(uintptr_t) u_tmp->rx_buf,\r\nu_tmp->len))\r\ngoto done;\r\n}\r\nif (u_tmp->tx_buf) {\r\nk_tmp->tx_buf = buf;\r\nif (copy_from_user(buf, (const u8 __user *)\r\n(uintptr_t) u_tmp->tx_buf,\r\nu_tmp->len))\r\ngoto done;\r\n}\r\nbuf += k_tmp->len;\r\nk_tmp->cs_change = !!u_tmp->cs_change;\r\nk_tmp->bits_per_word = u_tmp->bits_per_word;\r\nk_tmp->delay_usecs = u_tmp->delay_usecs;\r\nk_tmp->speed_hz = u_tmp->speed_hz;\r\n#ifdef VERBOSE\r\ndev_dbg(&spidev->spi->dev,\r\n" xfer len %zd %s%s%s%dbits %u usec %uHz\n",\r\nu_tmp->len,\r\nu_tmp->rx_buf ? "rx " : "",\r\nu_tmp->tx_buf ? "tx " : "",\r\nu_tmp->cs_change ? "cs " : "",\r\nu_tmp->bits_per_word ? : spidev->spi->bits_per_word,\r\nu_tmp->delay_usecs,\r\nu_tmp->speed_hz ? : spidev->spi->max_speed_hz);\r\n#endif\r\nspi_message_add_tail(k_tmp, &msg);\r\n}\r\nstatus = spidev_sync(spidev, &msg);\r\nif (status < 0)\r\ngoto done;\r\nbuf = spidev->buffer;\r\nfor (n = n_xfers, u_tmp = u_xfers; n; n--, u_tmp++) {\r\nif (u_tmp->rx_buf) {\r\nif (__copy_to_user((u8 __user *)\r\n(uintptr_t) u_tmp->rx_buf, buf,\r\nu_tmp->len)) {\r\nstatus = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\nbuf += u_tmp->len;\r\n}\r\nstatus = total;\r\ndone:\r\nkfree(k_xfers);\r\nreturn status;\r\n}\r\nstatic long\r\nspidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nint err = 0;\r\nint retval = 0;\r\nstruct spidev_data *spidev;\r\nstruct spi_device *spi;\r\nu32 tmp;\r\nunsigned n_ioc;\r\nstruct spi_ioc_transfer *ioc;\r\nif (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)\r\nreturn -ENOTTY;\r\nif (_IOC_DIR(cmd) & _IOC_READ)\r\nerr = !access_ok(VERIFY_WRITE,\r\n(void __user *)arg, _IOC_SIZE(cmd));\r\nif (err == 0 && _IOC_DIR(cmd) & _IOC_WRITE)\r\nerr = !access_ok(VERIFY_READ,\r\n(void __user *)arg, _IOC_SIZE(cmd));\r\nif (err)\r\nreturn -EFAULT;\r\nspidev = filp->private_data;\r\nspin_lock_irq(&spidev->spi_lock);\r\nspi = spi_dev_get(spidev->spi);\r\nspin_unlock_irq(&spidev->spi_lock);\r\nif (spi == NULL)\r\nreturn -ESHUTDOWN;\r\nmutex_lock(&spidev->buf_lock);\r\nswitch (cmd) {\r\ncase SPI_IOC_RD_MODE:\r\nretval = __put_user(spi->mode & SPI_MODE_MASK,\r\n(__u8 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_RD_LSB_FIRST:\r\nretval = __put_user((spi->mode & SPI_LSB_FIRST) ? 1 : 0,\r\n(__u8 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_RD_BITS_PER_WORD:\r\nretval = __put_user(spi->bits_per_word, (__u8 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_RD_MAX_SPEED_HZ:\r\nretval = __put_user(spi->max_speed_hz, (__u32 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_WR_MODE:\r\nretval = __get_user(tmp, (u8 __user *)arg);\r\nif (retval == 0) {\r\nu8 save = spi->mode;\r\nif (tmp & ~SPI_MODE_MASK) {\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\ntmp |= spi->mode & ~SPI_MODE_MASK;\r\nspi->mode = (u8)tmp;\r\nretval = spi_setup(spi);\r\nif (retval < 0)\r\nspi->mode = save;\r\nelse\r\ndev_dbg(&spi->dev, "spi mode %02x\n", tmp);\r\n}\r\nbreak;\r\ncase SPI_IOC_WR_LSB_FIRST:\r\nretval = __get_user(tmp, (__u8 __user *)arg);\r\nif (retval == 0) {\r\nu8 save = spi->mode;\r\nif (tmp)\r\nspi->mode |= SPI_LSB_FIRST;\r\nelse\r\nspi->mode &= ~SPI_LSB_FIRST;\r\nretval = spi_setup(spi);\r\nif (retval < 0)\r\nspi->mode = save;\r\nelse\r\ndev_dbg(&spi->dev, "%csb first\n",\r\ntmp ? 'l' : 'm');\r\n}\r\nbreak;\r\ncase SPI_IOC_WR_BITS_PER_WORD:\r\nretval = __get_user(tmp, (__u8 __user *)arg);\r\nif (retval == 0) {\r\nu8 save = spi->bits_per_word;\r\nspi->bits_per_word = tmp;\r\nretval = spi_setup(spi);\r\nif (retval < 0)\r\nspi->bits_per_word = save;\r\nelse\r\ndev_dbg(&spi->dev, "%d bits per word\n", tmp);\r\n}\r\nbreak;\r\ncase SPI_IOC_WR_MAX_SPEED_HZ:\r\nretval = __get_user(tmp, (__u32 __user *)arg);\r\nif (retval == 0) {\r\nu32 save = spi->max_speed_hz;\r\nspi->max_speed_hz = tmp;\r\nretval = spi_setup(spi);\r\nif (retval < 0)\r\nspi->max_speed_hz = save;\r\nelse\r\ndev_dbg(&spi->dev, "%d Hz (max)\n", tmp);\r\n}\r\nbreak;\r\ndefault:\r\nif (_IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))\r\n|| _IOC_DIR(cmd) != _IOC_WRITE) {\r\nretval = -ENOTTY;\r\nbreak;\r\n}\r\ntmp = _IOC_SIZE(cmd);\r\nif ((tmp % sizeof(struct spi_ioc_transfer)) != 0) {\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nn_ioc = tmp / sizeof(struct spi_ioc_transfer);\r\nif (n_ioc == 0)\r\nbreak;\r\nioc = kmalloc(tmp, GFP_KERNEL);\r\nif (!ioc) {\r\nretval = -ENOMEM;\r\nbreak;\r\n}\r\nif (__copy_from_user(ioc, (void __user *)arg, tmp)) {\r\nkfree(ioc);\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nretval = spidev_message(spidev, ioc, n_ioc);\r\nkfree(ioc);\r\nbreak;\r\n}\r\nmutex_unlock(&spidev->buf_lock);\r\nspi_dev_put(spi);\r\nreturn retval;\r\n}\r\nstatic long\r\nspidev_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn spidev_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int spidev_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct spidev_data *spidev;\r\nint status = -ENXIO;\r\nmutex_lock(&device_list_lock);\r\nlist_for_each_entry(spidev, &device_list, device_entry) {\r\nif (spidev->devt == inode->i_rdev) {\r\nstatus = 0;\r\nbreak;\r\n}\r\n}\r\nif (status == 0) {\r\nif (!spidev->buffer) {\r\nspidev->buffer = kmalloc(bufsiz, GFP_KERNEL);\r\nif (!spidev->buffer) {\r\ndev_dbg(&spidev->spi->dev, "open/ENOMEM\n");\r\nstatus = -ENOMEM;\r\n}\r\n}\r\nif (status == 0) {\r\nspidev->users++;\r\nfilp->private_data = spidev;\r\nnonseekable_open(inode, filp);\r\n}\r\n} else\r\npr_debug("spidev: nothing for minor %d\n", iminor(inode));\r\nmutex_unlock(&device_list_lock);\r\nreturn status;\r\n}\r\nstatic int spidev_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct spidev_data *spidev;\r\nint status = 0;\r\nmutex_lock(&device_list_lock);\r\nspidev = filp->private_data;\r\nfilp->private_data = NULL;\r\nspidev->users--;\r\nif (!spidev->users) {\r\nint dofree;\r\nkfree(spidev->buffer);\r\nspidev->buffer = NULL;\r\nspin_lock_irq(&spidev->spi_lock);\r\ndofree = (spidev->spi == NULL);\r\nspin_unlock_irq(&spidev->spi_lock);\r\nif (dofree)\r\nkfree(spidev);\r\n}\r\nmutex_unlock(&device_list_lock);\r\nreturn status;\r\n}\r\nstatic int spidev_probe(struct spi_device *spi)\r\n{\r\nstruct spidev_data *spidev;\r\nint status;\r\nunsigned long minor;\r\nspidev = kzalloc(sizeof(*spidev), GFP_KERNEL);\r\nif (!spidev)\r\nreturn -ENOMEM;\r\nspidev->spi = spi;\r\nspin_lock_init(&spidev->spi_lock);\r\nmutex_init(&spidev->buf_lock);\r\nINIT_LIST_HEAD(&spidev->device_entry);\r\nmutex_lock(&device_list_lock);\r\nminor = find_first_zero_bit(minors, N_SPI_MINORS);\r\nif (minor < N_SPI_MINORS) {\r\nstruct device *dev;\r\nspidev->devt = MKDEV(SPIDEV_MAJOR, minor);\r\ndev = device_create(spidev_class, &spi->dev, spidev->devt,\r\nspidev, "spidev%d.%d",\r\nspi->master->bus_num, spi->chip_select);\r\nstatus = PTR_RET(dev);\r\n} else {\r\ndev_dbg(&spi->dev, "no minor number available!\n");\r\nstatus = -ENODEV;\r\n}\r\nif (status == 0) {\r\nset_bit(minor, minors);\r\nlist_add(&spidev->device_entry, &device_list);\r\n}\r\nmutex_unlock(&device_list_lock);\r\nif (status == 0)\r\nspi_set_drvdata(spi, spidev);\r\nelse\r\nkfree(spidev);\r\nreturn status;\r\n}\r\nstatic int spidev_remove(struct spi_device *spi)\r\n{\r\nstruct spidev_data *spidev = spi_get_drvdata(spi);\r\nspin_lock_irq(&spidev->spi_lock);\r\nspidev->spi = NULL;\r\nspi_set_drvdata(spi, NULL);\r\nspin_unlock_irq(&spidev->spi_lock);\r\nmutex_lock(&device_list_lock);\r\nlist_del(&spidev->device_entry);\r\ndevice_destroy(spidev_class, spidev->devt);\r\nclear_bit(MINOR(spidev->devt), minors);\r\nif (spidev->users == 0)\r\nkfree(spidev);\r\nmutex_unlock(&device_list_lock);\r\nreturn 0;\r\n}\r\nstatic int __init spidev_init(void)\r\n{\r\nint status;\r\nBUILD_BUG_ON(N_SPI_MINORS > 256);\r\nstatus = register_chrdev(SPIDEV_MAJOR, "spi", &spidev_fops);\r\nif (status < 0)\r\nreturn status;\r\nspidev_class = class_create(THIS_MODULE, "spidev");\r\nif (IS_ERR(spidev_class)) {\r\nunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\r\nreturn PTR_ERR(spidev_class);\r\n}\r\nstatus = spi_register_driver(&spidev_spi_driver);\r\nif (status < 0) {\r\nclass_destroy(spidev_class);\r\nunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\r\n}\r\nreturn status;\r\n}\r\nstatic void __exit spidev_exit(void)\r\n{\r\nspi_unregister_driver(&spidev_spi_driver);\r\nclass_destroy(spidev_class);\r\nunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\r\n}
