static bool\r\nxfs_dir3_leafn_check(\r\nstruct xfs_mount *mp,\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_dir2_leaf *leaf = bp->b_addr;\r\nstruct xfs_dir3_icleaf_hdr leafhdr;\r\nxfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nif (leafhdr.magic == XFS_DIR3_LEAFN_MAGIC) {\r\nstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\r\nif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\r\nreturn false;\r\n} else if (leafhdr.magic != XFS_DIR2_LEAFN_MAGIC)\r\nreturn false;\r\nreturn xfs_dir3_leaf_check_int(mp, &leafhdr, leaf);\r\n}\r\nstatic bool\r\nxfs_dir3_free_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_mount *mp = bp->b_target->bt_mount;\r\nstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\r\nif (xfs_sb_version_hascrc(&mp->m_sb)) {\r\nstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\r\nif (hdr3->magic != cpu_to_be32(XFS_DIR3_FREE_MAGIC))\r\nreturn false;\r\nif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\r\nreturn false;\r\nif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\r\nreturn false;\r\n} else {\r\nif (hdr->magic != cpu_to_be32(XFS_DIR2_FREE_MAGIC))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nxfs_dir3_free_read_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_mount *mp = bp->b_target->bt_mount;\r\nif ((xfs_sb_version_hascrc(&mp->m_sb) &&\r\n!xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\r\nXFS_DIR3_FREE_CRC_OFF)) ||\r\n!xfs_dir3_free_verify(bp)) {\r\nXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp->b_addr);\r\nxfs_buf_ioerror(bp, EFSCORRUPTED);\r\n}\r\n}\r\nstatic void\r\nxfs_dir3_free_write_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_mount *mp = bp->b_target->bt_mount;\r\nstruct xfs_buf_log_item *bip = bp->b_fspriv;\r\nstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\r\nif (!xfs_dir3_free_verify(bp)) {\r\nXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp->b_addr);\r\nxfs_buf_ioerror(bp, EFSCORRUPTED);\r\nreturn;\r\n}\r\nif (!xfs_sb_version_hascrc(&mp->m_sb))\r\nreturn;\r\nif (bip)\r\nhdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\r\nxfs_update_cksum(bp->b_addr, BBTOB(bp->b_length), XFS_DIR3_FREE_CRC_OFF);\r\n}\r\nstatic int\r\n__xfs_dir3_free_read(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *dp,\r\nxfs_dablk_t fbno,\r\nxfs_daddr_t mappedbno,\r\nstruct xfs_buf **bpp)\r\n{\r\nint err;\r\nerr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\r\nXFS_DATA_FORK, &xfs_dir3_free_buf_ops);\r\nif (!err && tp && *bpp)\r\nxfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_FREE_BUF);\r\nreturn err;\r\n}\r\nint\r\nxfs_dir2_free_read(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *dp,\r\nxfs_dablk_t fbno,\r\nstruct xfs_buf **bpp)\r\n{\r\nreturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\r\n}\r\nstatic int\r\nxfs_dir2_free_try_read(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *dp,\r\nxfs_dablk_t fbno,\r\nstruct xfs_buf **bpp)\r\n{\r\nreturn __xfs_dir3_free_read(tp, dp, fbno, -2, bpp);\r\n}\r\nvoid\r\nxfs_dir3_free_hdr_from_disk(\r\nstruct xfs_dir3_icfree_hdr *to,\r\nstruct xfs_dir2_free *from)\r\n{\r\nif (from->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC)) {\r\nto->magic = be32_to_cpu(from->hdr.magic);\r\nto->firstdb = be32_to_cpu(from->hdr.firstdb);\r\nto->nvalid = be32_to_cpu(from->hdr.nvalid);\r\nto->nused = be32_to_cpu(from->hdr.nused);\r\n} else {\r\nstruct xfs_dir3_free_hdr *hdr3 = (struct xfs_dir3_free_hdr *)from;\r\nto->magic = be32_to_cpu(hdr3->hdr.magic);\r\nto->firstdb = be32_to_cpu(hdr3->firstdb);\r\nto->nvalid = be32_to_cpu(hdr3->nvalid);\r\nto->nused = be32_to_cpu(hdr3->nused);\r\n}\r\nASSERT(to->magic == XFS_DIR2_FREE_MAGIC ||\r\nto->magic == XFS_DIR3_FREE_MAGIC);\r\n}\r\nstatic void\r\nxfs_dir3_free_hdr_to_disk(\r\nstruct xfs_dir2_free *to,\r\nstruct xfs_dir3_icfree_hdr *from)\r\n{\r\nASSERT(from->magic == XFS_DIR2_FREE_MAGIC ||\r\nfrom->magic == XFS_DIR3_FREE_MAGIC);\r\nif (from->magic == XFS_DIR2_FREE_MAGIC) {\r\nto->hdr.magic = cpu_to_be32(from->magic);\r\nto->hdr.firstdb = cpu_to_be32(from->firstdb);\r\nto->hdr.nvalid = cpu_to_be32(from->nvalid);\r\nto->hdr.nused = cpu_to_be32(from->nused);\r\n} else {\r\nstruct xfs_dir3_free_hdr *hdr3 = (struct xfs_dir3_free_hdr *)to;\r\nhdr3->hdr.magic = cpu_to_be32(from->magic);\r\nhdr3->firstdb = cpu_to_be32(from->firstdb);\r\nhdr3->nvalid = cpu_to_be32(from->nvalid);\r\nhdr3->nused = cpu_to_be32(from->nused);\r\n}\r\n}\r\nstatic int\r\nxfs_dir3_free_get_buf(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *dp,\r\nxfs_dir2_db_t fbno,\r\nstruct xfs_buf **bpp)\r\n{\r\nstruct xfs_mount *mp = dp->i_mount;\r\nstruct xfs_buf *bp;\r\nint error;\r\nstruct xfs_dir3_icfree_hdr hdr;\r\nerror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(mp, fbno),\r\n-1, &bp, XFS_DATA_FORK);\r\nif (error)\r\nreturn error;\r\nxfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_FREE_BUF);\r\nbp->b_ops = &xfs_dir3_free_buf_ops;\r\nmemset(bp->b_addr, 0, sizeof(struct xfs_dir3_free_hdr));\r\nmemset(&hdr, 0, sizeof(hdr));\r\nif (xfs_sb_version_hascrc(&mp->m_sb)) {\r\nstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\r\nhdr.magic = XFS_DIR3_FREE_MAGIC;\r\nhdr3->hdr.blkno = cpu_to_be64(bp->b_bn);\r\nhdr3->hdr.owner = cpu_to_be64(dp->i_ino);\r\nuuid_copy(&hdr3->hdr.uuid, &mp->m_sb.sb_uuid);\r\n} else\r\nhdr.magic = XFS_DIR2_FREE_MAGIC;\r\nxfs_dir3_free_hdr_to_disk(bp->b_addr, &hdr);\r\n*bpp = bp;\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_dir2_free_log_bests(\r\nstruct xfs_trans *tp,\r\nstruct xfs_buf *bp,\r\nint first,\r\nint last)\r\n{\r\nxfs_dir2_free_t *free;\r\n__be16 *bests;\r\nfree = bp->b_addr;\r\nbests = xfs_dir3_free_bests_p(tp->t_mountp, free);\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\r\nfree->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\r\nxfs_trans_log_buf(tp, bp,\r\n(uint)((char *)&bests[first] - (char *)free),\r\n(uint)((char *)&bests[last] - (char *)free +\r\nsizeof(bests[0]) - 1));\r\n}\r\nstatic void\r\nxfs_dir2_free_log_header(\r\nstruct xfs_trans *tp,\r\nstruct xfs_buf *bp)\r\n{\r\nxfs_dir2_free_t *free;\r\nfree = bp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\r\nfree->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\r\nxfs_trans_log_buf(tp, bp, 0, xfs_dir3_free_hdr_size(tp->t_mountp) - 1);\r\n}\r\nint\r\nxfs_dir2_leaf_to_node(\r\nxfs_da_args_t *args,\r\nstruct xfs_buf *lbp)\r\n{\r\nxfs_inode_t *dp;\r\nint error;\r\nstruct xfs_buf *fbp;\r\nxfs_dir2_db_t fdb;\r\nxfs_dir2_free_t *free;\r\n__be16 *from;\r\nint i;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_tail_t *ltp;\r\nxfs_mount_t *mp;\r\nint n;\r\nxfs_dir2_data_off_t off;\r\n__be16 *to;\r\nxfs_trans_t *tp;\r\nstruct xfs_dir3_icfree_hdr freehdr;\r\ntrace_xfs_dir2_leaf_to_node(args);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fdb))) {\r\nreturn error;\r\n}\r\nASSERT(fdb == XFS_DIR2_FREE_FIRSTDB(mp));\r\nerror = xfs_dir3_free_get_buf(tp, dp, fdb, &fbp);\r\nif (error)\r\nreturn error;\r\nfree = fbp->b_addr;\r\nxfs_dir3_free_hdr_from_disk(&freehdr, free);\r\nleaf = lbp->b_addr;\r\nltp = xfs_dir2_leaf_tail_p(mp, leaf);\r\nASSERT(be32_to_cpu(ltp->bestcount) <=\r\n(uint)dp->i_d.di_size / mp->m_dirblksize);\r\nfrom = xfs_dir2_leaf_bests_p(ltp);\r\nto = xfs_dir3_free_bests_p(mp, free);\r\nfor (i = n = 0; i < be32_to_cpu(ltp->bestcount); i++, from++, to++) {\r\nif ((off = be16_to_cpu(*from)) != NULLDATAOFF)\r\nn++;\r\n*to = cpu_to_be16(off);\r\n}\r\nfreehdr.nused = n;\r\nfreehdr.nvalid = be32_to_cpu(ltp->bestcount);\r\nxfs_dir3_free_hdr_to_disk(fbp->b_addr, &freehdr);\r\nxfs_dir2_free_log_bests(tp, fbp, 0, freehdr.nvalid - 1);\r\nxfs_dir2_free_log_header(tp, fbp);\r\nif (leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC))\r\nleaf->hdr.info.magic = cpu_to_be16(XFS_DIR2_LEAFN_MAGIC);\r\nelse\r\nleaf->hdr.info.magic = cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\r\nlbp->b_ops = &xfs_dir3_leafn_buf_ops;\r\nxfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAFN_BUF);\r\nxfs_dir3_leaf_log_header(tp, lbp);\r\nxfs_dir3_leaf_check(mp, lbp);\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_dir2_leafn_add(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint index)\r\n{\r\nint compact;\r\nxfs_inode_t *dp;\r\nint highstale;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_entry_t *lep;\r\nint lfloghigh;\r\nint lfloglow;\r\nint lowstale;\r\nxfs_mount_t *mp;\r\nxfs_trans_t *tp;\r\nstruct xfs_dir3_icleaf_hdr leafhdr;\r\nstruct xfs_dir2_leaf_entry *ents;\r\ntrace_xfs_dir2_leafn_add(args, index);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nleaf = bp->b_addr;\r\nxfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nents = xfs_dir3_leaf_ents_p(leaf);\r\nif (index < 0)\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\nif (leafhdr.count == xfs_dir3_max_leaf_ents(mp, leaf)) {\r\nif (!leafhdr.stale)\r\nreturn XFS_ERROR(ENOSPC);\r\ncompact = leafhdr.stale > 1;\r\n} else\r\ncompact = 0;\r\nASSERT(index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval);\r\nASSERT(index == leafhdr.count ||\r\nbe32_to_cpu(ents[index].hashval) >= args->hashval);\r\nif (args->op_flags & XFS_DA_OP_JUSTCHECK)\r\nreturn 0;\r\nif (compact)\r\nxfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\r\n&highstale, &lfloglow, &lfloghigh);\r\nelse if (leafhdr.stale) {\r\nlfloglow = leafhdr.count;\r\nlfloghigh = -1;\r\n}\r\nlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\r\nhighstale, &lfloglow, &lfloghigh);\r\nlep->hashval = cpu_to_be32(args->hashval);\r\nlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(mp,\r\nargs->blkno, args->index));\r\nxfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);\r\nxfs_dir3_leaf_log_header(tp, bp);\r\nxfs_dir3_leaf_log_ents(tp, bp, lfloglow, lfloghigh);\r\nxfs_dir3_leaf_check(mp, bp);\r\nreturn 0;\r\n}\r\nstatic void\r\nxfs_dir2_free_hdr_check(\r\nstruct xfs_mount *mp,\r\nstruct xfs_buf *bp,\r\nxfs_dir2_db_t db)\r\n{\r\nstruct xfs_dir3_icfree_hdr hdr;\r\nxfs_dir3_free_hdr_from_disk(&hdr, bp->b_addr);\r\nASSERT((hdr.firstdb % xfs_dir3_free_max_bests(mp)) == 0);\r\nASSERT(hdr.firstdb <= db);\r\nASSERT(db < hdr.firstdb + hdr.nvalid);\r\n}\r\nxfs_dahash_t\r\nxfs_dir2_leafn_lasthash(\r\nstruct xfs_buf *bp,\r\nint *count)\r\n{\r\nstruct xfs_dir2_leaf *leaf = bp->b_addr;\r\nstruct xfs_dir2_leaf_entry *ents;\r\nstruct xfs_dir3_icleaf_hdr leafhdr;\r\nxfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\r\nleafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\r\nif (count)\r\n*count = leafhdr.count;\r\nif (!leafhdr.count)\r\nreturn 0;\r\nents = xfs_dir3_leaf_ents_p(leaf);\r\nreturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\r\n}\r\nSTATIC int\r\nxfs_dir2_leafn_lookup_for_addname(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint *indexp,\r\nxfs_da_state_t *state)\r\n{\r\nstruct xfs_buf *curbp = NULL;\r\nxfs_dir2_db_t curdb = -1;\r\nxfs_dir2_db_t curfdb = -1;\r\nxfs_inode_t *dp;\r\nint error;\r\nint fi;\r\nxfs_dir2_free_t *free = NULL;\r\nint index;\r\nxfs_dir2_leaf_t *leaf;\r\nint length;\r\nxfs_dir2_leaf_entry_t *lep;\r\nxfs_mount_t *mp;\r\nxfs_dir2_db_t newdb;\r\nxfs_dir2_db_t newfdb;\r\nxfs_trans_t *tp;\r\nstruct xfs_dir2_leaf_entry *ents;\r\nstruct xfs_dir3_icleaf_hdr leafhdr;\r\ndp = args->dp;\r\ntp = args->trans;\r\nmp = dp->i_mount;\r\nleaf = bp->b_addr;\r\nxfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nents = xfs_dir3_leaf_ents_p(leaf);\r\nxfs_dir3_leaf_check(mp, bp);\r\nASSERT(leafhdr.count > 0);\r\nindex = xfs_dir2_leaf_search_hash(args, bp);\r\nif (state->extravalid) {\r\ncurbp = state->extrablk.bp;\r\ncurfdb = state->extrablk.blkno;\r\nfree = curbp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\r\nfree->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\r\n}\r\nlength = xfs_dir2_data_entsize(args->namelen);\r\nfor (lep = &ents[index];\r\nindex < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\r\nlep++, index++) {\r\nif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\r\ncontinue;\r\nnewdb = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));\r\nif (newdb != curdb) {\r\n__be16 *bests;\r\ncurdb = newdb;\r\nnewfdb = xfs_dir2_db_to_fdb(mp, newdb);\r\nif (newfdb != curfdb) {\r\nif (curbp)\r\nxfs_trans_brelse(tp, curbp);\r\nerror = xfs_dir2_free_read(tp, dp,\r\nxfs_dir2_db_to_da(mp, newfdb),\r\n&curbp);\r\nif (error)\r\nreturn error;\r\nfree = curbp->b_addr;\r\nxfs_dir2_free_hdr_check(mp, curbp, curdb);\r\n}\r\nfi = xfs_dir2_db_to_fdindex(mp, curdb);\r\nbests = xfs_dir3_free_bests_p(mp, free);\r\nif (unlikely(bests[fi] == cpu_to_be16(NULLDATAOFF))) {\r\nXFS_ERROR_REPORT("xfs_dir2_leafn_lookup_int",\r\nXFS_ERRLEVEL_LOW, mp);\r\nif (curfdb != newfdb)\r\nxfs_trans_brelse(tp, curbp);\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\ncurfdb = newfdb;\r\nif (be16_to_cpu(bests[fi]) >= length)\r\ngoto out;\r\n}\r\n}\r\nfi = -1;\r\nout:\r\nASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\r\nif (curbp) {\r\nstate->extravalid = 1;\r\nstate->extrablk.bp = curbp;\r\nstate->extrablk.index = fi;\r\nstate->extrablk.blkno = curfdb;\r\nstate->extrablk.magic = XFS_DIR2_FREE_MAGIC;\r\n} else {\r\nstate->extravalid = 0;\r\n}\r\n*indexp = index;\r\nreturn XFS_ERROR(ENOENT);\r\n}\r\nSTATIC int\r\nxfs_dir2_leafn_lookup_for_entry(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint *indexp,\r\nxfs_da_state_t *state)\r\n{\r\nstruct xfs_buf *curbp = NULL;\r\nxfs_dir2_db_t curdb = -1;\r\nxfs_dir2_data_entry_t *dep;\r\nxfs_inode_t *dp;\r\nint error;\r\nint index;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_entry_t *lep;\r\nxfs_mount_t *mp;\r\nxfs_dir2_db_t newdb;\r\nxfs_trans_t *tp;\r\nenum xfs_dacmp cmp;\r\nstruct xfs_dir2_leaf_entry *ents;\r\nstruct xfs_dir3_icleaf_hdr leafhdr;\r\ndp = args->dp;\r\ntp = args->trans;\r\nmp = dp->i_mount;\r\nleaf = bp->b_addr;\r\nxfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nents = xfs_dir3_leaf_ents_p(leaf);\r\nxfs_dir3_leaf_check(mp, bp);\r\nASSERT(leafhdr.count > 0);\r\nindex = xfs_dir2_leaf_search_hash(args, bp);\r\nif (state->extravalid) {\r\ncurbp = state->extrablk.bp;\r\ncurdb = state->extrablk.blkno;\r\n}\r\nfor (lep = &ents[index];\r\nindex < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\r\nlep++, index++) {\r\nif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\r\ncontinue;\r\nnewdb = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));\r\nif (newdb != curdb) {\r\nif (curbp && (args->cmpresult == XFS_CMP_DIFFERENT ||\r\ncurdb != state->extrablk.blkno))\r\nxfs_trans_brelse(tp, curbp);\r\nif (args->cmpresult != XFS_CMP_DIFFERENT &&\r\nnewdb == state->extrablk.blkno) {\r\nASSERT(state->extravalid);\r\ncurbp = state->extrablk.bp;\r\n} else {\r\nerror = xfs_dir3_data_read(tp, dp,\r\nxfs_dir2_db_to_da(mp, newdb),\r\n-1, &curbp);\r\nif (error)\r\nreturn error;\r\n}\r\nxfs_dir3_data_check(dp, curbp);\r\ncurdb = newdb;\r\n}\r\ndep = (xfs_dir2_data_entry_t *)((char *)curbp->b_addr +\r\nxfs_dir2_dataptr_to_off(mp, be32_to_cpu(lep->address)));\r\ncmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\r\nif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\r\nif (args->cmpresult != XFS_CMP_DIFFERENT &&\r\ncurdb != state->extrablk.blkno)\r\nxfs_trans_brelse(tp, state->extrablk.bp);\r\nargs->cmpresult = cmp;\r\nargs->inumber = be64_to_cpu(dep->inumber);\r\n*indexp = index;\r\nstate->extravalid = 1;\r\nstate->extrablk.bp = curbp;\r\nstate->extrablk.blkno = curdb;\r\nstate->extrablk.index = (int)((char *)dep -\r\n(char *)curbp->b_addr);\r\nstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\r\ncurbp->b_ops = &xfs_dir3_data_buf_ops;\r\nxfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\r\nif (cmp == XFS_CMP_EXACT)\r\nreturn XFS_ERROR(EEXIST);\r\n}\r\n}\r\nASSERT(index == leafhdr.count || (args->op_flags & XFS_DA_OP_OKNOENT));\r\nif (curbp) {\r\nif (args->cmpresult == XFS_CMP_DIFFERENT) {\r\nstate->extravalid = 1;\r\nstate->extrablk.bp = curbp;\r\nstate->extrablk.index = -1;\r\nstate->extrablk.blkno = curdb;\r\nstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\r\ncurbp->b_ops = &xfs_dir3_data_buf_ops;\r\nxfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\r\n} else {\r\nif (state->extrablk.bp != curbp)\r\nxfs_trans_brelse(tp, curbp);\r\n}\r\n} else {\r\nstate->extravalid = 0;\r\n}\r\n*indexp = index;\r\nreturn XFS_ERROR(ENOENT);\r\n}\r\nint\r\nxfs_dir2_leafn_lookup_int(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint *indexp,\r\nxfs_da_state_t *state)\r\n{\r\nif (args->op_flags & XFS_DA_OP_ADDNAME)\r\nreturn xfs_dir2_leafn_lookup_for_addname(bp, args, indexp,\r\nstate);\r\nreturn xfs_dir2_leafn_lookup_for_entry(bp, args, indexp, state);\r\n}\r\nstatic void\r\nxfs_dir3_leafn_moveents(\r\nxfs_da_args_t *args,\r\nstruct xfs_buf *bp_s,\r\nstruct xfs_dir3_icleaf_hdr *shdr,\r\nstruct xfs_dir2_leaf_entry *sents,\r\nint start_s,\r\nstruct xfs_buf *bp_d,\r\nstruct xfs_dir3_icleaf_hdr *dhdr,\r\nstruct xfs_dir2_leaf_entry *dents,\r\nint start_d,\r\nint count)\r\n{\r\nstruct xfs_trans *tp = args->trans;\r\nint stale;\r\ntrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\r\nif (count == 0)\r\nreturn;\r\nif (start_d < dhdr->count) {\r\nmemmove(&dents[start_d + count], &dents[start_d],\r\n(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t));\r\nxfs_dir3_leaf_log_ents(tp, bp_d, start_d + count,\r\ncount + dhdr->count - 1);\r\n}\r\nif (shdr->stale) {\r\nint i;\r\nfor (i = start_s, stale = 0; i < start_s + count; i++) {\r\nif (sents[i].address ==\r\ncpu_to_be32(XFS_DIR2_NULL_DATAPTR))\r\nstale++;\r\n}\r\n} else\r\nstale = 0;\r\nmemcpy(&dents[start_d], &sents[start_s],\r\ncount * sizeof(xfs_dir2_leaf_entry_t));\r\nxfs_dir3_leaf_log_ents(tp, bp_d, start_d, start_d + count - 1);\r\nif (start_s + count < shdr->count) {\r\nmemmove(&sents[start_s], &sents[start_s + count],\r\ncount * sizeof(xfs_dir2_leaf_entry_t));\r\nxfs_dir3_leaf_log_ents(tp, bp_s, start_s, start_s + count - 1);\r\n}\r\nshdr->count -= count;\r\nshdr->stale -= stale;\r\ndhdr->count += count;\r\ndhdr->stale += stale;\r\n}\r\nint\r\nxfs_dir2_leafn_order(\r\nstruct xfs_buf *leaf1_bp,\r\nstruct xfs_buf *leaf2_bp)\r\n{\r\nstruct xfs_dir2_leaf *leaf1 = leaf1_bp->b_addr;\r\nstruct xfs_dir2_leaf *leaf2 = leaf2_bp->b_addr;\r\nstruct xfs_dir2_leaf_entry *ents1;\r\nstruct xfs_dir2_leaf_entry *ents2;\r\nstruct xfs_dir3_icleaf_hdr hdr1;\r\nstruct xfs_dir3_icleaf_hdr hdr2;\r\nxfs_dir3_leaf_hdr_from_disk(&hdr1, leaf1);\r\nxfs_dir3_leaf_hdr_from_disk(&hdr2, leaf2);\r\nents1 = xfs_dir3_leaf_ents_p(leaf1);\r\nents2 = xfs_dir3_leaf_ents_p(leaf2);\r\nif (hdr1.count > 0 && hdr2.count > 0 &&\r\n(be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\r\nbe32_to_cpu(ents2[hdr2.count - 1].hashval) <\r\nbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nxfs_dir2_leafn_rebalance(\r\nxfs_da_state_t *state,\r\nxfs_da_state_blk_t *blk1,\r\nxfs_da_state_blk_t *blk2)\r\n{\r\nxfs_da_args_t *args;\r\nint count;\r\nint isleft;\r\nxfs_dir2_leaf_t *leaf1;\r\nxfs_dir2_leaf_t *leaf2;\r\nint mid;\r\n#if defined(DEBUG) || defined(XFS_WARN)\r\nint oldstale;\r\n#endif\r\nint oldsum;\r\nint swap;\r\nstruct xfs_dir2_leaf_entry *ents1;\r\nstruct xfs_dir2_leaf_entry *ents2;\r\nstruct xfs_dir3_icleaf_hdr hdr1;\r\nstruct xfs_dir3_icleaf_hdr hdr2;\r\nargs = state->args;\r\nif ((swap = xfs_dir2_leafn_order(blk1->bp, blk2->bp))) {\r\nxfs_da_state_blk_t *tmp;\r\ntmp = blk1;\r\nblk1 = blk2;\r\nblk2 = tmp;\r\n}\r\nleaf1 = blk1->bp->b_addr;\r\nleaf2 = blk2->bp->b_addr;\r\nxfs_dir3_leaf_hdr_from_disk(&hdr1, leaf1);\r\nxfs_dir3_leaf_hdr_from_disk(&hdr2, leaf2);\r\nents1 = xfs_dir3_leaf_ents_p(leaf1);\r\nents2 = xfs_dir3_leaf_ents_p(leaf2);\r\noldsum = hdr1.count + hdr2.count;\r\n#if defined(DEBUG) || defined(XFS_WARN)\r\noldstale = hdr1.stale + hdr2.stale;\r\n#endif\r\nmid = oldsum >> 1;\r\nif (oldsum & 1) {\r\nxfs_dahash_t midhash;\r\nif (mid >= hdr1.count)\r\nmidhash = be32_to_cpu(ents2[mid - hdr1.count].hashval);\r\nelse\r\nmidhash = be32_to_cpu(ents1[mid].hashval);\r\nisleft = args->hashval <= midhash;\r\n}\r\nelse\r\nisleft = 1;\r\ncount = hdr1.count - mid + (isleft == 0);\r\nif (count > 0)\r\nxfs_dir3_leafn_moveents(args, blk1->bp, &hdr1, ents1,\r\nhdr1.count - count, blk2->bp,\r\n&hdr2, ents2, 0, count);\r\nelse if (count < 0)\r\nxfs_dir3_leafn_moveents(args, blk2->bp, &hdr2, ents2, 0,\r\nblk1->bp, &hdr1, ents1,\r\nhdr1.count, count);\r\nASSERT(hdr1.count + hdr2.count == oldsum);\r\nASSERT(hdr1.stale + hdr2.stale == oldstale);\r\nxfs_dir3_leaf_hdr_to_disk(leaf1, &hdr1);\r\nxfs_dir3_leaf_hdr_to_disk(leaf2, &hdr2);\r\nxfs_dir3_leaf_log_header(args->trans, blk1->bp);\r\nxfs_dir3_leaf_log_header(args->trans, blk2->bp);\r\nxfs_dir3_leaf_check(args->dp->i_mount, blk1->bp);\r\nxfs_dir3_leaf_check(args->dp->i_mount, blk2->bp);\r\nif (hdr1.count < hdr2.count)\r\nstate->inleaf = swap;\r\nelse if (hdr1.count > hdr2.count)\r\nstate->inleaf = !swap;\r\nelse\r\nstate->inleaf = swap ^ (blk1->index <= hdr1.count);\r\nif (!state->inleaf)\r\nblk2->index = blk1->index - hdr1.count;\r\nif(blk2->index < 0) {\r\nstate->inleaf = 1;\r\nblk2->index = 0;\r\nxfs_alert(args->dp->i_mount,\r\n"%s: picked the wrong leaf? reverting original leaf: blk1->index %d\n",\r\n__func__, blk1->index);\r\n}\r\n}\r\nstatic int\r\nxfs_dir3_data_block_free(\r\nxfs_da_args_t *args,\r\nstruct xfs_dir2_data_hdr *hdr,\r\nstruct xfs_dir2_free *free,\r\nxfs_dir2_db_t fdb,\r\nint findex,\r\nstruct xfs_buf *fbp,\r\nint longest)\r\n{\r\nstruct xfs_trans *tp = args->trans;\r\nint logfree = 0;\r\n__be16 *bests;\r\nstruct xfs_dir3_icfree_hdr freehdr;\r\nxfs_dir3_free_hdr_from_disk(&freehdr, free);\r\nbests = xfs_dir3_free_bests_p(tp->t_mountp, free);\r\nif (hdr) {\r\nbests[findex] = cpu_to_be16(longest);\r\nxfs_dir2_free_log_bests(tp, fbp, findex, findex);\r\nreturn 0;\r\n}\r\nfreehdr.nused--;\r\nif (findex == freehdr.nvalid - 1) {\r\nint i;\r\nfor (i = findex - 1; i >= 0; i--) {\r\nif (bests[i] != cpu_to_be16(NULLDATAOFF))\r\nbreak;\r\n}\r\nfreehdr.nvalid = i + 1;\r\nlogfree = 0;\r\n} else {\r\nbests[findex] = cpu_to_be16(NULLDATAOFF);\r\nlogfree = 1;\r\n}\r\nxfs_dir3_free_hdr_to_disk(free, &freehdr);\r\nxfs_dir2_free_log_header(tp, fbp);\r\nif (!freehdr.nused) {\r\nint error;\r\nerror = xfs_dir2_shrink_inode(args, fdb, fbp);\r\nif (error == 0) {\r\nfbp = NULL;\r\nlogfree = 0;\r\n} else if (error != ENOSPC || args->total != 0)\r\nreturn error;\r\n}\r\nif (logfree)\r\nxfs_dir2_free_log_bests(tp, fbp, findex, findex);\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_dir2_leafn_remove(\r\nxfs_da_args_t *args,\r\nstruct xfs_buf *bp,\r\nint index,\r\nxfs_da_state_blk_t *dblk,\r\nint *rval)\r\n{\r\nxfs_dir2_data_hdr_t *hdr;\r\nxfs_dir2_db_t db;\r\nstruct xfs_buf *dbp;\r\nxfs_dir2_data_entry_t *dep;\r\nxfs_inode_t *dp;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_entry_t *lep;\r\nint longest;\r\nint off;\r\nxfs_mount_t *mp;\r\nint needlog;\r\nint needscan;\r\nxfs_trans_t *tp;\r\nstruct xfs_dir2_data_free *bf;\r\nstruct xfs_dir3_icleaf_hdr leafhdr;\r\nstruct xfs_dir2_leaf_entry *ents;\r\ntrace_xfs_dir2_leafn_remove(args, index);\r\ndp = args->dp;\r\ntp = args->trans;\r\nmp = dp->i_mount;\r\nleaf = bp->b_addr;\r\nxfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nents = xfs_dir3_leaf_ents_p(leaf);\r\nlep = &ents[index];\r\ndb = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));\r\nASSERT(dblk->blkno == db);\r\noff = xfs_dir2_dataptr_to_off(mp, be32_to_cpu(lep->address));\r\nASSERT(dblk->index == off);\r\nleafhdr.stale++;\r\nxfs_dir3_leaf_hdr_to_disk(leaf, &leafhdr);\r\nxfs_dir3_leaf_log_header(tp, bp);\r\nlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\r\nxfs_dir3_leaf_log_ents(tp, bp, index, index);\r\ndbp = dblk->bp;\r\nhdr = dbp->b_addr;\r\ndep = (xfs_dir2_data_entry_t *)((char *)hdr + off);\r\nbf = xfs_dir3_data_bestfree_p(hdr);\r\nlongest = be16_to_cpu(bf[0].length);\r\nneedlog = needscan = 0;\r\nxfs_dir2_data_make_free(tp, dbp, off,\r\nxfs_dir2_data_entsize(dep->namelen), &needlog, &needscan);\r\nif (needscan)\r\nxfs_dir2_data_freescan(mp, hdr, &needlog);\r\nif (needlog)\r\nxfs_dir2_data_log_header(tp, dbp);\r\nxfs_dir3_data_check(dp, dbp);\r\nif (longest < be16_to_cpu(bf[0].length)) {\r\nint error;\r\nstruct xfs_buf *fbp;\r\nxfs_dir2_db_t fdb;\r\nint findex;\r\nxfs_dir2_free_t *free;\r\nfdb = xfs_dir2_db_to_fdb(mp, db);\r\nerror = xfs_dir2_free_read(tp, dp, xfs_dir2_db_to_da(mp, fdb),\r\n&fbp);\r\nif (error)\r\nreturn error;\r\nfree = fbp->b_addr;\r\n#ifdef DEBUG\r\n{\r\nstruct xfs_dir3_icfree_hdr freehdr;\r\nxfs_dir3_free_hdr_from_disk(&freehdr, free);\r\nASSERT(freehdr.firstdb == xfs_dir3_free_max_bests(mp) *\r\n(fdb - XFS_DIR2_FREE_FIRSTDB(mp)));\r\n}\r\n#endif\r\nfindex = xfs_dir2_db_to_fdindex(mp, db);\r\nlongest = be16_to_cpu(bf[0].length);\r\nif (longest == mp->m_dirblksize -\r\nxfs_dir3_data_entry_offset(hdr)) {\r\nerror = xfs_dir2_shrink_inode(args, db, dbp);\r\nif (error == 0) {\r\ndblk->bp = NULL;\r\nhdr = NULL;\r\n}\r\nelse if (!(error == ENOSPC && args->total == 0))\r\nreturn error;\r\n}\r\nerror = xfs_dir3_data_block_free(args, hdr, free,\r\nfdb, findex, fbp, longest);\r\nif (error)\r\nreturn error;\r\n}\r\nxfs_dir3_leaf_check(mp, bp);\r\n*rval = (xfs_dir3_leaf_hdr_size(leaf) +\r\n(uint)sizeof(ents[0]) * (leafhdr.count - leafhdr.stale)) <\r\nmp->m_dir_magicpct;\r\nreturn 0;\r\n}\r\nint\r\nxfs_dir2_leafn_split(\r\nxfs_da_state_t *state,\r\nxfs_da_state_blk_t *oldblk,\r\nxfs_da_state_blk_t *newblk)\r\n{\r\nxfs_da_args_t *args;\r\nxfs_dablk_t blkno;\r\nint error;\r\nxfs_mount_t *mp;\r\nargs = state->args;\r\nmp = args->dp->i_mount;\r\nASSERT(args != NULL);\r\nASSERT(oldblk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nerror = xfs_da_grow_inode(args, &blkno);\r\nif (error) {\r\nreturn error;\r\n}\r\nerror = xfs_dir3_leaf_get_buf(args, xfs_dir2_da_to_db(mp, blkno),\r\n&newblk->bp, XFS_DIR2_LEAFN_MAGIC);\r\nif (error)\r\nreturn error;\r\nnewblk->blkno = blkno;\r\nnewblk->magic = XFS_DIR2_LEAFN_MAGIC;\r\nxfs_dir2_leafn_rebalance(state, oldblk, newblk);\r\nerror = xfs_da3_blk_link(state, oldblk, newblk);\r\nif (error) {\r\nreturn error;\r\n}\r\nif (state->inleaf)\r\nerror = xfs_dir2_leafn_add(oldblk->bp, args, oldblk->index);\r\nelse\r\nerror = xfs_dir2_leafn_add(newblk->bp, args, newblk->index);\r\noldblk->hashval = xfs_dir2_leafn_lasthash(oldblk->bp, NULL);\r\nnewblk->hashval = xfs_dir2_leafn_lasthash(newblk->bp, NULL);\r\nxfs_dir3_leaf_check(mp, oldblk->bp);\r\nxfs_dir3_leaf_check(mp, newblk->bp);\r\nreturn error;\r\n}\r\nint\r\nxfs_dir2_leafn_toosmall(\r\nxfs_da_state_t *state,\r\nint *action)\r\n{\r\nxfs_da_state_blk_t *blk;\r\nxfs_dablk_t blkno;\r\nstruct xfs_buf *bp;\r\nint bytes;\r\nint count;\r\nint error;\r\nint forward;\r\nint i;\r\nxfs_dir2_leaf_t *leaf;\r\nint rval;\r\nstruct xfs_dir3_icleaf_hdr leafhdr;\r\nstruct xfs_dir2_leaf_entry *ents;\r\nblk = &state->path.blk[state->path.active - 1];\r\nleaf = blk->bp->b_addr;\r\nxfs_dir3_leaf_hdr_from_disk(&leafhdr, leaf);\r\nents = xfs_dir3_leaf_ents_p(leaf);\r\nxfs_dir3_leaf_check(state->args->dp->i_mount, blk->bp);\r\ncount = leafhdr.count - leafhdr.stale;\r\nbytes = xfs_dir3_leaf_hdr_size(leaf) + count * sizeof(ents[0]);\r\nif (bytes > (state->blocksize >> 1)) {\r\n*action = 0;\r\nreturn 0;\r\n}\r\nif (count == 0) {\r\nforward = (leafhdr.forw != 0);\r\nmemcpy(&state->altpath, &state->path, sizeof(state->path));\r\nerror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\r\n&rval);\r\nif (error)\r\nreturn error;\r\n*action = rval ? 2 : 0;\r\nreturn 0;\r\n}\r\nforward = leafhdr.forw < leafhdr.back;\r\nfor (i = 0, bp = NULL; i < 2; forward = !forward, i++) {\r\nstruct xfs_dir3_icleaf_hdr hdr2;\r\nblkno = forward ? leafhdr.forw : leafhdr.back;\r\nif (blkno == 0)\r\ncontinue;\r\nerror = xfs_dir3_leafn_read(state->args->trans, state->args->dp,\r\nblkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\ncount = leafhdr.count - leafhdr.stale;\r\nbytes = state->blocksize - (state->blocksize >> 2);\r\nleaf = bp->b_addr;\r\nxfs_dir3_leaf_hdr_from_disk(&hdr2, leaf);\r\nents = xfs_dir3_leaf_ents_p(leaf);\r\ncount += hdr2.count - hdr2.stale;\r\nbytes -= count * sizeof(ents[0]);\r\nif (bytes >= 0)\r\nbreak;\r\nxfs_trans_brelse(state->args->trans, bp);\r\n}\r\nif (i >= 2) {\r\n*action = 0;\r\nreturn 0;\r\n}\r\nmemcpy(&state->altpath, &state->path, sizeof(state->path));\r\nif (blkno < blk->blkno)\r\nerror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\r\n&rval);\r\nelse\r\nerror = xfs_da3_path_shift(state, &state->path, forward, 0,\r\n&rval);\r\nif (error) {\r\nreturn error;\r\n}\r\n*action = rval ? 0 : 1;\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_dir2_leafn_unbalance(\r\nxfs_da_state_t *state,\r\nxfs_da_state_blk_t *drop_blk,\r\nxfs_da_state_blk_t *save_blk)\r\n{\r\nxfs_da_args_t *args;\r\nxfs_dir2_leaf_t *drop_leaf;\r\nxfs_dir2_leaf_t *save_leaf;\r\nstruct xfs_dir3_icleaf_hdr savehdr;\r\nstruct xfs_dir3_icleaf_hdr drophdr;\r\nstruct xfs_dir2_leaf_entry *sents;\r\nstruct xfs_dir2_leaf_entry *dents;\r\nargs = state->args;\r\nASSERT(drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nASSERT(save_blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\ndrop_leaf = drop_blk->bp->b_addr;\r\nsave_leaf = save_blk->bp->b_addr;\r\nxfs_dir3_leaf_hdr_from_disk(&savehdr, save_leaf);\r\nxfs_dir3_leaf_hdr_from_disk(&drophdr, drop_leaf);\r\nsents = xfs_dir3_leaf_ents_p(save_leaf);\r\ndents = xfs_dir3_leaf_ents_p(drop_leaf);\r\nif (drophdr.stale)\r\nxfs_dir3_leaf_compact(args, &drophdr, drop_blk->bp);\r\nif (savehdr.stale)\r\nxfs_dir3_leaf_compact(args, &savehdr, save_blk->bp);\r\ndrop_blk->hashval = be32_to_cpu(dents[drophdr.count - 1].hashval);\r\nif (xfs_dir2_leafn_order(save_blk->bp, drop_blk->bp))\r\nxfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\r\nsave_blk->bp, &savehdr, sents, 0,\r\ndrophdr.count);\r\nelse\r\nxfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\r\nsave_blk->bp, &savehdr, sents,\r\nsavehdr.count, drophdr.count);\r\nsave_blk->hashval = be32_to_cpu(sents[savehdr.count - 1].hashval);\r\nxfs_dir3_leaf_hdr_to_disk(save_leaf, &savehdr);\r\nxfs_dir3_leaf_hdr_to_disk(drop_leaf, &drophdr);\r\nxfs_dir3_leaf_log_header(args->trans, save_blk->bp);\r\nxfs_dir3_leaf_log_header(args->trans, drop_blk->bp);\r\nxfs_dir3_leaf_check(args->dp->i_mount, save_blk->bp);\r\nxfs_dir3_leaf_check(args->dp->i_mount, drop_blk->bp);\r\n}\r\nint\r\nxfs_dir2_node_addname(\r\nxfs_da_args_t *args)\r\n{\r\nxfs_da_state_blk_t *blk;\r\nint error;\r\nint rval;\r\nxfs_da_state_t *state;\r\ntrace_xfs_dir2_node_addname(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_dirblksize;\r\nstate->node_ents = state->mp->m_dir_node_ents;\r\nerror = xfs_da3_node_lookup_int(state, &rval);\r\nif (error)\r\nrval = error;\r\nif (rval != ENOENT) {\r\ngoto done;\r\n}\r\nrval = xfs_dir2_node_addname_int(args,\r\nstate->extravalid ? &state->extrablk : NULL);\r\nif (rval) {\r\ngoto done;\r\n}\r\nblk = &state->path.blk[state->path.active - 1];\r\nASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nrval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\r\nif (rval == 0) {\r\nif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\r\nxfs_da3_fixhashpath(state, &state->path);\r\n} else {\r\nif (args->total == 0) {\r\nASSERT(rval == ENOSPC);\r\ngoto done;\r\n}\r\nrval = xfs_da3_split(state);\r\n}\r\ndone:\r\nxfs_da_state_free(state);\r\nreturn rval;\r\n}\r\nstatic int\r\nxfs_dir2_node_addname_int(\r\nxfs_da_args_t *args,\r\nxfs_da_state_blk_t *fblk)\r\n{\r\nxfs_dir2_data_hdr_t *hdr;\r\nxfs_dir2_db_t dbno;\r\nstruct xfs_buf *dbp;\r\nxfs_dir2_data_entry_t *dep;\r\nxfs_inode_t *dp;\r\nxfs_dir2_data_unused_t *dup;\r\nint error;\r\nxfs_dir2_db_t fbno;\r\nstruct xfs_buf *fbp;\r\nint findex;\r\nxfs_dir2_free_t *free=NULL;\r\nxfs_dir2_db_t ifbno;\r\nxfs_dir2_db_t lastfbno=0;\r\nint length;\r\nint logfree;\r\nxfs_mount_t *mp;\r\nint needlog;\r\nint needscan;\r\n__be16 *tagp;\r\nxfs_trans_t *tp;\r\n__be16 *bests;\r\nstruct xfs_dir3_icfree_hdr freehdr;\r\nstruct xfs_dir2_data_free *bf;\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nlength = xfs_dir2_data_entsize(args->namelen);\r\nif (fblk) {\r\nfbp = fblk->bp;\r\nifbno = fblk->blkno;\r\nfree = fbp->b_addr;\r\nfindex = fblk->index;\r\nbests = xfs_dir3_free_bests_p(mp, free);\r\nxfs_dir3_free_hdr_from_disk(&freehdr, free);\r\nif (findex >= 0) {\r\nASSERT(findex < freehdr.nvalid);\r\nASSERT(be16_to_cpu(bests[findex]) != NULLDATAOFF);\r\nASSERT(be16_to_cpu(bests[findex]) >= length);\r\ndbno = freehdr.firstdb + findex;\r\n} else {\r\ndbno = -1;\r\nfindex = 0;\r\n}\r\n} else {\r\nifbno = dbno = -1;\r\nfbp = NULL;\r\nfindex = 0;\r\n}\r\nif (dbno == -1) {\r\nxfs_fileoff_t fo;\r\nif ((error = xfs_bmap_last_offset(tp, dp, &fo, XFS_DATA_FORK)))\r\nreturn error;\r\nlastfbno = xfs_dir2_da_to_db(mp, (xfs_dablk_t)fo);\r\nfbno = ifbno;\r\n}\r\nwhile (dbno == -1) {\r\nif (fbp == NULL) {\r\nif (++fbno == 0)\r\nfbno = XFS_DIR2_FREE_FIRSTDB(mp);\r\nif (fbno == ifbno)\r\nfbno++;\r\nif (fbno >= lastfbno)\r\nbreak;\r\nerror = xfs_dir2_free_try_read(tp, dp,\r\nxfs_dir2_db_to_da(mp, fbno),\r\n&fbp);\r\nif (error)\r\nreturn error;\r\nif (!fbp)\r\ncontinue;\r\nfree = fbp->b_addr;\r\nfindex = 0;\r\n}\r\nbests = xfs_dir3_free_bests_p(mp, free);\r\nxfs_dir3_free_hdr_from_disk(&freehdr, free);\r\nif (be16_to_cpu(bests[findex]) != NULLDATAOFF &&\r\nbe16_to_cpu(bests[findex]) >= length)\r\ndbno = freehdr.firstdb + findex;\r\nelse {\r\nif (++findex == freehdr.nvalid) {\r\nxfs_trans_brelse(tp, fbp);\r\nfbp = NULL;\r\nif (fblk && fblk->bp)\r\nfblk->bp = NULL;\r\n}\r\n}\r\n}\r\nif (unlikely(dbno == -1)) {\r\nif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\r\nreturn XFS_ERROR(ENOSPC);\r\nif (unlikely((error = xfs_dir2_grow_inode(args,\r\nXFS_DIR2_DATA_SPACE,\r\n&dbno)) ||\r\n(error = xfs_dir3_data_init(args, dbno, &dbp))))\r\nreturn error;\r\nif (fbp)\r\nxfs_trans_brelse(tp, fbp);\r\nif (fblk && fblk->bp)\r\nfblk->bp = NULL;\r\nfbno = xfs_dir2_db_to_fdb(mp, dbno);\r\nerror = xfs_dir2_free_try_read(tp, dp,\r\nxfs_dir2_db_to_da(mp, fbno),\r\n&fbp);\r\nif (error)\r\nreturn error;\r\nif (!fbp) {\r\nerror = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE,\r\n&fbno);\r\nif (error)\r\nreturn error;\r\nif (unlikely(xfs_dir2_db_to_fdb(mp, dbno) != fbno)) {\r\nxfs_alert(mp,\r\n"%s: dir ino %llu needed freesp block %lld for\n"\r\n" data block %lld, got %lld ifbno %llu lastfbno %d",\r\n__func__, (unsigned long long)dp->i_ino,\r\n(long long)xfs_dir2_db_to_fdb(mp, dbno),\r\n(long long)dbno, (long long)fbno,\r\n(unsigned long long)ifbno, lastfbno);\r\nif (fblk) {\r\nxfs_alert(mp,\r\n" fblk 0x%p blkno %llu index %d magic 0x%x",\r\nfblk,\r\n(unsigned long long)fblk->blkno,\r\nfblk->index,\r\nfblk->magic);\r\n} else {\r\nxfs_alert(mp, " ... fblk is NULL");\r\n}\r\nXFS_ERROR_REPORT("xfs_dir2_node_addname_int",\r\nXFS_ERRLEVEL_LOW, mp);\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\nerror = xfs_dir3_free_get_buf(tp, dp, fbno, &fbp);\r\nif (error)\r\nreturn error;\r\nfree = fbp->b_addr;\r\nbests = xfs_dir3_free_bests_p(mp, free);\r\nxfs_dir3_free_hdr_from_disk(&freehdr, free);\r\nfreehdr.firstdb = (fbno - XFS_DIR2_FREE_FIRSTDB(mp)) *\r\nxfs_dir3_free_max_bests(mp);\r\n} else {\r\nfree = fbp->b_addr;\r\nbests = xfs_dir3_free_bests_p(mp, free);\r\nxfs_dir3_free_hdr_from_disk(&freehdr, free);\r\n}\r\nfindex = xfs_dir2_db_to_fdindex(mp, dbno);\r\nif (findex >= freehdr.nvalid) {\r\nASSERT(findex < xfs_dir3_free_max_bests(mp));\r\nfreehdr.nvalid = findex + 1;\r\nbests[findex] = cpu_to_be16(NULLDATAOFF);\r\n}\r\nif (bests[findex] == cpu_to_be16(NULLDATAOFF)) {\r\nfreehdr.nused++;\r\nxfs_dir3_free_hdr_to_disk(fbp->b_addr, &freehdr);\r\nxfs_dir2_free_log_header(tp, fbp);\r\n}\r\nhdr = dbp->b_addr;\r\nbf = xfs_dir3_data_bestfree_p(hdr);\r\nbests[findex] = bf[0].length;\r\nlogfree = 1;\r\n}\r\nelse {\r\nif (args->op_flags & XFS_DA_OP_JUSTCHECK)\r\nreturn 0;\r\nerror = xfs_dir3_data_read(tp, dp, xfs_dir2_db_to_da(mp, dbno),\r\n-1, &dbp);\r\nif (error)\r\nreturn error;\r\nhdr = dbp->b_addr;\r\nbf = xfs_dir3_data_bestfree_p(hdr);\r\nlogfree = 0;\r\n}\r\nASSERT(be16_to_cpu(bf[0].length) >= length);\r\ndup = (xfs_dir2_data_unused_t *)\r\n((char *)hdr + be16_to_cpu(bf[0].offset));\r\nneedscan = needlog = 0;\r\nxfs_dir2_data_use_free(tp, dbp, dup,\r\n(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\r\n&needlog, &needscan);\r\ndep = (xfs_dir2_data_entry_t *)dup;\r\ndep->inumber = cpu_to_be64(args->inumber);\r\ndep->namelen = args->namelen;\r\nmemcpy(dep->name, args->name, dep->namelen);\r\ntagp = xfs_dir2_data_entry_tag_p(dep);\r\n*tagp = cpu_to_be16((char *)dep - (char *)hdr);\r\nxfs_dir2_data_log_entry(tp, dbp, dep);\r\nif (needscan)\r\nxfs_dir2_data_freescan(mp, hdr, &needlog);\r\nif (needlog)\r\nxfs_dir2_data_log_header(tp, dbp);\r\nbests = xfs_dir3_free_bests_p(mp, free);\r\nif (be16_to_cpu(bests[findex]) != be16_to_cpu(bf[0].length)) {\r\nbests[findex] = bf[0].length;\r\nlogfree = 1;\r\n}\r\nif (logfree)\r\nxfs_dir2_free_log_bests(tp, fbp, findex, findex);\r\nargs->blkno = (xfs_dablk_t)dbno;\r\nargs->index = be16_to_cpu(*tagp);\r\nreturn 0;\r\n}\r\nint\r\nxfs_dir2_node_lookup(\r\nxfs_da_args_t *args)\r\n{\r\nint error;\r\nint i;\r\nint rval;\r\nxfs_da_state_t *state;\r\ntrace_xfs_dir2_node_lookup(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_dirblksize;\r\nstate->node_ents = state->mp->m_dir_node_ents;\r\nerror = xfs_da3_node_lookup_int(state, &rval);\r\nif (error)\r\nrval = error;\r\nelse if (rval == ENOENT && args->cmpresult == XFS_CMP_CASE) {\r\nxfs_dir2_data_entry_t *dep;\r\ndep = (xfs_dir2_data_entry_t *)\r\n((char *)state->extrablk.bp->b_addr +\r\nstate->extrablk.index);\r\nrval = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\r\n}\r\nfor (i = 0; i < state->path.active; i++) {\r\nxfs_trans_brelse(args->trans, state->path.blk[i].bp);\r\nstate->path.blk[i].bp = NULL;\r\n}\r\nif (state->extravalid && state->extrablk.bp) {\r\nxfs_trans_brelse(args->trans, state->extrablk.bp);\r\nstate->extrablk.bp = NULL;\r\n}\r\nxfs_da_state_free(state);\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir2_node_removename(\r\nxfs_da_args_t *args)\r\n{\r\nxfs_da_state_blk_t *blk;\r\nint error;\r\nint rval;\r\nxfs_da_state_t *state;\r\ntrace_xfs_dir2_node_removename(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_dirblksize;\r\nstate->node_ents = state->mp->m_dir_node_ents;\r\nerror = xfs_da3_node_lookup_int(state, &rval);\r\nif (error)\r\nrval = error;\r\nif (rval != EEXIST) {\r\nxfs_da_state_free(state);\r\nreturn rval;\r\n}\r\nblk = &state->path.blk[state->path.active - 1];\r\nASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nASSERT(state->extravalid);\r\nerror = xfs_dir2_leafn_remove(args, blk->bp, blk->index,\r\n&state->extrablk, &rval);\r\nif (error)\r\nreturn error;\r\nxfs_da3_fixhashpath(state, &state->path);\r\nif (rval && state->path.active > 1)\r\nerror = xfs_da3_join(state);\r\nif (!error)\r\nerror = xfs_dir2_node_to_leaf(state);\r\nxfs_da_state_free(state);\r\nreturn error;\r\n}\r\nint\r\nxfs_dir2_node_replace(\r\nxfs_da_args_t *args)\r\n{\r\nxfs_da_state_blk_t *blk;\r\nxfs_dir2_data_hdr_t *hdr;\r\nxfs_dir2_data_entry_t *dep;\r\nint error;\r\nint i;\r\nxfs_ino_t inum;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_entry_t *lep;\r\nint rval;\r\nxfs_da_state_t *state;\r\ntrace_xfs_dir2_node_replace(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_dirblksize;\r\nstate->node_ents = state->mp->m_dir_node_ents;\r\ninum = args->inumber;\r\nerror = xfs_da3_node_lookup_int(state, &rval);\r\nif (error) {\r\nrval = error;\r\n}\r\nif (rval == EEXIST) {\r\nstruct xfs_dir2_leaf_entry *ents;\r\nblk = &state->path.blk[state->path.active - 1];\r\nASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nleaf = blk->bp->b_addr;\r\nents = xfs_dir3_leaf_ents_p(leaf);\r\nlep = &ents[blk->index];\r\nASSERT(state->extravalid);\r\nhdr = state->extrablk.bp->b_addr;\r\nASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\r\nhdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\r\ndep = (xfs_dir2_data_entry_t *)\r\n((char *)hdr +\r\nxfs_dir2_dataptr_to_off(state->mp, be32_to_cpu(lep->address)));\r\nASSERT(inum != be64_to_cpu(dep->inumber));\r\ndep->inumber = cpu_to_be64(inum);\r\nxfs_dir2_data_log_entry(args->trans, state->extrablk.bp, dep);\r\nrval = 0;\r\n}\r\nelse if (state->extravalid) {\r\nxfs_trans_brelse(args->trans, state->extrablk.bp);\r\nstate->extrablk.bp = NULL;\r\n}\r\nfor (i = 0; i < state->path.active; i++) {\r\nxfs_trans_brelse(args->trans, state->path.blk[i].bp);\r\nstate->path.blk[i].bp = NULL;\r\n}\r\nxfs_da_state_free(state);\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir2_node_trim_free(\r\nxfs_da_args_t *args,\r\nxfs_fileoff_t fo,\r\nint *rvalp)\r\n{\r\nstruct xfs_buf *bp;\r\nxfs_inode_t *dp;\r\nint error;\r\nxfs_dir2_free_t *free;\r\nxfs_mount_t *mp;\r\nxfs_trans_t *tp;\r\nstruct xfs_dir3_icfree_hdr freehdr;\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nerror = xfs_dir2_free_try_read(tp, dp, fo, &bp);\r\nif (error)\r\nreturn error;\r\nif (!bp)\r\nreturn 0;\r\nfree = bp->b_addr;\r\nxfs_dir3_free_hdr_from_disk(&freehdr, free);\r\nif (freehdr.nused > 0) {\r\nxfs_trans_brelse(tp, bp);\r\n*rvalp = 0;\r\nreturn 0;\r\n}\r\nif ((error =\r\nxfs_dir2_shrink_inode(args, xfs_dir2_da_to_db(mp, (xfs_dablk_t)fo),\r\nbp))) {\r\nASSERT(error != ENOSPC);\r\nxfs_trans_brelse(tp, bp);\r\nreturn error;\r\n}\r\n*rvalp = 1;\r\nreturn 0;\r\n}
