static void mn10300_serial_mask_ack(unsigned int irq)\r\n{\r\nunsigned long flags;\r\nu16 tmp;\r\nflags = arch_local_cli_save();\r\nGxICR(irq) = GxICR_LEVEL_6;\r\ntmp = GxICR(irq);\r\narch_local_irq_restore(flags);\r\n}\r\nstatic void mn10300_serial_chip_mask_ack(struct irq_data *d)\r\n{\r\nmn10300_serial_mask_ack(d->irq);\r\n}\r\nstatic void mn10300_serial_nop(struct irq_data *d)\r\n{\r\n}\r\nstatic void mn10300_serial_low_mask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nu16 tmp;\r\nflags = arch_local_cli_save();\r\nGxICR(d->irq) = NUM2GxICR_LEVEL(CONFIG_MN10300_SERIAL_IRQ_LEVEL);\r\ntmp = GxICR(d->irq);\r\narch_local_irq_restore(flags);\r\n}\r\nstatic void mn10300_serial_low_unmask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nu16 tmp;\r\nflags = arch_local_cli_save();\r\nGxICR(d->irq) =\r\nNUM2GxICR_LEVEL(CONFIG_MN10300_SERIAL_IRQ_LEVEL) | GxICR_ENABLE;\r\ntmp = GxICR(d->irq);\r\narch_local_irq_restore(flags);\r\n}\r\nstatic void mn10300_serial_dis_tx_intr(struct mn10300_serial_port *port)\r\n{\r\nint retries = 100;\r\nu16 x;\r\nif (!mn10300_serial_int_tbl[port->tx_irq].port)\r\nreturn;\r\nport->tx_flags |= MNSCx_TX_STOP;\r\nmb();\r\nwhile ((*port->tx_icr & GxICR_ENABLE) && retries-- > 0)\r\n;\r\nif (retries <= 0) {\r\n*port->tx_icr =\r\nNUM2GxICR_LEVEL(CONFIG_MN10300_SERIAL_IRQ_LEVEL);\r\nx = *port->tx_icr;\r\n}\r\n}\r\nstatic void mn10300_serial_en_tx_intr(struct mn10300_serial_port *port)\r\n{\r\nu16 x;\r\nif (!mn10300_serial_int_tbl[port->tx_irq].port)\r\nreturn;\r\nif (!(port->tx_flags & MNSCx_TX_STOP))\r\nmn10300_serial_dis_tx_intr(port);\r\nport->tx_flags &= ~MNSCx_TX_STOP;\r\nmb();\r\n*port->tx_icr =\r\nNUM2GxICR_LEVEL(CONFIG_MN10300_SERIAL_IRQ_LEVEL) |\r\nGxICR_ENABLE | GxICR_REQUEST | GxICR_DETECT;\r\nx = *port->tx_icr;\r\n}\r\nstatic void mn10300_serial_dis_rx_intr(struct mn10300_serial_port *port)\r\n{\r\nunsigned long flags;\r\nu16 x;\r\nflags = arch_local_cli_save();\r\n*port->rx_icr = NUM2GxICR_LEVEL(CONFIG_MN10300_SERIAL_IRQ_LEVEL);\r\nx = *port->rx_icr;\r\narch_local_irq_restore(flags);\r\n}\r\nstatic int mask_test_and_clear(volatile u8 *ptr, u8 mask)\r\n{\r\nu32 epsw;\r\nasm volatile(" bclr %1,(%2) \n"\r\n" mov epsw,%0 \n"\r\n: "=d"(epsw) : "d"(mask), "a"(ptr)\r\n: "cc", "memory");\r\nreturn !(epsw & EPSW_FLAG_Z);\r\n}\r\nstatic void mn10300_serial_receive_interrupt(struct mn10300_serial_port *port)\r\n{\r\nstruct uart_icount *icount = &port->uart.icount;\r\nstruct tty_port *tport = &port->uart.state->port;\r\nunsigned ix;\r\nint count;\r\nu8 st, ch, push, status, overrun;\r\n_enter("%s", port->name);\r\npush = 0;\r\ncount = CIRC_CNT(port->rx_inp, port->rx_outp, MNSC_BUFFER_SIZE);\r\ncount = tty_buffer_request_room(tport, count);\r\nif (count == 0) {\r\nif (!tport->low_latency)\r\ntty_flip_buffer_push(tport);\r\nreturn;\r\n}\r\ntry_again:\r\nix = ACCESS_ONCE(port->rx_outp);\r\nif (CIRC_CNT(port->rx_inp, ix, MNSC_BUFFER_SIZE) == 0) {\r\nif (push && !tport->low_latency)\r\ntty_flip_buffer_push(tport);\r\nreturn;\r\n}\r\nsmp_read_barrier_depends();\r\nch = port->rx_buffer[ix++];\r\nst = port->rx_buffer[ix++];\r\nsmp_mb();\r\nport->rx_outp = ix & (MNSC_BUFFER_SIZE - 1);\r\nport->uart.icount.rx++;\r\nst &= SC01STR_FEF | SC01STR_PEF | SC01STR_OEF;\r\nstatus = 0;\r\noverrun = 0;\r\nswitch (port->rx_brk) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nif (st & SC01STR_FEF && ch == 0) {\r\nport->rx_brk = 2;\r\ngoto try_again;\r\n}\r\ngoto not_break;\r\ncase 2:\r\nif (st & SC01STR_FEF && ch == 0) {\r\nport->rx_brk = 3;\r\n_proto("Rx Break Detected");\r\nicount->brk++;\r\nif (uart_handle_break(&port->uart))\r\ngoto ignore_char;\r\nstatus |= 1 << TTY_BREAK;\r\ngoto insert;\r\n}\r\ngoto not_break;\r\ndefault:\r\nif (st & (SC01STR_FEF | SC01STR_PEF | SC01STR_OEF))\r\ngoto try_again;\r\nport->rx_brk = 0;\r\nswitch (ch) {\r\ncase 0xFF:\r\ncase 0xFE:\r\ncase 0xFC:\r\ncase 0xF8:\r\ncase 0xF0:\r\ncase 0xE0:\r\ncase 0xC0:\r\ncase 0x80:\r\ncase 0x00:\r\ngoto try_again;\r\n}\r\nbreak;\r\n}\r\nprocess_errors:\r\nif (st & SC01STR_FEF) {\r\nif (ch == 0) {\r\nport->rx_brk = 1;\r\ngoto try_again;\r\n}\r\n_proto("Rx Framing Error");\r\nicount->frame++;\r\nstatus |= 1 << TTY_FRAME;\r\n}\r\nif (st & SC01STR_PEF) {\r\n_proto("Rx Parity Error");\r\nicount->parity++;\r\nstatus = TTY_PARITY;\r\n}\r\nif (status == 0) {\r\nif (uart_handle_sysrq_char(&port->uart, ch))\r\ngoto ignore_char;\r\nstatus = (1 << TTY_NORMAL);\r\n}\r\nif (st & SC01STR_OEF) {\r\nif (port->rx_brk)\r\ngoto try_again;\r\n_proto("Rx Overrun Error");\r\nicount->overrun++;\r\noverrun = 1;\r\n}\r\ninsert:\r\nstatus &= port->uart.read_status_mask;\r\nif (!overrun && !(status & port->uart.ignore_status_mask)) {\r\nint flag;\r\nif (status & (1 << TTY_BREAK))\r\nflag = TTY_BREAK;\r\nelse if (status & (1 << TTY_PARITY))\r\nflag = TTY_PARITY;\r\nelse if (status & (1 << TTY_FRAME))\r\nflag = TTY_FRAME;\r\nelse\r\nflag = TTY_NORMAL;\r\ntty_insert_flip_char(tport, ch, flag);\r\n}\r\nif (overrun)\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\ncount--;\r\nif (count <= 0) {\r\nif (!tport->low_latency)\r\ntty_flip_buffer_push(tport);\r\nreturn;\r\n}\r\nignore_char:\r\npush = 1;\r\ngoto try_again;\r\nnot_break:\r\nport->rx_brk = 0;\r\ngoto process_errors;\r\n}\r\nstatic void mn10300_serial_transmit_interrupt(struct mn10300_serial_port *port)\r\n{\r\n_enter("%s", port->name);\r\nif (!port->uart.state || !port->uart.state->port.tty) {\r\nmn10300_serial_dis_tx_intr(port);\r\nreturn;\r\n}\r\nif (uart_tx_stopped(&port->uart) ||\r\nuart_circ_empty(&port->uart.state->xmit))\r\nmn10300_serial_dis_tx_intr(port);\r\nif (uart_circ_chars_pending(&port->uart.state->xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&port->uart);\r\n}\r\nstatic void mn10300_serial_cts_changed(struct mn10300_serial_port *port, u8 st)\r\n{\r\nu16 ctr;\r\nport->tx_cts = st;\r\nport->uart.icount.cts++;\r\nctr = *port->_control;\r\nctr ^= SC2CTR_TWS;\r\n*port->_control = ctr;\r\nuart_handle_cts_change(&port->uart, st & SC2STR_CTS);\r\nwake_up_interruptible(&port->uart.state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t mn10300_serial_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mn10300_serial_port *port = dev_id;\r\nu8 st;\r\nspin_lock(&port->uart.lock);\r\nif (port->intr_flags) {\r\n_debug("INT %s: %x", port->name, port->intr_flags);\r\nif (mask_test_and_clear(&port->intr_flags, MNSCx_RX_AVAIL))\r\nmn10300_serial_receive_interrupt(port);\r\nif (mask_test_and_clear(&port->intr_flags,\r\nMNSCx_TX_SPACE | MNSCx_TX_EMPTY))\r\nmn10300_serial_transmit_interrupt(port);\r\n}\r\nif (port->type == PORT_MN10300_CTS) {\r\nst = *port->_status;\r\nif ((port->tx_cts ^ st) & SC2STR_CTS)\r\nmn10300_serial_cts_changed(port, st);\r\n}\r\nspin_unlock(&port->uart.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int mn10300_serial_tx_empty(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s", port->name);\r\nreturn (*port->_status & (SC01STR_TXF | SC01STR_TBF)) ?\r\n0 : TIOCSER_TEMT;\r\n}\r\nstatic void mn10300_serial_set_mctrl(struct uart_port *_port,\r\nunsigned int mctrl)\r\n{\r\nstruct mn10300_serial_port *port __attribute__ ((unused)) =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s,%x", port->name, mctrl);\r\n}\r\nstatic unsigned int mn10300_serial_get_mctrl(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s", port->name);\r\nif (port->type == PORT_MN10300_CTS && !(*port->_status & SC2STR_CTS))\r\nreturn TIOCM_CAR | TIOCM_DSR;\r\nreturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR;\r\n}\r\nstatic void mn10300_serial_stop_tx(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s", port->name);\r\nmn10300_serial_dis_tx_intr(port);\r\n}\r\nstatic void mn10300_serial_start_tx(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s{%lu}",\r\nport->name,\r\nCIRC_CNT(&port->uart.state->xmit.head,\r\n&port->uart.state->xmit.tail,\r\nUART_XMIT_SIZE));\r\nmn10300_serial_en_tx_intr(port);\r\n_debug("CTR=%04hx ICR=%02hx STR=%04x TMD=%02hx TBR=%04hx ICR=%04hx",\r\n*port->_control, *port->_intr, *port->_status,\r\n*port->_tmxmd,\r\n(port->div_timer == MNSCx_DIV_TIMER_8BIT) ?\r\n*(volatile u8 *)port->_tmxbr : *port->_tmxbr,\r\n*port->tx_icr);\r\n}\r\nstatic void mn10300_serial_send_xchar(struct uart_port *_port, char ch)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nunsigned long flags;\r\n_enter("%s,%02x", port->name, ch);\r\nif (likely(port->gdbstub)) {\r\nport->tx_xchar = ch;\r\nif (ch) {\r\nspin_lock_irqsave(&port->uart.lock, flags);\r\nmn10300_serial_en_tx_intr(port);\r\nspin_unlock_irqrestore(&port->uart.lock, flags);\r\n}\r\n}\r\n}\r\nstatic void mn10300_serial_stop_rx(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nu16 ctr;\r\n_enter("%s", port->name);\r\nctr = *port->_control;\r\nctr &= ~SC01CTR_RXE;\r\n*port->_control = ctr;\r\nmn10300_serial_dis_rx_intr(port);\r\n}\r\nstatic void mn10300_serial_enable_ms(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nu16 ctr, cts;\r\n_enter("%s", port->name);\r\nif (port->type == PORT_MN10300_CTS) {\r\nport->tx_cts = *port->_status;\r\ncts = (port->tx_cts & SC2STR_CTS) ?\r\nSC2CTR_TWE : SC2CTR_TWE | SC2CTR_TWS;\r\nctr = *port->_control;\r\nctr &= ~SC2CTR_TWS;\r\nctr |= cts;\r\n*port->_control = ctr;\r\nmn10300_serial_en_tx_intr(port);\r\n}\r\n}\r\nstatic void mn10300_serial_break_ctl(struct uart_port *_port, int ctl)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nunsigned long flags;\r\n_enter("%s,%d", port->name, ctl);\r\nspin_lock_irqsave(&port->uart.lock, flags);\r\nif (ctl) {\r\nport->tx_flags |= MNSCx_TX_BREAK;\r\nmn10300_serial_en_tx_intr(port);\r\n} else {\r\nport->tx_flags &= ~MNSCx_TX_BREAK;\r\n*port->_control &= ~SC01CTR_BKE;\r\nmn10300_serial_en_tx_intr(port);\r\n}\r\nspin_unlock_irqrestore(&port->uart.lock, flags);\r\n}\r\nstatic int mn10300_serial_startup(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nstruct mn10300_serial_int *pint;\r\n_enter("%s{%d}", port->name, port->gdbstub);\r\nif (unlikely(port->gdbstub))\r\nreturn -EBUSY;\r\nport->rx_buffer = kmalloc(MNSC_BUFFER_SIZE, GFP_KERNEL);\r\nif (!port->rx_buffer)\r\nreturn -ENOMEM;\r\nport->rx_inp = port->rx_outp = 0;\r\nport->tx_flags = 0;\r\n*port->_intr = SC01ICR_TI;\r\n*port->_control |= SC01CTR_TXE | SC01CTR_RXE;\r\npint = &mn10300_serial_int_tbl[port->rx_irq];\r\npint->port = port;\r\npint->vdma = mn10300_serial_vdma_rx_handler;\r\npint = &mn10300_serial_int_tbl[port->tx_irq];\r\npint->port = port;\r\npint->vdma = mn10300_serial_vdma_tx_handler;\r\nirq_set_chip(port->rx_irq, &mn10300_serial_low_pic);\r\nirq_set_chip(port->tx_irq, &mn10300_serial_low_pic);\r\nirq_set_chip(port->tm_irq, &mn10300_serial_pic);\r\nif (request_irq(port->rx_irq, mn10300_serial_interrupt,\r\nIRQF_DISABLED | IRQF_NOBALANCING,\r\nport->rx_name, port) < 0)\r\ngoto error;\r\nif (request_irq(port->tx_irq, mn10300_serial_interrupt,\r\nIRQF_DISABLED | IRQF_NOBALANCING,\r\nport->tx_name, port) < 0)\r\ngoto error2;\r\nif (request_irq(port->tm_irq, mn10300_serial_interrupt,\r\nIRQF_DISABLED | IRQF_NOBALANCING,\r\nport->tm_name, port) < 0)\r\ngoto error3;\r\nmn10300_serial_mask_ack(port->tm_irq);\r\nreturn 0;\r\nerror3:\r\nfree_irq(port->tx_irq, port);\r\nerror2:\r\nfree_irq(port->rx_irq, port);\r\nerror:\r\nkfree(port->rx_buffer);\r\nport->rx_buffer = NULL;\r\nreturn -EBUSY;\r\n}\r\nstatic void mn10300_serial_shutdown(struct uart_port *_port)\r\n{\r\nunsigned long flags;\r\nu16 x;\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s", port->name);\r\nspin_lock_irqsave(&_port->lock, flags);\r\nmn10300_serial_dis_tx_intr(port);\r\n*port->rx_icr = NUM2GxICR_LEVEL(CONFIG_MN10300_SERIAL_IRQ_LEVEL);\r\nx = *port->rx_icr;\r\nport->tx_flags = 0;\r\nspin_unlock_irqrestore(&_port->lock, flags);\r\n*port->_control &= ~(SC01CTR_TXE | SC01CTR_RXE | SC01CTR_BKE);\r\n*port->_tmxmd = 0;\r\nif (port->rx_buffer) {\r\nvoid *buf = port->rx_buffer;\r\nport->rx_buffer = NULL;\r\nkfree(buf);\r\n}\r\nfree_irq(port->tm_irq, port);\r\nfree_irq(port->rx_irq, port);\r\nfree_irq(port->tx_irq, port);\r\nmn10300_serial_int_tbl[port->tx_irq].port = NULL;\r\nmn10300_serial_int_tbl[port->rx_irq].port = NULL;\r\n}\r\nstatic void mn10300_serial_change_speed(struct mn10300_serial_port *port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned long ioclk = port->ioclk;\r\nunsigned cflag;\r\nint baud, bits, xdiv, tmp;\r\nu16 tmxbr, scxctr;\r\nu8 tmxmd, battempt;\r\nu8 div_timer = port->div_timer;\r\n_enter("%s{%lu}", port->name, ioclk);\r\ncflag = new->c_cflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS7: scxctr = SC01CTR_CLN_7BIT; bits = 9; break;\r\ncase CS8: scxctr = SC01CTR_CLN_8BIT; bits = 10; break;\r\ndefault: scxctr = SC01CTR_CLN_8BIT; bits = 10; break;\r\n}\r\nif (cflag & CSTOPB) {\r\nscxctr |= SC01CTR_STB_2BIT;\r\nbits++;\r\n}\r\nif (cflag & PARENB) {\r\nbits++;\r\nif (cflag & PARODD)\r\nscxctr |= SC01CTR_PB_ODD;\r\n#ifdef CMSPAR\r\nelse if (cflag & CMSPAR)\r\nscxctr |= SC01CTR_PB_FIXED0;\r\n#endif\r\nelse\r\nscxctr |= SC01CTR_PB_EVEN;\r\n}\r\nbattempt = 0;\r\nswitch (port->uart.line) {\r\n#ifdef CONFIG_MN10300_TTYSM0\r\ncase 0:\r\n#if defined(CONFIG_MN10300_TTYSM0_TIMER8)\r\nscxctr |= SC0CTR_CK_TM8UFLOW_8;\r\n#elif defined(CONFIG_MN10300_TTYSM0_TIMER0)\r\nscxctr |= SC0CTR_CK_TM0UFLOW_8;\r\n#elif defined(CONFIG_MN10300_TTYSM0_TIMER2)\r\nscxctr |= SC0CTR_CK_TM2UFLOW_8;\r\n#else\r\n#error "Unknown config for ttySM0"\r\n#endif\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MN10300_TTYSM1\r\ncase 1:\r\n#if defined(CONFIG_AM33_2) || defined(CONFIG_AM33_3)\r\n#if defined(CONFIG_MN10300_TTYSM1_TIMER9)\r\nscxctr |= SC1CTR_CK_TM9UFLOW_8;\r\n#elif defined(CONFIG_MN10300_TTYSM1_TIMER3)\r\nscxctr |= SC1CTR_CK_TM3UFLOW_8;\r\n#else\r\n#error "Unknown config for ttySM1"\r\n#endif\r\n#else\r\n#if defined(CONFIG_MN10300_TTYSM1_TIMER12)\r\nscxctr |= SC1CTR_CK_TM12UFLOW_8;\r\n#else\r\n#error "Unknown config for ttySM1"\r\n#endif\r\n#endif\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MN10300_TTYSM2\r\ncase 2:\r\n#if defined(CONFIG_AM33_2)\r\n#if defined(CONFIG_MN10300_TTYSM2_TIMER10)\r\nscxctr |= SC2CTR_CK_TM10UFLOW;\r\n#else\r\n#error "Unknown config for ttySM2"\r\n#endif\r\n#else\r\n#if defined(CONFIG_MN10300_TTYSM2_TIMER9)\r\nscxctr |= SC2CTR_CK_TM9UFLOW_8;\r\n#elif defined(CONFIG_MN10300_TTYSM2_TIMER1)\r\nscxctr |= SC2CTR_CK_TM1UFLOW_8;\r\n#elif defined(CONFIG_MN10300_TTYSM2_TIMER3)\r\nscxctr |= SC2CTR_CK_TM3UFLOW_8;\r\n#else\r\n#error "Unknown config for ttySM2"\r\n#endif\r\n#endif\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\ntry_alternative:\r\nbaud = uart_get_baud_rate(&port->uart, new, old, 0,\r\nport->ioclk / 8);\r\n_debug("ALT %d [baud %d]", battempt, baud);\r\nif (!baud)\r\nbaud = 9600;\r\nxdiv = 1;\r\nif (baud == 134) {\r\nbaud = 269;\r\nxdiv = 2;\r\n}\r\nif (baud == 38400 &&\r\n(port->uart.flags & UPF_SPD_MASK) == UPF_SPD_CUST\r\n) {\r\n_debug("CUSTOM %u", port->uart.custom_divisor);\r\nif (div_timer == MNSCx_DIV_TIMER_16BIT) {\r\nif (port->uart.custom_divisor <= 65535) {\r\ntmxmd = TM8MD_SRC_IOCLK;\r\ntmxbr = port->uart.custom_divisor;\r\nport->uart.uartclk = ioclk;\r\ngoto timer_okay;\r\n}\r\nif (port->uart.custom_divisor / 8 <= 65535) {\r\ntmxmd = TM8MD_SRC_IOCLK_8;\r\ntmxbr = port->uart.custom_divisor / 8;\r\nport->uart.custom_divisor = tmxbr * 8;\r\nport->uart.uartclk = ioclk / 8;\r\ngoto timer_okay;\r\n}\r\nif (port->uart.custom_divisor / 32 <= 65535) {\r\ntmxmd = TM8MD_SRC_IOCLK_32;\r\ntmxbr = port->uart.custom_divisor / 32;\r\nport->uart.custom_divisor = tmxbr * 32;\r\nport->uart.uartclk = ioclk / 32;\r\ngoto timer_okay;\r\n}\r\n} else if (div_timer == MNSCx_DIV_TIMER_8BIT) {\r\nif (port->uart.custom_divisor <= 255) {\r\ntmxmd = TM2MD_SRC_IOCLK;\r\ntmxbr = port->uart.custom_divisor;\r\nport->uart.uartclk = ioclk;\r\ngoto timer_okay;\r\n}\r\nif (port->uart.custom_divisor / 8 <= 255) {\r\ntmxmd = TM2MD_SRC_IOCLK_8;\r\ntmxbr = port->uart.custom_divisor / 8;\r\nport->uart.custom_divisor = tmxbr * 8;\r\nport->uart.uartclk = ioclk / 8;\r\ngoto timer_okay;\r\n}\r\nif (port->uart.custom_divisor / 32 <= 255) {\r\ntmxmd = TM2MD_SRC_IOCLK_32;\r\ntmxbr = port->uart.custom_divisor / 32;\r\nport->uart.custom_divisor = tmxbr * 32;\r\nport->uart.uartclk = ioclk / 32;\r\ngoto timer_okay;\r\n}\r\n}\r\n}\r\nswitch (div_timer) {\r\ncase MNSCx_DIV_TIMER_16BIT:\r\nport->uart.uartclk = ioclk;\r\ntmxmd = TM8MD_SRC_IOCLK;\r\ntmxbr = tmp = (ioclk / (baud * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 65535)\r\ngoto timer_okay;\r\nport->uart.uartclk = ioclk / 8;\r\ntmxmd = TM8MD_SRC_IOCLK_8;\r\ntmxbr = tmp = (ioclk / (baud * 8 * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 65535)\r\ngoto timer_okay;\r\nport->uart.uartclk = ioclk / 32;\r\ntmxmd = TM8MD_SRC_IOCLK_32;\r\ntmxbr = tmp = (ioclk / (baud * 32 * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 65535)\r\ngoto timer_okay;\r\nbreak;\r\ncase MNSCx_DIV_TIMER_8BIT:\r\nport->uart.uartclk = ioclk;\r\ntmxmd = TM2MD_SRC_IOCLK;\r\ntmxbr = tmp = (ioclk / (baud * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 255)\r\ngoto timer_okay;\r\nport->uart.uartclk = ioclk / 8;\r\ntmxmd = TM2MD_SRC_IOCLK_8;\r\ntmxbr = tmp = (ioclk / (baud * 8 * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 255)\r\ngoto timer_okay;\r\nport->uart.uartclk = ioclk / 32;\r\ntmxmd = TM2MD_SRC_IOCLK_32;\r\ntmxbr = tmp = (ioclk / (baud * 32 * xdiv) + 4) / 8 - 1;\r\nif (tmp > 0 && tmp <= 255)\r\ngoto timer_okay;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\n_debug("CAN'T SUPPORT");\r\nswitch (battempt) {\r\ncase 0:\r\nif (old) {\r\nnew->c_cflag &= ~CBAUD;\r\nnew->c_cflag |= (old->c_cflag & CBAUD);\r\nbattempt = 1;\r\ngoto try_alternative;\r\n}\r\ncase 1:\r\nnew->c_cflag &= ~CBAUD;\r\nnew->c_cflag |= B9600;\r\nbattempt = 2;\r\ngoto try_alternative;\r\ndefault:\r\nnew->c_cflag &= ~CBAUD;\r\nnew->c_cflag |= B0;\r\nif (div_timer == MNSCx_DIV_TIMER_16BIT)\r\ntmxmd = TM8MD_SRC_IOCLK_32;\r\nelse if (div_timer == MNSCx_DIV_TIMER_8BIT)\r\ntmxmd = TM2MD_SRC_IOCLK_32;\r\ntmxbr = 1;\r\nport->uart.uartclk = ioclk / 32;\r\nbreak;\r\n}\r\ntimer_okay:\r\n_debug("UARTCLK: %u / %hu", port->uart.uartclk, tmxbr);\r\nspin_lock_irqsave(&port->uart.lock, flags);\r\nuart_update_timeout(&port->uart, new->c_cflag, baud);\r\nswitch (div_timer) {\r\ncase MNSCx_DIV_TIMER_16BIT:\r\n*port->_tmxmd = 0;\r\n*port->_tmxbr = tmxbr;\r\n*port->_tmxmd = TM8MD_INIT_COUNTER;\r\n*port->_tmxmd = tmxmd | TM8MD_COUNT_ENABLE;\r\nbreak;\r\ncase MNSCx_DIV_TIMER_8BIT:\r\n*port->_tmxmd = 0;\r\n*(volatile u8 *) port->_tmxbr = (u8) tmxbr;\r\n*port->_tmxmd = TM2MD_INIT_COUNTER;\r\n*port->_tmxmd = tmxmd | TM2MD_COUNT_ENABLE;\r\nbreak;\r\n}\r\nscxctr &= ~(SC2CTR_TWE | SC2CTR_TWS);\r\nif (port->type == PORT_MN10300_CTS && cflag & CRTSCTS) {\r\nport->tx_cts = *port->_status;\r\nif (port->tx_cts & SC2STR_CTS)\r\nscxctr |= SC2CTR_TWE;\r\nelse\r\nscxctr |= SC2CTR_TWE | SC2CTR_TWS;\r\n}\r\nport->uart.read_status_mask = (1 << TTY_NORMAL) | (1 << TTY_OVERRUN);\r\nif (new->c_iflag & INPCK)\r\nport->uart.read_status_mask |=\r\n(1 << TTY_PARITY) | (1 << TTY_FRAME);\r\nif (new->c_iflag & (BRKINT | PARMRK))\r\nport->uart.read_status_mask |= (1 << TTY_BREAK);\r\nport->uart.ignore_status_mask = 0;\r\nif (new->c_iflag & IGNPAR)\r\nport->uart.ignore_status_mask |=\r\n(1 << TTY_PARITY) | (1 << TTY_FRAME);\r\nif (new->c_iflag & IGNBRK) {\r\nport->uart.ignore_status_mask |= (1 << TTY_BREAK);\r\nif (new->c_iflag & IGNPAR)\r\nport->uart.ignore_status_mask |= (1 << TTY_OVERRUN);\r\n}\r\nif ((new->c_cflag & CREAD) == 0)\r\nport->uart.ignore_status_mask |= (1 << TTY_NORMAL);\r\nscxctr |= SC01CTR_TXE | SC01CTR_RXE;\r\nscxctr |= *port->_control & SC01CTR_BKE;\r\n*port->_control = scxctr;\r\nspin_unlock_irqrestore(&port->uart.lock, flags);\r\n}\r\nstatic void mn10300_serial_set_termios(struct uart_port *_port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s,%p,%p", port->name, new, old);\r\nmn10300_serial_change_speed(port, new, old);\r\nif (!(new->c_cflag & CRTSCTS)) {\r\nu16 ctr = *port->_control;\r\nctr &= ~SC2CTR_TWE;\r\n*port->_control = ctr;\r\n}\r\nif (new->c_cflag & CODMSB)\r\n*port->_control |= SC01CTR_OD_MSBFIRST;\r\nelse\r\n*port->_control &= ~SC01CTR_OD_MSBFIRST;\r\n}\r\nstatic const char *mn10300_serial_type(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nif (port->uart.type == PORT_MN10300_CTS)\r\nreturn "MN10300 SIF_CTS";\r\nreturn "MN10300 SIF";\r\n}\r\nstatic void mn10300_serial_release_port(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s", port->name);\r\nrelease_mem_region((unsigned long) port->_iobase, 16);\r\n}\r\nstatic int mn10300_serial_request_port(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s", port->name);\r\nrequest_mem_region((unsigned long) port->_iobase, 16, port->name);\r\nreturn 0;\r\n}\r\nstatic void mn10300_serial_config_port(struct uart_port *_port, int type)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\n_enter("%s", port->name);\r\nport->uart.type = PORT_MN10300;\r\nif (port->options & MNSCx_OPT_CTS)\r\nport->uart.type = PORT_MN10300_CTS;\r\nmn10300_serial_request_port(_port);\r\n}\r\nstatic int mn10300_serial_verify_port(struct uart_port *_port,\r\nstruct serial_struct *ss)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nvoid *mapbase = (void *) (unsigned long) port->uart.mapbase;\r\n_enter("%s", port->name);\r\nif (ss->irq != port->uart.irq ||\r\nss->port != port->uart.iobase ||\r\nss->io_type != port->uart.iotype ||\r\nss->iomem_base != mapbase ||\r\nss->iomem_reg_shift != port->uart.regshift ||\r\nss->hub6 != port->uart.hub6 ||\r\nss->xmit_fifo_size != port->uart.fifosize)\r\nreturn -EINVAL;\r\nif (ss->type != port->uart.type) {\r\nif (!(port->options & MNSCx_OPT_CTS))\r\nreturn -EINVAL;\r\nif (ss->type != PORT_MN10300 &&\r\nss->type != PORT_MN10300_CTS)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mn10300_serial_init(void)\r\n{\r\nstruct mn10300_serial_port *port;\r\nint ret, i;\r\nprintk(KERN_INFO "%s version %s (%s)\n",\r\nserial_name, serial_version, serial_revdate);\r\n#if defined(CONFIG_MN10300_TTYSM2) && defined(CONFIG_AM33_2)\r\n{\r\nint tmp;\r\nSC2TIM = 8;\r\ntmp = SC2TIM;\r\n}\r\n#endif\r\nset_intr_stub(NUM2EXCEP_IRQ_LEVEL(CONFIG_MN10300_SERIAL_IRQ_LEVEL),\r\nmn10300_serial_vdma_interrupt);\r\nret = uart_register_driver(&mn10300_serial_driver);\r\nif (!ret) {\r\nfor (i = 0 ; i < NR_PORTS ; i++) {\r\nport = mn10300_serial_ports[i];\r\nif (!port || port->gdbstub)\r\ncontinue;\r\nswitch (port->clock_src) {\r\ncase MNSCx_CLOCK_SRC_IOCLK:\r\nport->ioclk = MN10300_IOCLK;\r\nbreak;\r\n#ifdef MN10300_IOBCLK\r\ncase MNSCx_CLOCK_SRC_IOBCLK:\r\nport->ioclk = MN10300_IOBCLK;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\nret = uart_add_one_port(&mn10300_serial_driver,\r\n&port->uart);\r\nif (ret < 0) {\r\n_debug("ERROR %d", -ret);\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nuart_unregister_driver(&mn10300_serial_driver);\r\n}\r\nreturn ret;\r\n}\r\nstatic void mn10300_serial_console_write(struct console *co,\r\nconst char *s, unsigned count)\r\n{\r\nstruct mn10300_serial_port *port;\r\nunsigned i;\r\nu16 scxctr;\r\nu8 tmxmd;\r\nunsigned long flags;\r\nint locked = 1;\r\nport = mn10300_serial_ports[co->index];\r\nlocal_irq_save(flags);\r\nif (port->uart.sysrq) {\r\nlocked = 0;\r\n} else if (oops_in_progress) {\r\nlocked = spin_trylock(&port->uart.lock);\r\n} else\r\nspin_lock(&port->uart.lock);\r\nmn10300_serial_dis_tx_intr(port);\r\nscxctr = *port->_control;\r\nif (!(scxctr & SC01CTR_TXE)) {\r\ntmxmd = *port->_tmxmd;\r\nswitch (port->div_timer) {\r\ncase MNSCx_DIV_TIMER_16BIT:\r\n*port->_tmxmd = 0;\r\n*port->_tmxmd = TM8MD_INIT_COUNTER;\r\n*port->_tmxmd = tmxmd | TM8MD_COUNT_ENABLE;\r\nbreak;\r\ncase MNSCx_DIV_TIMER_8BIT:\r\n*port->_tmxmd = 0;\r\n*port->_tmxmd = TM2MD_INIT_COUNTER;\r\n*port->_tmxmd = tmxmd | TM2MD_COUNT_ENABLE;\r\nbreak;\r\n}\r\n*port->_control = (scxctr & ~SC01CTR_BKE) | SC01CTR_TXE;\r\n} else if (scxctr & SC01CTR_BKE) {\r\n*port->_control = (scxctr & ~SC01CTR_BKE);\r\n}\r\nfor (i = 0; i < count; i++) {\r\nchar ch = *s++;\r\nwhile (*port->_status & SC01STR_TBF)\r\ncontinue;\r\n*port->_txb = ch;\r\nif (ch == 0x0a) {\r\nwhile (*port->_status & SC01STR_TBF)\r\ncontinue;\r\n*port->_txb = 0xd;\r\n}\r\n}\r\nwhile (*port->_status & (SC01STR_TXF | SC01STR_TBF))\r\ncontinue;\r\nif (!(scxctr & SC01CTR_TXE))\r\n*port->_control = scxctr;\r\nmn10300_serial_en_tx_intr(port);\r\nif (locked)\r\nspin_unlock(&port->uart.lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init mn10300_serial_console_setup(struct console *co,\r\nchar *options)\r\n{\r\nstruct mn10300_serial_port *port;\r\nint i, parity = 'n', baud = 9600, bits = 8, flow = 0;\r\nfor (i = 0 ; i < NR_PORTS ; i++) {\r\nport = mn10300_serial_ports[i];\r\nif (port && !port->gdbstub && port->uart.line == co->index)\r\ngoto found_device;\r\n}\r\nreturn -ENODEV;\r\nfound_device:\r\nswitch (port->clock_src) {\r\ncase MNSCx_CLOCK_SRC_IOCLK:\r\nport->ioclk = MN10300_IOCLK;\r\nbreak;\r\n#ifdef MN10300_IOBCLK\r\ncase MNSCx_CLOCK_SRC_IOBCLK:\r\nport->ioclk = MN10300_IOBCLK;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&port->uart, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init mn10300_serial_console_init(void)\r\n{\r\nregister_console(&mn10300_serial_console);\r\nreturn 0;\r\n}\r\nstatic int mn10300_serial_poll_get_char(struct uart_port *_port)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nunsigned ix;\r\nu8 st, ch;\r\n_enter("%s", port->name);\r\nif (mn10300_serial_int_tbl[port->rx_irq].port != NULL) {\r\ndo {\r\nix = ACCESS_ONCE(port->rx_outp);\r\nif (CIRC_CNT(port->rx_inp, ix, MNSC_BUFFER_SIZE) == 0)\r\nreturn NO_POLL_CHAR;\r\nsmp_read_barrier_depends();\r\nch = port->rx_buffer[ix++];\r\nst = port->rx_buffer[ix++];\r\nsmp_mb();\r\nport->rx_outp = ix & (MNSC_BUFFER_SIZE - 1);\r\n} while (st & (SC01STR_FEF | SC01STR_PEF | SC01STR_OEF));\r\n} else {\r\ndo {\r\nst = *port->_status;\r\nif (st & (SC01STR_FEF | SC01STR_PEF | SC01STR_OEF))\r\ncontinue;\r\n} while (!(st & SC01STR_RBF));\r\nch = *port->_rxb;\r\n}\r\nreturn ch;\r\n}\r\nstatic void mn10300_serial_poll_put_char(struct uart_port *_port,\r\nunsigned char ch)\r\n{\r\nstruct mn10300_serial_port *port =\r\ncontainer_of(_port, struct mn10300_serial_port, uart);\r\nu8 intr, tmp;\r\nwhile (*port->_status & (SC01STR_TBF | SC01STR_TXF))\r\ncontinue;\r\nintr = *port->_intr;\r\n*port->_intr = intr & ~SC01ICR_TI;\r\ntmp = *port->_intr;\r\nif (ch == 0x0a) {\r\n*port->_txb = 0x0d;\r\nwhile (*port->_status & SC01STR_TBF)\r\ncontinue;\r\n}\r\n*port->_txb = ch;\r\nwhile (*port->_status & SC01STR_TBF)\r\ncontinue;\r\n*port->_intr = intr;\r\ntmp = *port->_intr;\r\n}
