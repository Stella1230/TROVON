static bool wm8960_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8960_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm8960_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nint val, i, best;\r\nif (wm8960->deemph) {\r\nbest = 1;\r\nfor (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {\r\nif (abs(deemph_settings[i] - wm8960->playback_fs) <\r\nabs(deemph_settings[best] - wm8960->playback_fs))\r\nbest = i;\r\n}\r\nval = best << 1;\r\n} else {\r\nval = 0;\r\n}\r\ndev_dbg(codec->dev, "Set deemphasis %d\n", val);\r\nreturn snd_soc_update_bits(codec, WM8960_DACCTL1,\r\n0x6, val);\r\n}\r\nstatic int wm8960_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8960->deemph;\r\nreturn 0;\r\n}\r\nstatic int wm8960_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nint deemph = ucontrol->value.enumerated.item[0];\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nwm8960->deemph = deemph;\r\nreturn wm8960_set_deemph(codec);\r\n}\r\nstatic int wm8960_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8960_data *pdata = codec->dev->platform_data;\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nstruct snd_soc_dapm_widget *w;\r\nsnd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets,\r\nARRAY_SIZE(wm8960_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, audio_paths, ARRAY_SIZE(audio_paths));\r\nif (pdata && pdata->capless) {\r\nsnd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_capless,\r\nARRAY_SIZE(wm8960_dapm_widgets_capless));\r\nsnd_soc_dapm_add_routes(dapm, audio_paths_capless,\r\nARRAY_SIZE(audio_paths_capless));\r\n} else {\r\nsnd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_out3,\r\nARRAY_SIZE(wm8960_dapm_widgets_out3));\r\nsnd_soc_dapm_add_routes(dapm, audio_paths_out3,\r\nARRAY_SIZE(audio_paths_out3));\r\n}\r\nlist_for_each_entry(w, &codec->card->widgets, list) {\r\nif (w->dapm != &codec->dapm)\r\ncontinue;\r\nif (strcmp(w->name, "LOUT1 PGA") == 0)\r\nwm8960->lout1 = w;\r\nif (strcmp(w->name, "ROUT1 PGA") == 0)\r\nwm8960->rout1 = w;\r\nif (strcmp(w->name, "OUT3 VMID") == 0)\r\nwm8960->out3 = w;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8960_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface |= 0x0040;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= 0x0002;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= 0x0001;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= 0x0003;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface |= 0x0013;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= 0x0090;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= 0x0080;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface |= 0x0010;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8960_IFACE1, iface);\r\nreturn 0;\r\n}\r\nstatic int wm8960_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nu16 iface = snd_soc_read(codec, WM8960_IFACE1) & 0xfff3;\r\nsnd_pcm_format_t format = params_format(params);\r\nint i;\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ncase SNDRV_PCM_FORMAT_S20_3BE:\r\niface |= 0x0004;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ncase SNDRV_PCM_FORMAT_S24_BE:\r\niface |= 0x0008;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported format %i\n", format);\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nwm8960->playback_fs = params_rate(params);\r\nwm8960_set_deemph(codec);\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(alc_rates); i++)\r\nif (alc_rates[i].rate == params_rate(params))\r\nsnd_soc_update_bits(codec,\r\nWM8960_ADDCTL3, 0x7,\r\nalc_rates[i].val);\r\n}\r\nsnd_soc_write(codec, WM8960_IFACE1, iface);\r\nreturn 0;\r\n}\r\nstatic int wm8960_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute)\r\nsnd_soc_update_bits(codec, WM8960_DACCTL1, 0x8, 0x8);\r\nelse\r\nsnd_soc_update_bits(codec, WM8960_DACCTL1, 0x8, 0);\r\nreturn 0;\r\n}\r\nstatic int wm8960_set_bias_level_out3(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8960_POWER1, 0x180, 0x80);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nregcache_sync(wm8960->regmap);\r\nsnd_soc_write(codec, WM8960_APOP1,\r\nWM8960_POBCTRL | WM8960_SOFT_ST |\r\nWM8960_BUFDCOPEN | WM8960_BUFIOEN);\r\nsnd_soc_update_bits(codec, WM8960_POWER1, 0x80, 0x80);\r\nmsleep(100);\r\nsnd_soc_update_bits(codec, WM8960_POWER1, WM8960_VREF,\r\nWM8960_VREF);\r\nsnd_soc_write(codec, WM8960_APOP1, WM8960_BUFIOEN);\r\n}\r\nsnd_soc_update_bits(codec, WM8960_POWER1, 0x180, 0x100);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, WM8960_APOP1,\r\nWM8960_POBCTRL | WM8960_SOFT_ST |\r\nWM8960_BUFDCOPEN | WM8960_BUFIOEN);\r\nsnd_soc_write(codec, WM8960_POWER1, 0);\r\nmsleep(600);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8960_set_bias_level_capless(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nint reg;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nswitch (codec->dapm.bias_level) {\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, WM8960_APOP1,\r\nWM8960_POBCTRL | WM8960_SOFT_ST |\r\nWM8960_BUFDCOPEN,\r\nWM8960_POBCTRL | WM8960_SOFT_ST |\r\nWM8960_BUFDCOPEN);\r\nreg = 0;\r\nif (wm8960->lout1 && wm8960->lout1->power)\r\nreg |= WM8960_PWR2_LOUT1;\r\nif (wm8960->rout1 && wm8960->rout1->power)\r\nreg |= WM8960_PWR2_ROUT1;\r\nif (wm8960->out3 && wm8960->out3->power)\r\nreg |= WM8960_PWR2_OUT3;\r\nsnd_soc_update_bits(codec, WM8960_POWER2,\r\nWM8960_PWR2_LOUT1 |\r\nWM8960_PWR2_ROUT1 |\r\nWM8960_PWR2_OUT3, reg);\r\nsnd_soc_update_bits(codec, WM8960_POWER1,\r\nWM8960_VMID_MASK, 0x80);\r\nmsleep(100);\r\nsnd_soc_update_bits(codec, WM8960_POWER1,\r\nWM8960_VREF, WM8960_VREF);\r\nmsleep(100);\r\nbreak;\r\ncase SND_SOC_BIAS_ON:\r\nsnd_soc_update_bits(codec, WM8960_APOP1,\r\nWM8960_POBCTRL | WM8960_SOFT_ST |\r\nWM8960_BUFDCOPEN,\r\nWM8960_POBCTRL | WM8960_SOFT_ST |\r\nWM8960_BUFDCOPEN);\r\nsnd_soc_update_bits(codec, WM8960_POWER1,\r\nWM8960_VREF | WM8960_VMID_MASK, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregcache_sync(wm8960->regmap);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nswitch (codec->dapm.bias_level) {\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8960_APOP2,\r\nWM8960_DISOP | WM8960_DRES_MASK,\r\n0);\r\nsnd_soc_update_bits(codec, WM8960_APOP1,\r\nWM8960_POBCTRL | WM8960_SOFT_ST |\r\nWM8960_BUFDCOPEN,\r\nWM8960_POBCTRL | WM8960_SOFT_ST |\r\nWM8960_BUFDCOPEN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int pll_factors(unsigned int source, unsigned int target,\r\nstruct _pll_div *pll_div)\r\n{\r\nunsigned long long Kpart;\r\nunsigned int K, Ndiv, Nmod;\r\npr_debug("WM8960 PLL: setting %dHz->%dHz\n", source, target);\r\ntarget *= 4;\r\nNdiv = target / source;\r\nif (Ndiv < 6) {\r\nsource >>= 1;\r\npll_div->pre_div = 1;\r\nNdiv = target / source;\r\n} else\r\npll_div->pre_div = 0;\r\nif ((Ndiv < 6) || (Ndiv > 12)) {\r\npr_err("WM8960 PLL: Unsupported N=%d\n", Ndiv);\r\nreturn -EINVAL;\r\n}\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div->k = K;\r\npr_debug("WM8960 PLL: N=%x K=%x pre_div=%d\n",\r\npll_div->n, pll_div->k, pll_div->pre_div);\r\nreturn 0;\r\n}\r\nstatic int wm8960_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nstatic struct _pll_div pll_div;\r\nint ret;\r\nif (freq_in && freq_out) {\r\nret = pll_factors(freq_in, freq_out, &pll_div);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, WM8960_CLOCK1, 0x1, 0);\r\nsnd_soc_update_bits(codec, WM8960_POWER2, 0x1, 0);\r\nif (!freq_in || !freq_out)\r\nreturn 0;\r\nreg = snd_soc_read(codec, WM8960_PLL1) & ~0x3f;\r\nreg |= pll_div.pre_div << 4;\r\nreg |= pll_div.n;\r\nif (pll_div.k) {\r\nreg |= 0x20;\r\nsnd_soc_write(codec, WM8960_PLL2, (pll_div.k >> 18) & 0x3f);\r\nsnd_soc_write(codec, WM8960_PLL3, (pll_div.k >> 9) & 0x1ff);\r\nsnd_soc_write(codec, WM8960_PLL4, pll_div.k & 0x1ff);\r\n}\r\nsnd_soc_write(codec, WM8960_PLL1, reg);\r\nsnd_soc_update_bits(codec, WM8960_POWER2, 0x1, 0x1);\r\nmsleep(250);\r\nsnd_soc_update_bits(codec, WM8960_CLOCK1, 0x1, 0x1);\r\nreturn 0;\r\n}\r\nstatic int wm8960_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nswitch (div_id) {\r\ncase WM8960_SYSCLKDIV:\r\nreg = snd_soc_read(codec, WM8960_CLOCK1) & 0x1f9;\r\nsnd_soc_write(codec, WM8960_CLOCK1, reg | div);\r\nbreak;\r\ncase WM8960_DACDIV:\r\nreg = snd_soc_read(codec, WM8960_CLOCK1) & 0x1c7;\r\nsnd_soc_write(codec, WM8960_CLOCK1, reg | div);\r\nbreak;\r\ncase WM8960_OPCLKDIV:\r\nreg = snd_soc_read(codec, WM8960_PLL1) & 0x03f;\r\nsnd_soc_write(codec, WM8960_PLL1, reg | div);\r\nbreak;\r\ncase WM8960_DCLKDIV:\r\nreg = snd_soc_read(codec, WM8960_CLOCK2) & 0x03f;\r\nsnd_soc_write(codec, WM8960_CLOCK2, reg | div);\r\nbreak;\r\ncase WM8960_TOCLKSEL:\r\nreg = snd_soc_read(codec, WM8960_ADDCTL1) & 0x1fd;\r\nsnd_soc_write(codec, WM8960_ADDCTL1, reg | div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8960_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nreturn wm8960->set_bias_level(codec, level);\r\n}\r\nstatic int wm8960_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nwm8960->set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8960_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nwm8960->set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8960_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8960_data *pdata = dev_get_platdata(codec->dev);\r\nint ret;\r\nwm8960->set_bias_level = wm8960_set_bias_level_out3;\r\nif (!pdata) {\r\ndev_warn(codec->dev, "No platform data supplied\n");\r\n} else {\r\nif (pdata->capless)\r\nwm8960->set_bias_level = wm8960_set_bias_level_capless;\r\n}\r\nret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = wm8960_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset\n");\r\nreturn ret;\r\n}\r\nwm8960->set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_update_bits(codec, WM8960_LINVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_RINVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_LADC, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_RADC, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_LDAC, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_RDAC, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_LOUT1, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_ROUT1, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_LOUT2, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8960_ROUT2, 0x100, 0x100);\r\nsnd_soc_add_codec_controls(codec, wm8960_snd_controls,\r\nARRAY_SIZE(wm8960_snd_controls));\r\nwm8960_add_widgets(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8960_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);\r\nwm8960->set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8960_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8960_data *pdata = dev_get_platdata(&i2c->dev);\r\nstruct wm8960_priv *wm8960;\r\nint ret;\r\nwm8960 = devm_kzalloc(&i2c->dev, sizeof(struct wm8960_priv),\r\nGFP_KERNEL);\r\nif (wm8960 == NULL)\r\nreturn -ENOMEM;\r\nwm8960->regmap = devm_regmap_init_i2c(i2c, &wm8960_regmap);\r\nif (IS_ERR(wm8960->regmap))\r\nreturn PTR_ERR(wm8960->regmap);\r\nif (pdata && pdata->shared_lrclk) {\r\nret = regmap_update_bits(wm8960->regmap, WM8960_ADDCTL2,\r\n0x4, 0x4);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable LRCM: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\ni2c_set_clientdata(i2c, wm8960);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8960, &wm8960_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8960_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
