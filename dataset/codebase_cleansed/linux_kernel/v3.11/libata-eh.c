static void ata_eh_handle_port_suspend(struct ata_port *ap)\r\n{ }\r\nstatic void ata_eh_handle_port_resume(struct ata_port *ap)\r\n{ }\r\nstatic void __ata_ehi_pushv_desc(struct ata_eh_info *ehi, const char *fmt,\r\nva_list args)\r\n{\r\nehi->desc_len += vscnprintf(ehi->desc + ehi->desc_len,\r\nATA_EH_DESC_LEN - ehi->desc_len,\r\nfmt, args);\r\n}\r\nvoid __ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)\r\n{\r\nva_list args;\r\nva_start(args, fmt);\r\n__ata_ehi_pushv_desc(ehi, fmt, args);\r\nva_end(args);\r\n}\r\nvoid ata_ehi_push_desc(struct ata_eh_info *ehi, const char *fmt, ...)\r\n{\r\nva_list args;\r\nif (ehi->desc_len)\r\n__ata_ehi_push_desc(ehi, ", ");\r\nva_start(args, fmt);\r\n__ata_ehi_pushv_desc(ehi, fmt, args);\r\nva_end(args);\r\n}\r\nvoid ata_ehi_clear_desc(struct ata_eh_info *ehi)\r\n{\r\nehi->desc[0] = '\0';\r\nehi->desc_len = 0;\r\n}\r\nvoid ata_port_desc(struct ata_port *ap, const char *fmt, ...)\r\n{\r\nva_list args;\r\nWARN_ON(!(ap->pflags & ATA_PFLAG_INITIALIZING));\r\nif (ap->link.eh_info.desc_len)\r\n__ata_ehi_push_desc(&ap->link.eh_info, " ");\r\nva_start(args, fmt);\r\n__ata_ehi_pushv_desc(&ap->link.eh_info, fmt, args);\r\nva_end(args);\r\n}\r\nvoid ata_port_pbar_desc(struct ata_port *ap, int bar, ssize_t offset,\r\nconst char *name)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nchar *type = "";\r\nunsigned long long start, len;\r\nif (pci_resource_flags(pdev, bar) & IORESOURCE_MEM)\r\ntype = "m";\r\nelse if (pci_resource_flags(pdev, bar) & IORESOURCE_IO)\r\ntype = "i";\r\nstart = (unsigned long long)pci_resource_start(pdev, bar);\r\nlen = (unsigned long long)pci_resource_len(pdev, bar);\r\nif (offset < 0)\r\nata_port_desc(ap, "%s %s%llu@0x%llx", name, type, len, start);\r\nelse\r\nata_port_desc(ap, "%s 0x%llx", name,\r\nstart + (unsigned long long)offset);\r\n}\r\nstatic int ata_lookup_timeout_table(u8 cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < ATA_EH_CMD_TIMEOUT_TABLE_SIZE; i++) {\r\nconst u8 *cur;\r\nfor (cur = ata_eh_cmd_timeout_table[i].commands; *cur; cur++)\r\nif (*cur == cmd)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nunsigned long ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd)\r\n{\r\nstruct ata_eh_context *ehc = &dev->link->eh_context;\r\nint ent = ata_lookup_timeout_table(cmd);\r\nint idx;\r\nif (ent < 0)\r\nreturn ATA_EH_CMD_DFL_TIMEOUT;\r\nidx = ehc->cmd_timeout_idx[dev->devno][ent];\r\nreturn ata_eh_cmd_timeout_table[ent].timeouts[idx];\r\n}\r\nvoid ata_internal_cmd_timed_out(struct ata_device *dev, u8 cmd)\r\n{\r\nstruct ata_eh_context *ehc = &dev->link->eh_context;\r\nint ent = ata_lookup_timeout_table(cmd);\r\nint idx;\r\nif (ent < 0)\r\nreturn;\r\nidx = ehc->cmd_timeout_idx[dev->devno][ent];\r\nif (ata_eh_cmd_timeout_table[ent].timeouts[idx + 1] != ULONG_MAX)\r\nehc->cmd_timeout_idx[dev->devno][ent]++;\r\n}\r\nstatic void ata_ering_record(struct ata_ering *ering, unsigned int eflags,\r\nunsigned int err_mask)\r\n{\r\nstruct ata_ering_entry *ent;\r\nWARN_ON(!err_mask);\r\nering->cursor++;\r\nering->cursor %= ATA_ERING_SIZE;\r\nent = &ering->ring[ering->cursor];\r\nent->eflags = eflags;\r\nent->err_mask = err_mask;\r\nent->timestamp = get_jiffies_64();\r\n}\r\nstatic struct ata_ering_entry *ata_ering_top(struct ata_ering *ering)\r\n{\r\nstruct ata_ering_entry *ent = &ering->ring[ering->cursor];\r\nif (ent->err_mask)\r\nreturn ent;\r\nreturn NULL;\r\n}\r\nint ata_ering_map(struct ata_ering *ering,\r\nint (*map_fn)(struct ata_ering_entry *, void *),\r\nvoid *arg)\r\n{\r\nint idx, rc = 0;\r\nstruct ata_ering_entry *ent;\r\nidx = ering->cursor;\r\ndo {\r\nent = &ering->ring[idx];\r\nif (!ent->err_mask)\r\nbreak;\r\nrc = map_fn(ent, arg);\r\nif (rc)\r\nbreak;\r\nidx = (idx - 1 + ATA_ERING_SIZE) % ATA_ERING_SIZE;\r\n} while (idx != ering->cursor);\r\nreturn rc;\r\n}\r\nstatic int ata_ering_clear_cb(struct ata_ering_entry *ent, void *void_arg)\r\n{\r\nent->eflags |= ATA_EFLAG_OLD_ER;\r\nreturn 0;\r\n}\r\nstatic void ata_ering_clear(struct ata_ering *ering)\r\n{\r\nata_ering_map(ering, ata_ering_clear_cb, NULL);\r\n}\r\nstatic unsigned int ata_eh_dev_action(struct ata_device *dev)\r\n{\r\nstruct ata_eh_context *ehc = &dev->link->eh_context;\r\nreturn ehc->i.action | ehc->i.dev_action[dev->devno];\r\n}\r\nstatic void ata_eh_clear_action(struct ata_link *link, struct ata_device *dev,\r\nstruct ata_eh_info *ehi, unsigned int action)\r\n{\r\nstruct ata_device *tdev;\r\nif (!dev) {\r\nehi->action &= ~action;\r\nata_for_each_dev(tdev, link, ALL)\r\nehi->dev_action[tdev->devno] &= ~action;\r\n} else {\r\nWARN_ON(!(action & ATA_EH_PERDEV_MASK));\r\nif (ehi->action & action) {\r\nata_for_each_dev(tdev, link, ALL)\r\nehi->dev_action[tdev->devno] |=\r\nehi->action & action;\r\nehi->action &= ~action;\r\n}\r\nehi->dev_action[dev->devno] &= ~action;\r\n}\r\n}\r\nvoid ata_eh_acquire(struct ata_port *ap)\r\n{\r\nmutex_lock(&ap->host->eh_mutex);\r\nWARN_ON_ONCE(ap->host->eh_owner);\r\nap->host->eh_owner = current;\r\n}\r\nvoid ata_eh_release(struct ata_port *ap)\r\n{\r\nWARN_ON_ONCE(ap->host->eh_owner != current);\r\nap->host->eh_owner = NULL;\r\nmutex_unlock(&ap->host->eh_mutex);\r\n}\r\nenum blk_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct ata_port *ap = ata_shost_to_port(host);\r\nunsigned long flags;\r\nstruct ata_queued_cmd *qc;\r\nenum blk_eh_timer_return ret;\r\nDPRINTK("ENTER\n");\r\nif (ap->ops->error_handler) {\r\nret = BLK_EH_NOT_HANDLED;\r\ngoto out;\r\n}\r\nret = BLK_EH_HANDLED;\r\nspin_lock_irqsave(ap->lock, flags);\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (qc) {\r\nWARN_ON(qc->scsicmd != cmd);\r\nqc->flags |= ATA_QCFLAG_EH_SCHEDULED;\r\nqc->err_mask |= AC_ERR_TIMEOUT;\r\nret = BLK_EH_NOT_HANDLED;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nout:\r\nDPRINTK("EXIT, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void ata_eh_unload(struct ata_port *ap)\r\n{\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nata_for_each_link(link, ap, PMP_FIRST) {\r\nsata_scr_write(link, SCR_CONTROL, link->saved_scontrol & 0xff0);\r\nata_for_each_dev(dev, link, ALL)\r\nata_dev_disable(dev);\r\n}\r\nspin_lock_irqsave(ap->lock, flags);\r\nata_port_freeze(ap);\r\nap->pflags &= ~ATA_PFLAG_EH_PENDING;\r\nap->pflags |= ATA_PFLAG_UNLOADED;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nvoid ata_scsi_error(struct Scsi_Host *host)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(host);\r\nunsigned long flags;\r\nLIST_HEAD(eh_work_q);\r\nDPRINTK("ENTER\n");\r\nspin_lock_irqsave(host->host_lock, flags);\r\nlist_splice_init(&host->eh_cmd_q, &eh_work_q);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nata_scsi_cmd_error_handler(host, ap, &eh_work_q);\r\nata_scsi_port_error_handler(host, ap);\r\nWARN_ON(host->host_failed || !list_empty(&eh_work_q));\r\nDPRINTK("EXIT\n");\r\n}\r\nvoid ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap,\r\nstruct list_head *eh_work_q)\r\n{\r\nint i;\r\nunsigned long flags;\r\nata_sff_flush_pio_task(ap);\r\nif (ap->ops->error_handler) {\r\nstruct scsi_cmnd *scmd, *tmp;\r\nint nr_timedout = 0;\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (ap->ops->lost_interrupt)\r\nap->ops->lost_interrupt(ap);\r\nlist_for_each_entry_safe(scmd, tmp, eh_work_q, eh_entry) {\r\nstruct ata_queued_cmd *qc;\r\nfor (i = 0; i < ATA_MAX_QUEUE; i++) {\r\nqc = __ata_qc_from_tag(ap, i);\r\nif (qc->flags & ATA_QCFLAG_ACTIVE &&\r\nqc->scsicmd == scmd)\r\nbreak;\r\n}\r\nif (i < ATA_MAX_QUEUE) {\r\nif (!(qc->flags & ATA_QCFLAG_FAILED)) {\r\nqc->err_mask |= AC_ERR_TIMEOUT;\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\nnr_timedout++;\r\n}\r\n} else {\r\nscmd->retries = scmd->allowed;\r\nscsi_eh_finish_cmd(scmd, &ap->eh_done_q);\r\n}\r\n}\r\nif (nr_timedout)\r\n__ata_port_freeze(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nap->eh_tries = ATA_EH_MAX_TRIES;\r\n} else\r\nspin_unlock_wait(ap->lock);\r\n}\r\nvoid ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap)\r\n{\r\nunsigned long flags;\r\nif (ap->ops->error_handler) {\r\nstruct ata_link *link;\r\nata_eh_acquire(ap);\r\nrepeat:\r\ndel_timer_sync(&ap->fastdrain_timer);\r\nata_eh_handle_port_resume(ap);\r\nspin_lock_irqsave(ap->lock, flags);\r\nata_for_each_link(link, ap, HOST_FIRST) {\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nstruct ata_device *dev;\r\nmemset(&link->eh_context, 0, sizeof(link->eh_context));\r\nlink->eh_context.i = link->eh_info;\r\nmemset(&link->eh_info, 0, sizeof(link->eh_info));\r\nata_for_each_dev(dev, link, ENABLED) {\r\nint devno = dev->devno;\r\nehc->saved_xfer_mode[devno] = dev->xfer_mode;\r\nif (ata_ncq_enabled(dev))\r\nehc->saved_ncq_enabled |= 1 << devno;\r\n}\r\n}\r\nap->pflags |= ATA_PFLAG_EH_IN_PROGRESS;\r\nap->pflags &= ~ATA_PFLAG_EH_PENDING;\r\nap->excl_link = NULL;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nif (!(ap->pflags & (ATA_PFLAG_UNLOADING | ATA_PFLAG_SUSPENDED)))\r\nap->ops->error_handler(ap);\r\nelse {\r\nif ((ap->pflags & ATA_PFLAG_UNLOADING) &&\r\n!(ap->pflags & ATA_PFLAG_UNLOADED))\r\nata_eh_unload(ap);\r\nata_eh_finish(ap);\r\n}\r\nata_eh_handle_port_suspend(ap);\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (ap->pflags & ATA_PFLAG_EH_PENDING) {\r\nif (--ap->eh_tries) {\r\nspin_unlock_irqrestore(ap->lock, flags);\r\ngoto repeat;\r\n}\r\nata_port_err(ap,\r\n"EH pending after %d tries, giving up\n",\r\nATA_EH_MAX_TRIES);\r\nap->pflags &= ~ATA_PFLAG_EH_PENDING;\r\n}\r\nata_for_each_link(link, ap, HOST_FIRST)\r\nmemset(&link->eh_info, 0, sizeof(link->eh_info));\r\nap->ops->end_eh(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nata_eh_release(ap);\r\n} else {\r\nWARN_ON(ata_qc_from_tag(ap, ap->link.active_tag) == NULL);\r\nap->ops->eng_timeout(ap);\r\n}\r\nscsi_eh_flush_done_q(&ap->eh_done_q);\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (ap->pflags & ATA_PFLAG_LOADING)\r\nap->pflags &= ~ATA_PFLAG_LOADING;\r\nelse if (ap->pflags & ATA_PFLAG_SCSI_HOTPLUG)\r\nschedule_delayed_work(&ap->hotplug_task, 0);\r\nif (ap->pflags & ATA_PFLAG_RECOVERED)\r\nata_port_info(ap, "EH complete\n");\r\nap->pflags &= ~(ATA_PFLAG_SCSI_HOTPLUG | ATA_PFLAG_RECOVERED);\r\nap->pflags &= ~ATA_PFLAG_EH_IN_PROGRESS;\r\nwake_up_all(&ap->eh_wait_q);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nvoid ata_port_wait_eh(struct ata_port *ap)\r\n{\r\nunsigned long flags;\r\nDEFINE_WAIT(wait);\r\nretry:\r\nspin_lock_irqsave(ap->lock, flags);\r\nwhile (ap->pflags & (ATA_PFLAG_EH_PENDING | ATA_PFLAG_EH_IN_PROGRESS)) {\r\nprepare_to_wait(&ap->eh_wait_q, &wait, TASK_UNINTERRUPTIBLE);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nschedule();\r\nspin_lock_irqsave(ap->lock, flags);\r\n}\r\nfinish_wait(&ap->eh_wait_q, &wait);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nif (scsi_host_in_recovery(ap->scsi_host)) {\r\nata_msleep(ap, 10);\r\ngoto retry;\r\n}\r\n}\r\nstatic int ata_eh_nr_in_flight(struct ata_port *ap)\r\n{\r\nunsigned int tag;\r\nint nr = 0;\r\nfor (tag = 0; tag < ATA_MAX_QUEUE - 1; tag++)\r\nif (ata_qc_from_tag(ap, tag))\r\nnr++;\r\nreturn nr;\r\n}\r\nvoid ata_eh_fastdrain_timerfn(unsigned long arg)\r\n{\r\nstruct ata_port *ap = (void *)arg;\r\nunsigned long flags;\r\nint cnt;\r\nspin_lock_irqsave(ap->lock, flags);\r\ncnt = ata_eh_nr_in_flight(ap);\r\nif (!cnt)\r\ngoto out_unlock;\r\nif (cnt == ap->fastdrain_cnt) {\r\nunsigned int tag;\r\nfor (tag = 0; tag < ATA_MAX_QUEUE - 1; tag++) {\r\nstruct ata_queued_cmd *qc = ata_qc_from_tag(ap, tag);\r\nif (qc)\r\nqc->err_mask |= AC_ERR_TIMEOUT;\r\n}\r\nata_port_freeze(ap);\r\n} else {\r\nap->fastdrain_cnt = cnt;\r\nap->fastdrain_timer.expires =\r\nata_deadline(jiffies, ATA_EH_FASTDRAIN_INTERVAL);\r\nadd_timer(&ap->fastdrain_timer);\r\n}\r\nout_unlock:\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nstatic void ata_eh_set_pending(struct ata_port *ap, int fastdrain)\r\n{\r\nint cnt;\r\nif (ap->pflags & ATA_PFLAG_EH_PENDING)\r\nreturn;\r\nap->pflags |= ATA_PFLAG_EH_PENDING;\r\nif (!fastdrain)\r\nreturn;\r\ncnt = ata_eh_nr_in_flight(ap);\r\nif (!cnt)\r\nreturn;\r\nap->fastdrain_cnt = cnt;\r\nap->fastdrain_timer.expires =\r\nata_deadline(jiffies, ATA_EH_FASTDRAIN_INTERVAL);\r\nadd_timer(&ap->fastdrain_timer);\r\n}\r\nvoid ata_qc_schedule_eh(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct request_queue *q = qc->scsicmd->device->request_queue;\r\nunsigned long flags;\r\nWARN_ON(!ap->ops->error_handler);\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\nata_eh_set_pending(ap, 1);\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nblk_abort_request(qc->scsicmd->request);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\n}\r\nvoid ata_std_sched_eh(struct ata_port *ap)\r\n{\r\nWARN_ON(!ap->ops->error_handler);\r\nif (ap->pflags & ATA_PFLAG_INITIALIZING)\r\nreturn;\r\nata_eh_set_pending(ap, 1);\r\nscsi_schedule_eh(ap->scsi_host);\r\nDPRINTK("port EH scheduled\n");\r\n}\r\nvoid ata_std_end_eh(struct ata_port *ap)\r\n{\r\nstruct Scsi_Host *host = ap->scsi_host;\r\nhost->host_eh_scheduled = 0;\r\n}\r\nvoid ata_port_schedule_eh(struct ata_port *ap)\r\n{\r\nap->ops->sched_eh(ap);\r\n}\r\nstatic int ata_do_link_abort(struct ata_port *ap, struct ata_link *link)\r\n{\r\nint tag, nr_aborted = 0;\r\nWARN_ON(!ap->ops->error_handler);\r\nata_eh_set_pending(ap, 0);\r\nfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\r\nstruct ata_queued_cmd *qc = ata_qc_from_tag(ap, tag);\r\nif (qc && (!link || qc->dev->link == link)) {\r\nqc->flags |= ATA_QCFLAG_FAILED;\r\nata_qc_complete(qc);\r\nnr_aborted++;\r\n}\r\n}\r\nif (!nr_aborted)\r\nata_port_schedule_eh(ap);\r\nreturn nr_aborted;\r\n}\r\nint ata_link_abort(struct ata_link *link)\r\n{\r\nreturn ata_do_link_abort(link->ap, link);\r\n}\r\nint ata_port_abort(struct ata_port *ap)\r\n{\r\nreturn ata_do_link_abort(ap, NULL);\r\n}\r\nstatic void __ata_port_freeze(struct ata_port *ap)\r\n{\r\nWARN_ON(!ap->ops->error_handler);\r\nif (ap->ops->freeze)\r\nap->ops->freeze(ap);\r\nap->pflags |= ATA_PFLAG_FROZEN;\r\nDPRINTK("ata%u port frozen\n", ap->print_id);\r\n}\r\nint ata_port_freeze(struct ata_port *ap)\r\n{\r\nint nr_aborted;\r\nWARN_ON(!ap->ops->error_handler);\r\n__ata_port_freeze(ap);\r\nnr_aborted = ata_port_abort(ap);\r\nreturn nr_aborted;\r\n}\r\nint sata_async_notification(struct ata_port *ap)\r\n{\r\nu32 sntf;\r\nint rc;\r\nif (!(ap->flags & ATA_FLAG_AN))\r\nreturn 0;\r\nrc = sata_scr_read(&ap->link, SCR_NOTIFICATION, &sntf);\r\nif (rc == 0)\r\nsata_scr_write(&ap->link, SCR_NOTIFICATION, sntf);\r\nif (!sata_pmp_attached(ap) || rc) {\r\nif (!sata_pmp_attached(ap)) {\r\nstruct ata_device *dev = ap->link.device;\r\nif ((dev->class == ATA_DEV_ATAPI) &&\r\n(dev->flags & ATA_DFLAG_AN))\r\nata_scsi_media_change_notify(dev);\r\nreturn 0;\r\n} else {\r\nata_port_schedule_eh(ap);\r\nreturn 1;\r\n}\r\n} else {\r\nstruct ata_link *link;\r\nata_for_each_link(link, ap, EDGE) {\r\nif (!(sntf & (1 << link->pmp)))\r\ncontinue;\r\nif ((link->device->class == ATA_DEV_ATAPI) &&\r\n(link->device->flags & ATA_DFLAG_AN))\r\nata_scsi_media_change_notify(link->device);\r\n}\r\nif (sntf & (1 << SATA_PMP_CTRL_PORT)) {\r\nata_port_schedule_eh(ap);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nvoid ata_eh_freeze_port(struct ata_port *ap)\r\n{\r\nunsigned long flags;\r\nif (!ap->ops->error_handler)\r\nreturn;\r\nspin_lock_irqsave(ap->lock, flags);\r\n__ata_port_freeze(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nvoid ata_eh_thaw_port(struct ata_port *ap)\r\n{\r\nunsigned long flags;\r\nif (!ap->ops->error_handler)\r\nreturn;\r\nspin_lock_irqsave(ap->lock, flags);\r\nap->pflags &= ~ATA_PFLAG_FROZEN;\r\nif (ap->ops->thaw)\r\nap->ops->thaw(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nDPRINTK("ata%u port thawed\n", ap->print_id);\r\n}\r\nstatic void ata_eh_scsidone(struct scsi_cmnd *scmd)\r\n{\r\n}\r\nstatic void __ata_eh_qc_complete(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nunsigned long flags;\r\nspin_lock_irqsave(ap->lock, flags);\r\nqc->scsidone = ata_eh_scsidone;\r\n__ata_qc_complete(qc);\r\nWARN_ON(ata_tag_valid(qc->tag));\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nscsi_eh_finish_cmd(scmd, &ap->eh_done_q);\r\n}\r\nvoid ata_eh_qc_complete(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nscmd->retries = scmd->allowed;\r\n__ata_eh_qc_complete(qc);\r\n}\r\nvoid ata_eh_qc_retry(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nif (!qc->err_mask && scmd->retries)\r\nscmd->retries--;\r\n__ata_eh_qc_complete(qc);\r\n}\r\nvoid ata_dev_disable(struct ata_device *dev)\r\n{\r\nif (!ata_dev_enabled(dev))\r\nreturn;\r\nif (ata_msg_drv(dev->link->ap))\r\nata_dev_warn(dev, "disabled\n");\r\nata_acpi_on_disable(dev);\r\nata_down_xfermask_limit(dev, ATA_DNXFER_FORCE_PIO0 | ATA_DNXFER_QUIET);\r\ndev->class++;\r\nata_ering_clear(&dev->ering);\r\n}\r\nvoid ata_eh_detach_dev(struct ata_device *dev)\r\n{\r\nstruct ata_link *link = dev->link;\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nunsigned long flags;\r\nata_dev_disable(dev);\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev->flags &= ~ATA_DFLAG_DETACH;\r\nif (ata_scsi_offline_dev(dev)) {\r\ndev->flags |= ATA_DFLAG_DETACHED;\r\nap->pflags |= ATA_PFLAG_SCSI_HOTPLUG;\r\n}\r\nata_eh_clear_action(link, dev, &link->eh_info, ATA_EH_PERDEV_MASK);\r\nata_eh_clear_action(link, dev, &link->eh_context.i, ATA_EH_PERDEV_MASK);\r\nehc->saved_xfer_mode[dev->devno] = 0;\r\nehc->saved_ncq_enabled &= ~(1 << dev->devno);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nvoid ata_eh_about_to_do(struct ata_link *link, struct ata_device *dev,\r\nunsigned int action)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_eh_info *ehi = &link->eh_info;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nunsigned long flags;\r\nspin_lock_irqsave(ap->lock, flags);\r\nata_eh_clear_action(link, dev, ehi, action);\r\nif (!(ehc->i.flags & ATA_EHI_QUIET) && link != ap->slave_link)\r\nap->pflags |= ATA_PFLAG_RECOVERED;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nvoid ata_eh_done(struct ata_link *link, struct ata_device *dev,\r\nunsigned int action)\r\n{\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nata_eh_clear_action(link, dev, &ehc->i, action);\r\n}\r\nstatic const char *ata_err_string(unsigned int err_mask)\r\n{\r\nif (err_mask & AC_ERR_HOST_BUS)\r\nreturn "host bus error";\r\nif (err_mask & AC_ERR_ATA_BUS)\r\nreturn "ATA bus error";\r\nif (err_mask & AC_ERR_TIMEOUT)\r\nreturn "timeout";\r\nif (err_mask & AC_ERR_HSM)\r\nreturn "HSM violation";\r\nif (err_mask & AC_ERR_SYSTEM)\r\nreturn "internal error";\r\nif (err_mask & AC_ERR_MEDIA)\r\nreturn "media error";\r\nif (err_mask & AC_ERR_INVALID)\r\nreturn "invalid argument";\r\nif (err_mask & AC_ERR_DEV)\r\nreturn "device error";\r\nreturn "unknown error";\r\n}\r\nunsigned int ata_read_log_page(struct ata_device *dev, u8 log,\r\nu8 page, void *buf, unsigned int sectors)\r\n{\r\nstruct ata_taskfile tf;\r\nunsigned int err_mask;\r\nDPRINTK("read log page - log 0x%x, page 0x%x\n", log, page);\r\nata_tf_init(dev, &tf);\r\ntf.command = ATA_CMD_READ_LOG_EXT;\r\ntf.lbal = log;\r\ntf.lbam = page;\r\ntf.nsect = sectors;\r\ntf.hob_nsect = sectors >> 8;\r\ntf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_LBA48 | ATA_TFLAG_DEVICE;\r\ntf.protocol = ATA_PROT_PIO;\r\nerr_mask = ata_exec_internal(dev, &tf, NULL, DMA_FROM_DEVICE,\r\nbuf, sectors * ATA_SECT_SIZE, 0);\r\nDPRINTK("EXIT, err_mask=%x\n", err_mask);\r\nreturn err_mask;\r\n}\r\nstatic int ata_eh_read_log_10h(struct ata_device *dev,\r\nint *tag, struct ata_taskfile *tf)\r\n{\r\nu8 *buf = dev->link->ap->sector_buf;\r\nunsigned int err_mask;\r\nu8 csum;\r\nint i;\r\nerr_mask = ata_read_log_page(dev, ATA_LOG_SATA_NCQ, 0, buf, 1);\r\nif (err_mask)\r\nreturn -EIO;\r\ncsum = 0;\r\nfor (i = 0; i < ATA_SECT_SIZE; i++)\r\ncsum += buf[i];\r\nif (csum)\r\nata_dev_warn(dev, "invalid checksum 0x%x on log page 10h\n",\r\ncsum);\r\nif (buf[0] & 0x80)\r\nreturn -ENOENT;\r\n*tag = buf[0] & 0x1f;\r\ntf->command = buf[2];\r\ntf->feature = buf[3];\r\ntf->lbal = buf[4];\r\ntf->lbam = buf[5];\r\ntf->lbah = buf[6];\r\ntf->device = buf[7];\r\ntf->hob_lbal = buf[8];\r\ntf->hob_lbam = buf[9];\r\ntf->hob_lbah = buf[10];\r\ntf->nsect = buf[12];\r\ntf->hob_nsect = buf[13];\r\nreturn 0;\r\n}\r\nunsigned int atapi_eh_tur(struct ata_device *dev, u8 *r_sense_key)\r\n{\r\nu8 cdb[ATAPI_CDB_LEN] = { TEST_UNIT_READY, 0, 0, 0, 0, 0 };\r\nstruct ata_taskfile tf;\r\nunsigned int err_mask;\r\nata_tf_init(dev, &tf);\r\ntf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\ntf.command = ATA_CMD_PACKET;\r\ntf.protocol = ATAPI_PROT_NODATA;\r\nerr_mask = ata_exec_internal(dev, &tf, cdb, DMA_NONE, NULL, 0, 0);\r\nif (err_mask == AC_ERR_DEV)\r\n*r_sense_key = tf.feature >> 4;\r\nreturn err_mask;\r\n}\r\nunsigned int atapi_eh_request_sense(struct ata_device *dev,\r\nu8 *sense_buf, u8 dfl_sense_key)\r\n{\r\nu8 cdb[ATAPI_CDB_LEN] =\r\n{ REQUEST_SENSE, 0, 0, 0, SCSI_SENSE_BUFFERSIZE, 0 };\r\nstruct ata_port *ap = dev->link->ap;\r\nstruct ata_taskfile tf;\r\nDPRINTK("ATAPI request sense\n");\r\nmemset(sense_buf, 0, SCSI_SENSE_BUFFERSIZE);\r\nsense_buf[0] = 0x70;\r\nsense_buf[2] = dfl_sense_key;\r\nata_tf_init(dev, &tf);\r\ntf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\ntf.command = ATA_CMD_PACKET;\r\nif (ap->flags & ATA_FLAG_PIO_DMA) {\r\ntf.protocol = ATAPI_PROT_DMA;\r\ntf.feature |= ATAPI_PKT_DMA;\r\n} else {\r\ntf.protocol = ATAPI_PROT_PIO;\r\ntf.lbam = SCSI_SENSE_BUFFERSIZE;\r\ntf.lbah = 0;\r\n}\r\nreturn ata_exec_internal(dev, &tf, cdb, DMA_FROM_DEVICE,\r\nsense_buf, SCSI_SENSE_BUFFERSIZE, 0);\r\n}\r\nstatic void ata_eh_analyze_serror(struct ata_link *link)\r\n{\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nu32 serror = ehc->i.serror;\r\nunsigned int err_mask = 0, action = 0;\r\nu32 hotplug_mask;\r\nif (serror & (SERR_PERSISTENT | SERR_DATA)) {\r\nerr_mask |= AC_ERR_ATA_BUS;\r\naction |= ATA_EH_RESET;\r\n}\r\nif (serror & SERR_PROTOCOL) {\r\nerr_mask |= AC_ERR_HSM;\r\naction |= ATA_EH_RESET;\r\n}\r\nif (serror & SERR_INTERNAL) {\r\nerr_mask |= AC_ERR_SYSTEM;\r\naction |= ATA_EH_RESET;\r\n}\r\nif (link->lpm_policy > ATA_LPM_MAX_POWER)\r\nhotplug_mask = 0;\r\nelse if (!(link->flags & ATA_LFLAG_DISABLED) || ata_is_host_link(link))\r\nhotplug_mask = SERR_PHYRDY_CHG | SERR_DEV_XCHG;\r\nelse\r\nhotplug_mask = SERR_PHYRDY_CHG;\r\nif (serror & hotplug_mask)\r\nata_ehi_hotplugged(&ehc->i);\r\nehc->i.err_mask |= err_mask;\r\nehc->i.action |= action;\r\n}\r\nvoid ata_eh_analyze_ncq_error(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nstruct ata_device *dev = link->device;\r\nstruct ata_queued_cmd *qc;\r\nstruct ata_taskfile tf;\r\nint tag, rc;\r\nif (ap->pflags & ATA_PFLAG_FROZEN)\r\nreturn;\r\nif (!link->sactive || !(ehc->i.err_mask & AC_ERR_DEV))\r\nreturn;\r\nfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\r\nqc = __ata_qc_from_tag(ap, tag);\r\nif (!(qc->flags & ATA_QCFLAG_FAILED))\r\ncontinue;\r\nif (qc->err_mask)\r\nreturn;\r\n}\r\nmemset(&tf, 0, sizeof(tf));\r\nrc = ata_eh_read_log_10h(dev, &tag, &tf);\r\nif (rc) {\r\nata_link_err(link, "failed to read log page 10h (errno=%d)\n",\r\nrc);\r\nreturn;\r\n}\r\nif (!(link->sactive & (1 << tag))) {\r\nata_link_err(link, "log page 10h reported inactive tag %d\n",\r\ntag);\r\nreturn;\r\n}\r\nqc = __ata_qc_from_tag(ap, tag);\r\nmemcpy(&qc->result_tf, &tf, sizeof(tf));\r\nqc->result_tf.flags = ATA_TFLAG_ISADDR | ATA_TFLAG_LBA | ATA_TFLAG_LBA48;\r\nqc->err_mask |= AC_ERR_DEV | AC_ERR_NCQ;\r\nehc->i.err_mask &= ~AC_ERR_DEV;\r\n}\r\nstatic unsigned int ata_eh_analyze_tf(struct ata_queued_cmd *qc,\r\nconst struct ata_taskfile *tf)\r\n{\r\nunsigned int tmp, action = 0;\r\nu8 stat = tf->command, err = tf->feature;\r\nif ((stat & (ATA_BUSY | ATA_DRQ | ATA_DRDY)) != ATA_DRDY) {\r\nqc->err_mask |= AC_ERR_HSM;\r\nreturn ATA_EH_RESET;\r\n}\r\nif (stat & (ATA_ERR | ATA_DF))\r\nqc->err_mask |= AC_ERR_DEV;\r\nelse\r\nreturn 0;\r\nswitch (qc->dev->class) {\r\ncase ATA_DEV_ATA:\r\nif (err & ATA_ICRC)\r\nqc->err_mask |= AC_ERR_ATA_BUS;\r\nif (err & ATA_UNC)\r\nqc->err_mask |= AC_ERR_MEDIA;\r\nif (err & ATA_IDNF)\r\nqc->err_mask |= AC_ERR_INVALID;\r\nbreak;\r\ncase ATA_DEV_ATAPI:\r\nif (!(qc->ap->pflags & ATA_PFLAG_FROZEN)) {\r\ntmp = atapi_eh_request_sense(qc->dev,\r\nqc->scsicmd->sense_buffer,\r\nqc->result_tf.feature >> 4);\r\nif (!tmp) {\r\nqc->flags |= ATA_QCFLAG_SENSE_VALID;\r\n} else\r\nqc->err_mask |= tmp;\r\n}\r\n}\r\nif (qc->err_mask & (AC_ERR_HSM | AC_ERR_TIMEOUT | AC_ERR_ATA_BUS))\r\naction |= ATA_EH_RESET;\r\nreturn action;\r\n}\r\nstatic int ata_eh_categorize_error(unsigned int eflags, unsigned int err_mask,\r\nint *xfer_ok)\r\n{\r\nint base = 0;\r\nif (!(eflags & ATA_EFLAG_DUBIOUS_XFER))\r\n*xfer_ok = 1;\r\nif (!*xfer_ok)\r\nbase = ATA_ECAT_DUBIOUS_NONE;\r\nif (err_mask & AC_ERR_ATA_BUS)\r\nreturn base + ATA_ECAT_ATA_BUS;\r\nif (err_mask & AC_ERR_TIMEOUT)\r\nreturn base + ATA_ECAT_TOUT_HSM;\r\nif (eflags & ATA_EFLAG_IS_IO) {\r\nif (err_mask & AC_ERR_HSM)\r\nreturn base + ATA_ECAT_TOUT_HSM;\r\nif ((err_mask &\r\n(AC_ERR_DEV|AC_ERR_MEDIA|AC_ERR_INVALID)) == AC_ERR_DEV)\r\nreturn base + ATA_ECAT_UNK_DEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int speed_down_verdict_cb(struct ata_ering_entry *ent, void *void_arg)\r\n{\r\nstruct speed_down_verdict_arg *arg = void_arg;\r\nint cat;\r\nif ((ent->eflags & ATA_EFLAG_OLD_ER) || (ent->timestamp < arg->since))\r\nreturn -1;\r\ncat = ata_eh_categorize_error(ent->eflags, ent->err_mask,\r\n&arg->xfer_ok);\r\narg->nr_errors[cat]++;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_eh_speed_down_verdict(struct ata_device *dev)\r\n{\r\nconst u64 j5mins = 5LLU * 60 * HZ, j10mins = 10LLU * 60 * HZ;\r\nu64 j64 = get_jiffies_64();\r\nstruct speed_down_verdict_arg arg;\r\nunsigned int verdict = 0;\r\nmemset(&arg, 0, sizeof(arg));\r\narg.since = j64 - min(j64, j5mins);\r\nata_ering_map(&dev->ering, speed_down_verdict_cb, &arg);\r\nif (arg.nr_errors[ATA_ECAT_DUBIOUS_ATA_BUS] +\r\narg.nr_errors[ATA_ECAT_DUBIOUS_TOUT_HSM] > 1)\r\nverdict |= ATA_EH_SPDN_SPEED_DOWN |\r\nATA_EH_SPDN_FALLBACK_TO_PIO | ATA_EH_SPDN_KEEP_ERRORS;\r\nif (arg.nr_errors[ATA_ECAT_DUBIOUS_TOUT_HSM] +\r\narg.nr_errors[ATA_ECAT_DUBIOUS_UNK_DEV] > 1)\r\nverdict |= ATA_EH_SPDN_NCQ_OFF | ATA_EH_SPDN_KEEP_ERRORS;\r\nif (arg.nr_errors[ATA_ECAT_ATA_BUS] +\r\narg.nr_errors[ATA_ECAT_TOUT_HSM] +\r\narg.nr_errors[ATA_ECAT_UNK_DEV] > 6)\r\nverdict |= ATA_EH_SPDN_FALLBACK_TO_PIO;\r\nmemset(&arg, 0, sizeof(arg));\r\narg.since = j64 - min(j64, j10mins);\r\nata_ering_map(&dev->ering, speed_down_verdict_cb, &arg);\r\nif (arg.nr_errors[ATA_ECAT_TOUT_HSM] +\r\narg.nr_errors[ATA_ECAT_UNK_DEV] > 3)\r\nverdict |= ATA_EH_SPDN_NCQ_OFF;\r\nif (arg.nr_errors[ATA_ECAT_ATA_BUS] +\r\narg.nr_errors[ATA_ECAT_TOUT_HSM] > 3 ||\r\narg.nr_errors[ATA_ECAT_UNK_DEV] > 6)\r\nverdict |= ATA_EH_SPDN_SPEED_DOWN;\r\nreturn verdict;\r\n}\r\nstatic unsigned int ata_eh_speed_down(struct ata_device *dev,\r\nunsigned int eflags, unsigned int err_mask)\r\n{\r\nstruct ata_link *link = ata_dev_phys_link(dev);\r\nint xfer_ok = 0;\r\nunsigned int verdict;\r\nunsigned int action = 0;\r\nif (ata_eh_categorize_error(eflags, err_mask, &xfer_ok) == 0)\r\nreturn 0;\r\nata_ering_record(&dev->ering, eflags, err_mask);\r\nverdict = ata_eh_speed_down_verdict(dev);\r\nif ((verdict & ATA_EH_SPDN_NCQ_OFF) &&\r\n(dev->flags & (ATA_DFLAG_PIO | ATA_DFLAG_NCQ |\r\nATA_DFLAG_NCQ_OFF)) == ATA_DFLAG_NCQ) {\r\ndev->flags |= ATA_DFLAG_NCQ_OFF;\r\nata_dev_warn(dev, "NCQ disabled due to excessive errors\n");\r\ngoto done;\r\n}\r\nif (verdict & ATA_EH_SPDN_SPEED_DOWN) {\r\nif (sata_down_spd_limit(link, 0) == 0) {\r\naction |= ATA_EH_RESET;\r\ngoto done;\r\n}\r\nif (dev->spdn_cnt < 2) {\r\nstatic const int dma_dnxfer_sel[] =\r\n{ ATA_DNXFER_DMA, ATA_DNXFER_40C };\r\nstatic const int pio_dnxfer_sel[] =\r\n{ ATA_DNXFER_PIO, ATA_DNXFER_FORCE_PIO0 };\r\nint sel;\r\nif (dev->xfer_shift != ATA_SHIFT_PIO)\r\nsel = dma_dnxfer_sel[dev->spdn_cnt];\r\nelse\r\nsel = pio_dnxfer_sel[dev->spdn_cnt];\r\ndev->spdn_cnt++;\r\nif (ata_down_xfermask_limit(dev, sel) == 0) {\r\naction |= ATA_EH_RESET;\r\ngoto done;\r\n}\r\n}\r\n}\r\nif ((verdict & ATA_EH_SPDN_FALLBACK_TO_PIO) && (dev->spdn_cnt >= 2) &&\r\n(link->ap->cbl != ATA_CBL_SATA || dev->class == ATA_DEV_ATAPI) &&\r\n(dev->xfer_shift != ATA_SHIFT_PIO)) {\r\nif (ata_down_xfermask_limit(dev, ATA_DNXFER_FORCE_PIO) == 0) {\r\ndev->spdn_cnt = 0;\r\naction |= ATA_EH_RESET;\r\ngoto done;\r\n}\r\n}\r\nreturn 0;\r\ndone:\r\nif (!(verdict & ATA_EH_SPDN_KEEP_ERRORS))\r\nata_ering_clear(&dev->ering);\r\nreturn action;\r\n}\r\nstatic inline int ata_eh_worth_retry(struct ata_queued_cmd *qc)\r\n{\r\nif (qc->err_mask & AC_ERR_MEDIA)\r\nreturn 0;\r\nif (qc->flags & ATA_QCFLAG_IO)\r\nreturn 1;\r\nif (qc->err_mask & AC_ERR_INVALID)\r\nreturn 0;\r\nreturn qc->err_mask != AC_ERR_DEV;\r\n}\r\nstatic void ata_eh_link_autopsy(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nstruct ata_device *dev;\r\nunsigned int all_err_mask = 0, eflags = 0;\r\nint tag;\r\nu32 serror;\r\nint rc;\r\nDPRINTK("ENTER\n");\r\nif (ehc->i.flags & ATA_EHI_NO_AUTOPSY)\r\nreturn;\r\nrc = sata_scr_read(link, SCR_ERROR, &serror);\r\nif (rc == 0) {\r\nehc->i.serror |= serror;\r\nata_eh_analyze_serror(link);\r\n} else if (rc != -EOPNOTSUPP) {\r\nehc->i.probe_mask |= ATA_ALL_DEVICES;\r\nehc->i.action |= ATA_EH_RESET;\r\nehc->i.err_mask |= AC_ERR_OTHER;\r\n}\r\nata_eh_analyze_ncq_error(link);\r\nif (ehc->i.err_mask & ~AC_ERR_OTHER)\r\nehc->i.err_mask &= ~AC_ERR_OTHER;\r\nall_err_mask |= ehc->i.err_mask;\r\nfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\r\nstruct ata_queued_cmd *qc = __ata_qc_from_tag(ap, tag);\r\nif (!(qc->flags & ATA_QCFLAG_FAILED) ||\r\nata_dev_phys_link(qc->dev) != link)\r\ncontinue;\r\nqc->err_mask |= ehc->i.err_mask;\r\nehc->i.action |= ata_eh_analyze_tf(qc, &qc->result_tf);\r\nif (qc->err_mask & AC_ERR_ATA_BUS)\r\nqc->err_mask &= ~(AC_ERR_DEV | AC_ERR_MEDIA |\r\nAC_ERR_INVALID);\r\nif (qc->err_mask & ~AC_ERR_OTHER)\r\nqc->err_mask &= ~AC_ERR_OTHER;\r\nif (qc->flags & ATA_QCFLAG_SENSE_VALID)\r\nqc->err_mask &= ~(AC_ERR_DEV | AC_ERR_OTHER);\r\nif (ata_eh_worth_retry(qc))\r\nqc->flags |= ATA_QCFLAG_RETRY;\r\nehc->i.dev = qc->dev;\r\nall_err_mask |= qc->err_mask;\r\nif (qc->flags & ATA_QCFLAG_IO)\r\neflags |= ATA_EFLAG_IS_IO;\r\n}\r\nif (ap->pflags & ATA_PFLAG_FROZEN ||\r\nall_err_mask & (AC_ERR_HSM | AC_ERR_TIMEOUT))\r\nehc->i.action |= ATA_EH_RESET;\r\nelse if (((eflags & ATA_EFLAG_IS_IO) && all_err_mask) ||\r\n(!(eflags & ATA_EFLAG_IS_IO) && (all_err_mask & ~AC_ERR_DEV)))\r\nehc->i.action |= ATA_EH_REVALIDATE;\r\nif (ehc->i.dev) {\r\nehc->i.dev_action[ehc->i.dev->devno] |=\r\nehc->i.action & ATA_EH_PERDEV_MASK;\r\nehc->i.action &= ~ATA_EH_PERDEV_MASK;\r\n}\r\nif ((all_err_mask & AC_ERR_TIMEOUT) && !ata_is_host_link(link))\r\nap->link.eh_context.i.err_mask |= AC_ERR_TIMEOUT;\r\ndev = ehc->i.dev;\r\nif (!dev && ((ata_link_max_devices(link) == 1 &&\r\nata_dev_enabled(link->device))))\r\ndev = link->device;\r\nif (dev) {\r\nif (dev->flags & ATA_DFLAG_DUBIOUS_XFER)\r\neflags |= ATA_EFLAG_DUBIOUS_XFER;\r\nehc->i.action |= ata_eh_speed_down(dev, eflags, all_err_mask);\r\n}\r\nDPRINTK("EXIT\n");\r\n}\r\nvoid ata_eh_autopsy(struct ata_port *ap)\r\n{\r\nstruct ata_link *link;\r\nata_for_each_link(link, ap, EDGE)\r\nata_eh_link_autopsy(link);\r\nif (ap->slave_link) {\r\nstruct ata_eh_context *mehc = &ap->link.eh_context;\r\nstruct ata_eh_context *sehc = &ap->slave_link->eh_context;\r\nsehc->i.flags |= mehc->i.flags & ATA_EHI_TO_SLAVE_MASK;\r\nata_eh_link_autopsy(ap->slave_link);\r\nata_eh_about_to_do(ap->slave_link, NULL, ATA_EH_ALL_ACTIONS);\r\nmehc->i.action |= sehc->i.action;\r\nmehc->i.dev_action[1] |= sehc->i.dev_action[1];\r\nmehc->i.flags |= sehc->i.flags;\r\nata_eh_done(ap->slave_link, NULL, ATA_EH_ALL_ACTIONS);\r\n}\r\nif (sata_pmp_attached(ap))\r\nata_eh_link_autopsy(&ap->link);\r\n}\r\nconst char *ata_get_cmd_descript(u8 command)\r\n{\r\n#ifdef CONFIG_ATA_VERBOSE_ERROR\r\nstatic const struct\r\n{\r\nu8 command;\r\nconst char *text;\r\n} cmd_descr[] = {\r\n{ ATA_CMD_DEV_RESET, "DEVICE RESET" },\r\n{ ATA_CMD_CHK_POWER, "CHECK POWER MODE" },\r\n{ ATA_CMD_STANDBY, "STANDBY" },\r\n{ ATA_CMD_IDLE, "IDLE" },\r\n{ ATA_CMD_EDD, "EXECUTE DEVICE DIAGNOSTIC" },\r\n{ ATA_CMD_DOWNLOAD_MICRO, "DOWNLOAD MICROCODE" },\r\n{ ATA_CMD_NOP, "NOP" },\r\n{ ATA_CMD_FLUSH, "FLUSH CACHE" },\r\n{ ATA_CMD_FLUSH_EXT, "FLUSH CACHE EXT" },\r\n{ ATA_CMD_ID_ATA, "IDENTIFY DEVICE" },\r\n{ ATA_CMD_ID_ATAPI, "IDENTIFY PACKET DEVICE" },\r\n{ ATA_CMD_SERVICE, "SERVICE" },\r\n{ ATA_CMD_READ, "READ DMA" },\r\n{ ATA_CMD_READ_EXT, "READ DMA EXT" },\r\n{ ATA_CMD_READ_QUEUED, "READ DMA QUEUED" },\r\n{ ATA_CMD_READ_STREAM_EXT, "READ STREAM EXT" },\r\n{ ATA_CMD_READ_STREAM_DMA_EXT, "READ STREAM DMA EXT" },\r\n{ ATA_CMD_WRITE, "WRITE DMA" },\r\n{ ATA_CMD_WRITE_EXT, "WRITE DMA EXT" },\r\n{ ATA_CMD_WRITE_QUEUED, "WRITE DMA QUEUED EXT" },\r\n{ ATA_CMD_WRITE_STREAM_EXT, "WRITE STREAM EXT" },\r\n{ ATA_CMD_WRITE_STREAM_DMA_EXT, "WRITE STREAM DMA EXT" },\r\n{ ATA_CMD_WRITE_FUA_EXT, "WRITE DMA FUA EXT" },\r\n{ ATA_CMD_WRITE_QUEUED_FUA_EXT, "WRITE DMA QUEUED FUA EXT" },\r\n{ ATA_CMD_FPDMA_READ, "READ FPDMA QUEUED" },\r\n{ ATA_CMD_FPDMA_WRITE, "WRITE FPDMA QUEUED" },\r\n{ ATA_CMD_PIO_READ, "READ SECTOR(S)" },\r\n{ ATA_CMD_PIO_READ_EXT, "READ SECTOR(S) EXT" },\r\n{ ATA_CMD_PIO_WRITE, "WRITE SECTOR(S)" },\r\n{ ATA_CMD_PIO_WRITE_EXT, "WRITE SECTOR(S) EXT" },\r\n{ ATA_CMD_READ_MULTI, "READ MULTIPLE" },\r\n{ ATA_CMD_READ_MULTI_EXT, "READ MULTIPLE EXT" },\r\n{ ATA_CMD_WRITE_MULTI, "WRITE MULTIPLE" },\r\n{ ATA_CMD_WRITE_MULTI_EXT, "WRITE MULTIPLE EXT" },\r\n{ ATA_CMD_WRITE_MULTI_FUA_EXT, "WRITE MULTIPLE FUA EXT" },\r\n{ ATA_CMD_SET_FEATURES, "SET FEATURES" },\r\n{ ATA_CMD_SET_MULTI, "SET MULTIPLE MODE" },\r\n{ ATA_CMD_VERIFY, "READ VERIFY SECTOR(S)" },\r\n{ ATA_CMD_VERIFY_EXT, "READ VERIFY SECTOR(S) EXT" },\r\n{ ATA_CMD_WRITE_UNCORR_EXT, "WRITE UNCORRECTABLE EXT" },\r\n{ ATA_CMD_STANDBYNOW1, "STANDBY IMMEDIATE" },\r\n{ ATA_CMD_IDLEIMMEDIATE, "IDLE IMMEDIATE" },\r\n{ ATA_CMD_SLEEP, "SLEEP" },\r\n{ ATA_CMD_INIT_DEV_PARAMS, "INITIALIZE DEVICE PARAMETERS" },\r\n{ ATA_CMD_READ_NATIVE_MAX, "READ NATIVE MAX ADDRESS" },\r\n{ ATA_CMD_READ_NATIVE_MAX_EXT, "READ NATIVE MAX ADDRESS EXT" },\r\n{ ATA_CMD_SET_MAX, "SET MAX ADDRESS" },\r\n{ ATA_CMD_SET_MAX_EXT, "SET MAX ADDRESS EXT" },\r\n{ ATA_CMD_READ_LOG_EXT, "READ LOG EXT" },\r\n{ ATA_CMD_WRITE_LOG_EXT, "WRITE LOG EXT" },\r\n{ ATA_CMD_READ_LOG_DMA_EXT, "READ LOG DMA EXT" },\r\n{ ATA_CMD_WRITE_LOG_DMA_EXT, "WRITE LOG DMA EXT" },\r\n{ ATA_CMD_TRUSTED_RCV, "TRUSTED RECEIVE" },\r\n{ ATA_CMD_TRUSTED_RCV_DMA, "TRUSTED RECEIVE DMA" },\r\n{ ATA_CMD_TRUSTED_SND, "TRUSTED SEND" },\r\n{ ATA_CMD_TRUSTED_SND_DMA, "TRUSTED SEND DMA" },\r\n{ ATA_CMD_PMP_READ, "READ BUFFER" },\r\n{ ATA_CMD_PMP_WRITE, "WRITE BUFFER" },\r\n{ ATA_CMD_CONF_OVERLAY, "DEVICE CONFIGURATION OVERLAY" },\r\n{ ATA_CMD_SEC_SET_PASS, "SECURITY SET PASSWORD" },\r\n{ ATA_CMD_SEC_UNLOCK, "SECURITY UNLOCK" },\r\n{ ATA_CMD_SEC_ERASE_PREP, "SECURITY ERASE PREPARE" },\r\n{ ATA_CMD_SEC_ERASE_UNIT, "SECURITY ERASE UNIT" },\r\n{ ATA_CMD_SEC_FREEZE_LOCK, "SECURITY FREEZE LOCK" },\r\n{ ATA_CMD_SEC_DISABLE_PASS, "SECURITY DISABLE PASSWORD" },\r\n{ ATA_CMD_CONFIG_STREAM, "CONFIGURE STREAM" },\r\n{ ATA_CMD_SMART, "SMART" },\r\n{ ATA_CMD_MEDIA_LOCK, "DOOR LOCK" },\r\n{ ATA_CMD_MEDIA_UNLOCK, "DOOR UNLOCK" },\r\n{ ATA_CMD_DSM, "DATA SET MANAGEMENT" },\r\n{ ATA_CMD_CHK_MED_CRD_TYP, "CHECK MEDIA CARD TYPE" },\r\n{ ATA_CMD_CFA_REQ_EXT_ERR, "CFA REQUEST EXTENDED ERROR" },\r\n{ ATA_CMD_CFA_WRITE_NE, "CFA WRITE SECTORS WITHOUT ERASE" },\r\n{ ATA_CMD_CFA_TRANS_SECT, "CFA TRANSLATE SECTOR" },\r\n{ ATA_CMD_CFA_ERASE, "CFA ERASE SECTORS" },\r\n{ ATA_CMD_CFA_WRITE_MULT_NE, "CFA WRITE MULTIPLE WITHOUT ERASE" },\r\n{ ATA_CMD_READ_LONG, "READ LONG (with retries)" },\r\n{ ATA_CMD_READ_LONG_ONCE, "READ LONG (without retries)" },\r\n{ ATA_CMD_WRITE_LONG, "WRITE LONG (with retries)" },\r\n{ ATA_CMD_WRITE_LONG_ONCE, "WRITE LONG (without retries)" },\r\n{ ATA_CMD_RESTORE, "RECALIBRATE" },\r\n{ 0, NULL }\r\n};\r\nunsigned int i;\r\nfor (i = 0; cmd_descr[i].text; i++)\r\nif (cmd_descr[i].command == command)\r\nreturn cmd_descr[i].text;\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic void ata_eh_link_report(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nconst char *frozen, *desc;\r\nchar tries_buf[6];\r\nint tag, nr_failed = 0;\r\nif (ehc->i.flags & ATA_EHI_QUIET)\r\nreturn;\r\ndesc = NULL;\r\nif (ehc->i.desc[0] != '\0')\r\ndesc = ehc->i.desc;\r\nfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\r\nstruct ata_queued_cmd *qc = __ata_qc_from_tag(ap, tag);\r\nif (!(qc->flags & ATA_QCFLAG_FAILED) ||\r\nata_dev_phys_link(qc->dev) != link ||\r\n((qc->flags & ATA_QCFLAG_QUIET) &&\r\nqc->err_mask == AC_ERR_DEV))\r\ncontinue;\r\nif (qc->flags & ATA_QCFLAG_SENSE_VALID && !qc->err_mask)\r\ncontinue;\r\nnr_failed++;\r\n}\r\nif (!nr_failed && !ehc->i.err_mask)\r\nreturn;\r\nfrozen = "";\r\nif (ap->pflags & ATA_PFLAG_FROZEN)\r\nfrozen = " frozen";\r\nmemset(tries_buf, 0, sizeof(tries_buf));\r\nif (ap->eh_tries < ATA_EH_MAX_TRIES)\r\nsnprintf(tries_buf, sizeof(tries_buf) - 1, " t%d",\r\nap->eh_tries);\r\nif (ehc->i.dev) {\r\nata_dev_err(ehc->i.dev, "exception Emask 0x%x "\r\n"SAct 0x%x SErr 0x%x action 0x%x%s%s\n",\r\nehc->i.err_mask, link->sactive, ehc->i.serror,\r\nehc->i.action, frozen, tries_buf);\r\nif (desc)\r\nata_dev_err(ehc->i.dev, "%s\n", desc);\r\n} else {\r\nata_link_err(link, "exception Emask 0x%x "\r\n"SAct 0x%x SErr 0x%x action 0x%x%s%s\n",\r\nehc->i.err_mask, link->sactive, ehc->i.serror,\r\nehc->i.action, frozen, tries_buf);\r\nif (desc)\r\nata_link_err(link, "%s\n", desc);\r\n}\r\n#ifdef CONFIG_ATA_VERBOSE_ERROR\r\nif (ehc->i.serror)\r\nata_link_err(link,\r\n"SError: { %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s}\n",\r\nehc->i.serror & SERR_DATA_RECOVERED ? "RecovData " : "",\r\nehc->i.serror & SERR_COMM_RECOVERED ? "RecovComm " : "",\r\nehc->i.serror & SERR_DATA ? "UnrecovData " : "",\r\nehc->i.serror & SERR_PERSISTENT ? "Persist " : "",\r\nehc->i.serror & SERR_PROTOCOL ? "Proto " : "",\r\nehc->i.serror & SERR_INTERNAL ? "HostInt " : "",\r\nehc->i.serror & SERR_PHYRDY_CHG ? "PHYRdyChg " : "",\r\nehc->i.serror & SERR_PHY_INT_ERR ? "PHYInt " : "",\r\nehc->i.serror & SERR_COMM_WAKE ? "CommWake " : "",\r\nehc->i.serror & SERR_10B_8B_ERR ? "10B8B " : "",\r\nehc->i.serror & SERR_DISPARITY ? "Dispar " : "",\r\nehc->i.serror & SERR_CRC ? "BadCRC " : "",\r\nehc->i.serror & SERR_HANDSHAKE ? "Handshk " : "",\r\nehc->i.serror & SERR_LINK_SEQ_ERR ? "LinkSeq " : "",\r\nehc->i.serror & SERR_TRANS_ST_ERROR ? "TrStaTrns " : "",\r\nehc->i.serror & SERR_UNRECOG_FIS ? "UnrecFIS " : "",\r\nehc->i.serror & SERR_DEV_XCHG ? "DevExch " : "");\r\n#endif\r\nfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\r\nstruct ata_queued_cmd *qc = __ata_qc_from_tag(ap, tag);\r\nstruct ata_taskfile *cmd = &qc->tf, *res = &qc->result_tf;\r\nconst u8 *cdb = qc->cdb;\r\nchar data_buf[20] = "";\r\nchar cdb_buf[70] = "";\r\nif (!(qc->flags & ATA_QCFLAG_FAILED) ||\r\nata_dev_phys_link(qc->dev) != link || !qc->err_mask)\r\ncontinue;\r\nif (qc->dma_dir != DMA_NONE) {\r\nstatic const char *dma_str[] = {\r\n[DMA_BIDIRECTIONAL] = "bidi",\r\n[DMA_TO_DEVICE] = "out",\r\n[DMA_FROM_DEVICE] = "in",\r\n};\r\nstatic const char *prot_str[] = {\r\n[ATA_PROT_PIO] = "pio",\r\n[ATA_PROT_DMA] = "dma",\r\n[ATA_PROT_NCQ] = "ncq",\r\n[ATAPI_PROT_PIO] = "pio",\r\n[ATAPI_PROT_DMA] = "dma",\r\n};\r\nsnprintf(data_buf, sizeof(data_buf), " %s %u %s",\r\nprot_str[qc->tf.protocol], qc->nbytes,\r\ndma_str[qc->dma_dir]);\r\n}\r\nif (ata_is_atapi(qc->tf.protocol)) {\r\nif (qc->scsicmd)\r\nscsi_print_command(qc->scsicmd);\r\nelse\r\nsnprintf(cdb_buf, sizeof(cdb_buf),\r\n"cdb %02x %02x %02x %02x %02x %02x %02x %02x "\r\n"%02x %02x %02x %02x %02x %02x %02x %02x\n ",\r\ncdb[0], cdb[1], cdb[2], cdb[3],\r\ncdb[4], cdb[5], cdb[6], cdb[7],\r\ncdb[8], cdb[9], cdb[10], cdb[11],\r\ncdb[12], cdb[13], cdb[14], cdb[15]);\r\n} else {\r\nconst char *descr = ata_get_cmd_descript(cmd->command);\r\nif (descr)\r\nata_dev_err(qc->dev, "failed command: %s\n",\r\ndescr);\r\n}\r\nata_dev_err(qc->dev,\r\n"cmd %02x/%02x:%02x:%02x:%02x:%02x/%02x:%02x:%02x:%02x:%02x/%02x "\r\n"tag %d%s\n %s"\r\n"res %02x/%02x:%02x:%02x:%02x:%02x/%02x:%02x:%02x:%02x:%02x/%02x "\r\n"Emask 0x%x (%s)%s\n",\r\ncmd->command, cmd->feature, cmd->nsect,\r\ncmd->lbal, cmd->lbam, cmd->lbah,\r\ncmd->hob_feature, cmd->hob_nsect,\r\ncmd->hob_lbal, cmd->hob_lbam, cmd->hob_lbah,\r\ncmd->device, qc->tag, data_buf, cdb_buf,\r\nres->command, res->feature, res->nsect,\r\nres->lbal, res->lbam, res->lbah,\r\nres->hob_feature, res->hob_nsect,\r\nres->hob_lbal, res->hob_lbam, res->hob_lbah,\r\nres->device, qc->err_mask, ata_err_string(qc->err_mask),\r\nqc->err_mask & AC_ERR_NCQ ? " <F>" : "");\r\n#ifdef CONFIG_ATA_VERBOSE_ERROR\r\nif (res->command & (ATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ |\r\nATA_ERR)) {\r\nif (res->command & ATA_BUSY)\r\nata_dev_err(qc->dev, "status: { Busy }\n");\r\nelse\r\nata_dev_err(qc->dev, "status: { %s%s%s%s}\n",\r\nres->command & ATA_DRDY ? "DRDY " : "",\r\nres->command & ATA_DF ? "DF " : "",\r\nres->command & ATA_DRQ ? "DRQ " : "",\r\nres->command & ATA_ERR ? "ERR " : "");\r\n}\r\nif (cmd->command != ATA_CMD_PACKET &&\r\n(res->feature & (ATA_ICRC | ATA_UNC | ATA_IDNF |\r\nATA_ABORTED)))\r\nata_dev_err(qc->dev, "error: { %s%s%s%s}\n",\r\nres->feature & ATA_ICRC ? "ICRC " : "",\r\nres->feature & ATA_UNC ? "UNC " : "",\r\nres->feature & ATA_IDNF ? "IDNF " : "",\r\nres->feature & ATA_ABORTED ? "ABRT " : "");\r\n#endif\r\n}\r\n}\r\nvoid ata_eh_report(struct ata_port *ap)\r\n{\r\nstruct ata_link *link;\r\nata_for_each_link(link, ap, HOST_FIRST)\r\nata_eh_link_report(link);\r\n}\r\nstatic int ata_do_reset(struct ata_link *link, ata_reset_fn_t reset,\r\nunsigned int *classes, unsigned long deadline,\r\nbool clear_classes)\r\n{\r\nstruct ata_device *dev;\r\nif (clear_classes)\r\nata_for_each_dev(dev, link, ALL)\r\nclasses[dev->devno] = ATA_DEV_UNKNOWN;\r\nreturn reset(link, classes, deadline);\r\n}\r\nstatic int ata_eh_followup_srst_needed(struct ata_link *link, int rc)\r\n{\r\nif ((link->flags & ATA_LFLAG_NO_SRST) || ata_link_offline(link))\r\nreturn 0;\r\nif (rc == -EAGAIN)\r\nreturn 1;\r\nif (sata_pmp_supported(link->ap) && ata_is_host_link(link))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint ata_eh_reset(struct ata_link *link, int classify,\r\nata_prereset_fn_t prereset, ata_reset_fn_t softreset,\r\nata_reset_fn_t hardreset, ata_postreset_fn_t postreset)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_link *slave = ap->slave_link;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nstruct ata_eh_context *sehc = slave ? &slave->eh_context : NULL;\r\nunsigned int *classes = ehc->classes;\r\nunsigned int lflags = link->flags;\r\nint verbose = !(ehc->i.flags & ATA_EHI_QUIET);\r\nint max_tries = 0, try = 0;\r\nstruct ata_link *failed_link;\r\nstruct ata_device *dev;\r\nunsigned long deadline, now;\r\nata_reset_fn_t reset;\r\nunsigned long flags;\r\nu32 sstatus;\r\nint nr_unknown, rc;\r\nwhile (ata_eh_reset_timeouts[max_tries] != ULONG_MAX)\r\nmax_tries++;\r\nif (link->flags & ATA_LFLAG_RST_ONCE)\r\nmax_tries = 1;\r\nif (link->flags & ATA_LFLAG_NO_HRST)\r\nhardreset = NULL;\r\nif (link->flags & ATA_LFLAG_NO_SRST)\r\nsoftreset = NULL;\r\nif (ehc->i.flags & ATA_EHI_DID_RESET) {\r\nnow = jiffies;\r\nWARN_ON(time_after(ehc->last_reset, now));\r\ndeadline = ata_deadline(ehc->last_reset,\r\nATA_EH_RESET_COOL_DOWN);\r\nif (time_before(now, deadline))\r\nschedule_timeout_uninterruptible(deadline - now);\r\n}\r\nspin_lock_irqsave(ap->lock, flags);\r\nap->pflags |= ATA_PFLAG_RESETTING;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nata_eh_about_to_do(link, NULL, ATA_EH_RESET);\r\nata_for_each_dev(dev, link, ALL) {\r\ndev->pio_mode = XFER_PIO_0;\r\ndev->dma_mode = 0xff;\r\nif (ap->ops->set_piomode)\r\nap->ops->set_piomode(ap, dev);\r\n}\r\nreset = NULL;\r\nehc->i.action &= ~ATA_EH_RESET;\r\nif (hardreset) {\r\nreset = hardreset;\r\nehc->i.action |= ATA_EH_HARDRESET;\r\n} else if (softreset) {\r\nreset = softreset;\r\nehc->i.action |= ATA_EH_SOFTRESET;\r\n}\r\nif (prereset) {\r\nunsigned long deadline = ata_deadline(jiffies,\r\nATA_EH_PRERESET_TIMEOUT);\r\nif (slave) {\r\nsehc->i.action &= ~ATA_EH_RESET;\r\nsehc->i.action |= ehc->i.action;\r\n}\r\nrc = prereset(link, deadline);\r\nif (slave && (rc == 0 || rc == -ENOENT)) {\r\nint tmp;\r\ntmp = prereset(slave, deadline);\r\nif (tmp != -ENOENT)\r\nrc = tmp;\r\nehc->i.action |= sehc->i.action;\r\n}\r\nif (rc) {\r\nif (rc == -ENOENT) {\r\nata_link_dbg(link, "port disabled--ignoring\n");\r\nehc->i.action &= ~ATA_EH_RESET;\r\nata_for_each_dev(dev, link, ALL)\r\nclasses[dev->devno] = ATA_DEV_NONE;\r\nrc = 0;\r\n} else\r\nata_link_err(link,\r\n"prereset failed (errno=%d)\n",\r\nrc);\r\ngoto out;\r\n}\r\nif (reset && !(ehc->i.action & ATA_EH_RESET)) {\r\nata_for_each_dev(dev, link, ALL)\r\nclasses[dev->devno] = ATA_DEV_NONE;\r\nif ((ap->pflags & ATA_PFLAG_FROZEN) &&\r\nata_is_host_link(link))\r\nata_eh_thaw_port(ap);\r\nrc = 0;\r\ngoto out;\r\n}\r\n}\r\nretry:\r\nif (ata_is_host_link(link))\r\nata_eh_freeze_port(ap);\r\ndeadline = ata_deadline(jiffies, ata_eh_reset_timeouts[try++]);\r\nif (reset) {\r\nif (verbose)\r\nata_link_info(link, "%s resetting link\n",\r\nreset == softreset ? "soft" : "hard");\r\nehc->last_reset = jiffies;\r\nif (reset == hardreset)\r\nehc->i.flags |= ATA_EHI_DID_HARDRESET;\r\nelse\r\nehc->i.flags |= ATA_EHI_DID_SOFTRESET;\r\nrc = ata_do_reset(link, reset, classes, deadline, true);\r\nif (rc && rc != -EAGAIN) {\r\nfailed_link = link;\r\ngoto fail;\r\n}\r\nif (slave && reset == hardreset) {\r\nint tmp;\r\nif (verbose)\r\nata_link_info(slave, "hard resetting link\n");\r\nata_eh_about_to_do(slave, NULL, ATA_EH_RESET);\r\ntmp = ata_do_reset(slave, reset, classes, deadline,\r\nfalse);\r\nswitch (tmp) {\r\ncase -EAGAIN:\r\nrc = -EAGAIN;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nfailed_link = slave;\r\nrc = tmp;\r\ngoto fail;\r\n}\r\n}\r\nif (reset == hardreset &&\r\nata_eh_followup_srst_needed(link, rc)) {\r\nreset = softreset;\r\nif (!reset) {\r\nata_link_err(link,\r\n"follow-up softreset required but no softreset available\n");\r\nfailed_link = link;\r\nrc = -EINVAL;\r\ngoto fail;\r\n}\r\nata_eh_about_to_do(link, NULL, ATA_EH_RESET);\r\nrc = ata_do_reset(link, reset, classes, deadline, true);\r\nif (rc) {\r\nfailed_link = link;\r\ngoto fail;\r\n}\r\n}\r\n} else {\r\nif (verbose)\r\nata_link_info(link,\r\n"no reset method available, skipping reset\n");\r\nif (!(lflags & ATA_LFLAG_ASSUME_CLASS))\r\nlflags |= ATA_LFLAG_ASSUME_ATA;\r\n}\r\nata_for_each_dev(dev, link, ALL) {\r\ndev->pio_mode = XFER_PIO_0;\r\ndev->flags &= ~ATA_DFLAG_SLEEPING;\r\nif (ata_phys_link_offline(ata_dev_phys_link(dev)))\r\ncontinue;\r\nif (lflags & ATA_LFLAG_ASSUME_ATA)\r\nclasses[dev->devno] = ATA_DEV_ATA;\r\nelse if (lflags & ATA_LFLAG_ASSUME_SEMB)\r\nclasses[dev->devno] = ATA_DEV_SEMB_UNSUP;\r\n}\r\nif (sata_scr_read(link, SCR_STATUS, &sstatus) == 0)\r\nlink->sata_spd = (sstatus >> 4) & 0xf;\r\nif (slave && sata_scr_read(slave, SCR_STATUS, &sstatus) == 0)\r\nslave->sata_spd = (sstatus >> 4) & 0xf;\r\nif (ata_is_host_link(link))\r\nata_eh_thaw_port(ap);\r\nif (postreset) {\r\npostreset(link, classes);\r\nif (slave)\r\npostreset(slave, classes);\r\n}\r\nspin_lock_irqsave(link->ap->lock, flags);\r\nmemset(&link->eh_info, 0, sizeof(link->eh_info));\r\nif (slave)\r\nmemset(&slave->eh_info, 0, sizeof(link->eh_info));\r\nap->pflags &= ~ATA_PFLAG_EH_PENDING;\r\nspin_unlock_irqrestore(link->ap->lock, flags);\r\nif (ap->pflags & ATA_PFLAG_FROZEN)\r\nata_eh_thaw_port(ap);\r\nnr_unknown = 0;\r\nata_for_each_dev(dev, link, ALL) {\r\nif (ata_phys_link_online(ata_dev_phys_link(dev))) {\r\nif (classes[dev->devno] == ATA_DEV_UNKNOWN) {\r\nata_dev_dbg(dev, "link online but device misclassified\n");\r\nclasses[dev->devno] = ATA_DEV_NONE;\r\nnr_unknown++;\r\n}\r\n} else if (ata_phys_link_offline(ata_dev_phys_link(dev))) {\r\nif (ata_class_enabled(classes[dev->devno]))\r\nata_dev_dbg(dev,\r\n"link offline, clearing class %d to NONE\n",\r\nclasses[dev->devno]);\r\nclasses[dev->devno] = ATA_DEV_NONE;\r\n} else if (classes[dev->devno] == ATA_DEV_UNKNOWN) {\r\nata_dev_dbg(dev,\r\n"link status unknown, clearing UNKNOWN to NONE\n");\r\nclasses[dev->devno] = ATA_DEV_NONE;\r\n}\r\n}\r\nif (classify && nr_unknown) {\r\nif (try < max_tries) {\r\nata_link_warn(link,\r\n"link online but %d devices misclassified, retrying\n",\r\nnr_unknown);\r\nfailed_link = link;\r\nrc = -EAGAIN;\r\ngoto fail;\r\n}\r\nata_link_warn(link,\r\n"link online but %d devices misclassified, "\r\n"device detection might fail\n", nr_unknown);\r\n}\r\nata_eh_done(link, NULL, ATA_EH_RESET);\r\nif (slave)\r\nata_eh_done(slave, NULL, ATA_EH_RESET);\r\nehc->last_reset = jiffies;\r\nehc->i.action |= ATA_EH_REVALIDATE;\r\nlink->lpm_policy = ATA_LPM_UNKNOWN;\r\nrc = 0;\r\nout:\r\nehc->i.flags &= ~ATA_EHI_HOTPLUGGED;\r\nif (slave)\r\nsehc->i.flags &= ~ATA_EHI_HOTPLUGGED;\r\nspin_lock_irqsave(ap->lock, flags);\r\nap->pflags &= ~ATA_PFLAG_RESETTING;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn rc;\r\nfail:\r\nif (!ata_is_host_link(link) &&\r\nsata_scr_read(link, SCR_STATUS, &sstatus))\r\nrc = -ERESTART;\r\nif (try >= max_tries) {\r\nif (ata_is_host_link(link))\r\nata_eh_thaw_port(ap);\r\ngoto out;\r\n}\r\nnow = jiffies;\r\nif (time_before(now, deadline)) {\r\nunsigned long delta = deadline - now;\r\nata_link_warn(failed_link,\r\n"reset failed (errno=%d), retrying in %u secs\n",\r\nrc, DIV_ROUND_UP(jiffies_to_msecs(delta), 1000));\r\nata_eh_release(ap);\r\nwhile (delta)\r\ndelta = schedule_timeout_uninterruptible(delta);\r\nata_eh_acquire(ap);\r\n}\r\nif (rc == -ERESTART) {\r\nif (ata_is_host_link(link))\r\nata_eh_thaw_port(ap);\r\ngoto out;\r\n}\r\nif (try == max_tries - 1) {\r\nsata_down_spd_limit(link, 0);\r\nif (slave)\r\nsata_down_spd_limit(slave, 0);\r\n} else if (rc == -EPIPE)\r\nsata_down_spd_limit(failed_link, 0);\r\nif (hardreset)\r\nreset = hardreset;\r\ngoto retry;\r\n}\r\nstatic inline void ata_eh_pull_park_action(struct ata_port *ap)\r\n{\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(ap->lock, flags);\r\nINIT_COMPLETION(ap->park_req_pending);\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ALL) {\r\nstruct ata_eh_info *ehi = &link->eh_info;\r\nlink->eh_context.i.dev_action[dev->devno] |=\r\nehi->dev_action[dev->devno] & ATA_EH_PARK;\r\nata_eh_clear_action(link, dev, ehi, ATA_EH_PARK);\r\n}\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nstatic void ata_eh_park_issue_cmd(struct ata_device *dev, int park)\r\n{\r\nstruct ata_eh_context *ehc = &dev->link->eh_context;\r\nstruct ata_taskfile tf;\r\nunsigned int err_mask;\r\nata_tf_init(dev, &tf);\r\nif (park) {\r\nehc->unloaded_mask |= 1 << dev->devno;\r\ntf.command = ATA_CMD_IDLEIMMEDIATE;\r\ntf.feature = 0x44;\r\ntf.lbal = 0x4c;\r\ntf.lbam = 0x4e;\r\ntf.lbah = 0x55;\r\n} else {\r\nehc->unloaded_mask &= ~(1 << dev->devno);\r\ntf.command = ATA_CMD_CHK_POWER;\r\n}\r\ntf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\r\ntf.protocol |= ATA_PROT_NODATA;\r\nerr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\r\nif (park && (err_mask || tf.lbal != 0xc4)) {\r\nata_dev_err(dev, "head unload failed!\n");\r\nehc->unloaded_mask &= ~(1 << dev->devno);\r\n}\r\n}\r\nstatic int ata_eh_revalidate_and_attach(struct ata_link *link,\r\nstruct ata_device **r_failed_dev)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nstruct ata_device *dev;\r\nunsigned int new_mask = 0;\r\nunsigned long flags;\r\nint rc = 0;\r\nDPRINTK("ENTER\n");\r\nata_for_each_dev(dev, link, ALL_REVERSE) {\r\nunsigned int action = ata_eh_dev_action(dev);\r\nunsigned int readid_flags = 0;\r\nif (ehc->i.flags & ATA_EHI_DID_RESET)\r\nreadid_flags |= ATA_READID_POSTRESET;\r\nif ((action & ATA_EH_REVALIDATE) && ata_dev_enabled(dev)) {\r\nWARN_ON(dev->class == ATA_DEV_PMP);\r\nif (ata_phys_link_offline(ata_dev_phys_link(dev))) {\r\nrc = -EIO;\r\ngoto err;\r\n}\r\nata_eh_about_to_do(link, dev, ATA_EH_REVALIDATE);\r\nrc = ata_dev_revalidate(dev, ehc->classes[dev->devno],\r\nreadid_flags);\r\nif (rc)\r\ngoto err;\r\nata_eh_done(link, dev, ATA_EH_REVALIDATE);\r\nehc->i.flags |= ATA_EHI_SETMODE;\r\nschedule_work(&(ap->scsi_rescan_task));\r\n} else if (dev->class == ATA_DEV_UNKNOWN &&\r\nehc->tries[dev->devno] &&\r\nata_class_enabled(ehc->classes[dev->devno])) {\r\ndev->class = ehc->classes[dev->devno];\r\nif (dev->class == ATA_DEV_PMP)\r\nrc = sata_pmp_attach(dev);\r\nelse\r\nrc = ata_dev_read_id(dev, &dev->class,\r\nreadid_flags, dev->id);\r\nehc->classes[dev->devno] = dev->class;\r\ndev->class = ATA_DEV_UNKNOWN;\r\nswitch (rc) {\r\ncase 0:\r\nata_ering_clear(&dev->ering);\r\nnew_mask |= 1 << dev->devno;\r\nbreak;\r\ncase -ENOENT:\r\nata_eh_thaw_port(ap);\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\n}\r\n}\r\nif ((ehc->i.flags & ATA_EHI_DID_RESET) && ata_is_host_link(link)) {\r\nif (ap->ops->cable_detect)\r\nap->cbl = ap->ops->cable_detect(ap);\r\nata_force_cbl(ap);\r\n}\r\nata_for_each_dev(dev, link, ALL) {\r\nif (!(new_mask & (1 << dev->devno)))\r\ncontinue;\r\ndev->class = ehc->classes[dev->devno];\r\nif (dev->class == ATA_DEV_PMP)\r\ncontinue;\r\nehc->i.flags |= ATA_EHI_PRINTINFO;\r\nrc = ata_dev_configure(dev);\r\nehc->i.flags &= ~ATA_EHI_PRINTINFO;\r\nif (rc) {\r\ndev->class = ATA_DEV_UNKNOWN;\r\ngoto err;\r\n}\r\nspin_lock_irqsave(ap->lock, flags);\r\nap->pflags |= ATA_PFLAG_SCSI_HOTPLUG;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nehc->i.flags |= ATA_EHI_SETMODE;\r\n}\r\nreturn 0;\r\nerr:\r\n*r_failed_dev = dev;\r\nDPRINTK("EXIT rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nint ata_set_mode(struct ata_link *link, struct ata_device **r_failed_dev)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_device *dev;\r\nint rc;\r\nata_for_each_dev(dev, link, ENABLED) {\r\nif (!(dev->flags & ATA_DFLAG_DUBIOUS_XFER)) {\r\nstruct ata_ering_entry *ent;\r\nent = ata_ering_top(&dev->ering);\r\nif (ent)\r\nent->eflags &= ~ATA_EFLAG_DUBIOUS_XFER;\r\n}\r\n}\r\nif (ap->ops->set_mode)\r\nrc = ap->ops->set_mode(link, r_failed_dev);\r\nelse\r\nrc = ata_do_set_mode(link, r_failed_dev);\r\nata_for_each_dev(dev, link, ENABLED) {\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nu8 saved_xfer_mode = ehc->saved_xfer_mode[dev->devno];\r\nu8 saved_ncq = !!(ehc->saved_ncq_enabled & (1 << dev->devno));\r\nif (dev->xfer_mode != saved_xfer_mode ||\r\nata_ncq_enabled(dev) != saved_ncq)\r\ndev->flags |= ATA_DFLAG_DUBIOUS_XFER;\r\n}\r\nreturn rc;\r\n}\r\nstatic int atapi_eh_clear_ua(struct ata_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < ATA_EH_UA_TRIES; i++) {\r\nu8 *sense_buffer = dev->link->ap->sector_buf;\r\nu8 sense_key = 0;\r\nunsigned int err_mask;\r\nerr_mask = atapi_eh_tur(dev, &sense_key);\r\nif (err_mask != 0 && err_mask != AC_ERR_DEV) {\r\nata_dev_warn(dev,\r\n"TEST_UNIT_READY failed (err_mask=0x%x)\n",\r\nerr_mask);\r\nreturn -EIO;\r\n}\r\nif (!err_mask || sense_key != UNIT_ATTENTION)\r\nreturn 0;\r\nerr_mask = atapi_eh_request_sense(dev, sense_buffer, sense_key);\r\nif (err_mask) {\r\nata_dev_warn(dev, "failed to clear "\r\n"UNIT ATTENTION (err_mask=0x%x)\n", err_mask);\r\nreturn -EIO;\r\n}\r\n}\r\nata_dev_warn(dev, "UNIT ATTENTION persists after %d tries\n",\r\nATA_EH_UA_TRIES);\r\nreturn 0;\r\n}\r\nstatic int ata_eh_maybe_retry_flush(struct ata_device *dev)\r\n{\r\nstruct ata_link *link = dev->link;\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_queued_cmd *qc;\r\nstruct ata_taskfile tf;\r\nunsigned int err_mask;\r\nint rc = 0;\r\nif (!ata_tag_valid(link->active_tag))\r\nreturn 0;\r\nqc = __ata_qc_from_tag(ap, link->active_tag);\r\nif (qc->dev != dev || (qc->tf.command != ATA_CMD_FLUSH_EXT &&\r\nqc->tf.command != ATA_CMD_FLUSH))\r\nreturn 0;\r\nif (qc->err_mask & AC_ERR_DEV)\r\nreturn 0;\r\nata_tf_init(dev, &tf);\r\ntf.command = qc->tf.command;\r\ntf.flags |= ATA_TFLAG_DEVICE;\r\ntf.protocol = ATA_PROT_NODATA;\r\nata_dev_warn(dev, "retrying FLUSH 0x%x Emask 0x%x\n",\r\ntf.command, qc->err_mask);\r\nerr_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);\r\nif (!err_mask) {\r\nqc->scsicmd->allowed = max(qc->scsicmd->allowed, 1);\r\n} else {\r\nata_dev_warn(dev, "FLUSH failed Emask 0x%x\n",\r\nerr_mask);\r\nrc = -EIO;\r\nif (err_mask & AC_ERR_DEV) {\r\nqc->err_mask |= AC_ERR_DEV;\r\nqc->result_tf = tf;\r\nif (!(ap->pflags & ATA_PFLAG_FROZEN))\r\nrc = 0;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\r\nstruct ata_device **r_failed_dev)\r\n{\r\nstruct ata_port *ap = ata_is_host_link(link) ? link->ap : NULL;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nstruct ata_device *dev, *link_dev = NULL, *lpm_dev = NULL;\r\nenum ata_lpm_policy old_policy = link->lpm_policy;\r\nbool no_dipm = link->ap->flags & ATA_FLAG_NO_DIPM;\r\nunsigned int hints = ATA_LPM_EMPTY | ATA_LPM_HIPM;\r\nunsigned int err_mask;\r\nint rc;\r\nif ((link->flags & ATA_LFLAG_NO_LPM) || (ap && !ap->ops->set_lpm))\r\nreturn 0;\r\nata_for_each_dev(dev, link, ENABLED) {\r\nbool hipm = ata_id_has_hipm(dev->id);\r\nbool dipm = ata_id_has_dipm(dev->id) && !no_dipm;\r\nif (!link_dev)\r\nlink_dev = dev;\r\nif (!lpm_dev && (hipm || dipm))\r\nlpm_dev = dev;\r\nhints &= ~ATA_LPM_EMPTY;\r\nif (!hipm)\r\nhints &= ~ATA_LPM_HIPM;\r\nif (policy != ATA_LPM_MIN_POWER && dipm) {\r\nerr_mask = ata_dev_set_feature(dev,\r\nSETFEATURES_SATA_DISABLE, SATA_DIPM);\r\nif (err_mask && err_mask != AC_ERR_DEV) {\r\nata_dev_warn(dev,\r\n"failed to disable DIPM, Emask 0x%x\n",\r\nerr_mask);\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n}\r\n}\r\nif (ap) {\r\nrc = ap->ops->set_lpm(link, policy, hints);\r\nif (!rc && ap->slave_link)\r\nrc = ap->ops->set_lpm(ap->slave_link, policy, hints);\r\n} else\r\nrc = sata_pmp_set_lpm(link, policy, hints);\r\nif (rc) {\r\nif (rc == -EOPNOTSUPP) {\r\nlink->flags |= ATA_LFLAG_NO_LPM;\r\nreturn 0;\r\n}\r\ndev = lpm_dev ? lpm_dev : link_dev;\r\ngoto fail;\r\n}\r\nlink->lpm_policy = policy;\r\nif (ap && ap->slave_link)\r\nap->slave_link->lpm_policy = policy;\r\nata_for_each_dev(dev, link, ENABLED) {\r\nif (policy == ATA_LPM_MIN_POWER && !no_dipm &&\r\nata_id_has_dipm(dev->id)) {\r\nerr_mask = ata_dev_set_feature(dev,\r\nSETFEATURES_SATA_ENABLE, SATA_DIPM);\r\nif (err_mask && err_mask != AC_ERR_DEV) {\r\nata_dev_warn(dev,\r\n"failed to enable DIPM, Emask 0x%x\n",\r\nerr_mask);\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nlink->lpm_policy = old_policy;\r\nif (ap && ap->slave_link)\r\nap->slave_link->lpm_policy = old_policy;\r\nif (!dev || ehc->tries[dev->devno] <= 2) {\r\nata_link_warn(link, "disabling LPM on the link\n");\r\nlink->flags |= ATA_LFLAG_NO_LPM;\r\n}\r\nif (r_failed_dev)\r\n*r_failed_dev = dev;\r\nreturn rc;\r\n}\r\nint ata_link_nr_enabled(struct ata_link *link)\r\n{\r\nstruct ata_device *dev;\r\nint cnt = 0;\r\nata_for_each_dev(dev, link, ENABLED)\r\ncnt++;\r\nreturn cnt;\r\n}\r\nstatic int ata_link_nr_vacant(struct ata_link *link)\r\n{\r\nstruct ata_device *dev;\r\nint cnt = 0;\r\nata_for_each_dev(dev, link, ALL)\r\nif (dev->class == ATA_DEV_UNKNOWN)\r\ncnt++;\r\nreturn cnt;\r\n}\r\nstatic int ata_eh_skip_recovery(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nstruct ata_device *dev;\r\nif (link->flags & ATA_LFLAG_DISABLED)\r\nreturn 1;\r\nif (ehc->i.flags & ATA_EHI_NO_RECOVERY)\r\nreturn 1;\r\nif ((ap->pflags & ATA_PFLAG_FROZEN) || ata_link_nr_enabled(link))\r\nreturn 0;\r\nif ((ehc->i.action & ATA_EH_RESET) &&\r\n!(ehc->i.flags & ATA_EHI_DID_RESET))\r\nreturn 0;\r\nata_for_each_dev(dev, link, ALL) {\r\nif (dev->class == ATA_DEV_UNKNOWN &&\r\nehc->classes[dev->devno] != ATA_DEV_NONE)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int ata_count_probe_trials_cb(struct ata_ering_entry *ent, void *void_arg)\r\n{\r\nu64 interval = msecs_to_jiffies(ATA_EH_PROBE_TRIAL_INTERVAL);\r\nu64 now = get_jiffies_64();\r\nint *trials = void_arg;\r\nif ((ent->eflags & ATA_EFLAG_OLD_ER) ||\r\n(ent->timestamp < now - min(now, interval)))\r\nreturn -1;\r\n(*trials)++;\r\nreturn 0;\r\n}\r\nstatic int ata_eh_schedule_probe(struct ata_device *dev)\r\n{\r\nstruct ata_eh_context *ehc = &dev->link->eh_context;\r\nstruct ata_link *link = ata_dev_phys_link(dev);\r\nint trials = 0;\r\nif (!(ehc->i.probe_mask & (1 << dev->devno)) ||\r\n(ehc->did_probe_mask & (1 << dev->devno)))\r\nreturn 0;\r\nata_eh_detach_dev(dev);\r\nata_dev_init(dev);\r\nehc->did_probe_mask |= (1 << dev->devno);\r\nehc->i.action |= ATA_EH_RESET;\r\nehc->saved_xfer_mode[dev->devno] = 0;\r\nehc->saved_ncq_enabled &= ~(1 << dev->devno);\r\nif (link->lpm_policy > ATA_LPM_MAX_POWER) {\r\nif (ata_is_host_link(link))\r\nlink->ap->ops->set_lpm(link, ATA_LPM_MAX_POWER,\r\nATA_LPM_EMPTY);\r\nelse\r\nsata_pmp_set_lpm(link, ATA_LPM_MAX_POWER,\r\nATA_LPM_EMPTY);\r\n}\r\nata_ering_record(&dev->ering, 0, AC_ERR_OTHER);\r\nata_ering_map(&dev->ering, ata_count_probe_trials_cb, &trials);\r\nif (trials > ATA_EH_PROBE_TRIALS)\r\nsata_down_spd_limit(link, 1);\r\nreturn 1;\r\n}\r\nstatic int ata_eh_handle_dev_fail(struct ata_device *dev, int err)\r\n{\r\nstruct ata_eh_context *ehc = &dev->link->eh_context;\r\nif (err != -EAGAIN)\r\nehc->tries[dev->devno]--;\r\nswitch (err) {\r\ncase -ENODEV:\r\nehc->i.probe_mask |= (1 << dev->devno);\r\ncase -EINVAL:\r\nehc->tries[dev->devno] = min(ehc->tries[dev->devno], 1);\r\ncase -EIO:\r\nif (ehc->tries[dev->devno] == 1) {\r\nsata_down_spd_limit(ata_dev_phys_link(dev), 0);\r\nif (dev->pio_mode > XFER_PIO_0)\r\nata_down_xfermask_limit(dev, ATA_DNXFER_PIO);\r\n}\r\n}\r\nif (ata_dev_enabled(dev) && !ehc->tries[dev->devno]) {\r\nata_dev_disable(dev);\r\nif (ata_phys_link_offline(ata_dev_phys_link(dev)))\r\nata_eh_detach_dev(dev);\r\nif (ata_eh_schedule_probe(dev)) {\r\nehc->tries[dev->devno] = ATA_EH_DEV_TRIES;\r\nmemset(ehc->cmd_timeout_idx[dev->devno], 0,\r\nsizeof(ehc->cmd_timeout_idx[dev->devno]));\r\n}\r\nreturn 1;\r\n} else {\r\nehc->i.action |= ATA_EH_RESET;\r\nreturn 0;\r\n}\r\n}\r\nint ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,\r\nata_reset_fn_t softreset, ata_reset_fn_t hardreset,\r\nata_postreset_fn_t postreset,\r\nstruct ata_link **r_failed_link)\r\n{\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nint rc, nr_fails;\r\nunsigned long flags, deadline;\r\nDPRINTK("ENTER\n");\r\nata_for_each_link(link, ap, EDGE) {\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nif (ehc->i.action & ATA_EH_ENABLE_LINK) {\r\nata_eh_about_to_do(link, NULL, ATA_EH_ENABLE_LINK);\r\nspin_lock_irqsave(ap->lock, flags);\r\nlink->flags &= ~ATA_LFLAG_DISABLED;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nata_eh_done(link, NULL, ATA_EH_ENABLE_LINK);\r\n}\r\nata_for_each_dev(dev, link, ALL) {\r\nif (link->flags & ATA_LFLAG_NO_RETRY)\r\nehc->tries[dev->devno] = 1;\r\nelse\r\nehc->tries[dev->devno] = ATA_EH_DEV_TRIES;\r\nehc->i.action |= ehc->i.dev_action[dev->devno] &\r\n~ATA_EH_PERDEV_MASK;\r\nehc->i.dev_action[dev->devno] &= ATA_EH_PERDEV_MASK;\r\nif (dev->flags & ATA_DFLAG_DETACH)\r\nata_eh_detach_dev(dev);\r\nif (!ata_dev_enabled(dev))\r\nata_eh_schedule_probe(dev);\r\n}\r\n}\r\nretry:\r\nrc = 0;\r\nif (ap->pflags & ATA_PFLAG_UNLOADING)\r\ngoto out;\r\nata_for_each_link(link, ap, EDGE) {\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nif (ata_eh_skip_recovery(link))\r\nehc->i.action = 0;\r\nata_for_each_dev(dev, link, ALL)\r\nehc->classes[dev->devno] = ATA_DEV_UNKNOWN;\r\n}\r\nata_for_each_link(link, ap, EDGE) {\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nif (!(ehc->i.action & ATA_EH_RESET))\r\ncontinue;\r\nrc = ata_eh_reset(link, ata_link_nr_vacant(link),\r\nprereset, softreset, hardreset, postreset);\r\nif (rc) {\r\nata_link_err(link, "reset failed, giving up\n");\r\ngoto out;\r\n}\r\n}\r\ndo {\r\nunsigned long now;\r\nata_eh_pull_park_action(ap);\r\ndeadline = jiffies;\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ALL) {\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nunsigned long tmp;\r\nif (dev->class != ATA_DEV_ATA)\r\ncontinue;\r\nif (!(ehc->i.dev_action[dev->devno] &\r\nATA_EH_PARK))\r\ncontinue;\r\ntmp = dev->unpark_deadline;\r\nif (time_before(deadline, tmp))\r\ndeadline = tmp;\r\nelse if (time_before_eq(tmp, jiffies))\r\ncontinue;\r\nif (ehc->unloaded_mask & (1 << dev->devno))\r\ncontinue;\r\nata_eh_park_issue_cmd(dev, 1);\r\n}\r\n}\r\nnow = jiffies;\r\nif (time_before_eq(deadline, now))\r\nbreak;\r\nata_eh_release(ap);\r\ndeadline = wait_for_completion_timeout(&ap->park_req_pending,\r\ndeadline - now);\r\nata_eh_acquire(ap);\r\n} while (deadline);\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ALL) {\r\nif (!(link->eh_context.unloaded_mask &\r\n(1 << dev->devno)))\r\ncontinue;\r\nata_eh_park_issue_cmd(dev, 0);\r\nata_eh_done(link, dev, ATA_EH_PARK);\r\n}\r\n}\r\nnr_fails = 0;\r\nata_for_each_link(link, ap, PMP_FIRST) {\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nif (sata_pmp_attached(ap) && ata_is_host_link(link))\r\ngoto config_lpm;\r\nrc = ata_eh_revalidate_and_attach(link, &dev);\r\nif (rc)\r\ngoto rest_fail;\r\nif (link->device->class == ATA_DEV_PMP) {\r\nehc->i.action = 0;\r\nreturn 0;\r\n}\r\nif (ehc->i.flags & ATA_EHI_SETMODE) {\r\nrc = ata_set_mode(link, &dev);\r\nif (rc)\r\ngoto rest_fail;\r\nehc->i.flags &= ~ATA_EHI_SETMODE;\r\n}\r\nif (ehc->i.flags & ATA_EHI_DID_RESET) {\r\nata_for_each_dev(dev, link, ALL) {\r\nif (dev->class != ATA_DEV_ATAPI)\r\ncontinue;\r\nrc = atapi_eh_clear_ua(dev);\r\nif (rc)\r\ngoto rest_fail;\r\nif (zpodd_dev_enabled(dev))\r\nzpodd_post_poweron(dev);\r\n}\r\n}\r\nata_for_each_dev(dev, link, ALL) {\r\nif (dev->class != ATA_DEV_ATA)\r\ncontinue;\r\nrc = ata_eh_maybe_retry_flush(dev);\r\nif (rc)\r\ngoto rest_fail;\r\n}\r\nconfig_lpm:\r\nif (link->lpm_policy != ap->target_lpm_policy) {\r\nrc = ata_eh_set_lpm(link, ap->target_lpm_policy, &dev);\r\nif (rc)\r\ngoto rest_fail;\r\n}\r\nehc->i.flags = 0;\r\ncontinue;\r\nrest_fail:\r\nnr_fails++;\r\nif (dev)\r\nata_eh_handle_dev_fail(dev, rc);\r\nif (ap->pflags & ATA_PFLAG_FROZEN) {\r\nif (sata_pmp_attached(ap))\r\ngoto out;\r\nbreak;\r\n}\r\n}\r\nif (nr_fails)\r\ngoto retry;\r\nout:\r\nif (rc && r_failed_link)\r\n*r_failed_link = link;\r\nDPRINTK("EXIT, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nvoid ata_eh_finish(struct ata_port *ap)\r\n{\r\nint tag;\r\nfor (tag = 0; tag < ATA_MAX_QUEUE; tag++) {\r\nstruct ata_queued_cmd *qc = __ata_qc_from_tag(ap, tag);\r\nif (!(qc->flags & ATA_QCFLAG_FAILED))\r\ncontinue;\r\nif (qc->err_mask) {\r\nif (qc->flags & ATA_QCFLAG_RETRY)\r\nata_eh_qc_retry(qc);\r\nelse\r\nata_eh_qc_complete(qc);\r\n} else {\r\nif (qc->flags & ATA_QCFLAG_SENSE_VALID) {\r\nata_eh_qc_complete(qc);\r\n} else {\r\nmemset(&qc->result_tf, 0, sizeof(qc->result_tf));\r\nata_eh_qc_retry(qc);\r\n}\r\n}\r\n}\r\nWARN_ON(ap->nr_active_links);\r\nap->nr_active_links = 0;\r\n}\r\nvoid ata_do_eh(struct ata_port *ap, ata_prereset_fn_t prereset,\r\nata_reset_fn_t softreset, ata_reset_fn_t hardreset,\r\nata_postreset_fn_t postreset)\r\n{\r\nstruct ata_device *dev;\r\nint rc;\r\nata_eh_autopsy(ap);\r\nata_eh_report(ap);\r\nrc = ata_eh_recover(ap, prereset, softreset, hardreset, postreset,\r\nNULL);\r\nif (rc) {\r\nata_for_each_dev(dev, &ap->link, ALL)\r\nata_dev_disable(dev);\r\n}\r\nata_eh_finish(ap);\r\n}\r\nvoid ata_std_error_handler(struct ata_port *ap)\r\n{\r\nstruct ata_port_operations *ops = ap->ops;\r\nata_reset_fn_t hardreset = ops->hardreset;\r\nif (hardreset == sata_std_hardreset && !sata_scr_valid(&ap->link))\r\nhardreset = NULL;\r\nata_do_eh(ap, ops->prereset, ops->softreset, hardreset, ops->postreset);\r\n}\r\nstatic void ata_eh_handle_port_suspend(struct ata_port *ap)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nstruct ata_device *dev;\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (!(ap->pflags & ATA_PFLAG_PM_PENDING) ||\r\nap->pm_mesg.event & PM_EVENT_RESUME) {\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nWARN_ON(ap->pflags & ATA_PFLAG_SUSPENDED);\r\nif (PMSG_IS_AUTO(ap->pm_mesg)) {\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nif (zpodd_dev_enabled(dev))\r\nzpodd_on_suspend(dev);\r\n}\r\n}\r\nrc = ata_acpi_on_suspend(ap);\r\nif (rc)\r\ngoto out;\r\nata_eh_freeze_port(ap);\r\nif (ap->ops->port_suspend)\r\nrc = ap->ops->port_suspend(ap, ap->pm_mesg);\r\nata_acpi_set_state(ap, ap->pm_mesg);\r\nout:\r\nspin_lock_irqsave(ap->lock, flags);\r\nap->pflags &= ~ATA_PFLAG_PM_PENDING;\r\nif (rc == 0)\r\nap->pflags |= ATA_PFLAG_SUSPENDED;\r\nelse if (ap->pflags & ATA_PFLAG_FROZEN)\r\nata_port_schedule_eh(ap);\r\nif (ap->pm_result) {\r\n*ap->pm_result = rc;\r\nap->pm_result = NULL;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn;\r\n}\r\nstatic void ata_eh_handle_port_resume(struct ata_port *ap)\r\n{\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (!(ap->pflags & ATA_PFLAG_PM_PENDING) ||\r\n!(ap->pm_mesg.event & PM_EVENT_RESUME)) {\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nWARN_ON(!(ap->pflags & ATA_PFLAG_SUSPENDED));\r\nata_for_each_link(link, ap, HOST_FIRST)\r\nata_for_each_dev(dev, link, ALL)\r\nata_ering_clear(&dev->ering);\r\nata_acpi_set_state(ap, ap->pm_mesg);\r\nif (ap->ops->port_resume)\r\nrc = ap->ops->port_resume(ap);\r\nata_acpi_on_resume(ap);\r\nspin_lock_irqsave(ap->lock, flags);\r\nap->pflags &= ~(ATA_PFLAG_PM_PENDING | ATA_PFLAG_SUSPENDED);\r\nif (ap->pm_result) {\r\n*ap->pm_result = rc;\r\nap->pm_result = NULL;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}
