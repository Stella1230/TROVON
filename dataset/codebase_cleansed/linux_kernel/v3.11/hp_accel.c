static inline void delayed_set_status_worker(struct work_struct *work)\r\n{\r\nstruct delayed_led_classdev *data =\r\ncontainer_of(work, struct delayed_led_classdev, work);\r\ndata->set_brightness(data, data->new_brightness);\r\n}\r\nstatic inline void delayed_sysfs_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct delayed_led_classdev *data = container_of(led_cdev,\r\nstruct delayed_led_classdev, led_classdev);\r\ndata->new_brightness = brightness;\r\nschedule_work(&data->work);\r\n}\r\nint lis3lv02d_acpi_init(struct lis3lv02d *lis3)\r\n{\r\nstruct acpi_device *dev = lis3->bus_priv;\r\nif (acpi_evaluate_object(dev->handle, METHOD_NAME__INI,\r\nNULL, NULL) != AE_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint lis3lv02d_acpi_read(struct lis3lv02d *lis3, int reg, u8 *ret)\r\n{\r\nstruct acpi_device *dev = lis3->bus_priv;\r\nunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\r\nstruct acpi_object_list args = { 1, &arg0 };\r\nunsigned long long lret;\r\nacpi_status status;\r\narg0.integer.value = reg;\r\nstatus = acpi_evaluate_integer(dev->handle, "ALRD", &args, &lret);\r\n*ret = lret;\r\nreturn (status != AE_OK) ? -EINVAL : 0;\r\n}\r\nint lis3lv02d_acpi_write(struct lis3lv02d *lis3, int reg, u8 val)\r\n{\r\nstruct acpi_device *dev = lis3->bus_priv;\r\nunsigned long long ret;\r\nunion acpi_object in_obj[2];\r\nstruct acpi_object_list args = { 2, in_obj };\r\nin_obj[0].type = ACPI_TYPE_INTEGER;\r\nin_obj[0].integer.value = reg;\r\nin_obj[1].type = ACPI_TYPE_INTEGER;\r\nin_obj[1].integer.value = val;\r\nif (acpi_evaluate_integer(dev->handle, "ALWR", &args, &ret) != AE_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int lis3lv02d_dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\nlis3_dev.ac = *((union axis_conversion *)dmi->driver_data);\r\npr_info("hardware type %s found\n", dmi->ident);\r\nreturn 1;\r\n}\r\nstatic void hpled_set(struct delayed_led_classdev *led_cdev, enum led_brightness value)\r\n{\r\nstruct acpi_device *dev = lis3_dev.bus_priv;\r\nunsigned long long ret;\r\nunion acpi_object in_obj[1];\r\nstruct acpi_object_list args = { 1, in_obj };\r\nin_obj[0].type = ACPI_TYPE_INTEGER;\r\nin_obj[0].integer.value = !!value;\r\nacpi_evaluate_integer(dev->handle, "ALED", &args, &ret);\r\n}\r\nstatic acpi_status\r\nlis3lv02d_get_resource(struct acpi_resource *resource, void *context)\r\n{\r\nif (resource->type == ACPI_RESOURCE_TYPE_EXTENDED_IRQ) {\r\nstruct acpi_resource_extended_irq *irq;\r\nu32 *device_irq = context;\r\nirq = &resource->data.extended_irq;\r\n*device_irq = irq->interrupts[0];\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic void lis3lv02d_enum_resources(struct acpi_device *device)\r\n{\r\nacpi_status status;\r\nstatus = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\r\nlis3lv02d_get_resource, &lis3_dev.irq);\r\nif (ACPI_FAILURE(status))\r\nprintk(KERN_DEBUG DRIVER_NAME ": Error getting resources\n");\r\n}\r\nstatic int lis3lv02d_add(struct acpi_device *device)\r\n{\r\nint ret;\r\nif (!device)\r\nreturn -EINVAL;\r\nlis3_dev.bus_priv = device;\r\nlis3_dev.init = lis3lv02d_acpi_init;\r\nlis3_dev.read = lis3lv02d_acpi_read;\r\nlis3_dev.write = lis3lv02d_acpi_write;\r\nstrcpy(acpi_device_name(device), DRIVER_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_MDPS_CLASS);\r\ndevice->driver_data = &lis3_dev;\r\nlis3lv02d_enum_resources(device);\r\nif (lis3_dev.ac.x && lis3_dev.ac.y && lis3_dev.ac.z) {\r\npr_info("Using custom axes %d,%d,%d\n",\r\nlis3_dev.ac.x, lis3_dev.ac.y, lis3_dev.ac.z);\r\n} else if (dmi_check_system(lis3lv02d_dmi_ids) == 0) {\r\npr_info("laptop model unknown, using default axes configuration\n");\r\nlis3_dev.ac = lis3lv02d_axis_normal;\r\n}\r\nret = lis3lv02d_init_device(&lis3_dev);\r\nif (ret)\r\nreturn ret;\r\nINIT_WORK(&hpled_led.work, delayed_set_status_worker);\r\nret = led_classdev_register(NULL, &hpled_led.led_classdev);\r\nif (ret) {\r\nlis3lv02d_joystick_disable(&lis3_dev);\r\nlis3lv02d_poweroff(&lis3_dev);\r\nflush_work(&hpled_led.work);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int lis3lv02d_remove(struct acpi_device *device)\r\n{\r\nif (!device)\r\nreturn -EINVAL;\r\nlis3lv02d_joystick_disable(&lis3_dev);\r\nlis3lv02d_poweroff(&lis3_dev);\r\nled_classdev_unregister(&hpled_led.led_classdev);\r\nflush_work(&hpled_led.work);\r\nreturn lis3lv02d_remove_fs(&lis3_dev);\r\n}\r\nstatic int lis3lv02d_suspend(struct device *dev)\r\n{\r\nlis3lv02d_poweroff(&lis3_dev);\r\nreturn 0;\r\n}\r\nstatic int lis3lv02d_resume(struct device *dev)\r\n{\r\nlis3lv02d_poweron(&lis3_dev);\r\nreturn 0;\r\n}
