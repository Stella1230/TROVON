static void dc_link_event(struct ipu_dc *dc, int event, int addr, int priority)\r\n{\r\nu32 reg;\r\nreg = readl(dc->base + DC_RL_CH(event));\r\nreg &= ~(0xffff << (16 * (event & 0x1)));\r\nreg |= ((addr << 8) | priority) << (16 * (event & 0x1));\r\nwritel(reg, dc->base + DC_RL_CH(event));\r\n}\r\nstatic void dc_write_tmpl(struct ipu_dc *dc, int word, u32 opcode, u32 operand,\r\nint map, int wave, int glue, int sync, int stop)\r\n{\r\nstruct ipu_dc_priv *priv = dc->priv;\r\nu32 reg1, reg2;\r\nif (opcode == WCLK) {\r\nreg1 = (operand << 20) & 0xfff00000;\r\nreg2 = operand >> 12 | opcode << 1 | stop << 9;\r\n} else if (opcode == WRG) {\r\nreg1 = sync | glue << 4 | ++wave << 11 | ((operand << 15) & 0xffff8000);\r\nreg2 = operand >> 17 | opcode << 7 | stop << 9;\r\n} else {\r\nreg1 = sync | glue << 4 | ++wave << 11 | ++map << 15 | ((operand << 20) & 0xfff00000);\r\nreg2 = operand >> 12 | opcode << 4 | stop << 9;\r\n}\r\nwritel(reg1, priv->dc_tmpl_reg + word * 8);\r\nwritel(reg2, priv->dc_tmpl_reg + word * 8 + 4);\r\n}\r\nstatic int ipu_pixfmt_to_map(u32 fmt)\r\n{\r\nswitch (fmt) {\r\ncase V4L2_PIX_FMT_RGB24:\r\nreturn IPU_DC_MAP_RGB24;\r\ncase V4L2_PIX_FMT_RGB565:\r\nreturn IPU_DC_MAP_RGB565;\r\ncase IPU_PIX_FMT_GBR24:\r\nreturn IPU_DC_MAP_GBR24;\r\ncase V4L2_PIX_FMT_BGR666:\r\nreturn IPU_DC_MAP_BGR666;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint ipu_dc_init_sync(struct ipu_dc *dc, struct ipu_di *di, bool interlaced,\r\nu32 pixel_fmt, u32 width)\r\n{\r\nstruct ipu_dc_priv *priv = dc->priv;\r\nu32 reg = 0, map;\r\ndc->di = ipu_di_get_num(di);\r\nmap = ipu_pixfmt_to_map(pixel_fmt);\r\nif (map < 0) {\r\ndev_dbg(priv->dev, "IPU_DISP: No MAP\n");\r\nreturn -EINVAL;\r\n}\r\nif (interlaced) {\r\ndc_link_event(dc, DC_EVT_NL, 0, 3);\r\ndc_link_event(dc, DC_EVT_EOL, 0, 2);\r\ndc_link_event(dc, DC_EVT_NEW_DATA, 0, 1);\r\ndc_write_tmpl(dc, 0, WROD(0), 0, map, SYNC_WAVE, 0, 8, 1);\r\n} else {\r\nif (dc->di) {\r\ndc_link_event(dc, DC_EVT_NL, 2, 3);\r\ndc_link_event(dc, DC_EVT_EOL, 3, 2);\r\ndc_link_event(dc, DC_EVT_NEW_DATA, 1, 1);\r\ndc_write_tmpl(dc, 2, WROD(0), 0, map, SYNC_WAVE, 8, 5, 1);\r\ndc_write_tmpl(dc, 3, WROD(0), 0, map, SYNC_WAVE, 4, 5, 0);\r\ndc_write_tmpl(dc, 4, WRG, 0, map, NULL_WAVE, 0, 0, 1);\r\ndc_write_tmpl(dc, 1, WROD(0), 0, map, SYNC_WAVE, 0, 5, 1);\r\n} else {\r\ndc_link_event(dc, DC_EVT_NL, 5, 3);\r\ndc_link_event(dc, DC_EVT_EOL, 6, 2);\r\ndc_link_event(dc, DC_EVT_NEW_DATA, 8, 1);\r\ndc_write_tmpl(dc, 5, WROD(0), 0, map, SYNC_WAVE, 8, 5, 1);\r\ndc_write_tmpl(dc, 6, WROD(0), 0, map, SYNC_WAVE, 4, 5, 0);\r\ndc_write_tmpl(dc, 7, WRG, 0, map, NULL_WAVE, 0, 0, 1);\r\ndc_write_tmpl(dc, 8, WROD(0), 0, map, SYNC_WAVE, 0, 5, 1);\r\n}\r\n}\r\ndc_link_event(dc, DC_EVT_NF, 0, 0);\r\ndc_link_event(dc, DC_EVT_NFIELD, 0, 0);\r\ndc_link_event(dc, DC_EVT_EOF, 0, 0);\r\ndc_link_event(dc, DC_EVT_EOFIELD, 0, 0);\r\ndc_link_event(dc, DC_EVT_NEW_CHAN, 0, 0);\r\ndc_link_event(dc, DC_EVT_NEW_ADDR, 0, 0);\r\nreg = readl(dc->base + DC_WR_CH_CONF);\r\nif (interlaced)\r\nreg |= DC_WR_CH_CONF_FIELD_MODE;\r\nelse\r\nreg &= ~DC_WR_CH_CONF_FIELD_MODE;\r\nwritel(reg, dc->base + DC_WR_CH_CONF);\r\nwritel(0x0, dc->base + DC_WR_CH_ADDR);\r\nwritel(width, priv->dc_reg + DC_DISP_CONF2(dc->di));\r\nipu_module_enable(priv->ipu, IPU_CONF_DC_EN);\r\nreturn 0;\r\n}\r\nvoid ipu_dc_enable_channel(struct ipu_dc *dc)\r\n{\r\nint di;\r\nu32 reg;\r\ndi = dc->di;\r\nreg = readl(dc->base + DC_WR_CH_CONF);\r\nreg |= DC_WR_CH_CONF_PROG_TYPE_NORMAL;\r\nwritel(reg, dc->base + DC_WR_CH_CONF);\r\n}\r\nvoid ipu_dc_disable_channel(struct ipu_dc *dc)\r\n{\r\nstruct ipu_dc_priv *priv = dc->priv;\r\nu32 val;\r\nint irq = 0, timeout = 50;\r\nif (dc->chno == 1)\r\nirq = IPU_IRQ_DC_FC_1;\r\nelse if (dc->chno == 5)\r\nirq = IPU_IRQ_DP_SF_END;\r\nelse\r\nreturn;\r\nmdelay(50);\r\nif (dc->di == 0)\r\nval = 0x00000002;\r\nelse\r\nval = 0x00000020;\r\nwhile ((readl(priv->dc_reg + DC_STAT) & val) != val) {\r\nmsleep(2);\r\ntimeout -= 2;\r\nif (timeout <= 0)\r\nbreak;\r\n}\r\nval = readl(dc->base + DC_WR_CH_CONF);\r\nval &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;\r\nwritel(val, dc->base + DC_WR_CH_CONF);\r\n}\r\nstatic void ipu_dc_map_config(struct ipu_dc_priv *priv, enum ipu_dc_map map,\r\nint byte_num, int offset, int mask)\r\n{\r\nint ptr = map * 3 + byte_num;\r\nu32 reg;\r\nreg = readl(priv->dc_reg + DC_MAP_CONF_VAL(ptr));\r\nreg &= ~(0xffff << (16 * (ptr & 0x1)));\r\nreg |= ((offset << 8) | mask) << (16 * (ptr & 0x1));\r\nwritel(reg, priv->dc_reg + DC_MAP_CONF_VAL(ptr));\r\nreg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));\r\nreg &= ~(0x1f << ((16 * (map & 0x1)) + (5 * byte_num)));\r\nreg |= ptr << ((16 * (map & 0x1)) + (5 * byte_num));\r\nwritel(reg, priv->dc_reg + DC_MAP_CONF_PTR(map));\r\n}\r\nstatic void ipu_dc_map_clear(struct ipu_dc_priv *priv, int map)\r\n{\r\nu32 reg = readl(priv->dc_reg + DC_MAP_CONF_PTR(map));\r\nwritel(reg & ~(0xffff << (16 * (map & 0x1))),\r\npriv->dc_reg + DC_MAP_CONF_PTR(map));\r\n}\r\nstruct ipu_dc *ipu_dc_get(struct ipu_soc *ipu, int channel)\r\n{\r\nstruct ipu_dc_priv *priv = ipu->dc_priv;\r\nstruct ipu_dc *dc;\r\nif (channel >= IPU_DC_NUM_CHANNELS)\r\nreturn ERR_PTR(-ENODEV);\r\ndc = &priv->channels[channel];\r\nmutex_lock(&priv->mutex);\r\nif (dc->in_use) {\r\nmutex_unlock(&priv->mutex);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\ndc->in_use = 1;\r\nmutex_unlock(&priv->mutex);\r\nreturn dc;\r\n}\r\nvoid ipu_dc_put(struct ipu_dc *dc)\r\n{\r\nstruct ipu_dc_priv *priv = dc->priv;\r\nmutex_lock(&priv->mutex);\r\ndc->in_use = 0;\r\nmutex_unlock(&priv->mutex);\r\n}\r\nint ipu_dc_init(struct ipu_soc *ipu, struct device *dev,\r\nunsigned long base, unsigned long template_base)\r\n{\r\nstruct ipu_dc_priv *priv;\r\nstatic int channel_offsets[] = { 0, 0x1c, 0x38, 0x54, 0x58, 0x5c,\r\n0x78, 0, 0x94, 0xb4};\r\nint i;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->mutex);\r\npriv->dev = dev;\r\npriv->ipu = ipu;\r\npriv->dc_reg = devm_ioremap(dev, base, PAGE_SIZE);\r\npriv->dc_tmpl_reg = devm_ioremap(dev, template_base, PAGE_SIZE);\r\nif (!priv->dc_reg || !priv->dc_tmpl_reg)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < IPU_DC_NUM_CHANNELS; i++) {\r\npriv->channels[i].chno = i;\r\npriv->channels[i].priv = priv;\r\npriv->channels[i].base = priv->dc_reg + channel_offsets[i];\r\n}\r\nwritel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(1) |\r\nDC_WR_CH_CONF_PROG_DI_ID,\r\npriv->channels[1].base + DC_WR_CH_CONF);\r\nwritel(DC_WR_CH_CONF_WORD_SIZE_24 | DC_WR_CH_CONF_DISP_ID_PARALLEL(0),\r\npriv->channels[5].base + DC_WR_CH_CONF);\r\nwritel(DC_GEN_SYNC_1_6_SYNC | DC_GEN_SYNC_PRIORITY_1, priv->dc_reg + DC_GEN);\r\nipu->dc_priv = priv;\r\ndev_dbg(dev, "DC base: 0x%08lx template base: 0x%08lx\n",\r\nbase, template_base);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_RGB24);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 0, 7, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 1, 15, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB24, 2, 23, 0xff);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_RGB565);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 0, 4, 0xf8);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 1, 10, 0xfc);\r\nipu_dc_map_config(priv, IPU_DC_MAP_RGB565, 2, 15, 0xf8);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_GBR24);\r\nipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 2, 15, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 1, 7, 0xff);\r\nipu_dc_map_config(priv, IPU_DC_MAP_GBR24, 0, 23, 0xff);\r\nipu_dc_map_clear(priv, IPU_DC_MAP_BGR666);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 0, 5, 0xfc);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 1, 11, 0xfc);\r\nipu_dc_map_config(priv, IPU_DC_MAP_BGR666, 2, 17, 0xfc);\r\nreturn 0;\r\n}\r\nvoid ipu_dc_exit(struct ipu_soc *ipu)\r\n{\r\n}
