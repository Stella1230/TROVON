static inline u32 rotl(u32 val, int bits)\r\n{\r\nreturn (val << bits) | (val >> (32 - bits));\r\n}\r\nstatic inline u32 rotr(u32 val, int bits)\r\n{\r\nreturn (val >> bits) | (val << (32 - bits));\r\n}\r\nstatic inline u32 xswap(u32 val)\r\n{\r\nreturn ((val & 0x00ff00ff) << 8) | ((val & 0xff00ff00) >> 8);\r\n}\r\nstatic inline u32 get_le32(const u8 *p)\r\n{\r\nreturn p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);\r\n}\r\nstatic inline void put_le32(u8 *p, u32 v)\r\n{\r\np[0] = v;\r\np[1] = v >> 8;\r\np[2] = v >> 16;\r\np[3] = v >> 24;\r\n}\r\nstatic void michael_init(void *ctx)\r\n{\r\nstruct michael_mic_ctx *mctx = ctx;\r\nmctx->pending_len = 0;\r\n}\r\nstatic void michael_update(void *ctx, const u8 *data, unsigned int len)\r\n{\r\nstruct michael_mic_ctx *mctx = ctx;\r\nif (mctx->pending_len) {\r\nint flen = 4 - mctx->pending_len;\r\nif (flen > len)\r\nflen = len;\r\nmemcpy(&mctx->pending[mctx->pending_len], data, flen);\r\nmctx->pending_len += flen;\r\ndata += flen;\r\nlen -= flen;\r\nif (mctx->pending_len < 4)\r\nreturn;\r\nmctx->l ^= get_le32(mctx->pending);\r\nmichael_block(mctx->l, mctx->r);\r\nmctx->pending_len = 0;\r\n}\r\nwhile (len >= 4) {\r\nmctx->l ^= get_le32(data);\r\nmichael_block(mctx->l, mctx->r);\r\ndata += 4;\r\nlen -= 4;\r\n}\r\nif (len > 0) {\r\nmctx->pending_len = len;\r\nmemcpy(mctx->pending, data, len);\r\n}\r\n}\r\nstatic void michael_final(void *ctx, u8 *out)\r\n{\r\nstruct michael_mic_ctx *mctx = ctx;\r\nu8 *data = mctx->pending;\r\nswitch (mctx->pending_len) {\r\ncase 0:\r\nmctx->l ^= 0x5a;\r\nbreak;\r\ncase 1:\r\nmctx->l ^= data[0] | 0x5a00;\r\nbreak;\r\ncase 2:\r\nmctx->l ^= data[0] | (data[1] << 8) | 0x5a0000;\r\nbreak;\r\ncase 3:\r\nmctx->l ^= data[0] | (data[1] << 8) | (data[2] << 16) |\r\n0x5a000000;\r\nbreak;\r\n}\r\nmichael_block(mctx->l, mctx->r);\r\nmichael_block(mctx->l, mctx->r);\r\nput_le32(out, mctx->l);\r\nput_le32(out + 4, mctx->r);\r\n}\r\nstatic int michael_setkey(void *ctx, const u8 *key, unsigned int keylen,\r\nu32 *flags)\r\n{\r\nstruct michael_mic_ctx *mctx = ctx;\r\nif (keylen != 8) {\r\nif (flags)\r\n*flags = CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nmctx->l = get_le32(key);\r\nmctx->r = get_le32(key + 4);\r\nreturn 0;\r\n}\r\nstatic int __init michael_mic_init(void)\r\n{\r\nreturn crypto_register_alg(&michael_mic_alg);\r\n}\r\nstatic void __exit michael_mic_exit(void)\r\n{\r\ncrypto_unregister_alg(&michael_mic_alg);\r\n}
