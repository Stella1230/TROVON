static void pca_isa_writebyte(void *pd, int reg, int val)\r\n{\r\n#ifdef DEBUG_IO\r\nstatic char *names[] = { "T/O", "DAT", "ADR", "CON" };\r\nprintk(KERN_DEBUG "*** write %s at %#lx <= %#04x\n", names[reg],\r\nbase+reg, val);\r\n#endif\r\noutb(val, base+reg);\r\n}\r\nstatic int pca_isa_readbyte(void *pd, int reg)\r\n{\r\nint res = inb(base+reg);\r\n#ifdef DEBUG_IO\r\n{\r\nstatic char *names[] = { "STA", "DAT", "ADR", "CON" };\r\nprintk(KERN_DEBUG "*** read %s => %#04x\n", names[reg], res);\r\n}\r\n#endif\r\nreturn res;\r\n}\r\nstatic int pca_isa_waitforcompletion(void *pd)\r\n{\r\nunsigned long timeout;\r\nlong ret;\r\nif (irq > -1) {\r\nret = wait_event_timeout(pca_wait,\r\npca_isa_readbyte(pd, I2C_PCA_CON)\r\n& I2C_PCA_CON_SI, pca_isa_ops.timeout);\r\n} else {\r\ntimeout = jiffies + pca_isa_ops.timeout;\r\ndo {\r\nret = time_before(jiffies, timeout);\r\nif (pca_isa_readbyte(pd, I2C_PCA_CON)\r\n& I2C_PCA_CON_SI)\r\nbreak;\r\nudelay(100);\r\n} while (ret);\r\n}\r\nreturn ret > 0;\r\n}\r\nstatic void pca_isa_resetchip(void *pd)\r\n{\r\nprintk(KERN_WARNING DRIVER ": Haven't figured out how to do a reset yet\n");\r\n}\r\nstatic irqreturn_t pca_handler(int this_irq, void *dev_id) {\r\nwake_up(&pca_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pca_isa_match(struct device *dev, unsigned int id)\r\n{\r\nint match = base != 0;\r\nif (match) {\r\nif (irq <= -1)\r\ndev_warn(dev, "Using polling mode (specify irq)\n");\r\n} else\r\ndev_err(dev, "Please specify I/O base\n");\r\nreturn match;\r\n}\r\nstatic int pca_isa_probe(struct device *dev, unsigned int id)\r\n{\r\ninit_waitqueue_head(&pca_wait);\r\ndev_info(dev, "i/o base %#08lx. irq %d\n", base, irq);\r\n#ifdef CONFIG_PPC\r\nif (check_legacy_ioport(base)) {\r\ndev_err(dev, "I/O address %#08lx is not available\n", base);\r\ngoto out;\r\n}\r\n#endif\r\nif (!request_region(base, IO_SIZE, "i2c-pca-isa")) {\r\ndev_err(dev, "I/O address %#08lx is in use\n", base);\r\ngoto out;\r\n}\r\nif (irq > -1) {\r\nif (request_irq(irq, pca_handler, 0, "i2c-pca-isa", &pca_isa_ops) < 0) {\r\ndev_err(dev, "Request irq%d failed\n", irq);\r\ngoto out_region;\r\n}\r\n}\r\npca_isa_data.i2c_clock = clock;\r\nif (i2c_pca_add_bus(&pca_isa_ops) < 0) {\r\ndev_err(dev, "Failed to add i2c bus\n");\r\ngoto out_irq;\r\n}\r\nreturn 0;\r\nout_irq:\r\nif (irq > -1)\r\nfree_irq(irq, &pca_isa_ops);\r\nout_region:\r\nrelease_region(base, IO_SIZE);\r\nout:\r\nreturn -ENODEV;\r\n}\r\nstatic int pca_isa_remove(struct device *dev, unsigned int id)\r\n{\r\ni2c_del_adapter(&pca_isa_ops);\r\nif (irq > -1) {\r\ndisable_irq(irq);\r\nfree_irq(irq, &pca_isa_ops);\r\n}\r\nrelease_region(base, IO_SIZE);\r\nreturn 0;\r\n}\r\nstatic int __init pca_isa_init(void)\r\n{\r\nreturn isa_register_driver(&pca_isa_driver, 1);\r\n}\r\nstatic void __exit pca_isa_exit(void)\r\n{\r\nisa_unregister_driver(&pca_isa_driver);\r\n}
