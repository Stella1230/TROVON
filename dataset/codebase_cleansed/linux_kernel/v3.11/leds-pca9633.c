static void pca9633_led_work(struct work_struct *work)\r\n{\r\nstruct pca9633_led *pca9633 = container_of(work,\r\nstruct pca9633_led, work);\r\nu8 ledout = i2c_smbus_read_byte_data(pca9633->client, PCA9633_LEDOUT);\r\nint shift = 2 * pca9633->led_num;\r\nu8 mask = 0x3 << shift;\r\nswitch (pca9633->brightness) {\r\ncase LED_FULL:\r\ni2c_smbus_write_byte_data(pca9633->client, PCA9633_LEDOUT,\r\n(ledout & ~mask) | (PCA9633_LED_ON << shift));\r\nbreak;\r\ncase LED_OFF:\r\ni2c_smbus_write_byte_data(pca9633->client, PCA9633_LEDOUT,\r\nledout & ~mask);\r\nbreak;\r\ndefault:\r\ni2c_smbus_write_byte_data(pca9633->client,\r\nPCA9633_PWM_BASE + pca9633->led_num,\r\npca9633->brightness);\r\ni2c_smbus_write_byte_data(pca9633->client, PCA9633_LEDOUT,\r\n(ledout & ~mask) | (PCA9633_LED_PWM << shift));\r\nbreak;\r\n}\r\n}\r\nstatic void pca9633_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct pca9633_led *pca9633;\r\npca9633 = container_of(led_cdev, struct pca9633_led, led_cdev);\r\npca9633->brightness = value;\r\nschedule_work(&pca9633->work);\r\n}\r\nstatic int pca9633_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pca9633_led *pca9633;\r\nstruct pca9633_platform_data *pdata;\r\nint i, err;\r\npdata = client->dev.platform_data;\r\nif (pdata) {\r\nif (pdata->leds.num_leds <= 0 || pdata->leds.num_leds > 4) {\r\ndev_err(&client->dev, "board info must claim at most 4 LEDs");\r\nreturn -EINVAL;\r\n}\r\n}\r\npca9633 = devm_kzalloc(&client->dev, 4 * sizeof(*pca9633), GFP_KERNEL);\r\nif (!pca9633)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, pca9633);\r\nfor (i = 0; i < 4; i++) {\r\npca9633[i].client = client;\r\npca9633[i].led_num = i;\r\nif (pdata && i < pdata->leds.num_leds) {\r\nif (pdata->leds.leds[i].name)\r\nsnprintf(pca9633[i].name,\r\nsizeof(pca9633[i].name), "pca9633:%s",\r\npdata->leds.leds[i].name);\r\nif (pdata->leds.leds[i].default_trigger)\r\npca9633[i].led_cdev.default_trigger =\r\npdata->leds.leds[i].default_trigger;\r\n} else {\r\nsnprintf(pca9633[i].name, sizeof(pca9633[i].name),\r\n"pca9633:%d", i);\r\n}\r\npca9633[i].led_cdev.name = pca9633[i].name;\r\npca9633[i].led_cdev.brightness_set = pca9633_led_set;\r\nINIT_WORK(&pca9633[i].work, pca9633_led_work);\r\nerr = led_classdev_register(&client->dev, &pca9633[i].led_cdev);\r\nif (err < 0)\r\ngoto exit;\r\n}\r\ni2c_smbus_write_byte_data(client, PCA9633_MODE1, 0x00);\r\nif (pdata && pdata->outdrv == PCA9633_OPEN_DRAIN)\r\ni2c_smbus_write_byte_data(client, PCA9633_MODE2, 0x01);\r\ni2c_smbus_write_byte_data(client, PCA9633_LEDOUT, 0x00);\r\nreturn 0;\r\nexit:\r\nwhile (i--) {\r\nled_classdev_unregister(&pca9633[i].led_cdev);\r\ncancel_work_sync(&pca9633[i].work);\r\n}\r\nreturn err;\r\n}\r\nstatic int pca9633_remove(struct i2c_client *client)\r\n{\r\nstruct pca9633_led *pca9633 = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nled_classdev_unregister(&pca9633[i].led_cdev);\r\ncancel_work_sync(&pca9633[i].work);\r\n}\r\nreturn 0;\r\n}
