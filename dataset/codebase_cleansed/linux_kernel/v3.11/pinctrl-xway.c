static int xway_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);\r\nenum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(*config);\r\nint port = PORT(pin);\r\nu32 reg;\r\nswitch (param) {\r\ncase LTQ_PINCONF_PARAM_OPEN_DRAIN:\r\nif (port == PORT3)\r\nreg = GPIO3_OD;\r\nelse\r\nreg = GPIO_OD(pin);\r\n*config = LTQ_PINCONF_PACK(param,\r\n!gpio_getbit(info->membase[0], reg, PORT_PIN(pin)));\r\nbreak;\r\ncase LTQ_PINCONF_PARAM_PULL:\r\nif (port == PORT3)\r\nreg = GPIO3_PUDEN;\r\nelse\r\nreg = GPIO_PUDEN(pin);\r\nif (!gpio_getbit(info->membase[0], reg, PORT_PIN(pin))) {\r\n*config = LTQ_PINCONF_PACK(param, 0);\r\nbreak;\r\n}\r\nif (port == PORT3)\r\nreg = GPIO3_PUDSEL;\r\nelse\r\nreg = GPIO_PUDSEL(pin);\r\nif (!gpio_getbit(info->membase[0], reg, PORT_PIN(pin)))\r\n*config = LTQ_PINCONF_PACK(param, 2);\r\nelse\r\n*config = LTQ_PINCONF_PACK(param, 1);\r\nbreak;\r\ncase LTQ_PINCONF_PARAM_OUTPUT:\r\nreg = GPIO_DIR(pin);\r\n*config = LTQ_PINCONF_PACK(param,\r\ngpio_getbit(info->membase[0], reg, PORT_PIN(pin)));\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev, "Invalid config param %04x\n", param);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xway_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nunsigned long config)\r\n{\r\nstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);\r\nenum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(config);\r\nint arg = LTQ_PINCONF_UNPACK_ARG(config);\r\nint port = PORT(pin);\r\nu32 reg;\r\nswitch (param) {\r\ncase LTQ_PINCONF_PARAM_OPEN_DRAIN:\r\nif (port == PORT3)\r\nreg = GPIO3_OD;\r\nelse\r\nreg = GPIO_OD(pin);\r\nif (arg == 0)\r\ngpio_setbit(info->membase[0], reg, PORT_PIN(pin));\r\nelse\r\ngpio_clearbit(info->membase[0], reg, PORT_PIN(pin));\r\nbreak;\r\ncase LTQ_PINCONF_PARAM_PULL:\r\nif (port == PORT3)\r\nreg = GPIO3_PUDEN;\r\nelse\r\nreg = GPIO_PUDEN(pin);\r\nif (arg == 0) {\r\ngpio_clearbit(info->membase[0], reg, PORT_PIN(pin));\r\nbreak;\r\n}\r\ngpio_setbit(info->membase[0], reg, PORT_PIN(pin));\r\nif (port == PORT3)\r\nreg = GPIO3_PUDSEL;\r\nelse\r\nreg = GPIO_PUDSEL(pin);\r\nif (arg == 1)\r\ngpio_clearbit(info->membase[0], reg, PORT_PIN(pin));\r\nelse if (arg == 2)\r\ngpio_setbit(info->membase[0], reg, PORT_PIN(pin));\r\nelse\r\ndev_err(pctldev->dev, "Invalid pull value %d\n", arg);\r\nbreak;\r\ncase LTQ_PINCONF_PARAM_OUTPUT:\r\nreg = GPIO_DIR(pin);\r\nif (arg == 0)\r\ngpio_clearbit(info->membase[0], reg, PORT_PIN(pin));\r\nelse\r\ngpio_setbit(info->membase[0], reg, PORT_PIN(pin));\r\nbreak;\r\ndefault:\r\ndev_err(pctldev->dev, "Invalid config param %04x\n", param);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nint xway_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nunsigned long config)\r\n{\r\nstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);\r\nint i, ret = 0;\r\nfor (i = 0; i < info->grps[selector].npins && !ret; i++)\r\nret = xway_pinconf_set(pctldev,\r\ninfo->grps[selector].pins[i], config);\r\nreturn ret;\r\n}\r\nstatic inline int xway_mux_apply(struct pinctrl_dev *pctrldev,\r\nint pin, int mux)\r\n{\r\nstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\r\nint port = PORT(pin);\r\nu32 alt1_reg = GPIO_ALT1(pin);\r\nif (port == PORT3)\r\nalt1_reg = GPIO3_ALT1;\r\nif (mux & MUX_ALT0)\r\ngpio_setbit(info->membase[0], GPIO_ALT0(pin), PORT_PIN(pin));\r\nelse\r\ngpio_clearbit(info->membase[0], GPIO_ALT0(pin), PORT_PIN(pin));\r\nif (mux & MUX_ALT1)\r\ngpio_setbit(info->membase[0], alt1_reg, PORT_PIN(pin));\r\nelse\r\ngpio_clearbit(info->membase[0], alt1_reg, PORT_PIN(pin));\r\nreturn 0;\r\n}\r\nstatic void xway_gpio_set(struct gpio_chip *chip, unsigned int pin, int val)\r\n{\r\nstruct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);\r\nif (val)\r\ngpio_setbit(info->membase[0], GPIO_OUT(pin), PORT_PIN(pin));\r\nelse\r\ngpio_clearbit(info->membase[0], GPIO_OUT(pin), PORT_PIN(pin));\r\n}\r\nstatic int xway_gpio_get(struct gpio_chip *chip, unsigned int pin)\r\n{\r\nstruct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);\r\nreturn gpio_getbit(info->membase[0], GPIO_IN(pin), PORT_PIN(pin));\r\n}\r\nstatic int xway_gpio_dir_in(struct gpio_chip *chip, unsigned int pin)\r\n{\r\nstruct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);\r\ngpio_clearbit(info->membase[0], GPIO_DIR(pin), PORT_PIN(pin));\r\nreturn 0;\r\n}\r\nstatic int xway_gpio_dir_out(struct gpio_chip *chip, unsigned int pin, int val)\r\n{\r\nstruct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);\r\ngpio_setbit(info->membase[0], GPIO_DIR(pin), PORT_PIN(pin));\r\nxway_gpio_set(chip, pin, val);\r\nreturn 0;\r\n}\r\nstatic int xway_gpio_req(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\nreturn pinctrl_request_gpio(gpio);\r\n}\r\nstatic void xway_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\npinctrl_free_gpio(gpio);\r\n}\r\nstatic int pinmux_xway_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct pinctrl_xway_soc *xway_soc;\r\nstruct resource *res;\r\nint ret, i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nxway_info.membase[0] = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(xway_info.membase[0]))\r\nreturn PTR_ERR(xway_info.membase[0]);\r\nmatch = of_match_device(xway_match, &pdev->dev);\r\nif (match)\r\nxway_soc = (const struct pinctrl_xway_soc *) match->data;\r\nelse\r\nxway_soc = &soc_cfg[0];\r\nxway_chip.ngpio = xway_soc->pin_count;\r\nxway_info.pads = devm_kzalloc(&pdev->dev,\r\nsizeof(struct pinctrl_pin_desc) * xway_chip.ngpio,\r\nGFP_KERNEL);\r\nif (!xway_info.pads) {\r\ndev_err(&pdev->dev, "Failed to allocate pads\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < xway_chip.ngpio; i++) {\r\nchar *name = devm_kzalloc(&pdev->dev, 5, GFP_KERNEL);\r\nif (!name) {\r\ndev_err(&pdev->dev, "Failed to allocate pad name\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(name, 5, "io%d", i);\r\nxway_info.pads[i].number = GPIO0 + i;\r\nxway_info.pads[i].name = name;\r\n}\r\nxway_pctrl_desc.pins = xway_info.pads;\r\nxway_chip.dev = &pdev->dev;\r\nof_gpiochip_add(&xway_chip);\r\nret = gpiochip_add(&xway_chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register gpio chip\n");\r\nreturn ret;\r\n}\r\nxway_pctrl_desc.name = dev_name(&pdev->dev);\r\nxway_pctrl_desc.npins = xway_chip.ngpio;\r\nxway_info.num_pads = xway_chip.ngpio;\r\nxway_info.num_mfp = xway_chip.ngpio;\r\nxway_info.mfp = xway_soc->mfp;\r\nxway_info.grps = xway_soc->grps;\r\nxway_info.num_grps = xway_soc->num_grps;\r\nxway_info.funcs = xway_soc->funcs;\r\nxway_info.num_funcs = xway_soc->num_funcs;\r\nxway_info.exin = xway_soc->exin;\r\nxway_info.num_exin = xway_soc->num_exin;\r\nret = ltq_pinctrl_register(pdev, &xway_info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register pinctrl driver\n");\r\nreturn ret;\r\n}\r\nxway_gpio_range.npins = xway_chip.ngpio;\r\nxway_gpio_range.base = xway_chip.base;\r\npinctrl_add_gpio_range(xway_info.pctrl, &xway_gpio_range);\r\ndev_info(&pdev->dev, "Init done\n");\r\nreturn 0;\r\n}\r\nstatic int __init pinmux_xway_init(void)\r\n{\r\nreturn platform_driver_register(&pinmux_xway_driver);\r\n}
