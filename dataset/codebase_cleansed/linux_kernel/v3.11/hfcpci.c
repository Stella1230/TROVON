static void\r\nenable_hwirq(struct hfc_pci *hc)\r\n{\r\nhc->hw.int_m2 |= HFCPCI_IRQ_ENABLE;\r\nWrite_hfc(hc, HFCPCI_INT_M2, hc->hw.int_m2);\r\n}\r\nstatic void\r\ndisable_hwirq(struct hfc_pci *hc)\r\n{\r\nhc->hw.int_m2 &= ~((u_char)HFCPCI_IRQ_ENABLE);\r\nWrite_hfc(hc, HFCPCI_INT_M2, hc->hw.int_m2);\r\n}\r\nstatic void\r\nrelease_io_hfcpci(struct hfc_pci *hc)\r\n{\r\npci_write_config_word(hc->pdev, PCI_COMMAND, 0);\r\ndel_timer(&hc->hw.timer);\r\npci_free_consistent(hc->pdev, 0x8000, hc->hw.fifos, hc->hw.dmahandle);\r\niounmap(hc->hw.pci_io);\r\n}\r\nstatic void\r\nhfcpci_setmode(struct hfc_pci *hc)\r\n{\r\nif (hc->hw.protocol == ISDN_P_NT_S0) {\r\nhc->hw.clkdel = CLKDEL_NT;\r\nhc->hw.sctrl |= SCTRL_MODE_NT;\r\nhc->hw.states = 1;\r\n} else {\r\nhc->hw.clkdel = CLKDEL_TE;\r\nhc->hw.sctrl &= ~SCTRL_MODE_NT;\r\nhc->hw.states = 2;\r\n}\r\nWrite_hfc(hc, HFCPCI_CLKDEL, hc->hw.clkdel);\r\nWrite_hfc(hc, HFCPCI_STATES, HFCPCI_LOAD_STATE | hc->hw.states);\r\nudelay(10);\r\nWrite_hfc(hc, HFCPCI_STATES, hc->hw.states | 0x40);\r\nWrite_hfc(hc, HFCPCI_SCTRL, hc->hw.sctrl);\r\n}\r\nstatic void\r\nreset_hfcpci(struct hfc_pci *hc)\r\n{\r\nu_char val;\r\nint cnt = 0;\r\nprintk(KERN_DEBUG "reset_hfcpci: entered\n");\r\nval = Read_hfc(hc, HFCPCI_CHIP_ID);\r\nprintk(KERN_INFO "HFC_PCI: resetting HFC ChipId(%x)\n", val);\r\npci_write_config_word(hc->pdev, PCI_COMMAND, PCI_ENA_MEMIO);\r\ndisable_hwirq(hc);\r\npci_write_config_word(hc->pdev, PCI_COMMAND,\r\nPCI_ENA_MEMIO + PCI_ENA_MASTER);\r\nval = Read_hfc(hc, HFCPCI_STATUS);\r\nprintk(KERN_DEBUG "HFC-PCI status(%x) before reset\n", val);\r\nhc->hw.cirm = HFCPCI_RESET;\r\nWrite_hfc(hc, HFCPCI_CIRM, hc->hw.cirm);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nmdelay(10);\r\nhc->hw.cirm = 0;\r\nWrite_hfc(hc, HFCPCI_CIRM, hc->hw.cirm);\r\nval = Read_hfc(hc, HFCPCI_STATUS);\r\nprintk(KERN_DEBUG "HFC-PCI status(%x) after reset\n", val);\r\nwhile (cnt < 50000) {\r\nudelay(5);\r\ncnt += 5;\r\nval = Read_hfc(hc, HFCPCI_STATUS);\r\nif (!(val & 2))\r\nbreak;\r\n}\r\nprintk(KERN_DEBUG "HFC-PCI status(%x) after %dus\n", val, cnt);\r\nhc->hw.fifo_en = 0x30;\r\nhc->hw.bswapped = 0;\r\nhc->hw.ctmt = HFCPCI_TIM3_125 | HFCPCI_AUTO_TIMER;\r\nhc->hw.trm = HFCPCI_BTRANS_THRESMASK;\r\nhc->hw.sctrl = 0x40;\r\nhc->hw.sctrl_r = 0;\r\nhc->hw.sctrl_e = HFCPCI_AUTO_AWAKE;\r\nhc->hw.mst_m = 0;\r\nif (test_bit(HFC_CFG_MASTER, &hc->cfg))\r\nhc->hw.mst_m |= HFCPCI_MASTER;\r\nif (test_bit(HFC_CFG_NEG_F0, &hc->cfg))\r\nhc->hw.mst_m |= HFCPCI_F0_NEGATIV;\r\nWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\r\nWrite_hfc(hc, HFCPCI_TRM, hc->hw.trm);\r\nWrite_hfc(hc, HFCPCI_SCTRL_E, hc->hw.sctrl_e);\r\nWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt);\r\nhc->hw.int_m1 = HFCPCI_INTS_DTRANS | HFCPCI_INTS_DREC |\r\nHFCPCI_INTS_L1STATE | HFCPCI_INTS_TIMER;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nval = Read_hfc(hc, HFCPCI_INT_S1);\r\nhfcpci_setmode(hc);\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\nWrite_hfc(hc, HFCPCI_SCTRL_R, hc->hw.sctrl_r);\r\nif (test_bit(HFC_CFG_PCM, &hc->cfg)) {\r\nhc->hw.conn = 0x09;\r\n} else {\r\nhc->hw.conn = 0x36;\r\nif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg)) {\r\nWrite_hfc(hc, HFCPCI_B1_SSL, 0xC0);\r\nWrite_hfc(hc, HFCPCI_B2_SSL, 0xC1);\r\nWrite_hfc(hc, HFCPCI_B1_RSL, 0xC0);\r\nWrite_hfc(hc, HFCPCI_B2_RSL, 0xC1);\r\n} else {\r\nWrite_hfc(hc, HFCPCI_B1_SSL, 0x80);\r\nWrite_hfc(hc, HFCPCI_B2_SSL, 0x81);\r\nWrite_hfc(hc, HFCPCI_B1_RSL, 0x80);\r\nWrite_hfc(hc, HFCPCI_B2_RSL, 0x81);\r\n}\r\n}\r\nWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\r\nval = Read_hfc(hc, HFCPCI_INT_S2);\r\n}\r\nstatic void\r\nhfcpci_Timer(struct hfc_pci *hc)\r\n{\r\nhc->hw.timer.expires = jiffies + 75;\r\n}\r\nstatic struct bchannel *\r\nSel_BCS(struct hfc_pci *hc, int channel)\r\n{\r\nif (test_bit(FLG_ACTIVE, &hc->bch[0].Flags) &&\r\n(hc->bch[0].nr & channel))\r\nreturn &hc->bch[0];\r\nelse if (test_bit(FLG_ACTIVE, &hc->bch[1].Flags) &&\r\n(hc->bch[1].nr & channel))\r\nreturn &hc->bch[1];\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void\r\nhfcpci_clear_fifo_rx(struct hfc_pci *hc, int fifo)\r\n{\r\nu_char fifo_state;\r\nstruct bzfifo *bzr;\r\nif (fifo) {\r\nbzr = &((union fifo_area *)(hc->hw.fifos))->b_chans.rxbz_b2;\r\nfifo_state = hc->hw.fifo_en & HFCPCI_FIFOEN_B2RX;\r\n} else {\r\nbzr = &((union fifo_area *)(hc->hw.fifos))->b_chans.rxbz_b1;\r\nfifo_state = hc->hw.fifo_en & HFCPCI_FIFOEN_B1RX;\r\n}\r\nif (fifo_state)\r\nhc->hw.fifo_en ^= fifo_state;\r\nWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\r\nhc->hw.last_bfifo_cnt[fifo] = 0;\r\nbzr->f1 = MAX_B_FRAMES;\r\nbzr->f2 = bzr->f1;\r\nbzr->za[MAX_B_FRAMES].z1 = cpu_to_le16(B_FIFO_SIZE + B_SUB_VAL - 1);\r\nbzr->za[MAX_B_FRAMES].z2 = cpu_to_le16(\r\nle16_to_cpu(bzr->za[MAX_B_FRAMES].z1));\r\nif (fifo_state)\r\nhc->hw.fifo_en |= fifo_state;\r\nWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\r\n}\r\nstatic void hfcpci_clear_fifo_tx(struct hfc_pci *hc, int fifo)\r\n{\r\nu_char fifo_state;\r\nstruct bzfifo *bzt;\r\nif (fifo) {\r\nbzt = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b2;\r\nfifo_state = hc->hw.fifo_en & HFCPCI_FIFOEN_B2TX;\r\n} else {\r\nbzt = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b1;\r\nfifo_state = hc->hw.fifo_en & HFCPCI_FIFOEN_B1TX;\r\n}\r\nif (fifo_state)\r\nhc->hw.fifo_en ^= fifo_state;\r\nWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\r\nif (hc->bch[fifo].debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG "hfcpci_clear_fifo_tx%d f1(%x) f2(%x) "\r\n"z1(%x) z2(%x) state(%x)\n",\r\nfifo, bzt->f1, bzt->f2,\r\nle16_to_cpu(bzt->za[MAX_B_FRAMES].z1),\r\nle16_to_cpu(bzt->za[MAX_B_FRAMES].z2),\r\nfifo_state);\r\nbzt->f2 = MAX_B_FRAMES;\r\nbzt->f1 = bzt->f2;\r\nbzt->za[MAX_B_FRAMES].z1 = cpu_to_le16(B_FIFO_SIZE + B_SUB_VAL - 1);\r\nbzt->za[MAX_B_FRAMES].z2 = cpu_to_le16(B_FIFO_SIZE + B_SUB_VAL - 2);\r\nif (fifo_state)\r\nhc->hw.fifo_en |= fifo_state;\r\nWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\r\nif (hc->bch[fifo].debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG\r\n"hfcpci_clear_fifo_tx%d f1(%x) f2(%x) z1(%x) z2(%x)\n",\r\nfifo, bzt->f1, bzt->f2,\r\nle16_to_cpu(bzt->za[MAX_B_FRAMES].z1),\r\nle16_to_cpu(bzt->za[MAX_B_FRAMES].z2));\r\n}\r\nstatic void\r\nhfcpci_empty_bfifo(struct bchannel *bch, struct bzfifo *bz,\r\nu_char *bdata, int count)\r\n{\r\nu_char *ptr, *ptr1, new_f2;\r\nint maxlen, new_z2;\r\nstruct zt *zp;\r\nif ((bch->debug & DEBUG_HW_BCHANNEL) && !(bch->debug & DEBUG_HW_BFIFO))\r\nprintk(KERN_DEBUG "hfcpci_empty_fifo\n");\r\nzp = &bz->za[bz->f2];\r\nnew_z2 = le16_to_cpu(zp->z2) + count;\r\nif (new_z2 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z2 -= B_FIFO_SIZE;\r\nnew_f2 = (bz->f2 + 1) & MAX_B_FRAMES;\r\nif ((count > MAX_DATA_SIZE + 3) || (count < 4) ||\r\n(*(bdata + (le16_to_cpu(zp->z1) - B_SUB_VAL)))) {\r\nif (bch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "hfcpci_empty_fifo: incoming packet "\r\n"invalid length %d or crc\n", count);\r\n#ifdef ERROR_STATISTIC\r\nbch->err_inv++;\r\n#endif\r\nbz->za[new_f2].z2 = cpu_to_le16(new_z2);\r\nbz->f2 = new_f2;\r\n} else {\r\nbch->rx_skb = mI_alloc_skb(count - 3, GFP_ATOMIC);\r\nif (!bch->rx_skb) {\r\nprintk(KERN_WARNING "HFCPCI: receive out of memory\n");\r\nreturn;\r\n}\r\ncount -= 3;\r\nptr = skb_put(bch->rx_skb, count);\r\nif (le16_to_cpu(zp->z2) + count <= B_FIFO_SIZE + B_SUB_VAL)\r\nmaxlen = count;\r\nelse\r\nmaxlen = B_FIFO_SIZE + B_SUB_VAL -\r\nle16_to_cpu(zp->z2);\r\nptr1 = bdata + (le16_to_cpu(zp->z2) - B_SUB_VAL);\r\nmemcpy(ptr, ptr1, maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\nptr += maxlen;\r\nptr1 = bdata;\r\nmemcpy(ptr, ptr1, count);\r\n}\r\nbz->za[new_f2].z2 = cpu_to_le16(new_z2);\r\nbz->f2 = new_f2;\r\nrecv_Bchannel(bch, MISDN_ID_ANY, false);\r\n}\r\n}\r\nstatic int\r\nreceive_dmsg(struct hfc_pci *hc)\r\n{\r\nstruct dchannel *dch = &hc->dch;\r\nint maxlen;\r\nint rcnt, total;\r\nint count = 5;\r\nu_char *ptr, *ptr1;\r\nstruct dfifo *df;\r\nstruct zt *zp;\r\ndf = &((union fifo_area *)(hc->hw.fifos))->d_chan.d_rx;\r\nwhile (((df->f1 & D_FREG_MASK) != (df->f2 & D_FREG_MASK)) && count--) {\r\nzp = &df->za[df->f2 & D_FREG_MASK];\r\nrcnt = le16_to_cpu(zp->z1) - le16_to_cpu(zp->z2);\r\nif (rcnt < 0)\r\nrcnt += D_FIFO_SIZE;\r\nrcnt++;\r\nif (dch->debug & DEBUG_HW_DCHANNEL)\r\nprintk(KERN_DEBUG\r\n"hfcpci recd f1(%d) f2(%d) z1(%x) z2(%x) cnt(%d)\n",\r\ndf->f1, df->f2,\r\nle16_to_cpu(zp->z1),\r\nle16_to_cpu(zp->z2),\r\nrcnt);\r\nif ((rcnt > MAX_DFRAME_LEN + 3) || (rcnt < 4) ||\r\n(df->data[le16_to_cpu(zp->z1)])) {\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG\r\n"empty_fifo hfcpci packet inv. len "\r\n"%d or crc %d\n",\r\nrcnt,\r\ndf->data[le16_to_cpu(zp->z1)]);\r\n#ifdef ERROR_STATISTIC\r\ncs->err_rx++;\r\n#endif\r\ndf->f2 = ((df->f2 + 1) & MAX_D_FRAMES) |\r\n(MAX_D_FRAMES + 1);\r\ndf->za[df->f2 & D_FREG_MASK].z2 =\r\ncpu_to_le16((le16_to_cpu(zp->z2) + rcnt) &\r\n(D_FIFO_SIZE - 1));\r\n} else {\r\ndch->rx_skb = mI_alloc_skb(rcnt - 3, GFP_ATOMIC);\r\nif (!dch->rx_skb) {\r\nprintk(KERN_WARNING\r\n"HFC-PCI: D receive out of memory\n");\r\nbreak;\r\n}\r\ntotal = rcnt;\r\nrcnt -= 3;\r\nptr = skb_put(dch->rx_skb, rcnt);\r\nif (le16_to_cpu(zp->z2) + rcnt <= D_FIFO_SIZE)\r\nmaxlen = rcnt;\r\nelse\r\nmaxlen = D_FIFO_SIZE - le16_to_cpu(zp->z2);\r\nptr1 = df->data + le16_to_cpu(zp->z2);\r\nmemcpy(ptr, ptr1, maxlen);\r\nrcnt -= maxlen;\r\nif (rcnt) {\r\nptr += maxlen;\r\nptr1 = df->data;\r\nmemcpy(ptr, ptr1, rcnt);\r\n}\r\ndf->f2 = ((df->f2 + 1) & MAX_D_FRAMES) |\r\n(MAX_D_FRAMES + 1);\r\ndf->za[df->f2 & D_FREG_MASK].z2 = cpu_to_le16((\r\nle16_to_cpu(zp->z2) + total) & (D_FIFO_SIZE - 1));\r\nrecv_Dchannel(dch);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nhfcpci_empty_fifo_trans(struct bchannel *bch, struct bzfifo *rxbz,\r\nstruct bzfifo *txbz, u_char *bdata)\r\n{\r\n__le16 *z1r, *z2r, *z1t, *z2t;\r\nint new_z2, fcnt_rx, fcnt_tx, maxlen;\r\nu_char *ptr, *ptr1;\r\nz1r = &rxbz->za[MAX_B_FRAMES].z1;\r\nz2r = z1r + 1;\r\nz1t = &txbz->za[MAX_B_FRAMES].z1;\r\nz2t = z1t + 1;\r\nfcnt_rx = le16_to_cpu(*z1r) - le16_to_cpu(*z2r);\r\nif (!fcnt_rx)\r\nreturn;\r\nif (fcnt_rx <= 0)\r\nfcnt_rx += B_FIFO_SIZE;\r\nnew_z2 = le16_to_cpu(*z2r) + fcnt_rx;\r\nif (new_z2 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z2 -= B_FIFO_SIZE;\r\nfcnt_tx = le16_to_cpu(*z2t) - le16_to_cpu(*z1t);\r\nif (fcnt_tx <= 0)\r\nfcnt_tx += B_FIFO_SIZE;\r\nfcnt_tx = B_FIFO_SIZE - fcnt_tx;\r\nif (test_bit(FLG_RX_OFF, &bch->Flags)) {\r\nbch->dropcnt += fcnt_rx;\r\n*z2r = cpu_to_le16(new_z2);\r\nreturn;\r\n}\r\nmaxlen = bchannel_get_rxbuf(bch, fcnt_rx);\r\nif (maxlen < 0) {\r\npr_warning("B%d: No bufferspace for %d bytes\n",\r\nbch->nr, fcnt_rx);\r\n} else {\r\nptr = skb_put(bch->rx_skb, fcnt_rx);\r\nif (le16_to_cpu(*z2r) + fcnt_rx <= B_FIFO_SIZE + B_SUB_VAL)\r\nmaxlen = fcnt_rx;\r\nelse\r\nmaxlen = B_FIFO_SIZE + B_SUB_VAL - le16_to_cpu(*z2r);\r\nptr1 = bdata + (le16_to_cpu(*z2r) - B_SUB_VAL);\r\nmemcpy(ptr, ptr1, maxlen);\r\nfcnt_rx -= maxlen;\r\nif (fcnt_rx) {\r\nptr += maxlen;\r\nptr1 = bdata;\r\nmemcpy(ptr, ptr1, fcnt_rx);\r\n}\r\nrecv_Bchannel(bch, fcnt_tx, false);\r\n}\r\n*z2r = cpu_to_le16(new_z2);\r\n}\r\nstatic void\r\nmain_rec_hfcpci(struct bchannel *bch)\r\n{\r\nstruct hfc_pci *hc = bch->hw;\r\nint rcnt, real_fifo;\r\nint receive = 0, count = 5;\r\nstruct bzfifo *txbz, *rxbz;\r\nu_char *bdata;\r\nstruct zt *zp;\r\nif ((bch->nr & 2) && (!hc->hw.bswapped)) {\r\nrxbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.rxbz_b2;\r\ntxbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b2;\r\nbdata = ((union fifo_area *)(hc->hw.fifos))->b_chans.rxdat_b2;\r\nreal_fifo = 1;\r\n} else {\r\nrxbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.rxbz_b1;\r\ntxbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b1;\r\nbdata = ((union fifo_area *)(hc->hw.fifos))->b_chans.rxdat_b1;\r\nreal_fifo = 0;\r\n}\r\nBegin:\r\ncount--;\r\nif (rxbz->f1 != rxbz->f2) {\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG "hfcpci rec ch(%x) f1(%d) f2(%d)\n",\r\nbch->nr, rxbz->f1, rxbz->f2);\r\nzp = &rxbz->za[rxbz->f2];\r\nrcnt = le16_to_cpu(zp->z1) - le16_to_cpu(zp->z2);\r\nif (rcnt < 0)\r\nrcnt += B_FIFO_SIZE;\r\nrcnt++;\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG\r\n"hfcpci rec ch(%x) z1(%x) z2(%x) cnt(%d)\n",\r\nbch->nr, le16_to_cpu(zp->z1),\r\nle16_to_cpu(zp->z2), rcnt);\r\nhfcpci_empty_bfifo(bch, rxbz, bdata, rcnt);\r\nrcnt = rxbz->f1 - rxbz->f2;\r\nif (rcnt < 0)\r\nrcnt += MAX_B_FRAMES + 1;\r\nif (hc->hw.last_bfifo_cnt[real_fifo] > rcnt + 1) {\r\nrcnt = 0;\r\nhfcpci_clear_fifo_rx(hc, real_fifo);\r\n}\r\nhc->hw.last_bfifo_cnt[real_fifo] = rcnt;\r\nif (rcnt > 1)\r\nreceive = 1;\r\nelse\r\nreceive = 0;\r\n} else if (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\r\nhfcpci_empty_fifo_trans(bch, rxbz, txbz, bdata);\r\nreturn;\r\n} else\r\nreceive = 0;\r\nif (count && receive)\r\ngoto Begin;\r\n}\r\nstatic void\r\nhfcpci_fill_dfifo(struct hfc_pci *hc)\r\n{\r\nstruct dchannel *dch = &hc->dch;\r\nint fcnt;\r\nint count, new_z1, maxlen;\r\nstruct dfifo *df;\r\nu_char *src, *dst, new_f1;\r\nif ((dch->debug & DEBUG_HW_DCHANNEL) && !(dch->debug & DEBUG_HW_DFIFO))\r\nprintk(KERN_DEBUG "%s\n", __func__);\r\nif (!dch->tx_skb)\r\nreturn;\r\ncount = dch->tx_skb->len - dch->tx_idx;\r\nif (count <= 0)\r\nreturn;\r\ndf = &((union fifo_area *) (hc->hw.fifos))->d_chan.d_tx;\r\nif (dch->debug & DEBUG_HW_DFIFO)\r\nprintk(KERN_DEBUG "%s:f1(%d) f2(%d) z1(f1)(%x)\n", __func__,\r\ndf->f1, df->f2,\r\nle16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1));\r\nfcnt = df->f1 - df->f2;\r\nif (fcnt < 0)\r\nfcnt += (MAX_D_FRAMES + 1);\r\nif (fcnt > (MAX_D_FRAMES - 1)) {\r\nif (dch->debug & DEBUG_HW_DCHANNEL)\r\nprintk(KERN_DEBUG\r\n"hfcpci_fill_Dfifo more as 14 frames\n");\r\n#ifdef ERROR_STATISTIC\r\ncs->err_tx++;\r\n#endif\r\nreturn;\r\n}\r\nmaxlen = le16_to_cpu(df->za[df->f2 & D_FREG_MASK].z2) -\r\nle16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1) - 1;\r\nif (maxlen <= 0)\r\nmaxlen += D_FIFO_SIZE;\r\nif (dch->debug & DEBUG_HW_DCHANNEL)\r\nprintk(KERN_DEBUG "hfcpci_fill_Dfifo count(%d/%d)\n",\r\ncount, maxlen);\r\nif (count > maxlen) {\r\nif (dch->debug & DEBUG_HW_DCHANNEL)\r\nprintk(KERN_DEBUG "hfcpci_fill_Dfifo no fifo mem\n");\r\nreturn;\r\n}\r\nnew_z1 = (le16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1) + count) &\r\n(D_FIFO_SIZE - 1);\r\nnew_f1 = ((df->f1 + 1) & D_FREG_MASK) | (D_FREG_MASK + 1);\r\nsrc = dch->tx_skb->data + dch->tx_idx;\r\ndst = df->data + le16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1);\r\nmaxlen = D_FIFO_SIZE - le16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1);\r\nif (maxlen > count)\r\nmaxlen = count;\r\nmemcpy(dst, src, maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\ndst = df->data;\r\nsrc += maxlen;\r\nmemcpy(dst, src, count);\r\n}\r\ndf->za[new_f1 & D_FREG_MASK].z1 = cpu_to_le16(new_z1);\r\ndf->za[df->f1 & D_FREG_MASK].z1 = cpu_to_le16(new_z1);\r\ndf->f1 = new_f1;\r\ndch->tx_idx = dch->tx_skb->len;\r\n}\r\nstatic void\r\nhfcpci_fill_fifo(struct bchannel *bch)\r\n{\r\nstruct hfc_pci *hc = bch->hw;\r\nint maxlen, fcnt;\r\nint count, new_z1;\r\nstruct bzfifo *bz;\r\nu_char *bdata;\r\nu_char new_f1, *src, *dst;\r\n__le16 *z1t, *z2t;\r\nif ((bch->debug & DEBUG_HW_BCHANNEL) && !(bch->debug & DEBUG_HW_BFIFO))\r\nprintk(KERN_DEBUG "%s\n", __func__);\r\nif ((!bch->tx_skb) || bch->tx_skb->len == 0) {\r\nif (!test_bit(FLG_FILLEMPTY, &bch->Flags) &&\r\n!test_bit(FLG_TRANSPARENT, &bch->Flags))\r\nreturn;\r\ncount = HFCPCI_FILLEMPTY;\r\n} else {\r\ncount = bch->tx_skb->len - bch->tx_idx;\r\n}\r\nif ((bch->nr & 2) && (!hc->hw.bswapped)) {\r\nbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b2;\r\nbdata = ((union fifo_area *)(hc->hw.fifos))->b_chans.txdat_b2;\r\n} else {\r\nbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b1;\r\nbdata = ((union fifo_area *)(hc->hw.fifos))->b_chans.txdat_b1;\r\n}\r\nif (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\r\nz1t = &bz->za[MAX_B_FRAMES].z1;\r\nz2t = z1t + 1;\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG "hfcpci_fill_fifo_trans ch(%x) "\r\n"cnt(%d) z1(%x) z2(%x)\n", bch->nr, count,\r\nle16_to_cpu(*z1t), le16_to_cpu(*z2t));\r\nfcnt = le16_to_cpu(*z2t) - le16_to_cpu(*z1t);\r\nif (fcnt <= 0)\r\nfcnt += B_FIFO_SIZE;\r\nif (test_bit(FLG_FILLEMPTY, &bch->Flags)) {\r\nif (count > fcnt)\r\ncount = fcnt;\r\nnew_z1 = le16_to_cpu(*z1t) + count;\r\nif (new_z1 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z1 -= B_FIFO_SIZE;\r\ndst = bdata + (le16_to_cpu(*z1t) - B_SUB_VAL);\r\nmaxlen = (B_FIFO_SIZE + B_SUB_VAL) - le16_to_cpu(*z1t);\r\nif (bch->debug & DEBUG_HW_BFIFO)\r\nprintk(KERN_DEBUG "hfcpci_FFt fillempty "\r\n"fcnt(%d) maxl(%d) nz1(%x) dst(%p)\n",\r\nfcnt, maxlen, new_z1, dst);\r\nif (maxlen > count)\r\nmaxlen = count;\r\nmemset(dst, bch->fill[0], maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\ndst = bdata;\r\nmemset(dst, bch->fill[0], count);\r\n}\r\n*z1t = cpu_to_le16(new_z1);\r\nreturn;\r\n}\r\nfcnt = B_FIFO_SIZE - fcnt;\r\nnext_t_frame:\r\ncount = bch->tx_skb->len - bch->tx_idx;\r\nif (count > (poll << 1) - fcnt)\r\ncount = (poll << 1) - fcnt;\r\nif (count <= 0)\r\nreturn;\r\nnew_z1 = le16_to_cpu(*z1t) + count;\r\nif (new_z1 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z1 -= B_FIFO_SIZE;\r\nsrc = bch->tx_skb->data + bch->tx_idx;\r\ndst = bdata + (le16_to_cpu(*z1t) - B_SUB_VAL);\r\nmaxlen = (B_FIFO_SIZE + B_SUB_VAL) - le16_to_cpu(*z1t);\r\nif (bch->debug & DEBUG_HW_BFIFO)\r\nprintk(KERN_DEBUG "hfcpci_FFt fcnt(%d) "\r\n"maxl(%d) nz1(%x) dst(%p)\n",\r\nfcnt, maxlen, new_z1, dst);\r\nfcnt += count;\r\nbch->tx_idx += count;\r\nif (maxlen > count)\r\nmaxlen = count;\r\nmemcpy(dst, src, maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\ndst = bdata;\r\nsrc += maxlen;\r\nmemcpy(dst, src, count);\r\n}\r\n*z1t = cpu_to_le16(new_z1);\r\nif (bch->tx_idx < bch->tx_skb->len)\r\nreturn;\r\ndev_kfree_skb(bch->tx_skb);\r\nif (get_next_bframe(bch))\r\ngoto next_t_frame;\r\nreturn;\r\n}\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG\r\n"%s: ch(%x) f1(%d) f2(%d) z1(f1)(%x)\n",\r\n__func__, bch->nr, bz->f1, bz->f2,\r\nbz->za[bz->f1].z1);\r\nfcnt = bz->f1 - bz->f2;\r\nif (fcnt < 0)\r\nfcnt += (MAX_B_FRAMES + 1);\r\nif (fcnt > (MAX_B_FRAMES - 1)) {\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG\r\n"hfcpci_fill_Bfifo more as 14 frames\n");\r\nreturn;\r\n}\r\nmaxlen = le16_to_cpu(bz->za[bz->f2].z2) -\r\nle16_to_cpu(bz->za[bz->f1].z1) - 1;\r\nif (maxlen <= 0)\r\nmaxlen += B_FIFO_SIZE;\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG "hfcpci_fill_fifo ch(%x) count(%d/%d)\n",\r\nbch->nr, count, maxlen);\r\nif (maxlen < count) {\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG "hfcpci_fill_fifo no fifo mem\n");\r\nreturn;\r\n}\r\nnew_z1 = le16_to_cpu(bz->za[bz->f1].z1) + count;\r\nif (new_z1 >= (B_FIFO_SIZE + B_SUB_VAL))\r\nnew_z1 -= B_FIFO_SIZE;\r\nnew_f1 = ((bz->f1 + 1) & MAX_B_FRAMES);\r\nsrc = bch->tx_skb->data + bch->tx_idx;\r\ndst = bdata + (le16_to_cpu(bz->za[bz->f1].z1) - B_SUB_VAL);\r\nmaxlen = (B_FIFO_SIZE + B_SUB_VAL) - le16_to_cpu(bz->za[bz->f1].z1);\r\nif (maxlen > count)\r\nmaxlen = count;\r\nmemcpy(dst, src, maxlen);\r\ncount -= maxlen;\r\nif (count) {\r\ndst = bdata;\r\nsrc += maxlen;\r\nmemcpy(dst, src, count);\r\n}\r\nbz->za[new_f1].z1 = cpu_to_le16(new_z1);\r\nbz->f1 = new_f1;\r\ndev_kfree_skb(bch->tx_skb);\r\nget_next_bframe(bch);\r\n}\r\nstatic void\r\nph_state_te(struct dchannel *dch)\r\n{\r\nif (dch->debug)\r\nprintk(KERN_DEBUG "%s: TE newstate %x\n",\r\n__func__, dch->state);\r\nswitch (dch->state) {\r\ncase 0:\r\nl1_event(dch->l1, HW_RESET_IND);\r\nbreak;\r\ncase 3:\r\nl1_event(dch->l1, HW_DEACT_IND);\r\nbreak;\r\ncase 5:\r\ncase 8:\r\nl1_event(dch->l1, ANYSIGNAL);\r\nbreak;\r\ncase 6:\r\nl1_event(dch->l1, INFO2);\r\nbreak;\r\ncase 7:\r\nl1_event(dch->l1, INFO4_P8);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nhandle_nt_timer3(struct dchannel *dch) {\r\nstruct hfc_pci *hc = dch->hw;\r\ntest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\r\nhc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nhc->hw.nt_timer = 0;\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\nif (test_bit(HFC_CFG_MASTER, &hc->cfg))\r\nhc->hw.mst_m |= HFCPCI_MASTER;\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\n_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\n}\r\nstatic void\r\nph_state_nt(struct dchannel *dch)\r\n{\r\nstruct hfc_pci *hc = dch->hw;\r\nif (dch->debug)\r\nprintk(KERN_DEBUG "%s: NT newstate %x\n",\r\n__func__, dch->state);\r\nswitch (dch->state) {\r\ncase 2:\r\nif (hc->hw.nt_timer < 0) {\r\nhc->hw.nt_timer = 0;\r\ntest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\r\ntest_and_clear_bit(FLG_HFC_TIMER_T1, &dch->Flags);\r\nhc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\n(void) Read_hfc(hc, HFCPCI_INT_S1);\r\nWrite_hfc(hc, HFCPCI_STATES, 4 | HFCPCI_LOAD_STATE);\r\nudelay(10);\r\nWrite_hfc(hc, HFCPCI_STATES, 4);\r\ndch->state = 4;\r\n} else if (hc->hw.nt_timer == 0) {\r\nhc->hw.int_m1 |= HFCPCI_INTS_TIMER;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nhc->hw.nt_timer = NT_T1_COUNT;\r\nhc->hw.ctmt &= ~HFCPCI_AUTO_TIMER;\r\nhc->hw.ctmt |= HFCPCI_TIM3_125;\r\nWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt |\r\nHFCPCI_CLTIMER);\r\ntest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\r\ntest_and_set_bit(FLG_HFC_TIMER_T1, &dch->Flags);\r\nWrite_hfc(hc, HFCPCI_STATES, 2 | HFCPCI_NT_G2_G3);\r\n} else {\r\nWrite_hfc(hc, HFCPCI_STATES, 2 | HFCPCI_NT_G2_G3);\r\n}\r\nbreak;\r\ncase 1:\r\nhc->hw.nt_timer = 0;\r\ntest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\r\ntest_and_clear_bit(FLG_HFC_TIMER_T1, &dch->Flags);\r\nhc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\nhc->hw.mst_m &= ~HFCPCI_MASTER;\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\ntest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_DEACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\nbreak;\r\ncase 4:\r\nhc->hw.nt_timer = 0;\r\ntest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\r\ntest_and_clear_bit(FLG_HFC_TIMER_T1, &dch->Flags);\r\nhc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nbreak;\r\ncase 3:\r\nif (!test_and_set_bit(FLG_HFC_TIMER_T3, &dch->Flags)) {\r\nif (!test_and_clear_bit(FLG_L2_ACTIVATED,\r\n&dch->Flags)) {\r\nhandle_nt_timer3(dch);\r\nbreak;\r\n}\r\ntest_and_clear_bit(FLG_HFC_TIMER_T1, &dch->Flags);\r\nhc->hw.int_m1 |= HFCPCI_INTS_TIMER;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nhc->hw.nt_timer = NT_T3_COUNT;\r\nhc->hw.ctmt &= ~HFCPCI_AUTO_TIMER;\r\nhc->hw.ctmt |= HFCPCI_TIM3_125;\r\nWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt |\r\nHFCPCI_CLTIMER);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nph_state(struct dchannel *dch)\r\n{\r\nstruct hfc_pci *hc = dch->hw;\r\nif (hc->hw.protocol == ISDN_P_NT_S0) {\r\nif (test_bit(FLG_HFC_TIMER_T3, &dch->Flags) &&\r\nhc->hw.nt_timer < 0)\r\nhandle_nt_timer3(dch);\r\nelse\r\nph_state_nt(dch);\r\n} else\r\nph_state_te(dch);\r\n}\r\nstatic int\r\nhfc_l1callback(struct dchannel *dch, u_int cmd)\r\n{\r\nstruct hfc_pci *hc = dch->hw;\r\nswitch (cmd) {\r\ncase INFO3_P8:\r\ncase INFO3_P10:\r\nif (test_bit(HFC_CFG_MASTER, &hc->cfg))\r\nhc->hw.mst_m |= HFCPCI_MASTER;\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\nbreak;\r\ncase HW_RESET_REQ:\r\nWrite_hfc(hc, HFCPCI_STATES, HFCPCI_LOAD_STATE | 3);\r\nudelay(6);\r\nWrite_hfc(hc, HFCPCI_STATES, 3);\r\nif (test_bit(HFC_CFG_MASTER, &hc->cfg))\r\nhc->hw.mst_m |= HFCPCI_MASTER;\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\nWrite_hfc(hc, HFCPCI_STATES, HFCPCI_ACTIVATE |\r\nHFCPCI_DO_ACTION);\r\nl1_event(dch->l1, HW_POWERUP_IND);\r\nbreak;\r\ncase HW_DEACT_REQ:\r\nhc->hw.mst_m &= ~HFCPCI_MASTER;\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\nskb_queue_purge(&dch->squeue);\r\nif (dch->tx_skb) {\r\ndev_kfree_skb(dch->tx_skb);\r\ndch->tx_skb = NULL;\r\n}\r\ndch->tx_idx = 0;\r\nif (dch->rx_skb) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\r\ndel_timer(&dch->timer);\r\nbreak;\r\ncase HW_POWERUP_REQ:\r\nWrite_hfc(hc, HFCPCI_STATES, HFCPCI_DO_ACTION);\r\nbreak;\r\ncase PH_ACTIVATE_IND:\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ncase PH_DEACTIVATE_IND:\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ndefault:\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: unknown command %x\n",\r\n__func__, cmd);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\ntx_birq(struct bchannel *bch)\r\n{\r\nif (bch->tx_skb && bch->tx_idx < bch->tx_skb->len)\r\nhfcpci_fill_fifo(bch);\r\nelse {\r\nif (bch->tx_skb)\r\ndev_kfree_skb(bch->tx_skb);\r\nif (get_next_bframe(bch))\r\nhfcpci_fill_fifo(bch);\r\n}\r\n}\r\nstatic inline void\r\ntx_dirq(struct dchannel *dch)\r\n{\r\nif (dch->tx_skb && dch->tx_idx < dch->tx_skb->len)\r\nhfcpci_fill_dfifo(dch->hw);\r\nelse {\r\nif (dch->tx_skb)\r\ndev_kfree_skb(dch->tx_skb);\r\nif (get_next_dframe(dch))\r\nhfcpci_fill_dfifo(dch->hw);\r\n}\r\n}\r\nstatic irqreturn_t\r\nhfcpci_int(int intno, void *dev_id)\r\n{\r\nstruct hfc_pci *hc = dev_id;\r\nu_char exval;\r\nstruct bchannel *bch;\r\nu_char val, stat;\r\nspin_lock(&hc->lock);\r\nif (!(hc->hw.int_m2 & 0x08)) {\r\nspin_unlock(&hc->lock);\r\nreturn IRQ_NONE;\r\n}\r\nstat = Read_hfc(hc, HFCPCI_STATUS);\r\nif (HFCPCI_ANYINT & stat) {\r\nval = Read_hfc(hc, HFCPCI_INT_S1);\r\nif (hc->dch.debug & DEBUG_HW_DCHANNEL)\r\nprintk(KERN_DEBUG\r\n"HFC-PCI: stat(%02x) s1(%02x)\n", stat, val);\r\n} else {\r\nspin_unlock(&hc->lock);\r\nreturn IRQ_NONE;\r\n}\r\nhc->irqcnt++;\r\nif (hc->dch.debug & DEBUG_HW_DCHANNEL)\r\nprintk(KERN_DEBUG "HFC-PCI irq %x\n", val);\r\nval &= hc->hw.int_m1;\r\nif (val & 0x40) {\r\nexval = Read_hfc(hc, HFCPCI_STATES) & 0xf;\r\nif (hc->dch.debug & DEBUG_HW_DCHANNEL)\r\nprintk(KERN_DEBUG "ph_state chg %d->%d\n",\r\nhc->dch.state, exval);\r\nhc->dch.state = exval;\r\nschedule_event(&hc->dch, FLG_PHCHANGE);\r\nval &= ~0x40;\r\n}\r\nif (val & 0x80) {\r\nif (hc->hw.protocol == ISDN_P_NT_S0) {\r\nif ((--hc->hw.nt_timer) < 0)\r\nschedule_event(&hc->dch, FLG_PHCHANGE);\r\n}\r\nval &= ~0x80;\r\nWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt | HFCPCI_CLTIMER);\r\n}\r\nif (val & 0x08) {\r\nbch = Sel_BCS(hc, hc->hw.bswapped ? 2 : 1);\r\nif (bch)\r\nmain_rec_hfcpci(bch);\r\nelse if (hc->dch.debug)\r\nprintk(KERN_DEBUG "hfcpci spurious 0x08 IRQ\n");\r\n}\r\nif (val & 0x10) {\r\nbch = Sel_BCS(hc, 2);\r\nif (bch)\r\nmain_rec_hfcpci(bch);\r\nelse if (hc->dch.debug)\r\nprintk(KERN_DEBUG "hfcpci spurious 0x10 IRQ\n");\r\n}\r\nif (val & 0x01) {\r\nbch = Sel_BCS(hc, hc->hw.bswapped ? 2 : 1);\r\nif (bch)\r\ntx_birq(bch);\r\nelse if (hc->dch.debug)\r\nprintk(KERN_DEBUG "hfcpci spurious 0x01 IRQ\n");\r\n}\r\nif (val & 0x02) {\r\nbch = Sel_BCS(hc, 2);\r\nif (bch)\r\ntx_birq(bch);\r\nelse if (hc->dch.debug)\r\nprintk(KERN_DEBUG "hfcpci spurious 0x02 IRQ\n");\r\n}\r\nif (val & 0x20)\r\nreceive_dmsg(hc);\r\nif (val & 0x04) {\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &hc->dch.Flags))\r\ndel_timer(&hc->dch.timer);\r\ntx_dirq(&hc->dch);\r\n}\r\nspin_unlock(&hc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nhfcpci_dbusy_timer(struct hfc_pci *hc)\r\n{\r\n}\r\nstatic int\r\nmode_hfcpci(struct bchannel *bch, int bc, int protocol)\r\n{\r\nstruct hfc_pci *hc = bch->hw;\r\nint fifo2;\r\nu_char rx_slot = 0, tx_slot = 0, pcm_mode;\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG\r\n"HFCPCI bchannel protocol %x-->%x ch %x-->%x\n",\r\nbch->state, protocol, bch->nr, bc);\r\nfifo2 = bc;\r\npcm_mode = (bc >> 24) & 0xff;\r\nif (pcm_mode) {\r\nif (!test_bit(HFC_CFG_PCM, &hc->cfg))\r\nprintk(KERN_WARNING\r\n"%s: pcm channel id without HFC_CFG_PCM\n",\r\n__func__);\r\nrx_slot = (bc >> 8) & 0xff;\r\ntx_slot = (bc >> 16) & 0xff;\r\nbc = bc & 0xff;\r\n} else if (test_bit(HFC_CFG_PCM, &hc->cfg) && (protocol > ISDN_P_NONE))\r\nprintk(KERN_WARNING "%s: no pcm channel id but HFC_CFG_PCM\n",\r\n__func__);\r\nif (hc->chanlimit > 1) {\r\nhc->hw.bswapped = 0;\r\nhc->hw.sctrl_e &= ~0x80;\r\n} else {\r\nif (bc & 2) {\r\nif (protocol != ISDN_P_NONE) {\r\nhc->hw.bswapped = 1;\r\nhc->hw.sctrl_e |= 0x80;\r\n} else {\r\nhc->hw.bswapped = 0;\r\nhc->hw.sctrl_e &= ~0x80;\r\n}\r\nfifo2 = 1;\r\n} else {\r\nhc->hw.bswapped = 0;\r\nhc->hw.sctrl_e &= ~0x80;\r\n}\r\n}\r\nswitch (protocol) {\r\ncase (-1):\r\nbch->state = -1;\r\nbch->nr = bc;\r\ncase (ISDN_P_NONE):\r\nif (bch->state == ISDN_P_NONE)\r\nreturn 0;\r\nif (bc & 2) {\r\nhc->hw.sctrl &= ~SCTRL_B2_ENA;\r\nhc->hw.sctrl_r &= ~SCTRL_B2_ENA;\r\n} else {\r\nhc->hw.sctrl &= ~SCTRL_B1_ENA;\r\nhc->hw.sctrl_r &= ~SCTRL_B1_ENA;\r\n}\r\nif (fifo2 & 2) {\r\nhc->hw.fifo_en &= ~HFCPCI_FIFOEN_B2;\r\nhc->hw.int_m1 &= ~(HFCPCI_INTS_B2TRANS +\r\nHFCPCI_INTS_B2REC);\r\n} else {\r\nhc->hw.fifo_en &= ~HFCPCI_FIFOEN_B1;\r\nhc->hw.int_m1 &= ~(HFCPCI_INTS_B1TRANS +\r\nHFCPCI_INTS_B1REC);\r\n}\r\n#ifdef REVERSE_BITORDER\r\nif (bch->nr & 2)\r\nhc->hw.cirm &= 0x7f;\r\nelse\r\nhc->hw.cirm &= 0xbf;\r\n#endif\r\nbch->state = ISDN_P_NONE;\r\nbch->nr = bc;\r\ntest_and_clear_bit(FLG_HDLC, &bch->Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT, &bch->Flags);\r\nbreak;\r\ncase (ISDN_P_B_RAW):\r\nbch->state = protocol;\r\nbch->nr = bc;\r\nhfcpci_clear_fifo_rx(hc, (fifo2 & 2) ? 1 : 0);\r\nhfcpci_clear_fifo_tx(hc, (fifo2 & 2) ? 1 : 0);\r\nif (bc & 2) {\r\nhc->hw.sctrl |= SCTRL_B2_ENA;\r\nhc->hw.sctrl_r |= SCTRL_B2_ENA;\r\n#ifdef REVERSE_BITORDER\r\nhc->hw.cirm |= 0x80;\r\n#endif\r\n} else {\r\nhc->hw.sctrl |= SCTRL_B1_ENA;\r\nhc->hw.sctrl_r |= SCTRL_B1_ENA;\r\n#ifdef REVERSE_BITORDER\r\nhc->hw.cirm |= 0x40;\r\n#endif\r\n}\r\nif (fifo2 & 2) {\r\nhc->hw.fifo_en |= HFCPCI_FIFOEN_B2;\r\nif (!tics)\r\nhc->hw.int_m1 |= (HFCPCI_INTS_B2TRANS +\r\nHFCPCI_INTS_B2REC);\r\nhc->hw.ctmt |= 2;\r\nhc->hw.conn &= ~0x18;\r\n} else {\r\nhc->hw.fifo_en |= HFCPCI_FIFOEN_B1;\r\nif (!tics)\r\nhc->hw.int_m1 |= (HFCPCI_INTS_B1TRANS +\r\nHFCPCI_INTS_B1REC);\r\nhc->hw.ctmt |= 1;\r\nhc->hw.conn &= ~0x03;\r\n}\r\ntest_and_set_bit(FLG_TRANSPARENT, &bch->Flags);\r\nbreak;\r\ncase (ISDN_P_B_HDLC):\r\nbch->state = protocol;\r\nbch->nr = bc;\r\nhfcpci_clear_fifo_rx(hc, (fifo2 & 2) ? 1 : 0);\r\nhfcpci_clear_fifo_tx(hc, (fifo2 & 2) ? 1 : 0);\r\nif (bc & 2) {\r\nhc->hw.sctrl |= SCTRL_B2_ENA;\r\nhc->hw.sctrl_r |= SCTRL_B2_ENA;\r\n} else {\r\nhc->hw.sctrl |= SCTRL_B1_ENA;\r\nhc->hw.sctrl_r |= SCTRL_B1_ENA;\r\n}\r\nif (fifo2 & 2) {\r\nhc->hw.last_bfifo_cnt[1] = 0;\r\nhc->hw.fifo_en |= HFCPCI_FIFOEN_B2;\r\nhc->hw.int_m1 |= (HFCPCI_INTS_B2TRANS +\r\nHFCPCI_INTS_B2REC);\r\nhc->hw.ctmt &= ~2;\r\nhc->hw.conn &= ~0x18;\r\n} else {\r\nhc->hw.last_bfifo_cnt[0] = 0;\r\nhc->hw.fifo_en |= HFCPCI_FIFOEN_B1;\r\nhc->hw.int_m1 |= (HFCPCI_INTS_B1TRANS +\r\nHFCPCI_INTS_B1REC);\r\nhc->hw.ctmt &= ~1;\r\nhc->hw.conn &= ~0x03;\r\n}\r\ntest_and_set_bit(FLG_HDLC, &bch->Flags);\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "prot not known %x\n", protocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (test_bit(HFC_CFG_PCM, &hc->cfg)) {\r\nif ((protocol == ISDN_P_NONE) ||\r\n(protocol == -1)) {\r\nrx_slot = 0;\r\ntx_slot = 0;\r\n} else {\r\nif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg)) {\r\nrx_slot |= 0xC0;\r\ntx_slot |= 0xC0;\r\n} else {\r\nrx_slot |= 0x80;\r\ntx_slot |= 0x80;\r\n}\r\n}\r\nif (bc & 2) {\r\nhc->hw.conn &= 0xc7;\r\nhc->hw.conn |= 0x08;\r\nprintk(KERN_DEBUG "%s: Write_hfc: B2_SSL 0x%x\n",\r\n__func__, tx_slot);\r\nprintk(KERN_DEBUG "%s: Write_hfc: B2_RSL 0x%x\n",\r\n__func__, rx_slot);\r\nWrite_hfc(hc, HFCPCI_B2_SSL, tx_slot);\r\nWrite_hfc(hc, HFCPCI_B2_RSL, rx_slot);\r\n} else {\r\nhc->hw.conn &= 0xf8;\r\nhc->hw.conn |= 0x01;\r\nprintk(KERN_DEBUG "%s: Write_hfc: B1_SSL 0x%x\n",\r\n__func__, tx_slot);\r\nprintk(KERN_DEBUG "%s: Write_hfc: B1_RSL 0x%x\n",\r\n__func__, rx_slot);\r\nWrite_hfc(hc, HFCPCI_B1_SSL, tx_slot);\r\nWrite_hfc(hc, HFCPCI_B1_RSL, rx_slot);\r\n}\r\n}\r\nWrite_hfc(hc, HFCPCI_SCTRL_E, hc->hw.sctrl_e);\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\r\nWrite_hfc(hc, HFCPCI_SCTRL, hc->hw.sctrl);\r\nWrite_hfc(hc, HFCPCI_SCTRL_R, hc->hw.sctrl_r);\r\nWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt);\r\nWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\r\n#ifdef REVERSE_BITORDER\r\nWrite_hfc(hc, HFCPCI_CIRM, hc->hw.cirm);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nset_hfcpci_rxtest(struct bchannel *bch, int protocol, int chan)\r\n{\r\nstruct hfc_pci *hc = bch->hw;\r\nif (bch->debug & DEBUG_HW_BCHANNEL)\r\nprintk(KERN_DEBUG\r\n"HFCPCI bchannel test rx protocol %x-->%x ch %x-->%x\n",\r\nbch->state, protocol, bch->nr, chan);\r\nif (bch->nr != chan) {\r\nprintk(KERN_DEBUG\r\n"HFCPCI rxtest wrong channel parameter %x/%x\n",\r\nbch->nr, chan);\r\nreturn -EINVAL;\r\n}\r\nswitch (protocol) {\r\ncase (ISDN_P_B_RAW):\r\nbch->state = protocol;\r\nhfcpci_clear_fifo_rx(hc, (chan & 2) ? 1 : 0);\r\nif (chan & 2) {\r\nhc->hw.sctrl_r |= SCTRL_B2_ENA;\r\nhc->hw.fifo_en |= HFCPCI_FIFOEN_B2RX;\r\nif (!tics)\r\nhc->hw.int_m1 |= HFCPCI_INTS_B2REC;\r\nhc->hw.ctmt |= 2;\r\nhc->hw.conn &= ~0x18;\r\n#ifdef REVERSE_BITORDER\r\nhc->hw.cirm |= 0x80;\r\n#endif\r\n} else {\r\nhc->hw.sctrl_r |= SCTRL_B1_ENA;\r\nhc->hw.fifo_en |= HFCPCI_FIFOEN_B1RX;\r\nif (!tics)\r\nhc->hw.int_m1 |= HFCPCI_INTS_B1REC;\r\nhc->hw.ctmt |= 1;\r\nhc->hw.conn &= ~0x03;\r\n#ifdef REVERSE_BITORDER\r\nhc->hw.cirm |= 0x40;\r\n#endif\r\n}\r\nbreak;\r\ncase (ISDN_P_B_HDLC):\r\nbch->state = protocol;\r\nhfcpci_clear_fifo_rx(hc, (chan & 2) ? 1 : 0);\r\nif (chan & 2) {\r\nhc->hw.sctrl_r |= SCTRL_B2_ENA;\r\nhc->hw.last_bfifo_cnt[1] = 0;\r\nhc->hw.fifo_en |= HFCPCI_FIFOEN_B2RX;\r\nhc->hw.int_m1 |= HFCPCI_INTS_B2REC;\r\nhc->hw.ctmt &= ~2;\r\nhc->hw.conn &= ~0x18;\r\n} else {\r\nhc->hw.sctrl_r |= SCTRL_B1_ENA;\r\nhc->hw.last_bfifo_cnt[0] = 0;\r\nhc->hw.fifo_en |= HFCPCI_FIFOEN_B1RX;\r\nhc->hw.int_m1 |= HFCPCI_INTS_B1REC;\r\nhc->hw.ctmt &= ~1;\r\nhc->hw.conn &= ~0x03;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "prot not known %x\n", protocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\r\nWrite_hfc(hc, HFCPCI_SCTRL_R, hc->hw.sctrl_r);\r\nWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt);\r\nWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\r\n#ifdef REVERSE_BITORDER\r\nWrite_hfc(hc, HFCPCI_CIRM, hc->hw.cirm);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void\r\ndeactivate_bchannel(struct bchannel *bch)\r\n{\r\nstruct hfc_pci *hc = bch->hw;\r\nu_long flags;\r\nspin_lock_irqsave(&hc->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nmode_hfcpci(bch, bch->nr, ISDN_P_NONE);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\n}\r\nstatic int\r\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nreturn mISDN_ctrl_bchannel(bch, cq);\r\n}\r\nstatic int\r\nhfc_bctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct hfc_pci *hc = bch->hw;\r\nint ret = -EINVAL;\r\nu_long flags;\r\nif (bch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: cmd:%x %p\n", __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase HW_TESTRX_RAW:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nret = set_hfcpci_rxtest(bch, ISDN_P_B_RAW, (int)(long)arg);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\ncase HW_TESTRX_HDLC:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nret = set_hfcpci_rxtest(bch, ISDN_P_B_HDLC, (int)(long)arg);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\ncase HW_TESTRX_OFF:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nmode_hfcpci(bch, bch->nr, ISDN_P_NONE);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nret = 0;\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\ndeactivate_bchannel(bch);\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(THIS_MODULE);\r\nret = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nret = channel_bctrl(bch, arg);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown prim(%x)\n",\r\n__func__, cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nhfcpci_l2l1D(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct hfc_pci *hc = dch->hw;\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nunsigned int id;\r\nu_long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nret = dchannel_senddata(dch, skb);\r\nif (ret > 0) {\r\nid = hh->id;\r\nhfcpci_fill_dfifo(dch->hw);\r\nret = 0;\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\r\n} else\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (hc->hw.protocol == ISDN_P_NT_S0) {\r\nret = 0;\r\nif (test_bit(HFC_CFG_MASTER, &hc->cfg))\r\nhc->hw.mst_m |= HFCPCI_MASTER;\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\nif (test_bit(FLG_ACTIVE, &dch->Flags)) {\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\n_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\nbreak;\r\n}\r\ntest_and_set_bit(FLG_L2_ACTIVATED, &dch->Flags);\r\nWrite_hfc(hc, HFCPCI_STATES, HFCPCI_ACTIVATE |\r\nHFCPCI_DO_ACTION | 1);\r\n} else\r\nret = l1_event(dch->l1, hh->prim);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\ntest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (hc->hw.protocol == ISDN_P_NT_S0) {\r\nWrite_hfc(hc, HFCPCI_STATES, 0x40);\r\nskb_queue_purge(&dch->squeue);\r\nif (dch->tx_skb) {\r\ndev_kfree_skb(dch->tx_skb);\r\ndch->tx_skb = NULL;\r\n}\r\ndch->tx_idx = 0;\r\nif (dch->rx_skb) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\r\ndel_timer(&dch->timer);\r\n#ifdef FIXME\r\nif (test_and_clear_bit(FLG_L1_BUSY, &dch->Flags))\r\ndchannel_sched_event(&hc->dch, D_CLEARBUSY);\r\n#endif\r\nhc->hw.mst_m &= ~HFCPCI_MASTER;\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\nret = 0;\r\n} else {\r\nret = l1_event(dch->l1, hh->prim);\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nhfcpci_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct hfc_pci *hc = bch->hw;\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nunsigned long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nret = bchannel_senddata(bch, skb);\r\nif (ret > 0) {\r\nhfcpci_fill_fifo(bch);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\r\nret = mode_hfcpci(bch, bch->nr, ch->protocol);\r\nelse\r\nret = 0;\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nif (!ret)\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\ndeactivate_bchannel(bch);\r\n_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nret = 0;\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic void\r\ninithfcpci(struct hfc_pci *hc)\r\n{\r\nprintk(KERN_DEBUG "inithfcpci: entered\n");\r\nhc->dch.timer.function = (void *) hfcpci_dbusy_timer;\r\nhc->dch.timer.data = (long) &hc->dch;\r\ninit_timer(&hc->dch.timer);\r\nhc->chanlimit = 2;\r\nmode_hfcpci(&hc->bch[0], 1, -1);\r\nmode_hfcpci(&hc->bch[1], 2, -1);\r\n}\r\nstatic int\r\ninit_card(struct hfc_pci *hc)\r\n{\r\nint cnt = 3;\r\nu_long flags;\r\nprintk(KERN_DEBUG "init_card: entered\n");\r\nspin_lock_irqsave(&hc->lock, flags);\r\ndisable_hwirq(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nif (request_irq(hc->irq, hfcpci_int, IRQF_SHARED, "HFC PCI", hc)) {\r\nprintk(KERN_WARNING\r\n"mISDN: couldn't get interrupt %d\n", hc->irq);\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&hc->lock, flags);\r\nreset_hfcpci(hc);\r\nwhile (cnt) {\r\ninithfcpci(hc);\r\nenable_hwirq(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\ncurrent->state = TASK_UNINTERRUPTIBLE;\r\nschedule_timeout((80 * HZ) / 1000);\r\nprintk(KERN_INFO "HFC PCI: IRQ %d count %d\n",\r\nhc->irq, hc->irqcnt);\r\nspin_lock_irqsave(&hc->lock, flags);\r\nhc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\r\nif (!hc->irqcnt) {\r\nprintk(KERN_WARNING\r\n"HFC PCI: IRQ(%d) getting no interrupts "\r\n"during init %d\n", hc->irq, 4 - cnt);\r\nif (cnt == 1)\r\nbreak;\r\nelse {\r\nreset_hfcpci(hc);\r\ncnt--;\r\n}\r\n} else {\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nhc->initdone = 1;\r\nreturn 0;\r\n}\r\n}\r\ndisable_hwirq(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nfree_irq(hc->irq, hc);\r\nreturn -EIO;\r\n}\r\nstatic int\r\nchannel_ctrl(struct hfc_pci *hc, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nu_char slot;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_LOOP | MISDN_CTRL_CONNECT |\r\nMISDN_CTRL_DISCONNECT | MISDN_CTRL_L1_TIMER3;\r\nbreak;\r\ncase MISDN_CTRL_LOOP:\r\nif (cq->channel < 0 || cq->channel > 2) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (cq->channel & 1) {\r\nif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg))\r\nslot = 0xC0;\r\nelse\r\nslot = 0x80;\r\nprintk(KERN_DEBUG "%s: Write_hfc: B1_SSL/RSL 0x%x\n",\r\n__func__, slot);\r\nWrite_hfc(hc, HFCPCI_B1_SSL, slot);\r\nWrite_hfc(hc, HFCPCI_B1_RSL, slot);\r\nhc->hw.conn = (hc->hw.conn & ~7) | 6;\r\nWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\r\n}\r\nif (cq->channel & 2) {\r\nif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg))\r\nslot = 0xC1;\r\nelse\r\nslot = 0x81;\r\nprintk(KERN_DEBUG "%s: Write_hfc: B2_SSL/RSL 0x%x\n",\r\n__func__, slot);\r\nWrite_hfc(hc, HFCPCI_B2_SSL, slot);\r\nWrite_hfc(hc, HFCPCI_B2_RSL, slot);\r\nhc->hw.conn = (hc->hw.conn & ~0x38) | 0x30;\r\nWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\r\n}\r\nif (cq->channel & 3)\r\nhc->hw.trm |= 0x80;\r\nelse {\r\nhc->hw.conn = (hc->hw.conn & ~0x3f) | 0x09;\r\nWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\r\nhc->hw.trm &= 0x7f;\r\n}\r\nWrite_hfc(hc, HFCPCI_TRM, hc->hw.trm);\r\nbreak;\r\ncase MISDN_CTRL_CONNECT:\r\nif (cq->channel == cq->p1) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (cq->channel < 1 || cq->channel > 2 ||\r\ncq->p1 < 1 || cq->p1 > 2) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg))\r\nslot = 0xC0;\r\nelse\r\nslot = 0x80;\r\nprintk(KERN_DEBUG "%s: Write_hfc: B1_SSL/RSL 0x%x\n",\r\n__func__, slot);\r\nWrite_hfc(hc, HFCPCI_B1_SSL, slot);\r\nWrite_hfc(hc, HFCPCI_B2_RSL, slot);\r\nif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg))\r\nslot = 0xC1;\r\nelse\r\nslot = 0x81;\r\nprintk(KERN_DEBUG "%s: Write_hfc: B2_SSL/RSL 0x%x\n",\r\n__func__, slot);\r\nWrite_hfc(hc, HFCPCI_B2_SSL, slot);\r\nWrite_hfc(hc, HFCPCI_B1_RSL, slot);\r\nhc->hw.conn = (hc->hw.conn & ~0x3f) | 0x36;\r\nWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\r\nhc->hw.trm |= 0x80;\r\nWrite_hfc(hc, HFCPCI_TRM, hc->hw.trm);\r\nbreak;\r\ncase MISDN_CTRL_DISCONNECT:\r\nhc->hw.conn = (hc->hw.conn & ~0x3f) | 0x09;\r\nWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\r\nhc->hw.trm &= 0x7f;\r\nbreak;\r\ncase MISDN_CTRL_L1_TIMER3:\r\nret = l1_event(hc->dch.l1, HW_TIMER3_VALUE | (cq->p1 & 0xff));\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown Op %x\n",\r\n__func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nopen_dchannel(struct hfc_pci *hc, struct mISDNchannel *ch,\r\nstruct channel_req *rq)\r\n{\r\nint err = 0;\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG "%s: dev(%d) open from %p\n", __func__,\r\nhc->dch.dev.id, __builtin_return_address(0));\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nif (rq->adr.channel == 1) {\r\nreturn -EINVAL;\r\n}\r\nif (!hc->initdone) {\r\nif (rq->protocol == ISDN_P_TE_S0) {\r\nerr = create_l1(&hc->dch, hfc_l1callback);\r\nif (err)\r\nreturn err;\r\n}\r\nhc->hw.protocol = rq->protocol;\r\nch->protocol = rq->protocol;\r\nerr = init_card(hc);\r\nif (err)\r\nreturn err;\r\n} else {\r\nif (rq->protocol != ch->protocol) {\r\nif (hc->hw.protocol == ISDN_P_TE_S0)\r\nl1_event(hc->dch.l1, CLOSE_CHANNEL);\r\nif (rq->protocol == ISDN_P_TE_S0) {\r\nerr = create_l1(&hc->dch, hfc_l1callback);\r\nif (err)\r\nreturn err;\r\n}\r\nhc->hw.protocol = rq->protocol;\r\nch->protocol = rq->protocol;\r\nhfcpci_setmode(hc);\r\n}\r\n}\r\nif (((ch->protocol == ISDN_P_NT_S0) && (hc->dch.state == 3)) ||\r\n((ch->protocol == ISDN_P_TE_S0) && (hc->dch.state == 7))) {\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\r\n0, NULL, GFP_KERNEL);\r\n}\r\nrq->ch = ch;\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s:cannot get module\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nopen_bchannel(struct hfc_pci *hc, struct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nif (rq->adr.channel == 0 || rq->adr.channel > 2)\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nbch = &hc->bch[rq->adr.channel - 1];\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\nbch->ch.protocol = rq->protocol;\r\nrq->ch = &bch->ch;\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s:cannot get module\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nhfc_dctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct hfc_pci *hc = dch->hw;\r\nstruct channel_req *rq;\r\nint err = 0;\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: cmd:%x %p\n",\r\n__func__, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nif ((rq->protocol == ISDN_P_TE_S0) ||\r\n(rq->protocol == ISDN_P_NT_S0))\r\nerr = open_dchannel(hc, ch, rq);\r\nelse\r\nerr = open_bchannel(hc, rq);\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG "%s: dev(%d) close from %p\n",\r\n__func__, hc->dch.dev.id,\r\n__builtin_return_address(0));\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_ctrl(hc, arg);\r\nbreak;\r\ndefault:\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: unknown command %x\n",\r\n__func__, cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nsetup_hw(struct hfc_pci *hc)\r\n{\r\nvoid *buffer;\r\nprintk(KERN_INFO "mISDN: HFC-PCI driver %s\n", hfcpci_revision);\r\nhc->hw.cirm = 0;\r\nhc->dch.state = 0;\r\npci_set_master(hc->pdev);\r\nif (!hc->irq) {\r\nprintk(KERN_WARNING "HFC-PCI: No IRQ for PCI card found\n");\r\nreturn 1;\r\n}\r\nhc->hw.pci_io =\r\n(char __iomem *)(unsigned long)hc->pdev->resource[1].start;\r\nif (!hc->hw.pci_io) {\r\nprintk(KERN_WARNING "HFC-PCI: No IO-Mem for PCI card found\n");\r\nreturn 1;\r\n}\r\npci_set_dma_mask(hc->pdev, 0xFFFF8000);\r\nbuffer = pci_alloc_consistent(hc->pdev, 0x8000, &hc->hw.dmahandle);\r\nif (!buffer) {\r\nprintk(KERN_WARNING\r\n"HFC-PCI: Error allocating memory for FIFO!\n");\r\nreturn 1;\r\n}\r\nhc->hw.fifos = buffer;\r\npci_write_config_dword(hc->pdev, 0x80, hc->hw.dmahandle);\r\nhc->hw.pci_io = ioremap((ulong) hc->hw.pci_io, 256);\r\nprintk(KERN_INFO\r\n"HFC-PCI: defined at mem %#lx fifo %#lx(%#lx) IRQ %d HZ %d\n",\r\n(u_long) hc->hw.pci_io, (u_long) hc->hw.fifos,\r\n(u_long) hc->hw.dmahandle, hc->irq, HZ);\r\npci_write_config_word(hc->pdev, PCI_COMMAND, PCI_ENA_MEMIO);\r\nhc->hw.int_m2 = 0;\r\ndisable_hwirq(hc);\r\nhc->hw.int_m1 = 0;\r\nWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\r\nhc->hw.timer.function = (void *) hfcpci_Timer;\r\nhc->hw.timer.data = (long) hc;\r\ninit_timer(&hc->hw.timer);\r\ntest_and_set_bit(HFC_CFG_MASTER, &hc->cfg);\r\nreturn 0;\r\n}\r\nstatic void\r\nrelease_card(struct hfc_pci *hc) {\r\nu_long flags;\r\nspin_lock_irqsave(&hc->lock, flags);\r\nhc->hw.int_m2 = 0;\r\ndisable_hwirq(hc);\r\nmode_hfcpci(&hc->bch[0], 1, ISDN_P_NONE);\r\nmode_hfcpci(&hc->bch[1], 2, ISDN_P_NONE);\r\nif (hc->dch.timer.function != NULL) {\r\ndel_timer(&hc->dch.timer);\r\nhc->dch.timer.function = NULL;\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nif (hc->hw.protocol == ISDN_P_TE_S0)\r\nl1_event(hc->dch.l1, CLOSE_CHANNEL);\r\nif (hc->initdone)\r\nfree_irq(hc->irq, hc);\r\nrelease_io_hfcpci(hc);\r\nmISDN_unregister_device(&hc->dch.dev);\r\nmISDN_freebchannel(&hc->bch[1]);\r\nmISDN_freebchannel(&hc->bch[0]);\r\nmISDN_freedchannel(&hc->dch);\r\npci_set_drvdata(hc->pdev, NULL);\r\nkfree(hc);\r\n}\r\nstatic int\r\nsetup_card(struct hfc_pci *card)\r\n{\r\nint err = -EINVAL;\r\nu_int i;\r\nchar name[MISDN_MAX_IDLEN];\r\ncard->dch.debug = debug;\r\nspin_lock_init(&card->lock);\r\nmISDN_initdchannel(&card->dch, MAX_DFRAME_LEN_L1, ph_state);\r\ncard->dch.hw = card;\r\ncard->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);\r\ncard->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\ncard->dch.dev.D.send = hfcpci_l2l1D;\r\ncard->dch.dev.D.ctrl = hfc_dctrl;\r\ncard->dch.dev.nrbchan = 2;\r\nfor (i = 0; i < 2; i++) {\r\ncard->bch[i].nr = i + 1;\r\nset_channelmap(i + 1, card->dch.dev.channelmap);\r\ncard->bch[i].debug = debug;\r\nmISDN_initbchannel(&card->bch[i], MAX_DATA_MEM, poll >> 1);\r\ncard->bch[i].hw = card;\r\ncard->bch[i].ch.send = hfcpci_l2l1B;\r\ncard->bch[i].ch.ctrl = hfc_bctrl;\r\ncard->bch[i].ch.nr = i + 1;\r\nlist_add(&card->bch[i].ch.list, &card->dch.dev.bchannels);\r\n}\r\nerr = setup_hw(card);\r\nif (err)\r\ngoto error;\r\nsnprintf(name, MISDN_MAX_IDLEN - 1, "hfc-pci.%d", HFC_cnt + 1);\r\nerr = mISDN_register_device(&card->dch.dev, &card->pdev->dev, name);\r\nif (err)\r\ngoto error;\r\nHFC_cnt++;\r\nprintk(KERN_INFO "HFC %d cards installed\n", HFC_cnt);\r\nreturn 0;\r\nerror:\r\nmISDN_freebchannel(&card->bch[1]);\r\nmISDN_freebchannel(&card->bch[0]);\r\nmISDN_freedchannel(&card->dch);\r\nkfree(card);\r\nreturn err;\r\n}\r\nstatic int\r\nhfc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = -ENOMEM;\r\nstruct hfc_pci *card;\r\nstruct _hfc_map *m = (struct _hfc_map *)ent->driver_data;\r\ncard = kzalloc(sizeof(struct hfc_pci), GFP_ATOMIC);\r\nif (!card) {\r\nprintk(KERN_ERR "No kmem for HFC card\n");\r\nreturn err;\r\n}\r\ncard->pdev = pdev;\r\ncard->subtype = m->subtype;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nkfree(card);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "mISDN_hfcpci: found adapter %s at %s\n",\r\nm->name, pci_name(pdev));\r\ncard->irq = pdev->irq;\r\npci_set_drvdata(pdev, card);\r\nerr = setup_card(card);\r\nif (err)\r\npci_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nstatic void\r\nhfc_remove_pci(struct pci_dev *pdev)\r\n{\r\nstruct hfc_pci *card = pci_get_drvdata(pdev);\r\nif (card)\r\nrelease_card(card);\r\nelse\r\nif (debug)\r\nprintk(KERN_DEBUG "%s: drvdata already removed\n",\r\n__func__);\r\n}\r\nstatic int\r\n_hfcpci_softirq(struct device *dev, void *arg)\r\n{\r\nstruct hfc_pci *hc = dev_get_drvdata(dev);\r\nstruct bchannel *bch;\r\nif (hc == NULL)\r\nreturn 0;\r\nif (hc->hw.int_m2 & HFCPCI_IRQ_ENABLE) {\r\nspin_lock(&hc->lock);\r\nbch = Sel_BCS(hc, hc->hw.bswapped ? 2 : 1);\r\nif (bch && bch->state == ISDN_P_B_RAW) {\r\nmain_rec_hfcpci(bch);\r\ntx_birq(bch);\r\n}\r\nbch = Sel_BCS(hc, hc->hw.bswapped ? 1 : 2);\r\nif (bch && bch->state == ISDN_P_B_RAW) {\r\nmain_rec_hfcpci(bch);\r\ntx_birq(bch);\r\n}\r\nspin_unlock(&hc->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nhfcpci_softirq(void *arg)\r\n{\r\n(void) driver_for_each_device(&hfc_driver.driver, NULL, arg,\r\n_hfcpci_softirq);\r\nif ((s32)(hfc_jiffies + tics - jiffies) <= 0)\r\nhfc_jiffies = jiffies + 1;\r\nelse\r\nhfc_jiffies += tics;\r\nhfc_tl.expires = hfc_jiffies;\r\nadd_timer(&hfc_tl);\r\n}\r\nstatic int __init\r\nHFC_init(void)\r\n{\r\nint err;\r\nif (!poll)\r\npoll = HFCPCI_BTRANS_THRESHOLD;\r\nif (poll != HFCPCI_BTRANS_THRESHOLD) {\r\ntics = (poll * HZ) / 8000;\r\nif (tics < 1)\r\ntics = 1;\r\npoll = (tics * 8000) / HZ;\r\nif (poll > 256 || poll < 8) {\r\nprintk(KERN_ERR "%s: Wrong poll value %d not in range "\r\n"of 8..256.\n", __func__, poll);\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\n}\r\nif (poll != HFCPCI_BTRANS_THRESHOLD) {\r\nprintk(KERN_INFO "%s: Using alternative poll value of %d\n",\r\n__func__, poll);\r\nhfc_tl.function = (void *)hfcpci_softirq;\r\nhfc_tl.data = 0;\r\ninit_timer(&hfc_tl);\r\nhfc_tl.expires = jiffies + tics;\r\nhfc_jiffies = hfc_tl.expires;\r\nadd_timer(&hfc_tl);\r\n} else\r\ntics = 0;\r\nerr = pci_register_driver(&hfc_driver);\r\nif (err) {\r\nif (timer_pending(&hfc_tl))\r\ndel_timer(&hfc_tl);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit\r\nHFC_cleanup(void)\r\n{\r\nif (timer_pending(&hfc_tl))\r\ndel_timer(&hfc_tl);\r\npci_unregister_driver(&hfc_driver);\r\n}
