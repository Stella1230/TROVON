static struct hid_blacklist *usbhid_exists_dquirk(const u16 idVendor,\r\nconst u16 idProduct)\r\n{\r\nstruct quirks_list_struct *q;\r\nstruct hid_blacklist *bl_entry = NULL;\r\nlist_for_each_entry(q, &dquirks_list, node) {\r\nif (q->hid_bl_item.idVendor == idVendor &&\r\nq->hid_bl_item.idProduct == idProduct) {\r\nbl_entry = &q->hid_bl_item;\r\nbreak;\r\n}\r\n}\r\nif (bl_entry != NULL)\r\ndbg_hid("Found dynamic quirk 0x%x for USB HID vendor 0x%hx prod 0x%hx\n",\r\nbl_entry->quirks, bl_entry->idVendor,\r\nbl_entry->idProduct);\r\nreturn bl_entry;\r\n}\r\nstatic int usbhid_modify_dquirk(const u16 idVendor, const u16 idProduct,\r\nconst u32 quirks)\r\n{\r\nstruct quirks_list_struct *q_new, *q;\r\nint list_edited = 0;\r\nif (!idVendor) {\r\ndbg_hid("Cannot add a quirk with idVendor = 0\n");\r\nreturn -EINVAL;\r\n}\r\nq_new = kmalloc(sizeof(struct quirks_list_struct), GFP_KERNEL);\r\nif (!q_new) {\r\ndbg_hid("Could not allocate quirks_list_struct\n");\r\nreturn -ENOMEM;\r\n}\r\nq_new->hid_bl_item.idVendor = idVendor;\r\nq_new->hid_bl_item.idProduct = idProduct;\r\nq_new->hid_bl_item.quirks = quirks;\r\ndown_write(&dquirks_rwsem);\r\nlist_for_each_entry(q, &dquirks_list, node) {\r\nif (q->hid_bl_item.idVendor == idVendor &&\r\nq->hid_bl_item.idProduct == idProduct) {\r\nlist_replace(&q->node, &q_new->node);\r\nkfree(q);\r\nlist_edited = 1;\r\nbreak;\r\n}\r\n}\r\nif (!list_edited)\r\nlist_add_tail(&q_new->node, &dquirks_list);\r\nup_write(&dquirks_rwsem);\r\nreturn 0;\r\n}\r\nstatic void usbhid_remove_all_dquirks(void)\r\n{\r\nstruct quirks_list_struct *q, *temp;\r\ndown_write(&dquirks_rwsem);\r\nlist_for_each_entry_safe(q, temp, &dquirks_list, node) {\r\nlist_del(&q->node);\r\nkfree(q);\r\n}\r\nup_write(&dquirks_rwsem);\r\n}\r\nint usbhid_quirks_init(char **quirks_param)\r\n{\r\nu16 idVendor, idProduct;\r\nu32 quirks;\r\nint n = 0, m;\r\nfor (; n < MAX_USBHID_BOOT_QUIRKS && quirks_param[n]; n++) {\r\nm = sscanf(quirks_param[n], "0x%hx:0x%hx:0x%x",\r\n&idVendor, &idProduct, &quirks);\r\nif (m != 3 ||\r\nusbhid_modify_dquirk(idVendor, idProduct, quirks) != 0) {\r\nprintk(KERN_WARNING\r\n"Could not parse HID quirk module param %s\n",\r\nquirks_param[n]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid usbhid_quirks_exit(void)\r\n{\r\nusbhid_remove_all_dquirks();\r\n}\r\nstatic const struct hid_blacklist *usbhid_exists_squirk(const u16 idVendor,\r\nconst u16 idProduct)\r\n{\r\nconst struct hid_blacklist *bl_entry = NULL;\r\nint n = 0;\r\nfor (; hid_blacklist[n].idVendor; n++)\r\nif (hid_blacklist[n].idVendor == idVendor &&\r\nhid_blacklist[n].idProduct == idProduct)\r\nbl_entry = &hid_blacklist[n];\r\nif (bl_entry != NULL)\r\ndbg_hid("Found squirk 0x%x for USB HID vendor 0x%hx prod 0x%hx\n",\r\nbl_entry->quirks, bl_entry->idVendor,\r\nbl_entry->idProduct);\r\nreturn bl_entry;\r\n}\r\nu32 usbhid_lookup_quirk(const u16 idVendor, const u16 idProduct)\r\n{\r\nu32 quirks = 0;\r\nconst struct hid_blacklist *bl_entry = NULL;\r\nif (idVendor == USB_VENDOR_ID_NCR &&\r\nidProduct >= USB_DEVICE_ID_NCR_FIRST &&\r\nidProduct <= USB_DEVICE_ID_NCR_LAST)\r\nreturn HID_QUIRK_NO_INIT_REPORTS;\r\ndown_read(&dquirks_rwsem);\r\nbl_entry = usbhid_exists_dquirk(idVendor, idProduct);\r\nif (!bl_entry)\r\nbl_entry = usbhid_exists_squirk(idVendor, idProduct);\r\nif (bl_entry)\r\nquirks = bl_entry->quirks;\r\nup_read(&dquirks_rwsem);\r\nreturn quirks;\r\n}
