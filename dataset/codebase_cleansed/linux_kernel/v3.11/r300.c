void rv370_pcie_gart_tlb_flush(struct radeon_device *rdev)\r\n{\r\nuint32_t tmp;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp | RADEON_PCIE_TX_GART_INVALIDATE_TLB);\r\n(void)RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp);\r\n}\r\nmb();\r\n}\r\nint rv370_pcie_gart_set_page(struct radeon_device *rdev, int i, uint64_t addr)\r\n{\r\nvoid __iomem *ptr = rdev->gart.ptr;\r\nif (i < 0 || i > rdev->gart.num_gpu_pages) {\r\nreturn -EINVAL;\r\n}\r\naddr = (lower_32_bits(addr) >> 8) |\r\n((upper_32_bits(addr) & 0xff) << 24) |\r\nR300_PTE_WRITEABLE | R300_PTE_READABLE;\r\nwritel(addr, ((void __iomem *)ptr) + (i * 4));\r\nreturn 0;\r\n}\r\nint rv370_pcie_gart_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (rdev->gart.robj) {\r\nWARN(1, "RV370 PCIE GART already initialized\n");\r\nreturn 0;\r\n}\r\nr = radeon_gart_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = rv370_debugfs_pcie_gart_info_init(rdev);\r\nif (r)\r\nDRM_ERROR("Failed to register debugfs file for PCIE gart !\n");\r\nrdev->gart.table_size = rdev->gart.num_gpu_pages * 4;\r\nrdev->asic->gart.tlb_flush = &rv370_pcie_gart_tlb_flush;\r\nrdev->asic->gart.set_page = &rv370_pcie_gart_set_page;\r\nreturn radeon_gart_table_vram_alloc(rdev);\r\n}\r\nint rv370_pcie_gart_enable(struct radeon_device *rdev)\r\n{\r\nuint32_t table_addr;\r\nuint32_t tmp;\r\nint r;\r\nif (rdev->gart.robj == NULL) {\r\ndev_err(rdev->dev, "No VRAM object for PCIE GART.\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_gart_table_vram_pin(rdev);\r\nif (r)\r\nreturn r;\r\nradeon_gart_restore(rdev);\r\ntmp = RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_DISCARD;\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_START_LO, rdev->mc.gtt_start);\r\ntmp = rdev->mc.gtt_end & ~RADEON_GPU_PAGE_MASK;\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_END_LO, tmp);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_START_HI, 0);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_END_HI, 0);\r\ntable_addr = rdev->gart.table_addr;\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_BASE, table_addr);\r\nWREG32_PCIE(RADEON_PCIE_TX_DISCARD_RD_ADDR_LO, rdev->mc.vram_start);\r\nWREG32_PCIE(RADEON_PCIE_TX_DISCARD_RD_ADDR_HI, 0);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_ERROR, 0);\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\r\ntmp |= RADEON_PCIE_TX_GART_EN;\r\ntmp |= RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_DISCARD;\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp);\r\nrv370_pcie_gart_tlb_flush(rdev);\r\nDRM_INFO("PCIE GART of %uM enabled (table at 0x%016llX).\n",\r\n(unsigned)(rdev->mc.gtt_size >> 20),\r\n(unsigned long long)table_addr);\r\nrdev->gart.ready = true;\r\nreturn 0;\r\n}\r\nvoid rv370_pcie_gart_disable(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_START_LO, 0);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_END_LO, 0);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_START_HI, 0);\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_END_HI, 0);\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\r\ntmp |= RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_DISCARD;\r\nWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp & ~RADEON_PCIE_TX_GART_EN);\r\nradeon_gart_table_vram_unpin(rdev);\r\n}\r\nvoid rv370_pcie_gart_fini(struct radeon_device *rdev)\r\n{\r\nradeon_gart_fini(rdev);\r\nrv370_pcie_gart_disable(rdev);\r\nradeon_gart_table_vram_free(rdev);\r\n}\r\nvoid r300_fence_ring_emit(struct radeon_device *rdev,\r\nstruct radeon_fence *fence)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[fence->ring];\r\nradeon_ring_write(ring, PACKET0(R300_RE_SCISSORS_TL, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(R300_RE_SCISSORS_BR, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, R300_RB3D_DC_FLUSH);\r\nradeon_ring_write(ring, PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, R300_ZC_FLUSH);\r\nradeon_ring_write(ring, PACKET0(RADEON_WAIT_UNTIL, 0));\r\nradeon_ring_write(ring, (RADEON_WAIT_3D_IDLECLEAN |\r\nRADEON_WAIT_2D_IDLECLEAN |\r\nRADEON_WAIT_DMA_GUI_IDLE));\r\nradeon_ring_write(ring, PACKET0(RADEON_HOST_PATH_CNTL, 0));\r\nradeon_ring_write(ring, rdev->config.r300.hdp_cntl |\r\nRADEON_HDP_READ_BUFFER_INVALIDATE);\r\nradeon_ring_write(ring, PACKET0(RADEON_HOST_PATH_CNTL, 0));\r\nradeon_ring_write(ring, rdev->config.r300.hdp_cntl);\r\nradeon_ring_write(ring, PACKET0(rdev->fence_drv[fence->ring].scratch_reg, 0));\r\nradeon_ring_write(ring, fence->seq);\r\nradeon_ring_write(ring, PACKET0(RADEON_GEN_INT_STATUS, 0));\r\nradeon_ring_write(ring, RADEON_SW_INT_FIRE);\r\n}\r\nvoid r300_ring_start(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nunsigned gb_tile_config;\r\nint r;\r\ngb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16);\r\nswitch(rdev->num_gb_pipes) {\r\ncase 2:\r\ngb_tile_config |= R300_PIPE_COUNT_R300;\r\nbreak;\r\ncase 3:\r\ngb_tile_config |= R300_PIPE_COUNT_R420_3P;\r\nbreak;\r\ncase 4:\r\ngb_tile_config |= R300_PIPE_COUNT_R420;\r\nbreak;\r\ncase 1:\r\ndefault:\r\ngb_tile_config |= R300_PIPE_COUNT_RV350;\r\nbreak;\r\n}\r\nr = radeon_ring_lock(rdev, ring, 64);\r\nif (r) {\r\nreturn;\r\n}\r\nradeon_ring_write(ring, PACKET0(RADEON_ISYNC_CNTL, 0));\r\nradeon_ring_write(ring,\r\nRADEON_ISYNC_ANY2D_IDLE3D |\r\nRADEON_ISYNC_ANY3D_IDLE2D |\r\nRADEON_ISYNC_WAIT_IDLEGUI |\r\nRADEON_ISYNC_CPSCRATCH_IDLEGUI);\r\nradeon_ring_write(ring, PACKET0(R300_GB_TILE_CONFIG, 0));\r\nradeon_ring_write(ring, gb_tile_config);\r\nradeon_ring_write(ring, PACKET0(RADEON_WAIT_UNTIL, 0));\r\nradeon_ring_write(ring,\r\nRADEON_WAIT_2D_IDLECLEAN |\r\nRADEON_WAIT_3D_IDLECLEAN);\r\nradeon_ring_write(ring, PACKET0(R300_DST_PIPE_CONFIG, 0));\r\nradeon_ring_write(ring, R300_PIPE_AUTO_CONFIG);\r\nradeon_ring_write(ring, PACKET0(R300_GB_SELECT, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(R300_GB_ENABLE, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, R300_RB3D_DC_FLUSH | R300_RB3D_DC_FREE);\r\nradeon_ring_write(ring, PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, R300_ZC_FLUSH | R300_ZC_FREE);\r\nradeon_ring_write(ring, PACKET0(RADEON_WAIT_UNTIL, 0));\r\nradeon_ring_write(ring,\r\nRADEON_WAIT_2D_IDLECLEAN |\r\nRADEON_WAIT_3D_IDLECLEAN);\r\nradeon_ring_write(ring, PACKET0(R300_GB_AA_CONFIG, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, R300_RB3D_DC_FLUSH | R300_RB3D_DC_FREE);\r\nradeon_ring_write(ring, PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, R300_ZC_FLUSH | R300_ZC_FREE);\r\nradeon_ring_write(ring, PACKET0(R300_GB_MSPOS0, 0));\r\nradeon_ring_write(ring,\r\n((6 << R300_MS_X0_SHIFT) |\r\n(6 << R300_MS_Y0_SHIFT) |\r\n(6 << R300_MS_X1_SHIFT) |\r\n(6 << R300_MS_Y1_SHIFT) |\r\n(6 << R300_MS_X2_SHIFT) |\r\n(6 << R300_MS_Y2_SHIFT) |\r\n(6 << R300_MSBD0_Y_SHIFT) |\r\n(6 << R300_MSBD0_X_SHIFT)));\r\nradeon_ring_write(ring, PACKET0(R300_GB_MSPOS1, 0));\r\nradeon_ring_write(ring,\r\n((6 << R300_MS_X3_SHIFT) |\r\n(6 << R300_MS_Y3_SHIFT) |\r\n(6 << R300_MS_X4_SHIFT) |\r\n(6 << R300_MS_Y4_SHIFT) |\r\n(6 << R300_MS_X5_SHIFT) |\r\n(6 << R300_MS_Y5_SHIFT) |\r\n(6 << R300_MSBD1_SHIFT)));\r\nradeon_ring_write(ring, PACKET0(R300_GA_ENHANCE, 0));\r\nradeon_ring_write(ring, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL);\r\nradeon_ring_write(ring, PACKET0(R300_GA_POLY_MODE, 0));\r\nradeon_ring_write(ring,\r\nR300_FRONT_PTYPE_TRIANGE | R300_BACK_PTYPE_TRIANGE);\r\nradeon_ring_write(ring, PACKET0(R300_GA_ROUND_MODE, 0));\r\nradeon_ring_write(ring,\r\nR300_GEOMETRY_ROUND_NEAREST |\r\nR300_COLOR_ROUND_NEAREST);\r\nradeon_ring_unlock_commit(rdev, ring);\r\n}\r\nstatic void r300_errata(struct radeon_device *rdev)\r\n{\r\nrdev->pll_errata = 0;\r\nif (rdev->family == CHIP_R300 &&\r\n(RREG32(RADEON_CONFIG_CNTL) & RADEON_CFG_ATI_REV_ID_MASK) == RADEON_CFG_ATI_REV_A11) {\r\nrdev->pll_errata |= CHIP_ERRATA_R300_CG;\r\n}\r\n}\r\nint r300_mc_wait_for_idle(struct radeon_device *rdev)\r\n{\r\nunsigned i;\r\nuint32_t tmp;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = RREG32(RADEON_MC_STATUS);\r\nif (tmp & R300_MC_IDLE) {\r\nreturn 0;\r\n}\r\nDRM_UDELAY(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic void r300_gpu_init(struct radeon_device *rdev)\r\n{\r\nuint32_t gb_tile_config, tmp;\r\nif ((rdev->family == CHIP_R300 && rdev->pdev->device != 0x4144) ||\r\n(rdev->family == CHIP_R350 && rdev->pdev->device != 0x4148)) {\r\nrdev->num_gb_pipes = 2;\r\n} else {\r\nrdev->num_gb_pipes = 1;\r\n}\r\nrdev->num_z_pipes = 1;\r\ngb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16);\r\nswitch (rdev->num_gb_pipes) {\r\ncase 2:\r\ngb_tile_config |= R300_PIPE_COUNT_R300;\r\nbreak;\r\ncase 3:\r\ngb_tile_config |= R300_PIPE_COUNT_R420_3P;\r\nbreak;\r\ncase 4:\r\ngb_tile_config |= R300_PIPE_COUNT_R420;\r\nbreak;\r\ndefault:\r\ncase 1:\r\ngb_tile_config |= R300_PIPE_COUNT_RV350;\r\nbreak;\r\n}\r\nWREG32(R300_GB_TILE_CONFIG, gb_tile_config);\r\nif (r100_gui_wait_for_idle(rdev)) {\r\nprintk(KERN_WARNING "Failed to wait GUI idle while "\r\n"programming pipes. Bad things might happen.\n");\r\n}\r\ntmp = RREG32(R300_DST_PIPE_CONFIG);\r\nWREG32(R300_DST_PIPE_CONFIG, tmp | R300_PIPE_AUTO_CONFIG);\r\nWREG32(R300_RB2D_DSTCACHE_MODE,\r\nR300_DC_AUTOFLUSH_ENABLE |\r\nR300_DC_DC_DISABLE_IGNORE_PE);\r\nif (r100_gui_wait_for_idle(rdev)) {\r\nprintk(KERN_WARNING "Failed to wait GUI idle while "\r\n"programming pipes. Bad things might happen.\n");\r\n}\r\nif (r300_mc_wait_for_idle(rdev)) {\r\nprintk(KERN_WARNING "Failed to wait MC idle while "\r\n"programming pipes. Bad things might happen.\n");\r\n}\r\nDRM_INFO("radeon: %d quad pipes, %d Z pipes initialized.\n",\r\nrdev->num_gb_pipes, rdev->num_z_pipes);\r\n}\r\nint r300_asic_reset(struct radeon_device *rdev)\r\n{\r\nstruct r100_mc_save save;\r\nu32 status, tmp;\r\nint ret = 0;\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\nif (!G_000E40_GUI_ACTIVE(status)) {\r\nreturn 0;\r\n}\r\nr100_mc_stop(rdev, &save);\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\ndev_info(rdev->dev, "(%s:%d) RBBM_STATUS=0x%08X\n", __func__, __LINE__, status);\r\nWREG32(RADEON_CP_CSQ_CNTL, 0);\r\ntmp = RREG32(RADEON_CP_RB_CNTL);\r\nWREG32(RADEON_CP_RB_CNTL, tmp | RADEON_RB_RPTR_WR_ENA);\r\nWREG32(RADEON_CP_RB_RPTR_WR, 0);\r\nWREG32(RADEON_CP_RB_WPTR, 0);\r\nWREG32(RADEON_CP_RB_CNTL, tmp);\r\npci_save_state(rdev->pdev);\r\nr100_bm_disable(rdev);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_VAP(1) |\r\nS_0000F0_SOFT_RESET_GA(1));\r\nRREG32(R_0000F0_RBBM_SOFT_RESET);\r\nmdelay(500);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\r\nmdelay(1);\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\ndev_info(rdev->dev, "(%s:%d) RBBM_STATUS=0x%08X\n", __func__, __LINE__, status);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_CP(1));\r\nRREG32(R_0000F0_RBBM_SOFT_RESET);\r\nmdelay(500);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\r\nmdelay(1);\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\ndev_info(rdev->dev, "(%s:%d) RBBM_STATUS=0x%08X\n", __func__, __LINE__, status);\r\npci_restore_state(rdev->pdev);\r\nr100_enable_bm(rdev);\r\nif (G_000E40_GA_BUSY(status) || G_000E40_VAP_BUSY(status)) {\r\ndev_err(rdev->dev, "failed to reset GPU\n");\r\nret = -1;\r\n} else\r\ndev_info(rdev->dev, "GPU reset succeed\n");\r\nr100_mc_resume(rdev, &save);\r\nreturn ret;\r\n}\r\nvoid r300_mc_init(struct radeon_device *rdev)\r\n{\r\nu64 base;\r\nu32 tmp;\r\nrdev->mc.vram_is_ddr = true;\r\ntmp = RREG32(RADEON_MEM_CNTL);\r\ntmp &= R300_MEM_NUM_CHANNELS_MASK;\r\nswitch (tmp) {\r\ncase 0: rdev->mc.vram_width = 64; break;\r\ncase 1: rdev->mc.vram_width = 128; break;\r\ncase 2: rdev->mc.vram_width = 256; break;\r\ndefault: rdev->mc.vram_width = 128; break;\r\n}\r\nr100_vram_init_sizes(rdev);\r\nbase = rdev->mc.aper_base;\r\nif (rdev->flags & RADEON_IS_IGP)\r\nbase = (RREG32(RADEON_NB_TOM) & 0xffff) << 16;\r\nradeon_vram_location(rdev, &rdev->mc, base);\r\nrdev->mc.gtt_base_align = 0;\r\nif (!(rdev->flags & RADEON_IS_AGP))\r\nradeon_gtt_location(rdev, &rdev->mc);\r\nradeon_update_bandwidth_info(rdev);\r\n}\r\nvoid rv370_set_pcie_lanes(struct radeon_device *rdev, int lanes)\r\n{\r\nuint32_t link_width_cntl, mask;\r\nif (rdev->flags & RADEON_IS_IGP)\r\nreturn;\r\nif (!(rdev->flags & RADEON_IS_PCIE))\r\nreturn;\r\nswitch (lanes) {\r\ncase 0:\r\nmask = RADEON_PCIE_LC_LINK_WIDTH_X0;\r\nbreak;\r\ncase 1:\r\nmask = RADEON_PCIE_LC_LINK_WIDTH_X1;\r\nbreak;\r\ncase 2:\r\nmask = RADEON_PCIE_LC_LINK_WIDTH_X2;\r\nbreak;\r\ncase 4:\r\nmask = RADEON_PCIE_LC_LINK_WIDTH_X4;\r\nbreak;\r\ncase 8:\r\nmask = RADEON_PCIE_LC_LINK_WIDTH_X8;\r\nbreak;\r\ncase 12:\r\nmask = RADEON_PCIE_LC_LINK_WIDTH_X12;\r\nbreak;\r\ncase 16:\r\ndefault:\r\nmask = RADEON_PCIE_LC_LINK_WIDTH_X16;\r\nbreak;\r\n}\r\nlink_width_cntl = RREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\r\nif ((link_width_cntl & RADEON_PCIE_LC_LINK_WIDTH_RD_MASK) ==\r\n(mask << RADEON_PCIE_LC_LINK_WIDTH_RD_SHIFT))\r\nreturn;\r\nlink_width_cntl &= ~(RADEON_PCIE_LC_LINK_WIDTH_MASK |\r\nRADEON_PCIE_LC_RECONFIG_NOW |\r\nRADEON_PCIE_LC_RECONFIG_LATER |\r\nRADEON_PCIE_LC_SHORT_RECONFIG_EN);\r\nlink_width_cntl |= mask;\r\nWREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\r\nWREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL, (link_width_cntl |\r\nRADEON_PCIE_LC_RECONFIG_NOW));\r\nlink_width_cntl = RREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\r\nwhile (link_width_cntl == 0xffffffff)\r\nlink_width_cntl = RREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\r\n}\r\nint rv370_get_pcie_lanes(struct radeon_device *rdev)\r\n{\r\nu32 link_width_cntl;\r\nif (rdev->flags & RADEON_IS_IGP)\r\nreturn 0;\r\nif (!(rdev->flags & RADEON_IS_PCIE))\r\nreturn 0;\r\nlink_width_cntl = RREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\r\nswitch ((link_width_cntl & RADEON_PCIE_LC_LINK_WIDTH_RD_MASK) >> RADEON_PCIE_LC_LINK_WIDTH_RD_SHIFT) {\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X0:\r\nreturn 0;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X1:\r\nreturn 1;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X2:\r\nreturn 2;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X4:\r\nreturn 4;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X8:\r\nreturn 8;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X16:\r\ndefault:\r\nreturn 16;\r\n}\r\n}\r\nstatic int rv370_debugfs_pcie_gart_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t tmp;\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\r\nseq_printf(m, "PCIE_TX_GART_CNTL 0x%08x\n", tmp);\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_BASE);\r\nseq_printf(m, "PCIE_TX_GART_BASE 0x%08x\n", tmp);\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_START_LO);\r\nseq_printf(m, "PCIE_TX_GART_START_LO 0x%08x\n", tmp);\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_START_HI);\r\nseq_printf(m, "PCIE_TX_GART_START_HI 0x%08x\n", tmp);\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_END_LO);\r\nseq_printf(m, "PCIE_TX_GART_END_LO 0x%08x\n", tmp);\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_END_HI);\r\nseq_printf(m, "PCIE_TX_GART_END_HI 0x%08x\n", tmp);\r\ntmp = RREG32_PCIE(RADEON_PCIE_TX_GART_ERROR);\r\nseq_printf(m, "PCIE_TX_GART_ERROR 0x%08x\n", tmp);\r\nreturn 0;\r\n}\r\nstatic int rv370_debugfs_pcie_gart_info_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, rv370_pcie_gart_info_list, 1);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int r300_packet0_check(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt,\r\nunsigned idx, unsigned reg)\r\n{\r\nstruct radeon_cs_reloc *reloc;\r\nstruct r100_cs_track *track;\r\nvolatile uint32_t *ib;\r\nuint32_t tmp, tile_flags = 0;\r\nunsigned i;\r\nint r;\r\nu32 idx_value;\r\nib = p->ib.ptr;\r\ntrack = (struct r100_cs_track *)p->track;\r\nidx_value = radeon_get_ib_value(p, idx);\r\nswitch(reg) {\r\ncase AVIVO_D1MODE_VLINE_START_END:\r\ncase RADEON_CRTC_GUI_TRIG_VLINE:\r\nr = r100_cs_packet_parse_vline(p);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\nbreak;\r\ncase RADEON_DST_PITCH_OFFSET:\r\ncase RADEON_SRC_PITCH_OFFSET:\r\nr = r100_reloc_pitch_offset(p, pkt, idx, reg);\r\nif (r)\r\nreturn r;\r\nbreak;\r\ncase R300_RB3D_COLOROFFSET0:\r\ncase R300_RB3D_COLOROFFSET1:\r\ncase R300_RB3D_COLOROFFSET2:\r\ncase R300_RB3D_COLOROFFSET3:\r\ni = (reg - R300_RB3D_COLOROFFSET0) >> 2;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\ntrack->cb[i].robj = reloc->robj;\r\ntrack->cb[i].offset = idx_value;\r\ntrack->cb_dirty = true;\r\nib[idx] = idx_value + ((u32)reloc->lobj.gpu_offset);\r\nbreak;\r\ncase R300_ZB_DEPTHOFFSET:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\ntrack->zb.robj = reloc->robj;\r\ntrack->zb.offset = idx_value;\r\ntrack->zb_dirty = true;\r\nib[idx] = idx_value + ((u32)reloc->lobj.gpu_offset);\r\nbreak;\r\ncase R300_TX_OFFSET_0:\r\ncase R300_TX_OFFSET_0+4:\r\ncase R300_TX_OFFSET_0+8:\r\ncase R300_TX_OFFSET_0+12:\r\ncase R300_TX_OFFSET_0+16:\r\ncase R300_TX_OFFSET_0+20:\r\ncase R300_TX_OFFSET_0+24:\r\ncase R300_TX_OFFSET_0+28:\r\ncase R300_TX_OFFSET_0+32:\r\ncase R300_TX_OFFSET_0+36:\r\ncase R300_TX_OFFSET_0+40:\r\ncase R300_TX_OFFSET_0+44:\r\ncase R300_TX_OFFSET_0+48:\r\ncase R300_TX_OFFSET_0+52:\r\ncase R300_TX_OFFSET_0+56:\r\ncase R300_TX_OFFSET_0+60:\r\ni = (reg - R300_TX_OFFSET_0) >> 2;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\nif (p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS) {\r\nib[idx] = (idx_value & 31) |\r\n((idx_value & ~31) + (u32)reloc->lobj.gpu_offset);\r\n} else {\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MACRO)\r\ntile_flags |= R300_TXO_MACRO_TILE;\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MICRO)\r\ntile_flags |= R300_TXO_MICRO_TILE;\r\nelse if (reloc->lobj.tiling_flags & RADEON_TILING_MICRO_SQUARE)\r\ntile_flags |= R300_TXO_MICRO_TILE_SQUARE;\r\ntmp = idx_value + ((u32)reloc->lobj.gpu_offset);\r\ntmp |= tile_flags;\r\nib[idx] = tmp;\r\n}\r\ntrack->textures[i].robj = reloc->robj;\r\ntrack->tex_dirty = true;\r\nbreak;\r\ncase 0x2084:\r\ntrack->vap_vf_cntl = idx_value;\r\nbreak;\r\ncase 0x20B4:\r\ntrack->vtx_size = idx_value & 0x7F;\r\nbreak;\r\ncase 0x2134:\r\ntrack->max_indx = idx_value & 0x00FFFFFFUL;\r\nbreak;\r\ncase 0x2088:\r\nif (p->rdev->family < CHIP_RV515)\r\ngoto fail;\r\ntrack->vap_alt_nverts = idx_value & 0xFFFFFF;\r\nbreak;\r\ncase 0x43E4:\r\ntrack->maxy = ((idx_value >> 13) & 0x1FFF) + 1;\r\nif (p->rdev->family < CHIP_RV515) {\r\ntrack->maxy -= 1440;\r\n}\r\ntrack->cb_dirty = true;\r\ntrack->zb_dirty = true;\r\nbreak;\r\ncase 0x4E00:\r\nif ((idx_value & (1 << 10)) &&\r\np->rdev->cmask_filp != p->filp) {\r\nDRM_ERROR("Invalid RB3D_CCTL: Cannot enable CMASK.\n");\r\nreturn -EINVAL;\r\n}\r\ntrack->num_cb = ((idx_value >> 5) & 0x3) + 1;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase 0x4E38:\r\ncase 0x4E3C:\r\ncase 0x4E40:\r\ncase 0x4E44:\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MACRO)\r\ntile_flags |= R300_COLOR_TILE_ENABLE;\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MICRO)\r\ntile_flags |= R300_COLOR_MICROTILE_ENABLE;\r\nelse if (reloc->lobj.tiling_flags & RADEON_TILING_MICRO_SQUARE)\r\ntile_flags |= R300_COLOR_MICROTILE_SQUARE_ENABLE;\r\ntmp = idx_value & ~(0x7 << 16);\r\ntmp |= tile_flags;\r\nib[idx] = tmp;\r\n}\r\ni = (reg - 0x4E38) >> 2;\r\ntrack->cb[i].pitch = idx_value & 0x3FFE;\r\nswitch (((idx_value >> 21) & 0xF)) {\r\ncase 9:\r\ncase 11:\r\ncase 12:\r\ntrack->cb[i].cpp = 1;\r\nbreak;\r\ncase 3:\r\ncase 4:\r\ncase 13:\r\ncase 15:\r\ntrack->cb[i].cpp = 2;\r\nbreak;\r\ncase 5:\r\nif (p->rdev->family < CHIP_RV515) {\r\nDRM_ERROR("Invalid color buffer format (%d)!\n",\r\n((idx_value >> 21) & 0xF));\r\nreturn -EINVAL;\r\n}\r\ncase 6:\r\ntrack->cb[i].cpp = 4;\r\nbreak;\r\ncase 10:\r\ntrack->cb[i].cpp = 8;\r\nbreak;\r\ncase 7:\r\ntrack->cb[i].cpp = 16;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid color buffer format (%d) !\n",\r\n((idx_value >> 21) & 0xF));\r\nreturn -EINVAL;\r\n}\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase 0x4F00:\r\nif (idx_value & 2) {\r\ntrack->z_enabled = true;\r\n} else {\r\ntrack->z_enabled = false;\r\n}\r\ntrack->zb_dirty = true;\r\nbreak;\r\ncase 0x4F10:\r\nswitch ((idx_value & 0xF)) {\r\ncase 0:\r\ncase 1:\r\ntrack->zb.cpp = 2;\r\nbreak;\r\ncase 2:\r\ntrack->zb.cpp = 4;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid z buffer format (%d) !\n",\r\n(idx_value & 0xF));\r\nreturn -EINVAL;\r\n}\r\ntrack->zb_dirty = true;\r\nbreak;\r\ncase 0x4F24:\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MACRO)\r\ntile_flags |= R300_DEPTHMACROTILE_ENABLE;\r\nif (reloc->lobj.tiling_flags & RADEON_TILING_MICRO)\r\ntile_flags |= R300_DEPTHMICROTILE_TILED;\r\nelse if (reloc->lobj.tiling_flags & RADEON_TILING_MICRO_SQUARE)\r\ntile_flags |= R300_DEPTHMICROTILE_TILED_SQUARE;\r\ntmp = idx_value & ~(0x7 << 16);\r\ntmp |= tile_flags;\r\nib[idx] = tmp;\r\n}\r\ntrack->zb.pitch = idx_value & 0x3FFC;\r\ntrack->zb_dirty = true;\r\nbreak;\r\ncase 0x4104:\r\nfor (i = 0; i < 16; i++) {\r\nbool enabled;\r\nenabled = !!(idx_value & (1 << i));\r\ntrack->textures[i].enabled = enabled;\r\n}\r\ntrack->tex_dirty = true;\r\nbreak;\r\ncase 0x44C0:\r\ncase 0x44C4:\r\ncase 0x44C8:\r\ncase 0x44CC:\r\ncase 0x44D0:\r\ncase 0x44D4:\r\ncase 0x44D8:\r\ncase 0x44DC:\r\ncase 0x44E0:\r\ncase 0x44E4:\r\ncase 0x44E8:\r\ncase 0x44EC:\r\ncase 0x44F0:\r\ncase 0x44F4:\r\ncase 0x44F8:\r\ncase 0x44FC:\r\ni = (reg - 0x44C0) >> 2;\r\ntmp = (idx_value >> 25) & 0x3;\r\ntrack->textures[i].tex_coord_type = tmp;\r\nswitch ((idx_value & 0x1F)) {\r\ncase R300_TX_FORMAT_X8:\r\ncase R300_TX_FORMAT_Y4X4:\r\ncase R300_TX_FORMAT_Z3Y3X2:\r\ntrack->textures[i].cpp = 1;\r\ntrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\r\nbreak;\r\ncase R300_TX_FORMAT_X16:\r\ncase R300_TX_FORMAT_FL_I16:\r\ncase R300_TX_FORMAT_Y8X8:\r\ncase R300_TX_FORMAT_Z5Y6X5:\r\ncase R300_TX_FORMAT_Z6Y5X5:\r\ncase R300_TX_FORMAT_W4Z4Y4X4:\r\ncase R300_TX_FORMAT_W1Z5Y5X5:\r\ncase R300_TX_FORMAT_D3DMFT_CxV8U8:\r\ncase R300_TX_FORMAT_B8G8_B8G8:\r\ncase R300_TX_FORMAT_G8R8_G8B8:\r\ntrack->textures[i].cpp = 2;\r\ntrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\r\nbreak;\r\ncase R300_TX_FORMAT_Y16X16:\r\ncase R300_TX_FORMAT_FL_I16A16:\r\ncase R300_TX_FORMAT_Z11Y11X10:\r\ncase R300_TX_FORMAT_Z10Y11X11:\r\ncase R300_TX_FORMAT_W8Z8Y8X8:\r\ncase R300_TX_FORMAT_W2Z10Y10X10:\r\ncase 0x17:\r\ncase R300_TX_FORMAT_FL_I32:\r\ncase 0x1e:\r\ntrack->textures[i].cpp = 4;\r\ntrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\r\nbreak;\r\ncase R300_TX_FORMAT_W16Z16Y16X16:\r\ncase R300_TX_FORMAT_FL_R16G16B16A16:\r\ncase R300_TX_FORMAT_FL_I32A32:\r\ntrack->textures[i].cpp = 8;\r\ntrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\r\nbreak;\r\ncase R300_TX_FORMAT_FL_R32G32B32A32:\r\ntrack->textures[i].cpp = 16;\r\ntrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\r\nbreak;\r\ncase R300_TX_FORMAT_DXT1:\r\ntrack->textures[i].cpp = 1;\r\ntrack->textures[i].compress_format = R100_TRACK_COMP_DXT1;\r\nbreak;\r\ncase R300_TX_FORMAT_ATI2N:\r\nif (p->rdev->family < CHIP_R420) {\r\nDRM_ERROR("Invalid texture format %u\n",\r\n(idx_value & 0x1F));\r\nreturn -EINVAL;\r\n}\r\ncase R300_TX_FORMAT_DXT3:\r\ncase R300_TX_FORMAT_DXT5:\r\ntrack->textures[i].cpp = 1;\r\ntrack->textures[i].compress_format = R100_TRACK_COMP_DXT35;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid texture format %u\n",\r\n(idx_value & 0x1F));\r\nreturn -EINVAL;\r\n}\r\ntrack->tex_dirty = true;\r\nbreak;\r\ncase 0x4400:\r\ncase 0x4404:\r\ncase 0x4408:\r\ncase 0x440C:\r\ncase 0x4410:\r\ncase 0x4414:\r\ncase 0x4418:\r\ncase 0x441C:\r\ncase 0x4420:\r\ncase 0x4424:\r\ncase 0x4428:\r\ncase 0x442C:\r\ncase 0x4430:\r\ncase 0x4434:\r\ncase 0x4438:\r\ncase 0x443C:\r\ni = (reg - 0x4400) >> 2;\r\ntmp = idx_value & 0x7;\r\nif (tmp == 2 || tmp == 4 || tmp == 6) {\r\ntrack->textures[i].roundup_w = false;\r\n}\r\ntmp = (idx_value >> 3) & 0x7;\r\nif (tmp == 2 || tmp == 4 || tmp == 6) {\r\ntrack->textures[i].roundup_h = false;\r\n}\r\ntrack->tex_dirty = true;\r\nbreak;\r\ncase 0x4500:\r\ncase 0x4504:\r\ncase 0x4508:\r\ncase 0x450C:\r\ncase 0x4510:\r\ncase 0x4514:\r\ncase 0x4518:\r\ncase 0x451C:\r\ncase 0x4520:\r\ncase 0x4524:\r\ncase 0x4528:\r\ncase 0x452C:\r\ncase 0x4530:\r\ncase 0x4534:\r\ncase 0x4538:\r\ncase 0x453C:\r\ni = (reg - 0x4500) >> 2;\r\ntmp = idx_value & 0x3FFF;\r\ntrack->textures[i].pitch = tmp + 1;\r\nif (p->rdev->family >= CHIP_RV515) {\r\ntmp = ((idx_value >> 15) & 1) << 11;\r\ntrack->textures[i].width_11 = tmp;\r\ntmp = ((idx_value >> 16) & 1) << 11;\r\ntrack->textures[i].height_11 = tmp;\r\nif (idx_value & (1 << 14)) {\r\ntrack->textures[i].compress_format =\r\nR100_TRACK_COMP_DXT1;\r\n}\r\n} else if (idx_value & (1 << 14)) {\r\nDRM_ERROR("Forbidden bit TXFORMAT_MSB\n");\r\nreturn -EINVAL;\r\n}\r\ntrack->tex_dirty = true;\r\nbreak;\r\ncase 0x4480:\r\ncase 0x4484:\r\ncase 0x4488:\r\ncase 0x448C:\r\ncase 0x4490:\r\ncase 0x4494:\r\ncase 0x4498:\r\ncase 0x449C:\r\ncase 0x44A0:\r\ncase 0x44A4:\r\ncase 0x44A8:\r\ncase 0x44AC:\r\ncase 0x44B0:\r\ncase 0x44B4:\r\ncase 0x44B8:\r\ncase 0x44BC:\r\ni = (reg - 0x4480) >> 2;\r\ntmp = idx_value & 0x7FF;\r\ntrack->textures[i].width = tmp + 1;\r\ntmp = (idx_value >> 11) & 0x7FF;\r\ntrack->textures[i].height = tmp + 1;\r\ntmp = (idx_value >> 26) & 0xF;\r\ntrack->textures[i].num_levels = tmp;\r\ntmp = idx_value & (1 << 31);\r\ntrack->textures[i].use_pitch = !!tmp;\r\ntmp = (idx_value >> 22) & 0xF;\r\ntrack->textures[i].txdepth = tmp;\r\ntrack->tex_dirty = true;\r\nbreak;\r\ncase R300_ZB_ZPASS_ADDR:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\nib[idx] = idx_value + ((u32)reloc->lobj.gpu_offset);\r\nbreak;\r\ncase 0x4e0c:\r\ntrack->color_channel_mask = idx_value;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase 0x43a4:\r\nif (p->rdev->hyperz_filp != p->filp) {\r\nif (idx_value & 0x1)\r\nib[idx] = idx_value & ~1;\r\n}\r\nbreak;\r\ncase 0x4f1c:\r\ntrack->zb_cb_clear = !!(idx_value & (1 << 5));\r\ntrack->cb_dirty = true;\r\ntrack->zb_dirty = true;\r\nif (p->rdev->hyperz_filp != p->filp) {\r\nif (idx_value & (R300_HIZ_ENABLE |\r\nR300_RD_COMP_ENABLE |\r\nR300_WR_COMP_ENABLE |\r\nR300_FAST_FILL_ENABLE))\r\ngoto fail;\r\n}\r\nbreak;\r\ncase 0x4e04:\r\ntrack->blend_read_enable = !!(idx_value & (1 << 2));\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase R300_RB3D_AARESOLVE_OFFSET:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\ntrack->aa.robj = reloc->robj;\r\ntrack->aa.offset = idx_value;\r\ntrack->aa_dirty = true;\r\nib[idx] = idx_value + ((u32)reloc->lobj.gpu_offset);\r\nbreak;\r\ncase R300_RB3D_AARESOLVE_PITCH:\r\ntrack->aa.pitch = idx_value & 0x3FFE;\r\ntrack->aa_dirty = true;\r\nbreak;\r\ncase R300_RB3D_AARESOLVE_CTL:\r\ntrack->aaresolve = idx_value & 0x1;\r\ntrack->aa_dirty = true;\r\nbreak;\r\ncase 0x4f30:\r\ncase 0x4f34:\r\ncase 0x4f44:\r\ncase 0x4f54:\r\nif (idx_value && (p->rdev->hyperz_filp != p->filp))\r\ngoto fail;\r\nbreak;\r\ncase 0x4028:\r\nif (idx_value && (p->rdev->hyperz_filp != p->filp))\r\ngoto fail;\r\nif (p->rdev->family >= CHIP_RV350)\r\nbreak;\r\ngoto fail;\r\nbreak;\r\ncase 0x4be8:\r\nif (p->rdev->family == CHIP_RV530)\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nprintk(KERN_ERR "Forbidden register 0x%04X in cs at %d (val=%08x)\n",\r\nreg, idx, idx_value);\r\nreturn -EINVAL;\r\n}\r\nstatic int r300_packet3_check(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt)\r\n{\r\nstruct radeon_cs_reloc *reloc;\r\nstruct r100_cs_track *track;\r\nvolatile uint32_t *ib;\r\nunsigned idx;\r\nint r;\r\nib = p->ib.ptr;\r\nidx = pkt->idx + 1;\r\ntrack = (struct r100_cs_track *)p->track;\r\nswitch(pkt->opcode) {\r\ncase PACKET3_3D_LOAD_VBPNTR:\r\nr = r100_packet3_load_vbpntr(p, pkt, idx);\r\nif (r)\r\nreturn r;\r\nbreak;\r\ncase PACKET3_INDX_BUFFER:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("No reloc for packet3 %d\n", pkt->opcode);\r\nradeon_cs_dump_packet(p, pkt);\r\nreturn r;\r\n}\r\nib[idx+1] = radeon_get_ib_value(p, idx + 1) + ((u32)reloc->lobj.gpu_offset);\r\nr = r100_cs_track_check_pkt3_indx_buffer(p, pkt, reloc->robj);\r\nif (r) {\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_3D_DRAW_IMMD:\r\nif (((radeon_get_ib_value(p, idx + 1) >> 4) & 0x3) != 3) {\r\nDRM_ERROR("PRIM_WALK must be 3 for IMMD draw\n");\r\nreturn -EINVAL;\r\n}\r\ntrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\r\ntrack->immd_dwords = pkt->count - 1;\r\nr = r100_cs_track_check(p->rdev, track);\r\nif (r) {\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_3D_DRAW_IMMD_2:\r\nif (((radeon_get_ib_value(p, idx) >> 4) & 0x3) != 3) {\r\nDRM_ERROR("PRIM_WALK must be 3 for IMMD draw\n");\r\nreturn -EINVAL;\r\n}\r\ntrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\r\ntrack->immd_dwords = pkt->count;\r\nr = r100_cs_track_check(p->rdev, track);\r\nif (r) {\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_3D_DRAW_VBUF:\r\ntrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\r\nr = r100_cs_track_check(p->rdev, track);\r\nif (r) {\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_3D_DRAW_VBUF_2:\r\ntrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\r\nr = r100_cs_track_check(p->rdev, track);\r\nif (r) {\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_3D_DRAW_INDX:\r\ntrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\r\nr = r100_cs_track_check(p->rdev, track);\r\nif (r) {\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_3D_DRAW_INDX_2:\r\ntrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\r\nr = r100_cs_track_check(p->rdev, track);\r\nif (r) {\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_3D_CLEAR_HIZ:\r\ncase PACKET3_3D_CLEAR_ZMASK:\r\nif (p->rdev->hyperz_filp != p->filp)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PACKET3_3D_CLEAR_CMASK:\r\nif (p->rdev->cmask_filp != p->filp)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PACKET3_NOP:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Packet3 opcode %x not supported\n", pkt->opcode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint r300_cs_parse(struct radeon_cs_parser *p)\r\n{\r\nstruct radeon_cs_packet pkt;\r\nstruct r100_cs_track *track;\r\nint r;\r\ntrack = kzalloc(sizeof(*track), GFP_KERNEL);\r\nif (track == NULL)\r\nreturn -ENOMEM;\r\nr100_cs_track_clear(p->rdev, track);\r\np->track = track;\r\ndo {\r\nr = radeon_cs_packet_parse(p, &pkt, p->idx);\r\nif (r) {\r\nreturn r;\r\n}\r\np->idx += pkt.count + 2;\r\nswitch (pkt.type) {\r\ncase RADEON_PACKET_TYPE0:\r\nr = r100_cs_parse_packet0(p, &pkt,\r\np->rdev->config.r300.reg_safe_bm,\r\np->rdev->config.r300.reg_safe_bm_size,\r\n&r300_packet0_check);\r\nbreak;\r\ncase RADEON_PACKET_TYPE2:\r\nbreak;\r\ncase RADEON_PACKET_TYPE3:\r\nr = r300_packet3_check(p, &pkt);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown packet type %d !\n", pkt.type);\r\nreturn -EINVAL;\r\n}\r\nif (r) {\r\nreturn r;\r\n}\r\n} while (p->idx < p->chunks[p->chunk_ib_idx].length_dw);\r\nreturn 0;\r\n}\r\nvoid r300_set_reg_safe(struct radeon_device *rdev)\r\n{\r\nrdev->config.r300.reg_safe_bm = r300_reg_safe_bm;\r\nrdev->config.r300.reg_safe_bm_size = ARRAY_SIZE(r300_reg_safe_bm);\r\n}\r\nvoid r300_mc_program(struct radeon_device *rdev)\r\n{\r\nstruct r100_mc_save save;\r\nint r;\r\nr = r100_debugfs_mc_info_init(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "Failed to create r100_mc debugfs file.\n");\r\n}\r\nr100_mc_stop(rdev, &save);\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nWREG32(R_00014C_MC_AGP_LOCATION,\r\nS_00014C_MC_AGP_START(rdev->mc.gtt_start >> 16) |\r\nS_00014C_MC_AGP_TOP(rdev->mc.gtt_end >> 16));\r\nWREG32(R_000170_AGP_BASE, lower_32_bits(rdev->mc.agp_base));\r\nWREG32(R_00015C_AGP_BASE_2,\r\nupper_32_bits(rdev->mc.agp_base) & 0xff);\r\n} else {\r\nWREG32(R_00014C_MC_AGP_LOCATION, 0x0FFFFFFF);\r\nWREG32(R_000170_AGP_BASE, 0);\r\nWREG32(R_00015C_AGP_BASE_2, 0);\r\n}\r\nif (r300_mc_wait_for_idle(rdev))\r\nDRM_INFO("Failed to wait MC idle before programming MC.\n");\r\nWREG32(R_000148_MC_FB_LOCATION,\r\nS_000148_MC_FB_START(rdev->mc.vram_start >> 16) |\r\nS_000148_MC_FB_TOP(rdev->mc.vram_end >> 16));\r\nr100_mc_resume(rdev, &save);\r\n}\r\nvoid r300_clock_startup(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\nif (radeon_dynclks != -1 && radeon_dynclks)\r\nradeon_legacy_set_clock_gating(rdev, 1);\r\ntmp = RREG32_PLL(R_00000D_SCLK_CNTL);\r\ntmp |= S_00000D_FORCE_CP(1) | S_00000D_FORCE_VIP(1);\r\nif ((rdev->family == CHIP_RV350) || (rdev->family == CHIP_RV380))\r\ntmp |= S_00000D_FORCE_VAP(1);\r\nWREG32_PLL(R_00000D_SCLK_CNTL, tmp);\r\n}\r\nstatic int r300_startup(struct radeon_device *rdev)\r\n{\r\nint r;\r\nr100_set_common_regs(rdev);\r\nr300_mc_program(rdev);\r\nr300_clock_startup(rdev);\r\nr300_gpu_init(rdev);\r\nif (rdev->flags & RADEON_IS_PCIE) {\r\nr = rv370_pcie_gart_enable(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nif (rdev->family == CHIP_R300 ||\r\nrdev->family == CHIP_R350 ||\r\nrdev->family == CHIP_RV350)\r\nr100_enable_bm(rdev);\r\nif (rdev->flags & RADEON_IS_PCI) {\r\nr = r100_pci_gart_enable(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nr = radeon_wb_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing CP fences (%d).\n", r);\r\nreturn r;\r\n}\r\nif (!rdev->irq.installed) {\r\nr = radeon_irq_kms_init(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nr100_irq_set(rdev);\r\nrdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\r\nr = r100_cp_init(rdev, 1024 * 1024);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing CP (%d).\n", r);\r\nreturn r;\r\n}\r\nr = radeon_ib_pool_init(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "IB initialization failed (%d).\n", r);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint r300_resume(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (rdev->flags & RADEON_IS_PCIE)\r\nrv370_pcie_gart_disable(rdev);\r\nif (rdev->flags & RADEON_IS_PCI)\r\nr100_pci_gart_disable(rdev);\r\nr300_clock_startup(rdev);\r\nif (radeon_asic_reset(rdev)) {\r\ndev_warn(rdev->dev, "GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\n",\r\nRREG32(R_000E40_RBBM_STATUS),\r\nRREG32(R_0007C0_CP_STAT));\r\n}\r\nradeon_combios_asic_init(rdev->ddev);\r\nr300_clock_startup(rdev);\r\nradeon_surface_init(rdev);\r\nrdev->accel_working = true;\r\nr = r300_startup(rdev);\r\nif (r) {\r\nrdev->accel_working = false;\r\n}\r\nreturn r;\r\n}\r\nint r300_suspend(struct radeon_device *rdev)\r\n{\r\nr100_cp_disable(rdev);\r\nradeon_wb_disable(rdev);\r\nr100_irq_disable(rdev);\r\nif (rdev->flags & RADEON_IS_PCIE)\r\nrv370_pcie_gart_disable(rdev);\r\nif (rdev->flags & RADEON_IS_PCI)\r\nr100_pci_gart_disable(rdev);\r\nreturn 0;\r\n}\r\nvoid r300_fini(struct radeon_device *rdev)\r\n{\r\nr100_cp_fini(rdev);\r\nradeon_wb_fini(rdev);\r\nradeon_ib_pool_fini(rdev);\r\nradeon_gem_fini(rdev);\r\nif (rdev->flags & RADEON_IS_PCIE)\r\nrv370_pcie_gart_fini(rdev);\r\nif (rdev->flags & RADEON_IS_PCI)\r\nr100_pci_gart_fini(rdev);\r\nradeon_agp_fini(rdev);\r\nradeon_irq_kms_fini(rdev);\r\nradeon_fence_driver_fini(rdev);\r\nradeon_bo_fini(rdev);\r\nradeon_atombios_fini(rdev);\r\nkfree(rdev->bios);\r\nrdev->bios = NULL;\r\n}\r\nint r300_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nr100_vga_render_disable(rdev);\r\nradeon_scratch_init(rdev);\r\nradeon_surface_init(rdev);\r\nr100_restore_sanity(rdev);\r\nif (!radeon_get_bios(rdev)) {\r\nif (ASIC_IS_AVIVO(rdev))\r\nreturn -EINVAL;\r\n}\r\nif (rdev->is_atom_bios) {\r\ndev_err(rdev->dev, "Expecting combios for RS400/RS480 GPU\n");\r\nreturn -EINVAL;\r\n} else {\r\nr = radeon_combios_init(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nif (radeon_asic_reset(rdev)) {\r\ndev_warn(rdev->dev,\r\n"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\n",\r\nRREG32(R_000E40_RBBM_STATUS),\r\nRREG32(R_0007C0_CP_STAT));\r\n}\r\nif (radeon_boot_test_post_card(rdev) == false)\r\nreturn -EINVAL;\r\nr300_errata(rdev);\r\nradeon_get_clock_info(rdev->ddev);\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nr = radeon_agp_init(rdev);\r\nif (r) {\r\nradeon_agp_disable(rdev);\r\n}\r\n}\r\nr300_mc_init(rdev);\r\nr = radeon_fence_driver_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_bo_init(rdev);\r\nif (r)\r\nreturn r;\r\nif (rdev->flags & RADEON_IS_PCIE) {\r\nr = rv370_pcie_gart_init(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nif (rdev->flags & RADEON_IS_PCI) {\r\nr = r100_pci_gart_init(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nr300_set_reg_safe(rdev);\r\nrdev->accel_working = true;\r\nr = r300_startup(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "Disabling GPU acceleration\n");\r\nr100_cp_fini(rdev);\r\nradeon_wb_fini(rdev);\r\nradeon_ib_pool_fini(rdev);\r\nradeon_irq_kms_fini(rdev);\r\nif (rdev->flags & RADEON_IS_PCIE)\r\nrv370_pcie_gart_fini(rdev);\r\nif (rdev->flags & RADEON_IS_PCI)\r\nr100_pci_gart_fini(rdev);\r\nradeon_agp_fini(rdev);\r\nrdev->accel_working = false;\r\n}\r\nreturn 0;\r\n}
