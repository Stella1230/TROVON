void iwl_connection_init_rx_config(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nmemset(&ctx->staging, 0, sizeof(ctx->staging));\r\nif (!ctx->vif) {\r\nctx->staging.dev_type = ctx->unused_devtype;\r\n} else\r\nswitch (ctx->vif->type) {\r\ncase NL80211_IFTYPE_AP:\r\nctx->staging.dev_type = ctx->ap_devtype;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nctx->staging.dev_type = ctx->station_devtype;\r\nctx->staging.filter_flags = RXON_FILTER_ACCEPT_GRP_MSK;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nctx->staging.dev_type = ctx->ibss_devtype;\r\nctx->staging.flags = RXON_FLG_SHORT_PREAMBLE_MSK;\r\nctx->staging.filter_flags = RXON_FILTER_BCON_AWARE_MSK |\r\nRXON_FILTER_ACCEPT_GRP_MSK;\r\nbreak;\r\ncase NL80211_IFTYPE_MONITOR:\r\nctx->staging.dev_type = RXON_DEV_TYPE_SNIFFER;\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv, "Unsupported interface type %d\n",\r\nctx->vif->type);\r\nbreak;\r\n}\r\n#if 0\r\nif (!hw_to_local(priv->hw)->short_preamble)\r\nctx->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\r\nelse\r\nctx->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\r\n#endif\r\nctx->staging.channel =\r\ncpu_to_le16(priv->hw->conf.chandef.chan->hw_value);\r\npriv->band = priv->hw->conf.chandef.chan->band;\r\niwl_set_flags_for_band(priv, ctx, priv->band, ctx->vif);\r\nctx->staging.flags &= ~(RXON_FLG_CHANNEL_MODE_MIXED |\r\nRXON_FLG_CHANNEL_MODE_PURE_40);\r\nif (ctx->vif)\r\nmemcpy(ctx->staging.node_addr, ctx->vif->addr, ETH_ALEN);\r\nctx->staging.ofdm_ht_single_stream_basic_rates = 0xff;\r\nctx->staging.ofdm_ht_dual_stream_basic_rates = 0xff;\r\nctx->staging.ofdm_ht_triple_stream_basic_rates = 0xff;\r\n}\r\nstatic int iwlagn_disable_bss(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct iwl_rxon_cmd *send)\r\n{\r\n__le32 old_filter = send->filter_flags;\r\nint ret;\r\nsend->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd,\r\nCMD_SYNC, sizeof(*send), send);\r\nsend->filter_flags = old_filter;\r\nif (ret)\r\nIWL_DEBUG_QUIET_RFKILL(priv,\r\n"Error clearing ASSOC_MSK on BSS (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int iwlagn_disable_pan(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct iwl_rxon_cmd *send)\r\n{\r\nstruct iwl_notification_wait disable_wait;\r\n__le32 old_filter = send->filter_flags;\r\nu8 old_dev_type = send->dev_type;\r\nint ret;\r\nstatic const u8 deactivate_cmd[] = {\r\nREPLY_WIPAN_DEACTIVATION_COMPLETE\r\n};\r\niwl_init_notification_wait(&priv->notif_wait, &disable_wait,\r\ndeactivate_cmd, ARRAY_SIZE(deactivate_cmd),\r\nNULL, NULL);\r\nsend->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nsend->dev_type = RXON_DEV_TYPE_P2P;\r\nret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd,\r\nCMD_SYNC, sizeof(*send), send);\r\nsend->filter_flags = old_filter;\r\nsend->dev_type = old_dev_type;\r\nif (ret) {\r\nIWL_ERR(priv, "Error disabling PAN (%d)\n", ret);\r\niwl_remove_notification(&priv->notif_wait, &disable_wait);\r\n} else {\r\nret = iwl_wait_notification(&priv->notif_wait,\r\n&disable_wait, HZ);\r\nif (ret)\r\nIWL_ERR(priv, "Timed out waiting for PAN disable\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int iwlagn_disconn_pan(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct iwl_rxon_cmd *send)\r\n{\r\n__le32 old_filter = send->filter_flags;\r\nint ret;\r\nsend->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd, CMD_SYNC,\r\nsizeof(*send), send);\r\nsend->filter_flags = old_filter;\r\nreturn ret;\r\n}\r\nstatic void iwlagn_update_qos(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nint ret;\r\nif (!ctx->is_active)\r\nreturn;\r\nctx->qos_data.def_qos_parm.qos_flags = 0;\r\nif (ctx->qos_data.qos_active)\r\nctx->qos_data.def_qos_parm.qos_flags |=\r\nQOS_PARAM_FLG_UPDATE_EDCA_MSK;\r\nif (ctx->ht.enabled)\r\nctx->qos_data.def_qos_parm.qos_flags |= QOS_PARAM_FLG_TGN_MSK;\r\nIWL_DEBUG_INFO(priv, "send QoS cmd with Qos active=%d FLAGS=0x%X\n",\r\nctx->qos_data.qos_active,\r\nctx->qos_data.def_qos_parm.qos_flags);\r\nret = iwl_dvm_send_cmd_pdu(priv, ctx->qos_cmd, CMD_SYNC,\r\nsizeof(struct iwl_qosparam_cmd),\r\n&ctx->qos_data.def_qos_parm);\r\nif (ret)\r\nIWL_DEBUG_QUIET_RFKILL(priv, "Failed to update QoS\n");\r\n}\r\nstatic int iwlagn_update_beacon(struct iwl_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nlockdep_assert_held(&priv->mutex);\r\ndev_kfree_skb(priv->beacon_skb);\r\npriv->beacon_skb = ieee80211_beacon_get(priv->hw, vif);\r\nif (!priv->beacon_skb)\r\nreturn -ENOMEM;\r\nreturn iwlagn_send_beacon_cmd(priv);\r\n}\r\nstatic int iwlagn_send_rxon_assoc(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nint ret = 0;\r\nstruct iwl_rxon_assoc_cmd rxon_assoc;\r\nconst struct iwl_rxon_cmd *rxon1 = &ctx->staging;\r\nconst struct iwl_rxon_cmd *rxon2 = &ctx->active;\r\nif ((rxon1->flags == rxon2->flags) &&\r\n(rxon1->filter_flags == rxon2->filter_flags) &&\r\n(rxon1->cck_basic_rates == rxon2->cck_basic_rates) &&\r\n(rxon1->ofdm_ht_single_stream_basic_rates ==\r\nrxon2->ofdm_ht_single_stream_basic_rates) &&\r\n(rxon1->ofdm_ht_dual_stream_basic_rates ==\r\nrxon2->ofdm_ht_dual_stream_basic_rates) &&\r\n(rxon1->ofdm_ht_triple_stream_basic_rates ==\r\nrxon2->ofdm_ht_triple_stream_basic_rates) &&\r\n(rxon1->acquisition_data == rxon2->acquisition_data) &&\r\n(rxon1->rx_chain == rxon2->rx_chain) &&\r\n(rxon1->ofdm_basic_rates == rxon2->ofdm_basic_rates)) {\r\nIWL_DEBUG_INFO(priv, "Using current RXON_ASSOC. Not resending.\n");\r\nreturn 0;\r\n}\r\nrxon_assoc.flags = ctx->staging.flags;\r\nrxon_assoc.filter_flags = ctx->staging.filter_flags;\r\nrxon_assoc.ofdm_basic_rates = ctx->staging.ofdm_basic_rates;\r\nrxon_assoc.cck_basic_rates = ctx->staging.cck_basic_rates;\r\nrxon_assoc.reserved1 = 0;\r\nrxon_assoc.reserved2 = 0;\r\nrxon_assoc.reserved3 = 0;\r\nrxon_assoc.ofdm_ht_single_stream_basic_rates =\r\nctx->staging.ofdm_ht_single_stream_basic_rates;\r\nrxon_assoc.ofdm_ht_dual_stream_basic_rates =\r\nctx->staging.ofdm_ht_dual_stream_basic_rates;\r\nrxon_assoc.rx_chain_select_flags = ctx->staging.rx_chain;\r\nrxon_assoc.ofdm_ht_triple_stream_basic_rates =\r\nctx->staging.ofdm_ht_triple_stream_basic_rates;\r\nrxon_assoc.acquisition_data = ctx->staging.acquisition_data;\r\nret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_assoc_cmd,\r\nCMD_ASYNC, sizeof(rxon_assoc), &rxon_assoc);\r\nreturn ret;\r\n}\r\nstatic u16 iwl_adjust_beacon_interval(u16 beacon_val, u16 max_beacon_val)\r\n{\r\nu16 new_val;\r\nu16 beacon_factor;\r\nif (!beacon_val)\r\nreturn DEFAULT_BEACON_INTERVAL;\r\nbeacon_factor = (beacon_val + max_beacon_val) / max_beacon_val;\r\nnew_val = beacon_val / beacon_factor;\r\nif (!new_val)\r\nnew_val = max_beacon_val;\r\nreturn new_val;\r\n}\r\nstatic int iwl_send_rxon_timing(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nu64 tsf;\r\ns32 interval_tm, rem;\r\nstruct ieee80211_conf *conf = NULL;\r\nu16 beacon_int;\r\nstruct ieee80211_vif *vif = ctx->vif;\r\nconf = &priv->hw->conf;\r\nlockdep_assert_held(&priv->mutex);\r\nmemset(&ctx->timing, 0, sizeof(struct iwl_rxon_time_cmd));\r\nctx->timing.timestamp = cpu_to_le64(priv->timestamp);\r\nctx->timing.listen_interval = cpu_to_le16(conf->listen_interval);\r\nbeacon_int = vif ? vif->bss_conf.beacon_int : 0;\r\nctx->timing.atim_window = 0;\r\nif (ctx->ctxid == IWL_RXON_CTX_PAN &&\r\n(!ctx->vif || ctx->vif->type != NL80211_IFTYPE_STATION) &&\r\niwl_is_associated(priv, IWL_RXON_CTX_BSS) &&\r\npriv->contexts[IWL_RXON_CTX_BSS].vif &&\r\npriv->contexts[IWL_RXON_CTX_BSS].vif->bss_conf.beacon_int) {\r\nctx->timing.beacon_interval =\r\npriv->contexts[IWL_RXON_CTX_BSS].timing.beacon_interval;\r\nbeacon_int = le16_to_cpu(ctx->timing.beacon_interval);\r\n} else if (ctx->ctxid == IWL_RXON_CTX_BSS &&\r\niwl_is_associated(priv, IWL_RXON_CTX_PAN) &&\r\npriv->contexts[IWL_RXON_CTX_PAN].vif &&\r\npriv->contexts[IWL_RXON_CTX_PAN].vif->bss_conf.beacon_int &&\r\n(!iwl_is_associated_ctx(ctx) || !ctx->vif ||\r\n!ctx->vif->bss_conf.beacon_int)) {\r\nctx->timing.beacon_interval =\r\npriv->contexts[IWL_RXON_CTX_PAN].timing.beacon_interval;\r\nbeacon_int = le16_to_cpu(ctx->timing.beacon_interval);\r\n} else {\r\nbeacon_int = iwl_adjust_beacon_interval(beacon_int,\r\nIWL_MAX_UCODE_BEACON_INTERVAL * TIME_UNIT);\r\nctx->timing.beacon_interval = cpu_to_le16(beacon_int);\r\n}\r\nctx->beacon_int = beacon_int;\r\ntsf = priv->timestamp;\r\ninterval_tm = beacon_int * TIME_UNIT;\r\nrem = do_div(tsf, interval_tm);\r\nctx->timing.beacon_init_val = cpu_to_le32(interval_tm - rem);\r\nctx->timing.dtim_period = vif ? (vif->bss_conf.dtim_period ?: 1) : 1;\r\nIWL_DEBUG_ASSOC(priv,\r\n"beacon interval %d beacon timer %d beacon tim %d\n",\r\nle16_to_cpu(ctx->timing.beacon_interval),\r\nle32_to_cpu(ctx->timing.beacon_init_val),\r\nle16_to_cpu(ctx->timing.atim_window));\r\nreturn iwl_dvm_send_cmd_pdu(priv, ctx->rxon_timing_cmd,\r\nCMD_SYNC, sizeof(ctx->timing), &ctx->timing);\r\n}\r\nstatic int iwlagn_rxon_disconn(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nint ret;\r\nstruct iwl_rxon_cmd *active = (void *)&ctx->active;\r\nif (ctx->ctxid == IWL_RXON_CTX_BSS) {\r\nret = iwlagn_disable_bss(priv, ctx, &ctx->staging);\r\n} else {\r\nret = iwlagn_disable_pan(priv, ctx, &ctx->staging);\r\nif (ret)\r\nreturn ret;\r\nif (ctx->vif) {\r\nret = iwl_send_rxon_timing(priv, ctx);\r\nif (ret) {\r\nIWL_ERR(priv, "Failed to send timing (%d)!\n", ret);\r\nreturn ret;\r\n}\r\nret = iwlagn_disconn_pan(priv, ctx, &ctx->staging);\r\n}\r\n}\r\nif (ret)\r\nreturn ret;\r\niwl_clear_ucode_stations(priv, ctx);\r\niwl_update_bcast_station(priv, ctx);\r\niwl_restore_stations(priv, ctx);\r\nret = iwl_restore_default_wep_keys(priv, ctx);\r\nif (ret) {\r\nIWL_ERR(priv, "Failed to restore WEP keys (%d)\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(active, &ctx->staging, sizeof(*active));\r\nreturn 0;\r\n}\r\nstatic int iwl_set_tx_power(struct iwl_priv *priv, s8 tx_power, bool force)\r\n{\r\nint ret;\r\ns8 prev_tx_power;\r\nbool defer;\r\nstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\r\nif (priv->calib_disabled & IWL_TX_POWER_CALIB_DISABLED)\r\nreturn 0;\r\nlockdep_assert_held(&priv->mutex);\r\nif (priv->tx_power_user_lmt == tx_power && !force)\r\nreturn 0;\r\nif (tx_power < IWLAGN_TX_POWER_TARGET_POWER_MIN) {\r\nIWL_WARN(priv,\r\n"Requested user TXPOWER %d below lower limit %d.\n",\r\ntx_power,\r\nIWLAGN_TX_POWER_TARGET_POWER_MIN);\r\nreturn -EINVAL;\r\n}\r\nif (tx_power > DIV_ROUND_UP(priv->nvm_data->max_tx_pwr_half_dbm, 2)) {\r\nIWL_WARN(priv,\r\n"Requested user TXPOWER %d above upper limit %d.\n",\r\ntx_power, priv->nvm_data->max_tx_pwr_half_dbm);\r\nreturn -EINVAL;\r\n}\r\nif (!iwl_is_ready_rf(priv))\r\nreturn -EIO;\r\npriv->tx_power_next = tx_power;\r\ndefer = test_bit(STATUS_SCANNING, &priv->status) ||\r\nmemcmp(&ctx->active, &ctx->staging, sizeof(ctx->staging));\r\nif (defer && !force) {\r\nIWL_DEBUG_INFO(priv, "Deferring tx power set\n");\r\nreturn 0;\r\n}\r\nprev_tx_power = priv->tx_power_user_lmt;\r\npriv->tx_power_user_lmt = tx_power;\r\nret = iwlagn_send_tx_power(priv);\r\nif (ret) {\r\npriv->tx_power_user_lmt = prev_tx_power;\r\npriv->tx_power_next = prev_tx_power;\r\n}\r\nreturn ret;\r\n}\r\nstatic int iwlagn_rxon_connect(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nint ret;\r\nstruct iwl_rxon_cmd *active = (void *)&ctx->active;\r\nif (ctx->ctxid == IWL_RXON_CTX_BSS) {\r\nret = iwl_send_rxon_timing(priv, ctx);\r\nif (ret) {\r\nIWL_ERR(priv, "Failed to send timing (%d)!\n", ret);\r\nreturn ret;\r\n}\r\n}\r\niwlagn_update_qos(priv, ctx);\r\nif (ctx->vif && (ctx->vif->type == NL80211_IFTYPE_AP)) {\r\nret = iwlagn_update_beacon(priv, ctx->vif);\r\nif (ret) {\r\nIWL_ERR(priv,\r\n"Error sending required beacon (%d)!\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\npriv->start_calib = 0;\r\nret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd, CMD_SYNC,\r\nsizeof(struct iwl_rxon_cmd), &ctx->staging);\r\nif (ret) {\r\nIWL_ERR(priv, "Error setting new RXON (%d)\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(active, &ctx->staging, sizeof(*active));\r\nif (ctx->vif && (ctx->vif->type == NL80211_IFTYPE_ADHOC))\r\nif (iwlagn_update_beacon(priv, ctx->vif))\r\nIWL_ERR(priv, "Error sending IBSS beacon\n");\r\niwl_init_sensitivity(priv);\r\nret = iwl_set_tx_power(priv, priv->tx_power_next, true);\r\nif (ret) {\r\nIWL_ERR(priv, "Error sending TX power (%d)\n", ret);\r\nreturn ret;\r\n}\r\nif (ctx->vif && ctx->vif->type == NL80211_IFTYPE_STATION &&\r\npriv->cfg->ht_params && priv->cfg->ht_params->smps_mode)\r\nieee80211_request_smps(ctx->vif,\r\npriv->cfg->ht_params->smps_mode);\r\nreturn 0;\r\n}\r\nint iwlagn_set_pan_params(struct iwl_priv *priv)\r\n{\r\nstruct iwl_wipan_params_cmd cmd;\r\nstruct iwl_rxon_context *ctx_bss, *ctx_pan;\r\nint slot0 = 300, slot1 = 0;\r\nint ret;\r\nif (priv->valid_contexts == BIT(IWL_RXON_CTX_BSS))\r\nreturn 0;\r\nBUILD_BUG_ON(NUM_IWL_RXON_CTX != 2);\r\nlockdep_assert_held(&priv->mutex);\r\nctx_bss = &priv->contexts[IWL_RXON_CTX_BSS];\r\nctx_pan = &priv->contexts[IWL_RXON_CTX_PAN];\r\nif (!ctx_pan->is_active)\r\nreturn 0;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.num_slots = 2;\r\ncmd.slots[0].type = 0;\r\ncmd.slots[1].type = 1;\r\nif (priv->hw_roc_setup) {\r\nslot1 = IWL_MIN_SLOT_TIME;\r\nslot0 = 3000;\r\n} else if (ctx_bss->vif && ctx_pan->vif) {\r\nint bcnint = ctx_pan->beacon_int;\r\nint dtim = ctx_pan->vif->bss_conf.dtim_period ?: 1;\r\ncmd.flags |= cpu_to_le16(IWL_WIPAN_PARAMS_FLG_SLOTTED_MODE);\r\nif (ctx_pan->vif->type == NL80211_IFTYPE_AP &&\r\nbcnint &&\r\nbcnint != ctx_bss->beacon_int) {\r\nIWL_ERR(priv,\r\n"beacon intervals don't match (%d, %d)\n",\r\nctx_bss->beacon_int, ctx_pan->beacon_int);\r\n} else\r\nbcnint = max_t(int, bcnint,\r\nctx_bss->beacon_int);\r\nif (!bcnint)\r\nbcnint = DEFAULT_BEACON_INTERVAL;\r\nslot0 = bcnint / 2;\r\nslot1 = bcnint - slot0;\r\nif (test_bit(STATUS_SCAN_HW, &priv->status) ||\r\n(!ctx_bss->vif->bss_conf.idle &&\r\n!ctx_bss->vif->bss_conf.assoc)) {\r\nslot0 = dtim * bcnint * 3 - IWL_MIN_SLOT_TIME;\r\nslot1 = IWL_MIN_SLOT_TIME;\r\n} else if (!ctx_pan->vif->bss_conf.idle &&\r\n!ctx_pan->vif->bss_conf.assoc) {\r\nslot1 = dtim * bcnint * 3 - IWL_MIN_SLOT_TIME;\r\nslot0 = IWL_MIN_SLOT_TIME;\r\n}\r\n} else if (ctx_pan->vif) {\r\nslot0 = 0;\r\nslot1 = max_t(int, 1, ctx_pan->vif->bss_conf.dtim_period) *\r\nctx_pan->beacon_int;\r\nslot1 = max_t(int, DEFAULT_BEACON_INTERVAL, slot1);\r\nif (test_bit(STATUS_SCAN_HW, &priv->status)) {\r\nslot0 = slot1 * 3 - IWL_MIN_SLOT_TIME;\r\nslot1 = IWL_MIN_SLOT_TIME;\r\n}\r\n}\r\ncmd.slots[0].width = cpu_to_le16(slot0);\r\ncmd.slots[1].width = cpu_to_le16(slot1);\r\nret = iwl_dvm_send_cmd_pdu(priv, REPLY_WIPAN_PARAMS, CMD_SYNC,\r\nsizeof(cmd), &cmd);\r\nif (ret)\r\nIWL_ERR(priv, "Error setting PAN parameters (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic void _iwl_set_rxon_ht(struct iwl_priv *priv,\r\nstruct iwl_ht_config *ht_conf,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nstruct iwl_rxon_cmd *rxon = &ctx->staging;\r\nif (!ctx->ht.enabled) {\r\nrxon->flags &= ~(RXON_FLG_CHANNEL_MODE_MSK |\r\nRXON_FLG_CTRL_CHANNEL_LOC_HI_MSK |\r\nRXON_FLG_HT40_PROT_MSK |\r\nRXON_FLG_HT_PROT_MSK);\r\nreturn;\r\n}\r\nrxon->flags |= cpu_to_le32(ctx->ht.protection <<\r\nRXON_FLG_HT_OPERATING_MODE_POS);\r\nrxon->flags &= ~(RXON_FLG_CHANNEL_MODE_MSK |\r\nRXON_FLG_CTRL_CHANNEL_LOC_HI_MSK);\r\nif (iwl_is_ht40_tx_allowed(priv, ctx, NULL)) {\r\nif (ctx->ht.protection ==\r\nIEEE80211_HT_OP_MODE_PROTECTION_20MHZ) {\r\nrxon->flags |= RXON_FLG_CHANNEL_MODE_PURE_40;\r\nswitch (ctx->ht.extension_chan_offset) {\r\ncase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\r\nrxon->flags &=\r\n~RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\r\nbreak;\r\ncase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\r\nrxon->flags |=\r\nRXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\r\nbreak;\r\n}\r\n} else {\r\nswitch (ctx->ht.extension_chan_offset) {\r\ncase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\r\nrxon->flags &=\r\n~(RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK);\r\nrxon->flags |= RXON_FLG_CHANNEL_MODE_MIXED;\r\nbreak;\r\ncase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\r\nrxon->flags |= RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\r\nrxon->flags |= RXON_FLG_CHANNEL_MODE_MIXED;\r\nbreak;\r\ncase IEEE80211_HT_PARAM_CHA_SEC_NONE:\r\ndefault:\r\nIWL_ERR(priv,\r\n"invalid extension channel offset\n");\r\nbreak;\r\n}\r\n}\r\n} else {\r\nrxon->flags |= RXON_FLG_CHANNEL_MODE_LEGACY;\r\n}\r\niwlagn_set_rxon_chain(priv, ctx);\r\nIWL_DEBUG_ASSOC(priv, "rxon flags 0x%X operation mode :0x%X "\r\n"extension channel offset 0x%x\n",\r\nle32_to_cpu(rxon->flags), ctx->ht.protection,\r\nctx->ht.extension_chan_offset);\r\n}\r\nvoid iwl_set_rxon_ht(struct iwl_priv *priv, struct iwl_ht_config *ht_conf)\r\n{\r\nstruct iwl_rxon_context *ctx;\r\nfor_each_context(priv, ctx)\r\n_iwl_set_rxon_ht(priv, ht_conf, ctx);\r\n}\r\nvoid iwl_set_rxon_channel(struct iwl_priv *priv, struct ieee80211_channel *ch,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nenum ieee80211_band band = ch->band;\r\nu16 channel = ch->hw_value;\r\nif ((le16_to_cpu(ctx->staging.channel) == channel) &&\r\n(priv->band == band))\r\nreturn;\r\nctx->staging.channel = cpu_to_le16(channel);\r\nif (band == IEEE80211_BAND_5GHZ)\r\nctx->staging.flags &= ~RXON_FLG_BAND_24G_MSK;\r\nelse\r\nctx->staging.flags |= RXON_FLG_BAND_24G_MSK;\r\npriv->band = band;\r\nIWL_DEBUG_INFO(priv, "Staging channel set to %d [%d]\n", channel, band);\r\n}\r\nvoid iwl_set_flags_for_band(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nenum ieee80211_band band,\r\nstruct ieee80211_vif *vif)\r\n{\r\nif (band == IEEE80211_BAND_5GHZ) {\r\nctx->staging.flags &=\r\n~(RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK\r\n| RXON_FLG_CCK_MSK);\r\nctx->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\r\n} else {\r\nif (vif && vif->bss_conf.use_short_slot)\r\nctx->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\r\nelse\r\nctx->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\r\nctx->staging.flags |= RXON_FLG_BAND_24G_MSK;\r\nctx->staging.flags |= RXON_FLG_AUTO_DETECT_MSK;\r\nctx->staging.flags &= ~RXON_FLG_CCK_MSK;\r\n}\r\n}\r\nstatic void iwl_set_rxon_hwcrypto(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx, int hw_decrypt)\r\n{\r\nstruct iwl_rxon_cmd *rxon = &ctx->staging;\r\nif (hw_decrypt)\r\nrxon->filter_flags &= ~RXON_FILTER_DIS_DECRYPT_MSK;\r\nelse\r\nrxon->filter_flags |= RXON_FILTER_DIS_DECRYPT_MSK;\r\n}\r\nstatic int iwl_check_rxon_cmd(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nstruct iwl_rxon_cmd *rxon = &ctx->staging;\r\nu32 errors = 0;\r\nif (rxon->flags & RXON_FLG_BAND_24G_MSK) {\r\nif (rxon->flags & RXON_FLG_TGJ_NARROW_BAND_MSK) {\r\nIWL_WARN(priv, "check 2.4G: wrong narrow\n");\r\nerrors |= BIT(0);\r\n}\r\nif (rxon->flags & RXON_FLG_RADAR_DETECT_MSK) {\r\nIWL_WARN(priv, "check 2.4G: wrong radar\n");\r\nerrors |= BIT(1);\r\n}\r\n} else {\r\nif (!(rxon->flags & RXON_FLG_SHORT_SLOT_MSK)) {\r\nIWL_WARN(priv, "check 5.2G: not short slot!\n");\r\nerrors |= BIT(2);\r\n}\r\nif (rxon->flags & RXON_FLG_CCK_MSK) {\r\nIWL_WARN(priv, "check 5.2G: CCK!\n");\r\nerrors |= BIT(3);\r\n}\r\n}\r\nif ((rxon->node_addr[0] | rxon->bssid_addr[0]) & 0x1) {\r\nIWL_WARN(priv, "mac/bssid mcast!\n");\r\nerrors |= BIT(4);\r\n}\r\nif ((rxon->ofdm_basic_rates & IWL_RATE_6M_MASK) == 0 &&\r\n(rxon->cck_basic_rates & IWL_RATE_1M_MASK) == 0) {\r\nIWL_WARN(priv, "neither 1 nor 6 are basic\n");\r\nerrors |= BIT(5);\r\n}\r\nif (le16_to_cpu(rxon->assoc_id) > 2007) {\r\nIWL_WARN(priv, "aid > 2007\n");\r\nerrors |= BIT(6);\r\n}\r\nif ((rxon->flags & (RXON_FLG_CCK_MSK | RXON_FLG_SHORT_SLOT_MSK))\r\n== (RXON_FLG_CCK_MSK | RXON_FLG_SHORT_SLOT_MSK)) {\r\nIWL_WARN(priv, "CCK and short slot\n");\r\nerrors |= BIT(7);\r\n}\r\nif ((rxon->flags & (RXON_FLG_CCK_MSK | RXON_FLG_AUTO_DETECT_MSK))\r\n== (RXON_FLG_CCK_MSK | RXON_FLG_AUTO_DETECT_MSK)) {\r\nIWL_WARN(priv, "CCK and auto detect");\r\nerrors |= BIT(8);\r\n}\r\nif ((rxon->flags & (RXON_FLG_AUTO_DETECT_MSK |\r\nRXON_FLG_TGG_PROTECT_MSK)) ==\r\nRXON_FLG_TGG_PROTECT_MSK) {\r\nIWL_WARN(priv, "TGg but no auto-detect\n");\r\nerrors |= BIT(9);\r\n}\r\nif (rxon->channel == 0) {\r\nIWL_WARN(priv, "zero channel is invalid\n");\r\nerrors |= BIT(10);\r\n}\r\nWARN(errors, "Invalid RXON (%#x), channel %d",\r\nerrors, le16_to_cpu(rxon->channel));\r\nreturn errors ? -EINVAL : 0;\r\n}\r\nstatic int iwl_full_rxon_required(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nconst struct iwl_rxon_cmd *staging = &ctx->staging;\r\nconst struct iwl_rxon_cmd *active = &ctx->active;\r\n#define CHK(cond) \\r\nif ((cond)) { \\r\nIWL_DEBUG_INFO(priv, "need full RXON - " #cond "\n"); \\r\nreturn 1; \\r\n}\r\n#define CHK_NEQ(c1, c2) \\r\nif ((c1) != (c2)) { \\r\nIWL_DEBUG_INFO(priv, "need full RXON - " \\r\n#c1 " != " #c2 " - %d != %d\n", \\r\n(c1), (c2)); \\r\nreturn 1; \\r\n}\r\nCHK(!iwl_is_associated_ctx(ctx));\r\nCHK(!ether_addr_equal(staging->bssid_addr, active->bssid_addr));\r\nCHK(!ether_addr_equal(staging->node_addr, active->node_addr));\r\nCHK(!ether_addr_equal(staging->wlap_bssid_addr,\r\nactive->wlap_bssid_addr));\r\nCHK_NEQ(staging->dev_type, active->dev_type);\r\nCHK_NEQ(staging->channel, active->channel);\r\nCHK_NEQ(staging->air_propagation, active->air_propagation);\r\nCHK_NEQ(staging->ofdm_ht_single_stream_basic_rates,\r\nactive->ofdm_ht_single_stream_basic_rates);\r\nCHK_NEQ(staging->ofdm_ht_dual_stream_basic_rates,\r\nactive->ofdm_ht_dual_stream_basic_rates);\r\nCHK_NEQ(staging->ofdm_ht_triple_stream_basic_rates,\r\nactive->ofdm_ht_triple_stream_basic_rates);\r\nCHK_NEQ(staging->assoc_id, active->assoc_id);\r\nCHK_NEQ(staging->flags & RXON_FLG_BAND_24G_MSK,\r\nactive->flags & RXON_FLG_BAND_24G_MSK);\r\nCHK_NEQ(staging->filter_flags & RXON_FILTER_ASSOC_MSK,\r\nactive->filter_flags & RXON_FILTER_ASSOC_MSK);\r\n#undef CHK\r\n#undef CHK_NEQ\r\nreturn 0;\r\n}\r\nvoid iwl_print_rx_config_cmd(struct iwl_priv *priv,\r\nenum iwl_rxon_context_id ctxid)\r\n{\r\nstruct iwl_rxon_context *ctx = &priv->contexts[ctxid];\r\nstruct iwl_rxon_cmd *rxon = &ctx->staging;\r\nIWL_DEBUG_RADIO(priv, "RX CONFIG:\n");\r\niwl_print_hex_dump(priv, IWL_DL_RADIO, (u8 *) rxon, sizeof(*rxon));\r\nIWL_DEBUG_RADIO(priv, "u16 channel: 0x%x\n",\r\nle16_to_cpu(rxon->channel));\r\nIWL_DEBUG_RADIO(priv, "u32 flags: 0x%08X\n",\r\nle32_to_cpu(rxon->flags));\r\nIWL_DEBUG_RADIO(priv, "u32 filter_flags: 0x%08x\n",\r\nle32_to_cpu(rxon->filter_flags));\r\nIWL_DEBUG_RADIO(priv, "u8 dev_type: 0x%x\n", rxon->dev_type);\r\nIWL_DEBUG_RADIO(priv, "u8 ofdm_basic_rates: 0x%02x\n",\r\nrxon->ofdm_basic_rates);\r\nIWL_DEBUG_RADIO(priv, "u8 cck_basic_rates: 0x%02x\n",\r\nrxon->cck_basic_rates);\r\nIWL_DEBUG_RADIO(priv, "u8[6] node_addr: %pM\n", rxon->node_addr);\r\nIWL_DEBUG_RADIO(priv, "u8[6] bssid_addr: %pM\n", rxon->bssid_addr);\r\nIWL_DEBUG_RADIO(priv, "u16 assoc_id: 0x%x\n",\r\nle16_to_cpu(rxon->assoc_id));\r\n}\r\nstatic void iwl_calc_basic_rates(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nint lowest_present_ofdm = 100;\r\nint lowest_present_cck = 100;\r\nu8 cck = 0;\r\nu8 ofdm = 0;\r\nif (ctx->vif) {\r\nstruct ieee80211_supported_band *sband;\r\nunsigned long basic = ctx->vif->bss_conf.basic_rates;\r\nint i;\r\nsband = priv->hw->wiphy->bands[priv->hw->conf.chandef.chan->band];\r\nfor_each_set_bit(i, &basic, BITS_PER_LONG) {\r\nint hw = sband->bitrates[i].hw_value;\r\nif (hw >= IWL_FIRST_OFDM_RATE) {\r\nofdm |= BIT(hw - IWL_FIRST_OFDM_RATE);\r\nif (lowest_present_ofdm > hw)\r\nlowest_present_ofdm = hw;\r\n} else {\r\nBUILD_BUG_ON(IWL_FIRST_CCK_RATE != 0);\r\ncck |= BIT(hw);\r\nif (lowest_present_cck > hw)\r\nlowest_present_cck = hw;\r\n}\r\n}\r\n}\r\nif (IWL_RATE_24M_INDEX < lowest_present_ofdm)\r\nofdm |= IWL_RATE_24M_MASK >> IWL_FIRST_OFDM_RATE;\r\nif (IWL_RATE_12M_INDEX < lowest_present_ofdm)\r\nofdm |= IWL_RATE_12M_MASK >> IWL_FIRST_OFDM_RATE;\r\nofdm |= IWL_RATE_6M_MASK >> IWL_FIRST_OFDM_RATE;\r\nif (IWL_RATE_11M_INDEX < lowest_present_cck)\r\ncck |= IWL_RATE_11M_MASK >> IWL_FIRST_CCK_RATE;\r\nif (IWL_RATE_5M_INDEX < lowest_present_cck)\r\ncck |= IWL_RATE_5M_MASK >> IWL_FIRST_CCK_RATE;\r\nif (IWL_RATE_2M_INDEX < lowest_present_cck)\r\ncck |= IWL_RATE_2M_MASK >> IWL_FIRST_CCK_RATE;\r\ncck |= IWL_RATE_1M_MASK >> IWL_FIRST_CCK_RATE;\r\nIWL_DEBUG_RATE(priv, "Set basic rates cck:0x%.2x ofdm:0x%.2x\n",\r\ncck, ofdm);\r\nctx->staging.cck_basic_rates = cck;\r\nctx->staging.ofdm_basic_rates = ofdm;\r\n}\r\nint iwlagn_commit_rxon(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\r\n{\r\nstruct iwl_rxon_cmd *active = (void *)&ctx->active;\r\nbool new_assoc = !!(ctx->staging.filter_flags & RXON_FILTER_ASSOC_MSK);\r\nint ret;\r\nlockdep_assert_held(&priv->mutex);\r\nif (!iwl_is_alive(priv))\r\nreturn -EBUSY;\r\nBUILD_BUG_ON(NUM_IWL_RXON_CTX != 2);\r\nif (!ctx->is_active)\r\nreturn 0;\r\nctx->staging.flags |= RXON_FLG_TSF2HOST_MSK;\r\niwl_calc_basic_rates(priv, ctx);\r\nif (!priv->hw_params.use_rts_for_aggregation)\r\nctx->staging.flags |= RXON_FLG_SELF_CTS_EN;\r\nif ((ctx->vif && ctx->vif->bss_conf.use_short_slot) ||\r\n!(ctx->staging.flags & RXON_FLG_BAND_24G_MSK))\r\nctx->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\r\nelse\r\nctx->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\r\niwl_print_rx_config_cmd(priv, ctx->ctxid);\r\nret = iwl_check_rxon_cmd(priv, ctx);\r\nif (ret) {\r\nIWL_ERR(priv, "Invalid RXON configuration. Not committing.\n");\r\nreturn -EINVAL;\r\n}\r\nif (test_bit(STATUS_CHANNEL_SWITCH_PENDING, &priv->status) &&\r\n(priv->switch_channel != ctx->staging.channel)) {\r\nIWL_DEBUG_11H(priv, "abort channel switch on %d\n",\r\nle16_to_cpu(priv->switch_channel));\r\niwl_chswitch_done(priv, false);\r\n}\r\nif (!iwl_full_rxon_required(priv, ctx)) {\r\nret = iwlagn_send_rxon_assoc(priv, ctx);\r\nif (ret) {\r\nIWL_ERR(priv, "Error setting RXON_ASSOC (%d)\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(active, &ctx->staging, sizeof(*active));\r\niwl_set_tx_power(priv, priv->tx_power_next, false);\r\niwl_power_update_mode(priv, true);\r\nreturn 0;\r\n}\r\niwl_set_rxon_hwcrypto(priv, ctx, !iwlwifi_mod_params.sw_crypto);\r\nIWL_DEBUG_INFO(priv,\r\n"Going to commit RXON\n"\r\n" * with%s RXON_FILTER_ASSOC_MSK\n"\r\n" * channel = %d\n"\r\n" * bssid = %pM\n",\r\n(new_assoc ? "" : "out"),\r\nle16_to_cpu(ctx->staging.channel),\r\nctx->staging.bssid_addr);\r\nret = iwlagn_rxon_disconn(priv, ctx);\r\nif (ret)\r\nreturn ret;\r\nret = iwlagn_set_pan_params(priv);\r\nif (ret)\r\nreturn ret;\r\nif (new_assoc)\r\nreturn iwlagn_rxon_connect(priv, ctx);\r\nreturn 0;\r\n}\r\nvoid iwlagn_config_ht40(struct ieee80211_conf *conf,\r\nstruct iwl_rxon_context *ctx)\r\n{\r\nif (conf_is_ht40_minus(conf)) {\r\nctx->ht.extension_chan_offset =\r\nIEEE80211_HT_PARAM_CHA_SEC_BELOW;\r\nctx->ht.is_40mhz = true;\r\n} else if (conf_is_ht40_plus(conf)) {\r\nctx->ht.extension_chan_offset =\r\nIEEE80211_HT_PARAM_CHA_SEC_ABOVE;\r\nctx->ht.is_40mhz = true;\r\n} else {\r\nctx->ht.extension_chan_offset =\r\nIEEE80211_HT_PARAM_CHA_SEC_NONE;\r\nctx->ht.is_40mhz = false;\r\n}\r\n}\r\nint iwlagn_mac_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\r\nstruct iwl_rxon_context *ctx;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstruct ieee80211_channel *channel = conf->chandef.chan;\r\nint ret = 0;\r\nIWL_DEBUG_MAC80211(priv, "enter: changed %#x\n", changed);\r\nmutex_lock(&priv->mutex);\r\nif (unlikely(test_bit(STATUS_SCANNING, &priv->status))) {\r\nIWL_DEBUG_MAC80211(priv, "leave - scanning\n");\r\ngoto out;\r\n}\r\nif (!iwl_is_ready(priv)) {\r\nIWL_DEBUG_MAC80211(priv, "leave - not ready\n");\r\ngoto out;\r\n}\r\nif (changed & (IEEE80211_CONF_CHANGE_SMPS |\r\nIEEE80211_CONF_CHANGE_CHANNEL)) {\r\npriv->current_ht_config.smps = conf->smps_mode;\r\nfor_each_context(priv, ctx)\r\niwlagn_set_rxon_chain(priv, ctx);\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\r\nfor_each_context(priv, ctx) {\r\nif (ctx->ht.enabled != conf_is_ht(conf))\r\nctx->ht.enabled = conf_is_ht(conf);\r\nif (ctx->ht.enabled) {\r\nif (!ctx->ht.is_40mhz ||\r\n!iwl_is_associated_ctx(ctx))\r\niwlagn_config_ht40(conf, ctx);\r\n} else\r\nctx->ht.is_40mhz = false;\r\nctx->ht.protection = IEEE80211_HT_OP_MODE_PROTECTION_NONE;\r\nif (le16_to_cpu(ctx->staging.channel) !=\r\nchannel->hw_value)\r\nctx->staging.flags = 0;\r\niwl_set_rxon_channel(priv, channel, ctx);\r\niwl_set_rxon_ht(priv, &priv->current_ht_config);\r\niwl_set_flags_for_band(priv, ctx, channel->band,\r\nctx->vif);\r\n}\r\niwl_update_bcast_stations(priv);\r\n}\r\nif (changed & (IEEE80211_CONF_CHANGE_PS |\r\nIEEE80211_CONF_CHANGE_IDLE)) {\r\nret = iwl_power_update_mode(priv, false);\r\nif (ret)\r\nIWL_DEBUG_MAC80211(priv, "Error setting sleep level\n");\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_POWER) {\r\nIWL_DEBUG_MAC80211(priv, "TX Power old=%d new=%d\n",\r\npriv->tx_power_user_lmt, conf->power_level);\r\niwl_set_tx_power(priv, conf->power_level, false);\r\n}\r\nfor_each_context(priv, ctx) {\r\nif (!memcmp(&ctx->staging, &ctx->active, sizeof(ctx->staging)))\r\ncontinue;\r\niwlagn_commit_rxon(priv, ctx);\r\n}\r\nout:\r\nmutex_unlock(&priv->mutex);\r\nIWL_DEBUG_MAC80211(priv, "leave\n");\r\nreturn ret;\r\n}\r\nstatic void iwlagn_check_needed_chains(struct iwl_priv *priv,\r\nstruct iwl_rxon_context *ctx,\r\nstruct ieee80211_bss_conf *bss_conf)\r\n{\r\nstruct ieee80211_vif *vif = ctx->vif;\r\nstruct iwl_rxon_context *tmp;\r\nstruct ieee80211_sta *sta;\r\nstruct iwl_ht_config *ht_conf = &priv->current_ht_config;\r\nstruct ieee80211_sta_ht_cap *ht_cap;\r\nbool need_multiple;\r\nlockdep_assert_held(&priv->mutex);\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(vif, bss_conf->bssid);\r\nif (!sta) {\r\nneed_multiple = false;\r\nrcu_read_unlock();\r\nbreak;\r\n}\r\nht_cap = &sta->ht_cap;\r\nneed_multiple = true;\r\nif (ht_cap->mcs.rx_mask[1] == 0 &&\r\nht_cap->mcs.rx_mask[2] == 0) {\r\nneed_multiple = false;\r\n} else if (!(ht_cap->mcs.tx_params &\r\nIEEE80211_HT_MCS_TX_DEFINED)) {\r\nneed_multiple = false;\r\n} else if (ht_cap->mcs.tx_params &\r\nIEEE80211_HT_MCS_TX_RX_DIFF) {\r\nint maxstreams;\r\nmaxstreams = (ht_cap->mcs.tx_params &\r\nIEEE80211_HT_MCS_TX_MAX_STREAMS_MASK);\r\nmaxstreams >>=\r\nIEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT;\r\nmaxstreams += 1;\r\nif (maxstreams <= 1)\r\nneed_multiple = false;\r\n}\r\nrcu_read_unlock();\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nneed_multiple = false;\r\nbreak;\r\ndefault:\r\nneed_multiple = true;\r\nbreak;\r\n}\r\nctx->ht_need_multiple_chains = need_multiple;\r\nif (!need_multiple) {\r\nfor_each_context(priv, tmp) {\r\nif (!tmp->vif)\r\ncontinue;\r\nif (tmp->ht_need_multiple_chains) {\r\nneed_multiple = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nht_conf->single_chain_sufficient = !need_multiple;\r\n}\r\nstatic void iwlagn_chain_noise_reset(struct iwl_priv *priv)\r\n{\r\nstruct iwl_chain_noise_data *data = &priv->chain_noise_data;\r\nint ret;\r\nif (priv->calib_disabled & IWL_CHAIN_NOISE_CALIB_DISABLED)\r\nreturn;\r\nif ((data->state == IWL_CHAIN_NOISE_ALIVE) &&\r\niwl_is_any_associated(priv)) {\r\nstruct iwl_calib_chain_noise_reset_cmd cmd;\r\ndata->chain_noise_a = 0;\r\ndata->chain_noise_b = 0;\r\ndata->chain_noise_c = 0;\r\ndata->chain_signal_a = 0;\r\ndata->chain_signal_b = 0;\r\ndata->chain_signal_c = 0;\r\ndata->beacon_count = 0;\r\nmemset(&cmd, 0, sizeof(cmd));\r\niwl_set_calib_hdr(&cmd.hdr,\r\npriv->phy_calib_chain_noise_reset_cmd);\r\nret = iwl_dvm_send_cmd_pdu(priv,\r\nREPLY_PHY_CALIBRATION_CMD,\r\nCMD_SYNC, sizeof(cmd), &cmd);\r\nif (ret)\r\nIWL_ERR(priv,\r\n"Could not send REPLY_PHY_CALIBRATION_CMD\n");\r\ndata->state = IWL_CHAIN_NOISE_ACCUMULATE;\r\nIWL_DEBUG_CALIB(priv, "Run chain_noise_calibrate\n");\r\n}\r\n}\r\nvoid iwlagn_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf,\r\nu32 changes)\r\n{\r\nstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\r\nstruct iwl_rxon_context *ctx = iwl_rxon_ctx_from_vif(vif);\r\nint ret;\r\nbool force = false;\r\nmutex_lock(&priv->mutex);\r\nif (changes & BSS_CHANGED_IDLE && bss_conf->idle) {\r\niwlagn_lift_passive_no_rx(priv);\r\n}\r\nif (unlikely(!iwl_is_ready(priv))) {\r\nIWL_DEBUG_MAC80211(priv, "leave - not ready\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn;\r\n}\r\nif (unlikely(!ctx->vif)) {\r\nIWL_DEBUG_MAC80211(priv, "leave - vif is NULL\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn;\r\n}\r\nif (changes & BSS_CHANGED_BEACON_INT)\r\nforce = true;\r\nif (changes & BSS_CHANGED_QOS) {\r\nctx->qos_data.qos_active = bss_conf->qos;\r\niwlagn_update_qos(priv, ctx);\r\n}\r\nctx->staging.assoc_id = cpu_to_le16(vif->bss_conf.aid);\r\nif (vif->bss_conf.use_short_preamble)\r\nctx->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\r\nelse\r\nctx->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\r\nif (changes & BSS_CHANGED_ASSOC) {\r\nif (bss_conf->assoc) {\r\npriv->timestamp = bss_conf->sync_tsf;\r\nctx->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\r\n} else {\r\nctx->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nif (ctx->ctxid == IWL_RXON_CTX_BSS)\r\npriv->have_rekey_data = false;\r\n}\r\niwlagn_bt_coex_rssi_monitor(priv);\r\n}\r\nif (ctx->ht.enabled) {\r\nctx->ht.protection = bss_conf->ht_operation_mode &\r\nIEEE80211_HT_OP_MODE_PROTECTION;\r\nctx->ht.non_gf_sta_present = !!(bss_conf->ht_operation_mode &\r\nIEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\r\niwlagn_check_needed_chains(priv, ctx, bss_conf);\r\niwl_set_rxon_ht(priv, &priv->current_ht_config);\r\n}\r\niwlagn_set_rxon_chain(priv, ctx);\r\nif (bss_conf->use_cts_prot && (priv->band != IEEE80211_BAND_5GHZ))\r\nctx->staging.flags |= RXON_FLG_TGG_PROTECT_MSK;\r\nelse\r\nctx->staging.flags &= ~RXON_FLG_TGG_PROTECT_MSK;\r\nif (bss_conf->use_cts_prot)\r\nctx->staging.flags |= RXON_FLG_SELF_CTS_EN;\r\nelse\r\nctx->staging.flags &= ~RXON_FLG_SELF_CTS_EN;\r\nmemcpy(ctx->staging.bssid_addr, bss_conf->bssid, ETH_ALEN);\r\nif (vif->type == NL80211_IFTYPE_AP ||\r\nvif->type == NL80211_IFTYPE_ADHOC) {\r\nif (vif->bss_conf.enable_beacon) {\r\nctx->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\r\npriv->beacon_ctx = ctx;\r\n} else {\r\nctx->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\npriv->beacon_ctx = NULL;\r\n}\r\n}\r\nif (vif->type == NL80211_IFTYPE_STATION) {\r\nif (!bss_conf->assoc)\r\nctx->staging.filter_flags |= RXON_FILTER_BCON_AWARE_MSK;\r\nelse\r\nctx->staging.filter_flags &=\r\n~RXON_FILTER_BCON_AWARE_MSK;\r\n}\r\nif (force || memcmp(&ctx->staging, &ctx->active, sizeof(ctx->staging)))\r\niwlagn_commit_rxon(priv, ctx);\r\nif (changes & BSS_CHANGED_ASSOC && bss_conf->assoc) {\r\nif (priv->chain_noise_data.state == IWL_CHAIN_NOISE_DONE)\r\niwl_power_update_mode(priv, false);\r\niwlagn_chain_noise_reset(priv);\r\npriv->start_calib = 1;\r\n}\r\nif (changes & BSS_CHANGED_IBSS) {\r\nret = iwlagn_manage_ibss_station(priv, vif,\r\nbss_conf->ibss_joined);\r\nif (ret)\r\nIWL_ERR(priv, "failed to %s IBSS station %pM\n",\r\nbss_conf->ibss_joined ? "add" : "remove",\r\nbss_conf->bssid);\r\n}\r\nif (changes & BSS_CHANGED_BEACON && priv->beacon_ctx == ctx) {\r\nif (iwlagn_update_beacon(priv, vif))\r\nIWL_ERR(priv, "Error updating beacon\n");\r\n}\r\nmutex_unlock(&priv->mutex);\r\n}\r\nvoid iwlagn_post_scan(struct iwl_priv *priv)\r\n{\r\nstruct iwl_rxon_context *ctx;\r\niwl_power_set_mode(priv, &priv->power_data.sleep_cmd_next, false);\r\niwl_set_tx_power(priv, priv->tx_power_next, false);\r\nfor_each_context(priv, ctx)\r\nif (memcmp(&ctx->staging, &ctx->active, sizeof(ctx->staging)))\r\niwlagn_commit_rxon(priv, ctx);\r\niwlagn_set_pan_params(priv);\r\n}
