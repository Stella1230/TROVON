static bool alps_is_valid_first_byte(struct alps_data *priv,\r\nunsigned char data)\r\n{\r\nreturn (data & priv->mask0) == priv->byte0;\r\n}\r\nstatic void alps_report_buttons(struct psmouse *psmouse,\r\nstruct input_dev *dev1, struct input_dev *dev2,\r\nint left, int right, int middle)\r\n{\r\nstruct input_dev *dev;\r\ndev = test_bit(BTN_LEFT, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_LEFT, left);\r\ndev = test_bit(BTN_RIGHT, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ndev = test_bit(BTN_MIDDLE, dev2->key) ? dev2 : dev1;\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\ninput_sync(dev2);\r\n}\r\nstatic void alps_process_packet_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct input_dev *dev2 = priv->dev2;\r\nint x, y, z, ges, fin, left, right, middle;\r\nint back = 0, forward = 0;\r\nif (priv->proto_version == ALPS_PROTO_V1) {\r\nleft = packet[2] & 0x10;\r\nright = packet[2] & 0x08;\r\nmiddle = 0;\r\nx = packet[1] | ((packet[0] & 0x07) << 7);\r\ny = packet[4] | ((packet[3] & 0x07) << 7);\r\nz = packet[5];\r\n} else {\r\nleft = packet[3] & 1;\r\nright = packet[3] & 2;\r\nmiddle = packet[3] & 4;\r\nx = packet[1] | ((packet[2] & 0x78) << (7 - 3));\r\ny = packet[4] | ((packet[3] & 0x70) << (7 - 4));\r\nz = packet[5];\r\n}\r\nif (priv->flags & ALPS_FW_BK_1) {\r\nback = packet[0] & 0x10;\r\nforward = packet[2] & 4;\r\n}\r\nif (priv->flags & ALPS_FW_BK_2) {\r\nback = packet[3] & 4;\r\nforward = packet[2] & 4;\r\nif ((middle = forward && back))\r\nforward = back = 0;\r\n}\r\nges = packet[2] & 1;\r\nfin = packet[2] & 2;\r\nif ((priv->flags & ALPS_DUALPOINT) && z == 127) {\r\ninput_report_rel(dev2, REL_X, (x > 383 ? (x - 768) : x));\r\ninput_report_rel(dev2, REL_Y, -(y > 255 ? (y - 512) : y));\r\nalps_report_buttons(psmouse, dev2, dev, left, right, middle);\r\ninput_sync(dev2);\r\nreturn;\r\n}\r\nalps_report_buttons(psmouse, dev, dev2, left, right, middle);\r\nif (ges && !fin)\r\nz = 40;\r\nif (ges && fin && !priv->prev_fin) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\ninput_report_abs(dev, ABS_PRESSURE, 0);\r\ninput_report_key(dev, BTN_TOOL_FINGER, 0);\r\ninput_sync(dev);\r\n}\r\npriv->prev_fin = fin;\r\nif (z > 30)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nif (z < 25)\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nif (z > 0) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, z);\r\ninput_report_key(dev, BTN_TOOL_FINGER, z > 0);\r\nif (priv->flags & ALPS_WHEEL)\r\ninput_report_rel(dev, REL_WHEEL, ((packet[2] << 1) & 0x08) - ((packet[0] >> 4) & 0x07));\r\nif (priv->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\r\ninput_report_key(dev, BTN_FORWARD, forward);\r\ninput_report_key(dev, BTN_BACK, back);\r\n}\r\nif (priv->flags & ALPS_FOUR_BUTTONS) {\r\ninput_report_key(dev, BTN_0, packet[2] & 4);\r\ninput_report_key(dev, BTN_1, packet[0] & 0x10);\r\ninput_report_key(dev, BTN_2, packet[3] & 4);\r\ninput_report_key(dev, BTN_3, packet[0] & 0x20);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic int alps_process_bitmap(struct alps_data *priv,\r\nunsigned int x_map, unsigned int y_map,\r\nint *x1, int *y1, int *x2, int *y2)\r\n{\r\nstruct alps_bitmap_point {\r\nint start_bit;\r\nint num_bits;\r\n};\r\nint fingers_x = 0, fingers_y = 0, fingers;\r\nint i, bit, prev_bit;\r\nstruct alps_bitmap_point x_low = {0,}, x_high = {0,};\r\nstruct alps_bitmap_point y_low = {0,}, y_high = {0,};\r\nstruct alps_bitmap_point *point;\r\nif (!x_map || !y_map)\r\nreturn 0;\r\n*x1 = *y1 = *x2 = *y2 = 0;\r\nprev_bit = 0;\r\npoint = &x_low;\r\nfor (i = 0; x_map != 0; i++, x_map >>= 1) {\r\nbit = x_map & 1;\r\nif (bit) {\r\nif (!prev_bit) {\r\npoint->start_bit = i;\r\nfingers_x++;\r\n}\r\npoint->num_bits++;\r\n} else {\r\nif (prev_bit)\r\npoint = &x_high;\r\nelse\r\npoint->num_bits = 0;\r\n}\r\nprev_bit = bit;\r\n}\r\ny_map = y_map << (sizeof(y_map) * BITS_PER_BYTE - priv->y_bits);\r\nprev_bit = 0;\r\npoint = &y_low;\r\nfor (i = 0; y_map != 0; i++, y_map <<= 1) {\r\nbit = y_map & (1 << (sizeof(y_map) * BITS_PER_BYTE - 1));\r\nif (bit) {\r\nif (!prev_bit) {\r\npoint->start_bit = i;\r\nfingers_y++;\r\n}\r\npoint->num_bits++;\r\n} else {\r\nif (prev_bit)\r\npoint = &y_high;\r\nelse\r\npoint->num_bits = 0;\r\n}\r\nprev_bit = bit;\r\n}\r\nfingers = max(fingers_x, fingers_y);\r\nif (fingers > 1) {\r\nif (fingers_x == 1) {\r\ni = x_low.num_bits / 2;\r\nx_low.num_bits = x_low.num_bits - i;\r\nx_high.start_bit = x_low.start_bit + i;\r\nx_high.num_bits = max(i, 1);\r\n} else if (fingers_y == 1) {\r\ni = y_low.num_bits / 2;\r\ny_low.num_bits = y_low.num_bits - i;\r\ny_high.start_bit = y_low.start_bit + i;\r\ny_high.num_bits = max(i, 1);\r\n}\r\n}\r\n*x1 = (priv->x_max * (2 * x_low.start_bit + x_low.num_bits - 1)) /\r\n(2 * (priv->x_bits - 1));\r\n*y1 = (priv->y_max * (2 * y_low.start_bit + y_low.num_bits - 1)) /\r\n(2 * (priv->y_bits - 1));\r\nif (fingers > 1) {\r\n*x2 = (priv->x_max *\r\n(2 * x_high.start_bit + x_high.num_bits - 1)) /\r\n(2 * (priv->x_bits - 1));\r\n*y2 = (priv->y_max *\r\n(2 * y_high.start_bit + y_high.num_bits - 1)) /\r\n(2 * (priv->y_bits - 1));\r\n}\r\nreturn fingers;\r\n}\r\nstatic void alps_set_slot(struct input_dev *dev, int slot, bool active,\r\nint x, int y)\r\n{\r\ninput_mt_slot(dev, slot);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, active);\r\nif (active) {\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\nstatic void alps_report_semi_mt_data(struct input_dev *dev, int num_fingers,\r\nint x1, int y1, int x2, int y2)\r\n{\r\nalps_set_slot(dev, 0, num_fingers != 0, x1, y1);\r\nalps_set_slot(dev, 1, num_fingers == 2, x2, y2);\r\n}\r\nstatic void alps_process_trackstick_packet_v3(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = priv->dev2;\r\nint x, y, z, left, right, middle;\r\nif (!(packet[0] & 0x40)) {\r\npsmouse_dbg(psmouse, "Bad trackstick packet, discarding\n");\r\nreturn;\r\n}\r\nif (packet[1] == 0x7f && packet[2] == 0x7f && packet[4] == 0x7f)\r\nreturn;\r\nx = (s8)(((packet[0] & 0x20) << 2) | (packet[1] & 0x7f));\r\ny = (s8)(((packet[0] & 0x10) << 3) | (packet[2] & 0x7f));\r\nz = (packet[4] & 0x7c) >> 2;\r\nx /= 8;\r\ny /= 8;\r\ninput_report_rel(dev, REL_X, x);\r\ninput_report_rel(dev, REL_Y, -y);\r\nleft = packet[3] & 0x01;\r\nright = packet[3] & 0x02;\r\nmiddle = packet[3] & 0x04;\r\nif (!(priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS) &&\r\n(left || right || middle))\r\npriv->quirks |= ALPS_QUIRK_TRACKSTICK_BUTTONS;\r\nif (priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS) {\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\ninput_report_key(dev, BTN_MIDDLE, middle);\r\n}\r\ninput_sync(dev);\r\nreturn;\r\n}\r\nstatic void alps_decode_buttons_v3(struct alps_fields *f, unsigned char *p)\r\n{\r\nf->left = !!(p[3] & 0x01);\r\nf->right = !!(p[3] & 0x02);\r\nf->middle = !!(p[3] & 0x04);\r\nf->ts_left = !!(p[3] & 0x10);\r\nf->ts_right = !!(p[3] & 0x20);\r\nf->ts_middle = !!(p[3] & 0x40);\r\n}\r\nstatic void alps_decode_pinnacle(struct alps_fields *f, unsigned char *p)\r\n{\r\nf->first_mp = !!(p[4] & 0x40);\r\nf->is_mp = !!(p[0] & 0x40);\r\nf->fingers = (p[5] & 0x3) + 1;\r\nf->x_map = ((p[4] & 0x7e) << 8) |\r\n((p[1] & 0x7f) << 2) |\r\n((p[0] & 0x30) >> 4);\r\nf->y_map = ((p[3] & 0x70) << 4) |\r\n((p[2] & 0x7f) << 1) |\r\n(p[4] & 0x01);\r\nf->x = ((p[1] & 0x7f) << 4) | ((p[4] & 0x30) >> 2) |\r\n((p[0] & 0x30) >> 4);\r\nf->y = ((p[2] & 0x7f) << 4) | (p[4] & 0x0f);\r\nf->z = p[5] & 0x7f;\r\nalps_decode_buttons_v3(f, p);\r\n}\r\nstatic void alps_decode_rushmore(struct alps_fields *f, unsigned char *p)\r\n{\r\nalps_decode_pinnacle(f, p);\r\nf->x_map |= (p[5] & 0x10) << 11;\r\nf->y_map |= (p[5] & 0x20) << 6;\r\n}\r\nstatic void alps_decode_dolphin(struct alps_fields *f, unsigned char *p)\r\n{\r\nf->first_mp = !!(p[0] & 0x02);\r\nf->is_mp = !!(p[0] & 0x20);\r\nf->fingers = ((p[0] & 0x6) >> 1 |\r\n(p[0] & 0x10) >> 2);\r\nf->x_map = ((p[2] & 0x60) >> 5) |\r\n((p[4] & 0x7f) << 2) |\r\n((p[5] & 0x7f) << 9) |\r\n((p[3] & 0x07) << 16) |\r\n((p[3] & 0x70) << 15) |\r\n((p[0] & 0x01) << 22);\r\nf->y_map = (p[1] & 0x7f) |\r\n((p[2] & 0x1f) << 7);\r\nf->x = ((p[1] & 0x7f) | ((p[4] & 0x0f) << 7));\r\nf->y = ((p[2] & 0x7f) | ((p[4] & 0xf0) << 3));\r\nf->z = (p[0] & 4) ? 0 : p[5] & 0x7f;\r\nalps_decode_buttons_v3(f, p);\r\n}\r\nstatic void alps_process_touchpad_packet_v3(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nstruct input_dev *dev2 = priv->dev2;\r\nint x1 = 0, y1 = 0, x2 = 0, y2 = 0;\r\nint fingers = 0, bmap_fingers;\r\nstruct alps_fields f;\r\npriv->decode_fields(&f, packet);\r\nif (priv->multi_packet) {\r\nif (f.is_mp) {\r\nfingers = f.fingers;\r\nbmap_fingers = alps_process_bitmap(priv,\r\nf.x_map, f.y_map,\r\n&x1, &y1, &x2, &y2);\r\nif (fingers > 1 && bmap_fingers < 2)\r\nfingers = bmap_fingers;\r\npriv->decode_fields(&f, priv->multi_data);\r\n} else {\r\npriv->multi_packet = 0;\r\n}\r\n}\r\nif (f.is_mp)\r\nreturn;\r\nif (!priv->multi_packet && f.first_mp) {\r\npriv->multi_packet = 1;\r\nmemcpy(priv->multi_data, packet, sizeof(priv->multi_data));\r\nreturn;\r\n}\r\npriv->multi_packet = 0;\r\nif (f.x && f.y && !f.z)\r\nreturn;\r\nif (!fingers) {\r\nx1 = f.x;\r\ny1 = f.y;\r\nfingers = f.z > 0 ? 1 : 0;\r\n}\r\nif (f.z >= 64)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nelse\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nalps_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\r\ninput_mt_report_finger_count(dev, fingers);\r\ninput_report_key(dev, BTN_LEFT, f.left);\r\ninput_report_key(dev, BTN_RIGHT, f.right);\r\ninput_report_key(dev, BTN_MIDDLE, f.middle);\r\nif (f.z > 0) {\r\ninput_report_abs(dev, ABS_X, f.x);\r\ninput_report_abs(dev, ABS_Y, f.y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, f.z);\r\ninput_sync(dev);\r\nif (!(priv->quirks & ALPS_QUIRK_TRACKSTICK_BUTTONS)) {\r\ninput_report_key(dev2, BTN_LEFT, f.ts_left);\r\ninput_report_key(dev2, BTN_RIGHT, f.ts_right);\r\ninput_report_key(dev2, BTN_MIDDLE, f.ts_middle);\r\ninput_sync(dev2);\r\n}\r\n}\r\nstatic void alps_process_packet_v3(struct psmouse *psmouse)\r\n{\r\nunsigned char *packet = psmouse->packet;\r\nif (packet[5] == 0x3f) {\r\nalps_process_trackstick_packet_v3(psmouse);\r\nreturn;\r\n}\r\nalps_process_touchpad_packet_v3(psmouse);\r\n}\r\nstatic void alps_process_packet_v4(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char *packet = psmouse->packet;\r\nstruct input_dev *dev = psmouse->dev;\r\nint offset;\r\nint x, y, z;\r\nint left, right;\r\nint x1, y1, x2, y2;\r\nint fingers = 0;\r\nunsigned int x_bitmap, y_bitmap;\r\nif (packet[6] & 0x40) {\r\npriv->multi_packet = 0;\r\n}\r\nif (WARN_ON_ONCE(priv->multi_packet > 2))\r\nreturn;\r\noffset = 2 * priv->multi_packet;\r\npriv->multi_data[offset] = packet[6];\r\npriv->multi_data[offset + 1] = packet[7];\r\nif (++priv->multi_packet > 2) {\r\npriv->multi_packet = 0;\r\nx_bitmap = ((priv->multi_data[2] & 0x1f) << 10) |\r\n((priv->multi_data[3] & 0x60) << 3) |\r\n((priv->multi_data[0] & 0x3f) << 2) |\r\n((priv->multi_data[1] & 0x60) >> 5);\r\ny_bitmap = ((priv->multi_data[5] & 0x01) << 10) |\r\n((priv->multi_data[3] & 0x1f) << 5) |\r\n(priv->multi_data[1] & 0x1f);\r\nfingers = alps_process_bitmap(priv, x_bitmap, y_bitmap,\r\n&x1, &y1, &x2, &y2);\r\npriv->fingers = fingers;\r\npriv->x1 = x1;\r\npriv->x2 = x2;\r\npriv->y1 = y1;\r\npriv->y2 = y2;\r\n}\r\nleft = packet[4] & 0x01;\r\nright = packet[4] & 0x02;\r\nx = ((packet[1] & 0x7f) << 4) | ((packet[3] & 0x30) >> 2) |\r\n((packet[0] & 0x30) >> 4);\r\ny = ((packet[2] & 0x7f) << 4) | (packet[3] & 0x0f);\r\nz = packet[5] & 0x7f;\r\nif (priv->fingers < 2) {\r\nx1 = x;\r\ny1 = y;\r\nfingers = z > 0 ? 1 : 0;\r\n} else {\r\nfingers = priv->fingers;\r\nx1 = priv->x1;\r\nx2 = priv->x2;\r\ny1 = priv->y1;\r\ny2 = priv->y2;\r\n}\r\nif (z >= 64)\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\nelse\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\nalps_report_semi_mt_data(dev, fingers, x1, y1, x2, y2);\r\ninput_mt_report_finger_count(dev, fingers);\r\ninput_report_key(dev, BTN_LEFT, left);\r\ninput_report_key(dev, BTN_RIGHT, right);\r\nif (z > 0) {\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\n}\r\ninput_report_abs(dev, ABS_PRESSURE, z);\r\ninput_sync(dev);\r\n}\r\nstatic void alps_report_bare_ps2_packet(struct psmouse *psmouse,\r\nunsigned char packet[],\r\nbool report_buttons)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct input_dev *dev2 = priv->dev2;\r\nif (report_buttons)\r\nalps_report_buttons(psmouse, dev2, psmouse->dev,\r\npacket[0] & 1, packet[0] & 2, packet[0] & 4);\r\ninput_report_rel(dev2, REL_X,\r\npacket[1] ? packet[1] - ((packet[0] << 4) & 0x100) : 0);\r\ninput_report_rel(dev2, REL_Y,\r\npacket[2] ? ((packet[0] << 3) & 0x100) - packet[2] : 0);\r\ninput_sync(dev2);\r\n}\r\nstatic psmouse_ret_t alps_handle_interleaved_ps2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nif (psmouse->pktcnt < 6)\r\nreturn PSMOUSE_GOOD_DATA;\r\nif (psmouse->pktcnt == 6) {\r\nmod_timer(&priv->timer, jiffies + msecs_to_jiffies(20));\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\ndel_timer(&priv->timer);\r\nif (psmouse->packet[6] & 0x80) {\r\nif (((psmouse->packet[3] |\r\npsmouse->packet[4] |\r\npsmouse->packet[5]) & 0x80) ||\r\n(!alps_is_valid_first_byte(priv, psmouse->packet[6]))) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet %4ph (suspected interleaved ps/2)\n",\r\npsmouse->packet + 3);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\npriv->process_packet(psmouse);\r\npsmouse->packet[0] = psmouse->packet[6];\r\npsmouse->pktcnt = 1;\r\n} else {\r\nalps_report_bare_ps2_packet(psmouse, &psmouse->packet[3],\r\nfalse);\r\npsmouse->packet[3] = psmouse->packet[6] & 0xf7;\r\npsmouse->pktcnt = 4;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic void alps_flush_packet(unsigned long data)\r\n{\r\nstruct psmouse *psmouse = (struct psmouse *)data;\r\nstruct alps_data *priv = psmouse->private;\r\nserio_pause_rx(psmouse->ps2dev.serio);\r\nif (psmouse->pktcnt == psmouse->pktsize) {\r\nif ((psmouse->packet[3] |\r\npsmouse->packet[4] |\r\npsmouse->packet[5]) & 0x80) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet %3ph (suspected interleaved ps/2)\n",\r\npsmouse->packet + 3);\r\n} else {\r\npriv->process_packet(psmouse);\r\n}\r\npsmouse->pktcnt = 0;\r\n}\r\nserio_continue_rx(psmouse->ps2dev.serio);\r\n}\r\nstatic psmouse_ret_t alps_process_byte(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nif ((psmouse->packet[0] & 0xc8) == 0x08) {\r\nif (psmouse->pktcnt == 3) {\r\nalps_report_bare_ps2_packet(psmouse, psmouse->packet,\r\ntrue);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nif ((priv->flags & ALPS_PS2_INTERLEAVED) &&\r\npsmouse->pktcnt >= 4 && (psmouse->packet[3] & 0x0f) == 0x0f) {\r\nreturn alps_handle_interleaved_ps2(psmouse);\r\n}\r\nif (!alps_is_valid_first_byte(priv, psmouse->packet[0])) {\r\npsmouse_dbg(psmouse,\r\n"refusing packet[0] = %x (mask0 = %x, byte0 = %x)\n",\r\npsmouse->packet[0], priv->mask0, priv->byte0);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (priv->proto_version != ALPS_PROTO_V5 &&\r\npsmouse->pktcnt >= 2 && psmouse->pktcnt <= psmouse->pktsize &&\r\n(psmouse->packet[psmouse->pktcnt - 1] & 0x80)) {\r\npsmouse_dbg(psmouse, "refusing packet[%i] = %x\n",\r\npsmouse->pktcnt - 1,\r\npsmouse->packet[psmouse->pktcnt - 1]);\r\nreturn PSMOUSE_BAD_DATA;\r\n}\r\nif (psmouse->pktcnt == psmouse->pktsize) {\r\npriv->process_packet(psmouse);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic int alps_command_mode_send_nibble(struct psmouse *psmouse, int nibble)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct alps_data *priv = psmouse->private;\r\nint command;\r\nunsigned char *param;\r\nunsigned char dummy[4];\r\nBUG_ON(nibble > 0xf);\r\ncommand = priv->nibble_commands[nibble].command;\r\nparam = (command & 0x0f00) ?\r\ndummy : (unsigned char *)&priv->nibble_commands[nibble].data;\r\nif (ps2_command(ps2dev, param, command))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_command_mode_set_addr(struct psmouse *psmouse, int addr)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nstruct alps_data *priv = psmouse->private;\r\nint i, nibble;\r\nif (ps2_command(ps2dev, NULL, priv->addr_command))\r\nreturn -1;\r\nfor (i = 12; i >= 0; i -= 4) {\r\nnibble = (addr >> i) & 0xf;\r\nif (alps_command_mode_send_nibble(psmouse, nibble))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __alps_command_mode_read_reg(struct psmouse *psmouse, int addr)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4];\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -1;\r\nif (addr != ((param[0] << 8) | param[1]))\r\nreturn -1;\r\nreturn param[2];\r\n}\r\nstatic int alps_command_mode_read_reg(struct psmouse *psmouse, int addr)\r\n{\r\nif (alps_command_mode_set_addr(psmouse, addr))\r\nreturn -1;\r\nreturn __alps_command_mode_read_reg(psmouse, addr);\r\n}\r\nstatic int __alps_command_mode_write_reg(struct psmouse *psmouse, u8 value)\r\n{\r\nif (alps_command_mode_send_nibble(psmouse, (value >> 4) & 0xf))\r\nreturn -1;\r\nif (alps_command_mode_send_nibble(psmouse, value & 0xf))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_command_mode_write_reg(struct psmouse *psmouse, int addr,\r\nu8 value)\r\n{\r\nif (alps_command_mode_set_addr(psmouse, addr))\r\nreturn -1;\r\nreturn __alps_command_mode_write_reg(psmouse, value);\r\n}\r\nstatic int alps_rpt_cmd(struct psmouse *psmouse, int init_command,\r\nint repeated_command, unsigned char *param)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nparam[0] = 0;\r\nif (init_command && ps2_command(ps2dev, param, init_command))\r\nreturn -EIO;\r\nif (ps2_command(ps2dev, NULL, repeated_command) ||\r\nps2_command(ps2dev, NULL, repeated_command) ||\r\nps2_command(ps2dev, NULL, repeated_command))\r\nreturn -EIO;\r\nparam[0] = param[1] = param[2] = 0xff;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO))\r\nreturn -EIO;\r\npsmouse_dbg(psmouse, "%2.2X report: %3ph\n",\r\nrepeated_command, param);\r\nreturn 0;\r\n}\r\nstatic int alps_enter_command_mode(struct psmouse *psmouse)\r\n{\r\nunsigned char param[4];\r\nif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_RESET_WRAP, param)) {\r\npsmouse_err(psmouse, "failed to enter command mode\n");\r\nreturn -1;\r\n}\r\nif ((param[0] != 0x88 || (param[1] != 0x07 && param[1] != 0x08)) &&\r\nparam[0] != 0x73) {\r\npsmouse_dbg(psmouse,\r\n"unknown response while entering command mode\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int alps_exit_command_mode(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_passthrough_mode_v2(struct psmouse *psmouse, bool enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint cmd = enable ? PSMOUSE_CMD_SETSCALE21 : PSMOUSE_CMD_SETSCALE11;\r\nif (ps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, cmd) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE))\r\nreturn -1;\r\nps2_drain(ps2dev, 3, 100);\r\nreturn 0;\r\n}\r\nstatic int alps_absolute_mode_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE))\r\nreturn -1;\r\nreturn ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETPOLL);\r\n}\r\nstatic int alps_get_status(struct psmouse *psmouse, char *param)\r\n{\r\nif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_DISABLE, param))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_tap_mode(struct psmouse *psmouse, int enable)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint cmd = enable ? PSMOUSE_CMD_SETRATE : PSMOUSE_CMD_SETRES;\r\nunsigned char tap_arg = enable ? 0x0A : 0x00;\r\nunsigned char param[4];\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_DISABLE) ||\r\nps2_command(ps2dev, &tap_arg, cmd))\r\nreturn -1;\r\nif (alps_get_status(psmouse, param))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_poll(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nunsigned char buf[sizeof(psmouse->packet)];\r\nbool poll_failed;\r\nif (priv->flags & ALPS_PASS)\r\nalps_passthrough_mode_v2(psmouse, true);\r\npoll_failed = ps2_command(&psmouse->ps2dev, buf,\r\nPSMOUSE_CMD_POLL | (psmouse->pktsize << 8)) < 0;\r\nif (priv->flags & ALPS_PASS)\r\nalps_passthrough_mode_v2(psmouse, false);\r\nif (poll_failed || (buf[0] & priv->mask0) != priv->byte0)\r\nreturn -1;\r\nif ((psmouse->badbyte & 0xc8) == 0x08) {\r\nif (ps2_command(&psmouse->ps2dev, buf, PSMOUSE_CMD_POLL | (3 << 8)))\r\nreturn -1;\r\n}\r\nmemcpy(psmouse->packet, buf, sizeof(buf));\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v1_v2(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nif ((priv->flags & ALPS_PASS) &&\r\nalps_passthrough_mode_v2(psmouse, true)) {\r\nreturn -1;\r\n}\r\nif (alps_tap_mode(psmouse, true)) {\r\npsmouse_warn(psmouse, "Failed to enable hardware tapping\n");\r\nreturn -1;\r\n}\r\nif (alps_absolute_mode_v1_v2(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enable absolute mode\n");\r\nreturn -1;\r\n}\r\nif ((priv->flags & ALPS_PASS) &&\r\nalps_passthrough_mode_v2(psmouse, false)) {\r\nreturn -1;\r\n}\r\nif (ps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_SETSTREAM)) {\r\npsmouse_err(psmouse, "Failed to enable stream mode\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_passthrough_mode_v3(struct psmouse *psmouse,\r\nint reg_base, bool enable)\r\n{\r\nint reg_val, ret = -1;\r\nif (alps_enter_command_mode(psmouse))\r\nreturn -1;\r\nreg_val = alps_command_mode_read_reg(psmouse, reg_base + 0x0008);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (enable)\r\nreg_val |= 0x01;\r\nelse\r\nreg_val &= ~0x01;\r\nret = __alps_command_mode_write_reg(psmouse, reg_val);\r\nerror:\r\nif (alps_exit_command_mode(psmouse))\r\nret = -1;\r\nreturn ret;\r\n}\r\nstatic int alps_absolute_mode_v3(struct psmouse *psmouse)\r\n{\r\nint reg_val;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0004);\r\nif (reg_val == -1)\r\nreturn -1;\r\nreg_val |= 0x06;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_probe_trackstick_v3(struct psmouse *psmouse, int reg_base)\r\n{\r\nint ret = -EIO, reg_val;\r\nif (alps_enter_command_mode(psmouse))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, reg_base + 0x08);\r\nif (reg_val == -1)\r\ngoto error;\r\nret = reg_val & 0x80 ? 0 : -ENODEV;\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn ret;\r\n}\r\nstatic int alps_setup_trackstick_v3(struct psmouse *psmouse, int reg_base)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint ret = 0;\r\nunsigned char param[4];\r\nif (alps_passthrough_mode_v3(psmouse, reg_base, true))\r\nreturn -EIO;\r\nif (alps_rpt_cmd(psmouse, 0, PSMOUSE_CMD_SETSCALE21, param)) {\r\npsmouse_warn(psmouse, "trackstick E7 report failed\n");\r\nret = -ENODEV;\r\n} else {\r\npsmouse_dbg(psmouse, "trackstick E7 report: %3ph\n", param);\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSCALE11) ||\r\nalps_command_mode_send_nibble(psmouse, 0x9) ||\r\nalps_command_mode_send_nibble(psmouse, 0x4)) {\r\npsmouse_err(psmouse,\r\n"Error sending magic E6 sequence\n");\r\nret = -EIO;\r\ngoto error;\r\n}\r\nif (alps_enter_command_mode(psmouse) ||\r\nalps_command_mode_write_reg(psmouse,\r\nreg_base + 0x08, 0x82) ||\r\nalps_exit_command_mode(psmouse))\r\nret = -EIO;\r\n}\r\nerror:\r\nif (alps_passthrough_mode_v3(psmouse, reg_base, false))\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nstatic int alps_hw_init_v3(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint reg_val;\r\nunsigned char param[4];\r\nreg_val = alps_probe_trackstick_v3(psmouse, ALPS_REG_BASE_PINNACLE);\r\nif (reg_val == -EIO)\r\ngoto error;\r\nif (reg_val == 0 &&\r\nalps_setup_trackstick_v3(psmouse, ALPS_REG_BASE_PINNACLE) == -EIO)\r\ngoto error;\r\nif (alps_enter_command_mode(psmouse) ||\r\nalps_absolute_mode_v3(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enter absolute mode\n");\r\ngoto error;\r\n}\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0006);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x01))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0007);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x01))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0144) == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, 0x04))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0159) == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, 0x03))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0163) == -1)\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0163, 0x03))\r\ngoto error;\r\nif (alps_command_mode_read_reg(psmouse, 0x0162) == -1)\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0162, 0x04))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nparam[0] = 0x64;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\r\npsmouse_err(psmouse, "Failed to enable data reporting\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn -1;\r\n}\r\nstatic int alps_hw_init_rushmore_v3(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint reg_val, ret = -1;\r\nif (priv->flags & ALPS_DUALPOINT) {\r\nreg_val = alps_setup_trackstick_v3(psmouse,\r\nALPS_REG_BASE_RUSHMORE);\r\nif (reg_val == -EIO)\r\ngoto error;\r\nif (reg_val == -ENODEV)\r\npriv->flags &= ~ALPS_DUALPOINT;\r\n}\r\nif (alps_enter_command_mode(psmouse) ||\r\nalps_command_mode_read_reg(psmouse, 0xc2d9) == -1 ||\r\nalps_command_mode_write_reg(psmouse, 0xc2cb, 0x00))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0xc2c6);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val & 0xfd))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0xc2c9, 0x64))\r\ngoto error;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0xc2c4);\r\nif (reg_val == -1)\r\ngoto error;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val | 0x02))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nreturn ps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE);\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn ret;\r\n}\r\nstatic int alps_absolute_mode_v4(struct psmouse *psmouse)\r\n{\r\nint reg_val;\r\nreg_val = alps_command_mode_read_reg(psmouse, 0x0004);\r\nif (reg_val == -1)\r\nreturn -1;\r\nreg_val |= 0x02;\r\nif (__alps_command_mode_write_reg(psmouse, reg_val))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int alps_hw_init_v4(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[4];\r\nif (alps_enter_command_mode(psmouse))\r\ngoto error;\r\nif (alps_absolute_mode_v4(psmouse)) {\r\npsmouse_err(psmouse, "Failed to enter absolute mode\n");\r\ngoto error;\r\n}\r\nif (alps_command_mode_write_reg(psmouse, 0x0007, 0x8c))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0149, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0160, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x017f, 0x15))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0151, 0x01))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0168, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x014a, 0x03))\r\ngoto error;\r\nif (alps_command_mode_write_reg(psmouse, 0x0161, 0x03))\r\ngoto error;\r\nalps_exit_command_mode(psmouse);\r\nparam[0] = 0xc8;\r\nparam[1] = 0x64;\r\nparam[2] = 0x50;\r\nif (ps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[2], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, param, PSMOUSE_CMD_GETID))\r\nreturn -1;\r\nparam[0] = 0x64;\r\nif (ps2_command(ps2dev, param, PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, NULL, PSMOUSE_CMD_ENABLE)) {\r\npsmouse_err(psmouse, "Failed to enable data reporting\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\nerror:\r\nalps_exit_command_mode(psmouse);\r\nreturn -1;\r\n}\r\nstatic int alps_hw_init_dolphin_v1(struct psmouse *psmouse)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nunsigned char param[2];\r\nparam[0] = 0x64;\r\nparam[1] = 0x28;\r\nif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_SETSTREAM) ||\r\nps2_command(ps2dev, &param[0], PSMOUSE_CMD_SETRATE) ||\r\nps2_command(ps2dev, &param[1], PSMOUSE_CMD_SETRATE))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void alps_set_defaults(struct alps_data *priv)\r\n{\r\npriv->byte0 = 0x8f;\r\npriv->mask0 = 0x8f;\r\npriv->flags = ALPS_DUALPOINT;\r\npriv->x_max = 2000;\r\npriv->y_max = 1400;\r\npriv->x_bits = 15;\r\npriv->y_bits = 11;\r\nswitch (priv->proto_version) {\r\ncase ALPS_PROTO_V1:\r\ncase ALPS_PROTO_V2:\r\npriv->hw_init = alps_hw_init_v1_v2;\r\npriv->process_packet = alps_process_packet_v1_v2;\r\npriv->set_abs_params = alps_set_abs_params_st;\r\nbreak;\r\ncase ALPS_PROTO_V3:\r\npriv->hw_init = alps_hw_init_v3;\r\npriv->process_packet = alps_process_packet_v3;\r\npriv->set_abs_params = alps_set_abs_params_mt;\r\npriv->decode_fields = alps_decode_pinnacle;\r\npriv->nibble_commands = alps_v3_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\r\nbreak;\r\ncase ALPS_PROTO_V4:\r\npriv->hw_init = alps_hw_init_v4;\r\npriv->process_packet = alps_process_packet_v4;\r\npriv->set_abs_params = alps_set_abs_params_mt;\r\npriv->nibble_commands = alps_v4_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_DISABLE;\r\nbreak;\r\ncase ALPS_PROTO_V5:\r\npriv->hw_init = alps_hw_init_dolphin_v1;\r\npriv->process_packet = alps_process_packet_v3;\r\npriv->decode_fields = alps_decode_dolphin;\r\npriv->set_abs_params = alps_set_abs_params_mt;\r\npriv->nibble_commands = alps_v3_nibble_commands;\r\npriv->addr_command = PSMOUSE_CMD_RESET_WRAP;\r\npriv->byte0 = 0xc8;\r\npriv->mask0 = 0xc8;\r\npriv->flags = 0;\r\npriv->x_max = 1360;\r\npriv->y_max = 660;\r\npriv->x_bits = 23;\r\npriv->y_bits = 12;\r\nbreak;\r\n}\r\n}\r\nstatic int alps_match_table(struct psmouse *psmouse, struct alps_data *priv,\r\nunsigned char *e7, unsigned char *ec)\r\n{\r\nconst struct alps_model_info *model;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(alps_model_data); i++) {\r\nmodel = &alps_model_data[i];\r\nif (!memcmp(e7, model->signature, sizeof(model->signature)) &&\r\n(!model->command_mode_resp ||\r\nmodel->command_mode_resp == ec[2])) {\r\npriv->proto_version = model->proto_version;\r\nalps_set_defaults(priv);\r\npriv->flags = model->flags;\r\npriv->byte0 = model->byte0;\r\npriv->mask0 = model->mask0;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int alps_identify(struct psmouse *psmouse, struct alps_data *priv)\r\n{\r\nunsigned char e6[4], e7[4], ec[4];\r\nif (alps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\r\nPSMOUSE_CMD_SETSCALE11, e6))\r\nreturn -EIO;\r\nif ((e6[0] & 0xf8) != 0 || e6[1] != 0 || (e6[2] != 10 && e6[2] != 100))\r\nreturn -EINVAL;\r\nif (alps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\r\nPSMOUSE_CMD_SETSCALE21, e7) ||\r\nalps_rpt_cmd(psmouse, PSMOUSE_CMD_SETRES,\r\nPSMOUSE_CMD_RESET_WRAP, ec) ||\r\nalps_exit_command_mode(psmouse))\r\nreturn -EIO;\r\nif (alps_match_table(psmouse, priv, e7, ec) == 0) {\r\nreturn 0;\r\n} else if (e7[0] == 0x73 && e7[1] == 0x03 && e7[2] == 0x50 &&\r\nec[0] == 0x73 && ec[1] == 0x01) {\r\npriv->proto_version = ALPS_PROTO_V5;\r\nalps_set_defaults(priv);\r\nreturn 0;\r\n} else if (ec[0] == 0x88 && ec[1] == 0x08) {\r\npriv->proto_version = ALPS_PROTO_V3;\r\nalps_set_defaults(priv);\r\npriv->hw_init = alps_hw_init_rushmore_v3;\r\npriv->decode_fields = alps_decode_rushmore;\r\npriv->x_bits = 16;\r\npriv->y_bits = 12;\r\npsmouse->private = priv;\r\nif (alps_probe_trackstick_v3(psmouse, ALPS_REG_BASE_RUSHMORE))\r\npriv->flags &= ~ALPS_DUALPOINT;\r\nreturn 0;\r\n} else if (ec[0] == 0x88 && ec[1] == 0x07 &&\r\nec[2] >= 0x90 && ec[2] <= 0x9d) {\r\npriv->proto_version = ALPS_PROTO_V3;\r\nalps_set_defaults(priv);\r\nreturn 0;\r\n}\r\npsmouse_info(psmouse,\r\n"Unknown ALPS touchpad: E7=%3ph, EC=%3ph\n", e7, ec);\r\nreturn -EINVAL;\r\n}\r\nstatic int alps_reconnect(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\npsmouse_reset(psmouse);\r\nif (alps_identify(psmouse, priv) < 0)\r\nreturn -1;\r\nreturn priv->hw_init(psmouse);\r\n}\r\nstatic void alps_disconnect(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv = psmouse->private;\r\npsmouse_reset(psmouse);\r\ndel_timer_sync(&priv->timer);\r\ninput_unregister_device(priv->dev2);\r\nkfree(priv);\r\n}\r\nstatic void alps_set_abs_params_st(struct alps_data *priv,\r\nstruct input_dev *dev1)\r\n{\r\ninput_set_abs_params(dev1, ABS_X, 0, 1023, 0, 0);\r\ninput_set_abs_params(dev1, ABS_Y, 0, 767, 0, 0);\r\n}\r\nstatic void alps_set_abs_params_mt(struct alps_data *priv,\r\nstruct input_dev *dev1)\r\n{\r\nset_bit(INPUT_PROP_SEMI_MT, dev1->propbit);\r\ninput_mt_init_slots(dev1, 2, 0);\r\ninput_set_abs_params(dev1, ABS_MT_POSITION_X, 0, priv->x_max, 0, 0);\r\ninput_set_abs_params(dev1, ABS_MT_POSITION_Y, 0, priv->y_max, 0, 0);\r\nset_bit(BTN_TOOL_DOUBLETAP, dev1->keybit);\r\nset_bit(BTN_TOOL_TRIPLETAP, dev1->keybit);\r\nset_bit(BTN_TOOL_QUADTAP, dev1->keybit);\r\ninput_set_abs_params(dev1, ABS_X, 0, priv->x_max, 0, 0);\r\ninput_set_abs_params(dev1, ABS_Y, 0, priv->y_max, 0, 0);\r\n}\r\nint alps_init(struct psmouse *psmouse)\r\n{\r\nstruct alps_data *priv;\r\nstruct input_dev *dev1 = psmouse->dev, *dev2;\r\npriv = kzalloc(sizeof(struct alps_data), GFP_KERNEL);\r\ndev2 = input_allocate_device();\r\nif (!priv || !dev2)\r\ngoto init_fail;\r\npriv->dev2 = dev2;\r\nsetup_timer(&priv->timer, alps_flush_packet, (unsigned long)psmouse);\r\npsmouse->private = priv;\r\npsmouse_reset(psmouse);\r\nif (alps_identify(psmouse, priv) < 0)\r\ngoto init_fail;\r\nif (priv->hw_init(psmouse))\r\ngoto init_fail;\r\n__clear_bit(EV_REL, dev1->evbit);\r\n__clear_bit(REL_X, dev1->relbit);\r\n__clear_bit(REL_Y, dev1->relbit);\r\ndev1->evbit[BIT_WORD(EV_KEY)] |= BIT_MASK(EV_KEY);\r\ndev1->keybit[BIT_WORD(BTN_TOUCH)] |= BIT_MASK(BTN_TOUCH);\r\ndev1->keybit[BIT_WORD(BTN_TOOL_FINGER)] |= BIT_MASK(BTN_TOOL_FINGER);\r\ndev1->keybit[BIT_WORD(BTN_LEFT)] |=\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_RIGHT);\r\ndev1->evbit[BIT_WORD(EV_ABS)] |= BIT_MASK(EV_ABS);\r\npriv->set_abs_params(priv, dev1);\r\ninput_set_abs_params(dev1, ABS_PRESSURE, 0, 127, 0, 0);\r\nif (priv->flags & ALPS_WHEEL) {\r\ndev1->evbit[BIT_WORD(EV_REL)] |= BIT_MASK(EV_REL);\r\ndev1->relbit[BIT_WORD(REL_WHEEL)] |= BIT_MASK(REL_WHEEL);\r\n}\r\nif (priv->flags & (ALPS_FW_BK_1 | ALPS_FW_BK_2)) {\r\ndev1->keybit[BIT_WORD(BTN_FORWARD)] |= BIT_MASK(BTN_FORWARD);\r\ndev1->keybit[BIT_WORD(BTN_BACK)] |= BIT_MASK(BTN_BACK);\r\n}\r\nif (priv->flags & ALPS_FOUR_BUTTONS) {\r\ndev1->keybit[BIT_WORD(BTN_0)] |= BIT_MASK(BTN_0);\r\ndev1->keybit[BIT_WORD(BTN_1)] |= BIT_MASK(BTN_1);\r\ndev1->keybit[BIT_WORD(BTN_2)] |= BIT_MASK(BTN_2);\r\ndev1->keybit[BIT_WORD(BTN_3)] |= BIT_MASK(BTN_3);\r\n} else {\r\ndev1->keybit[BIT_WORD(BTN_MIDDLE)] |= BIT_MASK(BTN_MIDDLE);\r\n}\r\nsnprintf(priv->phys, sizeof(priv->phys), "%s/input1", psmouse->ps2dev.serio->phys);\r\ndev2->phys = priv->phys;\r\ndev2->name = (priv->flags & ALPS_DUALPOINT) ?\r\n"DualPoint Stick" : "PS/2 Mouse";\r\ndev2->id.bustype = BUS_I8042;\r\ndev2->id.vendor = 0x0002;\r\ndev2->id.product = PSMOUSE_ALPS;\r\ndev2->id.version = 0x0000;\r\ndev2->dev.parent = &psmouse->ps2dev.serio->dev;\r\ndev2->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ndev2->relbit[BIT_WORD(REL_X)] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\ndev2->keybit[BIT_WORD(BTN_LEFT)] =\r\nBIT_MASK(BTN_LEFT) | BIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\r\nif (input_register_device(priv->dev2))\r\ngoto init_fail;\r\npsmouse->protocol_handler = alps_process_byte;\r\npsmouse->poll = alps_poll;\r\npsmouse->disconnect = alps_disconnect;\r\npsmouse->reconnect = alps_reconnect;\r\npsmouse->pktsize = priv->proto_version == ALPS_PROTO_V4 ? 8 : 6;\r\npsmouse->resync_time = 0;\r\nreturn 0;\r\ninit_fail:\r\npsmouse_reset(psmouse);\r\ninput_free_device(dev2);\r\nkfree(priv);\r\npsmouse->private = NULL;\r\nreturn -1;\r\n}\r\nint alps_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nstruct alps_data dummy;\r\nif (alps_identify(psmouse, &dummy) < 0)\r\nreturn -1;\r\nif (set_properties) {\r\npsmouse->vendor = "ALPS";\r\npsmouse->name = dummy.flags & ALPS_DUALPOINT ?\r\n"DualPoint TouchPad" : "GlidePoint";\r\npsmouse->model = dummy.proto_version << 8;\r\n}\r\nreturn 0;\r\n}
