static void\r\ndevice_set_options(struct vnt_private *pDevice) {\r\nu8 abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};\r\nu8 abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};\r\nmemcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);\r\npDevice->cbTD = TX_DESC_DEF0;\r\npDevice->cbRD = RX_DESC_DEF0;\r\npDevice->uChannel = CHANNEL_DEF;\r\npDevice->wRTSThreshold = RTS_THRESH_DEF;\r\npDevice->wFragmentationThreshold = FRAG_THRESH_DEF;\r\npDevice->byShortRetryLimit = SHORT_RETRY_DEF;\r\npDevice->byLongRetryLimit = LONG_RETRY_DEF;\r\npDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;\r\npDevice->byShortPreamble = PREAMBLE_TYPE_DEF;\r\npDevice->ePSMode = PS_MODE_DEF;\r\npDevice->b11hEnable = X80211h_MODE_DEF;\r\npDevice->eOPMode = OP_MODE_DEF;\r\npDevice->uConnectionRate = DATA_RATE_DEF;\r\nif (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = true;\r\npDevice->byBBType = BBP_TYPE_DEF;\r\npDevice->byPacketType = pDevice->byBBType;\r\npDevice->byAutoFBCtrl = AUTO_FB_0;\r\npDevice->bUpdateBBVGA = true;\r\npDevice->byFOETuning = 0;\r\npDevice->byAutoPwrTunning = 0;\r\npDevice->wCTSDuration = 0;\r\npDevice->byPreambleType = 0;\r\npDevice->bExistSWNetAddr = false;\r\npDevice->bDiversityRegCtlON = false;\r\n}\r\nstatic void device_init_diversity_timer(struct vnt_private *pDevice)\r\n{\r\ninit_timer(&pDevice->TimerSQ3Tmax1);\r\npDevice->TimerSQ3Tmax1.data = (unsigned long)pDevice;\r\npDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;\r\npDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);\r\ninit_timer(&pDevice->TimerSQ3Tmax2);\r\npDevice->TimerSQ3Tmax2.data = (unsigned long)pDevice;\r\npDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;\r\npDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);\r\ninit_timer(&pDevice->TimerSQ3Tmax3);\r\npDevice->TimerSQ3Tmax3.data = (unsigned long)pDevice;\r\npDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerSQ3Tmax3CallBack;\r\npDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);\r\nreturn;\r\n}\r\nstatic int device_init_registers(struct vnt_private *pDevice,\r\nDEVICE_INIT_TYPE InitType)\r\n{\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nu8 abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 abySNAP_RFC1042[ETH_ALEN] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};\r\nu8 abySNAP_Bridgetunnel[ETH_ALEN]\r\n= {0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8};\r\nu8 byAntenna;\r\nint ii;\r\nCMD_CARD_INIT sInitCmd;\r\nint ntStatus = STATUS_SUCCESS;\r\nRSP_CARD_INIT sInitRsp;\r\nu8 byTmp;\r\nu8 byCalibTXIQ = 0, byCalibTXDC = 0, byCalibRXIQ = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "---->INIbInitAdapter. [%d][%d]\n", InitType, pDevice->byPacketType);\r\nspin_lock_irq(&pDevice->lock);\r\nif (InitType == DEVICE_INIT_COLD) {\r\nmemcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_Bridgetunnel,\r\nabySNAP_Bridgetunnel,\r\nETH_ALEN);\r\nif ( !FIRMWAREbCheckVersion(pDevice) ) {\r\nif (FIRMWAREbDownload(pDevice) == true) {\r\nif (FIRMWAREbBrach2Sram(pDevice) == false) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" FIRMWAREbBrach2Sram fail \n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn false;\r\n}\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" FIRMWAREbDownload fail \n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn false;\r\n}\r\n}\r\nif ( !BBbVT3184Init(pDevice) ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" BBbVT3184Init fail \n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn false;\r\n}\r\n}\r\nsInitCmd.byInitClass = (u8)InitType;\r\nsInitCmd.bExistSWNetAddr = (u8) pDevice->bExistSWNetAddr;\r\nfor (ii = 0; ii < 6; ii++)\r\nsInitCmd.bySWNetAddr[ii] = pDevice->abyCurrentNetAddr[ii];\r\nsInitCmd.byShortRetryLimit = pDevice->byShortRetryLimit;\r\nsInitCmd.byLongRetryLimit = pDevice->byLongRetryLimit;\r\nntStatus = CONTROLnsRequestOut(pDevice,\r\nMESSAGE_TYPE_CARDINIT,\r\n0,\r\n0,\r\nsizeof(CMD_CARD_INIT),\r\n(u8 *) &(sInitCmd));\r\nif ( ntStatus != STATUS_SUCCESS ) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Issue Card init fail \n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn false;\r\n}\r\nif (InitType == DEVICE_INIT_COLD) {\r\nntStatus = CONTROLnsRequestIn(pDevice,MESSAGE_TYPE_INIT_RSP,0,0,sizeof(RSP_CARD_INIT), (u8 *) &(sInitRsp));\r\nif (ntStatus != STATUS_SUCCESS) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Cardinit request in status fail!\n");\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn false;\r\n}\r\nntStatus = CONTROLnsRequestIn(pDevice,\r\nMESSAGE_TYPE_READ,\r\nMAC_REG_LOCALID,\r\nMESSAGE_REQUEST_MACREG,\r\n1,\r\n&pDevice->byLocalID);\r\nif ( ntStatus != STATUS_SUCCESS ) {\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn false;\r\n}\r\npDevice->bCCK = true;\r\npDevice->bProtectMode = false;\r\npDevice->bNonERPPresent = false;\r\npDevice->bBarkerPreambleMd = false;\r\nif ( pDevice->bFixRate ) {\r\npDevice->wCurrentRate = (u16) pDevice->uConnectionRate;\r\n} else {\r\nif ( pDevice->byBBType == BB_TYPE_11B )\r\npDevice->wCurrentRate = RATE_11M;\r\nelse\r\npDevice->wCurrentRate = RATE_54M;\r\n}\r\nCHvInitChannelTable(pDevice);\r\npDevice->byTopOFDMBasicRate = RATE_24M;\r\npDevice->byTopCCKBasicRate = RATE_1M;\r\npDevice->byRevId = 0;\r\npDevice->byCurPwr = 0xFF;\r\npDevice->byCCKPwr = pDevice->abyEEPROM[EEP_OFS_PWR_CCK];\r\npDevice->byOFDMPwrG = pDevice->abyEEPROM[EEP_OFS_PWR_OFDMG];\r\nfor (ii = 0; ii < 14; ii++) {\r\npDevice->abyCCKPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_CCK_PWR_TBL];\r\nif (pDevice->abyCCKPwrTbl[ii] == 0)\r\npDevice->abyCCKPwrTbl[ii] = pDevice->byCCKPwr;\r\npDevice->abyOFDMPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_OFDM_PWR_TBL];\r\nif (pDevice->abyOFDMPwrTbl[ii] == 0)\r\npDevice->abyOFDMPwrTbl[ii] = pDevice->byOFDMPwrG;\r\n}\r\nif(((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||\r\n(pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe))&&\r\n(pDevice->byOriginalZonetype == ZoneType_USA)) {\r\nfor (ii = 11; ii < 14; ii++) {\r\npDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];\r\npDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];\r\n}\r\n}\r\npDevice->byOFDMPwrA = 0x34;\r\nfor (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) {\r\npDevice->abyOFDMAPwrTbl[ii] = pDevice->abyEEPROM[ii + EEP_OFS_OFDMA_PWR_TBL];\r\nif (pDevice->abyOFDMAPwrTbl[ii] == 0)\r\npDevice->abyOFDMAPwrTbl[ii] = pDevice->byOFDMPwrA;\r\n}\r\nbyAntenna = pDevice->abyEEPROM[EEP_OFS_ANTENNA];\r\nif (byAntenna & EEP_ANTINV)\r\npDevice->bTxRxAntInv = true;\r\nelse\r\npDevice->bTxRxAntInv = false;\r\nbyAntenna &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (byAntenna == 0)\r\nbyAntenna = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (byAntenna == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {\r\npDevice->byAntennaCount = 2;\r\npDevice->byTxAntennaMode = ANT_B;\r\npDevice->dwTxAntennaSel = 1;\r\npDevice->dwRxAntennaSel = 1;\r\nif (pDevice->bTxRxAntInv == true)\r\npDevice->byRxAntennaMode = ANT_A;\r\nelse\r\npDevice->byRxAntennaMode = ANT_B;\r\nif (pDevice->bDiversityRegCtlON)\r\npDevice->bDiversityEnable = true;\r\nelse\r\npDevice->bDiversityEnable = false;\r\n} else {\r\npDevice->bDiversityEnable = false;\r\npDevice->byAntennaCount = 1;\r\npDevice->dwTxAntennaSel = 0;\r\npDevice->dwRxAntennaSel = 0;\r\nif (byAntenna & EEP_ANTENNA_AUX) {\r\npDevice->byTxAntennaMode = ANT_A;\r\nif (pDevice->bTxRxAntInv == true)\r\npDevice->byRxAntennaMode = ANT_B;\r\nelse\r\npDevice->byRxAntennaMode = ANT_A;\r\n} else {\r\npDevice->byTxAntennaMode = ANT_B;\r\nif (pDevice->bTxRxAntInv == true)\r\npDevice->byRxAntennaMode = ANT_A;\r\nelse\r\npDevice->byRxAntennaMode = ANT_B;\r\n}\r\n}\r\npDevice->ulDiversityNValue = 100*255;\r\npDevice->ulDiversityMValue = 100*16;\r\npDevice->byTMax = 1;\r\npDevice->byTMax2 = 4;\r\npDevice->ulSQ3TH = 0;\r\npDevice->byTMax3 = 64;\r\npDevice->byAutoFBCtrl = AUTO_FB_0;\r\npDevice->uScanTime = WLAN_SCAN_MINITIME;\r\npDevice->eConfigPHYMode = PHY_TYPE_AUTO;\r\npDevice->byBBType = BB_TYPE_11G;\r\npDevice->ulTxPower = 25;\r\npDevice->byMinChannel = 1;\r\npDevice->byMaxChannel = CB_MAX_CHANNEL;\r\npDevice->byRFType = sInitRsp.byRFType;\r\nif ((pDevice->byRFType & RF_EMU) != 0) {\r\npDevice->byRevId = 0x80;\r\n}\r\nif (pDevice->byRFType == RF_VT3226D0) {\r\nif((pDevice->abyEEPROM[EEP_OFS_MAJOR_VER] == 0x1) &&\r\n(pDevice->abyEEPROM[EEP_OFS_MINOR_VER] >= 0x4)) {\r\nbyCalibTXIQ = pDevice->abyEEPROM[EEP_OFS_CALIB_TX_IQ];\r\nbyCalibTXDC = pDevice->abyEEPROM[EEP_OFS_CALIB_TX_DC];\r\nbyCalibRXIQ = pDevice->abyEEPROM[EEP_OFS_CALIB_RX_IQ];\r\nif( (byCalibTXIQ || byCalibTXDC || byCalibRXIQ) ) {\r\nControlvWriteByte(pDevice,\r\nMESSAGE_REQUEST_BBREG,\r\n0xFF,\r\n0x03);\r\nControlvWriteByte(pDevice,\r\nMESSAGE_REQUEST_BBREG,\r\n0xFB,\r\nbyCalibTXIQ);\r\nControlvWriteByte(pDevice,\r\nMESSAGE_REQUEST_BBREG,\r\n0xFC,\r\nbyCalibTXDC);\r\nControlvWriteByte(pDevice,\r\nMESSAGE_REQUEST_BBREG,\r\n0xFD,\r\nbyCalibRXIQ);\r\n} else {\r\nControlvWriteByte(pDevice,\r\nMESSAGE_REQUEST_BBREG,\r\n0xFF,\r\n0x0);\r\n}\r\n}\r\n}\r\npMgmt->eScanType = WMAC_SCAN_PASSIVE;\r\npMgmt->uCurrChannel = pDevice->uChannel;\r\npMgmt->uIBSSChannel = pDevice->uChannel;\r\nCARDbSetMediaChannel(pDevice, pMgmt->uCurrChannel);\r\nmemcpy(pDevice->abyPermanentNetAddr,&(sInitRsp.byNetAddr[0]),6);\r\nmemcpy(pDevice->abyCurrentNetAddr,\r\npDevice->abyPermanentNetAddr,\r\nETH_ALEN);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Network address = %pM\n",\r\npDevice->abyCurrentNetAddr);\r\n}\r\nif (pDevice->byBBType == BB_TYPE_11A) {\r\nCARDbAddBasicRate(pDevice, RATE_6M);\r\npDevice->bShortSlotTime = true;\r\n} else {\r\nCARDbAddBasicRate(pDevice, RATE_1M);\r\npDevice->bShortSlotTime = false;\r\n}\r\nBBvSetShortSlotTime(pDevice);\r\nCARDvSetBSSMode(pDevice);\r\nif (pDevice->bUpdateBBVGA) {\r\npDevice->byBBVGACurrent = pDevice->abyBBVGA[0];\r\npDevice->byBBVGANew = pDevice->byBBVGACurrent;\r\nBBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);\r\n}\r\npDevice->byRadioCtl = pDevice->abyEEPROM[EEP_OFS_RADIOCTL];\r\npDevice->bHWRadioOff = false;\r\nif ( (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) != 0 ) {\r\nntStatus = CONTROLnsRequestIn(pDevice,\r\nMESSAGE_TYPE_READ,\r\nMAC_REG_GPIOCTL1,\r\nMESSAGE_REQUEST_MACREG,\r\n1,\r\n&byTmp);\r\nif ( ntStatus != STATUS_SUCCESS ) {\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn false;\r\n}\r\nif ( (byTmp & GPIO3_DATA) == 0 ) {\r\npDevice->bHWRadioOff = true;\r\nMACvRegBitsOn(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);\r\n} else {\r\nMACvRegBitsOff(pDevice,MAC_REG_GPIOCTL1,GPIO3_INTMD);\r\npDevice->bHWRadioOff = false;\r\n}\r\n}\r\nControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_TMLEN,0x38);\r\nControlvMaskByte(pDevice,MESSAGE_REQUEST_MACREG,MAC_REG_PAPEDELAY,LEDSTS_STS,LEDSTS_SLOW);\r\nMACvRegBitsOn(pDevice,MAC_REG_GPIOCTL0,0x01);\r\nif ((pDevice->bHWRadioOff == true) || (pDevice->bRadioControlOff == true)) {\r\nCARDbRadioPowerOff(pDevice);\r\n} else {\r\nCARDbRadioPowerOn(pDevice);\r\n}\r\nspin_unlock_irq(&pDevice->lock);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"<----INIbInitAdapter Exit\n");\r\nreturn true;\r\n}\r\nstatic int vt6656_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct vnt_private *device = usb_get_intfdata(intf);\r\nif (!device || !device->dev)\r\nreturn -ENODEV;\r\nif (device->flags & DEVICE_FLAGS_OPENED)\r\ndevice_close(device->dev);\r\nreturn 0;\r\n}\r\nstatic int vt6656_resume(struct usb_interface *intf)\r\n{\r\nstruct vnt_private *device = usb_get_intfdata(intf);\r\nif (!device || !device->dev)\r\nreturn -ENODEV;\r\nif (!(device->flags & DEVICE_FLAGS_OPENED))\r\ndevice_open(device->dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nvt6656_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nu8 fake_mac[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nint rc = 0;\r\nstruct net_device *netdev = NULL;\r\nstruct vnt_private *pDevice;\r\nprintk(KERN_NOTICE "%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);\r\nprintk(KERN_NOTICE "Copyright (c) 2004 VIA Networking Technologies, Inc.\n");\r\nudev = usb_get_dev(udev);\r\nnetdev = alloc_etherdev(sizeof(struct vnt_private));\r\nif (!netdev) {\r\nprintk(KERN_ERR DEVICE_NAME ": allocate net device failed\n");\r\nrc = -ENOMEM;\r\ngoto err_nomem;\r\n}\r\npDevice = netdev_priv(netdev);\r\nmemset(pDevice, 0, sizeof(struct vnt_private));\r\npDevice->dev = netdev;\r\npDevice->usb = udev;\r\ndevice_set_options(pDevice);\r\nspin_lock_init(&pDevice->lock);\r\npDevice->tx_80211 = device_dma0_tx_80211;\r\npDevice->vnt_mgmt.pAdapter = (void *) pDevice;\r\nnetdev->netdev_ops = &device_netdev_ops;\r\nnetdev->wireless_handlers =\r\n(struct iw_handler_def *) &iwctl_handler_def;\r\nusb_set_intfdata(intf, pDevice);\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nmemcpy(pDevice->dev->dev_addr, fake_mac, ETH_ALEN);\r\nrc = register_netdev(netdev);\r\nif (rc) {\r\nprintk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");\r\ngoto err_netdev;\r\n}\r\nusb_device_reset(pDevice);\r\nreturn 0;\r\nerr_netdev:\r\nfree_netdev(netdev);\r\nerr_nomem:\r\nusb_put_dev(udev);\r\nreturn rc;\r\n}\r\nstatic void device_free_tx_bufs(struct vnt_private *pDevice)\r\n{\r\nPUSB_SEND_CONTEXT pTxContext;\r\nint ii;\r\nfor (ii = 0; ii < pDevice->cbTD; ii++) {\r\npTxContext = pDevice->apTD[ii];\r\nif (pTxContext->pUrb) {\r\nusb_kill_urb(pTxContext->pUrb);\r\nusb_free_urb(pTxContext->pUrb);\r\n}\r\nkfree(pTxContext);\r\n}\r\nreturn;\r\n}\r\nstatic void device_free_rx_bufs(struct vnt_private *pDevice)\r\n{\r\nPRCB pRCB;\r\nint ii;\r\nfor (ii = 0; ii < pDevice->cbRD; ii++) {\r\npRCB = pDevice->apRCB[ii];\r\nif (pRCB->pUrb) {\r\nusb_kill_urb(pRCB->pUrb);\r\nusb_free_urb(pRCB->pUrb);\r\n}\r\nif (pRCB->skb)\r\ndev_kfree_skb(pRCB->skb);\r\n}\r\nkfree(pDevice->pRCBMem);\r\nreturn;\r\n}\r\nstatic void usb_device_reset(struct vnt_private *pDevice)\r\n{\r\nint status;\r\nstatus = usb_reset_device(pDevice->usb);\r\nif (status)\r\nprintk("usb_device_reset fail status=%d\n",status);\r\nreturn ;\r\n}\r\nstatic void device_free_int_bufs(struct vnt_private *pDevice)\r\n{\r\nkfree(pDevice->intBuf.pDataBuf);\r\nreturn;\r\n}\r\nstatic bool device_alloc_bufs(struct vnt_private *pDevice)\r\n{\r\nPUSB_SEND_CONTEXT pTxContext;\r\nPRCB pRCB;\r\nint ii;\r\nfor (ii = 0; ii < pDevice->cbTD; ii++) {\r\npTxContext = kmalloc(sizeof(USB_SEND_CONTEXT), GFP_KERNEL);\r\nif (pTxContext == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate tx usb context failed\n", pDevice->dev->name);\r\ngoto free_tx;\r\n}\r\npDevice->apTD[ii] = pTxContext;\r\npTxContext->pDevice = (void *) pDevice;\r\npTxContext->pUrb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (pTxContext->pUrb == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "alloc tx urb failed\n");\r\ngoto free_tx;\r\n}\r\npTxContext->bBoolInUse = false;\r\n}\r\npDevice->pRCBMem = kzalloc((sizeof(RCB) * pDevice->cbRD), GFP_KERNEL);\r\nif (pDevice->pRCBMem == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : alloc rx usb context failed\n", pDevice->dev->name);\r\ngoto free_tx;\r\n}\r\npDevice->FirstRecvFreeList = NULL;\r\npDevice->LastRecvFreeList = NULL;\r\npDevice->FirstRecvMngList = NULL;\r\npDevice->LastRecvMngList = NULL;\r\npDevice->NumRecvFreeList = 0;\r\npRCB = (PRCB) pDevice->pRCBMem;\r\nfor (ii = 0; ii < pDevice->cbRD; ii++) {\r\npDevice->apRCB[ii] = pRCB;\r\npRCB->pDevice = (void *) pDevice;\r\npRCB->pUrb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (pRCB->pUrb == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to alloc rx urb\n");\r\ngoto free_rx_tx;\r\n}\r\npRCB->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (pRCB->skb == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR" Failed to alloc rx skb\n");\r\ngoto free_rx_tx;\r\n}\r\npRCB->skb->dev = pDevice->dev;\r\npRCB->bBoolInUse = false;\r\nEnqueueRCB(pDevice->FirstRecvFreeList, pDevice->LastRecvFreeList, pRCB);\r\npDevice->NumRecvFreeList++;\r\npRCB++;\r\n}\r\npDevice->pControlURB = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (pDevice->pControlURB == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc control urb\n");\r\ngoto free_rx_tx;\r\n}\r\npDevice->pInterruptURB = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (pDevice->pInterruptURB == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc int urb\n");\r\nusb_free_urb(pDevice->pControlURB);\r\ngoto free_rx_tx;\r\n}\r\npDevice->intBuf.pDataBuf = kmalloc(MAX_INTERRUPT_SIZE, GFP_KERNEL);\r\nif (pDevice->intBuf.pDataBuf == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR"Failed to alloc int buf\n");\r\nusb_free_urb(pDevice->pControlURB);\r\nusb_free_urb(pDevice->pInterruptURB);\r\ngoto free_rx_tx;\r\n}\r\nreturn true;\r\nfree_rx_tx:\r\ndevice_free_rx_bufs(pDevice);\r\nfree_tx:\r\ndevice_free_tx_bufs(pDevice);\r\nreturn false;\r\n}\r\nstatic bool device_init_defrag_cb(struct vnt_private *pDevice)\r\n{\r\nint i;\r\nPSDeFragControlBlock pDeF;\r\nfor (i = 0; i < CB_MAX_RX_FRAG; i++) {\r\npDeF = &(pDevice->sRxDFCB[i]);\r\nif (!device_alloc_frag_buf(pDevice, pDeF)) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",\r\npDevice->dev->name);\r\ngoto free_frag;\r\n}\r\n}\r\npDevice->cbDFCB = CB_MAX_RX_FRAG;\r\npDevice->cbFreeDFCB = pDevice->cbDFCB;\r\nreturn true;\r\nfree_frag:\r\ndevice_free_frag_bufs(pDevice);\r\nreturn false;\r\n}\r\nstatic void device_free_frag_bufs(struct vnt_private *pDevice)\r\n{\r\nPSDeFragControlBlock pDeF;\r\nint i;\r\nfor (i = 0; i < CB_MAX_RX_FRAG; i++) {\r\npDeF = &(pDevice->sRxDFCB[i]);\r\nif (pDeF->skb)\r\ndev_kfree_skb(pDeF->skb);\r\n}\r\n}\r\nint device_alloc_frag_buf(struct vnt_private *pDevice,\r\nPSDeFragControlBlock pDeF)\r\n{\r\npDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (pDeF->skb == NULL)\r\nreturn false;\r\nASSERT(pDeF->skb);\r\npDeF->skb->dev = pDevice->dev;\r\nreturn true;\r\n}\r\nstatic int device_open(struct net_device *dev)\r\n{\r\nstruct vnt_private *pDevice = netdev_priv(dev);\r\npDevice->fWPA_Authened = false;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " device_open...\n");\r\npDevice->rx_buf_sz = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;\r\nif (device_alloc_bufs(pDevice) == false) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " device_alloc_bufs fail... \n");\r\nreturn -ENOMEM;\r\n}\r\nif (device_init_defrag_cb(pDevice)== false) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Initial defragment cb fail \n");\r\ngoto free_rx_tx;\r\n}\r\nMP_CLEAR_FLAG(pDevice, fMP_DISCONNECTED);\r\nMP_CLEAR_FLAG(pDevice, fMP_CONTROL_READS);\r\nMP_CLEAR_FLAG(pDevice, fMP_CONTROL_WRITES);\r\nMP_SET_FLAG(pDevice, fMP_POST_READS);\r\nMP_SET_FLAG(pDevice, fMP_POST_WRITES);\r\nRead_config_file(pDevice);\r\nif (device_init_registers(pDevice, DEVICE_INIT_COLD) == false) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " init register fail\n");\r\ngoto free_all;\r\n}\r\ndevice_set_multi(pDevice->dev);\r\nKeyvInitTable(pDevice,&pDevice->sKey);\r\nmemcpy(pDevice->vnt_mgmt.abyMACAddr,\r\npDevice->abyCurrentNetAddr, ETH_ALEN);\r\nmemcpy(pDevice->dev->dev_addr, pDevice->abyCurrentNetAddr, ETH_ALEN);\r\npDevice->bStopTx0Pkt = false;\r\npDevice->bStopDataPkt = false;\r\npDevice->bRoaming = false;\r\npDevice->bIsRoaming = false;\r\npDevice->bEnableRoaming = false;\r\nif (pDevice->bDiversityRegCtlON) {\r\ndevice_init_diversity_timer(pDevice);\r\n}\r\nvMgrObjectInit(pDevice);\r\ntasklet_init(&pDevice->RxMngWorkItem, (void *)RXvMngWorkItem, (unsigned long)pDevice);\r\ntasklet_init(&pDevice->ReadWorkItem, (void *)RXvWorkItem, (unsigned long)pDevice);\r\ntasklet_init(&pDevice->EventWorkItem, (void *)INTvWorkItem, (unsigned long)pDevice);\r\nadd_timer(&pDevice->vnt_mgmt.sTimerSecondCallback);\r\npDevice->int_interval = 100;\r\npDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;\r\npDevice->bIsRxWorkItemQueued = true;\r\npDevice->fKillEventPollingThread = false;\r\npDevice->bEventAvailable = false;\r\npDevice->bWPADEVUp = false;\r\npDevice->bwextstep0 = false;\r\npDevice->bwextstep1 = false;\r\npDevice->bwextstep2 = false;\r\npDevice->bwextstep3 = false;\r\npDevice->bWPASuppWextEnabled = false;\r\npDevice->byReAssocCount = 0;\r\nRXvWorkItem(pDevice);\r\nINTvWorkItem(pDevice);\r\nif ((pDevice->bEncryptionEnable == true) && (pDevice->bTransmitKey == true)) {\r\nspin_lock_irq(&pDevice->lock);\r\nKeybSetDefaultKey( pDevice,\r\n&(pDevice->sKey),\r\npDevice->byKeyIndex | (1 << 31),\r\npDevice->uKeyLength,\r\nNULL,\r\npDevice->abyKey,\r\nKEY_CTL_WEP\r\n);\r\nspin_unlock_irq(&pDevice->lock);\r\npDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;\r\n}\r\nif (pDevice->vnt_mgmt.eConfigMode == WMAC_CONFIG_AP)\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_RUN_AP, NULL);\r\nelse\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, NULL);\r\nnetif_stop_queue(pDevice->dev);\r\npDevice->flags |= DEVICE_FLAGS_OPENED;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success..\n");\r\nreturn 0;\r\nfree_all:\r\ndevice_free_frag_bufs(pDevice);\r\nfree_rx_tx:\r\ndevice_free_rx_bufs(pDevice);\r\ndevice_free_tx_bufs(pDevice);\r\ndevice_free_int_bufs(pDevice);\r\nusb_kill_urb(pDevice->pControlURB);\r\nusb_kill_urb(pDevice->pInterruptURB);\r\nusb_free_urb(pDevice->pControlURB);\r\nusb_free_urb(pDevice->pInterruptURB);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open fail.. \n");\r\nreturn -ENOMEM;\r\n}\r\nstatic int device_close(struct net_device *dev)\r\n{\r\nstruct vnt_private *pDevice = netdev_priv(dev);\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nint uu;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close1\n");\r\nif (pDevice == NULL)\r\nreturn -ENODEV;\r\nif (pDevice->bLinkPass) {\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_DISASSOCIATE, NULL);\r\nmdelay(30);\r\n}\r\nmemset(pMgmt->abyDesireSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);\r\npMgmt->bShareKeyAlgorithm = false;\r\npDevice->bEncryptionEnable = false;\r\npDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;\r\nspin_lock_irq(&pDevice->lock);\r\nfor (uu = 0; uu < MAX_KEY_TABLE; uu++)\r\nMACvDisableKeyEntry(pDevice,uu);\r\nspin_unlock_irq(&pDevice->lock);\r\nif ((pDevice->flags & DEVICE_FLAGS_UNPLUG) == false) {\r\nMACbShutdown(pDevice);\r\n}\r\nnetif_stop_queue(pDevice->dev);\r\nMP_SET_FLAG(pDevice, fMP_DISCONNECTED);\r\nMP_CLEAR_FLAG(pDevice, fMP_POST_WRITES);\r\nMP_CLEAR_FLAG(pDevice, fMP_POST_READS);\r\npDevice->fKillEventPollingThread = true;\r\ndel_timer(&pDevice->sTimerCommand);\r\ndel_timer(&pMgmt->sTimerSecondCallback);\r\ndel_timer(&pDevice->sTimerTxData);\r\nif (pDevice->bDiversityRegCtlON) {\r\ndel_timer(&pDevice->TimerSQ3Tmax1);\r\ndel_timer(&pDevice->TimerSQ3Tmax2);\r\ndel_timer(&pDevice->TimerSQ3Tmax3);\r\n}\r\ntasklet_kill(&pDevice->RxMngWorkItem);\r\ntasklet_kill(&pDevice->ReadWorkItem);\r\ntasklet_kill(&pDevice->EventWorkItem);\r\npDevice->bRoaming = false;\r\npDevice->bIsRoaming = false;\r\npDevice->bEnableRoaming = false;\r\npDevice->bCmdRunning = false;\r\npDevice->bLinkPass = false;\r\nmemset(pMgmt->abyCurrBSSID, 0, 6);\r\npMgmt->eCurrState = WMAC_STATE_IDLE;\r\ndevice_free_tx_bufs(pDevice);\r\ndevice_free_rx_bufs(pDevice);\r\ndevice_free_int_bufs(pDevice);\r\ndevice_free_frag_bufs(pDevice);\r\nusb_kill_urb(pDevice->pControlURB);\r\nusb_kill_urb(pDevice->pInterruptURB);\r\nusb_free_urb(pDevice->pControlURB);\r\nusb_free_urb(pDevice->pInterruptURB);\r\nBSSvClearNodeDBTable(pDevice, 0);\r\npDevice->flags &=(~DEVICE_FLAGS_OPENED);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close2 \n");\r\nreturn 0;\r\n}\r\nstatic void vt6656_disconnect(struct usb_interface *intf)\r\n{\r\nstruct vnt_private *device = usb_get_intfdata(intf);\r\nif (!device)\r\nreturn;\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(interface_to_usbdev(intf));\r\ndevice->flags |= DEVICE_FLAGS_UNPLUG;\r\nif (device->dev) {\r\nunregister_netdev(device->dev);\r\nfree_netdev(device->dev);\r\n}\r\n}\r\nstatic int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct vnt_private *pDevice = netdev_priv(dev);\r\nspin_lock_irq(&pDevice->lock);\r\nif (unlikely(pDevice->bStopTx0Pkt))\r\ndev_kfree_skb_irq(skb);\r\nelse\r\nvDMA0_tx_80211(pDevice, skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int device_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct vnt_private *pDevice = netdev_priv(dev);\r\nstruct net_device_stats *stats = &pDevice->stats;\r\nspin_lock_irq(&pDevice->lock);\r\nnetif_stop_queue(dev);\r\nif (!pDevice->bLinkPass) {\r\ndev_kfree_skb_irq(skb);\r\ngoto out;\r\n}\r\nif (pDevice->bStopDataPkt) {\r\ndev_kfree_skb_irq(skb);\r\nstats->tx_dropped++;\r\ngoto out;\r\n}\r\nif (nsDMA_tx_packet(pDevice, TYPE_AC0DMA, skb)) {\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nout:\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic inline u32 ether_crc(int length, unsigned char *data)\r\n{\r\nint crc = -1;\r\nwhile(--length >= 0) {\r\nunsigned char current_octet = *data++;\r\nint bit;\r\nfor (bit = 0; bit < 8; bit++, current_octet >>= 1) {\r\ncrc = (crc << 1) ^\r\n((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);\r\n}\r\n}\r\nreturn crc;\r\n}\r\nstatic unsigned char *kstrstr(const unsigned char *str1,\r\nconst unsigned char *str2) {\r\nint str1_len = strlen(str1);\r\nint str2_len = strlen(str2);\r\nwhile (str1_len >= str2_len) {\r\nstr1_len--;\r\nif(memcmp(str1,str2,str2_len)==0)\r\nreturn (unsigned char *) str1;\r\nstr1++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int Config_FileGetParameter(unsigned char *string,\r\nunsigned char *dest,\r\nunsigned char *source)\r\n{\r\nunsigned char buf1[100];\r\nunsigned char buf2[100];\r\nunsigned char *start_p = NULL, *end_p = NULL, *tmp_p = NULL;\r\nint ii;\r\nmemset(buf1,0,100);\r\nstrcat(buf1, string);\r\nstrcat(buf1, "=");\r\nsource+=strlen(buf1);\r\nstart_p = kstrstr(source,buf1);\r\nif (start_p == NULL)\r\nreturn false;\r\nfor (ii = 1; ; ii++) {\r\nif (memcmp(start_p - ii, "\n", 1) == 0)\r\nbreak;\r\nif (memcmp(start_p - ii, "#", 1) == 0)\r\nreturn false;\r\n}\r\nend_p = kstrstr(start_p,"\n");\r\nif (end_p == NULL) {\r\nend_p = start_p + strlen(start_p);\r\n}\r\nmemset(buf2,0,100);\r\nmemcpy(buf2, start_p, end_p-start_p);\r\nbuf2[end_p-start_p]='\0';\r\nstart_p = kstrstr(buf2,"=");\r\nif (start_p == NULL)\r\nreturn false;\r\nmemset(buf1,0,100);\r\nstrcpy(buf1,start_p+1);\r\ntmp_p = buf1;\r\nwhile(*tmp_p != 0x00) {\r\nif(*tmp_p==' ')\r\ntmp_p++;\r\nelse\r\nbreak;\r\n}\r\nmemcpy(dest,tmp_p,strlen(tmp_p));\r\nreturn true;\r\n}\r\nstatic unsigned char *Config_FileOperation(struct vnt_private *pDevice)\r\n{\r\nunsigned char *buffer = kmalloc(1024, GFP_KERNEL);\r\nstruct file *file;\r\nif (!buffer) {\r\nprintk("allocate mem for file fail?\n");\r\nreturn NULL;\r\n}\r\nfile = filp_open(CONFIG_PATH, O_RDONLY, 0);\r\nif (IS_ERR(file)) {\r\nkfree(buffer);\r\nprintk("Config_FileOperation file Not exist\n");\r\nreturn NULL;\r\n}\r\nif (kernel_read(file, 0, buffer, 1024) < 0) {\r\nprintk("read file error?\n");\r\nkfree(buffer);\r\nbuffer = NULL;\r\n}\r\nfput(file);\r\nreturn buffer;\r\n}\r\nstatic int Read_config_file(struct vnt_private *pDevice)\r\n{\r\nint result = 0;\r\nunsigned char tmpbuffer[100];\r\nunsigned char *buffer = NULL;\r\npDevice->config_file.ZoneType = -1;\r\npDevice->config_file.eAuthenMode = -1;\r\npDevice->config_file.eEncryptionStatus = -1;\r\nbuffer = Config_FileOperation(pDevice);\r\nif (buffer == NULL) {\r\nresult =-1;\r\nreturn result;\r\n}\r\n{\r\nmemset(tmpbuffer,0,sizeof(tmpbuffer));\r\nif(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer) ==true) {\r\nif(memcmp(tmpbuffer,"USA",3)==0) {\r\npDevice->config_file.ZoneType=ZoneType_USA;\r\n}\r\nelse if(memcmp(tmpbuffer,"JAPAN",5)==0) {\r\npDevice->config_file.ZoneType=ZoneType_Japan;\r\n}\r\nelse if(memcmp(tmpbuffer,"EUROPE",6)==0) {\r\npDevice->config_file.ZoneType=ZoneType_Europe;\r\n}\r\nelse {\r\nprintk("Unknown Zonetype[%s]?\n",tmpbuffer);\r\n}\r\n}\r\n}\r\n{\r\nmemset(tmpbuffer,0,sizeof(tmpbuffer));\r\nif(Config_FileGetParameter("AUTHENMODE",tmpbuffer,buffer)==true) {\r\npDevice->config_file.eAuthenMode = (int) simple_strtol(tmpbuffer, NULL, 10);\r\n}\r\nmemset(tmpbuffer,0,sizeof(tmpbuffer));\r\nif(Config_FileGetParameter("ENCRYPTIONMODE",tmpbuffer,buffer)==true) {\r\npDevice->config_file.eEncryptionStatus= (int) simple_strtol(tmpbuffer, NULL, 10);\r\n}\r\n}\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic void device_set_multi(struct net_device *dev)\r\n{\r\nstruct vnt_private *pDevice = netdev_priv(dev);\r\nstruct vnt_manager *pMgmt = &pDevice->vnt_mgmt;\r\nstruct netdev_hw_addr *ha;\r\nu32 mc_filter[2];\r\nint ii;\r\nu8 pbyData[8] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 byTmpMode = 0;\r\nint rc;\r\nspin_lock_irq(&pDevice->lock);\r\nrc = CONTROLnsRequestIn(pDevice,\r\nMESSAGE_TYPE_READ,\r\nMAC_REG_RCR,\r\nMESSAGE_REQUEST_MACREG,\r\n1,\r\n&byTmpMode\r\n);\r\nif (rc == 0) pDevice->byRxMode = byTmpMode;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode in= %x\n", pDevice->byRxMode);\r\nif (dev->flags & IFF_PROMISC) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);\r\n}\r\nelse if ((netdev_mc_count(dev) > pDevice->multicast_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nCONTROLnsRequestOut(pDevice,\r\nMESSAGE_TYPE_WRITE,\r\nMAC_REG_MAR0,\r\nMESSAGE_REQUEST_MACREG,\r\n8,\r\npbyData\r\n);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\n}\r\nelse {\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));\r\n}\r\nfor (ii = 0; ii < 4; ii++) {\r\nMACvWriteMultiAddr(pDevice, ii, *((u8 *)&mc_filter[0] + ii));\r\nMACvWriteMultiAddr(pDevice, ii+ 4, *((u8 *)&mc_filter[1] + ii));\r\n}\r\npDevice->byRxMode &= ~(RCR_UNICAST);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\n}\r\nif (pMgmt->eConfigMode == WMAC_CONFIG_AP) {\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\npDevice->byRxMode &= ~(RCR_UNICAST);\r\n}\r\nControlvWriteByte(pDevice, MESSAGE_REQUEST_MACREG, MAC_REG_RCR, pDevice->byRxMode);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode out= %x\n", pDevice->byRxMode);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\nstatic struct net_device_stats *device_get_stats(struct net_device *dev)\r\n{\r\nstruct vnt_private *pDevice = netdev_priv(dev);\r\nreturn &pDevice->stats;\r\n}\r\nstatic int device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct vnt_private *pDevice = netdev_priv(dev);\r\nstruct iwreq *wrq = (struct iwreq *) rq;\r\nint rc = 0;\r\nswitch (cmd) {\r\ncase IOCTL_CMD_HOSTAPD:\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED))\r\nrc = -EFAULT;\r\nrc = vt6656_hostap_ioctl(pDevice, &wrq->u.data);\r\nbreak;\r\ncase SIOCETHTOOL:\r\nreturn ethtool_ioctl(dev, (void *) rq->ifr_data);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ethtool_ioctl(struct net_device *dev, void *useraddr)\r\n{\r\nu32 ethcmd;\r\nif (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))\r\nreturn -EFAULT;\r\nswitch (ethcmd) {\r\ncase ETHTOOL_GDRVINFO: {\r\nstruct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};\r\nstrncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);\r\nstrncpy(info.version, DEVICE_VERSION, sizeof(info.version)-1);\r\nif (copy_to_user(useraddr, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EOPNOTSUPP;\r\n}
