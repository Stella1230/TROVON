static void hexdump(char *title, u8 *data, int len)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "%s: length = %d\n", title, len);\r\nfor (i = 0; i < len; i++) {\r\nprintk(KERN_DEBUG "%02x ", data[i]);\r\nif ((i & 0xf) == 0xf)\r\nprintk(KERN_DEBUG "\n");\r\n}\r\nprintk(KERN_DEBUG "\n");\r\n}\r\nstatic struct usb_tx *alloc_tx_struct(struct tx_cxt *tx)\r\n{\r\nstruct usb_tx *t = kzalloc(sizeof(*t), GFP_ATOMIC);\r\nif (!t)\r\nreturn NULL;\r\nt->urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nt->buf = kmalloc(TX_BUF_SIZE, GFP_ATOMIC);\r\nif (!t->urb || !t->buf) {\r\nusb_free_urb(t->urb);\r\nkfree(t->buf);\r\nkfree(t);\r\nreturn NULL;\r\n}\r\nt->tx_cxt = tx;\r\nreturn t;\r\n}\r\nstatic void free_tx_struct(struct usb_tx *t)\r\n{\r\nif (t) {\r\nusb_free_urb(t->urb);\r\nkfree(t->buf);\r\nkfree(t);\r\n}\r\n}\r\nstatic struct usb_rx *alloc_rx_struct(struct rx_cxt *rx)\r\n{\r\nstruct usb_rx *r = kzalloc(sizeof(*r), GFP_ATOMIC);\r\nif (!r)\r\nreturn NULL;\r\nr->urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nr->buf = kmalloc(RX_BUF_SIZE, GFP_ATOMIC);\r\nif (!r->urb || !r->buf) {\r\nusb_free_urb(r->urb);\r\nkfree(r->buf);\r\nkfree(r);\r\nreturn NULL;\r\n}\r\nr->rx_cxt = rx;\r\nreturn r;\r\n}\r\nstatic void free_rx_struct(struct usb_rx *r)\r\n{\r\nif (r) {\r\nusb_free_urb(r->urb);\r\nkfree(r->buf);\r\nkfree(r);\r\n}\r\n}\r\nstatic struct usb_tx *get_tx_struct(struct tx_cxt *tx, int *no_spc)\r\n{\r\nstruct usb_tx *t;\r\nif (list_empty(&tx->free_list)) {\r\n*no_spc = 1;\r\nreturn NULL;\r\n}\r\nt = list_entry(tx->free_list.next, struct usb_tx, list);\r\nlist_del(&t->list);\r\n*no_spc = list_empty(&tx->free_list) ? 1 : 0;\r\nreturn t;\r\n}\r\nstatic void put_tx_struct(struct tx_cxt *tx, struct usb_tx *t)\r\n{\r\nlist_add_tail(&t->list, &tx->free_list);\r\n}\r\nstatic struct usb_rx *get_rx_struct(struct rx_cxt *rx)\r\n{\r\nstruct usb_rx *r;\r\nif (list_empty(&rx->free_list)) {\r\nr = alloc_rx_struct(rx);\r\nif (r == NULL)\r\nreturn NULL;\r\nlist_add(&r->list, &rx->free_list);\r\n}\r\nr = list_entry(rx->free_list.next, struct usb_rx, list);\r\nlist_move_tail(&r->list, &rx->used_list);\r\nreturn r;\r\n}\r\nstatic void put_rx_struct(struct rx_cxt *rx, struct usb_rx *r)\r\n{\r\nlist_move(&r->list, &rx->free_list);\r\n}\r\nstatic int init_usb(struct usbwm_dev *udev)\r\n{\r\nint ret = 0, i;\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct rx_cxt *rx = &udev->rx;\r\nstruct usb_tx *t;\r\nstruct usb_rx *r;\r\nunsigned long flags;\r\nINIT_LIST_HEAD(&tx->free_list);\r\nINIT_LIST_HEAD(&tx->sdu_list);\r\nINIT_LIST_HEAD(&tx->hci_list);\r\n#if defined(CONFIG_WIMAX_GDM72XX_USB_PM) || defined(CONFIG_WIMAX_GDM72XX_K_MODE)\r\nINIT_LIST_HEAD(&tx->pending_list);\r\n#endif\r\nINIT_LIST_HEAD(&rx->free_list);\r\nINIT_LIST_HEAD(&rx->used_list);\r\nspin_lock_init(&tx->lock);\r\nspin_lock_init(&rx->lock);\r\nspin_lock_irqsave(&tx->lock, flags);\r\nfor (i = 0; i < MAX_NR_SDU_BUF; i++) {\r\nt = alloc_tx_struct(tx);\r\nif (t == NULL) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nlist_add(&t->list, &tx->free_list);\r\n}\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nr = alloc_rx_struct(rx);\r\nif (r == NULL) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nspin_lock_irqsave(&rx->lock, flags);\r\nlist_add(&r->list, &rx->free_list);\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nreturn ret;\r\nfail:\r\nrelease_usb(udev);\r\nreturn ret;\r\n}\r\nstatic void release_usb(struct usbwm_dev *udev)\r\n{\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct rx_cxt *rx = &udev->rx;\r\nstruct usb_tx *t, *t_next;\r\nstruct usb_rx *r, *r_next;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tx->lock, flags);\r\nlist_for_each_entry_safe(t, t_next, &tx->sdu_list, list) {\r\nlist_del(&t->list);\r\nfree_tx_struct(t);\r\n}\r\nlist_for_each_entry_safe(t, t_next, &tx->hci_list, list) {\r\nlist_del(&t->list);\r\nfree_tx_struct(t);\r\n}\r\nlist_for_each_entry_safe(t, t_next, &tx->free_list, list) {\r\nlist_del(&t->list);\r\nfree_tx_struct(t);\r\n}\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nspin_lock_irqsave(&rx->lock, flags);\r\nlist_for_each_entry_safe(r, r_next, &rx->free_list, list) {\r\nlist_del(&r->list);\r\nfree_rx_struct(r);\r\n}\r\nlist_for_each_entry_safe(r, r_next, &rx->used_list, list) {\r\nlist_del(&r->list);\r\nfree_rx_struct(r);\r\n}\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\n}\r\nstatic void __gdm_usb_send_complete(struct urb *urb)\r\n{\r\nstruct usb_tx *t = urb->context;\r\nstruct tx_cxt *tx = t->tx_cxt;\r\nu8 *pkt = t->buf;\r\nu16 cmd_evt;\r\nif (urb->status == -ECONNRESET)\r\nreturn;\r\nif (t->callback)\r\nt->callback(t->cb_data);\r\nlist_del(&t->list);\r\ncmd_evt = (pkt[0] << 8) | pkt[1];\r\nif (cmd_evt == WIMAX_TX_SDU)\r\nput_tx_struct(tx, t);\r\nelse\r\nfree_tx_struct(t);\r\n}\r\nstatic void gdm_usb_send_complete(struct urb *urb)\r\n{\r\nstruct usb_tx *t = urb->context;\r\nstruct tx_cxt *tx = t->tx_cxt;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tx->lock, flags);\r\n__gdm_usb_send_complete(urb);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nstatic int gdm_usb_send(void *priv_dev, void *data, int len,\r\nvoid (*cb)(void *data), void *cb_data)\r\n{\r\nstruct usbwm_dev *udev = priv_dev;\r\nstruct usb_device *usbdev = udev->usbdev;\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct usb_tx *t;\r\nint padding = udev->padding;\r\nint no_spc = 0, ret;\r\nu8 *pkt = data;\r\nu16 cmd_evt;\r\nunsigned long flags;\r\n#ifdef CONFIG_WIMAX_GDM72XX_K_MODE\r\nunsigned long flags2;\r\n#endif\r\nif (!udev->usbdev) {\r\ndev_err(&usbdev->dev, "%s: No such device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nBUG_ON(len > TX_BUF_SIZE - padding - 1);\r\nspin_lock_irqsave(&tx->lock, flags);\r\ncmd_evt = (pkt[0] << 8) | pkt[1];\r\nif (cmd_evt == WIMAX_TX_SDU) {\r\nt = get_tx_struct(tx, &no_spc);\r\nif (t == NULL) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn -ENOSPC;\r\n}\r\nlist_add_tail(&t->list, &tx->sdu_list);\r\n} else {\r\nt = alloc_tx_struct(tx);\r\nif (t == NULL) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nlist_add_tail(&t->list, &tx->hci_list);\r\n}\r\nmemcpy(t->buf + padding, data, len);\r\nt->callback = cb;\r\nt->cb_data = cb_data;\r\nif ((len % 512) == 0)\r\nlen++;\r\nusb_fill_bulk_urb(t->urb,\r\nusbdev,\r\nusb_sndbulkpipe(usbdev, 1),\r\nt->buf,\r\nlen + padding,\r\ngdm_usb_send_complete,\r\nt);\r\n#ifdef DEBUG\r\nhexdump("usb_send", t->buf, len + padding);\r\n#endif\r\n#ifdef CONFIG_WIMAX_GDM72XX_USB_PM\r\nif (usbdev->state & USB_STATE_SUSPENDED) {\r\nlist_add_tail(&t->p_list, &tx->pending_list);\r\nschedule_work(&udev->pm_ws);\r\ngoto out;\r\n}\r\n#endif\r\n#ifdef CONFIG_WIMAX_GDM72XX_K_MODE\r\nif (udev->bw_switch) {\r\nlist_add_tail(&t->p_list, &tx->pending_list);\r\ngoto out;\r\n} else if (cmd_evt == WIMAX_SCAN) {\r\nstruct rx_cxt *rx;\r\nstruct usb_rx *r;\r\nrx = &udev->rx;\r\nspin_lock_irqsave(&rx->lock, flags2);\r\nlist_for_each_entry(r, &rx->used_list, list)\r\nusb_unlink_urb(r->urb);\r\nspin_unlock_irqrestore(&rx->lock, flags2);\r\nudev->bw_switch = 1;\r\nspin_lock_irqsave(&k_lock, flags2);\r\nlist_add_tail(&udev->list, &k_list);\r\nspin_unlock_irqrestore(&k_lock, flags2);\r\nwake_up(&k_wait);\r\n}\r\n#endif\r\nret = usb_submit_urb(t->urb, GFP_ATOMIC);\r\nif (ret)\r\ngoto send_fail;\r\n#ifdef CONFIG_WIMAX_GDM72XX_USB_PM\r\nusb_mark_last_busy(usbdev);\r\n#endif\r\n#if defined(CONFIG_WIMAX_GDM72XX_USB_PM) || defined(CONFIG_WIMAX_GDM72XX_K_MODE)\r\nout:\r\n#endif\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nif (no_spc)\r\nreturn -ENOSPC;\r\nreturn 0;\r\nsend_fail:\r\nt->callback = NULL;\r\n__gdm_usb_send_complete(t->urb);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void gdm_usb_rcv_complete(struct urb *urb)\r\n{\r\nstruct usb_rx *r = urb->context;\r\nstruct rx_cxt *rx = r->rx_cxt;\r\nstruct usbwm_dev *udev = container_of(r->rx_cxt, struct usbwm_dev, rx);\r\nstruct tx_cxt *tx = &udev->tx;\r\nstruct usb_tx *t;\r\nu16 cmd_evt;\r\nunsigned long flags, flags2;\r\n#ifdef CONFIG_WIMAX_GDM72XX_USB_PM\r\nstruct usb_device *dev = urb->dev;\r\n#endif\r\nif (urb->status == -ECONNRESET)\r\nreturn;\r\nspin_lock_irqsave(&tx->lock, flags);\r\nif (!urb->status) {\r\ncmd_evt = (r->buf[0] << 8) | (r->buf[1]);\r\n#ifdef DEBUG\r\nhexdump("usb_receive", r->buf, urb->actual_length);\r\n#endif\r\nif (cmd_evt == WIMAX_SDU_TX_FLOW) {\r\nif (r->buf[4] == 0) {\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "WIMAX ==> STOP SDU TX\n");\r\n#endif\r\nlist_for_each_entry(t, &tx->sdu_list, list)\r\nusb_unlink_urb(t->urb);\r\n} else if (r->buf[4] == 1) {\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "WIMAX ==> START SDU TX\n");\r\n#endif\r\nlist_for_each_entry(t, &tx->sdu_list, list) {\r\nusb_submit_urb(t->urb, GFP_ATOMIC);\r\n}\r\nif (list_empty(&tx->free_list))\r\nurb->actual_length = 0;\r\n}\r\n}\r\n}\r\nif (!urb->status && r->callback)\r\nr->callback(r->cb_data, r->buf, urb->actual_length);\r\nspin_lock_irqsave(&rx->lock, flags2);\r\nput_rx_struct(rx, r);\r\nspin_unlock_irqrestore(&rx->lock, flags2);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n#ifdef CONFIG_WIMAX_GDM72XX_USB_PM\r\nusb_mark_last_busy(dev);\r\n#endif\r\n}\r\nstatic int gdm_usb_receive(void *priv_dev,\r\nvoid (*cb)(void *cb_data, void *data, int len),\r\nvoid *cb_data)\r\n{\r\nstruct usbwm_dev *udev = priv_dev;\r\nstruct usb_device *usbdev = udev->usbdev;\r\nstruct rx_cxt *rx = &udev->rx;\r\nstruct usb_rx *r;\r\nunsigned long flags;\r\nif (!udev->usbdev) {\r\ndev_err(&usbdev->dev, "%s: No such device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&rx->lock, flags);\r\nr = get_rx_struct(rx);\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nif (r == NULL)\r\nreturn -ENOMEM;\r\nr->callback = cb;\r\nr->cb_data = cb_data;\r\nusb_fill_bulk_urb(r->urb,\r\nusbdev,\r\nusb_rcvbulkpipe(usbdev, 0x82),\r\nr->buf,\r\nRX_BUF_SIZE,\r\ngdm_usb_rcv_complete,\r\nr);\r\nreturn usb_submit_urb(r->urb, GFP_ATOMIC);\r\n}\r\nstatic void do_pm_control(struct work_struct *work)\r\n{\r\nstruct usbwm_dev *udev = container_of(work, struct usbwm_dev, pm_ws);\r\nstruct tx_cxt *tx = &udev->tx;\r\nint ret;\r\nunsigned long flags;\r\nret = usb_autopm_get_interface(udev->intf);\r\nif (!ret)\r\nusb_autopm_put_interface(udev->intf);\r\nspin_lock_irqsave(&tx->lock, flags);\r\nif (!(udev->usbdev->state & USB_STATE_SUSPENDED)\r\n&& (!list_empty(&tx->hci_list) || !list_empty(&tx->sdu_list))) {\r\nstruct usb_tx *t, *temp;\r\nlist_for_each_entry_safe(t, temp, &tx->pending_list, p_list) {\r\nlist_del(&t->p_list);\r\nret = usb_submit_urb(t->urb, GFP_ATOMIC);\r\nif (ret) {\r\nt->callback = NULL;\r\n__gdm_usb_send_complete(t->urb);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nstatic int gdm_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret = 0;\r\nu8 bConfigurationValue;\r\nstruct phy_dev *phy_dev = NULL;\r\nstruct usbwm_dev *udev = NULL;\r\nu16 idVendor, idProduct, bcdDevice;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nusb_get_dev(usbdev);\r\nbConfigurationValue = usbdev->actconfig->desc.bConfigurationValue;\r\nidVendor = L2H(usbdev->descriptor.idVendor);\r\nidProduct = L2H(usbdev->descriptor.idProduct);\r\nbcdDevice = L2H(usbdev->descriptor.bcdDevice);\r\ndev_info(&intf->dev, "Found GDM USB VID = 0x%04x PID = 0x%04x...\n",\r\nidVendor, idProduct);\r\ndev_info(&intf->dev, "GCT WiMax driver version %s\n", DRIVER_VERSION);\r\nif (idProduct == EMERGENCY_PID) {\r\nret = usb_emergency(usbdev);\r\ngoto out;\r\n}\r\nif (bConfigurationValue == DOWNLOAD_CONF_VALUE ||\r\nidProduct & B_DOWNLOAD) {\r\nret = usb_boot(usbdev, bcdDevice);\r\ngoto out;\r\n}\r\nphy_dev = kzalloc(sizeof(*phy_dev), GFP_KERNEL);\r\nif (phy_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nudev = kzalloc(sizeof(*udev), GFP_KERNEL);\r\nif (udev == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (idProduct == 0x7205 || idProduct == 0x7206)\r\nudev->padding = GDM7205_PADDING;\r\nelse\r\nudev->padding = 0;\r\nphy_dev->priv_dev = (void *)udev;\r\nphy_dev->send_func = gdm_usb_send;\r\nphy_dev->rcv_func = gdm_usb_receive;\r\nret = init_usb(udev);\r\nif (ret < 0)\r\ngoto out;\r\nudev->usbdev = usbdev;\r\n#ifdef CONFIG_WIMAX_GDM72XX_USB_PM\r\nudev->intf = intf;\r\nintf->needs_remote_wakeup = 1;\r\ndevice_init_wakeup(&intf->dev, 1);\r\npm_runtime_set_autosuspend_delay(&usbdev->dev, 10 * 1000);\r\nINIT_WORK(&udev->pm_ws, do_pm_control);\r\n#endif\r\nret = register_wimax_device(phy_dev, &intf->dev);\r\nout:\r\nif (ret) {\r\nkfree(phy_dev);\r\nkfree(udev);\r\n} else {\r\nusb_set_intfdata(intf, phy_dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void gdm_usb_disconnect(struct usb_interface *intf)\r\n{\r\nu8 bConfigurationValue;\r\nstruct phy_dev *phy_dev;\r\nstruct usbwm_dev *udev;\r\nu16 idProduct;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nbConfigurationValue = usbdev->actconfig->desc.bConfigurationValue;\r\nphy_dev = usb_get_intfdata(intf);\r\nidProduct = L2H(usbdev->descriptor.idProduct);\r\nif (idProduct != EMERGENCY_PID &&\r\nbConfigurationValue != DOWNLOAD_CONF_VALUE &&\r\n(idProduct & B_DOWNLOAD) == 0) {\r\nudev = phy_dev->priv_dev;\r\nudev->usbdev = NULL;\r\nunregister_wimax_device(phy_dev);\r\nrelease_usb(udev);\r\nkfree(udev);\r\nkfree(phy_dev);\r\n}\r\nusb_put_dev(usbdev);\r\n}\r\nstatic int gdm_suspend(struct usb_interface *intf, pm_message_t pm_msg)\r\n{\r\nstruct phy_dev *phy_dev;\r\nstruct usbwm_dev *udev;\r\nstruct rx_cxt *rx;\r\nstruct usb_rx *r;\r\nunsigned long flags;\r\nphy_dev = usb_get_intfdata(intf);\r\nif (!phy_dev)\r\nreturn 0;\r\nudev = phy_dev->priv_dev;\r\nrx = &udev->rx;\r\nspin_lock_irqsave(&rx->lock, flags);\r\nlist_for_each_entry(r, &rx->used_list, list)\r\nusb_unlink_urb(r->urb);\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gdm_resume(struct usb_interface *intf)\r\n{\r\nstruct phy_dev *phy_dev;\r\nstruct usbwm_dev *udev;\r\nstruct rx_cxt *rx;\r\nstruct usb_rx *r;\r\nunsigned long flags;\r\nphy_dev = usb_get_intfdata(intf);\r\nif (!phy_dev)\r\nreturn 0;\r\nudev = phy_dev->priv_dev;\r\nrx = &udev->rx;\r\nspin_lock_irqsave(&rx->lock, flags);\r\nlist_for_each_entry(r, &rx->used_list, list)\r\nusb_submit_urb(r->urb, GFP_ATOMIC);\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int k_mode_thread(void *arg)\r\n{\r\nstruct usbwm_dev *udev;\r\nstruct tx_cxt *tx;\r\nstruct rx_cxt *rx;\r\nstruct usb_tx *t, *temp;\r\nstruct usb_rx *r;\r\nunsigned long flags, flags2, expire;\r\nint ret;\r\nwhile (!k_mode_stop) {\r\nspin_lock_irqsave(&k_lock, flags2);\r\nwhile (!list_empty(&k_list)) {\r\nudev = list_entry(k_list.next, struct usbwm_dev, list);\r\ntx = &udev->tx;\r\nrx = &udev->rx;\r\nlist_del(&udev->list);\r\nspin_unlock_irqrestore(&k_lock, flags2);\r\nexpire = jiffies + K_WAIT_TIME;\r\nwhile (jiffies < expire)\r\nschedule_timeout(K_WAIT_TIME);\r\nspin_lock_irqsave(&rx->lock, flags);\r\nlist_for_each_entry(r, &rx->used_list, list)\r\nusb_submit_urb(r->urb, GFP_ATOMIC);\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nspin_lock_irqsave(&tx->lock, flags);\r\nlist_for_each_entry_safe(t, temp, &tx->pending_list,\r\np_list) {\r\nlist_del(&t->p_list);\r\nret = usb_submit_urb(t->urb, GFP_ATOMIC);\r\nif (ret) {\r\nt->callback = NULL;\r\n__gdm_usb_send_complete(t->urb);\r\n}\r\n}\r\nudev->bw_switch = 0;\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nspin_lock_irqsave(&k_lock, flags2);\r\n}\r\nspin_unlock_irqrestore(&k_lock, flags2);\r\ninterruptible_sleep_on(&k_wait);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init usb_gdm_wimax_init(void)\r\n{\r\n#ifdef CONFIG_WIMAX_GDM72XX_K_MODE\r\nkthread_run(k_mode_thread, NULL, "k_mode_wimax");\r\n#endif\r\nreturn usb_register(&gdm_usb_driver);\r\n}\r\nstatic void __exit usb_gdm_wimax_exit(void)\r\n{\r\n#ifdef CONFIG_WIMAX_GDM72XX_K_MODE\r\nk_mode_stop = 1;\r\nwake_up(&k_wait);\r\n#endif\r\nusb_deregister(&gdm_usb_driver);\r\n}
