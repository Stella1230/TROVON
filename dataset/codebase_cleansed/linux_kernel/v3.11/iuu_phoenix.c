static int iuu_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct iuu_private *priv;\r\nint ret;\r\npriv = kzalloc(sizeof(struct iuu_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->buf = kzalloc(256, GFP_KERNEL);\r\nif (!priv->buf) {\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\npriv->writebuf = kzalloc(256, GFP_KERNEL);\r\nif (!priv->writebuf) {\r\nkfree(priv->buf);\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\npriv->vcc = vcc_default;\r\nspin_lock_init(&priv->lock);\r\nusb_set_serial_port_data(port, priv);\r\nret = iuu_create_sysfs_attrs(port);\r\nif (ret) {\r\nkfree(priv->writebuf);\r\nkfree(priv->buf);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iuu_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\niuu_remove_sysfs_attrs(port);\r\nkfree(priv->writebuf);\r\nkfree(priv->buf);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int iuu_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\ndev_dbg(&port->dev, "%s msg : SET = 0x%04x, CLEAR = 0x%04x\n",\r\n__func__, set, clear);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif ((set & TIOCM_RTS) && !(priv->tiostatus == TIOCM_RTS)) {\r\ndev_dbg(&port->dev, "%s TIOCMSET RESET called !!!\n", __func__);\r\npriv->reset = 1;\r\n}\r\nif (set & TIOCM_RTS)\r\npriv->tiostatus = TIOCM_RTS;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int iuu_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrc = priv->tiostatus;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void iuu_rxcmd(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nint result;\r\nint status = urb->status;\r\nif (status) {\r\ndev_dbg(&port->dev, "%s - status = %d\n", __func__, status);\r\nreturn;\r\n}\r\nmemset(port->write_urb->transfer_buffer, IUU_UART_RX, 1);\r\nusb_fill_bulk_urb(port->write_urb, port->serial->dev,\r\nusb_sndbulkpipe(port->serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, 1,\r\nread_rxcmd_callback, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\n}\r\nstatic int iuu_reset(struct usb_serial_port *port, u8 wt)\r\n{\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nint result;\r\nchar *buf_ptr = port->write_urb->transfer_buffer;\r\n*buf_ptr++ = IUU_RST_SET;\r\n*buf_ptr++ = IUU_DELAY_MS;\r\n*buf_ptr++ = wt;\r\n*buf_ptr = IUU_RST_CLEAR;\r\nusb_fill_bulk_urb(port->write_urb,\r\nport->serial->dev,\r\nusb_sndbulkpipe(port->serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, 4, iuu_rxcmd, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\npriv->reset = 0;\r\nreturn result;\r\n}\r\nstatic void iuu_update_status_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nu8 *st;\r\nint status = urb->status;\r\nif (status) {\r\ndev_dbg(&port->dev, "%s - status = %d\n", __func__, status);\r\nreturn;\r\n}\r\nst = urb->transfer_buffer;\r\ndev_dbg(&port->dev, "%s - enter\n", __func__);\r\nif (urb->actual_length == 1) {\r\nswitch (st[0]) {\r\ncase 0x1:\r\npriv->tiostatus = iuu_cardout;\r\nbreak;\r\ncase 0x0:\r\npriv->tiostatus = iuu_cardin;\r\nbreak;\r\ndefault:\r\npriv->tiostatus = iuu_cardin;\r\n}\r\n}\r\niuu_rxcmd(urb);\r\n}\r\nstatic void iuu_status_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nint result;\r\nint status = urb->status;\r\ndev_dbg(&port->dev, "%s - status = %d\n", __func__, status);\r\nusb_fill_bulk_urb(port->read_urb, port->serial->dev,\r\nusb_rcvbulkpipe(port->serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->read_urb->transfer_buffer, 256,\r\niuu_update_status_callback, port);\r\nresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\n}\r\nstatic int iuu_status(struct usb_serial_port *port)\r\n{\r\nint result;\r\nmemset(port->write_urb->transfer_buffer, IUU_GET_STATE_REGISTER, 1);\r\nusb_fill_bulk_urb(port->write_urb, port->serial->dev,\r\nusb_sndbulkpipe(port->serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, 1,\r\niuu_status_callback, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nreturn result;\r\n}\r\nstatic int bulk_immediate(struct usb_serial_port *port, u8 *buf, u8 count)\r\n{\r\nint status;\r\nstruct usb_serial *serial = port->serial;\r\nint actual = 0;\r\nstatus =\r\nusb_bulk_msg(serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport->bulk_out_endpointAddress), buf,\r\ncount, &actual, 1000);\r\nif (status != IUU_OPERATION_OK)\r\ndev_dbg(&port->dev, "%s - error = %2x\n", __func__, status);\r\nelse\r\ndev_dbg(&port->dev, "%s - write OK !\n", __func__);\r\nreturn status;\r\n}\r\nstatic int read_immediate(struct usb_serial_port *port, u8 *buf, u8 count)\r\n{\r\nint status;\r\nstruct usb_serial *serial = port->serial;\r\nint actual = 0;\r\nstatus =\r\nusb_bulk_msg(serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport->bulk_in_endpointAddress), buf,\r\ncount, &actual, 1000);\r\nif (status != IUU_OPERATION_OK)\r\ndev_dbg(&port->dev, "%s - error = %2x\n", __func__, status);\r\nelse\r\ndev_dbg(&port->dev, "%s - read OK !\n", __func__);\r\nreturn status;\r\n}\r\nstatic int iuu_led(struct usb_serial_port *port, unsigned int R,\r\nunsigned int G, unsigned int B, u8 f)\r\n{\r\nint status;\r\nu8 *buf;\r\nbuf = kmalloc(8, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = IUU_SET_LED;\r\nbuf[1] = R & 0xFF;\r\nbuf[2] = (R >> 8) & 0xFF;\r\nbuf[3] = G & 0xFF;\r\nbuf[4] = (G >> 8) & 0xFF;\r\nbuf[5] = B & 0xFF;\r\nbuf[6] = (B >> 8) & 0xFF;\r\nbuf[7] = f;\r\nstatus = bulk_immediate(port, buf, 8);\r\nkfree(buf);\r\nif (status != IUU_OPERATION_OK)\r\ndev_dbg(&port->dev, "%s - led error status = %2x\n", __func__, status);\r\nelse\r\ndev_dbg(&port->dev, "%s - led OK !\n", __func__);\r\nreturn IUU_OPERATION_OK;\r\n}\r\nstatic void iuu_rgbf_fill_buffer(u8 *buf, u8 r1, u8 r2, u8 g1, u8 g2, u8 b1,\r\nu8 b2, u8 freq)\r\n{\r\n*buf++ = IUU_SET_LED;\r\n*buf++ = r1;\r\n*buf++ = r2;\r\n*buf++ = g1;\r\n*buf++ = g2;\r\n*buf++ = b1;\r\n*buf++ = b2;\r\n*buf = freq;\r\n}\r\nstatic void iuu_led_activity_on(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nint result;\r\nchar *buf_ptr = port->write_urb->transfer_buffer;\r\n*buf_ptr++ = IUU_SET_LED;\r\nif (xmas == 1) {\r\nget_random_bytes(buf_ptr, 6);\r\n*(buf_ptr+7) = 1;\r\n} else {\r\niuu_rgbf_fill_buffer(buf_ptr, 255, 255, 0, 0, 0, 0, 255);\r\n}\r\nusb_fill_bulk_urb(port->write_urb, port->serial->dev,\r\nusb_sndbulkpipe(port->serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, 8 ,\r\niuu_rxcmd, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\n}\r\nstatic void iuu_led_activity_off(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nint result;\r\nchar *buf_ptr = port->write_urb->transfer_buffer;\r\nif (xmas == 1) {\r\niuu_rxcmd(urb);\r\nreturn;\r\n} else {\r\n*buf_ptr++ = IUU_SET_LED;\r\niuu_rgbf_fill_buffer(buf_ptr, 0, 0, 255, 255, 0, 0, 255);\r\n}\r\nusb_fill_bulk_urb(port->write_urb, port->serial->dev,\r\nusb_sndbulkpipe(port->serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, 8 ,\r\niuu_rxcmd, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\n}\r\nstatic int iuu_clk(struct usb_serial_port *port, int dwFrq)\r\n{\r\nint status;\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nint Count = 0;\r\nu8 FrqGenAdr = 0x69;\r\nu8 DIV = 0;\r\nu8 XDRV = 0;\r\nu8 PUMP = 0;\r\nu8 PBmsb = 0;\r\nu8 PBlsb = 0;\r\nu8 PO = 0;\r\nu8 Q = 0;\r\nunsigned int P = 0;\r\nunsigned int P2 = 0;\r\nint frq = (int)dwFrq;\r\nif (frq == 0) {\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x09;\r\npriv->buf[Count++] = 0x00;\r\nstatus = bulk_immediate(port, (u8 *) priv->buf, Count);\r\nif (status != 0) {\r\ndev_dbg(&port->dev, "%s - write error\n", __func__);\r\nreturn status;\r\n}\r\n} else if (frq == 3579000) {\r\nDIV = 100;\r\nP = 1193;\r\nQ = 40;\r\nXDRV = 0;\r\n} else if (frq == 3680000) {\r\nDIV = 105;\r\nP = 161;\r\nQ = 5;\r\nXDRV = 0;\r\n} else if (frq == 6000000) {\r\nDIV = 66;\r\nP = 66;\r\nQ = 2;\r\nXDRV = 0x28;\r\n} else {\r\nunsigned int result = 0;\r\nunsigned int tmp = 0;\r\nunsigned int check;\r\nunsigned int check2;\r\nchar found = 0x00;\r\nunsigned int lQ = 2;\r\nunsigned int lP = 2055;\r\nunsigned int lDiv = 4;\r\nfor (lQ = 2; lQ <= 47 && !found; lQ++)\r\nfor (lP = 2055; lP >= 8 && !found; lP--)\r\nfor (lDiv = 4; lDiv <= 127 && !found; lDiv++) {\r\ntmp = (12000000 / lDiv) * (lP / lQ);\r\nif (abs((int)(tmp - frq)) <\r\nabs((int)(frq - result))) {\r\ncheck2 = (12000000 / lQ);\r\nif (check2 < 250000)\r\ncontinue;\r\ncheck = (12000000 / lQ) * lP;\r\nif (check > 400000000)\r\ncontinue;\r\nif (check < 100000000)\r\ncontinue;\r\nif (lDiv < 4 || lDiv > 127)\r\ncontinue;\r\nresult = tmp;\r\nP = lP;\r\nDIV = lDiv;\r\nQ = lQ;\r\nif (result == frq)\r\nfound = 0x01;\r\n}\r\n}\r\n}\r\nP2 = ((P - PO) / 2) - 4;\r\nDIV = DIV;\r\nPUMP = 0x04;\r\nPBmsb = (P2 >> 8 & 0x03);\r\nPBlsb = P2 & 0xFF;\r\nPO = (P >> 10) & 0x01;\r\nQ = Q - 2;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x09;\r\npriv->buf[Count++] = 0x20;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x0C;\r\npriv->buf[Count++] = DIV;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x12;\r\npriv->buf[Count++] = XDRV;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x13;\r\npriv->buf[Count++] = 0x6B;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x40;\r\npriv->buf[Count++] = (0xC0 | ((PUMP & 0x07) << 2)) |\r\n(PBmsb & 0x03);\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x41;\r\npriv->buf[Count++] = PBlsb;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x42;\r\npriv->buf[Count++] = Q | (((PO & 0x01) << 7));\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x44;\r\npriv->buf[Count++] = (char)0xFF;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x45;\r\npriv->buf[Count++] = (char)0xFE;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x46;\r\npriv->buf[Count++] = 0x7F;\r\npriv->buf[Count++] = IUU_UART_WRITE_I2C;\r\npriv->buf[Count++] = FrqGenAdr << 1;\r\npriv->buf[Count++] = 0x47;\r\npriv->buf[Count++] = (char)0x84;\r\nstatus = bulk_immediate(port, (u8 *) priv->buf, Count);\r\nif (status != IUU_OPERATION_OK)\r\ndev_dbg(&port->dev, "%s - write error\n", __func__);\r\nreturn status;\r\n}\r\nstatic int iuu_uart_flush(struct usb_serial_port *port)\r\n{\r\nstruct device *dev = &port->dev;\r\nint i;\r\nint status;\r\nu8 rxcmd = IUU_UART_RX;\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nif (iuu_led(port, 0xF000, 0, 0, 0xFF) < 0)\r\nreturn -EIO;\r\nfor (i = 0; i < 2; i++) {\r\nstatus = bulk_immediate(port, &rxcmd, 1);\r\nif (status != IUU_OPERATION_OK) {\r\ndev_dbg(dev, "%s - uart_flush_write error\n", __func__);\r\nreturn status;\r\n}\r\nstatus = read_immediate(port, &priv->len, 1);\r\nif (status != IUU_OPERATION_OK) {\r\ndev_dbg(dev, "%s - uart_flush_read error\n", __func__);\r\nreturn status;\r\n}\r\nif (priv->len > 0) {\r\ndev_dbg(dev, "%s - uart_flush datalen is : %i\n", __func__, priv->len);\r\nstatus = read_immediate(port, priv->buf, priv->len);\r\nif (status != IUU_OPERATION_OK) {\r\ndev_dbg(dev, "%s - uart_flush_read error\n", __func__);\r\nreturn status;\r\n}\r\n}\r\n}\r\ndev_dbg(dev, "%s - uart_flush_read OK!\n", __func__);\r\niuu_led(port, 0, 0xF000, 0, 0xFF);\r\nreturn status;\r\n}\r\nstatic void read_buf_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nint status = urb->status;\r\nif (status) {\r\nif (status == -EPROTO) {\r\n}\r\nreturn;\r\n}\r\ndev_dbg(&port->dev, "%s - %i chars to write\n", __func__, urb->actual_length);\r\nif (data == NULL)\r\ndev_dbg(&port->dev, "%s - data is NULL !!!\n", __func__);\r\nif (urb->actual_length && data) {\r\ntty_insert_flip_string(&port->port, data, urb->actual_length);\r\ntty_flip_buffer_push(&port->port);\r\n}\r\niuu_led_activity_on(urb);\r\n}\r\nstatic int iuu_bulk_write(struct usb_serial_port *port)\r\n{\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nint result;\r\nint buf_len;\r\nchar *buf_ptr = port->write_urb->transfer_buffer;\r\nspin_lock_irqsave(&priv->lock, flags);\r\n*buf_ptr++ = IUU_UART_ESC;\r\n*buf_ptr++ = IUU_UART_TX;\r\n*buf_ptr++ = priv->writelen;\r\nmemcpy(buf_ptr, priv->writebuf, priv->writelen);\r\nbuf_len = priv->writelen;\r\npriv->writelen = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&port->dev, "%s - writing %i chars : %*ph\n", __func__,\r\nbuf_len, buf_len, buf_ptr);\r\nusb_fill_bulk_urb(port->write_urb, port->serial->dev,\r\nusb_sndbulkpipe(port->serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, buf_len + 3,\r\niuu_rxcmd, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nusb_serial_port_softint(port);\r\nreturn result;\r\n}\r\nstatic int iuu_read_buf(struct usb_serial_port *port, int len)\r\n{\r\nint result;\r\nusb_fill_bulk_urb(port->read_urb, port->serial->dev,\r\nusb_rcvbulkpipe(port->serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->read_urb->transfer_buffer, len,\r\nread_buf_callback, port);\r\nresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nreturn result;\r\n}\r\nstatic void iuu_uart_read_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nint status = urb->status;\r\nint error = 0;\r\nint len = 0;\r\nunsigned char *data = urb->transfer_buffer;\r\npriv->poll++;\r\nif (status) {\r\ndev_dbg(&port->dev, "%s - status = %d\n", __func__, status);\r\nreturn;\r\n}\r\nif (data == NULL)\r\ndev_dbg(&port->dev, "%s - data is NULL !!!\n", __func__);\r\nif (urb->actual_length == 1 && data != NULL)\r\nlen = (int) data[0];\r\nif (urb->actual_length > 1) {\r\ndev_dbg(&port->dev, "%s - urb->actual_length = %i\n", __func__,\r\nurb->actual_length);\r\nerror = 1;\r\nreturn;\r\n}\r\nif (len > 0 && error == 0) {\r\ndev_dbg(&port->dev, "%s - call read buf - len to read is %i\n",\r\n__func__, len);\r\nstatus = iuu_read_buf(port, len);\r\nreturn;\r\n}\r\nif (priv->poll > 99) {\r\nstatus = iuu_status(port);\r\npriv->poll = 0;\r\nreturn;\r\n}\r\nif (priv->reset == 1) {\r\nstatus = iuu_reset(port, 0xC);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->writelen > 0) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nstatus = iuu_bulk_write(port);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&port->dev, "%s - rxcmd recall\n", __func__);\r\niuu_led_activity_off(urb);\r\n}\r\nstatic int iuu_uart_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst u8 *buf, int count)\r\n{\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nif (count > 256)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nmemcpy(priv->writebuf + priv->writelen, buf, count);\r\npriv->writelen += count;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn count;\r\n}\r\nstatic void read_rxcmd_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nint result;\r\nint status = urb->status;\r\nif (status) {\r\nreturn;\r\n}\r\nusb_fill_bulk_urb(port->read_urb, port->serial->dev,\r\nusb_rcvbulkpipe(port->serial->dev,\r\nport->bulk_in_endpointAddress),\r\nport->read_urb->transfer_buffer, 256,\r\niuu_uart_read_callback, port);\r\nresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\ndev_dbg(&port->dev, "%s - submit result = %d\n", __func__, result);\r\n}\r\nstatic int iuu_uart_on(struct usb_serial_port *port)\r\n{\r\nint status;\r\nu8 *buf;\r\nbuf = kmalloc(sizeof(u8) * 4, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = IUU_UART_ENABLE;\r\nbuf[1] = (u8) ((IUU_BAUD_9600 >> 8) & 0x00FF);\r\nbuf[2] = (u8) (0x00FF & IUU_BAUD_9600);\r\nbuf[3] = (u8) (0x0F0 & IUU_ONE_STOP_BIT) | (0x07 & IUU_PARITY_EVEN);\r\nstatus = bulk_immediate(port, buf, 4);\r\nif (status != IUU_OPERATION_OK) {\r\ndev_dbg(&port->dev, "%s - uart_on error\n", __func__);\r\ngoto uart_enable_failed;\r\n}\r\nstatus = iuu_uart_flush(port);\r\nif (status != IUU_OPERATION_OK)\r\ndev_dbg(&port->dev, "%s - uart_flush error\n", __func__);\r\nuart_enable_failed:\r\nkfree(buf);\r\nreturn status;\r\n}\r\nstatic int iuu_uart_off(struct usb_serial_port *port)\r\n{\r\nint status;\r\nu8 *buf;\r\nbuf = kmalloc(1, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = IUU_UART_DISABLE;\r\nstatus = bulk_immediate(port, buf, 1);\r\nif (status != IUU_OPERATION_OK)\r\ndev_dbg(&port->dev, "%s - uart_off error\n", __func__);\r\nkfree(buf);\r\nreturn status;\r\n}\r\nstatic int iuu_uart_baud(struct usb_serial_port *port, u32 baud_base,\r\nu32 *actual, u8 parity)\r\n{\r\nint status;\r\nu32 baud;\r\nu8 *dataout;\r\nu8 DataCount = 0;\r\nu8 T1Frekvens = 0;\r\nu8 T1reload = 0;\r\nunsigned int T1FrekvensHZ = 0;\r\ndev_dbg(&port->dev, "%s - enter baud_base=%d\n", __func__, baud_base);\r\ndataout = kmalloc(sizeof(u8) * 5, GFP_KERNEL);\r\nif (!dataout)\r\nreturn -ENOMEM;\r\nbaud = baud_base;\r\nif (baud < 1200 || baud > 230400) {\r\nkfree(dataout);\r\nreturn IUU_INVALID_PARAMETER;\r\n}\r\nif (baud > 977) {\r\nT1Frekvens = 3;\r\nT1FrekvensHZ = 500000;\r\n}\r\nif (baud > 3906) {\r\nT1Frekvens = 2;\r\nT1FrekvensHZ = 2000000;\r\n}\r\nif (baud > 11718) {\r\nT1Frekvens = 1;\r\nT1FrekvensHZ = 6000000;\r\n}\r\nif (baud > 46875) {\r\nT1Frekvens = 0;\r\nT1FrekvensHZ = 24000000;\r\n}\r\nT1reload = 256 - (u8) (T1FrekvensHZ / (baud * 2));\r\ndataout[DataCount++] = IUU_UART_ESC;\r\ndataout[DataCount++] = IUU_UART_CHANGE;\r\ndataout[DataCount++] = T1Frekvens;\r\ndataout[DataCount++] = T1reload;\r\n*actual = (T1FrekvensHZ / (256 - T1reload)) / 2;\r\nswitch (parity & 0x0F) {\r\ncase IUU_PARITY_NONE:\r\ndataout[DataCount++] = 0x00;\r\nbreak;\r\ncase IUU_PARITY_EVEN:\r\ndataout[DataCount++] = 0x01;\r\nbreak;\r\ncase IUU_PARITY_ODD:\r\ndataout[DataCount++] = 0x02;\r\nbreak;\r\ncase IUU_PARITY_MARK:\r\ndataout[DataCount++] = 0x03;\r\nbreak;\r\ncase IUU_PARITY_SPACE:\r\ndataout[DataCount++] = 0x04;\r\nbreak;\r\ndefault:\r\nkfree(dataout);\r\nreturn IUU_INVALID_PARAMETER;\r\nbreak;\r\n}\r\nswitch (parity & 0xF0) {\r\ncase IUU_ONE_STOP_BIT:\r\ndataout[DataCount - 1] |= IUU_ONE_STOP_BIT;\r\nbreak;\r\ncase IUU_TWO_STOP_BITS:\r\ndataout[DataCount - 1] |= IUU_TWO_STOP_BITS;\r\nbreak;\r\ndefault:\r\nkfree(dataout);\r\nreturn IUU_INVALID_PARAMETER;\r\nbreak;\r\n}\r\nstatus = bulk_immediate(port, dataout, DataCount);\r\nif (status != IUU_OPERATION_OK)\r\ndev_dbg(&port->dev, "%s - uart_off error\n", __func__);\r\nkfree(dataout);\r\nreturn status;\r\n}\r\nstatic void iuu_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nconst u32 supported_mask = CMSPAR|PARENB|PARODD;\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nunsigned int cflag = tty->termios.c_cflag;\r\nint status;\r\nu32 actual;\r\nu32 parity;\r\nint csize = CS7;\r\nint baud;\r\nu32 newval = cflag & supported_mask;\r\nbaud = tty->termios.c_ospeed;\r\ndev_dbg(&port->dev, "%s - enter c_ospeed or baud=%d\n", __func__, baud);\r\nparity = 0;\r\nif (cflag & CMSPAR) {\r\nif (cflag & PARODD)\r\nparity |= IUU_PARITY_SPACE;\r\nelse\r\nparity |= IUU_PARITY_MARK;\r\n} else if (!(cflag & PARENB)) {\r\nparity |= IUU_PARITY_NONE;\r\ncsize = CS8;\r\n} else if (cflag & PARODD)\r\nparity |= IUU_PARITY_ODD;\r\nelse\r\nparity |= IUU_PARITY_EVEN;\r\nparity |= (cflag & CSTOPB ? IUU_TWO_STOP_BITS : IUU_ONE_STOP_BIT);\r\nstatus = iuu_uart_baud(port,\r\nbaud * priv->boost / 100,\r\n&actual, parity);\r\nif (old_termios)\r\ntty_termios_copy_hw(&tty->termios, old_termios);\r\nif (status != 0)\r\nreturn;\r\ntty_encode_baud_rate(tty, baud, baud);\r\ntty->termios.c_cflag &= ~(supported_mask|CSIZE);\r\ntty->termios.c_cflag |= newval | csize;\r\n}\r\nstatic void iuu_close(struct usb_serial_port *port)\r\n{\r\niuu_uart_off(port);\r\nusb_kill_urb(port->write_urb);\r\nusb_kill_urb(port->read_urb);\r\niuu_led(port, 0, 0, 0xF000, 0xFF);\r\n}\r\nstatic void iuu_init_termios(struct tty_struct *tty)\r\n{\r\ntty->termios = tty_std_termios;\r\ntty->termios.c_cflag = CLOCAL | CREAD | CS8 | B9600\r\n| TIOCM_CTS | CSTOPB | PARENB;\r\ntty->termios.c_ispeed = 9600;\r\ntty->termios.c_ospeed = 9600;\r\ntty->termios.c_lflag = 0;\r\ntty->termios.c_oflag = 0;\r\ntty->termios.c_iflag = 0;\r\n}\r\nstatic int iuu_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct device *dev = &port->dev;\r\nu8 *buf;\r\nint result;\r\nint baud;\r\nu32 actual;\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nbaud = tty->termios.c_ospeed;\r\ntty->termios.c_ispeed = baud;\r\ntty_encode_baud_rate(tty, baud, baud);\r\ndev_dbg(dev, "%s - baud %d\n", __func__, baud);\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nbuf = kmalloc(10, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\npriv->poll = 0;\r\n#define FISH(a, b, c, d) do { \\r\nresult = usb_control_msg(port->serial->dev, \\r\nusb_rcvctrlpipe(port->serial->dev, 0), \\r\nb, a, c, d, buf, 1, 1000); \\r\ndev_dbg(dev, "0x%x:0x%x:0x%x:0x%x %d - %x\n", a, b, c, d, result, \\r\nbuf[0]); } while (0);\r\n#define SOUP(a, b, c, d) do { \\r\nresult = usb_control_msg(port->serial->dev, \\r\nusb_sndctrlpipe(port->serial->dev, 0), \\r\nb, a, c, d, NULL, 0, 1000); \\r\ndev_dbg(dev, "0x%x:0x%x:0x%x:0x%x %d\n", a, b, c, d, result); } while (0)\r\nSOUP(0x03, 0x02, 0x02, 0x0);\r\nkfree(buf);\r\niuu_led(port, 0xF000, 0xF000, 0, 0xFF);\r\niuu_uart_on(port);\r\nif (boost < 100)\r\nboost = 100;\r\npriv->boost = boost;\r\npriv->baud = baud;\r\nswitch (clockmode) {\r\ncase 2:\r\npriv->clk = IUU_CLK_3680000;\r\niuu_clk(port, IUU_CLK_3680000 * boost / 100);\r\nresult =\r\niuu_uart_baud(port, baud * boost / 100, &actual,\r\nIUU_PARITY_EVEN);\r\nbreak;\r\ncase 3:\r\niuu_clk(port, IUU_CLK_6000000 * boost / 100);\r\npriv->clk = IUU_CLK_6000000;\r\nresult =\r\niuu_uart_baud(port, 16457 * boost / 100, &actual,\r\nIUU_PARITY_EVEN);\r\nbreak;\r\ndefault:\r\niuu_clk(port, IUU_CLK_3579000 * boost / 100);\r\npriv->clk = IUU_CLK_3579000;\r\nresult =\r\niuu_uart_baud(port, baud * boost / 100, &actual,\r\nIUU_PARITY_EVEN);\r\n}\r\nswitch (cdmode) {\r\ncase 0:\r\niuu_cardin = 0;\r\niuu_cardout = 0;\r\nbreak;\r\ncase 1:\r\niuu_cardin = TIOCM_CD;\r\niuu_cardout = 0;\r\nbreak;\r\ncase 2:\r\niuu_cardin = 0;\r\niuu_cardout = TIOCM_CD;\r\nbreak;\r\ncase 3:\r\niuu_cardin = TIOCM_DSR;\r\niuu_cardout = 0;\r\nbreak;\r\ncase 4:\r\niuu_cardin = 0;\r\niuu_cardout = TIOCM_DSR;\r\nbreak;\r\ncase 5:\r\niuu_cardin = TIOCM_CTS;\r\niuu_cardout = 0;\r\nbreak;\r\ncase 6:\r\niuu_cardin = 0;\r\niuu_cardout = TIOCM_CTS;\r\nbreak;\r\ncase 7:\r\niuu_cardin = TIOCM_RNG;\r\niuu_cardout = 0;\r\nbreak;\r\ncase 8:\r\niuu_cardin = 0;\r\niuu_cardout = TIOCM_RNG;\r\n}\r\niuu_uart_flush(port);\r\ndev_dbg(dev, "%s - initialization done\n", __func__);\r\nmemset(port->write_urb->transfer_buffer, IUU_UART_RX, 1);\r\nusb_fill_bulk_urb(port->write_urb, port->serial->dev,\r\nusb_sndbulkpipe(port->serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, 1,\r\nread_rxcmd_callback, port);\r\nresult = usb_submit_urb(port->write_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(dev, "%s - failed submitting read urb, error %d\n", __func__, result);\r\niuu_close(port);\r\n} else {\r\ndev_dbg(dev, "%s - rxcmd OK\n", __func__);\r\n}\r\nreturn result;\r\n}\r\nstatic int iuu_vcc_set(struct usb_serial_port *port, unsigned int vcc)\r\n{\r\nint status;\r\nu8 *buf;\r\nbuf = kmalloc(5, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = IUU_SET_VCC;\r\nbuf[1] = vcc & 0xFF;\r\nbuf[2] = (vcc >> 8) & 0xFF;\r\nbuf[3] = (vcc >> 16) & 0xFF;\r\nbuf[4] = (vcc >> 24) & 0xFF;\r\nstatus = bulk_immediate(port, buf, 5);\r\nkfree(buf);\r\nif (status != IUU_OPERATION_OK)\r\ndev_dbg(&port->dev, "%s - vcc error status = %2x\n", __func__, status);\r\nelse\r\ndev_dbg(&port->dev, "%s - vcc OK !\n", __func__);\r\nreturn status;\r\n}\r\nstatic ssize_t show_vcc_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_serial_port *port = to_usb_serial_port(dev);\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nreturn sprintf(buf, "%d\n", priv->vcc);\r\n}\r\nstatic ssize_t store_vcc_mode(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct usb_serial_port *port = to_usb_serial_port(dev);\r\nstruct iuu_private *priv = usb_get_serial_port_data(port);\r\nunsigned long v;\r\nif (kstrtoul(buf, 10, &v)) {\r\ndev_err(dev, "%s - vcc_mode: %s is not a unsigned long\n",\r\n__func__, buf);\r\ngoto fail_store_vcc_mode;\r\n}\r\ndev_dbg(dev, "%s: setting vcc_mode = %ld", __func__, v);\r\nif ((v != 3) && (v != 5)) {\r\ndev_err(dev, "%s - vcc_mode %ld is invalid\n", __func__, v);\r\n} else {\r\niuu_vcc_set(port, v);\r\npriv->vcc = v;\r\n}\r\nfail_store_vcc_mode:\r\nreturn count;\r\n}\r\nstatic int iuu_create_sysfs_attrs(struct usb_serial_port *port)\r\n{\r\nreturn device_create_file(&port->dev, &dev_attr_vcc_mode);\r\n}\r\nstatic int iuu_remove_sysfs_attrs(struct usb_serial_port *port)\r\n{\r\ndevice_remove_file(&port->dev, &dev_attr_vcc_mode);\r\nreturn 0;\r\n}
