static inline struct samsung_spdif_info *to_info(struct snd_soc_dai *cpu_dai)\r\n{\r\nreturn snd_soc_dai_get_drvdata(cpu_dai);\r\n}\r\nstatic void spdif_snd_txctrl(struct samsung_spdif_info *spdif, int on)\r\n{\r\nvoid __iomem *regs = spdif->regs;\r\nu32 clkcon;\r\ndev_dbg(spdif->dev, "Entered %s\n", __func__);\r\nclkcon = readl(regs + CLKCON) & CLKCTL_MASK;\r\nif (on)\r\nwritel(clkcon | CLKCTL_PWR_ON, regs + CLKCON);\r\nelse\r\nwritel(clkcon & ~CLKCTL_PWR_ON, regs + CLKCON);\r\n}\r\nstatic int spdif_set_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct samsung_spdif_info *spdif = to_info(cpu_dai);\r\nu32 clkcon;\r\ndev_dbg(spdif->dev, "Entered %s\n", __func__);\r\nclkcon = readl(spdif->regs + CLKCON);\r\nif (clk_id == SND_SOC_SPDIF_INT_MCLK)\r\nclkcon &= ~CLKCTL_MCLK_EXT;\r\nelse\r\nclkcon |= CLKCTL_MCLK_EXT;\r\nwritel(clkcon, spdif->regs + CLKCON);\r\nspdif->clk_rate = freq;\r\nreturn 0;\r\n}\r\nstatic int spdif_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct samsung_spdif_info *spdif = to_info(rtd->cpu_dai);\r\nunsigned long flags;\r\ndev_dbg(spdif->dev, "Entered %s\n", __func__);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nspin_lock_irqsave(&spdif->lock, flags);\r\nspdif_snd_txctrl(spdif, 1);\r\nspin_unlock_irqrestore(&spdif->lock, flags);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nspin_lock_irqsave(&spdif->lock, flags);\r\nspdif_snd_txctrl(spdif, 0);\r\nspin_unlock_irqrestore(&spdif->lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spdif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *socdai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct samsung_spdif_info *spdif = to_info(rtd->cpu_dai);\r\nvoid __iomem *regs = spdif->regs;\r\nstruct s3c_dma_params *dma_data;\r\nu32 con, clkcon, cstas;\r\nunsigned long flags;\r\nint i, ratio;\r\ndev_dbg(spdif->dev, "Entered %s\n", __func__);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndma_data = spdif->dma_playback;\r\nelse {\r\ndev_err(spdif->dev, "Capture is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_dai_set_dma_data(rtd->cpu_dai, substream, dma_data);\r\nspin_lock_irqsave(&spdif->lock, flags);\r\ncon = readl(regs + CON) & CON_MASK;\r\ncstas = readl(regs + CSTAS) & CSTAS_MASK;\r\nclkcon = readl(regs + CLKCON) & CLKCTL_MASK;\r\ncon &= ~CON_FIFO_TH_MASK;\r\ncon |= (0x7 << CON_FIFO_TH_SHIFT);\r\ncon |= CON_USERDATA_23RDBIT;\r\ncon |= CON_PCM_DATA;\r\ncon &= ~CON_PCM_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ncon |= CON_PCM_16BIT;\r\nbreak;\r\ndefault:\r\ndev_err(spdif->dev, "Unsupported data size.\n");\r\ngoto err;\r\n}\r\nratio = spdif->clk_rate / params_rate(params);\r\nfor (i = 0; i < ARRAY_SIZE(spdif_sysclk_ratios); i++)\r\nif (ratio == spdif_sysclk_ratios[i])\r\nbreak;\r\nif (i == ARRAY_SIZE(spdif_sysclk_ratios)) {\r\ndev_err(spdif->dev, "Invalid clock ratio %ld/%d\n",\r\nspdif->clk_rate, params_rate(params));\r\ngoto err;\r\n}\r\ncon &= ~CON_MCLKDIV_MASK;\r\nswitch (ratio) {\r\ncase 256:\r\ncon |= CON_MCLKDIV_256FS;\r\nbreak;\r\ncase 384:\r\ncon |= CON_MCLKDIV_384FS;\r\nbreak;\r\ncase 512:\r\ncon |= CON_MCLKDIV_512FS;\r\nbreak;\r\n}\r\ncstas &= ~CSTAS_SAMP_FREQ_MASK;\r\nswitch (params_rate(params)) {\r\ncase 44100:\r\ncstas |= CSTAS_SAMP_FREQ_44;\r\nbreak;\r\ncase 48000:\r\ncstas |= CSTAS_SAMP_FREQ_48;\r\nbreak;\r\ncase 32000:\r\ncstas |= CSTAS_SAMP_FREQ_32;\r\nbreak;\r\ncase 96000:\r\ncstas |= CSTAS_SAMP_FREQ_96;\r\nbreak;\r\ndefault:\r\ndev_err(spdif->dev, "Invalid sampling rate %d\n",\r\nparams_rate(params));\r\ngoto err;\r\n}\r\ncstas &= ~CSTAS_CATEGORY_MASK;\r\ncstas |= CSTAS_CATEGORY_CODE_CDP;\r\ncstas |= CSTAS_NO_COPYRIGHT;\r\nwritel(con, regs + CON);\r\nwritel(cstas, regs + CSTAS);\r\nwritel(clkcon, regs + CLKCON);\r\nspin_unlock_irqrestore(&spdif->lock, flags);\r\nreturn 0;\r\nerr:\r\nspin_unlock_irqrestore(&spdif->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nstatic void spdif_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct samsung_spdif_info *spdif = to_info(rtd->cpu_dai);\r\nvoid __iomem *regs = spdif->regs;\r\nu32 con, clkcon;\r\ndev_dbg(spdif->dev, "Entered %s\n", __func__);\r\ncon = readl(regs + CON) & CON_MASK;\r\nclkcon = readl(regs + CLKCON) & CLKCTL_MASK;\r\nwritel(con | CON_SW_RESET, regs + CON);\r\ncpu_relax();\r\nwritel(clkcon & ~CLKCTL_PWR_ON, regs + CLKCON);\r\n}\r\nstatic int spdif_suspend(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct samsung_spdif_info *spdif = to_info(cpu_dai);\r\nu32 con = spdif->saved_con;\r\ndev_dbg(spdif->dev, "Entered %s\n", __func__);\r\nspdif->saved_clkcon = readl(spdif->regs + CLKCON) & CLKCTL_MASK;\r\nspdif->saved_con = readl(spdif->regs + CON) & CON_MASK;\r\nspdif->saved_cstas = readl(spdif->regs + CSTAS) & CSTAS_MASK;\r\nwritel(con | CON_SW_RESET, spdif->regs + CON);\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic int spdif_resume(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct samsung_spdif_info *spdif = to_info(cpu_dai);\r\ndev_dbg(spdif->dev, "Entered %s\n", __func__);\r\nwritel(spdif->saved_clkcon, spdif->regs + CLKCON);\r\nwritel(spdif->saved_con, spdif->regs + CON);\r\nwritel(spdif->saved_cstas, spdif->regs + CSTAS);\r\nreturn 0;\r\n}\r\nstatic int spdif_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c_audio_pdata *spdif_pdata;\r\nstruct resource *mem_res, *dma_res;\r\nstruct samsung_spdif_info *spdif;\r\nint ret;\r\nspdif_pdata = pdev->dev.platform_data;\r\ndev_dbg(&pdev->dev, "Entered %s\n", __func__);\r\ndma_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!dma_res) {\r\ndev_err(&pdev->dev, "Unable to get dma resource.\n");\r\nreturn -ENXIO;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_res) {\r\ndev_err(&pdev->dev, "Unable to get register resource.\n");\r\nreturn -ENXIO;\r\n}\r\nif (spdif_pdata && spdif_pdata->cfg_gpio\r\n&& spdif_pdata->cfg_gpio(pdev)) {\r\ndev_err(&pdev->dev, "Unable to configure GPIO pins\n");\r\nreturn -EINVAL;\r\n}\r\nspdif = &spdif_info;\r\nspdif->dev = &pdev->dev;\r\nspin_lock_init(&spdif->lock);\r\nspdif->pclk = clk_get(&pdev->dev, "spdif");\r\nif (IS_ERR(spdif->pclk)) {\r\ndev_err(&pdev->dev, "failed to get peri-clock\n");\r\nret = -ENOENT;\r\ngoto err0;\r\n}\r\nclk_prepare_enable(spdif->pclk);\r\nspdif->sclk = clk_get(&pdev->dev, "sclk_spdif");\r\nif (IS_ERR(spdif->sclk)) {\r\ndev_err(&pdev->dev, "failed to get internal source clock\n");\r\nret = -ENOENT;\r\ngoto err1;\r\n}\r\nclk_prepare_enable(spdif->sclk);\r\nif (!request_mem_region(mem_res->start,\r\nresource_size(mem_res), "samsung-spdif")) {\r\ndev_err(&pdev->dev, "Unable to request register region\n");\r\nret = -EBUSY;\r\ngoto err2;\r\n}\r\nspdif->regs = ioremap(mem_res->start, 0x100);\r\nif (spdif->regs == NULL) {\r\ndev_err(&pdev->dev, "Cannot ioremap registers\n");\r\nret = -ENXIO;\r\ngoto err3;\r\n}\r\ndev_set_drvdata(&pdev->dev, spdif);\r\nret = snd_soc_register_component(&pdev->dev, &samsung_spdif_component,\r\n&samsung_spdif_dai, 1);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "fail to register dai\n");\r\ngoto err4;\r\n}\r\nspdif_stereo_out.dma_size = 2;\r\nspdif_stereo_out.client = &spdif_dma_client_out;\r\nspdif_stereo_out.dma_addr = mem_res->start + DATA_OUTBUF;\r\nspdif_stereo_out.channel = dma_res->start;\r\nspdif->dma_playback = &spdif_stereo_out;\r\nret = asoc_dma_platform_register(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register DMA: %d\n", ret);\r\ngoto err5;\r\n}\r\nreturn 0;\r\nerr5:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nerr4:\r\niounmap(spdif->regs);\r\nerr3:\r\nrelease_mem_region(mem_res->start, resource_size(mem_res));\r\nerr2:\r\nclk_disable_unprepare(spdif->sclk);\r\nclk_put(spdif->sclk);\r\nerr1:\r\nclk_disable_unprepare(spdif->pclk);\r\nclk_put(spdif->pclk);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int spdif_remove(struct platform_device *pdev)\r\n{\r\nstruct samsung_spdif_info *spdif = &spdif_info;\r\nstruct resource *mem_res;\r\nasoc_dma_platform_unregister(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\niounmap(spdif->regs);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (mem_res)\r\nrelease_mem_region(mem_res->start, resource_size(mem_res));\r\nclk_disable_unprepare(spdif->sclk);\r\nclk_put(spdif->sclk);\r\nclk_disable_unprepare(spdif->pclk);\r\nclk_put(spdif->pclk);\r\nreturn 0;\r\n}
