static inline struct f_midi *func_to_midi(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_midi, func);\r\n}\r\nstatic struct usb_request *alloc_ep_req(struct usb_ep *ep, unsigned length)\r\n{\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (req) {\r\nreq->length = length;\r\nreq->buf = kmalloc(length, GFP_ATOMIC);\r\nif (!req->buf) {\r\nusb_ep_free_request(ep, req);\r\nreq = NULL;\r\n}\r\n}\r\nreturn req;\r\n}\r\nstatic void free_ep_req(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\nstatic void f_midi_read_data(struct usb_ep *ep, int cable,\r\nuint8_t *data, int length)\r\n{\r\nstruct f_midi *midi = ep->driver_data;\r\nstruct snd_rawmidi_substream *substream = midi->out_substream[cable];\r\nif (!substream)\r\nreturn;\r\nif (!test_bit(cable, &midi->out_triggered))\r\nreturn;\r\nsnd_rawmidi_receive(substream, data, length);\r\n}\r\nstatic void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nunsigned int i;\r\nu8 *buf = req->buf;\r\nfor (i = 0; i + 3 < req->actual; i += 4)\r\nif (buf[i] != 0) {\r\nint cable = buf[i] >> 4;\r\nint length = f_midi_cin_length[buf[i] & 0x0f];\r\nf_midi_read_data(ep, cable, &buf[i + 1], length);\r\n}\r\n}\r\nstatic void\r\nf_midi_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_midi *midi = ep->driver_data;\r\nstruct usb_composite_dev *cdev = midi->func.config->cdev;\r\nint status = req->status;\r\nswitch (status) {\r\ncase 0:\r\nif (ep == midi->out_ep) {\r\nf_midi_handle_out_data(ep, req);\r\n} else if (ep == midi->in_ep) {\r\nf_midi_transmit(midi, req);\r\nreturn;\r\n}\r\nbreak;\r\ncase -ECONNABORTED:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nVDBG(cdev, "%s gone (%d), %d/%d\n", ep->name, status,\r\nreq->actual, req->length);\r\nif (ep == midi->out_ep)\r\nf_midi_handle_out_data(ep, req);\r\nfree_ep_req(ep, req);\r\nreturn;\r\ncase -EOVERFLOW:\r\ndefault:\r\nDBG(cdev, "%s complete --> %d, %d/%d\n", ep->name,\r\nstatus, req->actual, req->length);\r\nbreak;\r\ncase -EREMOTEIO:\r\nbreak;\r\n}\r\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (status) {\r\nERROR(cdev, "kill %s: resubmit %d bytes --> %d\n",\r\nep->name, req->length, status);\r\nusb_ep_set_halt(ep);\r\n}\r\n}\r\nstatic int f_midi_start_ep(struct f_midi *midi,\r\nstruct usb_function *f,\r\nstruct usb_ep *ep)\r\n{\r\nint err;\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (ep->driver_data)\r\nusb_ep_disable(ep);\r\nerr = config_ep_by_speed(midi->gadget, f, ep);\r\nif (err) {\r\nERROR(cdev, "can't configure %s: %d\n", ep->name, err);\r\nreturn err;\r\n}\r\nerr = usb_ep_enable(ep);\r\nif (err) {\r\nERROR(cdev, "can't start %s: %d\n", ep->name, err);\r\nreturn err;\r\n}\r\nep->driver_data = midi;\r\nreturn 0;\r\n}\r\nstatic int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_midi *midi = func_to_midi(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nunsigned i;\r\nint err;\r\nerr = f_midi_start_ep(midi, f, midi->in_ep);\r\nif (err)\r\nreturn err;\r\nerr = f_midi_start_ep(midi, f, midi->out_ep);\r\nif (err)\r\nreturn err;\r\nif (midi->out_ep->driver_data)\r\nusb_ep_disable(midi->out_ep);\r\nerr = config_ep_by_speed(midi->gadget, f, midi->out_ep);\r\nif (err) {\r\nERROR(cdev, "can't configure %s: %d\n",\r\nmidi->out_ep->name, err);\r\nreturn err;\r\n}\r\nerr = usb_ep_enable(midi->out_ep);\r\nif (err) {\r\nERROR(cdev, "can't start %s: %d\n",\r\nmidi->out_ep->name, err);\r\nreturn err;\r\n}\r\nmidi->out_ep->driver_data = midi;\r\nfor (i = 0; i < midi->qlen && err == 0; i++) {\r\nstruct usb_request *req =\r\nalloc_ep_req(midi->out_ep, midi->buflen);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq->complete = f_midi_complete;\r\nerr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\r\nif (err) {\r\nERROR(midi, "%s queue req: %d\n",\r\nmidi->out_ep->name, err);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void f_midi_disable(struct usb_function *f)\r\n{\r\nstruct f_midi *midi = func_to_midi(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nDBG(cdev, "disable\n");\r\nusb_ep_disable(midi->in_ep);\r\nusb_ep_disable(midi->out_ep);\r\n}\r\nstatic void f_midi_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct f_midi *midi = func_to_midi(f);\r\nstruct snd_card *card;\r\nDBG(cdev, "unbind\n");\r\nf_midi_disable(f);\r\ncard = midi->card;\r\nmidi->card = NULL;\r\nif (card)\r\nsnd_card_free(card);\r\nkfree(midi->id);\r\nmidi->id = NULL;\r\nusb_free_all_descriptors(f);\r\nkfree(midi);\r\n}\r\nstatic int f_midi_snd_free(struct snd_device *device)\r\n{\r\nreturn 0;\r\n}\r\nstatic void f_midi_transmit_packet(struct usb_request *req, uint8_t p0,\r\nuint8_t p1, uint8_t p2, uint8_t p3)\r\n{\r\nunsigned length = req->length;\r\nu8 *buf = (u8 *)req->buf + length;\r\nbuf[0] = p0;\r\nbuf[1] = p1;\r\nbuf[2] = p2;\r\nbuf[3] = p3;\r\nreq->length = length + 4;\r\n}\r\nstatic void f_midi_transmit_byte(struct usb_request *req,\r\nstruct gmidi_in_port *port, uint8_t b)\r\n{\r\nuint8_t p0 = port->cable << 4;\r\nif (b >= 0xf8) {\r\nf_midi_transmit_packet(req, p0 | 0x0f, b, 0, 0);\r\n} else if (b >= 0xf0) {\r\nswitch (b) {\r\ncase 0xf0:\r\nport->data[0] = b;\r\nport->state = STATE_SYSEX_1;\r\nbreak;\r\ncase 0xf1:\r\ncase 0xf3:\r\nport->data[0] = b;\r\nport->state = STATE_1PARAM;\r\nbreak;\r\ncase 0xf2:\r\nport->data[0] = b;\r\nport->state = STATE_2PARAM_1;\r\nbreak;\r\ncase 0xf4:\r\ncase 0xf5:\r\nport->state = STATE_UNKNOWN;\r\nbreak;\r\ncase 0xf6:\r\nf_midi_transmit_packet(req, p0 | 0x05, 0xf6, 0, 0);\r\nport->state = STATE_UNKNOWN;\r\nbreak;\r\ncase 0xf7:\r\nswitch (port->state) {\r\ncase STATE_SYSEX_0:\r\nf_midi_transmit_packet(req,\r\np0 | 0x05, 0xf7, 0, 0);\r\nbreak;\r\ncase STATE_SYSEX_1:\r\nf_midi_transmit_packet(req,\r\np0 | 0x06, port->data[0], 0xf7, 0);\r\nbreak;\r\ncase STATE_SYSEX_2:\r\nf_midi_transmit_packet(req,\r\np0 | 0x07, port->data[0],\r\nport->data[1], 0xf7);\r\nbreak;\r\n}\r\nport->state = STATE_UNKNOWN;\r\nbreak;\r\n}\r\n} else if (b >= 0x80) {\r\nport->data[0] = b;\r\nif (b >= 0xc0 && b <= 0xdf)\r\nport->state = STATE_1PARAM;\r\nelse\r\nport->state = STATE_2PARAM_1;\r\n} else {\r\nswitch (port->state) {\r\ncase STATE_1PARAM:\r\nif (port->data[0] < 0xf0) {\r\np0 |= port->data[0] >> 4;\r\n} else {\r\np0 |= 0x02;\r\nport->state = STATE_UNKNOWN;\r\n}\r\nf_midi_transmit_packet(req, p0, port->data[0], b, 0);\r\nbreak;\r\ncase STATE_2PARAM_1:\r\nport->data[1] = b;\r\nport->state = STATE_2PARAM_2;\r\nbreak;\r\ncase STATE_2PARAM_2:\r\nif (port->data[0] < 0xf0) {\r\np0 |= port->data[0] >> 4;\r\nport->state = STATE_2PARAM_1;\r\n} else {\r\np0 |= 0x03;\r\nport->state = STATE_UNKNOWN;\r\n}\r\nf_midi_transmit_packet(req,\r\np0, port->data[0], port->data[1], b);\r\nbreak;\r\ncase STATE_SYSEX_0:\r\nport->data[0] = b;\r\nport->state = STATE_SYSEX_1;\r\nbreak;\r\ncase STATE_SYSEX_1:\r\nport->data[1] = b;\r\nport->state = STATE_SYSEX_2;\r\nbreak;\r\ncase STATE_SYSEX_2:\r\nf_midi_transmit_packet(req,\r\np0 | 0x04, port->data[0], port->data[1], b);\r\nport->state = STATE_SYSEX_0;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void f_midi_transmit(struct f_midi *midi, struct usb_request *req)\r\n{\r\nstruct usb_ep *ep = midi->in_ep;\r\nint i;\r\nif (!ep)\r\nreturn;\r\nif (!req)\r\nreq = alloc_ep_req(ep, midi->buflen);\r\nif (!req) {\r\nERROR(midi, "gmidi_transmit: alloc_ep_request failed\n");\r\nreturn;\r\n}\r\nreq->length = 0;\r\nreq->complete = f_midi_complete;\r\nfor (i = 0; i < MAX_PORTS; i++) {\r\nstruct gmidi_in_port *port = midi->in_port[i];\r\nstruct snd_rawmidi_substream *substream = midi->in_substream[i];\r\nif (!port || !port->active || !substream)\r\ncontinue;\r\nwhile (req->length + 3 < midi->buflen) {\r\nuint8_t b;\r\nif (snd_rawmidi_transmit(substream, &b, 1) != 1) {\r\nport->active = 0;\r\nbreak;\r\n}\r\nf_midi_transmit_byte(req, port, b);\r\n}\r\n}\r\nif (req->length > 0)\r\nusb_ep_queue(ep, req, GFP_ATOMIC);\r\nelse\r\nfree_ep_req(ep, req);\r\n}\r\nstatic void f_midi_in_tasklet(unsigned long data)\r\n{\r\nstruct f_midi *midi = (struct f_midi *) data;\r\nf_midi_transmit(midi, NULL);\r\n}\r\nstatic int f_midi_in_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nif (!midi->in_port[substream->number])\r\nreturn -EINVAL;\r\nVDBG(midi, "%s()\n", __func__);\r\nmidi->in_substream[substream->number] = substream;\r\nmidi->in_port[substream->number]->state = STATE_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic int f_midi_in_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nVDBG(midi, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void f_midi_in_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nif (!midi->in_port[substream->number])\r\nreturn;\r\nVDBG(midi, "%s() %d\n", __func__, up);\r\nmidi->in_port[substream->number]->active = up;\r\nif (up)\r\ntasklet_hi_schedule(&midi->tasklet);\r\n}\r\nstatic int f_midi_out_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nif (substream->number >= MAX_PORTS)\r\nreturn -EINVAL;\r\nVDBG(midi, "%s()\n", __func__);\r\nmidi->out_substream[substream->number] = substream;\r\nreturn 0;\r\n}\r\nstatic int f_midi_out_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nVDBG(midi, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void f_midi_out_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct f_midi *midi = substream->rmidi->private_data;\r\nVDBG(midi, "%s()\n", __func__);\r\nif (up)\r\nset_bit(substream->number, &midi->out_triggered);\r\nelse\r\nclear_bit(substream->number, &midi->out_triggered);\r\n}\r\nstatic int f_midi_register_card(struct f_midi *midi)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = f_midi_snd_free,\r\n};\r\nerr = snd_card_create(midi->index, midi->id, THIS_MODULE, 0, &card);\r\nif (err < 0) {\r\nERROR(midi, "snd_card_create() failed\n");\r\ngoto fail;\r\n}\r\nmidi->card = card;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, midi, &ops);\r\nif (err < 0) {\r\nERROR(midi, "snd_device_new() failed: error %d\n", err);\r\ngoto fail;\r\n}\r\nstrcpy(card->driver, f_midi_longname);\r\nstrcpy(card->longname, f_midi_longname);\r\nstrcpy(card->shortname, f_midi_shortname);\r\nsnd_component_add(card, "MIDI");\r\nerr = snd_rawmidi_new(card, card->longname, 0,\r\nmidi->out_ports, midi->in_ports, &rmidi);\r\nif (err < 0) {\r\nERROR(midi, "snd_rawmidi_new() failed: error %d\n", err);\r\ngoto fail;\r\n}\r\nmidi->rmidi = rmidi;\r\nstrcpy(rmidi->name, card->shortname);\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nrmidi->private_data = midi;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &gmidi_in_ops);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &gmidi_out_ops);\r\nsnd_card_set_dev(card, &midi->gadget->dev);\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nERROR(midi, "snd_card_register() failed\n");\r\ngoto fail;\r\n}\r\nVDBG(midi, "%s() finished ok\n", __func__);\r\nreturn 0;\r\nfail:\r\nif (midi->card) {\r\nsnd_card_free(midi->card);\r\nmidi->card = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int __init\r\nf_midi_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_descriptor_header **midi_function;\r\nstruct usb_midi_in_jack_descriptor jack_in_ext_desc[MAX_PORTS];\r\nstruct usb_midi_in_jack_descriptor jack_in_emb_desc[MAX_PORTS];\r\nstruct usb_midi_out_jack_descriptor_1 jack_out_ext_desc[MAX_PORTS];\r\nstruct usb_midi_out_jack_descriptor_1 jack_out_emb_desc[MAX_PORTS];\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_midi *midi = func_to_midi(f);\r\nint status, n, jack = 1, i = 0;\r\nif (midi_string_defs[0].id == 0) {\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\ngoto fail;\r\nmidi_string_defs[0].id = status;\r\n}\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nac_interface_desc.bInterfaceNumber = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nms_interface_desc.bInterfaceNumber = status;\r\nac_header_desc.baInterfaceNr[0] = status;\r\nstatus = -ENODEV;\r\nmidi->in_ep = usb_ep_autoconfig(cdev->gadget, &bulk_in_desc);\r\nif (!midi->in_ep)\r\ngoto fail;\r\nmidi->in_ep->driver_data = cdev;\r\nmidi->out_ep = usb_ep_autoconfig(cdev->gadget, &bulk_out_desc);\r\nif (!midi->out_ep)\r\ngoto fail;\r\nmidi->out_ep->driver_data = cdev;\r\nmidi_function = kcalloc((MAX_PORTS * 4) + 9, sizeof(*midi_function),\r\nGFP_KERNEL);\r\nif (!midi_function) {\r\nstatus = -ENOMEM;\r\ngoto fail;\r\n}\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ac_interface_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ac_header_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ms_interface_desc;\r\nn = USB_DT_MS_HEADER_SIZE\r\n+ (midi->in_ports + midi->out_ports) *\r\n(USB_DT_MIDI_IN_SIZE + USB_DT_MIDI_OUT_SIZE(1));\r\nms_header_desc.wTotalLength = cpu_to_le16(n);\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ms_header_desc;\r\nfor (n = 0; n < midi->in_ports; n++) {\r\nstruct usb_midi_in_jack_descriptor *in_ext = &jack_in_ext_desc[n];\r\nstruct usb_midi_out_jack_descriptor_1 *out_emb = &jack_out_emb_desc[n];\r\nin_ext->bLength = USB_DT_MIDI_IN_SIZE;\r\nin_ext->bDescriptorType = USB_DT_CS_INTERFACE;\r\nin_ext->bDescriptorSubtype = USB_MS_MIDI_IN_JACK;\r\nin_ext->bJackType = USB_MS_EXTERNAL;\r\nin_ext->bJackID = jack++;\r\nin_ext->iJack = 0;\r\nmidi_function[i++] = (struct usb_descriptor_header *) in_ext;\r\nout_emb->bLength = USB_DT_MIDI_OUT_SIZE(1);\r\nout_emb->bDescriptorType = USB_DT_CS_INTERFACE;\r\nout_emb->bDescriptorSubtype = USB_MS_MIDI_OUT_JACK;\r\nout_emb->bJackType = USB_MS_EMBEDDED;\r\nout_emb->bJackID = jack++;\r\nout_emb->bNrInputPins = 1;\r\nout_emb->pins[0].baSourcePin = 1;\r\nout_emb->pins[0].baSourceID = in_ext->bJackID;\r\nout_emb->iJack = 0;\r\nmidi_function[i++] = (struct usb_descriptor_header *) out_emb;\r\nms_in_desc.baAssocJackID[n] = out_emb->bJackID;\r\n}\r\nfor (n = 0; n < midi->out_ports; n++) {\r\nstruct usb_midi_in_jack_descriptor *in_emb = &jack_in_emb_desc[n];\r\nstruct usb_midi_out_jack_descriptor_1 *out_ext = &jack_out_ext_desc[n];\r\nin_emb->bLength = USB_DT_MIDI_IN_SIZE;\r\nin_emb->bDescriptorType = USB_DT_CS_INTERFACE;\r\nin_emb->bDescriptorSubtype = USB_MS_MIDI_IN_JACK;\r\nin_emb->bJackType = USB_MS_EMBEDDED;\r\nin_emb->bJackID = jack++;\r\nin_emb->iJack = 0;\r\nmidi_function[i++] = (struct usb_descriptor_header *) in_emb;\r\nout_ext->bLength = USB_DT_MIDI_OUT_SIZE(1);\r\nout_ext->bDescriptorType = USB_DT_CS_INTERFACE;\r\nout_ext->bDescriptorSubtype = USB_MS_MIDI_OUT_JACK;\r\nout_ext->bJackType = USB_MS_EXTERNAL;\r\nout_ext->bJackID = jack++;\r\nout_ext->bNrInputPins = 1;\r\nout_ext->iJack = 0;\r\nout_ext->pins[0].baSourceID = in_emb->bJackID;\r\nout_ext->pins[0].baSourcePin = 1;\r\nmidi_function[i++] = (struct usb_descriptor_header *) out_ext;\r\nms_out_desc.baAssocJackID[n] = in_emb->bJackID;\r\n}\r\nms_out_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->in_ports);\r\nms_out_desc.bNumEmbMIDIJack = midi->in_ports;\r\nms_in_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->out_ports);\r\nms_in_desc.bNumEmbMIDIJack = midi->out_ports;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &bulk_out_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ms_out_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &bulk_in_desc;\r\nmidi_function[i++] = (struct usb_descriptor_header *) &ms_in_desc;\r\nmidi_function[i++] = NULL;\r\nf->fs_descriptors = usb_copy_descriptors(midi_function);\r\nif (!f->fs_descriptors)\r\ngoto fail_f_midi;\r\nif (gadget_is_dualspeed(c->cdev->gadget)) {\r\nbulk_in_desc.wMaxPacketSize = cpu_to_le16(512);\r\nbulk_out_desc.wMaxPacketSize = cpu_to_le16(512);\r\nf->hs_descriptors = usb_copy_descriptors(midi_function);\r\nif (!f->hs_descriptors)\r\ngoto fail_f_midi;\r\n}\r\nkfree(midi_function);\r\nreturn 0;\r\nfail_f_midi:\r\nkfree(midi_function);\r\nusb_free_descriptors(f->hs_descriptors);\r\nfail:\r\nif (midi->out_ep)\r\nmidi->out_ep->driver_data = NULL;\r\nif (midi->in_ep)\r\nmidi->in_ep->driver_data = NULL;\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nint __init f_midi_bind_config(struct usb_configuration *c,\r\nint index, char *id,\r\nunsigned int in_ports,\r\nunsigned int out_ports,\r\nunsigned int buflen,\r\nunsigned int qlen)\r\n{\r\nstruct f_midi *midi;\r\nint status, i;\r\nif (in_ports > MAX_PORTS || out_ports > MAX_PORTS)\r\nreturn -EINVAL;\r\nmidi = kzalloc(sizeof *midi, GFP_KERNEL);\r\nif (!midi) {\r\nstatus = -ENOMEM;\r\ngoto fail;\r\n}\r\nfor (i = 0; i < in_ports; i++) {\r\nstruct gmidi_in_port *port = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port) {\r\nstatus = -ENOMEM;\r\ngoto setup_fail;\r\n}\r\nport->midi = midi;\r\nport->active = 0;\r\nport->cable = i;\r\nmidi->in_port[i] = port;\r\n}\r\nmidi->gadget = c->cdev->gadget;\r\ntasklet_init(&midi->tasklet, f_midi_in_tasklet, (unsigned long) midi);\r\nmidi->in_ports = in_ports;\r\nmidi->out_ports = out_ports;\r\nstatus = f_midi_register_card(midi);\r\nif (status < 0)\r\ngoto setup_fail;\r\nmidi->func.name = "gmidi function";\r\nmidi->func.strings = midi_strings;\r\nmidi->func.bind = f_midi_bind;\r\nmidi->func.unbind = f_midi_unbind;\r\nmidi->func.set_alt = f_midi_set_alt;\r\nmidi->func.disable = f_midi_disable;\r\nmidi->id = kstrdup(id, GFP_KERNEL);\r\nmidi->index = index;\r\nmidi->buflen = buflen;\r\nmidi->qlen = qlen;\r\nstatus = usb_add_function(c, &midi->func);\r\nif (status)\r\ngoto setup_fail;\r\nreturn 0;\r\nsetup_fail:\r\nfor (--i; i >= 0; i--)\r\nkfree(midi->in_port[i]);\r\nkfree(midi);\r\nfail:\r\nreturn status;\r\n}
