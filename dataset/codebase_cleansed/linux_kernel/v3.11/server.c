static int afs_install_server(struct afs_server *server)\r\n{\r\nstruct afs_server *xserver;\r\nstruct rb_node **pp, *p;\r\nint ret;\r\n_enter("%p", server);\r\nwrite_lock(&afs_servers_lock);\r\nret = -EEXIST;\r\npp = &afs_servers.rb_node;\r\np = NULL;\r\nwhile (*pp) {\r\np = *pp;\r\n_debug("- consider %p", p);\r\nxserver = rb_entry(p, struct afs_server, master_rb);\r\nif (server->addr.s_addr < xserver->addr.s_addr)\r\npp = &(*pp)->rb_left;\r\nelse if (server->addr.s_addr > xserver->addr.s_addr)\r\npp = &(*pp)->rb_right;\r\nelse\r\ngoto error;\r\n}\r\nrb_link_node(&server->master_rb, p, pp);\r\nrb_insert_color(&server->master_rb, &afs_servers);\r\nret = 0;\r\nerror:\r\nwrite_unlock(&afs_servers_lock);\r\nreturn ret;\r\n}\r\nstatic struct afs_server *afs_alloc_server(struct afs_cell *cell,\r\nconst struct in_addr *addr)\r\n{\r\nstruct afs_server *server;\r\n_enter("");\r\nserver = kzalloc(sizeof(struct afs_server), GFP_KERNEL);\r\nif (server) {\r\natomic_set(&server->usage, 1);\r\nserver->cell = cell;\r\nINIT_LIST_HEAD(&server->link);\r\nINIT_LIST_HEAD(&server->grave);\r\ninit_rwsem(&server->sem);\r\nspin_lock_init(&server->fs_lock);\r\nserver->fs_vnodes = RB_ROOT;\r\nserver->cb_promises = RB_ROOT;\r\nspin_lock_init(&server->cb_lock);\r\ninit_waitqueue_head(&server->cb_break_waitq);\r\nINIT_DELAYED_WORK(&server->cb_break_work,\r\nafs_dispatch_give_up_callbacks);\r\nmemcpy(&server->addr, addr, sizeof(struct in_addr));\r\nserver->addr.s_addr = addr->s_addr;\r\n_leave(" = %p{%d}", server, atomic_read(&server->usage));\r\n} else {\r\n_leave(" = NULL [nomem]");\r\n}\r\nreturn server;\r\n}\r\nstruct afs_server *afs_lookup_server(struct afs_cell *cell,\r\nconst struct in_addr *addr)\r\n{\r\nstruct afs_server *server, *candidate;\r\n_enter("%p,%pI4", cell, &addr->s_addr);\r\nread_lock(&cell->servers_lock);\r\nlist_for_each_entry(server, &cell->servers, link) {\r\nif (server->addr.s_addr == addr->s_addr)\r\ngoto found_server_quickly;\r\n}\r\nread_unlock(&cell->servers_lock);\r\ncandidate = afs_alloc_server(cell, addr);\r\nif (!candidate) {\r\n_leave(" = -ENOMEM");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nwrite_lock(&cell->servers_lock);\r\nlist_for_each_entry(server, &cell->servers, link) {\r\nif (server->addr.s_addr == addr->s_addr)\r\ngoto found_server;\r\n}\r\n_debug("new");\r\nserver = candidate;\r\nif (afs_install_server(server) < 0)\r\ngoto server_in_two_cells;\r\nafs_get_cell(cell);\r\nlist_add_tail(&server->link, &cell->servers);\r\nwrite_unlock(&cell->servers_lock);\r\n_leave(" = %p{%d}", server, atomic_read(&server->usage));\r\nreturn server;\r\nfound_server_quickly:\r\n_debug("found quickly");\r\nafs_get_server(server);\r\nread_unlock(&cell->servers_lock);\r\nno_longer_unused:\r\nif (!list_empty(&server->grave)) {\r\nspin_lock(&afs_server_graveyard_lock);\r\nlist_del_init(&server->grave);\r\nspin_unlock(&afs_server_graveyard_lock);\r\n}\r\n_leave(" = %p{%d}", server, atomic_read(&server->usage));\r\nreturn server;\r\nfound_server:\r\n_debug("found");\r\nafs_get_server(server);\r\nwrite_unlock(&cell->servers_lock);\r\nkfree(candidate);\r\ngoto no_longer_unused;\r\nserver_in_two_cells:\r\nwrite_unlock(&cell->servers_lock);\r\nkfree(candidate);\r\nprintk(KERN_NOTICE "kAFS: Server %pI4 appears to be in two cells\n",\r\naddr);\r\n_leave(" = -EEXIST");\r\nreturn ERR_PTR(-EEXIST);\r\n}\r\nstruct afs_server *afs_find_server(const struct in_addr *_addr)\r\n{\r\nstruct afs_server *server = NULL;\r\nstruct rb_node *p;\r\nstruct in_addr addr = *_addr;\r\n_enter("%pI4", &addr.s_addr);\r\nread_lock(&afs_servers_lock);\r\np = afs_servers.rb_node;\r\nwhile (p) {\r\nserver = rb_entry(p, struct afs_server, master_rb);\r\n_debug("- consider %p", p);\r\nif (addr.s_addr < server->addr.s_addr) {\r\np = p->rb_left;\r\n} else if (addr.s_addr > server->addr.s_addr) {\r\np = p->rb_right;\r\n} else {\r\nafs_get_server(server);\r\ngoto found;\r\n}\r\n}\r\nserver = NULL;\r\nfound:\r\nread_unlock(&afs_servers_lock);\r\nASSERTIFCMP(server, server->addr.s_addr, ==, addr.s_addr);\r\n_leave(" = %p", server);\r\nreturn server;\r\n}\r\nvoid afs_put_server(struct afs_server *server)\r\n{\r\nif (!server)\r\nreturn;\r\n_enter("%p{%d}", server, atomic_read(&server->usage));\r\n_debug("PUT SERVER %d", atomic_read(&server->usage));\r\nASSERTCMP(atomic_read(&server->usage), >, 0);\r\nif (likely(!atomic_dec_and_test(&server->usage))) {\r\n_leave("");\r\nreturn;\r\n}\r\nafs_flush_callback_breaks(server);\r\nspin_lock(&afs_server_graveyard_lock);\r\nif (atomic_read(&server->usage) == 0) {\r\nlist_move_tail(&server->grave, &afs_server_graveyard);\r\nserver->time_of_death = get_seconds();\r\nqueue_delayed_work(afs_wq, &afs_server_reaper,\r\nafs_server_timeout * HZ);\r\n}\r\nspin_unlock(&afs_server_graveyard_lock);\r\n_leave(" [dead]");\r\n}\r\nstatic void afs_destroy_server(struct afs_server *server)\r\n{\r\n_enter("%p", server);\r\nASSERTIF(server->cb_break_head != server->cb_break_tail,\r\ndelayed_work_pending(&server->cb_break_work));\r\nASSERTCMP(server->fs_vnodes.rb_node, ==, NULL);\r\nASSERTCMP(server->cb_promises.rb_node, ==, NULL);\r\nASSERTCMP(server->cb_break_head, ==, server->cb_break_tail);\r\nASSERTCMP(atomic_read(&server->cb_break_n), ==, 0);\r\nafs_put_cell(server->cell);\r\nkfree(server);\r\n}\r\nstatic void afs_reap_server(struct work_struct *work)\r\n{\r\nLIST_HEAD(corpses);\r\nstruct afs_server *server;\r\nunsigned long delay, expiry;\r\ntime_t now;\r\nnow = get_seconds();\r\nspin_lock(&afs_server_graveyard_lock);\r\nwhile (!list_empty(&afs_server_graveyard)) {\r\nserver = list_entry(afs_server_graveyard.next,\r\nstruct afs_server, grave);\r\nexpiry = server->time_of_death + afs_server_timeout;\r\nif (expiry > now) {\r\ndelay = (expiry - now) * HZ;\r\nmod_delayed_work(afs_wq, &afs_server_reaper, delay);\r\nbreak;\r\n}\r\nwrite_lock(&server->cell->servers_lock);\r\nwrite_lock(&afs_servers_lock);\r\nif (atomic_read(&server->usage) > 0) {\r\nlist_del_init(&server->grave);\r\n} else {\r\nlist_move_tail(&server->grave, &corpses);\r\nlist_del_init(&server->link);\r\nrb_erase(&server->master_rb, &afs_servers);\r\n}\r\nwrite_unlock(&afs_servers_lock);\r\nwrite_unlock(&server->cell->servers_lock);\r\n}\r\nspin_unlock(&afs_server_graveyard_lock);\r\nwhile (!list_empty(&corpses)) {\r\nserver = list_entry(corpses.next, struct afs_server, grave);\r\nlist_del(&server->grave);\r\nafs_destroy_server(server);\r\n}\r\n}\r\nvoid __exit afs_purge_servers(void)\r\n{\r\nafs_server_timeout = 0;\r\nmod_delayed_work(afs_wq, &afs_server_reaper, 0);\r\n}
