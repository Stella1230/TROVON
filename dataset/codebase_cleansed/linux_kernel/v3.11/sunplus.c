static void reg_r(struct gspca_dev *gspca_dev,\r\nu8 req,\r\nu16 index,\r\nu16 len)\r\n{\r\nint ret;\r\nif (len > USB_BUF_SZ) {\r\nPERR("reg_r: buffer overflow\n");\r\nreturn;\r\n}\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\nreq,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex,\r\nlen ? gspca_dev->usb_buf : NULL, len,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_r err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w_1(struct gspca_dev *gspca_dev,\r\nu8 req,\r\nu16 value,\r\nu16 index,\r\nu16 byte)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\ngspca_dev->usb_buf[0] = byte;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index,\r\ngspca_dev->usb_buf, 1,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w_1 err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w_riv(struct gspca_dev *gspca_dev,\r\nu8 req, u16 index, u16 value)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, NULL, 0, 500);\r\nif (ret < 0) {\r\npr_err("reg_w_riv err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\nreturn;\r\n}\r\nPDEBUG(D_USBO, "reg_w_riv: 0x%02x,0x%04x:0x%04x",\r\nreq, index, value);\r\n}\r\nstatic void write_vector(struct gspca_dev *gspca_dev,\r\nconst struct cmd *data, int ncmds)\r\n{\r\nwhile (--ncmds >= 0) {\r\nreg_w_riv(gspca_dev, data->req, data->idx, data->val);\r\ndata++;\r\n}\r\n}\r\nstatic void setup_qtable(struct gspca_dev *gspca_dev,\r\nconst u8 qtable[2][64])\r\n{\r\nint i;\r\nfor (i = 0; i < 64; i++)\r\nreg_w_riv(gspca_dev, 0x00, 0x2800 + i, qtable[0][i]);\r\nfor (i = 0; i < 64; i++)\r\nreg_w_riv(gspca_dev, 0x00, 0x2840 + i, qtable[1][i]);\r\n}\r\nstatic void spca504_acknowledged_command(struct gspca_dev *gspca_dev,\r\nu8 req, u16 idx, u16 val)\r\n{\r\nreg_w_riv(gspca_dev, req, idx, val);\r\nreg_r(gspca_dev, 0x01, 0x0001, 1);\r\nPDEBUG(D_FRAM, "before wait 0x%04x", gspca_dev->usb_buf[0]);\r\nreg_w_riv(gspca_dev, req, idx, val);\r\nmsleep(200);\r\nreg_r(gspca_dev, 0x01, 0x0001, 1);\r\nPDEBUG(D_FRAM, "after wait 0x%04x", gspca_dev->usb_buf[0]);\r\n}\r\nstatic void spca504_read_info(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nu8 info[6];\r\nif (gspca_debug < D_STREAM)\r\nreturn;\r\nfor (i = 0; i < 6; i++) {\r\nreg_r(gspca_dev, 0, i, 1);\r\ninfo[i] = gspca_dev->usb_buf[0];\r\n}\r\nPDEBUG(D_STREAM,\r\n"Read info: %d %d %d %d %d %d."\r\n" Should be 1,0,2,2,0,0",\r\ninfo[0], info[1], info[2],\r\ninfo[3], info[4], info[5]);\r\n}\r\nstatic void spca504A_acknowledged_command(struct gspca_dev *gspca_dev,\r\nu8 req,\r\nu16 idx, u16 val, u8 endcode, u8 count)\r\n{\r\nu16 status;\r\nreg_w_riv(gspca_dev, req, idx, val);\r\nreg_r(gspca_dev, 0x01, 0x0001, 1);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_FRAM, "Status 0x%02x Need 0x%02x",\r\ngspca_dev->usb_buf[0], endcode);\r\nif (!count)\r\nreturn;\r\ncount = 200;\r\nwhile (--count > 0) {\r\nmsleep(10);\r\nreg_r(gspca_dev, 0x01, 0x0001, 1);\r\nstatus = gspca_dev->usb_buf[0];\r\nif (status == endcode) {\r\nPDEBUG(D_FRAM, "status 0x%04x after wait %d",\r\nstatus, 200 - count);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void spca504B_PollingDataReady(struct gspca_dev *gspca_dev)\r\n{\r\nint count = 10;\r\nwhile (--count > 0) {\r\nreg_r(gspca_dev, 0x21, 0, 1);\r\nif ((gspca_dev->usb_buf[0] & 0x01) == 0)\r\nbreak;\r\nmsleep(10);\r\n}\r\n}\r\nstatic void spca504B_WaitCmdStatus(struct gspca_dev *gspca_dev)\r\n{\r\nint count = 50;\r\nwhile (--count > 0) {\r\nreg_r(gspca_dev, 0x21, 1, 1);\r\nif (gspca_dev->usb_buf[0] != 0) {\r\nreg_w_1(gspca_dev, 0x21, 0, 1, 0);\r\nreg_r(gspca_dev, 0x21, 1, 1);\r\nspca504B_PollingDataReady(gspca_dev);\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\n}\r\nstatic void spca50x_GetFirmware(struct gspca_dev *gspca_dev)\r\n{\r\nu8 *data;\r\nif (gspca_debug < D_STREAM)\r\nreturn;\r\ndata = gspca_dev->usb_buf;\r\nreg_r(gspca_dev, 0x20, 0, 5);\r\nPDEBUG(D_STREAM, "FirmWare: %d %d %d %d %d",\r\ndata[0], data[1], data[2], data[3], data[4]);\r\nreg_r(gspca_dev, 0x23, 0, 64);\r\nreg_r(gspca_dev, 0x23, 1, 64);\r\n}\r\nstatic void spca504B_SetSizeType(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 Size;\r\nSize = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_SPCA533:\r\nreg_w_riv(gspca_dev, 0x31, 0, 0);\r\nspca504B_WaitCmdStatus(gspca_dev);\r\nspca504B_PollingDataReady(gspca_dev);\r\nspca50x_GetFirmware(gspca_dev);\r\nreg_w_1(gspca_dev, 0x24, 0, 8, 2);\r\nreg_r(gspca_dev, 0x24, 8, 1);\r\nreg_w_1(gspca_dev, 0x25, 0, 4, Size);\r\nreg_r(gspca_dev, 0x25, 4, 1);\r\nspca504B_PollingDataReady(gspca_dev);\r\nreg_w_riv(gspca_dev, 0x31, 0x0004, 0x00);\r\nspca504B_WaitCmdStatus(gspca_dev);\r\nspca504B_PollingDataReady(gspca_dev);\r\nbreak;\r\ndefault:\r\nreg_w_1(gspca_dev, 0x25, 0, 4, Size);\r\nreg_r(gspca_dev, 0x25, 4, 1);\r\nreg_w_1(gspca_dev, 0x27, 0, 0, 6);\r\nreg_r(gspca_dev, 0x27, 0, 1);\r\nspca504B_PollingDataReady(gspca_dev);\r\nbreak;\r\ncase BRIDGE_SPCA504:\r\nSize += 3;\r\nif (sd->subtype == AiptekMiniPenCam13) {\r\nspca504A_acknowledged_command(gspca_dev,\r\n0x08, Size, 0,\r\n0x80 | (Size & 0x0f), 1);\r\nspca504A_acknowledged_command(gspca_dev,\r\n1, 3, 0, 0x9f, 0);\r\n} else {\r\nspca504_acknowledged_command(gspca_dev, 0x08, Size, 0);\r\n}\r\nbreak;\r\ncase BRIDGE_SPCA504C:\r\nreg_w_riv(gspca_dev, 0xa0, (0x0500 | (Size & 0x0f)), 0x00);\r\nreg_w_riv(gspca_dev, 0x20, 0x01, 0x0500 | (Size & 0x0f));\r\nbreak;\r\n}\r\n}\r\nstatic void spca504_wait_status(struct gspca_dev *gspca_dev)\r\n{\r\nint cnt;\r\ncnt = 256;\r\nwhile (--cnt > 0) {\r\nreg_r(gspca_dev, 0x06, 0x00, 1);\r\nif (gspca_dev->usb_buf[0] == 0)\r\nreturn;\r\nmsleep(10);\r\n}\r\n}\r\nstatic void spca504B_setQtable(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w_1(gspca_dev, 0x26, 0, 0, 3);\r\nreg_r(gspca_dev, 0x26, 0, 1);\r\nspca504B_PollingDataReady(gspca_dev);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 reg;\r\nreg = sd->bridge == BRIDGE_SPCA536 ? 0x20f0 : 0x21a7;\r\nreg_w_riv(gspca_dev, 0x00, reg, val);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 reg;\r\nreg = sd->bridge == BRIDGE_SPCA536 ? 0x20f1 : 0x21a8;\r\nreg_w_riv(gspca_dev, 0x00, reg, val);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 reg;\r\nreg = sd->bridge == BRIDGE_SPCA536 ? 0x20f6 : 0x21ae;\r\nreg_w_riv(gspca_dev, 0x00, reg, val);\r\n}\r\nstatic void init_ctl_reg(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint pollreg = 1;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_SPCA504:\r\ncase BRIDGE_SPCA504C:\r\npollreg = 0;\r\ndefault:\r\nreg_w_riv(gspca_dev, 0, 0x21ad, 0x00);\r\nreg_w_riv(gspca_dev, 0, 0x21ac, 0x01);\r\nreg_w_riv(gspca_dev, 0, 0x21a3, 0x00);\r\nbreak;\r\ncase BRIDGE_SPCA536:\r\nreg_w_riv(gspca_dev, 0, 0x20f5, 0x40);\r\nreg_w_riv(gspca_dev, 0, 0x20f4, 0x01);\r\nreg_w_riv(gspca_dev, 0, 0x2089, 0x00);\r\nbreak;\r\n}\r\nif (pollreg)\r\nspca504B_PollingDataReady(gspca_dev);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\nsd->bridge = id->driver_info >> 8;\r\nsd->subtype = id->driver_info;\r\nif (sd->subtype == AiptekMiniPenCam13) {\r\nreg_r(gspca_dev, 0x20, 0, 1);\r\nswitch (gspca_dev->usb_buf[0]) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nsd->bridge = BRIDGE_SPCA504B;\r\nsd->subtype = 0;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nswitch (sd->bridge) {\r\ndefault:\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nbreak;\r\ncase BRIDGE_SPCA533:\r\ncam->cam_mode = custom_mode;\r\nif (sd->subtype == MegaImageVI)\r\ncam->nmodes = ARRAY_SIZE(custom_mode) - 1;\r\nelse\r\ncam->nmodes = ARRAY_SIZE(custom_mode);\r\nbreak;\r\ncase BRIDGE_SPCA504C:\r\ncam->cam_mode = vga_mode2;\r\ncam->nmodes = ARRAY_SIZE(vga_mode2);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_SPCA504B:\r\nreg_w_riv(gspca_dev, 0x1d, 0x00, 0);\r\nreg_w_riv(gspca_dev, 0x00, 0x2306, 0x01);\r\nreg_w_riv(gspca_dev, 0x00, 0x0d04, 0x00);\r\nreg_w_riv(gspca_dev, 0x00, 0x2000, 0x00);\r\nreg_w_riv(gspca_dev, 0x00, 0x2301, 0x13);\r\nreg_w_riv(gspca_dev, 0x00, 0x2306, 0x00);\r\ncase BRIDGE_SPCA533:\r\nspca504B_PollingDataReady(gspca_dev);\r\nspca50x_GetFirmware(gspca_dev);\r\nbreak;\r\ncase BRIDGE_SPCA536:\r\nspca50x_GetFirmware(gspca_dev);\r\nreg_r(gspca_dev, 0x00, 0x5002, 1);\r\nreg_w_1(gspca_dev, 0x24, 0, 0, 0);\r\nreg_r(gspca_dev, 0x24, 0, 1);\r\nspca504B_PollingDataReady(gspca_dev);\r\nreg_w_riv(gspca_dev, 0x34, 0, 0);\r\nspca504B_WaitCmdStatus(gspca_dev);\r\nbreak;\r\ncase BRIDGE_SPCA504C:\r\nPDEBUG(D_STREAM, "Opening SPCA504 (PC-CAM 600)");\r\nreg_w_riv(gspca_dev, 0xe0, 0x0000, 0x0000);\r\nreg_w_riv(gspca_dev, 0xe0, 0x0000, 0x0001);\r\nspca504_wait_status(gspca_dev);\r\nif (sd->subtype == LogitechClickSmart420)\r\nwrite_vector(gspca_dev,\r\nspca504A_clicksmart420_open_data,\r\nARRAY_SIZE(spca504A_clicksmart420_open_data));\r\nelse\r\nwrite_vector(gspca_dev, spca504_pccam600_open_data,\r\nARRAY_SIZE(spca504_pccam600_open_data));\r\nsetup_qtable(gspca_dev, qtable_creative_pccam);\r\nbreak;\r\ndefault:\r\nPDEBUG(D_STREAM, "Opening SPCA504");\r\nif (sd->subtype == AiptekMiniPenCam13) {\r\nspca504_read_info(gspca_dev);\r\nspca504A_acknowledged_command(gspca_dev, 0x24,\r\n8, 3, 0x9e, 1);\r\nspca504A_acknowledged_command(gspca_dev, 0x24,\r\n8, 3, 0x9e, 0);\r\nspca504A_acknowledged_command(gspca_dev, 0x24,\r\n0, 0, 0x9d, 1);\r\nspca504A_acknowledged_command(gspca_dev, 0x08,\r\n6, 0, 0x86, 1);\r\nreg_w_riv(gspca_dev, 0x00, 0x270c, 0x05);\r\nreg_w_riv(gspca_dev, 0x00, 0x2310, 0x05);\r\nspca504A_acknowledged_command(gspca_dev, 0x01,\r\n0x0f, 0, 0xff, 0);\r\n}\r\nreg_w_riv(gspca_dev, 0, 0x2000, 0);\r\nreg_w_riv(gspca_dev, 0, 0x2883, 1);\r\nsetup_qtable(gspca_dev, qtable_spca504_default);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint enable;\r\njpeg_define(sd->jpeg_hdr, gspca_dev->height, gspca_dev->width,\r\n0x22);\r\njpeg_set_qual(sd->jpeg_hdr, QUALITY);\r\nif (sd->bridge == BRIDGE_SPCA504B)\r\nspca504B_setQtable(gspca_dev);\r\nspca504B_SetSizeType(gspca_dev);\r\nswitch (sd->bridge) {\r\ndefault:\r\nswitch (sd->subtype) {\r\ncase MegapixV4:\r\ncase LogitechClickSmart820:\r\ncase MegaImageVI:\r\nreg_w_riv(gspca_dev, 0xf0, 0, 0);\r\nspca504B_WaitCmdStatus(gspca_dev);\r\nreg_r(gspca_dev, 0xf0, 4, 0);\r\nspca504B_WaitCmdStatus(gspca_dev);\r\nbreak;\r\ndefault:\r\nreg_w_riv(gspca_dev, 0x31, 0x0004, 0x00);\r\nspca504B_WaitCmdStatus(gspca_dev);\r\nspca504B_PollingDataReady(gspca_dev);\r\nbreak;\r\n}\r\nbreak;\r\ncase BRIDGE_SPCA504:\r\nif (sd->subtype == AiptekMiniPenCam13) {\r\nspca504_read_info(gspca_dev);\r\nspca504A_acknowledged_command(gspca_dev, 0x24,\r\n8, 3, 0x9e, 1);\r\nspca504A_acknowledged_command(gspca_dev, 0x24,\r\n8, 3, 0x9e, 0);\r\nspca504A_acknowledged_command(gspca_dev, 0x24,\r\n0, 0, 0x9d, 1);\r\n} else {\r\nspca504_acknowledged_command(gspca_dev, 0x24, 8, 3);\r\nspca504_read_info(gspca_dev);\r\nspca504_acknowledged_command(gspca_dev, 0x24, 8, 3);\r\nspca504_acknowledged_command(gspca_dev, 0x24, 0, 0);\r\n}\r\nspca504B_SetSizeType(gspca_dev);\r\nreg_w_riv(gspca_dev, 0x00, 0x270c, 0x05);\r\nreg_w_riv(gspca_dev, 0x00, 0x2310, 0x05);\r\nbreak;\r\ncase BRIDGE_SPCA504C:\r\nif (sd->subtype == LogitechClickSmart420) {\r\nwrite_vector(gspca_dev,\r\nspca504A_clicksmart420_init_data,\r\nARRAY_SIZE(spca504A_clicksmart420_init_data));\r\n} else {\r\nwrite_vector(gspca_dev, spca504_pccam600_init_data,\r\nARRAY_SIZE(spca504_pccam600_init_data));\r\n}\r\nenable = (sd->autogain ? 0x04 : 0x01);\r\nreg_w_riv(gspca_dev, 0x0c, 0x0000, enable);\r\nreg_w_riv(gspca_dev, 0xb0, 0x0000, enable);\r\nreg_w_riv(gspca_dev, 0x30, 0x0001, 800);\r\nreg_w_riv(gspca_dev, 0x30, 0x0002, 1600);\r\nspca504B_SetSizeType(gspca_dev);\r\nbreak;\r\n}\r\ninit_ctl_reg(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->bridge) {\r\ndefault:\r\nreg_w_riv(gspca_dev, 0x31, 0, 0);\r\nspca504B_WaitCmdStatus(gspca_dev);\r\nspca504B_PollingDataReady(gspca_dev);\r\nbreak;\r\ncase BRIDGE_SPCA504:\r\ncase BRIDGE_SPCA504C:\r\nreg_w_riv(gspca_dev, 0x00, 0x2000, 0x0000);\r\nif (sd->subtype == AiptekMiniPenCam13) {\r\nspca504A_acknowledged_command(gspca_dev, 0x24,\r\n0x00, 0x00, 0x9d, 1);\r\nspca504A_acknowledged_command(gspca_dev, 0x01,\r\n0x0f, 0x00, 0xff, 1);\r\n} else {\r\nspca504_acknowledged_command(gspca_dev, 0x24, 0, 0);\r\nreg_w_riv(gspca_dev, 0x01, 0x000f, 0x0000);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, sof = 0;\r\nstatic u8 ffd9[] = {0xff, 0xd9};\r\nswitch (sd->bridge) {\r\ncase BRIDGE_SPCA533:\r\nif (data[0] == 0xff) {\r\nif (data[1] != 0x01) {\r\nreturn;\r\n}\r\nsof = 1;\r\ndata += SPCA533_OFFSET_DATA;\r\nlen -= SPCA533_OFFSET_DATA;\r\n} else {\r\ndata += 1;\r\nlen -= 1;\r\n}\r\nbreak;\r\ncase BRIDGE_SPCA536:\r\nif (data[0] == 0xff) {\r\nsof = 1;\r\ndata += SPCA536_OFFSET_DATA;\r\nlen -= SPCA536_OFFSET_DATA;\r\n} else {\r\ndata += 2;\r\nlen -= 2;\r\n}\r\nbreak;\r\ndefault:\r\nswitch (data[0]) {\r\ncase 0xfe:\r\nsof = 1;\r\ndata += SPCA50X_OFFSET_DATA;\r\nlen -= SPCA50X_OFFSET_DATA;\r\nbreak;\r\ncase 0xff:\r\nreturn;\r\ndefault:\r\ndata += 1;\r\nlen -= 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase BRIDGE_SPCA504C:\r\nswitch (data[0]) {\r\ncase 0xfe:\r\nsof = 1;\r\ndata += SPCA504_PCCAM600_OFFSET_DATA;\r\nlen -= SPCA504_PCCAM600_OFFSET_DATA;\r\nbreak;\r\ncase 0xff:\r\nreturn;\r\ndefault:\r\ndata += 1;\r\nlen -= 1;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (sof) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nffd9, 2);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\n}\r\ni = 0;\r\ndo {\r\nif (data[i] == 0xff) {\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata, i + 1);\r\nlen -= i;\r\ndata += i;\r\n*data = 0x00;\r\ni = 0;\r\n}\r\ni++;\r\n} while (i < len);\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nsd->autogain = ctrl->val;\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 0x20);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 0x1a);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
