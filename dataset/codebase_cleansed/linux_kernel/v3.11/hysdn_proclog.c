void\r\nhysdn_card_errlog(hysdn_card *card, tErrLogEntry *logp, int maxsize)\r\n{\r\nchar buf[ERRLOG_TEXT_SIZE + 40];\r\nsprintf(buf, "LOG 0x%08lX 0x%08lX : %s\n", logp->ulErrType, logp->ulErrSubtype, logp->ucText);\r\nput_log_buffer(card, buf);\r\n}\r\nvoid\r\nhysdn_addlog(hysdn_card *card, char *fmt, ...)\r\n{\r\nstruct procdata *pd = card->proclog;\r\nchar *cp;\r\nva_list args;\r\nif (!pd)\r\nreturn;\r\ncp = pd->logtmp;\r\ncp += sprintf(cp, "HYSDN: card %d ", card->myid);\r\nva_start(args, fmt);\r\ncp += vsprintf(cp, fmt, args);\r\nva_end(args);\r\n*cp++ = '\n';\r\n*cp = 0;\r\nif (card->debug_flags & DEB_OUT_SYSLOG)\r\nprintk(KERN_INFO "%s", pd->logtmp);\r\nelse\r\nput_log_buffer(card, pd->logtmp);\r\n}\r\nstatic void\r\nput_log_buffer(hysdn_card *card, char *cp)\r\n{\r\nstruct log_data *ib;\r\nstruct procdata *pd = card->proclog;\r\nint i;\r\nunsigned long flags;\r\nif (!pd)\r\nreturn;\r\nif (!cp)\r\nreturn;\r\nif (!*cp)\r\nreturn;\r\nif (pd->if_used <= 0)\r\nreturn;\r\nif (!(ib = kmalloc(sizeof(struct log_data) + strlen(cp), GFP_ATOMIC)))\r\nreturn;\r\nstrcpy(ib->log_start, cp);\r\nib->next = NULL;\r\nib->proc_ctrl = pd;\r\nspin_lock_irqsave(&card->hysdn_lock, flags);\r\nib->usage_cnt = pd->if_used;\r\nif (!pd->log_head)\r\npd->log_head = ib;\r\nelse\r\npd->log_tail->next = ib;\r\npd->log_tail = ib;\r\ni = pd->del_lock++;\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\nif (!i)\r\nwhile (pd->log_head->next) {\r\nif ((pd->log_head->usage_cnt <= 0) &&\r\n(pd->log_head->next->usage_cnt <= 0)) {\r\nib = pd->log_head;\r\npd->log_head = pd->log_head->next;\r\nkfree(ib);\r\n} else\r\nbreak;\r\n}\r\npd->del_lock--;\r\nwake_up_interruptible(&(pd->rd_queue));\r\n}\r\nstatic ssize_t\r\nhysdn_log_write(struct file *file, const char __user *buf, size_t count, loff_t *off)\r\n{\r\nint rc;\r\nhysdn_card *card = file->private_data;\r\nrc = kstrtoul_from_user(buf, count, 0, &card->debug_flags);\r\nif (rc < 0)\r\nreturn rc;\r\nhysdn_addlog(card, "debug set to 0x%lx", card->debug_flags);\r\nreturn (count);\r\n}\r\nstatic ssize_t\r\nhysdn_log_read(struct file *file, char __user *buf, size_t count, loff_t *off)\r\n{\r\nstruct log_data *inf;\r\nint len;\r\nhysdn_card *card = PDE_DATA(file_inode(file));\r\nif (!*((struct log_data **) file->private_data)) {\r\nstruct procdata *pd = card->proclog;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn (-EAGAIN);\r\ninterruptible_sleep_on(&(pd->rd_queue));\r\n}\r\nif (!(inf = *((struct log_data **) file->private_data)))\r\nreturn (0);\r\ninf->usage_cnt--;\r\nfile->private_data = &inf->next;\r\nif ((len = strlen(inf->log_start)) <= count) {\r\nif (copy_to_user(buf, inf->log_start, len))\r\nreturn -EFAULT;\r\n*off += len;\r\nreturn (len);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nhysdn_log_open(struct inode *ino, struct file *filep)\r\n{\r\nhysdn_card *card = PDE_DATA(ino);\r\nmutex_lock(&hysdn_log_mutex);\r\nif ((filep->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_WRITE) {\r\nfilep->private_data = card;\r\n} else if ((filep->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) {\r\nstruct procdata *pd = card->proclog;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->hysdn_lock, flags);\r\npd->if_used++;\r\nif (pd->log_head)\r\nfilep->private_data = &pd->log_tail->next;\r\nelse\r\nfilep->private_data = &pd->log_head;\r\nspin_unlock_irqrestore(&card->hysdn_lock, flags);\r\n} else {\r\nmutex_unlock(&hysdn_log_mutex);\r\nreturn (-EPERM);\r\n}\r\nmutex_unlock(&hysdn_log_mutex);\r\nreturn nonseekable_open(ino, filep);\r\n}\r\nstatic int\r\nhysdn_log_close(struct inode *ino, struct file *filep)\r\n{\r\nstruct log_data *inf;\r\nstruct procdata *pd;\r\nhysdn_card *card;\r\nint retval = 0;\r\nmutex_lock(&hysdn_log_mutex);\r\nif ((filep->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_WRITE) {\r\nretval = 0;\r\n} else {\r\ninf = *((struct log_data **) filep->private_data);\r\nif (inf)\r\npd = (struct procdata *) inf->proc_ctrl;\r\nelse {\r\ncard = PDE_DATA(file_inode(filep));\r\npd = card->proclog;\r\n}\r\nif (pd)\r\npd->if_used--;\r\nwhile (inf) {\r\ninf->usage_cnt--;\r\ninf = inf->next;\r\n}\r\nif (pd)\r\nif (pd->if_used <= 0)\r\nwhile (pd->log_head) {\r\ninf = pd->log_head;\r\npd->log_head = pd->log_head->next;\r\nkfree(inf);\r\n}\r\n}\r\nmutex_unlock(&hysdn_log_mutex);\r\nreturn (retval);\r\n}\r\nstatic unsigned int\r\nhysdn_log_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\nhysdn_card *card = PDE_DATA(file_inode(file));\r\nstruct procdata *pd = card->proclog;\r\nif ((file->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_WRITE)\r\nreturn (mask);\r\npoll_wait(file, &(pd->rd_queue), wait);\r\nif (*((struct log_data **) file->private_data))\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nint\r\nhysdn_proclog_init(hysdn_card *card)\r\n{\r\nstruct procdata *pd;\r\nif ((pd = kzalloc(sizeof(struct procdata), GFP_KERNEL)) != NULL) {\r\nsprintf(pd->log_name, "%s%d", PROC_LOG_BASENAME, card->myid);\r\npd->log = proc_create_data(pd->log_name,\r\nS_IFREG | S_IRUGO | S_IWUSR, hysdn_proc_entry,\r\n&log_fops, card);\r\ninit_waitqueue_head(&(pd->rd_queue));\r\ncard->proclog = (void *) pd;\r\n}\r\nreturn (0);\r\n}\r\nvoid\r\nhysdn_proclog_release(hysdn_card *card)\r\n{\r\nstruct procdata *pd;\r\nif ((pd = (struct procdata *) card->proclog) != NULL) {\r\nif (pd->log)\r\nremove_proc_entry(pd->log_name, hysdn_proc_entry);\r\nkfree(pd);\r\ncard->proclog = NULL;\r\n}\r\n}
