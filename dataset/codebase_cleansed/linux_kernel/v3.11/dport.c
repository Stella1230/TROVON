static int\r\ndp_set_link_config(struct dp_state *dp)\r\n{\r\nstruct nouveau_disp *disp = dp->disp;\r\nstruct nouveau_bios *bios = nouveau_bios(disp);\r\nstruct nvbios_init init = {\r\n.subdev = nv_subdev(dp->disp),\r\n.bios = bios,\r\n.offset = 0x0000,\r\n.outp = dp->outp,\r\n.crtc = dp->head,\r\n.execute = 1,\r\n};\r\nu32 lnkcmp;\r\nu8 sink[2];\r\nDBG("%d lanes at %d KB/s\n", dp->link_nr, dp->link_bw);\r\nsink[0] = dp->link_bw / 27000;\r\nsink[1] = dp->link_nr;\r\nif (dp->dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP)\r\nsink[1] |= DPCD_LC01_ENHANCED_FRAME_EN;\r\nnv_wraux(dp->aux, DPCD_LC00, sink, 2);\r\nif ((lnkcmp = dp->info.lnkcmp)) {\r\nif (dp->version < 0x30) {\r\nwhile ((dp->link_bw / 10) < nv_ro16(bios, lnkcmp))\r\nlnkcmp += 4;\r\ninit.offset = nv_ro16(bios, lnkcmp + 2);\r\n} else {\r\nwhile ((dp->link_bw / 27000) < nv_ro08(bios, lnkcmp))\r\nlnkcmp += 3;\r\ninit.offset = nv_ro16(bios, lnkcmp + 1);\r\n}\r\nnvbios_exec(&init);\r\n}\r\nreturn dp->func->lnk_ctl(dp->disp, dp->outp, dp->head,\r\ndp->link_nr, dp->link_bw / 27000,\r\ndp->dpcd[DPCD_RC02] &\r\nDPCD_RC02_ENHANCED_FRAME_CAP);\r\n}\r\nstatic void\r\ndp_set_training_pattern(struct dp_state *dp, u8 pattern)\r\n{\r\nu8 sink_tp;\r\nDBG("training pattern %d\n", pattern);\r\ndp->func->pattern(dp->disp, dp->outp, dp->head, pattern);\r\nnv_rdaux(dp->aux, DPCD_LC02, &sink_tp, 1);\r\nsink_tp &= ~DPCD_LC02_TRAINING_PATTERN_SET;\r\nsink_tp |= pattern;\r\nnv_wraux(dp->aux, DPCD_LC02, &sink_tp, 1);\r\n}\r\nstatic int\r\ndp_link_train_commit(struct dp_state *dp)\r\n{\r\nint i;\r\nfor (i = 0; i < dp->link_nr; i++) {\r\nu8 lane = (dp->stat[4 + (i >> 1)] >> ((i & 1) * 4)) & 0xf;\r\nu8 lpre = (lane & 0x0c) >> 2;\r\nu8 lvsw = (lane & 0x03) >> 0;\r\ndp->conf[i] = (lpre << 3) | lvsw;\r\nif (lvsw == 3)\r\ndp->conf[i] |= DPCD_LC03_MAX_SWING_REACHED;\r\nif (lpre == 3)\r\ndp->conf[i] |= DPCD_LC03_MAX_PRE_EMPHASIS_REACHED;\r\nDBG("config lane %d %02x\n", i, dp->conf[i]);\r\ndp->func->drv_ctl(dp->disp, dp->outp, dp->head, i, lvsw, lpre);\r\n}\r\nreturn nv_wraux(dp->aux, DPCD_LC03(0), dp->conf, 4);\r\n}\r\nstatic int\r\ndp_link_train_update(struct dp_state *dp, u32 delay)\r\n{\r\nint ret;\r\nudelay(delay);\r\nret = nv_rdaux(dp->aux, DPCD_LS02, dp->stat, 6);\r\nif (ret)\r\nreturn ret;\r\nDBG("status %*ph\n", 6, dp->stat);\r\nreturn 0;\r\n}\r\nstatic int\r\ndp_link_train_cr(struct dp_state *dp)\r\n{\r\nbool cr_done = false, abort = false;\r\nint voltage = dp->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET;\r\nint tries = 0, i;\r\ndp_set_training_pattern(dp, 1);\r\ndo {\r\nif (dp_link_train_commit(dp) ||\r\ndp_link_train_update(dp, 100))\r\nbreak;\r\ncr_done = true;\r\nfor (i = 0; i < dp->link_nr; i++) {\r\nu8 lane = (dp->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;\r\nif (!(lane & DPCD_LS02_LANE0_CR_DONE)) {\r\ncr_done = false;\r\nif (dp->conf[i] & DPCD_LC03_MAX_SWING_REACHED)\r\nabort = true;\r\nbreak;\r\n}\r\n}\r\nif ((dp->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET) != voltage) {\r\nvoltage = dp->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET;\r\ntries = 0;\r\n}\r\n} while (!cr_done && !abort && ++tries < 5);\r\nreturn cr_done ? 0 : -1;\r\n}\r\nstatic int\r\ndp_link_train_eq(struct dp_state *dp)\r\n{\r\nbool eq_done = false, cr_done = true;\r\nint tries = 0, i;\r\ndp_set_training_pattern(dp, 2);\r\ndo {\r\nif (dp_link_train_update(dp, 400))\r\nbreak;\r\neq_done = !!(dp->stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE);\r\nfor (i = 0; i < dp->link_nr && eq_done; i++) {\r\nu8 lane = (dp->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;\r\nif (!(lane & DPCD_LS02_LANE0_CR_DONE))\r\ncr_done = false;\r\nif (!(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||\r\n!(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED))\r\neq_done = false;\r\n}\r\nif (dp_link_train_commit(dp))\r\nbreak;\r\n} while (!eq_done && cr_done && ++tries <= 5);\r\nreturn eq_done ? 0 : -1;\r\n}\r\nstatic void\r\ndp_link_train_init(struct dp_state *dp, bool spread)\r\n{\r\nstruct nvbios_init init = {\r\n.subdev = nv_subdev(dp->disp),\r\n.bios = nouveau_bios(dp->disp),\r\n.outp = dp->outp,\r\n.crtc = dp->head,\r\n.execute = 1,\r\n};\r\nif (spread)\r\ninit.offset = dp->info.script[2];\r\nelse\r\ninit.offset = dp->info.script[3];\r\nnvbios_exec(&init);\r\ninit.offset = dp->info.script[0];\r\nnvbios_exec(&init);\r\n}\r\nstatic void\r\ndp_link_train_fini(struct dp_state *dp)\r\n{\r\nstruct nvbios_init init = {\r\n.subdev = nv_subdev(dp->disp),\r\n.bios = nouveau_bios(dp->disp),\r\n.outp = dp->outp,\r\n.crtc = dp->head,\r\n.execute = 1,\r\n};\r\ninit.offset = dp->info.script[1],\r\nnvbios_exec(&init);\r\n}\r\nint\r\nnouveau_dp_train(struct nouveau_disp *disp, const struct nouveau_dp_func *func,\r\nstruct dcb_output *outp, int head, u32 datarate)\r\n{\r\nstruct nouveau_bios *bios = nouveau_bios(disp);\r\nstruct nouveau_i2c *i2c = nouveau_i2c(disp);\r\nstruct dp_state _dp = {\r\n.disp = disp,\r\n.func = func,\r\n.outp = outp,\r\n.head = head,\r\n}, *dp = &_dp;\r\nconst u32 bw_list[] = { 270000, 162000, 0 };\r\nconst u32 *link_bw = bw_list;\r\nu8 hdr, cnt, len;\r\nu32 data;\r\nint ret;\r\ndata = nvbios_dpout_match(bios, outp->hasht, outp->hashm, &dp->version,\r\n&hdr, &cnt, &len, &dp->info);\r\nif (!data) {\r\nERR("bios data not found\n");\r\nreturn -EINVAL;\r\n}\r\nif (outp->location)\r\ndp->aux = i2c->find_type(i2c, NV_I2C_TYPE_EXTAUX(outp->extdev));\r\nelse\r\ndp->aux = i2c->find(i2c, NV_I2C_TYPE_DCBI2C(outp->i2c_index));\r\nif (!dp->aux) {\r\nERR("no aux channel?!\n");\r\nreturn -ENODEV;\r\n}\r\nret = nv_rdaux(dp->aux, 0x00000, dp->dpcd, sizeof(dp->dpcd));\r\nif (ret) {\r\nERR("failed to read DPCD\n");\r\nreturn ret;\r\n}\r\ndatarate = (datarate / 8) * 10;\r\ndp_link_train_init(dp, dp->dpcd[3] & 0x01);\r\nwhile (*link_bw > (dp->dpcd[1] * 27000))\r\nlink_bw++;\r\nwhile (link_bw[0]) {\r\ndp->link_nr = dp->dpcd[2] & DPCD_RC02_MAX_LANE_COUNT;\r\nwhile ((dp->link_nr >> 1) * link_bw[0] > datarate)\r\ndp->link_nr >>= 1;\r\nwhile ((link_bw[1] * dp->link_nr) > datarate)\r\nlink_bw++;\r\ndp->link_bw = link_bw[0];\r\nret = dp_set_link_config(dp);\r\nif (ret == 0) {\r\nmemset(dp->stat, 0x00, sizeof(dp->stat));\r\nif (!dp_link_train_cr(dp) &&\r\n!dp_link_train_eq(dp))\r\nbreak;\r\n} else\r\nif (ret >= 1) {\r\nbreak;\r\n}\r\nlink_bw++;\r\n}\r\ndp_set_training_pattern(dp, 0);\r\ndp_link_train_fini(dp);\r\nreturn true;\r\n}
