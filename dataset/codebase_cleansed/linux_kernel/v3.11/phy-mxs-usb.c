static void mxs_phy_hw_init(struct mxs_phy *mxs_phy)\r\n{\r\nvoid __iomem *base = mxs_phy->phy.io_priv;\r\nstmp_reset_block(base + HW_USBPHY_CTRL);\r\nwritel(0, base + HW_USBPHY_PWD);\r\nwritel(BM_USBPHY_CTRL_ENUTMILEVEL2 |\r\nBM_USBPHY_CTRL_ENUTMILEVEL3,\r\nbase + HW_USBPHY_CTRL_SET);\r\n}\r\nstatic int mxs_phy_init(struct usb_phy *phy)\r\n{\r\nstruct mxs_phy *mxs_phy = to_mxs_phy(phy);\r\nclk_prepare_enable(mxs_phy->clk);\r\nmxs_phy_hw_init(mxs_phy);\r\nreturn 0;\r\n}\r\nstatic void mxs_phy_shutdown(struct usb_phy *phy)\r\n{\r\nstruct mxs_phy *mxs_phy = to_mxs_phy(phy);\r\nwritel(BM_USBPHY_CTRL_CLKGATE,\r\nphy->io_priv + HW_USBPHY_CTRL_SET);\r\nclk_disable_unprepare(mxs_phy->clk);\r\n}\r\nstatic int mxs_phy_suspend(struct usb_phy *x, int suspend)\r\n{\r\nstruct mxs_phy *mxs_phy = to_mxs_phy(x);\r\nif (suspend) {\r\nwritel(0xffffffff, x->io_priv + HW_USBPHY_PWD);\r\nwritel(BM_USBPHY_CTRL_CLKGATE,\r\nx->io_priv + HW_USBPHY_CTRL_SET);\r\nclk_disable_unprepare(mxs_phy->clk);\r\n} else {\r\nclk_prepare_enable(mxs_phy->clk);\r\nwritel(BM_USBPHY_CTRL_CLKGATE,\r\nx->io_priv + HW_USBPHY_CTRL_CLR);\r\nwritel(0, x->io_priv + HW_USBPHY_PWD);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_on_connect(struct usb_phy *phy,\r\nenum usb_device_speed speed)\r\n{\r\ndev_dbg(phy->dev, "%s speed device has connected\n",\r\n(speed == USB_SPEED_HIGH) ? "high" : "non-high");\r\nif (speed == USB_SPEED_HIGH)\r\nwritel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,\r\nphy->io_priv + HW_USBPHY_CTRL_SET);\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_on_disconnect(struct usb_phy *phy,\r\nenum usb_device_speed speed)\r\n{\r\ndev_dbg(phy->dev, "%s speed device has disconnected\n",\r\n(speed == USB_SPEED_HIGH) ? "high" : "non-high");\r\nif (speed == USB_SPEED_HIGH)\r\nwritel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,\r\nphy->io_priv + HW_USBPHY_CTRL_CLR);\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct clk *clk;\r\nstruct mxs_phy *mxs_phy;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev,\r\n"can't get the clock, err=%ld", PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nmxs_phy = devm_kzalloc(&pdev->dev, sizeof(*mxs_phy), GFP_KERNEL);\r\nif (!mxs_phy) {\r\ndev_err(&pdev->dev, "Failed to allocate USB PHY structure!\n");\r\nreturn -ENOMEM;\r\n}\r\nmxs_phy->phy.io_priv = base;\r\nmxs_phy->phy.dev = &pdev->dev;\r\nmxs_phy->phy.label = DRIVER_NAME;\r\nmxs_phy->phy.init = mxs_phy_init;\r\nmxs_phy->phy.shutdown = mxs_phy_shutdown;\r\nmxs_phy->phy.set_suspend = mxs_phy_suspend;\r\nmxs_phy->phy.notify_connect = mxs_phy_on_connect;\r\nmxs_phy->phy.notify_disconnect = mxs_phy_on_disconnect;\r\nmxs_phy->phy.type = USB_PHY_TYPE_USB2;\r\nATOMIC_INIT_NOTIFIER_HEAD(&mxs_phy->phy.notifier);\r\nmxs_phy->clk = clk;\r\nplatform_set_drvdata(pdev, &mxs_phy->phy);\r\nret = usb_add_phy_dev(&mxs_phy->phy);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mxs_phy_remove(struct platform_device *pdev)\r\n{\r\nstruct mxs_phy *mxs_phy = platform_get_drvdata(pdev);\r\nusb_remove_phy(&mxs_phy->phy);\r\nreturn 0;\r\n}\r\nstatic int __init mxs_phy_module_init(void)\r\n{\r\nreturn platform_driver_register(&mxs_phy_driver);\r\n}\r\nstatic void __exit mxs_phy_module_exit(void)\r\n{\r\nplatform_driver_unregister(&mxs_phy_driver);\r\n}
