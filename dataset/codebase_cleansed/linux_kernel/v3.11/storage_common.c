static inline bool fsg_lun_is_open(struct fsg_lun *curlun)\r\n{\r\nreturn curlun->filp != NULL;\r\n}\r\nstatic inline struct fsg_lun *fsg_lun_from_dev(struct device *dev)\r\n{\r\nreturn container_of(dev, struct fsg_lun, dev);\r\n}\r\nstatic inline int fsg_num_buffers_validate(void)\r\n{\r\nif (fsg_num_buffers >= 2 && fsg_num_buffers <= 4)\r\nreturn 0;\r\npr_err("fsg_num_buffers %u is out of range (%d to %d)\n",\r\nfsg_num_buffers, 2 ,4);\r\nreturn -EINVAL;\r\n}\r\nstatic inline u32 get_unaligned_be24(u8 *buf)\r\n{\r\nreturn 0xffffff & (u32) get_unaligned_be32(buf - 1);\r\n}\r\nstatic void fsg_lun_close(struct fsg_lun *curlun)\r\n{\r\nif (curlun->filp) {\r\nLDBG(curlun, "close backing file\n");\r\nfput(curlun->filp);\r\ncurlun->filp = NULL;\r\n}\r\n}\r\nstatic int fsg_lun_open(struct fsg_lun *curlun, const char *filename)\r\n{\r\nint ro;\r\nstruct file *filp = NULL;\r\nint rc = -EINVAL;\r\nstruct inode *inode = NULL;\r\nloff_t size;\r\nloff_t num_sectors;\r\nloff_t min_sectors;\r\nunsigned int blkbits;\r\nunsigned int blksize;\r\nro = curlun->initially_ro;\r\nif (!ro) {\r\nfilp = filp_open(filename, O_RDWR | O_LARGEFILE, 0);\r\nif (PTR_ERR(filp) == -EROFS || PTR_ERR(filp) == -EACCES)\r\nro = 1;\r\n}\r\nif (ro)\r\nfilp = filp_open(filename, O_RDONLY | O_LARGEFILE, 0);\r\nif (IS_ERR(filp)) {\r\nLINFO(curlun, "unable to open backing file: %s\n", filename);\r\nreturn PTR_ERR(filp);\r\n}\r\nif (!(filp->f_mode & FMODE_WRITE))\r\nro = 1;\r\ninode = file_inode(filp);\r\nif ((!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))) {\r\nLINFO(curlun, "invalid file type: %s\n", filename);\r\ngoto out;\r\n}\r\nif (!(filp->f_op->read || filp->f_op->aio_read)) {\r\nLINFO(curlun, "file not readable: %s\n", filename);\r\ngoto out;\r\n}\r\nif (!(filp->f_op->write || filp->f_op->aio_write))\r\nro = 1;\r\nsize = i_size_read(inode->i_mapping->host);\r\nif (size < 0) {\r\nLINFO(curlun, "unable to find file size: %s\n", filename);\r\nrc = (int) size;\r\ngoto out;\r\n}\r\nif (curlun->cdrom) {\r\nblksize = 2048;\r\nblkbits = 11;\r\n} else if (inode->i_bdev) {\r\nblksize = bdev_logical_block_size(inode->i_bdev);\r\nblkbits = blksize_bits(blksize);\r\n} else {\r\nblksize = 512;\r\nblkbits = 9;\r\n}\r\nnum_sectors = size >> blkbits;\r\nmin_sectors = 1;\r\nif (curlun->cdrom) {\r\nmin_sectors = 300;\r\nif (num_sectors >= 256*60*75) {\r\nnum_sectors = 256*60*75 - 1;\r\nLINFO(curlun, "file too big: %s\n", filename);\r\nLINFO(curlun, "using only first %d blocks\n",\r\n(int) num_sectors);\r\n}\r\n}\r\nif (num_sectors < min_sectors) {\r\nLINFO(curlun, "file too small: %s\n", filename);\r\nrc = -ETOOSMALL;\r\ngoto out;\r\n}\r\nif (fsg_lun_is_open(curlun))\r\nfsg_lun_close(curlun);\r\ncurlun->blksize = blksize;\r\ncurlun->blkbits = blkbits;\r\ncurlun->ro = ro;\r\ncurlun->filp = filp;\r\ncurlun->file_length = size;\r\ncurlun->num_sectors = num_sectors;\r\nLDBG(curlun, "open backing file: %s\n", filename);\r\nreturn 0;\r\nout:\r\nfput(filp);\r\nreturn rc;\r\n}\r\nstatic int fsg_lun_fsync_sub(struct fsg_lun *curlun)\r\n{\r\nstruct file *filp = curlun->filp;\r\nif (curlun->ro || !filp)\r\nreturn 0;\r\nreturn vfs_fsync(filp, 1);\r\n}\r\nstatic void store_cdrom_address(u8 *dest, int msf, u32 addr)\r\n{\r\nif (msf) {\r\naddr >>= 2;\r\naddr += 2*75;\r\ndest[3] = addr % 75;\r\naddr /= 75;\r\ndest[2] = addr % 60;\r\naddr /= 60;\r\ndest[1] = addr;\r\ndest[0] = 0;\r\n} else {\r\nput_unaligned_be32(addr, dest);\r\n}\r\n}\r\nstatic ssize_t fsg_show_ro(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nreturn sprintf(buf, "%d\n", fsg_lun_is_open(curlun)\r\n? curlun->ro\r\n: curlun->initially_ro);\r\n}\r\nstatic ssize_t fsg_show_nofua(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nreturn sprintf(buf, "%u\n", curlun->nofua);\r\n}\r\nstatic ssize_t fsg_show_file(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nstruct rw_semaphore *filesem = dev_get_drvdata(dev);\r\nchar *p;\r\nssize_t rc;\r\ndown_read(filesem);\r\nif (fsg_lun_is_open(curlun)) {\r\np = d_path(&curlun->filp->f_path, buf, PAGE_SIZE - 1);\r\nif (IS_ERR(p))\r\nrc = PTR_ERR(p);\r\nelse {\r\nrc = strlen(p);\r\nmemmove(buf, p, rc);\r\nbuf[rc] = '\n';\r\nbuf[++rc] = 0;\r\n}\r\n} else {\r\n*buf = 0;\r\nrc = 0;\r\n}\r\nup_read(filesem);\r\nreturn rc;\r\n}\r\nstatic ssize_t fsg_store_ro(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nssize_t rc;\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nstruct rw_semaphore *filesem = dev_get_drvdata(dev);\r\nunsigned ro;\r\nrc = kstrtouint(buf, 2, &ro);\r\nif (rc)\r\nreturn rc;\r\ndown_read(filesem);\r\nif (fsg_lun_is_open(curlun)) {\r\nLDBG(curlun, "read-only status change prevented\n");\r\nrc = -EBUSY;\r\n} else {\r\ncurlun->ro = ro;\r\ncurlun->initially_ro = ro;\r\nLDBG(curlun, "read-only status set to %d\n", curlun->ro);\r\nrc = count;\r\n}\r\nup_read(filesem);\r\nreturn rc;\r\n}\r\nstatic ssize_t fsg_store_nofua(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nunsigned nofua;\r\nint ret;\r\nret = kstrtouint(buf, 2, &nofua);\r\nif (ret)\r\nreturn ret;\r\nif (!nofua && curlun->nofua)\r\nfsg_lun_fsync_sub(curlun);\r\ncurlun->nofua = nofua;\r\nreturn count;\r\n}\r\nstatic ssize_t fsg_store_file(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fsg_lun *curlun = fsg_lun_from_dev(dev);\r\nstruct rw_semaphore *filesem = dev_get_drvdata(dev);\r\nint rc = 0;\r\nif (curlun->prevent_medium_removal && fsg_lun_is_open(curlun)) {\r\nLDBG(curlun, "eject attempt prevented\n");\r\nreturn -EBUSY;\r\n}\r\nif (count > 0 && buf[count-1] == '\n')\r\n((char *) buf)[count-1] = 0;\r\ndown_write(filesem);\r\nif (count > 0 && buf[0]) {\r\nrc = fsg_lun_open(curlun, buf);\r\nif (rc == 0)\r\ncurlun->unit_attention_data =\r\nSS_NOT_READY_TO_READY_TRANSITION;\r\n} else if (fsg_lun_is_open(curlun)) {\r\nfsg_lun_close(curlun);\r\ncurlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;\r\n}\r\nup_write(filesem);\r\nreturn (rc < 0 ? rc : count);\r\n}
