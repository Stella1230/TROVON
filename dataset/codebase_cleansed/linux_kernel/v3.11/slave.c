static int dsa_slave_phy_read(struct mii_bus *bus, int addr, int reg)\r\n{\r\nstruct dsa_switch *ds = bus->priv;\r\nif (ds->phys_port_mask & (1 << addr))\r\nreturn ds->drv->phy_read(ds, addr, reg);\r\nreturn 0xffff;\r\n}\r\nstatic int dsa_slave_phy_write(struct mii_bus *bus, int addr, int reg, u16 val)\r\n{\r\nstruct dsa_switch *ds = bus->priv;\r\nif (ds->phys_port_mask & (1 << addr))\r\nreturn ds->drv->phy_write(ds, addr, reg, val);\r\nreturn 0;\r\n}\r\nvoid dsa_slave_mii_bus_init(struct dsa_switch *ds)\r\n{\r\nds->slave_mii_bus->priv = (void *)ds;\r\nds->slave_mii_bus->name = "dsa slave smi";\r\nds->slave_mii_bus->read = dsa_slave_phy_read;\r\nds->slave_mii_bus->write = dsa_slave_phy_write;\r\nsnprintf(ds->slave_mii_bus->id, MII_BUS_ID_SIZE, "dsa-%d:%.2x",\r\nds->index, ds->pd->sw_addr);\r\nds->slave_mii_bus->parent = &ds->master_mii_bus->dev;\r\n}\r\nstatic int dsa_slave_init(struct net_device *dev)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\ndev->iflink = p->parent->dst->master_netdev->ifindex;\r\nreturn 0;\r\n}\r\nstatic int dsa_slave_open(struct net_device *dev)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nstruct net_device *master = p->parent->dst->master_netdev;\r\nint err;\r\nif (!(master->flags & IFF_UP))\r\nreturn -ENETDOWN;\r\nif (!ether_addr_equal(dev->dev_addr, master->dev_addr)) {\r\nerr = dev_uc_add(master, dev->dev_addr);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nif (dev->flags & IFF_ALLMULTI) {\r\nerr = dev_set_allmulti(master, 1);\r\nif (err < 0)\r\ngoto del_unicast;\r\n}\r\nif (dev->flags & IFF_PROMISC) {\r\nerr = dev_set_promiscuity(master, 1);\r\nif (err < 0)\r\ngoto clear_allmulti;\r\n}\r\nreturn 0;\r\nclear_allmulti:\r\nif (dev->flags & IFF_ALLMULTI)\r\ndev_set_allmulti(master, -1);\r\ndel_unicast:\r\nif (!ether_addr_equal(dev->dev_addr, master->dev_addr))\r\ndev_uc_del(master, dev->dev_addr);\r\nout:\r\nreturn err;\r\n}\r\nstatic int dsa_slave_close(struct net_device *dev)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nstruct net_device *master = p->parent->dst->master_netdev;\r\ndev_mc_unsync(master, dev);\r\ndev_uc_unsync(master, dev);\r\nif (dev->flags & IFF_ALLMULTI)\r\ndev_set_allmulti(master, -1);\r\nif (dev->flags & IFF_PROMISC)\r\ndev_set_promiscuity(master, -1);\r\nif (!ether_addr_equal(dev->dev_addr, master->dev_addr))\r\ndev_uc_del(master, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic void dsa_slave_change_rx_flags(struct net_device *dev, int change)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nstruct net_device *master = p->parent->dst->master_netdev;\r\nif (change & IFF_ALLMULTI)\r\ndev_set_allmulti(master, dev->flags & IFF_ALLMULTI ? 1 : -1);\r\nif (change & IFF_PROMISC)\r\ndev_set_promiscuity(master, dev->flags & IFF_PROMISC ? 1 : -1);\r\n}\r\nstatic void dsa_slave_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nstruct net_device *master = p->parent->dst->master_netdev;\r\ndev_mc_sync(master, dev);\r\ndev_uc_sync(master, dev);\r\n}\r\nstatic int dsa_slave_set_mac_address(struct net_device *dev, void *a)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nstruct net_device *master = p->parent->dst->master_netdev;\r\nstruct sockaddr *addr = a;\r\nint err;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nif (!(dev->flags & IFF_UP))\r\ngoto out;\r\nif (!ether_addr_equal(addr->sa_data, master->dev_addr)) {\r\nerr = dev_uc_add(master, addr->sa_data);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (!ether_addr_equal(dev->dev_addr, master->dev_addr))\r\ndev_uc_del(master, dev->dev_addr);\r\nout:\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int dsa_slave_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nif (p->phy != NULL)\r\nreturn phy_mii_ioctl(p->phy, ifr, cmd);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\ndsa_slave_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nint err;\r\nerr = -EOPNOTSUPP;\r\nif (p->phy != NULL) {\r\nerr = phy_read_status(p->phy);\r\nif (err == 0)\r\nerr = phy_ethtool_gset(p->phy, cmd);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\ndsa_slave_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nif (p->phy != NULL)\r\nreturn phy_ethtool_sset(p->phy, cmd);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void dsa_slave_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstrlcpy(drvinfo->driver, "dsa", sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, dsa_driver_version, sizeof(drvinfo->version));\r\nstrlcpy(drvinfo->fw_version, "N/A", sizeof(drvinfo->fw_version));\r\nstrlcpy(drvinfo->bus_info, "platform", sizeof(drvinfo->bus_info));\r\n}\r\nstatic int dsa_slave_nway_reset(struct net_device *dev)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nif (p->phy != NULL)\r\nreturn genphy_restart_aneg(p->phy);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic u32 dsa_slave_get_link(struct net_device *dev)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nif (p->phy != NULL) {\r\ngenphy_update_link(p->phy);\r\nreturn p->phy->link;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void dsa_slave_get_strings(struct net_device *dev,\r\nuint32_t stringset, uint8_t *data)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nstruct dsa_switch *ds = p->parent;\r\nif (stringset == ETH_SS_STATS) {\r\nint len = ETH_GSTRING_LEN;\r\nstrncpy(data, "tx_packets", len);\r\nstrncpy(data + len, "tx_bytes", len);\r\nstrncpy(data + 2 * len, "rx_packets", len);\r\nstrncpy(data + 3 * len, "rx_bytes", len);\r\nif (ds->drv->get_strings != NULL)\r\nds->drv->get_strings(ds, p->port, data + 4 * len);\r\n}\r\n}\r\nstatic void dsa_slave_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats,\r\nuint64_t *data)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nstruct dsa_switch *ds = p->parent;\r\ndata[0] = p->dev->stats.tx_packets;\r\ndata[1] = p->dev->stats.tx_bytes;\r\ndata[2] = p->dev->stats.rx_packets;\r\ndata[3] = p->dev->stats.rx_bytes;\r\nif (ds->drv->get_ethtool_stats != NULL)\r\nds->drv->get_ethtool_stats(ds, p->port, data + 4);\r\n}\r\nstatic int dsa_slave_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nstruct dsa_slave_priv *p = netdev_priv(dev);\r\nstruct dsa_switch *ds = p->parent;\r\nif (sset == ETH_SS_STATS) {\r\nint count;\r\ncount = 4;\r\nif (ds->drv->get_sset_count != NULL)\r\ncount += ds->drv->get_sset_count(ds);\r\nreturn count;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstruct net_device *\r\ndsa_slave_create(struct dsa_switch *ds, struct device *parent,\r\nint port, char *name)\r\n{\r\nstruct net_device *master = ds->dst->master_netdev;\r\nstruct net_device *slave_dev;\r\nstruct dsa_slave_priv *p;\r\nint ret;\r\nslave_dev = alloc_netdev(sizeof(struct dsa_slave_priv),\r\nname, ether_setup);\r\nif (slave_dev == NULL)\r\nreturn slave_dev;\r\nslave_dev->features = master->vlan_features;\r\nSET_ETHTOOL_OPS(slave_dev, &dsa_slave_ethtool_ops);\r\nmemcpy(slave_dev->dev_addr, master->dev_addr, ETH_ALEN);\r\nslave_dev->tx_queue_len = 0;\r\nswitch (ds->dst->tag_protocol) {\r\n#ifdef CONFIG_NET_DSA_TAG_DSA\r\ncase htons(ETH_P_DSA):\r\nslave_dev->netdev_ops = &dsa_netdev_ops;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_EDSA\r\ncase htons(ETH_P_EDSA):\r\nslave_dev->netdev_ops = &edsa_netdev_ops;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_NET_DSA_TAG_TRAILER\r\ncase htons(ETH_P_TRAILER):\r\nslave_dev->netdev_ops = &trailer_netdev_ops;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\nSET_NETDEV_DEV(slave_dev, parent);\r\nslave_dev->vlan_features = master->vlan_features;\r\np = netdev_priv(slave_dev);\r\np->dev = slave_dev;\r\np->parent = ds;\r\np->port = port;\r\np->phy = ds->slave_mii_bus->phy_map[port];\r\nret = register_netdev(slave_dev);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: error %d registering interface %s\n",\r\nmaster->name, ret, slave_dev->name);\r\nfree_netdev(slave_dev);\r\nreturn NULL;\r\n}\r\nnetif_carrier_off(slave_dev);\r\nif (p->phy != NULL) {\r\nphy_attach(slave_dev, dev_name(&p->phy->dev),\r\nPHY_INTERFACE_MODE_GMII);\r\np->phy->autoneg = AUTONEG_ENABLE;\r\np->phy->speed = 0;\r\np->phy->duplex = 0;\r\np->phy->advertising = p->phy->supported | ADVERTISED_Autoneg;\r\nphy_start_aneg(p->phy);\r\n}\r\nreturn slave_dev;\r\n}
