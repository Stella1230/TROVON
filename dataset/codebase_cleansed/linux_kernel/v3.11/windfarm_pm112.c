static int create_cpu_loop(int cpu)\r\n{\r\nint chip = cpu / 2;\r\nint core = cpu & 1;\r\nstruct smu_sdbp_header *hdr;\r\nstruct smu_sdbp_cpupiddata *piddata;\r\nstruct wf_cpu_pid_param pid;\r\nstruct wf_control *main_fan = cpu_fans[0];\r\ns32 tmax;\r\nint fmin;\r\nhdr = smu_sat_get_sdb_partition(chip, 0xC8 + core, NULL);\r\nif (hdr == NULL) {\r\nprintk(KERN_WARNING"windfarm: can't get CPU PID fan config\n");\r\nreturn -EINVAL;\r\n}\r\npiddata = (struct smu_sdbp_cpupiddata *)&hdr[1];\r\nhdr = smu_sat_get_sdb_partition(chip, 0xC4 + core, NULL);\r\nif (hdr) {\r\nstruct smu_sdbp_fvt *fvt = (struct smu_sdbp_fvt *)&hdr[1];\r\ntmax = fvt->maxtemp << 16;\r\n} else\r\ntmax = 95 << 16;\r\nif (tmax < cpu_all_tmax)\r\ncpu_all_tmax = tmax;\r\nfmin = (nr_cores > 2) ? 750 : 515;\r\npid.interval = 1;\r\npid.history_len = piddata->history_len;\r\npid.gd = piddata->gd;\r\npid.gp = piddata->gp;\r\npid.gr = piddata->gr / piddata->history_len;\r\npid.pmaxadj = (piddata->max_power << 16) - (piddata->power_adj << 8);\r\npid.ttarget = tmax - (piddata->target_temp_delta << 16);\r\npid.tmax = tmax;\r\npid.min = main_fan->ops->get_min(main_fan);\r\npid.max = main_fan->ops->get_max(main_fan);\r\nif (pid.min < fmin)\r\npid.min = fmin;\r\nwf_cpu_pid_init(&cpu_pid[cpu], &pid);\r\nreturn 0;\r\n}\r\nstatic void cpu_max_all_fans(void)\r\n{\r\nint i;\r\nif (cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nfor (i = 0; i < NR_CPU_FANS; ++i)\r\nif (cpu_fans[i])\r\nwf_control_set_max(cpu_fans[i]);\r\n}\r\nstatic int cpu_check_overtemp(s32 temp)\r\n{\r\nint new_state = 0;\r\ns32 t_avg, t_old;\r\nif (temp >= (cpu_all_tmax + LOW_OVER_IMMEDIATE)) {\r\nnew_state |= FAILURE_LOW_OVERTEMP;\r\nif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Overtemp due to immediate CPU"\r\n" temperature !\n");\r\n}\r\nif (temp >= (cpu_all_tmax + HIGH_OVER_IMMEDIATE)) {\r\nnew_state |= FAILURE_HIGH_OVERTEMP;\r\nif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Critical overtemp due to"\r\n" immediate CPU temperature !\n");\r\n}\r\nt_old = cpu_thist[cpu_thist_pt];\r\ncpu_thist[cpu_thist_pt] = temp;\r\ncpu_thist_pt = (cpu_thist_pt + 1) % CPU_TEMP_HIST_SIZE;\r\ncpu_thist_total -= t_old;\r\ncpu_thist_total += temp;\r\nt_avg = cpu_thist_total / CPU_TEMP_HIST_SIZE;\r\nDBG_LOTS("t_avg = %d.%03d (out: %d.%03d, in: %d.%03d)\n",\r\nFIX32TOPRINT(t_avg), FIX32TOPRINT(t_old), FIX32TOPRINT(temp));\r\nif (t_avg >= (cpu_all_tmax + LOW_OVER_AVERAGE)) {\r\nnew_state |= FAILURE_LOW_OVERTEMP;\r\nif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Overtemp due to average CPU"\r\n" temperature !\n");\r\n}\r\nif (t_avg >= (cpu_all_tmax + HIGH_OVER_AVERAGE)) {\r\nnew_state |= FAILURE_HIGH_OVERTEMP;\r\nif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Critical overtemp due to"\r\n" average CPU temperature !\n");\r\n}\r\nif (new_state) {\r\nif (new_state & FAILURE_HIGH_OVERTEMP)\r\nmachine_power_off();\r\nif ((failure_state & new_state) != new_state)\r\ncpu_max_all_fans();\r\nfailure_state |= new_state;\r\n} else if ((failure_state & FAILURE_LOW_OVERTEMP) &&\r\n(temp < (cpu_all_tmax + LOW_OVER_CLEAR))) {\r\nprintk(KERN_ERR "windfarm: Overtemp condition cleared !\n");\r\nfailure_state &= ~FAILURE_LOW_OVERTEMP;\r\n}\r\nreturn failure_state & (FAILURE_LOW_OVERTEMP | FAILURE_HIGH_OVERTEMP);\r\n}\r\nstatic void cpu_fans_tick(void)\r\n{\r\nint err, cpu;\r\ns32 greatest_delta = 0;\r\ns32 temp, power, t_max = 0;\r\nint i, t, target = 0;\r\nstruct wf_sensor *sr;\r\nstruct wf_control *ct;\r\nstruct wf_cpu_pid_state *sp;\r\nDBG_LOTS(KERN_DEBUG);\r\nfor (cpu = 0; cpu < nr_cores; ++cpu) {\r\nsr = sens_cpu_temp[cpu];\r\nerr = sr->ops->get_value(sr, &temp);\r\nif (err) {\r\nDBG("\n");\r\nprintk(KERN_WARNING "windfarm: CPU %d temperature "\r\n"sensor error %d\n", cpu, err);\r\nfailure_state |= FAILURE_SENSOR;\r\ncpu_max_all_fans();\r\nreturn;\r\n}\r\nt_max = max(t_max, temp);\r\nsr = sens_cpu_power[cpu];\r\nerr = sr->ops->get_value(sr, &power);\r\nif (err) {\r\nDBG("\n");\r\nprintk(KERN_WARNING "windfarm: CPU %d power "\r\n"sensor error %d\n", cpu, err);\r\nfailure_state |= FAILURE_SENSOR;\r\ncpu_max_all_fans();\r\nreturn;\r\n}\r\nsp = &cpu_pid[cpu];\r\nt = wf_cpu_pid_run(sp, power, temp);\r\nif (cpu == 0 || sp->last_delta > greatest_delta) {\r\ngreatest_delta = sp->last_delta;\r\ntarget = t;\r\n}\r\nDBG_LOTS("[%d] P=%d.%.3d T=%d.%.3d ",\r\ncpu, FIX32TOPRINT(power), FIX32TOPRINT(temp));\r\n}\r\nDBG_LOTS("fans = %d, t_max = %d.%03d\n", target, FIX32TOPRINT(t_max));\r\nif (target < (cpu_last_target - 20))\r\ntarget = cpu_last_target - 20;\r\ncpu_last_target = target;\r\nfor (cpu = 0; cpu < nr_cores; ++cpu)\r\ncpu_pid[cpu].target = target;\r\nif (cpu_check_overtemp(t_max))\r\nreturn;\r\nfor (i = 0; i < NR_CPU_FANS; ++i) {\r\nct = cpu_fans[i];\r\nif (ct == NULL)\r\ncontinue;\r\nerr = ct->ops->set_value(ct, target * cpu_fan_scale[i] / 100);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: fan %s reports "\r\n"error %d\n", ct->name, err);\r\nfailure_state |= FAILURE_FAN;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void backside_fan_tick(void)\r\n{\r\ns32 temp;\r\nint speed;\r\nint err;\r\nif (!backside_fan || !u4_temp)\r\nreturn;\r\nif (!backside_tick) {\r\nprintk(KERN_INFO "windfarm: Backside control loop started.\n");\r\nbackside_param.min = backside_fan->ops->get_min(backside_fan);\r\nbackside_param.max = backside_fan->ops->get_max(backside_fan);\r\nwf_pid_init(&backside_pid, &backside_param);\r\nbackside_tick = 1;\r\n}\r\nif (--backside_tick > 0)\r\nreturn;\r\nbackside_tick = backside_pid.param.interval;\r\nerr = u4_temp->ops->get_value(u4_temp, &temp);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: U4 temp sensor error %d\n",\r\nerr);\r\nfailure_state |= FAILURE_SENSOR;\r\nwf_control_set_max(backside_fan);\r\nreturn;\r\n}\r\nspeed = wf_pid_run(&backside_pid, temp);\r\nDBG_LOTS("backside PID temp=%d.%.3d speed=%d\n",\r\nFIX32TOPRINT(temp), speed);\r\nerr = backside_fan->ops->set_value(backside_fan, speed);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: backside fan error %d\n", err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\nstatic void drive_bay_fan_tick(void)\r\n{\r\ns32 temp;\r\nint speed;\r\nint err;\r\nif (!drive_bay_fan || !hd_temp)\r\nreturn;\r\nif (!drive_bay_tick) {\r\nprintk(KERN_INFO "windfarm: Drive bay control loop started.\n");\r\ndrive_bay_prm.min = drive_bay_fan->ops->get_min(drive_bay_fan);\r\ndrive_bay_prm.max = drive_bay_fan->ops->get_max(drive_bay_fan);\r\nwf_pid_init(&drive_bay_pid, &drive_bay_prm);\r\ndrive_bay_tick = 1;\r\n}\r\nif (--drive_bay_tick > 0)\r\nreturn;\r\ndrive_bay_tick = drive_bay_pid.param.interval;\r\nerr = hd_temp->ops->get_value(hd_temp, &temp);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: drive bay temp sensor "\r\n"error %d\n", err);\r\nfailure_state |= FAILURE_SENSOR;\r\nwf_control_set_max(drive_bay_fan);\r\nreturn;\r\n}\r\nspeed = wf_pid_run(&drive_bay_pid, temp);\r\nDBG_LOTS("drive_bay PID temp=%d.%.3d speed=%d\n",\r\nFIX32TOPRINT(temp), speed);\r\nerr = drive_bay_fan->ops->set_value(drive_bay_fan, speed);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: drive bay fan error %d\n", err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\nstatic void slots_fan_tick(void)\r\n{\r\ns32 power;\r\nint speed;\r\nint err;\r\nif (!slots_fan || !slots_power)\r\nreturn;\r\nif (!slots_started) {\r\nprintk(KERN_INFO "windfarm: Slots control loop started.\n");\r\nwf_pid_init(&slots_pid, &slots_param);\r\nslots_started = 1;\r\n}\r\nerr = slots_power->ops->get_value(slots_power, &power);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: slots power sensor error %d\n",\r\nerr);\r\nfailure_state |= FAILURE_SENSOR;\r\nwf_control_set_max(slots_fan);\r\nreturn;\r\n}\r\nspeed = wf_pid_run(&slots_pid, power);\r\nDBG_LOTS("slots PID power=%d.%.3d speed=%d\n",\r\nFIX32TOPRINT(power), speed);\r\nerr = slots_fan->ops->set_value(slots_fan, speed);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: slots fan error %d\n", err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\nstatic void set_fail_state(void)\r\n{\r\nint i;\r\nif (cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nfor (i = 0; i < NR_CPU_FANS; ++i)\r\nif (cpu_fans[i])\r\nwf_control_set_max(cpu_fans[i]);\r\nif (backside_fan)\r\nwf_control_set_max(backside_fan);\r\nif (slots_fan)\r\nwf_control_set_max(slots_fan);\r\nif (drive_bay_fan)\r\nwf_control_set_max(drive_bay_fan);\r\n}\r\nstatic void pm112_tick(void)\r\n{\r\nint i, last_failure;\r\nif (!started) {\r\nstarted = 1;\r\nprintk(KERN_INFO "windfarm: CPUs control loops started.\n");\r\nfor (i = 0; i < nr_cores; ++i) {\r\nif (create_cpu_loop(i) < 0) {\r\nfailure_state = FAILURE_PERM;\r\nset_fail_state();\r\nbreak;\r\n}\r\n}\r\nDBG_LOTS("cpu_all_tmax=%d.%03d\n", FIX32TOPRINT(cpu_all_tmax));\r\n#ifdef HACKED_OVERTEMP\r\ncpu_all_tmax = 60 << 16;\r\n#endif\r\n}\r\nif (failure_state & FAILURE_PERM)\r\nreturn;\r\nlast_failure = failure_state;\r\nfailure_state &= FAILURE_LOW_OVERTEMP;\r\ncpu_fans_tick();\r\nbackside_fan_tick();\r\nslots_fan_tick();\r\ndrive_bay_fan_tick();\r\nDBG_LOTS("last_failure: 0x%x, failure_state: %x\n",\r\nlast_failure, failure_state);\r\nif (failure_state && last_failure == 0 && cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nif (failure_state == 0 && last_failure && cpufreq_clamp)\r\nwf_control_set_min(cpufreq_clamp);\r\n}\r\nstatic void pm112_new_control(struct wf_control *ct)\r\n{\r\nint i, max_exhaust;\r\nif (cpufreq_clamp == NULL && !strcmp(ct->name, "cpufreq-clamp")) {\r\nif (wf_get_control(ct) == 0)\r\ncpufreq_clamp = ct;\r\n}\r\nfor (i = 0; i < NR_CPU_FANS; ++i) {\r\nif (!strcmp(ct->name, cpu_fan_names[i])) {\r\nif (cpu_fans[i] == NULL && wf_get_control(ct) == 0)\r\ncpu_fans[i] = ct;\r\nbreak;\r\n}\r\n}\r\nif (i >= NR_CPU_FANS) {\r\nif (!strcmp(ct->name, "backside-fan")) {\r\nif (backside_fan == NULL && wf_get_control(ct) == 0)\r\nbackside_fan = ct;\r\n} else if (!strcmp(ct->name, "slots-fan")) {\r\nif (slots_fan == NULL && wf_get_control(ct) == 0)\r\nslots_fan = ct;\r\n} else if (!strcmp(ct->name, "drive-bay-fan")) {\r\nif (drive_bay_fan == NULL && wf_get_control(ct) == 0)\r\ndrive_bay_fan = ct;\r\n}\r\nreturn;\r\n}\r\nfor (i = 0; i < CPU_FANS_REQD; ++i)\r\nif (cpu_fans[i] == NULL)\r\nreturn;\r\nmax_exhaust = cpu_fans[0]->ops->get_max(cpu_fans[0]);\r\nfor (i = FIRST_PUMP; i <= LAST_PUMP; ++i)\r\nif ((ct = cpu_fans[i]) != NULL)\r\ncpu_fan_scale[i] =\r\nct->ops->get_max(ct) * 100 / max_exhaust;\r\nhave_all_controls = 1;\r\n}\r\nstatic void pm112_new_sensor(struct wf_sensor *sr)\r\n{\r\nunsigned int i;\r\nif (!strncmp(sr->name, "cpu-temp-", 9)) {\r\ni = sr->name[9] - '0';\r\nif (sr->name[10] == 0 && i < NR_CORES &&\r\nsens_cpu_temp[i] == NULL && wf_get_sensor(sr) == 0)\r\nsens_cpu_temp[i] = sr;\r\n} else if (!strncmp(sr->name, "cpu-power-", 10)) {\r\ni = sr->name[10] - '0';\r\nif (sr->name[11] == 0 && i < NR_CORES &&\r\nsens_cpu_power[i] == NULL && wf_get_sensor(sr) == 0)\r\nsens_cpu_power[i] = sr;\r\n} else if (!strcmp(sr->name, "hd-temp")) {\r\nif (hd_temp == NULL && wf_get_sensor(sr) == 0)\r\nhd_temp = sr;\r\n} else if (!strcmp(sr->name, "slots-power")) {\r\nif (slots_power == NULL && wf_get_sensor(sr) == 0)\r\nslots_power = sr;\r\n} else if (!strcmp(sr->name, "backside-temp")) {\r\nif (u4_temp == NULL && wf_get_sensor(sr) == 0)\r\nu4_temp = sr;\r\n} else\r\nreturn;\r\nfor (i = 0; i < nr_cores; ++i)\r\nif (sens_cpu_temp[i] == NULL || sens_cpu_power[i] == NULL)\r\nreturn;\r\nhave_all_sensors = 1;\r\n}\r\nstatic int pm112_wf_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nswitch (event) {\r\ncase WF_EVENT_NEW_SENSOR:\r\npm112_new_sensor(data);\r\nbreak;\r\ncase WF_EVENT_NEW_CONTROL:\r\npm112_new_control(data);\r\nbreak;\r\ncase WF_EVENT_TICK:\r\nif (have_all_controls && have_all_sensors)\r\npm112_tick();\r\n}\r\nreturn 0;\r\n}\r\nstatic int wf_pm112_probe(struct platform_device *dev)\r\n{\r\nwf_register_client(&pm112_events);\r\nreturn 0;\r\n}\r\nstatic int wf_pm112_remove(struct platform_device *dev)\r\n{\r\nwf_unregister_client(&pm112_events);\r\nreturn 0;\r\n}\r\nstatic int __init wf_pm112_init(void)\r\n{\r\nstruct device_node *cpu;\r\nif (!of_machine_is_compatible("PowerMac11,2"))\r\nreturn -ENODEV;\r\nnr_cores = 0;\r\nfor_each_node_by_type(cpu, "cpu")\r\n++nr_cores;\r\nprintk(KERN_INFO "windfarm: initializing for dual-core desktop G5\n");\r\n#ifdef MODULE\r\nrequest_module("windfarm_smu_controls");\r\nrequest_module("windfarm_smu_sensors");\r\nrequest_module("windfarm_smu_sat");\r\nrequest_module("windfarm_lm75_sensor");\r\nrequest_module("windfarm_max6690_sensor");\r\nrequest_module("windfarm_cpufreq_clamp");\r\n#endif\r\nplatform_driver_register(&wf_pm112_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit wf_pm112_exit(void)\r\n{\r\nplatform_driver_unregister(&wf_pm112_driver);\r\n}
