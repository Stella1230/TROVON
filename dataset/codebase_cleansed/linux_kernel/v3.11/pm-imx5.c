static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)\r\n{\r\nu32 plat_lpc, arm_srpgcr, ccm_clpcr;\r\nu32 empgc0, empgc1;\r\nint stop_mode = 0;\r\nplat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &\r\n~(MXC_CORTEXA8_PLAT_LPC_DSM);\r\nccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);\r\narm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);\r\nempgc0 = __raw_readl(MXC_SRPG_EMPGC0_SRPGCR) & ~(MXC_SRPGCR_PCR);\r\nempgc1 = __raw_readl(MXC_SRPG_EMPGC1_SRPGCR) & ~(MXC_SRPGCR_PCR);\r\nswitch (mode) {\r\ncase WAIT_CLOCKED:\r\nbreak;\r\ncase WAIT_UNCLOCKED:\r\nccm_clpcr |= 0x1 << MXC_CCM_CLPCR_LPM_OFFSET;\r\nbreak;\r\ncase WAIT_UNCLOCKED_POWER_OFF:\r\ncase STOP_POWER_OFF:\r\nplat_lpc |= MXC_CORTEXA8_PLAT_LPC_DSM\r\n| MXC_CORTEXA8_PLAT_LPC_DBG_DSM;\r\nif (mode == WAIT_UNCLOCKED_POWER_OFF) {\r\nccm_clpcr |= 0x1 << MXC_CCM_CLPCR_LPM_OFFSET;\r\nccm_clpcr &= ~MXC_CCM_CLPCR_VSTBY;\r\nccm_clpcr &= ~MXC_CCM_CLPCR_SBYOS;\r\nstop_mode = 0;\r\n} else {\r\nccm_clpcr |= 0x2 << MXC_CCM_CLPCR_LPM_OFFSET;\r\nccm_clpcr |= 0x3 << MXC_CCM_CLPCR_STBY_COUNT_OFFSET;\r\nccm_clpcr |= MXC_CCM_CLPCR_VSTBY;\r\nccm_clpcr |= MXC_CCM_CLPCR_SBYOS;\r\nstop_mode = 1;\r\n}\r\narm_srpgcr |= MXC_SRPGCR_PCR;\r\nbreak;\r\ncase STOP_POWER_ON:\r\nccm_clpcr |= 0x2 << MXC_CCM_CLPCR_LPM_OFFSET;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "UNKNOWN cpu power mode: %d\n", mode);\r\nreturn;\r\n}\r\n__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);\r\n__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);\r\n__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);\r\n__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);\r\nif (stop_mode) {\r\nempgc0 |= MXC_SRPGCR_PCR;\r\nempgc1 |= MXC_SRPGCR_PCR;\r\n__raw_writel(empgc0, MXC_SRPG_EMPGC0_SRPGCR);\r\n__raw_writel(empgc1, MXC_SRPG_EMPGC1_SRPGCR);\r\n}\r\n}\r\nstatic int mx5_suspend_enter(suspend_state_t state)\r\n{\r\nswitch (state) {\r\ncase PM_SUSPEND_MEM:\r\nmx5_cpu_lp_set(STOP_POWER_OFF);\r\nbreak;\r\ncase PM_SUSPEND_STANDBY:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (state == PM_SUSPEND_MEM) {\r\nlocal_flush_tlb_all();\r\nflush_cache_all();\r\n__raw_writel(0, MXC_SRPG_EMPGC0_SRPGCR);\r\n__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);\r\n}\r\ncpu_do_idle();\r\nmx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);\r\nreturn 0;\r\n}\r\nstatic int mx5_pm_valid(suspend_state_t state)\r\n{\r\nreturn (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);\r\n}\r\nstatic inline int imx5_cpu_do_idle(void)\r\n{\r\nint ret = tzic_enable_wake();\r\nif (likely(!ret))\r\ncpu_do_idle();\r\nreturn ret;\r\n}\r\nstatic void imx5_pm_idle(void)\r\n{\r\nimx5_cpu_do_idle();\r\n}\r\nstatic int __init imx5_pm_common_init(void)\r\n{\r\nint ret;\r\nstruct clk *gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");\r\nif (IS_ERR(gpc_dvfs_clk))\r\nreturn PTR_ERR(gpc_dvfs_clk);\r\nret = clk_prepare_enable(gpc_dvfs_clk);\r\nif (ret)\r\nreturn ret;\r\narm_pm_idle = imx5_pm_idle;\r\nmx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);\r\nreturn imx5_cpuidle_init();\r\n}\r\nvoid __init imx51_pm_init(void)\r\n{\r\nint ret = imx5_pm_common_init();\r\nif (!ret)\r\nsuspend_set_ops(&mx5_suspend_ops);\r\n}\r\nvoid __init imx53_pm_init(void)\r\n{\r\nimx5_pm_common_init();\r\n}
